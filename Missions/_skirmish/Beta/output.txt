// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12715 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 66
 744: PUSH
 745: LD_EXP 66
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 66
 777: PUSH
 778: LD_EXP 66
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 52927 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12572 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12572 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 66
1974: PUSH
1975: LD_EXP 66
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18426 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18426 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18426 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18426 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18426 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 75815 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 75759 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 74818 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 75647 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 75329 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 75060 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 74679 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 74494 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 74386 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 75236 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 75441 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 75815 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 75759 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 74818 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 75647 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 75329 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 75060 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 74679 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 74494 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 74386 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 75236 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 75441 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 74542 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 74542 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 74542 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 74890 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 85
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 88
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 85
7660: PUSH
7661: LD_EXP 85
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 85
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 66
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 74542 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 74542 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 74542 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 75960 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 85
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 88
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 85
8875: PUSH
8876: LD_EXP 85
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 85
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 66
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18426 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18426 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18426 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18426 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18426 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18426 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11258: LD_VAR 0 1
11262: PUSH
11263: LD_EXP 9
11267: EQUAL
11268: IFFALSE 11284
// begin wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// YouLost ( Brighton ) ;
11277: LD_STRING Brighton
11279: PPUSH
11280: CALL_OW 104
// end ; if un = JMM then
11284: LD_VAR 0 1
11288: PUSH
11289: LD_EXP 37
11293: EQUAL
11294: IFFALSE 11310
// begin wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// YouLost ( JMM ) ;
11303: LD_STRING JMM
11305: PPUSH
11306: CALL_OW 104
// end ; if un = Megan then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 11
11319: EQUAL
11320: IFFALSE 11334
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11322: LD_EXP 9
11326: PPUSH
11327: LD_STRING DBrighton-MeganDeath
11329: PPUSH
11330: CALL_OW 88
// end ; if un = Palmer then
11334: LD_VAR 0 1
11338: PUSH
11339: LD_EXP 10
11343: EQUAL
11344: IFFALSE 11358
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11346: LD_EXP 9
11350: PPUSH
11351: LD_STRING DBrighton-PalmerDeath
11353: PPUSH
11354: CALL_OW 88
// end ; if un = Burlak then
11358: LD_VAR 0 1
11362: PUSH
11363: LD_EXP 19
11367: EQUAL
11368: IFFALSE 11400
// begin if JMM_Arrived then
11370: LD_EXP 6
11374: IFFALSE 11388
// Say ( JMM , DJMM-BurlakDead ) ;
11376: LD_EXP 37
11380: PPUSH
11381: LD_STRING DJMM-BurlakDead
11383: PPUSH
11384: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11388: LD_EXP 10
11392: PPUSH
11393: LD_STRING DSol-BurlakDead
11395: PPUSH
11396: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 1
11407: EQUAL
11408: PUSH
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 3
11416: EQUAL
11417: OR
11418: IFFALSE 11434
// begin wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// YouLost ( Depot ) ;
11427: LD_STRING Depot
11429: PPUSH
11430: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11434: LD_VAR 0 1
11438: PPUSH
11439: CALL_OW 255
11443: PUSH
11444: LD_INT 1
11446: EQUAL
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 247
11457: PUSH
11458: LD_INT 1
11460: EQUAL
11461: AND
11462: IFFALSE 11478
// Losses := Losses + 1 ;
11464: LD_ADDR_EXP 45
11468: PUSH
11469: LD_EXP 45
11473: PUSH
11474: LD_INT 1
11476: PLUS
11477: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL 77953 0 1
// end ;
11487: PPOPN 1
11489: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11490: LD_VAR 0 1
11494: PPUSH
11495: CALL_OW 247
11499: PUSH
11500: LD_INT 2
11502: EQUAL
11503: PUSH
11504: LD_VAR 0 1
11508: PUSH
11509: LD_EXP 17
11513: IN
11514: AND
11515: IFFALSE 11529
// SetLives ( un , 0 ) ;
11517: LD_VAR 0 1
11521: PPUSH
11522: LD_INT 0
11524: PPUSH
11525: CALL_OW 234
// if un = Yashin then
11529: LD_VAR 0 1
11533: PUSH
11534: LD_EXP 13
11538: EQUAL
11539: IFFALSE 11553
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11541: LD_EXP 13
11545: PPUSH
11546: LD_STRING DDeath-Yas-3
11548: PPUSH
11549: CALL_OW 91
// if un = Popov then
11553: LD_VAR 0 1
11557: PUSH
11558: LD_EXP 14
11562: EQUAL
11563: IFFALSE 11577
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11565: LD_EXP 14
11569: PPUSH
11570: LD_STRING DDeath-Pop-3
11572: PPUSH
11573: CALL_OW 91
// if un = Gaydar then
11577: LD_VAR 0 1
11581: PUSH
11582: LD_EXP 15
11586: EQUAL
11587: IFFALSE 11601
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11589: LD_EXP 15
11593: PPUSH
11594: LD_STRING DDeath-Gay-3
11596: PPUSH
11597: CALL_OW 91
// if un = Sevi then
11601: LD_VAR 0 1
11605: PUSH
11606: LD_EXP 16
11610: EQUAL
11611: IFFALSE 11625
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11613: LD_EXP 16
11617: PPUSH
11618: LD_STRING DDeath-Vse-3
11620: PPUSH
11621: CALL_OW 91
// end ;
11625: PPOPN 1
11627: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 10
11635: EQUAL
11636: IFFALSE 11674
// begin Say ( Brighton , DBrighton-C1 ) ;
11638: LD_EXP 9
11642: PPUSH
11643: LD_STRING DBrighton-C1
11645: PPUSH
11646: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11650: LD_EXP 11
11654: PPUSH
11655: LD_STRING DMegan-C1
11657: PPUSH
11658: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11662: LD_EXP 9
11666: PPUSH
11667: LD_STRING DBrighton-C2
11669: PPUSH
11670: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL 77649 0 2
// end ;
11688: PPOPN 2
11690: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL 80287 0 2
// end ;
11705: PPOPN 2
11707: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11708: LD_VAR 0 1
11712: PPUSH
11713: CALL 79355 0 1
// end ;
11717: PPOPN 1
11719: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11720: LD_VAR 0 1
11724: PPUSH
11725: CALL_OW 266
11729: PUSH
11730: LD_INT 0
11732: EQUAL
11733: PUSH
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 255
11743: PUSH
11744: LD_INT 3
11746: EQUAL
11747: AND
11748: IFFALSE 11810
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11750: LD_VAR 0 1
11754: PPUSH
11755: CALL_OW 274
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 10000
11765: PPUSH
11766: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11770: LD_VAR 0 1
11774: PPUSH
11775: CALL_OW 274
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 250
11785: PPUSH
11786: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 274
11799: PPUSH
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 100
11805: PPUSH
11806: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL 79596 0 1
// end ;
11819: PPOPN 1
11821: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11822: LD_VAR 0 1
11826: PPUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: LD_VAR 0 3
11836: PPUSH
11837: LD_VAR 0 4
11841: PPUSH
11842: LD_VAR 0 5
11846: PPUSH
11847: CALL 77269 0 5
// end ;
11851: PPOPN 5
11853: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11854: LD_VAR 0 1
11858: PPUSH
11859: LD_VAR 0 2
11863: PPUSH
11864: CALL 76859 0 2
// end ;
11868: PPOPN 2
11870: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11871: LD_VAR 0 1
11875: PPUSH
11876: LD_VAR 0 2
11880: PPUSH
11881: LD_VAR 0 3
11885: PPUSH
11886: LD_VAR 0 4
11890: PPUSH
11891: CALL 76697 0 4
// end ;
11895: PPOPN 4
11897: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11898: LD_VAR 0 1
11902: PPUSH
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: CALL 76472 0 3
// end ;
11917: PPOPN 3
11919: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11920: LD_VAR 0 1
11924: PPUSH
11925: LD_VAR 0 2
11929: PPUSH
11930: CALL 76357 0 2
// end ;
11934: PPOPN 2
11936: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11937: LD_VAR 0 1
11941: PPUSH
11942: LD_VAR 0 2
11946: PPUSH
11947: CALL 80548 0 2
// end ;
11951: PPOPN 2
11953: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11954: LD_VAR 0 1
11958: PPUSH
11959: CALL_OW 255
11963: PUSH
11964: LD_INT 6
11966: EQUAL
11967: IFFALSE 12097
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 13
11978: PUSH
11979: LD_EXP 16
11983: PUSH
11984: LD_EXP 15
11988: PUSH
11989: LD_EXP 14
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12121
// if AssaultStarted then
12004: LD_EXP 8
12008: IFFALSE 12082
// case Rand ( 1 , 4 ) of 1 .. 3 :
12010: LD_INT 1
12012: PPUSH
12013: LD_INT 4
12015: PPUSH
12016: CALL_OW 12
12020: PUSH
12021: LD_INT 1
12023: DOUBLE
12024: GREATEREQUAL
12025: IFFALSE 12033
12027: LD_INT 3
12029: DOUBLE
12030: LESSEQUAL
12031: IFTRUE 12035
12033: GO 12053
12035: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12036: LD_VAR 0 1
12040: PPUSH
12041: LD_INT 67
12043: PPUSH
12044: LD_INT 37
12046: PPUSH
12047: CALL_OW 114
12051: GO 12080
12053: LD_INT 4
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12061
12059: GO 12079
12061: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12062: LD_VAR 0 1
12066: PPUSH
12067: LD_INT 120
12069: PPUSH
12070: LD_INT 131
12072: PPUSH
12073: CALL_OW 111
12077: GO 12080
12079: POP
12080: GO 12097
// ComMoveXY ( driver , 120 , 131 ) ;
12082: LD_VAR 0 1
12086: PPUSH
12087: LD_INT 120
12089: PPUSH
12090: LD_INT 131
12092: PPUSH
12093: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12097: LD_VAR 0 1
12101: PPUSH
12102: LD_VAR 0 2
12106: PPUSH
12107: LD_VAR 0 3
12111: PPUSH
12112: LD_VAR 0 4
12116: PPUSH
12117: CALL 80764 0 4
// end ;
12121: PPOPN 4
12123: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 76166 0 2
// end ;
12138: PPOPN 2
12140: END
// on Command ( cmd ) do var i ;
12141: LD_INT 0
12143: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 77
12151: EQUAL
12152: PUSH
12153: LD_EXP 2
12157: AND
12158: IFFALSE 12234
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12160: LD_ADDR_VAR 0 2
12164: PUSH
12165: LD_INT 22
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: LD_INT 2
12177: PUSH
12178: LD_INT 21
12180: PUSH
12181: LD_INT 1
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: LD_INT 21
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: LIST
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PPUSH
12207: CALL_OW 69
12211: PUSH
12212: FOR_IN
12213: IFFALSE 12232
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12215: LD_VAR 0 2
12219: PPUSH
12220: LD_INT 20
12222: PPUSH
12223: LD_INT 19
12225: PPUSH
12226: CALL 50201 0 3
12230: GO 12212
12232: POP
12233: POP
// end ; SOS_Command ( cmd ) ;
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL 94178 0 1
// end ;
12243: PPOPN 2
12245: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12246: LD_EXP 2
12250: PUSH
12251: LD_INT 16
12253: PPUSH
12254: LD_INT 22
12256: PUSH
12257: LD_INT 1
12259: PUSH
12260: EMPTY
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 2
12266: PUSH
12267: LD_INT 21
12269: PUSH
12270: LD_INT 1
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PUSH
12277: LD_INT 21
12279: PUSH
12280: LD_INT 2
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: LIST
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PPUSH
12296: CALL_OW 70
12300: AND
12301: IFFALSE 12387
12303: GO 12305
12305: DISABLE
12306: LD_INT 0
12308: PPUSH
// begin enable ;
12309: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12310: LD_ADDR_VAR 0 1
12314: PUSH
12315: LD_INT 16
12317: PPUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 1
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 2
12330: PUSH
12331: LD_INT 21
12333: PUSH
12334: LD_INT 1
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: LD_INT 21
12343: PUSH
12344: LD_INT 2
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: LIST
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PPUSH
12360: CALL_OW 70
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12385
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12368: LD_VAR 0 1
12372: PPUSH
12373: LD_INT 18
12375: PPUSH
12376: LD_INT 19
12378: PPUSH
12379: CALL 50201 0 3
12383: GO 12365
12385: POP
12386: POP
// end ; end_of_file
12387: PPOPN 1
12389: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12390: LD_EXP 6
12394: PUSH
12395: LD_EXP 44
12399: AND
12400: IFFALSE 12571
12402: GO 12404
12404: DISABLE
// begin wait ( 0 0$2 ) ;
12405: LD_INT 70
12407: PPUSH
12408: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12412: LD_EXP 9
12416: PPUSH
12417: LD_STRING DBrighton-G1
12419: PPUSH
12420: CALL_OW 88
// if Losses < 1 then
12424: LD_EXP 45
12428: PUSH
12429: LD_INT 1
12431: LESS
12432: IFFALSE 12446
// AddMedal ( Losses , 1 ) else
12434: LD_STRING Losses
12436: PPUSH
12437: LD_INT 1
12439: PPUSH
12440: CALL_OW 101
12444: GO 12479
// if Losses < 5 then
12446: LD_EXP 45
12450: PUSH
12451: LD_INT 5
12453: LESS
12454: IFFALSE 12468
// AddMedal ( Losses , 2 ) else
12456: LD_STRING Losses
12458: PPUSH
12459: LD_INT 2
12461: PPUSH
12462: CALL_OW 101
12466: GO 12479
// AddMedal ( Losses , - 1 ) ;
12468: LD_STRING Losses
12470: PPUSH
12471: LD_INT 1
12473: NEG
12474: PPUSH
12475: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12479: LD_EXP 7
12483: PUSH
12484: LD_INT 10
12486: PPUSH
12487: LD_INT 1
12489: PPUSH
12490: CALL_OW 321
12494: PUSH
12495: LD_INT 2
12497: EQUAL
12498: AND
12499: IFFALSE 12513
// AddMedal ( Laser , 1 ) else
12501: LD_STRING Laser
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 101
12511: GO 12560
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12513: LD_EXP 7
12517: NOT
12518: PUSH
12519: LD_INT 10
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 321
12529: PUSH
12530: LD_INT 2
12532: EQUAL
12533: AND
12534: IFFALSE 12549
// AddMedal ( Laser , - 1 ) else
12536: LD_STRING Laser
12538: PPUSH
12539: LD_INT 1
12541: NEG
12542: PPUSH
12543: CALL_OW 101
12547: GO 12560
// AddMedal ( Laser , - 2 ) ;
12549: LD_STRING Laser
12551: PPUSH
12552: LD_INT 2
12554: NEG
12555: PPUSH
12556: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12560: LD_STRING BaseMain
12562: PPUSH
12563: CALL_OW 102
// YouWin ;
12567: CALL_OW 103
// end ; end_of_file
12571: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12572: LD_INT 0
12574: PPUSH
12575: PPUSH
// area = ListEnvironmentArea ( area ) ;
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 353
12590: ST_TO_ADDR
// if bulldozer > 0 then
12591: LD_VAR 0 1
12595: PUSH
12596: LD_INT 0
12598: GREATER
12599: IFFALSE 12710
// for i = area downto 1 do
12601: LD_ADDR_VAR 0 4
12605: PUSH
12606: DOUBLE
12607: LD_VAR 0 2
12611: INC
12612: ST_TO_ADDR
12613: LD_INT 1
12615: PUSH
12616: FOR_DOWNTO
12617: IFFALSE 12708
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12619: LD_VAR 0 2
12623: PUSH
12624: LD_VAR 0 4
12628: ARRAY
12629: PUSH
12630: LD_INT 1
12632: ARRAY
12633: PPUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_VAR 0 4
12643: ARRAY
12644: PUSH
12645: LD_INT 2
12647: ARRAY
12648: PPUSH
12649: CALL_OW 351
12653: IFFALSE 12706
// if not HasTask ( bulldozer ) then
12655: LD_VAR 0 1
12659: PPUSH
12660: CALL_OW 314
12664: NOT
12665: IFFALSE 12706
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12667: LD_VAR 0 1
12671: PPUSH
12672: LD_VAR 0 2
12676: PUSH
12677: LD_VAR 0 4
12681: ARRAY
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_VAR 0 2
12691: PUSH
12692: LD_VAR 0 4
12696: ARRAY
12697: PUSH
12698: LD_INT 2
12700: ARRAY
12701: PPUSH
12702: CALL_OW 171
12706: GO 12616
12708: POP
12709: POP
// end ;
12710: LD_VAR 0 3
12714: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12715: LD_INT 0
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12724: LD_ADDR_VAR 0 8
12728: PUSH
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_INT 22
12736: PUSH
12737: LD_INT 1
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 72
12773: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12774: LD_ADDR_VAR 0 9
12778: PUSH
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 1
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 1
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 72
12830: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12831: LD_ADDR_EXP 47
12835: PUSH
12836: LD_VAR 0 8
12840: PPUSH
12841: LD_VAR 0 9
12845: PPUSH
12846: CALL 13239 0 2
12850: ST_TO_ADDR
// offset = 0 ;
12851: LD_ADDR_VAR 0 7
12855: PUSH
12856: LD_INT 0
12858: ST_TO_ADDR
// for i := 1 to sold_team do
12859: LD_ADDR_VAR 0 4
12863: PUSH
12864: DOUBLE
12865: LD_INT 1
12867: DEC
12868: ST_TO_ADDR
12869: LD_VAR 0 8
12873: PUSH
12874: FOR_TO
12875: IFFALSE 13006
// begin if IsInUnit ( sold_team [ i ] ) then
12877: LD_VAR 0 8
12881: PUSH
12882: LD_VAR 0 4
12886: ARRAY
12887: PPUSH
12888: CALL_OW 310
12892: IFFALSE 12909
// ComExitBuilding ( sold_team [ i ] ) ;
12894: LD_VAR 0 8
12898: PUSH
12899: LD_VAR 0 4
12903: ARRAY
12904: PPUSH
12905: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12909: LD_VAR 0 8
12913: PUSH
12914: LD_VAR 0 4
12918: ARRAY
12919: PPUSH
12920: LD_EXP 47
12924: PUSH
12925: LD_INT 1
12927: ARRAY
12928: PUSH
12929: LD_VAR 0 4
12933: PUSH
12934: LD_VAR 0 7
12938: PLUS
12939: ARRAY
12940: PPUSH
12941: LD_EXP 47
12945: PUSH
12946: LD_INT 1
12948: ARRAY
12949: PUSH
12950: LD_VAR 0 4
12954: PUSH
12955: LD_INT 1
12957: PLUS
12958: PUSH
12959: LD_VAR 0 7
12963: PLUS
12964: ARRAY
12965: PPUSH
12966: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12970: LD_VAR 0 8
12974: PUSH
12975: LD_VAR 0 4
12979: ARRAY
12980: PPUSH
12981: LD_EXP 9
12985: PPUSH
12986: CALL_OW 179
// offset = offset + 1 ;
12990: LD_ADDR_VAR 0 7
12994: PUSH
12995: LD_VAR 0 7
12999: PUSH
13000: LD_INT 1
13002: PLUS
13003: ST_TO_ADDR
// end ;
13004: GO 12874
13006: POP
13007: POP
// offset = 0 ;
13008: LD_ADDR_VAR 0 7
13012: PUSH
13013: LD_INT 0
13015: ST_TO_ADDR
// tmp = 1 ;
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: LD_INT 1
13023: ST_TO_ADDR
// for i := 2 to rows do
13024: LD_ADDR_VAR 0 4
13028: PUSH
13029: DOUBLE
13030: LD_INT 2
13032: DEC
13033: ST_TO_ADDR
13034: LD_EXP 47
13038: PUSH
13039: FOR_TO
13040: IFFALSE 13232
// begin for x := 1 to sold_team do
13042: LD_ADDR_VAR 0 5
13046: PUSH
13047: DOUBLE
13048: LD_INT 1
13050: DEC
13051: ST_TO_ADDR
13052: LD_VAR 0 8
13056: PUSH
13057: FOR_TO
13058: IFFALSE 13220
// begin if IsInUnit ( civil_team [ tmp ] ) then
13060: LD_VAR 0 9
13064: PUSH
13065: LD_VAR 0 6
13069: ARRAY
13070: PPUSH
13071: CALL_OW 310
13075: IFFALSE 13092
// ComExitBuilding ( civil_team [ tmp ] ) ;
13077: LD_VAR 0 9
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PPUSH
13088: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13092: LD_VAR 0 9
13096: PUSH
13097: LD_VAR 0 6
13101: ARRAY
13102: PPUSH
13103: LD_EXP 47
13107: PUSH
13108: LD_VAR 0 4
13112: ARRAY
13113: PUSH
13114: LD_VAR 0 5
13118: PUSH
13119: LD_VAR 0 7
13123: PLUS
13124: ARRAY
13125: PPUSH
13126: LD_EXP 47
13130: PUSH
13131: LD_VAR 0 4
13135: ARRAY
13136: PUSH
13137: LD_VAR 0 5
13141: PUSH
13142: LD_INT 1
13144: PLUS
13145: PUSH
13146: LD_VAR 0 7
13150: PLUS
13151: ARRAY
13152: PPUSH
13153: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13157: LD_VAR 0 9
13161: PUSH
13162: LD_VAR 0 6
13166: ARRAY
13167: PPUSH
13168: LD_EXP 9
13172: PPUSH
13173: CALL_OW 179
// offset = offset + 1 ;
13177: LD_ADDR_VAR 0 7
13181: PUSH
13182: LD_VAR 0 7
13186: PUSH
13187: LD_INT 1
13189: PLUS
13190: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13191: LD_VAR 0 6
13195: PUSH
13196: LD_VAR 0 9
13200: EQUAL
13201: NOT
13202: IFFALSE 13218
// tmp = tmp + 1 ;
13204: LD_ADDR_VAR 0 6
13208: PUSH
13209: LD_VAR 0 6
13213: PUSH
13214: LD_INT 1
13216: PLUS
13217: ST_TO_ADDR
// end ;
13218: GO 13057
13220: POP
13221: POP
// offset = 0 ;
13222: LD_ADDR_VAR 0 7
13226: PUSH
13227: LD_INT 0
13229: ST_TO_ADDR
// end ;
13230: GO 13039
13232: POP
13233: POP
// end ;
13234: LD_VAR 0 3
13238: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13239: LD_INT 0
13241: PPUSH
13242: PPUSH
13243: PPUSH
13244: PPUSH
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
13250: PPUSH
// start_pos = [ 65 , 34 ] ;
13251: LD_ADDR_VAR 0 6
13255: PUSH
13256: LD_INT 65
13258: PUSH
13259: LD_INT 34
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: ST_TO_ADDR
// row_size = 0 ;
13266: LD_ADDR_VAR 0 7
13270: PUSH
13271: LD_INT 0
13273: ST_TO_ADDR
// result_rows = [ ] ;
13274: LD_ADDR_VAR 0 9
13278: PUSH
13279: EMPTY
13280: ST_TO_ADDR
// new_row = [ ] ;
13281: LD_ADDR_VAR 0 8
13285: PUSH
13286: EMPTY
13287: ST_TO_ADDR
// for i := 1 to sold_team do
13288: LD_ADDR_VAR 0 4
13292: PUSH
13293: DOUBLE
13294: LD_INT 1
13296: DEC
13297: ST_TO_ADDR
13298: LD_VAR 0 1
13302: PUSH
13303: FOR_TO
13304: IFFALSE 13358
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13306: LD_ADDR_VAR 0 8
13310: PUSH
13311: LD_VAR 0 8
13315: PUSH
13316: LD_VAR 0 6
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: ADD
13325: PUSH
13326: LD_VAR 0 6
13330: PUSH
13331: LD_INT 2
13333: ARRAY
13334: PUSH
13335: LD_VAR 0 4
13339: PLUS
13340: ADD
13341: ST_TO_ADDR
// row_size = row_size + 1 ;
13342: LD_ADDR_VAR 0 7
13346: PUSH
13347: LD_VAR 0 7
13351: PUSH
13352: LD_INT 1
13354: PLUS
13355: ST_TO_ADDR
// end ;
13356: GO 13303
13358: POP
13359: POP
// result_rows = result_rows ^ [ new_row ] ;
13360: LD_ADDR_VAR 0 9
13364: PUSH
13365: LD_VAR 0 9
13369: PUSH
13370: LD_VAR 0 8
13374: PUSH
13375: EMPTY
13376: LIST
13377: ADD
13378: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13379: LD_ADDR_VAR 0 10
13383: PUSH
13384: LD_VAR 0 2
13388: PUSH
13389: LD_VAR 0 1
13393: DIV
13394: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13395: LD_VAR 0 10
13399: PUSH
13400: LD_VAR 0 1
13404: MOD
13405: PUSH
13406: LD_INT 0
13408: GREATER
13409: IFFALSE 13425
// civil_rows = civil_rows + 1 ;
13411: LD_ADDR_VAR 0 10
13415: PUSH
13416: LD_VAR 0 10
13420: PUSH
13421: LD_INT 1
13423: PLUS
13424: ST_TO_ADDR
// offsetX = 2 ;
13425: LD_ADDR_VAR 0 11
13429: PUSH
13430: LD_INT 2
13432: ST_TO_ADDR
// offsetY = 1 ;
13433: LD_ADDR_VAR 0 12
13437: PUSH
13438: LD_INT 1
13440: ST_TO_ADDR
// for i := 1 to civil_rows do
13441: LD_ADDR_VAR 0 4
13445: PUSH
13446: DOUBLE
13447: LD_INT 1
13449: DEC
13450: ST_TO_ADDR
13451: LD_VAR 0 10
13455: PUSH
13456: FOR_TO
13457: IFFALSE 13585
// begin new_row = [ ] ;
13459: LD_ADDR_VAR 0 8
13463: PUSH
13464: EMPTY
13465: ST_TO_ADDR
// for x := 1 to row_size do
13466: LD_ADDR_VAR 0 5
13470: PUSH
13471: DOUBLE
13472: LD_INT 1
13474: DEC
13475: ST_TO_ADDR
13476: LD_VAR 0 7
13480: PUSH
13481: FOR_TO
13482: IFFALSE 13534
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13484: LD_ADDR_VAR 0 8
13488: PUSH
13489: LD_VAR 0 8
13493: PUSH
13494: LD_VAR 0 6
13498: PUSH
13499: LD_INT 1
13501: ARRAY
13502: PUSH
13503: LD_VAR 0 11
13507: PLUS
13508: ADD
13509: PUSH
13510: LD_VAR 0 6
13514: PUSH
13515: LD_INT 2
13517: ARRAY
13518: PUSH
13519: LD_VAR 0 12
13523: PLUS
13524: PUSH
13525: LD_VAR 0 5
13529: PLUS
13530: ADD
13531: ST_TO_ADDR
// end ;
13532: GO 13481
13534: POP
13535: POP
// result_rows = result_rows ^ [ new_row ] ;
13536: LD_ADDR_VAR 0 9
13540: PUSH
13541: LD_VAR 0 9
13545: PUSH
13546: LD_VAR 0 8
13550: PUSH
13551: EMPTY
13552: LIST
13553: ADD
13554: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13555: LD_ADDR_VAR 0 11
13559: PUSH
13560: LD_VAR 0 11
13564: PUSH
13565: LD_INT 2
13567: PLUS
13568: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13569: LD_ADDR_VAR 0 12
13573: PUSH
13574: LD_VAR 0 12
13578: PUSH
13579: LD_INT 1
13581: PLUS
13582: ST_TO_ADDR
// end ;
13583: GO 13456
13585: POP
13586: POP
// result = result_rows ;
13587: LD_ADDR_VAR 0 3
13591: PUSH
13592: LD_VAR 0 9
13596: ST_TO_ADDR
// end ; end_of_file
13597: LD_VAR 0 3
13601: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13602: LD_INT 0
13604: PPUSH
13605: PPUSH
// if exist_mode then
13606: LD_VAR 0 2
13610: IFFALSE 13635
// unit := CreateCharacter ( prefix & ident ) else
13612: LD_ADDR_VAR 0 5
13616: PUSH
13617: LD_VAR 0 3
13621: PUSH
13622: LD_VAR 0 1
13626: STR
13627: PPUSH
13628: CALL_OW 34
13632: ST_TO_ADDR
13633: GO 13650
// unit := NewCharacter ( ident ) ;
13635: LD_ADDR_VAR 0 5
13639: PUSH
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL_OW 25
13649: ST_TO_ADDR
// result := unit ;
13650: LD_ADDR_VAR 0 4
13654: PUSH
13655: LD_VAR 0 5
13659: ST_TO_ADDR
// end ;
13660: LD_VAR 0 4
13664: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13665: LD_INT 0
13667: PPUSH
13668: PPUSH
// if not side or not nation then
13669: LD_VAR 0 1
13673: NOT
13674: PUSH
13675: LD_VAR 0 2
13679: NOT
13680: OR
13681: IFFALSE 13685
// exit ;
13683: GO 14449
// case nation of nation_american :
13685: LD_VAR 0 2
13689: PUSH
13690: LD_INT 1
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13912
13698: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13699: LD_ADDR_VAR 0 4
13703: PUSH
13704: LD_INT 35
13706: PUSH
13707: LD_INT 45
13709: PUSH
13710: LD_INT 46
13712: PUSH
13713: LD_INT 47
13715: PUSH
13716: LD_INT 82
13718: PUSH
13719: LD_INT 83
13721: PUSH
13722: LD_INT 84
13724: PUSH
13725: LD_INT 85
13727: PUSH
13728: LD_INT 86
13730: PUSH
13731: LD_INT 1
13733: PUSH
13734: LD_INT 2
13736: PUSH
13737: LD_INT 6
13739: PUSH
13740: LD_INT 15
13742: PUSH
13743: LD_INT 16
13745: PUSH
13746: LD_INT 7
13748: PUSH
13749: LD_INT 12
13751: PUSH
13752: LD_INT 13
13754: PUSH
13755: LD_INT 10
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: LD_INT 20
13763: PUSH
13764: LD_INT 21
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: LD_INT 25
13772: PUSH
13773: LD_INT 32
13775: PUSH
13776: LD_INT 27
13778: PUSH
13779: LD_INT 36
13781: PUSH
13782: LD_INT 69
13784: PUSH
13785: LD_INT 39
13787: PUSH
13788: LD_INT 34
13790: PUSH
13791: LD_INT 40
13793: PUSH
13794: LD_INT 48
13796: PUSH
13797: LD_INT 49
13799: PUSH
13800: LD_INT 50
13802: PUSH
13803: LD_INT 51
13805: PUSH
13806: LD_INT 52
13808: PUSH
13809: LD_INT 53
13811: PUSH
13812: LD_INT 54
13814: PUSH
13815: LD_INT 55
13817: PUSH
13818: LD_INT 56
13820: PUSH
13821: LD_INT 57
13823: PUSH
13824: LD_INT 58
13826: PUSH
13827: LD_INT 59
13829: PUSH
13830: LD_INT 60
13832: PUSH
13833: LD_INT 61
13835: PUSH
13836: LD_INT 62
13838: PUSH
13839: LD_INT 80
13841: PUSH
13842: LD_INT 82
13844: PUSH
13845: LD_INT 83
13847: PUSH
13848: LD_INT 84
13850: PUSH
13851: LD_INT 85
13853: PUSH
13854: LD_INT 86
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: ST_TO_ADDR
13910: GO 14373
13912: LD_INT 2
13914: DOUBLE
13915: EQUAL
13916: IFTRUE 13920
13918: GO 14142
13920: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
13921: LD_ADDR_VAR 0 4
13925: PUSH
13926: LD_INT 35
13928: PUSH
13929: LD_INT 45
13931: PUSH
13932: LD_INT 46
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: LD_INT 82
13940: PUSH
13941: LD_INT 83
13943: PUSH
13944: LD_INT 84
13946: PUSH
13947: LD_INT 85
13949: PUSH
13950: LD_INT 87
13952: PUSH
13953: LD_INT 70
13955: PUSH
13956: LD_INT 1
13958: PUSH
13959: LD_INT 11
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 4
13967: PUSH
13968: LD_INT 5
13970: PUSH
13971: LD_INT 6
13973: PUSH
13974: LD_INT 15
13976: PUSH
13977: LD_INT 18
13979: PUSH
13980: LD_INT 7
13982: PUSH
13983: LD_INT 17
13985: PUSH
13986: LD_INT 8
13988: PUSH
13989: LD_INT 20
13991: PUSH
13992: LD_INT 21
13994: PUSH
13995: LD_INT 22
13997: PUSH
13998: LD_INT 72
14000: PUSH
14001: LD_INT 26
14003: PUSH
14004: LD_INT 69
14006: PUSH
14007: LD_INT 39
14009: PUSH
14010: LD_INT 40
14012: PUSH
14013: LD_INT 41
14015: PUSH
14016: LD_INT 42
14018: PUSH
14019: LD_INT 43
14021: PUSH
14022: LD_INT 48
14024: PUSH
14025: LD_INT 49
14027: PUSH
14028: LD_INT 50
14030: PUSH
14031: LD_INT 51
14033: PUSH
14034: LD_INT 52
14036: PUSH
14037: LD_INT 53
14039: PUSH
14040: LD_INT 54
14042: PUSH
14043: LD_INT 55
14045: PUSH
14046: LD_INT 56
14048: PUSH
14049: LD_INT 60
14051: PUSH
14052: LD_INT 61
14054: PUSH
14055: LD_INT 62
14057: PUSH
14058: LD_INT 66
14060: PUSH
14061: LD_INT 67
14063: PUSH
14064: LD_INT 68
14066: PUSH
14067: LD_INT 81
14069: PUSH
14070: LD_INT 82
14072: PUSH
14073: LD_INT 83
14075: PUSH
14076: LD_INT 84
14078: PUSH
14079: LD_INT 85
14081: PUSH
14082: LD_INT 87
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: ST_TO_ADDR
14140: GO 14373
14142: LD_INT 3
14144: DOUBLE
14145: EQUAL
14146: IFTRUE 14150
14148: GO 14372
14150: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14151: LD_ADDR_VAR 0 4
14155: PUSH
14156: LD_INT 46
14158: PUSH
14159: LD_INT 47
14161: PUSH
14162: LD_INT 1
14164: PUSH
14165: LD_INT 2
14167: PUSH
14168: LD_INT 82
14170: PUSH
14171: LD_INT 83
14173: PUSH
14174: LD_INT 84
14176: PUSH
14177: LD_INT 85
14179: PUSH
14180: LD_INT 86
14182: PUSH
14183: LD_INT 11
14185: PUSH
14186: LD_INT 9
14188: PUSH
14189: LD_INT 20
14191: PUSH
14192: LD_INT 19
14194: PUSH
14195: LD_INT 21
14197: PUSH
14198: LD_INT 24
14200: PUSH
14201: LD_INT 22
14203: PUSH
14204: LD_INT 25
14206: PUSH
14207: LD_INT 28
14209: PUSH
14210: LD_INT 29
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 31
14218: PUSH
14219: LD_INT 37
14221: PUSH
14222: LD_INT 38
14224: PUSH
14225: LD_INT 32
14227: PUSH
14228: LD_INT 27
14230: PUSH
14231: LD_INT 33
14233: PUSH
14234: LD_INT 69
14236: PUSH
14237: LD_INT 39
14239: PUSH
14240: LD_INT 34
14242: PUSH
14243: LD_INT 40
14245: PUSH
14246: LD_INT 71
14248: PUSH
14249: LD_INT 23
14251: PUSH
14252: LD_INT 44
14254: PUSH
14255: LD_INT 48
14257: PUSH
14258: LD_INT 49
14260: PUSH
14261: LD_INT 50
14263: PUSH
14264: LD_INT 51
14266: PUSH
14267: LD_INT 52
14269: PUSH
14270: LD_INT 53
14272: PUSH
14273: LD_INT 54
14275: PUSH
14276: LD_INT 55
14278: PUSH
14279: LD_INT 56
14281: PUSH
14282: LD_INT 57
14284: PUSH
14285: LD_INT 58
14287: PUSH
14288: LD_INT 59
14290: PUSH
14291: LD_INT 63
14293: PUSH
14294: LD_INT 64
14296: PUSH
14297: LD_INT 65
14299: PUSH
14300: LD_INT 82
14302: PUSH
14303: LD_INT 83
14305: PUSH
14306: LD_INT 84
14308: PUSH
14309: LD_INT 85
14311: PUSH
14312: LD_INT 86
14314: PUSH
14315: EMPTY
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: ST_TO_ADDR
14370: GO 14373
14372: POP
// if state > - 1 and state < 3 then
14373: LD_VAR 0 3
14377: PUSH
14378: LD_INT 1
14380: NEG
14381: GREATER
14382: PUSH
14383: LD_VAR 0 3
14387: PUSH
14388: LD_INT 3
14390: LESS
14391: AND
14392: IFFALSE 14449
// for i in result do
14394: LD_ADDR_VAR 0 5
14398: PUSH
14399: LD_VAR 0 4
14403: PUSH
14404: FOR_IN
14405: IFFALSE 14447
// if GetTech ( i , side ) <> state then
14407: LD_VAR 0 5
14411: PPUSH
14412: LD_VAR 0 1
14416: PPUSH
14417: CALL_OW 321
14421: PUSH
14422: LD_VAR 0 3
14426: NONEQUAL
14427: IFFALSE 14445
// result := result diff i ;
14429: LD_ADDR_VAR 0 4
14433: PUSH
14434: LD_VAR 0 4
14438: PUSH
14439: LD_VAR 0 5
14443: DIFF
14444: ST_TO_ADDR
14445: GO 14404
14447: POP
14448: POP
// end ;
14449: LD_VAR 0 4
14453: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14454: LD_INT 0
14456: PPUSH
14457: PPUSH
14458: PPUSH
// result := true ;
14459: LD_ADDR_VAR 0 3
14463: PUSH
14464: LD_INT 1
14466: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14467: LD_ADDR_VAR 0 5
14471: PUSH
14472: LD_VAR 0 2
14476: PPUSH
14477: CALL_OW 480
14481: ST_TO_ADDR
// if not tmp then
14482: LD_VAR 0 5
14486: NOT
14487: IFFALSE 14491
// exit ;
14489: GO 14540
// for i in tmp do
14491: LD_ADDR_VAR 0 4
14495: PUSH
14496: LD_VAR 0 5
14500: PUSH
14501: FOR_IN
14502: IFFALSE 14538
// if GetTech ( i , side ) <> state_researched then
14504: LD_VAR 0 4
14508: PPUSH
14509: LD_VAR 0 1
14513: PPUSH
14514: CALL_OW 321
14518: PUSH
14519: LD_INT 2
14521: NONEQUAL
14522: IFFALSE 14536
// begin result := false ;
14524: LD_ADDR_VAR 0 3
14528: PUSH
14529: LD_INT 0
14531: ST_TO_ADDR
// exit ;
14532: POP
14533: POP
14534: GO 14540
// end ;
14536: GO 14501
14538: POP
14539: POP
// end ;
14540: LD_VAR 0 3
14544: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14545: LD_INT 0
14547: PPUSH
14548: PPUSH
14549: PPUSH
14550: PPUSH
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14560: LD_VAR 0 1
14564: NOT
14565: PUSH
14566: LD_VAR 0 1
14570: PPUSH
14571: CALL_OW 257
14575: PUSH
14576: LD_INT 9
14578: NONEQUAL
14579: OR
14580: IFFALSE 14584
// exit ;
14582: GO 15157
// side := GetSide ( unit ) ;
14584: LD_ADDR_VAR 0 9
14588: PUSH
14589: LD_VAR 0 1
14593: PPUSH
14594: CALL_OW 255
14598: ST_TO_ADDR
// tech_space := tech_spacanom ;
14599: LD_ADDR_VAR 0 12
14603: PUSH
14604: LD_INT 29
14606: ST_TO_ADDR
// tech_time := tech_taurad ;
14607: LD_ADDR_VAR 0 13
14611: PUSH
14612: LD_INT 28
14614: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14615: LD_ADDR_VAR 0 11
14619: PUSH
14620: LD_VAR 0 1
14624: PPUSH
14625: CALL_OW 310
14629: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14630: LD_VAR 0 11
14634: PPUSH
14635: CALL_OW 247
14639: PUSH
14640: LD_INT 2
14642: EQUAL
14643: IFFALSE 14647
// exit ;
14645: GO 15157
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14647: LD_ADDR_VAR 0 8
14651: PUSH
14652: LD_INT 81
14654: PUSH
14655: LD_VAR 0 9
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PUSH
14664: LD_INT 3
14666: PUSH
14667: LD_INT 21
14669: PUSH
14670: LD_INT 3
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: ST_TO_ADDR
// if not tmp then
14690: LD_VAR 0 8
14694: NOT
14695: IFFALSE 14699
// exit ;
14697: GO 15157
// if in_unit then
14699: LD_VAR 0 11
14703: IFFALSE 14727
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14705: LD_ADDR_VAR 0 10
14709: PUSH
14710: LD_VAR 0 8
14714: PPUSH
14715: LD_VAR 0 11
14719: PPUSH
14720: CALL_OW 74
14724: ST_TO_ADDR
14725: GO 14747
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14727: LD_ADDR_VAR 0 10
14731: PUSH
14732: LD_VAR 0 8
14736: PPUSH
14737: LD_VAR 0 1
14741: PPUSH
14742: CALL_OW 74
14746: ST_TO_ADDR
// if not enemy then
14747: LD_VAR 0 10
14751: NOT
14752: IFFALSE 14756
// exit ;
14754: GO 15157
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14756: LD_VAR 0 11
14760: PUSH
14761: LD_VAR 0 11
14765: PPUSH
14766: LD_VAR 0 10
14770: PPUSH
14771: CALL_OW 296
14775: PUSH
14776: LD_INT 13
14778: GREATER
14779: AND
14780: PUSH
14781: LD_VAR 0 1
14785: PPUSH
14786: LD_VAR 0 10
14790: PPUSH
14791: CALL_OW 296
14795: PUSH
14796: LD_INT 12
14798: GREATER
14799: OR
14800: IFFALSE 14804
// exit ;
14802: GO 15157
// missile := [ 1 ] ;
14804: LD_ADDR_VAR 0 14
14808: PUSH
14809: LD_INT 1
14811: PUSH
14812: EMPTY
14813: LIST
14814: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14815: LD_VAR 0 9
14819: PPUSH
14820: LD_VAR 0 12
14824: PPUSH
14825: CALL_OW 325
14829: IFFALSE 14858
// missile := Insert ( missile , missile + 1 , 2 ) ;
14831: LD_ADDR_VAR 0 14
14835: PUSH
14836: LD_VAR 0 14
14840: PPUSH
14841: LD_VAR 0 14
14845: PUSH
14846: LD_INT 1
14848: PLUS
14849: PPUSH
14850: LD_INT 2
14852: PPUSH
14853: CALL_OW 2
14857: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14858: LD_VAR 0 9
14862: PPUSH
14863: LD_VAR 0 13
14867: PPUSH
14868: CALL_OW 325
14872: PUSH
14873: LD_VAR 0 10
14877: PPUSH
14878: CALL_OW 255
14882: PPUSH
14883: LD_VAR 0 13
14887: PPUSH
14888: CALL_OW 325
14892: NOT
14893: AND
14894: IFFALSE 14923
// missile := Insert ( missile , missile + 1 , 3 ) ;
14896: LD_ADDR_VAR 0 14
14900: PUSH
14901: LD_VAR 0 14
14905: PPUSH
14906: LD_VAR 0 14
14910: PUSH
14911: LD_INT 1
14913: PLUS
14914: PPUSH
14915: LD_INT 3
14917: PPUSH
14918: CALL_OW 2
14922: ST_TO_ADDR
// if missile < 2 then
14923: LD_VAR 0 14
14927: PUSH
14928: LD_INT 2
14930: LESS
14931: IFFALSE 14935
// exit ;
14933: GO 15157
// x := GetX ( enemy ) ;
14935: LD_ADDR_VAR 0 4
14939: PUSH
14940: LD_VAR 0 10
14944: PPUSH
14945: CALL_OW 250
14949: ST_TO_ADDR
// y := GetY ( enemy ) ;
14950: LD_ADDR_VAR 0 5
14954: PUSH
14955: LD_VAR 0 10
14959: PPUSH
14960: CALL_OW 251
14964: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14965: LD_ADDR_VAR 0 6
14969: PUSH
14970: LD_VAR 0 4
14974: PUSH
14975: LD_INT 1
14977: NEG
14978: PPUSH
14979: LD_INT 1
14981: PPUSH
14982: CALL_OW 12
14986: PLUS
14987: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14988: LD_ADDR_VAR 0 7
14992: PUSH
14993: LD_VAR 0 5
14997: PUSH
14998: LD_INT 1
15000: NEG
15001: PPUSH
15002: LD_INT 1
15004: PPUSH
15005: CALL_OW 12
15009: PLUS
15010: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15011: LD_VAR 0 6
15015: PPUSH
15016: LD_VAR 0 7
15020: PPUSH
15021: CALL_OW 488
15025: NOT
15026: IFFALSE 15048
// begin _x := x ;
15028: LD_ADDR_VAR 0 6
15032: PUSH
15033: LD_VAR 0 4
15037: ST_TO_ADDR
// _y := y ;
15038: LD_ADDR_VAR 0 7
15042: PUSH
15043: LD_VAR 0 5
15047: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15048: LD_ADDR_VAR 0 3
15052: PUSH
15053: LD_INT 1
15055: PPUSH
15056: LD_VAR 0 14
15060: PPUSH
15061: CALL_OW 12
15065: ST_TO_ADDR
// case i of 1 :
15066: LD_VAR 0 3
15070: PUSH
15071: LD_INT 1
15073: DOUBLE
15074: EQUAL
15075: IFTRUE 15079
15077: GO 15096
15079: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15080: LD_VAR 0 1
15084: PPUSH
15085: LD_VAR 0 10
15089: PPUSH
15090: CALL_OW 115
15094: GO 15157
15096: LD_INT 2
15098: DOUBLE
15099: EQUAL
15100: IFTRUE 15104
15102: GO 15126
15104: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15105: LD_VAR 0 1
15109: PPUSH
15110: LD_VAR 0 6
15114: PPUSH
15115: LD_VAR 0 7
15119: PPUSH
15120: CALL_OW 153
15124: GO 15157
15126: LD_INT 3
15128: DOUBLE
15129: EQUAL
15130: IFTRUE 15134
15132: GO 15156
15134: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15135: LD_VAR 0 1
15139: PPUSH
15140: LD_VAR 0 6
15144: PPUSH
15145: LD_VAR 0 7
15149: PPUSH
15150: CALL_OW 154
15154: GO 15157
15156: POP
// end ;
15157: LD_VAR 0 2
15161: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15162: LD_INT 0
15164: PPUSH
15165: PPUSH
15166: PPUSH
15167: PPUSH
15168: PPUSH
15169: PPUSH
// if not unit or not building then
15170: LD_VAR 0 1
15174: NOT
15175: PUSH
15176: LD_VAR 0 2
15180: NOT
15181: OR
15182: IFFALSE 15186
// exit ;
15184: GO 15344
// x := GetX ( building ) ;
15186: LD_ADDR_VAR 0 5
15190: PUSH
15191: LD_VAR 0 2
15195: PPUSH
15196: CALL_OW 250
15200: ST_TO_ADDR
// y := GetY ( building ) ;
15201: LD_ADDR_VAR 0 6
15205: PUSH
15206: LD_VAR 0 2
15210: PPUSH
15211: CALL_OW 251
15215: ST_TO_ADDR
// for i = 0 to 5 do
15216: LD_ADDR_VAR 0 4
15220: PUSH
15221: DOUBLE
15222: LD_INT 0
15224: DEC
15225: ST_TO_ADDR
15226: LD_INT 5
15228: PUSH
15229: FOR_TO
15230: IFFALSE 15342
// begin _x := ShiftX ( x , i , 3 ) ;
15232: LD_ADDR_VAR 0 7
15236: PUSH
15237: LD_VAR 0 5
15241: PPUSH
15242: LD_VAR 0 4
15246: PPUSH
15247: LD_INT 3
15249: PPUSH
15250: CALL_OW 272
15254: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15255: LD_ADDR_VAR 0 8
15259: PUSH
15260: LD_VAR 0 6
15264: PPUSH
15265: LD_VAR 0 4
15269: PPUSH
15270: LD_INT 3
15272: PPUSH
15273: CALL_OW 273
15277: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15278: LD_VAR 0 7
15282: PPUSH
15283: LD_VAR 0 8
15287: PPUSH
15288: CALL_OW 488
15292: NOT
15293: IFFALSE 15297
// continue ;
15295: GO 15229
// if HexInfo ( _x , _y ) = 0 then
15297: LD_VAR 0 7
15301: PPUSH
15302: LD_VAR 0 8
15306: PPUSH
15307: CALL_OW 428
15311: PUSH
15312: LD_INT 0
15314: EQUAL
15315: IFFALSE 15340
// begin ComMoveXY ( unit , _x , _y ) ;
15317: LD_VAR 0 1
15321: PPUSH
15322: LD_VAR 0 7
15326: PPUSH
15327: LD_VAR 0 8
15331: PPUSH
15332: CALL_OW 111
// exit ;
15336: POP
15337: POP
15338: GO 15344
// end ; end ;
15340: GO 15229
15342: POP
15343: POP
// end ;
15344: LD_VAR 0 3
15348: RET
// export function ScanBase ( side , base_area ) ; begin
15349: LD_INT 0
15351: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15352: LD_ADDR_VAR 0 3
15356: PUSH
15357: LD_VAR 0 2
15361: PPUSH
15362: LD_INT 81
15364: PUSH
15365: LD_VAR 0 1
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: PPUSH
15374: CALL_OW 70
15378: ST_TO_ADDR
// end ;
15379: LD_VAR 0 3
15383: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15384: LD_INT 0
15386: PPUSH
15387: PPUSH
15388: PPUSH
15389: PPUSH
// result := false ;
15390: LD_ADDR_VAR 0 2
15394: PUSH
15395: LD_INT 0
15397: ST_TO_ADDR
// side := GetSide ( unit ) ;
15398: LD_ADDR_VAR 0 3
15402: PUSH
15403: LD_VAR 0 1
15407: PPUSH
15408: CALL_OW 255
15412: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15413: LD_ADDR_VAR 0 4
15417: PUSH
15418: LD_VAR 0 1
15422: PPUSH
15423: CALL_OW 248
15427: ST_TO_ADDR
// case nat of 1 :
15428: LD_VAR 0 4
15432: PUSH
15433: LD_INT 1
15435: DOUBLE
15436: EQUAL
15437: IFTRUE 15441
15439: GO 15452
15441: POP
// tech := tech_lassight ; 2 :
15442: LD_ADDR_VAR 0 5
15446: PUSH
15447: LD_INT 12
15449: ST_TO_ADDR
15450: GO 15491
15452: LD_INT 2
15454: DOUBLE
15455: EQUAL
15456: IFTRUE 15460
15458: GO 15471
15460: POP
// tech := tech_mortar ; 3 :
15461: LD_ADDR_VAR 0 5
15465: PUSH
15466: LD_INT 41
15468: ST_TO_ADDR
15469: GO 15491
15471: LD_INT 3
15473: DOUBLE
15474: EQUAL
15475: IFTRUE 15479
15477: GO 15490
15479: POP
// tech := tech_bazooka ; end ;
15480: LD_ADDR_VAR 0 5
15484: PUSH
15485: LD_INT 44
15487: ST_TO_ADDR
15488: GO 15491
15490: POP
// if Researched ( side , tech ) then
15491: LD_VAR 0 3
15495: PPUSH
15496: LD_VAR 0 5
15500: PPUSH
15501: CALL_OW 325
15505: IFFALSE 15532
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15507: LD_ADDR_VAR 0 2
15511: PUSH
15512: LD_INT 5
15514: PUSH
15515: LD_INT 8
15517: PUSH
15518: LD_INT 9
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: PUSH
15526: LD_VAR 0 4
15530: ARRAY
15531: ST_TO_ADDR
// end ;
15532: LD_VAR 0 2
15536: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15537: LD_INT 0
15539: PPUSH
15540: PPUSH
15541: PPUSH
// if not mines then
15542: LD_VAR 0 2
15546: NOT
15547: IFFALSE 15551
// exit ;
15549: GO 15695
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15551: LD_ADDR_VAR 0 5
15555: PUSH
15556: LD_INT 81
15558: PUSH
15559: LD_VAR 0 1
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: PUSH
15568: LD_INT 3
15570: PUSH
15571: LD_INT 21
15573: PUSH
15574: LD_INT 3
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PPUSH
15589: CALL_OW 69
15593: ST_TO_ADDR
// for i in mines do
15594: LD_ADDR_VAR 0 4
15598: PUSH
15599: LD_VAR 0 2
15603: PUSH
15604: FOR_IN
15605: IFFALSE 15693
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15607: LD_VAR 0 4
15611: PUSH
15612: LD_INT 1
15614: ARRAY
15615: PPUSH
15616: LD_VAR 0 4
15620: PUSH
15621: LD_INT 2
15623: ARRAY
15624: PPUSH
15625: CALL_OW 458
15629: NOT
15630: IFFALSE 15634
// continue ;
15632: GO 15604
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15634: LD_VAR 0 4
15638: PUSH
15639: LD_INT 1
15641: ARRAY
15642: PPUSH
15643: LD_VAR 0 4
15647: PUSH
15648: LD_INT 2
15650: ARRAY
15651: PPUSH
15652: CALL_OW 428
15656: PUSH
15657: LD_VAR 0 5
15661: IN
15662: IFFALSE 15691
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15664: LD_VAR 0 4
15668: PUSH
15669: LD_INT 1
15671: ARRAY
15672: PPUSH
15673: LD_VAR 0 4
15677: PUSH
15678: LD_INT 2
15680: ARRAY
15681: PPUSH
15682: LD_VAR 0 1
15686: PPUSH
15687: CALL_OW 456
// end ;
15691: GO 15604
15693: POP
15694: POP
// end ;
15695: LD_VAR 0 3
15699: RET
// export function Count ( array ) ; var i ; begin
15700: LD_INT 0
15702: PPUSH
15703: PPUSH
// result := 0 ;
15704: LD_ADDR_VAR 0 2
15708: PUSH
15709: LD_INT 0
15711: ST_TO_ADDR
// for i in array do
15712: LD_ADDR_VAR 0 3
15716: PUSH
15717: LD_VAR 0 1
15721: PUSH
15722: FOR_IN
15723: IFFALSE 15747
// if i then
15725: LD_VAR 0 3
15729: IFFALSE 15745
// result := result + 1 ;
15731: LD_ADDR_VAR 0 2
15735: PUSH
15736: LD_VAR 0 2
15740: PUSH
15741: LD_INT 1
15743: PLUS
15744: ST_TO_ADDR
15745: GO 15722
15747: POP
15748: POP
// end ;
15749: LD_VAR 0 2
15753: RET
// export function IsEmpty ( building ) ; begin
15754: LD_INT 0
15756: PPUSH
// if not building then
15757: LD_VAR 0 1
15761: NOT
15762: IFFALSE 15766
// exit ;
15764: GO 15809
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15766: LD_ADDR_VAR 0 2
15770: PUSH
15771: LD_VAR 0 1
15775: PUSH
15776: LD_INT 22
15778: PUSH
15779: LD_VAR 0 1
15783: PPUSH
15784: CALL_OW 255
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: PUSH
15793: LD_INT 58
15795: PUSH
15796: EMPTY
15797: LIST
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PPUSH
15803: CALL_OW 69
15807: IN
15808: ST_TO_ADDR
// end ;
15809: LD_VAR 0 2
15813: RET
// export function IsNotFull ( building ) ; begin
15814: LD_INT 0
15816: PPUSH
// if not building then
15817: LD_VAR 0 1
15821: NOT
15822: IFFALSE 15826
// exit ;
15824: GO 15845
// result := UnitsInside ( building ) < 6 ;
15826: LD_ADDR_VAR 0 2
15830: PUSH
15831: LD_VAR 0 1
15835: PPUSH
15836: CALL_OW 313
15840: PUSH
15841: LD_INT 6
15843: LESS
15844: ST_TO_ADDR
// end ;
15845: LD_VAR 0 2
15849: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15850: LD_INT 0
15852: PPUSH
15853: PPUSH
15854: PPUSH
15855: PPUSH
// tmp := [ ] ;
15856: LD_ADDR_VAR 0 3
15860: PUSH
15861: EMPTY
15862: ST_TO_ADDR
// list := [ ] ;
15863: LD_ADDR_VAR 0 5
15867: PUSH
15868: EMPTY
15869: ST_TO_ADDR
// for i = 16 to 25 do
15870: LD_ADDR_VAR 0 4
15874: PUSH
15875: DOUBLE
15876: LD_INT 16
15878: DEC
15879: ST_TO_ADDR
15880: LD_INT 25
15882: PUSH
15883: FOR_TO
15884: IFFALSE 15957
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15886: LD_ADDR_VAR 0 3
15890: PUSH
15891: LD_VAR 0 3
15895: PUSH
15896: LD_INT 22
15898: PUSH
15899: LD_VAR 0 1
15903: PPUSH
15904: CALL_OW 255
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 91
15915: PUSH
15916: LD_VAR 0 1
15920: PUSH
15921: LD_INT 6
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: LIST
15928: PUSH
15929: LD_INT 30
15931: PUSH
15932: LD_VAR 0 4
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: LIST
15945: PUSH
15946: EMPTY
15947: LIST
15948: PPUSH
15949: CALL_OW 69
15953: ADD
15954: ST_TO_ADDR
15955: GO 15883
15957: POP
15958: POP
// for i = 1 to tmp do
15959: LD_ADDR_VAR 0 4
15963: PUSH
15964: DOUBLE
15965: LD_INT 1
15967: DEC
15968: ST_TO_ADDR
15969: LD_VAR 0 3
15973: PUSH
15974: FOR_TO
15975: IFFALSE 16063
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15977: LD_ADDR_VAR 0 5
15981: PUSH
15982: LD_VAR 0 5
15986: PUSH
15987: LD_VAR 0 3
15991: PUSH
15992: LD_VAR 0 4
15996: ARRAY
15997: PPUSH
15998: CALL_OW 266
16002: PUSH
16003: LD_VAR 0 3
16007: PUSH
16008: LD_VAR 0 4
16012: ARRAY
16013: PPUSH
16014: CALL_OW 250
16018: PUSH
16019: LD_VAR 0 3
16023: PUSH
16024: LD_VAR 0 4
16028: ARRAY
16029: PPUSH
16030: CALL_OW 251
16034: PUSH
16035: LD_VAR 0 3
16039: PUSH
16040: LD_VAR 0 4
16044: ARRAY
16045: PPUSH
16046: CALL_OW 254
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: PUSH
16057: EMPTY
16058: LIST
16059: ADD
16060: ST_TO_ADDR
16061: GO 15974
16063: POP
16064: POP
// result := list ;
16065: LD_ADDR_VAR 0 2
16069: PUSH
16070: LD_VAR 0 5
16074: ST_TO_ADDR
// end ;
16075: LD_VAR 0 2
16079: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16080: LD_INT 0
16082: PPUSH
16083: PPUSH
16084: PPUSH
16085: PPUSH
16086: PPUSH
16087: PPUSH
16088: PPUSH
// if not factory then
16089: LD_VAR 0 1
16093: NOT
16094: IFFALSE 16098
// exit ;
16096: GO 16691
// if control = control_apeman then
16098: LD_VAR 0 4
16102: PUSH
16103: LD_INT 5
16105: EQUAL
16106: IFFALSE 16215
// begin tmp := UnitsInside ( factory ) ;
16108: LD_ADDR_VAR 0 8
16112: PUSH
16113: LD_VAR 0 1
16117: PPUSH
16118: CALL_OW 313
16122: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16123: LD_VAR 0 8
16127: PPUSH
16128: LD_INT 25
16130: PUSH
16131: LD_INT 12
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PPUSH
16138: CALL_OW 72
16142: NOT
16143: IFFALSE 16153
// control := control_manual ;
16145: LD_ADDR_VAR 0 4
16149: PUSH
16150: LD_INT 1
16152: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16153: LD_ADDR_VAR 0 8
16157: PUSH
16158: LD_VAR 0 1
16162: PPUSH
16163: CALL 15850 0 1
16167: ST_TO_ADDR
// if tmp then
16168: LD_VAR 0 8
16172: IFFALSE 16215
// begin for i in tmp do
16174: LD_ADDR_VAR 0 7
16178: PUSH
16179: LD_VAR 0 8
16183: PUSH
16184: FOR_IN
16185: IFFALSE 16213
// if i [ 1 ] = b_ext_radio then
16187: LD_VAR 0 7
16191: PUSH
16192: LD_INT 1
16194: ARRAY
16195: PUSH
16196: LD_INT 22
16198: EQUAL
16199: IFFALSE 16211
// begin control := control_remote ;
16201: LD_ADDR_VAR 0 4
16205: PUSH
16206: LD_INT 2
16208: ST_TO_ADDR
// break ;
16209: GO 16213
// end ;
16211: GO 16184
16213: POP
16214: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16215: LD_VAR 0 1
16219: PPUSH
16220: LD_VAR 0 2
16224: PPUSH
16225: LD_VAR 0 3
16229: PPUSH
16230: LD_VAR 0 4
16234: PPUSH
16235: LD_VAR 0 5
16239: PPUSH
16240: CALL_OW 448
16244: IFFALSE 16279
// begin result := [ chassis , engine , control , weapon ] ;
16246: LD_ADDR_VAR 0 6
16250: PUSH
16251: LD_VAR 0 2
16255: PUSH
16256: LD_VAR 0 3
16260: PUSH
16261: LD_VAR 0 4
16265: PUSH
16266: LD_VAR 0 5
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: LIST
16275: LIST
16276: ST_TO_ADDR
// exit ;
16277: GO 16691
// end ; _chassis := AvailableChassisList ( factory ) ;
16279: LD_ADDR_VAR 0 9
16283: PUSH
16284: LD_VAR 0 1
16288: PPUSH
16289: CALL_OW 475
16293: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16294: LD_ADDR_VAR 0 11
16298: PUSH
16299: LD_VAR 0 1
16303: PPUSH
16304: CALL_OW 476
16308: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16309: LD_ADDR_VAR 0 12
16313: PUSH
16314: LD_VAR 0 1
16318: PPUSH
16319: CALL_OW 477
16323: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16324: LD_ADDR_VAR 0 10
16328: PUSH
16329: LD_VAR 0 1
16333: PPUSH
16334: CALL_OW 478
16338: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16339: LD_VAR 0 9
16343: NOT
16344: PUSH
16345: LD_VAR 0 11
16349: NOT
16350: OR
16351: PUSH
16352: LD_VAR 0 12
16356: NOT
16357: OR
16358: PUSH
16359: LD_VAR 0 10
16363: NOT
16364: OR
16365: IFFALSE 16400
// begin result := [ chassis , engine , control , weapon ] ;
16367: LD_ADDR_VAR 0 6
16371: PUSH
16372: LD_VAR 0 2
16376: PUSH
16377: LD_VAR 0 3
16381: PUSH
16382: LD_VAR 0 4
16386: PUSH
16387: LD_VAR 0 5
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: LIST
16396: LIST
16397: ST_TO_ADDR
// exit ;
16398: GO 16691
// end ; if not chassis in _chassis then
16400: LD_VAR 0 2
16404: PUSH
16405: LD_VAR 0 9
16409: IN
16410: NOT
16411: IFFALSE 16437
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16413: LD_ADDR_VAR 0 2
16417: PUSH
16418: LD_VAR 0 9
16422: PUSH
16423: LD_INT 1
16425: PPUSH
16426: LD_VAR 0 9
16430: PPUSH
16431: CALL_OW 12
16435: ARRAY
16436: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16437: LD_VAR 0 2
16441: PPUSH
16442: LD_VAR 0 3
16446: PPUSH
16447: CALL 16696 0 2
16451: NOT
16452: IFFALSE 16511
// repeat engine := _engine [ 1 ] ;
16454: LD_ADDR_VAR 0 3
16458: PUSH
16459: LD_VAR 0 11
16463: PUSH
16464: LD_INT 1
16466: ARRAY
16467: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16468: LD_ADDR_VAR 0 11
16472: PUSH
16473: LD_VAR 0 11
16477: PPUSH
16478: LD_INT 1
16480: PPUSH
16481: CALL_OW 3
16485: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16486: LD_VAR 0 2
16490: PPUSH
16491: LD_VAR 0 3
16495: PPUSH
16496: CALL 16696 0 2
16500: PUSH
16501: LD_VAR 0 11
16505: PUSH
16506: EMPTY
16507: EQUAL
16508: OR
16509: IFFALSE 16454
// if not control in _control then
16511: LD_VAR 0 4
16515: PUSH
16516: LD_VAR 0 12
16520: IN
16521: NOT
16522: IFFALSE 16548
// control := _control [ rand ( 1 , _control ) ] ;
16524: LD_ADDR_VAR 0 4
16528: PUSH
16529: LD_VAR 0 12
16533: PUSH
16534: LD_INT 1
16536: PPUSH
16537: LD_VAR 0 12
16541: PPUSH
16542: CALL_OW 12
16546: ARRAY
16547: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16548: LD_VAR 0 2
16552: PPUSH
16553: LD_VAR 0 5
16557: PPUSH
16558: CALL 16916 0 2
16562: NOT
16563: IFFALSE 16622
// repeat weapon := _weapon [ 1 ] ;
16565: LD_ADDR_VAR 0 5
16569: PUSH
16570: LD_VAR 0 10
16574: PUSH
16575: LD_INT 1
16577: ARRAY
16578: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16579: LD_ADDR_VAR 0 10
16583: PUSH
16584: LD_VAR 0 10
16588: PPUSH
16589: LD_INT 1
16591: PPUSH
16592: CALL_OW 3
16596: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16597: LD_VAR 0 2
16601: PPUSH
16602: LD_VAR 0 5
16606: PPUSH
16607: CALL 16916 0 2
16611: PUSH
16612: LD_VAR 0 10
16616: PUSH
16617: EMPTY
16618: EQUAL
16619: OR
16620: IFFALSE 16565
// result := [ ] ;
16622: LD_ADDR_VAR 0 6
16626: PUSH
16627: EMPTY
16628: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16629: LD_VAR 0 1
16633: PPUSH
16634: LD_VAR 0 2
16638: PPUSH
16639: LD_VAR 0 3
16643: PPUSH
16644: LD_VAR 0 4
16648: PPUSH
16649: LD_VAR 0 5
16653: PPUSH
16654: CALL_OW 448
16658: IFFALSE 16691
// result := [ chassis , engine , control , weapon ] ;
16660: LD_ADDR_VAR 0 6
16664: PUSH
16665: LD_VAR 0 2
16669: PUSH
16670: LD_VAR 0 3
16674: PUSH
16675: LD_VAR 0 4
16679: PUSH
16680: LD_VAR 0 5
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: LIST
16689: LIST
16690: ST_TO_ADDR
// end ;
16691: LD_VAR 0 6
16695: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16696: LD_INT 0
16698: PPUSH
// if not chassis or not engine then
16699: LD_VAR 0 1
16703: NOT
16704: PUSH
16705: LD_VAR 0 2
16709: NOT
16710: OR
16711: IFFALSE 16715
// exit ;
16713: GO 16911
// case engine of engine_solar :
16715: LD_VAR 0 2
16719: PUSH
16720: LD_INT 2
16722: DOUBLE
16723: EQUAL
16724: IFTRUE 16728
16726: GO 16766
16728: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16729: LD_ADDR_VAR 0 3
16733: PUSH
16734: LD_INT 11
16736: PUSH
16737: LD_INT 12
16739: PUSH
16740: LD_INT 13
16742: PUSH
16743: LD_INT 14
16745: PUSH
16746: LD_INT 1
16748: PUSH
16749: LD_INT 2
16751: PUSH
16752: LD_INT 3
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: ST_TO_ADDR
16764: GO 16895
16766: LD_INT 1
16768: DOUBLE
16769: EQUAL
16770: IFTRUE 16774
16772: GO 16836
16774: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16775: LD_ADDR_VAR 0 3
16779: PUSH
16780: LD_INT 11
16782: PUSH
16783: LD_INT 12
16785: PUSH
16786: LD_INT 13
16788: PUSH
16789: LD_INT 14
16791: PUSH
16792: LD_INT 1
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 3
16800: PUSH
16801: LD_INT 4
16803: PUSH
16804: LD_INT 5
16806: PUSH
16807: LD_INT 21
16809: PUSH
16810: LD_INT 23
16812: PUSH
16813: LD_INT 22
16815: PUSH
16816: LD_INT 24
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: ST_TO_ADDR
16834: GO 16895
16836: LD_INT 3
16838: DOUBLE
16839: EQUAL
16840: IFTRUE 16844
16842: GO 16894
16844: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16845: LD_ADDR_VAR 0 3
16849: PUSH
16850: LD_INT 13
16852: PUSH
16853: LD_INT 14
16855: PUSH
16856: LD_INT 2
16858: PUSH
16859: LD_INT 3
16861: PUSH
16862: LD_INT 4
16864: PUSH
16865: LD_INT 5
16867: PUSH
16868: LD_INT 21
16870: PUSH
16871: LD_INT 22
16873: PUSH
16874: LD_INT 23
16876: PUSH
16877: LD_INT 24
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: LIST
16884: LIST
16885: LIST
16886: LIST
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: ST_TO_ADDR
16892: GO 16895
16894: POP
// result := ( chassis in result ) ;
16895: LD_ADDR_VAR 0 3
16899: PUSH
16900: LD_VAR 0 1
16904: PUSH
16905: LD_VAR 0 3
16909: IN
16910: ST_TO_ADDR
// end ;
16911: LD_VAR 0 3
16915: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16916: LD_INT 0
16918: PPUSH
// if not chassis or not weapon then
16919: LD_VAR 0 1
16923: NOT
16924: PUSH
16925: LD_VAR 0 2
16929: NOT
16930: OR
16931: IFFALSE 16935
// exit ;
16933: GO 17961
// case weapon of us_machine_gun :
16935: LD_VAR 0 2
16939: PUSH
16940: LD_INT 2
16942: DOUBLE
16943: EQUAL
16944: IFTRUE 16948
16946: GO 16978
16948: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16949: LD_ADDR_VAR 0 3
16953: PUSH
16954: LD_INT 1
16956: PUSH
16957: LD_INT 2
16959: PUSH
16960: LD_INT 3
16962: PUSH
16963: LD_INT 4
16965: PUSH
16966: LD_INT 5
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: ST_TO_ADDR
16976: GO 17945
16978: LD_INT 3
16980: DOUBLE
16981: EQUAL
16982: IFTRUE 16986
16984: GO 17016
16986: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16987: LD_ADDR_VAR 0 3
16991: PUSH
16992: LD_INT 1
16994: PUSH
16995: LD_INT 2
16997: PUSH
16998: LD_INT 3
17000: PUSH
17001: LD_INT 4
17003: PUSH
17004: LD_INT 5
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: ST_TO_ADDR
17014: GO 17945
17016: LD_INT 11
17018: DOUBLE
17019: EQUAL
17020: IFTRUE 17024
17022: GO 17054
17024: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17025: LD_ADDR_VAR 0 3
17029: PUSH
17030: LD_INT 1
17032: PUSH
17033: LD_INT 2
17035: PUSH
17036: LD_INT 3
17038: PUSH
17039: LD_INT 4
17041: PUSH
17042: LD_INT 5
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: LIST
17050: LIST
17051: ST_TO_ADDR
17052: GO 17945
17054: LD_INT 4
17056: DOUBLE
17057: EQUAL
17058: IFTRUE 17062
17060: GO 17088
17062: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17063: LD_ADDR_VAR 0 3
17067: PUSH
17068: LD_INT 2
17070: PUSH
17071: LD_INT 3
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: LD_INT 5
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: ST_TO_ADDR
17086: GO 17945
17088: LD_INT 5
17090: DOUBLE
17091: EQUAL
17092: IFTRUE 17096
17094: GO 17122
17096: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17097: LD_ADDR_VAR 0 3
17101: PUSH
17102: LD_INT 2
17104: PUSH
17105: LD_INT 3
17107: PUSH
17108: LD_INT 4
17110: PUSH
17111: LD_INT 5
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: ST_TO_ADDR
17120: GO 17945
17122: LD_INT 9
17124: DOUBLE
17125: EQUAL
17126: IFTRUE 17130
17128: GO 17156
17130: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17131: LD_ADDR_VAR 0 3
17135: PUSH
17136: LD_INT 2
17138: PUSH
17139: LD_INT 3
17141: PUSH
17142: LD_INT 4
17144: PUSH
17145: LD_INT 5
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: LIST
17152: LIST
17153: ST_TO_ADDR
17154: GO 17945
17156: LD_INT 7
17158: DOUBLE
17159: EQUAL
17160: IFTRUE 17164
17162: GO 17190
17164: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17165: LD_ADDR_VAR 0 3
17169: PUSH
17170: LD_INT 2
17172: PUSH
17173: LD_INT 3
17175: PUSH
17176: LD_INT 4
17178: PUSH
17179: LD_INT 5
17181: PUSH
17182: EMPTY
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: ST_TO_ADDR
17188: GO 17945
17190: LD_INT 12
17192: DOUBLE
17193: EQUAL
17194: IFTRUE 17198
17196: GO 17224
17198: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17199: LD_ADDR_VAR 0 3
17203: PUSH
17204: LD_INT 2
17206: PUSH
17207: LD_INT 3
17209: PUSH
17210: LD_INT 4
17212: PUSH
17213: LD_INT 5
17215: PUSH
17216: EMPTY
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: ST_TO_ADDR
17222: GO 17945
17224: LD_INT 13
17226: DOUBLE
17227: EQUAL
17228: IFTRUE 17232
17230: GO 17258
17232: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17233: LD_ADDR_VAR 0 3
17237: PUSH
17238: LD_INT 2
17240: PUSH
17241: LD_INT 3
17243: PUSH
17244: LD_INT 4
17246: PUSH
17247: LD_INT 5
17249: PUSH
17250: EMPTY
17251: LIST
17252: LIST
17253: LIST
17254: LIST
17255: ST_TO_ADDR
17256: GO 17945
17258: LD_INT 14
17260: DOUBLE
17261: EQUAL
17262: IFTRUE 17266
17264: GO 17284
17266: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17267: LD_ADDR_VAR 0 3
17271: PUSH
17272: LD_INT 4
17274: PUSH
17275: LD_INT 5
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: ST_TO_ADDR
17282: GO 17945
17284: LD_INT 6
17286: DOUBLE
17287: EQUAL
17288: IFTRUE 17292
17290: GO 17310
17292: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17293: LD_ADDR_VAR 0 3
17297: PUSH
17298: LD_INT 4
17300: PUSH
17301: LD_INT 5
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: ST_TO_ADDR
17308: GO 17945
17310: LD_INT 10
17312: DOUBLE
17313: EQUAL
17314: IFTRUE 17318
17316: GO 17336
17318: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17319: LD_ADDR_VAR 0 3
17323: PUSH
17324: LD_INT 4
17326: PUSH
17327: LD_INT 5
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: ST_TO_ADDR
17334: GO 17945
17336: LD_INT 22
17338: DOUBLE
17339: EQUAL
17340: IFTRUE 17344
17342: GO 17370
17344: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17345: LD_ADDR_VAR 0 3
17349: PUSH
17350: LD_INT 11
17352: PUSH
17353: LD_INT 12
17355: PUSH
17356: LD_INT 13
17358: PUSH
17359: LD_INT 14
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: LIST
17366: LIST
17367: ST_TO_ADDR
17368: GO 17945
17370: LD_INT 23
17372: DOUBLE
17373: EQUAL
17374: IFTRUE 17378
17376: GO 17404
17378: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17379: LD_ADDR_VAR 0 3
17383: PUSH
17384: LD_INT 11
17386: PUSH
17387: LD_INT 12
17389: PUSH
17390: LD_INT 13
17392: PUSH
17393: LD_INT 14
17395: PUSH
17396: EMPTY
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: ST_TO_ADDR
17402: GO 17945
17404: LD_INT 24
17406: DOUBLE
17407: EQUAL
17408: IFTRUE 17412
17410: GO 17438
17412: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17413: LD_ADDR_VAR 0 3
17417: PUSH
17418: LD_INT 11
17420: PUSH
17421: LD_INT 12
17423: PUSH
17424: LD_INT 13
17426: PUSH
17427: LD_INT 14
17429: PUSH
17430: EMPTY
17431: LIST
17432: LIST
17433: LIST
17434: LIST
17435: ST_TO_ADDR
17436: GO 17945
17438: LD_INT 30
17440: DOUBLE
17441: EQUAL
17442: IFTRUE 17446
17444: GO 17472
17446: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: LD_INT 11
17454: PUSH
17455: LD_INT 12
17457: PUSH
17458: LD_INT 13
17460: PUSH
17461: LD_INT 14
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: LIST
17468: LIST
17469: ST_TO_ADDR
17470: GO 17945
17472: LD_INT 25
17474: DOUBLE
17475: EQUAL
17476: IFTRUE 17480
17478: GO 17498
17480: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17481: LD_ADDR_VAR 0 3
17485: PUSH
17486: LD_INT 13
17488: PUSH
17489: LD_INT 14
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: ST_TO_ADDR
17496: GO 17945
17498: LD_INT 27
17500: DOUBLE
17501: EQUAL
17502: IFTRUE 17506
17504: GO 17524
17506: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17507: LD_ADDR_VAR 0 3
17511: PUSH
17512: LD_INT 13
17514: PUSH
17515: LD_INT 14
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: ST_TO_ADDR
17522: GO 17945
17524: LD_INT 28
17526: DOUBLE
17527: EQUAL
17528: IFTRUE 17532
17530: GO 17550
17532: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17533: LD_ADDR_VAR 0 3
17537: PUSH
17538: LD_INT 13
17540: PUSH
17541: LD_INT 14
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: ST_TO_ADDR
17548: GO 17945
17550: LD_INT 29
17552: DOUBLE
17553: EQUAL
17554: IFTRUE 17558
17556: GO 17576
17558: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17559: LD_ADDR_VAR 0 3
17563: PUSH
17564: LD_INT 13
17566: PUSH
17567: LD_INT 14
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: ST_TO_ADDR
17574: GO 17945
17576: LD_INT 31
17578: DOUBLE
17579: EQUAL
17580: IFTRUE 17584
17582: GO 17602
17584: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_INT 13
17592: PUSH
17593: LD_INT 14
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: ST_TO_ADDR
17600: GO 17945
17602: LD_INT 26
17604: DOUBLE
17605: EQUAL
17606: IFTRUE 17610
17608: GO 17628
17610: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17611: LD_ADDR_VAR 0 3
17615: PUSH
17616: LD_INT 13
17618: PUSH
17619: LD_INT 14
17621: PUSH
17622: EMPTY
17623: LIST
17624: LIST
17625: ST_TO_ADDR
17626: GO 17945
17628: LD_INT 42
17630: DOUBLE
17631: EQUAL
17632: IFTRUE 17636
17634: GO 17662
17636: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17637: LD_ADDR_VAR 0 3
17641: PUSH
17642: LD_INT 21
17644: PUSH
17645: LD_INT 22
17647: PUSH
17648: LD_INT 23
17650: PUSH
17651: LD_INT 24
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: ST_TO_ADDR
17660: GO 17945
17662: LD_INT 43
17664: DOUBLE
17665: EQUAL
17666: IFTRUE 17670
17668: GO 17696
17670: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17671: LD_ADDR_VAR 0 3
17675: PUSH
17676: LD_INT 21
17678: PUSH
17679: LD_INT 22
17681: PUSH
17682: LD_INT 23
17684: PUSH
17685: LD_INT 24
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: LIST
17693: ST_TO_ADDR
17694: GO 17945
17696: LD_INT 44
17698: DOUBLE
17699: EQUAL
17700: IFTRUE 17704
17702: GO 17730
17704: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17705: LD_ADDR_VAR 0 3
17709: PUSH
17710: LD_INT 21
17712: PUSH
17713: LD_INT 22
17715: PUSH
17716: LD_INT 23
17718: PUSH
17719: LD_INT 24
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: ST_TO_ADDR
17728: GO 17945
17730: LD_INT 45
17732: DOUBLE
17733: EQUAL
17734: IFTRUE 17738
17736: GO 17764
17738: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17739: LD_ADDR_VAR 0 3
17743: PUSH
17744: LD_INT 21
17746: PUSH
17747: LD_INT 22
17749: PUSH
17750: LD_INT 23
17752: PUSH
17753: LD_INT 24
17755: PUSH
17756: EMPTY
17757: LIST
17758: LIST
17759: LIST
17760: LIST
17761: ST_TO_ADDR
17762: GO 17945
17764: LD_INT 49
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17798
17772: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17773: LD_ADDR_VAR 0 3
17777: PUSH
17778: LD_INT 21
17780: PUSH
17781: LD_INT 22
17783: PUSH
17784: LD_INT 23
17786: PUSH
17787: LD_INT 24
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: ST_TO_ADDR
17796: GO 17945
17798: LD_INT 51
17800: DOUBLE
17801: EQUAL
17802: IFTRUE 17806
17804: GO 17832
17806: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17807: LD_ADDR_VAR 0 3
17811: PUSH
17812: LD_INT 21
17814: PUSH
17815: LD_INT 22
17817: PUSH
17818: LD_INT 23
17820: PUSH
17821: LD_INT 24
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: ST_TO_ADDR
17830: GO 17945
17832: LD_INT 52
17834: DOUBLE
17835: EQUAL
17836: IFTRUE 17840
17838: GO 17866
17840: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17841: LD_ADDR_VAR 0 3
17845: PUSH
17846: LD_INT 21
17848: PUSH
17849: LD_INT 22
17851: PUSH
17852: LD_INT 23
17854: PUSH
17855: LD_INT 24
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: ST_TO_ADDR
17864: GO 17945
17866: LD_INT 53
17868: DOUBLE
17869: EQUAL
17870: IFTRUE 17874
17872: GO 17892
17874: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17875: LD_ADDR_VAR 0 3
17879: PUSH
17880: LD_INT 23
17882: PUSH
17883: LD_INT 24
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: ST_TO_ADDR
17890: GO 17945
17892: LD_INT 46
17894: DOUBLE
17895: EQUAL
17896: IFTRUE 17900
17898: GO 17918
17900: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17901: LD_ADDR_VAR 0 3
17905: PUSH
17906: LD_INT 23
17908: PUSH
17909: LD_INT 24
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: ST_TO_ADDR
17916: GO 17945
17918: LD_INT 47
17920: DOUBLE
17921: EQUAL
17922: IFTRUE 17926
17924: GO 17944
17926: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17927: LD_ADDR_VAR 0 3
17931: PUSH
17932: LD_INT 23
17934: PUSH
17935: LD_INT 24
17937: PUSH
17938: EMPTY
17939: LIST
17940: LIST
17941: ST_TO_ADDR
17942: GO 17945
17944: POP
// result := ( chassis in result ) ;
17945: LD_ADDR_VAR 0 3
17949: PUSH
17950: LD_VAR 0 1
17954: PUSH
17955: LD_VAR 0 3
17959: IN
17960: ST_TO_ADDR
// end ;
17961: LD_VAR 0 3
17965: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17966: LD_INT 0
17968: PPUSH
17969: PPUSH
17970: PPUSH
17971: PPUSH
17972: PPUSH
17973: PPUSH
17974: PPUSH
// result := array ;
17975: LD_ADDR_VAR 0 5
17979: PUSH
17980: LD_VAR 0 1
17984: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
17985: LD_VAR 0 1
17989: NOT
17990: PUSH
17991: LD_VAR 0 2
17995: NOT
17996: OR
17997: PUSH
17998: LD_VAR 0 3
18002: NOT
18003: OR
18004: PUSH
18005: LD_VAR 0 2
18009: PUSH
18010: LD_VAR 0 1
18014: GREATER
18015: OR
18016: PUSH
18017: LD_VAR 0 3
18021: PUSH
18022: LD_VAR 0 1
18026: GREATER
18027: OR
18028: IFFALSE 18032
// exit ;
18030: GO 18328
// if direction then
18032: LD_VAR 0 4
18036: IFFALSE 18100
// begin d := 1 ;
18038: LD_ADDR_VAR 0 9
18042: PUSH
18043: LD_INT 1
18045: ST_TO_ADDR
// if i_from > i_to then
18046: LD_VAR 0 2
18050: PUSH
18051: LD_VAR 0 3
18055: GREATER
18056: IFFALSE 18082
// length := ( array - i_from ) + i_to else
18058: LD_ADDR_VAR 0 11
18062: PUSH
18063: LD_VAR 0 1
18067: PUSH
18068: LD_VAR 0 2
18072: MINUS
18073: PUSH
18074: LD_VAR 0 3
18078: PLUS
18079: ST_TO_ADDR
18080: GO 18098
// length := i_to - i_from ;
18082: LD_ADDR_VAR 0 11
18086: PUSH
18087: LD_VAR 0 3
18091: PUSH
18092: LD_VAR 0 2
18096: MINUS
18097: ST_TO_ADDR
// end else
18098: GO 18161
// begin d := - 1 ;
18100: LD_ADDR_VAR 0 9
18104: PUSH
18105: LD_INT 1
18107: NEG
18108: ST_TO_ADDR
// if i_from > i_to then
18109: LD_VAR 0 2
18113: PUSH
18114: LD_VAR 0 3
18118: GREATER
18119: IFFALSE 18139
// length := i_from - i_to else
18121: LD_ADDR_VAR 0 11
18125: PUSH
18126: LD_VAR 0 2
18130: PUSH
18131: LD_VAR 0 3
18135: MINUS
18136: ST_TO_ADDR
18137: GO 18161
// length := ( array - i_to ) + i_from ;
18139: LD_ADDR_VAR 0 11
18143: PUSH
18144: LD_VAR 0 1
18148: PUSH
18149: LD_VAR 0 3
18153: MINUS
18154: PUSH
18155: LD_VAR 0 2
18159: PLUS
18160: ST_TO_ADDR
// end ; if not length then
18161: LD_VAR 0 11
18165: NOT
18166: IFFALSE 18170
// exit ;
18168: GO 18328
// tmp := array ;
18170: LD_ADDR_VAR 0 10
18174: PUSH
18175: LD_VAR 0 1
18179: ST_TO_ADDR
// for i = 1 to length do
18180: LD_ADDR_VAR 0 6
18184: PUSH
18185: DOUBLE
18186: LD_INT 1
18188: DEC
18189: ST_TO_ADDR
18190: LD_VAR 0 11
18194: PUSH
18195: FOR_TO
18196: IFFALSE 18316
// begin for j = 1 to array do
18198: LD_ADDR_VAR 0 7
18202: PUSH
18203: DOUBLE
18204: LD_INT 1
18206: DEC
18207: ST_TO_ADDR
18208: LD_VAR 0 1
18212: PUSH
18213: FOR_TO
18214: IFFALSE 18302
// begin k := j + d ;
18216: LD_ADDR_VAR 0 8
18220: PUSH
18221: LD_VAR 0 7
18225: PUSH
18226: LD_VAR 0 9
18230: PLUS
18231: ST_TO_ADDR
// if k > array then
18232: LD_VAR 0 8
18236: PUSH
18237: LD_VAR 0 1
18241: GREATER
18242: IFFALSE 18252
// k := 1 ;
18244: LD_ADDR_VAR 0 8
18248: PUSH
18249: LD_INT 1
18251: ST_TO_ADDR
// if not k then
18252: LD_VAR 0 8
18256: NOT
18257: IFFALSE 18269
// k := array ;
18259: LD_ADDR_VAR 0 8
18263: PUSH
18264: LD_VAR 0 1
18268: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18269: LD_ADDR_VAR 0 10
18273: PUSH
18274: LD_VAR 0 10
18278: PPUSH
18279: LD_VAR 0 8
18283: PPUSH
18284: LD_VAR 0 1
18288: PUSH
18289: LD_VAR 0 7
18293: ARRAY
18294: PPUSH
18295: CALL_OW 1
18299: ST_TO_ADDR
// end ;
18300: GO 18213
18302: POP
18303: POP
// array := tmp ;
18304: LD_ADDR_VAR 0 1
18308: PUSH
18309: LD_VAR 0 10
18313: ST_TO_ADDR
// end ;
18314: GO 18195
18316: POP
18317: POP
// result := array ;
18318: LD_ADDR_VAR 0 5
18322: PUSH
18323: LD_VAR 0 1
18327: ST_TO_ADDR
// end ;
18328: LD_VAR 0 5
18332: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18333: LD_INT 0
18335: PPUSH
18336: PPUSH
// result := 0 ;
18337: LD_ADDR_VAR 0 3
18341: PUSH
18342: LD_INT 0
18344: ST_TO_ADDR
// if not array or not value in array then
18345: LD_VAR 0 1
18349: NOT
18350: PUSH
18351: LD_VAR 0 2
18355: PUSH
18356: LD_VAR 0 1
18360: IN
18361: NOT
18362: OR
18363: IFFALSE 18367
// exit ;
18365: GO 18421
// for i = 1 to array do
18367: LD_ADDR_VAR 0 4
18371: PUSH
18372: DOUBLE
18373: LD_INT 1
18375: DEC
18376: ST_TO_ADDR
18377: LD_VAR 0 1
18381: PUSH
18382: FOR_TO
18383: IFFALSE 18419
// if value = array [ i ] then
18385: LD_VAR 0 2
18389: PUSH
18390: LD_VAR 0 1
18394: PUSH
18395: LD_VAR 0 4
18399: ARRAY
18400: EQUAL
18401: IFFALSE 18417
// begin result := i ;
18403: LD_ADDR_VAR 0 3
18407: PUSH
18408: LD_VAR 0 4
18412: ST_TO_ADDR
// exit ;
18413: POP
18414: POP
18415: GO 18421
// end ;
18417: GO 18382
18419: POP
18420: POP
// end ;
18421: LD_VAR 0 3
18425: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18426: LD_INT 0
18428: PPUSH
// vc_chassis := chassis ;
18429: LD_ADDR_OWVAR 37
18433: PUSH
18434: LD_VAR 0 1
18438: ST_TO_ADDR
// vc_engine := engine ;
18439: LD_ADDR_OWVAR 39
18443: PUSH
18444: LD_VAR 0 2
18448: ST_TO_ADDR
// vc_control := control ;
18449: LD_ADDR_OWVAR 38
18453: PUSH
18454: LD_VAR 0 3
18458: ST_TO_ADDR
// vc_weapon := weapon ;
18459: LD_ADDR_OWVAR 40
18463: PUSH
18464: LD_VAR 0 4
18468: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18469: LD_ADDR_OWVAR 41
18473: PUSH
18474: LD_VAR 0 5
18478: ST_TO_ADDR
// end ;
18479: LD_VAR 0 6
18483: RET
// export function WantPlant ( unit ) ; var task ; begin
18484: LD_INT 0
18486: PPUSH
18487: PPUSH
// result := false ;
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: LD_INT 0
18495: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18496: LD_ADDR_VAR 0 3
18500: PUSH
18501: LD_VAR 0 1
18505: PPUSH
18506: CALL_OW 437
18510: ST_TO_ADDR
// if task then
18511: LD_VAR 0 3
18515: IFFALSE 18543
// if task [ 1 ] [ 1 ] = p then
18517: LD_VAR 0 3
18521: PUSH
18522: LD_INT 1
18524: ARRAY
18525: PUSH
18526: LD_INT 1
18528: ARRAY
18529: PUSH
18530: LD_STRING p
18532: EQUAL
18533: IFFALSE 18543
// result := true ;
18535: LD_ADDR_VAR 0 2
18539: PUSH
18540: LD_INT 1
18542: ST_TO_ADDR
// end ;
18543: LD_VAR 0 2
18547: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18548: LD_INT 0
18550: PPUSH
18551: PPUSH
18552: PPUSH
18553: PPUSH
// if pos < 1 then
18554: LD_VAR 0 2
18558: PUSH
18559: LD_INT 1
18561: LESS
18562: IFFALSE 18566
// exit ;
18564: GO 18869
// if pos = 1 then
18566: LD_VAR 0 2
18570: PUSH
18571: LD_INT 1
18573: EQUAL
18574: IFFALSE 18607
// result := Replace ( arr , pos [ 1 ] , value ) else
18576: LD_ADDR_VAR 0 4
18580: PUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: LD_VAR 0 2
18590: PUSH
18591: LD_INT 1
18593: ARRAY
18594: PPUSH
18595: LD_VAR 0 3
18599: PPUSH
18600: CALL_OW 1
18604: ST_TO_ADDR
18605: GO 18869
// begin tmp := arr ;
18607: LD_ADDR_VAR 0 6
18611: PUSH
18612: LD_VAR 0 1
18616: ST_TO_ADDR
// s_arr := [ tmp ] ;
18617: LD_ADDR_VAR 0 7
18621: PUSH
18622: LD_VAR 0 6
18626: PUSH
18627: EMPTY
18628: LIST
18629: ST_TO_ADDR
// for i = 1 to pos - 1 do
18630: LD_ADDR_VAR 0 5
18634: PUSH
18635: DOUBLE
18636: LD_INT 1
18638: DEC
18639: ST_TO_ADDR
18640: LD_VAR 0 2
18644: PUSH
18645: LD_INT 1
18647: MINUS
18648: PUSH
18649: FOR_TO
18650: IFFALSE 18695
// begin tmp := tmp [ pos [ i ] ] ;
18652: LD_ADDR_VAR 0 6
18656: PUSH
18657: LD_VAR 0 6
18661: PUSH
18662: LD_VAR 0 2
18666: PUSH
18667: LD_VAR 0 5
18671: ARRAY
18672: ARRAY
18673: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18674: LD_ADDR_VAR 0 7
18678: PUSH
18679: LD_VAR 0 7
18683: PUSH
18684: LD_VAR 0 6
18688: PUSH
18689: EMPTY
18690: LIST
18691: ADD
18692: ST_TO_ADDR
// end ;
18693: GO 18649
18695: POP
18696: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18697: LD_ADDR_VAR 0 6
18701: PUSH
18702: LD_VAR 0 6
18706: PPUSH
18707: LD_VAR 0 2
18711: PUSH
18712: LD_VAR 0 2
18716: ARRAY
18717: PPUSH
18718: LD_VAR 0 3
18722: PPUSH
18723: CALL_OW 1
18727: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18728: LD_ADDR_VAR 0 7
18732: PUSH
18733: LD_VAR 0 7
18737: PPUSH
18738: LD_VAR 0 7
18742: PPUSH
18743: LD_VAR 0 6
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
// for i = s_arr downto 2 do
18753: LD_ADDR_VAR 0 5
18757: PUSH
18758: DOUBLE
18759: LD_VAR 0 7
18763: INC
18764: ST_TO_ADDR
18765: LD_INT 2
18767: PUSH
18768: FOR_DOWNTO
18769: IFFALSE 18853
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18771: LD_ADDR_VAR 0 6
18775: PUSH
18776: LD_VAR 0 7
18780: PUSH
18781: LD_VAR 0 5
18785: PUSH
18786: LD_INT 1
18788: MINUS
18789: ARRAY
18790: PPUSH
18791: LD_VAR 0 2
18795: PUSH
18796: LD_VAR 0 5
18800: PUSH
18801: LD_INT 1
18803: MINUS
18804: ARRAY
18805: PPUSH
18806: LD_VAR 0 7
18810: PUSH
18811: LD_VAR 0 5
18815: ARRAY
18816: PPUSH
18817: CALL_OW 1
18821: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18822: LD_ADDR_VAR 0 7
18826: PUSH
18827: LD_VAR 0 7
18831: PPUSH
18832: LD_VAR 0 5
18836: PUSH
18837: LD_INT 1
18839: MINUS
18840: PPUSH
18841: LD_VAR 0 6
18845: PPUSH
18846: CALL_OW 1
18850: ST_TO_ADDR
// end ;
18851: GO 18768
18853: POP
18854: POP
// result := s_arr [ 1 ] ;
18855: LD_ADDR_VAR 0 4
18859: PUSH
18860: LD_VAR 0 7
18864: PUSH
18865: LD_INT 1
18867: ARRAY
18868: ST_TO_ADDR
// end ; end ;
18869: LD_VAR 0 4
18873: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18874: LD_INT 0
18876: PPUSH
18877: PPUSH
// if not list then
18878: LD_VAR 0 1
18882: NOT
18883: IFFALSE 18887
// exit ;
18885: GO 18978
// i := list [ pos1 ] ;
18887: LD_ADDR_VAR 0 5
18891: PUSH
18892: LD_VAR 0 1
18896: PUSH
18897: LD_VAR 0 2
18901: ARRAY
18902: ST_TO_ADDR
// if not i then
18903: LD_VAR 0 5
18907: NOT
18908: IFFALSE 18912
// exit ;
18910: GO 18978
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18912: LD_ADDR_VAR 0 1
18916: PUSH
18917: LD_VAR 0 1
18921: PPUSH
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 1
18931: PUSH
18932: LD_VAR 0 3
18936: ARRAY
18937: PPUSH
18938: CALL_OW 1
18942: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: LD_VAR 0 1
18952: PPUSH
18953: LD_VAR 0 3
18957: PPUSH
18958: LD_VAR 0 5
18962: PPUSH
18963: CALL_OW 1
18967: ST_TO_ADDR
// result := list ;
18968: LD_ADDR_VAR 0 4
18972: PUSH
18973: LD_VAR 0 1
18977: ST_TO_ADDR
// end ;
18978: LD_VAR 0 4
18982: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
18983: LD_INT 0
18985: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
18986: LD_ADDR_VAR 0 5
18990: PUSH
18991: LD_VAR 0 1
18995: PPUSH
18996: CALL_OW 250
19000: PPUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 251
19010: PPUSH
19011: LD_VAR 0 2
19015: PPUSH
19016: LD_VAR 0 3
19020: PPUSH
19021: LD_VAR 0 4
19025: PPUSH
19026: CALL 19036 0 5
19030: ST_TO_ADDR
// end ;
19031: LD_VAR 0 5
19035: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19036: LD_INT 0
19038: PPUSH
19039: PPUSH
19040: PPUSH
19041: PPUSH
// if not list then
19042: LD_VAR 0 3
19046: NOT
19047: IFFALSE 19051
// exit ;
19049: GO 19439
// result := [ ] ;
19051: LD_ADDR_VAR 0 6
19055: PUSH
19056: EMPTY
19057: ST_TO_ADDR
// for i in list do
19058: LD_ADDR_VAR 0 7
19062: PUSH
19063: LD_VAR 0 3
19067: PUSH
19068: FOR_IN
19069: IFFALSE 19271
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19071: LD_ADDR_VAR 0 9
19075: PUSH
19076: LD_VAR 0 7
19080: PPUSH
19081: LD_VAR 0 1
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 297
19095: ST_TO_ADDR
// if not result then
19096: LD_VAR 0 6
19100: NOT
19101: IFFALSE 19127
// result := [ [ i , tmp ] ] else
19103: LD_ADDR_VAR 0 6
19107: PUSH
19108: LD_VAR 0 7
19112: PUSH
19113: LD_VAR 0 9
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: PUSH
19122: EMPTY
19123: LIST
19124: ST_TO_ADDR
19125: GO 19269
// begin if result [ result ] [ 2 ] < tmp then
19127: LD_VAR 0 6
19131: PUSH
19132: LD_VAR 0 6
19136: ARRAY
19137: PUSH
19138: LD_INT 2
19140: ARRAY
19141: PUSH
19142: LD_VAR 0 9
19146: LESS
19147: IFFALSE 19189
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19149: LD_ADDR_VAR 0 6
19153: PUSH
19154: LD_VAR 0 6
19158: PPUSH
19159: LD_VAR 0 6
19163: PUSH
19164: LD_INT 1
19166: PLUS
19167: PPUSH
19168: LD_VAR 0 7
19172: PUSH
19173: LD_VAR 0 9
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: PPUSH
19182: CALL_OW 2
19186: ST_TO_ADDR
19187: GO 19269
// for j = 1 to result do
19189: LD_ADDR_VAR 0 8
19193: PUSH
19194: DOUBLE
19195: LD_INT 1
19197: DEC
19198: ST_TO_ADDR
19199: LD_VAR 0 6
19203: PUSH
19204: FOR_TO
19205: IFFALSE 19267
// begin if tmp < result [ j ] [ 2 ] then
19207: LD_VAR 0 9
19211: PUSH
19212: LD_VAR 0 6
19216: PUSH
19217: LD_VAR 0 8
19221: ARRAY
19222: PUSH
19223: LD_INT 2
19225: ARRAY
19226: LESS
19227: IFFALSE 19265
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19229: LD_ADDR_VAR 0 6
19233: PUSH
19234: LD_VAR 0 6
19238: PPUSH
19239: LD_VAR 0 8
19243: PPUSH
19244: LD_VAR 0 7
19248: PUSH
19249: LD_VAR 0 9
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: PPUSH
19258: CALL_OW 2
19262: ST_TO_ADDR
// break ;
19263: GO 19267
// end ; end ;
19265: GO 19204
19267: POP
19268: POP
// end ; end ;
19269: GO 19068
19271: POP
19272: POP
// if result and not asc then
19273: LD_VAR 0 6
19277: PUSH
19278: LD_VAR 0 4
19282: NOT
19283: AND
19284: IFFALSE 19359
// begin tmp := result ;
19286: LD_ADDR_VAR 0 9
19290: PUSH
19291: LD_VAR 0 6
19295: ST_TO_ADDR
// for i = tmp downto 1 do
19296: LD_ADDR_VAR 0 7
19300: PUSH
19301: DOUBLE
19302: LD_VAR 0 9
19306: INC
19307: ST_TO_ADDR
19308: LD_INT 1
19310: PUSH
19311: FOR_DOWNTO
19312: IFFALSE 19357
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19314: LD_ADDR_VAR 0 6
19318: PUSH
19319: LD_VAR 0 6
19323: PPUSH
19324: LD_VAR 0 9
19328: PUSH
19329: LD_VAR 0 7
19333: MINUS
19334: PUSH
19335: LD_INT 1
19337: PLUS
19338: PPUSH
19339: LD_VAR 0 9
19343: PUSH
19344: LD_VAR 0 7
19348: ARRAY
19349: PPUSH
19350: CALL_OW 1
19354: ST_TO_ADDR
19355: GO 19311
19357: POP
19358: POP
// end ; tmp := [ ] ;
19359: LD_ADDR_VAR 0 9
19363: PUSH
19364: EMPTY
19365: ST_TO_ADDR
// if mode then
19366: LD_VAR 0 5
19370: IFFALSE 19439
// begin for i = 1 to result do
19372: LD_ADDR_VAR 0 7
19376: PUSH
19377: DOUBLE
19378: LD_INT 1
19380: DEC
19381: ST_TO_ADDR
19382: LD_VAR 0 6
19386: PUSH
19387: FOR_TO
19388: IFFALSE 19427
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19390: LD_ADDR_VAR 0 9
19394: PUSH
19395: LD_VAR 0 9
19399: PPUSH
19400: LD_VAR 0 7
19404: PPUSH
19405: LD_VAR 0 6
19409: PUSH
19410: LD_VAR 0 7
19414: ARRAY
19415: PUSH
19416: LD_INT 1
19418: ARRAY
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
19425: GO 19387
19427: POP
19428: POP
// result := tmp ;
19429: LD_ADDR_VAR 0 6
19433: PUSH
19434: LD_VAR 0 9
19438: ST_TO_ADDR
// end ; end ;
19439: LD_VAR 0 6
19443: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19444: LD_INT 0
19446: PPUSH
19447: PPUSH
19448: PPUSH
19449: PPUSH
19450: PPUSH
19451: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19452: LD_ADDR_VAR 0 5
19456: PUSH
19457: LD_INT 0
19459: PUSH
19460: LD_INT 0
19462: PUSH
19463: LD_INT 0
19465: PUSH
19466: EMPTY
19467: PUSH
19468: EMPTY
19469: LIST
19470: LIST
19471: LIST
19472: LIST
19473: ST_TO_ADDR
// if not x or not y then
19474: LD_VAR 0 2
19478: NOT
19479: PUSH
19480: LD_VAR 0 3
19484: NOT
19485: OR
19486: IFFALSE 19490
// exit ;
19488: GO 21136
// if not range then
19490: LD_VAR 0 4
19494: NOT
19495: IFFALSE 19505
// range := 10 ;
19497: LD_ADDR_VAR 0 4
19501: PUSH
19502: LD_INT 10
19504: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19505: LD_ADDR_VAR 0 8
19509: PUSH
19510: LD_INT 81
19512: PUSH
19513: LD_VAR 0 1
19517: PUSH
19518: EMPTY
19519: LIST
19520: LIST
19521: PUSH
19522: LD_INT 92
19524: PUSH
19525: LD_VAR 0 2
19529: PUSH
19530: LD_VAR 0 3
19534: PUSH
19535: LD_VAR 0 4
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: LIST
19544: LIST
19545: PUSH
19546: LD_INT 3
19548: PUSH
19549: LD_INT 21
19551: PUSH
19552: LD_INT 3
19554: PUSH
19555: EMPTY
19556: LIST
19557: LIST
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: LIST
19567: PPUSH
19568: CALL_OW 69
19572: ST_TO_ADDR
// if not tmp then
19573: LD_VAR 0 8
19577: NOT
19578: IFFALSE 19582
// exit ;
19580: GO 21136
// for i in tmp do
19582: LD_ADDR_VAR 0 6
19586: PUSH
19587: LD_VAR 0 8
19591: PUSH
19592: FOR_IN
19593: IFFALSE 21111
// begin points := [ 0 , 0 , 0 ] ;
19595: LD_ADDR_VAR 0 9
19599: PUSH
19600: LD_INT 0
19602: PUSH
19603: LD_INT 0
19605: PUSH
19606: LD_INT 0
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: LIST
19613: ST_TO_ADDR
// bpoints := 1 ;
19614: LD_ADDR_VAR 0 10
19618: PUSH
19619: LD_INT 1
19621: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19622: LD_VAR 0 6
19626: PPUSH
19627: CALL_OW 247
19631: PUSH
19632: LD_INT 1
19634: DOUBLE
19635: EQUAL
19636: IFTRUE 19640
19638: GO 20218
19640: POP
// begin if GetClass ( i ) = 1 then
19641: LD_VAR 0 6
19645: PPUSH
19646: CALL_OW 257
19650: PUSH
19651: LD_INT 1
19653: EQUAL
19654: IFFALSE 19675
// points := [ 10 , 5 , 3 ] ;
19656: LD_ADDR_VAR 0 9
19660: PUSH
19661: LD_INT 10
19663: PUSH
19664: LD_INT 5
19666: PUSH
19667: LD_INT 3
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19675: LD_VAR 0 6
19679: PPUSH
19680: CALL_OW 257
19684: PUSH
19685: LD_INT 2
19687: PUSH
19688: LD_INT 3
19690: PUSH
19691: LD_INT 4
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: LIST
19698: IN
19699: IFFALSE 19720
// points := [ 3 , 2 , 1 ] ;
19701: LD_ADDR_VAR 0 9
19705: PUSH
19706: LD_INT 3
19708: PUSH
19709: LD_INT 2
19711: PUSH
19712: LD_INT 1
19714: PUSH
19715: EMPTY
19716: LIST
19717: LIST
19718: LIST
19719: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19720: LD_VAR 0 6
19724: PPUSH
19725: CALL_OW 257
19729: PUSH
19730: LD_INT 5
19732: EQUAL
19733: IFFALSE 19754
// points := [ 130 , 5 , 2 ] ;
19735: LD_ADDR_VAR 0 9
19739: PUSH
19740: LD_INT 130
19742: PUSH
19743: LD_INT 5
19745: PUSH
19746: LD_INT 2
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: LIST
19753: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19754: LD_VAR 0 6
19758: PPUSH
19759: CALL_OW 257
19763: PUSH
19764: LD_INT 8
19766: EQUAL
19767: IFFALSE 19788
// points := [ 35 , 35 , 30 ] ;
19769: LD_ADDR_VAR 0 9
19773: PUSH
19774: LD_INT 35
19776: PUSH
19777: LD_INT 35
19779: PUSH
19780: LD_INT 30
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: LIST
19787: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19788: LD_VAR 0 6
19792: PPUSH
19793: CALL_OW 257
19797: PUSH
19798: LD_INT 9
19800: EQUAL
19801: IFFALSE 19822
// points := [ 20 , 55 , 40 ] ;
19803: LD_ADDR_VAR 0 9
19807: PUSH
19808: LD_INT 20
19810: PUSH
19811: LD_INT 55
19813: PUSH
19814: LD_INT 40
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: LIST
19821: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19822: LD_VAR 0 6
19826: PPUSH
19827: CALL_OW 257
19831: PUSH
19832: LD_INT 12
19834: PUSH
19835: LD_INT 16
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: IN
19842: IFFALSE 19863
// points := [ 5 , 3 , 2 ] ;
19844: LD_ADDR_VAR 0 9
19848: PUSH
19849: LD_INT 5
19851: PUSH
19852: LD_INT 3
19854: PUSH
19855: LD_INT 2
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: LIST
19862: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19863: LD_VAR 0 6
19867: PPUSH
19868: CALL_OW 257
19872: PUSH
19873: LD_INT 17
19875: EQUAL
19876: IFFALSE 19897
// points := [ 100 , 50 , 75 ] ;
19878: LD_ADDR_VAR 0 9
19882: PUSH
19883: LD_INT 100
19885: PUSH
19886: LD_INT 50
19888: PUSH
19889: LD_INT 75
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: LIST
19896: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19897: LD_VAR 0 6
19901: PPUSH
19902: CALL_OW 257
19906: PUSH
19907: LD_INT 15
19909: EQUAL
19910: IFFALSE 19931
// points := [ 10 , 5 , 3 ] ;
19912: LD_ADDR_VAR 0 9
19916: PUSH
19917: LD_INT 10
19919: PUSH
19920: LD_INT 5
19922: PUSH
19923: LD_INT 3
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: LIST
19930: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19931: LD_VAR 0 6
19935: PPUSH
19936: CALL_OW 257
19940: PUSH
19941: LD_INT 14
19943: EQUAL
19944: IFFALSE 19965
// points := [ 10 , 0 , 0 ] ;
19946: LD_ADDR_VAR 0 9
19950: PUSH
19951: LD_INT 10
19953: PUSH
19954: LD_INT 0
19956: PUSH
19957: LD_INT 0
19959: PUSH
19960: EMPTY
19961: LIST
19962: LIST
19963: LIST
19964: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19965: LD_VAR 0 6
19969: PPUSH
19970: CALL_OW 257
19974: PUSH
19975: LD_INT 11
19977: EQUAL
19978: IFFALSE 19999
// points := [ 30 , 10 , 5 ] ;
19980: LD_ADDR_VAR 0 9
19984: PUSH
19985: LD_INT 30
19987: PUSH
19988: LD_INT 10
19990: PUSH
19991: LD_INT 5
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
19999: LD_VAR 0 1
20003: PPUSH
20004: LD_INT 5
20006: PPUSH
20007: CALL_OW 321
20011: PUSH
20012: LD_INT 2
20014: EQUAL
20015: IFFALSE 20032
// bpoints := bpoints * 1.8 ;
20017: LD_ADDR_VAR 0 10
20021: PUSH
20022: LD_VAR 0 10
20026: PUSH
20027: LD_REAL  1.80000000000000E+0000
20030: MUL
20031: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20032: LD_VAR 0 6
20036: PPUSH
20037: CALL_OW 257
20041: PUSH
20042: LD_INT 1
20044: PUSH
20045: LD_INT 2
20047: PUSH
20048: LD_INT 3
20050: PUSH
20051: LD_INT 4
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: LIST
20058: LIST
20059: IN
20060: PUSH
20061: LD_VAR 0 1
20065: PPUSH
20066: LD_INT 51
20068: PPUSH
20069: CALL_OW 321
20073: PUSH
20074: LD_INT 2
20076: EQUAL
20077: AND
20078: IFFALSE 20095
// bpoints := bpoints * 1.2 ;
20080: LD_ADDR_VAR 0 10
20084: PUSH
20085: LD_VAR 0 10
20089: PUSH
20090: LD_REAL  1.20000000000000E+0000
20093: MUL
20094: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20095: LD_VAR 0 6
20099: PPUSH
20100: CALL_OW 257
20104: PUSH
20105: LD_INT 5
20107: PUSH
20108: LD_INT 7
20110: PUSH
20111: LD_INT 9
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: LIST
20118: IN
20119: PUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: LD_INT 52
20127: PPUSH
20128: CALL_OW 321
20132: PUSH
20133: LD_INT 2
20135: EQUAL
20136: AND
20137: IFFALSE 20154
// bpoints := bpoints * 1.5 ;
20139: LD_ADDR_VAR 0 10
20143: PUSH
20144: LD_VAR 0 10
20148: PUSH
20149: LD_REAL  1.50000000000000E+0000
20152: MUL
20153: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20154: LD_VAR 0 1
20158: PPUSH
20159: LD_INT 66
20161: PPUSH
20162: CALL_OW 321
20166: PUSH
20167: LD_INT 2
20169: EQUAL
20170: IFFALSE 20187
// bpoints := bpoints * 1.1 ;
20172: LD_ADDR_VAR 0 10
20176: PUSH
20177: LD_VAR 0 10
20181: PUSH
20182: LD_REAL  1.10000000000000E+0000
20185: MUL
20186: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20187: LD_ADDR_VAR 0 10
20191: PUSH
20192: LD_VAR 0 10
20196: PUSH
20197: LD_VAR 0 6
20201: PPUSH
20202: LD_INT 1
20204: PPUSH
20205: CALL_OW 259
20209: PUSH
20210: LD_REAL  1.15000000000000E+0000
20213: MUL
20214: MUL
20215: ST_TO_ADDR
// end ; unit_vehicle :
20216: GO 21040
20218: LD_INT 2
20220: DOUBLE
20221: EQUAL
20222: IFTRUE 20226
20224: GO 21028
20226: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20227: LD_VAR 0 6
20231: PPUSH
20232: CALL_OW 264
20236: PUSH
20237: LD_INT 2
20239: PUSH
20240: LD_INT 42
20242: PUSH
20243: LD_INT 24
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: LIST
20250: IN
20251: IFFALSE 20272
// points := [ 25 , 5 , 3 ] ;
20253: LD_ADDR_VAR 0 9
20257: PUSH
20258: LD_INT 25
20260: PUSH
20261: LD_INT 5
20263: PUSH
20264: LD_INT 3
20266: PUSH
20267: EMPTY
20268: LIST
20269: LIST
20270: LIST
20271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20272: LD_VAR 0 6
20276: PPUSH
20277: CALL_OW 264
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 43
20287: PUSH
20288: LD_INT 25
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: IN
20296: IFFALSE 20317
// points := [ 40 , 15 , 5 ] ;
20298: LD_ADDR_VAR 0 9
20302: PUSH
20303: LD_INT 40
20305: PUSH
20306: LD_INT 15
20308: PUSH
20309: LD_INT 5
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20317: LD_VAR 0 6
20321: PPUSH
20322: CALL_OW 264
20326: PUSH
20327: LD_INT 3
20329: PUSH
20330: LD_INT 23
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: IN
20337: IFFALSE 20358
// points := [ 7 , 25 , 8 ] ;
20339: LD_ADDR_VAR 0 9
20343: PUSH
20344: LD_INT 7
20346: PUSH
20347: LD_INT 25
20349: PUSH
20350: LD_INT 8
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: LIST
20357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20358: LD_VAR 0 6
20362: PPUSH
20363: CALL_OW 264
20367: PUSH
20368: LD_INT 5
20370: PUSH
20371: LD_INT 27
20373: PUSH
20374: LD_INT 44
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: LIST
20381: IN
20382: IFFALSE 20403
// points := [ 14 , 50 , 16 ] ;
20384: LD_ADDR_VAR 0 9
20388: PUSH
20389: LD_INT 14
20391: PUSH
20392: LD_INT 50
20394: PUSH
20395: LD_INT 16
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: LIST
20402: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20403: LD_VAR 0 6
20407: PPUSH
20408: CALL_OW 264
20412: PUSH
20413: LD_INT 6
20415: PUSH
20416: LD_INT 46
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: IN
20423: IFFALSE 20444
// points := [ 32 , 120 , 70 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 32
20432: PUSH
20433: LD_INT 120
20435: PUSH
20436: LD_INT 70
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
20444: LD_VAR 0 6
20448: PPUSH
20449: CALL_OW 264
20453: PUSH
20454: LD_INT 7
20456: PUSH
20457: LD_INT 28
20459: PUSH
20460: LD_INT 45
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: IN
20468: IFFALSE 20489
// points := [ 35 , 20 , 45 ] ;
20470: LD_ADDR_VAR 0 9
20474: PUSH
20475: LD_INT 35
20477: PUSH
20478: LD_INT 20
20480: PUSH
20481: LD_INT 45
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: LIST
20488: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20489: LD_VAR 0 6
20493: PPUSH
20494: CALL_OW 264
20498: PUSH
20499: LD_INT 47
20501: PUSH
20502: EMPTY
20503: LIST
20504: IN
20505: IFFALSE 20526
// points := [ 67 , 45 , 75 ] ;
20507: LD_ADDR_VAR 0 9
20511: PUSH
20512: LD_INT 67
20514: PUSH
20515: LD_INT 45
20517: PUSH
20518: LD_INT 75
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: LIST
20525: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20526: LD_VAR 0 6
20530: PPUSH
20531: CALL_OW 264
20535: PUSH
20536: LD_INT 26
20538: PUSH
20539: EMPTY
20540: LIST
20541: IN
20542: IFFALSE 20563
// points := [ 120 , 30 , 80 ] ;
20544: LD_ADDR_VAR 0 9
20548: PUSH
20549: LD_INT 120
20551: PUSH
20552: LD_INT 30
20554: PUSH
20555: LD_INT 80
20557: PUSH
20558: EMPTY
20559: LIST
20560: LIST
20561: LIST
20562: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20563: LD_VAR 0 6
20567: PPUSH
20568: CALL_OW 264
20572: PUSH
20573: LD_INT 22
20575: PUSH
20576: EMPTY
20577: LIST
20578: IN
20579: IFFALSE 20600
// points := [ 40 , 1 , 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 40
20588: PUSH
20589: LD_INT 1
20591: PUSH
20592: LD_INT 1
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: LIST
20599: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20600: LD_VAR 0 6
20604: PPUSH
20605: CALL_OW 264
20609: PUSH
20610: LD_INT 29
20612: PUSH
20613: EMPTY
20614: LIST
20615: IN
20616: IFFALSE 20637
// points := [ 70 , 200 , 400 ] ;
20618: LD_ADDR_VAR 0 9
20622: PUSH
20623: LD_INT 70
20625: PUSH
20626: LD_INT 200
20628: PUSH
20629: LD_INT 400
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: LIST
20636: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20637: LD_VAR 0 6
20641: PPUSH
20642: CALL_OW 264
20646: PUSH
20647: LD_INT 14
20649: PUSH
20650: LD_INT 53
20652: PUSH
20653: EMPTY
20654: LIST
20655: LIST
20656: IN
20657: IFFALSE 20678
// points := [ 40 , 10 , 20 ] ;
20659: LD_ADDR_VAR 0 9
20663: PUSH
20664: LD_INT 40
20666: PUSH
20667: LD_INT 10
20669: PUSH
20670: LD_INT 20
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20678: LD_VAR 0 6
20682: PPUSH
20683: CALL_OW 264
20687: PUSH
20688: LD_INT 9
20690: PUSH
20691: EMPTY
20692: LIST
20693: IN
20694: IFFALSE 20715
// points := [ 5 , 70 , 20 ] ;
20696: LD_ADDR_VAR 0 9
20700: PUSH
20701: LD_INT 5
20703: PUSH
20704: LD_INT 70
20706: PUSH
20707: LD_INT 20
20709: PUSH
20710: EMPTY
20711: LIST
20712: LIST
20713: LIST
20714: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20715: LD_VAR 0 6
20719: PPUSH
20720: CALL_OW 264
20724: PUSH
20725: LD_INT 10
20727: PUSH
20728: EMPTY
20729: LIST
20730: IN
20731: IFFALSE 20752
// points := [ 35 , 110 , 70 ] ;
20733: LD_ADDR_VAR 0 9
20737: PUSH
20738: LD_INT 35
20740: PUSH
20741: LD_INT 110
20743: PUSH
20744: LD_INT 70
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: LIST
20751: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20752: LD_VAR 0 6
20756: PPUSH
20757: CALL_OW 265
20761: PUSH
20762: LD_INT 25
20764: EQUAL
20765: IFFALSE 20786
// points := [ 80 , 65 , 100 ] ;
20767: LD_ADDR_VAR 0 9
20771: PUSH
20772: LD_INT 80
20774: PUSH
20775: LD_INT 65
20777: PUSH
20778: LD_INT 100
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: LIST
20785: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20786: LD_VAR 0 6
20790: PPUSH
20791: CALL_OW 263
20795: PUSH
20796: LD_INT 1
20798: EQUAL
20799: IFFALSE 20834
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20801: LD_ADDR_VAR 0 10
20805: PUSH
20806: LD_VAR 0 10
20810: PUSH
20811: LD_VAR 0 6
20815: PPUSH
20816: CALL_OW 311
20820: PPUSH
20821: LD_INT 3
20823: PPUSH
20824: CALL_OW 259
20828: PUSH
20829: LD_INT 4
20831: MUL
20832: MUL
20833: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20834: LD_VAR 0 6
20838: PPUSH
20839: CALL_OW 263
20843: PUSH
20844: LD_INT 2
20846: EQUAL
20847: IFFALSE 20898
// begin j := IsControledBy ( i ) ;
20849: LD_ADDR_VAR 0 7
20853: PUSH
20854: LD_VAR 0 6
20858: PPUSH
20859: CALL_OW 312
20863: ST_TO_ADDR
// if j then
20864: LD_VAR 0 7
20868: IFFALSE 20898
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20870: LD_ADDR_VAR 0 10
20874: PUSH
20875: LD_VAR 0 10
20879: PUSH
20880: LD_VAR 0 7
20884: PPUSH
20885: LD_INT 3
20887: PPUSH
20888: CALL_OW 259
20892: PUSH
20893: LD_INT 3
20895: MUL
20896: MUL
20897: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20898: LD_VAR 0 6
20902: PPUSH
20903: CALL_OW 264
20907: PUSH
20908: LD_INT 5
20910: PUSH
20911: LD_INT 6
20913: PUSH
20914: LD_INT 46
20916: PUSH
20917: LD_INT 44
20919: PUSH
20920: LD_INT 47
20922: PUSH
20923: LD_INT 45
20925: PUSH
20926: LD_INT 28
20928: PUSH
20929: LD_INT 7
20931: PUSH
20932: LD_INT 27
20934: PUSH
20935: LD_INT 29
20937: PUSH
20938: EMPTY
20939: LIST
20940: LIST
20941: LIST
20942: LIST
20943: LIST
20944: LIST
20945: LIST
20946: LIST
20947: LIST
20948: LIST
20949: IN
20950: PUSH
20951: LD_VAR 0 1
20955: PPUSH
20956: LD_INT 52
20958: PPUSH
20959: CALL_OW 321
20963: PUSH
20964: LD_INT 2
20966: EQUAL
20967: AND
20968: IFFALSE 20985
// bpoints := bpoints * 1.2 ;
20970: LD_ADDR_VAR 0 10
20974: PUSH
20975: LD_VAR 0 10
20979: PUSH
20980: LD_REAL  1.20000000000000E+0000
20983: MUL
20984: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
20985: LD_VAR 0 6
20989: PPUSH
20990: CALL_OW 264
20994: PUSH
20995: LD_INT 6
20997: PUSH
20998: LD_INT 46
21000: PUSH
21001: LD_INT 47
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: LIST
21008: IN
21009: IFFALSE 21026
// bpoints := bpoints * 1.2 ;
21011: LD_ADDR_VAR 0 10
21015: PUSH
21016: LD_VAR 0 10
21020: PUSH
21021: LD_REAL  1.20000000000000E+0000
21024: MUL
21025: ST_TO_ADDR
// end ; unit_building :
21026: GO 21040
21028: LD_INT 3
21030: DOUBLE
21031: EQUAL
21032: IFTRUE 21036
21034: GO 21039
21036: POP
// ; end ;
21037: GO 21040
21039: POP
// for j = 1 to 3 do
21040: LD_ADDR_VAR 0 7
21044: PUSH
21045: DOUBLE
21046: LD_INT 1
21048: DEC
21049: ST_TO_ADDR
21050: LD_INT 3
21052: PUSH
21053: FOR_TO
21054: IFFALSE 21107
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21056: LD_ADDR_VAR 0 5
21060: PUSH
21061: LD_VAR 0 5
21065: PPUSH
21066: LD_VAR 0 7
21070: PPUSH
21071: LD_VAR 0 5
21075: PUSH
21076: LD_VAR 0 7
21080: ARRAY
21081: PUSH
21082: LD_VAR 0 9
21086: PUSH
21087: LD_VAR 0 7
21091: ARRAY
21092: PUSH
21093: LD_VAR 0 10
21097: MUL
21098: PLUS
21099: PPUSH
21100: CALL_OW 1
21104: ST_TO_ADDR
21105: GO 21053
21107: POP
21108: POP
// end ;
21109: GO 19592
21111: POP
21112: POP
// result := Replace ( result , 4 , tmp ) ;
21113: LD_ADDR_VAR 0 5
21117: PUSH
21118: LD_VAR 0 5
21122: PPUSH
21123: LD_INT 4
21125: PPUSH
21126: LD_VAR 0 8
21130: PPUSH
21131: CALL_OW 1
21135: ST_TO_ADDR
// end ;
21136: LD_VAR 0 5
21140: RET
// export function DangerAtRange ( unit , range ) ; begin
21141: LD_INT 0
21143: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21144: LD_ADDR_VAR 0 3
21148: PUSH
21149: LD_VAR 0 1
21153: PPUSH
21154: CALL_OW 255
21158: PPUSH
21159: LD_VAR 0 1
21163: PPUSH
21164: CALL_OW 250
21168: PPUSH
21169: LD_VAR 0 1
21173: PPUSH
21174: CALL_OW 251
21178: PPUSH
21179: LD_VAR 0 2
21183: PPUSH
21184: CALL 19444 0 4
21188: ST_TO_ADDR
// end ;
21189: LD_VAR 0 3
21193: RET
// export function DangerInArea ( side , area ) ; begin
21194: LD_INT 0
21196: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21197: LD_ADDR_VAR 0 3
21201: PUSH
21202: LD_VAR 0 2
21206: PPUSH
21207: LD_INT 81
21209: PUSH
21210: LD_VAR 0 1
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PPUSH
21219: CALL_OW 70
21223: ST_TO_ADDR
// end ;
21224: LD_VAR 0 3
21228: RET
// export function IsExtension ( b ) ; begin
21229: LD_INT 0
21231: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21232: LD_ADDR_VAR 0 2
21236: PUSH
21237: LD_VAR 0 1
21241: PUSH
21242: LD_INT 23
21244: PUSH
21245: LD_INT 20
21247: PUSH
21248: LD_INT 22
21250: PUSH
21251: LD_INT 17
21253: PUSH
21254: LD_INT 24
21256: PUSH
21257: LD_INT 21
21259: PUSH
21260: LD_INT 19
21262: PUSH
21263: LD_INT 16
21265: PUSH
21266: LD_INT 25
21268: PUSH
21269: LD_INT 18
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: LIST
21283: IN
21284: ST_TO_ADDR
// end ;
21285: LD_VAR 0 2
21289: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21290: LD_INT 0
21292: PPUSH
21293: PPUSH
21294: PPUSH
// result := [ ] ;
21295: LD_ADDR_VAR 0 3
21299: PUSH
21300: EMPTY
21301: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21302: LD_ADDR_VAR 0 4
21306: PUSH
21307: LD_VAR 0 2
21311: PPUSH
21312: LD_INT 21
21314: PUSH
21315: LD_INT 3
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: PPUSH
21322: CALL_OW 70
21326: ST_TO_ADDR
// if not tmp then
21327: LD_VAR 0 4
21331: NOT
21332: IFFALSE 21336
// exit ;
21334: GO 21394
// for i in tmp do
21336: LD_ADDR_VAR 0 5
21340: PUSH
21341: LD_VAR 0 4
21345: PUSH
21346: FOR_IN
21347: IFFALSE 21382
// if GetBase ( i ) <> base then
21349: LD_VAR 0 5
21353: PPUSH
21354: CALL_OW 274
21358: PUSH
21359: LD_VAR 0 1
21363: NONEQUAL
21364: IFFALSE 21380
// ComLinkToBase ( base , i ) ;
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 5
21375: PPUSH
21376: CALL_OW 169
21380: GO 21346
21382: POP
21383: POP
// result := tmp ;
21384: LD_ADDR_VAR 0 3
21388: PUSH
21389: LD_VAR 0 4
21393: ST_TO_ADDR
// end ;
21394: LD_VAR 0 3
21398: RET
// export function ComComplete ( unit , b ) ; var i ; begin
21399: LD_INT 0
21401: PPUSH
21402: PPUSH
// if BuildingStatus ( b ) = bs_build then
21403: LD_VAR 0 2
21407: PPUSH
21408: CALL_OW 461
21412: PUSH
21413: LD_INT 1
21415: EQUAL
21416: IFFALSE 21476
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21418: LD_VAR 0 1
21422: PPUSH
21423: LD_STRING h
21425: PUSH
21426: LD_VAR 0 2
21430: PPUSH
21431: CALL_OW 250
21435: PUSH
21436: LD_VAR 0 2
21440: PPUSH
21441: CALL_OW 251
21445: PUSH
21446: LD_VAR 0 2
21450: PUSH
21451: LD_INT 0
21453: PUSH
21454: LD_INT 0
21456: PUSH
21457: LD_INT 0
21459: PUSH
21460: EMPTY
21461: LIST
21462: LIST
21463: LIST
21464: LIST
21465: LIST
21466: LIST
21467: LIST
21468: PUSH
21469: EMPTY
21470: LIST
21471: PPUSH
21472: CALL_OW 446
// end ;
21476: LD_VAR 0 3
21480: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21481: LD_INT 0
21483: PPUSH
21484: PPUSH
21485: PPUSH
21486: PPUSH
21487: PPUSH
21488: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
21489: LD_VAR 0 1
21493: NOT
21494: PUSH
21495: LD_VAR 0 1
21499: PPUSH
21500: CALL_OW 263
21504: PUSH
21505: LD_INT 2
21507: EQUAL
21508: NOT
21509: OR
21510: IFFALSE 21514
// exit ;
21512: GO 21830
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21514: LD_ADDR_VAR 0 6
21518: PUSH
21519: LD_INT 22
21521: PUSH
21522: LD_VAR 0 1
21526: PPUSH
21527: CALL_OW 255
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: PUSH
21536: LD_INT 2
21538: PUSH
21539: LD_INT 30
21541: PUSH
21542: LD_INT 36
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PUSH
21549: LD_INT 34
21551: PUSH
21552: LD_INT 31
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: PUSH
21559: EMPTY
21560: LIST
21561: LIST
21562: LIST
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: PPUSH
21568: CALL_OW 69
21572: ST_TO_ADDR
// if not tmp then
21573: LD_VAR 0 6
21577: NOT
21578: IFFALSE 21582
// exit ;
21580: GO 21830
// result := [ ] ;
21582: LD_ADDR_VAR 0 2
21586: PUSH
21587: EMPTY
21588: ST_TO_ADDR
// for i in tmp do
21589: LD_ADDR_VAR 0 3
21593: PUSH
21594: LD_VAR 0 6
21598: PUSH
21599: FOR_IN
21600: IFFALSE 21671
// begin t := UnitsInside ( i ) ;
21602: LD_ADDR_VAR 0 4
21606: PUSH
21607: LD_VAR 0 3
21611: PPUSH
21612: CALL_OW 313
21616: ST_TO_ADDR
// if t then
21617: LD_VAR 0 4
21621: IFFALSE 21669
// for j in t do
21623: LD_ADDR_VAR 0 7
21627: PUSH
21628: LD_VAR 0 4
21632: PUSH
21633: FOR_IN
21634: IFFALSE 21667
// result := Insert ( result , result + 1 , j ) ;
21636: LD_ADDR_VAR 0 2
21640: PUSH
21641: LD_VAR 0 2
21645: PPUSH
21646: LD_VAR 0 2
21650: PUSH
21651: LD_INT 1
21653: PLUS
21654: PPUSH
21655: LD_VAR 0 7
21659: PPUSH
21660: CALL_OW 2
21664: ST_TO_ADDR
21665: GO 21633
21667: POP
21668: POP
// end ;
21669: GO 21599
21671: POP
21672: POP
// if not result then
21673: LD_VAR 0 2
21677: NOT
21678: IFFALSE 21682
// exit ;
21680: GO 21830
// mech := result [ 1 ] ;
21682: LD_ADDR_VAR 0 5
21686: PUSH
21687: LD_VAR 0 2
21691: PUSH
21692: LD_INT 1
21694: ARRAY
21695: ST_TO_ADDR
// if result > 1 then
21696: LD_VAR 0 2
21700: PUSH
21701: LD_INT 1
21703: GREATER
21704: IFFALSE 21816
// for i = 2 to result do
21706: LD_ADDR_VAR 0 3
21710: PUSH
21711: DOUBLE
21712: LD_INT 2
21714: DEC
21715: ST_TO_ADDR
21716: LD_VAR 0 2
21720: PUSH
21721: FOR_TO
21722: IFFALSE 21814
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21724: LD_ADDR_VAR 0 4
21728: PUSH
21729: LD_VAR 0 2
21733: PUSH
21734: LD_VAR 0 3
21738: ARRAY
21739: PPUSH
21740: LD_INT 3
21742: PPUSH
21743: CALL_OW 259
21747: PUSH
21748: LD_VAR 0 2
21752: PUSH
21753: LD_VAR 0 3
21757: ARRAY
21758: PPUSH
21759: CALL_OW 432
21763: MINUS
21764: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21765: LD_VAR 0 4
21769: PUSH
21770: LD_VAR 0 5
21774: PPUSH
21775: LD_INT 3
21777: PPUSH
21778: CALL_OW 259
21782: PUSH
21783: LD_VAR 0 5
21787: PPUSH
21788: CALL_OW 432
21792: MINUS
21793: GREATEREQUAL
21794: IFFALSE 21812
// mech := result [ i ] ;
21796: LD_ADDR_VAR 0 5
21800: PUSH
21801: LD_VAR 0 2
21805: PUSH
21806: LD_VAR 0 3
21810: ARRAY
21811: ST_TO_ADDR
// end ;
21812: GO 21721
21814: POP
21815: POP
// ComLinkTo ( vehicle , mech ) ;
21816: LD_VAR 0 1
21820: PPUSH
21821: LD_VAR 0 5
21825: PPUSH
21826: CALL_OW 135
// end ;
21830: LD_VAR 0 2
21834: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21835: LD_INT 0
21837: PPUSH
21838: PPUSH
21839: PPUSH
21840: PPUSH
21841: PPUSH
21842: PPUSH
21843: PPUSH
21844: PPUSH
21845: PPUSH
21846: PPUSH
21847: PPUSH
21848: PPUSH
21849: PPUSH
// result := [ ] ;
21850: LD_ADDR_VAR 0 7
21854: PUSH
21855: EMPTY
21856: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21857: LD_VAR 0 1
21861: PPUSH
21862: CALL_OW 266
21866: PUSH
21867: LD_INT 0
21869: PUSH
21870: LD_INT 1
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: IN
21877: NOT
21878: IFFALSE 21882
// exit ;
21880: GO 23513
// if name then
21882: LD_VAR 0 3
21886: IFFALSE 21902
// SetBName ( base_dep , name ) ;
21888: LD_VAR 0 1
21892: PPUSH
21893: LD_VAR 0 3
21897: PPUSH
21898: CALL_OW 500
// base := GetBase ( base_dep ) ;
21902: LD_ADDR_VAR 0 15
21906: PUSH
21907: LD_VAR 0 1
21911: PPUSH
21912: CALL_OW 274
21916: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21917: LD_ADDR_VAR 0 16
21921: PUSH
21922: LD_VAR 0 1
21926: PPUSH
21927: CALL_OW 255
21931: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21932: LD_ADDR_VAR 0 17
21936: PUSH
21937: LD_VAR 0 1
21941: PPUSH
21942: CALL_OW 248
21946: ST_TO_ADDR
// if sources then
21947: LD_VAR 0 5
21951: IFFALSE 21998
// for i = 1 to 3 do
21953: LD_ADDR_VAR 0 8
21957: PUSH
21958: DOUBLE
21959: LD_INT 1
21961: DEC
21962: ST_TO_ADDR
21963: LD_INT 3
21965: PUSH
21966: FOR_TO
21967: IFFALSE 21996
// AddResourceType ( base , i , sources [ i ] ) ;
21969: LD_VAR 0 15
21973: PPUSH
21974: LD_VAR 0 8
21978: PPUSH
21979: LD_VAR 0 5
21983: PUSH
21984: LD_VAR 0 8
21988: ARRAY
21989: PPUSH
21990: CALL_OW 276
21994: GO 21966
21996: POP
21997: POP
// buildings := GetBaseBuildings ( base , area ) ;
21998: LD_ADDR_VAR 0 18
22002: PUSH
22003: LD_VAR 0 15
22007: PPUSH
22008: LD_VAR 0 2
22012: PPUSH
22013: CALL 21290 0 2
22017: ST_TO_ADDR
// InitHc ;
22018: CALL_OW 19
// InitUc ;
22022: CALL_OW 18
// uc_side := side ;
22026: LD_ADDR_OWVAR 20
22030: PUSH
22031: LD_VAR 0 16
22035: ST_TO_ADDR
// uc_nation := nation ;
22036: LD_ADDR_OWVAR 21
22040: PUSH
22041: LD_VAR 0 17
22045: ST_TO_ADDR
// if buildings then
22046: LD_VAR 0 18
22050: IFFALSE 23372
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22052: LD_ADDR_VAR 0 19
22056: PUSH
22057: LD_VAR 0 18
22061: PPUSH
22062: LD_INT 2
22064: PUSH
22065: LD_INT 30
22067: PUSH
22068: LD_INT 29
22070: PUSH
22071: EMPTY
22072: LIST
22073: LIST
22074: PUSH
22075: LD_INT 30
22077: PUSH
22078: LD_INT 30
22080: PUSH
22081: EMPTY
22082: LIST
22083: LIST
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: LIST
22089: PPUSH
22090: CALL_OW 72
22094: ST_TO_ADDR
// if tmp then
22095: LD_VAR 0 19
22099: IFFALSE 22147
// for i in tmp do
22101: LD_ADDR_VAR 0 8
22105: PUSH
22106: LD_VAR 0 19
22110: PUSH
22111: FOR_IN
22112: IFFALSE 22145
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22114: LD_VAR 0 8
22118: PPUSH
22119: CALL_OW 250
22123: PPUSH
22124: LD_VAR 0 8
22128: PPUSH
22129: CALL_OW 251
22133: PPUSH
22134: LD_VAR 0 16
22138: PPUSH
22139: CALL_OW 441
22143: GO 22111
22145: POP
22146: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22147: LD_VAR 0 18
22151: PPUSH
22152: LD_INT 2
22154: PUSH
22155: LD_INT 30
22157: PUSH
22158: LD_INT 32
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: PUSH
22165: LD_INT 30
22167: PUSH
22168: LD_INT 33
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: LIST
22179: PPUSH
22180: CALL_OW 72
22184: IFFALSE 22272
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22186: LD_ADDR_VAR 0 8
22190: PUSH
22191: LD_VAR 0 18
22195: PPUSH
22196: LD_INT 2
22198: PUSH
22199: LD_INT 30
22201: PUSH
22202: LD_INT 32
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: PUSH
22209: LD_INT 30
22211: PUSH
22212: LD_INT 33
22214: PUSH
22215: EMPTY
22216: LIST
22217: LIST
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: LIST
22223: PPUSH
22224: CALL_OW 72
22228: PUSH
22229: FOR_IN
22230: IFFALSE 22270
// begin if not GetBWeapon ( i ) then
22232: LD_VAR 0 8
22236: PPUSH
22237: CALL_OW 269
22241: NOT
22242: IFFALSE 22268
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22244: LD_VAR 0 8
22248: PPUSH
22249: LD_VAR 0 8
22253: PPUSH
22254: LD_VAR 0 2
22258: PPUSH
22259: CALL 23518 0 2
22263: PPUSH
22264: CALL_OW 431
// end ;
22268: GO 22229
22270: POP
22271: POP
// end ; for i = 1 to personel do
22272: LD_ADDR_VAR 0 8
22276: PUSH
22277: DOUBLE
22278: LD_INT 1
22280: DEC
22281: ST_TO_ADDR
22282: LD_VAR 0 6
22286: PUSH
22287: FOR_TO
22288: IFFALSE 23352
// begin if i > 4 then
22290: LD_VAR 0 8
22294: PUSH
22295: LD_INT 4
22297: GREATER
22298: IFFALSE 22302
// break ;
22300: GO 23352
// case i of 1 :
22302: LD_VAR 0 8
22306: PUSH
22307: LD_INT 1
22309: DOUBLE
22310: EQUAL
22311: IFTRUE 22315
22313: GO 22395
22315: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22316: LD_ADDR_VAR 0 12
22320: PUSH
22321: LD_VAR 0 18
22325: PPUSH
22326: LD_INT 22
22328: PUSH
22329: LD_VAR 0 16
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: PUSH
22338: LD_INT 58
22340: PUSH
22341: EMPTY
22342: LIST
22343: PUSH
22344: LD_INT 2
22346: PUSH
22347: LD_INT 30
22349: PUSH
22350: LD_INT 32
22352: PUSH
22353: EMPTY
22354: LIST
22355: LIST
22356: PUSH
22357: LD_INT 30
22359: PUSH
22360: LD_INT 4
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PUSH
22367: LD_INT 30
22369: PUSH
22370: LD_INT 5
22372: PUSH
22373: EMPTY
22374: LIST
22375: LIST
22376: PUSH
22377: EMPTY
22378: LIST
22379: LIST
22380: LIST
22381: LIST
22382: PUSH
22383: EMPTY
22384: LIST
22385: LIST
22386: LIST
22387: PPUSH
22388: CALL_OW 72
22392: ST_TO_ADDR
22393: GO 22617
22395: LD_INT 2
22397: DOUBLE
22398: EQUAL
22399: IFTRUE 22403
22401: GO 22465
22403: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22404: LD_ADDR_VAR 0 12
22408: PUSH
22409: LD_VAR 0 18
22413: PPUSH
22414: LD_INT 22
22416: PUSH
22417: LD_VAR 0 16
22421: PUSH
22422: EMPTY
22423: LIST
22424: LIST
22425: PUSH
22426: LD_INT 2
22428: PUSH
22429: LD_INT 30
22431: PUSH
22432: LD_INT 0
22434: PUSH
22435: EMPTY
22436: LIST
22437: LIST
22438: PUSH
22439: LD_INT 30
22441: PUSH
22442: LD_INT 1
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: PUSH
22449: EMPTY
22450: LIST
22451: LIST
22452: LIST
22453: PUSH
22454: EMPTY
22455: LIST
22456: LIST
22457: PPUSH
22458: CALL_OW 72
22462: ST_TO_ADDR
22463: GO 22617
22465: LD_INT 3
22467: DOUBLE
22468: EQUAL
22469: IFTRUE 22473
22471: GO 22535
22473: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22474: LD_ADDR_VAR 0 12
22478: PUSH
22479: LD_VAR 0 18
22483: PPUSH
22484: LD_INT 22
22486: PUSH
22487: LD_VAR 0 16
22491: PUSH
22492: EMPTY
22493: LIST
22494: LIST
22495: PUSH
22496: LD_INT 2
22498: PUSH
22499: LD_INT 30
22501: PUSH
22502: LD_INT 2
22504: PUSH
22505: EMPTY
22506: LIST
22507: LIST
22508: PUSH
22509: LD_INT 30
22511: PUSH
22512: LD_INT 3
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: LIST
22523: PUSH
22524: EMPTY
22525: LIST
22526: LIST
22527: PPUSH
22528: CALL_OW 72
22532: ST_TO_ADDR
22533: GO 22617
22535: LD_INT 4
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22616
22543: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22544: LD_ADDR_VAR 0 12
22548: PUSH
22549: LD_VAR 0 18
22553: PPUSH
22554: LD_INT 22
22556: PUSH
22557: LD_VAR 0 16
22561: PUSH
22562: EMPTY
22563: LIST
22564: LIST
22565: PUSH
22566: LD_INT 2
22568: PUSH
22569: LD_INT 30
22571: PUSH
22572: LD_INT 6
22574: PUSH
22575: EMPTY
22576: LIST
22577: LIST
22578: PUSH
22579: LD_INT 30
22581: PUSH
22582: LD_INT 7
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: LD_INT 30
22591: PUSH
22592: LD_INT 8
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: EMPTY
22600: LIST
22601: LIST
22602: LIST
22603: LIST
22604: PUSH
22605: EMPTY
22606: LIST
22607: LIST
22608: PPUSH
22609: CALL_OW 72
22613: ST_TO_ADDR
22614: GO 22617
22616: POP
// if i = 1 then
22617: LD_VAR 0 8
22621: PUSH
22622: LD_INT 1
22624: EQUAL
22625: IFFALSE 22736
// begin tmp := [ ] ;
22627: LD_ADDR_VAR 0 19
22631: PUSH
22632: EMPTY
22633: ST_TO_ADDR
// for j in f do
22634: LD_ADDR_VAR 0 9
22638: PUSH
22639: LD_VAR 0 12
22643: PUSH
22644: FOR_IN
22645: IFFALSE 22718
// if GetBType ( j ) = b_bunker then
22647: LD_VAR 0 9
22651: PPUSH
22652: CALL_OW 266
22656: PUSH
22657: LD_INT 32
22659: EQUAL
22660: IFFALSE 22687
// tmp := Insert ( tmp , 1 , j ) else
22662: LD_ADDR_VAR 0 19
22666: PUSH
22667: LD_VAR 0 19
22671: PPUSH
22672: LD_INT 1
22674: PPUSH
22675: LD_VAR 0 9
22679: PPUSH
22680: CALL_OW 2
22684: ST_TO_ADDR
22685: GO 22716
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22687: LD_ADDR_VAR 0 19
22691: PUSH
22692: LD_VAR 0 19
22696: PPUSH
22697: LD_VAR 0 19
22701: PUSH
22702: LD_INT 1
22704: PLUS
22705: PPUSH
22706: LD_VAR 0 9
22710: PPUSH
22711: CALL_OW 2
22715: ST_TO_ADDR
22716: GO 22644
22718: POP
22719: POP
// if tmp then
22720: LD_VAR 0 19
22724: IFFALSE 22736
// f := tmp ;
22726: LD_ADDR_VAR 0 12
22730: PUSH
22731: LD_VAR 0 19
22735: ST_TO_ADDR
// end ; x := personel [ i ] ;
22736: LD_ADDR_VAR 0 13
22740: PUSH
22741: LD_VAR 0 6
22745: PUSH
22746: LD_VAR 0 8
22750: ARRAY
22751: ST_TO_ADDR
// if x = - 1 then
22752: LD_VAR 0 13
22756: PUSH
22757: LD_INT 1
22759: NEG
22760: EQUAL
22761: IFFALSE 22970
// begin for j in f do
22763: LD_ADDR_VAR 0 9
22767: PUSH
22768: LD_VAR 0 12
22772: PUSH
22773: FOR_IN
22774: IFFALSE 22966
// repeat InitHc ;
22776: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22780: LD_VAR 0 9
22784: PPUSH
22785: CALL_OW 266
22789: PUSH
22790: LD_INT 5
22792: EQUAL
22793: IFFALSE 22863
// begin if UnitsInside ( j ) < 3 then
22795: LD_VAR 0 9
22799: PPUSH
22800: CALL_OW 313
22804: PUSH
22805: LD_INT 3
22807: LESS
22808: IFFALSE 22844
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22810: LD_INT 0
22812: PPUSH
22813: LD_INT 5
22815: PUSH
22816: LD_INT 8
22818: PUSH
22819: LD_INT 9
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: LIST
22826: PUSH
22827: LD_VAR 0 17
22831: ARRAY
22832: PPUSH
22833: LD_VAR 0 4
22837: PPUSH
22838: CALL_OW 380
22842: GO 22861
// PrepareHuman ( false , i , skill ) ;
22844: LD_INT 0
22846: PPUSH
22847: LD_VAR 0 8
22851: PPUSH
22852: LD_VAR 0 4
22856: PPUSH
22857: CALL_OW 380
// end else
22861: GO 22880
// PrepareHuman ( false , i , skill ) ;
22863: LD_INT 0
22865: PPUSH
22866: LD_VAR 0 8
22870: PPUSH
22871: LD_VAR 0 4
22875: PPUSH
22876: CALL_OW 380
// un := CreateHuman ;
22880: LD_ADDR_VAR 0 14
22884: PUSH
22885: CALL_OW 44
22889: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22890: LD_ADDR_VAR 0 7
22894: PUSH
22895: LD_VAR 0 7
22899: PPUSH
22900: LD_INT 1
22902: PPUSH
22903: LD_VAR 0 14
22907: PPUSH
22908: CALL_OW 2
22912: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22913: LD_VAR 0 14
22917: PPUSH
22918: LD_VAR 0 9
22922: PPUSH
22923: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22927: LD_VAR 0 9
22931: PPUSH
22932: CALL_OW 313
22936: PUSH
22937: LD_INT 6
22939: EQUAL
22940: PUSH
22941: LD_VAR 0 9
22945: PPUSH
22946: CALL_OW 266
22950: PUSH
22951: LD_INT 32
22953: PUSH
22954: LD_INT 31
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: IN
22961: OR
22962: IFFALSE 22776
22964: GO 22773
22966: POP
22967: POP
// end else
22968: GO 23350
// for j = 1 to x do
22970: LD_ADDR_VAR 0 9
22974: PUSH
22975: DOUBLE
22976: LD_INT 1
22978: DEC
22979: ST_TO_ADDR
22980: LD_VAR 0 13
22984: PUSH
22985: FOR_TO
22986: IFFALSE 23348
// begin InitHc ;
22988: CALL_OW 19
// if not f then
22992: LD_VAR 0 12
22996: NOT
22997: IFFALSE 23086
// begin PrepareHuman ( false , i , skill ) ;
22999: LD_INT 0
23001: PPUSH
23002: LD_VAR 0 8
23006: PPUSH
23007: LD_VAR 0 4
23011: PPUSH
23012: CALL_OW 380
// un := CreateHuman ;
23016: LD_ADDR_VAR 0 14
23020: PUSH
23021: CALL_OW 44
23025: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23026: LD_ADDR_VAR 0 7
23030: PUSH
23031: LD_VAR 0 7
23035: PPUSH
23036: LD_INT 1
23038: PPUSH
23039: LD_VAR 0 14
23043: PPUSH
23044: CALL_OW 2
23048: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23049: LD_VAR 0 14
23053: PPUSH
23054: LD_VAR 0 1
23058: PPUSH
23059: CALL_OW 250
23063: PPUSH
23064: LD_VAR 0 1
23068: PPUSH
23069: CALL_OW 251
23073: PPUSH
23074: LD_INT 10
23076: PPUSH
23077: LD_INT 0
23079: PPUSH
23080: CALL_OW 50
// continue ;
23084: GO 22985
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23086: LD_VAR 0 12
23090: PUSH
23091: LD_INT 1
23093: ARRAY
23094: PPUSH
23095: CALL_OW 313
23099: PUSH
23100: LD_VAR 0 12
23104: PUSH
23105: LD_INT 1
23107: ARRAY
23108: PPUSH
23109: CALL_OW 266
23113: PUSH
23114: LD_INT 32
23116: PUSH
23117: LD_INT 31
23119: PUSH
23120: EMPTY
23121: LIST
23122: LIST
23123: IN
23124: AND
23125: PUSH
23126: LD_VAR 0 12
23130: PUSH
23131: LD_INT 1
23133: ARRAY
23134: PPUSH
23135: CALL_OW 313
23139: PUSH
23140: LD_INT 6
23142: EQUAL
23143: OR
23144: IFFALSE 23164
// f := Delete ( f , 1 ) ;
23146: LD_ADDR_VAR 0 12
23150: PUSH
23151: LD_VAR 0 12
23155: PPUSH
23156: LD_INT 1
23158: PPUSH
23159: CALL_OW 3
23163: ST_TO_ADDR
// if not f then
23164: LD_VAR 0 12
23168: NOT
23169: IFFALSE 23187
// begin x := x + 2 ;
23171: LD_ADDR_VAR 0 13
23175: PUSH
23176: LD_VAR 0 13
23180: PUSH
23181: LD_INT 2
23183: PLUS
23184: ST_TO_ADDR
// continue ;
23185: GO 22985
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23187: LD_VAR 0 12
23191: PUSH
23192: LD_INT 1
23194: ARRAY
23195: PPUSH
23196: CALL_OW 266
23200: PUSH
23201: LD_INT 5
23203: EQUAL
23204: IFFALSE 23278
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23206: LD_VAR 0 12
23210: PUSH
23211: LD_INT 1
23213: ARRAY
23214: PPUSH
23215: CALL_OW 313
23219: PUSH
23220: LD_INT 3
23222: LESS
23223: IFFALSE 23259
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23225: LD_INT 0
23227: PPUSH
23228: LD_INT 5
23230: PUSH
23231: LD_INT 8
23233: PUSH
23234: LD_INT 9
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: LIST
23241: PUSH
23242: LD_VAR 0 17
23246: ARRAY
23247: PPUSH
23248: LD_VAR 0 4
23252: PPUSH
23253: CALL_OW 380
23257: GO 23276
// PrepareHuman ( false , i , skill ) ;
23259: LD_INT 0
23261: PPUSH
23262: LD_VAR 0 8
23266: PPUSH
23267: LD_VAR 0 4
23271: PPUSH
23272: CALL_OW 380
// end else
23276: GO 23295
// PrepareHuman ( false , i , skill ) ;
23278: LD_INT 0
23280: PPUSH
23281: LD_VAR 0 8
23285: PPUSH
23286: LD_VAR 0 4
23290: PPUSH
23291: CALL_OW 380
// un := CreateHuman ;
23295: LD_ADDR_VAR 0 14
23299: PUSH
23300: CALL_OW 44
23304: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23305: LD_ADDR_VAR 0 7
23309: PUSH
23310: LD_VAR 0 7
23314: PPUSH
23315: LD_INT 1
23317: PPUSH
23318: LD_VAR 0 14
23322: PPUSH
23323: CALL_OW 2
23327: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23328: LD_VAR 0 14
23332: PPUSH
23333: LD_VAR 0 12
23337: PUSH
23338: LD_INT 1
23340: ARRAY
23341: PPUSH
23342: CALL_OW 52
// end ;
23346: GO 22985
23348: POP
23349: POP
// end ;
23350: GO 22287
23352: POP
23353: POP
// result := result ^ buildings ;
23354: LD_ADDR_VAR 0 7
23358: PUSH
23359: LD_VAR 0 7
23363: PUSH
23364: LD_VAR 0 18
23368: ADD
23369: ST_TO_ADDR
// end else
23370: GO 23513
// begin for i = 1 to personel do
23372: LD_ADDR_VAR 0 8
23376: PUSH
23377: DOUBLE
23378: LD_INT 1
23380: DEC
23381: ST_TO_ADDR
23382: LD_VAR 0 6
23386: PUSH
23387: FOR_TO
23388: IFFALSE 23511
// begin if i > 4 then
23390: LD_VAR 0 8
23394: PUSH
23395: LD_INT 4
23397: GREATER
23398: IFFALSE 23402
// break ;
23400: GO 23511
// x := personel [ i ] ;
23402: LD_ADDR_VAR 0 13
23406: PUSH
23407: LD_VAR 0 6
23411: PUSH
23412: LD_VAR 0 8
23416: ARRAY
23417: ST_TO_ADDR
// if x = - 1 then
23418: LD_VAR 0 13
23422: PUSH
23423: LD_INT 1
23425: NEG
23426: EQUAL
23427: IFFALSE 23431
// continue ;
23429: GO 23387
// PrepareHuman ( false , i , skill ) ;
23431: LD_INT 0
23433: PPUSH
23434: LD_VAR 0 8
23438: PPUSH
23439: LD_VAR 0 4
23443: PPUSH
23444: CALL_OW 380
// un := CreateHuman ;
23448: LD_ADDR_VAR 0 14
23452: PUSH
23453: CALL_OW 44
23457: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23458: LD_VAR 0 14
23462: PPUSH
23463: LD_VAR 0 1
23467: PPUSH
23468: CALL_OW 250
23472: PPUSH
23473: LD_VAR 0 1
23477: PPUSH
23478: CALL_OW 251
23482: PPUSH
23483: LD_INT 10
23485: PPUSH
23486: LD_INT 0
23488: PPUSH
23489: CALL_OW 50
// result := result ^ un ;
23493: LD_ADDR_VAR 0 7
23497: PUSH
23498: LD_VAR 0 7
23502: PUSH
23503: LD_VAR 0 14
23507: ADD
23508: ST_TO_ADDR
// end ;
23509: GO 23387
23511: POP
23512: POP
// end ; end ;
23513: LD_VAR 0 7
23517: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23518: LD_INT 0
23520: PPUSH
23521: PPUSH
23522: PPUSH
23523: PPUSH
23524: PPUSH
23525: PPUSH
23526: PPUSH
23527: PPUSH
23528: PPUSH
23529: PPUSH
23530: PPUSH
23531: PPUSH
23532: PPUSH
23533: PPUSH
23534: PPUSH
23535: PPUSH
// result := false ;
23536: LD_ADDR_VAR 0 3
23540: PUSH
23541: LD_INT 0
23543: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23544: LD_VAR 0 1
23548: NOT
23549: PUSH
23550: LD_VAR 0 1
23554: PPUSH
23555: CALL_OW 266
23559: PUSH
23560: LD_INT 32
23562: PUSH
23563: LD_INT 33
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: IN
23570: NOT
23571: OR
23572: IFFALSE 23576
// exit ;
23574: GO 24712
// nat := GetNation ( tower ) ;
23576: LD_ADDR_VAR 0 12
23580: PUSH
23581: LD_VAR 0 1
23585: PPUSH
23586: CALL_OW 248
23590: ST_TO_ADDR
// side := GetSide ( tower ) ;
23591: LD_ADDR_VAR 0 16
23595: PUSH
23596: LD_VAR 0 1
23600: PPUSH
23601: CALL_OW 255
23605: ST_TO_ADDR
// x := GetX ( tower ) ;
23606: LD_ADDR_VAR 0 10
23610: PUSH
23611: LD_VAR 0 1
23615: PPUSH
23616: CALL_OW 250
23620: ST_TO_ADDR
// y := GetY ( tower ) ;
23621: LD_ADDR_VAR 0 11
23625: PUSH
23626: LD_VAR 0 1
23630: PPUSH
23631: CALL_OW 251
23635: ST_TO_ADDR
// if not x or not y then
23636: LD_VAR 0 10
23640: NOT
23641: PUSH
23642: LD_VAR 0 11
23646: NOT
23647: OR
23648: IFFALSE 23652
// exit ;
23650: GO 24712
// weapon := 0 ;
23652: LD_ADDR_VAR 0 18
23656: PUSH
23657: LD_INT 0
23659: ST_TO_ADDR
// fac_list := [ ] ;
23660: LD_ADDR_VAR 0 17
23664: PUSH
23665: EMPTY
23666: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
23667: LD_ADDR_VAR 0 6
23671: PUSH
23672: LD_VAR 0 1
23676: PPUSH
23677: CALL_OW 274
23681: PPUSH
23682: LD_VAR 0 2
23686: PPUSH
23687: CALL 21290 0 2
23691: PPUSH
23692: LD_INT 30
23694: PUSH
23695: LD_INT 3
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PPUSH
23702: CALL_OW 72
23706: ST_TO_ADDR
// if not factories then
23707: LD_VAR 0 6
23711: NOT
23712: IFFALSE 23716
// exit ;
23714: GO 24712
// for i in factories do
23716: LD_ADDR_VAR 0 8
23720: PUSH
23721: LD_VAR 0 6
23725: PUSH
23726: FOR_IN
23727: IFFALSE 23752
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23729: LD_ADDR_VAR 0 17
23733: PUSH
23734: LD_VAR 0 17
23738: PUSH
23739: LD_VAR 0 8
23743: PPUSH
23744: CALL_OW 478
23748: UNION
23749: ST_TO_ADDR
23750: GO 23726
23752: POP
23753: POP
// if not fac_list then
23754: LD_VAR 0 17
23758: NOT
23759: IFFALSE 23763
// exit ;
23761: GO 24712
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23763: LD_ADDR_VAR 0 5
23767: PUSH
23768: LD_INT 4
23770: PUSH
23771: LD_INT 5
23773: PUSH
23774: LD_INT 9
23776: PUSH
23777: LD_INT 10
23779: PUSH
23780: LD_INT 6
23782: PUSH
23783: LD_INT 7
23785: PUSH
23786: LD_INT 11
23788: PUSH
23789: EMPTY
23790: LIST
23791: LIST
23792: LIST
23793: LIST
23794: LIST
23795: LIST
23796: LIST
23797: PUSH
23798: LD_INT 27
23800: PUSH
23801: LD_INT 28
23803: PUSH
23804: LD_INT 26
23806: PUSH
23807: LD_INT 30
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: LIST
23814: LIST
23815: PUSH
23816: LD_INT 43
23818: PUSH
23819: LD_INT 44
23821: PUSH
23822: LD_INT 46
23824: PUSH
23825: LD_INT 45
23827: PUSH
23828: LD_INT 47
23830: PUSH
23831: LD_INT 49
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: LIST
23841: PUSH
23842: EMPTY
23843: LIST
23844: LIST
23845: LIST
23846: PUSH
23847: LD_VAR 0 12
23851: ARRAY
23852: ST_TO_ADDR
// for i in list do
23853: LD_ADDR_VAR 0 8
23857: PUSH
23858: LD_VAR 0 5
23862: PUSH
23863: FOR_IN
23864: IFFALSE 23897
// if not i in fac_list then
23866: LD_VAR 0 8
23870: PUSH
23871: LD_VAR 0 17
23875: IN
23876: NOT
23877: IFFALSE 23895
// list := list diff i ;
23879: LD_ADDR_VAR 0 5
23883: PUSH
23884: LD_VAR 0 5
23888: PUSH
23889: LD_VAR 0 8
23893: DIFF
23894: ST_TO_ADDR
23895: GO 23863
23897: POP
23898: POP
// if not list then
23899: LD_VAR 0 5
23903: NOT
23904: IFFALSE 23908
// exit ;
23906: GO 24712
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23908: LD_VAR 0 12
23912: PUSH
23913: LD_INT 3
23915: EQUAL
23916: PUSH
23917: LD_INT 49
23919: PUSH
23920: LD_VAR 0 5
23924: IN
23925: AND
23926: PUSH
23927: LD_INT 31
23929: PPUSH
23930: LD_VAR 0 16
23934: PPUSH
23935: CALL_OW 321
23939: PUSH
23940: LD_INT 2
23942: EQUAL
23943: AND
23944: IFFALSE 24004
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23946: LD_INT 22
23948: PUSH
23949: LD_VAR 0 16
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: LD_INT 35
23960: PUSH
23961: LD_INT 49
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: LD_INT 91
23970: PUSH
23971: LD_VAR 0 1
23975: PUSH
23976: LD_INT 10
23978: PUSH
23979: EMPTY
23980: LIST
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PPUSH
23989: CALL_OW 69
23993: NOT
23994: IFFALSE 24004
// weapon := ru_time_lapser ;
23996: LD_ADDR_VAR 0 18
24000: PUSH
24001: LD_INT 49
24003: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24004: LD_VAR 0 12
24008: PUSH
24009: LD_INT 1
24011: PUSH
24012: LD_INT 2
24014: PUSH
24015: EMPTY
24016: LIST
24017: LIST
24018: IN
24019: PUSH
24020: LD_INT 11
24022: PUSH
24023: LD_VAR 0 5
24027: IN
24028: PUSH
24029: LD_INT 30
24031: PUSH
24032: LD_VAR 0 5
24036: IN
24037: OR
24038: AND
24039: PUSH
24040: LD_INT 6
24042: PPUSH
24043: LD_VAR 0 16
24047: PPUSH
24048: CALL_OW 321
24052: PUSH
24053: LD_INT 2
24055: EQUAL
24056: AND
24057: IFFALSE 24222
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24059: LD_INT 22
24061: PUSH
24062: LD_VAR 0 16
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: PUSH
24071: LD_INT 2
24073: PUSH
24074: LD_INT 35
24076: PUSH
24077: LD_INT 11
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 35
24086: PUSH
24087: LD_INT 30
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: LIST
24098: PUSH
24099: LD_INT 91
24101: PUSH
24102: LD_VAR 0 1
24106: PUSH
24107: LD_INT 18
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: LIST
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: LIST
24119: PPUSH
24120: CALL_OW 69
24124: NOT
24125: PUSH
24126: LD_INT 22
24128: PUSH
24129: LD_VAR 0 16
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: PUSH
24138: LD_INT 2
24140: PUSH
24141: LD_INT 30
24143: PUSH
24144: LD_INT 32
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: PUSH
24151: LD_INT 30
24153: PUSH
24154: LD_INT 33
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: PUSH
24166: LD_INT 91
24168: PUSH
24169: LD_VAR 0 1
24173: PUSH
24174: LD_INT 12
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: LIST
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: LIST
24186: PUSH
24187: EMPTY
24188: LIST
24189: PPUSH
24190: CALL_OW 69
24194: PUSH
24195: LD_INT 2
24197: GREATER
24198: AND
24199: IFFALSE 24222
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24201: LD_ADDR_VAR 0 18
24205: PUSH
24206: LD_INT 11
24208: PUSH
24209: LD_INT 30
24211: PUSH
24212: EMPTY
24213: LIST
24214: LIST
24215: PUSH
24216: LD_VAR 0 12
24220: ARRAY
24221: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24222: LD_VAR 0 18
24226: NOT
24227: PUSH
24228: LD_INT 40
24230: PPUSH
24231: LD_VAR 0 16
24235: PPUSH
24236: CALL_OW 321
24240: PUSH
24241: LD_INT 2
24243: EQUAL
24244: AND
24245: PUSH
24246: LD_INT 7
24248: PUSH
24249: LD_VAR 0 5
24253: IN
24254: PUSH
24255: LD_INT 28
24257: PUSH
24258: LD_VAR 0 5
24262: IN
24263: OR
24264: PUSH
24265: LD_INT 45
24267: PUSH
24268: LD_VAR 0 5
24272: IN
24273: OR
24274: AND
24275: IFFALSE 24529
// begin hex := GetHexInfo ( x , y ) ;
24277: LD_ADDR_VAR 0 4
24281: PUSH
24282: LD_VAR 0 10
24286: PPUSH
24287: LD_VAR 0 11
24291: PPUSH
24292: CALL_OW 546
24296: ST_TO_ADDR
// if hex [ 1 ] then
24297: LD_VAR 0 4
24301: PUSH
24302: LD_INT 1
24304: ARRAY
24305: IFFALSE 24309
// exit ;
24307: GO 24712
// height := hex [ 2 ] ;
24309: LD_ADDR_VAR 0 15
24313: PUSH
24314: LD_VAR 0 4
24318: PUSH
24319: LD_INT 2
24321: ARRAY
24322: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24323: LD_ADDR_VAR 0 14
24327: PUSH
24328: LD_INT 0
24330: PUSH
24331: LD_INT 2
24333: PUSH
24334: LD_INT 3
24336: PUSH
24337: LD_INT 5
24339: PUSH
24340: EMPTY
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: ST_TO_ADDR
// for i in tmp do
24346: LD_ADDR_VAR 0 8
24350: PUSH
24351: LD_VAR 0 14
24355: PUSH
24356: FOR_IN
24357: IFFALSE 24527
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24359: LD_ADDR_VAR 0 9
24363: PUSH
24364: LD_VAR 0 10
24368: PPUSH
24369: LD_VAR 0 8
24373: PPUSH
24374: LD_INT 5
24376: PPUSH
24377: CALL_OW 272
24381: PUSH
24382: LD_VAR 0 11
24386: PPUSH
24387: LD_VAR 0 8
24391: PPUSH
24392: LD_INT 5
24394: PPUSH
24395: CALL_OW 273
24399: PUSH
24400: EMPTY
24401: LIST
24402: LIST
24403: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24404: LD_VAR 0 9
24408: PUSH
24409: LD_INT 1
24411: ARRAY
24412: PPUSH
24413: LD_VAR 0 9
24417: PUSH
24418: LD_INT 2
24420: ARRAY
24421: PPUSH
24422: CALL_OW 488
24426: IFFALSE 24525
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24428: LD_ADDR_VAR 0 4
24432: PUSH
24433: LD_VAR 0 9
24437: PUSH
24438: LD_INT 1
24440: ARRAY
24441: PPUSH
24442: LD_VAR 0 9
24446: PUSH
24447: LD_INT 2
24449: ARRAY
24450: PPUSH
24451: CALL_OW 546
24455: ST_TO_ADDR
// if hex [ 1 ] then
24456: LD_VAR 0 4
24460: PUSH
24461: LD_INT 1
24463: ARRAY
24464: IFFALSE 24468
// continue ;
24466: GO 24356
// h := hex [ 2 ] ;
24468: LD_ADDR_VAR 0 13
24472: PUSH
24473: LD_VAR 0 4
24477: PUSH
24478: LD_INT 2
24480: ARRAY
24481: ST_TO_ADDR
// if h + 7 < height then
24482: LD_VAR 0 13
24486: PUSH
24487: LD_INT 7
24489: PLUS
24490: PUSH
24491: LD_VAR 0 15
24495: LESS
24496: IFFALSE 24525
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24498: LD_ADDR_VAR 0 18
24502: PUSH
24503: LD_INT 7
24505: PUSH
24506: LD_INT 28
24508: PUSH
24509: LD_INT 45
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: LIST
24516: PUSH
24517: LD_VAR 0 12
24521: ARRAY
24522: ST_TO_ADDR
// break ;
24523: GO 24527
// end ; end ; end ;
24525: GO 24356
24527: POP
24528: POP
// end ; if not weapon then
24529: LD_VAR 0 18
24533: NOT
24534: IFFALSE 24594
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24536: LD_ADDR_VAR 0 5
24540: PUSH
24541: LD_VAR 0 5
24545: PUSH
24546: LD_INT 11
24548: PUSH
24549: LD_INT 30
24551: PUSH
24552: LD_INT 49
24554: PUSH
24555: EMPTY
24556: LIST
24557: LIST
24558: LIST
24559: DIFF
24560: ST_TO_ADDR
// if not list then
24561: LD_VAR 0 5
24565: NOT
24566: IFFALSE 24570
// exit ;
24568: GO 24712
// weapon := list [ rand ( 1 , list ) ] ;
24570: LD_ADDR_VAR 0 18
24574: PUSH
24575: LD_VAR 0 5
24579: PUSH
24580: LD_INT 1
24582: PPUSH
24583: LD_VAR 0 5
24587: PPUSH
24588: CALL_OW 12
24592: ARRAY
24593: ST_TO_ADDR
// end ; if weapon then
24594: LD_VAR 0 18
24598: IFFALSE 24712
// begin tmp := CostOfWeapon ( weapon ) ;
24600: LD_ADDR_VAR 0 14
24604: PUSH
24605: LD_VAR 0 18
24609: PPUSH
24610: CALL_OW 451
24614: ST_TO_ADDR
// j := GetBase ( tower ) ;
24615: LD_ADDR_VAR 0 9
24619: PUSH
24620: LD_VAR 0 1
24624: PPUSH
24625: CALL_OW 274
24629: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24630: LD_VAR 0 9
24634: PPUSH
24635: LD_INT 1
24637: PPUSH
24638: CALL_OW 275
24642: PUSH
24643: LD_VAR 0 14
24647: PUSH
24648: LD_INT 1
24650: ARRAY
24651: GREATEREQUAL
24652: PUSH
24653: LD_VAR 0 9
24657: PPUSH
24658: LD_INT 2
24660: PPUSH
24661: CALL_OW 275
24665: PUSH
24666: LD_VAR 0 14
24670: PUSH
24671: LD_INT 2
24673: ARRAY
24674: GREATEREQUAL
24675: AND
24676: PUSH
24677: LD_VAR 0 9
24681: PPUSH
24682: LD_INT 3
24684: PPUSH
24685: CALL_OW 275
24689: PUSH
24690: LD_VAR 0 14
24694: PUSH
24695: LD_INT 3
24697: ARRAY
24698: GREATEREQUAL
24699: AND
24700: IFFALSE 24712
// result := weapon ;
24702: LD_ADDR_VAR 0 3
24706: PUSH
24707: LD_VAR 0 18
24711: ST_TO_ADDR
// end ; end ;
24712: LD_VAR 0 3
24716: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24717: LD_INT 0
24719: PPUSH
24720: PPUSH
// result := true ;
24721: LD_ADDR_VAR 0 3
24725: PUSH
24726: LD_INT 1
24728: ST_TO_ADDR
// if array1 = array2 then
24729: LD_VAR 0 1
24733: PUSH
24734: LD_VAR 0 2
24738: EQUAL
24739: IFFALSE 24799
// begin for i = 1 to array1 do
24741: LD_ADDR_VAR 0 4
24745: PUSH
24746: DOUBLE
24747: LD_INT 1
24749: DEC
24750: ST_TO_ADDR
24751: LD_VAR 0 1
24755: PUSH
24756: FOR_TO
24757: IFFALSE 24795
// if array1 [ i ] <> array2 [ i ] then
24759: LD_VAR 0 1
24763: PUSH
24764: LD_VAR 0 4
24768: ARRAY
24769: PUSH
24770: LD_VAR 0 2
24774: PUSH
24775: LD_VAR 0 4
24779: ARRAY
24780: NONEQUAL
24781: IFFALSE 24793
// begin result := false ;
24783: LD_ADDR_VAR 0 3
24787: PUSH
24788: LD_INT 0
24790: ST_TO_ADDR
// break ;
24791: GO 24795
// end ;
24793: GO 24756
24795: POP
24796: POP
// end else
24797: GO 24807
// result := false ;
24799: LD_ADDR_VAR 0 3
24803: PUSH
24804: LD_INT 0
24806: ST_TO_ADDR
// end ;
24807: LD_VAR 0 3
24811: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24812: LD_INT 0
24814: PPUSH
24815: PPUSH
24816: PPUSH
// pom := GetBase ( fac ) ;
24817: LD_ADDR_VAR 0 5
24821: PUSH
24822: LD_VAR 0 1
24826: PPUSH
24827: CALL_OW 274
24831: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24832: LD_ADDR_VAR 0 4
24836: PUSH
24837: LD_VAR 0 2
24841: PUSH
24842: LD_INT 1
24844: ARRAY
24845: PPUSH
24846: LD_VAR 0 2
24850: PUSH
24851: LD_INT 2
24853: ARRAY
24854: PPUSH
24855: LD_VAR 0 2
24859: PUSH
24860: LD_INT 3
24862: ARRAY
24863: PPUSH
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 4
24871: ARRAY
24872: PPUSH
24873: CALL_OW 449
24877: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24878: LD_ADDR_VAR 0 3
24882: PUSH
24883: LD_VAR 0 5
24887: PPUSH
24888: LD_INT 1
24890: PPUSH
24891: CALL_OW 275
24895: PUSH
24896: LD_VAR 0 4
24900: PUSH
24901: LD_INT 1
24903: ARRAY
24904: GREATEREQUAL
24905: PUSH
24906: LD_VAR 0 5
24910: PPUSH
24911: LD_INT 2
24913: PPUSH
24914: CALL_OW 275
24918: PUSH
24919: LD_VAR 0 4
24923: PUSH
24924: LD_INT 2
24926: ARRAY
24927: GREATEREQUAL
24928: AND
24929: PUSH
24930: LD_VAR 0 5
24934: PPUSH
24935: LD_INT 3
24937: PPUSH
24938: CALL_OW 275
24942: PUSH
24943: LD_VAR 0 4
24947: PUSH
24948: LD_INT 3
24950: ARRAY
24951: GREATEREQUAL
24952: AND
24953: ST_TO_ADDR
// end ;
24954: LD_VAR 0 3
24958: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
24959: LD_INT 0
24961: PPUSH
24962: PPUSH
24963: PPUSH
24964: PPUSH
// pom := GetBase ( building ) ;
24965: LD_ADDR_VAR 0 3
24969: PUSH
24970: LD_VAR 0 1
24974: PPUSH
24975: CALL_OW 274
24979: ST_TO_ADDR
// if not pom then
24980: LD_VAR 0 3
24984: NOT
24985: IFFALSE 24989
// exit ;
24987: GO 25159
// btype := GetBType ( building ) ;
24989: LD_ADDR_VAR 0 5
24993: PUSH
24994: LD_VAR 0 1
24998: PPUSH
24999: CALL_OW 266
25003: ST_TO_ADDR
// if btype = b_armoury then
25004: LD_VAR 0 5
25008: PUSH
25009: LD_INT 4
25011: EQUAL
25012: IFFALSE 25022
// btype := b_barracks ;
25014: LD_ADDR_VAR 0 5
25018: PUSH
25019: LD_INT 5
25021: ST_TO_ADDR
// if btype = b_depot then
25022: LD_VAR 0 5
25026: PUSH
25027: LD_INT 0
25029: EQUAL
25030: IFFALSE 25040
// btype := b_warehouse ;
25032: LD_ADDR_VAR 0 5
25036: PUSH
25037: LD_INT 1
25039: ST_TO_ADDR
// if btype = b_workshop then
25040: LD_VAR 0 5
25044: PUSH
25045: LD_INT 2
25047: EQUAL
25048: IFFALSE 25058
// btype := b_factory ;
25050: LD_ADDR_VAR 0 5
25054: PUSH
25055: LD_INT 3
25057: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25058: LD_ADDR_VAR 0 4
25062: PUSH
25063: LD_VAR 0 5
25067: PPUSH
25068: LD_VAR 0 1
25072: PPUSH
25073: CALL_OW 248
25077: PPUSH
25078: CALL_OW 450
25082: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25083: LD_ADDR_VAR 0 2
25087: PUSH
25088: LD_VAR 0 3
25092: PPUSH
25093: LD_INT 1
25095: PPUSH
25096: CALL_OW 275
25100: PUSH
25101: LD_VAR 0 4
25105: PUSH
25106: LD_INT 1
25108: ARRAY
25109: GREATEREQUAL
25110: PUSH
25111: LD_VAR 0 3
25115: PPUSH
25116: LD_INT 2
25118: PPUSH
25119: CALL_OW 275
25123: PUSH
25124: LD_VAR 0 4
25128: PUSH
25129: LD_INT 2
25131: ARRAY
25132: GREATEREQUAL
25133: AND
25134: PUSH
25135: LD_VAR 0 3
25139: PPUSH
25140: LD_INT 3
25142: PPUSH
25143: CALL_OW 275
25147: PUSH
25148: LD_VAR 0 4
25152: PUSH
25153: LD_INT 3
25155: ARRAY
25156: GREATEREQUAL
25157: AND
25158: ST_TO_ADDR
// end ;
25159: LD_VAR 0 2
25163: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25164: LD_INT 0
25166: PPUSH
25167: PPUSH
25168: PPUSH
// pom := GetBase ( building ) ;
25169: LD_ADDR_VAR 0 4
25173: PUSH
25174: LD_VAR 0 1
25178: PPUSH
25179: CALL_OW 274
25183: ST_TO_ADDR
// if not pom then
25184: LD_VAR 0 4
25188: NOT
25189: IFFALSE 25193
// exit ;
25191: GO 25294
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25193: LD_ADDR_VAR 0 5
25197: PUSH
25198: LD_VAR 0 2
25202: PPUSH
25203: LD_VAR 0 1
25207: PPUSH
25208: CALL_OW 248
25212: PPUSH
25213: CALL_OW 450
25217: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25218: LD_ADDR_VAR 0 3
25222: PUSH
25223: LD_VAR 0 4
25227: PPUSH
25228: LD_INT 1
25230: PPUSH
25231: CALL_OW 275
25235: PUSH
25236: LD_VAR 0 5
25240: PUSH
25241: LD_INT 1
25243: ARRAY
25244: GREATEREQUAL
25245: PUSH
25246: LD_VAR 0 4
25250: PPUSH
25251: LD_INT 2
25253: PPUSH
25254: CALL_OW 275
25258: PUSH
25259: LD_VAR 0 5
25263: PUSH
25264: LD_INT 2
25266: ARRAY
25267: GREATEREQUAL
25268: AND
25269: PUSH
25270: LD_VAR 0 4
25274: PPUSH
25275: LD_INT 3
25277: PPUSH
25278: CALL_OW 275
25282: PUSH
25283: LD_VAR 0 5
25287: PUSH
25288: LD_INT 3
25290: ARRAY
25291: GREATEREQUAL
25292: AND
25293: ST_TO_ADDR
// end ;
25294: LD_VAR 0 3
25298: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25299: LD_INT 0
25301: PPUSH
25302: PPUSH
25303: PPUSH
25304: PPUSH
25305: PPUSH
25306: PPUSH
25307: PPUSH
25308: PPUSH
25309: PPUSH
25310: PPUSH
// result := false ;
25311: LD_ADDR_VAR 0 6
25315: PUSH
25316: LD_INT 0
25318: ST_TO_ADDR
// if not base or not btype or not x or not y then
25319: LD_VAR 0 1
25323: NOT
25324: PUSH
25325: LD_VAR 0 2
25329: NOT
25330: OR
25331: PUSH
25332: LD_VAR 0 3
25336: NOT
25337: OR
25338: PUSH
25339: LD_VAR 0 4
25343: NOT
25344: OR
25345: IFFALSE 25349
// exit ;
25347: GO 25958
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
25349: LD_ADDR_VAR 0 12
25353: PUSH
25354: LD_VAR 0 2
25358: PPUSH
25359: LD_VAR 0 3
25363: PPUSH
25364: LD_VAR 0 4
25368: PPUSH
25369: LD_VAR 0 5
25373: PPUSH
25374: LD_VAR 0 1
25378: PUSH
25379: LD_INT 1
25381: ARRAY
25382: PPUSH
25383: CALL_OW 248
25387: PPUSH
25388: LD_INT 0
25390: PPUSH
25391: CALL 26795 0 6
25395: ST_TO_ADDR
// if not hexes then
25396: LD_VAR 0 12
25400: NOT
25401: IFFALSE 25405
// exit ;
25403: GO 25958
// for i = 1 to hexes do
25405: LD_ADDR_VAR 0 7
25409: PUSH
25410: DOUBLE
25411: LD_INT 1
25413: DEC
25414: ST_TO_ADDR
25415: LD_VAR 0 12
25419: PUSH
25420: FOR_TO
25421: IFFALSE 25956
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25423: LD_ADDR_VAR 0 11
25427: PUSH
25428: LD_VAR 0 12
25432: PUSH
25433: LD_VAR 0 7
25437: ARRAY
25438: PUSH
25439: LD_INT 1
25441: ARRAY
25442: PPUSH
25443: LD_VAR 0 12
25447: PUSH
25448: LD_VAR 0 7
25452: ARRAY
25453: PUSH
25454: LD_INT 2
25456: ARRAY
25457: PPUSH
25458: CALL_OW 428
25462: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25463: LD_VAR 0 12
25467: PUSH
25468: LD_VAR 0 7
25472: ARRAY
25473: PUSH
25474: LD_INT 1
25476: ARRAY
25477: PPUSH
25478: LD_VAR 0 12
25482: PUSH
25483: LD_VAR 0 7
25487: ARRAY
25488: PUSH
25489: LD_INT 2
25491: ARRAY
25492: PPUSH
25493: CALL_OW 351
25497: PUSH
25498: LD_VAR 0 12
25502: PUSH
25503: LD_VAR 0 7
25507: ARRAY
25508: PUSH
25509: LD_INT 1
25511: ARRAY
25512: PPUSH
25513: LD_VAR 0 12
25517: PUSH
25518: LD_VAR 0 7
25522: ARRAY
25523: PUSH
25524: LD_INT 2
25526: ARRAY
25527: PPUSH
25528: CALL_OW 488
25532: NOT
25533: OR
25534: PUSH
25535: LD_VAR 0 11
25539: PPUSH
25540: CALL_OW 247
25544: PUSH
25545: LD_INT 3
25547: EQUAL
25548: OR
25549: IFFALSE 25555
// exit ;
25551: POP
25552: POP
25553: GO 25958
// if not tmp or not tmp in base then
25555: LD_VAR 0 11
25559: NOT
25560: PUSH
25561: LD_VAR 0 11
25565: PUSH
25566: LD_VAR 0 1
25570: IN
25571: NOT
25572: OR
25573: IFFALSE 25577
// continue ;
25575: GO 25420
// result := true ;
25577: LD_ADDR_VAR 0 6
25581: PUSH
25582: LD_INT 1
25584: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25585: LD_ADDR_VAR 0 15
25589: PUSH
25590: LD_VAR 0 1
25594: PPUSH
25595: LD_INT 22
25597: PUSH
25598: LD_VAR 0 11
25602: PPUSH
25603: CALL_OW 255
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: PUSH
25612: LD_INT 2
25614: PUSH
25615: LD_INT 30
25617: PUSH
25618: LD_INT 0
25620: PUSH
25621: EMPTY
25622: LIST
25623: LIST
25624: PUSH
25625: LD_INT 30
25627: PUSH
25628: LD_INT 1
25630: PUSH
25631: EMPTY
25632: LIST
25633: LIST
25634: PUSH
25635: EMPTY
25636: LIST
25637: LIST
25638: LIST
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PPUSH
25644: CALL_OW 72
25648: ST_TO_ADDR
// if dep then
25649: LD_VAR 0 15
25653: IFFALSE 25789
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25655: LD_ADDR_VAR 0 14
25659: PUSH
25660: LD_VAR 0 15
25664: PUSH
25665: LD_INT 1
25667: ARRAY
25668: PPUSH
25669: CALL_OW 250
25673: PPUSH
25674: LD_VAR 0 15
25678: PUSH
25679: LD_INT 1
25681: ARRAY
25682: PPUSH
25683: CALL_OW 254
25687: PPUSH
25688: LD_INT 5
25690: PPUSH
25691: CALL_OW 272
25695: PUSH
25696: LD_VAR 0 15
25700: PUSH
25701: LD_INT 1
25703: ARRAY
25704: PPUSH
25705: CALL_OW 251
25709: PPUSH
25710: LD_VAR 0 15
25714: PUSH
25715: LD_INT 1
25717: ARRAY
25718: PPUSH
25719: CALL_OW 254
25723: PPUSH
25724: LD_INT 5
25726: PPUSH
25727: CALL_OW 273
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
25736: LD_VAR 0 14
25740: PUSH
25741: LD_INT 1
25743: ARRAY
25744: PPUSH
25745: LD_VAR 0 14
25749: PUSH
25750: LD_INT 2
25752: ARRAY
25753: PPUSH
25754: CALL_OW 488
25758: IFFALSE 25789
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
25760: LD_VAR 0 11
25764: PPUSH
25765: LD_VAR 0 14
25769: PUSH
25770: LD_INT 1
25772: ARRAY
25773: PPUSH
25774: LD_VAR 0 14
25778: PUSH
25779: LD_INT 2
25781: ARRAY
25782: PPUSH
25783: CALL_OW 111
// continue ;
25787: GO 25420
// end ; end ; r := GetDir ( tmp ) ;
25789: LD_ADDR_VAR 0 13
25793: PUSH
25794: LD_VAR 0 11
25798: PPUSH
25799: CALL_OW 254
25803: ST_TO_ADDR
// if r = 5 then
25804: LD_VAR 0 13
25808: PUSH
25809: LD_INT 5
25811: EQUAL
25812: IFFALSE 25822
// r := 0 ;
25814: LD_ADDR_VAR 0 13
25818: PUSH
25819: LD_INT 0
25821: ST_TO_ADDR
// for j = r to 5 do
25822: LD_ADDR_VAR 0 8
25826: PUSH
25827: DOUBLE
25828: LD_VAR 0 13
25832: DEC
25833: ST_TO_ADDR
25834: LD_INT 5
25836: PUSH
25837: FOR_TO
25838: IFFALSE 25952
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
25840: LD_ADDR_VAR 0 9
25844: PUSH
25845: LD_VAR 0 11
25849: PPUSH
25850: CALL_OW 250
25854: PPUSH
25855: LD_VAR 0 8
25859: PPUSH
25860: LD_INT 2
25862: PPUSH
25863: CALL_OW 272
25867: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
25868: LD_ADDR_VAR 0 10
25872: PUSH
25873: LD_VAR 0 11
25877: PPUSH
25878: CALL_OW 251
25882: PPUSH
25883: LD_VAR 0 8
25887: PPUSH
25888: LD_INT 2
25890: PPUSH
25891: CALL_OW 273
25895: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
25896: LD_VAR 0 9
25900: PPUSH
25901: LD_VAR 0 10
25905: PPUSH
25906: CALL_OW 488
25910: PUSH
25911: LD_VAR 0 9
25915: PPUSH
25916: LD_VAR 0 10
25920: PPUSH
25921: CALL_OW 428
25925: NOT
25926: AND
25927: IFFALSE 25950
// begin ComMoveXY ( tmp , _x , _y ) ;
25929: LD_VAR 0 11
25933: PPUSH
25934: LD_VAR 0 9
25938: PPUSH
25939: LD_VAR 0 10
25943: PPUSH
25944: CALL_OW 111
// break ;
25948: GO 25952
// end ; end ;
25950: GO 25837
25952: POP
25953: POP
// end ;
25954: GO 25420
25956: POP
25957: POP
// end ;
25958: LD_VAR 0 6
25962: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
25963: LD_INT 0
25965: PPUSH
25966: PPUSH
25967: PPUSH
25968: PPUSH
25969: PPUSH
25970: PPUSH
25971: PPUSH
25972: PPUSH
25973: PPUSH
25974: PPUSH
// result := false ;
25975: LD_ADDR_VAR 0 6
25979: PUSH
25980: LD_INT 0
25982: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
25983: LD_VAR 0 1
25987: NOT
25988: PUSH
25989: LD_VAR 0 1
25993: PPUSH
25994: CALL_OW 266
25998: PUSH
25999: LD_INT 0
26001: PUSH
26002: LD_INT 1
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: IN
26009: NOT
26010: OR
26011: PUSH
26012: LD_VAR 0 2
26016: NOT
26017: OR
26018: PUSH
26019: LD_VAR 0 5
26023: PUSH
26024: LD_INT 0
26026: PUSH
26027: LD_INT 1
26029: PUSH
26030: LD_INT 2
26032: PUSH
26033: LD_INT 3
26035: PUSH
26036: LD_INT 4
26038: PUSH
26039: LD_INT 5
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: LIST
26046: LIST
26047: LIST
26048: LIST
26049: IN
26050: NOT
26051: OR
26052: PUSH
26053: LD_VAR 0 3
26057: PPUSH
26058: LD_VAR 0 4
26062: PPUSH
26063: CALL_OW 488
26067: NOT
26068: OR
26069: IFFALSE 26073
// exit ;
26071: GO 26790
// pom := GetBase ( depot ) ;
26073: LD_ADDR_VAR 0 10
26077: PUSH
26078: LD_VAR 0 1
26082: PPUSH
26083: CALL_OW 274
26087: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26088: LD_ADDR_VAR 0 11
26092: PUSH
26093: LD_VAR 0 2
26097: PPUSH
26098: LD_VAR 0 1
26102: PPUSH
26103: CALL_OW 248
26107: PPUSH
26108: CALL_OW 450
26112: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26113: LD_VAR 0 10
26117: PPUSH
26118: LD_INT 1
26120: PPUSH
26121: CALL_OW 275
26125: PUSH
26126: LD_VAR 0 11
26130: PUSH
26131: LD_INT 1
26133: ARRAY
26134: GREATEREQUAL
26135: PUSH
26136: LD_VAR 0 10
26140: PPUSH
26141: LD_INT 2
26143: PPUSH
26144: CALL_OW 275
26148: PUSH
26149: LD_VAR 0 11
26153: PUSH
26154: LD_INT 2
26156: ARRAY
26157: GREATEREQUAL
26158: AND
26159: PUSH
26160: LD_VAR 0 10
26164: PPUSH
26165: LD_INT 3
26167: PPUSH
26168: CALL_OW 275
26172: PUSH
26173: LD_VAR 0 11
26177: PUSH
26178: LD_INT 3
26180: ARRAY
26181: GREATEREQUAL
26182: AND
26183: NOT
26184: IFFALSE 26188
// exit ;
26186: GO 26790
// if GetBType ( depot ) = b_depot then
26188: LD_VAR 0 1
26192: PPUSH
26193: CALL_OW 266
26197: PUSH
26198: LD_INT 0
26200: EQUAL
26201: IFFALSE 26213
// dist := 28 else
26203: LD_ADDR_VAR 0 14
26207: PUSH
26208: LD_INT 28
26210: ST_TO_ADDR
26211: GO 26221
// dist := 36 ;
26213: LD_ADDR_VAR 0 14
26217: PUSH
26218: LD_INT 36
26220: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26221: LD_VAR 0 1
26225: PPUSH
26226: LD_VAR 0 3
26230: PPUSH
26231: LD_VAR 0 4
26235: PPUSH
26236: CALL_OW 297
26240: PUSH
26241: LD_VAR 0 14
26245: GREATER
26246: IFFALSE 26250
// exit ;
26248: GO 26790
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26250: LD_ADDR_VAR 0 12
26254: PUSH
26255: LD_VAR 0 2
26259: PPUSH
26260: LD_VAR 0 3
26264: PPUSH
26265: LD_VAR 0 4
26269: PPUSH
26270: LD_VAR 0 5
26274: PPUSH
26275: LD_VAR 0 1
26279: PPUSH
26280: CALL_OW 248
26284: PPUSH
26285: LD_INT 0
26287: PPUSH
26288: CALL 26795 0 6
26292: ST_TO_ADDR
// if not hexes then
26293: LD_VAR 0 12
26297: NOT
26298: IFFALSE 26302
// exit ;
26300: GO 26790
// hex := GetHexInfo ( x , y ) ;
26302: LD_ADDR_VAR 0 15
26306: PUSH
26307: LD_VAR 0 3
26311: PPUSH
26312: LD_VAR 0 4
26316: PPUSH
26317: CALL_OW 546
26321: ST_TO_ADDR
// if hex [ 1 ] then
26322: LD_VAR 0 15
26326: PUSH
26327: LD_INT 1
26329: ARRAY
26330: IFFALSE 26334
// exit ;
26332: GO 26790
// height := hex [ 2 ] ;
26334: LD_ADDR_VAR 0 13
26338: PUSH
26339: LD_VAR 0 15
26343: PUSH
26344: LD_INT 2
26346: ARRAY
26347: ST_TO_ADDR
// for i = 1 to hexes do
26348: LD_ADDR_VAR 0 7
26352: PUSH
26353: DOUBLE
26354: LD_INT 1
26356: DEC
26357: ST_TO_ADDR
26358: LD_VAR 0 12
26362: PUSH
26363: FOR_TO
26364: IFFALSE 26694
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
26366: LD_VAR 0 12
26370: PUSH
26371: LD_VAR 0 7
26375: ARRAY
26376: PUSH
26377: LD_INT 1
26379: ARRAY
26380: PPUSH
26381: LD_VAR 0 12
26385: PUSH
26386: LD_VAR 0 7
26390: ARRAY
26391: PUSH
26392: LD_INT 2
26394: ARRAY
26395: PPUSH
26396: CALL_OW 488
26400: NOT
26401: PUSH
26402: LD_VAR 0 12
26406: PUSH
26407: LD_VAR 0 7
26411: ARRAY
26412: PUSH
26413: LD_INT 1
26415: ARRAY
26416: PPUSH
26417: LD_VAR 0 12
26421: PUSH
26422: LD_VAR 0 7
26426: ARRAY
26427: PUSH
26428: LD_INT 2
26430: ARRAY
26431: PPUSH
26432: CALL_OW 428
26436: PUSH
26437: LD_INT 0
26439: GREATER
26440: OR
26441: PUSH
26442: LD_VAR 0 12
26446: PUSH
26447: LD_VAR 0 7
26451: ARRAY
26452: PUSH
26453: LD_INT 1
26455: ARRAY
26456: PPUSH
26457: LD_VAR 0 12
26461: PUSH
26462: LD_VAR 0 7
26466: ARRAY
26467: PUSH
26468: LD_INT 2
26470: ARRAY
26471: PPUSH
26472: CALL_OW 351
26476: OR
26477: IFFALSE 26483
// exit ;
26479: POP
26480: POP
26481: GO 26790
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26483: LD_ADDR_VAR 0 8
26487: PUSH
26488: LD_VAR 0 12
26492: PUSH
26493: LD_VAR 0 7
26497: ARRAY
26498: PUSH
26499: LD_INT 1
26501: ARRAY
26502: PPUSH
26503: LD_VAR 0 12
26507: PUSH
26508: LD_VAR 0 7
26512: ARRAY
26513: PUSH
26514: LD_INT 2
26516: ARRAY
26517: PPUSH
26518: CALL_OW 546
26522: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
26523: LD_VAR 0 8
26527: PUSH
26528: LD_INT 1
26530: ARRAY
26531: PUSH
26532: LD_VAR 0 8
26536: PUSH
26537: LD_INT 2
26539: ARRAY
26540: PUSH
26541: LD_VAR 0 13
26545: PUSH
26546: LD_INT 2
26548: PLUS
26549: GREATER
26550: OR
26551: PUSH
26552: LD_VAR 0 8
26556: PUSH
26557: LD_INT 2
26559: ARRAY
26560: PUSH
26561: LD_VAR 0 13
26565: PUSH
26566: LD_INT 2
26568: MINUS
26569: LESS
26570: OR
26571: PUSH
26572: LD_VAR 0 8
26576: PUSH
26577: LD_INT 3
26579: ARRAY
26580: PUSH
26581: LD_INT 0
26583: PUSH
26584: LD_INT 8
26586: PUSH
26587: LD_INT 9
26589: PUSH
26590: LD_INT 10
26592: PUSH
26593: LD_INT 11
26595: PUSH
26596: LD_INT 12
26598: PUSH
26599: LD_INT 13
26601: PUSH
26602: LD_INT 16
26604: PUSH
26605: LD_INT 17
26607: PUSH
26608: LD_INT 18
26610: PUSH
26611: LD_INT 19
26613: PUSH
26614: LD_INT 20
26616: PUSH
26617: LD_INT 21
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: LIST
26624: LIST
26625: LIST
26626: LIST
26627: LIST
26628: LIST
26629: LIST
26630: LIST
26631: LIST
26632: LIST
26633: LIST
26634: IN
26635: NOT
26636: OR
26637: PUSH
26638: LD_VAR 0 8
26642: PUSH
26643: LD_INT 5
26645: ARRAY
26646: NOT
26647: OR
26648: PUSH
26649: LD_VAR 0 8
26653: PUSH
26654: LD_INT 6
26656: ARRAY
26657: PUSH
26658: LD_INT 1
26660: PUSH
26661: LD_INT 2
26663: PUSH
26664: LD_INT 7
26666: PUSH
26667: LD_INT 9
26669: PUSH
26670: LD_INT 10
26672: PUSH
26673: LD_INT 11
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: LIST
26683: IN
26684: NOT
26685: OR
26686: IFFALSE 26692
// exit ;
26688: POP
26689: POP
26690: GO 26790
// end ;
26692: GO 26363
26694: POP
26695: POP
// side := GetSide ( depot ) ;
26696: LD_ADDR_VAR 0 9
26700: PUSH
26701: LD_VAR 0 1
26705: PPUSH
26706: CALL_OW 255
26710: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
26711: LD_VAR 0 9
26715: PPUSH
26716: LD_VAR 0 3
26720: PPUSH
26721: LD_VAR 0 4
26725: PPUSH
26726: LD_INT 20
26728: PPUSH
26729: CALL 19444 0 4
26733: PUSH
26734: LD_INT 4
26736: ARRAY
26737: IFFALSE 26741
// exit ;
26739: GO 26790
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
26741: LD_VAR 0 2
26745: PUSH
26746: LD_INT 29
26748: PUSH
26749: LD_INT 30
26751: PUSH
26752: EMPTY
26753: LIST
26754: LIST
26755: IN
26756: PUSH
26757: LD_VAR 0 3
26761: PPUSH
26762: LD_VAR 0 4
26766: PPUSH
26767: LD_VAR 0 9
26771: PPUSH
26772: CALL_OW 440
26776: NOT
26777: AND
26778: IFFALSE 26782
// exit ;
26780: GO 26790
// result := true ;
26782: LD_ADDR_VAR 0 6
26786: PUSH
26787: LD_INT 1
26789: ST_TO_ADDR
// end ;
26790: LD_VAR 0 6
26794: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
26795: LD_INT 0
26797: PPUSH
26798: PPUSH
26799: PPUSH
26800: PPUSH
26801: PPUSH
26802: PPUSH
26803: PPUSH
26804: PPUSH
26805: PPUSH
26806: PPUSH
26807: PPUSH
26808: PPUSH
26809: PPUSH
26810: PPUSH
26811: PPUSH
26812: PPUSH
26813: PPUSH
26814: PPUSH
26815: PPUSH
26816: PPUSH
26817: PPUSH
26818: PPUSH
26819: PPUSH
26820: PPUSH
26821: PPUSH
26822: PPUSH
26823: PPUSH
26824: PPUSH
26825: PPUSH
26826: PPUSH
26827: PPUSH
26828: PPUSH
26829: PPUSH
26830: PPUSH
26831: PPUSH
26832: PPUSH
26833: PPUSH
26834: PPUSH
26835: PPUSH
26836: PPUSH
26837: PPUSH
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
26844: PPUSH
26845: PPUSH
26846: PPUSH
26847: PPUSH
26848: PPUSH
26849: PPUSH
26850: PPUSH
26851: PPUSH
26852: PPUSH
26853: PPUSH
26854: PPUSH
// result = [ ] ;
26855: LD_ADDR_VAR 0 7
26859: PUSH
26860: EMPTY
26861: ST_TO_ADDR
// temp_list = [ ] ;
26862: LD_ADDR_VAR 0 9
26866: PUSH
26867: EMPTY
26868: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
26869: LD_VAR 0 4
26873: PUSH
26874: LD_INT 0
26876: PUSH
26877: LD_INT 1
26879: PUSH
26880: LD_INT 2
26882: PUSH
26883: LD_INT 3
26885: PUSH
26886: LD_INT 4
26888: PUSH
26889: LD_INT 5
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: LIST
26896: LIST
26897: LIST
26898: LIST
26899: IN
26900: NOT
26901: PUSH
26902: LD_VAR 0 1
26906: PUSH
26907: LD_INT 0
26909: PUSH
26910: LD_INT 1
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: IN
26917: PUSH
26918: LD_VAR 0 5
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: LD_INT 2
26928: PUSH
26929: LD_INT 3
26931: PUSH
26932: EMPTY
26933: LIST
26934: LIST
26935: LIST
26936: IN
26937: NOT
26938: AND
26939: OR
26940: IFFALSE 26944
// exit ;
26942: GO 45335
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
26944: LD_VAR 0 1
26948: PUSH
26949: LD_INT 6
26951: PUSH
26952: LD_INT 7
26954: PUSH
26955: LD_INT 8
26957: PUSH
26958: LD_INT 13
26960: PUSH
26961: LD_INT 12
26963: PUSH
26964: LD_INT 15
26966: PUSH
26967: LD_INT 11
26969: PUSH
26970: LD_INT 14
26972: PUSH
26973: LD_INT 10
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: LIST
26980: LIST
26981: LIST
26982: LIST
26983: LIST
26984: LIST
26985: LIST
26986: IN
26987: IFFALSE 26997
// btype = b_lab ;
26989: LD_ADDR_VAR 0 1
26993: PUSH
26994: LD_INT 6
26996: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
26997: LD_VAR 0 6
27001: PUSH
27002: LD_INT 0
27004: PUSH
27005: LD_INT 1
27007: PUSH
27008: LD_INT 2
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: LIST
27015: IN
27016: NOT
27017: PUSH
27018: LD_VAR 0 1
27022: PUSH
27023: LD_INT 0
27025: PUSH
27026: LD_INT 1
27028: PUSH
27029: LD_INT 2
27031: PUSH
27032: LD_INT 3
27034: PUSH
27035: LD_INT 6
27037: PUSH
27038: LD_INT 36
27040: PUSH
27041: LD_INT 4
27043: PUSH
27044: LD_INT 5
27046: PUSH
27047: LD_INT 31
27049: PUSH
27050: LD_INT 32
27052: PUSH
27053: LD_INT 33
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: LIST
27065: LIST
27066: LIST
27067: LIST
27068: IN
27069: NOT
27070: PUSH
27071: LD_VAR 0 6
27075: PUSH
27076: LD_INT 1
27078: EQUAL
27079: AND
27080: OR
27081: PUSH
27082: LD_VAR 0 1
27086: PUSH
27087: LD_INT 2
27089: PUSH
27090: LD_INT 3
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: IN
27097: NOT
27098: PUSH
27099: LD_VAR 0 6
27103: PUSH
27104: LD_INT 2
27106: EQUAL
27107: AND
27108: OR
27109: IFFALSE 27119
// mode = 0 ;
27111: LD_ADDR_VAR 0 6
27115: PUSH
27116: LD_INT 0
27118: ST_TO_ADDR
// case mode of 0 :
27119: LD_VAR 0 6
27123: PUSH
27124: LD_INT 0
27126: DOUBLE
27127: EQUAL
27128: IFTRUE 27132
27130: GO 38585
27132: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27133: LD_ADDR_VAR 0 11
27137: PUSH
27138: LD_INT 0
27140: PUSH
27141: LD_INT 0
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 0
27150: PUSH
27151: LD_INT 1
27153: NEG
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: PUSH
27159: LD_INT 1
27161: PUSH
27162: LD_INT 0
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 1
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 0
27181: PUSH
27182: LD_INT 1
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_INT 1
27191: NEG
27192: PUSH
27193: LD_INT 0
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 1
27202: NEG
27203: PUSH
27204: LD_INT 1
27206: NEG
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 1
27214: NEG
27215: PUSH
27216: LD_INT 2
27218: NEG
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 0
27226: PUSH
27227: LD_INT 2
27229: NEG
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: PUSH
27235: LD_INT 1
27237: PUSH
27238: LD_INT 1
27240: NEG
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: LD_INT 1
27248: PUSH
27249: LD_INT 2
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 0
27258: PUSH
27259: LD_INT 2
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 1
27268: NEG
27269: PUSH
27270: LD_INT 1
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PUSH
27277: LD_INT 1
27279: PUSH
27280: LD_INT 3
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: LD_INT 0
27289: PUSH
27290: LD_INT 3
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: PUSH
27297: LD_INT 1
27299: NEG
27300: PUSH
27301: LD_INT 2
27303: PUSH
27304: EMPTY
27305: LIST
27306: LIST
27307: PUSH
27308: EMPTY
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: LIST
27325: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
27326: LD_ADDR_VAR 0 12
27330: PUSH
27331: LD_INT 0
27333: PUSH
27334: LD_INT 0
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PUSH
27341: LD_INT 0
27343: PUSH
27344: LD_INT 1
27346: NEG
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: LD_INT 1
27354: PUSH
27355: LD_INT 0
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: LD_INT 1
27364: PUSH
27365: LD_INT 1
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 0
27374: PUSH
27375: LD_INT 1
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 1
27384: NEG
27385: PUSH
27386: LD_INT 0
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: PUSH
27393: LD_INT 1
27395: NEG
27396: PUSH
27397: LD_INT 1
27399: NEG
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 1
27407: PUSH
27408: LD_INT 1
27410: NEG
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: PUSH
27416: LD_INT 2
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: EMPTY
27423: LIST
27424: LIST
27425: PUSH
27426: LD_INT 2
27428: PUSH
27429: LD_INT 1
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 1
27438: NEG
27439: PUSH
27440: LD_INT 1
27442: PUSH
27443: EMPTY
27444: LIST
27445: LIST
27446: PUSH
27447: LD_INT 2
27449: NEG
27450: PUSH
27451: LD_INT 0
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: LD_INT 2
27460: NEG
27461: PUSH
27462: LD_INT 1
27464: NEG
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 2
27472: NEG
27473: PUSH
27474: LD_INT 1
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 3
27483: NEG
27484: PUSH
27485: LD_INT 0
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 3
27494: NEG
27495: PUSH
27496: LD_INT 1
27498: NEG
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: LIST
27508: LIST
27509: LIST
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: LIST
27515: LIST
27516: LIST
27517: LIST
27518: LIST
27519: LIST
27520: LIST
27521: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
27522: LD_ADDR_VAR 0 13
27526: PUSH
27527: LD_INT 0
27529: PUSH
27530: LD_INT 0
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 0
27539: PUSH
27540: LD_INT 1
27542: NEG
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 1
27550: PUSH
27551: LD_INT 0
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: LD_INT 1
27560: PUSH
27561: LD_INT 1
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 0
27570: PUSH
27571: LD_INT 1
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: LD_INT 1
27580: NEG
27581: PUSH
27582: LD_INT 0
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: NEG
27592: PUSH
27593: LD_INT 1
27595: NEG
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: PUSH
27601: LD_INT 1
27603: NEG
27604: PUSH
27605: LD_INT 2
27607: NEG
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: PUSH
27613: LD_INT 2
27615: PUSH
27616: LD_INT 1
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: LD_INT 2
27625: PUSH
27626: LD_INT 2
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 1
27635: PUSH
27636: LD_INT 2
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 2
27645: NEG
27646: PUSH
27647: LD_INT 1
27649: NEG
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 2
27657: NEG
27658: PUSH
27659: LD_INT 2
27661: NEG
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 2
27669: NEG
27670: PUSH
27671: LD_INT 3
27673: NEG
27674: PUSH
27675: EMPTY
27676: LIST
27677: LIST
27678: PUSH
27679: LD_INT 3
27681: NEG
27682: PUSH
27683: LD_INT 2
27685: NEG
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: LD_INT 3
27693: NEG
27694: PUSH
27695: LD_INT 3
27697: NEG
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: LIST
27711: LIST
27712: LIST
27713: LIST
27714: LIST
27715: LIST
27716: LIST
27717: LIST
27718: LIST
27719: LIST
27720: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
27721: LD_ADDR_VAR 0 14
27725: PUSH
27726: LD_INT 0
27728: PUSH
27729: LD_INT 0
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 0
27738: PUSH
27739: LD_INT 1
27741: NEG
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: PUSH
27747: LD_INT 1
27749: PUSH
27750: LD_INT 0
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PUSH
27757: LD_INT 1
27759: PUSH
27760: LD_INT 1
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: PUSH
27767: LD_INT 0
27769: PUSH
27770: LD_INT 1
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 1
27779: NEG
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 1
27790: NEG
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 1
27802: NEG
27803: PUSH
27804: LD_INT 2
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: LD_INT 0
27814: PUSH
27815: LD_INT 2
27817: NEG
27818: PUSH
27819: EMPTY
27820: LIST
27821: LIST
27822: PUSH
27823: LD_INT 1
27825: PUSH
27826: LD_INT 1
27828: NEG
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: PUSH
27834: LD_INT 1
27836: PUSH
27837: LD_INT 2
27839: PUSH
27840: EMPTY
27841: LIST
27842: LIST
27843: PUSH
27844: LD_INT 0
27846: PUSH
27847: LD_INT 2
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: PUSH
27854: LD_INT 1
27856: NEG
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 1
27867: NEG
27868: PUSH
27869: LD_INT 3
27871: NEG
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 0
27879: PUSH
27880: LD_INT 3
27882: NEG
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 1
27890: PUSH
27891: LD_INT 2
27893: NEG
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: EMPTY
27900: LIST
27901: LIST
27902: LIST
27903: LIST
27904: LIST
27905: LIST
27906: LIST
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
27917: LD_ADDR_VAR 0 15
27921: PUSH
27922: LD_INT 0
27924: PUSH
27925: LD_INT 0
27927: PUSH
27928: EMPTY
27929: LIST
27930: LIST
27931: PUSH
27932: LD_INT 0
27934: PUSH
27935: LD_INT 1
27937: NEG
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: PUSH
27943: LD_INT 1
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: LD_INT 1
27958: PUSH
27959: EMPTY
27960: LIST
27961: LIST
27962: PUSH
27963: LD_INT 0
27965: PUSH
27966: LD_INT 1
27968: PUSH
27969: EMPTY
27970: LIST
27971: LIST
27972: PUSH
27973: LD_INT 1
27975: NEG
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: EMPTY
27981: LIST
27982: LIST
27983: PUSH
27984: LD_INT 1
27986: NEG
27987: PUSH
27988: LD_INT 1
27990: NEG
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 1
27998: PUSH
27999: LD_INT 1
28001: NEG
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 2
28009: PUSH
28010: LD_INT 0
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 2
28019: PUSH
28020: LD_INT 1
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: PUSH
28027: LD_INT 1
28029: NEG
28030: PUSH
28031: LD_INT 1
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: PUSH
28038: LD_INT 2
28040: NEG
28041: PUSH
28042: LD_INT 0
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PUSH
28049: LD_INT 2
28051: NEG
28052: PUSH
28053: LD_INT 1
28055: NEG
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: LD_INT 2
28063: PUSH
28064: LD_INT 1
28066: NEG
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 3
28074: PUSH
28075: LD_INT 0
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: PUSH
28082: LD_INT 3
28084: PUSH
28085: LD_INT 1
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28110: LD_ADDR_VAR 0 16
28114: PUSH
28115: LD_INT 0
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: LD_INT 1
28130: NEG
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: LD_INT 1
28138: PUSH
28139: LD_INT 0
28141: PUSH
28142: EMPTY
28143: LIST
28144: LIST
28145: PUSH
28146: LD_INT 1
28148: PUSH
28149: LD_INT 1
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 0
28158: PUSH
28159: LD_INT 1
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PUSH
28166: LD_INT 1
28168: NEG
28169: PUSH
28170: LD_INT 0
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 1
28179: NEG
28180: PUSH
28181: LD_INT 1
28183: NEG
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 1
28191: NEG
28192: PUSH
28193: LD_INT 2
28195: NEG
28196: PUSH
28197: EMPTY
28198: LIST
28199: LIST
28200: PUSH
28201: LD_INT 2
28203: PUSH
28204: LD_INT 1
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 2
28213: PUSH
28214: LD_INT 2
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: LD_INT 1
28223: PUSH
28224: LD_INT 2
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 2
28233: NEG
28234: PUSH
28235: LD_INT 1
28237: NEG
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: PUSH
28243: LD_INT 2
28245: NEG
28246: PUSH
28247: LD_INT 2
28249: NEG
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: PUSH
28255: LD_INT 3
28257: PUSH
28258: LD_INT 2
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 3
28267: PUSH
28268: LD_INT 3
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: LD_INT 2
28277: PUSH
28278: LD_INT 3
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: PUSH
28285: EMPTY
28286: LIST
28287: LIST
28288: LIST
28289: LIST
28290: LIST
28291: LIST
28292: LIST
28293: LIST
28294: LIST
28295: LIST
28296: LIST
28297: LIST
28298: LIST
28299: LIST
28300: LIST
28301: LIST
28302: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28303: LD_ADDR_VAR 0 17
28307: PUSH
28308: LD_INT 0
28310: PUSH
28311: LD_INT 0
28313: PUSH
28314: EMPTY
28315: LIST
28316: LIST
28317: PUSH
28318: LD_INT 0
28320: PUSH
28321: LD_INT 1
28323: NEG
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 1
28331: PUSH
28332: LD_INT 0
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: LD_INT 1
28341: PUSH
28342: LD_INT 1
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 0
28351: PUSH
28352: LD_INT 1
28354: PUSH
28355: EMPTY
28356: LIST
28357: LIST
28358: PUSH
28359: LD_INT 1
28361: NEG
28362: PUSH
28363: LD_INT 0
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 1
28372: NEG
28373: PUSH
28374: LD_INT 1
28376: NEG
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 1
28384: NEG
28385: PUSH
28386: LD_INT 2
28388: NEG
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 2
28399: NEG
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 1
28407: PUSH
28408: LD_INT 1
28410: NEG
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 2
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 2
28428: PUSH
28429: LD_INT 1
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 2
28438: PUSH
28439: LD_INT 2
28441: PUSH
28442: EMPTY
28443: LIST
28444: LIST
28445: PUSH
28446: LD_INT 1
28448: PUSH
28449: LD_INT 2
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 0
28458: PUSH
28459: LD_INT 2
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: LD_INT 1
28468: NEG
28469: PUSH
28470: LD_INT 1
28472: PUSH
28473: EMPTY
28474: LIST
28475: LIST
28476: PUSH
28477: LD_INT 2
28479: NEG
28480: PUSH
28481: LD_INT 0
28483: PUSH
28484: EMPTY
28485: LIST
28486: LIST
28487: PUSH
28488: LD_INT 2
28490: NEG
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 2
28502: NEG
28503: PUSH
28504: LD_INT 2
28506: NEG
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: LIST
28516: LIST
28517: LIST
28518: LIST
28519: LIST
28520: LIST
28521: LIST
28522: LIST
28523: LIST
28524: LIST
28525: LIST
28526: LIST
28527: LIST
28528: LIST
28529: LIST
28530: LIST
28531: LIST
28532: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28533: LD_ADDR_VAR 0 18
28537: PUSH
28538: LD_INT 0
28540: PUSH
28541: LD_INT 0
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 0
28550: PUSH
28551: LD_INT 1
28553: NEG
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 1
28561: PUSH
28562: LD_INT 0
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: LD_INT 1
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 0
28581: PUSH
28582: LD_INT 1
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 1
28591: NEG
28592: PUSH
28593: LD_INT 0
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 1
28602: NEG
28603: PUSH
28604: LD_INT 1
28606: NEG
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 1
28614: NEG
28615: PUSH
28616: LD_INT 2
28618: NEG
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 0
28626: PUSH
28627: LD_INT 2
28629: NEG
28630: PUSH
28631: EMPTY
28632: LIST
28633: LIST
28634: PUSH
28635: LD_INT 1
28637: PUSH
28638: LD_INT 1
28640: NEG
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 2
28648: PUSH
28649: LD_INT 0
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 2
28658: PUSH
28659: LD_INT 1
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 2
28668: PUSH
28669: LD_INT 2
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 1
28678: PUSH
28679: LD_INT 2
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: LD_INT 0
28688: PUSH
28689: LD_INT 2
28691: PUSH
28692: EMPTY
28693: LIST
28694: LIST
28695: PUSH
28696: LD_INT 1
28698: NEG
28699: PUSH
28700: LD_INT 1
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 2
28709: NEG
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 2
28720: NEG
28721: PUSH
28722: LD_INT 1
28724: NEG
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 2
28732: NEG
28733: PUSH
28734: LD_INT 2
28736: NEG
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: LIST
28746: LIST
28747: LIST
28748: LIST
28749: LIST
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28763: LD_ADDR_VAR 0 19
28767: PUSH
28768: LD_INT 0
28770: PUSH
28771: LD_INT 0
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: LD_INT 0
28780: PUSH
28781: LD_INT 1
28783: NEG
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: LD_INT 0
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 1
28801: PUSH
28802: LD_INT 1
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 0
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 1
28821: NEG
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 1
28832: NEG
28833: PUSH
28834: LD_INT 1
28836: NEG
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 1
28844: NEG
28845: PUSH
28846: LD_INT 2
28848: NEG
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 0
28856: PUSH
28857: LD_INT 2
28859: NEG
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 1
28867: PUSH
28868: LD_INT 1
28870: NEG
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 2
28878: PUSH
28879: LD_INT 0
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 2
28888: PUSH
28889: LD_INT 1
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 2
28898: PUSH
28899: LD_INT 2
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: LD_INT 2
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 0
28918: PUSH
28919: LD_INT 2
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PUSH
28926: LD_INT 1
28928: NEG
28929: PUSH
28930: LD_INT 1
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 2
28939: NEG
28940: PUSH
28941: LD_INT 0
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 2
28950: NEG
28951: PUSH
28952: LD_INT 1
28954: NEG
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 2
28962: NEG
28963: PUSH
28964: LD_INT 2
28966: NEG
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: LIST
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28993: LD_ADDR_VAR 0 20
28997: PUSH
28998: LD_INT 0
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 0
29010: PUSH
29011: LD_INT 1
29013: NEG
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 1
29021: PUSH
29022: LD_INT 0
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: PUSH
29032: LD_INT 1
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: LD_INT 1
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: PUSH
29049: LD_INT 1
29051: NEG
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: NEG
29063: PUSH
29064: LD_INT 1
29066: NEG
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: LD_INT 2
29078: NEG
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: LD_INT 2
29089: NEG
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 2
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 2
29128: PUSH
29129: LD_INT 2
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: LD_INT 2
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: LD_INT 1
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 2
29169: NEG
29170: PUSH
29171: LD_INT 0
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 2
29180: NEG
29181: PUSH
29182: LD_INT 1
29184: NEG
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: LD_INT 2
29196: NEG
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29223: LD_ADDR_VAR 0 21
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 0
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 1
29281: NEG
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: LD_INT 2
29308: NEG
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: LD_INT 2
29319: NEG
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 2
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 2
29358: PUSH
29359: LD_INT 2
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 2
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 0
29378: PUSH
29379: LD_INT 2
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 2
29399: NEG
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: LD_INT 2
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29453: LD_ADDR_VAR 0 22
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: LD_INT 1
29473: NEG
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 0
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: NEG
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 0
29546: PUSH
29547: LD_INT 2
29549: NEG
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 1
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: LD_INT 1
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 0
29608: PUSH
29609: LD_INT 2
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: LD_INT 1
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 2
29629: NEG
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 2
29640: NEG
29641: PUSH
29642: LD_INT 1
29644: NEG
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: LD_INT 2
29656: NEG
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
29683: LD_ADDR_VAR 0 23
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 0
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: NEG
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 0
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 1
29741: NEG
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: LD_INT 1
29756: NEG
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 1
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 2
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: PUSH
29829: LD_INT 2
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 0
29838: PUSH
29839: LD_INT 2
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: NEG
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 2
29870: NEG
29871: PUSH
29872: LD_INT 1
29874: NEG
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 2
29882: NEG
29883: PUSH
29884: LD_INT 2
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 2
29894: NEG
29895: PUSH
29896: LD_INT 3
29898: NEG
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: NEG
29907: PUSH
29908: LD_INT 3
29910: NEG
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: LD_INT 2
29921: NEG
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 2
29929: PUSH
29930: LD_INT 1
29932: NEG
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: LIST
29942: LIST
29943: LIST
29944: LIST
29945: LIST
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: LIST
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
29963: LD_ADDR_VAR 0 24
29967: PUSH
29968: LD_INT 0
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 0
29980: PUSH
29981: LD_INT 1
29983: NEG
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 1
29991: PUSH
29992: LD_INT 0
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 1
30001: PUSH
30002: LD_INT 1
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 0
30011: PUSH
30012: LD_INT 1
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 1
30021: NEG
30022: PUSH
30023: LD_INT 0
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 1
30032: NEG
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: NEG
30045: PUSH
30046: LD_INT 2
30048: NEG
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PUSH
30054: LD_INT 0
30056: PUSH
30057: LD_INT 2
30059: NEG
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: LD_INT 1
30067: PUSH
30068: LD_INT 1
30070: NEG
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 2
30078: PUSH
30079: LD_INT 0
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 2
30088: PUSH
30089: LD_INT 1
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: PUSH
30096: LD_INT 2
30098: PUSH
30099: LD_INT 2
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 1
30108: PUSH
30109: LD_INT 2
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 0
30118: PUSH
30119: LD_INT 2
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: LD_INT 1
30128: NEG
30129: PUSH
30130: LD_INT 1
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 2
30139: NEG
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 2
30150: NEG
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: NEG
30163: PUSH
30164: LD_INT 2
30166: NEG
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 1
30174: PUSH
30175: LD_INT 2
30177: NEG
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 2
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 3
30196: PUSH
30197: LD_INT 1
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 3
30206: PUSH
30207: LD_INT 2
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: LIST
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30239: LD_ADDR_VAR 0 25
30243: PUSH
30244: LD_INT 0
30246: PUSH
30247: LD_INT 0
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 0
30256: PUSH
30257: LD_INT 1
30259: NEG
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 1
30267: PUSH
30268: LD_INT 0
30270: PUSH
30271: EMPTY
30272: LIST
30273: LIST
30274: PUSH
30275: LD_INT 1
30277: PUSH
30278: LD_INT 1
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 0
30287: PUSH
30288: LD_INT 1
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: LD_INT 1
30312: NEG
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 1
30320: NEG
30321: PUSH
30322: LD_INT 2
30324: NEG
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 0
30332: PUSH
30333: LD_INT 2
30335: NEG
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PUSH
30341: LD_INT 1
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 2
30354: PUSH
30355: LD_INT 0
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 2
30364: PUSH
30365: LD_INT 1
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 2
30374: PUSH
30375: LD_INT 2
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 1
30384: PUSH
30385: LD_INT 2
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: LD_INT 2
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 1
30404: NEG
30405: PUSH
30406: LD_INT 1
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 2
30415: NEG
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 2
30426: NEG
30427: PUSH
30428: LD_INT 1
30430: NEG
30431: PUSH
30432: EMPTY
30433: LIST
30434: LIST
30435: PUSH
30436: LD_INT 2
30438: NEG
30439: PUSH
30440: LD_INT 2
30442: NEG
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 3
30450: PUSH
30451: LD_INT 1
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 3
30460: PUSH
30461: LD_INT 2
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 2
30470: PUSH
30471: LD_INT 3
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: PUSH
30478: LD_INT 1
30480: PUSH
30481: LD_INT 3
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
30513: LD_ADDR_VAR 0 26
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: LD_INT 0
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: LD_INT 1
30533: NEG
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 1
30541: PUSH
30542: LD_INT 0
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 1
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 0
30561: PUSH
30562: LD_INT 1
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 1
30571: NEG
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 1
30582: NEG
30583: PUSH
30584: LD_INT 1
30586: NEG
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 1
30594: NEG
30595: PUSH
30596: LD_INT 2
30598: NEG
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: LD_INT 0
30606: PUSH
30607: LD_INT 2
30609: NEG
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 1
30617: PUSH
30618: LD_INT 1
30620: NEG
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 2
30628: PUSH
30629: LD_INT 0
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 2
30638: PUSH
30639: LD_INT 1
30641: PUSH
30642: EMPTY
30643: LIST
30644: LIST
30645: PUSH
30646: LD_INT 2
30648: PUSH
30649: LD_INT 2
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 1
30658: PUSH
30659: LD_INT 2
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PUSH
30666: LD_INT 0
30668: PUSH
30669: LD_INT 2
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 1
30678: NEG
30679: PUSH
30680: LD_INT 1
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 2
30689: NEG
30690: PUSH
30691: LD_INT 0
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 2
30700: NEG
30701: PUSH
30702: LD_INT 1
30704: NEG
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: PUSH
30710: LD_INT 2
30712: NEG
30713: PUSH
30714: LD_INT 2
30716: NEG
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 2
30724: PUSH
30725: LD_INT 3
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: PUSH
30735: LD_INT 3
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 1
30744: NEG
30745: PUSH
30746: LD_INT 2
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 2
30755: NEG
30756: PUSH
30757: LD_INT 1
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: LIST
30770: LIST
30771: LIST
30772: LIST
30773: LIST
30774: LIST
30775: LIST
30776: LIST
30777: LIST
30778: LIST
30779: LIST
30780: LIST
30781: LIST
30782: LIST
30783: LIST
30784: LIST
30785: LIST
30786: LIST
30787: LIST
30788: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30789: LD_ADDR_VAR 0 27
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: LD_INT 0
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 0
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: PUSH
30818: LD_INT 0
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 1
30827: PUSH
30828: LD_INT 1
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 0
30837: PUSH
30838: LD_INT 1
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: LD_INT 0
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 1
30858: NEG
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 1
30870: NEG
30871: PUSH
30872: LD_INT 2
30874: NEG
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 0
30882: PUSH
30883: LD_INT 2
30885: NEG
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 1
30893: PUSH
30894: LD_INT 1
30896: NEG
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 2
30904: PUSH
30905: LD_INT 0
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 2
30914: PUSH
30915: LD_INT 1
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: LD_INT 2
30924: PUSH
30925: LD_INT 2
30927: PUSH
30928: EMPTY
30929: LIST
30930: LIST
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: LD_INT 2
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 0
30944: PUSH
30945: LD_INT 2
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: NEG
30955: PUSH
30956: LD_INT 1
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: PUSH
30963: LD_INT 2
30965: NEG
30966: PUSH
30967: LD_INT 0
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PUSH
30974: LD_INT 2
30976: NEG
30977: PUSH
30978: LD_INT 1
30980: NEG
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: LD_INT 2
30988: NEG
30989: PUSH
30990: LD_INT 2
30992: NEG
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: LD_INT 2
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: LD_INT 2
31011: NEG
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 3
31022: NEG
31023: PUSH
31024: LD_INT 1
31026: NEG
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 3
31034: NEG
31035: PUSH
31036: LD_INT 2
31038: NEG
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: LIST
31048: LIST
31049: LIST
31050: LIST
31051: LIST
31052: LIST
31053: LIST
31054: LIST
31055: LIST
31056: LIST
31057: LIST
31058: LIST
31059: LIST
31060: LIST
31061: LIST
31062: LIST
31063: LIST
31064: LIST
31065: LIST
31066: LIST
31067: LIST
31068: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31069: LD_ADDR_VAR 0 28
31073: PUSH
31074: LD_INT 0
31076: PUSH
31077: LD_INT 0
31079: PUSH
31080: EMPTY
31081: LIST
31082: LIST
31083: PUSH
31084: LD_INT 0
31086: PUSH
31087: LD_INT 1
31089: NEG
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 1
31097: PUSH
31098: LD_INT 0
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 1
31107: PUSH
31108: LD_INT 1
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 0
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 1
31127: NEG
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 1
31138: NEG
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 2
31154: NEG
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 0
31162: PUSH
31163: LD_INT 2
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 1
31173: PUSH
31174: LD_INT 1
31176: NEG
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 2
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: PUSH
31195: LD_INT 1
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 2
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: LD_INT 2
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 0
31224: PUSH
31225: LD_INT 2
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 1
31234: NEG
31235: PUSH
31236: LD_INT 1
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 2
31245: NEG
31246: PUSH
31247: LD_INT 0
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 2
31256: NEG
31257: PUSH
31258: LD_INT 1
31260: NEG
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 2
31268: NEG
31269: PUSH
31270: LD_INT 2
31272: NEG
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: LD_INT 2
31280: NEG
31281: PUSH
31282: LD_INT 3
31284: NEG
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 1
31292: NEG
31293: PUSH
31294: LD_INT 3
31296: NEG
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 3
31304: NEG
31305: PUSH
31306: LD_INT 1
31308: NEG
31309: PUSH
31310: EMPTY
31311: LIST
31312: LIST
31313: PUSH
31314: LD_INT 3
31316: NEG
31317: PUSH
31318: LD_INT 2
31320: NEG
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: LIST
31349: LIST
31350: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31351: LD_ADDR_VAR 0 29
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: LD_INT 0
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 0
31368: PUSH
31369: LD_INT 1
31371: NEG
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: LD_INT 0
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 1
31389: PUSH
31390: LD_INT 1
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: LD_INT 1
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 1
31409: NEG
31410: PUSH
31411: LD_INT 0
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: NEG
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 1
31432: NEG
31433: PUSH
31434: LD_INT 2
31436: NEG
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 0
31444: PUSH
31445: LD_INT 2
31447: NEG
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: LD_INT 1
31458: NEG
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 2
31466: PUSH
31467: LD_INT 0
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PUSH
31474: LD_INT 2
31476: PUSH
31477: LD_INT 1
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: LD_INT 1
31486: PUSH
31487: LD_INT 2
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 0
31496: PUSH
31497: LD_INT 2
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 1
31506: NEG
31507: PUSH
31508: LD_INT 1
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 2
31517: NEG
31518: PUSH
31519: LD_INT 1
31521: NEG
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 2
31529: NEG
31530: PUSH
31531: LD_INT 2
31533: NEG
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 2
31541: NEG
31542: PUSH
31543: LD_INT 3
31545: NEG
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: LD_INT 2
31553: PUSH
31554: LD_INT 1
31556: NEG
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 3
31564: PUSH
31565: LD_INT 1
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: PUSH
31575: LD_INT 3
31577: PUSH
31578: EMPTY
31579: LIST
31580: LIST
31581: PUSH
31582: LD_INT 1
31584: NEG
31585: PUSH
31586: LD_INT 2
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 3
31595: NEG
31596: PUSH
31597: LD_INT 2
31599: NEG
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: LIST
31609: LIST
31610: LIST
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31630: LD_ADDR_VAR 0 30
31634: PUSH
31635: LD_INT 0
31637: PUSH
31638: LD_INT 0
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: LD_INT 0
31647: PUSH
31648: LD_INT 1
31650: NEG
31651: PUSH
31652: EMPTY
31653: LIST
31654: LIST
31655: PUSH
31656: LD_INT 1
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: LD_INT 1
31668: PUSH
31669: LD_INT 1
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 0
31678: PUSH
31679: LD_INT 1
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 1
31688: NEG
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 1
31699: NEG
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 1
31711: NEG
31712: PUSH
31713: LD_INT 2
31715: NEG
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: LD_INT 2
31726: NEG
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: PUSH
31735: LD_INT 1
31737: NEG
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 2
31745: PUSH
31746: LD_INT 0
31748: PUSH
31749: EMPTY
31750: LIST
31751: LIST
31752: PUSH
31753: LD_INT 2
31755: PUSH
31756: LD_INT 1
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 2
31765: PUSH
31766: LD_INT 2
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: LD_INT 1
31775: PUSH
31776: LD_INT 2
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: LD_INT 1
31785: NEG
31786: PUSH
31787: LD_INT 1
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 2
31796: NEG
31797: PUSH
31798: LD_INT 0
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 2
31807: NEG
31808: PUSH
31809: LD_INT 1
31811: NEG
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: NEG
31820: PUSH
31821: LD_INT 3
31823: NEG
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: PUSH
31829: LD_INT 1
31831: PUSH
31832: LD_INT 2
31834: NEG
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 3
31842: PUSH
31843: LD_INT 2
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 2
31852: PUSH
31853: LD_INT 3
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: LD_INT 1
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 3
31873: NEG
31874: PUSH
31875: LD_INT 1
31877: NEG
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: LIST
31893: LIST
31894: LIST
31895: LIST
31896: LIST
31897: LIST
31898: LIST
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: LIST
31907: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31908: LD_ADDR_VAR 0 31
31912: PUSH
31913: LD_INT 0
31915: PUSH
31916: LD_INT 0
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: PUSH
31923: LD_INT 0
31925: PUSH
31926: LD_INT 1
31928: NEG
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: LD_INT 1
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: LD_INT 1
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 0
31956: PUSH
31957: LD_INT 1
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PUSH
31964: LD_INT 1
31966: NEG
31967: PUSH
31968: LD_INT 0
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 1
31977: NEG
31978: PUSH
31979: LD_INT 1
31981: NEG
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: LD_INT 2
31993: NEG
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: PUSH
32002: LD_INT 1
32004: NEG
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 2
32012: PUSH
32013: LD_INT 0
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 2
32022: PUSH
32023: LD_INT 1
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 2
32032: PUSH
32033: LD_INT 2
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 1
32042: PUSH
32043: LD_INT 2
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 0
32052: PUSH
32053: LD_INT 2
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 1
32062: NEG
32063: PUSH
32064: LD_INT 1
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 2
32073: NEG
32074: PUSH
32075: LD_INT 1
32077: NEG
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 2
32085: NEG
32086: PUSH
32087: LD_INT 2
32089: NEG
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 2
32097: NEG
32098: PUSH
32099: LD_INT 3
32101: NEG
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 2
32109: PUSH
32110: LD_INT 1
32112: NEG
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 3
32120: PUSH
32121: LD_INT 1
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 1
32130: PUSH
32131: LD_INT 3
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 1
32140: NEG
32141: PUSH
32142: LD_INT 2
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 3
32151: NEG
32152: PUSH
32153: LD_INT 2
32155: NEG
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: LIST
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32186: LD_ADDR_VAR 0 32
32190: PUSH
32191: LD_INT 0
32193: PUSH
32194: LD_INT 0
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 0
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 1
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 1
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 1
32244: NEG
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 1
32255: NEG
32256: PUSH
32257: LD_INT 1
32259: NEG
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 1
32267: NEG
32268: PUSH
32269: LD_INT 2
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: LD_INT 2
32282: NEG
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: LD_INT 1
32290: PUSH
32291: LD_INT 1
32293: NEG
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 2
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 2
32311: PUSH
32312: LD_INT 2
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 1
32321: PUSH
32322: LD_INT 2
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 0
32331: PUSH
32332: LD_INT 2
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 1
32341: NEG
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 2
32352: NEG
32353: PUSH
32354: LD_INT 0
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 2
32363: NEG
32364: PUSH
32365: LD_INT 1
32367: NEG
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 1
32375: NEG
32376: PUSH
32377: LD_INT 3
32379: NEG
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 1
32387: PUSH
32388: LD_INT 2
32390: NEG
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 3
32398: PUSH
32399: LD_INT 2
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 2
32408: PUSH
32409: LD_INT 3
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: PUSH
32416: LD_INT 2
32418: NEG
32419: PUSH
32420: LD_INT 1
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 3
32429: NEG
32430: PUSH
32431: LD_INT 1
32433: NEG
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: LIST
32463: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32464: LD_ADDR_VAR 0 33
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 0
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 0
32481: PUSH
32482: LD_INT 1
32484: NEG
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 1
32492: PUSH
32493: LD_INT 0
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 1
32502: PUSH
32503: LD_INT 1
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: LD_INT 1
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 1
32522: NEG
32523: PUSH
32524: LD_INT 0
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: NEG
32534: PUSH
32535: LD_INT 1
32537: NEG
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 1
32545: NEG
32546: PUSH
32547: LD_INT 2
32549: NEG
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 1
32557: PUSH
32558: LD_INT 1
32560: NEG
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 2
32568: PUSH
32569: LD_INT 0
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 1
32588: PUSH
32589: LD_INT 2
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 0
32598: PUSH
32599: LD_INT 2
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 1
32608: NEG
32609: PUSH
32610: LD_INT 1
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 2
32619: NEG
32620: PUSH
32621: LD_INT 0
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PUSH
32628: LD_INT 2
32630: NEG
32631: PUSH
32632: LD_INT 1
32634: NEG
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: LD_INT 2
32642: NEG
32643: PUSH
32644: LD_INT 2
32646: NEG
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 2
32654: NEG
32655: PUSH
32656: LD_INT 3
32658: NEG
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 2
32666: PUSH
32667: LD_INT 1
32669: NEG
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 3
32677: PUSH
32678: LD_INT 1
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 1
32687: PUSH
32688: LD_INT 3
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 1
32697: NEG
32698: PUSH
32699: LD_INT 2
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 3
32708: NEG
32709: PUSH
32710: LD_INT 2
32712: NEG
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32743: LD_ADDR_VAR 0 34
32747: PUSH
32748: LD_INT 0
32750: PUSH
32751: LD_INT 0
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 0
32760: PUSH
32761: LD_INT 1
32763: NEG
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 1
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: LD_INT 1
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 0
32791: PUSH
32792: LD_INT 1
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: NEG
32802: PUSH
32803: LD_INT 0
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: PUSH
32814: LD_INT 1
32816: NEG
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 1
32824: NEG
32825: PUSH
32826: LD_INT 2
32828: NEG
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: LD_INT 2
32839: NEG
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 1
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PUSH
32856: LD_INT 2
32858: PUSH
32859: LD_INT 1
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 2
32868: PUSH
32869: LD_INT 2
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: PUSH
32879: LD_INT 2
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 2
32899: NEG
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 2
32910: NEG
32911: PUSH
32912: LD_INT 1
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 2
32922: NEG
32923: PUSH
32924: LD_INT 2
32926: NEG
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 3
32938: NEG
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 3
32957: PUSH
32958: LD_INT 2
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: LD_INT 2
32967: PUSH
32968: LD_INT 3
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 2
32977: NEG
32978: PUSH
32979: LD_INT 1
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 3
32988: NEG
32989: PUSH
32990: LD_INT 1
32992: NEG
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: LIST
33020: LIST
33021: LIST
33022: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33023: LD_ADDR_VAR 0 35
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: LD_INT 0
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: LD_INT 1
33043: NEG
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 1
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: LD_INT 1
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: NEG
33082: PUSH
33083: LD_INT 0
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: LD_INT 1
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 2
33104: PUSH
33105: LD_INT 1
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 2
33114: NEG
33115: PUSH
33116: LD_INT 1
33118: NEG
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33135: LD_ADDR_VAR 0 36
33139: PUSH
33140: LD_INT 0
33142: PUSH
33143: LD_INT 0
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: LD_INT 0
33152: PUSH
33153: LD_INT 1
33155: NEG
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 1
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 1
33173: PUSH
33174: LD_INT 1
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 0
33183: PUSH
33184: LD_INT 1
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 1
33193: NEG
33194: PUSH
33195: LD_INT 0
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 1
33204: NEG
33205: PUSH
33206: LD_INT 1
33208: NEG
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 1
33216: NEG
33217: PUSH
33218: LD_INT 2
33220: NEG
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PUSH
33226: LD_INT 1
33228: PUSH
33229: LD_INT 2
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: LIST
33243: LIST
33244: LIST
33245: LIST
33246: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33247: LD_ADDR_VAR 0 37
33251: PUSH
33252: LD_INT 0
33254: PUSH
33255: LD_INT 0
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: LD_INT 1
33267: NEG
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: LD_INT 0
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 1
33285: PUSH
33286: LD_INT 1
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 0
33295: PUSH
33296: LD_INT 1
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 1
33305: NEG
33306: PUSH
33307: LD_INT 0
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: NEG
33317: PUSH
33318: LD_INT 1
33320: NEG
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: LD_INT 1
33328: PUSH
33329: LD_INT 1
33331: NEG
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 1
33339: NEG
33340: PUSH
33341: LD_INT 1
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33359: LD_ADDR_VAR 0 38
33363: PUSH
33364: LD_INT 0
33366: PUSH
33367: LD_INT 0
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PUSH
33374: LD_INT 0
33376: PUSH
33377: LD_INT 1
33379: NEG
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 1
33387: PUSH
33388: LD_INT 0
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: LD_INT 1
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 0
33407: PUSH
33408: LD_INT 1
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: LD_INT 1
33417: NEG
33418: PUSH
33419: LD_INT 0
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 1
33428: NEG
33429: PUSH
33430: LD_INT 1
33432: NEG
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 2
33440: PUSH
33441: LD_INT 1
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 2
33450: NEG
33451: PUSH
33452: LD_INT 1
33454: NEG
33455: PUSH
33456: EMPTY
33457: LIST
33458: LIST
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: LIST
33464: LIST
33465: LIST
33466: LIST
33467: LIST
33468: LIST
33469: LIST
33470: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33471: LD_ADDR_VAR 0 39
33475: PUSH
33476: LD_INT 0
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 0
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 1
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: LD_INT 1
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: NEG
33530: PUSH
33531: LD_INT 0
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: LD_INT 1
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: NEG
33553: PUSH
33554: LD_INT 2
33556: NEG
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 1
33564: PUSH
33565: LD_INT 2
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33583: LD_ADDR_VAR 0 40
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: LD_INT 0
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 0
33600: PUSH
33601: LD_INT 1
33603: NEG
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 1
33611: PUSH
33612: LD_INT 0
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 1
33641: NEG
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: NEG
33653: PUSH
33654: LD_INT 1
33656: NEG
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: PUSH
33662: LD_INT 1
33664: PUSH
33665: LD_INT 1
33667: NEG
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 1
33675: NEG
33676: PUSH
33677: LD_INT 1
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33695: LD_ADDR_VAR 0 41
33699: PUSH
33700: LD_INT 0
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 0
33712: PUSH
33713: LD_INT 1
33715: NEG
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: LD_INT 0
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 1
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: PUSH
33755: LD_INT 0
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 1
33764: NEG
33765: PUSH
33766: LD_INT 1
33768: NEG
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: NEG
33777: PUSH
33778: LD_INT 2
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 1
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 2
33799: PUSH
33800: LD_INT 0
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 2
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: PUSH
33820: LD_INT 2
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 1
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 1
33839: NEG
33840: PUSH
33841: LD_INT 1
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 2
33850: NEG
33851: PUSH
33852: LD_INT 0
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 2
33861: NEG
33862: PUSH
33863: LD_INT 1
33865: NEG
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 2
33873: NEG
33874: PUSH
33875: LD_INT 2
33877: NEG
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 2
33885: NEG
33886: PUSH
33887: LD_INT 3
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 2
33897: PUSH
33898: LD_INT 1
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 3
33908: PUSH
33909: LD_INT 0
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 3
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 3
33928: PUSH
33929: LD_INT 2
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 3
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 2
33948: PUSH
33949: LD_INT 3
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 2
33958: NEG
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 3
33969: NEG
33970: PUSH
33971: LD_INT 0
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 3
33980: NEG
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 3
33992: NEG
33993: PUSH
33994: LD_INT 2
33996: NEG
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 3
34004: NEG
34005: PUSH
34006: LD_INT 3
34008: NEG
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: LIST
34018: LIST
34019: LIST
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34045: LD_ADDR_VAR 0 42
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 1
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 0
34138: PUSH
34139: LD_INT 2
34141: NEG
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 2
34160: PUSH
34161: LD_INT 1
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 2
34170: PUSH
34171: LD_INT 2
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 1
34180: PUSH
34181: LD_INT 2
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 0
34190: PUSH
34191: LD_INT 2
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 1
34200: NEG
34201: PUSH
34202: LD_INT 1
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 2
34211: NEG
34212: PUSH
34213: LD_INT 1
34215: NEG
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: LD_INT 2
34223: NEG
34224: PUSH
34225: LD_INT 2
34227: NEG
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 2
34235: NEG
34236: PUSH
34237: LD_INT 3
34239: NEG
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 1
34247: NEG
34248: PUSH
34249: LD_INT 3
34251: NEG
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: LD_INT 3
34262: NEG
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 1
34270: PUSH
34271: LD_INT 2
34273: NEG
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 3
34281: PUSH
34282: LD_INT 2
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 3
34291: PUSH
34292: LD_INT 3
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 2
34301: PUSH
34302: LD_INT 3
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: PUSH
34312: LD_INT 3
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: LD_INT 3
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 3
34342: NEG
34343: PUSH
34344: LD_INT 2
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 3
34354: NEG
34355: PUSH
34356: LD_INT 3
34358: NEG
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: LIST
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34395: LD_ADDR_VAR 0 43
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 0
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: LD_INT 1
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: NEG
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: NEG
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: LD_INT 2
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 0
34488: PUSH
34489: LD_INT 2
34491: NEG
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: LD_INT 1
34502: NEG
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: LD_INT 0
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: PUSH
34531: LD_INT 2
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: LD_INT 2
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 1
34550: NEG
34551: PUSH
34552: LD_INT 1
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 2
34561: NEG
34562: PUSH
34563: LD_INT 0
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 2
34572: NEG
34573: PUSH
34574: LD_INT 1
34576: NEG
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: LD_INT 3
34588: NEG
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: LD_INT 3
34599: NEG
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 1
34607: PUSH
34608: LD_INT 2
34610: NEG
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 2
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: LD_INT 3
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 3
34639: PUSH
34640: LD_INT 1
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 1
34649: PUSH
34650: LD_INT 3
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: LD_INT 3
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 1
34669: NEG
34670: PUSH
34671: LD_INT 2
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 2
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 3
34691: NEG
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 3
34702: NEG
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34743: LD_ADDR_VAR 0 44
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: LD_INT 0
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 0
34760: PUSH
34761: LD_INT 1
34763: NEG
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: LD_INT 0
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 1
34781: PUSH
34782: LD_INT 1
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: LD_INT 1
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: LD_INT 0
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: NEG
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: LD_INT 2
34828: NEG
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 1
34836: PUSH
34837: LD_INT 1
34839: NEG
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 2
34847: PUSH
34848: LD_INT 0
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 2
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 2
34867: PUSH
34868: LD_INT 2
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 2
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 1
34887: NEG
34888: PUSH
34889: LD_INT 1
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 2
34898: NEG
34899: PUSH
34900: LD_INT 0
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 2
34909: NEG
34910: PUSH
34911: LD_INT 1
34913: NEG
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: LD_INT 2
34925: NEG
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 2
34933: NEG
34934: PUSH
34935: LD_INT 3
34937: NEG
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 2
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: LD_INT 3
34956: PUSH
34957: LD_INT 0
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PUSH
34964: LD_INT 3
34966: PUSH
34967: LD_INT 1
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 3
34976: PUSH
34977: LD_INT 2
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 3
34986: PUSH
34987: LD_INT 3
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 2
34996: PUSH
34997: LD_INT 3
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 2
35006: NEG
35007: PUSH
35008: LD_INT 1
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 3
35017: NEG
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 3
35028: NEG
35029: PUSH
35030: LD_INT 1
35032: NEG
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 3
35040: NEG
35041: PUSH
35042: LD_INT 2
35044: NEG
35045: PUSH
35046: EMPTY
35047: LIST
35048: LIST
35049: PUSH
35050: LD_INT 3
35052: NEG
35053: PUSH
35054: LD_INT 3
35056: NEG
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35093: LD_ADDR_VAR 0 45
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: PUSH
35122: LD_INT 0
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 1
35131: PUSH
35132: LD_INT 1
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: LD_INT 1
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 1
35151: NEG
35152: PUSH
35153: LD_INT 0
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 1
35174: NEG
35175: PUSH
35176: LD_INT 2
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 0
35186: PUSH
35187: LD_INT 2
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: LD_INT 1
35200: NEG
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 2
35208: PUSH
35209: LD_INT 1
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PUSH
35216: LD_INT 2
35218: PUSH
35219: LD_INT 2
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 1
35228: PUSH
35229: LD_INT 2
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: LD_INT 2
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: LD_INT 1
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 2
35259: NEG
35260: PUSH
35261: LD_INT 1
35263: NEG
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: PUSH
35269: LD_INT 2
35271: NEG
35272: PUSH
35273: LD_INT 2
35275: NEG
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 2
35283: NEG
35284: PUSH
35285: LD_INT 3
35287: NEG
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 1
35295: NEG
35296: PUSH
35297: LD_INT 3
35299: NEG
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 0
35307: PUSH
35308: LD_INT 3
35310: NEG
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: LD_INT 2
35321: NEG
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 3
35329: PUSH
35330: LD_INT 2
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 3
35339: PUSH
35340: LD_INT 3
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 2
35349: PUSH
35350: LD_INT 3
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: LD_INT 3
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: LD_INT 3
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: LD_INT 2
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 3
35390: NEG
35391: PUSH
35392: LD_INT 2
35394: NEG
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 3
35402: NEG
35403: PUSH
35404: LD_INT 3
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35443: LD_ADDR_VAR 0 46
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 0
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 0
35460: PUSH
35461: LD_INT 1
35463: NEG
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 1
35471: PUSH
35472: LD_INT 0
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 1
35481: PUSH
35482: LD_INT 1
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 0
35491: PUSH
35492: LD_INT 1
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 1
35501: NEG
35502: PUSH
35503: LD_INT 0
35505: PUSH
35506: EMPTY
35507: LIST
35508: LIST
35509: PUSH
35510: LD_INT 1
35512: NEG
35513: PUSH
35514: LD_INT 1
35516: NEG
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 1
35524: NEG
35525: PUSH
35526: LD_INT 2
35528: NEG
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 0
35536: PUSH
35537: LD_INT 2
35539: NEG
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: PUSH
35548: LD_INT 1
35550: NEG
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: LD_INT 2
35558: PUSH
35559: LD_INT 0
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 2
35568: PUSH
35569: LD_INT 1
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: PUSH
35576: LD_INT 1
35578: PUSH
35579: LD_INT 2
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: LD_INT 2
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 2
35609: NEG
35610: PUSH
35611: LD_INT 0
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 2
35620: NEG
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 1
35632: NEG
35633: PUSH
35634: LD_INT 3
35636: NEG
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: LD_INT 3
35647: NEG
35648: PUSH
35649: EMPTY
35650: LIST
35651: LIST
35652: PUSH
35653: LD_INT 1
35655: PUSH
35656: LD_INT 2
35658: NEG
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 3
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 3
35687: PUSH
35688: LD_INT 1
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: LD_INT 3
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: LD_INT 3
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 1
35717: NEG
35718: PUSH
35719: LD_INT 2
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: NEG
35729: PUSH
35730: LD_INT 1
35732: PUSH
35733: EMPTY
35734: LIST
35735: LIST
35736: PUSH
35737: LD_INT 3
35739: NEG
35740: PUSH
35741: LD_INT 0
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 3
35750: NEG
35751: PUSH
35752: LD_INT 1
35754: NEG
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35791: LD_ADDR_VAR 0 47
35795: PUSH
35796: LD_INT 0
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: LD_INT 1
35811: NEG
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: PUSH
35820: LD_INT 0
35822: PUSH
35823: EMPTY
35824: LIST
35825: LIST
35826: PUSH
35827: LD_INT 1
35829: PUSH
35830: LD_INT 1
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: NEG
35850: PUSH
35851: LD_INT 0
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 1
35860: NEG
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 1
35872: NEG
35873: PUSH
35874: LD_INT 2
35876: NEG
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: LD_INT 2
35887: NEG
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 1
35895: PUSH
35896: LD_INT 1
35898: NEG
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 2
35906: NEG
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 2
35918: NEG
35919: PUSH
35920: LD_INT 2
35922: NEG
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: LIST
35938: LIST
35939: LIST
35940: LIST
35941: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
35942: LD_ADDR_VAR 0 48
35946: PUSH
35947: LD_INT 0
35949: PUSH
35950: LD_INT 0
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 0
35959: PUSH
35960: LD_INT 1
35962: NEG
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: LD_INT 0
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 1
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 0
35990: PUSH
35991: LD_INT 1
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: NEG
36001: PUSH
36002: LD_INT 0
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: LD_INT 1
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 1
36023: NEG
36024: PUSH
36025: LD_INT 2
36027: NEG
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: LD_INT 2
36038: NEG
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 2
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36089: LD_ADDR_VAR 0 49
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 1
36117: PUSH
36118: LD_INT 0
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 0
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: NEG
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 1
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 2
36181: PUSH
36182: LD_INT 0
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 2
36191: PUSH
36192: LD_INT 1
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 2
36201: PUSH
36202: LD_INT 2
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 1
36211: PUSH
36212: LD_INT 2
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: LIST
36228: LIST
36229: LIST
36230: LIST
36231: LIST
36232: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36233: LD_ADDR_VAR 0 50
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: LD_INT 0
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 0
36250: PUSH
36251: LD_INT 1
36253: NEG
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: LD_INT 0
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 1
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 0
36281: PUSH
36282: LD_INT 1
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: PUSH
36289: LD_INT 1
36291: NEG
36292: PUSH
36293: LD_INT 0
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PUSH
36312: LD_INT 2
36314: PUSH
36315: LD_INT 1
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 2
36324: PUSH
36325: LD_INT 2
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: LD_INT 2
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 0
36344: PUSH
36345: LD_INT 2
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: LD_INT 1
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36377: LD_ADDR_VAR 0 51
36381: PUSH
36382: LD_INT 0
36384: PUSH
36385: LD_INT 0
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 0
36394: PUSH
36395: LD_INT 1
36397: NEG
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 1
36405: PUSH
36406: LD_INT 0
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 1
36415: PUSH
36416: LD_INT 1
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 0
36425: PUSH
36426: LD_INT 1
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 1
36435: NEG
36436: PUSH
36437: LD_INT 0
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 1
36446: NEG
36447: PUSH
36448: LD_INT 1
36450: NEG
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 1
36458: PUSH
36459: LD_INT 2
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 0
36468: PUSH
36469: LD_INT 2
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 1
36478: NEG
36479: PUSH
36480: LD_INT 1
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 2
36489: NEG
36490: PUSH
36491: LD_INT 0
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 2
36500: NEG
36501: PUSH
36502: LD_INT 1
36504: NEG
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36524: LD_ADDR_VAR 0 52
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: LD_INT 0
36534: PUSH
36535: EMPTY
36536: LIST
36537: LIST
36538: PUSH
36539: LD_INT 0
36541: PUSH
36542: LD_INT 1
36544: NEG
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 1
36552: PUSH
36553: LD_INT 0
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 1
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 0
36572: PUSH
36573: LD_INT 1
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: LD_INT 0
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 1
36593: NEG
36594: PUSH
36595: LD_INT 1
36597: NEG
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 1
36605: NEG
36606: PUSH
36607: LD_INT 2
36609: NEG
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: LD_INT 1
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: PUSH
36626: LD_INT 2
36628: NEG
36629: PUSH
36630: LD_INT 0
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 2
36639: NEG
36640: PUSH
36641: LD_INT 1
36643: NEG
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 2
36651: NEG
36652: PUSH
36653: LD_INT 2
36655: NEG
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36675: LD_ADDR_VAR 0 53
36679: PUSH
36680: LD_INT 0
36682: PUSH
36683: LD_INT 0
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: PUSH
36690: LD_INT 0
36692: PUSH
36693: LD_INT 1
36695: NEG
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 1
36703: PUSH
36704: LD_INT 0
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 1
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 0
36723: PUSH
36724: LD_INT 1
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 1
36733: NEG
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 1
36744: NEG
36745: PUSH
36746: LD_INT 1
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 1
36756: NEG
36757: PUSH
36758: LD_INT 2
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 0
36768: PUSH
36769: LD_INT 2
36771: NEG
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 1
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 2
36790: PUSH
36791: LD_INT 0
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 2
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 2
36810: PUSH
36811: LD_INT 2
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: LD_INT 2
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 0
36830: PUSH
36831: LD_INT 2
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 1
36840: NEG
36841: PUSH
36842: LD_INT 1
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 2
36851: NEG
36852: PUSH
36853: LD_INT 0
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 2
36862: NEG
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 2
36874: NEG
36875: PUSH
36876: LD_INT 2
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: LIST
36901: LIST
36902: LIST
36903: LIST
36904: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36905: LD_ADDR_VAR 0 54
36909: PUSH
36910: LD_INT 0
36912: PUSH
36913: LD_INT 0
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 0
36922: PUSH
36923: LD_INT 1
36925: NEG
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: LD_INT 0
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 1
36943: PUSH
36944: LD_INT 1
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 0
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 1
36963: NEG
36964: PUSH
36965: LD_INT 0
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 1
36974: NEG
36975: PUSH
36976: LD_INT 1
36978: NEG
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: NEG
36987: PUSH
36988: LD_INT 2
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 2
37001: NEG
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 1
37012: NEG
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 2
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 2
37030: PUSH
37031: LD_INT 1
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 2
37040: PUSH
37041: LD_INT 2
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: LD_INT 2
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 0
37060: PUSH
37061: LD_INT 2
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 1
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 2
37081: NEG
37082: PUSH
37083: LD_INT 0
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 2
37092: NEG
37093: PUSH
37094: LD_INT 1
37096: NEG
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 2
37104: NEG
37105: PUSH
37106: LD_INT 2
37108: NEG
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37135: LD_ADDR_VAR 0 55
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 0
37152: PUSH
37153: LD_INT 1
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 0
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 1
37204: NEG
37205: PUSH
37206: LD_INT 1
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: LD_INT 2
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 0
37228: PUSH
37229: LD_INT 2
37231: NEG
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 1
37239: PUSH
37240: LD_INT 1
37242: NEG
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: PUSH
37248: LD_INT 2
37250: PUSH
37251: LD_INT 0
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 2
37260: PUSH
37261: LD_INT 1
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 2
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 1
37280: PUSH
37281: LD_INT 2
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 0
37290: PUSH
37291: LD_INT 2
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 1
37300: NEG
37301: PUSH
37302: LD_INT 1
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PUSH
37309: LD_INT 2
37311: NEG
37312: PUSH
37313: LD_INT 0
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 2
37322: NEG
37323: PUSH
37324: LD_INT 1
37326: NEG
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 2
37334: NEG
37335: PUSH
37336: LD_INT 2
37338: NEG
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37365: LD_ADDR_VAR 0 56
37369: PUSH
37370: LD_INT 0
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 1
37423: NEG
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: LD_INT 2
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 2
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 2
37500: PUSH
37501: LD_INT 2
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 1
37510: PUSH
37511: LD_INT 2
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 2
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 2
37541: NEG
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 2
37552: NEG
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: NEG
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37595: LD_ADDR_VAR 0 57
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 0
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 1
37676: NEG
37677: PUSH
37678: LD_INT 2
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 1
37699: PUSH
37700: LD_INT 1
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: LD_INT 1
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 2
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: NEG
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: NEG
37783: PUSH
37784: LD_INT 1
37786: NEG
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37825: LD_ADDR_VAR 0 58
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: LD_INT 1
37845: NEG
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: LD_INT 0
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 1
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: LD_INT 2
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 0
37918: PUSH
37919: LD_INT 2
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 1
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: LD_INT 1
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 2
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 2
38001: NEG
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 1
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: LD_INT 2
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38055: LD_ADDR_VAR 0 59
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 1
38075: NEG
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: LD_INT 1
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38143: LD_ADDR_VAR 0 60
38147: PUSH
38148: LD_INT 0
38150: PUSH
38151: LD_INT 0
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 0
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: LD_INT 0
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 1
38181: PUSH
38182: LD_INT 1
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 0
38191: PUSH
38192: LD_INT 1
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 1
38212: NEG
38213: PUSH
38214: LD_INT 1
38216: NEG
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38231: LD_ADDR_VAR 0 61
38235: PUSH
38236: LD_INT 0
38238: PUSH
38239: LD_INT 0
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 0
38248: PUSH
38249: LD_INT 1
38251: NEG
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 1
38259: PUSH
38260: LD_INT 0
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: LD_INT 1
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 1
38289: NEG
38290: PUSH
38291: LD_INT 0
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 1
38300: NEG
38301: PUSH
38302: LD_INT 1
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38319: LD_ADDR_VAR 0 62
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: LD_INT 0
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 0
38336: PUSH
38337: LD_INT 1
38339: NEG
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 1
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 1
38357: PUSH
38358: LD_INT 1
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 0
38367: PUSH
38368: LD_INT 1
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 1
38377: NEG
38378: PUSH
38379: LD_INT 0
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 1
38388: NEG
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38407: LD_ADDR_VAR 0 63
38411: PUSH
38412: LD_INT 0
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: LD_INT 1
38427: NEG
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 1
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 1
38445: PUSH
38446: LD_INT 1
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: LD_INT 1
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: NEG
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: LD_INT 1
38480: NEG
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: LIST
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38495: LD_ADDR_VAR 0 64
38499: PUSH
38500: LD_INT 0
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 0
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 1
38523: PUSH
38524: LD_INT 0
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 1
38533: PUSH
38534: LD_INT 1
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 0
38543: PUSH
38544: LD_INT 1
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: NEG
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: NEG
38565: PUSH
38566: LD_INT 1
38568: NEG
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: LIST
38581: LIST
38582: ST_TO_ADDR
// end ; 1 :
38583: GO 44480
38585: LD_INT 1
38587: DOUBLE
38588: EQUAL
38589: IFTRUE 38593
38591: GO 41216
38593: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38594: LD_ADDR_VAR 0 11
38598: PUSH
38599: LD_INT 1
38601: NEG
38602: PUSH
38603: LD_INT 3
38605: NEG
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 0
38613: PUSH
38614: LD_INT 3
38616: NEG
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 1
38624: PUSH
38625: LD_INT 2
38627: NEG
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: LIST
38637: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38638: LD_ADDR_VAR 0 12
38642: PUSH
38643: LD_INT 2
38645: PUSH
38646: LD_INT 1
38648: NEG
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 3
38656: PUSH
38657: LD_INT 0
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 3
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: LIST
38678: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38679: LD_ADDR_VAR 0 13
38683: PUSH
38684: LD_INT 3
38686: PUSH
38687: LD_INT 2
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 3
38696: PUSH
38697: LD_INT 3
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 2
38706: PUSH
38707: LD_INT 3
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: LIST
38718: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38719: LD_ADDR_VAR 0 14
38723: PUSH
38724: LD_INT 1
38726: PUSH
38727: LD_INT 3
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: LD_INT 0
38736: PUSH
38737: LD_INT 3
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 1
38746: NEG
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: LIST
38759: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38760: LD_ADDR_VAR 0 15
38764: PUSH
38765: LD_INT 2
38767: NEG
38768: PUSH
38769: LD_INT 1
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 3
38778: NEG
38779: PUSH
38780: LD_INT 0
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 3
38789: NEG
38790: PUSH
38791: LD_INT 1
38793: NEG
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: LIST
38803: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38804: LD_ADDR_VAR 0 16
38808: PUSH
38809: LD_INT 2
38811: NEG
38812: PUSH
38813: LD_INT 3
38815: NEG
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 3
38823: NEG
38824: PUSH
38825: LD_INT 2
38827: NEG
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 3
38835: NEG
38836: PUSH
38837: LD_INT 3
38839: NEG
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38850: LD_ADDR_VAR 0 17
38854: PUSH
38855: LD_INT 1
38857: NEG
38858: PUSH
38859: LD_INT 3
38861: NEG
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 0
38869: PUSH
38870: LD_INT 3
38872: NEG
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 1
38880: PUSH
38881: LD_INT 2
38883: NEG
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: LIST
38893: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38894: LD_ADDR_VAR 0 18
38898: PUSH
38899: LD_INT 2
38901: PUSH
38902: LD_INT 1
38904: NEG
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: PUSH
38910: LD_INT 3
38912: PUSH
38913: LD_INT 0
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 3
38922: PUSH
38923: LD_INT 1
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: LIST
38934: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38935: LD_ADDR_VAR 0 19
38939: PUSH
38940: LD_INT 3
38942: PUSH
38943: LD_INT 2
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 3
38952: PUSH
38953: LD_INT 3
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 2
38962: PUSH
38963: LD_INT 3
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: LIST
38974: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38975: LD_ADDR_VAR 0 20
38979: PUSH
38980: LD_INT 1
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: LD_INT 3
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: LD_INT 1
39002: NEG
39003: PUSH
39004: LD_INT 2
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: LIST
39015: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39016: LD_ADDR_VAR 0 21
39020: PUSH
39021: LD_INT 2
39023: NEG
39024: PUSH
39025: LD_INT 1
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 3
39034: NEG
39035: PUSH
39036: LD_INT 0
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 3
39045: NEG
39046: PUSH
39047: LD_INT 1
39049: NEG
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: LIST
39059: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39060: LD_ADDR_VAR 0 22
39064: PUSH
39065: LD_INT 2
39067: NEG
39068: PUSH
39069: LD_INT 3
39071: NEG
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 3
39079: NEG
39080: PUSH
39081: LD_INT 2
39083: NEG
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 3
39091: NEG
39092: PUSH
39093: LD_INT 3
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: LIST
39105: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39106: LD_ADDR_VAR 0 23
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: LD_INT 3
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 1
39124: NEG
39125: PUSH
39126: LD_INT 4
39128: NEG
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 1
39136: PUSH
39137: LD_INT 3
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: LIST
39149: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39150: LD_ADDR_VAR 0 24
39154: PUSH
39155: LD_INT 3
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 3
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 4
39178: PUSH
39179: LD_INT 1
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: LIST
39190: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39191: LD_ADDR_VAR 0 25
39195: PUSH
39196: LD_INT 3
39198: PUSH
39199: LD_INT 3
39201: PUSH
39202: EMPTY
39203: LIST
39204: LIST
39205: PUSH
39206: LD_INT 4
39208: PUSH
39209: LD_INT 3
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 3
39218: PUSH
39219: LD_INT 4
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: LIST
39230: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39231: LD_ADDR_VAR 0 26
39235: PUSH
39236: LD_INT 0
39238: PUSH
39239: LD_INT 3
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 4
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: LD_INT 3
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: LIST
39271: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39272: LD_ADDR_VAR 0 27
39276: PUSH
39277: LD_INT 3
39279: NEG
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 3
39290: NEG
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 4
39301: NEG
39302: PUSH
39303: LD_INT 1
39305: NEG
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: LIST
39315: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
39316: LD_ADDR_VAR 0 28
39320: PUSH
39321: LD_INT 3
39323: NEG
39324: PUSH
39325: LD_INT 3
39327: NEG
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 3
39335: NEG
39336: PUSH
39337: LD_INT 4
39339: NEG
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 4
39347: NEG
39348: PUSH
39349: LD_INT 3
39351: NEG
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: EMPTY
39358: LIST
39359: LIST
39360: LIST
39361: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
39362: LD_ADDR_VAR 0 29
39366: PUSH
39367: LD_INT 1
39369: NEG
39370: PUSH
39371: LD_INT 3
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 0
39381: PUSH
39382: LD_INT 3
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 1
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: NEG
39404: PUSH
39405: LD_INT 4
39407: NEG
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 0
39415: PUSH
39416: LD_INT 4
39418: NEG
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: LD_INT 3
39429: NEG
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 1
39437: NEG
39438: PUSH
39439: LD_INT 5
39441: NEG
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 0
39449: PUSH
39450: LD_INT 5
39452: NEG
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 1
39460: PUSH
39461: LD_INT 4
39463: NEG
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: LD_INT 1
39471: NEG
39472: PUSH
39473: LD_INT 6
39475: NEG
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PUSH
39481: LD_INT 0
39483: PUSH
39484: LD_INT 6
39486: NEG
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 1
39494: PUSH
39495: LD_INT 5
39497: NEG
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: LIST
39507: LIST
39508: LIST
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
39517: LD_ADDR_VAR 0 30
39521: PUSH
39522: LD_INT 2
39524: PUSH
39525: LD_INT 1
39527: NEG
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 3
39535: PUSH
39536: LD_INT 0
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 3
39545: PUSH
39546: LD_INT 1
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 3
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 4
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 4
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 4
39586: PUSH
39587: LD_INT 1
39589: NEG
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 5
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 5
39607: PUSH
39608: LD_INT 1
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 5
39617: PUSH
39618: LD_INT 1
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 6
39628: PUSH
39629: LD_INT 0
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 6
39638: PUSH
39639: LD_INT 1
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
39660: LD_ADDR_VAR 0 31
39664: PUSH
39665: LD_INT 3
39667: PUSH
39668: LD_INT 2
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 3
39677: PUSH
39678: LD_INT 3
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 2
39687: PUSH
39688: LD_INT 3
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 4
39697: PUSH
39698: LD_INT 3
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 4
39707: PUSH
39708: LD_INT 4
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 3
39717: PUSH
39718: LD_INT 4
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 5
39727: PUSH
39728: LD_INT 4
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 5
39737: PUSH
39738: LD_INT 5
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 4
39747: PUSH
39748: LD_INT 5
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 6
39757: PUSH
39758: LD_INT 5
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 6
39767: PUSH
39768: LD_INT 6
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 5
39777: PUSH
39778: LD_INT 6
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: LIST
39789: LIST
39790: LIST
39791: LIST
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: LIST
39798: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
39799: LD_ADDR_VAR 0 32
39803: PUSH
39804: LD_INT 1
39806: PUSH
39807: LD_INT 3
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 0
39816: PUSH
39817: LD_INT 3
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: NEG
39827: PUSH
39828: LD_INT 2
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 1
39837: PUSH
39838: LD_INT 4
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 0
39847: PUSH
39848: LD_INT 4
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 1
39857: NEG
39858: PUSH
39859: LD_INT 3
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: LD_INT 5
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: LD_INT 5
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: LD_INT 4
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: LD_INT 6
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: LD_INT 6
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 1
39919: NEG
39920: PUSH
39921: LD_INT 5
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
39942: LD_ADDR_VAR 0 33
39946: PUSH
39947: LD_INT 2
39949: NEG
39950: PUSH
39951: LD_INT 1
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 3
39960: NEG
39961: PUSH
39962: LD_INT 0
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 3
39971: NEG
39972: PUSH
39973: LD_INT 1
39975: NEG
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 3
39983: NEG
39984: PUSH
39985: LD_INT 1
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 4
39994: NEG
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 4
40005: NEG
40006: PUSH
40007: LD_INT 1
40009: NEG
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 4
40017: NEG
40018: PUSH
40019: LD_INT 1
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 5
40028: NEG
40029: PUSH
40030: LD_INT 0
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 5
40039: NEG
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 5
40051: NEG
40052: PUSH
40053: LD_INT 1
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 6
40062: NEG
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 6
40073: NEG
40074: PUSH
40075: LD_INT 1
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40097: LD_ADDR_VAR 0 34
40101: PUSH
40102: LD_INT 2
40104: NEG
40105: PUSH
40106: LD_INT 3
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 3
40116: NEG
40117: PUSH
40118: LD_INT 2
40120: NEG
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 3
40128: NEG
40129: PUSH
40130: LD_INT 3
40132: NEG
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 3
40140: NEG
40141: PUSH
40142: LD_INT 4
40144: NEG
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 4
40152: NEG
40153: PUSH
40154: LD_INT 3
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 4
40164: NEG
40165: PUSH
40166: LD_INT 4
40168: NEG
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 4
40176: NEG
40177: PUSH
40178: LD_INT 5
40180: NEG
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 5
40188: NEG
40189: PUSH
40190: LD_INT 4
40192: NEG
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 5
40200: NEG
40201: PUSH
40202: LD_INT 5
40204: NEG
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 5
40212: NEG
40213: PUSH
40214: LD_INT 6
40216: NEG
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: LD_INT 6
40224: NEG
40225: PUSH
40226: LD_INT 5
40228: NEG
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 6
40236: NEG
40237: PUSH
40238: LD_INT 6
40240: NEG
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40260: LD_ADDR_VAR 0 41
40264: PUSH
40265: LD_INT 0
40267: PUSH
40268: LD_INT 2
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 1
40278: NEG
40279: PUSH
40280: LD_INT 3
40282: NEG
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 1
40290: PUSH
40291: LD_INT 2
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: LIST
40303: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40304: LD_ADDR_VAR 0 42
40308: PUSH
40309: LD_INT 2
40311: PUSH
40312: LD_INT 0
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 2
40321: PUSH
40322: LD_INT 1
40324: NEG
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 3
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: LIST
40344: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
40345: LD_ADDR_VAR 0 43
40349: PUSH
40350: LD_INT 2
40352: PUSH
40353: LD_INT 2
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 3
40362: PUSH
40363: LD_INT 2
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 2
40372: PUSH
40373: LD_INT 3
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: LIST
40384: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
40385: LD_ADDR_VAR 0 44
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: LD_INT 2
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: PUSH
40400: LD_INT 1
40402: PUSH
40403: LD_INT 3
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 1
40412: NEG
40413: PUSH
40414: LD_INT 2
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40426: LD_ADDR_VAR 0 45
40430: PUSH
40431: LD_INT 2
40433: NEG
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 2
40444: NEG
40445: PUSH
40446: LD_INT 1
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 3
40455: NEG
40456: PUSH
40457: LD_INT 1
40459: NEG
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: LIST
40469: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
40470: LD_ADDR_VAR 0 46
40474: PUSH
40475: LD_INT 2
40477: NEG
40478: PUSH
40479: LD_INT 2
40481: NEG
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 2
40489: NEG
40490: PUSH
40491: LD_INT 3
40493: NEG
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 3
40501: NEG
40502: PUSH
40503: LD_INT 2
40505: NEG
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: LIST
40515: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
40516: LD_ADDR_VAR 0 47
40520: PUSH
40521: LD_INT 2
40523: NEG
40524: PUSH
40525: LD_INT 3
40527: NEG
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: LD_INT 1
40535: NEG
40536: PUSH
40537: LD_INT 3
40539: NEG
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
40549: LD_ADDR_VAR 0 48
40553: PUSH
40554: LD_INT 1
40556: PUSH
40557: LD_INT 2
40559: NEG
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: PUSH
40565: LD_INT 2
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
40580: LD_ADDR_VAR 0 49
40584: PUSH
40585: LD_INT 3
40587: PUSH
40588: LD_INT 1
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 3
40597: PUSH
40598: LD_INT 2
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
40609: LD_ADDR_VAR 0 50
40613: PUSH
40614: LD_INT 2
40616: PUSH
40617: LD_INT 3
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: PUSH
40627: LD_INT 3
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
40638: LD_ADDR_VAR 0 51
40642: PUSH
40643: LD_INT 1
40645: NEG
40646: PUSH
40647: LD_INT 2
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 2
40656: NEG
40657: PUSH
40658: LD_INT 1
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
40669: LD_ADDR_VAR 0 52
40673: PUSH
40674: LD_INT 3
40676: NEG
40677: PUSH
40678: LD_INT 1
40680: NEG
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 3
40688: NEG
40689: PUSH
40690: LD_INT 2
40692: NEG
40693: PUSH
40694: EMPTY
40695: LIST
40696: LIST
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40702: LD_ADDR_VAR 0 53
40706: PUSH
40707: LD_INT 1
40709: NEG
40710: PUSH
40711: LD_INT 3
40713: NEG
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: LD_INT 0
40721: PUSH
40722: LD_INT 3
40724: NEG
40725: PUSH
40726: EMPTY
40727: LIST
40728: LIST
40729: PUSH
40730: LD_INT 1
40732: PUSH
40733: LD_INT 2
40735: NEG
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: LIST
40745: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40746: LD_ADDR_VAR 0 54
40750: PUSH
40751: LD_INT 2
40753: PUSH
40754: LD_INT 1
40756: NEG
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 3
40764: PUSH
40765: LD_INT 0
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 3
40774: PUSH
40775: LD_INT 1
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: LIST
40786: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40787: LD_ADDR_VAR 0 55
40791: PUSH
40792: LD_INT 3
40794: PUSH
40795: LD_INT 2
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 3
40804: PUSH
40805: LD_INT 3
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 2
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: LIST
40826: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40827: LD_ADDR_VAR 0 56
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 3
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: LD_INT 3
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: LD_INT 2
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: LIST
40867: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40868: LD_ADDR_VAR 0 57
40872: PUSH
40873: LD_INT 2
40875: NEG
40876: PUSH
40877: LD_INT 1
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 3
40886: NEG
40887: PUSH
40888: LD_INT 0
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 3
40897: NEG
40898: PUSH
40899: LD_INT 1
40901: NEG
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: LIST
40911: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40912: LD_ADDR_VAR 0 58
40916: PUSH
40917: LD_INT 2
40919: NEG
40920: PUSH
40921: LD_INT 3
40923: NEG
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 3
40931: NEG
40932: PUSH
40933: LD_INT 2
40935: NEG
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 3
40943: NEG
40944: PUSH
40945: LD_INT 3
40947: NEG
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: LIST
40957: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
40958: LD_ADDR_VAR 0 59
40962: PUSH
40963: LD_INT 1
40965: NEG
40966: PUSH
40967: LD_INT 2
40969: NEG
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: LD_INT 2
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 1
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: LIST
41001: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41002: LD_ADDR_VAR 0 60
41006: PUSH
41007: LD_INT 1
41009: PUSH
41010: LD_INT 1
41012: NEG
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: PUSH
41018: LD_INT 2
41020: PUSH
41021: LD_INT 0
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: LD_INT 2
41030: PUSH
41031: LD_INT 1
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: LIST
41042: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41043: LD_ADDR_VAR 0 61
41047: PUSH
41048: LD_INT 2
41050: PUSH
41051: LD_INT 1
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 2
41060: PUSH
41061: LD_INT 2
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 1
41070: PUSH
41071: LD_INT 2
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: LIST
41082: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41083: LD_ADDR_VAR 0 62
41087: PUSH
41088: LD_INT 1
41090: PUSH
41091: LD_INT 2
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: LD_INT 2
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 1
41110: NEG
41111: PUSH
41112: LD_INT 1
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: LIST
41123: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41124: LD_ADDR_VAR 0 63
41128: PUSH
41129: LD_INT 1
41131: NEG
41132: PUSH
41133: LD_INT 1
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: PUSH
41140: LD_INT 2
41142: NEG
41143: PUSH
41144: LD_INT 0
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 2
41153: NEG
41154: PUSH
41155: LD_INT 1
41157: NEG
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: LIST
41167: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41168: LD_ADDR_VAR 0 64
41172: PUSH
41173: LD_INT 1
41175: NEG
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 2
41187: NEG
41188: PUSH
41189: LD_INT 1
41191: NEG
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 2
41199: NEG
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: LIST
41213: ST_TO_ADDR
// end ; 2 :
41214: GO 44480
41216: LD_INT 2
41218: DOUBLE
41219: EQUAL
41220: IFTRUE 41224
41222: GO 44479
41224: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41225: LD_ADDR_VAR 0 29
41229: PUSH
41230: LD_INT 4
41232: PUSH
41233: LD_INT 0
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 4
41242: PUSH
41243: LD_INT 1
41245: NEG
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 5
41253: PUSH
41254: LD_INT 0
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 5
41263: PUSH
41264: LD_INT 1
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 4
41273: PUSH
41274: LD_INT 1
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 3
41283: PUSH
41284: LD_INT 0
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 3
41293: PUSH
41294: LD_INT 1
41296: NEG
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: LD_INT 3
41304: PUSH
41305: LD_INT 2
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 5
41315: PUSH
41316: LD_INT 2
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: LD_INT 3
41325: PUSH
41326: LD_INT 3
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: LD_INT 2
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 4
41345: PUSH
41346: LD_INT 3
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 4
41355: PUSH
41356: LD_INT 4
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 3
41365: PUSH
41366: LD_INT 4
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 2
41375: PUSH
41376: LD_INT 3
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 2
41385: PUSH
41386: LD_INT 2
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 4
41395: PUSH
41396: LD_INT 2
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 2
41405: PUSH
41406: LD_INT 4
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: LD_INT 0
41415: PUSH
41416: LD_INT 4
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: LD_INT 0
41425: PUSH
41426: LD_INT 3
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 1
41435: PUSH
41436: LD_INT 4
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: PUSH
41446: LD_INT 5
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 0
41455: PUSH
41456: LD_INT 5
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: LD_INT 1
41465: NEG
41466: PUSH
41467: LD_INT 4
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 1
41476: NEG
41477: PUSH
41478: LD_INT 3
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 2
41487: PUSH
41488: LD_INT 5
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: LD_INT 2
41497: NEG
41498: PUSH
41499: LD_INT 3
41501: PUSH
41502: EMPTY
41503: LIST
41504: LIST
41505: PUSH
41506: LD_INT 3
41508: NEG
41509: PUSH
41510: LD_INT 0
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 3
41519: NEG
41520: PUSH
41521: LD_INT 1
41523: NEG
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: PUSH
41529: LD_INT 2
41531: NEG
41532: PUSH
41533: LD_INT 0
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 2
41542: NEG
41543: PUSH
41544: LD_INT 1
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 3
41553: NEG
41554: PUSH
41555: LD_INT 1
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: LD_INT 4
41564: NEG
41565: PUSH
41566: LD_INT 0
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 4
41575: NEG
41576: PUSH
41577: LD_INT 1
41579: NEG
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 4
41587: NEG
41588: PUSH
41589: LD_INT 2
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 2
41599: NEG
41600: PUSH
41601: LD_INT 2
41603: PUSH
41604: EMPTY
41605: LIST
41606: LIST
41607: PUSH
41608: LD_INT 4
41610: NEG
41611: PUSH
41612: LD_INT 4
41614: NEG
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: LD_INT 4
41622: NEG
41623: PUSH
41624: LD_INT 5
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 3
41634: NEG
41635: PUSH
41636: LD_INT 4
41638: NEG
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 3
41646: NEG
41647: PUSH
41648: LD_INT 3
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 4
41658: NEG
41659: PUSH
41660: LD_INT 3
41662: NEG
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: LD_INT 5
41670: NEG
41671: PUSH
41672: LD_INT 4
41674: NEG
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 5
41682: NEG
41683: PUSH
41684: LD_INT 5
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 3
41694: NEG
41695: PUSH
41696: LD_INT 5
41698: NEG
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 5
41706: NEG
41707: PUSH
41708: LD_INT 3
41710: NEG
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: LIST
41724: LIST
41725: LIST
41726: LIST
41727: LIST
41728: LIST
41729: LIST
41730: LIST
41731: LIST
41732: LIST
41733: LIST
41734: LIST
41735: LIST
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: LIST
41741: LIST
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
41763: LD_ADDR_VAR 0 30
41767: PUSH
41768: LD_INT 4
41770: PUSH
41771: LD_INT 4
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 4
41780: PUSH
41781: LD_INT 3
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 5
41790: PUSH
41791: LD_INT 4
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 5
41800: PUSH
41801: LD_INT 5
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 4
41810: PUSH
41811: LD_INT 5
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 3
41820: PUSH
41821: LD_INT 4
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 3
41830: PUSH
41831: LD_INT 3
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 5
41840: PUSH
41841: LD_INT 3
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 3
41850: PUSH
41851: LD_INT 5
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 0
41860: PUSH
41861: LD_INT 3
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: LD_INT 2
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 1
41880: PUSH
41881: LD_INT 3
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 1
41890: PUSH
41891: LD_INT 4
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: LD_INT 0
41900: PUSH
41901: LD_INT 4
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 1
41910: NEG
41911: PUSH
41912: LD_INT 3
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 1
41921: NEG
41922: PUSH
41923: LD_INT 2
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 2
41932: PUSH
41933: LD_INT 4
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: LD_INT 2
41942: NEG
41943: PUSH
41944: LD_INT 2
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 4
41953: NEG
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: EMPTY
41959: LIST
41960: LIST
41961: PUSH
41962: LD_INT 4
41964: NEG
41965: PUSH
41966: LD_INT 1
41968: NEG
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 3
41976: NEG
41977: PUSH
41978: LD_INT 0
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 3
41987: NEG
41988: PUSH
41989: LD_INT 1
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 4
41998: NEG
41999: PUSH
42000: LD_INT 1
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PUSH
42007: LD_INT 5
42009: NEG
42010: PUSH
42011: LD_INT 0
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 5
42020: NEG
42021: PUSH
42022: LD_INT 1
42024: NEG
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 5
42032: NEG
42033: PUSH
42034: LD_INT 2
42036: NEG
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: PUSH
42042: LD_INT 3
42044: NEG
42045: PUSH
42046: LD_INT 2
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 3
42055: NEG
42056: PUSH
42057: LD_INT 3
42059: NEG
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 3
42067: NEG
42068: PUSH
42069: LD_INT 4
42071: NEG
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: PUSH
42077: LD_INT 2
42079: NEG
42080: PUSH
42081: LD_INT 3
42083: NEG
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 2
42091: NEG
42092: PUSH
42093: LD_INT 2
42095: NEG
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 3
42103: NEG
42104: PUSH
42105: LD_INT 2
42107: NEG
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 4
42115: NEG
42116: PUSH
42117: LD_INT 3
42119: NEG
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: LD_INT 4
42127: NEG
42128: PUSH
42129: LD_INT 4
42131: NEG
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 2
42139: NEG
42140: PUSH
42141: LD_INT 4
42143: NEG
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 4
42151: NEG
42152: PUSH
42153: LD_INT 2
42155: NEG
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: LD_INT 4
42166: NEG
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PUSH
42172: LD_INT 0
42174: PUSH
42175: LD_INT 5
42177: NEG
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 1
42185: PUSH
42186: LD_INT 4
42188: NEG
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: LD_INT 1
42196: PUSH
42197: LD_INT 3
42199: NEG
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 0
42207: PUSH
42208: LD_INT 3
42210: NEG
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 1
42218: NEG
42219: PUSH
42220: LD_INT 4
42222: NEG
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 1
42230: NEG
42231: PUSH
42232: LD_INT 5
42234: NEG
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: LD_INT 2
42242: PUSH
42243: LD_INT 3
42245: NEG
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: LD_INT 2
42253: NEG
42254: PUSH
42255: LD_INT 5
42257: NEG
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: LIST
42267: LIST
42268: LIST
42269: LIST
42270: LIST
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: LIST
42276: LIST
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: LIST
42284: LIST
42285: LIST
42286: LIST
42287: LIST
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
42310: LD_ADDR_VAR 0 31
42314: PUSH
42315: LD_INT 0
42317: PUSH
42318: LD_INT 4
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 0
42327: PUSH
42328: LD_INT 3
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 1
42337: PUSH
42338: LD_INT 4
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: LD_INT 5
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 0
42357: PUSH
42358: LD_INT 5
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 1
42367: NEG
42368: PUSH
42369: LD_INT 4
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 1
42378: NEG
42379: PUSH
42380: LD_INT 3
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 2
42389: PUSH
42390: LD_INT 5
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: LD_INT 3
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 3
42410: NEG
42411: PUSH
42412: LD_INT 0
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 3
42421: NEG
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 2
42433: NEG
42434: PUSH
42435: LD_INT 0
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 2
42444: NEG
42445: PUSH
42446: LD_INT 1
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 3
42455: NEG
42456: PUSH
42457: LD_INT 1
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 4
42466: NEG
42467: PUSH
42468: LD_INT 0
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 4
42477: NEG
42478: PUSH
42479: LD_INT 1
42481: NEG
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 4
42489: NEG
42490: PUSH
42491: LD_INT 2
42493: NEG
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 2
42501: NEG
42502: PUSH
42503: LD_INT 2
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 4
42512: NEG
42513: PUSH
42514: LD_INT 4
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 4
42524: NEG
42525: PUSH
42526: LD_INT 5
42528: NEG
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 3
42536: NEG
42537: PUSH
42538: LD_INT 4
42540: NEG
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 3
42548: NEG
42549: PUSH
42550: LD_INT 3
42552: NEG
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 4
42560: NEG
42561: PUSH
42562: LD_INT 3
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 5
42572: NEG
42573: PUSH
42574: LD_INT 4
42576: NEG
42577: PUSH
42578: EMPTY
42579: LIST
42580: LIST
42581: PUSH
42582: LD_INT 5
42584: NEG
42585: PUSH
42586: LD_INT 5
42588: NEG
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 3
42596: NEG
42597: PUSH
42598: LD_INT 5
42600: NEG
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 5
42608: NEG
42609: PUSH
42610: LD_INT 3
42612: NEG
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 0
42620: PUSH
42621: LD_INT 3
42623: NEG
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 0
42631: PUSH
42632: LD_INT 4
42634: NEG
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 1
42642: PUSH
42643: LD_INT 3
42645: NEG
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: LD_INT 1
42653: PUSH
42654: LD_INT 2
42656: NEG
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: LD_INT 0
42664: PUSH
42665: LD_INT 2
42667: NEG
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 1
42675: NEG
42676: PUSH
42677: LD_INT 3
42679: NEG
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: LD_INT 4
42691: NEG
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 2
42699: PUSH
42700: LD_INT 2
42702: NEG
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 2
42710: NEG
42711: PUSH
42712: LD_INT 4
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 4
42722: PUSH
42723: LD_INT 0
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 4
42732: PUSH
42733: LD_INT 1
42735: NEG
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 5
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 5
42753: PUSH
42754: LD_INT 1
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 4
42763: PUSH
42764: LD_INT 1
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 3
42773: PUSH
42774: LD_INT 0
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 3
42783: PUSH
42784: LD_INT 1
42786: NEG
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 3
42794: PUSH
42795: LD_INT 2
42797: NEG
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 5
42805: PUSH
42806: LD_INT 2
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: LIST
42821: LIST
42822: LIST
42823: LIST
42824: LIST
42825: LIST
42826: LIST
42827: LIST
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: LIST
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: LIST
42842: LIST
42843: LIST
42844: LIST
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
42860: LD_ADDR_VAR 0 32
42864: PUSH
42865: LD_INT 4
42867: NEG
42868: PUSH
42869: LD_INT 0
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 4
42878: NEG
42879: PUSH
42880: LD_INT 1
42882: NEG
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: LD_INT 3
42890: NEG
42891: PUSH
42892: LD_INT 0
42894: PUSH
42895: EMPTY
42896: LIST
42897: LIST
42898: PUSH
42899: LD_INT 3
42901: NEG
42902: PUSH
42903: LD_INT 1
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: PUSH
42910: LD_INT 4
42912: NEG
42913: PUSH
42914: LD_INT 1
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: LD_INT 5
42923: NEG
42924: PUSH
42925: LD_INT 0
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: PUSH
42932: LD_INT 5
42934: NEG
42935: PUSH
42936: LD_INT 1
42938: NEG
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: LD_INT 5
42946: NEG
42947: PUSH
42948: LD_INT 2
42950: NEG
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 3
42958: NEG
42959: PUSH
42960: LD_INT 2
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 3
42969: NEG
42970: PUSH
42971: LD_INT 3
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 3
42981: NEG
42982: PUSH
42983: LD_INT 4
42985: NEG
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 2
42993: NEG
42994: PUSH
42995: LD_INT 3
42997: NEG
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 2
43005: NEG
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 3
43017: NEG
43018: PUSH
43019: LD_INT 2
43021: NEG
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 4
43029: NEG
43030: PUSH
43031: LD_INT 3
43033: NEG
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 4
43041: NEG
43042: PUSH
43043: LD_INT 4
43045: NEG
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: LD_INT 2
43053: NEG
43054: PUSH
43055: LD_INT 4
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 4
43065: NEG
43066: PUSH
43067: LD_INT 2
43069: NEG
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 0
43077: PUSH
43078: LD_INT 4
43080: NEG
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: LD_INT 0
43088: PUSH
43089: LD_INT 5
43091: NEG
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 1
43099: PUSH
43100: LD_INT 4
43102: NEG
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: PUSH
43108: LD_INT 1
43110: PUSH
43111: LD_INT 3
43113: NEG
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 0
43121: PUSH
43122: LD_INT 3
43124: NEG
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: PUSH
43130: LD_INT 1
43132: NEG
43133: PUSH
43134: LD_INT 4
43136: NEG
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: PUSH
43142: LD_INT 1
43144: NEG
43145: PUSH
43146: LD_INT 5
43148: NEG
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 2
43156: PUSH
43157: LD_INT 3
43159: NEG
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 2
43167: NEG
43168: PUSH
43169: LD_INT 5
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 3
43179: PUSH
43180: LD_INT 0
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: LD_INT 3
43189: PUSH
43190: LD_INT 1
43192: NEG
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 4
43200: PUSH
43201: LD_INT 0
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 4
43210: PUSH
43211: LD_INT 1
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 3
43220: PUSH
43221: LD_INT 1
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 2
43230: PUSH
43231: LD_INT 0
43233: PUSH
43234: EMPTY
43235: LIST
43236: LIST
43237: PUSH
43238: LD_INT 2
43240: PUSH
43241: LD_INT 1
43243: NEG
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 2
43251: PUSH
43252: LD_INT 2
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 4
43262: PUSH
43263: LD_INT 2
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 4
43272: PUSH
43273: LD_INT 4
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 4
43282: PUSH
43283: LD_INT 3
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 5
43292: PUSH
43293: LD_INT 4
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 5
43302: PUSH
43303: LD_INT 5
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 4
43312: PUSH
43313: LD_INT 5
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 3
43322: PUSH
43323: LD_INT 4
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 3
43332: PUSH
43333: LD_INT 3
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 5
43342: PUSH
43343: LD_INT 3
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 3
43352: PUSH
43353: LD_INT 5
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: LIST
43378: LIST
43379: LIST
43380: LIST
43381: LIST
43382: LIST
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
43407: LD_ADDR_VAR 0 33
43411: PUSH
43412: LD_INT 4
43414: NEG
43415: PUSH
43416: LD_INT 4
43418: NEG
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 4
43426: NEG
43427: PUSH
43428: LD_INT 5
43430: NEG
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PUSH
43436: LD_INT 3
43438: NEG
43439: PUSH
43440: LD_INT 4
43442: NEG
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 3
43450: NEG
43451: PUSH
43452: LD_INT 3
43454: NEG
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 4
43462: NEG
43463: PUSH
43464: LD_INT 3
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 5
43474: NEG
43475: PUSH
43476: LD_INT 4
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 5
43486: NEG
43487: PUSH
43488: LD_INT 5
43490: NEG
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 3
43498: NEG
43499: PUSH
43500: LD_INT 5
43502: NEG
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: PUSH
43508: LD_INT 5
43510: NEG
43511: PUSH
43512: LD_INT 3
43514: NEG
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 3
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 0
43533: PUSH
43534: LD_INT 4
43536: NEG
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 1
43544: PUSH
43545: LD_INT 3
43547: NEG
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 1
43555: PUSH
43556: LD_INT 2
43558: NEG
43559: PUSH
43560: EMPTY
43561: LIST
43562: LIST
43563: PUSH
43564: LD_INT 0
43566: PUSH
43567: LD_INT 2
43569: NEG
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 1
43577: NEG
43578: PUSH
43579: LD_INT 3
43581: NEG
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 1
43589: NEG
43590: PUSH
43591: LD_INT 4
43593: NEG
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: LD_INT 2
43601: PUSH
43602: LD_INT 2
43604: NEG
43605: PUSH
43606: EMPTY
43607: LIST
43608: LIST
43609: PUSH
43610: LD_INT 2
43612: NEG
43613: PUSH
43614: LD_INT 4
43616: NEG
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 4
43624: PUSH
43625: LD_INT 0
43627: PUSH
43628: EMPTY
43629: LIST
43630: LIST
43631: PUSH
43632: LD_INT 4
43634: PUSH
43635: LD_INT 1
43637: NEG
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 5
43645: PUSH
43646: LD_INT 0
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 5
43655: PUSH
43656: LD_INT 1
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 4
43665: PUSH
43666: LD_INT 1
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 3
43675: PUSH
43676: LD_INT 0
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 3
43685: PUSH
43686: LD_INT 1
43688: NEG
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 3
43696: PUSH
43697: LD_INT 2
43699: NEG
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 5
43707: PUSH
43708: LD_INT 2
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 3
43717: PUSH
43718: LD_INT 3
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 3
43727: PUSH
43728: LD_INT 2
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 4
43737: PUSH
43738: LD_INT 3
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 4
43747: PUSH
43748: LD_INT 4
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 3
43757: PUSH
43758: LD_INT 4
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 2
43767: PUSH
43768: LD_INT 3
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 2
43777: PUSH
43778: LD_INT 2
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 4
43787: PUSH
43788: LD_INT 2
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 2
43797: PUSH
43798: LD_INT 4
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 0
43807: PUSH
43808: LD_INT 4
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 0
43817: PUSH
43818: LD_INT 3
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 1
43827: PUSH
43828: LD_INT 4
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 1
43837: PUSH
43838: LD_INT 5
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 0
43847: PUSH
43848: LD_INT 5
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 1
43857: NEG
43858: PUSH
43859: LD_INT 4
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 1
43868: NEG
43869: PUSH
43870: LD_INT 3
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 2
43879: PUSH
43880: LD_INT 5
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 2
43889: NEG
43890: PUSH
43891: LD_INT 3
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: LIST
43926: LIST
43927: LIST
43928: LIST
43929: LIST
43930: LIST
43931: LIST
43932: LIST
43933: LIST
43934: LIST
43935: LIST
43936: LIST
43937: LIST
43938: LIST
43939: LIST
43940: LIST
43941: LIST
43942: LIST
43943: LIST
43944: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
43945: LD_ADDR_VAR 0 34
43949: PUSH
43950: LD_INT 0
43952: PUSH
43953: LD_INT 4
43955: NEG
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 0
43963: PUSH
43964: LD_INT 5
43966: NEG
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: PUSH
43972: LD_INT 1
43974: PUSH
43975: LD_INT 4
43977: NEG
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 1
43985: PUSH
43986: LD_INT 3
43988: NEG
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: LD_INT 3
43999: NEG
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 1
44007: NEG
44008: PUSH
44009: LD_INT 4
44011: NEG
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PUSH
44017: LD_INT 1
44019: NEG
44020: PUSH
44021: LD_INT 5
44023: NEG
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 3
44034: NEG
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 2
44042: NEG
44043: PUSH
44044: LD_INT 5
44046: NEG
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 3
44054: PUSH
44055: LD_INT 0
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 3
44064: PUSH
44065: LD_INT 1
44067: NEG
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 4
44075: PUSH
44076: LD_INT 0
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: PUSH
44083: LD_INT 4
44085: PUSH
44086: LD_INT 1
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: PUSH
44093: LD_INT 3
44095: PUSH
44096: LD_INT 1
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 2
44105: PUSH
44106: LD_INT 0
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: PUSH
44113: LD_INT 2
44115: PUSH
44116: LD_INT 1
44118: NEG
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 2
44126: PUSH
44127: LD_INT 2
44129: NEG
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PUSH
44135: LD_INT 4
44137: PUSH
44138: LD_INT 2
44140: PUSH
44141: EMPTY
44142: LIST
44143: LIST
44144: PUSH
44145: LD_INT 4
44147: PUSH
44148: LD_INT 4
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 4
44157: PUSH
44158: LD_INT 3
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 5
44167: PUSH
44168: LD_INT 4
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 5
44177: PUSH
44178: LD_INT 5
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: PUSH
44185: LD_INT 4
44187: PUSH
44188: LD_INT 5
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: PUSH
44195: LD_INT 3
44197: PUSH
44198: LD_INT 4
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 3
44207: PUSH
44208: LD_INT 3
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 5
44217: PUSH
44218: LD_INT 3
44220: PUSH
44221: EMPTY
44222: LIST
44223: LIST
44224: PUSH
44225: LD_INT 3
44227: PUSH
44228: LD_INT 5
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: LD_INT 3
44240: PUSH
44241: EMPTY
44242: LIST
44243: LIST
44244: PUSH
44245: LD_INT 0
44247: PUSH
44248: LD_INT 2
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 1
44257: PUSH
44258: LD_INT 3
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 1
44267: PUSH
44268: LD_INT 4
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 0
44277: PUSH
44278: LD_INT 4
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PUSH
44285: LD_INT 1
44287: NEG
44288: PUSH
44289: LD_INT 3
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: NEG
44299: PUSH
44300: LD_INT 2
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 2
44309: PUSH
44310: LD_INT 4
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 2
44319: NEG
44320: PUSH
44321: LD_INT 2
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 4
44330: NEG
44331: PUSH
44332: LD_INT 0
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 4
44341: NEG
44342: PUSH
44343: LD_INT 1
44345: NEG
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: LD_INT 3
44353: NEG
44354: PUSH
44355: LD_INT 0
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 3
44364: NEG
44365: PUSH
44366: LD_INT 1
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 4
44375: NEG
44376: PUSH
44377: LD_INT 1
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 5
44386: NEG
44387: PUSH
44388: LD_INT 0
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 5
44397: NEG
44398: PUSH
44399: LD_INT 1
44401: NEG
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 5
44409: NEG
44410: PUSH
44411: LD_INT 2
44413: NEG
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 3
44421: NEG
44422: PUSH
44423: LD_INT 2
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: LIST
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: LIST
44450: LIST
44451: LIST
44452: LIST
44453: LIST
44454: LIST
44455: LIST
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: LIST
44475: LIST
44476: ST_TO_ADDR
// end ; end ;
44477: GO 44480
44479: POP
// case btype of b_depot , b_warehouse :
44480: LD_VAR 0 1
44484: PUSH
44485: LD_INT 0
44487: DOUBLE
44488: EQUAL
44489: IFTRUE 44499
44491: LD_INT 1
44493: DOUBLE
44494: EQUAL
44495: IFTRUE 44499
44497: GO 44700
44499: POP
// case nation of nation_american :
44500: LD_VAR 0 5
44504: PUSH
44505: LD_INT 1
44507: DOUBLE
44508: EQUAL
44509: IFTRUE 44513
44511: GO 44569
44513: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
44514: LD_ADDR_VAR 0 9
44518: PUSH
44519: LD_VAR 0 11
44523: PUSH
44524: LD_VAR 0 12
44528: PUSH
44529: LD_VAR 0 13
44533: PUSH
44534: LD_VAR 0 14
44538: PUSH
44539: LD_VAR 0 15
44543: PUSH
44544: LD_VAR 0 16
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: PUSH
44557: LD_VAR 0 4
44561: PUSH
44562: LD_INT 1
44564: PLUS
44565: ARRAY
44566: ST_TO_ADDR
44567: GO 44698
44569: LD_INT 2
44571: DOUBLE
44572: EQUAL
44573: IFTRUE 44577
44575: GO 44633
44577: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
44578: LD_ADDR_VAR 0 9
44582: PUSH
44583: LD_VAR 0 17
44587: PUSH
44588: LD_VAR 0 18
44592: PUSH
44593: LD_VAR 0 19
44597: PUSH
44598: LD_VAR 0 20
44602: PUSH
44603: LD_VAR 0 21
44607: PUSH
44608: LD_VAR 0 22
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: PUSH
44621: LD_VAR 0 4
44625: PUSH
44626: LD_INT 1
44628: PLUS
44629: ARRAY
44630: ST_TO_ADDR
44631: GO 44698
44633: LD_INT 3
44635: DOUBLE
44636: EQUAL
44637: IFTRUE 44641
44639: GO 44697
44641: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
44642: LD_ADDR_VAR 0 9
44646: PUSH
44647: LD_VAR 0 23
44651: PUSH
44652: LD_VAR 0 24
44656: PUSH
44657: LD_VAR 0 25
44661: PUSH
44662: LD_VAR 0 26
44666: PUSH
44667: LD_VAR 0 27
44671: PUSH
44672: LD_VAR 0 28
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: LIST
44684: PUSH
44685: LD_VAR 0 4
44689: PUSH
44690: LD_INT 1
44692: PLUS
44693: ARRAY
44694: ST_TO_ADDR
44695: GO 44698
44697: POP
44698: GO 45253
44700: LD_INT 2
44702: DOUBLE
44703: EQUAL
44704: IFTRUE 44714
44706: LD_INT 3
44708: DOUBLE
44709: EQUAL
44710: IFTRUE 44714
44712: GO 44770
44714: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
44715: LD_ADDR_VAR 0 9
44719: PUSH
44720: LD_VAR 0 29
44724: PUSH
44725: LD_VAR 0 30
44729: PUSH
44730: LD_VAR 0 31
44734: PUSH
44735: LD_VAR 0 32
44739: PUSH
44740: LD_VAR 0 33
44744: PUSH
44745: LD_VAR 0 34
44749: PUSH
44750: EMPTY
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: PUSH
44758: LD_VAR 0 4
44762: PUSH
44763: LD_INT 1
44765: PLUS
44766: ARRAY
44767: ST_TO_ADDR
44768: GO 45253
44770: LD_INT 16
44772: DOUBLE
44773: EQUAL
44774: IFTRUE 44832
44776: LD_INT 17
44778: DOUBLE
44779: EQUAL
44780: IFTRUE 44832
44782: LD_INT 18
44784: DOUBLE
44785: EQUAL
44786: IFTRUE 44832
44788: LD_INT 19
44790: DOUBLE
44791: EQUAL
44792: IFTRUE 44832
44794: LD_INT 22
44796: DOUBLE
44797: EQUAL
44798: IFTRUE 44832
44800: LD_INT 20
44802: DOUBLE
44803: EQUAL
44804: IFTRUE 44832
44806: LD_INT 21
44808: DOUBLE
44809: EQUAL
44810: IFTRUE 44832
44812: LD_INT 23
44814: DOUBLE
44815: EQUAL
44816: IFTRUE 44832
44818: LD_INT 24
44820: DOUBLE
44821: EQUAL
44822: IFTRUE 44832
44824: LD_INT 25
44826: DOUBLE
44827: EQUAL
44828: IFTRUE 44832
44830: GO 44888
44832: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
44833: LD_ADDR_VAR 0 9
44837: PUSH
44838: LD_VAR 0 35
44842: PUSH
44843: LD_VAR 0 36
44847: PUSH
44848: LD_VAR 0 37
44852: PUSH
44853: LD_VAR 0 38
44857: PUSH
44858: LD_VAR 0 39
44862: PUSH
44863: LD_VAR 0 40
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: LIST
44872: LIST
44873: LIST
44874: LIST
44875: PUSH
44876: LD_VAR 0 4
44880: PUSH
44881: LD_INT 1
44883: PLUS
44884: ARRAY
44885: ST_TO_ADDR
44886: GO 45253
44888: LD_INT 6
44890: DOUBLE
44891: EQUAL
44892: IFTRUE 44944
44894: LD_INT 7
44896: DOUBLE
44897: EQUAL
44898: IFTRUE 44944
44900: LD_INT 8
44902: DOUBLE
44903: EQUAL
44904: IFTRUE 44944
44906: LD_INT 13
44908: DOUBLE
44909: EQUAL
44910: IFTRUE 44944
44912: LD_INT 12
44914: DOUBLE
44915: EQUAL
44916: IFTRUE 44944
44918: LD_INT 15
44920: DOUBLE
44921: EQUAL
44922: IFTRUE 44944
44924: LD_INT 11
44926: DOUBLE
44927: EQUAL
44928: IFTRUE 44944
44930: LD_INT 14
44932: DOUBLE
44933: EQUAL
44934: IFTRUE 44944
44936: LD_INT 10
44938: DOUBLE
44939: EQUAL
44940: IFTRUE 44944
44942: GO 45000
44944: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
44945: LD_ADDR_VAR 0 9
44949: PUSH
44950: LD_VAR 0 41
44954: PUSH
44955: LD_VAR 0 42
44959: PUSH
44960: LD_VAR 0 43
44964: PUSH
44965: LD_VAR 0 44
44969: PUSH
44970: LD_VAR 0 45
44974: PUSH
44975: LD_VAR 0 46
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: PUSH
44988: LD_VAR 0 4
44992: PUSH
44993: LD_INT 1
44995: PLUS
44996: ARRAY
44997: ST_TO_ADDR
44998: GO 45253
45000: LD_INT 36
45002: DOUBLE
45003: EQUAL
45004: IFTRUE 45008
45006: GO 45064
45008: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45009: LD_ADDR_VAR 0 9
45013: PUSH
45014: LD_VAR 0 47
45018: PUSH
45019: LD_VAR 0 48
45023: PUSH
45024: LD_VAR 0 49
45028: PUSH
45029: LD_VAR 0 50
45033: PUSH
45034: LD_VAR 0 51
45038: PUSH
45039: LD_VAR 0 52
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: PUSH
45052: LD_VAR 0 4
45056: PUSH
45057: LD_INT 1
45059: PLUS
45060: ARRAY
45061: ST_TO_ADDR
45062: GO 45253
45064: LD_INT 4
45066: DOUBLE
45067: EQUAL
45068: IFTRUE 45090
45070: LD_INT 5
45072: DOUBLE
45073: EQUAL
45074: IFTRUE 45090
45076: LD_INT 34
45078: DOUBLE
45079: EQUAL
45080: IFTRUE 45090
45082: LD_INT 37
45084: DOUBLE
45085: EQUAL
45086: IFTRUE 45090
45088: GO 45146
45090: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45091: LD_ADDR_VAR 0 9
45095: PUSH
45096: LD_VAR 0 53
45100: PUSH
45101: LD_VAR 0 54
45105: PUSH
45106: LD_VAR 0 55
45110: PUSH
45111: LD_VAR 0 56
45115: PUSH
45116: LD_VAR 0 57
45120: PUSH
45121: LD_VAR 0 58
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: PUSH
45134: LD_VAR 0 4
45138: PUSH
45139: LD_INT 1
45141: PLUS
45142: ARRAY
45143: ST_TO_ADDR
45144: GO 45253
45146: LD_INT 31
45148: DOUBLE
45149: EQUAL
45150: IFTRUE 45196
45152: LD_INT 32
45154: DOUBLE
45155: EQUAL
45156: IFTRUE 45196
45158: LD_INT 33
45160: DOUBLE
45161: EQUAL
45162: IFTRUE 45196
45164: LD_INT 27
45166: DOUBLE
45167: EQUAL
45168: IFTRUE 45196
45170: LD_INT 26
45172: DOUBLE
45173: EQUAL
45174: IFTRUE 45196
45176: LD_INT 28
45178: DOUBLE
45179: EQUAL
45180: IFTRUE 45196
45182: LD_INT 29
45184: DOUBLE
45185: EQUAL
45186: IFTRUE 45196
45188: LD_INT 30
45190: DOUBLE
45191: EQUAL
45192: IFTRUE 45196
45194: GO 45252
45196: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45197: LD_ADDR_VAR 0 9
45201: PUSH
45202: LD_VAR 0 59
45206: PUSH
45207: LD_VAR 0 60
45211: PUSH
45212: LD_VAR 0 61
45216: PUSH
45217: LD_VAR 0 62
45221: PUSH
45222: LD_VAR 0 63
45226: PUSH
45227: LD_VAR 0 64
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: LIST
45236: LIST
45237: LIST
45238: LIST
45239: PUSH
45240: LD_VAR 0 4
45244: PUSH
45245: LD_INT 1
45247: PLUS
45248: ARRAY
45249: ST_TO_ADDR
45250: GO 45253
45252: POP
// temp_list2 = [ ] ;
45253: LD_ADDR_VAR 0 10
45257: PUSH
45258: EMPTY
45259: ST_TO_ADDR
// for i in temp_list do
45260: LD_ADDR_VAR 0 8
45264: PUSH
45265: LD_VAR 0 9
45269: PUSH
45270: FOR_IN
45271: IFFALSE 45323
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45273: LD_ADDR_VAR 0 10
45277: PUSH
45278: LD_VAR 0 10
45282: PUSH
45283: LD_VAR 0 8
45287: PUSH
45288: LD_INT 1
45290: ARRAY
45291: PUSH
45292: LD_VAR 0 2
45296: PLUS
45297: PUSH
45298: LD_VAR 0 8
45302: PUSH
45303: LD_INT 2
45305: ARRAY
45306: PUSH
45307: LD_VAR 0 3
45311: PLUS
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: EMPTY
45318: LIST
45319: ADD
45320: ST_TO_ADDR
45321: GO 45270
45323: POP
45324: POP
// result = temp_list2 ;
45325: LD_ADDR_VAR 0 7
45329: PUSH
45330: LD_VAR 0 10
45334: ST_TO_ADDR
// end ;
45335: LD_VAR 0 7
45339: RET
// export function EnemyInRange ( unit , dist ) ; begin
45340: LD_INT 0
45342: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
45343: LD_ADDR_VAR 0 3
45347: PUSH
45348: LD_VAR 0 1
45352: PPUSH
45353: CALL_OW 255
45357: PPUSH
45358: LD_VAR 0 1
45362: PPUSH
45363: CALL_OW 250
45367: PPUSH
45368: LD_VAR 0 1
45372: PPUSH
45373: CALL_OW 251
45377: PPUSH
45378: LD_VAR 0 2
45382: PPUSH
45383: CALL 19444 0 4
45387: PUSH
45388: LD_INT 4
45390: ARRAY
45391: ST_TO_ADDR
// end ;
45392: LD_VAR 0 3
45396: RET
// export function PlayerSeeMe ( unit ) ; begin
45397: LD_INT 0
45399: PPUSH
// result := See ( your_side , unit ) ;
45400: LD_ADDR_VAR 0 2
45404: PUSH
45405: LD_OWVAR 2
45409: PPUSH
45410: LD_VAR 0 1
45414: PPUSH
45415: CALL_OW 292
45419: ST_TO_ADDR
// end ;
45420: LD_VAR 0 2
45424: RET
// export function ReverseDir ( unit ) ; begin
45425: LD_INT 0
45427: PPUSH
// if not unit then
45428: LD_VAR 0 1
45432: NOT
45433: IFFALSE 45437
// exit ;
45435: GO 45460
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
45437: LD_ADDR_VAR 0 2
45441: PUSH
45442: LD_VAR 0 1
45446: PPUSH
45447: CALL_OW 254
45451: PUSH
45452: LD_INT 3
45454: PLUS
45455: PUSH
45456: LD_INT 6
45458: MOD
45459: ST_TO_ADDR
// end ;
45460: LD_VAR 0 2
45464: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
45465: LD_INT 0
45467: PPUSH
45468: PPUSH
45469: PPUSH
45470: PPUSH
45471: PPUSH
// if not hexes then
45472: LD_VAR 0 2
45476: NOT
45477: IFFALSE 45481
// exit ;
45479: GO 45629
// dist := 9999 ;
45481: LD_ADDR_VAR 0 5
45485: PUSH
45486: LD_INT 9999
45488: ST_TO_ADDR
// for i = 1 to hexes do
45489: LD_ADDR_VAR 0 4
45493: PUSH
45494: DOUBLE
45495: LD_INT 1
45497: DEC
45498: ST_TO_ADDR
45499: LD_VAR 0 2
45503: PUSH
45504: FOR_TO
45505: IFFALSE 45617
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
45507: LD_VAR 0 1
45511: PPUSH
45512: LD_VAR 0 2
45516: PUSH
45517: LD_VAR 0 4
45521: ARRAY
45522: PUSH
45523: LD_INT 1
45525: ARRAY
45526: PPUSH
45527: LD_VAR 0 2
45531: PUSH
45532: LD_VAR 0 4
45536: ARRAY
45537: PUSH
45538: LD_INT 2
45540: ARRAY
45541: PPUSH
45542: CALL_OW 297
45546: PUSH
45547: LD_VAR 0 5
45551: LESS
45552: IFFALSE 45615
// begin hex := hexes [ i ] ;
45554: LD_ADDR_VAR 0 7
45558: PUSH
45559: LD_VAR 0 2
45563: PUSH
45564: LD_VAR 0 4
45568: ARRAY
45569: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45570: LD_ADDR_VAR 0 5
45574: PUSH
45575: LD_VAR 0 1
45579: PPUSH
45580: LD_VAR 0 2
45584: PUSH
45585: LD_VAR 0 4
45589: ARRAY
45590: PUSH
45591: LD_INT 1
45593: ARRAY
45594: PPUSH
45595: LD_VAR 0 2
45599: PUSH
45600: LD_VAR 0 4
45604: ARRAY
45605: PUSH
45606: LD_INT 2
45608: ARRAY
45609: PPUSH
45610: CALL_OW 297
45614: ST_TO_ADDR
// end ; end ;
45615: GO 45504
45617: POP
45618: POP
// result := hex ;
45619: LD_ADDR_VAR 0 3
45623: PUSH
45624: LD_VAR 0 7
45628: ST_TO_ADDR
// end ;
45629: LD_VAR 0 3
45633: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
45634: LD_INT 0
45636: PPUSH
45637: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
45638: LD_VAR 0 1
45642: NOT
45643: PUSH
45644: LD_VAR 0 1
45648: PUSH
45649: LD_INT 21
45651: PUSH
45652: LD_INT 2
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 23
45661: PUSH
45662: LD_INT 2
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: EMPTY
45670: LIST
45671: LIST
45672: PPUSH
45673: CALL_OW 69
45677: IN
45678: NOT
45679: OR
45680: IFFALSE 45684
// exit ;
45682: GO 45731
// for i = 1 to 3 do
45684: LD_ADDR_VAR 0 3
45688: PUSH
45689: DOUBLE
45690: LD_INT 1
45692: DEC
45693: ST_TO_ADDR
45694: LD_INT 3
45696: PUSH
45697: FOR_TO
45698: IFFALSE 45729
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
45700: LD_VAR 0 1
45704: PPUSH
45705: CALL_OW 250
45709: PPUSH
45710: LD_VAR 0 1
45714: PPUSH
45715: CALL_OW 251
45719: PPUSH
45720: LD_INT 1
45722: PPUSH
45723: CALL_OW 453
45727: GO 45697
45729: POP
45730: POP
// end ;
45731: LD_VAR 0 2
45735: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
45736: LD_INT 0
45738: PPUSH
45739: PPUSH
45740: PPUSH
45741: PPUSH
45742: PPUSH
45743: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
45744: LD_VAR 0 1
45748: NOT
45749: PUSH
45750: LD_VAR 0 2
45754: NOT
45755: OR
45756: PUSH
45757: LD_VAR 0 1
45761: PPUSH
45762: CALL_OW 314
45766: OR
45767: IFFALSE 45771
// exit ;
45769: GO 46212
// x := GetX ( enemy_unit ) ;
45771: LD_ADDR_VAR 0 7
45775: PUSH
45776: LD_VAR 0 2
45780: PPUSH
45781: CALL_OW 250
45785: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
45786: LD_ADDR_VAR 0 8
45790: PUSH
45791: LD_VAR 0 2
45795: PPUSH
45796: CALL_OW 251
45800: ST_TO_ADDR
// if not x or not y then
45801: LD_VAR 0 7
45805: NOT
45806: PUSH
45807: LD_VAR 0 8
45811: NOT
45812: OR
45813: IFFALSE 45817
// exit ;
45815: GO 46212
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
45817: LD_ADDR_VAR 0 6
45821: PUSH
45822: LD_VAR 0 7
45826: PPUSH
45827: LD_INT 0
45829: PPUSH
45830: LD_INT 4
45832: PPUSH
45833: CALL_OW 272
45837: PUSH
45838: LD_VAR 0 8
45842: PPUSH
45843: LD_INT 0
45845: PPUSH
45846: LD_INT 4
45848: PPUSH
45849: CALL_OW 273
45853: PUSH
45854: EMPTY
45855: LIST
45856: LIST
45857: PUSH
45858: LD_VAR 0 7
45862: PPUSH
45863: LD_INT 1
45865: PPUSH
45866: LD_INT 4
45868: PPUSH
45869: CALL_OW 272
45873: PUSH
45874: LD_VAR 0 8
45878: PPUSH
45879: LD_INT 1
45881: PPUSH
45882: LD_INT 4
45884: PPUSH
45885: CALL_OW 273
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_VAR 0 7
45898: PPUSH
45899: LD_INT 2
45901: PPUSH
45902: LD_INT 4
45904: PPUSH
45905: CALL_OW 272
45909: PUSH
45910: LD_VAR 0 8
45914: PPUSH
45915: LD_INT 2
45917: PPUSH
45918: LD_INT 4
45920: PPUSH
45921: CALL_OW 273
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: LD_VAR 0 7
45934: PPUSH
45935: LD_INT 3
45937: PPUSH
45938: LD_INT 4
45940: PPUSH
45941: CALL_OW 272
45945: PUSH
45946: LD_VAR 0 8
45950: PPUSH
45951: LD_INT 3
45953: PPUSH
45954: LD_INT 4
45956: PPUSH
45957: CALL_OW 273
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_VAR 0 7
45970: PPUSH
45971: LD_INT 4
45973: PPUSH
45974: LD_INT 4
45976: PPUSH
45977: CALL_OW 272
45981: PUSH
45982: LD_VAR 0 8
45986: PPUSH
45987: LD_INT 4
45989: PPUSH
45990: LD_INT 4
45992: PPUSH
45993: CALL_OW 273
45997: PUSH
45998: EMPTY
45999: LIST
46000: LIST
46001: PUSH
46002: LD_VAR 0 7
46006: PPUSH
46007: LD_INT 5
46009: PPUSH
46010: LD_INT 4
46012: PPUSH
46013: CALL_OW 272
46017: PUSH
46018: LD_VAR 0 8
46022: PPUSH
46023: LD_INT 5
46025: PPUSH
46026: LD_INT 4
46028: PPUSH
46029: CALL_OW 273
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: ST_TO_ADDR
// for i = tmp downto 1 do
46046: LD_ADDR_VAR 0 4
46050: PUSH
46051: DOUBLE
46052: LD_VAR 0 6
46056: INC
46057: ST_TO_ADDR
46058: LD_INT 1
46060: PUSH
46061: FOR_DOWNTO
46062: IFFALSE 46163
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46064: LD_VAR 0 6
46068: PUSH
46069: LD_VAR 0 4
46073: ARRAY
46074: PUSH
46075: LD_INT 1
46077: ARRAY
46078: PPUSH
46079: LD_VAR 0 6
46083: PUSH
46084: LD_VAR 0 4
46088: ARRAY
46089: PUSH
46090: LD_INT 2
46092: ARRAY
46093: PPUSH
46094: CALL_OW 488
46098: NOT
46099: PUSH
46100: LD_VAR 0 6
46104: PUSH
46105: LD_VAR 0 4
46109: ARRAY
46110: PUSH
46111: LD_INT 1
46113: ARRAY
46114: PPUSH
46115: LD_VAR 0 6
46119: PUSH
46120: LD_VAR 0 4
46124: ARRAY
46125: PUSH
46126: LD_INT 2
46128: ARRAY
46129: PPUSH
46130: CALL_OW 428
46134: PUSH
46135: LD_INT 0
46137: NONEQUAL
46138: OR
46139: IFFALSE 46161
// tmp := Delete ( tmp , i ) ;
46141: LD_ADDR_VAR 0 6
46145: PUSH
46146: LD_VAR 0 6
46150: PPUSH
46151: LD_VAR 0 4
46155: PPUSH
46156: CALL_OW 3
46160: ST_TO_ADDR
46161: GO 46061
46163: POP
46164: POP
// j := GetClosestHex ( unit , tmp ) ;
46165: LD_ADDR_VAR 0 5
46169: PUSH
46170: LD_VAR 0 1
46174: PPUSH
46175: LD_VAR 0 6
46179: PPUSH
46180: CALL 45465 0 2
46184: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46185: LD_VAR 0 1
46189: PPUSH
46190: LD_VAR 0 5
46194: PUSH
46195: LD_INT 1
46197: ARRAY
46198: PPUSH
46199: LD_VAR 0 5
46203: PUSH
46204: LD_INT 2
46206: ARRAY
46207: PPUSH
46208: CALL_OW 111
// end ;
46212: LD_VAR 0 3
46216: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46217: LD_INT 0
46219: PPUSH
46220: PPUSH
46221: PPUSH
// uc_side = 0 ;
46222: LD_ADDR_OWVAR 20
46226: PUSH
46227: LD_INT 0
46229: ST_TO_ADDR
// uc_nation = 0 ;
46230: LD_ADDR_OWVAR 21
46234: PUSH
46235: LD_INT 0
46237: ST_TO_ADDR
// InitHc_All ( ) ;
46238: CALL_OW 584
// InitVc ;
46242: CALL_OW 20
// if mastodonts then
46246: LD_VAR 0 6
46250: IFFALSE 46317
// for i = 1 to mastodonts do
46252: LD_ADDR_VAR 0 11
46256: PUSH
46257: DOUBLE
46258: LD_INT 1
46260: DEC
46261: ST_TO_ADDR
46262: LD_VAR 0 6
46266: PUSH
46267: FOR_TO
46268: IFFALSE 46315
// begin vc_chassis := 31 ;
46270: LD_ADDR_OWVAR 37
46274: PUSH
46275: LD_INT 31
46277: ST_TO_ADDR
// vc_control := control_rider ;
46278: LD_ADDR_OWVAR 38
46282: PUSH
46283: LD_INT 4
46285: ST_TO_ADDR
// animal := CreateVehicle ;
46286: LD_ADDR_VAR 0 12
46290: PUSH
46291: CALL_OW 45
46295: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46296: LD_VAR 0 12
46300: PPUSH
46301: LD_VAR 0 8
46305: PPUSH
46306: LD_INT 0
46308: PPUSH
46309: CALL 48505 0 3
// end ;
46313: GO 46267
46315: POP
46316: POP
// if horses then
46317: LD_VAR 0 5
46321: IFFALSE 46388
// for i = 1 to horses do
46323: LD_ADDR_VAR 0 11
46327: PUSH
46328: DOUBLE
46329: LD_INT 1
46331: DEC
46332: ST_TO_ADDR
46333: LD_VAR 0 5
46337: PUSH
46338: FOR_TO
46339: IFFALSE 46386
// begin hc_class := 21 ;
46341: LD_ADDR_OWVAR 28
46345: PUSH
46346: LD_INT 21
46348: ST_TO_ADDR
// hc_gallery :=  ;
46349: LD_ADDR_OWVAR 33
46353: PUSH
46354: LD_STRING 
46356: ST_TO_ADDR
// animal := CreateHuman ;
46357: LD_ADDR_VAR 0 12
46361: PUSH
46362: CALL_OW 44
46366: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46367: LD_VAR 0 12
46371: PPUSH
46372: LD_VAR 0 8
46376: PPUSH
46377: LD_INT 0
46379: PPUSH
46380: CALL 48505 0 3
// end ;
46384: GO 46338
46386: POP
46387: POP
// if birds then
46388: LD_VAR 0 1
46392: IFFALSE 46459
// for i = 1 to birds do
46394: LD_ADDR_VAR 0 11
46398: PUSH
46399: DOUBLE
46400: LD_INT 1
46402: DEC
46403: ST_TO_ADDR
46404: LD_VAR 0 1
46408: PUSH
46409: FOR_TO
46410: IFFALSE 46457
// begin hc_class = 18 ;
46412: LD_ADDR_OWVAR 28
46416: PUSH
46417: LD_INT 18
46419: ST_TO_ADDR
// hc_gallery =  ;
46420: LD_ADDR_OWVAR 33
46424: PUSH
46425: LD_STRING 
46427: ST_TO_ADDR
// animal := CreateHuman ;
46428: LD_ADDR_VAR 0 12
46432: PUSH
46433: CALL_OW 44
46437: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46438: LD_VAR 0 12
46442: PPUSH
46443: LD_VAR 0 8
46447: PPUSH
46448: LD_INT 0
46450: PPUSH
46451: CALL 48505 0 3
// end ;
46455: GO 46409
46457: POP
46458: POP
// if tigers then
46459: LD_VAR 0 2
46463: IFFALSE 46547
// for i = 1 to tigers do
46465: LD_ADDR_VAR 0 11
46469: PUSH
46470: DOUBLE
46471: LD_INT 1
46473: DEC
46474: ST_TO_ADDR
46475: LD_VAR 0 2
46479: PUSH
46480: FOR_TO
46481: IFFALSE 46545
// begin hc_class = class_tiger ;
46483: LD_ADDR_OWVAR 28
46487: PUSH
46488: LD_INT 14
46490: ST_TO_ADDR
// hc_gallery =  ;
46491: LD_ADDR_OWVAR 33
46495: PUSH
46496: LD_STRING 
46498: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46499: LD_ADDR_OWVAR 35
46503: PUSH
46504: LD_INT 7
46506: NEG
46507: PPUSH
46508: LD_INT 7
46510: PPUSH
46511: CALL_OW 12
46515: ST_TO_ADDR
// animal := CreateHuman ;
46516: LD_ADDR_VAR 0 12
46520: PUSH
46521: CALL_OW 44
46525: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46526: LD_VAR 0 12
46530: PPUSH
46531: LD_VAR 0 8
46535: PPUSH
46536: LD_INT 0
46538: PPUSH
46539: CALL 48505 0 3
// end ;
46543: GO 46480
46545: POP
46546: POP
// if apemans then
46547: LD_VAR 0 3
46551: IFFALSE 46674
// for i = 1 to apemans do
46553: LD_ADDR_VAR 0 11
46557: PUSH
46558: DOUBLE
46559: LD_INT 1
46561: DEC
46562: ST_TO_ADDR
46563: LD_VAR 0 3
46567: PUSH
46568: FOR_TO
46569: IFFALSE 46672
// begin hc_class = class_apeman ;
46571: LD_ADDR_OWVAR 28
46575: PUSH
46576: LD_INT 12
46578: ST_TO_ADDR
// hc_gallery =  ;
46579: LD_ADDR_OWVAR 33
46583: PUSH
46584: LD_STRING 
46586: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
46587: LD_ADDR_OWVAR 35
46591: PUSH
46592: LD_INT 5
46594: NEG
46595: PPUSH
46596: LD_INT 5
46598: PPUSH
46599: CALL_OW 12
46603: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46604: LD_ADDR_OWVAR 31
46608: PUSH
46609: LD_INT 1
46611: PPUSH
46612: LD_INT 3
46614: PPUSH
46615: CALL_OW 12
46619: PUSH
46620: LD_INT 1
46622: PPUSH
46623: LD_INT 3
46625: PPUSH
46626: CALL_OW 12
46630: PUSH
46631: LD_INT 0
46633: PUSH
46634: LD_INT 0
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: ST_TO_ADDR
// animal := CreateHuman ;
46643: LD_ADDR_VAR 0 12
46647: PUSH
46648: CALL_OW 44
46652: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46653: LD_VAR 0 12
46657: PPUSH
46658: LD_VAR 0 8
46662: PPUSH
46663: LD_INT 0
46665: PPUSH
46666: CALL 48505 0 3
// end ;
46670: GO 46568
46672: POP
46673: POP
// if enchidnas then
46674: LD_VAR 0 4
46678: IFFALSE 46745
// for i = 1 to enchidnas do
46680: LD_ADDR_VAR 0 11
46684: PUSH
46685: DOUBLE
46686: LD_INT 1
46688: DEC
46689: ST_TO_ADDR
46690: LD_VAR 0 4
46694: PUSH
46695: FOR_TO
46696: IFFALSE 46743
// begin hc_class = 13 ;
46698: LD_ADDR_OWVAR 28
46702: PUSH
46703: LD_INT 13
46705: ST_TO_ADDR
// hc_gallery =  ;
46706: LD_ADDR_OWVAR 33
46710: PUSH
46711: LD_STRING 
46713: ST_TO_ADDR
// animal := CreateHuman ;
46714: LD_ADDR_VAR 0 12
46718: PUSH
46719: CALL_OW 44
46723: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46724: LD_VAR 0 12
46728: PPUSH
46729: LD_VAR 0 8
46733: PPUSH
46734: LD_INT 0
46736: PPUSH
46737: CALL 48505 0 3
// end ;
46741: GO 46695
46743: POP
46744: POP
// if fishes then
46745: LD_VAR 0 7
46749: IFFALSE 46816
// for i = 1 to fishes do
46751: LD_ADDR_VAR 0 11
46755: PUSH
46756: DOUBLE
46757: LD_INT 1
46759: DEC
46760: ST_TO_ADDR
46761: LD_VAR 0 7
46765: PUSH
46766: FOR_TO
46767: IFFALSE 46814
// begin hc_class = 20 ;
46769: LD_ADDR_OWVAR 28
46773: PUSH
46774: LD_INT 20
46776: ST_TO_ADDR
// hc_gallery =  ;
46777: LD_ADDR_OWVAR 33
46781: PUSH
46782: LD_STRING 
46784: ST_TO_ADDR
// animal := CreateHuman ;
46785: LD_ADDR_VAR 0 12
46789: PUSH
46790: CALL_OW 44
46794: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46795: LD_VAR 0 12
46799: PPUSH
46800: LD_VAR 0 9
46804: PPUSH
46805: LD_INT 0
46807: PPUSH
46808: CALL 48505 0 3
// end ;
46812: GO 46766
46814: POP
46815: POP
// end ;
46816: LD_VAR 0 10
46820: RET
// export function WantHeal ( sci , unit ) ; begin
46821: LD_INT 0
46823: PPUSH
// if GetTaskList ( sci ) > 0 then
46824: LD_VAR 0 1
46828: PPUSH
46829: CALL_OW 437
46833: PUSH
46834: LD_INT 0
46836: GREATER
46837: IFFALSE 46907
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46839: LD_VAR 0 1
46843: PPUSH
46844: CALL_OW 437
46848: PUSH
46849: LD_INT 1
46851: ARRAY
46852: PUSH
46853: LD_INT 1
46855: ARRAY
46856: PUSH
46857: LD_STRING l
46859: EQUAL
46860: PUSH
46861: LD_VAR 0 1
46865: PPUSH
46866: CALL_OW 437
46870: PUSH
46871: LD_INT 1
46873: ARRAY
46874: PUSH
46875: LD_INT 4
46877: ARRAY
46878: PUSH
46879: LD_VAR 0 2
46883: EQUAL
46884: AND
46885: IFFALSE 46897
// result := true else
46887: LD_ADDR_VAR 0 3
46891: PUSH
46892: LD_INT 1
46894: ST_TO_ADDR
46895: GO 46905
// result := false ;
46897: LD_ADDR_VAR 0 3
46901: PUSH
46902: LD_INT 0
46904: ST_TO_ADDR
// end else
46905: GO 46915
// result := false ;
46907: LD_ADDR_VAR 0 3
46911: PUSH
46912: LD_INT 0
46914: ST_TO_ADDR
// end ;
46915: LD_VAR 0 3
46919: RET
// export function HealTarget ( sci ) ; begin
46920: LD_INT 0
46922: PPUSH
// if not sci then
46923: LD_VAR 0 1
46927: NOT
46928: IFFALSE 46932
// exit ;
46930: GO 46997
// result := 0 ;
46932: LD_ADDR_VAR 0 2
46936: PUSH
46937: LD_INT 0
46939: ST_TO_ADDR
// if GetTaskList ( sci ) then
46940: LD_VAR 0 1
46944: PPUSH
46945: CALL_OW 437
46949: IFFALSE 46997
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46951: LD_VAR 0 1
46955: PPUSH
46956: CALL_OW 437
46960: PUSH
46961: LD_INT 1
46963: ARRAY
46964: PUSH
46965: LD_INT 1
46967: ARRAY
46968: PUSH
46969: LD_STRING l
46971: EQUAL
46972: IFFALSE 46997
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46974: LD_ADDR_VAR 0 2
46978: PUSH
46979: LD_VAR 0 1
46983: PPUSH
46984: CALL_OW 437
46988: PUSH
46989: LD_INT 1
46991: ARRAY
46992: PUSH
46993: LD_INT 4
46995: ARRAY
46996: ST_TO_ADDR
// end ;
46997: LD_VAR 0 2
47001: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47002: LD_INT 0
47004: PPUSH
47005: PPUSH
47006: PPUSH
47007: PPUSH
// if not base_units then
47008: LD_VAR 0 1
47012: NOT
47013: IFFALSE 47017
// exit ;
47015: GO 47104
// result := false ;
47017: LD_ADDR_VAR 0 2
47021: PUSH
47022: LD_INT 0
47024: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47025: LD_ADDR_VAR 0 5
47029: PUSH
47030: LD_VAR 0 1
47034: PPUSH
47035: LD_INT 21
47037: PUSH
47038: LD_INT 3
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PPUSH
47045: CALL_OW 72
47049: ST_TO_ADDR
// if not tmp then
47050: LD_VAR 0 5
47054: NOT
47055: IFFALSE 47059
// exit ;
47057: GO 47104
// for i in tmp do
47059: LD_ADDR_VAR 0 3
47063: PUSH
47064: LD_VAR 0 5
47068: PUSH
47069: FOR_IN
47070: IFFALSE 47102
// begin result := EnemyInRange ( i , 22 ) ;
47072: LD_ADDR_VAR 0 2
47076: PUSH
47077: LD_VAR 0 3
47081: PPUSH
47082: LD_INT 22
47084: PPUSH
47085: CALL 45340 0 2
47089: ST_TO_ADDR
// if result then
47090: LD_VAR 0 2
47094: IFFALSE 47100
// exit ;
47096: POP
47097: POP
47098: GO 47104
// end ;
47100: GO 47069
47102: POP
47103: POP
// end ;
47104: LD_VAR 0 2
47108: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47109: LD_INT 0
47111: PPUSH
47112: PPUSH
// if not units then
47113: LD_VAR 0 1
47117: NOT
47118: IFFALSE 47122
// exit ;
47120: GO 47192
// result := [ ] ;
47122: LD_ADDR_VAR 0 3
47126: PUSH
47127: EMPTY
47128: ST_TO_ADDR
// for i in units do
47129: LD_ADDR_VAR 0 4
47133: PUSH
47134: LD_VAR 0 1
47138: PUSH
47139: FOR_IN
47140: IFFALSE 47190
// if GetTag ( i ) = tag then
47142: LD_VAR 0 4
47146: PPUSH
47147: CALL_OW 110
47151: PUSH
47152: LD_VAR 0 2
47156: EQUAL
47157: IFFALSE 47188
// result := Insert ( result , result + 1 , i ) ;
47159: LD_ADDR_VAR 0 3
47163: PUSH
47164: LD_VAR 0 3
47168: PPUSH
47169: LD_VAR 0 3
47173: PUSH
47174: LD_INT 1
47176: PLUS
47177: PPUSH
47178: LD_VAR 0 4
47182: PPUSH
47183: CALL_OW 2
47187: ST_TO_ADDR
47188: GO 47139
47190: POP
47191: POP
// end ;
47192: LD_VAR 0 3
47196: RET
// export function IsDriver ( un ) ; begin
47197: LD_INT 0
47199: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47200: LD_ADDR_VAR 0 2
47204: PUSH
47205: LD_VAR 0 1
47209: PUSH
47210: LD_INT 55
47212: PUSH
47213: EMPTY
47214: LIST
47215: PPUSH
47216: CALL_OW 69
47220: IN
47221: ST_TO_ADDR
// end ;
47222: LD_VAR 0 2
47226: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47227: LD_INT 0
47229: PPUSH
47230: PPUSH
// list := [ ] ;
47231: LD_ADDR_VAR 0 5
47235: PUSH
47236: EMPTY
47237: ST_TO_ADDR
// case d of 0 :
47238: LD_VAR 0 3
47242: PUSH
47243: LD_INT 0
47245: DOUBLE
47246: EQUAL
47247: IFTRUE 47251
47249: GO 47384
47251: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47252: LD_ADDR_VAR 0 5
47256: PUSH
47257: LD_VAR 0 1
47261: PUSH
47262: LD_INT 4
47264: MINUS
47265: PUSH
47266: LD_VAR 0 2
47270: PUSH
47271: LD_INT 4
47273: MINUS
47274: PUSH
47275: LD_INT 2
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: LIST
47282: PUSH
47283: LD_VAR 0 1
47287: PUSH
47288: LD_INT 3
47290: MINUS
47291: PUSH
47292: LD_VAR 0 2
47296: PUSH
47297: LD_INT 1
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: LIST
47304: PUSH
47305: LD_VAR 0 1
47309: PUSH
47310: LD_INT 4
47312: PLUS
47313: PUSH
47314: LD_VAR 0 2
47318: PUSH
47319: LD_INT 4
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: LIST
47326: PUSH
47327: LD_VAR 0 1
47331: PUSH
47332: LD_INT 3
47334: PLUS
47335: PUSH
47336: LD_VAR 0 2
47340: PUSH
47341: LD_INT 3
47343: PLUS
47344: PUSH
47345: LD_INT 5
47347: PUSH
47348: EMPTY
47349: LIST
47350: LIST
47351: LIST
47352: PUSH
47353: LD_VAR 0 1
47357: PUSH
47358: LD_VAR 0 2
47362: PUSH
47363: LD_INT 4
47365: PLUS
47366: PUSH
47367: LD_INT 0
47369: PUSH
47370: EMPTY
47371: LIST
47372: LIST
47373: LIST
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: ST_TO_ADDR
// end ; 1 :
47382: GO 48082
47384: LD_INT 1
47386: DOUBLE
47387: EQUAL
47388: IFTRUE 47392
47390: GO 47525
47392: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
47393: LD_ADDR_VAR 0 5
47397: PUSH
47398: LD_VAR 0 1
47402: PUSH
47403: LD_VAR 0 2
47407: PUSH
47408: LD_INT 4
47410: MINUS
47411: PUSH
47412: LD_INT 3
47414: PUSH
47415: EMPTY
47416: LIST
47417: LIST
47418: LIST
47419: PUSH
47420: LD_VAR 0 1
47424: PUSH
47425: LD_INT 3
47427: MINUS
47428: PUSH
47429: LD_VAR 0 2
47433: PUSH
47434: LD_INT 3
47436: MINUS
47437: PUSH
47438: LD_INT 2
47440: PUSH
47441: EMPTY
47442: LIST
47443: LIST
47444: LIST
47445: PUSH
47446: LD_VAR 0 1
47450: PUSH
47451: LD_INT 4
47453: MINUS
47454: PUSH
47455: LD_VAR 0 2
47459: PUSH
47460: LD_INT 1
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: LIST
47467: PUSH
47468: LD_VAR 0 1
47472: PUSH
47473: LD_VAR 0 2
47477: PUSH
47478: LD_INT 3
47480: PLUS
47481: PUSH
47482: LD_INT 0
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: LIST
47489: PUSH
47490: LD_VAR 0 1
47494: PUSH
47495: LD_INT 4
47497: PLUS
47498: PUSH
47499: LD_VAR 0 2
47503: PUSH
47504: LD_INT 4
47506: PLUS
47507: PUSH
47508: LD_INT 5
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: LIST
47515: PUSH
47516: EMPTY
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: LIST
47522: ST_TO_ADDR
// end ; 2 :
47523: GO 48082
47525: LD_INT 2
47527: DOUBLE
47528: EQUAL
47529: IFTRUE 47533
47531: GO 47662
47533: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
47534: LD_ADDR_VAR 0 5
47538: PUSH
47539: LD_VAR 0 1
47543: PUSH
47544: LD_VAR 0 2
47548: PUSH
47549: LD_INT 3
47551: MINUS
47552: PUSH
47553: LD_INT 3
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: LIST
47560: PUSH
47561: LD_VAR 0 1
47565: PUSH
47566: LD_INT 4
47568: PLUS
47569: PUSH
47570: LD_VAR 0 2
47574: PUSH
47575: LD_INT 4
47577: PUSH
47578: EMPTY
47579: LIST
47580: LIST
47581: LIST
47582: PUSH
47583: LD_VAR 0 1
47587: PUSH
47588: LD_VAR 0 2
47592: PUSH
47593: LD_INT 4
47595: PLUS
47596: PUSH
47597: LD_INT 0
47599: PUSH
47600: EMPTY
47601: LIST
47602: LIST
47603: LIST
47604: PUSH
47605: LD_VAR 0 1
47609: PUSH
47610: LD_INT 3
47612: MINUS
47613: PUSH
47614: LD_VAR 0 2
47618: PUSH
47619: LD_INT 1
47621: PUSH
47622: EMPTY
47623: LIST
47624: LIST
47625: LIST
47626: PUSH
47627: LD_VAR 0 1
47631: PUSH
47632: LD_INT 4
47634: MINUS
47635: PUSH
47636: LD_VAR 0 2
47640: PUSH
47641: LD_INT 4
47643: MINUS
47644: PUSH
47645: LD_INT 2
47647: PUSH
47648: EMPTY
47649: LIST
47650: LIST
47651: LIST
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: ST_TO_ADDR
// end ; 3 :
47660: GO 48082
47662: LD_INT 3
47664: DOUBLE
47665: EQUAL
47666: IFTRUE 47670
47668: GO 47803
47670: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
47671: LD_ADDR_VAR 0 5
47675: PUSH
47676: LD_VAR 0 1
47680: PUSH
47681: LD_INT 3
47683: PLUS
47684: PUSH
47685: LD_VAR 0 2
47689: PUSH
47690: LD_INT 4
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: LIST
47697: PUSH
47698: LD_VAR 0 1
47702: PUSH
47703: LD_INT 4
47705: PLUS
47706: PUSH
47707: LD_VAR 0 2
47711: PUSH
47712: LD_INT 4
47714: PLUS
47715: PUSH
47716: LD_INT 5
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: LIST
47723: PUSH
47724: LD_VAR 0 1
47728: PUSH
47729: LD_INT 4
47731: MINUS
47732: PUSH
47733: LD_VAR 0 2
47737: PUSH
47738: LD_INT 1
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: LIST
47745: PUSH
47746: LD_VAR 0 1
47750: PUSH
47751: LD_VAR 0 2
47755: PUSH
47756: LD_INT 4
47758: MINUS
47759: PUSH
47760: LD_INT 3
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: LIST
47767: PUSH
47768: LD_VAR 0 1
47772: PUSH
47773: LD_INT 3
47775: MINUS
47776: PUSH
47777: LD_VAR 0 2
47781: PUSH
47782: LD_INT 3
47784: MINUS
47785: PUSH
47786: LD_INT 2
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: LIST
47793: PUSH
47794: EMPTY
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: ST_TO_ADDR
// end ; 4 :
47801: GO 48082
47803: LD_INT 4
47805: DOUBLE
47806: EQUAL
47807: IFTRUE 47811
47809: GO 47944
47811: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
47812: LD_ADDR_VAR 0 5
47816: PUSH
47817: LD_VAR 0 1
47821: PUSH
47822: LD_VAR 0 2
47826: PUSH
47827: LD_INT 4
47829: PLUS
47830: PUSH
47831: LD_INT 0
47833: PUSH
47834: EMPTY
47835: LIST
47836: LIST
47837: LIST
47838: PUSH
47839: LD_VAR 0 1
47843: PUSH
47844: LD_INT 3
47846: PLUS
47847: PUSH
47848: LD_VAR 0 2
47852: PUSH
47853: LD_INT 3
47855: PLUS
47856: PUSH
47857: LD_INT 5
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: LIST
47864: PUSH
47865: LD_VAR 0 1
47869: PUSH
47870: LD_INT 4
47872: PLUS
47873: PUSH
47874: LD_VAR 0 2
47878: PUSH
47879: LD_INT 4
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: LIST
47886: PUSH
47887: LD_VAR 0 1
47891: PUSH
47892: LD_VAR 0 2
47896: PUSH
47897: LD_INT 3
47899: MINUS
47900: PUSH
47901: LD_INT 3
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: LIST
47908: PUSH
47909: LD_VAR 0 1
47913: PUSH
47914: LD_INT 4
47916: MINUS
47917: PUSH
47918: LD_VAR 0 2
47922: PUSH
47923: LD_INT 4
47925: MINUS
47926: PUSH
47927: LD_INT 2
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: LIST
47934: PUSH
47935: EMPTY
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: ST_TO_ADDR
// end ; 5 :
47942: GO 48082
47944: LD_INT 5
47946: DOUBLE
47947: EQUAL
47948: IFTRUE 47952
47950: GO 48081
47952: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
47953: LD_ADDR_VAR 0 5
47957: PUSH
47958: LD_VAR 0 1
47962: PUSH
47963: LD_INT 4
47965: MINUS
47966: PUSH
47967: LD_VAR 0 2
47971: PUSH
47972: LD_INT 1
47974: PUSH
47975: EMPTY
47976: LIST
47977: LIST
47978: LIST
47979: PUSH
47980: LD_VAR 0 1
47984: PUSH
47985: LD_VAR 0 2
47989: PUSH
47990: LD_INT 4
47992: MINUS
47993: PUSH
47994: LD_INT 3
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: PUSH
48002: LD_VAR 0 1
48006: PUSH
48007: LD_INT 4
48009: PLUS
48010: PUSH
48011: LD_VAR 0 2
48015: PUSH
48016: LD_INT 4
48018: PLUS
48019: PUSH
48020: LD_INT 5
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: LIST
48027: PUSH
48028: LD_VAR 0 1
48032: PUSH
48033: LD_INT 3
48035: PLUS
48036: PUSH
48037: LD_VAR 0 2
48041: PUSH
48042: LD_INT 4
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: LIST
48049: PUSH
48050: LD_VAR 0 1
48054: PUSH
48055: LD_VAR 0 2
48059: PUSH
48060: LD_INT 3
48062: PLUS
48063: PUSH
48064: LD_INT 0
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: LIST
48071: PUSH
48072: EMPTY
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: ST_TO_ADDR
// end ; end ;
48079: GO 48082
48081: POP
// result := list ;
48082: LD_ADDR_VAR 0 4
48086: PUSH
48087: LD_VAR 0 5
48091: ST_TO_ADDR
// end ;
48092: LD_VAR 0 4
48096: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48097: LD_INT 0
48099: PPUSH
48100: PPUSH
48101: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48102: LD_VAR 0 1
48106: NOT
48107: PUSH
48108: LD_VAR 0 2
48112: PUSH
48113: LD_INT 1
48115: PUSH
48116: LD_INT 2
48118: PUSH
48119: LD_INT 3
48121: PUSH
48122: LD_INT 4
48124: PUSH
48125: EMPTY
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: IN
48131: NOT
48132: OR
48133: IFFALSE 48137
// exit ;
48135: GO 48229
// tmp := [ ] ;
48137: LD_ADDR_VAR 0 5
48141: PUSH
48142: EMPTY
48143: ST_TO_ADDR
// for i in units do
48144: LD_ADDR_VAR 0 4
48148: PUSH
48149: LD_VAR 0 1
48153: PUSH
48154: FOR_IN
48155: IFFALSE 48198
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48157: LD_ADDR_VAR 0 5
48161: PUSH
48162: LD_VAR 0 5
48166: PPUSH
48167: LD_VAR 0 5
48171: PUSH
48172: LD_INT 1
48174: PLUS
48175: PPUSH
48176: LD_VAR 0 4
48180: PPUSH
48181: LD_VAR 0 2
48185: PPUSH
48186: CALL_OW 259
48190: PPUSH
48191: CALL_OW 2
48195: ST_TO_ADDR
48196: GO 48154
48198: POP
48199: POP
// if not tmp then
48200: LD_VAR 0 5
48204: NOT
48205: IFFALSE 48209
// exit ;
48207: GO 48229
// result := SortListByListDesc ( units , tmp ) ;
48209: LD_ADDR_VAR 0 3
48213: PUSH
48214: LD_VAR 0 1
48218: PPUSH
48219: LD_VAR 0 5
48223: PPUSH
48224: CALL_OW 77
48228: ST_TO_ADDR
// end ;
48229: LD_VAR 0 3
48233: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48234: LD_INT 0
48236: PPUSH
48237: PPUSH
48238: PPUSH
// result := false ;
48239: LD_ADDR_VAR 0 3
48243: PUSH
48244: LD_INT 0
48246: ST_TO_ADDR
// x := GetX ( building ) ;
48247: LD_ADDR_VAR 0 4
48251: PUSH
48252: LD_VAR 0 2
48256: PPUSH
48257: CALL_OW 250
48261: ST_TO_ADDR
// y := GetY ( building ) ;
48262: LD_ADDR_VAR 0 5
48266: PUSH
48267: LD_VAR 0 2
48271: PPUSH
48272: CALL_OW 251
48276: ST_TO_ADDR
// if not building or not x or not y then
48277: LD_VAR 0 2
48281: NOT
48282: PUSH
48283: LD_VAR 0 4
48287: NOT
48288: OR
48289: PUSH
48290: LD_VAR 0 5
48294: NOT
48295: OR
48296: IFFALSE 48300
// exit ;
48298: GO 48392
// if GetTaskList ( unit ) then
48300: LD_VAR 0 1
48304: PPUSH
48305: CALL_OW 437
48309: IFFALSE 48392
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48311: LD_STRING e
48313: PUSH
48314: LD_VAR 0 1
48318: PPUSH
48319: CALL_OW 437
48323: PUSH
48324: LD_INT 1
48326: ARRAY
48327: PUSH
48328: LD_INT 1
48330: ARRAY
48331: EQUAL
48332: PUSH
48333: LD_VAR 0 4
48337: PUSH
48338: LD_VAR 0 1
48342: PPUSH
48343: CALL_OW 437
48347: PUSH
48348: LD_INT 1
48350: ARRAY
48351: PUSH
48352: LD_INT 2
48354: ARRAY
48355: EQUAL
48356: AND
48357: PUSH
48358: LD_VAR 0 5
48362: PUSH
48363: LD_VAR 0 1
48367: PPUSH
48368: CALL_OW 437
48372: PUSH
48373: LD_INT 1
48375: ARRAY
48376: PUSH
48377: LD_INT 3
48379: ARRAY
48380: EQUAL
48381: AND
48382: IFFALSE 48392
// result := true end ;
48384: LD_ADDR_VAR 0 3
48388: PUSH
48389: LD_INT 1
48391: ST_TO_ADDR
// end ;
48392: LD_VAR 0 3
48396: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
48397: LD_INT 0
48399: PPUSH
// result := false ;
48400: LD_ADDR_VAR 0 4
48404: PUSH
48405: LD_INT 0
48407: ST_TO_ADDR
// if GetTaskList ( unit ) then
48408: LD_VAR 0 1
48412: PPUSH
48413: CALL_OW 437
48417: IFFALSE 48500
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48419: LD_STRING M
48421: PUSH
48422: LD_VAR 0 1
48426: PPUSH
48427: CALL_OW 437
48431: PUSH
48432: LD_INT 1
48434: ARRAY
48435: PUSH
48436: LD_INT 1
48438: ARRAY
48439: EQUAL
48440: PUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_VAR 0 1
48450: PPUSH
48451: CALL_OW 437
48455: PUSH
48456: LD_INT 1
48458: ARRAY
48459: PUSH
48460: LD_INT 2
48462: ARRAY
48463: EQUAL
48464: AND
48465: PUSH
48466: LD_VAR 0 3
48470: PUSH
48471: LD_VAR 0 1
48475: PPUSH
48476: CALL_OW 437
48480: PUSH
48481: LD_INT 1
48483: ARRAY
48484: PUSH
48485: LD_INT 3
48487: ARRAY
48488: EQUAL
48489: AND
48490: IFFALSE 48500
// result := true ;
48492: LD_ADDR_VAR 0 4
48496: PUSH
48497: LD_INT 1
48499: ST_TO_ADDR
// end ; end ;
48500: LD_VAR 0 4
48504: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
48505: LD_INT 0
48507: PPUSH
48508: PPUSH
48509: PPUSH
48510: PPUSH
// if not unit or not area then
48511: LD_VAR 0 1
48515: NOT
48516: PUSH
48517: LD_VAR 0 2
48521: NOT
48522: OR
48523: IFFALSE 48527
// exit ;
48525: GO 48691
// tmp := AreaToList ( area , i ) ;
48527: LD_ADDR_VAR 0 6
48531: PUSH
48532: LD_VAR 0 2
48536: PPUSH
48537: LD_VAR 0 5
48541: PPUSH
48542: CALL_OW 517
48546: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
48547: LD_ADDR_VAR 0 5
48551: PUSH
48552: DOUBLE
48553: LD_INT 1
48555: DEC
48556: ST_TO_ADDR
48557: LD_VAR 0 6
48561: PUSH
48562: LD_INT 1
48564: ARRAY
48565: PUSH
48566: FOR_TO
48567: IFFALSE 48689
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
48569: LD_ADDR_VAR 0 7
48573: PUSH
48574: LD_VAR 0 6
48578: PUSH
48579: LD_INT 1
48581: ARRAY
48582: PUSH
48583: LD_VAR 0 5
48587: ARRAY
48588: PUSH
48589: LD_VAR 0 6
48593: PUSH
48594: LD_INT 2
48596: ARRAY
48597: PUSH
48598: LD_VAR 0 5
48602: ARRAY
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
48608: LD_VAR 0 7
48612: PUSH
48613: LD_INT 1
48615: ARRAY
48616: PPUSH
48617: LD_VAR 0 7
48621: PUSH
48622: LD_INT 2
48624: ARRAY
48625: PPUSH
48626: CALL_OW 428
48630: PUSH
48631: LD_INT 0
48633: EQUAL
48634: IFFALSE 48687
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
48636: LD_VAR 0 1
48640: PPUSH
48641: LD_VAR 0 7
48645: PUSH
48646: LD_INT 1
48648: ARRAY
48649: PPUSH
48650: LD_VAR 0 7
48654: PUSH
48655: LD_INT 2
48657: ARRAY
48658: PPUSH
48659: LD_VAR 0 3
48663: PPUSH
48664: CALL_OW 48
// result := IsPlaced ( unit ) ;
48668: LD_ADDR_VAR 0 4
48672: PUSH
48673: LD_VAR 0 1
48677: PPUSH
48678: CALL_OW 305
48682: ST_TO_ADDR
// exit ;
48683: POP
48684: POP
48685: GO 48691
// end ; end ;
48687: GO 48566
48689: POP
48690: POP
// end ;
48691: LD_VAR 0 4
48695: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
48696: LD_INT 0
48698: PPUSH
48699: PPUSH
48700: PPUSH
// if not side or side > 8 then
48701: LD_VAR 0 1
48705: NOT
48706: PUSH
48707: LD_VAR 0 1
48711: PUSH
48712: LD_INT 8
48714: GREATER
48715: OR
48716: IFFALSE 48720
// exit ;
48718: GO 48907
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
48720: LD_ADDR_VAR 0 4
48724: PUSH
48725: LD_INT 22
48727: PUSH
48728: LD_VAR 0 1
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: PUSH
48737: LD_INT 21
48739: PUSH
48740: LD_INT 3
48742: PUSH
48743: EMPTY
48744: LIST
48745: LIST
48746: PUSH
48747: EMPTY
48748: LIST
48749: LIST
48750: PPUSH
48751: CALL_OW 69
48755: ST_TO_ADDR
// if not tmp then
48756: LD_VAR 0 4
48760: NOT
48761: IFFALSE 48765
// exit ;
48763: GO 48907
// enable_addtolog := true ;
48765: LD_ADDR_OWVAR 81
48769: PUSH
48770: LD_INT 1
48772: ST_TO_ADDR
// AddToLog ( [ ) ;
48773: LD_STRING [
48775: PPUSH
48776: CALL_OW 561
// for i in tmp do
48780: LD_ADDR_VAR 0 3
48784: PUSH
48785: LD_VAR 0 4
48789: PUSH
48790: FOR_IN
48791: IFFALSE 48898
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
48793: LD_STRING [
48795: PUSH
48796: LD_VAR 0 3
48800: PPUSH
48801: CALL_OW 266
48805: STR
48806: PUSH
48807: LD_STRING , 
48809: STR
48810: PUSH
48811: LD_VAR 0 3
48815: PPUSH
48816: CALL_OW 250
48820: STR
48821: PUSH
48822: LD_STRING , 
48824: STR
48825: PUSH
48826: LD_VAR 0 3
48830: PPUSH
48831: CALL_OW 251
48835: STR
48836: PUSH
48837: LD_STRING , 
48839: STR
48840: PUSH
48841: LD_VAR 0 3
48845: PPUSH
48846: CALL_OW 254
48850: STR
48851: PUSH
48852: LD_STRING , 
48854: STR
48855: PUSH
48856: LD_VAR 0 3
48860: PPUSH
48861: LD_INT 1
48863: PPUSH
48864: CALL_OW 268
48868: STR
48869: PUSH
48870: LD_STRING , 
48872: STR
48873: PUSH
48874: LD_VAR 0 3
48878: PPUSH
48879: LD_INT 2
48881: PPUSH
48882: CALL_OW 268
48886: STR
48887: PUSH
48888: LD_STRING ],
48890: STR
48891: PPUSH
48892: CALL_OW 561
// end ;
48896: GO 48790
48898: POP
48899: POP
// AddToLog ( ]; ) ;
48900: LD_STRING ];
48902: PPUSH
48903: CALL_OW 561
// end ;
48907: LD_VAR 0 2
48911: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
48912: LD_INT 0
48914: PPUSH
48915: PPUSH
48916: PPUSH
48917: PPUSH
48918: PPUSH
// if not area or not rate or not max then
48919: LD_VAR 0 1
48923: NOT
48924: PUSH
48925: LD_VAR 0 2
48929: NOT
48930: OR
48931: PUSH
48932: LD_VAR 0 4
48936: NOT
48937: OR
48938: IFFALSE 48942
// exit ;
48940: GO 49134
// while 1 do
48942: LD_INT 1
48944: IFFALSE 49134
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
48946: LD_ADDR_VAR 0 9
48950: PUSH
48951: LD_VAR 0 1
48955: PPUSH
48956: LD_INT 1
48958: PPUSH
48959: CALL_OW 287
48963: PUSH
48964: LD_INT 10
48966: MUL
48967: ST_TO_ADDR
// r := rate / 10 ;
48968: LD_ADDR_VAR 0 7
48972: PUSH
48973: LD_VAR 0 2
48977: PUSH
48978: LD_INT 10
48980: DIVREAL
48981: ST_TO_ADDR
// time := 1 1$00 ;
48982: LD_ADDR_VAR 0 8
48986: PUSH
48987: LD_INT 2100
48989: ST_TO_ADDR
// if amount < min then
48990: LD_VAR 0 9
48994: PUSH
48995: LD_VAR 0 3
48999: LESS
49000: IFFALSE 49018
// r := r * 2 else
49002: LD_ADDR_VAR 0 7
49006: PUSH
49007: LD_VAR 0 7
49011: PUSH
49012: LD_INT 2
49014: MUL
49015: ST_TO_ADDR
49016: GO 49044
// if amount > max then
49018: LD_VAR 0 9
49022: PUSH
49023: LD_VAR 0 4
49027: GREATER
49028: IFFALSE 49044
// r := r / 2 ;
49030: LD_ADDR_VAR 0 7
49034: PUSH
49035: LD_VAR 0 7
49039: PUSH
49040: LD_INT 2
49042: DIVREAL
49043: ST_TO_ADDR
// time := time / r ;
49044: LD_ADDR_VAR 0 8
49048: PUSH
49049: LD_VAR 0 8
49053: PUSH
49054: LD_VAR 0 7
49058: DIVREAL
49059: ST_TO_ADDR
// if time < 0 then
49060: LD_VAR 0 8
49064: PUSH
49065: LD_INT 0
49067: LESS
49068: IFFALSE 49085
// time := time * - 1 ;
49070: LD_ADDR_VAR 0 8
49074: PUSH
49075: LD_VAR 0 8
49079: PUSH
49080: LD_INT 1
49082: NEG
49083: MUL
49084: ST_TO_ADDR
// wait ( time ) ;
49085: LD_VAR 0 8
49089: PPUSH
49090: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49094: LD_INT 35
49096: PPUSH
49097: LD_INT 875
49099: PPUSH
49100: CALL_OW 12
49104: PPUSH
49105: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49109: LD_INT 1
49111: PPUSH
49112: LD_INT 5
49114: PPUSH
49115: CALL_OW 12
49119: PPUSH
49120: LD_VAR 0 1
49124: PPUSH
49125: LD_INT 1
49127: PPUSH
49128: CALL_OW 55
// end ;
49132: GO 48942
// end ;
49134: LD_VAR 0 5
49138: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49139: LD_INT 0
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
// if not turrets or not factories then
49149: LD_VAR 0 1
49153: NOT
49154: PUSH
49155: LD_VAR 0 2
49159: NOT
49160: OR
49161: IFFALSE 49165
// exit ;
49163: GO 49472
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49165: LD_ADDR_VAR 0 10
49169: PUSH
49170: LD_INT 5
49172: PUSH
49173: LD_INT 6
49175: PUSH
49176: EMPTY
49177: LIST
49178: LIST
49179: PUSH
49180: LD_INT 2
49182: PUSH
49183: LD_INT 4
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: PUSH
49190: LD_INT 3
49192: PUSH
49193: LD_INT 5
49195: PUSH
49196: EMPTY
49197: LIST
49198: LIST
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 24
49207: PUSH
49208: LD_INT 25
49210: PUSH
49211: EMPTY
49212: LIST
49213: LIST
49214: PUSH
49215: LD_INT 23
49217: PUSH
49218: LD_INT 27
49220: PUSH
49221: EMPTY
49222: LIST
49223: LIST
49224: PUSH
49225: EMPTY
49226: LIST
49227: LIST
49228: PUSH
49229: LD_INT 42
49231: PUSH
49232: LD_INT 43
49234: PUSH
49235: EMPTY
49236: LIST
49237: LIST
49238: PUSH
49239: LD_INT 44
49241: PUSH
49242: LD_INT 46
49244: PUSH
49245: EMPTY
49246: LIST
49247: LIST
49248: PUSH
49249: LD_INT 45
49251: PUSH
49252: LD_INT 47
49254: PUSH
49255: EMPTY
49256: LIST
49257: LIST
49258: PUSH
49259: EMPTY
49260: LIST
49261: LIST
49262: LIST
49263: PUSH
49264: EMPTY
49265: LIST
49266: LIST
49267: LIST
49268: ST_TO_ADDR
// result := [ ] ;
49269: LD_ADDR_VAR 0 3
49273: PUSH
49274: EMPTY
49275: ST_TO_ADDR
// for i in turrets do
49276: LD_ADDR_VAR 0 4
49280: PUSH
49281: LD_VAR 0 1
49285: PUSH
49286: FOR_IN
49287: IFFALSE 49470
// begin nat := GetNation ( i ) ;
49289: LD_ADDR_VAR 0 7
49293: PUSH
49294: LD_VAR 0 4
49298: PPUSH
49299: CALL_OW 248
49303: ST_TO_ADDR
// weapon := 0 ;
49304: LD_ADDR_VAR 0 8
49308: PUSH
49309: LD_INT 0
49311: ST_TO_ADDR
// if not nat then
49312: LD_VAR 0 7
49316: NOT
49317: IFFALSE 49321
// continue ;
49319: GO 49286
// for j in list [ nat ] do
49321: LD_ADDR_VAR 0 5
49325: PUSH
49326: LD_VAR 0 10
49330: PUSH
49331: LD_VAR 0 7
49335: ARRAY
49336: PUSH
49337: FOR_IN
49338: IFFALSE 49379
// if GetBWeapon ( i ) = j [ 1 ] then
49340: LD_VAR 0 4
49344: PPUSH
49345: CALL_OW 269
49349: PUSH
49350: LD_VAR 0 5
49354: PUSH
49355: LD_INT 1
49357: ARRAY
49358: EQUAL
49359: IFFALSE 49377
// begin weapon := j [ 2 ] ;
49361: LD_ADDR_VAR 0 8
49365: PUSH
49366: LD_VAR 0 5
49370: PUSH
49371: LD_INT 2
49373: ARRAY
49374: ST_TO_ADDR
// break ;
49375: GO 49379
// end ;
49377: GO 49337
49379: POP
49380: POP
// if not weapon then
49381: LD_VAR 0 8
49385: NOT
49386: IFFALSE 49390
// continue ;
49388: GO 49286
// for k in factories do
49390: LD_ADDR_VAR 0 6
49394: PUSH
49395: LD_VAR 0 2
49399: PUSH
49400: FOR_IN
49401: IFFALSE 49466
// begin weapons := AvailableWeaponList ( k ) ;
49403: LD_ADDR_VAR 0 9
49407: PUSH
49408: LD_VAR 0 6
49412: PPUSH
49413: CALL_OW 478
49417: ST_TO_ADDR
// if not weapons then
49418: LD_VAR 0 9
49422: NOT
49423: IFFALSE 49427
// continue ;
49425: GO 49400
// if weapon in weapons then
49427: LD_VAR 0 8
49431: PUSH
49432: LD_VAR 0 9
49436: IN
49437: IFFALSE 49464
// begin result := [ i , weapon ] ;
49439: LD_ADDR_VAR 0 3
49443: PUSH
49444: LD_VAR 0 4
49448: PUSH
49449: LD_VAR 0 8
49453: PUSH
49454: EMPTY
49455: LIST
49456: LIST
49457: ST_TO_ADDR
// exit ;
49458: POP
49459: POP
49460: POP
49461: POP
49462: GO 49472
// end ; end ;
49464: GO 49400
49466: POP
49467: POP
// end ;
49468: GO 49286
49470: POP
49471: POP
// end ;
49472: LD_VAR 0 3
49476: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
49477: LD_INT 0
49479: PPUSH
// if not side or side > 8 then
49480: LD_VAR 0 3
49484: NOT
49485: PUSH
49486: LD_VAR 0 3
49490: PUSH
49491: LD_INT 8
49493: GREATER
49494: OR
49495: IFFALSE 49499
// exit ;
49497: GO 49558
// if not range then
49499: LD_VAR 0 4
49503: NOT
49504: IFFALSE 49515
// range := - 12 ;
49506: LD_ADDR_VAR 0 4
49510: PUSH
49511: LD_INT 12
49513: NEG
49514: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
49515: LD_VAR 0 1
49519: PPUSH
49520: LD_VAR 0 2
49524: PPUSH
49525: LD_VAR 0 3
49529: PPUSH
49530: LD_VAR 0 4
49534: PPUSH
49535: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
49539: LD_VAR 0 1
49543: PPUSH
49544: LD_VAR 0 2
49548: PPUSH
49549: LD_VAR 0 3
49553: PPUSH
49554: CALL_OW 331
// end ;
49558: LD_VAR 0 5
49562: RET
// export function Video ( mode ) ; begin
49563: LD_INT 0
49565: PPUSH
// ingame_video = mode ;
49566: LD_ADDR_OWVAR 52
49570: PUSH
49571: LD_VAR 0 1
49575: ST_TO_ADDR
// interface_hidden = mode ;
49576: LD_ADDR_OWVAR 54
49580: PUSH
49581: LD_VAR 0 1
49585: ST_TO_ADDR
// end ;
49586: LD_VAR 0 2
49590: RET
// export function Join ( array , element ) ; begin
49591: LD_INT 0
49593: PPUSH
// result := Replace ( array , array + 1 , element ) ;
49594: LD_ADDR_VAR 0 3
49598: PUSH
49599: LD_VAR 0 1
49603: PPUSH
49604: LD_VAR 0 1
49608: PUSH
49609: LD_INT 1
49611: PLUS
49612: PPUSH
49613: LD_VAR 0 2
49617: PPUSH
49618: CALL_OW 1
49622: ST_TO_ADDR
// end ;
49623: LD_VAR 0 3
49627: RET
// export function JoinUnion ( array , element ) ; begin
49628: LD_INT 0
49630: PPUSH
// result := array union element ;
49631: LD_ADDR_VAR 0 3
49635: PUSH
49636: LD_VAR 0 1
49640: PUSH
49641: LD_VAR 0 2
49645: UNION
49646: ST_TO_ADDR
// end ;
49647: LD_VAR 0 3
49651: RET
// export function GetBehemoths ( side ) ; begin
49652: LD_INT 0
49654: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
49655: LD_ADDR_VAR 0 2
49659: PUSH
49660: LD_INT 22
49662: PUSH
49663: LD_VAR 0 1
49667: PUSH
49668: EMPTY
49669: LIST
49670: LIST
49671: PUSH
49672: LD_INT 31
49674: PUSH
49675: LD_INT 25
49677: PUSH
49678: EMPTY
49679: LIST
49680: LIST
49681: PUSH
49682: EMPTY
49683: LIST
49684: LIST
49685: PPUSH
49686: CALL_OW 69
49690: ST_TO_ADDR
// end ;
49691: LD_VAR 0 2
49695: RET
// export function Shuffle ( array ) ; var i , index ; begin
49696: LD_INT 0
49698: PPUSH
49699: PPUSH
49700: PPUSH
// result := [ ] ;
49701: LD_ADDR_VAR 0 2
49705: PUSH
49706: EMPTY
49707: ST_TO_ADDR
// if not array then
49708: LD_VAR 0 1
49712: NOT
49713: IFFALSE 49717
// exit ;
49715: GO 49816
// Randomize ;
49717: CALL_OW 10
// for i = array downto 1 do
49721: LD_ADDR_VAR 0 3
49725: PUSH
49726: DOUBLE
49727: LD_VAR 0 1
49731: INC
49732: ST_TO_ADDR
49733: LD_INT 1
49735: PUSH
49736: FOR_DOWNTO
49737: IFFALSE 49814
// begin index := rand ( 1 , array ) ;
49739: LD_ADDR_VAR 0 4
49743: PUSH
49744: LD_INT 1
49746: PPUSH
49747: LD_VAR 0 1
49751: PPUSH
49752: CALL_OW 12
49756: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
49757: LD_ADDR_VAR 0 2
49761: PUSH
49762: LD_VAR 0 2
49766: PPUSH
49767: LD_VAR 0 2
49771: PUSH
49772: LD_INT 1
49774: PLUS
49775: PPUSH
49776: LD_VAR 0 1
49780: PUSH
49781: LD_VAR 0 4
49785: ARRAY
49786: PPUSH
49787: CALL_OW 2
49791: ST_TO_ADDR
// array := Delete ( array , index ) ;
49792: LD_ADDR_VAR 0 1
49796: PUSH
49797: LD_VAR 0 1
49801: PPUSH
49802: LD_VAR 0 4
49806: PPUSH
49807: CALL_OW 3
49811: ST_TO_ADDR
// end ;
49812: GO 49736
49814: POP
49815: POP
// end ;
49816: LD_VAR 0 2
49820: RET
// export function GetBaseMaterials ( base ) ; begin
49821: LD_INT 0
49823: PPUSH
// result := [ 0 , 0 , 0 ] ;
49824: LD_ADDR_VAR 0 2
49828: PUSH
49829: LD_INT 0
49831: PUSH
49832: LD_INT 0
49834: PUSH
49835: LD_INT 0
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: LIST
49842: ST_TO_ADDR
// if not base then
49843: LD_VAR 0 1
49847: NOT
49848: IFFALSE 49852
// exit ;
49850: GO 49901
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
49852: LD_ADDR_VAR 0 2
49856: PUSH
49857: LD_VAR 0 1
49861: PPUSH
49862: LD_INT 1
49864: PPUSH
49865: CALL_OW 275
49869: PUSH
49870: LD_VAR 0 1
49874: PPUSH
49875: LD_INT 2
49877: PPUSH
49878: CALL_OW 275
49882: PUSH
49883: LD_VAR 0 1
49887: PPUSH
49888: LD_INT 3
49890: PPUSH
49891: CALL_OW 275
49895: PUSH
49896: EMPTY
49897: LIST
49898: LIST
49899: LIST
49900: ST_TO_ADDR
// end ;
49901: LD_VAR 0 2
49905: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
49906: LD_INT 0
49908: PPUSH
49909: PPUSH
// result := array ;
49910: LD_ADDR_VAR 0 3
49914: PUSH
49915: LD_VAR 0 1
49919: ST_TO_ADDR
// if size > 0 then
49920: LD_VAR 0 2
49924: PUSH
49925: LD_INT 0
49927: GREATER
49928: IFFALSE 49974
// for i := array downto size do
49930: LD_ADDR_VAR 0 4
49934: PUSH
49935: DOUBLE
49936: LD_VAR 0 1
49940: INC
49941: ST_TO_ADDR
49942: LD_VAR 0 2
49946: PUSH
49947: FOR_DOWNTO
49948: IFFALSE 49972
// result := Delete ( result , result ) ;
49950: LD_ADDR_VAR 0 3
49954: PUSH
49955: LD_VAR 0 3
49959: PPUSH
49960: LD_VAR 0 3
49964: PPUSH
49965: CALL_OW 3
49969: ST_TO_ADDR
49970: GO 49947
49972: POP
49973: POP
// end ;
49974: LD_VAR 0 3
49978: RET
// export function ComExit ( unit ) ; var tmp ; begin
49979: LD_INT 0
49981: PPUSH
49982: PPUSH
// if not IsInUnit ( unit ) then
49983: LD_VAR 0 1
49987: PPUSH
49988: CALL_OW 310
49992: NOT
49993: IFFALSE 49997
// exit ;
49995: GO 50057
// tmp := IsInUnit ( unit ) ;
49997: LD_ADDR_VAR 0 3
50001: PUSH
50002: LD_VAR 0 1
50006: PPUSH
50007: CALL_OW 310
50011: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50012: LD_VAR 0 3
50016: PPUSH
50017: CALL_OW 247
50021: PUSH
50022: LD_INT 2
50024: EQUAL
50025: IFFALSE 50038
// ComExitVehicle ( unit ) else
50027: LD_VAR 0 1
50031: PPUSH
50032: CALL_OW 121
50036: GO 50047
// ComExitBuilding ( unit ) ;
50038: LD_VAR 0 1
50042: PPUSH
50043: CALL_OW 122
// result := tmp ;
50047: LD_ADDR_VAR 0 2
50051: PUSH
50052: LD_VAR 0 3
50056: ST_TO_ADDR
// end ;
50057: LD_VAR 0 2
50061: RET
// export function ResetHc ; begin
50062: LD_INT 0
50064: PPUSH
// InitHc ;
50065: CALL_OW 19
// hc_importance := 0 ;
50069: LD_ADDR_OWVAR 32
50073: PUSH
50074: LD_INT 0
50076: ST_TO_ADDR
// end ;
50077: LD_VAR 0 1
50081: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50082: LD_INT 0
50084: PPUSH
50085: PPUSH
50086: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50087: LD_ADDR_VAR 0 6
50091: PUSH
50092: LD_VAR 0 1
50096: PUSH
50097: LD_VAR 0 3
50101: PLUS
50102: PUSH
50103: LD_INT 2
50105: DIV
50106: ST_TO_ADDR
// if _x < 0 then
50107: LD_VAR 0 6
50111: PUSH
50112: LD_INT 0
50114: LESS
50115: IFFALSE 50132
// _x := _x * - 1 ;
50117: LD_ADDR_VAR 0 6
50121: PUSH
50122: LD_VAR 0 6
50126: PUSH
50127: LD_INT 1
50129: NEG
50130: MUL
50131: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50132: LD_ADDR_VAR 0 7
50136: PUSH
50137: LD_VAR 0 2
50141: PUSH
50142: LD_VAR 0 4
50146: PLUS
50147: PUSH
50148: LD_INT 2
50150: DIV
50151: ST_TO_ADDR
// if _y < 0 then
50152: LD_VAR 0 7
50156: PUSH
50157: LD_INT 0
50159: LESS
50160: IFFALSE 50177
// _y := _y * - 1 ;
50162: LD_ADDR_VAR 0 7
50166: PUSH
50167: LD_VAR 0 7
50171: PUSH
50172: LD_INT 1
50174: NEG
50175: MUL
50176: ST_TO_ADDR
// result := [ _x , _y ] ;
50177: LD_ADDR_VAR 0 5
50181: PUSH
50182: LD_VAR 0 6
50186: PUSH
50187: LD_VAR 0 7
50191: PUSH
50192: EMPTY
50193: LIST
50194: LIST
50195: ST_TO_ADDR
// end ;
50196: LD_VAR 0 5
50200: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50201: LD_INT 0
50203: PPUSH
50204: PPUSH
50205: PPUSH
50206: PPUSH
// task := GetTaskList ( unit ) ;
50207: LD_ADDR_VAR 0 7
50211: PUSH
50212: LD_VAR 0 1
50216: PPUSH
50217: CALL_OW 437
50221: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50222: LD_VAR 0 7
50226: NOT
50227: PUSH
50228: LD_VAR 0 1
50232: PPUSH
50233: LD_VAR 0 2
50237: PPUSH
50238: CALL_OW 308
50242: NOT
50243: AND
50244: IFFALSE 50248
// exit ;
50246: GO 50366
// if IsInArea ( unit , area ) then
50248: LD_VAR 0 1
50252: PPUSH
50253: LD_VAR 0 2
50257: PPUSH
50258: CALL_OW 308
50262: IFFALSE 50280
// begin ComMoveToArea ( unit , goAway ) ;
50264: LD_VAR 0 1
50268: PPUSH
50269: LD_VAR 0 3
50273: PPUSH
50274: CALL_OW 113
// exit ;
50278: GO 50366
// end ; if task [ 1 ] [ 1 ] <> M then
50280: LD_VAR 0 7
50284: PUSH
50285: LD_INT 1
50287: ARRAY
50288: PUSH
50289: LD_INT 1
50291: ARRAY
50292: PUSH
50293: LD_STRING M
50295: NONEQUAL
50296: IFFALSE 50300
// exit ;
50298: GO 50366
// x := task [ 1 ] [ 2 ] ;
50300: LD_ADDR_VAR 0 5
50304: PUSH
50305: LD_VAR 0 7
50309: PUSH
50310: LD_INT 1
50312: ARRAY
50313: PUSH
50314: LD_INT 2
50316: ARRAY
50317: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
50318: LD_ADDR_VAR 0 6
50322: PUSH
50323: LD_VAR 0 7
50327: PUSH
50328: LD_INT 1
50330: ARRAY
50331: PUSH
50332: LD_INT 3
50334: ARRAY
50335: ST_TO_ADDR
// if InArea ( x , y , area ) then
50336: LD_VAR 0 5
50340: PPUSH
50341: LD_VAR 0 6
50345: PPUSH
50346: LD_VAR 0 2
50350: PPUSH
50351: CALL_OW 309
50355: IFFALSE 50366
// ComStop ( unit ) ;
50357: LD_VAR 0 1
50361: PPUSH
50362: CALL_OW 141
// end ;
50366: LD_VAR 0 4
50370: RET
// export function Abs ( value ) ; begin
50371: LD_INT 0
50373: PPUSH
// result := value ;
50374: LD_ADDR_VAR 0 2
50378: PUSH
50379: LD_VAR 0 1
50383: ST_TO_ADDR
// if value < 0 then
50384: LD_VAR 0 1
50388: PUSH
50389: LD_INT 0
50391: LESS
50392: IFFALSE 50409
// result := value * - 1 ;
50394: LD_ADDR_VAR 0 2
50398: PUSH
50399: LD_VAR 0 1
50403: PUSH
50404: LD_INT 1
50406: NEG
50407: MUL
50408: ST_TO_ADDR
// end ;
50409: LD_VAR 0 2
50413: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
50414: LD_INT 0
50416: PPUSH
50417: PPUSH
50418: PPUSH
50419: PPUSH
50420: PPUSH
50421: PPUSH
50422: PPUSH
50423: PPUSH
// if not unit or not building then
50424: LD_VAR 0 1
50428: NOT
50429: PUSH
50430: LD_VAR 0 2
50434: NOT
50435: OR
50436: IFFALSE 50440
// exit ;
50438: GO 50666
// x := GetX ( building ) ;
50440: LD_ADDR_VAR 0 4
50444: PUSH
50445: LD_VAR 0 2
50449: PPUSH
50450: CALL_OW 250
50454: ST_TO_ADDR
// y := GetY ( building ) ;
50455: LD_ADDR_VAR 0 6
50459: PUSH
50460: LD_VAR 0 2
50464: PPUSH
50465: CALL_OW 251
50469: ST_TO_ADDR
// d := GetDir ( building ) ;
50470: LD_ADDR_VAR 0 8
50474: PUSH
50475: LD_VAR 0 2
50479: PPUSH
50480: CALL_OW 254
50484: ST_TO_ADDR
// r := 4 ;
50485: LD_ADDR_VAR 0 9
50489: PUSH
50490: LD_INT 4
50492: ST_TO_ADDR
// for i := 1 to 5 do
50493: LD_ADDR_VAR 0 10
50497: PUSH
50498: DOUBLE
50499: LD_INT 1
50501: DEC
50502: ST_TO_ADDR
50503: LD_INT 5
50505: PUSH
50506: FOR_TO
50507: IFFALSE 50664
// begin _x := ShiftX ( x , d , r + i ) ;
50509: LD_ADDR_VAR 0 5
50513: PUSH
50514: LD_VAR 0 4
50518: PPUSH
50519: LD_VAR 0 8
50523: PPUSH
50524: LD_VAR 0 9
50528: PUSH
50529: LD_VAR 0 10
50533: PLUS
50534: PPUSH
50535: CALL_OW 272
50539: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
50540: LD_ADDR_VAR 0 7
50544: PUSH
50545: LD_VAR 0 6
50549: PPUSH
50550: LD_VAR 0 8
50554: PPUSH
50555: LD_VAR 0 9
50559: PUSH
50560: LD_VAR 0 10
50564: PLUS
50565: PPUSH
50566: CALL_OW 273
50570: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
50571: LD_VAR 0 5
50575: PPUSH
50576: LD_VAR 0 7
50580: PPUSH
50581: CALL_OW 488
50585: PUSH
50586: LD_VAR 0 5
50590: PPUSH
50591: LD_VAR 0 7
50595: PPUSH
50596: CALL_OW 428
50600: PPUSH
50601: CALL_OW 247
50605: PUSH
50606: LD_INT 3
50608: PUSH
50609: LD_INT 2
50611: PUSH
50612: EMPTY
50613: LIST
50614: LIST
50615: IN
50616: NOT
50617: AND
50618: IFFALSE 50662
// begin ComMoveXY ( unit , _x , _y ) ;
50620: LD_VAR 0 1
50624: PPUSH
50625: LD_VAR 0 5
50629: PPUSH
50630: LD_VAR 0 7
50634: PPUSH
50635: CALL_OW 111
// result := [ _x , _y ] ;
50639: LD_ADDR_VAR 0 3
50643: PUSH
50644: LD_VAR 0 5
50648: PUSH
50649: LD_VAR 0 7
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: ST_TO_ADDR
// exit ;
50658: POP
50659: POP
50660: GO 50666
// end ; end ;
50662: GO 50506
50664: POP
50665: POP
// end ; end_of_file
50666: LD_VAR 0 3
50670: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
50671: LD_INT 0
50673: PPUSH
// ar_miner := 81 ;
50674: LD_ADDR_EXP 55
50678: PUSH
50679: LD_INT 81
50681: ST_TO_ADDR
// ar_crane := 88 ;
50682: LD_ADDR_EXP 54
50686: PUSH
50687: LD_INT 88
50689: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
50690: LD_ADDR_EXP 49
50694: PUSH
50695: LD_INT 89
50697: ST_TO_ADDR
// us_hack := 99 ;
50698: LD_ADDR_EXP 50
50702: PUSH
50703: LD_INT 99
50705: ST_TO_ADDR
// us_artillery := 97 ;
50706: LD_ADDR_EXP 51
50710: PUSH
50711: LD_INT 97
50713: ST_TO_ADDR
// ar_bio_bomb := 91 ;
50714: LD_ADDR_EXP 52
50718: PUSH
50719: LD_INT 91
50721: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
50722: LD_ADDR_EXP 53
50726: PUSH
50727: LD_INT 92
50729: ST_TO_ADDR
// ru_radar := 98 ;
50730: LD_ADDR_EXP 48
50734: PUSH
50735: LD_INT 98
50737: ST_TO_ADDR
// tech_Artillery := 80 ;
50738: LD_ADDR_EXP 56
50742: PUSH
50743: LD_INT 80
50745: ST_TO_ADDR
// tech_RadMat := 81 ;
50746: LD_ADDR_EXP 57
50750: PUSH
50751: LD_INT 81
50753: ST_TO_ADDR
// tech_BasicTools := 82 ;
50754: LD_ADDR_EXP 58
50758: PUSH
50759: LD_INT 82
50761: ST_TO_ADDR
// tech_Cargo := 83 ;
50762: LD_ADDR_EXP 59
50766: PUSH
50767: LD_INT 83
50769: ST_TO_ADDR
// tech_Track := 84 ;
50770: LD_ADDR_EXP 60
50774: PUSH
50775: LD_INT 84
50777: ST_TO_ADDR
// tech_Crane := 85 ;
50778: LD_ADDR_EXP 61
50782: PUSH
50783: LD_INT 85
50785: ST_TO_ADDR
// tech_Bulldozer := 86 ;
50786: LD_ADDR_EXP 62
50790: PUSH
50791: LD_INT 86
50793: ST_TO_ADDR
// tech_Hovercraft := 87 ;
50794: LD_ADDR_EXP 63
50798: PUSH
50799: LD_INT 87
50801: ST_TO_ADDR
// end ;
50802: LD_VAR 0 1
50806: RET
// every 1 do
50807: GO 50809
50809: DISABLE
// InitGlobalVariables ; end_of_file
50810: CALL 50671 0 0
50814: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
50815: LD_INT 0
50817: PPUSH
50818: PPUSH
// skirmish := false ;
50819: LD_ADDR_EXP 64
50823: PUSH
50824: LD_INT 0
50826: ST_TO_ADDR
// debug_mc := false ;
50827: LD_ADDR_EXP 65
50831: PUSH
50832: LD_INT 0
50834: ST_TO_ADDR
// mc_bases := [ ] ;
50835: LD_ADDR_EXP 66
50839: PUSH
50840: EMPTY
50841: ST_TO_ADDR
// mc_sides := [ ] ;
50842: LD_ADDR_EXP 92
50846: PUSH
50847: EMPTY
50848: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50849: LD_ADDR_EXP 67
50853: PUSH
50854: EMPTY
50855: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50856: LD_ADDR_EXP 68
50860: PUSH
50861: EMPTY
50862: ST_TO_ADDR
// mc_need_heal := [ ] ;
50863: LD_ADDR_EXP 69
50867: PUSH
50868: EMPTY
50869: ST_TO_ADDR
// mc_healers := [ ] ;
50870: LD_ADDR_EXP 70
50874: PUSH
50875: EMPTY
50876: ST_TO_ADDR
// mc_build_list := [ ] ;
50877: LD_ADDR_EXP 71
50881: PUSH
50882: EMPTY
50883: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50884: LD_ADDR_EXP 98
50888: PUSH
50889: EMPTY
50890: ST_TO_ADDR
// mc_builders := [ ] ;
50891: LD_ADDR_EXP 72
50895: PUSH
50896: EMPTY
50897: ST_TO_ADDR
// mc_construct_list := [ ] ;
50898: LD_ADDR_EXP 73
50902: PUSH
50903: EMPTY
50904: ST_TO_ADDR
// mc_turret_list := [ ] ;
50905: LD_ADDR_EXP 74
50909: PUSH
50910: EMPTY
50911: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50912: LD_ADDR_EXP 75
50916: PUSH
50917: EMPTY
50918: ST_TO_ADDR
// mc_miners := [ ] ;
50919: LD_ADDR_EXP 80
50923: PUSH
50924: EMPTY
50925: ST_TO_ADDR
// mc_mines := [ ] ;
50926: LD_ADDR_EXP 79
50930: PUSH
50931: EMPTY
50932: ST_TO_ADDR
// mc_minefields := [ ] ;
50933: LD_ADDR_EXP 81
50937: PUSH
50938: EMPTY
50939: ST_TO_ADDR
// mc_crates := [ ] ;
50940: LD_ADDR_EXP 82
50944: PUSH
50945: EMPTY
50946: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50947: LD_ADDR_EXP 83
50951: PUSH
50952: EMPTY
50953: ST_TO_ADDR
// mc_crates_area := [ ] ;
50954: LD_ADDR_EXP 84
50958: PUSH
50959: EMPTY
50960: ST_TO_ADDR
// mc_vehicles := [ ] ;
50961: LD_ADDR_EXP 85
50965: PUSH
50966: EMPTY
50967: ST_TO_ADDR
// mc_attack := [ ] ;
50968: LD_ADDR_EXP 86
50972: PUSH
50973: EMPTY
50974: ST_TO_ADDR
// mc_produce := [ ] ;
50975: LD_ADDR_EXP 87
50979: PUSH
50980: EMPTY
50981: ST_TO_ADDR
// mc_defender := [ ] ;
50982: LD_ADDR_EXP 88
50986: PUSH
50987: EMPTY
50988: ST_TO_ADDR
// mc_parking := [ ] ;
50989: LD_ADDR_EXP 90
50993: PUSH
50994: EMPTY
50995: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50996: LD_ADDR_EXP 76
51000: PUSH
51001: EMPTY
51002: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51003: LD_ADDR_EXP 78
51007: PUSH
51008: EMPTY
51009: ST_TO_ADDR
// mc_scan := [ ] ;
51010: LD_ADDR_EXP 89
51014: PUSH
51015: EMPTY
51016: ST_TO_ADDR
// mc_scan_area := [ ] ;
51017: LD_ADDR_EXP 91
51021: PUSH
51022: EMPTY
51023: ST_TO_ADDR
// mc_tech := [ ] ;
51024: LD_ADDR_EXP 93
51028: PUSH
51029: EMPTY
51030: ST_TO_ADDR
// mc_class := [ ] ;
51031: LD_ADDR_EXP 107
51035: PUSH
51036: EMPTY
51037: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51038: LD_ADDR_EXP 108
51042: PUSH
51043: EMPTY
51044: ST_TO_ADDR
// end ;
51045: LD_VAR 0 1
51049: RET
// export function MC_Kill ( base ) ; begin
51050: LD_INT 0
51052: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51053: LD_ADDR_EXP 66
51057: PUSH
51058: LD_EXP 66
51062: PPUSH
51063: LD_VAR 0 1
51067: PPUSH
51068: EMPTY
51069: PPUSH
51070: CALL_OW 1
51074: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51075: LD_ADDR_EXP 67
51079: PUSH
51080: LD_EXP 67
51084: PPUSH
51085: LD_VAR 0 1
51089: PPUSH
51090: EMPTY
51091: PPUSH
51092: CALL_OW 1
51096: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51097: LD_ADDR_EXP 68
51101: PUSH
51102: LD_EXP 68
51106: PPUSH
51107: LD_VAR 0 1
51111: PPUSH
51112: EMPTY
51113: PPUSH
51114: CALL_OW 1
51118: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51119: LD_ADDR_EXP 69
51123: PUSH
51124: LD_EXP 69
51128: PPUSH
51129: LD_VAR 0 1
51133: PPUSH
51134: EMPTY
51135: PPUSH
51136: CALL_OW 1
51140: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51141: LD_ADDR_EXP 70
51145: PUSH
51146: LD_EXP 70
51150: PPUSH
51151: LD_VAR 0 1
51155: PPUSH
51156: EMPTY
51157: PPUSH
51158: CALL_OW 1
51162: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51163: LD_ADDR_EXP 71
51167: PUSH
51168: LD_EXP 71
51172: PPUSH
51173: LD_VAR 0 1
51177: PPUSH
51178: EMPTY
51179: PPUSH
51180: CALL_OW 1
51184: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51185: LD_ADDR_EXP 72
51189: PUSH
51190: LD_EXP 72
51194: PPUSH
51195: LD_VAR 0 1
51199: PPUSH
51200: EMPTY
51201: PPUSH
51202: CALL_OW 1
51206: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51207: LD_ADDR_EXP 73
51211: PUSH
51212: LD_EXP 73
51216: PPUSH
51217: LD_VAR 0 1
51221: PPUSH
51222: EMPTY
51223: PPUSH
51224: CALL_OW 1
51228: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51229: LD_ADDR_EXP 74
51233: PUSH
51234: LD_EXP 74
51238: PPUSH
51239: LD_VAR 0 1
51243: PPUSH
51244: EMPTY
51245: PPUSH
51246: CALL_OW 1
51250: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51251: LD_ADDR_EXP 75
51255: PUSH
51256: LD_EXP 75
51260: PPUSH
51261: LD_VAR 0 1
51265: PPUSH
51266: EMPTY
51267: PPUSH
51268: CALL_OW 1
51272: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51273: LD_ADDR_EXP 76
51277: PUSH
51278: LD_EXP 76
51282: PPUSH
51283: LD_VAR 0 1
51287: PPUSH
51288: EMPTY
51289: PPUSH
51290: CALL_OW 1
51294: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51295: LD_ADDR_EXP 77
51299: PUSH
51300: LD_EXP 77
51304: PPUSH
51305: LD_VAR 0 1
51309: PPUSH
51310: LD_INT 0
51312: PPUSH
51313: CALL_OW 1
51317: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51318: LD_ADDR_EXP 78
51322: PUSH
51323: LD_EXP 78
51327: PPUSH
51328: LD_VAR 0 1
51332: PPUSH
51333: EMPTY
51334: PPUSH
51335: CALL_OW 1
51339: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51340: LD_ADDR_EXP 79
51344: PUSH
51345: LD_EXP 79
51349: PPUSH
51350: LD_VAR 0 1
51354: PPUSH
51355: EMPTY
51356: PPUSH
51357: CALL_OW 1
51361: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51362: LD_ADDR_EXP 80
51366: PUSH
51367: LD_EXP 80
51371: PPUSH
51372: LD_VAR 0 1
51376: PPUSH
51377: EMPTY
51378: PPUSH
51379: CALL_OW 1
51383: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51384: LD_ADDR_EXP 81
51388: PUSH
51389: LD_EXP 81
51393: PPUSH
51394: LD_VAR 0 1
51398: PPUSH
51399: EMPTY
51400: PPUSH
51401: CALL_OW 1
51405: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51406: LD_ADDR_EXP 82
51410: PUSH
51411: LD_EXP 82
51415: PPUSH
51416: LD_VAR 0 1
51420: PPUSH
51421: EMPTY
51422: PPUSH
51423: CALL_OW 1
51427: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51428: LD_ADDR_EXP 83
51432: PUSH
51433: LD_EXP 83
51437: PPUSH
51438: LD_VAR 0 1
51442: PPUSH
51443: EMPTY
51444: PPUSH
51445: CALL_OW 1
51449: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51450: LD_ADDR_EXP 84
51454: PUSH
51455: LD_EXP 84
51459: PPUSH
51460: LD_VAR 0 1
51464: PPUSH
51465: EMPTY
51466: PPUSH
51467: CALL_OW 1
51471: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51472: LD_ADDR_EXP 85
51476: PUSH
51477: LD_EXP 85
51481: PPUSH
51482: LD_VAR 0 1
51486: PPUSH
51487: EMPTY
51488: PPUSH
51489: CALL_OW 1
51493: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51494: LD_ADDR_EXP 86
51498: PUSH
51499: LD_EXP 86
51503: PPUSH
51504: LD_VAR 0 1
51508: PPUSH
51509: EMPTY
51510: PPUSH
51511: CALL_OW 1
51515: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51516: LD_ADDR_EXP 87
51520: PUSH
51521: LD_EXP 87
51525: PPUSH
51526: LD_VAR 0 1
51530: PPUSH
51531: EMPTY
51532: PPUSH
51533: CALL_OW 1
51537: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51538: LD_ADDR_EXP 88
51542: PUSH
51543: LD_EXP 88
51547: PPUSH
51548: LD_VAR 0 1
51552: PPUSH
51553: EMPTY
51554: PPUSH
51555: CALL_OW 1
51559: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51560: LD_ADDR_EXP 89
51564: PUSH
51565: LD_EXP 89
51569: PPUSH
51570: LD_VAR 0 1
51574: PPUSH
51575: EMPTY
51576: PPUSH
51577: CALL_OW 1
51581: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51582: LD_ADDR_EXP 90
51586: PUSH
51587: LD_EXP 90
51591: PPUSH
51592: LD_VAR 0 1
51596: PPUSH
51597: EMPTY
51598: PPUSH
51599: CALL_OW 1
51603: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51604: LD_ADDR_EXP 91
51608: PUSH
51609: LD_EXP 91
51613: PPUSH
51614: LD_VAR 0 1
51618: PPUSH
51619: EMPTY
51620: PPUSH
51621: CALL_OW 1
51625: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51626: LD_ADDR_EXP 93
51630: PUSH
51631: LD_EXP 93
51635: PPUSH
51636: LD_VAR 0 1
51640: PPUSH
51641: EMPTY
51642: PPUSH
51643: CALL_OW 1
51647: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51648: LD_ADDR_EXP 95
51652: PUSH
51653: LD_EXP 95
51657: PPUSH
51658: LD_VAR 0 1
51662: PPUSH
51663: EMPTY
51664: PPUSH
51665: CALL_OW 1
51669: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51670: LD_ADDR_EXP 96
51674: PUSH
51675: LD_EXP 96
51679: PPUSH
51680: LD_VAR 0 1
51684: PPUSH
51685: EMPTY
51686: PPUSH
51687: CALL_OW 1
51691: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51692: LD_ADDR_EXP 97
51696: PUSH
51697: LD_EXP 97
51701: PPUSH
51702: LD_VAR 0 1
51706: PPUSH
51707: EMPTY
51708: PPUSH
51709: CALL_OW 1
51713: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51714: LD_ADDR_EXP 98
51718: PUSH
51719: LD_EXP 98
51723: PPUSH
51724: LD_VAR 0 1
51728: PPUSH
51729: EMPTY
51730: PPUSH
51731: CALL_OW 1
51735: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51736: LD_ADDR_EXP 99
51740: PUSH
51741: LD_EXP 99
51745: PPUSH
51746: LD_VAR 0 1
51750: PPUSH
51751: EMPTY
51752: PPUSH
51753: CALL_OW 1
51757: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51758: LD_ADDR_EXP 100
51762: PUSH
51763: LD_EXP 100
51767: PPUSH
51768: LD_VAR 0 1
51772: PPUSH
51773: EMPTY
51774: PPUSH
51775: CALL_OW 1
51779: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51780: LD_ADDR_EXP 101
51784: PUSH
51785: LD_EXP 101
51789: PPUSH
51790: LD_VAR 0 1
51794: PPUSH
51795: EMPTY
51796: PPUSH
51797: CALL_OW 1
51801: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51802: LD_ADDR_EXP 102
51806: PUSH
51807: LD_EXP 102
51811: PPUSH
51812: LD_VAR 0 1
51816: PPUSH
51817: EMPTY
51818: PPUSH
51819: CALL_OW 1
51823: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51824: LD_ADDR_EXP 103
51828: PUSH
51829: LD_EXP 103
51833: PPUSH
51834: LD_VAR 0 1
51838: PPUSH
51839: EMPTY
51840: PPUSH
51841: CALL_OW 1
51845: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51846: LD_ADDR_EXP 104
51850: PUSH
51851: LD_EXP 104
51855: PPUSH
51856: LD_VAR 0 1
51860: PPUSH
51861: EMPTY
51862: PPUSH
51863: CALL_OW 1
51867: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51868: LD_ADDR_EXP 105
51872: PUSH
51873: LD_EXP 105
51877: PPUSH
51878: LD_VAR 0 1
51882: PPUSH
51883: EMPTY
51884: PPUSH
51885: CALL_OW 1
51889: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51890: LD_ADDR_EXP 106
51894: PUSH
51895: LD_EXP 106
51899: PPUSH
51900: LD_VAR 0 1
51904: PPUSH
51905: EMPTY
51906: PPUSH
51907: CALL_OW 1
51911: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51912: LD_ADDR_EXP 107
51916: PUSH
51917: LD_EXP 107
51921: PPUSH
51922: LD_VAR 0 1
51926: PPUSH
51927: EMPTY
51928: PPUSH
51929: CALL_OW 1
51933: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51934: LD_ADDR_EXP 108
51938: PUSH
51939: LD_EXP 108
51943: PPUSH
51944: LD_VAR 0 1
51948: PPUSH
51949: LD_INT 0
51951: PPUSH
51952: CALL_OW 1
51956: ST_TO_ADDR
// end ;
51957: LD_VAR 0 2
51961: RET
// export function MC_Add ( side , units ) ; var base ; begin
51962: LD_INT 0
51964: PPUSH
51965: PPUSH
// base := mc_bases + 1 ;
51966: LD_ADDR_VAR 0 4
51970: PUSH
51971: LD_EXP 66
51975: PUSH
51976: LD_INT 1
51978: PLUS
51979: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51980: LD_ADDR_EXP 92
51984: PUSH
51985: LD_EXP 92
51989: PPUSH
51990: LD_VAR 0 4
51994: PPUSH
51995: LD_VAR 0 1
51999: PPUSH
52000: CALL_OW 1
52004: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52005: LD_ADDR_EXP 66
52009: PUSH
52010: LD_EXP 66
52014: PPUSH
52015: LD_VAR 0 4
52019: PPUSH
52020: LD_VAR 0 2
52024: PPUSH
52025: CALL_OW 1
52029: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52030: LD_ADDR_EXP 67
52034: PUSH
52035: LD_EXP 67
52039: PPUSH
52040: LD_VAR 0 4
52044: PPUSH
52045: EMPTY
52046: PPUSH
52047: CALL_OW 1
52051: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52052: LD_ADDR_EXP 68
52056: PUSH
52057: LD_EXP 68
52061: PPUSH
52062: LD_VAR 0 4
52066: PPUSH
52067: EMPTY
52068: PPUSH
52069: CALL_OW 1
52073: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52074: LD_ADDR_EXP 69
52078: PUSH
52079: LD_EXP 69
52083: PPUSH
52084: LD_VAR 0 4
52088: PPUSH
52089: EMPTY
52090: PPUSH
52091: CALL_OW 1
52095: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52096: LD_ADDR_EXP 70
52100: PUSH
52101: LD_EXP 70
52105: PPUSH
52106: LD_VAR 0 4
52110: PPUSH
52111: EMPTY
52112: PPUSH
52113: CALL_OW 1
52117: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52118: LD_ADDR_EXP 71
52122: PUSH
52123: LD_EXP 71
52127: PPUSH
52128: LD_VAR 0 4
52132: PPUSH
52133: EMPTY
52134: PPUSH
52135: CALL_OW 1
52139: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52140: LD_ADDR_EXP 72
52144: PUSH
52145: LD_EXP 72
52149: PPUSH
52150: LD_VAR 0 4
52154: PPUSH
52155: EMPTY
52156: PPUSH
52157: CALL_OW 1
52161: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52162: LD_ADDR_EXP 73
52166: PUSH
52167: LD_EXP 73
52171: PPUSH
52172: LD_VAR 0 4
52176: PPUSH
52177: EMPTY
52178: PPUSH
52179: CALL_OW 1
52183: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52184: LD_ADDR_EXP 74
52188: PUSH
52189: LD_EXP 74
52193: PPUSH
52194: LD_VAR 0 4
52198: PPUSH
52199: EMPTY
52200: PPUSH
52201: CALL_OW 1
52205: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52206: LD_ADDR_EXP 75
52210: PUSH
52211: LD_EXP 75
52215: PPUSH
52216: LD_VAR 0 4
52220: PPUSH
52221: EMPTY
52222: PPUSH
52223: CALL_OW 1
52227: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52228: LD_ADDR_EXP 76
52232: PUSH
52233: LD_EXP 76
52237: PPUSH
52238: LD_VAR 0 4
52242: PPUSH
52243: EMPTY
52244: PPUSH
52245: CALL_OW 1
52249: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52250: LD_ADDR_EXP 77
52254: PUSH
52255: LD_EXP 77
52259: PPUSH
52260: LD_VAR 0 4
52264: PPUSH
52265: LD_INT 0
52267: PPUSH
52268: CALL_OW 1
52272: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52273: LD_ADDR_EXP 78
52277: PUSH
52278: LD_EXP 78
52282: PPUSH
52283: LD_VAR 0 4
52287: PPUSH
52288: EMPTY
52289: PPUSH
52290: CALL_OW 1
52294: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52295: LD_ADDR_EXP 79
52299: PUSH
52300: LD_EXP 79
52304: PPUSH
52305: LD_VAR 0 4
52309: PPUSH
52310: EMPTY
52311: PPUSH
52312: CALL_OW 1
52316: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52317: LD_ADDR_EXP 80
52321: PUSH
52322: LD_EXP 80
52326: PPUSH
52327: LD_VAR 0 4
52331: PPUSH
52332: EMPTY
52333: PPUSH
52334: CALL_OW 1
52338: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52339: LD_ADDR_EXP 81
52343: PUSH
52344: LD_EXP 81
52348: PPUSH
52349: LD_VAR 0 4
52353: PPUSH
52354: EMPTY
52355: PPUSH
52356: CALL_OW 1
52360: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52361: LD_ADDR_EXP 82
52365: PUSH
52366: LD_EXP 82
52370: PPUSH
52371: LD_VAR 0 4
52375: PPUSH
52376: EMPTY
52377: PPUSH
52378: CALL_OW 1
52382: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52383: LD_ADDR_EXP 83
52387: PUSH
52388: LD_EXP 83
52392: PPUSH
52393: LD_VAR 0 4
52397: PPUSH
52398: EMPTY
52399: PPUSH
52400: CALL_OW 1
52404: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52405: LD_ADDR_EXP 84
52409: PUSH
52410: LD_EXP 84
52414: PPUSH
52415: LD_VAR 0 4
52419: PPUSH
52420: EMPTY
52421: PPUSH
52422: CALL_OW 1
52426: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52427: LD_ADDR_EXP 85
52431: PUSH
52432: LD_EXP 85
52436: PPUSH
52437: LD_VAR 0 4
52441: PPUSH
52442: EMPTY
52443: PPUSH
52444: CALL_OW 1
52448: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52449: LD_ADDR_EXP 86
52453: PUSH
52454: LD_EXP 86
52458: PPUSH
52459: LD_VAR 0 4
52463: PPUSH
52464: EMPTY
52465: PPUSH
52466: CALL_OW 1
52470: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52471: LD_ADDR_EXP 87
52475: PUSH
52476: LD_EXP 87
52480: PPUSH
52481: LD_VAR 0 4
52485: PPUSH
52486: EMPTY
52487: PPUSH
52488: CALL_OW 1
52492: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52493: LD_ADDR_EXP 88
52497: PUSH
52498: LD_EXP 88
52502: PPUSH
52503: LD_VAR 0 4
52507: PPUSH
52508: EMPTY
52509: PPUSH
52510: CALL_OW 1
52514: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52515: LD_ADDR_EXP 89
52519: PUSH
52520: LD_EXP 89
52524: PPUSH
52525: LD_VAR 0 4
52529: PPUSH
52530: EMPTY
52531: PPUSH
52532: CALL_OW 1
52536: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52537: LD_ADDR_EXP 90
52541: PUSH
52542: LD_EXP 90
52546: PPUSH
52547: LD_VAR 0 4
52551: PPUSH
52552: EMPTY
52553: PPUSH
52554: CALL_OW 1
52558: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52559: LD_ADDR_EXP 91
52563: PUSH
52564: LD_EXP 91
52568: PPUSH
52569: LD_VAR 0 4
52573: PPUSH
52574: EMPTY
52575: PPUSH
52576: CALL_OW 1
52580: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52581: LD_ADDR_EXP 93
52585: PUSH
52586: LD_EXP 93
52590: PPUSH
52591: LD_VAR 0 4
52595: PPUSH
52596: EMPTY
52597: PPUSH
52598: CALL_OW 1
52602: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52603: LD_ADDR_EXP 95
52607: PUSH
52608: LD_EXP 95
52612: PPUSH
52613: LD_VAR 0 4
52617: PPUSH
52618: EMPTY
52619: PPUSH
52620: CALL_OW 1
52624: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52625: LD_ADDR_EXP 96
52629: PUSH
52630: LD_EXP 96
52634: PPUSH
52635: LD_VAR 0 4
52639: PPUSH
52640: EMPTY
52641: PPUSH
52642: CALL_OW 1
52646: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52647: LD_ADDR_EXP 97
52651: PUSH
52652: LD_EXP 97
52656: PPUSH
52657: LD_VAR 0 4
52661: PPUSH
52662: EMPTY
52663: PPUSH
52664: CALL_OW 1
52668: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52669: LD_ADDR_EXP 98
52673: PUSH
52674: LD_EXP 98
52678: PPUSH
52679: LD_VAR 0 4
52683: PPUSH
52684: EMPTY
52685: PPUSH
52686: CALL_OW 1
52690: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52691: LD_ADDR_EXP 99
52695: PUSH
52696: LD_EXP 99
52700: PPUSH
52701: LD_VAR 0 4
52705: PPUSH
52706: EMPTY
52707: PPUSH
52708: CALL_OW 1
52712: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52713: LD_ADDR_EXP 100
52717: PUSH
52718: LD_EXP 100
52722: PPUSH
52723: LD_VAR 0 4
52727: PPUSH
52728: EMPTY
52729: PPUSH
52730: CALL_OW 1
52734: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52735: LD_ADDR_EXP 101
52739: PUSH
52740: LD_EXP 101
52744: PPUSH
52745: LD_VAR 0 4
52749: PPUSH
52750: EMPTY
52751: PPUSH
52752: CALL_OW 1
52756: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52757: LD_ADDR_EXP 102
52761: PUSH
52762: LD_EXP 102
52766: PPUSH
52767: LD_VAR 0 4
52771: PPUSH
52772: EMPTY
52773: PPUSH
52774: CALL_OW 1
52778: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52779: LD_ADDR_EXP 103
52783: PUSH
52784: LD_EXP 103
52788: PPUSH
52789: LD_VAR 0 4
52793: PPUSH
52794: EMPTY
52795: PPUSH
52796: CALL_OW 1
52800: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52801: LD_ADDR_EXP 104
52805: PUSH
52806: LD_EXP 104
52810: PPUSH
52811: LD_VAR 0 4
52815: PPUSH
52816: EMPTY
52817: PPUSH
52818: CALL_OW 1
52822: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52823: LD_ADDR_EXP 105
52827: PUSH
52828: LD_EXP 105
52832: PPUSH
52833: LD_VAR 0 4
52837: PPUSH
52838: EMPTY
52839: PPUSH
52840: CALL_OW 1
52844: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52845: LD_ADDR_EXP 106
52849: PUSH
52850: LD_EXP 106
52854: PPUSH
52855: LD_VAR 0 4
52859: PPUSH
52860: EMPTY
52861: PPUSH
52862: CALL_OW 1
52866: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52867: LD_ADDR_EXP 107
52871: PUSH
52872: LD_EXP 107
52876: PPUSH
52877: LD_VAR 0 4
52881: PPUSH
52882: EMPTY
52883: PPUSH
52884: CALL_OW 1
52888: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52889: LD_ADDR_EXP 108
52893: PUSH
52894: LD_EXP 108
52898: PPUSH
52899: LD_VAR 0 4
52903: PPUSH
52904: LD_INT 0
52906: PPUSH
52907: CALL_OW 1
52911: ST_TO_ADDR
// result := base ;
52912: LD_ADDR_VAR 0 3
52916: PUSH
52917: LD_VAR 0 4
52921: ST_TO_ADDR
// end ;
52922: LD_VAR 0 3
52926: RET
// export function MC_Start ( ) ; var i ; begin
52927: LD_INT 0
52929: PPUSH
52930: PPUSH
// for i = 1 to mc_bases do
52931: LD_ADDR_VAR 0 2
52935: PUSH
52936: DOUBLE
52937: LD_INT 1
52939: DEC
52940: ST_TO_ADDR
52941: LD_EXP 66
52945: PUSH
52946: FOR_TO
52947: IFFALSE 54024
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52949: LD_ADDR_EXP 66
52953: PUSH
52954: LD_EXP 66
52958: PPUSH
52959: LD_VAR 0 2
52963: PPUSH
52964: LD_EXP 66
52968: PUSH
52969: LD_VAR 0 2
52973: ARRAY
52974: PUSH
52975: LD_INT 0
52977: DIFF
52978: PPUSH
52979: CALL_OW 1
52983: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52984: LD_ADDR_EXP 67
52988: PUSH
52989: LD_EXP 67
52993: PPUSH
52994: LD_VAR 0 2
52998: PPUSH
52999: EMPTY
53000: PPUSH
53001: CALL_OW 1
53005: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53006: LD_ADDR_EXP 68
53010: PUSH
53011: LD_EXP 68
53015: PPUSH
53016: LD_VAR 0 2
53020: PPUSH
53021: EMPTY
53022: PPUSH
53023: CALL_OW 1
53027: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53028: LD_ADDR_EXP 69
53032: PUSH
53033: LD_EXP 69
53037: PPUSH
53038: LD_VAR 0 2
53042: PPUSH
53043: EMPTY
53044: PPUSH
53045: CALL_OW 1
53049: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53050: LD_ADDR_EXP 70
53054: PUSH
53055: LD_EXP 70
53059: PPUSH
53060: LD_VAR 0 2
53064: PPUSH
53065: EMPTY
53066: PUSH
53067: EMPTY
53068: PUSH
53069: EMPTY
53070: LIST
53071: LIST
53072: PPUSH
53073: CALL_OW 1
53077: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53078: LD_ADDR_EXP 71
53082: PUSH
53083: LD_EXP 71
53087: PPUSH
53088: LD_VAR 0 2
53092: PPUSH
53093: EMPTY
53094: PPUSH
53095: CALL_OW 1
53099: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53100: LD_ADDR_EXP 98
53104: PUSH
53105: LD_EXP 98
53109: PPUSH
53110: LD_VAR 0 2
53114: PPUSH
53115: EMPTY
53116: PPUSH
53117: CALL_OW 1
53121: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53122: LD_ADDR_EXP 72
53126: PUSH
53127: LD_EXP 72
53131: PPUSH
53132: LD_VAR 0 2
53136: PPUSH
53137: EMPTY
53138: PPUSH
53139: CALL_OW 1
53143: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53144: LD_ADDR_EXP 73
53148: PUSH
53149: LD_EXP 73
53153: PPUSH
53154: LD_VAR 0 2
53158: PPUSH
53159: EMPTY
53160: PPUSH
53161: CALL_OW 1
53165: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53166: LD_ADDR_EXP 74
53170: PUSH
53171: LD_EXP 74
53175: PPUSH
53176: LD_VAR 0 2
53180: PPUSH
53181: LD_EXP 66
53185: PUSH
53186: LD_VAR 0 2
53190: ARRAY
53191: PPUSH
53192: LD_INT 2
53194: PUSH
53195: LD_INT 30
53197: PUSH
53198: LD_INT 32
53200: PUSH
53201: EMPTY
53202: LIST
53203: LIST
53204: PUSH
53205: LD_INT 30
53207: PUSH
53208: LD_INT 33
53210: PUSH
53211: EMPTY
53212: LIST
53213: LIST
53214: PUSH
53215: EMPTY
53216: LIST
53217: LIST
53218: LIST
53219: PPUSH
53220: CALL_OW 72
53224: PPUSH
53225: CALL_OW 1
53229: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53230: LD_ADDR_EXP 75
53234: PUSH
53235: LD_EXP 75
53239: PPUSH
53240: LD_VAR 0 2
53244: PPUSH
53245: LD_EXP 66
53249: PUSH
53250: LD_VAR 0 2
53254: ARRAY
53255: PPUSH
53256: LD_INT 2
53258: PUSH
53259: LD_INT 30
53261: PUSH
53262: LD_INT 32
53264: PUSH
53265: EMPTY
53266: LIST
53267: LIST
53268: PUSH
53269: LD_INT 30
53271: PUSH
53272: LD_INT 31
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: PUSH
53279: EMPTY
53280: LIST
53281: LIST
53282: LIST
53283: PUSH
53284: LD_INT 58
53286: PUSH
53287: EMPTY
53288: LIST
53289: PUSH
53290: EMPTY
53291: LIST
53292: LIST
53293: PPUSH
53294: CALL_OW 72
53298: PPUSH
53299: CALL_OW 1
53303: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53304: LD_ADDR_EXP 76
53308: PUSH
53309: LD_EXP 76
53313: PPUSH
53314: LD_VAR 0 2
53318: PPUSH
53319: EMPTY
53320: PPUSH
53321: CALL_OW 1
53325: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53326: LD_ADDR_EXP 80
53330: PUSH
53331: LD_EXP 80
53335: PPUSH
53336: LD_VAR 0 2
53340: PPUSH
53341: EMPTY
53342: PPUSH
53343: CALL_OW 1
53347: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53348: LD_ADDR_EXP 79
53352: PUSH
53353: LD_EXP 79
53357: PPUSH
53358: LD_VAR 0 2
53362: PPUSH
53363: EMPTY
53364: PPUSH
53365: CALL_OW 1
53369: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53370: LD_ADDR_EXP 81
53374: PUSH
53375: LD_EXP 81
53379: PPUSH
53380: LD_VAR 0 2
53384: PPUSH
53385: EMPTY
53386: PPUSH
53387: CALL_OW 1
53391: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53392: LD_ADDR_EXP 82
53396: PUSH
53397: LD_EXP 82
53401: PPUSH
53402: LD_VAR 0 2
53406: PPUSH
53407: EMPTY
53408: PPUSH
53409: CALL_OW 1
53413: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53414: LD_ADDR_EXP 83
53418: PUSH
53419: LD_EXP 83
53423: PPUSH
53424: LD_VAR 0 2
53428: PPUSH
53429: EMPTY
53430: PPUSH
53431: CALL_OW 1
53435: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53436: LD_ADDR_EXP 84
53440: PUSH
53441: LD_EXP 84
53445: PPUSH
53446: LD_VAR 0 2
53450: PPUSH
53451: EMPTY
53452: PPUSH
53453: CALL_OW 1
53457: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53458: LD_ADDR_EXP 85
53462: PUSH
53463: LD_EXP 85
53467: PPUSH
53468: LD_VAR 0 2
53472: PPUSH
53473: EMPTY
53474: PPUSH
53475: CALL_OW 1
53479: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53480: LD_ADDR_EXP 86
53484: PUSH
53485: LD_EXP 86
53489: PPUSH
53490: LD_VAR 0 2
53494: PPUSH
53495: EMPTY
53496: PPUSH
53497: CALL_OW 1
53501: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53502: LD_ADDR_EXP 87
53506: PUSH
53507: LD_EXP 87
53511: PPUSH
53512: LD_VAR 0 2
53516: PPUSH
53517: EMPTY
53518: PPUSH
53519: CALL_OW 1
53523: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53524: LD_ADDR_EXP 88
53528: PUSH
53529: LD_EXP 88
53533: PPUSH
53534: LD_VAR 0 2
53538: PPUSH
53539: EMPTY
53540: PPUSH
53541: CALL_OW 1
53545: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53546: LD_ADDR_EXP 77
53550: PUSH
53551: LD_EXP 77
53555: PPUSH
53556: LD_VAR 0 2
53560: PPUSH
53561: LD_INT 0
53563: PPUSH
53564: CALL_OW 1
53568: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53569: LD_ADDR_EXP 90
53573: PUSH
53574: LD_EXP 90
53578: PPUSH
53579: LD_VAR 0 2
53583: PPUSH
53584: LD_INT 0
53586: PPUSH
53587: CALL_OW 1
53591: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53592: LD_ADDR_EXP 78
53596: PUSH
53597: LD_EXP 78
53601: PPUSH
53602: LD_VAR 0 2
53606: PPUSH
53607: EMPTY
53608: PPUSH
53609: CALL_OW 1
53613: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53614: LD_ADDR_EXP 89
53618: PUSH
53619: LD_EXP 89
53623: PPUSH
53624: LD_VAR 0 2
53628: PPUSH
53629: LD_INT 0
53631: PPUSH
53632: CALL_OW 1
53636: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53637: LD_ADDR_EXP 91
53641: PUSH
53642: LD_EXP 91
53646: PPUSH
53647: LD_VAR 0 2
53651: PPUSH
53652: EMPTY
53653: PPUSH
53654: CALL_OW 1
53658: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53659: LD_ADDR_EXP 94
53663: PUSH
53664: LD_EXP 94
53668: PPUSH
53669: LD_VAR 0 2
53673: PPUSH
53674: LD_INT 0
53676: PPUSH
53677: CALL_OW 1
53681: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53682: LD_ADDR_EXP 95
53686: PUSH
53687: LD_EXP 95
53691: PPUSH
53692: LD_VAR 0 2
53696: PPUSH
53697: EMPTY
53698: PPUSH
53699: CALL_OW 1
53703: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53704: LD_ADDR_EXP 96
53708: PUSH
53709: LD_EXP 96
53713: PPUSH
53714: LD_VAR 0 2
53718: PPUSH
53719: EMPTY
53720: PPUSH
53721: CALL_OW 1
53725: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53726: LD_ADDR_EXP 97
53730: PUSH
53731: LD_EXP 97
53735: PPUSH
53736: LD_VAR 0 2
53740: PPUSH
53741: EMPTY
53742: PPUSH
53743: CALL_OW 1
53747: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
53748: LD_ADDR_EXP 99
53752: PUSH
53753: LD_EXP 99
53757: PPUSH
53758: LD_VAR 0 2
53762: PPUSH
53763: LD_EXP 66
53767: PUSH
53768: LD_VAR 0 2
53772: ARRAY
53773: PPUSH
53774: LD_INT 2
53776: PUSH
53777: LD_INT 30
53779: PUSH
53780: LD_INT 6
53782: PUSH
53783: EMPTY
53784: LIST
53785: LIST
53786: PUSH
53787: LD_INT 30
53789: PUSH
53790: LD_INT 7
53792: PUSH
53793: EMPTY
53794: LIST
53795: LIST
53796: PUSH
53797: LD_INT 30
53799: PUSH
53800: LD_INT 8
53802: PUSH
53803: EMPTY
53804: LIST
53805: LIST
53806: PUSH
53807: EMPTY
53808: LIST
53809: LIST
53810: LIST
53811: LIST
53812: PPUSH
53813: CALL_OW 72
53817: PPUSH
53818: CALL_OW 1
53822: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53823: LD_ADDR_EXP 100
53827: PUSH
53828: LD_EXP 100
53832: PPUSH
53833: LD_VAR 0 2
53837: PPUSH
53838: EMPTY
53839: PPUSH
53840: CALL_OW 1
53844: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53845: LD_ADDR_EXP 101
53849: PUSH
53850: LD_EXP 101
53854: PPUSH
53855: LD_VAR 0 2
53859: PPUSH
53860: EMPTY
53861: PPUSH
53862: CALL_OW 1
53866: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53867: LD_ADDR_EXP 102
53871: PUSH
53872: LD_EXP 102
53876: PPUSH
53877: LD_VAR 0 2
53881: PPUSH
53882: EMPTY
53883: PPUSH
53884: CALL_OW 1
53888: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53889: LD_ADDR_EXP 103
53893: PUSH
53894: LD_EXP 103
53898: PPUSH
53899: LD_VAR 0 2
53903: PPUSH
53904: EMPTY
53905: PPUSH
53906: CALL_OW 1
53910: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53911: LD_ADDR_EXP 104
53915: PUSH
53916: LD_EXP 104
53920: PPUSH
53921: LD_VAR 0 2
53925: PPUSH
53926: EMPTY
53927: PPUSH
53928: CALL_OW 1
53932: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53933: LD_ADDR_EXP 105
53937: PUSH
53938: LD_EXP 105
53942: PPUSH
53943: LD_VAR 0 2
53947: PPUSH
53948: EMPTY
53949: PPUSH
53950: CALL_OW 1
53954: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53955: LD_ADDR_EXP 106
53959: PUSH
53960: LD_EXP 106
53964: PPUSH
53965: LD_VAR 0 2
53969: PPUSH
53970: EMPTY
53971: PPUSH
53972: CALL_OW 1
53976: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53977: LD_ADDR_EXP 107
53981: PUSH
53982: LD_EXP 107
53986: PPUSH
53987: LD_VAR 0 2
53991: PPUSH
53992: EMPTY
53993: PPUSH
53994: CALL_OW 1
53998: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53999: LD_ADDR_EXP 108
54003: PUSH
54004: LD_EXP 108
54008: PPUSH
54009: LD_VAR 0 2
54013: PPUSH
54014: LD_INT 0
54016: PPUSH
54017: CALL_OW 1
54021: ST_TO_ADDR
// end ;
54022: GO 52946
54024: POP
54025: POP
// MC_InitSides ( ) ;
54026: CALL 54312 0 0
// MC_InitResearch ( ) ;
54030: CALL 54051 0 0
// CustomInitMacro ( ) ;
54034: CALL 5753 0 0
// skirmish := true ;
54038: LD_ADDR_EXP 64
54042: PUSH
54043: LD_INT 1
54045: ST_TO_ADDR
// end ;
54046: LD_VAR 0 1
54050: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54051: LD_INT 0
54053: PPUSH
54054: PPUSH
54055: PPUSH
54056: PPUSH
54057: PPUSH
54058: PPUSH
// if not mc_bases then
54059: LD_EXP 66
54063: NOT
54064: IFFALSE 54068
// exit ;
54066: GO 54307
// for i = 1 to 8 do
54068: LD_ADDR_VAR 0 2
54072: PUSH
54073: DOUBLE
54074: LD_INT 1
54076: DEC
54077: ST_TO_ADDR
54078: LD_INT 8
54080: PUSH
54081: FOR_TO
54082: IFFALSE 54108
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54084: LD_ADDR_EXP 93
54088: PUSH
54089: LD_EXP 93
54093: PPUSH
54094: LD_VAR 0 2
54098: PPUSH
54099: EMPTY
54100: PPUSH
54101: CALL_OW 1
54105: ST_TO_ADDR
54106: GO 54081
54108: POP
54109: POP
// tmp := [ ] ;
54110: LD_ADDR_VAR 0 5
54114: PUSH
54115: EMPTY
54116: ST_TO_ADDR
// for i = 1 to mc_sides do
54117: LD_ADDR_VAR 0 2
54121: PUSH
54122: DOUBLE
54123: LD_INT 1
54125: DEC
54126: ST_TO_ADDR
54127: LD_EXP 92
54131: PUSH
54132: FOR_TO
54133: IFFALSE 54191
// if not mc_sides [ i ] in tmp then
54135: LD_EXP 92
54139: PUSH
54140: LD_VAR 0 2
54144: ARRAY
54145: PUSH
54146: LD_VAR 0 5
54150: IN
54151: NOT
54152: IFFALSE 54189
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54154: LD_ADDR_VAR 0 5
54158: PUSH
54159: LD_VAR 0 5
54163: PPUSH
54164: LD_VAR 0 5
54168: PUSH
54169: LD_INT 1
54171: PLUS
54172: PPUSH
54173: LD_EXP 92
54177: PUSH
54178: LD_VAR 0 2
54182: ARRAY
54183: PPUSH
54184: CALL_OW 2
54188: ST_TO_ADDR
54189: GO 54132
54191: POP
54192: POP
// if not tmp then
54193: LD_VAR 0 5
54197: NOT
54198: IFFALSE 54202
// exit ;
54200: GO 54307
// for j in tmp do
54202: LD_ADDR_VAR 0 3
54206: PUSH
54207: LD_VAR 0 5
54211: PUSH
54212: FOR_IN
54213: IFFALSE 54305
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54215: LD_ADDR_VAR 0 6
54219: PUSH
54220: LD_INT 22
54222: PUSH
54223: LD_VAR 0 3
54227: PUSH
54228: EMPTY
54229: LIST
54230: LIST
54231: PPUSH
54232: CALL_OW 69
54236: ST_TO_ADDR
// if not un then
54237: LD_VAR 0 6
54241: NOT
54242: IFFALSE 54246
// continue ;
54244: GO 54212
// nation := GetNation ( un [ 1 ] ) ;
54246: LD_ADDR_VAR 0 4
54250: PUSH
54251: LD_VAR 0 6
54255: PUSH
54256: LD_INT 1
54258: ARRAY
54259: PPUSH
54260: CALL_OW 248
54264: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54265: LD_ADDR_EXP 93
54269: PUSH
54270: LD_EXP 93
54274: PPUSH
54275: LD_VAR 0 3
54279: PPUSH
54280: LD_VAR 0 3
54284: PPUSH
54285: LD_VAR 0 4
54289: PPUSH
54290: LD_INT 1
54292: PPUSH
54293: CALL 13665 0 3
54297: PPUSH
54298: CALL_OW 1
54302: ST_TO_ADDR
// end ;
54303: GO 54212
54305: POP
54306: POP
// end ;
54307: LD_VAR 0 1
54311: RET
// export function MC_InitSides ( ) ; var i ; begin
54312: LD_INT 0
54314: PPUSH
54315: PPUSH
// if not mc_bases then
54316: LD_EXP 66
54320: NOT
54321: IFFALSE 54325
// exit ;
54323: GO 54399
// for i = 1 to mc_bases do
54325: LD_ADDR_VAR 0 2
54329: PUSH
54330: DOUBLE
54331: LD_INT 1
54333: DEC
54334: ST_TO_ADDR
54335: LD_EXP 66
54339: PUSH
54340: FOR_TO
54341: IFFALSE 54397
// if mc_bases [ i ] then
54343: LD_EXP 66
54347: PUSH
54348: LD_VAR 0 2
54352: ARRAY
54353: IFFALSE 54395
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54355: LD_ADDR_EXP 92
54359: PUSH
54360: LD_EXP 92
54364: PPUSH
54365: LD_VAR 0 2
54369: PPUSH
54370: LD_EXP 66
54374: PUSH
54375: LD_VAR 0 2
54379: ARRAY
54380: PUSH
54381: LD_INT 1
54383: ARRAY
54384: PPUSH
54385: CALL_OW 255
54389: PPUSH
54390: CALL_OW 1
54394: ST_TO_ADDR
54395: GO 54340
54397: POP
54398: POP
// end ;
54399: LD_VAR 0 1
54403: RET
// every 0 0$01 trigger skirmish do
54404: LD_EXP 64
54408: IFFALSE 54562
54410: GO 54412
54412: DISABLE
// begin enable ;
54413: ENABLE
// MC_CheckBuildings ( ) ;
54414: CALL 59060 0 0
// MC_CheckPeopleLife ( ) ;
54418: CALL 59185 0 0
// RaiseSailEvent ( 100 ) ;
54422: LD_INT 100
54424: PPUSH
54425: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54429: LD_INT 103
54431: PPUSH
54432: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54436: LD_INT 104
54438: PPUSH
54439: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54443: LD_INT 105
54445: PPUSH
54446: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54450: LD_INT 106
54452: PPUSH
54453: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54457: LD_INT 107
54459: PPUSH
54460: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54464: LD_INT 108
54466: PPUSH
54467: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54471: LD_INT 109
54473: PPUSH
54474: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54478: LD_INT 110
54480: PPUSH
54481: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54485: LD_INT 111
54487: PPUSH
54488: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54492: LD_INT 112
54494: PPUSH
54495: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54499: LD_INT 113
54501: PPUSH
54502: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54506: LD_INT 120
54508: PPUSH
54509: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54513: LD_INT 121
54515: PPUSH
54516: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54520: LD_INT 122
54522: PPUSH
54523: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54527: LD_INT 123
54529: PPUSH
54530: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54534: LD_INT 124
54536: PPUSH
54537: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54541: LD_INT 125
54543: PPUSH
54544: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54548: LD_INT 126
54550: PPUSH
54551: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54555: LD_INT 200
54557: PPUSH
54558: CALL_OW 427
// end ;
54562: END
// on SailEvent ( event ) do begin if event < 100 then
54563: LD_VAR 0 1
54567: PUSH
54568: LD_INT 100
54570: LESS
54571: IFFALSE 54582
// CustomEvent ( event ) ;
54573: LD_VAR 0 1
54577: PPUSH
54578: CALL 5745 0 1
// if event = 100 then
54582: LD_VAR 0 1
54586: PUSH
54587: LD_INT 100
54589: EQUAL
54590: IFFALSE 54596
// MC_ClassManager ( ) ;
54592: CALL 54988 0 0
// if event = 101 then
54596: LD_VAR 0 1
54600: PUSH
54601: LD_INT 101
54603: EQUAL
54604: IFFALSE 54610
// MC_RepairBuildings ( ) ;
54606: CALL 59770 0 0
// if event = 102 then
54610: LD_VAR 0 1
54614: PUSH
54615: LD_INT 102
54617: EQUAL
54618: IFFALSE 54624
// MC_Heal ( ) ;
54620: CALL 60655 0 0
// if event = 103 then
54624: LD_VAR 0 1
54628: PUSH
54629: LD_INT 103
54631: EQUAL
54632: IFFALSE 54638
// MC_Build ( ) ;
54634: CALL 61077 0 0
// if event = 104 then
54638: LD_VAR 0 1
54642: PUSH
54643: LD_INT 104
54645: EQUAL
54646: IFFALSE 54652
// MC_TurretWeapon ( ) ;
54648: CALL 62690 0 0
// if event = 105 then
54652: LD_VAR 0 1
54656: PUSH
54657: LD_INT 105
54659: EQUAL
54660: IFFALSE 54666
// MC_BuildUpgrade ( ) ;
54662: CALL 62241 0 0
// if event = 106 then
54666: LD_VAR 0 1
54670: PUSH
54671: LD_INT 106
54673: EQUAL
54674: IFFALSE 54680
// MC_PlantMines ( ) ;
54676: CALL 63120 0 0
// if event = 107 then
54680: LD_VAR 0 1
54684: PUSH
54685: LD_INT 107
54687: EQUAL
54688: IFFALSE 54694
// MC_CollectCrates ( ) ;
54690: CALL 63918 0 0
// if event = 108 then
54694: LD_VAR 0 1
54698: PUSH
54699: LD_INT 108
54701: EQUAL
54702: IFFALSE 54708
// MC_LinkRemoteControl ( ) ;
54704: CALL 65694 0 0
// if event = 109 then
54708: LD_VAR 0 1
54712: PUSH
54713: LD_INT 109
54715: EQUAL
54716: IFFALSE 54722
// MC_ProduceVehicle ( ) ;
54718: CALL 65875 0 0
// if event = 110 then
54722: LD_VAR 0 1
54726: PUSH
54727: LD_INT 110
54729: EQUAL
54730: IFFALSE 54736
// MC_SendAttack ( ) ;
54732: CALL 66341 0 0
// if event = 111 then
54736: LD_VAR 0 1
54740: PUSH
54741: LD_INT 111
54743: EQUAL
54744: IFFALSE 54750
// MC_Defend ( ) ;
54746: CALL 66449 0 0
// if event = 112 then
54750: LD_VAR 0 1
54754: PUSH
54755: LD_INT 112
54757: EQUAL
54758: IFFALSE 54764
// MC_Research ( ) ;
54760: CALL 67076 0 0
// if event = 113 then
54764: LD_VAR 0 1
54768: PUSH
54769: LD_INT 113
54771: EQUAL
54772: IFFALSE 54778
// MC_MinesTrigger ( ) ;
54774: CALL 68190 0 0
// if event = 120 then
54778: LD_VAR 0 1
54782: PUSH
54783: LD_INT 120
54785: EQUAL
54786: IFFALSE 54792
// MC_RepairVehicle ( ) ;
54788: CALL 68289 0 0
// if event = 121 then
54792: LD_VAR 0 1
54796: PUSH
54797: LD_INT 121
54799: EQUAL
54800: IFFALSE 54806
// MC_TameApe ( ) ;
54802: CALL 69019 0 0
// if event = 122 then
54806: LD_VAR 0 1
54810: PUSH
54811: LD_INT 122
54813: EQUAL
54814: IFFALSE 54820
// MC_ChangeApeClass ( ) ;
54816: CALL 69848 0 0
// if event = 123 then
54820: LD_VAR 0 1
54824: PUSH
54825: LD_INT 123
54827: EQUAL
54828: IFFALSE 54834
// MC_Bazooka ( ) ;
54830: CALL 70498 0 0
// if event = 124 then
54834: LD_VAR 0 1
54838: PUSH
54839: LD_INT 124
54841: EQUAL
54842: IFFALSE 54848
// MC_TeleportExit ( ) ;
54844: CALL 70696 0 0
// if event = 125 then
54848: LD_VAR 0 1
54852: PUSH
54853: LD_INT 125
54855: EQUAL
54856: IFFALSE 54862
// MC_Deposits ( ) ;
54858: CALL 71343 0 0
// if event = 126 then
54862: LD_VAR 0 1
54866: PUSH
54867: LD_INT 126
54869: EQUAL
54870: IFFALSE 54876
// MC_RemoteDriver ( ) ;
54872: CALL 71968 0 0
// if event = 200 then
54876: LD_VAR 0 1
54880: PUSH
54881: LD_INT 200
54883: EQUAL
54884: IFFALSE 54890
// MC_Idle ( ) ;
54886: CALL 73917 0 0
// end ;
54890: PPOPN 1
54892: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54893: LD_INT 0
54895: PPUSH
54896: PPUSH
// if not mc_bases [ base ] or not tag then
54897: LD_EXP 66
54901: PUSH
54902: LD_VAR 0 1
54906: ARRAY
54907: NOT
54908: PUSH
54909: LD_VAR 0 2
54913: NOT
54914: OR
54915: IFFALSE 54919
// exit ;
54917: GO 54983
// for i in mc_bases [ base ] union mc_ape [ base ] do
54919: LD_ADDR_VAR 0 4
54923: PUSH
54924: LD_EXP 66
54928: PUSH
54929: LD_VAR 0 1
54933: ARRAY
54934: PUSH
54935: LD_EXP 95
54939: PUSH
54940: LD_VAR 0 1
54944: ARRAY
54945: UNION
54946: PUSH
54947: FOR_IN
54948: IFFALSE 54981
// if GetTag ( i ) = tag then
54950: LD_VAR 0 4
54954: PPUSH
54955: CALL_OW 110
54959: PUSH
54960: LD_VAR 0 2
54964: EQUAL
54965: IFFALSE 54979
// SetTag ( i , 0 ) ;
54967: LD_VAR 0 4
54971: PPUSH
54972: LD_INT 0
54974: PPUSH
54975: CALL_OW 109
54979: GO 54947
54981: POP
54982: POP
// end ;
54983: LD_VAR 0 3
54987: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54988: LD_INT 0
54990: PPUSH
54991: PPUSH
54992: PPUSH
54993: PPUSH
54994: PPUSH
54995: PPUSH
54996: PPUSH
54997: PPUSH
// if not mc_bases then
54998: LD_EXP 66
55002: NOT
55003: IFFALSE 55007
// exit ;
55005: GO 55465
// for i = 1 to mc_bases do
55007: LD_ADDR_VAR 0 2
55011: PUSH
55012: DOUBLE
55013: LD_INT 1
55015: DEC
55016: ST_TO_ADDR
55017: LD_EXP 66
55021: PUSH
55022: FOR_TO
55023: IFFALSE 55463
// begin tmp := MC_ClassCheckReq ( i ) ;
55025: LD_ADDR_VAR 0 4
55029: PUSH
55030: LD_VAR 0 2
55034: PPUSH
55035: CALL 55470 0 1
55039: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55040: LD_ADDR_EXP 107
55044: PUSH
55045: LD_EXP 107
55049: PPUSH
55050: LD_VAR 0 2
55054: PPUSH
55055: LD_VAR 0 4
55059: PPUSH
55060: CALL_OW 1
55064: ST_TO_ADDR
// if not tmp then
55065: LD_VAR 0 4
55069: NOT
55070: IFFALSE 55074
// continue ;
55072: GO 55022
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55074: LD_ADDR_VAR 0 6
55078: PUSH
55079: LD_EXP 66
55083: PUSH
55084: LD_VAR 0 2
55088: ARRAY
55089: PPUSH
55090: LD_INT 2
55092: PUSH
55093: LD_INT 30
55095: PUSH
55096: LD_INT 4
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: PUSH
55103: LD_INT 30
55105: PUSH
55106: LD_INT 5
55108: PUSH
55109: EMPTY
55110: LIST
55111: LIST
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: LIST
55117: PPUSH
55118: CALL_OW 72
55122: PUSH
55123: LD_EXP 66
55127: PUSH
55128: LD_VAR 0 2
55132: ARRAY
55133: PPUSH
55134: LD_INT 2
55136: PUSH
55137: LD_INT 30
55139: PUSH
55140: LD_INT 0
55142: PUSH
55143: EMPTY
55144: LIST
55145: LIST
55146: PUSH
55147: LD_INT 30
55149: PUSH
55150: LD_INT 1
55152: PUSH
55153: EMPTY
55154: LIST
55155: LIST
55156: PUSH
55157: EMPTY
55158: LIST
55159: LIST
55160: LIST
55161: PPUSH
55162: CALL_OW 72
55166: PUSH
55167: LD_EXP 66
55171: PUSH
55172: LD_VAR 0 2
55176: ARRAY
55177: PPUSH
55178: LD_INT 30
55180: PUSH
55181: LD_INT 3
55183: PUSH
55184: EMPTY
55185: LIST
55186: LIST
55187: PPUSH
55188: CALL_OW 72
55192: PUSH
55193: LD_EXP 66
55197: PUSH
55198: LD_VAR 0 2
55202: ARRAY
55203: PPUSH
55204: LD_INT 2
55206: PUSH
55207: LD_INT 30
55209: PUSH
55210: LD_INT 6
55212: PUSH
55213: EMPTY
55214: LIST
55215: LIST
55216: PUSH
55217: LD_INT 30
55219: PUSH
55220: LD_INT 7
55222: PUSH
55223: EMPTY
55224: LIST
55225: LIST
55226: PUSH
55227: LD_INT 30
55229: PUSH
55230: LD_INT 8
55232: PUSH
55233: EMPTY
55234: LIST
55235: LIST
55236: PUSH
55237: EMPTY
55238: LIST
55239: LIST
55240: LIST
55241: LIST
55242: PPUSH
55243: CALL_OW 72
55247: PUSH
55248: EMPTY
55249: LIST
55250: LIST
55251: LIST
55252: LIST
55253: ST_TO_ADDR
// for j = 1 to 4 do
55254: LD_ADDR_VAR 0 3
55258: PUSH
55259: DOUBLE
55260: LD_INT 1
55262: DEC
55263: ST_TO_ADDR
55264: LD_INT 4
55266: PUSH
55267: FOR_TO
55268: IFFALSE 55459
// begin if not tmp [ j ] then
55270: LD_VAR 0 4
55274: PUSH
55275: LD_VAR 0 3
55279: ARRAY
55280: NOT
55281: IFFALSE 55285
// continue ;
55283: GO 55267
// for p in tmp [ j ] do
55285: LD_ADDR_VAR 0 5
55289: PUSH
55290: LD_VAR 0 4
55294: PUSH
55295: LD_VAR 0 3
55299: ARRAY
55300: PUSH
55301: FOR_IN
55302: IFFALSE 55455
// begin if not b [ j ] then
55304: LD_VAR 0 6
55308: PUSH
55309: LD_VAR 0 3
55313: ARRAY
55314: NOT
55315: IFFALSE 55319
// break ;
55317: GO 55455
// e := 0 ;
55319: LD_ADDR_VAR 0 7
55323: PUSH
55324: LD_INT 0
55326: ST_TO_ADDR
// for k in b [ j ] do
55327: LD_ADDR_VAR 0 8
55331: PUSH
55332: LD_VAR 0 6
55336: PUSH
55337: LD_VAR 0 3
55341: ARRAY
55342: PUSH
55343: FOR_IN
55344: IFFALSE 55371
// if IsNotFull ( k ) then
55346: LD_VAR 0 8
55350: PPUSH
55351: CALL 15814 0 1
55355: IFFALSE 55369
// begin e := k ;
55357: LD_ADDR_VAR 0 7
55361: PUSH
55362: LD_VAR 0 8
55366: ST_TO_ADDR
// break ;
55367: GO 55371
// end ;
55369: GO 55343
55371: POP
55372: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55373: LD_VAR 0 7
55377: PUSH
55378: LD_VAR 0 5
55382: PPUSH
55383: LD_VAR 0 7
55387: PPUSH
55388: CALL 48234 0 2
55392: NOT
55393: AND
55394: IFFALSE 55453
// begin if IsInUnit ( p ) then
55396: LD_VAR 0 5
55400: PPUSH
55401: CALL_OW 310
55405: IFFALSE 55416
// ComExitBuilding ( p ) ;
55407: LD_VAR 0 5
55411: PPUSH
55412: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55416: LD_VAR 0 5
55420: PPUSH
55421: LD_VAR 0 7
55425: PPUSH
55426: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55430: LD_VAR 0 5
55434: PPUSH
55435: LD_VAR 0 3
55439: PPUSH
55440: CALL_OW 183
// AddComExitBuilding ( p ) ;
55444: LD_VAR 0 5
55448: PPUSH
55449: CALL_OW 182
// end ; end ;
55453: GO 55301
55455: POP
55456: POP
// end ;
55457: GO 55267
55459: POP
55460: POP
// end ;
55461: GO 55022
55463: POP
55464: POP
// end ;
55465: LD_VAR 0 1
55469: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55470: LD_INT 0
55472: PPUSH
55473: PPUSH
55474: PPUSH
55475: PPUSH
55476: PPUSH
55477: PPUSH
55478: PPUSH
55479: PPUSH
55480: PPUSH
55481: PPUSH
55482: PPUSH
55483: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55484: LD_VAR 0 1
55488: NOT
55489: PUSH
55490: LD_EXP 66
55494: PUSH
55495: LD_VAR 0 1
55499: ARRAY
55500: NOT
55501: OR
55502: PUSH
55503: LD_EXP 66
55507: PUSH
55508: LD_VAR 0 1
55512: ARRAY
55513: PPUSH
55514: LD_INT 2
55516: PUSH
55517: LD_INT 30
55519: PUSH
55520: LD_INT 0
55522: PUSH
55523: EMPTY
55524: LIST
55525: LIST
55526: PUSH
55527: LD_INT 30
55529: PUSH
55530: LD_INT 1
55532: PUSH
55533: EMPTY
55534: LIST
55535: LIST
55536: PUSH
55537: EMPTY
55538: LIST
55539: LIST
55540: LIST
55541: PPUSH
55542: CALL_OW 72
55546: NOT
55547: OR
55548: IFFALSE 55552
// exit ;
55550: GO 59055
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55552: LD_ADDR_VAR 0 4
55556: PUSH
55557: LD_EXP 66
55561: PUSH
55562: LD_VAR 0 1
55566: ARRAY
55567: PPUSH
55568: LD_INT 2
55570: PUSH
55571: LD_INT 25
55573: PUSH
55574: LD_INT 1
55576: PUSH
55577: EMPTY
55578: LIST
55579: LIST
55580: PUSH
55581: LD_INT 25
55583: PUSH
55584: LD_INT 2
55586: PUSH
55587: EMPTY
55588: LIST
55589: LIST
55590: PUSH
55591: LD_INT 25
55593: PUSH
55594: LD_INT 3
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: PUSH
55601: LD_INT 25
55603: PUSH
55604: LD_INT 4
55606: PUSH
55607: EMPTY
55608: LIST
55609: LIST
55610: PUSH
55611: LD_INT 25
55613: PUSH
55614: LD_INT 5
55616: PUSH
55617: EMPTY
55618: LIST
55619: LIST
55620: PUSH
55621: LD_INT 25
55623: PUSH
55624: LD_INT 8
55626: PUSH
55627: EMPTY
55628: LIST
55629: LIST
55630: PUSH
55631: LD_INT 25
55633: PUSH
55634: LD_INT 9
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: LIST
55645: LIST
55646: LIST
55647: LIST
55648: LIST
55649: LIST
55650: PPUSH
55651: CALL_OW 72
55655: ST_TO_ADDR
// if not tmp then
55656: LD_VAR 0 4
55660: NOT
55661: IFFALSE 55665
// exit ;
55663: GO 59055
// for i in tmp do
55665: LD_ADDR_VAR 0 3
55669: PUSH
55670: LD_VAR 0 4
55674: PUSH
55675: FOR_IN
55676: IFFALSE 55707
// if GetTag ( i ) then
55678: LD_VAR 0 3
55682: PPUSH
55683: CALL_OW 110
55687: IFFALSE 55705
// tmp := tmp diff i ;
55689: LD_ADDR_VAR 0 4
55693: PUSH
55694: LD_VAR 0 4
55698: PUSH
55699: LD_VAR 0 3
55703: DIFF
55704: ST_TO_ADDR
55705: GO 55675
55707: POP
55708: POP
// if not tmp then
55709: LD_VAR 0 4
55713: NOT
55714: IFFALSE 55718
// exit ;
55716: GO 59055
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55718: LD_ADDR_VAR 0 5
55722: PUSH
55723: LD_EXP 66
55727: PUSH
55728: LD_VAR 0 1
55732: ARRAY
55733: PPUSH
55734: LD_INT 2
55736: PUSH
55737: LD_INT 25
55739: PUSH
55740: LD_INT 1
55742: PUSH
55743: EMPTY
55744: LIST
55745: LIST
55746: PUSH
55747: LD_INT 25
55749: PUSH
55750: LD_INT 5
55752: PUSH
55753: EMPTY
55754: LIST
55755: LIST
55756: PUSH
55757: LD_INT 25
55759: PUSH
55760: LD_INT 8
55762: PUSH
55763: EMPTY
55764: LIST
55765: LIST
55766: PUSH
55767: LD_INT 25
55769: PUSH
55770: LD_INT 9
55772: PUSH
55773: EMPTY
55774: LIST
55775: LIST
55776: PUSH
55777: EMPTY
55778: LIST
55779: LIST
55780: LIST
55781: LIST
55782: LIST
55783: PPUSH
55784: CALL_OW 72
55788: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55789: LD_ADDR_VAR 0 6
55793: PUSH
55794: LD_EXP 66
55798: PUSH
55799: LD_VAR 0 1
55803: ARRAY
55804: PPUSH
55805: LD_INT 25
55807: PUSH
55808: LD_INT 2
55810: PUSH
55811: EMPTY
55812: LIST
55813: LIST
55814: PPUSH
55815: CALL_OW 72
55819: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55820: LD_ADDR_VAR 0 7
55824: PUSH
55825: LD_EXP 66
55829: PUSH
55830: LD_VAR 0 1
55834: ARRAY
55835: PPUSH
55836: LD_INT 25
55838: PUSH
55839: LD_INT 3
55841: PUSH
55842: EMPTY
55843: LIST
55844: LIST
55845: PPUSH
55846: CALL_OW 72
55850: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55851: LD_ADDR_VAR 0 8
55855: PUSH
55856: LD_EXP 66
55860: PUSH
55861: LD_VAR 0 1
55865: ARRAY
55866: PPUSH
55867: LD_INT 25
55869: PUSH
55870: LD_INT 4
55872: PUSH
55873: EMPTY
55874: LIST
55875: LIST
55876: PUSH
55877: LD_INT 24
55879: PUSH
55880: LD_INT 251
55882: PUSH
55883: EMPTY
55884: LIST
55885: LIST
55886: PUSH
55887: EMPTY
55888: LIST
55889: LIST
55890: PPUSH
55891: CALL_OW 72
55895: ST_TO_ADDR
// if mc_scan [ base ] then
55896: LD_EXP 89
55900: PUSH
55901: LD_VAR 0 1
55905: ARRAY
55906: IFFALSE 56367
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55908: LD_ADDR_EXP 108
55912: PUSH
55913: LD_EXP 108
55917: PPUSH
55918: LD_VAR 0 1
55922: PPUSH
55923: LD_INT 4
55925: PPUSH
55926: CALL_OW 1
55930: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55931: LD_ADDR_VAR 0 12
55935: PUSH
55936: LD_EXP 66
55940: PUSH
55941: LD_VAR 0 1
55945: ARRAY
55946: PPUSH
55947: LD_INT 2
55949: PUSH
55950: LD_INT 30
55952: PUSH
55953: LD_INT 4
55955: PUSH
55956: EMPTY
55957: LIST
55958: LIST
55959: PUSH
55960: LD_INT 30
55962: PUSH
55963: LD_INT 5
55965: PUSH
55966: EMPTY
55967: LIST
55968: LIST
55969: PUSH
55970: EMPTY
55971: LIST
55972: LIST
55973: LIST
55974: PPUSH
55975: CALL_OW 72
55979: ST_TO_ADDR
// if not b then
55980: LD_VAR 0 12
55984: NOT
55985: IFFALSE 55989
// exit ;
55987: GO 59055
// p := [ ] ;
55989: LD_ADDR_VAR 0 11
55993: PUSH
55994: EMPTY
55995: ST_TO_ADDR
// if sci >= 2 then
55996: LD_VAR 0 8
56000: PUSH
56001: LD_INT 2
56003: GREATEREQUAL
56004: IFFALSE 56035
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56006: LD_ADDR_VAR 0 8
56010: PUSH
56011: LD_VAR 0 8
56015: PUSH
56016: LD_INT 1
56018: ARRAY
56019: PUSH
56020: LD_VAR 0 8
56024: PUSH
56025: LD_INT 2
56027: ARRAY
56028: PUSH
56029: EMPTY
56030: LIST
56031: LIST
56032: ST_TO_ADDR
56033: GO 56096
// if sci = 1 then
56035: LD_VAR 0 8
56039: PUSH
56040: LD_INT 1
56042: EQUAL
56043: IFFALSE 56064
// sci := [ sci [ 1 ] ] else
56045: LD_ADDR_VAR 0 8
56049: PUSH
56050: LD_VAR 0 8
56054: PUSH
56055: LD_INT 1
56057: ARRAY
56058: PUSH
56059: EMPTY
56060: LIST
56061: ST_TO_ADDR
56062: GO 56096
// if sci = 0 then
56064: LD_VAR 0 8
56068: PUSH
56069: LD_INT 0
56071: EQUAL
56072: IFFALSE 56096
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56074: LD_ADDR_VAR 0 11
56078: PUSH
56079: LD_VAR 0 4
56083: PPUSH
56084: LD_INT 4
56086: PPUSH
56087: CALL 48097 0 2
56091: PUSH
56092: LD_INT 1
56094: ARRAY
56095: ST_TO_ADDR
// if eng > 4 then
56096: LD_VAR 0 6
56100: PUSH
56101: LD_INT 4
56103: GREATER
56104: IFFALSE 56150
// for i = eng downto 4 do
56106: LD_ADDR_VAR 0 3
56110: PUSH
56111: DOUBLE
56112: LD_VAR 0 6
56116: INC
56117: ST_TO_ADDR
56118: LD_INT 4
56120: PUSH
56121: FOR_DOWNTO
56122: IFFALSE 56148
// eng := eng diff eng [ i ] ;
56124: LD_ADDR_VAR 0 6
56128: PUSH
56129: LD_VAR 0 6
56133: PUSH
56134: LD_VAR 0 6
56138: PUSH
56139: LD_VAR 0 3
56143: ARRAY
56144: DIFF
56145: ST_TO_ADDR
56146: GO 56121
56148: POP
56149: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56150: LD_ADDR_VAR 0 4
56154: PUSH
56155: LD_VAR 0 4
56159: PUSH
56160: LD_VAR 0 5
56164: PUSH
56165: LD_VAR 0 6
56169: UNION
56170: PUSH
56171: LD_VAR 0 7
56175: UNION
56176: PUSH
56177: LD_VAR 0 8
56181: UNION
56182: DIFF
56183: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56184: LD_ADDR_VAR 0 13
56188: PUSH
56189: LD_EXP 66
56193: PUSH
56194: LD_VAR 0 1
56198: ARRAY
56199: PPUSH
56200: LD_INT 2
56202: PUSH
56203: LD_INT 30
56205: PUSH
56206: LD_INT 32
56208: PUSH
56209: EMPTY
56210: LIST
56211: LIST
56212: PUSH
56213: LD_INT 30
56215: PUSH
56216: LD_INT 31
56218: PUSH
56219: EMPTY
56220: LIST
56221: LIST
56222: PUSH
56223: EMPTY
56224: LIST
56225: LIST
56226: LIST
56227: PPUSH
56228: CALL_OW 72
56232: PUSH
56233: LD_EXP 66
56237: PUSH
56238: LD_VAR 0 1
56242: ARRAY
56243: PPUSH
56244: LD_INT 2
56246: PUSH
56247: LD_INT 30
56249: PUSH
56250: LD_INT 4
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: PUSH
56257: LD_INT 30
56259: PUSH
56260: LD_INT 5
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: PUSH
56267: EMPTY
56268: LIST
56269: LIST
56270: LIST
56271: PPUSH
56272: CALL_OW 72
56276: PUSH
56277: LD_INT 6
56279: MUL
56280: PLUS
56281: ST_TO_ADDR
// if bcount < tmp then
56282: LD_VAR 0 13
56286: PUSH
56287: LD_VAR 0 4
56291: LESS
56292: IFFALSE 56338
// for i = tmp downto bcount do
56294: LD_ADDR_VAR 0 3
56298: PUSH
56299: DOUBLE
56300: LD_VAR 0 4
56304: INC
56305: ST_TO_ADDR
56306: LD_VAR 0 13
56310: PUSH
56311: FOR_DOWNTO
56312: IFFALSE 56336
// tmp := Delete ( tmp , tmp ) ;
56314: LD_ADDR_VAR 0 4
56318: PUSH
56319: LD_VAR 0 4
56323: PPUSH
56324: LD_VAR 0 4
56328: PPUSH
56329: CALL_OW 3
56333: ST_TO_ADDR
56334: GO 56311
56336: POP
56337: POP
// result := [ tmp , 0 , 0 , p ] ;
56338: LD_ADDR_VAR 0 2
56342: PUSH
56343: LD_VAR 0 4
56347: PUSH
56348: LD_INT 0
56350: PUSH
56351: LD_INT 0
56353: PUSH
56354: LD_VAR 0 11
56358: PUSH
56359: EMPTY
56360: LIST
56361: LIST
56362: LIST
56363: LIST
56364: ST_TO_ADDR
// exit ;
56365: GO 59055
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56367: LD_EXP 66
56371: PUSH
56372: LD_VAR 0 1
56376: ARRAY
56377: PPUSH
56378: LD_INT 2
56380: PUSH
56381: LD_INT 30
56383: PUSH
56384: LD_INT 6
56386: PUSH
56387: EMPTY
56388: LIST
56389: LIST
56390: PUSH
56391: LD_INT 30
56393: PUSH
56394: LD_INT 7
56396: PUSH
56397: EMPTY
56398: LIST
56399: LIST
56400: PUSH
56401: LD_INT 30
56403: PUSH
56404: LD_INT 8
56406: PUSH
56407: EMPTY
56408: LIST
56409: LIST
56410: PUSH
56411: EMPTY
56412: LIST
56413: LIST
56414: LIST
56415: LIST
56416: PPUSH
56417: CALL_OW 72
56421: NOT
56422: PUSH
56423: LD_EXP 66
56427: PUSH
56428: LD_VAR 0 1
56432: ARRAY
56433: PPUSH
56434: LD_INT 30
56436: PUSH
56437: LD_INT 3
56439: PUSH
56440: EMPTY
56441: LIST
56442: LIST
56443: PPUSH
56444: CALL_OW 72
56448: NOT
56449: AND
56450: IFFALSE 56522
// begin if eng = tmp then
56452: LD_VAR 0 6
56456: PUSH
56457: LD_VAR 0 4
56461: EQUAL
56462: IFFALSE 56466
// exit ;
56464: GO 59055
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56466: LD_ADDR_EXP 108
56470: PUSH
56471: LD_EXP 108
56475: PPUSH
56476: LD_VAR 0 1
56480: PPUSH
56481: LD_INT 1
56483: PPUSH
56484: CALL_OW 1
56488: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56489: LD_ADDR_VAR 0 2
56493: PUSH
56494: LD_INT 0
56496: PUSH
56497: LD_VAR 0 4
56501: PUSH
56502: LD_VAR 0 6
56506: DIFF
56507: PUSH
56508: LD_INT 0
56510: PUSH
56511: LD_INT 0
56513: PUSH
56514: EMPTY
56515: LIST
56516: LIST
56517: LIST
56518: LIST
56519: ST_TO_ADDR
// exit ;
56520: GO 59055
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56522: LD_EXP 93
56526: PUSH
56527: LD_EXP 92
56531: PUSH
56532: LD_VAR 0 1
56536: ARRAY
56537: ARRAY
56538: PUSH
56539: LD_EXP 66
56543: PUSH
56544: LD_VAR 0 1
56548: ARRAY
56549: PPUSH
56550: LD_INT 2
56552: PUSH
56553: LD_INT 30
56555: PUSH
56556: LD_INT 6
56558: PUSH
56559: EMPTY
56560: LIST
56561: LIST
56562: PUSH
56563: LD_INT 30
56565: PUSH
56566: LD_INT 7
56568: PUSH
56569: EMPTY
56570: LIST
56571: LIST
56572: PUSH
56573: LD_INT 30
56575: PUSH
56576: LD_INT 8
56578: PUSH
56579: EMPTY
56580: LIST
56581: LIST
56582: PUSH
56583: EMPTY
56584: LIST
56585: LIST
56586: LIST
56587: LIST
56588: PPUSH
56589: CALL_OW 72
56593: AND
56594: PUSH
56595: LD_EXP 66
56599: PUSH
56600: LD_VAR 0 1
56604: ARRAY
56605: PPUSH
56606: LD_INT 30
56608: PUSH
56609: LD_INT 3
56611: PUSH
56612: EMPTY
56613: LIST
56614: LIST
56615: PPUSH
56616: CALL_OW 72
56620: NOT
56621: AND
56622: IFFALSE 56836
// begin if sci >= 6 then
56624: LD_VAR 0 8
56628: PUSH
56629: LD_INT 6
56631: GREATEREQUAL
56632: IFFALSE 56636
// exit ;
56634: GO 59055
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56636: LD_ADDR_EXP 108
56640: PUSH
56641: LD_EXP 108
56645: PPUSH
56646: LD_VAR 0 1
56650: PPUSH
56651: LD_INT 2
56653: PPUSH
56654: CALL_OW 1
56658: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56659: LD_ADDR_VAR 0 9
56663: PUSH
56664: LD_VAR 0 4
56668: PUSH
56669: LD_VAR 0 8
56673: DIFF
56674: PPUSH
56675: LD_INT 4
56677: PPUSH
56678: CALL 48097 0 2
56682: ST_TO_ADDR
// p := [ ] ;
56683: LD_ADDR_VAR 0 11
56687: PUSH
56688: EMPTY
56689: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56690: LD_VAR 0 8
56694: PUSH
56695: LD_INT 6
56697: LESS
56698: PUSH
56699: LD_VAR 0 9
56703: PUSH
56704: LD_INT 6
56706: GREATER
56707: AND
56708: IFFALSE 56789
// begin for i = 1 to 6 - sci do
56710: LD_ADDR_VAR 0 3
56714: PUSH
56715: DOUBLE
56716: LD_INT 1
56718: DEC
56719: ST_TO_ADDR
56720: LD_INT 6
56722: PUSH
56723: LD_VAR 0 8
56727: MINUS
56728: PUSH
56729: FOR_TO
56730: IFFALSE 56785
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
56732: LD_ADDR_VAR 0 11
56736: PUSH
56737: LD_VAR 0 11
56741: PPUSH
56742: LD_VAR 0 11
56746: PUSH
56747: LD_INT 1
56749: PLUS
56750: PPUSH
56751: LD_VAR 0 9
56755: PUSH
56756: LD_INT 1
56758: ARRAY
56759: PPUSH
56760: CALL_OW 2
56764: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56765: LD_ADDR_VAR 0 9
56769: PUSH
56770: LD_VAR 0 9
56774: PPUSH
56775: LD_INT 1
56777: PPUSH
56778: CALL_OW 3
56782: ST_TO_ADDR
// end ;
56783: GO 56729
56785: POP
56786: POP
// end else
56787: GO 56809
// if sort then
56789: LD_VAR 0 9
56793: IFFALSE 56809
// p := sort [ 1 ] ;
56795: LD_ADDR_VAR 0 11
56799: PUSH
56800: LD_VAR 0 9
56804: PUSH
56805: LD_INT 1
56807: ARRAY
56808: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56809: LD_ADDR_VAR 0 2
56813: PUSH
56814: LD_INT 0
56816: PUSH
56817: LD_INT 0
56819: PUSH
56820: LD_INT 0
56822: PUSH
56823: LD_VAR 0 11
56827: PUSH
56828: EMPTY
56829: LIST
56830: LIST
56831: LIST
56832: LIST
56833: ST_TO_ADDR
// exit ;
56834: GO 59055
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56836: LD_EXP 93
56840: PUSH
56841: LD_EXP 92
56845: PUSH
56846: LD_VAR 0 1
56850: ARRAY
56851: ARRAY
56852: PUSH
56853: LD_EXP 66
56857: PUSH
56858: LD_VAR 0 1
56862: ARRAY
56863: PPUSH
56864: LD_INT 2
56866: PUSH
56867: LD_INT 30
56869: PUSH
56870: LD_INT 6
56872: PUSH
56873: EMPTY
56874: LIST
56875: LIST
56876: PUSH
56877: LD_INT 30
56879: PUSH
56880: LD_INT 7
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: PUSH
56887: LD_INT 30
56889: PUSH
56890: LD_INT 8
56892: PUSH
56893: EMPTY
56894: LIST
56895: LIST
56896: PUSH
56897: EMPTY
56898: LIST
56899: LIST
56900: LIST
56901: LIST
56902: PPUSH
56903: CALL_OW 72
56907: AND
56908: PUSH
56909: LD_EXP 66
56913: PUSH
56914: LD_VAR 0 1
56918: ARRAY
56919: PPUSH
56920: LD_INT 30
56922: PUSH
56923: LD_INT 3
56925: PUSH
56926: EMPTY
56927: LIST
56928: LIST
56929: PPUSH
56930: CALL_OW 72
56934: AND
56935: IFFALSE 57669
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56937: LD_ADDR_EXP 108
56941: PUSH
56942: LD_EXP 108
56946: PPUSH
56947: LD_VAR 0 1
56951: PPUSH
56952: LD_INT 3
56954: PPUSH
56955: CALL_OW 1
56959: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56960: LD_ADDR_VAR 0 2
56964: PUSH
56965: LD_INT 0
56967: PUSH
56968: LD_INT 0
56970: PUSH
56971: LD_INT 0
56973: PUSH
56974: LD_INT 0
56976: PUSH
56977: EMPTY
56978: LIST
56979: LIST
56980: LIST
56981: LIST
56982: ST_TO_ADDR
// if not eng then
56983: LD_VAR 0 6
56987: NOT
56988: IFFALSE 57051
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56990: LD_ADDR_VAR 0 11
56994: PUSH
56995: LD_VAR 0 4
56999: PPUSH
57000: LD_INT 2
57002: PPUSH
57003: CALL 48097 0 2
57007: PUSH
57008: LD_INT 1
57010: ARRAY
57011: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57012: LD_ADDR_VAR 0 2
57016: PUSH
57017: LD_VAR 0 2
57021: PPUSH
57022: LD_INT 2
57024: PPUSH
57025: LD_VAR 0 11
57029: PPUSH
57030: CALL_OW 1
57034: ST_TO_ADDR
// tmp := tmp diff p ;
57035: LD_ADDR_VAR 0 4
57039: PUSH
57040: LD_VAR 0 4
57044: PUSH
57045: LD_VAR 0 11
57049: DIFF
57050: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57051: LD_VAR 0 4
57055: PUSH
57056: LD_VAR 0 8
57060: PUSH
57061: LD_INT 6
57063: LESS
57064: AND
57065: IFFALSE 57253
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57067: LD_ADDR_VAR 0 9
57071: PUSH
57072: LD_VAR 0 4
57076: PUSH
57077: LD_VAR 0 8
57081: PUSH
57082: LD_VAR 0 7
57086: UNION
57087: DIFF
57088: PPUSH
57089: LD_INT 4
57091: PPUSH
57092: CALL 48097 0 2
57096: ST_TO_ADDR
// p := [ ] ;
57097: LD_ADDR_VAR 0 11
57101: PUSH
57102: EMPTY
57103: ST_TO_ADDR
// if sort then
57104: LD_VAR 0 9
57108: IFFALSE 57224
// for i = 1 to 6 - sci do
57110: LD_ADDR_VAR 0 3
57114: PUSH
57115: DOUBLE
57116: LD_INT 1
57118: DEC
57119: ST_TO_ADDR
57120: LD_INT 6
57122: PUSH
57123: LD_VAR 0 8
57127: MINUS
57128: PUSH
57129: FOR_TO
57130: IFFALSE 57222
// begin if i = sort then
57132: LD_VAR 0 3
57136: PUSH
57137: LD_VAR 0 9
57141: EQUAL
57142: IFFALSE 57146
// break ;
57144: GO 57222
// if GetClass ( i ) = 4 then
57146: LD_VAR 0 3
57150: PPUSH
57151: CALL_OW 257
57155: PUSH
57156: LD_INT 4
57158: EQUAL
57159: IFFALSE 57163
// continue ;
57161: GO 57129
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57163: LD_ADDR_VAR 0 11
57167: PUSH
57168: LD_VAR 0 11
57172: PPUSH
57173: LD_VAR 0 11
57177: PUSH
57178: LD_INT 1
57180: PLUS
57181: PPUSH
57182: LD_VAR 0 9
57186: PUSH
57187: LD_VAR 0 3
57191: ARRAY
57192: PPUSH
57193: CALL_OW 2
57197: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57198: LD_ADDR_VAR 0 4
57202: PUSH
57203: LD_VAR 0 4
57207: PUSH
57208: LD_VAR 0 9
57212: PUSH
57213: LD_VAR 0 3
57217: ARRAY
57218: DIFF
57219: ST_TO_ADDR
// end ;
57220: GO 57129
57222: POP
57223: POP
// if p then
57224: LD_VAR 0 11
57228: IFFALSE 57253
// result := Replace ( result , 4 , p ) ;
57230: LD_ADDR_VAR 0 2
57234: PUSH
57235: LD_VAR 0 2
57239: PPUSH
57240: LD_INT 4
57242: PPUSH
57243: LD_VAR 0 11
57247: PPUSH
57248: CALL_OW 1
57252: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57253: LD_VAR 0 4
57257: PUSH
57258: LD_VAR 0 7
57262: PUSH
57263: LD_INT 6
57265: LESS
57266: AND
57267: IFFALSE 57455
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57269: LD_ADDR_VAR 0 9
57273: PUSH
57274: LD_VAR 0 4
57278: PUSH
57279: LD_VAR 0 8
57283: PUSH
57284: LD_VAR 0 7
57288: UNION
57289: DIFF
57290: PPUSH
57291: LD_INT 3
57293: PPUSH
57294: CALL 48097 0 2
57298: ST_TO_ADDR
// p := [ ] ;
57299: LD_ADDR_VAR 0 11
57303: PUSH
57304: EMPTY
57305: ST_TO_ADDR
// if sort then
57306: LD_VAR 0 9
57310: IFFALSE 57426
// for i = 1 to 6 - mech do
57312: LD_ADDR_VAR 0 3
57316: PUSH
57317: DOUBLE
57318: LD_INT 1
57320: DEC
57321: ST_TO_ADDR
57322: LD_INT 6
57324: PUSH
57325: LD_VAR 0 7
57329: MINUS
57330: PUSH
57331: FOR_TO
57332: IFFALSE 57424
// begin if i = sort then
57334: LD_VAR 0 3
57338: PUSH
57339: LD_VAR 0 9
57343: EQUAL
57344: IFFALSE 57348
// break ;
57346: GO 57424
// if GetClass ( i ) = 3 then
57348: LD_VAR 0 3
57352: PPUSH
57353: CALL_OW 257
57357: PUSH
57358: LD_INT 3
57360: EQUAL
57361: IFFALSE 57365
// continue ;
57363: GO 57331
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57365: LD_ADDR_VAR 0 11
57369: PUSH
57370: LD_VAR 0 11
57374: PPUSH
57375: LD_VAR 0 11
57379: PUSH
57380: LD_INT 1
57382: PLUS
57383: PPUSH
57384: LD_VAR 0 9
57388: PUSH
57389: LD_VAR 0 3
57393: ARRAY
57394: PPUSH
57395: CALL_OW 2
57399: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57400: LD_ADDR_VAR 0 4
57404: PUSH
57405: LD_VAR 0 4
57409: PUSH
57410: LD_VAR 0 9
57414: PUSH
57415: LD_VAR 0 3
57419: ARRAY
57420: DIFF
57421: ST_TO_ADDR
// end ;
57422: GO 57331
57424: POP
57425: POP
// if p then
57426: LD_VAR 0 11
57430: IFFALSE 57455
// result := Replace ( result , 3 , p ) ;
57432: LD_ADDR_VAR 0 2
57436: PUSH
57437: LD_VAR 0 2
57441: PPUSH
57442: LD_INT 3
57444: PPUSH
57445: LD_VAR 0 11
57449: PPUSH
57450: CALL_OW 1
57454: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57455: LD_VAR 0 4
57459: PUSH
57460: LD_INT 6
57462: GREATER
57463: PUSH
57464: LD_VAR 0 6
57468: PUSH
57469: LD_INT 6
57471: LESS
57472: AND
57473: IFFALSE 57667
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57475: LD_ADDR_VAR 0 9
57479: PUSH
57480: LD_VAR 0 4
57484: PUSH
57485: LD_VAR 0 8
57489: PUSH
57490: LD_VAR 0 7
57494: UNION
57495: PUSH
57496: LD_VAR 0 6
57500: UNION
57501: DIFF
57502: PPUSH
57503: LD_INT 2
57505: PPUSH
57506: CALL 48097 0 2
57510: ST_TO_ADDR
// p := [ ] ;
57511: LD_ADDR_VAR 0 11
57515: PUSH
57516: EMPTY
57517: ST_TO_ADDR
// if sort then
57518: LD_VAR 0 9
57522: IFFALSE 57638
// for i = 1 to 6 - eng do
57524: LD_ADDR_VAR 0 3
57528: PUSH
57529: DOUBLE
57530: LD_INT 1
57532: DEC
57533: ST_TO_ADDR
57534: LD_INT 6
57536: PUSH
57537: LD_VAR 0 6
57541: MINUS
57542: PUSH
57543: FOR_TO
57544: IFFALSE 57636
// begin if i = sort then
57546: LD_VAR 0 3
57550: PUSH
57551: LD_VAR 0 9
57555: EQUAL
57556: IFFALSE 57560
// break ;
57558: GO 57636
// if GetClass ( i ) = 2 then
57560: LD_VAR 0 3
57564: PPUSH
57565: CALL_OW 257
57569: PUSH
57570: LD_INT 2
57572: EQUAL
57573: IFFALSE 57577
// continue ;
57575: GO 57543
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57577: LD_ADDR_VAR 0 11
57581: PUSH
57582: LD_VAR 0 11
57586: PPUSH
57587: LD_VAR 0 11
57591: PUSH
57592: LD_INT 1
57594: PLUS
57595: PPUSH
57596: LD_VAR 0 9
57600: PUSH
57601: LD_VAR 0 3
57605: ARRAY
57606: PPUSH
57607: CALL_OW 2
57611: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57612: LD_ADDR_VAR 0 4
57616: PUSH
57617: LD_VAR 0 4
57621: PUSH
57622: LD_VAR 0 9
57626: PUSH
57627: LD_VAR 0 3
57631: ARRAY
57632: DIFF
57633: ST_TO_ADDR
// end ;
57634: GO 57543
57636: POP
57637: POP
// if p then
57638: LD_VAR 0 11
57642: IFFALSE 57667
// result := Replace ( result , 2 , p ) ;
57644: LD_ADDR_VAR 0 2
57648: PUSH
57649: LD_VAR 0 2
57653: PPUSH
57654: LD_INT 2
57656: PPUSH
57657: LD_VAR 0 11
57661: PPUSH
57662: CALL_OW 1
57666: ST_TO_ADDR
// end ; exit ;
57667: GO 59055
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57669: LD_EXP 93
57673: PUSH
57674: LD_EXP 92
57678: PUSH
57679: LD_VAR 0 1
57683: ARRAY
57684: ARRAY
57685: NOT
57686: PUSH
57687: LD_EXP 66
57691: PUSH
57692: LD_VAR 0 1
57696: ARRAY
57697: PPUSH
57698: LD_INT 30
57700: PUSH
57701: LD_INT 3
57703: PUSH
57704: EMPTY
57705: LIST
57706: LIST
57707: PPUSH
57708: CALL_OW 72
57712: AND
57713: PUSH
57714: LD_EXP 71
57718: PUSH
57719: LD_VAR 0 1
57723: ARRAY
57724: AND
57725: IFFALSE 58333
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
57727: LD_ADDR_EXP 108
57731: PUSH
57732: LD_EXP 108
57736: PPUSH
57737: LD_VAR 0 1
57741: PPUSH
57742: LD_INT 5
57744: PPUSH
57745: CALL_OW 1
57749: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57750: LD_ADDR_VAR 0 2
57754: PUSH
57755: LD_INT 0
57757: PUSH
57758: LD_INT 0
57760: PUSH
57761: LD_INT 0
57763: PUSH
57764: LD_INT 0
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: LIST
57771: LIST
57772: ST_TO_ADDR
// if sci > 1 then
57773: LD_VAR 0 8
57777: PUSH
57778: LD_INT 1
57780: GREATER
57781: IFFALSE 57809
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57783: LD_ADDR_VAR 0 4
57787: PUSH
57788: LD_VAR 0 4
57792: PUSH
57793: LD_VAR 0 8
57797: PUSH
57798: LD_VAR 0 8
57802: PUSH
57803: LD_INT 1
57805: ARRAY
57806: DIFF
57807: DIFF
57808: ST_TO_ADDR
// if tmp and not sci then
57809: LD_VAR 0 4
57813: PUSH
57814: LD_VAR 0 8
57818: NOT
57819: AND
57820: IFFALSE 57889
// begin sort := SortBySkill ( tmp , 4 ) ;
57822: LD_ADDR_VAR 0 9
57826: PUSH
57827: LD_VAR 0 4
57831: PPUSH
57832: LD_INT 4
57834: PPUSH
57835: CALL 48097 0 2
57839: ST_TO_ADDR
// if sort then
57840: LD_VAR 0 9
57844: IFFALSE 57860
// p := sort [ 1 ] ;
57846: LD_ADDR_VAR 0 11
57850: PUSH
57851: LD_VAR 0 9
57855: PUSH
57856: LD_INT 1
57858: ARRAY
57859: ST_TO_ADDR
// if p then
57860: LD_VAR 0 11
57864: IFFALSE 57889
// result := Replace ( result , 4 , p ) ;
57866: LD_ADDR_VAR 0 2
57870: PUSH
57871: LD_VAR 0 2
57875: PPUSH
57876: LD_INT 4
57878: PPUSH
57879: LD_VAR 0 11
57883: PPUSH
57884: CALL_OW 1
57888: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57889: LD_ADDR_VAR 0 4
57893: PUSH
57894: LD_VAR 0 4
57898: PUSH
57899: LD_VAR 0 7
57903: DIFF
57904: ST_TO_ADDR
// if tmp and mech < 6 then
57905: LD_VAR 0 4
57909: PUSH
57910: LD_VAR 0 7
57914: PUSH
57915: LD_INT 6
57917: LESS
57918: AND
57919: IFFALSE 58107
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57921: LD_ADDR_VAR 0 9
57925: PUSH
57926: LD_VAR 0 4
57930: PUSH
57931: LD_VAR 0 8
57935: PUSH
57936: LD_VAR 0 7
57940: UNION
57941: DIFF
57942: PPUSH
57943: LD_INT 3
57945: PPUSH
57946: CALL 48097 0 2
57950: ST_TO_ADDR
// p := [ ] ;
57951: LD_ADDR_VAR 0 11
57955: PUSH
57956: EMPTY
57957: ST_TO_ADDR
// if sort then
57958: LD_VAR 0 9
57962: IFFALSE 58078
// for i = 1 to 6 - mech do
57964: LD_ADDR_VAR 0 3
57968: PUSH
57969: DOUBLE
57970: LD_INT 1
57972: DEC
57973: ST_TO_ADDR
57974: LD_INT 6
57976: PUSH
57977: LD_VAR 0 7
57981: MINUS
57982: PUSH
57983: FOR_TO
57984: IFFALSE 58076
// begin if i = sort then
57986: LD_VAR 0 3
57990: PUSH
57991: LD_VAR 0 9
57995: EQUAL
57996: IFFALSE 58000
// break ;
57998: GO 58076
// if GetClass ( i ) = 3 then
58000: LD_VAR 0 3
58004: PPUSH
58005: CALL_OW 257
58009: PUSH
58010: LD_INT 3
58012: EQUAL
58013: IFFALSE 58017
// continue ;
58015: GO 57983
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58017: LD_ADDR_VAR 0 11
58021: PUSH
58022: LD_VAR 0 11
58026: PPUSH
58027: LD_VAR 0 11
58031: PUSH
58032: LD_INT 1
58034: PLUS
58035: PPUSH
58036: LD_VAR 0 9
58040: PUSH
58041: LD_VAR 0 3
58045: ARRAY
58046: PPUSH
58047: CALL_OW 2
58051: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58052: LD_ADDR_VAR 0 4
58056: PUSH
58057: LD_VAR 0 4
58061: PUSH
58062: LD_VAR 0 9
58066: PUSH
58067: LD_VAR 0 3
58071: ARRAY
58072: DIFF
58073: ST_TO_ADDR
// end ;
58074: GO 57983
58076: POP
58077: POP
// if p then
58078: LD_VAR 0 11
58082: IFFALSE 58107
// result := Replace ( result , 3 , p ) ;
58084: LD_ADDR_VAR 0 2
58088: PUSH
58089: LD_VAR 0 2
58093: PPUSH
58094: LD_INT 3
58096: PPUSH
58097: LD_VAR 0 11
58101: PPUSH
58102: CALL_OW 1
58106: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58107: LD_ADDR_VAR 0 4
58111: PUSH
58112: LD_VAR 0 4
58116: PUSH
58117: LD_VAR 0 6
58121: DIFF
58122: ST_TO_ADDR
// if tmp and eng < 6 then
58123: LD_VAR 0 4
58127: PUSH
58128: LD_VAR 0 6
58132: PUSH
58133: LD_INT 6
58135: LESS
58136: AND
58137: IFFALSE 58331
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58139: LD_ADDR_VAR 0 9
58143: PUSH
58144: LD_VAR 0 4
58148: PUSH
58149: LD_VAR 0 8
58153: PUSH
58154: LD_VAR 0 7
58158: UNION
58159: PUSH
58160: LD_VAR 0 6
58164: UNION
58165: DIFF
58166: PPUSH
58167: LD_INT 2
58169: PPUSH
58170: CALL 48097 0 2
58174: ST_TO_ADDR
// p := [ ] ;
58175: LD_ADDR_VAR 0 11
58179: PUSH
58180: EMPTY
58181: ST_TO_ADDR
// if sort then
58182: LD_VAR 0 9
58186: IFFALSE 58302
// for i = 1 to 6 - eng do
58188: LD_ADDR_VAR 0 3
58192: PUSH
58193: DOUBLE
58194: LD_INT 1
58196: DEC
58197: ST_TO_ADDR
58198: LD_INT 6
58200: PUSH
58201: LD_VAR 0 6
58205: MINUS
58206: PUSH
58207: FOR_TO
58208: IFFALSE 58300
// begin if i = sort then
58210: LD_VAR 0 3
58214: PUSH
58215: LD_VAR 0 9
58219: EQUAL
58220: IFFALSE 58224
// break ;
58222: GO 58300
// if GetClass ( i ) = 2 then
58224: LD_VAR 0 3
58228: PPUSH
58229: CALL_OW 257
58233: PUSH
58234: LD_INT 2
58236: EQUAL
58237: IFFALSE 58241
// continue ;
58239: GO 58207
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58241: LD_ADDR_VAR 0 11
58245: PUSH
58246: LD_VAR 0 11
58250: PPUSH
58251: LD_VAR 0 11
58255: PUSH
58256: LD_INT 1
58258: PLUS
58259: PPUSH
58260: LD_VAR 0 9
58264: PUSH
58265: LD_VAR 0 3
58269: ARRAY
58270: PPUSH
58271: CALL_OW 2
58275: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58276: LD_ADDR_VAR 0 4
58280: PUSH
58281: LD_VAR 0 4
58285: PUSH
58286: LD_VAR 0 9
58290: PUSH
58291: LD_VAR 0 3
58295: ARRAY
58296: DIFF
58297: ST_TO_ADDR
// end ;
58298: GO 58207
58300: POP
58301: POP
// if p then
58302: LD_VAR 0 11
58306: IFFALSE 58331
// result := Replace ( result , 2 , p ) ;
58308: LD_ADDR_VAR 0 2
58312: PUSH
58313: LD_VAR 0 2
58317: PPUSH
58318: LD_INT 2
58320: PPUSH
58321: LD_VAR 0 11
58325: PPUSH
58326: CALL_OW 1
58330: ST_TO_ADDR
// end ; exit ;
58331: GO 59055
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58333: LD_EXP 93
58337: PUSH
58338: LD_EXP 92
58342: PUSH
58343: LD_VAR 0 1
58347: ARRAY
58348: ARRAY
58349: NOT
58350: PUSH
58351: LD_EXP 66
58355: PUSH
58356: LD_VAR 0 1
58360: ARRAY
58361: PPUSH
58362: LD_INT 30
58364: PUSH
58365: LD_INT 3
58367: PUSH
58368: EMPTY
58369: LIST
58370: LIST
58371: PPUSH
58372: CALL_OW 72
58376: AND
58377: PUSH
58378: LD_EXP 71
58382: PUSH
58383: LD_VAR 0 1
58387: ARRAY
58388: NOT
58389: AND
58390: IFFALSE 59055
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58392: LD_ADDR_EXP 108
58396: PUSH
58397: LD_EXP 108
58401: PPUSH
58402: LD_VAR 0 1
58406: PPUSH
58407: LD_INT 6
58409: PPUSH
58410: CALL_OW 1
58414: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58415: LD_ADDR_VAR 0 2
58419: PUSH
58420: LD_INT 0
58422: PUSH
58423: LD_INT 0
58425: PUSH
58426: LD_INT 0
58428: PUSH
58429: LD_INT 0
58431: PUSH
58432: EMPTY
58433: LIST
58434: LIST
58435: LIST
58436: LIST
58437: ST_TO_ADDR
// if sci >= 1 then
58438: LD_VAR 0 8
58442: PUSH
58443: LD_INT 1
58445: GREATEREQUAL
58446: IFFALSE 58468
// tmp := tmp diff sci [ 1 ] ;
58448: LD_ADDR_VAR 0 4
58452: PUSH
58453: LD_VAR 0 4
58457: PUSH
58458: LD_VAR 0 8
58462: PUSH
58463: LD_INT 1
58465: ARRAY
58466: DIFF
58467: ST_TO_ADDR
// if tmp and not sci then
58468: LD_VAR 0 4
58472: PUSH
58473: LD_VAR 0 8
58477: NOT
58478: AND
58479: IFFALSE 58548
// begin sort := SortBySkill ( tmp , 4 ) ;
58481: LD_ADDR_VAR 0 9
58485: PUSH
58486: LD_VAR 0 4
58490: PPUSH
58491: LD_INT 4
58493: PPUSH
58494: CALL 48097 0 2
58498: ST_TO_ADDR
// if sort then
58499: LD_VAR 0 9
58503: IFFALSE 58519
// p := sort [ 1 ] ;
58505: LD_ADDR_VAR 0 11
58509: PUSH
58510: LD_VAR 0 9
58514: PUSH
58515: LD_INT 1
58517: ARRAY
58518: ST_TO_ADDR
// if p then
58519: LD_VAR 0 11
58523: IFFALSE 58548
// result := Replace ( result , 4 , p ) ;
58525: LD_ADDR_VAR 0 2
58529: PUSH
58530: LD_VAR 0 2
58534: PPUSH
58535: LD_INT 4
58537: PPUSH
58538: LD_VAR 0 11
58542: PPUSH
58543: CALL_OW 1
58547: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58548: LD_ADDR_VAR 0 4
58552: PUSH
58553: LD_VAR 0 4
58557: PUSH
58558: LD_VAR 0 7
58562: DIFF
58563: ST_TO_ADDR
// if tmp and mech < 6 then
58564: LD_VAR 0 4
58568: PUSH
58569: LD_VAR 0 7
58573: PUSH
58574: LD_INT 6
58576: LESS
58577: AND
58578: IFFALSE 58760
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58580: LD_ADDR_VAR 0 9
58584: PUSH
58585: LD_VAR 0 4
58589: PUSH
58590: LD_VAR 0 7
58594: DIFF
58595: PPUSH
58596: LD_INT 3
58598: PPUSH
58599: CALL 48097 0 2
58603: ST_TO_ADDR
// p := [ ] ;
58604: LD_ADDR_VAR 0 11
58608: PUSH
58609: EMPTY
58610: ST_TO_ADDR
// if sort then
58611: LD_VAR 0 9
58615: IFFALSE 58731
// for i = 1 to 6 - mech do
58617: LD_ADDR_VAR 0 3
58621: PUSH
58622: DOUBLE
58623: LD_INT 1
58625: DEC
58626: ST_TO_ADDR
58627: LD_INT 6
58629: PUSH
58630: LD_VAR 0 7
58634: MINUS
58635: PUSH
58636: FOR_TO
58637: IFFALSE 58729
// begin if i = sort then
58639: LD_VAR 0 3
58643: PUSH
58644: LD_VAR 0 9
58648: EQUAL
58649: IFFALSE 58653
// break ;
58651: GO 58729
// if GetClass ( i ) = 3 then
58653: LD_VAR 0 3
58657: PPUSH
58658: CALL_OW 257
58662: PUSH
58663: LD_INT 3
58665: EQUAL
58666: IFFALSE 58670
// continue ;
58668: GO 58636
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58670: LD_ADDR_VAR 0 11
58674: PUSH
58675: LD_VAR 0 11
58679: PPUSH
58680: LD_VAR 0 11
58684: PUSH
58685: LD_INT 1
58687: PLUS
58688: PPUSH
58689: LD_VAR 0 9
58693: PUSH
58694: LD_VAR 0 3
58698: ARRAY
58699: PPUSH
58700: CALL_OW 2
58704: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58705: LD_ADDR_VAR 0 4
58709: PUSH
58710: LD_VAR 0 4
58714: PUSH
58715: LD_VAR 0 9
58719: PUSH
58720: LD_VAR 0 3
58724: ARRAY
58725: DIFF
58726: ST_TO_ADDR
// end ;
58727: GO 58636
58729: POP
58730: POP
// if p then
58731: LD_VAR 0 11
58735: IFFALSE 58760
// result := Replace ( result , 3 , p ) ;
58737: LD_ADDR_VAR 0 2
58741: PUSH
58742: LD_VAR 0 2
58746: PPUSH
58747: LD_INT 3
58749: PPUSH
58750: LD_VAR 0 11
58754: PPUSH
58755: CALL_OW 1
58759: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58760: LD_ADDR_VAR 0 4
58764: PUSH
58765: LD_VAR 0 4
58769: PUSH
58770: LD_VAR 0 6
58774: DIFF
58775: ST_TO_ADDR
// if tmp and eng < 4 then
58776: LD_VAR 0 4
58780: PUSH
58781: LD_VAR 0 6
58785: PUSH
58786: LD_INT 4
58788: LESS
58789: AND
58790: IFFALSE 58980
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58792: LD_ADDR_VAR 0 9
58796: PUSH
58797: LD_VAR 0 4
58801: PUSH
58802: LD_VAR 0 7
58806: PUSH
58807: LD_VAR 0 6
58811: UNION
58812: DIFF
58813: PPUSH
58814: LD_INT 2
58816: PPUSH
58817: CALL 48097 0 2
58821: ST_TO_ADDR
// p := [ ] ;
58822: LD_ADDR_VAR 0 11
58826: PUSH
58827: EMPTY
58828: ST_TO_ADDR
// if sort then
58829: LD_VAR 0 9
58833: IFFALSE 58949
// for i = 1 to 4 - eng do
58835: LD_ADDR_VAR 0 3
58839: PUSH
58840: DOUBLE
58841: LD_INT 1
58843: DEC
58844: ST_TO_ADDR
58845: LD_INT 4
58847: PUSH
58848: LD_VAR 0 6
58852: MINUS
58853: PUSH
58854: FOR_TO
58855: IFFALSE 58947
// begin if i = sort then
58857: LD_VAR 0 3
58861: PUSH
58862: LD_VAR 0 9
58866: EQUAL
58867: IFFALSE 58871
// break ;
58869: GO 58947
// if GetClass ( i ) = 2 then
58871: LD_VAR 0 3
58875: PPUSH
58876: CALL_OW 257
58880: PUSH
58881: LD_INT 2
58883: EQUAL
58884: IFFALSE 58888
// continue ;
58886: GO 58854
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58888: LD_ADDR_VAR 0 11
58892: PUSH
58893: LD_VAR 0 11
58897: PPUSH
58898: LD_VAR 0 11
58902: PUSH
58903: LD_INT 1
58905: PLUS
58906: PPUSH
58907: LD_VAR 0 9
58911: PUSH
58912: LD_VAR 0 3
58916: ARRAY
58917: PPUSH
58918: CALL_OW 2
58922: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58923: LD_ADDR_VAR 0 4
58927: PUSH
58928: LD_VAR 0 4
58932: PUSH
58933: LD_VAR 0 9
58937: PUSH
58938: LD_VAR 0 3
58942: ARRAY
58943: DIFF
58944: ST_TO_ADDR
// end ;
58945: GO 58854
58947: POP
58948: POP
// if p then
58949: LD_VAR 0 11
58953: IFFALSE 58978
// result := Replace ( result , 2 , p ) ;
58955: LD_ADDR_VAR 0 2
58959: PUSH
58960: LD_VAR 0 2
58964: PPUSH
58965: LD_INT 2
58967: PPUSH
58968: LD_VAR 0 11
58972: PPUSH
58973: CALL_OW 1
58977: ST_TO_ADDR
// end else
58978: GO 59024
// for i = eng downto 5 do
58980: LD_ADDR_VAR 0 3
58984: PUSH
58985: DOUBLE
58986: LD_VAR 0 6
58990: INC
58991: ST_TO_ADDR
58992: LD_INT 5
58994: PUSH
58995: FOR_DOWNTO
58996: IFFALSE 59022
// tmp := tmp union eng [ i ] ;
58998: LD_ADDR_VAR 0 4
59002: PUSH
59003: LD_VAR 0 4
59007: PUSH
59008: LD_VAR 0 6
59012: PUSH
59013: LD_VAR 0 3
59017: ARRAY
59018: UNION
59019: ST_TO_ADDR
59020: GO 58995
59022: POP
59023: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59024: LD_ADDR_VAR 0 2
59028: PUSH
59029: LD_VAR 0 2
59033: PPUSH
59034: LD_INT 1
59036: PPUSH
59037: LD_VAR 0 4
59041: PUSH
59042: LD_VAR 0 5
59046: DIFF
59047: PPUSH
59048: CALL_OW 1
59052: ST_TO_ADDR
// exit ;
59053: GO 59055
// end ; end ;
59055: LD_VAR 0 2
59059: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59060: LD_INT 0
59062: PPUSH
59063: PPUSH
59064: PPUSH
// if not mc_bases then
59065: LD_EXP 66
59069: NOT
59070: IFFALSE 59074
// exit ;
59072: GO 59180
// for i = 1 to mc_bases do
59074: LD_ADDR_VAR 0 2
59078: PUSH
59079: DOUBLE
59080: LD_INT 1
59082: DEC
59083: ST_TO_ADDR
59084: LD_EXP 66
59088: PUSH
59089: FOR_TO
59090: IFFALSE 59171
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59092: LD_ADDR_VAR 0 3
59096: PUSH
59097: LD_EXP 66
59101: PUSH
59102: LD_VAR 0 2
59106: ARRAY
59107: PPUSH
59108: LD_INT 21
59110: PUSH
59111: LD_INT 3
59113: PUSH
59114: EMPTY
59115: LIST
59116: LIST
59117: PUSH
59118: LD_INT 3
59120: PUSH
59121: LD_INT 24
59123: PUSH
59124: LD_INT 1000
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: PUSH
59131: EMPTY
59132: LIST
59133: LIST
59134: PUSH
59135: EMPTY
59136: LIST
59137: LIST
59138: PPUSH
59139: CALL_OW 72
59143: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59144: LD_ADDR_EXP 67
59148: PUSH
59149: LD_EXP 67
59153: PPUSH
59154: LD_VAR 0 2
59158: PPUSH
59159: LD_VAR 0 3
59163: PPUSH
59164: CALL_OW 1
59168: ST_TO_ADDR
// end ;
59169: GO 59089
59171: POP
59172: POP
// RaiseSailEvent ( 101 ) ;
59173: LD_INT 101
59175: PPUSH
59176: CALL_OW 427
// end ;
59180: LD_VAR 0 1
59184: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59185: LD_INT 0
59187: PPUSH
59188: PPUSH
59189: PPUSH
59190: PPUSH
59191: PPUSH
59192: PPUSH
59193: PPUSH
// if not mc_bases then
59194: LD_EXP 66
59198: NOT
59199: IFFALSE 59203
// exit ;
59201: GO 59765
// for i = 1 to mc_bases do
59203: LD_ADDR_VAR 0 2
59207: PUSH
59208: DOUBLE
59209: LD_INT 1
59211: DEC
59212: ST_TO_ADDR
59213: LD_EXP 66
59217: PUSH
59218: FOR_TO
59219: IFFALSE 59756
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
59221: LD_ADDR_VAR 0 5
59225: PUSH
59226: LD_EXP 66
59230: PUSH
59231: LD_VAR 0 2
59235: ARRAY
59236: PUSH
59237: LD_EXP 95
59241: PUSH
59242: LD_VAR 0 2
59246: ARRAY
59247: UNION
59248: PPUSH
59249: LD_INT 21
59251: PUSH
59252: LD_INT 1
59254: PUSH
59255: EMPTY
59256: LIST
59257: LIST
59258: PUSH
59259: LD_INT 1
59261: PUSH
59262: LD_INT 3
59264: PUSH
59265: LD_INT 54
59267: PUSH
59268: EMPTY
59269: LIST
59270: PUSH
59271: EMPTY
59272: LIST
59273: LIST
59274: PUSH
59275: LD_INT 3
59277: PUSH
59278: LD_INT 24
59280: PUSH
59281: LD_INT 800
59283: PUSH
59284: EMPTY
59285: LIST
59286: LIST
59287: PUSH
59288: EMPTY
59289: LIST
59290: LIST
59291: PUSH
59292: EMPTY
59293: LIST
59294: LIST
59295: LIST
59296: PUSH
59297: EMPTY
59298: LIST
59299: LIST
59300: PPUSH
59301: CALL_OW 72
59305: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59306: LD_ADDR_VAR 0 6
59310: PUSH
59311: LD_EXP 66
59315: PUSH
59316: LD_VAR 0 2
59320: ARRAY
59321: PPUSH
59322: LD_INT 21
59324: PUSH
59325: LD_INT 1
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: PUSH
59332: LD_INT 1
59334: PUSH
59335: LD_INT 3
59337: PUSH
59338: LD_INT 54
59340: PUSH
59341: EMPTY
59342: LIST
59343: PUSH
59344: EMPTY
59345: LIST
59346: LIST
59347: PUSH
59348: LD_INT 3
59350: PUSH
59351: LD_INT 24
59353: PUSH
59354: LD_INT 250
59356: PUSH
59357: EMPTY
59358: LIST
59359: LIST
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: PUSH
59365: EMPTY
59366: LIST
59367: LIST
59368: LIST
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: PPUSH
59374: CALL_OW 72
59378: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59379: LD_ADDR_VAR 0 7
59383: PUSH
59384: LD_VAR 0 5
59388: PUSH
59389: LD_VAR 0 6
59393: DIFF
59394: ST_TO_ADDR
// if not need_heal_1 then
59395: LD_VAR 0 6
59399: NOT
59400: IFFALSE 59433
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59402: LD_ADDR_EXP 69
59406: PUSH
59407: LD_EXP 69
59411: PPUSH
59412: LD_VAR 0 2
59416: PUSH
59417: LD_INT 1
59419: PUSH
59420: EMPTY
59421: LIST
59422: LIST
59423: PPUSH
59424: EMPTY
59425: PPUSH
59426: CALL 18548 0 3
59430: ST_TO_ADDR
59431: GO 59503
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59433: LD_ADDR_EXP 69
59437: PUSH
59438: LD_EXP 69
59442: PPUSH
59443: LD_VAR 0 2
59447: PUSH
59448: LD_INT 1
59450: PUSH
59451: EMPTY
59452: LIST
59453: LIST
59454: PPUSH
59455: LD_EXP 69
59459: PUSH
59460: LD_VAR 0 2
59464: ARRAY
59465: PUSH
59466: LD_INT 1
59468: ARRAY
59469: PPUSH
59470: LD_INT 3
59472: PUSH
59473: LD_INT 24
59475: PUSH
59476: LD_INT 1000
59478: PUSH
59479: EMPTY
59480: LIST
59481: LIST
59482: PUSH
59483: EMPTY
59484: LIST
59485: LIST
59486: PPUSH
59487: CALL_OW 72
59491: PUSH
59492: LD_VAR 0 6
59496: UNION
59497: PPUSH
59498: CALL 18548 0 3
59502: ST_TO_ADDR
// if not need_heal_2 then
59503: LD_VAR 0 7
59507: NOT
59508: IFFALSE 59541
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59510: LD_ADDR_EXP 69
59514: PUSH
59515: LD_EXP 69
59519: PPUSH
59520: LD_VAR 0 2
59524: PUSH
59525: LD_INT 2
59527: PUSH
59528: EMPTY
59529: LIST
59530: LIST
59531: PPUSH
59532: EMPTY
59533: PPUSH
59534: CALL 18548 0 3
59538: ST_TO_ADDR
59539: GO 59573
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59541: LD_ADDR_EXP 69
59545: PUSH
59546: LD_EXP 69
59550: PPUSH
59551: LD_VAR 0 2
59555: PUSH
59556: LD_INT 2
59558: PUSH
59559: EMPTY
59560: LIST
59561: LIST
59562: PPUSH
59563: LD_VAR 0 7
59567: PPUSH
59568: CALL 18548 0 3
59572: ST_TO_ADDR
// if need_heal_2 then
59573: LD_VAR 0 7
59577: IFFALSE 59738
// for j in need_heal_2 do
59579: LD_ADDR_VAR 0 3
59583: PUSH
59584: LD_VAR 0 7
59588: PUSH
59589: FOR_IN
59590: IFFALSE 59736
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59592: LD_ADDR_VAR 0 5
59596: PUSH
59597: LD_EXP 66
59601: PUSH
59602: LD_VAR 0 2
59606: ARRAY
59607: PPUSH
59608: LD_INT 2
59610: PUSH
59611: LD_INT 30
59613: PUSH
59614: LD_INT 6
59616: PUSH
59617: EMPTY
59618: LIST
59619: LIST
59620: PUSH
59621: LD_INT 30
59623: PUSH
59624: LD_INT 7
59626: PUSH
59627: EMPTY
59628: LIST
59629: LIST
59630: PUSH
59631: LD_INT 30
59633: PUSH
59634: LD_INT 8
59636: PUSH
59637: EMPTY
59638: LIST
59639: LIST
59640: PUSH
59641: LD_INT 30
59643: PUSH
59644: LD_INT 0
59646: PUSH
59647: EMPTY
59648: LIST
59649: LIST
59650: PUSH
59651: LD_INT 30
59653: PUSH
59654: LD_INT 1
59656: PUSH
59657: EMPTY
59658: LIST
59659: LIST
59660: PUSH
59661: EMPTY
59662: LIST
59663: LIST
59664: LIST
59665: LIST
59666: LIST
59667: LIST
59668: PPUSH
59669: CALL_OW 72
59673: ST_TO_ADDR
// if tmp then
59674: LD_VAR 0 5
59678: IFFALSE 59734
// begin k := NearestUnitToUnit ( tmp , j ) ;
59680: LD_ADDR_VAR 0 4
59684: PUSH
59685: LD_VAR 0 5
59689: PPUSH
59690: LD_VAR 0 3
59694: PPUSH
59695: CALL_OW 74
59699: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
59700: LD_VAR 0 3
59704: PPUSH
59705: LD_VAR 0 4
59709: PPUSH
59710: CALL_OW 296
59714: PUSH
59715: LD_INT 5
59717: GREATER
59718: IFFALSE 59734
// ComMoveToNearbyEntrance ( j , k ) ;
59720: LD_VAR 0 3
59724: PPUSH
59725: LD_VAR 0 4
59729: PPUSH
59730: CALL 50414 0 2
// end ; end ;
59734: GO 59589
59736: POP
59737: POP
// if not need_heal_1 and not need_heal_2 then
59738: LD_VAR 0 6
59742: NOT
59743: PUSH
59744: LD_VAR 0 7
59748: NOT
59749: AND
59750: IFFALSE 59754
// continue ;
59752: GO 59218
// end ;
59754: GO 59218
59756: POP
59757: POP
// RaiseSailEvent ( 102 ) ;
59758: LD_INT 102
59760: PPUSH
59761: CALL_OW 427
// end ;
59765: LD_VAR 0 1
59769: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59770: LD_INT 0
59772: PPUSH
59773: PPUSH
59774: PPUSH
59775: PPUSH
59776: PPUSH
59777: PPUSH
59778: PPUSH
59779: PPUSH
// if not mc_bases then
59780: LD_EXP 66
59784: NOT
59785: IFFALSE 59789
// exit ;
59787: GO 60650
// for i = 1 to mc_bases do
59789: LD_ADDR_VAR 0 2
59793: PUSH
59794: DOUBLE
59795: LD_INT 1
59797: DEC
59798: ST_TO_ADDR
59799: LD_EXP 66
59803: PUSH
59804: FOR_TO
59805: IFFALSE 60648
// begin if not mc_building_need_repair [ i ] then
59807: LD_EXP 67
59811: PUSH
59812: LD_VAR 0 2
59816: ARRAY
59817: NOT
59818: IFFALSE 60005
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
59820: LD_ADDR_VAR 0 6
59824: PUSH
59825: LD_EXP 85
59829: PUSH
59830: LD_VAR 0 2
59834: ARRAY
59835: PPUSH
59836: LD_INT 3
59838: PUSH
59839: LD_INT 24
59841: PUSH
59842: LD_INT 1000
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: PUSH
59853: LD_INT 2
59855: PUSH
59856: LD_INT 34
59858: PUSH
59859: LD_INT 13
59861: PUSH
59862: EMPTY
59863: LIST
59864: LIST
59865: PUSH
59866: LD_INT 34
59868: PUSH
59869: LD_INT 52
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: PUSH
59876: LD_INT 34
59878: PUSH
59879: LD_EXP 54
59883: PUSH
59884: EMPTY
59885: LIST
59886: LIST
59887: PUSH
59888: EMPTY
59889: LIST
59890: LIST
59891: LIST
59892: LIST
59893: PUSH
59894: EMPTY
59895: LIST
59896: LIST
59897: PPUSH
59898: CALL_OW 72
59902: ST_TO_ADDR
// if cranes then
59903: LD_VAR 0 6
59907: IFFALSE 59969
// for j in cranes do
59909: LD_ADDR_VAR 0 3
59913: PUSH
59914: LD_VAR 0 6
59918: PUSH
59919: FOR_IN
59920: IFFALSE 59967
// if not IsInArea ( j , mc_parking [ i ] ) then
59922: LD_VAR 0 3
59926: PPUSH
59927: LD_EXP 90
59931: PUSH
59932: LD_VAR 0 2
59936: ARRAY
59937: PPUSH
59938: CALL_OW 308
59942: NOT
59943: IFFALSE 59965
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59945: LD_VAR 0 3
59949: PPUSH
59950: LD_EXP 90
59954: PUSH
59955: LD_VAR 0 2
59959: ARRAY
59960: PPUSH
59961: CALL_OW 113
59965: GO 59919
59967: POP
59968: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59969: LD_ADDR_EXP 68
59973: PUSH
59974: LD_EXP 68
59978: PPUSH
59979: LD_VAR 0 2
59983: PPUSH
59984: EMPTY
59985: PPUSH
59986: CALL_OW 1
59990: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59991: LD_VAR 0 2
59995: PPUSH
59996: LD_INT 101
59998: PPUSH
59999: CALL 54893 0 2
// continue ;
60003: GO 59804
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60005: LD_ADDR_EXP 72
60009: PUSH
60010: LD_EXP 72
60014: PPUSH
60015: LD_VAR 0 2
60019: PPUSH
60020: EMPTY
60021: PPUSH
60022: CALL_OW 1
60026: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60027: LD_VAR 0 2
60031: PPUSH
60032: LD_INT 103
60034: PPUSH
60035: CALL 54893 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60039: LD_ADDR_VAR 0 5
60043: PUSH
60044: LD_EXP 66
60048: PUSH
60049: LD_VAR 0 2
60053: ARRAY
60054: PUSH
60055: LD_EXP 95
60059: PUSH
60060: LD_VAR 0 2
60064: ARRAY
60065: UNION
60066: PPUSH
60067: LD_INT 2
60069: PUSH
60070: LD_INT 25
60072: PUSH
60073: LD_INT 2
60075: PUSH
60076: EMPTY
60077: LIST
60078: LIST
60079: PUSH
60080: LD_INT 25
60082: PUSH
60083: LD_INT 16
60085: PUSH
60086: EMPTY
60087: LIST
60088: LIST
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: LIST
60094: PUSH
60095: EMPTY
60096: LIST
60097: PPUSH
60098: CALL_OW 72
60102: PUSH
60103: LD_EXP 69
60107: PUSH
60108: LD_VAR 0 2
60112: ARRAY
60113: PUSH
60114: LD_INT 1
60116: ARRAY
60117: PUSH
60118: LD_EXP 69
60122: PUSH
60123: LD_VAR 0 2
60127: ARRAY
60128: PUSH
60129: LD_INT 2
60131: ARRAY
60132: UNION
60133: DIFF
60134: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60135: LD_ADDR_VAR 0 6
60139: PUSH
60140: LD_EXP 85
60144: PUSH
60145: LD_VAR 0 2
60149: ARRAY
60150: PPUSH
60151: LD_INT 2
60153: PUSH
60154: LD_INT 34
60156: PUSH
60157: LD_INT 13
60159: PUSH
60160: EMPTY
60161: LIST
60162: LIST
60163: PUSH
60164: LD_INT 34
60166: PUSH
60167: LD_INT 52
60169: PUSH
60170: EMPTY
60171: LIST
60172: LIST
60173: PUSH
60174: LD_INT 34
60176: PUSH
60177: LD_EXP 54
60181: PUSH
60182: EMPTY
60183: LIST
60184: LIST
60185: PUSH
60186: EMPTY
60187: LIST
60188: LIST
60189: LIST
60190: LIST
60191: PPUSH
60192: CALL_OW 72
60196: ST_TO_ADDR
// if cranes then
60197: LD_VAR 0 6
60201: IFFALSE 60337
// begin for j in cranes do
60203: LD_ADDR_VAR 0 3
60207: PUSH
60208: LD_VAR 0 6
60212: PUSH
60213: FOR_IN
60214: IFFALSE 60335
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60216: LD_VAR 0 3
60220: PPUSH
60221: CALL_OW 256
60225: PUSH
60226: LD_INT 1000
60228: EQUAL
60229: PUSH
60230: LD_VAR 0 3
60234: PPUSH
60235: CALL_OW 314
60239: NOT
60240: AND
60241: IFFALSE 60275
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60243: LD_VAR 0 3
60247: PPUSH
60248: LD_EXP 67
60252: PUSH
60253: LD_VAR 0 2
60257: ARRAY
60258: PPUSH
60259: LD_VAR 0 3
60263: PPUSH
60264: CALL_OW 74
60268: PPUSH
60269: CALL_OW 130
60273: GO 60333
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60275: LD_VAR 0 3
60279: PPUSH
60280: CALL_OW 256
60284: PUSH
60285: LD_INT 500
60287: LESS
60288: PUSH
60289: LD_VAR 0 3
60293: PPUSH
60294: LD_EXP 90
60298: PUSH
60299: LD_VAR 0 2
60303: ARRAY
60304: PPUSH
60305: CALL_OW 308
60309: NOT
60310: AND
60311: IFFALSE 60333
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60313: LD_VAR 0 3
60317: PPUSH
60318: LD_EXP 90
60322: PUSH
60323: LD_VAR 0 2
60327: ARRAY
60328: PPUSH
60329: CALL_OW 113
// end ;
60333: GO 60213
60335: POP
60336: POP
// end ; if tmp > 3 then
60337: LD_VAR 0 5
60341: PUSH
60342: LD_INT 3
60344: GREATER
60345: IFFALSE 60365
// tmp := ShrinkArray ( tmp , 4 ) ;
60347: LD_ADDR_VAR 0 5
60351: PUSH
60352: LD_VAR 0 5
60356: PPUSH
60357: LD_INT 4
60359: PPUSH
60360: CALL 49906 0 2
60364: ST_TO_ADDR
// if not tmp then
60365: LD_VAR 0 5
60369: NOT
60370: IFFALSE 60374
// continue ;
60372: GO 59804
// for j in tmp do
60374: LD_ADDR_VAR 0 3
60378: PUSH
60379: LD_VAR 0 5
60383: PUSH
60384: FOR_IN
60385: IFFALSE 60644
// begin if IsInUnit ( j ) then
60387: LD_VAR 0 3
60391: PPUSH
60392: CALL_OW 310
60396: IFFALSE 60407
// ComExitBuilding ( j ) ;
60398: LD_VAR 0 3
60402: PPUSH
60403: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60407: LD_VAR 0 3
60411: PUSH
60412: LD_EXP 68
60416: PUSH
60417: LD_VAR 0 2
60421: ARRAY
60422: IN
60423: NOT
60424: IFFALSE 60482
// begin SetTag ( j , 101 ) ;
60426: LD_VAR 0 3
60430: PPUSH
60431: LD_INT 101
60433: PPUSH
60434: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60438: LD_ADDR_EXP 68
60442: PUSH
60443: LD_EXP 68
60447: PPUSH
60448: LD_VAR 0 2
60452: PUSH
60453: LD_EXP 68
60457: PUSH
60458: LD_VAR 0 2
60462: ARRAY
60463: PUSH
60464: LD_INT 1
60466: PLUS
60467: PUSH
60468: EMPTY
60469: LIST
60470: LIST
60471: PPUSH
60472: LD_VAR 0 3
60476: PPUSH
60477: CALL 18548 0 3
60481: ST_TO_ADDR
// end ; wait ( 1 ) ;
60482: LD_INT 1
60484: PPUSH
60485: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60489: LD_ADDR_VAR 0 7
60493: PUSH
60494: LD_EXP 67
60498: PUSH
60499: LD_VAR 0 2
60503: ARRAY
60504: ST_TO_ADDR
// if mc_scan [ i ] then
60505: LD_EXP 89
60509: PUSH
60510: LD_VAR 0 2
60514: ARRAY
60515: IFFALSE 60577
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60517: LD_ADDR_VAR 0 7
60521: PUSH
60522: LD_EXP 67
60526: PUSH
60527: LD_VAR 0 2
60531: ARRAY
60532: PPUSH
60533: LD_INT 3
60535: PUSH
60536: LD_INT 30
60538: PUSH
60539: LD_INT 32
60541: PUSH
60542: EMPTY
60543: LIST
60544: LIST
60545: PUSH
60546: LD_INT 30
60548: PUSH
60549: LD_INT 33
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: PUSH
60556: LD_INT 30
60558: PUSH
60559: LD_INT 31
60561: PUSH
60562: EMPTY
60563: LIST
60564: LIST
60565: PUSH
60566: EMPTY
60567: LIST
60568: LIST
60569: LIST
60570: LIST
60571: PPUSH
60572: CALL_OW 72
60576: ST_TO_ADDR
// if not to_repair_tmp then
60577: LD_VAR 0 7
60581: NOT
60582: IFFALSE 60586
// continue ;
60584: GO 60384
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60586: LD_ADDR_VAR 0 8
60590: PUSH
60591: LD_VAR 0 7
60595: PPUSH
60596: LD_VAR 0 3
60600: PPUSH
60601: CALL_OW 74
60605: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60606: LD_VAR 0 8
60610: PPUSH
60611: LD_INT 16
60613: PPUSH
60614: CALL 21141 0 2
60618: PUSH
60619: LD_INT 4
60621: ARRAY
60622: PUSH
60623: LD_INT 10
60625: LESS
60626: IFFALSE 60642
// ComRepairBuilding ( j , to_repair ) ;
60628: LD_VAR 0 3
60632: PPUSH
60633: LD_VAR 0 8
60637: PPUSH
60638: CALL_OW 130
// end ;
60642: GO 60384
60644: POP
60645: POP
// end ;
60646: GO 59804
60648: POP
60649: POP
// end ;
60650: LD_VAR 0 1
60654: RET
// export function MC_Heal ; var i , j , tmp ; begin
60655: LD_INT 0
60657: PPUSH
60658: PPUSH
60659: PPUSH
60660: PPUSH
// if not mc_bases then
60661: LD_EXP 66
60665: NOT
60666: IFFALSE 60670
// exit ;
60668: GO 61072
// for i = 1 to mc_bases do
60670: LD_ADDR_VAR 0 2
60674: PUSH
60675: DOUBLE
60676: LD_INT 1
60678: DEC
60679: ST_TO_ADDR
60680: LD_EXP 66
60684: PUSH
60685: FOR_TO
60686: IFFALSE 61070
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60688: LD_EXP 69
60692: PUSH
60693: LD_VAR 0 2
60697: ARRAY
60698: PUSH
60699: LD_INT 1
60701: ARRAY
60702: NOT
60703: PUSH
60704: LD_EXP 69
60708: PUSH
60709: LD_VAR 0 2
60713: ARRAY
60714: PUSH
60715: LD_INT 2
60717: ARRAY
60718: NOT
60719: AND
60720: IFFALSE 60758
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60722: LD_ADDR_EXP 70
60726: PUSH
60727: LD_EXP 70
60731: PPUSH
60732: LD_VAR 0 2
60736: PPUSH
60737: EMPTY
60738: PPUSH
60739: CALL_OW 1
60743: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60744: LD_VAR 0 2
60748: PPUSH
60749: LD_INT 102
60751: PPUSH
60752: CALL 54893 0 2
// continue ;
60756: GO 60685
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60758: LD_ADDR_VAR 0 4
60762: PUSH
60763: LD_EXP 66
60767: PUSH
60768: LD_VAR 0 2
60772: ARRAY
60773: PPUSH
60774: LD_INT 25
60776: PUSH
60777: LD_INT 4
60779: PUSH
60780: EMPTY
60781: LIST
60782: LIST
60783: PPUSH
60784: CALL_OW 72
60788: ST_TO_ADDR
// if not tmp then
60789: LD_VAR 0 4
60793: NOT
60794: IFFALSE 60798
// continue ;
60796: GO 60685
// if mc_taming [ i ] then
60798: LD_EXP 97
60802: PUSH
60803: LD_VAR 0 2
60807: ARRAY
60808: IFFALSE 60832
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60810: LD_ADDR_EXP 97
60814: PUSH
60815: LD_EXP 97
60819: PPUSH
60820: LD_VAR 0 2
60824: PPUSH
60825: EMPTY
60826: PPUSH
60827: CALL_OW 1
60831: ST_TO_ADDR
// for j in tmp do
60832: LD_ADDR_VAR 0 3
60836: PUSH
60837: LD_VAR 0 4
60841: PUSH
60842: FOR_IN
60843: IFFALSE 61066
// begin if IsInUnit ( j ) then
60845: LD_VAR 0 3
60849: PPUSH
60850: CALL_OW 310
60854: IFFALSE 60865
// ComExitBuilding ( j ) ;
60856: LD_VAR 0 3
60860: PPUSH
60861: CALL_OW 122
// if not j in mc_healers [ i ] then
60865: LD_VAR 0 3
60869: PUSH
60870: LD_EXP 70
60874: PUSH
60875: LD_VAR 0 2
60879: ARRAY
60880: IN
60881: NOT
60882: IFFALSE 60928
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60884: LD_ADDR_EXP 70
60888: PUSH
60889: LD_EXP 70
60893: PPUSH
60894: LD_VAR 0 2
60898: PUSH
60899: LD_EXP 70
60903: PUSH
60904: LD_VAR 0 2
60908: ARRAY
60909: PUSH
60910: LD_INT 1
60912: PLUS
60913: PUSH
60914: EMPTY
60915: LIST
60916: LIST
60917: PPUSH
60918: LD_VAR 0 3
60922: PPUSH
60923: CALL 18548 0 3
60927: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60928: LD_VAR 0 3
60932: PPUSH
60933: CALL_OW 110
60937: PUSH
60938: LD_INT 102
60940: NONEQUAL
60941: IFFALSE 60955
// SetTag ( j , 102 ) ;
60943: LD_VAR 0 3
60947: PPUSH
60948: LD_INT 102
60950: PPUSH
60951: CALL_OW 109
// Wait ( 3 ) ;
60955: LD_INT 3
60957: PPUSH
60958: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60962: LD_EXP 69
60966: PUSH
60967: LD_VAR 0 2
60971: ARRAY
60972: PUSH
60973: LD_INT 1
60975: ARRAY
60976: IFFALSE 61008
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60978: LD_VAR 0 3
60982: PPUSH
60983: LD_EXP 69
60987: PUSH
60988: LD_VAR 0 2
60992: ARRAY
60993: PUSH
60994: LD_INT 1
60996: ARRAY
60997: PUSH
60998: LD_INT 1
61000: ARRAY
61001: PPUSH
61002: CALL_OW 128
61006: GO 61064
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61008: LD_VAR 0 3
61012: PPUSH
61013: CALL_OW 314
61017: NOT
61018: PUSH
61019: LD_EXP 69
61023: PUSH
61024: LD_VAR 0 2
61028: ARRAY
61029: PUSH
61030: LD_INT 2
61032: ARRAY
61033: AND
61034: IFFALSE 61064
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61036: LD_VAR 0 3
61040: PPUSH
61041: LD_EXP 69
61045: PUSH
61046: LD_VAR 0 2
61050: ARRAY
61051: PUSH
61052: LD_INT 2
61054: ARRAY
61055: PUSH
61056: LD_INT 1
61058: ARRAY
61059: PPUSH
61060: CALL_OW 128
// end ;
61064: GO 60842
61066: POP
61067: POP
// end ;
61068: GO 60685
61070: POP
61071: POP
// end ;
61072: LD_VAR 0 1
61076: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61077: LD_INT 0
61079: PPUSH
61080: PPUSH
61081: PPUSH
61082: PPUSH
61083: PPUSH
// if not mc_bases then
61084: LD_EXP 66
61088: NOT
61089: IFFALSE 61093
// exit ;
61091: GO 62236
// for i = 1 to mc_bases do
61093: LD_ADDR_VAR 0 2
61097: PUSH
61098: DOUBLE
61099: LD_INT 1
61101: DEC
61102: ST_TO_ADDR
61103: LD_EXP 66
61107: PUSH
61108: FOR_TO
61109: IFFALSE 62234
// begin if mc_scan [ i ] then
61111: LD_EXP 89
61115: PUSH
61116: LD_VAR 0 2
61120: ARRAY
61121: IFFALSE 61125
// continue ;
61123: GO 61108
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61125: LD_EXP 71
61129: PUSH
61130: LD_VAR 0 2
61134: ARRAY
61135: NOT
61136: PUSH
61137: LD_EXP 73
61141: PUSH
61142: LD_VAR 0 2
61146: ARRAY
61147: NOT
61148: AND
61149: PUSH
61150: LD_EXP 72
61154: PUSH
61155: LD_VAR 0 2
61159: ARRAY
61160: AND
61161: IFFALSE 61199
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61163: LD_ADDR_EXP 72
61167: PUSH
61168: LD_EXP 72
61172: PPUSH
61173: LD_VAR 0 2
61177: PPUSH
61178: EMPTY
61179: PPUSH
61180: CALL_OW 1
61184: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61185: LD_VAR 0 2
61189: PPUSH
61190: LD_INT 103
61192: PPUSH
61193: CALL 54893 0 2
// continue ;
61197: GO 61108
// end ; if mc_construct_list [ i ] then
61199: LD_EXP 73
61203: PUSH
61204: LD_VAR 0 2
61208: ARRAY
61209: IFFALSE 61429
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61211: LD_ADDR_VAR 0 4
61215: PUSH
61216: LD_EXP 66
61220: PUSH
61221: LD_VAR 0 2
61225: ARRAY
61226: PPUSH
61227: LD_INT 25
61229: PUSH
61230: LD_INT 2
61232: PUSH
61233: EMPTY
61234: LIST
61235: LIST
61236: PPUSH
61237: CALL_OW 72
61241: PUSH
61242: LD_EXP 68
61246: PUSH
61247: LD_VAR 0 2
61251: ARRAY
61252: DIFF
61253: ST_TO_ADDR
// if not tmp then
61254: LD_VAR 0 4
61258: NOT
61259: IFFALSE 61263
// continue ;
61261: GO 61108
// for j in tmp do
61263: LD_ADDR_VAR 0 3
61267: PUSH
61268: LD_VAR 0 4
61272: PUSH
61273: FOR_IN
61274: IFFALSE 61425
// begin if not mc_builders [ i ] then
61276: LD_EXP 72
61280: PUSH
61281: LD_VAR 0 2
61285: ARRAY
61286: NOT
61287: IFFALSE 61345
// begin SetTag ( j , 103 ) ;
61289: LD_VAR 0 3
61293: PPUSH
61294: LD_INT 103
61296: PPUSH
61297: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61301: LD_ADDR_EXP 72
61305: PUSH
61306: LD_EXP 72
61310: PPUSH
61311: LD_VAR 0 2
61315: PUSH
61316: LD_EXP 72
61320: PUSH
61321: LD_VAR 0 2
61325: ARRAY
61326: PUSH
61327: LD_INT 1
61329: PLUS
61330: PUSH
61331: EMPTY
61332: LIST
61333: LIST
61334: PPUSH
61335: LD_VAR 0 3
61339: PPUSH
61340: CALL 18548 0 3
61344: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61345: LD_VAR 0 3
61349: PPUSH
61350: CALL_OW 310
61354: IFFALSE 61365
// ComExitBuilding ( j ) ;
61356: LD_VAR 0 3
61360: PPUSH
61361: CALL_OW 122
// wait ( 3 ) ;
61365: LD_INT 3
61367: PPUSH
61368: CALL_OW 67
// if not mc_construct_list [ i ] then
61372: LD_EXP 73
61376: PUSH
61377: LD_VAR 0 2
61381: ARRAY
61382: NOT
61383: IFFALSE 61387
// break ;
61385: GO 61425
// if not HasTask ( j ) then
61387: LD_VAR 0 3
61391: PPUSH
61392: CALL_OW 314
61396: NOT
61397: IFFALSE 61423
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61399: LD_VAR 0 3
61403: PPUSH
61404: LD_EXP 73
61408: PUSH
61409: LD_VAR 0 2
61413: ARRAY
61414: PUSH
61415: LD_INT 1
61417: ARRAY
61418: PPUSH
61419: CALL 21399 0 2
// end ;
61423: GO 61273
61425: POP
61426: POP
// end else
61427: GO 62232
// if mc_build_list [ i ] then
61429: LD_EXP 71
61433: PUSH
61434: LD_VAR 0 2
61438: ARRAY
61439: IFFALSE 62232
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61441: LD_ADDR_VAR 0 5
61445: PUSH
61446: LD_EXP 66
61450: PUSH
61451: LD_VAR 0 2
61455: ARRAY
61456: PPUSH
61457: LD_INT 2
61459: PUSH
61460: LD_INT 30
61462: PUSH
61463: LD_INT 0
61465: PUSH
61466: EMPTY
61467: LIST
61468: LIST
61469: PUSH
61470: LD_INT 30
61472: PUSH
61473: LD_INT 1
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PUSH
61480: EMPTY
61481: LIST
61482: LIST
61483: LIST
61484: PPUSH
61485: CALL_OW 72
61489: ST_TO_ADDR
// if depot then
61490: LD_VAR 0 5
61494: IFFALSE 61512
// depot := depot [ 1 ] else
61496: LD_ADDR_VAR 0 5
61500: PUSH
61501: LD_VAR 0 5
61505: PUSH
61506: LD_INT 1
61508: ARRAY
61509: ST_TO_ADDR
61510: GO 61520
// depot := 0 ;
61512: LD_ADDR_VAR 0 5
61516: PUSH
61517: LD_INT 0
61519: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61520: LD_EXP 71
61524: PUSH
61525: LD_VAR 0 2
61529: ARRAY
61530: PUSH
61531: LD_INT 1
61533: ARRAY
61534: PUSH
61535: LD_INT 1
61537: ARRAY
61538: PPUSH
61539: CALL 21229 0 1
61543: PUSH
61544: LD_EXP 66
61548: PUSH
61549: LD_VAR 0 2
61553: ARRAY
61554: PPUSH
61555: LD_INT 2
61557: PUSH
61558: LD_INT 30
61560: PUSH
61561: LD_INT 2
61563: PUSH
61564: EMPTY
61565: LIST
61566: LIST
61567: PUSH
61568: LD_INT 30
61570: PUSH
61571: LD_INT 3
61573: PUSH
61574: EMPTY
61575: LIST
61576: LIST
61577: PUSH
61578: EMPTY
61579: LIST
61580: LIST
61581: LIST
61582: PPUSH
61583: CALL_OW 72
61587: NOT
61588: AND
61589: IFFALSE 61694
// begin for j = 1 to mc_build_list [ i ] do
61591: LD_ADDR_VAR 0 3
61595: PUSH
61596: DOUBLE
61597: LD_INT 1
61599: DEC
61600: ST_TO_ADDR
61601: LD_EXP 71
61605: PUSH
61606: LD_VAR 0 2
61610: ARRAY
61611: PUSH
61612: FOR_TO
61613: IFFALSE 61692
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61615: LD_EXP 71
61619: PUSH
61620: LD_VAR 0 2
61624: ARRAY
61625: PUSH
61626: LD_VAR 0 3
61630: ARRAY
61631: PUSH
61632: LD_INT 1
61634: ARRAY
61635: PUSH
61636: LD_INT 2
61638: EQUAL
61639: IFFALSE 61690
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61641: LD_ADDR_EXP 71
61645: PUSH
61646: LD_EXP 71
61650: PPUSH
61651: LD_VAR 0 2
61655: PPUSH
61656: LD_EXP 71
61660: PUSH
61661: LD_VAR 0 2
61665: ARRAY
61666: PPUSH
61667: LD_VAR 0 3
61671: PPUSH
61672: LD_INT 1
61674: PPUSH
61675: LD_INT 0
61677: PPUSH
61678: CALL 17966 0 4
61682: PPUSH
61683: CALL_OW 1
61687: ST_TO_ADDR
// break ;
61688: GO 61692
// end ;
61690: GO 61612
61692: POP
61693: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61694: LD_EXP 71
61698: PUSH
61699: LD_VAR 0 2
61703: ARRAY
61704: PUSH
61705: LD_INT 1
61707: ARRAY
61708: PUSH
61709: LD_INT 1
61711: ARRAY
61712: PUSH
61713: LD_INT 0
61715: EQUAL
61716: PUSH
61717: LD_VAR 0 5
61721: PUSH
61722: LD_VAR 0 5
61726: PPUSH
61727: LD_EXP 71
61731: PUSH
61732: LD_VAR 0 2
61736: ARRAY
61737: PUSH
61738: LD_INT 1
61740: ARRAY
61741: PUSH
61742: LD_INT 1
61744: ARRAY
61745: PPUSH
61746: LD_EXP 71
61750: PUSH
61751: LD_VAR 0 2
61755: ARRAY
61756: PUSH
61757: LD_INT 1
61759: ARRAY
61760: PUSH
61761: LD_INT 2
61763: ARRAY
61764: PPUSH
61765: LD_EXP 71
61769: PUSH
61770: LD_VAR 0 2
61774: ARRAY
61775: PUSH
61776: LD_INT 1
61778: ARRAY
61779: PUSH
61780: LD_INT 3
61782: ARRAY
61783: PPUSH
61784: LD_EXP 71
61788: PUSH
61789: LD_VAR 0 2
61793: ARRAY
61794: PUSH
61795: LD_INT 1
61797: ARRAY
61798: PUSH
61799: LD_INT 4
61801: ARRAY
61802: PPUSH
61803: CALL 25963 0 5
61807: AND
61808: OR
61809: IFFALSE 62090
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61811: LD_ADDR_VAR 0 4
61815: PUSH
61816: LD_EXP 66
61820: PUSH
61821: LD_VAR 0 2
61825: ARRAY
61826: PPUSH
61827: LD_INT 25
61829: PUSH
61830: LD_INT 2
61832: PUSH
61833: EMPTY
61834: LIST
61835: LIST
61836: PPUSH
61837: CALL_OW 72
61841: PUSH
61842: LD_EXP 68
61846: PUSH
61847: LD_VAR 0 2
61851: ARRAY
61852: DIFF
61853: ST_TO_ADDR
// if not tmp then
61854: LD_VAR 0 4
61858: NOT
61859: IFFALSE 61863
// continue ;
61861: GO 61108
// for j in tmp do
61863: LD_ADDR_VAR 0 3
61867: PUSH
61868: LD_VAR 0 4
61872: PUSH
61873: FOR_IN
61874: IFFALSE 62086
// begin if not mc_builders [ i ] then
61876: LD_EXP 72
61880: PUSH
61881: LD_VAR 0 2
61885: ARRAY
61886: NOT
61887: IFFALSE 61945
// begin SetTag ( j , 103 ) ;
61889: LD_VAR 0 3
61893: PPUSH
61894: LD_INT 103
61896: PPUSH
61897: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61901: LD_ADDR_EXP 72
61905: PUSH
61906: LD_EXP 72
61910: PPUSH
61911: LD_VAR 0 2
61915: PUSH
61916: LD_EXP 72
61920: PUSH
61921: LD_VAR 0 2
61925: ARRAY
61926: PUSH
61927: LD_INT 1
61929: PLUS
61930: PUSH
61931: EMPTY
61932: LIST
61933: LIST
61934: PPUSH
61935: LD_VAR 0 3
61939: PPUSH
61940: CALL 18548 0 3
61944: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61945: LD_VAR 0 3
61949: PPUSH
61950: CALL_OW 310
61954: IFFALSE 61965
// ComExitBuilding ( j ) ;
61956: LD_VAR 0 3
61960: PPUSH
61961: CALL_OW 122
// wait ( 3 ) ;
61965: LD_INT 3
61967: PPUSH
61968: CALL_OW 67
// if not mc_build_list [ i ] then
61972: LD_EXP 71
61976: PUSH
61977: LD_VAR 0 2
61981: ARRAY
61982: NOT
61983: IFFALSE 61987
// break ;
61985: GO 62086
// if not HasTask ( j ) then
61987: LD_VAR 0 3
61991: PPUSH
61992: CALL_OW 314
61996: NOT
61997: IFFALSE 62084
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61999: LD_VAR 0 3
62003: PPUSH
62004: LD_EXP 71
62008: PUSH
62009: LD_VAR 0 2
62013: ARRAY
62014: PUSH
62015: LD_INT 1
62017: ARRAY
62018: PUSH
62019: LD_INT 1
62021: ARRAY
62022: PPUSH
62023: LD_EXP 71
62027: PUSH
62028: LD_VAR 0 2
62032: ARRAY
62033: PUSH
62034: LD_INT 1
62036: ARRAY
62037: PUSH
62038: LD_INT 2
62040: ARRAY
62041: PPUSH
62042: LD_EXP 71
62046: PUSH
62047: LD_VAR 0 2
62051: ARRAY
62052: PUSH
62053: LD_INT 1
62055: ARRAY
62056: PUSH
62057: LD_INT 3
62059: ARRAY
62060: PPUSH
62061: LD_EXP 71
62065: PUSH
62066: LD_VAR 0 2
62070: ARRAY
62071: PUSH
62072: LD_INT 1
62074: ARRAY
62075: PUSH
62076: LD_INT 4
62078: ARRAY
62079: PPUSH
62080: CALL_OW 145
// end ;
62084: GO 61873
62086: POP
62087: POP
// end else
62088: GO 62232
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62090: LD_EXP 66
62094: PUSH
62095: LD_VAR 0 2
62099: ARRAY
62100: PPUSH
62101: LD_EXP 71
62105: PUSH
62106: LD_VAR 0 2
62110: ARRAY
62111: PUSH
62112: LD_INT 1
62114: ARRAY
62115: PUSH
62116: LD_INT 1
62118: ARRAY
62119: PPUSH
62120: LD_EXP 71
62124: PUSH
62125: LD_VAR 0 2
62129: ARRAY
62130: PUSH
62131: LD_INT 1
62133: ARRAY
62134: PUSH
62135: LD_INT 2
62137: ARRAY
62138: PPUSH
62139: LD_EXP 71
62143: PUSH
62144: LD_VAR 0 2
62148: ARRAY
62149: PUSH
62150: LD_INT 1
62152: ARRAY
62153: PUSH
62154: LD_INT 3
62156: ARRAY
62157: PPUSH
62158: LD_EXP 71
62162: PUSH
62163: LD_VAR 0 2
62167: ARRAY
62168: PUSH
62169: LD_INT 1
62171: ARRAY
62172: PUSH
62173: LD_INT 4
62175: ARRAY
62176: PPUSH
62177: CALL 25299 0 5
62181: NOT
62182: IFFALSE 62232
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62184: LD_ADDR_EXP 71
62188: PUSH
62189: LD_EXP 71
62193: PPUSH
62194: LD_VAR 0 2
62198: PPUSH
62199: LD_EXP 71
62203: PUSH
62204: LD_VAR 0 2
62208: ARRAY
62209: PPUSH
62210: LD_INT 1
62212: PPUSH
62213: LD_INT 1
62215: NEG
62216: PPUSH
62217: LD_INT 0
62219: PPUSH
62220: CALL 17966 0 4
62224: PPUSH
62225: CALL_OW 1
62229: ST_TO_ADDR
// continue ;
62230: GO 61108
// end ; end ; end ;
62232: GO 61108
62234: POP
62235: POP
// end ;
62236: LD_VAR 0 1
62240: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62241: LD_INT 0
62243: PPUSH
62244: PPUSH
62245: PPUSH
62246: PPUSH
62247: PPUSH
62248: PPUSH
// if not mc_bases then
62249: LD_EXP 66
62253: NOT
62254: IFFALSE 62258
// exit ;
62256: GO 62685
// for i = 1 to mc_bases do
62258: LD_ADDR_VAR 0 2
62262: PUSH
62263: DOUBLE
62264: LD_INT 1
62266: DEC
62267: ST_TO_ADDR
62268: LD_EXP 66
62272: PUSH
62273: FOR_TO
62274: IFFALSE 62683
// begin tmp := mc_build_upgrade [ i ] ;
62276: LD_ADDR_VAR 0 4
62280: PUSH
62281: LD_EXP 98
62285: PUSH
62286: LD_VAR 0 2
62290: ARRAY
62291: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62292: LD_ADDR_VAR 0 6
62296: PUSH
62297: LD_EXP 99
62301: PUSH
62302: LD_VAR 0 2
62306: ARRAY
62307: PPUSH
62308: LD_INT 2
62310: PUSH
62311: LD_INT 30
62313: PUSH
62314: LD_INT 6
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: PUSH
62321: LD_INT 30
62323: PUSH
62324: LD_INT 7
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: PUSH
62331: EMPTY
62332: LIST
62333: LIST
62334: LIST
62335: PPUSH
62336: CALL_OW 72
62340: ST_TO_ADDR
// if not tmp and not lab then
62341: LD_VAR 0 4
62345: NOT
62346: PUSH
62347: LD_VAR 0 6
62351: NOT
62352: AND
62353: IFFALSE 62357
// continue ;
62355: GO 62273
// if tmp then
62357: LD_VAR 0 4
62361: IFFALSE 62481
// for j in tmp do
62363: LD_ADDR_VAR 0 3
62367: PUSH
62368: LD_VAR 0 4
62372: PUSH
62373: FOR_IN
62374: IFFALSE 62479
// begin if UpgradeCost ( j ) then
62376: LD_VAR 0 3
62380: PPUSH
62381: CALL 24959 0 1
62385: IFFALSE 62477
// begin ComUpgrade ( j ) ;
62387: LD_VAR 0 3
62391: PPUSH
62392: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62396: LD_ADDR_EXP 98
62400: PUSH
62401: LD_EXP 98
62405: PPUSH
62406: LD_VAR 0 2
62410: PPUSH
62411: LD_EXP 98
62415: PUSH
62416: LD_VAR 0 2
62420: ARRAY
62421: PUSH
62422: LD_VAR 0 3
62426: DIFF
62427: PPUSH
62428: CALL_OW 1
62432: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62433: LD_ADDR_EXP 73
62437: PUSH
62438: LD_EXP 73
62442: PPUSH
62443: LD_VAR 0 2
62447: PUSH
62448: LD_EXP 73
62452: PUSH
62453: LD_VAR 0 2
62457: ARRAY
62458: PUSH
62459: LD_INT 1
62461: PLUS
62462: PUSH
62463: EMPTY
62464: LIST
62465: LIST
62466: PPUSH
62467: LD_VAR 0 3
62471: PPUSH
62472: CALL 18548 0 3
62476: ST_TO_ADDR
// end ; end ;
62477: GO 62373
62479: POP
62480: POP
// if not lab or not mc_lab_upgrade [ i ] then
62481: LD_VAR 0 6
62485: NOT
62486: PUSH
62487: LD_EXP 100
62491: PUSH
62492: LD_VAR 0 2
62496: ARRAY
62497: NOT
62498: OR
62499: IFFALSE 62503
// continue ;
62501: GO 62273
// for j in lab do
62503: LD_ADDR_VAR 0 3
62507: PUSH
62508: LD_VAR 0 6
62512: PUSH
62513: FOR_IN
62514: IFFALSE 62679
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62516: LD_VAR 0 3
62520: PPUSH
62521: CALL_OW 266
62525: PUSH
62526: LD_INT 6
62528: PUSH
62529: LD_INT 7
62531: PUSH
62532: EMPTY
62533: LIST
62534: LIST
62535: IN
62536: PUSH
62537: LD_VAR 0 3
62541: PPUSH
62542: CALL_OW 461
62546: PUSH
62547: LD_INT 1
62549: NONEQUAL
62550: AND
62551: IFFALSE 62677
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62553: LD_VAR 0 3
62557: PPUSH
62558: LD_EXP 100
62562: PUSH
62563: LD_VAR 0 2
62567: ARRAY
62568: PUSH
62569: LD_INT 1
62571: ARRAY
62572: PPUSH
62573: CALL 25164 0 2
62577: IFFALSE 62677
// begin ComCancel ( j ) ;
62579: LD_VAR 0 3
62583: PPUSH
62584: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62588: LD_VAR 0 3
62592: PPUSH
62593: LD_EXP 100
62597: PUSH
62598: LD_VAR 0 2
62602: ARRAY
62603: PUSH
62604: LD_INT 1
62606: ARRAY
62607: PPUSH
62608: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62612: LD_VAR 0 3
62616: PUSH
62617: LD_EXP 73
62621: PUSH
62622: LD_VAR 0 2
62626: ARRAY
62627: IN
62628: NOT
62629: IFFALSE 62675
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62631: LD_ADDR_EXP 73
62635: PUSH
62636: LD_EXP 73
62640: PPUSH
62641: LD_VAR 0 2
62645: PUSH
62646: LD_EXP 73
62650: PUSH
62651: LD_VAR 0 2
62655: ARRAY
62656: PUSH
62657: LD_INT 1
62659: PLUS
62660: PUSH
62661: EMPTY
62662: LIST
62663: LIST
62664: PPUSH
62665: LD_VAR 0 3
62669: PPUSH
62670: CALL 18548 0 3
62674: ST_TO_ADDR
// break ;
62675: GO 62679
// end ; end ; end ;
62677: GO 62513
62679: POP
62680: POP
// end ;
62681: GO 62273
62683: POP
62684: POP
// end ;
62685: LD_VAR 0 1
62689: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62690: LD_INT 0
62692: PPUSH
62693: PPUSH
62694: PPUSH
62695: PPUSH
62696: PPUSH
62697: PPUSH
62698: PPUSH
62699: PPUSH
62700: PPUSH
// if not mc_bases then
62701: LD_EXP 66
62705: NOT
62706: IFFALSE 62710
// exit ;
62708: GO 63115
// for i = 1 to mc_bases do
62710: LD_ADDR_VAR 0 2
62714: PUSH
62715: DOUBLE
62716: LD_INT 1
62718: DEC
62719: ST_TO_ADDR
62720: LD_EXP 66
62724: PUSH
62725: FOR_TO
62726: IFFALSE 63113
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62728: LD_EXP 74
62732: PUSH
62733: LD_VAR 0 2
62737: ARRAY
62738: NOT
62739: PUSH
62740: LD_EXP 66
62744: PUSH
62745: LD_VAR 0 2
62749: ARRAY
62750: PPUSH
62751: LD_INT 30
62753: PUSH
62754: LD_INT 3
62756: PUSH
62757: EMPTY
62758: LIST
62759: LIST
62760: PPUSH
62761: CALL_OW 72
62765: NOT
62766: OR
62767: IFFALSE 62771
// continue ;
62769: GO 62725
// busy := false ;
62771: LD_ADDR_VAR 0 8
62775: PUSH
62776: LD_INT 0
62778: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62779: LD_ADDR_VAR 0 4
62783: PUSH
62784: LD_EXP 66
62788: PUSH
62789: LD_VAR 0 2
62793: ARRAY
62794: PPUSH
62795: LD_INT 30
62797: PUSH
62798: LD_INT 3
62800: PUSH
62801: EMPTY
62802: LIST
62803: LIST
62804: PPUSH
62805: CALL_OW 72
62809: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62810: LD_ADDR_VAR 0 6
62814: PUSH
62815: LD_EXP 74
62819: PUSH
62820: LD_VAR 0 2
62824: ARRAY
62825: PPUSH
62826: LD_INT 2
62828: PUSH
62829: LD_INT 30
62831: PUSH
62832: LD_INT 32
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: PUSH
62839: LD_INT 30
62841: PUSH
62842: LD_INT 33
62844: PUSH
62845: EMPTY
62846: LIST
62847: LIST
62848: PUSH
62849: EMPTY
62850: LIST
62851: LIST
62852: LIST
62853: PPUSH
62854: CALL_OW 72
62858: ST_TO_ADDR
// if not t then
62859: LD_VAR 0 6
62863: NOT
62864: IFFALSE 62868
// continue ;
62866: GO 62725
// for j in tmp do
62868: LD_ADDR_VAR 0 3
62872: PUSH
62873: LD_VAR 0 4
62877: PUSH
62878: FOR_IN
62879: IFFALSE 62909
// if not BuildingStatus ( j ) = bs_idle then
62881: LD_VAR 0 3
62885: PPUSH
62886: CALL_OW 461
62890: PUSH
62891: LD_INT 2
62893: EQUAL
62894: NOT
62895: IFFALSE 62907
// begin busy := true ;
62897: LD_ADDR_VAR 0 8
62901: PUSH
62902: LD_INT 1
62904: ST_TO_ADDR
// break ;
62905: GO 62909
// end ;
62907: GO 62878
62909: POP
62910: POP
// if busy then
62911: LD_VAR 0 8
62915: IFFALSE 62919
// continue ;
62917: GO 62725
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62919: LD_ADDR_VAR 0 7
62923: PUSH
62924: LD_VAR 0 6
62928: PPUSH
62929: LD_INT 35
62931: PUSH
62932: LD_INT 0
62934: PUSH
62935: EMPTY
62936: LIST
62937: LIST
62938: PPUSH
62939: CALL_OW 72
62943: ST_TO_ADDR
// if tw then
62944: LD_VAR 0 7
62948: IFFALSE 63025
// begin tw := tw [ 1 ] ;
62950: LD_ADDR_VAR 0 7
62954: PUSH
62955: LD_VAR 0 7
62959: PUSH
62960: LD_INT 1
62962: ARRAY
62963: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62964: LD_ADDR_VAR 0 9
62968: PUSH
62969: LD_VAR 0 7
62973: PPUSH
62974: LD_EXP 91
62978: PUSH
62979: LD_VAR 0 2
62983: ARRAY
62984: PPUSH
62985: CALL 23518 0 2
62989: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62990: LD_EXP 105
62994: PUSH
62995: LD_VAR 0 2
62999: ARRAY
63000: IFFALSE 63023
// if not weapon in mc_allowed_tower_weapons [ i ] then
63002: LD_VAR 0 9
63006: PUSH
63007: LD_EXP 105
63011: PUSH
63012: LD_VAR 0 2
63016: ARRAY
63017: IN
63018: NOT
63019: IFFALSE 63023
// continue ;
63021: GO 62725
// end else
63023: GO 63088
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63025: LD_ADDR_VAR 0 5
63029: PUSH
63030: LD_EXP 74
63034: PUSH
63035: LD_VAR 0 2
63039: ARRAY
63040: PPUSH
63041: LD_VAR 0 4
63045: PPUSH
63046: CALL 49139 0 2
63050: ST_TO_ADDR
// if not tmp2 then
63051: LD_VAR 0 5
63055: NOT
63056: IFFALSE 63060
// continue ;
63058: GO 62725
// tw := tmp2 [ 1 ] ;
63060: LD_ADDR_VAR 0 7
63064: PUSH
63065: LD_VAR 0 5
63069: PUSH
63070: LD_INT 1
63072: ARRAY
63073: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63074: LD_ADDR_VAR 0 9
63078: PUSH
63079: LD_VAR 0 5
63083: PUSH
63084: LD_INT 2
63086: ARRAY
63087: ST_TO_ADDR
// end ; if not weapon then
63088: LD_VAR 0 9
63092: NOT
63093: IFFALSE 63097
// continue ;
63095: GO 62725
// ComPlaceWeapon ( tw , weapon ) ;
63097: LD_VAR 0 7
63101: PPUSH
63102: LD_VAR 0 9
63106: PPUSH
63107: CALL_OW 148
// end ;
63111: GO 62725
63113: POP
63114: POP
// end ;
63115: LD_VAR 0 1
63119: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
63120: LD_INT 0
63122: PPUSH
63123: PPUSH
63124: PPUSH
63125: PPUSH
63126: PPUSH
63127: PPUSH
// if not mc_bases then
63128: LD_EXP 66
63132: NOT
63133: IFFALSE 63137
// exit ;
63135: GO 63913
// for i = 1 to mc_bases do
63137: LD_ADDR_VAR 0 2
63141: PUSH
63142: DOUBLE
63143: LD_INT 1
63145: DEC
63146: ST_TO_ADDR
63147: LD_EXP 66
63151: PUSH
63152: FOR_TO
63153: IFFALSE 63911
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63155: LD_EXP 79
63159: PUSH
63160: LD_VAR 0 2
63164: ARRAY
63165: NOT
63166: PUSH
63167: LD_EXP 79
63171: PUSH
63172: LD_VAR 0 2
63176: ARRAY
63177: PUSH
63178: LD_EXP 80
63182: PUSH
63183: LD_VAR 0 2
63187: ARRAY
63188: EQUAL
63189: OR
63190: PUSH
63191: LD_EXP 89
63195: PUSH
63196: LD_VAR 0 2
63200: ARRAY
63201: OR
63202: IFFALSE 63206
// continue ;
63204: GO 63152
// if mc_miners [ i ] then
63206: LD_EXP 80
63210: PUSH
63211: LD_VAR 0 2
63215: ARRAY
63216: IFFALSE 63598
// begin for j = mc_miners [ i ] downto 1 do
63218: LD_ADDR_VAR 0 3
63222: PUSH
63223: DOUBLE
63224: LD_EXP 80
63228: PUSH
63229: LD_VAR 0 2
63233: ARRAY
63234: INC
63235: ST_TO_ADDR
63236: LD_INT 1
63238: PUSH
63239: FOR_DOWNTO
63240: IFFALSE 63596
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63242: LD_EXP 80
63246: PUSH
63247: LD_VAR 0 2
63251: ARRAY
63252: PUSH
63253: LD_VAR 0 3
63257: ARRAY
63258: PPUSH
63259: CALL_OW 301
63263: PUSH
63264: LD_EXP 80
63268: PUSH
63269: LD_VAR 0 2
63273: ARRAY
63274: PUSH
63275: LD_VAR 0 3
63279: ARRAY
63280: PPUSH
63281: CALL_OW 257
63285: PUSH
63286: LD_INT 1
63288: NONEQUAL
63289: OR
63290: IFFALSE 63353
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63292: LD_ADDR_VAR 0 5
63296: PUSH
63297: LD_EXP 80
63301: PUSH
63302: LD_VAR 0 2
63306: ARRAY
63307: PUSH
63308: LD_EXP 80
63312: PUSH
63313: LD_VAR 0 2
63317: ARRAY
63318: PUSH
63319: LD_VAR 0 3
63323: ARRAY
63324: DIFF
63325: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63326: LD_ADDR_EXP 80
63330: PUSH
63331: LD_EXP 80
63335: PPUSH
63336: LD_VAR 0 2
63340: PPUSH
63341: LD_VAR 0 5
63345: PPUSH
63346: CALL_OW 1
63350: ST_TO_ADDR
// continue ;
63351: GO 63239
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63353: LD_EXP 80
63357: PUSH
63358: LD_VAR 0 2
63362: ARRAY
63363: PUSH
63364: LD_VAR 0 3
63368: ARRAY
63369: PPUSH
63370: CALL_OW 257
63374: PUSH
63375: LD_INT 1
63377: EQUAL
63378: PUSH
63379: LD_EXP 80
63383: PUSH
63384: LD_VAR 0 2
63388: ARRAY
63389: PUSH
63390: LD_VAR 0 3
63394: ARRAY
63395: PPUSH
63396: CALL_OW 459
63400: NOT
63401: AND
63402: PUSH
63403: LD_EXP 80
63407: PUSH
63408: LD_VAR 0 2
63412: ARRAY
63413: PUSH
63414: LD_VAR 0 3
63418: ARRAY
63419: PPUSH
63420: CALL_OW 314
63424: NOT
63425: AND
63426: IFFALSE 63594
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63428: LD_EXP 80
63432: PUSH
63433: LD_VAR 0 2
63437: ARRAY
63438: PUSH
63439: LD_VAR 0 3
63443: ARRAY
63444: PPUSH
63445: CALL_OW 310
63449: IFFALSE 63472
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63451: LD_EXP 80
63455: PUSH
63456: LD_VAR 0 2
63460: ARRAY
63461: PUSH
63462: LD_VAR 0 3
63466: ARRAY
63467: PPUSH
63468: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63472: LD_EXP 80
63476: PUSH
63477: LD_VAR 0 2
63481: ARRAY
63482: PUSH
63483: LD_VAR 0 3
63487: ARRAY
63488: PPUSH
63489: CALL_OW 314
63493: NOT
63494: IFFALSE 63594
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
63496: LD_EXP 80
63500: PUSH
63501: LD_VAR 0 2
63505: ARRAY
63506: PUSH
63507: LD_VAR 0 3
63511: ARRAY
63512: PPUSH
63513: LD_EXP 79
63517: PUSH
63518: LD_VAR 0 2
63522: ARRAY
63523: PUSH
63524: LD_VAR 0 3
63528: PUSH
63529: LD_EXP 79
63533: PUSH
63534: LD_VAR 0 2
63538: ARRAY
63539: MOD
63540: PUSH
63541: LD_INT 1
63543: PLUS
63544: ARRAY
63545: PUSH
63546: LD_INT 1
63548: ARRAY
63549: PPUSH
63550: LD_EXP 79
63554: PUSH
63555: LD_VAR 0 2
63559: ARRAY
63560: PUSH
63561: LD_VAR 0 3
63565: PUSH
63566: LD_EXP 79
63570: PUSH
63571: LD_VAR 0 2
63575: ARRAY
63576: MOD
63577: PUSH
63578: LD_INT 1
63580: PLUS
63581: ARRAY
63582: PUSH
63583: LD_INT 2
63585: ARRAY
63586: PPUSH
63587: LD_INT 0
63589: PPUSH
63590: CALL_OW 193
// end ; end ;
63594: GO 63239
63596: POP
63597: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63598: LD_ADDR_VAR 0 5
63602: PUSH
63603: LD_EXP 66
63607: PUSH
63608: LD_VAR 0 2
63612: ARRAY
63613: PPUSH
63614: LD_INT 2
63616: PUSH
63617: LD_INT 30
63619: PUSH
63620: LD_INT 4
63622: PUSH
63623: EMPTY
63624: LIST
63625: LIST
63626: PUSH
63627: LD_INT 30
63629: PUSH
63630: LD_INT 5
63632: PUSH
63633: EMPTY
63634: LIST
63635: LIST
63636: PUSH
63637: LD_INT 30
63639: PUSH
63640: LD_INT 32
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: PPUSH
63653: CALL_OW 72
63657: ST_TO_ADDR
// if not tmp then
63658: LD_VAR 0 5
63662: NOT
63663: IFFALSE 63667
// continue ;
63665: GO 63152
// list := [ ] ;
63667: LD_ADDR_VAR 0 6
63671: PUSH
63672: EMPTY
63673: ST_TO_ADDR
// for j in tmp do
63674: LD_ADDR_VAR 0 3
63678: PUSH
63679: LD_VAR 0 5
63683: PUSH
63684: FOR_IN
63685: IFFALSE 63754
// begin for k in UnitsInside ( j ) do
63687: LD_ADDR_VAR 0 4
63691: PUSH
63692: LD_VAR 0 3
63696: PPUSH
63697: CALL_OW 313
63701: PUSH
63702: FOR_IN
63703: IFFALSE 63750
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63705: LD_VAR 0 4
63709: PPUSH
63710: CALL_OW 257
63714: PUSH
63715: LD_INT 1
63717: EQUAL
63718: PUSH
63719: LD_VAR 0 4
63723: PPUSH
63724: CALL_OW 459
63728: NOT
63729: AND
63730: IFFALSE 63748
// list := list ^ k ;
63732: LD_ADDR_VAR 0 6
63736: PUSH
63737: LD_VAR 0 6
63741: PUSH
63742: LD_VAR 0 4
63746: ADD
63747: ST_TO_ADDR
63748: GO 63702
63750: POP
63751: POP
// end ;
63752: GO 63684
63754: POP
63755: POP
// list := list diff mc_miners [ i ] ;
63756: LD_ADDR_VAR 0 6
63760: PUSH
63761: LD_VAR 0 6
63765: PUSH
63766: LD_EXP 80
63770: PUSH
63771: LD_VAR 0 2
63775: ARRAY
63776: DIFF
63777: ST_TO_ADDR
// if not list then
63778: LD_VAR 0 6
63782: NOT
63783: IFFALSE 63787
// continue ;
63785: GO 63152
// k := mc_mines [ i ] - mc_miners [ i ] ;
63787: LD_ADDR_VAR 0 4
63791: PUSH
63792: LD_EXP 79
63796: PUSH
63797: LD_VAR 0 2
63801: ARRAY
63802: PUSH
63803: LD_EXP 80
63807: PUSH
63808: LD_VAR 0 2
63812: ARRAY
63813: MINUS
63814: ST_TO_ADDR
// if k > list then
63815: LD_VAR 0 4
63819: PUSH
63820: LD_VAR 0 6
63824: GREATER
63825: IFFALSE 63837
// k := list ;
63827: LD_ADDR_VAR 0 4
63831: PUSH
63832: LD_VAR 0 6
63836: ST_TO_ADDR
// for j = 1 to k do
63837: LD_ADDR_VAR 0 3
63841: PUSH
63842: DOUBLE
63843: LD_INT 1
63845: DEC
63846: ST_TO_ADDR
63847: LD_VAR 0 4
63851: PUSH
63852: FOR_TO
63853: IFFALSE 63907
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63855: LD_ADDR_EXP 80
63859: PUSH
63860: LD_EXP 80
63864: PPUSH
63865: LD_VAR 0 2
63869: PUSH
63870: LD_EXP 80
63874: PUSH
63875: LD_VAR 0 2
63879: ARRAY
63880: PUSH
63881: LD_INT 1
63883: PLUS
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: PPUSH
63889: LD_VAR 0 6
63893: PUSH
63894: LD_VAR 0 3
63898: ARRAY
63899: PPUSH
63900: CALL 18548 0 3
63904: ST_TO_ADDR
63905: GO 63852
63907: POP
63908: POP
// end ;
63909: GO 63152
63911: POP
63912: POP
// end ;
63913: LD_VAR 0 1
63917: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
63918: LD_INT 0
63920: PPUSH
63921: PPUSH
63922: PPUSH
63923: PPUSH
63924: PPUSH
63925: PPUSH
63926: PPUSH
63927: PPUSH
63928: PPUSH
63929: PPUSH
// if not mc_bases then
63930: LD_EXP 66
63934: NOT
63935: IFFALSE 63939
// exit ;
63937: GO 65689
// for i = 1 to mc_bases do
63939: LD_ADDR_VAR 0 2
63943: PUSH
63944: DOUBLE
63945: LD_INT 1
63947: DEC
63948: ST_TO_ADDR
63949: LD_EXP 66
63953: PUSH
63954: FOR_TO
63955: IFFALSE 65687
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63957: LD_EXP 66
63961: PUSH
63962: LD_VAR 0 2
63966: ARRAY
63967: NOT
63968: PUSH
63969: LD_EXP 73
63973: PUSH
63974: LD_VAR 0 2
63978: ARRAY
63979: OR
63980: IFFALSE 63984
// continue ;
63982: GO 63954
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63984: LD_EXP 82
63988: PUSH
63989: LD_VAR 0 2
63993: ARRAY
63994: NOT
63995: PUSH
63996: LD_EXP 83
64000: PUSH
64001: LD_VAR 0 2
64005: ARRAY
64006: AND
64007: IFFALSE 64045
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64009: LD_ADDR_EXP 83
64013: PUSH
64014: LD_EXP 83
64018: PPUSH
64019: LD_VAR 0 2
64023: PPUSH
64024: EMPTY
64025: PPUSH
64026: CALL_OW 1
64030: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64031: LD_VAR 0 2
64035: PPUSH
64036: LD_INT 107
64038: PPUSH
64039: CALL 54893 0 2
// continue ;
64043: GO 63954
// end ; target := [ ] ;
64045: LD_ADDR_VAR 0 6
64049: PUSH
64050: EMPTY
64051: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64052: LD_ADDR_VAR 0 3
64056: PUSH
64057: DOUBLE
64058: LD_EXP 82
64062: PUSH
64063: LD_VAR 0 2
64067: ARRAY
64068: INC
64069: ST_TO_ADDR
64070: LD_INT 1
64072: PUSH
64073: FOR_DOWNTO
64074: IFFALSE 64334
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64076: LD_EXP 82
64080: PUSH
64081: LD_VAR 0 2
64085: ARRAY
64086: PUSH
64087: LD_VAR 0 3
64091: ARRAY
64092: PUSH
64093: LD_INT 2
64095: ARRAY
64096: PPUSH
64097: LD_EXP 82
64101: PUSH
64102: LD_VAR 0 2
64106: ARRAY
64107: PUSH
64108: LD_VAR 0 3
64112: ARRAY
64113: PUSH
64114: LD_INT 3
64116: ARRAY
64117: PPUSH
64118: CALL_OW 488
64122: PUSH
64123: LD_EXP 82
64127: PUSH
64128: LD_VAR 0 2
64132: ARRAY
64133: PUSH
64134: LD_VAR 0 3
64138: ARRAY
64139: PUSH
64140: LD_INT 2
64142: ARRAY
64143: PPUSH
64144: LD_EXP 82
64148: PUSH
64149: LD_VAR 0 2
64153: ARRAY
64154: PUSH
64155: LD_VAR 0 3
64159: ARRAY
64160: PUSH
64161: LD_INT 3
64163: ARRAY
64164: PPUSH
64165: CALL_OW 284
64169: PUSH
64170: LD_INT 0
64172: EQUAL
64173: AND
64174: IFFALSE 64229
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64176: LD_ADDR_VAR 0 5
64180: PUSH
64181: LD_EXP 82
64185: PUSH
64186: LD_VAR 0 2
64190: ARRAY
64191: PPUSH
64192: LD_VAR 0 3
64196: PPUSH
64197: CALL_OW 3
64201: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64202: LD_ADDR_EXP 82
64206: PUSH
64207: LD_EXP 82
64211: PPUSH
64212: LD_VAR 0 2
64216: PPUSH
64217: LD_VAR 0 5
64221: PPUSH
64222: CALL_OW 1
64226: ST_TO_ADDR
// continue ;
64227: GO 64073
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64229: LD_EXP 66
64233: PUSH
64234: LD_VAR 0 2
64238: ARRAY
64239: PUSH
64240: LD_INT 1
64242: ARRAY
64243: PPUSH
64244: CALL_OW 255
64248: PPUSH
64249: LD_EXP 82
64253: PUSH
64254: LD_VAR 0 2
64258: ARRAY
64259: PUSH
64260: LD_VAR 0 3
64264: ARRAY
64265: PUSH
64266: LD_INT 2
64268: ARRAY
64269: PPUSH
64270: LD_EXP 82
64274: PUSH
64275: LD_VAR 0 2
64279: ARRAY
64280: PUSH
64281: LD_VAR 0 3
64285: ARRAY
64286: PUSH
64287: LD_INT 3
64289: ARRAY
64290: PPUSH
64291: LD_INT 30
64293: PPUSH
64294: CALL 19444 0 4
64298: PUSH
64299: LD_INT 4
64301: ARRAY
64302: PUSH
64303: LD_INT 0
64305: EQUAL
64306: IFFALSE 64332
// begin target := mc_crates [ i ] [ j ] ;
64308: LD_ADDR_VAR 0 6
64312: PUSH
64313: LD_EXP 82
64317: PUSH
64318: LD_VAR 0 2
64322: ARRAY
64323: PUSH
64324: LD_VAR 0 3
64328: ARRAY
64329: ST_TO_ADDR
// break ;
64330: GO 64334
// end ; end ;
64332: GO 64073
64334: POP
64335: POP
// if not target then
64336: LD_VAR 0 6
64340: NOT
64341: IFFALSE 64345
// continue ;
64343: GO 63954
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64345: LD_ADDR_VAR 0 7
64349: PUSH
64350: LD_EXP 85
64354: PUSH
64355: LD_VAR 0 2
64359: ARRAY
64360: PPUSH
64361: LD_INT 2
64363: PUSH
64364: LD_INT 3
64366: PUSH
64367: LD_INT 58
64369: PUSH
64370: EMPTY
64371: LIST
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 61
64379: PUSH
64380: EMPTY
64381: LIST
64382: PUSH
64383: LD_INT 33
64385: PUSH
64386: LD_INT 5
64388: PUSH
64389: EMPTY
64390: LIST
64391: LIST
64392: PUSH
64393: LD_INT 33
64395: PUSH
64396: LD_INT 3
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: PUSH
64403: EMPTY
64404: LIST
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: PUSH
64410: LD_INT 2
64412: PUSH
64413: LD_INT 34
64415: PUSH
64416: LD_INT 32
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PUSH
64423: LD_INT 34
64425: PUSH
64426: LD_INT 51
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PUSH
64433: LD_INT 34
64435: PUSH
64436: LD_INT 12
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: EMPTY
64444: LIST
64445: LIST
64446: LIST
64447: LIST
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PPUSH
64453: CALL_OW 72
64457: ST_TO_ADDR
// if not cargo then
64458: LD_VAR 0 7
64462: NOT
64463: IFFALSE 65106
// begin if mc_crates_collector [ i ] < 5 then
64465: LD_EXP 83
64469: PUSH
64470: LD_VAR 0 2
64474: ARRAY
64475: PUSH
64476: LD_INT 5
64478: LESS
64479: IFFALSE 64845
// begin if mc_ape [ i ] then
64481: LD_EXP 95
64485: PUSH
64486: LD_VAR 0 2
64490: ARRAY
64491: IFFALSE 64538
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64493: LD_ADDR_VAR 0 5
64497: PUSH
64498: LD_EXP 95
64502: PUSH
64503: LD_VAR 0 2
64507: ARRAY
64508: PPUSH
64509: LD_INT 25
64511: PUSH
64512: LD_INT 16
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: LD_INT 24
64521: PUSH
64522: LD_INT 750
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: PUSH
64529: EMPTY
64530: LIST
64531: LIST
64532: PPUSH
64533: CALL_OW 72
64537: ST_TO_ADDR
// if not tmp then
64538: LD_VAR 0 5
64542: NOT
64543: IFFALSE 64590
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64545: LD_ADDR_VAR 0 5
64549: PUSH
64550: LD_EXP 66
64554: PUSH
64555: LD_VAR 0 2
64559: ARRAY
64560: PPUSH
64561: LD_INT 25
64563: PUSH
64564: LD_INT 2
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PUSH
64571: LD_INT 24
64573: PUSH
64574: LD_INT 750
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PPUSH
64585: CALL_OW 72
64589: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64590: LD_EXP 95
64594: PUSH
64595: LD_VAR 0 2
64599: ARRAY
64600: PUSH
64601: LD_EXP 66
64605: PUSH
64606: LD_VAR 0 2
64610: ARRAY
64611: PPUSH
64612: LD_INT 25
64614: PUSH
64615: LD_INT 2
64617: PUSH
64618: EMPTY
64619: LIST
64620: LIST
64621: PUSH
64622: LD_INT 24
64624: PUSH
64625: LD_INT 750
64627: PUSH
64628: EMPTY
64629: LIST
64630: LIST
64631: PUSH
64632: EMPTY
64633: LIST
64634: LIST
64635: PPUSH
64636: CALL_OW 72
64640: AND
64641: PUSH
64642: LD_VAR 0 5
64646: PUSH
64647: LD_INT 5
64649: LESS
64650: AND
64651: IFFALSE 64733
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64653: LD_ADDR_VAR 0 3
64657: PUSH
64658: LD_EXP 66
64662: PUSH
64663: LD_VAR 0 2
64667: ARRAY
64668: PPUSH
64669: LD_INT 25
64671: PUSH
64672: LD_INT 2
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: PUSH
64679: LD_INT 24
64681: PUSH
64682: LD_INT 750
64684: PUSH
64685: EMPTY
64686: LIST
64687: LIST
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PPUSH
64693: CALL_OW 72
64697: PUSH
64698: FOR_IN
64699: IFFALSE 64731
// begin tmp := tmp union j ;
64701: LD_ADDR_VAR 0 5
64705: PUSH
64706: LD_VAR 0 5
64710: PUSH
64711: LD_VAR 0 3
64715: UNION
64716: ST_TO_ADDR
// if tmp >= 5 then
64717: LD_VAR 0 5
64721: PUSH
64722: LD_INT 5
64724: GREATEREQUAL
64725: IFFALSE 64729
// break ;
64727: GO 64731
// end ;
64729: GO 64698
64731: POP
64732: POP
// end ; if not tmp then
64733: LD_VAR 0 5
64737: NOT
64738: IFFALSE 64742
// continue ;
64740: GO 63954
// for j in tmp do
64742: LD_ADDR_VAR 0 3
64746: PUSH
64747: LD_VAR 0 5
64751: PUSH
64752: FOR_IN
64753: IFFALSE 64843
// if not GetTag ( j ) then
64755: LD_VAR 0 3
64759: PPUSH
64760: CALL_OW 110
64764: NOT
64765: IFFALSE 64841
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64767: LD_ADDR_EXP 83
64771: PUSH
64772: LD_EXP 83
64776: PPUSH
64777: LD_VAR 0 2
64781: PUSH
64782: LD_EXP 83
64786: PUSH
64787: LD_VAR 0 2
64791: ARRAY
64792: PUSH
64793: LD_INT 1
64795: PLUS
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PPUSH
64801: LD_VAR 0 3
64805: PPUSH
64806: CALL 18548 0 3
64810: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64811: LD_VAR 0 3
64815: PPUSH
64816: LD_INT 107
64818: PPUSH
64819: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64823: LD_EXP 83
64827: PUSH
64828: LD_VAR 0 2
64832: ARRAY
64833: PUSH
64834: LD_INT 5
64836: GREATEREQUAL
64837: IFFALSE 64841
// break ;
64839: GO 64843
// end ;
64841: GO 64752
64843: POP
64844: POP
// end ; if mc_crates_collector [ i ] and target then
64845: LD_EXP 83
64849: PUSH
64850: LD_VAR 0 2
64854: ARRAY
64855: PUSH
64856: LD_VAR 0 6
64860: AND
64861: IFFALSE 65104
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64863: LD_EXP 83
64867: PUSH
64868: LD_VAR 0 2
64872: ARRAY
64873: PUSH
64874: LD_VAR 0 6
64878: PUSH
64879: LD_INT 1
64881: ARRAY
64882: LESS
64883: IFFALSE 64903
// tmp := mc_crates_collector [ i ] else
64885: LD_ADDR_VAR 0 5
64889: PUSH
64890: LD_EXP 83
64894: PUSH
64895: LD_VAR 0 2
64899: ARRAY
64900: ST_TO_ADDR
64901: GO 64917
// tmp := target [ 1 ] ;
64903: LD_ADDR_VAR 0 5
64907: PUSH
64908: LD_VAR 0 6
64912: PUSH
64913: LD_INT 1
64915: ARRAY
64916: ST_TO_ADDR
// k := 0 ;
64917: LD_ADDR_VAR 0 4
64921: PUSH
64922: LD_INT 0
64924: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64925: LD_ADDR_VAR 0 3
64929: PUSH
64930: LD_EXP 83
64934: PUSH
64935: LD_VAR 0 2
64939: ARRAY
64940: PUSH
64941: FOR_IN
64942: IFFALSE 65102
// begin k := k + 1 ;
64944: LD_ADDR_VAR 0 4
64948: PUSH
64949: LD_VAR 0 4
64953: PUSH
64954: LD_INT 1
64956: PLUS
64957: ST_TO_ADDR
// if k > tmp then
64958: LD_VAR 0 4
64962: PUSH
64963: LD_VAR 0 5
64967: GREATER
64968: IFFALSE 64972
// break ;
64970: GO 65102
// if not GetClass ( j ) in [ 2 , 16 ] then
64972: LD_VAR 0 3
64976: PPUSH
64977: CALL_OW 257
64981: PUSH
64982: LD_INT 2
64984: PUSH
64985: LD_INT 16
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: IN
64992: NOT
64993: IFFALSE 65046
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64995: LD_ADDR_EXP 83
64999: PUSH
65000: LD_EXP 83
65004: PPUSH
65005: LD_VAR 0 2
65009: PPUSH
65010: LD_EXP 83
65014: PUSH
65015: LD_VAR 0 2
65019: ARRAY
65020: PUSH
65021: LD_VAR 0 3
65025: DIFF
65026: PPUSH
65027: CALL_OW 1
65031: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65032: LD_VAR 0 3
65036: PPUSH
65037: LD_INT 0
65039: PPUSH
65040: CALL_OW 109
// continue ;
65044: GO 64941
// end ; if IsInUnit ( j ) then
65046: LD_VAR 0 3
65050: PPUSH
65051: CALL_OW 310
65055: IFFALSE 65066
// ComExitBuilding ( j ) ;
65057: LD_VAR 0 3
65061: PPUSH
65062: CALL_OW 122
// wait ( 3 ) ;
65066: LD_INT 3
65068: PPUSH
65069: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65073: LD_VAR 0 3
65077: PPUSH
65078: LD_VAR 0 6
65082: PUSH
65083: LD_INT 2
65085: ARRAY
65086: PPUSH
65087: LD_VAR 0 6
65091: PUSH
65092: LD_INT 3
65094: ARRAY
65095: PPUSH
65096: CALL_OW 117
// end ;
65100: GO 64941
65102: POP
65103: POP
// end ; end else
65104: GO 65685
// begin for j in cargo do
65106: LD_ADDR_VAR 0 3
65110: PUSH
65111: LD_VAR 0 7
65115: PUSH
65116: FOR_IN
65117: IFFALSE 65683
// begin if GetTag ( j ) <> 0 then
65119: LD_VAR 0 3
65123: PPUSH
65124: CALL_OW 110
65128: PUSH
65129: LD_INT 0
65131: NONEQUAL
65132: IFFALSE 65136
// continue ;
65134: GO 65116
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65136: LD_VAR 0 3
65140: PPUSH
65141: CALL_OW 256
65145: PUSH
65146: LD_INT 1000
65148: LESS
65149: PUSH
65150: LD_VAR 0 3
65154: PPUSH
65155: LD_EXP 90
65159: PUSH
65160: LD_VAR 0 2
65164: ARRAY
65165: PPUSH
65166: CALL_OW 308
65170: NOT
65171: AND
65172: IFFALSE 65194
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65174: LD_VAR 0 3
65178: PPUSH
65179: LD_EXP 90
65183: PUSH
65184: LD_VAR 0 2
65188: ARRAY
65189: PPUSH
65190: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65194: LD_VAR 0 3
65198: PPUSH
65199: CALL_OW 256
65203: PUSH
65204: LD_INT 1000
65206: LESS
65207: PUSH
65208: LD_VAR 0 3
65212: PPUSH
65213: LD_EXP 90
65217: PUSH
65218: LD_VAR 0 2
65222: ARRAY
65223: PPUSH
65224: CALL_OW 308
65228: AND
65229: IFFALSE 65233
// continue ;
65231: GO 65116
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65233: LD_VAR 0 3
65237: PPUSH
65238: CALL_OW 262
65242: PUSH
65243: LD_INT 2
65245: EQUAL
65246: PUSH
65247: LD_VAR 0 3
65251: PPUSH
65252: CALL_OW 261
65256: PUSH
65257: LD_INT 15
65259: LESS
65260: AND
65261: IFFALSE 65265
// continue ;
65263: GO 65116
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65265: LD_VAR 0 3
65269: PPUSH
65270: CALL_OW 262
65274: PUSH
65275: LD_INT 1
65277: EQUAL
65278: PUSH
65279: LD_VAR 0 3
65283: PPUSH
65284: CALL_OW 261
65288: PUSH
65289: LD_INT 10
65291: LESS
65292: AND
65293: IFFALSE 65622
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65295: LD_ADDR_VAR 0 8
65299: PUSH
65300: LD_EXP 66
65304: PUSH
65305: LD_VAR 0 2
65309: ARRAY
65310: PPUSH
65311: LD_INT 2
65313: PUSH
65314: LD_INT 30
65316: PUSH
65317: LD_INT 0
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 30
65326: PUSH
65327: LD_INT 1
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: LIST
65338: PPUSH
65339: CALL_OW 72
65343: ST_TO_ADDR
// if not depot then
65344: LD_VAR 0 8
65348: NOT
65349: IFFALSE 65353
// continue ;
65351: GO 65116
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65353: LD_VAR 0 3
65357: PPUSH
65358: LD_VAR 0 8
65362: PPUSH
65363: LD_VAR 0 3
65367: PPUSH
65368: CALL_OW 74
65372: PPUSH
65373: CALL_OW 296
65377: PUSH
65378: LD_INT 6
65380: LESS
65381: IFFALSE 65397
// SetFuel ( j , 100 ) else
65383: LD_VAR 0 3
65387: PPUSH
65388: LD_INT 100
65390: PPUSH
65391: CALL_OW 240
65395: GO 65622
// if GetFuel ( j ) = 0 then
65397: LD_VAR 0 3
65401: PPUSH
65402: CALL_OW 261
65406: PUSH
65407: LD_INT 0
65409: EQUAL
65410: IFFALSE 65622
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65412: LD_ADDR_EXP 85
65416: PUSH
65417: LD_EXP 85
65421: PPUSH
65422: LD_VAR 0 2
65426: PPUSH
65427: LD_EXP 85
65431: PUSH
65432: LD_VAR 0 2
65436: ARRAY
65437: PUSH
65438: LD_VAR 0 3
65442: DIFF
65443: PPUSH
65444: CALL_OW 1
65448: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65449: LD_VAR 0 3
65453: PPUSH
65454: CALL_OW 263
65458: PUSH
65459: LD_INT 1
65461: EQUAL
65462: IFFALSE 65478
// ComExitVehicle ( IsInUnit ( j ) ) ;
65464: LD_VAR 0 3
65468: PPUSH
65469: CALL_OW 310
65473: PPUSH
65474: CALL_OW 121
// if GetControl ( j ) = control_remote then
65478: LD_VAR 0 3
65482: PPUSH
65483: CALL_OW 263
65487: PUSH
65488: LD_INT 2
65490: EQUAL
65491: IFFALSE 65502
// ComUnlink ( j ) ;
65493: LD_VAR 0 3
65497: PPUSH
65498: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65502: LD_ADDR_VAR 0 9
65506: PUSH
65507: LD_VAR 0 2
65511: PPUSH
65512: LD_INT 3
65514: PPUSH
65515: CALL 74997 0 2
65519: ST_TO_ADDR
// if fac then
65520: LD_VAR 0 9
65524: IFFALSE 65620
// begin for k in fac do
65526: LD_ADDR_VAR 0 4
65530: PUSH
65531: LD_VAR 0 9
65535: PUSH
65536: FOR_IN
65537: IFFALSE 65618
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65539: LD_ADDR_VAR 0 10
65543: PUSH
65544: LD_VAR 0 9
65548: PPUSH
65549: LD_VAR 0 3
65553: PPUSH
65554: CALL_OW 265
65558: PPUSH
65559: LD_VAR 0 3
65563: PPUSH
65564: CALL_OW 262
65568: PPUSH
65569: LD_VAR 0 3
65573: PPUSH
65574: CALL_OW 263
65578: PPUSH
65579: LD_VAR 0 3
65583: PPUSH
65584: CALL_OW 264
65588: PPUSH
65589: CALL 16080 0 5
65593: ST_TO_ADDR
// if components then
65594: LD_VAR 0 10
65598: IFFALSE 65616
// begin MC_InsertProduceList ( i , components ) ;
65600: LD_VAR 0 2
65604: PPUSH
65605: LD_VAR 0 10
65609: PPUSH
65610: CALL 74542 0 2
// break ;
65614: GO 65618
// end ; end ;
65616: GO 65536
65618: POP
65619: POP
// end ; continue ;
65620: GO 65116
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65622: LD_VAR 0 3
65626: PPUSH
65627: LD_INT 1
65629: PPUSH
65630: CALL_OW 289
65634: PUSH
65635: LD_INT 100
65637: LESS
65638: PUSH
65639: LD_VAR 0 3
65643: PPUSH
65644: CALL_OW 314
65648: NOT
65649: AND
65650: IFFALSE 65679
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65652: LD_VAR 0 3
65656: PPUSH
65657: LD_VAR 0 6
65661: PUSH
65662: LD_INT 2
65664: ARRAY
65665: PPUSH
65666: LD_VAR 0 6
65670: PUSH
65671: LD_INT 3
65673: ARRAY
65674: PPUSH
65675: CALL_OW 117
// break ;
65679: GO 65683
// end ;
65681: GO 65116
65683: POP
65684: POP
// end ; end ;
65685: GO 63954
65687: POP
65688: POP
// end ;
65689: LD_VAR 0 1
65693: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65694: LD_INT 0
65696: PPUSH
65697: PPUSH
65698: PPUSH
65699: PPUSH
// if not mc_bases then
65700: LD_EXP 66
65704: NOT
65705: IFFALSE 65709
// exit ;
65707: GO 65870
// for i = 1 to mc_bases do
65709: LD_ADDR_VAR 0 2
65713: PUSH
65714: DOUBLE
65715: LD_INT 1
65717: DEC
65718: ST_TO_ADDR
65719: LD_EXP 66
65723: PUSH
65724: FOR_TO
65725: IFFALSE 65868
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65727: LD_ADDR_VAR 0 4
65731: PUSH
65732: LD_EXP 85
65736: PUSH
65737: LD_VAR 0 2
65741: ARRAY
65742: PUSH
65743: LD_EXP 88
65747: PUSH
65748: LD_VAR 0 2
65752: ARRAY
65753: UNION
65754: PPUSH
65755: LD_INT 33
65757: PUSH
65758: LD_INT 2
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: PPUSH
65765: CALL_OW 72
65769: ST_TO_ADDR
// if tmp then
65770: LD_VAR 0 4
65774: IFFALSE 65866
// for j in tmp do
65776: LD_ADDR_VAR 0 3
65780: PUSH
65781: LD_VAR 0 4
65785: PUSH
65786: FOR_IN
65787: IFFALSE 65864
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65789: LD_VAR 0 3
65793: PPUSH
65794: CALL_OW 312
65798: NOT
65799: PUSH
65800: LD_VAR 0 3
65804: PPUSH
65805: CALL_OW 256
65809: PUSH
65810: LD_INT 250
65812: GREATEREQUAL
65813: AND
65814: IFFALSE 65827
// Connect ( j ) else
65816: LD_VAR 0 3
65820: PPUSH
65821: CALL 21481 0 1
65825: GO 65862
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65827: LD_VAR 0 3
65831: PPUSH
65832: CALL_OW 256
65836: PUSH
65837: LD_INT 250
65839: LESS
65840: PUSH
65841: LD_VAR 0 3
65845: PPUSH
65846: CALL_OW 312
65850: AND
65851: IFFALSE 65862
// ComUnlink ( j ) ;
65853: LD_VAR 0 3
65857: PPUSH
65858: CALL_OW 136
65862: GO 65786
65864: POP
65865: POP
// end ;
65866: GO 65724
65868: POP
65869: POP
// end ;
65870: LD_VAR 0 1
65874: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65875: LD_INT 0
65877: PPUSH
65878: PPUSH
65879: PPUSH
65880: PPUSH
65881: PPUSH
// if not mc_bases then
65882: LD_EXP 66
65886: NOT
65887: IFFALSE 65891
// exit ;
65889: GO 66336
// for i = 1 to mc_bases do
65891: LD_ADDR_VAR 0 2
65895: PUSH
65896: DOUBLE
65897: LD_INT 1
65899: DEC
65900: ST_TO_ADDR
65901: LD_EXP 66
65905: PUSH
65906: FOR_TO
65907: IFFALSE 66334
// begin if not mc_produce [ i ] then
65909: LD_EXP 87
65913: PUSH
65914: LD_VAR 0 2
65918: ARRAY
65919: NOT
65920: IFFALSE 65924
// continue ;
65922: GO 65906
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65924: LD_ADDR_VAR 0 5
65928: PUSH
65929: LD_EXP 66
65933: PUSH
65934: LD_VAR 0 2
65938: ARRAY
65939: PPUSH
65940: LD_INT 30
65942: PUSH
65943: LD_INT 3
65945: PUSH
65946: EMPTY
65947: LIST
65948: LIST
65949: PPUSH
65950: CALL_OW 72
65954: ST_TO_ADDR
// if not fac then
65955: LD_VAR 0 5
65959: NOT
65960: IFFALSE 65964
// continue ;
65962: GO 65906
// for j in fac do
65964: LD_ADDR_VAR 0 3
65968: PUSH
65969: LD_VAR 0 5
65973: PUSH
65974: FOR_IN
65975: IFFALSE 66330
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65977: LD_VAR 0 3
65981: PPUSH
65982: CALL_OW 461
65986: PUSH
65987: LD_INT 2
65989: NONEQUAL
65990: PUSH
65991: LD_VAR 0 3
65995: PPUSH
65996: LD_INT 15
65998: PPUSH
65999: CALL 21141 0 2
66003: PUSH
66004: LD_INT 4
66006: ARRAY
66007: OR
66008: IFFALSE 66012
// continue ;
66010: GO 65974
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66012: LD_VAR 0 3
66016: PPUSH
66017: LD_EXP 87
66021: PUSH
66022: LD_VAR 0 2
66026: ARRAY
66027: PUSH
66028: LD_INT 1
66030: ARRAY
66031: PUSH
66032: LD_INT 1
66034: ARRAY
66035: PPUSH
66036: LD_EXP 87
66040: PUSH
66041: LD_VAR 0 2
66045: ARRAY
66046: PUSH
66047: LD_INT 1
66049: ARRAY
66050: PUSH
66051: LD_INT 2
66053: ARRAY
66054: PPUSH
66055: LD_EXP 87
66059: PUSH
66060: LD_VAR 0 2
66064: ARRAY
66065: PUSH
66066: LD_INT 1
66068: ARRAY
66069: PUSH
66070: LD_INT 3
66072: ARRAY
66073: PPUSH
66074: LD_EXP 87
66078: PUSH
66079: LD_VAR 0 2
66083: ARRAY
66084: PUSH
66085: LD_INT 1
66087: ARRAY
66088: PUSH
66089: LD_INT 4
66091: ARRAY
66092: PPUSH
66093: CALL_OW 448
66097: PUSH
66098: LD_VAR 0 3
66102: PPUSH
66103: LD_EXP 87
66107: PUSH
66108: LD_VAR 0 2
66112: ARRAY
66113: PUSH
66114: LD_INT 1
66116: ARRAY
66117: PUSH
66118: LD_INT 1
66120: ARRAY
66121: PUSH
66122: LD_EXP 87
66126: PUSH
66127: LD_VAR 0 2
66131: ARRAY
66132: PUSH
66133: LD_INT 1
66135: ARRAY
66136: PUSH
66137: LD_INT 2
66139: ARRAY
66140: PUSH
66141: LD_EXP 87
66145: PUSH
66146: LD_VAR 0 2
66150: ARRAY
66151: PUSH
66152: LD_INT 1
66154: ARRAY
66155: PUSH
66156: LD_INT 3
66158: ARRAY
66159: PUSH
66160: LD_EXP 87
66164: PUSH
66165: LD_VAR 0 2
66169: ARRAY
66170: PUSH
66171: LD_INT 1
66173: ARRAY
66174: PUSH
66175: LD_INT 4
66177: ARRAY
66178: PUSH
66179: EMPTY
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: PPUSH
66185: CALL 24812 0 2
66189: AND
66190: IFFALSE 66328
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66192: LD_VAR 0 3
66196: PPUSH
66197: LD_EXP 87
66201: PUSH
66202: LD_VAR 0 2
66206: ARRAY
66207: PUSH
66208: LD_INT 1
66210: ARRAY
66211: PUSH
66212: LD_INT 1
66214: ARRAY
66215: PPUSH
66216: LD_EXP 87
66220: PUSH
66221: LD_VAR 0 2
66225: ARRAY
66226: PUSH
66227: LD_INT 1
66229: ARRAY
66230: PUSH
66231: LD_INT 2
66233: ARRAY
66234: PPUSH
66235: LD_EXP 87
66239: PUSH
66240: LD_VAR 0 2
66244: ARRAY
66245: PUSH
66246: LD_INT 1
66248: ARRAY
66249: PUSH
66250: LD_INT 3
66252: ARRAY
66253: PPUSH
66254: LD_EXP 87
66258: PUSH
66259: LD_VAR 0 2
66263: ARRAY
66264: PUSH
66265: LD_INT 1
66267: ARRAY
66268: PUSH
66269: LD_INT 4
66271: ARRAY
66272: PPUSH
66273: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66277: LD_ADDR_VAR 0 4
66281: PUSH
66282: LD_EXP 87
66286: PUSH
66287: LD_VAR 0 2
66291: ARRAY
66292: PPUSH
66293: LD_INT 1
66295: PPUSH
66296: CALL_OW 3
66300: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66301: LD_ADDR_EXP 87
66305: PUSH
66306: LD_EXP 87
66310: PPUSH
66311: LD_VAR 0 2
66315: PPUSH
66316: LD_VAR 0 4
66320: PPUSH
66321: CALL_OW 1
66325: ST_TO_ADDR
// break ;
66326: GO 66330
// end ; end ;
66328: GO 65974
66330: POP
66331: POP
// end ;
66332: GO 65906
66334: POP
66335: POP
// end ;
66336: LD_VAR 0 1
66340: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66341: LD_INT 0
66343: PPUSH
66344: PPUSH
66345: PPUSH
// if not mc_bases then
66346: LD_EXP 66
66350: NOT
66351: IFFALSE 66355
// exit ;
66353: GO 66444
// for i = 1 to mc_bases do
66355: LD_ADDR_VAR 0 2
66359: PUSH
66360: DOUBLE
66361: LD_INT 1
66363: DEC
66364: ST_TO_ADDR
66365: LD_EXP 66
66369: PUSH
66370: FOR_TO
66371: IFFALSE 66442
// begin if mc_attack [ i ] then
66373: LD_EXP 86
66377: PUSH
66378: LD_VAR 0 2
66382: ARRAY
66383: IFFALSE 66440
// begin tmp := mc_attack [ i ] [ 1 ] ;
66385: LD_ADDR_VAR 0 3
66389: PUSH
66390: LD_EXP 86
66394: PUSH
66395: LD_VAR 0 2
66399: ARRAY
66400: PUSH
66401: LD_INT 1
66403: ARRAY
66404: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66405: LD_ADDR_EXP 86
66409: PUSH
66410: LD_EXP 86
66414: PPUSH
66415: LD_VAR 0 2
66419: PPUSH
66420: EMPTY
66421: PPUSH
66422: CALL_OW 1
66426: ST_TO_ADDR
// Attack ( tmp ) ;
66427: LD_VAR 0 3
66431: PPUSH
66432: CALL 98061 0 1
// exit ;
66436: POP
66437: POP
66438: GO 66444
// end ; end ;
66440: GO 66370
66442: POP
66443: POP
// end ;
66444: LD_VAR 0 1
66448: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66449: LD_INT 0
66451: PPUSH
66452: PPUSH
66453: PPUSH
66454: PPUSH
66455: PPUSH
66456: PPUSH
66457: PPUSH
// if not mc_bases then
66458: LD_EXP 66
66462: NOT
66463: IFFALSE 66467
// exit ;
66465: GO 67071
// for i = 1 to mc_bases do
66467: LD_ADDR_VAR 0 2
66471: PUSH
66472: DOUBLE
66473: LD_INT 1
66475: DEC
66476: ST_TO_ADDR
66477: LD_EXP 66
66481: PUSH
66482: FOR_TO
66483: IFFALSE 67069
// begin if not mc_bases [ i ] then
66485: LD_EXP 66
66489: PUSH
66490: LD_VAR 0 2
66494: ARRAY
66495: NOT
66496: IFFALSE 66500
// continue ;
66498: GO 66482
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66500: LD_ADDR_VAR 0 7
66504: PUSH
66505: LD_EXP 66
66509: PUSH
66510: LD_VAR 0 2
66514: ARRAY
66515: PUSH
66516: LD_INT 1
66518: ARRAY
66519: PPUSH
66520: CALL 15384 0 1
66524: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66525: LD_ADDR_EXP 89
66529: PUSH
66530: LD_EXP 89
66534: PPUSH
66535: LD_VAR 0 2
66539: PPUSH
66540: LD_EXP 66
66544: PUSH
66545: LD_VAR 0 2
66549: ARRAY
66550: PUSH
66551: LD_INT 1
66553: ARRAY
66554: PPUSH
66555: CALL_OW 255
66559: PPUSH
66560: LD_EXP 91
66564: PUSH
66565: LD_VAR 0 2
66569: ARRAY
66570: PPUSH
66571: CALL 15349 0 2
66575: PPUSH
66576: CALL_OW 1
66580: ST_TO_ADDR
// if not mc_scan [ i ] then
66581: LD_EXP 89
66585: PUSH
66586: LD_VAR 0 2
66590: ARRAY
66591: NOT
66592: IFFALSE 66747
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66594: LD_ADDR_VAR 0 4
66598: PUSH
66599: LD_EXP 66
66603: PUSH
66604: LD_VAR 0 2
66608: ARRAY
66609: PPUSH
66610: LD_INT 2
66612: PUSH
66613: LD_INT 25
66615: PUSH
66616: LD_INT 5
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: PUSH
66623: LD_INT 25
66625: PUSH
66626: LD_INT 8
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 25
66635: PUSH
66636: LD_INT 9
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: PPUSH
66649: CALL_OW 72
66653: ST_TO_ADDR
// if not tmp then
66654: LD_VAR 0 4
66658: NOT
66659: IFFALSE 66663
// continue ;
66661: GO 66482
// for j in tmp do
66663: LD_ADDR_VAR 0 3
66667: PUSH
66668: LD_VAR 0 4
66672: PUSH
66673: FOR_IN
66674: IFFALSE 66745
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66676: LD_VAR 0 3
66680: PPUSH
66681: CALL_OW 310
66685: PPUSH
66686: CALL_OW 266
66690: PUSH
66691: LD_INT 5
66693: EQUAL
66694: PUSH
66695: LD_VAR 0 3
66699: PPUSH
66700: CALL_OW 257
66704: PUSH
66705: LD_INT 1
66707: EQUAL
66708: AND
66709: PUSH
66710: LD_VAR 0 3
66714: PPUSH
66715: CALL_OW 459
66719: NOT
66720: AND
66721: PUSH
66722: LD_VAR 0 7
66726: AND
66727: IFFALSE 66743
// ComChangeProfession ( j , class ) ;
66729: LD_VAR 0 3
66733: PPUSH
66734: LD_VAR 0 7
66738: PPUSH
66739: CALL_OW 123
66743: GO 66673
66745: POP
66746: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66747: LD_EXP 89
66751: PUSH
66752: LD_VAR 0 2
66756: ARRAY
66757: PUSH
66758: LD_EXP 88
66762: PUSH
66763: LD_VAR 0 2
66767: ARRAY
66768: NOT
66769: AND
66770: PUSH
66771: LD_EXP 66
66775: PUSH
66776: LD_VAR 0 2
66780: ARRAY
66781: PPUSH
66782: LD_INT 30
66784: PUSH
66785: LD_INT 32
66787: PUSH
66788: EMPTY
66789: LIST
66790: LIST
66791: PPUSH
66792: CALL_OW 72
66796: NOT
66797: AND
66798: PUSH
66799: LD_EXP 66
66803: PUSH
66804: LD_VAR 0 2
66808: ARRAY
66809: PPUSH
66810: LD_INT 2
66812: PUSH
66813: LD_INT 30
66815: PUSH
66816: LD_INT 4
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 30
66825: PUSH
66826: LD_INT 5
66828: PUSH
66829: EMPTY
66830: LIST
66831: LIST
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: LIST
66837: PPUSH
66838: CALL_OW 72
66842: NOT
66843: AND
66844: IFFALSE 66976
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66846: LD_ADDR_VAR 0 4
66850: PUSH
66851: LD_EXP 66
66855: PUSH
66856: LD_VAR 0 2
66860: ARRAY
66861: PPUSH
66862: LD_INT 2
66864: PUSH
66865: LD_INT 25
66867: PUSH
66868: LD_INT 1
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 25
66877: PUSH
66878: LD_INT 5
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 25
66887: PUSH
66888: LD_INT 8
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 25
66897: PUSH
66898: LD_INT 9
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: PPUSH
66912: CALL_OW 72
66916: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66917: LD_ADDR_VAR 0 4
66921: PUSH
66922: LD_VAR 0 4
66926: PUSH
66927: LD_VAR 0 4
66931: PPUSH
66932: LD_INT 18
66934: PPUSH
66935: CALL 47109 0 2
66939: DIFF
66940: ST_TO_ADDR
// if tmp then
66941: LD_VAR 0 4
66945: IFFALSE 66976
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
66947: LD_VAR 0 2
66951: PPUSH
66952: LD_VAR 0 4
66956: PPUSH
66957: LD_EXP 91
66961: PUSH
66962: LD_VAR 0 2
66966: ARRAY
66967: PPUSH
66968: CALL 102770 0 3
// exit ;
66972: POP
66973: POP
66974: GO 67071
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
66976: LD_EXP 89
66980: PUSH
66981: LD_VAR 0 2
66985: ARRAY
66986: PUSH
66987: LD_EXP 88
66991: PUSH
66992: LD_VAR 0 2
66996: ARRAY
66997: AND
66998: IFFALSE 67067
// begin tmp := mc_defender [ i ] ;
67000: LD_ADDR_VAR 0 4
67004: PUSH
67005: LD_EXP 88
67009: PUSH
67010: LD_VAR 0 2
67014: ARRAY
67015: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67016: LD_ADDR_EXP 88
67020: PUSH
67021: LD_EXP 88
67025: PPUSH
67026: LD_VAR 0 2
67030: PPUSH
67031: EMPTY
67032: PPUSH
67033: CALL_OW 1
67037: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
67038: LD_VAR 0 2
67042: PPUSH
67043: LD_VAR 0 4
67047: PPUSH
67048: LD_EXP 89
67052: PUSH
67053: LD_VAR 0 2
67057: ARRAY
67058: PPUSH
67059: CALL 103331 0 3
// exit ;
67063: POP
67064: POP
67065: GO 67071
// end ; end ;
67067: GO 66482
67069: POP
67070: POP
// end ;
67071: LD_VAR 0 1
67075: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67076: LD_INT 0
67078: PPUSH
67079: PPUSH
67080: PPUSH
67081: PPUSH
67082: PPUSH
67083: PPUSH
67084: PPUSH
67085: PPUSH
67086: PPUSH
67087: PPUSH
67088: PPUSH
// if not mc_bases then
67089: LD_EXP 66
67093: NOT
67094: IFFALSE 67098
// exit ;
67096: GO 68185
// for i = 1 to mc_bases do
67098: LD_ADDR_VAR 0 2
67102: PUSH
67103: DOUBLE
67104: LD_INT 1
67106: DEC
67107: ST_TO_ADDR
67108: LD_EXP 66
67112: PUSH
67113: FOR_TO
67114: IFFALSE 68183
// begin tmp := mc_lab [ i ] ;
67116: LD_ADDR_VAR 0 6
67120: PUSH
67121: LD_EXP 99
67125: PUSH
67126: LD_VAR 0 2
67130: ARRAY
67131: ST_TO_ADDR
// if not tmp then
67132: LD_VAR 0 6
67136: NOT
67137: IFFALSE 67141
// continue ;
67139: GO 67113
// idle_lab := 0 ;
67141: LD_ADDR_VAR 0 11
67145: PUSH
67146: LD_INT 0
67148: ST_TO_ADDR
// for j in tmp do
67149: LD_ADDR_VAR 0 3
67153: PUSH
67154: LD_VAR 0 6
67158: PUSH
67159: FOR_IN
67160: IFFALSE 68179
// begin researching := false ;
67162: LD_ADDR_VAR 0 10
67166: PUSH
67167: LD_INT 0
67169: ST_TO_ADDR
// side := GetSide ( j ) ;
67170: LD_ADDR_VAR 0 4
67174: PUSH
67175: LD_VAR 0 3
67179: PPUSH
67180: CALL_OW 255
67184: ST_TO_ADDR
// if not mc_tech [ side ] then
67185: LD_EXP 93
67189: PUSH
67190: LD_VAR 0 4
67194: ARRAY
67195: NOT
67196: IFFALSE 67200
// continue ;
67198: GO 67159
// if BuildingStatus ( j ) = bs_idle then
67200: LD_VAR 0 3
67204: PPUSH
67205: CALL_OW 461
67209: PUSH
67210: LD_INT 2
67212: EQUAL
67213: IFFALSE 67401
// begin if idle_lab and UnitsInside ( j ) < 6 then
67215: LD_VAR 0 11
67219: PUSH
67220: LD_VAR 0 3
67224: PPUSH
67225: CALL_OW 313
67229: PUSH
67230: LD_INT 6
67232: LESS
67233: AND
67234: IFFALSE 67305
// begin tmp2 := UnitsInside ( idle_lab ) ;
67236: LD_ADDR_VAR 0 9
67240: PUSH
67241: LD_VAR 0 11
67245: PPUSH
67246: CALL_OW 313
67250: ST_TO_ADDR
// if tmp2 then
67251: LD_VAR 0 9
67255: IFFALSE 67297
// for x in tmp2 do
67257: LD_ADDR_VAR 0 7
67261: PUSH
67262: LD_VAR 0 9
67266: PUSH
67267: FOR_IN
67268: IFFALSE 67295
// begin ComExitBuilding ( x ) ;
67270: LD_VAR 0 7
67274: PPUSH
67275: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67279: LD_VAR 0 7
67283: PPUSH
67284: LD_VAR 0 3
67288: PPUSH
67289: CALL_OW 180
// end ;
67293: GO 67267
67295: POP
67296: POP
// idle_lab := 0 ;
67297: LD_ADDR_VAR 0 11
67301: PUSH
67302: LD_INT 0
67304: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67305: LD_ADDR_VAR 0 5
67309: PUSH
67310: LD_EXP 93
67314: PUSH
67315: LD_VAR 0 4
67319: ARRAY
67320: PUSH
67321: FOR_IN
67322: IFFALSE 67382
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67324: LD_VAR 0 3
67328: PPUSH
67329: LD_VAR 0 5
67333: PPUSH
67334: CALL_OW 430
67338: PUSH
67339: LD_VAR 0 4
67343: PPUSH
67344: LD_VAR 0 5
67348: PPUSH
67349: CALL 14454 0 2
67353: AND
67354: IFFALSE 67380
// begin researching := true ;
67356: LD_ADDR_VAR 0 10
67360: PUSH
67361: LD_INT 1
67363: ST_TO_ADDR
// ComResearch ( j , t ) ;
67364: LD_VAR 0 3
67368: PPUSH
67369: LD_VAR 0 5
67373: PPUSH
67374: CALL_OW 124
// break ;
67378: GO 67382
// end ;
67380: GO 67321
67382: POP
67383: POP
// if not researching then
67384: LD_VAR 0 10
67388: NOT
67389: IFFALSE 67401
// idle_lab := j ;
67391: LD_ADDR_VAR 0 11
67395: PUSH
67396: LD_VAR 0 3
67400: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67401: LD_VAR 0 3
67405: PPUSH
67406: CALL_OW 461
67410: PUSH
67411: LD_INT 10
67413: EQUAL
67414: IFFALSE 68002
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67416: LD_EXP 95
67420: PUSH
67421: LD_VAR 0 2
67425: ARRAY
67426: NOT
67427: PUSH
67428: LD_EXP 96
67432: PUSH
67433: LD_VAR 0 2
67437: ARRAY
67438: NOT
67439: AND
67440: PUSH
67441: LD_EXP 93
67445: PUSH
67446: LD_VAR 0 4
67450: ARRAY
67451: PUSH
67452: LD_INT 1
67454: GREATER
67455: AND
67456: IFFALSE 67587
// begin ComCancel ( j ) ;
67458: LD_VAR 0 3
67462: PPUSH
67463: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67467: LD_ADDR_EXP 93
67471: PUSH
67472: LD_EXP 93
67476: PPUSH
67477: LD_VAR 0 4
67481: PPUSH
67482: LD_EXP 93
67486: PUSH
67487: LD_VAR 0 4
67491: ARRAY
67492: PPUSH
67493: LD_EXP 93
67497: PUSH
67498: LD_VAR 0 4
67502: ARRAY
67503: PUSH
67504: LD_INT 1
67506: MINUS
67507: PPUSH
67508: LD_EXP 93
67512: PUSH
67513: LD_VAR 0 4
67517: ARRAY
67518: PPUSH
67519: LD_INT 0
67521: PPUSH
67522: CALL 17966 0 4
67526: PPUSH
67527: CALL_OW 1
67531: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67532: LD_ADDR_EXP 93
67536: PUSH
67537: LD_EXP 93
67541: PPUSH
67542: LD_VAR 0 4
67546: PPUSH
67547: LD_EXP 93
67551: PUSH
67552: LD_VAR 0 4
67556: ARRAY
67557: PPUSH
67558: LD_EXP 93
67562: PUSH
67563: LD_VAR 0 4
67567: ARRAY
67568: PPUSH
67569: LD_INT 1
67571: PPUSH
67572: LD_INT 0
67574: PPUSH
67575: CALL 17966 0 4
67579: PPUSH
67580: CALL_OW 1
67584: ST_TO_ADDR
// continue ;
67585: GO 67159
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67587: LD_EXP 95
67591: PUSH
67592: LD_VAR 0 2
67596: ARRAY
67597: PUSH
67598: LD_EXP 96
67602: PUSH
67603: LD_VAR 0 2
67607: ARRAY
67608: NOT
67609: AND
67610: IFFALSE 67737
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67612: LD_ADDR_EXP 96
67616: PUSH
67617: LD_EXP 96
67621: PPUSH
67622: LD_VAR 0 2
67626: PUSH
67627: LD_EXP 96
67631: PUSH
67632: LD_VAR 0 2
67636: ARRAY
67637: PUSH
67638: LD_INT 1
67640: PLUS
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PPUSH
67646: LD_EXP 95
67650: PUSH
67651: LD_VAR 0 2
67655: ARRAY
67656: PUSH
67657: LD_INT 1
67659: ARRAY
67660: PPUSH
67661: CALL 18548 0 3
67665: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67666: LD_EXP 95
67670: PUSH
67671: LD_VAR 0 2
67675: ARRAY
67676: PUSH
67677: LD_INT 1
67679: ARRAY
67680: PPUSH
67681: LD_INT 112
67683: PPUSH
67684: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67688: LD_ADDR_VAR 0 9
67692: PUSH
67693: LD_EXP 95
67697: PUSH
67698: LD_VAR 0 2
67702: ARRAY
67703: PPUSH
67704: LD_INT 1
67706: PPUSH
67707: CALL_OW 3
67711: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67712: LD_ADDR_EXP 95
67716: PUSH
67717: LD_EXP 95
67721: PPUSH
67722: LD_VAR 0 2
67726: PPUSH
67727: LD_VAR 0 9
67731: PPUSH
67732: CALL_OW 1
67736: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67737: LD_EXP 95
67741: PUSH
67742: LD_VAR 0 2
67746: ARRAY
67747: PUSH
67748: LD_EXP 96
67752: PUSH
67753: LD_VAR 0 2
67757: ARRAY
67758: AND
67759: PUSH
67760: LD_EXP 96
67764: PUSH
67765: LD_VAR 0 2
67769: ARRAY
67770: PUSH
67771: LD_INT 1
67773: ARRAY
67774: PPUSH
67775: CALL_OW 310
67779: NOT
67780: AND
67781: PUSH
67782: LD_VAR 0 3
67786: PPUSH
67787: CALL_OW 313
67791: PUSH
67792: LD_INT 6
67794: EQUAL
67795: AND
67796: IFFALSE 67852
// begin tmp2 := UnitsInside ( j ) ;
67798: LD_ADDR_VAR 0 9
67802: PUSH
67803: LD_VAR 0 3
67807: PPUSH
67808: CALL_OW 313
67812: ST_TO_ADDR
// if tmp2 = 6 then
67813: LD_VAR 0 9
67817: PUSH
67818: LD_INT 6
67820: EQUAL
67821: IFFALSE 67852
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67823: LD_VAR 0 9
67827: PUSH
67828: LD_INT 1
67830: ARRAY
67831: PPUSH
67832: LD_INT 112
67834: PPUSH
67835: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67839: LD_VAR 0 9
67843: PUSH
67844: LD_INT 1
67846: ARRAY
67847: PPUSH
67848: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67852: LD_EXP 96
67856: PUSH
67857: LD_VAR 0 2
67861: ARRAY
67862: PUSH
67863: LD_EXP 96
67867: PUSH
67868: LD_VAR 0 2
67872: ARRAY
67873: PUSH
67874: LD_INT 1
67876: ARRAY
67877: PPUSH
67878: CALL_OW 314
67882: NOT
67883: AND
67884: PUSH
67885: LD_EXP 96
67889: PUSH
67890: LD_VAR 0 2
67894: ARRAY
67895: PUSH
67896: LD_INT 1
67898: ARRAY
67899: PPUSH
67900: CALL_OW 310
67904: NOT
67905: AND
67906: IFFALSE 67932
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67908: LD_EXP 96
67912: PUSH
67913: LD_VAR 0 2
67917: ARRAY
67918: PUSH
67919: LD_INT 1
67921: ARRAY
67922: PPUSH
67923: LD_VAR 0 3
67927: PPUSH
67928: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67932: LD_EXP 96
67936: PUSH
67937: LD_VAR 0 2
67941: ARRAY
67942: PUSH
67943: LD_INT 1
67945: ARRAY
67946: PPUSH
67947: CALL_OW 310
67951: PUSH
67952: LD_EXP 96
67956: PUSH
67957: LD_VAR 0 2
67961: ARRAY
67962: PUSH
67963: LD_INT 1
67965: ARRAY
67966: PPUSH
67967: CALL_OW 310
67971: PPUSH
67972: CALL_OW 461
67976: PUSH
67977: LD_INT 3
67979: NONEQUAL
67980: AND
67981: IFFALSE 68002
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67983: LD_EXP 96
67987: PUSH
67988: LD_VAR 0 2
67992: ARRAY
67993: PUSH
67994: LD_INT 1
67996: ARRAY
67997: PPUSH
67998: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68002: LD_VAR 0 3
68006: PPUSH
68007: CALL_OW 461
68011: PUSH
68012: LD_INT 6
68014: EQUAL
68015: PUSH
68016: LD_VAR 0 6
68020: PUSH
68021: LD_INT 1
68023: GREATER
68024: AND
68025: IFFALSE 68177
// begin sci := [ ] ;
68027: LD_ADDR_VAR 0 8
68031: PUSH
68032: EMPTY
68033: ST_TO_ADDR
// for x in ( tmp diff j ) do
68034: LD_ADDR_VAR 0 7
68038: PUSH
68039: LD_VAR 0 6
68043: PUSH
68044: LD_VAR 0 3
68048: DIFF
68049: PUSH
68050: FOR_IN
68051: IFFALSE 68103
// begin if sci = 6 then
68053: LD_VAR 0 8
68057: PUSH
68058: LD_INT 6
68060: EQUAL
68061: IFFALSE 68065
// break ;
68063: GO 68103
// if BuildingStatus ( x ) = bs_idle then
68065: LD_VAR 0 7
68069: PPUSH
68070: CALL_OW 461
68074: PUSH
68075: LD_INT 2
68077: EQUAL
68078: IFFALSE 68101
// sci := sci ^ UnitsInside ( x ) ;
68080: LD_ADDR_VAR 0 8
68084: PUSH
68085: LD_VAR 0 8
68089: PUSH
68090: LD_VAR 0 7
68094: PPUSH
68095: CALL_OW 313
68099: ADD
68100: ST_TO_ADDR
// end ;
68101: GO 68050
68103: POP
68104: POP
// if not sci then
68105: LD_VAR 0 8
68109: NOT
68110: IFFALSE 68114
// continue ;
68112: GO 67159
// for x in sci do
68114: LD_ADDR_VAR 0 7
68118: PUSH
68119: LD_VAR 0 8
68123: PUSH
68124: FOR_IN
68125: IFFALSE 68175
// if IsInUnit ( x ) and not HasTask ( x ) then
68127: LD_VAR 0 7
68131: PPUSH
68132: CALL_OW 310
68136: PUSH
68137: LD_VAR 0 7
68141: PPUSH
68142: CALL_OW 314
68146: NOT
68147: AND
68148: IFFALSE 68173
// begin ComExitBuilding ( x ) ;
68150: LD_VAR 0 7
68154: PPUSH
68155: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68159: LD_VAR 0 7
68163: PPUSH
68164: LD_VAR 0 3
68168: PPUSH
68169: CALL_OW 180
// end ;
68173: GO 68124
68175: POP
68176: POP
// end ; end ;
68177: GO 67159
68179: POP
68180: POP
// end ;
68181: GO 67113
68183: POP
68184: POP
// end ;
68185: LD_VAR 0 1
68189: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68190: LD_INT 0
68192: PPUSH
68193: PPUSH
// if not mc_bases then
68194: LD_EXP 66
68198: NOT
68199: IFFALSE 68203
// exit ;
68201: GO 68284
// for i = 1 to mc_bases do
68203: LD_ADDR_VAR 0 2
68207: PUSH
68208: DOUBLE
68209: LD_INT 1
68211: DEC
68212: ST_TO_ADDR
68213: LD_EXP 66
68217: PUSH
68218: FOR_TO
68219: IFFALSE 68282
// if mc_mines [ i ] and mc_miners [ i ] then
68221: LD_EXP 79
68225: PUSH
68226: LD_VAR 0 2
68230: ARRAY
68231: PUSH
68232: LD_EXP 80
68236: PUSH
68237: LD_VAR 0 2
68241: ARRAY
68242: AND
68243: IFFALSE 68280
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68245: LD_EXP 80
68249: PUSH
68250: LD_VAR 0 2
68254: ARRAY
68255: PUSH
68256: LD_INT 1
68258: ARRAY
68259: PPUSH
68260: CALL_OW 255
68264: PPUSH
68265: LD_EXP 79
68269: PUSH
68270: LD_VAR 0 2
68274: ARRAY
68275: PPUSH
68276: CALL 15537 0 2
68280: GO 68218
68282: POP
68283: POP
// end ;
68284: LD_VAR 0 1
68288: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
68289: LD_INT 0
68291: PPUSH
68292: PPUSH
68293: PPUSH
68294: PPUSH
68295: PPUSH
68296: PPUSH
68297: PPUSH
68298: PPUSH
// if not mc_bases or not mc_parking then
68299: LD_EXP 66
68303: NOT
68304: PUSH
68305: LD_EXP 90
68309: NOT
68310: OR
68311: IFFALSE 68315
// exit ;
68313: GO 69014
// for i = 1 to mc_bases do
68315: LD_ADDR_VAR 0 2
68319: PUSH
68320: DOUBLE
68321: LD_INT 1
68323: DEC
68324: ST_TO_ADDR
68325: LD_EXP 66
68329: PUSH
68330: FOR_TO
68331: IFFALSE 69012
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68333: LD_EXP 66
68337: PUSH
68338: LD_VAR 0 2
68342: ARRAY
68343: NOT
68344: PUSH
68345: LD_EXP 90
68349: PUSH
68350: LD_VAR 0 2
68354: ARRAY
68355: NOT
68356: OR
68357: IFFALSE 68361
// continue ;
68359: GO 68330
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68361: LD_ADDR_VAR 0 5
68365: PUSH
68366: LD_EXP 66
68370: PUSH
68371: LD_VAR 0 2
68375: ARRAY
68376: PUSH
68377: LD_INT 1
68379: ARRAY
68380: PPUSH
68381: CALL_OW 255
68385: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68386: LD_ADDR_VAR 0 6
68390: PUSH
68391: LD_EXP 66
68395: PUSH
68396: LD_VAR 0 2
68400: ARRAY
68401: PPUSH
68402: LD_INT 30
68404: PUSH
68405: LD_INT 3
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PPUSH
68412: CALL_OW 72
68416: ST_TO_ADDR
// if not fac then
68417: LD_VAR 0 6
68421: NOT
68422: IFFALSE 68473
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68424: LD_ADDR_VAR 0 6
68428: PUSH
68429: LD_EXP 66
68433: PUSH
68434: LD_VAR 0 2
68438: ARRAY
68439: PPUSH
68440: LD_INT 2
68442: PUSH
68443: LD_INT 30
68445: PUSH
68446: LD_INT 0
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 30
68455: PUSH
68456: LD_INT 1
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: LIST
68467: PPUSH
68468: CALL_OW 72
68472: ST_TO_ADDR
// if not fac then
68473: LD_VAR 0 6
68477: NOT
68478: IFFALSE 68482
// continue ;
68480: GO 68330
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68482: LD_ADDR_VAR 0 7
68486: PUSH
68487: LD_EXP 90
68491: PUSH
68492: LD_VAR 0 2
68496: ARRAY
68497: PPUSH
68498: LD_INT 22
68500: PUSH
68501: LD_VAR 0 5
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 21
68512: PUSH
68513: LD_INT 2
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 3
68522: PUSH
68523: LD_INT 24
68525: PUSH
68526: LD_INT 1000
68528: PUSH
68529: EMPTY
68530: LIST
68531: LIST
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: LIST
68541: PPUSH
68542: CALL_OW 70
68546: ST_TO_ADDR
// for j in fac do
68547: LD_ADDR_VAR 0 3
68551: PUSH
68552: LD_VAR 0 6
68556: PUSH
68557: FOR_IN
68558: IFFALSE 68639
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68560: LD_ADDR_VAR 0 7
68564: PUSH
68565: LD_VAR 0 7
68569: PUSH
68570: LD_INT 22
68572: PUSH
68573: LD_VAR 0 5
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 91
68584: PUSH
68585: LD_VAR 0 3
68589: PUSH
68590: LD_INT 15
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 21
68600: PUSH
68601: LD_INT 2
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: PUSH
68608: LD_INT 3
68610: PUSH
68611: LD_INT 24
68613: PUSH
68614: LD_INT 1000
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: PPUSH
68631: CALL_OW 69
68635: UNION
68636: ST_TO_ADDR
68637: GO 68557
68639: POP
68640: POP
// if not vehs then
68641: LD_VAR 0 7
68645: NOT
68646: IFFALSE 68672
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68648: LD_ADDR_EXP 78
68652: PUSH
68653: LD_EXP 78
68657: PPUSH
68658: LD_VAR 0 2
68662: PPUSH
68663: EMPTY
68664: PPUSH
68665: CALL_OW 1
68669: ST_TO_ADDR
// continue ;
68670: GO 68330
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68672: LD_ADDR_VAR 0 8
68676: PUSH
68677: LD_EXP 66
68681: PUSH
68682: LD_VAR 0 2
68686: ARRAY
68687: PPUSH
68688: LD_INT 30
68690: PUSH
68691: LD_INT 3
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PPUSH
68698: CALL_OW 72
68702: ST_TO_ADDR
// if tmp then
68703: LD_VAR 0 8
68707: IFFALSE 68810
// begin for j in tmp do
68709: LD_ADDR_VAR 0 3
68713: PUSH
68714: LD_VAR 0 8
68718: PUSH
68719: FOR_IN
68720: IFFALSE 68808
// for k in UnitsInside ( j ) do
68722: LD_ADDR_VAR 0 4
68726: PUSH
68727: LD_VAR 0 3
68731: PPUSH
68732: CALL_OW 313
68736: PUSH
68737: FOR_IN
68738: IFFALSE 68804
// if k then
68740: LD_VAR 0 4
68744: IFFALSE 68802
// if not k in mc_repair_vehicle [ i ] then
68746: LD_VAR 0 4
68750: PUSH
68751: LD_EXP 78
68755: PUSH
68756: LD_VAR 0 2
68760: ARRAY
68761: IN
68762: NOT
68763: IFFALSE 68802
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68765: LD_ADDR_EXP 78
68769: PUSH
68770: LD_EXP 78
68774: PPUSH
68775: LD_VAR 0 2
68779: PPUSH
68780: LD_EXP 78
68784: PUSH
68785: LD_VAR 0 2
68789: ARRAY
68790: PUSH
68791: LD_VAR 0 4
68795: UNION
68796: PPUSH
68797: CALL_OW 1
68801: ST_TO_ADDR
68802: GO 68737
68804: POP
68805: POP
68806: GO 68719
68808: POP
68809: POP
// end ; if not mc_repair_vehicle [ i ] then
68810: LD_EXP 78
68814: PUSH
68815: LD_VAR 0 2
68819: ARRAY
68820: NOT
68821: IFFALSE 68825
// continue ;
68823: GO 68330
// for j in mc_repair_vehicle [ i ] do
68825: LD_ADDR_VAR 0 3
68829: PUSH
68830: LD_EXP 78
68834: PUSH
68835: LD_VAR 0 2
68839: ARRAY
68840: PUSH
68841: FOR_IN
68842: IFFALSE 69008
// begin if GetClass ( j ) <> 3 then
68844: LD_VAR 0 3
68848: PPUSH
68849: CALL_OW 257
68853: PUSH
68854: LD_INT 3
68856: NONEQUAL
68857: IFFALSE 68898
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68859: LD_ADDR_EXP 78
68863: PUSH
68864: LD_EXP 78
68868: PPUSH
68869: LD_VAR 0 2
68873: PPUSH
68874: LD_EXP 78
68878: PUSH
68879: LD_VAR 0 2
68883: ARRAY
68884: PUSH
68885: LD_VAR 0 3
68889: DIFF
68890: PPUSH
68891: CALL_OW 1
68895: ST_TO_ADDR
// continue ;
68896: GO 68841
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68898: LD_VAR 0 3
68902: PPUSH
68903: CALL_OW 311
68907: NOT
68908: PUSH
68909: LD_VAR 0 3
68913: PUSH
68914: LD_EXP 69
68918: PUSH
68919: LD_VAR 0 2
68923: ARRAY
68924: PUSH
68925: LD_INT 1
68927: ARRAY
68928: IN
68929: NOT
68930: AND
68931: PUSH
68932: LD_VAR 0 3
68936: PUSH
68937: LD_EXP 69
68941: PUSH
68942: LD_VAR 0 2
68946: ARRAY
68947: PUSH
68948: LD_INT 2
68950: ARRAY
68951: IN
68952: NOT
68953: AND
68954: IFFALSE 69006
// begin if IsInUnit ( j ) then
68956: LD_VAR 0 3
68960: PPUSH
68961: CALL_OW 310
68965: IFFALSE 68976
// ComExitBuilding ( j ) ;
68967: LD_VAR 0 3
68971: PPUSH
68972: CALL_OW 122
// if not HasTask ( j ) then
68976: LD_VAR 0 3
68980: PPUSH
68981: CALL_OW 314
68985: NOT
68986: IFFALSE 69006
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
68988: LD_VAR 0 3
68992: PPUSH
68993: LD_VAR 0 7
68997: PUSH
68998: LD_INT 1
69000: ARRAY
69001: PPUSH
69002: CALL_OW 189
// end ; end ;
69006: GO 68841
69008: POP
69009: POP
// end ;
69010: GO 68330
69012: POP
69013: POP
// end ;
69014: LD_VAR 0 1
69018: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69019: LD_INT 0
69021: PPUSH
69022: PPUSH
69023: PPUSH
69024: PPUSH
69025: PPUSH
69026: PPUSH
69027: PPUSH
69028: PPUSH
69029: PPUSH
69030: PPUSH
69031: PPUSH
// if not mc_bases then
69032: LD_EXP 66
69036: NOT
69037: IFFALSE 69041
// exit ;
69039: GO 69843
// for i = 1 to mc_bases do
69041: LD_ADDR_VAR 0 2
69045: PUSH
69046: DOUBLE
69047: LD_INT 1
69049: DEC
69050: ST_TO_ADDR
69051: LD_EXP 66
69055: PUSH
69056: FOR_TO
69057: IFFALSE 69841
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69059: LD_EXP 94
69063: PUSH
69064: LD_VAR 0 2
69068: ARRAY
69069: NOT
69070: PUSH
69071: LD_EXP 69
69075: PUSH
69076: LD_VAR 0 2
69080: ARRAY
69081: PUSH
69082: LD_INT 1
69084: ARRAY
69085: OR
69086: PUSH
69087: LD_EXP 69
69091: PUSH
69092: LD_VAR 0 2
69096: ARRAY
69097: PUSH
69098: LD_INT 2
69100: ARRAY
69101: OR
69102: PUSH
69103: LD_EXP 92
69107: PUSH
69108: LD_VAR 0 2
69112: ARRAY
69113: PPUSH
69114: LD_INT 1
69116: PPUSH
69117: CALL_OW 325
69121: NOT
69122: OR
69123: PUSH
69124: LD_EXP 89
69128: PUSH
69129: LD_VAR 0 2
69133: ARRAY
69134: OR
69135: IFFALSE 69139
// continue ;
69137: GO 69056
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69139: LD_ADDR_VAR 0 8
69143: PUSH
69144: LD_EXP 66
69148: PUSH
69149: LD_VAR 0 2
69153: ARRAY
69154: PPUSH
69155: LD_INT 25
69157: PUSH
69158: LD_INT 4
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 50
69167: PUSH
69168: EMPTY
69169: LIST
69170: PUSH
69171: LD_INT 3
69173: PUSH
69174: LD_INT 60
69176: PUSH
69177: EMPTY
69178: LIST
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: LIST
69188: PPUSH
69189: CALL_OW 72
69193: PUSH
69194: LD_EXP 70
69198: PUSH
69199: LD_VAR 0 2
69203: ARRAY
69204: DIFF
69205: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69206: LD_ADDR_VAR 0 9
69210: PUSH
69211: LD_EXP 66
69215: PUSH
69216: LD_VAR 0 2
69220: ARRAY
69221: PPUSH
69222: LD_INT 2
69224: PUSH
69225: LD_INT 30
69227: PUSH
69228: LD_INT 0
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: LD_INT 30
69237: PUSH
69238: LD_INT 1
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: LIST
69249: PPUSH
69250: CALL_OW 72
69254: ST_TO_ADDR
// if not tmp or not dep then
69255: LD_VAR 0 8
69259: NOT
69260: PUSH
69261: LD_VAR 0 9
69265: NOT
69266: OR
69267: IFFALSE 69271
// continue ;
69269: GO 69056
// side := GetSide ( tmp [ 1 ] ) ;
69271: LD_ADDR_VAR 0 11
69275: PUSH
69276: LD_VAR 0 8
69280: PUSH
69281: LD_INT 1
69283: ARRAY
69284: PPUSH
69285: CALL_OW 255
69289: ST_TO_ADDR
// dep := dep [ 1 ] ;
69290: LD_ADDR_VAR 0 9
69294: PUSH
69295: LD_VAR 0 9
69299: PUSH
69300: LD_INT 1
69302: ARRAY
69303: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
69304: LD_ADDR_VAR 0 7
69308: PUSH
69309: LD_EXP 94
69313: PUSH
69314: LD_VAR 0 2
69318: ARRAY
69319: PPUSH
69320: LD_INT 22
69322: PUSH
69323: LD_INT 0
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: LD_INT 25
69332: PUSH
69333: LD_INT 12
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PPUSH
69344: CALL_OW 70
69348: PUSH
69349: LD_INT 22
69351: PUSH
69352: LD_INT 0
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 25
69361: PUSH
69362: LD_INT 12
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 91
69371: PUSH
69372: LD_VAR 0 9
69376: PUSH
69377: LD_INT 20
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: LIST
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: LIST
69389: PPUSH
69390: CALL_OW 69
69394: UNION
69395: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69396: LD_ADDR_VAR 0 10
69400: PUSH
69401: LD_EXP 94
69405: PUSH
69406: LD_VAR 0 2
69410: ARRAY
69411: PPUSH
69412: LD_INT 81
69414: PUSH
69415: LD_VAR 0 11
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PPUSH
69424: CALL_OW 70
69428: ST_TO_ADDR
// if not apes or danger_at_area then
69429: LD_VAR 0 7
69433: NOT
69434: PUSH
69435: LD_VAR 0 10
69439: OR
69440: IFFALSE 69490
// begin if mc_taming [ i ] then
69442: LD_EXP 97
69446: PUSH
69447: LD_VAR 0 2
69451: ARRAY
69452: IFFALSE 69488
// begin MC_Reset ( i , 121 ) ;
69454: LD_VAR 0 2
69458: PPUSH
69459: LD_INT 121
69461: PPUSH
69462: CALL 54893 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69466: LD_ADDR_EXP 97
69470: PUSH
69471: LD_EXP 97
69475: PPUSH
69476: LD_VAR 0 2
69480: PPUSH
69481: EMPTY
69482: PPUSH
69483: CALL_OW 1
69487: ST_TO_ADDR
// end ; continue ;
69488: GO 69056
// end ; for j in tmp do
69490: LD_ADDR_VAR 0 3
69494: PUSH
69495: LD_VAR 0 8
69499: PUSH
69500: FOR_IN
69501: IFFALSE 69837
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69503: LD_VAR 0 3
69507: PUSH
69508: LD_EXP 97
69512: PUSH
69513: LD_VAR 0 2
69517: ARRAY
69518: IN
69519: NOT
69520: PUSH
69521: LD_EXP 97
69525: PUSH
69526: LD_VAR 0 2
69530: ARRAY
69531: PUSH
69532: LD_INT 3
69534: LESS
69535: AND
69536: IFFALSE 69594
// begin SetTag ( j , 121 ) ;
69538: LD_VAR 0 3
69542: PPUSH
69543: LD_INT 121
69545: PPUSH
69546: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69550: LD_ADDR_EXP 97
69554: PUSH
69555: LD_EXP 97
69559: PPUSH
69560: LD_VAR 0 2
69564: PUSH
69565: LD_EXP 97
69569: PUSH
69570: LD_VAR 0 2
69574: ARRAY
69575: PUSH
69576: LD_INT 1
69578: PLUS
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PPUSH
69584: LD_VAR 0 3
69588: PPUSH
69589: CALL 18548 0 3
69593: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69594: LD_VAR 0 3
69598: PUSH
69599: LD_EXP 97
69603: PUSH
69604: LD_VAR 0 2
69608: ARRAY
69609: IN
69610: IFFALSE 69835
// begin if GetClass ( j ) <> 4 then
69612: LD_VAR 0 3
69616: PPUSH
69617: CALL_OW 257
69621: PUSH
69622: LD_INT 4
69624: NONEQUAL
69625: IFFALSE 69678
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69627: LD_ADDR_EXP 97
69631: PUSH
69632: LD_EXP 97
69636: PPUSH
69637: LD_VAR 0 2
69641: PPUSH
69642: LD_EXP 97
69646: PUSH
69647: LD_VAR 0 2
69651: ARRAY
69652: PUSH
69653: LD_VAR 0 3
69657: DIFF
69658: PPUSH
69659: CALL_OW 1
69663: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69664: LD_VAR 0 3
69668: PPUSH
69669: LD_INT 0
69671: PPUSH
69672: CALL_OW 109
// continue ;
69676: GO 69500
// end ; if IsInUnit ( j ) then
69678: LD_VAR 0 3
69682: PPUSH
69683: CALL_OW 310
69687: IFFALSE 69698
// ComExitBuilding ( j ) ;
69689: LD_VAR 0 3
69693: PPUSH
69694: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69698: LD_ADDR_VAR 0 6
69702: PUSH
69703: LD_VAR 0 7
69707: PPUSH
69708: LD_VAR 0 3
69712: PPUSH
69713: CALL_OW 74
69717: ST_TO_ADDR
// if not ape then
69718: LD_VAR 0 6
69722: NOT
69723: IFFALSE 69727
// break ;
69725: GO 69837
// x := GetX ( ape ) ;
69727: LD_ADDR_VAR 0 4
69731: PUSH
69732: LD_VAR 0 6
69736: PPUSH
69737: CALL_OW 250
69741: ST_TO_ADDR
// y := GetY ( ape ) ;
69742: LD_ADDR_VAR 0 5
69746: PUSH
69747: LD_VAR 0 6
69751: PPUSH
69752: CALL_OW 251
69756: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69757: LD_VAR 0 4
69761: PPUSH
69762: LD_VAR 0 5
69766: PPUSH
69767: CALL_OW 488
69771: NOT
69772: PUSH
69773: LD_VAR 0 11
69777: PPUSH
69778: LD_VAR 0 4
69782: PPUSH
69783: LD_VAR 0 5
69787: PPUSH
69788: LD_INT 20
69790: PPUSH
69791: CALL 19444 0 4
69795: PUSH
69796: LD_INT 4
69798: ARRAY
69799: OR
69800: IFFALSE 69804
// break ;
69802: GO 69837
// if not HasTask ( j ) then
69804: LD_VAR 0 3
69808: PPUSH
69809: CALL_OW 314
69813: NOT
69814: IFFALSE 69835
// ComTameXY ( j , x , y ) ;
69816: LD_VAR 0 3
69820: PPUSH
69821: LD_VAR 0 4
69825: PPUSH
69826: LD_VAR 0 5
69830: PPUSH
69831: CALL_OW 131
// end ; end ;
69835: GO 69500
69837: POP
69838: POP
// end ;
69839: GO 69056
69841: POP
69842: POP
// end ;
69843: LD_VAR 0 1
69847: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69848: LD_INT 0
69850: PPUSH
69851: PPUSH
69852: PPUSH
69853: PPUSH
69854: PPUSH
69855: PPUSH
69856: PPUSH
69857: PPUSH
// if not mc_bases then
69858: LD_EXP 66
69862: NOT
69863: IFFALSE 69867
// exit ;
69865: GO 70493
// for i = 1 to mc_bases do
69867: LD_ADDR_VAR 0 2
69871: PUSH
69872: DOUBLE
69873: LD_INT 1
69875: DEC
69876: ST_TO_ADDR
69877: LD_EXP 66
69881: PUSH
69882: FOR_TO
69883: IFFALSE 70491
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69885: LD_EXP 95
69889: PUSH
69890: LD_VAR 0 2
69894: ARRAY
69895: NOT
69896: PUSH
69897: LD_EXP 95
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: PPUSH
69908: LD_INT 25
69910: PUSH
69911: LD_INT 12
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PPUSH
69918: CALL_OW 72
69922: NOT
69923: OR
69924: IFFALSE 69928
// continue ;
69926: GO 69882
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69928: LD_ADDR_VAR 0 5
69932: PUSH
69933: LD_EXP 95
69937: PUSH
69938: LD_VAR 0 2
69942: ARRAY
69943: PUSH
69944: LD_INT 1
69946: ARRAY
69947: PPUSH
69948: CALL_OW 255
69952: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69953: LD_VAR 0 5
69957: PPUSH
69958: LD_INT 2
69960: PPUSH
69961: CALL_OW 325
69965: IFFALSE 70218
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69967: LD_ADDR_VAR 0 4
69971: PUSH
69972: LD_EXP 95
69976: PUSH
69977: LD_VAR 0 2
69981: ARRAY
69982: PPUSH
69983: LD_INT 25
69985: PUSH
69986: LD_INT 16
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PPUSH
69993: CALL_OW 72
69997: ST_TO_ADDR
// if tmp < 6 then
69998: LD_VAR 0 4
70002: PUSH
70003: LD_INT 6
70005: LESS
70006: IFFALSE 70218
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70008: LD_ADDR_VAR 0 6
70012: PUSH
70013: LD_EXP 66
70017: PUSH
70018: LD_VAR 0 2
70022: ARRAY
70023: PPUSH
70024: LD_INT 2
70026: PUSH
70027: LD_INT 30
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 30
70039: PUSH
70040: LD_INT 1
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: LIST
70051: PPUSH
70052: CALL_OW 72
70056: ST_TO_ADDR
// if depot then
70057: LD_VAR 0 6
70061: IFFALSE 70218
// begin selected := 0 ;
70063: LD_ADDR_VAR 0 7
70067: PUSH
70068: LD_INT 0
70070: ST_TO_ADDR
// for j in depot do
70071: LD_ADDR_VAR 0 3
70075: PUSH
70076: LD_VAR 0 6
70080: PUSH
70081: FOR_IN
70082: IFFALSE 70113
// begin if UnitsInside ( j ) < 6 then
70084: LD_VAR 0 3
70088: PPUSH
70089: CALL_OW 313
70093: PUSH
70094: LD_INT 6
70096: LESS
70097: IFFALSE 70111
// begin selected := j ;
70099: LD_ADDR_VAR 0 7
70103: PUSH
70104: LD_VAR 0 3
70108: ST_TO_ADDR
// break ;
70109: GO 70113
// end ; end ;
70111: GO 70081
70113: POP
70114: POP
// if selected then
70115: LD_VAR 0 7
70119: IFFALSE 70218
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70121: LD_ADDR_VAR 0 3
70125: PUSH
70126: LD_EXP 95
70130: PUSH
70131: LD_VAR 0 2
70135: ARRAY
70136: PPUSH
70137: LD_INT 25
70139: PUSH
70140: LD_INT 12
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PPUSH
70147: CALL_OW 72
70151: PUSH
70152: FOR_IN
70153: IFFALSE 70216
// if not HasTask ( j ) then
70155: LD_VAR 0 3
70159: PPUSH
70160: CALL_OW 314
70164: NOT
70165: IFFALSE 70214
// begin if not IsInUnit ( j ) then
70167: LD_VAR 0 3
70171: PPUSH
70172: CALL_OW 310
70176: NOT
70177: IFFALSE 70193
// ComEnterUnit ( j , selected ) ;
70179: LD_VAR 0 3
70183: PPUSH
70184: LD_VAR 0 7
70188: PPUSH
70189: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70193: LD_VAR 0 3
70197: PPUSH
70198: LD_INT 16
70200: PPUSH
70201: CALL_OW 183
// AddComExitBuilding ( j ) ;
70205: LD_VAR 0 3
70209: PPUSH
70210: CALL_OW 182
// end ;
70214: GO 70152
70216: POP
70217: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70218: LD_VAR 0 5
70222: PPUSH
70223: LD_INT 11
70225: PPUSH
70226: CALL_OW 325
70230: IFFALSE 70489
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70232: LD_ADDR_VAR 0 4
70236: PUSH
70237: LD_EXP 95
70241: PUSH
70242: LD_VAR 0 2
70246: ARRAY
70247: PPUSH
70248: LD_INT 25
70250: PUSH
70251: LD_INT 16
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: PPUSH
70258: CALL_OW 72
70262: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70263: LD_VAR 0 4
70267: PUSH
70268: LD_INT 6
70270: GREATEREQUAL
70271: PUSH
70272: LD_VAR 0 5
70276: PPUSH
70277: LD_INT 2
70279: PPUSH
70280: CALL_OW 325
70284: NOT
70285: OR
70286: IFFALSE 70489
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70288: LD_ADDR_VAR 0 8
70292: PUSH
70293: LD_EXP 66
70297: PUSH
70298: LD_VAR 0 2
70302: ARRAY
70303: PPUSH
70304: LD_INT 2
70306: PUSH
70307: LD_INT 30
70309: PUSH
70310: LD_INT 4
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: LD_INT 30
70319: PUSH
70320: LD_INT 5
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: LIST
70331: PPUSH
70332: CALL_OW 72
70336: ST_TO_ADDR
// if barracks then
70337: LD_VAR 0 8
70341: IFFALSE 70489
// begin selected := 0 ;
70343: LD_ADDR_VAR 0 7
70347: PUSH
70348: LD_INT 0
70350: ST_TO_ADDR
// for j in barracks do
70351: LD_ADDR_VAR 0 3
70355: PUSH
70356: LD_VAR 0 8
70360: PUSH
70361: FOR_IN
70362: IFFALSE 70393
// begin if UnitsInside ( j ) < 6 then
70364: LD_VAR 0 3
70368: PPUSH
70369: CALL_OW 313
70373: PUSH
70374: LD_INT 6
70376: LESS
70377: IFFALSE 70391
// begin selected := j ;
70379: LD_ADDR_VAR 0 7
70383: PUSH
70384: LD_VAR 0 3
70388: ST_TO_ADDR
// break ;
70389: GO 70393
// end ; end ;
70391: GO 70361
70393: POP
70394: POP
// if selected then
70395: LD_VAR 0 7
70399: IFFALSE 70489
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70401: LD_ADDR_VAR 0 3
70405: PUSH
70406: LD_EXP 95
70410: PUSH
70411: LD_VAR 0 2
70415: ARRAY
70416: PPUSH
70417: LD_INT 25
70419: PUSH
70420: LD_INT 12
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PPUSH
70427: CALL_OW 72
70431: PUSH
70432: FOR_IN
70433: IFFALSE 70487
// if not IsInUnit ( j ) and not HasTask ( j ) then
70435: LD_VAR 0 3
70439: PPUSH
70440: CALL_OW 310
70444: NOT
70445: PUSH
70446: LD_VAR 0 3
70450: PPUSH
70451: CALL_OW 314
70455: NOT
70456: AND
70457: IFFALSE 70485
// begin ComEnterUnit ( j , selected ) ;
70459: LD_VAR 0 3
70463: PPUSH
70464: LD_VAR 0 7
70468: PPUSH
70469: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
70473: LD_VAR 0 3
70477: PPUSH
70478: LD_INT 15
70480: PPUSH
70481: CALL_OW 183
// end ;
70485: GO 70432
70487: POP
70488: POP
// end ; end ; end ; end ; end ;
70489: GO 69882
70491: POP
70492: POP
// end ;
70493: LD_VAR 0 1
70497: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70498: LD_INT 0
70500: PPUSH
70501: PPUSH
70502: PPUSH
70503: PPUSH
// if not mc_bases then
70504: LD_EXP 66
70508: NOT
70509: IFFALSE 70513
// exit ;
70511: GO 70691
// for i = 1 to mc_bases do
70513: LD_ADDR_VAR 0 2
70517: PUSH
70518: DOUBLE
70519: LD_INT 1
70521: DEC
70522: ST_TO_ADDR
70523: LD_EXP 66
70527: PUSH
70528: FOR_TO
70529: IFFALSE 70689
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70531: LD_ADDR_VAR 0 4
70535: PUSH
70536: LD_EXP 66
70540: PUSH
70541: LD_VAR 0 2
70545: ARRAY
70546: PPUSH
70547: LD_INT 25
70549: PUSH
70550: LD_INT 9
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PPUSH
70557: CALL_OW 72
70561: ST_TO_ADDR
// if not tmp then
70562: LD_VAR 0 4
70566: NOT
70567: IFFALSE 70571
// continue ;
70569: GO 70528
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70571: LD_EXP 92
70575: PUSH
70576: LD_VAR 0 2
70580: ARRAY
70581: PPUSH
70582: LD_INT 29
70584: PPUSH
70585: CALL_OW 325
70589: NOT
70590: PUSH
70591: LD_EXP 92
70595: PUSH
70596: LD_VAR 0 2
70600: ARRAY
70601: PPUSH
70602: LD_INT 28
70604: PPUSH
70605: CALL_OW 325
70609: NOT
70610: AND
70611: IFFALSE 70615
// continue ;
70613: GO 70528
// for j in tmp do
70615: LD_ADDR_VAR 0 3
70619: PUSH
70620: LD_VAR 0 4
70624: PUSH
70625: FOR_IN
70626: IFFALSE 70685
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70628: LD_VAR 0 3
70632: PUSH
70633: LD_EXP 69
70637: PUSH
70638: LD_VAR 0 2
70642: ARRAY
70643: PUSH
70644: LD_INT 1
70646: ARRAY
70647: IN
70648: NOT
70649: PUSH
70650: LD_VAR 0 3
70654: PUSH
70655: LD_EXP 69
70659: PUSH
70660: LD_VAR 0 2
70664: ARRAY
70665: PUSH
70666: LD_INT 2
70668: ARRAY
70669: IN
70670: NOT
70671: AND
70672: IFFALSE 70683
// ComSpaceTimeShoot ( j ) ;
70674: LD_VAR 0 3
70678: PPUSH
70679: CALL 14545 0 1
70683: GO 70625
70685: POP
70686: POP
// end ;
70687: GO 70528
70689: POP
70690: POP
// end ;
70691: LD_VAR 0 1
70695: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70696: LD_INT 0
70698: PPUSH
70699: PPUSH
70700: PPUSH
70701: PPUSH
70702: PPUSH
70703: PPUSH
70704: PPUSH
70705: PPUSH
70706: PPUSH
// if not mc_bases then
70707: LD_EXP 66
70711: NOT
70712: IFFALSE 70716
// exit ;
70714: GO 71338
// for i = 1 to mc_bases do
70716: LD_ADDR_VAR 0 2
70720: PUSH
70721: DOUBLE
70722: LD_INT 1
70724: DEC
70725: ST_TO_ADDR
70726: LD_EXP 66
70730: PUSH
70731: FOR_TO
70732: IFFALSE 71336
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70734: LD_EXP 101
70738: PUSH
70739: LD_VAR 0 2
70743: ARRAY
70744: NOT
70745: PUSH
70746: LD_INT 38
70748: PPUSH
70749: LD_EXP 92
70753: PUSH
70754: LD_VAR 0 2
70758: ARRAY
70759: PPUSH
70760: CALL_OW 321
70764: PUSH
70765: LD_INT 2
70767: NONEQUAL
70768: OR
70769: IFFALSE 70773
// continue ;
70771: GO 70731
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70773: LD_ADDR_VAR 0 8
70777: PUSH
70778: LD_EXP 66
70782: PUSH
70783: LD_VAR 0 2
70787: ARRAY
70788: PPUSH
70789: LD_INT 30
70791: PUSH
70792: LD_INT 34
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PPUSH
70799: CALL_OW 72
70803: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70804: LD_ADDR_VAR 0 9
70808: PUSH
70809: LD_EXP 66
70813: PUSH
70814: LD_VAR 0 2
70818: ARRAY
70819: PPUSH
70820: LD_INT 25
70822: PUSH
70823: LD_INT 4
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PPUSH
70830: CALL_OW 72
70834: PPUSH
70835: LD_INT 0
70837: PPUSH
70838: CALL 47109 0 2
70842: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70843: LD_VAR 0 9
70847: NOT
70848: PUSH
70849: LD_VAR 0 8
70853: NOT
70854: OR
70855: PUSH
70856: LD_EXP 66
70860: PUSH
70861: LD_VAR 0 2
70865: ARRAY
70866: PPUSH
70867: LD_INT 124
70869: PPUSH
70870: CALL 47109 0 2
70874: OR
70875: IFFALSE 70879
// continue ;
70877: GO 70731
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70879: LD_EXP 102
70883: PUSH
70884: LD_VAR 0 2
70888: ARRAY
70889: PUSH
70890: LD_EXP 101
70894: PUSH
70895: LD_VAR 0 2
70899: ARRAY
70900: LESS
70901: PUSH
70902: LD_EXP 102
70906: PUSH
70907: LD_VAR 0 2
70911: ARRAY
70912: PUSH
70913: LD_VAR 0 8
70917: LESS
70918: AND
70919: IFFALSE 71334
// begin tmp := sci [ 1 ] ;
70921: LD_ADDR_VAR 0 7
70925: PUSH
70926: LD_VAR 0 9
70930: PUSH
70931: LD_INT 1
70933: ARRAY
70934: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70935: LD_VAR 0 7
70939: PPUSH
70940: LD_INT 124
70942: PPUSH
70943: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70947: LD_ADDR_VAR 0 3
70951: PUSH
70952: DOUBLE
70953: LD_EXP 101
70957: PUSH
70958: LD_VAR 0 2
70962: ARRAY
70963: INC
70964: ST_TO_ADDR
70965: LD_EXP 101
70969: PUSH
70970: LD_VAR 0 2
70974: ARRAY
70975: PUSH
70976: FOR_DOWNTO
70977: IFFALSE 71320
// begin if IsInUnit ( tmp ) then
70979: LD_VAR 0 7
70983: PPUSH
70984: CALL_OW 310
70988: IFFALSE 70999
// ComExitBuilding ( tmp ) ;
70990: LD_VAR 0 7
70994: PPUSH
70995: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70999: LD_INT 35
71001: PPUSH
71002: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71006: LD_VAR 0 7
71010: PPUSH
71011: CALL_OW 310
71015: NOT
71016: PUSH
71017: LD_VAR 0 7
71021: PPUSH
71022: CALL_OW 314
71026: NOT
71027: AND
71028: IFFALSE 70999
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71030: LD_ADDR_VAR 0 6
71034: PUSH
71035: LD_VAR 0 7
71039: PPUSH
71040: CALL_OW 250
71044: PUSH
71045: LD_VAR 0 7
71049: PPUSH
71050: CALL_OW 251
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71059: LD_INT 35
71061: PPUSH
71062: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71066: LD_ADDR_VAR 0 4
71070: PUSH
71071: LD_EXP 101
71075: PUSH
71076: LD_VAR 0 2
71080: ARRAY
71081: PUSH
71082: LD_VAR 0 3
71086: ARRAY
71087: PUSH
71088: LD_INT 1
71090: ARRAY
71091: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71092: LD_ADDR_VAR 0 5
71096: PUSH
71097: LD_EXP 101
71101: PUSH
71102: LD_VAR 0 2
71106: ARRAY
71107: PUSH
71108: LD_VAR 0 3
71112: ARRAY
71113: PUSH
71114: LD_INT 2
71116: ARRAY
71117: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71118: LD_VAR 0 7
71122: PPUSH
71123: LD_INT 10
71125: PPUSH
71126: CALL 21141 0 2
71130: PUSH
71131: LD_INT 4
71133: ARRAY
71134: IFFALSE 71172
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71136: LD_VAR 0 7
71140: PPUSH
71141: LD_VAR 0 6
71145: PUSH
71146: LD_INT 1
71148: ARRAY
71149: PPUSH
71150: LD_VAR 0 6
71154: PUSH
71155: LD_INT 2
71157: ARRAY
71158: PPUSH
71159: CALL_OW 111
// wait ( 0 0$10 ) ;
71163: LD_INT 350
71165: PPUSH
71166: CALL_OW 67
// end else
71170: GO 71198
// begin ComMoveXY ( tmp , x , y ) ;
71172: LD_VAR 0 7
71176: PPUSH
71177: LD_VAR 0 4
71181: PPUSH
71182: LD_VAR 0 5
71186: PPUSH
71187: CALL_OW 111
// wait ( 0 0$3 ) ;
71191: LD_INT 105
71193: PPUSH
71194: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71198: LD_VAR 0 7
71202: PPUSH
71203: LD_VAR 0 4
71207: PPUSH
71208: LD_VAR 0 5
71212: PPUSH
71213: CALL_OW 307
71217: IFFALSE 71059
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71219: LD_VAR 0 7
71223: PPUSH
71224: LD_VAR 0 4
71228: PPUSH
71229: LD_VAR 0 5
71233: PPUSH
71234: LD_VAR 0 8
71238: PUSH
71239: LD_VAR 0 3
71243: ARRAY
71244: PPUSH
71245: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71249: LD_INT 35
71251: PPUSH
71252: CALL_OW 67
// until not HasTask ( tmp ) ;
71256: LD_VAR 0 7
71260: PPUSH
71261: CALL_OW 314
71265: NOT
71266: IFFALSE 71249
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71268: LD_ADDR_EXP 102
71272: PUSH
71273: LD_EXP 102
71277: PPUSH
71278: LD_VAR 0 2
71282: PUSH
71283: LD_EXP 102
71287: PUSH
71288: LD_VAR 0 2
71292: ARRAY
71293: PUSH
71294: LD_INT 1
71296: PLUS
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PPUSH
71302: LD_VAR 0 8
71306: PUSH
71307: LD_VAR 0 3
71311: ARRAY
71312: PPUSH
71313: CALL 18548 0 3
71317: ST_TO_ADDR
// end ;
71318: GO 70976
71320: POP
71321: POP
// MC_Reset ( i , 124 ) ;
71322: LD_VAR 0 2
71326: PPUSH
71327: LD_INT 124
71329: PPUSH
71330: CALL 54893 0 2
// end ; end ;
71334: GO 70731
71336: POP
71337: POP
// end ;
71338: LD_VAR 0 1
71342: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71343: LD_INT 0
71345: PPUSH
71346: PPUSH
71347: PPUSH
// if not mc_bases then
71348: LD_EXP 66
71352: NOT
71353: IFFALSE 71357
// exit ;
71355: GO 71963
// for i = 1 to mc_bases do
71357: LD_ADDR_VAR 0 2
71361: PUSH
71362: DOUBLE
71363: LD_INT 1
71365: DEC
71366: ST_TO_ADDR
71367: LD_EXP 66
71371: PUSH
71372: FOR_TO
71373: IFFALSE 71961
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71375: LD_ADDR_VAR 0 3
71379: PUSH
71380: LD_EXP 66
71384: PUSH
71385: LD_VAR 0 2
71389: ARRAY
71390: PPUSH
71391: LD_INT 25
71393: PUSH
71394: LD_INT 4
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PPUSH
71401: CALL_OW 72
71405: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71406: LD_VAR 0 3
71410: NOT
71411: PUSH
71412: LD_EXP 103
71416: PUSH
71417: LD_VAR 0 2
71421: ARRAY
71422: NOT
71423: OR
71424: PUSH
71425: LD_EXP 66
71429: PUSH
71430: LD_VAR 0 2
71434: ARRAY
71435: PPUSH
71436: LD_INT 2
71438: PUSH
71439: LD_INT 30
71441: PUSH
71442: LD_INT 0
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 30
71451: PUSH
71452: LD_INT 1
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: LIST
71463: PPUSH
71464: CALL_OW 72
71468: NOT
71469: OR
71470: IFFALSE 71520
// begin if mc_deposits_finder [ i ] then
71472: LD_EXP 104
71476: PUSH
71477: LD_VAR 0 2
71481: ARRAY
71482: IFFALSE 71518
// begin MC_Reset ( i , 125 ) ;
71484: LD_VAR 0 2
71488: PPUSH
71489: LD_INT 125
71491: PPUSH
71492: CALL 54893 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71496: LD_ADDR_EXP 104
71500: PUSH
71501: LD_EXP 104
71505: PPUSH
71506: LD_VAR 0 2
71510: PPUSH
71511: EMPTY
71512: PPUSH
71513: CALL_OW 1
71517: ST_TO_ADDR
// end ; continue ;
71518: GO 71372
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71520: LD_EXP 103
71524: PUSH
71525: LD_VAR 0 2
71529: ARRAY
71530: PUSH
71531: LD_INT 1
71533: ARRAY
71534: PUSH
71535: LD_INT 3
71537: ARRAY
71538: PUSH
71539: LD_INT 1
71541: EQUAL
71542: PUSH
71543: LD_INT 20
71545: PPUSH
71546: LD_EXP 92
71550: PUSH
71551: LD_VAR 0 2
71555: ARRAY
71556: PPUSH
71557: CALL_OW 321
71561: PUSH
71562: LD_INT 2
71564: NONEQUAL
71565: AND
71566: IFFALSE 71616
// begin if mc_deposits_finder [ i ] then
71568: LD_EXP 104
71572: PUSH
71573: LD_VAR 0 2
71577: ARRAY
71578: IFFALSE 71614
// begin MC_Reset ( i , 125 ) ;
71580: LD_VAR 0 2
71584: PPUSH
71585: LD_INT 125
71587: PPUSH
71588: CALL 54893 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71592: LD_ADDR_EXP 104
71596: PUSH
71597: LD_EXP 104
71601: PPUSH
71602: LD_VAR 0 2
71606: PPUSH
71607: EMPTY
71608: PPUSH
71609: CALL_OW 1
71613: ST_TO_ADDR
// end ; continue ;
71614: GO 71372
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71616: LD_EXP 103
71620: PUSH
71621: LD_VAR 0 2
71625: ARRAY
71626: PUSH
71627: LD_INT 1
71629: ARRAY
71630: PUSH
71631: LD_INT 1
71633: ARRAY
71634: PPUSH
71635: LD_EXP 103
71639: PUSH
71640: LD_VAR 0 2
71644: ARRAY
71645: PUSH
71646: LD_INT 1
71648: ARRAY
71649: PUSH
71650: LD_INT 2
71652: ARRAY
71653: PPUSH
71654: LD_EXP 92
71658: PUSH
71659: LD_VAR 0 2
71663: ARRAY
71664: PPUSH
71665: CALL_OW 440
71669: IFFALSE 71712
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71671: LD_ADDR_EXP 103
71675: PUSH
71676: LD_EXP 103
71680: PPUSH
71681: LD_VAR 0 2
71685: PPUSH
71686: LD_EXP 103
71690: PUSH
71691: LD_VAR 0 2
71695: ARRAY
71696: PPUSH
71697: LD_INT 1
71699: PPUSH
71700: CALL_OW 3
71704: PPUSH
71705: CALL_OW 1
71709: ST_TO_ADDR
71710: GO 71959
// begin if not mc_deposits_finder [ i ] then
71712: LD_EXP 104
71716: PUSH
71717: LD_VAR 0 2
71721: ARRAY
71722: NOT
71723: IFFALSE 71775
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71725: LD_ADDR_EXP 104
71729: PUSH
71730: LD_EXP 104
71734: PPUSH
71735: LD_VAR 0 2
71739: PPUSH
71740: LD_VAR 0 3
71744: PUSH
71745: LD_INT 1
71747: ARRAY
71748: PUSH
71749: EMPTY
71750: LIST
71751: PPUSH
71752: CALL_OW 1
71756: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71757: LD_VAR 0 3
71761: PUSH
71762: LD_INT 1
71764: ARRAY
71765: PPUSH
71766: LD_INT 125
71768: PPUSH
71769: CALL_OW 109
// end else
71773: GO 71959
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71775: LD_EXP 104
71779: PUSH
71780: LD_VAR 0 2
71784: ARRAY
71785: PUSH
71786: LD_INT 1
71788: ARRAY
71789: PPUSH
71790: CALL_OW 310
71794: IFFALSE 71817
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71796: LD_EXP 104
71800: PUSH
71801: LD_VAR 0 2
71805: ARRAY
71806: PUSH
71807: LD_INT 1
71809: ARRAY
71810: PPUSH
71811: CALL_OW 122
71815: GO 71959
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71817: LD_EXP 104
71821: PUSH
71822: LD_VAR 0 2
71826: ARRAY
71827: PUSH
71828: LD_INT 1
71830: ARRAY
71831: PPUSH
71832: CALL_OW 314
71836: NOT
71837: PUSH
71838: LD_EXP 104
71842: PUSH
71843: LD_VAR 0 2
71847: ARRAY
71848: PUSH
71849: LD_INT 1
71851: ARRAY
71852: PPUSH
71853: LD_EXP 103
71857: PUSH
71858: LD_VAR 0 2
71862: ARRAY
71863: PUSH
71864: LD_INT 1
71866: ARRAY
71867: PUSH
71868: LD_INT 1
71870: ARRAY
71871: PPUSH
71872: LD_EXP 103
71876: PUSH
71877: LD_VAR 0 2
71881: ARRAY
71882: PUSH
71883: LD_INT 1
71885: ARRAY
71886: PUSH
71887: LD_INT 2
71889: ARRAY
71890: PPUSH
71891: CALL_OW 297
71895: PUSH
71896: LD_INT 6
71898: GREATER
71899: AND
71900: IFFALSE 71959
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71902: LD_EXP 104
71906: PUSH
71907: LD_VAR 0 2
71911: ARRAY
71912: PUSH
71913: LD_INT 1
71915: ARRAY
71916: PPUSH
71917: LD_EXP 103
71921: PUSH
71922: LD_VAR 0 2
71926: ARRAY
71927: PUSH
71928: LD_INT 1
71930: ARRAY
71931: PUSH
71932: LD_INT 1
71934: ARRAY
71935: PPUSH
71936: LD_EXP 103
71940: PUSH
71941: LD_VAR 0 2
71945: ARRAY
71946: PUSH
71947: LD_INT 1
71949: ARRAY
71950: PUSH
71951: LD_INT 2
71953: ARRAY
71954: PPUSH
71955: CALL_OW 111
// end ; end ; end ;
71959: GO 71372
71961: POP
71962: POP
// end ;
71963: LD_VAR 0 1
71967: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71968: LD_INT 0
71970: PPUSH
71971: PPUSH
71972: PPUSH
71973: PPUSH
71974: PPUSH
71975: PPUSH
71976: PPUSH
71977: PPUSH
71978: PPUSH
71979: PPUSH
71980: PPUSH
// if not mc_bases then
71981: LD_EXP 66
71985: NOT
71986: IFFALSE 71990
// exit ;
71988: GO 72930
// for i = 1 to mc_bases do
71990: LD_ADDR_VAR 0 2
71994: PUSH
71995: DOUBLE
71996: LD_INT 1
71998: DEC
71999: ST_TO_ADDR
72000: LD_EXP 66
72004: PUSH
72005: FOR_TO
72006: IFFALSE 72928
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72008: LD_EXP 66
72012: PUSH
72013: LD_VAR 0 2
72017: ARRAY
72018: NOT
72019: PUSH
72020: LD_EXP 89
72024: PUSH
72025: LD_VAR 0 2
72029: ARRAY
72030: OR
72031: IFFALSE 72035
// continue ;
72033: GO 72005
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72035: LD_ADDR_VAR 0 7
72039: PUSH
72040: LD_EXP 66
72044: PUSH
72045: LD_VAR 0 2
72049: ARRAY
72050: PUSH
72051: LD_INT 1
72053: ARRAY
72054: PPUSH
72055: CALL_OW 248
72059: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72060: LD_VAR 0 7
72064: PUSH
72065: LD_INT 3
72067: EQUAL
72068: PUSH
72069: LD_EXP 85
72073: PUSH
72074: LD_VAR 0 2
72078: ARRAY
72079: PUSH
72080: LD_EXP 88
72084: PUSH
72085: LD_VAR 0 2
72089: ARRAY
72090: UNION
72091: PPUSH
72092: LD_INT 33
72094: PUSH
72095: LD_INT 2
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PPUSH
72102: CALL_OW 72
72106: NOT
72107: OR
72108: IFFALSE 72112
// continue ;
72110: GO 72005
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72112: LD_ADDR_VAR 0 9
72116: PUSH
72117: LD_EXP 66
72121: PUSH
72122: LD_VAR 0 2
72126: ARRAY
72127: PPUSH
72128: LD_INT 30
72130: PUSH
72131: LD_INT 36
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PPUSH
72138: CALL_OW 72
72142: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72143: LD_ADDR_VAR 0 10
72147: PUSH
72148: LD_EXP 85
72152: PUSH
72153: LD_VAR 0 2
72157: ARRAY
72158: PPUSH
72159: LD_INT 34
72161: PUSH
72162: LD_INT 31
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PPUSH
72169: CALL_OW 72
72173: ST_TO_ADDR
// if not cts and not mcts then
72174: LD_VAR 0 9
72178: NOT
72179: PUSH
72180: LD_VAR 0 10
72184: NOT
72185: AND
72186: IFFALSE 72190
// continue ;
72188: GO 72005
// x := cts ;
72190: LD_ADDR_VAR 0 11
72194: PUSH
72195: LD_VAR 0 9
72199: ST_TO_ADDR
// if not x then
72200: LD_VAR 0 11
72204: NOT
72205: IFFALSE 72217
// x := mcts ;
72207: LD_ADDR_VAR 0 11
72211: PUSH
72212: LD_VAR 0 10
72216: ST_TO_ADDR
// if not x then
72217: LD_VAR 0 11
72221: NOT
72222: IFFALSE 72226
// continue ;
72224: GO 72005
// if mc_remote_driver [ i ] then
72226: LD_EXP 106
72230: PUSH
72231: LD_VAR 0 2
72235: ARRAY
72236: IFFALSE 72623
// for j in mc_remote_driver [ i ] do
72238: LD_ADDR_VAR 0 3
72242: PUSH
72243: LD_EXP 106
72247: PUSH
72248: LD_VAR 0 2
72252: ARRAY
72253: PUSH
72254: FOR_IN
72255: IFFALSE 72621
// begin if GetClass ( j ) <> 3 then
72257: LD_VAR 0 3
72261: PPUSH
72262: CALL_OW 257
72266: PUSH
72267: LD_INT 3
72269: NONEQUAL
72270: IFFALSE 72323
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
72272: LD_ADDR_EXP 106
72276: PUSH
72277: LD_EXP 106
72281: PPUSH
72282: LD_VAR 0 2
72286: PPUSH
72287: LD_EXP 106
72291: PUSH
72292: LD_VAR 0 2
72296: ARRAY
72297: PUSH
72298: LD_VAR 0 3
72302: DIFF
72303: PPUSH
72304: CALL_OW 1
72308: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72309: LD_VAR 0 3
72313: PPUSH
72314: LD_INT 0
72316: PPUSH
72317: CALL_OW 109
// continue ;
72321: GO 72254
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72323: LD_EXP 85
72327: PUSH
72328: LD_VAR 0 2
72332: ARRAY
72333: PPUSH
72334: LD_INT 34
72336: PUSH
72337: LD_INT 31
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 58
72346: PUSH
72347: EMPTY
72348: LIST
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PPUSH
72354: CALL_OW 72
72358: PUSH
72359: LD_VAR 0 3
72363: PPUSH
72364: CALL 47197 0 1
72368: NOT
72369: AND
72370: IFFALSE 72441
// begin if IsInUnit ( j ) then
72372: LD_VAR 0 3
72376: PPUSH
72377: CALL_OW 310
72381: IFFALSE 72392
// ComExitBuilding ( j ) ;
72383: LD_VAR 0 3
72387: PPUSH
72388: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72392: LD_VAR 0 3
72396: PPUSH
72397: LD_EXP 85
72401: PUSH
72402: LD_VAR 0 2
72406: ARRAY
72407: PPUSH
72408: LD_INT 34
72410: PUSH
72411: LD_INT 31
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 58
72420: PUSH
72421: EMPTY
72422: LIST
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PPUSH
72428: CALL_OW 72
72432: PUSH
72433: LD_INT 1
72435: ARRAY
72436: PPUSH
72437: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72441: LD_VAR 0 3
72445: PPUSH
72446: CALL_OW 310
72450: NOT
72451: PUSH
72452: LD_VAR 0 3
72456: PPUSH
72457: CALL_OW 310
72461: PPUSH
72462: CALL_OW 266
72466: PUSH
72467: LD_INT 36
72469: NONEQUAL
72470: PUSH
72471: LD_VAR 0 3
72475: PPUSH
72476: CALL 47197 0 1
72480: NOT
72481: AND
72482: OR
72483: IFFALSE 72619
// begin if IsInUnit ( j ) then
72485: LD_VAR 0 3
72489: PPUSH
72490: CALL_OW 310
72494: IFFALSE 72505
// ComExitBuilding ( j ) ;
72496: LD_VAR 0 3
72500: PPUSH
72501: CALL_OW 122
// ct := 0 ;
72505: LD_ADDR_VAR 0 8
72509: PUSH
72510: LD_INT 0
72512: ST_TO_ADDR
// for k in x do
72513: LD_ADDR_VAR 0 4
72517: PUSH
72518: LD_VAR 0 11
72522: PUSH
72523: FOR_IN
72524: IFFALSE 72597
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72526: LD_VAR 0 4
72530: PPUSH
72531: CALL_OW 264
72535: PUSH
72536: LD_INT 31
72538: EQUAL
72539: PUSH
72540: LD_VAR 0 4
72544: PPUSH
72545: CALL_OW 311
72549: NOT
72550: AND
72551: PUSH
72552: LD_VAR 0 4
72556: PPUSH
72557: CALL_OW 266
72561: PUSH
72562: LD_INT 36
72564: EQUAL
72565: PUSH
72566: LD_VAR 0 4
72570: PPUSH
72571: CALL_OW 313
72575: PUSH
72576: LD_INT 3
72578: LESS
72579: AND
72580: OR
72581: IFFALSE 72595
// begin ct := k ;
72583: LD_ADDR_VAR 0 8
72587: PUSH
72588: LD_VAR 0 4
72592: ST_TO_ADDR
// break ;
72593: GO 72597
// end ;
72595: GO 72523
72597: POP
72598: POP
// if ct then
72599: LD_VAR 0 8
72603: IFFALSE 72619
// ComEnterUnit ( j , ct ) ;
72605: LD_VAR 0 3
72609: PPUSH
72610: LD_VAR 0 8
72614: PPUSH
72615: CALL_OW 120
// end ; end ;
72619: GO 72254
72621: POP
72622: POP
// places := 0 ;
72623: LD_ADDR_VAR 0 5
72627: PUSH
72628: LD_INT 0
72630: ST_TO_ADDR
// for j = 1 to x do
72631: LD_ADDR_VAR 0 3
72635: PUSH
72636: DOUBLE
72637: LD_INT 1
72639: DEC
72640: ST_TO_ADDR
72641: LD_VAR 0 11
72645: PUSH
72646: FOR_TO
72647: IFFALSE 72723
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72649: LD_VAR 0 11
72653: PUSH
72654: LD_VAR 0 3
72658: ARRAY
72659: PPUSH
72660: CALL_OW 264
72664: PUSH
72665: LD_INT 31
72667: EQUAL
72668: IFFALSE 72686
// places := places + 1 else
72670: LD_ADDR_VAR 0 5
72674: PUSH
72675: LD_VAR 0 5
72679: PUSH
72680: LD_INT 1
72682: PLUS
72683: ST_TO_ADDR
72684: GO 72721
// if GetBType ( x [ j ] ) = b_control_tower then
72686: LD_VAR 0 11
72690: PUSH
72691: LD_VAR 0 3
72695: ARRAY
72696: PPUSH
72697: CALL_OW 266
72701: PUSH
72702: LD_INT 36
72704: EQUAL
72705: IFFALSE 72721
// places := places + 3 ;
72707: LD_ADDR_VAR 0 5
72711: PUSH
72712: LD_VAR 0 5
72716: PUSH
72717: LD_INT 3
72719: PLUS
72720: ST_TO_ADDR
72721: GO 72646
72723: POP
72724: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72725: LD_VAR 0 5
72729: PUSH
72730: LD_INT 0
72732: EQUAL
72733: PUSH
72734: LD_VAR 0 5
72738: PUSH
72739: LD_EXP 106
72743: PUSH
72744: LD_VAR 0 2
72748: ARRAY
72749: LESSEQUAL
72750: OR
72751: IFFALSE 72755
// continue ;
72753: GO 72005
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72755: LD_ADDR_VAR 0 6
72759: PUSH
72760: LD_EXP 66
72764: PUSH
72765: LD_VAR 0 2
72769: ARRAY
72770: PPUSH
72771: LD_INT 25
72773: PUSH
72774: LD_INT 3
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PPUSH
72781: CALL_OW 72
72785: PUSH
72786: LD_EXP 106
72790: PUSH
72791: LD_VAR 0 2
72795: ARRAY
72796: DIFF
72797: PPUSH
72798: LD_INT 3
72800: PPUSH
72801: CALL 48097 0 2
72805: ST_TO_ADDR
// for j in tmp do
72806: LD_ADDR_VAR 0 3
72810: PUSH
72811: LD_VAR 0 6
72815: PUSH
72816: FOR_IN
72817: IFFALSE 72852
// if GetTag ( j ) > 0 then
72819: LD_VAR 0 3
72823: PPUSH
72824: CALL_OW 110
72828: PUSH
72829: LD_INT 0
72831: GREATER
72832: IFFALSE 72850
// tmp := tmp diff j ;
72834: LD_ADDR_VAR 0 6
72838: PUSH
72839: LD_VAR 0 6
72843: PUSH
72844: LD_VAR 0 3
72848: DIFF
72849: ST_TO_ADDR
72850: GO 72816
72852: POP
72853: POP
// if not tmp then
72854: LD_VAR 0 6
72858: NOT
72859: IFFALSE 72863
// continue ;
72861: GO 72005
// if places then
72863: LD_VAR 0 5
72867: IFFALSE 72926
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72869: LD_ADDR_EXP 106
72873: PUSH
72874: LD_EXP 106
72878: PPUSH
72879: LD_VAR 0 2
72883: PPUSH
72884: LD_EXP 106
72888: PUSH
72889: LD_VAR 0 2
72893: ARRAY
72894: PUSH
72895: LD_VAR 0 6
72899: PUSH
72900: LD_INT 1
72902: ARRAY
72903: UNION
72904: PPUSH
72905: CALL_OW 1
72909: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72910: LD_VAR 0 6
72914: PUSH
72915: LD_INT 1
72917: ARRAY
72918: PPUSH
72919: LD_INT 126
72921: PPUSH
72922: CALL_OW 109
// end ; end ;
72926: GO 72005
72928: POP
72929: POP
// end ;
72930: LD_VAR 0 1
72934: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72935: LD_INT 0
72937: PPUSH
72938: PPUSH
72939: PPUSH
72940: PPUSH
72941: PPUSH
72942: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72943: LD_VAR 0 1
72947: NOT
72948: PUSH
72949: LD_VAR 0 2
72953: NOT
72954: OR
72955: PUSH
72956: LD_VAR 0 3
72960: NOT
72961: OR
72962: PUSH
72963: LD_VAR 0 4
72967: PUSH
72968: LD_INT 1
72970: PUSH
72971: LD_INT 2
72973: PUSH
72974: LD_INT 3
72976: PUSH
72977: LD_INT 4
72979: PUSH
72980: LD_INT 5
72982: PUSH
72983: LD_INT 8
72985: PUSH
72986: LD_INT 9
72988: PUSH
72989: LD_INT 15
72991: PUSH
72992: LD_INT 16
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: IN
73006: NOT
73007: OR
73008: IFFALSE 73012
// exit ;
73010: GO 73912
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73012: LD_ADDR_VAR 0 2
73016: PUSH
73017: LD_VAR 0 2
73021: PPUSH
73022: LD_INT 21
73024: PUSH
73025: LD_INT 3
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 24
73034: PUSH
73035: LD_INT 250
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PPUSH
73046: CALL_OW 72
73050: ST_TO_ADDR
// case class of 1 , 15 :
73051: LD_VAR 0 4
73055: PUSH
73056: LD_INT 1
73058: DOUBLE
73059: EQUAL
73060: IFTRUE 73070
73062: LD_INT 15
73064: DOUBLE
73065: EQUAL
73066: IFTRUE 73070
73068: GO 73155
73070: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73071: LD_ADDR_VAR 0 8
73075: PUSH
73076: LD_VAR 0 2
73080: PPUSH
73081: LD_INT 2
73083: PUSH
73084: LD_INT 30
73086: PUSH
73087: LD_INT 32
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 30
73096: PUSH
73097: LD_INT 31
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: LIST
73108: PPUSH
73109: CALL_OW 72
73113: PUSH
73114: LD_VAR 0 2
73118: PPUSH
73119: LD_INT 2
73121: PUSH
73122: LD_INT 30
73124: PUSH
73125: LD_INT 4
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: PUSH
73132: LD_INT 30
73134: PUSH
73135: LD_INT 5
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: LIST
73146: PPUSH
73147: CALL_OW 72
73151: ADD
73152: ST_TO_ADDR
73153: GO 73401
73155: LD_INT 2
73157: DOUBLE
73158: EQUAL
73159: IFTRUE 73169
73161: LD_INT 16
73163: DOUBLE
73164: EQUAL
73165: IFTRUE 73169
73167: GO 73215
73169: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73170: LD_ADDR_VAR 0 8
73174: PUSH
73175: LD_VAR 0 2
73179: PPUSH
73180: LD_INT 2
73182: PUSH
73183: LD_INT 30
73185: PUSH
73186: LD_INT 0
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 30
73195: PUSH
73196: LD_INT 1
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: LIST
73207: PPUSH
73208: CALL_OW 72
73212: ST_TO_ADDR
73213: GO 73401
73215: LD_INT 3
73217: DOUBLE
73218: EQUAL
73219: IFTRUE 73223
73221: GO 73269
73223: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73224: LD_ADDR_VAR 0 8
73228: PUSH
73229: LD_VAR 0 2
73233: PPUSH
73234: LD_INT 2
73236: PUSH
73237: LD_INT 30
73239: PUSH
73240: LD_INT 2
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 30
73249: PUSH
73250: LD_INT 3
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: LIST
73261: PPUSH
73262: CALL_OW 72
73266: ST_TO_ADDR
73267: GO 73401
73269: LD_INT 4
73271: DOUBLE
73272: EQUAL
73273: IFTRUE 73277
73275: GO 73334
73277: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
73278: LD_ADDR_VAR 0 8
73282: PUSH
73283: LD_VAR 0 2
73287: PPUSH
73288: LD_INT 2
73290: PUSH
73291: LD_INT 30
73293: PUSH
73294: LD_INT 6
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 30
73303: PUSH
73304: LD_INT 7
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 30
73313: PUSH
73314: LD_INT 8
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: LIST
73325: LIST
73326: PPUSH
73327: CALL_OW 72
73331: ST_TO_ADDR
73332: GO 73401
73334: LD_INT 5
73336: DOUBLE
73337: EQUAL
73338: IFTRUE 73354
73340: LD_INT 8
73342: DOUBLE
73343: EQUAL
73344: IFTRUE 73354
73346: LD_INT 9
73348: DOUBLE
73349: EQUAL
73350: IFTRUE 73354
73352: GO 73400
73354: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73355: LD_ADDR_VAR 0 8
73359: PUSH
73360: LD_VAR 0 2
73364: PPUSH
73365: LD_INT 2
73367: PUSH
73368: LD_INT 30
73370: PUSH
73371: LD_INT 4
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 30
73380: PUSH
73381: LD_INT 5
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: LIST
73392: PPUSH
73393: CALL_OW 72
73397: ST_TO_ADDR
73398: GO 73401
73400: POP
// if not tmp then
73401: LD_VAR 0 8
73405: NOT
73406: IFFALSE 73410
// exit ;
73408: GO 73912
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73410: LD_VAR 0 4
73414: PUSH
73415: LD_INT 1
73417: PUSH
73418: LD_INT 15
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: IN
73425: PUSH
73426: LD_EXP 75
73430: PUSH
73431: LD_VAR 0 1
73435: ARRAY
73436: AND
73437: IFFALSE 73593
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73439: LD_ADDR_VAR 0 9
73443: PUSH
73444: LD_EXP 75
73448: PUSH
73449: LD_VAR 0 1
73453: ARRAY
73454: PUSH
73455: LD_INT 1
73457: ARRAY
73458: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73459: LD_VAR 0 9
73463: PUSH
73464: LD_EXP 76
73468: PUSH
73469: LD_VAR 0 1
73473: ARRAY
73474: IN
73475: NOT
73476: IFFALSE 73591
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73478: LD_ADDR_EXP 76
73482: PUSH
73483: LD_EXP 76
73487: PPUSH
73488: LD_VAR 0 1
73492: PUSH
73493: LD_EXP 76
73497: PUSH
73498: LD_VAR 0 1
73502: ARRAY
73503: PUSH
73504: LD_INT 1
73506: PLUS
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PPUSH
73512: LD_VAR 0 9
73516: PPUSH
73517: CALL 18548 0 3
73521: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73522: LD_ADDR_EXP 75
73526: PUSH
73527: LD_EXP 75
73531: PPUSH
73532: LD_VAR 0 1
73536: PPUSH
73537: LD_EXP 75
73541: PUSH
73542: LD_VAR 0 1
73546: ARRAY
73547: PUSH
73548: LD_VAR 0 9
73552: DIFF
73553: PPUSH
73554: CALL_OW 1
73558: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73559: LD_VAR 0 3
73563: PPUSH
73564: LD_EXP 76
73568: PUSH
73569: LD_VAR 0 1
73573: ARRAY
73574: PUSH
73575: LD_EXP 76
73579: PUSH
73580: LD_VAR 0 1
73584: ARRAY
73585: ARRAY
73586: PPUSH
73587: CALL_OW 120
// end ; exit ;
73591: GO 73912
// end ; if tmp > 1 then
73593: LD_VAR 0 8
73597: PUSH
73598: LD_INT 1
73600: GREATER
73601: IFFALSE 73705
// for i = 2 to tmp do
73603: LD_ADDR_VAR 0 6
73607: PUSH
73608: DOUBLE
73609: LD_INT 2
73611: DEC
73612: ST_TO_ADDR
73613: LD_VAR 0 8
73617: PUSH
73618: FOR_TO
73619: IFFALSE 73703
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73621: LD_VAR 0 8
73625: PUSH
73626: LD_VAR 0 6
73630: ARRAY
73631: PPUSH
73632: CALL_OW 461
73636: PUSH
73637: LD_INT 6
73639: EQUAL
73640: IFFALSE 73701
// begin x := tmp [ i ] ;
73642: LD_ADDR_VAR 0 9
73646: PUSH
73647: LD_VAR 0 8
73651: PUSH
73652: LD_VAR 0 6
73656: ARRAY
73657: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73658: LD_ADDR_VAR 0 8
73662: PUSH
73663: LD_VAR 0 8
73667: PPUSH
73668: LD_VAR 0 6
73672: PPUSH
73673: CALL_OW 3
73677: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73678: LD_ADDR_VAR 0 8
73682: PUSH
73683: LD_VAR 0 8
73687: PPUSH
73688: LD_INT 1
73690: PPUSH
73691: LD_VAR 0 9
73695: PPUSH
73696: CALL_OW 2
73700: ST_TO_ADDR
// end ;
73701: GO 73618
73703: POP
73704: POP
// for i in tmp do
73705: LD_ADDR_VAR 0 6
73709: PUSH
73710: LD_VAR 0 8
73714: PUSH
73715: FOR_IN
73716: IFFALSE 73785
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73718: LD_VAR 0 6
73722: PPUSH
73723: CALL_OW 313
73727: PUSH
73728: LD_INT 6
73730: LESS
73731: PUSH
73732: LD_VAR 0 6
73736: PPUSH
73737: CALL_OW 266
73741: PUSH
73742: LD_INT 31
73744: PUSH
73745: LD_INT 32
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: IN
73752: NOT
73753: AND
73754: PUSH
73755: LD_VAR 0 6
73759: PPUSH
73760: CALL_OW 313
73764: PUSH
73765: LD_INT 0
73767: EQUAL
73768: OR
73769: IFFALSE 73783
// begin j := i ;
73771: LD_ADDR_VAR 0 7
73775: PUSH
73776: LD_VAR 0 6
73780: ST_TO_ADDR
// break ;
73781: GO 73785
// end ; end ;
73783: GO 73715
73785: POP
73786: POP
// if j then
73787: LD_VAR 0 7
73791: IFFALSE 73809
// ComEnterUnit ( unit , j ) else
73793: LD_VAR 0 3
73797: PPUSH
73798: LD_VAR 0 7
73802: PPUSH
73803: CALL_OW 120
73807: GO 73912
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73809: LD_ADDR_VAR 0 10
73813: PUSH
73814: LD_VAR 0 2
73818: PPUSH
73819: LD_INT 2
73821: PUSH
73822: LD_INT 30
73824: PUSH
73825: LD_INT 0
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: LD_INT 30
73834: PUSH
73835: LD_INT 1
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: LIST
73846: PPUSH
73847: CALL_OW 72
73851: ST_TO_ADDR
// if depot then
73852: LD_VAR 0 10
73856: IFFALSE 73912
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73858: LD_ADDR_VAR 0 10
73862: PUSH
73863: LD_VAR 0 10
73867: PPUSH
73868: LD_VAR 0 3
73872: PPUSH
73873: CALL_OW 74
73877: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73878: LD_VAR 0 3
73882: PPUSH
73883: LD_VAR 0 10
73887: PPUSH
73888: CALL_OW 296
73892: PUSH
73893: LD_INT 10
73895: GREATER
73896: IFFALSE 73912
// ComStandNearbyBuilding ( unit , depot ) ;
73898: LD_VAR 0 3
73902: PPUSH
73903: LD_VAR 0 10
73907: PPUSH
73908: CALL 15162 0 2
// end ; end ; end ;
73912: LD_VAR 0 5
73916: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73917: LD_INT 0
73919: PPUSH
73920: PPUSH
73921: PPUSH
73922: PPUSH
// if not mc_bases then
73923: LD_EXP 66
73927: NOT
73928: IFFALSE 73932
// exit ;
73930: GO 74171
// for i = 1 to mc_bases do
73932: LD_ADDR_VAR 0 2
73936: PUSH
73937: DOUBLE
73938: LD_INT 1
73940: DEC
73941: ST_TO_ADDR
73942: LD_EXP 66
73946: PUSH
73947: FOR_TO
73948: IFFALSE 74169
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73950: LD_ADDR_VAR 0 4
73954: PUSH
73955: LD_EXP 66
73959: PUSH
73960: LD_VAR 0 2
73964: ARRAY
73965: PPUSH
73966: LD_INT 21
73968: PUSH
73969: LD_INT 1
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PPUSH
73976: CALL_OW 72
73980: PUSH
73981: LD_EXP 95
73985: PUSH
73986: LD_VAR 0 2
73990: ARRAY
73991: UNION
73992: ST_TO_ADDR
// if not tmp then
73993: LD_VAR 0 4
73997: NOT
73998: IFFALSE 74002
// continue ;
74000: GO 73947
// for j in tmp do
74002: LD_ADDR_VAR 0 3
74006: PUSH
74007: LD_VAR 0 4
74011: PUSH
74012: FOR_IN
74013: IFFALSE 74165
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74015: LD_VAR 0 3
74019: PPUSH
74020: CALL_OW 110
74024: NOT
74025: PUSH
74026: LD_VAR 0 3
74030: PPUSH
74031: CALL_OW 314
74035: NOT
74036: AND
74037: PUSH
74038: LD_VAR 0 3
74042: PPUSH
74043: CALL_OW 311
74047: NOT
74048: AND
74049: PUSH
74050: LD_VAR 0 3
74054: PPUSH
74055: CALL_OW 310
74059: NOT
74060: AND
74061: PUSH
74062: LD_VAR 0 3
74066: PUSH
74067: LD_EXP 69
74071: PUSH
74072: LD_VAR 0 2
74076: ARRAY
74077: PUSH
74078: LD_INT 1
74080: ARRAY
74081: IN
74082: NOT
74083: AND
74084: PUSH
74085: LD_VAR 0 3
74089: PUSH
74090: LD_EXP 69
74094: PUSH
74095: LD_VAR 0 2
74099: ARRAY
74100: PUSH
74101: LD_INT 2
74103: ARRAY
74104: IN
74105: NOT
74106: AND
74107: PUSH
74108: LD_VAR 0 3
74112: PUSH
74113: LD_EXP 78
74117: PUSH
74118: LD_VAR 0 2
74122: ARRAY
74123: IN
74124: NOT
74125: AND
74126: IFFALSE 74163
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74128: LD_VAR 0 2
74132: PPUSH
74133: LD_EXP 66
74137: PUSH
74138: LD_VAR 0 2
74142: ARRAY
74143: PPUSH
74144: LD_VAR 0 3
74148: PPUSH
74149: LD_VAR 0 3
74153: PPUSH
74154: CALL_OW 257
74158: PPUSH
74159: CALL 72935 0 4
// end ;
74163: GO 74012
74165: POP
74166: POP
// end ;
74167: GO 73947
74169: POP
74170: POP
// end ;
74171: LD_VAR 0 1
74175: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74176: LD_INT 0
74178: PPUSH
74179: PPUSH
74180: PPUSH
74181: PPUSH
74182: PPUSH
74183: PPUSH
// if not mc_bases [ base ] then
74184: LD_EXP 66
74188: PUSH
74189: LD_VAR 0 1
74193: ARRAY
74194: NOT
74195: IFFALSE 74199
// exit ;
74197: GO 74381
// tmp := [ ] ;
74199: LD_ADDR_VAR 0 6
74203: PUSH
74204: EMPTY
74205: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74206: LD_ADDR_VAR 0 7
74210: PUSH
74211: LD_VAR 0 3
74215: PPUSH
74216: LD_INT 0
74218: PPUSH
74219: CALL_OW 517
74223: ST_TO_ADDR
// if not list then
74224: LD_VAR 0 7
74228: NOT
74229: IFFALSE 74233
// exit ;
74231: GO 74381
// for i = 1 to amount do
74233: LD_ADDR_VAR 0 5
74237: PUSH
74238: DOUBLE
74239: LD_INT 1
74241: DEC
74242: ST_TO_ADDR
74243: LD_VAR 0 2
74247: PUSH
74248: FOR_TO
74249: IFFALSE 74329
// begin x := rand ( 1 , list [ 1 ] ) ;
74251: LD_ADDR_VAR 0 8
74255: PUSH
74256: LD_INT 1
74258: PPUSH
74259: LD_VAR 0 7
74263: PUSH
74264: LD_INT 1
74266: ARRAY
74267: PPUSH
74268: CALL_OW 12
74272: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
74273: LD_ADDR_VAR 0 6
74277: PUSH
74278: LD_VAR 0 6
74282: PPUSH
74283: LD_VAR 0 5
74287: PPUSH
74288: LD_VAR 0 7
74292: PUSH
74293: LD_INT 1
74295: ARRAY
74296: PUSH
74297: LD_VAR 0 8
74301: ARRAY
74302: PUSH
74303: LD_VAR 0 7
74307: PUSH
74308: LD_INT 2
74310: ARRAY
74311: PUSH
74312: LD_VAR 0 8
74316: ARRAY
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: PPUSH
74322: CALL_OW 1
74326: ST_TO_ADDR
// end ;
74327: GO 74248
74329: POP
74330: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74331: LD_ADDR_EXP 79
74335: PUSH
74336: LD_EXP 79
74340: PPUSH
74341: LD_VAR 0 1
74345: PPUSH
74346: LD_VAR 0 6
74350: PPUSH
74351: CALL_OW 1
74355: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74356: LD_ADDR_EXP 81
74360: PUSH
74361: LD_EXP 81
74365: PPUSH
74366: LD_VAR 0 1
74370: PPUSH
74371: LD_VAR 0 3
74375: PPUSH
74376: CALL_OW 1
74380: ST_TO_ADDR
// end ;
74381: LD_VAR 0 4
74385: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74386: LD_INT 0
74388: PPUSH
// if not mc_bases [ base ] then
74389: LD_EXP 66
74393: PUSH
74394: LD_VAR 0 1
74398: ARRAY
74399: NOT
74400: IFFALSE 74404
// exit ;
74402: GO 74429
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74404: LD_ADDR_EXP 71
74408: PUSH
74409: LD_EXP 71
74413: PPUSH
74414: LD_VAR 0 1
74418: PPUSH
74419: LD_VAR 0 2
74423: PPUSH
74424: CALL_OW 1
74428: ST_TO_ADDR
// end ;
74429: LD_VAR 0 3
74433: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74434: LD_INT 0
74436: PPUSH
// if not mc_bases [ base ] then
74437: LD_EXP 66
74441: PUSH
74442: LD_VAR 0 1
74446: ARRAY
74447: NOT
74448: IFFALSE 74452
// exit ;
74450: GO 74489
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74452: LD_ADDR_EXP 71
74456: PUSH
74457: LD_EXP 71
74461: PPUSH
74462: LD_VAR 0 1
74466: PPUSH
74467: LD_EXP 71
74471: PUSH
74472: LD_VAR 0 1
74476: ARRAY
74477: PUSH
74478: LD_VAR 0 2
74482: UNION
74483: PPUSH
74484: CALL_OW 1
74488: ST_TO_ADDR
// end ;
74489: LD_VAR 0 3
74493: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74494: LD_INT 0
74496: PPUSH
// if not mc_bases [ base ] then
74497: LD_EXP 66
74501: PUSH
74502: LD_VAR 0 1
74506: ARRAY
74507: NOT
74508: IFFALSE 74512
// exit ;
74510: GO 74537
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74512: LD_ADDR_EXP 87
74516: PUSH
74517: LD_EXP 87
74521: PPUSH
74522: LD_VAR 0 1
74526: PPUSH
74527: LD_VAR 0 2
74531: PPUSH
74532: CALL_OW 1
74536: ST_TO_ADDR
// end ;
74537: LD_VAR 0 3
74541: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74542: LD_INT 0
74544: PPUSH
// if not mc_bases [ base ] then
74545: LD_EXP 66
74549: PUSH
74550: LD_VAR 0 1
74554: ARRAY
74555: NOT
74556: IFFALSE 74560
// exit ;
74558: GO 74597
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74560: LD_ADDR_EXP 87
74564: PUSH
74565: LD_EXP 87
74569: PPUSH
74570: LD_VAR 0 1
74574: PPUSH
74575: LD_EXP 87
74579: PUSH
74580: LD_VAR 0 1
74584: ARRAY
74585: PUSH
74586: LD_VAR 0 2
74590: ADD
74591: PPUSH
74592: CALL_OW 1
74596: ST_TO_ADDR
// end ;
74597: LD_VAR 0 3
74601: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74602: LD_INT 0
74604: PPUSH
// if not mc_bases [ base ] then
74605: LD_EXP 66
74609: PUSH
74610: LD_VAR 0 1
74614: ARRAY
74615: NOT
74616: IFFALSE 74620
// exit ;
74618: GO 74674
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74620: LD_ADDR_EXP 88
74624: PUSH
74625: LD_EXP 88
74629: PPUSH
74630: LD_VAR 0 1
74634: PPUSH
74635: LD_VAR 0 2
74639: PPUSH
74640: CALL_OW 1
74644: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74645: LD_ADDR_EXP 77
74649: PUSH
74650: LD_EXP 77
74654: PPUSH
74655: LD_VAR 0 1
74659: PPUSH
74660: LD_VAR 0 2
74664: PUSH
74665: LD_INT 0
74667: PLUS
74668: PPUSH
74669: CALL_OW 1
74673: ST_TO_ADDR
// end ;
74674: LD_VAR 0 3
74678: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74679: LD_INT 0
74681: PPUSH
// if not mc_bases [ base ] then
74682: LD_EXP 66
74686: PUSH
74687: LD_VAR 0 1
74691: ARRAY
74692: NOT
74693: IFFALSE 74697
// exit ;
74695: GO 74722
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74697: LD_ADDR_EXP 77
74701: PUSH
74702: LD_EXP 77
74706: PPUSH
74707: LD_VAR 0 1
74711: PPUSH
74712: LD_VAR 0 2
74716: PPUSH
74717: CALL_OW 1
74721: ST_TO_ADDR
// end ;
74722: LD_VAR 0 3
74726: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74727: LD_INT 0
74729: PPUSH
74730: PPUSH
74731: PPUSH
74732: PPUSH
// if not mc_bases [ base ] then
74733: LD_EXP 66
74737: PUSH
74738: LD_VAR 0 1
74742: ARRAY
74743: NOT
74744: IFFALSE 74748
// exit ;
74746: GO 74813
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74748: LD_ADDR_EXP 86
74752: PUSH
74753: LD_EXP 86
74757: PPUSH
74758: LD_VAR 0 1
74762: PUSH
74763: LD_EXP 86
74767: PUSH
74768: LD_VAR 0 1
74772: ARRAY
74773: PUSH
74774: LD_INT 1
74776: PLUS
74777: PUSH
74778: EMPTY
74779: LIST
74780: LIST
74781: PPUSH
74782: LD_VAR 0 1
74786: PUSH
74787: LD_VAR 0 2
74791: PUSH
74792: LD_VAR 0 3
74796: PUSH
74797: LD_VAR 0 4
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: LIST
74806: LIST
74807: PPUSH
74808: CALL 18548 0 3
74812: ST_TO_ADDR
// end ;
74813: LD_VAR 0 5
74817: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74818: LD_INT 0
74820: PPUSH
// if not mc_bases [ base ] then
74821: LD_EXP 66
74825: PUSH
74826: LD_VAR 0 1
74830: ARRAY
74831: NOT
74832: IFFALSE 74836
// exit ;
74834: GO 74861
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74836: LD_ADDR_EXP 103
74840: PUSH
74841: LD_EXP 103
74845: PPUSH
74846: LD_VAR 0 1
74850: PPUSH
74851: LD_VAR 0 2
74855: PPUSH
74856: CALL_OW 1
74860: ST_TO_ADDR
// end ;
74861: LD_VAR 0 3
74865: RET
// export function MC_GetMinesField ( base ) ; begin
74866: LD_INT 0
74868: PPUSH
// result := mc_mines [ base ] ;
74869: LD_ADDR_VAR 0 2
74873: PUSH
74874: LD_EXP 79
74878: PUSH
74879: LD_VAR 0 1
74883: ARRAY
74884: ST_TO_ADDR
// end ;
74885: LD_VAR 0 2
74889: RET
// export function MC_GetProduceList ( base ) ; begin
74890: LD_INT 0
74892: PPUSH
// result := mc_produce [ base ] ;
74893: LD_ADDR_VAR 0 2
74897: PUSH
74898: LD_EXP 87
74902: PUSH
74903: LD_VAR 0 1
74907: ARRAY
74908: ST_TO_ADDR
// end ;
74909: LD_VAR 0 2
74913: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74914: LD_INT 0
74916: PPUSH
74917: PPUSH
// if not mc_bases then
74918: LD_EXP 66
74922: NOT
74923: IFFALSE 74927
// exit ;
74925: GO 74992
// if mc_bases [ base ] then
74927: LD_EXP 66
74931: PUSH
74932: LD_VAR 0 1
74936: ARRAY
74937: IFFALSE 74992
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74939: LD_ADDR_VAR 0 3
74943: PUSH
74944: LD_EXP 66
74948: PUSH
74949: LD_VAR 0 1
74953: ARRAY
74954: PPUSH
74955: LD_INT 30
74957: PUSH
74958: LD_VAR 0 2
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PPUSH
74967: CALL_OW 72
74971: ST_TO_ADDR
// if result then
74972: LD_VAR 0 3
74976: IFFALSE 74992
// result := result [ 1 ] ;
74978: LD_ADDR_VAR 0 3
74982: PUSH
74983: LD_VAR 0 3
74987: PUSH
74988: LD_INT 1
74990: ARRAY
74991: ST_TO_ADDR
// end ; end ;
74992: LD_VAR 0 3
74996: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74997: LD_INT 0
74999: PPUSH
75000: PPUSH
// if not mc_bases then
75001: LD_EXP 66
75005: NOT
75006: IFFALSE 75010
// exit ;
75008: GO 75055
// if mc_bases [ base ] then
75010: LD_EXP 66
75014: PUSH
75015: LD_VAR 0 1
75019: ARRAY
75020: IFFALSE 75055
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75022: LD_ADDR_VAR 0 3
75026: PUSH
75027: LD_EXP 66
75031: PUSH
75032: LD_VAR 0 1
75036: ARRAY
75037: PPUSH
75038: LD_INT 30
75040: PUSH
75041: LD_VAR 0 2
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PPUSH
75050: CALL_OW 72
75054: ST_TO_ADDR
// end ;
75055: LD_VAR 0 3
75059: RET
// export function MC_SetTame ( base , area ) ; begin
75060: LD_INT 0
75062: PPUSH
// if not mc_bases or not base then
75063: LD_EXP 66
75067: NOT
75068: PUSH
75069: LD_VAR 0 1
75073: NOT
75074: OR
75075: IFFALSE 75079
// exit ;
75077: GO 75104
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75079: LD_ADDR_EXP 94
75083: PUSH
75084: LD_EXP 94
75088: PPUSH
75089: LD_VAR 0 1
75093: PPUSH
75094: LD_VAR 0 2
75098: PPUSH
75099: CALL_OW 1
75103: ST_TO_ADDR
// end ;
75104: LD_VAR 0 3
75108: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75109: LD_INT 0
75111: PPUSH
75112: PPUSH
// if not mc_bases or not base then
75113: LD_EXP 66
75117: NOT
75118: PUSH
75119: LD_VAR 0 1
75123: NOT
75124: OR
75125: IFFALSE 75129
// exit ;
75127: GO 75231
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75129: LD_ADDR_VAR 0 4
75133: PUSH
75134: LD_EXP 66
75138: PUSH
75139: LD_VAR 0 1
75143: ARRAY
75144: PPUSH
75145: LD_INT 30
75147: PUSH
75148: LD_VAR 0 2
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: PPUSH
75157: CALL_OW 72
75161: ST_TO_ADDR
// if not tmp then
75162: LD_VAR 0 4
75166: NOT
75167: IFFALSE 75171
// exit ;
75169: GO 75231
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75171: LD_ADDR_EXP 98
75175: PUSH
75176: LD_EXP 98
75180: PPUSH
75181: LD_VAR 0 1
75185: PPUSH
75186: LD_EXP 98
75190: PUSH
75191: LD_VAR 0 1
75195: ARRAY
75196: PPUSH
75197: LD_EXP 98
75201: PUSH
75202: LD_VAR 0 1
75206: ARRAY
75207: PUSH
75208: LD_INT 1
75210: PLUS
75211: PPUSH
75212: LD_VAR 0 4
75216: PUSH
75217: LD_INT 1
75219: ARRAY
75220: PPUSH
75221: CALL_OW 2
75225: PPUSH
75226: CALL_OW 1
75230: ST_TO_ADDR
// end ;
75231: LD_VAR 0 3
75235: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75236: LD_INT 0
75238: PPUSH
75239: PPUSH
// if not mc_bases or not base or not kinds then
75240: LD_EXP 66
75244: NOT
75245: PUSH
75246: LD_VAR 0 1
75250: NOT
75251: OR
75252: PUSH
75253: LD_VAR 0 2
75257: NOT
75258: OR
75259: IFFALSE 75263
// exit ;
75261: GO 75324
// for i in kinds do
75263: LD_ADDR_VAR 0 4
75267: PUSH
75268: LD_VAR 0 2
75272: PUSH
75273: FOR_IN
75274: IFFALSE 75322
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
75276: LD_ADDR_EXP 100
75280: PUSH
75281: LD_EXP 100
75285: PPUSH
75286: LD_VAR 0 1
75290: PUSH
75291: LD_EXP 100
75295: PUSH
75296: LD_VAR 0 1
75300: ARRAY
75301: PUSH
75302: LD_INT 1
75304: PLUS
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PPUSH
75310: LD_VAR 0 4
75314: PPUSH
75315: CALL 18548 0 3
75319: ST_TO_ADDR
75320: GO 75273
75322: POP
75323: POP
// end ;
75324: LD_VAR 0 3
75328: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75329: LD_INT 0
75331: PPUSH
// if not mc_bases or not base or not areas then
75332: LD_EXP 66
75336: NOT
75337: PUSH
75338: LD_VAR 0 1
75342: NOT
75343: OR
75344: PUSH
75345: LD_VAR 0 2
75349: NOT
75350: OR
75351: IFFALSE 75355
// exit ;
75353: GO 75380
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75355: LD_ADDR_EXP 84
75359: PUSH
75360: LD_EXP 84
75364: PPUSH
75365: LD_VAR 0 1
75369: PPUSH
75370: LD_VAR 0 2
75374: PPUSH
75375: CALL_OW 1
75379: ST_TO_ADDR
// end ;
75380: LD_VAR 0 3
75384: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75385: LD_INT 0
75387: PPUSH
// if not mc_bases or not base or not teleports_exit then
75388: LD_EXP 66
75392: NOT
75393: PUSH
75394: LD_VAR 0 1
75398: NOT
75399: OR
75400: PUSH
75401: LD_VAR 0 2
75405: NOT
75406: OR
75407: IFFALSE 75411
// exit ;
75409: GO 75436
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75411: LD_ADDR_EXP 101
75415: PUSH
75416: LD_EXP 101
75420: PPUSH
75421: LD_VAR 0 1
75425: PPUSH
75426: LD_VAR 0 2
75430: PPUSH
75431: CALL_OW 1
75435: ST_TO_ADDR
// end ;
75436: LD_VAR 0 3
75440: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75441: LD_INT 0
75443: PPUSH
75444: PPUSH
75445: PPUSH
// if not mc_bases or not base or not ext_list then
75446: LD_EXP 66
75450: NOT
75451: PUSH
75452: LD_VAR 0 1
75456: NOT
75457: OR
75458: PUSH
75459: LD_VAR 0 5
75463: NOT
75464: OR
75465: IFFALSE 75469
// exit ;
75467: GO 75642
// tmp := GetFacExtXYD ( x , y , d ) ;
75469: LD_ADDR_VAR 0 8
75473: PUSH
75474: LD_VAR 0 2
75478: PPUSH
75479: LD_VAR 0 3
75483: PPUSH
75484: LD_VAR 0 4
75488: PPUSH
75489: CALL 47227 0 3
75493: ST_TO_ADDR
// if not tmp then
75494: LD_VAR 0 8
75498: NOT
75499: IFFALSE 75503
// exit ;
75501: GO 75642
// for i in tmp do
75503: LD_ADDR_VAR 0 7
75507: PUSH
75508: LD_VAR 0 8
75512: PUSH
75513: FOR_IN
75514: IFFALSE 75640
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75516: LD_ADDR_EXP 71
75520: PUSH
75521: LD_EXP 71
75525: PPUSH
75526: LD_VAR 0 1
75530: PPUSH
75531: LD_EXP 71
75535: PUSH
75536: LD_VAR 0 1
75540: ARRAY
75541: PPUSH
75542: LD_EXP 71
75546: PUSH
75547: LD_VAR 0 1
75551: ARRAY
75552: PUSH
75553: LD_INT 1
75555: PLUS
75556: PPUSH
75557: LD_VAR 0 5
75561: PUSH
75562: LD_INT 1
75564: ARRAY
75565: PUSH
75566: LD_VAR 0 7
75570: PUSH
75571: LD_INT 1
75573: ARRAY
75574: PUSH
75575: LD_VAR 0 7
75579: PUSH
75580: LD_INT 2
75582: ARRAY
75583: PUSH
75584: LD_VAR 0 7
75588: PUSH
75589: LD_INT 3
75591: ARRAY
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: PPUSH
75599: CALL_OW 2
75603: PPUSH
75604: CALL_OW 1
75608: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75609: LD_ADDR_VAR 0 5
75613: PUSH
75614: LD_VAR 0 5
75618: PPUSH
75619: LD_INT 1
75621: PPUSH
75622: CALL_OW 3
75626: ST_TO_ADDR
// if not ext_list then
75627: LD_VAR 0 5
75631: NOT
75632: IFFALSE 75638
// exit ;
75634: POP
75635: POP
75636: GO 75642
// end ;
75638: GO 75513
75640: POP
75641: POP
// end ;
75642: LD_VAR 0 6
75646: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75647: LD_INT 0
75649: PPUSH
// if not mc_bases or not base or not weapon_list then
75650: LD_EXP 66
75654: NOT
75655: PUSH
75656: LD_VAR 0 1
75660: NOT
75661: OR
75662: PUSH
75663: LD_VAR 0 2
75667: NOT
75668: OR
75669: IFFALSE 75673
// exit ;
75671: GO 75698
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75673: LD_ADDR_EXP 105
75677: PUSH
75678: LD_EXP 105
75682: PPUSH
75683: LD_VAR 0 1
75687: PPUSH
75688: LD_VAR 0 2
75692: PPUSH
75693: CALL_OW 1
75697: ST_TO_ADDR
// end ;
75698: LD_VAR 0 3
75702: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75703: LD_INT 0
75705: PPUSH
// if not mc_bases or not base or not tech_list then
75706: LD_EXP 66
75710: NOT
75711: PUSH
75712: LD_VAR 0 1
75716: NOT
75717: OR
75718: PUSH
75719: LD_VAR 0 2
75723: NOT
75724: OR
75725: IFFALSE 75729
// exit ;
75727: GO 75754
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75729: LD_ADDR_EXP 93
75733: PUSH
75734: LD_EXP 93
75738: PPUSH
75739: LD_VAR 0 1
75743: PPUSH
75744: LD_VAR 0 2
75748: PPUSH
75749: CALL_OW 1
75753: ST_TO_ADDR
// end ;
75754: LD_VAR 0 3
75758: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75759: LD_INT 0
75761: PPUSH
// if not mc_bases or not parking_area or not base then
75762: LD_EXP 66
75766: NOT
75767: PUSH
75768: LD_VAR 0 2
75772: NOT
75773: OR
75774: PUSH
75775: LD_VAR 0 1
75779: NOT
75780: OR
75781: IFFALSE 75785
// exit ;
75783: GO 75810
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75785: LD_ADDR_EXP 90
75789: PUSH
75790: LD_EXP 90
75794: PPUSH
75795: LD_VAR 0 1
75799: PPUSH
75800: LD_VAR 0 2
75804: PPUSH
75805: CALL_OW 1
75809: ST_TO_ADDR
// end ;
75810: LD_VAR 0 3
75814: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75815: LD_INT 0
75817: PPUSH
// if not mc_bases or not base or not scan_area then
75818: LD_EXP 66
75822: NOT
75823: PUSH
75824: LD_VAR 0 1
75828: NOT
75829: OR
75830: PUSH
75831: LD_VAR 0 2
75835: NOT
75836: OR
75837: IFFALSE 75841
// exit ;
75839: GO 75866
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75841: LD_ADDR_EXP 91
75845: PUSH
75846: LD_EXP 91
75850: PPUSH
75851: LD_VAR 0 1
75855: PPUSH
75856: LD_VAR 0 2
75860: PPUSH
75861: CALL_OW 1
75865: ST_TO_ADDR
// end ;
75866: LD_VAR 0 3
75870: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75871: LD_INT 0
75873: PPUSH
75874: PPUSH
// if not mc_bases or not base then
75875: LD_EXP 66
75879: NOT
75880: PUSH
75881: LD_VAR 0 1
75885: NOT
75886: OR
75887: IFFALSE 75891
// exit ;
75889: GO 75955
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75891: LD_ADDR_VAR 0 3
75895: PUSH
75896: LD_INT 1
75898: PUSH
75899: LD_INT 2
75901: PUSH
75902: LD_INT 3
75904: PUSH
75905: LD_INT 4
75907: PUSH
75908: LD_INT 11
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: LIST
75915: LIST
75916: LIST
75917: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75918: LD_ADDR_EXP 93
75922: PUSH
75923: LD_EXP 93
75927: PPUSH
75928: LD_VAR 0 1
75932: PPUSH
75933: LD_EXP 93
75937: PUSH
75938: LD_VAR 0 1
75942: ARRAY
75943: PUSH
75944: LD_VAR 0 3
75948: DIFF
75949: PPUSH
75950: CALL_OW 1
75954: ST_TO_ADDR
// end ;
75955: LD_VAR 0 2
75959: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75960: LD_INT 0
75962: PPUSH
// result := mc_vehicles [ base ] ;
75963: LD_ADDR_VAR 0 3
75967: PUSH
75968: LD_EXP 85
75972: PUSH
75973: LD_VAR 0 1
75977: ARRAY
75978: ST_TO_ADDR
// if onlyCombat then
75979: LD_VAR 0 2
75983: IFFALSE 76161
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75985: LD_ADDR_VAR 0 3
75989: PUSH
75990: LD_VAR 0 3
75994: PUSH
75995: LD_VAR 0 3
75999: PPUSH
76000: LD_INT 2
76002: PUSH
76003: LD_INT 34
76005: PUSH
76006: LD_INT 12
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 34
76015: PUSH
76016: LD_INT 51
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 34
76025: PUSH
76026: LD_EXP 49
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 34
76037: PUSH
76038: LD_INT 32
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 34
76047: PUSH
76048: LD_INT 13
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 34
76057: PUSH
76058: LD_INT 52
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 34
76067: PUSH
76068: LD_EXP 54
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: LD_INT 34
76079: PUSH
76080: LD_INT 14
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 34
76089: PUSH
76090: LD_INT 53
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 34
76099: PUSH
76100: LD_EXP 48
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: PUSH
76109: LD_INT 34
76111: PUSH
76112: LD_INT 31
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: PUSH
76119: LD_INT 34
76121: PUSH
76122: LD_INT 48
76124: PUSH
76125: EMPTY
76126: LIST
76127: LIST
76128: PUSH
76129: LD_INT 34
76131: PUSH
76132: LD_INT 8
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: LIST
76147: LIST
76148: LIST
76149: LIST
76150: LIST
76151: LIST
76152: LIST
76153: LIST
76154: PPUSH
76155: CALL_OW 72
76159: DIFF
76160: ST_TO_ADDR
// end ; end_of_file
76161: LD_VAR 0 3
76165: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76166: LD_INT 0
76168: PPUSH
76169: PPUSH
76170: PPUSH
// if not mc_bases or not skirmish then
76171: LD_EXP 66
76175: NOT
76176: PUSH
76177: LD_EXP 64
76181: NOT
76182: OR
76183: IFFALSE 76187
// exit ;
76185: GO 76352
// for i = 1 to mc_bases do
76187: LD_ADDR_VAR 0 4
76191: PUSH
76192: DOUBLE
76193: LD_INT 1
76195: DEC
76196: ST_TO_ADDR
76197: LD_EXP 66
76201: PUSH
76202: FOR_TO
76203: IFFALSE 76350
// begin if sci in mc_bases [ i ] then
76205: LD_VAR 0 2
76209: PUSH
76210: LD_EXP 66
76214: PUSH
76215: LD_VAR 0 4
76219: ARRAY
76220: IN
76221: IFFALSE 76348
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76223: LD_ADDR_EXP 95
76227: PUSH
76228: LD_EXP 95
76232: PPUSH
76233: LD_VAR 0 4
76237: PUSH
76238: LD_EXP 95
76242: PUSH
76243: LD_VAR 0 4
76247: ARRAY
76248: PUSH
76249: LD_INT 1
76251: PLUS
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PPUSH
76257: LD_VAR 0 1
76261: PPUSH
76262: CALL 18548 0 3
76266: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76267: LD_ADDR_VAR 0 5
76271: PUSH
76272: LD_EXP 66
76276: PUSH
76277: LD_VAR 0 4
76281: ARRAY
76282: PPUSH
76283: LD_INT 2
76285: PUSH
76286: LD_INT 30
76288: PUSH
76289: LD_INT 0
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 30
76298: PUSH
76299: LD_INT 1
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: LIST
76310: PPUSH
76311: CALL_OW 72
76315: PPUSH
76316: LD_VAR 0 1
76320: PPUSH
76321: CALL_OW 74
76325: ST_TO_ADDR
// if tmp then
76326: LD_VAR 0 5
76330: IFFALSE 76346
// ComStandNearbyBuilding ( ape , tmp ) ;
76332: LD_VAR 0 1
76336: PPUSH
76337: LD_VAR 0 5
76341: PPUSH
76342: CALL 15162 0 2
// break ;
76346: GO 76350
// end ; end ;
76348: GO 76202
76350: POP
76351: POP
// end ;
76352: LD_VAR 0 3
76356: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76357: LD_INT 0
76359: PPUSH
76360: PPUSH
76361: PPUSH
// if not mc_bases or not skirmish then
76362: LD_EXP 66
76366: NOT
76367: PUSH
76368: LD_EXP 64
76372: NOT
76373: OR
76374: IFFALSE 76378
// exit ;
76376: GO 76467
// for i = 1 to mc_bases do
76378: LD_ADDR_VAR 0 4
76382: PUSH
76383: DOUBLE
76384: LD_INT 1
76386: DEC
76387: ST_TO_ADDR
76388: LD_EXP 66
76392: PUSH
76393: FOR_TO
76394: IFFALSE 76465
// begin if building in mc_busy_turret_list [ i ] then
76396: LD_VAR 0 1
76400: PUSH
76401: LD_EXP 76
76405: PUSH
76406: LD_VAR 0 4
76410: ARRAY
76411: IN
76412: IFFALSE 76463
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76414: LD_ADDR_VAR 0 5
76418: PUSH
76419: LD_EXP 76
76423: PUSH
76424: LD_VAR 0 4
76428: ARRAY
76429: PUSH
76430: LD_VAR 0 1
76434: DIFF
76435: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76436: LD_ADDR_EXP 76
76440: PUSH
76441: LD_EXP 76
76445: PPUSH
76446: LD_VAR 0 4
76450: PPUSH
76451: LD_VAR 0 5
76455: PPUSH
76456: CALL_OW 1
76460: ST_TO_ADDR
// break ;
76461: GO 76465
// end ; end ;
76463: GO 76393
76465: POP
76466: POP
// end ;
76467: LD_VAR 0 3
76471: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76472: LD_INT 0
76474: PPUSH
76475: PPUSH
76476: PPUSH
// if not mc_bases or not skirmish then
76477: LD_EXP 66
76481: NOT
76482: PUSH
76483: LD_EXP 64
76487: NOT
76488: OR
76489: IFFALSE 76493
// exit ;
76491: GO 76692
// for i = 1 to mc_bases do
76493: LD_ADDR_VAR 0 5
76497: PUSH
76498: DOUBLE
76499: LD_INT 1
76501: DEC
76502: ST_TO_ADDR
76503: LD_EXP 66
76507: PUSH
76508: FOR_TO
76509: IFFALSE 76690
// if building in mc_bases [ i ] then
76511: LD_VAR 0 1
76515: PUSH
76516: LD_EXP 66
76520: PUSH
76521: LD_VAR 0 5
76525: ARRAY
76526: IN
76527: IFFALSE 76688
// begin tmp := mc_bases [ i ] diff building ;
76529: LD_ADDR_VAR 0 6
76533: PUSH
76534: LD_EXP 66
76538: PUSH
76539: LD_VAR 0 5
76543: ARRAY
76544: PUSH
76545: LD_VAR 0 1
76549: DIFF
76550: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76551: LD_ADDR_EXP 66
76555: PUSH
76556: LD_EXP 66
76560: PPUSH
76561: LD_VAR 0 5
76565: PPUSH
76566: LD_VAR 0 6
76570: PPUSH
76571: CALL_OW 1
76575: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76576: LD_VAR 0 1
76580: PUSH
76581: LD_EXP 74
76585: PUSH
76586: LD_VAR 0 5
76590: ARRAY
76591: IN
76592: IFFALSE 76631
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76594: LD_ADDR_EXP 74
76598: PUSH
76599: LD_EXP 74
76603: PPUSH
76604: LD_VAR 0 5
76608: PPUSH
76609: LD_EXP 74
76613: PUSH
76614: LD_VAR 0 5
76618: ARRAY
76619: PUSH
76620: LD_VAR 0 1
76624: DIFF
76625: PPUSH
76626: CALL_OW 1
76630: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76631: LD_VAR 0 1
76635: PUSH
76636: LD_EXP 75
76640: PUSH
76641: LD_VAR 0 5
76645: ARRAY
76646: IN
76647: IFFALSE 76686
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76649: LD_ADDR_EXP 75
76653: PUSH
76654: LD_EXP 75
76658: PPUSH
76659: LD_VAR 0 5
76663: PPUSH
76664: LD_EXP 75
76668: PUSH
76669: LD_VAR 0 5
76673: ARRAY
76674: PUSH
76675: LD_VAR 0 1
76679: DIFF
76680: PPUSH
76681: CALL_OW 1
76685: ST_TO_ADDR
// break ;
76686: GO 76690
// end ;
76688: GO 76508
76690: POP
76691: POP
// end ;
76692: LD_VAR 0 4
76696: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76697: LD_INT 0
76699: PPUSH
76700: PPUSH
76701: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76702: LD_EXP 66
76706: NOT
76707: PUSH
76708: LD_EXP 64
76712: NOT
76713: OR
76714: PUSH
76715: LD_VAR 0 3
76719: PUSH
76720: LD_EXP 92
76724: IN
76725: NOT
76726: OR
76727: IFFALSE 76731
// exit ;
76729: GO 76854
// for i = 1 to mc_vehicles do
76731: LD_ADDR_VAR 0 6
76735: PUSH
76736: DOUBLE
76737: LD_INT 1
76739: DEC
76740: ST_TO_ADDR
76741: LD_EXP 85
76745: PUSH
76746: FOR_TO
76747: IFFALSE 76852
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76749: LD_VAR 0 2
76753: PUSH
76754: LD_EXP 85
76758: PUSH
76759: LD_VAR 0 6
76763: ARRAY
76764: IN
76765: PUSH
76766: LD_VAR 0 1
76770: PUSH
76771: LD_EXP 85
76775: PUSH
76776: LD_VAR 0 6
76780: ARRAY
76781: IN
76782: OR
76783: IFFALSE 76850
// begin tmp := mc_vehicles [ i ] diff old ;
76785: LD_ADDR_VAR 0 7
76789: PUSH
76790: LD_EXP 85
76794: PUSH
76795: LD_VAR 0 6
76799: ARRAY
76800: PUSH
76801: LD_VAR 0 2
76805: DIFF
76806: ST_TO_ADDR
// tmp := tmp diff new ;
76807: LD_ADDR_VAR 0 7
76811: PUSH
76812: LD_VAR 0 7
76816: PUSH
76817: LD_VAR 0 1
76821: DIFF
76822: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76823: LD_ADDR_EXP 85
76827: PUSH
76828: LD_EXP 85
76832: PPUSH
76833: LD_VAR 0 6
76837: PPUSH
76838: LD_VAR 0 7
76842: PPUSH
76843: CALL_OW 1
76847: ST_TO_ADDR
// break ;
76848: GO 76852
// end ;
76850: GO 76746
76852: POP
76853: POP
// end ;
76854: LD_VAR 0 5
76858: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76859: LD_INT 0
76861: PPUSH
76862: PPUSH
76863: PPUSH
76864: PPUSH
// if not mc_bases or not skirmish then
76865: LD_EXP 66
76869: NOT
76870: PUSH
76871: LD_EXP 64
76875: NOT
76876: OR
76877: IFFALSE 76881
// exit ;
76879: GO 77264
// side := GetSide ( vehicle ) ;
76881: LD_ADDR_VAR 0 5
76885: PUSH
76886: LD_VAR 0 1
76890: PPUSH
76891: CALL_OW 255
76895: ST_TO_ADDR
// for i = 1 to mc_bases do
76896: LD_ADDR_VAR 0 4
76900: PUSH
76901: DOUBLE
76902: LD_INT 1
76904: DEC
76905: ST_TO_ADDR
76906: LD_EXP 66
76910: PUSH
76911: FOR_TO
76912: IFFALSE 77262
// begin if factory in mc_bases [ i ] then
76914: LD_VAR 0 2
76918: PUSH
76919: LD_EXP 66
76923: PUSH
76924: LD_VAR 0 4
76928: ARRAY
76929: IN
76930: IFFALSE 77260
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
76932: LD_EXP 88
76936: PUSH
76937: LD_VAR 0 4
76941: ARRAY
76942: PUSH
76943: LD_EXP 77
76947: PUSH
76948: LD_VAR 0 4
76952: ARRAY
76953: LESS
76954: PUSH
76955: LD_VAR 0 1
76959: PPUSH
76960: CALL_OW 264
76964: PUSH
76965: LD_INT 31
76967: PUSH
76968: LD_INT 32
76970: PUSH
76971: LD_INT 51
76973: PUSH
76974: LD_EXP 49
76978: PUSH
76979: LD_INT 12
76981: PUSH
76982: LD_INT 30
76984: PUSH
76985: LD_EXP 48
76989: PUSH
76990: LD_INT 11
76992: PUSH
76993: LD_INT 53
76995: PUSH
76996: LD_INT 14
76998: PUSH
76999: LD_EXP 52
77003: PUSH
77004: LD_INT 29
77006: PUSH
77007: LD_EXP 50
77011: PUSH
77012: LD_INT 13
77014: PUSH
77015: LD_INT 52
77017: PUSH
77018: LD_EXP 54
77022: PUSH
77023: LD_INT 48
77025: PUSH
77026: LD_INT 8
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: LIST
77033: LIST
77034: LIST
77035: LIST
77036: LIST
77037: LIST
77038: LIST
77039: LIST
77040: LIST
77041: LIST
77042: LIST
77043: LIST
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: IN
77049: NOT
77050: AND
77051: IFFALSE 77099
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77053: LD_ADDR_EXP 88
77057: PUSH
77058: LD_EXP 88
77062: PPUSH
77063: LD_VAR 0 4
77067: PUSH
77068: LD_EXP 88
77072: PUSH
77073: LD_VAR 0 4
77077: ARRAY
77078: PUSH
77079: LD_INT 1
77081: PLUS
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PPUSH
77087: LD_VAR 0 1
77091: PPUSH
77092: CALL 18548 0 3
77096: ST_TO_ADDR
77097: GO 77143
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77099: LD_ADDR_EXP 85
77103: PUSH
77104: LD_EXP 85
77108: PPUSH
77109: LD_VAR 0 4
77113: PUSH
77114: LD_EXP 85
77118: PUSH
77119: LD_VAR 0 4
77123: ARRAY
77124: PUSH
77125: LD_INT 1
77127: PLUS
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PPUSH
77133: LD_VAR 0 1
77137: PPUSH
77138: CALL 18548 0 3
77142: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77143: LD_VAR 0 1
77147: PPUSH
77148: CALL_OW 263
77152: PUSH
77153: LD_INT 2
77155: EQUAL
77156: IFFALSE 77176
// begin repeat wait ( 0 0$1 ) ;
77158: LD_INT 35
77160: PPUSH
77161: CALL_OW 67
// until IsControledBy ( vehicle ) ;
77165: LD_VAR 0 1
77169: PPUSH
77170: CALL_OW 312
77174: IFFALSE 77158
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77176: LD_VAR 0 1
77180: PPUSH
77181: LD_EXP 90
77185: PUSH
77186: LD_VAR 0 4
77190: ARRAY
77191: PPUSH
77192: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77196: LD_VAR 0 1
77200: PPUSH
77201: CALL_OW 263
77205: PUSH
77206: LD_INT 1
77208: NONEQUAL
77209: IFFALSE 77213
// break ;
77211: GO 77262
// repeat wait ( 0 0$1 ) ;
77213: LD_INT 35
77215: PPUSH
77216: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77220: LD_VAR 0 1
77224: PPUSH
77225: LD_EXP 90
77229: PUSH
77230: LD_VAR 0 4
77234: ARRAY
77235: PPUSH
77236: CALL_OW 308
77240: IFFALSE 77213
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77242: LD_VAR 0 1
77246: PPUSH
77247: CALL_OW 311
77251: PPUSH
77252: CALL_OW 121
// exit ;
77256: POP
77257: POP
77258: GO 77264
// end ; end ;
77260: GO 76911
77262: POP
77263: POP
// end ;
77264: LD_VAR 0 3
77268: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
77269: LD_INT 0
77271: PPUSH
77272: PPUSH
77273: PPUSH
77274: PPUSH
// if not mc_bases or not skirmish then
77275: LD_EXP 66
77279: NOT
77280: PUSH
77281: LD_EXP 64
77285: NOT
77286: OR
77287: IFFALSE 77291
// exit ;
77289: GO 77644
// repeat wait ( 0 0$1 ) ;
77291: LD_INT 35
77293: PPUSH
77294: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
77298: LD_VAR 0 2
77302: PPUSH
77303: LD_VAR 0 3
77307: PPUSH
77308: CALL_OW 284
77312: IFFALSE 77291
// if GetResourceTypeXY ( x , y ) = mat_artefact then
77314: LD_VAR 0 2
77318: PPUSH
77319: LD_VAR 0 3
77323: PPUSH
77324: CALL_OW 283
77328: PUSH
77329: LD_INT 4
77331: EQUAL
77332: IFFALSE 77336
// exit ;
77334: GO 77644
// for i = 1 to mc_bases do
77336: LD_ADDR_VAR 0 7
77340: PUSH
77341: DOUBLE
77342: LD_INT 1
77344: DEC
77345: ST_TO_ADDR
77346: LD_EXP 66
77350: PUSH
77351: FOR_TO
77352: IFFALSE 77642
// begin if mc_crates_area [ i ] then
77354: LD_EXP 84
77358: PUSH
77359: LD_VAR 0 7
77363: ARRAY
77364: IFFALSE 77475
// for j in mc_crates_area [ i ] do
77366: LD_ADDR_VAR 0 8
77370: PUSH
77371: LD_EXP 84
77375: PUSH
77376: LD_VAR 0 7
77380: ARRAY
77381: PUSH
77382: FOR_IN
77383: IFFALSE 77473
// if InArea ( x , y , j ) then
77385: LD_VAR 0 2
77389: PPUSH
77390: LD_VAR 0 3
77394: PPUSH
77395: LD_VAR 0 8
77399: PPUSH
77400: CALL_OW 309
77404: IFFALSE 77471
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77406: LD_ADDR_EXP 82
77410: PUSH
77411: LD_EXP 82
77415: PPUSH
77416: LD_VAR 0 7
77420: PUSH
77421: LD_EXP 82
77425: PUSH
77426: LD_VAR 0 7
77430: ARRAY
77431: PUSH
77432: LD_INT 1
77434: PLUS
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PPUSH
77440: LD_VAR 0 4
77444: PUSH
77445: LD_VAR 0 2
77449: PUSH
77450: LD_VAR 0 3
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: LIST
77459: PPUSH
77460: CALL 18548 0 3
77464: ST_TO_ADDR
// exit ;
77465: POP
77466: POP
77467: POP
77468: POP
77469: GO 77644
// end ;
77471: GO 77382
77473: POP
77474: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77475: LD_ADDR_VAR 0 9
77479: PUSH
77480: LD_EXP 66
77484: PUSH
77485: LD_VAR 0 7
77489: ARRAY
77490: PPUSH
77491: LD_INT 2
77493: PUSH
77494: LD_INT 30
77496: PUSH
77497: LD_INT 0
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 30
77506: PUSH
77507: LD_INT 1
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: LIST
77518: PPUSH
77519: CALL_OW 72
77523: ST_TO_ADDR
// if not depot then
77524: LD_VAR 0 9
77528: NOT
77529: IFFALSE 77533
// continue ;
77531: GO 77351
// for j in depot do
77533: LD_ADDR_VAR 0 8
77537: PUSH
77538: LD_VAR 0 9
77542: PUSH
77543: FOR_IN
77544: IFFALSE 77638
// if GetDistUnitXY ( j , x , y ) < 30 then
77546: LD_VAR 0 8
77550: PPUSH
77551: LD_VAR 0 2
77555: PPUSH
77556: LD_VAR 0 3
77560: PPUSH
77561: CALL_OW 297
77565: PUSH
77566: LD_INT 30
77568: LESS
77569: IFFALSE 77636
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77571: LD_ADDR_EXP 82
77575: PUSH
77576: LD_EXP 82
77580: PPUSH
77581: LD_VAR 0 7
77585: PUSH
77586: LD_EXP 82
77590: PUSH
77591: LD_VAR 0 7
77595: ARRAY
77596: PUSH
77597: LD_INT 1
77599: PLUS
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PPUSH
77605: LD_VAR 0 4
77609: PUSH
77610: LD_VAR 0 2
77614: PUSH
77615: LD_VAR 0 3
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: LIST
77624: PPUSH
77625: CALL 18548 0 3
77629: ST_TO_ADDR
// exit ;
77630: POP
77631: POP
77632: POP
77633: POP
77634: GO 77644
// end ;
77636: GO 77543
77638: POP
77639: POP
// end ;
77640: GO 77351
77642: POP
77643: POP
// end ;
77644: LD_VAR 0 6
77648: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77649: LD_INT 0
77651: PPUSH
77652: PPUSH
77653: PPUSH
77654: PPUSH
// if not mc_bases or not skirmish then
77655: LD_EXP 66
77659: NOT
77660: PUSH
77661: LD_EXP 64
77665: NOT
77666: OR
77667: IFFALSE 77671
// exit ;
77669: GO 77948
// side := GetSide ( lab ) ;
77671: LD_ADDR_VAR 0 4
77675: PUSH
77676: LD_VAR 0 2
77680: PPUSH
77681: CALL_OW 255
77685: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77686: LD_VAR 0 4
77690: PUSH
77691: LD_EXP 92
77695: IN
77696: NOT
77697: PUSH
77698: LD_EXP 93
77702: NOT
77703: OR
77704: PUSH
77705: LD_EXP 66
77709: NOT
77710: OR
77711: IFFALSE 77715
// exit ;
77713: GO 77948
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77715: LD_ADDR_EXP 93
77719: PUSH
77720: LD_EXP 93
77724: PPUSH
77725: LD_VAR 0 4
77729: PPUSH
77730: LD_EXP 93
77734: PUSH
77735: LD_VAR 0 4
77739: ARRAY
77740: PUSH
77741: LD_VAR 0 1
77745: DIFF
77746: PPUSH
77747: CALL_OW 1
77751: ST_TO_ADDR
// for i = 1 to mc_bases do
77752: LD_ADDR_VAR 0 5
77756: PUSH
77757: DOUBLE
77758: LD_INT 1
77760: DEC
77761: ST_TO_ADDR
77762: LD_EXP 66
77766: PUSH
77767: FOR_TO
77768: IFFALSE 77946
// begin if lab in mc_bases [ i ] then
77770: LD_VAR 0 2
77774: PUSH
77775: LD_EXP 66
77779: PUSH
77780: LD_VAR 0 5
77784: ARRAY
77785: IN
77786: IFFALSE 77944
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77788: LD_VAR 0 1
77792: PUSH
77793: LD_INT 11
77795: PUSH
77796: LD_INT 4
77798: PUSH
77799: LD_INT 3
77801: PUSH
77802: LD_INT 2
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: LIST
77809: LIST
77810: IN
77811: PUSH
77812: LD_EXP 96
77816: PUSH
77817: LD_VAR 0 5
77821: ARRAY
77822: AND
77823: IFFALSE 77944
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77825: LD_ADDR_VAR 0 6
77829: PUSH
77830: LD_EXP 96
77834: PUSH
77835: LD_VAR 0 5
77839: ARRAY
77840: PUSH
77841: LD_INT 1
77843: ARRAY
77844: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77845: LD_ADDR_EXP 96
77849: PUSH
77850: LD_EXP 96
77854: PPUSH
77855: LD_VAR 0 5
77859: PPUSH
77860: EMPTY
77861: PPUSH
77862: CALL_OW 1
77866: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77867: LD_VAR 0 6
77871: PPUSH
77872: LD_INT 0
77874: PPUSH
77875: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77879: LD_VAR 0 6
77883: PPUSH
77884: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77888: LD_ADDR_EXP 95
77892: PUSH
77893: LD_EXP 95
77897: PPUSH
77898: LD_VAR 0 5
77902: PPUSH
77903: LD_EXP 95
77907: PUSH
77908: LD_VAR 0 5
77912: ARRAY
77913: PPUSH
77914: LD_INT 1
77916: PPUSH
77917: LD_VAR 0 6
77921: PPUSH
77922: CALL_OW 2
77926: PPUSH
77927: CALL_OW 1
77931: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77932: LD_VAR 0 5
77936: PPUSH
77937: LD_INT 112
77939: PPUSH
77940: CALL 54893 0 2
// end ; end ; end ;
77944: GO 77767
77946: POP
77947: POP
// end ;
77948: LD_VAR 0 3
77952: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77953: LD_INT 0
77955: PPUSH
77956: PPUSH
77957: PPUSH
77958: PPUSH
77959: PPUSH
77960: PPUSH
77961: PPUSH
77962: PPUSH
// if not mc_bases or not skirmish then
77963: LD_EXP 66
77967: NOT
77968: PUSH
77969: LD_EXP 64
77973: NOT
77974: OR
77975: IFFALSE 77979
// exit ;
77977: GO 79350
// for i = 1 to mc_bases do
77979: LD_ADDR_VAR 0 3
77983: PUSH
77984: DOUBLE
77985: LD_INT 1
77987: DEC
77988: ST_TO_ADDR
77989: LD_EXP 66
77993: PUSH
77994: FOR_TO
77995: IFFALSE 79348
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77997: LD_VAR 0 1
78001: PUSH
78002: LD_EXP 66
78006: PUSH
78007: LD_VAR 0 3
78011: ARRAY
78012: IN
78013: PUSH
78014: LD_VAR 0 1
78018: PUSH
78019: LD_EXP 73
78023: PUSH
78024: LD_VAR 0 3
78028: ARRAY
78029: IN
78030: OR
78031: PUSH
78032: LD_VAR 0 1
78036: PUSH
78037: LD_EXP 88
78041: PUSH
78042: LD_VAR 0 3
78046: ARRAY
78047: IN
78048: OR
78049: PUSH
78050: LD_VAR 0 1
78054: PUSH
78055: LD_EXP 85
78059: PUSH
78060: LD_VAR 0 3
78064: ARRAY
78065: IN
78066: OR
78067: PUSH
78068: LD_VAR 0 1
78072: PUSH
78073: LD_EXP 95
78077: PUSH
78078: LD_VAR 0 3
78082: ARRAY
78083: IN
78084: OR
78085: PUSH
78086: LD_VAR 0 1
78090: PUSH
78091: LD_EXP 96
78095: PUSH
78096: LD_VAR 0 3
78100: ARRAY
78101: IN
78102: OR
78103: IFFALSE 79346
// begin if un in mc_ape [ i ] then
78105: LD_VAR 0 1
78109: PUSH
78110: LD_EXP 95
78114: PUSH
78115: LD_VAR 0 3
78119: ARRAY
78120: IN
78121: IFFALSE 78160
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78123: LD_ADDR_EXP 95
78127: PUSH
78128: LD_EXP 95
78132: PPUSH
78133: LD_VAR 0 3
78137: PPUSH
78138: LD_EXP 95
78142: PUSH
78143: LD_VAR 0 3
78147: ARRAY
78148: PUSH
78149: LD_VAR 0 1
78153: DIFF
78154: PPUSH
78155: CALL_OW 1
78159: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78160: LD_VAR 0 1
78164: PUSH
78165: LD_EXP 96
78169: PUSH
78170: LD_VAR 0 3
78174: ARRAY
78175: IN
78176: IFFALSE 78200
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78178: LD_ADDR_EXP 96
78182: PUSH
78183: LD_EXP 96
78187: PPUSH
78188: LD_VAR 0 3
78192: PPUSH
78193: EMPTY
78194: PPUSH
78195: CALL_OW 1
78199: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78200: LD_VAR 0 1
78204: PPUSH
78205: CALL_OW 247
78209: PUSH
78210: LD_INT 2
78212: EQUAL
78213: PUSH
78214: LD_VAR 0 1
78218: PPUSH
78219: CALL_OW 110
78223: PUSH
78224: LD_INT 20
78226: EQUAL
78227: PUSH
78228: LD_VAR 0 1
78232: PUSH
78233: LD_EXP 88
78237: PUSH
78238: LD_VAR 0 3
78242: ARRAY
78243: IN
78244: OR
78245: PUSH
78246: LD_VAR 0 1
78250: PPUSH
78251: CALL_OW 264
78255: PUSH
78256: LD_INT 12
78258: PUSH
78259: LD_INT 51
78261: PUSH
78262: LD_EXP 49
78266: PUSH
78267: LD_INT 32
78269: PUSH
78270: LD_INT 13
78272: PUSH
78273: LD_INT 52
78275: PUSH
78276: LD_INT 31
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: LIST
78286: LIST
78287: IN
78288: OR
78289: AND
78290: IFFALSE 78598
// begin if un in mc_defender [ i ] then
78292: LD_VAR 0 1
78296: PUSH
78297: LD_EXP 88
78301: PUSH
78302: LD_VAR 0 3
78306: ARRAY
78307: IN
78308: IFFALSE 78347
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78310: LD_ADDR_EXP 88
78314: PUSH
78315: LD_EXP 88
78319: PPUSH
78320: LD_VAR 0 3
78324: PPUSH
78325: LD_EXP 88
78329: PUSH
78330: LD_VAR 0 3
78334: ARRAY
78335: PUSH
78336: LD_VAR 0 1
78340: DIFF
78341: PPUSH
78342: CALL_OW 1
78346: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78347: LD_ADDR_VAR 0 8
78351: PUSH
78352: LD_VAR 0 3
78356: PPUSH
78357: LD_INT 3
78359: PPUSH
78360: CALL 74997 0 2
78364: ST_TO_ADDR
// if fac then
78365: LD_VAR 0 8
78369: IFFALSE 78598
// begin for j in fac do
78371: LD_ADDR_VAR 0 4
78375: PUSH
78376: LD_VAR 0 8
78380: PUSH
78381: FOR_IN
78382: IFFALSE 78596
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78384: LD_ADDR_VAR 0 9
78388: PUSH
78389: LD_VAR 0 8
78393: PPUSH
78394: LD_VAR 0 1
78398: PPUSH
78399: CALL_OW 265
78403: PPUSH
78404: LD_VAR 0 1
78408: PPUSH
78409: CALL_OW 262
78413: PPUSH
78414: LD_VAR 0 1
78418: PPUSH
78419: CALL_OW 263
78423: PPUSH
78424: LD_VAR 0 1
78428: PPUSH
78429: CALL_OW 264
78433: PPUSH
78434: CALL 16080 0 5
78438: ST_TO_ADDR
// if components then
78439: LD_VAR 0 9
78443: IFFALSE 78594
// begin if GetWeapon ( un ) = ar_control_tower then
78445: LD_VAR 0 1
78449: PPUSH
78450: CALL_OW 264
78454: PUSH
78455: LD_INT 31
78457: EQUAL
78458: IFFALSE 78575
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78460: LD_VAR 0 1
78464: PPUSH
78465: CALL_OW 311
78469: PPUSH
78470: LD_INT 0
78472: PPUSH
78473: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78477: LD_ADDR_EXP 106
78481: PUSH
78482: LD_EXP 106
78486: PPUSH
78487: LD_VAR 0 3
78491: PPUSH
78492: LD_EXP 106
78496: PUSH
78497: LD_VAR 0 3
78501: ARRAY
78502: PUSH
78503: LD_VAR 0 1
78507: PPUSH
78508: CALL_OW 311
78512: DIFF
78513: PPUSH
78514: CALL_OW 1
78518: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78519: LD_ADDR_VAR 0 7
78523: PUSH
78524: LD_EXP 87
78528: PUSH
78529: LD_VAR 0 3
78533: ARRAY
78534: PPUSH
78535: LD_INT 1
78537: PPUSH
78538: LD_VAR 0 9
78542: PPUSH
78543: CALL_OW 2
78547: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78548: LD_ADDR_EXP 87
78552: PUSH
78553: LD_EXP 87
78557: PPUSH
78558: LD_VAR 0 3
78562: PPUSH
78563: LD_VAR 0 7
78567: PPUSH
78568: CALL_OW 1
78572: ST_TO_ADDR
// end else
78573: GO 78592
// MC_InsertProduceList ( i , [ components ] ) ;
78575: LD_VAR 0 3
78579: PPUSH
78580: LD_VAR 0 9
78584: PUSH
78585: EMPTY
78586: LIST
78587: PPUSH
78588: CALL 74542 0 2
// break ;
78592: GO 78596
// end ; end ;
78594: GO 78381
78596: POP
78597: POP
// end ; end ; if GetType ( un ) = unit_building then
78598: LD_VAR 0 1
78602: PPUSH
78603: CALL_OW 247
78607: PUSH
78608: LD_INT 3
78610: EQUAL
78611: IFFALSE 79014
// begin btype := GetBType ( un ) ;
78613: LD_ADDR_VAR 0 5
78617: PUSH
78618: LD_VAR 0 1
78622: PPUSH
78623: CALL_OW 266
78627: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78628: LD_VAR 0 5
78632: PUSH
78633: LD_INT 29
78635: PUSH
78636: LD_INT 30
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: IN
78643: IFFALSE 78716
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78645: LD_VAR 0 1
78649: PPUSH
78650: CALL_OW 250
78654: PPUSH
78655: LD_VAR 0 1
78659: PPUSH
78660: CALL_OW 251
78664: PPUSH
78665: LD_VAR 0 1
78669: PPUSH
78670: CALL_OW 255
78674: PPUSH
78675: CALL_OW 440
78679: NOT
78680: IFFALSE 78716
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78682: LD_VAR 0 1
78686: PPUSH
78687: CALL_OW 250
78691: PPUSH
78692: LD_VAR 0 1
78696: PPUSH
78697: CALL_OW 251
78701: PPUSH
78702: LD_VAR 0 1
78706: PPUSH
78707: CALL_OW 255
78711: PPUSH
78712: CALL_OW 441
// end ; if btype = b_warehouse then
78716: LD_VAR 0 5
78720: PUSH
78721: LD_INT 1
78723: EQUAL
78724: IFFALSE 78742
// begin btype := b_depot ;
78726: LD_ADDR_VAR 0 5
78730: PUSH
78731: LD_INT 0
78733: ST_TO_ADDR
// pos := 1 ;
78734: LD_ADDR_VAR 0 6
78738: PUSH
78739: LD_INT 1
78741: ST_TO_ADDR
// end ; if btype = b_factory then
78742: LD_VAR 0 5
78746: PUSH
78747: LD_INT 3
78749: EQUAL
78750: IFFALSE 78768
// begin btype := b_workshop ;
78752: LD_ADDR_VAR 0 5
78756: PUSH
78757: LD_INT 2
78759: ST_TO_ADDR
// pos := 1 ;
78760: LD_ADDR_VAR 0 6
78764: PUSH
78765: LD_INT 1
78767: ST_TO_ADDR
// end ; if btype = b_barracks then
78768: LD_VAR 0 5
78772: PUSH
78773: LD_INT 5
78775: EQUAL
78776: IFFALSE 78786
// btype := b_armoury ;
78778: LD_ADDR_VAR 0 5
78782: PUSH
78783: LD_INT 4
78785: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78786: LD_VAR 0 5
78790: PUSH
78791: LD_INT 7
78793: PUSH
78794: LD_INT 8
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: IN
78801: IFFALSE 78811
// btype := b_lab ;
78803: LD_ADDR_VAR 0 5
78807: PUSH
78808: LD_INT 6
78810: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78811: LD_ADDR_EXP 71
78815: PUSH
78816: LD_EXP 71
78820: PPUSH
78821: LD_VAR 0 3
78825: PUSH
78826: LD_EXP 71
78830: PUSH
78831: LD_VAR 0 3
78835: ARRAY
78836: PUSH
78837: LD_INT 1
78839: PLUS
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PPUSH
78845: LD_VAR 0 5
78849: PUSH
78850: LD_VAR 0 1
78854: PPUSH
78855: CALL_OW 250
78859: PUSH
78860: LD_VAR 0 1
78864: PPUSH
78865: CALL_OW 251
78869: PUSH
78870: LD_VAR 0 1
78874: PPUSH
78875: CALL_OW 254
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: PPUSH
78886: CALL 18548 0 3
78890: ST_TO_ADDR
// if pos = 1 then
78891: LD_VAR 0 6
78895: PUSH
78896: LD_INT 1
78898: EQUAL
78899: IFFALSE 79014
// begin tmp := mc_build_list [ i ] ;
78901: LD_ADDR_VAR 0 7
78905: PUSH
78906: LD_EXP 71
78910: PUSH
78911: LD_VAR 0 3
78915: ARRAY
78916: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78917: LD_VAR 0 7
78921: PPUSH
78922: LD_INT 2
78924: PUSH
78925: LD_INT 30
78927: PUSH
78928: LD_INT 0
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 30
78937: PUSH
78938: LD_INT 1
78940: PUSH
78941: EMPTY
78942: LIST
78943: LIST
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: LIST
78949: PPUSH
78950: CALL_OW 72
78954: IFFALSE 78964
// pos := 2 ;
78956: LD_ADDR_VAR 0 6
78960: PUSH
78961: LD_INT 2
78963: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78964: LD_ADDR_VAR 0 7
78968: PUSH
78969: LD_VAR 0 7
78973: PPUSH
78974: LD_VAR 0 6
78978: PPUSH
78979: LD_VAR 0 7
78983: PPUSH
78984: CALL 18874 0 3
78988: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78989: LD_ADDR_EXP 71
78993: PUSH
78994: LD_EXP 71
78998: PPUSH
78999: LD_VAR 0 3
79003: PPUSH
79004: LD_VAR 0 7
79008: PPUSH
79009: CALL_OW 1
79013: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79014: LD_VAR 0 1
79018: PUSH
79019: LD_EXP 66
79023: PUSH
79024: LD_VAR 0 3
79028: ARRAY
79029: IN
79030: IFFALSE 79069
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79032: LD_ADDR_EXP 66
79036: PUSH
79037: LD_EXP 66
79041: PPUSH
79042: LD_VAR 0 3
79046: PPUSH
79047: LD_EXP 66
79051: PUSH
79052: LD_VAR 0 3
79056: ARRAY
79057: PUSH
79058: LD_VAR 0 1
79062: DIFF
79063: PPUSH
79064: CALL_OW 1
79068: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79069: LD_VAR 0 1
79073: PUSH
79074: LD_EXP 73
79078: PUSH
79079: LD_VAR 0 3
79083: ARRAY
79084: IN
79085: IFFALSE 79124
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79087: LD_ADDR_EXP 73
79091: PUSH
79092: LD_EXP 73
79096: PPUSH
79097: LD_VAR 0 3
79101: PPUSH
79102: LD_EXP 73
79106: PUSH
79107: LD_VAR 0 3
79111: ARRAY
79112: PUSH
79113: LD_VAR 0 1
79117: DIFF
79118: PPUSH
79119: CALL_OW 1
79123: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79124: LD_VAR 0 1
79128: PUSH
79129: LD_EXP 85
79133: PUSH
79134: LD_VAR 0 3
79138: ARRAY
79139: IN
79140: IFFALSE 79179
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79142: LD_ADDR_EXP 85
79146: PUSH
79147: LD_EXP 85
79151: PPUSH
79152: LD_VAR 0 3
79156: PPUSH
79157: LD_EXP 85
79161: PUSH
79162: LD_VAR 0 3
79166: ARRAY
79167: PUSH
79168: LD_VAR 0 1
79172: DIFF
79173: PPUSH
79174: CALL_OW 1
79178: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79179: LD_VAR 0 1
79183: PUSH
79184: LD_EXP 88
79188: PUSH
79189: LD_VAR 0 3
79193: ARRAY
79194: IN
79195: IFFALSE 79234
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79197: LD_ADDR_EXP 88
79201: PUSH
79202: LD_EXP 88
79206: PPUSH
79207: LD_VAR 0 3
79211: PPUSH
79212: LD_EXP 88
79216: PUSH
79217: LD_VAR 0 3
79221: ARRAY
79222: PUSH
79223: LD_VAR 0 1
79227: DIFF
79228: PPUSH
79229: CALL_OW 1
79233: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79234: LD_VAR 0 1
79238: PUSH
79239: LD_EXP 75
79243: PUSH
79244: LD_VAR 0 3
79248: ARRAY
79249: IN
79250: IFFALSE 79289
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79252: LD_ADDR_EXP 75
79256: PUSH
79257: LD_EXP 75
79261: PPUSH
79262: LD_VAR 0 3
79266: PPUSH
79267: LD_EXP 75
79271: PUSH
79272: LD_VAR 0 3
79276: ARRAY
79277: PUSH
79278: LD_VAR 0 1
79282: DIFF
79283: PPUSH
79284: CALL_OW 1
79288: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
79289: LD_VAR 0 1
79293: PUSH
79294: LD_EXP 74
79298: PUSH
79299: LD_VAR 0 3
79303: ARRAY
79304: IN
79305: IFFALSE 79344
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
79307: LD_ADDR_EXP 74
79311: PUSH
79312: LD_EXP 74
79316: PPUSH
79317: LD_VAR 0 3
79321: PPUSH
79322: LD_EXP 74
79326: PUSH
79327: LD_VAR 0 3
79331: ARRAY
79332: PUSH
79333: LD_VAR 0 1
79337: DIFF
79338: PPUSH
79339: CALL_OW 1
79343: ST_TO_ADDR
// end ; break ;
79344: GO 79348
// end ;
79346: GO 77994
79348: POP
79349: POP
// end ;
79350: LD_VAR 0 2
79354: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79355: LD_INT 0
79357: PPUSH
79358: PPUSH
79359: PPUSH
// if not mc_bases or not skirmish then
79360: LD_EXP 66
79364: NOT
79365: PUSH
79366: LD_EXP 64
79370: NOT
79371: OR
79372: IFFALSE 79376
// exit ;
79374: GO 79591
// for i = 1 to mc_bases do
79376: LD_ADDR_VAR 0 3
79380: PUSH
79381: DOUBLE
79382: LD_INT 1
79384: DEC
79385: ST_TO_ADDR
79386: LD_EXP 66
79390: PUSH
79391: FOR_TO
79392: IFFALSE 79589
// begin if building in mc_construct_list [ i ] then
79394: LD_VAR 0 1
79398: PUSH
79399: LD_EXP 73
79403: PUSH
79404: LD_VAR 0 3
79408: ARRAY
79409: IN
79410: IFFALSE 79587
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79412: LD_ADDR_EXP 73
79416: PUSH
79417: LD_EXP 73
79421: PPUSH
79422: LD_VAR 0 3
79426: PPUSH
79427: LD_EXP 73
79431: PUSH
79432: LD_VAR 0 3
79436: ARRAY
79437: PUSH
79438: LD_VAR 0 1
79442: DIFF
79443: PPUSH
79444: CALL_OW 1
79448: ST_TO_ADDR
// if building in mc_lab [ i ] then
79449: LD_VAR 0 1
79453: PUSH
79454: LD_EXP 99
79458: PUSH
79459: LD_VAR 0 3
79463: ARRAY
79464: IN
79465: IFFALSE 79520
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79467: LD_ADDR_EXP 100
79471: PUSH
79472: LD_EXP 100
79476: PPUSH
79477: LD_VAR 0 3
79481: PPUSH
79482: LD_EXP 100
79486: PUSH
79487: LD_VAR 0 3
79491: ARRAY
79492: PPUSH
79493: LD_INT 1
79495: PPUSH
79496: LD_EXP 100
79500: PUSH
79501: LD_VAR 0 3
79505: ARRAY
79506: PPUSH
79507: LD_INT 0
79509: PPUSH
79510: CALL 17966 0 4
79514: PPUSH
79515: CALL_OW 1
79519: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79520: LD_VAR 0 1
79524: PUSH
79525: LD_EXP 66
79529: PUSH
79530: LD_VAR 0 3
79534: ARRAY
79535: IN
79536: NOT
79537: IFFALSE 79583
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79539: LD_ADDR_EXP 66
79543: PUSH
79544: LD_EXP 66
79548: PPUSH
79549: LD_VAR 0 3
79553: PUSH
79554: LD_EXP 66
79558: PUSH
79559: LD_VAR 0 3
79563: ARRAY
79564: PUSH
79565: LD_INT 1
79567: PLUS
79568: PUSH
79569: EMPTY
79570: LIST
79571: LIST
79572: PPUSH
79573: LD_VAR 0 1
79577: PPUSH
79578: CALL 18548 0 3
79582: ST_TO_ADDR
// exit ;
79583: POP
79584: POP
79585: GO 79591
// end ; end ;
79587: GO 79391
79589: POP
79590: POP
// end ;
79591: LD_VAR 0 2
79595: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79596: LD_INT 0
79598: PPUSH
79599: PPUSH
79600: PPUSH
79601: PPUSH
79602: PPUSH
79603: PPUSH
79604: PPUSH
// if not mc_bases or not skirmish then
79605: LD_EXP 66
79609: NOT
79610: PUSH
79611: LD_EXP 64
79615: NOT
79616: OR
79617: IFFALSE 79621
// exit ;
79619: GO 80282
// for i = 1 to mc_bases do
79621: LD_ADDR_VAR 0 3
79625: PUSH
79626: DOUBLE
79627: LD_INT 1
79629: DEC
79630: ST_TO_ADDR
79631: LD_EXP 66
79635: PUSH
79636: FOR_TO
79637: IFFALSE 80280
// begin if building in mc_construct_list [ i ] then
79639: LD_VAR 0 1
79643: PUSH
79644: LD_EXP 73
79648: PUSH
79649: LD_VAR 0 3
79653: ARRAY
79654: IN
79655: IFFALSE 80278
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79657: LD_ADDR_EXP 73
79661: PUSH
79662: LD_EXP 73
79666: PPUSH
79667: LD_VAR 0 3
79671: PPUSH
79672: LD_EXP 73
79676: PUSH
79677: LD_VAR 0 3
79681: ARRAY
79682: PUSH
79683: LD_VAR 0 1
79687: DIFF
79688: PPUSH
79689: CALL_OW 1
79693: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79694: LD_ADDR_EXP 66
79698: PUSH
79699: LD_EXP 66
79703: PPUSH
79704: LD_VAR 0 3
79708: PUSH
79709: LD_EXP 66
79713: PUSH
79714: LD_VAR 0 3
79718: ARRAY
79719: PUSH
79720: LD_INT 1
79722: PLUS
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PPUSH
79728: LD_VAR 0 1
79732: PPUSH
79733: CALL 18548 0 3
79737: ST_TO_ADDR
// btype := GetBType ( building ) ;
79738: LD_ADDR_VAR 0 5
79742: PUSH
79743: LD_VAR 0 1
79747: PPUSH
79748: CALL_OW 266
79752: ST_TO_ADDR
// side := GetSide ( building ) ;
79753: LD_ADDR_VAR 0 8
79757: PUSH
79758: LD_VAR 0 1
79762: PPUSH
79763: CALL_OW 255
79767: ST_TO_ADDR
// if btype = b_lab then
79768: LD_VAR 0 5
79772: PUSH
79773: LD_INT 6
79775: EQUAL
79776: IFFALSE 79826
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79778: LD_ADDR_EXP 99
79782: PUSH
79783: LD_EXP 99
79787: PPUSH
79788: LD_VAR 0 3
79792: PUSH
79793: LD_EXP 99
79797: PUSH
79798: LD_VAR 0 3
79802: ARRAY
79803: PUSH
79804: LD_INT 1
79806: PLUS
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PPUSH
79812: LD_VAR 0 1
79816: PPUSH
79817: CALL 18548 0 3
79821: ST_TO_ADDR
// exit ;
79822: POP
79823: POP
79824: GO 80282
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79826: LD_VAR 0 5
79830: PUSH
79831: LD_INT 0
79833: PUSH
79834: LD_INT 2
79836: PUSH
79837: LD_INT 4
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: LIST
79844: IN
79845: IFFALSE 79969
// begin if btype = b_armoury then
79847: LD_VAR 0 5
79851: PUSH
79852: LD_INT 4
79854: EQUAL
79855: IFFALSE 79865
// btype := b_barracks ;
79857: LD_ADDR_VAR 0 5
79861: PUSH
79862: LD_INT 5
79864: ST_TO_ADDR
// if btype = b_depot then
79865: LD_VAR 0 5
79869: PUSH
79870: LD_INT 0
79872: EQUAL
79873: IFFALSE 79883
// btype := b_warehouse ;
79875: LD_ADDR_VAR 0 5
79879: PUSH
79880: LD_INT 1
79882: ST_TO_ADDR
// if btype = b_workshop then
79883: LD_VAR 0 5
79887: PUSH
79888: LD_INT 2
79890: EQUAL
79891: IFFALSE 79901
// btype := b_factory ;
79893: LD_ADDR_VAR 0 5
79897: PUSH
79898: LD_INT 3
79900: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79901: LD_VAR 0 5
79905: PPUSH
79906: LD_VAR 0 8
79910: PPUSH
79911: CALL_OW 323
79915: PUSH
79916: LD_INT 1
79918: EQUAL
79919: IFFALSE 79965
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79921: LD_ADDR_EXP 98
79925: PUSH
79926: LD_EXP 98
79930: PPUSH
79931: LD_VAR 0 3
79935: PUSH
79936: LD_EXP 98
79940: PUSH
79941: LD_VAR 0 3
79945: ARRAY
79946: PUSH
79947: LD_INT 1
79949: PLUS
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PPUSH
79955: LD_VAR 0 1
79959: PPUSH
79960: CALL 18548 0 3
79964: ST_TO_ADDR
// exit ;
79965: POP
79966: POP
79967: GO 80282
// end ; if btype in [ b_bunker , b_turret ] then
79969: LD_VAR 0 5
79973: PUSH
79974: LD_INT 32
79976: PUSH
79977: LD_INT 33
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: IN
79984: IFFALSE 80274
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79986: LD_ADDR_EXP 74
79990: PUSH
79991: LD_EXP 74
79995: PPUSH
79996: LD_VAR 0 3
80000: PUSH
80001: LD_EXP 74
80005: PUSH
80006: LD_VAR 0 3
80010: ARRAY
80011: PUSH
80012: LD_INT 1
80014: PLUS
80015: PUSH
80016: EMPTY
80017: LIST
80018: LIST
80019: PPUSH
80020: LD_VAR 0 1
80024: PPUSH
80025: CALL 18548 0 3
80029: ST_TO_ADDR
// if btype = b_bunker then
80030: LD_VAR 0 5
80034: PUSH
80035: LD_INT 32
80037: EQUAL
80038: IFFALSE 80274
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80040: LD_ADDR_EXP 75
80044: PUSH
80045: LD_EXP 75
80049: PPUSH
80050: LD_VAR 0 3
80054: PUSH
80055: LD_EXP 75
80059: PUSH
80060: LD_VAR 0 3
80064: ARRAY
80065: PUSH
80066: LD_INT 1
80068: PLUS
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PPUSH
80074: LD_VAR 0 1
80078: PPUSH
80079: CALL 18548 0 3
80083: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80084: LD_ADDR_VAR 0 6
80088: PUSH
80089: LD_EXP 66
80093: PUSH
80094: LD_VAR 0 3
80098: ARRAY
80099: PPUSH
80100: LD_INT 25
80102: PUSH
80103: LD_INT 1
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: LD_INT 3
80112: PUSH
80113: LD_INT 54
80115: PUSH
80116: EMPTY
80117: LIST
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PPUSH
80127: CALL_OW 72
80131: ST_TO_ADDR
// if tmp then
80132: LD_VAR 0 6
80136: IFFALSE 80142
// exit ;
80138: POP
80139: POP
80140: GO 80282
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80142: LD_ADDR_VAR 0 6
80146: PUSH
80147: LD_EXP 66
80151: PUSH
80152: LD_VAR 0 3
80156: ARRAY
80157: PPUSH
80158: LD_INT 2
80160: PUSH
80161: LD_INT 30
80163: PUSH
80164: LD_INT 4
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 30
80173: PUSH
80174: LD_INT 5
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: LIST
80185: PPUSH
80186: CALL_OW 72
80190: ST_TO_ADDR
// if not tmp then
80191: LD_VAR 0 6
80195: NOT
80196: IFFALSE 80202
// exit ;
80198: POP
80199: POP
80200: GO 80282
// for j in tmp do
80202: LD_ADDR_VAR 0 4
80206: PUSH
80207: LD_VAR 0 6
80211: PUSH
80212: FOR_IN
80213: IFFALSE 80272
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80215: LD_ADDR_VAR 0 7
80219: PUSH
80220: LD_VAR 0 4
80224: PPUSH
80225: CALL_OW 313
80229: PPUSH
80230: LD_INT 25
80232: PUSH
80233: LD_INT 1
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PPUSH
80240: CALL_OW 72
80244: ST_TO_ADDR
// if units then
80245: LD_VAR 0 7
80249: IFFALSE 80270
// begin ComExitBuilding ( units [ 1 ] ) ;
80251: LD_VAR 0 7
80255: PUSH
80256: LD_INT 1
80258: ARRAY
80259: PPUSH
80260: CALL_OW 122
// exit ;
80264: POP
80265: POP
80266: POP
80267: POP
80268: GO 80282
// end ; end ;
80270: GO 80212
80272: POP
80273: POP
// end ; end ; exit ;
80274: POP
80275: POP
80276: GO 80282
// end ; end ;
80278: GO 79636
80280: POP
80281: POP
// end ;
80282: LD_VAR 0 2
80286: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
80287: LD_INT 0
80289: PPUSH
80290: PPUSH
80291: PPUSH
80292: PPUSH
80293: PPUSH
80294: PPUSH
80295: PPUSH
// if not mc_bases or not skirmish then
80296: LD_EXP 66
80300: NOT
80301: PUSH
80302: LD_EXP 64
80306: NOT
80307: OR
80308: IFFALSE 80312
// exit ;
80310: GO 80543
// btype := GetBType ( building ) ;
80312: LD_ADDR_VAR 0 6
80316: PUSH
80317: LD_VAR 0 1
80321: PPUSH
80322: CALL_OW 266
80326: ST_TO_ADDR
// x := GetX ( building ) ;
80327: LD_ADDR_VAR 0 7
80331: PUSH
80332: LD_VAR 0 1
80336: PPUSH
80337: CALL_OW 250
80341: ST_TO_ADDR
// y := GetY ( building ) ;
80342: LD_ADDR_VAR 0 8
80346: PUSH
80347: LD_VAR 0 1
80351: PPUSH
80352: CALL_OW 251
80356: ST_TO_ADDR
// d := GetDir ( building ) ;
80357: LD_ADDR_VAR 0 9
80361: PUSH
80362: LD_VAR 0 1
80366: PPUSH
80367: CALL_OW 254
80371: ST_TO_ADDR
// for i = 1 to mc_bases do
80372: LD_ADDR_VAR 0 4
80376: PUSH
80377: DOUBLE
80378: LD_INT 1
80380: DEC
80381: ST_TO_ADDR
80382: LD_EXP 66
80386: PUSH
80387: FOR_TO
80388: IFFALSE 80541
// begin if not mc_build_list [ i ] then
80390: LD_EXP 71
80394: PUSH
80395: LD_VAR 0 4
80399: ARRAY
80400: NOT
80401: IFFALSE 80405
// continue ;
80403: GO 80387
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
80405: LD_VAR 0 6
80409: PUSH
80410: LD_VAR 0 7
80414: PUSH
80415: LD_VAR 0 8
80419: PUSH
80420: LD_VAR 0 9
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: LIST
80429: LIST
80430: PPUSH
80431: LD_EXP 71
80435: PUSH
80436: LD_VAR 0 4
80440: ARRAY
80441: PUSH
80442: LD_INT 1
80444: ARRAY
80445: PPUSH
80446: CALL 24717 0 2
80450: IFFALSE 80539
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
80452: LD_ADDR_EXP 71
80456: PUSH
80457: LD_EXP 71
80461: PPUSH
80462: LD_VAR 0 4
80466: PPUSH
80467: LD_EXP 71
80471: PUSH
80472: LD_VAR 0 4
80476: ARRAY
80477: PPUSH
80478: LD_INT 1
80480: PPUSH
80481: CALL_OW 3
80485: PPUSH
80486: CALL_OW 1
80490: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80491: LD_ADDR_EXP 73
80495: PUSH
80496: LD_EXP 73
80500: PPUSH
80501: LD_VAR 0 4
80505: PUSH
80506: LD_EXP 73
80510: PUSH
80511: LD_VAR 0 4
80515: ARRAY
80516: PUSH
80517: LD_INT 1
80519: PLUS
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PPUSH
80525: LD_VAR 0 1
80529: PPUSH
80530: CALL 18548 0 3
80534: ST_TO_ADDR
// exit ;
80535: POP
80536: POP
80537: GO 80543
// end ; end ;
80539: GO 80387
80541: POP
80542: POP
// end ;
80543: LD_VAR 0 3
80547: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80548: LD_INT 0
80550: PPUSH
80551: PPUSH
80552: PPUSH
// if not mc_bases or not skirmish then
80553: LD_EXP 66
80557: NOT
80558: PUSH
80559: LD_EXP 64
80563: NOT
80564: OR
80565: IFFALSE 80569
// exit ;
80567: GO 80759
// for i = 1 to mc_bases do
80569: LD_ADDR_VAR 0 4
80573: PUSH
80574: DOUBLE
80575: LD_INT 1
80577: DEC
80578: ST_TO_ADDR
80579: LD_EXP 66
80583: PUSH
80584: FOR_TO
80585: IFFALSE 80672
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80587: LD_VAR 0 1
80591: PUSH
80592: LD_EXP 74
80596: PUSH
80597: LD_VAR 0 4
80601: ARRAY
80602: IN
80603: PUSH
80604: LD_VAR 0 1
80608: PUSH
80609: LD_EXP 75
80613: PUSH
80614: LD_VAR 0 4
80618: ARRAY
80619: IN
80620: NOT
80621: AND
80622: IFFALSE 80670
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80624: LD_ADDR_EXP 75
80628: PUSH
80629: LD_EXP 75
80633: PPUSH
80634: LD_VAR 0 4
80638: PUSH
80639: LD_EXP 75
80643: PUSH
80644: LD_VAR 0 4
80648: ARRAY
80649: PUSH
80650: LD_INT 1
80652: PLUS
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PPUSH
80658: LD_VAR 0 1
80662: PPUSH
80663: CALL 18548 0 3
80667: ST_TO_ADDR
// break ;
80668: GO 80672
// end ; end ;
80670: GO 80584
80672: POP
80673: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80674: LD_VAR 0 1
80678: PPUSH
80679: CALL_OW 257
80683: PUSH
80684: LD_EXP 92
80688: IN
80689: PUSH
80690: LD_VAR 0 1
80694: PPUSH
80695: CALL_OW 266
80699: PUSH
80700: LD_INT 5
80702: EQUAL
80703: AND
80704: PUSH
80705: LD_VAR 0 2
80709: PPUSH
80710: CALL_OW 110
80714: PUSH
80715: LD_INT 18
80717: NONEQUAL
80718: AND
80719: IFFALSE 80759
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80721: LD_VAR 0 2
80725: PPUSH
80726: CALL_OW 257
80730: PUSH
80731: LD_INT 5
80733: PUSH
80734: LD_INT 8
80736: PUSH
80737: LD_INT 9
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: LIST
80744: IN
80745: IFFALSE 80759
// SetClass ( unit , 1 ) ;
80747: LD_VAR 0 2
80751: PPUSH
80752: LD_INT 1
80754: PPUSH
80755: CALL_OW 336
// end ;
80759: LD_VAR 0 3
80763: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80764: LD_INT 0
80766: PPUSH
80767: PPUSH
// if not mc_bases or not skirmish then
80768: LD_EXP 66
80772: NOT
80773: PUSH
80774: LD_EXP 64
80778: NOT
80779: OR
80780: IFFALSE 80784
// exit ;
80782: GO 80900
// if GetLives ( abandoned_vehicle ) > 250 then
80784: LD_VAR 0 2
80788: PPUSH
80789: CALL_OW 256
80793: PUSH
80794: LD_INT 250
80796: GREATER
80797: IFFALSE 80801
// exit ;
80799: GO 80900
// for i = 1 to mc_bases do
80801: LD_ADDR_VAR 0 6
80805: PUSH
80806: DOUBLE
80807: LD_INT 1
80809: DEC
80810: ST_TO_ADDR
80811: LD_EXP 66
80815: PUSH
80816: FOR_TO
80817: IFFALSE 80898
// begin if driver in mc_bases [ i ] then
80819: LD_VAR 0 1
80823: PUSH
80824: LD_EXP 66
80828: PUSH
80829: LD_VAR 0 6
80833: ARRAY
80834: IN
80835: IFFALSE 80896
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80837: LD_VAR 0 1
80841: PPUSH
80842: LD_EXP 66
80846: PUSH
80847: LD_VAR 0 6
80851: ARRAY
80852: PPUSH
80853: LD_INT 2
80855: PUSH
80856: LD_INT 30
80858: PUSH
80859: LD_INT 0
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 30
80868: PUSH
80869: LD_INT 1
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: LIST
80880: PPUSH
80881: CALL_OW 72
80885: PUSH
80886: LD_INT 1
80888: ARRAY
80889: PPUSH
80890: CALL 50414 0 2
// break ;
80894: GO 80898
// end ; end ;
80896: GO 80816
80898: POP
80899: POP
// end ; end_of_file end_of_file
80900: LD_VAR 0 5
80904: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
80905: LD_VAR 0 2
80909: PUSH
80910: LD_INT 100
80912: EQUAL
80913: IFFALSE 81862
// begin if not StreamModeActive then
80915: LD_EXP 109
80919: NOT
80920: IFFALSE 80930
// StreamModeActive := true ;
80922: LD_ADDR_EXP 109
80926: PUSH
80927: LD_INT 1
80929: ST_TO_ADDR
// if p3 = 0 then
80930: LD_VAR 0 3
80934: PUSH
80935: LD_INT 0
80937: EQUAL
80938: IFFALSE 80944
// InitStreamMode ;
80940: CALL 82020 0 0
// if p3 = 1 then
80944: LD_VAR 0 3
80948: PUSH
80949: LD_INT 1
80951: EQUAL
80952: IFFALSE 80962
// sRocket := true ;
80954: LD_ADDR_EXP 114
80958: PUSH
80959: LD_INT 1
80961: ST_TO_ADDR
// if p3 = 2 then
80962: LD_VAR 0 3
80966: PUSH
80967: LD_INT 2
80969: EQUAL
80970: IFFALSE 80980
// sSpeed := true ;
80972: LD_ADDR_EXP 113
80976: PUSH
80977: LD_INT 1
80979: ST_TO_ADDR
// if p3 = 3 then
80980: LD_VAR 0 3
80984: PUSH
80985: LD_INT 3
80987: EQUAL
80988: IFFALSE 80998
// sEngine := true ;
80990: LD_ADDR_EXP 115
80994: PUSH
80995: LD_INT 1
80997: ST_TO_ADDR
// if p3 = 4 then
80998: LD_VAR 0 3
81002: PUSH
81003: LD_INT 4
81005: EQUAL
81006: IFFALSE 81016
// sSpec := true ;
81008: LD_ADDR_EXP 112
81012: PUSH
81013: LD_INT 1
81015: ST_TO_ADDR
// if p3 = 5 then
81016: LD_VAR 0 3
81020: PUSH
81021: LD_INT 5
81023: EQUAL
81024: IFFALSE 81034
// sLevel := true ;
81026: LD_ADDR_EXP 116
81030: PUSH
81031: LD_INT 1
81033: ST_TO_ADDR
// if p3 = 6 then
81034: LD_VAR 0 3
81038: PUSH
81039: LD_INT 6
81041: EQUAL
81042: IFFALSE 81052
// sArmoury := true ;
81044: LD_ADDR_EXP 117
81048: PUSH
81049: LD_INT 1
81051: ST_TO_ADDR
// if p3 = 7 then
81052: LD_VAR 0 3
81056: PUSH
81057: LD_INT 7
81059: EQUAL
81060: IFFALSE 81070
// sRadar := true ;
81062: LD_ADDR_EXP 118
81066: PUSH
81067: LD_INT 1
81069: ST_TO_ADDR
// if p3 = 8 then
81070: LD_VAR 0 3
81074: PUSH
81075: LD_INT 8
81077: EQUAL
81078: IFFALSE 81088
// sBunker := true ;
81080: LD_ADDR_EXP 119
81084: PUSH
81085: LD_INT 1
81087: ST_TO_ADDR
// if p3 = 9 then
81088: LD_VAR 0 3
81092: PUSH
81093: LD_INT 9
81095: EQUAL
81096: IFFALSE 81106
// sHack := true ;
81098: LD_ADDR_EXP 120
81102: PUSH
81103: LD_INT 1
81105: ST_TO_ADDR
// if p3 = 10 then
81106: LD_VAR 0 3
81110: PUSH
81111: LD_INT 10
81113: EQUAL
81114: IFFALSE 81124
// sFire := true ;
81116: LD_ADDR_EXP 121
81120: PUSH
81121: LD_INT 1
81123: ST_TO_ADDR
// if p3 = 11 then
81124: LD_VAR 0 3
81128: PUSH
81129: LD_INT 11
81131: EQUAL
81132: IFFALSE 81142
// sRefresh := true ;
81134: LD_ADDR_EXP 122
81138: PUSH
81139: LD_INT 1
81141: ST_TO_ADDR
// if p3 = 12 then
81142: LD_VAR 0 3
81146: PUSH
81147: LD_INT 12
81149: EQUAL
81150: IFFALSE 81160
// sExp := true ;
81152: LD_ADDR_EXP 123
81156: PUSH
81157: LD_INT 1
81159: ST_TO_ADDR
// if p3 = 13 then
81160: LD_VAR 0 3
81164: PUSH
81165: LD_INT 13
81167: EQUAL
81168: IFFALSE 81178
// sDepot := true ;
81170: LD_ADDR_EXP 124
81174: PUSH
81175: LD_INT 1
81177: ST_TO_ADDR
// if p3 = 14 then
81178: LD_VAR 0 3
81182: PUSH
81183: LD_INT 14
81185: EQUAL
81186: IFFALSE 81196
// sFlag := true ;
81188: LD_ADDR_EXP 125
81192: PUSH
81193: LD_INT 1
81195: ST_TO_ADDR
// if p3 = 15 then
81196: LD_VAR 0 3
81200: PUSH
81201: LD_INT 15
81203: EQUAL
81204: IFFALSE 81214
// sKamikadze := true ;
81206: LD_ADDR_EXP 133
81210: PUSH
81211: LD_INT 1
81213: ST_TO_ADDR
// if p3 = 16 then
81214: LD_VAR 0 3
81218: PUSH
81219: LD_INT 16
81221: EQUAL
81222: IFFALSE 81232
// sTroll := true ;
81224: LD_ADDR_EXP 134
81228: PUSH
81229: LD_INT 1
81231: ST_TO_ADDR
// if p3 = 17 then
81232: LD_VAR 0 3
81236: PUSH
81237: LD_INT 17
81239: EQUAL
81240: IFFALSE 81250
// sSlow := true ;
81242: LD_ADDR_EXP 135
81246: PUSH
81247: LD_INT 1
81249: ST_TO_ADDR
// if p3 = 18 then
81250: LD_VAR 0 3
81254: PUSH
81255: LD_INT 18
81257: EQUAL
81258: IFFALSE 81268
// sLack := true ;
81260: LD_ADDR_EXP 136
81264: PUSH
81265: LD_INT 1
81267: ST_TO_ADDR
// if p3 = 19 then
81268: LD_VAR 0 3
81272: PUSH
81273: LD_INT 19
81275: EQUAL
81276: IFFALSE 81286
// sTank := true ;
81278: LD_ADDR_EXP 138
81282: PUSH
81283: LD_INT 1
81285: ST_TO_ADDR
// if p3 = 20 then
81286: LD_VAR 0 3
81290: PUSH
81291: LD_INT 20
81293: EQUAL
81294: IFFALSE 81304
// sRemote := true ;
81296: LD_ADDR_EXP 139
81300: PUSH
81301: LD_INT 1
81303: ST_TO_ADDR
// if p3 = 21 then
81304: LD_VAR 0 3
81308: PUSH
81309: LD_INT 21
81311: EQUAL
81312: IFFALSE 81322
// sPowell := true ;
81314: LD_ADDR_EXP 140
81318: PUSH
81319: LD_INT 1
81321: ST_TO_ADDR
// if p3 = 22 then
81322: LD_VAR 0 3
81326: PUSH
81327: LD_INT 22
81329: EQUAL
81330: IFFALSE 81340
// sTeleport := true ;
81332: LD_ADDR_EXP 143
81336: PUSH
81337: LD_INT 1
81339: ST_TO_ADDR
// if p3 = 23 then
81340: LD_VAR 0 3
81344: PUSH
81345: LD_INT 23
81347: EQUAL
81348: IFFALSE 81358
// sOilTower := true ;
81350: LD_ADDR_EXP 145
81354: PUSH
81355: LD_INT 1
81357: ST_TO_ADDR
// if p3 = 24 then
81358: LD_VAR 0 3
81362: PUSH
81363: LD_INT 24
81365: EQUAL
81366: IFFALSE 81376
// sShovel := true ;
81368: LD_ADDR_EXP 146
81372: PUSH
81373: LD_INT 1
81375: ST_TO_ADDR
// if p3 = 25 then
81376: LD_VAR 0 3
81380: PUSH
81381: LD_INT 25
81383: EQUAL
81384: IFFALSE 81394
// sSheik := true ;
81386: LD_ADDR_EXP 147
81390: PUSH
81391: LD_INT 1
81393: ST_TO_ADDR
// if p3 = 26 then
81394: LD_VAR 0 3
81398: PUSH
81399: LD_INT 26
81401: EQUAL
81402: IFFALSE 81412
// sEarthquake := true ;
81404: LD_ADDR_EXP 149
81408: PUSH
81409: LD_INT 1
81411: ST_TO_ADDR
// if p3 = 27 then
81412: LD_VAR 0 3
81416: PUSH
81417: LD_INT 27
81419: EQUAL
81420: IFFALSE 81430
// sAI := true ;
81422: LD_ADDR_EXP 150
81426: PUSH
81427: LD_INT 1
81429: ST_TO_ADDR
// if p3 = 28 then
81430: LD_VAR 0 3
81434: PUSH
81435: LD_INT 28
81437: EQUAL
81438: IFFALSE 81448
// sCargo := true ;
81440: LD_ADDR_EXP 153
81444: PUSH
81445: LD_INT 1
81447: ST_TO_ADDR
// if p3 = 29 then
81448: LD_VAR 0 3
81452: PUSH
81453: LD_INT 29
81455: EQUAL
81456: IFFALSE 81466
// sDLaser := true ;
81458: LD_ADDR_EXP 154
81462: PUSH
81463: LD_INT 1
81465: ST_TO_ADDR
// if p3 = 30 then
81466: LD_VAR 0 3
81470: PUSH
81471: LD_INT 30
81473: EQUAL
81474: IFFALSE 81484
// sExchange := true ;
81476: LD_ADDR_EXP 155
81480: PUSH
81481: LD_INT 1
81483: ST_TO_ADDR
// if p3 = 31 then
81484: LD_VAR 0 3
81488: PUSH
81489: LD_INT 31
81491: EQUAL
81492: IFFALSE 81502
// sFac := true ;
81494: LD_ADDR_EXP 156
81498: PUSH
81499: LD_INT 1
81501: ST_TO_ADDR
// if p3 = 32 then
81502: LD_VAR 0 3
81506: PUSH
81507: LD_INT 32
81509: EQUAL
81510: IFFALSE 81520
// sPower := true ;
81512: LD_ADDR_EXP 157
81516: PUSH
81517: LD_INT 1
81519: ST_TO_ADDR
// if p3 = 33 then
81520: LD_VAR 0 3
81524: PUSH
81525: LD_INT 33
81527: EQUAL
81528: IFFALSE 81538
// sRandom := true ;
81530: LD_ADDR_EXP 158
81534: PUSH
81535: LD_INT 1
81537: ST_TO_ADDR
// if p3 = 34 then
81538: LD_VAR 0 3
81542: PUSH
81543: LD_INT 34
81545: EQUAL
81546: IFFALSE 81556
// sShield := true ;
81548: LD_ADDR_EXP 159
81552: PUSH
81553: LD_INT 1
81555: ST_TO_ADDR
// if p3 = 35 then
81556: LD_VAR 0 3
81560: PUSH
81561: LD_INT 35
81563: EQUAL
81564: IFFALSE 81574
// sTime := true ;
81566: LD_ADDR_EXP 160
81570: PUSH
81571: LD_INT 1
81573: ST_TO_ADDR
// if p3 = 36 then
81574: LD_VAR 0 3
81578: PUSH
81579: LD_INT 36
81581: EQUAL
81582: IFFALSE 81592
// sTools := true ;
81584: LD_ADDR_EXP 161
81588: PUSH
81589: LD_INT 1
81591: ST_TO_ADDR
// if p3 = 101 then
81592: LD_VAR 0 3
81596: PUSH
81597: LD_INT 101
81599: EQUAL
81600: IFFALSE 81610
// sSold := true ;
81602: LD_ADDR_EXP 126
81606: PUSH
81607: LD_INT 1
81609: ST_TO_ADDR
// if p3 = 102 then
81610: LD_VAR 0 3
81614: PUSH
81615: LD_INT 102
81617: EQUAL
81618: IFFALSE 81628
// sDiff := true ;
81620: LD_ADDR_EXP 127
81624: PUSH
81625: LD_INT 1
81627: ST_TO_ADDR
// if p3 = 103 then
81628: LD_VAR 0 3
81632: PUSH
81633: LD_INT 103
81635: EQUAL
81636: IFFALSE 81646
// sFog := true ;
81638: LD_ADDR_EXP 130
81642: PUSH
81643: LD_INT 1
81645: ST_TO_ADDR
// if p3 = 104 then
81646: LD_VAR 0 3
81650: PUSH
81651: LD_INT 104
81653: EQUAL
81654: IFFALSE 81664
// sReset := true ;
81656: LD_ADDR_EXP 131
81660: PUSH
81661: LD_INT 1
81663: ST_TO_ADDR
// if p3 = 105 then
81664: LD_VAR 0 3
81668: PUSH
81669: LD_INT 105
81671: EQUAL
81672: IFFALSE 81682
// sSun := true ;
81674: LD_ADDR_EXP 132
81678: PUSH
81679: LD_INT 1
81681: ST_TO_ADDR
// if p3 = 106 then
81682: LD_VAR 0 3
81686: PUSH
81687: LD_INT 106
81689: EQUAL
81690: IFFALSE 81700
// sTiger := true ;
81692: LD_ADDR_EXP 128
81696: PUSH
81697: LD_INT 1
81699: ST_TO_ADDR
// if p3 = 107 then
81700: LD_VAR 0 3
81704: PUSH
81705: LD_INT 107
81707: EQUAL
81708: IFFALSE 81718
// sBomb := true ;
81710: LD_ADDR_EXP 129
81714: PUSH
81715: LD_INT 1
81717: ST_TO_ADDR
// if p3 = 108 then
81718: LD_VAR 0 3
81722: PUSH
81723: LD_INT 108
81725: EQUAL
81726: IFFALSE 81736
// sWound := true ;
81728: LD_ADDR_EXP 137
81732: PUSH
81733: LD_INT 1
81735: ST_TO_ADDR
// if p3 = 109 then
81736: LD_VAR 0 3
81740: PUSH
81741: LD_INT 109
81743: EQUAL
81744: IFFALSE 81754
// sBetray := true ;
81746: LD_ADDR_EXP 141
81750: PUSH
81751: LD_INT 1
81753: ST_TO_ADDR
// if p3 = 110 then
81754: LD_VAR 0 3
81758: PUSH
81759: LD_INT 110
81761: EQUAL
81762: IFFALSE 81772
// sContamin := true ;
81764: LD_ADDR_EXP 142
81768: PUSH
81769: LD_INT 1
81771: ST_TO_ADDR
// if p3 = 111 then
81772: LD_VAR 0 3
81776: PUSH
81777: LD_INT 111
81779: EQUAL
81780: IFFALSE 81790
// sOil := true ;
81782: LD_ADDR_EXP 144
81786: PUSH
81787: LD_INT 1
81789: ST_TO_ADDR
// if p3 = 112 then
81790: LD_VAR 0 3
81794: PUSH
81795: LD_INT 112
81797: EQUAL
81798: IFFALSE 81808
// sStu := true ;
81800: LD_ADDR_EXP 148
81804: PUSH
81805: LD_INT 1
81807: ST_TO_ADDR
// if p3 = 113 then
81808: LD_VAR 0 3
81812: PUSH
81813: LD_INT 113
81815: EQUAL
81816: IFFALSE 81826
// sBazooka := true ;
81818: LD_ADDR_EXP 151
81822: PUSH
81823: LD_INT 1
81825: ST_TO_ADDR
// if p3 = 114 then
81826: LD_VAR 0 3
81830: PUSH
81831: LD_INT 114
81833: EQUAL
81834: IFFALSE 81844
// sMortar := true ;
81836: LD_ADDR_EXP 152
81840: PUSH
81841: LD_INT 1
81843: ST_TO_ADDR
// if p3 = 115 then
81844: LD_VAR 0 3
81848: PUSH
81849: LD_INT 115
81851: EQUAL
81852: IFFALSE 81862
// sRanger := true ;
81854: LD_ADDR_EXP 162
81858: PUSH
81859: LD_INT 1
81861: ST_TO_ADDR
// end ; if p2 = 101 then
81862: LD_VAR 0 2
81866: PUSH
81867: LD_INT 101
81869: EQUAL
81870: IFFALSE 81998
// begin case p3 of 1 :
81872: LD_VAR 0 3
81876: PUSH
81877: LD_INT 1
81879: DOUBLE
81880: EQUAL
81881: IFTRUE 81885
81883: GO 81892
81885: POP
// hHackUnlimitedResources ; 2 :
81886: CALL 93033 0 0
81890: GO 81998
81892: LD_INT 2
81894: DOUBLE
81895: EQUAL
81896: IFTRUE 81900
81898: GO 81907
81900: POP
// hHackSetLevel10 ; 3 :
81901: CALL 93166 0 0
81905: GO 81998
81907: LD_INT 3
81909: DOUBLE
81910: EQUAL
81911: IFTRUE 81915
81913: GO 81922
81915: POP
// hHackSetLevel10YourUnits ; 4 :
81916: CALL 93251 0 0
81920: GO 81998
81922: LD_INT 4
81924: DOUBLE
81925: EQUAL
81926: IFTRUE 81930
81928: GO 81937
81930: POP
// hHackInvincible ; 5 :
81931: CALL 93699 0 0
81935: GO 81998
81937: LD_INT 5
81939: DOUBLE
81940: EQUAL
81941: IFTRUE 81945
81943: GO 81952
81945: POP
// hHackInvisible ; 6 :
81946: CALL 93810 0 0
81950: GO 81998
81952: LD_INT 6
81954: DOUBLE
81955: EQUAL
81956: IFTRUE 81960
81958: GO 81967
81960: POP
// hHackChangeYourSide ; 7 :
81961: CALL 93867 0 0
81965: GO 81998
81967: LD_INT 7
81969: DOUBLE
81970: EQUAL
81971: IFTRUE 81975
81973: GO 81982
81975: POP
// hHackChangeUnitSide ; 8 :
81976: CALL 93909 0 0
81980: GO 81998
81982: LD_INT 8
81984: DOUBLE
81985: EQUAL
81986: IFTRUE 81990
81988: GO 81997
81990: POP
// hHackFog ; end ;
81991: CALL 94010 0 0
81995: GO 81998
81997: POP
// end ; end ;
81998: PPOPN 6
82000: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
82001: GO 82003
82003: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
82004: LD_STRING initStreamRollete();
82006: PPUSH
82007: CALL_OW 559
// InitStreamMode ;
82011: CALL 82020 0 0
// DefineStreamItems ( ) ;
82015: CALL 82460 0 0
// end ;
82019: END
// function InitStreamMode ; begin
82020: LD_INT 0
82022: PPUSH
// streamModeActive := false ;
82023: LD_ADDR_EXP 109
82027: PUSH
82028: LD_INT 0
82030: ST_TO_ADDR
// normalCounter := 36 ;
82031: LD_ADDR_EXP 110
82035: PUSH
82036: LD_INT 36
82038: ST_TO_ADDR
// hardcoreCounter := 16 ;
82039: LD_ADDR_EXP 111
82043: PUSH
82044: LD_INT 16
82046: ST_TO_ADDR
// sRocket := false ;
82047: LD_ADDR_EXP 114
82051: PUSH
82052: LD_INT 0
82054: ST_TO_ADDR
// sSpeed := false ;
82055: LD_ADDR_EXP 113
82059: PUSH
82060: LD_INT 0
82062: ST_TO_ADDR
// sEngine := false ;
82063: LD_ADDR_EXP 115
82067: PUSH
82068: LD_INT 0
82070: ST_TO_ADDR
// sSpec := false ;
82071: LD_ADDR_EXP 112
82075: PUSH
82076: LD_INT 0
82078: ST_TO_ADDR
// sLevel := false ;
82079: LD_ADDR_EXP 116
82083: PUSH
82084: LD_INT 0
82086: ST_TO_ADDR
// sArmoury := false ;
82087: LD_ADDR_EXP 117
82091: PUSH
82092: LD_INT 0
82094: ST_TO_ADDR
// sRadar := false ;
82095: LD_ADDR_EXP 118
82099: PUSH
82100: LD_INT 0
82102: ST_TO_ADDR
// sBunker := false ;
82103: LD_ADDR_EXP 119
82107: PUSH
82108: LD_INT 0
82110: ST_TO_ADDR
// sHack := false ;
82111: LD_ADDR_EXP 120
82115: PUSH
82116: LD_INT 0
82118: ST_TO_ADDR
// sFire := false ;
82119: LD_ADDR_EXP 121
82123: PUSH
82124: LD_INT 0
82126: ST_TO_ADDR
// sRefresh := false ;
82127: LD_ADDR_EXP 122
82131: PUSH
82132: LD_INT 0
82134: ST_TO_ADDR
// sExp := false ;
82135: LD_ADDR_EXP 123
82139: PUSH
82140: LD_INT 0
82142: ST_TO_ADDR
// sDepot := false ;
82143: LD_ADDR_EXP 124
82147: PUSH
82148: LD_INT 0
82150: ST_TO_ADDR
// sFlag := false ;
82151: LD_ADDR_EXP 125
82155: PUSH
82156: LD_INT 0
82158: ST_TO_ADDR
// sKamikadze := false ;
82159: LD_ADDR_EXP 133
82163: PUSH
82164: LD_INT 0
82166: ST_TO_ADDR
// sTroll := false ;
82167: LD_ADDR_EXP 134
82171: PUSH
82172: LD_INT 0
82174: ST_TO_ADDR
// sSlow := false ;
82175: LD_ADDR_EXP 135
82179: PUSH
82180: LD_INT 0
82182: ST_TO_ADDR
// sLack := false ;
82183: LD_ADDR_EXP 136
82187: PUSH
82188: LD_INT 0
82190: ST_TO_ADDR
// sTank := false ;
82191: LD_ADDR_EXP 138
82195: PUSH
82196: LD_INT 0
82198: ST_TO_ADDR
// sRemote := false ;
82199: LD_ADDR_EXP 139
82203: PUSH
82204: LD_INT 0
82206: ST_TO_ADDR
// sPowell := false ;
82207: LD_ADDR_EXP 140
82211: PUSH
82212: LD_INT 0
82214: ST_TO_ADDR
// sTeleport := false ;
82215: LD_ADDR_EXP 143
82219: PUSH
82220: LD_INT 0
82222: ST_TO_ADDR
// sOilTower := false ;
82223: LD_ADDR_EXP 145
82227: PUSH
82228: LD_INT 0
82230: ST_TO_ADDR
// sShovel := false ;
82231: LD_ADDR_EXP 146
82235: PUSH
82236: LD_INT 0
82238: ST_TO_ADDR
// sSheik := false ;
82239: LD_ADDR_EXP 147
82243: PUSH
82244: LD_INT 0
82246: ST_TO_ADDR
// sEarthquake := false ;
82247: LD_ADDR_EXP 149
82251: PUSH
82252: LD_INT 0
82254: ST_TO_ADDR
// sAI := false ;
82255: LD_ADDR_EXP 150
82259: PUSH
82260: LD_INT 0
82262: ST_TO_ADDR
// sCargo := false ;
82263: LD_ADDR_EXP 153
82267: PUSH
82268: LD_INT 0
82270: ST_TO_ADDR
// sDLaser := false ;
82271: LD_ADDR_EXP 154
82275: PUSH
82276: LD_INT 0
82278: ST_TO_ADDR
// sExchange := false ;
82279: LD_ADDR_EXP 155
82283: PUSH
82284: LD_INT 0
82286: ST_TO_ADDR
// sFac := false ;
82287: LD_ADDR_EXP 156
82291: PUSH
82292: LD_INT 0
82294: ST_TO_ADDR
// sPower := false ;
82295: LD_ADDR_EXP 157
82299: PUSH
82300: LD_INT 0
82302: ST_TO_ADDR
// sRandom := false ;
82303: LD_ADDR_EXP 158
82307: PUSH
82308: LD_INT 0
82310: ST_TO_ADDR
// sShield := false ;
82311: LD_ADDR_EXP 159
82315: PUSH
82316: LD_INT 0
82318: ST_TO_ADDR
// sTime := false ;
82319: LD_ADDR_EXP 160
82323: PUSH
82324: LD_INT 0
82326: ST_TO_ADDR
// sTools := false ;
82327: LD_ADDR_EXP 161
82331: PUSH
82332: LD_INT 0
82334: ST_TO_ADDR
// sSold := false ;
82335: LD_ADDR_EXP 126
82339: PUSH
82340: LD_INT 0
82342: ST_TO_ADDR
// sDiff := false ;
82343: LD_ADDR_EXP 127
82347: PUSH
82348: LD_INT 0
82350: ST_TO_ADDR
// sFog := false ;
82351: LD_ADDR_EXP 130
82355: PUSH
82356: LD_INT 0
82358: ST_TO_ADDR
// sReset := false ;
82359: LD_ADDR_EXP 131
82363: PUSH
82364: LD_INT 0
82366: ST_TO_ADDR
// sSun := false ;
82367: LD_ADDR_EXP 132
82371: PUSH
82372: LD_INT 0
82374: ST_TO_ADDR
// sTiger := false ;
82375: LD_ADDR_EXP 128
82379: PUSH
82380: LD_INT 0
82382: ST_TO_ADDR
// sBomb := false ;
82383: LD_ADDR_EXP 129
82387: PUSH
82388: LD_INT 0
82390: ST_TO_ADDR
// sWound := false ;
82391: LD_ADDR_EXP 137
82395: PUSH
82396: LD_INT 0
82398: ST_TO_ADDR
// sBetray := false ;
82399: LD_ADDR_EXP 141
82403: PUSH
82404: LD_INT 0
82406: ST_TO_ADDR
// sContamin := false ;
82407: LD_ADDR_EXP 142
82411: PUSH
82412: LD_INT 0
82414: ST_TO_ADDR
// sOil := false ;
82415: LD_ADDR_EXP 144
82419: PUSH
82420: LD_INT 0
82422: ST_TO_ADDR
// sStu := false ;
82423: LD_ADDR_EXP 148
82427: PUSH
82428: LD_INT 0
82430: ST_TO_ADDR
// sBazooka := false ;
82431: LD_ADDR_EXP 151
82435: PUSH
82436: LD_INT 0
82438: ST_TO_ADDR
// sMortar := false ;
82439: LD_ADDR_EXP 152
82443: PUSH
82444: LD_INT 0
82446: ST_TO_ADDR
// sRanger := false ;
82447: LD_ADDR_EXP 162
82451: PUSH
82452: LD_INT 0
82454: ST_TO_ADDR
// end ;
82455: LD_VAR 0 1
82459: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
82460: LD_INT 0
82462: PPUSH
82463: PPUSH
82464: PPUSH
82465: PPUSH
82466: PPUSH
// result := [ ] ;
82467: LD_ADDR_VAR 0 1
82471: PUSH
82472: EMPTY
82473: ST_TO_ADDR
// if campaign_id = 1 then
82474: LD_OWVAR 69
82478: PUSH
82479: LD_INT 1
82481: EQUAL
82482: IFFALSE 85420
// begin case mission_number of 1 :
82484: LD_OWVAR 70
82488: PUSH
82489: LD_INT 1
82491: DOUBLE
82492: EQUAL
82493: IFTRUE 82497
82495: GO 82561
82497: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
82498: LD_ADDR_VAR 0 1
82502: PUSH
82503: LD_INT 2
82505: PUSH
82506: LD_INT 4
82508: PUSH
82509: LD_INT 11
82511: PUSH
82512: LD_INT 12
82514: PUSH
82515: LD_INT 15
82517: PUSH
82518: LD_INT 16
82520: PUSH
82521: LD_INT 22
82523: PUSH
82524: LD_INT 23
82526: PUSH
82527: LD_INT 26
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 101
82543: PUSH
82544: LD_INT 102
82546: PUSH
82547: LD_INT 106
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: LIST
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: ST_TO_ADDR
82559: GO 85418
82561: LD_INT 2
82563: DOUBLE
82564: EQUAL
82565: IFTRUE 82569
82567: GO 82641
82569: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
82570: LD_ADDR_VAR 0 1
82574: PUSH
82575: LD_INT 2
82577: PUSH
82578: LD_INT 4
82580: PUSH
82581: LD_INT 11
82583: PUSH
82584: LD_INT 12
82586: PUSH
82587: LD_INT 15
82589: PUSH
82590: LD_INT 16
82592: PUSH
82593: LD_INT 22
82595: PUSH
82596: LD_INT 23
82598: PUSH
82599: LD_INT 26
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: LIST
82608: LIST
82609: LIST
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 101
82615: PUSH
82616: LD_INT 102
82618: PUSH
82619: LD_INT 105
82621: PUSH
82622: LD_INT 106
82624: PUSH
82625: LD_INT 108
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: ST_TO_ADDR
82639: GO 85418
82641: LD_INT 3
82643: DOUBLE
82644: EQUAL
82645: IFTRUE 82649
82647: GO 82725
82649: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
82650: LD_ADDR_VAR 0 1
82654: PUSH
82655: LD_INT 2
82657: PUSH
82658: LD_INT 4
82660: PUSH
82661: LD_INT 5
82663: PUSH
82664: LD_INT 11
82666: PUSH
82667: LD_INT 12
82669: PUSH
82670: LD_INT 15
82672: PUSH
82673: LD_INT 16
82675: PUSH
82676: LD_INT 22
82678: PUSH
82679: LD_INT 26
82681: PUSH
82682: LD_INT 36
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: LIST
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 101
82699: PUSH
82700: LD_INT 102
82702: PUSH
82703: LD_INT 105
82705: PUSH
82706: LD_INT 106
82708: PUSH
82709: LD_INT 108
82711: PUSH
82712: EMPTY
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: PUSH
82719: EMPTY
82720: LIST
82721: LIST
82722: ST_TO_ADDR
82723: GO 85418
82725: LD_INT 4
82727: DOUBLE
82728: EQUAL
82729: IFTRUE 82733
82731: GO 82817
82733: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
82734: LD_ADDR_VAR 0 1
82738: PUSH
82739: LD_INT 2
82741: PUSH
82742: LD_INT 4
82744: PUSH
82745: LD_INT 5
82747: PUSH
82748: LD_INT 8
82750: PUSH
82751: LD_INT 11
82753: PUSH
82754: LD_INT 12
82756: PUSH
82757: LD_INT 15
82759: PUSH
82760: LD_INT 16
82762: PUSH
82763: LD_INT 22
82765: PUSH
82766: LD_INT 23
82768: PUSH
82769: LD_INT 26
82771: PUSH
82772: LD_INT 36
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 101
82791: PUSH
82792: LD_INT 102
82794: PUSH
82795: LD_INT 105
82797: PUSH
82798: LD_INT 106
82800: PUSH
82801: LD_INT 108
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: ST_TO_ADDR
82815: GO 85418
82817: LD_INT 5
82819: DOUBLE
82820: EQUAL
82821: IFTRUE 82825
82823: GO 82925
82825: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
82826: LD_ADDR_VAR 0 1
82830: PUSH
82831: LD_INT 2
82833: PUSH
82834: LD_INT 4
82836: PUSH
82837: LD_INT 5
82839: PUSH
82840: LD_INT 6
82842: PUSH
82843: LD_INT 8
82845: PUSH
82846: LD_INT 11
82848: PUSH
82849: LD_INT 12
82851: PUSH
82852: LD_INT 15
82854: PUSH
82855: LD_INT 16
82857: PUSH
82858: LD_INT 22
82860: PUSH
82861: LD_INT 23
82863: PUSH
82864: LD_INT 25
82866: PUSH
82867: LD_INT 26
82869: PUSH
82870: LD_INT 36
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 101
82891: PUSH
82892: LD_INT 102
82894: PUSH
82895: LD_INT 105
82897: PUSH
82898: LD_INT 106
82900: PUSH
82901: LD_INT 108
82903: PUSH
82904: LD_INT 109
82906: PUSH
82907: LD_INT 112
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: ST_TO_ADDR
82923: GO 85418
82925: LD_INT 6
82927: DOUBLE
82928: EQUAL
82929: IFTRUE 82933
82931: GO 83053
82933: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
82934: LD_ADDR_VAR 0 1
82938: PUSH
82939: LD_INT 2
82941: PUSH
82942: LD_INT 4
82944: PUSH
82945: LD_INT 5
82947: PUSH
82948: LD_INT 6
82950: PUSH
82951: LD_INT 8
82953: PUSH
82954: LD_INT 11
82956: PUSH
82957: LD_INT 12
82959: PUSH
82960: LD_INT 15
82962: PUSH
82963: LD_INT 16
82965: PUSH
82966: LD_INT 20
82968: PUSH
82969: LD_INT 21
82971: PUSH
82972: LD_INT 22
82974: PUSH
82975: LD_INT 23
82977: PUSH
82978: LD_INT 25
82980: PUSH
82981: LD_INT 26
82983: PUSH
82984: LD_INT 30
82986: PUSH
82987: LD_INT 31
82989: PUSH
82990: LD_INT 32
82992: PUSH
82993: LD_INT 36
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 101
83019: PUSH
83020: LD_INT 102
83022: PUSH
83023: LD_INT 105
83025: PUSH
83026: LD_INT 106
83028: PUSH
83029: LD_INT 108
83031: PUSH
83032: LD_INT 109
83034: PUSH
83035: LD_INT 112
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: ST_TO_ADDR
83051: GO 85418
83053: LD_INT 7
83055: DOUBLE
83056: EQUAL
83057: IFTRUE 83061
83059: GO 83161
83061: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
83062: LD_ADDR_VAR 0 1
83066: PUSH
83067: LD_INT 2
83069: PUSH
83070: LD_INT 4
83072: PUSH
83073: LD_INT 5
83075: PUSH
83076: LD_INT 7
83078: PUSH
83079: LD_INT 11
83081: PUSH
83082: LD_INT 12
83084: PUSH
83085: LD_INT 15
83087: PUSH
83088: LD_INT 16
83090: PUSH
83091: LD_INT 20
83093: PUSH
83094: LD_INT 21
83096: PUSH
83097: LD_INT 22
83099: PUSH
83100: LD_INT 23
83102: PUSH
83103: LD_INT 25
83105: PUSH
83106: LD_INT 26
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 101
83127: PUSH
83128: LD_INT 102
83130: PUSH
83131: LD_INT 103
83133: PUSH
83134: LD_INT 105
83136: PUSH
83137: LD_INT 106
83139: PUSH
83140: LD_INT 108
83142: PUSH
83143: LD_INT 112
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: ST_TO_ADDR
83159: GO 85418
83161: LD_INT 8
83163: DOUBLE
83164: EQUAL
83165: IFTRUE 83169
83167: GO 83297
83169: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
83170: LD_ADDR_VAR 0 1
83174: PUSH
83175: LD_INT 2
83177: PUSH
83178: LD_INT 4
83180: PUSH
83181: LD_INT 5
83183: PUSH
83184: LD_INT 6
83186: PUSH
83187: LD_INT 7
83189: PUSH
83190: LD_INT 8
83192: PUSH
83193: LD_INT 11
83195: PUSH
83196: LD_INT 12
83198: PUSH
83199: LD_INT 15
83201: PUSH
83202: LD_INT 16
83204: PUSH
83205: LD_INT 20
83207: PUSH
83208: LD_INT 21
83210: PUSH
83211: LD_INT 22
83213: PUSH
83214: LD_INT 23
83216: PUSH
83217: LD_INT 25
83219: PUSH
83220: LD_INT 26
83222: PUSH
83223: LD_INT 30
83225: PUSH
83226: LD_INT 31
83228: PUSH
83229: LD_INT 32
83231: PUSH
83232: LD_INT 36
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 101
83259: PUSH
83260: LD_INT 102
83262: PUSH
83263: LD_INT 103
83265: PUSH
83266: LD_INT 105
83268: PUSH
83269: LD_INT 106
83271: PUSH
83272: LD_INT 108
83274: PUSH
83275: LD_INT 109
83277: PUSH
83278: LD_INT 112
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: ST_TO_ADDR
83295: GO 85418
83297: LD_INT 9
83299: DOUBLE
83300: EQUAL
83301: IFTRUE 83305
83303: GO 83441
83305: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
83306: LD_ADDR_VAR 0 1
83310: PUSH
83311: LD_INT 2
83313: PUSH
83314: LD_INT 4
83316: PUSH
83317: LD_INT 5
83319: PUSH
83320: LD_INT 6
83322: PUSH
83323: LD_INT 7
83325: PUSH
83326: LD_INT 8
83328: PUSH
83329: LD_INT 11
83331: PUSH
83332: LD_INT 12
83334: PUSH
83335: LD_INT 15
83337: PUSH
83338: LD_INT 16
83340: PUSH
83341: LD_INT 20
83343: PUSH
83344: LD_INT 21
83346: PUSH
83347: LD_INT 22
83349: PUSH
83350: LD_INT 23
83352: PUSH
83353: LD_INT 25
83355: PUSH
83356: LD_INT 26
83358: PUSH
83359: LD_INT 28
83361: PUSH
83362: LD_INT 30
83364: PUSH
83365: LD_INT 31
83367: PUSH
83368: LD_INT 32
83370: PUSH
83371: LD_INT 36
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 101
83399: PUSH
83400: LD_INT 102
83402: PUSH
83403: LD_INT 103
83405: PUSH
83406: LD_INT 105
83408: PUSH
83409: LD_INT 106
83411: PUSH
83412: LD_INT 108
83414: PUSH
83415: LD_INT 109
83417: PUSH
83418: LD_INT 112
83420: PUSH
83421: LD_INT 114
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: ST_TO_ADDR
83439: GO 85418
83441: LD_INT 10
83443: DOUBLE
83444: EQUAL
83445: IFTRUE 83449
83447: GO 83633
83449: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
83450: LD_ADDR_VAR 0 1
83454: PUSH
83455: LD_INT 2
83457: PUSH
83458: LD_INT 4
83460: PUSH
83461: LD_INT 5
83463: PUSH
83464: LD_INT 6
83466: PUSH
83467: LD_INT 7
83469: PUSH
83470: LD_INT 8
83472: PUSH
83473: LD_INT 9
83475: PUSH
83476: LD_INT 10
83478: PUSH
83479: LD_INT 11
83481: PUSH
83482: LD_INT 12
83484: PUSH
83485: LD_INT 13
83487: PUSH
83488: LD_INT 14
83490: PUSH
83491: LD_INT 15
83493: PUSH
83494: LD_INT 16
83496: PUSH
83497: LD_INT 17
83499: PUSH
83500: LD_INT 18
83502: PUSH
83503: LD_INT 19
83505: PUSH
83506: LD_INT 20
83508: PUSH
83509: LD_INT 21
83511: PUSH
83512: LD_INT 22
83514: PUSH
83515: LD_INT 23
83517: PUSH
83518: LD_INT 24
83520: PUSH
83521: LD_INT 25
83523: PUSH
83524: LD_INT 26
83526: PUSH
83527: LD_INT 28
83529: PUSH
83530: LD_INT 30
83532: PUSH
83533: LD_INT 31
83535: PUSH
83536: LD_INT 32
83538: PUSH
83539: LD_INT 36
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 101
83575: PUSH
83576: LD_INT 102
83578: PUSH
83579: LD_INT 103
83581: PUSH
83582: LD_INT 104
83584: PUSH
83585: LD_INT 105
83587: PUSH
83588: LD_INT 106
83590: PUSH
83591: LD_INT 107
83593: PUSH
83594: LD_INT 108
83596: PUSH
83597: LD_INT 109
83599: PUSH
83600: LD_INT 110
83602: PUSH
83603: LD_INT 111
83605: PUSH
83606: LD_INT 112
83608: PUSH
83609: LD_INT 114
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: ST_TO_ADDR
83631: GO 85418
83633: LD_INT 11
83635: DOUBLE
83636: EQUAL
83637: IFTRUE 83641
83639: GO 83833
83641: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
83642: LD_ADDR_VAR 0 1
83646: PUSH
83647: LD_INT 2
83649: PUSH
83650: LD_INT 3
83652: PUSH
83653: LD_INT 4
83655: PUSH
83656: LD_INT 5
83658: PUSH
83659: LD_INT 6
83661: PUSH
83662: LD_INT 7
83664: PUSH
83665: LD_INT 8
83667: PUSH
83668: LD_INT 9
83670: PUSH
83671: LD_INT 10
83673: PUSH
83674: LD_INT 11
83676: PUSH
83677: LD_INT 12
83679: PUSH
83680: LD_INT 13
83682: PUSH
83683: LD_INT 14
83685: PUSH
83686: LD_INT 15
83688: PUSH
83689: LD_INT 16
83691: PUSH
83692: LD_INT 17
83694: PUSH
83695: LD_INT 18
83697: PUSH
83698: LD_INT 19
83700: PUSH
83701: LD_INT 20
83703: PUSH
83704: LD_INT 21
83706: PUSH
83707: LD_INT 22
83709: PUSH
83710: LD_INT 23
83712: PUSH
83713: LD_INT 24
83715: PUSH
83716: LD_INT 25
83718: PUSH
83719: LD_INT 26
83721: PUSH
83722: LD_INT 28
83724: PUSH
83725: LD_INT 30
83727: PUSH
83728: LD_INT 31
83730: PUSH
83731: LD_INT 32
83733: PUSH
83734: LD_INT 34
83736: PUSH
83737: LD_INT 36
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 101
83775: PUSH
83776: LD_INT 102
83778: PUSH
83779: LD_INT 103
83781: PUSH
83782: LD_INT 104
83784: PUSH
83785: LD_INT 105
83787: PUSH
83788: LD_INT 106
83790: PUSH
83791: LD_INT 107
83793: PUSH
83794: LD_INT 108
83796: PUSH
83797: LD_INT 109
83799: PUSH
83800: LD_INT 110
83802: PUSH
83803: LD_INT 111
83805: PUSH
83806: LD_INT 112
83808: PUSH
83809: LD_INT 114
83811: PUSH
83812: EMPTY
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: ST_TO_ADDR
83831: GO 85418
83833: LD_INT 12
83835: DOUBLE
83836: EQUAL
83837: IFTRUE 83841
83839: GO 84049
83841: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
83842: LD_ADDR_VAR 0 1
83846: PUSH
83847: LD_INT 1
83849: PUSH
83850: LD_INT 2
83852: PUSH
83853: LD_INT 3
83855: PUSH
83856: LD_INT 4
83858: PUSH
83859: LD_INT 5
83861: PUSH
83862: LD_INT 6
83864: PUSH
83865: LD_INT 7
83867: PUSH
83868: LD_INT 8
83870: PUSH
83871: LD_INT 9
83873: PUSH
83874: LD_INT 10
83876: PUSH
83877: LD_INT 11
83879: PUSH
83880: LD_INT 12
83882: PUSH
83883: LD_INT 13
83885: PUSH
83886: LD_INT 14
83888: PUSH
83889: LD_INT 15
83891: PUSH
83892: LD_INT 16
83894: PUSH
83895: LD_INT 17
83897: PUSH
83898: LD_INT 18
83900: PUSH
83901: LD_INT 19
83903: PUSH
83904: LD_INT 20
83906: PUSH
83907: LD_INT 21
83909: PUSH
83910: LD_INT 22
83912: PUSH
83913: LD_INT 23
83915: PUSH
83916: LD_INT 24
83918: PUSH
83919: LD_INT 25
83921: PUSH
83922: LD_INT 26
83924: PUSH
83925: LD_INT 27
83927: PUSH
83928: LD_INT 28
83930: PUSH
83931: LD_INT 30
83933: PUSH
83934: LD_INT 31
83936: PUSH
83937: LD_INT 32
83939: PUSH
83940: LD_INT 33
83942: PUSH
83943: LD_INT 34
83945: PUSH
83946: LD_INT 36
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: LIST
83977: LIST
83978: LIST
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 101
83987: PUSH
83988: LD_INT 102
83990: PUSH
83991: LD_INT 103
83993: PUSH
83994: LD_INT 104
83996: PUSH
83997: LD_INT 105
83999: PUSH
84000: LD_INT 106
84002: PUSH
84003: LD_INT 107
84005: PUSH
84006: LD_INT 108
84008: PUSH
84009: LD_INT 109
84011: PUSH
84012: LD_INT 110
84014: PUSH
84015: LD_INT 111
84017: PUSH
84018: LD_INT 112
84020: PUSH
84021: LD_INT 113
84023: PUSH
84024: LD_INT 114
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: ST_TO_ADDR
84047: GO 85418
84049: LD_INT 13
84051: DOUBLE
84052: EQUAL
84053: IFTRUE 84057
84055: GO 84253
84057: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
84058: LD_ADDR_VAR 0 1
84062: PUSH
84063: LD_INT 1
84065: PUSH
84066: LD_INT 2
84068: PUSH
84069: LD_INT 3
84071: PUSH
84072: LD_INT 4
84074: PUSH
84075: LD_INT 5
84077: PUSH
84078: LD_INT 8
84080: PUSH
84081: LD_INT 9
84083: PUSH
84084: LD_INT 10
84086: PUSH
84087: LD_INT 11
84089: PUSH
84090: LD_INT 12
84092: PUSH
84093: LD_INT 14
84095: PUSH
84096: LD_INT 15
84098: PUSH
84099: LD_INT 16
84101: PUSH
84102: LD_INT 17
84104: PUSH
84105: LD_INT 18
84107: PUSH
84108: LD_INT 19
84110: PUSH
84111: LD_INT 20
84113: PUSH
84114: LD_INT 21
84116: PUSH
84117: LD_INT 22
84119: PUSH
84120: LD_INT 23
84122: PUSH
84123: LD_INT 24
84125: PUSH
84126: LD_INT 25
84128: PUSH
84129: LD_INT 26
84131: PUSH
84132: LD_INT 27
84134: PUSH
84135: LD_INT 28
84137: PUSH
84138: LD_INT 30
84140: PUSH
84141: LD_INT 31
84143: PUSH
84144: LD_INT 32
84146: PUSH
84147: LD_INT 33
84149: PUSH
84150: LD_INT 34
84152: PUSH
84153: LD_INT 36
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: LIST
84178: LIST
84179: LIST
84180: LIST
84181: LIST
84182: LIST
84183: LIST
84184: LIST
84185: LIST
84186: LIST
84187: LIST
84188: PUSH
84189: LD_INT 101
84191: PUSH
84192: LD_INT 102
84194: PUSH
84195: LD_INT 103
84197: PUSH
84198: LD_INT 104
84200: PUSH
84201: LD_INT 105
84203: PUSH
84204: LD_INT 106
84206: PUSH
84207: LD_INT 107
84209: PUSH
84210: LD_INT 108
84212: PUSH
84213: LD_INT 109
84215: PUSH
84216: LD_INT 110
84218: PUSH
84219: LD_INT 111
84221: PUSH
84222: LD_INT 112
84224: PUSH
84225: LD_INT 113
84227: PUSH
84228: LD_INT 114
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: ST_TO_ADDR
84251: GO 85418
84253: LD_INT 14
84255: DOUBLE
84256: EQUAL
84257: IFTRUE 84261
84259: GO 84473
84261: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
84262: LD_ADDR_VAR 0 1
84266: PUSH
84267: LD_INT 1
84269: PUSH
84270: LD_INT 2
84272: PUSH
84273: LD_INT 3
84275: PUSH
84276: LD_INT 4
84278: PUSH
84279: LD_INT 5
84281: PUSH
84282: LD_INT 6
84284: PUSH
84285: LD_INT 7
84287: PUSH
84288: LD_INT 8
84290: PUSH
84291: LD_INT 9
84293: PUSH
84294: LD_INT 10
84296: PUSH
84297: LD_INT 11
84299: PUSH
84300: LD_INT 12
84302: PUSH
84303: LD_INT 13
84305: PUSH
84306: LD_INT 14
84308: PUSH
84309: LD_INT 15
84311: PUSH
84312: LD_INT 16
84314: PUSH
84315: LD_INT 17
84317: PUSH
84318: LD_INT 18
84320: PUSH
84321: LD_INT 19
84323: PUSH
84324: LD_INT 20
84326: PUSH
84327: LD_INT 21
84329: PUSH
84330: LD_INT 22
84332: PUSH
84333: LD_INT 23
84335: PUSH
84336: LD_INT 24
84338: PUSH
84339: LD_INT 25
84341: PUSH
84342: LD_INT 26
84344: PUSH
84345: LD_INT 27
84347: PUSH
84348: LD_INT 28
84350: PUSH
84351: LD_INT 29
84353: PUSH
84354: LD_INT 30
84356: PUSH
84357: LD_INT 31
84359: PUSH
84360: LD_INT 32
84362: PUSH
84363: LD_INT 33
84365: PUSH
84366: LD_INT 34
84368: PUSH
84369: LD_INT 36
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 101
84411: PUSH
84412: LD_INT 102
84414: PUSH
84415: LD_INT 103
84417: PUSH
84418: LD_INT 104
84420: PUSH
84421: LD_INT 105
84423: PUSH
84424: LD_INT 106
84426: PUSH
84427: LD_INT 107
84429: PUSH
84430: LD_INT 108
84432: PUSH
84433: LD_INT 109
84435: PUSH
84436: LD_INT 110
84438: PUSH
84439: LD_INT 111
84441: PUSH
84442: LD_INT 112
84444: PUSH
84445: LD_INT 113
84447: PUSH
84448: LD_INT 114
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: LIST
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: PUSH
84467: EMPTY
84468: LIST
84469: LIST
84470: ST_TO_ADDR
84471: GO 85418
84473: LD_INT 15
84475: DOUBLE
84476: EQUAL
84477: IFTRUE 84481
84479: GO 84693
84481: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
84482: LD_ADDR_VAR 0 1
84486: PUSH
84487: LD_INT 1
84489: PUSH
84490: LD_INT 2
84492: PUSH
84493: LD_INT 3
84495: PUSH
84496: LD_INT 4
84498: PUSH
84499: LD_INT 5
84501: PUSH
84502: LD_INT 6
84504: PUSH
84505: LD_INT 7
84507: PUSH
84508: LD_INT 8
84510: PUSH
84511: LD_INT 9
84513: PUSH
84514: LD_INT 10
84516: PUSH
84517: LD_INT 11
84519: PUSH
84520: LD_INT 12
84522: PUSH
84523: LD_INT 13
84525: PUSH
84526: LD_INT 14
84528: PUSH
84529: LD_INT 15
84531: PUSH
84532: LD_INT 16
84534: PUSH
84535: LD_INT 17
84537: PUSH
84538: LD_INT 18
84540: PUSH
84541: LD_INT 19
84543: PUSH
84544: LD_INT 20
84546: PUSH
84547: LD_INT 21
84549: PUSH
84550: LD_INT 22
84552: PUSH
84553: LD_INT 23
84555: PUSH
84556: LD_INT 24
84558: PUSH
84559: LD_INT 25
84561: PUSH
84562: LD_INT 26
84564: PUSH
84565: LD_INT 27
84567: PUSH
84568: LD_INT 28
84570: PUSH
84571: LD_INT 29
84573: PUSH
84574: LD_INT 30
84576: PUSH
84577: LD_INT 31
84579: PUSH
84580: LD_INT 32
84582: PUSH
84583: LD_INT 33
84585: PUSH
84586: LD_INT 34
84588: PUSH
84589: LD_INT 36
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: LIST
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: LIST
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 101
84631: PUSH
84632: LD_INT 102
84634: PUSH
84635: LD_INT 103
84637: PUSH
84638: LD_INT 104
84640: PUSH
84641: LD_INT 105
84643: PUSH
84644: LD_INT 106
84646: PUSH
84647: LD_INT 107
84649: PUSH
84650: LD_INT 108
84652: PUSH
84653: LD_INT 109
84655: PUSH
84656: LD_INT 110
84658: PUSH
84659: LD_INT 111
84661: PUSH
84662: LD_INT 112
84664: PUSH
84665: LD_INT 113
84667: PUSH
84668: LD_INT 114
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: ST_TO_ADDR
84691: GO 85418
84693: LD_INT 16
84695: DOUBLE
84696: EQUAL
84697: IFTRUE 84701
84699: GO 84825
84701: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
84702: LD_ADDR_VAR 0 1
84706: PUSH
84707: LD_INT 2
84709: PUSH
84710: LD_INT 4
84712: PUSH
84713: LD_INT 5
84715: PUSH
84716: LD_INT 7
84718: PUSH
84719: LD_INT 11
84721: PUSH
84722: LD_INT 12
84724: PUSH
84725: LD_INT 15
84727: PUSH
84728: LD_INT 16
84730: PUSH
84731: LD_INT 20
84733: PUSH
84734: LD_INT 21
84736: PUSH
84737: LD_INT 22
84739: PUSH
84740: LD_INT 23
84742: PUSH
84743: LD_INT 25
84745: PUSH
84746: LD_INT 26
84748: PUSH
84749: LD_INT 30
84751: PUSH
84752: LD_INT 31
84754: PUSH
84755: LD_INT 32
84757: PUSH
84758: LD_INT 33
84760: PUSH
84761: LD_INT 34
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 101
84787: PUSH
84788: LD_INT 102
84790: PUSH
84791: LD_INT 103
84793: PUSH
84794: LD_INT 106
84796: PUSH
84797: LD_INT 108
84799: PUSH
84800: LD_INT 112
84802: PUSH
84803: LD_INT 113
84805: PUSH
84806: LD_INT 114
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: PUSH
84819: EMPTY
84820: LIST
84821: LIST
84822: ST_TO_ADDR
84823: GO 85418
84825: LD_INT 17
84827: DOUBLE
84828: EQUAL
84829: IFTRUE 84833
84831: GO 85045
84833: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
84834: LD_ADDR_VAR 0 1
84838: PUSH
84839: LD_INT 1
84841: PUSH
84842: LD_INT 2
84844: PUSH
84845: LD_INT 3
84847: PUSH
84848: LD_INT 4
84850: PUSH
84851: LD_INT 5
84853: PUSH
84854: LD_INT 6
84856: PUSH
84857: LD_INT 7
84859: PUSH
84860: LD_INT 8
84862: PUSH
84863: LD_INT 9
84865: PUSH
84866: LD_INT 10
84868: PUSH
84869: LD_INT 11
84871: PUSH
84872: LD_INT 12
84874: PUSH
84875: LD_INT 13
84877: PUSH
84878: LD_INT 14
84880: PUSH
84881: LD_INT 15
84883: PUSH
84884: LD_INT 16
84886: PUSH
84887: LD_INT 17
84889: PUSH
84890: LD_INT 18
84892: PUSH
84893: LD_INT 19
84895: PUSH
84896: LD_INT 20
84898: PUSH
84899: LD_INT 21
84901: PUSH
84902: LD_INT 22
84904: PUSH
84905: LD_INT 23
84907: PUSH
84908: LD_INT 24
84910: PUSH
84911: LD_INT 25
84913: PUSH
84914: LD_INT 26
84916: PUSH
84917: LD_INT 27
84919: PUSH
84920: LD_INT 28
84922: PUSH
84923: LD_INT 29
84925: PUSH
84926: LD_INT 30
84928: PUSH
84929: LD_INT 31
84931: PUSH
84932: LD_INT 32
84934: PUSH
84935: LD_INT 33
84937: PUSH
84938: LD_INT 34
84940: PUSH
84941: LD_INT 36
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: PUSH
84981: LD_INT 101
84983: PUSH
84984: LD_INT 102
84986: PUSH
84987: LD_INT 103
84989: PUSH
84990: LD_INT 104
84992: PUSH
84993: LD_INT 105
84995: PUSH
84996: LD_INT 106
84998: PUSH
84999: LD_INT 107
85001: PUSH
85002: LD_INT 108
85004: PUSH
85005: LD_INT 109
85007: PUSH
85008: LD_INT 110
85010: PUSH
85011: LD_INT 111
85013: PUSH
85014: LD_INT 112
85016: PUSH
85017: LD_INT 113
85019: PUSH
85020: LD_INT 114
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: LIST
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: ST_TO_ADDR
85043: GO 85418
85045: LD_INT 18
85047: DOUBLE
85048: EQUAL
85049: IFTRUE 85053
85051: GO 85189
85053: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
85054: LD_ADDR_VAR 0 1
85058: PUSH
85059: LD_INT 2
85061: PUSH
85062: LD_INT 4
85064: PUSH
85065: LD_INT 5
85067: PUSH
85068: LD_INT 7
85070: PUSH
85071: LD_INT 11
85073: PUSH
85074: LD_INT 12
85076: PUSH
85077: LD_INT 15
85079: PUSH
85080: LD_INT 16
85082: PUSH
85083: LD_INT 20
85085: PUSH
85086: LD_INT 21
85088: PUSH
85089: LD_INT 22
85091: PUSH
85092: LD_INT 23
85094: PUSH
85095: LD_INT 25
85097: PUSH
85098: LD_INT 26
85100: PUSH
85101: LD_INT 30
85103: PUSH
85104: LD_INT 31
85106: PUSH
85107: LD_INT 32
85109: PUSH
85110: LD_INT 33
85112: PUSH
85113: LD_INT 34
85115: PUSH
85116: LD_INT 35
85118: PUSH
85119: LD_INT 36
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 101
85147: PUSH
85148: LD_INT 102
85150: PUSH
85151: LD_INT 103
85153: PUSH
85154: LD_INT 106
85156: PUSH
85157: LD_INT 108
85159: PUSH
85160: LD_INT 112
85162: PUSH
85163: LD_INT 113
85165: PUSH
85166: LD_INT 114
85168: PUSH
85169: LD_INT 115
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: PUSH
85183: EMPTY
85184: LIST
85185: LIST
85186: ST_TO_ADDR
85187: GO 85418
85189: LD_INT 19
85191: DOUBLE
85192: EQUAL
85193: IFTRUE 85197
85195: GO 85417
85197: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
85198: LD_ADDR_VAR 0 1
85202: PUSH
85203: LD_INT 1
85205: PUSH
85206: LD_INT 2
85208: PUSH
85209: LD_INT 3
85211: PUSH
85212: LD_INT 4
85214: PUSH
85215: LD_INT 5
85217: PUSH
85218: LD_INT 6
85220: PUSH
85221: LD_INT 7
85223: PUSH
85224: LD_INT 8
85226: PUSH
85227: LD_INT 9
85229: PUSH
85230: LD_INT 10
85232: PUSH
85233: LD_INT 11
85235: PUSH
85236: LD_INT 12
85238: PUSH
85239: LD_INT 13
85241: PUSH
85242: LD_INT 14
85244: PUSH
85245: LD_INT 15
85247: PUSH
85248: LD_INT 16
85250: PUSH
85251: LD_INT 17
85253: PUSH
85254: LD_INT 18
85256: PUSH
85257: LD_INT 19
85259: PUSH
85260: LD_INT 20
85262: PUSH
85263: LD_INT 21
85265: PUSH
85266: LD_INT 22
85268: PUSH
85269: LD_INT 23
85271: PUSH
85272: LD_INT 24
85274: PUSH
85275: LD_INT 25
85277: PUSH
85278: LD_INT 26
85280: PUSH
85281: LD_INT 27
85283: PUSH
85284: LD_INT 28
85286: PUSH
85287: LD_INT 29
85289: PUSH
85290: LD_INT 30
85292: PUSH
85293: LD_INT 31
85295: PUSH
85296: LD_INT 32
85298: PUSH
85299: LD_INT 33
85301: PUSH
85302: LD_INT 34
85304: PUSH
85305: LD_INT 35
85307: PUSH
85308: LD_INT 36
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 101
85351: PUSH
85352: LD_INT 102
85354: PUSH
85355: LD_INT 103
85357: PUSH
85358: LD_INT 104
85360: PUSH
85361: LD_INT 105
85363: PUSH
85364: LD_INT 106
85366: PUSH
85367: LD_INT 107
85369: PUSH
85370: LD_INT 108
85372: PUSH
85373: LD_INT 109
85375: PUSH
85376: LD_INT 110
85378: PUSH
85379: LD_INT 111
85381: PUSH
85382: LD_INT 112
85384: PUSH
85385: LD_INT 113
85387: PUSH
85388: LD_INT 114
85390: PUSH
85391: LD_INT 115
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: PUSH
85411: EMPTY
85412: LIST
85413: LIST
85414: ST_TO_ADDR
85415: GO 85418
85417: POP
// end else
85418: GO 85637
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
85420: LD_ADDR_VAR 0 1
85424: PUSH
85425: LD_INT 1
85427: PUSH
85428: LD_INT 2
85430: PUSH
85431: LD_INT 3
85433: PUSH
85434: LD_INT 4
85436: PUSH
85437: LD_INT 5
85439: PUSH
85440: LD_INT 6
85442: PUSH
85443: LD_INT 7
85445: PUSH
85446: LD_INT 8
85448: PUSH
85449: LD_INT 9
85451: PUSH
85452: LD_INT 10
85454: PUSH
85455: LD_INT 11
85457: PUSH
85458: LD_INT 12
85460: PUSH
85461: LD_INT 13
85463: PUSH
85464: LD_INT 14
85466: PUSH
85467: LD_INT 15
85469: PUSH
85470: LD_INT 16
85472: PUSH
85473: LD_INT 17
85475: PUSH
85476: LD_INT 18
85478: PUSH
85479: LD_INT 19
85481: PUSH
85482: LD_INT 20
85484: PUSH
85485: LD_INT 21
85487: PUSH
85488: LD_INT 22
85490: PUSH
85491: LD_INT 23
85493: PUSH
85494: LD_INT 24
85496: PUSH
85497: LD_INT 25
85499: PUSH
85500: LD_INT 26
85502: PUSH
85503: LD_INT 27
85505: PUSH
85506: LD_INT 28
85508: PUSH
85509: LD_INT 29
85511: PUSH
85512: LD_INT 30
85514: PUSH
85515: LD_INT 31
85517: PUSH
85518: LD_INT 32
85520: PUSH
85521: LD_INT 33
85523: PUSH
85524: LD_INT 34
85526: PUSH
85527: LD_INT 35
85529: PUSH
85530: LD_INT 36
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: PUSH
85571: LD_INT 101
85573: PUSH
85574: LD_INT 102
85576: PUSH
85577: LD_INT 103
85579: PUSH
85580: LD_INT 104
85582: PUSH
85583: LD_INT 105
85585: PUSH
85586: LD_INT 106
85588: PUSH
85589: LD_INT 107
85591: PUSH
85592: LD_INT 108
85594: PUSH
85595: LD_INT 109
85597: PUSH
85598: LD_INT 110
85600: PUSH
85601: LD_INT 111
85603: PUSH
85604: LD_INT 112
85606: PUSH
85607: LD_INT 113
85609: PUSH
85610: LD_INT 114
85612: PUSH
85613: LD_INT 115
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: ST_TO_ADDR
// if result then
85637: LD_VAR 0 1
85641: IFFALSE 85930
// begin normal :=  ;
85643: LD_ADDR_VAR 0 3
85647: PUSH
85648: LD_STRING 
85650: ST_TO_ADDR
// hardcore :=  ;
85651: LD_ADDR_VAR 0 4
85655: PUSH
85656: LD_STRING 
85658: ST_TO_ADDR
// for i = 1 to normalCounter do
85659: LD_ADDR_VAR 0 5
85663: PUSH
85664: DOUBLE
85665: LD_INT 1
85667: DEC
85668: ST_TO_ADDR
85669: LD_EXP 110
85673: PUSH
85674: FOR_TO
85675: IFFALSE 85776
// begin tmp := 0 ;
85677: LD_ADDR_VAR 0 2
85681: PUSH
85682: LD_STRING 0
85684: ST_TO_ADDR
// if result [ 1 ] then
85685: LD_VAR 0 1
85689: PUSH
85690: LD_INT 1
85692: ARRAY
85693: IFFALSE 85758
// if result [ 1 ] [ 1 ] = i then
85695: LD_VAR 0 1
85699: PUSH
85700: LD_INT 1
85702: ARRAY
85703: PUSH
85704: LD_INT 1
85706: ARRAY
85707: PUSH
85708: LD_VAR 0 5
85712: EQUAL
85713: IFFALSE 85758
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
85715: LD_ADDR_VAR 0 1
85719: PUSH
85720: LD_VAR 0 1
85724: PPUSH
85725: LD_INT 1
85727: PPUSH
85728: LD_VAR 0 1
85732: PUSH
85733: LD_INT 1
85735: ARRAY
85736: PPUSH
85737: LD_INT 1
85739: PPUSH
85740: CALL_OW 3
85744: PPUSH
85745: CALL_OW 1
85749: ST_TO_ADDR
// tmp := 1 ;
85750: LD_ADDR_VAR 0 2
85754: PUSH
85755: LD_STRING 1
85757: ST_TO_ADDR
// end ; normal := normal & tmp ;
85758: LD_ADDR_VAR 0 3
85762: PUSH
85763: LD_VAR 0 3
85767: PUSH
85768: LD_VAR 0 2
85772: STR
85773: ST_TO_ADDR
// end ;
85774: GO 85674
85776: POP
85777: POP
// for i = 1 to hardcoreCounter do
85778: LD_ADDR_VAR 0 5
85782: PUSH
85783: DOUBLE
85784: LD_INT 1
85786: DEC
85787: ST_TO_ADDR
85788: LD_EXP 111
85792: PUSH
85793: FOR_TO
85794: IFFALSE 85899
// begin tmp := 0 ;
85796: LD_ADDR_VAR 0 2
85800: PUSH
85801: LD_STRING 0
85803: ST_TO_ADDR
// if result [ 2 ] then
85804: LD_VAR 0 1
85808: PUSH
85809: LD_INT 2
85811: ARRAY
85812: IFFALSE 85881
// if result [ 2 ] [ 1 ] = 100 + i then
85814: LD_VAR 0 1
85818: PUSH
85819: LD_INT 2
85821: ARRAY
85822: PUSH
85823: LD_INT 1
85825: ARRAY
85826: PUSH
85827: LD_INT 100
85829: PUSH
85830: LD_VAR 0 5
85834: PLUS
85835: EQUAL
85836: IFFALSE 85881
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
85838: LD_ADDR_VAR 0 1
85842: PUSH
85843: LD_VAR 0 1
85847: PPUSH
85848: LD_INT 2
85850: PPUSH
85851: LD_VAR 0 1
85855: PUSH
85856: LD_INT 2
85858: ARRAY
85859: PPUSH
85860: LD_INT 1
85862: PPUSH
85863: CALL_OW 3
85867: PPUSH
85868: CALL_OW 1
85872: ST_TO_ADDR
// tmp := 1 ;
85873: LD_ADDR_VAR 0 2
85877: PUSH
85878: LD_STRING 1
85880: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
85881: LD_ADDR_VAR 0 4
85885: PUSH
85886: LD_VAR 0 4
85890: PUSH
85891: LD_VAR 0 2
85895: STR
85896: ST_TO_ADDR
// end ;
85897: GO 85793
85899: POP
85900: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
85901: LD_STRING getStreamItemsFromMission("
85903: PUSH
85904: LD_VAR 0 3
85908: STR
85909: PUSH
85910: LD_STRING ","
85912: STR
85913: PUSH
85914: LD_VAR 0 4
85918: STR
85919: PUSH
85920: LD_STRING ")
85922: STR
85923: PPUSH
85924: CALL_OW 559
// end else
85928: GO 85937
// ToLua ( getStreamItemsFromMission("","") ) ;
85930: LD_STRING getStreamItemsFromMission("","")
85932: PPUSH
85933: CALL_OW 559
// end ;
85937: LD_VAR 0 1
85941: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
85942: LD_EXP 109
85946: PUSH
85947: LD_EXP 114
85951: AND
85952: IFFALSE 86076
85954: GO 85956
85956: DISABLE
85957: LD_INT 0
85959: PPUSH
85960: PPUSH
// begin enable ;
85961: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
85962: LD_ADDR_VAR 0 2
85966: PUSH
85967: LD_INT 22
85969: PUSH
85970: LD_OWVAR 2
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: LD_INT 2
85981: PUSH
85982: LD_INT 34
85984: PUSH
85985: LD_INT 7
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 34
85994: PUSH
85995: LD_INT 45
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PUSH
86002: LD_INT 34
86004: PUSH
86005: LD_INT 28
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 34
86014: PUSH
86015: LD_INT 47
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PPUSH
86033: CALL_OW 69
86037: ST_TO_ADDR
// if not tmp then
86038: LD_VAR 0 2
86042: NOT
86043: IFFALSE 86047
// exit ;
86045: GO 86076
// for i in tmp do
86047: LD_ADDR_VAR 0 1
86051: PUSH
86052: LD_VAR 0 2
86056: PUSH
86057: FOR_IN
86058: IFFALSE 86074
// begin SetLives ( i , 0 ) ;
86060: LD_VAR 0 1
86064: PPUSH
86065: LD_INT 0
86067: PPUSH
86068: CALL_OW 234
// end ;
86072: GO 86057
86074: POP
86075: POP
// end ;
86076: PPOPN 2
86078: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
86079: LD_EXP 109
86083: PUSH
86084: LD_EXP 115
86088: AND
86089: IFFALSE 86173
86091: GO 86093
86093: DISABLE
86094: LD_INT 0
86096: PPUSH
86097: PPUSH
// begin enable ;
86098: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
86099: LD_ADDR_VAR 0 2
86103: PUSH
86104: LD_INT 22
86106: PUSH
86107: LD_OWVAR 2
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 32
86118: PUSH
86119: LD_INT 3
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PPUSH
86130: CALL_OW 69
86134: ST_TO_ADDR
// if not tmp then
86135: LD_VAR 0 2
86139: NOT
86140: IFFALSE 86144
// exit ;
86142: GO 86173
// for i in tmp do
86144: LD_ADDR_VAR 0 1
86148: PUSH
86149: LD_VAR 0 2
86153: PUSH
86154: FOR_IN
86155: IFFALSE 86171
// begin SetLives ( i , 0 ) ;
86157: LD_VAR 0 1
86161: PPUSH
86162: LD_INT 0
86164: PPUSH
86165: CALL_OW 234
// end ;
86169: GO 86154
86171: POP
86172: POP
// end ;
86173: PPOPN 2
86175: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
86176: LD_EXP 109
86180: PUSH
86181: LD_EXP 112
86185: AND
86186: IFFALSE 86279
86188: GO 86190
86190: DISABLE
86191: LD_INT 0
86193: PPUSH
// begin enable ;
86194: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
86195: LD_ADDR_VAR 0 1
86199: PUSH
86200: LD_INT 22
86202: PUSH
86203: LD_OWVAR 2
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 2
86214: PUSH
86215: LD_INT 25
86217: PUSH
86218: LD_INT 5
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 25
86227: PUSH
86228: LD_INT 9
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 25
86237: PUSH
86238: LD_INT 8
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PPUSH
86255: CALL_OW 69
86259: PUSH
86260: FOR_IN
86261: IFFALSE 86277
// begin SetClass ( i , 1 ) ;
86263: LD_VAR 0 1
86267: PPUSH
86268: LD_INT 1
86270: PPUSH
86271: CALL_OW 336
// end ;
86275: GO 86260
86277: POP
86278: POP
// end ;
86279: PPOPN 1
86281: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
86282: LD_EXP 109
86286: PUSH
86287: LD_EXP 113
86291: AND
86292: PUSH
86293: LD_OWVAR 65
86297: PUSH
86298: LD_INT 7
86300: LESS
86301: AND
86302: IFFALSE 86316
86304: GO 86306
86306: DISABLE
// begin enable ;
86307: ENABLE
// game_speed := 7 ;
86308: LD_ADDR_OWVAR 65
86312: PUSH
86313: LD_INT 7
86315: ST_TO_ADDR
// end ;
86316: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
86317: LD_EXP 109
86321: PUSH
86322: LD_EXP 116
86326: AND
86327: IFFALSE 86529
86329: GO 86331
86331: DISABLE
86332: LD_INT 0
86334: PPUSH
86335: PPUSH
86336: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
86337: LD_ADDR_VAR 0 3
86341: PUSH
86342: LD_INT 81
86344: PUSH
86345: LD_OWVAR 2
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 21
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: EMPTY
86361: LIST
86362: LIST
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PPUSH
86368: CALL_OW 69
86372: ST_TO_ADDR
// if not tmp then
86373: LD_VAR 0 3
86377: NOT
86378: IFFALSE 86382
// exit ;
86380: GO 86529
// if tmp > 5 then
86382: LD_VAR 0 3
86386: PUSH
86387: LD_INT 5
86389: GREATER
86390: IFFALSE 86402
// k := 5 else
86392: LD_ADDR_VAR 0 2
86396: PUSH
86397: LD_INT 5
86399: ST_TO_ADDR
86400: GO 86412
// k := tmp ;
86402: LD_ADDR_VAR 0 2
86406: PUSH
86407: LD_VAR 0 3
86411: ST_TO_ADDR
// for i := 1 to k do
86412: LD_ADDR_VAR 0 1
86416: PUSH
86417: DOUBLE
86418: LD_INT 1
86420: DEC
86421: ST_TO_ADDR
86422: LD_VAR 0 2
86426: PUSH
86427: FOR_TO
86428: IFFALSE 86527
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
86430: LD_VAR 0 3
86434: PUSH
86435: LD_VAR 0 1
86439: ARRAY
86440: PPUSH
86441: LD_VAR 0 1
86445: PUSH
86446: LD_INT 4
86448: MOD
86449: PUSH
86450: LD_INT 1
86452: PLUS
86453: PPUSH
86454: CALL_OW 259
86458: PUSH
86459: LD_INT 10
86461: LESS
86462: IFFALSE 86525
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
86464: LD_VAR 0 3
86468: PUSH
86469: LD_VAR 0 1
86473: ARRAY
86474: PPUSH
86475: LD_VAR 0 1
86479: PUSH
86480: LD_INT 4
86482: MOD
86483: PUSH
86484: LD_INT 1
86486: PLUS
86487: PPUSH
86488: LD_VAR 0 3
86492: PUSH
86493: LD_VAR 0 1
86497: ARRAY
86498: PPUSH
86499: LD_VAR 0 1
86503: PUSH
86504: LD_INT 4
86506: MOD
86507: PUSH
86508: LD_INT 1
86510: PLUS
86511: PPUSH
86512: CALL_OW 259
86516: PUSH
86517: LD_INT 1
86519: PLUS
86520: PPUSH
86521: CALL_OW 237
86525: GO 86427
86527: POP
86528: POP
// end ;
86529: PPOPN 3
86531: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
86532: LD_EXP 109
86536: PUSH
86537: LD_EXP 117
86541: AND
86542: IFFALSE 86562
86544: GO 86546
86546: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
86547: LD_INT 4
86549: PPUSH
86550: LD_OWVAR 2
86554: PPUSH
86555: LD_INT 0
86557: PPUSH
86558: CALL_OW 324
86562: END
// every 0 0$1 trigger StreamModeActive and sShovel do
86563: LD_EXP 109
86567: PUSH
86568: LD_EXP 146
86572: AND
86573: IFFALSE 86593
86575: GO 86577
86577: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
86578: LD_INT 19
86580: PPUSH
86581: LD_OWVAR 2
86585: PPUSH
86586: LD_INT 0
86588: PPUSH
86589: CALL_OW 324
86593: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
86594: LD_EXP 109
86598: PUSH
86599: LD_EXP 118
86603: AND
86604: IFFALSE 86706
86606: GO 86608
86608: DISABLE
86609: LD_INT 0
86611: PPUSH
86612: PPUSH
// begin enable ;
86613: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
86614: LD_ADDR_VAR 0 2
86618: PUSH
86619: LD_INT 22
86621: PUSH
86622: LD_OWVAR 2
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: PUSH
86631: LD_INT 2
86633: PUSH
86634: LD_INT 34
86636: PUSH
86637: LD_INT 11
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 34
86646: PUSH
86647: LD_INT 30
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: LIST
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PPUSH
86663: CALL_OW 69
86667: ST_TO_ADDR
// if not tmp then
86668: LD_VAR 0 2
86672: NOT
86673: IFFALSE 86677
// exit ;
86675: GO 86706
// for i in tmp do
86677: LD_ADDR_VAR 0 1
86681: PUSH
86682: LD_VAR 0 2
86686: PUSH
86687: FOR_IN
86688: IFFALSE 86704
// begin SetLives ( i , 0 ) ;
86690: LD_VAR 0 1
86694: PPUSH
86695: LD_INT 0
86697: PPUSH
86698: CALL_OW 234
// end ;
86702: GO 86687
86704: POP
86705: POP
// end ;
86706: PPOPN 2
86708: END
// every 0 0$1 trigger StreamModeActive and sBunker do
86709: LD_EXP 109
86713: PUSH
86714: LD_EXP 119
86718: AND
86719: IFFALSE 86739
86721: GO 86723
86723: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
86724: LD_INT 32
86726: PPUSH
86727: LD_OWVAR 2
86731: PPUSH
86732: LD_INT 0
86734: PPUSH
86735: CALL_OW 324
86739: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
86740: LD_EXP 109
86744: PUSH
86745: LD_EXP 120
86749: AND
86750: IFFALSE 86931
86752: GO 86754
86754: DISABLE
86755: LD_INT 0
86757: PPUSH
86758: PPUSH
86759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
86760: LD_ADDR_VAR 0 2
86764: PUSH
86765: LD_INT 22
86767: PUSH
86768: LD_OWVAR 2
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PUSH
86777: LD_INT 33
86779: PUSH
86780: LD_INT 3
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PPUSH
86791: CALL_OW 69
86795: ST_TO_ADDR
// if not tmp then
86796: LD_VAR 0 2
86800: NOT
86801: IFFALSE 86805
// exit ;
86803: GO 86931
// side := 0 ;
86805: LD_ADDR_VAR 0 3
86809: PUSH
86810: LD_INT 0
86812: ST_TO_ADDR
// for i := 1 to 8 do
86813: LD_ADDR_VAR 0 1
86817: PUSH
86818: DOUBLE
86819: LD_INT 1
86821: DEC
86822: ST_TO_ADDR
86823: LD_INT 8
86825: PUSH
86826: FOR_TO
86827: IFFALSE 86875
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
86829: LD_OWVAR 2
86833: PUSH
86834: LD_VAR 0 1
86838: NONEQUAL
86839: PUSH
86840: LD_OWVAR 2
86844: PPUSH
86845: LD_VAR 0 1
86849: PPUSH
86850: CALL_OW 81
86854: PUSH
86855: LD_INT 2
86857: EQUAL
86858: AND
86859: IFFALSE 86873
// begin side := i ;
86861: LD_ADDR_VAR 0 3
86865: PUSH
86866: LD_VAR 0 1
86870: ST_TO_ADDR
// break ;
86871: GO 86875
// end ;
86873: GO 86826
86875: POP
86876: POP
// if not side then
86877: LD_VAR 0 3
86881: NOT
86882: IFFALSE 86886
// exit ;
86884: GO 86931
// for i := 1 to tmp do
86886: LD_ADDR_VAR 0 1
86890: PUSH
86891: DOUBLE
86892: LD_INT 1
86894: DEC
86895: ST_TO_ADDR
86896: LD_VAR 0 2
86900: PUSH
86901: FOR_TO
86902: IFFALSE 86929
// if Prob ( 60 ) then
86904: LD_INT 60
86906: PPUSH
86907: CALL_OW 13
86911: IFFALSE 86927
// SetSide ( i , side ) ;
86913: LD_VAR 0 1
86917: PPUSH
86918: LD_VAR 0 3
86922: PPUSH
86923: CALL_OW 235
86927: GO 86901
86929: POP
86930: POP
// end ;
86931: PPOPN 3
86933: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
86934: LD_EXP 109
86938: PUSH
86939: LD_EXP 122
86943: AND
86944: IFFALSE 87063
86946: GO 86948
86948: DISABLE
86949: LD_INT 0
86951: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
86952: LD_ADDR_VAR 0 1
86956: PUSH
86957: LD_INT 22
86959: PUSH
86960: LD_OWVAR 2
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 21
86971: PUSH
86972: LD_INT 1
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 3
86981: PUSH
86982: LD_INT 23
86984: PUSH
86985: LD_INT 0
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: LIST
87000: PPUSH
87001: CALL_OW 69
87005: PUSH
87006: FOR_IN
87007: IFFALSE 87061
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
87009: LD_VAR 0 1
87013: PPUSH
87014: CALL_OW 257
87018: PUSH
87019: LD_INT 1
87021: PUSH
87022: LD_INT 2
87024: PUSH
87025: LD_INT 3
87027: PUSH
87028: LD_INT 4
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: IN
87037: IFFALSE 87059
// SetClass ( un , rand ( 1 , 4 ) ) ;
87039: LD_VAR 0 1
87043: PPUSH
87044: LD_INT 1
87046: PPUSH
87047: LD_INT 4
87049: PPUSH
87050: CALL_OW 12
87054: PPUSH
87055: CALL_OW 336
87059: GO 87006
87061: POP
87062: POP
// end ;
87063: PPOPN 1
87065: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
87066: LD_EXP 109
87070: PUSH
87071: LD_EXP 121
87075: AND
87076: IFFALSE 87155
87078: GO 87080
87080: DISABLE
87081: LD_INT 0
87083: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87084: LD_ADDR_VAR 0 1
87088: PUSH
87089: LD_INT 22
87091: PUSH
87092: LD_OWVAR 2
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 21
87103: PUSH
87104: LD_INT 3
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PPUSH
87115: CALL_OW 69
87119: ST_TO_ADDR
// if not tmp then
87120: LD_VAR 0 1
87124: NOT
87125: IFFALSE 87129
// exit ;
87127: GO 87155
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
87129: LD_VAR 0 1
87133: PUSH
87134: LD_INT 1
87136: PPUSH
87137: LD_VAR 0 1
87141: PPUSH
87142: CALL_OW 12
87146: ARRAY
87147: PPUSH
87148: LD_INT 100
87150: PPUSH
87151: CALL_OW 234
// end ;
87155: PPOPN 1
87157: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
87158: LD_EXP 109
87162: PUSH
87163: LD_EXP 123
87167: AND
87168: IFFALSE 87266
87170: GO 87172
87172: DISABLE
87173: LD_INT 0
87175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
87176: LD_ADDR_VAR 0 1
87180: PUSH
87181: LD_INT 22
87183: PUSH
87184: LD_OWVAR 2
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: PUSH
87193: LD_INT 21
87195: PUSH
87196: LD_INT 1
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PPUSH
87207: CALL_OW 69
87211: ST_TO_ADDR
// if not tmp then
87212: LD_VAR 0 1
87216: NOT
87217: IFFALSE 87221
// exit ;
87219: GO 87266
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
87221: LD_VAR 0 1
87225: PUSH
87226: LD_INT 1
87228: PPUSH
87229: LD_VAR 0 1
87233: PPUSH
87234: CALL_OW 12
87238: ARRAY
87239: PPUSH
87240: LD_INT 1
87242: PPUSH
87243: LD_INT 4
87245: PPUSH
87246: CALL_OW 12
87250: PPUSH
87251: LD_INT 3000
87253: PPUSH
87254: LD_INT 9000
87256: PPUSH
87257: CALL_OW 12
87261: PPUSH
87262: CALL_OW 492
// end ;
87266: PPOPN 1
87268: END
// every 0 0$1 trigger StreamModeActive and sDepot do
87269: LD_EXP 109
87273: PUSH
87274: LD_EXP 124
87278: AND
87279: IFFALSE 87299
87281: GO 87283
87283: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
87284: LD_INT 1
87286: PPUSH
87287: LD_OWVAR 2
87291: PPUSH
87292: LD_INT 0
87294: PPUSH
87295: CALL_OW 324
87299: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
87300: LD_EXP 109
87304: PUSH
87305: LD_EXP 125
87309: AND
87310: IFFALSE 87393
87312: GO 87314
87314: DISABLE
87315: LD_INT 0
87317: PPUSH
87318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87319: LD_ADDR_VAR 0 2
87323: PUSH
87324: LD_INT 22
87326: PUSH
87327: LD_OWVAR 2
87331: PUSH
87332: EMPTY
87333: LIST
87334: LIST
87335: PUSH
87336: LD_INT 21
87338: PUSH
87339: LD_INT 3
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PPUSH
87350: CALL_OW 69
87354: ST_TO_ADDR
// if not tmp then
87355: LD_VAR 0 2
87359: NOT
87360: IFFALSE 87364
// exit ;
87362: GO 87393
// for i in tmp do
87364: LD_ADDR_VAR 0 1
87368: PUSH
87369: LD_VAR 0 2
87373: PUSH
87374: FOR_IN
87375: IFFALSE 87391
// SetBLevel ( i , 10 ) ;
87377: LD_VAR 0 1
87381: PPUSH
87382: LD_INT 10
87384: PPUSH
87385: CALL_OW 241
87389: GO 87374
87391: POP
87392: POP
// end ;
87393: PPOPN 2
87395: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
87396: LD_EXP 109
87400: PUSH
87401: LD_EXP 126
87405: AND
87406: IFFALSE 87517
87408: GO 87410
87410: DISABLE
87411: LD_INT 0
87413: PPUSH
87414: PPUSH
87415: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
87416: LD_ADDR_VAR 0 3
87420: PUSH
87421: LD_INT 22
87423: PUSH
87424: LD_OWVAR 2
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 25
87435: PUSH
87436: LD_INT 1
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PPUSH
87447: CALL_OW 69
87451: ST_TO_ADDR
// if not tmp then
87452: LD_VAR 0 3
87456: NOT
87457: IFFALSE 87461
// exit ;
87459: GO 87517
// un := tmp [ rand ( 1 , tmp ) ] ;
87461: LD_ADDR_VAR 0 2
87465: PUSH
87466: LD_VAR 0 3
87470: PUSH
87471: LD_INT 1
87473: PPUSH
87474: LD_VAR 0 3
87478: PPUSH
87479: CALL_OW 12
87483: ARRAY
87484: ST_TO_ADDR
// if Crawls ( un ) then
87485: LD_VAR 0 2
87489: PPUSH
87490: CALL_OW 318
87494: IFFALSE 87505
// ComWalk ( un ) ;
87496: LD_VAR 0 2
87500: PPUSH
87501: CALL_OW 138
// SetClass ( un , class_sniper ) ;
87505: LD_VAR 0 2
87509: PPUSH
87510: LD_INT 5
87512: PPUSH
87513: CALL_OW 336
// end ;
87517: PPOPN 3
87519: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
87520: LD_EXP 109
87524: PUSH
87525: LD_EXP 127
87529: AND
87530: PUSH
87531: LD_OWVAR 67
87535: PUSH
87536: LD_INT 3
87538: LESS
87539: AND
87540: IFFALSE 87559
87542: GO 87544
87544: DISABLE
// Difficulty := Difficulty + 1 ;
87545: LD_ADDR_OWVAR 67
87549: PUSH
87550: LD_OWVAR 67
87554: PUSH
87555: LD_INT 1
87557: PLUS
87558: ST_TO_ADDR
87559: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
87560: LD_EXP 109
87564: PUSH
87565: LD_EXP 128
87569: AND
87570: IFFALSE 87673
87572: GO 87574
87574: DISABLE
87575: LD_INT 0
87577: PPUSH
// begin for i := 1 to 5 do
87578: LD_ADDR_VAR 0 1
87582: PUSH
87583: DOUBLE
87584: LD_INT 1
87586: DEC
87587: ST_TO_ADDR
87588: LD_INT 5
87590: PUSH
87591: FOR_TO
87592: IFFALSE 87671
// begin uc_nation := nation_nature ;
87594: LD_ADDR_OWVAR 21
87598: PUSH
87599: LD_INT 0
87601: ST_TO_ADDR
// uc_side := 0 ;
87602: LD_ADDR_OWVAR 20
87606: PUSH
87607: LD_INT 0
87609: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87610: LD_ADDR_OWVAR 29
87614: PUSH
87615: LD_INT 12
87617: PUSH
87618: LD_INT 12
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: ST_TO_ADDR
// hc_agressivity := 20 ;
87625: LD_ADDR_OWVAR 35
87629: PUSH
87630: LD_INT 20
87632: ST_TO_ADDR
// hc_class := class_tiger ;
87633: LD_ADDR_OWVAR 28
87637: PUSH
87638: LD_INT 14
87640: ST_TO_ADDR
// hc_gallery :=  ;
87641: LD_ADDR_OWVAR 33
87645: PUSH
87646: LD_STRING 
87648: ST_TO_ADDR
// hc_name :=  ;
87649: LD_ADDR_OWVAR 26
87653: PUSH
87654: LD_STRING 
87656: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
87657: CALL_OW 44
87661: PPUSH
87662: LD_INT 0
87664: PPUSH
87665: CALL_OW 51
// end ;
87669: GO 87591
87671: POP
87672: POP
// end ;
87673: PPOPN 1
87675: END
// every 0 0$1 trigger StreamModeActive and sBomb do
87676: LD_EXP 109
87680: PUSH
87681: LD_EXP 129
87685: AND
87686: IFFALSE 87695
87688: GO 87690
87690: DISABLE
// StreamSibBomb ;
87691: CALL 87696 0 0
87695: END
// export function StreamSibBomb ; var i , x , y ; begin
87696: LD_INT 0
87698: PPUSH
87699: PPUSH
87700: PPUSH
87701: PPUSH
// result := false ;
87702: LD_ADDR_VAR 0 1
87706: PUSH
87707: LD_INT 0
87709: ST_TO_ADDR
// for i := 1 to 16 do
87710: LD_ADDR_VAR 0 2
87714: PUSH
87715: DOUBLE
87716: LD_INT 1
87718: DEC
87719: ST_TO_ADDR
87720: LD_INT 16
87722: PUSH
87723: FOR_TO
87724: IFFALSE 87923
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87726: LD_ADDR_VAR 0 3
87730: PUSH
87731: LD_INT 10
87733: PUSH
87734: LD_INT 20
87736: PUSH
87737: LD_INT 30
87739: PUSH
87740: LD_INT 40
87742: PUSH
87743: LD_INT 50
87745: PUSH
87746: LD_INT 60
87748: PUSH
87749: LD_INT 70
87751: PUSH
87752: LD_INT 80
87754: PUSH
87755: LD_INT 90
87757: PUSH
87758: LD_INT 100
87760: PUSH
87761: LD_INT 110
87763: PUSH
87764: LD_INT 120
87766: PUSH
87767: LD_INT 130
87769: PUSH
87770: LD_INT 140
87772: PUSH
87773: LD_INT 150
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: PUSH
87793: LD_INT 1
87795: PPUSH
87796: LD_INT 15
87798: PPUSH
87799: CALL_OW 12
87803: ARRAY
87804: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87805: LD_ADDR_VAR 0 4
87809: PUSH
87810: LD_INT 10
87812: PUSH
87813: LD_INT 20
87815: PUSH
87816: LD_INT 30
87818: PUSH
87819: LD_INT 40
87821: PUSH
87822: LD_INT 50
87824: PUSH
87825: LD_INT 60
87827: PUSH
87828: LD_INT 70
87830: PUSH
87831: LD_INT 80
87833: PUSH
87834: LD_INT 90
87836: PUSH
87837: LD_INT 100
87839: PUSH
87840: LD_INT 110
87842: PUSH
87843: LD_INT 120
87845: PUSH
87846: LD_INT 130
87848: PUSH
87849: LD_INT 140
87851: PUSH
87852: LD_INT 150
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: PUSH
87872: LD_INT 1
87874: PPUSH
87875: LD_INT 15
87877: PPUSH
87878: CALL_OW 12
87882: ARRAY
87883: ST_TO_ADDR
// if ValidHex ( x , y ) then
87884: LD_VAR 0 3
87888: PPUSH
87889: LD_VAR 0 4
87893: PPUSH
87894: CALL_OW 488
87898: IFFALSE 87921
// begin result := [ x , y ] ;
87900: LD_ADDR_VAR 0 1
87904: PUSH
87905: LD_VAR 0 3
87909: PUSH
87910: LD_VAR 0 4
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: ST_TO_ADDR
// break ;
87919: GO 87923
// end ; end ;
87921: GO 87723
87923: POP
87924: POP
// if result then
87925: LD_VAR 0 1
87929: IFFALSE 87989
// begin ToLua ( playSibBomb() ) ;
87931: LD_STRING playSibBomb()
87933: PPUSH
87934: CALL_OW 559
// wait ( 0 0$14 ) ;
87938: LD_INT 490
87940: PPUSH
87941: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
87945: LD_VAR 0 1
87949: PUSH
87950: LD_INT 1
87952: ARRAY
87953: PPUSH
87954: LD_VAR 0 1
87958: PUSH
87959: LD_INT 2
87961: ARRAY
87962: PPUSH
87963: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
87967: LD_VAR 0 1
87971: PUSH
87972: LD_INT 1
87974: ARRAY
87975: PPUSH
87976: LD_VAR 0 1
87980: PUSH
87981: LD_INT 2
87983: ARRAY
87984: PPUSH
87985: CALL_OW 429
// end ; end ;
87989: LD_VAR 0 1
87993: RET
// every 0 0$1 trigger StreamModeActive and sReset do
87994: LD_EXP 109
87998: PUSH
87999: LD_EXP 131
88003: AND
88004: IFFALSE 88016
88006: GO 88008
88008: DISABLE
// YouLost (  ) ;
88009: LD_STRING 
88011: PPUSH
88012: CALL_OW 104
88016: END
// every 0 0$1 trigger StreamModeActive and sFog do
88017: LD_EXP 109
88021: PUSH
88022: LD_EXP 130
88026: AND
88027: IFFALSE 88041
88029: GO 88031
88031: DISABLE
// FogOff ( your_side ) ;
88032: LD_OWVAR 2
88036: PPUSH
88037: CALL_OW 344
88041: END
// every 0 0$1 trigger StreamModeActive and sSun do
88042: LD_EXP 109
88046: PUSH
88047: LD_EXP 132
88051: AND
88052: IFFALSE 88080
88054: GO 88056
88056: DISABLE
// begin solar_recharge_percent := 0 ;
88057: LD_ADDR_OWVAR 79
88061: PUSH
88062: LD_INT 0
88064: ST_TO_ADDR
// wait ( 5 5$00 ) ;
88065: LD_INT 10500
88067: PPUSH
88068: CALL_OW 67
// solar_recharge_percent := 100 ;
88072: LD_ADDR_OWVAR 79
88076: PUSH
88077: LD_INT 100
88079: ST_TO_ADDR
// end ;
88080: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
88081: LD_EXP 109
88085: PUSH
88086: LD_EXP 133
88090: AND
88091: IFFALSE 88330
88093: GO 88095
88095: DISABLE
88096: LD_INT 0
88098: PPUSH
88099: PPUSH
88100: PPUSH
// begin tmp := [ ] ;
88101: LD_ADDR_VAR 0 3
88105: PUSH
88106: EMPTY
88107: ST_TO_ADDR
// for i := 1 to 6 do
88108: LD_ADDR_VAR 0 1
88112: PUSH
88113: DOUBLE
88114: LD_INT 1
88116: DEC
88117: ST_TO_ADDR
88118: LD_INT 6
88120: PUSH
88121: FOR_TO
88122: IFFALSE 88227
// begin uc_nation := nation_nature ;
88124: LD_ADDR_OWVAR 21
88128: PUSH
88129: LD_INT 0
88131: ST_TO_ADDR
// uc_side := 0 ;
88132: LD_ADDR_OWVAR 20
88136: PUSH
88137: LD_INT 0
88139: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88140: LD_ADDR_OWVAR 29
88144: PUSH
88145: LD_INT 12
88147: PUSH
88148: LD_INT 12
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: ST_TO_ADDR
// hc_agressivity := 20 ;
88155: LD_ADDR_OWVAR 35
88159: PUSH
88160: LD_INT 20
88162: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
88163: LD_ADDR_OWVAR 28
88167: PUSH
88168: LD_INT 17
88170: ST_TO_ADDR
// hc_gallery :=  ;
88171: LD_ADDR_OWVAR 33
88175: PUSH
88176: LD_STRING 
88178: ST_TO_ADDR
// hc_name :=  ;
88179: LD_ADDR_OWVAR 26
88183: PUSH
88184: LD_STRING 
88186: ST_TO_ADDR
// un := CreateHuman ;
88187: LD_ADDR_VAR 0 2
88191: PUSH
88192: CALL_OW 44
88196: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
88197: LD_VAR 0 2
88201: PPUSH
88202: LD_INT 1
88204: PPUSH
88205: CALL_OW 51
// tmp := tmp ^ un ;
88209: LD_ADDR_VAR 0 3
88213: PUSH
88214: LD_VAR 0 3
88218: PUSH
88219: LD_VAR 0 2
88223: ADD
88224: ST_TO_ADDR
// end ;
88225: GO 88121
88227: POP
88228: POP
// repeat wait ( 0 0$1 ) ;
88229: LD_INT 35
88231: PPUSH
88232: CALL_OW 67
// for un in tmp do
88236: LD_ADDR_VAR 0 2
88240: PUSH
88241: LD_VAR 0 3
88245: PUSH
88246: FOR_IN
88247: IFFALSE 88321
// begin if IsDead ( un ) then
88249: LD_VAR 0 2
88253: PPUSH
88254: CALL_OW 301
88258: IFFALSE 88278
// begin tmp := tmp diff un ;
88260: LD_ADDR_VAR 0 3
88264: PUSH
88265: LD_VAR 0 3
88269: PUSH
88270: LD_VAR 0 2
88274: DIFF
88275: ST_TO_ADDR
// continue ;
88276: GO 88246
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
88278: LD_VAR 0 2
88282: PPUSH
88283: LD_INT 3
88285: PUSH
88286: LD_INT 22
88288: PUSH
88289: LD_INT 0
88291: PUSH
88292: EMPTY
88293: LIST
88294: LIST
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PPUSH
88300: CALL_OW 69
88304: PPUSH
88305: LD_VAR 0 2
88309: PPUSH
88310: CALL_OW 74
88314: PPUSH
88315: CALL_OW 115
// end ;
88319: GO 88246
88321: POP
88322: POP
// until not tmp ;
88323: LD_VAR 0 3
88327: NOT
88328: IFFALSE 88229
// end ;
88330: PPOPN 3
88332: END
// every 0 0$1 trigger StreamModeActive and sTroll do
88333: LD_EXP 109
88337: PUSH
88338: LD_EXP 134
88342: AND
88343: IFFALSE 88397
88345: GO 88347
88347: DISABLE
// begin ToLua ( displayTroll(); ) ;
88348: LD_STRING displayTroll();
88350: PPUSH
88351: CALL_OW 559
// wait ( 3 3$00 ) ;
88355: LD_INT 6300
88357: PPUSH
88358: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88362: LD_STRING hideTroll();
88364: PPUSH
88365: CALL_OW 559
// wait ( 1 1$00 ) ;
88369: LD_INT 2100
88371: PPUSH
88372: CALL_OW 67
// ToLua ( displayTroll(); ) ;
88376: LD_STRING displayTroll();
88378: PPUSH
88379: CALL_OW 559
// wait ( 1 1$00 ) ;
88383: LD_INT 2100
88385: PPUSH
88386: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88390: LD_STRING hideTroll();
88392: PPUSH
88393: CALL_OW 559
// end ;
88397: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
88398: LD_EXP 109
88402: PUSH
88403: LD_EXP 135
88407: AND
88408: IFFALSE 88471
88410: GO 88412
88412: DISABLE
88413: LD_INT 0
88415: PPUSH
// begin p := 0 ;
88416: LD_ADDR_VAR 0 1
88420: PUSH
88421: LD_INT 0
88423: ST_TO_ADDR
// repeat game_speed := 1 ;
88424: LD_ADDR_OWVAR 65
88428: PUSH
88429: LD_INT 1
88431: ST_TO_ADDR
// wait ( 0 0$1 ) ;
88432: LD_INT 35
88434: PPUSH
88435: CALL_OW 67
// p := p + 1 ;
88439: LD_ADDR_VAR 0 1
88443: PUSH
88444: LD_VAR 0 1
88448: PUSH
88449: LD_INT 1
88451: PLUS
88452: ST_TO_ADDR
// until p >= 60 ;
88453: LD_VAR 0 1
88457: PUSH
88458: LD_INT 60
88460: GREATEREQUAL
88461: IFFALSE 88424
// game_speed := 4 ;
88463: LD_ADDR_OWVAR 65
88467: PUSH
88468: LD_INT 4
88470: ST_TO_ADDR
// end ;
88471: PPOPN 1
88473: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
88474: LD_EXP 109
88478: PUSH
88479: LD_EXP 136
88483: AND
88484: IFFALSE 88630
88486: GO 88488
88488: DISABLE
88489: LD_INT 0
88491: PPUSH
88492: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88493: LD_ADDR_VAR 0 1
88497: PUSH
88498: LD_INT 22
88500: PUSH
88501: LD_OWVAR 2
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 2
88512: PUSH
88513: LD_INT 30
88515: PUSH
88516: LD_INT 0
88518: PUSH
88519: EMPTY
88520: LIST
88521: LIST
88522: PUSH
88523: LD_INT 30
88525: PUSH
88526: LD_INT 1
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: LIST
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PPUSH
88542: CALL_OW 69
88546: ST_TO_ADDR
// if not depot then
88547: LD_VAR 0 1
88551: NOT
88552: IFFALSE 88556
// exit ;
88554: GO 88630
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
88556: LD_ADDR_VAR 0 2
88560: PUSH
88561: LD_VAR 0 1
88565: PUSH
88566: LD_INT 1
88568: PPUSH
88569: LD_VAR 0 1
88573: PPUSH
88574: CALL_OW 12
88578: ARRAY
88579: PPUSH
88580: CALL_OW 274
88584: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
88585: LD_VAR 0 2
88589: PPUSH
88590: LD_INT 1
88592: PPUSH
88593: LD_INT 0
88595: PPUSH
88596: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
88600: LD_VAR 0 2
88604: PPUSH
88605: LD_INT 2
88607: PPUSH
88608: LD_INT 0
88610: PPUSH
88611: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
88615: LD_VAR 0 2
88619: PPUSH
88620: LD_INT 3
88622: PPUSH
88623: LD_INT 0
88625: PPUSH
88626: CALL_OW 277
// end ;
88630: PPOPN 2
88632: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
88633: LD_EXP 109
88637: PUSH
88638: LD_EXP 137
88642: AND
88643: IFFALSE 88740
88645: GO 88647
88647: DISABLE
88648: LD_INT 0
88650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
88651: LD_ADDR_VAR 0 1
88655: PUSH
88656: LD_INT 22
88658: PUSH
88659: LD_OWVAR 2
88663: PUSH
88664: EMPTY
88665: LIST
88666: LIST
88667: PUSH
88668: LD_INT 21
88670: PUSH
88671: LD_INT 1
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: PUSH
88678: LD_INT 3
88680: PUSH
88681: LD_INT 23
88683: PUSH
88684: LD_INT 0
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: LIST
88699: PPUSH
88700: CALL_OW 69
88704: ST_TO_ADDR
// if not tmp then
88705: LD_VAR 0 1
88709: NOT
88710: IFFALSE 88714
// exit ;
88712: GO 88740
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
88714: LD_VAR 0 1
88718: PUSH
88719: LD_INT 1
88721: PPUSH
88722: LD_VAR 0 1
88726: PPUSH
88727: CALL_OW 12
88731: ARRAY
88732: PPUSH
88733: LD_INT 200
88735: PPUSH
88736: CALL_OW 234
// end ;
88740: PPOPN 1
88742: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
88743: LD_EXP 109
88747: PUSH
88748: LD_EXP 138
88752: AND
88753: IFFALSE 88832
88755: GO 88757
88757: DISABLE
88758: LD_INT 0
88760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
88761: LD_ADDR_VAR 0 1
88765: PUSH
88766: LD_INT 22
88768: PUSH
88769: LD_OWVAR 2
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: PUSH
88778: LD_INT 21
88780: PUSH
88781: LD_INT 2
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PPUSH
88792: CALL_OW 69
88796: ST_TO_ADDR
// if not tmp then
88797: LD_VAR 0 1
88801: NOT
88802: IFFALSE 88806
// exit ;
88804: GO 88832
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
88806: LD_VAR 0 1
88810: PUSH
88811: LD_INT 1
88813: PPUSH
88814: LD_VAR 0 1
88818: PPUSH
88819: CALL_OW 12
88823: ARRAY
88824: PPUSH
88825: LD_INT 60
88827: PPUSH
88828: CALL_OW 234
// end ;
88832: PPOPN 1
88834: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
88835: LD_EXP 109
88839: PUSH
88840: LD_EXP 139
88844: AND
88845: IFFALSE 88944
88847: GO 88849
88849: DISABLE
88850: LD_INT 0
88852: PPUSH
88853: PPUSH
// begin enable ;
88854: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
88855: LD_ADDR_VAR 0 1
88859: PUSH
88860: LD_INT 22
88862: PUSH
88863: LD_OWVAR 2
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 61
88874: PUSH
88875: EMPTY
88876: LIST
88877: PUSH
88878: LD_INT 33
88880: PUSH
88881: LD_INT 2
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: LIST
88892: PPUSH
88893: CALL_OW 69
88897: ST_TO_ADDR
// if not tmp then
88898: LD_VAR 0 1
88902: NOT
88903: IFFALSE 88907
// exit ;
88905: GO 88944
// for i in tmp do
88907: LD_ADDR_VAR 0 2
88911: PUSH
88912: LD_VAR 0 1
88916: PUSH
88917: FOR_IN
88918: IFFALSE 88942
// if IsControledBy ( i ) then
88920: LD_VAR 0 2
88924: PPUSH
88925: CALL_OW 312
88929: IFFALSE 88940
// ComUnlink ( i ) ;
88931: LD_VAR 0 2
88935: PPUSH
88936: CALL_OW 136
88940: GO 88917
88942: POP
88943: POP
// end ;
88944: PPOPN 2
88946: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
88947: LD_EXP 109
88951: PUSH
88952: LD_EXP 140
88956: AND
88957: IFFALSE 89097
88959: GO 88961
88961: DISABLE
88962: LD_INT 0
88964: PPUSH
88965: PPUSH
// begin ToLua ( displayPowell(); ) ;
88966: LD_STRING displayPowell();
88968: PPUSH
88969: CALL_OW 559
// uc_side := 0 ;
88973: LD_ADDR_OWVAR 20
88977: PUSH
88978: LD_INT 0
88980: ST_TO_ADDR
// uc_nation := 2 ;
88981: LD_ADDR_OWVAR 21
88985: PUSH
88986: LD_INT 2
88988: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
88989: LD_ADDR_OWVAR 37
88993: PUSH
88994: LD_INT 14
88996: ST_TO_ADDR
// vc_engine := engine_siberite ;
88997: LD_ADDR_OWVAR 39
89001: PUSH
89002: LD_INT 3
89004: ST_TO_ADDR
// vc_control := control_apeman ;
89005: LD_ADDR_OWVAR 38
89009: PUSH
89010: LD_INT 5
89012: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
89013: LD_ADDR_OWVAR 40
89017: PUSH
89018: LD_INT 29
89020: ST_TO_ADDR
// un := CreateVehicle ;
89021: LD_ADDR_VAR 0 2
89025: PUSH
89026: CALL_OW 45
89030: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89031: LD_VAR 0 2
89035: PPUSH
89036: LD_INT 1
89038: PPUSH
89039: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89043: LD_INT 35
89045: PPUSH
89046: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89050: LD_VAR 0 2
89054: PPUSH
89055: LD_INT 22
89057: PUSH
89058: LD_OWVAR 2
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PPUSH
89067: CALL_OW 69
89071: PPUSH
89072: LD_VAR 0 2
89076: PPUSH
89077: CALL_OW 74
89081: PPUSH
89082: CALL_OW 115
// until IsDead ( un ) ;
89086: LD_VAR 0 2
89090: PPUSH
89091: CALL_OW 301
89095: IFFALSE 89043
// end ;
89097: PPOPN 2
89099: END
// every 0 0$1 trigger StreamModeActive and sStu do
89100: LD_EXP 109
89104: PUSH
89105: LD_EXP 148
89109: AND
89110: IFFALSE 89126
89112: GO 89114
89114: DISABLE
// begin ToLua ( displayStucuk(); ) ;
89115: LD_STRING displayStucuk();
89117: PPUSH
89118: CALL_OW 559
// ResetFog ;
89122: CALL_OW 335
// end ;
89126: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
89127: LD_EXP 109
89131: PUSH
89132: LD_EXP 141
89136: AND
89137: IFFALSE 89278
89139: GO 89141
89141: DISABLE
89142: LD_INT 0
89144: PPUSH
89145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89146: LD_ADDR_VAR 0 2
89150: PUSH
89151: LD_INT 22
89153: PUSH
89154: LD_OWVAR 2
89158: PUSH
89159: EMPTY
89160: LIST
89161: LIST
89162: PUSH
89163: LD_INT 21
89165: PUSH
89166: LD_INT 1
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PPUSH
89177: CALL_OW 69
89181: ST_TO_ADDR
// if not tmp then
89182: LD_VAR 0 2
89186: NOT
89187: IFFALSE 89191
// exit ;
89189: GO 89278
// un := tmp [ rand ( 1 , tmp ) ] ;
89191: LD_ADDR_VAR 0 1
89195: PUSH
89196: LD_VAR 0 2
89200: PUSH
89201: LD_INT 1
89203: PPUSH
89204: LD_VAR 0 2
89208: PPUSH
89209: CALL_OW 12
89213: ARRAY
89214: ST_TO_ADDR
// SetSide ( un , 0 ) ;
89215: LD_VAR 0 1
89219: PPUSH
89220: LD_INT 0
89222: PPUSH
89223: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
89227: LD_VAR 0 1
89231: PPUSH
89232: LD_OWVAR 3
89236: PUSH
89237: LD_VAR 0 1
89241: DIFF
89242: PPUSH
89243: LD_VAR 0 1
89247: PPUSH
89248: CALL_OW 74
89252: PPUSH
89253: CALL_OW 115
// wait ( 0 0$20 ) ;
89257: LD_INT 700
89259: PPUSH
89260: CALL_OW 67
// SetSide ( un , your_side ) ;
89264: LD_VAR 0 1
89268: PPUSH
89269: LD_OWVAR 2
89273: PPUSH
89274: CALL_OW 235
// end ;
89278: PPOPN 2
89280: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
89281: LD_EXP 109
89285: PUSH
89286: LD_EXP 142
89290: AND
89291: IFFALSE 89397
89293: GO 89295
89295: DISABLE
89296: LD_INT 0
89298: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89299: LD_ADDR_VAR 0 1
89303: PUSH
89304: LD_INT 22
89306: PUSH
89307: LD_OWVAR 2
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: PUSH
89316: LD_INT 2
89318: PUSH
89319: LD_INT 30
89321: PUSH
89322: LD_INT 0
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 30
89331: PUSH
89332: LD_INT 1
89334: PUSH
89335: EMPTY
89336: LIST
89337: LIST
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: LIST
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PPUSH
89348: CALL_OW 69
89352: ST_TO_ADDR
// if not depot then
89353: LD_VAR 0 1
89357: NOT
89358: IFFALSE 89362
// exit ;
89360: GO 89397
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
89362: LD_VAR 0 1
89366: PUSH
89367: LD_INT 1
89369: ARRAY
89370: PPUSH
89371: CALL_OW 250
89375: PPUSH
89376: LD_VAR 0 1
89380: PUSH
89381: LD_INT 1
89383: ARRAY
89384: PPUSH
89385: CALL_OW 251
89389: PPUSH
89390: LD_INT 70
89392: PPUSH
89393: CALL_OW 495
// end ;
89397: PPOPN 1
89399: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
89400: LD_EXP 109
89404: PUSH
89405: LD_EXP 143
89409: AND
89410: IFFALSE 89621
89412: GO 89414
89414: DISABLE
89415: LD_INT 0
89417: PPUSH
89418: PPUSH
89419: PPUSH
89420: PPUSH
89421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89422: LD_ADDR_VAR 0 5
89426: PUSH
89427: LD_INT 22
89429: PUSH
89430: LD_OWVAR 2
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: PUSH
89439: LD_INT 21
89441: PUSH
89442: LD_INT 1
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PPUSH
89453: CALL_OW 69
89457: ST_TO_ADDR
// if not tmp then
89458: LD_VAR 0 5
89462: NOT
89463: IFFALSE 89467
// exit ;
89465: GO 89621
// for i in tmp do
89467: LD_ADDR_VAR 0 1
89471: PUSH
89472: LD_VAR 0 5
89476: PUSH
89477: FOR_IN
89478: IFFALSE 89619
// begin d := rand ( 0 , 5 ) ;
89480: LD_ADDR_VAR 0 4
89484: PUSH
89485: LD_INT 0
89487: PPUSH
89488: LD_INT 5
89490: PPUSH
89491: CALL_OW 12
89495: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
89496: LD_ADDR_VAR 0 2
89500: PUSH
89501: LD_VAR 0 1
89505: PPUSH
89506: CALL_OW 250
89510: PPUSH
89511: LD_VAR 0 4
89515: PPUSH
89516: LD_INT 3
89518: PPUSH
89519: LD_INT 12
89521: PPUSH
89522: CALL_OW 12
89526: PPUSH
89527: CALL_OW 272
89531: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
89532: LD_ADDR_VAR 0 3
89536: PUSH
89537: LD_VAR 0 1
89541: PPUSH
89542: CALL_OW 251
89546: PPUSH
89547: LD_VAR 0 4
89551: PPUSH
89552: LD_INT 3
89554: PPUSH
89555: LD_INT 12
89557: PPUSH
89558: CALL_OW 12
89562: PPUSH
89563: CALL_OW 273
89567: ST_TO_ADDR
// if ValidHex ( x , y ) then
89568: LD_VAR 0 2
89572: PPUSH
89573: LD_VAR 0 3
89577: PPUSH
89578: CALL_OW 488
89582: IFFALSE 89617
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
89584: LD_VAR 0 1
89588: PPUSH
89589: LD_VAR 0 2
89593: PPUSH
89594: LD_VAR 0 3
89598: PPUSH
89599: LD_INT 3
89601: PPUSH
89602: LD_INT 6
89604: PPUSH
89605: CALL_OW 12
89609: PPUSH
89610: LD_INT 1
89612: PPUSH
89613: CALL_OW 483
// end ;
89617: GO 89477
89619: POP
89620: POP
// end ;
89621: PPOPN 5
89623: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
89624: LD_EXP 109
89628: PUSH
89629: LD_EXP 144
89633: AND
89634: IFFALSE 89728
89636: GO 89638
89638: DISABLE
89639: LD_INT 0
89641: PPUSH
89642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
89643: LD_ADDR_VAR 0 2
89647: PUSH
89648: LD_INT 22
89650: PUSH
89651: LD_OWVAR 2
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 32
89662: PUSH
89663: LD_INT 1
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 21
89672: PUSH
89673: LD_INT 2
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: LIST
89684: PPUSH
89685: CALL_OW 69
89689: ST_TO_ADDR
// if not tmp then
89690: LD_VAR 0 2
89694: NOT
89695: IFFALSE 89699
// exit ;
89697: GO 89728
// for i in tmp do
89699: LD_ADDR_VAR 0 1
89703: PUSH
89704: LD_VAR 0 2
89708: PUSH
89709: FOR_IN
89710: IFFALSE 89726
// SetFuel ( i , 0 ) ;
89712: LD_VAR 0 1
89716: PPUSH
89717: LD_INT 0
89719: PPUSH
89720: CALL_OW 240
89724: GO 89709
89726: POP
89727: POP
// end ;
89728: PPOPN 2
89730: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
89731: LD_EXP 109
89735: PUSH
89736: LD_EXP 145
89740: AND
89741: IFFALSE 89807
89743: GO 89745
89745: DISABLE
89746: LD_INT 0
89748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
89749: LD_ADDR_VAR 0 1
89753: PUSH
89754: LD_INT 22
89756: PUSH
89757: LD_OWVAR 2
89761: PUSH
89762: EMPTY
89763: LIST
89764: LIST
89765: PUSH
89766: LD_INT 30
89768: PUSH
89769: LD_INT 29
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PPUSH
89780: CALL_OW 69
89784: ST_TO_ADDR
// if not tmp then
89785: LD_VAR 0 1
89789: NOT
89790: IFFALSE 89794
// exit ;
89792: GO 89807
// DestroyUnit ( tmp [ 1 ] ) ;
89794: LD_VAR 0 1
89798: PUSH
89799: LD_INT 1
89801: ARRAY
89802: PPUSH
89803: CALL_OW 65
// end ;
89807: PPOPN 1
89809: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
89810: LD_EXP 109
89814: PUSH
89815: LD_EXP 147
89819: AND
89820: IFFALSE 89949
89822: GO 89824
89824: DISABLE
89825: LD_INT 0
89827: PPUSH
// begin uc_side := 0 ;
89828: LD_ADDR_OWVAR 20
89832: PUSH
89833: LD_INT 0
89835: ST_TO_ADDR
// uc_nation := nation_arabian ;
89836: LD_ADDR_OWVAR 21
89840: PUSH
89841: LD_INT 2
89843: ST_TO_ADDR
// hc_gallery :=  ;
89844: LD_ADDR_OWVAR 33
89848: PUSH
89849: LD_STRING 
89851: ST_TO_ADDR
// hc_name :=  ;
89852: LD_ADDR_OWVAR 26
89856: PUSH
89857: LD_STRING 
89859: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
89860: LD_INT 1
89862: PPUSH
89863: LD_INT 11
89865: PPUSH
89866: LD_INT 10
89868: PPUSH
89869: CALL_OW 380
// un := CreateHuman ;
89873: LD_ADDR_VAR 0 1
89877: PUSH
89878: CALL_OW 44
89882: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89883: LD_VAR 0 1
89887: PPUSH
89888: LD_INT 1
89890: PPUSH
89891: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89895: LD_INT 35
89897: PPUSH
89898: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89902: LD_VAR 0 1
89906: PPUSH
89907: LD_INT 22
89909: PUSH
89910: LD_OWVAR 2
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PPUSH
89919: CALL_OW 69
89923: PPUSH
89924: LD_VAR 0 1
89928: PPUSH
89929: CALL_OW 74
89933: PPUSH
89934: CALL_OW 115
// until IsDead ( un ) ;
89938: LD_VAR 0 1
89942: PPUSH
89943: CALL_OW 301
89947: IFFALSE 89895
// end ;
89949: PPOPN 1
89951: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
89952: LD_EXP 109
89956: PUSH
89957: LD_EXP 149
89961: AND
89962: IFFALSE 89974
89964: GO 89966
89966: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
89967: LD_STRING earthquake(getX(game), 0, 32)
89969: PPUSH
89970: CALL_OW 559
89974: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
89975: LD_EXP 109
89979: PUSH
89980: LD_EXP 150
89984: AND
89985: IFFALSE 90076
89987: GO 89989
89989: DISABLE
89990: LD_INT 0
89992: PPUSH
// begin enable ;
89993: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
89994: LD_ADDR_VAR 0 1
89998: PUSH
89999: LD_INT 22
90001: PUSH
90002: LD_OWVAR 2
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 21
90013: PUSH
90014: LD_INT 2
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 33
90023: PUSH
90024: LD_INT 3
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: LIST
90035: PPUSH
90036: CALL_OW 69
90040: ST_TO_ADDR
// if not tmp then
90041: LD_VAR 0 1
90045: NOT
90046: IFFALSE 90050
// exit ;
90048: GO 90076
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90050: LD_VAR 0 1
90054: PUSH
90055: LD_INT 1
90057: PPUSH
90058: LD_VAR 0 1
90062: PPUSH
90063: CALL_OW 12
90067: ARRAY
90068: PPUSH
90069: LD_INT 1
90071: PPUSH
90072: CALL_OW 234
// end ;
90076: PPOPN 1
90078: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
90079: LD_EXP 109
90083: PUSH
90084: LD_EXP 151
90088: AND
90089: IFFALSE 90230
90091: GO 90093
90093: DISABLE
90094: LD_INT 0
90096: PPUSH
90097: PPUSH
90098: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90099: LD_ADDR_VAR 0 3
90103: PUSH
90104: LD_INT 22
90106: PUSH
90107: LD_OWVAR 2
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: PUSH
90116: LD_INT 25
90118: PUSH
90119: LD_INT 1
90121: PUSH
90122: EMPTY
90123: LIST
90124: LIST
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PPUSH
90130: CALL_OW 69
90134: ST_TO_ADDR
// if not tmp then
90135: LD_VAR 0 3
90139: NOT
90140: IFFALSE 90144
// exit ;
90142: GO 90230
// un := tmp [ rand ( 1 , tmp ) ] ;
90144: LD_ADDR_VAR 0 2
90148: PUSH
90149: LD_VAR 0 3
90153: PUSH
90154: LD_INT 1
90156: PPUSH
90157: LD_VAR 0 3
90161: PPUSH
90162: CALL_OW 12
90166: ARRAY
90167: ST_TO_ADDR
// if Crawls ( un ) then
90168: LD_VAR 0 2
90172: PPUSH
90173: CALL_OW 318
90177: IFFALSE 90188
// ComWalk ( un ) ;
90179: LD_VAR 0 2
90183: PPUSH
90184: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
90188: LD_VAR 0 2
90192: PPUSH
90193: LD_INT 9
90195: PPUSH
90196: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
90200: LD_INT 28
90202: PPUSH
90203: LD_OWVAR 2
90207: PPUSH
90208: LD_INT 2
90210: PPUSH
90211: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
90215: LD_INT 29
90217: PPUSH
90218: LD_OWVAR 2
90222: PPUSH
90223: LD_INT 2
90225: PPUSH
90226: CALL_OW 322
// end ;
90230: PPOPN 3
90232: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
90233: LD_EXP 109
90237: PUSH
90238: LD_EXP 152
90242: AND
90243: IFFALSE 90354
90245: GO 90247
90247: DISABLE
90248: LD_INT 0
90250: PPUSH
90251: PPUSH
90252: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90253: LD_ADDR_VAR 0 3
90257: PUSH
90258: LD_INT 22
90260: PUSH
90261: LD_OWVAR 2
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: PUSH
90270: LD_INT 25
90272: PUSH
90273: LD_INT 1
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PPUSH
90284: CALL_OW 69
90288: ST_TO_ADDR
// if not tmp then
90289: LD_VAR 0 3
90293: NOT
90294: IFFALSE 90298
// exit ;
90296: GO 90354
// un := tmp [ rand ( 1 , tmp ) ] ;
90298: LD_ADDR_VAR 0 2
90302: PUSH
90303: LD_VAR 0 3
90307: PUSH
90308: LD_INT 1
90310: PPUSH
90311: LD_VAR 0 3
90315: PPUSH
90316: CALL_OW 12
90320: ARRAY
90321: ST_TO_ADDR
// if Crawls ( un ) then
90322: LD_VAR 0 2
90326: PPUSH
90327: CALL_OW 318
90331: IFFALSE 90342
// ComWalk ( un ) ;
90333: LD_VAR 0 2
90337: PPUSH
90338: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90342: LD_VAR 0 2
90346: PPUSH
90347: LD_INT 8
90349: PPUSH
90350: CALL_OW 336
// end ;
90354: PPOPN 3
90356: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
90357: LD_EXP 109
90361: PUSH
90362: LD_EXP 153
90366: AND
90367: IFFALSE 90511
90369: GO 90371
90371: DISABLE
90372: LD_INT 0
90374: PPUSH
90375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
90376: LD_ADDR_VAR 0 2
90380: PUSH
90381: LD_INT 22
90383: PUSH
90384: LD_OWVAR 2
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 21
90395: PUSH
90396: LD_INT 2
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: PUSH
90403: LD_INT 2
90405: PUSH
90406: LD_INT 34
90408: PUSH
90409: LD_INT 12
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: PUSH
90416: LD_INT 34
90418: PUSH
90419: LD_INT 51
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 34
90428: PUSH
90429: LD_INT 32
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: PUSH
90436: EMPTY
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: LIST
90446: PPUSH
90447: CALL_OW 69
90451: ST_TO_ADDR
// if not tmp then
90452: LD_VAR 0 2
90456: NOT
90457: IFFALSE 90461
// exit ;
90459: GO 90511
// for i in tmp do
90461: LD_ADDR_VAR 0 1
90465: PUSH
90466: LD_VAR 0 2
90470: PUSH
90471: FOR_IN
90472: IFFALSE 90509
// if GetCargo ( i , mat_artifact ) = 0 then
90474: LD_VAR 0 1
90478: PPUSH
90479: LD_INT 4
90481: PPUSH
90482: CALL_OW 289
90486: PUSH
90487: LD_INT 0
90489: EQUAL
90490: IFFALSE 90507
// SetCargo ( i , mat_siberit , 100 ) ;
90492: LD_VAR 0 1
90496: PPUSH
90497: LD_INT 3
90499: PPUSH
90500: LD_INT 100
90502: PPUSH
90503: CALL_OW 290
90507: GO 90471
90509: POP
90510: POP
// end ;
90511: PPOPN 2
90513: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
90514: LD_EXP 109
90518: PUSH
90519: LD_EXP 154
90523: AND
90524: IFFALSE 90707
90526: GO 90528
90528: DISABLE
90529: LD_INT 0
90531: PPUSH
90532: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
90533: LD_ADDR_VAR 0 2
90537: PUSH
90538: LD_INT 22
90540: PUSH
90541: LD_OWVAR 2
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: PPUSH
90550: CALL_OW 69
90554: ST_TO_ADDR
// if not tmp then
90555: LD_VAR 0 2
90559: NOT
90560: IFFALSE 90564
// exit ;
90562: GO 90707
// for i := 1 to 2 do
90564: LD_ADDR_VAR 0 1
90568: PUSH
90569: DOUBLE
90570: LD_INT 1
90572: DEC
90573: ST_TO_ADDR
90574: LD_INT 2
90576: PUSH
90577: FOR_TO
90578: IFFALSE 90705
// begin uc_side := your_side ;
90580: LD_ADDR_OWVAR 20
90584: PUSH
90585: LD_OWVAR 2
90589: ST_TO_ADDR
// uc_nation := nation_american ;
90590: LD_ADDR_OWVAR 21
90594: PUSH
90595: LD_INT 1
90597: ST_TO_ADDR
// vc_chassis := us_morphling ;
90598: LD_ADDR_OWVAR 37
90602: PUSH
90603: LD_INT 5
90605: ST_TO_ADDR
// vc_engine := engine_siberite ;
90606: LD_ADDR_OWVAR 39
90610: PUSH
90611: LD_INT 3
90613: ST_TO_ADDR
// vc_control := control_computer ;
90614: LD_ADDR_OWVAR 38
90618: PUSH
90619: LD_INT 3
90621: ST_TO_ADDR
// vc_weapon := us_double_laser ;
90622: LD_ADDR_OWVAR 40
90626: PUSH
90627: LD_INT 10
90629: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
90630: LD_VAR 0 2
90634: PUSH
90635: LD_INT 1
90637: ARRAY
90638: PPUSH
90639: CALL_OW 310
90643: NOT
90644: IFFALSE 90691
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
90646: CALL_OW 45
90650: PPUSH
90651: LD_VAR 0 2
90655: PUSH
90656: LD_INT 1
90658: ARRAY
90659: PPUSH
90660: CALL_OW 250
90664: PPUSH
90665: LD_VAR 0 2
90669: PUSH
90670: LD_INT 1
90672: ARRAY
90673: PPUSH
90674: CALL_OW 251
90678: PPUSH
90679: LD_INT 12
90681: PPUSH
90682: LD_INT 1
90684: PPUSH
90685: CALL_OW 50
90689: GO 90703
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
90691: CALL_OW 45
90695: PPUSH
90696: LD_INT 1
90698: PPUSH
90699: CALL_OW 51
// end ;
90703: GO 90577
90705: POP
90706: POP
// end ;
90707: PPOPN 2
90709: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
90710: LD_EXP 109
90714: PUSH
90715: LD_EXP 155
90719: AND
90720: IFFALSE 90942
90722: GO 90724
90724: DISABLE
90725: LD_INT 0
90727: PPUSH
90728: PPUSH
90729: PPUSH
90730: PPUSH
90731: PPUSH
90732: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90733: LD_ADDR_VAR 0 6
90737: PUSH
90738: LD_INT 22
90740: PUSH
90741: LD_OWVAR 2
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 21
90752: PUSH
90753: LD_INT 1
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: PUSH
90760: LD_INT 3
90762: PUSH
90763: LD_INT 23
90765: PUSH
90766: LD_INT 0
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: LIST
90781: PPUSH
90782: CALL_OW 69
90786: ST_TO_ADDR
// if not tmp then
90787: LD_VAR 0 6
90791: NOT
90792: IFFALSE 90796
// exit ;
90794: GO 90942
// s1 := rand ( 1 , 4 ) ;
90796: LD_ADDR_VAR 0 2
90800: PUSH
90801: LD_INT 1
90803: PPUSH
90804: LD_INT 4
90806: PPUSH
90807: CALL_OW 12
90811: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
90812: LD_ADDR_VAR 0 4
90816: PUSH
90817: LD_VAR 0 6
90821: PUSH
90822: LD_INT 1
90824: ARRAY
90825: PPUSH
90826: LD_VAR 0 2
90830: PPUSH
90831: CALL_OW 259
90835: ST_TO_ADDR
// if s1 = 1 then
90836: LD_VAR 0 2
90840: PUSH
90841: LD_INT 1
90843: EQUAL
90844: IFFALSE 90864
// s2 := rand ( 2 , 4 ) else
90846: LD_ADDR_VAR 0 3
90850: PUSH
90851: LD_INT 2
90853: PPUSH
90854: LD_INT 4
90856: PPUSH
90857: CALL_OW 12
90861: ST_TO_ADDR
90862: GO 90872
// s2 := 1 ;
90864: LD_ADDR_VAR 0 3
90868: PUSH
90869: LD_INT 1
90871: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
90872: LD_ADDR_VAR 0 5
90876: PUSH
90877: LD_VAR 0 6
90881: PUSH
90882: LD_INT 1
90884: ARRAY
90885: PPUSH
90886: LD_VAR 0 3
90890: PPUSH
90891: CALL_OW 259
90895: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
90896: LD_VAR 0 6
90900: PUSH
90901: LD_INT 1
90903: ARRAY
90904: PPUSH
90905: LD_VAR 0 2
90909: PPUSH
90910: LD_VAR 0 5
90914: PPUSH
90915: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
90919: LD_VAR 0 6
90923: PUSH
90924: LD_INT 1
90926: ARRAY
90927: PPUSH
90928: LD_VAR 0 3
90932: PPUSH
90933: LD_VAR 0 4
90937: PPUSH
90938: CALL_OW 237
// end ;
90942: PPOPN 6
90944: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
90945: LD_EXP 109
90949: PUSH
90950: LD_EXP 156
90954: AND
90955: IFFALSE 91034
90957: GO 90959
90959: DISABLE
90960: LD_INT 0
90962: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
90963: LD_ADDR_VAR 0 1
90967: PUSH
90968: LD_INT 22
90970: PUSH
90971: LD_OWVAR 2
90975: PUSH
90976: EMPTY
90977: LIST
90978: LIST
90979: PUSH
90980: LD_INT 30
90982: PUSH
90983: LD_INT 3
90985: PUSH
90986: EMPTY
90987: LIST
90988: LIST
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PPUSH
90994: CALL_OW 69
90998: ST_TO_ADDR
// if not tmp then
90999: LD_VAR 0 1
91003: NOT
91004: IFFALSE 91008
// exit ;
91006: GO 91034
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91008: LD_VAR 0 1
91012: PUSH
91013: LD_INT 1
91015: PPUSH
91016: LD_VAR 0 1
91020: PPUSH
91021: CALL_OW 12
91025: ARRAY
91026: PPUSH
91027: LD_INT 1
91029: PPUSH
91030: CALL_OW 234
// end ;
91034: PPOPN 1
91036: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
91037: LD_EXP 109
91041: PUSH
91042: LD_EXP 157
91046: AND
91047: IFFALSE 91159
91049: GO 91051
91051: DISABLE
91052: LD_INT 0
91054: PPUSH
91055: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
91056: LD_ADDR_VAR 0 2
91060: PUSH
91061: LD_INT 22
91063: PUSH
91064: LD_OWVAR 2
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: PUSH
91073: LD_INT 2
91075: PUSH
91076: LD_INT 30
91078: PUSH
91079: LD_INT 27
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 30
91088: PUSH
91089: LD_INT 26
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 30
91098: PUSH
91099: LD_INT 28
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: EMPTY
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PPUSH
91116: CALL_OW 69
91120: ST_TO_ADDR
// if not tmp then
91121: LD_VAR 0 2
91125: NOT
91126: IFFALSE 91130
// exit ;
91128: GO 91159
// for i in tmp do
91130: LD_ADDR_VAR 0 1
91134: PUSH
91135: LD_VAR 0 2
91139: PUSH
91140: FOR_IN
91141: IFFALSE 91157
// SetLives ( i , 1 ) ;
91143: LD_VAR 0 1
91147: PPUSH
91148: LD_INT 1
91150: PPUSH
91151: CALL_OW 234
91155: GO 91140
91157: POP
91158: POP
// end ;
91159: PPOPN 2
91161: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
91162: LD_EXP 109
91166: PUSH
91167: LD_EXP 158
91171: AND
91172: IFFALSE 91446
91174: GO 91176
91176: DISABLE
91177: LD_INT 0
91179: PPUSH
91180: PPUSH
91181: PPUSH
// begin i := rand ( 1 , 7 ) ;
91182: LD_ADDR_VAR 0 1
91186: PUSH
91187: LD_INT 1
91189: PPUSH
91190: LD_INT 7
91192: PPUSH
91193: CALL_OW 12
91197: ST_TO_ADDR
// case i of 1 :
91198: LD_VAR 0 1
91202: PUSH
91203: LD_INT 1
91205: DOUBLE
91206: EQUAL
91207: IFTRUE 91211
91209: GO 91221
91211: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
91212: LD_STRING earthquake(getX(game), 0, 32)
91214: PPUSH
91215: CALL_OW 559
91219: GO 91446
91221: LD_INT 2
91223: DOUBLE
91224: EQUAL
91225: IFTRUE 91229
91227: GO 91243
91229: POP
// begin ToLua ( displayStucuk(); ) ;
91230: LD_STRING displayStucuk();
91232: PPUSH
91233: CALL_OW 559
// ResetFog ;
91237: CALL_OW 335
// end ; 3 :
91241: GO 91446
91243: LD_INT 3
91245: DOUBLE
91246: EQUAL
91247: IFTRUE 91251
91249: GO 91355
91251: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91252: LD_ADDR_VAR 0 2
91256: PUSH
91257: LD_INT 22
91259: PUSH
91260: LD_OWVAR 2
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 25
91271: PUSH
91272: LD_INT 1
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PPUSH
91283: CALL_OW 69
91287: ST_TO_ADDR
// if not tmp then
91288: LD_VAR 0 2
91292: NOT
91293: IFFALSE 91297
// exit ;
91295: GO 91446
// un := tmp [ rand ( 1 , tmp ) ] ;
91297: LD_ADDR_VAR 0 3
91301: PUSH
91302: LD_VAR 0 2
91306: PUSH
91307: LD_INT 1
91309: PPUSH
91310: LD_VAR 0 2
91314: PPUSH
91315: CALL_OW 12
91319: ARRAY
91320: ST_TO_ADDR
// if Crawls ( un ) then
91321: LD_VAR 0 3
91325: PPUSH
91326: CALL_OW 318
91330: IFFALSE 91341
// ComWalk ( un ) ;
91332: LD_VAR 0 3
91336: PPUSH
91337: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91341: LD_VAR 0 3
91345: PPUSH
91346: LD_INT 8
91348: PPUSH
91349: CALL_OW 336
// end ; 4 :
91353: GO 91446
91355: LD_INT 4
91357: DOUBLE
91358: EQUAL
91359: IFTRUE 91363
91361: GO 91424
91363: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91364: LD_ADDR_VAR 0 2
91368: PUSH
91369: LD_INT 22
91371: PUSH
91372: LD_OWVAR 2
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 30
91383: PUSH
91384: LD_INT 29
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PPUSH
91395: CALL_OW 69
91399: ST_TO_ADDR
// if not tmp then
91400: LD_VAR 0 2
91404: NOT
91405: IFFALSE 91409
// exit ;
91407: GO 91446
// DestroyUnit ( tmp [ 1 ] ) ;
91409: LD_VAR 0 2
91413: PUSH
91414: LD_INT 1
91416: ARRAY
91417: PPUSH
91418: CALL_OW 65
// end ; 5 .. 7 :
91422: GO 91446
91424: LD_INT 5
91426: DOUBLE
91427: GREATEREQUAL
91428: IFFALSE 91436
91430: LD_INT 7
91432: DOUBLE
91433: LESSEQUAL
91434: IFTRUE 91438
91436: GO 91445
91438: POP
// StreamSibBomb ; end ;
91439: CALL 87696 0 0
91443: GO 91446
91445: POP
// end ;
91446: PPOPN 3
91448: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
91449: LD_EXP 109
91453: PUSH
91454: LD_EXP 159
91458: AND
91459: IFFALSE 91615
91461: GO 91463
91463: DISABLE
91464: LD_INT 0
91466: PPUSH
91467: PPUSH
91468: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
91469: LD_ADDR_VAR 0 2
91473: PUSH
91474: LD_INT 81
91476: PUSH
91477: LD_OWVAR 2
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 2
91488: PUSH
91489: LD_INT 21
91491: PUSH
91492: LD_INT 1
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 21
91501: PUSH
91502: LD_INT 2
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: LIST
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PPUSH
91518: CALL_OW 69
91522: ST_TO_ADDR
// if not tmp then
91523: LD_VAR 0 2
91527: NOT
91528: IFFALSE 91532
// exit ;
91530: GO 91615
// p := 0 ;
91532: LD_ADDR_VAR 0 3
91536: PUSH
91537: LD_INT 0
91539: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91540: LD_INT 35
91542: PPUSH
91543: CALL_OW 67
// p := p + 1 ;
91547: LD_ADDR_VAR 0 3
91551: PUSH
91552: LD_VAR 0 3
91556: PUSH
91557: LD_INT 1
91559: PLUS
91560: ST_TO_ADDR
// for i in tmp do
91561: LD_ADDR_VAR 0 1
91565: PUSH
91566: LD_VAR 0 2
91570: PUSH
91571: FOR_IN
91572: IFFALSE 91603
// if GetLives ( i ) < 1000 then
91574: LD_VAR 0 1
91578: PPUSH
91579: CALL_OW 256
91583: PUSH
91584: LD_INT 1000
91586: LESS
91587: IFFALSE 91601
// SetLives ( i , 1000 ) ;
91589: LD_VAR 0 1
91593: PPUSH
91594: LD_INT 1000
91596: PPUSH
91597: CALL_OW 234
91601: GO 91571
91603: POP
91604: POP
// until p > 20 ;
91605: LD_VAR 0 3
91609: PUSH
91610: LD_INT 20
91612: GREATER
91613: IFFALSE 91540
// end ;
91615: PPOPN 3
91617: END
// every 0 0$1 trigger StreamModeActive and sTime do
91618: LD_EXP 109
91622: PUSH
91623: LD_EXP 160
91627: AND
91628: IFFALSE 91663
91630: GO 91632
91632: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
91633: LD_INT 28
91635: PPUSH
91636: LD_OWVAR 2
91640: PPUSH
91641: LD_INT 2
91643: PPUSH
91644: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
91648: LD_INT 30
91650: PPUSH
91651: LD_OWVAR 2
91655: PPUSH
91656: LD_INT 2
91658: PPUSH
91659: CALL_OW 322
// end ;
91663: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
91664: LD_EXP 109
91668: PUSH
91669: LD_EXP 161
91673: AND
91674: IFFALSE 91795
91676: GO 91678
91678: DISABLE
91679: LD_INT 0
91681: PPUSH
91682: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91683: LD_ADDR_VAR 0 2
91687: PUSH
91688: LD_INT 22
91690: PUSH
91691: LD_OWVAR 2
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 21
91702: PUSH
91703: LD_INT 1
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: LD_INT 3
91712: PUSH
91713: LD_INT 23
91715: PUSH
91716: LD_INT 0
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PUSH
91727: EMPTY
91728: LIST
91729: LIST
91730: LIST
91731: PPUSH
91732: CALL_OW 69
91736: ST_TO_ADDR
// if not tmp then
91737: LD_VAR 0 2
91741: NOT
91742: IFFALSE 91746
// exit ;
91744: GO 91795
// for i in tmp do
91746: LD_ADDR_VAR 0 1
91750: PUSH
91751: LD_VAR 0 2
91755: PUSH
91756: FOR_IN
91757: IFFALSE 91793
// begin if Crawls ( i ) then
91759: LD_VAR 0 1
91763: PPUSH
91764: CALL_OW 318
91768: IFFALSE 91779
// ComWalk ( i ) ;
91770: LD_VAR 0 1
91774: PPUSH
91775: CALL_OW 138
// SetClass ( i , 2 ) ;
91779: LD_VAR 0 1
91783: PPUSH
91784: LD_INT 2
91786: PPUSH
91787: CALL_OW 336
// end ;
91791: GO 91756
91793: POP
91794: POP
// end ;
91795: PPOPN 2
91797: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
91798: LD_EXP 109
91802: PUSH
91803: LD_EXP 162
91807: AND
91808: IFFALSE 92089
91810: GO 91812
91812: DISABLE
91813: LD_INT 0
91815: PPUSH
91816: PPUSH
91817: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
91818: LD_OWVAR 2
91822: PPUSH
91823: LD_INT 9
91825: PPUSH
91826: LD_INT 1
91828: PPUSH
91829: LD_INT 1
91831: PPUSH
91832: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
91836: LD_INT 9
91838: PPUSH
91839: LD_OWVAR 2
91843: PPUSH
91844: CALL_OW 343
// uc_side := 9 ;
91848: LD_ADDR_OWVAR 20
91852: PUSH
91853: LD_INT 9
91855: ST_TO_ADDR
// uc_nation := 2 ;
91856: LD_ADDR_OWVAR 21
91860: PUSH
91861: LD_INT 2
91863: ST_TO_ADDR
// hc_name := Dark Warrior ;
91864: LD_ADDR_OWVAR 26
91868: PUSH
91869: LD_STRING Dark Warrior
91871: ST_TO_ADDR
// hc_gallery :=  ;
91872: LD_ADDR_OWVAR 33
91876: PUSH
91877: LD_STRING 
91879: ST_TO_ADDR
// hc_noskilllimit := true ;
91880: LD_ADDR_OWVAR 76
91884: PUSH
91885: LD_INT 1
91887: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
91888: LD_ADDR_OWVAR 31
91892: PUSH
91893: LD_INT 30
91895: PUSH
91896: LD_INT 30
91898: PUSH
91899: LD_INT 30
91901: PUSH
91902: LD_INT 30
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: ST_TO_ADDR
// un := CreateHuman ;
91911: LD_ADDR_VAR 0 3
91915: PUSH
91916: CALL_OW 44
91920: ST_TO_ADDR
// hc_noskilllimit := false ;
91921: LD_ADDR_OWVAR 76
91925: PUSH
91926: LD_INT 0
91928: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91929: LD_VAR 0 3
91933: PPUSH
91934: LD_INT 1
91936: PPUSH
91937: CALL_OW 51
// p := 0 ;
91941: LD_ADDR_VAR 0 2
91945: PUSH
91946: LD_INT 0
91948: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91949: LD_INT 35
91951: PPUSH
91952: CALL_OW 67
// p := p + 1 ;
91956: LD_ADDR_VAR 0 2
91960: PUSH
91961: LD_VAR 0 2
91965: PUSH
91966: LD_INT 1
91968: PLUS
91969: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
91970: LD_VAR 0 3
91974: PPUSH
91975: CALL_OW 256
91979: PUSH
91980: LD_INT 1000
91982: LESS
91983: IFFALSE 91997
// SetLives ( un , 1000 ) ;
91985: LD_VAR 0 3
91989: PPUSH
91990: LD_INT 1000
91992: PPUSH
91993: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
91997: LD_VAR 0 3
92001: PPUSH
92002: LD_INT 81
92004: PUSH
92005: LD_OWVAR 2
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 91
92016: PUSH
92017: LD_VAR 0 3
92021: PUSH
92022: LD_INT 30
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: LIST
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: PPUSH
92034: CALL_OW 69
92038: PPUSH
92039: LD_VAR 0 3
92043: PPUSH
92044: CALL_OW 74
92048: PPUSH
92049: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
92053: LD_VAR 0 2
92057: PUSH
92058: LD_INT 60
92060: GREATER
92061: PUSH
92062: LD_VAR 0 3
92066: PPUSH
92067: CALL_OW 301
92071: OR
92072: IFFALSE 91949
// if un then
92074: LD_VAR 0 3
92078: IFFALSE 92089
// RemoveUnit ( un ) ;
92080: LD_VAR 0 3
92084: PPUSH
92085: CALL_OW 64
// end ;
92089: PPOPN 3
92091: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92092: LD_INT 0
92094: PPUSH
// case cmd of 301 :
92095: LD_VAR 0 1
92099: PUSH
92100: LD_INT 301
92102: DOUBLE
92103: EQUAL
92104: IFTRUE 92108
92106: GO 92140
92108: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
92109: LD_VAR 0 6
92113: PPUSH
92114: LD_VAR 0 7
92118: PPUSH
92119: LD_VAR 0 8
92123: PPUSH
92124: LD_VAR 0 4
92128: PPUSH
92129: LD_VAR 0 5
92133: PPUSH
92134: CALL 93341 0 5
92138: GO 92261
92140: LD_INT 302
92142: DOUBLE
92143: EQUAL
92144: IFTRUE 92148
92146: GO 92185
92148: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
92149: LD_VAR 0 6
92153: PPUSH
92154: LD_VAR 0 7
92158: PPUSH
92159: LD_VAR 0 8
92163: PPUSH
92164: LD_VAR 0 9
92168: PPUSH
92169: LD_VAR 0 4
92173: PPUSH
92174: LD_VAR 0 5
92178: PPUSH
92179: CALL 93432 0 6
92183: GO 92261
92185: LD_INT 303
92187: DOUBLE
92188: EQUAL
92189: IFTRUE 92193
92191: GO 92230
92193: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
92194: LD_VAR 0 6
92198: PPUSH
92199: LD_VAR 0 7
92203: PPUSH
92204: LD_VAR 0 8
92208: PPUSH
92209: LD_VAR 0 9
92213: PPUSH
92214: LD_VAR 0 4
92218: PPUSH
92219: LD_VAR 0 5
92223: PPUSH
92224: CALL 92266 0 6
92228: GO 92261
92230: LD_INT 304
92232: DOUBLE
92233: EQUAL
92234: IFTRUE 92238
92236: GO 92260
92238: POP
// hHackTeleport ( unit , x , y ) ; end ;
92239: LD_VAR 0 2
92243: PPUSH
92244: LD_VAR 0 4
92248: PPUSH
92249: LD_VAR 0 5
92253: PPUSH
92254: CALL 94025 0 3
92258: GO 92261
92260: POP
// end ;
92261: LD_VAR 0 12
92265: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
92266: LD_INT 0
92268: PPUSH
92269: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
92270: LD_VAR 0 1
92274: PUSH
92275: LD_INT 1
92277: LESS
92278: PUSH
92279: LD_VAR 0 1
92283: PUSH
92284: LD_INT 3
92286: GREATER
92287: OR
92288: PUSH
92289: LD_VAR 0 5
92293: PPUSH
92294: LD_VAR 0 6
92298: PPUSH
92299: CALL_OW 428
92303: OR
92304: IFFALSE 92308
// exit ;
92306: GO 93028
// uc_side := your_side ;
92308: LD_ADDR_OWVAR 20
92312: PUSH
92313: LD_OWVAR 2
92317: ST_TO_ADDR
// uc_nation := nation ;
92318: LD_ADDR_OWVAR 21
92322: PUSH
92323: LD_VAR 0 1
92327: ST_TO_ADDR
// bc_level = 1 ;
92328: LD_ADDR_OWVAR 43
92332: PUSH
92333: LD_INT 1
92335: ST_TO_ADDR
// case btype of 1 :
92336: LD_VAR 0 2
92340: PUSH
92341: LD_INT 1
92343: DOUBLE
92344: EQUAL
92345: IFTRUE 92349
92347: GO 92360
92349: POP
// bc_type := b_depot ; 2 :
92350: LD_ADDR_OWVAR 42
92354: PUSH
92355: LD_INT 0
92357: ST_TO_ADDR
92358: GO 92972
92360: LD_INT 2
92362: DOUBLE
92363: EQUAL
92364: IFTRUE 92368
92366: GO 92379
92368: POP
// bc_type := b_warehouse ; 3 :
92369: LD_ADDR_OWVAR 42
92373: PUSH
92374: LD_INT 1
92376: ST_TO_ADDR
92377: GO 92972
92379: LD_INT 3
92381: DOUBLE
92382: EQUAL
92383: IFTRUE 92387
92385: GO 92398
92387: POP
// bc_type := b_lab ; 4 .. 9 :
92388: LD_ADDR_OWVAR 42
92392: PUSH
92393: LD_INT 6
92395: ST_TO_ADDR
92396: GO 92972
92398: LD_INT 4
92400: DOUBLE
92401: GREATEREQUAL
92402: IFFALSE 92410
92404: LD_INT 9
92406: DOUBLE
92407: LESSEQUAL
92408: IFTRUE 92412
92410: GO 92464
92412: POP
// begin bc_type := b_lab_half ;
92413: LD_ADDR_OWVAR 42
92417: PUSH
92418: LD_INT 7
92420: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
92421: LD_ADDR_OWVAR 44
92425: PUSH
92426: LD_INT 10
92428: PUSH
92429: LD_INT 11
92431: PUSH
92432: LD_INT 12
92434: PUSH
92435: LD_INT 15
92437: PUSH
92438: LD_INT 14
92440: PUSH
92441: LD_INT 13
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: PUSH
92452: LD_VAR 0 2
92456: PUSH
92457: LD_INT 3
92459: MINUS
92460: ARRAY
92461: ST_TO_ADDR
// end ; 10 .. 13 :
92462: GO 92972
92464: LD_INT 10
92466: DOUBLE
92467: GREATEREQUAL
92468: IFFALSE 92476
92470: LD_INT 13
92472: DOUBLE
92473: LESSEQUAL
92474: IFTRUE 92478
92476: GO 92555
92478: POP
// begin bc_type := b_lab_full ;
92479: LD_ADDR_OWVAR 42
92483: PUSH
92484: LD_INT 8
92486: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
92487: LD_ADDR_OWVAR 44
92491: PUSH
92492: LD_INT 10
92494: PUSH
92495: LD_INT 12
92497: PUSH
92498: LD_INT 14
92500: PUSH
92501: LD_INT 13
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: PUSH
92510: LD_VAR 0 2
92514: PUSH
92515: LD_INT 9
92517: MINUS
92518: ARRAY
92519: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
92520: LD_ADDR_OWVAR 45
92524: PUSH
92525: LD_INT 11
92527: PUSH
92528: LD_INT 15
92530: PUSH
92531: LD_INT 12
92533: PUSH
92534: LD_INT 15
92536: PUSH
92537: EMPTY
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: PUSH
92543: LD_VAR 0 2
92547: PUSH
92548: LD_INT 9
92550: MINUS
92551: ARRAY
92552: ST_TO_ADDR
// end ; 14 :
92553: GO 92972
92555: LD_INT 14
92557: DOUBLE
92558: EQUAL
92559: IFTRUE 92563
92561: GO 92574
92563: POP
// bc_type := b_workshop ; 15 :
92564: LD_ADDR_OWVAR 42
92568: PUSH
92569: LD_INT 2
92571: ST_TO_ADDR
92572: GO 92972
92574: LD_INT 15
92576: DOUBLE
92577: EQUAL
92578: IFTRUE 92582
92580: GO 92593
92582: POP
// bc_type := b_factory ; 16 :
92583: LD_ADDR_OWVAR 42
92587: PUSH
92588: LD_INT 3
92590: ST_TO_ADDR
92591: GO 92972
92593: LD_INT 16
92595: DOUBLE
92596: EQUAL
92597: IFTRUE 92601
92599: GO 92612
92601: POP
// bc_type := b_ext_gun ; 17 :
92602: LD_ADDR_OWVAR 42
92606: PUSH
92607: LD_INT 17
92609: ST_TO_ADDR
92610: GO 92972
92612: LD_INT 17
92614: DOUBLE
92615: EQUAL
92616: IFTRUE 92620
92618: GO 92648
92620: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
92621: LD_ADDR_OWVAR 42
92625: PUSH
92626: LD_INT 19
92628: PUSH
92629: LD_INT 23
92631: PUSH
92632: LD_INT 19
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: LIST
92639: PUSH
92640: LD_VAR 0 1
92644: ARRAY
92645: ST_TO_ADDR
92646: GO 92972
92648: LD_INT 18
92650: DOUBLE
92651: EQUAL
92652: IFTRUE 92656
92654: GO 92667
92656: POP
// bc_type := b_ext_radar ; 19 :
92657: LD_ADDR_OWVAR 42
92661: PUSH
92662: LD_INT 20
92664: ST_TO_ADDR
92665: GO 92972
92667: LD_INT 19
92669: DOUBLE
92670: EQUAL
92671: IFTRUE 92675
92673: GO 92686
92675: POP
// bc_type := b_ext_radio ; 20 :
92676: LD_ADDR_OWVAR 42
92680: PUSH
92681: LD_INT 22
92683: ST_TO_ADDR
92684: GO 92972
92686: LD_INT 20
92688: DOUBLE
92689: EQUAL
92690: IFTRUE 92694
92692: GO 92705
92694: POP
// bc_type := b_ext_siberium ; 21 :
92695: LD_ADDR_OWVAR 42
92699: PUSH
92700: LD_INT 21
92702: ST_TO_ADDR
92703: GO 92972
92705: LD_INT 21
92707: DOUBLE
92708: EQUAL
92709: IFTRUE 92713
92711: GO 92724
92713: POP
// bc_type := b_ext_computer ; 22 :
92714: LD_ADDR_OWVAR 42
92718: PUSH
92719: LD_INT 24
92721: ST_TO_ADDR
92722: GO 92972
92724: LD_INT 22
92726: DOUBLE
92727: EQUAL
92728: IFTRUE 92732
92730: GO 92743
92732: POP
// bc_type := b_ext_track ; 23 :
92733: LD_ADDR_OWVAR 42
92737: PUSH
92738: LD_INT 16
92740: ST_TO_ADDR
92741: GO 92972
92743: LD_INT 23
92745: DOUBLE
92746: EQUAL
92747: IFTRUE 92751
92749: GO 92762
92751: POP
// bc_type := b_ext_laser ; 24 :
92752: LD_ADDR_OWVAR 42
92756: PUSH
92757: LD_INT 25
92759: ST_TO_ADDR
92760: GO 92972
92762: LD_INT 24
92764: DOUBLE
92765: EQUAL
92766: IFTRUE 92770
92768: GO 92781
92770: POP
// bc_type := b_control_tower ; 25 :
92771: LD_ADDR_OWVAR 42
92775: PUSH
92776: LD_INT 36
92778: ST_TO_ADDR
92779: GO 92972
92781: LD_INT 25
92783: DOUBLE
92784: EQUAL
92785: IFTRUE 92789
92787: GO 92800
92789: POP
// bc_type := b_breastwork ; 26 :
92790: LD_ADDR_OWVAR 42
92794: PUSH
92795: LD_INT 31
92797: ST_TO_ADDR
92798: GO 92972
92800: LD_INT 26
92802: DOUBLE
92803: EQUAL
92804: IFTRUE 92808
92806: GO 92819
92808: POP
// bc_type := b_bunker ; 27 :
92809: LD_ADDR_OWVAR 42
92813: PUSH
92814: LD_INT 32
92816: ST_TO_ADDR
92817: GO 92972
92819: LD_INT 27
92821: DOUBLE
92822: EQUAL
92823: IFTRUE 92827
92825: GO 92838
92827: POP
// bc_type := b_turret ; 28 :
92828: LD_ADDR_OWVAR 42
92832: PUSH
92833: LD_INT 33
92835: ST_TO_ADDR
92836: GO 92972
92838: LD_INT 28
92840: DOUBLE
92841: EQUAL
92842: IFTRUE 92846
92844: GO 92857
92846: POP
// bc_type := b_armoury ; 29 :
92847: LD_ADDR_OWVAR 42
92851: PUSH
92852: LD_INT 4
92854: ST_TO_ADDR
92855: GO 92972
92857: LD_INT 29
92859: DOUBLE
92860: EQUAL
92861: IFTRUE 92865
92863: GO 92876
92865: POP
// bc_type := b_barracks ; 30 :
92866: LD_ADDR_OWVAR 42
92870: PUSH
92871: LD_INT 5
92873: ST_TO_ADDR
92874: GO 92972
92876: LD_INT 30
92878: DOUBLE
92879: EQUAL
92880: IFTRUE 92884
92882: GO 92895
92884: POP
// bc_type := b_solar_power ; 31 :
92885: LD_ADDR_OWVAR 42
92889: PUSH
92890: LD_INT 27
92892: ST_TO_ADDR
92893: GO 92972
92895: LD_INT 31
92897: DOUBLE
92898: EQUAL
92899: IFTRUE 92903
92901: GO 92914
92903: POP
// bc_type := b_oil_power ; 32 :
92904: LD_ADDR_OWVAR 42
92908: PUSH
92909: LD_INT 26
92911: ST_TO_ADDR
92912: GO 92972
92914: LD_INT 32
92916: DOUBLE
92917: EQUAL
92918: IFTRUE 92922
92920: GO 92933
92922: POP
// bc_type := b_siberite_power ; 33 :
92923: LD_ADDR_OWVAR 42
92927: PUSH
92928: LD_INT 28
92930: ST_TO_ADDR
92931: GO 92972
92933: LD_INT 33
92935: DOUBLE
92936: EQUAL
92937: IFTRUE 92941
92939: GO 92952
92941: POP
// bc_type := b_oil_mine ; 34 :
92942: LD_ADDR_OWVAR 42
92946: PUSH
92947: LD_INT 29
92949: ST_TO_ADDR
92950: GO 92972
92952: LD_INT 34
92954: DOUBLE
92955: EQUAL
92956: IFTRUE 92960
92958: GO 92971
92960: POP
// bc_type := b_siberite_mine ; end ;
92961: LD_ADDR_OWVAR 42
92965: PUSH
92966: LD_INT 30
92968: ST_TO_ADDR
92969: GO 92972
92971: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
92972: LD_ADDR_VAR 0 8
92976: PUSH
92977: LD_VAR 0 5
92981: PPUSH
92982: LD_VAR 0 6
92986: PPUSH
92987: LD_VAR 0 3
92991: PPUSH
92992: CALL_OW 47
92996: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
92997: LD_OWVAR 42
93001: PUSH
93002: LD_INT 32
93004: PUSH
93005: LD_INT 33
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: IN
93012: IFFALSE 93028
// PlaceWeaponTurret ( b , weapon ) ;
93014: LD_VAR 0 8
93018: PPUSH
93019: LD_VAR 0 4
93023: PPUSH
93024: CALL_OW 431
// end ;
93028: LD_VAR 0 7
93032: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
93033: LD_INT 0
93035: PPUSH
93036: PPUSH
93037: PPUSH
93038: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93039: LD_ADDR_VAR 0 4
93043: PUSH
93044: LD_INT 22
93046: PUSH
93047: LD_OWVAR 2
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: LD_INT 2
93058: PUSH
93059: LD_INT 30
93061: PUSH
93062: LD_INT 0
93064: PUSH
93065: EMPTY
93066: LIST
93067: LIST
93068: PUSH
93069: LD_INT 30
93071: PUSH
93072: LD_INT 1
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: LIST
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PPUSH
93088: CALL_OW 69
93092: ST_TO_ADDR
// if not tmp then
93093: LD_VAR 0 4
93097: NOT
93098: IFFALSE 93102
// exit ;
93100: GO 93161
// for i in tmp do
93102: LD_ADDR_VAR 0 2
93106: PUSH
93107: LD_VAR 0 4
93111: PUSH
93112: FOR_IN
93113: IFFALSE 93159
// for j = 1 to 3 do
93115: LD_ADDR_VAR 0 3
93119: PUSH
93120: DOUBLE
93121: LD_INT 1
93123: DEC
93124: ST_TO_ADDR
93125: LD_INT 3
93127: PUSH
93128: FOR_TO
93129: IFFALSE 93155
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
93131: LD_VAR 0 2
93135: PPUSH
93136: CALL_OW 274
93140: PPUSH
93141: LD_VAR 0 3
93145: PPUSH
93146: LD_INT 99999
93148: PPUSH
93149: CALL_OW 277
93153: GO 93128
93155: POP
93156: POP
93157: GO 93112
93159: POP
93160: POP
// end ;
93161: LD_VAR 0 1
93165: RET
// export function hHackSetLevel10 ; var i , j ; begin
93166: LD_INT 0
93168: PPUSH
93169: PPUSH
93170: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93171: LD_ADDR_VAR 0 2
93175: PUSH
93176: LD_INT 21
93178: PUSH
93179: LD_INT 1
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PPUSH
93186: CALL_OW 69
93190: PUSH
93191: FOR_IN
93192: IFFALSE 93244
// if IsSelected ( i ) then
93194: LD_VAR 0 2
93198: PPUSH
93199: CALL_OW 306
93203: IFFALSE 93242
// begin for j := 1 to 4 do
93205: LD_ADDR_VAR 0 3
93209: PUSH
93210: DOUBLE
93211: LD_INT 1
93213: DEC
93214: ST_TO_ADDR
93215: LD_INT 4
93217: PUSH
93218: FOR_TO
93219: IFFALSE 93240
// SetSkill ( i , j , 10 ) ;
93221: LD_VAR 0 2
93225: PPUSH
93226: LD_VAR 0 3
93230: PPUSH
93231: LD_INT 10
93233: PPUSH
93234: CALL_OW 237
93238: GO 93218
93240: POP
93241: POP
// end ;
93242: GO 93191
93244: POP
93245: POP
// end ;
93246: LD_VAR 0 1
93250: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
93251: LD_INT 0
93253: PPUSH
93254: PPUSH
93255: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
93256: LD_ADDR_VAR 0 2
93260: PUSH
93261: LD_INT 22
93263: PUSH
93264: LD_OWVAR 2
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 21
93275: PUSH
93276: LD_INT 1
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: EMPTY
93284: LIST
93285: LIST
93286: PPUSH
93287: CALL_OW 69
93291: PUSH
93292: FOR_IN
93293: IFFALSE 93334
// begin for j := 1 to 4 do
93295: LD_ADDR_VAR 0 3
93299: PUSH
93300: DOUBLE
93301: LD_INT 1
93303: DEC
93304: ST_TO_ADDR
93305: LD_INT 4
93307: PUSH
93308: FOR_TO
93309: IFFALSE 93330
// SetSkill ( i , j , 10 ) ;
93311: LD_VAR 0 2
93315: PPUSH
93316: LD_VAR 0 3
93320: PPUSH
93321: LD_INT 10
93323: PPUSH
93324: CALL_OW 237
93328: GO 93308
93330: POP
93331: POP
// end ;
93332: GO 93292
93334: POP
93335: POP
// end ;
93336: LD_VAR 0 1
93340: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
93341: LD_INT 0
93343: PPUSH
// uc_side := your_side ;
93344: LD_ADDR_OWVAR 20
93348: PUSH
93349: LD_OWVAR 2
93353: ST_TO_ADDR
// uc_nation := nation ;
93354: LD_ADDR_OWVAR 21
93358: PUSH
93359: LD_VAR 0 1
93363: ST_TO_ADDR
// InitHc ;
93364: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
93368: LD_INT 0
93370: PPUSH
93371: LD_VAR 0 2
93375: PPUSH
93376: LD_VAR 0 3
93380: PPUSH
93381: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
93385: LD_VAR 0 4
93389: PPUSH
93390: LD_VAR 0 5
93394: PPUSH
93395: CALL_OW 428
93399: PUSH
93400: LD_INT 0
93402: EQUAL
93403: IFFALSE 93427
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
93405: CALL_OW 44
93409: PPUSH
93410: LD_VAR 0 4
93414: PPUSH
93415: LD_VAR 0 5
93419: PPUSH
93420: LD_INT 1
93422: PPUSH
93423: CALL_OW 48
// end ;
93427: LD_VAR 0 6
93431: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
93432: LD_INT 0
93434: PPUSH
93435: PPUSH
// uc_side := your_side ;
93436: LD_ADDR_OWVAR 20
93440: PUSH
93441: LD_OWVAR 2
93445: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
93446: LD_VAR 0 1
93450: PUSH
93451: LD_INT 1
93453: PUSH
93454: LD_INT 2
93456: PUSH
93457: LD_INT 3
93459: PUSH
93460: LD_INT 4
93462: PUSH
93463: LD_INT 5
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: IN
93473: IFFALSE 93485
// uc_nation := nation_american else
93475: LD_ADDR_OWVAR 21
93479: PUSH
93480: LD_INT 1
93482: ST_TO_ADDR
93483: GO 93528
// if chassis in [ 11 , 12 , 13 , 14 ] then
93485: LD_VAR 0 1
93489: PUSH
93490: LD_INT 11
93492: PUSH
93493: LD_INT 12
93495: PUSH
93496: LD_INT 13
93498: PUSH
93499: LD_INT 14
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: IN
93508: IFFALSE 93520
// uc_nation := nation_arabian else
93510: LD_ADDR_OWVAR 21
93514: PUSH
93515: LD_INT 2
93517: ST_TO_ADDR
93518: GO 93528
// uc_nation := nation_russian ;
93520: LD_ADDR_OWVAR 21
93524: PUSH
93525: LD_INT 3
93527: ST_TO_ADDR
// vc_chassis := chassis ;
93528: LD_ADDR_OWVAR 37
93532: PUSH
93533: LD_VAR 0 1
93537: ST_TO_ADDR
// vc_engine := engine ;
93538: LD_ADDR_OWVAR 39
93542: PUSH
93543: LD_VAR 0 2
93547: ST_TO_ADDR
// vc_control := control ;
93548: LD_ADDR_OWVAR 38
93552: PUSH
93553: LD_VAR 0 3
93557: ST_TO_ADDR
// vc_weapon := weapon ;
93558: LD_ADDR_OWVAR 40
93562: PUSH
93563: LD_VAR 0 4
93567: ST_TO_ADDR
// un := CreateVehicle ;
93568: LD_ADDR_VAR 0 8
93572: PUSH
93573: CALL_OW 45
93577: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
93578: LD_VAR 0 8
93582: PPUSH
93583: LD_INT 0
93585: PPUSH
93586: LD_INT 5
93588: PPUSH
93589: CALL_OW 12
93593: PPUSH
93594: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
93598: LD_VAR 0 8
93602: PPUSH
93603: LD_VAR 0 5
93607: PPUSH
93608: LD_VAR 0 6
93612: PPUSH
93613: LD_INT 1
93615: PPUSH
93616: CALL_OW 48
// end ;
93620: LD_VAR 0 7
93624: RET
// export hInvincible ; every 1 do
93625: GO 93627
93627: DISABLE
// hInvincible := [ ] ;
93628: LD_ADDR_EXP 163
93632: PUSH
93633: EMPTY
93634: ST_TO_ADDR
93635: END
// every 10 do var i ;
93636: GO 93638
93638: DISABLE
93639: LD_INT 0
93641: PPUSH
// begin enable ;
93642: ENABLE
// if not hInvincible then
93643: LD_EXP 163
93647: NOT
93648: IFFALSE 93652
// exit ;
93650: GO 93696
// for i in hInvincible do
93652: LD_ADDR_VAR 0 1
93656: PUSH
93657: LD_EXP 163
93661: PUSH
93662: FOR_IN
93663: IFFALSE 93694
// if GetLives ( i ) < 1000 then
93665: LD_VAR 0 1
93669: PPUSH
93670: CALL_OW 256
93674: PUSH
93675: LD_INT 1000
93677: LESS
93678: IFFALSE 93692
// SetLives ( i , 1000 ) ;
93680: LD_VAR 0 1
93684: PPUSH
93685: LD_INT 1000
93687: PPUSH
93688: CALL_OW 234
93692: GO 93662
93694: POP
93695: POP
// end ;
93696: PPOPN 1
93698: END
// export function hHackInvincible ; var i ; begin
93699: LD_INT 0
93701: PPUSH
93702: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
93703: LD_ADDR_VAR 0 2
93707: PUSH
93708: LD_INT 2
93710: PUSH
93711: LD_INT 21
93713: PUSH
93714: LD_INT 1
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: LD_INT 21
93723: PUSH
93724: LD_INT 2
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: LIST
93735: PPUSH
93736: CALL_OW 69
93740: PUSH
93741: FOR_IN
93742: IFFALSE 93803
// if IsSelected ( i ) then
93744: LD_VAR 0 2
93748: PPUSH
93749: CALL_OW 306
93753: IFFALSE 93801
// begin if i in hInvincible then
93755: LD_VAR 0 2
93759: PUSH
93760: LD_EXP 163
93764: IN
93765: IFFALSE 93785
// hInvincible := hInvincible diff i else
93767: LD_ADDR_EXP 163
93771: PUSH
93772: LD_EXP 163
93776: PUSH
93777: LD_VAR 0 2
93781: DIFF
93782: ST_TO_ADDR
93783: GO 93801
// hInvincible := hInvincible union i ;
93785: LD_ADDR_EXP 163
93789: PUSH
93790: LD_EXP 163
93794: PUSH
93795: LD_VAR 0 2
93799: UNION
93800: ST_TO_ADDR
// end ;
93801: GO 93741
93803: POP
93804: POP
// end ;
93805: LD_VAR 0 1
93809: RET
// export function hHackInvisible ; var i , j ; begin
93810: LD_INT 0
93812: PPUSH
93813: PPUSH
93814: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93815: LD_ADDR_VAR 0 2
93819: PUSH
93820: LD_INT 21
93822: PUSH
93823: LD_INT 1
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PPUSH
93830: CALL_OW 69
93834: PUSH
93835: FOR_IN
93836: IFFALSE 93860
// if IsSelected ( i ) then
93838: LD_VAR 0 2
93842: PPUSH
93843: CALL_OW 306
93847: IFFALSE 93858
// ComForceInvisible ( i ) ;
93849: LD_VAR 0 2
93853: PPUSH
93854: CALL_OW 496
93858: GO 93835
93860: POP
93861: POP
// end ;
93862: LD_VAR 0 1
93866: RET
// export function hHackChangeYourSide ; begin
93867: LD_INT 0
93869: PPUSH
// if your_side = 8 then
93870: LD_OWVAR 2
93874: PUSH
93875: LD_INT 8
93877: EQUAL
93878: IFFALSE 93890
// your_side := 0 else
93880: LD_ADDR_OWVAR 2
93884: PUSH
93885: LD_INT 0
93887: ST_TO_ADDR
93888: GO 93904
// your_side := your_side + 1 ;
93890: LD_ADDR_OWVAR 2
93894: PUSH
93895: LD_OWVAR 2
93899: PUSH
93900: LD_INT 1
93902: PLUS
93903: ST_TO_ADDR
// end ;
93904: LD_VAR 0 1
93908: RET
// export function hHackChangeUnitSide ; var i , j ; begin
93909: LD_INT 0
93911: PPUSH
93912: PPUSH
93913: PPUSH
// for i in all_units do
93914: LD_ADDR_VAR 0 2
93918: PUSH
93919: LD_OWVAR 3
93923: PUSH
93924: FOR_IN
93925: IFFALSE 94003
// if IsSelected ( i ) then
93927: LD_VAR 0 2
93931: PPUSH
93932: CALL_OW 306
93936: IFFALSE 94001
// begin j := GetSide ( i ) ;
93938: LD_ADDR_VAR 0 3
93942: PUSH
93943: LD_VAR 0 2
93947: PPUSH
93948: CALL_OW 255
93952: ST_TO_ADDR
// if j = 8 then
93953: LD_VAR 0 3
93957: PUSH
93958: LD_INT 8
93960: EQUAL
93961: IFFALSE 93973
// j := 0 else
93963: LD_ADDR_VAR 0 3
93967: PUSH
93968: LD_INT 0
93970: ST_TO_ADDR
93971: GO 93987
// j := j + 1 ;
93973: LD_ADDR_VAR 0 3
93977: PUSH
93978: LD_VAR 0 3
93982: PUSH
93983: LD_INT 1
93985: PLUS
93986: ST_TO_ADDR
// SetSide ( i , j ) ;
93987: LD_VAR 0 2
93991: PPUSH
93992: LD_VAR 0 3
93996: PPUSH
93997: CALL_OW 235
// end ;
94001: GO 93924
94003: POP
94004: POP
// end ;
94005: LD_VAR 0 1
94009: RET
// export function hHackFog ; begin
94010: LD_INT 0
94012: PPUSH
// FogOff ( true ) ;
94013: LD_INT 1
94015: PPUSH
94016: CALL_OW 344
// end ;
94020: LD_VAR 0 1
94024: RET
// export function hHackTeleport ( unit , x , y ) ; begin
94025: LD_INT 0
94027: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
94028: LD_VAR 0 1
94032: PPUSH
94033: LD_VAR 0 2
94037: PPUSH
94038: LD_VAR 0 3
94042: PPUSH
94043: LD_INT 1
94045: PPUSH
94046: LD_INT 1
94048: PPUSH
94049: CALL_OW 483
// CenterOnXY ( x , y ) ;
94053: LD_VAR 0 2
94057: PPUSH
94058: LD_VAR 0 3
94062: PPUSH
94063: CALL_OW 84
// end ; end_of_file
94067: LD_VAR 0 4
94071: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
94072: LD_INT 0
94074: PPUSH
94075: PPUSH
94076: PPUSH
94077: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
94078: LD_VAR 0 1
94082: PPUSH
94083: CALL_OW 264
94087: PUSH
94088: LD_EXP 52
94092: EQUAL
94093: IFFALSE 94165
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94095: LD_INT 68
94097: PPUSH
94098: LD_VAR 0 1
94102: PPUSH
94103: CALL_OW 255
94107: PPUSH
94108: CALL_OW 321
94112: PUSH
94113: LD_INT 2
94115: EQUAL
94116: IFFALSE 94128
// eff := 70 else
94118: LD_ADDR_VAR 0 4
94122: PUSH
94123: LD_INT 70
94125: ST_TO_ADDR
94126: GO 94136
// eff := 30 ;
94128: LD_ADDR_VAR 0 4
94132: PUSH
94133: LD_INT 30
94135: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94136: LD_VAR 0 1
94140: PPUSH
94141: CALL_OW 250
94145: PPUSH
94146: LD_VAR 0 1
94150: PPUSH
94151: CALL_OW 251
94155: PPUSH
94156: LD_VAR 0 4
94160: PPUSH
94161: CALL_OW 495
// end ; end ;
94165: LD_VAR 0 2
94169: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
94170: LD_INT 0
94172: PPUSH
// end ;
94173: LD_VAR 0 4
94177: RET
// export function SOS_Command ( cmd ) ; begin
94178: LD_INT 0
94180: PPUSH
// end ;
94181: LD_VAR 0 2
94185: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
94186: LD_INT 0
94188: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
94189: LD_VAR 0 1
94193: PUSH
94194: LD_INT 250
94196: EQUAL
94197: PUSH
94198: LD_VAR 0 2
94202: PPUSH
94203: CALL_OW 264
94207: PUSH
94208: LD_EXP 55
94212: EQUAL
94213: AND
94214: IFFALSE 94235
// MinerPlaceMine ( unit , x , y ) ;
94216: LD_VAR 0 2
94220: PPUSH
94221: LD_VAR 0 4
94225: PPUSH
94226: LD_VAR 0 5
94230: PPUSH
94231: CALL 96576 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
94235: LD_VAR 0 1
94239: PUSH
94240: LD_INT 251
94242: EQUAL
94243: PUSH
94244: LD_VAR 0 2
94248: PPUSH
94249: CALL_OW 264
94253: PUSH
94254: LD_EXP 55
94258: EQUAL
94259: AND
94260: IFFALSE 94281
// MinerDetonateMine ( unit , x , y ) ;
94262: LD_VAR 0 2
94266: PPUSH
94267: LD_VAR 0 4
94271: PPUSH
94272: LD_VAR 0 5
94276: PPUSH
94277: CALL 96853 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
94281: LD_VAR 0 1
94285: PUSH
94286: LD_INT 252
94288: EQUAL
94289: PUSH
94290: LD_VAR 0 2
94294: PPUSH
94295: CALL_OW 264
94299: PUSH
94300: LD_EXP 55
94304: EQUAL
94305: AND
94306: IFFALSE 94327
// MinerCreateMinefield ( unit , x , y ) ;
94308: LD_VAR 0 2
94312: PPUSH
94313: LD_VAR 0 4
94317: PPUSH
94318: LD_VAR 0 5
94322: PPUSH
94323: CALL 97270 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
94327: LD_VAR 0 1
94331: PUSH
94332: LD_INT 253
94334: EQUAL
94335: PUSH
94336: LD_VAR 0 2
94340: PPUSH
94341: CALL_OW 257
94345: PUSH
94346: LD_INT 5
94348: EQUAL
94349: AND
94350: IFFALSE 94371
// ComBinocular ( unit , x , y ) ;
94352: LD_VAR 0 2
94356: PPUSH
94357: LD_VAR 0 4
94361: PPUSH
94362: LD_VAR 0 5
94366: PPUSH
94367: CALL 97641 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
94371: LD_VAR 0 1
94375: PUSH
94376: LD_INT 254
94378: EQUAL
94379: PUSH
94380: LD_VAR 0 2
94384: PPUSH
94385: CALL_OW 264
94389: PUSH
94390: LD_EXP 50
94394: EQUAL
94395: AND
94396: PUSH
94397: LD_VAR 0 3
94401: PPUSH
94402: CALL_OW 263
94406: PUSH
94407: LD_INT 3
94409: EQUAL
94410: AND
94411: IFFALSE 94427
// HackDestroyVehicle ( unit , selectedUnit ) ;
94413: LD_VAR 0 2
94417: PPUSH
94418: LD_VAR 0 3
94422: PPUSH
94423: CALL 95936 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
94427: LD_VAR 0 1
94431: PUSH
94432: LD_INT 255
94434: EQUAL
94435: PUSH
94436: LD_VAR 0 2
94440: PPUSH
94441: CALL_OW 264
94445: PUSH
94446: LD_INT 14
94448: PUSH
94449: LD_INT 53
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: IN
94456: AND
94457: PUSH
94458: LD_VAR 0 4
94462: PPUSH
94463: LD_VAR 0 5
94467: PPUSH
94468: CALL_OW 488
94472: AND
94473: IFFALSE 94497
// CutTreeXYR ( unit , x , y , 12 ) ;
94475: LD_VAR 0 2
94479: PPUSH
94480: LD_VAR 0 4
94484: PPUSH
94485: LD_VAR 0 5
94489: PPUSH
94490: LD_INT 12
94492: PPUSH
94493: CALL 94502 0 4
// end ;
94497: LD_VAR 0 6
94501: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
94502: LD_INT 0
94504: PPUSH
94505: PPUSH
94506: PPUSH
94507: PPUSH
94508: PPUSH
94509: PPUSH
94510: PPUSH
94511: PPUSH
94512: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
94513: LD_VAR 0 1
94517: NOT
94518: PUSH
94519: LD_VAR 0 2
94523: PPUSH
94524: LD_VAR 0 3
94528: PPUSH
94529: CALL_OW 488
94533: NOT
94534: OR
94535: PUSH
94536: LD_VAR 0 4
94540: NOT
94541: OR
94542: IFFALSE 94546
// exit ;
94544: GO 94886
// list := [ ] ;
94546: LD_ADDR_VAR 0 13
94550: PUSH
94551: EMPTY
94552: ST_TO_ADDR
// if x - r < 0 then
94553: LD_VAR 0 2
94557: PUSH
94558: LD_VAR 0 4
94562: MINUS
94563: PUSH
94564: LD_INT 0
94566: LESS
94567: IFFALSE 94579
// min_x := 0 else
94569: LD_ADDR_VAR 0 7
94573: PUSH
94574: LD_INT 0
94576: ST_TO_ADDR
94577: GO 94595
// min_x := x - r ;
94579: LD_ADDR_VAR 0 7
94583: PUSH
94584: LD_VAR 0 2
94588: PUSH
94589: LD_VAR 0 4
94593: MINUS
94594: ST_TO_ADDR
// if y - r < 0 then
94595: LD_VAR 0 3
94599: PUSH
94600: LD_VAR 0 4
94604: MINUS
94605: PUSH
94606: LD_INT 0
94608: LESS
94609: IFFALSE 94621
// min_y := 0 else
94611: LD_ADDR_VAR 0 8
94615: PUSH
94616: LD_INT 0
94618: ST_TO_ADDR
94619: GO 94637
// min_y := y - r ;
94621: LD_ADDR_VAR 0 8
94625: PUSH
94626: LD_VAR 0 3
94630: PUSH
94631: LD_VAR 0 4
94635: MINUS
94636: ST_TO_ADDR
// max_x := x + r ;
94637: LD_ADDR_VAR 0 9
94641: PUSH
94642: LD_VAR 0 2
94646: PUSH
94647: LD_VAR 0 4
94651: PLUS
94652: ST_TO_ADDR
// max_y := y + r ;
94653: LD_ADDR_VAR 0 10
94657: PUSH
94658: LD_VAR 0 3
94662: PUSH
94663: LD_VAR 0 4
94667: PLUS
94668: ST_TO_ADDR
// for _x = min_x to max_x do
94669: LD_ADDR_VAR 0 11
94673: PUSH
94674: DOUBLE
94675: LD_VAR 0 7
94679: DEC
94680: ST_TO_ADDR
94681: LD_VAR 0 9
94685: PUSH
94686: FOR_TO
94687: IFFALSE 94804
// for _y = min_y to max_y do
94689: LD_ADDR_VAR 0 12
94693: PUSH
94694: DOUBLE
94695: LD_VAR 0 8
94699: DEC
94700: ST_TO_ADDR
94701: LD_VAR 0 10
94705: PUSH
94706: FOR_TO
94707: IFFALSE 94800
// begin if not ValidHex ( _x , _y ) then
94709: LD_VAR 0 11
94713: PPUSH
94714: LD_VAR 0 12
94718: PPUSH
94719: CALL_OW 488
94723: NOT
94724: IFFALSE 94728
// continue ;
94726: GO 94706
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94728: LD_VAR 0 11
94732: PPUSH
94733: LD_VAR 0 12
94737: PPUSH
94738: CALL_OW 351
94742: PUSH
94743: LD_VAR 0 11
94747: PPUSH
94748: LD_VAR 0 12
94752: PPUSH
94753: CALL_OW 554
94757: AND
94758: IFFALSE 94798
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94760: LD_ADDR_VAR 0 13
94764: PUSH
94765: LD_VAR 0 13
94769: PPUSH
94770: LD_VAR 0 13
94774: PUSH
94775: LD_INT 1
94777: PLUS
94778: PPUSH
94779: LD_VAR 0 11
94783: PUSH
94784: LD_VAR 0 12
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PPUSH
94793: CALL_OW 2
94797: ST_TO_ADDR
// end ;
94798: GO 94706
94800: POP
94801: POP
94802: GO 94686
94804: POP
94805: POP
// if not list then
94806: LD_VAR 0 13
94810: NOT
94811: IFFALSE 94815
// exit ;
94813: GO 94886
// for i in list do
94815: LD_ADDR_VAR 0 6
94819: PUSH
94820: LD_VAR 0 13
94824: PUSH
94825: FOR_IN
94826: IFFALSE 94884
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94828: LD_VAR 0 1
94832: PPUSH
94833: LD_STRING M
94835: PUSH
94836: LD_VAR 0 6
94840: PUSH
94841: LD_INT 1
94843: ARRAY
94844: PUSH
94845: LD_VAR 0 6
94849: PUSH
94850: LD_INT 2
94852: ARRAY
94853: PUSH
94854: LD_INT 0
94856: PUSH
94857: LD_INT 0
94859: PUSH
94860: LD_INT 0
94862: PUSH
94863: LD_INT 0
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: PUSH
94875: EMPTY
94876: LIST
94877: PPUSH
94878: CALL_OW 447
94882: GO 94825
94884: POP
94885: POP
// end ;
94886: LD_VAR 0 5
94890: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
94891: LD_EXP 164
94895: NOT
94896: IFFALSE 94946
94898: GO 94900
94900: DISABLE
// begin initHack := true ;
94901: LD_ADDR_EXP 164
94905: PUSH
94906: LD_INT 1
94908: ST_TO_ADDR
// hackTanks := [ ] ;
94909: LD_ADDR_EXP 165
94913: PUSH
94914: EMPTY
94915: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
94916: LD_ADDR_EXP 166
94920: PUSH
94921: EMPTY
94922: ST_TO_ADDR
// hackLimit := 3 ;
94923: LD_ADDR_EXP 167
94927: PUSH
94928: LD_INT 3
94930: ST_TO_ADDR
// hackDist := 12 ;
94931: LD_ADDR_EXP 168
94935: PUSH
94936: LD_INT 12
94938: ST_TO_ADDR
// hackCounter := [ ] ;
94939: LD_ADDR_EXP 169
94943: PUSH
94944: EMPTY
94945: ST_TO_ADDR
// end ;
94946: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
94947: LD_EXP 164
94951: PUSH
94952: LD_INT 34
94954: PUSH
94955: LD_EXP 50
94959: PUSH
94960: EMPTY
94961: LIST
94962: LIST
94963: PPUSH
94964: CALL_OW 69
94968: AND
94969: IFFALSE 95224
94971: GO 94973
94973: DISABLE
94974: LD_INT 0
94976: PPUSH
94977: PPUSH
// begin enable ;
94978: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
94979: LD_ADDR_VAR 0 1
94983: PUSH
94984: LD_INT 34
94986: PUSH
94987: LD_EXP 50
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PPUSH
94996: CALL_OW 69
95000: PUSH
95001: FOR_IN
95002: IFFALSE 95222
// begin if not i in hackTanks then
95004: LD_VAR 0 1
95008: PUSH
95009: LD_EXP 165
95013: IN
95014: NOT
95015: IFFALSE 95098
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
95017: LD_ADDR_EXP 165
95021: PUSH
95022: LD_EXP 165
95026: PPUSH
95027: LD_EXP 165
95031: PUSH
95032: LD_INT 1
95034: PLUS
95035: PPUSH
95036: LD_VAR 0 1
95040: PPUSH
95041: CALL_OW 1
95045: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
95046: LD_ADDR_EXP 166
95050: PUSH
95051: LD_EXP 166
95055: PPUSH
95056: LD_EXP 166
95060: PUSH
95061: LD_INT 1
95063: PLUS
95064: PPUSH
95065: EMPTY
95066: PPUSH
95067: CALL_OW 1
95071: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
95072: LD_ADDR_EXP 169
95076: PUSH
95077: LD_EXP 169
95081: PPUSH
95082: LD_EXP 169
95086: PUSH
95087: LD_INT 1
95089: PLUS
95090: PPUSH
95091: EMPTY
95092: PPUSH
95093: CALL_OW 1
95097: ST_TO_ADDR
// end ; if not IsOk ( i ) then
95098: LD_VAR 0 1
95102: PPUSH
95103: CALL_OW 302
95107: NOT
95108: IFFALSE 95121
// begin HackUnlinkAll ( i ) ;
95110: LD_VAR 0 1
95114: PPUSH
95115: CALL 95227 0 1
// continue ;
95119: GO 95001
// end ; HackCheckCapturedStatus ( i ) ;
95121: LD_VAR 0 1
95125: PPUSH
95126: CALL 95670 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
95130: LD_ADDR_VAR 0 2
95134: PUSH
95135: LD_INT 81
95137: PUSH
95138: LD_VAR 0 1
95142: PPUSH
95143: CALL_OW 255
95147: PUSH
95148: EMPTY
95149: LIST
95150: LIST
95151: PUSH
95152: LD_INT 33
95154: PUSH
95155: LD_INT 3
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 91
95164: PUSH
95165: LD_VAR 0 1
95169: PUSH
95170: LD_EXP 168
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: LIST
95179: PUSH
95180: LD_INT 50
95182: PUSH
95183: EMPTY
95184: LIST
95185: PUSH
95186: EMPTY
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: PPUSH
95192: CALL_OW 69
95196: ST_TO_ADDR
// if not tmp then
95197: LD_VAR 0 2
95201: NOT
95202: IFFALSE 95206
// continue ;
95204: GO 95001
// HackLink ( i , tmp ) ;
95206: LD_VAR 0 1
95210: PPUSH
95211: LD_VAR 0 2
95215: PPUSH
95216: CALL 95363 0 2
// end ;
95220: GO 95001
95222: POP
95223: POP
// end ;
95224: PPOPN 2
95226: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
95227: LD_INT 0
95229: PPUSH
95230: PPUSH
95231: PPUSH
// if not hack in hackTanks then
95232: LD_VAR 0 1
95236: PUSH
95237: LD_EXP 165
95241: IN
95242: NOT
95243: IFFALSE 95247
// exit ;
95245: GO 95358
// index := GetElementIndex ( hackTanks , hack ) ;
95247: LD_ADDR_VAR 0 4
95251: PUSH
95252: LD_EXP 165
95256: PPUSH
95257: LD_VAR 0 1
95261: PPUSH
95262: CALL 18333 0 2
95266: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
95267: LD_EXP 166
95271: PUSH
95272: LD_VAR 0 4
95276: ARRAY
95277: IFFALSE 95358
// begin for i in hackTanksCaptured [ index ] do
95279: LD_ADDR_VAR 0 3
95283: PUSH
95284: LD_EXP 166
95288: PUSH
95289: LD_VAR 0 4
95293: ARRAY
95294: PUSH
95295: FOR_IN
95296: IFFALSE 95322
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
95298: LD_VAR 0 3
95302: PUSH
95303: LD_INT 1
95305: ARRAY
95306: PPUSH
95307: LD_VAR 0 3
95311: PUSH
95312: LD_INT 2
95314: ARRAY
95315: PPUSH
95316: CALL_OW 235
95320: GO 95295
95322: POP
95323: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
95324: LD_ADDR_EXP 166
95328: PUSH
95329: LD_EXP 166
95333: PPUSH
95334: LD_VAR 0 4
95338: PPUSH
95339: EMPTY
95340: PPUSH
95341: CALL_OW 1
95345: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
95346: LD_VAR 0 1
95350: PPUSH
95351: LD_INT 0
95353: PPUSH
95354: CALL_OW 505
// end ; end ;
95358: LD_VAR 0 2
95362: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
95363: LD_INT 0
95365: PPUSH
95366: PPUSH
95367: PPUSH
// if not hack in hackTanks or not vehicles then
95368: LD_VAR 0 1
95372: PUSH
95373: LD_EXP 165
95377: IN
95378: NOT
95379: PUSH
95380: LD_VAR 0 2
95384: NOT
95385: OR
95386: IFFALSE 95390
// exit ;
95388: GO 95665
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
95390: LD_ADDR_VAR 0 2
95394: PUSH
95395: LD_VAR 0 1
95399: PPUSH
95400: LD_VAR 0 2
95404: PPUSH
95405: LD_INT 1
95407: PPUSH
95408: LD_INT 1
95410: PPUSH
95411: CALL 18983 0 4
95415: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
95416: LD_ADDR_VAR 0 5
95420: PUSH
95421: LD_EXP 165
95425: PPUSH
95426: LD_VAR 0 1
95430: PPUSH
95431: CALL 18333 0 2
95435: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
95436: LD_EXP 166
95440: PUSH
95441: LD_VAR 0 5
95445: ARRAY
95446: PUSH
95447: LD_EXP 167
95451: LESS
95452: IFFALSE 95641
// begin for i := 1 to vehicles do
95454: LD_ADDR_VAR 0 4
95458: PUSH
95459: DOUBLE
95460: LD_INT 1
95462: DEC
95463: ST_TO_ADDR
95464: LD_VAR 0 2
95468: PUSH
95469: FOR_TO
95470: IFFALSE 95639
// begin if hackTanksCaptured [ index ] = hackLimit then
95472: LD_EXP 166
95476: PUSH
95477: LD_VAR 0 5
95481: ARRAY
95482: PUSH
95483: LD_EXP 167
95487: EQUAL
95488: IFFALSE 95492
// break ;
95490: GO 95639
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
95492: LD_ADDR_EXP 169
95496: PUSH
95497: LD_EXP 169
95501: PPUSH
95502: LD_VAR 0 5
95506: PPUSH
95507: LD_EXP 169
95511: PUSH
95512: LD_VAR 0 5
95516: ARRAY
95517: PUSH
95518: LD_INT 1
95520: PLUS
95521: PPUSH
95522: CALL_OW 1
95526: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
95527: LD_ADDR_EXP 166
95531: PUSH
95532: LD_EXP 166
95536: PPUSH
95537: LD_VAR 0 5
95541: PUSH
95542: LD_EXP 166
95546: PUSH
95547: LD_VAR 0 5
95551: ARRAY
95552: PUSH
95553: LD_INT 1
95555: PLUS
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PPUSH
95561: LD_VAR 0 2
95565: PUSH
95566: LD_VAR 0 4
95570: ARRAY
95571: PUSH
95572: LD_VAR 0 2
95576: PUSH
95577: LD_VAR 0 4
95581: ARRAY
95582: PPUSH
95583: CALL_OW 255
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PPUSH
95592: CALL 18548 0 3
95596: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
95597: LD_VAR 0 2
95601: PUSH
95602: LD_VAR 0 4
95606: ARRAY
95607: PPUSH
95608: LD_VAR 0 1
95612: PPUSH
95613: CALL_OW 255
95617: PPUSH
95618: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
95622: LD_VAR 0 2
95626: PUSH
95627: LD_VAR 0 4
95631: ARRAY
95632: PPUSH
95633: CALL_OW 141
// end ;
95637: GO 95469
95639: POP
95640: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
95641: LD_VAR 0 1
95645: PPUSH
95646: LD_EXP 166
95650: PUSH
95651: LD_VAR 0 5
95655: ARRAY
95656: PUSH
95657: LD_INT 0
95659: PLUS
95660: PPUSH
95661: CALL_OW 505
// end ;
95665: LD_VAR 0 3
95669: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
95670: LD_INT 0
95672: PPUSH
95673: PPUSH
95674: PPUSH
95675: PPUSH
// if not hack in hackTanks then
95676: LD_VAR 0 1
95680: PUSH
95681: LD_EXP 165
95685: IN
95686: NOT
95687: IFFALSE 95691
// exit ;
95689: GO 95931
// index := GetElementIndex ( hackTanks , hack ) ;
95691: LD_ADDR_VAR 0 4
95695: PUSH
95696: LD_EXP 165
95700: PPUSH
95701: LD_VAR 0 1
95705: PPUSH
95706: CALL 18333 0 2
95710: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
95711: LD_ADDR_VAR 0 3
95715: PUSH
95716: DOUBLE
95717: LD_EXP 166
95721: PUSH
95722: LD_VAR 0 4
95726: ARRAY
95727: INC
95728: ST_TO_ADDR
95729: LD_INT 1
95731: PUSH
95732: FOR_DOWNTO
95733: IFFALSE 95905
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
95735: LD_ADDR_VAR 0 5
95739: PUSH
95740: LD_EXP 166
95744: PUSH
95745: LD_VAR 0 4
95749: ARRAY
95750: PUSH
95751: LD_VAR 0 3
95755: ARRAY
95756: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
95757: LD_VAR 0 5
95761: PUSH
95762: LD_INT 1
95764: ARRAY
95765: PPUSH
95766: CALL_OW 302
95770: NOT
95771: PUSH
95772: LD_VAR 0 5
95776: PUSH
95777: LD_INT 1
95779: ARRAY
95780: PPUSH
95781: CALL_OW 255
95785: PUSH
95786: LD_VAR 0 1
95790: PPUSH
95791: CALL_OW 255
95795: NONEQUAL
95796: OR
95797: IFFALSE 95903
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
95799: LD_VAR 0 5
95803: PUSH
95804: LD_INT 1
95806: ARRAY
95807: PPUSH
95808: CALL_OW 305
95812: PUSH
95813: LD_VAR 0 5
95817: PUSH
95818: LD_INT 1
95820: ARRAY
95821: PPUSH
95822: CALL_OW 255
95826: PUSH
95827: LD_VAR 0 1
95831: PPUSH
95832: CALL_OW 255
95836: EQUAL
95837: AND
95838: IFFALSE 95862
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
95840: LD_VAR 0 5
95844: PUSH
95845: LD_INT 1
95847: ARRAY
95848: PPUSH
95849: LD_VAR 0 5
95853: PUSH
95854: LD_INT 2
95856: ARRAY
95857: PPUSH
95858: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
95862: LD_ADDR_EXP 166
95866: PUSH
95867: LD_EXP 166
95871: PPUSH
95872: LD_VAR 0 4
95876: PPUSH
95877: LD_EXP 166
95881: PUSH
95882: LD_VAR 0 4
95886: ARRAY
95887: PPUSH
95888: LD_VAR 0 3
95892: PPUSH
95893: CALL_OW 3
95897: PPUSH
95898: CALL_OW 1
95902: ST_TO_ADDR
// end ; end ;
95903: GO 95732
95905: POP
95906: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
95907: LD_VAR 0 1
95911: PPUSH
95912: LD_EXP 166
95916: PUSH
95917: LD_VAR 0 4
95921: ARRAY
95922: PUSH
95923: LD_INT 0
95925: PLUS
95926: PPUSH
95927: CALL_OW 505
// end ;
95931: LD_VAR 0 2
95935: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
95936: LD_INT 0
95938: PPUSH
95939: PPUSH
95940: PPUSH
95941: PPUSH
// if not hack in hackTanks then
95942: LD_VAR 0 1
95946: PUSH
95947: LD_EXP 165
95951: IN
95952: NOT
95953: IFFALSE 95957
// exit ;
95955: GO 96042
// index := GetElementIndex ( hackTanks , hack ) ;
95957: LD_ADDR_VAR 0 5
95961: PUSH
95962: LD_EXP 165
95966: PPUSH
95967: LD_VAR 0 1
95971: PPUSH
95972: CALL 18333 0 2
95976: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
95977: LD_ADDR_VAR 0 4
95981: PUSH
95982: DOUBLE
95983: LD_INT 1
95985: DEC
95986: ST_TO_ADDR
95987: LD_EXP 166
95991: PUSH
95992: LD_VAR 0 5
95996: ARRAY
95997: PUSH
95998: FOR_TO
95999: IFFALSE 96040
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
96001: LD_EXP 166
96005: PUSH
96006: LD_VAR 0 5
96010: ARRAY
96011: PUSH
96012: LD_VAR 0 4
96016: ARRAY
96017: PUSH
96018: LD_INT 1
96020: ARRAY
96021: PUSH
96022: LD_VAR 0 2
96026: EQUAL
96027: IFFALSE 96038
// KillUnit ( vehicle ) ;
96029: LD_VAR 0 2
96033: PPUSH
96034: CALL_OW 66
96038: GO 95998
96040: POP
96041: POP
// end ;
96042: LD_VAR 0 3
96046: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
96047: LD_EXP 170
96051: NOT
96052: IFFALSE 96087
96054: GO 96056
96056: DISABLE
// begin initMiner := true ;
96057: LD_ADDR_EXP 170
96061: PUSH
96062: LD_INT 1
96064: ST_TO_ADDR
// minersList := [ ] ;
96065: LD_ADDR_EXP 171
96069: PUSH
96070: EMPTY
96071: ST_TO_ADDR
// minerMinesList := [ ] ;
96072: LD_ADDR_EXP 172
96076: PUSH
96077: EMPTY
96078: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
96079: LD_ADDR_EXP 173
96083: PUSH
96084: LD_INT 5
96086: ST_TO_ADDR
// end ;
96087: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
96088: LD_EXP 170
96092: PUSH
96093: LD_INT 34
96095: PUSH
96096: LD_EXP 55
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: PPUSH
96105: CALL_OW 69
96109: AND
96110: IFFALSE 96573
96112: GO 96114
96114: DISABLE
96115: LD_INT 0
96117: PPUSH
96118: PPUSH
96119: PPUSH
96120: PPUSH
// begin enable ;
96121: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
96122: LD_ADDR_VAR 0 1
96126: PUSH
96127: LD_INT 34
96129: PUSH
96130: LD_EXP 55
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PPUSH
96139: CALL_OW 69
96143: PUSH
96144: FOR_IN
96145: IFFALSE 96217
// begin if not i in minersList then
96147: LD_VAR 0 1
96151: PUSH
96152: LD_EXP 171
96156: IN
96157: NOT
96158: IFFALSE 96215
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
96160: LD_ADDR_EXP 171
96164: PUSH
96165: LD_EXP 171
96169: PPUSH
96170: LD_EXP 171
96174: PUSH
96175: LD_INT 1
96177: PLUS
96178: PPUSH
96179: LD_VAR 0 1
96183: PPUSH
96184: CALL_OW 1
96188: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
96189: LD_ADDR_EXP 172
96193: PUSH
96194: LD_EXP 172
96198: PPUSH
96199: LD_EXP 172
96203: PUSH
96204: LD_INT 1
96206: PLUS
96207: PPUSH
96208: EMPTY
96209: PPUSH
96210: CALL_OW 1
96214: ST_TO_ADDR
// end end ;
96215: GO 96144
96217: POP
96218: POP
// for i := minerMinesList downto 1 do
96219: LD_ADDR_VAR 0 1
96223: PUSH
96224: DOUBLE
96225: LD_EXP 172
96229: INC
96230: ST_TO_ADDR
96231: LD_INT 1
96233: PUSH
96234: FOR_DOWNTO
96235: IFFALSE 96571
// begin if IsLive ( minersList [ i ] ) then
96237: LD_EXP 171
96241: PUSH
96242: LD_VAR 0 1
96246: ARRAY
96247: PPUSH
96248: CALL_OW 300
96252: IFFALSE 96280
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
96254: LD_EXP 171
96258: PUSH
96259: LD_VAR 0 1
96263: ARRAY
96264: PPUSH
96265: LD_EXP 172
96269: PUSH
96270: LD_VAR 0 1
96274: ARRAY
96275: PPUSH
96276: CALL_OW 505
// if not minerMinesList [ i ] then
96280: LD_EXP 172
96284: PUSH
96285: LD_VAR 0 1
96289: ARRAY
96290: NOT
96291: IFFALSE 96295
// continue ;
96293: GO 96234
// for j := minerMinesList [ i ] downto 1 do
96295: LD_ADDR_VAR 0 2
96299: PUSH
96300: DOUBLE
96301: LD_EXP 172
96305: PUSH
96306: LD_VAR 0 1
96310: ARRAY
96311: INC
96312: ST_TO_ADDR
96313: LD_INT 1
96315: PUSH
96316: FOR_DOWNTO
96317: IFFALSE 96567
// begin side := GetSide ( minersList [ i ] ) ;
96319: LD_ADDR_VAR 0 3
96323: PUSH
96324: LD_EXP 171
96328: PUSH
96329: LD_VAR 0 1
96333: ARRAY
96334: PPUSH
96335: CALL_OW 255
96339: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
96340: LD_ADDR_VAR 0 4
96344: PUSH
96345: LD_EXP 172
96349: PUSH
96350: LD_VAR 0 1
96354: ARRAY
96355: PUSH
96356: LD_VAR 0 2
96360: ARRAY
96361: PUSH
96362: LD_INT 1
96364: ARRAY
96365: PPUSH
96366: LD_EXP 172
96370: PUSH
96371: LD_VAR 0 1
96375: ARRAY
96376: PUSH
96377: LD_VAR 0 2
96381: ARRAY
96382: PUSH
96383: LD_INT 2
96385: ARRAY
96386: PPUSH
96387: CALL_OW 428
96391: ST_TO_ADDR
// if not tmp then
96392: LD_VAR 0 4
96396: NOT
96397: IFFALSE 96401
// continue ;
96399: GO 96316
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
96401: LD_VAR 0 4
96405: PUSH
96406: LD_INT 81
96408: PUSH
96409: LD_VAR 0 3
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: PPUSH
96418: CALL_OW 69
96422: IN
96423: PUSH
96424: LD_EXP 172
96428: PUSH
96429: LD_VAR 0 1
96433: ARRAY
96434: PUSH
96435: LD_VAR 0 2
96439: ARRAY
96440: PUSH
96441: LD_INT 1
96443: ARRAY
96444: PPUSH
96445: LD_EXP 172
96449: PUSH
96450: LD_VAR 0 1
96454: ARRAY
96455: PUSH
96456: LD_VAR 0 2
96460: ARRAY
96461: PUSH
96462: LD_INT 2
96464: ARRAY
96465: PPUSH
96466: CALL_OW 458
96470: AND
96471: IFFALSE 96565
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
96473: LD_EXP 172
96477: PUSH
96478: LD_VAR 0 1
96482: ARRAY
96483: PUSH
96484: LD_VAR 0 2
96488: ARRAY
96489: PUSH
96490: LD_INT 1
96492: ARRAY
96493: PPUSH
96494: LD_EXP 172
96498: PUSH
96499: LD_VAR 0 1
96503: ARRAY
96504: PUSH
96505: LD_VAR 0 2
96509: ARRAY
96510: PUSH
96511: LD_INT 2
96513: ARRAY
96514: PPUSH
96515: LD_VAR 0 3
96519: PPUSH
96520: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
96524: LD_ADDR_EXP 172
96528: PUSH
96529: LD_EXP 172
96533: PPUSH
96534: LD_VAR 0 1
96538: PPUSH
96539: LD_EXP 172
96543: PUSH
96544: LD_VAR 0 1
96548: ARRAY
96549: PPUSH
96550: LD_VAR 0 2
96554: PPUSH
96555: CALL_OW 3
96559: PPUSH
96560: CALL_OW 1
96564: ST_TO_ADDR
// end ; end ;
96565: GO 96316
96567: POP
96568: POP
// end ;
96569: GO 96234
96571: POP
96572: POP
// end ;
96573: PPOPN 4
96575: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
96576: LD_INT 0
96578: PPUSH
96579: PPUSH
// result := false ;
96580: LD_ADDR_VAR 0 4
96584: PUSH
96585: LD_INT 0
96587: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
96588: LD_VAR 0 1
96592: PPUSH
96593: CALL_OW 264
96597: PUSH
96598: LD_EXP 55
96602: EQUAL
96603: NOT
96604: IFFALSE 96608
// exit ;
96606: GO 96848
// index := GetElementIndex ( minersList , unit ) ;
96608: LD_ADDR_VAR 0 5
96612: PUSH
96613: LD_EXP 171
96617: PPUSH
96618: LD_VAR 0 1
96622: PPUSH
96623: CALL 18333 0 2
96627: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
96628: LD_EXP 172
96632: PUSH
96633: LD_VAR 0 5
96637: ARRAY
96638: PUSH
96639: LD_EXP 173
96643: GREATEREQUAL
96644: IFFALSE 96648
// exit ;
96646: GO 96848
// ComMoveXY ( unit , x , y ) ;
96648: LD_VAR 0 1
96652: PPUSH
96653: LD_VAR 0 2
96657: PPUSH
96658: LD_VAR 0 3
96662: PPUSH
96663: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
96667: LD_INT 35
96669: PPUSH
96670: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
96674: LD_VAR 0 1
96678: PPUSH
96679: LD_VAR 0 2
96683: PPUSH
96684: LD_VAR 0 3
96688: PPUSH
96689: CALL 48397 0 3
96693: NOT
96694: PUSH
96695: LD_VAR 0 1
96699: PPUSH
96700: CALL_OW 314
96704: AND
96705: IFFALSE 96709
// exit ;
96707: GO 96848
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
96709: LD_VAR 0 2
96713: PPUSH
96714: LD_VAR 0 3
96718: PPUSH
96719: CALL_OW 428
96723: PUSH
96724: LD_VAR 0 1
96728: EQUAL
96729: PUSH
96730: LD_VAR 0 1
96734: PPUSH
96735: CALL_OW 314
96739: NOT
96740: AND
96741: IFFALSE 96667
// PlaySoundXY ( x , y , PlantMine ) ;
96743: LD_VAR 0 2
96747: PPUSH
96748: LD_VAR 0 3
96752: PPUSH
96753: LD_STRING PlantMine
96755: PPUSH
96756: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
96760: LD_VAR 0 2
96764: PPUSH
96765: LD_VAR 0 3
96769: PPUSH
96770: LD_VAR 0 1
96774: PPUSH
96775: CALL_OW 255
96779: PPUSH
96780: LD_INT 0
96782: PPUSH
96783: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
96787: LD_ADDR_EXP 172
96791: PUSH
96792: LD_EXP 172
96796: PPUSH
96797: LD_VAR 0 5
96801: PUSH
96802: LD_EXP 172
96806: PUSH
96807: LD_VAR 0 5
96811: ARRAY
96812: PUSH
96813: LD_INT 1
96815: PLUS
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: PPUSH
96821: LD_VAR 0 2
96825: PUSH
96826: LD_VAR 0 3
96830: PUSH
96831: EMPTY
96832: LIST
96833: LIST
96834: PPUSH
96835: CALL 18548 0 3
96839: ST_TO_ADDR
// result := true ;
96840: LD_ADDR_VAR 0 4
96844: PUSH
96845: LD_INT 1
96847: ST_TO_ADDR
// end ;
96848: LD_VAR 0 4
96852: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
96853: LD_INT 0
96855: PPUSH
96856: PPUSH
96857: PPUSH
// if not unit in minersList then
96858: LD_VAR 0 1
96862: PUSH
96863: LD_EXP 171
96867: IN
96868: NOT
96869: IFFALSE 96873
// exit ;
96871: GO 97265
// index := GetElementIndex ( minersList , unit ) ;
96873: LD_ADDR_VAR 0 6
96877: PUSH
96878: LD_EXP 171
96882: PPUSH
96883: LD_VAR 0 1
96887: PPUSH
96888: CALL 18333 0 2
96892: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
96893: LD_ADDR_VAR 0 5
96897: PUSH
96898: DOUBLE
96899: LD_EXP 172
96903: PUSH
96904: LD_VAR 0 6
96908: ARRAY
96909: INC
96910: ST_TO_ADDR
96911: LD_INT 1
96913: PUSH
96914: FOR_DOWNTO
96915: IFFALSE 97076
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
96917: LD_EXP 172
96921: PUSH
96922: LD_VAR 0 6
96926: ARRAY
96927: PUSH
96928: LD_VAR 0 5
96932: ARRAY
96933: PUSH
96934: LD_INT 1
96936: ARRAY
96937: PUSH
96938: LD_VAR 0 2
96942: EQUAL
96943: PUSH
96944: LD_EXP 172
96948: PUSH
96949: LD_VAR 0 6
96953: ARRAY
96954: PUSH
96955: LD_VAR 0 5
96959: ARRAY
96960: PUSH
96961: LD_INT 2
96963: ARRAY
96964: PUSH
96965: LD_VAR 0 3
96969: EQUAL
96970: AND
96971: IFFALSE 97074
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
96973: LD_EXP 172
96977: PUSH
96978: LD_VAR 0 6
96982: ARRAY
96983: PUSH
96984: LD_VAR 0 5
96988: ARRAY
96989: PUSH
96990: LD_INT 1
96992: ARRAY
96993: PPUSH
96994: LD_EXP 172
96998: PUSH
96999: LD_VAR 0 6
97003: ARRAY
97004: PUSH
97005: LD_VAR 0 5
97009: ARRAY
97010: PUSH
97011: LD_INT 2
97013: ARRAY
97014: PPUSH
97015: LD_VAR 0 1
97019: PPUSH
97020: CALL_OW 255
97024: PPUSH
97025: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97029: LD_ADDR_EXP 172
97033: PUSH
97034: LD_EXP 172
97038: PPUSH
97039: LD_VAR 0 6
97043: PPUSH
97044: LD_EXP 172
97048: PUSH
97049: LD_VAR 0 6
97053: ARRAY
97054: PPUSH
97055: LD_VAR 0 5
97059: PPUSH
97060: CALL_OW 3
97064: PPUSH
97065: CALL_OW 1
97069: ST_TO_ADDR
// exit ;
97070: POP
97071: POP
97072: GO 97265
// end ; end ;
97074: GO 96914
97076: POP
97077: POP
// for i := minerMinesList [ index ] downto 1 do
97078: LD_ADDR_VAR 0 5
97082: PUSH
97083: DOUBLE
97084: LD_EXP 172
97088: PUSH
97089: LD_VAR 0 6
97093: ARRAY
97094: INC
97095: ST_TO_ADDR
97096: LD_INT 1
97098: PUSH
97099: FOR_DOWNTO
97100: IFFALSE 97263
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
97102: LD_EXP 172
97106: PUSH
97107: LD_VAR 0 6
97111: ARRAY
97112: PUSH
97113: LD_VAR 0 5
97117: ARRAY
97118: PUSH
97119: LD_INT 1
97121: ARRAY
97122: PPUSH
97123: LD_EXP 172
97127: PUSH
97128: LD_VAR 0 6
97132: ARRAY
97133: PUSH
97134: LD_VAR 0 5
97138: ARRAY
97139: PUSH
97140: LD_INT 2
97142: ARRAY
97143: PPUSH
97144: LD_VAR 0 2
97148: PPUSH
97149: LD_VAR 0 3
97153: PPUSH
97154: CALL_OW 298
97158: PUSH
97159: LD_INT 6
97161: LESS
97162: IFFALSE 97261
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97164: LD_EXP 172
97168: PUSH
97169: LD_VAR 0 6
97173: ARRAY
97174: PUSH
97175: LD_VAR 0 5
97179: ARRAY
97180: PUSH
97181: LD_INT 1
97183: ARRAY
97184: PPUSH
97185: LD_EXP 172
97189: PUSH
97190: LD_VAR 0 6
97194: ARRAY
97195: PUSH
97196: LD_VAR 0 5
97200: ARRAY
97201: PUSH
97202: LD_INT 2
97204: ARRAY
97205: PPUSH
97206: LD_VAR 0 1
97210: PPUSH
97211: CALL_OW 255
97215: PPUSH
97216: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97220: LD_ADDR_EXP 172
97224: PUSH
97225: LD_EXP 172
97229: PPUSH
97230: LD_VAR 0 6
97234: PPUSH
97235: LD_EXP 172
97239: PUSH
97240: LD_VAR 0 6
97244: ARRAY
97245: PPUSH
97246: LD_VAR 0 5
97250: PPUSH
97251: CALL_OW 3
97255: PPUSH
97256: CALL_OW 1
97260: ST_TO_ADDR
// end ; end ;
97261: GO 97099
97263: POP
97264: POP
// end ;
97265: LD_VAR 0 4
97269: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
97270: LD_INT 0
97272: PPUSH
97273: PPUSH
97274: PPUSH
97275: PPUSH
97276: PPUSH
97277: PPUSH
97278: PPUSH
97279: PPUSH
97280: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
97281: LD_VAR 0 1
97285: PPUSH
97286: CALL_OW 264
97290: PUSH
97291: LD_EXP 55
97295: EQUAL
97296: NOT
97297: PUSH
97298: LD_VAR 0 1
97302: PUSH
97303: LD_EXP 171
97307: IN
97308: NOT
97309: OR
97310: IFFALSE 97314
// exit ;
97312: GO 97636
// index := GetElementIndex ( minersList , unit ) ;
97314: LD_ADDR_VAR 0 6
97318: PUSH
97319: LD_EXP 171
97323: PPUSH
97324: LD_VAR 0 1
97328: PPUSH
97329: CALL 18333 0 2
97333: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
97334: LD_ADDR_VAR 0 8
97338: PUSH
97339: LD_EXP 173
97343: PUSH
97344: LD_EXP 172
97348: PUSH
97349: LD_VAR 0 6
97353: ARRAY
97354: MINUS
97355: ST_TO_ADDR
// if not minesFreeAmount then
97356: LD_VAR 0 8
97360: NOT
97361: IFFALSE 97365
// exit ;
97363: GO 97636
// tmp := [ ] ;
97365: LD_ADDR_VAR 0 7
97369: PUSH
97370: EMPTY
97371: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
97372: LD_ADDR_VAR 0 5
97376: PUSH
97377: DOUBLE
97378: LD_INT 1
97380: DEC
97381: ST_TO_ADDR
97382: LD_VAR 0 8
97386: PUSH
97387: FOR_TO
97388: IFFALSE 97583
// begin _d := rand ( 0 , 5 ) ;
97390: LD_ADDR_VAR 0 11
97394: PUSH
97395: LD_INT 0
97397: PPUSH
97398: LD_INT 5
97400: PPUSH
97401: CALL_OW 12
97405: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
97406: LD_ADDR_VAR 0 12
97410: PUSH
97411: LD_INT 2
97413: PPUSH
97414: LD_INT 6
97416: PPUSH
97417: CALL_OW 12
97421: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
97422: LD_ADDR_VAR 0 9
97426: PUSH
97427: LD_VAR 0 2
97431: PPUSH
97432: LD_VAR 0 11
97436: PPUSH
97437: LD_VAR 0 12
97441: PPUSH
97442: CALL_OW 272
97446: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
97447: LD_ADDR_VAR 0 10
97451: PUSH
97452: LD_VAR 0 3
97456: PPUSH
97457: LD_VAR 0 11
97461: PPUSH
97462: LD_VAR 0 12
97466: PPUSH
97467: CALL_OW 273
97471: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
97472: LD_VAR 0 9
97476: PPUSH
97477: LD_VAR 0 10
97481: PPUSH
97482: CALL_OW 488
97486: PUSH
97487: LD_VAR 0 9
97491: PUSH
97492: LD_VAR 0 10
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: LD_VAR 0 7
97505: IN
97506: NOT
97507: AND
97508: PUSH
97509: LD_VAR 0 9
97513: PPUSH
97514: LD_VAR 0 10
97518: PPUSH
97519: CALL_OW 458
97523: NOT
97524: AND
97525: IFFALSE 97567
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
97527: LD_ADDR_VAR 0 7
97531: PUSH
97532: LD_VAR 0 7
97536: PPUSH
97537: LD_VAR 0 7
97541: PUSH
97542: LD_INT 1
97544: PLUS
97545: PPUSH
97546: LD_VAR 0 9
97550: PUSH
97551: LD_VAR 0 10
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: PPUSH
97560: CALL_OW 1
97564: ST_TO_ADDR
97565: GO 97581
// i := i - 1 ;
97567: LD_ADDR_VAR 0 5
97571: PUSH
97572: LD_VAR 0 5
97576: PUSH
97577: LD_INT 1
97579: MINUS
97580: ST_TO_ADDR
// end ;
97581: GO 97387
97583: POP
97584: POP
// for i in tmp do
97585: LD_ADDR_VAR 0 5
97589: PUSH
97590: LD_VAR 0 7
97594: PUSH
97595: FOR_IN
97596: IFFALSE 97634
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
97598: LD_VAR 0 1
97602: PPUSH
97603: LD_VAR 0 5
97607: PUSH
97608: LD_INT 1
97610: ARRAY
97611: PPUSH
97612: LD_VAR 0 5
97616: PUSH
97617: LD_INT 2
97619: ARRAY
97620: PPUSH
97621: CALL 96576 0 3
97625: NOT
97626: IFFALSE 97632
// exit ;
97628: POP
97629: POP
97630: GO 97636
97632: GO 97595
97634: POP
97635: POP
// end ;
97636: LD_VAR 0 4
97640: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
97641: LD_INT 0
97643: PPUSH
97644: PPUSH
97645: PPUSH
97646: PPUSH
97647: PPUSH
97648: PPUSH
97649: PPUSH
// if not GetClass ( unit ) = class_sniper then
97650: LD_VAR 0 1
97654: PPUSH
97655: CALL_OW 257
97659: PUSH
97660: LD_INT 5
97662: EQUAL
97663: NOT
97664: IFFALSE 97668
// exit ;
97666: GO 98056
// dist := 8 ;
97668: LD_ADDR_VAR 0 5
97672: PUSH
97673: LD_INT 8
97675: ST_TO_ADDR
// viewRange := 12 ;
97676: LD_ADDR_VAR 0 7
97680: PUSH
97681: LD_INT 12
97683: ST_TO_ADDR
// side := GetSide ( unit ) ;
97684: LD_ADDR_VAR 0 6
97688: PUSH
97689: LD_VAR 0 1
97693: PPUSH
97694: CALL_OW 255
97698: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
97699: LD_INT 61
97701: PPUSH
97702: LD_VAR 0 6
97706: PPUSH
97707: CALL_OW 321
97711: PUSH
97712: LD_INT 2
97714: EQUAL
97715: IFFALSE 97725
// viewRange := 16 ;
97717: LD_ADDR_VAR 0 7
97721: PUSH
97722: LD_INT 16
97724: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
97725: LD_VAR 0 1
97729: PPUSH
97730: LD_VAR 0 2
97734: PPUSH
97735: LD_VAR 0 3
97739: PPUSH
97740: CALL_OW 297
97744: PUSH
97745: LD_VAR 0 5
97749: GREATER
97750: IFFALSE 97829
// begin ComMoveXY ( unit , x , y ) ;
97752: LD_VAR 0 1
97756: PPUSH
97757: LD_VAR 0 2
97761: PPUSH
97762: LD_VAR 0 3
97766: PPUSH
97767: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97771: LD_INT 35
97773: PPUSH
97774: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
97778: LD_VAR 0 1
97782: PPUSH
97783: LD_VAR 0 2
97787: PPUSH
97788: LD_VAR 0 3
97792: PPUSH
97793: CALL 48397 0 3
97797: NOT
97798: IFFALSE 97802
// exit ;
97800: GO 98056
// until GetDistUnitXY ( unit , x , y ) < dist ;
97802: LD_VAR 0 1
97806: PPUSH
97807: LD_VAR 0 2
97811: PPUSH
97812: LD_VAR 0 3
97816: PPUSH
97817: CALL_OW 297
97821: PUSH
97822: LD_VAR 0 5
97826: LESS
97827: IFFALSE 97771
// end ; ComTurnXY ( unit , x , y ) ;
97829: LD_VAR 0 1
97833: PPUSH
97834: LD_VAR 0 2
97838: PPUSH
97839: LD_VAR 0 3
97843: PPUSH
97844: CALL_OW 118
// wait ( 5 ) ;
97848: LD_INT 5
97850: PPUSH
97851: CALL_OW 67
// _d := GetDir ( unit ) ;
97855: LD_ADDR_VAR 0 10
97859: PUSH
97860: LD_VAR 0 1
97864: PPUSH
97865: CALL_OW 254
97869: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
97870: LD_ADDR_VAR 0 8
97874: PUSH
97875: LD_VAR 0 1
97879: PPUSH
97880: CALL_OW 250
97884: PPUSH
97885: LD_VAR 0 10
97889: PPUSH
97890: LD_VAR 0 5
97894: PPUSH
97895: CALL_OW 272
97899: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
97900: LD_ADDR_VAR 0 9
97904: PUSH
97905: LD_VAR 0 1
97909: PPUSH
97910: CALL_OW 251
97914: PPUSH
97915: LD_VAR 0 10
97919: PPUSH
97920: LD_VAR 0 5
97924: PPUSH
97925: CALL_OW 273
97929: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
97930: LD_VAR 0 8
97934: PPUSH
97935: LD_VAR 0 9
97939: PPUSH
97940: CALL_OW 488
97944: NOT
97945: IFFALSE 97949
// exit ;
97947: GO 98056
// ComAnimCustom ( unit , 1 ) ;
97949: LD_VAR 0 1
97953: PPUSH
97954: LD_INT 1
97956: PPUSH
97957: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
97961: LD_VAR 0 8
97965: PPUSH
97966: LD_VAR 0 9
97970: PPUSH
97971: LD_VAR 0 6
97975: PPUSH
97976: LD_VAR 0 7
97980: PPUSH
97981: CALL_OW 330
// repeat wait ( 1 ) ;
97985: LD_INT 1
97987: PPUSH
97988: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
97992: LD_VAR 0 1
97996: PPUSH
97997: CALL_OW 316
98001: PUSH
98002: LD_VAR 0 1
98006: PPUSH
98007: CALL_OW 314
98011: OR
98012: PUSH
98013: LD_VAR 0 1
98017: PPUSH
98018: CALL_OW 302
98022: NOT
98023: OR
98024: PUSH
98025: LD_VAR 0 1
98029: PPUSH
98030: CALL_OW 301
98034: OR
98035: IFFALSE 97985
// RemoveSeeing ( _x , _y , side ) ;
98037: LD_VAR 0 8
98041: PPUSH
98042: LD_VAR 0 9
98046: PPUSH
98047: LD_VAR 0 6
98051: PPUSH
98052: CALL_OW 331
// end ; end_of_file
98056: LD_VAR 0 4
98060: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98061: LD_INT 0
98063: PPUSH
98064: PPUSH
98065: PPUSH
98066: PPUSH
98067: PPUSH
98068: PPUSH
98069: PPUSH
98070: PPUSH
98071: PPUSH
98072: PPUSH
98073: PPUSH
98074: PPUSH
98075: PPUSH
98076: PPUSH
98077: PPUSH
98078: PPUSH
98079: PPUSH
98080: PPUSH
98081: PPUSH
98082: PPUSH
98083: PPUSH
98084: PPUSH
98085: PPUSH
98086: PPUSH
98087: PPUSH
98088: PPUSH
98089: PPUSH
98090: PPUSH
98091: PPUSH
98092: PPUSH
98093: PPUSH
98094: PPUSH
98095: PPUSH
98096: PPUSH
// if not list then
98097: LD_VAR 0 1
98101: NOT
98102: IFFALSE 98106
// exit ;
98104: GO 102765
// base := list [ 1 ] ;
98106: LD_ADDR_VAR 0 3
98110: PUSH
98111: LD_VAR 0 1
98115: PUSH
98116: LD_INT 1
98118: ARRAY
98119: ST_TO_ADDR
// group := list [ 2 ] ;
98120: LD_ADDR_VAR 0 4
98124: PUSH
98125: LD_VAR 0 1
98129: PUSH
98130: LD_INT 2
98132: ARRAY
98133: ST_TO_ADDR
// path := list [ 3 ] ;
98134: LD_ADDR_VAR 0 5
98138: PUSH
98139: LD_VAR 0 1
98143: PUSH
98144: LD_INT 3
98146: ARRAY
98147: ST_TO_ADDR
// flags := list [ 4 ] ;
98148: LD_ADDR_VAR 0 6
98152: PUSH
98153: LD_VAR 0 1
98157: PUSH
98158: LD_INT 4
98160: ARRAY
98161: ST_TO_ADDR
// mined := [ ] ;
98162: LD_ADDR_VAR 0 27
98166: PUSH
98167: EMPTY
98168: ST_TO_ADDR
// bombed := [ ] ;
98169: LD_ADDR_VAR 0 28
98173: PUSH
98174: EMPTY
98175: ST_TO_ADDR
// healers := [ ] ;
98176: LD_ADDR_VAR 0 31
98180: PUSH
98181: EMPTY
98182: ST_TO_ADDR
// to_heal := [ ] ;
98183: LD_ADDR_VAR 0 30
98187: PUSH
98188: EMPTY
98189: ST_TO_ADDR
// repairs := [ ] ;
98190: LD_ADDR_VAR 0 33
98194: PUSH
98195: EMPTY
98196: ST_TO_ADDR
// to_repair := [ ] ;
98197: LD_ADDR_VAR 0 32
98201: PUSH
98202: EMPTY
98203: ST_TO_ADDR
// if not group or not path then
98204: LD_VAR 0 4
98208: NOT
98209: PUSH
98210: LD_VAR 0 5
98214: NOT
98215: OR
98216: IFFALSE 98220
// exit ;
98218: GO 102765
// side := GetSide ( group [ 1 ] ) ;
98220: LD_ADDR_VAR 0 35
98224: PUSH
98225: LD_VAR 0 4
98229: PUSH
98230: LD_INT 1
98232: ARRAY
98233: PPUSH
98234: CALL_OW 255
98238: ST_TO_ADDR
// if flags then
98239: LD_VAR 0 6
98243: IFFALSE 98387
// begin f_ignore_area := flags [ 1 ] ;
98245: LD_ADDR_VAR 0 17
98249: PUSH
98250: LD_VAR 0 6
98254: PUSH
98255: LD_INT 1
98257: ARRAY
98258: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98259: LD_ADDR_VAR 0 18
98263: PUSH
98264: LD_VAR 0 6
98268: PUSH
98269: LD_INT 2
98271: ARRAY
98272: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98273: LD_ADDR_VAR 0 19
98277: PUSH
98278: LD_VAR 0 6
98282: PUSH
98283: LD_INT 3
98285: ARRAY
98286: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98287: LD_ADDR_VAR 0 20
98291: PUSH
98292: LD_VAR 0 6
98296: PUSH
98297: LD_INT 4
98299: ARRAY
98300: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98301: LD_ADDR_VAR 0 21
98305: PUSH
98306: LD_VAR 0 6
98310: PUSH
98311: LD_INT 5
98313: ARRAY
98314: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98315: LD_ADDR_VAR 0 22
98319: PUSH
98320: LD_VAR 0 6
98324: PUSH
98325: LD_INT 6
98327: ARRAY
98328: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98329: LD_ADDR_VAR 0 23
98333: PUSH
98334: LD_VAR 0 6
98338: PUSH
98339: LD_INT 7
98341: ARRAY
98342: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98343: LD_ADDR_VAR 0 24
98347: PUSH
98348: LD_VAR 0 6
98352: PUSH
98353: LD_INT 8
98355: ARRAY
98356: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98357: LD_ADDR_VAR 0 25
98361: PUSH
98362: LD_VAR 0 6
98366: PUSH
98367: LD_INT 9
98369: ARRAY
98370: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98371: LD_ADDR_VAR 0 26
98375: PUSH
98376: LD_VAR 0 6
98380: PUSH
98381: LD_INT 10
98383: ARRAY
98384: ST_TO_ADDR
// end else
98385: GO 98467
// begin f_ignore_area := false ;
98387: LD_ADDR_VAR 0 17
98391: PUSH
98392: LD_INT 0
98394: ST_TO_ADDR
// f_capture := false ;
98395: LD_ADDR_VAR 0 18
98399: PUSH
98400: LD_INT 0
98402: ST_TO_ADDR
// f_ignore_civ := false ;
98403: LD_ADDR_VAR 0 19
98407: PUSH
98408: LD_INT 0
98410: ST_TO_ADDR
// f_murder := false ;
98411: LD_ADDR_VAR 0 20
98415: PUSH
98416: LD_INT 0
98418: ST_TO_ADDR
// f_mines := false ;
98419: LD_ADDR_VAR 0 21
98423: PUSH
98424: LD_INT 0
98426: ST_TO_ADDR
// f_repair := false ;
98427: LD_ADDR_VAR 0 22
98431: PUSH
98432: LD_INT 0
98434: ST_TO_ADDR
// f_heal := false ;
98435: LD_ADDR_VAR 0 23
98439: PUSH
98440: LD_INT 0
98442: ST_TO_ADDR
// f_spacetime := false ;
98443: LD_ADDR_VAR 0 24
98447: PUSH
98448: LD_INT 0
98450: ST_TO_ADDR
// f_attack_depot := false ;
98451: LD_ADDR_VAR 0 25
98455: PUSH
98456: LD_INT 0
98458: ST_TO_ADDR
// f_crawl := false ;
98459: LD_ADDR_VAR 0 26
98463: PUSH
98464: LD_INT 0
98466: ST_TO_ADDR
// end ; if f_heal then
98467: LD_VAR 0 23
98471: IFFALSE 98498
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98473: LD_ADDR_VAR 0 31
98477: PUSH
98478: LD_VAR 0 4
98482: PPUSH
98483: LD_INT 25
98485: PUSH
98486: LD_INT 4
98488: PUSH
98489: EMPTY
98490: LIST
98491: LIST
98492: PPUSH
98493: CALL_OW 72
98497: ST_TO_ADDR
// if f_repair then
98498: LD_VAR 0 22
98502: IFFALSE 98529
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98504: LD_ADDR_VAR 0 33
98508: PUSH
98509: LD_VAR 0 4
98513: PPUSH
98514: LD_INT 25
98516: PUSH
98517: LD_INT 3
98519: PUSH
98520: EMPTY
98521: LIST
98522: LIST
98523: PPUSH
98524: CALL_OW 72
98528: ST_TO_ADDR
// units_path := [ ] ;
98529: LD_ADDR_VAR 0 16
98533: PUSH
98534: EMPTY
98535: ST_TO_ADDR
// for i = 1 to group do
98536: LD_ADDR_VAR 0 7
98540: PUSH
98541: DOUBLE
98542: LD_INT 1
98544: DEC
98545: ST_TO_ADDR
98546: LD_VAR 0 4
98550: PUSH
98551: FOR_TO
98552: IFFALSE 98581
// units_path := Replace ( units_path , i , path ) ;
98554: LD_ADDR_VAR 0 16
98558: PUSH
98559: LD_VAR 0 16
98563: PPUSH
98564: LD_VAR 0 7
98568: PPUSH
98569: LD_VAR 0 5
98573: PPUSH
98574: CALL_OW 1
98578: ST_TO_ADDR
98579: GO 98551
98581: POP
98582: POP
// repeat for i = group downto 1 do
98583: LD_ADDR_VAR 0 7
98587: PUSH
98588: DOUBLE
98589: LD_VAR 0 4
98593: INC
98594: ST_TO_ADDR
98595: LD_INT 1
98597: PUSH
98598: FOR_DOWNTO
98599: IFFALSE 102721
// begin wait ( 5 ) ;
98601: LD_INT 5
98603: PPUSH
98604: CALL_OW 67
// tmp := [ ] ;
98608: LD_ADDR_VAR 0 14
98612: PUSH
98613: EMPTY
98614: ST_TO_ADDR
// attacking := false ;
98615: LD_ADDR_VAR 0 29
98619: PUSH
98620: LD_INT 0
98622: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98623: LD_VAR 0 4
98627: PUSH
98628: LD_VAR 0 7
98632: ARRAY
98633: PPUSH
98634: CALL_OW 301
98638: PUSH
98639: LD_VAR 0 4
98643: PUSH
98644: LD_VAR 0 7
98648: ARRAY
98649: NOT
98650: OR
98651: IFFALSE 98760
// begin if GetType ( group [ i ] ) = unit_human then
98653: LD_VAR 0 4
98657: PUSH
98658: LD_VAR 0 7
98662: ARRAY
98663: PPUSH
98664: CALL_OW 247
98668: PUSH
98669: LD_INT 1
98671: EQUAL
98672: IFFALSE 98718
// begin to_heal := to_heal diff group [ i ] ;
98674: LD_ADDR_VAR 0 30
98678: PUSH
98679: LD_VAR 0 30
98683: PUSH
98684: LD_VAR 0 4
98688: PUSH
98689: LD_VAR 0 7
98693: ARRAY
98694: DIFF
98695: ST_TO_ADDR
// healers := healers diff group [ i ] ;
98696: LD_ADDR_VAR 0 31
98700: PUSH
98701: LD_VAR 0 31
98705: PUSH
98706: LD_VAR 0 4
98710: PUSH
98711: LD_VAR 0 7
98715: ARRAY
98716: DIFF
98717: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
98718: LD_ADDR_VAR 0 4
98722: PUSH
98723: LD_VAR 0 4
98727: PPUSH
98728: LD_VAR 0 7
98732: PPUSH
98733: CALL_OW 3
98737: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
98738: LD_ADDR_VAR 0 16
98742: PUSH
98743: LD_VAR 0 16
98747: PPUSH
98748: LD_VAR 0 7
98752: PPUSH
98753: CALL_OW 3
98757: ST_TO_ADDR
// continue ;
98758: GO 98598
// end ; if f_repair then
98760: LD_VAR 0 22
98764: IFFALSE 99253
// begin if GetType ( group [ i ] ) = unit_vehicle then
98766: LD_VAR 0 4
98770: PUSH
98771: LD_VAR 0 7
98775: ARRAY
98776: PPUSH
98777: CALL_OW 247
98781: PUSH
98782: LD_INT 2
98784: EQUAL
98785: IFFALSE 98975
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
98787: LD_VAR 0 4
98791: PUSH
98792: LD_VAR 0 7
98796: ARRAY
98797: PPUSH
98798: CALL_OW 256
98802: PUSH
98803: LD_INT 700
98805: LESS
98806: PUSH
98807: LD_VAR 0 4
98811: PUSH
98812: LD_VAR 0 7
98816: ARRAY
98817: PUSH
98818: LD_VAR 0 32
98822: IN
98823: NOT
98824: AND
98825: IFFALSE 98849
// to_repair := to_repair union group [ i ] ;
98827: LD_ADDR_VAR 0 32
98831: PUSH
98832: LD_VAR 0 32
98836: PUSH
98837: LD_VAR 0 4
98841: PUSH
98842: LD_VAR 0 7
98846: ARRAY
98847: UNION
98848: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
98849: LD_VAR 0 4
98853: PUSH
98854: LD_VAR 0 7
98858: ARRAY
98859: PPUSH
98860: CALL_OW 256
98864: PUSH
98865: LD_INT 1000
98867: EQUAL
98868: PUSH
98869: LD_VAR 0 4
98873: PUSH
98874: LD_VAR 0 7
98878: ARRAY
98879: PUSH
98880: LD_VAR 0 32
98884: IN
98885: AND
98886: IFFALSE 98910
// to_repair := to_repair diff group [ i ] ;
98888: LD_ADDR_VAR 0 32
98892: PUSH
98893: LD_VAR 0 32
98897: PUSH
98898: LD_VAR 0 4
98902: PUSH
98903: LD_VAR 0 7
98907: ARRAY
98908: DIFF
98909: ST_TO_ADDR
// if group [ i ] in to_repair then
98910: LD_VAR 0 4
98914: PUSH
98915: LD_VAR 0 7
98919: ARRAY
98920: PUSH
98921: LD_VAR 0 32
98925: IN
98926: IFFALSE 98973
// begin if not IsInArea ( group [ i ] , f_repair ) then
98928: LD_VAR 0 4
98932: PUSH
98933: LD_VAR 0 7
98937: ARRAY
98938: PPUSH
98939: LD_VAR 0 22
98943: PPUSH
98944: CALL_OW 308
98948: NOT
98949: IFFALSE 98971
// ComMoveToArea ( group [ i ] , f_repair ) ;
98951: LD_VAR 0 4
98955: PUSH
98956: LD_VAR 0 7
98960: ARRAY
98961: PPUSH
98962: LD_VAR 0 22
98966: PPUSH
98967: CALL_OW 113
// continue ;
98971: GO 98598
// end ; end else
98973: GO 99253
// if group [ i ] in repairs then
98975: LD_VAR 0 4
98979: PUSH
98980: LD_VAR 0 7
98984: ARRAY
98985: PUSH
98986: LD_VAR 0 33
98990: IN
98991: IFFALSE 99253
// begin if IsInUnit ( group [ i ] ) then
98993: LD_VAR 0 4
98997: PUSH
98998: LD_VAR 0 7
99002: ARRAY
99003: PPUSH
99004: CALL_OW 310
99008: IFFALSE 99076
// begin z := IsInUnit ( group [ i ] ) ;
99010: LD_ADDR_VAR 0 13
99014: PUSH
99015: LD_VAR 0 4
99019: PUSH
99020: LD_VAR 0 7
99024: ARRAY
99025: PPUSH
99026: CALL_OW 310
99030: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99031: LD_VAR 0 13
99035: PUSH
99036: LD_VAR 0 32
99040: IN
99041: PUSH
99042: LD_VAR 0 13
99046: PPUSH
99047: LD_VAR 0 22
99051: PPUSH
99052: CALL_OW 308
99056: AND
99057: IFFALSE 99074
// ComExitVehicle ( group [ i ] ) ;
99059: LD_VAR 0 4
99063: PUSH
99064: LD_VAR 0 7
99068: ARRAY
99069: PPUSH
99070: CALL_OW 121
// end else
99074: GO 99253
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99076: LD_ADDR_VAR 0 13
99080: PUSH
99081: LD_VAR 0 4
99085: PPUSH
99086: LD_INT 95
99088: PUSH
99089: LD_VAR 0 22
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: PUSH
99098: LD_INT 58
99100: PUSH
99101: EMPTY
99102: LIST
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: PPUSH
99108: CALL_OW 72
99112: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99113: LD_VAR 0 4
99117: PUSH
99118: LD_VAR 0 7
99122: ARRAY
99123: PPUSH
99124: CALL_OW 314
99128: NOT
99129: IFFALSE 99251
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99131: LD_ADDR_VAR 0 10
99135: PUSH
99136: LD_VAR 0 13
99140: PPUSH
99141: LD_VAR 0 4
99145: PUSH
99146: LD_VAR 0 7
99150: ARRAY
99151: PPUSH
99152: CALL_OW 74
99156: ST_TO_ADDR
// if not x then
99157: LD_VAR 0 10
99161: NOT
99162: IFFALSE 99166
// continue ;
99164: GO 98598
// if GetLives ( x ) < 1000 then
99166: LD_VAR 0 10
99170: PPUSH
99171: CALL_OW 256
99175: PUSH
99176: LD_INT 1000
99178: LESS
99179: IFFALSE 99203
// ComRepairVehicle ( group [ i ] , x ) else
99181: LD_VAR 0 4
99185: PUSH
99186: LD_VAR 0 7
99190: ARRAY
99191: PPUSH
99192: LD_VAR 0 10
99196: PPUSH
99197: CALL_OW 129
99201: GO 99251
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99203: LD_VAR 0 23
99207: PUSH
99208: LD_VAR 0 4
99212: PUSH
99213: LD_VAR 0 7
99217: ARRAY
99218: PPUSH
99219: CALL_OW 256
99223: PUSH
99224: LD_INT 1000
99226: LESS
99227: AND
99228: NOT
99229: IFFALSE 99251
// ComEnterUnit ( group [ i ] , x ) ;
99231: LD_VAR 0 4
99235: PUSH
99236: LD_VAR 0 7
99240: ARRAY
99241: PPUSH
99242: LD_VAR 0 10
99246: PPUSH
99247: CALL_OW 120
// end ; continue ;
99251: GO 98598
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99253: LD_VAR 0 23
99257: PUSH
99258: LD_VAR 0 4
99262: PUSH
99263: LD_VAR 0 7
99267: ARRAY
99268: PPUSH
99269: CALL_OW 247
99273: PUSH
99274: LD_INT 1
99276: EQUAL
99277: AND
99278: IFFALSE 99756
// begin if group [ i ] in healers then
99280: LD_VAR 0 4
99284: PUSH
99285: LD_VAR 0 7
99289: ARRAY
99290: PUSH
99291: LD_VAR 0 31
99295: IN
99296: IFFALSE 99569
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99298: LD_VAR 0 4
99302: PUSH
99303: LD_VAR 0 7
99307: ARRAY
99308: PPUSH
99309: LD_VAR 0 23
99313: PPUSH
99314: CALL_OW 308
99318: NOT
99319: PUSH
99320: LD_VAR 0 4
99324: PUSH
99325: LD_VAR 0 7
99329: ARRAY
99330: PPUSH
99331: CALL_OW 314
99335: NOT
99336: AND
99337: IFFALSE 99361
// ComMoveToArea ( group [ i ] , f_heal ) else
99339: LD_VAR 0 4
99343: PUSH
99344: LD_VAR 0 7
99348: ARRAY
99349: PPUSH
99350: LD_VAR 0 23
99354: PPUSH
99355: CALL_OW 113
99359: GO 99567
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99361: LD_VAR 0 4
99365: PUSH
99366: LD_VAR 0 7
99370: ARRAY
99371: PPUSH
99372: CALL 46920 0 1
99376: PPUSH
99377: CALL_OW 256
99381: PUSH
99382: LD_INT 1000
99384: EQUAL
99385: IFFALSE 99404
// ComStop ( group [ i ] ) else
99387: LD_VAR 0 4
99391: PUSH
99392: LD_VAR 0 7
99396: ARRAY
99397: PPUSH
99398: CALL_OW 141
99402: GO 99567
// if not HasTask ( group [ i ] ) and to_heal then
99404: LD_VAR 0 4
99408: PUSH
99409: LD_VAR 0 7
99413: ARRAY
99414: PPUSH
99415: CALL_OW 314
99419: NOT
99420: PUSH
99421: LD_VAR 0 30
99425: AND
99426: IFFALSE 99567
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99428: LD_ADDR_VAR 0 13
99432: PUSH
99433: LD_VAR 0 30
99437: PPUSH
99438: LD_INT 3
99440: PUSH
99441: LD_INT 54
99443: PUSH
99444: EMPTY
99445: LIST
99446: PUSH
99447: EMPTY
99448: LIST
99449: LIST
99450: PPUSH
99451: CALL_OW 72
99455: PPUSH
99456: LD_VAR 0 4
99460: PUSH
99461: LD_VAR 0 7
99465: ARRAY
99466: PPUSH
99467: CALL_OW 74
99471: ST_TO_ADDR
// if z then
99472: LD_VAR 0 13
99476: IFFALSE 99567
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99478: LD_INT 91
99480: PUSH
99481: LD_VAR 0 13
99485: PUSH
99486: LD_INT 10
99488: PUSH
99489: EMPTY
99490: LIST
99491: LIST
99492: LIST
99493: PUSH
99494: LD_INT 81
99496: PUSH
99497: LD_VAR 0 13
99501: PPUSH
99502: CALL_OW 255
99506: PUSH
99507: EMPTY
99508: LIST
99509: LIST
99510: PUSH
99511: EMPTY
99512: LIST
99513: LIST
99514: PPUSH
99515: CALL_OW 69
99519: PUSH
99520: LD_INT 0
99522: EQUAL
99523: IFFALSE 99547
// ComHeal ( group [ i ] , z ) else
99525: LD_VAR 0 4
99529: PUSH
99530: LD_VAR 0 7
99534: ARRAY
99535: PPUSH
99536: LD_VAR 0 13
99540: PPUSH
99541: CALL_OW 128
99545: GO 99567
// ComMoveToArea ( group [ i ] , f_heal ) ;
99547: LD_VAR 0 4
99551: PUSH
99552: LD_VAR 0 7
99556: ARRAY
99557: PPUSH
99558: LD_VAR 0 23
99562: PPUSH
99563: CALL_OW 113
// end ; continue ;
99567: GO 98598
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99569: LD_VAR 0 4
99573: PUSH
99574: LD_VAR 0 7
99578: ARRAY
99579: PPUSH
99580: CALL_OW 256
99584: PUSH
99585: LD_INT 700
99587: LESS
99588: PUSH
99589: LD_VAR 0 4
99593: PUSH
99594: LD_VAR 0 7
99598: ARRAY
99599: PUSH
99600: LD_VAR 0 30
99604: IN
99605: NOT
99606: AND
99607: IFFALSE 99631
// to_heal := to_heal union group [ i ] ;
99609: LD_ADDR_VAR 0 30
99613: PUSH
99614: LD_VAR 0 30
99618: PUSH
99619: LD_VAR 0 4
99623: PUSH
99624: LD_VAR 0 7
99628: ARRAY
99629: UNION
99630: ST_TO_ADDR
// if group [ i ] in to_heal then
99631: LD_VAR 0 4
99635: PUSH
99636: LD_VAR 0 7
99640: ARRAY
99641: PUSH
99642: LD_VAR 0 30
99646: IN
99647: IFFALSE 99756
// begin if GetLives ( group [ i ] ) = 1000 then
99649: LD_VAR 0 4
99653: PUSH
99654: LD_VAR 0 7
99658: ARRAY
99659: PPUSH
99660: CALL_OW 256
99664: PUSH
99665: LD_INT 1000
99667: EQUAL
99668: IFFALSE 99694
// to_heal := to_heal diff group [ i ] else
99670: LD_ADDR_VAR 0 30
99674: PUSH
99675: LD_VAR 0 30
99679: PUSH
99680: LD_VAR 0 4
99684: PUSH
99685: LD_VAR 0 7
99689: ARRAY
99690: DIFF
99691: ST_TO_ADDR
99692: GO 99756
// begin if not IsInArea ( group [ i ] , to_heal ) then
99694: LD_VAR 0 4
99698: PUSH
99699: LD_VAR 0 7
99703: ARRAY
99704: PPUSH
99705: LD_VAR 0 30
99709: PPUSH
99710: CALL_OW 308
99714: NOT
99715: IFFALSE 99739
// ComMoveToArea ( group [ i ] , f_heal ) else
99717: LD_VAR 0 4
99721: PUSH
99722: LD_VAR 0 7
99726: ARRAY
99727: PPUSH
99728: LD_VAR 0 23
99732: PPUSH
99733: CALL_OW 113
99737: GO 99754
// ComHold ( group [ i ] ) ;
99739: LD_VAR 0 4
99743: PUSH
99744: LD_VAR 0 7
99748: ARRAY
99749: PPUSH
99750: CALL_OW 140
// continue ;
99754: GO 98598
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
99756: LD_VAR 0 4
99760: PUSH
99761: LD_VAR 0 7
99765: ARRAY
99766: PPUSH
99767: LD_INT 10
99769: PPUSH
99770: CALL 45340 0 2
99774: NOT
99775: PUSH
99776: LD_VAR 0 16
99780: PUSH
99781: LD_VAR 0 7
99785: ARRAY
99786: PUSH
99787: EMPTY
99788: EQUAL
99789: NOT
99790: AND
99791: IFFALSE 100057
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
99793: LD_VAR 0 4
99797: PUSH
99798: LD_VAR 0 7
99802: ARRAY
99803: PPUSH
99804: CALL_OW 262
99808: PUSH
99809: LD_INT 1
99811: PUSH
99812: LD_INT 2
99814: PUSH
99815: EMPTY
99816: LIST
99817: LIST
99818: IN
99819: IFFALSE 99860
// if GetFuel ( group [ i ] ) < 10 then
99821: LD_VAR 0 4
99825: PUSH
99826: LD_VAR 0 7
99830: ARRAY
99831: PPUSH
99832: CALL_OW 261
99836: PUSH
99837: LD_INT 10
99839: LESS
99840: IFFALSE 99860
// SetFuel ( group [ i ] , 12 ) ;
99842: LD_VAR 0 4
99846: PUSH
99847: LD_VAR 0 7
99851: ARRAY
99852: PPUSH
99853: LD_INT 12
99855: PPUSH
99856: CALL_OW 240
// if units_path [ i ] then
99860: LD_VAR 0 16
99864: PUSH
99865: LD_VAR 0 7
99869: ARRAY
99870: IFFALSE 100055
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
99872: LD_VAR 0 4
99876: PUSH
99877: LD_VAR 0 7
99881: ARRAY
99882: PPUSH
99883: LD_VAR 0 16
99887: PUSH
99888: LD_VAR 0 7
99892: ARRAY
99893: PUSH
99894: LD_INT 1
99896: ARRAY
99897: PUSH
99898: LD_INT 1
99900: ARRAY
99901: PPUSH
99902: LD_VAR 0 16
99906: PUSH
99907: LD_VAR 0 7
99911: ARRAY
99912: PUSH
99913: LD_INT 1
99915: ARRAY
99916: PUSH
99917: LD_INT 2
99919: ARRAY
99920: PPUSH
99921: CALL_OW 297
99925: PUSH
99926: LD_INT 6
99928: GREATER
99929: IFFALSE 100004
// begin if not HasTask ( group [ i ] ) then
99931: LD_VAR 0 4
99935: PUSH
99936: LD_VAR 0 7
99940: ARRAY
99941: PPUSH
99942: CALL_OW 314
99946: NOT
99947: IFFALSE 100002
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
99949: LD_VAR 0 4
99953: PUSH
99954: LD_VAR 0 7
99958: ARRAY
99959: PPUSH
99960: LD_VAR 0 16
99964: PUSH
99965: LD_VAR 0 7
99969: ARRAY
99970: PUSH
99971: LD_INT 1
99973: ARRAY
99974: PUSH
99975: LD_INT 1
99977: ARRAY
99978: PPUSH
99979: LD_VAR 0 16
99983: PUSH
99984: LD_VAR 0 7
99988: ARRAY
99989: PUSH
99990: LD_INT 1
99992: ARRAY
99993: PUSH
99994: LD_INT 2
99996: ARRAY
99997: PPUSH
99998: CALL_OW 114
// end else
100002: GO 100055
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100004: LD_ADDR_VAR 0 15
100008: PUSH
100009: LD_VAR 0 16
100013: PUSH
100014: LD_VAR 0 7
100018: ARRAY
100019: PPUSH
100020: LD_INT 1
100022: PPUSH
100023: CALL_OW 3
100027: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100028: LD_ADDR_VAR 0 16
100032: PUSH
100033: LD_VAR 0 16
100037: PPUSH
100038: LD_VAR 0 7
100042: PPUSH
100043: LD_VAR 0 15
100047: PPUSH
100048: CALL_OW 1
100052: ST_TO_ADDR
// continue ;
100053: GO 98598
// end ; end ; end else
100055: GO 102719
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100057: LD_ADDR_VAR 0 14
100061: PUSH
100062: LD_INT 81
100064: PUSH
100065: LD_VAR 0 4
100069: PUSH
100070: LD_VAR 0 7
100074: ARRAY
100075: PPUSH
100076: CALL_OW 255
100080: PUSH
100081: EMPTY
100082: LIST
100083: LIST
100084: PPUSH
100085: CALL_OW 69
100089: ST_TO_ADDR
// if not tmp then
100090: LD_VAR 0 14
100094: NOT
100095: IFFALSE 100099
// continue ;
100097: GO 98598
// if f_ignore_area then
100099: LD_VAR 0 17
100103: IFFALSE 100191
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100105: LD_ADDR_VAR 0 15
100109: PUSH
100110: LD_VAR 0 14
100114: PPUSH
100115: LD_INT 3
100117: PUSH
100118: LD_INT 92
100120: PUSH
100121: LD_VAR 0 17
100125: PUSH
100126: LD_INT 1
100128: ARRAY
100129: PUSH
100130: LD_VAR 0 17
100134: PUSH
100135: LD_INT 2
100137: ARRAY
100138: PUSH
100139: LD_VAR 0 17
100143: PUSH
100144: LD_INT 3
100146: ARRAY
100147: PUSH
100148: EMPTY
100149: LIST
100150: LIST
100151: LIST
100152: LIST
100153: PUSH
100154: EMPTY
100155: LIST
100156: LIST
100157: PPUSH
100158: CALL_OW 72
100162: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100163: LD_VAR 0 14
100167: PUSH
100168: LD_VAR 0 15
100172: DIFF
100173: IFFALSE 100191
// tmp := tmp diff tmp2 ;
100175: LD_ADDR_VAR 0 14
100179: PUSH
100180: LD_VAR 0 14
100184: PUSH
100185: LD_VAR 0 15
100189: DIFF
100190: ST_TO_ADDR
// end ; if not f_murder then
100191: LD_VAR 0 20
100195: NOT
100196: IFFALSE 100254
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100198: LD_ADDR_VAR 0 15
100202: PUSH
100203: LD_VAR 0 14
100207: PPUSH
100208: LD_INT 3
100210: PUSH
100211: LD_INT 50
100213: PUSH
100214: EMPTY
100215: LIST
100216: PUSH
100217: EMPTY
100218: LIST
100219: LIST
100220: PPUSH
100221: CALL_OW 72
100225: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100226: LD_VAR 0 14
100230: PUSH
100231: LD_VAR 0 15
100235: DIFF
100236: IFFALSE 100254
// tmp := tmp diff tmp2 ;
100238: LD_ADDR_VAR 0 14
100242: PUSH
100243: LD_VAR 0 14
100247: PUSH
100248: LD_VAR 0 15
100252: DIFF
100253: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100254: LD_ADDR_VAR 0 14
100258: PUSH
100259: LD_VAR 0 4
100263: PUSH
100264: LD_VAR 0 7
100268: ARRAY
100269: PPUSH
100270: LD_VAR 0 14
100274: PPUSH
100275: LD_INT 1
100277: PPUSH
100278: LD_INT 1
100280: PPUSH
100281: CALL 18983 0 4
100285: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100286: LD_VAR 0 4
100290: PUSH
100291: LD_VAR 0 7
100295: ARRAY
100296: PPUSH
100297: CALL_OW 257
100301: PUSH
100302: LD_INT 1
100304: EQUAL
100305: IFFALSE 100753
// begin if WantPlant ( group [ i ] ) then
100307: LD_VAR 0 4
100311: PUSH
100312: LD_VAR 0 7
100316: ARRAY
100317: PPUSH
100318: CALL 18484 0 1
100322: IFFALSE 100326
// continue ;
100324: GO 98598
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100326: LD_VAR 0 18
100330: PUSH
100331: LD_VAR 0 4
100335: PUSH
100336: LD_VAR 0 7
100340: ARRAY
100341: PPUSH
100342: CALL_OW 310
100346: NOT
100347: AND
100348: PUSH
100349: LD_VAR 0 14
100353: PUSH
100354: LD_INT 1
100356: ARRAY
100357: PUSH
100358: LD_VAR 0 14
100362: PPUSH
100363: LD_INT 21
100365: PUSH
100366: LD_INT 2
100368: PUSH
100369: EMPTY
100370: LIST
100371: LIST
100372: PUSH
100373: LD_INT 58
100375: PUSH
100376: EMPTY
100377: LIST
100378: PUSH
100379: EMPTY
100380: LIST
100381: LIST
100382: PPUSH
100383: CALL_OW 72
100387: IN
100388: AND
100389: IFFALSE 100425
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100391: LD_VAR 0 4
100395: PUSH
100396: LD_VAR 0 7
100400: ARRAY
100401: PPUSH
100402: LD_VAR 0 14
100406: PUSH
100407: LD_INT 1
100409: ARRAY
100410: PPUSH
100411: CALL_OW 120
// attacking := true ;
100415: LD_ADDR_VAR 0 29
100419: PUSH
100420: LD_INT 1
100422: ST_TO_ADDR
// continue ;
100423: GO 98598
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100425: LD_VAR 0 26
100429: PUSH
100430: LD_VAR 0 4
100434: PUSH
100435: LD_VAR 0 7
100439: ARRAY
100440: PPUSH
100441: CALL_OW 257
100445: PUSH
100446: LD_INT 1
100448: EQUAL
100449: AND
100450: PUSH
100451: LD_VAR 0 4
100455: PUSH
100456: LD_VAR 0 7
100460: ARRAY
100461: PPUSH
100462: CALL_OW 256
100466: PUSH
100467: LD_INT 800
100469: LESS
100470: AND
100471: PUSH
100472: LD_VAR 0 4
100476: PUSH
100477: LD_VAR 0 7
100481: ARRAY
100482: PPUSH
100483: CALL_OW 318
100487: NOT
100488: AND
100489: IFFALSE 100506
// ComCrawl ( group [ i ] ) ;
100491: LD_VAR 0 4
100495: PUSH
100496: LD_VAR 0 7
100500: ARRAY
100501: PPUSH
100502: CALL_OW 137
// if f_mines then
100506: LD_VAR 0 21
100510: IFFALSE 100753
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100512: LD_VAR 0 14
100516: PUSH
100517: LD_INT 1
100519: ARRAY
100520: PPUSH
100521: CALL_OW 247
100525: PUSH
100526: LD_INT 3
100528: EQUAL
100529: PUSH
100530: LD_VAR 0 14
100534: PUSH
100535: LD_INT 1
100537: ARRAY
100538: PUSH
100539: LD_VAR 0 27
100543: IN
100544: NOT
100545: AND
100546: IFFALSE 100753
// begin x := GetX ( tmp [ 1 ] ) ;
100548: LD_ADDR_VAR 0 10
100552: PUSH
100553: LD_VAR 0 14
100557: PUSH
100558: LD_INT 1
100560: ARRAY
100561: PPUSH
100562: CALL_OW 250
100566: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100567: LD_ADDR_VAR 0 11
100571: PUSH
100572: LD_VAR 0 14
100576: PUSH
100577: LD_INT 1
100579: ARRAY
100580: PPUSH
100581: CALL_OW 251
100585: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100586: LD_ADDR_VAR 0 12
100590: PUSH
100591: LD_VAR 0 4
100595: PUSH
100596: LD_VAR 0 7
100600: ARRAY
100601: PPUSH
100602: CALL 45425 0 1
100606: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100607: LD_VAR 0 4
100611: PUSH
100612: LD_VAR 0 7
100616: ARRAY
100617: PPUSH
100618: LD_VAR 0 10
100622: PPUSH
100623: LD_VAR 0 11
100627: PPUSH
100628: LD_VAR 0 14
100632: PUSH
100633: LD_INT 1
100635: ARRAY
100636: PPUSH
100637: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
100641: LD_VAR 0 4
100645: PUSH
100646: LD_VAR 0 7
100650: ARRAY
100651: PPUSH
100652: LD_VAR 0 10
100656: PPUSH
100657: LD_VAR 0 12
100661: PPUSH
100662: LD_INT 7
100664: PPUSH
100665: CALL_OW 272
100669: PPUSH
100670: LD_VAR 0 11
100674: PPUSH
100675: LD_VAR 0 12
100679: PPUSH
100680: LD_INT 7
100682: PPUSH
100683: CALL_OW 273
100687: PPUSH
100688: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
100692: LD_VAR 0 4
100696: PUSH
100697: LD_VAR 0 7
100701: ARRAY
100702: PPUSH
100703: LD_INT 71
100705: PPUSH
100706: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
100710: LD_ADDR_VAR 0 27
100714: PUSH
100715: LD_VAR 0 27
100719: PPUSH
100720: LD_VAR 0 27
100724: PUSH
100725: LD_INT 1
100727: PLUS
100728: PPUSH
100729: LD_VAR 0 14
100733: PUSH
100734: LD_INT 1
100736: ARRAY
100737: PPUSH
100738: CALL_OW 1
100742: ST_TO_ADDR
// attacking := true ;
100743: LD_ADDR_VAR 0 29
100747: PUSH
100748: LD_INT 1
100750: ST_TO_ADDR
// continue ;
100751: GO 98598
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
100753: LD_VAR 0 4
100757: PUSH
100758: LD_VAR 0 7
100762: ARRAY
100763: PPUSH
100764: CALL_OW 257
100768: PUSH
100769: LD_INT 17
100771: EQUAL
100772: PUSH
100773: LD_VAR 0 4
100777: PUSH
100778: LD_VAR 0 7
100782: ARRAY
100783: PPUSH
100784: CALL_OW 110
100788: PUSH
100789: LD_INT 71
100791: EQUAL
100792: NOT
100793: AND
100794: IFFALSE 100940
// begin attacking := false ;
100796: LD_ADDR_VAR 0 29
100800: PUSH
100801: LD_INT 0
100803: ST_TO_ADDR
// k := 5 ;
100804: LD_ADDR_VAR 0 9
100808: PUSH
100809: LD_INT 5
100811: ST_TO_ADDR
// if tmp < k then
100812: LD_VAR 0 14
100816: PUSH
100817: LD_VAR 0 9
100821: LESS
100822: IFFALSE 100834
// k := tmp ;
100824: LD_ADDR_VAR 0 9
100828: PUSH
100829: LD_VAR 0 14
100833: ST_TO_ADDR
// for j = 1 to k do
100834: LD_ADDR_VAR 0 8
100838: PUSH
100839: DOUBLE
100840: LD_INT 1
100842: DEC
100843: ST_TO_ADDR
100844: LD_VAR 0 9
100848: PUSH
100849: FOR_TO
100850: IFFALSE 100938
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
100852: LD_VAR 0 14
100856: PUSH
100857: LD_VAR 0 8
100861: ARRAY
100862: PUSH
100863: LD_VAR 0 14
100867: PPUSH
100868: LD_INT 58
100870: PUSH
100871: EMPTY
100872: LIST
100873: PPUSH
100874: CALL_OW 72
100878: IN
100879: NOT
100880: IFFALSE 100936
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100882: LD_VAR 0 4
100886: PUSH
100887: LD_VAR 0 7
100891: ARRAY
100892: PPUSH
100893: LD_VAR 0 14
100897: PUSH
100898: LD_VAR 0 8
100902: ARRAY
100903: PPUSH
100904: CALL_OW 115
// attacking := true ;
100908: LD_ADDR_VAR 0 29
100912: PUSH
100913: LD_INT 1
100915: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
100916: LD_VAR 0 4
100920: PUSH
100921: LD_VAR 0 7
100925: ARRAY
100926: PPUSH
100927: LD_INT 71
100929: PPUSH
100930: CALL_OW 109
// continue ;
100934: GO 100849
// end ; end ;
100936: GO 100849
100938: POP
100939: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
100940: LD_VAR 0 4
100944: PUSH
100945: LD_VAR 0 7
100949: ARRAY
100950: PPUSH
100951: CALL_OW 257
100955: PUSH
100956: LD_INT 8
100958: EQUAL
100959: PUSH
100960: LD_VAR 0 4
100964: PUSH
100965: LD_VAR 0 7
100969: ARRAY
100970: PPUSH
100971: CALL_OW 264
100975: PUSH
100976: LD_INT 28
100978: PUSH
100979: LD_INT 45
100981: PUSH
100982: LD_INT 7
100984: PUSH
100985: LD_INT 47
100987: PUSH
100988: EMPTY
100989: LIST
100990: LIST
100991: LIST
100992: LIST
100993: IN
100994: OR
100995: IFFALSE 101251
// begin attacking := false ;
100997: LD_ADDR_VAR 0 29
101001: PUSH
101002: LD_INT 0
101004: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101005: LD_VAR 0 14
101009: PUSH
101010: LD_INT 1
101012: ARRAY
101013: PPUSH
101014: CALL_OW 266
101018: PUSH
101019: LD_INT 32
101021: PUSH
101022: LD_INT 31
101024: PUSH
101025: LD_INT 33
101027: PUSH
101028: LD_INT 4
101030: PUSH
101031: LD_INT 5
101033: PUSH
101034: EMPTY
101035: LIST
101036: LIST
101037: LIST
101038: LIST
101039: LIST
101040: IN
101041: IFFALSE 101227
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101043: LD_ADDR_VAR 0 9
101047: PUSH
101048: LD_VAR 0 14
101052: PUSH
101053: LD_INT 1
101055: ARRAY
101056: PPUSH
101057: CALL_OW 266
101061: PPUSH
101062: LD_VAR 0 14
101066: PUSH
101067: LD_INT 1
101069: ARRAY
101070: PPUSH
101071: CALL_OW 250
101075: PPUSH
101076: LD_VAR 0 14
101080: PUSH
101081: LD_INT 1
101083: ARRAY
101084: PPUSH
101085: CALL_OW 251
101089: PPUSH
101090: LD_VAR 0 14
101094: PUSH
101095: LD_INT 1
101097: ARRAY
101098: PPUSH
101099: CALL_OW 254
101103: PPUSH
101104: LD_VAR 0 14
101108: PUSH
101109: LD_INT 1
101111: ARRAY
101112: PPUSH
101113: CALL_OW 248
101117: PPUSH
101118: LD_INT 0
101120: PPUSH
101121: CALL 26795 0 6
101125: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101126: LD_ADDR_VAR 0 8
101130: PUSH
101131: LD_VAR 0 4
101135: PUSH
101136: LD_VAR 0 7
101140: ARRAY
101141: PPUSH
101142: LD_VAR 0 9
101146: PPUSH
101147: CALL 45465 0 2
101151: ST_TO_ADDR
// if j then
101152: LD_VAR 0 8
101156: IFFALSE 101225
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101158: LD_VAR 0 8
101162: PUSH
101163: LD_INT 1
101165: ARRAY
101166: PPUSH
101167: LD_VAR 0 8
101171: PUSH
101172: LD_INT 2
101174: ARRAY
101175: PPUSH
101176: CALL_OW 488
101180: IFFALSE 101225
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101182: LD_VAR 0 4
101186: PUSH
101187: LD_VAR 0 7
101191: ARRAY
101192: PPUSH
101193: LD_VAR 0 8
101197: PUSH
101198: LD_INT 1
101200: ARRAY
101201: PPUSH
101202: LD_VAR 0 8
101206: PUSH
101207: LD_INT 2
101209: ARRAY
101210: PPUSH
101211: CALL_OW 116
// attacking := true ;
101215: LD_ADDR_VAR 0 29
101219: PUSH
101220: LD_INT 1
101222: ST_TO_ADDR
// continue ;
101223: GO 98598
// end ; end else
101225: GO 101251
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101227: LD_VAR 0 4
101231: PUSH
101232: LD_VAR 0 7
101236: ARRAY
101237: PPUSH
101238: LD_VAR 0 14
101242: PUSH
101243: LD_INT 1
101245: ARRAY
101246: PPUSH
101247: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101251: LD_VAR 0 4
101255: PUSH
101256: LD_VAR 0 7
101260: ARRAY
101261: PPUSH
101262: CALL_OW 265
101266: PUSH
101267: LD_INT 11
101269: EQUAL
101270: IFFALSE 101548
// begin k := 10 ;
101272: LD_ADDR_VAR 0 9
101276: PUSH
101277: LD_INT 10
101279: ST_TO_ADDR
// x := 0 ;
101280: LD_ADDR_VAR 0 10
101284: PUSH
101285: LD_INT 0
101287: ST_TO_ADDR
// if tmp < k then
101288: LD_VAR 0 14
101292: PUSH
101293: LD_VAR 0 9
101297: LESS
101298: IFFALSE 101310
// k := tmp ;
101300: LD_ADDR_VAR 0 9
101304: PUSH
101305: LD_VAR 0 14
101309: ST_TO_ADDR
// for j = k downto 1 do
101310: LD_ADDR_VAR 0 8
101314: PUSH
101315: DOUBLE
101316: LD_VAR 0 9
101320: INC
101321: ST_TO_ADDR
101322: LD_INT 1
101324: PUSH
101325: FOR_DOWNTO
101326: IFFALSE 101401
// begin if GetType ( tmp [ j ] ) = unit_human then
101328: LD_VAR 0 14
101332: PUSH
101333: LD_VAR 0 8
101337: ARRAY
101338: PPUSH
101339: CALL_OW 247
101343: PUSH
101344: LD_INT 1
101346: EQUAL
101347: IFFALSE 101399
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101349: LD_VAR 0 4
101353: PUSH
101354: LD_VAR 0 7
101358: ARRAY
101359: PPUSH
101360: LD_VAR 0 14
101364: PUSH
101365: LD_VAR 0 8
101369: ARRAY
101370: PPUSH
101371: CALL 45736 0 2
// x := tmp [ j ] ;
101375: LD_ADDR_VAR 0 10
101379: PUSH
101380: LD_VAR 0 14
101384: PUSH
101385: LD_VAR 0 8
101389: ARRAY
101390: ST_TO_ADDR
// attacking := true ;
101391: LD_ADDR_VAR 0 29
101395: PUSH
101396: LD_INT 1
101398: ST_TO_ADDR
// end ; end ;
101399: GO 101325
101401: POP
101402: POP
// if not x then
101403: LD_VAR 0 10
101407: NOT
101408: IFFALSE 101548
// begin attacking := true ;
101410: LD_ADDR_VAR 0 29
101414: PUSH
101415: LD_INT 1
101417: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101418: LD_VAR 0 4
101422: PUSH
101423: LD_VAR 0 7
101427: ARRAY
101428: PPUSH
101429: CALL_OW 250
101433: PPUSH
101434: LD_VAR 0 4
101438: PUSH
101439: LD_VAR 0 7
101443: ARRAY
101444: PPUSH
101445: CALL_OW 251
101449: PPUSH
101450: CALL_OW 546
101454: PUSH
101455: LD_INT 2
101457: ARRAY
101458: PUSH
101459: LD_VAR 0 14
101463: PUSH
101464: LD_INT 1
101466: ARRAY
101467: PPUSH
101468: CALL_OW 250
101472: PPUSH
101473: LD_VAR 0 14
101477: PUSH
101478: LD_INT 1
101480: ARRAY
101481: PPUSH
101482: CALL_OW 251
101486: PPUSH
101487: CALL_OW 546
101491: PUSH
101492: LD_INT 2
101494: ARRAY
101495: EQUAL
101496: IFFALSE 101524
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101498: LD_VAR 0 4
101502: PUSH
101503: LD_VAR 0 7
101507: ARRAY
101508: PPUSH
101509: LD_VAR 0 14
101513: PUSH
101514: LD_INT 1
101516: ARRAY
101517: PPUSH
101518: CALL 45736 0 2
101522: GO 101548
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101524: LD_VAR 0 4
101528: PUSH
101529: LD_VAR 0 7
101533: ARRAY
101534: PPUSH
101535: LD_VAR 0 14
101539: PUSH
101540: LD_INT 1
101542: ARRAY
101543: PPUSH
101544: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101548: LD_VAR 0 4
101552: PUSH
101553: LD_VAR 0 7
101557: ARRAY
101558: PPUSH
101559: CALL_OW 264
101563: PUSH
101564: LD_INT 29
101566: EQUAL
101567: IFFALSE 101933
// begin if WantsToAttack ( group [ i ] ) in bombed then
101569: LD_VAR 0 4
101573: PUSH
101574: LD_VAR 0 7
101578: ARRAY
101579: PPUSH
101580: CALL_OW 319
101584: PUSH
101585: LD_VAR 0 28
101589: IN
101590: IFFALSE 101594
// continue ;
101592: GO 98598
// k := 8 ;
101594: LD_ADDR_VAR 0 9
101598: PUSH
101599: LD_INT 8
101601: ST_TO_ADDR
// x := 0 ;
101602: LD_ADDR_VAR 0 10
101606: PUSH
101607: LD_INT 0
101609: ST_TO_ADDR
// if tmp < k then
101610: LD_VAR 0 14
101614: PUSH
101615: LD_VAR 0 9
101619: LESS
101620: IFFALSE 101632
// k := tmp ;
101622: LD_ADDR_VAR 0 9
101626: PUSH
101627: LD_VAR 0 14
101631: ST_TO_ADDR
// for j = 1 to k do
101632: LD_ADDR_VAR 0 8
101636: PUSH
101637: DOUBLE
101638: LD_INT 1
101640: DEC
101641: ST_TO_ADDR
101642: LD_VAR 0 9
101646: PUSH
101647: FOR_TO
101648: IFFALSE 101780
// begin if GetType ( tmp [ j ] ) = unit_building then
101650: LD_VAR 0 14
101654: PUSH
101655: LD_VAR 0 8
101659: ARRAY
101660: PPUSH
101661: CALL_OW 247
101665: PUSH
101666: LD_INT 3
101668: EQUAL
101669: IFFALSE 101778
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
101671: LD_VAR 0 14
101675: PUSH
101676: LD_VAR 0 8
101680: ARRAY
101681: PUSH
101682: LD_VAR 0 28
101686: IN
101687: NOT
101688: PUSH
101689: LD_VAR 0 14
101693: PUSH
101694: LD_VAR 0 8
101698: ARRAY
101699: PPUSH
101700: CALL_OW 313
101704: AND
101705: IFFALSE 101778
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101707: LD_VAR 0 4
101711: PUSH
101712: LD_VAR 0 7
101716: ARRAY
101717: PPUSH
101718: LD_VAR 0 14
101722: PUSH
101723: LD_VAR 0 8
101727: ARRAY
101728: PPUSH
101729: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
101733: LD_ADDR_VAR 0 28
101737: PUSH
101738: LD_VAR 0 28
101742: PPUSH
101743: LD_VAR 0 28
101747: PUSH
101748: LD_INT 1
101750: PLUS
101751: PPUSH
101752: LD_VAR 0 14
101756: PUSH
101757: LD_VAR 0 8
101761: ARRAY
101762: PPUSH
101763: CALL_OW 1
101767: ST_TO_ADDR
// attacking := true ;
101768: LD_ADDR_VAR 0 29
101772: PUSH
101773: LD_INT 1
101775: ST_TO_ADDR
// break ;
101776: GO 101780
// end ; end ;
101778: GO 101647
101780: POP
101781: POP
// if not attacking and f_attack_depot then
101782: LD_VAR 0 29
101786: NOT
101787: PUSH
101788: LD_VAR 0 25
101792: AND
101793: IFFALSE 101888
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101795: LD_ADDR_VAR 0 13
101799: PUSH
101800: LD_VAR 0 14
101804: PPUSH
101805: LD_INT 2
101807: PUSH
101808: LD_INT 30
101810: PUSH
101811: LD_INT 0
101813: PUSH
101814: EMPTY
101815: LIST
101816: LIST
101817: PUSH
101818: LD_INT 30
101820: PUSH
101821: LD_INT 1
101823: PUSH
101824: EMPTY
101825: LIST
101826: LIST
101827: PUSH
101828: EMPTY
101829: LIST
101830: LIST
101831: LIST
101832: PPUSH
101833: CALL_OW 72
101837: ST_TO_ADDR
// if z then
101838: LD_VAR 0 13
101842: IFFALSE 101888
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
101844: LD_VAR 0 4
101848: PUSH
101849: LD_VAR 0 7
101853: ARRAY
101854: PPUSH
101855: LD_VAR 0 13
101859: PPUSH
101860: LD_VAR 0 4
101864: PUSH
101865: LD_VAR 0 7
101869: ARRAY
101870: PPUSH
101871: CALL_OW 74
101875: PPUSH
101876: CALL_OW 115
// attacking := true ;
101880: LD_ADDR_VAR 0 29
101884: PUSH
101885: LD_INT 1
101887: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
101888: LD_VAR 0 4
101892: PUSH
101893: LD_VAR 0 7
101897: ARRAY
101898: PPUSH
101899: CALL_OW 256
101903: PUSH
101904: LD_INT 500
101906: LESS
101907: IFFALSE 101933
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101909: LD_VAR 0 4
101913: PUSH
101914: LD_VAR 0 7
101918: ARRAY
101919: PPUSH
101920: LD_VAR 0 14
101924: PUSH
101925: LD_INT 1
101927: ARRAY
101928: PPUSH
101929: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
101933: LD_VAR 0 4
101937: PUSH
101938: LD_VAR 0 7
101942: ARRAY
101943: PPUSH
101944: CALL_OW 264
101948: PUSH
101949: LD_INT 49
101951: EQUAL
101952: IFFALSE 102073
// begin if not HasTask ( group [ i ] ) then
101954: LD_VAR 0 4
101958: PUSH
101959: LD_VAR 0 7
101963: ARRAY
101964: PPUSH
101965: CALL_OW 314
101969: NOT
101970: IFFALSE 102073
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
101972: LD_ADDR_VAR 0 9
101976: PUSH
101977: LD_INT 81
101979: PUSH
101980: LD_VAR 0 4
101984: PUSH
101985: LD_VAR 0 7
101989: ARRAY
101990: PPUSH
101991: CALL_OW 255
101995: PUSH
101996: EMPTY
101997: LIST
101998: LIST
101999: PPUSH
102000: CALL_OW 69
102004: PPUSH
102005: LD_VAR 0 4
102009: PUSH
102010: LD_VAR 0 7
102014: ARRAY
102015: PPUSH
102016: CALL_OW 74
102020: ST_TO_ADDR
// if k then
102021: LD_VAR 0 9
102025: IFFALSE 102073
// if GetDistUnits ( group [ i ] , k ) > 10 then
102027: LD_VAR 0 4
102031: PUSH
102032: LD_VAR 0 7
102036: ARRAY
102037: PPUSH
102038: LD_VAR 0 9
102042: PPUSH
102043: CALL_OW 296
102047: PUSH
102048: LD_INT 10
102050: GREATER
102051: IFFALSE 102073
// ComMoveUnit ( group [ i ] , k ) ;
102053: LD_VAR 0 4
102057: PUSH
102058: LD_VAR 0 7
102062: ARRAY
102063: PPUSH
102064: LD_VAR 0 9
102068: PPUSH
102069: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102073: LD_VAR 0 4
102077: PUSH
102078: LD_VAR 0 7
102082: ARRAY
102083: PPUSH
102084: CALL_OW 256
102088: PUSH
102089: LD_INT 250
102091: LESS
102092: PUSH
102093: LD_VAR 0 4
102097: PUSH
102098: LD_VAR 0 7
102102: ARRAY
102103: PUSH
102104: LD_INT 21
102106: PUSH
102107: LD_INT 2
102109: PUSH
102110: EMPTY
102111: LIST
102112: LIST
102113: PUSH
102114: LD_INT 23
102116: PUSH
102117: LD_INT 2
102119: PUSH
102120: EMPTY
102121: LIST
102122: LIST
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: PPUSH
102128: CALL_OW 69
102132: IN
102133: AND
102134: IFFALSE 102259
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102136: LD_ADDR_VAR 0 9
102140: PUSH
102141: LD_OWVAR 3
102145: PUSH
102146: LD_VAR 0 4
102150: PUSH
102151: LD_VAR 0 7
102155: ARRAY
102156: DIFF
102157: PPUSH
102158: LD_VAR 0 4
102162: PUSH
102163: LD_VAR 0 7
102167: ARRAY
102168: PPUSH
102169: CALL_OW 74
102173: ST_TO_ADDR
// if not k then
102174: LD_VAR 0 9
102178: NOT
102179: IFFALSE 102183
// continue ;
102181: GO 98598
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102183: LD_VAR 0 9
102187: PUSH
102188: LD_INT 81
102190: PUSH
102191: LD_VAR 0 4
102195: PUSH
102196: LD_VAR 0 7
102200: ARRAY
102201: PPUSH
102202: CALL_OW 255
102206: PUSH
102207: EMPTY
102208: LIST
102209: LIST
102210: PPUSH
102211: CALL_OW 69
102215: IN
102216: PUSH
102217: LD_VAR 0 9
102221: PPUSH
102222: LD_VAR 0 4
102226: PUSH
102227: LD_VAR 0 7
102231: ARRAY
102232: PPUSH
102233: CALL_OW 296
102237: PUSH
102238: LD_INT 5
102240: LESS
102241: AND
102242: IFFALSE 102259
// ComAutodestruct ( group [ i ] ) ;
102244: LD_VAR 0 4
102248: PUSH
102249: LD_VAR 0 7
102253: ARRAY
102254: PPUSH
102255: CALL 45634 0 1
// end ; if f_attack_depot then
102259: LD_VAR 0 25
102263: IFFALSE 102375
// begin k := 6 ;
102265: LD_ADDR_VAR 0 9
102269: PUSH
102270: LD_INT 6
102272: ST_TO_ADDR
// if tmp < k then
102273: LD_VAR 0 14
102277: PUSH
102278: LD_VAR 0 9
102282: LESS
102283: IFFALSE 102295
// k := tmp ;
102285: LD_ADDR_VAR 0 9
102289: PUSH
102290: LD_VAR 0 14
102294: ST_TO_ADDR
// for j = 1 to k do
102295: LD_ADDR_VAR 0 8
102299: PUSH
102300: DOUBLE
102301: LD_INT 1
102303: DEC
102304: ST_TO_ADDR
102305: LD_VAR 0 9
102309: PUSH
102310: FOR_TO
102311: IFFALSE 102373
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102313: LD_VAR 0 8
102317: PPUSH
102318: CALL_OW 266
102322: PUSH
102323: LD_INT 0
102325: PUSH
102326: LD_INT 1
102328: PUSH
102329: EMPTY
102330: LIST
102331: LIST
102332: IN
102333: IFFALSE 102371
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102335: LD_VAR 0 4
102339: PUSH
102340: LD_VAR 0 7
102344: ARRAY
102345: PPUSH
102346: LD_VAR 0 14
102350: PUSH
102351: LD_VAR 0 8
102355: ARRAY
102356: PPUSH
102357: CALL_OW 115
// attacking := true ;
102361: LD_ADDR_VAR 0 29
102365: PUSH
102366: LD_INT 1
102368: ST_TO_ADDR
// break ;
102369: GO 102373
// end ;
102371: GO 102310
102373: POP
102374: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102375: LD_VAR 0 4
102379: PUSH
102380: LD_VAR 0 7
102384: ARRAY
102385: PPUSH
102386: CALL_OW 302
102390: PUSH
102391: LD_VAR 0 29
102395: NOT
102396: AND
102397: IFFALSE 102719
// begin if GetTag ( group [ i ] ) = 71 then
102399: LD_VAR 0 4
102403: PUSH
102404: LD_VAR 0 7
102408: ARRAY
102409: PPUSH
102410: CALL_OW 110
102414: PUSH
102415: LD_INT 71
102417: EQUAL
102418: IFFALSE 102459
// begin if HasTask ( group [ i ] ) then
102420: LD_VAR 0 4
102424: PUSH
102425: LD_VAR 0 7
102429: ARRAY
102430: PPUSH
102431: CALL_OW 314
102435: IFFALSE 102441
// continue else
102437: GO 98598
102439: GO 102459
// SetTag ( group [ i ] , 0 ) ;
102441: LD_VAR 0 4
102445: PUSH
102446: LD_VAR 0 7
102450: ARRAY
102451: PPUSH
102452: LD_INT 0
102454: PPUSH
102455: CALL_OW 109
// end ; k := 8 ;
102459: LD_ADDR_VAR 0 9
102463: PUSH
102464: LD_INT 8
102466: ST_TO_ADDR
// x := 0 ;
102467: LD_ADDR_VAR 0 10
102471: PUSH
102472: LD_INT 0
102474: ST_TO_ADDR
// if tmp < k then
102475: LD_VAR 0 14
102479: PUSH
102480: LD_VAR 0 9
102484: LESS
102485: IFFALSE 102497
// k := tmp ;
102487: LD_ADDR_VAR 0 9
102491: PUSH
102492: LD_VAR 0 14
102496: ST_TO_ADDR
// for j = 1 to k do
102497: LD_ADDR_VAR 0 8
102501: PUSH
102502: DOUBLE
102503: LD_INT 1
102505: DEC
102506: ST_TO_ADDR
102507: LD_VAR 0 9
102511: PUSH
102512: FOR_TO
102513: IFFALSE 102611
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102515: LD_VAR 0 14
102519: PUSH
102520: LD_VAR 0 8
102524: ARRAY
102525: PPUSH
102526: CALL_OW 247
102530: PUSH
102531: LD_INT 1
102533: EQUAL
102534: PUSH
102535: LD_VAR 0 14
102539: PUSH
102540: LD_VAR 0 8
102544: ARRAY
102545: PPUSH
102546: CALL_OW 256
102550: PUSH
102551: LD_INT 250
102553: LESS
102554: PUSH
102555: LD_VAR 0 20
102559: AND
102560: PUSH
102561: LD_VAR 0 20
102565: NOT
102566: PUSH
102567: LD_VAR 0 14
102571: PUSH
102572: LD_VAR 0 8
102576: ARRAY
102577: PPUSH
102578: CALL_OW 256
102582: PUSH
102583: LD_INT 250
102585: GREATEREQUAL
102586: AND
102587: OR
102588: AND
102589: IFFALSE 102609
// begin x := tmp [ j ] ;
102591: LD_ADDR_VAR 0 10
102595: PUSH
102596: LD_VAR 0 14
102600: PUSH
102601: LD_VAR 0 8
102605: ARRAY
102606: ST_TO_ADDR
// break ;
102607: GO 102611
// end ;
102609: GO 102512
102611: POP
102612: POP
// if x then
102613: LD_VAR 0 10
102617: IFFALSE 102641
// ComAttackUnit ( group [ i ] , x ) else
102619: LD_VAR 0 4
102623: PUSH
102624: LD_VAR 0 7
102628: ARRAY
102629: PPUSH
102630: LD_VAR 0 10
102634: PPUSH
102635: CALL_OW 115
102639: GO 102665
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102641: LD_VAR 0 4
102645: PUSH
102646: LD_VAR 0 7
102650: ARRAY
102651: PPUSH
102652: LD_VAR 0 14
102656: PUSH
102657: LD_INT 1
102659: ARRAY
102660: PPUSH
102661: CALL_OW 115
// if not HasTask ( group [ i ] ) then
102665: LD_VAR 0 4
102669: PUSH
102670: LD_VAR 0 7
102674: ARRAY
102675: PPUSH
102676: CALL_OW 314
102680: NOT
102681: IFFALSE 102719
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
102683: LD_VAR 0 4
102687: PUSH
102688: LD_VAR 0 7
102692: ARRAY
102693: PPUSH
102694: LD_VAR 0 14
102698: PPUSH
102699: LD_VAR 0 4
102703: PUSH
102704: LD_VAR 0 7
102708: ARRAY
102709: PPUSH
102710: CALL_OW 74
102714: PPUSH
102715: CALL_OW 115
// end ; end ; end ;
102719: GO 98598
102721: POP
102722: POP
// wait ( 0 0$2 ) ;
102723: LD_INT 70
102725: PPUSH
102726: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
102730: LD_VAR 0 4
102734: NOT
102735: PUSH
102736: LD_VAR 0 4
102740: PUSH
102741: EMPTY
102742: EQUAL
102743: OR
102744: PUSH
102745: LD_INT 81
102747: PUSH
102748: LD_VAR 0 35
102752: PUSH
102753: EMPTY
102754: LIST
102755: LIST
102756: PPUSH
102757: CALL_OW 69
102761: NOT
102762: OR
102763: IFFALSE 98583
// end ;
102765: LD_VAR 0 2
102769: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
102770: LD_INT 0
102772: PPUSH
102773: PPUSH
102774: PPUSH
102775: PPUSH
102776: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
102777: LD_VAR 0 1
102781: NOT
102782: PUSH
102783: LD_EXP 66
102787: PUSH
102788: LD_VAR 0 1
102792: ARRAY
102793: NOT
102794: OR
102795: PUSH
102796: LD_VAR 0 2
102800: NOT
102801: OR
102802: PUSH
102803: LD_VAR 0 3
102807: NOT
102808: OR
102809: IFFALSE 102813
// exit ;
102811: GO 103326
// side := mc_sides [ base ] ;
102813: LD_ADDR_VAR 0 6
102817: PUSH
102818: LD_EXP 92
102822: PUSH
102823: LD_VAR 0 1
102827: ARRAY
102828: ST_TO_ADDR
// if not side then
102829: LD_VAR 0 6
102833: NOT
102834: IFFALSE 102838
// exit ;
102836: GO 103326
// for i in solds do
102838: LD_ADDR_VAR 0 7
102842: PUSH
102843: LD_VAR 0 2
102847: PUSH
102848: FOR_IN
102849: IFFALSE 102910
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
102851: LD_VAR 0 7
102855: PPUSH
102856: CALL_OW 310
102860: PPUSH
102861: CALL_OW 266
102865: PUSH
102866: LD_INT 32
102868: PUSH
102869: LD_INT 31
102871: PUSH
102872: EMPTY
102873: LIST
102874: LIST
102875: IN
102876: IFFALSE 102896
// solds := solds diff i else
102878: LD_ADDR_VAR 0 2
102882: PUSH
102883: LD_VAR 0 2
102887: PUSH
102888: LD_VAR 0 7
102892: DIFF
102893: ST_TO_ADDR
102894: GO 102908
// SetTag ( i , 18 ) ;
102896: LD_VAR 0 7
102900: PPUSH
102901: LD_INT 18
102903: PPUSH
102904: CALL_OW 109
102908: GO 102848
102910: POP
102911: POP
// if not solds then
102912: LD_VAR 0 2
102916: NOT
102917: IFFALSE 102921
// exit ;
102919: GO 103326
// repeat wait ( 0 0$2 ) ;
102921: LD_INT 70
102923: PPUSH
102924: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
102928: LD_ADDR_VAR 0 5
102932: PUSH
102933: LD_VAR 0 6
102937: PPUSH
102938: LD_VAR 0 3
102942: PPUSH
102943: CALL 15349 0 2
102947: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
102948: LD_EXP 66
102952: PUSH
102953: LD_VAR 0 1
102957: ARRAY
102958: NOT
102959: PUSH
102960: LD_EXP 66
102964: PUSH
102965: LD_VAR 0 1
102969: ARRAY
102970: PUSH
102971: EMPTY
102972: EQUAL
102973: OR
102974: IFFALSE 103011
// begin for i in solds do
102976: LD_ADDR_VAR 0 7
102980: PUSH
102981: LD_VAR 0 2
102985: PUSH
102986: FOR_IN
102987: IFFALSE 103000
// ComStop ( i ) ;
102989: LD_VAR 0 7
102993: PPUSH
102994: CALL_OW 141
102998: GO 102986
103000: POP
103001: POP
// solds := [ ] ;
103002: LD_ADDR_VAR 0 2
103006: PUSH
103007: EMPTY
103008: ST_TO_ADDR
// exit ;
103009: GO 103326
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
103011: LD_VAR 0 5
103015: NOT
103016: PUSH
103017: LD_VAR 0 5
103021: PUSH
103022: LD_INT 3
103024: GREATER
103025: OR
103026: PUSH
103027: LD_EXP 88
103031: PUSH
103032: LD_VAR 0 1
103036: ARRAY
103037: OR
103038: IFFALSE 103079
// begin for i in solds do
103040: LD_ADDR_VAR 0 7
103044: PUSH
103045: LD_VAR 0 2
103049: PUSH
103050: FOR_IN
103051: IFFALSE 103075
// if HasTask ( i ) then
103053: LD_VAR 0 7
103057: PPUSH
103058: CALL_OW 314
103062: IFFALSE 103073
// ComStop ( i ) ;
103064: LD_VAR 0 7
103068: PPUSH
103069: CALL_OW 141
103073: GO 103050
103075: POP
103076: POP
// break ;
103077: GO 103314
// end ; for i in solds do
103079: LD_ADDR_VAR 0 7
103083: PUSH
103084: LD_VAR 0 2
103088: PUSH
103089: FOR_IN
103090: IFFALSE 103306
// begin if IsInUnit ( i ) then
103092: LD_VAR 0 7
103096: PPUSH
103097: CALL_OW 310
103101: IFFALSE 103112
// ComExitBuilding ( i ) ;
103103: LD_VAR 0 7
103107: PPUSH
103108: CALL_OW 122
// if GetLives ( i ) > 333 then
103112: LD_VAR 0 7
103116: PPUSH
103117: CALL_OW 256
103121: PUSH
103122: LD_INT 333
103124: GREATER
103125: IFFALSE 103153
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103127: LD_VAR 0 7
103131: PPUSH
103132: LD_VAR 0 5
103136: PPUSH
103137: LD_VAR 0 7
103141: PPUSH
103142: CALL_OW 74
103146: PPUSH
103147: CALL_OW 115
103151: GO 103304
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
103153: LD_ADDR_VAR 0 8
103157: PUSH
103158: LD_EXP 66
103162: PUSH
103163: LD_VAR 0 1
103167: ARRAY
103168: PPUSH
103169: LD_INT 2
103171: PUSH
103172: LD_INT 30
103174: PUSH
103175: LD_INT 0
103177: PUSH
103178: EMPTY
103179: LIST
103180: LIST
103181: PUSH
103182: LD_INT 30
103184: PUSH
103185: LD_INT 1
103187: PUSH
103188: EMPTY
103189: LIST
103190: LIST
103191: PUSH
103192: LD_INT 30
103194: PUSH
103195: LD_INT 6
103197: PUSH
103198: EMPTY
103199: LIST
103200: LIST
103201: PUSH
103202: EMPTY
103203: LIST
103204: LIST
103205: LIST
103206: LIST
103207: PPUSH
103208: CALL_OW 72
103212: PPUSH
103213: LD_VAR 0 7
103217: PPUSH
103218: CALL_OW 74
103222: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
103223: LD_VAR 0 7
103227: PPUSH
103228: LD_VAR 0 8
103232: PPUSH
103233: CALL_OW 250
103237: PPUSH
103238: LD_INT 3
103240: PPUSH
103241: LD_INT 5
103243: PPUSH
103244: CALL_OW 272
103248: PPUSH
103249: LD_VAR 0 8
103253: PPUSH
103254: CALL_OW 251
103258: PPUSH
103259: LD_INT 3
103261: PPUSH
103262: LD_INT 5
103264: PPUSH
103265: CALL_OW 273
103269: PPUSH
103270: CALL_OW 111
// SetTag ( i , 0 ) ;
103274: LD_VAR 0 7
103278: PPUSH
103279: LD_INT 0
103281: PPUSH
103282: CALL_OW 109
// solds := solds diff i ;
103286: LD_ADDR_VAR 0 2
103290: PUSH
103291: LD_VAR 0 2
103295: PUSH
103296: LD_VAR 0 7
103300: DIFF
103301: ST_TO_ADDR
// continue ;
103302: GO 103089
// end ; end ;
103304: GO 103089
103306: POP
103307: POP
// until solds ;
103308: LD_VAR 0 2
103312: IFFALSE 102921
// MC_Reset ( base , 18 ) ;
103314: LD_VAR 0 1
103318: PPUSH
103319: LD_INT 18
103321: PPUSH
103322: CALL 54893 0 2
// end ;
103326: LD_VAR 0 4
103330: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
103331: LD_INT 0
103333: PPUSH
103334: PPUSH
103335: PPUSH
103336: PPUSH
103337: PPUSH
103338: PPUSH
103339: PPUSH
103340: PPUSH
103341: PPUSH
103342: PPUSH
103343: PPUSH
103344: PPUSH
103345: PPUSH
103346: PPUSH
103347: PPUSH
103348: PPUSH
103349: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
103350: LD_ADDR_VAR 0 13
103354: PUSH
103355: LD_EXP 66
103359: PUSH
103360: LD_VAR 0 1
103364: ARRAY
103365: PPUSH
103366: LD_INT 25
103368: PUSH
103369: LD_INT 3
103371: PUSH
103372: EMPTY
103373: LIST
103374: LIST
103375: PPUSH
103376: CALL_OW 72
103380: ST_TO_ADDR
// if mc_remote_driver [ base ] then
103381: LD_EXP 106
103385: PUSH
103386: LD_VAR 0 1
103390: ARRAY
103391: IFFALSE 103415
// mechs := mechs diff mc_remote_driver [ base ] ;
103393: LD_ADDR_VAR 0 13
103397: PUSH
103398: LD_VAR 0 13
103402: PUSH
103403: LD_EXP 106
103407: PUSH
103408: LD_VAR 0 1
103412: ARRAY
103413: DIFF
103414: ST_TO_ADDR
// for i in mechs do
103415: LD_ADDR_VAR 0 5
103419: PUSH
103420: LD_VAR 0 13
103424: PUSH
103425: FOR_IN
103426: IFFALSE 103461
// if GetTag ( i ) > 0 then
103428: LD_VAR 0 5
103432: PPUSH
103433: CALL_OW 110
103437: PUSH
103438: LD_INT 0
103440: GREATER
103441: IFFALSE 103459
// mechs := mechs diff i ;
103443: LD_ADDR_VAR 0 13
103447: PUSH
103448: LD_VAR 0 13
103452: PUSH
103453: LD_VAR 0 5
103457: DIFF
103458: ST_TO_ADDR
103459: GO 103425
103461: POP
103462: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
103463: LD_ADDR_VAR 0 9
103467: PUSH
103468: LD_EXP 66
103472: PUSH
103473: LD_VAR 0 1
103477: ARRAY
103478: PPUSH
103479: LD_INT 2
103481: PUSH
103482: LD_INT 25
103484: PUSH
103485: LD_INT 1
103487: PUSH
103488: EMPTY
103489: LIST
103490: LIST
103491: PUSH
103492: LD_INT 25
103494: PUSH
103495: LD_INT 5
103497: PUSH
103498: EMPTY
103499: LIST
103500: LIST
103501: PUSH
103502: LD_INT 25
103504: PUSH
103505: LD_INT 8
103507: PUSH
103508: EMPTY
103509: LIST
103510: LIST
103511: PUSH
103512: LD_INT 25
103514: PUSH
103515: LD_INT 9
103517: PUSH
103518: EMPTY
103519: LIST
103520: LIST
103521: PUSH
103522: EMPTY
103523: LIST
103524: LIST
103525: LIST
103526: LIST
103527: LIST
103528: PPUSH
103529: CALL_OW 72
103533: ST_TO_ADDR
// if not defenders and not solds then
103534: LD_VAR 0 2
103538: NOT
103539: PUSH
103540: LD_VAR 0 9
103544: NOT
103545: AND
103546: IFFALSE 103550
// exit ;
103548: GO 105240
// depot_under_attack := false ;
103550: LD_ADDR_VAR 0 17
103554: PUSH
103555: LD_INT 0
103557: ST_TO_ADDR
// sold_defenders := [ ] ;
103558: LD_ADDR_VAR 0 18
103562: PUSH
103563: EMPTY
103564: ST_TO_ADDR
// if mechs then
103565: LD_VAR 0 13
103569: IFFALSE 103722
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
103571: LD_ADDR_VAR 0 5
103575: PUSH
103576: LD_VAR 0 2
103580: PPUSH
103581: LD_INT 21
103583: PUSH
103584: LD_INT 2
103586: PUSH
103587: EMPTY
103588: LIST
103589: LIST
103590: PPUSH
103591: CALL_OW 72
103595: PUSH
103596: FOR_IN
103597: IFFALSE 103720
// begin if GetTag ( i ) <> 20 then
103599: LD_VAR 0 5
103603: PPUSH
103604: CALL_OW 110
103608: PUSH
103609: LD_INT 20
103611: NONEQUAL
103612: IFFALSE 103626
// SetTag ( i , 20 ) ;
103614: LD_VAR 0 5
103618: PPUSH
103619: LD_INT 20
103621: PPUSH
103622: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
103626: LD_VAR 0 5
103630: PPUSH
103631: CALL_OW 263
103635: PUSH
103636: LD_INT 1
103638: EQUAL
103639: PUSH
103640: LD_VAR 0 5
103644: PPUSH
103645: CALL_OW 311
103649: NOT
103650: AND
103651: IFFALSE 103718
// begin un := mechs [ 1 ] ;
103653: LD_ADDR_VAR 0 11
103657: PUSH
103658: LD_VAR 0 13
103662: PUSH
103663: LD_INT 1
103665: ARRAY
103666: ST_TO_ADDR
// ComExit ( un ) ;
103667: LD_VAR 0 11
103671: PPUSH
103672: CALL 49979 0 1
// AddComEnterUnit ( un , i ) ;
103676: LD_VAR 0 11
103680: PPUSH
103681: LD_VAR 0 5
103685: PPUSH
103686: CALL_OW 180
// SetTag ( un , 19 ) ;
103690: LD_VAR 0 11
103694: PPUSH
103695: LD_INT 19
103697: PPUSH
103698: CALL_OW 109
// mechs := mechs diff un ;
103702: LD_ADDR_VAR 0 13
103706: PUSH
103707: LD_VAR 0 13
103711: PUSH
103712: LD_VAR 0 11
103716: DIFF
103717: ST_TO_ADDR
// end ; end ;
103718: GO 103596
103720: POP
103721: POP
// if solds then
103722: LD_VAR 0 9
103726: IFFALSE 103785
// for i in solds do
103728: LD_ADDR_VAR 0 5
103732: PUSH
103733: LD_VAR 0 9
103737: PUSH
103738: FOR_IN
103739: IFFALSE 103783
// if not GetTag ( i ) then
103741: LD_VAR 0 5
103745: PPUSH
103746: CALL_OW 110
103750: NOT
103751: IFFALSE 103781
// begin defenders := defenders union i ;
103753: LD_ADDR_VAR 0 2
103757: PUSH
103758: LD_VAR 0 2
103762: PUSH
103763: LD_VAR 0 5
103767: UNION
103768: ST_TO_ADDR
// SetTag ( i , 18 ) ;
103769: LD_VAR 0 5
103773: PPUSH
103774: LD_INT 18
103776: PPUSH
103777: CALL_OW 109
// end ;
103781: GO 103738
103783: POP
103784: POP
// repeat wait ( 0 0$2 ) ;
103785: LD_INT 70
103787: PPUSH
103788: CALL_OW 67
// enemy := mc_scan [ base ] ;
103792: LD_ADDR_VAR 0 3
103796: PUSH
103797: LD_EXP 89
103801: PUSH
103802: LD_VAR 0 1
103806: ARRAY
103807: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103808: LD_EXP 66
103812: PUSH
103813: LD_VAR 0 1
103817: ARRAY
103818: NOT
103819: PUSH
103820: LD_EXP 66
103824: PUSH
103825: LD_VAR 0 1
103829: ARRAY
103830: PUSH
103831: EMPTY
103832: EQUAL
103833: OR
103834: IFFALSE 103871
// begin for i in defenders do
103836: LD_ADDR_VAR 0 5
103840: PUSH
103841: LD_VAR 0 2
103845: PUSH
103846: FOR_IN
103847: IFFALSE 103860
// ComStop ( i ) ;
103849: LD_VAR 0 5
103853: PPUSH
103854: CALL_OW 141
103858: GO 103846
103860: POP
103861: POP
// defenders := [ ] ;
103862: LD_ADDR_VAR 0 2
103866: PUSH
103867: EMPTY
103868: ST_TO_ADDR
// exit ;
103869: GO 105240
// end ; for i in defenders do
103871: LD_ADDR_VAR 0 5
103875: PUSH
103876: LD_VAR 0 2
103880: PUSH
103881: FOR_IN
103882: IFFALSE 104700
// begin e := NearestUnitToUnit ( enemy , i ) ;
103884: LD_ADDR_VAR 0 14
103888: PUSH
103889: LD_VAR 0 3
103893: PPUSH
103894: LD_VAR 0 5
103898: PPUSH
103899: CALL_OW 74
103903: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103904: LD_ADDR_VAR 0 8
103908: PUSH
103909: LD_EXP 66
103913: PUSH
103914: LD_VAR 0 1
103918: ARRAY
103919: PPUSH
103920: LD_INT 2
103922: PUSH
103923: LD_INT 30
103925: PUSH
103926: LD_INT 0
103928: PUSH
103929: EMPTY
103930: LIST
103931: LIST
103932: PUSH
103933: LD_INT 30
103935: PUSH
103936: LD_INT 1
103938: PUSH
103939: EMPTY
103940: LIST
103941: LIST
103942: PUSH
103943: EMPTY
103944: LIST
103945: LIST
103946: LIST
103947: PPUSH
103948: CALL_OW 72
103952: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
103953: LD_ADDR_VAR 0 17
103957: PUSH
103958: LD_VAR 0 8
103962: NOT
103963: PUSH
103964: LD_VAR 0 8
103968: PPUSH
103969: LD_INT 3
103971: PUSH
103972: LD_INT 24
103974: PUSH
103975: LD_INT 600
103977: PUSH
103978: EMPTY
103979: LIST
103980: LIST
103981: PUSH
103982: EMPTY
103983: LIST
103984: LIST
103985: PPUSH
103986: CALL_OW 72
103990: OR
103991: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
103992: LD_VAR 0 5
103996: PPUSH
103997: CALL_OW 247
104001: PUSH
104002: LD_INT 2
104004: DOUBLE
104005: EQUAL
104006: IFTRUE 104010
104008: GO 104406
104010: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
104011: LD_VAR 0 5
104015: PPUSH
104016: CALL_OW 256
104020: PUSH
104021: LD_INT 650
104023: GREATER
104024: PUSH
104025: LD_VAR 0 5
104029: PPUSH
104030: LD_VAR 0 14
104034: PPUSH
104035: CALL_OW 296
104039: PUSH
104040: LD_INT 40
104042: LESS
104043: PUSH
104044: LD_VAR 0 14
104048: PPUSH
104049: LD_EXP 91
104053: PUSH
104054: LD_VAR 0 1
104058: ARRAY
104059: PPUSH
104060: CALL_OW 308
104064: OR
104065: AND
104066: IFFALSE 104188
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
104068: LD_VAR 0 5
104072: PPUSH
104073: CALL_OW 262
104077: PUSH
104078: LD_INT 1
104080: EQUAL
104081: PUSH
104082: LD_VAR 0 5
104086: PPUSH
104087: CALL_OW 261
104091: PUSH
104092: LD_INT 30
104094: LESS
104095: AND
104096: PUSH
104097: LD_VAR 0 8
104101: AND
104102: IFFALSE 104172
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
104104: LD_VAR 0 5
104108: PPUSH
104109: LD_VAR 0 8
104113: PPUSH
104114: LD_VAR 0 5
104118: PPUSH
104119: CALL_OW 74
104123: PPUSH
104124: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
104128: LD_VAR 0 5
104132: PPUSH
104133: LD_VAR 0 8
104137: PPUSH
104138: LD_VAR 0 5
104142: PPUSH
104143: CALL_OW 74
104147: PPUSH
104148: CALL_OW 296
104152: PUSH
104153: LD_INT 6
104155: LESS
104156: IFFALSE 104170
// SetFuel ( i , 100 ) ;
104158: LD_VAR 0 5
104162: PPUSH
104163: LD_INT 100
104165: PPUSH
104166: CALL_OW 240
// end else
104170: GO 104186
// ComAttackUnit ( i , e ) ;
104172: LD_VAR 0 5
104176: PPUSH
104177: LD_VAR 0 14
104181: PPUSH
104182: CALL_OW 115
// end else
104186: GO 104289
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
104188: LD_VAR 0 14
104192: PPUSH
104193: LD_EXP 91
104197: PUSH
104198: LD_VAR 0 1
104202: ARRAY
104203: PPUSH
104204: CALL_OW 308
104208: NOT
104209: PUSH
104210: LD_VAR 0 5
104214: PPUSH
104215: LD_VAR 0 14
104219: PPUSH
104220: CALL_OW 296
104224: PUSH
104225: LD_INT 40
104227: GREATEREQUAL
104228: AND
104229: PUSH
104230: LD_VAR 0 5
104234: PPUSH
104235: CALL_OW 256
104239: PUSH
104240: LD_INT 650
104242: LESSEQUAL
104243: OR
104244: PUSH
104245: LD_VAR 0 5
104249: PPUSH
104250: LD_EXP 90
104254: PUSH
104255: LD_VAR 0 1
104259: ARRAY
104260: PPUSH
104261: CALL_OW 308
104265: NOT
104266: AND
104267: IFFALSE 104289
// ComMoveToArea ( i , mc_parking [ base ] ) ;
104269: LD_VAR 0 5
104273: PPUSH
104274: LD_EXP 90
104278: PUSH
104279: LD_VAR 0 1
104283: ARRAY
104284: PPUSH
104285: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
104289: LD_VAR 0 5
104293: PPUSH
104294: CALL_OW 256
104298: PUSH
104299: LD_INT 998
104301: LESS
104302: PUSH
104303: LD_VAR 0 5
104307: PPUSH
104308: CALL_OW 263
104312: PUSH
104313: LD_INT 1
104315: EQUAL
104316: AND
104317: PUSH
104318: LD_VAR 0 5
104322: PPUSH
104323: CALL_OW 311
104327: AND
104328: PUSH
104329: LD_VAR 0 5
104333: PPUSH
104334: LD_EXP 90
104338: PUSH
104339: LD_VAR 0 1
104343: ARRAY
104344: PPUSH
104345: CALL_OW 308
104349: AND
104350: IFFALSE 104404
// begin mech := IsDrivenBy ( i ) ;
104352: LD_ADDR_VAR 0 10
104356: PUSH
104357: LD_VAR 0 5
104361: PPUSH
104362: CALL_OW 311
104366: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
104367: LD_VAR 0 10
104371: PPUSH
104372: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
104376: LD_VAR 0 10
104380: PPUSH
104381: LD_VAR 0 5
104385: PPUSH
104386: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
104390: LD_VAR 0 10
104394: PPUSH
104395: LD_VAR 0 5
104399: PPUSH
104400: CALL_OW 180
// end ; end ; unit_human :
104404: GO 104671
104406: LD_INT 1
104408: DOUBLE
104409: EQUAL
104410: IFTRUE 104414
104412: GO 104670
104414: POP
// begin b := IsInUnit ( i ) ;
104415: LD_ADDR_VAR 0 19
104419: PUSH
104420: LD_VAR 0 5
104424: PPUSH
104425: CALL_OW 310
104429: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
104430: LD_ADDR_VAR 0 20
104434: PUSH
104435: LD_VAR 0 19
104439: NOT
104440: PUSH
104441: LD_VAR 0 19
104445: PPUSH
104446: CALL_OW 266
104450: PUSH
104451: LD_INT 32
104453: PUSH
104454: LD_INT 31
104456: PUSH
104457: EMPTY
104458: LIST
104459: LIST
104460: IN
104461: OR
104462: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
104463: LD_VAR 0 17
104467: PUSH
104468: LD_VAR 0 2
104472: PPUSH
104473: LD_INT 21
104475: PUSH
104476: LD_INT 2
104478: PUSH
104479: EMPTY
104480: LIST
104481: LIST
104482: PPUSH
104483: CALL_OW 72
104487: PUSH
104488: LD_INT 1
104490: LESSEQUAL
104491: OR
104492: PUSH
104493: LD_VAR 0 20
104497: AND
104498: PUSH
104499: LD_VAR 0 5
104503: PUSH
104504: LD_VAR 0 18
104508: IN
104509: NOT
104510: AND
104511: IFFALSE 104604
// begin if b then
104513: LD_VAR 0 19
104517: IFFALSE 104566
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
104519: LD_VAR 0 19
104523: PPUSH
104524: LD_VAR 0 3
104528: PPUSH
104529: LD_VAR 0 19
104533: PPUSH
104534: CALL_OW 74
104538: PPUSH
104539: CALL_OW 296
104543: PUSH
104544: LD_INT 10
104546: LESS
104547: PUSH
104548: LD_VAR 0 19
104552: PPUSH
104553: CALL_OW 461
104557: PUSH
104558: LD_INT 7
104560: NONEQUAL
104561: AND
104562: IFFALSE 104566
// continue ;
104564: GO 103881
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
104566: LD_ADDR_VAR 0 18
104570: PUSH
104571: LD_VAR 0 18
104575: PPUSH
104576: LD_VAR 0 18
104580: PUSH
104581: LD_INT 1
104583: PLUS
104584: PPUSH
104585: LD_VAR 0 5
104589: PPUSH
104590: CALL_OW 1
104594: ST_TO_ADDR
// ComExitBuilding ( i ) ;
104595: LD_VAR 0 5
104599: PPUSH
104600: CALL_OW 122
// end ; if sold_defenders then
104604: LD_VAR 0 18
104608: IFFALSE 104668
// if i in sold_defenders then
104610: LD_VAR 0 5
104614: PUSH
104615: LD_VAR 0 18
104619: IN
104620: IFFALSE 104668
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
104622: LD_VAR 0 5
104626: PPUSH
104627: CALL_OW 314
104631: NOT
104632: PUSH
104633: LD_VAR 0 5
104637: PPUSH
104638: LD_VAR 0 14
104642: PPUSH
104643: CALL_OW 296
104647: PUSH
104648: LD_INT 30
104650: LESS
104651: AND
104652: IFFALSE 104668
// ComAttackUnit ( i , e ) ;
104654: LD_VAR 0 5
104658: PPUSH
104659: LD_VAR 0 14
104663: PPUSH
104664: CALL_OW 115
// end ; end ; end ;
104668: GO 104671
104670: POP
// if IsDead ( i ) then
104671: LD_VAR 0 5
104675: PPUSH
104676: CALL_OW 301
104680: IFFALSE 104698
// defenders := defenders diff i ;
104682: LD_ADDR_VAR 0 2
104686: PUSH
104687: LD_VAR 0 2
104691: PUSH
104692: LD_VAR 0 5
104696: DIFF
104697: ST_TO_ADDR
// end ;
104698: GO 103881
104700: POP
104701: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
104702: LD_VAR 0 3
104706: NOT
104707: PUSH
104708: LD_VAR 0 2
104712: NOT
104713: OR
104714: PUSH
104715: LD_EXP 66
104719: PUSH
104720: LD_VAR 0 1
104724: ARRAY
104725: NOT
104726: OR
104727: IFFALSE 103785
// MC_Reset ( base , 18 ) ;
104729: LD_VAR 0 1
104733: PPUSH
104734: LD_INT 18
104736: PPUSH
104737: CALL 54893 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104741: LD_ADDR_VAR 0 2
104745: PUSH
104746: LD_VAR 0 2
104750: PUSH
104751: LD_VAR 0 2
104755: PPUSH
104756: LD_INT 2
104758: PUSH
104759: LD_INT 25
104761: PUSH
104762: LD_INT 1
104764: PUSH
104765: EMPTY
104766: LIST
104767: LIST
104768: PUSH
104769: LD_INT 25
104771: PUSH
104772: LD_INT 5
104774: PUSH
104775: EMPTY
104776: LIST
104777: LIST
104778: PUSH
104779: LD_INT 25
104781: PUSH
104782: LD_INT 8
104784: PUSH
104785: EMPTY
104786: LIST
104787: LIST
104788: PUSH
104789: LD_INT 25
104791: PUSH
104792: LD_INT 9
104794: PUSH
104795: EMPTY
104796: LIST
104797: LIST
104798: PUSH
104799: EMPTY
104800: LIST
104801: LIST
104802: LIST
104803: LIST
104804: LIST
104805: PPUSH
104806: CALL_OW 72
104810: DIFF
104811: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
104812: LD_VAR 0 3
104816: NOT
104817: PUSH
104818: LD_VAR 0 2
104822: PPUSH
104823: LD_INT 21
104825: PUSH
104826: LD_INT 2
104828: PUSH
104829: EMPTY
104830: LIST
104831: LIST
104832: PPUSH
104833: CALL_OW 72
104837: AND
104838: IFFALSE 105176
// begin tmp := FilterByTag ( defenders , 19 ) ;
104840: LD_ADDR_VAR 0 12
104844: PUSH
104845: LD_VAR 0 2
104849: PPUSH
104850: LD_INT 19
104852: PPUSH
104853: CALL 47109 0 2
104857: ST_TO_ADDR
// if tmp then
104858: LD_VAR 0 12
104862: IFFALSE 104932
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
104864: LD_ADDR_VAR 0 12
104868: PUSH
104869: LD_VAR 0 12
104873: PPUSH
104874: LD_INT 25
104876: PUSH
104877: LD_INT 3
104879: PUSH
104880: EMPTY
104881: LIST
104882: LIST
104883: PPUSH
104884: CALL_OW 72
104888: ST_TO_ADDR
// if tmp then
104889: LD_VAR 0 12
104893: IFFALSE 104932
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
104895: LD_ADDR_EXP 78
104899: PUSH
104900: LD_EXP 78
104904: PPUSH
104905: LD_VAR 0 1
104909: PPUSH
104910: LD_EXP 78
104914: PUSH
104915: LD_VAR 0 1
104919: ARRAY
104920: PUSH
104921: LD_VAR 0 12
104925: UNION
104926: PPUSH
104927: CALL_OW 1
104931: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
104932: LD_VAR 0 1
104936: PPUSH
104937: LD_INT 19
104939: PPUSH
104940: CALL 54893 0 2
// repeat wait ( 0 0$1 ) ;
104944: LD_INT 35
104946: PPUSH
104947: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104951: LD_EXP 66
104955: PUSH
104956: LD_VAR 0 1
104960: ARRAY
104961: NOT
104962: PUSH
104963: LD_EXP 66
104967: PUSH
104968: LD_VAR 0 1
104972: ARRAY
104973: PUSH
104974: EMPTY
104975: EQUAL
104976: OR
104977: IFFALSE 105014
// begin for i in defenders do
104979: LD_ADDR_VAR 0 5
104983: PUSH
104984: LD_VAR 0 2
104988: PUSH
104989: FOR_IN
104990: IFFALSE 105003
// ComStop ( i ) ;
104992: LD_VAR 0 5
104996: PPUSH
104997: CALL_OW 141
105001: GO 104989
105003: POP
105004: POP
// defenders := [ ] ;
105005: LD_ADDR_VAR 0 2
105009: PUSH
105010: EMPTY
105011: ST_TO_ADDR
// exit ;
105012: GO 105240
// end ; for i in defenders do
105014: LD_ADDR_VAR 0 5
105018: PUSH
105019: LD_VAR 0 2
105023: PUSH
105024: FOR_IN
105025: IFFALSE 105114
// begin if not IsInArea ( i , mc_parking [ base ] ) then
105027: LD_VAR 0 5
105031: PPUSH
105032: LD_EXP 90
105036: PUSH
105037: LD_VAR 0 1
105041: ARRAY
105042: PPUSH
105043: CALL_OW 308
105047: NOT
105048: IFFALSE 105072
// ComMoveToArea ( i , mc_parking [ base ] ) else
105050: LD_VAR 0 5
105054: PPUSH
105055: LD_EXP 90
105059: PUSH
105060: LD_VAR 0 1
105064: ARRAY
105065: PPUSH
105066: CALL_OW 113
105070: GO 105112
// if GetControl ( i ) = control_manual then
105072: LD_VAR 0 5
105076: PPUSH
105077: CALL_OW 263
105081: PUSH
105082: LD_INT 1
105084: EQUAL
105085: IFFALSE 105112
// if IsDrivenBy ( i ) then
105087: LD_VAR 0 5
105091: PPUSH
105092: CALL_OW 311
105096: IFFALSE 105112
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
105098: LD_VAR 0 5
105102: PPUSH
105103: CALL_OW 311
105107: PPUSH
105108: CALL_OW 121
// end ;
105112: GO 105024
105114: POP
105115: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
105116: LD_VAR 0 2
105120: PPUSH
105121: LD_INT 95
105123: PUSH
105124: LD_EXP 90
105128: PUSH
105129: LD_VAR 0 1
105133: ARRAY
105134: PUSH
105135: EMPTY
105136: LIST
105137: LIST
105138: PPUSH
105139: CALL_OW 72
105143: PUSH
105144: LD_VAR 0 2
105148: EQUAL
105149: PUSH
105150: LD_EXP 89
105154: PUSH
105155: LD_VAR 0 1
105159: ARRAY
105160: OR
105161: PUSH
105162: LD_EXP 66
105166: PUSH
105167: LD_VAR 0 1
105171: ARRAY
105172: NOT
105173: OR
105174: IFFALSE 104944
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
105176: LD_ADDR_EXP 88
105180: PUSH
105181: LD_EXP 88
105185: PPUSH
105186: LD_VAR 0 1
105190: PPUSH
105191: LD_VAR 0 2
105195: PPUSH
105196: LD_INT 21
105198: PUSH
105199: LD_INT 2
105201: PUSH
105202: EMPTY
105203: LIST
105204: LIST
105205: PPUSH
105206: CALL_OW 72
105210: PPUSH
105211: CALL_OW 1
105215: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
105216: LD_VAR 0 1
105220: PPUSH
105221: LD_INT 19
105223: PPUSH
105224: CALL 54893 0 2
// MC_Reset ( base , 20 ) ;
105228: LD_VAR 0 1
105232: PPUSH
105233: LD_INT 20
105235: PPUSH
105236: CALL 54893 0 2
// end ;
105240: LD_VAR 0 4
105244: RET
