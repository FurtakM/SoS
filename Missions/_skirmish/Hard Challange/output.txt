// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// debug := 0 ;
  14: LD_ADDR_EXP 1
  18: PUSH
  19: LD_INT 0
  21: ST_TO_ADDR
// if debug then
  22: LD_EXP 1
  26: IFFALSE 48
// begin display_strings := Debug mode active! ;
  28: LD_ADDR_OWVAR 47
  32: PUSH
  33: LD_STRING Debug mode active!
  35: ST_TO_ADDR
// Your_Side := 1 ;
  36: LD_ADDR_OWVAR 2
  40: PUSH
  41: LD_INT 1
  43: ST_TO_ADDR
// TurnFogOff ;
  44: CALL_OW 537
// end ; case Query ( QDiff ) of 1 :
  48: LD_STRING QDiff
  50: PPUSH
  51: CALL_OW 97
  55: PUSH
  56: LD_INT 1
  58: DOUBLE
  59: EQUAL
  60: IFTRUE 64
  62: GO 75
  64: POP
// Difficulty := 1 ; 2 :
  65: LD_ADDR_OWVAR 67
  69: PUSH
  70: LD_INT 1
  72: ST_TO_ADDR
  73: GO 114
  75: LD_INT 2
  77: DOUBLE
  78: EQUAL
  79: IFTRUE 83
  81: GO 94
  83: POP
// Difficulty := 2 ; 3 :
  84: LD_ADDR_OWVAR 67
  88: PUSH
  89: LD_INT 2
  91: ST_TO_ADDR
  92: GO 114
  94: LD_INT 3
  96: DOUBLE
  97: EQUAL
  98: IFTRUE 102
 100: GO 113
 102: POP
// Difficulty := 3 ; end ;
 103: LD_ADDR_OWVAR 67
 107: PUSH
 108: LD_INT 3
 110: ST_TO_ADDR
 111: GO 114
 113: POP
// PrepareTigers ( tiger_area ) ;
 114: LD_INT 8
 116: PPUSH
 117: CALL 10757 0 1
// PrepareApemans ( apeman_area ) ;
 121: LD_INT 9
 123: PPUSH
 124: CALL 10887 0 1
// PrepareRussian ;
 128: CALL 148 0 0
// PrepareAmerican ;
 132: CALL 12294 0 0
// if not debug then
 136: LD_EXP 1
 140: NOT
 141: IFFALSE 147
// Action ;
 143: CALL 14523 0 0
// end ;
 147: END
// export debug ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
 152: PPUSH
 153: PPUSH
// uc_side := 3 ;
 154: LD_ADDR_OWVAR 20
 158: PUSH
 159: LD_INT 3
 161: ST_TO_ADDR
// uc_nation := nation_russian ;
 162: LD_ADDR_OWVAR 21
 166: PUSH
 167: LD_INT 3
 169: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 170: LD_ADDR_VAR 0 2
 174: PUSH
 175: LD_INT 6
 177: PUSH
 178: LD_INT 7
 180: PUSH
 181: LD_INT 8
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: LIST
 188: PUSH
 189: LD_OWVAR 67
 193: ARRAY
 194: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 195: LD_INT 2
 197: PPUSH
 198: CALL_OW 274
 202: PPUSH
 203: LD_INT 1
 205: PPUSH
 206: LD_INT 1200
 208: PPUSH
 209: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 213: LD_INT 2
 215: PPUSH
 216: CALL_OW 274
 220: PPUSH
 221: LD_INT 2
 223: PPUSH
 224: LD_INT 600
 226: PPUSH
 227: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 231: LD_INT 33
 233: PPUSH
 234: LD_INT 4
 236: PPUSH
 237: LD_INT 3
 239: PPUSH
 240: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 244: LD_INT 37
 246: PPUSH
 247: LD_INT 3
 249: PPUSH
 250: LD_INT 3
 252: PPUSH
 253: CALL_OW 441
// ru_force := [ ] ;
 257: LD_ADDR_EXP 2
 261: PUSH
 262: EMPTY
 263: ST_TO_ADDR
// ru_group1 := [ ] ;
 264: LD_ADDR_EXP 3
 268: PUSH
 269: EMPTY
 270: ST_TO_ADDR
// ru_group2 := [ ] ;
 271: LD_ADDR_EXP 4
 275: PUSH
 276: EMPTY
 277: ST_TO_ADDR
// ru_reserve := [ ] ;
 278: LD_ADDR_EXP 8
 282: PUSH
 283: EMPTY
 284: ST_TO_ADDR
// ru_attack_list := [ ] ;
 285: LD_ADDR_EXP 9
 289: PUSH
 290: EMPTY
 291: ST_TO_ADDR
// ru_protector := [ ] ;
 292: LD_ADDR_EXP 16
 296: PUSH
 297: EMPTY
 298: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 299: LD_ADDR_EXP 5
 303: PUSH
 304: LD_INT 48
 306: PUSH
 307: LD_INT 49
 309: PUSH
 310: LD_INT 50
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 1
 318: PUSH
 319: LD_INT 51
 321: PUSH
 322: LD_INT 52
 324: PUSH
 325: LD_INT 69
 327: PUSH
 328: LD_INT 39
 330: PUSH
 331: LD_INT 34
 333: PUSH
 334: LD_INT 40
 336: PUSH
 337: LD_INT 53
 339: PUSH
 340: LD_INT 71
 342: PUSH
 343: LD_INT 57
 345: PUSH
 346: LD_INT 58
 348: PUSH
 349: LD_INT 44
 351: PUSH
 352: LD_INT 32
 354: PUSH
 355: LD_INT 27
 357: PUSH
 358: LD_INT 23
 360: PUSH
 361: LD_INT 33
 363: PUSH
 364: LD_INT 59
 366: PUSH
 367: LD_INT 54
 369: PUSH
 370: LD_INT 55
 372: PUSH
 373: LD_INT 56
 375: PUSH
 376: LD_INT 63
 378: PUSH
 379: LD_INT 64
 381: PUSH
 382: LD_INT 65
 384: PUSH
 385: LD_INT 30
 387: PUSH
 388: LD_INT 31
 390: PUSH
 391: LD_INT 21
 393: PUSH
 394: LD_INT 22
 396: PUSH
 397: LD_INT 25
 399: PUSH
 400: EMPTY
 401: LIST
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: LIST
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 434: LD_ADDR_EXP 6
 438: PUSH
 439: LD_INT 3
 441: PPUSH
 442: LD_INT 33
 444: PPUSH
 445: CALL 8872 0 2
 449: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 450: LD_ADDR_EXP 7
 454: PUSH
 455: LD_INT 46
 457: PUSH
 458: LD_INT 45
 460: PUSH
 461: LD_INT 47
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 469: LD_ADDR_EXP 12
 473: PUSH
 474: LD_INT 33
 476: PUSH
 477: LD_INT 36
 479: PUSH
 480: LD_INT 8
 482: PUSH
 483: LD_INT 3
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: ST_TO_ADDR
// ru_buildings := [ ] ;
 492: LD_ADDR_EXP 13
 496: PUSH
 497: EMPTY
 498: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 499: LD_ADDR_EXP 10
 503: PUSH
 504: LD_INT 3
 506: PPUSH
 507: CALL 6921 0 1
 511: PUSH
 512: LD_INT 1
 514: ARRAY
 515: PPUSH
 516: CALL_OW 250
 520: PUSH
 521: LD_INT 3
 523: PPUSH
 524: CALL 6921 0 1
 528: PUSH
 529: LD_INT 1
 531: ARRAY
 532: PPUSH
 533: CALL_OW 251
 537: PUSH
 538: LD_INT 3
 540: PPUSH
 541: CALL 6921 0 1
 545: PUSH
 546: LD_INT 1
 548: ARRAY
 549: PPUSH
 550: CALL_OW 254
 554: PUSH
 555: LD_INT 3
 557: PPUSH
 558: CALL 6921 0 1
 562: PUSH
 563: LD_INT 1
 565: ARRAY
 566: PPUSH
 567: LD_INT 1
 569: PPUSH
 570: CALL_OW 268
 574: PUSH
 575: LD_INT 3
 577: PPUSH
 578: CALL 6921 0 1
 582: PUSH
 583: LD_INT 1
 585: ARRAY
 586: PPUSH
 587: LD_INT 2
 589: PPUSH
 590: CALL_OW 268
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: PUSH
 602: LD_INT 12
 604: PUSH
 605: LD_INT 13
 607: PUSH
 608: LD_INT 1
 610: PUSH
 611: LD_INT 11
 613: PUSH
 614: LD_INT 14
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: ST_TO_ADDR
// ru_heal_list := [ ] ;
 628: LD_ADDR_EXP 11
 632: PUSH
 633: EMPTY
 634: ST_TO_ADDR
// need_buldozer := false ;
 635: LD_ADDR_EXP 17
 639: PUSH
 640: LD_INT 0
 642: ST_TO_ADDR
// need_crane := true ;
 643: LD_ADDR_EXP 18
 647: PUSH
 648: LD_INT 1
 650: ST_TO_ADDR
// ru_spotted := false ;
 651: LD_ADDR_EXP 15
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// for i = 1 to 6 do
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: DOUBLE
 665: LD_INT 1
 667: DEC
 668: ST_TO_ADDR
 669: LD_INT 6
 671: PUSH
 672: FOR_TO
 673: IFFALSE 714
// begin PrepareHuman ( false , 4 , skill ) ;
 675: LD_INT 0
 677: PPUSH
 678: LD_INT 4
 680: PPUSH
 681: LD_VAR 0 2
 685: PPUSH
 686: CALL_OW 380
// un := CreateHuman ;
 690: LD_ADDR_VAR 0 4
 694: PUSH
 695: CALL_OW 44
 699: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_INT 3
 707: PPUSH
 708: CALL_OW 52
// end ;
 712: GO 672
 714: POP
 715: POP
// for i = 1 to 6 do
 716: LD_ADDR_VAR 0 3
 720: PUSH
 721: DOUBLE
 722: LD_INT 1
 724: DEC
 725: ST_TO_ADDR
 726: LD_INT 6
 728: PUSH
 729: FOR_TO
 730: IFFALSE 771
// begin PrepareHuman ( false , 3 , skill ) ;
 732: LD_INT 0
 734: PPUSH
 735: LD_INT 3
 737: PPUSH
 738: LD_VAR 0 2
 742: PPUSH
 743: CALL_OW 380
// un := CreateHuman ;
 747: LD_ADDR_VAR 0 4
 751: PUSH
 752: CALL_OW 44
 756: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 757: LD_VAR 0 4
 761: PPUSH
 762: LD_INT 14
 764: PPUSH
 765: CALL_OW 52
// end ;
 769: GO 729
 771: POP
 772: POP
// for i = 1 to 6 do
 773: LD_ADDR_VAR 0 3
 777: PUSH
 778: DOUBLE
 779: LD_INT 1
 781: DEC
 782: ST_TO_ADDR
 783: LD_INT 6
 785: PUSH
 786: FOR_TO
 787: IFFALSE 831
// begin PrepareHuman ( false , 2 , skill ) ;
 789: LD_INT 0
 791: PPUSH
 792: LD_INT 2
 794: PPUSH
 795: LD_VAR 0 2
 799: PPUSH
 800: CALL_OW 380
// un := CreateHuman ;
 804: LD_ADDR_VAR 0 4
 808: PUSH
 809: CALL_OW 44
 813: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 814: LD_VAR 0 4
 818: PPUSH
 819: LD_INT 1
 821: PPUSH
 822: LD_INT 0
 824: PPUSH
 825: CALL_OW 49
// end ;
 829: GO 786
 831: POP
 832: POP
// for i = 1 to 6 do
 833: LD_ADDR_VAR 0 3
 837: PUSH
 838: DOUBLE
 839: LD_INT 1
 841: DEC
 842: ST_TO_ADDR
 843: LD_INT 6
 845: PUSH
 846: FOR_TO
 847: IFFALSE 925
// begin PrepareHuman ( false , 1 , skill ) ;
 849: LD_INT 0
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: LD_VAR 0 2
 859: PPUSH
 860: CALL_OW 380
// un := CreateHuman ;
 864: LD_ADDR_VAR 0 4
 868: PUSH
 869: CALL_OW 44
 873: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 874: LD_VAR 0 4
 878: PPUSH
 879: LD_INT 1
 881: PPUSH
 882: LD_INT 0
 884: PPUSH
 885: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 889: LD_VAR 0 4
 893: PPUSH
 894: LD_INT 30
 896: PUSH
 897: LD_INT 5
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PPUSH
 904: CALL_OW 69
 908: PPUSH
 909: LD_VAR 0 4
 913: PPUSH
 914: CALL_OW 74
 918: PPUSH
 919: CALL_OW 120
// end ;
 923: GO 846
 925: POP
 926: POP
// for i = 1 to Difficulty do
 927: LD_ADDR_VAR 0 3
 931: PUSH
 932: DOUBLE
 933: LD_INT 1
 935: DEC
 936: ST_TO_ADDR
 937: LD_OWVAR 67
 941: PUSH
 942: FOR_TO
 943: IFFALSE 1054
// begin vc_chassis := ru_medium_tracked ;
 945: LD_ADDR_OWVAR 37
 949: PUSH
 950: LD_INT 22
 952: ST_TO_ADDR
// vc_engine := engine_siberite ;
 953: LD_ADDR_OWVAR 39
 957: PUSH
 958: LD_INT 3
 960: ST_TO_ADDR
// vc_control := control_computer ;
 961: LD_ADDR_OWVAR 38
 965: PUSH
 966: LD_INT 3
 968: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 969: LD_ADDR_OWVAR 40
 973: PUSH
 974: LD_INT 43
 976: PUSH
 977: LD_INT 45
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: LD_VAR 0 3
 988: PUSH
 989: LD_INT 2
 991: MOD
 992: PUSH
 993: LD_INT 1
 995: PLUS
 996: ARRAY
 997: ST_TO_ADDR
// un := CreateVehicle ;
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: CALL_OW 45
1007: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
1008: LD_VAR 0 4
1012: PPUSH
1013: LD_INT 52
1015: PPUSH
1016: LD_INT 42
1018: PPUSH
1019: LD_INT 6
1021: PPUSH
1022: LD_INT 0
1024: PPUSH
1025: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
1029: LD_ADDR_EXP 16
1033: PUSH
1034: LD_EXP 16
1038: PPUSH
1039: LD_INT 1
1041: PPUSH
1042: LD_VAR 0 4
1046: PPUSH
1047: CALL_OW 2
1051: ST_TO_ADDR
// end ;
1052: GO 942
1054: POP
1055: POP
// end ;
1056: LD_VAR 0 1
1060: RET
// every 150 150$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1061: LD_OWVAR 67
1065: PUSH
1066: LD_INT 2
1068: EQUAL
1069: PUSH
1070: LD_INT 3
1072: PPUSH
1073: LD_INT 3
1075: PPUSH
1076: CALL 6770 0 2
1080: AND
1081: IFFALSE 1117
1083: GO 1085
1085: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1086: LD_INT 3
1088: PPUSH
1089: LD_INT 3
1091: PPUSH
1092: CALL 6770 0 2
1096: PUSH
1097: LD_INT 1
1099: ARRAY
1100: PPUSH
1101: LD_INT 24
1103: PPUSH
1104: LD_INT 1
1106: PPUSH
1107: LD_INT 3
1109: PPUSH
1110: LD_INT 48
1112: PPUSH
1113: CALL 8645 0 5
1117: END
// every 120 120$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1118: LD_OWVAR 67
1122: PUSH
1123: LD_INT 3
1125: EQUAL
1126: PUSH
1127: LD_INT 3
1129: PPUSH
1130: LD_INT 3
1132: PPUSH
1133: CALL 6770 0 2
1137: AND
1138: IFFALSE 1174
1140: GO 1142
1142: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1143: LD_INT 3
1145: PPUSH
1146: LD_INT 3
1148: PPUSH
1149: CALL 6770 0 2
1153: PUSH
1154: LD_INT 1
1156: ARRAY
1157: PPUSH
1158: LD_INT 24
1160: PPUSH
1161: LD_INT 1
1163: PPUSH
1164: LD_INT 3
1166: PPUSH
1167: LD_INT 48
1169: PPUSH
1170: CALL 8645 0 5
1174: END
// every 0 0$01 trigger ru_protector do var i ;
1175: LD_EXP 16
1179: IFFALSE 1350
1181: GO 1183
1183: DISABLE
1184: LD_INT 0
1186: PPUSH
// begin enable ;
1187: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1188: LD_INT 14
1190: PPUSH
1191: LD_INT 81
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: EMPTY
1198: LIST
1199: LIST
1200: PPUSH
1201: CALL_OW 70
1205: IFFALSE 1280
// begin for i = 1 to ru_protector do
1207: LD_ADDR_VAR 0 1
1211: PUSH
1212: DOUBLE
1213: LD_INT 1
1215: DEC
1216: ST_TO_ADDR
1217: LD_EXP 16
1221: PUSH
1222: FOR_TO
1223: IFFALSE 1276
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1225: LD_EXP 16
1229: PUSH
1230: LD_VAR 0 1
1234: ARRAY
1235: PPUSH
1236: LD_INT 14
1238: PPUSH
1239: LD_INT 81
1241: PUSH
1242: LD_INT 3
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: PPUSH
1249: CALL_OW 70
1253: PPUSH
1254: LD_EXP 16
1258: PUSH
1259: LD_VAR 0 1
1263: ARRAY
1264: PPUSH
1265: CALL_OW 74
1269: PPUSH
1270: CALL_OW 115
1274: GO 1222
1276: POP
1277: POP
// end else
1278: GO 1350
// for i = 1 to ru_protector do
1280: LD_ADDR_VAR 0 1
1284: PUSH
1285: DOUBLE
1286: LD_INT 1
1288: DEC
1289: ST_TO_ADDR
1290: LD_EXP 16
1294: PUSH
1295: FOR_TO
1296: IFFALSE 1348
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1298: LD_EXP 16
1302: PUSH
1303: LD_VAR 0 1
1307: ARRAY
1308: PPUSH
1309: LD_INT 49
1311: PPUSH
1312: LD_INT 39
1314: PPUSH
1315: CALL_OW 297
1319: PUSH
1320: LD_INT 10
1322: GREATER
1323: IFFALSE 1346
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1325: LD_EXP 16
1329: PUSH
1330: LD_VAR 0 1
1334: ARRAY
1335: PPUSH
1336: LD_INT 49
1338: PPUSH
1339: LD_INT 39
1341: PPUSH
1342: CALL_OW 111
1346: GO 1295
1348: POP
1349: POP
// end ;
1350: PPOPN 1
1352: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1353: LD_OWVAR 1
1357: PUSH
1358: LD_INT 4200
1360: PUSH
1361: LD_INT 2100
1363: PUSH
1364: LD_INT 1050
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: PUSH
1372: LD_OWVAR 67
1376: ARRAY
1377: GREATER
1378: IFFALSE 1391
1380: GO 1382
1382: DISABLE
// need_buldozer := true ;
1383: LD_ADDR_EXP 17
1387: PUSH
1388: LD_INT 1
1390: ST_TO_ADDR
1391: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1392: GO 1394
1394: DISABLE
// begin enable ;
1395: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1396: LD_ADDR_EXP 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 3
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: PUSH
1411: LD_INT 25
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: PPUSH
1425: CALL_OW 69
1429: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1430: LD_ADDR_EXP 20
1434: PUSH
1435: LD_INT 22
1437: PUSH
1438: LD_INT 3
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: PUSH
1445: LD_INT 25
1447: PUSH
1448: LD_INT 2
1450: PUSH
1451: EMPTY
1452: LIST
1453: LIST
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PPUSH
1459: CALL_OW 69
1463: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1464: LD_ADDR_EXP 21
1468: PUSH
1469: LD_INT 22
1471: PUSH
1472: LD_INT 3
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: PUSH
1479: LD_INT 25
1481: PUSH
1482: LD_INT 3
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: PPUSH
1493: CALL_OW 69
1497: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1498: LD_ADDR_EXP 22
1502: PUSH
1503: LD_INT 22
1505: PUSH
1506: LD_INT 3
1508: PUSH
1509: EMPTY
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 25
1515: PUSH
1516: LD_INT 4
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: PPUSH
1527: CALL_OW 69
1531: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1532: LD_ADDR_EXP 23
1536: PUSH
1537: LD_INT 22
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: PUSH
1547: LD_INT 25
1549: PUSH
1550: LD_INT 9
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: PUSH
1557: EMPTY
1558: LIST
1559: LIST
1560: PPUSH
1561: CALL_OW 69
1565: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1566: LD_ADDR_EXP 24
1570: PUSH
1571: LD_INT 2
1573: PPUSH
1574: LD_INT 22
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: LD_INT 21
1586: PUSH
1587: LD_INT 1
1589: PUSH
1590: EMPTY
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: PPUSH
1598: CALL_OW 70
1602: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1603: LD_ADDR_EXP 25
1607: PUSH
1608: LD_INT 34
1610: PUSH
1611: LD_INT 53
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PPUSH
1618: CALL_OW 69
1622: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1623: LD_ADDR_EXP 26
1627: PUSH
1628: LD_INT 34
1630: PUSH
1631: LD_INT 52
1633: PUSH
1634: EMPTY
1635: LIST
1636: LIST
1637: PPUSH
1638: CALL_OW 69
1642: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1643: LD_ADDR_EXP 27
1647: PUSH
1648: LD_INT 34
1650: PUSH
1651: LD_INT 51
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: PPUSH
1658: CALL_OW 69
1662: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1663: LD_ADDR_EXP 13
1667: PUSH
1668: LD_INT 3
1670: PPUSH
1671: LD_INT 1
1673: NEG
1674: PPUSH
1675: CALL 11275 0 2
1679: ST_TO_ADDR
// end ;
1680: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1681: LD_INT 22
1683: PUSH
1684: LD_INT 3
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: PPUSH
1691: CALL_OW 69
1695: PUSH
1696: LD_EXP 28
1700: AND
1701: PUSH
1702: LD_EXP 1
1706: OR
1707: IFFALSE 5196
1709: GO 1711
1711: DISABLE
1712: LD_INT 0
1714: PPUSH
1715: PPUSH
1716: PPUSH
1717: PPUSH
1718: PPUSH
1719: PPUSH
1720: PPUSH
1721: PPUSH
1722: PPUSH
1723: PPUSH
// begin enable ;
1724: ENABLE
// for i = 1 to ru_eng do
1725: LD_ADDR_VAR 0 1
1729: PUSH
1730: DOUBLE
1731: LD_INT 1
1733: DEC
1734: ST_TO_ADDR
1735: LD_EXP 20
1739: PUSH
1740: FOR_TO
1741: IFFALSE 1804
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1743: LD_EXP 20
1747: PUSH
1748: LD_VAR 0 1
1752: ARRAY
1753: PPUSH
1754: CALL_OW 314
1758: NOT
1759: PUSH
1760: LD_EXP 20
1764: PUSH
1765: LD_VAR 0 1
1769: ARRAY
1770: PPUSH
1771: CALL_OW 310
1775: NOT
1776: AND
1777: IFFALSE 1802
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1779: LD_EXP 20
1783: PUSH
1784: LD_VAR 0 1
1788: ARRAY
1789: PPUSH
1790: LD_INT 3
1792: PPUSH
1793: CALL 6679 0 1
1797: PPUSH
1798: CALL_OW 120
1802: GO 1740
1804: POP
1805: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1806: LD_INT 2
1808: PPUSH
1809: LD_INT 22
1811: PUSH
1812: LD_INT 3
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: PUSH
1819: LD_INT 21
1821: PUSH
1822: LD_INT 3
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: PUSH
1829: LD_INT 3
1831: PUSH
1832: LD_INT 24
1834: PUSH
1835: LD_INT 1000
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: EMPTY
1843: LIST
1844: LIST
1845: PUSH
1846: EMPTY
1847: LIST
1848: LIST
1849: LIST
1850: PPUSH
1851: CALL_OW 70
1855: IFFALSE 2022
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1857: LD_ADDR_VAR 0 4
1861: PUSH
1862: LD_INT 2
1864: PPUSH
1865: LD_INT 22
1867: PUSH
1868: LD_INT 3
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: PUSH
1875: LD_INT 21
1877: PUSH
1878: LD_INT 3
1880: PUSH
1881: EMPTY
1882: LIST
1883: LIST
1884: PUSH
1885: LD_INT 3
1887: PUSH
1888: LD_INT 24
1890: PUSH
1891: LD_INT 1000
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: LIST
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: LIST
1906: PPUSH
1907: CALL_OW 70
1911: ST_TO_ADDR
// for i = 1 to ru_eng do
1912: LD_ADDR_VAR 0 1
1916: PUSH
1917: DOUBLE
1918: LD_INT 1
1920: DEC
1921: ST_TO_ADDR
1922: LD_EXP 20
1926: PUSH
1927: FOR_TO
1928: IFFALSE 2020
// begin if IsInUnit ( ru_eng [ i ] ) then
1930: LD_EXP 20
1934: PUSH
1935: LD_VAR 0 1
1939: ARRAY
1940: PPUSH
1941: CALL_OW 310
1945: IFFALSE 1964
// ComExitBuilding ( ru_eng [ i ] ) else
1947: LD_EXP 20
1951: PUSH
1952: LD_VAR 0 1
1956: ARRAY
1957: PPUSH
1958: CALL_OW 122
1962: GO 2018
// if not WantRepair ( ru_eng [ i ] ) then
1964: LD_EXP 20
1968: PUSH
1969: LD_VAR 0 1
1973: ARRAY
1974: PPUSH
1975: CALL 11201 0 1
1979: NOT
1980: IFFALSE 2018
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1982: LD_EXP 20
1986: PUSH
1987: LD_VAR 0 1
1991: ARRAY
1992: PPUSH
1993: LD_VAR 0 4
1997: PPUSH
1998: LD_EXP 20
2002: PUSH
2003: LD_VAR 0 1
2007: ARRAY
2008: PPUSH
2009: CALL_OW 74
2013: PPUSH
2014: CALL_OW 130
// end ;
2018: GO 1927
2020: POP
2021: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
2022: LD_OWVAR 2
2026: PPUSH
2027: LD_INT 38
2029: PPUSH
2030: LD_INT 26
2032: PPUSH
2033: CALL 5998 0 3
2037: PUSH
2038: LD_INT 0
2040: EQUAL
2041: PUSH
2042: LD_OWVAR 2
2046: PPUSH
2047: LD_INT 29
2049: PPUSH
2050: LD_INT 37
2052: PPUSH
2053: CALL 5998 0 3
2057: PUSH
2058: LD_INT 0
2060: EQUAL
2061: AND
2062: IFFALSE 2199
// begin if ru_blist > 0 then
2064: LD_EXP 12
2068: PUSH
2069: LD_INT 0
2071: GREATER
2072: IFFALSE 2199
// begin for i = 1 to ru_eng do
2074: LD_ADDR_VAR 0 1
2078: PUSH
2079: DOUBLE
2080: LD_INT 1
2082: DEC
2083: ST_TO_ADDR
2084: LD_EXP 20
2088: PUSH
2089: FOR_TO
2090: IFFALSE 2197
// if IsInUnit ( ru_eng [ i ] ) then
2092: LD_EXP 20
2096: PUSH
2097: LD_VAR 0 1
2101: ARRAY
2102: PPUSH
2103: CALL_OW 310
2107: IFFALSE 2126
// ComExitBuilding ( ru_eng [ i ] ) else
2109: LD_EXP 20
2113: PUSH
2114: LD_VAR 0 1
2118: ARRAY
2119: PPUSH
2120: CALL_OW 122
2124: GO 2195
// if not HasTask ( ru_eng [ i ] ) then
2126: LD_EXP 20
2130: PUSH
2131: LD_VAR 0 1
2135: ARRAY
2136: PPUSH
2137: CALL_OW 314
2141: NOT
2142: IFFALSE 2195
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2144: LD_EXP 20
2148: PUSH
2149: LD_VAR 0 1
2153: ARRAY
2154: PPUSH
2155: LD_EXP 12
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PPUSH
2164: LD_EXP 12
2168: PUSH
2169: LD_INT 2
2171: ARRAY
2172: PPUSH
2173: LD_EXP 12
2177: PUSH
2178: LD_INT 3
2180: ARRAY
2181: PPUSH
2182: LD_EXP 12
2186: PUSH
2187: LD_INT 4
2189: ARRAY
2190: PPUSH
2191: CALL_OW 145
2195: GO 2089
2197: POP
2198: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2199: LD_ADDR_EXP 11
2203: PUSH
2204: LD_INT 3
2206: PPUSH
2207: LD_EXP 11
2211: PPUSH
2212: LD_EXP 14
2216: PPUSH
2217: CALL 9688 0 3
2221: ST_TO_ADDR
// if debug then
2222: LD_EXP 1
2226: IFFALSE 2238
// display_strings := ru_heal_list ;
2228: LD_ADDR_OWVAR 47
2232: PUSH
2233: LD_EXP 11
2237: ST_TO_ADDR
// for i = 1 to ru_sci do
2238: LD_ADDR_VAR 0 1
2242: PUSH
2243: DOUBLE
2244: LD_INT 1
2246: DEC
2247: ST_TO_ADDR
2248: LD_EXP 22
2252: PUSH
2253: FOR_TO
2254: IFFALSE 2586
// begin if ru_heal_list then
2256: LD_EXP 11
2260: IFFALSE 2499
// begin list := ru_heal_list ;
2262: LD_ADDR_VAR 0 9
2266: PUSH
2267: LD_EXP 11
2271: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2272: LD_EXP 22
2276: PUSH
2277: LD_VAR 0 1
2281: ARRAY
2282: PPUSH
2283: CALL_OW 310
2287: IFFALSE 2304
// ComExitBuilding ( ru_sci [ i ] ) ;
2289: LD_EXP 22
2293: PUSH
2294: LD_VAR 0 1
2298: ARRAY
2299: PPUSH
2300: CALL_OW 122
// for p = 1 to list do
2304: LD_ADDR_VAR 0 5
2308: PUSH
2309: DOUBLE
2310: LD_INT 1
2312: DEC
2313: ST_TO_ADDR
2314: LD_VAR 0 9
2318: PUSH
2319: FOR_TO
2320: IFFALSE 2495
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2322: LD_VAR 0 9
2326: PUSH
2327: LD_VAR 0 5
2331: ARRAY
2332: PPUSH
2333: CALL_OW 110
2337: PUSH
2338: LD_INT 100
2340: EQUAL
2341: PUSH
2342: LD_EXP 22
2346: PUSH
2347: LD_VAR 0 1
2351: ARRAY
2352: PPUSH
2353: LD_INT 100
2355: PPUSH
2356: CALL 10048 0 2
2360: NOT
2361: AND
2362: IFFALSE 2390
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2364: LD_EXP 22
2368: PUSH
2369: LD_VAR 0 1
2373: ARRAY
2374: PPUSH
2375: LD_VAR 0 9
2379: PUSH
2380: LD_VAR 0 5
2384: ARRAY
2385: PPUSH
2386: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2390: LD_VAR 0 9
2394: PUSH
2395: LD_VAR 0 5
2399: ARRAY
2400: PPUSH
2401: CALL_OW 110
2405: PUSH
2406: LD_INT 100
2408: GREATER
2409: IFFALSE 2437
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2411: LD_EXP 22
2415: PUSH
2416: LD_VAR 0 1
2420: ARRAY
2421: PPUSH
2422: LD_VAR 0 9
2426: PUSH
2427: LD_VAR 0 5
2431: ARRAY
2432: PPUSH
2433: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2437: LD_VAR 0 9
2441: PUSH
2442: LD_VAR 0 5
2446: ARRAY
2447: PPUSH
2448: LD_INT 4
2450: PPUSH
2451: CALL_OW 308
2455: NOT
2456: IFFALSE 2478
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2458: LD_VAR 0 9
2462: PUSH
2463: LD_VAR 0 5
2467: ARRAY
2468: PPUSH
2469: LD_INT 4
2471: PPUSH
2472: CALL_OW 113
2476: GO 2493
// ComHold ( list [ p ] ) ;
2478: LD_VAR 0 9
2482: PUSH
2483: LD_VAR 0 5
2487: ARRAY
2488: PPUSH
2489: CALL_OW 140
// end ;
2493: GO 2319
2495: POP
2496: POP
// end else
2497: GO 2584
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2499: LD_EXP 22
2503: PUSH
2504: LD_VAR 0 1
2508: ARRAY
2509: PPUSH
2510: CALL_OW 314
2514: NOT
2515: PUSH
2516: LD_EXP 22
2520: PUSH
2521: LD_VAR 0 1
2525: ARRAY
2526: PPUSH
2527: CALL_OW 310
2531: NOT
2532: AND
2533: PUSH
2534: LD_EXP 11
2538: PUSH
2539: LD_INT 0
2541: EQUAL
2542: AND
2543: IFFALSE 2584
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2545: LD_EXP 22
2549: PUSH
2550: LD_VAR 0 1
2554: ARRAY
2555: PPUSH
2556: LD_INT 3
2558: PPUSH
2559: CALL 6921 0 1
2563: PPUSH
2564: LD_EXP 22
2568: PUSH
2569: LD_VAR 0 1
2573: ARRAY
2574: PPUSH
2575: CALL_OW 74
2579: PPUSH
2580: CALL_OW 120
// end ;
2584: GO 2253
2586: POP
2587: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2588: LD_INT 3
2590: PPUSH
2591: LD_EXP 5
2595: PPUSH
2596: CALL 7062 0 2
2600: IFFALSE 2614
// ResearchTechList ( 3 , ru_tech_list ) ;
2602: LD_INT 3
2604: PPUSH
2605: LD_EXP 5
2609: PPUSH
2610: CALL 7137 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2614: LD_EXP 20
2618: PPUSH
2619: LD_EXP 10
2623: PPUSH
2624: CALL 9044 0 2
// lab := GetLabs ( 3 ) ;
2628: LD_ADDR_VAR 0 8
2632: PUSH
2633: LD_INT 3
2635: PPUSH
2636: CALL 6921 0 1
2640: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2641: LD_VAR 0 8
2645: PUSH
2646: LD_EXP 11
2650: PUSH
2651: LD_INT 0
2653: EQUAL
2654: AND
2655: IFFALSE 2782
// for i = 1 to lab do
2657: LD_ADDR_VAR 0 1
2661: PUSH
2662: DOUBLE
2663: LD_INT 1
2665: DEC
2666: ST_TO_ADDR
2667: LD_VAR 0 8
2671: PUSH
2672: FOR_TO
2673: IFFALSE 2780
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2675: LD_VAR 0 8
2679: PUSH
2680: LD_VAR 0 1
2684: ARRAY
2685: PPUSH
2686: CALL_OW 461
2690: PUSH
2691: LD_INT 6
2693: EQUAL
2694: IFFALSE 2778
// begin for p = 1 to ru_sci do
2696: LD_ADDR_VAR 0 5
2700: PUSH
2701: DOUBLE
2702: LD_INT 1
2704: DEC
2705: ST_TO_ADDR
2706: LD_EXP 22
2710: PUSH
2711: FOR_TO
2712: IFFALSE 2776
// if IsInUnit ( ru_sci [ p ] ) then
2714: LD_EXP 22
2718: PUSH
2719: LD_VAR 0 5
2723: ARRAY
2724: PPUSH
2725: CALL_OW 310
2729: IFFALSE 2748
// ComExitBuilding ( ru_sci [ p ] ) else
2731: LD_EXP 22
2735: PUSH
2736: LD_VAR 0 5
2740: ARRAY
2741: PPUSH
2742: CALL_OW 122
2746: GO 2774
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2748: LD_EXP 22
2752: PUSH
2753: LD_VAR 0 5
2757: ARRAY
2758: PPUSH
2759: LD_VAR 0 8
2763: PUSH
2764: LD_VAR 0 1
2768: ARRAY
2769: PPUSH
2770: CALL_OW 120
2774: GO 2711
2776: POP
2777: POP
// end ;
2778: GO 2672
2780: POP
2781: POP
// if GetTowers ( 3 ) < 5 then
2782: LD_INT 3
2784: PPUSH
2785: CALL 7476 0 1
2789: PUSH
2790: LD_INT 5
2792: LESS
2793: IFFALSE 2811
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2795: LD_EXP 20
2799: PPUSH
2800: LD_EXP 6
2804: PPUSH
2805: CALL 8084 0 2
2809: GO 2823
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2811: LD_INT 3
2813: PPUSH
2814: LD_EXP 7
2818: PPUSH
2819: CALL 8375 0 2
// if GetBuilding ( 3 , b_factory ) then
2823: LD_INT 3
2825: PPUSH
2826: LD_INT 3
2828: PPUSH
2829: CALL 6770 0 2
2833: IFFALSE 3103
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2835: LD_INT 3
2837: PPUSH
2838: LD_INT 3
2840: PPUSH
2841: CALL 6770 0 2
2845: PUSH
2846: LD_INT 1
2848: ARRAY
2849: PPUSH
2850: CALL_OW 461
2854: PUSH
2855: LD_INT 2
2857: EQUAL
2858: IFFALSE 3103
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2860: LD_ADDR_VAR 0 7
2864: PUSH
2865: LD_INT 3
2867: PPUSH
2868: LD_INT 3
2870: PPUSH
2871: CALL 6770 0 2
2875: PUSH
2876: LD_INT 1
2878: ARRAY
2879: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2880: LD_INT 3
2882: PPUSH
2883: LD_INT 24
2885: PPUSH
2886: LD_INT 53
2888: PPUSH
2889: CALL 8523 0 3
2893: PUSH
2894: LD_INT 0
2896: EQUAL
2897: PUSH
2898: LD_EXP 17
2902: AND
2903: IFFALSE 2926
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2905: LD_VAR 0 7
2909: PPUSH
2910: LD_INT 24
2912: PPUSH
2913: LD_INT 1
2915: PPUSH
2916: LD_INT 1
2918: PPUSH
2919: LD_INT 53
2921: PPUSH
2922: CALL 8645 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2926: LD_INT 3
2928: PPUSH
2929: LD_INT 22
2931: PPUSH
2932: LD_INT 52
2934: PPUSH
2935: CALL 8523 0 3
2939: PUSH
2940: LD_INT 0
2942: EQUAL
2943: PUSH
2944: LD_EXP 18
2948: AND
2949: IFFALSE 2972
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2951: LD_VAR 0 7
2955: PPUSH
2956: LD_INT 22
2958: PPUSH
2959: LD_INT 1
2961: PPUSH
2962: LD_INT 3
2964: PPUSH
2965: LD_INT 52
2967: PPUSH
2968: CALL 8645 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2972: LD_INT 3
2974: PPUSH
2975: LD_INT 22
2977: PPUSH
2978: LD_INT 49
2980: PPUSH
2981: CALL 8523 0 3
2985: PUSH
2986: LD_INT 4
2988: LESS
2989: PUSH
2990: LD_INT 31
2992: PPUSH
2993: LD_INT 3
2995: PPUSH
2996: CALL_OW 321
3000: PUSH
3001: LD_INT 2
3003: EQUAL
3004: AND
3005: IFFALSE 3028
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
3007: LD_VAR 0 7
3011: PPUSH
3012: LD_INT 22
3014: PPUSH
3015: LD_INT 1
3017: PPUSH
3018: LD_INT 3
3020: PPUSH
3021: LD_INT 49
3023: PPUSH
3024: CALL 8645 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
3028: LD_EXP 8
3032: PUSH
3033: LD_INT 5
3035: PUSH
3036: LD_INT 6
3038: PUSH
3039: LD_INT 7
3041: PUSH
3042: EMPTY
3043: LIST
3044: LIST
3045: LIST
3046: PUSH
3047: LD_OWVAR 67
3051: ARRAY
3052: LESS
3053: IFFALSE 3103
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3055: LD_VAR 0 7
3059: PPUSH
3060: LD_INT 24
3062: PPUSH
3063: LD_INT 1
3065: PPUSH
3066: LD_INT 3
3068: PPUSH
3069: LD_INT 46
3071: PUSH
3072: LD_INT 45
3074: PUSH
3075: LD_INT 47
3077: PUSH
3078: LD_INT 46
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: PUSH
3087: LD_INT 1
3089: PPUSH
3090: LD_INT 4
3092: PPUSH
3093: CALL_OW 12
3097: ARRAY
3098: PPUSH
3099: CALL 8645 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3103: LD_INT 3
3105: PPUSH
3106: CALL 6679 0 1
3110: PPUSH
3111: CALL 6371 0 1
3115: PUSH
3116: LD_INT 1
3118: ARRAY
3119: PUSH
3120: LD_INT 250
3122: GREATER
3123: PUSH
3124: LD_INT 3
3126: PPUSH
3127: CALL 6679 0 1
3131: PPUSH
3132: CALL 6371 0 1
3136: PUSH
3137: LD_INT 3
3139: ARRAY
3140: PUSH
3141: LD_INT 50
3143: GREATER
3144: AND
3145: PUSH
3146: LD_INT 23
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: CALL_OW 321
3156: PUSH
3157: LD_INT 2
3159: EQUAL
3160: AND
3161: PUSH
3162: LD_INT 3
3164: PPUSH
3165: CALL 11999 0 1
3169: PUSH
3170: LD_INT 0
3172: EQUAL
3173: AND
3174: PUSH
3175: LD_INT 22
3177: PUSH
3178: LD_INT 3
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: PUSH
3185: LD_INT 34
3187: PUSH
3188: LD_INT 49
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: PPUSH
3199: CALL_OW 69
3203: PUSH
3204: LD_INT 3
3206: GREATER
3207: AND
3208: PUSH
3209: LD_OWVAR 2
3213: PPUSH
3214: LD_INT 51
3216: PPUSH
3217: LD_INT 42
3219: PPUSH
3220: CALL 5998 0 3
3224: PUSH
3225: LD_INT 0
3227: EQUAL
3228: AND
3229: IFFALSE 3314
// begin for i = 1 to ru_mech do
3231: LD_ADDR_VAR 0 1
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_EXP 21
3245: PUSH
3246: FOR_TO
3247: IFFALSE 3312
// begin if IsInUnit ( ru_mech [ i ] ) then
3249: LD_EXP 21
3253: PUSH
3254: LD_VAR 0 1
3258: ARRAY
3259: PPUSH
3260: CALL_OW 310
3264: IFFALSE 3283
// ComExitBuilding ( ru_mech [ i ] ) else
3266: LD_EXP 21
3270: PUSH
3271: LD_VAR 0 1
3275: ARRAY
3276: PPUSH
3277: CALL_OW 122
3281: GO 3310
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3283: LD_EXP 21
3287: PUSH
3288: LD_VAR 0 1
3292: ARRAY
3293: PPUSH
3294: LD_INT 37
3296: PPUSH
3297: LD_INT 51
3299: PPUSH
3300: LD_INT 43
3302: PPUSH
3303: LD_INT 0
3305: PPUSH
3306: CALL_OW 170
// end ;
3310: GO 3246
3312: POP
3313: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3314: LD_OWVAR 1
3318: PUSH
3319: LD_INT 94500
3321: PUSH
3322: LD_INT 84000
3324: PUSH
3325: LD_INT 71400
3327: PUSH
3328: EMPTY
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_OWVAR 67
3337: ARRAY
3338: GREATEREQUAL
3339: IFFALSE 3395
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3341: LD_OWVAR 1
3345: PUSH
3346: LD_INT 18900
3348: PUSH
3349: LD_INT 16800
3351: PUSH
3352: LD_INT 14700
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: PUSH
3360: LD_OWVAR 67
3364: ARRAY
3365: MOD
3366: PUSH
3367: LD_INT 0
3369: EQUAL
3370: IFFALSE 3395
// if ru_reserve then
3372: LD_EXP 8
3376: IFFALSE 3395
// begin ru_attack_list := ru_reserve ;
3378: LD_ADDR_EXP 9
3382: PUSH
3383: LD_EXP 8
3387: ST_TO_ADDR
// ru_reserve := [ ] ;
3388: LD_ADDR_EXP 8
3392: PUSH
3393: EMPTY
3394: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3395: LD_EXP 9
3399: IFFALSE 3521
// begin for i = 1 to ru_attack_list do
3401: LD_ADDR_VAR 0 1
3405: PUSH
3406: DOUBLE
3407: LD_INT 1
3409: DEC
3410: ST_TO_ADDR
3411: LD_EXP 9
3415: PUSH
3416: FOR_TO
3417: IFFALSE 3519
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3419: LD_EXP 9
3423: PUSH
3424: LD_VAR 0 1
3428: ARRAY
3429: PPUSH
3430: CALL_OW 256
3434: PUSH
3435: LD_INT 250
3437: GREATEREQUAL
3438: PUSH
3439: LD_EXP 9
3443: PUSH
3444: LD_VAR 0 1
3448: ARRAY
3449: PPUSH
3450: CALL_OW 314
3454: NOT
3455: AND
3456: IFFALSE 3517
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3458: LD_EXP 9
3462: PUSH
3463: LD_VAR 0 1
3467: ARRAY
3468: PPUSH
3469: LD_INT 81
3471: PUSH
3472: LD_EXP 9
3476: PUSH
3477: LD_VAR 0 1
3481: ARRAY
3482: PPUSH
3483: CALL_OW 255
3487: PUSH
3488: EMPTY
3489: LIST
3490: LIST
3491: PPUSH
3492: CALL_OW 69
3496: PPUSH
3497: LD_EXP 9
3501: PUSH
3502: LD_VAR 0 1
3506: ARRAY
3507: PPUSH
3508: CALL_OW 74
3512: PPUSH
3513: CALL_OW 115
3517: GO 3416
3519: POP
3520: POP
// end ; if GetBehemoth ( 3 ) then
3521: LD_INT 3
3523: PPUSH
3524: CALL 11999 0 1
3528: IFFALSE 3822
// begin if ru_mech >= 4 then
3530: LD_EXP 21
3534: PUSH
3535: LD_INT 4
3537: GREATEREQUAL
3538: IFFALSE 3589
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3540: LD_ADDR_EXP 14
3544: PUSH
3545: LD_EXP 21
3549: PUSH
3550: LD_INT 1
3552: ARRAY
3553: PUSH
3554: LD_EXP 21
3558: PUSH
3559: LD_INT 2
3561: ARRAY
3562: PUSH
3563: LD_EXP 21
3567: PUSH
3568: LD_INT 3
3570: ARRAY
3571: PUSH
3572: LD_EXP 21
3576: PUSH
3577: LD_INT 4
3579: ARRAY
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: ST_TO_ADDR
3587: GO 3599
// ru_behemoth_mechanic := ru_mech ;
3589: LD_ADDR_EXP 14
3593: PUSH
3594: LD_EXP 21
3598: ST_TO_ADDR
// for i = 1 to ru_mech do
3599: LD_ADDR_VAR 0 1
3603: PUSH
3604: DOUBLE
3605: LD_INT 1
3607: DEC
3608: ST_TO_ADDR
3609: LD_EXP 21
3613: PUSH
3614: FOR_TO
3615: IFFALSE 3669
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3617: LD_EXP 21
3621: PUSH
3622: LD_VAR 0 1
3626: ARRAY
3627: PPUSH
3628: CALL_OW 310
3632: PUSH
3633: LD_EXP 21
3637: PUSH
3638: LD_VAR 0 1
3642: ARRAY
3643: PUSH
3644: LD_EXP 14
3648: IN
3649: AND
3650: IFFALSE 3667
// ComExitBuilding ( ru_mech [ i ] ) ;
3652: LD_EXP 21
3656: PUSH
3657: LD_VAR 0 1
3661: ARRAY
3662: PPUSH
3663: CALL_OW 122
3667: GO 3614
3669: POP
3670: POP
// if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3671: LD_INT 12
3673: PPUSH
3674: LD_INT 22
3676: PUSH
3677: LD_INT 1
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: PUSH
3684: LD_INT 21
3686: PUSH
3687: LD_INT 3
3689: PUSH
3690: EMPTY
3691: LIST
3692: LIST
3693: PUSH
3694: EMPTY
3695: LIST
3696: LIST
3697: PPUSH
3698: CALL_OW 70
3702: PUSH
3703: LD_INT 0
3705: GREATER
3706: IFFALSE 3766
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3708: LD_INT 3
3710: PPUSH
3711: CALL 11999 0 1
3715: PUSH
3716: LD_INT 1
3718: ARRAY
3719: PPUSH
3720: LD_INT 21
3722: PUSH
3723: LD_INT 2
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: PUSH
3730: LD_INT 34
3732: PUSH
3733: LD_INT 49
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PPUSH
3744: CALL_OW 69
3748: PPUSH
3749: LD_EXP 14
3753: PPUSH
3754: LD_INT 97
3756: PPUSH
3757: LD_INT 9
3759: PPUSH
3760: CALL 11496 0 5
3764: GO 3822
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3766: LD_INT 3
3768: PPUSH
3769: CALL 11999 0 1
3773: PUSH
3774: LD_INT 1
3776: ARRAY
3777: PPUSH
3778: LD_INT 21
3780: PUSH
3781: LD_INT 2
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 34
3790: PUSH
3791: LD_INT 49
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PPUSH
3807: LD_EXP 14
3811: PPUSH
3812: LD_INT 153
3814: PPUSH
3815: LD_INT 102
3817: PPUSH
3818: CALL 11496 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3822: LD_EXP 23
3826: PUSH
3827: LD_INT 0
3829: EQUAL
3830: PUSH
3831: LD_INT 44
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: CALL_OW 321
3841: PUSH
3842: LD_INT 2
3844: EQUAL
3845: AND
3846: IFFALSE 3857
// ComChangeClassToBazooker ( ru_sold ) ;
3848: LD_EXP 19
3852: PPUSH
3853: CALL 10433 0 1
// if ru_bazz then
3857: LD_EXP 23
3861: IFFALSE 3875
// IntBazooka ( ru_bazz , 1 ) ;
3863: LD_EXP 23
3867: PPUSH
3868: LD_INT 1
3870: PPUSH
3871: CALL 10152 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3875: LD_INT 67
3877: PPUSH
3878: LD_INT 39
3880: PPUSH
3881: LD_INT 3
3883: PPUSH
3884: CALL_OW 440
3888: PUSH
3889: LD_INT 0
3891: EQUAL
3892: PUSH
3893: LD_INT 20
3895: PPUSH
3896: LD_INT 3
3898: PPUSH
3899: CALL_OW 321
3903: PUSH
3904: LD_INT 2
3906: EQUAL
3907: AND
3908: IFFALSE 3929
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3910: LD_EXP 22
3914: PUSH
3915: LD_INT 1
3917: ARRAY
3918: PPUSH
3919: LD_INT 67
3921: PPUSH
3922: LD_INT 39
3924: PPUSH
3925: CALL 9627 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3929: LD_INT 89
3931: PPUSH
3932: LD_INT 66
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: CALL_OW 440
3942: PUSH
3943: LD_INT 0
3945: EQUAL
3946: IFFALSE 3967
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
3948: LD_EXP 22
3952: PUSH
3953: LD_INT 1
3955: ARRAY
3956: PPUSH
3957: LD_INT 87
3959: PPUSH
3960: LD_INT 60
3962: PPUSH
3963: CALL 9627 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3967: LD_INT 104
3969: PPUSH
3970: LD_INT 94
3972: PPUSH
3973: LD_INT 3
3975: PPUSH
3976: CALL_OW 440
3980: PUSH
3981: LD_INT 0
3983: EQUAL
3984: PUSH
3985: LD_INT 20
3987: PPUSH
3988: LD_INT 3
3990: PPUSH
3991: CALL_OW 321
3995: PUSH
3996: LD_INT 2
3998: EQUAL
3999: AND
4000: IFFALSE 4021
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
4002: LD_EXP 22
4006: PUSH
4007: LD_INT 1
4009: ARRAY
4010: PPUSH
4011: LD_INT 104
4013: PPUSH
4014: LD_INT 94
4016: PPUSH
4017: CALL 9627 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
4021: LD_INT 3
4023: PPUSH
4024: LD_INT 24
4026: PPUSH
4027: LD_INT 53
4029: PPUSH
4030: CALL 8523 0 3
4034: PUSH
4035: LD_INT 1
4037: EQUAL
4038: PUSH
4039: LD_EXP 17
4043: AND
4044: IFFALSE 4185
// begin need_buldozer := false ;
4046: LD_ADDR_EXP 17
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4054: LD_INT 3
4056: PPUSH
4057: LD_INT 24
4059: PPUSH
4060: LD_INT 53
4062: PPUSH
4063: CALL 8523 0 3
4067: PUSH
4068: LD_INT 1
4070: ARRAY
4071: PPUSH
4072: LD_INT 67
4074: PPUSH
4075: LD_INT 39
4077: PPUSH
4078: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4082: LD_INT 3
4084: PPUSH
4085: LD_INT 24
4087: PPUSH
4088: LD_INT 53
4090: PPUSH
4091: CALL 8523 0 3
4095: PUSH
4096: LD_INT 1
4098: ARRAY
4099: PPUSH
4100: LD_INT 71
4102: PPUSH
4103: LD_INT 10
4105: PPUSH
4106: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4110: LD_INT 3
4112: PPUSH
4113: LD_INT 24
4115: PPUSH
4116: LD_INT 53
4118: PPUSH
4119: CALL 8523 0 3
4123: PUSH
4124: LD_INT 1
4126: ARRAY
4127: PPUSH
4128: LD_INT 15
4130: PPUSH
4131: CALL 6112 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4135: LD_INT 3
4137: PPUSH
4138: LD_INT 24
4140: PPUSH
4141: LD_INT 53
4143: PPUSH
4144: CALL 8523 0 3
4148: PUSH
4149: LD_INT 1
4151: ARRAY
4152: PPUSH
4153: LD_INT 350
4155: PPUSH
4156: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4160: LD_INT 3
4162: PPUSH
4163: LD_INT 24
4165: PPUSH
4166: LD_INT 53
4168: PPUSH
4169: CALL 8523 0 3
4173: PUSH
4174: LD_INT 1
4176: ARRAY
4177: PPUSH
4178: LD_INT 14
4180: PPUSH
4181: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4185: LD_INT 67
4187: PPUSH
4188: LD_INT 39
4190: PPUSH
4191: LD_INT 3
4193: PPUSH
4194: CALL_OW 440
4198: PUSH
4199: LD_INT 67
4201: PPUSH
4202: LD_INT 39
4204: PPUSH
4205: CALL_OW 428
4209: PUSH
4210: LD_INT 0
4212: EQUAL
4213: AND
4214: PUSH
4215: LD_INT 79
4217: PPUSH
4218: LD_INT 45
4220: PPUSH
4221: CALL_OW 428
4225: PPUSH
4226: CALL_OW 266
4230: PUSH
4231: LD_INT 0
4233: EQUAL
4234: AND
4235: PUSH
4236: LD_INT 1
4238: PPUSH
4239: LD_INT 79
4241: PPUSH
4242: LD_INT 45
4244: PPUSH
4245: CALL 5998 0 3
4249: PUSH
4250: LD_INT 0
4252: EQUAL
4253: AND
4254: IFFALSE 4357
// begin for i = 1 to ru_eng do
4256: LD_ADDR_VAR 0 1
4260: PUSH
4261: DOUBLE
4262: LD_INT 1
4264: DEC
4265: ST_TO_ADDR
4266: LD_EXP 20
4270: PUSH
4271: FOR_TO
4272: IFFALSE 4355
// if IsInUnit ( ru_eng [ i ] ) then
4274: LD_EXP 20
4278: PUSH
4279: LD_VAR 0 1
4283: ARRAY
4284: PPUSH
4285: CALL_OW 310
4289: IFFALSE 4308
// ComExitBuilding ( ru_eng [ i ] ) else
4291: LD_EXP 20
4295: PUSH
4296: LD_VAR 0 1
4300: ARRAY
4301: PPUSH
4302: CALL_OW 122
4306: GO 4353
// if not HasTask ( ru_eng [ i ] ) then
4308: LD_EXP 20
4312: PUSH
4313: LD_VAR 0 1
4317: ARRAY
4318: PPUSH
4319: CALL_OW 314
4323: NOT
4324: IFFALSE 4353
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4326: LD_EXP 20
4330: PUSH
4331: LD_VAR 0 1
4335: ARRAY
4336: PPUSH
4337: LD_INT 30
4339: PPUSH
4340: LD_INT 67
4342: PPUSH
4343: LD_INT 39
4345: PPUSH
4346: LD_INT 3
4348: PPUSH
4349: CALL_OW 145
4353: GO 4271
4355: POP
4356: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4357: LD_INT 1
4359: PPUSH
4360: LD_INT 79
4362: PPUSH
4363: LD_INT 45
4365: PPUSH
4366: CALL 5998 0 3
4370: PUSH
4371: LD_INT 0
4373: EQUAL
4374: IFFALSE 4570
// begin if HexInfo ( 79 , 45 ) = 0 then
4376: LD_INT 79
4378: PPUSH
4379: LD_INT 45
4381: PPUSH
4382: CALL_OW 428
4386: PUSH
4387: LD_INT 0
4389: EQUAL
4390: IFFALSE 4412
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4392: LD_EXP 20
4396: PPUSH
4397: LD_INT 79
4399: PPUSH
4400: LD_INT 45
4402: PPUSH
4403: LD_INT 3
4405: PPUSH
4406: CALL 7538 0 4
4410: GO 4570
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4412: LD_INT 89
4414: PPUSH
4415: LD_INT 66
4417: PPUSH
4418: CALL_OW 428
4422: PUSH
4423: LD_INT 0
4425: EQUAL
4426: PUSH
4427: LD_INT 89
4429: PPUSH
4430: LD_INT 66
4432: PPUSH
4433: LD_INT 3
4435: PPUSH
4436: CALL_OW 440
4440: AND
4441: IFFALSE 4570
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4443: LD_INT 79
4445: PPUSH
4446: LD_INT 45
4448: PPUSH
4449: CALL_OW 428
4453: PPUSH
4454: CALL_OW 274
4458: PPUSH
4459: LD_INT 1
4461: PPUSH
4462: LD_INT 100
4464: PPUSH
4465: CALL_OW 277
// for i = 1 to ru_eng do
4469: LD_ADDR_VAR 0 1
4473: PUSH
4474: DOUBLE
4475: LD_INT 1
4477: DEC
4478: ST_TO_ADDR
4479: LD_EXP 20
4483: PUSH
4484: FOR_TO
4485: IFFALSE 4568
// if IsInUnit ( ru_eng [ i ] ) then
4487: LD_EXP 20
4491: PUSH
4492: LD_VAR 0 1
4496: ARRAY
4497: PPUSH
4498: CALL_OW 310
4502: IFFALSE 4521
// ComExitBuilding ( ru_eng [ i ] ) else
4504: LD_EXP 20
4508: PUSH
4509: LD_VAR 0 1
4513: ARRAY
4514: PPUSH
4515: CALL_OW 122
4519: GO 4566
// if not HasTask ( ru_eng [ i ] ) then
4521: LD_EXP 20
4525: PUSH
4526: LD_VAR 0 1
4530: ARRAY
4531: PPUSH
4532: CALL_OW 314
4536: NOT
4537: IFFALSE 4566
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4539: LD_EXP 20
4543: PUSH
4544: LD_VAR 0 1
4548: ARRAY
4549: PPUSH
4550: LD_INT 29
4552: PPUSH
4553: LD_INT 89
4555: PPUSH
4556: LD_INT 66
4558: PPUSH
4559: LD_INT 3
4561: PPUSH
4562: CALL_OW 145
4566: GO 4484
4568: POP
4569: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4570: LD_INT 3
4572: PPUSH
4573: LD_INT 29
4575: PPUSH
4576: CALL 6770 0 2
4580: PUSH
4581: LD_INT 0
4583: EQUAL
4584: PUSH
4585: LD_INT 1
4587: PPUSH
4588: LD_INT 36
4590: PPUSH
4591: LD_INT 6
4593: PPUSH
4594: CALL 5998 0 3
4598: PUSH
4599: LD_INT 0
4601: EQUAL
4602: AND
4603: PUSH
4604: LD_INT 3
4606: PPUSH
4607: CALL 6679 0 1
4611: PPUSH
4612: LD_INT 29
4614: PPUSH
4615: CALL 6255 0 2
4619: AND
4620: IFFALSE 4723
// begin for i = 1 to ru_eng do
4622: LD_ADDR_VAR 0 1
4626: PUSH
4627: DOUBLE
4628: LD_INT 1
4630: DEC
4631: ST_TO_ADDR
4632: LD_EXP 20
4636: PUSH
4637: FOR_TO
4638: IFFALSE 4721
// begin if IsInUnit ( ru_eng [ i ] ) then
4640: LD_EXP 20
4644: PUSH
4645: LD_VAR 0 1
4649: ARRAY
4650: PPUSH
4651: CALL_OW 310
4655: IFFALSE 4674
// ComExitBuilding ( ru_eng [ i ] ) else
4657: LD_EXP 20
4661: PUSH
4662: LD_VAR 0 1
4666: ARRAY
4667: PPUSH
4668: CALL_OW 122
4672: GO 4719
// if not HasTask ( ru_eng [ i ] ) then
4674: LD_EXP 20
4678: PUSH
4679: LD_VAR 0 1
4683: ARRAY
4684: PPUSH
4685: CALL_OW 314
4689: NOT
4690: IFFALSE 4719
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4692: LD_EXP 20
4696: PUSH
4697: LD_VAR 0 1
4701: ARRAY
4702: PPUSH
4703: LD_INT 29
4705: PPUSH
4706: LD_INT 33
4708: PPUSH
4709: LD_INT 4
4711: PPUSH
4712: LD_INT 0
4714: PPUSH
4715: CALL_OW 205
// end ; end ;
4719: GO 4637
4721: POP
4722: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4723: LD_EXP 20
4727: PUSH
4728: LD_INT 79
4730: PPUSH
4731: LD_INT 45
4733: PPUSH
4734: CALL_OW 428
4738: PUSH
4739: LD_INT 0
4741: GREATER
4742: AND
4743: PUSH
4744: LD_INT 79
4746: PPUSH
4747: LD_INT 45
4749: PPUSH
4750: CALL_OW 428
4754: PPUSH
4755: CALL_OW 266
4759: PUSH
4760: LD_INT 0
4762: EQUAL
4763: AND
4764: IFFALSE 4924
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4766: LD_INT 79
4768: PPUSH
4769: LD_INT 45
4771: PPUSH
4772: CALL_OW 428
4776: PPUSH
4777: CALL_OW 255
4781: PUSH
4782: LD_INT 3
4784: EQUAL
4785: PUSH
4786: LD_INT 1
4788: PPUSH
4789: LD_INT 79
4791: PPUSH
4792: LD_INT 45
4794: PPUSH
4795: CALL 5998 0 3
4799: PUSH
4800: LD_INT 0
4802: EQUAL
4803: AND
4804: PUSH
4805: LD_INT 79
4807: PPUSH
4808: LD_INT 45
4810: PPUSH
4811: CALL_OW 428
4815: PPUSH
4816: CALL_OW 274
4820: PPUSH
4821: LD_INT 3
4823: PPUSH
4824: CALL_OW 275
4828: PUSH
4829: LD_INT 10
4831: GREATEREQUAL
4832: AND
4833: IFFALSE 4924
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4835: LD_EXP 20
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: CALL_OW 310
4848: IFFALSE 4865
// ComExitBuilding ( ru_eng [ 1 ] ) else
4850: LD_EXP 20
4854: PUSH
4855: LD_INT 1
4857: ARRAY
4858: PPUSH
4859: CALL_OW 122
4863: GO 4924
// if not HasTask ( ru_eng [ 1 ] ) then
4865: LD_EXP 20
4869: PUSH
4870: LD_INT 1
4872: ARRAY
4873: PPUSH
4874: CALL_OW 314
4878: NOT
4879: IFFALSE 4924
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4881: LD_EXP 20
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 79
4892: PPUSH
4893: LD_INT 45
4895: PPUSH
4896: CALL_OW 428
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4908: LD_EXP 20
4912: PUSH
4913: LD_INT 1
4915: ARRAY
4916: PPUSH
4917: LD_INT 2
4919: PPUSH
4920: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4924: LD_EXP 20
4928: PUSH
4929: LD_INT 2
4931: GREATER
4932: PUSH
4933: LD_INT 79
4935: PPUSH
4936: LD_INT 45
4938: PPUSH
4939: CALL_OW 428
4943: PUSH
4944: LD_INT 0
4946: GREATER
4947: AND
4948: PUSH
4949: LD_INT 79
4951: PPUSH
4952: LD_INT 45
4954: PPUSH
4955: CALL_OW 428
4959: PPUSH
4960: CALL_OW 266
4964: PUSH
4965: LD_INT 0
4967: EQUAL
4968: AND
4969: IFFALSE 5129
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
4971: LD_INT 79
4973: PPUSH
4974: LD_INT 45
4976: PPUSH
4977: CALL_OW 428
4981: PPUSH
4982: CALL_OW 255
4986: PUSH
4987: LD_INT 3
4989: EQUAL
4990: PUSH
4991: LD_INT 1
4993: PPUSH
4994: LD_INT 79
4996: PPUSH
4997: LD_INT 45
4999: PPUSH
5000: CALL 5998 0 3
5004: PUSH
5005: LD_INT 0
5007: EQUAL
5008: AND
5009: PUSH
5010: LD_INT 79
5012: PPUSH
5013: LD_INT 45
5015: PPUSH
5016: CALL_OW 428
5020: PPUSH
5021: CALL_OW 274
5025: PPUSH
5026: LD_INT 1
5028: PPUSH
5029: CALL_OW 275
5033: PUSH
5034: LD_INT 20
5036: GREATER
5037: AND
5038: IFFALSE 5129
// begin if IsInUnit ( ru_eng [ 2 ] ) then
5040: LD_EXP 20
5044: PUSH
5045: LD_INT 2
5047: ARRAY
5048: PPUSH
5049: CALL_OW 310
5053: IFFALSE 5070
// ComExitBuilding ( ru_eng [ 2 ] ) else
5055: LD_EXP 20
5059: PUSH
5060: LD_INT 2
5062: ARRAY
5063: PPUSH
5064: CALL_OW 122
5068: GO 5129
// if not HasTask ( ru_eng [ 2 ] ) then
5070: LD_EXP 20
5074: PUSH
5075: LD_INT 2
5077: ARRAY
5078: PPUSH
5079: CALL_OW 314
5083: NOT
5084: IFFALSE 5129
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5086: LD_EXP 20
5090: PUSH
5091: LD_INT 2
5093: ARRAY
5094: PPUSH
5095: LD_INT 79
5097: PPUSH
5098: LD_INT 45
5100: PPUSH
5101: CALL_OW 428
5105: PPUSH
5106: LD_INT 1
5108: PPUSH
5109: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5113: LD_EXP 20
5117: PUSH
5118: LD_INT 2
5120: ARRAY
5121: PPUSH
5122: LD_INT 2
5124: PPUSH
5125: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5129: LD_INT 1
5131: PPUSH
5132: LD_INT 59
5134: PPUSH
5135: LD_INT 60
5137: PPUSH
5138: CALL 5998 0 3
5142: PUSH
5143: LD_INT 0
5145: EQUAL
5146: PUSH
5147: LD_INT 1
5149: PPUSH
5150: LD_INT 67
5152: PPUSH
5153: LD_INT 76
5155: PPUSH
5156: CALL 5998 0 3
5160: PUSH
5161: LD_INT 0
5163: EQUAL
5164: AND
5165: PUSH
5166: LD_INT 1
5168: PPUSH
5169: LD_INT 79
5171: PPUSH
5172: LD_INT 100
5174: PPUSH
5175: CALL 5998 0 3
5179: PUSH
5180: LD_INT 0
5182: EQUAL
5183: AND
5184: IFFALSE 5196
// CollectCrates ( 3 , west_crates ) ;
5186: LD_INT 3
5188: PPUSH
5189: LD_INT 13
5191: PPUSH
5192: CALL 12043 0 2
// end ;
5196: PPOPN 10
5198: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5199: LD_OWVAR 1
5203: PUSH
5204: LD_INT 111300
5206: LESSEQUAL
5207: PUSH
5208: LD_EXP 29
5212: NOT
5213: OR
5214: IFFALSE 5411
5216: GO 5218
5218: DISABLE
5219: LD_INT 0
5221: PPUSH
// begin enable ;
5222: ENABLE
// uc_nation := 3 ;
5223: LD_ADDR_OWVAR 21
5227: PUSH
5228: LD_INT 3
5230: ST_TO_ADDR
// uc_side := 3 ;
5231: LD_ADDR_OWVAR 20
5235: PUSH
5236: LD_INT 3
5238: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5239: LD_ADDR_OWVAR 37
5243: PUSH
5244: LD_INT 22
5246: ST_TO_ADDR
// vc_engine := engine_siberite ;
5247: LD_ADDR_OWVAR 39
5251: PUSH
5252: LD_INT 3
5254: ST_TO_ADDR
// vc_control := control_computer ;
5255: LD_ADDR_OWVAR 38
5259: PUSH
5260: LD_INT 3
5262: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5263: LD_ADDR_OWVAR 40
5267: PUSH
5268: LD_INT 51
5270: ST_TO_ADDR
// veh := CreateVehicle ;
5271: LD_ADDR_VAR 0 1
5275: PUSH
5276: CALL_OW 45
5280: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5281: LD_VAR 0 1
5285: PPUSH
5286: LD_INT 4
5288: PPUSH
5289: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5293: LD_VAR 0 1
5297: PPUSH
5298: LD_INT 10
5300: PPUSH
5301: LD_INT 0
5303: PPUSH
5304: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5308: LD_VAR 0 1
5312: PPUSH
5313: LD_INT 1
5315: PUSH
5316: LD_INT 2
5318: PUSH
5319: LD_INT 3
5321: PUSH
5322: LD_INT 2
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 1
5333: PPUSH
5334: LD_INT 4
5336: PPUSH
5337: CALL_OW 12
5341: ARRAY
5342: PPUSH
5343: LD_INT 100
5345: PPUSH
5346: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5350: LD_VAR 0 1
5354: PPUSH
5355: LD_INT 2
5357: PPUSH
5358: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5362: LD_VAR 0 1
5366: PPUSH
5367: LD_INT 10
5369: PPUSH
5370: CALL_OW 173
// Wait ( 0 0$10 ) ;
5374: LD_INT 350
5376: PPUSH
5377: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5381: LD_INT 35
5383: PPUSH
5384: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5388: LD_VAR 0 1
5392: PPUSH
5393: LD_INT 10
5395: PPUSH
5396: CALL_OW 308
5400: IFFALSE 5381
// RemoveUnit ( veh ) ;
5402: LD_VAR 0 1
5406: PPUSH
5407: CALL_OW 64
// end ;
5411: PPOPN 1
5413: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
5414: LD_VAR 0 1
5418: PPUSH
5419: CALL_OW 255
5423: PUSH
5424: LD_INT 3
5426: EQUAL
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 2
5435: PUSH
5436: LD_INT 34
5438: PUSH
5439: LD_INT 46
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PUSH
5446: LD_INT 34
5448: PUSH
5449: LD_INT 47
5451: PUSH
5452: EMPTY
5453: LIST
5454: LIST
5455: PUSH
5456: LD_INT 34
5458: PUSH
5459: LD_INT 45
5461: PUSH
5462: EMPTY
5463: LIST
5464: LIST
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: PUSH
5472: EMPTY
5473: LIST
5474: PPUSH
5475: CALL_OW 69
5479: IN
5480: AND
5481: IFFALSE 5499
// ru_reserve := ru_reserve ^ un ;
5483: LD_ADDR_EXP 8
5487: PUSH
5488: LD_EXP 8
5492: PUSH
5493: LD_VAR 0 1
5497: ADD
5498: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
5499: LD_VAR 0 1
5503: PUSH
5504: LD_INT 22
5506: PUSH
5507: LD_INT 3
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: PUSH
5514: LD_INT 34
5516: PUSH
5517: LD_INT 48
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL_OW 69
5532: IN
5533: IFFALSE 5586
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
5535: LD_INT 12
5537: PPUSH
5538: LD_INT 22
5540: PUSH
5541: LD_INT 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PPUSH
5548: CALL_OW 70
5552: IFFALSE 5571
// ComAttackPlace ( un , 98 , 10 ) else
5554: LD_VAR 0 1
5558: PPUSH
5559: LD_INT 98
5561: PPUSH
5562: LD_INT 10
5564: PPUSH
5565: CALL_OW 116
5569: GO 5586
// ComAttackPlace ( un , 134 , 99 ) ;
5571: LD_VAR 0 1
5575: PPUSH
5576: LD_INT 134
5578: PPUSH
5579: LD_INT 99
5581: PPUSH
5582: CALL_OW 116
// end ;
5586: PPOPN 2
5588: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
5589: LD_VAR 0 1
5593: PUSH
5594: LD_INT 22
5596: PUSH
5597: LD_INT 3
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 21
5606: PUSH
5607: LD_INT 3
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PPUSH
5618: CALL_OW 69
5622: IN
5623: PUSH
5624: LD_VAR 0 1
5628: PPUSH
5629: CALL_OW 266
5633: PUSH
5634: LD_INT 0
5636: PUSH
5637: LD_INT 29
5639: PUSH
5640: LD_INT 30
5642: PUSH
5643: LD_INT 26
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: IN
5652: NOT
5653: AND
5654: IFFALSE 5740
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
5656: LD_ADDR_EXP 12
5660: PUSH
5661: LD_EXP 12
5665: PUSH
5666: LD_VAR 0 1
5670: PPUSH
5671: CALL_OW 266
5675: ADD
5676: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
5677: LD_ADDR_EXP 12
5681: PUSH
5682: LD_EXP 12
5686: PUSH
5687: LD_VAR 0 1
5691: PPUSH
5692: CALL_OW 250
5696: ADD
5697: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
5698: LD_ADDR_EXP 12
5702: PUSH
5703: LD_EXP 12
5707: PUSH
5708: LD_VAR 0 1
5712: PPUSH
5713: CALL_OW 251
5717: ADD
5718: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
5719: LD_ADDR_EXP 12
5723: PUSH
5724: LD_EXP 12
5728: PUSH
5729: LD_VAR 0 1
5733: PPUSH
5734: CALL_OW 254
5738: ADD
5739: ST_TO_ADDR
// end ; if un in ru_attack_list then
5740: LD_VAR 0 1
5744: PUSH
5745: LD_EXP 9
5749: IN
5750: IFFALSE 5768
// ru_attack_list := ru_attack_list diff un ;
5752: LD_ADDR_EXP 9
5756: PUSH
5757: LD_EXP 9
5761: PUSH
5762: LD_VAR 0 1
5766: DIFF
5767: ST_TO_ADDR
// if un in ru_protector then
5768: LD_VAR 0 1
5772: PUSH
5773: LD_EXP 16
5777: IN
5778: IFFALSE 5796
// ru_protector := ru_protector diff un ;
5780: LD_ADDR_EXP 16
5784: PUSH
5785: LD_EXP 16
5789: PUSH
5790: LD_VAR 0 1
5794: DIFF
5795: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
5796: LD_VAR 0 1
5800: PPUSH
5801: CALL_OW 266
5805: PUSH
5806: LD_INT 30
5808: EQUAL
5809: PUSH
5810: LD_VAR 0 1
5814: PPUSH
5815: CALL_OW 255
5819: PUSH
5820: LD_INT 1
5822: EQUAL
5823: AND
5824: IFFALSE 5834
// mine_ck := true ;
5826: LD_ADDR_EXP 34
5830: PUSH
5831: LD_INT 1
5833: ST_TO_ADDR
// end ;
5834: PPOPN 1
5836: END
// on BuildingComplete ( un ) do var i ;
5837: LD_INT 0
5839: PPUSH
// begin if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
5840: LD_VAR 0 1
5844: PPUSH
5845: CALL_OW 255
5849: PUSH
5850: LD_INT 3
5852: EQUAL
5853: PUSH
5854: LD_VAR 0 1
5858: PPUSH
5859: CALL_OW 266
5863: PUSH
5864: LD_INT 0
5866: EQUAL
5867: AND
5868: IFFALSE 5925
// begin for i = 1 to 2 do
5870: LD_ADDR_VAR 0 2
5874: PUSH
5875: DOUBLE
5876: LD_INT 1
5878: DEC
5879: ST_TO_ADDR
5880: LD_INT 2
5882: PUSH
5883: FOR_TO
5884: IFFALSE 5923
// begin ComExitBuilding ( ru_sold [ i ] ) ;
5886: LD_EXP 19
5890: PUSH
5891: LD_VAR 0 2
5895: ARRAY
5896: PPUSH
5897: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
5901: LD_EXP 19
5905: PUSH
5906: LD_VAR 0 2
5910: ARRAY
5911: PPUSH
5912: LD_VAR 0 1
5916: PPUSH
5917: CALL_OW 180
// end ;
5921: GO 5883
5923: POP
5924: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
5925: LD_VAR 0 1
5929: PPUSH
5930: CALL_OW 255
5934: PUSH
5935: LD_INT 3
5937: EQUAL
5938: PUSH
5939: LD_VAR 0 1
5943: PPUSH
5944: CALL_OW 266
5948: PUSH
5949: LD_EXP 12
5953: IN
5954: AND
5955: IFFALSE 5995
// for i = 1 to 4 do
5957: LD_ADDR_VAR 0 2
5961: PUSH
5962: DOUBLE
5963: LD_INT 1
5965: DEC
5966: ST_TO_ADDR
5967: LD_INT 4
5969: PUSH
5970: FOR_TO
5971: IFFALSE 5993
// ru_blist := Delete ( ru_blist , 1 ) ;
5973: LD_ADDR_EXP 12
5977: PUSH
5978: LD_EXP 12
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL_OW 3
5990: ST_TO_ADDR
5991: GO 5970
5993: POP
5994: POP
// end ; end_of_file
5995: PPOPN 2
5997: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
5998: LD_INT 0
6000: PPUSH
6001: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
6002: LD_ADDR_VAR 0 5
6006: PUSH
6007: LD_INT 22
6009: PUSH
6010: LD_VAR 0 1
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PPUSH
6019: CALL_OW 69
6023: PPUSH
6024: LD_VAR 0 2
6028: PPUSH
6029: LD_VAR 0 3
6033: PPUSH
6034: CALL_OW 73
6038: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 then
6039: LD_VAR 0 5
6043: PPUSH
6044: LD_VAR 0 2
6048: PPUSH
6049: LD_VAR 0 3
6053: PPUSH
6054: CALL_OW 297
6058: PUSH
6059: LD_INT 17
6061: LESS
6062: PUSH
6063: LD_INT 2
6065: PPUSH
6066: LD_INT 22
6068: PUSH
6069: LD_VAR 0 1
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: PPUSH
6078: CALL_OW 70
6082: PUSH
6083: LD_INT 0
6085: GREATER
6086: OR
6087: IFFALSE 6099
// result := true else
6089: LD_ADDR_VAR 0 4
6093: PUSH
6094: LD_INT 1
6096: ST_TO_ADDR
6097: GO 6107
// result := false ;
6099: LD_ADDR_VAR 0 4
6103: PUSH
6104: LD_INT 0
6106: ST_TO_ADDR
// end ;
6107: LD_VAR 0 4
6111: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
6112: LD_INT 0
6114: PPUSH
6115: PPUSH
// area = ListEnvironmentArea ( area ) ;
6116: LD_ADDR_VAR 0 2
6120: PUSH
6121: LD_VAR 0 2
6125: PPUSH
6126: CALL_OW 353
6130: ST_TO_ADDR
// if bulldozer > 0 then
6131: LD_VAR 0 1
6135: PUSH
6136: LD_INT 0
6138: GREATER
6139: IFFALSE 6250
// for i = 1 to area do
6141: LD_ADDR_VAR 0 4
6145: PUSH
6146: DOUBLE
6147: LD_INT 1
6149: DEC
6150: ST_TO_ADDR
6151: LD_VAR 0 2
6155: PUSH
6156: FOR_TO
6157: IFFALSE 6248
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
6159: LD_VAR 0 2
6163: PUSH
6164: LD_VAR 0 4
6168: ARRAY
6169: PUSH
6170: LD_INT 1
6172: ARRAY
6173: PPUSH
6174: LD_VAR 0 2
6178: PUSH
6179: LD_VAR 0 4
6183: ARRAY
6184: PUSH
6185: LD_INT 2
6187: ARRAY
6188: PPUSH
6189: CALL_OW 351
6193: IFFALSE 6246
// if not HasTask ( bulldozer ) then
6195: LD_VAR 0 1
6199: PPUSH
6200: CALL_OW 314
6204: NOT
6205: IFFALSE 6246
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
6207: LD_VAR 0 1
6211: PPUSH
6212: LD_VAR 0 2
6216: PUSH
6217: LD_VAR 0 4
6221: ARRAY
6222: PUSH
6223: LD_INT 1
6225: ARRAY
6226: PPUSH
6227: LD_VAR 0 2
6231: PUSH
6232: LD_VAR 0 4
6236: ARRAY
6237: PUSH
6238: LD_INT 2
6240: ARRAY
6241: PPUSH
6242: CALL_OW 171
6246: GO 6156
6248: POP
6249: POP
// end ;
6250: LD_VAR 0 3
6254: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
6255: LD_INT 0
6257: PPUSH
6258: PPUSH
6259: PPUSH
// pom := GetBase ( bdepot ) ;
6260: LD_ADDR_VAR 0 4
6264: PUSH
6265: LD_VAR 0 1
6269: PPUSH
6270: CALL_OW 274
6274: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
6275: LD_ADDR_VAR 0 5
6279: PUSH
6280: LD_VAR 0 2
6284: PPUSH
6285: LD_VAR 0 1
6289: PPUSH
6290: CALL_OW 248
6294: PPUSH
6295: CALL_OW 450
6299: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
6300: LD_VAR 0 4
6304: PPUSH
6305: LD_INT 1
6307: PPUSH
6308: CALL_OW 275
6312: PUSH
6313: LD_VAR 0 5
6317: PUSH
6318: LD_INT 1
6320: ARRAY
6321: GREATEREQUAL
6322: PUSH
6323: LD_VAR 0 4
6327: PPUSH
6328: LD_INT 3
6330: PPUSH
6331: CALL_OW 275
6335: PUSH
6336: LD_VAR 0 5
6340: PUSH
6341: LD_INT 3
6343: ARRAY
6344: GREATEREQUAL
6345: AND
6346: IFFALSE 6358
// result := true else
6348: LD_ADDR_VAR 0 3
6352: PUSH
6353: LD_INT 1
6355: ST_TO_ADDR
6356: GO 6366
// result := false ;
6358: LD_ADDR_VAR 0 3
6362: PUSH
6363: LD_INT 0
6365: ST_TO_ADDR
// end ;
6366: LD_VAR 0 3
6370: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
6371: LD_INT 0
6373: PPUSH
6374: PPUSH
6375: PPUSH
// pom := GetBase ( bdepot ) ;
6376: LD_ADDR_VAR 0 3
6380: PUSH
6381: LD_VAR 0 1
6385: PPUSH
6386: CALL_OW 274
6390: ST_TO_ADDR
// sor := [ ] ;
6391: LD_ADDR_VAR 0 4
6395: PUSH
6396: EMPTY
6397: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
6398: LD_ADDR_VAR 0 4
6402: PUSH
6403: LD_VAR 0 4
6407: PUSH
6408: LD_VAR 0 3
6412: PPUSH
6413: LD_INT 1
6415: PPUSH
6416: CALL_OW 275
6420: ADD
6421: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
6422: LD_ADDR_VAR 0 4
6426: PUSH
6427: LD_VAR 0 4
6431: PUSH
6432: LD_VAR 0 3
6436: PPUSH
6437: LD_INT 2
6439: PPUSH
6440: CALL_OW 275
6444: ADD
6445: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
6446: LD_ADDR_VAR 0 4
6450: PUSH
6451: LD_VAR 0 4
6455: PUSH
6456: LD_VAR 0 3
6460: PPUSH
6461: LD_INT 3
6463: PPUSH
6464: CALL_OW 275
6468: ADD
6469: ST_TO_ADDR
// result := sor ;
6470: LD_ADDR_VAR 0 2
6474: PUSH
6475: LD_VAR 0 4
6479: ST_TO_ADDR
// end ;
6480: LD_VAR 0 2
6484: RET
// export function Hex ( x , y ) ; begin
6485: LD_INT 0
6487: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
6488: LD_VAR 0 1
6492: PPUSH
6493: LD_VAR 0 2
6497: PPUSH
6498: CALL_OW 488
6502: PUSH
6503: LD_VAR 0 1
6507: PPUSH
6508: LD_VAR 0 2
6512: PPUSH
6513: CALL_OW 428
6517: PUSH
6518: LD_INT 0
6520: EQUAL
6521: AND
6522: IFFALSE 6534
// result := true else
6524: LD_ADDR_VAR 0 3
6528: PUSH
6529: LD_INT 1
6531: ST_TO_ADDR
6532: GO 6542
// result := false ;
6534: LD_ADDR_VAR 0 3
6538: PUSH
6539: LD_INT 0
6541: ST_TO_ADDR
// end ;
6542: LD_VAR 0 3
6546: RET
// export function NeedBuilding ( side , btype ) ; begin
6547: LD_INT 0
6549: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
6550: LD_INT 22
6552: PUSH
6553: LD_VAR 0 1
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 30
6564: PUSH
6565: LD_VAR 0 2
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 3
6576: PUSH
6577: LD_INT 57
6579: PUSH
6580: EMPTY
6581: LIST
6582: PUSH
6583: EMPTY
6584: LIST
6585: LIST
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: LIST
6591: PPUSH
6592: CALL_OW 69
6596: PUSH
6597: LD_INT 0
6599: EQUAL
6600: IFFALSE 6612
// result := true else
6602: LD_ADDR_VAR 0 3
6606: PUSH
6607: LD_INT 1
6609: ST_TO_ADDR
6610: GO 6620
// result := false ;
6612: LD_ADDR_VAR 0 3
6616: PUSH
6617: LD_INT 0
6619: ST_TO_ADDR
// end ;
6620: LD_VAR 0 3
6624: RET
// export function NeedBase ( side ) ; begin
6625: LD_INT 0
6627: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6628: LD_VAR 0 1
6632: PPUSH
6633: LD_INT 0
6635: PPUSH
6636: CALL 6547 0 2
6640: PUSH
6641: LD_VAR 0 1
6645: PPUSH
6646: LD_INT 1
6648: PPUSH
6649: CALL 6547 0 2
6653: AND
6654: IFFALSE 6666
// result := true else
6656: LD_ADDR_VAR 0 2
6660: PUSH
6661: LD_INT 1
6663: ST_TO_ADDR
6664: GO 6674
// result := false ;
6666: LD_ADDR_VAR 0 2
6670: PUSH
6671: LD_INT 0
6673: ST_TO_ADDR
// end ;
6674: LD_VAR 0 2
6678: RET
// export function MyBase ( side ) ; begin
6679: LD_INT 0
6681: PPUSH
// if not NeedBase ( side ) then
6682: LD_VAR 0 1
6686: PPUSH
6687: CALL 6625 0 1
6691: NOT
6692: IFFALSE 6757
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6694: LD_ADDR_VAR 0 2
6698: PUSH
6699: LD_INT 22
6701: PUSH
6702: LD_VAR 0 1
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: PUSH
6711: LD_INT 2
6713: PUSH
6714: LD_INT 30
6716: PUSH
6717: LD_INT 0
6719: PUSH
6720: EMPTY
6721: LIST
6722: LIST
6723: PUSH
6724: LD_INT 30
6726: PUSH
6727: LD_INT 1
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: LIST
6738: PUSH
6739: EMPTY
6740: LIST
6741: LIST
6742: PUSH
6743: EMPTY
6744: LIST
6745: PPUSH
6746: CALL_OW 69
6750: PUSH
6751: LD_INT 1
6753: ARRAY
6754: ST_TO_ADDR
6755: GO 6765
// result := false ;
6757: LD_ADDR_VAR 0 2
6761: PUSH
6762: LD_INT 0
6764: ST_TO_ADDR
// end ;
6765: LD_VAR 0 2
6769: RET
// export function GetBuilding ( side , btype ) ; begin
6770: LD_INT 0
6772: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6773: LD_INT 22
6775: PUSH
6776: LD_VAR 0 1
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: PUSH
6785: LD_INT 30
6787: PUSH
6788: LD_VAR 0 2
6792: PUSH
6793: EMPTY
6794: LIST
6795: LIST
6796: PUSH
6797: EMPTY
6798: LIST
6799: LIST
6800: PPUSH
6801: CALL_OW 69
6805: PUSH
6806: LD_INT 0
6808: GREATER
6809: IFFALSE 6851
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6811: LD_ADDR_VAR 0 3
6815: PUSH
6816: LD_INT 22
6818: PUSH
6819: LD_VAR 0 1
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: PUSH
6828: LD_INT 30
6830: PUSH
6831: LD_VAR 0 2
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL_OW 69
6848: ST_TO_ADDR
6849: GO 6859
// result := false ;
6851: LD_ADDR_VAR 0 3
6855: PUSH
6856: LD_INT 0
6858: ST_TO_ADDR
// end ;
6859: LD_VAR 0 3
6863: RET
// export function GetCrates ( side ) ; begin
6864: LD_INT 0
6866: PPUSH
// if MyBase ( side ) then
6867: LD_VAR 0 1
6871: PPUSH
6872: CALL 6679 0 1
6876: IFFALSE 6908
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
6878: LD_ADDR_VAR 0 2
6882: PUSH
6883: LD_VAR 0 1
6887: PPUSH
6888: CALL 6679 0 1
6892: PPUSH
6893: CALL_OW 274
6897: PPUSH
6898: LD_INT 1
6900: PPUSH
6901: CALL_OW 275
6905: ST_TO_ADDR
6906: GO 6916
// result := false ;
6908: LD_ADDR_VAR 0 2
6912: PUSH
6913: LD_INT 0
6915: ST_TO_ADDR
// end ;
6916: LD_VAR 0 2
6920: RET
// export function GetLabs ( side ) ; begin
6921: LD_INT 0
6923: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6924: LD_ADDR_VAR 0 2
6928: PUSH
6929: LD_INT 22
6931: PUSH
6932: LD_VAR 0 1
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 2
6943: PUSH
6944: LD_INT 30
6946: PUSH
6947: LD_INT 6
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: PUSH
6954: LD_INT 30
6956: PUSH
6957: LD_INT 8
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: PUSH
6964: LD_INT 30
6966: PUSH
6967: LD_INT 7
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: PPUSH
6987: CALL_OW 69
6991: ST_TO_ADDR
// end ;
6992: LD_VAR 0 2
6996: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
6997: LD_INT 0
6999: PPUSH
7000: PPUSH
7001: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
7002: LD_ADDR_VAR 0 3
7006: PUSH
7007: LD_VAR 0 1
7011: PPUSH
7012: LD_INT 1
7014: PPUSH
7015: CALL_OW 268
7019: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
7020: LD_ADDR_VAR 0 4
7024: PUSH
7025: LD_VAR 0 1
7029: PPUSH
7030: LD_INT 2
7032: PPUSH
7033: CALL_OW 268
7037: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
7038: LD_ADDR_VAR 0 2
7042: PUSH
7043: LD_VAR 0 3
7047: PUSH
7048: LD_VAR 0 4
7052: PUSH
7053: EMPTY
7054: LIST
7055: LIST
7056: ST_TO_ADDR
// end ;
7057: LD_VAR 0 2
7061: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
7062: LD_INT 0
7064: PPUSH
7065: PPUSH
// result := false ;
7066: LD_ADDR_VAR 0 3
7070: PUSH
7071: LD_INT 0
7073: ST_TO_ADDR
// for i = 1 to tlist do
7074: LD_ADDR_VAR 0 4
7078: PUSH
7079: DOUBLE
7080: LD_INT 1
7082: DEC
7083: ST_TO_ADDR
7084: LD_VAR 0 2
7088: PUSH
7089: FOR_TO
7090: IFFALSE 7130
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7092: LD_VAR 0 2
7096: PUSH
7097: LD_VAR 0 4
7101: ARRAY
7102: PPUSH
7103: LD_VAR 0 1
7107: PPUSH
7108: CALL_OW 321
7112: PUSH
7113: LD_INT 2
7115: NONEQUAL
7116: IFFALSE 7128
// begin result := true ;
7118: LD_ADDR_VAR 0 3
7122: PUSH
7123: LD_INT 1
7125: ST_TO_ADDR
// break ;
7126: GO 7130
// end ;
7128: GO 7089
7130: POP
7131: POP
// end ;
7132: LD_VAR 0 3
7136: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
7137: LD_INT 0
7139: PPUSH
7140: PPUSH
7141: PPUSH
7142: PPUSH
7143: PPUSH
7144: PPUSH
7145: PPUSH
7146: PPUSH
// lab := GetLabs ( side ) ;
7147: LD_ADDR_VAR 0 5
7151: PUSH
7152: LD_VAR 0 1
7156: PPUSH
7157: CALL 6921 0 1
7161: ST_TO_ADDR
// tmp := 0 ;
7162: LD_ADDR_VAR 0 7
7166: PUSH
7167: LD_INT 0
7169: ST_TO_ADDR
// list := [ ] ;
7170: LD_ADDR_VAR 0 8
7174: PUSH
7175: EMPTY
7176: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
7177: LD_ADDR_VAR 0 10
7181: PUSH
7182: LD_INT 35
7184: PUSH
7185: LD_INT 45
7187: PUSH
7188: LD_INT 46
7190: PUSH
7191: LD_INT 47
7193: PUSH
7194: LD_INT 1
7196: PUSH
7197: LD_INT 2
7199: PUSH
7200: LD_INT 48
7202: PUSH
7203: LD_INT 49
7205: PUSH
7206: LD_INT 50
7208: PUSH
7209: LD_INT 20
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: LIST
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: ST_TO_ADDR
// for i = 1 to tlist do
7224: LD_ADDR_VAR 0 4
7228: PUSH
7229: DOUBLE
7230: LD_INT 1
7232: DEC
7233: ST_TO_ADDR
7234: LD_VAR 0 2
7238: PUSH
7239: FOR_TO
7240: IFFALSE 7292
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7242: LD_VAR 0 2
7246: PUSH
7247: LD_VAR 0 4
7251: ARRAY
7252: PPUSH
7253: LD_VAR 0 1
7257: PPUSH
7258: CALL_OW 321
7262: PUSH
7263: LD_INT 2
7265: NONEQUAL
7266: IFFALSE 7290
// list := list ^ tlist [ i ] ;
7268: LD_ADDR_VAR 0 8
7272: PUSH
7273: LD_VAR 0 8
7277: PUSH
7278: LD_VAR 0 2
7282: PUSH
7283: LD_VAR 0 4
7287: ARRAY
7288: ADD
7289: ST_TO_ADDR
7290: GO 7239
7292: POP
7293: POP
// if list then
7294: LD_VAR 0 8
7298: IFFALSE 7463
// begin for i = 1 to lab do
7300: LD_ADDR_VAR 0 4
7304: PUSH
7305: DOUBLE
7306: LD_INT 1
7308: DEC
7309: ST_TO_ADDR
7310: LD_VAR 0 5
7314: PUSH
7315: FOR_TO
7316: IFFALSE 7386
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
7318: LD_VAR 0 8
7322: PUSH
7323: LD_INT 1
7325: ARRAY
7326: PUSH
7327: LD_VAR 0 10
7331: IN
7332: PUSH
7333: LD_VAR 0 8
7337: PUSH
7338: LD_INT 1
7340: ARRAY
7341: PPUSH
7342: CALL_OW 481
7346: PUSH
7347: LD_VAR 0 5
7351: PUSH
7352: LD_VAR 0 4
7356: ARRAY
7357: PPUSH
7358: CALL 6997 0 1
7362: IN
7363: OR
7364: IFFALSE 7384
// begin mylab := lab [ i ] ;
7366: LD_ADDR_VAR 0 9
7370: PUSH
7371: LD_VAR 0 5
7375: PUSH
7376: LD_VAR 0 4
7380: ARRAY
7381: ST_TO_ADDR
// break ;
7382: GO 7386
// end ;
7384: GO 7315
7386: POP
7387: POP
// if mylab then
7388: LD_VAR 0 9
7392: IFFALSE 7453
// begin if BuildingStatus ( mylab ) = bs_idle then
7394: LD_VAR 0 9
7398: PPUSH
7399: CALL_OW 461
7403: PUSH
7404: LD_INT 2
7406: EQUAL
7407: IFFALSE 7451
// for i = 1 to list do
7409: LD_ADDR_VAR 0 4
7413: PUSH
7414: DOUBLE
7415: LD_INT 1
7417: DEC
7418: ST_TO_ADDR
7419: LD_VAR 0 8
7423: PUSH
7424: FOR_TO
7425: IFFALSE 7449
// AddComResearch ( mylab , list [ i ] ) ;
7427: LD_VAR 0 9
7431: PPUSH
7432: LD_VAR 0 8
7436: PUSH
7437: LD_VAR 0 4
7441: ARRAY
7442: PPUSH
7443: CALL_OW 184
7447: GO 7424
7449: POP
7450: POP
// end else
7451: GO 7461
// result := false ;
7453: LD_ADDR_VAR 0 3
7457: PUSH
7458: LD_INT 0
7460: ST_TO_ADDR
// end else
7461: GO 7471
// result := false ;
7463: LD_ADDR_VAR 0 3
7467: PUSH
7468: LD_INT 0
7470: ST_TO_ADDR
// end ;
7471: LD_VAR 0 3
7475: RET
// export function GetTowers ( side ) ; begin
7476: LD_INT 0
7478: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
7479: LD_ADDR_VAR 0 2
7483: PUSH
7484: LD_INT 22
7486: PUSH
7487: LD_VAR 0 1
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: PUSH
7496: LD_INT 2
7498: PUSH
7499: LD_INT 30
7501: PUSH
7502: LD_INT 32
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 30
7511: PUSH
7512: LD_INT 33
7514: PUSH
7515: EMPTY
7516: LIST
7517: LIST
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PPUSH
7528: CALL_OW 69
7532: ST_TO_ADDR
// end ;
7533: LD_VAR 0 2
7537: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
7538: LD_INT 0
7540: PPUSH
7541: PPUSH
// if Hex ( x , y ) then
7542: LD_VAR 0 2
7546: PPUSH
7547: LD_VAR 0 3
7551: PPUSH
7552: CALL 6485 0 2
7556: IFFALSE 7631
// for i = 1 to plist do
7558: LD_ADDR_VAR 0 6
7562: PUSH
7563: DOUBLE
7564: LD_INT 1
7566: DEC
7567: ST_TO_ADDR
7568: LD_VAR 0 1
7572: PUSH
7573: FOR_TO
7574: IFFALSE 7629
// if not HasTask ( plist [ i ] ) then
7576: LD_VAR 0 1
7580: PUSH
7581: LD_VAR 0 6
7585: ARRAY
7586: PPUSH
7587: CALL_OW 314
7591: NOT
7592: IFFALSE 7627
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
7594: LD_VAR 0 1
7598: PUSH
7599: LD_VAR 0 6
7603: ARRAY
7604: PPUSH
7605: LD_INT 0
7607: PPUSH
7608: LD_VAR 0 2
7612: PPUSH
7613: LD_VAR 0 3
7617: PPUSH
7618: LD_VAR 0 4
7622: PPUSH
7623: CALL_OW 145
7627: GO 7573
7629: POP
7630: POP
// end ;
7631: LD_VAR 0 5
7635: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7636: LD_INT 0
7638: PPUSH
7639: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7640: LD_VAR 0 2
7644: PPUSH
7645: CALL_OW 266
7649: PUSH
7650: LD_INT 0
7652: EQUAL
7653: PUSH
7654: LD_VAR 0 2
7658: PPUSH
7659: LD_INT 1
7661: PPUSH
7662: CALL 6255 0 2
7666: AND
7667: PUSH
7668: LD_VAR 0 1
7672: PUSH
7673: LD_INT 1
7675: ARRAY
7676: PPUSH
7677: CALL_OW 255
7681: PPUSH
7682: CALL_OW 345
7686: NOT
7687: AND
7688: IFFALSE 7784
// begin ComUpgrade ( bident ) ;
7690: LD_VAR 0 2
7694: PPUSH
7695: CALL_OW 146
// for i = 1 to plist do
7699: LD_ADDR_VAR 0 4
7703: PUSH
7704: DOUBLE
7705: LD_INT 1
7707: DEC
7708: ST_TO_ADDR
7709: LD_VAR 0 1
7713: PUSH
7714: FOR_TO
7715: IFFALSE 7772
// if not HasTask ( plist [ i ] ) then
7717: LD_VAR 0 1
7721: PUSH
7722: LD_VAR 0 4
7726: ARRAY
7727: PPUSH
7728: CALL_OW 314
7732: NOT
7733: IFFALSE 7770
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7735: LD_VAR 0 1
7739: PUSH
7740: LD_VAR 0 4
7744: ARRAY
7745: PPUSH
7746: LD_VAR 0 2
7750: PPUSH
7751: CALL_OW 250
7755: PPUSH
7756: LD_VAR 0 2
7760: PPUSH
7761: CALL_OW 251
7765: PPUSH
7766: CALL_OW 111
7770: GO 7714
7772: POP
7773: POP
// result := true ;
7774: LD_ADDR_VAR 0 3
7778: PUSH
7779: LD_INT 1
7781: ST_TO_ADDR
// end else
7782: GO 7792
// result := false ;
7784: LD_ADDR_VAR 0 3
7788: PUSH
7789: LD_INT 0
7791: ST_TO_ADDR
// end ;
7792: LD_VAR 0 3
7796: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7797: LD_INT 0
7799: PPUSH
7800: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7801: LD_VAR 0 1
7805: PUSH
7806: LD_INT 1
7808: ARRAY
7809: PPUSH
7810: CALL_OW 255
7814: PPUSH
7815: CALL 6864 0 1
7819: PUSH
7820: LD_INT 20
7822: GREATEREQUAL
7823: PUSH
7824: LD_VAR 0 2
7828: PPUSH
7829: LD_VAR 0 3
7833: PPUSH
7834: CALL 6485 0 2
7838: AND
7839: IFFALSE 7924
// begin for i = 1 to plist do
7841: LD_ADDR_VAR 0 6
7845: PUSH
7846: DOUBLE
7847: LD_INT 1
7849: DEC
7850: ST_TO_ADDR
7851: LD_VAR 0 1
7855: PUSH
7856: FOR_TO
7857: IFFALSE 7912
// if not HasTask ( plist [ i ] ) then
7859: LD_VAR 0 1
7863: PUSH
7864: LD_VAR 0 6
7868: ARRAY
7869: PPUSH
7870: CALL_OW 314
7874: NOT
7875: IFFALSE 7910
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7877: LD_VAR 0 1
7881: PUSH
7882: LD_VAR 0 6
7886: ARRAY
7887: PPUSH
7888: LD_INT 6
7890: PPUSH
7891: LD_VAR 0 2
7895: PPUSH
7896: LD_VAR 0 3
7900: PPUSH
7901: LD_VAR 0 4
7905: PPUSH
7906: CALL_OW 145
7910: GO 7856
7912: POP
7913: POP
// result := true ;
7914: LD_ADDR_VAR 0 5
7918: PUSH
7919: LD_INT 1
7921: ST_TO_ADDR
// end else
7922: GO 7932
// result := false ;
7924: LD_ADDR_VAR 0 5
7928: PUSH
7929: LD_INT 0
7931: ST_TO_ADDR
// end ;
7932: LD_VAR 0 5
7936: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7937: LD_INT 0
7939: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7940: LD_VAR 0 1
7944: PPUSH
7945: LD_INT 1
7947: PPUSH
7948: CALL_OW 268
7952: PUSH
7953: LD_INT 9
7955: EQUAL
7956: PUSH
7957: LD_VAR 0 1
7961: PPUSH
7962: LD_INT 2
7964: PPUSH
7965: CALL_OW 268
7969: PUSH
7970: LD_INT 9
7972: EQUAL
7973: AND
7974: IFFALSE 8071
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7976: LD_VAR 0 1
7980: PPUSH
7981: LD_VAR 0 2
7985: PPUSH
7986: CALL 6255 0 2
7990: PUSH
7991: LD_VAR 0 1
7995: PPUSH
7996: LD_VAR 0 3
8000: PPUSH
8001: CALL 6255 0 2
8005: AND
8006: PUSH
8007: LD_VAR 0 1
8011: PPUSH
8012: CALL_OW 461
8016: PUSH
8017: LD_INT 2
8019: EQUAL
8020: AND
8021: IFFALSE 8061
// begin ComUpgradeLab ( lab , bkind1 ) ;
8023: LD_VAR 0 1
8027: PPUSH
8028: LD_VAR 0 2
8032: PPUSH
8033: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
8037: LD_VAR 0 1
8041: PPUSH
8042: LD_VAR 0 3
8046: PPUSH
8047: CALL_OW 207
// result := true ;
8051: LD_ADDR_VAR 0 4
8055: PUSH
8056: LD_INT 1
8058: ST_TO_ADDR
// end else
8059: GO 8069
// result := false ;
8061: LD_ADDR_VAR 0 4
8065: PUSH
8066: LD_INT 0
8068: ST_TO_ADDR
// end else
8069: GO 8079
// result := false ;
8071: LD_ADDR_VAR 0 4
8075: PUSH
8076: LD_INT 0
8078: ST_TO_ADDR
// end ;
8079: LD_VAR 0 4
8083: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
8084: LD_INT 0
8086: PPUSH
8087: PPUSH
8088: PPUSH
8089: PPUSH
8090: PPUSH
// p := 1 ;
8091: LD_ADDR_VAR 0 6
8095: PUSH
8096: LD_INT 1
8098: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
8099: LD_ADDR_VAR 0 4
8103: PUSH
8104: DOUBLE
8105: LD_INT 1
8107: DEC
8108: ST_TO_ADDR
8109: LD_VAR 0 2
8113: PUSH
8114: LD_INT 4
8116: DIVREAL
8117: PUSH
8118: FOR_TO
8119: IFFALSE 8368
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
8121: LD_VAR 0 2
8125: PUSH
8126: LD_VAR 0 6
8130: PUSH
8131: LD_INT 1
8133: PLUS
8134: ARRAY
8135: PPUSH
8136: LD_VAR 0 2
8140: PUSH
8141: LD_VAR 0 6
8145: PUSH
8146: LD_INT 2
8148: PLUS
8149: ARRAY
8150: PPUSH
8151: CALL_OW 428
8155: PUSH
8156: LD_INT 0
8158: EQUAL
8159: PUSH
8160: LD_VAR 0 2
8164: PUSH
8165: LD_VAR 0 6
8169: PUSH
8170: LD_INT 1
8172: PLUS
8173: ARRAY
8174: PPUSH
8175: LD_VAR 0 2
8179: PUSH
8180: LD_VAR 0 6
8184: PUSH
8185: LD_INT 2
8187: PLUS
8188: ARRAY
8189: PPUSH
8190: CALL 6485 0 2
8194: AND
8195: PUSH
8196: LD_VAR 0 1
8200: PUSH
8201: LD_INT 1
8203: ARRAY
8204: PPUSH
8205: CALL_OW 255
8209: PPUSH
8210: CALL 6864 0 1
8214: PUSH
8215: LD_INT 20
8217: GREATEREQUAL
8218: AND
8219: IFFALSE 8336
// begin for c = 1 to plist do
8221: LD_ADDR_VAR 0 7
8225: PUSH
8226: DOUBLE
8227: LD_INT 1
8229: DEC
8230: ST_TO_ADDR
8231: LD_VAR 0 1
8235: PUSH
8236: FOR_TO
8237: IFFALSE 8330
// if not HasTask ( plist [ c ] ) then
8239: LD_VAR 0 1
8243: PUSH
8244: LD_VAR 0 7
8248: ARRAY
8249: PPUSH
8250: CALL_OW 314
8254: NOT
8255: IFFALSE 8328
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
8257: LD_VAR 0 1
8261: PUSH
8262: LD_VAR 0 7
8266: ARRAY
8267: PPUSH
8268: LD_VAR 0 2
8272: PUSH
8273: LD_VAR 0 6
8277: ARRAY
8278: PPUSH
8279: LD_VAR 0 2
8283: PUSH
8284: LD_VAR 0 6
8288: PUSH
8289: LD_INT 1
8291: PLUS
8292: ARRAY
8293: PPUSH
8294: LD_VAR 0 2
8298: PUSH
8299: LD_VAR 0 6
8303: PUSH
8304: LD_INT 2
8306: PLUS
8307: ARRAY
8308: PPUSH
8309: LD_VAR 0 2
8313: PUSH
8314: LD_VAR 0 6
8318: PUSH
8319: LD_INT 3
8321: PLUS
8322: ARRAY
8323: PPUSH
8324: CALL_OW 145
8328: GO 8236
8330: POP
8331: POP
// break ;
8332: GO 8368
// end else
8334: GO 8366
// if ( p + 4 < tlist ) then
8336: LD_VAR 0 6
8340: PUSH
8341: LD_INT 4
8343: PLUS
8344: PUSH
8345: LD_VAR 0 2
8349: LESS
8350: IFFALSE 8366
// p := p + 4 ;
8352: LD_ADDR_VAR 0 6
8356: PUSH
8357: LD_VAR 0 6
8361: PUSH
8362: LD_INT 4
8364: PLUS
8365: ST_TO_ADDR
// end ;
8366: GO 8118
8368: POP
8369: POP
// end ;
8370: LD_VAR 0 3
8374: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
8375: LD_INT 0
8377: PPUSH
8378: PPUSH
8379: PPUSH
8380: PPUSH
// tmp := GetTowers ( side ) ;
8381: LD_ADDR_VAR 0 5
8385: PUSH
8386: LD_VAR 0 1
8390: PPUSH
8391: CALL 7476 0 1
8395: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
8396: LD_ADDR_VAR 0 6
8400: PUSH
8401: LD_VAR 0 1
8405: PPUSH
8406: LD_INT 3
8408: PPUSH
8409: CALL 6770 0 2
8413: PUSH
8414: LD_INT 1
8416: ARRAY
8417: ST_TO_ADDR
// if fac then
8418: LD_VAR 0 6
8422: IFFALSE 8518
// for i = 1 to tmp do
8424: LD_ADDR_VAR 0 4
8428: PUSH
8429: DOUBLE
8430: LD_INT 1
8432: DEC
8433: ST_TO_ADDR
8434: LD_VAR 0 5
8438: PUSH
8439: FOR_TO
8440: IFFALSE 8516
// if GetBWeapon ( tmp [ i ] ) = 0 then
8442: LD_VAR 0 5
8446: PUSH
8447: LD_VAR 0 4
8451: ARRAY
8452: PPUSH
8453: CALL_OW 269
8457: PUSH
8458: LD_INT 0
8460: EQUAL
8461: IFFALSE 8514
// begin if BuildingStatus ( fac ) = bs_idle then
8463: LD_VAR 0 6
8467: PPUSH
8468: CALL_OW 461
8472: PUSH
8473: LD_INT 2
8475: EQUAL
8476: IFFALSE 8512
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
8478: LD_VAR 0 5
8482: PUSH
8483: LD_VAR 0 4
8487: ARRAY
8488: PPUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 1
8496: PPUSH
8497: LD_VAR 0 2
8501: PPUSH
8502: CALL_OW 12
8506: ARRAY
8507: PPUSH
8508: CALL_OW 148
// break ;
8512: GO 8516
// end ;
8514: GO 8439
8516: POP
8517: POP
// end ;
8518: LD_VAR 0 3
8522: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
8523: LD_INT 0
8525: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
8526: LD_INT 22
8528: PUSH
8529: LD_VAR 0 1
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PUSH
8538: LD_INT 34
8540: PUSH
8541: LD_VAR 0 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 31
8552: PUSH
8553: LD_VAR 0 2
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: LIST
8566: PUSH
8567: EMPTY
8568: LIST
8569: PPUSH
8570: CALL_OW 69
8574: IFFALSE 8632
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
8576: LD_ADDR_VAR 0 4
8580: PUSH
8581: LD_INT 22
8583: PUSH
8584: LD_VAR 0 1
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: PUSH
8593: LD_INT 34
8595: PUSH
8596: LD_VAR 0 3
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: PUSH
8605: LD_INT 31
8607: PUSH
8608: LD_VAR 0 2
8612: PUSH
8613: EMPTY
8614: LIST
8615: LIST
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: LIST
8621: PUSH
8622: EMPTY
8623: LIST
8624: PPUSH
8625: CALL_OW 69
8629: ST_TO_ADDR
8630: GO 8640
// result := false ;
8632: LD_ADDR_VAR 0 4
8636: PUSH
8637: LD_INT 0
8639: ST_TO_ADDR
// end ;
8640: LD_VAR 0 4
8644: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8645: LD_INT 0
8647: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8648: LD_VAR 0 1
8652: PPUSH
8653: LD_VAR 0 2
8657: PPUSH
8658: LD_VAR 0 3
8662: PPUSH
8663: LD_VAR 0 4
8667: PPUSH
8668: LD_VAR 0 5
8672: PPUSH
8673: CALL_OW 448
8677: PUSH
8678: LD_VAR 0 2
8682: PPUSH
8683: LD_VAR 0 3
8687: PPUSH
8688: LD_VAR 0 4
8692: PPUSH
8693: LD_VAR 0 5
8697: PPUSH
8698: CALL_OW 449
8702: PUSH
8703: LD_INT 1
8705: ARRAY
8706: PUSH
8707: LD_VAR 0 1
8711: PPUSH
8712: CALL 6371 0 1
8716: PUSH
8717: LD_INT 1
8719: ARRAY
8720: LESSEQUAL
8721: AND
8722: PUSH
8723: LD_VAR 0 2
8727: PPUSH
8728: LD_VAR 0 3
8732: PPUSH
8733: LD_VAR 0 4
8737: PPUSH
8738: LD_VAR 0 5
8742: PPUSH
8743: CALL_OW 449
8747: PUSH
8748: LD_INT 2
8750: ARRAY
8751: PUSH
8752: LD_VAR 0 1
8756: PPUSH
8757: CALL 6371 0 1
8761: PUSH
8762: LD_INT 2
8764: ARRAY
8765: LESSEQUAL
8766: AND
8767: PUSH
8768: LD_VAR 0 2
8772: PPUSH
8773: LD_VAR 0 3
8777: PPUSH
8778: LD_VAR 0 4
8782: PPUSH
8783: LD_VAR 0 5
8787: PPUSH
8788: CALL_OW 449
8792: PUSH
8793: LD_INT 3
8795: ARRAY
8796: PUSH
8797: LD_VAR 0 1
8801: PPUSH
8802: CALL 6371 0 1
8806: PUSH
8807: LD_INT 3
8809: ARRAY
8810: LESSEQUAL
8811: AND
8812: IFFALSE 8859
// begin if debug then
8814: LD_EXP 1
8818: IFFALSE 8828
// display_strings := Factory work! ;
8820: LD_ADDR_OWVAR 47
8824: PUSH
8825: LD_STRING Factory work!
8827: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8828: LD_VAR 0 1
8832: PPUSH
8833: LD_VAR 0 2
8837: PPUSH
8838: LD_VAR 0 3
8842: PPUSH
8843: LD_VAR 0 4
8847: PPUSH
8848: LD_VAR 0 5
8852: PPUSH
8853: CALL_OW 125
// end else
8857: GO 8867
// result := false ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// end ;
8867: LD_VAR 0 6
8871: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8872: LD_INT 0
8874: PPUSH
8875: PPUSH
8876: PPUSH
8877: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8878: LD_ADDR_VAR 0 6
8882: PUSH
8883: LD_INT 22
8885: PUSH
8886: LD_VAR 0 1
8890: PUSH
8891: EMPTY
8892: LIST
8893: LIST
8894: PUSH
8895: LD_INT 30
8897: PUSH
8898: LD_VAR 0 2
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: PPUSH
8911: CALL_OW 69
8915: ST_TO_ADDR
// tmp := [ ] ;
8916: LD_ADDR_VAR 0 5
8920: PUSH
8921: EMPTY
8922: ST_TO_ADDR
// for i = 1 to filter do
8923: LD_ADDR_VAR 0 4
8927: PUSH
8928: DOUBLE
8929: LD_INT 1
8931: DEC
8932: ST_TO_ADDR
8933: LD_VAR 0 6
8937: PUSH
8938: FOR_TO
8939: IFFALSE 9027
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8941: LD_ADDR_VAR 0 5
8945: PUSH
8946: LD_VAR 0 5
8950: PUSH
8951: LD_VAR 0 6
8955: PUSH
8956: LD_VAR 0 4
8960: ARRAY
8961: PPUSH
8962: CALL_OW 266
8966: PUSH
8967: LD_VAR 0 6
8971: PUSH
8972: LD_VAR 0 4
8976: ARRAY
8977: PPUSH
8978: CALL_OW 250
8982: PUSH
8983: LD_VAR 0 6
8987: PUSH
8988: LD_VAR 0 4
8992: ARRAY
8993: PPUSH
8994: CALL_OW 251
8998: PUSH
8999: LD_VAR 0 6
9003: PUSH
9004: LD_VAR 0 4
9008: ARRAY
9009: PPUSH
9010: CALL_OW 254
9014: PUSH
9015: EMPTY
9016: LIST
9017: LIST
9018: LIST
9019: LIST
9020: PUSH
9021: EMPTY
9022: LIST
9023: ADD
9024: ST_TO_ADDR
// end ;
9025: GO 8938
9027: POP
9028: POP
// result := tmp ;
9029: LD_ADDR_VAR 0 3
9033: PUSH
9034: LD_VAR 0 5
9038: ST_TO_ADDR
// end ;
9039: LD_VAR 0 3
9043: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
9044: LD_INT 0
9046: PPUSH
9047: PPUSH
9048: PPUSH
// for i = 1 to list do
9049: LD_ADDR_VAR 0 4
9053: PUSH
9054: DOUBLE
9055: LD_INT 1
9057: DEC
9058: ST_TO_ADDR
9059: LD_VAR 0 2
9063: PUSH
9064: FOR_TO
9065: IFFALSE 9620
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
9067: LD_VAR 0 2
9071: PUSH
9072: LD_VAR 0 4
9076: ARRAY
9077: PUSH
9078: LD_INT 1
9080: ARRAY
9081: PPUSH
9082: LD_VAR 0 2
9086: PUSH
9087: LD_VAR 0 4
9091: ARRAY
9092: PUSH
9093: LD_INT 2
9095: ARRAY
9096: PPUSH
9097: CALL_OW 428
9101: PUSH
9102: LD_INT 0
9104: GREATER
9105: IFFALSE 9391
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
9107: LD_VAR 0 2
9111: PUSH
9112: LD_VAR 0 4
9116: ARRAY
9117: PUSH
9118: LD_INT 1
9120: ARRAY
9121: PPUSH
9122: LD_VAR 0 2
9126: PUSH
9127: LD_VAR 0 4
9131: ARRAY
9132: PUSH
9133: LD_INT 2
9135: ARRAY
9136: PPUSH
9137: CALL_OW 428
9141: PPUSH
9142: CALL_OW 248
9146: PUSH
9147: LD_INT 3
9149: EQUAL
9150: IFFALSE 9276
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
9152: LD_VAR 0 2
9156: PUSH
9157: LD_VAR 0 4
9161: ARRAY
9162: PUSH
9163: LD_INT 1
9165: ARRAY
9166: PPUSH
9167: LD_VAR 0 2
9171: PUSH
9172: LD_VAR 0 4
9176: ARRAY
9177: PUSH
9178: LD_INT 2
9180: ARRAY
9181: PPUSH
9182: CALL_OW 428
9186: PPUSH
9187: CALL_OW 274
9191: PPUSH
9192: LD_INT 3
9194: PPUSH
9195: CALL_OW 275
9199: PUSH
9200: LD_INT 15
9202: GREATEREQUAL
9203: IFFALSE 9274
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9205: LD_VAR 0 2
9209: PUSH
9210: LD_VAR 0 4
9214: ARRAY
9215: PUSH
9216: LD_INT 1
9218: ARRAY
9219: PPUSH
9220: LD_VAR 0 2
9224: PUSH
9225: LD_VAR 0 4
9229: ARRAY
9230: PUSH
9231: LD_INT 2
9233: ARRAY
9234: PPUSH
9235: CALL_OW 428
9239: PPUSH
9240: LD_VAR 0 2
9244: PUSH
9245: LD_VAR 0 4
9249: ARRAY
9250: PUSH
9251: LD_INT 4
9253: ARRAY
9254: PPUSH
9255: LD_VAR 0 2
9259: PUSH
9260: LD_VAR 0 4
9264: ARRAY
9265: PUSH
9266: LD_INT 5
9268: ARRAY
9269: PPUSH
9270: CALL 7937 0 3
// end else
9274: GO 9345
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9276: LD_VAR 0 2
9280: PUSH
9281: LD_VAR 0 4
9285: ARRAY
9286: PUSH
9287: LD_INT 1
9289: ARRAY
9290: PPUSH
9291: LD_VAR 0 2
9295: PUSH
9296: LD_VAR 0 4
9300: ARRAY
9301: PUSH
9302: LD_INT 2
9304: ARRAY
9305: PPUSH
9306: CALL_OW 428
9310: PPUSH
9311: LD_VAR 0 2
9315: PUSH
9316: LD_VAR 0 4
9320: ARRAY
9321: PUSH
9322: LD_INT 4
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_VAR 0 4
9335: ARRAY
9336: PUSH
9337: LD_INT 5
9339: ARRAY
9340: PPUSH
9341: CALL 7937 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
9345: LD_VAR 0 1
9349: PPUSH
9350: LD_VAR 0 2
9354: PUSH
9355: LD_VAR 0 4
9359: ARRAY
9360: PUSH
9361: LD_INT 1
9363: ARRAY
9364: PPUSH
9365: LD_VAR 0 2
9369: PUSH
9370: LD_VAR 0 4
9374: ARRAY
9375: PUSH
9376: LD_INT 2
9378: ARRAY
9379: PPUSH
9380: CALL_OW 428
9384: PPUSH
9385: CALL 10993 0 2
// end else
9389: GO 9618
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
9391: LD_VAR 0 1
9395: PUSH
9396: LD_INT 1
9398: ARRAY
9399: PPUSH
9400: CALL_OW 255
9404: PPUSH
9405: CALL 6679 0 1
9409: PPUSH
9410: LD_INT 6
9412: PPUSH
9413: CALL 6255 0 2
9417: PUSH
9418: LD_VAR 0 1
9422: PUSH
9423: LD_INT 1
9425: ARRAY
9426: PPUSH
9427: CALL_OW 255
9431: PPUSH
9432: CALL 6679 0 1
9436: PPUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_VAR 0 4
9446: ARRAY
9447: PUSH
9448: LD_INT 4
9450: ARRAY
9451: PPUSH
9452: CALL 6255 0 2
9456: AND
9457: PUSH
9458: LD_VAR 0 1
9462: PUSH
9463: LD_INT 1
9465: ARRAY
9466: PPUSH
9467: CALL_OW 255
9471: PPUSH
9472: CALL 6679 0 1
9476: PPUSH
9477: LD_VAR 0 2
9481: PUSH
9482: LD_VAR 0 4
9486: ARRAY
9487: PUSH
9488: LD_INT 5
9490: ARRAY
9491: PPUSH
9492: CALL 6255 0 2
9496: AND
9497: IFFALSE 9618
// for p = 1 to plist do
9499: LD_ADDR_VAR 0 5
9503: PUSH
9504: DOUBLE
9505: LD_INT 1
9507: DEC
9508: ST_TO_ADDR
9509: LD_VAR 0 1
9513: PUSH
9514: FOR_TO
9515: IFFALSE 9616
// if IsInUnit ( plist [ p ] ) then
9517: LD_VAR 0 1
9521: PUSH
9522: LD_VAR 0 5
9526: ARRAY
9527: PPUSH
9528: CALL_OW 310
9532: IFFALSE 9551
// ComExitBuilding ( plist [ p ] ) else
9534: LD_VAR 0 1
9538: PUSH
9539: LD_VAR 0 5
9543: ARRAY
9544: PPUSH
9545: CALL_OW 122
9549: GO 9614
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
9551: LD_VAR 0 1
9555: PUSH
9556: LD_VAR 0 5
9560: ARRAY
9561: PPUSH
9562: LD_INT 6
9564: PPUSH
9565: LD_VAR 0 2
9569: PUSH
9570: LD_VAR 0 4
9574: ARRAY
9575: PUSH
9576: LD_INT 1
9578: ARRAY
9579: PPUSH
9580: LD_VAR 0 2
9584: PUSH
9585: LD_VAR 0 4
9589: ARRAY
9590: PUSH
9591: LD_INT 2
9593: ARRAY
9594: PPUSH
9595: LD_VAR 0 2
9599: PUSH
9600: LD_VAR 0 4
9604: ARRAY
9605: PUSH
9606: LD_INT 3
9608: ARRAY
9609: PPUSH
9610: CALL_OW 145
9614: GO 9514
9616: POP
9617: POP
// end ;
9618: GO 9064
9620: POP
9621: POP
// end ;
9622: LD_VAR 0 3
9626: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9627: LD_INT 0
9629: PPUSH
// if IsInUnit ( sci ) then
9630: LD_VAR 0 1
9634: PPUSH
9635: CALL_OW 310
9639: IFFALSE 9652
// ComExitBuilding ( sci ) else
9641: LD_VAR 0 1
9645: PPUSH
9646: CALL_OW 122
9650: GO 9683
// if not HasTask ( sci ) then
9652: LD_VAR 0 1
9656: PPUSH
9657: CALL_OW 314
9661: NOT
9662: IFFALSE 9683
// begin ComMoveXY ( sci , x , y ) ;
9664: LD_VAR 0 1
9668: PPUSH
9669: LD_VAR 0 2
9673: PPUSH
9674: LD_VAR 0 3
9678: PPUSH
9679: CALL_OW 111
// end ; end ;
9683: LD_VAR 0 4
9687: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9688: LD_INT 0
9690: PPUSH
9691: PPUSH
9692: PPUSH
9693: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9694: LD_ADDR_VAR 0 6
9698: PUSH
9699: LD_INT 22
9701: PUSH
9702: LD_VAR 0 1
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 21
9713: PUSH
9714: LD_INT 1
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 69
9729: PUSH
9730: LD_VAR 0 3
9734: DIFF
9735: ST_TO_ADDR
// tmp := tag_list ;
9736: LD_ADDR_VAR 0 7
9740: PUSH
9741: LD_VAR 0 2
9745: ST_TO_ADDR
// for i = 1 to filter do
9746: LD_ADDR_VAR 0 5
9750: PUSH
9751: DOUBLE
9752: LD_INT 1
9754: DEC
9755: ST_TO_ADDR
9756: LD_VAR 0 6
9760: PUSH
9761: FOR_TO
9762: IFFALSE 10031
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9764: LD_VAR 0 6
9768: PUSH
9769: LD_VAR 0 5
9773: ARRAY
9774: PPUSH
9775: CALL_OW 256
9779: PUSH
9780: LD_INT 1000
9782: EQUAL
9783: PUSH
9784: LD_VAR 0 6
9788: PUSH
9789: LD_VAR 0 5
9793: ARRAY
9794: PPUSH
9795: CALL_OW 110
9799: PUSH
9800: LD_INT 100
9802: GREATEREQUAL
9803: AND
9804: IFFALSE 9846
// begin SetTag ( filter [ i ] , 0 ) ;
9806: LD_VAR 0 6
9810: PUSH
9811: LD_VAR 0 5
9815: ARRAY
9816: PPUSH
9817: LD_INT 0
9819: PPUSH
9820: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9824: LD_ADDR_VAR 0 7
9828: PUSH
9829: LD_VAR 0 7
9833: PUSH
9834: LD_VAR 0 6
9838: PUSH
9839: LD_VAR 0 5
9843: ARRAY
9844: DIFF
9845: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9846: LD_VAR 0 6
9850: PUSH
9851: LD_VAR 0 5
9855: ARRAY
9856: PPUSH
9857: CALL_OW 256
9861: PUSH
9862: LD_INT 1000
9864: LESS
9865: IFFALSE 10029
// begin if not filter [ i ] in tmp then
9867: LD_VAR 0 6
9871: PUSH
9872: LD_VAR 0 5
9876: ARRAY
9877: PUSH
9878: LD_VAR 0 7
9882: IN
9883: NOT
9884: IFFALSE 9908
// tmp := tmp ^ filter [ i ] ;
9886: LD_ADDR_VAR 0 7
9890: PUSH
9891: LD_VAR 0 7
9895: PUSH
9896: LD_VAR 0 6
9900: PUSH
9901: LD_VAR 0 5
9905: ARRAY
9906: ADD
9907: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9908: LD_VAR 0 6
9912: PUSH
9913: LD_VAR 0 5
9917: ARRAY
9918: PPUSH
9919: CALL_OW 256
9923: PUSH
9924: LD_INT 250
9926: LESS
9927: IFFALSE 9949
// SetTag ( filter [ i ] , 100 ) else
9929: LD_VAR 0 6
9933: PUSH
9934: LD_VAR 0 5
9938: ARRAY
9939: PPUSH
9940: LD_INT 100
9942: PPUSH
9943: CALL_OW 109
9947: GO 10029
// if GetLives ( filter [ i ] ) < 500 then
9949: LD_VAR 0 6
9953: PUSH
9954: LD_VAR 0 5
9958: ARRAY
9959: PPUSH
9960: CALL_OW 256
9964: PUSH
9965: LD_INT 500
9967: LESS
9968: IFFALSE 9990
// SetTag ( filter [ i ] , 101 ) else
9970: LD_VAR 0 6
9974: PUSH
9975: LD_VAR 0 5
9979: ARRAY
9980: PPUSH
9981: LD_INT 101
9983: PPUSH
9984: CALL_OW 109
9988: GO 10029
// if GetLives ( filter [ i ] ) < 1000 then
9990: LD_VAR 0 6
9994: PUSH
9995: LD_VAR 0 5
9999: ARRAY
10000: PPUSH
10001: CALL_OW 256
10005: PUSH
10006: LD_INT 1000
10008: LESS
10009: IFFALSE 10029
// SetTag ( filter [ i ] , 102 ) ;
10011: LD_VAR 0 6
10015: PUSH
10016: LD_VAR 0 5
10020: ARRAY
10021: PPUSH
10022: LD_INT 102
10024: PPUSH
10025: CALL_OW 109
// end ; end ;
10029: GO 9761
10031: POP
10032: POP
// result := tmp ;
10033: LD_ADDR_VAR 0 4
10037: PUSH
10038: LD_VAR 0 7
10042: ST_TO_ADDR
// end ;
10043: LD_VAR 0 4
10047: RET
// export function WantHeal ( sci , tag ) ; begin
10048: LD_INT 0
10050: PPUSH
// if GetTaskList ( sci ) > 0 then
10051: LD_VAR 0 1
10055: PPUSH
10056: CALL_OW 437
10060: PUSH
10061: LD_INT 0
10063: GREATER
10064: IFFALSE 10139
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 437
10075: PUSH
10076: LD_INT 1
10078: ARRAY
10079: PUSH
10080: LD_INT 1
10082: ARRAY
10083: PUSH
10084: LD_STRING l
10086: EQUAL
10087: PUSH
10088: LD_VAR 0 1
10092: PPUSH
10093: CALL_OW 437
10097: PUSH
10098: LD_INT 1
10100: ARRAY
10101: PUSH
10102: LD_INT 4
10104: ARRAY
10105: PPUSH
10106: CALL_OW 110
10110: PUSH
10111: LD_VAR 0 2
10115: EQUAL
10116: AND
10117: IFFALSE 10129
// result := true else
10119: LD_ADDR_VAR 0 3
10123: PUSH
10124: LD_INT 1
10126: ST_TO_ADDR
10127: GO 10137
// result := false ;
10129: LD_ADDR_VAR 0 3
10133: PUSH
10134: LD_INT 0
10136: ST_TO_ADDR
// end else
10137: GO 10147
// result := false ;
10139: LD_ADDR_VAR 0 3
10143: PUSH
10144: LD_INT 0
10146: ST_TO_ADDR
// end ;
10147: LD_VAR 0 3
10151: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
10152: LD_INT 0
10154: PPUSH
10155: PPUSH
10156: PPUSH
10157: PPUSH
10158: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10159: LD_ADDR_VAR 0 7
10163: PUSH
10164: LD_INT 22
10166: PUSH
10167: LD_VAR 0 2
10171: PUSH
10172: EMPTY
10173: LIST
10174: LIST
10175: PUSH
10176: LD_INT 3
10178: PUSH
10179: LD_INT 21
10181: PUSH
10182: LD_INT 3
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: PUSH
10189: EMPTY
10190: LIST
10191: LIST
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PPUSH
10197: CALL_OW 69
10201: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
10202: LD_ADDR_VAR 0 5
10206: PUSH
10207: LD_INT 1
10209: PPUSH
10210: LD_INT 3
10212: PPUSH
10213: CALL_OW 12
10217: ST_TO_ADDR
// if filter > 0 then
10218: LD_VAR 0 7
10222: PUSH
10223: LD_INT 0
10225: GREATER
10226: IFFALSE 10428
// for i = 1 to list do
10228: LD_ADDR_VAR 0 6
10232: PUSH
10233: DOUBLE
10234: LD_INT 1
10236: DEC
10237: ST_TO_ADDR
10238: LD_VAR 0 1
10242: PUSH
10243: FOR_TO
10244: IFFALSE 10426
// for ta in filter do
10246: LD_ADDR_VAR 0 4
10250: PUSH
10251: LD_VAR 0 7
10255: PUSH
10256: FOR_IN
10257: IFFALSE 10422
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
10259: LD_VAR 0 1
10263: PUSH
10264: LD_VAR 0 6
10268: ARRAY
10269: PPUSH
10270: LD_VAR 0 4
10274: PPUSH
10275: CALL_OW 296
10279: PUSH
10280: LD_INT 13
10282: LESSEQUAL
10283: IFFALSE 10420
// begin case c of 1 :
10285: LD_VAR 0 5
10289: PUSH
10290: LD_INT 1
10292: DOUBLE
10293: EQUAL
10294: IFTRUE 10298
10296: GO 10336
10298: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
10299: LD_VAR 0 1
10303: PUSH
10304: LD_VAR 0 6
10308: ARRAY
10309: PPUSH
10310: LD_VAR 0 4
10314: PPUSH
10315: CALL_OW 250
10319: PPUSH
10320: LD_VAR 0 4
10324: PPUSH
10325: CALL_OW 251
10329: PPUSH
10330: CALL_OW 154
10334: GO 10420
10336: LD_INT 2
10338: DOUBLE
10339: EQUAL
10340: IFTRUE 10344
10342: GO 10408
10344: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
10345: LD_VAR 0 1
10349: PUSH
10350: LD_VAR 0 6
10354: ARRAY
10355: PPUSH
10356: LD_VAR 0 4
10360: PPUSH
10361: CALL_OW 250
10365: PUSH
10366: LD_INT 1
10368: NEG
10369: PPUSH
10370: LD_INT 1
10372: PPUSH
10373: CALL_OW 12
10377: PLUS
10378: PPUSH
10379: LD_VAR 0 4
10383: PPUSH
10384: CALL_OW 251
10388: PUSH
10389: LD_INT 1
10391: NEG
10392: PPUSH
10393: LD_INT 1
10395: PPUSH
10396: CALL_OW 12
10400: PLUS
10401: PPUSH
10402: CALL_OW 153
10406: GO 10420
10408: LD_INT 3
10410: DOUBLE
10411: EQUAL
10412: IFTRUE 10416
10414: GO 10419
10416: POP
// ; end ;
10417: GO 10420
10419: POP
// end ; end ;
10420: GO 10256
10422: POP
10423: POP
10424: GO 10243
10426: POP
10427: POP
// end ;
10428: LD_VAR 0 3
10432: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
10433: LD_INT 0
10435: PPUSH
10436: PPUSH
// for i = 1 to plist do
10437: LD_ADDR_VAR 0 3
10441: PUSH
10442: DOUBLE
10443: LD_INT 1
10445: DEC
10446: ST_TO_ADDR
10447: LD_VAR 0 1
10451: PUSH
10452: FOR_TO
10453: IFFALSE 10655
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
10455: LD_VAR 0 1
10459: PUSH
10460: LD_VAR 0 3
10464: ARRAY
10465: PPUSH
10466: CALL_OW 310
10470: PUSH
10471: LD_INT 30
10473: PUSH
10474: LD_INT 5
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: PUSH
10481: EMPTY
10482: LIST
10483: PPUSH
10484: CALL_OW 69
10488: IN
10489: NOT
10490: IFFALSE 10635
// begin if IsInUnit ( plist [ i ] ) then
10492: LD_VAR 0 1
10496: PUSH
10497: LD_VAR 0 3
10501: ARRAY
10502: PPUSH
10503: CALL_OW 310
10507: IFFALSE 10526
// ComExitBuilding ( plist [ i ] ) else
10509: LD_VAR 0 1
10513: PUSH
10514: LD_VAR 0 3
10518: ARRAY
10519: PPUSH
10520: CALL_OW 122
10524: GO 10633
// if not HasTask ( plist [ i ] ) then
10526: LD_VAR 0 1
10530: PUSH
10531: LD_VAR 0 3
10535: ARRAY
10536: PPUSH
10537: CALL_OW 314
10541: NOT
10542: IFFALSE 10633
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
10544: LD_VAR 0 1
10548: PUSH
10549: LD_VAR 0 3
10553: ARRAY
10554: PPUSH
10555: LD_INT 22
10557: PUSH
10558: LD_VAR 0 1
10562: PUSH
10563: LD_INT 1
10565: ARRAY
10566: PPUSH
10567: CALL_OW 255
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: LD_INT 30
10578: PUSH
10579: LD_INT 5
10581: PUSH
10582: EMPTY
10583: LIST
10584: LIST
10585: PUSH
10586: EMPTY
10587: LIST
10588: LIST
10589: PPUSH
10590: CALL_OW 69
10594: PPUSH
10595: LD_VAR 0 1
10599: PUSH
10600: LD_VAR 0 3
10604: ARRAY
10605: PPUSH
10606: CALL_OW 74
10610: PPUSH
10611: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10615: LD_VAR 0 1
10619: PUSH
10620: LD_VAR 0 3
10624: ARRAY
10625: PPUSH
10626: LD_INT 9
10628: PPUSH
10629: CALL_OW 183
// end ; end else
10633: GO 10653
// ComChangeProfession ( plist [ i ] , 9 ) ;
10635: LD_VAR 0 1
10639: PUSH
10640: LD_VAR 0 3
10644: ARRAY
10645: PPUSH
10646: LD_INT 9
10648: PPUSH
10649: CALL_OW 123
10653: GO 10452
10655: POP
10656: POP
// end ;
10657: LD_VAR 0 2
10661: RET
// export function GetHuman ( side ) ; begin
10662: LD_INT 0
10664: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10665: LD_ADDR_VAR 0 2
10669: PUSH
10670: LD_INT 22
10672: PUSH
10673: LD_VAR 0 1
10677: PUSH
10678: EMPTY
10679: LIST
10680: LIST
10681: PUSH
10682: LD_INT 21
10684: PUSH
10685: LD_INT 1
10687: PUSH
10688: EMPTY
10689: LIST
10690: LIST
10691: PUSH
10692: LD_INT 2
10694: PUSH
10695: LD_INT 25
10697: PUSH
10698: LD_INT 1
10700: PUSH
10701: EMPTY
10702: LIST
10703: LIST
10704: PUSH
10705: LD_INT 25
10707: PUSH
10708: LD_INT 2
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: PUSH
10715: LD_INT 25
10717: PUSH
10718: LD_INT 3
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: LD_INT 25
10727: PUSH
10728: LD_INT 4
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: LIST
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: LIST
10746: PPUSH
10747: CALL_OW 69
10751: ST_TO_ADDR
// end ;
10752: LD_VAR 0 2
10756: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10757: LD_INT 0
10759: PPUSH
10760: PPUSH
10761: PPUSH
// uc_side := 0 ;
10762: LD_ADDR_OWVAR 20
10766: PUSH
10767: LD_INT 0
10769: ST_TO_ADDR
// uc_nation := 0 ;
10770: LD_ADDR_OWVAR 21
10774: PUSH
10775: LD_INT 0
10777: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10778: LD_ADDR_VAR 0 4
10782: PUSH
10783: DOUBLE
10784: LD_INT 1
10786: DEC
10787: ST_TO_ADDR
10788: LD_INT 4
10790: PUSH
10791: LD_INT 5
10793: PUSH
10794: LD_INT 6
10796: PUSH
10797: EMPTY
10798: LIST
10799: LIST
10800: LIST
10801: PUSH
10802: LD_OWVAR 67
10806: ARRAY
10807: PUSH
10808: FOR_TO
10809: IFFALSE 10880
// begin hc_class = class_tiger ;
10811: LD_ADDR_OWVAR 28
10815: PUSH
10816: LD_INT 14
10818: ST_TO_ADDR
// hc_gallery = sandnature ;
10819: LD_ADDR_OWVAR 33
10823: PUSH
10824: LD_STRING sandnature
10826: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10827: LD_ADDR_OWVAR 35
10831: PUSH
10832: LD_INT 0
10834: PPUSH
10835: LD_INT 50
10837: PPUSH
10838: CALL_OW 12
10842: ST_TO_ADDR
// hc_face_number = 3 ;
10843: LD_ADDR_OWVAR 34
10847: PUSH
10848: LD_INT 3
10850: ST_TO_ADDR
// tiger := CreateHuman ;
10851: LD_ADDR_VAR 0 3
10855: PUSH
10856: CALL_OW 44
10860: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10861: LD_VAR 0 3
10865: PPUSH
10866: LD_VAR 0 1
10870: PPUSH
10871: LD_INT 0
10873: PPUSH
10874: CALL_OW 49
// end ;
10878: GO 10808
10880: POP
10881: POP
// end ;
10882: LD_VAR 0 2
10886: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10887: LD_INT 0
10889: PPUSH
10890: PPUSH
10891: PPUSH
// uc_side := 0 ;
10892: LD_ADDR_OWVAR 20
10896: PUSH
10897: LD_INT 0
10899: ST_TO_ADDR
// uc_nation := 0 ;
10900: LD_ADDR_OWVAR 21
10904: PUSH
10905: LD_INT 0
10907: ST_TO_ADDR
// for i = 1 to 8 do
10908: LD_ADDR_VAR 0 4
10912: PUSH
10913: DOUBLE
10914: LD_INT 1
10916: DEC
10917: ST_TO_ADDR
10918: LD_INT 8
10920: PUSH
10921: FOR_TO
10922: IFFALSE 10986
// begin hc_class = class_apeman ;
10924: LD_ADDR_OWVAR 28
10928: PUSH
10929: LD_INT 12
10931: ST_TO_ADDR
// hc_gallery =  ;
10932: LD_ADDR_OWVAR 33
10936: PUSH
10937: LD_STRING 
10939: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10940: LD_ADDR_OWVAR 35
10944: PUSH
10945: LD_INT 5
10947: NEG
10948: PPUSH
10949: LD_INT 20
10951: PPUSH
10952: CALL_OW 12
10956: ST_TO_ADDR
// ape := CreateHuman ;
10957: LD_ADDR_VAR 0 3
10961: PUSH
10962: CALL_OW 44
10966: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10967: LD_VAR 0 3
10971: PPUSH
10972: LD_VAR 0 1
10976: PPUSH
10977: LD_INT 0
10979: PPUSH
10980: CALL_OW 49
// end ;
10984: GO 10921
10986: POP
10987: POP
// end ;
10988: LD_VAR 0 2
10992: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
10993: LD_INT 0
10995: PPUSH
10996: PPUSH
// if BuildingStatus ( b ) = bs_build then
10997: LD_VAR 0 2
11001: PPUSH
11002: CALL_OW 461
11006: PUSH
11007: LD_INT 1
11009: EQUAL
11010: IFFALSE 11196
// for i = 1 to plist do
11012: LD_ADDR_VAR 0 4
11016: PUSH
11017: DOUBLE
11018: LD_INT 1
11020: DEC
11021: ST_TO_ADDR
11022: LD_VAR 0 1
11026: PUSH
11027: FOR_TO
11028: IFFALSE 11194
// if IsInUnit ( plist [ i ] ) then
11030: LD_VAR 0 1
11034: PUSH
11035: LD_VAR 0 4
11039: ARRAY
11040: PPUSH
11041: CALL_OW 310
11045: IFFALSE 11128
// begin ComExitBuilding ( plist [ i ] ) ;
11047: LD_VAR 0 1
11051: PUSH
11052: LD_VAR 0 4
11056: ARRAY
11057: PPUSH
11058: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11062: LD_VAR 0 1
11066: PUSH
11067: LD_VAR 0 4
11071: ARRAY
11072: PPUSH
11073: LD_STRING h
11075: PUSH
11076: LD_VAR 0 2
11080: PPUSH
11081: CALL_OW 250
11085: PUSH
11086: LD_VAR 0 2
11090: PPUSH
11091: CALL_OW 251
11095: PUSH
11096: LD_VAR 0 2
11100: PUSH
11101: LD_INT 0
11103: PUSH
11104: LD_INT 0
11106: PUSH
11107: LD_INT 0
11109: PUSH
11110: EMPTY
11111: LIST
11112: LIST
11113: LIST
11114: LIST
11115: LIST
11116: LIST
11117: LIST
11118: PUSH
11119: EMPTY
11120: LIST
11121: PPUSH
11122: CALL_OW 447
// end else
11126: GO 11192
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11128: LD_VAR 0 1
11132: PUSH
11133: LD_VAR 0 4
11137: ARRAY
11138: PPUSH
11139: LD_STRING h
11141: PUSH
11142: LD_VAR 0 2
11146: PPUSH
11147: CALL_OW 250
11151: PUSH
11152: LD_VAR 0 2
11156: PPUSH
11157: CALL_OW 251
11161: PUSH
11162: LD_VAR 0 2
11166: PUSH
11167: LD_INT 0
11169: PUSH
11170: LD_INT 0
11172: PUSH
11173: LD_INT 0
11175: PUSH
11176: EMPTY
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: PPUSH
11188: CALL_OW 446
11192: GO 11027
11194: POP
11195: POP
// end ;
11196: LD_VAR 0 3
11200: RET
// export function WantRepair ( eng ) ; begin
11201: LD_INT 0
11203: PPUSH
// if GetTaskList ( eng ) > 0 then
11204: LD_VAR 0 1
11208: PPUSH
11209: CALL_OW 437
11213: PUSH
11214: LD_INT 0
11216: GREATER
11217: IFFALSE 11262
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
11219: LD_VAR 0 1
11223: PPUSH
11224: CALL_OW 437
11228: PUSH
11229: LD_INT 1
11231: ARRAY
11232: PUSH
11233: LD_INT 1
11235: ARRAY
11236: PUSH
11237: LD_STRING o
11239: EQUAL
11240: IFFALSE 11252
// result := true else
11242: LD_ADDR_VAR 0 2
11246: PUSH
11247: LD_INT 1
11249: ST_TO_ADDR
11250: GO 11260
// result := false ;
11252: LD_ADDR_VAR 0 2
11256: PUSH
11257: LD_INT 0
11259: ST_TO_ADDR
// end else
11260: GO 11270
// result := false ;
11262: LD_ADDR_VAR 0 2
11266: PUSH
11267: LD_INT 0
11269: ST_TO_ADDR
// end ;
11270: LD_VAR 0 2
11274: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
11275: LD_INT 0
11277: PPUSH
11278: PPUSH
11279: PPUSH
11280: PPUSH
// if btype = - 1 then
11281: LD_VAR 0 2
11285: PUSH
11286: LD_INT 1
11288: NEG
11289: EQUAL
11290: IFFALSE 11330
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
11292: LD_ADDR_VAR 0 5
11296: PUSH
11297: LD_INT 22
11299: PUSH
11300: LD_VAR 0 1
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PUSH
11309: LD_INT 21
11311: PUSH
11312: LD_INT 3
11314: PUSH
11315: EMPTY
11316: LIST
11317: LIST
11318: PUSH
11319: EMPTY
11320: LIST
11321: LIST
11322: PPUSH
11323: CALL_OW 69
11327: ST_TO_ADDR
11328: GO 11368
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
11330: LD_ADDR_VAR 0 5
11334: PUSH
11335: LD_INT 22
11337: PUSH
11338: LD_VAR 0 1
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: PUSH
11347: LD_INT 30
11349: PUSH
11350: LD_VAR 0 2
11354: PUSH
11355: EMPTY
11356: LIST
11357: LIST
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PPUSH
11363: CALL_OW 69
11367: ST_TO_ADDR
// list := [ ] ;
11368: LD_ADDR_VAR 0 6
11372: PUSH
11373: EMPTY
11374: ST_TO_ADDR
// for i = 1 to tmp do
11375: LD_ADDR_VAR 0 4
11379: PUSH
11380: DOUBLE
11381: LD_INT 1
11383: DEC
11384: ST_TO_ADDR
11385: LD_VAR 0 5
11389: PUSH
11390: FOR_TO
11391: IFFALSE 11479
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11393: LD_ADDR_VAR 0 6
11397: PUSH
11398: LD_VAR 0 6
11402: PUSH
11403: LD_VAR 0 5
11407: PUSH
11408: LD_VAR 0 4
11412: ARRAY
11413: PPUSH
11414: CALL_OW 266
11418: PUSH
11419: LD_VAR 0 5
11423: PUSH
11424: LD_VAR 0 4
11428: ARRAY
11429: PPUSH
11430: CALL_OW 250
11434: PUSH
11435: LD_VAR 0 5
11439: PUSH
11440: LD_VAR 0 4
11444: ARRAY
11445: PPUSH
11446: CALL_OW 251
11450: PUSH
11451: LD_VAR 0 5
11455: PUSH
11456: LD_VAR 0 4
11460: ARRAY
11461: PPUSH
11462: CALL_OW 254
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: ADD
11476: ST_TO_ADDR
11477: GO 11390
11479: POP
11480: POP
// result = list ;
11481: LD_ADDR_VAR 0 3
11485: PUSH
11486: LD_VAR 0 6
11490: ST_TO_ADDR
// end ;
11491: LD_VAR 0 3
11495: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
11496: LD_INT 0
11498: PPUSH
11499: PPUSH
11500: PPUSH
11501: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
11502: LD_VAR 0 1
11506: PPUSH
11507: LD_INT 81
11509: PUSH
11510: LD_VAR 0 1
11514: PPUSH
11515: CALL_OW 255
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: PPUSH
11524: CALL_OW 69
11528: PPUSH
11529: LD_VAR 0 1
11533: PPUSH
11534: CALL_OW 74
11538: PPUSH
11539: CALL_OW 296
11543: PUSH
11544: LD_INT 18
11546: LESS
11547: IFFALSE 11592
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
11549: LD_VAR 0 1
11553: PPUSH
11554: LD_INT 81
11556: PUSH
11557: LD_VAR 0 1
11561: PPUSH
11562: CALL_OW 255
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PPUSH
11571: CALL_OW 69
11575: PPUSH
11576: LD_VAR 0 1
11580: PPUSH
11581: CALL_OW 74
11585: PPUSH
11586: CALL_OW 115
11590: GO 11611
// ComMoveXY ( behemoth , x , y ) ;
11592: LD_VAR 0 1
11596: PPUSH
11597: LD_VAR 0 4
11601: PPUSH
11602: LD_VAR 0 5
11606: PPUSH
11607: CALL_OW 111
// if time_lapsers_list > 0 then
11611: LD_VAR 0 2
11615: PUSH
11616: LD_INT 0
11618: GREATER
11619: IFFALSE 11809
// begin for i = 1 to time_lapsers_list do
11621: LD_ADDR_VAR 0 7
11625: PUSH
11626: DOUBLE
11627: LD_INT 1
11629: DEC
11630: ST_TO_ADDR
11631: LD_VAR 0 2
11635: PUSH
11636: FOR_TO
11637: IFFALSE 11807
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11639: LD_VAR 0 2
11643: PUSH
11644: LD_VAR 0 7
11648: ARRAY
11649: PPUSH
11650: CALL_OW 256
11654: PUSH
11655: LD_INT 250
11657: GREATEREQUAL
11658: PUSH
11659: LD_VAR 0 2
11663: PUSH
11664: LD_VAR 0 7
11668: ARRAY
11669: PPUSH
11670: LD_VAR 0 1
11674: PPUSH
11675: CALL_OW 296
11679: PUSH
11680: LD_INT 9
11682: GREATER
11683: AND
11684: IFFALSE 11721
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11686: LD_VAR 0 2
11690: PUSH
11691: LD_VAR 0 7
11695: ARRAY
11696: PPUSH
11697: LD_VAR 0 1
11701: PPUSH
11702: CALL_OW 250
11706: PPUSH
11707: LD_VAR 0 1
11711: PPUSH
11712: CALL_OW 251
11716: PPUSH
11717: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11721: LD_VAR 0 2
11725: PUSH
11726: LD_VAR 0 7
11730: ARRAY
11731: PPUSH
11732: CALL_OW 256
11736: PUSH
11737: LD_INT 500
11739: LESS
11740: PUSH
11741: LD_VAR 0 1
11745: PPUSH
11746: CALL_OW 256
11750: PUSH
11751: LD_INT 700
11753: GREATER
11754: AND
11755: IFFALSE 11805
// for p = 1 to mechanic_list do
11757: LD_ADDR_VAR 0 8
11761: PUSH
11762: DOUBLE
11763: LD_INT 1
11765: DEC
11766: ST_TO_ADDR
11767: LD_VAR 0 3
11771: PUSH
11772: FOR_TO
11773: IFFALSE 11803
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11775: LD_VAR 0 3
11779: PUSH
11780: LD_VAR 0 8
11784: ARRAY
11785: PPUSH
11786: LD_VAR 0 2
11790: PUSH
11791: LD_VAR 0 7
11795: ARRAY
11796: PPUSH
11797: CALL_OW 129
11801: GO 11772
11803: POP
11804: POP
// end ;
11805: GO 11636
11807: POP
11808: POP
// end ; if mechanic_list then
11809: LD_VAR 0 3
11813: IFFALSE 11994
// begin for i = 1 to mechanic_list do
11815: LD_ADDR_VAR 0 7
11819: PUSH
11820: DOUBLE
11821: LD_INT 1
11823: DEC
11824: ST_TO_ADDR
11825: LD_VAR 0 3
11829: PUSH
11830: FOR_TO
11831: IFFALSE 11992
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11833: LD_VAR 0 3
11837: PUSH
11838: LD_VAR 0 7
11842: ARRAY
11843: PPUSH
11844: CALL_OW 256
11848: PUSH
11849: LD_INT 333
11851: LESS
11852: IFFALSE 11876
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11854: LD_ADDR_EXP 14
11858: PUSH
11859: LD_EXP 14
11863: PUSH
11864: LD_VAR 0 3
11868: PUSH
11869: LD_VAR 0 7
11873: ARRAY
11874: DIFF
11875: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11876: LD_VAR 0 3
11880: PUSH
11881: LD_VAR 0 7
11885: ARRAY
11886: PPUSH
11887: LD_VAR 0 1
11891: PPUSH
11892: CALL_OW 296
11896: PUSH
11897: LD_INT 9
11899: GREATER
11900: PUSH
11901: LD_VAR 0 3
11905: PUSH
11906: LD_VAR 0 7
11910: ARRAY
11911: PPUSH
11912: CALL_OW 314
11916: NOT
11917: AND
11918: IFFALSE 11955
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11920: LD_VAR 0 3
11924: PUSH
11925: LD_VAR 0 7
11929: ARRAY
11930: PPUSH
11931: LD_VAR 0 1
11935: PPUSH
11936: CALL_OW 250
11940: PPUSH
11941: LD_VAR 0 1
11945: PPUSH
11946: CALL_OW 251
11950: PPUSH
11951: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11955: LD_VAR 0 1
11959: PPUSH
11960: CALL_OW 256
11964: PUSH
11965: LD_INT 700
11967: LESS
11968: IFFALSE 11990
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11970: LD_VAR 0 3
11974: PUSH
11975: LD_VAR 0 7
11979: ARRAY
11980: PPUSH
11981: LD_VAR 0 1
11985: PPUSH
11986: CALL_OW 129
// end ;
11990: GO 11830
11992: POP
11993: POP
// end ; end ;
11994: LD_VAR 0 6
11998: RET
// export function GetBehemoth ( side ) ; begin
11999: LD_INT 0
12001: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
12002: LD_ADDR_VAR 0 2
12006: PUSH
12007: LD_INT 22
12009: PUSH
12010: LD_VAR 0 1
12014: PUSH
12015: EMPTY
12016: LIST
12017: LIST
12018: PUSH
12019: LD_INT 31
12021: PUSH
12022: LD_INT 25
12024: PUSH
12025: EMPTY
12026: LIST
12027: LIST
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PPUSH
12033: CALL_OW 69
12037: ST_TO_ADDR
// end ;
12038: LD_VAR 0 2
12042: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
12043: LD_INT 0
12045: PPUSH
12046: PPUSH
12047: PPUSH
12048: PPUSH
12049: PPUSH
12050: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
12051: LD_ADDR_VAR 0 6
12055: PUSH
12056: LD_VAR 0 2
12060: PPUSH
12061: CALL_OW 435
12065: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
12066: LD_ADDR_VAR 0 5
12070: PUSH
12071: LD_INT 22
12073: PUSH
12074: LD_VAR 0 1
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 2
12085: PUSH
12086: LD_INT 25
12088: PUSH
12089: LD_INT 2
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: PUSH
12096: LD_INT 25
12098: PUSH
12099: LD_INT 16
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: LIST
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: PPUSH
12115: CALL_OW 69
12119: ST_TO_ADDR
// if skr then
12120: LD_VAR 0 6
12124: IFFALSE 12289
// begin if engs then
12126: LD_VAR 0 5
12130: IFFALSE 12289
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
12132: LD_ADDR_VAR 0 8
12136: PUSH
12137: LD_VAR 0 6
12141: PUSH
12142: LD_INT 1
12144: ARRAY
12145: PPUSH
12146: LD_VAR 0 6
12150: PUSH
12151: LD_INT 2
12153: ARRAY
12154: PPUSH
12155: CALL_OW 284
12159: ST_TO_ADDR
// if am > engs then
12160: LD_VAR 0 8
12164: PUSH
12165: LD_VAR 0 5
12169: GREATER
12170: IFFALSE 12182
// am := engs ;
12172: LD_ADDR_VAR 0 8
12176: PUSH
12177: LD_VAR 0 5
12181: ST_TO_ADDR
// for i = 1 to am do
12182: LD_ADDR_VAR 0 7
12186: PUSH
12187: DOUBLE
12188: LD_INT 1
12190: DEC
12191: ST_TO_ADDR
12192: LD_VAR 0 8
12196: PUSH
12197: FOR_TO
12198: IFFALSE 12287
// begin if IsInUnit ( engs [ i ] ) then
12200: LD_VAR 0 5
12204: PUSH
12205: LD_VAR 0 7
12209: ARRAY
12210: PPUSH
12211: CALL_OW 310
12215: IFFALSE 12234
// ComExitBuilding ( engs [ i ] ) else
12217: LD_VAR 0 5
12221: PUSH
12222: LD_VAR 0 7
12226: ARRAY
12227: PPUSH
12228: CALL_OW 122
12232: GO 12285
// if not HasTask ( engs [ i ] ) then
12234: LD_VAR 0 5
12238: PUSH
12239: LD_VAR 0 7
12243: ARRAY
12244: PPUSH
12245: CALL_OW 314
12249: NOT
12250: IFFALSE 12285
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
12252: LD_VAR 0 5
12256: PUSH
12257: LD_VAR 0 7
12261: ARRAY
12262: PPUSH
12263: LD_VAR 0 6
12267: PUSH
12268: LD_INT 1
12270: ARRAY
12271: PPUSH
12272: LD_VAR 0 6
12276: PUSH
12277: LD_INT 2
12279: ARRAY
12280: PPUSH
12281: CALL_OW 117
// end ;
12285: GO 12197
12287: POP
12288: POP
// end ; end ; end ; end_of_file
12289: LD_VAR 0 3
12293: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
12294: LD_INT 0
12296: PPUSH
12297: PPUSH
// uc_side := 1 ;
12298: LD_ADDR_OWVAR 20
12302: PUSH
12303: LD_INT 1
12305: ST_TO_ADDR
// uc_nation := 1 ;
12306: LD_ADDR_OWVAR 21
12310: PUSH
12311: LD_INT 1
12313: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12314: LD_ADDR_VAR 0 2
12318: PUSH
12319: LD_INT 6
12321: PUSH
12322: LD_INT 5
12324: PUSH
12325: LD_INT 4
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: LIST
12332: PUSH
12333: LD_OWVAR 67
12337: ARRAY
12338: ST_TO_ADDR
// game_status := false ;
12339: LD_ADDR_EXP 28
12343: PUSH
12344: LD_INT 0
12346: ST_TO_ADDR
// helps_arrive := false ;
12347: LD_ADDR_EXP 29
12351: PUSH
12352: LD_INT 0
12354: ST_TO_ADDR
// helps_can_arrive := false ;
12355: LD_ADDR_EXP 30
12359: PUSH
12360: LD_INT 0
12362: ST_TO_ADDR
// beta_come := false ;
12363: LD_ADDR_EXP 31
12367: PUSH
12368: LD_INT 0
12370: ST_TO_ADDR
// gamma_come := false ;
12371: LD_ADDR_EXP 32
12375: PUSH
12376: LD_INT 0
12378: ST_TO_ADDR
// zeta_come := false ;
12379: LD_ADDR_EXP 33
12383: PUSH
12384: LD_INT 0
12386: ST_TO_ADDR
// mine_ck := false ;
12387: LD_ADDR_EXP 34
12391: PUSH
12392: LD_INT 0
12394: ST_TO_ADDR
// sib_bomb_constructed := false ;
12395: LD_ADDR_EXP 35
12399: PUSH
12400: LD_INT 0
12402: ST_TO_ADDR
// mine_constructed := false ;
12403: LD_ADDR_EXP 36
12407: PUSH
12408: LD_INT 0
12410: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
12411: LD_INT 35
12413: PPUSH
12414: CALL_OW 274
12418: PPUSH
12419: LD_INT 1
12421: PPUSH
12422: LD_INT 200
12424: PUSH
12425: LD_INT 100
12427: PUSH
12428: LD_INT 70
12430: PUSH
12431: EMPTY
12432: LIST
12433: LIST
12434: LIST
12435: PUSH
12436: LD_OWVAR 67
12440: ARRAY
12441: PPUSH
12442: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
12446: LD_INT 35
12448: PPUSH
12449: LD_INT 4
12451: PPUSH
12452: CALL_OW 235
// hc_importance := 100 ;
12456: LD_ADDR_OWVAR 32
12460: PUSH
12461: LD_INT 100
12463: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
12464: LD_INT 1
12466: PPUSH
12467: LD_INT 2
12469: PPUSH
12470: LD_VAR 0 2
12474: PUSH
12475: LD_INT 1
12477: PLUS
12478: PPUSH
12479: CALL_OW 380
// hc_gallery := hardch ;
12483: LD_ADDR_OWVAR 33
12487: PUSH
12488: LD_STRING hardch
12490: ST_TO_ADDR
// hc_face_number := 1 ;
12491: LD_ADDR_OWVAR 34
12495: PUSH
12496: LD_INT 1
12498: ST_TO_ADDR
// guyA := CreateHuman ;
12499: LD_ADDR_EXP 37
12503: PUSH
12504: CALL_OW 44
12508: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
12509: LD_INT 1
12511: PPUSH
12512: LD_INT 1
12514: PPUSH
12515: LD_VAR 0 2
12519: PPUSH
12520: CALL_OW 380
// hc_face_number := 2 ;
12524: LD_ADDR_OWVAR 34
12528: PUSH
12529: LD_INT 2
12531: ST_TO_ADDR
// guyB := CreateHuman ;
12532: LD_ADDR_EXP 38
12536: PUSH
12537: CALL_OW 44
12541: ST_TO_ADDR
// hc_importance := 0 ;
12542: LD_ADDR_OWVAR 32
12546: PUSH
12547: LD_INT 0
12549: ST_TO_ADDR
// hc_gallery :=  ;
12550: LD_ADDR_OWVAR 33
12554: PUSH
12555: LD_STRING 
12557: ST_TO_ADDR
// end ;
12558: LD_VAR 0 1
12562: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
12563: LD_INT 0
12565: PPUSH
12566: PPUSH
12567: PPUSH
12568: PPUSH
12569: PPUSH
12570: PPUSH
12571: PPUSH
12572: PPUSH
12573: PPUSH
// uc_side := 4 ;
12574: LD_ADDR_OWVAR 20
12578: PUSH
12579: LD_INT 4
12581: ST_TO_ADDR
// uc_nation := 1 ;
12582: LD_ADDR_OWVAR 21
12586: PUSH
12587: LD_INT 1
12589: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12590: LD_ADDR_VAR 0 10
12594: PUSH
12595: LD_INT 6
12597: PUSH
12598: LD_INT 5
12600: PUSH
12601: LD_INT 4
12603: PUSH
12604: EMPTY
12605: LIST
12606: LIST
12607: LIST
12608: PUSH
12609: LD_OWVAR 67
12613: ARRAY
12614: ST_TO_ADDR
// Beta_Squad := [ ] ;
12615: LD_ADDR_EXP 39
12619: PUSH
12620: EMPTY
12621: ST_TO_ADDR
// case num of 1 :
12622: LD_VAR 0 1
12626: PUSH
12627: LD_INT 1
12629: DOUBLE
12630: EQUAL
12631: IFTRUE 12635
12633: GO 12678
12635: POP
// begin sold := 2 ;
12636: LD_ADDR_VAR 0 5
12640: PUSH
12641: LD_INT 2
12643: ST_TO_ADDR
// sci := 1 ;
12644: LD_ADDR_VAR 0 6
12648: PUSH
12649: LD_INT 1
12651: ST_TO_ADDR
// mech := 2 ;
12652: LD_ADDR_VAR 0 7
12656: PUSH
12657: LD_INT 2
12659: ST_TO_ADDR
// tank := 1 ;
12660: LD_ADDR_VAR 0 8
12664: PUSH
12665: LD_INT 1
12667: ST_TO_ADDR
// cargo := 1 ;
12668: LD_ADDR_VAR 0 9
12672: PUSH
12673: LD_INT 1
12675: ST_TO_ADDR
// end ; 2 :
12676: GO 12781
12678: LD_INT 2
12680: DOUBLE
12681: EQUAL
12682: IFTRUE 12686
12684: GO 12729
12686: POP
// begin sold := 2 ;
12687: LD_ADDR_VAR 0 5
12691: PUSH
12692: LD_INT 2
12694: ST_TO_ADDR
// sci := 1 ;
12695: LD_ADDR_VAR 0 6
12699: PUSH
12700: LD_INT 1
12702: ST_TO_ADDR
// mech := 1 ;
12703: LD_ADDR_VAR 0 7
12707: PUSH
12708: LD_INT 1
12710: ST_TO_ADDR
// tank := 1 ;
12711: LD_ADDR_VAR 0 8
12715: PUSH
12716: LD_INT 1
12718: ST_TO_ADDR
// cargo := 0 ;
12719: LD_ADDR_VAR 0 9
12723: PUSH
12724: LD_INT 0
12726: ST_TO_ADDR
// end ; 3 :
12727: GO 12781
12729: LD_INT 3
12731: DOUBLE
12732: EQUAL
12733: IFTRUE 12737
12735: GO 12780
12737: POP
// begin sold := 1 ;
12738: LD_ADDR_VAR 0 5
12742: PUSH
12743: LD_INT 1
12745: ST_TO_ADDR
// sci := 1 ;
12746: LD_ADDR_VAR 0 6
12750: PUSH
12751: LD_INT 1
12753: ST_TO_ADDR
// mech := 1 ;
12754: LD_ADDR_VAR 0 7
12758: PUSH
12759: LD_INT 1
12761: ST_TO_ADDR
// tank := 1 ;
12762: LD_ADDR_VAR 0 8
12766: PUSH
12767: LD_INT 1
12769: ST_TO_ADDR
// cargo := 0 ;
12770: LD_ADDR_VAR 0 9
12774: PUSH
12775: LD_INT 0
12777: ST_TO_ADDR
// end ; end ;
12778: GO 12781
12780: POP
// for i = 1 to sold do
12781: LD_ADDR_VAR 0 3
12785: PUSH
12786: DOUBLE
12787: LD_INT 1
12789: DEC
12790: ST_TO_ADDR
12791: LD_VAR 0 5
12795: PUSH
12796: FOR_TO
12797: IFFALSE 12869
// begin if i = 1 then
12799: LD_VAR 0 3
12803: PUSH
12804: LD_INT 1
12806: EQUAL
12807: IFFALSE 12826
// PrepareHuman ( sex_male , 1 , skill ) else
12809: LD_INT 1
12811: PPUSH
12812: LD_INT 1
12814: PPUSH
12815: LD_VAR 0 10
12819: PPUSH
12820: CALL_OW 380
12824: GO 12841
// PrepareHuman ( false , 1 , skill ) ;
12826: LD_INT 0
12828: PPUSH
12829: LD_INT 1
12831: PPUSH
12832: LD_VAR 0 10
12836: PPUSH
12837: CALL_OW 380
// un := CreateHuman ;
12841: LD_ADDR_VAR 0 4
12845: PUSH
12846: CALL_OW 44
12850: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12851: LD_ADDR_EXP 39
12855: PUSH
12856: LD_EXP 39
12860: PUSH
12861: LD_VAR 0 4
12865: ADD
12866: ST_TO_ADDR
// end ;
12867: GO 12796
12869: POP
12870: POP
// for i = 1 to mech do
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: DOUBLE
12877: LD_INT 1
12879: DEC
12880: ST_TO_ADDR
12881: LD_VAR 0 7
12885: PUSH
12886: FOR_TO
12887: IFFALSE 12944
// begin PrepareHuman ( false , 3 , skill ) ;
12889: LD_INT 0
12891: PPUSH
12892: LD_INT 3
12894: PPUSH
12895: LD_VAR 0 10
12899: PPUSH
12900: CALL_OW 380
// un := CreateHuman ;
12904: LD_ADDR_VAR 0 4
12908: PUSH
12909: CALL_OW 44
12913: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12914: LD_VAR 0 4
12918: PPUSH
12919: LD_INT 3
12921: PPUSH
12922: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12926: LD_ADDR_EXP 39
12930: PUSH
12931: LD_EXP 39
12935: PUSH
12936: LD_VAR 0 4
12940: ADD
12941: ST_TO_ADDR
// end ;
12942: GO 12886
12944: POP
12945: POP
// for i = 1 to sci do
12946: LD_ADDR_VAR 0 3
12950: PUSH
12951: DOUBLE
12952: LD_INT 1
12954: DEC
12955: ST_TO_ADDR
12956: LD_VAR 0 6
12960: PUSH
12961: FOR_TO
12962: IFFALSE 13007
// begin PrepareHuman ( false , 4 , skill ) ;
12964: LD_INT 0
12966: PPUSH
12967: LD_INT 4
12969: PPUSH
12970: LD_VAR 0 10
12974: PPUSH
12975: CALL_OW 380
// un := CreateHuman ;
12979: LD_ADDR_VAR 0 4
12983: PUSH
12984: CALL_OW 44
12988: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12989: LD_ADDR_EXP 39
12993: PUSH
12994: LD_EXP 39
12998: PUSH
12999: LD_VAR 0 4
13003: ADD
13004: ST_TO_ADDR
// end ;
13005: GO 12961
13007: POP
13008: POP
// for i = 1 to tank do
13009: LD_ADDR_VAR 0 3
13013: PUSH
13014: DOUBLE
13015: LD_INT 1
13017: DEC
13018: ST_TO_ADDR
13019: LD_VAR 0 8
13023: PUSH
13024: FOR_TO
13025: IFFALSE 13138
// begin Randomize ;
13027: CALL_OW 10
// vc_chassis := us_medium_tracked ;
13031: LD_ADDR_OWVAR 37
13035: PUSH
13036: LD_INT 3
13038: ST_TO_ADDR
// vc_engine := engine_solar ;
13039: LD_ADDR_OWVAR 39
13043: PUSH
13044: LD_INT 2
13046: ST_TO_ADDR
// vc_control := control_manual ;
13047: LD_ADDR_OWVAR 38
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
13055: LD_ADDR_OWVAR 40
13059: PUSH
13060: LD_INT 4
13062: PUSH
13063: LD_INT 5
13065: PUSH
13066: EMPTY
13067: LIST
13068: LIST
13069: PUSH
13070: LD_INT 1
13072: PPUSH
13073: LD_INT 2
13075: PPUSH
13076: CALL_OW 12
13080: ARRAY
13081: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13082: LD_ADDR_OWVAR 41
13086: PUSH
13087: LD_INT 35
13089: PPUSH
13090: LD_INT 55
13092: PPUSH
13093: CALL_OW 12
13097: ST_TO_ADDR
// un := CreateVehicle ;
13098: LD_ADDR_VAR 0 4
13102: PUSH
13103: CALL_OW 45
13107: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13108: LD_VAR 0 4
13112: PPUSH
13113: LD_INT 5
13115: PPUSH
13116: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13120: LD_ADDR_EXP 39
13124: PUSH
13125: LD_EXP 39
13129: PUSH
13130: LD_VAR 0 4
13134: ADD
13135: ST_TO_ADDR
// end ;
13136: GO 13024
13138: POP
13139: POP
// if cargo then
13140: LD_VAR 0 9
13144: IFFALSE 13247
// begin vc_chassis := us_medium_tracked ;
13146: LD_ADDR_OWVAR 37
13150: PUSH
13151: LD_INT 3
13153: ST_TO_ADDR
// vc_engine := engine_solar ;
13154: LD_ADDR_OWVAR 39
13158: PUSH
13159: LD_INT 2
13161: ST_TO_ADDR
// vc_control := control_manual ;
13162: LD_ADDR_OWVAR 38
13166: PUSH
13167: LD_INT 1
13169: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13170: LD_ADDR_OWVAR 40
13174: PUSH
13175: LD_INT 12
13177: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13178: LD_ADDR_OWVAR 41
13182: PUSH
13183: LD_INT 35
13185: PPUSH
13186: LD_INT 55
13188: PPUSH
13189: CALL_OW 12
13193: ST_TO_ADDR
// un := CreateVehicle ;
13194: LD_ADDR_VAR 0 4
13198: PUSH
13199: CALL_OW 45
13203: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13204: LD_VAR 0 4
13208: PPUSH
13209: LD_INT 5
13211: PPUSH
13212: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13216: LD_ADDR_EXP 39
13220: PUSH
13221: LD_EXP 39
13225: PUSH
13226: LD_VAR 0 4
13230: ADD
13231: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
13232: LD_VAR 0 4
13236: PPUSH
13237: LD_INT 1
13239: PPUSH
13240: LD_INT 60
13242: PPUSH
13243: CALL_OW 290
// end ; end ;
13247: LD_VAR 0 2
13251: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13252: LD_INT 0
13254: PPUSH
13255: PPUSH
13256: PPUSH
13257: PPUSH
13258: PPUSH
13259: PPUSH
13260: PPUSH
13261: PPUSH
13262: PPUSH
13263: PPUSH
// uc_side := 4 ;
13264: LD_ADDR_OWVAR 20
13268: PUSH
13269: LD_INT 4
13271: ST_TO_ADDR
// uc_nation := 1 ;
13272: LD_ADDR_OWVAR 21
13276: PUSH
13277: LD_INT 1
13279: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13280: LD_ADDR_VAR 0 11
13284: PUSH
13285: LD_INT 6
13287: PUSH
13288: LD_INT 5
13290: PUSH
13291: LD_INT 4
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: PUSH
13299: LD_OWVAR 67
13303: ARRAY
13304: ST_TO_ADDR
// Gamma_Squad := [ ] ;
13305: LD_ADDR_EXP 40
13309: PUSH
13310: EMPTY
13311: ST_TO_ADDR
// case num of 1 :
13312: LD_VAR 0 1
13316: PUSH
13317: LD_INT 1
13319: DOUBLE
13320: EQUAL
13321: IFTRUE 13325
13323: GO 13376
13325: POP
// begin sold := 2 ;
13326: LD_ADDR_VAR 0 5
13330: PUSH
13331: LD_INT 2
13333: ST_TO_ADDR
// eng := 2 ;
13334: LD_ADDR_VAR 0 6
13338: PUSH
13339: LD_INT 2
13341: ST_TO_ADDR
// sci := 0 ;
13342: LD_ADDR_VAR 0 7
13346: PUSH
13347: LD_INT 0
13349: ST_TO_ADDR
// mech := 1 ;
13350: LD_ADDR_VAR 0 8
13354: PUSH
13355: LD_INT 1
13357: ST_TO_ADDR
// tank := 0 ;
13358: LD_ADDR_VAR 0 9
13362: PUSH
13363: LD_INT 0
13365: ST_TO_ADDR
// cargo := 1 ;
13366: LD_ADDR_VAR 0 10
13370: PUSH
13371: LD_INT 1
13373: ST_TO_ADDR
// end ; 2 :
13374: GO 13495
13376: LD_INT 2
13378: DOUBLE
13379: EQUAL
13380: IFTRUE 13384
13382: GO 13435
13384: POP
// begin sold := 1 ;
13385: LD_ADDR_VAR 0 5
13389: PUSH
13390: LD_INT 1
13392: ST_TO_ADDR
// eng := 2 ;
13393: LD_ADDR_VAR 0 6
13397: PUSH
13398: LD_INT 2
13400: ST_TO_ADDR
// sci := 0 ;
13401: LD_ADDR_VAR 0 7
13405: PUSH
13406: LD_INT 0
13408: ST_TO_ADDR
// mech := 1 ;
13409: LD_ADDR_VAR 0 8
13413: PUSH
13414: LD_INT 1
13416: ST_TO_ADDR
// tank := 0 ;
13417: LD_ADDR_VAR 0 9
13421: PUSH
13422: LD_INT 0
13424: ST_TO_ADDR
// cargo := 1 ;
13425: LD_ADDR_VAR 0 10
13429: PUSH
13430: LD_INT 1
13432: ST_TO_ADDR
// end ; 3 :
13433: GO 13495
13435: LD_INT 3
13437: DOUBLE
13438: EQUAL
13439: IFTRUE 13443
13441: GO 13494
13443: POP
// begin sold := 1 ;
13444: LD_ADDR_VAR 0 5
13448: PUSH
13449: LD_INT 1
13451: ST_TO_ADDR
// eng := 1 ;
13452: LD_ADDR_VAR 0 6
13456: PUSH
13457: LD_INT 1
13459: ST_TO_ADDR
// sci := 0 ;
13460: LD_ADDR_VAR 0 7
13464: PUSH
13465: LD_INT 0
13467: ST_TO_ADDR
// mech := 1 ;
13468: LD_ADDR_VAR 0 8
13472: PUSH
13473: LD_INT 1
13475: ST_TO_ADDR
// tank := 0 ;
13476: LD_ADDR_VAR 0 9
13480: PUSH
13481: LD_INT 0
13483: ST_TO_ADDR
// cargo := 1 ;
13484: LD_ADDR_VAR 0 10
13488: PUSH
13489: LD_INT 1
13491: ST_TO_ADDR
// end ; end ;
13492: GO 13495
13494: POP
// for i = 1 to sold do
13495: LD_ADDR_VAR 0 3
13499: PUSH
13500: DOUBLE
13501: LD_INT 1
13503: DEC
13504: ST_TO_ADDR
13505: LD_VAR 0 5
13509: PUSH
13510: FOR_TO
13511: IFFALSE 13583
// begin if i = 1 then
13513: LD_VAR 0 3
13517: PUSH
13518: LD_INT 1
13520: EQUAL
13521: IFFALSE 13540
// PrepareHuman ( sex_male , 1 , skill ) else
13523: LD_INT 1
13525: PPUSH
13526: LD_INT 1
13528: PPUSH
13529: LD_VAR 0 11
13533: PPUSH
13534: CALL_OW 380
13538: GO 13555
// PrepareHuman ( false , 1 , skill ) ;
13540: LD_INT 0
13542: PPUSH
13543: LD_INT 1
13545: PPUSH
13546: LD_VAR 0 11
13550: PPUSH
13551: CALL_OW 380
// un := CreateHuman ;
13555: LD_ADDR_VAR 0 4
13559: PUSH
13560: CALL_OW 44
13564: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13565: LD_ADDR_EXP 40
13569: PUSH
13570: LD_EXP 40
13574: PUSH
13575: LD_VAR 0 4
13579: ADD
13580: ST_TO_ADDR
// end ;
13581: GO 13510
13583: POP
13584: POP
// for i = 1 to mech do
13585: LD_ADDR_VAR 0 3
13589: PUSH
13590: DOUBLE
13591: LD_INT 1
13593: DEC
13594: ST_TO_ADDR
13595: LD_VAR 0 8
13599: PUSH
13600: FOR_TO
13601: IFFALSE 13658
// begin PrepareHuman ( false , 3 , skill ) ;
13603: LD_INT 0
13605: PPUSH
13606: LD_INT 3
13608: PPUSH
13609: LD_VAR 0 11
13613: PPUSH
13614: CALL_OW 380
// un := CreateHuman ;
13618: LD_ADDR_VAR 0 4
13622: PUSH
13623: CALL_OW 44
13627: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13628: LD_VAR 0 4
13632: PPUSH
13633: LD_INT 3
13635: PPUSH
13636: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13640: LD_ADDR_EXP 40
13644: PUSH
13645: LD_EXP 40
13649: PUSH
13650: LD_VAR 0 4
13654: ADD
13655: ST_TO_ADDR
// end ;
13656: GO 13600
13658: POP
13659: POP
// for i = 1 to eng do
13660: LD_ADDR_VAR 0 3
13664: PUSH
13665: DOUBLE
13666: LD_INT 1
13668: DEC
13669: ST_TO_ADDR
13670: LD_VAR 0 6
13674: PUSH
13675: FOR_TO
13676: IFFALSE 13721
// begin PrepareHuman ( false , 2 , skill ) ;
13678: LD_INT 0
13680: PPUSH
13681: LD_INT 2
13683: PPUSH
13684: LD_VAR 0 11
13688: PPUSH
13689: CALL_OW 380
// un := CreateHuman ;
13693: LD_ADDR_VAR 0 4
13697: PUSH
13698: CALL_OW 44
13702: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13703: LD_ADDR_EXP 40
13707: PUSH
13708: LD_EXP 40
13712: PUSH
13713: LD_VAR 0 4
13717: ADD
13718: ST_TO_ADDR
// end ;
13719: GO 13675
13721: POP
13722: POP
// for i = 1 to tank do
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: DOUBLE
13729: LD_INT 1
13731: DEC
13732: ST_TO_ADDR
13733: LD_VAR 0 9
13737: PUSH
13738: FOR_TO
13739: IFFALSE 13852
// begin Randomize ;
13741: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13745: LD_ADDR_OWVAR 37
13749: PUSH
13750: LD_INT 2
13752: ST_TO_ADDR
// vc_engine := engine_siberite ;
13753: LD_ADDR_OWVAR 39
13757: PUSH
13758: LD_INT 3
13760: ST_TO_ADDR
// vc_control := control_manual ;
13761: LD_ADDR_OWVAR 38
13765: PUSH
13766: LD_INT 1
13768: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13769: LD_ADDR_OWVAR 40
13773: PUSH
13774: LD_INT 7
13776: PUSH
13777: LD_INT 9
13779: PUSH
13780: EMPTY
13781: LIST
13782: LIST
13783: PUSH
13784: LD_INT 1
13786: PPUSH
13787: LD_INT 2
13789: PPUSH
13790: CALL_OW 12
13794: ARRAY
13795: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13796: LD_ADDR_OWVAR 41
13800: PUSH
13801: LD_INT 35
13803: PPUSH
13804: LD_INT 55
13806: PPUSH
13807: CALL_OW 12
13811: ST_TO_ADDR
// un := CreateVehicle ;
13812: LD_ADDR_VAR 0 4
13816: PUSH
13817: CALL_OW 45
13821: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13822: LD_VAR 0 4
13826: PPUSH
13827: LD_INT 5
13829: PPUSH
13830: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13834: LD_ADDR_EXP 40
13838: PUSH
13839: LD_EXP 40
13843: PUSH
13844: LD_VAR 0 4
13848: ADD
13849: ST_TO_ADDR
// end ;
13850: GO 13738
13852: POP
13853: POP
// if cargo then
13854: LD_VAR 0 10
13858: IFFALSE 13976
// begin vc_chassis := us_medium_tracked ;
13860: LD_ADDR_OWVAR 37
13864: PUSH
13865: LD_INT 3
13867: ST_TO_ADDR
// vc_engine := engine_combustion ;
13868: LD_ADDR_OWVAR 39
13872: PUSH
13873: LD_INT 1
13875: ST_TO_ADDR
// vc_control := control_manual ;
13876: LD_ADDR_OWVAR 38
13880: PUSH
13881: LD_INT 1
13883: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13884: LD_ADDR_OWVAR 40
13888: PUSH
13889: LD_INT 12
13891: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13892: LD_ADDR_OWVAR 41
13896: PUSH
13897: LD_INT 35
13899: PPUSH
13900: LD_INT 55
13902: PPUSH
13903: CALL_OW 12
13907: ST_TO_ADDR
// un := CreateVehicle ;
13908: LD_ADDR_VAR 0 4
13912: PUSH
13913: CALL_OW 45
13917: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13918: LD_VAR 0 4
13922: PPUSH
13923: LD_INT 5
13925: PPUSH
13926: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13930: LD_ADDR_EXP 40
13934: PUSH
13935: LD_EXP 40
13939: PUSH
13940: LD_VAR 0 4
13944: ADD
13945: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13946: LD_VAR 0 4
13950: PPUSH
13951: LD_INT 3
13953: PPUSH
13954: LD_INT 30
13956: PPUSH
13957: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13961: LD_VAR 0 4
13965: PPUSH
13966: LD_INT 1
13968: PPUSH
13969: LD_INT 40
13971: PPUSH
13972: CALL_OW 290
// end ; end ;
13976: LD_VAR 0 2
13980: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13981: LD_INT 0
13983: PPUSH
13984: PPUSH
13985: PPUSH
13986: PPUSH
13987: PPUSH
13988: PPUSH
13989: PPUSH
13990: PPUSH
13991: PPUSH
13992: PPUSH
// uc_side := 4 ;
13993: LD_ADDR_OWVAR 20
13997: PUSH
13998: LD_INT 4
14000: ST_TO_ADDR
// uc_nation := 1 ;
14001: LD_ADDR_OWVAR 21
14005: PUSH
14006: LD_INT 1
14008: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
14009: LD_ADDR_VAR 0 10
14013: PUSH
14014: LD_INT 6
14016: PUSH
14017: LD_INT 5
14019: PUSH
14020: LD_INT 4
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: LIST
14027: PUSH
14028: LD_OWVAR 67
14032: ARRAY
14033: ST_TO_ADDR
// Zeta_Squad := [ ] ;
14034: LD_ADDR_EXP 41
14038: PUSH
14039: EMPTY
14040: ST_TO_ADDR
// sold := 1 ;
14041: LD_ADDR_VAR 0 4
14045: PUSH
14046: LD_INT 1
14048: ST_TO_ADDR
// eng := 0 ;
14049: LD_ADDR_VAR 0 5
14053: PUSH
14054: LD_INT 0
14056: ST_TO_ADDR
// sci := 0 ;
14057: LD_ADDR_VAR 0 6
14061: PUSH
14062: LD_INT 0
14064: ST_TO_ADDR
// mech := 3 ;
14065: LD_ADDR_VAR 0 7
14069: PUSH
14070: LD_INT 3
14072: ST_TO_ADDR
// tank := 3 ;
14073: LD_ADDR_VAR 0 8
14077: PUSH
14078: LD_INT 3
14080: ST_TO_ADDR
// cargo := 0 ;
14081: LD_ADDR_VAR 0 9
14085: PUSH
14086: LD_INT 0
14088: ST_TO_ADDR
// for i = 1 to sold do
14089: LD_ADDR_VAR 0 2
14093: PUSH
14094: DOUBLE
14095: LD_INT 1
14097: DEC
14098: ST_TO_ADDR
14099: LD_VAR 0 4
14103: PUSH
14104: FOR_TO
14105: IFFALSE 14177
// begin if i = 1 then
14107: LD_VAR 0 2
14111: PUSH
14112: LD_INT 1
14114: EQUAL
14115: IFFALSE 14134
// PrepareHuman ( sex_male , 1 , skill ) else
14117: LD_INT 1
14119: PPUSH
14120: LD_INT 1
14122: PPUSH
14123: LD_VAR 0 10
14127: PPUSH
14128: CALL_OW 380
14132: GO 14149
// PrepareHuman ( false , 1 , skill ) ;
14134: LD_INT 0
14136: PPUSH
14137: LD_INT 1
14139: PPUSH
14140: LD_VAR 0 10
14144: PPUSH
14145: CALL_OW 380
// un := CreateHuman ;
14149: LD_ADDR_VAR 0 3
14153: PUSH
14154: CALL_OW 44
14158: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
14159: LD_ADDR_EXP 41
14163: PUSH
14164: LD_EXP 41
14168: PUSH
14169: LD_VAR 0 3
14173: ADD
14174: ST_TO_ADDR
// end ;
14175: GO 14104
14177: POP
14178: POP
// for i = 1 to mech do
14179: LD_ADDR_VAR 0 2
14183: PUSH
14184: DOUBLE
14185: LD_INT 1
14187: DEC
14188: ST_TO_ADDR
14189: LD_VAR 0 7
14193: PUSH
14194: FOR_TO
14195: IFFALSE 14252
// begin PrepareHuman ( false , 3 , skill ) ;
14197: LD_INT 0
14199: PPUSH
14200: LD_INT 3
14202: PPUSH
14203: LD_VAR 0 10
14207: PPUSH
14208: CALL_OW 380
// un := CreateHuman ;
14212: LD_ADDR_VAR 0 3
14216: PUSH
14217: CALL_OW 44
14221: ST_TO_ADDR
// SetTag ( un , 3 ) ;
14222: LD_VAR 0 3
14226: PPUSH
14227: LD_INT 3
14229: PPUSH
14230: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14234: LD_ADDR_EXP 41
14238: PUSH
14239: LD_EXP 41
14243: PUSH
14244: LD_VAR 0 3
14248: ADD
14249: ST_TO_ADDR
// end ;
14250: GO 14194
14252: POP
14253: POP
// for i = 1 to tank do
14254: LD_ADDR_VAR 0 2
14258: PUSH
14259: DOUBLE
14260: LD_INT 1
14262: DEC
14263: ST_TO_ADDR
14264: LD_VAR 0 8
14268: PUSH
14269: FOR_TO
14270: IFFALSE 14516
// begin Randomize ;
14272: CALL_OW 10
// if i < 3 then
14276: LD_VAR 0 2
14280: PUSH
14281: LD_INT 3
14283: LESS
14284: IFFALSE 14393
// begin vc_chassis := us_medium_tracked ;
14286: LD_ADDR_OWVAR 37
14290: PUSH
14291: LD_INT 3
14293: ST_TO_ADDR
// vc_engine := engine_combustion ;
14294: LD_ADDR_OWVAR 39
14298: PUSH
14299: LD_INT 1
14301: ST_TO_ADDR
// vc_control := control_manual ;
14302: LD_ADDR_OWVAR 38
14306: PUSH
14307: LD_INT 1
14309: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
14310: LD_ADDR_OWVAR 40
14314: PUSH
14315: LD_INT 3
14317: PUSH
14318: LD_INT 9
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: PUSH
14325: LD_INT 1
14327: PPUSH
14328: LD_INT 2
14330: PPUSH
14331: CALL_OW 12
14335: ARRAY
14336: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14337: LD_ADDR_OWVAR 41
14341: PUSH
14342: LD_INT 35
14344: PPUSH
14345: LD_INT 55
14347: PPUSH
14348: CALL_OW 12
14352: ST_TO_ADDR
// un := CreateVehicle ;
14353: LD_ADDR_VAR 0 3
14357: PUSH
14358: CALL_OW 45
14362: ST_TO_ADDR
// SetTag ( un , 5 ) ;
14363: LD_VAR 0 3
14367: PPUSH
14368: LD_INT 5
14370: PPUSH
14371: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14375: LD_ADDR_EXP 41
14379: PUSH
14380: LD_EXP 41
14384: PUSH
14385: LD_VAR 0 3
14389: ADD
14390: ST_TO_ADDR
// end else
14391: GO 14514
// begin uc_nation := 3 ;
14393: LD_ADDR_OWVAR 21
14397: PUSH
14398: LD_INT 3
14400: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
14401: LD_ADDR_OWVAR 37
14405: PUSH
14406: LD_INT 22
14408: ST_TO_ADDR
// vc_engine := engine_combustion ;
14409: LD_ADDR_OWVAR 39
14413: PUSH
14414: LD_INT 1
14416: ST_TO_ADDR
// vc_control := control_manual ;
14417: LD_ADDR_OWVAR 38
14421: PUSH
14422: LD_INT 1
14424: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
14425: LD_ADDR_OWVAR 40
14429: PUSH
14430: LD_INT 51
14432: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14433: LD_ADDR_OWVAR 41
14437: PUSH
14438: LD_INT 35
14440: PPUSH
14441: LD_INT 55
14443: PPUSH
14444: CALL_OW 12
14448: ST_TO_ADDR
// un := CreateVehicle ;
14449: LD_ADDR_VAR 0 3
14453: PUSH
14454: CALL_OW 45
14458: ST_TO_ADDR
// SetLives ( un , 496 ) ;
14459: LD_VAR 0 3
14463: PPUSH
14464: LD_INT 496
14466: PPUSH
14467: CALL_OW 234
// SetTag ( un , 5 ) ;
14471: LD_VAR 0 3
14475: PPUSH
14476: LD_INT 5
14478: PPUSH
14479: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
14483: LD_VAR 0 3
14487: PPUSH
14488: LD_INT 2
14490: PPUSH
14491: LD_INT 100
14493: PPUSH
14494: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
14498: LD_ADDR_EXP 41
14502: PUSH
14503: LD_EXP 41
14507: PUSH
14508: LD_VAR 0 3
14512: ADD
14513: ST_TO_ADDR
// end ; end ;
14514: GO 14269
14516: POP
14517: POP
// end ; end_of_file
14518: LD_VAR 0 1
14522: RET
// export function Action ; begin
14523: LD_INT 0
14525: PPUSH
// InGameOn ;
14526: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
14530: LD_INT 151
14532: PPUSH
14533: LD_INT 107
14535: PPUSH
14536: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
14540: LD_EXP 37
14544: PPUSH
14545: LD_INT 171
14547: PPUSH
14548: LD_INT 108
14550: PPUSH
14551: LD_INT 0
14553: PPUSH
14554: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
14558: LD_EXP 38
14562: PPUSH
14563: LD_INT 172
14565: PPUSH
14566: LD_INT 110
14568: PPUSH
14569: LD_INT 0
14571: PPUSH
14572: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
14576: LD_EXP 37
14580: PPUSH
14581: LD_INT 156
14583: PPUSH
14584: LD_INT 107
14586: PPUSH
14587: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
14591: LD_EXP 38
14595: PPUSH
14596: LD_INT 154
14598: PPUSH
14599: LD_INT 105
14601: PPUSH
14602: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
14606: LD_INT 4
14608: PPUSH
14609: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
14613: LD_EXP 37
14617: PPUSH
14618: CALL_OW 250
14622: PUSH
14623: LD_INT 156
14625: EQUAL
14626: PUSH
14627: LD_EXP 37
14631: PPUSH
14632: CALL_OW 251
14636: PUSH
14637: LD_INT 107
14639: EQUAL
14640: AND
14641: IFFALSE 14606
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14643: LD_EXP 37
14647: PUSH
14648: LD_EXP 38
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PPUSH
14657: LD_INT 35
14659: PPUSH
14660: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14664: LD_EXP 37
14668: PPUSH
14669: LD_STRING D1-A-1
14671: PPUSH
14672: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14676: LD_EXP 38
14680: PPUSH
14681: LD_STRING D1-B-1
14683: PPUSH
14684: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14688: LD_EXP 37
14692: PPUSH
14693: LD_STRING D1-A-2
14695: PPUSH
14696: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14700: LD_EXP 38
14704: PPUSH
14705: LD_STRING D1-B-2
14707: PPUSH
14708: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14712: LD_EXP 37
14716: PUSH
14717: LD_EXP 38
14721: PUSH
14722: EMPTY
14723: LIST
14724: LIST
14725: PPUSH
14726: LD_INT 147
14728: PPUSH
14729: LD_INT 108
14731: PPUSH
14732: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14736: LD_EXP 37
14740: PPUSH
14741: LD_STRING D1-A-3
14743: PPUSH
14744: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14748: LD_INT 4
14750: PPUSH
14751: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14755: LD_EXP 37
14759: PPUSH
14760: LD_INT 35
14762: PPUSH
14763: CALL_OW 296
14767: PUSH
14768: LD_INT 8
14770: LESS
14771: IFFALSE 14748
// ComTurnUnit ( guyA , guyB ) ;
14773: LD_EXP 37
14777: PPUSH
14778: LD_EXP 38
14782: PPUSH
14783: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14787: LD_EXP 38
14791: PPUSH
14792: LD_EXP 37
14796: PPUSH
14797: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14801: LD_EXP 37
14805: PPUSH
14806: LD_STRING D1-A-10
14808: PPUSH
14809: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14813: LD_EXP 38
14817: PPUSH
14818: LD_STRING D1-B-10
14820: PPUSH
14821: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14825: LD_EXP 37
14829: PPUSH
14830: LD_STRING D1-A-11
14832: PPUSH
14833: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14837: LD_EXP 38
14841: PPUSH
14842: LD_STRING D1-B-11
14844: PPUSH
14845: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14849: LD_EXP 37
14853: PPUSH
14854: LD_STRING D1-A-12
14856: PPUSH
14857: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14861: LD_EXP 38
14865: PPUSH
14866: LD_STRING D1-B-12
14868: PPUSH
14869: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14873: LD_EXP 37
14877: PPUSH
14878: LD_STRING D1-A-13
14880: PPUSH
14881: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14885: LD_EXP 38
14889: PPUSH
14890: LD_STRING D1-B-13
14892: PPUSH
14893: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14897: LD_EXP 37
14901: PPUSH
14902: LD_STRING D1-A-14
14904: PPUSH
14905: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14909: LD_EXP 38
14913: PPUSH
14914: LD_STRING D1-B-14
14916: PPUSH
14917: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14921: LD_EXP 37
14925: PPUSH
14926: LD_STRING D1-A-15
14928: PPUSH
14929: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14933: LD_EXP 38
14937: PPUSH
14938: LD_STRING D1-B-15
14940: PPUSH
14941: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14945: LD_EXP 37
14949: PPUSH
14950: LD_STRING D1-A-16
14952: PPUSH
14953: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14957: LD_EXP 38
14961: PPUSH
14962: LD_STRING D1-B-16
14964: PPUSH
14965: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14969: LD_EXP 37
14973: PPUSH
14974: LD_STRING D1-A-17
14976: PPUSH
14977: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14981: LD_EXP 38
14985: PPUSH
14986: LD_STRING D1-B-17
14988: PPUSH
14989: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
14993: LD_EXP 37
14997: PPUSH
14998: LD_STRING D1-A-18
15000: PPUSH
15001: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
15005: LD_INT 35
15007: PPUSH
15008: LD_INT 1
15010: PPUSH
15011: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
15015: LD_EXP 37
15019: PUSH
15020: LD_EXP 38
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PPUSH
15029: LD_INT 35
15031: PPUSH
15032: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
15036: LD_INT 4
15038: PPUSH
15039: CALL_OW 67
// until IsInUnit ( guyA ) ;
15043: LD_EXP 37
15047: PPUSH
15048: CALL_OW 310
15052: IFFALSE 15036
// Wait ( 0 0$02 ) ;
15054: LD_INT 70
15056: PPUSH
15057: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
15061: LD_EXP 37
15065: PPUSH
15066: LD_STRING D1-A-19
15068: PPUSH
15069: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
15073: LD_EXP 38
15077: PPUSH
15078: LD_STRING D1-B-19
15080: PPUSH
15081: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
15085: LD_EXP 37
15089: PPUSH
15090: LD_STRING D1-A-20
15092: PPUSH
15093: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
15097: LD_INT 10
15099: PPUSH
15100: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
15104: LD_EXP 38
15108: PPUSH
15109: LD_STRING D1-B-20
15111: PPUSH
15112: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
15116: LD_EXP 37
15120: PPUSH
15121: LD_STRING D1-A-21
15123: PPUSH
15124: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
15128: LD_EXP 38
15132: PPUSH
15133: LD_STRING D1-B-21
15135: PPUSH
15136: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
15140: LD_EXP 37
15144: PPUSH
15145: LD_STRING D1-A-22
15147: PPUSH
15148: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
15152: LD_EXP 38
15156: PPUSH
15157: LD_STRING D1-B-22
15159: PPUSH
15160: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
15164: LD_EXP 37
15168: PPUSH
15169: LD_STRING D1-A-23
15171: PPUSH
15172: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
15176: LD_EXP 38
15180: PPUSH
15181: LD_STRING D1-B-23
15183: PPUSH
15184: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
15188: LD_EXP 37
15192: PPUSH
15193: LD_STRING D1-A-24
15195: PPUSH
15196: CALL_OW 88
// InGameOff ;
15200: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
15204: LD_STRING M_main
15206: PPUSH
15207: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
15211: LD_INT 4
15213: PPUSH
15214: LD_INT 1
15216: PPUSH
15217: CALL_OW 343
// game_status := true ;
15221: LD_ADDR_EXP 28
15225: PUSH
15226: LD_INT 1
15228: ST_TO_ADDR
// end ;
15229: LD_VAR 0 1
15233: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
15234: LD_INT 1
15236: PPUSH
15237: CALL 6921 0 1
15241: PUSH
15242: LD_INT 0
15244: GREATER
15245: IFFALSE 15347
15247: GO 15249
15249: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15250: LD_INT 35
15252: PPUSH
15253: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
15257: LD_INT 1
15259: PPUSH
15260: CALL 6921 0 1
15264: PUSH
15265: LD_INT 1
15267: ARRAY
15268: PPUSH
15269: CALL_OW 461
15273: PUSH
15274: LD_INT 1
15276: NONEQUAL
15277: IFFALSE 15250
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
15279: LD_EXP 37
15283: PPUSH
15284: CALL_OW 300
15288: PUSH
15289: LD_EXP 38
15293: PPUSH
15294: CALL_OW 300
15298: AND
15299: PUSH
15300: LD_EXP 29
15304: NOT
15305: AND
15306: IFFALSE 15332
// begin Say ( guyA , DL-A-1 ) ;
15308: LD_EXP 37
15312: PPUSH
15313: LD_STRING DL-A-1
15315: PPUSH
15316: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
15320: LD_EXP 38
15324: PPUSH
15325: LD_STRING DL-B-1
15327: PPUSH
15328: CALL_OW 88
// end ; if not helps_can_arrive then
15332: LD_EXP 30
15336: NOT
15337: IFFALSE 15347
// helps_can_arrive := true ;
15339: LD_ADDR_EXP 30
15343: PUSH
15344: LD_INT 1
15346: ST_TO_ADDR
// end ;
15347: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
15348: LD_INT 1
15350: PPUSH
15351: CALL 6921 0 1
15355: PUSH
15356: LD_INT 0
15358: GREATER
15359: PUSH
15360: LD_EXP 37
15364: PPUSH
15365: CALL_OW 300
15369: AND
15370: PUSH
15371: LD_EXP 38
15375: PPUSH
15376: CALL_OW 300
15380: AND
15381: PUSH
15382: LD_INT 22
15384: PUSH
15385: LD_INT 1
15387: PUSH
15388: EMPTY
15389: LIST
15390: LIST
15391: PUSH
15392: LD_INT 25
15394: PUSH
15395: LD_INT 12
15397: PUSH
15398: EMPTY
15399: LIST
15400: LIST
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: PPUSH
15406: CALL_OW 69
15410: PUSH
15411: LD_INT 0
15413: EQUAL
15414: AND
15415: PUSH
15416: LD_INT 1
15418: PPUSH
15419: LD_INT 25
15421: PUSH
15422: LD_INT 12
15424: PUSH
15425: EMPTY
15426: LIST
15427: LIST
15428: PPUSH
15429: CALL_OW 69
15433: PPUSH
15434: LD_EXP 37
15438: PPUSH
15439: CALL_OW 74
15443: PPUSH
15444: CALL_OW 292
15448: AND
15449: IFFALSE 15490
15451: GO 15453
15453: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
15454: LD_EXP 37
15458: PPUSH
15459: LD_STRING DA-A-1
15461: PPUSH
15462: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
15466: LD_EXP 38
15470: PPUSH
15471: LD_STRING DA-B-1
15473: PPUSH
15474: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
15478: LD_EXP 37
15482: PPUSH
15483: LD_STRING DA-A-2
15485: PPUSH
15486: CALL_OW 88
// end ;
15490: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
15491: LD_EXP 28
15495: PUSH
15496: LD_EXP 37
15500: PPUSH
15501: LD_INT 6
15503: PPUSH
15504: CALL_OW 299
15508: PUSH
15509: LD_INT 7
15511: LESS
15512: AND
15513: IFFALSE 15566
15515: GO 15517
15517: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
15518: LD_INT 117
15520: PPUSH
15521: LD_INT 50
15523: PPUSH
15524: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
15528: LD_INT 1
15530: PPUSH
15531: CALL 10662 0 1
15535: PUSH
15536: LD_INT 2
15538: ARRAY
15539: PPUSH
15540: LD_STRING D5-A-1
15542: PPUSH
15543: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
15547: LD_INT 1
15549: PPUSH
15550: CALL 10662 0 1
15554: PUSH
15555: LD_INT 1
15557: ARRAY
15558: PPUSH
15559: LD_STRING D5-B-1
15561: PPUSH
15562: CALL_OW 88
// end ;
15566: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
15567: LD_INT 7
15569: PPUSH
15570: LD_INT 22
15572: PUSH
15573: LD_INT 1
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: PPUSH
15580: CALL_OW 70
15584: PUSH
15585: LD_INT 0
15587: GREATER
15588: IFFALSE 15733
15590: GO 15592
15592: DISABLE
// begin Wait ( 0 0$03 ) ;
15593: LD_INT 105
15595: PPUSH
15596: CALL_OW 67
// DialogueOn ;
15600: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
15604: LD_INT 1
15606: PPUSH
15607: CALL 10662 0 1
15611: PUSH
15612: LD_INT 1
15614: ARRAY
15615: PPUSH
15616: LD_STRING D6-A-1
15618: PPUSH
15619: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15623: LD_INT 1
15625: PPUSH
15626: CALL 10662 0 1
15630: PUSH
15631: LD_INT 2
15633: ARRAY
15634: PPUSH
15635: LD_STRING D6-B-1
15637: PPUSH
15638: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15642: LD_INT 95
15644: PPUSH
15645: LD_INT 8
15647: PPUSH
15648: LD_INT 1
15650: PPUSH
15651: LD_INT 20
15653: PPUSH
15654: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15658: LD_INT 10
15660: PPUSH
15661: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15665: LD_INT 1
15667: PPUSH
15668: CALL 10662 0 1
15672: PUSH
15673: LD_INT 1
15675: ARRAY
15676: PPUSH
15677: LD_STRING D6-A-2
15679: PPUSH
15680: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15684: LD_INT 1
15686: PPUSH
15687: CALL 10662 0 1
15691: PUSH
15692: LD_INT 2
15694: ARRAY
15695: PPUSH
15696: LD_STRING D6-B-2
15698: PPUSH
15699: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15703: LD_INT 1
15705: PPUSH
15706: CALL 10662 0 1
15710: PUSH
15711: LD_INT 1
15713: ARRAY
15714: PPUSH
15715: LD_STRING D6-A-3
15717: PPUSH
15718: CALL_OW 88
// DialogueOff ;
15722: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15726: LD_STRING M_base
15728: PPUSH
15729: CALL_OW 337
// end ;
15733: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15734: LD_EXP 29
15738: NOT
15739: PUSH
15740: LD_INT 22
15742: PUSH
15743: LD_INT 3
15745: PUSH
15746: EMPTY
15747: LIST
15748: LIST
15749: PUSH
15750: LD_INT 21
15752: PUSH
15753: LD_INT 2
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: PUSH
15760: EMPTY
15761: LIST
15762: LIST
15763: PPUSH
15764: CALL_OW 69
15768: PUSH
15769: LD_INT 0
15771: GREATER
15772: AND
15773: IFFALSE 15906
15775: GO 15777
15777: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15778: LD_INT 35
15780: PPUSH
15781: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15785: LD_INT 22
15787: PUSH
15788: LD_INT 3
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 21
15797: PUSH
15798: LD_INT 2
15800: PUSH
15801: EMPTY
15802: LIST
15803: LIST
15804: PUSH
15805: EMPTY
15806: LIST
15807: LIST
15808: PPUSH
15809: CALL_OW 69
15813: PPUSH
15814: LD_INT 1
15816: PPUSH
15817: CALL 10662 0 1
15821: PUSH
15822: LD_INT 1
15824: ARRAY
15825: PPUSH
15826: CALL_OW 74
15830: PPUSH
15831: LD_INT 1
15833: PPUSH
15834: CALL 10662 0 1
15838: PUSH
15839: LD_INT 1
15841: ARRAY
15842: PPUSH
15843: CALL_OW 296
15847: PUSH
15848: LD_INT 7
15850: LESS
15851: IFFALSE 15778
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15853: LD_INT 1
15855: PPUSH
15856: CALL 10662 0 1
15860: PUSH
15861: LD_INT 1
15863: ARRAY
15864: PPUSH
15865: LD_STRING DR-A-1
15867: PPUSH
15868: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15872: LD_INT 1
15874: PPUSH
15875: CALL 10662 0 1
15879: PUSH
15880: LD_INT 2
15882: ARRAY
15883: PPUSH
15884: LD_STRING DR-B-1
15886: PPUSH
15887: CALL_OW 88
// Wait ( 3 3$00 ) ;
15891: LD_INT 6300
15893: PPUSH
15894: CALL_OW 67
// ru_spotted := true ;
15898: LD_ADDR_EXP 15
15902: PUSH
15903: LD_INT 1
15905: ST_TO_ADDR
// end ;
15906: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15907: LD_INT 35
15909: PPUSH
15910: CALL_OW 300
15914: NOT
15915: IFFALSE 15939
15917: GO 15919
15919: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15920: LD_INT 1
15922: PPUSH
15923: CALL 10662 0 1
15927: PUSH
15928: LD_INT 1
15930: ARRAY
15931: PPUSH
15932: LD_STRING DDR-A-1
15934: PPUSH
15935: CALL_OW 88
15939: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15940: LD_INT 1
15942: PPUSH
15943: LD_INT 30
15945: PPUSH
15946: CALL 6770 0 2
15950: IFFALSE 16032
15952: GO 15954
15954: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15955: LD_INT 35
15957: PPUSH
15958: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15962: LD_INT 1
15964: PPUSH
15965: LD_INT 30
15967: PPUSH
15968: CALL 6770 0 2
15972: PUSH
15973: LD_INT 1
15975: ARRAY
15976: PPUSH
15977: CALL_OW 461
15981: PUSH
15982: LD_INT 1
15984: NONEQUAL
15985: IFFALSE 15955
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15987: LD_INT 1
15989: PPUSH
15990: CALL 10662 0 1
15994: PUSH
15995: LD_INT 1
15997: ARRAY
15998: PPUSH
15999: LD_STRING D8-A-1
16001: PPUSH
16002: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
16006: LD_INT 1
16008: PPUSH
16009: CALL 10662 0 1
16013: PUSH
16014: LD_INT 2
16016: ARRAY
16017: PPUSH
16018: LD_STRING D8-B-1
16020: PPUSH
16021: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
16025: LD_STRING M_mineok
16027: PPUSH
16028: CALL_OW 337
// end ;
16032: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
16033: LD_INT 22
16035: PUSH
16036: LD_INT 1
16038: PUSH
16039: EMPTY
16040: LIST
16041: LIST
16042: PUSH
16043: LD_INT 30
16045: PUSH
16046: LD_INT 0
16048: PUSH
16049: EMPTY
16050: LIST
16051: LIST
16052: PUSH
16053: LD_INT 3
16055: PUSH
16056: LD_INT 57
16058: PUSH
16059: EMPTY
16060: LIST
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: LIST
16070: PPUSH
16071: CALL_OW 69
16075: PUSH
16076: LD_INT 1
16078: GREATER
16079: PUSH
16080: LD_INT 22
16082: PUSH
16083: LD_INT 1
16085: PUSH
16086: EMPTY
16087: LIST
16088: LIST
16089: PUSH
16090: LD_INT 30
16092: PUSH
16093: LD_INT 0
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: PUSH
16100: LD_INT 3
16102: PUSH
16103: LD_INT 57
16105: PUSH
16106: EMPTY
16107: LIST
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: LIST
16117: PPUSH
16118: CALL_OW 69
16122: PUSH
16123: LD_INT 1
16125: EQUAL
16126: PUSH
16127: LD_INT 35
16129: PPUSH
16130: CALL_OW 300
16134: NOT
16135: AND
16136: OR
16137: IFFALSE 16189
16139: GO 16141
16141: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
16142: LD_INT 22
16144: PUSH
16145: LD_INT 1
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: PUSH
16152: LD_INT 25
16154: PUSH
16155: LD_INT 2
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PPUSH
16166: CALL_OW 69
16170: PUSH
16171: LD_INT 1
16173: ARRAY
16174: PPUSH
16175: LD_STRING D7-A-1
16177: PPUSH
16178: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
16182: LD_STRING M_baseok
16184: PPUSH
16185: CALL_OW 337
// end ;
16189: END
// every 0 0$01 trigger mine_ck do
16190: LD_EXP 34
16194: IFFALSE 16225
16196: GO 16198
16198: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
16199: LD_INT 1
16201: PPUSH
16202: CALL 10662 0 1
16206: PUSH
16207: LD_INT 1
16209: ARRAY
16210: PPUSH
16211: LD_STRING D9-A-1
16213: PPUSH
16214: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
16218: LD_STRING M_minedest
16220: PPUSH
16221: CALL_OW 337
// end ;
16225: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
16226: LD_EXP 28
16230: IFFALSE 16736
16232: GO 16234
16234: DISABLE
16235: LD_INT 0
16237: PPUSH
16238: PPUSH
16239: PPUSH
16240: PPUSH
16241: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
16242: LD_OWVAR 67
16246: PPUSH
16247: CALL 12563 0 1
// if not helps_can_arrive then
16251: LD_EXP 30
16255: NOT
16256: IFFALSE 16284
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
16258: LD_EXP 39
16262: PUSH
16263: LD_INT 1
16265: ARRAY
16266: PPUSH
16267: LD_STRING DB-Delay
16269: PPUSH
16270: CALL_OW 94
// time := 10 10$00 ;
16274: LD_ADDR_VAR 0 1
16278: PUSH
16279: LD_INT 21000
16281: ST_TO_ADDR
// end else
16282: GO 16292
// time := 3 3$00 ;
16284: LD_ADDR_VAR 0 1
16288: PUSH
16289: LD_INT 6300
16291: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
16292: LD_ADDR_VAR 0 1
16296: PUSH
16297: LD_VAR 0 1
16301: PUSH
16302: LD_INT 35
16304: MINUS
16305: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
16306: LD_INT 35
16308: PPUSH
16309: CALL_OW 67
// end until time = 0 0$00 ;
16313: LD_VAR 0 1
16317: PUSH
16318: LD_INT 0
16320: EQUAL
16321: IFFALSE 16292
// helps_arrive := true ;
16323: LD_ADDR_EXP 29
16327: PUSH
16328: LD_INT 1
16330: ST_TO_ADDR
// if IsLive ( guyA ) then
16331: LD_EXP 37
16335: PPUSH
16336: CALL_OW 300
16340: IFFALSE 16354
// r := guyA else
16342: LD_ADDR_VAR 0 4
16346: PUSH
16347: LD_EXP 37
16351: ST_TO_ADDR
16352: GO 16364
// r := guyB ;
16354: LD_ADDR_VAR 0 4
16358: PUSH
16359: LD_EXP 38
16363: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
16364: LD_EXP 39
16368: PUSH
16369: LD_INT 1
16371: ARRAY
16372: PPUSH
16373: LD_STRING D2-A-1
16375: PPUSH
16376: CALL_OW 94
// Say ( r , D2-B-1 ) ;
16380: LD_VAR 0 4
16384: PPUSH
16385: LD_STRING D2-B-1
16387: PPUSH
16388: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
16392: LD_EXP 39
16396: PUSH
16397: LD_INT 1
16399: ARRAY
16400: PPUSH
16401: LD_STRING D2-A-2
16403: PPUSH
16404: CALL_OW 94
// Say ( r , D2-B-2 ) ;
16408: LD_VAR 0 4
16412: PPUSH
16413: LD_STRING D2-B-2
16415: PPUSH
16416: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
16420: LD_EXP 39
16424: PUSH
16425: LD_INT 1
16427: ARRAY
16428: PPUSH
16429: LD_STRING D2-A-3
16431: PPUSH
16432: CALL_OW 94
// Say ( r , D2-B-3 ) ;
16436: LD_VAR 0 4
16440: PPUSH
16441: LD_STRING D2-B-3
16443: PPUSH
16444: CALL_OW 88
// to_veh := [ ] ;
16448: LD_ADDR_VAR 0 5
16452: PUSH
16453: EMPTY
16454: ST_TO_ADDR
// for i = 1 to Beta_Squad do
16455: LD_ADDR_VAR 0 2
16459: PUSH
16460: DOUBLE
16461: LD_INT 1
16463: DEC
16464: ST_TO_ADDR
16465: LD_EXP 39
16469: PUSH
16470: FOR_TO
16471: IFFALSE 16734
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
16473: LD_EXP 39
16477: PUSH
16478: LD_VAR 0 2
16482: ARRAY
16483: PPUSH
16484: CALL_OW 110
16488: PUSH
16489: LD_INT 3
16491: EQUAL
16492: IFFALSE 16518
// to_veh := to_veh ^ Beta_Squad [ i ] else
16494: LD_ADDR_VAR 0 5
16498: PUSH
16499: LD_VAR 0 5
16503: PUSH
16504: LD_EXP 39
16508: PUSH
16509: LD_VAR 0 2
16513: ARRAY
16514: ADD
16515: ST_TO_ADDR
16516: GO 16643
// if GetTag ( Beta_Squad [ i ] ) = 5 then
16518: LD_EXP 39
16522: PUSH
16523: LD_VAR 0 2
16527: ARRAY
16528: PPUSH
16529: CALL_OW 110
16533: PUSH
16534: LD_INT 5
16536: EQUAL
16537: IFFALSE 16622
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
16539: LD_EXP 39
16543: PUSH
16544: LD_VAR 0 2
16548: ARRAY
16549: PPUSH
16550: LD_INT 4
16552: PPUSH
16553: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16557: LD_EXP 39
16561: PUSH
16562: LD_VAR 0 2
16566: ARRAY
16567: PPUSH
16568: LD_INT 5
16570: PPUSH
16571: LD_INT 0
16573: PPUSH
16574: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
16578: LD_VAR 0 5
16582: PUSH
16583: LD_INT 1
16585: ARRAY
16586: PPUSH
16587: LD_EXP 39
16591: PUSH
16592: LD_VAR 0 2
16596: ARRAY
16597: PPUSH
16598: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16602: LD_ADDR_VAR 0 5
16606: PUSH
16607: LD_VAR 0 5
16611: PPUSH
16612: LD_INT 1
16614: PPUSH
16615: CALL_OW 3
16619: ST_TO_ADDR
// end else
16620: GO 16643
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16622: LD_EXP 39
16626: PUSH
16627: LD_VAR 0 2
16631: ARRAY
16632: PPUSH
16633: LD_INT 5
16635: PPUSH
16636: LD_INT 0
16638: PPUSH
16639: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16643: LD_EXP 39
16647: PUSH
16648: LD_VAR 0 2
16652: ARRAY
16653: PPUSH
16654: LD_INT 165
16656: PPUSH
16657: LD_INT 105
16659: PPUSH
16660: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16664: LD_INT 70
16666: PPUSH
16667: LD_INT 140
16669: PPUSH
16670: CALL_OW 12
16674: PPUSH
16675: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16679: LD_EXP 39
16683: PUSH
16684: LD_VAR 0 2
16688: ARRAY
16689: PPUSH
16690: LD_INT 1
16692: PPUSH
16693: CALL_OW 235
// if i = 1 then
16697: LD_VAR 0 2
16701: PUSH
16702: LD_INT 1
16704: EQUAL
16705: IFFALSE 16717
// CenterNowOnXY ( 168 , 109 ) ;
16707: LD_INT 168
16709: PPUSH
16710: LD_INT 109
16712: PPUSH
16713: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16717: LD_EXP 39
16721: PUSH
16722: LD_VAR 0 2
16726: ARRAY
16727: PPUSH
16728: CALL_OW 141
// end ;
16732: GO 16470
16734: POP
16735: POP
// end ;
16736: PPOPN 5
16738: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16739: LD_EXP 29
16743: IFFALSE 17772
16745: GO 16747
16747: DISABLE
16748: LD_INT 0
16750: PPUSH
16751: PPUSH
// begin Wait ( 5 5$00 ) ;
16752: LD_INT 10500
16754: PPUSH
16755: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16759: LD_OWVAR 67
16763: PPUSH
16764: CALL 13252 0 1
// to_veh := [ ] ;
16768: LD_ADDR_VAR 0 2
16772: PUSH
16773: EMPTY
16774: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16775: LD_ADDR_VAR 0 1
16779: PUSH
16780: DOUBLE
16781: LD_INT 1
16783: DEC
16784: ST_TO_ADDR
16785: LD_EXP 40
16789: PUSH
16790: FOR_TO
16791: IFFALSE 17019
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16793: LD_EXP 40
16797: PUSH
16798: LD_VAR 0 1
16802: ARRAY
16803: PPUSH
16804: CALL_OW 110
16808: PUSH
16809: LD_INT 3
16811: EQUAL
16812: IFFALSE 16838
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16814: LD_ADDR_VAR 0 2
16818: PUSH
16819: LD_VAR 0 2
16823: PUSH
16824: LD_EXP 40
16828: PUSH
16829: LD_VAR 0 1
16833: ARRAY
16834: ADD
16835: ST_TO_ADDR
16836: GO 16963
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16838: LD_EXP 40
16842: PUSH
16843: LD_VAR 0 1
16847: ARRAY
16848: PPUSH
16849: CALL_OW 110
16853: PUSH
16854: LD_INT 5
16856: EQUAL
16857: IFFALSE 16942
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16859: LD_EXP 40
16863: PUSH
16864: LD_VAR 0 1
16868: ARRAY
16869: PPUSH
16870: LD_INT 4
16872: PPUSH
16873: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16877: LD_EXP 40
16881: PUSH
16882: LD_VAR 0 1
16886: ARRAY
16887: PPUSH
16888: LD_INT 5
16890: PPUSH
16891: LD_INT 0
16893: PPUSH
16894: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16898: LD_VAR 0 2
16902: PUSH
16903: LD_INT 1
16905: ARRAY
16906: PPUSH
16907: LD_EXP 40
16911: PUSH
16912: LD_VAR 0 1
16916: ARRAY
16917: PPUSH
16918: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16922: LD_ADDR_VAR 0 2
16926: PUSH
16927: LD_VAR 0 2
16931: PPUSH
16932: LD_INT 1
16934: PPUSH
16935: CALL_OW 3
16939: ST_TO_ADDR
// end else
16940: GO 16963
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16942: LD_EXP 40
16946: PUSH
16947: LD_VAR 0 1
16951: ARRAY
16952: PPUSH
16953: LD_INT 5
16955: PPUSH
16956: LD_INT 0
16958: PPUSH
16959: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16963: LD_EXP 40
16967: PUSH
16968: LD_VAR 0 1
16972: ARRAY
16973: PPUSH
16974: LD_INT 164
16976: PPUSH
16977: LD_INT 104
16979: PPUSH
16980: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16984: LD_INT 70
16986: PPUSH
16987: LD_INT 140
16989: PPUSH
16990: CALL_OW 12
16994: PPUSH
16995: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16999: LD_EXP 40
17003: PUSH
17004: LD_VAR 0 1
17008: ARRAY
17009: PPUSH
17010: LD_INT 1
17012: PPUSH
17013: CALL_OW 235
// end ;
17017: GO 16790
17019: POP
17020: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
17021: LD_EXP 40
17025: PUSH
17026: LD_INT 1
17028: ARRAY
17029: PPUSH
17030: LD_STRING D3-A-1
17032: PPUSH
17033: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
17037: LD_INT 1
17039: PPUSH
17040: CALL 10662 0 1
17044: PUSH
17045: LD_INT 1
17047: ARRAY
17048: PPUSH
17049: LD_STRING D3-B-1
17051: PPUSH
17052: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
17056: LD_EXP 40
17060: PUSH
17061: LD_INT 1
17063: ARRAY
17064: PPUSH
17065: LD_STRING D3-A-2
17067: PPUSH
17068: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
17072: LD_INT 1
17074: PPUSH
17075: CALL 10662 0 1
17079: PUSH
17080: LD_INT 1
17082: ARRAY
17083: PPUSH
17084: LD_STRING D3-B-2
17086: PPUSH
17087: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
17091: LD_EXP 40
17095: PUSH
17096: LD_INT 1
17098: ARRAY
17099: PPUSH
17100: LD_STRING D3-A-3
17102: PPUSH
17103: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
17107: LD_INT 1
17109: PPUSH
17110: CALL 10662 0 1
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: PPUSH
17119: LD_STRING D3-B-3
17121: PPUSH
17122: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
17126: LD_EXP 40
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: PPUSH
17135: LD_STRING D3-A-4
17137: PPUSH
17138: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
17142: LD_INT 1
17144: PPUSH
17145: CALL 10662 0 1
17149: PUSH
17150: LD_INT 1
17152: ARRAY
17153: PPUSH
17154: LD_STRING D3-B-4
17156: PPUSH
17157: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
17161: LD_EXP 40
17165: PUSH
17166: LD_INT 1
17168: ARRAY
17169: PPUSH
17170: LD_STRING D3-A-5
17172: PPUSH
17173: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
17177: LD_INT 1
17179: PPUSH
17180: CALL 10662 0 1
17184: PUSH
17185: LD_INT 1
17187: ARRAY
17188: PPUSH
17189: LD_STRING D3-B-5
17191: PPUSH
17192: CALL_OW 88
// for i = 1 to Gamma_Squad do
17196: LD_ADDR_VAR 0 1
17200: PUSH
17201: DOUBLE
17202: LD_INT 1
17204: DEC
17205: ST_TO_ADDR
17206: LD_EXP 40
17210: PUSH
17211: FOR_TO
17212: IFFALSE 17234
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
17214: LD_EXP 40
17218: PUSH
17219: LD_VAR 0 1
17223: ARRAY
17224: PPUSH
17225: LD_INT 1
17227: PPUSH
17228: CALL_OW 235
17232: GO 17211
17234: POP
17235: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
17236: LD_INT 6300
17238: PUSH
17239: LD_INT 10500
17241: PUSH
17242: LD_INT 11550
17244: PUSH
17245: EMPTY
17246: LIST
17247: LIST
17248: LIST
17249: PUSH
17250: LD_OWVAR 67
17254: ARRAY
17255: PPUSH
17256: CALL_OW 67
// AddZetaSquad ;
17260: CALL 13981 0 0
// Wait ( 0 0$10 ) ;
17264: LD_INT 350
17266: PPUSH
17267: CALL_OW 67
// to_veh := [ ] ;
17271: LD_ADDR_VAR 0 2
17275: PUSH
17276: EMPTY
17277: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
17278: LD_ADDR_VAR 0 1
17282: PUSH
17283: DOUBLE
17284: LD_INT 1
17286: DEC
17287: ST_TO_ADDR
17288: LD_EXP 41
17292: PUSH
17293: FOR_TO
17294: IFFALSE 17504
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
17296: LD_EXP 41
17300: PUSH
17301: LD_VAR 0 1
17305: ARRAY
17306: PPUSH
17307: CALL_OW 110
17311: PUSH
17312: LD_INT 3
17314: EQUAL
17315: IFFALSE 17341
// to_veh := to_veh ^ Zeta_Squad [ i ] else
17317: LD_ADDR_VAR 0 2
17321: PUSH
17322: LD_VAR 0 2
17326: PUSH
17327: LD_EXP 41
17331: PUSH
17332: LD_VAR 0 1
17336: ARRAY
17337: ADD
17338: ST_TO_ADDR
17339: GO 17466
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
17341: LD_EXP 41
17345: PUSH
17346: LD_VAR 0 1
17350: ARRAY
17351: PPUSH
17352: CALL_OW 110
17356: PUSH
17357: LD_INT 5
17359: EQUAL
17360: IFFALSE 17445
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
17362: LD_EXP 41
17366: PUSH
17367: LD_VAR 0 1
17371: ARRAY
17372: PPUSH
17373: LD_INT 4
17375: PPUSH
17376: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17380: LD_EXP 41
17384: PUSH
17385: LD_VAR 0 1
17389: ARRAY
17390: PPUSH
17391: LD_INT 5
17393: PPUSH
17394: LD_INT 0
17396: PPUSH
17397: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
17401: LD_VAR 0 2
17405: PUSH
17406: LD_INT 1
17408: ARRAY
17409: PPUSH
17410: LD_EXP 41
17414: PUSH
17415: LD_VAR 0 1
17419: ARRAY
17420: PPUSH
17421: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
17425: LD_ADDR_VAR 0 2
17429: PUSH
17430: LD_VAR 0 2
17434: PPUSH
17435: LD_INT 1
17437: PPUSH
17438: CALL_OW 3
17442: ST_TO_ADDR
// end else
17443: GO 17466
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17445: LD_EXP 41
17449: PUSH
17450: LD_VAR 0 1
17454: ARRAY
17455: PPUSH
17456: LD_INT 5
17458: PPUSH
17459: LD_INT 0
17461: PPUSH
17462: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
17466: LD_EXP 41
17470: PUSH
17471: LD_VAR 0 1
17475: ARRAY
17476: PPUSH
17477: LD_INT 165
17479: PPUSH
17480: LD_INT 105
17482: PPUSH
17483: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
17487: LD_INT 70
17489: PPUSH
17490: LD_INT 140
17492: PPUSH
17493: CALL_OW 12
17497: PPUSH
17498: CALL_OW 67
// end ;
17502: GO 17293
17504: POP
17505: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
17506: LD_EXP 41
17510: PUSH
17511: LD_INT 1
17513: ARRAY
17514: PPUSH
17515: LD_STRING D4-A-1
17517: PPUSH
17518: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
17522: LD_INT 1
17524: PPUSH
17525: CALL 10662 0 1
17529: PUSH
17530: LD_INT 1
17532: ARRAY
17533: PPUSH
17534: LD_STRING D4-B-1
17536: PPUSH
17537: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
17541: LD_EXP 41
17545: PUSH
17546: LD_INT 1
17548: ARRAY
17549: PPUSH
17550: LD_STRING D4-A-2
17552: PPUSH
17553: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
17557: LD_INT 1
17559: PPUSH
17560: CALL 10662 0 1
17564: PUSH
17565: LD_INT 1
17567: ARRAY
17568: PPUSH
17569: LD_STRING D4-B-2
17571: PPUSH
17572: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
17576: LD_EXP 41
17580: PUSH
17581: LD_INT 1
17583: ARRAY
17584: PPUSH
17585: LD_STRING D4-A-3
17587: PPUSH
17588: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
17592: LD_INT 1
17594: PPUSH
17595: CALL 10662 0 1
17599: PUSH
17600: LD_INT 1
17602: ARRAY
17603: PPUSH
17604: LD_STRING D4-B-3
17606: PPUSH
17607: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
17611: LD_EXP 41
17615: PUSH
17616: LD_INT 1
17618: ARRAY
17619: PPUSH
17620: LD_STRING D4-A-4
17622: PPUSH
17623: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17627: LD_INT 1
17629: PPUSH
17630: CALL 10662 0 1
17634: PUSH
17635: LD_INT 1
17637: ARRAY
17638: PPUSH
17639: LD_STRING D4-B-4
17641: PPUSH
17642: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17646: LD_EXP 41
17650: PUSH
17651: LD_INT 1
17653: ARRAY
17654: PPUSH
17655: LD_STRING D4-A-5
17657: PPUSH
17658: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17662: LD_INT 1
17664: PPUSH
17665: CALL 10662 0 1
17669: PUSH
17670: LD_INT 1
17672: ARRAY
17673: PPUSH
17674: LD_STRING D4-B-5
17676: PPUSH
17677: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17681: LD_EXP 41
17685: PUSH
17686: LD_INT 1
17688: ARRAY
17689: PPUSH
17690: LD_STRING D4-A-6
17692: PPUSH
17693: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17697: LD_INT 1
17699: PPUSH
17700: CALL 10662 0 1
17704: PUSH
17705: LD_INT 1
17707: ARRAY
17708: PPUSH
17709: LD_STRING D4-B-6
17711: PPUSH
17712: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17716: LD_EXP 41
17720: PUSH
17721: LD_INT 1
17723: ARRAY
17724: PPUSH
17725: LD_STRING D4-A-7
17727: PPUSH
17728: CALL_OW 94
// for i = 1 to Zeta_Squad do
17732: LD_ADDR_VAR 0 1
17736: PUSH
17737: DOUBLE
17738: LD_INT 1
17740: DEC
17741: ST_TO_ADDR
17742: LD_EXP 41
17746: PUSH
17747: FOR_TO
17748: IFFALSE 17770
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17750: LD_EXP 41
17754: PUSH
17755: LD_VAR 0 1
17759: ARRAY
17760: PPUSH
17761: LD_INT 1
17763: PPUSH
17764: CALL_OW 235
17768: GO 17747
17770: POP
17771: POP
// end ;
17772: PPOPN 2
17774: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17775: LD_INT 11
17777: PPUSH
17778: LD_INT 22
17780: PUSH
17781: LD_OWVAR 2
17785: PUSH
17786: EMPTY
17787: LIST
17788: LIST
17789: PPUSH
17790: CALL_OW 70
17794: PUSH
17795: LD_INT 0
17797: GREATER
17798: IFFALSE 17823
17800: GO 17802
17802: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17803: LD_EXP 37
17807: PPUSH
17808: LD_STRING D10-A-1
17810: PPUSH
17811: CALL_OW 88
// ru_spotted := true ;
17815: LD_ADDR_EXP 15
17819: PUSH
17820: LD_INT 1
17822: ST_TO_ADDR
// end ;
17823: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17824: LD_EXP 37
17828: PPUSH
17829: CALL_OW 301
17833: PUSH
17834: LD_EXP 38
17838: PPUSH
17839: CALL_OW 301
17843: OR
17844: IFFALSE 17856
17846: GO 17848
17848: DISABLE
// begin YouLost ( DieP ) ;
17849: LD_STRING DieP
17851: PPUSH
17852: CALL_OW 104
// end ;
17856: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17857: LD_INT 34
17859: PUSH
17860: LD_INT 8
17862: PUSH
17863: EMPTY
17864: LIST
17865: LIST
17866: PPUSH
17867: CALL_OW 69
17871: IFFALSE 17884
17873: GO 17875
17875: DISABLE
// sib_bomb_constructed := true ;
17876: LD_ADDR_EXP 35
17880: PUSH
17881: LD_INT 1
17883: ST_TO_ADDR
17884: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17885: LD_EXP 28
17889: PUSH
17890: LD_INT 22
17892: PUSH
17893: LD_INT 3
17895: PUSH
17896: EMPTY
17897: LIST
17898: LIST
17899: PPUSH
17900: CALL_OW 69
17904: PUSH
17905: LD_INT 0
17907: EQUAL
17908: AND
17909: IFFALSE 18081
17911: GO 17913
17913: DISABLE
17914: LD_INT 0
17916: PPUSH
// begin game_status := false ;
17917: LD_ADDR_EXP 28
17921: PUSH
17922: LD_INT 0
17924: ST_TO_ADDR
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17925: LD_OWVAR 1
17929: PUSH
17930: LD_INT 35
17932: DIVREAL
17933: PUSH
17934: LD_INT 60
17936: DIVREAL
17937: PUSH
17938: LD_INT 70
17940: PUSH
17941: LD_INT 60
17943: PUSH
17944: LD_INT 50
17946: PUSH
17947: EMPTY
17948: LIST
17949: LIST
17950: LIST
17951: PUSH
17952: LD_OWVAR 67
17956: ARRAY
17957: LESS
17958: IFFALSE 17972
// AddMedal ( play , 1 ) else
17960: LD_STRING play
17962: PPUSH
17963: LD_INT 1
17965: PPUSH
17966: CALL_OW 101
17970: GO 17983
// AddMedal ( play , - 1 ) ;
17972: LD_STRING play
17974: PPUSH
17975: LD_INT 1
17977: NEG
17978: PPUSH
17979: CALL_OW 101
// if sib_bomb_constructed then
17983: LD_EXP 35
17987: IFFALSE 18001
// AddMedal ( sibbomb , 1 ) else
17989: LD_STRING sibbomb
17991: PPUSH
17992: LD_INT 1
17994: PPUSH
17995: CALL_OW 101
17999: GO 18012
// AddMedal ( sibbomb , - 1 ) ;
18001: LD_STRING sibbomb
18003: PPUSH
18004: LD_INT 1
18006: NEG
18007: PPUSH
18008: CALL_OW 101
// if mine_constructed and not mine_ck then
18012: LD_EXP 36
18016: PUSH
18017: LD_EXP 34
18021: NOT
18022: AND
18023: IFFALSE 18035
// AddMedal ( mine , 1 ) ;
18025: LD_STRING mine
18027: PPUSH
18028: LD_INT 1
18030: PPUSH
18031: CALL_OW 101
// if mine_ck then
18035: LD_EXP 34
18039: IFFALSE 18052
// AddMedal ( mine , - 1 ) ;
18041: LD_STRING mine
18043: PPUSH
18044: LD_INT 1
18046: NEG
18047: PPUSH
18048: CALL_OW 101
// if not mine_constructed then
18052: LD_EXP 36
18056: NOT
18057: IFFALSE 18070
// AddMedal ( mine , - 2 ) ;
18059: LD_STRING mine
18061: PPUSH
18062: LD_INT 2
18064: NEG
18065: PPUSH
18066: CALL_OW 101
// GiveMedals ( Main ) ;
18070: LD_STRING Main
18072: PPUSH
18073: CALL_OW 102
// YouWin ;
18077: CALL_OW 103
// end ; end_of_file
18081: PPOPN 1
18083: END
// every 0 0$03 trigger game_status do var time ;
18084: LD_EXP 28
18088: IFFALSE 18253
18090: GO 18092
18092: DISABLE
18093: LD_INT 0
18095: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
18096: LD_ADDR_VAR 0 1
18100: PUSH
18101: LD_INT 1050
18103: PUSH
18104: LD_INT 1575
18106: PUSH
18107: LD_INT 2100
18109: PUSH
18110: EMPTY
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: LD_OWVAR 67
18119: ARRAY
18120: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
18121: LD_VAR 0 1
18125: PUSH
18126: LD_INT 0
18128: PPUSH
18129: LD_INT 420
18131: PPUSH
18132: CALL_OW 12
18136: PLUS
18137: PPUSH
18138: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
18142: LD_INT 1
18144: PPUSH
18145: LD_INT 5
18147: PPUSH
18148: CALL_OW 12
18152: PPUSH
18153: LD_INT 1
18155: PPUSH
18156: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
18160: LD_INT 105
18162: PPUSH
18163: LD_INT 1050
18165: PPUSH
18166: CALL_OW 12
18170: PPUSH
18171: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
18175: LD_INT 1
18177: PPUSH
18178: LD_INT 5
18180: PPUSH
18181: CALL_OW 12
18185: PPUSH
18186: LD_INT 148
18188: PPUSH
18189: LD_INT 107
18191: PPUSH
18192: LD_INT 20
18194: PPUSH
18195: LD_INT 1
18197: PPUSH
18198: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
18202: LD_OWVAR 1
18206: PUSH
18207: LD_INT 44100
18209: PUSH
18210: LD_INT 37800
18212: PUSH
18213: LD_INT 33600
18215: PUSH
18216: EMPTY
18217: LIST
18218: LIST
18219: LIST
18220: PUSH
18221: LD_OWVAR 67
18225: ARRAY
18226: MOD
18227: IFFALSE 18243
// time := time + 0 0$20 ;
18229: LD_ADDR_VAR 0 1
18233: PUSH
18234: LD_VAR 0 1
18238: PUSH
18239: LD_INT 700
18241: PLUS
18242: ST_TO_ADDR
// end until game_status = false ;
18243: LD_EXP 28
18247: PUSH
18248: LD_INT 0
18250: EQUAL
18251: IFFALSE 18121
// end ;
18253: PPOPN 1
18255: END
// every 0 0$03 trigger game_status do var time ;
18256: LD_EXP 28
18260: IFFALSE 18414
18262: GO 18264
18264: DISABLE
18265: LD_INT 0
18267: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
18268: LD_ADDR_VAR 0 1
18272: PUSH
18273: LD_INT 700
18275: PUSH
18276: LD_INT 875
18278: PUSH
18279: LD_INT 1400
18281: PUSH
18282: EMPTY
18283: LIST
18284: LIST
18285: LIST
18286: PUSH
18287: LD_OWVAR 67
18291: ARRAY
18292: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18293: LD_VAR 0 1
18297: PUSH
18298: LD_INT 0
18300: PPUSH
18301: LD_INT 385
18303: PPUSH
18304: CALL_OW 12
18308: PLUS
18309: PPUSH
18310: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
18314: LD_INT 1
18316: PPUSH
18317: LD_INT 5
18319: PPUSH
18320: CALL_OW 12
18324: PPUSH
18325: LD_INT 102
18327: PPUSH
18328: LD_INT 6
18330: PPUSH
18331: LD_INT 25
18333: PPUSH
18334: LD_INT 1
18336: PPUSH
18337: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
18341: LD_OWVAR 1
18345: PUSH
18346: LD_INT 52500
18348: PUSH
18349: LD_INT 46200
18351: PUSH
18352: LD_INT 42000
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: LIST
18359: PUSH
18360: LD_OWVAR 67
18364: ARRAY
18365: MOD
18366: IFFALSE 18382
// time := time + 0 0$25 ;
18368: LD_ADDR_VAR 0 1
18372: PUSH
18373: LD_VAR 0 1
18377: PUSH
18378: LD_INT 875
18380: PLUS
18381: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
18382: LD_OWVAR 1
18386: PUSH
18387: LD_INT 231000
18389: MOD
18390: PUSH
18391: LD_INT 0
18393: EQUAL
18394: IFFALSE 18404
// time := 0 0$30 ;
18396: LD_ADDR_VAR 0 1
18400: PUSH
18401: LD_INT 1050
18403: ST_TO_ADDR
// end until game_status = false ;
18404: LD_EXP 28
18408: PUSH
18409: LD_INT 0
18411: EQUAL
18412: IFFALSE 18293
// end ;
18414: PPOPN 1
18416: END
// every 0 0$03 trigger game_status do var time ;
18417: LD_EXP 28
18421: IFFALSE 18557
18423: GO 18425
18425: DISABLE
18426: LD_INT 0
18428: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
18429: LD_ADDR_VAR 0 1
18433: PUSH
18434: LD_INT 1050
18436: PUSH
18437: LD_INT 1575
18439: PUSH
18440: LD_INT 1750
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: LIST
18447: PUSH
18448: LD_OWVAR 67
18452: ARRAY
18453: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18454: LD_VAR 0 1
18458: PUSH
18459: LD_INT 0
18461: PPUSH
18462: LD_INT 385
18464: PPUSH
18465: CALL_OW 12
18469: PLUS
18470: PPUSH
18471: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
18475: LD_INT 1
18477: PPUSH
18478: LD_INT 5
18480: PPUSH
18481: CALL_OW 12
18485: PPUSH
18486: LD_INT 51
18488: PPUSH
18489: LD_INT 74
18491: PPUSH
18492: LD_INT 25
18494: PPUSH
18495: LD_INT 1
18497: PPUSH
18498: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
18502: LD_OWVAR 1
18506: PUSH
18507: LD_INT 84000
18509: PUSH
18510: LD_INT 105000
18512: PUSH
18513: LD_INT 136500
18515: PUSH
18516: EMPTY
18517: LIST
18518: LIST
18519: LIST
18520: PUSH
18521: LD_OWVAR 67
18525: ARRAY
18526: MOD
18527: PUSH
18528: LD_INT 0
18530: EQUAL
18531: IFFALSE 18547
// time := time + 0 0$15 ;
18533: LD_ADDR_VAR 0 1
18537: PUSH
18538: LD_VAR 0 1
18542: PUSH
18543: LD_INT 525
18545: PLUS
18546: ST_TO_ADDR
// end until game_status = false ;
18547: LD_EXP 28
18551: PUSH
18552: LD_INT 0
18554: EQUAL
18555: IFFALSE 18454
// end ; end_of_file
18557: PPOPN 1
18559: END
// every 0 0$01 trigger not debug do
18560: LD_EXP 1
18564: NOT
18565: IFFALSE 18588
18567: GO 18569
18569: DISABLE
// begin enable ;
18570: ENABLE
// Display_Strings := [ #tick , tick ] ;
18571: LD_ADDR_OWVAR 47
18575: PUSH
18576: LD_STRING #tick
18578: PUSH
18579: LD_OWVAR 1
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: ST_TO_ADDR
// end ;
18588: END
