// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// debug := 0 ;
  21: LD_ADDR_EXP 1
  25: PUSH
  26: LD_INT 0
  28: ST_TO_ADDR
// if debug then
  29: LD_EXP 1
  33: IFFALSE 55
// begin display_strings := Debug mode active! ;
  35: LD_ADDR_OWVAR 47
  39: PUSH
  40: LD_STRING Debug mode active!
  42: ST_TO_ADDR
// Your_Side := 1 ;
  43: LD_ADDR_OWVAR 2
  47: PUSH
  48: LD_INT 1
  50: ST_TO_ADDR
// TurnFogOff ;
  51: CALL_OW 537
// end ; Difficulty := GetMultiplayerSetting ( 0 ) ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 426
  67: ST_TO_ADDR
// if not Difficulty then
  68: LD_OWVAR 67
  72: NOT
  73: IFFALSE 83
// Difficulty := 2 ;
  75: LD_ADDR_OWVAR 67
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// depotConstructed := false ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// PrepareTigers ( tiger_area ) ;
  91: LD_INT 8
  93: PPUSH
  94: CALL 10150 0 1
// PrepareApemans ( apeman_area ) ;
  98: LD_INT 9
 100: PPUSH
 101: CALL 10280 0 1
// PrepareRussian ;
 105: CALL 125 0 0
// PrepareAmerican ;
 109: CALL 11687 0 0
// if not debug then
 113: LD_EXP 1
 117: NOT
 118: IFFALSE 124
// Action ;
 120: CALL 13916 0 0
// end ;
 124: END
// export debug , depotConstructed ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 125: LD_INT 0
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// uc_side := 3 ;
 131: LD_ADDR_OWVAR 20
 135: PUSH
 136: LD_INT 3
 138: ST_TO_ADDR
// uc_nation := nation_russian ;
 139: LD_ADDR_OWVAR 21
 143: PUSH
 144: LD_INT 3
 146: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 147: LD_ADDR_VAR 0 2
 151: PUSH
 152: LD_INT 6
 154: PUSH
 155: LD_INT 7
 157: PUSH
 158: LD_INT 8
 160: PUSH
 161: EMPTY
 162: LIST
 163: LIST
 164: LIST
 165: PUSH
 166: LD_OWVAR 67
 170: ARRAY
 171: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 172: LD_INT 2
 174: PPUSH
 175: CALL_OW 274
 179: PPUSH
 180: LD_INT 1
 182: PPUSH
 183: LD_INT 1200
 185: PPUSH
 186: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 190: LD_INT 2
 192: PPUSH
 193: CALL_OW 274
 197: PPUSH
 198: LD_INT 2
 200: PPUSH
 201: LD_INT 600
 203: PPUSH
 204: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 208: LD_INT 33
 210: PPUSH
 211: LD_INT 4
 213: PPUSH
 214: LD_INT 3
 216: PPUSH
 217: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 221: LD_INT 37
 223: PPUSH
 224: LD_INT 3
 226: PPUSH
 227: LD_INT 3
 229: PPUSH
 230: CALL_OW 441
// ru_force := [ ] ;
 234: LD_ADDR_EXP 3
 238: PUSH
 239: EMPTY
 240: ST_TO_ADDR
// ru_group1 := [ ] ;
 241: LD_ADDR_EXP 4
 245: PUSH
 246: EMPTY
 247: ST_TO_ADDR
// ru_group2 := [ ] ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// ru_reserve := [ ] ;
 255: LD_ADDR_EXP 9
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// ru_attack_list := [ ] ;
 262: LD_ADDR_EXP 10
 266: PUSH
 267: EMPTY
 268: ST_TO_ADDR
// ru_protector := [ ] ;
 269: LD_ADDR_EXP 17
 273: PUSH
 274: EMPTY
 275: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 276: LD_ADDR_EXP 6
 280: PUSH
 281: LD_INT 48
 283: PUSH
 284: LD_INT 49
 286: PUSH
 287: LD_INT 50
 289: PUSH
 290: LD_INT 20
 292: PUSH
 293: LD_INT 1
 295: PUSH
 296: LD_INT 51
 298: PUSH
 299: LD_INT 52
 301: PUSH
 302: LD_INT 69
 304: PUSH
 305: LD_INT 39
 307: PUSH
 308: LD_INT 34
 310: PUSH
 311: LD_INT 40
 313: PUSH
 314: LD_INT 53
 316: PUSH
 317: LD_INT 71
 319: PUSH
 320: LD_INT 57
 322: PUSH
 323: LD_INT 58
 325: PUSH
 326: LD_INT 44
 328: PUSH
 329: LD_INT 32
 331: PUSH
 332: LD_INT 27
 334: PUSH
 335: LD_INT 23
 337: PUSH
 338: LD_INT 33
 340: PUSH
 341: LD_INT 59
 343: PUSH
 344: LD_INT 54
 346: PUSH
 347: LD_INT 55
 349: PUSH
 350: LD_INT 56
 352: PUSH
 353: LD_INT 63
 355: PUSH
 356: LD_INT 64
 358: PUSH
 359: LD_INT 65
 361: PUSH
 362: LD_INT 30
 364: PUSH
 365: LD_INT 31
 367: PUSH
 368: LD_INT 21
 370: PUSH
 371: LD_INT 22
 373: PUSH
 374: LD_INT 25
 376: PUSH
 377: EMPTY
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: LIST
 407: LIST
 408: LIST
 409: LIST
 410: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 411: LD_ADDR_EXP 7
 415: PUSH
 416: LD_INT 3
 418: PPUSH
 419: LD_INT 33
 421: PPUSH
 422: CALL 8265 0 2
 426: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 427: LD_ADDR_EXP 8
 431: PUSH
 432: LD_INT 46
 434: PUSH
 435: LD_INT 45
 437: PUSH
 438: LD_INT 47
 440: PUSH
 441: EMPTY
 442: LIST
 443: LIST
 444: LIST
 445: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 446: LD_ADDR_EXP 13
 450: PUSH
 451: LD_INT 33
 453: PUSH
 454: LD_INT 36
 456: PUSH
 457: LD_INT 8
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: ST_TO_ADDR
// ru_buildings := [ ] ;
 469: LD_ADDR_EXP 14
 473: PUSH
 474: EMPTY
 475: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 476: LD_ADDR_EXP 11
 480: PUSH
 481: LD_INT 3
 483: PPUSH
 484: CALL 6314 0 1
 488: PUSH
 489: LD_INT 1
 491: ARRAY
 492: PPUSH
 493: CALL_OW 250
 497: PUSH
 498: LD_INT 3
 500: PPUSH
 501: CALL 6314 0 1
 505: PUSH
 506: LD_INT 1
 508: ARRAY
 509: PPUSH
 510: CALL_OW 251
 514: PUSH
 515: LD_INT 3
 517: PPUSH
 518: CALL 6314 0 1
 522: PUSH
 523: LD_INT 1
 525: ARRAY
 526: PPUSH
 527: CALL_OW 254
 531: PUSH
 532: LD_INT 3
 534: PPUSH
 535: CALL 6314 0 1
 539: PUSH
 540: LD_INT 1
 542: ARRAY
 543: PPUSH
 544: LD_INT 1
 546: PPUSH
 547: CALL_OW 268
 551: PUSH
 552: LD_INT 3
 554: PPUSH
 555: CALL 6314 0 1
 559: PUSH
 560: LD_INT 1
 562: ARRAY
 563: PPUSH
 564: LD_INT 2
 566: PPUSH
 567: CALL_OW 268
 571: PUSH
 572: EMPTY
 573: LIST
 574: LIST
 575: LIST
 576: LIST
 577: LIST
 578: PUSH
 579: LD_INT 12
 581: PUSH
 582: LD_INT 13
 584: PUSH
 585: LD_INT 1
 587: PUSH
 588: LD_INT 11
 590: PUSH
 591: LD_INT 14
 593: PUSH
 594: EMPTY
 595: LIST
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: ST_TO_ADDR
// ru_heal_list := [ ] ;
 605: LD_ADDR_EXP 12
 609: PUSH
 610: EMPTY
 611: ST_TO_ADDR
// need_buldozer := false ;
 612: LD_ADDR_EXP 18
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// need_crane := true ;
 620: LD_ADDR_EXP 19
 624: PUSH
 625: LD_INT 1
 627: ST_TO_ADDR
// ru_spotted := false ;
 628: LD_ADDR_EXP 16
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// for i = 1 to 6 do
 636: LD_ADDR_VAR 0 3
 640: PUSH
 641: DOUBLE
 642: LD_INT 1
 644: DEC
 645: ST_TO_ADDR
 646: LD_INT 6
 648: PUSH
 649: FOR_TO
 650: IFFALSE 691
// begin PrepareHuman ( false , 4 , skill ) ;
 652: LD_INT 0
 654: PPUSH
 655: LD_INT 4
 657: PPUSH
 658: LD_VAR 0 2
 662: PPUSH
 663: CALL_OW 380
// un := CreateHuman ;
 667: LD_ADDR_VAR 0 4
 671: PUSH
 672: CALL_OW 44
 676: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 677: LD_VAR 0 4
 681: PPUSH
 682: LD_INT 3
 684: PPUSH
 685: CALL_OW 52
// end ;
 689: GO 649
 691: POP
 692: POP
// for i = 1 to 6 do
 693: LD_ADDR_VAR 0 3
 697: PUSH
 698: DOUBLE
 699: LD_INT 1
 701: DEC
 702: ST_TO_ADDR
 703: LD_INT 6
 705: PUSH
 706: FOR_TO
 707: IFFALSE 748
// begin PrepareHuman ( false , 3 , skill ) ;
 709: LD_INT 0
 711: PPUSH
 712: LD_INT 3
 714: PPUSH
 715: LD_VAR 0 2
 719: PPUSH
 720: CALL_OW 380
// un := CreateHuman ;
 724: LD_ADDR_VAR 0 4
 728: PUSH
 729: CALL_OW 44
 733: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 734: LD_VAR 0 4
 738: PPUSH
 739: LD_INT 14
 741: PPUSH
 742: CALL_OW 52
// end ;
 746: GO 706
 748: POP
 749: POP
// for i = 1 to 6 do
 750: LD_ADDR_VAR 0 3
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: LD_INT 6
 762: PUSH
 763: FOR_TO
 764: IFFALSE 808
// begin PrepareHuman ( false , 2 , skill ) ;
 766: LD_INT 0
 768: PPUSH
 769: LD_INT 2
 771: PPUSH
 772: LD_VAR 0 2
 776: PPUSH
 777: CALL_OW 380
// un := CreateHuman ;
 781: LD_ADDR_VAR 0 4
 785: PUSH
 786: CALL_OW 44
 790: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 791: LD_VAR 0 4
 795: PPUSH
 796: LD_INT 1
 798: PPUSH
 799: LD_INT 0
 801: PPUSH
 802: CALL_OW 49
// end ;
 806: GO 763
 808: POP
 809: POP
// for i = 1 to 6 do
 810: LD_ADDR_VAR 0 3
 814: PUSH
 815: DOUBLE
 816: LD_INT 1
 818: DEC
 819: ST_TO_ADDR
 820: LD_INT 6
 822: PUSH
 823: FOR_TO
 824: IFFALSE 902
// begin PrepareHuman ( false , 1 , skill ) ;
 826: LD_INT 0
 828: PPUSH
 829: LD_INT 1
 831: PPUSH
 832: LD_VAR 0 2
 836: PPUSH
 837: CALL_OW 380
// un := CreateHuman ;
 841: LD_ADDR_VAR 0 4
 845: PUSH
 846: CALL_OW 44
 850: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 851: LD_VAR 0 4
 855: PPUSH
 856: LD_INT 1
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 866: LD_VAR 0 4
 870: PPUSH
 871: LD_INT 30
 873: PUSH
 874: LD_INT 5
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: PPUSH
 881: CALL_OW 69
 885: PPUSH
 886: LD_VAR 0 4
 890: PPUSH
 891: CALL_OW 74
 895: PPUSH
 896: CALL_OW 120
// end ;
 900: GO 823
 902: POP
 903: POP
// for i = 1 to Difficulty do
 904: LD_ADDR_VAR 0 3
 908: PUSH
 909: DOUBLE
 910: LD_INT 1
 912: DEC
 913: ST_TO_ADDR
 914: LD_OWVAR 67
 918: PUSH
 919: FOR_TO
 920: IFFALSE 1031
// begin vc_chassis := ru_medium_tracked ;
 922: LD_ADDR_OWVAR 37
 926: PUSH
 927: LD_INT 22
 929: ST_TO_ADDR
// vc_engine := engine_siberite ;
 930: LD_ADDR_OWVAR 39
 934: PUSH
 935: LD_INT 3
 937: ST_TO_ADDR
// vc_control := control_computer ;
 938: LD_ADDR_OWVAR 38
 942: PUSH
 943: LD_INT 3
 945: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 946: LD_ADDR_OWVAR 40
 950: PUSH
 951: LD_INT 43
 953: PUSH
 954: LD_INT 45
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: LD_VAR 0 3
 965: PUSH
 966: LD_INT 2
 968: MOD
 969: PUSH
 970: LD_INT 1
 972: PLUS
 973: ARRAY
 974: ST_TO_ADDR
// un := CreateVehicle ;
 975: LD_ADDR_VAR 0 4
 979: PUSH
 980: CALL_OW 45
 984: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
 985: LD_VAR 0 4
 989: PPUSH
 990: LD_INT 52
 992: PPUSH
 993: LD_INT 42
 995: PPUSH
 996: LD_INT 6
 998: PPUSH
 999: LD_INT 0
1001: PPUSH
1002: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
1006: LD_ADDR_EXP 17
1010: PUSH
1011: LD_EXP 17
1015: PPUSH
1016: LD_INT 1
1018: PPUSH
1019: LD_VAR 0 4
1023: PPUSH
1024: CALL_OW 2
1028: ST_TO_ADDR
// end ;
1029: GO 919
1031: POP
1032: POP
// end ;
1033: LD_VAR 0 1
1037: RET
// every 150 150$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1038: LD_OWVAR 67
1042: PUSH
1043: LD_INT 2
1045: EQUAL
1046: PUSH
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 3
1052: PPUSH
1053: CALL 6163 0 2
1057: AND
1058: IFFALSE 1094
1060: GO 1062
1062: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1063: LD_INT 3
1065: PPUSH
1066: LD_INT 3
1068: PPUSH
1069: CALL 6163 0 2
1073: PUSH
1074: LD_INT 1
1076: ARRAY
1077: PPUSH
1078: LD_INT 24
1080: PPUSH
1081: LD_INT 1
1083: PPUSH
1084: LD_INT 3
1086: PPUSH
1087: LD_INT 48
1089: PPUSH
1090: CALL 8038 0 5
1094: END
// every 120 120$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1095: LD_OWVAR 67
1099: PUSH
1100: LD_INT 3
1102: EQUAL
1103: PUSH
1104: LD_INT 3
1106: PPUSH
1107: LD_INT 3
1109: PPUSH
1110: CALL 6163 0 2
1114: AND
1115: IFFALSE 1151
1117: GO 1119
1119: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1120: LD_INT 3
1122: PPUSH
1123: LD_INT 3
1125: PPUSH
1126: CALL 6163 0 2
1130: PUSH
1131: LD_INT 1
1133: ARRAY
1134: PPUSH
1135: LD_INT 24
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 48
1146: PPUSH
1147: CALL 8038 0 5
1151: END
// every 0 0$01 trigger ru_protector do var i ;
1152: LD_EXP 17
1156: IFFALSE 1327
1158: GO 1160
1160: DISABLE
1161: LD_INT 0
1163: PPUSH
// begin enable ;
1164: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1165: LD_INT 14
1167: PPUSH
1168: LD_INT 81
1170: PUSH
1171: LD_INT 3
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: PPUSH
1178: CALL_OW 70
1182: IFFALSE 1257
// begin for i = 1 to ru_protector do
1184: LD_ADDR_VAR 0 1
1188: PUSH
1189: DOUBLE
1190: LD_INT 1
1192: DEC
1193: ST_TO_ADDR
1194: LD_EXP 17
1198: PUSH
1199: FOR_TO
1200: IFFALSE 1253
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1202: LD_EXP 17
1206: PUSH
1207: LD_VAR 0 1
1211: ARRAY
1212: PPUSH
1213: LD_INT 14
1215: PPUSH
1216: LD_INT 81
1218: PUSH
1219: LD_INT 3
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: PPUSH
1226: CALL_OW 70
1230: PPUSH
1231: LD_EXP 17
1235: PUSH
1236: LD_VAR 0 1
1240: ARRAY
1241: PPUSH
1242: CALL_OW 74
1246: PPUSH
1247: CALL_OW 115
1251: GO 1199
1253: POP
1254: POP
// end else
1255: GO 1327
// for i = 1 to ru_protector do
1257: LD_ADDR_VAR 0 1
1261: PUSH
1262: DOUBLE
1263: LD_INT 1
1265: DEC
1266: ST_TO_ADDR
1267: LD_EXP 17
1271: PUSH
1272: FOR_TO
1273: IFFALSE 1325
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1275: LD_EXP 17
1279: PUSH
1280: LD_VAR 0 1
1284: ARRAY
1285: PPUSH
1286: LD_INT 49
1288: PPUSH
1289: LD_INT 39
1291: PPUSH
1292: CALL_OW 297
1296: PUSH
1297: LD_INT 10
1299: GREATER
1300: IFFALSE 1323
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1302: LD_EXP 17
1306: PUSH
1307: LD_VAR 0 1
1311: ARRAY
1312: PPUSH
1313: LD_INT 49
1315: PPUSH
1316: LD_INT 39
1318: PPUSH
1319: CALL_OW 111
1323: GO 1272
1325: POP
1326: POP
// end ;
1327: PPOPN 1
1329: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1330: LD_OWVAR 1
1334: PUSH
1335: LD_INT 4200
1337: PUSH
1338: LD_INT 2100
1340: PUSH
1341: LD_INT 1050
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: LIST
1348: PUSH
1349: LD_OWVAR 67
1353: ARRAY
1354: GREATER
1355: IFFALSE 1368
1357: GO 1359
1359: DISABLE
// need_buldozer := true ;
1360: LD_ADDR_EXP 18
1364: PUSH
1365: LD_INT 1
1367: ST_TO_ADDR
1368: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1369: GO 1371
1371: DISABLE
// begin enable ;
1372: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1373: LD_ADDR_EXP 20
1377: PUSH
1378: LD_INT 22
1380: PUSH
1381: LD_INT 3
1383: PUSH
1384: EMPTY
1385: LIST
1386: LIST
1387: PUSH
1388: LD_INT 25
1390: PUSH
1391: LD_INT 1
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PPUSH
1402: CALL_OW 69
1406: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1407: LD_ADDR_EXP 21
1411: PUSH
1412: LD_INT 22
1414: PUSH
1415: LD_INT 3
1417: PUSH
1418: EMPTY
1419: LIST
1420: LIST
1421: PUSH
1422: LD_INT 25
1424: PUSH
1425: LD_INT 2
1427: PUSH
1428: EMPTY
1429: LIST
1430: LIST
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: PPUSH
1436: CALL_OW 69
1440: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1441: LD_ADDR_EXP 22
1445: PUSH
1446: LD_INT 22
1448: PUSH
1449: LD_INT 3
1451: PUSH
1452: EMPTY
1453: LIST
1454: LIST
1455: PUSH
1456: LD_INT 25
1458: PUSH
1459: LD_INT 3
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL_OW 69
1474: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1475: LD_ADDR_EXP 23
1479: PUSH
1480: LD_INT 22
1482: PUSH
1483: LD_INT 3
1485: PUSH
1486: EMPTY
1487: LIST
1488: LIST
1489: PUSH
1490: LD_INT 25
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: PPUSH
1504: CALL_OW 69
1508: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1509: LD_ADDR_EXP 24
1513: PUSH
1514: LD_INT 22
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: PUSH
1524: LD_INT 25
1526: PUSH
1527: LD_INT 9
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: PPUSH
1538: CALL_OW 69
1542: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1543: LD_ADDR_EXP 25
1547: PUSH
1548: LD_INT 2
1550: PPUSH
1551: LD_INT 22
1553: PUSH
1554: LD_INT 3
1556: PUSH
1557: EMPTY
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 21
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: PPUSH
1575: CALL_OW 70
1579: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1580: LD_ADDR_EXP 26
1584: PUSH
1585: LD_INT 34
1587: PUSH
1588: LD_INT 53
1590: PUSH
1591: EMPTY
1592: LIST
1593: LIST
1594: PPUSH
1595: CALL_OW 69
1599: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1600: LD_ADDR_EXP 27
1604: PUSH
1605: LD_INT 34
1607: PUSH
1608: LD_INT 52
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: PPUSH
1615: CALL_OW 69
1619: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1620: LD_ADDR_EXP 28
1624: PUSH
1625: LD_INT 34
1627: PUSH
1628: LD_INT 51
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PPUSH
1635: CALL_OW 69
1639: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1640: LD_ADDR_EXP 14
1644: PUSH
1645: LD_INT 3
1647: PPUSH
1648: LD_INT 1
1650: NEG
1651: PPUSH
1652: CALL 10668 0 2
1656: ST_TO_ADDR
// end ;
1657: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1658: LD_INT 22
1660: PUSH
1661: LD_INT 3
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PPUSH
1668: CALL_OW 69
1672: PUSH
1673: LD_EXP 29
1677: AND
1678: PUSH
1679: LD_EXP 1
1683: OR
1684: IFFALSE 5173
1686: GO 1688
1688: DISABLE
1689: LD_INT 0
1691: PPUSH
1692: PPUSH
1693: PPUSH
1694: PPUSH
1695: PPUSH
1696: PPUSH
1697: PPUSH
1698: PPUSH
1699: PPUSH
1700: PPUSH
// begin enable ;
1701: ENABLE
// for i = 1 to ru_eng do
1702: LD_ADDR_VAR 0 1
1706: PUSH
1707: DOUBLE
1708: LD_INT 1
1710: DEC
1711: ST_TO_ADDR
1712: LD_EXP 21
1716: PUSH
1717: FOR_TO
1718: IFFALSE 1781
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1720: LD_EXP 21
1724: PUSH
1725: LD_VAR 0 1
1729: ARRAY
1730: PPUSH
1731: CALL_OW 314
1735: NOT
1736: PUSH
1737: LD_EXP 21
1741: PUSH
1742: LD_VAR 0 1
1746: ARRAY
1747: PPUSH
1748: CALL_OW 310
1752: NOT
1753: AND
1754: IFFALSE 1779
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1756: LD_EXP 21
1760: PUSH
1761: LD_VAR 0 1
1765: ARRAY
1766: PPUSH
1767: LD_INT 3
1769: PPUSH
1770: CALL 6072 0 1
1774: PPUSH
1775: CALL_OW 120
1779: GO 1717
1781: POP
1782: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1783: LD_INT 2
1785: PPUSH
1786: LD_INT 22
1788: PUSH
1789: LD_INT 3
1791: PUSH
1792: EMPTY
1793: LIST
1794: LIST
1795: PUSH
1796: LD_INT 21
1798: PUSH
1799: LD_INT 3
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 3
1808: PUSH
1809: LD_INT 24
1811: PUSH
1812: LD_INT 1000
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: PUSH
1819: EMPTY
1820: LIST
1821: LIST
1822: PUSH
1823: EMPTY
1824: LIST
1825: LIST
1826: LIST
1827: PPUSH
1828: CALL_OW 70
1832: IFFALSE 1999
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1834: LD_ADDR_VAR 0 4
1838: PUSH
1839: LD_INT 2
1841: PPUSH
1842: LD_INT 22
1844: PUSH
1845: LD_INT 3
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: PUSH
1852: LD_INT 21
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: PUSH
1862: LD_INT 3
1864: PUSH
1865: LD_INT 24
1867: PUSH
1868: LD_INT 1000
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: PUSH
1879: EMPTY
1880: LIST
1881: LIST
1882: LIST
1883: PPUSH
1884: CALL_OW 70
1888: ST_TO_ADDR
// for i = 1 to ru_eng do
1889: LD_ADDR_VAR 0 1
1893: PUSH
1894: DOUBLE
1895: LD_INT 1
1897: DEC
1898: ST_TO_ADDR
1899: LD_EXP 21
1903: PUSH
1904: FOR_TO
1905: IFFALSE 1997
// begin if IsInUnit ( ru_eng [ i ] ) then
1907: LD_EXP 21
1911: PUSH
1912: LD_VAR 0 1
1916: ARRAY
1917: PPUSH
1918: CALL_OW 310
1922: IFFALSE 1941
// ComExitBuilding ( ru_eng [ i ] ) else
1924: LD_EXP 21
1928: PUSH
1929: LD_VAR 0 1
1933: ARRAY
1934: PPUSH
1935: CALL_OW 122
1939: GO 1995
// if not WantRepair ( ru_eng [ i ] ) then
1941: LD_EXP 21
1945: PUSH
1946: LD_VAR 0 1
1950: ARRAY
1951: PPUSH
1952: CALL 10594 0 1
1956: NOT
1957: IFFALSE 1995
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1959: LD_EXP 21
1963: PUSH
1964: LD_VAR 0 1
1968: ARRAY
1969: PPUSH
1970: LD_VAR 0 4
1974: PPUSH
1975: LD_EXP 21
1979: PUSH
1980: LD_VAR 0 1
1984: ARRAY
1985: PPUSH
1986: CALL_OW 74
1990: PPUSH
1991: CALL_OW 130
// end ;
1995: GO 1904
1997: POP
1998: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
1999: LD_OWVAR 2
2003: PPUSH
2004: LD_INT 38
2006: PPUSH
2007: LD_INT 26
2009: PPUSH
2010: CALL 5391 0 3
2014: PUSH
2015: LD_INT 0
2017: EQUAL
2018: PUSH
2019: LD_OWVAR 2
2023: PPUSH
2024: LD_INT 29
2026: PPUSH
2027: LD_INT 37
2029: PPUSH
2030: CALL 5391 0 3
2034: PUSH
2035: LD_INT 0
2037: EQUAL
2038: AND
2039: IFFALSE 2176
// begin if ru_blist > 0 then
2041: LD_EXP 13
2045: PUSH
2046: LD_INT 0
2048: GREATER
2049: IFFALSE 2176
// begin for i = 1 to ru_eng do
2051: LD_ADDR_VAR 0 1
2055: PUSH
2056: DOUBLE
2057: LD_INT 1
2059: DEC
2060: ST_TO_ADDR
2061: LD_EXP 21
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2174
// if IsInUnit ( ru_eng [ i ] ) then
2069: LD_EXP 21
2073: PUSH
2074: LD_VAR 0 1
2078: ARRAY
2079: PPUSH
2080: CALL_OW 310
2084: IFFALSE 2103
// ComExitBuilding ( ru_eng [ i ] ) else
2086: LD_EXP 21
2090: PUSH
2091: LD_VAR 0 1
2095: ARRAY
2096: PPUSH
2097: CALL_OW 122
2101: GO 2172
// if not HasTask ( ru_eng [ i ] ) then
2103: LD_EXP 21
2107: PUSH
2108: LD_VAR 0 1
2112: ARRAY
2113: PPUSH
2114: CALL_OW 314
2118: NOT
2119: IFFALSE 2172
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2121: LD_EXP 21
2125: PUSH
2126: LD_VAR 0 1
2130: ARRAY
2131: PPUSH
2132: LD_EXP 13
2136: PUSH
2137: LD_INT 1
2139: ARRAY
2140: PPUSH
2141: LD_EXP 13
2145: PUSH
2146: LD_INT 2
2148: ARRAY
2149: PPUSH
2150: LD_EXP 13
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: PPUSH
2159: LD_EXP 13
2163: PUSH
2164: LD_INT 4
2166: ARRAY
2167: PPUSH
2168: CALL_OW 145
2172: GO 2066
2174: POP
2175: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2176: LD_ADDR_EXP 12
2180: PUSH
2181: LD_INT 3
2183: PPUSH
2184: LD_EXP 12
2188: PPUSH
2189: LD_EXP 15
2193: PPUSH
2194: CALL 9081 0 3
2198: ST_TO_ADDR
// if debug then
2199: LD_EXP 1
2203: IFFALSE 2215
// display_strings := ru_heal_list ;
2205: LD_ADDR_OWVAR 47
2209: PUSH
2210: LD_EXP 12
2214: ST_TO_ADDR
// for i = 1 to ru_sci do
2215: LD_ADDR_VAR 0 1
2219: PUSH
2220: DOUBLE
2221: LD_INT 1
2223: DEC
2224: ST_TO_ADDR
2225: LD_EXP 23
2229: PUSH
2230: FOR_TO
2231: IFFALSE 2563
// begin if ru_heal_list then
2233: LD_EXP 12
2237: IFFALSE 2476
// begin list := ru_heal_list ;
2239: LD_ADDR_VAR 0 9
2243: PUSH
2244: LD_EXP 12
2248: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2249: LD_EXP 23
2253: PUSH
2254: LD_VAR 0 1
2258: ARRAY
2259: PPUSH
2260: CALL_OW 310
2264: IFFALSE 2281
// ComExitBuilding ( ru_sci [ i ] ) ;
2266: LD_EXP 23
2270: PUSH
2271: LD_VAR 0 1
2275: ARRAY
2276: PPUSH
2277: CALL_OW 122
// for p = 1 to list do
2281: LD_ADDR_VAR 0 5
2285: PUSH
2286: DOUBLE
2287: LD_INT 1
2289: DEC
2290: ST_TO_ADDR
2291: LD_VAR 0 9
2295: PUSH
2296: FOR_TO
2297: IFFALSE 2472
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2299: LD_VAR 0 9
2303: PUSH
2304: LD_VAR 0 5
2308: ARRAY
2309: PPUSH
2310: CALL_OW 110
2314: PUSH
2315: LD_INT 100
2317: EQUAL
2318: PUSH
2319: LD_EXP 23
2323: PUSH
2324: LD_VAR 0 1
2328: ARRAY
2329: PPUSH
2330: LD_INT 100
2332: PPUSH
2333: CALL 9441 0 2
2337: NOT
2338: AND
2339: IFFALSE 2367
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2341: LD_EXP 23
2345: PUSH
2346: LD_VAR 0 1
2350: ARRAY
2351: PPUSH
2352: LD_VAR 0 9
2356: PUSH
2357: LD_VAR 0 5
2361: ARRAY
2362: PPUSH
2363: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2367: LD_VAR 0 9
2371: PUSH
2372: LD_VAR 0 5
2376: ARRAY
2377: PPUSH
2378: CALL_OW 110
2382: PUSH
2383: LD_INT 100
2385: GREATER
2386: IFFALSE 2414
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2388: LD_EXP 23
2392: PUSH
2393: LD_VAR 0 1
2397: ARRAY
2398: PPUSH
2399: LD_VAR 0 9
2403: PUSH
2404: LD_VAR 0 5
2408: ARRAY
2409: PPUSH
2410: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2414: LD_VAR 0 9
2418: PUSH
2419: LD_VAR 0 5
2423: ARRAY
2424: PPUSH
2425: LD_INT 4
2427: PPUSH
2428: CALL_OW 308
2432: NOT
2433: IFFALSE 2455
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2435: LD_VAR 0 9
2439: PUSH
2440: LD_VAR 0 5
2444: ARRAY
2445: PPUSH
2446: LD_INT 4
2448: PPUSH
2449: CALL_OW 113
2453: GO 2470
// ComHold ( list [ p ] ) ;
2455: LD_VAR 0 9
2459: PUSH
2460: LD_VAR 0 5
2464: ARRAY
2465: PPUSH
2466: CALL_OW 140
// end ;
2470: GO 2296
2472: POP
2473: POP
// end else
2474: GO 2561
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2476: LD_EXP 23
2480: PUSH
2481: LD_VAR 0 1
2485: ARRAY
2486: PPUSH
2487: CALL_OW 314
2491: NOT
2492: PUSH
2493: LD_EXP 23
2497: PUSH
2498: LD_VAR 0 1
2502: ARRAY
2503: PPUSH
2504: CALL_OW 310
2508: NOT
2509: AND
2510: PUSH
2511: LD_EXP 12
2515: PUSH
2516: LD_INT 0
2518: EQUAL
2519: AND
2520: IFFALSE 2561
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2522: LD_EXP 23
2526: PUSH
2527: LD_VAR 0 1
2531: ARRAY
2532: PPUSH
2533: LD_INT 3
2535: PPUSH
2536: CALL 6314 0 1
2540: PPUSH
2541: LD_EXP 23
2545: PUSH
2546: LD_VAR 0 1
2550: ARRAY
2551: PPUSH
2552: CALL_OW 74
2556: PPUSH
2557: CALL_OW 120
// end ;
2561: GO 2230
2563: POP
2564: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2565: LD_INT 3
2567: PPUSH
2568: LD_EXP 6
2572: PPUSH
2573: CALL 6455 0 2
2577: IFFALSE 2591
// ResearchTechList ( 3 , ru_tech_list ) ;
2579: LD_INT 3
2581: PPUSH
2582: LD_EXP 6
2586: PPUSH
2587: CALL 6530 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2591: LD_EXP 21
2595: PPUSH
2596: LD_EXP 11
2600: PPUSH
2601: CALL 8437 0 2
// lab := GetLabs ( 3 ) ;
2605: LD_ADDR_VAR 0 8
2609: PUSH
2610: LD_INT 3
2612: PPUSH
2613: CALL 6314 0 1
2617: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2618: LD_VAR 0 8
2622: PUSH
2623: LD_EXP 12
2627: PUSH
2628: LD_INT 0
2630: EQUAL
2631: AND
2632: IFFALSE 2759
// for i = 1 to lab do
2634: LD_ADDR_VAR 0 1
2638: PUSH
2639: DOUBLE
2640: LD_INT 1
2642: DEC
2643: ST_TO_ADDR
2644: LD_VAR 0 8
2648: PUSH
2649: FOR_TO
2650: IFFALSE 2757
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2652: LD_VAR 0 8
2656: PUSH
2657: LD_VAR 0 1
2661: ARRAY
2662: PPUSH
2663: CALL_OW 461
2667: PUSH
2668: LD_INT 6
2670: EQUAL
2671: IFFALSE 2755
// begin for p = 1 to ru_sci do
2673: LD_ADDR_VAR 0 5
2677: PUSH
2678: DOUBLE
2679: LD_INT 1
2681: DEC
2682: ST_TO_ADDR
2683: LD_EXP 23
2687: PUSH
2688: FOR_TO
2689: IFFALSE 2753
// if IsInUnit ( ru_sci [ p ] ) then
2691: LD_EXP 23
2695: PUSH
2696: LD_VAR 0 5
2700: ARRAY
2701: PPUSH
2702: CALL_OW 310
2706: IFFALSE 2725
// ComExitBuilding ( ru_sci [ p ] ) else
2708: LD_EXP 23
2712: PUSH
2713: LD_VAR 0 5
2717: ARRAY
2718: PPUSH
2719: CALL_OW 122
2723: GO 2751
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2725: LD_EXP 23
2729: PUSH
2730: LD_VAR 0 5
2734: ARRAY
2735: PPUSH
2736: LD_VAR 0 8
2740: PUSH
2741: LD_VAR 0 1
2745: ARRAY
2746: PPUSH
2747: CALL_OW 120
2751: GO 2688
2753: POP
2754: POP
// end ;
2755: GO 2649
2757: POP
2758: POP
// if GetTowers ( 3 ) < 5 then
2759: LD_INT 3
2761: PPUSH
2762: CALL 6869 0 1
2766: PUSH
2767: LD_INT 5
2769: LESS
2770: IFFALSE 2788
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2772: LD_EXP 21
2776: PPUSH
2777: LD_EXP 7
2781: PPUSH
2782: CALL 7477 0 2
2786: GO 2800
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2788: LD_INT 3
2790: PPUSH
2791: LD_EXP 8
2795: PPUSH
2796: CALL 7768 0 2
// if GetBuilding ( 3 , b_factory ) then
2800: LD_INT 3
2802: PPUSH
2803: LD_INT 3
2805: PPUSH
2806: CALL 6163 0 2
2810: IFFALSE 3080
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2812: LD_INT 3
2814: PPUSH
2815: LD_INT 3
2817: PPUSH
2818: CALL 6163 0 2
2822: PUSH
2823: LD_INT 1
2825: ARRAY
2826: PPUSH
2827: CALL_OW 461
2831: PUSH
2832: LD_INT 2
2834: EQUAL
2835: IFFALSE 3080
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2837: LD_ADDR_VAR 0 7
2841: PUSH
2842: LD_INT 3
2844: PPUSH
2845: LD_INT 3
2847: PPUSH
2848: CALL 6163 0 2
2852: PUSH
2853: LD_INT 1
2855: ARRAY
2856: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2857: LD_INT 3
2859: PPUSH
2860: LD_INT 24
2862: PPUSH
2863: LD_INT 53
2865: PPUSH
2866: CALL 7916 0 3
2870: PUSH
2871: LD_INT 0
2873: EQUAL
2874: PUSH
2875: LD_EXP 18
2879: AND
2880: IFFALSE 2903
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2882: LD_VAR 0 7
2886: PPUSH
2887: LD_INT 24
2889: PPUSH
2890: LD_INT 1
2892: PPUSH
2893: LD_INT 1
2895: PPUSH
2896: LD_INT 53
2898: PPUSH
2899: CALL 8038 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2903: LD_INT 3
2905: PPUSH
2906: LD_INT 22
2908: PPUSH
2909: LD_INT 52
2911: PPUSH
2912: CALL 7916 0 3
2916: PUSH
2917: LD_INT 0
2919: EQUAL
2920: PUSH
2921: LD_EXP 19
2925: AND
2926: IFFALSE 2949
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2928: LD_VAR 0 7
2932: PPUSH
2933: LD_INT 22
2935: PPUSH
2936: LD_INT 1
2938: PPUSH
2939: LD_INT 3
2941: PPUSH
2942: LD_INT 52
2944: PPUSH
2945: CALL 8038 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2949: LD_INT 3
2951: PPUSH
2952: LD_INT 22
2954: PPUSH
2955: LD_INT 49
2957: PPUSH
2958: CALL 7916 0 3
2962: PUSH
2963: LD_INT 4
2965: LESS
2966: PUSH
2967: LD_INT 31
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: CALL_OW 321
2977: PUSH
2978: LD_INT 2
2980: EQUAL
2981: AND
2982: IFFALSE 3005
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
2984: LD_VAR 0 7
2988: PPUSH
2989: LD_INT 22
2991: PPUSH
2992: LD_INT 1
2994: PPUSH
2995: LD_INT 3
2997: PPUSH
2998: LD_INT 49
3000: PPUSH
3001: CALL 8038 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
3005: LD_EXP 9
3009: PUSH
3010: LD_INT 5
3012: PUSH
3013: LD_INT 6
3015: PUSH
3016: LD_INT 7
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: LIST
3023: PUSH
3024: LD_OWVAR 67
3028: ARRAY
3029: LESS
3030: IFFALSE 3080
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3032: LD_VAR 0 7
3036: PPUSH
3037: LD_INT 24
3039: PPUSH
3040: LD_INT 1
3042: PPUSH
3043: LD_INT 3
3045: PPUSH
3046: LD_INT 46
3048: PUSH
3049: LD_INT 45
3051: PUSH
3052: LD_INT 47
3054: PUSH
3055: LD_INT 46
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: LIST
3062: LIST
3063: PUSH
3064: LD_INT 1
3066: PPUSH
3067: LD_INT 4
3069: PPUSH
3070: CALL_OW 12
3074: ARRAY
3075: PPUSH
3076: CALL 8038 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3080: LD_INT 3
3082: PPUSH
3083: CALL 6072 0 1
3087: PPUSH
3088: CALL 5764 0 1
3092: PUSH
3093: LD_INT 1
3095: ARRAY
3096: PUSH
3097: LD_INT 250
3099: GREATER
3100: PUSH
3101: LD_INT 3
3103: PPUSH
3104: CALL 6072 0 1
3108: PPUSH
3109: CALL 5764 0 1
3113: PUSH
3114: LD_INT 3
3116: ARRAY
3117: PUSH
3118: LD_INT 50
3120: GREATER
3121: AND
3122: PUSH
3123: LD_INT 23
3125: PPUSH
3126: LD_INT 3
3128: PPUSH
3129: CALL_OW 321
3133: PUSH
3134: LD_INT 2
3136: EQUAL
3137: AND
3138: PUSH
3139: LD_INT 3
3141: PPUSH
3142: CALL 11392 0 1
3146: PUSH
3147: LD_INT 0
3149: EQUAL
3150: AND
3151: PUSH
3152: LD_INT 22
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: PUSH
3162: LD_INT 34
3164: PUSH
3165: LD_INT 49
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 69
3180: PUSH
3181: LD_INT 3
3183: GREATER
3184: AND
3185: PUSH
3186: LD_OWVAR 2
3190: PPUSH
3191: LD_INT 51
3193: PPUSH
3194: LD_INT 42
3196: PPUSH
3197: CALL 5391 0 3
3201: PUSH
3202: LD_INT 0
3204: EQUAL
3205: AND
3206: IFFALSE 3291
// begin for i = 1 to ru_mech do
3208: LD_ADDR_VAR 0 1
3212: PUSH
3213: DOUBLE
3214: LD_INT 1
3216: DEC
3217: ST_TO_ADDR
3218: LD_EXP 22
3222: PUSH
3223: FOR_TO
3224: IFFALSE 3289
// begin if IsInUnit ( ru_mech [ i ] ) then
3226: LD_EXP 22
3230: PUSH
3231: LD_VAR 0 1
3235: ARRAY
3236: PPUSH
3237: CALL_OW 310
3241: IFFALSE 3260
// ComExitBuilding ( ru_mech [ i ] ) else
3243: LD_EXP 22
3247: PUSH
3248: LD_VAR 0 1
3252: ARRAY
3253: PPUSH
3254: CALL_OW 122
3258: GO 3287
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3260: LD_EXP 22
3264: PUSH
3265: LD_VAR 0 1
3269: ARRAY
3270: PPUSH
3271: LD_INT 37
3273: PPUSH
3274: LD_INT 51
3276: PPUSH
3277: LD_INT 43
3279: PPUSH
3280: LD_INT 0
3282: PPUSH
3283: CALL_OW 170
// end ;
3287: GO 3223
3289: POP
3290: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3291: LD_OWVAR 1
3295: PUSH
3296: LD_INT 94500
3298: PUSH
3299: LD_INT 84000
3301: PUSH
3302: LD_INT 71400
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: LIST
3309: PUSH
3310: LD_OWVAR 67
3314: ARRAY
3315: GREATEREQUAL
3316: IFFALSE 3372
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3318: LD_OWVAR 1
3322: PUSH
3323: LD_INT 18900
3325: PUSH
3326: LD_INT 16800
3328: PUSH
3329: LD_INT 14700
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: LIST
3336: PUSH
3337: LD_OWVAR 67
3341: ARRAY
3342: MOD
3343: PUSH
3344: LD_INT 0
3346: EQUAL
3347: IFFALSE 3372
// if ru_reserve then
3349: LD_EXP 9
3353: IFFALSE 3372
// begin ru_attack_list := ru_reserve ;
3355: LD_ADDR_EXP 10
3359: PUSH
3360: LD_EXP 9
3364: ST_TO_ADDR
// ru_reserve := [ ] ;
3365: LD_ADDR_EXP 9
3369: PUSH
3370: EMPTY
3371: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3372: LD_EXP 10
3376: IFFALSE 3498
// begin for i = 1 to ru_attack_list do
3378: LD_ADDR_VAR 0 1
3382: PUSH
3383: DOUBLE
3384: LD_INT 1
3386: DEC
3387: ST_TO_ADDR
3388: LD_EXP 10
3392: PUSH
3393: FOR_TO
3394: IFFALSE 3496
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3396: LD_EXP 10
3400: PUSH
3401: LD_VAR 0 1
3405: ARRAY
3406: PPUSH
3407: CALL_OW 256
3411: PUSH
3412: LD_INT 250
3414: GREATEREQUAL
3415: PUSH
3416: LD_EXP 10
3420: PUSH
3421: LD_VAR 0 1
3425: ARRAY
3426: PPUSH
3427: CALL_OW 314
3431: NOT
3432: AND
3433: IFFALSE 3494
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3435: LD_EXP 10
3439: PUSH
3440: LD_VAR 0 1
3444: ARRAY
3445: PPUSH
3446: LD_INT 81
3448: PUSH
3449: LD_EXP 10
3453: PUSH
3454: LD_VAR 0 1
3458: ARRAY
3459: PPUSH
3460: CALL_OW 255
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: PPUSH
3469: CALL_OW 69
3473: PPUSH
3474: LD_EXP 10
3478: PUSH
3479: LD_VAR 0 1
3483: ARRAY
3484: PPUSH
3485: CALL_OW 74
3489: PPUSH
3490: CALL_OW 115
3494: GO 3393
3496: POP
3497: POP
// end ; if GetBehemoth ( 3 ) then
3498: LD_INT 3
3500: PPUSH
3501: CALL 11392 0 1
3505: IFFALSE 3799
// begin if ru_mech >= 4 then
3507: LD_EXP 22
3511: PUSH
3512: LD_INT 4
3514: GREATEREQUAL
3515: IFFALSE 3566
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3517: LD_ADDR_EXP 15
3521: PUSH
3522: LD_EXP 22
3526: PUSH
3527: LD_INT 1
3529: ARRAY
3530: PUSH
3531: LD_EXP 22
3535: PUSH
3536: LD_INT 2
3538: ARRAY
3539: PUSH
3540: LD_EXP 22
3544: PUSH
3545: LD_INT 3
3547: ARRAY
3548: PUSH
3549: LD_EXP 22
3553: PUSH
3554: LD_INT 4
3556: ARRAY
3557: PUSH
3558: EMPTY
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: ST_TO_ADDR
3564: GO 3576
// ru_behemoth_mechanic := ru_mech ;
3566: LD_ADDR_EXP 15
3570: PUSH
3571: LD_EXP 22
3575: ST_TO_ADDR
// for i = 1 to ru_mech do
3576: LD_ADDR_VAR 0 1
3580: PUSH
3581: DOUBLE
3582: LD_INT 1
3584: DEC
3585: ST_TO_ADDR
3586: LD_EXP 22
3590: PUSH
3591: FOR_TO
3592: IFFALSE 3646
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3594: LD_EXP 22
3598: PUSH
3599: LD_VAR 0 1
3603: ARRAY
3604: PPUSH
3605: CALL_OW 310
3609: PUSH
3610: LD_EXP 22
3614: PUSH
3615: LD_VAR 0 1
3619: ARRAY
3620: PUSH
3621: LD_EXP 15
3625: IN
3626: AND
3627: IFFALSE 3644
// ComExitBuilding ( ru_mech [ i ] ) ;
3629: LD_EXP 22
3633: PUSH
3634: LD_VAR 0 1
3638: ARRAY
3639: PPUSH
3640: CALL_OW 122
3644: GO 3591
3646: POP
3647: POP
// if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3648: LD_INT 12
3650: PPUSH
3651: LD_INT 22
3653: PUSH
3654: LD_INT 1
3656: PUSH
3657: EMPTY
3658: LIST
3659: LIST
3660: PUSH
3661: LD_INT 21
3663: PUSH
3664: LD_INT 3
3666: PUSH
3667: EMPTY
3668: LIST
3669: LIST
3670: PUSH
3671: EMPTY
3672: LIST
3673: LIST
3674: PPUSH
3675: CALL_OW 70
3679: PUSH
3680: LD_INT 0
3682: GREATER
3683: IFFALSE 3743
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3685: LD_INT 3
3687: PPUSH
3688: CALL 11392 0 1
3692: PUSH
3693: LD_INT 1
3695: ARRAY
3696: PPUSH
3697: LD_INT 21
3699: PUSH
3700: LD_INT 2
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 34
3709: PUSH
3710: LD_INT 49
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PPUSH
3721: CALL_OW 69
3725: PPUSH
3726: LD_EXP 15
3730: PPUSH
3731: LD_INT 97
3733: PPUSH
3734: LD_INT 9
3736: PPUSH
3737: CALL 10889 0 5
3741: GO 3799
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3743: LD_INT 3
3745: PPUSH
3746: CALL 11392 0 1
3750: PUSH
3751: LD_INT 1
3753: ARRAY
3754: PPUSH
3755: LD_INT 21
3757: PUSH
3758: LD_INT 2
3760: PUSH
3761: EMPTY
3762: LIST
3763: LIST
3764: PUSH
3765: LD_INT 34
3767: PUSH
3768: LD_INT 49
3770: PUSH
3771: EMPTY
3772: LIST
3773: LIST
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: PPUSH
3779: CALL_OW 69
3783: PPUSH
3784: LD_EXP 15
3788: PPUSH
3789: LD_INT 153
3791: PPUSH
3792: LD_INT 102
3794: PPUSH
3795: CALL 10889 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3799: LD_EXP 24
3803: PUSH
3804: LD_INT 0
3806: EQUAL
3807: PUSH
3808: LD_INT 44
3810: PPUSH
3811: LD_INT 3
3813: PPUSH
3814: CALL_OW 321
3818: PUSH
3819: LD_INT 2
3821: EQUAL
3822: AND
3823: IFFALSE 3834
// ComChangeClassToBazooker ( ru_sold ) ;
3825: LD_EXP 20
3829: PPUSH
3830: CALL 9826 0 1
// if ru_bazz then
3834: LD_EXP 24
3838: IFFALSE 3852
// IntBazooka ( ru_bazz , 1 ) ;
3840: LD_EXP 24
3844: PPUSH
3845: LD_INT 1
3847: PPUSH
3848: CALL 9545 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3852: LD_INT 67
3854: PPUSH
3855: LD_INT 39
3857: PPUSH
3858: LD_INT 3
3860: PPUSH
3861: CALL_OW 440
3865: PUSH
3866: LD_INT 0
3868: EQUAL
3869: PUSH
3870: LD_INT 20
3872: PPUSH
3873: LD_INT 3
3875: PPUSH
3876: CALL_OW 321
3880: PUSH
3881: LD_INT 2
3883: EQUAL
3884: AND
3885: IFFALSE 3906
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3887: LD_EXP 23
3891: PUSH
3892: LD_INT 1
3894: ARRAY
3895: PPUSH
3896: LD_INT 67
3898: PPUSH
3899: LD_INT 39
3901: PPUSH
3902: CALL 9020 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3906: LD_INT 89
3908: PPUSH
3909: LD_INT 66
3911: PPUSH
3912: LD_INT 3
3914: PPUSH
3915: CALL_OW 440
3919: PUSH
3920: LD_INT 0
3922: EQUAL
3923: IFFALSE 3944
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
3925: LD_EXP 23
3929: PUSH
3930: LD_INT 1
3932: ARRAY
3933: PPUSH
3934: LD_INT 87
3936: PPUSH
3937: LD_INT 60
3939: PPUSH
3940: CALL 9020 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3944: LD_INT 104
3946: PPUSH
3947: LD_INT 94
3949: PPUSH
3950: LD_INT 3
3952: PPUSH
3953: CALL_OW 440
3957: PUSH
3958: LD_INT 0
3960: EQUAL
3961: PUSH
3962: LD_INT 20
3964: PPUSH
3965: LD_INT 3
3967: PPUSH
3968: CALL_OW 321
3972: PUSH
3973: LD_INT 2
3975: EQUAL
3976: AND
3977: IFFALSE 3998
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
3979: LD_EXP 23
3983: PUSH
3984: LD_INT 1
3986: ARRAY
3987: PPUSH
3988: LD_INT 104
3990: PPUSH
3991: LD_INT 94
3993: PPUSH
3994: CALL 9020 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
3998: LD_INT 3
4000: PPUSH
4001: LD_INT 24
4003: PPUSH
4004: LD_INT 53
4006: PPUSH
4007: CALL 7916 0 3
4011: PUSH
4012: LD_INT 1
4014: EQUAL
4015: PUSH
4016: LD_EXP 18
4020: AND
4021: IFFALSE 4162
// begin need_buldozer := false ;
4023: LD_ADDR_EXP 18
4027: PUSH
4028: LD_INT 0
4030: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4031: LD_INT 3
4033: PPUSH
4034: LD_INT 24
4036: PPUSH
4037: LD_INT 53
4039: PPUSH
4040: CALL 7916 0 3
4044: PUSH
4045: LD_INT 1
4047: ARRAY
4048: PPUSH
4049: LD_INT 67
4051: PPUSH
4052: LD_INT 39
4054: PPUSH
4055: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4059: LD_INT 3
4061: PPUSH
4062: LD_INT 24
4064: PPUSH
4065: LD_INT 53
4067: PPUSH
4068: CALL 7916 0 3
4072: PUSH
4073: LD_INT 1
4075: ARRAY
4076: PPUSH
4077: LD_INT 71
4079: PPUSH
4080: LD_INT 10
4082: PPUSH
4083: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4087: LD_INT 3
4089: PPUSH
4090: LD_INT 24
4092: PPUSH
4093: LD_INT 53
4095: PPUSH
4096: CALL 7916 0 3
4100: PUSH
4101: LD_INT 1
4103: ARRAY
4104: PPUSH
4105: LD_INT 15
4107: PPUSH
4108: CALL 5505 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4112: LD_INT 3
4114: PPUSH
4115: LD_INT 24
4117: PPUSH
4118: LD_INT 53
4120: PPUSH
4121: CALL 7916 0 3
4125: PUSH
4126: LD_INT 1
4128: ARRAY
4129: PPUSH
4130: LD_INT 350
4132: PPUSH
4133: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4137: LD_INT 3
4139: PPUSH
4140: LD_INT 24
4142: PPUSH
4143: LD_INT 53
4145: PPUSH
4146: CALL 7916 0 3
4150: PUSH
4151: LD_INT 1
4153: ARRAY
4154: PPUSH
4155: LD_INT 14
4157: PPUSH
4158: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4162: LD_INT 67
4164: PPUSH
4165: LD_INT 39
4167: PPUSH
4168: LD_INT 3
4170: PPUSH
4171: CALL_OW 440
4175: PUSH
4176: LD_INT 67
4178: PPUSH
4179: LD_INT 39
4181: PPUSH
4182: CALL_OW 428
4186: PUSH
4187: LD_INT 0
4189: EQUAL
4190: AND
4191: PUSH
4192: LD_INT 79
4194: PPUSH
4195: LD_INT 45
4197: PPUSH
4198: CALL_OW 428
4202: PPUSH
4203: CALL_OW 266
4207: PUSH
4208: LD_INT 0
4210: EQUAL
4211: AND
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 79
4218: PPUSH
4219: LD_INT 45
4221: PPUSH
4222: CALL 5391 0 3
4226: PUSH
4227: LD_INT 0
4229: EQUAL
4230: AND
4231: IFFALSE 4334
// begin for i = 1 to ru_eng do
4233: LD_ADDR_VAR 0 1
4237: PUSH
4238: DOUBLE
4239: LD_INT 1
4241: DEC
4242: ST_TO_ADDR
4243: LD_EXP 21
4247: PUSH
4248: FOR_TO
4249: IFFALSE 4332
// if IsInUnit ( ru_eng [ i ] ) then
4251: LD_EXP 21
4255: PUSH
4256: LD_VAR 0 1
4260: ARRAY
4261: PPUSH
4262: CALL_OW 310
4266: IFFALSE 4285
// ComExitBuilding ( ru_eng [ i ] ) else
4268: LD_EXP 21
4272: PUSH
4273: LD_VAR 0 1
4277: ARRAY
4278: PPUSH
4279: CALL_OW 122
4283: GO 4330
// if not HasTask ( ru_eng [ i ] ) then
4285: LD_EXP 21
4289: PUSH
4290: LD_VAR 0 1
4294: ARRAY
4295: PPUSH
4296: CALL_OW 314
4300: NOT
4301: IFFALSE 4330
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4303: LD_EXP 21
4307: PUSH
4308: LD_VAR 0 1
4312: ARRAY
4313: PPUSH
4314: LD_INT 30
4316: PPUSH
4317: LD_INT 67
4319: PPUSH
4320: LD_INT 39
4322: PPUSH
4323: LD_INT 3
4325: PPUSH
4326: CALL_OW 145
4330: GO 4248
4332: POP
4333: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4334: LD_INT 1
4336: PPUSH
4337: LD_INT 79
4339: PPUSH
4340: LD_INT 45
4342: PPUSH
4343: CALL 5391 0 3
4347: PUSH
4348: LD_INT 0
4350: EQUAL
4351: IFFALSE 4547
// begin if HexInfo ( 79 , 45 ) = 0 then
4353: LD_INT 79
4355: PPUSH
4356: LD_INT 45
4358: PPUSH
4359: CALL_OW 428
4363: PUSH
4364: LD_INT 0
4366: EQUAL
4367: IFFALSE 4389
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4369: LD_EXP 21
4373: PPUSH
4374: LD_INT 79
4376: PPUSH
4377: LD_INT 45
4379: PPUSH
4380: LD_INT 3
4382: PPUSH
4383: CALL 6931 0 4
4387: GO 4547
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4389: LD_INT 89
4391: PPUSH
4392: LD_INT 66
4394: PPUSH
4395: CALL_OW 428
4399: PUSH
4400: LD_INT 0
4402: EQUAL
4403: PUSH
4404: LD_INT 89
4406: PPUSH
4407: LD_INT 66
4409: PPUSH
4410: LD_INT 3
4412: PPUSH
4413: CALL_OW 440
4417: AND
4418: IFFALSE 4547
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4420: LD_INT 79
4422: PPUSH
4423: LD_INT 45
4425: PPUSH
4426: CALL_OW 428
4430: PPUSH
4431: CALL_OW 274
4435: PPUSH
4436: LD_INT 1
4438: PPUSH
4439: LD_INT 100
4441: PPUSH
4442: CALL_OW 277
// for i = 1 to ru_eng do
4446: LD_ADDR_VAR 0 1
4450: PUSH
4451: DOUBLE
4452: LD_INT 1
4454: DEC
4455: ST_TO_ADDR
4456: LD_EXP 21
4460: PUSH
4461: FOR_TO
4462: IFFALSE 4545
// if IsInUnit ( ru_eng [ i ] ) then
4464: LD_EXP 21
4468: PUSH
4469: LD_VAR 0 1
4473: ARRAY
4474: PPUSH
4475: CALL_OW 310
4479: IFFALSE 4498
// ComExitBuilding ( ru_eng [ i ] ) else
4481: LD_EXP 21
4485: PUSH
4486: LD_VAR 0 1
4490: ARRAY
4491: PPUSH
4492: CALL_OW 122
4496: GO 4543
// if not HasTask ( ru_eng [ i ] ) then
4498: LD_EXP 21
4502: PUSH
4503: LD_VAR 0 1
4507: ARRAY
4508: PPUSH
4509: CALL_OW 314
4513: NOT
4514: IFFALSE 4543
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4516: LD_EXP 21
4520: PUSH
4521: LD_VAR 0 1
4525: ARRAY
4526: PPUSH
4527: LD_INT 29
4529: PPUSH
4530: LD_INT 89
4532: PPUSH
4533: LD_INT 66
4535: PPUSH
4536: LD_INT 3
4538: PPUSH
4539: CALL_OW 145
4543: GO 4461
4545: POP
4546: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4547: LD_INT 3
4549: PPUSH
4550: LD_INT 29
4552: PPUSH
4553: CALL 6163 0 2
4557: PUSH
4558: LD_INT 0
4560: EQUAL
4561: PUSH
4562: LD_INT 1
4564: PPUSH
4565: LD_INT 36
4567: PPUSH
4568: LD_INT 6
4570: PPUSH
4571: CALL 5391 0 3
4575: PUSH
4576: LD_INT 0
4578: EQUAL
4579: AND
4580: PUSH
4581: LD_INT 3
4583: PPUSH
4584: CALL 6072 0 1
4588: PPUSH
4589: LD_INT 29
4591: PPUSH
4592: CALL 5648 0 2
4596: AND
4597: IFFALSE 4700
// begin for i = 1 to ru_eng do
4599: LD_ADDR_VAR 0 1
4603: PUSH
4604: DOUBLE
4605: LD_INT 1
4607: DEC
4608: ST_TO_ADDR
4609: LD_EXP 21
4613: PUSH
4614: FOR_TO
4615: IFFALSE 4698
// begin if IsInUnit ( ru_eng [ i ] ) then
4617: LD_EXP 21
4621: PUSH
4622: LD_VAR 0 1
4626: ARRAY
4627: PPUSH
4628: CALL_OW 310
4632: IFFALSE 4651
// ComExitBuilding ( ru_eng [ i ] ) else
4634: LD_EXP 21
4638: PUSH
4639: LD_VAR 0 1
4643: ARRAY
4644: PPUSH
4645: CALL_OW 122
4649: GO 4696
// if not HasTask ( ru_eng [ i ] ) then
4651: LD_EXP 21
4655: PUSH
4656: LD_VAR 0 1
4660: ARRAY
4661: PPUSH
4662: CALL_OW 314
4666: NOT
4667: IFFALSE 4696
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4669: LD_EXP 21
4673: PUSH
4674: LD_VAR 0 1
4678: ARRAY
4679: PPUSH
4680: LD_INT 29
4682: PPUSH
4683: LD_INT 33
4685: PPUSH
4686: LD_INT 4
4688: PPUSH
4689: LD_INT 0
4691: PPUSH
4692: CALL_OW 205
// end ; end ;
4696: GO 4614
4698: POP
4699: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4700: LD_EXP 21
4704: PUSH
4705: LD_INT 79
4707: PPUSH
4708: LD_INT 45
4710: PPUSH
4711: CALL_OW 428
4715: PUSH
4716: LD_INT 0
4718: GREATER
4719: AND
4720: PUSH
4721: LD_INT 79
4723: PPUSH
4724: LD_INT 45
4726: PPUSH
4727: CALL_OW 428
4731: PPUSH
4732: CALL_OW 266
4736: PUSH
4737: LD_INT 0
4739: EQUAL
4740: AND
4741: IFFALSE 4901
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4743: LD_INT 79
4745: PPUSH
4746: LD_INT 45
4748: PPUSH
4749: CALL_OW 428
4753: PPUSH
4754: CALL_OW 255
4758: PUSH
4759: LD_INT 3
4761: EQUAL
4762: PUSH
4763: LD_INT 1
4765: PPUSH
4766: LD_INT 79
4768: PPUSH
4769: LD_INT 45
4771: PPUSH
4772: CALL 5391 0 3
4776: PUSH
4777: LD_INT 0
4779: EQUAL
4780: AND
4781: PUSH
4782: LD_INT 79
4784: PPUSH
4785: LD_INT 45
4787: PPUSH
4788: CALL_OW 428
4792: PPUSH
4793: CALL_OW 274
4797: PPUSH
4798: LD_INT 3
4800: PPUSH
4801: CALL_OW 275
4805: PUSH
4806: LD_INT 10
4808: GREATEREQUAL
4809: AND
4810: IFFALSE 4901
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4812: LD_EXP 21
4816: PUSH
4817: LD_INT 1
4819: ARRAY
4820: PPUSH
4821: CALL_OW 310
4825: IFFALSE 4842
// ComExitBuilding ( ru_eng [ 1 ] ) else
4827: LD_EXP 21
4831: PUSH
4832: LD_INT 1
4834: ARRAY
4835: PPUSH
4836: CALL_OW 122
4840: GO 4901
// if not HasTask ( ru_eng [ 1 ] ) then
4842: LD_EXP 21
4846: PUSH
4847: LD_INT 1
4849: ARRAY
4850: PPUSH
4851: CALL_OW 314
4855: NOT
4856: IFFALSE 4901
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4858: LD_EXP 21
4862: PUSH
4863: LD_INT 1
4865: ARRAY
4866: PPUSH
4867: LD_INT 79
4869: PPUSH
4870: LD_INT 45
4872: PPUSH
4873: CALL_OW 428
4877: PPUSH
4878: LD_INT 3
4880: PPUSH
4881: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4885: LD_EXP 21
4889: PUSH
4890: LD_INT 1
4892: ARRAY
4893: PPUSH
4894: LD_INT 2
4896: PPUSH
4897: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4901: LD_EXP 21
4905: PUSH
4906: LD_INT 2
4908: GREATER
4909: PUSH
4910: LD_INT 79
4912: PPUSH
4913: LD_INT 45
4915: PPUSH
4916: CALL_OW 428
4920: PUSH
4921: LD_INT 0
4923: GREATER
4924: AND
4925: PUSH
4926: LD_INT 79
4928: PPUSH
4929: LD_INT 45
4931: PPUSH
4932: CALL_OW 428
4936: PPUSH
4937: CALL_OW 266
4941: PUSH
4942: LD_INT 0
4944: EQUAL
4945: AND
4946: IFFALSE 5106
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
4948: LD_INT 79
4950: PPUSH
4951: LD_INT 45
4953: PPUSH
4954: CALL_OW 428
4958: PPUSH
4959: CALL_OW 255
4963: PUSH
4964: LD_INT 3
4966: EQUAL
4967: PUSH
4968: LD_INT 1
4970: PPUSH
4971: LD_INT 79
4973: PPUSH
4974: LD_INT 45
4976: PPUSH
4977: CALL 5391 0 3
4981: PUSH
4982: LD_INT 0
4984: EQUAL
4985: AND
4986: PUSH
4987: LD_INT 79
4989: PPUSH
4990: LD_INT 45
4992: PPUSH
4993: CALL_OW 428
4997: PPUSH
4998: CALL_OW 274
5002: PPUSH
5003: LD_INT 1
5005: PPUSH
5006: CALL_OW 275
5010: PUSH
5011: LD_INT 20
5013: GREATER
5014: AND
5015: IFFALSE 5106
// begin if IsInUnit ( ru_eng [ 2 ] ) then
5017: LD_EXP 21
5021: PUSH
5022: LD_INT 2
5024: ARRAY
5025: PPUSH
5026: CALL_OW 310
5030: IFFALSE 5047
// ComExitBuilding ( ru_eng [ 2 ] ) else
5032: LD_EXP 21
5036: PUSH
5037: LD_INT 2
5039: ARRAY
5040: PPUSH
5041: CALL_OW 122
5045: GO 5106
// if not HasTask ( ru_eng [ 2 ] ) then
5047: LD_EXP 21
5051: PUSH
5052: LD_INT 2
5054: ARRAY
5055: PPUSH
5056: CALL_OW 314
5060: NOT
5061: IFFALSE 5106
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5063: LD_EXP 21
5067: PUSH
5068: LD_INT 2
5070: ARRAY
5071: PPUSH
5072: LD_INT 79
5074: PPUSH
5075: LD_INT 45
5077: PPUSH
5078: CALL_OW 428
5082: PPUSH
5083: LD_INT 1
5085: PPUSH
5086: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5090: LD_EXP 21
5094: PUSH
5095: LD_INT 2
5097: ARRAY
5098: PPUSH
5099: LD_INT 2
5101: PPUSH
5102: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5106: LD_INT 1
5108: PPUSH
5109: LD_INT 59
5111: PPUSH
5112: LD_INT 60
5114: PPUSH
5115: CALL 5391 0 3
5119: PUSH
5120: LD_INT 0
5122: EQUAL
5123: PUSH
5124: LD_INT 1
5126: PPUSH
5127: LD_INT 67
5129: PPUSH
5130: LD_INT 76
5132: PPUSH
5133: CALL 5391 0 3
5137: PUSH
5138: LD_INT 0
5140: EQUAL
5141: AND
5142: PUSH
5143: LD_INT 1
5145: PPUSH
5146: LD_INT 79
5148: PPUSH
5149: LD_INT 100
5151: PPUSH
5152: CALL 5391 0 3
5156: PUSH
5157: LD_INT 0
5159: EQUAL
5160: AND
5161: IFFALSE 5173
// CollectCrates ( 3 , west_crates ) ;
5163: LD_INT 3
5165: PPUSH
5166: LD_INT 13
5168: PPUSH
5169: CALL 11436 0 2
// end ;
5173: PPOPN 10
5175: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5176: LD_OWVAR 1
5180: PUSH
5181: LD_INT 111300
5183: LESSEQUAL
5184: PUSH
5185: LD_EXP 30
5189: NOT
5190: OR
5191: IFFALSE 5388
5193: GO 5195
5195: DISABLE
5196: LD_INT 0
5198: PPUSH
// begin enable ;
5199: ENABLE
// uc_nation := 3 ;
5200: LD_ADDR_OWVAR 21
5204: PUSH
5205: LD_INT 3
5207: ST_TO_ADDR
// uc_side := 3 ;
5208: LD_ADDR_OWVAR 20
5212: PUSH
5213: LD_INT 3
5215: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5216: LD_ADDR_OWVAR 37
5220: PUSH
5221: LD_INT 22
5223: ST_TO_ADDR
// vc_engine := engine_siberite ;
5224: LD_ADDR_OWVAR 39
5228: PUSH
5229: LD_INT 3
5231: ST_TO_ADDR
// vc_control := control_computer ;
5232: LD_ADDR_OWVAR 38
5236: PUSH
5237: LD_INT 3
5239: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5240: LD_ADDR_OWVAR 40
5244: PUSH
5245: LD_INT 51
5247: ST_TO_ADDR
// veh := CreateVehicle ;
5248: LD_ADDR_VAR 0 1
5252: PUSH
5253: CALL_OW 45
5257: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5258: LD_VAR 0 1
5262: PPUSH
5263: LD_INT 4
5265: PPUSH
5266: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5270: LD_VAR 0 1
5274: PPUSH
5275: LD_INT 10
5277: PPUSH
5278: LD_INT 0
5280: PPUSH
5281: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5285: LD_VAR 0 1
5289: PPUSH
5290: LD_INT 1
5292: PUSH
5293: LD_INT 2
5295: PUSH
5296: LD_INT 3
5298: PUSH
5299: LD_INT 2
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: LIST
5306: LIST
5307: PUSH
5308: LD_INT 1
5310: PPUSH
5311: LD_INT 4
5313: PPUSH
5314: CALL_OW 12
5318: ARRAY
5319: PPUSH
5320: LD_INT 100
5322: PPUSH
5323: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5327: LD_VAR 0 1
5331: PPUSH
5332: LD_INT 2
5334: PPUSH
5335: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5339: LD_VAR 0 1
5343: PPUSH
5344: LD_INT 10
5346: PPUSH
5347: CALL_OW 173
// Wait ( 0 0$10 ) ;
5351: LD_INT 350
5353: PPUSH
5354: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5358: LD_INT 35
5360: PPUSH
5361: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5365: LD_VAR 0 1
5369: PPUSH
5370: LD_INT 10
5372: PPUSH
5373: CALL_OW 308
5377: IFFALSE 5358
// RemoveUnit ( veh ) ;
5379: LD_VAR 0 1
5383: PPUSH
5384: CALL_OW 64
// end ; end_of_file
5388: PPOPN 1
5390: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
5391: LD_INT 0
5393: PPUSH
5394: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
5395: LD_ADDR_VAR 0 5
5399: PUSH
5400: LD_INT 22
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: EMPTY
5409: LIST
5410: LIST
5411: PPUSH
5412: CALL_OW 69
5416: PPUSH
5417: LD_VAR 0 2
5421: PPUSH
5422: LD_VAR 0 3
5426: PPUSH
5427: CALL_OW 73
5431: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 then
5432: LD_VAR 0 5
5436: PPUSH
5437: LD_VAR 0 2
5441: PPUSH
5442: LD_VAR 0 3
5446: PPUSH
5447: CALL_OW 297
5451: PUSH
5452: LD_INT 17
5454: LESS
5455: PUSH
5456: LD_INT 2
5458: PPUSH
5459: LD_INT 22
5461: PUSH
5462: LD_VAR 0 1
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: PPUSH
5471: CALL_OW 70
5475: PUSH
5476: LD_INT 0
5478: GREATER
5479: OR
5480: IFFALSE 5492
// result := true else
5482: LD_ADDR_VAR 0 4
5486: PUSH
5487: LD_INT 1
5489: ST_TO_ADDR
5490: GO 5500
// result := false ;
5492: LD_ADDR_VAR 0 4
5496: PUSH
5497: LD_INT 0
5499: ST_TO_ADDR
// end ;
5500: LD_VAR 0 4
5504: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
5505: LD_INT 0
5507: PPUSH
5508: PPUSH
// area = ListEnvironmentArea ( area ) ;
5509: LD_ADDR_VAR 0 2
5513: PUSH
5514: LD_VAR 0 2
5518: PPUSH
5519: CALL_OW 353
5523: ST_TO_ADDR
// if bulldozer > 0 then
5524: LD_VAR 0 1
5528: PUSH
5529: LD_INT 0
5531: GREATER
5532: IFFALSE 5643
// for i = 1 to area do
5534: LD_ADDR_VAR 0 4
5538: PUSH
5539: DOUBLE
5540: LD_INT 1
5542: DEC
5543: ST_TO_ADDR
5544: LD_VAR 0 2
5548: PUSH
5549: FOR_TO
5550: IFFALSE 5641
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
5552: LD_VAR 0 2
5556: PUSH
5557: LD_VAR 0 4
5561: ARRAY
5562: PUSH
5563: LD_INT 1
5565: ARRAY
5566: PPUSH
5567: LD_VAR 0 2
5571: PUSH
5572: LD_VAR 0 4
5576: ARRAY
5577: PUSH
5578: LD_INT 2
5580: ARRAY
5581: PPUSH
5582: CALL_OW 351
5586: IFFALSE 5639
// if not HasTask ( bulldozer ) then
5588: LD_VAR 0 1
5592: PPUSH
5593: CALL_OW 314
5597: NOT
5598: IFFALSE 5639
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
5600: LD_VAR 0 1
5604: PPUSH
5605: LD_VAR 0 2
5609: PUSH
5610: LD_VAR 0 4
5614: ARRAY
5615: PUSH
5616: LD_INT 1
5618: ARRAY
5619: PPUSH
5620: LD_VAR 0 2
5624: PUSH
5625: LD_VAR 0 4
5629: ARRAY
5630: PUSH
5631: LD_INT 2
5633: ARRAY
5634: PPUSH
5635: CALL_OW 171
5639: GO 5549
5641: POP
5642: POP
// end ;
5643: LD_VAR 0 3
5647: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
5648: LD_INT 0
5650: PPUSH
5651: PPUSH
5652: PPUSH
// pom := GetBase ( bdepot ) ;
5653: LD_ADDR_VAR 0 4
5657: PUSH
5658: LD_VAR 0 1
5662: PPUSH
5663: CALL_OW 274
5667: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
5668: LD_ADDR_VAR 0 5
5672: PUSH
5673: LD_VAR 0 2
5677: PPUSH
5678: LD_VAR 0 1
5682: PPUSH
5683: CALL_OW 248
5687: PPUSH
5688: CALL_OW 450
5692: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
5693: LD_VAR 0 4
5697: PPUSH
5698: LD_INT 1
5700: PPUSH
5701: CALL_OW 275
5705: PUSH
5706: LD_VAR 0 5
5710: PUSH
5711: LD_INT 1
5713: ARRAY
5714: GREATEREQUAL
5715: PUSH
5716: LD_VAR 0 4
5720: PPUSH
5721: LD_INT 3
5723: PPUSH
5724: CALL_OW 275
5728: PUSH
5729: LD_VAR 0 5
5733: PUSH
5734: LD_INT 3
5736: ARRAY
5737: GREATEREQUAL
5738: AND
5739: IFFALSE 5751
// result := true else
5741: LD_ADDR_VAR 0 3
5745: PUSH
5746: LD_INT 1
5748: ST_TO_ADDR
5749: GO 5759
// result := false ;
5751: LD_ADDR_VAR 0 3
5755: PUSH
5756: LD_INT 0
5758: ST_TO_ADDR
// end ;
5759: LD_VAR 0 3
5763: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
5764: LD_INT 0
5766: PPUSH
5767: PPUSH
5768: PPUSH
// pom := GetBase ( bdepot ) ;
5769: LD_ADDR_VAR 0 3
5773: PUSH
5774: LD_VAR 0 1
5778: PPUSH
5779: CALL_OW 274
5783: ST_TO_ADDR
// sor := [ ] ;
5784: LD_ADDR_VAR 0 4
5788: PUSH
5789: EMPTY
5790: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
5791: LD_ADDR_VAR 0 4
5795: PUSH
5796: LD_VAR 0 4
5800: PUSH
5801: LD_VAR 0 3
5805: PPUSH
5806: LD_INT 1
5808: PPUSH
5809: CALL_OW 275
5813: ADD
5814: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
5815: LD_ADDR_VAR 0 4
5819: PUSH
5820: LD_VAR 0 4
5824: PUSH
5825: LD_VAR 0 3
5829: PPUSH
5830: LD_INT 2
5832: PPUSH
5833: CALL_OW 275
5837: ADD
5838: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
5839: LD_ADDR_VAR 0 4
5843: PUSH
5844: LD_VAR 0 4
5848: PUSH
5849: LD_VAR 0 3
5853: PPUSH
5854: LD_INT 3
5856: PPUSH
5857: CALL_OW 275
5861: ADD
5862: ST_TO_ADDR
// result := sor ;
5863: LD_ADDR_VAR 0 2
5867: PUSH
5868: LD_VAR 0 4
5872: ST_TO_ADDR
// end ;
5873: LD_VAR 0 2
5877: RET
// export function Hex ( x , y ) ; begin
5878: LD_INT 0
5880: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
5881: LD_VAR 0 1
5885: PPUSH
5886: LD_VAR 0 2
5890: PPUSH
5891: CALL_OW 488
5895: PUSH
5896: LD_VAR 0 1
5900: PPUSH
5901: LD_VAR 0 2
5905: PPUSH
5906: CALL_OW 428
5910: PUSH
5911: LD_INT 0
5913: EQUAL
5914: AND
5915: IFFALSE 5927
// result := true else
5917: LD_ADDR_VAR 0 3
5921: PUSH
5922: LD_INT 1
5924: ST_TO_ADDR
5925: GO 5935
// result := false ;
5927: LD_ADDR_VAR 0 3
5931: PUSH
5932: LD_INT 0
5934: ST_TO_ADDR
// end ;
5935: LD_VAR 0 3
5939: RET
// export function NeedBuilding ( side , btype ) ; begin
5940: LD_INT 0
5942: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
5943: LD_INT 22
5945: PUSH
5946: LD_VAR 0 1
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 30
5957: PUSH
5958: LD_VAR 0 2
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: PUSH
5967: LD_INT 3
5969: PUSH
5970: LD_INT 57
5972: PUSH
5973: EMPTY
5974: LIST
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: PPUSH
5985: CALL_OW 69
5989: PUSH
5990: LD_INT 0
5992: EQUAL
5993: IFFALSE 6005
// result := true else
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_INT 1
6002: ST_TO_ADDR
6003: GO 6013
// result := false ;
6005: LD_ADDR_VAR 0 3
6009: PUSH
6010: LD_INT 0
6012: ST_TO_ADDR
// end ;
6013: LD_VAR 0 3
6017: RET
// export function NeedBase ( side ) ; begin
6018: LD_INT 0
6020: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6021: LD_VAR 0 1
6025: PPUSH
6026: LD_INT 0
6028: PPUSH
6029: CALL 5940 0 2
6033: PUSH
6034: LD_VAR 0 1
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 5940 0 2
6046: AND
6047: IFFALSE 6059
// result := true else
6049: LD_ADDR_VAR 0 2
6053: PUSH
6054: LD_INT 1
6056: ST_TO_ADDR
6057: GO 6067
// result := false ;
6059: LD_ADDR_VAR 0 2
6063: PUSH
6064: LD_INT 0
6066: ST_TO_ADDR
// end ;
6067: LD_VAR 0 2
6071: RET
// export function MyBase ( side ) ; begin
6072: LD_INT 0
6074: PPUSH
// if not NeedBase ( side ) then
6075: LD_VAR 0 1
6079: PPUSH
6080: CALL 6018 0 1
6084: NOT
6085: IFFALSE 6150
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6087: LD_ADDR_VAR 0 2
6091: PUSH
6092: LD_INT 22
6094: PUSH
6095: LD_VAR 0 1
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: PUSH
6104: LD_INT 2
6106: PUSH
6107: LD_INT 30
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: PUSH
6117: LD_INT 30
6119: PUSH
6120: LD_INT 1
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: PUSH
6136: EMPTY
6137: LIST
6138: PPUSH
6139: CALL_OW 69
6143: PUSH
6144: LD_INT 1
6146: ARRAY
6147: ST_TO_ADDR
6148: GO 6158
// result := false ;
6150: LD_ADDR_VAR 0 2
6154: PUSH
6155: LD_INT 0
6157: ST_TO_ADDR
// end ;
6158: LD_VAR 0 2
6162: RET
// export function GetBuilding ( side , btype ) ; begin
6163: LD_INT 0
6165: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6166: LD_INT 22
6168: PUSH
6169: LD_VAR 0 1
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PUSH
6178: LD_INT 30
6180: PUSH
6181: LD_VAR 0 2
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 69
6198: PUSH
6199: LD_INT 0
6201: GREATER
6202: IFFALSE 6244
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6204: LD_ADDR_VAR 0 3
6208: PUSH
6209: LD_INT 22
6211: PUSH
6212: LD_VAR 0 1
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: LD_INT 30
6223: PUSH
6224: LD_VAR 0 2
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PPUSH
6237: CALL_OW 69
6241: ST_TO_ADDR
6242: GO 6252
// result := false ;
6244: LD_ADDR_VAR 0 3
6248: PUSH
6249: LD_INT 0
6251: ST_TO_ADDR
// end ;
6252: LD_VAR 0 3
6256: RET
// export function GetCrates ( side ) ; begin
6257: LD_INT 0
6259: PPUSH
// if MyBase ( side ) then
6260: LD_VAR 0 1
6264: PPUSH
6265: CALL 6072 0 1
6269: IFFALSE 6301
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
6271: LD_ADDR_VAR 0 2
6275: PUSH
6276: LD_VAR 0 1
6280: PPUSH
6281: CALL 6072 0 1
6285: PPUSH
6286: CALL_OW 274
6290: PPUSH
6291: LD_INT 1
6293: PPUSH
6294: CALL_OW 275
6298: ST_TO_ADDR
6299: GO 6309
// result := false ;
6301: LD_ADDR_VAR 0 2
6305: PUSH
6306: LD_INT 0
6308: ST_TO_ADDR
// end ;
6309: LD_VAR 0 2
6313: RET
// export function GetLabs ( side ) ; begin
6314: LD_INT 0
6316: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6317: LD_ADDR_VAR 0 2
6321: PUSH
6322: LD_INT 22
6324: PUSH
6325: LD_VAR 0 1
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PUSH
6334: LD_INT 2
6336: PUSH
6337: LD_INT 30
6339: PUSH
6340: LD_INT 6
6342: PUSH
6343: EMPTY
6344: LIST
6345: LIST
6346: PUSH
6347: LD_INT 30
6349: PUSH
6350: LD_INT 8
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: PUSH
6357: LD_INT 30
6359: PUSH
6360: LD_INT 7
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: PUSH
6377: EMPTY
6378: LIST
6379: PPUSH
6380: CALL_OW 69
6384: ST_TO_ADDR
// end ;
6385: LD_VAR 0 2
6389: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
6390: LD_INT 0
6392: PPUSH
6393: PPUSH
6394: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
6395: LD_ADDR_VAR 0 3
6399: PUSH
6400: LD_VAR 0 1
6404: PPUSH
6405: LD_INT 1
6407: PPUSH
6408: CALL_OW 268
6412: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
6413: LD_ADDR_VAR 0 4
6417: PUSH
6418: LD_VAR 0 1
6422: PPUSH
6423: LD_INT 2
6425: PPUSH
6426: CALL_OW 268
6430: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
6431: LD_ADDR_VAR 0 2
6435: PUSH
6436: LD_VAR 0 3
6440: PUSH
6441: LD_VAR 0 4
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: ST_TO_ADDR
// end ;
6450: LD_VAR 0 2
6454: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
6455: LD_INT 0
6457: PPUSH
6458: PPUSH
// result := false ;
6459: LD_ADDR_VAR 0 3
6463: PUSH
6464: LD_INT 0
6466: ST_TO_ADDR
// for i = 1 to tlist do
6467: LD_ADDR_VAR 0 4
6471: PUSH
6472: DOUBLE
6473: LD_INT 1
6475: DEC
6476: ST_TO_ADDR
6477: LD_VAR 0 2
6481: PUSH
6482: FOR_TO
6483: IFFALSE 6523
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6485: LD_VAR 0 2
6489: PUSH
6490: LD_VAR 0 4
6494: ARRAY
6495: PPUSH
6496: LD_VAR 0 1
6500: PPUSH
6501: CALL_OW 321
6505: PUSH
6506: LD_INT 2
6508: NONEQUAL
6509: IFFALSE 6521
// begin result := true ;
6511: LD_ADDR_VAR 0 3
6515: PUSH
6516: LD_INT 1
6518: ST_TO_ADDR
// break ;
6519: GO 6523
// end ;
6521: GO 6482
6523: POP
6524: POP
// end ;
6525: LD_VAR 0 3
6529: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
6530: LD_INT 0
6532: PPUSH
6533: PPUSH
6534: PPUSH
6535: PPUSH
6536: PPUSH
6537: PPUSH
6538: PPUSH
6539: PPUSH
// lab := GetLabs ( side ) ;
6540: LD_ADDR_VAR 0 5
6544: PUSH
6545: LD_VAR 0 1
6549: PPUSH
6550: CALL 6314 0 1
6554: ST_TO_ADDR
// tmp := 0 ;
6555: LD_ADDR_VAR 0 7
6559: PUSH
6560: LD_INT 0
6562: ST_TO_ADDR
// list := [ ] ;
6563: LD_ADDR_VAR 0 8
6567: PUSH
6568: EMPTY
6569: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
6570: LD_ADDR_VAR 0 10
6574: PUSH
6575: LD_INT 35
6577: PUSH
6578: LD_INT 45
6580: PUSH
6581: LD_INT 46
6583: PUSH
6584: LD_INT 47
6586: PUSH
6587: LD_INT 1
6589: PUSH
6590: LD_INT 2
6592: PUSH
6593: LD_INT 48
6595: PUSH
6596: LD_INT 49
6598: PUSH
6599: LD_INT 50
6601: PUSH
6602: LD_INT 20
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: LIST
6615: LIST
6616: ST_TO_ADDR
// for i = 1 to tlist do
6617: LD_ADDR_VAR 0 4
6621: PUSH
6622: DOUBLE
6623: LD_INT 1
6625: DEC
6626: ST_TO_ADDR
6627: LD_VAR 0 2
6631: PUSH
6632: FOR_TO
6633: IFFALSE 6685
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6635: LD_VAR 0 2
6639: PUSH
6640: LD_VAR 0 4
6644: ARRAY
6645: PPUSH
6646: LD_VAR 0 1
6650: PPUSH
6651: CALL_OW 321
6655: PUSH
6656: LD_INT 2
6658: NONEQUAL
6659: IFFALSE 6683
// list := list ^ tlist [ i ] ;
6661: LD_ADDR_VAR 0 8
6665: PUSH
6666: LD_VAR 0 8
6670: PUSH
6671: LD_VAR 0 2
6675: PUSH
6676: LD_VAR 0 4
6680: ARRAY
6681: ADD
6682: ST_TO_ADDR
6683: GO 6632
6685: POP
6686: POP
// if list then
6687: LD_VAR 0 8
6691: IFFALSE 6856
// begin for i = 1 to lab do
6693: LD_ADDR_VAR 0 4
6697: PUSH
6698: DOUBLE
6699: LD_INT 1
6701: DEC
6702: ST_TO_ADDR
6703: LD_VAR 0 5
6707: PUSH
6708: FOR_TO
6709: IFFALSE 6779
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
6711: LD_VAR 0 8
6715: PUSH
6716: LD_INT 1
6718: ARRAY
6719: PUSH
6720: LD_VAR 0 10
6724: IN
6725: PUSH
6726: LD_VAR 0 8
6730: PUSH
6731: LD_INT 1
6733: ARRAY
6734: PPUSH
6735: CALL_OW 481
6739: PUSH
6740: LD_VAR 0 5
6744: PUSH
6745: LD_VAR 0 4
6749: ARRAY
6750: PPUSH
6751: CALL 6390 0 1
6755: IN
6756: OR
6757: IFFALSE 6777
// begin mylab := lab [ i ] ;
6759: LD_ADDR_VAR 0 9
6763: PUSH
6764: LD_VAR 0 5
6768: PUSH
6769: LD_VAR 0 4
6773: ARRAY
6774: ST_TO_ADDR
// break ;
6775: GO 6779
// end ;
6777: GO 6708
6779: POP
6780: POP
// if mylab then
6781: LD_VAR 0 9
6785: IFFALSE 6846
// begin if BuildingStatus ( mylab ) = bs_idle then
6787: LD_VAR 0 9
6791: PPUSH
6792: CALL_OW 461
6796: PUSH
6797: LD_INT 2
6799: EQUAL
6800: IFFALSE 6844
// for i = 1 to list do
6802: LD_ADDR_VAR 0 4
6806: PUSH
6807: DOUBLE
6808: LD_INT 1
6810: DEC
6811: ST_TO_ADDR
6812: LD_VAR 0 8
6816: PUSH
6817: FOR_TO
6818: IFFALSE 6842
// AddComResearch ( mylab , list [ i ] ) ;
6820: LD_VAR 0 9
6824: PPUSH
6825: LD_VAR 0 8
6829: PUSH
6830: LD_VAR 0 4
6834: ARRAY
6835: PPUSH
6836: CALL_OW 184
6840: GO 6817
6842: POP
6843: POP
// end else
6844: GO 6854
// result := false ;
6846: LD_ADDR_VAR 0 3
6850: PUSH
6851: LD_INT 0
6853: ST_TO_ADDR
// end else
6854: GO 6864
// result := false ;
6856: LD_ADDR_VAR 0 3
6860: PUSH
6861: LD_INT 0
6863: ST_TO_ADDR
// end ;
6864: LD_VAR 0 3
6868: RET
// export function GetTowers ( side ) ; begin
6869: LD_INT 0
6871: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
6872: LD_ADDR_VAR 0 2
6876: PUSH
6877: LD_INT 22
6879: PUSH
6880: LD_VAR 0 1
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PUSH
6889: LD_INT 2
6891: PUSH
6892: LD_INT 30
6894: PUSH
6895: LD_INT 32
6897: PUSH
6898: EMPTY
6899: LIST
6900: LIST
6901: PUSH
6902: LD_INT 30
6904: PUSH
6905: LD_INT 33
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: LIST
6916: PUSH
6917: EMPTY
6918: LIST
6919: LIST
6920: PPUSH
6921: CALL_OW 69
6925: ST_TO_ADDR
// end ;
6926: LD_VAR 0 2
6930: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
6931: LD_INT 0
6933: PPUSH
6934: PPUSH
// if Hex ( x , y ) then
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_VAR 0 3
6944: PPUSH
6945: CALL 5878 0 2
6949: IFFALSE 7024
// for i = 1 to plist do
6951: LD_ADDR_VAR 0 6
6955: PUSH
6956: DOUBLE
6957: LD_INT 1
6959: DEC
6960: ST_TO_ADDR
6961: LD_VAR 0 1
6965: PUSH
6966: FOR_TO
6967: IFFALSE 7022
// if not HasTask ( plist [ i ] ) then
6969: LD_VAR 0 1
6973: PUSH
6974: LD_VAR 0 6
6978: ARRAY
6979: PPUSH
6980: CALL_OW 314
6984: NOT
6985: IFFALSE 7020
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
6987: LD_VAR 0 1
6991: PUSH
6992: LD_VAR 0 6
6996: ARRAY
6997: PPUSH
6998: LD_INT 0
7000: PPUSH
7001: LD_VAR 0 2
7005: PPUSH
7006: LD_VAR 0 3
7010: PPUSH
7011: LD_VAR 0 4
7015: PPUSH
7016: CALL_OW 145
7020: GO 6966
7022: POP
7023: POP
// end ;
7024: LD_VAR 0 5
7028: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7029: LD_INT 0
7031: PPUSH
7032: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7033: LD_VAR 0 2
7037: PPUSH
7038: CALL_OW 266
7042: PUSH
7043: LD_INT 0
7045: EQUAL
7046: PUSH
7047: LD_VAR 0 2
7051: PPUSH
7052: LD_INT 1
7054: PPUSH
7055: CALL 5648 0 2
7059: AND
7060: PUSH
7061: LD_VAR 0 1
7065: PUSH
7066: LD_INT 1
7068: ARRAY
7069: PPUSH
7070: CALL_OW 255
7074: PPUSH
7075: CALL_OW 345
7079: NOT
7080: AND
7081: IFFALSE 7177
// begin ComUpgrade ( bident ) ;
7083: LD_VAR 0 2
7087: PPUSH
7088: CALL_OW 146
// for i = 1 to plist do
7092: LD_ADDR_VAR 0 4
7096: PUSH
7097: DOUBLE
7098: LD_INT 1
7100: DEC
7101: ST_TO_ADDR
7102: LD_VAR 0 1
7106: PUSH
7107: FOR_TO
7108: IFFALSE 7165
// if not HasTask ( plist [ i ] ) then
7110: LD_VAR 0 1
7114: PUSH
7115: LD_VAR 0 4
7119: ARRAY
7120: PPUSH
7121: CALL_OW 314
7125: NOT
7126: IFFALSE 7163
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7128: LD_VAR 0 1
7132: PUSH
7133: LD_VAR 0 4
7137: ARRAY
7138: PPUSH
7139: LD_VAR 0 2
7143: PPUSH
7144: CALL_OW 250
7148: PPUSH
7149: LD_VAR 0 2
7153: PPUSH
7154: CALL_OW 251
7158: PPUSH
7159: CALL_OW 111
7163: GO 7107
7165: POP
7166: POP
// result := true ;
7167: LD_ADDR_VAR 0 3
7171: PUSH
7172: LD_INT 1
7174: ST_TO_ADDR
// end else
7175: GO 7185
// result := false ;
7177: LD_ADDR_VAR 0 3
7181: PUSH
7182: LD_INT 0
7184: ST_TO_ADDR
// end ;
7185: LD_VAR 0 3
7189: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7190: LD_INT 0
7192: PPUSH
7193: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7194: LD_VAR 0 1
7198: PUSH
7199: LD_INT 1
7201: ARRAY
7202: PPUSH
7203: CALL_OW 255
7207: PPUSH
7208: CALL 6257 0 1
7212: PUSH
7213: LD_INT 20
7215: GREATEREQUAL
7216: PUSH
7217: LD_VAR 0 2
7221: PPUSH
7222: LD_VAR 0 3
7226: PPUSH
7227: CALL 5878 0 2
7231: AND
7232: IFFALSE 7317
// begin for i = 1 to plist do
7234: LD_ADDR_VAR 0 6
7238: PUSH
7239: DOUBLE
7240: LD_INT 1
7242: DEC
7243: ST_TO_ADDR
7244: LD_VAR 0 1
7248: PUSH
7249: FOR_TO
7250: IFFALSE 7305
// if not HasTask ( plist [ i ] ) then
7252: LD_VAR 0 1
7256: PUSH
7257: LD_VAR 0 6
7261: ARRAY
7262: PPUSH
7263: CALL_OW 314
7267: NOT
7268: IFFALSE 7303
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7270: LD_VAR 0 1
7274: PUSH
7275: LD_VAR 0 6
7279: ARRAY
7280: PPUSH
7281: LD_INT 6
7283: PPUSH
7284: LD_VAR 0 2
7288: PPUSH
7289: LD_VAR 0 3
7293: PPUSH
7294: LD_VAR 0 4
7298: PPUSH
7299: CALL_OW 145
7303: GO 7249
7305: POP
7306: POP
// result := true ;
7307: LD_ADDR_VAR 0 5
7311: PUSH
7312: LD_INT 1
7314: ST_TO_ADDR
// end else
7315: GO 7325
// result := false ;
7317: LD_ADDR_VAR 0 5
7321: PUSH
7322: LD_INT 0
7324: ST_TO_ADDR
// end ;
7325: LD_VAR 0 5
7329: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7330: LD_INT 0
7332: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7333: LD_VAR 0 1
7337: PPUSH
7338: LD_INT 1
7340: PPUSH
7341: CALL_OW 268
7345: PUSH
7346: LD_INT 9
7348: EQUAL
7349: PUSH
7350: LD_VAR 0 1
7354: PPUSH
7355: LD_INT 2
7357: PPUSH
7358: CALL_OW 268
7362: PUSH
7363: LD_INT 9
7365: EQUAL
7366: AND
7367: IFFALSE 7464
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7369: LD_VAR 0 1
7373: PPUSH
7374: LD_VAR 0 2
7378: PPUSH
7379: CALL 5648 0 2
7383: PUSH
7384: LD_VAR 0 1
7388: PPUSH
7389: LD_VAR 0 3
7393: PPUSH
7394: CALL 5648 0 2
7398: AND
7399: PUSH
7400: LD_VAR 0 1
7404: PPUSH
7405: CALL_OW 461
7409: PUSH
7410: LD_INT 2
7412: EQUAL
7413: AND
7414: IFFALSE 7454
// begin ComUpgradeLab ( lab , bkind1 ) ;
7416: LD_VAR 0 1
7420: PPUSH
7421: LD_VAR 0 2
7425: PPUSH
7426: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
7430: LD_VAR 0 1
7434: PPUSH
7435: LD_VAR 0 3
7439: PPUSH
7440: CALL_OW 207
// result := true ;
7444: LD_ADDR_VAR 0 4
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// end else
7452: GO 7462
// result := false ;
7454: LD_ADDR_VAR 0 4
7458: PUSH
7459: LD_INT 0
7461: ST_TO_ADDR
// end else
7462: GO 7472
// result := false ;
7464: LD_ADDR_VAR 0 4
7468: PUSH
7469: LD_INT 0
7471: ST_TO_ADDR
// end ;
7472: LD_VAR 0 4
7476: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
7477: LD_INT 0
7479: PPUSH
7480: PPUSH
7481: PPUSH
7482: PPUSH
7483: PPUSH
// p := 1 ;
7484: LD_ADDR_VAR 0 6
7488: PUSH
7489: LD_INT 1
7491: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
7492: LD_ADDR_VAR 0 4
7496: PUSH
7497: DOUBLE
7498: LD_INT 1
7500: DEC
7501: ST_TO_ADDR
7502: LD_VAR 0 2
7506: PUSH
7507: LD_INT 4
7509: DIVREAL
7510: PUSH
7511: FOR_TO
7512: IFFALSE 7761
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
7514: LD_VAR 0 2
7518: PUSH
7519: LD_VAR 0 6
7523: PUSH
7524: LD_INT 1
7526: PLUS
7527: ARRAY
7528: PPUSH
7529: LD_VAR 0 2
7533: PUSH
7534: LD_VAR 0 6
7538: PUSH
7539: LD_INT 2
7541: PLUS
7542: ARRAY
7543: PPUSH
7544: CALL_OW 428
7548: PUSH
7549: LD_INT 0
7551: EQUAL
7552: PUSH
7553: LD_VAR 0 2
7557: PUSH
7558: LD_VAR 0 6
7562: PUSH
7563: LD_INT 1
7565: PLUS
7566: ARRAY
7567: PPUSH
7568: LD_VAR 0 2
7572: PUSH
7573: LD_VAR 0 6
7577: PUSH
7578: LD_INT 2
7580: PLUS
7581: ARRAY
7582: PPUSH
7583: CALL 5878 0 2
7587: AND
7588: PUSH
7589: LD_VAR 0 1
7593: PUSH
7594: LD_INT 1
7596: ARRAY
7597: PPUSH
7598: CALL_OW 255
7602: PPUSH
7603: CALL 6257 0 1
7607: PUSH
7608: LD_INT 20
7610: GREATEREQUAL
7611: AND
7612: IFFALSE 7729
// begin for c = 1 to plist do
7614: LD_ADDR_VAR 0 7
7618: PUSH
7619: DOUBLE
7620: LD_INT 1
7622: DEC
7623: ST_TO_ADDR
7624: LD_VAR 0 1
7628: PUSH
7629: FOR_TO
7630: IFFALSE 7723
// if not HasTask ( plist [ c ] ) then
7632: LD_VAR 0 1
7636: PUSH
7637: LD_VAR 0 7
7641: ARRAY
7642: PPUSH
7643: CALL_OW 314
7647: NOT
7648: IFFALSE 7721
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
7650: LD_VAR 0 1
7654: PUSH
7655: LD_VAR 0 7
7659: ARRAY
7660: PPUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_VAR 0 6
7670: ARRAY
7671: PPUSH
7672: LD_VAR 0 2
7676: PUSH
7677: LD_VAR 0 6
7681: PUSH
7682: LD_INT 1
7684: PLUS
7685: ARRAY
7686: PPUSH
7687: LD_VAR 0 2
7691: PUSH
7692: LD_VAR 0 6
7696: PUSH
7697: LD_INT 2
7699: PLUS
7700: ARRAY
7701: PPUSH
7702: LD_VAR 0 2
7706: PUSH
7707: LD_VAR 0 6
7711: PUSH
7712: LD_INT 3
7714: PLUS
7715: ARRAY
7716: PPUSH
7717: CALL_OW 145
7721: GO 7629
7723: POP
7724: POP
// break ;
7725: GO 7761
// end else
7727: GO 7759
// if ( p + 4 < tlist ) then
7729: LD_VAR 0 6
7733: PUSH
7734: LD_INT 4
7736: PLUS
7737: PUSH
7738: LD_VAR 0 2
7742: LESS
7743: IFFALSE 7759
// p := p + 4 ;
7745: LD_ADDR_VAR 0 6
7749: PUSH
7750: LD_VAR 0 6
7754: PUSH
7755: LD_INT 4
7757: PLUS
7758: ST_TO_ADDR
// end ;
7759: GO 7511
7761: POP
7762: POP
// end ;
7763: LD_VAR 0 3
7767: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
7768: LD_INT 0
7770: PPUSH
7771: PPUSH
7772: PPUSH
7773: PPUSH
// tmp := GetTowers ( side ) ;
7774: LD_ADDR_VAR 0 5
7778: PUSH
7779: LD_VAR 0 1
7783: PPUSH
7784: CALL 6869 0 1
7788: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
7789: LD_ADDR_VAR 0 6
7793: PUSH
7794: LD_VAR 0 1
7798: PPUSH
7799: LD_INT 3
7801: PPUSH
7802: CALL 6163 0 2
7806: PUSH
7807: LD_INT 1
7809: ARRAY
7810: ST_TO_ADDR
// if fac then
7811: LD_VAR 0 6
7815: IFFALSE 7911
// for i = 1 to tmp do
7817: LD_ADDR_VAR 0 4
7821: PUSH
7822: DOUBLE
7823: LD_INT 1
7825: DEC
7826: ST_TO_ADDR
7827: LD_VAR 0 5
7831: PUSH
7832: FOR_TO
7833: IFFALSE 7909
// if GetBWeapon ( tmp [ i ] ) = 0 then
7835: LD_VAR 0 5
7839: PUSH
7840: LD_VAR 0 4
7844: ARRAY
7845: PPUSH
7846: CALL_OW 269
7850: PUSH
7851: LD_INT 0
7853: EQUAL
7854: IFFALSE 7907
// begin if BuildingStatus ( fac ) = bs_idle then
7856: LD_VAR 0 6
7860: PPUSH
7861: CALL_OW 461
7865: PUSH
7866: LD_INT 2
7868: EQUAL
7869: IFFALSE 7905
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
7871: LD_VAR 0 5
7875: PUSH
7876: LD_VAR 0 4
7880: ARRAY
7881: PPUSH
7882: LD_VAR 0 2
7886: PUSH
7887: LD_INT 1
7889: PPUSH
7890: LD_VAR 0 2
7894: PPUSH
7895: CALL_OW 12
7899: ARRAY
7900: PPUSH
7901: CALL_OW 148
// break ;
7905: GO 7909
// end ;
7907: GO 7832
7909: POP
7910: POP
// end ;
7911: LD_VAR 0 3
7915: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
7916: LD_INT 0
7918: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
7919: LD_INT 22
7921: PUSH
7922: LD_VAR 0 1
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: PUSH
7931: LD_INT 34
7933: PUSH
7934: LD_VAR 0 3
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: PUSH
7943: LD_INT 31
7945: PUSH
7946: LD_VAR 0 2
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: LIST
7959: PUSH
7960: EMPTY
7961: LIST
7962: PPUSH
7963: CALL_OW 69
7967: IFFALSE 8025
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
7969: LD_ADDR_VAR 0 4
7973: PUSH
7974: LD_INT 22
7976: PUSH
7977: LD_VAR 0 1
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PUSH
7986: LD_INT 34
7988: PUSH
7989: LD_VAR 0 3
7993: PUSH
7994: EMPTY
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 31
8000: PUSH
8001: LD_VAR 0 2
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: LIST
8014: PUSH
8015: EMPTY
8016: LIST
8017: PPUSH
8018: CALL_OW 69
8022: ST_TO_ADDR
8023: GO 8033
// result := false ;
8025: LD_ADDR_VAR 0 4
8029: PUSH
8030: LD_INT 0
8032: ST_TO_ADDR
// end ;
8033: LD_VAR 0 4
8037: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8038: LD_INT 0
8040: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8041: LD_VAR 0 1
8045: PPUSH
8046: LD_VAR 0 2
8050: PPUSH
8051: LD_VAR 0 3
8055: PPUSH
8056: LD_VAR 0 4
8060: PPUSH
8061: LD_VAR 0 5
8065: PPUSH
8066: CALL_OW 448
8070: PUSH
8071: LD_VAR 0 2
8075: PPUSH
8076: LD_VAR 0 3
8080: PPUSH
8081: LD_VAR 0 4
8085: PPUSH
8086: LD_VAR 0 5
8090: PPUSH
8091: CALL_OW 449
8095: PUSH
8096: LD_INT 1
8098: ARRAY
8099: PUSH
8100: LD_VAR 0 1
8104: PPUSH
8105: CALL 5764 0 1
8109: PUSH
8110: LD_INT 1
8112: ARRAY
8113: LESSEQUAL
8114: AND
8115: PUSH
8116: LD_VAR 0 2
8120: PPUSH
8121: LD_VAR 0 3
8125: PPUSH
8126: LD_VAR 0 4
8130: PPUSH
8131: LD_VAR 0 5
8135: PPUSH
8136: CALL_OW 449
8140: PUSH
8141: LD_INT 2
8143: ARRAY
8144: PUSH
8145: LD_VAR 0 1
8149: PPUSH
8150: CALL 5764 0 1
8154: PUSH
8155: LD_INT 2
8157: ARRAY
8158: LESSEQUAL
8159: AND
8160: PUSH
8161: LD_VAR 0 2
8165: PPUSH
8166: LD_VAR 0 3
8170: PPUSH
8171: LD_VAR 0 4
8175: PPUSH
8176: LD_VAR 0 5
8180: PPUSH
8181: CALL_OW 449
8185: PUSH
8186: LD_INT 3
8188: ARRAY
8189: PUSH
8190: LD_VAR 0 1
8194: PPUSH
8195: CALL 5764 0 1
8199: PUSH
8200: LD_INT 3
8202: ARRAY
8203: LESSEQUAL
8204: AND
8205: IFFALSE 8252
// begin if debug then
8207: LD_EXP 1
8211: IFFALSE 8221
// display_strings := Factory work! ;
8213: LD_ADDR_OWVAR 47
8217: PUSH
8218: LD_STRING Factory work!
8220: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8221: LD_VAR 0 1
8225: PPUSH
8226: LD_VAR 0 2
8230: PPUSH
8231: LD_VAR 0 3
8235: PPUSH
8236: LD_VAR 0 4
8240: PPUSH
8241: LD_VAR 0 5
8245: PPUSH
8246: CALL_OW 125
// end else
8250: GO 8260
// result := false ;
8252: LD_ADDR_VAR 0 6
8256: PUSH
8257: LD_INT 0
8259: ST_TO_ADDR
// end ;
8260: LD_VAR 0 6
8264: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8265: LD_INT 0
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8271: LD_ADDR_VAR 0 6
8275: PUSH
8276: LD_INT 22
8278: PUSH
8279: LD_VAR 0 1
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: LD_INT 30
8290: PUSH
8291: LD_VAR 0 2
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: PUSH
8300: EMPTY
8301: LIST
8302: LIST
8303: PPUSH
8304: CALL_OW 69
8308: ST_TO_ADDR
// tmp := [ ] ;
8309: LD_ADDR_VAR 0 5
8313: PUSH
8314: EMPTY
8315: ST_TO_ADDR
// for i = 1 to filter do
8316: LD_ADDR_VAR 0 4
8320: PUSH
8321: DOUBLE
8322: LD_INT 1
8324: DEC
8325: ST_TO_ADDR
8326: LD_VAR 0 6
8330: PUSH
8331: FOR_TO
8332: IFFALSE 8420
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8334: LD_ADDR_VAR 0 5
8338: PUSH
8339: LD_VAR 0 5
8343: PUSH
8344: LD_VAR 0 6
8348: PUSH
8349: LD_VAR 0 4
8353: ARRAY
8354: PPUSH
8355: CALL_OW 266
8359: PUSH
8360: LD_VAR 0 6
8364: PUSH
8365: LD_VAR 0 4
8369: ARRAY
8370: PPUSH
8371: CALL_OW 250
8375: PUSH
8376: LD_VAR 0 6
8380: PUSH
8381: LD_VAR 0 4
8385: ARRAY
8386: PPUSH
8387: CALL_OW 251
8391: PUSH
8392: LD_VAR 0 6
8396: PUSH
8397: LD_VAR 0 4
8401: ARRAY
8402: PPUSH
8403: CALL_OW 254
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: EMPTY
8415: LIST
8416: ADD
8417: ST_TO_ADDR
// end ;
8418: GO 8331
8420: POP
8421: POP
// result := tmp ;
8422: LD_ADDR_VAR 0 3
8426: PUSH
8427: LD_VAR 0 5
8431: ST_TO_ADDR
// end ;
8432: LD_VAR 0 3
8436: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
8437: LD_INT 0
8439: PPUSH
8440: PPUSH
8441: PPUSH
// for i = 1 to list do
8442: LD_ADDR_VAR 0 4
8446: PUSH
8447: DOUBLE
8448: LD_INT 1
8450: DEC
8451: ST_TO_ADDR
8452: LD_VAR 0 2
8456: PUSH
8457: FOR_TO
8458: IFFALSE 9013
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
8460: LD_VAR 0 2
8464: PUSH
8465: LD_VAR 0 4
8469: ARRAY
8470: PUSH
8471: LD_INT 1
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 2
8479: PUSH
8480: LD_VAR 0 4
8484: ARRAY
8485: PUSH
8486: LD_INT 2
8488: ARRAY
8489: PPUSH
8490: CALL_OW 428
8494: PUSH
8495: LD_INT 0
8497: GREATER
8498: IFFALSE 8784
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
8500: LD_VAR 0 2
8504: PUSH
8505: LD_VAR 0 4
8509: ARRAY
8510: PUSH
8511: LD_INT 1
8513: ARRAY
8514: PPUSH
8515: LD_VAR 0 2
8519: PUSH
8520: LD_VAR 0 4
8524: ARRAY
8525: PUSH
8526: LD_INT 2
8528: ARRAY
8529: PPUSH
8530: CALL_OW 428
8534: PPUSH
8535: CALL_OW 248
8539: PUSH
8540: LD_INT 3
8542: EQUAL
8543: IFFALSE 8669
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
8545: LD_VAR 0 2
8549: PUSH
8550: LD_VAR 0 4
8554: ARRAY
8555: PUSH
8556: LD_INT 1
8558: ARRAY
8559: PPUSH
8560: LD_VAR 0 2
8564: PUSH
8565: LD_VAR 0 4
8569: ARRAY
8570: PUSH
8571: LD_INT 2
8573: ARRAY
8574: PPUSH
8575: CALL_OW 428
8579: PPUSH
8580: CALL_OW 274
8584: PPUSH
8585: LD_INT 3
8587: PPUSH
8588: CALL_OW 275
8592: PUSH
8593: LD_INT 15
8595: GREATEREQUAL
8596: IFFALSE 8667
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
8598: LD_VAR 0 2
8602: PUSH
8603: LD_VAR 0 4
8607: ARRAY
8608: PUSH
8609: LD_INT 1
8611: ARRAY
8612: PPUSH
8613: LD_VAR 0 2
8617: PUSH
8618: LD_VAR 0 4
8622: ARRAY
8623: PUSH
8624: LD_INT 2
8626: ARRAY
8627: PPUSH
8628: CALL_OW 428
8632: PPUSH
8633: LD_VAR 0 2
8637: PUSH
8638: LD_VAR 0 4
8642: ARRAY
8643: PUSH
8644: LD_INT 4
8646: ARRAY
8647: PPUSH
8648: LD_VAR 0 2
8652: PUSH
8653: LD_VAR 0 4
8657: ARRAY
8658: PUSH
8659: LD_INT 5
8661: ARRAY
8662: PPUSH
8663: CALL 7330 0 3
// end else
8667: GO 8738
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
8669: LD_VAR 0 2
8673: PUSH
8674: LD_VAR 0 4
8678: ARRAY
8679: PUSH
8680: LD_INT 1
8682: ARRAY
8683: PPUSH
8684: LD_VAR 0 2
8688: PUSH
8689: LD_VAR 0 4
8693: ARRAY
8694: PUSH
8695: LD_INT 2
8697: ARRAY
8698: PPUSH
8699: CALL_OW 428
8703: PPUSH
8704: LD_VAR 0 2
8708: PUSH
8709: LD_VAR 0 4
8713: ARRAY
8714: PUSH
8715: LD_INT 4
8717: ARRAY
8718: PPUSH
8719: LD_VAR 0 2
8723: PUSH
8724: LD_VAR 0 4
8728: ARRAY
8729: PUSH
8730: LD_INT 5
8732: ARRAY
8733: PPUSH
8734: CALL 7330 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
8738: LD_VAR 0 1
8742: PPUSH
8743: LD_VAR 0 2
8747: PUSH
8748: LD_VAR 0 4
8752: ARRAY
8753: PUSH
8754: LD_INT 1
8756: ARRAY
8757: PPUSH
8758: LD_VAR 0 2
8762: PUSH
8763: LD_VAR 0 4
8767: ARRAY
8768: PUSH
8769: LD_INT 2
8771: ARRAY
8772: PPUSH
8773: CALL_OW 428
8777: PPUSH
8778: CALL 10386 0 2
// end else
8782: GO 9011
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
8784: LD_VAR 0 1
8788: PUSH
8789: LD_INT 1
8791: ARRAY
8792: PPUSH
8793: CALL_OW 255
8797: PPUSH
8798: CALL 6072 0 1
8802: PPUSH
8803: LD_INT 6
8805: PPUSH
8806: CALL 5648 0 2
8810: PUSH
8811: LD_VAR 0 1
8815: PUSH
8816: LD_INT 1
8818: ARRAY
8819: PPUSH
8820: CALL_OW 255
8824: PPUSH
8825: CALL 6072 0 1
8829: PPUSH
8830: LD_VAR 0 2
8834: PUSH
8835: LD_VAR 0 4
8839: ARRAY
8840: PUSH
8841: LD_INT 4
8843: ARRAY
8844: PPUSH
8845: CALL 5648 0 2
8849: AND
8850: PUSH
8851: LD_VAR 0 1
8855: PUSH
8856: LD_INT 1
8858: ARRAY
8859: PPUSH
8860: CALL_OW 255
8864: PPUSH
8865: CALL 6072 0 1
8869: PPUSH
8870: LD_VAR 0 2
8874: PUSH
8875: LD_VAR 0 4
8879: ARRAY
8880: PUSH
8881: LD_INT 5
8883: ARRAY
8884: PPUSH
8885: CALL 5648 0 2
8889: AND
8890: IFFALSE 9011
// for p = 1 to plist do
8892: LD_ADDR_VAR 0 5
8896: PUSH
8897: DOUBLE
8898: LD_INT 1
8900: DEC
8901: ST_TO_ADDR
8902: LD_VAR 0 1
8906: PUSH
8907: FOR_TO
8908: IFFALSE 9009
// if IsInUnit ( plist [ p ] ) then
8910: LD_VAR 0 1
8914: PUSH
8915: LD_VAR 0 5
8919: ARRAY
8920: PPUSH
8921: CALL_OW 310
8925: IFFALSE 8944
// ComExitBuilding ( plist [ p ] ) else
8927: LD_VAR 0 1
8931: PUSH
8932: LD_VAR 0 5
8936: ARRAY
8937: PPUSH
8938: CALL_OW 122
8942: GO 9007
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
8944: LD_VAR 0 1
8948: PUSH
8949: LD_VAR 0 5
8953: ARRAY
8954: PPUSH
8955: LD_INT 6
8957: PPUSH
8958: LD_VAR 0 2
8962: PUSH
8963: LD_VAR 0 4
8967: ARRAY
8968: PUSH
8969: LD_INT 1
8971: ARRAY
8972: PPUSH
8973: LD_VAR 0 2
8977: PUSH
8978: LD_VAR 0 4
8982: ARRAY
8983: PUSH
8984: LD_INT 2
8986: ARRAY
8987: PPUSH
8988: LD_VAR 0 2
8992: PUSH
8993: LD_VAR 0 4
8997: ARRAY
8998: PUSH
8999: LD_INT 3
9001: ARRAY
9002: PPUSH
9003: CALL_OW 145
9007: GO 8907
9009: POP
9010: POP
// end ;
9011: GO 8457
9013: POP
9014: POP
// end ;
9015: LD_VAR 0 3
9019: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9020: LD_INT 0
9022: PPUSH
// if IsInUnit ( sci ) then
9023: LD_VAR 0 1
9027: PPUSH
9028: CALL_OW 310
9032: IFFALSE 9045
// ComExitBuilding ( sci ) else
9034: LD_VAR 0 1
9038: PPUSH
9039: CALL_OW 122
9043: GO 9076
// if not HasTask ( sci ) then
9045: LD_VAR 0 1
9049: PPUSH
9050: CALL_OW 314
9054: NOT
9055: IFFALSE 9076
// begin ComMoveXY ( sci , x , y ) ;
9057: LD_VAR 0 1
9061: PPUSH
9062: LD_VAR 0 2
9066: PPUSH
9067: LD_VAR 0 3
9071: PPUSH
9072: CALL_OW 111
// end ; end ;
9076: LD_VAR 0 4
9080: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9081: LD_INT 0
9083: PPUSH
9084: PPUSH
9085: PPUSH
9086: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9087: LD_ADDR_VAR 0 6
9091: PUSH
9092: LD_INT 22
9094: PUSH
9095: LD_VAR 0 1
9099: PUSH
9100: EMPTY
9101: LIST
9102: LIST
9103: PUSH
9104: LD_INT 21
9106: PUSH
9107: LD_INT 1
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: PUSH
9114: EMPTY
9115: LIST
9116: LIST
9117: PPUSH
9118: CALL_OW 69
9122: PUSH
9123: LD_VAR 0 3
9127: DIFF
9128: ST_TO_ADDR
// tmp := tag_list ;
9129: LD_ADDR_VAR 0 7
9133: PUSH
9134: LD_VAR 0 2
9138: ST_TO_ADDR
// for i = 1 to filter do
9139: LD_ADDR_VAR 0 5
9143: PUSH
9144: DOUBLE
9145: LD_INT 1
9147: DEC
9148: ST_TO_ADDR
9149: LD_VAR 0 6
9153: PUSH
9154: FOR_TO
9155: IFFALSE 9424
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9157: LD_VAR 0 6
9161: PUSH
9162: LD_VAR 0 5
9166: ARRAY
9167: PPUSH
9168: CALL_OW 256
9172: PUSH
9173: LD_INT 1000
9175: EQUAL
9176: PUSH
9177: LD_VAR 0 6
9181: PUSH
9182: LD_VAR 0 5
9186: ARRAY
9187: PPUSH
9188: CALL_OW 110
9192: PUSH
9193: LD_INT 100
9195: GREATEREQUAL
9196: AND
9197: IFFALSE 9239
// begin SetTag ( filter [ i ] , 0 ) ;
9199: LD_VAR 0 6
9203: PUSH
9204: LD_VAR 0 5
9208: ARRAY
9209: PPUSH
9210: LD_INT 0
9212: PPUSH
9213: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9217: LD_ADDR_VAR 0 7
9221: PUSH
9222: LD_VAR 0 7
9226: PUSH
9227: LD_VAR 0 6
9231: PUSH
9232: LD_VAR 0 5
9236: ARRAY
9237: DIFF
9238: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9239: LD_VAR 0 6
9243: PUSH
9244: LD_VAR 0 5
9248: ARRAY
9249: PPUSH
9250: CALL_OW 256
9254: PUSH
9255: LD_INT 1000
9257: LESS
9258: IFFALSE 9422
// begin if not filter [ i ] in tmp then
9260: LD_VAR 0 6
9264: PUSH
9265: LD_VAR 0 5
9269: ARRAY
9270: PUSH
9271: LD_VAR 0 7
9275: IN
9276: NOT
9277: IFFALSE 9301
// tmp := tmp ^ filter [ i ] ;
9279: LD_ADDR_VAR 0 7
9283: PUSH
9284: LD_VAR 0 7
9288: PUSH
9289: LD_VAR 0 6
9293: PUSH
9294: LD_VAR 0 5
9298: ARRAY
9299: ADD
9300: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9301: LD_VAR 0 6
9305: PUSH
9306: LD_VAR 0 5
9310: ARRAY
9311: PPUSH
9312: CALL_OW 256
9316: PUSH
9317: LD_INT 250
9319: LESS
9320: IFFALSE 9342
// SetTag ( filter [ i ] , 100 ) else
9322: LD_VAR 0 6
9326: PUSH
9327: LD_VAR 0 5
9331: ARRAY
9332: PPUSH
9333: LD_INT 100
9335: PPUSH
9336: CALL_OW 109
9340: GO 9422
// if GetLives ( filter [ i ] ) < 500 then
9342: LD_VAR 0 6
9346: PUSH
9347: LD_VAR 0 5
9351: ARRAY
9352: PPUSH
9353: CALL_OW 256
9357: PUSH
9358: LD_INT 500
9360: LESS
9361: IFFALSE 9383
// SetTag ( filter [ i ] , 101 ) else
9363: LD_VAR 0 6
9367: PUSH
9368: LD_VAR 0 5
9372: ARRAY
9373: PPUSH
9374: LD_INT 101
9376: PPUSH
9377: CALL_OW 109
9381: GO 9422
// if GetLives ( filter [ i ] ) < 1000 then
9383: LD_VAR 0 6
9387: PUSH
9388: LD_VAR 0 5
9392: ARRAY
9393: PPUSH
9394: CALL_OW 256
9398: PUSH
9399: LD_INT 1000
9401: LESS
9402: IFFALSE 9422
// SetTag ( filter [ i ] , 102 ) ;
9404: LD_VAR 0 6
9408: PUSH
9409: LD_VAR 0 5
9413: ARRAY
9414: PPUSH
9415: LD_INT 102
9417: PPUSH
9418: CALL_OW 109
// end ; end ;
9422: GO 9154
9424: POP
9425: POP
// result := tmp ;
9426: LD_ADDR_VAR 0 4
9430: PUSH
9431: LD_VAR 0 7
9435: ST_TO_ADDR
// end ;
9436: LD_VAR 0 4
9440: RET
// export function WantHeal ( sci , tag ) ; begin
9441: LD_INT 0
9443: PPUSH
// if GetTaskList ( sci ) > 0 then
9444: LD_VAR 0 1
9448: PPUSH
9449: CALL_OW 437
9453: PUSH
9454: LD_INT 0
9456: GREATER
9457: IFFALSE 9532
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
9459: LD_VAR 0 1
9463: PPUSH
9464: CALL_OW 437
9468: PUSH
9469: LD_INT 1
9471: ARRAY
9472: PUSH
9473: LD_INT 1
9475: ARRAY
9476: PUSH
9477: LD_STRING l
9479: EQUAL
9480: PUSH
9481: LD_VAR 0 1
9485: PPUSH
9486: CALL_OW 437
9490: PUSH
9491: LD_INT 1
9493: ARRAY
9494: PUSH
9495: LD_INT 4
9497: ARRAY
9498: PPUSH
9499: CALL_OW 110
9503: PUSH
9504: LD_VAR 0 2
9508: EQUAL
9509: AND
9510: IFFALSE 9522
// result := true else
9512: LD_ADDR_VAR 0 3
9516: PUSH
9517: LD_INT 1
9519: ST_TO_ADDR
9520: GO 9530
// result := false ;
9522: LD_ADDR_VAR 0 3
9526: PUSH
9527: LD_INT 0
9529: ST_TO_ADDR
// end else
9530: GO 9540
// result := false ;
9532: LD_ADDR_VAR 0 3
9536: PUSH
9537: LD_INT 0
9539: ST_TO_ADDR
// end ;
9540: LD_VAR 0 3
9544: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
9545: LD_INT 0
9547: PPUSH
9548: PPUSH
9549: PPUSH
9550: PPUSH
9551: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9552: LD_ADDR_VAR 0 7
9556: PUSH
9557: LD_INT 22
9559: PUSH
9560: LD_VAR 0 2
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: PUSH
9569: LD_INT 3
9571: PUSH
9572: LD_INT 21
9574: PUSH
9575: LD_INT 3
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PUSH
9582: EMPTY
9583: LIST
9584: LIST
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: PPUSH
9590: CALL_OW 69
9594: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
9595: LD_ADDR_VAR 0 5
9599: PUSH
9600: LD_INT 1
9602: PPUSH
9603: LD_INT 3
9605: PPUSH
9606: CALL_OW 12
9610: ST_TO_ADDR
// if filter > 0 then
9611: LD_VAR 0 7
9615: PUSH
9616: LD_INT 0
9618: GREATER
9619: IFFALSE 9821
// for i = 1 to list do
9621: LD_ADDR_VAR 0 6
9625: PUSH
9626: DOUBLE
9627: LD_INT 1
9629: DEC
9630: ST_TO_ADDR
9631: LD_VAR 0 1
9635: PUSH
9636: FOR_TO
9637: IFFALSE 9819
// for ta in filter do
9639: LD_ADDR_VAR 0 4
9643: PUSH
9644: LD_VAR 0 7
9648: PUSH
9649: FOR_IN
9650: IFFALSE 9815
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
9652: LD_VAR 0 1
9656: PUSH
9657: LD_VAR 0 6
9661: ARRAY
9662: PPUSH
9663: LD_VAR 0 4
9667: PPUSH
9668: CALL_OW 296
9672: PUSH
9673: LD_INT 13
9675: LESSEQUAL
9676: IFFALSE 9813
// begin case c of 1 :
9678: LD_VAR 0 5
9682: PUSH
9683: LD_INT 1
9685: DOUBLE
9686: EQUAL
9687: IFTRUE 9691
9689: GO 9729
9691: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
9692: LD_VAR 0 1
9696: PUSH
9697: LD_VAR 0 6
9701: ARRAY
9702: PPUSH
9703: LD_VAR 0 4
9707: PPUSH
9708: CALL_OW 250
9712: PPUSH
9713: LD_VAR 0 4
9717: PPUSH
9718: CALL_OW 251
9722: PPUSH
9723: CALL_OW 154
9727: GO 9813
9729: LD_INT 2
9731: DOUBLE
9732: EQUAL
9733: IFTRUE 9737
9735: GO 9801
9737: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
9738: LD_VAR 0 1
9742: PUSH
9743: LD_VAR 0 6
9747: ARRAY
9748: PPUSH
9749: LD_VAR 0 4
9753: PPUSH
9754: CALL_OW 250
9758: PUSH
9759: LD_INT 1
9761: NEG
9762: PPUSH
9763: LD_INT 1
9765: PPUSH
9766: CALL_OW 12
9770: PLUS
9771: PPUSH
9772: LD_VAR 0 4
9776: PPUSH
9777: CALL_OW 251
9781: PUSH
9782: LD_INT 1
9784: NEG
9785: PPUSH
9786: LD_INT 1
9788: PPUSH
9789: CALL_OW 12
9793: PLUS
9794: PPUSH
9795: CALL_OW 153
9799: GO 9813
9801: LD_INT 3
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9812
9809: POP
// ; end ;
9810: GO 9813
9812: POP
// end ; end ;
9813: GO 9649
9815: POP
9816: POP
9817: GO 9636
9819: POP
9820: POP
// end ;
9821: LD_VAR 0 3
9825: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
9826: LD_INT 0
9828: PPUSH
9829: PPUSH
// for i = 1 to plist do
9830: LD_ADDR_VAR 0 3
9834: PUSH
9835: DOUBLE
9836: LD_INT 1
9838: DEC
9839: ST_TO_ADDR
9840: LD_VAR 0 1
9844: PUSH
9845: FOR_TO
9846: IFFALSE 10048
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
9848: LD_VAR 0 1
9852: PUSH
9853: LD_VAR 0 3
9857: ARRAY
9858: PPUSH
9859: CALL_OW 310
9863: PUSH
9864: LD_INT 30
9866: PUSH
9867: LD_INT 5
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PUSH
9874: EMPTY
9875: LIST
9876: PPUSH
9877: CALL_OW 69
9881: IN
9882: NOT
9883: IFFALSE 10028
// begin if IsInUnit ( plist [ i ] ) then
9885: LD_VAR 0 1
9889: PUSH
9890: LD_VAR 0 3
9894: ARRAY
9895: PPUSH
9896: CALL_OW 310
9900: IFFALSE 9919
// ComExitBuilding ( plist [ i ] ) else
9902: LD_VAR 0 1
9906: PUSH
9907: LD_VAR 0 3
9911: ARRAY
9912: PPUSH
9913: CALL_OW 122
9917: GO 10026
// if not HasTask ( plist [ i ] ) then
9919: LD_VAR 0 1
9923: PUSH
9924: LD_VAR 0 3
9928: ARRAY
9929: PPUSH
9930: CALL_OW 314
9934: NOT
9935: IFFALSE 10026
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
9937: LD_VAR 0 1
9941: PUSH
9942: LD_VAR 0 3
9946: ARRAY
9947: PPUSH
9948: LD_INT 22
9950: PUSH
9951: LD_VAR 0 1
9955: PUSH
9956: LD_INT 1
9958: ARRAY
9959: PPUSH
9960: CALL_OW 255
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: PUSH
9969: LD_INT 30
9971: PUSH
9972: LD_INT 5
9974: PUSH
9975: EMPTY
9976: LIST
9977: LIST
9978: PUSH
9979: EMPTY
9980: LIST
9981: LIST
9982: PPUSH
9983: CALL_OW 69
9987: PPUSH
9988: LD_VAR 0 1
9992: PUSH
9993: LD_VAR 0 3
9997: ARRAY
9998: PPUSH
9999: CALL_OW 74
10003: PPUSH
10004: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10008: LD_VAR 0 1
10012: PUSH
10013: LD_VAR 0 3
10017: ARRAY
10018: PPUSH
10019: LD_INT 9
10021: PPUSH
10022: CALL_OW 183
// end ; end else
10026: GO 10046
// ComChangeProfession ( plist [ i ] , 9 ) ;
10028: LD_VAR 0 1
10032: PUSH
10033: LD_VAR 0 3
10037: ARRAY
10038: PPUSH
10039: LD_INT 9
10041: PPUSH
10042: CALL_OW 123
10046: GO 9845
10048: POP
10049: POP
// end ;
10050: LD_VAR 0 2
10054: RET
// export function GetHuman ( side ) ; begin
10055: LD_INT 0
10057: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10058: LD_ADDR_VAR 0 2
10062: PUSH
10063: LD_INT 22
10065: PUSH
10066: LD_VAR 0 1
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: PUSH
10075: LD_INT 21
10077: PUSH
10078: LD_INT 1
10080: PUSH
10081: EMPTY
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 2
10087: PUSH
10088: LD_INT 25
10090: PUSH
10091: LD_INT 1
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: LD_INT 25
10100: PUSH
10101: LD_INT 2
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: PUSH
10108: LD_INT 25
10110: PUSH
10111: LD_INT 3
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: PUSH
10118: LD_INT 25
10120: PUSH
10121: LD_INT 4
10123: PUSH
10124: EMPTY
10125: LIST
10126: LIST
10127: PUSH
10128: EMPTY
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: PUSH
10135: EMPTY
10136: LIST
10137: LIST
10138: LIST
10139: PPUSH
10140: CALL_OW 69
10144: ST_TO_ADDR
// end ;
10145: LD_VAR 0 2
10149: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10150: LD_INT 0
10152: PPUSH
10153: PPUSH
10154: PPUSH
// uc_side := 0 ;
10155: LD_ADDR_OWVAR 20
10159: PUSH
10160: LD_INT 0
10162: ST_TO_ADDR
// uc_nation := 0 ;
10163: LD_ADDR_OWVAR 21
10167: PUSH
10168: LD_INT 0
10170: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10171: LD_ADDR_VAR 0 4
10175: PUSH
10176: DOUBLE
10177: LD_INT 1
10179: DEC
10180: ST_TO_ADDR
10181: LD_INT 4
10183: PUSH
10184: LD_INT 5
10186: PUSH
10187: LD_INT 6
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: PUSH
10195: LD_OWVAR 67
10199: ARRAY
10200: PUSH
10201: FOR_TO
10202: IFFALSE 10273
// begin hc_class = class_tiger ;
10204: LD_ADDR_OWVAR 28
10208: PUSH
10209: LD_INT 14
10211: ST_TO_ADDR
// hc_gallery = sandnature ;
10212: LD_ADDR_OWVAR 33
10216: PUSH
10217: LD_STRING sandnature
10219: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10220: LD_ADDR_OWVAR 35
10224: PUSH
10225: LD_INT 0
10227: PPUSH
10228: LD_INT 50
10230: PPUSH
10231: CALL_OW 12
10235: ST_TO_ADDR
// hc_face_number = 3 ;
10236: LD_ADDR_OWVAR 34
10240: PUSH
10241: LD_INT 3
10243: ST_TO_ADDR
// tiger := CreateHuman ;
10244: LD_ADDR_VAR 0 3
10248: PUSH
10249: CALL_OW 44
10253: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10254: LD_VAR 0 3
10258: PPUSH
10259: LD_VAR 0 1
10263: PPUSH
10264: LD_INT 0
10266: PPUSH
10267: CALL_OW 49
// end ;
10271: GO 10201
10273: POP
10274: POP
// end ;
10275: LD_VAR 0 2
10279: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10280: LD_INT 0
10282: PPUSH
10283: PPUSH
10284: PPUSH
// uc_side := 0 ;
10285: LD_ADDR_OWVAR 20
10289: PUSH
10290: LD_INT 0
10292: ST_TO_ADDR
// uc_nation := 0 ;
10293: LD_ADDR_OWVAR 21
10297: PUSH
10298: LD_INT 0
10300: ST_TO_ADDR
// for i = 1 to 8 do
10301: LD_ADDR_VAR 0 4
10305: PUSH
10306: DOUBLE
10307: LD_INT 1
10309: DEC
10310: ST_TO_ADDR
10311: LD_INT 8
10313: PUSH
10314: FOR_TO
10315: IFFALSE 10379
// begin hc_class = class_apeman ;
10317: LD_ADDR_OWVAR 28
10321: PUSH
10322: LD_INT 12
10324: ST_TO_ADDR
// hc_gallery =  ;
10325: LD_ADDR_OWVAR 33
10329: PUSH
10330: LD_STRING 
10332: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10333: LD_ADDR_OWVAR 35
10337: PUSH
10338: LD_INT 5
10340: NEG
10341: PPUSH
10342: LD_INT 20
10344: PPUSH
10345: CALL_OW 12
10349: ST_TO_ADDR
// ape := CreateHuman ;
10350: LD_ADDR_VAR 0 3
10354: PUSH
10355: CALL_OW 44
10359: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10360: LD_VAR 0 3
10364: PPUSH
10365: LD_VAR 0 1
10369: PPUSH
10370: LD_INT 0
10372: PPUSH
10373: CALL_OW 49
// end ;
10377: GO 10314
10379: POP
10380: POP
// end ;
10381: LD_VAR 0 2
10385: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
10386: LD_INT 0
10388: PPUSH
10389: PPUSH
// if BuildingStatus ( b ) = bs_build then
10390: LD_VAR 0 2
10394: PPUSH
10395: CALL_OW 461
10399: PUSH
10400: LD_INT 1
10402: EQUAL
10403: IFFALSE 10589
// for i = 1 to plist do
10405: LD_ADDR_VAR 0 4
10409: PUSH
10410: DOUBLE
10411: LD_INT 1
10413: DEC
10414: ST_TO_ADDR
10415: LD_VAR 0 1
10419: PUSH
10420: FOR_TO
10421: IFFALSE 10587
// if IsInUnit ( plist [ i ] ) then
10423: LD_VAR 0 1
10427: PUSH
10428: LD_VAR 0 4
10432: ARRAY
10433: PPUSH
10434: CALL_OW 310
10438: IFFALSE 10521
// begin ComExitBuilding ( plist [ i ] ) ;
10440: LD_VAR 0 1
10444: PUSH
10445: LD_VAR 0 4
10449: ARRAY
10450: PPUSH
10451: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
10455: LD_VAR 0 1
10459: PUSH
10460: LD_VAR 0 4
10464: ARRAY
10465: PPUSH
10466: LD_STRING h
10468: PUSH
10469: LD_VAR 0 2
10473: PPUSH
10474: CALL_OW 250
10478: PUSH
10479: LD_VAR 0 2
10483: PPUSH
10484: CALL_OW 251
10488: PUSH
10489: LD_VAR 0 2
10493: PUSH
10494: LD_INT 0
10496: PUSH
10497: LD_INT 0
10499: PUSH
10500: LD_INT 0
10502: PUSH
10503: EMPTY
10504: LIST
10505: LIST
10506: LIST
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: PUSH
10512: EMPTY
10513: LIST
10514: PPUSH
10515: CALL_OW 447
// end else
10519: GO 10585
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
10521: LD_VAR 0 1
10525: PUSH
10526: LD_VAR 0 4
10530: ARRAY
10531: PPUSH
10532: LD_STRING h
10534: PUSH
10535: LD_VAR 0 2
10539: PPUSH
10540: CALL_OW 250
10544: PUSH
10545: LD_VAR 0 2
10549: PPUSH
10550: CALL_OW 251
10554: PUSH
10555: LD_VAR 0 2
10559: PUSH
10560: LD_INT 0
10562: PUSH
10563: LD_INT 0
10565: PUSH
10566: LD_INT 0
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: PUSH
10578: EMPTY
10579: LIST
10580: PPUSH
10581: CALL_OW 446
10585: GO 10420
10587: POP
10588: POP
// end ;
10589: LD_VAR 0 3
10593: RET
// export function WantRepair ( eng ) ; begin
10594: LD_INT 0
10596: PPUSH
// if GetTaskList ( eng ) > 0 then
10597: LD_VAR 0 1
10601: PPUSH
10602: CALL_OW 437
10606: PUSH
10607: LD_INT 0
10609: GREATER
10610: IFFALSE 10655
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
10612: LD_VAR 0 1
10616: PPUSH
10617: CALL_OW 437
10621: PUSH
10622: LD_INT 1
10624: ARRAY
10625: PUSH
10626: LD_INT 1
10628: ARRAY
10629: PUSH
10630: LD_STRING o
10632: EQUAL
10633: IFFALSE 10645
// result := true else
10635: LD_ADDR_VAR 0 2
10639: PUSH
10640: LD_INT 1
10642: ST_TO_ADDR
10643: GO 10653
// result := false ;
10645: LD_ADDR_VAR 0 2
10649: PUSH
10650: LD_INT 0
10652: ST_TO_ADDR
// end else
10653: GO 10663
// result := false ;
10655: LD_ADDR_VAR 0 2
10659: PUSH
10660: LD_INT 0
10662: ST_TO_ADDR
// end ;
10663: LD_VAR 0 2
10667: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
10668: LD_INT 0
10670: PPUSH
10671: PPUSH
10672: PPUSH
10673: PPUSH
// if btype = - 1 then
10674: LD_VAR 0 2
10678: PUSH
10679: LD_INT 1
10681: NEG
10682: EQUAL
10683: IFFALSE 10723
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
10685: LD_ADDR_VAR 0 5
10689: PUSH
10690: LD_INT 22
10692: PUSH
10693: LD_VAR 0 1
10697: PUSH
10698: EMPTY
10699: LIST
10700: LIST
10701: PUSH
10702: LD_INT 21
10704: PUSH
10705: LD_INT 3
10707: PUSH
10708: EMPTY
10709: LIST
10710: LIST
10711: PUSH
10712: EMPTY
10713: LIST
10714: LIST
10715: PPUSH
10716: CALL_OW 69
10720: ST_TO_ADDR
10721: GO 10761
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
10723: LD_ADDR_VAR 0 5
10727: PUSH
10728: LD_INT 22
10730: PUSH
10731: LD_VAR 0 1
10735: PUSH
10736: EMPTY
10737: LIST
10738: LIST
10739: PUSH
10740: LD_INT 30
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: EMPTY
10749: LIST
10750: LIST
10751: PUSH
10752: EMPTY
10753: LIST
10754: LIST
10755: PPUSH
10756: CALL_OW 69
10760: ST_TO_ADDR
// list := [ ] ;
10761: LD_ADDR_VAR 0 6
10765: PUSH
10766: EMPTY
10767: ST_TO_ADDR
// for i = 1 to tmp do
10768: LD_ADDR_VAR 0 4
10772: PUSH
10773: DOUBLE
10774: LD_INT 1
10776: DEC
10777: ST_TO_ADDR
10778: LD_VAR 0 5
10782: PUSH
10783: FOR_TO
10784: IFFALSE 10872
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
10786: LD_ADDR_VAR 0 6
10790: PUSH
10791: LD_VAR 0 6
10795: PUSH
10796: LD_VAR 0 5
10800: PUSH
10801: LD_VAR 0 4
10805: ARRAY
10806: PPUSH
10807: CALL_OW 266
10811: PUSH
10812: LD_VAR 0 5
10816: PUSH
10817: LD_VAR 0 4
10821: ARRAY
10822: PPUSH
10823: CALL_OW 250
10827: PUSH
10828: LD_VAR 0 5
10832: PUSH
10833: LD_VAR 0 4
10837: ARRAY
10838: PPUSH
10839: CALL_OW 251
10843: PUSH
10844: LD_VAR 0 5
10848: PUSH
10849: LD_VAR 0 4
10853: ARRAY
10854: PPUSH
10855: CALL_OW 254
10859: PUSH
10860: EMPTY
10861: LIST
10862: LIST
10863: LIST
10864: LIST
10865: PUSH
10866: EMPTY
10867: LIST
10868: ADD
10869: ST_TO_ADDR
10870: GO 10783
10872: POP
10873: POP
// result = list ;
10874: LD_ADDR_VAR 0 3
10878: PUSH
10879: LD_VAR 0 6
10883: ST_TO_ADDR
// end ;
10884: LD_VAR 0 3
10888: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
10889: LD_INT 0
10891: PPUSH
10892: PPUSH
10893: PPUSH
10894: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
10895: LD_VAR 0 1
10899: PPUSH
10900: LD_INT 81
10902: PUSH
10903: LD_VAR 0 1
10907: PPUSH
10908: CALL_OW 255
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PPUSH
10917: CALL_OW 69
10921: PPUSH
10922: LD_VAR 0 1
10926: PPUSH
10927: CALL_OW 74
10931: PPUSH
10932: CALL_OW 296
10936: PUSH
10937: LD_INT 18
10939: LESS
10940: IFFALSE 10985
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
10942: LD_VAR 0 1
10946: PPUSH
10947: LD_INT 81
10949: PUSH
10950: LD_VAR 0 1
10954: PPUSH
10955: CALL_OW 255
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PPUSH
10964: CALL_OW 69
10968: PPUSH
10969: LD_VAR 0 1
10973: PPUSH
10974: CALL_OW 74
10978: PPUSH
10979: CALL_OW 115
10983: GO 11004
// ComMoveXY ( behemoth , x , y ) ;
10985: LD_VAR 0 1
10989: PPUSH
10990: LD_VAR 0 4
10994: PPUSH
10995: LD_VAR 0 5
10999: PPUSH
11000: CALL_OW 111
// if time_lapsers_list > 0 then
11004: LD_VAR 0 2
11008: PUSH
11009: LD_INT 0
11011: GREATER
11012: IFFALSE 11202
// begin for i = 1 to time_lapsers_list do
11014: LD_ADDR_VAR 0 7
11018: PUSH
11019: DOUBLE
11020: LD_INT 1
11022: DEC
11023: ST_TO_ADDR
11024: LD_VAR 0 2
11028: PUSH
11029: FOR_TO
11030: IFFALSE 11200
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11032: LD_VAR 0 2
11036: PUSH
11037: LD_VAR 0 7
11041: ARRAY
11042: PPUSH
11043: CALL_OW 256
11047: PUSH
11048: LD_INT 250
11050: GREATEREQUAL
11051: PUSH
11052: LD_VAR 0 2
11056: PUSH
11057: LD_VAR 0 7
11061: ARRAY
11062: PPUSH
11063: LD_VAR 0 1
11067: PPUSH
11068: CALL_OW 296
11072: PUSH
11073: LD_INT 9
11075: GREATER
11076: AND
11077: IFFALSE 11114
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11079: LD_VAR 0 2
11083: PUSH
11084: LD_VAR 0 7
11088: ARRAY
11089: PPUSH
11090: LD_VAR 0 1
11094: PPUSH
11095: CALL_OW 250
11099: PPUSH
11100: LD_VAR 0 1
11104: PPUSH
11105: CALL_OW 251
11109: PPUSH
11110: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11114: LD_VAR 0 2
11118: PUSH
11119: LD_VAR 0 7
11123: ARRAY
11124: PPUSH
11125: CALL_OW 256
11129: PUSH
11130: LD_INT 500
11132: LESS
11133: PUSH
11134: LD_VAR 0 1
11138: PPUSH
11139: CALL_OW 256
11143: PUSH
11144: LD_INT 700
11146: GREATER
11147: AND
11148: IFFALSE 11198
// for p = 1 to mechanic_list do
11150: LD_ADDR_VAR 0 8
11154: PUSH
11155: DOUBLE
11156: LD_INT 1
11158: DEC
11159: ST_TO_ADDR
11160: LD_VAR 0 3
11164: PUSH
11165: FOR_TO
11166: IFFALSE 11196
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11168: LD_VAR 0 3
11172: PUSH
11173: LD_VAR 0 8
11177: ARRAY
11178: PPUSH
11179: LD_VAR 0 2
11183: PUSH
11184: LD_VAR 0 7
11188: ARRAY
11189: PPUSH
11190: CALL_OW 129
11194: GO 11165
11196: POP
11197: POP
// end ;
11198: GO 11029
11200: POP
11201: POP
// end ; if mechanic_list then
11202: LD_VAR 0 3
11206: IFFALSE 11387
// begin for i = 1 to mechanic_list do
11208: LD_ADDR_VAR 0 7
11212: PUSH
11213: DOUBLE
11214: LD_INT 1
11216: DEC
11217: ST_TO_ADDR
11218: LD_VAR 0 3
11222: PUSH
11223: FOR_TO
11224: IFFALSE 11385
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11226: LD_VAR 0 3
11230: PUSH
11231: LD_VAR 0 7
11235: ARRAY
11236: PPUSH
11237: CALL_OW 256
11241: PUSH
11242: LD_INT 333
11244: LESS
11245: IFFALSE 11269
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11247: LD_ADDR_EXP 15
11251: PUSH
11252: LD_EXP 15
11256: PUSH
11257: LD_VAR 0 3
11261: PUSH
11262: LD_VAR 0 7
11266: ARRAY
11267: DIFF
11268: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11269: LD_VAR 0 3
11273: PUSH
11274: LD_VAR 0 7
11278: ARRAY
11279: PPUSH
11280: LD_VAR 0 1
11284: PPUSH
11285: CALL_OW 296
11289: PUSH
11290: LD_INT 9
11292: GREATER
11293: PUSH
11294: LD_VAR 0 3
11298: PUSH
11299: LD_VAR 0 7
11303: ARRAY
11304: PPUSH
11305: CALL_OW 314
11309: NOT
11310: AND
11311: IFFALSE 11348
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11313: LD_VAR 0 3
11317: PUSH
11318: LD_VAR 0 7
11322: ARRAY
11323: PPUSH
11324: LD_VAR 0 1
11328: PPUSH
11329: CALL_OW 250
11333: PPUSH
11334: LD_VAR 0 1
11338: PPUSH
11339: CALL_OW 251
11343: PPUSH
11344: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11348: LD_VAR 0 1
11352: PPUSH
11353: CALL_OW 256
11357: PUSH
11358: LD_INT 700
11360: LESS
11361: IFFALSE 11383
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11363: LD_VAR 0 3
11367: PUSH
11368: LD_VAR 0 7
11372: ARRAY
11373: PPUSH
11374: LD_VAR 0 1
11378: PPUSH
11379: CALL_OW 129
// end ;
11383: GO 11223
11385: POP
11386: POP
// end ; end ;
11387: LD_VAR 0 6
11391: RET
// export function GetBehemoth ( side ) ; begin
11392: LD_INT 0
11394: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
11395: LD_ADDR_VAR 0 2
11399: PUSH
11400: LD_INT 22
11402: PUSH
11403: LD_VAR 0 1
11407: PUSH
11408: EMPTY
11409: LIST
11410: LIST
11411: PUSH
11412: LD_INT 31
11414: PUSH
11415: LD_INT 25
11417: PUSH
11418: EMPTY
11419: LIST
11420: LIST
11421: PUSH
11422: EMPTY
11423: LIST
11424: LIST
11425: PPUSH
11426: CALL_OW 69
11430: ST_TO_ADDR
// end ;
11431: LD_VAR 0 2
11435: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
11436: LD_INT 0
11438: PPUSH
11439: PPUSH
11440: PPUSH
11441: PPUSH
11442: PPUSH
11443: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
11444: LD_ADDR_VAR 0 6
11448: PUSH
11449: LD_VAR 0 2
11453: PPUSH
11454: CALL_OW 435
11458: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
11459: LD_ADDR_VAR 0 5
11463: PUSH
11464: LD_INT 22
11466: PUSH
11467: LD_VAR 0 1
11471: PUSH
11472: EMPTY
11473: LIST
11474: LIST
11475: PUSH
11476: LD_INT 2
11478: PUSH
11479: LD_INT 25
11481: PUSH
11482: LD_INT 2
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PUSH
11489: LD_INT 25
11491: PUSH
11492: LD_INT 16
11494: PUSH
11495: EMPTY
11496: LIST
11497: LIST
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PPUSH
11508: CALL_OW 69
11512: ST_TO_ADDR
// if skr then
11513: LD_VAR 0 6
11517: IFFALSE 11682
// begin if engs then
11519: LD_VAR 0 5
11523: IFFALSE 11682
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
11525: LD_ADDR_VAR 0 8
11529: PUSH
11530: LD_VAR 0 6
11534: PUSH
11535: LD_INT 1
11537: ARRAY
11538: PPUSH
11539: LD_VAR 0 6
11543: PUSH
11544: LD_INT 2
11546: ARRAY
11547: PPUSH
11548: CALL_OW 284
11552: ST_TO_ADDR
// if am > engs then
11553: LD_VAR 0 8
11557: PUSH
11558: LD_VAR 0 5
11562: GREATER
11563: IFFALSE 11575
// am := engs ;
11565: LD_ADDR_VAR 0 8
11569: PUSH
11570: LD_VAR 0 5
11574: ST_TO_ADDR
// for i = 1 to am do
11575: LD_ADDR_VAR 0 7
11579: PUSH
11580: DOUBLE
11581: LD_INT 1
11583: DEC
11584: ST_TO_ADDR
11585: LD_VAR 0 8
11589: PUSH
11590: FOR_TO
11591: IFFALSE 11680
// begin if IsInUnit ( engs [ i ] ) then
11593: LD_VAR 0 5
11597: PUSH
11598: LD_VAR 0 7
11602: ARRAY
11603: PPUSH
11604: CALL_OW 310
11608: IFFALSE 11627
// ComExitBuilding ( engs [ i ] ) else
11610: LD_VAR 0 5
11614: PUSH
11615: LD_VAR 0 7
11619: ARRAY
11620: PPUSH
11621: CALL_OW 122
11625: GO 11678
// if not HasTask ( engs [ i ] ) then
11627: LD_VAR 0 5
11631: PUSH
11632: LD_VAR 0 7
11636: ARRAY
11637: PPUSH
11638: CALL_OW 314
11642: NOT
11643: IFFALSE 11678
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
11645: LD_VAR 0 5
11649: PUSH
11650: LD_VAR 0 7
11654: ARRAY
11655: PPUSH
11656: LD_VAR 0 6
11660: PUSH
11661: LD_INT 1
11663: ARRAY
11664: PPUSH
11665: LD_VAR 0 6
11669: PUSH
11670: LD_INT 2
11672: ARRAY
11673: PPUSH
11674: CALL_OW 117
// end ;
11678: GO 11590
11680: POP
11681: POP
// end ; end ; end ; end_of_file
11682: LD_VAR 0 3
11686: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
11687: LD_INT 0
11689: PPUSH
11690: PPUSH
// uc_side := 1 ;
11691: LD_ADDR_OWVAR 20
11695: PUSH
11696: LD_INT 1
11698: ST_TO_ADDR
// uc_nation := 1 ;
11699: LD_ADDR_OWVAR 21
11703: PUSH
11704: LD_INT 1
11706: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
11707: LD_ADDR_VAR 0 2
11711: PUSH
11712: LD_INT 6
11714: PUSH
11715: LD_INT 5
11717: PUSH
11718: LD_INT 4
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: PUSH
11726: LD_OWVAR 67
11730: ARRAY
11731: ST_TO_ADDR
// game_status := false ;
11732: LD_ADDR_EXP 29
11736: PUSH
11737: LD_INT 0
11739: ST_TO_ADDR
// helps_arrive := false ;
11740: LD_ADDR_EXP 30
11744: PUSH
11745: LD_INT 0
11747: ST_TO_ADDR
// helps_can_arrive := false ;
11748: LD_ADDR_EXP 31
11752: PUSH
11753: LD_INT 0
11755: ST_TO_ADDR
// beta_come := false ;
11756: LD_ADDR_EXP 32
11760: PUSH
11761: LD_INT 0
11763: ST_TO_ADDR
// gamma_come := false ;
11764: LD_ADDR_EXP 33
11768: PUSH
11769: LD_INT 0
11771: ST_TO_ADDR
// zeta_come := false ;
11772: LD_ADDR_EXP 34
11776: PUSH
11777: LD_INT 0
11779: ST_TO_ADDR
// mine_ck := false ;
11780: LD_ADDR_EXP 35
11784: PUSH
11785: LD_INT 0
11787: ST_TO_ADDR
// sib_bomb_constructed := false ;
11788: LD_ADDR_EXP 36
11792: PUSH
11793: LD_INT 0
11795: ST_TO_ADDR
// mine_constructed := false ;
11796: LD_ADDR_EXP 37
11800: PUSH
11801: LD_INT 0
11803: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
11804: LD_INT 35
11806: PPUSH
11807: CALL_OW 274
11811: PPUSH
11812: LD_INT 1
11814: PPUSH
11815: LD_INT 200
11817: PUSH
11818: LD_INT 100
11820: PUSH
11821: LD_INT 70
11823: PUSH
11824: EMPTY
11825: LIST
11826: LIST
11827: LIST
11828: PUSH
11829: LD_OWVAR 67
11833: ARRAY
11834: PPUSH
11835: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
11839: LD_INT 35
11841: PPUSH
11842: LD_INT 4
11844: PPUSH
11845: CALL_OW 235
// hc_importance := 100 ;
11849: LD_ADDR_OWVAR 32
11853: PUSH
11854: LD_INT 100
11856: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
11857: LD_INT 1
11859: PPUSH
11860: LD_INT 2
11862: PPUSH
11863: LD_VAR 0 2
11867: PUSH
11868: LD_INT 1
11870: PLUS
11871: PPUSH
11872: CALL_OW 380
// hc_gallery := hardch ;
11876: LD_ADDR_OWVAR 33
11880: PUSH
11881: LD_STRING hardch
11883: ST_TO_ADDR
// hc_face_number := 1 ;
11884: LD_ADDR_OWVAR 34
11888: PUSH
11889: LD_INT 1
11891: ST_TO_ADDR
// guyA := CreateHuman ;
11892: LD_ADDR_EXP 38
11896: PUSH
11897: CALL_OW 44
11901: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
11902: LD_INT 1
11904: PPUSH
11905: LD_INT 1
11907: PPUSH
11908: LD_VAR 0 2
11912: PPUSH
11913: CALL_OW 380
// hc_face_number := 2 ;
11917: LD_ADDR_OWVAR 34
11921: PUSH
11922: LD_INT 2
11924: ST_TO_ADDR
// guyB := CreateHuman ;
11925: LD_ADDR_EXP 39
11929: PUSH
11930: CALL_OW 44
11934: ST_TO_ADDR
// hc_importance := 0 ;
11935: LD_ADDR_OWVAR 32
11939: PUSH
11940: LD_INT 0
11942: ST_TO_ADDR
// hc_gallery :=  ;
11943: LD_ADDR_OWVAR 33
11947: PUSH
11948: LD_STRING 
11950: ST_TO_ADDR
// end ;
11951: LD_VAR 0 1
11955: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
11956: LD_INT 0
11958: PPUSH
11959: PPUSH
11960: PPUSH
11961: PPUSH
11962: PPUSH
11963: PPUSH
11964: PPUSH
11965: PPUSH
11966: PPUSH
// uc_side := 4 ;
11967: LD_ADDR_OWVAR 20
11971: PUSH
11972: LD_INT 4
11974: ST_TO_ADDR
// uc_nation := 1 ;
11975: LD_ADDR_OWVAR 21
11979: PUSH
11980: LD_INT 1
11982: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
11983: LD_ADDR_VAR 0 10
11987: PUSH
11988: LD_INT 6
11990: PUSH
11991: LD_INT 5
11993: PUSH
11994: LD_INT 4
11996: PUSH
11997: EMPTY
11998: LIST
11999: LIST
12000: LIST
12001: PUSH
12002: LD_OWVAR 67
12006: ARRAY
12007: ST_TO_ADDR
// Beta_Squad := [ ] ;
12008: LD_ADDR_EXP 40
12012: PUSH
12013: EMPTY
12014: ST_TO_ADDR
// case num of 1 :
12015: LD_VAR 0 1
12019: PUSH
12020: LD_INT 1
12022: DOUBLE
12023: EQUAL
12024: IFTRUE 12028
12026: GO 12071
12028: POP
// begin sold := 2 ;
12029: LD_ADDR_VAR 0 5
12033: PUSH
12034: LD_INT 2
12036: ST_TO_ADDR
// sci := 1 ;
12037: LD_ADDR_VAR 0 6
12041: PUSH
12042: LD_INT 1
12044: ST_TO_ADDR
// mech := 2 ;
12045: LD_ADDR_VAR 0 7
12049: PUSH
12050: LD_INT 2
12052: ST_TO_ADDR
// tank := 1 ;
12053: LD_ADDR_VAR 0 8
12057: PUSH
12058: LD_INT 1
12060: ST_TO_ADDR
// cargo := 1 ;
12061: LD_ADDR_VAR 0 9
12065: PUSH
12066: LD_INT 1
12068: ST_TO_ADDR
// end ; 2 :
12069: GO 12174
12071: LD_INT 2
12073: DOUBLE
12074: EQUAL
12075: IFTRUE 12079
12077: GO 12122
12079: POP
// begin sold := 2 ;
12080: LD_ADDR_VAR 0 5
12084: PUSH
12085: LD_INT 2
12087: ST_TO_ADDR
// sci := 1 ;
12088: LD_ADDR_VAR 0 6
12092: PUSH
12093: LD_INT 1
12095: ST_TO_ADDR
// mech := 1 ;
12096: LD_ADDR_VAR 0 7
12100: PUSH
12101: LD_INT 1
12103: ST_TO_ADDR
// tank := 1 ;
12104: LD_ADDR_VAR 0 8
12108: PUSH
12109: LD_INT 1
12111: ST_TO_ADDR
// cargo := 0 ;
12112: LD_ADDR_VAR 0 9
12116: PUSH
12117: LD_INT 0
12119: ST_TO_ADDR
// end ; 3 :
12120: GO 12174
12122: LD_INT 3
12124: DOUBLE
12125: EQUAL
12126: IFTRUE 12130
12128: GO 12173
12130: POP
// begin sold := 1 ;
12131: LD_ADDR_VAR 0 5
12135: PUSH
12136: LD_INT 1
12138: ST_TO_ADDR
// sci := 1 ;
12139: LD_ADDR_VAR 0 6
12143: PUSH
12144: LD_INT 1
12146: ST_TO_ADDR
// mech := 1 ;
12147: LD_ADDR_VAR 0 7
12151: PUSH
12152: LD_INT 1
12154: ST_TO_ADDR
// tank := 1 ;
12155: LD_ADDR_VAR 0 8
12159: PUSH
12160: LD_INT 1
12162: ST_TO_ADDR
// cargo := 0 ;
12163: LD_ADDR_VAR 0 9
12167: PUSH
12168: LD_INT 0
12170: ST_TO_ADDR
// end ; end ;
12171: GO 12174
12173: POP
// for i = 1 to sold do
12174: LD_ADDR_VAR 0 3
12178: PUSH
12179: DOUBLE
12180: LD_INT 1
12182: DEC
12183: ST_TO_ADDR
12184: LD_VAR 0 5
12188: PUSH
12189: FOR_TO
12190: IFFALSE 12262
// begin if i = 1 then
12192: LD_VAR 0 3
12196: PUSH
12197: LD_INT 1
12199: EQUAL
12200: IFFALSE 12219
// PrepareHuman ( sex_male , 1 , skill ) else
12202: LD_INT 1
12204: PPUSH
12205: LD_INT 1
12207: PPUSH
12208: LD_VAR 0 10
12212: PPUSH
12213: CALL_OW 380
12217: GO 12234
// PrepareHuman ( false , 1 , skill ) ;
12219: LD_INT 0
12221: PPUSH
12222: LD_INT 1
12224: PPUSH
12225: LD_VAR 0 10
12229: PPUSH
12230: CALL_OW 380
// un := CreateHuman ;
12234: LD_ADDR_VAR 0 4
12238: PUSH
12239: CALL_OW 44
12243: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12244: LD_ADDR_EXP 40
12248: PUSH
12249: LD_EXP 40
12253: PUSH
12254: LD_VAR 0 4
12258: ADD
12259: ST_TO_ADDR
// end ;
12260: GO 12189
12262: POP
12263: POP
// for i = 1 to mech do
12264: LD_ADDR_VAR 0 3
12268: PUSH
12269: DOUBLE
12270: LD_INT 1
12272: DEC
12273: ST_TO_ADDR
12274: LD_VAR 0 7
12278: PUSH
12279: FOR_TO
12280: IFFALSE 12337
// begin PrepareHuman ( false , 3 , skill ) ;
12282: LD_INT 0
12284: PPUSH
12285: LD_INT 3
12287: PPUSH
12288: LD_VAR 0 10
12292: PPUSH
12293: CALL_OW 380
// un := CreateHuman ;
12297: LD_ADDR_VAR 0 4
12301: PUSH
12302: CALL_OW 44
12306: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12307: LD_VAR 0 4
12311: PPUSH
12312: LD_INT 3
12314: PPUSH
12315: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12319: LD_ADDR_EXP 40
12323: PUSH
12324: LD_EXP 40
12328: PUSH
12329: LD_VAR 0 4
12333: ADD
12334: ST_TO_ADDR
// end ;
12335: GO 12279
12337: POP
12338: POP
// for i = 1 to sci do
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: DOUBLE
12345: LD_INT 1
12347: DEC
12348: ST_TO_ADDR
12349: LD_VAR 0 6
12353: PUSH
12354: FOR_TO
12355: IFFALSE 12400
// begin PrepareHuman ( false , 4 , skill ) ;
12357: LD_INT 0
12359: PPUSH
12360: LD_INT 4
12362: PPUSH
12363: LD_VAR 0 10
12367: PPUSH
12368: CALL_OW 380
// un := CreateHuman ;
12372: LD_ADDR_VAR 0 4
12376: PUSH
12377: CALL_OW 44
12381: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12382: LD_ADDR_EXP 40
12386: PUSH
12387: LD_EXP 40
12391: PUSH
12392: LD_VAR 0 4
12396: ADD
12397: ST_TO_ADDR
// end ;
12398: GO 12354
12400: POP
12401: POP
// for i = 1 to tank do
12402: LD_ADDR_VAR 0 3
12406: PUSH
12407: DOUBLE
12408: LD_INT 1
12410: DEC
12411: ST_TO_ADDR
12412: LD_VAR 0 8
12416: PUSH
12417: FOR_TO
12418: IFFALSE 12531
// begin Randomize ;
12420: CALL_OW 10
// vc_chassis := us_medium_tracked ;
12424: LD_ADDR_OWVAR 37
12428: PUSH
12429: LD_INT 3
12431: ST_TO_ADDR
// vc_engine := engine_solar ;
12432: LD_ADDR_OWVAR 39
12436: PUSH
12437: LD_INT 2
12439: ST_TO_ADDR
// vc_control := control_manual ;
12440: LD_ADDR_OWVAR 38
12444: PUSH
12445: LD_INT 1
12447: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
12448: LD_ADDR_OWVAR 40
12452: PUSH
12453: LD_INT 4
12455: PUSH
12456: LD_INT 5
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: PUSH
12463: LD_INT 1
12465: PPUSH
12466: LD_INT 2
12468: PPUSH
12469: CALL_OW 12
12473: ARRAY
12474: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
12475: LD_ADDR_OWVAR 41
12479: PUSH
12480: LD_INT 35
12482: PPUSH
12483: LD_INT 55
12485: PPUSH
12486: CALL_OW 12
12490: ST_TO_ADDR
// un := CreateVehicle ;
12491: LD_ADDR_VAR 0 4
12495: PUSH
12496: CALL_OW 45
12500: ST_TO_ADDR
// SetTag ( un , 5 ) ;
12501: LD_VAR 0 4
12505: PPUSH
12506: LD_INT 5
12508: PPUSH
12509: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12513: LD_ADDR_EXP 40
12517: PUSH
12518: LD_EXP 40
12522: PUSH
12523: LD_VAR 0 4
12527: ADD
12528: ST_TO_ADDR
// end ;
12529: GO 12417
12531: POP
12532: POP
// if cargo then
12533: LD_VAR 0 9
12537: IFFALSE 12640
// begin vc_chassis := us_medium_tracked ;
12539: LD_ADDR_OWVAR 37
12543: PUSH
12544: LD_INT 3
12546: ST_TO_ADDR
// vc_engine := engine_solar ;
12547: LD_ADDR_OWVAR 39
12551: PUSH
12552: LD_INT 2
12554: ST_TO_ADDR
// vc_control := control_manual ;
12555: LD_ADDR_OWVAR 38
12559: PUSH
12560: LD_INT 1
12562: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
12563: LD_ADDR_OWVAR 40
12567: PUSH
12568: LD_INT 12
12570: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
12571: LD_ADDR_OWVAR 41
12575: PUSH
12576: LD_INT 35
12578: PPUSH
12579: LD_INT 55
12581: PPUSH
12582: CALL_OW 12
12586: ST_TO_ADDR
// un := CreateVehicle ;
12587: LD_ADDR_VAR 0 4
12591: PUSH
12592: CALL_OW 45
12596: ST_TO_ADDR
// SetTag ( un , 5 ) ;
12597: LD_VAR 0 4
12601: PPUSH
12602: LD_INT 5
12604: PPUSH
12605: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12609: LD_ADDR_EXP 40
12613: PUSH
12614: LD_EXP 40
12618: PUSH
12619: LD_VAR 0 4
12623: ADD
12624: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
12625: LD_VAR 0 4
12629: PPUSH
12630: LD_INT 1
12632: PPUSH
12633: LD_INT 60
12635: PPUSH
12636: CALL_OW 290
// end ; end ;
12640: LD_VAR 0 2
12644: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
12645: LD_INT 0
12647: PPUSH
12648: PPUSH
12649: PPUSH
12650: PPUSH
12651: PPUSH
12652: PPUSH
12653: PPUSH
12654: PPUSH
12655: PPUSH
12656: PPUSH
// uc_side := 4 ;
12657: LD_ADDR_OWVAR 20
12661: PUSH
12662: LD_INT 4
12664: ST_TO_ADDR
// uc_nation := 1 ;
12665: LD_ADDR_OWVAR 21
12669: PUSH
12670: LD_INT 1
12672: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12673: LD_ADDR_VAR 0 11
12677: PUSH
12678: LD_INT 6
12680: PUSH
12681: LD_INT 5
12683: PUSH
12684: LD_INT 4
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: LIST
12691: PUSH
12692: LD_OWVAR 67
12696: ARRAY
12697: ST_TO_ADDR
// Gamma_Squad := [ ] ;
12698: LD_ADDR_EXP 41
12702: PUSH
12703: EMPTY
12704: ST_TO_ADDR
// case num of 1 :
12705: LD_VAR 0 1
12709: PUSH
12710: LD_INT 1
12712: DOUBLE
12713: EQUAL
12714: IFTRUE 12718
12716: GO 12769
12718: POP
// begin sold := 2 ;
12719: LD_ADDR_VAR 0 5
12723: PUSH
12724: LD_INT 2
12726: ST_TO_ADDR
// eng := 2 ;
12727: LD_ADDR_VAR 0 6
12731: PUSH
12732: LD_INT 2
12734: ST_TO_ADDR
// sci := 0 ;
12735: LD_ADDR_VAR 0 7
12739: PUSH
12740: LD_INT 0
12742: ST_TO_ADDR
// mech := 1 ;
12743: LD_ADDR_VAR 0 8
12747: PUSH
12748: LD_INT 1
12750: ST_TO_ADDR
// tank := 0 ;
12751: LD_ADDR_VAR 0 9
12755: PUSH
12756: LD_INT 0
12758: ST_TO_ADDR
// cargo := 1 ;
12759: LD_ADDR_VAR 0 10
12763: PUSH
12764: LD_INT 1
12766: ST_TO_ADDR
// end ; 2 :
12767: GO 12888
12769: LD_INT 2
12771: DOUBLE
12772: EQUAL
12773: IFTRUE 12777
12775: GO 12828
12777: POP
// begin sold := 1 ;
12778: LD_ADDR_VAR 0 5
12782: PUSH
12783: LD_INT 1
12785: ST_TO_ADDR
// eng := 2 ;
12786: LD_ADDR_VAR 0 6
12790: PUSH
12791: LD_INT 2
12793: ST_TO_ADDR
// sci := 0 ;
12794: LD_ADDR_VAR 0 7
12798: PUSH
12799: LD_INT 0
12801: ST_TO_ADDR
// mech := 1 ;
12802: LD_ADDR_VAR 0 8
12806: PUSH
12807: LD_INT 1
12809: ST_TO_ADDR
// tank := 0 ;
12810: LD_ADDR_VAR 0 9
12814: PUSH
12815: LD_INT 0
12817: ST_TO_ADDR
// cargo := 1 ;
12818: LD_ADDR_VAR 0 10
12822: PUSH
12823: LD_INT 1
12825: ST_TO_ADDR
// end ; 3 :
12826: GO 12888
12828: LD_INT 3
12830: DOUBLE
12831: EQUAL
12832: IFTRUE 12836
12834: GO 12887
12836: POP
// begin sold := 1 ;
12837: LD_ADDR_VAR 0 5
12841: PUSH
12842: LD_INT 1
12844: ST_TO_ADDR
// eng := 1 ;
12845: LD_ADDR_VAR 0 6
12849: PUSH
12850: LD_INT 1
12852: ST_TO_ADDR
// sci := 0 ;
12853: LD_ADDR_VAR 0 7
12857: PUSH
12858: LD_INT 0
12860: ST_TO_ADDR
// mech := 1 ;
12861: LD_ADDR_VAR 0 8
12865: PUSH
12866: LD_INT 1
12868: ST_TO_ADDR
// tank := 0 ;
12869: LD_ADDR_VAR 0 9
12873: PUSH
12874: LD_INT 0
12876: ST_TO_ADDR
// cargo := 1 ;
12877: LD_ADDR_VAR 0 10
12881: PUSH
12882: LD_INT 1
12884: ST_TO_ADDR
// end ; end ;
12885: GO 12888
12887: POP
// for i = 1 to sold do
12888: LD_ADDR_VAR 0 3
12892: PUSH
12893: DOUBLE
12894: LD_INT 1
12896: DEC
12897: ST_TO_ADDR
12898: LD_VAR 0 5
12902: PUSH
12903: FOR_TO
12904: IFFALSE 12976
// begin if i = 1 then
12906: LD_VAR 0 3
12910: PUSH
12911: LD_INT 1
12913: EQUAL
12914: IFFALSE 12933
// PrepareHuman ( sex_male , 1 , skill ) else
12916: LD_INT 1
12918: PPUSH
12919: LD_INT 1
12921: PPUSH
12922: LD_VAR 0 11
12926: PPUSH
12927: CALL_OW 380
12931: GO 12948
// PrepareHuman ( false , 1 , skill ) ;
12933: LD_INT 0
12935: PPUSH
12936: LD_INT 1
12938: PPUSH
12939: LD_VAR 0 11
12943: PPUSH
12944: CALL_OW 380
// un := CreateHuman ;
12948: LD_ADDR_VAR 0 4
12952: PUSH
12953: CALL_OW 44
12957: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
12958: LD_ADDR_EXP 41
12962: PUSH
12963: LD_EXP 41
12967: PUSH
12968: LD_VAR 0 4
12972: ADD
12973: ST_TO_ADDR
// end ;
12974: GO 12903
12976: POP
12977: POP
// for i = 1 to mech do
12978: LD_ADDR_VAR 0 3
12982: PUSH
12983: DOUBLE
12984: LD_INT 1
12986: DEC
12987: ST_TO_ADDR
12988: LD_VAR 0 8
12992: PUSH
12993: FOR_TO
12994: IFFALSE 13051
// begin PrepareHuman ( false , 3 , skill ) ;
12996: LD_INT 0
12998: PPUSH
12999: LD_INT 3
13001: PPUSH
13002: LD_VAR 0 11
13006: PPUSH
13007: CALL_OW 380
// un := CreateHuman ;
13011: LD_ADDR_VAR 0 4
13015: PUSH
13016: CALL_OW 44
13020: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13021: LD_VAR 0 4
13025: PPUSH
13026: LD_INT 3
13028: PPUSH
13029: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13033: LD_ADDR_EXP 41
13037: PUSH
13038: LD_EXP 41
13042: PUSH
13043: LD_VAR 0 4
13047: ADD
13048: ST_TO_ADDR
// end ;
13049: GO 12993
13051: POP
13052: POP
// for i = 1 to eng do
13053: LD_ADDR_VAR 0 3
13057: PUSH
13058: DOUBLE
13059: LD_INT 1
13061: DEC
13062: ST_TO_ADDR
13063: LD_VAR 0 6
13067: PUSH
13068: FOR_TO
13069: IFFALSE 13114
// begin PrepareHuman ( false , 2 , skill ) ;
13071: LD_INT 0
13073: PPUSH
13074: LD_INT 2
13076: PPUSH
13077: LD_VAR 0 11
13081: PPUSH
13082: CALL_OW 380
// un := CreateHuman ;
13086: LD_ADDR_VAR 0 4
13090: PUSH
13091: CALL_OW 44
13095: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13096: LD_ADDR_EXP 41
13100: PUSH
13101: LD_EXP 41
13105: PUSH
13106: LD_VAR 0 4
13110: ADD
13111: ST_TO_ADDR
// end ;
13112: GO 13068
13114: POP
13115: POP
// for i = 1 to tank do
13116: LD_ADDR_VAR 0 3
13120: PUSH
13121: DOUBLE
13122: LD_INT 1
13124: DEC
13125: ST_TO_ADDR
13126: LD_VAR 0 9
13130: PUSH
13131: FOR_TO
13132: IFFALSE 13245
// begin Randomize ;
13134: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13138: LD_ADDR_OWVAR 37
13142: PUSH
13143: LD_INT 2
13145: ST_TO_ADDR
// vc_engine := engine_siberite ;
13146: LD_ADDR_OWVAR 39
13150: PUSH
13151: LD_INT 3
13153: ST_TO_ADDR
// vc_control := control_manual ;
13154: LD_ADDR_OWVAR 38
13158: PUSH
13159: LD_INT 1
13161: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13162: LD_ADDR_OWVAR 40
13166: PUSH
13167: LD_INT 7
13169: PUSH
13170: LD_INT 9
13172: PUSH
13173: EMPTY
13174: LIST
13175: LIST
13176: PUSH
13177: LD_INT 1
13179: PPUSH
13180: LD_INT 2
13182: PPUSH
13183: CALL_OW 12
13187: ARRAY
13188: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13189: LD_ADDR_OWVAR 41
13193: PUSH
13194: LD_INT 35
13196: PPUSH
13197: LD_INT 55
13199: PPUSH
13200: CALL_OW 12
13204: ST_TO_ADDR
// un := CreateVehicle ;
13205: LD_ADDR_VAR 0 4
13209: PUSH
13210: CALL_OW 45
13214: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13215: LD_VAR 0 4
13219: PPUSH
13220: LD_INT 5
13222: PPUSH
13223: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13227: LD_ADDR_EXP 41
13231: PUSH
13232: LD_EXP 41
13236: PUSH
13237: LD_VAR 0 4
13241: ADD
13242: ST_TO_ADDR
// end ;
13243: GO 13131
13245: POP
13246: POP
// if cargo then
13247: LD_VAR 0 10
13251: IFFALSE 13369
// begin vc_chassis := us_medium_tracked ;
13253: LD_ADDR_OWVAR 37
13257: PUSH
13258: LD_INT 3
13260: ST_TO_ADDR
// vc_engine := engine_combustion ;
13261: LD_ADDR_OWVAR 39
13265: PUSH
13266: LD_INT 1
13268: ST_TO_ADDR
// vc_control := control_manual ;
13269: LD_ADDR_OWVAR 38
13273: PUSH
13274: LD_INT 1
13276: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13277: LD_ADDR_OWVAR 40
13281: PUSH
13282: LD_INT 12
13284: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13285: LD_ADDR_OWVAR 41
13289: PUSH
13290: LD_INT 35
13292: PPUSH
13293: LD_INT 55
13295: PPUSH
13296: CALL_OW 12
13300: ST_TO_ADDR
// un := CreateVehicle ;
13301: LD_ADDR_VAR 0 4
13305: PUSH
13306: CALL_OW 45
13310: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13311: LD_VAR 0 4
13315: PPUSH
13316: LD_INT 5
13318: PPUSH
13319: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13323: LD_ADDR_EXP 41
13327: PUSH
13328: LD_EXP 41
13332: PUSH
13333: LD_VAR 0 4
13337: ADD
13338: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13339: LD_VAR 0 4
13343: PPUSH
13344: LD_INT 3
13346: PPUSH
13347: LD_INT 30
13349: PPUSH
13350: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13354: LD_VAR 0 4
13358: PPUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 40
13364: PPUSH
13365: CALL_OW 290
// end ; end ;
13369: LD_VAR 0 2
13373: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13374: LD_INT 0
13376: PPUSH
13377: PPUSH
13378: PPUSH
13379: PPUSH
13380: PPUSH
13381: PPUSH
13382: PPUSH
13383: PPUSH
13384: PPUSH
13385: PPUSH
// uc_side := 4 ;
13386: LD_ADDR_OWVAR 20
13390: PUSH
13391: LD_INT 4
13393: ST_TO_ADDR
// uc_nation := 1 ;
13394: LD_ADDR_OWVAR 21
13398: PUSH
13399: LD_INT 1
13401: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13402: LD_ADDR_VAR 0 10
13406: PUSH
13407: LD_INT 6
13409: PUSH
13410: LD_INT 5
13412: PUSH
13413: LD_INT 4
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: LIST
13420: PUSH
13421: LD_OWVAR 67
13425: ARRAY
13426: ST_TO_ADDR
// Zeta_Squad := [ ] ;
13427: LD_ADDR_EXP 42
13431: PUSH
13432: EMPTY
13433: ST_TO_ADDR
// sold := 1 ;
13434: LD_ADDR_VAR 0 4
13438: PUSH
13439: LD_INT 1
13441: ST_TO_ADDR
// eng := 0 ;
13442: LD_ADDR_VAR 0 5
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// sci := 0 ;
13450: LD_ADDR_VAR 0 6
13454: PUSH
13455: LD_INT 0
13457: ST_TO_ADDR
// mech := 3 ;
13458: LD_ADDR_VAR 0 7
13462: PUSH
13463: LD_INT 3
13465: ST_TO_ADDR
// tank := 3 ;
13466: LD_ADDR_VAR 0 8
13470: PUSH
13471: LD_INT 3
13473: ST_TO_ADDR
// cargo := 0 ;
13474: LD_ADDR_VAR 0 9
13478: PUSH
13479: LD_INT 0
13481: ST_TO_ADDR
// for i = 1 to sold do
13482: LD_ADDR_VAR 0 2
13486: PUSH
13487: DOUBLE
13488: LD_INT 1
13490: DEC
13491: ST_TO_ADDR
13492: LD_VAR 0 4
13496: PUSH
13497: FOR_TO
13498: IFFALSE 13570
// begin if i = 1 then
13500: LD_VAR 0 2
13504: PUSH
13505: LD_INT 1
13507: EQUAL
13508: IFFALSE 13527
// PrepareHuman ( sex_male , 1 , skill ) else
13510: LD_INT 1
13512: PPUSH
13513: LD_INT 1
13515: PPUSH
13516: LD_VAR 0 10
13520: PPUSH
13521: CALL_OW 380
13525: GO 13542
// PrepareHuman ( false , 1 , skill ) ;
13527: LD_INT 0
13529: PPUSH
13530: LD_INT 1
13532: PPUSH
13533: LD_VAR 0 10
13537: PPUSH
13538: CALL_OW 380
// un := CreateHuman ;
13542: LD_ADDR_VAR 0 3
13546: PUSH
13547: CALL_OW 44
13551: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
13552: LD_ADDR_EXP 42
13556: PUSH
13557: LD_EXP 42
13561: PUSH
13562: LD_VAR 0 3
13566: ADD
13567: ST_TO_ADDR
// end ;
13568: GO 13497
13570: POP
13571: POP
// for i = 1 to mech do
13572: LD_ADDR_VAR 0 2
13576: PUSH
13577: DOUBLE
13578: LD_INT 1
13580: DEC
13581: ST_TO_ADDR
13582: LD_VAR 0 7
13586: PUSH
13587: FOR_TO
13588: IFFALSE 13645
// begin PrepareHuman ( false , 3 , skill ) ;
13590: LD_INT 0
13592: PPUSH
13593: LD_INT 3
13595: PPUSH
13596: LD_VAR 0 10
13600: PPUSH
13601: CALL_OW 380
// un := CreateHuman ;
13605: LD_ADDR_VAR 0 3
13609: PUSH
13610: CALL_OW 44
13614: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13615: LD_VAR 0 3
13619: PPUSH
13620: LD_INT 3
13622: PPUSH
13623: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
13627: LD_ADDR_EXP 42
13631: PUSH
13632: LD_EXP 42
13636: PUSH
13637: LD_VAR 0 3
13641: ADD
13642: ST_TO_ADDR
// end ;
13643: GO 13587
13645: POP
13646: POP
// for i = 1 to tank do
13647: LD_ADDR_VAR 0 2
13651: PUSH
13652: DOUBLE
13653: LD_INT 1
13655: DEC
13656: ST_TO_ADDR
13657: LD_VAR 0 8
13661: PUSH
13662: FOR_TO
13663: IFFALSE 13909
// begin Randomize ;
13665: CALL_OW 10
// if i < 3 then
13669: LD_VAR 0 2
13673: PUSH
13674: LD_INT 3
13676: LESS
13677: IFFALSE 13786
// begin vc_chassis := us_medium_tracked ;
13679: LD_ADDR_OWVAR 37
13683: PUSH
13684: LD_INT 3
13686: ST_TO_ADDR
// vc_engine := engine_combustion ;
13687: LD_ADDR_OWVAR 39
13691: PUSH
13692: LD_INT 1
13694: ST_TO_ADDR
// vc_control := control_manual ;
13695: LD_ADDR_OWVAR 38
13699: PUSH
13700: LD_INT 1
13702: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
13703: LD_ADDR_OWVAR 40
13707: PUSH
13708: LD_INT 3
13710: PUSH
13711: LD_INT 9
13713: PUSH
13714: EMPTY
13715: LIST
13716: LIST
13717: PUSH
13718: LD_INT 1
13720: PPUSH
13721: LD_INT 2
13723: PPUSH
13724: CALL_OW 12
13728: ARRAY
13729: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13730: LD_ADDR_OWVAR 41
13734: PUSH
13735: LD_INT 35
13737: PPUSH
13738: LD_INT 55
13740: PPUSH
13741: CALL_OW 12
13745: ST_TO_ADDR
// un := CreateVehicle ;
13746: LD_ADDR_VAR 0 3
13750: PUSH
13751: CALL_OW 45
13755: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13756: LD_VAR 0 3
13760: PPUSH
13761: LD_INT 5
13763: PPUSH
13764: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
13768: LD_ADDR_EXP 42
13772: PUSH
13773: LD_EXP 42
13777: PUSH
13778: LD_VAR 0 3
13782: ADD
13783: ST_TO_ADDR
// end else
13784: GO 13907
// begin uc_nation := 3 ;
13786: LD_ADDR_OWVAR 21
13790: PUSH
13791: LD_INT 3
13793: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
13794: LD_ADDR_OWVAR 37
13798: PUSH
13799: LD_INT 22
13801: ST_TO_ADDR
// vc_engine := engine_combustion ;
13802: LD_ADDR_OWVAR 39
13806: PUSH
13807: LD_INT 1
13809: ST_TO_ADDR
// vc_control := control_manual ;
13810: LD_ADDR_OWVAR 38
13814: PUSH
13815: LD_INT 1
13817: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
13818: LD_ADDR_OWVAR 40
13822: PUSH
13823: LD_INT 51
13825: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13826: LD_ADDR_OWVAR 41
13830: PUSH
13831: LD_INT 35
13833: PPUSH
13834: LD_INT 55
13836: PPUSH
13837: CALL_OW 12
13841: ST_TO_ADDR
// un := CreateVehicle ;
13842: LD_ADDR_VAR 0 3
13846: PUSH
13847: CALL_OW 45
13851: ST_TO_ADDR
// SetLives ( un , 496 ) ;
13852: LD_VAR 0 3
13856: PPUSH
13857: LD_INT 496
13859: PPUSH
13860: CALL_OW 234
// SetTag ( un , 5 ) ;
13864: LD_VAR 0 3
13868: PPUSH
13869: LD_INT 5
13871: PPUSH
13872: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
13876: LD_VAR 0 3
13880: PPUSH
13881: LD_INT 2
13883: PPUSH
13884: LD_INT 100
13886: PPUSH
13887: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
13891: LD_ADDR_EXP 42
13895: PUSH
13896: LD_EXP 42
13900: PUSH
13901: LD_VAR 0 3
13905: ADD
13906: ST_TO_ADDR
// end ; end ;
13907: GO 13662
13909: POP
13910: POP
// end ; end_of_file
13911: LD_VAR 0 1
13915: RET
// export function Action ; begin
13916: LD_INT 0
13918: PPUSH
// InGameOn ;
13919: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
13923: LD_INT 151
13925: PPUSH
13926: LD_INT 107
13928: PPUSH
13929: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
13933: LD_EXP 38
13937: PPUSH
13938: LD_INT 171
13940: PPUSH
13941: LD_INT 108
13943: PPUSH
13944: LD_INT 0
13946: PPUSH
13947: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
13951: LD_EXP 39
13955: PPUSH
13956: LD_INT 172
13958: PPUSH
13959: LD_INT 110
13961: PPUSH
13962: LD_INT 0
13964: PPUSH
13965: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
13969: LD_EXP 38
13973: PPUSH
13974: LD_INT 156
13976: PPUSH
13977: LD_INT 107
13979: PPUSH
13980: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
13984: LD_EXP 39
13988: PPUSH
13989: LD_INT 154
13991: PPUSH
13992: LD_INT 105
13994: PPUSH
13995: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
13999: LD_INT 4
14001: PPUSH
14002: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
14006: LD_EXP 38
14010: PPUSH
14011: CALL_OW 250
14015: PUSH
14016: LD_INT 156
14018: EQUAL
14019: PUSH
14020: LD_EXP 38
14024: PPUSH
14025: CALL_OW 251
14029: PUSH
14030: LD_INT 107
14032: EQUAL
14033: AND
14034: IFFALSE 13999
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14036: LD_EXP 38
14040: PUSH
14041: LD_EXP 39
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PPUSH
14050: LD_INT 35
14052: PPUSH
14053: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14057: LD_EXP 38
14061: PPUSH
14062: LD_STRING D1-A-1
14064: PPUSH
14065: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14069: LD_EXP 39
14073: PPUSH
14074: LD_STRING D1-B-1
14076: PPUSH
14077: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14081: LD_EXP 38
14085: PPUSH
14086: LD_STRING D1-A-2
14088: PPUSH
14089: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14093: LD_EXP 39
14097: PPUSH
14098: LD_STRING D1-B-2
14100: PPUSH
14101: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14105: LD_EXP 38
14109: PUSH
14110: LD_EXP 39
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: PPUSH
14119: LD_INT 147
14121: PPUSH
14122: LD_INT 108
14124: PPUSH
14125: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14129: LD_EXP 38
14133: PPUSH
14134: LD_STRING D1-A-3
14136: PPUSH
14137: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14141: LD_INT 4
14143: PPUSH
14144: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14148: LD_EXP 38
14152: PPUSH
14153: LD_INT 35
14155: PPUSH
14156: CALL_OW 296
14160: PUSH
14161: LD_INT 8
14163: LESS
14164: IFFALSE 14141
// ComTurnUnit ( guyA , guyB ) ;
14166: LD_EXP 38
14170: PPUSH
14171: LD_EXP 39
14175: PPUSH
14176: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14180: LD_EXP 39
14184: PPUSH
14185: LD_EXP 38
14189: PPUSH
14190: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14194: LD_EXP 38
14198: PPUSH
14199: LD_STRING D1-A-10
14201: PPUSH
14202: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14206: LD_EXP 39
14210: PPUSH
14211: LD_STRING D1-B-10
14213: PPUSH
14214: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14218: LD_EXP 38
14222: PPUSH
14223: LD_STRING D1-A-11
14225: PPUSH
14226: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14230: LD_EXP 39
14234: PPUSH
14235: LD_STRING D1-B-11
14237: PPUSH
14238: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14242: LD_EXP 38
14246: PPUSH
14247: LD_STRING D1-A-12
14249: PPUSH
14250: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14254: LD_EXP 39
14258: PPUSH
14259: LD_STRING D1-B-12
14261: PPUSH
14262: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14266: LD_EXP 38
14270: PPUSH
14271: LD_STRING D1-A-13
14273: PPUSH
14274: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14278: LD_EXP 39
14282: PPUSH
14283: LD_STRING D1-B-13
14285: PPUSH
14286: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14290: LD_EXP 38
14294: PPUSH
14295: LD_STRING D1-A-14
14297: PPUSH
14298: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14302: LD_EXP 39
14306: PPUSH
14307: LD_STRING D1-B-14
14309: PPUSH
14310: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14314: LD_EXP 38
14318: PPUSH
14319: LD_STRING D1-A-15
14321: PPUSH
14322: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14326: LD_EXP 39
14330: PPUSH
14331: LD_STRING D1-B-15
14333: PPUSH
14334: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14338: LD_EXP 38
14342: PPUSH
14343: LD_STRING D1-A-16
14345: PPUSH
14346: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14350: LD_EXP 39
14354: PPUSH
14355: LD_STRING D1-B-16
14357: PPUSH
14358: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14362: LD_EXP 38
14366: PPUSH
14367: LD_STRING D1-A-17
14369: PPUSH
14370: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14374: LD_EXP 39
14378: PPUSH
14379: LD_STRING D1-B-17
14381: PPUSH
14382: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
14386: LD_EXP 38
14390: PPUSH
14391: LD_STRING D1-A-18
14393: PPUSH
14394: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
14398: LD_INT 35
14400: PPUSH
14401: LD_INT 1
14403: PPUSH
14404: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
14408: LD_EXP 38
14412: PUSH
14413: LD_EXP 39
14417: PUSH
14418: EMPTY
14419: LIST
14420: LIST
14421: PPUSH
14422: LD_INT 35
14424: PPUSH
14425: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
14429: LD_INT 4
14431: PPUSH
14432: CALL_OW 67
// until IsInUnit ( guyA ) ;
14436: LD_EXP 38
14440: PPUSH
14441: CALL_OW 310
14445: IFFALSE 14429
// Wait ( 0 0$02 ) ;
14447: LD_INT 70
14449: PPUSH
14450: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
14454: LD_EXP 38
14458: PPUSH
14459: LD_STRING D1-A-19
14461: PPUSH
14462: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
14466: LD_EXP 39
14470: PPUSH
14471: LD_STRING D1-B-19
14473: PPUSH
14474: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
14478: LD_EXP 38
14482: PPUSH
14483: LD_STRING D1-A-20
14485: PPUSH
14486: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
14490: LD_INT 10
14492: PPUSH
14493: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
14497: LD_EXP 39
14501: PPUSH
14502: LD_STRING D1-B-20
14504: PPUSH
14505: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
14509: LD_EXP 38
14513: PPUSH
14514: LD_STRING D1-A-21
14516: PPUSH
14517: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
14521: LD_EXP 39
14525: PPUSH
14526: LD_STRING D1-B-21
14528: PPUSH
14529: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
14533: LD_EXP 38
14537: PPUSH
14538: LD_STRING D1-A-22
14540: PPUSH
14541: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
14545: LD_EXP 39
14549: PPUSH
14550: LD_STRING D1-B-22
14552: PPUSH
14553: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
14557: LD_EXP 38
14561: PPUSH
14562: LD_STRING D1-A-23
14564: PPUSH
14565: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
14569: LD_EXP 39
14573: PPUSH
14574: LD_STRING D1-B-23
14576: PPUSH
14577: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
14581: LD_EXP 38
14585: PPUSH
14586: LD_STRING D1-A-24
14588: PPUSH
14589: CALL_OW 88
// InGameOff ;
14593: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
14597: LD_STRING M_main
14599: PPUSH
14600: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
14604: LD_INT 4
14606: PPUSH
14607: LD_INT 1
14609: PPUSH
14610: CALL_OW 343
// game_status := true ;
14614: LD_ADDR_EXP 29
14618: PUSH
14619: LD_INT 1
14621: ST_TO_ADDR
// end ;
14622: LD_VAR 0 1
14626: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
14627: LD_INT 1
14629: PPUSH
14630: CALL 6314 0 1
14634: PUSH
14635: LD_INT 0
14637: GREATER
14638: IFFALSE 14740
14640: GO 14642
14642: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
14643: LD_INT 35
14645: PPUSH
14646: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
14650: LD_INT 1
14652: PPUSH
14653: CALL 6314 0 1
14657: PUSH
14658: LD_INT 1
14660: ARRAY
14661: PPUSH
14662: CALL_OW 461
14666: PUSH
14667: LD_INT 1
14669: NONEQUAL
14670: IFFALSE 14643
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
14672: LD_EXP 38
14676: PPUSH
14677: CALL_OW 300
14681: PUSH
14682: LD_EXP 39
14686: PPUSH
14687: CALL_OW 300
14691: AND
14692: PUSH
14693: LD_EXP 30
14697: NOT
14698: AND
14699: IFFALSE 14725
// begin Say ( guyA , DL-A-1 ) ;
14701: LD_EXP 38
14705: PPUSH
14706: LD_STRING DL-A-1
14708: PPUSH
14709: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
14713: LD_EXP 39
14717: PPUSH
14718: LD_STRING DL-B-1
14720: PPUSH
14721: CALL_OW 88
// end ; if not helps_can_arrive then
14725: LD_EXP 31
14729: NOT
14730: IFFALSE 14740
// helps_can_arrive := true ;
14732: LD_ADDR_EXP 31
14736: PUSH
14737: LD_INT 1
14739: ST_TO_ADDR
// end ;
14740: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
14741: LD_INT 1
14743: PPUSH
14744: CALL 6314 0 1
14748: PUSH
14749: LD_INT 0
14751: GREATER
14752: PUSH
14753: LD_EXP 38
14757: PPUSH
14758: CALL_OW 300
14762: AND
14763: PUSH
14764: LD_EXP 39
14768: PPUSH
14769: CALL_OW 300
14773: AND
14774: PUSH
14775: LD_INT 22
14777: PUSH
14778: LD_INT 1
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PUSH
14785: LD_INT 25
14787: PUSH
14788: LD_INT 12
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: PUSH
14795: EMPTY
14796: LIST
14797: LIST
14798: PPUSH
14799: CALL_OW 69
14803: PUSH
14804: LD_INT 0
14806: EQUAL
14807: AND
14808: PUSH
14809: LD_INT 1
14811: PPUSH
14812: LD_INT 25
14814: PUSH
14815: LD_INT 12
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PPUSH
14822: CALL_OW 69
14826: PPUSH
14827: LD_EXP 38
14831: PPUSH
14832: CALL_OW 74
14836: PPUSH
14837: CALL_OW 292
14841: AND
14842: IFFALSE 14883
14844: GO 14846
14846: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
14847: LD_EXP 38
14851: PPUSH
14852: LD_STRING DA-A-1
14854: PPUSH
14855: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
14859: LD_EXP 39
14863: PPUSH
14864: LD_STRING DA-B-1
14866: PPUSH
14867: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
14871: LD_EXP 38
14875: PPUSH
14876: LD_STRING DA-A-2
14878: PPUSH
14879: CALL_OW 88
// end ;
14883: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
14884: LD_EXP 29
14888: PUSH
14889: LD_EXP 38
14893: PPUSH
14894: LD_INT 6
14896: PPUSH
14897: CALL_OW 299
14901: PUSH
14902: LD_INT 7
14904: LESS
14905: AND
14906: IFFALSE 14959
14908: GO 14910
14910: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
14911: LD_INT 117
14913: PPUSH
14914: LD_INT 50
14916: PPUSH
14917: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
14921: LD_INT 1
14923: PPUSH
14924: CALL 10055 0 1
14928: PUSH
14929: LD_INT 2
14931: ARRAY
14932: PPUSH
14933: LD_STRING D5-A-1
14935: PPUSH
14936: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
14940: LD_INT 1
14942: PPUSH
14943: CALL 10055 0 1
14947: PUSH
14948: LD_INT 1
14950: ARRAY
14951: PPUSH
14952: LD_STRING D5-B-1
14954: PPUSH
14955: CALL_OW 88
// end ;
14959: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
14960: LD_INT 7
14962: PPUSH
14963: LD_INT 22
14965: PUSH
14966: LD_INT 1
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PPUSH
14973: CALL_OW 70
14977: PUSH
14978: LD_INT 0
14980: GREATER
14981: IFFALSE 15126
14983: GO 14985
14985: DISABLE
// begin Wait ( 0 0$03 ) ;
14986: LD_INT 105
14988: PPUSH
14989: CALL_OW 67
// DialogueOn ;
14993: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
14997: LD_INT 1
14999: PPUSH
15000: CALL 10055 0 1
15004: PUSH
15005: LD_INT 1
15007: ARRAY
15008: PPUSH
15009: LD_STRING D6-A-1
15011: PPUSH
15012: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15016: LD_INT 1
15018: PPUSH
15019: CALL 10055 0 1
15023: PUSH
15024: LD_INT 2
15026: ARRAY
15027: PPUSH
15028: LD_STRING D6-B-1
15030: PPUSH
15031: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15035: LD_INT 95
15037: PPUSH
15038: LD_INT 8
15040: PPUSH
15041: LD_INT 1
15043: PPUSH
15044: LD_INT 20
15046: PPUSH
15047: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15051: LD_INT 10
15053: PPUSH
15054: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15058: LD_INT 1
15060: PPUSH
15061: CALL 10055 0 1
15065: PUSH
15066: LD_INT 1
15068: ARRAY
15069: PPUSH
15070: LD_STRING D6-A-2
15072: PPUSH
15073: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15077: LD_INT 1
15079: PPUSH
15080: CALL 10055 0 1
15084: PUSH
15085: LD_INT 2
15087: ARRAY
15088: PPUSH
15089: LD_STRING D6-B-2
15091: PPUSH
15092: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15096: LD_INT 1
15098: PPUSH
15099: CALL 10055 0 1
15103: PUSH
15104: LD_INT 1
15106: ARRAY
15107: PPUSH
15108: LD_STRING D6-A-3
15110: PPUSH
15111: CALL_OW 88
// DialogueOff ;
15115: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15119: LD_STRING M_base
15121: PPUSH
15122: CALL_OW 337
// end ;
15126: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15127: LD_EXP 30
15131: NOT
15132: PUSH
15133: LD_INT 22
15135: PUSH
15136: LD_INT 3
15138: PUSH
15139: EMPTY
15140: LIST
15141: LIST
15142: PUSH
15143: LD_INT 21
15145: PUSH
15146: LD_INT 2
15148: PUSH
15149: EMPTY
15150: LIST
15151: LIST
15152: PUSH
15153: EMPTY
15154: LIST
15155: LIST
15156: PPUSH
15157: CALL_OW 69
15161: PUSH
15162: LD_INT 0
15164: GREATER
15165: AND
15166: IFFALSE 15299
15168: GO 15170
15170: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15171: LD_INT 35
15173: PPUSH
15174: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15178: LD_INT 22
15180: PUSH
15181: LD_INT 3
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: PUSH
15188: LD_INT 21
15190: PUSH
15191: LD_INT 2
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PPUSH
15202: CALL_OW 69
15206: PPUSH
15207: LD_INT 1
15209: PPUSH
15210: CALL 10055 0 1
15214: PUSH
15215: LD_INT 1
15217: ARRAY
15218: PPUSH
15219: CALL_OW 74
15223: PPUSH
15224: LD_INT 1
15226: PPUSH
15227: CALL 10055 0 1
15231: PUSH
15232: LD_INT 1
15234: ARRAY
15235: PPUSH
15236: CALL_OW 296
15240: PUSH
15241: LD_INT 7
15243: LESS
15244: IFFALSE 15171
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15246: LD_INT 1
15248: PPUSH
15249: CALL 10055 0 1
15253: PUSH
15254: LD_INT 1
15256: ARRAY
15257: PPUSH
15258: LD_STRING DR-A-1
15260: PPUSH
15261: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15265: LD_INT 1
15267: PPUSH
15268: CALL 10055 0 1
15272: PUSH
15273: LD_INT 2
15275: ARRAY
15276: PPUSH
15277: LD_STRING DR-B-1
15279: PPUSH
15280: CALL_OW 88
// Wait ( 3 3$00 ) ;
15284: LD_INT 6300
15286: PPUSH
15287: CALL_OW 67
// ru_spotted := true ;
15291: LD_ADDR_EXP 16
15295: PUSH
15296: LD_INT 1
15298: ST_TO_ADDR
// end ;
15299: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15300: LD_INT 35
15302: PPUSH
15303: CALL_OW 300
15307: NOT
15308: IFFALSE 15332
15310: GO 15312
15312: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15313: LD_INT 1
15315: PPUSH
15316: CALL 10055 0 1
15320: PUSH
15321: LD_INT 1
15323: ARRAY
15324: PPUSH
15325: LD_STRING DDR-A-1
15327: PPUSH
15328: CALL_OW 88
15332: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15333: LD_INT 1
15335: PPUSH
15336: LD_INT 30
15338: PPUSH
15339: CALL 6163 0 2
15343: IFFALSE 15425
15345: GO 15347
15347: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15348: LD_INT 35
15350: PPUSH
15351: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15355: LD_INT 1
15357: PPUSH
15358: LD_INT 30
15360: PPUSH
15361: CALL 6163 0 2
15365: PUSH
15366: LD_INT 1
15368: ARRAY
15369: PPUSH
15370: CALL_OW 461
15374: PUSH
15375: LD_INT 1
15377: NONEQUAL
15378: IFFALSE 15348
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15380: LD_INT 1
15382: PPUSH
15383: CALL 10055 0 1
15387: PUSH
15388: LD_INT 1
15390: ARRAY
15391: PPUSH
15392: LD_STRING D8-A-1
15394: PPUSH
15395: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
15399: LD_INT 1
15401: PPUSH
15402: CALL 10055 0 1
15406: PUSH
15407: LD_INT 2
15409: ARRAY
15410: PPUSH
15411: LD_STRING D8-B-1
15413: PPUSH
15414: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
15418: LD_STRING M_mineok
15420: PPUSH
15421: CALL_OW 337
// end ;
15425: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
15426: LD_INT 22
15428: PUSH
15429: LD_INT 1
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 30
15438: PUSH
15439: LD_INT 0
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: LD_INT 3
15448: PUSH
15449: LD_INT 57
15451: PUSH
15452: EMPTY
15453: LIST
15454: PUSH
15455: EMPTY
15456: LIST
15457: LIST
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: LIST
15463: PPUSH
15464: CALL_OW 69
15468: PUSH
15469: LD_INT 1
15471: GREATER
15472: PUSH
15473: LD_INT 22
15475: PUSH
15476: LD_INT 1
15478: PUSH
15479: EMPTY
15480: LIST
15481: LIST
15482: PUSH
15483: LD_INT 30
15485: PUSH
15486: LD_INT 0
15488: PUSH
15489: EMPTY
15490: LIST
15491: LIST
15492: PUSH
15493: LD_INT 3
15495: PUSH
15496: LD_INT 57
15498: PUSH
15499: EMPTY
15500: LIST
15501: PUSH
15502: EMPTY
15503: LIST
15504: LIST
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: LIST
15510: PPUSH
15511: CALL_OW 69
15515: PUSH
15516: LD_INT 1
15518: EQUAL
15519: PUSH
15520: LD_INT 35
15522: PPUSH
15523: CALL_OW 300
15527: NOT
15528: AND
15529: OR
15530: IFFALSE 15582
15532: GO 15534
15534: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
15535: LD_INT 22
15537: PUSH
15538: LD_INT 1
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: PUSH
15545: LD_INT 25
15547: PUSH
15548: LD_INT 2
15550: PUSH
15551: EMPTY
15552: LIST
15553: LIST
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PPUSH
15559: CALL_OW 69
15563: PUSH
15564: LD_INT 1
15566: ARRAY
15567: PPUSH
15568: LD_STRING D7-A-1
15570: PPUSH
15571: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
15575: LD_STRING M_baseok
15577: PPUSH
15578: CALL_OW 337
// end ;
15582: END
// every 0 0$01 trigger mine_ck do
15583: LD_EXP 35
15587: IFFALSE 15618
15589: GO 15591
15591: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
15592: LD_INT 1
15594: PPUSH
15595: CALL 10055 0 1
15599: PUSH
15600: LD_INT 1
15602: ARRAY
15603: PPUSH
15604: LD_STRING D9-A-1
15606: PPUSH
15607: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
15611: LD_STRING M_minedest
15613: PPUSH
15614: CALL_OW 337
// end ;
15618: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
15619: LD_EXP 29
15623: IFFALSE 16129
15625: GO 15627
15627: DISABLE
15628: LD_INT 0
15630: PPUSH
15631: PPUSH
15632: PPUSH
15633: PPUSH
15634: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
15635: LD_OWVAR 67
15639: PPUSH
15640: CALL 11956 0 1
// if not helps_can_arrive then
15644: LD_EXP 31
15648: NOT
15649: IFFALSE 15677
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
15651: LD_EXP 40
15655: PUSH
15656: LD_INT 1
15658: ARRAY
15659: PPUSH
15660: LD_STRING DB-Delay
15662: PPUSH
15663: CALL_OW 94
// time := 10 10$00 ;
15667: LD_ADDR_VAR 0 1
15671: PUSH
15672: LD_INT 21000
15674: ST_TO_ADDR
// end else
15675: GO 15685
// time := 3 3$00 ;
15677: LD_ADDR_VAR 0 1
15681: PUSH
15682: LD_INT 6300
15684: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
15685: LD_ADDR_VAR 0 1
15689: PUSH
15690: LD_VAR 0 1
15694: PUSH
15695: LD_INT 35
15697: MINUS
15698: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
15699: LD_INT 35
15701: PPUSH
15702: CALL_OW 67
// end until time = 0 0$00 ;
15706: LD_VAR 0 1
15710: PUSH
15711: LD_INT 0
15713: EQUAL
15714: IFFALSE 15685
// helps_arrive := true ;
15716: LD_ADDR_EXP 30
15720: PUSH
15721: LD_INT 1
15723: ST_TO_ADDR
// if IsLive ( guyA ) then
15724: LD_EXP 38
15728: PPUSH
15729: CALL_OW 300
15733: IFFALSE 15747
// r := guyA else
15735: LD_ADDR_VAR 0 4
15739: PUSH
15740: LD_EXP 38
15744: ST_TO_ADDR
15745: GO 15757
// r := guyB ;
15747: LD_ADDR_VAR 0 4
15751: PUSH
15752: LD_EXP 39
15756: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
15757: LD_EXP 40
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PPUSH
15766: LD_STRING D2-A-1
15768: PPUSH
15769: CALL_OW 94
// Say ( r , D2-B-1 ) ;
15773: LD_VAR 0 4
15777: PPUSH
15778: LD_STRING D2-B-1
15780: PPUSH
15781: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
15785: LD_EXP 40
15789: PUSH
15790: LD_INT 1
15792: ARRAY
15793: PPUSH
15794: LD_STRING D2-A-2
15796: PPUSH
15797: CALL_OW 94
// Say ( r , D2-B-2 ) ;
15801: LD_VAR 0 4
15805: PPUSH
15806: LD_STRING D2-B-2
15808: PPUSH
15809: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
15813: LD_EXP 40
15817: PUSH
15818: LD_INT 1
15820: ARRAY
15821: PPUSH
15822: LD_STRING D2-A-3
15824: PPUSH
15825: CALL_OW 94
// Say ( r , D2-B-3 ) ;
15829: LD_VAR 0 4
15833: PPUSH
15834: LD_STRING D2-B-3
15836: PPUSH
15837: CALL_OW 88
// to_veh := [ ] ;
15841: LD_ADDR_VAR 0 5
15845: PUSH
15846: EMPTY
15847: ST_TO_ADDR
// for i = 1 to Beta_Squad do
15848: LD_ADDR_VAR 0 2
15852: PUSH
15853: DOUBLE
15854: LD_INT 1
15856: DEC
15857: ST_TO_ADDR
15858: LD_EXP 40
15862: PUSH
15863: FOR_TO
15864: IFFALSE 16127
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
15866: LD_EXP 40
15870: PUSH
15871: LD_VAR 0 2
15875: ARRAY
15876: PPUSH
15877: CALL_OW 110
15881: PUSH
15882: LD_INT 3
15884: EQUAL
15885: IFFALSE 15911
// to_veh := to_veh ^ Beta_Squad [ i ] else
15887: LD_ADDR_VAR 0 5
15891: PUSH
15892: LD_VAR 0 5
15896: PUSH
15897: LD_EXP 40
15901: PUSH
15902: LD_VAR 0 2
15906: ARRAY
15907: ADD
15908: ST_TO_ADDR
15909: GO 16036
// if GetTag ( Beta_Squad [ i ] ) = 5 then
15911: LD_EXP 40
15915: PUSH
15916: LD_VAR 0 2
15920: ARRAY
15921: PPUSH
15922: CALL_OW 110
15926: PUSH
15927: LD_INT 5
15929: EQUAL
15930: IFFALSE 16015
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
15932: LD_EXP 40
15936: PUSH
15937: LD_VAR 0 2
15941: ARRAY
15942: PPUSH
15943: LD_INT 4
15945: PPUSH
15946: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
15950: LD_EXP 40
15954: PUSH
15955: LD_VAR 0 2
15959: ARRAY
15960: PPUSH
15961: LD_INT 5
15963: PPUSH
15964: LD_INT 0
15966: PPUSH
15967: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
15971: LD_VAR 0 5
15975: PUSH
15976: LD_INT 1
15978: ARRAY
15979: PPUSH
15980: LD_EXP 40
15984: PUSH
15985: LD_VAR 0 2
15989: ARRAY
15990: PPUSH
15991: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
15995: LD_ADDR_VAR 0 5
15999: PUSH
16000: LD_VAR 0 5
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: CALL_OW 3
16012: ST_TO_ADDR
// end else
16013: GO 16036
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16015: LD_EXP 40
16019: PUSH
16020: LD_VAR 0 2
16024: ARRAY
16025: PPUSH
16026: LD_INT 5
16028: PPUSH
16029: LD_INT 0
16031: PPUSH
16032: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16036: LD_EXP 40
16040: PUSH
16041: LD_VAR 0 2
16045: ARRAY
16046: PPUSH
16047: LD_INT 165
16049: PPUSH
16050: LD_INT 105
16052: PPUSH
16053: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16057: LD_INT 70
16059: PPUSH
16060: LD_INT 140
16062: PPUSH
16063: CALL_OW 12
16067: PPUSH
16068: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16072: LD_EXP 40
16076: PUSH
16077: LD_VAR 0 2
16081: ARRAY
16082: PPUSH
16083: LD_INT 1
16085: PPUSH
16086: CALL_OW 235
// if i = 1 then
16090: LD_VAR 0 2
16094: PUSH
16095: LD_INT 1
16097: EQUAL
16098: IFFALSE 16110
// CenterNowOnXY ( 168 , 109 ) ;
16100: LD_INT 168
16102: PPUSH
16103: LD_INT 109
16105: PPUSH
16106: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16110: LD_EXP 40
16114: PUSH
16115: LD_VAR 0 2
16119: ARRAY
16120: PPUSH
16121: CALL_OW 141
// end ;
16125: GO 15863
16127: POP
16128: POP
// end ;
16129: PPOPN 5
16131: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16132: LD_EXP 30
16136: IFFALSE 17165
16138: GO 16140
16140: DISABLE
16141: LD_INT 0
16143: PPUSH
16144: PPUSH
// begin Wait ( 5 5$00 ) ;
16145: LD_INT 10500
16147: PPUSH
16148: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16152: LD_OWVAR 67
16156: PPUSH
16157: CALL 12645 0 1
// to_veh := [ ] ;
16161: LD_ADDR_VAR 0 2
16165: PUSH
16166: EMPTY
16167: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16168: LD_ADDR_VAR 0 1
16172: PUSH
16173: DOUBLE
16174: LD_INT 1
16176: DEC
16177: ST_TO_ADDR
16178: LD_EXP 41
16182: PUSH
16183: FOR_TO
16184: IFFALSE 16412
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16186: LD_EXP 41
16190: PUSH
16191: LD_VAR 0 1
16195: ARRAY
16196: PPUSH
16197: CALL_OW 110
16201: PUSH
16202: LD_INT 3
16204: EQUAL
16205: IFFALSE 16231
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16207: LD_ADDR_VAR 0 2
16211: PUSH
16212: LD_VAR 0 2
16216: PUSH
16217: LD_EXP 41
16221: PUSH
16222: LD_VAR 0 1
16226: ARRAY
16227: ADD
16228: ST_TO_ADDR
16229: GO 16356
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16231: LD_EXP 41
16235: PUSH
16236: LD_VAR 0 1
16240: ARRAY
16241: PPUSH
16242: CALL_OW 110
16246: PUSH
16247: LD_INT 5
16249: EQUAL
16250: IFFALSE 16335
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16252: LD_EXP 41
16256: PUSH
16257: LD_VAR 0 1
16261: ARRAY
16262: PPUSH
16263: LD_INT 4
16265: PPUSH
16266: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16270: LD_EXP 41
16274: PUSH
16275: LD_VAR 0 1
16279: ARRAY
16280: PPUSH
16281: LD_INT 5
16283: PPUSH
16284: LD_INT 0
16286: PPUSH
16287: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16291: LD_VAR 0 2
16295: PUSH
16296: LD_INT 1
16298: ARRAY
16299: PPUSH
16300: LD_EXP 41
16304: PUSH
16305: LD_VAR 0 1
16309: ARRAY
16310: PPUSH
16311: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16315: LD_ADDR_VAR 0 2
16319: PUSH
16320: LD_VAR 0 2
16324: PPUSH
16325: LD_INT 1
16327: PPUSH
16328: CALL_OW 3
16332: ST_TO_ADDR
// end else
16333: GO 16356
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16335: LD_EXP 41
16339: PUSH
16340: LD_VAR 0 1
16344: ARRAY
16345: PPUSH
16346: LD_INT 5
16348: PPUSH
16349: LD_INT 0
16351: PPUSH
16352: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16356: LD_EXP 41
16360: PUSH
16361: LD_VAR 0 1
16365: ARRAY
16366: PPUSH
16367: LD_INT 164
16369: PPUSH
16370: LD_INT 104
16372: PPUSH
16373: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16377: LD_INT 70
16379: PPUSH
16380: LD_INT 140
16382: PPUSH
16383: CALL_OW 12
16387: PPUSH
16388: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16392: LD_EXP 41
16396: PUSH
16397: LD_VAR 0 1
16401: ARRAY
16402: PPUSH
16403: LD_INT 1
16405: PPUSH
16406: CALL_OW 235
// end ;
16410: GO 16183
16412: POP
16413: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
16414: LD_EXP 41
16418: PUSH
16419: LD_INT 1
16421: ARRAY
16422: PPUSH
16423: LD_STRING D3-A-1
16425: PPUSH
16426: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
16430: LD_INT 1
16432: PPUSH
16433: CALL 10055 0 1
16437: PUSH
16438: LD_INT 1
16440: ARRAY
16441: PPUSH
16442: LD_STRING D3-B-1
16444: PPUSH
16445: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
16449: LD_EXP 41
16453: PUSH
16454: LD_INT 1
16456: ARRAY
16457: PPUSH
16458: LD_STRING D3-A-2
16460: PPUSH
16461: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
16465: LD_INT 1
16467: PPUSH
16468: CALL 10055 0 1
16472: PUSH
16473: LD_INT 1
16475: ARRAY
16476: PPUSH
16477: LD_STRING D3-B-2
16479: PPUSH
16480: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
16484: LD_EXP 41
16488: PUSH
16489: LD_INT 1
16491: ARRAY
16492: PPUSH
16493: LD_STRING D3-A-3
16495: PPUSH
16496: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
16500: LD_INT 1
16502: PPUSH
16503: CALL 10055 0 1
16507: PUSH
16508: LD_INT 1
16510: ARRAY
16511: PPUSH
16512: LD_STRING D3-B-3
16514: PPUSH
16515: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
16519: LD_EXP 41
16523: PUSH
16524: LD_INT 1
16526: ARRAY
16527: PPUSH
16528: LD_STRING D3-A-4
16530: PPUSH
16531: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
16535: LD_INT 1
16537: PPUSH
16538: CALL 10055 0 1
16542: PUSH
16543: LD_INT 1
16545: ARRAY
16546: PPUSH
16547: LD_STRING D3-B-4
16549: PPUSH
16550: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
16554: LD_EXP 41
16558: PUSH
16559: LD_INT 1
16561: ARRAY
16562: PPUSH
16563: LD_STRING D3-A-5
16565: PPUSH
16566: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
16570: LD_INT 1
16572: PPUSH
16573: CALL 10055 0 1
16577: PUSH
16578: LD_INT 1
16580: ARRAY
16581: PPUSH
16582: LD_STRING D3-B-5
16584: PPUSH
16585: CALL_OW 88
// for i = 1 to Gamma_Squad do
16589: LD_ADDR_VAR 0 1
16593: PUSH
16594: DOUBLE
16595: LD_INT 1
16597: DEC
16598: ST_TO_ADDR
16599: LD_EXP 41
16603: PUSH
16604: FOR_TO
16605: IFFALSE 16627
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16607: LD_EXP 41
16611: PUSH
16612: LD_VAR 0 1
16616: ARRAY
16617: PPUSH
16618: LD_INT 1
16620: PPUSH
16621: CALL_OW 235
16625: GO 16604
16627: POP
16628: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
16629: LD_INT 6300
16631: PUSH
16632: LD_INT 10500
16634: PUSH
16635: LD_INT 11550
16637: PUSH
16638: EMPTY
16639: LIST
16640: LIST
16641: LIST
16642: PUSH
16643: LD_OWVAR 67
16647: ARRAY
16648: PPUSH
16649: CALL_OW 67
// AddZetaSquad ;
16653: CALL 13374 0 0
// Wait ( 0 0$10 ) ;
16657: LD_INT 350
16659: PPUSH
16660: CALL_OW 67
// to_veh := [ ] ;
16664: LD_ADDR_VAR 0 2
16668: PUSH
16669: EMPTY
16670: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
16671: LD_ADDR_VAR 0 1
16675: PUSH
16676: DOUBLE
16677: LD_INT 1
16679: DEC
16680: ST_TO_ADDR
16681: LD_EXP 42
16685: PUSH
16686: FOR_TO
16687: IFFALSE 16897
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
16689: LD_EXP 42
16693: PUSH
16694: LD_VAR 0 1
16698: ARRAY
16699: PPUSH
16700: CALL_OW 110
16704: PUSH
16705: LD_INT 3
16707: EQUAL
16708: IFFALSE 16734
// to_veh := to_veh ^ Zeta_Squad [ i ] else
16710: LD_ADDR_VAR 0 2
16714: PUSH
16715: LD_VAR 0 2
16719: PUSH
16720: LD_EXP 42
16724: PUSH
16725: LD_VAR 0 1
16729: ARRAY
16730: ADD
16731: ST_TO_ADDR
16732: GO 16859
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
16734: LD_EXP 42
16738: PUSH
16739: LD_VAR 0 1
16743: ARRAY
16744: PPUSH
16745: CALL_OW 110
16749: PUSH
16750: LD_INT 5
16752: EQUAL
16753: IFFALSE 16838
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
16755: LD_EXP 42
16759: PUSH
16760: LD_VAR 0 1
16764: ARRAY
16765: PPUSH
16766: LD_INT 4
16768: PPUSH
16769: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
16773: LD_EXP 42
16777: PUSH
16778: LD_VAR 0 1
16782: ARRAY
16783: PPUSH
16784: LD_INT 5
16786: PPUSH
16787: LD_INT 0
16789: PPUSH
16790: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
16794: LD_VAR 0 2
16798: PUSH
16799: LD_INT 1
16801: ARRAY
16802: PPUSH
16803: LD_EXP 42
16807: PUSH
16808: LD_VAR 0 1
16812: ARRAY
16813: PPUSH
16814: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16818: LD_ADDR_VAR 0 2
16822: PUSH
16823: LD_VAR 0 2
16827: PPUSH
16828: LD_INT 1
16830: PPUSH
16831: CALL_OW 3
16835: ST_TO_ADDR
// end else
16836: GO 16859
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
16838: LD_EXP 42
16842: PUSH
16843: LD_VAR 0 1
16847: ARRAY
16848: PPUSH
16849: LD_INT 5
16851: PPUSH
16852: LD_INT 0
16854: PPUSH
16855: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
16859: LD_EXP 42
16863: PUSH
16864: LD_VAR 0 1
16868: ARRAY
16869: PPUSH
16870: LD_INT 165
16872: PPUSH
16873: LD_INT 105
16875: PPUSH
16876: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16880: LD_INT 70
16882: PPUSH
16883: LD_INT 140
16885: PPUSH
16886: CALL_OW 12
16890: PPUSH
16891: CALL_OW 67
// end ;
16895: GO 16686
16897: POP
16898: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
16899: LD_EXP 42
16903: PUSH
16904: LD_INT 1
16906: ARRAY
16907: PPUSH
16908: LD_STRING D4-A-1
16910: PPUSH
16911: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
16915: LD_INT 1
16917: PPUSH
16918: CALL 10055 0 1
16922: PUSH
16923: LD_INT 1
16925: ARRAY
16926: PPUSH
16927: LD_STRING D4-B-1
16929: PPUSH
16930: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
16934: LD_EXP 42
16938: PUSH
16939: LD_INT 1
16941: ARRAY
16942: PPUSH
16943: LD_STRING D4-A-2
16945: PPUSH
16946: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
16950: LD_INT 1
16952: PPUSH
16953: CALL 10055 0 1
16957: PUSH
16958: LD_INT 1
16960: ARRAY
16961: PPUSH
16962: LD_STRING D4-B-2
16964: PPUSH
16965: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
16969: LD_EXP 42
16973: PUSH
16974: LD_INT 1
16976: ARRAY
16977: PPUSH
16978: LD_STRING D4-A-3
16980: PPUSH
16981: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
16985: LD_INT 1
16987: PPUSH
16988: CALL 10055 0 1
16992: PUSH
16993: LD_INT 1
16995: ARRAY
16996: PPUSH
16997: LD_STRING D4-B-3
16999: PPUSH
17000: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
17004: LD_EXP 42
17008: PUSH
17009: LD_INT 1
17011: ARRAY
17012: PPUSH
17013: LD_STRING D4-A-4
17015: PPUSH
17016: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17020: LD_INT 1
17022: PPUSH
17023: CALL 10055 0 1
17027: PUSH
17028: LD_INT 1
17030: ARRAY
17031: PPUSH
17032: LD_STRING D4-B-4
17034: PPUSH
17035: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17039: LD_EXP 42
17043: PUSH
17044: LD_INT 1
17046: ARRAY
17047: PPUSH
17048: LD_STRING D4-A-5
17050: PPUSH
17051: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17055: LD_INT 1
17057: PPUSH
17058: CALL 10055 0 1
17062: PUSH
17063: LD_INT 1
17065: ARRAY
17066: PPUSH
17067: LD_STRING D4-B-5
17069: PPUSH
17070: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17074: LD_EXP 42
17078: PUSH
17079: LD_INT 1
17081: ARRAY
17082: PPUSH
17083: LD_STRING D4-A-6
17085: PPUSH
17086: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17090: LD_INT 1
17092: PPUSH
17093: CALL 10055 0 1
17097: PUSH
17098: LD_INT 1
17100: ARRAY
17101: PPUSH
17102: LD_STRING D4-B-6
17104: PPUSH
17105: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17109: LD_EXP 42
17113: PUSH
17114: LD_INT 1
17116: ARRAY
17117: PPUSH
17118: LD_STRING D4-A-7
17120: PPUSH
17121: CALL_OW 94
// for i = 1 to Zeta_Squad do
17125: LD_ADDR_VAR 0 1
17129: PUSH
17130: DOUBLE
17131: LD_INT 1
17133: DEC
17134: ST_TO_ADDR
17135: LD_EXP 42
17139: PUSH
17140: FOR_TO
17141: IFFALSE 17163
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17143: LD_EXP 42
17147: PUSH
17148: LD_VAR 0 1
17152: ARRAY
17153: PPUSH
17154: LD_INT 1
17156: PPUSH
17157: CALL_OW 235
17161: GO 17140
17163: POP
17164: POP
// end ;
17165: PPOPN 2
17167: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17168: LD_INT 11
17170: PPUSH
17171: LD_INT 22
17173: PUSH
17174: LD_OWVAR 2
17178: PUSH
17179: EMPTY
17180: LIST
17181: LIST
17182: PPUSH
17183: CALL_OW 70
17187: PUSH
17188: LD_INT 0
17190: GREATER
17191: IFFALSE 17216
17193: GO 17195
17195: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17196: LD_EXP 38
17200: PPUSH
17201: LD_STRING D10-A-1
17203: PPUSH
17204: CALL_OW 88
// ru_spotted := true ;
17208: LD_ADDR_EXP 16
17212: PUSH
17213: LD_INT 1
17215: ST_TO_ADDR
// end ;
17216: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17217: LD_EXP 38
17221: PPUSH
17222: CALL_OW 301
17226: PUSH
17227: LD_EXP 39
17231: PPUSH
17232: CALL_OW 301
17236: OR
17237: IFFALSE 17249
17239: GO 17241
17241: DISABLE
// begin YouLost ( DieP ) ;
17242: LD_STRING DieP
17244: PPUSH
17245: CALL_OW 104
// end ;
17249: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17250: LD_INT 34
17252: PUSH
17253: LD_INT 8
17255: PUSH
17256: EMPTY
17257: LIST
17258: LIST
17259: PPUSH
17260: CALL_OW 69
17264: IFFALSE 17277
17266: GO 17268
17268: DISABLE
// sib_bomb_constructed := true ;
17269: LD_ADDR_EXP 36
17273: PUSH
17274: LD_INT 1
17276: ST_TO_ADDR
17277: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17278: LD_EXP 29
17282: PUSH
17283: LD_INT 22
17285: PUSH
17286: LD_INT 3
17288: PUSH
17289: EMPTY
17290: LIST
17291: LIST
17292: PPUSH
17293: CALL_OW 69
17297: PUSH
17298: LD_INT 0
17300: EQUAL
17301: AND
17302: IFFALSE 17505
17304: GO 17306
17306: DISABLE
17307: LD_INT 0
17309: PPUSH
// begin game_status := false ;
17310: LD_ADDR_EXP 29
17314: PUSH
17315: LD_INT 0
17317: ST_TO_ADDR
// if not depotConstructed then
17318: LD_EXP 2
17322: NOT
17323: IFFALSE 17332
// SetAchievement ( ACH_NODEPOT ) ;
17325: LD_STRING ACH_NODEPOT
17327: PPUSH
17328: CALL_OW 543
// if Difficulty = 3 then
17332: LD_OWVAR 67
17336: PUSH
17337: LD_INT 3
17339: EQUAL
17340: IFFALSE 17349
// SetAchievement ( ACH_HARD ) ;
17342: LD_STRING ACH_HARD
17344: PPUSH
17345: CALL_OW 543
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17349: LD_OWVAR 1
17353: PUSH
17354: LD_INT 35
17356: DIVREAL
17357: PUSH
17358: LD_INT 60
17360: DIVREAL
17361: PUSH
17362: LD_INT 70
17364: PUSH
17365: LD_INT 60
17367: PUSH
17368: LD_INT 50
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: LIST
17375: PUSH
17376: LD_OWVAR 67
17380: ARRAY
17381: LESS
17382: IFFALSE 17396
// AddMedal ( play , 1 ) else
17384: LD_STRING play
17386: PPUSH
17387: LD_INT 1
17389: PPUSH
17390: CALL_OW 101
17394: GO 17407
// AddMedal ( play , - 1 ) ;
17396: LD_STRING play
17398: PPUSH
17399: LD_INT 1
17401: NEG
17402: PPUSH
17403: CALL_OW 101
// if sib_bomb_constructed then
17407: LD_EXP 36
17411: IFFALSE 17425
// AddMedal ( sibbomb , 1 ) else
17413: LD_STRING sibbomb
17415: PPUSH
17416: LD_INT 1
17418: PPUSH
17419: CALL_OW 101
17423: GO 17436
// AddMedal ( sibbomb , - 1 ) ;
17425: LD_STRING sibbomb
17427: PPUSH
17428: LD_INT 1
17430: NEG
17431: PPUSH
17432: CALL_OW 101
// if mine_constructed and not mine_ck then
17436: LD_EXP 37
17440: PUSH
17441: LD_EXP 35
17445: NOT
17446: AND
17447: IFFALSE 17459
// AddMedal ( mine , 1 ) ;
17449: LD_STRING mine
17451: PPUSH
17452: LD_INT 1
17454: PPUSH
17455: CALL_OW 101
// if mine_ck then
17459: LD_EXP 35
17463: IFFALSE 17476
// AddMedal ( mine , - 1 ) ;
17465: LD_STRING mine
17467: PPUSH
17468: LD_INT 1
17470: NEG
17471: PPUSH
17472: CALL_OW 101
// if not mine_constructed then
17476: LD_EXP 37
17480: NOT
17481: IFFALSE 17494
// AddMedal ( mine , - 2 ) ;
17483: LD_STRING mine
17485: PPUSH
17486: LD_INT 2
17488: NEG
17489: PPUSH
17490: CALL_OW 101
// GiveMedals ( Main ) ;
17494: LD_STRING Main
17496: PPUSH
17497: CALL_OW 102
// YouWin ;
17501: CALL_OW 103
// end ; end_of_file
17505: PPOPN 1
17507: END
// every 0 0$03 trigger game_status do var time ;
17508: LD_EXP 29
17512: IFFALSE 17677
17514: GO 17516
17516: DISABLE
17517: LD_INT 0
17519: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
17520: LD_ADDR_VAR 0 1
17524: PUSH
17525: LD_INT 1050
17527: PUSH
17528: LD_INT 1575
17530: PUSH
17531: LD_INT 2100
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: LIST
17538: PUSH
17539: LD_OWVAR 67
17543: ARRAY
17544: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
17545: LD_VAR 0 1
17549: PUSH
17550: LD_INT 0
17552: PPUSH
17553: LD_INT 420
17555: PPUSH
17556: CALL_OW 12
17560: PLUS
17561: PPUSH
17562: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
17566: LD_INT 1
17568: PPUSH
17569: LD_INT 5
17571: PPUSH
17572: CALL_OW 12
17576: PPUSH
17577: LD_INT 1
17579: PPUSH
17580: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
17584: LD_INT 105
17586: PPUSH
17587: LD_INT 1050
17589: PPUSH
17590: CALL_OW 12
17594: PPUSH
17595: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
17599: LD_INT 1
17601: PPUSH
17602: LD_INT 5
17604: PPUSH
17605: CALL_OW 12
17609: PPUSH
17610: LD_INT 148
17612: PPUSH
17613: LD_INT 107
17615: PPUSH
17616: LD_INT 20
17618: PPUSH
17619: LD_INT 1
17621: PPUSH
17622: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
17626: LD_OWVAR 1
17630: PUSH
17631: LD_INT 44100
17633: PUSH
17634: LD_INT 37800
17636: PUSH
17637: LD_INT 33600
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: LIST
17644: PUSH
17645: LD_OWVAR 67
17649: ARRAY
17650: MOD
17651: IFFALSE 17667
// time := time + 0 0$20 ;
17653: LD_ADDR_VAR 0 1
17657: PUSH
17658: LD_VAR 0 1
17662: PUSH
17663: LD_INT 700
17665: PLUS
17666: ST_TO_ADDR
// end until game_status = false ;
17667: LD_EXP 29
17671: PUSH
17672: LD_INT 0
17674: EQUAL
17675: IFFALSE 17545
// end ;
17677: PPOPN 1
17679: END
// every 0 0$03 trigger game_status do var time ;
17680: LD_EXP 29
17684: IFFALSE 17838
17686: GO 17688
17688: DISABLE
17689: LD_INT 0
17691: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
17692: LD_ADDR_VAR 0 1
17696: PUSH
17697: LD_INT 700
17699: PUSH
17700: LD_INT 875
17702: PUSH
17703: LD_INT 1400
17705: PUSH
17706: EMPTY
17707: LIST
17708: LIST
17709: LIST
17710: PUSH
17711: LD_OWVAR 67
17715: ARRAY
17716: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
17717: LD_VAR 0 1
17721: PUSH
17722: LD_INT 0
17724: PPUSH
17725: LD_INT 385
17727: PPUSH
17728: CALL_OW 12
17732: PLUS
17733: PPUSH
17734: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
17738: LD_INT 1
17740: PPUSH
17741: LD_INT 5
17743: PPUSH
17744: CALL_OW 12
17748: PPUSH
17749: LD_INT 102
17751: PPUSH
17752: LD_INT 6
17754: PPUSH
17755: LD_INT 25
17757: PPUSH
17758: LD_INT 1
17760: PPUSH
17761: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
17765: LD_OWVAR 1
17769: PUSH
17770: LD_INT 52500
17772: PUSH
17773: LD_INT 46200
17775: PUSH
17776: LD_INT 42000
17778: PUSH
17779: EMPTY
17780: LIST
17781: LIST
17782: LIST
17783: PUSH
17784: LD_OWVAR 67
17788: ARRAY
17789: MOD
17790: IFFALSE 17806
// time := time + 0 0$25 ;
17792: LD_ADDR_VAR 0 1
17796: PUSH
17797: LD_VAR 0 1
17801: PUSH
17802: LD_INT 875
17804: PLUS
17805: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
17806: LD_OWVAR 1
17810: PUSH
17811: LD_INT 231000
17813: MOD
17814: PUSH
17815: LD_INT 0
17817: EQUAL
17818: IFFALSE 17828
// time := 0 0$30 ;
17820: LD_ADDR_VAR 0 1
17824: PUSH
17825: LD_INT 1050
17827: ST_TO_ADDR
// end until game_status = false ;
17828: LD_EXP 29
17832: PUSH
17833: LD_INT 0
17835: EQUAL
17836: IFFALSE 17717
// end ;
17838: PPOPN 1
17840: END
// every 0 0$03 trigger game_status do var time ;
17841: LD_EXP 29
17845: IFFALSE 17981
17847: GO 17849
17849: DISABLE
17850: LD_INT 0
17852: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
17853: LD_ADDR_VAR 0 1
17857: PUSH
17858: LD_INT 1050
17860: PUSH
17861: LD_INT 1575
17863: PUSH
17864: LD_INT 1750
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: LIST
17871: PUSH
17872: LD_OWVAR 67
17876: ARRAY
17877: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
17878: LD_VAR 0 1
17882: PUSH
17883: LD_INT 0
17885: PPUSH
17886: LD_INT 385
17888: PPUSH
17889: CALL_OW 12
17893: PLUS
17894: PPUSH
17895: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
17899: LD_INT 1
17901: PPUSH
17902: LD_INT 5
17904: PPUSH
17905: CALL_OW 12
17909: PPUSH
17910: LD_INT 51
17912: PPUSH
17913: LD_INT 74
17915: PPUSH
17916: LD_INT 25
17918: PPUSH
17919: LD_INT 1
17921: PPUSH
17922: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
17926: LD_OWVAR 1
17930: PUSH
17931: LD_INT 84000
17933: PUSH
17934: LD_INT 105000
17936: PUSH
17937: LD_INT 136500
17939: PUSH
17940: EMPTY
17941: LIST
17942: LIST
17943: LIST
17944: PUSH
17945: LD_OWVAR 67
17949: ARRAY
17950: MOD
17951: PUSH
17952: LD_INT 0
17954: EQUAL
17955: IFFALSE 17971
// time := time + 0 0$15 ;
17957: LD_ADDR_VAR 0 1
17961: PUSH
17962: LD_VAR 0 1
17966: PUSH
17967: LD_INT 525
17969: PLUS
17970: ST_TO_ADDR
// end until game_status = false ;
17971: LD_EXP 29
17975: PUSH
17976: LD_INT 0
17978: EQUAL
17979: IFFALSE 17878
// end ; end_of_file
17981: PPOPN 1
17983: END
// every 0 0$01 trigger not debug do
17984: LD_EXP 1
17988: NOT
17989: IFFALSE 18012
17991: GO 17993
17993: DISABLE
// begin enable ;
17994: ENABLE
// Display_Strings := [ #tick , tick ] ;
17995: LD_ADDR_OWVAR 47
17999: PUSH
18000: LD_STRING #tick
18002: PUSH
18003: LD_OWVAR 1
18007: PUSH
18008: EMPTY
18009: LIST
18010: LIST
18011: ST_TO_ADDR
// end ; end_of_file
18012: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
18013: LD_VAR 0 1
18017: PPUSH
18018: CALL_OW 255
18022: PUSH
18023: LD_INT 3
18025: EQUAL
18026: PUSH
18027: LD_VAR 0 1
18031: PUSH
18032: LD_INT 2
18034: PUSH
18035: LD_INT 34
18037: PUSH
18038: LD_INT 46
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 34
18047: PUSH
18048: LD_INT 47
18050: PUSH
18051: EMPTY
18052: LIST
18053: LIST
18054: PUSH
18055: LD_INT 34
18057: PUSH
18058: LD_INT 45
18060: PUSH
18061: EMPTY
18062: LIST
18063: LIST
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: LIST
18069: LIST
18070: PUSH
18071: EMPTY
18072: LIST
18073: PPUSH
18074: CALL_OW 69
18078: IN
18079: AND
18080: IFFALSE 18098
// ru_reserve := ru_reserve ^ un ;
18082: LD_ADDR_EXP 9
18086: PUSH
18087: LD_EXP 9
18091: PUSH
18092: LD_VAR 0 1
18096: ADD
18097: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
18098: LD_VAR 0 1
18102: PUSH
18103: LD_INT 22
18105: PUSH
18106: LD_INT 3
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: PUSH
18113: LD_INT 34
18115: PUSH
18116: LD_INT 48
18118: PUSH
18119: EMPTY
18120: LIST
18121: LIST
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: PPUSH
18127: CALL_OW 69
18131: IN
18132: IFFALSE 18185
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
18134: LD_INT 12
18136: PPUSH
18137: LD_INT 22
18139: PUSH
18140: LD_INT 1
18142: PUSH
18143: EMPTY
18144: LIST
18145: LIST
18146: PPUSH
18147: CALL_OW 70
18151: IFFALSE 18170
// ComAttackPlace ( un , 98 , 10 ) else
18153: LD_VAR 0 1
18157: PPUSH
18158: LD_INT 98
18160: PPUSH
18161: LD_INT 10
18163: PPUSH
18164: CALL_OW 116
18168: GO 18185
// ComAttackPlace ( un , 134 , 99 ) ;
18170: LD_VAR 0 1
18174: PPUSH
18175: LD_INT 134
18177: PPUSH
18178: LD_INT 99
18180: PPUSH
18181: CALL_OW 116
// end ;
18185: PPOPN 2
18187: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
18188: LD_VAR 0 1
18192: PPUSH
18193: CALL 29897 0 1
// if GetChassis ( un ) = 25 then
18197: LD_VAR 0 1
18201: PPUSH
18202: CALL_OW 265
18206: PUSH
18207: LD_INT 25
18209: EQUAL
18210: IFFALSE 18219
// SetAchievement ( ACH_BEH ) ;
18212: LD_STRING ACH_BEH
18214: PPUSH
18215: CALL_OW 543
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
18219: LD_VAR 0 1
18223: PUSH
18224: LD_INT 22
18226: PUSH
18227: LD_INT 3
18229: PUSH
18230: EMPTY
18231: LIST
18232: LIST
18233: PUSH
18234: LD_INT 21
18236: PUSH
18237: LD_INT 3
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: PPUSH
18248: CALL_OW 69
18252: IN
18253: PUSH
18254: LD_VAR 0 1
18258: PPUSH
18259: CALL_OW 266
18263: PUSH
18264: LD_INT 0
18266: PUSH
18267: LD_INT 29
18269: PUSH
18270: LD_INT 30
18272: PUSH
18273: LD_INT 26
18275: PUSH
18276: EMPTY
18277: LIST
18278: LIST
18279: LIST
18280: LIST
18281: IN
18282: NOT
18283: AND
18284: IFFALSE 18370
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
18286: LD_ADDR_EXP 13
18290: PUSH
18291: LD_EXP 13
18295: PUSH
18296: LD_VAR 0 1
18300: PPUSH
18301: CALL_OW 266
18305: ADD
18306: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
18307: LD_ADDR_EXP 13
18311: PUSH
18312: LD_EXP 13
18316: PUSH
18317: LD_VAR 0 1
18321: PPUSH
18322: CALL_OW 250
18326: ADD
18327: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
18328: LD_ADDR_EXP 13
18332: PUSH
18333: LD_EXP 13
18337: PUSH
18338: LD_VAR 0 1
18342: PPUSH
18343: CALL_OW 251
18347: ADD
18348: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
18349: LD_ADDR_EXP 13
18353: PUSH
18354: LD_EXP 13
18358: PUSH
18359: LD_VAR 0 1
18363: PPUSH
18364: CALL_OW 254
18368: ADD
18369: ST_TO_ADDR
// end ; if un in ru_attack_list then
18370: LD_VAR 0 1
18374: PUSH
18375: LD_EXP 10
18379: IN
18380: IFFALSE 18398
// ru_attack_list := ru_attack_list diff un ;
18382: LD_ADDR_EXP 10
18386: PUSH
18387: LD_EXP 10
18391: PUSH
18392: LD_VAR 0 1
18396: DIFF
18397: ST_TO_ADDR
// if un in ru_protector then
18398: LD_VAR 0 1
18402: PUSH
18403: LD_EXP 17
18407: IN
18408: IFFALSE 18426
// ru_protector := ru_protector diff un ;
18410: LD_ADDR_EXP 17
18414: PUSH
18415: LD_EXP 17
18419: PUSH
18420: LD_VAR 0 1
18424: DIFF
18425: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
18426: LD_VAR 0 1
18430: PPUSH
18431: CALL_OW 266
18435: PUSH
18436: LD_INT 30
18438: EQUAL
18439: PUSH
18440: LD_VAR 0 1
18444: PPUSH
18445: CALL_OW 255
18449: PUSH
18450: LD_INT 1
18452: EQUAL
18453: AND
18454: IFFALSE 18464
// mine_ck := true ;
18456: LD_ADDR_EXP 35
18460: PUSH
18461: LD_INT 1
18463: ST_TO_ADDR
// end ;
18464: PPOPN 1
18466: END
// on BuildingComplete ( un ) do var i ;
18467: LD_INT 0
18469: PPUSH
// begin if GetSide ( un ) = 1 and GetBType ( un ) = b_depot then
18470: LD_VAR 0 1
18474: PPUSH
18475: CALL_OW 255
18479: PUSH
18480: LD_INT 1
18482: EQUAL
18483: PUSH
18484: LD_VAR 0 1
18488: PPUSH
18489: CALL_OW 266
18493: PUSH
18494: LD_INT 0
18496: EQUAL
18497: AND
18498: IFFALSE 18508
// depotConstructed := true ;
18500: LD_ADDR_EXP 2
18504: PUSH
18505: LD_INT 1
18507: ST_TO_ADDR
// if GetSide ( un ) = 1 and GetBType ( un ) = b_siberite_mine then
18508: LD_VAR 0 1
18512: PPUSH
18513: CALL_OW 255
18517: PUSH
18518: LD_INT 1
18520: EQUAL
18521: PUSH
18522: LD_VAR 0 1
18526: PPUSH
18527: CALL_OW 266
18531: PUSH
18532: LD_INT 30
18534: EQUAL
18535: AND
18536: IFFALSE 18546
// mine_constructed := true ;
18538: LD_ADDR_EXP 37
18542: PUSH
18543: LD_INT 1
18545: ST_TO_ADDR
// if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
18546: LD_VAR 0 1
18550: PPUSH
18551: CALL_OW 255
18555: PUSH
18556: LD_INT 3
18558: EQUAL
18559: PUSH
18560: LD_VAR 0 1
18564: PPUSH
18565: CALL_OW 266
18569: PUSH
18570: LD_INT 0
18572: EQUAL
18573: AND
18574: IFFALSE 18631
// begin for i = 1 to 2 do
18576: LD_ADDR_VAR 0 2
18580: PUSH
18581: DOUBLE
18582: LD_INT 1
18584: DEC
18585: ST_TO_ADDR
18586: LD_INT 2
18588: PUSH
18589: FOR_TO
18590: IFFALSE 18629
// begin ComExitBuilding ( ru_sold [ i ] ) ;
18592: LD_EXP 20
18596: PUSH
18597: LD_VAR 0 2
18601: ARRAY
18602: PPUSH
18603: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
18607: LD_EXP 20
18611: PUSH
18612: LD_VAR 0 2
18616: ARRAY
18617: PPUSH
18618: LD_VAR 0 1
18622: PPUSH
18623: CALL_OW 180
// end ;
18627: GO 18589
18629: POP
18630: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
18631: LD_VAR 0 1
18635: PPUSH
18636: CALL_OW 255
18640: PUSH
18641: LD_INT 3
18643: EQUAL
18644: PUSH
18645: LD_VAR 0 1
18649: PPUSH
18650: CALL_OW 266
18654: PUSH
18655: LD_EXP 13
18659: IN
18660: AND
18661: IFFALSE 18701
// for i = 1 to 4 do
18663: LD_ADDR_VAR 0 2
18667: PUSH
18668: DOUBLE
18669: LD_INT 1
18671: DEC
18672: ST_TO_ADDR
18673: LD_INT 4
18675: PUSH
18676: FOR_TO
18677: IFFALSE 18699
// ru_blist := Delete ( ru_blist , 1 ) ;
18679: LD_ADDR_EXP 13
18683: PUSH
18684: LD_EXP 13
18688: PPUSH
18689: LD_INT 1
18691: PPUSH
18692: CALL_OW 3
18696: ST_TO_ADDR
18697: GO 18676
18699: POP
18700: POP
// end ;
18701: PPOPN 2
18703: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
18704: LD_VAR 0 1
18708: PPUSH
18709: LD_VAR 0 2
18713: PPUSH
18714: LD_VAR 0 3
18718: PPUSH
18719: CALL 29995 0 3
// end ;
18723: PPOPN 3
18725: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18726: LD_VAR 0 1
18730: PPUSH
18731: CALL 30003 0 1
// end ; end_of_file
18735: PPOPN 1
18737: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18738: GO 18740
18740: DISABLE
// begin ru_radar := 98 ;
18741: LD_ADDR_EXP 43
18745: PUSH
18746: LD_INT 98
18748: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18749: LD_ADDR_EXP 44
18753: PUSH
18754: LD_INT 89
18756: ST_TO_ADDR
// us_hack := 99 ;
18757: LD_ADDR_EXP 45
18761: PUSH
18762: LD_INT 99
18764: ST_TO_ADDR
// us_artillery := 97 ;
18765: LD_ADDR_EXP 46
18769: PUSH
18770: LD_INT 97
18772: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18773: LD_ADDR_EXP 47
18777: PUSH
18778: LD_INT 91
18780: ST_TO_ADDR
// tech_Artillery := 80 ;
18781: LD_ADDR_EXP 48
18785: PUSH
18786: LD_INT 80
18788: ST_TO_ADDR
// tech_RadMat := 81 ;
18789: LD_ADDR_EXP 49
18793: PUSH
18794: LD_INT 81
18796: ST_TO_ADDR
// tech_BasicTools := 82 ;
18797: LD_ADDR_EXP 50
18801: PUSH
18802: LD_INT 82
18804: ST_TO_ADDR
// tech_Cargo := 83 ;
18805: LD_ADDR_EXP 51
18809: PUSH
18810: LD_INT 83
18812: ST_TO_ADDR
// tech_Track := 84 ;
18813: LD_ADDR_EXP 52
18817: PUSH
18818: LD_INT 84
18820: ST_TO_ADDR
// tech_Crane := 85 ;
18821: LD_ADDR_EXP 53
18825: PUSH
18826: LD_INT 85
18828: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18829: LD_ADDR_EXP 54
18833: PUSH
18834: LD_INT 86
18836: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18837: LD_ADDR_EXP 55
18841: PUSH
18842: LD_INT 87
18844: ST_TO_ADDR
// end ; end_of_file end_of_file
18845: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18846: GO 18848
18848: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18849: LD_STRING initStreamRollete();
18851: PPUSH
18852: CALL_OW 559
// InitStreamMode ;
18856: CALL 18865 0 0
// DefineStreamItems ( ) ;
18860: CALL 19305 0 0
// end ;
18864: END
// function InitStreamMode ; begin
18865: LD_INT 0
18867: PPUSH
// streamModeActive := false ;
18868: LD_ADDR_EXP 56
18872: PUSH
18873: LD_INT 0
18875: ST_TO_ADDR
// normalCounter := 36 ;
18876: LD_ADDR_EXP 57
18880: PUSH
18881: LD_INT 36
18883: ST_TO_ADDR
// hardcoreCounter := 16 ;
18884: LD_ADDR_EXP 58
18888: PUSH
18889: LD_INT 16
18891: ST_TO_ADDR
// sRocket := false ;
18892: LD_ADDR_EXP 61
18896: PUSH
18897: LD_INT 0
18899: ST_TO_ADDR
// sSpeed := false ;
18900: LD_ADDR_EXP 60
18904: PUSH
18905: LD_INT 0
18907: ST_TO_ADDR
// sEngine := false ;
18908: LD_ADDR_EXP 62
18912: PUSH
18913: LD_INT 0
18915: ST_TO_ADDR
// sSpec := false ;
18916: LD_ADDR_EXP 59
18920: PUSH
18921: LD_INT 0
18923: ST_TO_ADDR
// sLevel := false ;
18924: LD_ADDR_EXP 63
18928: PUSH
18929: LD_INT 0
18931: ST_TO_ADDR
// sArmoury := false ;
18932: LD_ADDR_EXP 64
18936: PUSH
18937: LD_INT 0
18939: ST_TO_ADDR
// sRadar := false ;
18940: LD_ADDR_EXP 65
18944: PUSH
18945: LD_INT 0
18947: ST_TO_ADDR
// sBunker := false ;
18948: LD_ADDR_EXP 66
18952: PUSH
18953: LD_INT 0
18955: ST_TO_ADDR
// sHack := false ;
18956: LD_ADDR_EXP 67
18960: PUSH
18961: LD_INT 0
18963: ST_TO_ADDR
// sFire := false ;
18964: LD_ADDR_EXP 68
18968: PUSH
18969: LD_INT 0
18971: ST_TO_ADDR
// sRefresh := false ;
18972: LD_ADDR_EXP 69
18976: PUSH
18977: LD_INT 0
18979: ST_TO_ADDR
// sExp := false ;
18980: LD_ADDR_EXP 70
18984: PUSH
18985: LD_INT 0
18987: ST_TO_ADDR
// sDepot := false ;
18988: LD_ADDR_EXP 71
18992: PUSH
18993: LD_INT 0
18995: ST_TO_ADDR
// sFlag := false ;
18996: LD_ADDR_EXP 72
19000: PUSH
19001: LD_INT 0
19003: ST_TO_ADDR
// sKamikadze := false ;
19004: LD_ADDR_EXP 80
19008: PUSH
19009: LD_INT 0
19011: ST_TO_ADDR
// sTroll := false ;
19012: LD_ADDR_EXP 81
19016: PUSH
19017: LD_INT 0
19019: ST_TO_ADDR
// sSlow := false ;
19020: LD_ADDR_EXP 82
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// sLack := false ;
19028: LD_ADDR_EXP 83
19032: PUSH
19033: LD_INT 0
19035: ST_TO_ADDR
// sTank := false ;
19036: LD_ADDR_EXP 85
19040: PUSH
19041: LD_INT 0
19043: ST_TO_ADDR
// sRemote := false ;
19044: LD_ADDR_EXP 86
19048: PUSH
19049: LD_INT 0
19051: ST_TO_ADDR
// sPowell := false ;
19052: LD_ADDR_EXP 87
19056: PUSH
19057: LD_INT 0
19059: ST_TO_ADDR
// sTeleport := false ;
19060: LD_ADDR_EXP 90
19064: PUSH
19065: LD_INT 0
19067: ST_TO_ADDR
// sOilTower := false ;
19068: LD_ADDR_EXP 92
19072: PUSH
19073: LD_INT 0
19075: ST_TO_ADDR
// sShovel := false ;
19076: LD_ADDR_EXP 93
19080: PUSH
19081: LD_INT 0
19083: ST_TO_ADDR
// sSheik := false ;
19084: LD_ADDR_EXP 94
19088: PUSH
19089: LD_INT 0
19091: ST_TO_ADDR
// sEarthquake := false ;
19092: LD_ADDR_EXP 96
19096: PUSH
19097: LD_INT 0
19099: ST_TO_ADDR
// sAI := false ;
19100: LD_ADDR_EXP 97
19104: PUSH
19105: LD_INT 0
19107: ST_TO_ADDR
// sCargo := false ;
19108: LD_ADDR_EXP 100
19112: PUSH
19113: LD_INT 0
19115: ST_TO_ADDR
// sDLaser := false ;
19116: LD_ADDR_EXP 101
19120: PUSH
19121: LD_INT 0
19123: ST_TO_ADDR
// sExchange := false ;
19124: LD_ADDR_EXP 102
19128: PUSH
19129: LD_INT 0
19131: ST_TO_ADDR
// sFac := false ;
19132: LD_ADDR_EXP 103
19136: PUSH
19137: LD_INT 0
19139: ST_TO_ADDR
// sPower := false ;
19140: LD_ADDR_EXP 104
19144: PUSH
19145: LD_INT 0
19147: ST_TO_ADDR
// sRandom := false ;
19148: LD_ADDR_EXP 105
19152: PUSH
19153: LD_INT 0
19155: ST_TO_ADDR
// sShield := false ;
19156: LD_ADDR_EXP 106
19160: PUSH
19161: LD_INT 0
19163: ST_TO_ADDR
// sTime := false ;
19164: LD_ADDR_EXP 107
19168: PUSH
19169: LD_INT 0
19171: ST_TO_ADDR
// sTools := false ;
19172: LD_ADDR_EXP 108
19176: PUSH
19177: LD_INT 0
19179: ST_TO_ADDR
// sSold := false ;
19180: LD_ADDR_EXP 73
19184: PUSH
19185: LD_INT 0
19187: ST_TO_ADDR
// sDiff := false ;
19188: LD_ADDR_EXP 74
19192: PUSH
19193: LD_INT 0
19195: ST_TO_ADDR
// sFog := false ;
19196: LD_ADDR_EXP 77
19200: PUSH
19201: LD_INT 0
19203: ST_TO_ADDR
// sReset := false ;
19204: LD_ADDR_EXP 78
19208: PUSH
19209: LD_INT 0
19211: ST_TO_ADDR
// sSun := false ;
19212: LD_ADDR_EXP 79
19216: PUSH
19217: LD_INT 0
19219: ST_TO_ADDR
// sTiger := false ;
19220: LD_ADDR_EXP 75
19224: PUSH
19225: LD_INT 0
19227: ST_TO_ADDR
// sBomb := false ;
19228: LD_ADDR_EXP 76
19232: PUSH
19233: LD_INT 0
19235: ST_TO_ADDR
// sWound := false ;
19236: LD_ADDR_EXP 84
19240: PUSH
19241: LD_INT 0
19243: ST_TO_ADDR
// sBetray := false ;
19244: LD_ADDR_EXP 88
19248: PUSH
19249: LD_INT 0
19251: ST_TO_ADDR
// sContamin := false ;
19252: LD_ADDR_EXP 89
19256: PUSH
19257: LD_INT 0
19259: ST_TO_ADDR
// sOil := false ;
19260: LD_ADDR_EXP 91
19264: PUSH
19265: LD_INT 0
19267: ST_TO_ADDR
// sStu := false ;
19268: LD_ADDR_EXP 95
19272: PUSH
19273: LD_INT 0
19275: ST_TO_ADDR
// sBazooka := false ;
19276: LD_ADDR_EXP 98
19280: PUSH
19281: LD_INT 0
19283: ST_TO_ADDR
// sMortar := false ;
19284: LD_ADDR_EXP 99
19288: PUSH
19289: LD_INT 0
19291: ST_TO_ADDR
// sRanger := false ;
19292: LD_ADDR_EXP 109
19296: PUSH
19297: LD_INT 0
19299: ST_TO_ADDR
// end ;
19300: LD_VAR 0 1
19304: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19305: LD_INT 0
19307: PPUSH
19308: PPUSH
19309: PPUSH
19310: PPUSH
19311: PPUSH
// result := [ ] ;
19312: LD_ADDR_VAR 0 1
19316: PUSH
19317: EMPTY
19318: ST_TO_ADDR
// if campaign_id = 1 then
19319: LD_OWVAR 69
19323: PUSH
19324: LD_INT 1
19326: EQUAL
19327: IFFALSE 22265
// begin case mission_number of 1 :
19329: LD_OWVAR 70
19333: PUSH
19334: LD_INT 1
19336: DOUBLE
19337: EQUAL
19338: IFTRUE 19342
19340: GO 19406
19342: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19343: LD_ADDR_VAR 0 1
19347: PUSH
19348: LD_INT 2
19350: PUSH
19351: LD_INT 4
19353: PUSH
19354: LD_INT 11
19356: PUSH
19357: LD_INT 12
19359: PUSH
19360: LD_INT 15
19362: PUSH
19363: LD_INT 16
19365: PUSH
19366: LD_INT 22
19368: PUSH
19369: LD_INT 23
19371: PUSH
19372: LD_INT 26
19374: PUSH
19375: EMPTY
19376: LIST
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: PUSH
19386: LD_INT 101
19388: PUSH
19389: LD_INT 102
19391: PUSH
19392: LD_INT 106
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: LIST
19399: PUSH
19400: EMPTY
19401: LIST
19402: LIST
19403: ST_TO_ADDR
19404: GO 22263
19406: LD_INT 2
19408: DOUBLE
19409: EQUAL
19410: IFTRUE 19414
19412: GO 19486
19414: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19415: LD_ADDR_VAR 0 1
19419: PUSH
19420: LD_INT 2
19422: PUSH
19423: LD_INT 4
19425: PUSH
19426: LD_INT 11
19428: PUSH
19429: LD_INT 12
19431: PUSH
19432: LD_INT 15
19434: PUSH
19435: LD_INT 16
19437: PUSH
19438: LD_INT 22
19440: PUSH
19441: LD_INT 23
19443: PUSH
19444: LD_INT 26
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: LIST
19456: LIST
19457: PUSH
19458: LD_INT 101
19460: PUSH
19461: LD_INT 102
19463: PUSH
19464: LD_INT 105
19466: PUSH
19467: LD_INT 106
19469: PUSH
19470: LD_INT 108
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: LIST
19477: LIST
19478: LIST
19479: PUSH
19480: EMPTY
19481: LIST
19482: LIST
19483: ST_TO_ADDR
19484: GO 22263
19486: LD_INT 3
19488: DOUBLE
19489: EQUAL
19490: IFTRUE 19494
19492: GO 19570
19494: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19495: LD_ADDR_VAR 0 1
19499: PUSH
19500: LD_INT 2
19502: PUSH
19503: LD_INT 4
19505: PUSH
19506: LD_INT 5
19508: PUSH
19509: LD_INT 11
19511: PUSH
19512: LD_INT 12
19514: PUSH
19515: LD_INT 15
19517: PUSH
19518: LD_INT 16
19520: PUSH
19521: LD_INT 22
19523: PUSH
19524: LD_INT 26
19526: PUSH
19527: LD_INT 36
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: LIST
19534: LIST
19535: LIST
19536: LIST
19537: LIST
19538: LIST
19539: LIST
19540: LIST
19541: PUSH
19542: LD_INT 101
19544: PUSH
19545: LD_INT 102
19547: PUSH
19548: LD_INT 105
19550: PUSH
19551: LD_INT 106
19553: PUSH
19554: LD_INT 108
19556: PUSH
19557: EMPTY
19558: LIST
19559: LIST
19560: LIST
19561: LIST
19562: LIST
19563: PUSH
19564: EMPTY
19565: LIST
19566: LIST
19567: ST_TO_ADDR
19568: GO 22263
19570: LD_INT 4
19572: DOUBLE
19573: EQUAL
19574: IFTRUE 19578
19576: GO 19662
19578: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19579: LD_ADDR_VAR 0 1
19583: PUSH
19584: LD_INT 2
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 8
19595: PUSH
19596: LD_INT 11
19598: PUSH
19599: LD_INT 12
19601: PUSH
19602: LD_INT 15
19604: PUSH
19605: LD_INT 16
19607: PUSH
19608: LD_INT 22
19610: PUSH
19611: LD_INT 23
19613: PUSH
19614: LD_INT 26
19616: PUSH
19617: LD_INT 36
19619: PUSH
19620: EMPTY
19621: LIST
19622: LIST
19623: LIST
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: PUSH
19634: LD_INT 101
19636: PUSH
19637: LD_INT 102
19639: PUSH
19640: LD_INT 105
19642: PUSH
19643: LD_INT 106
19645: PUSH
19646: LD_INT 108
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: LIST
19655: PUSH
19656: EMPTY
19657: LIST
19658: LIST
19659: ST_TO_ADDR
19660: GO 22263
19662: LD_INT 5
19664: DOUBLE
19665: EQUAL
19666: IFTRUE 19670
19668: GO 19770
19670: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19671: LD_ADDR_VAR 0 1
19675: PUSH
19676: LD_INT 2
19678: PUSH
19679: LD_INT 4
19681: PUSH
19682: LD_INT 5
19684: PUSH
19685: LD_INT 6
19687: PUSH
19688: LD_INT 8
19690: PUSH
19691: LD_INT 11
19693: PUSH
19694: LD_INT 12
19696: PUSH
19697: LD_INT 15
19699: PUSH
19700: LD_INT 16
19702: PUSH
19703: LD_INT 22
19705: PUSH
19706: LD_INT 23
19708: PUSH
19709: LD_INT 25
19711: PUSH
19712: LD_INT 26
19714: PUSH
19715: LD_INT 36
19717: PUSH
19718: EMPTY
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: PUSH
19734: LD_INT 101
19736: PUSH
19737: LD_INT 102
19739: PUSH
19740: LD_INT 105
19742: PUSH
19743: LD_INT 106
19745: PUSH
19746: LD_INT 108
19748: PUSH
19749: LD_INT 109
19751: PUSH
19752: LD_INT 112
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: PUSH
19764: EMPTY
19765: LIST
19766: LIST
19767: ST_TO_ADDR
19768: GO 22263
19770: LD_INT 6
19772: DOUBLE
19773: EQUAL
19774: IFTRUE 19778
19776: GO 19898
19778: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19779: LD_ADDR_VAR 0 1
19783: PUSH
19784: LD_INT 2
19786: PUSH
19787: LD_INT 4
19789: PUSH
19790: LD_INT 5
19792: PUSH
19793: LD_INT 6
19795: PUSH
19796: LD_INT 8
19798: PUSH
19799: LD_INT 11
19801: PUSH
19802: LD_INT 12
19804: PUSH
19805: LD_INT 15
19807: PUSH
19808: LD_INT 16
19810: PUSH
19811: LD_INT 20
19813: PUSH
19814: LD_INT 21
19816: PUSH
19817: LD_INT 22
19819: PUSH
19820: LD_INT 23
19822: PUSH
19823: LD_INT 25
19825: PUSH
19826: LD_INT 26
19828: PUSH
19829: LD_INT 30
19831: PUSH
19832: LD_INT 31
19834: PUSH
19835: LD_INT 32
19837: PUSH
19838: LD_INT 36
19840: PUSH
19841: EMPTY
19842: LIST
19843: LIST
19844: LIST
19845: LIST
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: LIST
19852: LIST
19853: LIST
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: PUSH
19862: LD_INT 101
19864: PUSH
19865: LD_INT 102
19867: PUSH
19868: LD_INT 105
19870: PUSH
19871: LD_INT 106
19873: PUSH
19874: LD_INT 108
19876: PUSH
19877: LD_INT 109
19879: PUSH
19880: LD_INT 112
19882: PUSH
19883: EMPTY
19884: LIST
19885: LIST
19886: LIST
19887: LIST
19888: LIST
19889: LIST
19890: LIST
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: ST_TO_ADDR
19896: GO 22263
19898: LD_INT 7
19900: DOUBLE
19901: EQUAL
19902: IFTRUE 19906
19904: GO 20006
19906: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19907: LD_ADDR_VAR 0 1
19911: PUSH
19912: LD_INT 2
19914: PUSH
19915: LD_INT 4
19917: PUSH
19918: LD_INT 5
19920: PUSH
19921: LD_INT 7
19923: PUSH
19924: LD_INT 11
19926: PUSH
19927: LD_INT 12
19929: PUSH
19930: LD_INT 15
19932: PUSH
19933: LD_INT 16
19935: PUSH
19936: LD_INT 20
19938: PUSH
19939: LD_INT 21
19941: PUSH
19942: LD_INT 22
19944: PUSH
19945: LD_INT 23
19947: PUSH
19948: LD_INT 25
19950: PUSH
19951: LD_INT 26
19953: PUSH
19954: EMPTY
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: PUSH
19970: LD_INT 101
19972: PUSH
19973: LD_INT 102
19975: PUSH
19976: LD_INT 103
19978: PUSH
19979: LD_INT 105
19981: PUSH
19982: LD_INT 106
19984: PUSH
19985: LD_INT 108
19987: PUSH
19988: LD_INT 112
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: PUSH
20000: EMPTY
20001: LIST
20002: LIST
20003: ST_TO_ADDR
20004: GO 22263
20006: LD_INT 8
20008: DOUBLE
20009: EQUAL
20010: IFTRUE 20014
20012: GO 20142
20014: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
20015: LD_ADDR_VAR 0 1
20019: PUSH
20020: LD_INT 2
20022: PUSH
20023: LD_INT 4
20025: PUSH
20026: LD_INT 5
20028: PUSH
20029: LD_INT 6
20031: PUSH
20032: LD_INT 7
20034: PUSH
20035: LD_INT 8
20037: PUSH
20038: LD_INT 11
20040: PUSH
20041: LD_INT 12
20043: PUSH
20044: LD_INT 15
20046: PUSH
20047: LD_INT 16
20049: PUSH
20050: LD_INT 20
20052: PUSH
20053: LD_INT 21
20055: PUSH
20056: LD_INT 22
20058: PUSH
20059: LD_INT 23
20061: PUSH
20062: LD_INT 25
20064: PUSH
20065: LD_INT 26
20067: PUSH
20068: LD_INT 30
20070: PUSH
20071: LD_INT 31
20073: PUSH
20074: LD_INT 32
20076: PUSH
20077: LD_INT 36
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: LIST
20087: LIST
20088: LIST
20089: LIST
20090: LIST
20091: LIST
20092: LIST
20093: LIST
20094: LIST
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: LIST
20101: PUSH
20102: LD_INT 101
20104: PUSH
20105: LD_INT 102
20107: PUSH
20108: LD_INT 103
20110: PUSH
20111: LD_INT 105
20113: PUSH
20114: LD_INT 106
20116: PUSH
20117: LD_INT 108
20119: PUSH
20120: LD_INT 109
20122: PUSH
20123: LD_INT 112
20125: PUSH
20126: EMPTY
20127: LIST
20128: LIST
20129: LIST
20130: LIST
20131: LIST
20132: LIST
20133: LIST
20134: LIST
20135: PUSH
20136: EMPTY
20137: LIST
20138: LIST
20139: ST_TO_ADDR
20140: GO 22263
20142: LD_INT 9
20144: DOUBLE
20145: EQUAL
20146: IFTRUE 20150
20148: GO 20286
20150: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
20151: LD_ADDR_VAR 0 1
20155: PUSH
20156: LD_INT 2
20158: PUSH
20159: LD_INT 4
20161: PUSH
20162: LD_INT 5
20164: PUSH
20165: LD_INT 6
20167: PUSH
20168: LD_INT 7
20170: PUSH
20171: LD_INT 8
20173: PUSH
20174: LD_INT 11
20176: PUSH
20177: LD_INT 12
20179: PUSH
20180: LD_INT 15
20182: PUSH
20183: LD_INT 16
20185: PUSH
20186: LD_INT 20
20188: PUSH
20189: LD_INT 21
20191: PUSH
20192: LD_INT 22
20194: PUSH
20195: LD_INT 23
20197: PUSH
20198: LD_INT 25
20200: PUSH
20201: LD_INT 26
20203: PUSH
20204: LD_INT 28
20206: PUSH
20207: LD_INT 30
20209: PUSH
20210: LD_INT 31
20212: PUSH
20213: LD_INT 32
20215: PUSH
20216: LD_INT 36
20218: PUSH
20219: EMPTY
20220: LIST
20221: LIST
20222: LIST
20223: LIST
20224: LIST
20225: LIST
20226: LIST
20227: LIST
20228: LIST
20229: LIST
20230: LIST
20231: LIST
20232: LIST
20233: LIST
20234: LIST
20235: LIST
20236: LIST
20237: LIST
20238: LIST
20239: LIST
20240: LIST
20241: PUSH
20242: LD_INT 101
20244: PUSH
20245: LD_INT 102
20247: PUSH
20248: LD_INT 103
20250: PUSH
20251: LD_INT 105
20253: PUSH
20254: LD_INT 106
20256: PUSH
20257: LD_INT 108
20259: PUSH
20260: LD_INT 109
20262: PUSH
20263: LD_INT 112
20265: PUSH
20266: LD_INT 114
20268: PUSH
20269: EMPTY
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: LIST
20277: LIST
20278: LIST
20279: PUSH
20280: EMPTY
20281: LIST
20282: LIST
20283: ST_TO_ADDR
20284: GO 22263
20286: LD_INT 10
20288: DOUBLE
20289: EQUAL
20290: IFTRUE 20294
20292: GO 20478
20294: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20295: LD_ADDR_VAR 0 1
20299: PUSH
20300: LD_INT 2
20302: PUSH
20303: LD_INT 4
20305: PUSH
20306: LD_INT 5
20308: PUSH
20309: LD_INT 6
20311: PUSH
20312: LD_INT 7
20314: PUSH
20315: LD_INT 8
20317: PUSH
20318: LD_INT 9
20320: PUSH
20321: LD_INT 10
20323: PUSH
20324: LD_INT 11
20326: PUSH
20327: LD_INT 12
20329: PUSH
20330: LD_INT 13
20332: PUSH
20333: LD_INT 14
20335: PUSH
20336: LD_INT 15
20338: PUSH
20339: LD_INT 16
20341: PUSH
20342: LD_INT 17
20344: PUSH
20345: LD_INT 18
20347: PUSH
20348: LD_INT 19
20350: PUSH
20351: LD_INT 20
20353: PUSH
20354: LD_INT 21
20356: PUSH
20357: LD_INT 22
20359: PUSH
20360: LD_INT 23
20362: PUSH
20363: LD_INT 24
20365: PUSH
20366: LD_INT 25
20368: PUSH
20369: LD_INT 26
20371: PUSH
20372: LD_INT 28
20374: PUSH
20375: LD_INT 30
20377: PUSH
20378: LD_INT 31
20380: PUSH
20381: LD_INT 32
20383: PUSH
20384: LD_INT 36
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: PUSH
20418: LD_INT 101
20420: PUSH
20421: LD_INT 102
20423: PUSH
20424: LD_INT 103
20426: PUSH
20427: LD_INT 104
20429: PUSH
20430: LD_INT 105
20432: PUSH
20433: LD_INT 106
20435: PUSH
20436: LD_INT 107
20438: PUSH
20439: LD_INT 108
20441: PUSH
20442: LD_INT 109
20444: PUSH
20445: LD_INT 110
20447: PUSH
20448: LD_INT 111
20450: PUSH
20451: LD_INT 112
20453: PUSH
20454: LD_INT 114
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: LIST
20461: LIST
20462: LIST
20463: LIST
20464: LIST
20465: LIST
20466: LIST
20467: LIST
20468: LIST
20469: LIST
20470: LIST
20471: PUSH
20472: EMPTY
20473: LIST
20474: LIST
20475: ST_TO_ADDR
20476: GO 22263
20478: LD_INT 11
20480: DOUBLE
20481: EQUAL
20482: IFTRUE 20486
20484: GO 20678
20486: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20487: LD_ADDR_VAR 0 1
20491: PUSH
20492: LD_INT 2
20494: PUSH
20495: LD_INT 3
20497: PUSH
20498: LD_INT 4
20500: PUSH
20501: LD_INT 5
20503: PUSH
20504: LD_INT 6
20506: PUSH
20507: LD_INT 7
20509: PUSH
20510: LD_INT 8
20512: PUSH
20513: LD_INT 9
20515: PUSH
20516: LD_INT 10
20518: PUSH
20519: LD_INT 11
20521: PUSH
20522: LD_INT 12
20524: PUSH
20525: LD_INT 13
20527: PUSH
20528: LD_INT 14
20530: PUSH
20531: LD_INT 15
20533: PUSH
20534: LD_INT 16
20536: PUSH
20537: LD_INT 17
20539: PUSH
20540: LD_INT 18
20542: PUSH
20543: LD_INT 19
20545: PUSH
20546: LD_INT 20
20548: PUSH
20549: LD_INT 21
20551: PUSH
20552: LD_INT 22
20554: PUSH
20555: LD_INT 23
20557: PUSH
20558: LD_INT 24
20560: PUSH
20561: LD_INT 25
20563: PUSH
20564: LD_INT 26
20566: PUSH
20567: LD_INT 28
20569: PUSH
20570: LD_INT 30
20572: PUSH
20573: LD_INT 31
20575: PUSH
20576: LD_INT 32
20578: PUSH
20579: LD_INT 34
20581: PUSH
20582: LD_INT 36
20584: PUSH
20585: EMPTY
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: LIST
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: PUSH
20618: LD_INT 101
20620: PUSH
20621: LD_INT 102
20623: PUSH
20624: LD_INT 103
20626: PUSH
20627: LD_INT 104
20629: PUSH
20630: LD_INT 105
20632: PUSH
20633: LD_INT 106
20635: PUSH
20636: LD_INT 107
20638: PUSH
20639: LD_INT 108
20641: PUSH
20642: LD_INT 109
20644: PUSH
20645: LD_INT 110
20647: PUSH
20648: LD_INT 111
20650: PUSH
20651: LD_INT 112
20653: PUSH
20654: LD_INT 114
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: LIST
20671: PUSH
20672: EMPTY
20673: LIST
20674: LIST
20675: ST_TO_ADDR
20676: GO 22263
20678: LD_INT 12
20680: DOUBLE
20681: EQUAL
20682: IFTRUE 20686
20684: GO 20894
20686: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20687: LD_ADDR_VAR 0 1
20691: PUSH
20692: LD_INT 1
20694: PUSH
20695: LD_INT 2
20697: PUSH
20698: LD_INT 3
20700: PUSH
20701: LD_INT 4
20703: PUSH
20704: LD_INT 5
20706: PUSH
20707: LD_INT 6
20709: PUSH
20710: LD_INT 7
20712: PUSH
20713: LD_INT 8
20715: PUSH
20716: LD_INT 9
20718: PUSH
20719: LD_INT 10
20721: PUSH
20722: LD_INT 11
20724: PUSH
20725: LD_INT 12
20727: PUSH
20728: LD_INT 13
20730: PUSH
20731: LD_INT 14
20733: PUSH
20734: LD_INT 15
20736: PUSH
20737: LD_INT 16
20739: PUSH
20740: LD_INT 17
20742: PUSH
20743: LD_INT 18
20745: PUSH
20746: LD_INT 19
20748: PUSH
20749: LD_INT 20
20751: PUSH
20752: LD_INT 21
20754: PUSH
20755: LD_INT 22
20757: PUSH
20758: LD_INT 23
20760: PUSH
20761: LD_INT 24
20763: PUSH
20764: LD_INT 25
20766: PUSH
20767: LD_INT 26
20769: PUSH
20770: LD_INT 27
20772: PUSH
20773: LD_INT 28
20775: PUSH
20776: LD_INT 30
20778: PUSH
20779: LD_INT 31
20781: PUSH
20782: LD_INT 32
20784: PUSH
20785: LD_INT 33
20787: PUSH
20788: LD_INT 34
20790: PUSH
20791: LD_INT 36
20793: PUSH
20794: EMPTY
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: LIST
20821: LIST
20822: LIST
20823: LIST
20824: LIST
20825: LIST
20826: LIST
20827: LIST
20828: LIST
20829: PUSH
20830: LD_INT 101
20832: PUSH
20833: LD_INT 102
20835: PUSH
20836: LD_INT 103
20838: PUSH
20839: LD_INT 104
20841: PUSH
20842: LD_INT 105
20844: PUSH
20845: LD_INT 106
20847: PUSH
20848: LD_INT 107
20850: PUSH
20851: LD_INT 108
20853: PUSH
20854: LD_INT 109
20856: PUSH
20857: LD_INT 110
20859: PUSH
20860: LD_INT 111
20862: PUSH
20863: LD_INT 112
20865: PUSH
20866: LD_INT 113
20868: PUSH
20869: LD_INT 114
20871: PUSH
20872: EMPTY
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: LIST
20878: LIST
20879: LIST
20880: LIST
20881: LIST
20882: LIST
20883: LIST
20884: LIST
20885: LIST
20886: LIST
20887: PUSH
20888: EMPTY
20889: LIST
20890: LIST
20891: ST_TO_ADDR
20892: GO 22263
20894: LD_INT 13
20896: DOUBLE
20897: EQUAL
20898: IFTRUE 20902
20900: GO 21098
20902: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20903: LD_ADDR_VAR 0 1
20907: PUSH
20908: LD_INT 1
20910: PUSH
20911: LD_INT 2
20913: PUSH
20914: LD_INT 3
20916: PUSH
20917: LD_INT 4
20919: PUSH
20920: LD_INT 5
20922: PUSH
20923: LD_INT 8
20925: PUSH
20926: LD_INT 9
20928: PUSH
20929: LD_INT 10
20931: PUSH
20932: LD_INT 11
20934: PUSH
20935: LD_INT 12
20937: PUSH
20938: LD_INT 14
20940: PUSH
20941: LD_INT 15
20943: PUSH
20944: LD_INT 16
20946: PUSH
20947: LD_INT 17
20949: PUSH
20950: LD_INT 18
20952: PUSH
20953: LD_INT 19
20955: PUSH
20956: LD_INT 20
20958: PUSH
20959: LD_INT 21
20961: PUSH
20962: LD_INT 22
20964: PUSH
20965: LD_INT 23
20967: PUSH
20968: LD_INT 24
20970: PUSH
20971: LD_INT 25
20973: PUSH
20974: LD_INT 26
20976: PUSH
20977: LD_INT 27
20979: PUSH
20980: LD_INT 28
20982: PUSH
20983: LD_INT 30
20985: PUSH
20986: LD_INT 31
20988: PUSH
20989: LD_INT 32
20991: PUSH
20992: LD_INT 33
20994: PUSH
20995: LD_INT 34
20997: PUSH
20998: LD_INT 36
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: LIST
21005: LIST
21006: LIST
21007: LIST
21008: LIST
21009: LIST
21010: LIST
21011: LIST
21012: LIST
21013: LIST
21014: LIST
21015: LIST
21016: LIST
21017: LIST
21018: LIST
21019: LIST
21020: LIST
21021: LIST
21022: LIST
21023: LIST
21024: LIST
21025: LIST
21026: LIST
21027: LIST
21028: LIST
21029: LIST
21030: LIST
21031: LIST
21032: LIST
21033: PUSH
21034: LD_INT 101
21036: PUSH
21037: LD_INT 102
21039: PUSH
21040: LD_INT 103
21042: PUSH
21043: LD_INT 104
21045: PUSH
21046: LD_INT 105
21048: PUSH
21049: LD_INT 106
21051: PUSH
21052: LD_INT 107
21054: PUSH
21055: LD_INT 108
21057: PUSH
21058: LD_INT 109
21060: PUSH
21061: LD_INT 110
21063: PUSH
21064: LD_INT 111
21066: PUSH
21067: LD_INT 112
21069: PUSH
21070: LD_INT 113
21072: PUSH
21073: LD_INT 114
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: LIST
21080: LIST
21081: LIST
21082: LIST
21083: LIST
21084: LIST
21085: LIST
21086: LIST
21087: LIST
21088: LIST
21089: LIST
21090: LIST
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: ST_TO_ADDR
21096: GO 22263
21098: LD_INT 14
21100: DOUBLE
21101: EQUAL
21102: IFTRUE 21106
21104: GO 21318
21106: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
21107: LD_ADDR_VAR 0 1
21111: PUSH
21112: LD_INT 1
21114: PUSH
21115: LD_INT 2
21117: PUSH
21118: LD_INT 3
21120: PUSH
21121: LD_INT 4
21123: PUSH
21124: LD_INT 5
21126: PUSH
21127: LD_INT 6
21129: PUSH
21130: LD_INT 7
21132: PUSH
21133: LD_INT 8
21135: PUSH
21136: LD_INT 9
21138: PUSH
21139: LD_INT 10
21141: PUSH
21142: LD_INT 11
21144: PUSH
21145: LD_INT 12
21147: PUSH
21148: LD_INT 13
21150: PUSH
21151: LD_INT 14
21153: PUSH
21154: LD_INT 15
21156: PUSH
21157: LD_INT 16
21159: PUSH
21160: LD_INT 17
21162: PUSH
21163: LD_INT 18
21165: PUSH
21166: LD_INT 19
21168: PUSH
21169: LD_INT 20
21171: PUSH
21172: LD_INT 21
21174: PUSH
21175: LD_INT 22
21177: PUSH
21178: LD_INT 23
21180: PUSH
21181: LD_INT 24
21183: PUSH
21184: LD_INT 25
21186: PUSH
21187: LD_INT 26
21189: PUSH
21190: LD_INT 27
21192: PUSH
21193: LD_INT 28
21195: PUSH
21196: LD_INT 29
21198: PUSH
21199: LD_INT 30
21201: PUSH
21202: LD_INT 31
21204: PUSH
21205: LD_INT 32
21207: PUSH
21208: LD_INT 33
21210: PUSH
21211: LD_INT 34
21213: PUSH
21214: LD_INT 36
21216: PUSH
21217: EMPTY
21218: LIST
21219: LIST
21220: LIST
21221: LIST
21222: LIST
21223: LIST
21224: LIST
21225: LIST
21226: LIST
21227: LIST
21228: LIST
21229: LIST
21230: LIST
21231: LIST
21232: LIST
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: LIST
21238: LIST
21239: LIST
21240: LIST
21241: LIST
21242: LIST
21243: LIST
21244: LIST
21245: LIST
21246: LIST
21247: LIST
21248: LIST
21249: LIST
21250: LIST
21251: LIST
21252: LIST
21253: PUSH
21254: LD_INT 101
21256: PUSH
21257: LD_INT 102
21259: PUSH
21260: LD_INT 103
21262: PUSH
21263: LD_INT 104
21265: PUSH
21266: LD_INT 105
21268: PUSH
21269: LD_INT 106
21271: PUSH
21272: LD_INT 107
21274: PUSH
21275: LD_INT 108
21277: PUSH
21278: LD_INT 109
21280: PUSH
21281: LD_INT 110
21283: PUSH
21284: LD_INT 111
21286: PUSH
21287: LD_INT 112
21289: PUSH
21290: LD_INT 113
21292: PUSH
21293: LD_INT 114
21295: PUSH
21296: EMPTY
21297: LIST
21298: LIST
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: LIST
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: PUSH
21312: EMPTY
21313: LIST
21314: LIST
21315: ST_TO_ADDR
21316: GO 22263
21318: LD_INT 15
21320: DOUBLE
21321: EQUAL
21322: IFTRUE 21326
21324: GO 21538
21326: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21327: LD_ADDR_VAR 0 1
21331: PUSH
21332: LD_INT 1
21334: PUSH
21335: LD_INT 2
21337: PUSH
21338: LD_INT 3
21340: PUSH
21341: LD_INT 4
21343: PUSH
21344: LD_INT 5
21346: PUSH
21347: LD_INT 6
21349: PUSH
21350: LD_INT 7
21352: PUSH
21353: LD_INT 8
21355: PUSH
21356: LD_INT 9
21358: PUSH
21359: LD_INT 10
21361: PUSH
21362: LD_INT 11
21364: PUSH
21365: LD_INT 12
21367: PUSH
21368: LD_INT 13
21370: PUSH
21371: LD_INT 14
21373: PUSH
21374: LD_INT 15
21376: PUSH
21377: LD_INT 16
21379: PUSH
21380: LD_INT 17
21382: PUSH
21383: LD_INT 18
21385: PUSH
21386: LD_INT 19
21388: PUSH
21389: LD_INT 20
21391: PUSH
21392: LD_INT 21
21394: PUSH
21395: LD_INT 22
21397: PUSH
21398: LD_INT 23
21400: PUSH
21401: LD_INT 24
21403: PUSH
21404: LD_INT 25
21406: PUSH
21407: LD_INT 26
21409: PUSH
21410: LD_INT 27
21412: PUSH
21413: LD_INT 28
21415: PUSH
21416: LD_INT 29
21418: PUSH
21419: LD_INT 30
21421: PUSH
21422: LD_INT 31
21424: PUSH
21425: LD_INT 32
21427: PUSH
21428: LD_INT 33
21430: PUSH
21431: LD_INT 34
21433: PUSH
21434: LD_INT 36
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: LIST
21448: LIST
21449: LIST
21450: LIST
21451: LIST
21452: LIST
21453: LIST
21454: LIST
21455: LIST
21456: LIST
21457: LIST
21458: LIST
21459: LIST
21460: LIST
21461: LIST
21462: LIST
21463: LIST
21464: LIST
21465: LIST
21466: LIST
21467: LIST
21468: LIST
21469: LIST
21470: LIST
21471: LIST
21472: LIST
21473: PUSH
21474: LD_INT 101
21476: PUSH
21477: LD_INT 102
21479: PUSH
21480: LD_INT 103
21482: PUSH
21483: LD_INT 104
21485: PUSH
21486: LD_INT 105
21488: PUSH
21489: LD_INT 106
21491: PUSH
21492: LD_INT 107
21494: PUSH
21495: LD_INT 108
21497: PUSH
21498: LD_INT 109
21500: PUSH
21501: LD_INT 110
21503: PUSH
21504: LD_INT 111
21506: PUSH
21507: LD_INT 112
21509: PUSH
21510: LD_INT 113
21512: PUSH
21513: LD_INT 114
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: LIST
21520: LIST
21521: LIST
21522: LIST
21523: LIST
21524: LIST
21525: LIST
21526: LIST
21527: LIST
21528: LIST
21529: LIST
21530: LIST
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: ST_TO_ADDR
21536: GO 22263
21538: LD_INT 16
21540: DOUBLE
21541: EQUAL
21542: IFTRUE 21546
21544: GO 21670
21546: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21547: LD_ADDR_VAR 0 1
21551: PUSH
21552: LD_INT 2
21554: PUSH
21555: LD_INT 4
21557: PUSH
21558: LD_INT 5
21560: PUSH
21561: LD_INT 7
21563: PUSH
21564: LD_INT 11
21566: PUSH
21567: LD_INT 12
21569: PUSH
21570: LD_INT 15
21572: PUSH
21573: LD_INT 16
21575: PUSH
21576: LD_INT 20
21578: PUSH
21579: LD_INT 21
21581: PUSH
21582: LD_INT 22
21584: PUSH
21585: LD_INT 23
21587: PUSH
21588: LD_INT 25
21590: PUSH
21591: LD_INT 26
21593: PUSH
21594: LD_INT 30
21596: PUSH
21597: LD_INT 31
21599: PUSH
21600: LD_INT 32
21602: PUSH
21603: LD_INT 33
21605: PUSH
21606: LD_INT 34
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: LIST
21613: LIST
21614: LIST
21615: LIST
21616: LIST
21617: LIST
21618: LIST
21619: LIST
21620: LIST
21621: LIST
21622: LIST
21623: LIST
21624: LIST
21625: LIST
21626: LIST
21627: LIST
21628: LIST
21629: PUSH
21630: LD_INT 101
21632: PUSH
21633: LD_INT 102
21635: PUSH
21636: LD_INT 103
21638: PUSH
21639: LD_INT 106
21641: PUSH
21642: LD_INT 108
21644: PUSH
21645: LD_INT 112
21647: PUSH
21648: LD_INT 113
21650: PUSH
21651: LD_INT 114
21653: PUSH
21654: EMPTY
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: ST_TO_ADDR
21668: GO 22263
21670: LD_INT 17
21672: DOUBLE
21673: EQUAL
21674: IFTRUE 21678
21676: GO 21890
21678: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21679: LD_ADDR_VAR 0 1
21683: PUSH
21684: LD_INT 1
21686: PUSH
21687: LD_INT 2
21689: PUSH
21690: LD_INT 3
21692: PUSH
21693: LD_INT 4
21695: PUSH
21696: LD_INT 5
21698: PUSH
21699: LD_INT 6
21701: PUSH
21702: LD_INT 7
21704: PUSH
21705: LD_INT 8
21707: PUSH
21708: LD_INT 9
21710: PUSH
21711: LD_INT 10
21713: PUSH
21714: LD_INT 11
21716: PUSH
21717: LD_INT 12
21719: PUSH
21720: LD_INT 13
21722: PUSH
21723: LD_INT 14
21725: PUSH
21726: LD_INT 15
21728: PUSH
21729: LD_INT 16
21731: PUSH
21732: LD_INT 17
21734: PUSH
21735: LD_INT 18
21737: PUSH
21738: LD_INT 19
21740: PUSH
21741: LD_INT 20
21743: PUSH
21744: LD_INT 21
21746: PUSH
21747: LD_INT 22
21749: PUSH
21750: LD_INT 23
21752: PUSH
21753: LD_INT 24
21755: PUSH
21756: LD_INT 25
21758: PUSH
21759: LD_INT 26
21761: PUSH
21762: LD_INT 27
21764: PUSH
21765: LD_INT 28
21767: PUSH
21768: LD_INT 29
21770: PUSH
21771: LD_INT 30
21773: PUSH
21774: LD_INT 31
21776: PUSH
21777: LD_INT 32
21779: PUSH
21780: LD_INT 33
21782: PUSH
21783: LD_INT 34
21785: PUSH
21786: LD_INT 36
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: LIST
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: LIST
21801: LIST
21802: LIST
21803: LIST
21804: LIST
21805: LIST
21806: LIST
21807: LIST
21808: LIST
21809: LIST
21810: LIST
21811: LIST
21812: LIST
21813: LIST
21814: LIST
21815: LIST
21816: LIST
21817: LIST
21818: LIST
21819: LIST
21820: LIST
21821: LIST
21822: LIST
21823: LIST
21824: LIST
21825: PUSH
21826: LD_INT 101
21828: PUSH
21829: LD_INT 102
21831: PUSH
21832: LD_INT 103
21834: PUSH
21835: LD_INT 104
21837: PUSH
21838: LD_INT 105
21840: PUSH
21841: LD_INT 106
21843: PUSH
21844: LD_INT 107
21846: PUSH
21847: LD_INT 108
21849: PUSH
21850: LD_INT 109
21852: PUSH
21853: LD_INT 110
21855: PUSH
21856: LD_INT 111
21858: PUSH
21859: LD_INT 112
21861: PUSH
21862: LD_INT 113
21864: PUSH
21865: LD_INT 114
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: LIST
21872: LIST
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: LIST
21878: LIST
21879: LIST
21880: LIST
21881: LIST
21882: LIST
21883: PUSH
21884: EMPTY
21885: LIST
21886: LIST
21887: ST_TO_ADDR
21888: GO 22263
21890: LD_INT 18
21892: DOUBLE
21893: EQUAL
21894: IFTRUE 21898
21896: GO 22034
21898: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21899: LD_ADDR_VAR 0 1
21903: PUSH
21904: LD_INT 2
21906: PUSH
21907: LD_INT 4
21909: PUSH
21910: LD_INT 5
21912: PUSH
21913: LD_INT 7
21915: PUSH
21916: LD_INT 11
21918: PUSH
21919: LD_INT 12
21921: PUSH
21922: LD_INT 15
21924: PUSH
21925: LD_INT 16
21927: PUSH
21928: LD_INT 20
21930: PUSH
21931: LD_INT 21
21933: PUSH
21934: LD_INT 22
21936: PUSH
21937: LD_INT 23
21939: PUSH
21940: LD_INT 25
21942: PUSH
21943: LD_INT 26
21945: PUSH
21946: LD_INT 30
21948: PUSH
21949: LD_INT 31
21951: PUSH
21952: LD_INT 32
21954: PUSH
21955: LD_INT 33
21957: PUSH
21958: LD_INT 34
21960: PUSH
21961: LD_INT 35
21963: PUSH
21964: LD_INT 36
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: LIST
21975: LIST
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: LIST
21986: LIST
21987: LIST
21988: LIST
21989: PUSH
21990: LD_INT 101
21992: PUSH
21993: LD_INT 102
21995: PUSH
21996: LD_INT 103
21998: PUSH
21999: LD_INT 106
22001: PUSH
22002: LD_INT 108
22004: PUSH
22005: LD_INT 112
22007: PUSH
22008: LD_INT 113
22010: PUSH
22011: LD_INT 114
22013: PUSH
22014: LD_INT 115
22016: PUSH
22017: EMPTY
22018: LIST
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: LIST
22024: LIST
22025: LIST
22026: LIST
22027: PUSH
22028: EMPTY
22029: LIST
22030: LIST
22031: ST_TO_ADDR
22032: GO 22263
22034: LD_INT 19
22036: DOUBLE
22037: EQUAL
22038: IFTRUE 22042
22040: GO 22262
22042: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
22043: LD_ADDR_VAR 0 1
22047: PUSH
22048: LD_INT 1
22050: PUSH
22051: LD_INT 2
22053: PUSH
22054: LD_INT 3
22056: PUSH
22057: LD_INT 4
22059: PUSH
22060: LD_INT 5
22062: PUSH
22063: LD_INT 6
22065: PUSH
22066: LD_INT 7
22068: PUSH
22069: LD_INT 8
22071: PUSH
22072: LD_INT 9
22074: PUSH
22075: LD_INT 10
22077: PUSH
22078: LD_INT 11
22080: PUSH
22081: LD_INT 12
22083: PUSH
22084: LD_INT 13
22086: PUSH
22087: LD_INT 14
22089: PUSH
22090: LD_INT 15
22092: PUSH
22093: LD_INT 16
22095: PUSH
22096: LD_INT 17
22098: PUSH
22099: LD_INT 18
22101: PUSH
22102: LD_INT 19
22104: PUSH
22105: LD_INT 20
22107: PUSH
22108: LD_INT 21
22110: PUSH
22111: LD_INT 22
22113: PUSH
22114: LD_INT 23
22116: PUSH
22117: LD_INT 24
22119: PUSH
22120: LD_INT 25
22122: PUSH
22123: LD_INT 26
22125: PUSH
22126: LD_INT 27
22128: PUSH
22129: LD_INT 28
22131: PUSH
22132: LD_INT 29
22134: PUSH
22135: LD_INT 30
22137: PUSH
22138: LD_INT 31
22140: PUSH
22141: LD_INT 32
22143: PUSH
22144: LD_INT 33
22146: PUSH
22147: LD_INT 34
22149: PUSH
22150: LD_INT 35
22152: PUSH
22153: LD_INT 36
22155: PUSH
22156: EMPTY
22157: LIST
22158: LIST
22159: LIST
22160: LIST
22161: LIST
22162: LIST
22163: LIST
22164: LIST
22165: LIST
22166: LIST
22167: LIST
22168: LIST
22169: LIST
22170: LIST
22171: LIST
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: LIST
22177: LIST
22178: LIST
22179: LIST
22180: LIST
22181: LIST
22182: LIST
22183: LIST
22184: LIST
22185: LIST
22186: LIST
22187: LIST
22188: LIST
22189: LIST
22190: LIST
22191: LIST
22192: LIST
22193: PUSH
22194: LD_INT 101
22196: PUSH
22197: LD_INT 102
22199: PUSH
22200: LD_INT 103
22202: PUSH
22203: LD_INT 104
22205: PUSH
22206: LD_INT 105
22208: PUSH
22209: LD_INT 106
22211: PUSH
22212: LD_INT 107
22214: PUSH
22215: LD_INT 108
22217: PUSH
22218: LD_INT 109
22220: PUSH
22221: LD_INT 110
22223: PUSH
22224: LD_INT 111
22226: PUSH
22227: LD_INT 112
22229: PUSH
22230: LD_INT 113
22232: PUSH
22233: LD_INT 114
22235: PUSH
22236: LD_INT 115
22238: PUSH
22239: EMPTY
22240: LIST
22241: LIST
22242: LIST
22243: LIST
22244: LIST
22245: LIST
22246: LIST
22247: LIST
22248: LIST
22249: LIST
22250: LIST
22251: LIST
22252: LIST
22253: LIST
22254: LIST
22255: PUSH
22256: EMPTY
22257: LIST
22258: LIST
22259: ST_TO_ADDR
22260: GO 22263
22262: POP
// end else
22263: GO 22482
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
22265: LD_ADDR_VAR 0 1
22269: PUSH
22270: LD_INT 1
22272: PUSH
22273: LD_INT 2
22275: PUSH
22276: LD_INT 3
22278: PUSH
22279: LD_INT 4
22281: PUSH
22282: LD_INT 5
22284: PUSH
22285: LD_INT 6
22287: PUSH
22288: LD_INT 7
22290: PUSH
22291: LD_INT 8
22293: PUSH
22294: LD_INT 9
22296: PUSH
22297: LD_INT 10
22299: PUSH
22300: LD_INT 11
22302: PUSH
22303: LD_INT 12
22305: PUSH
22306: LD_INT 13
22308: PUSH
22309: LD_INT 14
22311: PUSH
22312: LD_INT 15
22314: PUSH
22315: LD_INT 16
22317: PUSH
22318: LD_INT 17
22320: PUSH
22321: LD_INT 18
22323: PUSH
22324: LD_INT 19
22326: PUSH
22327: LD_INT 20
22329: PUSH
22330: LD_INT 21
22332: PUSH
22333: LD_INT 22
22335: PUSH
22336: LD_INT 23
22338: PUSH
22339: LD_INT 24
22341: PUSH
22342: LD_INT 25
22344: PUSH
22345: LD_INT 26
22347: PUSH
22348: LD_INT 27
22350: PUSH
22351: LD_INT 28
22353: PUSH
22354: LD_INT 29
22356: PUSH
22357: LD_INT 30
22359: PUSH
22360: LD_INT 31
22362: PUSH
22363: LD_INT 32
22365: PUSH
22366: LD_INT 33
22368: PUSH
22369: LD_INT 34
22371: PUSH
22372: LD_INT 35
22374: PUSH
22375: LD_INT 36
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: LIST
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: LIST
22387: LIST
22388: LIST
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: LIST
22394: LIST
22395: LIST
22396: LIST
22397: LIST
22398: LIST
22399: LIST
22400: LIST
22401: LIST
22402: LIST
22403: LIST
22404: LIST
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: LIST
22410: LIST
22411: LIST
22412: LIST
22413: LIST
22414: LIST
22415: PUSH
22416: LD_INT 101
22418: PUSH
22419: LD_INT 102
22421: PUSH
22422: LD_INT 103
22424: PUSH
22425: LD_INT 104
22427: PUSH
22428: LD_INT 105
22430: PUSH
22431: LD_INT 106
22433: PUSH
22434: LD_INT 107
22436: PUSH
22437: LD_INT 108
22439: PUSH
22440: LD_INT 109
22442: PUSH
22443: LD_INT 110
22445: PUSH
22446: LD_INT 111
22448: PUSH
22449: LD_INT 112
22451: PUSH
22452: LD_INT 113
22454: PUSH
22455: LD_INT 114
22457: PUSH
22458: LD_INT 115
22460: PUSH
22461: EMPTY
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: LIST
22467: LIST
22468: LIST
22469: LIST
22470: LIST
22471: LIST
22472: LIST
22473: LIST
22474: LIST
22475: LIST
22476: LIST
22477: PUSH
22478: EMPTY
22479: LIST
22480: LIST
22481: ST_TO_ADDR
// if result then
22482: LD_VAR 0 1
22486: IFFALSE 22775
// begin normal :=  ;
22488: LD_ADDR_VAR 0 3
22492: PUSH
22493: LD_STRING 
22495: ST_TO_ADDR
// hardcore :=  ;
22496: LD_ADDR_VAR 0 4
22500: PUSH
22501: LD_STRING 
22503: ST_TO_ADDR
// for i = 1 to normalCounter do
22504: LD_ADDR_VAR 0 5
22508: PUSH
22509: DOUBLE
22510: LD_INT 1
22512: DEC
22513: ST_TO_ADDR
22514: LD_EXP 57
22518: PUSH
22519: FOR_TO
22520: IFFALSE 22621
// begin tmp := 0 ;
22522: LD_ADDR_VAR 0 2
22526: PUSH
22527: LD_STRING 0
22529: ST_TO_ADDR
// if result [ 1 ] then
22530: LD_VAR 0 1
22534: PUSH
22535: LD_INT 1
22537: ARRAY
22538: IFFALSE 22603
// if result [ 1 ] [ 1 ] = i then
22540: LD_VAR 0 1
22544: PUSH
22545: LD_INT 1
22547: ARRAY
22548: PUSH
22549: LD_INT 1
22551: ARRAY
22552: PUSH
22553: LD_VAR 0 5
22557: EQUAL
22558: IFFALSE 22603
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22560: LD_ADDR_VAR 0 1
22564: PUSH
22565: LD_VAR 0 1
22569: PPUSH
22570: LD_INT 1
22572: PPUSH
22573: LD_VAR 0 1
22577: PUSH
22578: LD_INT 1
22580: ARRAY
22581: PPUSH
22582: LD_INT 1
22584: PPUSH
22585: CALL_OW 3
22589: PPUSH
22590: CALL_OW 1
22594: ST_TO_ADDR
// tmp := 1 ;
22595: LD_ADDR_VAR 0 2
22599: PUSH
22600: LD_STRING 1
22602: ST_TO_ADDR
// end ; normal := normal & tmp ;
22603: LD_ADDR_VAR 0 3
22607: PUSH
22608: LD_VAR 0 3
22612: PUSH
22613: LD_VAR 0 2
22617: STR
22618: ST_TO_ADDR
// end ;
22619: GO 22519
22621: POP
22622: POP
// for i = 1 to hardcoreCounter do
22623: LD_ADDR_VAR 0 5
22627: PUSH
22628: DOUBLE
22629: LD_INT 1
22631: DEC
22632: ST_TO_ADDR
22633: LD_EXP 58
22637: PUSH
22638: FOR_TO
22639: IFFALSE 22744
// begin tmp := 0 ;
22641: LD_ADDR_VAR 0 2
22645: PUSH
22646: LD_STRING 0
22648: ST_TO_ADDR
// if result [ 2 ] then
22649: LD_VAR 0 1
22653: PUSH
22654: LD_INT 2
22656: ARRAY
22657: IFFALSE 22726
// if result [ 2 ] [ 1 ] = 100 + i then
22659: LD_VAR 0 1
22663: PUSH
22664: LD_INT 2
22666: ARRAY
22667: PUSH
22668: LD_INT 1
22670: ARRAY
22671: PUSH
22672: LD_INT 100
22674: PUSH
22675: LD_VAR 0 5
22679: PLUS
22680: EQUAL
22681: IFFALSE 22726
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22683: LD_ADDR_VAR 0 1
22687: PUSH
22688: LD_VAR 0 1
22692: PPUSH
22693: LD_INT 2
22695: PPUSH
22696: LD_VAR 0 1
22700: PUSH
22701: LD_INT 2
22703: ARRAY
22704: PPUSH
22705: LD_INT 1
22707: PPUSH
22708: CALL_OW 3
22712: PPUSH
22713: CALL_OW 1
22717: ST_TO_ADDR
// tmp := 1 ;
22718: LD_ADDR_VAR 0 2
22722: PUSH
22723: LD_STRING 1
22725: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22726: LD_ADDR_VAR 0 4
22730: PUSH
22731: LD_VAR 0 4
22735: PUSH
22736: LD_VAR 0 2
22740: STR
22741: ST_TO_ADDR
// end ;
22742: GO 22638
22744: POP
22745: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22746: LD_STRING getStreamItemsFromMission("
22748: PUSH
22749: LD_VAR 0 3
22753: STR
22754: PUSH
22755: LD_STRING ","
22757: STR
22758: PUSH
22759: LD_VAR 0 4
22763: STR
22764: PUSH
22765: LD_STRING ")
22767: STR
22768: PPUSH
22769: CALL_OW 559
// end else
22773: GO 22782
// ToLua ( getStreamItemsFromMission("","") ) ;
22775: LD_STRING getStreamItemsFromMission("","")
22777: PPUSH
22778: CALL_OW 559
// end ;
22782: LD_VAR 0 1
22786: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22787: LD_VAR 0 2
22791: PUSH
22792: LD_INT 100
22794: EQUAL
22795: IFFALSE 23744
// begin if not StreamModeActive then
22797: LD_EXP 56
22801: NOT
22802: IFFALSE 22812
// StreamModeActive := true ;
22804: LD_ADDR_EXP 56
22808: PUSH
22809: LD_INT 1
22811: ST_TO_ADDR
// if p3 = 0 then
22812: LD_VAR 0 3
22816: PUSH
22817: LD_INT 0
22819: EQUAL
22820: IFFALSE 22826
// InitStreamMode ;
22822: CALL 18865 0 0
// if p3 = 1 then
22826: LD_VAR 0 3
22830: PUSH
22831: LD_INT 1
22833: EQUAL
22834: IFFALSE 22844
// sRocket := true ;
22836: LD_ADDR_EXP 61
22840: PUSH
22841: LD_INT 1
22843: ST_TO_ADDR
// if p3 = 2 then
22844: LD_VAR 0 3
22848: PUSH
22849: LD_INT 2
22851: EQUAL
22852: IFFALSE 22862
// sSpeed := true ;
22854: LD_ADDR_EXP 60
22858: PUSH
22859: LD_INT 1
22861: ST_TO_ADDR
// if p3 = 3 then
22862: LD_VAR 0 3
22866: PUSH
22867: LD_INT 3
22869: EQUAL
22870: IFFALSE 22880
// sEngine := true ;
22872: LD_ADDR_EXP 62
22876: PUSH
22877: LD_INT 1
22879: ST_TO_ADDR
// if p3 = 4 then
22880: LD_VAR 0 3
22884: PUSH
22885: LD_INT 4
22887: EQUAL
22888: IFFALSE 22898
// sSpec := true ;
22890: LD_ADDR_EXP 59
22894: PUSH
22895: LD_INT 1
22897: ST_TO_ADDR
// if p3 = 5 then
22898: LD_VAR 0 3
22902: PUSH
22903: LD_INT 5
22905: EQUAL
22906: IFFALSE 22916
// sLevel := true ;
22908: LD_ADDR_EXP 63
22912: PUSH
22913: LD_INT 1
22915: ST_TO_ADDR
// if p3 = 6 then
22916: LD_VAR 0 3
22920: PUSH
22921: LD_INT 6
22923: EQUAL
22924: IFFALSE 22934
// sArmoury := true ;
22926: LD_ADDR_EXP 64
22930: PUSH
22931: LD_INT 1
22933: ST_TO_ADDR
// if p3 = 7 then
22934: LD_VAR 0 3
22938: PUSH
22939: LD_INT 7
22941: EQUAL
22942: IFFALSE 22952
// sRadar := true ;
22944: LD_ADDR_EXP 65
22948: PUSH
22949: LD_INT 1
22951: ST_TO_ADDR
// if p3 = 8 then
22952: LD_VAR 0 3
22956: PUSH
22957: LD_INT 8
22959: EQUAL
22960: IFFALSE 22970
// sBunker := true ;
22962: LD_ADDR_EXP 66
22966: PUSH
22967: LD_INT 1
22969: ST_TO_ADDR
// if p3 = 9 then
22970: LD_VAR 0 3
22974: PUSH
22975: LD_INT 9
22977: EQUAL
22978: IFFALSE 22988
// sHack := true ;
22980: LD_ADDR_EXP 67
22984: PUSH
22985: LD_INT 1
22987: ST_TO_ADDR
// if p3 = 10 then
22988: LD_VAR 0 3
22992: PUSH
22993: LD_INT 10
22995: EQUAL
22996: IFFALSE 23006
// sFire := true ;
22998: LD_ADDR_EXP 68
23002: PUSH
23003: LD_INT 1
23005: ST_TO_ADDR
// if p3 = 11 then
23006: LD_VAR 0 3
23010: PUSH
23011: LD_INT 11
23013: EQUAL
23014: IFFALSE 23024
// sRefresh := true ;
23016: LD_ADDR_EXP 69
23020: PUSH
23021: LD_INT 1
23023: ST_TO_ADDR
// if p3 = 12 then
23024: LD_VAR 0 3
23028: PUSH
23029: LD_INT 12
23031: EQUAL
23032: IFFALSE 23042
// sExp := true ;
23034: LD_ADDR_EXP 70
23038: PUSH
23039: LD_INT 1
23041: ST_TO_ADDR
// if p3 = 13 then
23042: LD_VAR 0 3
23046: PUSH
23047: LD_INT 13
23049: EQUAL
23050: IFFALSE 23060
// sDepot := true ;
23052: LD_ADDR_EXP 71
23056: PUSH
23057: LD_INT 1
23059: ST_TO_ADDR
// if p3 = 14 then
23060: LD_VAR 0 3
23064: PUSH
23065: LD_INT 14
23067: EQUAL
23068: IFFALSE 23078
// sFlag := true ;
23070: LD_ADDR_EXP 72
23074: PUSH
23075: LD_INT 1
23077: ST_TO_ADDR
// if p3 = 15 then
23078: LD_VAR 0 3
23082: PUSH
23083: LD_INT 15
23085: EQUAL
23086: IFFALSE 23096
// sKamikadze := true ;
23088: LD_ADDR_EXP 80
23092: PUSH
23093: LD_INT 1
23095: ST_TO_ADDR
// if p3 = 16 then
23096: LD_VAR 0 3
23100: PUSH
23101: LD_INT 16
23103: EQUAL
23104: IFFALSE 23114
// sTroll := true ;
23106: LD_ADDR_EXP 81
23110: PUSH
23111: LD_INT 1
23113: ST_TO_ADDR
// if p3 = 17 then
23114: LD_VAR 0 3
23118: PUSH
23119: LD_INT 17
23121: EQUAL
23122: IFFALSE 23132
// sSlow := true ;
23124: LD_ADDR_EXP 82
23128: PUSH
23129: LD_INT 1
23131: ST_TO_ADDR
// if p3 = 18 then
23132: LD_VAR 0 3
23136: PUSH
23137: LD_INT 18
23139: EQUAL
23140: IFFALSE 23150
// sLack := true ;
23142: LD_ADDR_EXP 83
23146: PUSH
23147: LD_INT 1
23149: ST_TO_ADDR
// if p3 = 19 then
23150: LD_VAR 0 3
23154: PUSH
23155: LD_INT 19
23157: EQUAL
23158: IFFALSE 23168
// sTank := true ;
23160: LD_ADDR_EXP 85
23164: PUSH
23165: LD_INT 1
23167: ST_TO_ADDR
// if p3 = 20 then
23168: LD_VAR 0 3
23172: PUSH
23173: LD_INT 20
23175: EQUAL
23176: IFFALSE 23186
// sRemote := true ;
23178: LD_ADDR_EXP 86
23182: PUSH
23183: LD_INT 1
23185: ST_TO_ADDR
// if p3 = 21 then
23186: LD_VAR 0 3
23190: PUSH
23191: LD_INT 21
23193: EQUAL
23194: IFFALSE 23204
// sPowell := true ;
23196: LD_ADDR_EXP 87
23200: PUSH
23201: LD_INT 1
23203: ST_TO_ADDR
// if p3 = 22 then
23204: LD_VAR 0 3
23208: PUSH
23209: LD_INT 22
23211: EQUAL
23212: IFFALSE 23222
// sTeleport := true ;
23214: LD_ADDR_EXP 90
23218: PUSH
23219: LD_INT 1
23221: ST_TO_ADDR
// if p3 = 23 then
23222: LD_VAR 0 3
23226: PUSH
23227: LD_INT 23
23229: EQUAL
23230: IFFALSE 23240
// sOilTower := true ;
23232: LD_ADDR_EXP 92
23236: PUSH
23237: LD_INT 1
23239: ST_TO_ADDR
// if p3 = 24 then
23240: LD_VAR 0 3
23244: PUSH
23245: LD_INT 24
23247: EQUAL
23248: IFFALSE 23258
// sShovel := true ;
23250: LD_ADDR_EXP 93
23254: PUSH
23255: LD_INT 1
23257: ST_TO_ADDR
// if p3 = 25 then
23258: LD_VAR 0 3
23262: PUSH
23263: LD_INT 25
23265: EQUAL
23266: IFFALSE 23276
// sSheik := true ;
23268: LD_ADDR_EXP 94
23272: PUSH
23273: LD_INT 1
23275: ST_TO_ADDR
// if p3 = 26 then
23276: LD_VAR 0 3
23280: PUSH
23281: LD_INT 26
23283: EQUAL
23284: IFFALSE 23294
// sEarthquake := true ;
23286: LD_ADDR_EXP 96
23290: PUSH
23291: LD_INT 1
23293: ST_TO_ADDR
// if p3 = 27 then
23294: LD_VAR 0 3
23298: PUSH
23299: LD_INT 27
23301: EQUAL
23302: IFFALSE 23312
// sAI := true ;
23304: LD_ADDR_EXP 97
23308: PUSH
23309: LD_INT 1
23311: ST_TO_ADDR
// if p3 = 28 then
23312: LD_VAR 0 3
23316: PUSH
23317: LD_INT 28
23319: EQUAL
23320: IFFALSE 23330
// sCargo := true ;
23322: LD_ADDR_EXP 100
23326: PUSH
23327: LD_INT 1
23329: ST_TO_ADDR
// if p3 = 29 then
23330: LD_VAR 0 3
23334: PUSH
23335: LD_INT 29
23337: EQUAL
23338: IFFALSE 23348
// sDLaser := true ;
23340: LD_ADDR_EXP 101
23344: PUSH
23345: LD_INT 1
23347: ST_TO_ADDR
// if p3 = 30 then
23348: LD_VAR 0 3
23352: PUSH
23353: LD_INT 30
23355: EQUAL
23356: IFFALSE 23366
// sExchange := true ;
23358: LD_ADDR_EXP 102
23362: PUSH
23363: LD_INT 1
23365: ST_TO_ADDR
// if p3 = 31 then
23366: LD_VAR 0 3
23370: PUSH
23371: LD_INT 31
23373: EQUAL
23374: IFFALSE 23384
// sFac := true ;
23376: LD_ADDR_EXP 103
23380: PUSH
23381: LD_INT 1
23383: ST_TO_ADDR
// if p3 = 32 then
23384: LD_VAR 0 3
23388: PUSH
23389: LD_INT 32
23391: EQUAL
23392: IFFALSE 23402
// sPower := true ;
23394: LD_ADDR_EXP 104
23398: PUSH
23399: LD_INT 1
23401: ST_TO_ADDR
// if p3 = 33 then
23402: LD_VAR 0 3
23406: PUSH
23407: LD_INT 33
23409: EQUAL
23410: IFFALSE 23420
// sRandom := true ;
23412: LD_ADDR_EXP 105
23416: PUSH
23417: LD_INT 1
23419: ST_TO_ADDR
// if p3 = 34 then
23420: LD_VAR 0 3
23424: PUSH
23425: LD_INT 34
23427: EQUAL
23428: IFFALSE 23438
// sShield := true ;
23430: LD_ADDR_EXP 106
23434: PUSH
23435: LD_INT 1
23437: ST_TO_ADDR
// if p3 = 35 then
23438: LD_VAR 0 3
23442: PUSH
23443: LD_INT 35
23445: EQUAL
23446: IFFALSE 23456
// sTime := true ;
23448: LD_ADDR_EXP 107
23452: PUSH
23453: LD_INT 1
23455: ST_TO_ADDR
// if p3 = 36 then
23456: LD_VAR 0 3
23460: PUSH
23461: LD_INT 36
23463: EQUAL
23464: IFFALSE 23474
// sTools := true ;
23466: LD_ADDR_EXP 108
23470: PUSH
23471: LD_INT 1
23473: ST_TO_ADDR
// if p3 = 101 then
23474: LD_VAR 0 3
23478: PUSH
23479: LD_INT 101
23481: EQUAL
23482: IFFALSE 23492
// sSold := true ;
23484: LD_ADDR_EXP 73
23488: PUSH
23489: LD_INT 1
23491: ST_TO_ADDR
// if p3 = 102 then
23492: LD_VAR 0 3
23496: PUSH
23497: LD_INT 102
23499: EQUAL
23500: IFFALSE 23510
// sDiff := true ;
23502: LD_ADDR_EXP 74
23506: PUSH
23507: LD_INT 1
23509: ST_TO_ADDR
// if p3 = 103 then
23510: LD_VAR 0 3
23514: PUSH
23515: LD_INT 103
23517: EQUAL
23518: IFFALSE 23528
// sFog := true ;
23520: LD_ADDR_EXP 77
23524: PUSH
23525: LD_INT 1
23527: ST_TO_ADDR
// if p3 = 104 then
23528: LD_VAR 0 3
23532: PUSH
23533: LD_INT 104
23535: EQUAL
23536: IFFALSE 23546
// sReset := true ;
23538: LD_ADDR_EXP 78
23542: PUSH
23543: LD_INT 1
23545: ST_TO_ADDR
// if p3 = 105 then
23546: LD_VAR 0 3
23550: PUSH
23551: LD_INT 105
23553: EQUAL
23554: IFFALSE 23564
// sSun := true ;
23556: LD_ADDR_EXP 79
23560: PUSH
23561: LD_INT 1
23563: ST_TO_ADDR
// if p3 = 106 then
23564: LD_VAR 0 3
23568: PUSH
23569: LD_INT 106
23571: EQUAL
23572: IFFALSE 23582
// sTiger := true ;
23574: LD_ADDR_EXP 75
23578: PUSH
23579: LD_INT 1
23581: ST_TO_ADDR
// if p3 = 107 then
23582: LD_VAR 0 3
23586: PUSH
23587: LD_INT 107
23589: EQUAL
23590: IFFALSE 23600
// sBomb := true ;
23592: LD_ADDR_EXP 76
23596: PUSH
23597: LD_INT 1
23599: ST_TO_ADDR
// if p3 = 108 then
23600: LD_VAR 0 3
23604: PUSH
23605: LD_INT 108
23607: EQUAL
23608: IFFALSE 23618
// sWound := true ;
23610: LD_ADDR_EXP 84
23614: PUSH
23615: LD_INT 1
23617: ST_TO_ADDR
// if p3 = 109 then
23618: LD_VAR 0 3
23622: PUSH
23623: LD_INT 109
23625: EQUAL
23626: IFFALSE 23636
// sBetray := true ;
23628: LD_ADDR_EXP 88
23632: PUSH
23633: LD_INT 1
23635: ST_TO_ADDR
// if p3 = 110 then
23636: LD_VAR 0 3
23640: PUSH
23641: LD_INT 110
23643: EQUAL
23644: IFFALSE 23654
// sContamin := true ;
23646: LD_ADDR_EXP 89
23650: PUSH
23651: LD_INT 1
23653: ST_TO_ADDR
// if p3 = 111 then
23654: LD_VAR 0 3
23658: PUSH
23659: LD_INT 111
23661: EQUAL
23662: IFFALSE 23672
// sOil := true ;
23664: LD_ADDR_EXP 91
23668: PUSH
23669: LD_INT 1
23671: ST_TO_ADDR
// if p3 = 112 then
23672: LD_VAR 0 3
23676: PUSH
23677: LD_INT 112
23679: EQUAL
23680: IFFALSE 23690
// sStu := true ;
23682: LD_ADDR_EXP 95
23686: PUSH
23687: LD_INT 1
23689: ST_TO_ADDR
// if p3 = 113 then
23690: LD_VAR 0 3
23694: PUSH
23695: LD_INT 113
23697: EQUAL
23698: IFFALSE 23708
// sBazooka := true ;
23700: LD_ADDR_EXP 98
23704: PUSH
23705: LD_INT 1
23707: ST_TO_ADDR
// if p3 = 114 then
23708: LD_VAR 0 3
23712: PUSH
23713: LD_INT 114
23715: EQUAL
23716: IFFALSE 23726
// sMortar := true ;
23718: LD_ADDR_EXP 99
23722: PUSH
23723: LD_INT 1
23725: ST_TO_ADDR
// if p3 = 115 then
23726: LD_VAR 0 3
23730: PUSH
23731: LD_INT 115
23733: EQUAL
23734: IFFALSE 23744
// sRanger := true ;
23736: LD_ADDR_EXP 109
23740: PUSH
23741: LD_INT 1
23743: ST_TO_ADDR
// end ; end ;
23744: PPOPN 6
23746: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23747: LD_EXP 56
23751: PUSH
23752: LD_EXP 61
23756: AND
23757: IFFALSE 23881
23759: GO 23761
23761: DISABLE
23762: LD_INT 0
23764: PPUSH
23765: PPUSH
// begin enable ;
23766: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23767: LD_ADDR_VAR 0 2
23771: PUSH
23772: LD_INT 22
23774: PUSH
23775: LD_OWVAR 2
23779: PUSH
23780: EMPTY
23781: LIST
23782: LIST
23783: PUSH
23784: LD_INT 2
23786: PUSH
23787: LD_INT 34
23789: PUSH
23790: LD_INT 7
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: LD_INT 34
23799: PUSH
23800: LD_INT 45
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: PUSH
23807: LD_INT 34
23809: PUSH
23810: LD_INT 28
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: LD_INT 34
23819: PUSH
23820: LD_INT 47
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: LIST
23831: LIST
23832: LIST
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: PPUSH
23838: CALL_OW 69
23842: ST_TO_ADDR
// if not tmp then
23843: LD_VAR 0 2
23847: NOT
23848: IFFALSE 23852
// exit ;
23850: GO 23881
// for i in tmp do
23852: LD_ADDR_VAR 0 1
23856: PUSH
23857: LD_VAR 0 2
23861: PUSH
23862: FOR_IN
23863: IFFALSE 23879
// begin SetLives ( i , 0 ) ;
23865: LD_VAR 0 1
23869: PPUSH
23870: LD_INT 0
23872: PPUSH
23873: CALL_OW 234
// end ;
23877: GO 23862
23879: POP
23880: POP
// end ;
23881: PPOPN 2
23883: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23884: LD_EXP 56
23888: PUSH
23889: LD_EXP 62
23893: AND
23894: IFFALSE 23978
23896: GO 23898
23898: DISABLE
23899: LD_INT 0
23901: PPUSH
23902: PPUSH
// begin enable ;
23903: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23904: LD_ADDR_VAR 0 2
23908: PUSH
23909: LD_INT 22
23911: PUSH
23912: LD_OWVAR 2
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: PUSH
23921: LD_INT 32
23923: PUSH
23924: LD_INT 3
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: PPUSH
23935: CALL_OW 69
23939: ST_TO_ADDR
// if not tmp then
23940: LD_VAR 0 2
23944: NOT
23945: IFFALSE 23949
// exit ;
23947: GO 23978
// for i in tmp do
23949: LD_ADDR_VAR 0 1
23953: PUSH
23954: LD_VAR 0 2
23958: PUSH
23959: FOR_IN
23960: IFFALSE 23976
// begin SetLives ( i , 0 ) ;
23962: LD_VAR 0 1
23966: PPUSH
23967: LD_INT 0
23969: PPUSH
23970: CALL_OW 234
// end ;
23974: GO 23959
23976: POP
23977: POP
// end ;
23978: PPOPN 2
23980: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23981: LD_EXP 56
23985: PUSH
23986: LD_EXP 59
23990: AND
23991: IFFALSE 24084
23993: GO 23995
23995: DISABLE
23996: LD_INT 0
23998: PPUSH
// begin enable ;
23999: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
24000: LD_ADDR_VAR 0 1
24004: PUSH
24005: LD_INT 22
24007: PUSH
24008: LD_OWVAR 2
24012: PUSH
24013: EMPTY
24014: LIST
24015: LIST
24016: PUSH
24017: LD_INT 2
24019: PUSH
24020: LD_INT 25
24022: PUSH
24023: LD_INT 5
24025: PUSH
24026: EMPTY
24027: LIST
24028: LIST
24029: PUSH
24030: LD_INT 25
24032: PUSH
24033: LD_INT 9
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PUSH
24040: LD_INT 25
24042: PUSH
24043: LD_INT 8
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: PUSH
24050: EMPTY
24051: LIST
24052: LIST
24053: LIST
24054: LIST
24055: PUSH
24056: EMPTY
24057: LIST
24058: LIST
24059: PPUSH
24060: CALL_OW 69
24064: PUSH
24065: FOR_IN
24066: IFFALSE 24082
// begin SetClass ( i , 1 ) ;
24068: LD_VAR 0 1
24072: PPUSH
24073: LD_INT 1
24075: PPUSH
24076: CALL_OW 336
// end ;
24080: GO 24065
24082: POP
24083: POP
// end ;
24084: PPOPN 1
24086: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
24087: LD_EXP 56
24091: PUSH
24092: LD_EXP 60
24096: AND
24097: PUSH
24098: LD_OWVAR 65
24102: PUSH
24103: LD_INT 7
24105: LESS
24106: AND
24107: IFFALSE 24121
24109: GO 24111
24111: DISABLE
// begin enable ;
24112: ENABLE
// game_speed := 7 ;
24113: LD_ADDR_OWVAR 65
24117: PUSH
24118: LD_INT 7
24120: ST_TO_ADDR
// end ;
24121: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
24122: LD_EXP 56
24126: PUSH
24127: LD_EXP 63
24131: AND
24132: IFFALSE 24334
24134: GO 24136
24136: DISABLE
24137: LD_INT 0
24139: PPUSH
24140: PPUSH
24141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
24142: LD_ADDR_VAR 0 3
24146: PUSH
24147: LD_INT 81
24149: PUSH
24150: LD_OWVAR 2
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: PUSH
24159: LD_INT 21
24161: PUSH
24162: LD_INT 1
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: PPUSH
24173: CALL_OW 69
24177: ST_TO_ADDR
// if not tmp then
24178: LD_VAR 0 3
24182: NOT
24183: IFFALSE 24187
// exit ;
24185: GO 24334
// if tmp > 5 then
24187: LD_VAR 0 3
24191: PUSH
24192: LD_INT 5
24194: GREATER
24195: IFFALSE 24207
// k := 5 else
24197: LD_ADDR_VAR 0 2
24201: PUSH
24202: LD_INT 5
24204: ST_TO_ADDR
24205: GO 24217
// k := tmp ;
24207: LD_ADDR_VAR 0 2
24211: PUSH
24212: LD_VAR 0 3
24216: ST_TO_ADDR
// for i := 1 to k do
24217: LD_ADDR_VAR 0 1
24221: PUSH
24222: DOUBLE
24223: LD_INT 1
24225: DEC
24226: ST_TO_ADDR
24227: LD_VAR 0 2
24231: PUSH
24232: FOR_TO
24233: IFFALSE 24332
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
24235: LD_VAR 0 3
24239: PUSH
24240: LD_VAR 0 1
24244: ARRAY
24245: PPUSH
24246: LD_VAR 0 1
24250: PUSH
24251: LD_INT 4
24253: MOD
24254: PUSH
24255: LD_INT 1
24257: PLUS
24258: PPUSH
24259: CALL_OW 259
24263: PUSH
24264: LD_INT 10
24266: LESS
24267: IFFALSE 24330
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
24269: LD_VAR 0 3
24273: PUSH
24274: LD_VAR 0 1
24278: ARRAY
24279: PPUSH
24280: LD_VAR 0 1
24284: PUSH
24285: LD_INT 4
24287: MOD
24288: PUSH
24289: LD_INT 1
24291: PLUS
24292: PPUSH
24293: LD_VAR 0 3
24297: PUSH
24298: LD_VAR 0 1
24302: ARRAY
24303: PPUSH
24304: LD_VAR 0 1
24308: PUSH
24309: LD_INT 4
24311: MOD
24312: PUSH
24313: LD_INT 1
24315: PLUS
24316: PPUSH
24317: CALL_OW 259
24321: PUSH
24322: LD_INT 1
24324: PLUS
24325: PPUSH
24326: CALL_OW 237
24330: GO 24232
24332: POP
24333: POP
// end ;
24334: PPOPN 3
24336: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
24337: LD_EXP 56
24341: PUSH
24342: LD_EXP 64
24346: AND
24347: IFFALSE 24367
24349: GO 24351
24351: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
24352: LD_INT 4
24354: PPUSH
24355: LD_OWVAR 2
24359: PPUSH
24360: LD_INT 0
24362: PPUSH
24363: CALL_OW 324
24367: END
// every 0 0$1 trigger StreamModeActive and sShovel do
24368: LD_EXP 56
24372: PUSH
24373: LD_EXP 93
24377: AND
24378: IFFALSE 24398
24380: GO 24382
24382: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
24383: LD_INT 19
24385: PPUSH
24386: LD_OWVAR 2
24390: PPUSH
24391: LD_INT 0
24393: PPUSH
24394: CALL_OW 324
24398: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24399: LD_EXP 56
24403: PUSH
24404: LD_EXP 65
24408: AND
24409: IFFALSE 24511
24411: GO 24413
24413: DISABLE
24414: LD_INT 0
24416: PPUSH
24417: PPUSH
// begin enable ;
24418: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24419: LD_ADDR_VAR 0 2
24423: PUSH
24424: LD_INT 22
24426: PUSH
24427: LD_OWVAR 2
24431: PUSH
24432: EMPTY
24433: LIST
24434: LIST
24435: PUSH
24436: LD_INT 2
24438: PUSH
24439: LD_INT 34
24441: PUSH
24442: LD_INT 11
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: PUSH
24449: LD_INT 34
24451: PUSH
24452: LD_INT 30
24454: PUSH
24455: EMPTY
24456: LIST
24457: LIST
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: LIST
24463: PUSH
24464: EMPTY
24465: LIST
24466: LIST
24467: PPUSH
24468: CALL_OW 69
24472: ST_TO_ADDR
// if not tmp then
24473: LD_VAR 0 2
24477: NOT
24478: IFFALSE 24482
// exit ;
24480: GO 24511
// for i in tmp do
24482: LD_ADDR_VAR 0 1
24486: PUSH
24487: LD_VAR 0 2
24491: PUSH
24492: FOR_IN
24493: IFFALSE 24509
// begin SetLives ( i , 0 ) ;
24495: LD_VAR 0 1
24499: PPUSH
24500: LD_INT 0
24502: PPUSH
24503: CALL_OW 234
// end ;
24507: GO 24492
24509: POP
24510: POP
// end ;
24511: PPOPN 2
24513: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24514: LD_EXP 56
24518: PUSH
24519: LD_EXP 66
24523: AND
24524: IFFALSE 24544
24526: GO 24528
24528: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24529: LD_INT 32
24531: PPUSH
24532: LD_OWVAR 2
24536: PPUSH
24537: LD_INT 0
24539: PPUSH
24540: CALL_OW 324
24544: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24545: LD_EXP 56
24549: PUSH
24550: LD_EXP 67
24554: AND
24555: IFFALSE 24736
24557: GO 24559
24559: DISABLE
24560: LD_INT 0
24562: PPUSH
24563: PPUSH
24564: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24565: LD_ADDR_VAR 0 2
24569: PUSH
24570: LD_INT 22
24572: PUSH
24573: LD_OWVAR 2
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: PUSH
24582: LD_INT 33
24584: PUSH
24585: LD_INT 3
24587: PUSH
24588: EMPTY
24589: LIST
24590: LIST
24591: PUSH
24592: EMPTY
24593: LIST
24594: LIST
24595: PPUSH
24596: CALL_OW 69
24600: ST_TO_ADDR
// if not tmp then
24601: LD_VAR 0 2
24605: NOT
24606: IFFALSE 24610
// exit ;
24608: GO 24736
// side := 0 ;
24610: LD_ADDR_VAR 0 3
24614: PUSH
24615: LD_INT 0
24617: ST_TO_ADDR
// for i := 1 to 8 do
24618: LD_ADDR_VAR 0 1
24622: PUSH
24623: DOUBLE
24624: LD_INT 1
24626: DEC
24627: ST_TO_ADDR
24628: LD_INT 8
24630: PUSH
24631: FOR_TO
24632: IFFALSE 24680
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24634: LD_OWVAR 2
24638: PUSH
24639: LD_VAR 0 1
24643: NONEQUAL
24644: PUSH
24645: LD_OWVAR 2
24649: PPUSH
24650: LD_VAR 0 1
24654: PPUSH
24655: CALL_OW 81
24659: PUSH
24660: LD_INT 2
24662: EQUAL
24663: AND
24664: IFFALSE 24678
// begin side := i ;
24666: LD_ADDR_VAR 0 3
24670: PUSH
24671: LD_VAR 0 1
24675: ST_TO_ADDR
// break ;
24676: GO 24680
// end ;
24678: GO 24631
24680: POP
24681: POP
// if not side then
24682: LD_VAR 0 3
24686: NOT
24687: IFFALSE 24691
// exit ;
24689: GO 24736
// for i := 1 to tmp do
24691: LD_ADDR_VAR 0 1
24695: PUSH
24696: DOUBLE
24697: LD_INT 1
24699: DEC
24700: ST_TO_ADDR
24701: LD_VAR 0 2
24705: PUSH
24706: FOR_TO
24707: IFFALSE 24734
// if Prob ( 60 ) then
24709: LD_INT 60
24711: PPUSH
24712: CALL_OW 13
24716: IFFALSE 24732
// SetSide ( i , side ) ;
24718: LD_VAR 0 1
24722: PPUSH
24723: LD_VAR 0 3
24727: PPUSH
24728: CALL_OW 235
24732: GO 24706
24734: POP
24735: POP
// end ;
24736: PPOPN 3
24738: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24739: LD_EXP 56
24743: PUSH
24744: LD_EXP 69
24748: AND
24749: IFFALSE 24868
24751: GO 24753
24753: DISABLE
24754: LD_INT 0
24756: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24757: LD_ADDR_VAR 0 1
24761: PUSH
24762: LD_INT 22
24764: PUSH
24765: LD_OWVAR 2
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 21
24776: PUSH
24777: LD_INT 1
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: LD_INT 3
24786: PUSH
24787: LD_INT 23
24789: PUSH
24790: LD_INT 0
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: EMPTY
24798: LIST
24799: LIST
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: LIST
24805: PPUSH
24806: CALL_OW 69
24810: PUSH
24811: FOR_IN
24812: IFFALSE 24866
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24814: LD_VAR 0 1
24818: PPUSH
24819: CALL_OW 257
24823: PUSH
24824: LD_INT 1
24826: PUSH
24827: LD_INT 2
24829: PUSH
24830: LD_INT 3
24832: PUSH
24833: LD_INT 4
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: LIST
24840: LIST
24841: IN
24842: IFFALSE 24864
// SetClass ( un , rand ( 1 , 4 ) ) ;
24844: LD_VAR 0 1
24848: PPUSH
24849: LD_INT 1
24851: PPUSH
24852: LD_INT 4
24854: PPUSH
24855: CALL_OW 12
24859: PPUSH
24860: CALL_OW 336
24864: GO 24811
24866: POP
24867: POP
// end ;
24868: PPOPN 1
24870: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24871: LD_EXP 56
24875: PUSH
24876: LD_EXP 68
24880: AND
24881: IFFALSE 24960
24883: GO 24885
24885: DISABLE
24886: LD_INT 0
24888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24889: LD_ADDR_VAR 0 1
24893: PUSH
24894: LD_INT 22
24896: PUSH
24897: LD_OWVAR 2
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PUSH
24906: LD_INT 21
24908: PUSH
24909: LD_INT 3
24911: PUSH
24912: EMPTY
24913: LIST
24914: LIST
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 69
24924: ST_TO_ADDR
// if not tmp then
24925: LD_VAR 0 1
24929: NOT
24930: IFFALSE 24934
// exit ;
24932: GO 24960
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24934: LD_VAR 0 1
24938: PUSH
24939: LD_INT 1
24941: PPUSH
24942: LD_VAR 0 1
24946: PPUSH
24947: CALL_OW 12
24951: ARRAY
24952: PPUSH
24953: LD_INT 100
24955: PPUSH
24956: CALL_OW 234
// end ;
24960: PPOPN 1
24962: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24963: LD_EXP 56
24967: PUSH
24968: LD_EXP 70
24972: AND
24973: IFFALSE 25071
24975: GO 24977
24977: DISABLE
24978: LD_INT 0
24980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24981: LD_ADDR_VAR 0 1
24985: PUSH
24986: LD_INT 22
24988: PUSH
24989: LD_OWVAR 2
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PUSH
24998: LD_INT 21
25000: PUSH
25001: LD_INT 1
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: PUSH
25008: EMPTY
25009: LIST
25010: LIST
25011: PPUSH
25012: CALL_OW 69
25016: ST_TO_ADDR
// if not tmp then
25017: LD_VAR 0 1
25021: NOT
25022: IFFALSE 25026
// exit ;
25024: GO 25071
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
25026: LD_VAR 0 1
25030: PUSH
25031: LD_INT 1
25033: PPUSH
25034: LD_VAR 0 1
25038: PPUSH
25039: CALL_OW 12
25043: ARRAY
25044: PPUSH
25045: LD_INT 1
25047: PPUSH
25048: LD_INT 4
25050: PPUSH
25051: CALL_OW 12
25055: PPUSH
25056: LD_INT 3000
25058: PPUSH
25059: LD_INT 9000
25061: PPUSH
25062: CALL_OW 12
25066: PPUSH
25067: CALL_OW 492
// end ;
25071: PPOPN 1
25073: END
// every 0 0$1 trigger StreamModeActive and sDepot do
25074: LD_EXP 56
25078: PUSH
25079: LD_EXP 71
25083: AND
25084: IFFALSE 25104
25086: GO 25088
25088: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
25089: LD_INT 1
25091: PPUSH
25092: LD_OWVAR 2
25096: PPUSH
25097: LD_INT 0
25099: PPUSH
25100: CALL_OW 324
25104: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
25105: LD_EXP 56
25109: PUSH
25110: LD_EXP 72
25114: AND
25115: IFFALSE 25198
25117: GO 25119
25119: DISABLE
25120: LD_INT 0
25122: PPUSH
25123: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
25124: LD_ADDR_VAR 0 2
25128: PUSH
25129: LD_INT 22
25131: PUSH
25132: LD_OWVAR 2
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PUSH
25141: LD_INT 21
25143: PUSH
25144: LD_INT 3
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PPUSH
25155: CALL_OW 69
25159: ST_TO_ADDR
// if not tmp then
25160: LD_VAR 0 2
25164: NOT
25165: IFFALSE 25169
// exit ;
25167: GO 25198
// for i in tmp do
25169: LD_ADDR_VAR 0 1
25173: PUSH
25174: LD_VAR 0 2
25178: PUSH
25179: FOR_IN
25180: IFFALSE 25196
// SetBLevel ( i , 10 ) ;
25182: LD_VAR 0 1
25186: PPUSH
25187: LD_INT 10
25189: PPUSH
25190: CALL_OW 241
25194: GO 25179
25196: POP
25197: POP
// end ;
25198: PPOPN 2
25200: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
25201: LD_EXP 56
25205: PUSH
25206: LD_EXP 73
25210: AND
25211: IFFALSE 25322
25213: GO 25215
25215: DISABLE
25216: LD_INT 0
25218: PPUSH
25219: PPUSH
25220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25221: LD_ADDR_VAR 0 3
25225: PUSH
25226: LD_INT 22
25228: PUSH
25229: LD_OWVAR 2
25233: PUSH
25234: EMPTY
25235: LIST
25236: LIST
25237: PUSH
25238: LD_INT 25
25240: PUSH
25241: LD_INT 1
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PPUSH
25252: CALL_OW 69
25256: ST_TO_ADDR
// if not tmp then
25257: LD_VAR 0 3
25261: NOT
25262: IFFALSE 25266
// exit ;
25264: GO 25322
// un := tmp [ rand ( 1 , tmp ) ] ;
25266: LD_ADDR_VAR 0 2
25270: PUSH
25271: LD_VAR 0 3
25275: PUSH
25276: LD_INT 1
25278: PPUSH
25279: LD_VAR 0 3
25283: PPUSH
25284: CALL_OW 12
25288: ARRAY
25289: ST_TO_ADDR
// if Crawls ( un ) then
25290: LD_VAR 0 2
25294: PPUSH
25295: CALL_OW 318
25299: IFFALSE 25310
// ComWalk ( un ) ;
25301: LD_VAR 0 2
25305: PPUSH
25306: CALL_OW 138
// SetClass ( un , class_sniper ) ;
25310: LD_VAR 0 2
25314: PPUSH
25315: LD_INT 5
25317: PPUSH
25318: CALL_OW 336
// end ;
25322: PPOPN 3
25324: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
25325: LD_EXP 56
25329: PUSH
25330: LD_EXP 74
25334: AND
25335: PUSH
25336: LD_OWVAR 67
25340: PUSH
25341: LD_INT 3
25343: LESS
25344: AND
25345: IFFALSE 25364
25347: GO 25349
25349: DISABLE
// Difficulty := Difficulty + 1 ;
25350: LD_ADDR_OWVAR 67
25354: PUSH
25355: LD_OWVAR 67
25359: PUSH
25360: LD_INT 1
25362: PLUS
25363: ST_TO_ADDR
25364: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
25365: LD_EXP 56
25369: PUSH
25370: LD_EXP 75
25374: AND
25375: IFFALSE 25478
25377: GO 25379
25379: DISABLE
25380: LD_INT 0
25382: PPUSH
// begin for i := 1 to 5 do
25383: LD_ADDR_VAR 0 1
25387: PUSH
25388: DOUBLE
25389: LD_INT 1
25391: DEC
25392: ST_TO_ADDR
25393: LD_INT 5
25395: PUSH
25396: FOR_TO
25397: IFFALSE 25476
// begin uc_nation := nation_nature ;
25399: LD_ADDR_OWVAR 21
25403: PUSH
25404: LD_INT 0
25406: ST_TO_ADDR
// uc_side := 0 ;
25407: LD_ADDR_OWVAR 20
25411: PUSH
25412: LD_INT 0
25414: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25415: LD_ADDR_OWVAR 29
25419: PUSH
25420: LD_INT 12
25422: PUSH
25423: LD_INT 12
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: ST_TO_ADDR
// hc_agressivity := 20 ;
25430: LD_ADDR_OWVAR 35
25434: PUSH
25435: LD_INT 20
25437: ST_TO_ADDR
// hc_class := class_tiger ;
25438: LD_ADDR_OWVAR 28
25442: PUSH
25443: LD_INT 14
25445: ST_TO_ADDR
// hc_gallery :=  ;
25446: LD_ADDR_OWVAR 33
25450: PUSH
25451: LD_STRING 
25453: ST_TO_ADDR
// hc_name :=  ;
25454: LD_ADDR_OWVAR 26
25458: PUSH
25459: LD_STRING 
25461: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25462: CALL_OW 44
25466: PPUSH
25467: LD_INT 0
25469: PPUSH
25470: CALL_OW 51
// end ;
25474: GO 25396
25476: POP
25477: POP
// end ;
25478: PPOPN 1
25480: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25481: LD_EXP 56
25485: PUSH
25486: LD_EXP 76
25490: AND
25491: IFFALSE 25500
25493: GO 25495
25495: DISABLE
// StreamSibBomb ;
25496: CALL 25501 0 0
25500: END
// export function StreamSibBomb ; var i , x , y ; begin
25501: LD_INT 0
25503: PPUSH
25504: PPUSH
25505: PPUSH
25506: PPUSH
// result := false ;
25507: LD_ADDR_VAR 0 1
25511: PUSH
25512: LD_INT 0
25514: ST_TO_ADDR
// for i := 1 to 16 do
25515: LD_ADDR_VAR 0 2
25519: PUSH
25520: DOUBLE
25521: LD_INT 1
25523: DEC
25524: ST_TO_ADDR
25525: LD_INT 16
25527: PUSH
25528: FOR_TO
25529: IFFALSE 25728
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25531: LD_ADDR_VAR 0 3
25535: PUSH
25536: LD_INT 10
25538: PUSH
25539: LD_INT 20
25541: PUSH
25542: LD_INT 30
25544: PUSH
25545: LD_INT 40
25547: PUSH
25548: LD_INT 50
25550: PUSH
25551: LD_INT 60
25553: PUSH
25554: LD_INT 70
25556: PUSH
25557: LD_INT 80
25559: PUSH
25560: LD_INT 90
25562: PUSH
25563: LD_INT 100
25565: PUSH
25566: LD_INT 110
25568: PUSH
25569: LD_INT 120
25571: PUSH
25572: LD_INT 130
25574: PUSH
25575: LD_INT 140
25577: PUSH
25578: LD_INT 150
25580: PUSH
25581: EMPTY
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: PUSH
25598: LD_INT 1
25600: PPUSH
25601: LD_INT 15
25603: PPUSH
25604: CALL_OW 12
25608: ARRAY
25609: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25610: LD_ADDR_VAR 0 4
25614: PUSH
25615: LD_INT 10
25617: PUSH
25618: LD_INT 20
25620: PUSH
25621: LD_INT 30
25623: PUSH
25624: LD_INT 40
25626: PUSH
25627: LD_INT 50
25629: PUSH
25630: LD_INT 60
25632: PUSH
25633: LD_INT 70
25635: PUSH
25636: LD_INT 80
25638: PUSH
25639: LD_INT 90
25641: PUSH
25642: LD_INT 100
25644: PUSH
25645: LD_INT 110
25647: PUSH
25648: LD_INT 120
25650: PUSH
25651: LD_INT 130
25653: PUSH
25654: LD_INT 140
25656: PUSH
25657: LD_INT 150
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: LIST
25674: LIST
25675: LIST
25676: PUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 15
25682: PPUSH
25683: CALL_OW 12
25687: ARRAY
25688: ST_TO_ADDR
// if ValidHex ( x , y ) then
25689: LD_VAR 0 3
25693: PPUSH
25694: LD_VAR 0 4
25698: PPUSH
25699: CALL_OW 488
25703: IFFALSE 25726
// begin result := [ x , y ] ;
25705: LD_ADDR_VAR 0 1
25709: PUSH
25710: LD_VAR 0 3
25714: PUSH
25715: LD_VAR 0 4
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: ST_TO_ADDR
// break ;
25724: GO 25728
// end ; end ;
25726: GO 25528
25728: POP
25729: POP
// if result then
25730: LD_VAR 0 1
25734: IFFALSE 25794
// begin ToLua ( playSibBomb() ) ;
25736: LD_STRING playSibBomb()
25738: PPUSH
25739: CALL_OW 559
// wait ( 0 0$14 ) ;
25743: LD_INT 490
25745: PPUSH
25746: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25750: LD_VAR 0 1
25754: PUSH
25755: LD_INT 1
25757: ARRAY
25758: PPUSH
25759: LD_VAR 0 1
25763: PUSH
25764: LD_INT 2
25766: ARRAY
25767: PPUSH
25768: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25772: LD_VAR 0 1
25776: PUSH
25777: LD_INT 1
25779: ARRAY
25780: PPUSH
25781: LD_VAR 0 1
25785: PUSH
25786: LD_INT 2
25788: ARRAY
25789: PPUSH
25790: CALL_OW 429
// end ; end ;
25794: LD_VAR 0 1
25798: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25799: LD_EXP 56
25803: PUSH
25804: LD_EXP 78
25808: AND
25809: IFFALSE 25821
25811: GO 25813
25813: DISABLE
// YouLost (  ) ;
25814: LD_STRING 
25816: PPUSH
25817: CALL_OW 104
25821: END
// every 0 0$1 trigger StreamModeActive and sFog do
25822: LD_EXP 56
25826: PUSH
25827: LD_EXP 77
25831: AND
25832: IFFALSE 25846
25834: GO 25836
25836: DISABLE
// FogOff ( your_side ) ;
25837: LD_OWVAR 2
25841: PPUSH
25842: CALL_OW 344
25846: END
// every 0 0$1 trigger StreamModeActive and sSun do
25847: LD_EXP 56
25851: PUSH
25852: LD_EXP 79
25856: AND
25857: IFFALSE 25885
25859: GO 25861
25861: DISABLE
// begin solar_recharge_percent := 0 ;
25862: LD_ADDR_OWVAR 79
25866: PUSH
25867: LD_INT 0
25869: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25870: LD_INT 10500
25872: PPUSH
25873: CALL_OW 67
// solar_recharge_percent := 100 ;
25877: LD_ADDR_OWVAR 79
25881: PUSH
25882: LD_INT 100
25884: ST_TO_ADDR
// end ;
25885: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25886: LD_EXP 56
25890: PUSH
25891: LD_EXP 80
25895: AND
25896: IFFALSE 26135
25898: GO 25900
25900: DISABLE
25901: LD_INT 0
25903: PPUSH
25904: PPUSH
25905: PPUSH
// begin tmp := [ ] ;
25906: LD_ADDR_VAR 0 3
25910: PUSH
25911: EMPTY
25912: ST_TO_ADDR
// for i := 1 to 6 do
25913: LD_ADDR_VAR 0 1
25917: PUSH
25918: DOUBLE
25919: LD_INT 1
25921: DEC
25922: ST_TO_ADDR
25923: LD_INT 6
25925: PUSH
25926: FOR_TO
25927: IFFALSE 26032
// begin uc_nation := nation_nature ;
25929: LD_ADDR_OWVAR 21
25933: PUSH
25934: LD_INT 0
25936: ST_TO_ADDR
// uc_side := 0 ;
25937: LD_ADDR_OWVAR 20
25941: PUSH
25942: LD_INT 0
25944: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25945: LD_ADDR_OWVAR 29
25949: PUSH
25950: LD_INT 12
25952: PUSH
25953: LD_INT 12
25955: PUSH
25956: EMPTY
25957: LIST
25958: LIST
25959: ST_TO_ADDR
// hc_agressivity := 20 ;
25960: LD_ADDR_OWVAR 35
25964: PUSH
25965: LD_INT 20
25967: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25968: LD_ADDR_OWVAR 28
25972: PUSH
25973: LD_INT 17
25975: ST_TO_ADDR
// hc_gallery :=  ;
25976: LD_ADDR_OWVAR 33
25980: PUSH
25981: LD_STRING 
25983: ST_TO_ADDR
// hc_name :=  ;
25984: LD_ADDR_OWVAR 26
25988: PUSH
25989: LD_STRING 
25991: ST_TO_ADDR
// un := CreateHuman ;
25992: LD_ADDR_VAR 0 2
25996: PUSH
25997: CALL_OW 44
26001: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
26002: LD_VAR 0 2
26006: PPUSH
26007: LD_INT 1
26009: PPUSH
26010: CALL_OW 51
// tmp := tmp ^ un ;
26014: LD_ADDR_VAR 0 3
26018: PUSH
26019: LD_VAR 0 3
26023: PUSH
26024: LD_VAR 0 2
26028: ADD
26029: ST_TO_ADDR
// end ;
26030: GO 25926
26032: POP
26033: POP
// repeat wait ( 0 0$1 ) ;
26034: LD_INT 35
26036: PPUSH
26037: CALL_OW 67
// for un in tmp do
26041: LD_ADDR_VAR 0 2
26045: PUSH
26046: LD_VAR 0 3
26050: PUSH
26051: FOR_IN
26052: IFFALSE 26126
// begin if IsDead ( un ) then
26054: LD_VAR 0 2
26058: PPUSH
26059: CALL_OW 301
26063: IFFALSE 26083
// begin tmp := tmp diff un ;
26065: LD_ADDR_VAR 0 3
26069: PUSH
26070: LD_VAR 0 3
26074: PUSH
26075: LD_VAR 0 2
26079: DIFF
26080: ST_TO_ADDR
// continue ;
26081: GO 26051
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
26083: LD_VAR 0 2
26087: PPUSH
26088: LD_INT 3
26090: PUSH
26091: LD_INT 22
26093: PUSH
26094: LD_INT 0
26096: PUSH
26097: EMPTY
26098: LIST
26099: LIST
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PPUSH
26105: CALL_OW 69
26109: PPUSH
26110: LD_VAR 0 2
26114: PPUSH
26115: CALL_OW 74
26119: PPUSH
26120: CALL_OW 115
// end ;
26124: GO 26051
26126: POP
26127: POP
// until not tmp ;
26128: LD_VAR 0 3
26132: NOT
26133: IFFALSE 26034
// end ;
26135: PPOPN 3
26137: END
// every 0 0$1 trigger StreamModeActive and sTroll do
26138: LD_EXP 56
26142: PUSH
26143: LD_EXP 81
26147: AND
26148: IFFALSE 26202
26150: GO 26152
26152: DISABLE
// begin ToLua ( displayTroll(); ) ;
26153: LD_STRING displayTroll();
26155: PPUSH
26156: CALL_OW 559
// wait ( 3 3$00 ) ;
26160: LD_INT 6300
26162: PPUSH
26163: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26167: LD_STRING hideTroll();
26169: PPUSH
26170: CALL_OW 559
// wait ( 1 1$00 ) ;
26174: LD_INT 2100
26176: PPUSH
26177: CALL_OW 67
// ToLua ( displayTroll(); ) ;
26181: LD_STRING displayTroll();
26183: PPUSH
26184: CALL_OW 559
// wait ( 1 1$00 ) ;
26188: LD_INT 2100
26190: PPUSH
26191: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26195: LD_STRING hideTroll();
26197: PPUSH
26198: CALL_OW 559
// end ;
26202: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
26203: LD_EXP 56
26207: PUSH
26208: LD_EXP 82
26212: AND
26213: IFFALSE 26276
26215: GO 26217
26217: DISABLE
26218: LD_INT 0
26220: PPUSH
// begin p := 0 ;
26221: LD_ADDR_VAR 0 1
26225: PUSH
26226: LD_INT 0
26228: ST_TO_ADDR
// repeat game_speed := 1 ;
26229: LD_ADDR_OWVAR 65
26233: PUSH
26234: LD_INT 1
26236: ST_TO_ADDR
// wait ( 0 0$1 ) ;
26237: LD_INT 35
26239: PPUSH
26240: CALL_OW 67
// p := p + 1 ;
26244: LD_ADDR_VAR 0 1
26248: PUSH
26249: LD_VAR 0 1
26253: PUSH
26254: LD_INT 1
26256: PLUS
26257: ST_TO_ADDR
// until p >= 60 ;
26258: LD_VAR 0 1
26262: PUSH
26263: LD_INT 60
26265: GREATEREQUAL
26266: IFFALSE 26229
// game_speed := 4 ;
26268: LD_ADDR_OWVAR 65
26272: PUSH
26273: LD_INT 4
26275: ST_TO_ADDR
// end ;
26276: PPOPN 1
26278: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
26279: LD_EXP 56
26283: PUSH
26284: LD_EXP 83
26288: AND
26289: IFFALSE 26435
26291: GO 26293
26293: DISABLE
26294: LD_INT 0
26296: PPUSH
26297: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26298: LD_ADDR_VAR 0 1
26302: PUSH
26303: LD_INT 22
26305: PUSH
26306: LD_OWVAR 2
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PUSH
26315: LD_INT 2
26317: PUSH
26318: LD_INT 30
26320: PUSH
26321: LD_INT 0
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: LD_INT 30
26330: PUSH
26331: LD_INT 1
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: LIST
26342: PUSH
26343: EMPTY
26344: LIST
26345: LIST
26346: PPUSH
26347: CALL_OW 69
26351: ST_TO_ADDR
// if not depot then
26352: LD_VAR 0 1
26356: NOT
26357: IFFALSE 26361
// exit ;
26359: GO 26435
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
26361: LD_ADDR_VAR 0 2
26365: PUSH
26366: LD_VAR 0 1
26370: PUSH
26371: LD_INT 1
26373: PPUSH
26374: LD_VAR 0 1
26378: PPUSH
26379: CALL_OW 12
26383: ARRAY
26384: PPUSH
26385: CALL_OW 274
26389: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
26390: LD_VAR 0 2
26394: PPUSH
26395: LD_INT 1
26397: PPUSH
26398: LD_INT 0
26400: PPUSH
26401: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26405: LD_VAR 0 2
26409: PPUSH
26410: LD_INT 2
26412: PPUSH
26413: LD_INT 0
26415: PPUSH
26416: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26420: LD_VAR 0 2
26424: PPUSH
26425: LD_INT 3
26427: PPUSH
26428: LD_INT 0
26430: PPUSH
26431: CALL_OW 277
// end ;
26435: PPOPN 2
26437: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26438: LD_EXP 56
26442: PUSH
26443: LD_EXP 84
26447: AND
26448: IFFALSE 26545
26450: GO 26452
26452: DISABLE
26453: LD_INT 0
26455: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26456: LD_ADDR_VAR 0 1
26460: PUSH
26461: LD_INT 22
26463: PUSH
26464: LD_OWVAR 2
26468: PUSH
26469: EMPTY
26470: LIST
26471: LIST
26472: PUSH
26473: LD_INT 21
26475: PUSH
26476: LD_INT 1
26478: PUSH
26479: EMPTY
26480: LIST
26481: LIST
26482: PUSH
26483: LD_INT 3
26485: PUSH
26486: LD_INT 23
26488: PUSH
26489: LD_INT 0
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: EMPTY
26497: LIST
26498: LIST
26499: PUSH
26500: EMPTY
26501: LIST
26502: LIST
26503: LIST
26504: PPUSH
26505: CALL_OW 69
26509: ST_TO_ADDR
// if not tmp then
26510: LD_VAR 0 1
26514: NOT
26515: IFFALSE 26519
// exit ;
26517: GO 26545
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26519: LD_VAR 0 1
26523: PUSH
26524: LD_INT 1
26526: PPUSH
26527: LD_VAR 0 1
26531: PPUSH
26532: CALL_OW 12
26536: ARRAY
26537: PPUSH
26538: LD_INT 200
26540: PPUSH
26541: CALL_OW 234
// end ;
26545: PPOPN 1
26547: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26548: LD_EXP 56
26552: PUSH
26553: LD_EXP 85
26557: AND
26558: IFFALSE 26637
26560: GO 26562
26562: DISABLE
26563: LD_INT 0
26565: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26566: LD_ADDR_VAR 0 1
26570: PUSH
26571: LD_INT 22
26573: PUSH
26574: LD_OWVAR 2
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: LD_INT 21
26585: PUSH
26586: LD_INT 2
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: PPUSH
26597: CALL_OW 69
26601: ST_TO_ADDR
// if not tmp then
26602: LD_VAR 0 1
26606: NOT
26607: IFFALSE 26611
// exit ;
26609: GO 26637
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26611: LD_VAR 0 1
26615: PUSH
26616: LD_INT 1
26618: PPUSH
26619: LD_VAR 0 1
26623: PPUSH
26624: CALL_OW 12
26628: ARRAY
26629: PPUSH
26630: LD_INT 60
26632: PPUSH
26633: CALL_OW 234
// end ;
26637: PPOPN 1
26639: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26640: LD_EXP 56
26644: PUSH
26645: LD_EXP 86
26649: AND
26650: IFFALSE 26749
26652: GO 26654
26654: DISABLE
26655: LD_INT 0
26657: PPUSH
26658: PPUSH
// begin enable ;
26659: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26660: LD_ADDR_VAR 0 1
26664: PUSH
26665: LD_INT 22
26667: PUSH
26668: LD_OWVAR 2
26672: PUSH
26673: EMPTY
26674: LIST
26675: LIST
26676: PUSH
26677: LD_INT 61
26679: PUSH
26680: EMPTY
26681: LIST
26682: PUSH
26683: LD_INT 33
26685: PUSH
26686: LD_INT 2
26688: PUSH
26689: EMPTY
26690: LIST
26691: LIST
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: LIST
26697: PPUSH
26698: CALL_OW 69
26702: ST_TO_ADDR
// if not tmp then
26703: LD_VAR 0 1
26707: NOT
26708: IFFALSE 26712
// exit ;
26710: GO 26749
// for i in tmp do
26712: LD_ADDR_VAR 0 2
26716: PUSH
26717: LD_VAR 0 1
26721: PUSH
26722: FOR_IN
26723: IFFALSE 26747
// if IsControledBy ( i ) then
26725: LD_VAR 0 2
26729: PPUSH
26730: CALL_OW 312
26734: IFFALSE 26745
// ComUnlink ( i ) ;
26736: LD_VAR 0 2
26740: PPUSH
26741: CALL_OW 136
26745: GO 26722
26747: POP
26748: POP
// end ;
26749: PPOPN 2
26751: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26752: LD_EXP 56
26756: PUSH
26757: LD_EXP 87
26761: AND
26762: IFFALSE 26902
26764: GO 26766
26766: DISABLE
26767: LD_INT 0
26769: PPUSH
26770: PPUSH
// begin ToLua ( displayPowell(); ) ;
26771: LD_STRING displayPowell();
26773: PPUSH
26774: CALL_OW 559
// uc_side := 0 ;
26778: LD_ADDR_OWVAR 20
26782: PUSH
26783: LD_INT 0
26785: ST_TO_ADDR
// uc_nation := 2 ;
26786: LD_ADDR_OWVAR 21
26790: PUSH
26791: LD_INT 2
26793: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26794: LD_ADDR_OWVAR 37
26798: PUSH
26799: LD_INT 14
26801: ST_TO_ADDR
// vc_engine := engine_siberite ;
26802: LD_ADDR_OWVAR 39
26806: PUSH
26807: LD_INT 3
26809: ST_TO_ADDR
// vc_control := control_apeman ;
26810: LD_ADDR_OWVAR 38
26814: PUSH
26815: LD_INT 5
26817: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26818: LD_ADDR_OWVAR 40
26822: PUSH
26823: LD_INT 29
26825: ST_TO_ADDR
// un := CreateVehicle ;
26826: LD_ADDR_VAR 0 2
26830: PUSH
26831: CALL_OW 45
26835: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26836: LD_VAR 0 2
26840: PPUSH
26841: LD_INT 1
26843: PPUSH
26844: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26848: LD_INT 35
26850: PPUSH
26851: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26855: LD_VAR 0 2
26859: PPUSH
26860: LD_INT 22
26862: PUSH
26863: LD_OWVAR 2
26867: PUSH
26868: EMPTY
26869: LIST
26870: LIST
26871: PPUSH
26872: CALL_OW 69
26876: PPUSH
26877: LD_VAR 0 2
26881: PPUSH
26882: CALL_OW 74
26886: PPUSH
26887: CALL_OW 115
// until IsDead ( un ) ;
26891: LD_VAR 0 2
26895: PPUSH
26896: CALL_OW 301
26900: IFFALSE 26848
// end ;
26902: PPOPN 2
26904: END
// every 0 0$1 trigger StreamModeActive and sStu do
26905: LD_EXP 56
26909: PUSH
26910: LD_EXP 95
26914: AND
26915: IFFALSE 26931
26917: GO 26919
26919: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26920: LD_STRING displayStucuk();
26922: PPUSH
26923: CALL_OW 559
// ResetFog ;
26927: CALL_OW 335
// end ;
26931: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26932: LD_EXP 56
26936: PUSH
26937: LD_EXP 88
26941: AND
26942: IFFALSE 27083
26944: GO 26946
26946: DISABLE
26947: LD_INT 0
26949: PPUSH
26950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26951: LD_ADDR_VAR 0 2
26955: PUSH
26956: LD_INT 22
26958: PUSH
26959: LD_OWVAR 2
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: PUSH
26968: LD_INT 21
26970: PUSH
26971: LD_INT 1
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PPUSH
26982: CALL_OW 69
26986: ST_TO_ADDR
// if not tmp then
26987: LD_VAR 0 2
26991: NOT
26992: IFFALSE 26996
// exit ;
26994: GO 27083
// un := tmp [ rand ( 1 , tmp ) ] ;
26996: LD_ADDR_VAR 0 1
27000: PUSH
27001: LD_VAR 0 2
27005: PUSH
27006: LD_INT 1
27008: PPUSH
27009: LD_VAR 0 2
27013: PPUSH
27014: CALL_OW 12
27018: ARRAY
27019: ST_TO_ADDR
// SetSide ( un , 0 ) ;
27020: LD_VAR 0 1
27024: PPUSH
27025: LD_INT 0
27027: PPUSH
27028: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
27032: LD_VAR 0 1
27036: PPUSH
27037: LD_OWVAR 3
27041: PUSH
27042: LD_VAR 0 1
27046: DIFF
27047: PPUSH
27048: LD_VAR 0 1
27052: PPUSH
27053: CALL_OW 74
27057: PPUSH
27058: CALL_OW 115
// wait ( 0 0$20 ) ;
27062: LD_INT 700
27064: PPUSH
27065: CALL_OW 67
// SetSide ( un , your_side ) ;
27069: LD_VAR 0 1
27073: PPUSH
27074: LD_OWVAR 2
27078: PPUSH
27079: CALL_OW 235
// end ;
27083: PPOPN 2
27085: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
27086: LD_EXP 56
27090: PUSH
27091: LD_EXP 89
27095: AND
27096: IFFALSE 27202
27098: GO 27100
27100: DISABLE
27101: LD_INT 0
27103: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27104: LD_ADDR_VAR 0 1
27108: PUSH
27109: LD_INT 22
27111: PUSH
27112: LD_OWVAR 2
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: PUSH
27121: LD_INT 2
27123: PUSH
27124: LD_INT 30
27126: PUSH
27127: LD_INT 0
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: LD_INT 30
27136: PUSH
27137: LD_INT 1
27139: PUSH
27140: EMPTY
27141: LIST
27142: LIST
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: LIST
27148: PUSH
27149: EMPTY
27150: LIST
27151: LIST
27152: PPUSH
27153: CALL_OW 69
27157: ST_TO_ADDR
// if not depot then
27158: LD_VAR 0 1
27162: NOT
27163: IFFALSE 27167
// exit ;
27165: GO 27202
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
27167: LD_VAR 0 1
27171: PUSH
27172: LD_INT 1
27174: ARRAY
27175: PPUSH
27176: CALL_OW 250
27180: PPUSH
27181: LD_VAR 0 1
27185: PUSH
27186: LD_INT 1
27188: ARRAY
27189: PPUSH
27190: CALL_OW 251
27194: PPUSH
27195: LD_INT 70
27197: PPUSH
27198: CALL_OW 495
// end ;
27202: PPOPN 1
27204: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
27205: LD_EXP 56
27209: PUSH
27210: LD_EXP 90
27214: AND
27215: IFFALSE 27426
27217: GO 27219
27219: DISABLE
27220: LD_INT 0
27222: PPUSH
27223: PPUSH
27224: PPUSH
27225: PPUSH
27226: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27227: LD_ADDR_VAR 0 5
27231: PUSH
27232: LD_INT 22
27234: PUSH
27235: LD_OWVAR 2
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PUSH
27244: LD_INT 21
27246: PUSH
27247: LD_INT 1
27249: PUSH
27250: EMPTY
27251: LIST
27252: LIST
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PPUSH
27258: CALL_OW 69
27262: ST_TO_ADDR
// if not tmp then
27263: LD_VAR 0 5
27267: NOT
27268: IFFALSE 27272
// exit ;
27270: GO 27426
// for i in tmp do
27272: LD_ADDR_VAR 0 1
27276: PUSH
27277: LD_VAR 0 5
27281: PUSH
27282: FOR_IN
27283: IFFALSE 27424
// begin d := rand ( 0 , 5 ) ;
27285: LD_ADDR_VAR 0 4
27289: PUSH
27290: LD_INT 0
27292: PPUSH
27293: LD_INT 5
27295: PPUSH
27296: CALL_OW 12
27300: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
27301: LD_ADDR_VAR 0 2
27305: PUSH
27306: LD_VAR 0 1
27310: PPUSH
27311: CALL_OW 250
27315: PPUSH
27316: LD_VAR 0 4
27320: PPUSH
27321: LD_INT 3
27323: PPUSH
27324: LD_INT 12
27326: PPUSH
27327: CALL_OW 12
27331: PPUSH
27332: CALL_OW 272
27336: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
27337: LD_ADDR_VAR 0 3
27341: PUSH
27342: LD_VAR 0 1
27346: PPUSH
27347: CALL_OW 251
27351: PPUSH
27352: LD_VAR 0 4
27356: PPUSH
27357: LD_INT 3
27359: PPUSH
27360: LD_INT 12
27362: PPUSH
27363: CALL_OW 12
27367: PPUSH
27368: CALL_OW 273
27372: ST_TO_ADDR
// if ValidHex ( x , y ) then
27373: LD_VAR 0 2
27377: PPUSH
27378: LD_VAR 0 3
27382: PPUSH
27383: CALL_OW 488
27387: IFFALSE 27422
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
27389: LD_VAR 0 1
27393: PPUSH
27394: LD_VAR 0 2
27398: PPUSH
27399: LD_VAR 0 3
27403: PPUSH
27404: LD_INT 3
27406: PPUSH
27407: LD_INT 6
27409: PPUSH
27410: CALL_OW 12
27414: PPUSH
27415: LD_INT 1
27417: PPUSH
27418: CALL_OW 483
// end ;
27422: GO 27282
27424: POP
27425: POP
// end ;
27426: PPOPN 5
27428: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27429: LD_EXP 56
27433: PUSH
27434: LD_EXP 91
27438: AND
27439: IFFALSE 27533
27441: GO 27443
27443: DISABLE
27444: LD_INT 0
27446: PPUSH
27447: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27448: LD_ADDR_VAR 0 2
27452: PUSH
27453: LD_INT 22
27455: PUSH
27456: LD_OWVAR 2
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: LD_INT 32
27467: PUSH
27468: LD_INT 1
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 21
27477: PUSH
27478: LD_INT 2
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: LIST
27489: PPUSH
27490: CALL_OW 69
27494: ST_TO_ADDR
// if not tmp then
27495: LD_VAR 0 2
27499: NOT
27500: IFFALSE 27504
// exit ;
27502: GO 27533
// for i in tmp do
27504: LD_ADDR_VAR 0 1
27508: PUSH
27509: LD_VAR 0 2
27513: PUSH
27514: FOR_IN
27515: IFFALSE 27531
// SetFuel ( i , 0 ) ;
27517: LD_VAR 0 1
27521: PPUSH
27522: LD_INT 0
27524: PPUSH
27525: CALL_OW 240
27529: GO 27514
27531: POP
27532: POP
// end ;
27533: PPOPN 2
27535: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27536: LD_EXP 56
27540: PUSH
27541: LD_EXP 92
27545: AND
27546: IFFALSE 27612
27548: GO 27550
27550: DISABLE
27551: LD_INT 0
27553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27554: LD_ADDR_VAR 0 1
27558: PUSH
27559: LD_INT 22
27561: PUSH
27562: LD_OWVAR 2
27566: PUSH
27567: EMPTY
27568: LIST
27569: LIST
27570: PUSH
27571: LD_INT 30
27573: PUSH
27574: LD_INT 29
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: PUSH
27581: EMPTY
27582: LIST
27583: LIST
27584: PPUSH
27585: CALL_OW 69
27589: ST_TO_ADDR
// if not tmp then
27590: LD_VAR 0 1
27594: NOT
27595: IFFALSE 27599
// exit ;
27597: GO 27612
// DestroyUnit ( tmp [ 1 ] ) ;
27599: LD_VAR 0 1
27603: PUSH
27604: LD_INT 1
27606: ARRAY
27607: PPUSH
27608: CALL_OW 65
// end ;
27612: PPOPN 1
27614: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27615: LD_EXP 56
27619: PUSH
27620: LD_EXP 94
27624: AND
27625: IFFALSE 27754
27627: GO 27629
27629: DISABLE
27630: LD_INT 0
27632: PPUSH
// begin uc_side := 0 ;
27633: LD_ADDR_OWVAR 20
27637: PUSH
27638: LD_INT 0
27640: ST_TO_ADDR
// uc_nation := nation_arabian ;
27641: LD_ADDR_OWVAR 21
27645: PUSH
27646: LD_INT 2
27648: ST_TO_ADDR
// hc_gallery :=  ;
27649: LD_ADDR_OWVAR 33
27653: PUSH
27654: LD_STRING 
27656: ST_TO_ADDR
// hc_name :=  ;
27657: LD_ADDR_OWVAR 26
27661: PUSH
27662: LD_STRING 
27664: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27665: LD_INT 1
27667: PPUSH
27668: LD_INT 11
27670: PPUSH
27671: LD_INT 10
27673: PPUSH
27674: CALL_OW 380
// un := CreateHuman ;
27678: LD_ADDR_VAR 0 1
27682: PUSH
27683: CALL_OW 44
27687: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27688: LD_VAR 0 1
27692: PPUSH
27693: LD_INT 1
27695: PPUSH
27696: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27700: LD_INT 35
27702: PPUSH
27703: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27707: LD_VAR 0 1
27711: PPUSH
27712: LD_INT 22
27714: PUSH
27715: LD_OWVAR 2
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PPUSH
27724: CALL_OW 69
27728: PPUSH
27729: LD_VAR 0 1
27733: PPUSH
27734: CALL_OW 74
27738: PPUSH
27739: CALL_OW 115
// until IsDead ( un ) ;
27743: LD_VAR 0 1
27747: PPUSH
27748: CALL_OW 301
27752: IFFALSE 27700
// end ;
27754: PPOPN 1
27756: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27757: LD_EXP 56
27761: PUSH
27762: LD_EXP 96
27766: AND
27767: IFFALSE 27779
27769: GO 27771
27771: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27772: LD_STRING earthquake(getX(game), 0, 32)
27774: PPUSH
27775: CALL_OW 559
27779: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27780: LD_EXP 56
27784: PUSH
27785: LD_EXP 97
27789: AND
27790: IFFALSE 27881
27792: GO 27794
27794: DISABLE
27795: LD_INT 0
27797: PPUSH
// begin enable ;
27798: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27799: LD_ADDR_VAR 0 1
27803: PUSH
27804: LD_INT 22
27806: PUSH
27807: LD_OWVAR 2
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: PUSH
27816: LD_INT 21
27818: PUSH
27819: LD_INT 2
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 33
27828: PUSH
27829: LD_INT 3
27831: PUSH
27832: EMPTY
27833: LIST
27834: LIST
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: LIST
27840: PPUSH
27841: CALL_OW 69
27845: ST_TO_ADDR
// if not tmp then
27846: LD_VAR 0 1
27850: NOT
27851: IFFALSE 27855
// exit ;
27853: GO 27881
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27855: LD_VAR 0 1
27859: PUSH
27860: LD_INT 1
27862: PPUSH
27863: LD_VAR 0 1
27867: PPUSH
27868: CALL_OW 12
27872: ARRAY
27873: PPUSH
27874: LD_INT 1
27876: PPUSH
27877: CALL_OW 234
// end ;
27881: PPOPN 1
27883: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27884: LD_EXP 56
27888: PUSH
27889: LD_EXP 98
27893: AND
27894: IFFALSE 28035
27896: GO 27898
27898: DISABLE
27899: LD_INT 0
27901: PPUSH
27902: PPUSH
27903: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27904: LD_ADDR_VAR 0 3
27908: PUSH
27909: LD_INT 22
27911: PUSH
27912: LD_OWVAR 2
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: LD_INT 25
27923: PUSH
27924: LD_INT 1
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PPUSH
27935: CALL_OW 69
27939: ST_TO_ADDR
// if not tmp then
27940: LD_VAR 0 3
27944: NOT
27945: IFFALSE 27949
// exit ;
27947: GO 28035
// un := tmp [ rand ( 1 , tmp ) ] ;
27949: LD_ADDR_VAR 0 2
27953: PUSH
27954: LD_VAR 0 3
27958: PUSH
27959: LD_INT 1
27961: PPUSH
27962: LD_VAR 0 3
27966: PPUSH
27967: CALL_OW 12
27971: ARRAY
27972: ST_TO_ADDR
// if Crawls ( un ) then
27973: LD_VAR 0 2
27977: PPUSH
27978: CALL_OW 318
27982: IFFALSE 27993
// ComWalk ( un ) ;
27984: LD_VAR 0 2
27988: PPUSH
27989: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27993: LD_VAR 0 2
27997: PPUSH
27998: LD_INT 9
28000: PPUSH
28001: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
28005: LD_INT 28
28007: PPUSH
28008: LD_OWVAR 2
28012: PPUSH
28013: LD_INT 2
28015: PPUSH
28016: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
28020: LD_INT 29
28022: PPUSH
28023: LD_OWVAR 2
28027: PPUSH
28028: LD_INT 2
28030: PPUSH
28031: CALL_OW 322
// end ;
28035: PPOPN 3
28037: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
28038: LD_EXP 56
28042: PUSH
28043: LD_EXP 99
28047: AND
28048: IFFALSE 28159
28050: GO 28052
28052: DISABLE
28053: LD_INT 0
28055: PPUSH
28056: PPUSH
28057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28058: LD_ADDR_VAR 0 3
28062: PUSH
28063: LD_INT 22
28065: PUSH
28066: LD_OWVAR 2
28070: PUSH
28071: EMPTY
28072: LIST
28073: LIST
28074: PUSH
28075: LD_INT 25
28077: PUSH
28078: LD_INT 1
28080: PUSH
28081: EMPTY
28082: LIST
28083: LIST
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PPUSH
28089: CALL_OW 69
28093: ST_TO_ADDR
// if not tmp then
28094: LD_VAR 0 3
28098: NOT
28099: IFFALSE 28103
// exit ;
28101: GO 28159
// un := tmp [ rand ( 1 , tmp ) ] ;
28103: LD_ADDR_VAR 0 2
28107: PUSH
28108: LD_VAR 0 3
28112: PUSH
28113: LD_INT 1
28115: PPUSH
28116: LD_VAR 0 3
28120: PPUSH
28121: CALL_OW 12
28125: ARRAY
28126: ST_TO_ADDR
// if Crawls ( un ) then
28127: LD_VAR 0 2
28131: PPUSH
28132: CALL_OW 318
28136: IFFALSE 28147
// ComWalk ( un ) ;
28138: LD_VAR 0 2
28142: PPUSH
28143: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28147: LD_VAR 0 2
28151: PPUSH
28152: LD_INT 8
28154: PPUSH
28155: CALL_OW 336
// end ;
28159: PPOPN 3
28161: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
28162: LD_EXP 56
28166: PUSH
28167: LD_EXP 100
28171: AND
28172: IFFALSE 28316
28174: GO 28176
28176: DISABLE
28177: LD_INT 0
28179: PPUSH
28180: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
28181: LD_ADDR_VAR 0 2
28185: PUSH
28186: LD_INT 22
28188: PUSH
28189: LD_OWVAR 2
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 21
28200: PUSH
28201: LD_INT 2
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 2
28210: PUSH
28211: LD_INT 34
28213: PUSH
28214: LD_INT 12
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: LD_INT 34
28223: PUSH
28224: LD_INT 51
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 34
28233: PUSH
28234: LD_INT 32
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: LIST
28251: PPUSH
28252: CALL_OW 69
28256: ST_TO_ADDR
// if not tmp then
28257: LD_VAR 0 2
28261: NOT
28262: IFFALSE 28266
// exit ;
28264: GO 28316
// for i in tmp do
28266: LD_ADDR_VAR 0 1
28270: PUSH
28271: LD_VAR 0 2
28275: PUSH
28276: FOR_IN
28277: IFFALSE 28314
// if GetCargo ( i , mat_artifact ) = 0 then
28279: LD_VAR 0 1
28283: PPUSH
28284: LD_INT 4
28286: PPUSH
28287: CALL_OW 289
28291: PUSH
28292: LD_INT 0
28294: EQUAL
28295: IFFALSE 28312
// SetCargo ( i , mat_siberit , 100 ) ;
28297: LD_VAR 0 1
28301: PPUSH
28302: LD_INT 3
28304: PPUSH
28305: LD_INT 100
28307: PPUSH
28308: CALL_OW 290
28312: GO 28276
28314: POP
28315: POP
// end ;
28316: PPOPN 2
28318: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
28319: LD_EXP 56
28323: PUSH
28324: LD_EXP 101
28328: AND
28329: IFFALSE 28512
28331: GO 28333
28333: DISABLE
28334: LD_INT 0
28336: PPUSH
28337: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
28338: LD_ADDR_VAR 0 2
28342: PUSH
28343: LD_INT 22
28345: PUSH
28346: LD_OWVAR 2
28350: PUSH
28351: EMPTY
28352: LIST
28353: LIST
28354: PPUSH
28355: CALL_OW 69
28359: ST_TO_ADDR
// if not tmp then
28360: LD_VAR 0 2
28364: NOT
28365: IFFALSE 28369
// exit ;
28367: GO 28512
// for i := 1 to 2 do
28369: LD_ADDR_VAR 0 1
28373: PUSH
28374: DOUBLE
28375: LD_INT 1
28377: DEC
28378: ST_TO_ADDR
28379: LD_INT 2
28381: PUSH
28382: FOR_TO
28383: IFFALSE 28510
// begin uc_side := your_side ;
28385: LD_ADDR_OWVAR 20
28389: PUSH
28390: LD_OWVAR 2
28394: ST_TO_ADDR
// uc_nation := nation_american ;
28395: LD_ADDR_OWVAR 21
28399: PUSH
28400: LD_INT 1
28402: ST_TO_ADDR
// vc_chassis := us_morphling ;
28403: LD_ADDR_OWVAR 37
28407: PUSH
28408: LD_INT 5
28410: ST_TO_ADDR
// vc_engine := engine_siberite ;
28411: LD_ADDR_OWVAR 39
28415: PUSH
28416: LD_INT 3
28418: ST_TO_ADDR
// vc_control := control_computer ;
28419: LD_ADDR_OWVAR 38
28423: PUSH
28424: LD_INT 3
28426: ST_TO_ADDR
// vc_weapon := us_double_laser ;
28427: LD_ADDR_OWVAR 40
28431: PUSH
28432: LD_INT 10
28434: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
28435: LD_VAR 0 2
28439: PUSH
28440: LD_INT 1
28442: ARRAY
28443: PPUSH
28444: CALL_OW 310
28448: NOT
28449: IFFALSE 28496
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
28451: CALL_OW 45
28455: PPUSH
28456: LD_VAR 0 2
28460: PUSH
28461: LD_INT 1
28463: ARRAY
28464: PPUSH
28465: CALL_OW 250
28469: PPUSH
28470: LD_VAR 0 2
28474: PUSH
28475: LD_INT 1
28477: ARRAY
28478: PPUSH
28479: CALL_OW 251
28483: PPUSH
28484: LD_INT 12
28486: PPUSH
28487: LD_INT 1
28489: PPUSH
28490: CALL_OW 50
28494: GO 28508
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
28496: CALL_OW 45
28500: PPUSH
28501: LD_INT 1
28503: PPUSH
28504: CALL_OW 51
// end ;
28508: GO 28382
28510: POP
28511: POP
// end ;
28512: PPOPN 2
28514: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28515: LD_EXP 56
28519: PUSH
28520: LD_EXP 102
28524: AND
28525: IFFALSE 28747
28527: GO 28529
28529: DISABLE
28530: LD_INT 0
28532: PPUSH
28533: PPUSH
28534: PPUSH
28535: PPUSH
28536: PPUSH
28537: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28538: LD_ADDR_VAR 0 6
28542: PUSH
28543: LD_INT 22
28545: PUSH
28546: LD_OWVAR 2
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 21
28557: PUSH
28558: LD_INT 1
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 3
28567: PUSH
28568: LD_INT 23
28570: PUSH
28571: LD_INT 0
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: LIST
28586: PPUSH
28587: CALL_OW 69
28591: ST_TO_ADDR
// if not tmp then
28592: LD_VAR 0 6
28596: NOT
28597: IFFALSE 28601
// exit ;
28599: GO 28747
// s1 := rand ( 1 , 4 ) ;
28601: LD_ADDR_VAR 0 2
28605: PUSH
28606: LD_INT 1
28608: PPUSH
28609: LD_INT 4
28611: PPUSH
28612: CALL_OW 12
28616: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28617: LD_ADDR_VAR 0 4
28621: PUSH
28622: LD_VAR 0 6
28626: PUSH
28627: LD_INT 1
28629: ARRAY
28630: PPUSH
28631: LD_VAR 0 2
28635: PPUSH
28636: CALL_OW 259
28640: ST_TO_ADDR
// if s1 = 1 then
28641: LD_VAR 0 2
28645: PUSH
28646: LD_INT 1
28648: EQUAL
28649: IFFALSE 28669
// s2 := rand ( 2 , 4 ) else
28651: LD_ADDR_VAR 0 3
28655: PUSH
28656: LD_INT 2
28658: PPUSH
28659: LD_INT 4
28661: PPUSH
28662: CALL_OW 12
28666: ST_TO_ADDR
28667: GO 28677
// s2 := 1 ;
28669: LD_ADDR_VAR 0 3
28673: PUSH
28674: LD_INT 1
28676: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28677: LD_ADDR_VAR 0 5
28681: PUSH
28682: LD_VAR 0 6
28686: PUSH
28687: LD_INT 1
28689: ARRAY
28690: PPUSH
28691: LD_VAR 0 3
28695: PPUSH
28696: CALL_OW 259
28700: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28701: LD_VAR 0 6
28705: PUSH
28706: LD_INT 1
28708: ARRAY
28709: PPUSH
28710: LD_VAR 0 2
28714: PPUSH
28715: LD_VAR 0 5
28719: PPUSH
28720: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28724: LD_VAR 0 6
28728: PUSH
28729: LD_INT 1
28731: ARRAY
28732: PPUSH
28733: LD_VAR 0 3
28737: PPUSH
28738: LD_VAR 0 4
28742: PPUSH
28743: CALL_OW 237
// end ;
28747: PPOPN 6
28749: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28750: LD_EXP 56
28754: PUSH
28755: LD_EXP 103
28759: AND
28760: IFFALSE 28839
28762: GO 28764
28764: DISABLE
28765: LD_INT 0
28767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28768: LD_ADDR_VAR 0 1
28772: PUSH
28773: LD_INT 22
28775: PUSH
28776: LD_OWVAR 2
28780: PUSH
28781: EMPTY
28782: LIST
28783: LIST
28784: PUSH
28785: LD_INT 30
28787: PUSH
28788: LD_INT 3
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PPUSH
28799: CALL_OW 69
28803: ST_TO_ADDR
// if not tmp then
28804: LD_VAR 0 1
28808: NOT
28809: IFFALSE 28813
// exit ;
28811: GO 28839
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28813: LD_VAR 0 1
28817: PUSH
28818: LD_INT 1
28820: PPUSH
28821: LD_VAR 0 1
28825: PPUSH
28826: CALL_OW 12
28830: ARRAY
28831: PPUSH
28832: LD_INT 1
28834: PPUSH
28835: CALL_OW 234
// end ;
28839: PPOPN 1
28841: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28842: LD_EXP 56
28846: PUSH
28847: LD_EXP 104
28851: AND
28852: IFFALSE 28964
28854: GO 28856
28856: DISABLE
28857: LD_INT 0
28859: PPUSH
28860: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28861: LD_ADDR_VAR 0 2
28865: PUSH
28866: LD_INT 22
28868: PUSH
28869: LD_OWVAR 2
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 2
28880: PUSH
28881: LD_INT 30
28883: PUSH
28884: LD_INT 27
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 30
28893: PUSH
28894: LD_INT 26
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 30
28903: PUSH
28904: LD_INT 28
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PPUSH
28921: CALL_OW 69
28925: ST_TO_ADDR
// if not tmp then
28926: LD_VAR 0 2
28930: NOT
28931: IFFALSE 28935
// exit ;
28933: GO 28964
// for i in tmp do
28935: LD_ADDR_VAR 0 1
28939: PUSH
28940: LD_VAR 0 2
28944: PUSH
28945: FOR_IN
28946: IFFALSE 28962
// SetLives ( i , 1 ) ;
28948: LD_VAR 0 1
28952: PPUSH
28953: LD_INT 1
28955: PPUSH
28956: CALL_OW 234
28960: GO 28945
28962: POP
28963: POP
// end ;
28964: PPOPN 2
28966: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28967: LD_EXP 56
28971: PUSH
28972: LD_EXP 105
28976: AND
28977: IFFALSE 29251
28979: GO 28981
28981: DISABLE
28982: LD_INT 0
28984: PPUSH
28985: PPUSH
28986: PPUSH
// begin i := rand ( 1 , 7 ) ;
28987: LD_ADDR_VAR 0 1
28991: PUSH
28992: LD_INT 1
28994: PPUSH
28995: LD_INT 7
28997: PPUSH
28998: CALL_OW 12
29002: ST_TO_ADDR
// case i of 1 :
29003: LD_VAR 0 1
29007: PUSH
29008: LD_INT 1
29010: DOUBLE
29011: EQUAL
29012: IFTRUE 29016
29014: GO 29026
29016: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
29017: LD_STRING earthquake(getX(game), 0, 32)
29019: PPUSH
29020: CALL_OW 559
29024: GO 29251
29026: LD_INT 2
29028: DOUBLE
29029: EQUAL
29030: IFTRUE 29034
29032: GO 29048
29034: POP
// begin ToLua ( displayStucuk(); ) ;
29035: LD_STRING displayStucuk();
29037: PPUSH
29038: CALL_OW 559
// ResetFog ;
29042: CALL_OW 335
// end ; 3 :
29046: GO 29251
29048: LD_INT 3
29050: DOUBLE
29051: EQUAL
29052: IFTRUE 29056
29054: GO 29160
29056: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29057: LD_ADDR_VAR 0 2
29061: PUSH
29062: LD_INT 22
29064: PUSH
29065: LD_OWVAR 2
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 25
29076: PUSH
29077: LD_INT 1
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PPUSH
29088: CALL_OW 69
29092: ST_TO_ADDR
// if not tmp then
29093: LD_VAR 0 2
29097: NOT
29098: IFFALSE 29102
// exit ;
29100: GO 29251
// un := tmp [ rand ( 1 , tmp ) ] ;
29102: LD_ADDR_VAR 0 3
29106: PUSH
29107: LD_VAR 0 2
29111: PUSH
29112: LD_INT 1
29114: PPUSH
29115: LD_VAR 0 2
29119: PPUSH
29120: CALL_OW 12
29124: ARRAY
29125: ST_TO_ADDR
// if Crawls ( un ) then
29126: LD_VAR 0 3
29130: PPUSH
29131: CALL_OW 318
29135: IFFALSE 29146
// ComWalk ( un ) ;
29137: LD_VAR 0 3
29141: PPUSH
29142: CALL_OW 138
// SetClass ( un , class_mortar ) ;
29146: LD_VAR 0 3
29150: PPUSH
29151: LD_INT 8
29153: PPUSH
29154: CALL_OW 336
// end ; 4 :
29158: GO 29251
29160: LD_INT 4
29162: DOUBLE
29163: EQUAL
29164: IFTRUE 29168
29166: GO 29229
29168: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
29169: LD_ADDR_VAR 0 2
29173: PUSH
29174: LD_INT 22
29176: PUSH
29177: LD_OWVAR 2
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: LD_INT 30
29188: PUSH
29189: LD_INT 29
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PPUSH
29200: CALL_OW 69
29204: ST_TO_ADDR
// if not tmp then
29205: LD_VAR 0 2
29209: NOT
29210: IFFALSE 29214
// exit ;
29212: GO 29251
// DestroyUnit ( tmp [ 1 ] ) ;
29214: LD_VAR 0 2
29218: PUSH
29219: LD_INT 1
29221: ARRAY
29222: PPUSH
29223: CALL_OW 65
// end ; 5 .. 7 :
29227: GO 29251
29229: LD_INT 5
29231: DOUBLE
29232: GREATEREQUAL
29233: IFFALSE 29241
29235: LD_INT 7
29237: DOUBLE
29238: LESSEQUAL
29239: IFTRUE 29243
29241: GO 29250
29243: POP
// StreamSibBomb ; end ;
29244: CALL 25501 0 0
29248: GO 29251
29250: POP
// end ;
29251: PPOPN 3
29253: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
29254: LD_EXP 56
29258: PUSH
29259: LD_EXP 106
29263: AND
29264: IFFALSE 29420
29266: GO 29268
29268: DISABLE
29269: LD_INT 0
29271: PPUSH
29272: PPUSH
29273: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
29274: LD_ADDR_VAR 0 2
29278: PUSH
29279: LD_INT 81
29281: PUSH
29282: LD_OWVAR 2
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 2
29293: PUSH
29294: LD_INT 21
29296: PUSH
29297: LD_INT 1
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 21
29306: PUSH
29307: LD_INT 2
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: LIST
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PPUSH
29323: CALL_OW 69
29327: ST_TO_ADDR
// if not tmp then
29328: LD_VAR 0 2
29332: NOT
29333: IFFALSE 29337
// exit ;
29335: GO 29420
// p := 0 ;
29337: LD_ADDR_VAR 0 3
29341: PUSH
29342: LD_INT 0
29344: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29345: LD_INT 35
29347: PPUSH
29348: CALL_OW 67
// p := p + 1 ;
29352: LD_ADDR_VAR 0 3
29356: PUSH
29357: LD_VAR 0 3
29361: PUSH
29362: LD_INT 1
29364: PLUS
29365: ST_TO_ADDR
// for i in tmp do
29366: LD_ADDR_VAR 0 1
29370: PUSH
29371: LD_VAR 0 2
29375: PUSH
29376: FOR_IN
29377: IFFALSE 29408
// if GetLives ( i ) < 1000 then
29379: LD_VAR 0 1
29383: PPUSH
29384: CALL_OW 256
29388: PUSH
29389: LD_INT 1000
29391: LESS
29392: IFFALSE 29406
// SetLives ( i , 1000 ) ;
29394: LD_VAR 0 1
29398: PPUSH
29399: LD_INT 1000
29401: PPUSH
29402: CALL_OW 234
29406: GO 29376
29408: POP
29409: POP
// until p > 20 ;
29410: LD_VAR 0 3
29414: PUSH
29415: LD_INT 20
29417: GREATER
29418: IFFALSE 29345
// end ;
29420: PPOPN 3
29422: END
// every 0 0$1 trigger StreamModeActive and sTime do
29423: LD_EXP 56
29427: PUSH
29428: LD_EXP 107
29432: AND
29433: IFFALSE 29468
29435: GO 29437
29437: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
29438: LD_INT 28
29440: PPUSH
29441: LD_OWVAR 2
29445: PPUSH
29446: LD_INT 2
29448: PPUSH
29449: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
29453: LD_INT 30
29455: PPUSH
29456: LD_OWVAR 2
29460: PPUSH
29461: LD_INT 2
29463: PPUSH
29464: CALL_OW 322
// end ;
29468: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
29469: LD_EXP 56
29473: PUSH
29474: LD_EXP 108
29478: AND
29479: IFFALSE 29600
29481: GO 29483
29483: DISABLE
29484: LD_INT 0
29486: PPUSH
29487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29488: LD_ADDR_VAR 0 2
29492: PUSH
29493: LD_INT 22
29495: PUSH
29496: LD_OWVAR 2
29500: PUSH
29501: EMPTY
29502: LIST
29503: LIST
29504: PUSH
29505: LD_INT 21
29507: PUSH
29508: LD_INT 1
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 3
29517: PUSH
29518: LD_INT 23
29520: PUSH
29521: LD_INT 0
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: EMPTY
29533: LIST
29534: LIST
29535: LIST
29536: PPUSH
29537: CALL_OW 69
29541: ST_TO_ADDR
// if not tmp then
29542: LD_VAR 0 2
29546: NOT
29547: IFFALSE 29551
// exit ;
29549: GO 29600
// for i in tmp do
29551: LD_ADDR_VAR 0 1
29555: PUSH
29556: LD_VAR 0 2
29560: PUSH
29561: FOR_IN
29562: IFFALSE 29598
// begin if Crawls ( i ) then
29564: LD_VAR 0 1
29568: PPUSH
29569: CALL_OW 318
29573: IFFALSE 29584
// ComWalk ( i ) ;
29575: LD_VAR 0 1
29579: PPUSH
29580: CALL_OW 138
// SetClass ( i , 2 ) ;
29584: LD_VAR 0 1
29588: PPUSH
29589: LD_INT 2
29591: PPUSH
29592: CALL_OW 336
// end ;
29596: GO 29561
29598: POP
29599: POP
// end ;
29600: PPOPN 2
29602: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29603: LD_EXP 56
29607: PUSH
29608: LD_EXP 109
29612: AND
29613: IFFALSE 29894
29615: GO 29617
29617: DISABLE
29618: LD_INT 0
29620: PPUSH
29621: PPUSH
29622: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29623: LD_OWVAR 2
29627: PPUSH
29628: LD_INT 9
29630: PPUSH
29631: LD_INT 1
29633: PPUSH
29634: LD_INT 1
29636: PPUSH
29637: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29641: LD_INT 9
29643: PPUSH
29644: LD_OWVAR 2
29648: PPUSH
29649: CALL_OW 343
// uc_side := 9 ;
29653: LD_ADDR_OWVAR 20
29657: PUSH
29658: LD_INT 9
29660: ST_TO_ADDR
// uc_nation := 2 ;
29661: LD_ADDR_OWVAR 21
29665: PUSH
29666: LD_INT 2
29668: ST_TO_ADDR
// hc_name := Dark Warrior ;
29669: LD_ADDR_OWVAR 26
29673: PUSH
29674: LD_STRING Dark Warrior
29676: ST_TO_ADDR
// hc_gallery :=  ;
29677: LD_ADDR_OWVAR 33
29681: PUSH
29682: LD_STRING 
29684: ST_TO_ADDR
// hc_noskilllimit := true ;
29685: LD_ADDR_OWVAR 76
29689: PUSH
29690: LD_INT 1
29692: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
29693: LD_ADDR_OWVAR 31
29697: PUSH
29698: LD_INT 30
29700: PUSH
29701: LD_INT 30
29703: PUSH
29704: LD_INT 30
29706: PUSH
29707: LD_INT 30
29709: PUSH
29710: EMPTY
29711: LIST
29712: LIST
29713: LIST
29714: LIST
29715: ST_TO_ADDR
// un := CreateHuman ;
29716: LD_ADDR_VAR 0 3
29720: PUSH
29721: CALL_OW 44
29725: ST_TO_ADDR
// hc_noskilllimit := false ;
29726: LD_ADDR_OWVAR 76
29730: PUSH
29731: LD_INT 0
29733: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29734: LD_VAR 0 3
29738: PPUSH
29739: LD_INT 1
29741: PPUSH
29742: CALL_OW 51
// p := 0 ;
29746: LD_ADDR_VAR 0 2
29750: PUSH
29751: LD_INT 0
29753: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29754: LD_INT 35
29756: PPUSH
29757: CALL_OW 67
// p := p + 1 ;
29761: LD_ADDR_VAR 0 2
29765: PUSH
29766: LD_VAR 0 2
29770: PUSH
29771: LD_INT 1
29773: PLUS
29774: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
29775: LD_VAR 0 3
29779: PPUSH
29780: CALL_OW 256
29784: PUSH
29785: LD_INT 1000
29787: LESS
29788: IFFALSE 29802
// SetLives ( un , 1000 ) ;
29790: LD_VAR 0 3
29794: PPUSH
29795: LD_INT 1000
29797: PPUSH
29798: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
29802: LD_VAR 0 3
29806: PPUSH
29807: LD_INT 81
29809: PUSH
29810: LD_OWVAR 2
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 91
29821: PUSH
29822: LD_VAR 0 3
29826: PUSH
29827: LD_INT 30
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: LIST
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PPUSH
29839: CALL_OW 69
29843: PPUSH
29844: LD_VAR 0 3
29848: PPUSH
29849: CALL_OW 74
29853: PPUSH
29854: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29858: LD_VAR 0 2
29862: PUSH
29863: LD_INT 60
29865: GREATER
29866: PUSH
29867: LD_VAR 0 3
29871: PPUSH
29872: CALL_OW 301
29876: OR
29877: IFFALSE 29754
// if un then
29879: LD_VAR 0 3
29883: IFFALSE 29894
// RemoveUnit ( un ) ;
29885: LD_VAR 0 3
29889: PPUSH
29890: CALL_OW 64
// end ; end_of_file
29894: PPOPN 3
29896: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29897: LD_INT 0
29899: PPUSH
29900: PPUSH
29901: PPUSH
29902: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29903: LD_VAR 0 1
29907: PPUSH
29908: CALL_OW 264
29912: PUSH
29913: LD_EXP 47
29917: EQUAL
29918: IFFALSE 29990
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29920: LD_INT 68
29922: PPUSH
29923: LD_VAR 0 1
29927: PPUSH
29928: CALL_OW 255
29932: PPUSH
29933: CALL_OW 321
29937: PUSH
29938: LD_INT 2
29940: EQUAL
29941: IFFALSE 29953
// eff := 70 else
29943: LD_ADDR_VAR 0 4
29947: PUSH
29948: LD_INT 70
29950: ST_TO_ADDR
29951: GO 29961
// eff := 30 ;
29953: LD_ADDR_VAR 0 4
29957: PUSH
29958: LD_INT 30
29960: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29961: LD_VAR 0 1
29965: PPUSH
29966: CALL_OW 250
29970: PPUSH
29971: LD_VAR 0 1
29975: PPUSH
29976: CALL_OW 251
29980: PPUSH
29981: LD_VAR 0 4
29985: PPUSH
29986: CALL_OW 495
// end ; end ;
29990: LD_VAR 0 2
29994: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29995: LD_INT 0
29997: PPUSH
// end ;
29998: LD_VAR 0 4
30002: RET
// export function SOS_Command ( cmd ) ; begin
30003: LD_INT 0
30005: PPUSH
// end ;
30006: LD_VAR 0 2
30010: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
30011: LD_VAR 0 1
30015: PUSH
30016: LD_INT 255
30018: EQUAL
30019: PUSH
30020: LD_VAR 0 2
30024: PPUSH
30025: CALL_OW 264
30029: PUSH
30030: LD_INT 14
30032: PUSH
30033: LD_INT 53
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: IN
30040: AND
30041: PUSH
30042: LD_VAR 0 4
30046: PPUSH
30047: LD_VAR 0 5
30051: PPUSH
30052: CALL_OW 488
30056: AND
30057: IFFALSE 30081
// CutTreeXYR ( unit , x , y , 12 ) ;
30059: LD_VAR 0 2
30063: PPUSH
30064: LD_VAR 0 4
30068: PPUSH
30069: LD_VAR 0 5
30073: PPUSH
30074: LD_INT 12
30076: PPUSH
30077: CALL 30084 0 4
// end ;
30081: PPOPN 5
30083: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
30084: LD_INT 0
30086: PPUSH
30087: PPUSH
30088: PPUSH
30089: PPUSH
30090: PPUSH
30091: PPUSH
30092: PPUSH
30093: PPUSH
30094: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
30095: LD_VAR 0 1
30099: NOT
30100: PUSH
30101: LD_VAR 0 2
30105: PPUSH
30106: LD_VAR 0 3
30110: PPUSH
30111: CALL_OW 488
30115: NOT
30116: OR
30117: PUSH
30118: LD_VAR 0 4
30122: NOT
30123: OR
30124: IFFALSE 30128
// exit ;
30126: GO 30468
// list := [ ] ;
30128: LD_ADDR_VAR 0 13
30132: PUSH
30133: EMPTY
30134: ST_TO_ADDR
// if x - r < 0 then
30135: LD_VAR 0 2
30139: PUSH
30140: LD_VAR 0 4
30144: MINUS
30145: PUSH
30146: LD_INT 0
30148: LESS
30149: IFFALSE 30161
// min_x := 0 else
30151: LD_ADDR_VAR 0 7
30155: PUSH
30156: LD_INT 0
30158: ST_TO_ADDR
30159: GO 30177
// min_x := x - r ;
30161: LD_ADDR_VAR 0 7
30165: PUSH
30166: LD_VAR 0 2
30170: PUSH
30171: LD_VAR 0 4
30175: MINUS
30176: ST_TO_ADDR
// if y - r < 0 then
30177: LD_VAR 0 3
30181: PUSH
30182: LD_VAR 0 4
30186: MINUS
30187: PUSH
30188: LD_INT 0
30190: LESS
30191: IFFALSE 30203
// min_y := 0 else
30193: LD_ADDR_VAR 0 8
30197: PUSH
30198: LD_INT 0
30200: ST_TO_ADDR
30201: GO 30219
// min_y := y - r ;
30203: LD_ADDR_VAR 0 8
30207: PUSH
30208: LD_VAR 0 3
30212: PUSH
30213: LD_VAR 0 4
30217: MINUS
30218: ST_TO_ADDR
// max_x := x + r ;
30219: LD_ADDR_VAR 0 9
30223: PUSH
30224: LD_VAR 0 2
30228: PUSH
30229: LD_VAR 0 4
30233: PLUS
30234: ST_TO_ADDR
// max_y := y + r ;
30235: LD_ADDR_VAR 0 10
30239: PUSH
30240: LD_VAR 0 3
30244: PUSH
30245: LD_VAR 0 4
30249: PLUS
30250: ST_TO_ADDR
// for _x = min_x to max_x do
30251: LD_ADDR_VAR 0 11
30255: PUSH
30256: DOUBLE
30257: LD_VAR 0 7
30261: DEC
30262: ST_TO_ADDR
30263: LD_VAR 0 9
30267: PUSH
30268: FOR_TO
30269: IFFALSE 30386
// for _y = min_y to max_y do
30271: LD_ADDR_VAR 0 12
30275: PUSH
30276: DOUBLE
30277: LD_VAR 0 8
30281: DEC
30282: ST_TO_ADDR
30283: LD_VAR 0 10
30287: PUSH
30288: FOR_TO
30289: IFFALSE 30382
// begin if not ValidHex ( _x , _y ) then
30291: LD_VAR 0 11
30295: PPUSH
30296: LD_VAR 0 12
30300: PPUSH
30301: CALL_OW 488
30305: NOT
30306: IFFALSE 30310
// continue ;
30308: GO 30288
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
30310: LD_VAR 0 11
30314: PPUSH
30315: LD_VAR 0 12
30319: PPUSH
30320: CALL_OW 351
30324: PUSH
30325: LD_VAR 0 11
30329: PPUSH
30330: LD_VAR 0 12
30334: PPUSH
30335: CALL_OW 554
30339: AND
30340: IFFALSE 30380
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
30342: LD_ADDR_VAR 0 13
30346: PUSH
30347: LD_VAR 0 13
30351: PPUSH
30352: LD_VAR 0 13
30356: PUSH
30357: LD_INT 1
30359: PLUS
30360: PPUSH
30361: LD_VAR 0 11
30365: PUSH
30366: LD_VAR 0 12
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: PPUSH
30375: CALL_OW 2
30379: ST_TO_ADDR
// end ;
30380: GO 30288
30382: POP
30383: POP
30384: GO 30268
30386: POP
30387: POP
// if not list then
30388: LD_VAR 0 13
30392: NOT
30393: IFFALSE 30397
// exit ;
30395: GO 30468
// for i in list do
30397: LD_ADDR_VAR 0 6
30401: PUSH
30402: LD_VAR 0 13
30406: PUSH
30407: FOR_IN
30408: IFFALSE 30466
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
30410: LD_VAR 0 1
30414: PPUSH
30415: LD_STRING M
30417: PUSH
30418: LD_VAR 0 6
30422: PUSH
30423: LD_INT 1
30425: ARRAY
30426: PUSH
30427: LD_VAR 0 6
30431: PUSH
30432: LD_INT 2
30434: ARRAY
30435: PUSH
30436: LD_INT 0
30438: PUSH
30439: LD_INT 0
30441: PUSH
30442: LD_INT 0
30444: PUSH
30445: LD_INT 0
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: PUSH
30457: EMPTY
30458: LIST
30459: PPUSH
30460: CALL_OW 447
30464: GO 30407
30466: POP
30467: POP
// end ;
30468: LD_VAR 0 5
30472: RET
