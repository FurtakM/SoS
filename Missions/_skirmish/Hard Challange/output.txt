// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// debug := 0 ;
  21: LD_ADDR_EXP 1
  25: PUSH
  26: LD_INT 0
  28: ST_TO_ADDR
// if debug then
  29: LD_EXP 1
  33: IFFALSE 55
// begin display_strings := Debug mode active! ;
  35: LD_ADDR_OWVAR 47
  39: PUSH
  40: LD_STRING Debug mode active!
  42: ST_TO_ADDR
// Your_Side := 1 ;
  43: LD_ADDR_OWVAR 2
  47: PUSH
  48: LD_INT 1
  50: ST_TO_ADDR
// TurnFogOff ;
  51: CALL_OW 537
// end ; Difficulty := GetMultiplayerSetting ( 0 ) ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 426
  67: ST_TO_ADDR
// if not Difficulty then
  68: LD_OWVAR 67
  72: NOT
  73: IFFALSE 83
// Difficulty := 2 ;
  75: LD_ADDR_OWVAR 67
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// PrepareTigers ( tiger_area ) ;
  83: LD_INT 8
  85: PPUSH
  86: CALL 10142 0 1
// PrepareApemans ( apeman_area ) ;
  90: LD_INT 9
  92: PPUSH
  93: CALL 10272 0 1
// PrepareRussian ;
  97: CALL 117 0 0
// PrepareAmerican ;
 101: CALL 11679 0 0
// if not debug then
 105: LD_EXP 1
 109: NOT
 110: IFFALSE 116
// Action ;
 112: CALL 13908 0 0
// end ;
 116: END
// export debug ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 117: LD_INT 0
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
// uc_side := 3 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 3
 130: ST_TO_ADDR
// uc_nation := nation_russian ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 3
 138: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 139: LD_ADDR_VAR 0 2
 143: PUSH
 144: LD_INT 6
 146: PUSH
 147: LD_INT 7
 149: PUSH
 150: LD_INT 8
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: LIST
 157: PUSH
 158: LD_OWVAR 67
 162: ARRAY
 163: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 164: LD_INT 2
 166: PPUSH
 167: CALL_OW 274
 171: PPUSH
 172: LD_INT 1
 174: PPUSH
 175: LD_INT 1200
 177: PPUSH
 178: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 182: LD_INT 2
 184: PPUSH
 185: CALL_OW 274
 189: PPUSH
 190: LD_INT 2
 192: PPUSH
 193: LD_INT 600
 195: PPUSH
 196: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 200: LD_INT 33
 202: PPUSH
 203: LD_INT 4
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 213: LD_INT 37
 215: PPUSH
 216: LD_INT 3
 218: PPUSH
 219: LD_INT 3
 221: PPUSH
 222: CALL_OW 441
// ru_force := [ ] ;
 226: LD_ADDR_EXP 2
 230: PUSH
 231: EMPTY
 232: ST_TO_ADDR
// ru_group1 := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// ru_group2 := [ ] ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: EMPTY
 246: ST_TO_ADDR
// ru_reserve := [ ] ;
 247: LD_ADDR_EXP 8
 251: PUSH
 252: EMPTY
 253: ST_TO_ADDR
// ru_attack_list := [ ] ;
 254: LD_ADDR_EXP 9
 258: PUSH
 259: EMPTY
 260: ST_TO_ADDR
// ru_protector := [ ] ;
 261: LD_ADDR_EXP 16
 265: PUSH
 266: EMPTY
 267: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 268: LD_ADDR_EXP 5
 272: PUSH
 273: LD_INT 48
 275: PUSH
 276: LD_INT 49
 278: PUSH
 279: LD_INT 50
 281: PUSH
 282: LD_INT 20
 284: PUSH
 285: LD_INT 1
 287: PUSH
 288: LD_INT 51
 290: PUSH
 291: LD_INT 52
 293: PUSH
 294: LD_INT 69
 296: PUSH
 297: LD_INT 39
 299: PUSH
 300: LD_INT 34
 302: PUSH
 303: LD_INT 40
 305: PUSH
 306: LD_INT 53
 308: PUSH
 309: LD_INT 71
 311: PUSH
 312: LD_INT 57
 314: PUSH
 315: LD_INT 58
 317: PUSH
 318: LD_INT 44
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: LD_INT 27
 326: PUSH
 327: LD_INT 23
 329: PUSH
 330: LD_INT 33
 332: PUSH
 333: LD_INT 59
 335: PUSH
 336: LD_INT 54
 338: PUSH
 339: LD_INT 55
 341: PUSH
 342: LD_INT 56
 344: PUSH
 345: LD_INT 63
 347: PUSH
 348: LD_INT 64
 350: PUSH
 351: LD_INT 65
 353: PUSH
 354: LD_INT 30
 356: PUSH
 357: LD_INT 31
 359: PUSH
 360: LD_INT 21
 362: PUSH
 363: LD_INT 22
 365: PUSH
 366: LD_INT 25
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 403: LD_ADDR_EXP 6
 407: PUSH
 408: LD_INT 3
 410: PPUSH
 411: LD_INT 33
 413: PPUSH
 414: CALL 8257 0 2
 418: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 419: LD_ADDR_EXP 7
 423: PUSH
 424: LD_INT 46
 426: PUSH
 427: LD_INT 45
 429: PUSH
 430: LD_INT 47
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 438: LD_ADDR_EXP 12
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 36
 448: PUSH
 449: LD_INT 8
 451: PUSH
 452: LD_INT 3
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// ru_buildings := [ ] ;
 461: LD_ADDR_EXP 13
 465: PUSH
 466: EMPTY
 467: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 468: LD_ADDR_EXP 10
 472: PUSH
 473: LD_INT 3
 475: PPUSH
 476: CALL 6306 0 1
 480: PUSH
 481: LD_INT 1
 483: ARRAY
 484: PPUSH
 485: CALL_OW 250
 489: PUSH
 490: LD_INT 3
 492: PPUSH
 493: CALL 6306 0 1
 497: PUSH
 498: LD_INT 1
 500: ARRAY
 501: PPUSH
 502: CALL_OW 251
 506: PUSH
 507: LD_INT 3
 509: PPUSH
 510: CALL 6306 0 1
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: CALL_OW 254
 523: PUSH
 524: LD_INT 3
 526: PPUSH
 527: CALL 6306 0 1
 531: PUSH
 532: LD_INT 1
 534: ARRAY
 535: PPUSH
 536: LD_INT 1
 538: PPUSH
 539: CALL_OW 268
 543: PUSH
 544: LD_INT 3
 546: PPUSH
 547: CALL 6306 0 1
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_INT 2
 558: PPUSH
 559: CALL_OW 268
 563: PUSH
 564: EMPTY
 565: LIST
 566: LIST
 567: LIST
 568: LIST
 569: LIST
 570: PUSH
 571: LD_INT 12
 573: PUSH
 574: LD_INT 13
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 11
 582: PUSH
 583: LD_INT 14
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: ST_TO_ADDR
// ru_heal_list := [ ] ;
 597: LD_ADDR_EXP 11
 601: PUSH
 602: EMPTY
 603: ST_TO_ADDR
// need_buldozer := false ;
 604: LD_ADDR_EXP 17
 608: PUSH
 609: LD_INT 0
 611: ST_TO_ADDR
// need_crane := true ;
 612: LD_ADDR_EXP 18
 616: PUSH
 617: LD_INT 1
 619: ST_TO_ADDR
// ru_spotted := false ;
 620: LD_ADDR_EXP 15
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// for i = 1 to 6 do
 628: LD_ADDR_VAR 0 3
 632: PUSH
 633: DOUBLE
 634: LD_INT 1
 636: DEC
 637: ST_TO_ADDR
 638: LD_INT 6
 640: PUSH
 641: FOR_TO
 642: IFFALSE 683
// begin PrepareHuman ( false , 4 , skill ) ;
 644: LD_INT 0
 646: PPUSH
 647: LD_INT 4
 649: PPUSH
 650: LD_VAR 0 2
 654: PPUSH
 655: CALL_OW 380
// un := CreateHuman ;
 659: LD_ADDR_VAR 0 4
 663: PUSH
 664: CALL_OW 44
 668: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 669: LD_VAR 0 4
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: CALL_OW 52
// end ;
 681: GO 641
 683: POP
 684: POP
// for i = 1 to 6 do
 685: LD_ADDR_VAR 0 3
 689: PUSH
 690: DOUBLE
 691: LD_INT 1
 693: DEC
 694: ST_TO_ADDR
 695: LD_INT 6
 697: PUSH
 698: FOR_TO
 699: IFFALSE 740
// begin PrepareHuman ( false , 3 , skill ) ;
 701: LD_INT 0
 703: PPUSH
 704: LD_INT 3
 706: PPUSH
 707: LD_VAR 0 2
 711: PPUSH
 712: CALL_OW 380
// un := CreateHuman ;
 716: LD_ADDR_VAR 0 4
 720: PUSH
 721: CALL_OW 44
 725: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 726: LD_VAR 0 4
 730: PPUSH
 731: LD_INT 14
 733: PPUSH
 734: CALL_OW 52
// end ;
 738: GO 698
 740: POP
 741: POP
// for i = 1 to 6 do
 742: LD_ADDR_VAR 0 3
 746: PUSH
 747: DOUBLE
 748: LD_INT 1
 750: DEC
 751: ST_TO_ADDR
 752: LD_INT 6
 754: PUSH
 755: FOR_TO
 756: IFFALSE 800
// begin PrepareHuman ( false , 2 , skill ) ;
 758: LD_INT 0
 760: PPUSH
 761: LD_INT 2
 763: PPUSH
 764: LD_VAR 0 2
 768: PPUSH
 769: CALL_OW 380
// un := CreateHuman ;
 773: LD_ADDR_VAR 0 4
 777: PUSH
 778: CALL_OW 44
 782: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 783: LD_VAR 0 4
 787: PPUSH
 788: LD_INT 1
 790: PPUSH
 791: LD_INT 0
 793: PPUSH
 794: CALL_OW 49
// end ;
 798: GO 755
 800: POP
 801: POP
// for i = 1 to 6 do
 802: LD_ADDR_VAR 0 3
 806: PUSH
 807: DOUBLE
 808: LD_INT 1
 810: DEC
 811: ST_TO_ADDR
 812: LD_INT 6
 814: PUSH
 815: FOR_TO
 816: IFFALSE 894
// begin PrepareHuman ( false , 1 , skill ) ;
 818: LD_INT 0
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: LD_VAR 0 2
 828: PPUSH
 829: CALL_OW 380
// un := CreateHuman ;
 833: LD_ADDR_VAR 0 4
 837: PUSH
 838: CALL_OW 44
 842: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 843: LD_VAR 0 4
 847: PPUSH
 848: LD_INT 1
 850: PPUSH
 851: LD_INT 0
 853: PPUSH
 854: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 858: LD_VAR 0 4
 862: PPUSH
 863: LD_INT 30
 865: PUSH
 866: LD_INT 5
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL_OW 69
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: CALL_OW 74
 887: PPUSH
 888: CALL_OW 120
// end ;
 892: GO 815
 894: POP
 895: POP
// for i = 1 to Difficulty do
 896: LD_ADDR_VAR 0 3
 900: PUSH
 901: DOUBLE
 902: LD_INT 1
 904: DEC
 905: ST_TO_ADDR
 906: LD_OWVAR 67
 910: PUSH
 911: FOR_TO
 912: IFFALSE 1023
// begin vc_chassis := ru_medium_tracked ;
 914: LD_ADDR_OWVAR 37
 918: PUSH
 919: LD_INT 22
 921: ST_TO_ADDR
// vc_engine := engine_siberite ;
 922: LD_ADDR_OWVAR 39
 926: PUSH
 927: LD_INT 3
 929: ST_TO_ADDR
// vc_control := control_computer ;
 930: LD_ADDR_OWVAR 38
 934: PUSH
 935: LD_INT 3
 937: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 938: LD_ADDR_OWVAR 40
 942: PUSH
 943: LD_INT 43
 945: PUSH
 946: LD_INT 45
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: PUSH
 953: LD_VAR 0 3
 957: PUSH
 958: LD_INT 2
 960: MOD
 961: PUSH
 962: LD_INT 1
 964: PLUS
 965: ARRAY
 966: ST_TO_ADDR
// un := CreateVehicle ;
 967: LD_ADDR_VAR 0 4
 971: PUSH
 972: CALL_OW 45
 976: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
 977: LD_VAR 0 4
 981: PPUSH
 982: LD_INT 52
 984: PPUSH
 985: LD_INT 42
 987: PPUSH
 988: LD_INT 6
 990: PPUSH
 991: LD_INT 0
 993: PPUSH
 994: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
 998: LD_ADDR_EXP 16
1002: PUSH
1003: LD_EXP 16
1007: PPUSH
1008: LD_INT 1
1010: PPUSH
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 2
1020: ST_TO_ADDR
// end ;
1021: GO 911
1023: POP
1024: POP
// end ;
1025: LD_VAR 0 1
1029: RET
// every 150 150$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1030: LD_OWVAR 67
1034: PUSH
1035: LD_INT 2
1037: EQUAL
1038: PUSH
1039: LD_INT 3
1041: PPUSH
1042: LD_INT 3
1044: PPUSH
1045: CALL 6155 0 2
1049: AND
1050: IFFALSE 1086
1052: GO 1054
1054: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 3
1060: PPUSH
1061: CALL 6155 0 2
1065: PUSH
1066: LD_INT 1
1068: ARRAY
1069: PPUSH
1070: LD_INT 24
1072: PPUSH
1073: LD_INT 1
1075: PPUSH
1076: LD_INT 3
1078: PPUSH
1079: LD_INT 48
1081: PPUSH
1082: CALL 8030 0 5
1086: END
// every 120 120$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1087: LD_OWVAR 67
1091: PUSH
1092: LD_INT 3
1094: EQUAL
1095: PUSH
1096: LD_INT 3
1098: PPUSH
1099: LD_INT 3
1101: PPUSH
1102: CALL 6155 0 2
1106: AND
1107: IFFALSE 1143
1109: GO 1111
1111: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1112: LD_INT 3
1114: PPUSH
1115: LD_INT 3
1117: PPUSH
1118: CALL 6155 0 2
1122: PUSH
1123: LD_INT 1
1125: ARRAY
1126: PPUSH
1127: LD_INT 24
1129: PPUSH
1130: LD_INT 1
1132: PPUSH
1133: LD_INT 3
1135: PPUSH
1136: LD_INT 48
1138: PPUSH
1139: CALL 8030 0 5
1143: END
// every 0 0$01 trigger ru_protector do var i ;
1144: LD_EXP 16
1148: IFFALSE 1319
1150: GO 1152
1152: DISABLE
1153: LD_INT 0
1155: PPUSH
// begin enable ;
1156: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1157: LD_INT 14
1159: PPUSH
1160: LD_INT 81
1162: PUSH
1163: LD_INT 3
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: PPUSH
1170: CALL_OW 70
1174: IFFALSE 1249
// begin for i = 1 to ru_protector do
1176: LD_ADDR_VAR 0 1
1180: PUSH
1181: DOUBLE
1182: LD_INT 1
1184: DEC
1185: ST_TO_ADDR
1186: LD_EXP 16
1190: PUSH
1191: FOR_TO
1192: IFFALSE 1245
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1194: LD_EXP 16
1198: PUSH
1199: LD_VAR 0 1
1203: ARRAY
1204: PPUSH
1205: LD_INT 14
1207: PPUSH
1208: LD_INT 81
1210: PUSH
1211: LD_INT 3
1213: PUSH
1214: EMPTY
1215: LIST
1216: LIST
1217: PPUSH
1218: CALL_OW 70
1222: PPUSH
1223: LD_EXP 16
1227: PUSH
1228: LD_VAR 0 1
1232: ARRAY
1233: PPUSH
1234: CALL_OW 74
1238: PPUSH
1239: CALL_OW 115
1243: GO 1191
1245: POP
1246: POP
// end else
1247: GO 1319
// for i = 1 to ru_protector do
1249: LD_ADDR_VAR 0 1
1253: PUSH
1254: DOUBLE
1255: LD_INT 1
1257: DEC
1258: ST_TO_ADDR
1259: LD_EXP 16
1263: PUSH
1264: FOR_TO
1265: IFFALSE 1317
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1267: LD_EXP 16
1271: PUSH
1272: LD_VAR 0 1
1276: ARRAY
1277: PPUSH
1278: LD_INT 49
1280: PPUSH
1281: LD_INT 39
1283: PPUSH
1284: CALL_OW 297
1288: PUSH
1289: LD_INT 10
1291: GREATER
1292: IFFALSE 1315
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1294: LD_EXP 16
1298: PUSH
1299: LD_VAR 0 1
1303: ARRAY
1304: PPUSH
1305: LD_INT 49
1307: PPUSH
1308: LD_INT 39
1310: PPUSH
1311: CALL_OW 111
1315: GO 1264
1317: POP
1318: POP
// end ;
1319: PPOPN 1
1321: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1322: LD_OWVAR 1
1326: PUSH
1327: LD_INT 4200
1329: PUSH
1330: LD_INT 2100
1332: PUSH
1333: LD_INT 1050
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: LD_OWVAR 67
1345: ARRAY
1346: GREATER
1347: IFFALSE 1360
1349: GO 1351
1351: DISABLE
// need_buldozer := true ;
1352: LD_ADDR_EXP 17
1356: PUSH
1357: LD_INT 1
1359: ST_TO_ADDR
1360: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1361: GO 1363
1363: DISABLE
// begin enable ;
1364: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1365: LD_ADDR_EXP 19
1369: PUSH
1370: LD_INT 22
1372: PUSH
1373: LD_INT 3
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: PUSH
1380: LD_INT 25
1382: PUSH
1383: LD_INT 1
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: PPUSH
1394: CALL_OW 69
1398: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1399: LD_ADDR_EXP 20
1403: PUSH
1404: LD_INT 22
1406: PUSH
1407: LD_INT 3
1409: PUSH
1410: EMPTY
1411: LIST
1412: LIST
1413: PUSH
1414: LD_INT 25
1416: PUSH
1417: LD_INT 2
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: PPUSH
1428: CALL_OW 69
1432: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1433: LD_ADDR_EXP 21
1437: PUSH
1438: LD_INT 22
1440: PUSH
1441: LD_INT 3
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: PUSH
1448: LD_INT 25
1450: PUSH
1451: LD_INT 3
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: EMPTY
1459: LIST
1460: LIST
1461: PPUSH
1462: CALL_OW 69
1466: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_INT 22
1474: PUSH
1475: LD_INT 3
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: LD_INT 25
1484: PUSH
1485: LD_INT 4
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PPUSH
1496: CALL_OW 69
1500: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1501: LD_ADDR_EXP 23
1505: PUSH
1506: LD_INT 22
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: LD_INT 25
1518: PUSH
1519: LD_INT 9
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL_OW 69
1534: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1535: LD_ADDR_EXP 24
1539: PUSH
1540: LD_INT 2
1542: PPUSH
1543: LD_INT 22
1545: PUSH
1546: LD_INT 3
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: PUSH
1553: LD_INT 21
1555: PUSH
1556: LD_INT 1
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: PPUSH
1567: CALL_OW 70
1571: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1572: LD_ADDR_EXP 25
1576: PUSH
1577: LD_INT 34
1579: PUSH
1580: LD_INT 53
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1592: LD_ADDR_EXP 26
1596: PUSH
1597: LD_INT 34
1599: PUSH
1600: LD_INT 52
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: PPUSH
1607: CALL_OW 69
1611: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1612: LD_ADDR_EXP 27
1616: PUSH
1617: LD_INT 34
1619: PUSH
1620: LD_INT 51
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PPUSH
1627: CALL_OW 69
1631: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1632: LD_ADDR_EXP 13
1636: PUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 1
1642: NEG
1643: PPUSH
1644: CALL 10660 0 2
1648: ST_TO_ADDR
// end ;
1649: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1650: LD_INT 22
1652: PUSH
1653: LD_INT 3
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PPUSH
1660: CALL_OW 69
1664: PUSH
1665: LD_EXP 28
1669: AND
1670: PUSH
1671: LD_EXP 1
1675: OR
1676: IFFALSE 5165
1678: GO 1680
1680: DISABLE
1681: LD_INT 0
1683: PPUSH
1684: PPUSH
1685: PPUSH
1686: PPUSH
1687: PPUSH
1688: PPUSH
1689: PPUSH
1690: PPUSH
1691: PPUSH
1692: PPUSH
// begin enable ;
1693: ENABLE
// for i = 1 to ru_eng do
1694: LD_ADDR_VAR 0 1
1698: PUSH
1699: DOUBLE
1700: LD_INT 1
1702: DEC
1703: ST_TO_ADDR
1704: LD_EXP 20
1708: PUSH
1709: FOR_TO
1710: IFFALSE 1773
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1712: LD_EXP 20
1716: PUSH
1717: LD_VAR 0 1
1721: ARRAY
1722: PPUSH
1723: CALL_OW 314
1727: NOT
1728: PUSH
1729: LD_EXP 20
1733: PUSH
1734: LD_VAR 0 1
1738: ARRAY
1739: PPUSH
1740: CALL_OW 310
1744: NOT
1745: AND
1746: IFFALSE 1771
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1748: LD_EXP 20
1752: PUSH
1753: LD_VAR 0 1
1757: ARRAY
1758: PPUSH
1759: LD_INT 3
1761: PPUSH
1762: CALL 6064 0 1
1766: PPUSH
1767: CALL_OW 120
1771: GO 1709
1773: POP
1774: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1775: LD_INT 2
1777: PPUSH
1778: LD_INT 22
1780: PUSH
1781: LD_INT 3
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 21
1790: PUSH
1791: LD_INT 3
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: LD_INT 24
1803: PUSH
1804: LD_INT 1000
1806: PUSH
1807: EMPTY
1808: LIST
1809: LIST
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 70
1824: IFFALSE 1991
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1826: LD_ADDR_VAR 0 4
1830: PUSH
1831: LD_INT 2
1833: PPUSH
1834: LD_INT 22
1836: PUSH
1837: LD_INT 3
1839: PUSH
1840: EMPTY
1841: LIST
1842: LIST
1843: PUSH
1844: LD_INT 21
1846: PUSH
1847: LD_INT 3
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: PUSH
1854: LD_INT 3
1856: PUSH
1857: LD_INT 24
1859: PUSH
1860: LD_INT 1000
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: LIST
1875: PPUSH
1876: CALL_OW 70
1880: ST_TO_ADDR
// for i = 1 to ru_eng do
1881: LD_ADDR_VAR 0 1
1885: PUSH
1886: DOUBLE
1887: LD_INT 1
1889: DEC
1890: ST_TO_ADDR
1891: LD_EXP 20
1895: PUSH
1896: FOR_TO
1897: IFFALSE 1989
// begin if IsInUnit ( ru_eng [ i ] ) then
1899: LD_EXP 20
1903: PUSH
1904: LD_VAR 0 1
1908: ARRAY
1909: PPUSH
1910: CALL_OW 310
1914: IFFALSE 1933
// ComExitBuilding ( ru_eng [ i ] ) else
1916: LD_EXP 20
1920: PUSH
1921: LD_VAR 0 1
1925: ARRAY
1926: PPUSH
1927: CALL_OW 122
1931: GO 1987
// if not WantRepair ( ru_eng [ i ] ) then
1933: LD_EXP 20
1937: PUSH
1938: LD_VAR 0 1
1942: ARRAY
1943: PPUSH
1944: CALL 10586 0 1
1948: NOT
1949: IFFALSE 1987
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1951: LD_EXP 20
1955: PUSH
1956: LD_VAR 0 1
1960: ARRAY
1961: PPUSH
1962: LD_VAR 0 4
1966: PPUSH
1967: LD_EXP 20
1971: PUSH
1972: LD_VAR 0 1
1976: ARRAY
1977: PPUSH
1978: CALL_OW 74
1982: PPUSH
1983: CALL_OW 130
// end ;
1987: GO 1896
1989: POP
1990: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
1991: LD_OWVAR 2
1995: PPUSH
1996: LD_INT 38
1998: PPUSH
1999: LD_INT 26
2001: PPUSH
2002: CALL 5383 0 3
2006: PUSH
2007: LD_INT 0
2009: EQUAL
2010: PUSH
2011: LD_OWVAR 2
2015: PPUSH
2016: LD_INT 29
2018: PPUSH
2019: LD_INT 37
2021: PPUSH
2022: CALL 5383 0 3
2026: PUSH
2027: LD_INT 0
2029: EQUAL
2030: AND
2031: IFFALSE 2168
// begin if ru_blist > 0 then
2033: LD_EXP 12
2037: PUSH
2038: LD_INT 0
2040: GREATER
2041: IFFALSE 2168
// begin for i = 1 to ru_eng do
2043: LD_ADDR_VAR 0 1
2047: PUSH
2048: DOUBLE
2049: LD_INT 1
2051: DEC
2052: ST_TO_ADDR
2053: LD_EXP 20
2057: PUSH
2058: FOR_TO
2059: IFFALSE 2166
// if IsInUnit ( ru_eng [ i ] ) then
2061: LD_EXP 20
2065: PUSH
2066: LD_VAR 0 1
2070: ARRAY
2071: PPUSH
2072: CALL_OW 310
2076: IFFALSE 2095
// ComExitBuilding ( ru_eng [ i ] ) else
2078: LD_EXP 20
2082: PUSH
2083: LD_VAR 0 1
2087: ARRAY
2088: PPUSH
2089: CALL_OW 122
2093: GO 2164
// if not HasTask ( ru_eng [ i ] ) then
2095: LD_EXP 20
2099: PUSH
2100: LD_VAR 0 1
2104: ARRAY
2105: PPUSH
2106: CALL_OW 314
2110: NOT
2111: IFFALSE 2164
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2113: LD_EXP 20
2117: PUSH
2118: LD_VAR 0 1
2122: ARRAY
2123: PPUSH
2124: LD_EXP 12
2128: PUSH
2129: LD_INT 1
2131: ARRAY
2132: PPUSH
2133: LD_EXP 12
2137: PUSH
2138: LD_INT 2
2140: ARRAY
2141: PPUSH
2142: LD_EXP 12
2146: PUSH
2147: LD_INT 3
2149: ARRAY
2150: PPUSH
2151: LD_EXP 12
2155: PUSH
2156: LD_INT 4
2158: ARRAY
2159: PPUSH
2160: CALL_OW 145
2164: GO 2058
2166: POP
2167: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2168: LD_ADDR_EXP 11
2172: PUSH
2173: LD_INT 3
2175: PPUSH
2176: LD_EXP 11
2180: PPUSH
2181: LD_EXP 14
2185: PPUSH
2186: CALL 9073 0 3
2190: ST_TO_ADDR
// if debug then
2191: LD_EXP 1
2195: IFFALSE 2207
// display_strings := ru_heal_list ;
2197: LD_ADDR_OWVAR 47
2201: PUSH
2202: LD_EXP 11
2206: ST_TO_ADDR
// for i = 1 to ru_sci do
2207: LD_ADDR_VAR 0 1
2211: PUSH
2212: DOUBLE
2213: LD_INT 1
2215: DEC
2216: ST_TO_ADDR
2217: LD_EXP 22
2221: PUSH
2222: FOR_TO
2223: IFFALSE 2555
// begin if ru_heal_list then
2225: LD_EXP 11
2229: IFFALSE 2468
// begin list := ru_heal_list ;
2231: LD_ADDR_VAR 0 9
2235: PUSH
2236: LD_EXP 11
2240: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2241: LD_EXP 22
2245: PUSH
2246: LD_VAR 0 1
2250: ARRAY
2251: PPUSH
2252: CALL_OW 310
2256: IFFALSE 2273
// ComExitBuilding ( ru_sci [ i ] ) ;
2258: LD_EXP 22
2262: PUSH
2263: LD_VAR 0 1
2267: ARRAY
2268: PPUSH
2269: CALL_OW 122
// for p = 1 to list do
2273: LD_ADDR_VAR 0 5
2277: PUSH
2278: DOUBLE
2279: LD_INT 1
2281: DEC
2282: ST_TO_ADDR
2283: LD_VAR 0 9
2287: PUSH
2288: FOR_TO
2289: IFFALSE 2464
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2291: LD_VAR 0 9
2295: PUSH
2296: LD_VAR 0 5
2300: ARRAY
2301: PPUSH
2302: CALL_OW 110
2306: PUSH
2307: LD_INT 100
2309: EQUAL
2310: PUSH
2311: LD_EXP 22
2315: PUSH
2316: LD_VAR 0 1
2320: ARRAY
2321: PPUSH
2322: LD_INT 100
2324: PPUSH
2325: CALL 9433 0 2
2329: NOT
2330: AND
2331: IFFALSE 2359
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2333: LD_EXP 22
2337: PUSH
2338: LD_VAR 0 1
2342: ARRAY
2343: PPUSH
2344: LD_VAR 0 9
2348: PUSH
2349: LD_VAR 0 5
2353: ARRAY
2354: PPUSH
2355: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2359: LD_VAR 0 9
2363: PUSH
2364: LD_VAR 0 5
2368: ARRAY
2369: PPUSH
2370: CALL_OW 110
2374: PUSH
2375: LD_INT 100
2377: GREATER
2378: IFFALSE 2406
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2380: LD_EXP 22
2384: PUSH
2385: LD_VAR 0 1
2389: ARRAY
2390: PPUSH
2391: LD_VAR 0 9
2395: PUSH
2396: LD_VAR 0 5
2400: ARRAY
2401: PPUSH
2402: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2406: LD_VAR 0 9
2410: PUSH
2411: LD_VAR 0 5
2415: ARRAY
2416: PPUSH
2417: LD_INT 4
2419: PPUSH
2420: CALL_OW 308
2424: NOT
2425: IFFALSE 2447
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2427: LD_VAR 0 9
2431: PUSH
2432: LD_VAR 0 5
2436: ARRAY
2437: PPUSH
2438: LD_INT 4
2440: PPUSH
2441: CALL_OW 113
2445: GO 2462
// ComHold ( list [ p ] ) ;
2447: LD_VAR 0 9
2451: PUSH
2452: LD_VAR 0 5
2456: ARRAY
2457: PPUSH
2458: CALL_OW 140
// end ;
2462: GO 2288
2464: POP
2465: POP
// end else
2466: GO 2553
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2468: LD_EXP 22
2472: PUSH
2473: LD_VAR 0 1
2477: ARRAY
2478: PPUSH
2479: CALL_OW 314
2483: NOT
2484: PUSH
2485: LD_EXP 22
2489: PUSH
2490: LD_VAR 0 1
2494: ARRAY
2495: PPUSH
2496: CALL_OW 310
2500: NOT
2501: AND
2502: PUSH
2503: LD_EXP 11
2507: PUSH
2508: LD_INT 0
2510: EQUAL
2511: AND
2512: IFFALSE 2553
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2514: LD_EXP 22
2518: PUSH
2519: LD_VAR 0 1
2523: ARRAY
2524: PPUSH
2525: LD_INT 3
2527: PPUSH
2528: CALL 6306 0 1
2532: PPUSH
2533: LD_EXP 22
2537: PUSH
2538: LD_VAR 0 1
2542: ARRAY
2543: PPUSH
2544: CALL_OW 74
2548: PPUSH
2549: CALL_OW 120
// end ;
2553: GO 2222
2555: POP
2556: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2557: LD_INT 3
2559: PPUSH
2560: LD_EXP 5
2564: PPUSH
2565: CALL 6447 0 2
2569: IFFALSE 2583
// ResearchTechList ( 3 , ru_tech_list ) ;
2571: LD_INT 3
2573: PPUSH
2574: LD_EXP 5
2578: PPUSH
2579: CALL 6522 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2583: LD_EXP 20
2587: PPUSH
2588: LD_EXP 10
2592: PPUSH
2593: CALL 8429 0 2
// lab := GetLabs ( 3 ) ;
2597: LD_ADDR_VAR 0 8
2601: PUSH
2602: LD_INT 3
2604: PPUSH
2605: CALL 6306 0 1
2609: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2610: LD_VAR 0 8
2614: PUSH
2615: LD_EXP 11
2619: PUSH
2620: LD_INT 0
2622: EQUAL
2623: AND
2624: IFFALSE 2751
// for i = 1 to lab do
2626: LD_ADDR_VAR 0 1
2630: PUSH
2631: DOUBLE
2632: LD_INT 1
2634: DEC
2635: ST_TO_ADDR
2636: LD_VAR 0 8
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2749
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2644: LD_VAR 0 8
2648: PUSH
2649: LD_VAR 0 1
2653: ARRAY
2654: PPUSH
2655: CALL_OW 461
2659: PUSH
2660: LD_INT 6
2662: EQUAL
2663: IFFALSE 2747
// begin for p = 1 to ru_sci do
2665: LD_ADDR_VAR 0 5
2669: PUSH
2670: DOUBLE
2671: LD_INT 1
2673: DEC
2674: ST_TO_ADDR
2675: LD_EXP 22
2679: PUSH
2680: FOR_TO
2681: IFFALSE 2745
// if IsInUnit ( ru_sci [ p ] ) then
2683: LD_EXP 22
2687: PUSH
2688: LD_VAR 0 5
2692: ARRAY
2693: PPUSH
2694: CALL_OW 310
2698: IFFALSE 2717
// ComExitBuilding ( ru_sci [ p ] ) else
2700: LD_EXP 22
2704: PUSH
2705: LD_VAR 0 5
2709: ARRAY
2710: PPUSH
2711: CALL_OW 122
2715: GO 2743
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2717: LD_EXP 22
2721: PUSH
2722: LD_VAR 0 5
2726: ARRAY
2727: PPUSH
2728: LD_VAR 0 8
2732: PUSH
2733: LD_VAR 0 1
2737: ARRAY
2738: PPUSH
2739: CALL_OW 120
2743: GO 2680
2745: POP
2746: POP
// end ;
2747: GO 2641
2749: POP
2750: POP
// if GetTowers ( 3 ) < 5 then
2751: LD_INT 3
2753: PPUSH
2754: CALL 6861 0 1
2758: PUSH
2759: LD_INT 5
2761: LESS
2762: IFFALSE 2780
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2764: LD_EXP 20
2768: PPUSH
2769: LD_EXP 6
2773: PPUSH
2774: CALL 7469 0 2
2778: GO 2792
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2780: LD_INT 3
2782: PPUSH
2783: LD_EXP 7
2787: PPUSH
2788: CALL 7760 0 2
// if GetBuilding ( 3 , b_factory ) then
2792: LD_INT 3
2794: PPUSH
2795: LD_INT 3
2797: PPUSH
2798: CALL 6155 0 2
2802: IFFALSE 3072
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2804: LD_INT 3
2806: PPUSH
2807: LD_INT 3
2809: PPUSH
2810: CALL 6155 0 2
2814: PUSH
2815: LD_INT 1
2817: ARRAY
2818: PPUSH
2819: CALL_OW 461
2823: PUSH
2824: LD_INT 2
2826: EQUAL
2827: IFFALSE 3072
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2829: LD_ADDR_VAR 0 7
2833: PUSH
2834: LD_INT 3
2836: PPUSH
2837: LD_INT 3
2839: PPUSH
2840: CALL 6155 0 2
2844: PUSH
2845: LD_INT 1
2847: ARRAY
2848: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2849: LD_INT 3
2851: PPUSH
2852: LD_INT 24
2854: PPUSH
2855: LD_INT 53
2857: PPUSH
2858: CALL 7908 0 3
2862: PUSH
2863: LD_INT 0
2865: EQUAL
2866: PUSH
2867: LD_EXP 17
2871: AND
2872: IFFALSE 2895
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2874: LD_VAR 0 7
2878: PPUSH
2879: LD_INT 24
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 53
2890: PPUSH
2891: CALL 8030 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2895: LD_INT 3
2897: PPUSH
2898: LD_INT 22
2900: PPUSH
2901: LD_INT 52
2903: PPUSH
2904: CALL 7908 0 3
2908: PUSH
2909: LD_INT 0
2911: EQUAL
2912: PUSH
2913: LD_EXP 18
2917: AND
2918: IFFALSE 2941
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2920: LD_VAR 0 7
2924: PPUSH
2925: LD_INT 22
2927: PPUSH
2928: LD_INT 1
2930: PPUSH
2931: LD_INT 3
2933: PPUSH
2934: LD_INT 52
2936: PPUSH
2937: CALL 8030 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2941: LD_INT 3
2943: PPUSH
2944: LD_INT 22
2946: PPUSH
2947: LD_INT 49
2949: PPUSH
2950: CALL 7908 0 3
2954: PUSH
2955: LD_INT 4
2957: LESS
2958: PUSH
2959: LD_INT 31
2961: PPUSH
2962: LD_INT 3
2964: PPUSH
2965: CALL_OW 321
2969: PUSH
2970: LD_INT 2
2972: EQUAL
2973: AND
2974: IFFALSE 2997
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
2976: LD_VAR 0 7
2980: PPUSH
2981: LD_INT 22
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: LD_INT 3
2989: PPUSH
2990: LD_INT 49
2992: PPUSH
2993: CALL 8030 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
2997: LD_EXP 8
3001: PUSH
3002: LD_INT 5
3004: PUSH
3005: LD_INT 6
3007: PUSH
3008: LD_INT 7
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_OWVAR 67
3020: ARRAY
3021: LESS
3022: IFFALSE 3072
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3024: LD_VAR 0 7
3028: PPUSH
3029: LD_INT 24
3031: PPUSH
3032: LD_INT 1
3034: PPUSH
3035: LD_INT 3
3037: PPUSH
3038: LD_INT 46
3040: PUSH
3041: LD_INT 45
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 46
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: LIST
3055: PUSH
3056: LD_INT 1
3058: PPUSH
3059: LD_INT 4
3061: PPUSH
3062: CALL_OW 12
3066: ARRAY
3067: PPUSH
3068: CALL 8030 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3072: LD_INT 3
3074: PPUSH
3075: CALL 6064 0 1
3079: PPUSH
3080: CALL 5756 0 1
3084: PUSH
3085: LD_INT 1
3087: ARRAY
3088: PUSH
3089: LD_INT 250
3091: GREATER
3092: PUSH
3093: LD_INT 3
3095: PPUSH
3096: CALL 6064 0 1
3100: PPUSH
3101: CALL 5756 0 1
3105: PUSH
3106: LD_INT 3
3108: ARRAY
3109: PUSH
3110: LD_INT 50
3112: GREATER
3113: AND
3114: PUSH
3115: LD_INT 23
3117: PPUSH
3118: LD_INT 3
3120: PPUSH
3121: CALL_OW 321
3125: PUSH
3126: LD_INT 2
3128: EQUAL
3129: AND
3130: PUSH
3131: LD_INT 3
3133: PPUSH
3134: CALL 11384 0 1
3138: PUSH
3139: LD_INT 0
3141: EQUAL
3142: AND
3143: PUSH
3144: LD_INT 22
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: PUSH
3154: LD_INT 34
3156: PUSH
3157: LD_INT 49
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: PUSH
3173: LD_INT 3
3175: GREATER
3176: AND
3177: PUSH
3178: LD_OWVAR 2
3182: PPUSH
3183: LD_INT 51
3185: PPUSH
3186: LD_INT 42
3188: PPUSH
3189: CALL 5383 0 3
3193: PUSH
3194: LD_INT 0
3196: EQUAL
3197: AND
3198: IFFALSE 3283
// begin for i = 1 to ru_mech do
3200: LD_ADDR_VAR 0 1
3204: PUSH
3205: DOUBLE
3206: LD_INT 1
3208: DEC
3209: ST_TO_ADDR
3210: LD_EXP 21
3214: PUSH
3215: FOR_TO
3216: IFFALSE 3281
// begin if IsInUnit ( ru_mech [ i ] ) then
3218: LD_EXP 21
3222: PUSH
3223: LD_VAR 0 1
3227: ARRAY
3228: PPUSH
3229: CALL_OW 310
3233: IFFALSE 3252
// ComExitBuilding ( ru_mech [ i ] ) else
3235: LD_EXP 21
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 122
3250: GO 3279
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3252: LD_EXP 21
3256: PUSH
3257: LD_VAR 0 1
3261: ARRAY
3262: PPUSH
3263: LD_INT 37
3265: PPUSH
3266: LD_INT 51
3268: PPUSH
3269: LD_INT 43
3271: PPUSH
3272: LD_INT 0
3274: PPUSH
3275: CALL_OW 170
// end ;
3279: GO 3215
3281: POP
3282: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3283: LD_OWVAR 1
3287: PUSH
3288: LD_INT 94500
3290: PUSH
3291: LD_INT 84000
3293: PUSH
3294: LD_INT 71400
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: PUSH
3302: LD_OWVAR 67
3306: ARRAY
3307: GREATEREQUAL
3308: IFFALSE 3364
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3310: LD_OWVAR 1
3314: PUSH
3315: LD_INT 18900
3317: PUSH
3318: LD_INT 16800
3320: PUSH
3321: LD_INT 14700
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: MOD
3335: PUSH
3336: LD_INT 0
3338: EQUAL
3339: IFFALSE 3364
// if ru_reserve then
3341: LD_EXP 8
3345: IFFALSE 3364
// begin ru_attack_list := ru_reserve ;
3347: LD_ADDR_EXP 9
3351: PUSH
3352: LD_EXP 8
3356: ST_TO_ADDR
// ru_reserve := [ ] ;
3357: LD_ADDR_EXP 8
3361: PUSH
3362: EMPTY
3363: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3364: LD_EXP 9
3368: IFFALSE 3490
// begin for i = 1 to ru_attack_list do
3370: LD_ADDR_VAR 0 1
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_EXP 9
3384: PUSH
3385: FOR_TO
3386: IFFALSE 3488
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3388: LD_EXP 9
3392: PUSH
3393: LD_VAR 0 1
3397: ARRAY
3398: PPUSH
3399: CALL_OW 256
3403: PUSH
3404: LD_INT 250
3406: GREATEREQUAL
3407: PUSH
3408: LD_EXP 9
3412: PUSH
3413: LD_VAR 0 1
3417: ARRAY
3418: PPUSH
3419: CALL_OW 314
3423: NOT
3424: AND
3425: IFFALSE 3486
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3427: LD_EXP 9
3431: PUSH
3432: LD_VAR 0 1
3436: ARRAY
3437: PPUSH
3438: LD_INT 81
3440: PUSH
3441: LD_EXP 9
3445: PUSH
3446: LD_VAR 0 1
3450: ARRAY
3451: PPUSH
3452: CALL_OW 255
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: PPUSH
3466: LD_EXP 9
3470: PUSH
3471: LD_VAR 0 1
3475: ARRAY
3476: PPUSH
3477: CALL_OW 74
3481: PPUSH
3482: CALL_OW 115
3486: GO 3385
3488: POP
3489: POP
// end ; if GetBehemoth ( 3 ) then
3490: LD_INT 3
3492: PPUSH
3493: CALL 11384 0 1
3497: IFFALSE 3791
// begin if ru_mech >= 4 then
3499: LD_EXP 21
3503: PUSH
3504: LD_INT 4
3506: GREATEREQUAL
3507: IFFALSE 3558
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3509: LD_ADDR_EXP 14
3513: PUSH
3514: LD_EXP 21
3518: PUSH
3519: LD_INT 1
3521: ARRAY
3522: PUSH
3523: LD_EXP 21
3527: PUSH
3528: LD_INT 2
3530: ARRAY
3531: PUSH
3532: LD_EXP 21
3536: PUSH
3537: LD_INT 3
3539: ARRAY
3540: PUSH
3541: LD_EXP 21
3545: PUSH
3546: LD_INT 4
3548: ARRAY
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: ST_TO_ADDR
3556: GO 3568
// ru_behemoth_mechanic := ru_mech ;
3558: LD_ADDR_EXP 14
3562: PUSH
3563: LD_EXP 21
3567: ST_TO_ADDR
// for i = 1 to ru_mech do
3568: LD_ADDR_VAR 0 1
3572: PUSH
3573: DOUBLE
3574: LD_INT 1
3576: DEC
3577: ST_TO_ADDR
3578: LD_EXP 21
3582: PUSH
3583: FOR_TO
3584: IFFALSE 3638
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3586: LD_EXP 21
3590: PUSH
3591: LD_VAR 0 1
3595: ARRAY
3596: PPUSH
3597: CALL_OW 310
3601: PUSH
3602: LD_EXP 21
3606: PUSH
3607: LD_VAR 0 1
3611: ARRAY
3612: PUSH
3613: LD_EXP 14
3617: IN
3618: AND
3619: IFFALSE 3636
// ComExitBuilding ( ru_mech [ i ] ) ;
3621: LD_EXP 21
3625: PUSH
3626: LD_VAR 0 1
3630: ARRAY
3631: PPUSH
3632: CALL_OW 122
3636: GO 3583
3638: POP
3639: POP
// if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3640: LD_INT 12
3642: PPUSH
3643: LD_INT 22
3645: PUSH
3646: LD_INT 1
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: LD_INT 21
3655: PUSH
3656: LD_INT 3
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PPUSH
3667: CALL_OW 70
3671: PUSH
3672: LD_INT 0
3674: GREATER
3675: IFFALSE 3735
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3677: LD_INT 3
3679: PPUSH
3680: CALL 11384 0 1
3684: PUSH
3685: LD_INT 1
3687: ARRAY
3688: PPUSH
3689: LD_INT 21
3691: PUSH
3692: LD_INT 2
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 34
3701: PUSH
3702: LD_INT 49
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PPUSH
3713: CALL_OW 69
3717: PPUSH
3718: LD_EXP 14
3722: PPUSH
3723: LD_INT 97
3725: PPUSH
3726: LD_INT 9
3728: PPUSH
3729: CALL 10881 0 5
3733: GO 3791
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3735: LD_INT 3
3737: PPUSH
3738: CALL 11384 0 1
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: PPUSH
3747: LD_INT 21
3749: PUSH
3750: LD_INT 2
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 34
3759: PUSH
3760: LD_INT 49
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: PPUSH
3771: CALL_OW 69
3775: PPUSH
3776: LD_EXP 14
3780: PPUSH
3781: LD_INT 153
3783: PPUSH
3784: LD_INT 102
3786: PPUSH
3787: CALL 10881 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3791: LD_EXP 23
3795: PUSH
3796: LD_INT 0
3798: EQUAL
3799: PUSH
3800: LD_INT 44
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 321
3810: PUSH
3811: LD_INT 2
3813: EQUAL
3814: AND
3815: IFFALSE 3826
// ComChangeClassToBazooker ( ru_sold ) ;
3817: LD_EXP 19
3821: PPUSH
3822: CALL 9818 0 1
// if ru_bazz then
3826: LD_EXP 23
3830: IFFALSE 3844
// IntBazooka ( ru_bazz , 1 ) ;
3832: LD_EXP 23
3836: PPUSH
3837: LD_INT 1
3839: PPUSH
3840: CALL 9537 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3844: LD_INT 67
3846: PPUSH
3847: LD_INT 39
3849: PPUSH
3850: LD_INT 3
3852: PPUSH
3853: CALL_OW 440
3857: PUSH
3858: LD_INT 0
3860: EQUAL
3861: PUSH
3862: LD_INT 20
3864: PPUSH
3865: LD_INT 3
3867: PPUSH
3868: CALL_OW 321
3872: PUSH
3873: LD_INT 2
3875: EQUAL
3876: AND
3877: IFFALSE 3898
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3879: LD_EXP 22
3883: PUSH
3884: LD_INT 1
3886: ARRAY
3887: PPUSH
3888: LD_INT 67
3890: PPUSH
3891: LD_INT 39
3893: PPUSH
3894: CALL 9012 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3898: LD_INT 89
3900: PPUSH
3901: LD_INT 66
3903: PPUSH
3904: LD_INT 3
3906: PPUSH
3907: CALL_OW 440
3911: PUSH
3912: LD_INT 0
3914: EQUAL
3915: IFFALSE 3936
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
3917: LD_EXP 22
3921: PUSH
3922: LD_INT 1
3924: ARRAY
3925: PPUSH
3926: LD_INT 87
3928: PPUSH
3929: LD_INT 60
3931: PPUSH
3932: CALL 9012 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3936: LD_INT 104
3938: PPUSH
3939: LD_INT 94
3941: PPUSH
3942: LD_INT 3
3944: PPUSH
3945: CALL_OW 440
3949: PUSH
3950: LD_INT 0
3952: EQUAL
3953: PUSH
3954: LD_INT 20
3956: PPUSH
3957: LD_INT 3
3959: PPUSH
3960: CALL_OW 321
3964: PUSH
3965: LD_INT 2
3967: EQUAL
3968: AND
3969: IFFALSE 3990
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
3971: LD_EXP 22
3975: PUSH
3976: LD_INT 1
3978: ARRAY
3979: PPUSH
3980: LD_INT 104
3982: PPUSH
3983: LD_INT 94
3985: PPUSH
3986: CALL 9012 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
3990: LD_INT 3
3992: PPUSH
3993: LD_INT 24
3995: PPUSH
3996: LD_INT 53
3998: PPUSH
3999: CALL 7908 0 3
4003: PUSH
4004: LD_INT 1
4006: EQUAL
4007: PUSH
4008: LD_EXP 17
4012: AND
4013: IFFALSE 4154
// begin need_buldozer := false ;
4015: LD_ADDR_EXP 17
4019: PUSH
4020: LD_INT 0
4022: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4023: LD_INT 3
4025: PPUSH
4026: LD_INT 24
4028: PPUSH
4029: LD_INT 53
4031: PPUSH
4032: CALL 7908 0 3
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 39
4046: PPUSH
4047: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 24
4056: PPUSH
4057: LD_INT 53
4059: PPUSH
4060: CALL 7908 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: LD_INT 71
4071: PPUSH
4072: LD_INT 10
4074: PPUSH
4075: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4079: LD_INT 3
4081: PPUSH
4082: LD_INT 24
4084: PPUSH
4085: LD_INT 53
4087: PPUSH
4088: CALL 7908 0 3
4092: PUSH
4093: LD_INT 1
4095: ARRAY
4096: PPUSH
4097: LD_INT 15
4099: PPUSH
4100: CALL 5497 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4104: LD_INT 3
4106: PPUSH
4107: LD_INT 24
4109: PPUSH
4110: LD_INT 53
4112: PPUSH
4113: CALL 7908 0 3
4117: PUSH
4118: LD_INT 1
4120: ARRAY
4121: PPUSH
4122: LD_INT 350
4124: PPUSH
4125: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4129: LD_INT 3
4131: PPUSH
4132: LD_INT 24
4134: PPUSH
4135: LD_INT 53
4137: PPUSH
4138: CALL 7908 0 3
4142: PUSH
4143: LD_INT 1
4145: ARRAY
4146: PPUSH
4147: LD_INT 14
4149: PPUSH
4150: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4154: LD_INT 67
4156: PPUSH
4157: LD_INT 39
4159: PPUSH
4160: LD_INT 3
4162: PPUSH
4163: CALL_OW 440
4167: PUSH
4168: LD_INT 67
4170: PPUSH
4171: LD_INT 39
4173: PPUSH
4174: CALL_OW 428
4178: PUSH
4179: LD_INT 0
4181: EQUAL
4182: AND
4183: PUSH
4184: LD_INT 79
4186: PPUSH
4187: LD_INT 45
4189: PPUSH
4190: CALL_OW 428
4194: PPUSH
4195: CALL_OW 266
4199: PUSH
4200: LD_INT 0
4202: EQUAL
4203: AND
4204: PUSH
4205: LD_INT 1
4207: PPUSH
4208: LD_INT 79
4210: PPUSH
4211: LD_INT 45
4213: PPUSH
4214: CALL 5383 0 3
4218: PUSH
4219: LD_INT 0
4221: EQUAL
4222: AND
4223: IFFALSE 4326
// begin for i = 1 to ru_eng do
4225: LD_ADDR_VAR 0 1
4229: PUSH
4230: DOUBLE
4231: LD_INT 1
4233: DEC
4234: ST_TO_ADDR
4235: LD_EXP 20
4239: PUSH
4240: FOR_TO
4241: IFFALSE 4324
// if IsInUnit ( ru_eng [ i ] ) then
4243: LD_EXP 20
4247: PUSH
4248: LD_VAR 0 1
4252: ARRAY
4253: PPUSH
4254: CALL_OW 310
4258: IFFALSE 4277
// ComExitBuilding ( ru_eng [ i ] ) else
4260: LD_EXP 20
4264: PUSH
4265: LD_VAR 0 1
4269: ARRAY
4270: PPUSH
4271: CALL_OW 122
4275: GO 4322
// if not HasTask ( ru_eng [ i ] ) then
4277: LD_EXP 20
4281: PUSH
4282: LD_VAR 0 1
4286: ARRAY
4287: PPUSH
4288: CALL_OW 314
4292: NOT
4293: IFFALSE 4322
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4295: LD_EXP 20
4299: PUSH
4300: LD_VAR 0 1
4304: ARRAY
4305: PPUSH
4306: LD_INT 30
4308: PPUSH
4309: LD_INT 67
4311: PPUSH
4312: LD_INT 39
4314: PPUSH
4315: LD_INT 3
4317: PPUSH
4318: CALL_OW 145
4322: GO 4240
4324: POP
4325: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4326: LD_INT 1
4328: PPUSH
4329: LD_INT 79
4331: PPUSH
4332: LD_INT 45
4334: PPUSH
4335: CALL 5383 0 3
4339: PUSH
4340: LD_INT 0
4342: EQUAL
4343: IFFALSE 4539
// begin if HexInfo ( 79 , 45 ) = 0 then
4345: LD_INT 79
4347: PPUSH
4348: LD_INT 45
4350: PPUSH
4351: CALL_OW 428
4355: PUSH
4356: LD_INT 0
4358: EQUAL
4359: IFFALSE 4381
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4361: LD_EXP 20
4365: PPUSH
4366: LD_INT 79
4368: PPUSH
4369: LD_INT 45
4371: PPUSH
4372: LD_INT 3
4374: PPUSH
4375: CALL 6923 0 4
4379: GO 4539
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4381: LD_INT 89
4383: PPUSH
4384: LD_INT 66
4386: PPUSH
4387: CALL_OW 428
4391: PUSH
4392: LD_INT 0
4394: EQUAL
4395: PUSH
4396: LD_INT 89
4398: PPUSH
4399: LD_INT 66
4401: PPUSH
4402: LD_INT 3
4404: PPUSH
4405: CALL_OW 440
4409: AND
4410: IFFALSE 4539
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4412: LD_INT 79
4414: PPUSH
4415: LD_INT 45
4417: PPUSH
4418: CALL_OW 428
4422: PPUSH
4423: CALL_OW 274
4427: PPUSH
4428: LD_INT 1
4430: PPUSH
4431: LD_INT 100
4433: PPUSH
4434: CALL_OW 277
// for i = 1 to ru_eng do
4438: LD_ADDR_VAR 0 1
4442: PUSH
4443: DOUBLE
4444: LD_INT 1
4446: DEC
4447: ST_TO_ADDR
4448: LD_EXP 20
4452: PUSH
4453: FOR_TO
4454: IFFALSE 4537
// if IsInUnit ( ru_eng [ i ] ) then
4456: LD_EXP 20
4460: PUSH
4461: LD_VAR 0 1
4465: ARRAY
4466: PPUSH
4467: CALL_OW 310
4471: IFFALSE 4490
// ComExitBuilding ( ru_eng [ i ] ) else
4473: LD_EXP 20
4477: PUSH
4478: LD_VAR 0 1
4482: ARRAY
4483: PPUSH
4484: CALL_OW 122
4488: GO 4535
// if not HasTask ( ru_eng [ i ] ) then
4490: LD_EXP 20
4494: PUSH
4495: LD_VAR 0 1
4499: ARRAY
4500: PPUSH
4501: CALL_OW 314
4505: NOT
4506: IFFALSE 4535
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4508: LD_EXP 20
4512: PUSH
4513: LD_VAR 0 1
4517: ARRAY
4518: PPUSH
4519: LD_INT 29
4521: PPUSH
4522: LD_INT 89
4524: PPUSH
4525: LD_INT 66
4527: PPUSH
4528: LD_INT 3
4530: PPUSH
4531: CALL_OW 145
4535: GO 4453
4537: POP
4538: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4539: LD_INT 3
4541: PPUSH
4542: LD_INT 29
4544: PPUSH
4545: CALL 6155 0 2
4549: PUSH
4550: LD_INT 0
4552: EQUAL
4553: PUSH
4554: LD_INT 1
4556: PPUSH
4557: LD_INT 36
4559: PPUSH
4560: LD_INT 6
4562: PPUSH
4563: CALL 5383 0 3
4567: PUSH
4568: LD_INT 0
4570: EQUAL
4571: AND
4572: PUSH
4573: LD_INT 3
4575: PPUSH
4576: CALL 6064 0 1
4580: PPUSH
4581: LD_INT 29
4583: PPUSH
4584: CALL 5640 0 2
4588: AND
4589: IFFALSE 4692
// begin for i = 1 to ru_eng do
4591: LD_ADDR_VAR 0 1
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_EXP 20
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4690
// begin if IsInUnit ( ru_eng [ i ] ) then
4609: LD_EXP 20
4613: PUSH
4614: LD_VAR 0 1
4618: ARRAY
4619: PPUSH
4620: CALL_OW 310
4624: IFFALSE 4643
// ComExitBuilding ( ru_eng [ i ] ) else
4626: LD_EXP 20
4630: PUSH
4631: LD_VAR 0 1
4635: ARRAY
4636: PPUSH
4637: CALL_OW 122
4641: GO 4688
// if not HasTask ( ru_eng [ i ] ) then
4643: LD_EXP 20
4647: PUSH
4648: LD_VAR 0 1
4652: ARRAY
4653: PPUSH
4654: CALL_OW 314
4658: NOT
4659: IFFALSE 4688
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4661: LD_EXP 20
4665: PUSH
4666: LD_VAR 0 1
4670: ARRAY
4671: PPUSH
4672: LD_INT 29
4674: PPUSH
4675: LD_INT 33
4677: PPUSH
4678: LD_INT 4
4680: PPUSH
4681: LD_INT 0
4683: PPUSH
4684: CALL_OW 205
// end ; end ;
4688: GO 4606
4690: POP
4691: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4692: LD_EXP 20
4696: PUSH
4697: LD_INT 79
4699: PPUSH
4700: LD_INT 45
4702: PPUSH
4703: CALL_OW 428
4707: PUSH
4708: LD_INT 0
4710: GREATER
4711: AND
4712: PUSH
4713: LD_INT 79
4715: PPUSH
4716: LD_INT 45
4718: PPUSH
4719: CALL_OW 428
4723: PPUSH
4724: CALL_OW 266
4728: PUSH
4729: LD_INT 0
4731: EQUAL
4732: AND
4733: IFFALSE 4893
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4735: LD_INT 79
4737: PPUSH
4738: LD_INT 45
4740: PPUSH
4741: CALL_OW 428
4745: PPUSH
4746: CALL_OW 255
4750: PUSH
4751: LD_INT 3
4753: EQUAL
4754: PUSH
4755: LD_INT 1
4757: PPUSH
4758: LD_INT 79
4760: PPUSH
4761: LD_INT 45
4763: PPUSH
4764: CALL 5383 0 3
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: AND
4773: PUSH
4774: LD_INT 79
4776: PPUSH
4777: LD_INT 45
4779: PPUSH
4780: CALL_OW 428
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 3
4792: PPUSH
4793: CALL_OW 275
4797: PUSH
4798: LD_INT 10
4800: GREATEREQUAL
4801: AND
4802: IFFALSE 4893
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4804: LD_EXP 20
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: CALL_OW 310
4817: IFFALSE 4834
// ComExitBuilding ( ru_eng [ 1 ] ) else
4819: LD_EXP 20
4823: PUSH
4824: LD_INT 1
4826: ARRAY
4827: PPUSH
4828: CALL_OW 122
4832: GO 4893
// if not HasTask ( ru_eng [ 1 ] ) then
4834: LD_EXP 20
4838: PUSH
4839: LD_INT 1
4841: ARRAY
4842: PPUSH
4843: CALL_OW 314
4847: NOT
4848: IFFALSE 4893
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4850: LD_EXP 20
4854: PUSH
4855: LD_INT 1
4857: ARRAY
4858: PPUSH
4859: LD_INT 79
4861: PPUSH
4862: LD_INT 45
4864: PPUSH
4865: CALL_OW 428
4869: PPUSH
4870: LD_INT 3
4872: PPUSH
4873: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4877: LD_EXP 20
4881: PUSH
4882: LD_INT 1
4884: ARRAY
4885: PPUSH
4886: LD_INT 2
4888: PPUSH
4889: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4893: LD_EXP 20
4897: PUSH
4898: LD_INT 2
4900: GREATER
4901: PUSH
4902: LD_INT 79
4904: PPUSH
4905: LD_INT 45
4907: PPUSH
4908: CALL_OW 428
4912: PUSH
4913: LD_INT 0
4915: GREATER
4916: AND
4917: PUSH
4918: LD_INT 79
4920: PPUSH
4921: LD_INT 45
4923: PPUSH
4924: CALL_OW 428
4928: PPUSH
4929: CALL_OW 266
4933: PUSH
4934: LD_INT 0
4936: EQUAL
4937: AND
4938: IFFALSE 5098
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
4940: LD_INT 79
4942: PPUSH
4943: LD_INT 45
4945: PPUSH
4946: CALL_OW 428
4950: PPUSH
4951: CALL_OW 255
4955: PUSH
4956: LD_INT 3
4958: EQUAL
4959: PUSH
4960: LD_INT 1
4962: PPUSH
4963: LD_INT 79
4965: PPUSH
4966: LD_INT 45
4968: PPUSH
4969: CALL 5383 0 3
4973: PUSH
4974: LD_INT 0
4976: EQUAL
4977: AND
4978: PUSH
4979: LD_INT 79
4981: PPUSH
4982: LD_INT 45
4984: PPUSH
4985: CALL_OW 428
4989: PPUSH
4990: CALL_OW 274
4994: PPUSH
4995: LD_INT 1
4997: PPUSH
4998: CALL_OW 275
5002: PUSH
5003: LD_INT 20
5005: GREATER
5006: AND
5007: IFFALSE 5098
// begin if IsInUnit ( ru_eng [ 2 ] ) then
5009: LD_EXP 20
5013: PUSH
5014: LD_INT 2
5016: ARRAY
5017: PPUSH
5018: CALL_OW 310
5022: IFFALSE 5039
// ComExitBuilding ( ru_eng [ 2 ] ) else
5024: LD_EXP 20
5028: PUSH
5029: LD_INT 2
5031: ARRAY
5032: PPUSH
5033: CALL_OW 122
5037: GO 5098
// if not HasTask ( ru_eng [ 2 ] ) then
5039: LD_EXP 20
5043: PUSH
5044: LD_INT 2
5046: ARRAY
5047: PPUSH
5048: CALL_OW 314
5052: NOT
5053: IFFALSE 5098
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5055: LD_EXP 20
5059: PUSH
5060: LD_INT 2
5062: ARRAY
5063: PPUSH
5064: LD_INT 79
5066: PPUSH
5067: LD_INT 45
5069: PPUSH
5070: CALL_OW 428
5074: PPUSH
5075: LD_INT 1
5077: PPUSH
5078: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5082: LD_EXP 20
5086: PUSH
5087: LD_INT 2
5089: ARRAY
5090: PPUSH
5091: LD_INT 2
5093: PPUSH
5094: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5098: LD_INT 1
5100: PPUSH
5101: LD_INT 59
5103: PPUSH
5104: LD_INT 60
5106: PPUSH
5107: CALL 5383 0 3
5111: PUSH
5112: LD_INT 0
5114: EQUAL
5115: PUSH
5116: LD_INT 1
5118: PPUSH
5119: LD_INT 67
5121: PPUSH
5122: LD_INT 76
5124: PPUSH
5125: CALL 5383 0 3
5129: PUSH
5130: LD_INT 0
5132: EQUAL
5133: AND
5134: PUSH
5135: LD_INT 1
5137: PPUSH
5138: LD_INT 79
5140: PPUSH
5141: LD_INT 100
5143: PPUSH
5144: CALL 5383 0 3
5148: PUSH
5149: LD_INT 0
5151: EQUAL
5152: AND
5153: IFFALSE 5165
// CollectCrates ( 3 , west_crates ) ;
5155: LD_INT 3
5157: PPUSH
5158: LD_INT 13
5160: PPUSH
5161: CALL 11428 0 2
// end ;
5165: PPOPN 10
5167: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5168: LD_OWVAR 1
5172: PUSH
5173: LD_INT 111300
5175: LESSEQUAL
5176: PUSH
5177: LD_EXP 29
5181: NOT
5182: OR
5183: IFFALSE 5380
5185: GO 5187
5187: DISABLE
5188: LD_INT 0
5190: PPUSH
// begin enable ;
5191: ENABLE
// uc_nation := 3 ;
5192: LD_ADDR_OWVAR 21
5196: PUSH
5197: LD_INT 3
5199: ST_TO_ADDR
// uc_side := 3 ;
5200: LD_ADDR_OWVAR 20
5204: PUSH
5205: LD_INT 3
5207: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5208: LD_ADDR_OWVAR 37
5212: PUSH
5213: LD_INT 22
5215: ST_TO_ADDR
// vc_engine := engine_siberite ;
5216: LD_ADDR_OWVAR 39
5220: PUSH
5221: LD_INT 3
5223: ST_TO_ADDR
// vc_control := control_computer ;
5224: LD_ADDR_OWVAR 38
5228: PUSH
5229: LD_INT 3
5231: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5232: LD_ADDR_OWVAR 40
5236: PUSH
5237: LD_INT 51
5239: ST_TO_ADDR
// veh := CreateVehicle ;
5240: LD_ADDR_VAR 0 1
5244: PUSH
5245: CALL_OW 45
5249: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5250: LD_VAR 0 1
5254: PPUSH
5255: LD_INT 4
5257: PPUSH
5258: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5262: LD_VAR 0 1
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: LD_INT 0
5272: PPUSH
5273: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5277: LD_VAR 0 1
5281: PPUSH
5282: LD_INT 1
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: LD_INT 3
5290: PUSH
5291: LD_INT 2
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: PUSH
5300: LD_INT 1
5302: PPUSH
5303: LD_INT 4
5305: PPUSH
5306: CALL_OW 12
5310: ARRAY
5311: PPUSH
5312: LD_INT 100
5314: PPUSH
5315: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5319: LD_VAR 0 1
5323: PPUSH
5324: LD_INT 2
5326: PPUSH
5327: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5331: LD_VAR 0 1
5335: PPUSH
5336: LD_INT 10
5338: PPUSH
5339: CALL_OW 173
// Wait ( 0 0$10 ) ;
5343: LD_INT 350
5345: PPUSH
5346: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5357: LD_VAR 0 1
5361: PPUSH
5362: LD_INT 10
5364: PPUSH
5365: CALL_OW 308
5369: IFFALSE 5350
// RemoveUnit ( veh ) ;
5371: LD_VAR 0 1
5375: PPUSH
5376: CALL_OW 64
// end ; end_of_file
5380: PPOPN 1
5382: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
5383: LD_INT 0
5385: PPUSH
5386: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
5387: LD_ADDR_VAR 0 5
5391: PUSH
5392: LD_INT 22
5394: PUSH
5395: LD_VAR 0 1
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: PPUSH
5404: CALL_OW 69
5408: PPUSH
5409: LD_VAR 0 2
5413: PPUSH
5414: LD_VAR 0 3
5418: PPUSH
5419: CALL_OW 73
5423: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 then
5424: LD_VAR 0 5
5428: PPUSH
5429: LD_VAR 0 2
5433: PPUSH
5434: LD_VAR 0 3
5438: PPUSH
5439: CALL_OW 297
5443: PUSH
5444: LD_INT 17
5446: LESS
5447: PUSH
5448: LD_INT 2
5450: PPUSH
5451: LD_INT 22
5453: PUSH
5454: LD_VAR 0 1
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL_OW 70
5467: PUSH
5468: LD_INT 0
5470: GREATER
5471: OR
5472: IFFALSE 5484
// result := true else
5474: LD_ADDR_VAR 0 4
5478: PUSH
5479: LD_INT 1
5481: ST_TO_ADDR
5482: GO 5492
// result := false ;
5484: LD_ADDR_VAR 0 4
5488: PUSH
5489: LD_INT 0
5491: ST_TO_ADDR
// end ;
5492: LD_VAR 0 4
5496: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
5497: LD_INT 0
5499: PPUSH
5500: PPUSH
// area = ListEnvironmentArea ( area ) ;
5501: LD_ADDR_VAR 0 2
5505: PUSH
5506: LD_VAR 0 2
5510: PPUSH
5511: CALL_OW 353
5515: ST_TO_ADDR
// if bulldozer > 0 then
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 0
5523: GREATER
5524: IFFALSE 5635
// for i = 1 to area do
5526: LD_ADDR_VAR 0 4
5530: PUSH
5531: DOUBLE
5532: LD_INT 1
5534: DEC
5535: ST_TO_ADDR
5536: LD_VAR 0 2
5540: PUSH
5541: FOR_TO
5542: IFFALSE 5633
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
5544: LD_VAR 0 2
5548: PUSH
5549: LD_VAR 0 4
5553: ARRAY
5554: PUSH
5555: LD_INT 1
5557: ARRAY
5558: PPUSH
5559: LD_VAR 0 2
5563: PUSH
5564: LD_VAR 0 4
5568: ARRAY
5569: PUSH
5570: LD_INT 2
5572: ARRAY
5573: PPUSH
5574: CALL_OW 351
5578: IFFALSE 5631
// if not HasTask ( bulldozer ) then
5580: LD_VAR 0 1
5584: PPUSH
5585: CALL_OW 314
5589: NOT
5590: IFFALSE 5631
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
5592: LD_VAR 0 1
5596: PPUSH
5597: LD_VAR 0 2
5601: PUSH
5602: LD_VAR 0 4
5606: ARRAY
5607: PUSH
5608: LD_INT 1
5610: ARRAY
5611: PPUSH
5612: LD_VAR 0 2
5616: PUSH
5617: LD_VAR 0 4
5621: ARRAY
5622: PUSH
5623: LD_INT 2
5625: ARRAY
5626: PPUSH
5627: CALL_OW 171
5631: GO 5541
5633: POP
5634: POP
// end ;
5635: LD_VAR 0 3
5639: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
5640: LD_INT 0
5642: PPUSH
5643: PPUSH
5644: PPUSH
// pom := GetBase ( bdepot ) ;
5645: LD_ADDR_VAR 0 4
5649: PUSH
5650: LD_VAR 0 1
5654: PPUSH
5655: CALL_OW 274
5659: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
5660: LD_ADDR_VAR 0 5
5664: PUSH
5665: LD_VAR 0 2
5669: PPUSH
5670: LD_VAR 0 1
5674: PPUSH
5675: CALL_OW 248
5679: PPUSH
5680: CALL_OW 450
5684: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
5685: LD_VAR 0 4
5689: PPUSH
5690: LD_INT 1
5692: PPUSH
5693: CALL_OW 275
5697: PUSH
5698: LD_VAR 0 5
5702: PUSH
5703: LD_INT 1
5705: ARRAY
5706: GREATEREQUAL
5707: PUSH
5708: LD_VAR 0 4
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 275
5720: PUSH
5721: LD_VAR 0 5
5725: PUSH
5726: LD_INT 3
5728: ARRAY
5729: GREATEREQUAL
5730: AND
5731: IFFALSE 5743
// result := true else
5733: LD_ADDR_VAR 0 3
5737: PUSH
5738: LD_INT 1
5740: ST_TO_ADDR
5741: GO 5751
// result := false ;
5743: LD_ADDR_VAR 0 3
5747: PUSH
5748: LD_INT 0
5750: ST_TO_ADDR
// end ;
5751: LD_VAR 0 3
5755: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
5756: LD_INT 0
5758: PPUSH
5759: PPUSH
5760: PPUSH
// pom := GetBase ( bdepot ) ;
5761: LD_ADDR_VAR 0 3
5765: PUSH
5766: LD_VAR 0 1
5770: PPUSH
5771: CALL_OW 274
5775: ST_TO_ADDR
// sor := [ ] ;
5776: LD_ADDR_VAR 0 4
5780: PUSH
5781: EMPTY
5782: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
5783: LD_ADDR_VAR 0 4
5787: PUSH
5788: LD_VAR 0 4
5792: PUSH
5793: LD_VAR 0 3
5797: PPUSH
5798: LD_INT 1
5800: PPUSH
5801: CALL_OW 275
5805: ADD
5806: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
5807: LD_ADDR_VAR 0 4
5811: PUSH
5812: LD_VAR 0 4
5816: PUSH
5817: LD_VAR 0 3
5821: PPUSH
5822: LD_INT 2
5824: PPUSH
5825: CALL_OW 275
5829: ADD
5830: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
5831: LD_ADDR_VAR 0 4
5835: PUSH
5836: LD_VAR 0 4
5840: PUSH
5841: LD_VAR 0 3
5845: PPUSH
5846: LD_INT 3
5848: PPUSH
5849: CALL_OW 275
5853: ADD
5854: ST_TO_ADDR
// result := sor ;
5855: LD_ADDR_VAR 0 2
5859: PUSH
5860: LD_VAR 0 4
5864: ST_TO_ADDR
// end ;
5865: LD_VAR 0 2
5869: RET
// export function Hex ( x , y ) ; begin
5870: LD_INT 0
5872: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
5873: LD_VAR 0 1
5877: PPUSH
5878: LD_VAR 0 2
5882: PPUSH
5883: CALL_OW 488
5887: PUSH
5888: LD_VAR 0 1
5892: PPUSH
5893: LD_VAR 0 2
5897: PPUSH
5898: CALL_OW 428
5902: PUSH
5903: LD_INT 0
5905: EQUAL
5906: AND
5907: IFFALSE 5919
// result := true else
5909: LD_ADDR_VAR 0 3
5913: PUSH
5914: LD_INT 1
5916: ST_TO_ADDR
5917: GO 5927
// result := false ;
5919: LD_ADDR_VAR 0 3
5923: PUSH
5924: LD_INT 0
5926: ST_TO_ADDR
// end ;
5927: LD_VAR 0 3
5931: RET
// export function NeedBuilding ( side , btype ) ; begin
5932: LD_INT 0
5934: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
5935: LD_INT 22
5937: PUSH
5938: LD_VAR 0 1
5942: PUSH
5943: EMPTY
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 30
5949: PUSH
5950: LD_VAR 0 2
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 3
5961: PUSH
5962: LD_INT 57
5964: PUSH
5965: EMPTY
5966: LIST
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: LIST
5976: PPUSH
5977: CALL_OW 69
5981: PUSH
5982: LD_INT 0
5984: EQUAL
5985: IFFALSE 5997
// result := true else
5987: LD_ADDR_VAR 0 3
5991: PUSH
5992: LD_INT 1
5994: ST_TO_ADDR
5995: GO 6005
// result := false ;
5997: LD_ADDR_VAR 0 3
6001: PUSH
6002: LD_INT 0
6004: ST_TO_ADDR
// end ;
6005: LD_VAR 0 3
6009: RET
// export function NeedBase ( side ) ; begin
6010: LD_INT 0
6012: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6013: LD_VAR 0 1
6017: PPUSH
6018: LD_INT 0
6020: PPUSH
6021: CALL 5932 0 2
6025: PUSH
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 1
6033: PPUSH
6034: CALL 5932 0 2
6038: AND
6039: IFFALSE 6051
// result := true else
6041: LD_ADDR_VAR 0 2
6045: PUSH
6046: LD_INT 1
6048: ST_TO_ADDR
6049: GO 6059
// result := false ;
6051: LD_ADDR_VAR 0 2
6055: PUSH
6056: LD_INT 0
6058: ST_TO_ADDR
// end ;
6059: LD_VAR 0 2
6063: RET
// export function MyBase ( side ) ; begin
6064: LD_INT 0
6066: PPUSH
// if not NeedBase ( side ) then
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL 6010 0 1
6076: NOT
6077: IFFALSE 6142
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6079: LD_ADDR_VAR 0 2
6083: PUSH
6084: LD_INT 22
6086: PUSH
6087: LD_VAR 0 1
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: LD_INT 2
6098: PUSH
6099: LD_INT 30
6101: PUSH
6102: LD_INT 0
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 30
6111: PUSH
6112: LD_INT 1
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: EMPTY
6129: LIST
6130: PPUSH
6131: CALL_OW 69
6135: PUSH
6136: LD_INT 1
6138: ARRAY
6139: ST_TO_ADDR
6140: GO 6150
// result := false ;
6142: LD_ADDR_VAR 0 2
6146: PUSH
6147: LD_INT 0
6149: ST_TO_ADDR
// end ;
6150: LD_VAR 0 2
6154: RET
// export function GetBuilding ( side , btype ) ; begin
6155: LD_INT 0
6157: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6158: LD_INT 22
6160: PUSH
6161: LD_VAR 0 1
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 30
6172: PUSH
6173: LD_VAR 0 2
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PPUSH
6186: CALL_OW 69
6190: PUSH
6191: LD_INT 0
6193: GREATER
6194: IFFALSE 6236
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6196: LD_ADDR_VAR 0 3
6200: PUSH
6201: LD_INT 22
6203: PUSH
6204: LD_VAR 0 1
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PUSH
6213: LD_INT 30
6215: PUSH
6216: LD_VAR 0 2
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: PPUSH
6229: CALL_OW 69
6233: ST_TO_ADDR
6234: GO 6244
// result := false ;
6236: LD_ADDR_VAR 0 3
6240: PUSH
6241: LD_INT 0
6243: ST_TO_ADDR
// end ;
6244: LD_VAR 0 3
6248: RET
// export function GetCrates ( side ) ; begin
6249: LD_INT 0
6251: PPUSH
// if MyBase ( side ) then
6252: LD_VAR 0 1
6256: PPUSH
6257: CALL 6064 0 1
6261: IFFALSE 6293
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
6263: LD_ADDR_VAR 0 2
6267: PUSH
6268: LD_VAR 0 1
6272: PPUSH
6273: CALL 6064 0 1
6277: PPUSH
6278: CALL_OW 274
6282: PPUSH
6283: LD_INT 1
6285: PPUSH
6286: CALL_OW 275
6290: ST_TO_ADDR
6291: GO 6301
// result := false ;
6293: LD_ADDR_VAR 0 2
6297: PUSH
6298: LD_INT 0
6300: ST_TO_ADDR
// end ;
6301: LD_VAR 0 2
6305: RET
// export function GetLabs ( side ) ; begin
6306: LD_INT 0
6308: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6309: LD_ADDR_VAR 0 2
6313: PUSH
6314: LD_INT 22
6316: PUSH
6317: LD_VAR 0 1
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PUSH
6326: LD_INT 2
6328: PUSH
6329: LD_INT 30
6331: PUSH
6332: LD_INT 6
6334: PUSH
6335: EMPTY
6336: LIST
6337: LIST
6338: PUSH
6339: LD_INT 30
6341: PUSH
6342: LD_INT 8
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PUSH
6349: LD_INT 30
6351: PUSH
6352: LD_INT 7
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: PUSH
6369: EMPTY
6370: LIST
6371: PPUSH
6372: CALL_OW 69
6376: ST_TO_ADDR
// end ;
6377: LD_VAR 0 2
6381: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
6382: LD_INT 0
6384: PPUSH
6385: PPUSH
6386: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
6387: LD_ADDR_VAR 0 3
6391: PUSH
6392: LD_VAR 0 1
6396: PPUSH
6397: LD_INT 1
6399: PPUSH
6400: CALL_OW 268
6404: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
6405: LD_ADDR_VAR 0 4
6409: PUSH
6410: LD_VAR 0 1
6414: PPUSH
6415: LD_INT 2
6417: PPUSH
6418: CALL_OW 268
6422: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
6423: LD_ADDR_VAR 0 2
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_VAR 0 4
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: ST_TO_ADDR
// end ;
6442: LD_VAR 0 2
6446: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
6447: LD_INT 0
6449: PPUSH
6450: PPUSH
// result := false ;
6451: LD_ADDR_VAR 0 3
6455: PUSH
6456: LD_INT 0
6458: ST_TO_ADDR
// for i = 1 to tlist do
6459: LD_ADDR_VAR 0 4
6463: PUSH
6464: DOUBLE
6465: LD_INT 1
6467: DEC
6468: ST_TO_ADDR
6469: LD_VAR 0 2
6473: PUSH
6474: FOR_TO
6475: IFFALSE 6515
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6477: LD_VAR 0 2
6481: PUSH
6482: LD_VAR 0 4
6486: ARRAY
6487: PPUSH
6488: LD_VAR 0 1
6492: PPUSH
6493: CALL_OW 321
6497: PUSH
6498: LD_INT 2
6500: NONEQUAL
6501: IFFALSE 6513
// begin result := true ;
6503: LD_ADDR_VAR 0 3
6507: PUSH
6508: LD_INT 1
6510: ST_TO_ADDR
// break ;
6511: GO 6515
// end ;
6513: GO 6474
6515: POP
6516: POP
// end ;
6517: LD_VAR 0 3
6521: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
6522: LD_INT 0
6524: PPUSH
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
6529: PPUSH
6530: PPUSH
6531: PPUSH
// lab := GetLabs ( side ) ;
6532: LD_ADDR_VAR 0 5
6536: PUSH
6537: LD_VAR 0 1
6541: PPUSH
6542: CALL 6306 0 1
6546: ST_TO_ADDR
// tmp := 0 ;
6547: LD_ADDR_VAR 0 7
6551: PUSH
6552: LD_INT 0
6554: ST_TO_ADDR
// list := [ ] ;
6555: LD_ADDR_VAR 0 8
6559: PUSH
6560: EMPTY
6561: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
6562: LD_ADDR_VAR 0 10
6566: PUSH
6567: LD_INT 35
6569: PUSH
6570: LD_INT 45
6572: PUSH
6573: LD_INT 46
6575: PUSH
6576: LD_INT 47
6578: PUSH
6579: LD_INT 1
6581: PUSH
6582: LD_INT 2
6584: PUSH
6585: LD_INT 48
6587: PUSH
6588: LD_INT 49
6590: PUSH
6591: LD_INT 50
6593: PUSH
6594: LD_INT 20
6596: PUSH
6597: EMPTY
6598: LIST
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: LIST
6606: LIST
6607: LIST
6608: ST_TO_ADDR
// for i = 1 to tlist do
6609: LD_ADDR_VAR 0 4
6613: PUSH
6614: DOUBLE
6615: LD_INT 1
6617: DEC
6618: ST_TO_ADDR
6619: LD_VAR 0 2
6623: PUSH
6624: FOR_TO
6625: IFFALSE 6677
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6627: LD_VAR 0 2
6631: PUSH
6632: LD_VAR 0 4
6636: ARRAY
6637: PPUSH
6638: LD_VAR 0 1
6642: PPUSH
6643: CALL_OW 321
6647: PUSH
6648: LD_INT 2
6650: NONEQUAL
6651: IFFALSE 6675
// list := list ^ tlist [ i ] ;
6653: LD_ADDR_VAR 0 8
6657: PUSH
6658: LD_VAR 0 8
6662: PUSH
6663: LD_VAR 0 2
6667: PUSH
6668: LD_VAR 0 4
6672: ARRAY
6673: ADD
6674: ST_TO_ADDR
6675: GO 6624
6677: POP
6678: POP
// if list then
6679: LD_VAR 0 8
6683: IFFALSE 6848
// begin for i = 1 to lab do
6685: LD_ADDR_VAR 0 4
6689: PUSH
6690: DOUBLE
6691: LD_INT 1
6693: DEC
6694: ST_TO_ADDR
6695: LD_VAR 0 5
6699: PUSH
6700: FOR_TO
6701: IFFALSE 6771
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
6703: LD_VAR 0 8
6707: PUSH
6708: LD_INT 1
6710: ARRAY
6711: PUSH
6712: LD_VAR 0 10
6716: IN
6717: PUSH
6718: LD_VAR 0 8
6722: PUSH
6723: LD_INT 1
6725: ARRAY
6726: PPUSH
6727: CALL_OW 481
6731: PUSH
6732: LD_VAR 0 5
6736: PUSH
6737: LD_VAR 0 4
6741: ARRAY
6742: PPUSH
6743: CALL 6382 0 1
6747: IN
6748: OR
6749: IFFALSE 6769
// begin mylab := lab [ i ] ;
6751: LD_ADDR_VAR 0 9
6755: PUSH
6756: LD_VAR 0 5
6760: PUSH
6761: LD_VAR 0 4
6765: ARRAY
6766: ST_TO_ADDR
// break ;
6767: GO 6771
// end ;
6769: GO 6700
6771: POP
6772: POP
// if mylab then
6773: LD_VAR 0 9
6777: IFFALSE 6838
// begin if BuildingStatus ( mylab ) = bs_idle then
6779: LD_VAR 0 9
6783: PPUSH
6784: CALL_OW 461
6788: PUSH
6789: LD_INT 2
6791: EQUAL
6792: IFFALSE 6836
// for i = 1 to list do
6794: LD_ADDR_VAR 0 4
6798: PUSH
6799: DOUBLE
6800: LD_INT 1
6802: DEC
6803: ST_TO_ADDR
6804: LD_VAR 0 8
6808: PUSH
6809: FOR_TO
6810: IFFALSE 6834
// AddComResearch ( mylab , list [ i ] ) ;
6812: LD_VAR 0 9
6816: PPUSH
6817: LD_VAR 0 8
6821: PUSH
6822: LD_VAR 0 4
6826: ARRAY
6827: PPUSH
6828: CALL_OW 184
6832: GO 6809
6834: POP
6835: POP
// end else
6836: GO 6846
// result := false ;
6838: LD_ADDR_VAR 0 3
6842: PUSH
6843: LD_INT 0
6845: ST_TO_ADDR
// end else
6846: GO 6856
// result := false ;
6848: LD_ADDR_VAR 0 3
6852: PUSH
6853: LD_INT 0
6855: ST_TO_ADDR
// end ;
6856: LD_VAR 0 3
6860: RET
// export function GetTowers ( side ) ; begin
6861: LD_INT 0
6863: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
6864: LD_ADDR_VAR 0 2
6868: PUSH
6869: LD_INT 22
6871: PUSH
6872: LD_VAR 0 1
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: PUSH
6881: LD_INT 2
6883: PUSH
6884: LD_INT 30
6886: PUSH
6887: LD_INT 32
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PUSH
6894: LD_INT 30
6896: PUSH
6897: LD_INT 33
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: LIST
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: CALL_OW 69
6917: ST_TO_ADDR
// end ;
6918: LD_VAR 0 2
6922: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
6923: LD_INT 0
6925: PPUSH
6926: PPUSH
// if Hex ( x , y ) then
6927: LD_VAR 0 2
6931: PPUSH
6932: LD_VAR 0 3
6936: PPUSH
6937: CALL 5870 0 2
6941: IFFALSE 7016
// for i = 1 to plist do
6943: LD_ADDR_VAR 0 6
6947: PUSH
6948: DOUBLE
6949: LD_INT 1
6951: DEC
6952: ST_TO_ADDR
6953: LD_VAR 0 1
6957: PUSH
6958: FOR_TO
6959: IFFALSE 7014
// if not HasTask ( plist [ i ] ) then
6961: LD_VAR 0 1
6965: PUSH
6966: LD_VAR 0 6
6970: ARRAY
6971: PPUSH
6972: CALL_OW 314
6976: NOT
6977: IFFALSE 7012
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
6979: LD_VAR 0 1
6983: PUSH
6984: LD_VAR 0 6
6988: ARRAY
6989: PPUSH
6990: LD_INT 0
6992: PPUSH
6993: LD_VAR 0 2
6997: PPUSH
6998: LD_VAR 0 3
7002: PPUSH
7003: LD_VAR 0 4
7007: PPUSH
7008: CALL_OW 145
7012: GO 6958
7014: POP
7015: POP
// end ;
7016: LD_VAR 0 5
7020: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7021: LD_INT 0
7023: PPUSH
7024: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7025: LD_VAR 0 2
7029: PPUSH
7030: CALL_OW 266
7034: PUSH
7035: LD_INT 0
7037: EQUAL
7038: PUSH
7039: LD_VAR 0 2
7043: PPUSH
7044: LD_INT 1
7046: PPUSH
7047: CALL 5640 0 2
7051: AND
7052: PUSH
7053: LD_VAR 0 1
7057: PUSH
7058: LD_INT 1
7060: ARRAY
7061: PPUSH
7062: CALL_OW 255
7066: PPUSH
7067: CALL_OW 345
7071: NOT
7072: AND
7073: IFFALSE 7169
// begin ComUpgrade ( bident ) ;
7075: LD_VAR 0 2
7079: PPUSH
7080: CALL_OW 146
// for i = 1 to plist do
7084: LD_ADDR_VAR 0 4
7088: PUSH
7089: DOUBLE
7090: LD_INT 1
7092: DEC
7093: ST_TO_ADDR
7094: LD_VAR 0 1
7098: PUSH
7099: FOR_TO
7100: IFFALSE 7157
// if not HasTask ( plist [ i ] ) then
7102: LD_VAR 0 1
7106: PUSH
7107: LD_VAR 0 4
7111: ARRAY
7112: PPUSH
7113: CALL_OW 314
7117: NOT
7118: IFFALSE 7155
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7120: LD_VAR 0 1
7124: PUSH
7125: LD_VAR 0 4
7129: ARRAY
7130: PPUSH
7131: LD_VAR 0 2
7135: PPUSH
7136: CALL_OW 250
7140: PPUSH
7141: LD_VAR 0 2
7145: PPUSH
7146: CALL_OW 251
7150: PPUSH
7151: CALL_OW 111
7155: GO 7099
7157: POP
7158: POP
// result := true ;
7159: LD_ADDR_VAR 0 3
7163: PUSH
7164: LD_INT 1
7166: ST_TO_ADDR
// end else
7167: GO 7177
// result := false ;
7169: LD_ADDR_VAR 0 3
7173: PUSH
7174: LD_INT 0
7176: ST_TO_ADDR
// end ;
7177: LD_VAR 0 3
7181: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7182: LD_INT 0
7184: PPUSH
7185: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7186: LD_VAR 0 1
7190: PUSH
7191: LD_INT 1
7193: ARRAY
7194: PPUSH
7195: CALL_OW 255
7199: PPUSH
7200: CALL 6249 0 1
7204: PUSH
7205: LD_INT 20
7207: GREATEREQUAL
7208: PUSH
7209: LD_VAR 0 2
7213: PPUSH
7214: LD_VAR 0 3
7218: PPUSH
7219: CALL 5870 0 2
7223: AND
7224: IFFALSE 7309
// begin for i = 1 to plist do
7226: LD_ADDR_VAR 0 6
7230: PUSH
7231: DOUBLE
7232: LD_INT 1
7234: DEC
7235: ST_TO_ADDR
7236: LD_VAR 0 1
7240: PUSH
7241: FOR_TO
7242: IFFALSE 7297
// if not HasTask ( plist [ i ] ) then
7244: LD_VAR 0 1
7248: PUSH
7249: LD_VAR 0 6
7253: ARRAY
7254: PPUSH
7255: CALL_OW 314
7259: NOT
7260: IFFALSE 7295
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7262: LD_VAR 0 1
7266: PUSH
7267: LD_VAR 0 6
7271: ARRAY
7272: PPUSH
7273: LD_INT 6
7275: PPUSH
7276: LD_VAR 0 2
7280: PPUSH
7281: LD_VAR 0 3
7285: PPUSH
7286: LD_VAR 0 4
7290: PPUSH
7291: CALL_OW 145
7295: GO 7241
7297: POP
7298: POP
// result := true ;
7299: LD_ADDR_VAR 0 5
7303: PUSH
7304: LD_INT 1
7306: ST_TO_ADDR
// end else
7307: GO 7317
// result := false ;
7309: LD_ADDR_VAR 0 5
7313: PUSH
7314: LD_INT 0
7316: ST_TO_ADDR
// end ;
7317: LD_VAR 0 5
7321: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7322: LD_INT 0
7324: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7325: LD_VAR 0 1
7329: PPUSH
7330: LD_INT 1
7332: PPUSH
7333: CALL_OW 268
7337: PUSH
7338: LD_INT 9
7340: EQUAL
7341: PUSH
7342: LD_VAR 0 1
7346: PPUSH
7347: LD_INT 2
7349: PPUSH
7350: CALL_OW 268
7354: PUSH
7355: LD_INT 9
7357: EQUAL
7358: AND
7359: IFFALSE 7456
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7361: LD_VAR 0 1
7365: PPUSH
7366: LD_VAR 0 2
7370: PPUSH
7371: CALL 5640 0 2
7375: PUSH
7376: LD_VAR 0 1
7380: PPUSH
7381: LD_VAR 0 3
7385: PPUSH
7386: CALL 5640 0 2
7390: AND
7391: PUSH
7392: LD_VAR 0 1
7396: PPUSH
7397: CALL_OW 461
7401: PUSH
7402: LD_INT 2
7404: EQUAL
7405: AND
7406: IFFALSE 7446
// begin ComUpgradeLab ( lab , bkind1 ) ;
7408: LD_VAR 0 1
7412: PPUSH
7413: LD_VAR 0 2
7417: PPUSH
7418: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
7422: LD_VAR 0 1
7426: PPUSH
7427: LD_VAR 0 3
7431: PPUSH
7432: CALL_OW 207
// result := true ;
7436: LD_ADDR_VAR 0 4
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// end else
7444: GO 7454
// result := false ;
7446: LD_ADDR_VAR 0 4
7450: PUSH
7451: LD_INT 0
7453: ST_TO_ADDR
// end else
7454: GO 7464
// result := false ;
7456: LD_ADDR_VAR 0 4
7460: PUSH
7461: LD_INT 0
7463: ST_TO_ADDR
// end ;
7464: LD_VAR 0 4
7468: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
7469: LD_INT 0
7471: PPUSH
7472: PPUSH
7473: PPUSH
7474: PPUSH
7475: PPUSH
// p := 1 ;
7476: LD_ADDR_VAR 0 6
7480: PUSH
7481: LD_INT 1
7483: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
7484: LD_ADDR_VAR 0 4
7488: PUSH
7489: DOUBLE
7490: LD_INT 1
7492: DEC
7493: ST_TO_ADDR
7494: LD_VAR 0 2
7498: PUSH
7499: LD_INT 4
7501: DIVREAL
7502: PUSH
7503: FOR_TO
7504: IFFALSE 7753
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
7506: LD_VAR 0 2
7510: PUSH
7511: LD_VAR 0 6
7515: PUSH
7516: LD_INT 1
7518: PLUS
7519: ARRAY
7520: PPUSH
7521: LD_VAR 0 2
7525: PUSH
7526: LD_VAR 0 6
7530: PUSH
7531: LD_INT 2
7533: PLUS
7534: ARRAY
7535: PPUSH
7536: CALL_OW 428
7540: PUSH
7541: LD_INT 0
7543: EQUAL
7544: PUSH
7545: LD_VAR 0 2
7549: PUSH
7550: LD_VAR 0 6
7554: PUSH
7555: LD_INT 1
7557: PLUS
7558: ARRAY
7559: PPUSH
7560: LD_VAR 0 2
7564: PUSH
7565: LD_VAR 0 6
7569: PUSH
7570: LD_INT 2
7572: PLUS
7573: ARRAY
7574: PPUSH
7575: CALL 5870 0 2
7579: AND
7580: PUSH
7581: LD_VAR 0 1
7585: PUSH
7586: LD_INT 1
7588: ARRAY
7589: PPUSH
7590: CALL_OW 255
7594: PPUSH
7595: CALL 6249 0 1
7599: PUSH
7600: LD_INT 20
7602: GREATEREQUAL
7603: AND
7604: IFFALSE 7721
// begin for c = 1 to plist do
7606: LD_ADDR_VAR 0 7
7610: PUSH
7611: DOUBLE
7612: LD_INT 1
7614: DEC
7615: ST_TO_ADDR
7616: LD_VAR 0 1
7620: PUSH
7621: FOR_TO
7622: IFFALSE 7715
// if not HasTask ( plist [ c ] ) then
7624: LD_VAR 0 1
7628: PUSH
7629: LD_VAR 0 7
7633: ARRAY
7634: PPUSH
7635: CALL_OW 314
7639: NOT
7640: IFFALSE 7713
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
7642: LD_VAR 0 1
7646: PUSH
7647: LD_VAR 0 7
7651: ARRAY
7652: PPUSH
7653: LD_VAR 0 2
7657: PUSH
7658: LD_VAR 0 6
7662: ARRAY
7663: PPUSH
7664: LD_VAR 0 2
7668: PUSH
7669: LD_VAR 0 6
7673: PUSH
7674: LD_INT 1
7676: PLUS
7677: ARRAY
7678: PPUSH
7679: LD_VAR 0 2
7683: PUSH
7684: LD_VAR 0 6
7688: PUSH
7689: LD_INT 2
7691: PLUS
7692: ARRAY
7693: PPUSH
7694: LD_VAR 0 2
7698: PUSH
7699: LD_VAR 0 6
7703: PUSH
7704: LD_INT 3
7706: PLUS
7707: ARRAY
7708: PPUSH
7709: CALL_OW 145
7713: GO 7621
7715: POP
7716: POP
// break ;
7717: GO 7753
// end else
7719: GO 7751
// if ( p + 4 < tlist ) then
7721: LD_VAR 0 6
7725: PUSH
7726: LD_INT 4
7728: PLUS
7729: PUSH
7730: LD_VAR 0 2
7734: LESS
7735: IFFALSE 7751
// p := p + 4 ;
7737: LD_ADDR_VAR 0 6
7741: PUSH
7742: LD_VAR 0 6
7746: PUSH
7747: LD_INT 4
7749: PLUS
7750: ST_TO_ADDR
// end ;
7751: GO 7503
7753: POP
7754: POP
// end ;
7755: LD_VAR 0 3
7759: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
7760: LD_INT 0
7762: PPUSH
7763: PPUSH
7764: PPUSH
7765: PPUSH
// tmp := GetTowers ( side ) ;
7766: LD_ADDR_VAR 0 5
7770: PUSH
7771: LD_VAR 0 1
7775: PPUSH
7776: CALL 6861 0 1
7780: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
7781: LD_ADDR_VAR 0 6
7785: PUSH
7786: LD_VAR 0 1
7790: PPUSH
7791: LD_INT 3
7793: PPUSH
7794: CALL 6155 0 2
7798: PUSH
7799: LD_INT 1
7801: ARRAY
7802: ST_TO_ADDR
// if fac then
7803: LD_VAR 0 6
7807: IFFALSE 7903
// for i = 1 to tmp do
7809: LD_ADDR_VAR 0 4
7813: PUSH
7814: DOUBLE
7815: LD_INT 1
7817: DEC
7818: ST_TO_ADDR
7819: LD_VAR 0 5
7823: PUSH
7824: FOR_TO
7825: IFFALSE 7901
// if GetBWeapon ( tmp [ i ] ) = 0 then
7827: LD_VAR 0 5
7831: PUSH
7832: LD_VAR 0 4
7836: ARRAY
7837: PPUSH
7838: CALL_OW 269
7842: PUSH
7843: LD_INT 0
7845: EQUAL
7846: IFFALSE 7899
// begin if BuildingStatus ( fac ) = bs_idle then
7848: LD_VAR 0 6
7852: PPUSH
7853: CALL_OW 461
7857: PUSH
7858: LD_INT 2
7860: EQUAL
7861: IFFALSE 7897
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
7863: LD_VAR 0 5
7867: PUSH
7868: LD_VAR 0 4
7872: ARRAY
7873: PPUSH
7874: LD_VAR 0 2
7878: PUSH
7879: LD_INT 1
7881: PPUSH
7882: LD_VAR 0 2
7886: PPUSH
7887: CALL_OW 12
7891: ARRAY
7892: PPUSH
7893: CALL_OW 148
// break ;
7897: GO 7901
// end ;
7899: GO 7824
7901: POP
7902: POP
// end ;
7903: LD_VAR 0 3
7907: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
7908: LD_INT 0
7910: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
7911: LD_INT 22
7913: PUSH
7914: LD_VAR 0 1
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: PUSH
7923: LD_INT 34
7925: PUSH
7926: LD_VAR 0 3
7930: PUSH
7931: EMPTY
7932: LIST
7933: LIST
7934: PUSH
7935: LD_INT 31
7937: PUSH
7938: LD_VAR 0 2
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: LIST
7951: PUSH
7952: EMPTY
7953: LIST
7954: PPUSH
7955: CALL_OW 69
7959: IFFALSE 8017
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
7961: LD_ADDR_VAR 0 4
7965: PUSH
7966: LD_INT 22
7968: PUSH
7969: LD_VAR 0 1
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PUSH
7978: LD_INT 34
7980: PUSH
7981: LD_VAR 0 3
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: PUSH
7990: LD_INT 31
7992: PUSH
7993: LD_VAR 0 2
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: EMPTY
8008: LIST
8009: PPUSH
8010: CALL_OW 69
8014: ST_TO_ADDR
8015: GO 8025
// result := false ;
8017: LD_ADDR_VAR 0 4
8021: PUSH
8022: LD_INT 0
8024: ST_TO_ADDR
// end ;
8025: LD_VAR 0 4
8029: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8030: LD_INT 0
8032: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8033: LD_VAR 0 1
8037: PPUSH
8038: LD_VAR 0 2
8042: PPUSH
8043: LD_VAR 0 3
8047: PPUSH
8048: LD_VAR 0 4
8052: PPUSH
8053: LD_VAR 0 5
8057: PPUSH
8058: CALL_OW 448
8062: PUSH
8063: LD_VAR 0 2
8067: PPUSH
8068: LD_VAR 0 3
8072: PPUSH
8073: LD_VAR 0 4
8077: PPUSH
8078: LD_VAR 0 5
8082: PPUSH
8083: CALL_OW 449
8087: PUSH
8088: LD_INT 1
8090: ARRAY
8091: PUSH
8092: LD_VAR 0 1
8096: PPUSH
8097: CALL 5756 0 1
8101: PUSH
8102: LD_INT 1
8104: ARRAY
8105: LESSEQUAL
8106: AND
8107: PUSH
8108: LD_VAR 0 2
8112: PPUSH
8113: LD_VAR 0 3
8117: PPUSH
8118: LD_VAR 0 4
8122: PPUSH
8123: LD_VAR 0 5
8127: PPUSH
8128: CALL_OW 449
8132: PUSH
8133: LD_INT 2
8135: ARRAY
8136: PUSH
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL 5756 0 1
8146: PUSH
8147: LD_INT 2
8149: ARRAY
8150: LESSEQUAL
8151: AND
8152: PUSH
8153: LD_VAR 0 2
8157: PPUSH
8158: LD_VAR 0 3
8162: PPUSH
8163: LD_VAR 0 4
8167: PPUSH
8168: LD_VAR 0 5
8172: PPUSH
8173: CALL_OW 449
8177: PUSH
8178: LD_INT 3
8180: ARRAY
8181: PUSH
8182: LD_VAR 0 1
8186: PPUSH
8187: CALL 5756 0 1
8191: PUSH
8192: LD_INT 3
8194: ARRAY
8195: LESSEQUAL
8196: AND
8197: IFFALSE 8244
// begin if debug then
8199: LD_EXP 1
8203: IFFALSE 8213
// display_strings := Factory work! ;
8205: LD_ADDR_OWVAR 47
8209: PUSH
8210: LD_STRING Factory work!
8212: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8213: LD_VAR 0 1
8217: PPUSH
8218: LD_VAR 0 2
8222: PPUSH
8223: LD_VAR 0 3
8227: PPUSH
8228: LD_VAR 0 4
8232: PPUSH
8233: LD_VAR 0 5
8237: PPUSH
8238: CALL_OW 125
// end else
8242: GO 8252
// result := false ;
8244: LD_ADDR_VAR 0 6
8248: PUSH
8249: LD_INT 0
8251: ST_TO_ADDR
// end ;
8252: LD_VAR 0 6
8256: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8257: LD_INT 0
8259: PPUSH
8260: PPUSH
8261: PPUSH
8262: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8263: LD_ADDR_VAR 0 6
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_VAR 0 1
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PUSH
8280: LD_INT 30
8282: PUSH
8283: LD_VAR 0 2
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PPUSH
8296: CALL_OW 69
8300: ST_TO_ADDR
// tmp := [ ] ;
8301: LD_ADDR_VAR 0 5
8305: PUSH
8306: EMPTY
8307: ST_TO_ADDR
// for i = 1 to filter do
8308: LD_ADDR_VAR 0 4
8312: PUSH
8313: DOUBLE
8314: LD_INT 1
8316: DEC
8317: ST_TO_ADDR
8318: LD_VAR 0 6
8322: PUSH
8323: FOR_TO
8324: IFFALSE 8412
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8326: LD_ADDR_VAR 0 5
8330: PUSH
8331: LD_VAR 0 5
8335: PUSH
8336: LD_VAR 0 6
8340: PUSH
8341: LD_VAR 0 4
8345: ARRAY
8346: PPUSH
8347: CALL_OW 266
8351: PUSH
8352: LD_VAR 0 6
8356: PUSH
8357: LD_VAR 0 4
8361: ARRAY
8362: PPUSH
8363: CALL_OW 250
8367: PUSH
8368: LD_VAR 0 6
8372: PUSH
8373: LD_VAR 0 4
8377: ARRAY
8378: PPUSH
8379: CALL_OW 251
8383: PUSH
8384: LD_VAR 0 6
8388: PUSH
8389: LD_VAR 0 4
8393: ARRAY
8394: PPUSH
8395: CALL_OW 254
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: LIST
8404: LIST
8405: PUSH
8406: EMPTY
8407: LIST
8408: ADD
8409: ST_TO_ADDR
// end ;
8410: GO 8323
8412: POP
8413: POP
// result := tmp ;
8414: LD_ADDR_VAR 0 3
8418: PUSH
8419: LD_VAR 0 5
8423: ST_TO_ADDR
// end ;
8424: LD_VAR 0 3
8428: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
8429: LD_INT 0
8431: PPUSH
8432: PPUSH
8433: PPUSH
// for i = 1 to list do
8434: LD_ADDR_VAR 0 4
8438: PUSH
8439: DOUBLE
8440: LD_INT 1
8442: DEC
8443: ST_TO_ADDR
8444: LD_VAR 0 2
8448: PUSH
8449: FOR_TO
8450: IFFALSE 9005
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
8452: LD_VAR 0 2
8456: PUSH
8457: LD_VAR 0 4
8461: ARRAY
8462: PUSH
8463: LD_INT 1
8465: ARRAY
8466: PPUSH
8467: LD_VAR 0 2
8471: PUSH
8472: LD_VAR 0 4
8476: ARRAY
8477: PUSH
8478: LD_INT 2
8480: ARRAY
8481: PPUSH
8482: CALL_OW 428
8486: PUSH
8487: LD_INT 0
8489: GREATER
8490: IFFALSE 8776
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
8492: LD_VAR 0 2
8496: PUSH
8497: LD_VAR 0 4
8501: ARRAY
8502: PUSH
8503: LD_INT 1
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_VAR 0 4
8516: ARRAY
8517: PUSH
8518: LD_INT 2
8520: ARRAY
8521: PPUSH
8522: CALL_OW 428
8526: PPUSH
8527: CALL_OW 248
8531: PUSH
8532: LD_INT 3
8534: EQUAL
8535: IFFALSE 8661
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
8537: LD_VAR 0 2
8541: PUSH
8542: LD_VAR 0 4
8546: ARRAY
8547: PUSH
8548: LD_INT 1
8550: ARRAY
8551: PPUSH
8552: LD_VAR 0 2
8556: PUSH
8557: LD_VAR 0 4
8561: ARRAY
8562: PUSH
8563: LD_INT 2
8565: ARRAY
8566: PPUSH
8567: CALL_OW 428
8571: PPUSH
8572: CALL_OW 274
8576: PPUSH
8577: LD_INT 3
8579: PPUSH
8580: CALL_OW 275
8584: PUSH
8585: LD_INT 15
8587: GREATEREQUAL
8588: IFFALSE 8659
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
8590: LD_VAR 0 2
8594: PUSH
8595: LD_VAR 0 4
8599: ARRAY
8600: PUSH
8601: LD_INT 1
8603: ARRAY
8604: PPUSH
8605: LD_VAR 0 2
8609: PUSH
8610: LD_VAR 0 4
8614: ARRAY
8615: PUSH
8616: LD_INT 2
8618: ARRAY
8619: PPUSH
8620: CALL_OW 428
8624: PPUSH
8625: LD_VAR 0 2
8629: PUSH
8630: LD_VAR 0 4
8634: ARRAY
8635: PUSH
8636: LD_INT 4
8638: ARRAY
8639: PPUSH
8640: LD_VAR 0 2
8644: PUSH
8645: LD_VAR 0 4
8649: ARRAY
8650: PUSH
8651: LD_INT 5
8653: ARRAY
8654: PPUSH
8655: CALL 7322 0 3
// end else
8659: GO 8730
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
8661: LD_VAR 0 2
8665: PUSH
8666: LD_VAR 0 4
8670: ARRAY
8671: PUSH
8672: LD_INT 1
8674: ARRAY
8675: PPUSH
8676: LD_VAR 0 2
8680: PUSH
8681: LD_VAR 0 4
8685: ARRAY
8686: PUSH
8687: LD_INT 2
8689: ARRAY
8690: PPUSH
8691: CALL_OW 428
8695: PPUSH
8696: LD_VAR 0 2
8700: PUSH
8701: LD_VAR 0 4
8705: ARRAY
8706: PUSH
8707: LD_INT 4
8709: ARRAY
8710: PPUSH
8711: LD_VAR 0 2
8715: PUSH
8716: LD_VAR 0 4
8720: ARRAY
8721: PUSH
8722: LD_INT 5
8724: ARRAY
8725: PPUSH
8726: CALL 7322 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
8730: LD_VAR 0 1
8734: PPUSH
8735: LD_VAR 0 2
8739: PUSH
8740: LD_VAR 0 4
8744: ARRAY
8745: PUSH
8746: LD_INT 1
8748: ARRAY
8749: PPUSH
8750: LD_VAR 0 2
8754: PUSH
8755: LD_VAR 0 4
8759: ARRAY
8760: PUSH
8761: LD_INT 2
8763: ARRAY
8764: PPUSH
8765: CALL_OW 428
8769: PPUSH
8770: CALL 10378 0 2
// end else
8774: GO 9003
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
8776: LD_VAR 0 1
8780: PUSH
8781: LD_INT 1
8783: ARRAY
8784: PPUSH
8785: CALL_OW 255
8789: PPUSH
8790: CALL 6064 0 1
8794: PPUSH
8795: LD_INT 6
8797: PPUSH
8798: CALL 5640 0 2
8802: PUSH
8803: LD_VAR 0 1
8807: PUSH
8808: LD_INT 1
8810: ARRAY
8811: PPUSH
8812: CALL_OW 255
8816: PPUSH
8817: CALL 6064 0 1
8821: PPUSH
8822: LD_VAR 0 2
8826: PUSH
8827: LD_VAR 0 4
8831: ARRAY
8832: PUSH
8833: LD_INT 4
8835: ARRAY
8836: PPUSH
8837: CALL 5640 0 2
8841: AND
8842: PUSH
8843: LD_VAR 0 1
8847: PUSH
8848: LD_INT 1
8850: ARRAY
8851: PPUSH
8852: CALL_OW 255
8856: PPUSH
8857: CALL 6064 0 1
8861: PPUSH
8862: LD_VAR 0 2
8866: PUSH
8867: LD_VAR 0 4
8871: ARRAY
8872: PUSH
8873: LD_INT 5
8875: ARRAY
8876: PPUSH
8877: CALL 5640 0 2
8881: AND
8882: IFFALSE 9003
// for p = 1 to plist do
8884: LD_ADDR_VAR 0 5
8888: PUSH
8889: DOUBLE
8890: LD_INT 1
8892: DEC
8893: ST_TO_ADDR
8894: LD_VAR 0 1
8898: PUSH
8899: FOR_TO
8900: IFFALSE 9001
// if IsInUnit ( plist [ p ] ) then
8902: LD_VAR 0 1
8906: PUSH
8907: LD_VAR 0 5
8911: ARRAY
8912: PPUSH
8913: CALL_OW 310
8917: IFFALSE 8936
// ComExitBuilding ( plist [ p ] ) else
8919: LD_VAR 0 1
8923: PUSH
8924: LD_VAR 0 5
8928: ARRAY
8929: PPUSH
8930: CALL_OW 122
8934: GO 8999
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
8936: LD_VAR 0 1
8940: PUSH
8941: LD_VAR 0 5
8945: ARRAY
8946: PPUSH
8947: LD_INT 6
8949: PPUSH
8950: LD_VAR 0 2
8954: PUSH
8955: LD_VAR 0 4
8959: ARRAY
8960: PUSH
8961: LD_INT 1
8963: ARRAY
8964: PPUSH
8965: LD_VAR 0 2
8969: PUSH
8970: LD_VAR 0 4
8974: ARRAY
8975: PUSH
8976: LD_INT 2
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 2
8984: PUSH
8985: LD_VAR 0 4
8989: ARRAY
8990: PUSH
8991: LD_INT 3
8993: ARRAY
8994: PPUSH
8995: CALL_OW 145
8999: GO 8899
9001: POP
9002: POP
// end ;
9003: GO 8449
9005: POP
9006: POP
// end ;
9007: LD_VAR 0 3
9011: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9012: LD_INT 0
9014: PPUSH
// if IsInUnit ( sci ) then
9015: LD_VAR 0 1
9019: PPUSH
9020: CALL_OW 310
9024: IFFALSE 9037
// ComExitBuilding ( sci ) else
9026: LD_VAR 0 1
9030: PPUSH
9031: CALL_OW 122
9035: GO 9068
// if not HasTask ( sci ) then
9037: LD_VAR 0 1
9041: PPUSH
9042: CALL_OW 314
9046: NOT
9047: IFFALSE 9068
// begin ComMoveXY ( sci , x , y ) ;
9049: LD_VAR 0 1
9053: PPUSH
9054: LD_VAR 0 2
9058: PPUSH
9059: LD_VAR 0 3
9063: PPUSH
9064: CALL_OW 111
// end ; end ;
9068: LD_VAR 0 4
9072: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9073: LD_INT 0
9075: PPUSH
9076: PPUSH
9077: PPUSH
9078: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9079: LD_ADDR_VAR 0 6
9083: PUSH
9084: LD_INT 22
9086: PUSH
9087: LD_VAR 0 1
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 21
9098: PUSH
9099: LD_INT 1
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: PUSH
9106: EMPTY
9107: LIST
9108: LIST
9109: PPUSH
9110: CALL_OW 69
9114: PUSH
9115: LD_VAR 0 3
9119: DIFF
9120: ST_TO_ADDR
// tmp := tag_list ;
9121: LD_ADDR_VAR 0 7
9125: PUSH
9126: LD_VAR 0 2
9130: ST_TO_ADDR
// for i = 1 to filter do
9131: LD_ADDR_VAR 0 5
9135: PUSH
9136: DOUBLE
9137: LD_INT 1
9139: DEC
9140: ST_TO_ADDR
9141: LD_VAR 0 6
9145: PUSH
9146: FOR_TO
9147: IFFALSE 9416
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9149: LD_VAR 0 6
9153: PUSH
9154: LD_VAR 0 5
9158: ARRAY
9159: PPUSH
9160: CALL_OW 256
9164: PUSH
9165: LD_INT 1000
9167: EQUAL
9168: PUSH
9169: LD_VAR 0 6
9173: PUSH
9174: LD_VAR 0 5
9178: ARRAY
9179: PPUSH
9180: CALL_OW 110
9184: PUSH
9185: LD_INT 100
9187: GREATEREQUAL
9188: AND
9189: IFFALSE 9231
// begin SetTag ( filter [ i ] , 0 ) ;
9191: LD_VAR 0 6
9195: PUSH
9196: LD_VAR 0 5
9200: ARRAY
9201: PPUSH
9202: LD_INT 0
9204: PPUSH
9205: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9209: LD_ADDR_VAR 0 7
9213: PUSH
9214: LD_VAR 0 7
9218: PUSH
9219: LD_VAR 0 6
9223: PUSH
9224: LD_VAR 0 5
9228: ARRAY
9229: DIFF
9230: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9231: LD_VAR 0 6
9235: PUSH
9236: LD_VAR 0 5
9240: ARRAY
9241: PPUSH
9242: CALL_OW 256
9246: PUSH
9247: LD_INT 1000
9249: LESS
9250: IFFALSE 9414
// begin if not filter [ i ] in tmp then
9252: LD_VAR 0 6
9256: PUSH
9257: LD_VAR 0 5
9261: ARRAY
9262: PUSH
9263: LD_VAR 0 7
9267: IN
9268: NOT
9269: IFFALSE 9293
// tmp := tmp ^ filter [ i ] ;
9271: LD_ADDR_VAR 0 7
9275: PUSH
9276: LD_VAR 0 7
9280: PUSH
9281: LD_VAR 0 6
9285: PUSH
9286: LD_VAR 0 5
9290: ARRAY
9291: ADD
9292: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9293: LD_VAR 0 6
9297: PUSH
9298: LD_VAR 0 5
9302: ARRAY
9303: PPUSH
9304: CALL_OW 256
9308: PUSH
9309: LD_INT 250
9311: LESS
9312: IFFALSE 9334
// SetTag ( filter [ i ] , 100 ) else
9314: LD_VAR 0 6
9318: PUSH
9319: LD_VAR 0 5
9323: ARRAY
9324: PPUSH
9325: LD_INT 100
9327: PPUSH
9328: CALL_OW 109
9332: GO 9414
// if GetLives ( filter [ i ] ) < 500 then
9334: LD_VAR 0 6
9338: PUSH
9339: LD_VAR 0 5
9343: ARRAY
9344: PPUSH
9345: CALL_OW 256
9349: PUSH
9350: LD_INT 500
9352: LESS
9353: IFFALSE 9375
// SetTag ( filter [ i ] , 101 ) else
9355: LD_VAR 0 6
9359: PUSH
9360: LD_VAR 0 5
9364: ARRAY
9365: PPUSH
9366: LD_INT 101
9368: PPUSH
9369: CALL_OW 109
9373: GO 9414
// if GetLives ( filter [ i ] ) < 1000 then
9375: LD_VAR 0 6
9379: PUSH
9380: LD_VAR 0 5
9384: ARRAY
9385: PPUSH
9386: CALL_OW 256
9390: PUSH
9391: LD_INT 1000
9393: LESS
9394: IFFALSE 9414
// SetTag ( filter [ i ] , 102 ) ;
9396: LD_VAR 0 6
9400: PUSH
9401: LD_VAR 0 5
9405: ARRAY
9406: PPUSH
9407: LD_INT 102
9409: PPUSH
9410: CALL_OW 109
// end ; end ;
9414: GO 9146
9416: POP
9417: POP
// result := tmp ;
9418: LD_ADDR_VAR 0 4
9422: PUSH
9423: LD_VAR 0 7
9427: ST_TO_ADDR
// end ;
9428: LD_VAR 0 4
9432: RET
// export function WantHeal ( sci , tag ) ; begin
9433: LD_INT 0
9435: PPUSH
// if GetTaskList ( sci ) > 0 then
9436: LD_VAR 0 1
9440: PPUSH
9441: CALL_OW 437
9445: PUSH
9446: LD_INT 0
9448: GREATER
9449: IFFALSE 9524
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
9451: LD_VAR 0 1
9455: PPUSH
9456: CALL_OW 437
9460: PUSH
9461: LD_INT 1
9463: ARRAY
9464: PUSH
9465: LD_INT 1
9467: ARRAY
9468: PUSH
9469: LD_STRING l
9471: EQUAL
9472: PUSH
9473: LD_VAR 0 1
9477: PPUSH
9478: CALL_OW 437
9482: PUSH
9483: LD_INT 1
9485: ARRAY
9486: PUSH
9487: LD_INT 4
9489: ARRAY
9490: PPUSH
9491: CALL_OW 110
9495: PUSH
9496: LD_VAR 0 2
9500: EQUAL
9501: AND
9502: IFFALSE 9514
// result := true else
9504: LD_ADDR_VAR 0 3
9508: PUSH
9509: LD_INT 1
9511: ST_TO_ADDR
9512: GO 9522
// result := false ;
9514: LD_ADDR_VAR 0 3
9518: PUSH
9519: LD_INT 0
9521: ST_TO_ADDR
// end else
9522: GO 9532
// result := false ;
9524: LD_ADDR_VAR 0 3
9528: PUSH
9529: LD_INT 0
9531: ST_TO_ADDR
// end ;
9532: LD_VAR 0 3
9536: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
9537: LD_INT 0
9539: PPUSH
9540: PPUSH
9541: PPUSH
9542: PPUSH
9543: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9544: LD_ADDR_VAR 0 7
9548: PUSH
9549: LD_INT 22
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 21
9566: PUSH
9567: LD_INT 3
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PPUSH
9582: CALL_OW 69
9586: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
9587: LD_ADDR_VAR 0 5
9591: PUSH
9592: LD_INT 1
9594: PPUSH
9595: LD_INT 3
9597: PPUSH
9598: CALL_OW 12
9602: ST_TO_ADDR
// if filter > 0 then
9603: LD_VAR 0 7
9607: PUSH
9608: LD_INT 0
9610: GREATER
9611: IFFALSE 9813
// for i = 1 to list do
9613: LD_ADDR_VAR 0 6
9617: PUSH
9618: DOUBLE
9619: LD_INT 1
9621: DEC
9622: ST_TO_ADDR
9623: LD_VAR 0 1
9627: PUSH
9628: FOR_TO
9629: IFFALSE 9811
// for ta in filter do
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_VAR 0 7
9640: PUSH
9641: FOR_IN
9642: IFFALSE 9807
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
9644: LD_VAR 0 1
9648: PUSH
9649: LD_VAR 0 6
9653: ARRAY
9654: PPUSH
9655: LD_VAR 0 4
9659: PPUSH
9660: CALL_OW 296
9664: PUSH
9665: LD_INT 13
9667: LESSEQUAL
9668: IFFALSE 9805
// begin case c of 1 :
9670: LD_VAR 0 5
9674: PUSH
9675: LD_INT 1
9677: DOUBLE
9678: EQUAL
9679: IFTRUE 9683
9681: GO 9721
9683: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
9684: LD_VAR 0 1
9688: PUSH
9689: LD_VAR 0 6
9693: ARRAY
9694: PPUSH
9695: LD_VAR 0 4
9699: PPUSH
9700: CALL_OW 250
9704: PPUSH
9705: LD_VAR 0 4
9709: PPUSH
9710: CALL_OW 251
9714: PPUSH
9715: CALL_OW 154
9719: GO 9805
9721: LD_INT 2
9723: DOUBLE
9724: EQUAL
9725: IFTRUE 9729
9727: GO 9793
9729: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
9730: LD_VAR 0 1
9734: PUSH
9735: LD_VAR 0 6
9739: ARRAY
9740: PPUSH
9741: LD_VAR 0 4
9745: PPUSH
9746: CALL_OW 250
9750: PUSH
9751: LD_INT 1
9753: NEG
9754: PPUSH
9755: LD_INT 1
9757: PPUSH
9758: CALL_OW 12
9762: PLUS
9763: PPUSH
9764: LD_VAR 0 4
9768: PPUSH
9769: CALL_OW 251
9773: PUSH
9774: LD_INT 1
9776: NEG
9777: PPUSH
9778: LD_INT 1
9780: PPUSH
9781: CALL_OW 12
9785: PLUS
9786: PPUSH
9787: CALL_OW 153
9791: GO 9805
9793: LD_INT 3
9795: DOUBLE
9796: EQUAL
9797: IFTRUE 9801
9799: GO 9804
9801: POP
// ; end ;
9802: GO 9805
9804: POP
// end ; end ;
9805: GO 9641
9807: POP
9808: POP
9809: GO 9628
9811: POP
9812: POP
// end ;
9813: LD_VAR 0 3
9817: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
9818: LD_INT 0
9820: PPUSH
9821: PPUSH
// for i = 1 to plist do
9822: LD_ADDR_VAR 0 3
9826: PUSH
9827: DOUBLE
9828: LD_INT 1
9830: DEC
9831: ST_TO_ADDR
9832: LD_VAR 0 1
9836: PUSH
9837: FOR_TO
9838: IFFALSE 10040
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
9840: LD_VAR 0 1
9844: PUSH
9845: LD_VAR 0 3
9849: ARRAY
9850: PPUSH
9851: CALL_OW 310
9855: PUSH
9856: LD_INT 30
9858: PUSH
9859: LD_INT 5
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: PUSH
9866: EMPTY
9867: LIST
9868: PPUSH
9869: CALL_OW 69
9873: IN
9874: NOT
9875: IFFALSE 10020
// begin if IsInUnit ( plist [ i ] ) then
9877: LD_VAR 0 1
9881: PUSH
9882: LD_VAR 0 3
9886: ARRAY
9887: PPUSH
9888: CALL_OW 310
9892: IFFALSE 9911
// ComExitBuilding ( plist [ i ] ) else
9894: LD_VAR 0 1
9898: PUSH
9899: LD_VAR 0 3
9903: ARRAY
9904: PPUSH
9905: CALL_OW 122
9909: GO 10018
// if not HasTask ( plist [ i ] ) then
9911: LD_VAR 0 1
9915: PUSH
9916: LD_VAR 0 3
9920: ARRAY
9921: PPUSH
9922: CALL_OW 314
9926: NOT
9927: IFFALSE 10018
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
9929: LD_VAR 0 1
9933: PUSH
9934: LD_VAR 0 3
9938: ARRAY
9939: PPUSH
9940: LD_INT 22
9942: PUSH
9943: LD_VAR 0 1
9947: PUSH
9948: LD_INT 1
9950: ARRAY
9951: PPUSH
9952: CALL_OW 255
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: PUSH
9961: LD_INT 30
9963: PUSH
9964: LD_INT 5
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: PPUSH
9975: CALL_OW 69
9979: PPUSH
9980: LD_VAR 0 1
9984: PUSH
9985: LD_VAR 0 3
9989: ARRAY
9990: PPUSH
9991: CALL_OW 74
9995: PPUSH
9996: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10000: LD_VAR 0 1
10004: PUSH
10005: LD_VAR 0 3
10009: ARRAY
10010: PPUSH
10011: LD_INT 9
10013: PPUSH
10014: CALL_OW 183
// end ; end else
10018: GO 10038
// ComChangeProfession ( plist [ i ] , 9 ) ;
10020: LD_VAR 0 1
10024: PUSH
10025: LD_VAR 0 3
10029: ARRAY
10030: PPUSH
10031: LD_INT 9
10033: PPUSH
10034: CALL_OW 123
10038: GO 9837
10040: POP
10041: POP
// end ;
10042: LD_VAR 0 2
10046: RET
// export function GetHuman ( side ) ; begin
10047: LD_INT 0
10049: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10050: LD_ADDR_VAR 0 2
10054: PUSH
10055: LD_INT 22
10057: PUSH
10058: LD_VAR 0 1
10062: PUSH
10063: EMPTY
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 21
10069: PUSH
10070: LD_INT 1
10072: PUSH
10073: EMPTY
10074: LIST
10075: LIST
10076: PUSH
10077: LD_INT 2
10079: PUSH
10080: LD_INT 25
10082: PUSH
10083: LD_INT 1
10085: PUSH
10086: EMPTY
10087: LIST
10088: LIST
10089: PUSH
10090: LD_INT 25
10092: PUSH
10093: LD_INT 2
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: PUSH
10100: LD_INT 25
10102: PUSH
10103: LD_INT 3
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: PUSH
10110: LD_INT 25
10112: PUSH
10113: LD_INT 4
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: LIST
10131: PPUSH
10132: CALL_OW 69
10136: ST_TO_ADDR
// end ;
10137: LD_VAR 0 2
10141: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10142: LD_INT 0
10144: PPUSH
10145: PPUSH
10146: PPUSH
// uc_side := 0 ;
10147: LD_ADDR_OWVAR 20
10151: PUSH
10152: LD_INT 0
10154: ST_TO_ADDR
// uc_nation := 0 ;
10155: LD_ADDR_OWVAR 21
10159: PUSH
10160: LD_INT 0
10162: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10163: LD_ADDR_VAR 0 4
10167: PUSH
10168: DOUBLE
10169: LD_INT 1
10171: DEC
10172: ST_TO_ADDR
10173: LD_INT 4
10175: PUSH
10176: LD_INT 5
10178: PUSH
10179: LD_INT 6
10181: PUSH
10182: EMPTY
10183: LIST
10184: LIST
10185: LIST
10186: PUSH
10187: LD_OWVAR 67
10191: ARRAY
10192: PUSH
10193: FOR_TO
10194: IFFALSE 10265
// begin hc_class = class_tiger ;
10196: LD_ADDR_OWVAR 28
10200: PUSH
10201: LD_INT 14
10203: ST_TO_ADDR
// hc_gallery = sandnature ;
10204: LD_ADDR_OWVAR 33
10208: PUSH
10209: LD_STRING sandnature
10211: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10212: LD_ADDR_OWVAR 35
10216: PUSH
10217: LD_INT 0
10219: PPUSH
10220: LD_INT 50
10222: PPUSH
10223: CALL_OW 12
10227: ST_TO_ADDR
// hc_face_number = 3 ;
10228: LD_ADDR_OWVAR 34
10232: PUSH
10233: LD_INT 3
10235: ST_TO_ADDR
// tiger := CreateHuman ;
10236: LD_ADDR_VAR 0 3
10240: PUSH
10241: CALL_OW 44
10245: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10246: LD_VAR 0 3
10250: PPUSH
10251: LD_VAR 0 1
10255: PPUSH
10256: LD_INT 0
10258: PPUSH
10259: CALL_OW 49
// end ;
10263: GO 10193
10265: POP
10266: POP
// end ;
10267: LD_VAR 0 2
10271: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10272: LD_INT 0
10274: PPUSH
10275: PPUSH
10276: PPUSH
// uc_side := 0 ;
10277: LD_ADDR_OWVAR 20
10281: PUSH
10282: LD_INT 0
10284: ST_TO_ADDR
// uc_nation := 0 ;
10285: LD_ADDR_OWVAR 21
10289: PUSH
10290: LD_INT 0
10292: ST_TO_ADDR
// for i = 1 to 8 do
10293: LD_ADDR_VAR 0 4
10297: PUSH
10298: DOUBLE
10299: LD_INT 1
10301: DEC
10302: ST_TO_ADDR
10303: LD_INT 8
10305: PUSH
10306: FOR_TO
10307: IFFALSE 10371
// begin hc_class = class_apeman ;
10309: LD_ADDR_OWVAR 28
10313: PUSH
10314: LD_INT 12
10316: ST_TO_ADDR
// hc_gallery =  ;
10317: LD_ADDR_OWVAR 33
10321: PUSH
10322: LD_STRING 
10324: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10325: LD_ADDR_OWVAR 35
10329: PUSH
10330: LD_INT 5
10332: NEG
10333: PPUSH
10334: LD_INT 20
10336: PPUSH
10337: CALL_OW 12
10341: ST_TO_ADDR
// ape := CreateHuman ;
10342: LD_ADDR_VAR 0 3
10346: PUSH
10347: CALL_OW 44
10351: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10352: LD_VAR 0 3
10356: PPUSH
10357: LD_VAR 0 1
10361: PPUSH
10362: LD_INT 0
10364: PPUSH
10365: CALL_OW 49
// end ;
10369: GO 10306
10371: POP
10372: POP
// end ;
10373: LD_VAR 0 2
10377: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
10378: LD_INT 0
10380: PPUSH
10381: PPUSH
// if BuildingStatus ( b ) = bs_build then
10382: LD_VAR 0 2
10386: PPUSH
10387: CALL_OW 461
10391: PUSH
10392: LD_INT 1
10394: EQUAL
10395: IFFALSE 10581
// for i = 1 to plist do
10397: LD_ADDR_VAR 0 4
10401: PUSH
10402: DOUBLE
10403: LD_INT 1
10405: DEC
10406: ST_TO_ADDR
10407: LD_VAR 0 1
10411: PUSH
10412: FOR_TO
10413: IFFALSE 10579
// if IsInUnit ( plist [ i ] ) then
10415: LD_VAR 0 1
10419: PUSH
10420: LD_VAR 0 4
10424: ARRAY
10425: PPUSH
10426: CALL_OW 310
10430: IFFALSE 10513
// begin ComExitBuilding ( plist [ i ] ) ;
10432: LD_VAR 0 1
10436: PUSH
10437: LD_VAR 0 4
10441: ARRAY
10442: PPUSH
10443: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
10447: LD_VAR 0 1
10451: PUSH
10452: LD_VAR 0 4
10456: ARRAY
10457: PPUSH
10458: LD_STRING h
10460: PUSH
10461: LD_VAR 0 2
10465: PPUSH
10466: CALL_OW 250
10470: PUSH
10471: LD_VAR 0 2
10475: PPUSH
10476: CALL_OW 251
10480: PUSH
10481: LD_VAR 0 2
10485: PUSH
10486: LD_INT 0
10488: PUSH
10489: LD_INT 0
10491: PUSH
10492: LD_INT 0
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: EMPTY
10505: LIST
10506: PPUSH
10507: CALL_OW 447
// end else
10511: GO 10577
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
10513: LD_VAR 0 1
10517: PUSH
10518: LD_VAR 0 4
10522: ARRAY
10523: PPUSH
10524: LD_STRING h
10526: PUSH
10527: LD_VAR 0 2
10531: PPUSH
10532: CALL_OW 250
10536: PUSH
10537: LD_VAR 0 2
10541: PPUSH
10542: CALL_OW 251
10546: PUSH
10547: LD_VAR 0 2
10551: PUSH
10552: LD_INT 0
10554: PUSH
10555: LD_INT 0
10557: PUSH
10558: LD_INT 0
10560: PUSH
10561: EMPTY
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: PUSH
10570: EMPTY
10571: LIST
10572: PPUSH
10573: CALL_OW 446
10577: GO 10412
10579: POP
10580: POP
// end ;
10581: LD_VAR 0 3
10585: RET
// export function WantRepair ( eng ) ; begin
10586: LD_INT 0
10588: PPUSH
// if GetTaskList ( eng ) > 0 then
10589: LD_VAR 0 1
10593: PPUSH
10594: CALL_OW 437
10598: PUSH
10599: LD_INT 0
10601: GREATER
10602: IFFALSE 10647
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
10604: LD_VAR 0 1
10608: PPUSH
10609: CALL_OW 437
10613: PUSH
10614: LD_INT 1
10616: ARRAY
10617: PUSH
10618: LD_INT 1
10620: ARRAY
10621: PUSH
10622: LD_STRING o
10624: EQUAL
10625: IFFALSE 10637
// result := true else
10627: LD_ADDR_VAR 0 2
10631: PUSH
10632: LD_INT 1
10634: ST_TO_ADDR
10635: GO 10645
// result := false ;
10637: LD_ADDR_VAR 0 2
10641: PUSH
10642: LD_INT 0
10644: ST_TO_ADDR
// end else
10645: GO 10655
// result := false ;
10647: LD_ADDR_VAR 0 2
10651: PUSH
10652: LD_INT 0
10654: ST_TO_ADDR
// end ;
10655: LD_VAR 0 2
10659: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
10660: LD_INT 0
10662: PPUSH
10663: PPUSH
10664: PPUSH
10665: PPUSH
// if btype = - 1 then
10666: LD_VAR 0 2
10670: PUSH
10671: LD_INT 1
10673: NEG
10674: EQUAL
10675: IFFALSE 10715
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
10677: LD_ADDR_VAR 0 5
10681: PUSH
10682: LD_INT 22
10684: PUSH
10685: LD_VAR 0 1
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 21
10696: PUSH
10697: LD_INT 3
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: PPUSH
10708: CALL_OW 69
10712: ST_TO_ADDR
10713: GO 10753
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
10715: LD_ADDR_VAR 0 5
10719: PUSH
10720: LD_INT 22
10722: PUSH
10723: LD_VAR 0 1
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 30
10734: PUSH
10735: LD_VAR 0 2
10739: PUSH
10740: EMPTY
10741: LIST
10742: LIST
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: PPUSH
10748: CALL_OW 69
10752: ST_TO_ADDR
// list := [ ] ;
10753: LD_ADDR_VAR 0 6
10757: PUSH
10758: EMPTY
10759: ST_TO_ADDR
// for i = 1 to tmp do
10760: LD_ADDR_VAR 0 4
10764: PUSH
10765: DOUBLE
10766: LD_INT 1
10768: DEC
10769: ST_TO_ADDR
10770: LD_VAR 0 5
10774: PUSH
10775: FOR_TO
10776: IFFALSE 10864
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
10778: LD_ADDR_VAR 0 6
10782: PUSH
10783: LD_VAR 0 6
10787: PUSH
10788: LD_VAR 0 5
10792: PUSH
10793: LD_VAR 0 4
10797: ARRAY
10798: PPUSH
10799: CALL_OW 266
10803: PUSH
10804: LD_VAR 0 5
10808: PUSH
10809: LD_VAR 0 4
10813: ARRAY
10814: PPUSH
10815: CALL_OW 250
10819: PUSH
10820: LD_VAR 0 5
10824: PUSH
10825: LD_VAR 0 4
10829: ARRAY
10830: PPUSH
10831: CALL_OW 251
10835: PUSH
10836: LD_VAR 0 5
10840: PUSH
10841: LD_VAR 0 4
10845: ARRAY
10846: PPUSH
10847: CALL_OW 254
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: LIST
10856: LIST
10857: PUSH
10858: EMPTY
10859: LIST
10860: ADD
10861: ST_TO_ADDR
10862: GO 10775
10864: POP
10865: POP
// result = list ;
10866: LD_ADDR_VAR 0 3
10870: PUSH
10871: LD_VAR 0 6
10875: ST_TO_ADDR
// end ;
10876: LD_VAR 0 3
10880: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
10881: LD_INT 0
10883: PPUSH
10884: PPUSH
10885: PPUSH
10886: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
10887: LD_VAR 0 1
10891: PPUSH
10892: LD_INT 81
10894: PUSH
10895: LD_VAR 0 1
10899: PPUSH
10900: CALL_OW 255
10904: PUSH
10905: EMPTY
10906: LIST
10907: LIST
10908: PPUSH
10909: CALL_OW 69
10913: PPUSH
10914: LD_VAR 0 1
10918: PPUSH
10919: CALL_OW 74
10923: PPUSH
10924: CALL_OW 296
10928: PUSH
10929: LD_INT 18
10931: LESS
10932: IFFALSE 10977
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
10934: LD_VAR 0 1
10938: PPUSH
10939: LD_INT 81
10941: PUSH
10942: LD_VAR 0 1
10946: PPUSH
10947: CALL_OW 255
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PPUSH
10961: LD_VAR 0 1
10965: PPUSH
10966: CALL_OW 74
10970: PPUSH
10971: CALL_OW 115
10975: GO 10996
// ComMoveXY ( behemoth , x , y ) ;
10977: LD_VAR 0 1
10981: PPUSH
10982: LD_VAR 0 4
10986: PPUSH
10987: LD_VAR 0 5
10991: PPUSH
10992: CALL_OW 111
// if time_lapsers_list > 0 then
10996: LD_VAR 0 2
11000: PUSH
11001: LD_INT 0
11003: GREATER
11004: IFFALSE 11194
// begin for i = 1 to time_lapsers_list do
11006: LD_ADDR_VAR 0 7
11010: PUSH
11011: DOUBLE
11012: LD_INT 1
11014: DEC
11015: ST_TO_ADDR
11016: LD_VAR 0 2
11020: PUSH
11021: FOR_TO
11022: IFFALSE 11192
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11024: LD_VAR 0 2
11028: PUSH
11029: LD_VAR 0 7
11033: ARRAY
11034: PPUSH
11035: CALL_OW 256
11039: PUSH
11040: LD_INT 250
11042: GREATEREQUAL
11043: PUSH
11044: LD_VAR 0 2
11048: PUSH
11049: LD_VAR 0 7
11053: ARRAY
11054: PPUSH
11055: LD_VAR 0 1
11059: PPUSH
11060: CALL_OW 296
11064: PUSH
11065: LD_INT 9
11067: GREATER
11068: AND
11069: IFFALSE 11106
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11071: LD_VAR 0 2
11075: PUSH
11076: LD_VAR 0 7
11080: ARRAY
11081: PPUSH
11082: LD_VAR 0 1
11086: PPUSH
11087: CALL_OW 250
11091: PPUSH
11092: LD_VAR 0 1
11096: PPUSH
11097: CALL_OW 251
11101: PPUSH
11102: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11106: LD_VAR 0 2
11110: PUSH
11111: LD_VAR 0 7
11115: ARRAY
11116: PPUSH
11117: CALL_OW 256
11121: PUSH
11122: LD_INT 500
11124: LESS
11125: PUSH
11126: LD_VAR 0 1
11130: PPUSH
11131: CALL_OW 256
11135: PUSH
11136: LD_INT 700
11138: GREATER
11139: AND
11140: IFFALSE 11190
// for p = 1 to mechanic_list do
11142: LD_ADDR_VAR 0 8
11146: PUSH
11147: DOUBLE
11148: LD_INT 1
11150: DEC
11151: ST_TO_ADDR
11152: LD_VAR 0 3
11156: PUSH
11157: FOR_TO
11158: IFFALSE 11188
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11160: LD_VAR 0 3
11164: PUSH
11165: LD_VAR 0 8
11169: ARRAY
11170: PPUSH
11171: LD_VAR 0 2
11175: PUSH
11176: LD_VAR 0 7
11180: ARRAY
11181: PPUSH
11182: CALL_OW 129
11186: GO 11157
11188: POP
11189: POP
// end ;
11190: GO 11021
11192: POP
11193: POP
// end ; if mechanic_list then
11194: LD_VAR 0 3
11198: IFFALSE 11379
// begin for i = 1 to mechanic_list do
11200: LD_ADDR_VAR 0 7
11204: PUSH
11205: DOUBLE
11206: LD_INT 1
11208: DEC
11209: ST_TO_ADDR
11210: LD_VAR 0 3
11214: PUSH
11215: FOR_TO
11216: IFFALSE 11377
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11218: LD_VAR 0 3
11222: PUSH
11223: LD_VAR 0 7
11227: ARRAY
11228: PPUSH
11229: CALL_OW 256
11233: PUSH
11234: LD_INT 333
11236: LESS
11237: IFFALSE 11261
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11239: LD_ADDR_EXP 14
11243: PUSH
11244: LD_EXP 14
11248: PUSH
11249: LD_VAR 0 3
11253: PUSH
11254: LD_VAR 0 7
11258: ARRAY
11259: DIFF
11260: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11261: LD_VAR 0 3
11265: PUSH
11266: LD_VAR 0 7
11270: ARRAY
11271: PPUSH
11272: LD_VAR 0 1
11276: PPUSH
11277: CALL_OW 296
11281: PUSH
11282: LD_INT 9
11284: GREATER
11285: PUSH
11286: LD_VAR 0 3
11290: PUSH
11291: LD_VAR 0 7
11295: ARRAY
11296: PPUSH
11297: CALL_OW 314
11301: NOT
11302: AND
11303: IFFALSE 11340
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11305: LD_VAR 0 3
11309: PUSH
11310: LD_VAR 0 7
11314: ARRAY
11315: PPUSH
11316: LD_VAR 0 1
11320: PPUSH
11321: CALL_OW 250
11325: PPUSH
11326: LD_VAR 0 1
11330: PPUSH
11331: CALL_OW 251
11335: PPUSH
11336: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11340: LD_VAR 0 1
11344: PPUSH
11345: CALL_OW 256
11349: PUSH
11350: LD_INT 700
11352: LESS
11353: IFFALSE 11375
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11355: LD_VAR 0 3
11359: PUSH
11360: LD_VAR 0 7
11364: ARRAY
11365: PPUSH
11366: LD_VAR 0 1
11370: PPUSH
11371: CALL_OW 129
// end ;
11375: GO 11215
11377: POP
11378: POP
// end ; end ;
11379: LD_VAR 0 6
11383: RET
// export function GetBehemoth ( side ) ; begin
11384: LD_INT 0
11386: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
11387: LD_ADDR_VAR 0 2
11391: PUSH
11392: LD_INT 22
11394: PUSH
11395: LD_VAR 0 1
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: PUSH
11404: LD_INT 31
11406: PUSH
11407: LD_INT 25
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: EMPTY
11415: LIST
11416: LIST
11417: PPUSH
11418: CALL_OW 69
11422: ST_TO_ADDR
// end ;
11423: LD_VAR 0 2
11427: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
11428: LD_INT 0
11430: PPUSH
11431: PPUSH
11432: PPUSH
11433: PPUSH
11434: PPUSH
11435: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
11436: LD_ADDR_VAR 0 6
11440: PUSH
11441: LD_VAR 0 2
11445: PPUSH
11446: CALL_OW 435
11450: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
11451: LD_ADDR_VAR 0 5
11455: PUSH
11456: LD_INT 22
11458: PUSH
11459: LD_VAR 0 1
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: LD_INT 2
11470: PUSH
11471: LD_INT 25
11473: PUSH
11474: LD_INT 2
11476: PUSH
11477: EMPTY
11478: LIST
11479: LIST
11480: PUSH
11481: LD_INT 25
11483: PUSH
11484: LD_INT 16
11486: PUSH
11487: EMPTY
11488: LIST
11489: LIST
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: LIST
11495: PUSH
11496: EMPTY
11497: LIST
11498: LIST
11499: PPUSH
11500: CALL_OW 69
11504: ST_TO_ADDR
// if skr then
11505: LD_VAR 0 6
11509: IFFALSE 11674
// begin if engs then
11511: LD_VAR 0 5
11515: IFFALSE 11674
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
11517: LD_ADDR_VAR 0 8
11521: PUSH
11522: LD_VAR 0 6
11526: PUSH
11527: LD_INT 1
11529: ARRAY
11530: PPUSH
11531: LD_VAR 0 6
11535: PUSH
11536: LD_INT 2
11538: ARRAY
11539: PPUSH
11540: CALL_OW 284
11544: ST_TO_ADDR
// if am > engs then
11545: LD_VAR 0 8
11549: PUSH
11550: LD_VAR 0 5
11554: GREATER
11555: IFFALSE 11567
// am := engs ;
11557: LD_ADDR_VAR 0 8
11561: PUSH
11562: LD_VAR 0 5
11566: ST_TO_ADDR
// for i = 1 to am do
11567: LD_ADDR_VAR 0 7
11571: PUSH
11572: DOUBLE
11573: LD_INT 1
11575: DEC
11576: ST_TO_ADDR
11577: LD_VAR 0 8
11581: PUSH
11582: FOR_TO
11583: IFFALSE 11672
// begin if IsInUnit ( engs [ i ] ) then
11585: LD_VAR 0 5
11589: PUSH
11590: LD_VAR 0 7
11594: ARRAY
11595: PPUSH
11596: CALL_OW 310
11600: IFFALSE 11619
// ComExitBuilding ( engs [ i ] ) else
11602: LD_VAR 0 5
11606: PUSH
11607: LD_VAR 0 7
11611: ARRAY
11612: PPUSH
11613: CALL_OW 122
11617: GO 11670
// if not HasTask ( engs [ i ] ) then
11619: LD_VAR 0 5
11623: PUSH
11624: LD_VAR 0 7
11628: ARRAY
11629: PPUSH
11630: CALL_OW 314
11634: NOT
11635: IFFALSE 11670
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
11637: LD_VAR 0 5
11641: PUSH
11642: LD_VAR 0 7
11646: ARRAY
11647: PPUSH
11648: LD_VAR 0 6
11652: PUSH
11653: LD_INT 1
11655: ARRAY
11656: PPUSH
11657: LD_VAR 0 6
11661: PUSH
11662: LD_INT 2
11664: ARRAY
11665: PPUSH
11666: CALL_OW 117
// end ;
11670: GO 11582
11672: POP
11673: POP
// end ; end ; end ; end_of_file
11674: LD_VAR 0 3
11678: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
11679: LD_INT 0
11681: PPUSH
11682: PPUSH
// uc_side := 1 ;
11683: LD_ADDR_OWVAR 20
11687: PUSH
11688: LD_INT 1
11690: ST_TO_ADDR
// uc_nation := 1 ;
11691: LD_ADDR_OWVAR 21
11695: PUSH
11696: LD_INT 1
11698: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
11699: LD_ADDR_VAR 0 2
11703: PUSH
11704: LD_INT 6
11706: PUSH
11707: LD_INT 5
11709: PUSH
11710: LD_INT 4
11712: PUSH
11713: EMPTY
11714: LIST
11715: LIST
11716: LIST
11717: PUSH
11718: LD_OWVAR 67
11722: ARRAY
11723: ST_TO_ADDR
// game_status := false ;
11724: LD_ADDR_EXP 28
11728: PUSH
11729: LD_INT 0
11731: ST_TO_ADDR
// helps_arrive := false ;
11732: LD_ADDR_EXP 29
11736: PUSH
11737: LD_INT 0
11739: ST_TO_ADDR
// helps_can_arrive := false ;
11740: LD_ADDR_EXP 30
11744: PUSH
11745: LD_INT 0
11747: ST_TO_ADDR
// beta_come := false ;
11748: LD_ADDR_EXP 31
11752: PUSH
11753: LD_INT 0
11755: ST_TO_ADDR
// gamma_come := false ;
11756: LD_ADDR_EXP 32
11760: PUSH
11761: LD_INT 0
11763: ST_TO_ADDR
// zeta_come := false ;
11764: LD_ADDR_EXP 33
11768: PUSH
11769: LD_INT 0
11771: ST_TO_ADDR
// mine_ck := false ;
11772: LD_ADDR_EXP 34
11776: PUSH
11777: LD_INT 0
11779: ST_TO_ADDR
// sib_bomb_constructed := false ;
11780: LD_ADDR_EXP 35
11784: PUSH
11785: LD_INT 0
11787: ST_TO_ADDR
// mine_constructed := false ;
11788: LD_ADDR_EXP 36
11792: PUSH
11793: LD_INT 0
11795: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
11796: LD_INT 35
11798: PPUSH
11799: CALL_OW 274
11803: PPUSH
11804: LD_INT 1
11806: PPUSH
11807: LD_INT 200
11809: PUSH
11810: LD_INT 100
11812: PUSH
11813: LD_INT 70
11815: PUSH
11816: EMPTY
11817: LIST
11818: LIST
11819: LIST
11820: PUSH
11821: LD_OWVAR 67
11825: ARRAY
11826: PPUSH
11827: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
11831: LD_INT 35
11833: PPUSH
11834: LD_INT 4
11836: PPUSH
11837: CALL_OW 235
// hc_importance := 100 ;
11841: LD_ADDR_OWVAR 32
11845: PUSH
11846: LD_INT 100
11848: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
11849: LD_INT 1
11851: PPUSH
11852: LD_INT 2
11854: PPUSH
11855: LD_VAR 0 2
11859: PUSH
11860: LD_INT 1
11862: PLUS
11863: PPUSH
11864: CALL_OW 380
// hc_gallery := hardch ;
11868: LD_ADDR_OWVAR 33
11872: PUSH
11873: LD_STRING hardch
11875: ST_TO_ADDR
// hc_face_number := 1 ;
11876: LD_ADDR_OWVAR 34
11880: PUSH
11881: LD_INT 1
11883: ST_TO_ADDR
// guyA := CreateHuman ;
11884: LD_ADDR_EXP 37
11888: PUSH
11889: CALL_OW 44
11893: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
11894: LD_INT 1
11896: PPUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_VAR 0 2
11904: PPUSH
11905: CALL_OW 380
// hc_face_number := 2 ;
11909: LD_ADDR_OWVAR 34
11913: PUSH
11914: LD_INT 2
11916: ST_TO_ADDR
// guyB := CreateHuman ;
11917: LD_ADDR_EXP 38
11921: PUSH
11922: CALL_OW 44
11926: ST_TO_ADDR
// hc_importance := 0 ;
11927: LD_ADDR_OWVAR 32
11931: PUSH
11932: LD_INT 0
11934: ST_TO_ADDR
// hc_gallery :=  ;
11935: LD_ADDR_OWVAR 33
11939: PUSH
11940: LD_STRING 
11942: ST_TO_ADDR
// end ;
11943: LD_VAR 0 1
11947: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
11948: LD_INT 0
11950: PPUSH
11951: PPUSH
11952: PPUSH
11953: PPUSH
11954: PPUSH
11955: PPUSH
11956: PPUSH
11957: PPUSH
11958: PPUSH
// uc_side := 4 ;
11959: LD_ADDR_OWVAR 20
11963: PUSH
11964: LD_INT 4
11966: ST_TO_ADDR
// uc_nation := 1 ;
11967: LD_ADDR_OWVAR 21
11971: PUSH
11972: LD_INT 1
11974: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
11975: LD_ADDR_VAR 0 10
11979: PUSH
11980: LD_INT 6
11982: PUSH
11983: LD_INT 5
11985: PUSH
11986: LD_INT 4
11988: PUSH
11989: EMPTY
11990: LIST
11991: LIST
11992: LIST
11993: PUSH
11994: LD_OWVAR 67
11998: ARRAY
11999: ST_TO_ADDR
// Beta_Squad := [ ] ;
12000: LD_ADDR_EXP 39
12004: PUSH
12005: EMPTY
12006: ST_TO_ADDR
// case num of 1 :
12007: LD_VAR 0 1
12011: PUSH
12012: LD_INT 1
12014: DOUBLE
12015: EQUAL
12016: IFTRUE 12020
12018: GO 12063
12020: POP
// begin sold := 2 ;
12021: LD_ADDR_VAR 0 5
12025: PUSH
12026: LD_INT 2
12028: ST_TO_ADDR
// sci := 1 ;
12029: LD_ADDR_VAR 0 6
12033: PUSH
12034: LD_INT 1
12036: ST_TO_ADDR
// mech := 2 ;
12037: LD_ADDR_VAR 0 7
12041: PUSH
12042: LD_INT 2
12044: ST_TO_ADDR
// tank := 1 ;
12045: LD_ADDR_VAR 0 8
12049: PUSH
12050: LD_INT 1
12052: ST_TO_ADDR
// cargo := 1 ;
12053: LD_ADDR_VAR 0 9
12057: PUSH
12058: LD_INT 1
12060: ST_TO_ADDR
// end ; 2 :
12061: GO 12166
12063: LD_INT 2
12065: DOUBLE
12066: EQUAL
12067: IFTRUE 12071
12069: GO 12114
12071: POP
// begin sold := 2 ;
12072: LD_ADDR_VAR 0 5
12076: PUSH
12077: LD_INT 2
12079: ST_TO_ADDR
// sci := 1 ;
12080: LD_ADDR_VAR 0 6
12084: PUSH
12085: LD_INT 1
12087: ST_TO_ADDR
// mech := 1 ;
12088: LD_ADDR_VAR 0 7
12092: PUSH
12093: LD_INT 1
12095: ST_TO_ADDR
// tank := 1 ;
12096: LD_ADDR_VAR 0 8
12100: PUSH
12101: LD_INT 1
12103: ST_TO_ADDR
// cargo := 0 ;
12104: LD_ADDR_VAR 0 9
12108: PUSH
12109: LD_INT 0
12111: ST_TO_ADDR
// end ; 3 :
12112: GO 12166
12114: LD_INT 3
12116: DOUBLE
12117: EQUAL
12118: IFTRUE 12122
12120: GO 12165
12122: POP
// begin sold := 1 ;
12123: LD_ADDR_VAR 0 5
12127: PUSH
12128: LD_INT 1
12130: ST_TO_ADDR
// sci := 1 ;
12131: LD_ADDR_VAR 0 6
12135: PUSH
12136: LD_INT 1
12138: ST_TO_ADDR
// mech := 1 ;
12139: LD_ADDR_VAR 0 7
12143: PUSH
12144: LD_INT 1
12146: ST_TO_ADDR
// tank := 1 ;
12147: LD_ADDR_VAR 0 8
12151: PUSH
12152: LD_INT 1
12154: ST_TO_ADDR
// cargo := 0 ;
12155: LD_ADDR_VAR 0 9
12159: PUSH
12160: LD_INT 0
12162: ST_TO_ADDR
// end ; end ;
12163: GO 12166
12165: POP
// for i = 1 to sold do
12166: LD_ADDR_VAR 0 3
12170: PUSH
12171: DOUBLE
12172: LD_INT 1
12174: DEC
12175: ST_TO_ADDR
12176: LD_VAR 0 5
12180: PUSH
12181: FOR_TO
12182: IFFALSE 12254
// begin if i = 1 then
12184: LD_VAR 0 3
12188: PUSH
12189: LD_INT 1
12191: EQUAL
12192: IFFALSE 12211
// PrepareHuman ( sex_male , 1 , skill ) else
12194: LD_INT 1
12196: PPUSH
12197: LD_INT 1
12199: PPUSH
12200: LD_VAR 0 10
12204: PPUSH
12205: CALL_OW 380
12209: GO 12226
// PrepareHuman ( false , 1 , skill ) ;
12211: LD_INT 0
12213: PPUSH
12214: LD_INT 1
12216: PPUSH
12217: LD_VAR 0 10
12221: PPUSH
12222: CALL_OW 380
// un := CreateHuman ;
12226: LD_ADDR_VAR 0 4
12230: PUSH
12231: CALL_OW 44
12235: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12236: LD_ADDR_EXP 39
12240: PUSH
12241: LD_EXP 39
12245: PUSH
12246: LD_VAR 0 4
12250: ADD
12251: ST_TO_ADDR
// end ;
12252: GO 12181
12254: POP
12255: POP
// for i = 1 to mech do
12256: LD_ADDR_VAR 0 3
12260: PUSH
12261: DOUBLE
12262: LD_INT 1
12264: DEC
12265: ST_TO_ADDR
12266: LD_VAR 0 7
12270: PUSH
12271: FOR_TO
12272: IFFALSE 12329
// begin PrepareHuman ( false , 3 , skill ) ;
12274: LD_INT 0
12276: PPUSH
12277: LD_INT 3
12279: PPUSH
12280: LD_VAR 0 10
12284: PPUSH
12285: CALL_OW 380
// un := CreateHuman ;
12289: LD_ADDR_VAR 0 4
12293: PUSH
12294: CALL_OW 44
12298: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12299: LD_VAR 0 4
12303: PPUSH
12304: LD_INT 3
12306: PPUSH
12307: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12311: LD_ADDR_EXP 39
12315: PUSH
12316: LD_EXP 39
12320: PUSH
12321: LD_VAR 0 4
12325: ADD
12326: ST_TO_ADDR
// end ;
12327: GO 12271
12329: POP
12330: POP
// for i = 1 to sci do
12331: LD_ADDR_VAR 0 3
12335: PUSH
12336: DOUBLE
12337: LD_INT 1
12339: DEC
12340: ST_TO_ADDR
12341: LD_VAR 0 6
12345: PUSH
12346: FOR_TO
12347: IFFALSE 12392
// begin PrepareHuman ( false , 4 , skill ) ;
12349: LD_INT 0
12351: PPUSH
12352: LD_INT 4
12354: PPUSH
12355: LD_VAR 0 10
12359: PPUSH
12360: CALL_OW 380
// un := CreateHuman ;
12364: LD_ADDR_VAR 0 4
12368: PUSH
12369: CALL_OW 44
12373: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12374: LD_ADDR_EXP 39
12378: PUSH
12379: LD_EXP 39
12383: PUSH
12384: LD_VAR 0 4
12388: ADD
12389: ST_TO_ADDR
// end ;
12390: GO 12346
12392: POP
12393: POP
// for i = 1 to tank do
12394: LD_ADDR_VAR 0 3
12398: PUSH
12399: DOUBLE
12400: LD_INT 1
12402: DEC
12403: ST_TO_ADDR
12404: LD_VAR 0 8
12408: PUSH
12409: FOR_TO
12410: IFFALSE 12523
// begin Randomize ;
12412: CALL_OW 10
// vc_chassis := us_medium_tracked ;
12416: LD_ADDR_OWVAR 37
12420: PUSH
12421: LD_INT 3
12423: ST_TO_ADDR
// vc_engine := engine_solar ;
12424: LD_ADDR_OWVAR 39
12428: PUSH
12429: LD_INT 2
12431: ST_TO_ADDR
// vc_control := control_manual ;
12432: LD_ADDR_OWVAR 38
12436: PUSH
12437: LD_INT 1
12439: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
12440: LD_ADDR_OWVAR 40
12444: PUSH
12445: LD_INT 4
12447: PUSH
12448: LD_INT 5
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PUSH
12455: LD_INT 1
12457: PPUSH
12458: LD_INT 2
12460: PPUSH
12461: CALL_OW 12
12465: ARRAY
12466: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
12467: LD_ADDR_OWVAR 41
12471: PUSH
12472: LD_INT 35
12474: PPUSH
12475: LD_INT 55
12477: PPUSH
12478: CALL_OW 12
12482: ST_TO_ADDR
// un := CreateVehicle ;
12483: LD_ADDR_VAR 0 4
12487: PUSH
12488: CALL_OW 45
12492: ST_TO_ADDR
// SetTag ( un , 5 ) ;
12493: LD_VAR 0 4
12497: PPUSH
12498: LD_INT 5
12500: PPUSH
12501: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12505: LD_ADDR_EXP 39
12509: PUSH
12510: LD_EXP 39
12514: PUSH
12515: LD_VAR 0 4
12519: ADD
12520: ST_TO_ADDR
// end ;
12521: GO 12409
12523: POP
12524: POP
// if cargo then
12525: LD_VAR 0 9
12529: IFFALSE 12632
// begin vc_chassis := us_medium_tracked ;
12531: LD_ADDR_OWVAR 37
12535: PUSH
12536: LD_INT 3
12538: ST_TO_ADDR
// vc_engine := engine_solar ;
12539: LD_ADDR_OWVAR 39
12543: PUSH
12544: LD_INT 2
12546: ST_TO_ADDR
// vc_control := control_manual ;
12547: LD_ADDR_OWVAR 38
12551: PUSH
12552: LD_INT 1
12554: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
12555: LD_ADDR_OWVAR 40
12559: PUSH
12560: LD_INT 12
12562: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
12563: LD_ADDR_OWVAR 41
12567: PUSH
12568: LD_INT 35
12570: PPUSH
12571: LD_INT 55
12573: PPUSH
12574: CALL_OW 12
12578: ST_TO_ADDR
// un := CreateVehicle ;
12579: LD_ADDR_VAR 0 4
12583: PUSH
12584: CALL_OW 45
12588: ST_TO_ADDR
// SetTag ( un , 5 ) ;
12589: LD_VAR 0 4
12593: PPUSH
12594: LD_INT 5
12596: PPUSH
12597: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12601: LD_ADDR_EXP 39
12605: PUSH
12606: LD_EXP 39
12610: PUSH
12611: LD_VAR 0 4
12615: ADD
12616: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
12617: LD_VAR 0 4
12621: PPUSH
12622: LD_INT 1
12624: PPUSH
12625: LD_INT 60
12627: PPUSH
12628: CALL_OW 290
// end ; end ;
12632: LD_VAR 0 2
12636: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
12637: LD_INT 0
12639: PPUSH
12640: PPUSH
12641: PPUSH
12642: PPUSH
12643: PPUSH
12644: PPUSH
12645: PPUSH
12646: PPUSH
12647: PPUSH
12648: PPUSH
// uc_side := 4 ;
12649: LD_ADDR_OWVAR 20
12653: PUSH
12654: LD_INT 4
12656: ST_TO_ADDR
// uc_nation := 1 ;
12657: LD_ADDR_OWVAR 21
12661: PUSH
12662: LD_INT 1
12664: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12665: LD_ADDR_VAR 0 11
12669: PUSH
12670: LD_INT 6
12672: PUSH
12673: LD_INT 5
12675: PUSH
12676: LD_INT 4
12678: PUSH
12679: EMPTY
12680: LIST
12681: LIST
12682: LIST
12683: PUSH
12684: LD_OWVAR 67
12688: ARRAY
12689: ST_TO_ADDR
// Gamma_Squad := [ ] ;
12690: LD_ADDR_EXP 40
12694: PUSH
12695: EMPTY
12696: ST_TO_ADDR
// case num of 1 :
12697: LD_VAR 0 1
12701: PUSH
12702: LD_INT 1
12704: DOUBLE
12705: EQUAL
12706: IFTRUE 12710
12708: GO 12761
12710: POP
// begin sold := 2 ;
12711: LD_ADDR_VAR 0 5
12715: PUSH
12716: LD_INT 2
12718: ST_TO_ADDR
// eng := 2 ;
12719: LD_ADDR_VAR 0 6
12723: PUSH
12724: LD_INT 2
12726: ST_TO_ADDR
// sci := 0 ;
12727: LD_ADDR_VAR 0 7
12731: PUSH
12732: LD_INT 0
12734: ST_TO_ADDR
// mech := 1 ;
12735: LD_ADDR_VAR 0 8
12739: PUSH
12740: LD_INT 1
12742: ST_TO_ADDR
// tank := 0 ;
12743: LD_ADDR_VAR 0 9
12747: PUSH
12748: LD_INT 0
12750: ST_TO_ADDR
// cargo := 1 ;
12751: LD_ADDR_VAR 0 10
12755: PUSH
12756: LD_INT 1
12758: ST_TO_ADDR
// end ; 2 :
12759: GO 12880
12761: LD_INT 2
12763: DOUBLE
12764: EQUAL
12765: IFTRUE 12769
12767: GO 12820
12769: POP
// begin sold := 1 ;
12770: LD_ADDR_VAR 0 5
12774: PUSH
12775: LD_INT 1
12777: ST_TO_ADDR
// eng := 2 ;
12778: LD_ADDR_VAR 0 6
12782: PUSH
12783: LD_INT 2
12785: ST_TO_ADDR
// sci := 0 ;
12786: LD_ADDR_VAR 0 7
12790: PUSH
12791: LD_INT 0
12793: ST_TO_ADDR
// mech := 1 ;
12794: LD_ADDR_VAR 0 8
12798: PUSH
12799: LD_INT 1
12801: ST_TO_ADDR
// tank := 0 ;
12802: LD_ADDR_VAR 0 9
12806: PUSH
12807: LD_INT 0
12809: ST_TO_ADDR
// cargo := 1 ;
12810: LD_ADDR_VAR 0 10
12814: PUSH
12815: LD_INT 1
12817: ST_TO_ADDR
// end ; 3 :
12818: GO 12880
12820: LD_INT 3
12822: DOUBLE
12823: EQUAL
12824: IFTRUE 12828
12826: GO 12879
12828: POP
// begin sold := 1 ;
12829: LD_ADDR_VAR 0 5
12833: PUSH
12834: LD_INT 1
12836: ST_TO_ADDR
// eng := 1 ;
12837: LD_ADDR_VAR 0 6
12841: PUSH
12842: LD_INT 1
12844: ST_TO_ADDR
// sci := 0 ;
12845: LD_ADDR_VAR 0 7
12849: PUSH
12850: LD_INT 0
12852: ST_TO_ADDR
// mech := 1 ;
12853: LD_ADDR_VAR 0 8
12857: PUSH
12858: LD_INT 1
12860: ST_TO_ADDR
// tank := 0 ;
12861: LD_ADDR_VAR 0 9
12865: PUSH
12866: LD_INT 0
12868: ST_TO_ADDR
// cargo := 1 ;
12869: LD_ADDR_VAR 0 10
12873: PUSH
12874: LD_INT 1
12876: ST_TO_ADDR
// end ; end ;
12877: GO 12880
12879: POP
// for i = 1 to sold do
12880: LD_ADDR_VAR 0 3
12884: PUSH
12885: DOUBLE
12886: LD_INT 1
12888: DEC
12889: ST_TO_ADDR
12890: LD_VAR 0 5
12894: PUSH
12895: FOR_TO
12896: IFFALSE 12968
// begin if i = 1 then
12898: LD_VAR 0 3
12902: PUSH
12903: LD_INT 1
12905: EQUAL
12906: IFFALSE 12925
// PrepareHuman ( sex_male , 1 , skill ) else
12908: LD_INT 1
12910: PPUSH
12911: LD_INT 1
12913: PPUSH
12914: LD_VAR 0 11
12918: PPUSH
12919: CALL_OW 380
12923: GO 12940
// PrepareHuman ( false , 1 , skill ) ;
12925: LD_INT 0
12927: PPUSH
12928: LD_INT 1
12930: PPUSH
12931: LD_VAR 0 11
12935: PPUSH
12936: CALL_OW 380
// un := CreateHuman ;
12940: LD_ADDR_VAR 0 4
12944: PUSH
12945: CALL_OW 44
12949: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
12950: LD_ADDR_EXP 40
12954: PUSH
12955: LD_EXP 40
12959: PUSH
12960: LD_VAR 0 4
12964: ADD
12965: ST_TO_ADDR
// end ;
12966: GO 12895
12968: POP
12969: POP
// for i = 1 to mech do
12970: LD_ADDR_VAR 0 3
12974: PUSH
12975: DOUBLE
12976: LD_INT 1
12978: DEC
12979: ST_TO_ADDR
12980: LD_VAR 0 8
12984: PUSH
12985: FOR_TO
12986: IFFALSE 13043
// begin PrepareHuman ( false , 3 , skill ) ;
12988: LD_INT 0
12990: PPUSH
12991: LD_INT 3
12993: PPUSH
12994: LD_VAR 0 11
12998: PPUSH
12999: CALL_OW 380
// un := CreateHuman ;
13003: LD_ADDR_VAR 0 4
13007: PUSH
13008: CALL_OW 44
13012: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13013: LD_VAR 0 4
13017: PPUSH
13018: LD_INT 3
13020: PPUSH
13021: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13025: LD_ADDR_EXP 40
13029: PUSH
13030: LD_EXP 40
13034: PUSH
13035: LD_VAR 0 4
13039: ADD
13040: ST_TO_ADDR
// end ;
13041: GO 12985
13043: POP
13044: POP
// for i = 1 to eng do
13045: LD_ADDR_VAR 0 3
13049: PUSH
13050: DOUBLE
13051: LD_INT 1
13053: DEC
13054: ST_TO_ADDR
13055: LD_VAR 0 6
13059: PUSH
13060: FOR_TO
13061: IFFALSE 13106
// begin PrepareHuman ( false , 2 , skill ) ;
13063: LD_INT 0
13065: PPUSH
13066: LD_INT 2
13068: PPUSH
13069: LD_VAR 0 11
13073: PPUSH
13074: CALL_OW 380
// un := CreateHuman ;
13078: LD_ADDR_VAR 0 4
13082: PUSH
13083: CALL_OW 44
13087: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13088: LD_ADDR_EXP 40
13092: PUSH
13093: LD_EXP 40
13097: PUSH
13098: LD_VAR 0 4
13102: ADD
13103: ST_TO_ADDR
// end ;
13104: GO 13060
13106: POP
13107: POP
// for i = 1 to tank do
13108: LD_ADDR_VAR 0 3
13112: PUSH
13113: DOUBLE
13114: LD_INT 1
13116: DEC
13117: ST_TO_ADDR
13118: LD_VAR 0 9
13122: PUSH
13123: FOR_TO
13124: IFFALSE 13237
// begin Randomize ;
13126: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13130: LD_ADDR_OWVAR 37
13134: PUSH
13135: LD_INT 2
13137: ST_TO_ADDR
// vc_engine := engine_siberite ;
13138: LD_ADDR_OWVAR 39
13142: PUSH
13143: LD_INT 3
13145: ST_TO_ADDR
// vc_control := control_manual ;
13146: LD_ADDR_OWVAR 38
13150: PUSH
13151: LD_INT 1
13153: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13154: LD_ADDR_OWVAR 40
13158: PUSH
13159: LD_INT 7
13161: PUSH
13162: LD_INT 9
13164: PUSH
13165: EMPTY
13166: LIST
13167: LIST
13168: PUSH
13169: LD_INT 1
13171: PPUSH
13172: LD_INT 2
13174: PPUSH
13175: CALL_OW 12
13179: ARRAY
13180: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13181: LD_ADDR_OWVAR 41
13185: PUSH
13186: LD_INT 35
13188: PPUSH
13189: LD_INT 55
13191: PPUSH
13192: CALL_OW 12
13196: ST_TO_ADDR
// un := CreateVehicle ;
13197: LD_ADDR_VAR 0 4
13201: PUSH
13202: CALL_OW 45
13206: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13207: LD_VAR 0 4
13211: PPUSH
13212: LD_INT 5
13214: PPUSH
13215: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13219: LD_ADDR_EXP 40
13223: PUSH
13224: LD_EXP 40
13228: PUSH
13229: LD_VAR 0 4
13233: ADD
13234: ST_TO_ADDR
// end ;
13235: GO 13123
13237: POP
13238: POP
// if cargo then
13239: LD_VAR 0 10
13243: IFFALSE 13361
// begin vc_chassis := us_medium_tracked ;
13245: LD_ADDR_OWVAR 37
13249: PUSH
13250: LD_INT 3
13252: ST_TO_ADDR
// vc_engine := engine_combustion ;
13253: LD_ADDR_OWVAR 39
13257: PUSH
13258: LD_INT 1
13260: ST_TO_ADDR
// vc_control := control_manual ;
13261: LD_ADDR_OWVAR 38
13265: PUSH
13266: LD_INT 1
13268: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13269: LD_ADDR_OWVAR 40
13273: PUSH
13274: LD_INT 12
13276: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13277: LD_ADDR_OWVAR 41
13281: PUSH
13282: LD_INT 35
13284: PPUSH
13285: LD_INT 55
13287: PPUSH
13288: CALL_OW 12
13292: ST_TO_ADDR
// un := CreateVehicle ;
13293: LD_ADDR_VAR 0 4
13297: PUSH
13298: CALL_OW 45
13302: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13303: LD_VAR 0 4
13307: PPUSH
13308: LD_INT 5
13310: PPUSH
13311: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13315: LD_ADDR_EXP 40
13319: PUSH
13320: LD_EXP 40
13324: PUSH
13325: LD_VAR 0 4
13329: ADD
13330: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13331: LD_VAR 0 4
13335: PPUSH
13336: LD_INT 3
13338: PPUSH
13339: LD_INT 30
13341: PPUSH
13342: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13346: LD_VAR 0 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: LD_INT 40
13356: PPUSH
13357: CALL_OW 290
// end ; end ;
13361: LD_VAR 0 2
13365: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13366: LD_INT 0
13368: PPUSH
13369: PPUSH
13370: PPUSH
13371: PPUSH
13372: PPUSH
13373: PPUSH
13374: PPUSH
13375: PPUSH
13376: PPUSH
13377: PPUSH
// uc_side := 4 ;
13378: LD_ADDR_OWVAR 20
13382: PUSH
13383: LD_INT 4
13385: ST_TO_ADDR
// uc_nation := 1 ;
13386: LD_ADDR_OWVAR 21
13390: PUSH
13391: LD_INT 1
13393: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13394: LD_ADDR_VAR 0 10
13398: PUSH
13399: LD_INT 6
13401: PUSH
13402: LD_INT 5
13404: PUSH
13405: LD_INT 4
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: LIST
13412: PUSH
13413: LD_OWVAR 67
13417: ARRAY
13418: ST_TO_ADDR
// Zeta_Squad := [ ] ;
13419: LD_ADDR_EXP 41
13423: PUSH
13424: EMPTY
13425: ST_TO_ADDR
// sold := 1 ;
13426: LD_ADDR_VAR 0 4
13430: PUSH
13431: LD_INT 1
13433: ST_TO_ADDR
// eng := 0 ;
13434: LD_ADDR_VAR 0 5
13438: PUSH
13439: LD_INT 0
13441: ST_TO_ADDR
// sci := 0 ;
13442: LD_ADDR_VAR 0 6
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// mech := 3 ;
13450: LD_ADDR_VAR 0 7
13454: PUSH
13455: LD_INT 3
13457: ST_TO_ADDR
// tank := 3 ;
13458: LD_ADDR_VAR 0 8
13462: PUSH
13463: LD_INT 3
13465: ST_TO_ADDR
// cargo := 0 ;
13466: LD_ADDR_VAR 0 9
13470: PUSH
13471: LD_INT 0
13473: ST_TO_ADDR
// for i = 1 to sold do
13474: LD_ADDR_VAR 0 2
13478: PUSH
13479: DOUBLE
13480: LD_INT 1
13482: DEC
13483: ST_TO_ADDR
13484: LD_VAR 0 4
13488: PUSH
13489: FOR_TO
13490: IFFALSE 13562
// begin if i = 1 then
13492: LD_VAR 0 2
13496: PUSH
13497: LD_INT 1
13499: EQUAL
13500: IFFALSE 13519
// PrepareHuman ( sex_male , 1 , skill ) else
13502: LD_INT 1
13504: PPUSH
13505: LD_INT 1
13507: PPUSH
13508: LD_VAR 0 10
13512: PPUSH
13513: CALL_OW 380
13517: GO 13534
// PrepareHuman ( false , 1 , skill ) ;
13519: LD_INT 0
13521: PPUSH
13522: LD_INT 1
13524: PPUSH
13525: LD_VAR 0 10
13529: PPUSH
13530: CALL_OW 380
// un := CreateHuman ;
13534: LD_ADDR_VAR 0 3
13538: PUSH
13539: CALL_OW 44
13543: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
13544: LD_ADDR_EXP 41
13548: PUSH
13549: LD_EXP 41
13553: PUSH
13554: LD_VAR 0 3
13558: ADD
13559: ST_TO_ADDR
// end ;
13560: GO 13489
13562: POP
13563: POP
// for i = 1 to mech do
13564: LD_ADDR_VAR 0 2
13568: PUSH
13569: DOUBLE
13570: LD_INT 1
13572: DEC
13573: ST_TO_ADDR
13574: LD_VAR 0 7
13578: PUSH
13579: FOR_TO
13580: IFFALSE 13637
// begin PrepareHuman ( false , 3 , skill ) ;
13582: LD_INT 0
13584: PPUSH
13585: LD_INT 3
13587: PPUSH
13588: LD_VAR 0 10
13592: PPUSH
13593: CALL_OW 380
// un := CreateHuman ;
13597: LD_ADDR_VAR 0 3
13601: PUSH
13602: CALL_OW 44
13606: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13607: LD_VAR 0 3
13611: PPUSH
13612: LD_INT 3
13614: PPUSH
13615: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
13619: LD_ADDR_EXP 41
13623: PUSH
13624: LD_EXP 41
13628: PUSH
13629: LD_VAR 0 3
13633: ADD
13634: ST_TO_ADDR
// end ;
13635: GO 13579
13637: POP
13638: POP
// for i = 1 to tank do
13639: LD_ADDR_VAR 0 2
13643: PUSH
13644: DOUBLE
13645: LD_INT 1
13647: DEC
13648: ST_TO_ADDR
13649: LD_VAR 0 8
13653: PUSH
13654: FOR_TO
13655: IFFALSE 13901
// begin Randomize ;
13657: CALL_OW 10
// if i < 3 then
13661: LD_VAR 0 2
13665: PUSH
13666: LD_INT 3
13668: LESS
13669: IFFALSE 13778
// begin vc_chassis := us_medium_tracked ;
13671: LD_ADDR_OWVAR 37
13675: PUSH
13676: LD_INT 3
13678: ST_TO_ADDR
// vc_engine := engine_combustion ;
13679: LD_ADDR_OWVAR 39
13683: PUSH
13684: LD_INT 1
13686: ST_TO_ADDR
// vc_control := control_manual ;
13687: LD_ADDR_OWVAR 38
13691: PUSH
13692: LD_INT 1
13694: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
13695: LD_ADDR_OWVAR 40
13699: PUSH
13700: LD_INT 3
13702: PUSH
13703: LD_INT 9
13705: PUSH
13706: EMPTY
13707: LIST
13708: LIST
13709: PUSH
13710: LD_INT 1
13712: PPUSH
13713: LD_INT 2
13715: PPUSH
13716: CALL_OW 12
13720: ARRAY
13721: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13722: LD_ADDR_OWVAR 41
13726: PUSH
13727: LD_INT 35
13729: PPUSH
13730: LD_INT 55
13732: PPUSH
13733: CALL_OW 12
13737: ST_TO_ADDR
// un := CreateVehicle ;
13738: LD_ADDR_VAR 0 3
13742: PUSH
13743: CALL_OW 45
13747: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13748: LD_VAR 0 3
13752: PPUSH
13753: LD_INT 5
13755: PPUSH
13756: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
13760: LD_ADDR_EXP 41
13764: PUSH
13765: LD_EXP 41
13769: PUSH
13770: LD_VAR 0 3
13774: ADD
13775: ST_TO_ADDR
// end else
13776: GO 13899
// begin uc_nation := 3 ;
13778: LD_ADDR_OWVAR 21
13782: PUSH
13783: LD_INT 3
13785: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
13786: LD_ADDR_OWVAR 37
13790: PUSH
13791: LD_INT 22
13793: ST_TO_ADDR
// vc_engine := engine_combustion ;
13794: LD_ADDR_OWVAR 39
13798: PUSH
13799: LD_INT 1
13801: ST_TO_ADDR
// vc_control := control_manual ;
13802: LD_ADDR_OWVAR 38
13806: PUSH
13807: LD_INT 1
13809: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
13810: LD_ADDR_OWVAR 40
13814: PUSH
13815: LD_INT 51
13817: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13818: LD_ADDR_OWVAR 41
13822: PUSH
13823: LD_INT 35
13825: PPUSH
13826: LD_INT 55
13828: PPUSH
13829: CALL_OW 12
13833: ST_TO_ADDR
// un := CreateVehicle ;
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: CALL_OW 45
13843: ST_TO_ADDR
// SetLives ( un , 496 ) ;
13844: LD_VAR 0 3
13848: PPUSH
13849: LD_INT 496
13851: PPUSH
13852: CALL_OW 234
// SetTag ( un , 5 ) ;
13856: LD_VAR 0 3
13860: PPUSH
13861: LD_INT 5
13863: PPUSH
13864: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
13868: LD_VAR 0 3
13872: PPUSH
13873: LD_INT 2
13875: PPUSH
13876: LD_INT 100
13878: PPUSH
13879: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
13883: LD_ADDR_EXP 41
13887: PUSH
13888: LD_EXP 41
13892: PUSH
13893: LD_VAR 0 3
13897: ADD
13898: ST_TO_ADDR
// end ; end ;
13899: GO 13654
13901: POP
13902: POP
// end ; end_of_file
13903: LD_VAR 0 1
13907: RET
// export function Action ; begin
13908: LD_INT 0
13910: PPUSH
// InGameOn ;
13911: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
13915: LD_INT 151
13917: PPUSH
13918: LD_INT 107
13920: PPUSH
13921: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
13925: LD_EXP 37
13929: PPUSH
13930: LD_INT 171
13932: PPUSH
13933: LD_INT 108
13935: PPUSH
13936: LD_INT 0
13938: PPUSH
13939: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
13943: LD_EXP 38
13947: PPUSH
13948: LD_INT 172
13950: PPUSH
13951: LD_INT 110
13953: PPUSH
13954: LD_INT 0
13956: PPUSH
13957: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
13961: LD_EXP 37
13965: PPUSH
13966: LD_INT 156
13968: PPUSH
13969: LD_INT 107
13971: PPUSH
13972: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
13976: LD_EXP 38
13980: PPUSH
13981: LD_INT 154
13983: PPUSH
13984: LD_INT 105
13986: PPUSH
13987: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
13991: LD_INT 4
13993: PPUSH
13994: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
13998: LD_EXP 37
14002: PPUSH
14003: CALL_OW 250
14007: PUSH
14008: LD_INT 156
14010: EQUAL
14011: PUSH
14012: LD_EXP 37
14016: PPUSH
14017: CALL_OW 251
14021: PUSH
14022: LD_INT 107
14024: EQUAL
14025: AND
14026: IFFALSE 13991
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14028: LD_EXP 37
14032: PUSH
14033: LD_EXP 38
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: PPUSH
14042: LD_INT 35
14044: PPUSH
14045: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14049: LD_EXP 37
14053: PPUSH
14054: LD_STRING D1-A-1
14056: PPUSH
14057: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14061: LD_EXP 38
14065: PPUSH
14066: LD_STRING D1-B-1
14068: PPUSH
14069: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14073: LD_EXP 37
14077: PPUSH
14078: LD_STRING D1-A-2
14080: PPUSH
14081: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14085: LD_EXP 38
14089: PPUSH
14090: LD_STRING D1-B-2
14092: PPUSH
14093: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14097: LD_EXP 37
14101: PUSH
14102: LD_EXP 38
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: PPUSH
14111: LD_INT 147
14113: PPUSH
14114: LD_INT 108
14116: PPUSH
14117: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14121: LD_EXP 37
14125: PPUSH
14126: LD_STRING D1-A-3
14128: PPUSH
14129: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14133: LD_INT 4
14135: PPUSH
14136: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14140: LD_EXP 37
14144: PPUSH
14145: LD_INT 35
14147: PPUSH
14148: CALL_OW 296
14152: PUSH
14153: LD_INT 8
14155: LESS
14156: IFFALSE 14133
// ComTurnUnit ( guyA , guyB ) ;
14158: LD_EXP 37
14162: PPUSH
14163: LD_EXP 38
14167: PPUSH
14168: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14172: LD_EXP 38
14176: PPUSH
14177: LD_EXP 37
14181: PPUSH
14182: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14186: LD_EXP 37
14190: PPUSH
14191: LD_STRING D1-A-10
14193: PPUSH
14194: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14198: LD_EXP 38
14202: PPUSH
14203: LD_STRING D1-B-10
14205: PPUSH
14206: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14210: LD_EXP 37
14214: PPUSH
14215: LD_STRING D1-A-11
14217: PPUSH
14218: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14222: LD_EXP 38
14226: PPUSH
14227: LD_STRING D1-B-11
14229: PPUSH
14230: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14234: LD_EXP 37
14238: PPUSH
14239: LD_STRING D1-A-12
14241: PPUSH
14242: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14246: LD_EXP 38
14250: PPUSH
14251: LD_STRING D1-B-12
14253: PPUSH
14254: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14258: LD_EXP 37
14262: PPUSH
14263: LD_STRING D1-A-13
14265: PPUSH
14266: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14270: LD_EXP 38
14274: PPUSH
14275: LD_STRING D1-B-13
14277: PPUSH
14278: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14282: LD_EXP 37
14286: PPUSH
14287: LD_STRING D1-A-14
14289: PPUSH
14290: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14294: LD_EXP 38
14298: PPUSH
14299: LD_STRING D1-B-14
14301: PPUSH
14302: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14306: LD_EXP 37
14310: PPUSH
14311: LD_STRING D1-A-15
14313: PPUSH
14314: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14318: LD_EXP 38
14322: PPUSH
14323: LD_STRING D1-B-15
14325: PPUSH
14326: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14330: LD_EXP 37
14334: PPUSH
14335: LD_STRING D1-A-16
14337: PPUSH
14338: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14342: LD_EXP 38
14346: PPUSH
14347: LD_STRING D1-B-16
14349: PPUSH
14350: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14354: LD_EXP 37
14358: PPUSH
14359: LD_STRING D1-A-17
14361: PPUSH
14362: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14366: LD_EXP 38
14370: PPUSH
14371: LD_STRING D1-B-17
14373: PPUSH
14374: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
14378: LD_EXP 37
14382: PPUSH
14383: LD_STRING D1-A-18
14385: PPUSH
14386: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
14390: LD_INT 35
14392: PPUSH
14393: LD_INT 1
14395: PPUSH
14396: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
14400: LD_EXP 37
14404: PUSH
14405: LD_EXP 38
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PPUSH
14414: LD_INT 35
14416: PPUSH
14417: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
14421: LD_INT 4
14423: PPUSH
14424: CALL_OW 67
// until IsInUnit ( guyA ) ;
14428: LD_EXP 37
14432: PPUSH
14433: CALL_OW 310
14437: IFFALSE 14421
// Wait ( 0 0$02 ) ;
14439: LD_INT 70
14441: PPUSH
14442: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
14446: LD_EXP 37
14450: PPUSH
14451: LD_STRING D1-A-19
14453: PPUSH
14454: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
14458: LD_EXP 38
14462: PPUSH
14463: LD_STRING D1-B-19
14465: PPUSH
14466: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
14470: LD_EXP 37
14474: PPUSH
14475: LD_STRING D1-A-20
14477: PPUSH
14478: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
14482: LD_INT 10
14484: PPUSH
14485: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
14489: LD_EXP 38
14493: PPUSH
14494: LD_STRING D1-B-20
14496: PPUSH
14497: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
14501: LD_EXP 37
14505: PPUSH
14506: LD_STRING D1-A-21
14508: PPUSH
14509: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
14513: LD_EXP 38
14517: PPUSH
14518: LD_STRING D1-B-21
14520: PPUSH
14521: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
14525: LD_EXP 37
14529: PPUSH
14530: LD_STRING D1-A-22
14532: PPUSH
14533: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
14537: LD_EXP 38
14541: PPUSH
14542: LD_STRING D1-B-22
14544: PPUSH
14545: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
14549: LD_EXP 37
14553: PPUSH
14554: LD_STRING D1-A-23
14556: PPUSH
14557: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
14561: LD_EXP 38
14565: PPUSH
14566: LD_STRING D1-B-23
14568: PPUSH
14569: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
14573: LD_EXP 37
14577: PPUSH
14578: LD_STRING D1-A-24
14580: PPUSH
14581: CALL_OW 88
// InGameOff ;
14585: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
14589: LD_STRING M_main
14591: PPUSH
14592: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
14596: LD_INT 4
14598: PPUSH
14599: LD_INT 1
14601: PPUSH
14602: CALL_OW 343
// game_status := true ;
14606: LD_ADDR_EXP 28
14610: PUSH
14611: LD_INT 1
14613: ST_TO_ADDR
// end ;
14614: LD_VAR 0 1
14618: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
14619: LD_INT 1
14621: PPUSH
14622: CALL 6306 0 1
14626: PUSH
14627: LD_INT 0
14629: GREATER
14630: IFFALSE 14732
14632: GO 14634
14634: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
14635: LD_INT 35
14637: PPUSH
14638: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
14642: LD_INT 1
14644: PPUSH
14645: CALL 6306 0 1
14649: PUSH
14650: LD_INT 1
14652: ARRAY
14653: PPUSH
14654: CALL_OW 461
14658: PUSH
14659: LD_INT 1
14661: NONEQUAL
14662: IFFALSE 14635
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
14664: LD_EXP 37
14668: PPUSH
14669: CALL_OW 300
14673: PUSH
14674: LD_EXP 38
14678: PPUSH
14679: CALL_OW 300
14683: AND
14684: PUSH
14685: LD_EXP 29
14689: NOT
14690: AND
14691: IFFALSE 14717
// begin Say ( guyA , DL-A-1 ) ;
14693: LD_EXP 37
14697: PPUSH
14698: LD_STRING DL-A-1
14700: PPUSH
14701: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
14705: LD_EXP 38
14709: PPUSH
14710: LD_STRING DL-B-1
14712: PPUSH
14713: CALL_OW 88
// end ; if not helps_can_arrive then
14717: LD_EXP 30
14721: NOT
14722: IFFALSE 14732
// helps_can_arrive := true ;
14724: LD_ADDR_EXP 30
14728: PUSH
14729: LD_INT 1
14731: ST_TO_ADDR
// end ;
14732: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
14733: LD_INT 1
14735: PPUSH
14736: CALL 6306 0 1
14740: PUSH
14741: LD_INT 0
14743: GREATER
14744: PUSH
14745: LD_EXP 37
14749: PPUSH
14750: CALL_OW 300
14754: AND
14755: PUSH
14756: LD_EXP 38
14760: PPUSH
14761: CALL_OW 300
14765: AND
14766: PUSH
14767: LD_INT 22
14769: PUSH
14770: LD_INT 1
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PUSH
14777: LD_INT 25
14779: PUSH
14780: LD_INT 12
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: PPUSH
14791: CALL_OW 69
14795: PUSH
14796: LD_INT 0
14798: EQUAL
14799: AND
14800: PUSH
14801: LD_INT 1
14803: PPUSH
14804: LD_INT 25
14806: PUSH
14807: LD_INT 12
14809: PUSH
14810: EMPTY
14811: LIST
14812: LIST
14813: PPUSH
14814: CALL_OW 69
14818: PPUSH
14819: LD_EXP 37
14823: PPUSH
14824: CALL_OW 74
14828: PPUSH
14829: CALL_OW 292
14833: AND
14834: IFFALSE 14875
14836: GO 14838
14838: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
14839: LD_EXP 37
14843: PPUSH
14844: LD_STRING DA-A-1
14846: PPUSH
14847: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
14851: LD_EXP 38
14855: PPUSH
14856: LD_STRING DA-B-1
14858: PPUSH
14859: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
14863: LD_EXP 37
14867: PPUSH
14868: LD_STRING DA-A-2
14870: PPUSH
14871: CALL_OW 88
// end ;
14875: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
14876: LD_EXP 28
14880: PUSH
14881: LD_EXP 37
14885: PPUSH
14886: LD_INT 6
14888: PPUSH
14889: CALL_OW 299
14893: PUSH
14894: LD_INT 7
14896: LESS
14897: AND
14898: IFFALSE 14951
14900: GO 14902
14902: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
14903: LD_INT 117
14905: PPUSH
14906: LD_INT 50
14908: PPUSH
14909: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
14913: LD_INT 1
14915: PPUSH
14916: CALL 10047 0 1
14920: PUSH
14921: LD_INT 2
14923: ARRAY
14924: PPUSH
14925: LD_STRING D5-A-1
14927: PPUSH
14928: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
14932: LD_INT 1
14934: PPUSH
14935: CALL 10047 0 1
14939: PUSH
14940: LD_INT 1
14942: ARRAY
14943: PPUSH
14944: LD_STRING D5-B-1
14946: PPUSH
14947: CALL_OW 88
// end ;
14951: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
14952: LD_INT 7
14954: PPUSH
14955: LD_INT 22
14957: PUSH
14958: LD_INT 1
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: PPUSH
14965: CALL_OW 70
14969: PUSH
14970: LD_INT 0
14972: GREATER
14973: IFFALSE 15118
14975: GO 14977
14977: DISABLE
// begin Wait ( 0 0$03 ) ;
14978: LD_INT 105
14980: PPUSH
14981: CALL_OW 67
// DialogueOn ;
14985: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
14989: LD_INT 1
14991: PPUSH
14992: CALL 10047 0 1
14996: PUSH
14997: LD_INT 1
14999: ARRAY
15000: PPUSH
15001: LD_STRING D6-A-1
15003: PPUSH
15004: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15008: LD_INT 1
15010: PPUSH
15011: CALL 10047 0 1
15015: PUSH
15016: LD_INT 2
15018: ARRAY
15019: PPUSH
15020: LD_STRING D6-B-1
15022: PPUSH
15023: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15027: LD_INT 95
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: LD_INT 1
15035: PPUSH
15036: LD_INT 20
15038: PPUSH
15039: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15043: LD_INT 10
15045: PPUSH
15046: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15050: LD_INT 1
15052: PPUSH
15053: CALL 10047 0 1
15057: PUSH
15058: LD_INT 1
15060: ARRAY
15061: PPUSH
15062: LD_STRING D6-A-2
15064: PPUSH
15065: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15069: LD_INT 1
15071: PPUSH
15072: CALL 10047 0 1
15076: PUSH
15077: LD_INT 2
15079: ARRAY
15080: PPUSH
15081: LD_STRING D6-B-2
15083: PPUSH
15084: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15088: LD_INT 1
15090: PPUSH
15091: CALL 10047 0 1
15095: PUSH
15096: LD_INT 1
15098: ARRAY
15099: PPUSH
15100: LD_STRING D6-A-3
15102: PPUSH
15103: CALL_OW 88
// DialogueOff ;
15107: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15111: LD_STRING M_base
15113: PPUSH
15114: CALL_OW 337
// end ;
15118: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15119: LD_EXP 29
15123: NOT
15124: PUSH
15125: LD_INT 22
15127: PUSH
15128: LD_INT 3
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 21
15137: PUSH
15138: LD_INT 2
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL_OW 69
15153: PUSH
15154: LD_INT 0
15156: GREATER
15157: AND
15158: IFFALSE 15291
15160: GO 15162
15162: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15163: LD_INT 35
15165: PPUSH
15166: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15170: LD_INT 22
15172: PUSH
15173: LD_INT 3
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: PUSH
15180: LD_INT 21
15182: PUSH
15183: LD_INT 2
15185: PUSH
15186: EMPTY
15187: LIST
15188: LIST
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PPUSH
15194: CALL_OW 69
15198: PPUSH
15199: LD_INT 1
15201: PPUSH
15202: CALL 10047 0 1
15206: PUSH
15207: LD_INT 1
15209: ARRAY
15210: PPUSH
15211: CALL_OW 74
15215: PPUSH
15216: LD_INT 1
15218: PPUSH
15219: CALL 10047 0 1
15223: PUSH
15224: LD_INT 1
15226: ARRAY
15227: PPUSH
15228: CALL_OW 296
15232: PUSH
15233: LD_INT 7
15235: LESS
15236: IFFALSE 15163
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15238: LD_INT 1
15240: PPUSH
15241: CALL 10047 0 1
15245: PUSH
15246: LD_INT 1
15248: ARRAY
15249: PPUSH
15250: LD_STRING DR-A-1
15252: PPUSH
15253: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15257: LD_INT 1
15259: PPUSH
15260: CALL 10047 0 1
15264: PUSH
15265: LD_INT 2
15267: ARRAY
15268: PPUSH
15269: LD_STRING DR-B-1
15271: PPUSH
15272: CALL_OW 88
// Wait ( 3 3$00 ) ;
15276: LD_INT 6300
15278: PPUSH
15279: CALL_OW 67
// ru_spotted := true ;
15283: LD_ADDR_EXP 15
15287: PUSH
15288: LD_INT 1
15290: ST_TO_ADDR
// end ;
15291: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15292: LD_INT 35
15294: PPUSH
15295: CALL_OW 300
15299: NOT
15300: IFFALSE 15324
15302: GO 15304
15304: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15305: LD_INT 1
15307: PPUSH
15308: CALL 10047 0 1
15312: PUSH
15313: LD_INT 1
15315: ARRAY
15316: PPUSH
15317: LD_STRING DDR-A-1
15319: PPUSH
15320: CALL_OW 88
15324: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15325: LD_INT 1
15327: PPUSH
15328: LD_INT 30
15330: PPUSH
15331: CALL 6155 0 2
15335: IFFALSE 15417
15337: GO 15339
15339: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15340: LD_INT 35
15342: PPUSH
15343: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15347: LD_INT 1
15349: PPUSH
15350: LD_INT 30
15352: PPUSH
15353: CALL 6155 0 2
15357: PUSH
15358: LD_INT 1
15360: ARRAY
15361: PPUSH
15362: CALL_OW 461
15366: PUSH
15367: LD_INT 1
15369: NONEQUAL
15370: IFFALSE 15340
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15372: LD_INT 1
15374: PPUSH
15375: CALL 10047 0 1
15379: PUSH
15380: LD_INT 1
15382: ARRAY
15383: PPUSH
15384: LD_STRING D8-A-1
15386: PPUSH
15387: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
15391: LD_INT 1
15393: PPUSH
15394: CALL 10047 0 1
15398: PUSH
15399: LD_INT 2
15401: ARRAY
15402: PPUSH
15403: LD_STRING D8-B-1
15405: PPUSH
15406: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
15410: LD_STRING M_mineok
15412: PPUSH
15413: CALL_OW 337
// end ;
15417: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
15418: LD_INT 22
15420: PUSH
15421: LD_INT 1
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: LD_INT 30
15430: PUSH
15431: LD_INT 0
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PUSH
15438: LD_INT 3
15440: PUSH
15441: LD_INT 57
15443: PUSH
15444: EMPTY
15445: LIST
15446: PUSH
15447: EMPTY
15448: LIST
15449: LIST
15450: PUSH
15451: EMPTY
15452: LIST
15453: LIST
15454: LIST
15455: PPUSH
15456: CALL_OW 69
15460: PUSH
15461: LD_INT 1
15463: GREATER
15464: PUSH
15465: LD_INT 22
15467: PUSH
15468: LD_INT 1
15470: PUSH
15471: EMPTY
15472: LIST
15473: LIST
15474: PUSH
15475: LD_INT 30
15477: PUSH
15478: LD_INT 0
15480: PUSH
15481: EMPTY
15482: LIST
15483: LIST
15484: PUSH
15485: LD_INT 3
15487: PUSH
15488: LD_INT 57
15490: PUSH
15491: EMPTY
15492: LIST
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: LIST
15502: PPUSH
15503: CALL_OW 69
15507: PUSH
15508: LD_INT 1
15510: EQUAL
15511: PUSH
15512: LD_INT 35
15514: PPUSH
15515: CALL_OW 300
15519: NOT
15520: AND
15521: OR
15522: IFFALSE 15574
15524: GO 15526
15526: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
15527: LD_INT 22
15529: PUSH
15530: LD_INT 1
15532: PUSH
15533: EMPTY
15534: LIST
15535: LIST
15536: PUSH
15537: LD_INT 25
15539: PUSH
15540: LD_INT 2
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PPUSH
15551: CALL_OW 69
15555: PUSH
15556: LD_INT 1
15558: ARRAY
15559: PPUSH
15560: LD_STRING D7-A-1
15562: PPUSH
15563: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
15567: LD_STRING M_baseok
15569: PPUSH
15570: CALL_OW 337
// end ;
15574: END
// every 0 0$01 trigger mine_ck do
15575: LD_EXP 34
15579: IFFALSE 15610
15581: GO 15583
15583: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
15584: LD_INT 1
15586: PPUSH
15587: CALL 10047 0 1
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: LD_STRING D9-A-1
15598: PPUSH
15599: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
15603: LD_STRING M_minedest
15605: PPUSH
15606: CALL_OW 337
// end ;
15610: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
15611: LD_EXP 28
15615: IFFALSE 16121
15617: GO 15619
15619: DISABLE
15620: LD_INT 0
15622: PPUSH
15623: PPUSH
15624: PPUSH
15625: PPUSH
15626: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
15627: LD_OWVAR 67
15631: PPUSH
15632: CALL 11948 0 1
// if not helps_can_arrive then
15636: LD_EXP 30
15640: NOT
15641: IFFALSE 15669
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
15643: LD_EXP 39
15647: PUSH
15648: LD_INT 1
15650: ARRAY
15651: PPUSH
15652: LD_STRING DB-Delay
15654: PPUSH
15655: CALL_OW 94
// time := 10 10$00 ;
15659: LD_ADDR_VAR 0 1
15663: PUSH
15664: LD_INT 21000
15666: ST_TO_ADDR
// end else
15667: GO 15677
// time := 3 3$00 ;
15669: LD_ADDR_VAR 0 1
15673: PUSH
15674: LD_INT 6300
15676: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
15677: LD_ADDR_VAR 0 1
15681: PUSH
15682: LD_VAR 0 1
15686: PUSH
15687: LD_INT 35
15689: MINUS
15690: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
15691: LD_INT 35
15693: PPUSH
15694: CALL_OW 67
// end until time = 0 0$00 ;
15698: LD_VAR 0 1
15702: PUSH
15703: LD_INT 0
15705: EQUAL
15706: IFFALSE 15677
// helps_arrive := true ;
15708: LD_ADDR_EXP 29
15712: PUSH
15713: LD_INT 1
15715: ST_TO_ADDR
// if IsLive ( guyA ) then
15716: LD_EXP 37
15720: PPUSH
15721: CALL_OW 300
15725: IFFALSE 15739
// r := guyA else
15727: LD_ADDR_VAR 0 4
15731: PUSH
15732: LD_EXP 37
15736: ST_TO_ADDR
15737: GO 15749
// r := guyB ;
15739: LD_ADDR_VAR 0 4
15743: PUSH
15744: LD_EXP 38
15748: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
15749: LD_EXP 39
15753: PUSH
15754: LD_INT 1
15756: ARRAY
15757: PPUSH
15758: LD_STRING D2-A-1
15760: PPUSH
15761: CALL_OW 94
// Say ( r , D2-B-1 ) ;
15765: LD_VAR 0 4
15769: PPUSH
15770: LD_STRING D2-B-1
15772: PPUSH
15773: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
15777: LD_EXP 39
15781: PUSH
15782: LD_INT 1
15784: ARRAY
15785: PPUSH
15786: LD_STRING D2-A-2
15788: PPUSH
15789: CALL_OW 94
// Say ( r , D2-B-2 ) ;
15793: LD_VAR 0 4
15797: PPUSH
15798: LD_STRING D2-B-2
15800: PPUSH
15801: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
15805: LD_EXP 39
15809: PUSH
15810: LD_INT 1
15812: ARRAY
15813: PPUSH
15814: LD_STRING D2-A-3
15816: PPUSH
15817: CALL_OW 94
// Say ( r , D2-B-3 ) ;
15821: LD_VAR 0 4
15825: PPUSH
15826: LD_STRING D2-B-3
15828: PPUSH
15829: CALL_OW 88
// to_veh := [ ] ;
15833: LD_ADDR_VAR 0 5
15837: PUSH
15838: EMPTY
15839: ST_TO_ADDR
// for i = 1 to Beta_Squad do
15840: LD_ADDR_VAR 0 2
15844: PUSH
15845: DOUBLE
15846: LD_INT 1
15848: DEC
15849: ST_TO_ADDR
15850: LD_EXP 39
15854: PUSH
15855: FOR_TO
15856: IFFALSE 16119
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
15858: LD_EXP 39
15862: PUSH
15863: LD_VAR 0 2
15867: ARRAY
15868: PPUSH
15869: CALL_OW 110
15873: PUSH
15874: LD_INT 3
15876: EQUAL
15877: IFFALSE 15903
// to_veh := to_veh ^ Beta_Squad [ i ] else
15879: LD_ADDR_VAR 0 5
15883: PUSH
15884: LD_VAR 0 5
15888: PUSH
15889: LD_EXP 39
15893: PUSH
15894: LD_VAR 0 2
15898: ARRAY
15899: ADD
15900: ST_TO_ADDR
15901: GO 16028
// if GetTag ( Beta_Squad [ i ] ) = 5 then
15903: LD_EXP 39
15907: PUSH
15908: LD_VAR 0 2
15912: ARRAY
15913: PPUSH
15914: CALL_OW 110
15918: PUSH
15919: LD_INT 5
15921: EQUAL
15922: IFFALSE 16007
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
15924: LD_EXP 39
15928: PUSH
15929: LD_VAR 0 2
15933: ARRAY
15934: PPUSH
15935: LD_INT 4
15937: PPUSH
15938: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
15942: LD_EXP 39
15946: PUSH
15947: LD_VAR 0 2
15951: ARRAY
15952: PPUSH
15953: LD_INT 5
15955: PPUSH
15956: LD_INT 0
15958: PPUSH
15959: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
15963: LD_VAR 0 5
15967: PUSH
15968: LD_INT 1
15970: ARRAY
15971: PPUSH
15972: LD_EXP 39
15976: PUSH
15977: LD_VAR 0 2
15981: ARRAY
15982: PPUSH
15983: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
15987: LD_ADDR_VAR 0 5
15991: PUSH
15992: LD_VAR 0 5
15996: PPUSH
15997: LD_INT 1
15999: PPUSH
16000: CALL_OW 3
16004: ST_TO_ADDR
// end else
16005: GO 16028
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16007: LD_EXP 39
16011: PUSH
16012: LD_VAR 0 2
16016: ARRAY
16017: PPUSH
16018: LD_INT 5
16020: PPUSH
16021: LD_INT 0
16023: PPUSH
16024: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16028: LD_EXP 39
16032: PUSH
16033: LD_VAR 0 2
16037: ARRAY
16038: PPUSH
16039: LD_INT 165
16041: PPUSH
16042: LD_INT 105
16044: PPUSH
16045: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16049: LD_INT 70
16051: PPUSH
16052: LD_INT 140
16054: PPUSH
16055: CALL_OW 12
16059: PPUSH
16060: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16064: LD_EXP 39
16068: PUSH
16069: LD_VAR 0 2
16073: ARRAY
16074: PPUSH
16075: LD_INT 1
16077: PPUSH
16078: CALL_OW 235
// if i = 1 then
16082: LD_VAR 0 2
16086: PUSH
16087: LD_INT 1
16089: EQUAL
16090: IFFALSE 16102
// CenterNowOnXY ( 168 , 109 ) ;
16092: LD_INT 168
16094: PPUSH
16095: LD_INT 109
16097: PPUSH
16098: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16102: LD_EXP 39
16106: PUSH
16107: LD_VAR 0 2
16111: ARRAY
16112: PPUSH
16113: CALL_OW 141
// end ;
16117: GO 15855
16119: POP
16120: POP
// end ;
16121: PPOPN 5
16123: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16124: LD_EXP 29
16128: IFFALSE 17157
16130: GO 16132
16132: DISABLE
16133: LD_INT 0
16135: PPUSH
16136: PPUSH
// begin Wait ( 5 5$00 ) ;
16137: LD_INT 10500
16139: PPUSH
16140: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16144: LD_OWVAR 67
16148: PPUSH
16149: CALL 12637 0 1
// to_veh := [ ] ;
16153: LD_ADDR_VAR 0 2
16157: PUSH
16158: EMPTY
16159: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16160: LD_ADDR_VAR 0 1
16164: PUSH
16165: DOUBLE
16166: LD_INT 1
16168: DEC
16169: ST_TO_ADDR
16170: LD_EXP 40
16174: PUSH
16175: FOR_TO
16176: IFFALSE 16404
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16178: LD_EXP 40
16182: PUSH
16183: LD_VAR 0 1
16187: ARRAY
16188: PPUSH
16189: CALL_OW 110
16193: PUSH
16194: LD_INT 3
16196: EQUAL
16197: IFFALSE 16223
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16199: LD_ADDR_VAR 0 2
16203: PUSH
16204: LD_VAR 0 2
16208: PUSH
16209: LD_EXP 40
16213: PUSH
16214: LD_VAR 0 1
16218: ARRAY
16219: ADD
16220: ST_TO_ADDR
16221: GO 16348
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16223: LD_EXP 40
16227: PUSH
16228: LD_VAR 0 1
16232: ARRAY
16233: PPUSH
16234: CALL_OW 110
16238: PUSH
16239: LD_INT 5
16241: EQUAL
16242: IFFALSE 16327
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16244: LD_EXP 40
16248: PUSH
16249: LD_VAR 0 1
16253: ARRAY
16254: PPUSH
16255: LD_INT 4
16257: PPUSH
16258: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16262: LD_EXP 40
16266: PUSH
16267: LD_VAR 0 1
16271: ARRAY
16272: PPUSH
16273: LD_INT 5
16275: PPUSH
16276: LD_INT 0
16278: PPUSH
16279: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16283: LD_VAR 0 2
16287: PUSH
16288: LD_INT 1
16290: ARRAY
16291: PPUSH
16292: LD_EXP 40
16296: PUSH
16297: LD_VAR 0 1
16301: ARRAY
16302: PPUSH
16303: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16307: LD_ADDR_VAR 0 2
16311: PUSH
16312: LD_VAR 0 2
16316: PPUSH
16317: LD_INT 1
16319: PPUSH
16320: CALL_OW 3
16324: ST_TO_ADDR
// end else
16325: GO 16348
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16327: LD_EXP 40
16331: PUSH
16332: LD_VAR 0 1
16336: ARRAY
16337: PPUSH
16338: LD_INT 5
16340: PPUSH
16341: LD_INT 0
16343: PPUSH
16344: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16348: LD_EXP 40
16352: PUSH
16353: LD_VAR 0 1
16357: ARRAY
16358: PPUSH
16359: LD_INT 164
16361: PPUSH
16362: LD_INT 104
16364: PPUSH
16365: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16369: LD_INT 70
16371: PPUSH
16372: LD_INT 140
16374: PPUSH
16375: CALL_OW 12
16379: PPUSH
16380: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16384: LD_EXP 40
16388: PUSH
16389: LD_VAR 0 1
16393: ARRAY
16394: PPUSH
16395: LD_INT 1
16397: PPUSH
16398: CALL_OW 235
// end ;
16402: GO 16175
16404: POP
16405: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
16406: LD_EXP 40
16410: PUSH
16411: LD_INT 1
16413: ARRAY
16414: PPUSH
16415: LD_STRING D3-A-1
16417: PPUSH
16418: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
16422: LD_INT 1
16424: PPUSH
16425: CALL 10047 0 1
16429: PUSH
16430: LD_INT 1
16432: ARRAY
16433: PPUSH
16434: LD_STRING D3-B-1
16436: PPUSH
16437: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
16441: LD_EXP 40
16445: PUSH
16446: LD_INT 1
16448: ARRAY
16449: PPUSH
16450: LD_STRING D3-A-2
16452: PPUSH
16453: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
16457: LD_INT 1
16459: PPUSH
16460: CALL 10047 0 1
16464: PUSH
16465: LD_INT 1
16467: ARRAY
16468: PPUSH
16469: LD_STRING D3-B-2
16471: PPUSH
16472: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
16476: LD_EXP 40
16480: PUSH
16481: LD_INT 1
16483: ARRAY
16484: PPUSH
16485: LD_STRING D3-A-3
16487: PPUSH
16488: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
16492: LD_INT 1
16494: PPUSH
16495: CALL 10047 0 1
16499: PUSH
16500: LD_INT 1
16502: ARRAY
16503: PPUSH
16504: LD_STRING D3-B-3
16506: PPUSH
16507: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
16511: LD_EXP 40
16515: PUSH
16516: LD_INT 1
16518: ARRAY
16519: PPUSH
16520: LD_STRING D3-A-4
16522: PPUSH
16523: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
16527: LD_INT 1
16529: PPUSH
16530: CALL 10047 0 1
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_STRING D3-B-4
16541: PPUSH
16542: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
16546: LD_EXP 40
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_STRING D3-A-5
16557: PPUSH
16558: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
16562: LD_INT 1
16564: PPUSH
16565: CALL 10047 0 1
16569: PUSH
16570: LD_INT 1
16572: ARRAY
16573: PPUSH
16574: LD_STRING D3-B-5
16576: PPUSH
16577: CALL_OW 88
// for i = 1 to Gamma_Squad do
16581: LD_ADDR_VAR 0 1
16585: PUSH
16586: DOUBLE
16587: LD_INT 1
16589: DEC
16590: ST_TO_ADDR
16591: LD_EXP 40
16595: PUSH
16596: FOR_TO
16597: IFFALSE 16619
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16599: LD_EXP 40
16603: PUSH
16604: LD_VAR 0 1
16608: ARRAY
16609: PPUSH
16610: LD_INT 1
16612: PPUSH
16613: CALL_OW 235
16617: GO 16596
16619: POP
16620: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
16621: LD_INT 6300
16623: PUSH
16624: LD_INT 10500
16626: PUSH
16627: LD_INT 11550
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: LIST
16634: PUSH
16635: LD_OWVAR 67
16639: ARRAY
16640: PPUSH
16641: CALL_OW 67
// AddZetaSquad ;
16645: CALL 13366 0 0
// Wait ( 0 0$10 ) ;
16649: LD_INT 350
16651: PPUSH
16652: CALL_OW 67
// to_veh := [ ] ;
16656: LD_ADDR_VAR 0 2
16660: PUSH
16661: EMPTY
16662: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
16663: LD_ADDR_VAR 0 1
16667: PUSH
16668: DOUBLE
16669: LD_INT 1
16671: DEC
16672: ST_TO_ADDR
16673: LD_EXP 41
16677: PUSH
16678: FOR_TO
16679: IFFALSE 16889
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
16681: LD_EXP 41
16685: PUSH
16686: LD_VAR 0 1
16690: ARRAY
16691: PPUSH
16692: CALL_OW 110
16696: PUSH
16697: LD_INT 3
16699: EQUAL
16700: IFFALSE 16726
// to_veh := to_veh ^ Zeta_Squad [ i ] else
16702: LD_ADDR_VAR 0 2
16706: PUSH
16707: LD_VAR 0 2
16711: PUSH
16712: LD_EXP 41
16716: PUSH
16717: LD_VAR 0 1
16721: ARRAY
16722: ADD
16723: ST_TO_ADDR
16724: GO 16851
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
16726: LD_EXP 41
16730: PUSH
16731: LD_VAR 0 1
16735: ARRAY
16736: PPUSH
16737: CALL_OW 110
16741: PUSH
16742: LD_INT 5
16744: EQUAL
16745: IFFALSE 16830
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
16747: LD_EXP 41
16751: PUSH
16752: LD_VAR 0 1
16756: ARRAY
16757: PPUSH
16758: LD_INT 4
16760: PPUSH
16761: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
16765: LD_EXP 41
16769: PUSH
16770: LD_VAR 0 1
16774: ARRAY
16775: PPUSH
16776: LD_INT 5
16778: PPUSH
16779: LD_INT 0
16781: PPUSH
16782: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
16786: LD_VAR 0 2
16790: PUSH
16791: LD_INT 1
16793: ARRAY
16794: PPUSH
16795: LD_EXP 41
16799: PUSH
16800: LD_VAR 0 1
16804: ARRAY
16805: PPUSH
16806: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16810: LD_ADDR_VAR 0 2
16814: PUSH
16815: LD_VAR 0 2
16819: PPUSH
16820: LD_INT 1
16822: PPUSH
16823: CALL_OW 3
16827: ST_TO_ADDR
// end else
16828: GO 16851
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
16830: LD_EXP 41
16834: PUSH
16835: LD_VAR 0 1
16839: ARRAY
16840: PPUSH
16841: LD_INT 5
16843: PPUSH
16844: LD_INT 0
16846: PPUSH
16847: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
16851: LD_EXP 41
16855: PUSH
16856: LD_VAR 0 1
16860: ARRAY
16861: PPUSH
16862: LD_INT 165
16864: PPUSH
16865: LD_INT 105
16867: PPUSH
16868: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16872: LD_INT 70
16874: PPUSH
16875: LD_INT 140
16877: PPUSH
16878: CALL_OW 12
16882: PPUSH
16883: CALL_OW 67
// end ;
16887: GO 16678
16889: POP
16890: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
16891: LD_EXP 41
16895: PUSH
16896: LD_INT 1
16898: ARRAY
16899: PPUSH
16900: LD_STRING D4-A-1
16902: PPUSH
16903: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
16907: LD_INT 1
16909: PPUSH
16910: CALL 10047 0 1
16914: PUSH
16915: LD_INT 1
16917: ARRAY
16918: PPUSH
16919: LD_STRING D4-B-1
16921: PPUSH
16922: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
16926: LD_EXP 41
16930: PUSH
16931: LD_INT 1
16933: ARRAY
16934: PPUSH
16935: LD_STRING D4-A-2
16937: PPUSH
16938: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
16942: LD_INT 1
16944: PPUSH
16945: CALL 10047 0 1
16949: PUSH
16950: LD_INT 1
16952: ARRAY
16953: PPUSH
16954: LD_STRING D4-B-2
16956: PPUSH
16957: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
16961: LD_EXP 41
16965: PUSH
16966: LD_INT 1
16968: ARRAY
16969: PPUSH
16970: LD_STRING D4-A-3
16972: PPUSH
16973: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
16977: LD_INT 1
16979: PPUSH
16980: CALL 10047 0 1
16984: PUSH
16985: LD_INT 1
16987: ARRAY
16988: PPUSH
16989: LD_STRING D4-B-3
16991: PPUSH
16992: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
16996: LD_EXP 41
17000: PUSH
17001: LD_INT 1
17003: ARRAY
17004: PPUSH
17005: LD_STRING D4-A-4
17007: PPUSH
17008: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17012: LD_INT 1
17014: PPUSH
17015: CALL 10047 0 1
17019: PUSH
17020: LD_INT 1
17022: ARRAY
17023: PPUSH
17024: LD_STRING D4-B-4
17026: PPUSH
17027: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17031: LD_EXP 41
17035: PUSH
17036: LD_INT 1
17038: ARRAY
17039: PPUSH
17040: LD_STRING D4-A-5
17042: PPUSH
17043: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17047: LD_INT 1
17049: PPUSH
17050: CALL 10047 0 1
17054: PUSH
17055: LD_INT 1
17057: ARRAY
17058: PPUSH
17059: LD_STRING D4-B-5
17061: PPUSH
17062: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17066: LD_EXP 41
17070: PUSH
17071: LD_INT 1
17073: ARRAY
17074: PPUSH
17075: LD_STRING D4-A-6
17077: PPUSH
17078: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17082: LD_INT 1
17084: PPUSH
17085: CALL 10047 0 1
17089: PUSH
17090: LD_INT 1
17092: ARRAY
17093: PPUSH
17094: LD_STRING D4-B-6
17096: PPUSH
17097: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17101: LD_EXP 41
17105: PUSH
17106: LD_INT 1
17108: ARRAY
17109: PPUSH
17110: LD_STRING D4-A-7
17112: PPUSH
17113: CALL_OW 94
// for i = 1 to Zeta_Squad do
17117: LD_ADDR_VAR 0 1
17121: PUSH
17122: DOUBLE
17123: LD_INT 1
17125: DEC
17126: ST_TO_ADDR
17127: LD_EXP 41
17131: PUSH
17132: FOR_TO
17133: IFFALSE 17155
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17135: LD_EXP 41
17139: PUSH
17140: LD_VAR 0 1
17144: ARRAY
17145: PPUSH
17146: LD_INT 1
17148: PPUSH
17149: CALL_OW 235
17153: GO 17132
17155: POP
17156: POP
// end ;
17157: PPOPN 2
17159: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17160: LD_INT 11
17162: PPUSH
17163: LD_INT 22
17165: PUSH
17166: LD_OWVAR 2
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PPUSH
17175: CALL_OW 70
17179: PUSH
17180: LD_INT 0
17182: GREATER
17183: IFFALSE 17208
17185: GO 17187
17187: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17188: LD_EXP 37
17192: PPUSH
17193: LD_STRING D10-A-1
17195: PPUSH
17196: CALL_OW 88
// ru_spotted := true ;
17200: LD_ADDR_EXP 15
17204: PUSH
17205: LD_INT 1
17207: ST_TO_ADDR
// end ;
17208: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17209: LD_EXP 37
17213: PPUSH
17214: CALL_OW 301
17218: PUSH
17219: LD_EXP 38
17223: PPUSH
17224: CALL_OW 301
17228: OR
17229: IFFALSE 17241
17231: GO 17233
17233: DISABLE
// begin YouLost ( DieP ) ;
17234: LD_STRING DieP
17236: PPUSH
17237: CALL_OW 104
// end ;
17241: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17242: LD_INT 34
17244: PUSH
17245: LD_INT 8
17247: PUSH
17248: EMPTY
17249: LIST
17250: LIST
17251: PPUSH
17252: CALL_OW 69
17256: IFFALSE 17269
17258: GO 17260
17260: DISABLE
// sib_bomb_constructed := true ;
17261: LD_ADDR_EXP 35
17265: PUSH
17266: LD_INT 1
17268: ST_TO_ADDR
17269: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17270: LD_EXP 28
17274: PUSH
17275: LD_INT 22
17277: PUSH
17278: LD_INT 3
17280: PUSH
17281: EMPTY
17282: LIST
17283: LIST
17284: PPUSH
17285: CALL_OW 69
17289: PUSH
17290: LD_INT 0
17292: EQUAL
17293: AND
17294: IFFALSE 17483
17296: GO 17298
17298: DISABLE
17299: LD_INT 0
17301: PPUSH
// begin game_status := false ;
17302: LD_ADDR_EXP 28
17306: PUSH
17307: LD_INT 0
17309: ST_TO_ADDR
// if Difficulty = 3 then
17310: LD_OWVAR 67
17314: PUSH
17315: LD_INT 3
17317: EQUAL
17318: IFFALSE 17327
// SetAchievement ( ACH_HARD ) ;
17320: LD_STRING ACH_HARD
17322: PPUSH
17323: CALL_OW 543
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17327: LD_OWVAR 1
17331: PUSH
17332: LD_INT 35
17334: DIVREAL
17335: PUSH
17336: LD_INT 60
17338: DIVREAL
17339: PUSH
17340: LD_INT 70
17342: PUSH
17343: LD_INT 60
17345: PUSH
17346: LD_INT 50
17348: PUSH
17349: EMPTY
17350: LIST
17351: LIST
17352: LIST
17353: PUSH
17354: LD_OWVAR 67
17358: ARRAY
17359: LESS
17360: IFFALSE 17374
// AddMedal ( play , 1 ) else
17362: LD_STRING play
17364: PPUSH
17365: LD_INT 1
17367: PPUSH
17368: CALL_OW 101
17372: GO 17385
// AddMedal ( play , - 1 ) ;
17374: LD_STRING play
17376: PPUSH
17377: LD_INT 1
17379: NEG
17380: PPUSH
17381: CALL_OW 101
// if sib_bomb_constructed then
17385: LD_EXP 35
17389: IFFALSE 17403
// AddMedal ( sibbomb , 1 ) else
17391: LD_STRING sibbomb
17393: PPUSH
17394: LD_INT 1
17396: PPUSH
17397: CALL_OW 101
17401: GO 17414
// AddMedal ( sibbomb , - 1 ) ;
17403: LD_STRING sibbomb
17405: PPUSH
17406: LD_INT 1
17408: NEG
17409: PPUSH
17410: CALL_OW 101
// if mine_constructed and not mine_ck then
17414: LD_EXP 36
17418: PUSH
17419: LD_EXP 34
17423: NOT
17424: AND
17425: IFFALSE 17437
// AddMedal ( mine , 1 ) ;
17427: LD_STRING mine
17429: PPUSH
17430: LD_INT 1
17432: PPUSH
17433: CALL_OW 101
// if mine_ck then
17437: LD_EXP 34
17441: IFFALSE 17454
// AddMedal ( mine , - 1 ) ;
17443: LD_STRING mine
17445: PPUSH
17446: LD_INT 1
17448: NEG
17449: PPUSH
17450: CALL_OW 101
// if not mine_constructed then
17454: LD_EXP 36
17458: NOT
17459: IFFALSE 17472
// AddMedal ( mine , - 2 ) ;
17461: LD_STRING mine
17463: PPUSH
17464: LD_INT 2
17466: NEG
17467: PPUSH
17468: CALL_OW 101
// GiveMedals ( Main ) ;
17472: LD_STRING Main
17474: PPUSH
17475: CALL_OW 102
// YouWin ;
17479: CALL_OW 103
// end ; end_of_file
17483: PPOPN 1
17485: END
// every 0 0$03 trigger game_status do var time ;
17486: LD_EXP 28
17490: IFFALSE 17655
17492: GO 17494
17494: DISABLE
17495: LD_INT 0
17497: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
17498: LD_ADDR_VAR 0 1
17502: PUSH
17503: LD_INT 1050
17505: PUSH
17506: LD_INT 1575
17508: PUSH
17509: LD_INT 2100
17511: PUSH
17512: EMPTY
17513: LIST
17514: LIST
17515: LIST
17516: PUSH
17517: LD_OWVAR 67
17521: ARRAY
17522: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
17523: LD_VAR 0 1
17527: PUSH
17528: LD_INT 0
17530: PPUSH
17531: LD_INT 420
17533: PPUSH
17534: CALL_OW 12
17538: PLUS
17539: PPUSH
17540: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
17544: LD_INT 1
17546: PPUSH
17547: LD_INT 5
17549: PPUSH
17550: CALL_OW 12
17554: PPUSH
17555: LD_INT 1
17557: PPUSH
17558: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
17562: LD_INT 105
17564: PPUSH
17565: LD_INT 1050
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 148
17590: PPUSH
17591: LD_INT 107
17593: PPUSH
17594: LD_INT 20
17596: PPUSH
17597: LD_INT 1
17599: PPUSH
17600: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
17604: LD_OWVAR 1
17608: PUSH
17609: LD_INT 44100
17611: PUSH
17612: LD_INT 37800
17614: PUSH
17615: LD_INT 33600
17617: PUSH
17618: EMPTY
17619: LIST
17620: LIST
17621: LIST
17622: PUSH
17623: LD_OWVAR 67
17627: ARRAY
17628: MOD
17629: IFFALSE 17645
// time := time + 0 0$20 ;
17631: LD_ADDR_VAR 0 1
17635: PUSH
17636: LD_VAR 0 1
17640: PUSH
17641: LD_INT 700
17643: PLUS
17644: ST_TO_ADDR
// end until game_status = false ;
17645: LD_EXP 28
17649: PUSH
17650: LD_INT 0
17652: EQUAL
17653: IFFALSE 17523
// end ;
17655: PPOPN 1
17657: END
// every 0 0$03 trigger game_status do var time ;
17658: LD_EXP 28
17662: IFFALSE 17816
17664: GO 17666
17666: DISABLE
17667: LD_INT 0
17669: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
17670: LD_ADDR_VAR 0 1
17674: PUSH
17675: LD_INT 700
17677: PUSH
17678: LD_INT 875
17680: PUSH
17681: LD_INT 1400
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: LIST
17688: PUSH
17689: LD_OWVAR 67
17693: ARRAY
17694: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
17695: LD_VAR 0 1
17699: PUSH
17700: LD_INT 0
17702: PPUSH
17703: LD_INT 385
17705: PPUSH
17706: CALL_OW 12
17710: PLUS
17711: PPUSH
17712: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
17716: LD_INT 1
17718: PPUSH
17719: LD_INT 5
17721: PPUSH
17722: CALL_OW 12
17726: PPUSH
17727: LD_INT 102
17729: PPUSH
17730: LD_INT 6
17732: PPUSH
17733: LD_INT 25
17735: PPUSH
17736: LD_INT 1
17738: PPUSH
17739: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
17743: LD_OWVAR 1
17747: PUSH
17748: LD_INT 52500
17750: PUSH
17751: LD_INT 46200
17753: PUSH
17754: LD_INT 42000
17756: PUSH
17757: EMPTY
17758: LIST
17759: LIST
17760: LIST
17761: PUSH
17762: LD_OWVAR 67
17766: ARRAY
17767: MOD
17768: IFFALSE 17784
// time := time + 0 0$25 ;
17770: LD_ADDR_VAR 0 1
17774: PUSH
17775: LD_VAR 0 1
17779: PUSH
17780: LD_INT 875
17782: PLUS
17783: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
17784: LD_OWVAR 1
17788: PUSH
17789: LD_INT 231000
17791: MOD
17792: PUSH
17793: LD_INT 0
17795: EQUAL
17796: IFFALSE 17806
// time := 0 0$30 ;
17798: LD_ADDR_VAR 0 1
17802: PUSH
17803: LD_INT 1050
17805: ST_TO_ADDR
// end until game_status = false ;
17806: LD_EXP 28
17810: PUSH
17811: LD_INT 0
17813: EQUAL
17814: IFFALSE 17695
// end ;
17816: PPOPN 1
17818: END
// every 0 0$03 trigger game_status do var time ;
17819: LD_EXP 28
17823: IFFALSE 17959
17825: GO 17827
17827: DISABLE
17828: LD_INT 0
17830: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
17831: LD_ADDR_VAR 0 1
17835: PUSH
17836: LD_INT 1050
17838: PUSH
17839: LD_INT 1575
17841: PUSH
17842: LD_INT 1750
17844: PUSH
17845: EMPTY
17846: LIST
17847: LIST
17848: LIST
17849: PUSH
17850: LD_OWVAR 67
17854: ARRAY
17855: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
17856: LD_VAR 0 1
17860: PUSH
17861: LD_INT 0
17863: PPUSH
17864: LD_INT 385
17866: PPUSH
17867: CALL_OW 12
17871: PLUS
17872: PPUSH
17873: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
17877: LD_INT 1
17879: PPUSH
17880: LD_INT 5
17882: PPUSH
17883: CALL_OW 12
17887: PPUSH
17888: LD_INT 51
17890: PPUSH
17891: LD_INT 74
17893: PPUSH
17894: LD_INT 25
17896: PPUSH
17897: LD_INT 1
17899: PPUSH
17900: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
17904: LD_OWVAR 1
17908: PUSH
17909: LD_INT 84000
17911: PUSH
17912: LD_INT 105000
17914: PUSH
17915: LD_INT 136500
17917: PUSH
17918: EMPTY
17919: LIST
17920: LIST
17921: LIST
17922: PUSH
17923: LD_OWVAR 67
17927: ARRAY
17928: MOD
17929: PUSH
17930: LD_INT 0
17932: EQUAL
17933: IFFALSE 17949
// time := time + 0 0$15 ;
17935: LD_ADDR_VAR 0 1
17939: PUSH
17940: LD_VAR 0 1
17944: PUSH
17945: LD_INT 525
17947: PLUS
17948: ST_TO_ADDR
// end until game_status = false ;
17949: LD_EXP 28
17953: PUSH
17954: LD_INT 0
17956: EQUAL
17957: IFFALSE 17856
// end ; end_of_file
17959: PPOPN 1
17961: END
// every 0 0$01 trigger not debug do
17962: LD_EXP 1
17966: NOT
17967: IFFALSE 17990
17969: GO 17971
17971: DISABLE
// begin enable ;
17972: ENABLE
// Display_Strings := [ #tick , tick ] ;
17973: LD_ADDR_OWVAR 47
17977: PUSH
17978: LD_STRING #tick
17980: PUSH
17981: LD_OWVAR 1
17985: PUSH
17986: EMPTY
17987: LIST
17988: LIST
17989: ST_TO_ADDR
// end ; end_of_file
17990: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
17991: LD_VAR 0 1
17995: PPUSH
17996: CALL_OW 255
18000: PUSH
18001: LD_INT 3
18003: EQUAL
18004: PUSH
18005: LD_VAR 0 1
18009: PUSH
18010: LD_INT 2
18012: PUSH
18013: LD_INT 34
18015: PUSH
18016: LD_INT 46
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: PUSH
18023: LD_INT 34
18025: PUSH
18026: LD_INT 47
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: PUSH
18033: LD_INT 34
18035: PUSH
18036: LD_INT 45
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: PUSH
18049: EMPTY
18050: LIST
18051: PPUSH
18052: CALL_OW 69
18056: IN
18057: AND
18058: IFFALSE 18076
// ru_reserve := ru_reserve ^ un ;
18060: LD_ADDR_EXP 8
18064: PUSH
18065: LD_EXP 8
18069: PUSH
18070: LD_VAR 0 1
18074: ADD
18075: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
18076: LD_VAR 0 1
18080: PUSH
18081: LD_INT 22
18083: PUSH
18084: LD_INT 3
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: PUSH
18091: LD_INT 34
18093: PUSH
18094: LD_INT 48
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PUSH
18101: EMPTY
18102: LIST
18103: LIST
18104: PPUSH
18105: CALL_OW 69
18109: IN
18110: IFFALSE 18163
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
18112: LD_INT 12
18114: PPUSH
18115: LD_INT 22
18117: PUSH
18118: LD_INT 1
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PPUSH
18125: CALL_OW 70
18129: IFFALSE 18148
// ComAttackPlace ( un , 98 , 10 ) else
18131: LD_VAR 0 1
18135: PPUSH
18136: LD_INT 98
18138: PPUSH
18139: LD_INT 10
18141: PPUSH
18142: CALL_OW 116
18146: GO 18163
// ComAttackPlace ( un , 134 , 99 ) ;
18148: LD_VAR 0 1
18152: PPUSH
18153: LD_INT 134
18155: PPUSH
18156: LD_INT 99
18158: PPUSH
18159: CALL_OW 116
// end ;
18163: PPOPN 2
18165: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
18166: LD_VAR 0 1
18170: PPUSH
18171: CALL 29539 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
18175: LD_VAR 0 1
18179: PUSH
18180: LD_INT 22
18182: PUSH
18183: LD_INT 3
18185: PUSH
18186: EMPTY
18187: LIST
18188: LIST
18189: PUSH
18190: LD_INT 21
18192: PUSH
18193: LD_INT 3
18195: PUSH
18196: EMPTY
18197: LIST
18198: LIST
18199: PUSH
18200: EMPTY
18201: LIST
18202: LIST
18203: PPUSH
18204: CALL_OW 69
18208: IN
18209: PUSH
18210: LD_VAR 0 1
18214: PPUSH
18215: CALL_OW 266
18219: PUSH
18220: LD_INT 0
18222: PUSH
18223: LD_INT 29
18225: PUSH
18226: LD_INT 30
18228: PUSH
18229: LD_INT 26
18231: PUSH
18232: EMPTY
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: IN
18238: NOT
18239: AND
18240: IFFALSE 18326
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
18242: LD_ADDR_EXP 12
18246: PUSH
18247: LD_EXP 12
18251: PUSH
18252: LD_VAR 0 1
18256: PPUSH
18257: CALL_OW 266
18261: ADD
18262: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
18263: LD_ADDR_EXP 12
18267: PUSH
18268: LD_EXP 12
18272: PUSH
18273: LD_VAR 0 1
18277: PPUSH
18278: CALL_OW 250
18282: ADD
18283: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
18284: LD_ADDR_EXP 12
18288: PUSH
18289: LD_EXP 12
18293: PUSH
18294: LD_VAR 0 1
18298: PPUSH
18299: CALL_OW 251
18303: ADD
18304: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
18305: LD_ADDR_EXP 12
18309: PUSH
18310: LD_EXP 12
18314: PUSH
18315: LD_VAR 0 1
18319: PPUSH
18320: CALL_OW 254
18324: ADD
18325: ST_TO_ADDR
// end ; if un in ru_attack_list then
18326: LD_VAR 0 1
18330: PUSH
18331: LD_EXP 9
18335: IN
18336: IFFALSE 18354
// ru_attack_list := ru_attack_list diff un ;
18338: LD_ADDR_EXP 9
18342: PUSH
18343: LD_EXP 9
18347: PUSH
18348: LD_VAR 0 1
18352: DIFF
18353: ST_TO_ADDR
// if un in ru_protector then
18354: LD_VAR 0 1
18358: PUSH
18359: LD_EXP 16
18363: IN
18364: IFFALSE 18382
// ru_protector := ru_protector diff un ;
18366: LD_ADDR_EXP 16
18370: PUSH
18371: LD_EXP 16
18375: PUSH
18376: LD_VAR 0 1
18380: DIFF
18381: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
18382: LD_VAR 0 1
18386: PPUSH
18387: CALL_OW 266
18391: PUSH
18392: LD_INT 30
18394: EQUAL
18395: PUSH
18396: LD_VAR 0 1
18400: PPUSH
18401: CALL_OW 255
18405: PUSH
18406: LD_INT 1
18408: EQUAL
18409: AND
18410: IFFALSE 18420
// mine_ck := true ;
18412: LD_ADDR_EXP 34
18416: PUSH
18417: LD_INT 1
18419: ST_TO_ADDR
// end ;
18420: PPOPN 1
18422: END
// on BuildingComplete ( un ) do var i ;
18423: LD_INT 0
18425: PPUSH
// begin if GetSide ( un ) = 1 and GetBType ( un ) = b_siberite_mine then
18426: LD_VAR 0 1
18430: PPUSH
18431: CALL_OW 255
18435: PUSH
18436: LD_INT 1
18438: EQUAL
18439: PUSH
18440: LD_VAR 0 1
18444: PPUSH
18445: CALL_OW 266
18449: PUSH
18450: LD_INT 30
18452: EQUAL
18453: AND
18454: IFFALSE 18464
// mine_constructed := true ;
18456: LD_ADDR_EXP 36
18460: PUSH
18461: LD_INT 1
18463: ST_TO_ADDR
// if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
18464: LD_VAR 0 1
18468: PPUSH
18469: CALL_OW 255
18473: PUSH
18474: LD_INT 3
18476: EQUAL
18477: PUSH
18478: LD_VAR 0 1
18482: PPUSH
18483: CALL_OW 266
18487: PUSH
18488: LD_INT 0
18490: EQUAL
18491: AND
18492: IFFALSE 18549
// begin for i = 1 to 2 do
18494: LD_ADDR_VAR 0 2
18498: PUSH
18499: DOUBLE
18500: LD_INT 1
18502: DEC
18503: ST_TO_ADDR
18504: LD_INT 2
18506: PUSH
18507: FOR_TO
18508: IFFALSE 18547
// begin ComExitBuilding ( ru_sold [ i ] ) ;
18510: LD_EXP 19
18514: PUSH
18515: LD_VAR 0 2
18519: ARRAY
18520: PPUSH
18521: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
18525: LD_EXP 19
18529: PUSH
18530: LD_VAR 0 2
18534: ARRAY
18535: PPUSH
18536: LD_VAR 0 1
18540: PPUSH
18541: CALL_OW 180
// end ;
18545: GO 18507
18547: POP
18548: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
18549: LD_VAR 0 1
18553: PPUSH
18554: CALL_OW 255
18558: PUSH
18559: LD_INT 3
18561: EQUAL
18562: PUSH
18563: LD_VAR 0 1
18567: PPUSH
18568: CALL_OW 266
18572: PUSH
18573: LD_EXP 12
18577: IN
18578: AND
18579: IFFALSE 18619
// for i = 1 to 4 do
18581: LD_ADDR_VAR 0 2
18585: PUSH
18586: DOUBLE
18587: LD_INT 1
18589: DEC
18590: ST_TO_ADDR
18591: LD_INT 4
18593: PUSH
18594: FOR_TO
18595: IFFALSE 18617
// ru_blist := Delete ( ru_blist , 1 ) ;
18597: LD_ADDR_EXP 12
18601: PUSH
18602: LD_EXP 12
18606: PPUSH
18607: LD_INT 1
18609: PPUSH
18610: CALL_OW 3
18614: ST_TO_ADDR
18615: GO 18594
18617: POP
18618: POP
// end ;
18619: PPOPN 2
18621: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
18622: LD_VAR 0 1
18626: PPUSH
18627: LD_VAR 0 2
18631: PPUSH
18632: LD_VAR 0 3
18636: PPUSH
18637: CALL 29637 0 3
// end ;
18641: PPOPN 3
18643: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18644: LD_VAR 0 1
18648: PPUSH
18649: CALL 29645 0 1
// end ; end_of_file
18653: PPOPN 1
18655: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18656: GO 18658
18658: DISABLE
// begin ru_radar := 98 ;
18659: LD_ADDR_EXP 42
18663: PUSH
18664: LD_INT 98
18666: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18667: LD_ADDR_EXP 43
18671: PUSH
18672: LD_INT 89
18674: ST_TO_ADDR
// us_hack := 99 ;
18675: LD_ADDR_EXP 44
18679: PUSH
18680: LD_INT 99
18682: ST_TO_ADDR
// us_artillery := 97 ;
18683: LD_ADDR_EXP 45
18687: PUSH
18688: LD_INT 97
18690: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18691: LD_ADDR_EXP 46
18695: PUSH
18696: LD_INT 91
18698: ST_TO_ADDR
// end ; end_of_file end_of_file
18699: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18700: GO 18702
18702: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18703: LD_STRING initStreamRollete();
18705: PPUSH
18706: CALL_OW 559
// InitStreamMode ;
18710: CALL 18719 0 0
// DefineStreamItems ( ) ;
18714: CALL 19159 0 0
// end ;
18718: END
// function InitStreamMode ; begin
18719: LD_INT 0
18721: PPUSH
// streamModeActive := false ;
18722: LD_ADDR_EXP 47
18726: PUSH
18727: LD_INT 0
18729: ST_TO_ADDR
// normalCounter := 36 ;
18730: LD_ADDR_EXP 48
18734: PUSH
18735: LD_INT 36
18737: ST_TO_ADDR
// hardcoreCounter := 16 ;
18738: LD_ADDR_EXP 49
18742: PUSH
18743: LD_INT 16
18745: ST_TO_ADDR
// sRocket := false ;
18746: LD_ADDR_EXP 52
18750: PUSH
18751: LD_INT 0
18753: ST_TO_ADDR
// sSpeed := false ;
18754: LD_ADDR_EXP 51
18758: PUSH
18759: LD_INT 0
18761: ST_TO_ADDR
// sEngine := false ;
18762: LD_ADDR_EXP 53
18766: PUSH
18767: LD_INT 0
18769: ST_TO_ADDR
// sSpec := false ;
18770: LD_ADDR_EXP 50
18774: PUSH
18775: LD_INT 0
18777: ST_TO_ADDR
// sLevel := false ;
18778: LD_ADDR_EXP 54
18782: PUSH
18783: LD_INT 0
18785: ST_TO_ADDR
// sArmoury := false ;
18786: LD_ADDR_EXP 55
18790: PUSH
18791: LD_INT 0
18793: ST_TO_ADDR
// sRadar := false ;
18794: LD_ADDR_EXP 56
18798: PUSH
18799: LD_INT 0
18801: ST_TO_ADDR
// sBunker := false ;
18802: LD_ADDR_EXP 57
18806: PUSH
18807: LD_INT 0
18809: ST_TO_ADDR
// sHack := false ;
18810: LD_ADDR_EXP 58
18814: PUSH
18815: LD_INT 0
18817: ST_TO_ADDR
// sFire := false ;
18818: LD_ADDR_EXP 59
18822: PUSH
18823: LD_INT 0
18825: ST_TO_ADDR
// sRefresh := false ;
18826: LD_ADDR_EXP 60
18830: PUSH
18831: LD_INT 0
18833: ST_TO_ADDR
// sExp := false ;
18834: LD_ADDR_EXP 61
18838: PUSH
18839: LD_INT 0
18841: ST_TO_ADDR
// sDepot := false ;
18842: LD_ADDR_EXP 62
18846: PUSH
18847: LD_INT 0
18849: ST_TO_ADDR
// sFlag := false ;
18850: LD_ADDR_EXP 63
18854: PUSH
18855: LD_INT 0
18857: ST_TO_ADDR
// sKamikadze := false ;
18858: LD_ADDR_EXP 71
18862: PUSH
18863: LD_INT 0
18865: ST_TO_ADDR
// sTroll := false ;
18866: LD_ADDR_EXP 72
18870: PUSH
18871: LD_INT 0
18873: ST_TO_ADDR
// sSlow := false ;
18874: LD_ADDR_EXP 73
18878: PUSH
18879: LD_INT 0
18881: ST_TO_ADDR
// sLack := false ;
18882: LD_ADDR_EXP 74
18886: PUSH
18887: LD_INT 0
18889: ST_TO_ADDR
// sTank := false ;
18890: LD_ADDR_EXP 76
18894: PUSH
18895: LD_INT 0
18897: ST_TO_ADDR
// sRemote := false ;
18898: LD_ADDR_EXP 77
18902: PUSH
18903: LD_INT 0
18905: ST_TO_ADDR
// sPowell := false ;
18906: LD_ADDR_EXP 78
18910: PUSH
18911: LD_INT 0
18913: ST_TO_ADDR
// sTeleport := false ;
18914: LD_ADDR_EXP 81
18918: PUSH
18919: LD_INT 0
18921: ST_TO_ADDR
// sOilTower := false ;
18922: LD_ADDR_EXP 83
18926: PUSH
18927: LD_INT 0
18929: ST_TO_ADDR
// sShovel := false ;
18930: LD_ADDR_EXP 84
18934: PUSH
18935: LD_INT 0
18937: ST_TO_ADDR
// sSheik := false ;
18938: LD_ADDR_EXP 85
18942: PUSH
18943: LD_INT 0
18945: ST_TO_ADDR
// sEarthquake := false ;
18946: LD_ADDR_EXP 87
18950: PUSH
18951: LD_INT 0
18953: ST_TO_ADDR
// sAI := false ;
18954: LD_ADDR_EXP 88
18958: PUSH
18959: LD_INT 0
18961: ST_TO_ADDR
// sCargo := false ;
18962: LD_ADDR_EXP 91
18966: PUSH
18967: LD_INT 0
18969: ST_TO_ADDR
// sDLaser := false ;
18970: LD_ADDR_EXP 92
18974: PUSH
18975: LD_INT 0
18977: ST_TO_ADDR
// sExchange := false ;
18978: LD_ADDR_EXP 93
18982: PUSH
18983: LD_INT 0
18985: ST_TO_ADDR
// sFac := false ;
18986: LD_ADDR_EXP 94
18990: PUSH
18991: LD_INT 0
18993: ST_TO_ADDR
// sPower := false ;
18994: LD_ADDR_EXP 95
18998: PUSH
18999: LD_INT 0
19001: ST_TO_ADDR
// sRandom := false ;
19002: LD_ADDR_EXP 96
19006: PUSH
19007: LD_INT 0
19009: ST_TO_ADDR
// sShield := false ;
19010: LD_ADDR_EXP 97
19014: PUSH
19015: LD_INT 0
19017: ST_TO_ADDR
// sTime := false ;
19018: LD_ADDR_EXP 98
19022: PUSH
19023: LD_INT 0
19025: ST_TO_ADDR
// sTools := false ;
19026: LD_ADDR_EXP 99
19030: PUSH
19031: LD_INT 0
19033: ST_TO_ADDR
// sSold := false ;
19034: LD_ADDR_EXP 64
19038: PUSH
19039: LD_INT 0
19041: ST_TO_ADDR
// sDiff := false ;
19042: LD_ADDR_EXP 65
19046: PUSH
19047: LD_INT 0
19049: ST_TO_ADDR
// sFog := false ;
19050: LD_ADDR_EXP 68
19054: PUSH
19055: LD_INT 0
19057: ST_TO_ADDR
// sReset := false ;
19058: LD_ADDR_EXP 69
19062: PUSH
19063: LD_INT 0
19065: ST_TO_ADDR
// sSun := false ;
19066: LD_ADDR_EXP 70
19070: PUSH
19071: LD_INT 0
19073: ST_TO_ADDR
// sTiger := false ;
19074: LD_ADDR_EXP 66
19078: PUSH
19079: LD_INT 0
19081: ST_TO_ADDR
// sBomb := false ;
19082: LD_ADDR_EXP 67
19086: PUSH
19087: LD_INT 0
19089: ST_TO_ADDR
// sWound := false ;
19090: LD_ADDR_EXP 75
19094: PUSH
19095: LD_INT 0
19097: ST_TO_ADDR
// sBetray := false ;
19098: LD_ADDR_EXP 79
19102: PUSH
19103: LD_INT 0
19105: ST_TO_ADDR
// sContamin := false ;
19106: LD_ADDR_EXP 80
19110: PUSH
19111: LD_INT 0
19113: ST_TO_ADDR
// sOil := false ;
19114: LD_ADDR_EXP 82
19118: PUSH
19119: LD_INT 0
19121: ST_TO_ADDR
// sStu := false ;
19122: LD_ADDR_EXP 86
19126: PUSH
19127: LD_INT 0
19129: ST_TO_ADDR
// sBazooka := false ;
19130: LD_ADDR_EXP 89
19134: PUSH
19135: LD_INT 0
19137: ST_TO_ADDR
// sMortar := false ;
19138: LD_ADDR_EXP 90
19142: PUSH
19143: LD_INT 0
19145: ST_TO_ADDR
// sRanger := false ;
19146: LD_ADDR_EXP 100
19150: PUSH
19151: LD_INT 0
19153: ST_TO_ADDR
// end ;
19154: LD_VAR 0 1
19158: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19159: LD_INT 0
19161: PPUSH
19162: PPUSH
19163: PPUSH
19164: PPUSH
19165: PPUSH
// result := [ ] ;
19166: LD_ADDR_VAR 0 1
19170: PUSH
19171: EMPTY
19172: ST_TO_ADDR
// if campaign_id = 1 then
19173: LD_OWVAR 69
19177: PUSH
19178: LD_INT 1
19180: EQUAL
19181: IFFALSE 22119
// begin case mission_number of 1 :
19183: LD_OWVAR 70
19187: PUSH
19188: LD_INT 1
19190: DOUBLE
19191: EQUAL
19192: IFTRUE 19196
19194: GO 19260
19196: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19197: LD_ADDR_VAR 0 1
19201: PUSH
19202: LD_INT 2
19204: PUSH
19205: LD_INT 4
19207: PUSH
19208: LD_INT 11
19210: PUSH
19211: LD_INT 12
19213: PUSH
19214: LD_INT 15
19216: PUSH
19217: LD_INT 16
19219: PUSH
19220: LD_INT 22
19222: PUSH
19223: LD_INT 23
19225: PUSH
19226: LD_INT 26
19228: PUSH
19229: EMPTY
19230: LIST
19231: LIST
19232: LIST
19233: LIST
19234: LIST
19235: LIST
19236: LIST
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 101
19242: PUSH
19243: LD_INT 102
19245: PUSH
19246: LD_INT 106
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: LIST
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: ST_TO_ADDR
19258: GO 22117
19260: LD_INT 2
19262: DOUBLE
19263: EQUAL
19264: IFTRUE 19268
19266: GO 19340
19268: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19269: LD_ADDR_VAR 0 1
19273: PUSH
19274: LD_INT 2
19276: PUSH
19277: LD_INT 4
19279: PUSH
19280: LD_INT 11
19282: PUSH
19283: LD_INT 12
19285: PUSH
19286: LD_INT 15
19288: PUSH
19289: LD_INT 16
19291: PUSH
19292: LD_INT 22
19294: PUSH
19295: LD_INT 23
19297: PUSH
19298: LD_INT 26
19300: PUSH
19301: EMPTY
19302: LIST
19303: LIST
19304: LIST
19305: LIST
19306: LIST
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: PUSH
19312: LD_INT 101
19314: PUSH
19315: LD_INT 102
19317: PUSH
19318: LD_INT 105
19320: PUSH
19321: LD_INT 106
19323: PUSH
19324: LD_INT 108
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: LIST
19331: LIST
19332: LIST
19333: PUSH
19334: EMPTY
19335: LIST
19336: LIST
19337: ST_TO_ADDR
19338: GO 22117
19340: LD_INT 3
19342: DOUBLE
19343: EQUAL
19344: IFTRUE 19348
19346: GO 19424
19348: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19349: LD_ADDR_VAR 0 1
19353: PUSH
19354: LD_INT 2
19356: PUSH
19357: LD_INT 4
19359: PUSH
19360: LD_INT 5
19362: PUSH
19363: LD_INT 11
19365: PUSH
19366: LD_INT 12
19368: PUSH
19369: LD_INT 15
19371: PUSH
19372: LD_INT 16
19374: PUSH
19375: LD_INT 22
19377: PUSH
19378: LD_INT 26
19380: PUSH
19381: LD_INT 36
19383: PUSH
19384: EMPTY
19385: LIST
19386: LIST
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: LIST
19393: LIST
19394: LIST
19395: PUSH
19396: LD_INT 101
19398: PUSH
19399: LD_INT 102
19401: PUSH
19402: LD_INT 105
19404: PUSH
19405: LD_INT 106
19407: PUSH
19408: LD_INT 108
19410: PUSH
19411: EMPTY
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: PUSH
19418: EMPTY
19419: LIST
19420: LIST
19421: ST_TO_ADDR
19422: GO 22117
19424: LD_INT 4
19426: DOUBLE
19427: EQUAL
19428: IFTRUE 19432
19430: GO 19516
19432: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19433: LD_ADDR_VAR 0 1
19437: PUSH
19438: LD_INT 2
19440: PUSH
19441: LD_INT 4
19443: PUSH
19444: LD_INT 5
19446: PUSH
19447: LD_INT 8
19449: PUSH
19450: LD_INT 11
19452: PUSH
19453: LD_INT 12
19455: PUSH
19456: LD_INT 15
19458: PUSH
19459: LD_INT 16
19461: PUSH
19462: LD_INT 22
19464: PUSH
19465: LD_INT 23
19467: PUSH
19468: LD_INT 26
19470: PUSH
19471: LD_INT 36
19473: PUSH
19474: EMPTY
19475: LIST
19476: LIST
19477: LIST
19478: LIST
19479: LIST
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: PUSH
19488: LD_INT 101
19490: PUSH
19491: LD_INT 102
19493: PUSH
19494: LD_INT 105
19496: PUSH
19497: LD_INT 106
19499: PUSH
19500: LD_INT 108
19502: PUSH
19503: EMPTY
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: PUSH
19510: EMPTY
19511: LIST
19512: LIST
19513: ST_TO_ADDR
19514: GO 22117
19516: LD_INT 5
19518: DOUBLE
19519: EQUAL
19520: IFTRUE 19524
19522: GO 19624
19524: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19525: LD_ADDR_VAR 0 1
19529: PUSH
19530: LD_INT 2
19532: PUSH
19533: LD_INT 4
19535: PUSH
19536: LD_INT 5
19538: PUSH
19539: LD_INT 6
19541: PUSH
19542: LD_INT 8
19544: PUSH
19545: LD_INT 11
19547: PUSH
19548: LD_INT 12
19550: PUSH
19551: LD_INT 15
19553: PUSH
19554: LD_INT 16
19556: PUSH
19557: LD_INT 22
19559: PUSH
19560: LD_INT 23
19562: PUSH
19563: LD_INT 25
19565: PUSH
19566: LD_INT 26
19568: PUSH
19569: LD_INT 36
19571: PUSH
19572: EMPTY
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: LIST
19587: PUSH
19588: LD_INT 101
19590: PUSH
19591: LD_INT 102
19593: PUSH
19594: LD_INT 105
19596: PUSH
19597: LD_INT 106
19599: PUSH
19600: LD_INT 108
19602: PUSH
19603: LD_INT 109
19605: PUSH
19606: LD_INT 112
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: LIST
19613: LIST
19614: LIST
19615: LIST
19616: LIST
19617: PUSH
19618: EMPTY
19619: LIST
19620: LIST
19621: ST_TO_ADDR
19622: GO 22117
19624: LD_INT 6
19626: DOUBLE
19627: EQUAL
19628: IFTRUE 19632
19630: GO 19752
19632: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19633: LD_ADDR_VAR 0 1
19637: PUSH
19638: LD_INT 2
19640: PUSH
19641: LD_INT 4
19643: PUSH
19644: LD_INT 5
19646: PUSH
19647: LD_INT 6
19649: PUSH
19650: LD_INT 8
19652: PUSH
19653: LD_INT 11
19655: PUSH
19656: LD_INT 12
19658: PUSH
19659: LD_INT 15
19661: PUSH
19662: LD_INT 16
19664: PUSH
19665: LD_INT 20
19667: PUSH
19668: LD_INT 21
19670: PUSH
19671: LD_INT 22
19673: PUSH
19674: LD_INT 23
19676: PUSH
19677: LD_INT 25
19679: PUSH
19680: LD_INT 26
19682: PUSH
19683: LD_INT 30
19685: PUSH
19686: LD_INT 31
19688: PUSH
19689: LD_INT 32
19691: PUSH
19692: LD_INT 36
19694: PUSH
19695: EMPTY
19696: LIST
19697: LIST
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: LIST
19705: LIST
19706: LIST
19707: LIST
19708: LIST
19709: LIST
19710: LIST
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: PUSH
19716: LD_INT 101
19718: PUSH
19719: LD_INT 102
19721: PUSH
19722: LD_INT 105
19724: PUSH
19725: LD_INT 106
19727: PUSH
19728: LD_INT 108
19730: PUSH
19731: LD_INT 109
19733: PUSH
19734: LD_INT 112
19736: PUSH
19737: EMPTY
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: PUSH
19746: EMPTY
19747: LIST
19748: LIST
19749: ST_TO_ADDR
19750: GO 22117
19752: LD_INT 7
19754: DOUBLE
19755: EQUAL
19756: IFTRUE 19760
19758: GO 19860
19760: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19761: LD_ADDR_VAR 0 1
19765: PUSH
19766: LD_INT 2
19768: PUSH
19769: LD_INT 4
19771: PUSH
19772: LD_INT 5
19774: PUSH
19775: LD_INT 7
19777: PUSH
19778: LD_INT 11
19780: PUSH
19781: LD_INT 12
19783: PUSH
19784: LD_INT 15
19786: PUSH
19787: LD_INT 16
19789: PUSH
19790: LD_INT 20
19792: PUSH
19793: LD_INT 21
19795: PUSH
19796: LD_INT 22
19798: PUSH
19799: LD_INT 23
19801: PUSH
19802: LD_INT 25
19804: PUSH
19805: LD_INT 26
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: LIST
19815: LIST
19816: LIST
19817: LIST
19818: LIST
19819: LIST
19820: LIST
19821: LIST
19822: LIST
19823: PUSH
19824: LD_INT 101
19826: PUSH
19827: LD_INT 102
19829: PUSH
19830: LD_INT 103
19832: PUSH
19833: LD_INT 105
19835: PUSH
19836: LD_INT 106
19838: PUSH
19839: LD_INT 108
19841: PUSH
19842: LD_INT 112
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: LIST
19852: LIST
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: ST_TO_ADDR
19858: GO 22117
19860: LD_INT 8
19862: DOUBLE
19863: EQUAL
19864: IFTRUE 19868
19866: GO 19996
19868: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19869: LD_ADDR_VAR 0 1
19873: PUSH
19874: LD_INT 2
19876: PUSH
19877: LD_INT 4
19879: PUSH
19880: LD_INT 5
19882: PUSH
19883: LD_INT 6
19885: PUSH
19886: LD_INT 7
19888: PUSH
19889: LD_INT 8
19891: PUSH
19892: LD_INT 11
19894: PUSH
19895: LD_INT 12
19897: PUSH
19898: LD_INT 15
19900: PUSH
19901: LD_INT 16
19903: PUSH
19904: LD_INT 20
19906: PUSH
19907: LD_INT 21
19909: PUSH
19910: LD_INT 22
19912: PUSH
19913: LD_INT 23
19915: PUSH
19916: LD_INT 25
19918: PUSH
19919: LD_INT 26
19921: PUSH
19922: LD_INT 30
19924: PUSH
19925: LD_INT 31
19927: PUSH
19928: LD_INT 32
19930: PUSH
19931: LD_INT 36
19933: PUSH
19934: EMPTY
19935: LIST
19936: LIST
19937: LIST
19938: LIST
19939: LIST
19940: LIST
19941: LIST
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: PUSH
19956: LD_INT 101
19958: PUSH
19959: LD_INT 102
19961: PUSH
19962: LD_INT 103
19964: PUSH
19965: LD_INT 105
19967: PUSH
19968: LD_INT 106
19970: PUSH
19971: LD_INT 108
19973: PUSH
19974: LD_INT 109
19976: PUSH
19977: LD_INT 112
19979: PUSH
19980: EMPTY
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: PUSH
19990: EMPTY
19991: LIST
19992: LIST
19993: ST_TO_ADDR
19994: GO 22117
19996: LD_INT 9
19998: DOUBLE
19999: EQUAL
20000: IFTRUE 20004
20002: GO 20140
20004: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
20005: LD_ADDR_VAR 0 1
20009: PUSH
20010: LD_INT 2
20012: PUSH
20013: LD_INT 4
20015: PUSH
20016: LD_INT 5
20018: PUSH
20019: LD_INT 6
20021: PUSH
20022: LD_INT 7
20024: PUSH
20025: LD_INT 8
20027: PUSH
20028: LD_INT 11
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: LD_INT 15
20036: PUSH
20037: LD_INT 16
20039: PUSH
20040: LD_INT 20
20042: PUSH
20043: LD_INT 21
20045: PUSH
20046: LD_INT 22
20048: PUSH
20049: LD_INT 23
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 26
20057: PUSH
20058: LD_INT 28
20060: PUSH
20061: LD_INT 30
20063: PUSH
20064: LD_INT 31
20066: PUSH
20067: LD_INT 32
20069: PUSH
20070: LD_INT 36
20072: PUSH
20073: EMPTY
20074: LIST
20075: LIST
20076: LIST
20077: LIST
20078: LIST
20079: LIST
20080: LIST
20081: LIST
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: LIST
20087: LIST
20088: LIST
20089: LIST
20090: LIST
20091: LIST
20092: LIST
20093: LIST
20094: LIST
20095: PUSH
20096: LD_INT 101
20098: PUSH
20099: LD_INT 102
20101: PUSH
20102: LD_INT 103
20104: PUSH
20105: LD_INT 105
20107: PUSH
20108: LD_INT 106
20110: PUSH
20111: LD_INT 108
20113: PUSH
20114: LD_INT 109
20116: PUSH
20117: LD_INT 112
20119: PUSH
20120: LD_INT 114
20122: PUSH
20123: EMPTY
20124: LIST
20125: LIST
20126: LIST
20127: LIST
20128: LIST
20129: LIST
20130: LIST
20131: LIST
20132: LIST
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: ST_TO_ADDR
20138: GO 22117
20140: LD_INT 10
20142: DOUBLE
20143: EQUAL
20144: IFTRUE 20148
20146: GO 20332
20148: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20149: LD_ADDR_VAR 0 1
20153: PUSH
20154: LD_INT 2
20156: PUSH
20157: LD_INT 4
20159: PUSH
20160: LD_INT 5
20162: PUSH
20163: LD_INT 6
20165: PUSH
20166: LD_INT 7
20168: PUSH
20169: LD_INT 8
20171: PUSH
20172: LD_INT 9
20174: PUSH
20175: LD_INT 10
20177: PUSH
20178: LD_INT 11
20180: PUSH
20181: LD_INT 12
20183: PUSH
20184: LD_INT 13
20186: PUSH
20187: LD_INT 14
20189: PUSH
20190: LD_INT 15
20192: PUSH
20193: LD_INT 16
20195: PUSH
20196: LD_INT 17
20198: PUSH
20199: LD_INT 18
20201: PUSH
20202: LD_INT 19
20204: PUSH
20205: LD_INT 20
20207: PUSH
20208: LD_INT 21
20210: PUSH
20211: LD_INT 22
20213: PUSH
20214: LD_INT 23
20216: PUSH
20217: LD_INT 24
20219: PUSH
20220: LD_INT 25
20222: PUSH
20223: LD_INT 26
20225: PUSH
20226: LD_INT 28
20228: PUSH
20229: LD_INT 30
20231: PUSH
20232: LD_INT 31
20234: PUSH
20235: LD_INT 32
20237: PUSH
20238: LD_INT 36
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: LIST
20245: LIST
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: LIST
20251: LIST
20252: LIST
20253: LIST
20254: LIST
20255: LIST
20256: LIST
20257: LIST
20258: LIST
20259: LIST
20260: LIST
20261: LIST
20262: LIST
20263: LIST
20264: LIST
20265: LIST
20266: LIST
20267: LIST
20268: LIST
20269: LIST
20270: LIST
20271: PUSH
20272: LD_INT 101
20274: PUSH
20275: LD_INT 102
20277: PUSH
20278: LD_INT 103
20280: PUSH
20281: LD_INT 104
20283: PUSH
20284: LD_INT 105
20286: PUSH
20287: LD_INT 106
20289: PUSH
20290: LD_INT 107
20292: PUSH
20293: LD_INT 108
20295: PUSH
20296: LD_INT 109
20298: PUSH
20299: LD_INT 110
20301: PUSH
20302: LD_INT 111
20304: PUSH
20305: LD_INT 112
20307: PUSH
20308: LD_INT 114
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: LIST
20325: PUSH
20326: EMPTY
20327: LIST
20328: LIST
20329: ST_TO_ADDR
20330: GO 22117
20332: LD_INT 11
20334: DOUBLE
20335: EQUAL
20336: IFTRUE 20340
20338: GO 20532
20340: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20341: LD_ADDR_VAR 0 1
20345: PUSH
20346: LD_INT 2
20348: PUSH
20349: LD_INT 3
20351: PUSH
20352: LD_INT 4
20354: PUSH
20355: LD_INT 5
20357: PUSH
20358: LD_INT 6
20360: PUSH
20361: LD_INT 7
20363: PUSH
20364: LD_INT 8
20366: PUSH
20367: LD_INT 9
20369: PUSH
20370: LD_INT 10
20372: PUSH
20373: LD_INT 11
20375: PUSH
20376: LD_INT 12
20378: PUSH
20379: LD_INT 13
20381: PUSH
20382: LD_INT 14
20384: PUSH
20385: LD_INT 15
20387: PUSH
20388: LD_INT 16
20390: PUSH
20391: LD_INT 17
20393: PUSH
20394: LD_INT 18
20396: PUSH
20397: LD_INT 19
20399: PUSH
20400: LD_INT 20
20402: PUSH
20403: LD_INT 21
20405: PUSH
20406: LD_INT 22
20408: PUSH
20409: LD_INT 23
20411: PUSH
20412: LD_INT 24
20414: PUSH
20415: LD_INT 25
20417: PUSH
20418: LD_INT 26
20420: PUSH
20421: LD_INT 28
20423: PUSH
20424: LD_INT 30
20426: PUSH
20427: LD_INT 31
20429: PUSH
20430: LD_INT 32
20432: PUSH
20433: LD_INT 34
20435: PUSH
20436: LD_INT 36
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: LIST
20448: LIST
20449: LIST
20450: LIST
20451: LIST
20452: LIST
20453: LIST
20454: LIST
20455: LIST
20456: LIST
20457: LIST
20458: LIST
20459: LIST
20460: LIST
20461: LIST
20462: LIST
20463: LIST
20464: LIST
20465: LIST
20466: LIST
20467: LIST
20468: LIST
20469: LIST
20470: LIST
20471: PUSH
20472: LD_INT 101
20474: PUSH
20475: LD_INT 102
20477: PUSH
20478: LD_INT 103
20480: PUSH
20481: LD_INT 104
20483: PUSH
20484: LD_INT 105
20486: PUSH
20487: LD_INT 106
20489: PUSH
20490: LD_INT 107
20492: PUSH
20493: LD_INT 108
20495: PUSH
20496: LD_INT 109
20498: PUSH
20499: LD_INT 110
20501: PUSH
20502: LD_INT 111
20504: PUSH
20505: LD_INT 112
20507: PUSH
20508: LD_INT 114
20510: PUSH
20511: EMPTY
20512: LIST
20513: LIST
20514: LIST
20515: LIST
20516: LIST
20517: LIST
20518: LIST
20519: LIST
20520: LIST
20521: LIST
20522: LIST
20523: LIST
20524: LIST
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: ST_TO_ADDR
20530: GO 22117
20532: LD_INT 12
20534: DOUBLE
20535: EQUAL
20536: IFTRUE 20540
20538: GO 20748
20540: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20541: LD_ADDR_VAR 0 1
20545: PUSH
20546: LD_INT 1
20548: PUSH
20549: LD_INT 2
20551: PUSH
20552: LD_INT 3
20554: PUSH
20555: LD_INT 4
20557: PUSH
20558: LD_INT 5
20560: PUSH
20561: LD_INT 6
20563: PUSH
20564: LD_INT 7
20566: PUSH
20567: LD_INT 8
20569: PUSH
20570: LD_INT 9
20572: PUSH
20573: LD_INT 10
20575: PUSH
20576: LD_INT 11
20578: PUSH
20579: LD_INT 12
20581: PUSH
20582: LD_INT 13
20584: PUSH
20585: LD_INT 14
20587: PUSH
20588: LD_INT 15
20590: PUSH
20591: LD_INT 16
20593: PUSH
20594: LD_INT 17
20596: PUSH
20597: LD_INT 18
20599: PUSH
20600: LD_INT 19
20602: PUSH
20603: LD_INT 20
20605: PUSH
20606: LD_INT 21
20608: PUSH
20609: LD_INT 22
20611: PUSH
20612: LD_INT 23
20614: PUSH
20615: LD_INT 24
20617: PUSH
20618: LD_INT 25
20620: PUSH
20621: LD_INT 26
20623: PUSH
20624: LD_INT 27
20626: PUSH
20627: LD_INT 28
20629: PUSH
20630: LD_INT 30
20632: PUSH
20633: LD_INT 31
20635: PUSH
20636: LD_INT 32
20638: PUSH
20639: LD_INT 33
20641: PUSH
20642: LD_INT 34
20644: PUSH
20645: LD_INT 36
20647: PUSH
20648: EMPTY
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: LIST
20671: LIST
20672: LIST
20673: LIST
20674: LIST
20675: LIST
20676: LIST
20677: LIST
20678: LIST
20679: LIST
20680: LIST
20681: LIST
20682: LIST
20683: PUSH
20684: LD_INT 101
20686: PUSH
20687: LD_INT 102
20689: PUSH
20690: LD_INT 103
20692: PUSH
20693: LD_INT 104
20695: PUSH
20696: LD_INT 105
20698: PUSH
20699: LD_INT 106
20701: PUSH
20702: LD_INT 107
20704: PUSH
20705: LD_INT 108
20707: PUSH
20708: LD_INT 109
20710: PUSH
20711: LD_INT 110
20713: PUSH
20714: LD_INT 111
20716: PUSH
20717: LD_INT 112
20719: PUSH
20720: LD_INT 113
20722: PUSH
20723: LD_INT 114
20725: PUSH
20726: EMPTY
20727: LIST
20728: LIST
20729: LIST
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: LIST
20735: LIST
20736: LIST
20737: LIST
20738: LIST
20739: LIST
20740: LIST
20741: PUSH
20742: EMPTY
20743: LIST
20744: LIST
20745: ST_TO_ADDR
20746: GO 22117
20748: LD_INT 13
20750: DOUBLE
20751: EQUAL
20752: IFTRUE 20756
20754: GO 20952
20756: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20757: LD_ADDR_VAR 0 1
20761: PUSH
20762: LD_INT 1
20764: PUSH
20765: LD_INT 2
20767: PUSH
20768: LD_INT 3
20770: PUSH
20771: LD_INT 4
20773: PUSH
20774: LD_INT 5
20776: PUSH
20777: LD_INT 8
20779: PUSH
20780: LD_INT 9
20782: PUSH
20783: LD_INT 10
20785: PUSH
20786: LD_INT 11
20788: PUSH
20789: LD_INT 12
20791: PUSH
20792: LD_INT 14
20794: PUSH
20795: LD_INT 15
20797: PUSH
20798: LD_INT 16
20800: PUSH
20801: LD_INT 17
20803: PUSH
20804: LD_INT 18
20806: PUSH
20807: LD_INT 19
20809: PUSH
20810: LD_INT 20
20812: PUSH
20813: LD_INT 21
20815: PUSH
20816: LD_INT 22
20818: PUSH
20819: LD_INT 23
20821: PUSH
20822: LD_INT 24
20824: PUSH
20825: LD_INT 25
20827: PUSH
20828: LD_INT 26
20830: PUSH
20831: LD_INT 27
20833: PUSH
20834: LD_INT 28
20836: PUSH
20837: LD_INT 30
20839: PUSH
20840: LD_INT 31
20842: PUSH
20843: LD_INT 32
20845: PUSH
20846: LD_INT 33
20848: PUSH
20849: LD_INT 34
20851: PUSH
20852: LD_INT 36
20854: PUSH
20855: EMPTY
20856: LIST
20857: LIST
20858: LIST
20859: LIST
20860: LIST
20861: LIST
20862: LIST
20863: LIST
20864: LIST
20865: LIST
20866: LIST
20867: LIST
20868: LIST
20869: LIST
20870: LIST
20871: LIST
20872: LIST
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: LIST
20878: LIST
20879: LIST
20880: LIST
20881: LIST
20882: LIST
20883: LIST
20884: LIST
20885: LIST
20886: LIST
20887: PUSH
20888: LD_INT 101
20890: PUSH
20891: LD_INT 102
20893: PUSH
20894: LD_INT 103
20896: PUSH
20897: LD_INT 104
20899: PUSH
20900: LD_INT 105
20902: PUSH
20903: LD_INT 106
20905: PUSH
20906: LD_INT 107
20908: PUSH
20909: LD_INT 108
20911: PUSH
20912: LD_INT 109
20914: PUSH
20915: LD_INT 110
20917: PUSH
20918: LD_INT 111
20920: PUSH
20921: LD_INT 112
20923: PUSH
20924: LD_INT 113
20926: PUSH
20927: LD_INT 114
20929: PUSH
20930: EMPTY
20931: LIST
20932: LIST
20933: LIST
20934: LIST
20935: LIST
20936: LIST
20937: LIST
20938: LIST
20939: LIST
20940: LIST
20941: LIST
20942: LIST
20943: LIST
20944: LIST
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: ST_TO_ADDR
20950: GO 22117
20952: LD_INT 14
20954: DOUBLE
20955: EQUAL
20956: IFTRUE 20960
20958: GO 21172
20960: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20961: LD_ADDR_VAR 0 1
20965: PUSH
20966: LD_INT 1
20968: PUSH
20969: LD_INT 2
20971: PUSH
20972: LD_INT 3
20974: PUSH
20975: LD_INT 4
20977: PUSH
20978: LD_INT 5
20980: PUSH
20981: LD_INT 6
20983: PUSH
20984: LD_INT 7
20986: PUSH
20987: LD_INT 8
20989: PUSH
20990: LD_INT 9
20992: PUSH
20993: LD_INT 10
20995: PUSH
20996: LD_INT 11
20998: PUSH
20999: LD_INT 12
21001: PUSH
21002: LD_INT 13
21004: PUSH
21005: LD_INT 14
21007: PUSH
21008: LD_INT 15
21010: PUSH
21011: LD_INT 16
21013: PUSH
21014: LD_INT 17
21016: PUSH
21017: LD_INT 18
21019: PUSH
21020: LD_INT 19
21022: PUSH
21023: LD_INT 20
21025: PUSH
21026: LD_INT 21
21028: PUSH
21029: LD_INT 22
21031: PUSH
21032: LD_INT 23
21034: PUSH
21035: LD_INT 24
21037: PUSH
21038: LD_INT 25
21040: PUSH
21041: LD_INT 26
21043: PUSH
21044: LD_INT 27
21046: PUSH
21047: LD_INT 28
21049: PUSH
21050: LD_INT 29
21052: PUSH
21053: LD_INT 30
21055: PUSH
21056: LD_INT 31
21058: PUSH
21059: LD_INT 32
21061: PUSH
21062: LD_INT 33
21064: PUSH
21065: LD_INT 34
21067: PUSH
21068: LD_INT 36
21070: PUSH
21071: EMPTY
21072: LIST
21073: LIST
21074: LIST
21075: LIST
21076: LIST
21077: LIST
21078: LIST
21079: LIST
21080: LIST
21081: LIST
21082: LIST
21083: LIST
21084: LIST
21085: LIST
21086: LIST
21087: LIST
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: LIST
21093: LIST
21094: LIST
21095: LIST
21096: LIST
21097: LIST
21098: LIST
21099: LIST
21100: LIST
21101: LIST
21102: LIST
21103: LIST
21104: LIST
21105: LIST
21106: LIST
21107: PUSH
21108: LD_INT 101
21110: PUSH
21111: LD_INT 102
21113: PUSH
21114: LD_INT 103
21116: PUSH
21117: LD_INT 104
21119: PUSH
21120: LD_INT 105
21122: PUSH
21123: LD_INT 106
21125: PUSH
21126: LD_INT 107
21128: PUSH
21129: LD_INT 108
21131: PUSH
21132: LD_INT 109
21134: PUSH
21135: LD_INT 110
21137: PUSH
21138: LD_INT 111
21140: PUSH
21141: LD_INT 112
21143: PUSH
21144: LD_INT 113
21146: PUSH
21147: LD_INT 114
21149: PUSH
21150: EMPTY
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: LIST
21160: LIST
21161: LIST
21162: LIST
21163: LIST
21164: LIST
21165: PUSH
21166: EMPTY
21167: LIST
21168: LIST
21169: ST_TO_ADDR
21170: GO 22117
21172: LD_INT 15
21174: DOUBLE
21175: EQUAL
21176: IFTRUE 21180
21178: GO 21392
21180: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21181: LD_ADDR_VAR 0 1
21185: PUSH
21186: LD_INT 1
21188: PUSH
21189: LD_INT 2
21191: PUSH
21192: LD_INT 3
21194: PUSH
21195: LD_INT 4
21197: PUSH
21198: LD_INT 5
21200: PUSH
21201: LD_INT 6
21203: PUSH
21204: LD_INT 7
21206: PUSH
21207: LD_INT 8
21209: PUSH
21210: LD_INT 9
21212: PUSH
21213: LD_INT 10
21215: PUSH
21216: LD_INT 11
21218: PUSH
21219: LD_INT 12
21221: PUSH
21222: LD_INT 13
21224: PUSH
21225: LD_INT 14
21227: PUSH
21228: LD_INT 15
21230: PUSH
21231: LD_INT 16
21233: PUSH
21234: LD_INT 17
21236: PUSH
21237: LD_INT 18
21239: PUSH
21240: LD_INT 19
21242: PUSH
21243: LD_INT 20
21245: PUSH
21246: LD_INT 21
21248: PUSH
21249: LD_INT 22
21251: PUSH
21252: LD_INT 23
21254: PUSH
21255: LD_INT 24
21257: PUSH
21258: LD_INT 25
21260: PUSH
21261: LD_INT 26
21263: PUSH
21264: LD_INT 27
21266: PUSH
21267: LD_INT 28
21269: PUSH
21270: LD_INT 29
21272: PUSH
21273: LD_INT 30
21275: PUSH
21276: LD_INT 31
21278: PUSH
21279: LD_INT 32
21281: PUSH
21282: LD_INT 33
21284: PUSH
21285: LD_INT 34
21287: PUSH
21288: LD_INT 36
21290: PUSH
21291: EMPTY
21292: LIST
21293: LIST
21294: LIST
21295: LIST
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: LIST
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: LIST
21313: LIST
21314: LIST
21315: LIST
21316: LIST
21317: LIST
21318: LIST
21319: LIST
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: LIST
21327: PUSH
21328: LD_INT 101
21330: PUSH
21331: LD_INT 102
21333: PUSH
21334: LD_INT 103
21336: PUSH
21337: LD_INT 104
21339: PUSH
21340: LD_INT 105
21342: PUSH
21343: LD_INT 106
21345: PUSH
21346: LD_INT 107
21348: PUSH
21349: LD_INT 108
21351: PUSH
21352: LD_INT 109
21354: PUSH
21355: LD_INT 110
21357: PUSH
21358: LD_INT 111
21360: PUSH
21361: LD_INT 112
21363: PUSH
21364: LD_INT 113
21366: PUSH
21367: LD_INT 114
21369: PUSH
21370: EMPTY
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: LIST
21379: LIST
21380: LIST
21381: LIST
21382: LIST
21383: LIST
21384: LIST
21385: PUSH
21386: EMPTY
21387: LIST
21388: LIST
21389: ST_TO_ADDR
21390: GO 22117
21392: LD_INT 16
21394: DOUBLE
21395: EQUAL
21396: IFTRUE 21400
21398: GO 21524
21400: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21401: LD_ADDR_VAR 0 1
21405: PUSH
21406: LD_INT 2
21408: PUSH
21409: LD_INT 4
21411: PUSH
21412: LD_INT 5
21414: PUSH
21415: LD_INT 7
21417: PUSH
21418: LD_INT 11
21420: PUSH
21421: LD_INT 12
21423: PUSH
21424: LD_INT 15
21426: PUSH
21427: LD_INT 16
21429: PUSH
21430: LD_INT 20
21432: PUSH
21433: LD_INT 21
21435: PUSH
21436: LD_INT 22
21438: PUSH
21439: LD_INT 23
21441: PUSH
21442: LD_INT 25
21444: PUSH
21445: LD_INT 26
21447: PUSH
21448: LD_INT 30
21450: PUSH
21451: LD_INT 31
21453: PUSH
21454: LD_INT 32
21456: PUSH
21457: LD_INT 33
21459: PUSH
21460: LD_INT 34
21462: PUSH
21463: EMPTY
21464: LIST
21465: LIST
21466: LIST
21467: LIST
21468: LIST
21469: LIST
21470: LIST
21471: LIST
21472: LIST
21473: LIST
21474: LIST
21475: LIST
21476: LIST
21477: LIST
21478: LIST
21479: LIST
21480: LIST
21481: LIST
21482: LIST
21483: PUSH
21484: LD_INT 101
21486: PUSH
21487: LD_INT 102
21489: PUSH
21490: LD_INT 103
21492: PUSH
21493: LD_INT 106
21495: PUSH
21496: LD_INT 108
21498: PUSH
21499: LD_INT 112
21501: PUSH
21502: LD_INT 113
21504: PUSH
21505: LD_INT 114
21507: PUSH
21508: EMPTY
21509: LIST
21510: LIST
21511: LIST
21512: LIST
21513: LIST
21514: LIST
21515: LIST
21516: LIST
21517: PUSH
21518: EMPTY
21519: LIST
21520: LIST
21521: ST_TO_ADDR
21522: GO 22117
21524: LD_INT 17
21526: DOUBLE
21527: EQUAL
21528: IFTRUE 21532
21530: GO 21744
21532: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21533: LD_ADDR_VAR 0 1
21537: PUSH
21538: LD_INT 1
21540: PUSH
21541: LD_INT 2
21543: PUSH
21544: LD_INT 3
21546: PUSH
21547: LD_INT 4
21549: PUSH
21550: LD_INT 5
21552: PUSH
21553: LD_INT 6
21555: PUSH
21556: LD_INT 7
21558: PUSH
21559: LD_INT 8
21561: PUSH
21562: LD_INT 9
21564: PUSH
21565: LD_INT 10
21567: PUSH
21568: LD_INT 11
21570: PUSH
21571: LD_INT 12
21573: PUSH
21574: LD_INT 13
21576: PUSH
21577: LD_INT 14
21579: PUSH
21580: LD_INT 15
21582: PUSH
21583: LD_INT 16
21585: PUSH
21586: LD_INT 17
21588: PUSH
21589: LD_INT 18
21591: PUSH
21592: LD_INT 19
21594: PUSH
21595: LD_INT 20
21597: PUSH
21598: LD_INT 21
21600: PUSH
21601: LD_INT 22
21603: PUSH
21604: LD_INT 23
21606: PUSH
21607: LD_INT 24
21609: PUSH
21610: LD_INT 25
21612: PUSH
21613: LD_INT 26
21615: PUSH
21616: LD_INT 27
21618: PUSH
21619: LD_INT 28
21621: PUSH
21622: LD_INT 29
21624: PUSH
21625: LD_INT 30
21627: PUSH
21628: LD_INT 31
21630: PUSH
21631: LD_INT 32
21633: PUSH
21634: LD_INT 33
21636: PUSH
21637: LD_INT 34
21639: PUSH
21640: LD_INT 36
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: LIST
21653: LIST
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: LIST
21668: LIST
21669: LIST
21670: LIST
21671: LIST
21672: LIST
21673: LIST
21674: LIST
21675: LIST
21676: LIST
21677: LIST
21678: LIST
21679: PUSH
21680: LD_INT 101
21682: PUSH
21683: LD_INT 102
21685: PUSH
21686: LD_INT 103
21688: PUSH
21689: LD_INT 104
21691: PUSH
21692: LD_INT 105
21694: PUSH
21695: LD_INT 106
21697: PUSH
21698: LD_INT 107
21700: PUSH
21701: LD_INT 108
21703: PUSH
21704: LD_INT 109
21706: PUSH
21707: LD_INT 110
21709: PUSH
21710: LD_INT 111
21712: PUSH
21713: LD_INT 112
21715: PUSH
21716: LD_INT 113
21718: PUSH
21719: LD_INT 114
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: LIST
21726: LIST
21727: LIST
21728: LIST
21729: LIST
21730: LIST
21731: LIST
21732: LIST
21733: LIST
21734: LIST
21735: LIST
21736: LIST
21737: PUSH
21738: EMPTY
21739: LIST
21740: LIST
21741: ST_TO_ADDR
21742: GO 22117
21744: LD_INT 18
21746: DOUBLE
21747: EQUAL
21748: IFTRUE 21752
21750: GO 21888
21752: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21753: LD_ADDR_VAR 0 1
21757: PUSH
21758: LD_INT 2
21760: PUSH
21761: LD_INT 4
21763: PUSH
21764: LD_INT 5
21766: PUSH
21767: LD_INT 7
21769: PUSH
21770: LD_INT 11
21772: PUSH
21773: LD_INT 12
21775: PUSH
21776: LD_INT 15
21778: PUSH
21779: LD_INT 16
21781: PUSH
21782: LD_INT 20
21784: PUSH
21785: LD_INT 21
21787: PUSH
21788: LD_INT 22
21790: PUSH
21791: LD_INT 23
21793: PUSH
21794: LD_INT 25
21796: PUSH
21797: LD_INT 26
21799: PUSH
21800: LD_INT 30
21802: PUSH
21803: LD_INT 31
21805: PUSH
21806: LD_INT 32
21808: PUSH
21809: LD_INT 33
21811: PUSH
21812: LD_INT 34
21814: PUSH
21815: LD_INT 35
21817: PUSH
21818: LD_INT 36
21820: PUSH
21821: EMPTY
21822: LIST
21823: LIST
21824: LIST
21825: LIST
21826: LIST
21827: LIST
21828: LIST
21829: LIST
21830: LIST
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: LIST
21836: LIST
21837: LIST
21838: LIST
21839: LIST
21840: LIST
21841: LIST
21842: LIST
21843: PUSH
21844: LD_INT 101
21846: PUSH
21847: LD_INT 102
21849: PUSH
21850: LD_INT 103
21852: PUSH
21853: LD_INT 106
21855: PUSH
21856: LD_INT 108
21858: PUSH
21859: LD_INT 112
21861: PUSH
21862: LD_INT 113
21864: PUSH
21865: LD_INT 114
21867: PUSH
21868: LD_INT 115
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: LIST
21878: LIST
21879: LIST
21880: LIST
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: ST_TO_ADDR
21886: GO 22117
21888: LD_INT 19
21890: DOUBLE
21891: EQUAL
21892: IFTRUE 21896
21894: GO 22116
21896: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21897: LD_ADDR_VAR 0 1
21901: PUSH
21902: LD_INT 1
21904: PUSH
21905: LD_INT 2
21907: PUSH
21908: LD_INT 3
21910: PUSH
21911: LD_INT 4
21913: PUSH
21914: LD_INT 5
21916: PUSH
21917: LD_INT 6
21919: PUSH
21920: LD_INT 7
21922: PUSH
21923: LD_INT 8
21925: PUSH
21926: LD_INT 9
21928: PUSH
21929: LD_INT 10
21931: PUSH
21932: LD_INT 11
21934: PUSH
21935: LD_INT 12
21937: PUSH
21938: LD_INT 13
21940: PUSH
21941: LD_INT 14
21943: PUSH
21944: LD_INT 15
21946: PUSH
21947: LD_INT 16
21949: PUSH
21950: LD_INT 17
21952: PUSH
21953: LD_INT 18
21955: PUSH
21956: LD_INT 19
21958: PUSH
21959: LD_INT 20
21961: PUSH
21962: LD_INT 21
21964: PUSH
21965: LD_INT 22
21967: PUSH
21968: LD_INT 23
21970: PUSH
21971: LD_INT 24
21973: PUSH
21974: LD_INT 25
21976: PUSH
21977: LD_INT 26
21979: PUSH
21980: LD_INT 27
21982: PUSH
21983: LD_INT 28
21985: PUSH
21986: LD_INT 29
21988: PUSH
21989: LD_INT 30
21991: PUSH
21992: LD_INT 31
21994: PUSH
21995: LD_INT 32
21997: PUSH
21998: LD_INT 33
22000: PUSH
22001: LD_INT 34
22003: PUSH
22004: LD_INT 35
22006: PUSH
22007: LD_INT 36
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: LIST
22014: LIST
22015: LIST
22016: LIST
22017: LIST
22018: LIST
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: LIST
22024: LIST
22025: LIST
22026: LIST
22027: LIST
22028: LIST
22029: LIST
22030: LIST
22031: LIST
22032: LIST
22033: LIST
22034: LIST
22035: LIST
22036: LIST
22037: LIST
22038: LIST
22039: LIST
22040: LIST
22041: LIST
22042: LIST
22043: LIST
22044: LIST
22045: LIST
22046: LIST
22047: PUSH
22048: LD_INT 101
22050: PUSH
22051: LD_INT 102
22053: PUSH
22054: LD_INT 103
22056: PUSH
22057: LD_INT 104
22059: PUSH
22060: LD_INT 105
22062: PUSH
22063: LD_INT 106
22065: PUSH
22066: LD_INT 107
22068: PUSH
22069: LD_INT 108
22071: PUSH
22072: LD_INT 109
22074: PUSH
22075: LD_INT 110
22077: PUSH
22078: LD_INT 111
22080: PUSH
22081: LD_INT 112
22083: PUSH
22084: LD_INT 113
22086: PUSH
22087: LD_INT 114
22089: PUSH
22090: LD_INT 115
22092: PUSH
22093: EMPTY
22094: LIST
22095: LIST
22096: LIST
22097: LIST
22098: LIST
22099: LIST
22100: LIST
22101: LIST
22102: LIST
22103: LIST
22104: LIST
22105: LIST
22106: LIST
22107: LIST
22108: LIST
22109: PUSH
22110: EMPTY
22111: LIST
22112: LIST
22113: ST_TO_ADDR
22114: GO 22117
22116: POP
// end else
22117: GO 22154
// if campaign_id = 5 then
22119: LD_OWVAR 69
22123: PUSH
22124: LD_INT 5
22126: EQUAL
22127: IFFALSE 22154
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
22129: LD_ADDR_VAR 0 1
22133: PUSH
22134: LD_INT 1
22136: PUSH
22137: LD_INT 2
22139: PUSH
22140: EMPTY
22141: LIST
22142: LIST
22143: PUSH
22144: LD_INT 100
22146: PUSH
22147: EMPTY
22148: LIST
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: ST_TO_ADDR
// end ; if result then
22154: LD_VAR 0 1
22158: IFFALSE 22447
// begin normal :=  ;
22160: LD_ADDR_VAR 0 3
22164: PUSH
22165: LD_STRING 
22167: ST_TO_ADDR
// hardcore :=  ;
22168: LD_ADDR_VAR 0 4
22172: PUSH
22173: LD_STRING 
22175: ST_TO_ADDR
// for i = 1 to normalCounter do
22176: LD_ADDR_VAR 0 5
22180: PUSH
22181: DOUBLE
22182: LD_INT 1
22184: DEC
22185: ST_TO_ADDR
22186: LD_EXP 48
22190: PUSH
22191: FOR_TO
22192: IFFALSE 22293
// begin tmp := 0 ;
22194: LD_ADDR_VAR 0 2
22198: PUSH
22199: LD_STRING 0
22201: ST_TO_ADDR
// if result [ 1 ] then
22202: LD_VAR 0 1
22206: PUSH
22207: LD_INT 1
22209: ARRAY
22210: IFFALSE 22275
// if result [ 1 ] [ 1 ] = i then
22212: LD_VAR 0 1
22216: PUSH
22217: LD_INT 1
22219: ARRAY
22220: PUSH
22221: LD_INT 1
22223: ARRAY
22224: PUSH
22225: LD_VAR 0 5
22229: EQUAL
22230: IFFALSE 22275
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22232: LD_ADDR_VAR 0 1
22236: PUSH
22237: LD_VAR 0 1
22241: PPUSH
22242: LD_INT 1
22244: PPUSH
22245: LD_VAR 0 1
22249: PUSH
22250: LD_INT 1
22252: ARRAY
22253: PPUSH
22254: LD_INT 1
22256: PPUSH
22257: CALL_OW 3
22261: PPUSH
22262: CALL_OW 1
22266: ST_TO_ADDR
// tmp := 1 ;
22267: LD_ADDR_VAR 0 2
22271: PUSH
22272: LD_STRING 1
22274: ST_TO_ADDR
// end ; normal := normal & tmp ;
22275: LD_ADDR_VAR 0 3
22279: PUSH
22280: LD_VAR 0 3
22284: PUSH
22285: LD_VAR 0 2
22289: STR
22290: ST_TO_ADDR
// end ;
22291: GO 22191
22293: POP
22294: POP
// for i = 1 to hardcoreCounter do
22295: LD_ADDR_VAR 0 5
22299: PUSH
22300: DOUBLE
22301: LD_INT 1
22303: DEC
22304: ST_TO_ADDR
22305: LD_EXP 49
22309: PUSH
22310: FOR_TO
22311: IFFALSE 22416
// begin tmp := 0 ;
22313: LD_ADDR_VAR 0 2
22317: PUSH
22318: LD_STRING 0
22320: ST_TO_ADDR
// if result [ 2 ] then
22321: LD_VAR 0 1
22325: PUSH
22326: LD_INT 2
22328: ARRAY
22329: IFFALSE 22398
// if result [ 2 ] [ 1 ] = 100 + i then
22331: LD_VAR 0 1
22335: PUSH
22336: LD_INT 2
22338: ARRAY
22339: PUSH
22340: LD_INT 1
22342: ARRAY
22343: PUSH
22344: LD_INT 100
22346: PUSH
22347: LD_VAR 0 5
22351: PLUS
22352: EQUAL
22353: IFFALSE 22398
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22355: LD_ADDR_VAR 0 1
22359: PUSH
22360: LD_VAR 0 1
22364: PPUSH
22365: LD_INT 2
22367: PPUSH
22368: LD_VAR 0 1
22372: PUSH
22373: LD_INT 2
22375: ARRAY
22376: PPUSH
22377: LD_INT 1
22379: PPUSH
22380: CALL_OW 3
22384: PPUSH
22385: CALL_OW 1
22389: ST_TO_ADDR
// tmp := 1 ;
22390: LD_ADDR_VAR 0 2
22394: PUSH
22395: LD_STRING 1
22397: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22398: LD_ADDR_VAR 0 4
22402: PUSH
22403: LD_VAR 0 4
22407: PUSH
22408: LD_VAR 0 2
22412: STR
22413: ST_TO_ADDR
// end ;
22414: GO 22310
22416: POP
22417: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22418: LD_STRING getStreamItemsFromMission("
22420: PUSH
22421: LD_VAR 0 3
22425: STR
22426: PUSH
22427: LD_STRING ","
22429: STR
22430: PUSH
22431: LD_VAR 0 4
22435: STR
22436: PUSH
22437: LD_STRING ")
22439: STR
22440: PPUSH
22441: CALL_OW 559
// end else
22445: GO 22454
// ToLua ( getStreamItemsFromMission("","") ) ;
22447: LD_STRING getStreamItemsFromMission("","")
22449: PPUSH
22450: CALL_OW 559
// end ;
22454: LD_VAR 0 1
22458: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22459: LD_VAR 0 2
22463: PUSH
22464: LD_INT 100
22466: EQUAL
22467: IFFALSE 23416
// begin if not StreamModeActive then
22469: LD_EXP 47
22473: NOT
22474: IFFALSE 22484
// StreamModeActive := true ;
22476: LD_ADDR_EXP 47
22480: PUSH
22481: LD_INT 1
22483: ST_TO_ADDR
// if p3 = 0 then
22484: LD_VAR 0 3
22488: PUSH
22489: LD_INT 0
22491: EQUAL
22492: IFFALSE 22498
// InitStreamMode ;
22494: CALL 18719 0 0
// if p3 = 1 then
22498: LD_VAR 0 3
22502: PUSH
22503: LD_INT 1
22505: EQUAL
22506: IFFALSE 22516
// sRocket := true ;
22508: LD_ADDR_EXP 52
22512: PUSH
22513: LD_INT 1
22515: ST_TO_ADDR
// if p3 = 2 then
22516: LD_VAR 0 3
22520: PUSH
22521: LD_INT 2
22523: EQUAL
22524: IFFALSE 22534
// sSpeed := true ;
22526: LD_ADDR_EXP 51
22530: PUSH
22531: LD_INT 1
22533: ST_TO_ADDR
// if p3 = 3 then
22534: LD_VAR 0 3
22538: PUSH
22539: LD_INT 3
22541: EQUAL
22542: IFFALSE 22552
// sEngine := true ;
22544: LD_ADDR_EXP 53
22548: PUSH
22549: LD_INT 1
22551: ST_TO_ADDR
// if p3 = 4 then
22552: LD_VAR 0 3
22556: PUSH
22557: LD_INT 4
22559: EQUAL
22560: IFFALSE 22570
// sSpec := true ;
22562: LD_ADDR_EXP 50
22566: PUSH
22567: LD_INT 1
22569: ST_TO_ADDR
// if p3 = 5 then
22570: LD_VAR 0 3
22574: PUSH
22575: LD_INT 5
22577: EQUAL
22578: IFFALSE 22588
// sLevel := true ;
22580: LD_ADDR_EXP 54
22584: PUSH
22585: LD_INT 1
22587: ST_TO_ADDR
// if p3 = 6 then
22588: LD_VAR 0 3
22592: PUSH
22593: LD_INT 6
22595: EQUAL
22596: IFFALSE 22606
// sArmoury := true ;
22598: LD_ADDR_EXP 55
22602: PUSH
22603: LD_INT 1
22605: ST_TO_ADDR
// if p3 = 7 then
22606: LD_VAR 0 3
22610: PUSH
22611: LD_INT 7
22613: EQUAL
22614: IFFALSE 22624
// sRadar := true ;
22616: LD_ADDR_EXP 56
22620: PUSH
22621: LD_INT 1
22623: ST_TO_ADDR
// if p3 = 8 then
22624: LD_VAR 0 3
22628: PUSH
22629: LD_INT 8
22631: EQUAL
22632: IFFALSE 22642
// sBunker := true ;
22634: LD_ADDR_EXP 57
22638: PUSH
22639: LD_INT 1
22641: ST_TO_ADDR
// if p3 = 9 then
22642: LD_VAR 0 3
22646: PUSH
22647: LD_INT 9
22649: EQUAL
22650: IFFALSE 22660
// sHack := true ;
22652: LD_ADDR_EXP 58
22656: PUSH
22657: LD_INT 1
22659: ST_TO_ADDR
// if p3 = 10 then
22660: LD_VAR 0 3
22664: PUSH
22665: LD_INT 10
22667: EQUAL
22668: IFFALSE 22678
// sFire := true ;
22670: LD_ADDR_EXP 59
22674: PUSH
22675: LD_INT 1
22677: ST_TO_ADDR
// if p3 = 11 then
22678: LD_VAR 0 3
22682: PUSH
22683: LD_INT 11
22685: EQUAL
22686: IFFALSE 22696
// sRefresh := true ;
22688: LD_ADDR_EXP 60
22692: PUSH
22693: LD_INT 1
22695: ST_TO_ADDR
// if p3 = 12 then
22696: LD_VAR 0 3
22700: PUSH
22701: LD_INT 12
22703: EQUAL
22704: IFFALSE 22714
// sExp := true ;
22706: LD_ADDR_EXP 61
22710: PUSH
22711: LD_INT 1
22713: ST_TO_ADDR
// if p3 = 13 then
22714: LD_VAR 0 3
22718: PUSH
22719: LD_INT 13
22721: EQUAL
22722: IFFALSE 22732
// sDepot := true ;
22724: LD_ADDR_EXP 62
22728: PUSH
22729: LD_INT 1
22731: ST_TO_ADDR
// if p3 = 14 then
22732: LD_VAR 0 3
22736: PUSH
22737: LD_INT 14
22739: EQUAL
22740: IFFALSE 22750
// sFlag := true ;
22742: LD_ADDR_EXP 63
22746: PUSH
22747: LD_INT 1
22749: ST_TO_ADDR
// if p3 = 15 then
22750: LD_VAR 0 3
22754: PUSH
22755: LD_INT 15
22757: EQUAL
22758: IFFALSE 22768
// sKamikadze := true ;
22760: LD_ADDR_EXP 71
22764: PUSH
22765: LD_INT 1
22767: ST_TO_ADDR
// if p3 = 16 then
22768: LD_VAR 0 3
22772: PUSH
22773: LD_INT 16
22775: EQUAL
22776: IFFALSE 22786
// sTroll := true ;
22778: LD_ADDR_EXP 72
22782: PUSH
22783: LD_INT 1
22785: ST_TO_ADDR
// if p3 = 17 then
22786: LD_VAR 0 3
22790: PUSH
22791: LD_INT 17
22793: EQUAL
22794: IFFALSE 22804
// sSlow := true ;
22796: LD_ADDR_EXP 73
22800: PUSH
22801: LD_INT 1
22803: ST_TO_ADDR
// if p3 = 18 then
22804: LD_VAR 0 3
22808: PUSH
22809: LD_INT 18
22811: EQUAL
22812: IFFALSE 22822
// sLack := true ;
22814: LD_ADDR_EXP 74
22818: PUSH
22819: LD_INT 1
22821: ST_TO_ADDR
// if p3 = 19 then
22822: LD_VAR 0 3
22826: PUSH
22827: LD_INT 19
22829: EQUAL
22830: IFFALSE 22840
// sTank := true ;
22832: LD_ADDR_EXP 76
22836: PUSH
22837: LD_INT 1
22839: ST_TO_ADDR
// if p3 = 20 then
22840: LD_VAR 0 3
22844: PUSH
22845: LD_INT 20
22847: EQUAL
22848: IFFALSE 22858
// sRemote := true ;
22850: LD_ADDR_EXP 77
22854: PUSH
22855: LD_INT 1
22857: ST_TO_ADDR
// if p3 = 21 then
22858: LD_VAR 0 3
22862: PUSH
22863: LD_INT 21
22865: EQUAL
22866: IFFALSE 22876
// sPowell := true ;
22868: LD_ADDR_EXP 78
22872: PUSH
22873: LD_INT 1
22875: ST_TO_ADDR
// if p3 = 22 then
22876: LD_VAR 0 3
22880: PUSH
22881: LD_INT 22
22883: EQUAL
22884: IFFALSE 22894
// sTeleport := true ;
22886: LD_ADDR_EXP 81
22890: PUSH
22891: LD_INT 1
22893: ST_TO_ADDR
// if p3 = 23 then
22894: LD_VAR 0 3
22898: PUSH
22899: LD_INT 23
22901: EQUAL
22902: IFFALSE 22912
// sOilTower := true ;
22904: LD_ADDR_EXP 83
22908: PUSH
22909: LD_INT 1
22911: ST_TO_ADDR
// if p3 = 24 then
22912: LD_VAR 0 3
22916: PUSH
22917: LD_INT 24
22919: EQUAL
22920: IFFALSE 22930
// sShovel := true ;
22922: LD_ADDR_EXP 84
22926: PUSH
22927: LD_INT 1
22929: ST_TO_ADDR
// if p3 = 25 then
22930: LD_VAR 0 3
22934: PUSH
22935: LD_INT 25
22937: EQUAL
22938: IFFALSE 22948
// sSheik := true ;
22940: LD_ADDR_EXP 85
22944: PUSH
22945: LD_INT 1
22947: ST_TO_ADDR
// if p3 = 26 then
22948: LD_VAR 0 3
22952: PUSH
22953: LD_INT 26
22955: EQUAL
22956: IFFALSE 22966
// sEarthquake := true ;
22958: LD_ADDR_EXP 87
22962: PUSH
22963: LD_INT 1
22965: ST_TO_ADDR
// if p3 = 27 then
22966: LD_VAR 0 3
22970: PUSH
22971: LD_INT 27
22973: EQUAL
22974: IFFALSE 22984
// sAI := true ;
22976: LD_ADDR_EXP 88
22980: PUSH
22981: LD_INT 1
22983: ST_TO_ADDR
// if p3 = 28 then
22984: LD_VAR 0 3
22988: PUSH
22989: LD_INT 28
22991: EQUAL
22992: IFFALSE 23002
// sCargo := true ;
22994: LD_ADDR_EXP 91
22998: PUSH
22999: LD_INT 1
23001: ST_TO_ADDR
// if p3 = 29 then
23002: LD_VAR 0 3
23006: PUSH
23007: LD_INT 29
23009: EQUAL
23010: IFFALSE 23020
// sDLaser := true ;
23012: LD_ADDR_EXP 92
23016: PUSH
23017: LD_INT 1
23019: ST_TO_ADDR
// if p3 = 30 then
23020: LD_VAR 0 3
23024: PUSH
23025: LD_INT 30
23027: EQUAL
23028: IFFALSE 23038
// sExchange := true ;
23030: LD_ADDR_EXP 93
23034: PUSH
23035: LD_INT 1
23037: ST_TO_ADDR
// if p3 = 31 then
23038: LD_VAR 0 3
23042: PUSH
23043: LD_INT 31
23045: EQUAL
23046: IFFALSE 23056
// sFac := true ;
23048: LD_ADDR_EXP 94
23052: PUSH
23053: LD_INT 1
23055: ST_TO_ADDR
// if p3 = 32 then
23056: LD_VAR 0 3
23060: PUSH
23061: LD_INT 32
23063: EQUAL
23064: IFFALSE 23074
// sPower := true ;
23066: LD_ADDR_EXP 95
23070: PUSH
23071: LD_INT 1
23073: ST_TO_ADDR
// if p3 = 33 then
23074: LD_VAR 0 3
23078: PUSH
23079: LD_INT 33
23081: EQUAL
23082: IFFALSE 23092
// sRandom := true ;
23084: LD_ADDR_EXP 96
23088: PUSH
23089: LD_INT 1
23091: ST_TO_ADDR
// if p3 = 34 then
23092: LD_VAR 0 3
23096: PUSH
23097: LD_INT 34
23099: EQUAL
23100: IFFALSE 23110
// sShield := true ;
23102: LD_ADDR_EXP 97
23106: PUSH
23107: LD_INT 1
23109: ST_TO_ADDR
// if p3 = 35 then
23110: LD_VAR 0 3
23114: PUSH
23115: LD_INT 35
23117: EQUAL
23118: IFFALSE 23128
// sTime := true ;
23120: LD_ADDR_EXP 98
23124: PUSH
23125: LD_INT 1
23127: ST_TO_ADDR
// if p3 = 36 then
23128: LD_VAR 0 3
23132: PUSH
23133: LD_INT 36
23135: EQUAL
23136: IFFALSE 23146
// sTools := true ;
23138: LD_ADDR_EXP 99
23142: PUSH
23143: LD_INT 1
23145: ST_TO_ADDR
// if p3 = 101 then
23146: LD_VAR 0 3
23150: PUSH
23151: LD_INT 101
23153: EQUAL
23154: IFFALSE 23164
// sSold := true ;
23156: LD_ADDR_EXP 64
23160: PUSH
23161: LD_INT 1
23163: ST_TO_ADDR
// if p3 = 102 then
23164: LD_VAR 0 3
23168: PUSH
23169: LD_INT 102
23171: EQUAL
23172: IFFALSE 23182
// sDiff := true ;
23174: LD_ADDR_EXP 65
23178: PUSH
23179: LD_INT 1
23181: ST_TO_ADDR
// if p3 = 103 then
23182: LD_VAR 0 3
23186: PUSH
23187: LD_INT 103
23189: EQUAL
23190: IFFALSE 23200
// sFog := true ;
23192: LD_ADDR_EXP 68
23196: PUSH
23197: LD_INT 1
23199: ST_TO_ADDR
// if p3 = 104 then
23200: LD_VAR 0 3
23204: PUSH
23205: LD_INT 104
23207: EQUAL
23208: IFFALSE 23218
// sReset := true ;
23210: LD_ADDR_EXP 69
23214: PUSH
23215: LD_INT 1
23217: ST_TO_ADDR
// if p3 = 105 then
23218: LD_VAR 0 3
23222: PUSH
23223: LD_INT 105
23225: EQUAL
23226: IFFALSE 23236
// sSun := true ;
23228: LD_ADDR_EXP 70
23232: PUSH
23233: LD_INT 1
23235: ST_TO_ADDR
// if p3 = 106 then
23236: LD_VAR 0 3
23240: PUSH
23241: LD_INT 106
23243: EQUAL
23244: IFFALSE 23254
// sTiger := true ;
23246: LD_ADDR_EXP 66
23250: PUSH
23251: LD_INT 1
23253: ST_TO_ADDR
// if p3 = 107 then
23254: LD_VAR 0 3
23258: PUSH
23259: LD_INT 107
23261: EQUAL
23262: IFFALSE 23272
// sBomb := true ;
23264: LD_ADDR_EXP 67
23268: PUSH
23269: LD_INT 1
23271: ST_TO_ADDR
// if p3 = 108 then
23272: LD_VAR 0 3
23276: PUSH
23277: LD_INT 108
23279: EQUAL
23280: IFFALSE 23290
// sWound := true ;
23282: LD_ADDR_EXP 75
23286: PUSH
23287: LD_INT 1
23289: ST_TO_ADDR
// if p3 = 109 then
23290: LD_VAR 0 3
23294: PUSH
23295: LD_INT 109
23297: EQUAL
23298: IFFALSE 23308
// sBetray := true ;
23300: LD_ADDR_EXP 79
23304: PUSH
23305: LD_INT 1
23307: ST_TO_ADDR
// if p3 = 110 then
23308: LD_VAR 0 3
23312: PUSH
23313: LD_INT 110
23315: EQUAL
23316: IFFALSE 23326
// sContamin := true ;
23318: LD_ADDR_EXP 80
23322: PUSH
23323: LD_INT 1
23325: ST_TO_ADDR
// if p3 = 111 then
23326: LD_VAR 0 3
23330: PUSH
23331: LD_INT 111
23333: EQUAL
23334: IFFALSE 23344
// sOil := true ;
23336: LD_ADDR_EXP 82
23340: PUSH
23341: LD_INT 1
23343: ST_TO_ADDR
// if p3 = 112 then
23344: LD_VAR 0 3
23348: PUSH
23349: LD_INT 112
23351: EQUAL
23352: IFFALSE 23362
// sStu := true ;
23354: LD_ADDR_EXP 86
23358: PUSH
23359: LD_INT 1
23361: ST_TO_ADDR
// if p3 = 113 then
23362: LD_VAR 0 3
23366: PUSH
23367: LD_INT 113
23369: EQUAL
23370: IFFALSE 23380
// sBazooka := true ;
23372: LD_ADDR_EXP 89
23376: PUSH
23377: LD_INT 1
23379: ST_TO_ADDR
// if p3 = 114 then
23380: LD_VAR 0 3
23384: PUSH
23385: LD_INT 114
23387: EQUAL
23388: IFFALSE 23398
// sMortar := true ;
23390: LD_ADDR_EXP 90
23394: PUSH
23395: LD_INT 1
23397: ST_TO_ADDR
// if p3 = 115 then
23398: LD_VAR 0 3
23402: PUSH
23403: LD_INT 115
23405: EQUAL
23406: IFFALSE 23416
// sRanger := true ;
23408: LD_ADDR_EXP 100
23412: PUSH
23413: LD_INT 1
23415: ST_TO_ADDR
// end ; end ;
23416: PPOPN 6
23418: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23419: LD_EXP 47
23423: PUSH
23424: LD_EXP 52
23428: AND
23429: IFFALSE 23553
23431: GO 23433
23433: DISABLE
23434: LD_INT 0
23436: PPUSH
23437: PPUSH
// begin enable ;
23438: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23439: LD_ADDR_VAR 0 2
23443: PUSH
23444: LD_INT 22
23446: PUSH
23447: LD_OWVAR 2
23451: PUSH
23452: EMPTY
23453: LIST
23454: LIST
23455: PUSH
23456: LD_INT 2
23458: PUSH
23459: LD_INT 34
23461: PUSH
23462: LD_INT 7
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: PUSH
23469: LD_INT 34
23471: PUSH
23472: LD_INT 45
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PUSH
23479: LD_INT 34
23481: PUSH
23482: LD_INT 28
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PUSH
23489: LD_INT 34
23491: PUSH
23492: LD_INT 47
23494: PUSH
23495: EMPTY
23496: LIST
23497: LIST
23498: PUSH
23499: EMPTY
23500: LIST
23501: LIST
23502: LIST
23503: LIST
23504: LIST
23505: PUSH
23506: EMPTY
23507: LIST
23508: LIST
23509: PPUSH
23510: CALL_OW 69
23514: ST_TO_ADDR
// if not tmp then
23515: LD_VAR 0 2
23519: NOT
23520: IFFALSE 23524
// exit ;
23522: GO 23553
// for i in tmp do
23524: LD_ADDR_VAR 0 1
23528: PUSH
23529: LD_VAR 0 2
23533: PUSH
23534: FOR_IN
23535: IFFALSE 23551
// begin SetLives ( i , 0 ) ;
23537: LD_VAR 0 1
23541: PPUSH
23542: LD_INT 0
23544: PPUSH
23545: CALL_OW 234
// end ;
23549: GO 23534
23551: POP
23552: POP
// end ;
23553: PPOPN 2
23555: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23556: LD_EXP 47
23560: PUSH
23561: LD_EXP 53
23565: AND
23566: IFFALSE 23650
23568: GO 23570
23570: DISABLE
23571: LD_INT 0
23573: PPUSH
23574: PPUSH
// begin enable ;
23575: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23576: LD_ADDR_VAR 0 2
23580: PUSH
23581: LD_INT 22
23583: PUSH
23584: LD_OWVAR 2
23588: PUSH
23589: EMPTY
23590: LIST
23591: LIST
23592: PUSH
23593: LD_INT 32
23595: PUSH
23596: LD_INT 3
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: PUSH
23603: EMPTY
23604: LIST
23605: LIST
23606: PPUSH
23607: CALL_OW 69
23611: ST_TO_ADDR
// if not tmp then
23612: LD_VAR 0 2
23616: NOT
23617: IFFALSE 23621
// exit ;
23619: GO 23650
// for i in tmp do
23621: LD_ADDR_VAR 0 1
23625: PUSH
23626: LD_VAR 0 2
23630: PUSH
23631: FOR_IN
23632: IFFALSE 23648
// begin SetLives ( i , 0 ) ;
23634: LD_VAR 0 1
23638: PPUSH
23639: LD_INT 0
23641: PPUSH
23642: CALL_OW 234
// end ;
23646: GO 23631
23648: POP
23649: POP
// end ;
23650: PPOPN 2
23652: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23653: LD_EXP 47
23657: PUSH
23658: LD_EXP 50
23662: AND
23663: IFFALSE 23756
23665: GO 23667
23667: DISABLE
23668: LD_INT 0
23670: PPUSH
// begin enable ;
23671: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23672: LD_ADDR_VAR 0 1
23676: PUSH
23677: LD_INT 22
23679: PUSH
23680: LD_OWVAR 2
23684: PUSH
23685: EMPTY
23686: LIST
23687: LIST
23688: PUSH
23689: LD_INT 2
23691: PUSH
23692: LD_INT 25
23694: PUSH
23695: LD_INT 5
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PUSH
23702: LD_INT 25
23704: PUSH
23705: LD_INT 9
23707: PUSH
23708: EMPTY
23709: LIST
23710: LIST
23711: PUSH
23712: LD_INT 25
23714: PUSH
23715: LD_INT 8
23717: PUSH
23718: EMPTY
23719: LIST
23720: LIST
23721: PUSH
23722: EMPTY
23723: LIST
23724: LIST
23725: LIST
23726: LIST
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PPUSH
23732: CALL_OW 69
23736: PUSH
23737: FOR_IN
23738: IFFALSE 23754
// begin SetClass ( i , 1 ) ;
23740: LD_VAR 0 1
23744: PPUSH
23745: LD_INT 1
23747: PPUSH
23748: CALL_OW 336
// end ;
23752: GO 23737
23754: POP
23755: POP
// end ;
23756: PPOPN 1
23758: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23759: LD_EXP 47
23763: PUSH
23764: LD_EXP 51
23768: AND
23769: PUSH
23770: LD_OWVAR 65
23774: PUSH
23775: LD_INT 7
23777: LESS
23778: AND
23779: IFFALSE 23793
23781: GO 23783
23783: DISABLE
// begin enable ;
23784: ENABLE
// game_speed := 7 ;
23785: LD_ADDR_OWVAR 65
23789: PUSH
23790: LD_INT 7
23792: ST_TO_ADDR
// end ;
23793: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23794: LD_EXP 47
23798: PUSH
23799: LD_EXP 54
23803: AND
23804: IFFALSE 24006
23806: GO 23808
23808: DISABLE
23809: LD_INT 0
23811: PPUSH
23812: PPUSH
23813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23814: LD_ADDR_VAR 0 3
23818: PUSH
23819: LD_INT 81
23821: PUSH
23822: LD_OWVAR 2
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: PUSH
23831: LD_INT 21
23833: PUSH
23834: LD_INT 1
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: PPUSH
23845: CALL_OW 69
23849: ST_TO_ADDR
// if not tmp then
23850: LD_VAR 0 3
23854: NOT
23855: IFFALSE 23859
// exit ;
23857: GO 24006
// if tmp > 5 then
23859: LD_VAR 0 3
23863: PUSH
23864: LD_INT 5
23866: GREATER
23867: IFFALSE 23879
// k := 5 else
23869: LD_ADDR_VAR 0 2
23873: PUSH
23874: LD_INT 5
23876: ST_TO_ADDR
23877: GO 23889
// k := tmp ;
23879: LD_ADDR_VAR 0 2
23883: PUSH
23884: LD_VAR 0 3
23888: ST_TO_ADDR
// for i := 1 to k do
23889: LD_ADDR_VAR 0 1
23893: PUSH
23894: DOUBLE
23895: LD_INT 1
23897: DEC
23898: ST_TO_ADDR
23899: LD_VAR 0 2
23903: PUSH
23904: FOR_TO
23905: IFFALSE 24004
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
23907: LD_VAR 0 3
23911: PUSH
23912: LD_VAR 0 1
23916: ARRAY
23917: PPUSH
23918: LD_VAR 0 1
23922: PUSH
23923: LD_INT 4
23925: MOD
23926: PUSH
23927: LD_INT 1
23929: PLUS
23930: PPUSH
23931: CALL_OW 259
23935: PUSH
23936: LD_INT 10
23938: LESS
23939: IFFALSE 24002
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23941: LD_VAR 0 3
23945: PUSH
23946: LD_VAR 0 1
23950: ARRAY
23951: PPUSH
23952: LD_VAR 0 1
23956: PUSH
23957: LD_INT 4
23959: MOD
23960: PUSH
23961: LD_INT 1
23963: PLUS
23964: PPUSH
23965: LD_VAR 0 3
23969: PUSH
23970: LD_VAR 0 1
23974: ARRAY
23975: PPUSH
23976: LD_VAR 0 1
23980: PUSH
23981: LD_INT 4
23983: MOD
23984: PUSH
23985: LD_INT 1
23987: PLUS
23988: PPUSH
23989: CALL_OW 259
23993: PUSH
23994: LD_INT 1
23996: PLUS
23997: PPUSH
23998: CALL_OW 237
24002: GO 23904
24004: POP
24005: POP
// end ;
24006: PPOPN 3
24008: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
24009: LD_EXP 47
24013: PUSH
24014: LD_EXP 55
24018: AND
24019: IFFALSE 24039
24021: GO 24023
24023: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
24024: LD_INT 4
24026: PPUSH
24027: LD_OWVAR 2
24031: PPUSH
24032: LD_INT 0
24034: PPUSH
24035: CALL_OW 324
24039: END
// every 0 0$1 trigger StreamModeActive and sShovel do
24040: LD_EXP 47
24044: PUSH
24045: LD_EXP 84
24049: AND
24050: IFFALSE 24070
24052: GO 24054
24054: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
24055: LD_INT 19
24057: PPUSH
24058: LD_OWVAR 2
24062: PPUSH
24063: LD_INT 0
24065: PPUSH
24066: CALL_OW 324
24070: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24071: LD_EXP 47
24075: PUSH
24076: LD_EXP 56
24080: AND
24081: IFFALSE 24183
24083: GO 24085
24085: DISABLE
24086: LD_INT 0
24088: PPUSH
24089: PPUSH
// begin enable ;
24090: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24091: LD_ADDR_VAR 0 2
24095: PUSH
24096: LD_INT 22
24098: PUSH
24099: LD_OWVAR 2
24103: PUSH
24104: EMPTY
24105: LIST
24106: LIST
24107: PUSH
24108: LD_INT 2
24110: PUSH
24111: LD_INT 34
24113: PUSH
24114: LD_INT 11
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: PUSH
24121: LD_INT 34
24123: PUSH
24124: LD_INT 30
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PUSH
24131: EMPTY
24132: LIST
24133: LIST
24134: LIST
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PPUSH
24140: CALL_OW 69
24144: ST_TO_ADDR
// if not tmp then
24145: LD_VAR 0 2
24149: NOT
24150: IFFALSE 24154
// exit ;
24152: GO 24183
// for i in tmp do
24154: LD_ADDR_VAR 0 1
24158: PUSH
24159: LD_VAR 0 2
24163: PUSH
24164: FOR_IN
24165: IFFALSE 24181
// begin SetLives ( i , 0 ) ;
24167: LD_VAR 0 1
24171: PPUSH
24172: LD_INT 0
24174: PPUSH
24175: CALL_OW 234
// end ;
24179: GO 24164
24181: POP
24182: POP
// end ;
24183: PPOPN 2
24185: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24186: LD_EXP 47
24190: PUSH
24191: LD_EXP 57
24195: AND
24196: IFFALSE 24216
24198: GO 24200
24200: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24201: LD_INT 32
24203: PPUSH
24204: LD_OWVAR 2
24208: PPUSH
24209: LD_INT 0
24211: PPUSH
24212: CALL_OW 324
24216: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24217: LD_EXP 47
24221: PUSH
24222: LD_EXP 58
24226: AND
24227: IFFALSE 24408
24229: GO 24231
24231: DISABLE
24232: LD_INT 0
24234: PPUSH
24235: PPUSH
24236: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24237: LD_ADDR_VAR 0 2
24241: PUSH
24242: LD_INT 22
24244: PUSH
24245: LD_OWVAR 2
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: PUSH
24254: LD_INT 33
24256: PUSH
24257: LD_INT 3
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: PUSH
24264: EMPTY
24265: LIST
24266: LIST
24267: PPUSH
24268: CALL_OW 69
24272: ST_TO_ADDR
// if not tmp then
24273: LD_VAR 0 2
24277: NOT
24278: IFFALSE 24282
// exit ;
24280: GO 24408
// side := 0 ;
24282: LD_ADDR_VAR 0 3
24286: PUSH
24287: LD_INT 0
24289: ST_TO_ADDR
// for i := 1 to 8 do
24290: LD_ADDR_VAR 0 1
24294: PUSH
24295: DOUBLE
24296: LD_INT 1
24298: DEC
24299: ST_TO_ADDR
24300: LD_INT 8
24302: PUSH
24303: FOR_TO
24304: IFFALSE 24352
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24306: LD_OWVAR 2
24310: PUSH
24311: LD_VAR 0 1
24315: NONEQUAL
24316: PUSH
24317: LD_OWVAR 2
24321: PPUSH
24322: LD_VAR 0 1
24326: PPUSH
24327: CALL_OW 81
24331: PUSH
24332: LD_INT 2
24334: EQUAL
24335: AND
24336: IFFALSE 24350
// begin side := i ;
24338: LD_ADDR_VAR 0 3
24342: PUSH
24343: LD_VAR 0 1
24347: ST_TO_ADDR
// break ;
24348: GO 24352
// end ;
24350: GO 24303
24352: POP
24353: POP
// if not side then
24354: LD_VAR 0 3
24358: NOT
24359: IFFALSE 24363
// exit ;
24361: GO 24408
// for i := 1 to tmp do
24363: LD_ADDR_VAR 0 1
24367: PUSH
24368: DOUBLE
24369: LD_INT 1
24371: DEC
24372: ST_TO_ADDR
24373: LD_VAR 0 2
24377: PUSH
24378: FOR_TO
24379: IFFALSE 24406
// if Prob ( 60 ) then
24381: LD_INT 60
24383: PPUSH
24384: CALL_OW 13
24388: IFFALSE 24404
// SetSide ( i , side ) ;
24390: LD_VAR 0 1
24394: PPUSH
24395: LD_VAR 0 3
24399: PPUSH
24400: CALL_OW 235
24404: GO 24378
24406: POP
24407: POP
// end ;
24408: PPOPN 3
24410: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24411: LD_EXP 47
24415: PUSH
24416: LD_EXP 60
24420: AND
24421: IFFALSE 24540
24423: GO 24425
24425: DISABLE
24426: LD_INT 0
24428: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24429: LD_ADDR_VAR 0 1
24433: PUSH
24434: LD_INT 22
24436: PUSH
24437: LD_OWVAR 2
24441: PUSH
24442: EMPTY
24443: LIST
24444: LIST
24445: PUSH
24446: LD_INT 21
24448: PUSH
24449: LD_INT 1
24451: PUSH
24452: EMPTY
24453: LIST
24454: LIST
24455: PUSH
24456: LD_INT 3
24458: PUSH
24459: LD_INT 23
24461: PUSH
24462: LD_INT 0
24464: PUSH
24465: EMPTY
24466: LIST
24467: LIST
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: LIST
24477: PPUSH
24478: CALL_OW 69
24482: PUSH
24483: FOR_IN
24484: IFFALSE 24538
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24486: LD_VAR 0 1
24490: PPUSH
24491: CALL_OW 257
24495: PUSH
24496: LD_INT 1
24498: PUSH
24499: LD_INT 2
24501: PUSH
24502: LD_INT 3
24504: PUSH
24505: LD_INT 4
24507: PUSH
24508: EMPTY
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: IN
24514: IFFALSE 24536
// SetClass ( un , rand ( 1 , 4 ) ) ;
24516: LD_VAR 0 1
24520: PPUSH
24521: LD_INT 1
24523: PPUSH
24524: LD_INT 4
24526: PPUSH
24527: CALL_OW 12
24531: PPUSH
24532: CALL_OW 336
24536: GO 24483
24538: POP
24539: POP
// end ;
24540: PPOPN 1
24542: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24543: LD_EXP 47
24547: PUSH
24548: LD_EXP 59
24552: AND
24553: IFFALSE 24632
24555: GO 24557
24557: DISABLE
24558: LD_INT 0
24560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24561: LD_ADDR_VAR 0 1
24565: PUSH
24566: LD_INT 22
24568: PUSH
24569: LD_OWVAR 2
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: LD_INT 21
24580: PUSH
24581: LD_INT 3
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: PUSH
24588: EMPTY
24589: LIST
24590: LIST
24591: PPUSH
24592: CALL_OW 69
24596: ST_TO_ADDR
// if not tmp then
24597: LD_VAR 0 1
24601: NOT
24602: IFFALSE 24606
// exit ;
24604: GO 24632
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24606: LD_VAR 0 1
24610: PUSH
24611: LD_INT 1
24613: PPUSH
24614: LD_VAR 0 1
24618: PPUSH
24619: CALL_OW 12
24623: ARRAY
24624: PPUSH
24625: LD_INT 100
24627: PPUSH
24628: CALL_OW 234
// end ;
24632: PPOPN 1
24634: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24635: LD_EXP 47
24639: PUSH
24640: LD_EXP 61
24644: AND
24645: IFFALSE 24743
24647: GO 24649
24649: DISABLE
24650: LD_INT 0
24652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24653: LD_ADDR_VAR 0 1
24657: PUSH
24658: LD_INT 22
24660: PUSH
24661: LD_OWVAR 2
24665: PUSH
24666: EMPTY
24667: LIST
24668: LIST
24669: PUSH
24670: LD_INT 21
24672: PUSH
24673: LD_INT 1
24675: PUSH
24676: EMPTY
24677: LIST
24678: LIST
24679: PUSH
24680: EMPTY
24681: LIST
24682: LIST
24683: PPUSH
24684: CALL_OW 69
24688: ST_TO_ADDR
// if not tmp then
24689: LD_VAR 0 1
24693: NOT
24694: IFFALSE 24698
// exit ;
24696: GO 24743
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24698: LD_VAR 0 1
24702: PUSH
24703: LD_INT 1
24705: PPUSH
24706: LD_VAR 0 1
24710: PPUSH
24711: CALL_OW 12
24715: ARRAY
24716: PPUSH
24717: LD_INT 1
24719: PPUSH
24720: LD_INT 4
24722: PPUSH
24723: CALL_OW 12
24727: PPUSH
24728: LD_INT 3000
24730: PPUSH
24731: LD_INT 9000
24733: PPUSH
24734: CALL_OW 12
24738: PPUSH
24739: CALL_OW 492
// end ;
24743: PPOPN 1
24745: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24746: LD_EXP 47
24750: PUSH
24751: LD_EXP 62
24755: AND
24756: IFFALSE 24776
24758: GO 24760
24760: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24761: LD_INT 1
24763: PPUSH
24764: LD_OWVAR 2
24768: PPUSH
24769: LD_INT 0
24771: PPUSH
24772: CALL_OW 324
24776: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24777: LD_EXP 47
24781: PUSH
24782: LD_EXP 63
24786: AND
24787: IFFALSE 24870
24789: GO 24791
24791: DISABLE
24792: LD_INT 0
24794: PPUSH
24795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24796: LD_ADDR_VAR 0 2
24800: PUSH
24801: LD_INT 22
24803: PUSH
24804: LD_OWVAR 2
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: PUSH
24813: LD_INT 21
24815: PUSH
24816: LD_INT 3
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: PUSH
24823: EMPTY
24824: LIST
24825: LIST
24826: PPUSH
24827: CALL_OW 69
24831: ST_TO_ADDR
// if not tmp then
24832: LD_VAR 0 2
24836: NOT
24837: IFFALSE 24841
// exit ;
24839: GO 24870
// for i in tmp do
24841: LD_ADDR_VAR 0 1
24845: PUSH
24846: LD_VAR 0 2
24850: PUSH
24851: FOR_IN
24852: IFFALSE 24868
// SetBLevel ( i , 10 ) ;
24854: LD_VAR 0 1
24858: PPUSH
24859: LD_INT 10
24861: PPUSH
24862: CALL_OW 241
24866: GO 24851
24868: POP
24869: POP
// end ;
24870: PPOPN 2
24872: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
24873: LD_EXP 47
24877: PUSH
24878: LD_EXP 64
24882: AND
24883: IFFALSE 24994
24885: GO 24887
24887: DISABLE
24888: LD_INT 0
24890: PPUSH
24891: PPUSH
24892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24893: LD_ADDR_VAR 0 3
24897: PUSH
24898: LD_INT 22
24900: PUSH
24901: LD_OWVAR 2
24905: PUSH
24906: EMPTY
24907: LIST
24908: LIST
24909: PUSH
24910: LD_INT 25
24912: PUSH
24913: LD_INT 1
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: EMPTY
24921: LIST
24922: LIST
24923: PPUSH
24924: CALL_OW 69
24928: ST_TO_ADDR
// if not tmp then
24929: LD_VAR 0 3
24933: NOT
24934: IFFALSE 24938
// exit ;
24936: GO 24994
// un := tmp [ rand ( 1 , tmp ) ] ;
24938: LD_ADDR_VAR 0 2
24942: PUSH
24943: LD_VAR 0 3
24947: PUSH
24948: LD_INT 1
24950: PPUSH
24951: LD_VAR 0 3
24955: PPUSH
24956: CALL_OW 12
24960: ARRAY
24961: ST_TO_ADDR
// if Crawls ( un ) then
24962: LD_VAR 0 2
24966: PPUSH
24967: CALL_OW 318
24971: IFFALSE 24982
// ComWalk ( un ) ;
24973: LD_VAR 0 2
24977: PPUSH
24978: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24982: LD_VAR 0 2
24986: PPUSH
24987: LD_INT 5
24989: PPUSH
24990: CALL_OW 336
// end ;
24994: PPOPN 3
24996: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24997: LD_EXP 47
25001: PUSH
25002: LD_EXP 65
25006: AND
25007: PUSH
25008: LD_OWVAR 67
25012: PUSH
25013: LD_INT 3
25015: LESS
25016: AND
25017: IFFALSE 25036
25019: GO 25021
25021: DISABLE
// Difficulty := Difficulty + 1 ;
25022: LD_ADDR_OWVAR 67
25026: PUSH
25027: LD_OWVAR 67
25031: PUSH
25032: LD_INT 1
25034: PLUS
25035: ST_TO_ADDR
25036: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
25037: LD_EXP 47
25041: PUSH
25042: LD_EXP 66
25046: AND
25047: IFFALSE 25150
25049: GO 25051
25051: DISABLE
25052: LD_INT 0
25054: PPUSH
// begin for i := 1 to 5 do
25055: LD_ADDR_VAR 0 1
25059: PUSH
25060: DOUBLE
25061: LD_INT 1
25063: DEC
25064: ST_TO_ADDR
25065: LD_INT 5
25067: PUSH
25068: FOR_TO
25069: IFFALSE 25148
// begin uc_nation := nation_nature ;
25071: LD_ADDR_OWVAR 21
25075: PUSH
25076: LD_INT 0
25078: ST_TO_ADDR
// uc_side := 0 ;
25079: LD_ADDR_OWVAR 20
25083: PUSH
25084: LD_INT 0
25086: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25087: LD_ADDR_OWVAR 29
25091: PUSH
25092: LD_INT 12
25094: PUSH
25095: LD_INT 12
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: ST_TO_ADDR
// hc_agressivity := 20 ;
25102: LD_ADDR_OWVAR 35
25106: PUSH
25107: LD_INT 20
25109: ST_TO_ADDR
// hc_class := class_tiger ;
25110: LD_ADDR_OWVAR 28
25114: PUSH
25115: LD_INT 14
25117: ST_TO_ADDR
// hc_gallery :=  ;
25118: LD_ADDR_OWVAR 33
25122: PUSH
25123: LD_STRING 
25125: ST_TO_ADDR
// hc_name :=  ;
25126: LD_ADDR_OWVAR 26
25130: PUSH
25131: LD_STRING 
25133: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25134: CALL_OW 44
25138: PPUSH
25139: LD_INT 0
25141: PPUSH
25142: CALL_OW 51
// end ;
25146: GO 25068
25148: POP
25149: POP
// end ;
25150: PPOPN 1
25152: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25153: LD_EXP 47
25157: PUSH
25158: LD_EXP 67
25162: AND
25163: IFFALSE 25172
25165: GO 25167
25167: DISABLE
// StreamSibBomb ;
25168: CALL 25173 0 0
25172: END
// export function StreamSibBomb ; var i , x , y ; begin
25173: LD_INT 0
25175: PPUSH
25176: PPUSH
25177: PPUSH
25178: PPUSH
// result := false ;
25179: LD_ADDR_VAR 0 1
25183: PUSH
25184: LD_INT 0
25186: ST_TO_ADDR
// for i := 1 to 16 do
25187: LD_ADDR_VAR 0 2
25191: PUSH
25192: DOUBLE
25193: LD_INT 1
25195: DEC
25196: ST_TO_ADDR
25197: LD_INT 16
25199: PUSH
25200: FOR_TO
25201: IFFALSE 25400
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25203: LD_ADDR_VAR 0 3
25207: PUSH
25208: LD_INT 10
25210: PUSH
25211: LD_INT 20
25213: PUSH
25214: LD_INT 30
25216: PUSH
25217: LD_INT 40
25219: PUSH
25220: LD_INT 50
25222: PUSH
25223: LD_INT 60
25225: PUSH
25226: LD_INT 70
25228: PUSH
25229: LD_INT 80
25231: PUSH
25232: LD_INT 90
25234: PUSH
25235: LD_INT 100
25237: PUSH
25238: LD_INT 110
25240: PUSH
25241: LD_INT 120
25243: PUSH
25244: LD_INT 130
25246: PUSH
25247: LD_INT 140
25249: PUSH
25250: LD_INT 150
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: LIST
25257: LIST
25258: LIST
25259: LIST
25260: LIST
25261: LIST
25262: LIST
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: PUSH
25270: LD_INT 1
25272: PPUSH
25273: LD_INT 15
25275: PPUSH
25276: CALL_OW 12
25280: ARRAY
25281: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25282: LD_ADDR_VAR 0 4
25286: PUSH
25287: LD_INT 10
25289: PUSH
25290: LD_INT 20
25292: PUSH
25293: LD_INT 30
25295: PUSH
25296: LD_INT 40
25298: PUSH
25299: LD_INT 50
25301: PUSH
25302: LD_INT 60
25304: PUSH
25305: LD_INT 70
25307: PUSH
25308: LD_INT 80
25310: PUSH
25311: LD_INT 90
25313: PUSH
25314: LD_INT 100
25316: PUSH
25317: LD_INT 110
25319: PUSH
25320: LD_INT 120
25322: PUSH
25323: LD_INT 130
25325: PUSH
25326: LD_INT 140
25328: PUSH
25329: LD_INT 150
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: LIST
25336: LIST
25337: LIST
25338: LIST
25339: LIST
25340: LIST
25341: LIST
25342: LIST
25343: LIST
25344: LIST
25345: LIST
25346: LIST
25347: LIST
25348: PUSH
25349: LD_INT 1
25351: PPUSH
25352: LD_INT 15
25354: PPUSH
25355: CALL_OW 12
25359: ARRAY
25360: ST_TO_ADDR
// if ValidHex ( x , y ) then
25361: LD_VAR 0 3
25365: PPUSH
25366: LD_VAR 0 4
25370: PPUSH
25371: CALL_OW 488
25375: IFFALSE 25398
// begin result := [ x , y ] ;
25377: LD_ADDR_VAR 0 1
25381: PUSH
25382: LD_VAR 0 3
25386: PUSH
25387: LD_VAR 0 4
25391: PUSH
25392: EMPTY
25393: LIST
25394: LIST
25395: ST_TO_ADDR
// break ;
25396: GO 25400
// end ; end ;
25398: GO 25200
25400: POP
25401: POP
// if result then
25402: LD_VAR 0 1
25406: IFFALSE 25466
// begin ToLua ( playSibBomb() ) ;
25408: LD_STRING playSibBomb()
25410: PPUSH
25411: CALL_OW 559
// wait ( 0 0$14 ) ;
25415: LD_INT 490
25417: PPUSH
25418: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25422: LD_VAR 0 1
25426: PUSH
25427: LD_INT 1
25429: ARRAY
25430: PPUSH
25431: LD_VAR 0 1
25435: PUSH
25436: LD_INT 2
25438: ARRAY
25439: PPUSH
25440: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25444: LD_VAR 0 1
25448: PUSH
25449: LD_INT 1
25451: ARRAY
25452: PPUSH
25453: LD_VAR 0 1
25457: PUSH
25458: LD_INT 2
25460: ARRAY
25461: PPUSH
25462: CALL_OW 429
// end ; end ;
25466: LD_VAR 0 1
25470: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25471: LD_EXP 47
25475: PUSH
25476: LD_EXP 69
25480: AND
25481: IFFALSE 25493
25483: GO 25485
25485: DISABLE
// YouLost (  ) ;
25486: LD_STRING 
25488: PPUSH
25489: CALL_OW 104
25493: END
// every 0 0$1 trigger StreamModeActive and sFog do
25494: LD_EXP 47
25498: PUSH
25499: LD_EXP 68
25503: AND
25504: IFFALSE 25518
25506: GO 25508
25508: DISABLE
// FogOff ( your_side ) ;
25509: LD_OWVAR 2
25513: PPUSH
25514: CALL_OW 344
25518: END
// every 0 0$1 trigger StreamModeActive and sSun do
25519: LD_EXP 47
25523: PUSH
25524: LD_EXP 70
25528: AND
25529: IFFALSE 25557
25531: GO 25533
25533: DISABLE
// begin solar_recharge_percent := 0 ;
25534: LD_ADDR_OWVAR 79
25538: PUSH
25539: LD_INT 0
25541: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25542: LD_INT 10500
25544: PPUSH
25545: CALL_OW 67
// solar_recharge_percent := 100 ;
25549: LD_ADDR_OWVAR 79
25553: PUSH
25554: LD_INT 100
25556: ST_TO_ADDR
// end ;
25557: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25558: LD_EXP 47
25562: PUSH
25563: LD_EXP 71
25567: AND
25568: IFFALSE 25807
25570: GO 25572
25572: DISABLE
25573: LD_INT 0
25575: PPUSH
25576: PPUSH
25577: PPUSH
// begin tmp := [ ] ;
25578: LD_ADDR_VAR 0 3
25582: PUSH
25583: EMPTY
25584: ST_TO_ADDR
// for i := 1 to 6 do
25585: LD_ADDR_VAR 0 1
25589: PUSH
25590: DOUBLE
25591: LD_INT 1
25593: DEC
25594: ST_TO_ADDR
25595: LD_INT 6
25597: PUSH
25598: FOR_TO
25599: IFFALSE 25704
// begin uc_nation := nation_nature ;
25601: LD_ADDR_OWVAR 21
25605: PUSH
25606: LD_INT 0
25608: ST_TO_ADDR
// uc_side := 0 ;
25609: LD_ADDR_OWVAR 20
25613: PUSH
25614: LD_INT 0
25616: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25617: LD_ADDR_OWVAR 29
25621: PUSH
25622: LD_INT 12
25624: PUSH
25625: LD_INT 12
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: ST_TO_ADDR
// hc_agressivity := 20 ;
25632: LD_ADDR_OWVAR 35
25636: PUSH
25637: LD_INT 20
25639: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25640: LD_ADDR_OWVAR 28
25644: PUSH
25645: LD_INT 17
25647: ST_TO_ADDR
// hc_gallery :=  ;
25648: LD_ADDR_OWVAR 33
25652: PUSH
25653: LD_STRING 
25655: ST_TO_ADDR
// hc_name :=  ;
25656: LD_ADDR_OWVAR 26
25660: PUSH
25661: LD_STRING 
25663: ST_TO_ADDR
// un := CreateHuman ;
25664: LD_ADDR_VAR 0 2
25668: PUSH
25669: CALL_OW 44
25673: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25674: LD_VAR 0 2
25678: PPUSH
25679: LD_INT 1
25681: PPUSH
25682: CALL_OW 51
// tmp := tmp ^ un ;
25686: LD_ADDR_VAR 0 3
25690: PUSH
25691: LD_VAR 0 3
25695: PUSH
25696: LD_VAR 0 2
25700: ADD
25701: ST_TO_ADDR
// end ;
25702: GO 25598
25704: POP
25705: POP
// repeat wait ( 0 0$1 ) ;
25706: LD_INT 35
25708: PPUSH
25709: CALL_OW 67
// for un in tmp do
25713: LD_ADDR_VAR 0 2
25717: PUSH
25718: LD_VAR 0 3
25722: PUSH
25723: FOR_IN
25724: IFFALSE 25798
// begin if IsDead ( un ) then
25726: LD_VAR 0 2
25730: PPUSH
25731: CALL_OW 301
25735: IFFALSE 25755
// begin tmp := tmp diff un ;
25737: LD_ADDR_VAR 0 3
25741: PUSH
25742: LD_VAR 0 3
25746: PUSH
25747: LD_VAR 0 2
25751: DIFF
25752: ST_TO_ADDR
// continue ;
25753: GO 25723
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25755: LD_VAR 0 2
25759: PPUSH
25760: LD_INT 3
25762: PUSH
25763: LD_INT 22
25765: PUSH
25766: LD_INT 0
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: PPUSH
25777: CALL_OW 69
25781: PPUSH
25782: LD_VAR 0 2
25786: PPUSH
25787: CALL_OW 74
25791: PPUSH
25792: CALL_OW 115
// end ;
25796: GO 25723
25798: POP
25799: POP
// until not tmp ;
25800: LD_VAR 0 3
25804: NOT
25805: IFFALSE 25706
// end ;
25807: PPOPN 3
25809: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25810: LD_EXP 47
25814: PUSH
25815: LD_EXP 72
25819: AND
25820: IFFALSE 25874
25822: GO 25824
25824: DISABLE
// begin ToLua ( displayTroll(); ) ;
25825: LD_STRING displayTroll();
25827: PPUSH
25828: CALL_OW 559
// wait ( 3 3$00 ) ;
25832: LD_INT 6300
25834: PPUSH
25835: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25839: LD_STRING hideTroll();
25841: PPUSH
25842: CALL_OW 559
// wait ( 1 1$00 ) ;
25846: LD_INT 2100
25848: PPUSH
25849: CALL_OW 67
// ToLua ( displayTroll(); ) ;
25853: LD_STRING displayTroll();
25855: PPUSH
25856: CALL_OW 559
// wait ( 1 1$00 ) ;
25860: LD_INT 2100
25862: PPUSH
25863: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25867: LD_STRING hideTroll();
25869: PPUSH
25870: CALL_OW 559
// end ;
25874: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
25875: LD_EXP 47
25879: PUSH
25880: LD_EXP 73
25884: AND
25885: IFFALSE 25948
25887: GO 25889
25889: DISABLE
25890: LD_INT 0
25892: PPUSH
// begin p := 0 ;
25893: LD_ADDR_VAR 0 1
25897: PUSH
25898: LD_INT 0
25900: ST_TO_ADDR
// repeat game_speed := 1 ;
25901: LD_ADDR_OWVAR 65
25905: PUSH
25906: LD_INT 1
25908: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25909: LD_INT 35
25911: PPUSH
25912: CALL_OW 67
// p := p + 1 ;
25916: LD_ADDR_VAR 0 1
25920: PUSH
25921: LD_VAR 0 1
25925: PUSH
25926: LD_INT 1
25928: PLUS
25929: ST_TO_ADDR
// until p >= 60 ;
25930: LD_VAR 0 1
25934: PUSH
25935: LD_INT 60
25937: GREATEREQUAL
25938: IFFALSE 25901
// game_speed := 4 ;
25940: LD_ADDR_OWVAR 65
25944: PUSH
25945: LD_INT 4
25947: ST_TO_ADDR
// end ;
25948: PPOPN 1
25950: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25951: LD_EXP 47
25955: PUSH
25956: LD_EXP 74
25960: AND
25961: IFFALSE 26107
25963: GO 25965
25965: DISABLE
25966: LD_INT 0
25968: PPUSH
25969: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25970: LD_ADDR_VAR 0 1
25974: PUSH
25975: LD_INT 22
25977: PUSH
25978: LD_OWVAR 2
25982: PUSH
25983: EMPTY
25984: LIST
25985: LIST
25986: PUSH
25987: LD_INT 2
25989: PUSH
25990: LD_INT 30
25992: PUSH
25993: LD_INT 0
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 30
26002: PUSH
26003: LD_INT 1
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: LIST
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PPUSH
26019: CALL_OW 69
26023: ST_TO_ADDR
// if not depot then
26024: LD_VAR 0 1
26028: NOT
26029: IFFALSE 26033
// exit ;
26031: GO 26107
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
26033: LD_ADDR_VAR 0 2
26037: PUSH
26038: LD_VAR 0 1
26042: PUSH
26043: LD_INT 1
26045: PPUSH
26046: LD_VAR 0 1
26050: PPUSH
26051: CALL_OW 12
26055: ARRAY
26056: PPUSH
26057: CALL_OW 274
26061: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
26062: LD_VAR 0 2
26066: PPUSH
26067: LD_INT 1
26069: PPUSH
26070: LD_INT 0
26072: PPUSH
26073: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26077: LD_VAR 0 2
26081: PPUSH
26082: LD_INT 2
26084: PPUSH
26085: LD_INT 0
26087: PPUSH
26088: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26092: LD_VAR 0 2
26096: PPUSH
26097: LD_INT 3
26099: PPUSH
26100: LD_INT 0
26102: PPUSH
26103: CALL_OW 277
// end ;
26107: PPOPN 2
26109: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26110: LD_EXP 47
26114: PUSH
26115: LD_EXP 75
26119: AND
26120: IFFALSE 26217
26122: GO 26124
26124: DISABLE
26125: LD_INT 0
26127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26128: LD_ADDR_VAR 0 1
26132: PUSH
26133: LD_INT 22
26135: PUSH
26136: LD_OWVAR 2
26140: PUSH
26141: EMPTY
26142: LIST
26143: LIST
26144: PUSH
26145: LD_INT 21
26147: PUSH
26148: LD_INT 1
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: PUSH
26155: LD_INT 3
26157: PUSH
26158: LD_INT 23
26160: PUSH
26161: LD_INT 0
26163: PUSH
26164: EMPTY
26165: LIST
26166: LIST
26167: PUSH
26168: EMPTY
26169: LIST
26170: LIST
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: LIST
26176: PPUSH
26177: CALL_OW 69
26181: ST_TO_ADDR
// if not tmp then
26182: LD_VAR 0 1
26186: NOT
26187: IFFALSE 26191
// exit ;
26189: GO 26217
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26191: LD_VAR 0 1
26195: PUSH
26196: LD_INT 1
26198: PPUSH
26199: LD_VAR 0 1
26203: PPUSH
26204: CALL_OW 12
26208: ARRAY
26209: PPUSH
26210: LD_INT 200
26212: PPUSH
26213: CALL_OW 234
// end ;
26217: PPOPN 1
26219: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26220: LD_EXP 47
26224: PUSH
26225: LD_EXP 76
26229: AND
26230: IFFALSE 26309
26232: GO 26234
26234: DISABLE
26235: LD_INT 0
26237: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26238: LD_ADDR_VAR 0 1
26242: PUSH
26243: LD_INT 22
26245: PUSH
26246: LD_OWVAR 2
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: LD_INT 21
26257: PUSH
26258: LD_INT 2
26260: PUSH
26261: EMPTY
26262: LIST
26263: LIST
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PPUSH
26269: CALL_OW 69
26273: ST_TO_ADDR
// if not tmp then
26274: LD_VAR 0 1
26278: NOT
26279: IFFALSE 26283
// exit ;
26281: GO 26309
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26283: LD_VAR 0 1
26287: PUSH
26288: LD_INT 1
26290: PPUSH
26291: LD_VAR 0 1
26295: PPUSH
26296: CALL_OW 12
26300: ARRAY
26301: PPUSH
26302: LD_INT 60
26304: PPUSH
26305: CALL_OW 234
// end ;
26309: PPOPN 1
26311: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26312: LD_EXP 47
26316: PUSH
26317: LD_EXP 77
26321: AND
26322: IFFALSE 26421
26324: GO 26326
26326: DISABLE
26327: LD_INT 0
26329: PPUSH
26330: PPUSH
// begin enable ;
26331: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26332: LD_ADDR_VAR 0 1
26336: PUSH
26337: LD_INT 22
26339: PUSH
26340: LD_OWVAR 2
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: PUSH
26349: LD_INT 61
26351: PUSH
26352: EMPTY
26353: LIST
26354: PUSH
26355: LD_INT 33
26357: PUSH
26358: LD_INT 2
26360: PUSH
26361: EMPTY
26362: LIST
26363: LIST
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: LIST
26369: PPUSH
26370: CALL_OW 69
26374: ST_TO_ADDR
// if not tmp then
26375: LD_VAR 0 1
26379: NOT
26380: IFFALSE 26384
// exit ;
26382: GO 26421
// for i in tmp do
26384: LD_ADDR_VAR 0 2
26388: PUSH
26389: LD_VAR 0 1
26393: PUSH
26394: FOR_IN
26395: IFFALSE 26419
// if IsControledBy ( i ) then
26397: LD_VAR 0 2
26401: PPUSH
26402: CALL_OW 312
26406: IFFALSE 26417
// ComUnlink ( i ) ;
26408: LD_VAR 0 2
26412: PPUSH
26413: CALL_OW 136
26417: GO 26394
26419: POP
26420: POP
// end ;
26421: PPOPN 2
26423: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26424: LD_EXP 47
26428: PUSH
26429: LD_EXP 78
26433: AND
26434: IFFALSE 26574
26436: GO 26438
26438: DISABLE
26439: LD_INT 0
26441: PPUSH
26442: PPUSH
// begin ToLua ( displayPowell(); ) ;
26443: LD_STRING displayPowell();
26445: PPUSH
26446: CALL_OW 559
// uc_side := 0 ;
26450: LD_ADDR_OWVAR 20
26454: PUSH
26455: LD_INT 0
26457: ST_TO_ADDR
// uc_nation := 2 ;
26458: LD_ADDR_OWVAR 21
26462: PUSH
26463: LD_INT 2
26465: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26466: LD_ADDR_OWVAR 37
26470: PUSH
26471: LD_INT 14
26473: ST_TO_ADDR
// vc_engine := engine_siberite ;
26474: LD_ADDR_OWVAR 39
26478: PUSH
26479: LD_INT 3
26481: ST_TO_ADDR
// vc_control := control_apeman ;
26482: LD_ADDR_OWVAR 38
26486: PUSH
26487: LD_INT 5
26489: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26490: LD_ADDR_OWVAR 40
26494: PUSH
26495: LD_INT 29
26497: ST_TO_ADDR
// un := CreateVehicle ;
26498: LD_ADDR_VAR 0 2
26502: PUSH
26503: CALL_OW 45
26507: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26508: LD_VAR 0 2
26512: PPUSH
26513: LD_INT 1
26515: PPUSH
26516: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26520: LD_INT 35
26522: PPUSH
26523: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26527: LD_VAR 0 2
26531: PPUSH
26532: LD_INT 22
26534: PUSH
26535: LD_OWVAR 2
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PPUSH
26544: CALL_OW 69
26548: PPUSH
26549: LD_VAR 0 2
26553: PPUSH
26554: CALL_OW 74
26558: PPUSH
26559: CALL_OW 115
// until IsDead ( un ) ;
26563: LD_VAR 0 2
26567: PPUSH
26568: CALL_OW 301
26572: IFFALSE 26520
// end ;
26574: PPOPN 2
26576: END
// every 0 0$1 trigger StreamModeActive and sStu do
26577: LD_EXP 47
26581: PUSH
26582: LD_EXP 86
26586: AND
26587: IFFALSE 26603
26589: GO 26591
26591: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26592: LD_STRING displayStucuk();
26594: PPUSH
26595: CALL_OW 559
// ResetFog ;
26599: CALL_OW 335
// end ;
26603: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26604: LD_EXP 47
26608: PUSH
26609: LD_EXP 79
26613: AND
26614: IFFALSE 26755
26616: GO 26618
26618: DISABLE
26619: LD_INT 0
26621: PPUSH
26622: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26623: LD_ADDR_VAR 0 2
26627: PUSH
26628: LD_INT 22
26630: PUSH
26631: LD_OWVAR 2
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: PUSH
26640: LD_INT 21
26642: PUSH
26643: LD_INT 1
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: EMPTY
26651: LIST
26652: LIST
26653: PPUSH
26654: CALL_OW 69
26658: ST_TO_ADDR
// if not tmp then
26659: LD_VAR 0 2
26663: NOT
26664: IFFALSE 26668
// exit ;
26666: GO 26755
// un := tmp [ rand ( 1 , tmp ) ] ;
26668: LD_ADDR_VAR 0 1
26672: PUSH
26673: LD_VAR 0 2
26677: PUSH
26678: LD_INT 1
26680: PPUSH
26681: LD_VAR 0 2
26685: PPUSH
26686: CALL_OW 12
26690: ARRAY
26691: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26692: LD_VAR 0 1
26696: PPUSH
26697: LD_INT 0
26699: PPUSH
26700: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26704: LD_VAR 0 1
26708: PPUSH
26709: LD_OWVAR 3
26713: PUSH
26714: LD_VAR 0 1
26718: DIFF
26719: PPUSH
26720: LD_VAR 0 1
26724: PPUSH
26725: CALL_OW 74
26729: PPUSH
26730: CALL_OW 115
// wait ( 0 0$20 ) ;
26734: LD_INT 700
26736: PPUSH
26737: CALL_OW 67
// SetSide ( un , your_side ) ;
26741: LD_VAR 0 1
26745: PPUSH
26746: LD_OWVAR 2
26750: PPUSH
26751: CALL_OW 235
// end ;
26755: PPOPN 2
26757: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26758: LD_EXP 47
26762: PUSH
26763: LD_EXP 80
26767: AND
26768: IFFALSE 26874
26770: GO 26772
26772: DISABLE
26773: LD_INT 0
26775: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26776: LD_ADDR_VAR 0 1
26780: PUSH
26781: LD_INT 22
26783: PUSH
26784: LD_OWVAR 2
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 2
26795: PUSH
26796: LD_INT 30
26798: PUSH
26799: LD_INT 0
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 30
26808: PUSH
26809: LD_INT 1
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: EMPTY
26817: LIST
26818: LIST
26819: LIST
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: PPUSH
26825: CALL_OW 69
26829: ST_TO_ADDR
// if not depot then
26830: LD_VAR 0 1
26834: NOT
26835: IFFALSE 26839
// exit ;
26837: GO 26874
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
26839: LD_VAR 0 1
26843: PUSH
26844: LD_INT 1
26846: ARRAY
26847: PPUSH
26848: CALL_OW 250
26852: PPUSH
26853: LD_VAR 0 1
26857: PUSH
26858: LD_INT 1
26860: ARRAY
26861: PPUSH
26862: CALL_OW 251
26866: PPUSH
26867: LD_INT 70
26869: PPUSH
26870: CALL_OW 495
// end ;
26874: PPOPN 1
26876: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
26877: LD_EXP 47
26881: PUSH
26882: LD_EXP 81
26886: AND
26887: IFFALSE 27098
26889: GO 26891
26891: DISABLE
26892: LD_INT 0
26894: PPUSH
26895: PPUSH
26896: PPUSH
26897: PPUSH
26898: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26899: LD_ADDR_VAR 0 5
26903: PUSH
26904: LD_INT 22
26906: PUSH
26907: LD_OWVAR 2
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: PUSH
26916: LD_INT 21
26918: PUSH
26919: LD_INT 1
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PPUSH
26930: CALL_OW 69
26934: ST_TO_ADDR
// if not tmp then
26935: LD_VAR 0 5
26939: NOT
26940: IFFALSE 26944
// exit ;
26942: GO 27098
// for i in tmp do
26944: LD_ADDR_VAR 0 1
26948: PUSH
26949: LD_VAR 0 5
26953: PUSH
26954: FOR_IN
26955: IFFALSE 27096
// begin d := rand ( 0 , 5 ) ;
26957: LD_ADDR_VAR 0 4
26961: PUSH
26962: LD_INT 0
26964: PPUSH
26965: LD_INT 5
26967: PPUSH
26968: CALL_OW 12
26972: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26973: LD_ADDR_VAR 0 2
26977: PUSH
26978: LD_VAR 0 1
26982: PPUSH
26983: CALL_OW 250
26987: PPUSH
26988: LD_VAR 0 4
26992: PPUSH
26993: LD_INT 3
26995: PPUSH
26996: LD_INT 12
26998: PPUSH
26999: CALL_OW 12
27003: PPUSH
27004: CALL_OW 272
27008: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
27009: LD_ADDR_VAR 0 3
27013: PUSH
27014: LD_VAR 0 1
27018: PPUSH
27019: CALL_OW 251
27023: PPUSH
27024: LD_VAR 0 4
27028: PPUSH
27029: LD_INT 3
27031: PPUSH
27032: LD_INT 12
27034: PPUSH
27035: CALL_OW 12
27039: PPUSH
27040: CALL_OW 273
27044: ST_TO_ADDR
// if ValidHex ( x , y ) then
27045: LD_VAR 0 2
27049: PPUSH
27050: LD_VAR 0 3
27054: PPUSH
27055: CALL_OW 488
27059: IFFALSE 27094
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
27061: LD_VAR 0 1
27065: PPUSH
27066: LD_VAR 0 2
27070: PPUSH
27071: LD_VAR 0 3
27075: PPUSH
27076: LD_INT 3
27078: PPUSH
27079: LD_INT 6
27081: PPUSH
27082: CALL_OW 12
27086: PPUSH
27087: LD_INT 1
27089: PPUSH
27090: CALL_OW 483
// end ;
27094: GO 26954
27096: POP
27097: POP
// end ;
27098: PPOPN 5
27100: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27101: LD_EXP 47
27105: PUSH
27106: LD_EXP 82
27110: AND
27111: IFFALSE 27205
27113: GO 27115
27115: DISABLE
27116: LD_INT 0
27118: PPUSH
27119: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27120: LD_ADDR_VAR 0 2
27124: PUSH
27125: LD_INT 22
27127: PUSH
27128: LD_OWVAR 2
27132: PUSH
27133: EMPTY
27134: LIST
27135: LIST
27136: PUSH
27137: LD_INT 32
27139: PUSH
27140: LD_INT 1
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PUSH
27147: LD_INT 21
27149: PUSH
27150: LD_INT 2
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: LIST
27161: PPUSH
27162: CALL_OW 69
27166: ST_TO_ADDR
// if not tmp then
27167: LD_VAR 0 2
27171: NOT
27172: IFFALSE 27176
// exit ;
27174: GO 27205
// for i in tmp do
27176: LD_ADDR_VAR 0 1
27180: PUSH
27181: LD_VAR 0 2
27185: PUSH
27186: FOR_IN
27187: IFFALSE 27203
// SetFuel ( i , 0 ) ;
27189: LD_VAR 0 1
27193: PPUSH
27194: LD_INT 0
27196: PPUSH
27197: CALL_OW 240
27201: GO 27186
27203: POP
27204: POP
// end ;
27205: PPOPN 2
27207: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27208: LD_EXP 47
27212: PUSH
27213: LD_EXP 83
27217: AND
27218: IFFALSE 27284
27220: GO 27222
27222: DISABLE
27223: LD_INT 0
27225: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27226: LD_ADDR_VAR 0 1
27230: PUSH
27231: LD_INT 22
27233: PUSH
27234: LD_OWVAR 2
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 30
27245: PUSH
27246: LD_INT 29
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: PUSH
27253: EMPTY
27254: LIST
27255: LIST
27256: PPUSH
27257: CALL_OW 69
27261: ST_TO_ADDR
// if not tmp then
27262: LD_VAR 0 1
27266: NOT
27267: IFFALSE 27271
// exit ;
27269: GO 27284
// DestroyUnit ( tmp [ 1 ] ) ;
27271: LD_VAR 0 1
27275: PUSH
27276: LD_INT 1
27278: ARRAY
27279: PPUSH
27280: CALL_OW 65
// end ;
27284: PPOPN 1
27286: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27287: LD_EXP 47
27291: PUSH
27292: LD_EXP 85
27296: AND
27297: IFFALSE 27426
27299: GO 27301
27301: DISABLE
27302: LD_INT 0
27304: PPUSH
// begin uc_side := 0 ;
27305: LD_ADDR_OWVAR 20
27309: PUSH
27310: LD_INT 0
27312: ST_TO_ADDR
// uc_nation := nation_arabian ;
27313: LD_ADDR_OWVAR 21
27317: PUSH
27318: LD_INT 2
27320: ST_TO_ADDR
// hc_gallery :=  ;
27321: LD_ADDR_OWVAR 33
27325: PUSH
27326: LD_STRING 
27328: ST_TO_ADDR
// hc_name :=  ;
27329: LD_ADDR_OWVAR 26
27333: PUSH
27334: LD_STRING 
27336: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27337: LD_INT 1
27339: PPUSH
27340: LD_INT 11
27342: PPUSH
27343: LD_INT 10
27345: PPUSH
27346: CALL_OW 380
// un := CreateHuman ;
27350: LD_ADDR_VAR 0 1
27354: PUSH
27355: CALL_OW 44
27359: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27360: LD_VAR 0 1
27364: PPUSH
27365: LD_INT 1
27367: PPUSH
27368: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27372: LD_INT 35
27374: PPUSH
27375: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27379: LD_VAR 0 1
27383: PPUSH
27384: LD_INT 22
27386: PUSH
27387: LD_OWVAR 2
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PPUSH
27396: CALL_OW 69
27400: PPUSH
27401: LD_VAR 0 1
27405: PPUSH
27406: CALL_OW 74
27410: PPUSH
27411: CALL_OW 115
// until IsDead ( un ) ;
27415: LD_VAR 0 1
27419: PPUSH
27420: CALL_OW 301
27424: IFFALSE 27372
// end ;
27426: PPOPN 1
27428: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27429: LD_EXP 47
27433: PUSH
27434: LD_EXP 87
27438: AND
27439: IFFALSE 27451
27441: GO 27443
27443: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27444: LD_STRING earthquake(getX(game), 0, 32)
27446: PPUSH
27447: CALL_OW 559
27451: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27452: LD_EXP 47
27456: PUSH
27457: LD_EXP 88
27461: AND
27462: IFFALSE 27553
27464: GO 27466
27466: DISABLE
27467: LD_INT 0
27469: PPUSH
// begin enable ;
27470: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27471: LD_ADDR_VAR 0 1
27475: PUSH
27476: LD_INT 22
27478: PUSH
27479: LD_OWVAR 2
27483: PUSH
27484: EMPTY
27485: LIST
27486: LIST
27487: PUSH
27488: LD_INT 21
27490: PUSH
27491: LD_INT 2
27493: PUSH
27494: EMPTY
27495: LIST
27496: LIST
27497: PUSH
27498: LD_INT 33
27500: PUSH
27501: LD_INT 3
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: LIST
27512: PPUSH
27513: CALL_OW 69
27517: ST_TO_ADDR
// if not tmp then
27518: LD_VAR 0 1
27522: NOT
27523: IFFALSE 27527
// exit ;
27525: GO 27553
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27527: LD_VAR 0 1
27531: PUSH
27532: LD_INT 1
27534: PPUSH
27535: LD_VAR 0 1
27539: PPUSH
27540: CALL_OW 12
27544: ARRAY
27545: PPUSH
27546: LD_INT 1
27548: PPUSH
27549: CALL_OW 234
// end ;
27553: PPOPN 1
27555: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27556: LD_EXP 47
27560: PUSH
27561: LD_EXP 89
27565: AND
27566: IFFALSE 27707
27568: GO 27570
27570: DISABLE
27571: LD_INT 0
27573: PPUSH
27574: PPUSH
27575: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27576: LD_ADDR_VAR 0 3
27580: PUSH
27581: LD_INT 22
27583: PUSH
27584: LD_OWVAR 2
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: PUSH
27593: LD_INT 25
27595: PUSH
27596: LD_INT 1
27598: PUSH
27599: EMPTY
27600: LIST
27601: LIST
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: PPUSH
27607: CALL_OW 69
27611: ST_TO_ADDR
// if not tmp then
27612: LD_VAR 0 3
27616: NOT
27617: IFFALSE 27621
// exit ;
27619: GO 27707
// un := tmp [ rand ( 1 , tmp ) ] ;
27621: LD_ADDR_VAR 0 2
27625: PUSH
27626: LD_VAR 0 3
27630: PUSH
27631: LD_INT 1
27633: PPUSH
27634: LD_VAR 0 3
27638: PPUSH
27639: CALL_OW 12
27643: ARRAY
27644: ST_TO_ADDR
// if Crawls ( un ) then
27645: LD_VAR 0 2
27649: PPUSH
27650: CALL_OW 318
27654: IFFALSE 27665
// ComWalk ( un ) ;
27656: LD_VAR 0 2
27660: PPUSH
27661: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27665: LD_VAR 0 2
27669: PPUSH
27670: LD_INT 9
27672: PPUSH
27673: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27677: LD_INT 28
27679: PPUSH
27680: LD_OWVAR 2
27684: PPUSH
27685: LD_INT 2
27687: PPUSH
27688: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27692: LD_INT 29
27694: PPUSH
27695: LD_OWVAR 2
27699: PPUSH
27700: LD_INT 2
27702: PPUSH
27703: CALL_OW 322
// end ;
27707: PPOPN 3
27709: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27710: LD_EXP 47
27714: PUSH
27715: LD_EXP 90
27719: AND
27720: IFFALSE 27831
27722: GO 27724
27724: DISABLE
27725: LD_INT 0
27727: PPUSH
27728: PPUSH
27729: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27730: LD_ADDR_VAR 0 3
27734: PUSH
27735: LD_INT 22
27737: PUSH
27738: LD_OWVAR 2
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: PUSH
27747: LD_INT 25
27749: PUSH
27750: LD_INT 1
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PUSH
27757: EMPTY
27758: LIST
27759: LIST
27760: PPUSH
27761: CALL_OW 69
27765: ST_TO_ADDR
// if not tmp then
27766: LD_VAR 0 3
27770: NOT
27771: IFFALSE 27775
// exit ;
27773: GO 27831
// un := tmp [ rand ( 1 , tmp ) ] ;
27775: LD_ADDR_VAR 0 2
27779: PUSH
27780: LD_VAR 0 3
27784: PUSH
27785: LD_INT 1
27787: PPUSH
27788: LD_VAR 0 3
27792: PPUSH
27793: CALL_OW 12
27797: ARRAY
27798: ST_TO_ADDR
// if Crawls ( un ) then
27799: LD_VAR 0 2
27803: PPUSH
27804: CALL_OW 318
27808: IFFALSE 27819
// ComWalk ( un ) ;
27810: LD_VAR 0 2
27814: PPUSH
27815: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27819: LD_VAR 0 2
27823: PPUSH
27824: LD_INT 8
27826: PPUSH
27827: CALL_OW 336
// end ;
27831: PPOPN 3
27833: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
27834: LD_EXP 47
27838: PUSH
27839: LD_EXP 91
27843: AND
27844: IFFALSE 27988
27846: GO 27848
27848: DISABLE
27849: LD_INT 0
27851: PPUSH
27852: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
27853: LD_ADDR_VAR 0 2
27857: PUSH
27858: LD_INT 22
27860: PUSH
27861: LD_OWVAR 2
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PUSH
27870: LD_INT 21
27872: PUSH
27873: LD_INT 2
27875: PUSH
27876: EMPTY
27877: LIST
27878: LIST
27879: PUSH
27880: LD_INT 2
27882: PUSH
27883: LD_INT 34
27885: PUSH
27886: LD_INT 12
27888: PUSH
27889: EMPTY
27890: LIST
27891: LIST
27892: PUSH
27893: LD_INT 34
27895: PUSH
27896: LD_INT 51
27898: PUSH
27899: EMPTY
27900: LIST
27901: LIST
27902: PUSH
27903: LD_INT 34
27905: PUSH
27906: LD_INT 32
27908: PUSH
27909: EMPTY
27910: LIST
27911: LIST
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: LIST
27917: LIST
27918: PUSH
27919: EMPTY
27920: LIST
27921: LIST
27922: LIST
27923: PPUSH
27924: CALL_OW 69
27928: ST_TO_ADDR
// if not tmp then
27929: LD_VAR 0 2
27933: NOT
27934: IFFALSE 27938
// exit ;
27936: GO 27988
// for i in tmp do
27938: LD_ADDR_VAR 0 1
27942: PUSH
27943: LD_VAR 0 2
27947: PUSH
27948: FOR_IN
27949: IFFALSE 27986
// if GetCargo ( i , mat_artifact ) = 0 then
27951: LD_VAR 0 1
27955: PPUSH
27956: LD_INT 4
27958: PPUSH
27959: CALL_OW 289
27963: PUSH
27964: LD_INT 0
27966: EQUAL
27967: IFFALSE 27984
// SetCargo ( i , mat_siberit , 100 ) ;
27969: LD_VAR 0 1
27973: PPUSH
27974: LD_INT 3
27976: PPUSH
27977: LD_INT 100
27979: PPUSH
27980: CALL_OW 290
27984: GO 27948
27986: POP
27987: POP
// end ;
27988: PPOPN 2
27990: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27991: LD_EXP 47
27995: PUSH
27996: LD_EXP 92
28000: AND
28001: IFFALSE 28154
28003: GO 28005
28005: DISABLE
28006: LD_INT 0
28008: PPUSH
28009: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
28010: LD_ADDR_VAR 0 2
28014: PUSH
28015: LD_INT 22
28017: PUSH
28018: LD_OWVAR 2
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: PPUSH
28027: CALL_OW 69
28031: ST_TO_ADDR
// if not tmp then
28032: LD_VAR 0 2
28036: NOT
28037: IFFALSE 28041
// exit ;
28039: GO 28154
// for i := 1 to 2 do
28041: LD_ADDR_VAR 0 1
28045: PUSH
28046: DOUBLE
28047: LD_INT 1
28049: DEC
28050: ST_TO_ADDR
28051: LD_INT 2
28053: PUSH
28054: FOR_TO
28055: IFFALSE 28152
// begin uc_side := your_side ;
28057: LD_ADDR_OWVAR 20
28061: PUSH
28062: LD_OWVAR 2
28066: ST_TO_ADDR
// uc_nation := nation_american ;
28067: LD_ADDR_OWVAR 21
28071: PUSH
28072: LD_INT 1
28074: ST_TO_ADDR
// vc_chassis := us_morphling ;
28075: LD_ADDR_OWVAR 37
28079: PUSH
28080: LD_INT 5
28082: ST_TO_ADDR
// vc_engine := engine_siberite ;
28083: LD_ADDR_OWVAR 39
28087: PUSH
28088: LD_INT 3
28090: ST_TO_ADDR
// vc_control := control_computer ;
28091: LD_ADDR_OWVAR 38
28095: PUSH
28096: LD_INT 3
28098: ST_TO_ADDR
// vc_weapon := us_double_laser ;
28099: LD_ADDR_OWVAR 40
28103: PUSH
28104: LD_INT 10
28106: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
28107: CALL_OW 45
28111: PPUSH
28112: LD_VAR 0 2
28116: PUSH
28117: LD_INT 1
28119: ARRAY
28120: PPUSH
28121: CALL_OW 250
28125: PPUSH
28126: LD_VAR 0 2
28130: PUSH
28131: LD_INT 1
28133: ARRAY
28134: PPUSH
28135: CALL_OW 251
28139: PPUSH
28140: LD_INT 12
28142: PPUSH
28143: LD_INT 1
28145: PPUSH
28146: CALL_OW 50
// end ;
28150: GO 28054
28152: POP
28153: POP
// end ;
28154: PPOPN 2
28156: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28157: LD_EXP 47
28161: PUSH
28162: LD_EXP 93
28166: AND
28167: IFFALSE 28389
28169: GO 28171
28171: DISABLE
28172: LD_INT 0
28174: PPUSH
28175: PPUSH
28176: PPUSH
28177: PPUSH
28178: PPUSH
28179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28180: LD_ADDR_VAR 0 6
28184: PUSH
28185: LD_INT 22
28187: PUSH
28188: LD_OWVAR 2
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: PUSH
28197: LD_INT 21
28199: PUSH
28200: LD_INT 1
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PUSH
28207: LD_INT 3
28209: PUSH
28210: LD_INT 23
28212: PUSH
28213: LD_INT 0
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: LIST
28228: PPUSH
28229: CALL_OW 69
28233: ST_TO_ADDR
// if not tmp then
28234: LD_VAR 0 6
28238: NOT
28239: IFFALSE 28243
// exit ;
28241: GO 28389
// s1 := rand ( 1 , 4 ) ;
28243: LD_ADDR_VAR 0 2
28247: PUSH
28248: LD_INT 1
28250: PPUSH
28251: LD_INT 4
28253: PPUSH
28254: CALL_OW 12
28258: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28259: LD_ADDR_VAR 0 4
28263: PUSH
28264: LD_VAR 0 6
28268: PUSH
28269: LD_INT 1
28271: ARRAY
28272: PPUSH
28273: LD_VAR 0 2
28277: PPUSH
28278: CALL_OW 259
28282: ST_TO_ADDR
// if s1 = 1 then
28283: LD_VAR 0 2
28287: PUSH
28288: LD_INT 1
28290: EQUAL
28291: IFFALSE 28311
// s2 := rand ( 2 , 4 ) else
28293: LD_ADDR_VAR 0 3
28297: PUSH
28298: LD_INT 2
28300: PPUSH
28301: LD_INT 4
28303: PPUSH
28304: CALL_OW 12
28308: ST_TO_ADDR
28309: GO 28319
// s2 := 1 ;
28311: LD_ADDR_VAR 0 3
28315: PUSH
28316: LD_INT 1
28318: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28319: LD_ADDR_VAR 0 5
28323: PUSH
28324: LD_VAR 0 6
28328: PUSH
28329: LD_INT 1
28331: ARRAY
28332: PPUSH
28333: LD_VAR 0 3
28337: PPUSH
28338: CALL_OW 259
28342: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28343: LD_VAR 0 6
28347: PUSH
28348: LD_INT 1
28350: ARRAY
28351: PPUSH
28352: LD_VAR 0 2
28356: PPUSH
28357: LD_VAR 0 5
28361: PPUSH
28362: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28366: LD_VAR 0 6
28370: PUSH
28371: LD_INT 1
28373: ARRAY
28374: PPUSH
28375: LD_VAR 0 3
28379: PPUSH
28380: LD_VAR 0 4
28384: PPUSH
28385: CALL_OW 237
// end ;
28389: PPOPN 6
28391: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28392: LD_EXP 47
28396: PUSH
28397: LD_EXP 94
28401: AND
28402: IFFALSE 28481
28404: GO 28406
28406: DISABLE
28407: LD_INT 0
28409: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28410: LD_ADDR_VAR 0 1
28414: PUSH
28415: LD_INT 22
28417: PUSH
28418: LD_OWVAR 2
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 30
28429: PUSH
28430: LD_INT 3
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: PUSH
28437: EMPTY
28438: LIST
28439: LIST
28440: PPUSH
28441: CALL_OW 69
28445: ST_TO_ADDR
// if not tmp then
28446: LD_VAR 0 1
28450: NOT
28451: IFFALSE 28455
// exit ;
28453: GO 28481
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28455: LD_VAR 0 1
28459: PUSH
28460: LD_INT 1
28462: PPUSH
28463: LD_VAR 0 1
28467: PPUSH
28468: CALL_OW 12
28472: ARRAY
28473: PPUSH
28474: LD_INT 1
28476: PPUSH
28477: CALL_OW 234
// end ;
28481: PPOPN 1
28483: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28484: LD_EXP 47
28488: PUSH
28489: LD_EXP 95
28493: AND
28494: IFFALSE 28606
28496: GO 28498
28498: DISABLE
28499: LD_INT 0
28501: PPUSH
28502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28503: LD_ADDR_VAR 0 2
28507: PUSH
28508: LD_INT 22
28510: PUSH
28511: LD_OWVAR 2
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: LD_INT 2
28522: PUSH
28523: LD_INT 30
28525: PUSH
28526: LD_INT 27
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: LD_INT 30
28535: PUSH
28536: LD_INT 26
28538: PUSH
28539: EMPTY
28540: LIST
28541: LIST
28542: PUSH
28543: LD_INT 30
28545: PUSH
28546: LD_INT 28
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: LIST
28557: LIST
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PPUSH
28563: CALL_OW 69
28567: ST_TO_ADDR
// if not tmp then
28568: LD_VAR 0 2
28572: NOT
28573: IFFALSE 28577
// exit ;
28575: GO 28606
// for i in tmp do
28577: LD_ADDR_VAR 0 1
28581: PUSH
28582: LD_VAR 0 2
28586: PUSH
28587: FOR_IN
28588: IFFALSE 28604
// SetLives ( i , 1 ) ;
28590: LD_VAR 0 1
28594: PPUSH
28595: LD_INT 1
28597: PPUSH
28598: CALL_OW 234
28602: GO 28587
28604: POP
28605: POP
// end ;
28606: PPOPN 2
28608: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28609: LD_EXP 47
28613: PUSH
28614: LD_EXP 96
28618: AND
28619: IFFALSE 28893
28621: GO 28623
28623: DISABLE
28624: LD_INT 0
28626: PPUSH
28627: PPUSH
28628: PPUSH
// begin i := rand ( 1 , 7 ) ;
28629: LD_ADDR_VAR 0 1
28633: PUSH
28634: LD_INT 1
28636: PPUSH
28637: LD_INT 7
28639: PPUSH
28640: CALL_OW 12
28644: ST_TO_ADDR
// case i of 1 :
28645: LD_VAR 0 1
28649: PUSH
28650: LD_INT 1
28652: DOUBLE
28653: EQUAL
28654: IFTRUE 28658
28656: GO 28668
28658: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28659: LD_STRING earthquake(getX(game), 0, 32)
28661: PPUSH
28662: CALL_OW 559
28666: GO 28893
28668: LD_INT 2
28670: DOUBLE
28671: EQUAL
28672: IFTRUE 28676
28674: GO 28690
28676: POP
// begin ToLua ( displayStucuk(); ) ;
28677: LD_STRING displayStucuk();
28679: PPUSH
28680: CALL_OW 559
// ResetFog ;
28684: CALL_OW 335
// end ; 3 :
28688: GO 28893
28690: LD_INT 3
28692: DOUBLE
28693: EQUAL
28694: IFTRUE 28698
28696: GO 28802
28698: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28699: LD_ADDR_VAR 0 2
28703: PUSH
28704: LD_INT 22
28706: PUSH
28707: LD_OWVAR 2
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 25
28718: PUSH
28719: LD_INT 1
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PPUSH
28730: CALL_OW 69
28734: ST_TO_ADDR
// if not tmp then
28735: LD_VAR 0 2
28739: NOT
28740: IFFALSE 28744
// exit ;
28742: GO 28893
// un := tmp [ rand ( 1 , tmp ) ] ;
28744: LD_ADDR_VAR 0 3
28748: PUSH
28749: LD_VAR 0 2
28753: PUSH
28754: LD_INT 1
28756: PPUSH
28757: LD_VAR 0 2
28761: PPUSH
28762: CALL_OW 12
28766: ARRAY
28767: ST_TO_ADDR
// if Crawls ( un ) then
28768: LD_VAR 0 3
28772: PPUSH
28773: CALL_OW 318
28777: IFFALSE 28788
// ComWalk ( un ) ;
28779: LD_VAR 0 3
28783: PPUSH
28784: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28788: LD_VAR 0 3
28792: PPUSH
28793: LD_INT 8
28795: PPUSH
28796: CALL_OW 336
// end ; 4 :
28800: GO 28893
28802: LD_INT 4
28804: DOUBLE
28805: EQUAL
28806: IFTRUE 28810
28808: GO 28871
28810: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28811: LD_ADDR_VAR 0 2
28815: PUSH
28816: LD_INT 22
28818: PUSH
28819: LD_OWVAR 2
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 30
28830: PUSH
28831: LD_INT 29
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PPUSH
28842: CALL_OW 69
28846: ST_TO_ADDR
// if not tmp then
28847: LD_VAR 0 2
28851: NOT
28852: IFFALSE 28856
// exit ;
28854: GO 28893
// DestroyUnit ( tmp [ 1 ] ) ;
28856: LD_VAR 0 2
28860: PUSH
28861: LD_INT 1
28863: ARRAY
28864: PPUSH
28865: CALL_OW 65
// end ; 5 .. 7 :
28869: GO 28893
28871: LD_INT 5
28873: DOUBLE
28874: GREATEREQUAL
28875: IFFALSE 28883
28877: LD_INT 7
28879: DOUBLE
28880: LESSEQUAL
28881: IFTRUE 28885
28883: GO 28892
28885: POP
// StreamSibBomb ; end ;
28886: CALL 25173 0 0
28890: GO 28893
28892: POP
// end ;
28893: PPOPN 3
28895: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
28896: LD_EXP 47
28900: PUSH
28901: LD_EXP 97
28905: AND
28906: IFFALSE 29062
28908: GO 28910
28910: DISABLE
28911: LD_INT 0
28913: PPUSH
28914: PPUSH
28915: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
28916: LD_ADDR_VAR 0 2
28920: PUSH
28921: LD_INT 81
28923: PUSH
28924: LD_OWVAR 2
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 2
28935: PUSH
28936: LD_INT 21
28938: PUSH
28939: LD_INT 1
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 21
28948: PUSH
28949: LD_INT 2
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: LIST
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PPUSH
28965: CALL_OW 69
28969: ST_TO_ADDR
// if not tmp then
28970: LD_VAR 0 2
28974: NOT
28975: IFFALSE 28979
// exit ;
28977: GO 29062
// p := 0 ;
28979: LD_ADDR_VAR 0 3
28983: PUSH
28984: LD_INT 0
28986: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28987: LD_INT 35
28989: PPUSH
28990: CALL_OW 67
// p := p + 1 ;
28994: LD_ADDR_VAR 0 3
28998: PUSH
28999: LD_VAR 0 3
29003: PUSH
29004: LD_INT 1
29006: PLUS
29007: ST_TO_ADDR
// for i in tmp do
29008: LD_ADDR_VAR 0 1
29012: PUSH
29013: LD_VAR 0 2
29017: PUSH
29018: FOR_IN
29019: IFFALSE 29050
// if GetLives ( i ) < 1000 then
29021: LD_VAR 0 1
29025: PPUSH
29026: CALL_OW 256
29030: PUSH
29031: LD_INT 1000
29033: LESS
29034: IFFALSE 29048
// SetLives ( i , 1000 ) ;
29036: LD_VAR 0 1
29040: PPUSH
29041: LD_INT 1000
29043: PPUSH
29044: CALL_OW 234
29048: GO 29018
29050: POP
29051: POP
// until p > 20 ;
29052: LD_VAR 0 3
29056: PUSH
29057: LD_INT 20
29059: GREATER
29060: IFFALSE 28987
// end ;
29062: PPOPN 3
29064: END
// every 0 0$1 trigger StreamModeActive and sTime do
29065: LD_EXP 47
29069: PUSH
29070: LD_EXP 98
29074: AND
29075: IFFALSE 29110
29077: GO 29079
29079: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
29080: LD_INT 28
29082: PPUSH
29083: LD_OWVAR 2
29087: PPUSH
29088: LD_INT 2
29090: PPUSH
29091: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
29095: LD_INT 30
29097: PPUSH
29098: LD_OWVAR 2
29102: PPUSH
29103: LD_INT 2
29105: PPUSH
29106: CALL_OW 322
// end ;
29110: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
29111: LD_EXP 47
29115: PUSH
29116: LD_EXP 99
29120: AND
29121: IFFALSE 29242
29123: GO 29125
29125: DISABLE
29126: LD_INT 0
29128: PPUSH
29129: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29130: LD_ADDR_VAR 0 2
29134: PUSH
29135: LD_INT 22
29137: PUSH
29138: LD_OWVAR 2
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 21
29149: PUSH
29150: LD_INT 1
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 3
29159: PUSH
29160: LD_INT 23
29162: PUSH
29163: LD_INT 0
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: LIST
29178: PPUSH
29179: CALL_OW 69
29183: ST_TO_ADDR
// if not tmp then
29184: LD_VAR 0 2
29188: NOT
29189: IFFALSE 29193
// exit ;
29191: GO 29242
// for i in tmp do
29193: LD_ADDR_VAR 0 1
29197: PUSH
29198: LD_VAR 0 2
29202: PUSH
29203: FOR_IN
29204: IFFALSE 29240
// begin if Crawls ( i ) then
29206: LD_VAR 0 1
29210: PPUSH
29211: CALL_OW 318
29215: IFFALSE 29226
// ComWalk ( i ) ;
29217: LD_VAR 0 1
29221: PPUSH
29222: CALL_OW 138
// SetClass ( i , 2 ) ;
29226: LD_VAR 0 1
29230: PPUSH
29231: LD_INT 2
29233: PPUSH
29234: CALL_OW 336
// end ;
29238: GO 29203
29240: POP
29241: POP
// end ;
29242: PPOPN 2
29244: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29245: LD_EXP 47
29249: PUSH
29250: LD_EXP 100
29254: AND
29255: IFFALSE 29536
29257: GO 29259
29259: DISABLE
29260: LD_INT 0
29262: PPUSH
29263: PPUSH
29264: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29265: LD_OWVAR 2
29269: PPUSH
29270: LD_INT 9
29272: PPUSH
29273: LD_INT 1
29275: PPUSH
29276: LD_INT 1
29278: PPUSH
29279: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29283: LD_INT 9
29285: PPUSH
29286: LD_OWVAR 2
29290: PPUSH
29291: CALL_OW 343
// uc_side := 9 ;
29295: LD_ADDR_OWVAR 20
29299: PUSH
29300: LD_INT 9
29302: ST_TO_ADDR
// uc_nation := 2 ;
29303: LD_ADDR_OWVAR 21
29307: PUSH
29308: LD_INT 2
29310: ST_TO_ADDR
// hc_name := Dark Warrior ;
29311: LD_ADDR_OWVAR 26
29315: PUSH
29316: LD_STRING Dark Warrior
29318: ST_TO_ADDR
// hc_gallery :=  ;
29319: LD_ADDR_OWVAR 33
29323: PUSH
29324: LD_STRING 
29326: ST_TO_ADDR
// hc_noskilllimit := true ;
29327: LD_ADDR_OWVAR 76
29331: PUSH
29332: LD_INT 1
29334: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
29335: LD_ADDR_OWVAR 31
29339: PUSH
29340: LD_INT 30
29342: PUSH
29343: LD_INT 30
29345: PUSH
29346: LD_INT 30
29348: PUSH
29349: LD_INT 30
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: LIST
29356: LIST
29357: ST_TO_ADDR
// un := CreateHuman ;
29358: LD_ADDR_VAR 0 3
29362: PUSH
29363: CALL_OW 44
29367: ST_TO_ADDR
// hc_noskilllimit := false ;
29368: LD_ADDR_OWVAR 76
29372: PUSH
29373: LD_INT 0
29375: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29376: LD_VAR 0 3
29380: PPUSH
29381: LD_INT 1
29383: PPUSH
29384: CALL_OW 51
// p := 0 ;
29388: LD_ADDR_VAR 0 2
29392: PUSH
29393: LD_INT 0
29395: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29396: LD_INT 35
29398: PPUSH
29399: CALL_OW 67
// p := p + 1 ;
29403: LD_ADDR_VAR 0 2
29407: PUSH
29408: LD_VAR 0 2
29412: PUSH
29413: LD_INT 1
29415: PLUS
29416: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
29417: LD_VAR 0 3
29421: PPUSH
29422: CALL_OW 256
29426: PUSH
29427: LD_INT 1000
29429: LESS
29430: IFFALSE 29444
// SetLives ( un , 1000 ) ;
29432: LD_VAR 0 3
29436: PPUSH
29437: LD_INT 1000
29439: PPUSH
29440: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
29444: LD_VAR 0 3
29448: PPUSH
29449: LD_INT 81
29451: PUSH
29452: LD_OWVAR 2
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 91
29463: PUSH
29464: LD_VAR 0 3
29468: PUSH
29469: LD_INT 30
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: LIST
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PPUSH
29481: CALL_OW 69
29485: PPUSH
29486: LD_VAR 0 3
29490: PPUSH
29491: CALL_OW 74
29495: PPUSH
29496: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29500: LD_VAR 0 2
29504: PUSH
29505: LD_INT 60
29507: GREATER
29508: PUSH
29509: LD_VAR 0 3
29513: PPUSH
29514: CALL_OW 301
29518: OR
29519: IFFALSE 29396
// if un then
29521: LD_VAR 0 3
29525: IFFALSE 29536
// RemoveUnit ( un ) ;
29527: LD_VAR 0 3
29531: PPUSH
29532: CALL_OW 64
// end ; end_of_file
29536: PPOPN 3
29538: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29539: LD_INT 0
29541: PPUSH
29542: PPUSH
29543: PPUSH
29544: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29545: LD_VAR 0 1
29549: PPUSH
29550: CALL_OW 264
29554: PUSH
29555: LD_EXP 46
29559: EQUAL
29560: IFFALSE 29632
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29562: LD_INT 68
29564: PPUSH
29565: LD_VAR 0 1
29569: PPUSH
29570: CALL_OW 255
29574: PPUSH
29575: CALL_OW 321
29579: PUSH
29580: LD_INT 2
29582: EQUAL
29583: IFFALSE 29595
// eff := 70 else
29585: LD_ADDR_VAR 0 4
29589: PUSH
29590: LD_INT 70
29592: ST_TO_ADDR
29593: GO 29603
// eff := 30 ;
29595: LD_ADDR_VAR 0 4
29599: PUSH
29600: LD_INT 30
29602: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29603: LD_VAR 0 1
29607: PPUSH
29608: CALL_OW 250
29612: PPUSH
29613: LD_VAR 0 1
29617: PPUSH
29618: CALL_OW 251
29622: PPUSH
29623: LD_VAR 0 4
29627: PPUSH
29628: CALL_OW 495
// end ; end ;
29632: LD_VAR 0 2
29636: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29637: LD_INT 0
29639: PPUSH
// end ;
29640: LD_VAR 0 4
29644: RET
// export function SOS_Command ( cmd ) ; begin
29645: LD_INT 0
29647: PPUSH
// end ;
29648: LD_VAR 0 2
29652: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
29653: LD_VAR 0 1
29657: PUSH
29658: LD_INT 255
29660: EQUAL
29661: PUSH
29662: LD_VAR 0 2
29666: PPUSH
29667: CALL_OW 264
29671: PUSH
29672: LD_INT 14
29674: PUSH
29675: LD_INT 53
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: IN
29682: AND
29683: PUSH
29684: LD_VAR 0 4
29688: PPUSH
29689: LD_VAR 0 5
29693: PPUSH
29694: CALL_OW 488
29698: AND
29699: IFFALSE 29723
// CutTreeXYR ( unit , x , y , 12 ) ;
29701: LD_VAR 0 2
29705: PPUSH
29706: LD_VAR 0 4
29710: PPUSH
29711: LD_VAR 0 5
29715: PPUSH
29716: LD_INT 12
29718: PPUSH
29719: CALL 29726 0 4
// end ;
29723: PPOPN 5
29725: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29726: LD_INT 0
29728: PPUSH
29729: PPUSH
29730: PPUSH
29731: PPUSH
29732: PPUSH
29733: PPUSH
29734: PPUSH
29735: PPUSH
29736: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29737: LD_VAR 0 1
29741: NOT
29742: PUSH
29743: LD_VAR 0 2
29747: PPUSH
29748: LD_VAR 0 3
29752: PPUSH
29753: CALL_OW 488
29757: NOT
29758: OR
29759: PUSH
29760: LD_VAR 0 4
29764: NOT
29765: OR
29766: IFFALSE 29770
// exit ;
29768: GO 30110
// list := [ ] ;
29770: LD_ADDR_VAR 0 13
29774: PUSH
29775: EMPTY
29776: ST_TO_ADDR
// if x - r < 0 then
29777: LD_VAR 0 2
29781: PUSH
29782: LD_VAR 0 4
29786: MINUS
29787: PUSH
29788: LD_INT 0
29790: LESS
29791: IFFALSE 29803
// min_x := 0 else
29793: LD_ADDR_VAR 0 7
29797: PUSH
29798: LD_INT 0
29800: ST_TO_ADDR
29801: GO 29819
// min_x := x - r ;
29803: LD_ADDR_VAR 0 7
29807: PUSH
29808: LD_VAR 0 2
29812: PUSH
29813: LD_VAR 0 4
29817: MINUS
29818: ST_TO_ADDR
// if y - r < 0 then
29819: LD_VAR 0 3
29823: PUSH
29824: LD_VAR 0 4
29828: MINUS
29829: PUSH
29830: LD_INT 0
29832: LESS
29833: IFFALSE 29845
// min_y := 0 else
29835: LD_ADDR_VAR 0 8
29839: PUSH
29840: LD_INT 0
29842: ST_TO_ADDR
29843: GO 29861
// min_y := y - r ;
29845: LD_ADDR_VAR 0 8
29849: PUSH
29850: LD_VAR 0 3
29854: PUSH
29855: LD_VAR 0 4
29859: MINUS
29860: ST_TO_ADDR
// max_x := x + r ;
29861: LD_ADDR_VAR 0 9
29865: PUSH
29866: LD_VAR 0 2
29870: PUSH
29871: LD_VAR 0 4
29875: PLUS
29876: ST_TO_ADDR
// max_y := y + r ;
29877: LD_ADDR_VAR 0 10
29881: PUSH
29882: LD_VAR 0 3
29886: PUSH
29887: LD_VAR 0 4
29891: PLUS
29892: ST_TO_ADDR
// for _x = min_x to max_x do
29893: LD_ADDR_VAR 0 11
29897: PUSH
29898: DOUBLE
29899: LD_VAR 0 7
29903: DEC
29904: ST_TO_ADDR
29905: LD_VAR 0 9
29909: PUSH
29910: FOR_TO
29911: IFFALSE 30028
// for _y = min_y to max_y do
29913: LD_ADDR_VAR 0 12
29917: PUSH
29918: DOUBLE
29919: LD_VAR 0 8
29923: DEC
29924: ST_TO_ADDR
29925: LD_VAR 0 10
29929: PUSH
29930: FOR_TO
29931: IFFALSE 30024
// begin if not ValidHex ( _x , _y ) then
29933: LD_VAR 0 11
29937: PPUSH
29938: LD_VAR 0 12
29942: PPUSH
29943: CALL_OW 488
29947: NOT
29948: IFFALSE 29952
// continue ;
29950: GO 29930
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29952: LD_VAR 0 11
29956: PPUSH
29957: LD_VAR 0 12
29961: PPUSH
29962: CALL_OW 351
29966: PUSH
29967: LD_VAR 0 11
29971: PPUSH
29972: LD_VAR 0 12
29976: PPUSH
29977: CALL_OW 554
29981: AND
29982: IFFALSE 30022
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29984: LD_ADDR_VAR 0 13
29988: PUSH
29989: LD_VAR 0 13
29993: PPUSH
29994: LD_VAR 0 13
29998: PUSH
29999: LD_INT 1
30001: PLUS
30002: PPUSH
30003: LD_VAR 0 11
30007: PUSH
30008: LD_VAR 0 12
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PPUSH
30017: CALL_OW 2
30021: ST_TO_ADDR
// end ;
30022: GO 29930
30024: POP
30025: POP
30026: GO 29910
30028: POP
30029: POP
// if not list then
30030: LD_VAR 0 13
30034: NOT
30035: IFFALSE 30039
// exit ;
30037: GO 30110
// for i in list do
30039: LD_ADDR_VAR 0 6
30043: PUSH
30044: LD_VAR 0 13
30048: PUSH
30049: FOR_IN
30050: IFFALSE 30108
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
30052: LD_VAR 0 1
30056: PPUSH
30057: LD_STRING M
30059: PUSH
30060: LD_VAR 0 6
30064: PUSH
30065: LD_INT 1
30067: ARRAY
30068: PUSH
30069: LD_VAR 0 6
30073: PUSH
30074: LD_INT 2
30076: ARRAY
30077: PUSH
30078: LD_INT 0
30080: PUSH
30081: LD_INT 0
30083: PUSH
30084: LD_INT 0
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: LIST
30094: LIST
30095: LIST
30096: LIST
30097: LIST
30098: PUSH
30099: EMPTY
30100: LIST
30101: PPUSH
30102: CALL_OW 447
30106: GO 30049
30108: POP
30109: POP
// end ;
30110: LD_VAR 0 5
30114: RET
