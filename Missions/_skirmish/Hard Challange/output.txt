// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// debug := 0 ;
  21: LD_ADDR_EXP 1
  25: PUSH
  26: LD_INT 0
  28: ST_TO_ADDR
// if debug then
  29: LD_EXP 1
  33: IFFALSE 55
// begin display_strings := Debug mode active! ;
  35: LD_ADDR_OWVAR 47
  39: PUSH
  40: LD_STRING Debug mode active!
  42: ST_TO_ADDR
// Your_Side := 1 ;
  43: LD_ADDR_OWVAR 2
  47: PUSH
  48: LD_INT 1
  50: ST_TO_ADDR
// TurnFogOff ;
  51: CALL_OW 537
// end ; Difficulty := GetMultiplayerSetting ( 0 ) ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 426
  67: ST_TO_ADDR
// PrepareTigers ( tiger_area ) ;
  68: LD_INT 8
  70: PPUSH
  71: CALL 10711 0 1
// PrepareApemans ( apeman_area ) ;
  75: LD_INT 9
  77: PPUSH
  78: CALL 10841 0 1
// PrepareRussian ;
  82: CALL 102 0 0
// PrepareAmerican ;
  86: CALL 12248 0 0
// if not debug then
  90: LD_EXP 1
  94: NOT
  95: IFFALSE 101
// Action ;
  97: CALL 14477 0 0
// end ;
 101: END
// export debug ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 102: LD_INT 0
 104: PPUSH
 105: PPUSH
 106: PPUSH
 107: PPUSH
// uc_side := 3 ;
 108: LD_ADDR_OWVAR 20
 112: PUSH
 113: LD_INT 3
 115: ST_TO_ADDR
// uc_nation := nation_russian ;
 116: LD_ADDR_OWVAR 21
 120: PUSH
 121: LD_INT 3
 123: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 124: LD_ADDR_VAR 0 2
 128: PUSH
 129: LD_INT 6
 131: PUSH
 132: LD_INT 7
 134: PUSH
 135: LD_INT 8
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: PUSH
 143: LD_OWVAR 67
 147: ARRAY
 148: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 149: LD_INT 2
 151: PPUSH
 152: CALL_OW 274
 156: PPUSH
 157: LD_INT 1
 159: PPUSH
 160: LD_INT 1200
 162: PPUSH
 163: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 167: LD_INT 2
 169: PPUSH
 170: CALL_OW 274
 174: PPUSH
 175: LD_INT 2
 177: PPUSH
 178: LD_INT 600
 180: PPUSH
 181: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 185: LD_INT 33
 187: PPUSH
 188: LD_INT 4
 190: PPUSH
 191: LD_INT 3
 193: PPUSH
 194: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 198: LD_INT 37
 200: PPUSH
 201: LD_INT 3
 203: PPUSH
 204: LD_INT 3
 206: PPUSH
 207: CALL_OW 441
// ru_force := [ ] ;
 211: LD_ADDR_EXP 2
 215: PUSH
 216: EMPTY
 217: ST_TO_ADDR
// ru_group1 := [ ] ;
 218: LD_ADDR_EXP 3
 222: PUSH
 223: EMPTY
 224: ST_TO_ADDR
// ru_group2 := [ ] ;
 225: LD_ADDR_EXP 4
 229: PUSH
 230: EMPTY
 231: ST_TO_ADDR
// ru_reserve := [ ] ;
 232: LD_ADDR_EXP 8
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// ru_attack_list := [ ] ;
 239: LD_ADDR_EXP 9
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// ru_protector := [ ] ;
 246: LD_ADDR_EXP 16
 250: PUSH
 251: EMPTY
 252: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 253: LD_ADDR_EXP 5
 257: PUSH
 258: LD_INT 48
 260: PUSH
 261: LD_INT 49
 263: PUSH
 264: LD_INT 50
 266: PUSH
 267: LD_INT 20
 269: PUSH
 270: LD_INT 1
 272: PUSH
 273: LD_INT 51
 275: PUSH
 276: LD_INT 52
 278: PUSH
 279: LD_INT 69
 281: PUSH
 282: LD_INT 39
 284: PUSH
 285: LD_INT 34
 287: PUSH
 288: LD_INT 40
 290: PUSH
 291: LD_INT 53
 293: PUSH
 294: LD_INT 71
 296: PUSH
 297: LD_INT 57
 299: PUSH
 300: LD_INT 58
 302: PUSH
 303: LD_INT 44
 305: PUSH
 306: LD_INT 32
 308: PUSH
 309: LD_INT 27
 311: PUSH
 312: LD_INT 23
 314: PUSH
 315: LD_INT 33
 317: PUSH
 318: LD_INT 59
 320: PUSH
 321: LD_INT 54
 323: PUSH
 324: LD_INT 55
 326: PUSH
 327: LD_INT 56
 329: PUSH
 330: LD_INT 63
 332: PUSH
 333: LD_INT 64
 335: PUSH
 336: LD_INT 65
 338: PUSH
 339: LD_INT 30
 341: PUSH
 342: LD_INT 31
 344: PUSH
 345: LD_INT 21
 347: PUSH
 348: LD_INT 22
 350: PUSH
 351: LD_INT 25
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: LIST
 361: LIST
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 388: LD_ADDR_EXP 6
 392: PUSH
 393: LD_INT 3
 395: PPUSH
 396: LD_INT 33
 398: PPUSH
 399: CALL 8826 0 2
 403: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 404: LD_ADDR_EXP 7
 408: PUSH
 409: LD_INT 46
 411: PUSH
 412: LD_INT 45
 414: PUSH
 415: LD_INT 47
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 423: LD_ADDR_EXP 12
 427: PUSH
 428: LD_INT 33
 430: PUSH
 431: LD_INT 36
 433: PUSH
 434: LD_INT 8
 436: PUSH
 437: LD_INT 3
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: ST_TO_ADDR
// ru_buildings := [ ] ;
 446: LD_ADDR_EXP 13
 450: PUSH
 451: EMPTY
 452: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 453: LD_ADDR_EXP 10
 457: PUSH
 458: LD_INT 3
 460: PPUSH
 461: CALL 6875 0 1
 465: PUSH
 466: LD_INT 1
 468: ARRAY
 469: PPUSH
 470: CALL_OW 250
 474: PUSH
 475: LD_INT 3
 477: PPUSH
 478: CALL 6875 0 1
 482: PUSH
 483: LD_INT 1
 485: ARRAY
 486: PPUSH
 487: CALL_OW 251
 491: PUSH
 492: LD_INT 3
 494: PPUSH
 495: CALL 6875 0 1
 499: PUSH
 500: LD_INT 1
 502: ARRAY
 503: PPUSH
 504: CALL_OW 254
 508: PUSH
 509: LD_INT 3
 511: PPUSH
 512: CALL 6875 0 1
 516: PUSH
 517: LD_INT 1
 519: ARRAY
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 268
 528: PUSH
 529: LD_INT 3
 531: PPUSH
 532: CALL 6875 0 1
 536: PUSH
 537: LD_INT 1
 539: ARRAY
 540: PPUSH
 541: LD_INT 2
 543: PPUSH
 544: CALL_OW 268
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PUSH
 556: LD_INT 12
 558: PUSH
 559: LD_INT 13
 561: PUSH
 562: LD_INT 1
 564: PUSH
 565: LD_INT 11
 567: PUSH
 568: LD_INT 14
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: LIST
 575: LIST
 576: LIST
 577: PUSH
 578: EMPTY
 579: LIST
 580: LIST
 581: ST_TO_ADDR
// ru_heal_list := [ ] ;
 582: LD_ADDR_EXP 11
 586: PUSH
 587: EMPTY
 588: ST_TO_ADDR
// need_buldozer := false ;
 589: LD_ADDR_EXP 17
 593: PUSH
 594: LD_INT 0
 596: ST_TO_ADDR
// need_crane := true ;
 597: LD_ADDR_EXP 18
 601: PUSH
 602: LD_INT 1
 604: ST_TO_ADDR
// ru_spotted := false ;
 605: LD_ADDR_EXP 15
 609: PUSH
 610: LD_INT 0
 612: ST_TO_ADDR
// for i = 1 to 6 do
 613: LD_ADDR_VAR 0 3
 617: PUSH
 618: DOUBLE
 619: LD_INT 1
 621: DEC
 622: ST_TO_ADDR
 623: LD_INT 6
 625: PUSH
 626: FOR_TO
 627: IFFALSE 668
// begin PrepareHuman ( false , 4 , skill ) ;
 629: LD_INT 0
 631: PPUSH
 632: LD_INT 4
 634: PPUSH
 635: LD_VAR 0 2
 639: PPUSH
 640: CALL_OW 380
// un := CreateHuman ;
 644: LD_ADDR_VAR 0 4
 648: PUSH
 649: CALL_OW 44
 653: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 654: LD_VAR 0 4
 658: PPUSH
 659: LD_INT 3
 661: PPUSH
 662: CALL_OW 52
// end ;
 666: GO 626
 668: POP
 669: POP
// for i = 1 to 6 do
 670: LD_ADDR_VAR 0 3
 674: PUSH
 675: DOUBLE
 676: LD_INT 1
 678: DEC
 679: ST_TO_ADDR
 680: LD_INT 6
 682: PUSH
 683: FOR_TO
 684: IFFALSE 725
// begin PrepareHuman ( false , 3 , skill ) ;
 686: LD_INT 0
 688: PPUSH
 689: LD_INT 3
 691: PPUSH
 692: LD_VAR 0 2
 696: PPUSH
 697: CALL_OW 380
// un := CreateHuman ;
 701: LD_ADDR_VAR 0 4
 705: PUSH
 706: CALL_OW 44
 710: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 711: LD_VAR 0 4
 715: PPUSH
 716: LD_INT 14
 718: PPUSH
 719: CALL_OW 52
// end ;
 723: GO 683
 725: POP
 726: POP
// for i = 1 to 6 do
 727: LD_ADDR_VAR 0 3
 731: PUSH
 732: DOUBLE
 733: LD_INT 1
 735: DEC
 736: ST_TO_ADDR
 737: LD_INT 6
 739: PUSH
 740: FOR_TO
 741: IFFALSE 785
// begin PrepareHuman ( false , 2 , skill ) ;
 743: LD_INT 0
 745: PPUSH
 746: LD_INT 2
 748: PPUSH
 749: LD_VAR 0 2
 753: PPUSH
 754: CALL_OW 380
// un := CreateHuman ;
 758: LD_ADDR_VAR 0 4
 762: PUSH
 763: CALL_OW 44
 767: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 768: LD_VAR 0 4
 772: PPUSH
 773: LD_INT 1
 775: PPUSH
 776: LD_INT 0
 778: PPUSH
 779: CALL_OW 49
// end ;
 783: GO 740
 785: POP
 786: POP
// for i = 1 to 6 do
 787: LD_ADDR_VAR 0 3
 791: PUSH
 792: DOUBLE
 793: LD_INT 1
 795: DEC
 796: ST_TO_ADDR
 797: LD_INT 6
 799: PUSH
 800: FOR_TO
 801: IFFALSE 879
// begin PrepareHuman ( false , 1 , skill ) ;
 803: LD_INT 0
 805: PPUSH
 806: LD_INT 1
 808: PPUSH
 809: LD_VAR 0 2
 813: PPUSH
 814: CALL_OW 380
// un := CreateHuman ;
 818: LD_ADDR_VAR 0 4
 822: PUSH
 823: CALL_OW 44
 827: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 828: LD_VAR 0 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 0
 838: PPUSH
 839: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 843: LD_VAR 0 4
 847: PPUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 5
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PPUSH
 858: CALL_OW 69
 862: PPUSH
 863: LD_VAR 0 4
 867: PPUSH
 868: CALL_OW 74
 872: PPUSH
 873: CALL_OW 120
// end ;
 877: GO 800
 879: POP
 880: POP
// for i = 1 to Difficulty do
 881: LD_ADDR_VAR 0 3
 885: PUSH
 886: DOUBLE
 887: LD_INT 1
 889: DEC
 890: ST_TO_ADDR
 891: LD_OWVAR 67
 895: PUSH
 896: FOR_TO
 897: IFFALSE 1008
// begin vc_chassis := ru_medium_tracked ;
 899: LD_ADDR_OWVAR 37
 903: PUSH
 904: LD_INT 22
 906: ST_TO_ADDR
// vc_engine := engine_siberite ;
 907: LD_ADDR_OWVAR 39
 911: PUSH
 912: LD_INT 3
 914: ST_TO_ADDR
// vc_control := control_computer ;
 915: LD_ADDR_OWVAR 38
 919: PUSH
 920: LD_INT 3
 922: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 923: LD_ADDR_OWVAR 40
 927: PUSH
 928: LD_INT 43
 930: PUSH
 931: LD_INT 45
 933: PUSH
 934: EMPTY
 935: LIST
 936: LIST
 937: PUSH
 938: LD_VAR 0 3
 942: PUSH
 943: LD_INT 2
 945: MOD
 946: PUSH
 947: LD_INT 1
 949: PLUS
 950: ARRAY
 951: ST_TO_ADDR
// un := CreateVehicle ;
 952: LD_ADDR_VAR 0 4
 956: PUSH
 957: CALL_OW 45
 961: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
 962: LD_VAR 0 4
 966: PPUSH
 967: LD_INT 52
 969: PPUSH
 970: LD_INT 42
 972: PPUSH
 973: LD_INT 6
 975: PPUSH
 976: LD_INT 0
 978: PPUSH
 979: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
 983: LD_ADDR_EXP 16
 987: PUSH
 988: LD_EXP 16
 992: PPUSH
 993: LD_INT 1
 995: PPUSH
 996: LD_VAR 0 4
1000: PPUSH
1001: CALL_OW 2
1005: ST_TO_ADDR
// end ;
1006: GO 896
1008: POP
1009: POP
// end ;
1010: LD_VAR 0 1
1014: RET
// every 150 150$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1015: LD_OWVAR 67
1019: PUSH
1020: LD_INT 2
1022: EQUAL
1023: PUSH
1024: LD_INT 3
1026: PPUSH
1027: LD_INT 3
1029: PPUSH
1030: CALL 6724 0 2
1034: AND
1035: IFFALSE 1071
1037: GO 1039
1039: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1040: LD_INT 3
1042: PPUSH
1043: LD_INT 3
1045: PPUSH
1046: CALL 6724 0 2
1050: PUSH
1051: LD_INT 1
1053: ARRAY
1054: PPUSH
1055: LD_INT 24
1057: PPUSH
1058: LD_INT 1
1060: PPUSH
1061: LD_INT 3
1063: PPUSH
1064: LD_INT 48
1066: PPUSH
1067: CALL 8599 0 5
1071: END
// every 120 120$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1072: LD_OWVAR 67
1076: PUSH
1077: LD_INT 3
1079: EQUAL
1080: PUSH
1081: LD_INT 3
1083: PPUSH
1084: LD_INT 3
1086: PPUSH
1087: CALL 6724 0 2
1091: AND
1092: IFFALSE 1128
1094: GO 1096
1096: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1097: LD_INT 3
1099: PPUSH
1100: LD_INT 3
1102: PPUSH
1103: CALL 6724 0 2
1107: PUSH
1108: LD_INT 1
1110: ARRAY
1111: PPUSH
1112: LD_INT 24
1114: PPUSH
1115: LD_INT 1
1117: PPUSH
1118: LD_INT 3
1120: PPUSH
1121: LD_INT 48
1123: PPUSH
1124: CALL 8599 0 5
1128: END
// every 0 0$01 trigger ru_protector do var i ;
1129: LD_EXP 16
1133: IFFALSE 1304
1135: GO 1137
1137: DISABLE
1138: LD_INT 0
1140: PPUSH
// begin enable ;
1141: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1142: LD_INT 14
1144: PPUSH
1145: LD_INT 81
1147: PUSH
1148: LD_INT 3
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: PPUSH
1155: CALL_OW 70
1159: IFFALSE 1234
// begin for i = 1 to ru_protector do
1161: LD_ADDR_VAR 0 1
1165: PUSH
1166: DOUBLE
1167: LD_INT 1
1169: DEC
1170: ST_TO_ADDR
1171: LD_EXP 16
1175: PUSH
1176: FOR_TO
1177: IFFALSE 1230
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1179: LD_EXP 16
1183: PUSH
1184: LD_VAR 0 1
1188: ARRAY
1189: PPUSH
1190: LD_INT 14
1192: PPUSH
1193: LD_INT 81
1195: PUSH
1196: LD_INT 3
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL_OW 70
1207: PPUSH
1208: LD_EXP 16
1212: PUSH
1213: LD_VAR 0 1
1217: ARRAY
1218: PPUSH
1219: CALL_OW 74
1223: PPUSH
1224: CALL_OW 115
1228: GO 1176
1230: POP
1231: POP
// end else
1232: GO 1304
// for i = 1 to ru_protector do
1234: LD_ADDR_VAR 0 1
1238: PUSH
1239: DOUBLE
1240: LD_INT 1
1242: DEC
1243: ST_TO_ADDR
1244: LD_EXP 16
1248: PUSH
1249: FOR_TO
1250: IFFALSE 1302
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1252: LD_EXP 16
1256: PUSH
1257: LD_VAR 0 1
1261: ARRAY
1262: PPUSH
1263: LD_INT 49
1265: PPUSH
1266: LD_INT 39
1268: PPUSH
1269: CALL_OW 297
1273: PUSH
1274: LD_INT 10
1276: GREATER
1277: IFFALSE 1300
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1279: LD_EXP 16
1283: PUSH
1284: LD_VAR 0 1
1288: ARRAY
1289: PPUSH
1290: LD_INT 49
1292: PPUSH
1293: LD_INT 39
1295: PPUSH
1296: CALL_OW 111
1300: GO 1249
1302: POP
1303: POP
// end ;
1304: PPOPN 1
1306: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1307: LD_OWVAR 1
1311: PUSH
1312: LD_INT 4200
1314: PUSH
1315: LD_INT 2100
1317: PUSH
1318: LD_INT 1050
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: LIST
1325: PUSH
1326: LD_OWVAR 67
1330: ARRAY
1331: GREATER
1332: IFFALSE 1345
1334: GO 1336
1336: DISABLE
// need_buldozer := true ;
1337: LD_ADDR_EXP 17
1341: PUSH
1342: LD_INT 1
1344: ST_TO_ADDR
1345: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1346: GO 1348
1348: DISABLE
// begin enable ;
1349: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1350: LD_ADDR_EXP 19
1354: PUSH
1355: LD_INT 22
1357: PUSH
1358: LD_INT 3
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: PUSH
1365: LD_INT 25
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PPUSH
1379: CALL_OW 69
1383: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1384: LD_ADDR_EXP 20
1388: PUSH
1389: LD_INT 22
1391: PUSH
1392: LD_INT 3
1394: PUSH
1395: EMPTY
1396: LIST
1397: LIST
1398: PUSH
1399: LD_INT 25
1401: PUSH
1402: LD_INT 2
1404: PUSH
1405: EMPTY
1406: LIST
1407: LIST
1408: PUSH
1409: EMPTY
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL_OW 69
1417: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1418: LD_ADDR_EXP 21
1422: PUSH
1423: LD_INT 22
1425: PUSH
1426: LD_INT 3
1428: PUSH
1429: EMPTY
1430: LIST
1431: LIST
1432: PUSH
1433: LD_INT 25
1435: PUSH
1436: LD_INT 3
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: PPUSH
1447: CALL_OW 69
1451: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1452: LD_ADDR_EXP 22
1456: PUSH
1457: LD_INT 22
1459: PUSH
1460: LD_INT 3
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: PUSH
1467: LD_INT 25
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: EMPTY
1474: LIST
1475: LIST
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: PPUSH
1481: CALL_OW 69
1485: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1486: LD_ADDR_EXP 23
1490: PUSH
1491: LD_INT 22
1493: PUSH
1494: LD_INT 3
1496: PUSH
1497: EMPTY
1498: LIST
1499: LIST
1500: PUSH
1501: LD_INT 25
1503: PUSH
1504: LD_INT 9
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: PPUSH
1515: CALL_OW 69
1519: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1520: LD_ADDR_EXP 24
1524: PUSH
1525: LD_INT 2
1527: PPUSH
1528: LD_INT 22
1530: PUSH
1531: LD_INT 3
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: PUSH
1538: LD_INT 21
1540: PUSH
1541: LD_INT 1
1543: PUSH
1544: EMPTY
1545: LIST
1546: LIST
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: PPUSH
1552: CALL_OW 70
1556: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1557: LD_ADDR_EXP 25
1561: PUSH
1562: LD_INT 34
1564: PUSH
1565: LD_INT 53
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PPUSH
1572: CALL_OW 69
1576: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1577: LD_ADDR_EXP 26
1581: PUSH
1582: LD_INT 34
1584: PUSH
1585: LD_INT 52
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: PPUSH
1592: CALL_OW 69
1596: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1597: LD_ADDR_EXP 27
1601: PUSH
1602: LD_INT 34
1604: PUSH
1605: LD_INT 51
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PPUSH
1612: CALL_OW 69
1616: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1617: LD_ADDR_EXP 13
1621: PUSH
1622: LD_INT 3
1624: PPUSH
1625: LD_INT 1
1627: NEG
1628: PPUSH
1629: CALL 11229 0 2
1633: ST_TO_ADDR
// end ;
1634: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1635: LD_INT 22
1637: PUSH
1638: LD_INT 3
1640: PUSH
1641: EMPTY
1642: LIST
1643: LIST
1644: PPUSH
1645: CALL_OW 69
1649: PUSH
1650: LD_EXP 28
1654: AND
1655: PUSH
1656: LD_EXP 1
1660: OR
1661: IFFALSE 5150
1663: GO 1665
1665: DISABLE
1666: LD_INT 0
1668: PPUSH
1669: PPUSH
1670: PPUSH
1671: PPUSH
1672: PPUSH
1673: PPUSH
1674: PPUSH
1675: PPUSH
1676: PPUSH
1677: PPUSH
// begin enable ;
1678: ENABLE
// for i = 1 to ru_eng do
1679: LD_ADDR_VAR 0 1
1683: PUSH
1684: DOUBLE
1685: LD_INT 1
1687: DEC
1688: ST_TO_ADDR
1689: LD_EXP 20
1693: PUSH
1694: FOR_TO
1695: IFFALSE 1758
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1697: LD_EXP 20
1701: PUSH
1702: LD_VAR 0 1
1706: ARRAY
1707: PPUSH
1708: CALL_OW 314
1712: NOT
1713: PUSH
1714: LD_EXP 20
1718: PUSH
1719: LD_VAR 0 1
1723: ARRAY
1724: PPUSH
1725: CALL_OW 310
1729: NOT
1730: AND
1731: IFFALSE 1756
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1733: LD_EXP 20
1737: PUSH
1738: LD_VAR 0 1
1742: ARRAY
1743: PPUSH
1744: LD_INT 3
1746: PPUSH
1747: CALL 6633 0 1
1751: PPUSH
1752: CALL_OW 120
1756: GO 1694
1758: POP
1759: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1760: LD_INT 2
1762: PPUSH
1763: LD_INT 22
1765: PUSH
1766: LD_INT 3
1768: PUSH
1769: EMPTY
1770: LIST
1771: LIST
1772: PUSH
1773: LD_INT 21
1775: PUSH
1776: LD_INT 3
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 3
1785: PUSH
1786: LD_INT 24
1788: PUSH
1789: LD_INT 1000
1791: PUSH
1792: EMPTY
1793: LIST
1794: LIST
1795: PUSH
1796: EMPTY
1797: LIST
1798: LIST
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL_OW 70
1809: IFFALSE 1976
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1811: LD_ADDR_VAR 0 4
1815: PUSH
1816: LD_INT 2
1818: PPUSH
1819: LD_INT 22
1821: PUSH
1822: LD_INT 3
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: PUSH
1829: LD_INT 21
1831: PUSH
1832: LD_INT 3
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: PUSH
1839: LD_INT 3
1841: PUSH
1842: LD_INT 24
1844: PUSH
1845: LD_INT 1000
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: PUSH
1852: EMPTY
1853: LIST
1854: LIST
1855: PUSH
1856: EMPTY
1857: LIST
1858: LIST
1859: LIST
1860: PPUSH
1861: CALL_OW 70
1865: ST_TO_ADDR
// for i = 1 to ru_eng do
1866: LD_ADDR_VAR 0 1
1870: PUSH
1871: DOUBLE
1872: LD_INT 1
1874: DEC
1875: ST_TO_ADDR
1876: LD_EXP 20
1880: PUSH
1881: FOR_TO
1882: IFFALSE 1974
// begin if IsInUnit ( ru_eng [ i ] ) then
1884: LD_EXP 20
1888: PUSH
1889: LD_VAR 0 1
1893: ARRAY
1894: PPUSH
1895: CALL_OW 310
1899: IFFALSE 1918
// ComExitBuilding ( ru_eng [ i ] ) else
1901: LD_EXP 20
1905: PUSH
1906: LD_VAR 0 1
1910: ARRAY
1911: PPUSH
1912: CALL_OW 122
1916: GO 1972
// if not WantRepair ( ru_eng [ i ] ) then
1918: LD_EXP 20
1922: PUSH
1923: LD_VAR 0 1
1927: ARRAY
1928: PPUSH
1929: CALL 11155 0 1
1933: NOT
1934: IFFALSE 1972
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1936: LD_EXP 20
1940: PUSH
1941: LD_VAR 0 1
1945: ARRAY
1946: PPUSH
1947: LD_VAR 0 4
1951: PPUSH
1952: LD_EXP 20
1956: PUSH
1957: LD_VAR 0 1
1961: ARRAY
1962: PPUSH
1963: CALL_OW 74
1967: PPUSH
1968: CALL_OW 130
// end ;
1972: GO 1881
1974: POP
1975: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
1976: LD_OWVAR 2
1980: PPUSH
1981: LD_INT 38
1983: PPUSH
1984: LD_INT 26
1986: PPUSH
1987: CALL 5952 0 3
1991: PUSH
1992: LD_INT 0
1994: EQUAL
1995: PUSH
1996: LD_OWVAR 2
2000: PPUSH
2001: LD_INT 29
2003: PPUSH
2004: LD_INT 37
2006: PPUSH
2007: CALL 5952 0 3
2011: PUSH
2012: LD_INT 0
2014: EQUAL
2015: AND
2016: IFFALSE 2153
// begin if ru_blist > 0 then
2018: LD_EXP 12
2022: PUSH
2023: LD_INT 0
2025: GREATER
2026: IFFALSE 2153
// begin for i = 1 to ru_eng do
2028: LD_ADDR_VAR 0 1
2032: PUSH
2033: DOUBLE
2034: LD_INT 1
2036: DEC
2037: ST_TO_ADDR
2038: LD_EXP 20
2042: PUSH
2043: FOR_TO
2044: IFFALSE 2151
// if IsInUnit ( ru_eng [ i ] ) then
2046: LD_EXP 20
2050: PUSH
2051: LD_VAR 0 1
2055: ARRAY
2056: PPUSH
2057: CALL_OW 310
2061: IFFALSE 2080
// ComExitBuilding ( ru_eng [ i ] ) else
2063: LD_EXP 20
2067: PUSH
2068: LD_VAR 0 1
2072: ARRAY
2073: PPUSH
2074: CALL_OW 122
2078: GO 2149
// if not HasTask ( ru_eng [ i ] ) then
2080: LD_EXP 20
2084: PUSH
2085: LD_VAR 0 1
2089: ARRAY
2090: PPUSH
2091: CALL_OW 314
2095: NOT
2096: IFFALSE 2149
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2098: LD_EXP 20
2102: PUSH
2103: LD_VAR 0 1
2107: ARRAY
2108: PPUSH
2109: LD_EXP 12
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PPUSH
2118: LD_EXP 12
2122: PUSH
2123: LD_INT 2
2125: ARRAY
2126: PPUSH
2127: LD_EXP 12
2131: PUSH
2132: LD_INT 3
2134: ARRAY
2135: PPUSH
2136: LD_EXP 12
2140: PUSH
2141: LD_INT 4
2143: ARRAY
2144: PPUSH
2145: CALL_OW 145
2149: GO 2043
2151: POP
2152: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2153: LD_ADDR_EXP 11
2157: PUSH
2158: LD_INT 3
2160: PPUSH
2161: LD_EXP 11
2165: PPUSH
2166: LD_EXP 14
2170: PPUSH
2171: CALL 9642 0 3
2175: ST_TO_ADDR
// if debug then
2176: LD_EXP 1
2180: IFFALSE 2192
// display_strings := ru_heal_list ;
2182: LD_ADDR_OWVAR 47
2186: PUSH
2187: LD_EXP 11
2191: ST_TO_ADDR
// for i = 1 to ru_sci do
2192: LD_ADDR_VAR 0 1
2196: PUSH
2197: DOUBLE
2198: LD_INT 1
2200: DEC
2201: ST_TO_ADDR
2202: LD_EXP 22
2206: PUSH
2207: FOR_TO
2208: IFFALSE 2540
// begin if ru_heal_list then
2210: LD_EXP 11
2214: IFFALSE 2453
// begin list := ru_heal_list ;
2216: LD_ADDR_VAR 0 9
2220: PUSH
2221: LD_EXP 11
2225: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2226: LD_EXP 22
2230: PUSH
2231: LD_VAR 0 1
2235: ARRAY
2236: PPUSH
2237: CALL_OW 310
2241: IFFALSE 2258
// ComExitBuilding ( ru_sci [ i ] ) ;
2243: LD_EXP 22
2247: PUSH
2248: LD_VAR 0 1
2252: ARRAY
2253: PPUSH
2254: CALL_OW 122
// for p = 1 to list do
2258: LD_ADDR_VAR 0 5
2262: PUSH
2263: DOUBLE
2264: LD_INT 1
2266: DEC
2267: ST_TO_ADDR
2268: LD_VAR 0 9
2272: PUSH
2273: FOR_TO
2274: IFFALSE 2449
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2276: LD_VAR 0 9
2280: PUSH
2281: LD_VAR 0 5
2285: ARRAY
2286: PPUSH
2287: CALL_OW 110
2291: PUSH
2292: LD_INT 100
2294: EQUAL
2295: PUSH
2296: LD_EXP 22
2300: PUSH
2301: LD_VAR 0 1
2305: ARRAY
2306: PPUSH
2307: LD_INT 100
2309: PPUSH
2310: CALL 10002 0 2
2314: NOT
2315: AND
2316: IFFALSE 2344
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2318: LD_EXP 22
2322: PUSH
2323: LD_VAR 0 1
2327: ARRAY
2328: PPUSH
2329: LD_VAR 0 9
2333: PUSH
2334: LD_VAR 0 5
2338: ARRAY
2339: PPUSH
2340: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2344: LD_VAR 0 9
2348: PUSH
2349: LD_VAR 0 5
2353: ARRAY
2354: PPUSH
2355: CALL_OW 110
2359: PUSH
2360: LD_INT 100
2362: GREATER
2363: IFFALSE 2391
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2365: LD_EXP 22
2369: PUSH
2370: LD_VAR 0 1
2374: ARRAY
2375: PPUSH
2376: LD_VAR 0 9
2380: PUSH
2381: LD_VAR 0 5
2385: ARRAY
2386: PPUSH
2387: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2391: LD_VAR 0 9
2395: PUSH
2396: LD_VAR 0 5
2400: ARRAY
2401: PPUSH
2402: LD_INT 4
2404: PPUSH
2405: CALL_OW 308
2409: NOT
2410: IFFALSE 2432
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2412: LD_VAR 0 9
2416: PUSH
2417: LD_VAR 0 5
2421: ARRAY
2422: PPUSH
2423: LD_INT 4
2425: PPUSH
2426: CALL_OW 113
2430: GO 2447
// ComHold ( list [ p ] ) ;
2432: LD_VAR 0 9
2436: PUSH
2437: LD_VAR 0 5
2441: ARRAY
2442: PPUSH
2443: CALL_OW 140
// end ;
2447: GO 2273
2449: POP
2450: POP
// end else
2451: GO 2538
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2453: LD_EXP 22
2457: PUSH
2458: LD_VAR 0 1
2462: ARRAY
2463: PPUSH
2464: CALL_OW 314
2468: NOT
2469: PUSH
2470: LD_EXP 22
2474: PUSH
2475: LD_VAR 0 1
2479: ARRAY
2480: PPUSH
2481: CALL_OW 310
2485: NOT
2486: AND
2487: PUSH
2488: LD_EXP 11
2492: PUSH
2493: LD_INT 0
2495: EQUAL
2496: AND
2497: IFFALSE 2538
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2499: LD_EXP 22
2503: PUSH
2504: LD_VAR 0 1
2508: ARRAY
2509: PPUSH
2510: LD_INT 3
2512: PPUSH
2513: CALL 6875 0 1
2517: PPUSH
2518: LD_EXP 22
2522: PUSH
2523: LD_VAR 0 1
2527: ARRAY
2528: PPUSH
2529: CALL_OW 74
2533: PPUSH
2534: CALL_OW 120
// end ;
2538: GO 2207
2540: POP
2541: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2542: LD_INT 3
2544: PPUSH
2545: LD_EXP 5
2549: PPUSH
2550: CALL 7016 0 2
2554: IFFALSE 2568
// ResearchTechList ( 3 , ru_tech_list ) ;
2556: LD_INT 3
2558: PPUSH
2559: LD_EXP 5
2563: PPUSH
2564: CALL 7091 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2568: LD_EXP 20
2572: PPUSH
2573: LD_EXP 10
2577: PPUSH
2578: CALL 8998 0 2
// lab := GetLabs ( 3 ) ;
2582: LD_ADDR_VAR 0 8
2586: PUSH
2587: LD_INT 3
2589: PPUSH
2590: CALL 6875 0 1
2594: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2595: LD_VAR 0 8
2599: PUSH
2600: LD_EXP 11
2604: PUSH
2605: LD_INT 0
2607: EQUAL
2608: AND
2609: IFFALSE 2736
// for i = 1 to lab do
2611: LD_ADDR_VAR 0 1
2615: PUSH
2616: DOUBLE
2617: LD_INT 1
2619: DEC
2620: ST_TO_ADDR
2621: LD_VAR 0 8
2625: PUSH
2626: FOR_TO
2627: IFFALSE 2734
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2629: LD_VAR 0 8
2633: PUSH
2634: LD_VAR 0 1
2638: ARRAY
2639: PPUSH
2640: CALL_OW 461
2644: PUSH
2645: LD_INT 6
2647: EQUAL
2648: IFFALSE 2732
// begin for p = 1 to ru_sci do
2650: LD_ADDR_VAR 0 5
2654: PUSH
2655: DOUBLE
2656: LD_INT 1
2658: DEC
2659: ST_TO_ADDR
2660: LD_EXP 22
2664: PUSH
2665: FOR_TO
2666: IFFALSE 2730
// if IsInUnit ( ru_sci [ p ] ) then
2668: LD_EXP 22
2672: PUSH
2673: LD_VAR 0 5
2677: ARRAY
2678: PPUSH
2679: CALL_OW 310
2683: IFFALSE 2702
// ComExitBuilding ( ru_sci [ p ] ) else
2685: LD_EXP 22
2689: PUSH
2690: LD_VAR 0 5
2694: ARRAY
2695: PPUSH
2696: CALL_OW 122
2700: GO 2728
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2702: LD_EXP 22
2706: PUSH
2707: LD_VAR 0 5
2711: ARRAY
2712: PPUSH
2713: LD_VAR 0 8
2717: PUSH
2718: LD_VAR 0 1
2722: ARRAY
2723: PPUSH
2724: CALL_OW 120
2728: GO 2665
2730: POP
2731: POP
// end ;
2732: GO 2626
2734: POP
2735: POP
// if GetTowers ( 3 ) < 5 then
2736: LD_INT 3
2738: PPUSH
2739: CALL 7430 0 1
2743: PUSH
2744: LD_INT 5
2746: LESS
2747: IFFALSE 2765
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2749: LD_EXP 20
2753: PPUSH
2754: LD_EXP 6
2758: PPUSH
2759: CALL 8038 0 2
2763: GO 2777
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2765: LD_INT 3
2767: PPUSH
2768: LD_EXP 7
2772: PPUSH
2773: CALL 8329 0 2
// if GetBuilding ( 3 , b_factory ) then
2777: LD_INT 3
2779: PPUSH
2780: LD_INT 3
2782: PPUSH
2783: CALL 6724 0 2
2787: IFFALSE 3057
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2789: LD_INT 3
2791: PPUSH
2792: LD_INT 3
2794: PPUSH
2795: CALL 6724 0 2
2799: PUSH
2800: LD_INT 1
2802: ARRAY
2803: PPUSH
2804: CALL_OW 461
2808: PUSH
2809: LD_INT 2
2811: EQUAL
2812: IFFALSE 3057
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2814: LD_ADDR_VAR 0 7
2818: PUSH
2819: LD_INT 3
2821: PPUSH
2822: LD_INT 3
2824: PPUSH
2825: CALL 6724 0 2
2829: PUSH
2830: LD_INT 1
2832: ARRAY
2833: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2834: LD_INT 3
2836: PPUSH
2837: LD_INT 24
2839: PPUSH
2840: LD_INT 53
2842: PPUSH
2843: CALL 8477 0 3
2847: PUSH
2848: LD_INT 0
2850: EQUAL
2851: PUSH
2852: LD_EXP 17
2856: AND
2857: IFFALSE 2880
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2859: LD_VAR 0 7
2863: PPUSH
2864: LD_INT 24
2866: PPUSH
2867: LD_INT 1
2869: PPUSH
2870: LD_INT 1
2872: PPUSH
2873: LD_INT 53
2875: PPUSH
2876: CALL 8599 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2880: LD_INT 3
2882: PPUSH
2883: LD_INT 22
2885: PPUSH
2886: LD_INT 52
2888: PPUSH
2889: CALL 8477 0 3
2893: PUSH
2894: LD_INT 0
2896: EQUAL
2897: PUSH
2898: LD_EXP 18
2902: AND
2903: IFFALSE 2926
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2905: LD_VAR 0 7
2909: PPUSH
2910: LD_INT 22
2912: PPUSH
2913: LD_INT 1
2915: PPUSH
2916: LD_INT 3
2918: PPUSH
2919: LD_INT 52
2921: PPUSH
2922: CALL 8599 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2926: LD_INT 3
2928: PPUSH
2929: LD_INT 22
2931: PPUSH
2932: LD_INT 49
2934: PPUSH
2935: CALL 8477 0 3
2939: PUSH
2940: LD_INT 4
2942: LESS
2943: PUSH
2944: LD_INT 31
2946: PPUSH
2947: LD_INT 3
2949: PPUSH
2950: CALL_OW 321
2954: PUSH
2955: LD_INT 2
2957: EQUAL
2958: AND
2959: IFFALSE 2982
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
2961: LD_VAR 0 7
2965: PPUSH
2966: LD_INT 22
2968: PPUSH
2969: LD_INT 1
2971: PPUSH
2972: LD_INT 3
2974: PPUSH
2975: LD_INT 49
2977: PPUSH
2978: CALL 8599 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
2982: LD_EXP 8
2986: PUSH
2987: LD_INT 5
2989: PUSH
2990: LD_INT 6
2992: PUSH
2993: LD_INT 7
2995: PUSH
2996: EMPTY
2997: LIST
2998: LIST
2999: LIST
3000: PUSH
3001: LD_OWVAR 67
3005: ARRAY
3006: LESS
3007: IFFALSE 3057
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3009: LD_VAR 0 7
3013: PPUSH
3014: LD_INT 24
3016: PPUSH
3017: LD_INT 1
3019: PPUSH
3020: LD_INT 3
3022: PPUSH
3023: LD_INT 46
3025: PUSH
3026: LD_INT 45
3028: PUSH
3029: LD_INT 47
3031: PUSH
3032: LD_INT 46
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: LIST
3039: LIST
3040: PUSH
3041: LD_INT 1
3043: PPUSH
3044: LD_INT 4
3046: PPUSH
3047: CALL_OW 12
3051: ARRAY
3052: PPUSH
3053: CALL 8599 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3057: LD_INT 3
3059: PPUSH
3060: CALL 6633 0 1
3064: PPUSH
3065: CALL 6325 0 1
3069: PUSH
3070: LD_INT 1
3072: ARRAY
3073: PUSH
3074: LD_INT 250
3076: GREATER
3077: PUSH
3078: LD_INT 3
3080: PPUSH
3081: CALL 6633 0 1
3085: PPUSH
3086: CALL 6325 0 1
3090: PUSH
3091: LD_INT 3
3093: ARRAY
3094: PUSH
3095: LD_INT 50
3097: GREATER
3098: AND
3099: PUSH
3100: LD_INT 23
3102: PPUSH
3103: LD_INT 3
3105: PPUSH
3106: CALL_OW 321
3110: PUSH
3111: LD_INT 2
3113: EQUAL
3114: AND
3115: PUSH
3116: LD_INT 3
3118: PPUSH
3119: CALL 11953 0 1
3123: PUSH
3124: LD_INT 0
3126: EQUAL
3127: AND
3128: PUSH
3129: LD_INT 22
3131: PUSH
3132: LD_INT 3
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: PUSH
3139: LD_INT 34
3141: PUSH
3142: LD_INT 49
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: PUSH
3149: EMPTY
3150: LIST
3151: LIST
3152: PPUSH
3153: CALL_OW 69
3157: PUSH
3158: LD_INT 3
3160: GREATER
3161: AND
3162: PUSH
3163: LD_OWVAR 2
3167: PPUSH
3168: LD_INT 51
3170: PPUSH
3171: LD_INT 42
3173: PPUSH
3174: CALL 5952 0 3
3178: PUSH
3179: LD_INT 0
3181: EQUAL
3182: AND
3183: IFFALSE 3268
// begin for i = 1 to ru_mech do
3185: LD_ADDR_VAR 0 1
3189: PUSH
3190: DOUBLE
3191: LD_INT 1
3193: DEC
3194: ST_TO_ADDR
3195: LD_EXP 21
3199: PUSH
3200: FOR_TO
3201: IFFALSE 3266
// begin if IsInUnit ( ru_mech [ i ] ) then
3203: LD_EXP 21
3207: PUSH
3208: LD_VAR 0 1
3212: ARRAY
3213: PPUSH
3214: CALL_OW 310
3218: IFFALSE 3237
// ComExitBuilding ( ru_mech [ i ] ) else
3220: LD_EXP 21
3224: PUSH
3225: LD_VAR 0 1
3229: ARRAY
3230: PPUSH
3231: CALL_OW 122
3235: GO 3264
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3237: LD_EXP 21
3241: PUSH
3242: LD_VAR 0 1
3246: ARRAY
3247: PPUSH
3248: LD_INT 37
3250: PPUSH
3251: LD_INT 51
3253: PPUSH
3254: LD_INT 43
3256: PPUSH
3257: LD_INT 0
3259: PPUSH
3260: CALL_OW 170
// end ;
3264: GO 3200
3266: POP
3267: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3268: LD_OWVAR 1
3272: PUSH
3273: LD_INT 94500
3275: PUSH
3276: LD_INT 84000
3278: PUSH
3279: LD_INT 71400
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: LIST
3286: PUSH
3287: LD_OWVAR 67
3291: ARRAY
3292: GREATEREQUAL
3293: IFFALSE 3349
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3295: LD_OWVAR 1
3299: PUSH
3300: LD_INT 18900
3302: PUSH
3303: LD_INT 16800
3305: PUSH
3306: LD_INT 14700
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: LIST
3313: PUSH
3314: LD_OWVAR 67
3318: ARRAY
3319: MOD
3320: PUSH
3321: LD_INT 0
3323: EQUAL
3324: IFFALSE 3349
// if ru_reserve then
3326: LD_EXP 8
3330: IFFALSE 3349
// begin ru_attack_list := ru_reserve ;
3332: LD_ADDR_EXP 9
3336: PUSH
3337: LD_EXP 8
3341: ST_TO_ADDR
// ru_reserve := [ ] ;
3342: LD_ADDR_EXP 8
3346: PUSH
3347: EMPTY
3348: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3349: LD_EXP 9
3353: IFFALSE 3475
// begin for i = 1 to ru_attack_list do
3355: LD_ADDR_VAR 0 1
3359: PUSH
3360: DOUBLE
3361: LD_INT 1
3363: DEC
3364: ST_TO_ADDR
3365: LD_EXP 9
3369: PUSH
3370: FOR_TO
3371: IFFALSE 3473
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3373: LD_EXP 9
3377: PUSH
3378: LD_VAR 0 1
3382: ARRAY
3383: PPUSH
3384: CALL_OW 256
3388: PUSH
3389: LD_INT 250
3391: GREATEREQUAL
3392: PUSH
3393: LD_EXP 9
3397: PUSH
3398: LD_VAR 0 1
3402: ARRAY
3403: PPUSH
3404: CALL_OW 314
3408: NOT
3409: AND
3410: IFFALSE 3471
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3412: LD_EXP 9
3416: PUSH
3417: LD_VAR 0 1
3421: ARRAY
3422: PPUSH
3423: LD_INT 81
3425: PUSH
3426: LD_EXP 9
3430: PUSH
3431: LD_VAR 0 1
3435: ARRAY
3436: PPUSH
3437: CALL_OW 255
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: PPUSH
3446: CALL_OW 69
3450: PPUSH
3451: LD_EXP 9
3455: PUSH
3456: LD_VAR 0 1
3460: ARRAY
3461: PPUSH
3462: CALL_OW 74
3466: PPUSH
3467: CALL_OW 115
3471: GO 3370
3473: POP
3474: POP
// end ; if GetBehemoth ( 3 ) then
3475: LD_INT 3
3477: PPUSH
3478: CALL 11953 0 1
3482: IFFALSE 3776
// begin if ru_mech >= 4 then
3484: LD_EXP 21
3488: PUSH
3489: LD_INT 4
3491: GREATEREQUAL
3492: IFFALSE 3543
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3494: LD_ADDR_EXP 14
3498: PUSH
3499: LD_EXP 21
3503: PUSH
3504: LD_INT 1
3506: ARRAY
3507: PUSH
3508: LD_EXP 21
3512: PUSH
3513: LD_INT 2
3515: ARRAY
3516: PUSH
3517: LD_EXP 21
3521: PUSH
3522: LD_INT 3
3524: ARRAY
3525: PUSH
3526: LD_EXP 21
3530: PUSH
3531: LD_INT 4
3533: ARRAY
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: ST_TO_ADDR
3541: GO 3553
// ru_behemoth_mechanic := ru_mech ;
3543: LD_ADDR_EXP 14
3547: PUSH
3548: LD_EXP 21
3552: ST_TO_ADDR
// for i = 1 to ru_mech do
3553: LD_ADDR_VAR 0 1
3557: PUSH
3558: DOUBLE
3559: LD_INT 1
3561: DEC
3562: ST_TO_ADDR
3563: LD_EXP 21
3567: PUSH
3568: FOR_TO
3569: IFFALSE 3623
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3571: LD_EXP 21
3575: PUSH
3576: LD_VAR 0 1
3580: ARRAY
3581: PPUSH
3582: CALL_OW 310
3586: PUSH
3587: LD_EXP 21
3591: PUSH
3592: LD_VAR 0 1
3596: ARRAY
3597: PUSH
3598: LD_EXP 14
3602: IN
3603: AND
3604: IFFALSE 3621
// ComExitBuilding ( ru_mech [ i ] ) ;
3606: LD_EXP 21
3610: PUSH
3611: LD_VAR 0 1
3615: ARRAY
3616: PPUSH
3617: CALL_OW 122
3621: GO 3568
3623: POP
3624: POP
// if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3625: LD_INT 12
3627: PPUSH
3628: LD_INT 22
3630: PUSH
3631: LD_INT 1
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: PUSH
3638: LD_INT 21
3640: PUSH
3641: LD_INT 3
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PPUSH
3652: CALL_OW 70
3656: PUSH
3657: LD_INT 0
3659: GREATER
3660: IFFALSE 3720
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3662: LD_INT 3
3664: PPUSH
3665: CALL 11953 0 1
3669: PUSH
3670: LD_INT 1
3672: ARRAY
3673: PPUSH
3674: LD_INT 21
3676: PUSH
3677: LD_INT 2
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: PUSH
3684: LD_INT 34
3686: PUSH
3687: LD_INT 49
3689: PUSH
3690: EMPTY
3691: LIST
3692: LIST
3693: PUSH
3694: EMPTY
3695: LIST
3696: LIST
3697: PPUSH
3698: CALL_OW 69
3702: PPUSH
3703: LD_EXP 14
3707: PPUSH
3708: LD_INT 97
3710: PPUSH
3711: LD_INT 9
3713: PPUSH
3714: CALL 11450 0 5
3718: GO 3776
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3720: LD_INT 3
3722: PPUSH
3723: CALL 11953 0 1
3727: PUSH
3728: LD_INT 1
3730: ARRAY
3731: PPUSH
3732: LD_INT 21
3734: PUSH
3735: LD_INT 2
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 34
3744: PUSH
3745: LD_INT 49
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PPUSH
3756: CALL_OW 69
3760: PPUSH
3761: LD_EXP 14
3765: PPUSH
3766: LD_INT 153
3768: PPUSH
3769: LD_INT 102
3771: PPUSH
3772: CALL 11450 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3776: LD_EXP 23
3780: PUSH
3781: LD_INT 0
3783: EQUAL
3784: PUSH
3785: LD_INT 44
3787: PPUSH
3788: LD_INT 3
3790: PPUSH
3791: CALL_OW 321
3795: PUSH
3796: LD_INT 2
3798: EQUAL
3799: AND
3800: IFFALSE 3811
// ComChangeClassToBazooker ( ru_sold ) ;
3802: LD_EXP 19
3806: PPUSH
3807: CALL 10387 0 1
// if ru_bazz then
3811: LD_EXP 23
3815: IFFALSE 3829
// IntBazooka ( ru_bazz , 1 ) ;
3817: LD_EXP 23
3821: PPUSH
3822: LD_INT 1
3824: PPUSH
3825: CALL 10106 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3829: LD_INT 67
3831: PPUSH
3832: LD_INT 39
3834: PPUSH
3835: LD_INT 3
3837: PPUSH
3838: CALL_OW 440
3842: PUSH
3843: LD_INT 0
3845: EQUAL
3846: PUSH
3847: LD_INT 20
3849: PPUSH
3850: LD_INT 3
3852: PPUSH
3853: CALL_OW 321
3857: PUSH
3858: LD_INT 2
3860: EQUAL
3861: AND
3862: IFFALSE 3883
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3864: LD_EXP 22
3868: PUSH
3869: LD_INT 1
3871: ARRAY
3872: PPUSH
3873: LD_INT 67
3875: PPUSH
3876: LD_INT 39
3878: PPUSH
3879: CALL 9581 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3883: LD_INT 89
3885: PPUSH
3886: LD_INT 66
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: CALL_OW 440
3896: PUSH
3897: LD_INT 0
3899: EQUAL
3900: IFFALSE 3921
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
3902: LD_EXP 22
3906: PUSH
3907: LD_INT 1
3909: ARRAY
3910: PPUSH
3911: LD_INT 87
3913: PPUSH
3914: LD_INT 60
3916: PPUSH
3917: CALL 9581 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3921: LD_INT 104
3923: PPUSH
3924: LD_INT 94
3926: PPUSH
3927: LD_INT 3
3929: PPUSH
3930: CALL_OW 440
3934: PUSH
3935: LD_INT 0
3937: EQUAL
3938: PUSH
3939: LD_INT 20
3941: PPUSH
3942: LD_INT 3
3944: PPUSH
3945: CALL_OW 321
3949: PUSH
3950: LD_INT 2
3952: EQUAL
3953: AND
3954: IFFALSE 3975
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
3956: LD_EXP 22
3960: PUSH
3961: LD_INT 1
3963: ARRAY
3964: PPUSH
3965: LD_INT 104
3967: PPUSH
3968: LD_INT 94
3970: PPUSH
3971: CALL 9581 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
3975: LD_INT 3
3977: PPUSH
3978: LD_INT 24
3980: PPUSH
3981: LD_INT 53
3983: PPUSH
3984: CALL 8477 0 3
3988: PUSH
3989: LD_INT 1
3991: EQUAL
3992: PUSH
3993: LD_EXP 17
3997: AND
3998: IFFALSE 4139
// begin need_buldozer := false ;
4000: LD_ADDR_EXP 17
4004: PUSH
4005: LD_INT 0
4007: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4008: LD_INT 3
4010: PPUSH
4011: LD_INT 24
4013: PPUSH
4014: LD_INT 53
4016: PPUSH
4017: CALL 8477 0 3
4021: PUSH
4022: LD_INT 1
4024: ARRAY
4025: PPUSH
4026: LD_INT 67
4028: PPUSH
4029: LD_INT 39
4031: PPUSH
4032: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4036: LD_INT 3
4038: PPUSH
4039: LD_INT 24
4041: PPUSH
4042: LD_INT 53
4044: PPUSH
4045: CALL 8477 0 3
4049: PUSH
4050: LD_INT 1
4052: ARRAY
4053: PPUSH
4054: LD_INT 71
4056: PPUSH
4057: LD_INT 10
4059: PPUSH
4060: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4064: LD_INT 3
4066: PPUSH
4067: LD_INT 24
4069: PPUSH
4070: LD_INT 53
4072: PPUSH
4073: CALL 8477 0 3
4077: PUSH
4078: LD_INT 1
4080: ARRAY
4081: PPUSH
4082: LD_INT 15
4084: PPUSH
4085: CALL 6066 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4089: LD_INT 3
4091: PPUSH
4092: LD_INT 24
4094: PPUSH
4095: LD_INT 53
4097: PPUSH
4098: CALL 8477 0 3
4102: PUSH
4103: LD_INT 1
4105: ARRAY
4106: PPUSH
4107: LD_INT 350
4109: PPUSH
4110: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4114: LD_INT 3
4116: PPUSH
4117: LD_INT 24
4119: PPUSH
4120: LD_INT 53
4122: PPUSH
4123: CALL 8477 0 3
4127: PUSH
4128: LD_INT 1
4130: ARRAY
4131: PPUSH
4132: LD_INT 14
4134: PPUSH
4135: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4139: LD_INT 67
4141: PPUSH
4142: LD_INT 39
4144: PPUSH
4145: LD_INT 3
4147: PPUSH
4148: CALL_OW 440
4152: PUSH
4153: LD_INT 67
4155: PPUSH
4156: LD_INT 39
4158: PPUSH
4159: CALL_OW 428
4163: PUSH
4164: LD_INT 0
4166: EQUAL
4167: AND
4168: PUSH
4169: LD_INT 79
4171: PPUSH
4172: LD_INT 45
4174: PPUSH
4175: CALL_OW 428
4179: PPUSH
4180: CALL_OW 266
4184: PUSH
4185: LD_INT 0
4187: EQUAL
4188: AND
4189: PUSH
4190: LD_INT 1
4192: PPUSH
4193: LD_INT 79
4195: PPUSH
4196: LD_INT 45
4198: PPUSH
4199: CALL 5952 0 3
4203: PUSH
4204: LD_INT 0
4206: EQUAL
4207: AND
4208: IFFALSE 4311
// begin for i = 1 to ru_eng do
4210: LD_ADDR_VAR 0 1
4214: PUSH
4215: DOUBLE
4216: LD_INT 1
4218: DEC
4219: ST_TO_ADDR
4220: LD_EXP 20
4224: PUSH
4225: FOR_TO
4226: IFFALSE 4309
// if IsInUnit ( ru_eng [ i ] ) then
4228: LD_EXP 20
4232: PUSH
4233: LD_VAR 0 1
4237: ARRAY
4238: PPUSH
4239: CALL_OW 310
4243: IFFALSE 4262
// ComExitBuilding ( ru_eng [ i ] ) else
4245: LD_EXP 20
4249: PUSH
4250: LD_VAR 0 1
4254: ARRAY
4255: PPUSH
4256: CALL_OW 122
4260: GO 4307
// if not HasTask ( ru_eng [ i ] ) then
4262: LD_EXP 20
4266: PUSH
4267: LD_VAR 0 1
4271: ARRAY
4272: PPUSH
4273: CALL_OW 314
4277: NOT
4278: IFFALSE 4307
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4280: LD_EXP 20
4284: PUSH
4285: LD_VAR 0 1
4289: ARRAY
4290: PPUSH
4291: LD_INT 30
4293: PPUSH
4294: LD_INT 67
4296: PPUSH
4297: LD_INT 39
4299: PPUSH
4300: LD_INT 3
4302: PPUSH
4303: CALL_OW 145
4307: GO 4225
4309: POP
4310: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4311: LD_INT 1
4313: PPUSH
4314: LD_INT 79
4316: PPUSH
4317: LD_INT 45
4319: PPUSH
4320: CALL 5952 0 3
4324: PUSH
4325: LD_INT 0
4327: EQUAL
4328: IFFALSE 4524
// begin if HexInfo ( 79 , 45 ) = 0 then
4330: LD_INT 79
4332: PPUSH
4333: LD_INT 45
4335: PPUSH
4336: CALL_OW 428
4340: PUSH
4341: LD_INT 0
4343: EQUAL
4344: IFFALSE 4366
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4346: LD_EXP 20
4350: PPUSH
4351: LD_INT 79
4353: PPUSH
4354: LD_INT 45
4356: PPUSH
4357: LD_INT 3
4359: PPUSH
4360: CALL 7492 0 4
4364: GO 4524
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4366: LD_INT 89
4368: PPUSH
4369: LD_INT 66
4371: PPUSH
4372: CALL_OW 428
4376: PUSH
4377: LD_INT 0
4379: EQUAL
4380: PUSH
4381: LD_INT 89
4383: PPUSH
4384: LD_INT 66
4386: PPUSH
4387: LD_INT 3
4389: PPUSH
4390: CALL_OW 440
4394: AND
4395: IFFALSE 4524
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4397: LD_INT 79
4399: PPUSH
4400: LD_INT 45
4402: PPUSH
4403: CALL_OW 428
4407: PPUSH
4408: CALL_OW 274
4412: PPUSH
4413: LD_INT 1
4415: PPUSH
4416: LD_INT 100
4418: PPUSH
4419: CALL_OW 277
// for i = 1 to ru_eng do
4423: LD_ADDR_VAR 0 1
4427: PUSH
4428: DOUBLE
4429: LD_INT 1
4431: DEC
4432: ST_TO_ADDR
4433: LD_EXP 20
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4522
// if IsInUnit ( ru_eng [ i ] ) then
4441: LD_EXP 20
4445: PUSH
4446: LD_VAR 0 1
4450: ARRAY
4451: PPUSH
4452: CALL_OW 310
4456: IFFALSE 4475
// ComExitBuilding ( ru_eng [ i ] ) else
4458: LD_EXP 20
4462: PUSH
4463: LD_VAR 0 1
4467: ARRAY
4468: PPUSH
4469: CALL_OW 122
4473: GO 4520
// if not HasTask ( ru_eng [ i ] ) then
4475: LD_EXP 20
4479: PUSH
4480: LD_VAR 0 1
4484: ARRAY
4485: PPUSH
4486: CALL_OW 314
4490: NOT
4491: IFFALSE 4520
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4493: LD_EXP 20
4497: PUSH
4498: LD_VAR 0 1
4502: ARRAY
4503: PPUSH
4504: LD_INT 29
4506: PPUSH
4507: LD_INT 89
4509: PPUSH
4510: LD_INT 66
4512: PPUSH
4513: LD_INT 3
4515: PPUSH
4516: CALL_OW 145
4520: GO 4438
4522: POP
4523: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4524: LD_INT 3
4526: PPUSH
4527: LD_INT 29
4529: PPUSH
4530: CALL 6724 0 2
4534: PUSH
4535: LD_INT 0
4537: EQUAL
4538: PUSH
4539: LD_INT 1
4541: PPUSH
4542: LD_INT 36
4544: PPUSH
4545: LD_INT 6
4547: PPUSH
4548: CALL 5952 0 3
4552: PUSH
4553: LD_INT 0
4555: EQUAL
4556: AND
4557: PUSH
4558: LD_INT 3
4560: PPUSH
4561: CALL 6633 0 1
4565: PPUSH
4566: LD_INT 29
4568: PPUSH
4569: CALL 6209 0 2
4573: AND
4574: IFFALSE 4677
// begin for i = 1 to ru_eng do
4576: LD_ADDR_VAR 0 1
4580: PUSH
4581: DOUBLE
4582: LD_INT 1
4584: DEC
4585: ST_TO_ADDR
4586: LD_EXP 20
4590: PUSH
4591: FOR_TO
4592: IFFALSE 4675
// begin if IsInUnit ( ru_eng [ i ] ) then
4594: LD_EXP 20
4598: PUSH
4599: LD_VAR 0 1
4603: ARRAY
4604: PPUSH
4605: CALL_OW 310
4609: IFFALSE 4628
// ComExitBuilding ( ru_eng [ i ] ) else
4611: LD_EXP 20
4615: PUSH
4616: LD_VAR 0 1
4620: ARRAY
4621: PPUSH
4622: CALL_OW 122
4626: GO 4673
// if not HasTask ( ru_eng [ i ] ) then
4628: LD_EXP 20
4632: PUSH
4633: LD_VAR 0 1
4637: ARRAY
4638: PPUSH
4639: CALL_OW 314
4643: NOT
4644: IFFALSE 4673
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4646: LD_EXP 20
4650: PUSH
4651: LD_VAR 0 1
4655: ARRAY
4656: PPUSH
4657: LD_INT 29
4659: PPUSH
4660: LD_INT 33
4662: PPUSH
4663: LD_INT 4
4665: PPUSH
4666: LD_INT 0
4668: PPUSH
4669: CALL_OW 205
// end ; end ;
4673: GO 4591
4675: POP
4676: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4677: LD_EXP 20
4681: PUSH
4682: LD_INT 79
4684: PPUSH
4685: LD_INT 45
4687: PPUSH
4688: CALL_OW 428
4692: PUSH
4693: LD_INT 0
4695: GREATER
4696: AND
4697: PUSH
4698: LD_INT 79
4700: PPUSH
4701: LD_INT 45
4703: PPUSH
4704: CALL_OW 428
4708: PPUSH
4709: CALL_OW 266
4713: PUSH
4714: LD_INT 0
4716: EQUAL
4717: AND
4718: IFFALSE 4878
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4720: LD_INT 79
4722: PPUSH
4723: LD_INT 45
4725: PPUSH
4726: CALL_OW 428
4730: PPUSH
4731: CALL_OW 255
4735: PUSH
4736: LD_INT 3
4738: EQUAL
4739: PUSH
4740: LD_INT 1
4742: PPUSH
4743: LD_INT 79
4745: PPUSH
4746: LD_INT 45
4748: PPUSH
4749: CALL 5952 0 3
4753: PUSH
4754: LD_INT 0
4756: EQUAL
4757: AND
4758: PUSH
4759: LD_INT 79
4761: PPUSH
4762: LD_INT 45
4764: PPUSH
4765: CALL_OW 428
4769: PPUSH
4770: CALL_OW 274
4774: PPUSH
4775: LD_INT 3
4777: PPUSH
4778: CALL_OW 275
4782: PUSH
4783: LD_INT 10
4785: GREATEREQUAL
4786: AND
4787: IFFALSE 4878
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4789: LD_EXP 20
4793: PUSH
4794: LD_INT 1
4796: ARRAY
4797: PPUSH
4798: CALL_OW 310
4802: IFFALSE 4819
// ComExitBuilding ( ru_eng [ 1 ] ) else
4804: LD_EXP 20
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: CALL_OW 122
4817: GO 4878
// if not HasTask ( ru_eng [ 1 ] ) then
4819: LD_EXP 20
4823: PUSH
4824: LD_INT 1
4826: ARRAY
4827: PPUSH
4828: CALL_OW 314
4832: NOT
4833: IFFALSE 4878
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4835: LD_EXP 20
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 79
4846: PPUSH
4847: LD_INT 45
4849: PPUSH
4850: CALL_OW 428
4854: PPUSH
4855: LD_INT 3
4857: PPUSH
4858: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4862: LD_EXP 20
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 2
4873: PPUSH
4874: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4878: LD_EXP 20
4882: PUSH
4883: LD_INT 2
4885: GREATER
4886: PUSH
4887: LD_INT 79
4889: PPUSH
4890: LD_INT 45
4892: PPUSH
4893: CALL_OW 428
4897: PUSH
4898: LD_INT 0
4900: GREATER
4901: AND
4902: PUSH
4903: LD_INT 79
4905: PPUSH
4906: LD_INT 45
4908: PPUSH
4909: CALL_OW 428
4913: PPUSH
4914: CALL_OW 266
4918: PUSH
4919: LD_INT 0
4921: EQUAL
4922: AND
4923: IFFALSE 5083
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
4925: LD_INT 79
4927: PPUSH
4928: LD_INT 45
4930: PPUSH
4931: CALL_OW 428
4935: PPUSH
4936: CALL_OW 255
4940: PUSH
4941: LD_INT 3
4943: EQUAL
4944: PUSH
4945: LD_INT 1
4947: PPUSH
4948: LD_INT 79
4950: PPUSH
4951: LD_INT 45
4953: PPUSH
4954: CALL 5952 0 3
4958: PUSH
4959: LD_INT 0
4961: EQUAL
4962: AND
4963: PUSH
4964: LD_INT 79
4966: PPUSH
4967: LD_INT 45
4969: PPUSH
4970: CALL_OW 428
4974: PPUSH
4975: CALL_OW 274
4979: PPUSH
4980: LD_INT 1
4982: PPUSH
4983: CALL_OW 275
4987: PUSH
4988: LD_INT 20
4990: GREATER
4991: AND
4992: IFFALSE 5083
// begin if IsInUnit ( ru_eng [ 2 ] ) then
4994: LD_EXP 20
4998: PUSH
4999: LD_INT 2
5001: ARRAY
5002: PPUSH
5003: CALL_OW 310
5007: IFFALSE 5024
// ComExitBuilding ( ru_eng [ 2 ] ) else
5009: LD_EXP 20
5013: PUSH
5014: LD_INT 2
5016: ARRAY
5017: PPUSH
5018: CALL_OW 122
5022: GO 5083
// if not HasTask ( ru_eng [ 2 ] ) then
5024: LD_EXP 20
5028: PUSH
5029: LD_INT 2
5031: ARRAY
5032: PPUSH
5033: CALL_OW 314
5037: NOT
5038: IFFALSE 5083
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5040: LD_EXP 20
5044: PUSH
5045: LD_INT 2
5047: ARRAY
5048: PPUSH
5049: LD_INT 79
5051: PPUSH
5052: LD_INT 45
5054: PPUSH
5055: CALL_OW 428
5059: PPUSH
5060: LD_INT 1
5062: PPUSH
5063: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5067: LD_EXP 20
5071: PUSH
5072: LD_INT 2
5074: ARRAY
5075: PPUSH
5076: LD_INT 2
5078: PPUSH
5079: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5083: LD_INT 1
5085: PPUSH
5086: LD_INT 59
5088: PPUSH
5089: LD_INT 60
5091: PPUSH
5092: CALL 5952 0 3
5096: PUSH
5097: LD_INT 0
5099: EQUAL
5100: PUSH
5101: LD_INT 1
5103: PPUSH
5104: LD_INT 67
5106: PPUSH
5107: LD_INT 76
5109: PPUSH
5110: CALL 5952 0 3
5114: PUSH
5115: LD_INT 0
5117: EQUAL
5118: AND
5119: PUSH
5120: LD_INT 1
5122: PPUSH
5123: LD_INT 79
5125: PPUSH
5126: LD_INT 100
5128: PPUSH
5129: CALL 5952 0 3
5133: PUSH
5134: LD_INT 0
5136: EQUAL
5137: AND
5138: IFFALSE 5150
// CollectCrates ( 3 , west_crates ) ;
5140: LD_INT 3
5142: PPUSH
5143: LD_INT 13
5145: PPUSH
5146: CALL 11997 0 2
// end ;
5150: PPOPN 10
5152: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5153: LD_OWVAR 1
5157: PUSH
5158: LD_INT 111300
5160: LESSEQUAL
5161: PUSH
5162: LD_EXP 29
5166: NOT
5167: OR
5168: IFFALSE 5365
5170: GO 5172
5172: DISABLE
5173: LD_INT 0
5175: PPUSH
// begin enable ;
5176: ENABLE
// uc_nation := 3 ;
5177: LD_ADDR_OWVAR 21
5181: PUSH
5182: LD_INT 3
5184: ST_TO_ADDR
// uc_side := 3 ;
5185: LD_ADDR_OWVAR 20
5189: PUSH
5190: LD_INT 3
5192: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5193: LD_ADDR_OWVAR 37
5197: PUSH
5198: LD_INT 22
5200: ST_TO_ADDR
// vc_engine := engine_siberite ;
5201: LD_ADDR_OWVAR 39
5205: PUSH
5206: LD_INT 3
5208: ST_TO_ADDR
// vc_control := control_computer ;
5209: LD_ADDR_OWVAR 38
5213: PUSH
5214: LD_INT 3
5216: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5217: LD_ADDR_OWVAR 40
5221: PUSH
5222: LD_INT 51
5224: ST_TO_ADDR
// veh := CreateVehicle ;
5225: LD_ADDR_VAR 0 1
5229: PUSH
5230: CALL_OW 45
5234: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5235: LD_VAR 0 1
5239: PPUSH
5240: LD_INT 4
5242: PPUSH
5243: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5247: LD_VAR 0 1
5251: PPUSH
5252: LD_INT 10
5254: PPUSH
5255: LD_INT 0
5257: PPUSH
5258: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5262: LD_VAR 0 1
5266: PPUSH
5267: LD_INT 1
5269: PUSH
5270: LD_INT 2
5272: PUSH
5273: LD_INT 3
5275: PUSH
5276: LD_INT 2
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: LIST
5283: LIST
5284: PUSH
5285: LD_INT 1
5287: PPUSH
5288: LD_INT 4
5290: PPUSH
5291: CALL_OW 12
5295: ARRAY
5296: PPUSH
5297: LD_INT 100
5299: PPUSH
5300: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5304: LD_VAR 0 1
5308: PPUSH
5309: LD_INT 2
5311: PPUSH
5312: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5316: LD_VAR 0 1
5320: PPUSH
5321: LD_INT 10
5323: PPUSH
5324: CALL_OW 173
// Wait ( 0 0$10 ) ;
5328: LD_INT 350
5330: PPUSH
5331: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5335: LD_INT 35
5337: PPUSH
5338: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5342: LD_VAR 0 1
5346: PPUSH
5347: LD_INT 10
5349: PPUSH
5350: CALL_OW 308
5354: IFFALSE 5335
// RemoveUnit ( veh ) ;
5356: LD_VAR 0 1
5360: PPUSH
5361: CALL_OW 64
// end ;
5365: PPOPN 1
5367: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
5368: LD_VAR 0 1
5372: PPUSH
5373: CALL_OW 255
5377: PUSH
5378: LD_INT 3
5380: EQUAL
5381: PUSH
5382: LD_VAR 0 1
5386: PUSH
5387: LD_INT 2
5389: PUSH
5390: LD_INT 34
5392: PUSH
5393: LD_INT 46
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PUSH
5400: LD_INT 34
5402: PUSH
5403: LD_INT 47
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: PUSH
5410: LD_INT 34
5412: PUSH
5413: LD_INT 45
5415: PUSH
5416: EMPTY
5417: LIST
5418: LIST
5419: PUSH
5420: EMPTY
5421: LIST
5422: LIST
5423: LIST
5424: LIST
5425: PUSH
5426: EMPTY
5427: LIST
5428: PPUSH
5429: CALL_OW 69
5433: IN
5434: AND
5435: IFFALSE 5453
// ru_reserve := ru_reserve ^ un ;
5437: LD_ADDR_EXP 8
5441: PUSH
5442: LD_EXP 8
5446: PUSH
5447: LD_VAR 0 1
5451: ADD
5452: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
5453: LD_VAR 0 1
5457: PUSH
5458: LD_INT 22
5460: PUSH
5461: LD_INT 3
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PUSH
5468: LD_INT 34
5470: PUSH
5471: LD_INT 48
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PPUSH
5482: CALL_OW 69
5486: IN
5487: IFFALSE 5540
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
5489: LD_INT 12
5491: PPUSH
5492: LD_INT 22
5494: PUSH
5495: LD_INT 1
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 70
5506: IFFALSE 5525
// ComAttackPlace ( un , 98 , 10 ) else
5508: LD_VAR 0 1
5512: PPUSH
5513: LD_INT 98
5515: PPUSH
5516: LD_INT 10
5518: PPUSH
5519: CALL_OW 116
5523: GO 5540
// ComAttackPlace ( un , 134 , 99 ) ;
5525: LD_VAR 0 1
5529: PPUSH
5530: LD_INT 134
5532: PPUSH
5533: LD_INT 99
5535: PPUSH
5536: CALL_OW 116
// end ;
5540: PPOPN 2
5542: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
5543: LD_VAR 0 1
5547: PUSH
5548: LD_INT 22
5550: PUSH
5551: LD_INT 3
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: PUSH
5558: LD_INT 21
5560: PUSH
5561: LD_INT 3
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 69
5576: IN
5577: PUSH
5578: LD_VAR 0 1
5582: PPUSH
5583: CALL_OW 266
5587: PUSH
5588: LD_INT 0
5590: PUSH
5591: LD_INT 29
5593: PUSH
5594: LD_INT 30
5596: PUSH
5597: LD_INT 26
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: LIST
5604: LIST
5605: IN
5606: NOT
5607: AND
5608: IFFALSE 5694
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
5610: LD_ADDR_EXP 12
5614: PUSH
5615: LD_EXP 12
5619: PUSH
5620: LD_VAR 0 1
5624: PPUSH
5625: CALL_OW 266
5629: ADD
5630: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
5631: LD_ADDR_EXP 12
5635: PUSH
5636: LD_EXP 12
5640: PUSH
5641: LD_VAR 0 1
5645: PPUSH
5646: CALL_OW 250
5650: ADD
5651: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
5652: LD_ADDR_EXP 12
5656: PUSH
5657: LD_EXP 12
5661: PUSH
5662: LD_VAR 0 1
5666: PPUSH
5667: CALL_OW 251
5671: ADD
5672: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
5673: LD_ADDR_EXP 12
5677: PUSH
5678: LD_EXP 12
5682: PUSH
5683: LD_VAR 0 1
5687: PPUSH
5688: CALL_OW 254
5692: ADD
5693: ST_TO_ADDR
// end ; if un in ru_attack_list then
5694: LD_VAR 0 1
5698: PUSH
5699: LD_EXP 9
5703: IN
5704: IFFALSE 5722
// ru_attack_list := ru_attack_list diff un ;
5706: LD_ADDR_EXP 9
5710: PUSH
5711: LD_EXP 9
5715: PUSH
5716: LD_VAR 0 1
5720: DIFF
5721: ST_TO_ADDR
// if un in ru_protector then
5722: LD_VAR 0 1
5726: PUSH
5727: LD_EXP 16
5731: IN
5732: IFFALSE 5750
// ru_protector := ru_protector diff un ;
5734: LD_ADDR_EXP 16
5738: PUSH
5739: LD_EXP 16
5743: PUSH
5744: LD_VAR 0 1
5748: DIFF
5749: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
5750: LD_VAR 0 1
5754: PPUSH
5755: CALL_OW 266
5759: PUSH
5760: LD_INT 30
5762: EQUAL
5763: PUSH
5764: LD_VAR 0 1
5768: PPUSH
5769: CALL_OW 255
5773: PUSH
5774: LD_INT 1
5776: EQUAL
5777: AND
5778: IFFALSE 5788
// mine_ck := true ;
5780: LD_ADDR_EXP 34
5784: PUSH
5785: LD_INT 1
5787: ST_TO_ADDR
// end ;
5788: PPOPN 1
5790: END
// on BuildingComplete ( un ) do var i ;
5791: LD_INT 0
5793: PPUSH
// begin if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
5794: LD_VAR 0 1
5798: PPUSH
5799: CALL_OW 255
5803: PUSH
5804: LD_INT 3
5806: EQUAL
5807: PUSH
5808: LD_VAR 0 1
5812: PPUSH
5813: CALL_OW 266
5817: PUSH
5818: LD_INT 0
5820: EQUAL
5821: AND
5822: IFFALSE 5879
// begin for i = 1 to 2 do
5824: LD_ADDR_VAR 0 2
5828: PUSH
5829: DOUBLE
5830: LD_INT 1
5832: DEC
5833: ST_TO_ADDR
5834: LD_INT 2
5836: PUSH
5837: FOR_TO
5838: IFFALSE 5877
// begin ComExitBuilding ( ru_sold [ i ] ) ;
5840: LD_EXP 19
5844: PUSH
5845: LD_VAR 0 2
5849: ARRAY
5850: PPUSH
5851: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
5855: LD_EXP 19
5859: PUSH
5860: LD_VAR 0 2
5864: ARRAY
5865: PPUSH
5866: LD_VAR 0 1
5870: PPUSH
5871: CALL_OW 180
// end ;
5875: GO 5837
5877: POP
5878: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
5879: LD_VAR 0 1
5883: PPUSH
5884: CALL_OW 255
5888: PUSH
5889: LD_INT 3
5891: EQUAL
5892: PUSH
5893: LD_VAR 0 1
5897: PPUSH
5898: CALL_OW 266
5902: PUSH
5903: LD_EXP 12
5907: IN
5908: AND
5909: IFFALSE 5949
// for i = 1 to 4 do
5911: LD_ADDR_VAR 0 2
5915: PUSH
5916: DOUBLE
5917: LD_INT 1
5919: DEC
5920: ST_TO_ADDR
5921: LD_INT 4
5923: PUSH
5924: FOR_TO
5925: IFFALSE 5947
// ru_blist := Delete ( ru_blist , 1 ) ;
5927: LD_ADDR_EXP 12
5931: PUSH
5932: LD_EXP 12
5936: PPUSH
5937: LD_INT 1
5939: PPUSH
5940: CALL_OW 3
5944: ST_TO_ADDR
5945: GO 5924
5947: POP
5948: POP
// end ; end_of_file
5949: PPOPN 2
5951: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
5952: LD_INT 0
5954: PPUSH
5955: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
5956: LD_ADDR_VAR 0 5
5960: PUSH
5961: LD_INT 22
5963: PUSH
5964: LD_VAR 0 1
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: PPUSH
5973: CALL_OW 69
5977: PPUSH
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_VAR 0 3
5987: PPUSH
5988: CALL_OW 73
5992: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 then
5993: LD_VAR 0 5
5997: PPUSH
5998: LD_VAR 0 2
6002: PPUSH
6003: LD_VAR 0 3
6007: PPUSH
6008: CALL_OW 297
6012: PUSH
6013: LD_INT 17
6015: LESS
6016: PUSH
6017: LD_INT 2
6019: PPUSH
6020: LD_INT 22
6022: PUSH
6023: LD_VAR 0 1
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: PPUSH
6032: CALL_OW 70
6036: PUSH
6037: LD_INT 0
6039: GREATER
6040: OR
6041: IFFALSE 6053
// result := true else
6043: LD_ADDR_VAR 0 4
6047: PUSH
6048: LD_INT 1
6050: ST_TO_ADDR
6051: GO 6061
// result := false ;
6053: LD_ADDR_VAR 0 4
6057: PUSH
6058: LD_INT 0
6060: ST_TO_ADDR
// end ;
6061: LD_VAR 0 4
6065: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
6066: LD_INT 0
6068: PPUSH
6069: PPUSH
// area = ListEnvironmentArea ( area ) ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_VAR 0 2
6079: PPUSH
6080: CALL_OW 353
6084: ST_TO_ADDR
// if bulldozer > 0 then
6085: LD_VAR 0 1
6089: PUSH
6090: LD_INT 0
6092: GREATER
6093: IFFALSE 6204
// for i = 1 to area do
6095: LD_ADDR_VAR 0 4
6099: PUSH
6100: DOUBLE
6101: LD_INT 1
6103: DEC
6104: ST_TO_ADDR
6105: LD_VAR 0 2
6109: PUSH
6110: FOR_TO
6111: IFFALSE 6202
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
6113: LD_VAR 0 2
6117: PUSH
6118: LD_VAR 0 4
6122: ARRAY
6123: PUSH
6124: LD_INT 1
6126: ARRAY
6127: PPUSH
6128: LD_VAR 0 2
6132: PUSH
6133: LD_VAR 0 4
6137: ARRAY
6138: PUSH
6139: LD_INT 2
6141: ARRAY
6142: PPUSH
6143: CALL_OW 351
6147: IFFALSE 6200
// if not HasTask ( bulldozer ) then
6149: LD_VAR 0 1
6153: PPUSH
6154: CALL_OW 314
6158: NOT
6159: IFFALSE 6200
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_VAR 0 2
6170: PUSH
6171: LD_VAR 0 4
6175: ARRAY
6176: PUSH
6177: LD_INT 1
6179: ARRAY
6180: PPUSH
6181: LD_VAR 0 2
6185: PUSH
6186: LD_VAR 0 4
6190: ARRAY
6191: PUSH
6192: LD_INT 2
6194: ARRAY
6195: PPUSH
6196: CALL_OW 171
6200: GO 6110
6202: POP
6203: POP
// end ;
6204: LD_VAR 0 3
6208: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
6209: LD_INT 0
6211: PPUSH
6212: PPUSH
6213: PPUSH
// pom := GetBase ( bdepot ) ;
6214: LD_ADDR_VAR 0 4
6218: PUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 274
6228: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
6229: LD_ADDR_VAR 0 5
6233: PUSH
6234: LD_VAR 0 2
6238: PPUSH
6239: LD_VAR 0 1
6243: PPUSH
6244: CALL_OW 248
6248: PPUSH
6249: CALL_OW 450
6253: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
6254: LD_VAR 0 4
6258: PPUSH
6259: LD_INT 1
6261: PPUSH
6262: CALL_OW 275
6266: PUSH
6267: LD_VAR 0 5
6271: PUSH
6272: LD_INT 1
6274: ARRAY
6275: GREATEREQUAL
6276: PUSH
6277: LD_VAR 0 4
6281: PPUSH
6282: LD_INT 3
6284: PPUSH
6285: CALL_OW 275
6289: PUSH
6290: LD_VAR 0 5
6294: PUSH
6295: LD_INT 3
6297: ARRAY
6298: GREATEREQUAL
6299: AND
6300: IFFALSE 6312
// result := true else
6302: LD_ADDR_VAR 0 3
6306: PUSH
6307: LD_INT 1
6309: ST_TO_ADDR
6310: GO 6320
// result := false ;
6312: LD_ADDR_VAR 0 3
6316: PUSH
6317: LD_INT 0
6319: ST_TO_ADDR
// end ;
6320: LD_VAR 0 3
6324: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
6325: LD_INT 0
6327: PPUSH
6328: PPUSH
6329: PPUSH
// pom := GetBase ( bdepot ) ;
6330: LD_ADDR_VAR 0 3
6334: PUSH
6335: LD_VAR 0 1
6339: PPUSH
6340: CALL_OW 274
6344: ST_TO_ADDR
// sor := [ ] ;
6345: LD_ADDR_VAR 0 4
6349: PUSH
6350: EMPTY
6351: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
6352: LD_ADDR_VAR 0 4
6356: PUSH
6357: LD_VAR 0 4
6361: PUSH
6362: LD_VAR 0 3
6366: PPUSH
6367: LD_INT 1
6369: PPUSH
6370: CALL_OW 275
6374: ADD
6375: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
6376: LD_ADDR_VAR 0 4
6380: PUSH
6381: LD_VAR 0 4
6385: PUSH
6386: LD_VAR 0 3
6390: PPUSH
6391: LD_INT 2
6393: PPUSH
6394: CALL_OW 275
6398: ADD
6399: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
6400: LD_ADDR_VAR 0 4
6404: PUSH
6405: LD_VAR 0 4
6409: PUSH
6410: LD_VAR 0 3
6414: PPUSH
6415: LD_INT 3
6417: PPUSH
6418: CALL_OW 275
6422: ADD
6423: ST_TO_ADDR
// result := sor ;
6424: LD_ADDR_VAR 0 2
6428: PUSH
6429: LD_VAR 0 4
6433: ST_TO_ADDR
// end ;
6434: LD_VAR 0 2
6438: RET
// export function Hex ( x , y ) ; begin
6439: LD_INT 0
6441: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
6442: LD_VAR 0 1
6446: PPUSH
6447: LD_VAR 0 2
6451: PPUSH
6452: CALL_OW 488
6456: PUSH
6457: LD_VAR 0 1
6461: PPUSH
6462: LD_VAR 0 2
6466: PPUSH
6467: CALL_OW 428
6471: PUSH
6472: LD_INT 0
6474: EQUAL
6475: AND
6476: IFFALSE 6488
// result := true else
6478: LD_ADDR_VAR 0 3
6482: PUSH
6483: LD_INT 1
6485: ST_TO_ADDR
6486: GO 6496
// result := false ;
6488: LD_ADDR_VAR 0 3
6492: PUSH
6493: LD_INT 0
6495: ST_TO_ADDR
// end ;
6496: LD_VAR 0 3
6500: RET
// export function NeedBuilding ( side , btype ) ; begin
6501: LD_INT 0
6503: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
6504: LD_INT 22
6506: PUSH
6507: LD_VAR 0 1
6511: PUSH
6512: EMPTY
6513: LIST
6514: LIST
6515: PUSH
6516: LD_INT 30
6518: PUSH
6519: LD_VAR 0 2
6523: PUSH
6524: EMPTY
6525: LIST
6526: LIST
6527: PUSH
6528: LD_INT 3
6530: PUSH
6531: LD_INT 57
6533: PUSH
6534: EMPTY
6535: LIST
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PUSH
6541: EMPTY
6542: LIST
6543: LIST
6544: LIST
6545: PPUSH
6546: CALL_OW 69
6550: PUSH
6551: LD_INT 0
6553: EQUAL
6554: IFFALSE 6566
// result := true else
6556: LD_ADDR_VAR 0 3
6560: PUSH
6561: LD_INT 1
6563: ST_TO_ADDR
6564: GO 6574
// result := false ;
6566: LD_ADDR_VAR 0 3
6570: PUSH
6571: LD_INT 0
6573: ST_TO_ADDR
// end ;
6574: LD_VAR 0 3
6578: RET
// export function NeedBase ( side ) ; begin
6579: LD_INT 0
6581: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6582: LD_VAR 0 1
6586: PPUSH
6587: LD_INT 0
6589: PPUSH
6590: CALL 6501 0 2
6594: PUSH
6595: LD_VAR 0 1
6599: PPUSH
6600: LD_INT 1
6602: PPUSH
6603: CALL 6501 0 2
6607: AND
6608: IFFALSE 6620
// result := true else
6610: LD_ADDR_VAR 0 2
6614: PUSH
6615: LD_INT 1
6617: ST_TO_ADDR
6618: GO 6628
// result := false ;
6620: LD_ADDR_VAR 0 2
6624: PUSH
6625: LD_INT 0
6627: ST_TO_ADDR
// end ;
6628: LD_VAR 0 2
6632: RET
// export function MyBase ( side ) ; begin
6633: LD_INT 0
6635: PPUSH
// if not NeedBase ( side ) then
6636: LD_VAR 0 1
6640: PPUSH
6641: CALL 6579 0 1
6645: NOT
6646: IFFALSE 6711
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6648: LD_ADDR_VAR 0 2
6652: PUSH
6653: LD_INT 22
6655: PUSH
6656: LD_VAR 0 1
6660: PUSH
6661: EMPTY
6662: LIST
6663: LIST
6664: PUSH
6665: LD_INT 2
6667: PUSH
6668: LD_INT 30
6670: PUSH
6671: LD_INT 0
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: PUSH
6678: LD_INT 30
6680: PUSH
6681: LD_INT 1
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: LIST
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PUSH
6697: EMPTY
6698: LIST
6699: PPUSH
6700: CALL_OW 69
6704: PUSH
6705: LD_INT 1
6707: ARRAY
6708: ST_TO_ADDR
6709: GO 6719
// result := false ;
6711: LD_ADDR_VAR 0 2
6715: PUSH
6716: LD_INT 0
6718: ST_TO_ADDR
// end ;
6719: LD_VAR 0 2
6723: RET
// export function GetBuilding ( side , btype ) ; begin
6724: LD_INT 0
6726: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6727: LD_INT 22
6729: PUSH
6730: LD_VAR 0 1
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 30
6741: PUSH
6742: LD_VAR 0 2
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: PPUSH
6755: CALL_OW 69
6759: PUSH
6760: LD_INT 0
6762: GREATER
6763: IFFALSE 6805
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6765: LD_ADDR_VAR 0 3
6769: PUSH
6770: LD_INT 22
6772: PUSH
6773: LD_VAR 0 1
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: PUSH
6782: LD_INT 30
6784: PUSH
6785: LD_VAR 0 2
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: EMPTY
6795: LIST
6796: LIST
6797: PPUSH
6798: CALL_OW 69
6802: ST_TO_ADDR
6803: GO 6813
// result := false ;
6805: LD_ADDR_VAR 0 3
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// end ;
6813: LD_VAR 0 3
6817: RET
// export function GetCrates ( side ) ; begin
6818: LD_INT 0
6820: PPUSH
// if MyBase ( side ) then
6821: LD_VAR 0 1
6825: PPUSH
6826: CALL 6633 0 1
6830: IFFALSE 6862
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
6832: LD_ADDR_VAR 0 2
6836: PUSH
6837: LD_VAR 0 1
6841: PPUSH
6842: CALL 6633 0 1
6846: PPUSH
6847: CALL_OW 274
6851: PPUSH
6852: LD_INT 1
6854: PPUSH
6855: CALL_OW 275
6859: ST_TO_ADDR
6860: GO 6870
// result := false ;
6862: LD_ADDR_VAR 0 2
6866: PUSH
6867: LD_INT 0
6869: ST_TO_ADDR
// end ;
6870: LD_VAR 0 2
6874: RET
// export function GetLabs ( side ) ; begin
6875: LD_INT 0
6877: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6878: LD_ADDR_VAR 0 2
6882: PUSH
6883: LD_INT 22
6885: PUSH
6886: LD_VAR 0 1
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: PUSH
6895: LD_INT 2
6897: PUSH
6898: LD_INT 30
6900: PUSH
6901: LD_INT 6
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PUSH
6908: LD_INT 30
6910: PUSH
6911: LD_INT 8
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: PUSH
6918: LD_INT 30
6920: PUSH
6921: LD_INT 7
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: PPUSH
6941: CALL_OW 69
6945: ST_TO_ADDR
// end ;
6946: LD_VAR 0 2
6950: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
6951: LD_INT 0
6953: PPUSH
6954: PPUSH
6955: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
6956: LD_ADDR_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: PPUSH
6966: LD_INT 1
6968: PPUSH
6969: CALL_OW 268
6973: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
6974: LD_ADDR_VAR 0 4
6978: PUSH
6979: LD_VAR 0 1
6983: PPUSH
6984: LD_INT 2
6986: PPUSH
6987: CALL_OW 268
6991: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
6992: LD_ADDR_VAR 0 2
6996: PUSH
6997: LD_VAR 0 3
7001: PUSH
7002: LD_VAR 0 4
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: ST_TO_ADDR
// end ;
7011: LD_VAR 0 2
7015: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
7016: LD_INT 0
7018: PPUSH
7019: PPUSH
// result := false ;
7020: LD_ADDR_VAR 0 3
7024: PUSH
7025: LD_INT 0
7027: ST_TO_ADDR
// for i = 1 to tlist do
7028: LD_ADDR_VAR 0 4
7032: PUSH
7033: DOUBLE
7034: LD_INT 1
7036: DEC
7037: ST_TO_ADDR
7038: LD_VAR 0 2
7042: PUSH
7043: FOR_TO
7044: IFFALSE 7084
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7046: LD_VAR 0 2
7050: PUSH
7051: LD_VAR 0 4
7055: ARRAY
7056: PPUSH
7057: LD_VAR 0 1
7061: PPUSH
7062: CALL_OW 321
7066: PUSH
7067: LD_INT 2
7069: NONEQUAL
7070: IFFALSE 7082
// begin result := true ;
7072: LD_ADDR_VAR 0 3
7076: PUSH
7077: LD_INT 1
7079: ST_TO_ADDR
// break ;
7080: GO 7084
// end ;
7082: GO 7043
7084: POP
7085: POP
// end ;
7086: LD_VAR 0 3
7090: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
// lab := GetLabs ( side ) ;
7101: LD_ADDR_VAR 0 5
7105: PUSH
7106: LD_VAR 0 1
7110: PPUSH
7111: CALL 6875 0 1
7115: ST_TO_ADDR
// tmp := 0 ;
7116: LD_ADDR_VAR 0 7
7120: PUSH
7121: LD_INT 0
7123: ST_TO_ADDR
// list := [ ] ;
7124: LD_ADDR_VAR 0 8
7128: PUSH
7129: EMPTY
7130: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
7131: LD_ADDR_VAR 0 10
7135: PUSH
7136: LD_INT 35
7138: PUSH
7139: LD_INT 45
7141: PUSH
7142: LD_INT 46
7144: PUSH
7145: LD_INT 47
7147: PUSH
7148: LD_INT 1
7150: PUSH
7151: LD_INT 2
7153: PUSH
7154: LD_INT 48
7156: PUSH
7157: LD_INT 49
7159: PUSH
7160: LD_INT 50
7162: PUSH
7163: LD_INT 20
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: LIST
7177: ST_TO_ADDR
// for i = 1 to tlist do
7178: LD_ADDR_VAR 0 4
7182: PUSH
7183: DOUBLE
7184: LD_INT 1
7186: DEC
7187: ST_TO_ADDR
7188: LD_VAR 0 2
7192: PUSH
7193: FOR_TO
7194: IFFALSE 7246
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7196: LD_VAR 0 2
7200: PUSH
7201: LD_VAR 0 4
7205: ARRAY
7206: PPUSH
7207: LD_VAR 0 1
7211: PPUSH
7212: CALL_OW 321
7216: PUSH
7217: LD_INT 2
7219: NONEQUAL
7220: IFFALSE 7244
// list := list ^ tlist [ i ] ;
7222: LD_ADDR_VAR 0 8
7226: PUSH
7227: LD_VAR 0 8
7231: PUSH
7232: LD_VAR 0 2
7236: PUSH
7237: LD_VAR 0 4
7241: ARRAY
7242: ADD
7243: ST_TO_ADDR
7244: GO 7193
7246: POP
7247: POP
// if list then
7248: LD_VAR 0 8
7252: IFFALSE 7417
// begin for i = 1 to lab do
7254: LD_ADDR_VAR 0 4
7258: PUSH
7259: DOUBLE
7260: LD_INT 1
7262: DEC
7263: ST_TO_ADDR
7264: LD_VAR 0 5
7268: PUSH
7269: FOR_TO
7270: IFFALSE 7340
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
7272: LD_VAR 0 8
7276: PUSH
7277: LD_INT 1
7279: ARRAY
7280: PUSH
7281: LD_VAR 0 10
7285: IN
7286: PUSH
7287: LD_VAR 0 8
7291: PUSH
7292: LD_INT 1
7294: ARRAY
7295: PPUSH
7296: CALL_OW 481
7300: PUSH
7301: LD_VAR 0 5
7305: PUSH
7306: LD_VAR 0 4
7310: ARRAY
7311: PPUSH
7312: CALL 6951 0 1
7316: IN
7317: OR
7318: IFFALSE 7338
// begin mylab := lab [ i ] ;
7320: LD_ADDR_VAR 0 9
7324: PUSH
7325: LD_VAR 0 5
7329: PUSH
7330: LD_VAR 0 4
7334: ARRAY
7335: ST_TO_ADDR
// break ;
7336: GO 7340
// end ;
7338: GO 7269
7340: POP
7341: POP
// if mylab then
7342: LD_VAR 0 9
7346: IFFALSE 7407
// begin if BuildingStatus ( mylab ) = bs_idle then
7348: LD_VAR 0 9
7352: PPUSH
7353: CALL_OW 461
7357: PUSH
7358: LD_INT 2
7360: EQUAL
7361: IFFALSE 7405
// for i = 1 to list do
7363: LD_ADDR_VAR 0 4
7367: PUSH
7368: DOUBLE
7369: LD_INT 1
7371: DEC
7372: ST_TO_ADDR
7373: LD_VAR 0 8
7377: PUSH
7378: FOR_TO
7379: IFFALSE 7403
// AddComResearch ( mylab , list [ i ] ) ;
7381: LD_VAR 0 9
7385: PPUSH
7386: LD_VAR 0 8
7390: PUSH
7391: LD_VAR 0 4
7395: ARRAY
7396: PPUSH
7397: CALL_OW 184
7401: GO 7378
7403: POP
7404: POP
// end else
7405: GO 7415
// result := false ;
7407: LD_ADDR_VAR 0 3
7411: PUSH
7412: LD_INT 0
7414: ST_TO_ADDR
// end else
7415: GO 7425
// result := false ;
7417: LD_ADDR_VAR 0 3
7421: PUSH
7422: LD_INT 0
7424: ST_TO_ADDR
// end ;
7425: LD_VAR 0 3
7429: RET
// export function GetTowers ( side ) ; begin
7430: LD_INT 0
7432: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
7433: LD_ADDR_VAR 0 2
7437: PUSH
7438: LD_INT 22
7440: PUSH
7441: LD_VAR 0 1
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: LD_INT 30
7455: PUSH
7456: LD_INT 32
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 30
7465: PUSH
7466: LD_INT 33
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PPUSH
7482: CALL_OW 69
7486: ST_TO_ADDR
// end ;
7487: LD_VAR 0 2
7491: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
7492: LD_INT 0
7494: PPUSH
7495: PPUSH
// if Hex ( x , y ) then
7496: LD_VAR 0 2
7500: PPUSH
7501: LD_VAR 0 3
7505: PPUSH
7506: CALL 6439 0 2
7510: IFFALSE 7585
// for i = 1 to plist do
7512: LD_ADDR_VAR 0 6
7516: PUSH
7517: DOUBLE
7518: LD_INT 1
7520: DEC
7521: ST_TO_ADDR
7522: LD_VAR 0 1
7526: PUSH
7527: FOR_TO
7528: IFFALSE 7583
// if not HasTask ( plist [ i ] ) then
7530: LD_VAR 0 1
7534: PUSH
7535: LD_VAR 0 6
7539: ARRAY
7540: PPUSH
7541: CALL_OW 314
7545: NOT
7546: IFFALSE 7581
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
7548: LD_VAR 0 1
7552: PUSH
7553: LD_VAR 0 6
7557: ARRAY
7558: PPUSH
7559: LD_INT 0
7561: PPUSH
7562: LD_VAR 0 2
7566: PPUSH
7567: LD_VAR 0 3
7571: PPUSH
7572: LD_VAR 0 4
7576: PPUSH
7577: CALL_OW 145
7581: GO 7527
7583: POP
7584: POP
// end ;
7585: LD_VAR 0 5
7589: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7590: LD_INT 0
7592: PPUSH
7593: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7594: LD_VAR 0 2
7598: PPUSH
7599: CALL_OW 266
7603: PUSH
7604: LD_INT 0
7606: EQUAL
7607: PUSH
7608: LD_VAR 0 2
7612: PPUSH
7613: LD_INT 1
7615: PPUSH
7616: CALL 6209 0 2
7620: AND
7621: PUSH
7622: LD_VAR 0 1
7626: PUSH
7627: LD_INT 1
7629: ARRAY
7630: PPUSH
7631: CALL_OW 255
7635: PPUSH
7636: CALL_OW 345
7640: NOT
7641: AND
7642: IFFALSE 7738
// begin ComUpgrade ( bident ) ;
7644: LD_VAR 0 2
7648: PPUSH
7649: CALL_OW 146
// for i = 1 to plist do
7653: LD_ADDR_VAR 0 4
7657: PUSH
7658: DOUBLE
7659: LD_INT 1
7661: DEC
7662: ST_TO_ADDR
7663: LD_VAR 0 1
7667: PUSH
7668: FOR_TO
7669: IFFALSE 7726
// if not HasTask ( plist [ i ] ) then
7671: LD_VAR 0 1
7675: PUSH
7676: LD_VAR 0 4
7680: ARRAY
7681: PPUSH
7682: CALL_OW 314
7686: NOT
7687: IFFALSE 7724
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7689: LD_VAR 0 1
7693: PUSH
7694: LD_VAR 0 4
7698: ARRAY
7699: PPUSH
7700: LD_VAR 0 2
7704: PPUSH
7705: CALL_OW 250
7709: PPUSH
7710: LD_VAR 0 2
7714: PPUSH
7715: CALL_OW 251
7719: PPUSH
7720: CALL_OW 111
7724: GO 7668
7726: POP
7727: POP
// result := true ;
7728: LD_ADDR_VAR 0 3
7732: PUSH
7733: LD_INT 1
7735: ST_TO_ADDR
// end else
7736: GO 7746
// result := false ;
7738: LD_ADDR_VAR 0 3
7742: PUSH
7743: LD_INT 0
7745: ST_TO_ADDR
// end ;
7746: LD_VAR 0 3
7750: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7751: LD_INT 0
7753: PPUSH
7754: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7755: LD_VAR 0 1
7759: PUSH
7760: LD_INT 1
7762: ARRAY
7763: PPUSH
7764: CALL_OW 255
7768: PPUSH
7769: CALL 6818 0 1
7773: PUSH
7774: LD_INT 20
7776: GREATEREQUAL
7777: PUSH
7778: LD_VAR 0 2
7782: PPUSH
7783: LD_VAR 0 3
7787: PPUSH
7788: CALL 6439 0 2
7792: AND
7793: IFFALSE 7878
// begin for i = 1 to plist do
7795: LD_ADDR_VAR 0 6
7799: PUSH
7800: DOUBLE
7801: LD_INT 1
7803: DEC
7804: ST_TO_ADDR
7805: LD_VAR 0 1
7809: PUSH
7810: FOR_TO
7811: IFFALSE 7866
// if not HasTask ( plist [ i ] ) then
7813: LD_VAR 0 1
7817: PUSH
7818: LD_VAR 0 6
7822: ARRAY
7823: PPUSH
7824: CALL_OW 314
7828: NOT
7829: IFFALSE 7864
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7831: LD_VAR 0 1
7835: PUSH
7836: LD_VAR 0 6
7840: ARRAY
7841: PPUSH
7842: LD_INT 6
7844: PPUSH
7845: LD_VAR 0 2
7849: PPUSH
7850: LD_VAR 0 3
7854: PPUSH
7855: LD_VAR 0 4
7859: PPUSH
7860: CALL_OW 145
7864: GO 7810
7866: POP
7867: POP
// result := true ;
7868: LD_ADDR_VAR 0 5
7872: PUSH
7873: LD_INT 1
7875: ST_TO_ADDR
// end else
7876: GO 7886
// result := false ;
7878: LD_ADDR_VAR 0 5
7882: PUSH
7883: LD_INT 0
7885: ST_TO_ADDR
// end ;
7886: LD_VAR 0 5
7890: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7891: LD_INT 0
7893: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7894: LD_VAR 0 1
7898: PPUSH
7899: LD_INT 1
7901: PPUSH
7902: CALL_OW 268
7906: PUSH
7907: LD_INT 9
7909: EQUAL
7910: PUSH
7911: LD_VAR 0 1
7915: PPUSH
7916: LD_INT 2
7918: PPUSH
7919: CALL_OW 268
7923: PUSH
7924: LD_INT 9
7926: EQUAL
7927: AND
7928: IFFALSE 8025
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7930: LD_VAR 0 1
7934: PPUSH
7935: LD_VAR 0 2
7939: PPUSH
7940: CALL 6209 0 2
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: CALL 6209 0 2
7959: AND
7960: PUSH
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 461
7970: PUSH
7971: LD_INT 2
7973: EQUAL
7974: AND
7975: IFFALSE 8015
// begin ComUpgradeLab ( lab , bkind1 ) ;
7977: LD_VAR 0 1
7981: PPUSH
7982: LD_VAR 0 2
7986: PPUSH
7987: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
7991: LD_VAR 0 1
7995: PPUSH
7996: LD_VAR 0 3
8000: PPUSH
8001: CALL_OW 207
// result := true ;
8005: LD_ADDR_VAR 0 4
8009: PUSH
8010: LD_INT 1
8012: ST_TO_ADDR
// end else
8013: GO 8023
// result := false ;
8015: LD_ADDR_VAR 0 4
8019: PUSH
8020: LD_INT 0
8022: ST_TO_ADDR
// end else
8023: GO 8033
// result := false ;
8025: LD_ADDR_VAR 0 4
8029: PUSH
8030: LD_INT 0
8032: ST_TO_ADDR
// end ;
8033: LD_VAR 0 4
8037: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
8038: LD_INT 0
8040: PPUSH
8041: PPUSH
8042: PPUSH
8043: PPUSH
8044: PPUSH
// p := 1 ;
8045: LD_ADDR_VAR 0 6
8049: PUSH
8050: LD_INT 1
8052: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
8053: LD_ADDR_VAR 0 4
8057: PUSH
8058: DOUBLE
8059: LD_INT 1
8061: DEC
8062: ST_TO_ADDR
8063: LD_VAR 0 2
8067: PUSH
8068: LD_INT 4
8070: DIVREAL
8071: PUSH
8072: FOR_TO
8073: IFFALSE 8322
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
8075: LD_VAR 0 2
8079: PUSH
8080: LD_VAR 0 6
8084: PUSH
8085: LD_INT 1
8087: PLUS
8088: ARRAY
8089: PPUSH
8090: LD_VAR 0 2
8094: PUSH
8095: LD_VAR 0 6
8099: PUSH
8100: LD_INT 2
8102: PLUS
8103: ARRAY
8104: PPUSH
8105: CALL_OW 428
8109: PUSH
8110: LD_INT 0
8112: EQUAL
8113: PUSH
8114: LD_VAR 0 2
8118: PUSH
8119: LD_VAR 0 6
8123: PUSH
8124: LD_INT 1
8126: PLUS
8127: ARRAY
8128: PPUSH
8129: LD_VAR 0 2
8133: PUSH
8134: LD_VAR 0 6
8138: PUSH
8139: LD_INT 2
8141: PLUS
8142: ARRAY
8143: PPUSH
8144: CALL 6439 0 2
8148: AND
8149: PUSH
8150: LD_VAR 0 1
8154: PUSH
8155: LD_INT 1
8157: ARRAY
8158: PPUSH
8159: CALL_OW 255
8163: PPUSH
8164: CALL 6818 0 1
8168: PUSH
8169: LD_INT 20
8171: GREATEREQUAL
8172: AND
8173: IFFALSE 8290
// begin for c = 1 to plist do
8175: LD_ADDR_VAR 0 7
8179: PUSH
8180: DOUBLE
8181: LD_INT 1
8183: DEC
8184: ST_TO_ADDR
8185: LD_VAR 0 1
8189: PUSH
8190: FOR_TO
8191: IFFALSE 8284
// if not HasTask ( plist [ c ] ) then
8193: LD_VAR 0 1
8197: PUSH
8198: LD_VAR 0 7
8202: ARRAY
8203: PPUSH
8204: CALL_OW 314
8208: NOT
8209: IFFALSE 8282
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
8211: LD_VAR 0 1
8215: PUSH
8216: LD_VAR 0 7
8220: ARRAY
8221: PPUSH
8222: LD_VAR 0 2
8226: PUSH
8227: LD_VAR 0 6
8231: ARRAY
8232: PPUSH
8233: LD_VAR 0 2
8237: PUSH
8238: LD_VAR 0 6
8242: PUSH
8243: LD_INT 1
8245: PLUS
8246: ARRAY
8247: PPUSH
8248: LD_VAR 0 2
8252: PUSH
8253: LD_VAR 0 6
8257: PUSH
8258: LD_INT 2
8260: PLUS
8261: ARRAY
8262: PPUSH
8263: LD_VAR 0 2
8267: PUSH
8268: LD_VAR 0 6
8272: PUSH
8273: LD_INT 3
8275: PLUS
8276: ARRAY
8277: PPUSH
8278: CALL_OW 145
8282: GO 8190
8284: POP
8285: POP
// break ;
8286: GO 8322
// end else
8288: GO 8320
// if ( p + 4 < tlist ) then
8290: LD_VAR 0 6
8294: PUSH
8295: LD_INT 4
8297: PLUS
8298: PUSH
8299: LD_VAR 0 2
8303: LESS
8304: IFFALSE 8320
// p := p + 4 ;
8306: LD_ADDR_VAR 0 6
8310: PUSH
8311: LD_VAR 0 6
8315: PUSH
8316: LD_INT 4
8318: PLUS
8319: ST_TO_ADDR
// end ;
8320: GO 8072
8322: POP
8323: POP
// end ;
8324: LD_VAR 0 3
8328: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
8329: LD_INT 0
8331: PPUSH
8332: PPUSH
8333: PPUSH
8334: PPUSH
// tmp := GetTowers ( side ) ;
8335: LD_ADDR_VAR 0 5
8339: PUSH
8340: LD_VAR 0 1
8344: PPUSH
8345: CALL 7430 0 1
8349: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
8350: LD_ADDR_VAR 0 6
8354: PUSH
8355: LD_VAR 0 1
8359: PPUSH
8360: LD_INT 3
8362: PPUSH
8363: CALL 6724 0 2
8367: PUSH
8368: LD_INT 1
8370: ARRAY
8371: ST_TO_ADDR
// if fac then
8372: LD_VAR 0 6
8376: IFFALSE 8472
// for i = 1 to tmp do
8378: LD_ADDR_VAR 0 4
8382: PUSH
8383: DOUBLE
8384: LD_INT 1
8386: DEC
8387: ST_TO_ADDR
8388: LD_VAR 0 5
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8470
// if GetBWeapon ( tmp [ i ] ) = 0 then
8396: LD_VAR 0 5
8400: PUSH
8401: LD_VAR 0 4
8405: ARRAY
8406: PPUSH
8407: CALL_OW 269
8411: PUSH
8412: LD_INT 0
8414: EQUAL
8415: IFFALSE 8468
// begin if BuildingStatus ( fac ) = bs_idle then
8417: LD_VAR 0 6
8421: PPUSH
8422: CALL_OW 461
8426: PUSH
8427: LD_INT 2
8429: EQUAL
8430: IFFALSE 8466
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
8432: LD_VAR 0 5
8436: PUSH
8437: LD_VAR 0 4
8441: ARRAY
8442: PPUSH
8443: LD_VAR 0 2
8447: PUSH
8448: LD_INT 1
8450: PPUSH
8451: LD_VAR 0 2
8455: PPUSH
8456: CALL_OW 12
8460: ARRAY
8461: PPUSH
8462: CALL_OW 148
// break ;
8466: GO 8470
// end ;
8468: GO 8393
8470: POP
8471: POP
// end ;
8472: LD_VAR 0 3
8476: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
8477: LD_INT 0
8479: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
8480: LD_INT 22
8482: PUSH
8483: LD_VAR 0 1
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: PUSH
8492: LD_INT 34
8494: PUSH
8495: LD_VAR 0 3
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 31
8506: PUSH
8507: LD_VAR 0 2
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: LIST
8520: PUSH
8521: EMPTY
8522: LIST
8523: PPUSH
8524: CALL_OW 69
8528: IFFALSE 8586
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
8530: LD_ADDR_VAR 0 4
8534: PUSH
8535: LD_INT 22
8537: PUSH
8538: LD_VAR 0 1
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: PUSH
8547: LD_INT 34
8549: PUSH
8550: LD_VAR 0 3
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: LD_INT 31
8561: PUSH
8562: LD_VAR 0 2
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: PUSH
8571: EMPTY
8572: LIST
8573: LIST
8574: LIST
8575: PUSH
8576: EMPTY
8577: LIST
8578: PPUSH
8579: CALL_OW 69
8583: ST_TO_ADDR
8584: GO 8594
// result := false ;
8586: LD_ADDR_VAR 0 4
8590: PUSH
8591: LD_INT 0
8593: ST_TO_ADDR
// end ;
8594: LD_VAR 0 4
8598: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8599: LD_INT 0
8601: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8602: LD_VAR 0 1
8606: PPUSH
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_VAR 0 3
8616: PPUSH
8617: LD_VAR 0 4
8621: PPUSH
8622: LD_VAR 0 5
8626: PPUSH
8627: CALL_OW 448
8631: PUSH
8632: LD_VAR 0 2
8636: PPUSH
8637: LD_VAR 0 3
8641: PPUSH
8642: LD_VAR 0 4
8646: PPUSH
8647: LD_VAR 0 5
8651: PPUSH
8652: CALL_OW 449
8656: PUSH
8657: LD_INT 1
8659: ARRAY
8660: PUSH
8661: LD_VAR 0 1
8665: PPUSH
8666: CALL 6325 0 1
8670: PUSH
8671: LD_INT 1
8673: ARRAY
8674: LESSEQUAL
8675: AND
8676: PUSH
8677: LD_VAR 0 2
8681: PPUSH
8682: LD_VAR 0 3
8686: PPUSH
8687: LD_VAR 0 4
8691: PPUSH
8692: LD_VAR 0 5
8696: PPUSH
8697: CALL_OW 449
8701: PUSH
8702: LD_INT 2
8704: ARRAY
8705: PUSH
8706: LD_VAR 0 1
8710: PPUSH
8711: CALL 6325 0 1
8715: PUSH
8716: LD_INT 2
8718: ARRAY
8719: LESSEQUAL
8720: AND
8721: PUSH
8722: LD_VAR 0 2
8726: PPUSH
8727: LD_VAR 0 3
8731: PPUSH
8732: LD_VAR 0 4
8736: PPUSH
8737: LD_VAR 0 5
8741: PPUSH
8742: CALL_OW 449
8746: PUSH
8747: LD_INT 3
8749: ARRAY
8750: PUSH
8751: LD_VAR 0 1
8755: PPUSH
8756: CALL 6325 0 1
8760: PUSH
8761: LD_INT 3
8763: ARRAY
8764: LESSEQUAL
8765: AND
8766: IFFALSE 8813
// begin if debug then
8768: LD_EXP 1
8772: IFFALSE 8782
// display_strings := Factory work! ;
8774: LD_ADDR_OWVAR 47
8778: PUSH
8779: LD_STRING Factory work!
8781: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8782: LD_VAR 0 1
8786: PPUSH
8787: LD_VAR 0 2
8791: PPUSH
8792: LD_VAR 0 3
8796: PPUSH
8797: LD_VAR 0 4
8801: PPUSH
8802: LD_VAR 0 5
8806: PPUSH
8807: CALL_OW 125
// end else
8811: GO 8821
// result := false ;
8813: LD_ADDR_VAR 0 6
8817: PUSH
8818: LD_INT 0
8820: ST_TO_ADDR
// end ;
8821: LD_VAR 0 6
8825: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8826: LD_INT 0
8828: PPUSH
8829: PPUSH
8830: PPUSH
8831: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8832: LD_ADDR_VAR 0 6
8836: PUSH
8837: LD_INT 22
8839: PUSH
8840: LD_VAR 0 1
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PUSH
8849: LD_INT 30
8851: PUSH
8852: LD_VAR 0 2
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: PUSH
8861: EMPTY
8862: LIST
8863: LIST
8864: PPUSH
8865: CALL_OW 69
8869: ST_TO_ADDR
// tmp := [ ] ;
8870: LD_ADDR_VAR 0 5
8874: PUSH
8875: EMPTY
8876: ST_TO_ADDR
// for i = 1 to filter do
8877: LD_ADDR_VAR 0 4
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 6
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8981
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8895: LD_ADDR_VAR 0 5
8899: PUSH
8900: LD_VAR 0 5
8904: PUSH
8905: LD_VAR 0 6
8909: PUSH
8910: LD_VAR 0 4
8914: ARRAY
8915: PPUSH
8916: CALL_OW 266
8920: PUSH
8921: LD_VAR 0 6
8925: PUSH
8926: LD_VAR 0 4
8930: ARRAY
8931: PPUSH
8932: CALL_OW 250
8936: PUSH
8937: LD_VAR 0 6
8941: PUSH
8942: LD_VAR 0 4
8946: ARRAY
8947: PPUSH
8948: CALL_OW 251
8952: PUSH
8953: LD_VAR 0 6
8957: PUSH
8958: LD_VAR 0 4
8962: ARRAY
8963: PPUSH
8964: CALL_OW 254
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: LIST
8973: LIST
8974: PUSH
8975: EMPTY
8976: LIST
8977: ADD
8978: ST_TO_ADDR
// end ;
8979: GO 8892
8981: POP
8982: POP
// result := tmp ;
8983: LD_ADDR_VAR 0 3
8987: PUSH
8988: LD_VAR 0 5
8992: ST_TO_ADDR
// end ;
8993: LD_VAR 0 3
8997: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
8998: LD_INT 0
9000: PPUSH
9001: PPUSH
9002: PPUSH
// for i = 1 to list do
9003: LD_ADDR_VAR 0 4
9007: PUSH
9008: DOUBLE
9009: LD_INT 1
9011: DEC
9012: ST_TO_ADDR
9013: LD_VAR 0 2
9017: PUSH
9018: FOR_TO
9019: IFFALSE 9574
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
9021: LD_VAR 0 2
9025: PUSH
9026: LD_VAR 0 4
9030: ARRAY
9031: PUSH
9032: LD_INT 1
9034: ARRAY
9035: PPUSH
9036: LD_VAR 0 2
9040: PUSH
9041: LD_VAR 0 4
9045: ARRAY
9046: PUSH
9047: LD_INT 2
9049: ARRAY
9050: PPUSH
9051: CALL_OW 428
9055: PUSH
9056: LD_INT 0
9058: GREATER
9059: IFFALSE 9345
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
9061: LD_VAR 0 2
9065: PUSH
9066: LD_VAR 0 4
9070: ARRAY
9071: PUSH
9072: LD_INT 1
9074: ARRAY
9075: PPUSH
9076: LD_VAR 0 2
9080: PUSH
9081: LD_VAR 0 4
9085: ARRAY
9086: PUSH
9087: LD_INT 2
9089: ARRAY
9090: PPUSH
9091: CALL_OW 428
9095: PPUSH
9096: CALL_OW 248
9100: PUSH
9101: LD_INT 3
9103: EQUAL
9104: IFFALSE 9230
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
9106: LD_VAR 0 2
9110: PUSH
9111: LD_VAR 0 4
9115: ARRAY
9116: PUSH
9117: LD_INT 1
9119: ARRAY
9120: PPUSH
9121: LD_VAR 0 2
9125: PUSH
9126: LD_VAR 0 4
9130: ARRAY
9131: PUSH
9132: LD_INT 2
9134: ARRAY
9135: PPUSH
9136: CALL_OW 428
9140: PPUSH
9141: CALL_OW 274
9145: PPUSH
9146: LD_INT 3
9148: PPUSH
9149: CALL_OW 275
9153: PUSH
9154: LD_INT 15
9156: GREATEREQUAL
9157: IFFALSE 9228
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9159: LD_VAR 0 2
9163: PUSH
9164: LD_VAR 0 4
9168: ARRAY
9169: PUSH
9170: LD_INT 1
9172: ARRAY
9173: PPUSH
9174: LD_VAR 0 2
9178: PUSH
9179: LD_VAR 0 4
9183: ARRAY
9184: PUSH
9185: LD_INT 2
9187: ARRAY
9188: PPUSH
9189: CALL_OW 428
9193: PPUSH
9194: LD_VAR 0 2
9198: PUSH
9199: LD_VAR 0 4
9203: ARRAY
9204: PUSH
9205: LD_INT 4
9207: ARRAY
9208: PPUSH
9209: LD_VAR 0 2
9213: PUSH
9214: LD_VAR 0 4
9218: ARRAY
9219: PUSH
9220: LD_INT 5
9222: ARRAY
9223: PPUSH
9224: CALL 7891 0 3
// end else
9228: GO 9299
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9230: LD_VAR 0 2
9234: PUSH
9235: LD_VAR 0 4
9239: ARRAY
9240: PUSH
9241: LD_INT 1
9243: ARRAY
9244: PPUSH
9245: LD_VAR 0 2
9249: PUSH
9250: LD_VAR 0 4
9254: ARRAY
9255: PUSH
9256: LD_INT 2
9258: ARRAY
9259: PPUSH
9260: CALL_OW 428
9264: PPUSH
9265: LD_VAR 0 2
9269: PUSH
9270: LD_VAR 0 4
9274: ARRAY
9275: PUSH
9276: LD_INT 4
9278: ARRAY
9279: PPUSH
9280: LD_VAR 0 2
9284: PUSH
9285: LD_VAR 0 4
9289: ARRAY
9290: PUSH
9291: LD_INT 5
9293: ARRAY
9294: PPUSH
9295: CALL 7891 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
9299: LD_VAR 0 1
9303: PPUSH
9304: LD_VAR 0 2
9308: PUSH
9309: LD_VAR 0 4
9313: ARRAY
9314: PUSH
9315: LD_INT 1
9317: ARRAY
9318: PPUSH
9319: LD_VAR 0 2
9323: PUSH
9324: LD_VAR 0 4
9328: ARRAY
9329: PUSH
9330: LD_INT 2
9332: ARRAY
9333: PPUSH
9334: CALL_OW 428
9338: PPUSH
9339: CALL 10947 0 2
// end else
9343: GO 9572
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
9345: LD_VAR 0 1
9349: PUSH
9350: LD_INT 1
9352: ARRAY
9353: PPUSH
9354: CALL_OW 255
9358: PPUSH
9359: CALL 6633 0 1
9363: PPUSH
9364: LD_INT 6
9366: PPUSH
9367: CALL 6209 0 2
9371: PUSH
9372: LD_VAR 0 1
9376: PUSH
9377: LD_INT 1
9379: ARRAY
9380: PPUSH
9381: CALL_OW 255
9385: PPUSH
9386: CALL 6633 0 1
9390: PPUSH
9391: LD_VAR 0 2
9395: PUSH
9396: LD_VAR 0 4
9400: ARRAY
9401: PUSH
9402: LD_INT 4
9404: ARRAY
9405: PPUSH
9406: CALL 6209 0 2
9410: AND
9411: PUSH
9412: LD_VAR 0 1
9416: PUSH
9417: LD_INT 1
9419: ARRAY
9420: PPUSH
9421: CALL_OW 255
9425: PPUSH
9426: CALL 6633 0 1
9430: PPUSH
9431: LD_VAR 0 2
9435: PUSH
9436: LD_VAR 0 4
9440: ARRAY
9441: PUSH
9442: LD_INT 5
9444: ARRAY
9445: PPUSH
9446: CALL 6209 0 2
9450: AND
9451: IFFALSE 9572
// for p = 1 to plist do
9453: LD_ADDR_VAR 0 5
9457: PUSH
9458: DOUBLE
9459: LD_INT 1
9461: DEC
9462: ST_TO_ADDR
9463: LD_VAR 0 1
9467: PUSH
9468: FOR_TO
9469: IFFALSE 9570
// if IsInUnit ( plist [ p ] ) then
9471: LD_VAR 0 1
9475: PUSH
9476: LD_VAR 0 5
9480: ARRAY
9481: PPUSH
9482: CALL_OW 310
9486: IFFALSE 9505
// ComExitBuilding ( plist [ p ] ) else
9488: LD_VAR 0 1
9492: PUSH
9493: LD_VAR 0 5
9497: ARRAY
9498: PPUSH
9499: CALL_OW 122
9503: GO 9568
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
9505: LD_VAR 0 1
9509: PUSH
9510: LD_VAR 0 5
9514: ARRAY
9515: PPUSH
9516: LD_INT 6
9518: PPUSH
9519: LD_VAR 0 2
9523: PUSH
9524: LD_VAR 0 4
9528: ARRAY
9529: PUSH
9530: LD_INT 1
9532: ARRAY
9533: PPUSH
9534: LD_VAR 0 2
9538: PUSH
9539: LD_VAR 0 4
9543: ARRAY
9544: PUSH
9545: LD_INT 2
9547: ARRAY
9548: PPUSH
9549: LD_VAR 0 2
9553: PUSH
9554: LD_VAR 0 4
9558: ARRAY
9559: PUSH
9560: LD_INT 3
9562: ARRAY
9563: PPUSH
9564: CALL_OW 145
9568: GO 9468
9570: POP
9571: POP
// end ;
9572: GO 9018
9574: POP
9575: POP
// end ;
9576: LD_VAR 0 3
9580: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9581: LD_INT 0
9583: PPUSH
// if IsInUnit ( sci ) then
9584: LD_VAR 0 1
9588: PPUSH
9589: CALL_OW 310
9593: IFFALSE 9606
// ComExitBuilding ( sci ) else
9595: LD_VAR 0 1
9599: PPUSH
9600: CALL_OW 122
9604: GO 9637
// if not HasTask ( sci ) then
9606: LD_VAR 0 1
9610: PPUSH
9611: CALL_OW 314
9615: NOT
9616: IFFALSE 9637
// begin ComMoveXY ( sci , x , y ) ;
9618: LD_VAR 0 1
9622: PPUSH
9623: LD_VAR 0 2
9627: PPUSH
9628: LD_VAR 0 3
9632: PPUSH
9633: CALL_OW 111
// end ; end ;
9637: LD_VAR 0 4
9641: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9642: LD_INT 0
9644: PPUSH
9645: PPUSH
9646: PPUSH
9647: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9648: LD_ADDR_VAR 0 6
9652: PUSH
9653: LD_INT 22
9655: PUSH
9656: LD_VAR 0 1
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 21
9667: PUSH
9668: LD_INT 1
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: PUSH
9675: EMPTY
9676: LIST
9677: LIST
9678: PPUSH
9679: CALL_OW 69
9683: PUSH
9684: LD_VAR 0 3
9688: DIFF
9689: ST_TO_ADDR
// tmp := tag_list ;
9690: LD_ADDR_VAR 0 7
9694: PUSH
9695: LD_VAR 0 2
9699: ST_TO_ADDR
// for i = 1 to filter do
9700: LD_ADDR_VAR 0 5
9704: PUSH
9705: DOUBLE
9706: LD_INT 1
9708: DEC
9709: ST_TO_ADDR
9710: LD_VAR 0 6
9714: PUSH
9715: FOR_TO
9716: IFFALSE 9985
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9718: LD_VAR 0 6
9722: PUSH
9723: LD_VAR 0 5
9727: ARRAY
9728: PPUSH
9729: CALL_OW 256
9733: PUSH
9734: LD_INT 1000
9736: EQUAL
9737: PUSH
9738: LD_VAR 0 6
9742: PUSH
9743: LD_VAR 0 5
9747: ARRAY
9748: PPUSH
9749: CALL_OW 110
9753: PUSH
9754: LD_INT 100
9756: GREATEREQUAL
9757: AND
9758: IFFALSE 9800
// begin SetTag ( filter [ i ] , 0 ) ;
9760: LD_VAR 0 6
9764: PUSH
9765: LD_VAR 0 5
9769: ARRAY
9770: PPUSH
9771: LD_INT 0
9773: PPUSH
9774: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9778: LD_ADDR_VAR 0 7
9782: PUSH
9783: LD_VAR 0 7
9787: PUSH
9788: LD_VAR 0 6
9792: PUSH
9793: LD_VAR 0 5
9797: ARRAY
9798: DIFF
9799: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9800: LD_VAR 0 6
9804: PUSH
9805: LD_VAR 0 5
9809: ARRAY
9810: PPUSH
9811: CALL_OW 256
9815: PUSH
9816: LD_INT 1000
9818: LESS
9819: IFFALSE 9983
// begin if not filter [ i ] in tmp then
9821: LD_VAR 0 6
9825: PUSH
9826: LD_VAR 0 5
9830: ARRAY
9831: PUSH
9832: LD_VAR 0 7
9836: IN
9837: NOT
9838: IFFALSE 9862
// tmp := tmp ^ filter [ i ] ;
9840: LD_ADDR_VAR 0 7
9844: PUSH
9845: LD_VAR 0 7
9849: PUSH
9850: LD_VAR 0 6
9854: PUSH
9855: LD_VAR 0 5
9859: ARRAY
9860: ADD
9861: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9862: LD_VAR 0 6
9866: PUSH
9867: LD_VAR 0 5
9871: ARRAY
9872: PPUSH
9873: CALL_OW 256
9877: PUSH
9878: LD_INT 250
9880: LESS
9881: IFFALSE 9903
// SetTag ( filter [ i ] , 100 ) else
9883: LD_VAR 0 6
9887: PUSH
9888: LD_VAR 0 5
9892: ARRAY
9893: PPUSH
9894: LD_INT 100
9896: PPUSH
9897: CALL_OW 109
9901: GO 9983
// if GetLives ( filter [ i ] ) < 500 then
9903: LD_VAR 0 6
9907: PUSH
9908: LD_VAR 0 5
9912: ARRAY
9913: PPUSH
9914: CALL_OW 256
9918: PUSH
9919: LD_INT 500
9921: LESS
9922: IFFALSE 9944
// SetTag ( filter [ i ] , 101 ) else
9924: LD_VAR 0 6
9928: PUSH
9929: LD_VAR 0 5
9933: ARRAY
9934: PPUSH
9935: LD_INT 101
9937: PPUSH
9938: CALL_OW 109
9942: GO 9983
// if GetLives ( filter [ i ] ) < 1000 then
9944: LD_VAR 0 6
9948: PUSH
9949: LD_VAR 0 5
9953: ARRAY
9954: PPUSH
9955: CALL_OW 256
9959: PUSH
9960: LD_INT 1000
9962: LESS
9963: IFFALSE 9983
// SetTag ( filter [ i ] , 102 ) ;
9965: LD_VAR 0 6
9969: PUSH
9970: LD_VAR 0 5
9974: ARRAY
9975: PPUSH
9976: LD_INT 102
9978: PPUSH
9979: CALL_OW 109
// end ; end ;
9983: GO 9715
9985: POP
9986: POP
// result := tmp ;
9987: LD_ADDR_VAR 0 4
9991: PUSH
9992: LD_VAR 0 7
9996: ST_TO_ADDR
// end ;
9997: LD_VAR 0 4
10001: RET
// export function WantHeal ( sci , tag ) ; begin
10002: LD_INT 0
10004: PPUSH
// if GetTaskList ( sci ) > 0 then
10005: LD_VAR 0 1
10009: PPUSH
10010: CALL_OW 437
10014: PUSH
10015: LD_INT 0
10017: GREATER
10018: IFFALSE 10093
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
10020: LD_VAR 0 1
10024: PPUSH
10025: CALL_OW 437
10029: PUSH
10030: LD_INT 1
10032: ARRAY
10033: PUSH
10034: LD_INT 1
10036: ARRAY
10037: PUSH
10038: LD_STRING l
10040: EQUAL
10041: PUSH
10042: LD_VAR 0 1
10046: PPUSH
10047: CALL_OW 437
10051: PUSH
10052: LD_INT 1
10054: ARRAY
10055: PUSH
10056: LD_INT 4
10058: ARRAY
10059: PPUSH
10060: CALL_OW 110
10064: PUSH
10065: LD_VAR 0 2
10069: EQUAL
10070: AND
10071: IFFALSE 10083
// result := true else
10073: LD_ADDR_VAR 0 3
10077: PUSH
10078: LD_INT 1
10080: ST_TO_ADDR
10081: GO 10091
// result := false ;
10083: LD_ADDR_VAR 0 3
10087: PUSH
10088: LD_INT 0
10090: ST_TO_ADDR
// end else
10091: GO 10101
// result := false ;
10093: LD_ADDR_VAR 0 3
10097: PUSH
10098: LD_INT 0
10100: ST_TO_ADDR
// end ;
10101: LD_VAR 0 3
10105: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
10106: LD_INT 0
10108: PPUSH
10109: PPUSH
10110: PPUSH
10111: PPUSH
10112: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10113: LD_ADDR_VAR 0 7
10117: PUSH
10118: LD_INT 22
10120: PUSH
10121: LD_VAR 0 2
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: LD_INT 3
10132: PUSH
10133: LD_INT 21
10135: PUSH
10136: LD_INT 3
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: PPUSH
10151: CALL_OW 69
10155: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
10156: LD_ADDR_VAR 0 5
10160: PUSH
10161: LD_INT 1
10163: PPUSH
10164: LD_INT 3
10166: PPUSH
10167: CALL_OW 12
10171: ST_TO_ADDR
// if filter > 0 then
10172: LD_VAR 0 7
10176: PUSH
10177: LD_INT 0
10179: GREATER
10180: IFFALSE 10382
// for i = 1 to list do
10182: LD_ADDR_VAR 0 6
10186: PUSH
10187: DOUBLE
10188: LD_INT 1
10190: DEC
10191: ST_TO_ADDR
10192: LD_VAR 0 1
10196: PUSH
10197: FOR_TO
10198: IFFALSE 10380
// for ta in filter do
10200: LD_ADDR_VAR 0 4
10204: PUSH
10205: LD_VAR 0 7
10209: PUSH
10210: FOR_IN
10211: IFFALSE 10376
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
10213: LD_VAR 0 1
10217: PUSH
10218: LD_VAR 0 6
10222: ARRAY
10223: PPUSH
10224: LD_VAR 0 4
10228: PPUSH
10229: CALL_OW 296
10233: PUSH
10234: LD_INT 13
10236: LESSEQUAL
10237: IFFALSE 10374
// begin case c of 1 :
10239: LD_VAR 0 5
10243: PUSH
10244: LD_INT 1
10246: DOUBLE
10247: EQUAL
10248: IFTRUE 10252
10250: GO 10290
10252: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
10253: LD_VAR 0 1
10257: PUSH
10258: LD_VAR 0 6
10262: ARRAY
10263: PPUSH
10264: LD_VAR 0 4
10268: PPUSH
10269: CALL_OW 250
10273: PPUSH
10274: LD_VAR 0 4
10278: PPUSH
10279: CALL_OW 251
10283: PPUSH
10284: CALL_OW 154
10288: GO 10374
10290: LD_INT 2
10292: DOUBLE
10293: EQUAL
10294: IFTRUE 10298
10296: GO 10362
10298: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
10299: LD_VAR 0 1
10303: PUSH
10304: LD_VAR 0 6
10308: ARRAY
10309: PPUSH
10310: LD_VAR 0 4
10314: PPUSH
10315: CALL_OW 250
10319: PUSH
10320: LD_INT 1
10322: NEG
10323: PPUSH
10324: LD_INT 1
10326: PPUSH
10327: CALL_OW 12
10331: PLUS
10332: PPUSH
10333: LD_VAR 0 4
10337: PPUSH
10338: CALL_OW 251
10342: PUSH
10343: LD_INT 1
10345: NEG
10346: PPUSH
10347: LD_INT 1
10349: PPUSH
10350: CALL_OW 12
10354: PLUS
10355: PPUSH
10356: CALL_OW 153
10360: GO 10374
10362: LD_INT 3
10364: DOUBLE
10365: EQUAL
10366: IFTRUE 10370
10368: GO 10373
10370: POP
// ; end ;
10371: GO 10374
10373: POP
// end ; end ;
10374: GO 10210
10376: POP
10377: POP
10378: GO 10197
10380: POP
10381: POP
// end ;
10382: LD_VAR 0 3
10386: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
10387: LD_INT 0
10389: PPUSH
10390: PPUSH
// for i = 1 to plist do
10391: LD_ADDR_VAR 0 3
10395: PUSH
10396: DOUBLE
10397: LD_INT 1
10399: DEC
10400: ST_TO_ADDR
10401: LD_VAR 0 1
10405: PUSH
10406: FOR_TO
10407: IFFALSE 10609
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
10409: LD_VAR 0 1
10413: PUSH
10414: LD_VAR 0 3
10418: ARRAY
10419: PPUSH
10420: CALL_OW 310
10424: PUSH
10425: LD_INT 30
10427: PUSH
10428: LD_INT 5
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: PUSH
10435: EMPTY
10436: LIST
10437: PPUSH
10438: CALL_OW 69
10442: IN
10443: NOT
10444: IFFALSE 10589
// begin if IsInUnit ( plist [ i ] ) then
10446: LD_VAR 0 1
10450: PUSH
10451: LD_VAR 0 3
10455: ARRAY
10456: PPUSH
10457: CALL_OW 310
10461: IFFALSE 10480
// ComExitBuilding ( plist [ i ] ) else
10463: LD_VAR 0 1
10467: PUSH
10468: LD_VAR 0 3
10472: ARRAY
10473: PPUSH
10474: CALL_OW 122
10478: GO 10587
// if not HasTask ( plist [ i ] ) then
10480: LD_VAR 0 1
10484: PUSH
10485: LD_VAR 0 3
10489: ARRAY
10490: PPUSH
10491: CALL_OW 314
10495: NOT
10496: IFFALSE 10587
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
10498: LD_VAR 0 1
10502: PUSH
10503: LD_VAR 0 3
10507: ARRAY
10508: PPUSH
10509: LD_INT 22
10511: PUSH
10512: LD_VAR 0 1
10516: PUSH
10517: LD_INT 1
10519: ARRAY
10520: PPUSH
10521: CALL_OW 255
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: LD_INT 30
10532: PUSH
10533: LD_INT 5
10535: PUSH
10536: EMPTY
10537: LIST
10538: LIST
10539: PUSH
10540: EMPTY
10541: LIST
10542: LIST
10543: PPUSH
10544: CALL_OW 69
10548: PPUSH
10549: LD_VAR 0 1
10553: PUSH
10554: LD_VAR 0 3
10558: ARRAY
10559: PPUSH
10560: CALL_OW 74
10564: PPUSH
10565: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10569: LD_VAR 0 1
10573: PUSH
10574: LD_VAR 0 3
10578: ARRAY
10579: PPUSH
10580: LD_INT 9
10582: PPUSH
10583: CALL_OW 183
// end ; end else
10587: GO 10607
// ComChangeProfession ( plist [ i ] , 9 ) ;
10589: LD_VAR 0 1
10593: PUSH
10594: LD_VAR 0 3
10598: ARRAY
10599: PPUSH
10600: LD_INT 9
10602: PPUSH
10603: CALL_OW 123
10607: GO 10406
10609: POP
10610: POP
// end ;
10611: LD_VAR 0 2
10615: RET
// export function GetHuman ( side ) ; begin
10616: LD_INT 0
10618: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10619: LD_ADDR_VAR 0 2
10623: PUSH
10624: LD_INT 22
10626: PUSH
10627: LD_VAR 0 1
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PUSH
10636: LD_INT 21
10638: PUSH
10639: LD_INT 1
10641: PUSH
10642: EMPTY
10643: LIST
10644: LIST
10645: PUSH
10646: LD_INT 2
10648: PUSH
10649: LD_INT 25
10651: PUSH
10652: LD_INT 1
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: PUSH
10659: LD_INT 25
10661: PUSH
10662: LD_INT 2
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: PUSH
10669: LD_INT 25
10671: PUSH
10672: LD_INT 3
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: PUSH
10679: LD_INT 25
10681: PUSH
10682: LD_INT 4
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: LIST
10693: LIST
10694: LIST
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: LIST
10700: PPUSH
10701: CALL_OW 69
10705: ST_TO_ADDR
// end ;
10706: LD_VAR 0 2
10710: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10711: LD_INT 0
10713: PPUSH
10714: PPUSH
10715: PPUSH
// uc_side := 0 ;
10716: LD_ADDR_OWVAR 20
10720: PUSH
10721: LD_INT 0
10723: ST_TO_ADDR
// uc_nation := 0 ;
10724: LD_ADDR_OWVAR 21
10728: PUSH
10729: LD_INT 0
10731: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10732: LD_ADDR_VAR 0 4
10736: PUSH
10737: DOUBLE
10738: LD_INT 1
10740: DEC
10741: ST_TO_ADDR
10742: LD_INT 4
10744: PUSH
10745: LD_INT 5
10747: PUSH
10748: LD_INT 6
10750: PUSH
10751: EMPTY
10752: LIST
10753: LIST
10754: LIST
10755: PUSH
10756: LD_OWVAR 67
10760: ARRAY
10761: PUSH
10762: FOR_TO
10763: IFFALSE 10834
// begin hc_class = class_tiger ;
10765: LD_ADDR_OWVAR 28
10769: PUSH
10770: LD_INT 14
10772: ST_TO_ADDR
// hc_gallery = sandnature ;
10773: LD_ADDR_OWVAR 33
10777: PUSH
10778: LD_STRING sandnature
10780: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10781: LD_ADDR_OWVAR 35
10785: PUSH
10786: LD_INT 0
10788: PPUSH
10789: LD_INT 50
10791: PPUSH
10792: CALL_OW 12
10796: ST_TO_ADDR
// hc_face_number = 3 ;
10797: LD_ADDR_OWVAR 34
10801: PUSH
10802: LD_INT 3
10804: ST_TO_ADDR
// tiger := CreateHuman ;
10805: LD_ADDR_VAR 0 3
10809: PUSH
10810: CALL_OW 44
10814: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10815: LD_VAR 0 3
10819: PPUSH
10820: LD_VAR 0 1
10824: PPUSH
10825: LD_INT 0
10827: PPUSH
10828: CALL_OW 49
// end ;
10832: GO 10762
10834: POP
10835: POP
// end ;
10836: LD_VAR 0 2
10840: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10841: LD_INT 0
10843: PPUSH
10844: PPUSH
10845: PPUSH
// uc_side := 0 ;
10846: LD_ADDR_OWVAR 20
10850: PUSH
10851: LD_INT 0
10853: ST_TO_ADDR
// uc_nation := 0 ;
10854: LD_ADDR_OWVAR 21
10858: PUSH
10859: LD_INT 0
10861: ST_TO_ADDR
// for i = 1 to 8 do
10862: LD_ADDR_VAR 0 4
10866: PUSH
10867: DOUBLE
10868: LD_INT 1
10870: DEC
10871: ST_TO_ADDR
10872: LD_INT 8
10874: PUSH
10875: FOR_TO
10876: IFFALSE 10940
// begin hc_class = class_apeman ;
10878: LD_ADDR_OWVAR 28
10882: PUSH
10883: LD_INT 12
10885: ST_TO_ADDR
// hc_gallery =  ;
10886: LD_ADDR_OWVAR 33
10890: PUSH
10891: LD_STRING 
10893: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10894: LD_ADDR_OWVAR 35
10898: PUSH
10899: LD_INT 5
10901: NEG
10902: PPUSH
10903: LD_INT 20
10905: PPUSH
10906: CALL_OW 12
10910: ST_TO_ADDR
// ape := CreateHuman ;
10911: LD_ADDR_VAR 0 3
10915: PUSH
10916: CALL_OW 44
10920: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10921: LD_VAR 0 3
10925: PPUSH
10926: LD_VAR 0 1
10930: PPUSH
10931: LD_INT 0
10933: PPUSH
10934: CALL_OW 49
// end ;
10938: GO 10875
10940: POP
10941: POP
// end ;
10942: LD_VAR 0 2
10946: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
10947: LD_INT 0
10949: PPUSH
10950: PPUSH
// if BuildingStatus ( b ) = bs_build then
10951: LD_VAR 0 2
10955: PPUSH
10956: CALL_OW 461
10960: PUSH
10961: LD_INT 1
10963: EQUAL
10964: IFFALSE 11150
// for i = 1 to plist do
10966: LD_ADDR_VAR 0 4
10970: PUSH
10971: DOUBLE
10972: LD_INT 1
10974: DEC
10975: ST_TO_ADDR
10976: LD_VAR 0 1
10980: PUSH
10981: FOR_TO
10982: IFFALSE 11148
// if IsInUnit ( plist [ i ] ) then
10984: LD_VAR 0 1
10988: PUSH
10989: LD_VAR 0 4
10993: ARRAY
10994: PPUSH
10995: CALL_OW 310
10999: IFFALSE 11082
// begin ComExitBuilding ( plist [ i ] ) ;
11001: LD_VAR 0 1
11005: PUSH
11006: LD_VAR 0 4
11010: ARRAY
11011: PPUSH
11012: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11016: LD_VAR 0 1
11020: PUSH
11021: LD_VAR 0 4
11025: ARRAY
11026: PPUSH
11027: LD_STRING h
11029: PUSH
11030: LD_VAR 0 2
11034: PPUSH
11035: CALL_OW 250
11039: PUSH
11040: LD_VAR 0 2
11044: PPUSH
11045: CALL_OW 251
11049: PUSH
11050: LD_VAR 0 2
11054: PUSH
11055: LD_INT 0
11057: PUSH
11058: LD_INT 0
11060: PUSH
11061: LD_INT 0
11063: PUSH
11064: EMPTY
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: LIST
11070: LIST
11071: LIST
11072: PUSH
11073: EMPTY
11074: LIST
11075: PPUSH
11076: CALL_OW 447
// end else
11080: GO 11146
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11082: LD_VAR 0 1
11086: PUSH
11087: LD_VAR 0 4
11091: ARRAY
11092: PPUSH
11093: LD_STRING h
11095: PUSH
11096: LD_VAR 0 2
11100: PPUSH
11101: CALL_OW 250
11105: PUSH
11106: LD_VAR 0 2
11110: PPUSH
11111: CALL_OW 251
11115: PUSH
11116: LD_VAR 0 2
11120: PUSH
11121: LD_INT 0
11123: PUSH
11124: LD_INT 0
11126: PUSH
11127: LD_INT 0
11129: PUSH
11130: EMPTY
11131: LIST
11132: LIST
11133: LIST
11134: LIST
11135: LIST
11136: LIST
11137: LIST
11138: PUSH
11139: EMPTY
11140: LIST
11141: PPUSH
11142: CALL_OW 446
11146: GO 10981
11148: POP
11149: POP
// end ;
11150: LD_VAR 0 3
11154: RET
// export function WantRepair ( eng ) ; begin
11155: LD_INT 0
11157: PPUSH
// if GetTaskList ( eng ) > 0 then
11158: LD_VAR 0 1
11162: PPUSH
11163: CALL_OW 437
11167: PUSH
11168: LD_INT 0
11170: GREATER
11171: IFFALSE 11216
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
11173: LD_VAR 0 1
11177: PPUSH
11178: CALL_OW 437
11182: PUSH
11183: LD_INT 1
11185: ARRAY
11186: PUSH
11187: LD_INT 1
11189: ARRAY
11190: PUSH
11191: LD_STRING o
11193: EQUAL
11194: IFFALSE 11206
// result := true else
11196: LD_ADDR_VAR 0 2
11200: PUSH
11201: LD_INT 1
11203: ST_TO_ADDR
11204: GO 11214
// result := false ;
11206: LD_ADDR_VAR 0 2
11210: PUSH
11211: LD_INT 0
11213: ST_TO_ADDR
// end else
11214: GO 11224
// result := false ;
11216: LD_ADDR_VAR 0 2
11220: PUSH
11221: LD_INT 0
11223: ST_TO_ADDR
// end ;
11224: LD_VAR 0 2
11228: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
11229: LD_INT 0
11231: PPUSH
11232: PPUSH
11233: PPUSH
11234: PPUSH
// if btype = - 1 then
11235: LD_VAR 0 2
11239: PUSH
11240: LD_INT 1
11242: NEG
11243: EQUAL
11244: IFFALSE 11284
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
11246: LD_ADDR_VAR 0 5
11250: PUSH
11251: LD_INT 22
11253: PUSH
11254: LD_VAR 0 1
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: PUSH
11263: LD_INT 21
11265: PUSH
11266: LD_INT 3
11268: PUSH
11269: EMPTY
11270: LIST
11271: LIST
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PPUSH
11277: CALL_OW 69
11281: ST_TO_ADDR
11282: GO 11322
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
11284: LD_ADDR_VAR 0 5
11288: PUSH
11289: LD_INT 22
11291: PUSH
11292: LD_VAR 0 1
11296: PUSH
11297: EMPTY
11298: LIST
11299: LIST
11300: PUSH
11301: LD_INT 30
11303: PUSH
11304: LD_VAR 0 2
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: PPUSH
11317: CALL_OW 69
11321: ST_TO_ADDR
// list := [ ] ;
11322: LD_ADDR_VAR 0 6
11326: PUSH
11327: EMPTY
11328: ST_TO_ADDR
// for i = 1 to tmp do
11329: LD_ADDR_VAR 0 4
11333: PUSH
11334: DOUBLE
11335: LD_INT 1
11337: DEC
11338: ST_TO_ADDR
11339: LD_VAR 0 5
11343: PUSH
11344: FOR_TO
11345: IFFALSE 11433
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11347: LD_ADDR_VAR 0 6
11351: PUSH
11352: LD_VAR 0 6
11356: PUSH
11357: LD_VAR 0 5
11361: PUSH
11362: LD_VAR 0 4
11366: ARRAY
11367: PPUSH
11368: CALL_OW 266
11372: PUSH
11373: LD_VAR 0 5
11377: PUSH
11378: LD_VAR 0 4
11382: ARRAY
11383: PPUSH
11384: CALL_OW 250
11388: PUSH
11389: LD_VAR 0 5
11393: PUSH
11394: LD_VAR 0 4
11398: ARRAY
11399: PPUSH
11400: CALL_OW 251
11404: PUSH
11405: LD_VAR 0 5
11409: PUSH
11410: LD_VAR 0 4
11414: ARRAY
11415: PPUSH
11416: CALL_OW 254
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: PUSH
11427: EMPTY
11428: LIST
11429: ADD
11430: ST_TO_ADDR
11431: GO 11344
11433: POP
11434: POP
// result = list ;
11435: LD_ADDR_VAR 0 3
11439: PUSH
11440: LD_VAR 0 6
11444: ST_TO_ADDR
// end ;
11445: LD_VAR 0 3
11449: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
11450: LD_INT 0
11452: PPUSH
11453: PPUSH
11454: PPUSH
11455: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
11456: LD_VAR 0 1
11460: PPUSH
11461: LD_INT 81
11463: PUSH
11464: LD_VAR 0 1
11468: PPUSH
11469: CALL_OW 255
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: PPUSH
11478: CALL_OW 69
11482: PPUSH
11483: LD_VAR 0 1
11487: PPUSH
11488: CALL_OW 74
11492: PPUSH
11493: CALL_OW 296
11497: PUSH
11498: LD_INT 18
11500: LESS
11501: IFFALSE 11546
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
11503: LD_VAR 0 1
11507: PPUSH
11508: LD_INT 81
11510: PUSH
11511: LD_VAR 0 1
11515: PPUSH
11516: CALL_OW 255
11520: PUSH
11521: EMPTY
11522: LIST
11523: LIST
11524: PPUSH
11525: CALL_OW 69
11529: PPUSH
11530: LD_VAR 0 1
11534: PPUSH
11535: CALL_OW 74
11539: PPUSH
11540: CALL_OW 115
11544: GO 11565
// ComMoveXY ( behemoth , x , y ) ;
11546: LD_VAR 0 1
11550: PPUSH
11551: LD_VAR 0 4
11555: PPUSH
11556: LD_VAR 0 5
11560: PPUSH
11561: CALL_OW 111
// if time_lapsers_list > 0 then
11565: LD_VAR 0 2
11569: PUSH
11570: LD_INT 0
11572: GREATER
11573: IFFALSE 11763
// begin for i = 1 to time_lapsers_list do
11575: LD_ADDR_VAR 0 7
11579: PUSH
11580: DOUBLE
11581: LD_INT 1
11583: DEC
11584: ST_TO_ADDR
11585: LD_VAR 0 2
11589: PUSH
11590: FOR_TO
11591: IFFALSE 11761
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11593: LD_VAR 0 2
11597: PUSH
11598: LD_VAR 0 7
11602: ARRAY
11603: PPUSH
11604: CALL_OW 256
11608: PUSH
11609: LD_INT 250
11611: GREATEREQUAL
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: LD_VAR 0 7
11622: ARRAY
11623: PPUSH
11624: LD_VAR 0 1
11628: PPUSH
11629: CALL_OW 296
11633: PUSH
11634: LD_INT 9
11636: GREATER
11637: AND
11638: IFFALSE 11675
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11640: LD_VAR 0 2
11644: PUSH
11645: LD_VAR 0 7
11649: ARRAY
11650: PPUSH
11651: LD_VAR 0 1
11655: PPUSH
11656: CALL_OW 250
11660: PPUSH
11661: LD_VAR 0 1
11665: PPUSH
11666: CALL_OW 251
11670: PPUSH
11671: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11675: LD_VAR 0 2
11679: PUSH
11680: LD_VAR 0 7
11684: ARRAY
11685: PPUSH
11686: CALL_OW 256
11690: PUSH
11691: LD_INT 500
11693: LESS
11694: PUSH
11695: LD_VAR 0 1
11699: PPUSH
11700: CALL_OW 256
11704: PUSH
11705: LD_INT 700
11707: GREATER
11708: AND
11709: IFFALSE 11759
// for p = 1 to mechanic_list do
11711: LD_ADDR_VAR 0 8
11715: PUSH
11716: DOUBLE
11717: LD_INT 1
11719: DEC
11720: ST_TO_ADDR
11721: LD_VAR 0 3
11725: PUSH
11726: FOR_TO
11727: IFFALSE 11757
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11729: LD_VAR 0 3
11733: PUSH
11734: LD_VAR 0 8
11738: ARRAY
11739: PPUSH
11740: LD_VAR 0 2
11744: PUSH
11745: LD_VAR 0 7
11749: ARRAY
11750: PPUSH
11751: CALL_OW 129
11755: GO 11726
11757: POP
11758: POP
// end ;
11759: GO 11590
11761: POP
11762: POP
// end ; if mechanic_list then
11763: LD_VAR 0 3
11767: IFFALSE 11948
// begin for i = 1 to mechanic_list do
11769: LD_ADDR_VAR 0 7
11773: PUSH
11774: DOUBLE
11775: LD_INT 1
11777: DEC
11778: ST_TO_ADDR
11779: LD_VAR 0 3
11783: PUSH
11784: FOR_TO
11785: IFFALSE 11946
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11787: LD_VAR 0 3
11791: PUSH
11792: LD_VAR 0 7
11796: ARRAY
11797: PPUSH
11798: CALL_OW 256
11802: PUSH
11803: LD_INT 333
11805: LESS
11806: IFFALSE 11830
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11808: LD_ADDR_EXP 14
11812: PUSH
11813: LD_EXP 14
11817: PUSH
11818: LD_VAR 0 3
11822: PUSH
11823: LD_VAR 0 7
11827: ARRAY
11828: DIFF
11829: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11830: LD_VAR 0 3
11834: PUSH
11835: LD_VAR 0 7
11839: ARRAY
11840: PPUSH
11841: LD_VAR 0 1
11845: PPUSH
11846: CALL_OW 296
11850: PUSH
11851: LD_INT 9
11853: GREATER
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_VAR 0 7
11864: ARRAY
11865: PPUSH
11866: CALL_OW 314
11870: NOT
11871: AND
11872: IFFALSE 11909
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11874: LD_VAR 0 3
11878: PUSH
11879: LD_VAR 0 7
11883: ARRAY
11884: PPUSH
11885: LD_VAR 0 1
11889: PPUSH
11890: CALL_OW 250
11894: PPUSH
11895: LD_VAR 0 1
11899: PPUSH
11900: CALL_OW 251
11904: PPUSH
11905: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11909: LD_VAR 0 1
11913: PPUSH
11914: CALL_OW 256
11918: PUSH
11919: LD_INT 700
11921: LESS
11922: IFFALSE 11944
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11924: LD_VAR 0 3
11928: PUSH
11929: LD_VAR 0 7
11933: ARRAY
11934: PPUSH
11935: LD_VAR 0 1
11939: PPUSH
11940: CALL_OW 129
// end ;
11944: GO 11784
11946: POP
11947: POP
// end ; end ;
11948: LD_VAR 0 6
11952: RET
// export function GetBehemoth ( side ) ; begin
11953: LD_INT 0
11955: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
11956: LD_ADDR_VAR 0 2
11960: PUSH
11961: LD_INT 22
11963: PUSH
11964: LD_VAR 0 1
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: PUSH
11973: LD_INT 31
11975: PUSH
11976: LD_INT 25
11978: PUSH
11979: EMPTY
11980: LIST
11981: LIST
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PPUSH
11987: CALL_OW 69
11991: ST_TO_ADDR
// end ;
11992: LD_VAR 0 2
11996: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
11997: LD_INT 0
11999: PPUSH
12000: PPUSH
12001: PPUSH
12002: PPUSH
12003: PPUSH
12004: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
12005: LD_ADDR_VAR 0 6
12009: PUSH
12010: LD_VAR 0 2
12014: PPUSH
12015: CALL_OW 435
12019: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
12020: LD_ADDR_VAR 0 5
12024: PUSH
12025: LD_INT 22
12027: PUSH
12028: LD_VAR 0 1
12032: PUSH
12033: EMPTY
12034: LIST
12035: LIST
12036: PUSH
12037: LD_INT 2
12039: PUSH
12040: LD_INT 25
12042: PUSH
12043: LD_INT 2
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 25
12052: PUSH
12053: LD_INT 16
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: LIST
12064: PUSH
12065: EMPTY
12066: LIST
12067: LIST
12068: PPUSH
12069: CALL_OW 69
12073: ST_TO_ADDR
// if skr then
12074: LD_VAR 0 6
12078: IFFALSE 12243
// begin if engs then
12080: LD_VAR 0 5
12084: IFFALSE 12243
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
12086: LD_ADDR_VAR 0 8
12090: PUSH
12091: LD_VAR 0 6
12095: PUSH
12096: LD_INT 1
12098: ARRAY
12099: PPUSH
12100: LD_VAR 0 6
12104: PUSH
12105: LD_INT 2
12107: ARRAY
12108: PPUSH
12109: CALL_OW 284
12113: ST_TO_ADDR
// if am > engs then
12114: LD_VAR 0 8
12118: PUSH
12119: LD_VAR 0 5
12123: GREATER
12124: IFFALSE 12136
// am := engs ;
12126: LD_ADDR_VAR 0 8
12130: PUSH
12131: LD_VAR 0 5
12135: ST_TO_ADDR
// for i = 1 to am do
12136: LD_ADDR_VAR 0 7
12140: PUSH
12141: DOUBLE
12142: LD_INT 1
12144: DEC
12145: ST_TO_ADDR
12146: LD_VAR 0 8
12150: PUSH
12151: FOR_TO
12152: IFFALSE 12241
// begin if IsInUnit ( engs [ i ] ) then
12154: LD_VAR 0 5
12158: PUSH
12159: LD_VAR 0 7
12163: ARRAY
12164: PPUSH
12165: CALL_OW 310
12169: IFFALSE 12188
// ComExitBuilding ( engs [ i ] ) else
12171: LD_VAR 0 5
12175: PUSH
12176: LD_VAR 0 7
12180: ARRAY
12181: PPUSH
12182: CALL_OW 122
12186: GO 12239
// if not HasTask ( engs [ i ] ) then
12188: LD_VAR 0 5
12192: PUSH
12193: LD_VAR 0 7
12197: ARRAY
12198: PPUSH
12199: CALL_OW 314
12203: NOT
12204: IFFALSE 12239
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
12206: LD_VAR 0 5
12210: PUSH
12211: LD_VAR 0 7
12215: ARRAY
12216: PPUSH
12217: LD_VAR 0 6
12221: PUSH
12222: LD_INT 1
12224: ARRAY
12225: PPUSH
12226: LD_VAR 0 6
12230: PUSH
12231: LD_INT 2
12233: ARRAY
12234: PPUSH
12235: CALL_OW 117
// end ;
12239: GO 12151
12241: POP
12242: POP
// end ; end ; end ; end_of_file
12243: LD_VAR 0 3
12247: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
12248: LD_INT 0
12250: PPUSH
12251: PPUSH
// uc_side := 1 ;
12252: LD_ADDR_OWVAR 20
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// uc_nation := 1 ;
12260: LD_ADDR_OWVAR 21
12264: PUSH
12265: LD_INT 1
12267: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12268: LD_ADDR_VAR 0 2
12272: PUSH
12273: LD_INT 6
12275: PUSH
12276: LD_INT 5
12278: PUSH
12279: LD_INT 4
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: LIST
12286: PUSH
12287: LD_OWVAR 67
12291: ARRAY
12292: ST_TO_ADDR
// game_status := false ;
12293: LD_ADDR_EXP 28
12297: PUSH
12298: LD_INT 0
12300: ST_TO_ADDR
// helps_arrive := false ;
12301: LD_ADDR_EXP 29
12305: PUSH
12306: LD_INT 0
12308: ST_TO_ADDR
// helps_can_arrive := false ;
12309: LD_ADDR_EXP 30
12313: PUSH
12314: LD_INT 0
12316: ST_TO_ADDR
// beta_come := false ;
12317: LD_ADDR_EXP 31
12321: PUSH
12322: LD_INT 0
12324: ST_TO_ADDR
// gamma_come := false ;
12325: LD_ADDR_EXP 32
12329: PUSH
12330: LD_INT 0
12332: ST_TO_ADDR
// zeta_come := false ;
12333: LD_ADDR_EXP 33
12337: PUSH
12338: LD_INT 0
12340: ST_TO_ADDR
// mine_ck := false ;
12341: LD_ADDR_EXP 34
12345: PUSH
12346: LD_INT 0
12348: ST_TO_ADDR
// sib_bomb_constructed := false ;
12349: LD_ADDR_EXP 35
12353: PUSH
12354: LD_INT 0
12356: ST_TO_ADDR
// mine_constructed := false ;
12357: LD_ADDR_EXP 36
12361: PUSH
12362: LD_INT 0
12364: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
12365: LD_INT 35
12367: PPUSH
12368: CALL_OW 274
12372: PPUSH
12373: LD_INT 1
12375: PPUSH
12376: LD_INT 200
12378: PUSH
12379: LD_INT 100
12381: PUSH
12382: LD_INT 70
12384: PUSH
12385: EMPTY
12386: LIST
12387: LIST
12388: LIST
12389: PUSH
12390: LD_OWVAR 67
12394: ARRAY
12395: PPUSH
12396: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
12400: LD_INT 35
12402: PPUSH
12403: LD_INT 4
12405: PPUSH
12406: CALL_OW 235
// hc_importance := 100 ;
12410: LD_ADDR_OWVAR 32
12414: PUSH
12415: LD_INT 100
12417: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
12418: LD_INT 1
12420: PPUSH
12421: LD_INT 2
12423: PPUSH
12424: LD_VAR 0 2
12428: PUSH
12429: LD_INT 1
12431: PLUS
12432: PPUSH
12433: CALL_OW 380
// hc_gallery := hardch ;
12437: LD_ADDR_OWVAR 33
12441: PUSH
12442: LD_STRING hardch
12444: ST_TO_ADDR
// hc_face_number := 1 ;
12445: LD_ADDR_OWVAR 34
12449: PUSH
12450: LD_INT 1
12452: ST_TO_ADDR
// guyA := CreateHuman ;
12453: LD_ADDR_EXP 37
12457: PUSH
12458: CALL_OW 44
12462: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
12463: LD_INT 1
12465: PPUSH
12466: LD_INT 1
12468: PPUSH
12469: LD_VAR 0 2
12473: PPUSH
12474: CALL_OW 380
// hc_face_number := 2 ;
12478: LD_ADDR_OWVAR 34
12482: PUSH
12483: LD_INT 2
12485: ST_TO_ADDR
// guyB := CreateHuman ;
12486: LD_ADDR_EXP 38
12490: PUSH
12491: CALL_OW 44
12495: ST_TO_ADDR
// hc_importance := 0 ;
12496: LD_ADDR_OWVAR 32
12500: PUSH
12501: LD_INT 0
12503: ST_TO_ADDR
// hc_gallery :=  ;
12504: LD_ADDR_OWVAR 33
12508: PUSH
12509: LD_STRING 
12511: ST_TO_ADDR
// end ;
12512: LD_VAR 0 1
12516: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
12517: LD_INT 0
12519: PPUSH
12520: PPUSH
12521: PPUSH
12522: PPUSH
12523: PPUSH
12524: PPUSH
12525: PPUSH
12526: PPUSH
12527: PPUSH
// uc_side := 4 ;
12528: LD_ADDR_OWVAR 20
12532: PUSH
12533: LD_INT 4
12535: ST_TO_ADDR
// uc_nation := 1 ;
12536: LD_ADDR_OWVAR 21
12540: PUSH
12541: LD_INT 1
12543: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12544: LD_ADDR_VAR 0 10
12548: PUSH
12549: LD_INT 6
12551: PUSH
12552: LD_INT 5
12554: PUSH
12555: LD_INT 4
12557: PUSH
12558: EMPTY
12559: LIST
12560: LIST
12561: LIST
12562: PUSH
12563: LD_OWVAR 67
12567: ARRAY
12568: ST_TO_ADDR
// Beta_Squad := [ ] ;
12569: LD_ADDR_EXP 39
12573: PUSH
12574: EMPTY
12575: ST_TO_ADDR
// case num of 1 :
12576: LD_VAR 0 1
12580: PUSH
12581: LD_INT 1
12583: DOUBLE
12584: EQUAL
12585: IFTRUE 12589
12587: GO 12632
12589: POP
// begin sold := 2 ;
12590: LD_ADDR_VAR 0 5
12594: PUSH
12595: LD_INT 2
12597: ST_TO_ADDR
// sci := 1 ;
12598: LD_ADDR_VAR 0 6
12602: PUSH
12603: LD_INT 1
12605: ST_TO_ADDR
// mech := 2 ;
12606: LD_ADDR_VAR 0 7
12610: PUSH
12611: LD_INT 2
12613: ST_TO_ADDR
// tank := 1 ;
12614: LD_ADDR_VAR 0 8
12618: PUSH
12619: LD_INT 1
12621: ST_TO_ADDR
// cargo := 1 ;
12622: LD_ADDR_VAR 0 9
12626: PUSH
12627: LD_INT 1
12629: ST_TO_ADDR
// end ; 2 :
12630: GO 12735
12632: LD_INT 2
12634: DOUBLE
12635: EQUAL
12636: IFTRUE 12640
12638: GO 12683
12640: POP
// begin sold := 2 ;
12641: LD_ADDR_VAR 0 5
12645: PUSH
12646: LD_INT 2
12648: ST_TO_ADDR
// sci := 1 ;
12649: LD_ADDR_VAR 0 6
12653: PUSH
12654: LD_INT 1
12656: ST_TO_ADDR
// mech := 1 ;
12657: LD_ADDR_VAR 0 7
12661: PUSH
12662: LD_INT 1
12664: ST_TO_ADDR
// tank := 1 ;
12665: LD_ADDR_VAR 0 8
12669: PUSH
12670: LD_INT 1
12672: ST_TO_ADDR
// cargo := 0 ;
12673: LD_ADDR_VAR 0 9
12677: PUSH
12678: LD_INT 0
12680: ST_TO_ADDR
// end ; 3 :
12681: GO 12735
12683: LD_INT 3
12685: DOUBLE
12686: EQUAL
12687: IFTRUE 12691
12689: GO 12734
12691: POP
// begin sold := 1 ;
12692: LD_ADDR_VAR 0 5
12696: PUSH
12697: LD_INT 1
12699: ST_TO_ADDR
// sci := 1 ;
12700: LD_ADDR_VAR 0 6
12704: PUSH
12705: LD_INT 1
12707: ST_TO_ADDR
// mech := 1 ;
12708: LD_ADDR_VAR 0 7
12712: PUSH
12713: LD_INT 1
12715: ST_TO_ADDR
// tank := 1 ;
12716: LD_ADDR_VAR 0 8
12720: PUSH
12721: LD_INT 1
12723: ST_TO_ADDR
// cargo := 0 ;
12724: LD_ADDR_VAR 0 9
12728: PUSH
12729: LD_INT 0
12731: ST_TO_ADDR
// end ; end ;
12732: GO 12735
12734: POP
// for i = 1 to sold do
12735: LD_ADDR_VAR 0 3
12739: PUSH
12740: DOUBLE
12741: LD_INT 1
12743: DEC
12744: ST_TO_ADDR
12745: LD_VAR 0 5
12749: PUSH
12750: FOR_TO
12751: IFFALSE 12823
// begin if i = 1 then
12753: LD_VAR 0 3
12757: PUSH
12758: LD_INT 1
12760: EQUAL
12761: IFFALSE 12780
// PrepareHuman ( sex_male , 1 , skill ) else
12763: LD_INT 1
12765: PPUSH
12766: LD_INT 1
12768: PPUSH
12769: LD_VAR 0 10
12773: PPUSH
12774: CALL_OW 380
12778: GO 12795
// PrepareHuman ( false , 1 , skill ) ;
12780: LD_INT 0
12782: PPUSH
12783: LD_INT 1
12785: PPUSH
12786: LD_VAR 0 10
12790: PPUSH
12791: CALL_OW 380
// un := CreateHuman ;
12795: LD_ADDR_VAR 0 4
12799: PUSH
12800: CALL_OW 44
12804: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12805: LD_ADDR_EXP 39
12809: PUSH
12810: LD_EXP 39
12814: PUSH
12815: LD_VAR 0 4
12819: ADD
12820: ST_TO_ADDR
// end ;
12821: GO 12750
12823: POP
12824: POP
// for i = 1 to mech do
12825: LD_ADDR_VAR 0 3
12829: PUSH
12830: DOUBLE
12831: LD_INT 1
12833: DEC
12834: ST_TO_ADDR
12835: LD_VAR 0 7
12839: PUSH
12840: FOR_TO
12841: IFFALSE 12898
// begin PrepareHuman ( false , 3 , skill ) ;
12843: LD_INT 0
12845: PPUSH
12846: LD_INT 3
12848: PPUSH
12849: LD_VAR 0 10
12853: PPUSH
12854: CALL_OW 380
// un := CreateHuman ;
12858: LD_ADDR_VAR 0 4
12862: PUSH
12863: CALL_OW 44
12867: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12868: LD_VAR 0 4
12872: PPUSH
12873: LD_INT 3
12875: PPUSH
12876: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12880: LD_ADDR_EXP 39
12884: PUSH
12885: LD_EXP 39
12889: PUSH
12890: LD_VAR 0 4
12894: ADD
12895: ST_TO_ADDR
// end ;
12896: GO 12840
12898: POP
12899: POP
// for i = 1 to sci do
12900: LD_ADDR_VAR 0 3
12904: PUSH
12905: DOUBLE
12906: LD_INT 1
12908: DEC
12909: ST_TO_ADDR
12910: LD_VAR 0 6
12914: PUSH
12915: FOR_TO
12916: IFFALSE 12961
// begin PrepareHuman ( false , 4 , skill ) ;
12918: LD_INT 0
12920: PPUSH
12921: LD_INT 4
12923: PPUSH
12924: LD_VAR 0 10
12928: PPUSH
12929: CALL_OW 380
// un := CreateHuman ;
12933: LD_ADDR_VAR 0 4
12937: PUSH
12938: CALL_OW 44
12942: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12943: LD_ADDR_EXP 39
12947: PUSH
12948: LD_EXP 39
12952: PUSH
12953: LD_VAR 0 4
12957: ADD
12958: ST_TO_ADDR
// end ;
12959: GO 12915
12961: POP
12962: POP
// for i = 1 to tank do
12963: LD_ADDR_VAR 0 3
12967: PUSH
12968: DOUBLE
12969: LD_INT 1
12971: DEC
12972: ST_TO_ADDR
12973: LD_VAR 0 8
12977: PUSH
12978: FOR_TO
12979: IFFALSE 13092
// begin Randomize ;
12981: CALL_OW 10
// vc_chassis := us_medium_tracked ;
12985: LD_ADDR_OWVAR 37
12989: PUSH
12990: LD_INT 3
12992: ST_TO_ADDR
// vc_engine := engine_solar ;
12993: LD_ADDR_OWVAR 39
12997: PUSH
12998: LD_INT 2
13000: ST_TO_ADDR
// vc_control := control_manual ;
13001: LD_ADDR_OWVAR 38
13005: PUSH
13006: LD_INT 1
13008: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
13009: LD_ADDR_OWVAR 40
13013: PUSH
13014: LD_INT 4
13016: PUSH
13017: LD_INT 5
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: PUSH
13024: LD_INT 1
13026: PPUSH
13027: LD_INT 2
13029: PPUSH
13030: CALL_OW 12
13034: ARRAY
13035: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13036: LD_ADDR_OWVAR 41
13040: PUSH
13041: LD_INT 35
13043: PPUSH
13044: LD_INT 55
13046: PPUSH
13047: CALL_OW 12
13051: ST_TO_ADDR
// un := CreateVehicle ;
13052: LD_ADDR_VAR 0 4
13056: PUSH
13057: CALL_OW 45
13061: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13062: LD_VAR 0 4
13066: PPUSH
13067: LD_INT 5
13069: PPUSH
13070: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13074: LD_ADDR_EXP 39
13078: PUSH
13079: LD_EXP 39
13083: PUSH
13084: LD_VAR 0 4
13088: ADD
13089: ST_TO_ADDR
// end ;
13090: GO 12978
13092: POP
13093: POP
// if cargo then
13094: LD_VAR 0 9
13098: IFFALSE 13201
// begin vc_chassis := us_medium_tracked ;
13100: LD_ADDR_OWVAR 37
13104: PUSH
13105: LD_INT 3
13107: ST_TO_ADDR
// vc_engine := engine_solar ;
13108: LD_ADDR_OWVAR 39
13112: PUSH
13113: LD_INT 2
13115: ST_TO_ADDR
// vc_control := control_manual ;
13116: LD_ADDR_OWVAR 38
13120: PUSH
13121: LD_INT 1
13123: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13124: LD_ADDR_OWVAR 40
13128: PUSH
13129: LD_INT 12
13131: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13132: LD_ADDR_OWVAR 41
13136: PUSH
13137: LD_INT 35
13139: PPUSH
13140: LD_INT 55
13142: PPUSH
13143: CALL_OW 12
13147: ST_TO_ADDR
// un := CreateVehicle ;
13148: LD_ADDR_VAR 0 4
13152: PUSH
13153: CALL_OW 45
13157: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13158: LD_VAR 0 4
13162: PPUSH
13163: LD_INT 5
13165: PPUSH
13166: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13170: LD_ADDR_EXP 39
13174: PUSH
13175: LD_EXP 39
13179: PUSH
13180: LD_VAR 0 4
13184: ADD
13185: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
13186: LD_VAR 0 4
13190: PPUSH
13191: LD_INT 1
13193: PPUSH
13194: LD_INT 60
13196: PPUSH
13197: CALL_OW 290
// end ; end ;
13201: LD_VAR 0 2
13205: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13206: LD_INT 0
13208: PPUSH
13209: PPUSH
13210: PPUSH
13211: PPUSH
13212: PPUSH
13213: PPUSH
13214: PPUSH
13215: PPUSH
13216: PPUSH
13217: PPUSH
// uc_side := 4 ;
13218: LD_ADDR_OWVAR 20
13222: PUSH
13223: LD_INT 4
13225: ST_TO_ADDR
// uc_nation := 1 ;
13226: LD_ADDR_OWVAR 21
13230: PUSH
13231: LD_INT 1
13233: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13234: LD_ADDR_VAR 0 11
13238: PUSH
13239: LD_INT 6
13241: PUSH
13242: LD_INT 5
13244: PUSH
13245: LD_INT 4
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: LIST
13252: PUSH
13253: LD_OWVAR 67
13257: ARRAY
13258: ST_TO_ADDR
// Gamma_Squad := [ ] ;
13259: LD_ADDR_EXP 40
13263: PUSH
13264: EMPTY
13265: ST_TO_ADDR
// case num of 1 :
13266: LD_VAR 0 1
13270: PUSH
13271: LD_INT 1
13273: DOUBLE
13274: EQUAL
13275: IFTRUE 13279
13277: GO 13330
13279: POP
// begin sold := 2 ;
13280: LD_ADDR_VAR 0 5
13284: PUSH
13285: LD_INT 2
13287: ST_TO_ADDR
// eng := 2 ;
13288: LD_ADDR_VAR 0 6
13292: PUSH
13293: LD_INT 2
13295: ST_TO_ADDR
// sci := 0 ;
13296: LD_ADDR_VAR 0 7
13300: PUSH
13301: LD_INT 0
13303: ST_TO_ADDR
// mech := 1 ;
13304: LD_ADDR_VAR 0 8
13308: PUSH
13309: LD_INT 1
13311: ST_TO_ADDR
// tank := 0 ;
13312: LD_ADDR_VAR 0 9
13316: PUSH
13317: LD_INT 0
13319: ST_TO_ADDR
// cargo := 1 ;
13320: LD_ADDR_VAR 0 10
13324: PUSH
13325: LD_INT 1
13327: ST_TO_ADDR
// end ; 2 :
13328: GO 13449
13330: LD_INT 2
13332: DOUBLE
13333: EQUAL
13334: IFTRUE 13338
13336: GO 13389
13338: POP
// begin sold := 1 ;
13339: LD_ADDR_VAR 0 5
13343: PUSH
13344: LD_INT 1
13346: ST_TO_ADDR
// eng := 2 ;
13347: LD_ADDR_VAR 0 6
13351: PUSH
13352: LD_INT 2
13354: ST_TO_ADDR
// sci := 0 ;
13355: LD_ADDR_VAR 0 7
13359: PUSH
13360: LD_INT 0
13362: ST_TO_ADDR
// mech := 1 ;
13363: LD_ADDR_VAR 0 8
13367: PUSH
13368: LD_INT 1
13370: ST_TO_ADDR
// tank := 0 ;
13371: LD_ADDR_VAR 0 9
13375: PUSH
13376: LD_INT 0
13378: ST_TO_ADDR
// cargo := 1 ;
13379: LD_ADDR_VAR 0 10
13383: PUSH
13384: LD_INT 1
13386: ST_TO_ADDR
// end ; 3 :
13387: GO 13449
13389: LD_INT 3
13391: DOUBLE
13392: EQUAL
13393: IFTRUE 13397
13395: GO 13448
13397: POP
// begin sold := 1 ;
13398: LD_ADDR_VAR 0 5
13402: PUSH
13403: LD_INT 1
13405: ST_TO_ADDR
// eng := 1 ;
13406: LD_ADDR_VAR 0 6
13410: PUSH
13411: LD_INT 1
13413: ST_TO_ADDR
// sci := 0 ;
13414: LD_ADDR_VAR 0 7
13418: PUSH
13419: LD_INT 0
13421: ST_TO_ADDR
// mech := 1 ;
13422: LD_ADDR_VAR 0 8
13426: PUSH
13427: LD_INT 1
13429: ST_TO_ADDR
// tank := 0 ;
13430: LD_ADDR_VAR 0 9
13434: PUSH
13435: LD_INT 0
13437: ST_TO_ADDR
// cargo := 1 ;
13438: LD_ADDR_VAR 0 10
13442: PUSH
13443: LD_INT 1
13445: ST_TO_ADDR
// end ; end ;
13446: GO 13449
13448: POP
// for i = 1 to sold do
13449: LD_ADDR_VAR 0 3
13453: PUSH
13454: DOUBLE
13455: LD_INT 1
13457: DEC
13458: ST_TO_ADDR
13459: LD_VAR 0 5
13463: PUSH
13464: FOR_TO
13465: IFFALSE 13537
// begin if i = 1 then
13467: LD_VAR 0 3
13471: PUSH
13472: LD_INT 1
13474: EQUAL
13475: IFFALSE 13494
// PrepareHuman ( sex_male , 1 , skill ) else
13477: LD_INT 1
13479: PPUSH
13480: LD_INT 1
13482: PPUSH
13483: LD_VAR 0 11
13487: PPUSH
13488: CALL_OW 380
13492: GO 13509
// PrepareHuman ( false , 1 , skill ) ;
13494: LD_INT 0
13496: PPUSH
13497: LD_INT 1
13499: PPUSH
13500: LD_VAR 0 11
13504: PPUSH
13505: CALL_OW 380
// un := CreateHuman ;
13509: LD_ADDR_VAR 0 4
13513: PUSH
13514: CALL_OW 44
13518: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13519: LD_ADDR_EXP 40
13523: PUSH
13524: LD_EXP 40
13528: PUSH
13529: LD_VAR 0 4
13533: ADD
13534: ST_TO_ADDR
// end ;
13535: GO 13464
13537: POP
13538: POP
// for i = 1 to mech do
13539: LD_ADDR_VAR 0 3
13543: PUSH
13544: DOUBLE
13545: LD_INT 1
13547: DEC
13548: ST_TO_ADDR
13549: LD_VAR 0 8
13553: PUSH
13554: FOR_TO
13555: IFFALSE 13612
// begin PrepareHuman ( false , 3 , skill ) ;
13557: LD_INT 0
13559: PPUSH
13560: LD_INT 3
13562: PPUSH
13563: LD_VAR 0 11
13567: PPUSH
13568: CALL_OW 380
// un := CreateHuman ;
13572: LD_ADDR_VAR 0 4
13576: PUSH
13577: CALL_OW 44
13581: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13582: LD_VAR 0 4
13586: PPUSH
13587: LD_INT 3
13589: PPUSH
13590: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13594: LD_ADDR_EXP 40
13598: PUSH
13599: LD_EXP 40
13603: PUSH
13604: LD_VAR 0 4
13608: ADD
13609: ST_TO_ADDR
// end ;
13610: GO 13554
13612: POP
13613: POP
// for i = 1 to eng do
13614: LD_ADDR_VAR 0 3
13618: PUSH
13619: DOUBLE
13620: LD_INT 1
13622: DEC
13623: ST_TO_ADDR
13624: LD_VAR 0 6
13628: PUSH
13629: FOR_TO
13630: IFFALSE 13675
// begin PrepareHuman ( false , 2 , skill ) ;
13632: LD_INT 0
13634: PPUSH
13635: LD_INT 2
13637: PPUSH
13638: LD_VAR 0 11
13642: PPUSH
13643: CALL_OW 380
// un := CreateHuman ;
13647: LD_ADDR_VAR 0 4
13651: PUSH
13652: CALL_OW 44
13656: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13657: LD_ADDR_EXP 40
13661: PUSH
13662: LD_EXP 40
13666: PUSH
13667: LD_VAR 0 4
13671: ADD
13672: ST_TO_ADDR
// end ;
13673: GO 13629
13675: POP
13676: POP
// for i = 1 to tank do
13677: LD_ADDR_VAR 0 3
13681: PUSH
13682: DOUBLE
13683: LD_INT 1
13685: DEC
13686: ST_TO_ADDR
13687: LD_VAR 0 9
13691: PUSH
13692: FOR_TO
13693: IFFALSE 13806
// begin Randomize ;
13695: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13699: LD_ADDR_OWVAR 37
13703: PUSH
13704: LD_INT 2
13706: ST_TO_ADDR
// vc_engine := engine_siberite ;
13707: LD_ADDR_OWVAR 39
13711: PUSH
13712: LD_INT 3
13714: ST_TO_ADDR
// vc_control := control_manual ;
13715: LD_ADDR_OWVAR 38
13719: PUSH
13720: LD_INT 1
13722: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13723: LD_ADDR_OWVAR 40
13727: PUSH
13728: LD_INT 7
13730: PUSH
13731: LD_INT 9
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PUSH
13738: LD_INT 1
13740: PPUSH
13741: LD_INT 2
13743: PPUSH
13744: CALL_OW 12
13748: ARRAY
13749: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13750: LD_ADDR_OWVAR 41
13754: PUSH
13755: LD_INT 35
13757: PPUSH
13758: LD_INT 55
13760: PPUSH
13761: CALL_OW 12
13765: ST_TO_ADDR
// un := CreateVehicle ;
13766: LD_ADDR_VAR 0 4
13770: PUSH
13771: CALL_OW 45
13775: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13776: LD_VAR 0 4
13780: PPUSH
13781: LD_INT 5
13783: PPUSH
13784: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13788: LD_ADDR_EXP 40
13792: PUSH
13793: LD_EXP 40
13797: PUSH
13798: LD_VAR 0 4
13802: ADD
13803: ST_TO_ADDR
// end ;
13804: GO 13692
13806: POP
13807: POP
// if cargo then
13808: LD_VAR 0 10
13812: IFFALSE 13930
// begin vc_chassis := us_medium_tracked ;
13814: LD_ADDR_OWVAR 37
13818: PUSH
13819: LD_INT 3
13821: ST_TO_ADDR
// vc_engine := engine_combustion ;
13822: LD_ADDR_OWVAR 39
13826: PUSH
13827: LD_INT 1
13829: ST_TO_ADDR
// vc_control := control_manual ;
13830: LD_ADDR_OWVAR 38
13834: PUSH
13835: LD_INT 1
13837: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13838: LD_ADDR_OWVAR 40
13842: PUSH
13843: LD_INT 12
13845: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13846: LD_ADDR_OWVAR 41
13850: PUSH
13851: LD_INT 35
13853: PPUSH
13854: LD_INT 55
13856: PPUSH
13857: CALL_OW 12
13861: ST_TO_ADDR
// un := CreateVehicle ;
13862: LD_ADDR_VAR 0 4
13866: PUSH
13867: CALL_OW 45
13871: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13872: LD_VAR 0 4
13876: PPUSH
13877: LD_INT 5
13879: PPUSH
13880: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13884: LD_ADDR_EXP 40
13888: PUSH
13889: LD_EXP 40
13893: PUSH
13894: LD_VAR 0 4
13898: ADD
13899: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13900: LD_VAR 0 4
13904: PPUSH
13905: LD_INT 3
13907: PPUSH
13908: LD_INT 30
13910: PPUSH
13911: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13915: LD_VAR 0 4
13919: PPUSH
13920: LD_INT 1
13922: PPUSH
13923: LD_INT 40
13925: PPUSH
13926: CALL_OW 290
// end ; end ;
13930: LD_VAR 0 2
13934: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13935: LD_INT 0
13937: PPUSH
13938: PPUSH
13939: PPUSH
13940: PPUSH
13941: PPUSH
13942: PPUSH
13943: PPUSH
13944: PPUSH
13945: PPUSH
13946: PPUSH
// uc_side := 4 ;
13947: LD_ADDR_OWVAR 20
13951: PUSH
13952: LD_INT 4
13954: ST_TO_ADDR
// uc_nation := 1 ;
13955: LD_ADDR_OWVAR 21
13959: PUSH
13960: LD_INT 1
13962: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13963: LD_ADDR_VAR 0 10
13967: PUSH
13968: LD_INT 6
13970: PUSH
13971: LD_INT 5
13973: PUSH
13974: LD_INT 4
13976: PUSH
13977: EMPTY
13978: LIST
13979: LIST
13980: LIST
13981: PUSH
13982: LD_OWVAR 67
13986: ARRAY
13987: ST_TO_ADDR
// Zeta_Squad := [ ] ;
13988: LD_ADDR_EXP 41
13992: PUSH
13993: EMPTY
13994: ST_TO_ADDR
// sold := 1 ;
13995: LD_ADDR_VAR 0 4
13999: PUSH
14000: LD_INT 1
14002: ST_TO_ADDR
// eng := 0 ;
14003: LD_ADDR_VAR 0 5
14007: PUSH
14008: LD_INT 0
14010: ST_TO_ADDR
// sci := 0 ;
14011: LD_ADDR_VAR 0 6
14015: PUSH
14016: LD_INT 0
14018: ST_TO_ADDR
// mech := 3 ;
14019: LD_ADDR_VAR 0 7
14023: PUSH
14024: LD_INT 3
14026: ST_TO_ADDR
// tank := 3 ;
14027: LD_ADDR_VAR 0 8
14031: PUSH
14032: LD_INT 3
14034: ST_TO_ADDR
// cargo := 0 ;
14035: LD_ADDR_VAR 0 9
14039: PUSH
14040: LD_INT 0
14042: ST_TO_ADDR
// for i = 1 to sold do
14043: LD_ADDR_VAR 0 2
14047: PUSH
14048: DOUBLE
14049: LD_INT 1
14051: DEC
14052: ST_TO_ADDR
14053: LD_VAR 0 4
14057: PUSH
14058: FOR_TO
14059: IFFALSE 14131
// begin if i = 1 then
14061: LD_VAR 0 2
14065: PUSH
14066: LD_INT 1
14068: EQUAL
14069: IFFALSE 14088
// PrepareHuman ( sex_male , 1 , skill ) else
14071: LD_INT 1
14073: PPUSH
14074: LD_INT 1
14076: PPUSH
14077: LD_VAR 0 10
14081: PPUSH
14082: CALL_OW 380
14086: GO 14103
// PrepareHuman ( false , 1 , skill ) ;
14088: LD_INT 0
14090: PPUSH
14091: LD_INT 1
14093: PPUSH
14094: LD_VAR 0 10
14098: PPUSH
14099: CALL_OW 380
// un := CreateHuman ;
14103: LD_ADDR_VAR 0 3
14107: PUSH
14108: CALL_OW 44
14112: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
14113: LD_ADDR_EXP 41
14117: PUSH
14118: LD_EXP 41
14122: PUSH
14123: LD_VAR 0 3
14127: ADD
14128: ST_TO_ADDR
// end ;
14129: GO 14058
14131: POP
14132: POP
// for i = 1 to mech do
14133: LD_ADDR_VAR 0 2
14137: PUSH
14138: DOUBLE
14139: LD_INT 1
14141: DEC
14142: ST_TO_ADDR
14143: LD_VAR 0 7
14147: PUSH
14148: FOR_TO
14149: IFFALSE 14206
// begin PrepareHuman ( false , 3 , skill ) ;
14151: LD_INT 0
14153: PPUSH
14154: LD_INT 3
14156: PPUSH
14157: LD_VAR 0 10
14161: PPUSH
14162: CALL_OW 380
// un := CreateHuman ;
14166: LD_ADDR_VAR 0 3
14170: PUSH
14171: CALL_OW 44
14175: ST_TO_ADDR
// SetTag ( un , 3 ) ;
14176: LD_VAR 0 3
14180: PPUSH
14181: LD_INT 3
14183: PPUSH
14184: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14188: LD_ADDR_EXP 41
14192: PUSH
14193: LD_EXP 41
14197: PUSH
14198: LD_VAR 0 3
14202: ADD
14203: ST_TO_ADDR
// end ;
14204: GO 14148
14206: POP
14207: POP
// for i = 1 to tank do
14208: LD_ADDR_VAR 0 2
14212: PUSH
14213: DOUBLE
14214: LD_INT 1
14216: DEC
14217: ST_TO_ADDR
14218: LD_VAR 0 8
14222: PUSH
14223: FOR_TO
14224: IFFALSE 14470
// begin Randomize ;
14226: CALL_OW 10
// if i < 3 then
14230: LD_VAR 0 2
14234: PUSH
14235: LD_INT 3
14237: LESS
14238: IFFALSE 14347
// begin vc_chassis := us_medium_tracked ;
14240: LD_ADDR_OWVAR 37
14244: PUSH
14245: LD_INT 3
14247: ST_TO_ADDR
// vc_engine := engine_combustion ;
14248: LD_ADDR_OWVAR 39
14252: PUSH
14253: LD_INT 1
14255: ST_TO_ADDR
// vc_control := control_manual ;
14256: LD_ADDR_OWVAR 38
14260: PUSH
14261: LD_INT 1
14263: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
14264: LD_ADDR_OWVAR 40
14268: PUSH
14269: LD_INT 3
14271: PUSH
14272: LD_INT 9
14274: PUSH
14275: EMPTY
14276: LIST
14277: LIST
14278: PUSH
14279: LD_INT 1
14281: PPUSH
14282: LD_INT 2
14284: PPUSH
14285: CALL_OW 12
14289: ARRAY
14290: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14291: LD_ADDR_OWVAR 41
14295: PUSH
14296: LD_INT 35
14298: PPUSH
14299: LD_INT 55
14301: PPUSH
14302: CALL_OW 12
14306: ST_TO_ADDR
// un := CreateVehicle ;
14307: LD_ADDR_VAR 0 3
14311: PUSH
14312: CALL_OW 45
14316: ST_TO_ADDR
// SetTag ( un , 5 ) ;
14317: LD_VAR 0 3
14321: PPUSH
14322: LD_INT 5
14324: PPUSH
14325: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14329: LD_ADDR_EXP 41
14333: PUSH
14334: LD_EXP 41
14338: PUSH
14339: LD_VAR 0 3
14343: ADD
14344: ST_TO_ADDR
// end else
14345: GO 14468
// begin uc_nation := 3 ;
14347: LD_ADDR_OWVAR 21
14351: PUSH
14352: LD_INT 3
14354: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
14355: LD_ADDR_OWVAR 37
14359: PUSH
14360: LD_INT 22
14362: ST_TO_ADDR
// vc_engine := engine_combustion ;
14363: LD_ADDR_OWVAR 39
14367: PUSH
14368: LD_INT 1
14370: ST_TO_ADDR
// vc_control := control_manual ;
14371: LD_ADDR_OWVAR 38
14375: PUSH
14376: LD_INT 1
14378: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
14379: LD_ADDR_OWVAR 40
14383: PUSH
14384: LD_INT 51
14386: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14387: LD_ADDR_OWVAR 41
14391: PUSH
14392: LD_INT 35
14394: PPUSH
14395: LD_INT 55
14397: PPUSH
14398: CALL_OW 12
14402: ST_TO_ADDR
// un := CreateVehicle ;
14403: LD_ADDR_VAR 0 3
14407: PUSH
14408: CALL_OW 45
14412: ST_TO_ADDR
// SetLives ( un , 496 ) ;
14413: LD_VAR 0 3
14417: PPUSH
14418: LD_INT 496
14420: PPUSH
14421: CALL_OW 234
// SetTag ( un , 5 ) ;
14425: LD_VAR 0 3
14429: PPUSH
14430: LD_INT 5
14432: PPUSH
14433: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
14437: LD_VAR 0 3
14441: PPUSH
14442: LD_INT 2
14444: PPUSH
14445: LD_INT 100
14447: PPUSH
14448: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
14452: LD_ADDR_EXP 41
14456: PUSH
14457: LD_EXP 41
14461: PUSH
14462: LD_VAR 0 3
14466: ADD
14467: ST_TO_ADDR
// end ; end ;
14468: GO 14223
14470: POP
14471: POP
// end ; end_of_file
14472: LD_VAR 0 1
14476: RET
// export function Action ; begin
14477: LD_INT 0
14479: PPUSH
// InGameOn ;
14480: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
14484: LD_INT 151
14486: PPUSH
14487: LD_INT 107
14489: PPUSH
14490: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
14494: LD_EXP 37
14498: PPUSH
14499: LD_INT 171
14501: PPUSH
14502: LD_INT 108
14504: PPUSH
14505: LD_INT 0
14507: PPUSH
14508: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
14512: LD_EXP 38
14516: PPUSH
14517: LD_INT 172
14519: PPUSH
14520: LD_INT 110
14522: PPUSH
14523: LD_INT 0
14525: PPUSH
14526: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
14530: LD_EXP 37
14534: PPUSH
14535: LD_INT 156
14537: PPUSH
14538: LD_INT 107
14540: PPUSH
14541: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
14545: LD_EXP 38
14549: PPUSH
14550: LD_INT 154
14552: PPUSH
14553: LD_INT 105
14555: PPUSH
14556: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
14560: LD_INT 4
14562: PPUSH
14563: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
14567: LD_EXP 37
14571: PPUSH
14572: CALL_OW 250
14576: PUSH
14577: LD_INT 156
14579: EQUAL
14580: PUSH
14581: LD_EXP 37
14585: PPUSH
14586: CALL_OW 251
14590: PUSH
14591: LD_INT 107
14593: EQUAL
14594: AND
14595: IFFALSE 14560
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14597: LD_EXP 37
14601: PUSH
14602: LD_EXP 38
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: PPUSH
14611: LD_INT 35
14613: PPUSH
14614: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14618: LD_EXP 37
14622: PPUSH
14623: LD_STRING D1-A-1
14625: PPUSH
14626: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14630: LD_EXP 38
14634: PPUSH
14635: LD_STRING D1-B-1
14637: PPUSH
14638: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14642: LD_EXP 37
14646: PPUSH
14647: LD_STRING D1-A-2
14649: PPUSH
14650: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14654: LD_EXP 38
14658: PPUSH
14659: LD_STRING D1-B-2
14661: PPUSH
14662: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14666: LD_EXP 37
14670: PUSH
14671: LD_EXP 38
14675: PUSH
14676: EMPTY
14677: LIST
14678: LIST
14679: PPUSH
14680: LD_INT 147
14682: PPUSH
14683: LD_INT 108
14685: PPUSH
14686: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14690: LD_EXP 37
14694: PPUSH
14695: LD_STRING D1-A-3
14697: PPUSH
14698: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14702: LD_INT 4
14704: PPUSH
14705: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14709: LD_EXP 37
14713: PPUSH
14714: LD_INT 35
14716: PPUSH
14717: CALL_OW 296
14721: PUSH
14722: LD_INT 8
14724: LESS
14725: IFFALSE 14702
// ComTurnUnit ( guyA , guyB ) ;
14727: LD_EXP 37
14731: PPUSH
14732: LD_EXP 38
14736: PPUSH
14737: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14741: LD_EXP 38
14745: PPUSH
14746: LD_EXP 37
14750: PPUSH
14751: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14755: LD_EXP 37
14759: PPUSH
14760: LD_STRING D1-A-10
14762: PPUSH
14763: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14767: LD_EXP 38
14771: PPUSH
14772: LD_STRING D1-B-10
14774: PPUSH
14775: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14779: LD_EXP 37
14783: PPUSH
14784: LD_STRING D1-A-11
14786: PPUSH
14787: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14791: LD_EXP 38
14795: PPUSH
14796: LD_STRING D1-B-11
14798: PPUSH
14799: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14803: LD_EXP 37
14807: PPUSH
14808: LD_STRING D1-A-12
14810: PPUSH
14811: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14815: LD_EXP 38
14819: PPUSH
14820: LD_STRING D1-B-12
14822: PPUSH
14823: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14827: LD_EXP 37
14831: PPUSH
14832: LD_STRING D1-A-13
14834: PPUSH
14835: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14839: LD_EXP 38
14843: PPUSH
14844: LD_STRING D1-B-13
14846: PPUSH
14847: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14851: LD_EXP 37
14855: PPUSH
14856: LD_STRING D1-A-14
14858: PPUSH
14859: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14863: LD_EXP 38
14867: PPUSH
14868: LD_STRING D1-B-14
14870: PPUSH
14871: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14875: LD_EXP 37
14879: PPUSH
14880: LD_STRING D1-A-15
14882: PPUSH
14883: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14887: LD_EXP 38
14891: PPUSH
14892: LD_STRING D1-B-15
14894: PPUSH
14895: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14899: LD_EXP 37
14903: PPUSH
14904: LD_STRING D1-A-16
14906: PPUSH
14907: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14911: LD_EXP 38
14915: PPUSH
14916: LD_STRING D1-B-16
14918: PPUSH
14919: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14923: LD_EXP 37
14927: PPUSH
14928: LD_STRING D1-A-17
14930: PPUSH
14931: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14935: LD_EXP 38
14939: PPUSH
14940: LD_STRING D1-B-17
14942: PPUSH
14943: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
14947: LD_EXP 37
14951: PPUSH
14952: LD_STRING D1-A-18
14954: PPUSH
14955: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
14959: LD_INT 35
14961: PPUSH
14962: LD_INT 1
14964: PPUSH
14965: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
14969: LD_EXP 37
14973: PUSH
14974: LD_EXP 38
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PPUSH
14983: LD_INT 35
14985: PPUSH
14986: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
14990: LD_INT 4
14992: PPUSH
14993: CALL_OW 67
// until IsInUnit ( guyA ) ;
14997: LD_EXP 37
15001: PPUSH
15002: CALL_OW 310
15006: IFFALSE 14990
// Wait ( 0 0$02 ) ;
15008: LD_INT 70
15010: PPUSH
15011: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
15015: LD_EXP 37
15019: PPUSH
15020: LD_STRING D1-A-19
15022: PPUSH
15023: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
15027: LD_EXP 38
15031: PPUSH
15032: LD_STRING D1-B-19
15034: PPUSH
15035: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
15039: LD_EXP 37
15043: PPUSH
15044: LD_STRING D1-A-20
15046: PPUSH
15047: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
15051: LD_INT 10
15053: PPUSH
15054: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
15058: LD_EXP 38
15062: PPUSH
15063: LD_STRING D1-B-20
15065: PPUSH
15066: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
15070: LD_EXP 37
15074: PPUSH
15075: LD_STRING D1-A-21
15077: PPUSH
15078: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
15082: LD_EXP 38
15086: PPUSH
15087: LD_STRING D1-B-21
15089: PPUSH
15090: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
15094: LD_EXP 37
15098: PPUSH
15099: LD_STRING D1-A-22
15101: PPUSH
15102: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
15106: LD_EXP 38
15110: PPUSH
15111: LD_STRING D1-B-22
15113: PPUSH
15114: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
15118: LD_EXP 37
15122: PPUSH
15123: LD_STRING D1-A-23
15125: PPUSH
15126: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
15130: LD_EXP 38
15134: PPUSH
15135: LD_STRING D1-B-23
15137: PPUSH
15138: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
15142: LD_EXP 37
15146: PPUSH
15147: LD_STRING D1-A-24
15149: PPUSH
15150: CALL_OW 88
// InGameOff ;
15154: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
15158: LD_STRING M_main
15160: PPUSH
15161: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
15165: LD_INT 4
15167: PPUSH
15168: LD_INT 1
15170: PPUSH
15171: CALL_OW 343
// game_status := true ;
15175: LD_ADDR_EXP 28
15179: PUSH
15180: LD_INT 1
15182: ST_TO_ADDR
// end ;
15183: LD_VAR 0 1
15187: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
15188: LD_INT 1
15190: PPUSH
15191: CALL 6875 0 1
15195: PUSH
15196: LD_INT 0
15198: GREATER
15199: IFFALSE 15301
15201: GO 15203
15203: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15204: LD_INT 35
15206: PPUSH
15207: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
15211: LD_INT 1
15213: PPUSH
15214: CALL 6875 0 1
15218: PUSH
15219: LD_INT 1
15221: ARRAY
15222: PPUSH
15223: CALL_OW 461
15227: PUSH
15228: LD_INT 1
15230: NONEQUAL
15231: IFFALSE 15204
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
15233: LD_EXP 37
15237: PPUSH
15238: CALL_OW 300
15242: PUSH
15243: LD_EXP 38
15247: PPUSH
15248: CALL_OW 300
15252: AND
15253: PUSH
15254: LD_EXP 29
15258: NOT
15259: AND
15260: IFFALSE 15286
// begin Say ( guyA , DL-A-1 ) ;
15262: LD_EXP 37
15266: PPUSH
15267: LD_STRING DL-A-1
15269: PPUSH
15270: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
15274: LD_EXP 38
15278: PPUSH
15279: LD_STRING DL-B-1
15281: PPUSH
15282: CALL_OW 88
// end ; if not helps_can_arrive then
15286: LD_EXP 30
15290: NOT
15291: IFFALSE 15301
// helps_can_arrive := true ;
15293: LD_ADDR_EXP 30
15297: PUSH
15298: LD_INT 1
15300: ST_TO_ADDR
// end ;
15301: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
15302: LD_INT 1
15304: PPUSH
15305: CALL 6875 0 1
15309: PUSH
15310: LD_INT 0
15312: GREATER
15313: PUSH
15314: LD_EXP 37
15318: PPUSH
15319: CALL_OW 300
15323: AND
15324: PUSH
15325: LD_EXP 38
15329: PPUSH
15330: CALL_OW 300
15334: AND
15335: PUSH
15336: LD_INT 22
15338: PUSH
15339: LD_INT 1
15341: PUSH
15342: EMPTY
15343: LIST
15344: LIST
15345: PUSH
15346: LD_INT 25
15348: PUSH
15349: LD_INT 12
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PPUSH
15360: CALL_OW 69
15364: PUSH
15365: LD_INT 0
15367: EQUAL
15368: AND
15369: PUSH
15370: LD_INT 1
15372: PPUSH
15373: LD_INT 25
15375: PUSH
15376: LD_INT 12
15378: PUSH
15379: EMPTY
15380: LIST
15381: LIST
15382: PPUSH
15383: CALL_OW 69
15387: PPUSH
15388: LD_EXP 37
15392: PPUSH
15393: CALL_OW 74
15397: PPUSH
15398: CALL_OW 292
15402: AND
15403: IFFALSE 15444
15405: GO 15407
15407: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
15408: LD_EXP 37
15412: PPUSH
15413: LD_STRING DA-A-1
15415: PPUSH
15416: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
15420: LD_EXP 38
15424: PPUSH
15425: LD_STRING DA-B-1
15427: PPUSH
15428: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
15432: LD_EXP 37
15436: PPUSH
15437: LD_STRING DA-A-2
15439: PPUSH
15440: CALL_OW 88
// end ;
15444: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
15445: LD_EXP 28
15449: PUSH
15450: LD_EXP 37
15454: PPUSH
15455: LD_INT 6
15457: PPUSH
15458: CALL_OW 299
15462: PUSH
15463: LD_INT 7
15465: LESS
15466: AND
15467: IFFALSE 15520
15469: GO 15471
15471: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
15472: LD_INT 117
15474: PPUSH
15475: LD_INT 50
15477: PPUSH
15478: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
15482: LD_INT 1
15484: PPUSH
15485: CALL 10616 0 1
15489: PUSH
15490: LD_INT 2
15492: ARRAY
15493: PPUSH
15494: LD_STRING D5-A-1
15496: PPUSH
15497: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
15501: LD_INT 1
15503: PPUSH
15504: CALL 10616 0 1
15508: PUSH
15509: LD_INT 1
15511: ARRAY
15512: PPUSH
15513: LD_STRING D5-B-1
15515: PPUSH
15516: CALL_OW 88
// end ;
15520: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
15521: LD_INT 7
15523: PPUSH
15524: LD_INT 22
15526: PUSH
15527: LD_INT 1
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: PPUSH
15534: CALL_OW 70
15538: PUSH
15539: LD_INT 0
15541: GREATER
15542: IFFALSE 15687
15544: GO 15546
15546: DISABLE
// begin Wait ( 0 0$03 ) ;
15547: LD_INT 105
15549: PPUSH
15550: CALL_OW 67
// DialogueOn ;
15554: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
15558: LD_INT 1
15560: PPUSH
15561: CALL 10616 0 1
15565: PUSH
15566: LD_INT 1
15568: ARRAY
15569: PPUSH
15570: LD_STRING D6-A-1
15572: PPUSH
15573: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15577: LD_INT 1
15579: PPUSH
15580: CALL 10616 0 1
15584: PUSH
15585: LD_INT 2
15587: ARRAY
15588: PPUSH
15589: LD_STRING D6-B-1
15591: PPUSH
15592: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15596: LD_INT 95
15598: PPUSH
15599: LD_INT 8
15601: PPUSH
15602: LD_INT 1
15604: PPUSH
15605: LD_INT 20
15607: PPUSH
15608: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15612: LD_INT 10
15614: PPUSH
15615: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15619: LD_INT 1
15621: PPUSH
15622: CALL 10616 0 1
15626: PUSH
15627: LD_INT 1
15629: ARRAY
15630: PPUSH
15631: LD_STRING D6-A-2
15633: PPUSH
15634: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15638: LD_INT 1
15640: PPUSH
15641: CALL 10616 0 1
15645: PUSH
15646: LD_INT 2
15648: ARRAY
15649: PPUSH
15650: LD_STRING D6-B-2
15652: PPUSH
15653: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15657: LD_INT 1
15659: PPUSH
15660: CALL 10616 0 1
15664: PUSH
15665: LD_INT 1
15667: ARRAY
15668: PPUSH
15669: LD_STRING D6-A-3
15671: PPUSH
15672: CALL_OW 88
// DialogueOff ;
15676: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15680: LD_STRING M_base
15682: PPUSH
15683: CALL_OW 337
// end ;
15687: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15688: LD_EXP 29
15692: NOT
15693: PUSH
15694: LD_INT 22
15696: PUSH
15697: LD_INT 3
15699: PUSH
15700: EMPTY
15701: LIST
15702: LIST
15703: PUSH
15704: LD_INT 21
15706: PUSH
15707: LD_INT 2
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: PPUSH
15718: CALL_OW 69
15722: PUSH
15723: LD_INT 0
15725: GREATER
15726: AND
15727: IFFALSE 15860
15729: GO 15731
15731: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15732: LD_INT 35
15734: PPUSH
15735: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15739: LD_INT 22
15741: PUSH
15742: LD_INT 3
15744: PUSH
15745: EMPTY
15746: LIST
15747: LIST
15748: PUSH
15749: LD_INT 21
15751: PUSH
15752: LD_INT 2
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: PPUSH
15763: CALL_OW 69
15767: PPUSH
15768: LD_INT 1
15770: PPUSH
15771: CALL 10616 0 1
15775: PUSH
15776: LD_INT 1
15778: ARRAY
15779: PPUSH
15780: CALL_OW 74
15784: PPUSH
15785: LD_INT 1
15787: PPUSH
15788: CALL 10616 0 1
15792: PUSH
15793: LD_INT 1
15795: ARRAY
15796: PPUSH
15797: CALL_OW 296
15801: PUSH
15802: LD_INT 7
15804: LESS
15805: IFFALSE 15732
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15807: LD_INT 1
15809: PPUSH
15810: CALL 10616 0 1
15814: PUSH
15815: LD_INT 1
15817: ARRAY
15818: PPUSH
15819: LD_STRING DR-A-1
15821: PPUSH
15822: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15826: LD_INT 1
15828: PPUSH
15829: CALL 10616 0 1
15833: PUSH
15834: LD_INT 2
15836: ARRAY
15837: PPUSH
15838: LD_STRING DR-B-1
15840: PPUSH
15841: CALL_OW 88
// Wait ( 3 3$00 ) ;
15845: LD_INT 6300
15847: PPUSH
15848: CALL_OW 67
// ru_spotted := true ;
15852: LD_ADDR_EXP 15
15856: PUSH
15857: LD_INT 1
15859: ST_TO_ADDR
// end ;
15860: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15861: LD_INT 35
15863: PPUSH
15864: CALL_OW 300
15868: NOT
15869: IFFALSE 15893
15871: GO 15873
15873: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15874: LD_INT 1
15876: PPUSH
15877: CALL 10616 0 1
15881: PUSH
15882: LD_INT 1
15884: ARRAY
15885: PPUSH
15886: LD_STRING DDR-A-1
15888: PPUSH
15889: CALL_OW 88
15893: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15894: LD_INT 1
15896: PPUSH
15897: LD_INT 30
15899: PPUSH
15900: CALL 6724 0 2
15904: IFFALSE 15986
15906: GO 15908
15908: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15909: LD_INT 35
15911: PPUSH
15912: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15916: LD_INT 1
15918: PPUSH
15919: LD_INT 30
15921: PPUSH
15922: CALL 6724 0 2
15926: PUSH
15927: LD_INT 1
15929: ARRAY
15930: PPUSH
15931: CALL_OW 461
15935: PUSH
15936: LD_INT 1
15938: NONEQUAL
15939: IFFALSE 15909
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15941: LD_INT 1
15943: PPUSH
15944: CALL 10616 0 1
15948: PUSH
15949: LD_INT 1
15951: ARRAY
15952: PPUSH
15953: LD_STRING D8-A-1
15955: PPUSH
15956: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
15960: LD_INT 1
15962: PPUSH
15963: CALL 10616 0 1
15967: PUSH
15968: LD_INT 2
15970: ARRAY
15971: PPUSH
15972: LD_STRING D8-B-1
15974: PPUSH
15975: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
15979: LD_STRING M_mineok
15981: PPUSH
15982: CALL_OW 337
// end ;
15986: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
15987: LD_INT 22
15989: PUSH
15990: LD_INT 1
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: PUSH
15997: LD_INT 30
15999: PUSH
16000: LD_INT 0
16002: PUSH
16003: EMPTY
16004: LIST
16005: LIST
16006: PUSH
16007: LD_INT 3
16009: PUSH
16010: LD_INT 57
16012: PUSH
16013: EMPTY
16014: LIST
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: PUSH
16020: EMPTY
16021: LIST
16022: LIST
16023: LIST
16024: PPUSH
16025: CALL_OW 69
16029: PUSH
16030: LD_INT 1
16032: GREATER
16033: PUSH
16034: LD_INT 22
16036: PUSH
16037: LD_INT 1
16039: PUSH
16040: EMPTY
16041: LIST
16042: LIST
16043: PUSH
16044: LD_INT 30
16046: PUSH
16047: LD_INT 0
16049: PUSH
16050: EMPTY
16051: LIST
16052: LIST
16053: PUSH
16054: LD_INT 3
16056: PUSH
16057: LD_INT 57
16059: PUSH
16060: EMPTY
16061: LIST
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: PUSH
16067: EMPTY
16068: LIST
16069: LIST
16070: LIST
16071: PPUSH
16072: CALL_OW 69
16076: PUSH
16077: LD_INT 1
16079: EQUAL
16080: PUSH
16081: LD_INT 35
16083: PPUSH
16084: CALL_OW 300
16088: NOT
16089: AND
16090: OR
16091: IFFALSE 16143
16093: GO 16095
16095: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
16096: LD_INT 22
16098: PUSH
16099: LD_INT 1
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PUSH
16106: LD_INT 25
16108: PUSH
16109: LD_INT 2
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: PPUSH
16120: CALL_OW 69
16124: PUSH
16125: LD_INT 1
16127: ARRAY
16128: PPUSH
16129: LD_STRING D7-A-1
16131: PPUSH
16132: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
16136: LD_STRING M_baseok
16138: PPUSH
16139: CALL_OW 337
// end ;
16143: END
// every 0 0$01 trigger mine_ck do
16144: LD_EXP 34
16148: IFFALSE 16179
16150: GO 16152
16152: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
16153: LD_INT 1
16155: PPUSH
16156: CALL 10616 0 1
16160: PUSH
16161: LD_INT 1
16163: ARRAY
16164: PPUSH
16165: LD_STRING D9-A-1
16167: PPUSH
16168: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
16172: LD_STRING M_minedest
16174: PPUSH
16175: CALL_OW 337
// end ;
16179: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
16180: LD_EXP 28
16184: IFFALSE 16690
16186: GO 16188
16188: DISABLE
16189: LD_INT 0
16191: PPUSH
16192: PPUSH
16193: PPUSH
16194: PPUSH
16195: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
16196: LD_OWVAR 67
16200: PPUSH
16201: CALL 12517 0 1
// if not helps_can_arrive then
16205: LD_EXP 30
16209: NOT
16210: IFFALSE 16238
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
16212: LD_EXP 39
16216: PUSH
16217: LD_INT 1
16219: ARRAY
16220: PPUSH
16221: LD_STRING DB-Delay
16223: PPUSH
16224: CALL_OW 94
// time := 10 10$00 ;
16228: LD_ADDR_VAR 0 1
16232: PUSH
16233: LD_INT 21000
16235: ST_TO_ADDR
// end else
16236: GO 16246
// time := 3 3$00 ;
16238: LD_ADDR_VAR 0 1
16242: PUSH
16243: LD_INT 6300
16245: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
16246: LD_ADDR_VAR 0 1
16250: PUSH
16251: LD_VAR 0 1
16255: PUSH
16256: LD_INT 35
16258: MINUS
16259: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
16260: LD_INT 35
16262: PPUSH
16263: CALL_OW 67
// end until time = 0 0$00 ;
16267: LD_VAR 0 1
16271: PUSH
16272: LD_INT 0
16274: EQUAL
16275: IFFALSE 16246
// helps_arrive := true ;
16277: LD_ADDR_EXP 29
16281: PUSH
16282: LD_INT 1
16284: ST_TO_ADDR
// if IsLive ( guyA ) then
16285: LD_EXP 37
16289: PPUSH
16290: CALL_OW 300
16294: IFFALSE 16308
// r := guyA else
16296: LD_ADDR_VAR 0 4
16300: PUSH
16301: LD_EXP 37
16305: ST_TO_ADDR
16306: GO 16318
// r := guyB ;
16308: LD_ADDR_VAR 0 4
16312: PUSH
16313: LD_EXP 38
16317: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
16318: LD_EXP 39
16322: PUSH
16323: LD_INT 1
16325: ARRAY
16326: PPUSH
16327: LD_STRING D2-A-1
16329: PPUSH
16330: CALL_OW 94
// Say ( r , D2-B-1 ) ;
16334: LD_VAR 0 4
16338: PPUSH
16339: LD_STRING D2-B-1
16341: PPUSH
16342: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
16346: LD_EXP 39
16350: PUSH
16351: LD_INT 1
16353: ARRAY
16354: PPUSH
16355: LD_STRING D2-A-2
16357: PPUSH
16358: CALL_OW 94
// Say ( r , D2-B-2 ) ;
16362: LD_VAR 0 4
16366: PPUSH
16367: LD_STRING D2-B-2
16369: PPUSH
16370: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
16374: LD_EXP 39
16378: PUSH
16379: LD_INT 1
16381: ARRAY
16382: PPUSH
16383: LD_STRING D2-A-3
16385: PPUSH
16386: CALL_OW 94
// Say ( r , D2-B-3 ) ;
16390: LD_VAR 0 4
16394: PPUSH
16395: LD_STRING D2-B-3
16397: PPUSH
16398: CALL_OW 88
// to_veh := [ ] ;
16402: LD_ADDR_VAR 0 5
16406: PUSH
16407: EMPTY
16408: ST_TO_ADDR
// for i = 1 to Beta_Squad do
16409: LD_ADDR_VAR 0 2
16413: PUSH
16414: DOUBLE
16415: LD_INT 1
16417: DEC
16418: ST_TO_ADDR
16419: LD_EXP 39
16423: PUSH
16424: FOR_TO
16425: IFFALSE 16688
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
16427: LD_EXP 39
16431: PUSH
16432: LD_VAR 0 2
16436: ARRAY
16437: PPUSH
16438: CALL_OW 110
16442: PUSH
16443: LD_INT 3
16445: EQUAL
16446: IFFALSE 16472
// to_veh := to_veh ^ Beta_Squad [ i ] else
16448: LD_ADDR_VAR 0 5
16452: PUSH
16453: LD_VAR 0 5
16457: PUSH
16458: LD_EXP 39
16462: PUSH
16463: LD_VAR 0 2
16467: ARRAY
16468: ADD
16469: ST_TO_ADDR
16470: GO 16597
// if GetTag ( Beta_Squad [ i ] ) = 5 then
16472: LD_EXP 39
16476: PUSH
16477: LD_VAR 0 2
16481: ARRAY
16482: PPUSH
16483: CALL_OW 110
16487: PUSH
16488: LD_INT 5
16490: EQUAL
16491: IFFALSE 16576
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
16493: LD_EXP 39
16497: PUSH
16498: LD_VAR 0 2
16502: ARRAY
16503: PPUSH
16504: LD_INT 4
16506: PPUSH
16507: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16511: LD_EXP 39
16515: PUSH
16516: LD_VAR 0 2
16520: ARRAY
16521: PPUSH
16522: LD_INT 5
16524: PPUSH
16525: LD_INT 0
16527: PPUSH
16528: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
16532: LD_VAR 0 5
16536: PUSH
16537: LD_INT 1
16539: ARRAY
16540: PPUSH
16541: LD_EXP 39
16545: PUSH
16546: LD_VAR 0 2
16550: ARRAY
16551: PPUSH
16552: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16556: LD_ADDR_VAR 0 5
16560: PUSH
16561: LD_VAR 0 5
16565: PPUSH
16566: LD_INT 1
16568: PPUSH
16569: CALL_OW 3
16573: ST_TO_ADDR
// end else
16574: GO 16597
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16576: LD_EXP 39
16580: PUSH
16581: LD_VAR 0 2
16585: ARRAY
16586: PPUSH
16587: LD_INT 5
16589: PPUSH
16590: LD_INT 0
16592: PPUSH
16593: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16597: LD_EXP 39
16601: PUSH
16602: LD_VAR 0 2
16606: ARRAY
16607: PPUSH
16608: LD_INT 165
16610: PPUSH
16611: LD_INT 105
16613: PPUSH
16614: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16618: LD_INT 70
16620: PPUSH
16621: LD_INT 140
16623: PPUSH
16624: CALL_OW 12
16628: PPUSH
16629: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16633: LD_EXP 39
16637: PUSH
16638: LD_VAR 0 2
16642: ARRAY
16643: PPUSH
16644: LD_INT 1
16646: PPUSH
16647: CALL_OW 235
// if i = 1 then
16651: LD_VAR 0 2
16655: PUSH
16656: LD_INT 1
16658: EQUAL
16659: IFFALSE 16671
// CenterNowOnXY ( 168 , 109 ) ;
16661: LD_INT 168
16663: PPUSH
16664: LD_INT 109
16666: PPUSH
16667: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16671: LD_EXP 39
16675: PUSH
16676: LD_VAR 0 2
16680: ARRAY
16681: PPUSH
16682: CALL_OW 141
// end ;
16686: GO 16424
16688: POP
16689: POP
// end ;
16690: PPOPN 5
16692: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16693: LD_EXP 29
16697: IFFALSE 17726
16699: GO 16701
16701: DISABLE
16702: LD_INT 0
16704: PPUSH
16705: PPUSH
// begin Wait ( 5 5$00 ) ;
16706: LD_INT 10500
16708: PPUSH
16709: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16713: LD_OWVAR 67
16717: PPUSH
16718: CALL 13206 0 1
// to_veh := [ ] ;
16722: LD_ADDR_VAR 0 2
16726: PUSH
16727: EMPTY
16728: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16729: LD_ADDR_VAR 0 1
16733: PUSH
16734: DOUBLE
16735: LD_INT 1
16737: DEC
16738: ST_TO_ADDR
16739: LD_EXP 40
16743: PUSH
16744: FOR_TO
16745: IFFALSE 16973
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16747: LD_EXP 40
16751: PUSH
16752: LD_VAR 0 1
16756: ARRAY
16757: PPUSH
16758: CALL_OW 110
16762: PUSH
16763: LD_INT 3
16765: EQUAL
16766: IFFALSE 16792
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16768: LD_ADDR_VAR 0 2
16772: PUSH
16773: LD_VAR 0 2
16777: PUSH
16778: LD_EXP 40
16782: PUSH
16783: LD_VAR 0 1
16787: ARRAY
16788: ADD
16789: ST_TO_ADDR
16790: GO 16917
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16792: LD_EXP 40
16796: PUSH
16797: LD_VAR 0 1
16801: ARRAY
16802: PPUSH
16803: CALL_OW 110
16807: PUSH
16808: LD_INT 5
16810: EQUAL
16811: IFFALSE 16896
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16813: LD_EXP 40
16817: PUSH
16818: LD_VAR 0 1
16822: ARRAY
16823: PPUSH
16824: LD_INT 4
16826: PPUSH
16827: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16831: LD_EXP 40
16835: PUSH
16836: LD_VAR 0 1
16840: ARRAY
16841: PPUSH
16842: LD_INT 5
16844: PPUSH
16845: LD_INT 0
16847: PPUSH
16848: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16852: LD_VAR 0 2
16856: PUSH
16857: LD_INT 1
16859: ARRAY
16860: PPUSH
16861: LD_EXP 40
16865: PUSH
16866: LD_VAR 0 1
16870: ARRAY
16871: PPUSH
16872: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16876: LD_ADDR_VAR 0 2
16880: PUSH
16881: LD_VAR 0 2
16885: PPUSH
16886: LD_INT 1
16888: PPUSH
16889: CALL_OW 3
16893: ST_TO_ADDR
// end else
16894: GO 16917
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16896: LD_EXP 40
16900: PUSH
16901: LD_VAR 0 1
16905: ARRAY
16906: PPUSH
16907: LD_INT 5
16909: PPUSH
16910: LD_INT 0
16912: PPUSH
16913: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16917: LD_EXP 40
16921: PUSH
16922: LD_VAR 0 1
16926: ARRAY
16927: PPUSH
16928: LD_INT 164
16930: PPUSH
16931: LD_INT 104
16933: PPUSH
16934: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16938: LD_INT 70
16940: PPUSH
16941: LD_INT 140
16943: PPUSH
16944: CALL_OW 12
16948: PPUSH
16949: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16953: LD_EXP 40
16957: PUSH
16958: LD_VAR 0 1
16962: ARRAY
16963: PPUSH
16964: LD_INT 1
16966: PPUSH
16967: CALL_OW 235
// end ;
16971: GO 16744
16973: POP
16974: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
16975: LD_EXP 40
16979: PUSH
16980: LD_INT 1
16982: ARRAY
16983: PPUSH
16984: LD_STRING D3-A-1
16986: PPUSH
16987: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
16991: LD_INT 1
16993: PPUSH
16994: CALL 10616 0 1
16998: PUSH
16999: LD_INT 1
17001: ARRAY
17002: PPUSH
17003: LD_STRING D3-B-1
17005: PPUSH
17006: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
17010: LD_EXP 40
17014: PUSH
17015: LD_INT 1
17017: ARRAY
17018: PPUSH
17019: LD_STRING D3-A-2
17021: PPUSH
17022: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
17026: LD_INT 1
17028: PPUSH
17029: CALL 10616 0 1
17033: PUSH
17034: LD_INT 1
17036: ARRAY
17037: PPUSH
17038: LD_STRING D3-B-2
17040: PPUSH
17041: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
17045: LD_EXP 40
17049: PUSH
17050: LD_INT 1
17052: ARRAY
17053: PPUSH
17054: LD_STRING D3-A-3
17056: PPUSH
17057: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
17061: LD_INT 1
17063: PPUSH
17064: CALL 10616 0 1
17068: PUSH
17069: LD_INT 1
17071: ARRAY
17072: PPUSH
17073: LD_STRING D3-B-3
17075: PPUSH
17076: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
17080: LD_EXP 40
17084: PUSH
17085: LD_INT 1
17087: ARRAY
17088: PPUSH
17089: LD_STRING D3-A-4
17091: PPUSH
17092: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
17096: LD_INT 1
17098: PPUSH
17099: CALL 10616 0 1
17103: PUSH
17104: LD_INT 1
17106: ARRAY
17107: PPUSH
17108: LD_STRING D3-B-4
17110: PPUSH
17111: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
17115: LD_EXP 40
17119: PUSH
17120: LD_INT 1
17122: ARRAY
17123: PPUSH
17124: LD_STRING D3-A-5
17126: PPUSH
17127: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
17131: LD_INT 1
17133: PPUSH
17134: CALL 10616 0 1
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PPUSH
17143: LD_STRING D3-B-5
17145: PPUSH
17146: CALL_OW 88
// for i = 1 to Gamma_Squad do
17150: LD_ADDR_VAR 0 1
17154: PUSH
17155: DOUBLE
17156: LD_INT 1
17158: DEC
17159: ST_TO_ADDR
17160: LD_EXP 40
17164: PUSH
17165: FOR_TO
17166: IFFALSE 17188
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
17168: LD_EXP 40
17172: PUSH
17173: LD_VAR 0 1
17177: ARRAY
17178: PPUSH
17179: LD_INT 1
17181: PPUSH
17182: CALL_OW 235
17186: GO 17165
17188: POP
17189: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
17190: LD_INT 6300
17192: PUSH
17193: LD_INT 10500
17195: PUSH
17196: LD_INT 11550
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: LIST
17203: PUSH
17204: LD_OWVAR 67
17208: ARRAY
17209: PPUSH
17210: CALL_OW 67
// AddZetaSquad ;
17214: CALL 13935 0 0
// Wait ( 0 0$10 ) ;
17218: LD_INT 350
17220: PPUSH
17221: CALL_OW 67
// to_veh := [ ] ;
17225: LD_ADDR_VAR 0 2
17229: PUSH
17230: EMPTY
17231: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
17232: LD_ADDR_VAR 0 1
17236: PUSH
17237: DOUBLE
17238: LD_INT 1
17240: DEC
17241: ST_TO_ADDR
17242: LD_EXP 41
17246: PUSH
17247: FOR_TO
17248: IFFALSE 17458
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
17250: LD_EXP 41
17254: PUSH
17255: LD_VAR 0 1
17259: ARRAY
17260: PPUSH
17261: CALL_OW 110
17265: PUSH
17266: LD_INT 3
17268: EQUAL
17269: IFFALSE 17295
// to_veh := to_veh ^ Zeta_Squad [ i ] else
17271: LD_ADDR_VAR 0 2
17275: PUSH
17276: LD_VAR 0 2
17280: PUSH
17281: LD_EXP 41
17285: PUSH
17286: LD_VAR 0 1
17290: ARRAY
17291: ADD
17292: ST_TO_ADDR
17293: GO 17420
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
17295: LD_EXP 41
17299: PUSH
17300: LD_VAR 0 1
17304: ARRAY
17305: PPUSH
17306: CALL_OW 110
17310: PUSH
17311: LD_INT 5
17313: EQUAL
17314: IFFALSE 17399
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
17316: LD_EXP 41
17320: PUSH
17321: LD_VAR 0 1
17325: ARRAY
17326: PPUSH
17327: LD_INT 4
17329: PPUSH
17330: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17334: LD_EXP 41
17338: PUSH
17339: LD_VAR 0 1
17343: ARRAY
17344: PPUSH
17345: LD_INT 5
17347: PPUSH
17348: LD_INT 0
17350: PPUSH
17351: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
17355: LD_VAR 0 2
17359: PUSH
17360: LD_INT 1
17362: ARRAY
17363: PPUSH
17364: LD_EXP 41
17368: PUSH
17369: LD_VAR 0 1
17373: ARRAY
17374: PPUSH
17375: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
17379: LD_ADDR_VAR 0 2
17383: PUSH
17384: LD_VAR 0 2
17388: PPUSH
17389: LD_INT 1
17391: PPUSH
17392: CALL_OW 3
17396: ST_TO_ADDR
// end else
17397: GO 17420
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17399: LD_EXP 41
17403: PUSH
17404: LD_VAR 0 1
17408: ARRAY
17409: PPUSH
17410: LD_INT 5
17412: PPUSH
17413: LD_INT 0
17415: PPUSH
17416: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
17420: LD_EXP 41
17424: PUSH
17425: LD_VAR 0 1
17429: ARRAY
17430: PPUSH
17431: LD_INT 165
17433: PPUSH
17434: LD_INT 105
17436: PPUSH
17437: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
17441: LD_INT 70
17443: PPUSH
17444: LD_INT 140
17446: PPUSH
17447: CALL_OW 12
17451: PPUSH
17452: CALL_OW 67
// end ;
17456: GO 17247
17458: POP
17459: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
17460: LD_EXP 41
17464: PUSH
17465: LD_INT 1
17467: ARRAY
17468: PPUSH
17469: LD_STRING D4-A-1
17471: PPUSH
17472: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
17476: LD_INT 1
17478: PPUSH
17479: CALL 10616 0 1
17483: PUSH
17484: LD_INT 1
17486: ARRAY
17487: PPUSH
17488: LD_STRING D4-B-1
17490: PPUSH
17491: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
17495: LD_EXP 41
17499: PUSH
17500: LD_INT 1
17502: ARRAY
17503: PPUSH
17504: LD_STRING D4-A-2
17506: PPUSH
17507: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
17511: LD_INT 1
17513: PPUSH
17514: CALL 10616 0 1
17518: PUSH
17519: LD_INT 1
17521: ARRAY
17522: PPUSH
17523: LD_STRING D4-B-2
17525: PPUSH
17526: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
17530: LD_EXP 41
17534: PUSH
17535: LD_INT 1
17537: ARRAY
17538: PPUSH
17539: LD_STRING D4-A-3
17541: PPUSH
17542: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
17546: LD_INT 1
17548: PPUSH
17549: CALL 10616 0 1
17553: PUSH
17554: LD_INT 1
17556: ARRAY
17557: PPUSH
17558: LD_STRING D4-B-3
17560: PPUSH
17561: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
17565: LD_EXP 41
17569: PUSH
17570: LD_INT 1
17572: ARRAY
17573: PPUSH
17574: LD_STRING D4-A-4
17576: PPUSH
17577: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17581: LD_INT 1
17583: PPUSH
17584: CALL 10616 0 1
17588: PUSH
17589: LD_INT 1
17591: ARRAY
17592: PPUSH
17593: LD_STRING D4-B-4
17595: PPUSH
17596: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17600: LD_EXP 41
17604: PUSH
17605: LD_INT 1
17607: ARRAY
17608: PPUSH
17609: LD_STRING D4-A-5
17611: PPUSH
17612: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17616: LD_INT 1
17618: PPUSH
17619: CALL 10616 0 1
17623: PUSH
17624: LD_INT 1
17626: ARRAY
17627: PPUSH
17628: LD_STRING D4-B-5
17630: PPUSH
17631: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17635: LD_EXP 41
17639: PUSH
17640: LD_INT 1
17642: ARRAY
17643: PPUSH
17644: LD_STRING D4-A-6
17646: PPUSH
17647: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17651: LD_INT 1
17653: PPUSH
17654: CALL 10616 0 1
17658: PUSH
17659: LD_INT 1
17661: ARRAY
17662: PPUSH
17663: LD_STRING D4-B-6
17665: PPUSH
17666: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17670: LD_EXP 41
17674: PUSH
17675: LD_INT 1
17677: ARRAY
17678: PPUSH
17679: LD_STRING D4-A-7
17681: PPUSH
17682: CALL_OW 94
// for i = 1 to Zeta_Squad do
17686: LD_ADDR_VAR 0 1
17690: PUSH
17691: DOUBLE
17692: LD_INT 1
17694: DEC
17695: ST_TO_ADDR
17696: LD_EXP 41
17700: PUSH
17701: FOR_TO
17702: IFFALSE 17724
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17704: LD_EXP 41
17708: PUSH
17709: LD_VAR 0 1
17713: ARRAY
17714: PPUSH
17715: LD_INT 1
17717: PPUSH
17718: CALL_OW 235
17722: GO 17701
17724: POP
17725: POP
// end ;
17726: PPOPN 2
17728: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17729: LD_INT 11
17731: PPUSH
17732: LD_INT 22
17734: PUSH
17735: LD_OWVAR 2
17739: PUSH
17740: EMPTY
17741: LIST
17742: LIST
17743: PPUSH
17744: CALL_OW 70
17748: PUSH
17749: LD_INT 0
17751: GREATER
17752: IFFALSE 17777
17754: GO 17756
17756: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17757: LD_EXP 37
17761: PPUSH
17762: LD_STRING D10-A-1
17764: PPUSH
17765: CALL_OW 88
// ru_spotted := true ;
17769: LD_ADDR_EXP 15
17773: PUSH
17774: LD_INT 1
17776: ST_TO_ADDR
// end ;
17777: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17778: LD_EXP 37
17782: PPUSH
17783: CALL_OW 301
17787: PUSH
17788: LD_EXP 38
17792: PPUSH
17793: CALL_OW 301
17797: OR
17798: IFFALSE 17810
17800: GO 17802
17802: DISABLE
// begin YouLost ( DieP ) ;
17803: LD_STRING DieP
17805: PPUSH
17806: CALL_OW 104
// end ;
17810: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17811: LD_INT 34
17813: PUSH
17814: LD_INT 8
17816: PUSH
17817: EMPTY
17818: LIST
17819: LIST
17820: PPUSH
17821: CALL_OW 69
17825: IFFALSE 17838
17827: GO 17829
17829: DISABLE
// sib_bomb_constructed := true ;
17830: LD_ADDR_EXP 35
17834: PUSH
17835: LD_INT 1
17837: ST_TO_ADDR
17838: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17839: LD_EXP 28
17843: PUSH
17844: LD_INT 22
17846: PUSH
17847: LD_INT 3
17849: PUSH
17850: EMPTY
17851: LIST
17852: LIST
17853: PPUSH
17854: CALL_OW 69
17858: PUSH
17859: LD_INT 0
17861: EQUAL
17862: AND
17863: IFFALSE 18035
17865: GO 17867
17867: DISABLE
17868: LD_INT 0
17870: PPUSH
// begin game_status := false ;
17871: LD_ADDR_EXP 28
17875: PUSH
17876: LD_INT 0
17878: ST_TO_ADDR
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17879: LD_OWVAR 1
17883: PUSH
17884: LD_INT 35
17886: DIVREAL
17887: PUSH
17888: LD_INT 60
17890: DIVREAL
17891: PUSH
17892: LD_INT 70
17894: PUSH
17895: LD_INT 60
17897: PUSH
17898: LD_INT 50
17900: PUSH
17901: EMPTY
17902: LIST
17903: LIST
17904: LIST
17905: PUSH
17906: LD_OWVAR 67
17910: ARRAY
17911: LESS
17912: IFFALSE 17926
// AddMedal ( play , 1 ) else
17914: LD_STRING play
17916: PPUSH
17917: LD_INT 1
17919: PPUSH
17920: CALL_OW 101
17924: GO 17937
// AddMedal ( play , - 1 ) ;
17926: LD_STRING play
17928: PPUSH
17929: LD_INT 1
17931: NEG
17932: PPUSH
17933: CALL_OW 101
// if sib_bomb_constructed then
17937: LD_EXP 35
17941: IFFALSE 17955
// AddMedal ( sibbomb , 1 ) else
17943: LD_STRING sibbomb
17945: PPUSH
17946: LD_INT 1
17948: PPUSH
17949: CALL_OW 101
17953: GO 17966
// AddMedal ( sibbomb , - 1 ) ;
17955: LD_STRING sibbomb
17957: PPUSH
17958: LD_INT 1
17960: NEG
17961: PPUSH
17962: CALL_OW 101
// if mine_constructed and not mine_ck then
17966: LD_EXP 36
17970: PUSH
17971: LD_EXP 34
17975: NOT
17976: AND
17977: IFFALSE 17989
// AddMedal ( mine , 1 ) ;
17979: LD_STRING mine
17981: PPUSH
17982: LD_INT 1
17984: PPUSH
17985: CALL_OW 101
// if mine_ck then
17989: LD_EXP 34
17993: IFFALSE 18006
// AddMedal ( mine , - 1 ) ;
17995: LD_STRING mine
17997: PPUSH
17998: LD_INT 1
18000: NEG
18001: PPUSH
18002: CALL_OW 101
// if not mine_constructed then
18006: LD_EXP 36
18010: NOT
18011: IFFALSE 18024
// AddMedal ( mine , - 2 ) ;
18013: LD_STRING mine
18015: PPUSH
18016: LD_INT 2
18018: NEG
18019: PPUSH
18020: CALL_OW 101
// GiveMedals ( Main ) ;
18024: LD_STRING Main
18026: PPUSH
18027: CALL_OW 102
// YouWin ;
18031: CALL_OW 103
// end ; end_of_file
18035: PPOPN 1
18037: END
// every 0 0$03 trigger game_status do var time ;
18038: LD_EXP 28
18042: IFFALSE 18207
18044: GO 18046
18046: DISABLE
18047: LD_INT 0
18049: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
18050: LD_ADDR_VAR 0 1
18054: PUSH
18055: LD_INT 1050
18057: PUSH
18058: LD_INT 1575
18060: PUSH
18061: LD_INT 2100
18063: PUSH
18064: EMPTY
18065: LIST
18066: LIST
18067: LIST
18068: PUSH
18069: LD_OWVAR 67
18073: ARRAY
18074: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
18075: LD_VAR 0 1
18079: PUSH
18080: LD_INT 0
18082: PPUSH
18083: LD_INT 420
18085: PPUSH
18086: CALL_OW 12
18090: PLUS
18091: PPUSH
18092: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
18096: LD_INT 1
18098: PPUSH
18099: LD_INT 5
18101: PPUSH
18102: CALL_OW 12
18106: PPUSH
18107: LD_INT 1
18109: PPUSH
18110: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
18114: LD_INT 105
18116: PPUSH
18117: LD_INT 1050
18119: PPUSH
18120: CALL_OW 12
18124: PPUSH
18125: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
18129: LD_INT 1
18131: PPUSH
18132: LD_INT 5
18134: PPUSH
18135: CALL_OW 12
18139: PPUSH
18140: LD_INT 148
18142: PPUSH
18143: LD_INT 107
18145: PPUSH
18146: LD_INT 20
18148: PPUSH
18149: LD_INT 1
18151: PPUSH
18152: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
18156: LD_OWVAR 1
18160: PUSH
18161: LD_INT 44100
18163: PUSH
18164: LD_INT 37800
18166: PUSH
18167: LD_INT 33600
18169: PUSH
18170: EMPTY
18171: LIST
18172: LIST
18173: LIST
18174: PUSH
18175: LD_OWVAR 67
18179: ARRAY
18180: MOD
18181: IFFALSE 18197
// time := time + 0 0$20 ;
18183: LD_ADDR_VAR 0 1
18187: PUSH
18188: LD_VAR 0 1
18192: PUSH
18193: LD_INT 700
18195: PLUS
18196: ST_TO_ADDR
// end until game_status = false ;
18197: LD_EXP 28
18201: PUSH
18202: LD_INT 0
18204: EQUAL
18205: IFFALSE 18075
// end ;
18207: PPOPN 1
18209: END
// every 0 0$03 trigger game_status do var time ;
18210: LD_EXP 28
18214: IFFALSE 18368
18216: GO 18218
18218: DISABLE
18219: LD_INT 0
18221: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
18222: LD_ADDR_VAR 0 1
18226: PUSH
18227: LD_INT 700
18229: PUSH
18230: LD_INT 875
18232: PUSH
18233: LD_INT 1400
18235: PUSH
18236: EMPTY
18237: LIST
18238: LIST
18239: LIST
18240: PUSH
18241: LD_OWVAR 67
18245: ARRAY
18246: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18247: LD_VAR 0 1
18251: PUSH
18252: LD_INT 0
18254: PPUSH
18255: LD_INT 385
18257: PPUSH
18258: CALL_OW 12
18262: PLUS
18263: PPUSH
18264: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
18268: LD_INT 1
18270: PPUSH
18271: LD_INT 5
18273: PPUSH
18274: CALL_OW 12
18278: PPUSH
18279: LD_INT 102
18281: PPUSH
18282: LD_INT 6
18284: PPUSH
18285: LD_INT 25
18287: PPUSH
18288: LD_INT 1
18290: PPUSH
18291: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
18295: LD_OWVAR 1
18299: PUSH
18300: LD_INT 52500
18302: PUSH
18303: LD_INT 46200
18305: PUSH
18306: LD_INT 42000
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: LIST
18313: PUSH
18314: LD_OWVAR 67
18318: ARRAY
18319: MOD
18320: IFFALSE 18336
// time := time + 0 0$25 ;
18322: LD_ADDR_VAR 0 1
18326: PUSH
18327: LD_VAR 0 1
18331: PUSH
18332: LD_INT 875
18334: PLUS
18335: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
18336: LD_OWVAR 1
18340: PUSH
18341: LD_INT 231000
18343: MOD
18344: PUSH
18345: LD_INT 0
18347: EQUAL
18348: IFFALSE 18358
// time := 0 0$30 ;
18350: LD_ADDR_VAR 0 1
18354: PUSH
18355: LD_INT 1050
18357: ST_TO_ADDR
// end until game_status = false ;
18358: LD_EXP 28
18362: PUSH
18363: LD_INT 0
18365: EQUAL
18366: IFFALSE 18247
// end ;
18368: PPOPN 1
18370: END
// every 0 0$03 trigger game_status do var time ;
18371: LD_EXP 28
18375: IFFALSE 18511
18377: GO 18379
18379: DISABLE
18380: LD_INT 0
18382: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
18383: LD_ADDR_VAR 0 1
18387: PUSH
18388: LD_INT 1050
18390: PUSH
18391: LD_INT 1575
18393: PUSH
18394: LD_INT 1750
18396: PUSH
18397: EMPTY
18398: LIST
18399: LIST
18400: LIST
18401: PUSH
18402: LD_OWVAR 67
18406: ARRAY
18407: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18408: LD_VAR 0 1
18412: PUSH
18413: LD_INT 0
18415: PPUSH
18416: LD_INT 385
18418: PPUSH
18419: CALL_OW 12
18423: PLUS
18424: PPUSH
18425: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
18429: LD_INT 1
18431: PPUSH
18432: LD_INT 5
18434: PPUSH
18435: CALL_OW 12
18439: PPUSH
18440: LD_INT 51
18442: PPUSH
18443: LD_INT 74
18445: PPUSH
18446: LD_INT 25
18448: PPUSH
18449: LD_INT 1
18451: PPUSH
18452: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
18456: LD_OWVAR 1
18460: PUSH
18461: LD_INT 84000
18463: PUSH
18464: LD_INT 105000
18466: PUSH
18467: LD_INT 136500
18469: PUSH
18470: EMPTY
18471: LIST
18472: LIST
18473: LIST
18474: PUSH
18475: LD_OWVAR 67
18479: ARRAY
18480: MOD
18481: PUSH
18482: LD_INT 0
18484: EQUAL
18485: IFFALSE 18501
// time := time + 0 0$15 ;
18487: LD_ADDR_VAR 0 1
18491: PUSH
18492: LD_VAR 0 1
18496: PUSH
18497: LD_INT 525
18499: PLUS
18500: ST_TO_ADDR
// end until game_status = false ;
18501: LD_EXP 28
18505: PUSH
18506: LD_INT 0
18508: EQUAL
18509: IFFALSE 18408
// end ; end_of_file
18511: PPOPN 1
18513: END
// every 0 0$01 trigger not debug do
18514: LD_EXP 1
18518: NOT
18519: IFFALSE 18542
18521: GO 18523
18523: DISABLE
// begin enable ;
18524: ENABLE
// Display_Strings := [ #tick , tick ] ;
18525: LD_ADDR_OWVAR 47
18529: PUSH
18530: LD_STRING #tick
18532: PUSH
18533: LD_OWVAR 1
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: ST_TO_ADDR
// end ;
18542: END
