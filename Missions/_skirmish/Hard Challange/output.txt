// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// debug := 0 ;
  21: LD_ADDR_EXP 1
  25: PUSH
  26: LD_INT 0
  28: ST_TO_ADDR
// if debug then
  29: LD_EXP 1
  33: IFFALSE 55
// begin display_strings := Debug mode active! ;
  35: LD_ADDR_OWVAR 47
  39: PUSH
  40: LD_STRING Debug mode active!
  42: ST_TO_ADDR
// Your_Side := 1 ;
  43: LD_ADDR_OWVAR 2
  47: PUSH
  48: LD_INT 1
  50: ST_TO_ADDR
// TurnFogOff ;
  51: CALL_OW 537
// end ; Difficulty := GetMultiplayerSetting ( 0 ) ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 426
  67: ST_TO_ADDR
// if not Difficulty then
  68: LD_OWVAR 67
  72: NOT
  73: IFFALSE 83
// Difficulty := 2 ;
  75: LD_ADDR_OWVAR 67
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// depotConstructed := false ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// PrepareTigers ( tiger_area ) ;
  91: LD_INT 8
  93: PPUSH
  94: CALL 10212 0 1
// PrepareApemans ( apeman_area ) ;
  98: LD_INT 9
 100: PPUSH
 101: CALL 10342 0 1
// PrepareRussian ;
 105: CALL 125 0 0
// PrepareAmerican ;
 109: CALL 11749 0 0
// if not debug then
 113: LD_EXP 1
 117: NOT
 118: IFFALSE 124
// Action ;
 120: CALL 13978 0 0
// end ;
 124: END
// export debug , depotConstructed ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 125: LD_INT 0
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// uc_side := 3 ;
 131: LD_ADDR_OWVAR 20
 135: PUSH
 136: LD_INT 3
 138: ST_TO_ADDR
// uc_nation := nation_russian ;
 139: LD_ADDR_OWVAR 21
 143: PUSH
 144: LD_INT 3
 146: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 147: LD_ADDR_VAR 0 2
 151: PUSH
 152: LD_INT 6
 154: PUSH
 155: LD_INT 7
 157: PUSH
 158: LD_INT 8
 160: PUSH
 161: EMPTY
 162: LIST
 163: LIST
 164: LIST
 165: PUSH
 166: LD_OWVAR 67
 170: ARRAY
 171: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 172: LD_INT 2
 174: PPUSH
 175: CALL_OW 274
 179: PPUSH
 180: LD_INT 1
 182: PPUSH
 183: LD_INT 1200
 185: PPUSH
 186: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 190: LD_INT 2
 192: PPUSH
 193: CALL_OW 274
 197: PPUSH
 198: LD_INT 2
 200: PPUSH
 201: LD_INT 600
 203: PPUSH
 204: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 208: LD_INT 33
 210: PPUSH
 211: LD_INT 4
 213: PPUSH
 214: LD_INT 3
 216: PPUSH
 217: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 221: LD_INT 37
 223: PPUSH
 224: LD_INT 3
 226: PPUSH
 227: LD_INT 3
 229: PPUSH
 230: CALL_OW 441
// ru_force := [ ] ;
 234: LD_ADDR_EXP 3
 238: PUSH
 239: EMPTY
 240: ST_TO_ADDR
// ru_group1 := [ ] ;
 241: LD_ADDR_EXP 4
 245: PUSH
 246: EMPTY
 247: ST_TO_ADDR
// ru_group2 := [ ] ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// ru_reserve := [ ] ;
 255: LD_ADDR_EXP 9
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// ru_attack_list := [ ] ;
 262: LD_ADDR_EXP 10
 266: PUSH
 267: EMPTY
 268: ST_TO_ADDR
// ru_protector := [ ] ;
 269: LD_ADDR_EXP 17
 273: PUSH
 274: EMPTY
 275: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 276: LD_ADDR_EXP 6
 280: PUSH
 281: LD_INT 48
 283: PUSH
 284: LD_INT 49
 286: PUSH
 287: LD_INT 50
 289: PUSH
 290: LD_INT 20
 292: PUSH
 293: LD_INT 1
 295: PUSH
 296: LD_INT 51
 298: PUSH
 299: LD_INT 52
 301: PUSH
 302: LD_INT 69
 304: PUSH
 305: LD_INT 39
 307: PUSH
 308: LD_INT 34
 310: PUSH
 311: LD_INT 40
 313: PUSH
 314: LD_INT 53
 316: PUSH
 317: LD_INT 71
 319: PUSH
 320: LD_INT 57
 322: PUSH
 323: LD_INT 58
 325: PUSH
 326: LD_INT 44
 328: PUSH
 329: LD_INT 32
 331: PUSH
 332: LD_INT 27
 334: PUSH
 335: LD_INT 23
 337: PUSH
 338: LD_INT 33
 340: PUSH
 341: LD_INT 59
 343: PUSH
 344: LD_INT 54
 346: PUSH
 347: LD_INT 55
 349: PUSH
 350: LD_INT 56
 352: PUSH
 353: LD_INT 63
 355: PUSH
 356: LD_INT 64
 358: PUSH
 359: LD_INT 65
 361: PUSH
 362: LD_INT 30
 364: PUSH
 365: LD_INT 31
 367: PUSH
 368: LD_INT 21
 370: PUSH
 371: LD_INT 22
 373: PUSH
 374: LD_INT 25
 376: PUSH
 377: EMPTY
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: LIST
 407: LIST
 408: LIST
 409: LIST
 410: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 411: LD_ADDR_EXP 7
 415: PUSH
 416: LD_INT 3
 418: PPUSH
 419: LD_INT 33
 421: PPUSH
 422: CALL 8327 0 2
 426: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 427: LD_ADDR_EXP 8
 431: PUSH
 432: LD_INT 46
 434: PUSH
 435: LD_INT 45
 437: PUSH
 438: LD_INT 47
 440: PUSH
 441: EMPTY
 442: LIST
 443: LIST
 444: LIST
 445: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 446: LD_ADDR_EXP 13
 450: PUSH
 451: LD_INT 33
 453: PUSH
 454: LD_INT 36
 456: PUSH
 457: LD_INT 8
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: ST_TO_ADDR
// ru_buildings := [ ] ;
 469: LD_ADDR_EXP 14
 473: PUSH
 474: EMPTY
 475: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 476: LD_ADDR_EXP 11
 480: PUSH
 481: LD_INT 3
 483: PPUSH
 484: CALL 6376 0 1
 488: PUSH
 489: LD_INT 1
 491: ARRAY
 492: PPUSH
 493: CALL_OW 250
 497: PUSH
 498: LD_INT 3
 500: PPUSH
 501: CALL 6376 0 1
 505: PUSH
 506: LD_INT 1
 508: ARRAY
 509: PPUSH
 510: CALL_OW 251
 514: PUSH
 515: LD_INT 3
 517: PPUSH
 518: CALL 6376 0 1
 522: PUSH
 523: LD_INT 1
 525: ARRAY
 526: PPUSH
 527: CALL_OW 254
 531: PUSH
 532: LD_INT 3
 534: PPUSH
 535: CALL 6376 0 1
 539: PUSH
 540: LD_INT 1
 542: ARRAY
 543: PPUSH
 544: LD_INT 1
 546: PPUSH
 547: CALL_OW 268
 551: PUSH
 552: LD_INT 3
 554: PPUSH
 555: CALL 6376 0 1
 559: PUSH
 560: LD_INT 1
 562: ARRAY
 563: PPUSH
 564: LD_INT 2
 566: PPUSH
 567: CALL_OW 268
 571: PUSH
 572: EMPTY
 573: LIST
 574: LIST
 575: LIST
 576: LIST
 577: LIST
 578: PUSH
 579: LD_INT 12
 581: PUSH
 582: LD_INT 13
 584: PUSH
 585: LD_INT 1
 587: PUSH
 588: LD_INT 11
 590: PUSH
 591: LD_INT 14
 593: PUSH
 594: EMPTY
 595: LIST
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: ST_TO_ADDR
// ru_heal_list := [ ] ;
 605: LD_ADDR_EXP 12
 609: PUSH
 610: EMPTY
 611: ST_TO_ADDR
// need_buldozer := false ;
 612: LD_ADDR_EXP 18
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// need_crane := true ;
 620: LD_ADDR_EXP 19
 624: PUSH
 625: LD_INT 1
 627: ST_TO_ADDR
// ru_spotted := false ;
 628: LD_ADDR_EXP 16
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// for i = 1 to 6 do
 636: LD_ADDR_VAR 0 3
 640: PUSH
 641: DOUBLE
 642: LD_INT 1
 644: DEC
 645: ST_TO_ADDR
 646: LD_INT 6
 648: PUSH
 649: FOR_TO
 650: IFFALSE 691
// begin PrepareHuman ( false , 4 , skill ) ;
 652: LD_INT 0
 654: PPUSH
 655: LD_INT 4
 657: PPUSH
 658: LD_VAR 0 2
 662: PPUSH
 663: CALL_OW 380
// un := CreateHuman ;
 667: LD_ADDR_VAR 0 4
 671: PUSH
 672: CALL_OW 44
 676: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 677: LD_VAR 0 4
 681: PPUSH
 682: LD_INT 3
 684: PPUSH
 685: CALL_OW 52
// end ;
 689: GO 649
 691: POP
 692: POP
// for i = 1 to 6 do
 693: LD_ADDR_VAR 0 3
 697: PUSH
 698: DOUBLE
 699: LD_INT 1
 701: DEC
 702: ST_TO_ADDR
 703: LD_INT 6
 705: PUSH
 706: FOR_TO
 707: IFFALSE 748
// begin PrepareHuman ( false , 3 , skill ) ;
 709: LD_INT 0
 711: PPUSH
 712: LD_INT 3
 714: PPUSH
 715: LD_VAR 0 2
 719: PPUSH
 720: CALL_OW 380
// un := CreateHuman ;
 724: LD_ADDR_VAR 0 4
 728: PUSH
 729: CALL_OW 44
 733: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 734: LD_VAR 0 4
 738: PPUSH
 739: LD_INT 14
 741: PPUSH
 742: CALL_OW 52
// end ;
 746: GO 706
 748: POP
 749: POP
// for i = 1 to 6 do
 750: LD_ADDR_VAR 0 3
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: LD_INT 6
 762: PUSH
 763: FOR_TO
 764: IFFALSE 808
// begin PrepareHuman ( false , 2 , skill ) ;
 766: LD_INT 0
 768: PPUSH
 769: LD_INT 2
 771: PPUSH
 772: LD_VAR 0 2
 776: PPUSH
 777: CALL_OW 380
// un := CreateHuman ;
 781: LD_ADDR_VAR 0 4
 785: PUSH
 786: CALL_OW 44
 790: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 791: LD_VAR 0 4
 795: PPUSH
 796: LD_INT 1
 798: PPUSH
 799: LD_INT 0
 801: PPUSH
 802: CALL_OW 49
// end ;
 806: GO 763
 808: POP
 809: POP
// for i = 1 to 6 do
 810: LD_ADDR_VAR 0 3
 814: PUSH
 815: DOUBLE
 816: LD_INT 1
 818: DEC
 819: ST_TO_ADDR
 820: LD_INT 6
 822: PUSH
 823: FOR_TO
 824: IFFALSE 902
// begin PrepareHuman ( false , 1 , skill ) ;
 826: LD_INT 0
 828: PPUSH
 829: LD_INT 1
 831: PPUSH
 832: LD_VAR 0 2
 836: PPUSH
 837: CALL_OW 380
// un := CreateHuman ;
 841: LD_ADDR_VAR 0 4
 845: PUSH
 846: CALL_OW 44
 850: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 851: LD_VAR 0 4
 855: PPUSH
 856: LD_INT 1
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 866: LD_VAR 0 4
 870: PPUSH
 871: LD_INT 30
 873: PUSH
 874: LD_INT 5
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: PPUSH
 881: CALL_OW 69
 885: PPUSH
 886: LD_VAR 0 4
 890: PPUSH
 891: CALL_OW 74
 895: PPUSH
 896: CALL_OW 120
// end ;
 900: GO 823
 902: POP
 903: POP
// for i = 1 to Difficulty do
 904: LD_ADDR_VAR 0 3
 908: PUSH
 909: DOUBLE
 910: LD_INT 1
 912: DEC
 913: ST_TO_ADDR
 914: LD_OWVAR 67
 918: PUSH
 919: FOR_TO
 920: IFFALSE 1031
// begin vc_chassis := ru_medium_tracked ;
 922: LD_ADDR_OWVAR 37
 926: PUSH
 927: LD_INT 22
 929: ST_TO_ADDR
// vc_engine := engine_siberite ;
 930: LD_ADDR_OWVAR 39
 934: PUSH
 935: LD_INT 3
 937: ST_TO_ADDR
// vc_control := control_computer ;
 938: LD_ADDR_OWVAR 38
 942: PUSH
 943: LD_INT 3
 945: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 946: LD_ADDR_OWVAR 40
 950: PUSH
 951: LD_INT 43
 953: PUSH
 954: LD_INT 45
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: LD_VAR 0 3
 965: PUSH
 966: LD_INT 2
 968: MOD
 969: PUSH
 970: LD_INT 1
 972: PLUS
 973: ARRAY
 974: ST_TO_ADDR
// un := CreateVehicle ;
 975: LD_ADDR_VAR 0 4
 979: PUSH
 980: CALL_OW 45
 984: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
 985: LD_VAR 0 4
 989: PPUSH
 990: LD_INT 52
 992: PPUSH
 993: LD_INT 42
 995: PPUSH
 996: LD_INT 6
 998: PPUSH
 999: LD_INT 0
1001: PPUSH
1002: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
1006: LD_ADDR_EXP 17
1010: PUSH
1011: LD_EXP 17
1015: PPUSH
1016: LD_INT 1
1018: PPUSH
1019: LD_VAR 0 4
1023: PPUSH
1024: CALL_OW 2
1028: ST_TO_ADDR
// end ;
1029: GO 919
1031: POP
1032: POP
// end ;
1033: LD_VAR 0 1
1037: RET
// every 120 120$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1038: LD_OWVAR 67
1042: PUSH
1043: LD_INT 2
1045: EQUAL
1046: PUSH
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 3
1052: PPUSH
1053: CALL 6227 0 2
1057: AND
1058: IFFALSE 1094
1060: GO 1062
1062: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1063: LD_INT 3
1065: PPUSH
1066: LD_INT 3
1068: PPUSH
1069: CALL 6227 0 2
1073: PUSH
1074: LD_INT 1
1076: ARRAY
1077: PPUSH
1078: LD_INT 24
1080: PPUSH
1081: LD_INT 1
1083: PPUSH
1084: LD_INT 3
1086: PPUSH
1087: LD_INT 48
1089: PPUSH
1090: CALL 8100 0 5
1094: END
// every 100 100$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1095: LD_OWVAR 67
1099: PUSH
1100: LD_INT 3
1102: EQUAL
1103: PUSH
1104: LD_INT 3
1106: PPUSH
1107: LD_INT 3
1109: PPUSH
1110: CALL 6227 0 2
1114: AND
1115: IFFALSE 1151
1117: GO 1119
1119: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1120: LD_INT 3
1122: PPUSH
1123: LD_INT 3
1125: PPUSH
1126: CALL 6227 0 2
1130: PUSH
1131: LD_INT 1
1133: ARRAY
1134: PPUSH
1135: LD_INT 24
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 48
1146: PPUSH
1147: CALL 8100 0 5
1151: END
// every 0 0$01 trigger ru_protector do var i ;
1152: LD_EXP 17
1156: IFFALSE 1327
1158: GO 1160
1160: DISABLE
1161: LD_INT 0
1163: PPUSH
// begin enable ;
1164: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1165: LD_INT 14
1167: PPUSH
1168: LD_INT 81
1170: PUSH
1171: LD_INT 3
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: PPUSH
1178: CALL_OW 70
1182: IFFALSE 1257
// begin for i = 1 to ru_protector do
1184: LD_ADDR_VAR 0 1
1188: PUSH
1189: DOUBLE
1190: LD_INT 1
1192: DEC
1193: ST_TO_ADDR
1194: LD_EXP 17
1198: PUSH
1199: FOR_TO
1200: IFFALSE 1253
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1202: LD_EXP 17
1206: PUSH
1207: LD_VAR 0 1
1211: ARRAY
1212: PPUSH
1213: LD_INT 14
1215: PPUSH
1216: LD_INT 81
1218: PUSH
1219: LD_INT 3
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: PPUSH
1226: CALL_OW 70
1230: PPUSH
1231: LD_EXP 17
1235: PUSH
1236: LD_VAR 0 1
1240: ARRAY
1241: PPUSH
1242: CALL_OW 74
1246: PPUSH
1247: CALL_OW 115
1251: GO 1199
1253: POP
1254: POP
// end else
1255: GO 1327
// for i = 1 to ru_protector do
1257: LD_ADDR_VAR 0 1
1261: PUSH
1262: DOUBLE
1263: LD_INT 1
1265: DEC
1266: ST_TO_ADDR
1267: LD_EXP 17
1271: PUSH
1272: FOR_TO
1273: IFFALSE 1325
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1275: LD_EXP 17
1279: PUSH
1280: LD_VAR 0 1
1284: ARRAY
1285: PPUSH
1286: LD_INT 49
1288: PPUSH
1289: LD_INT 39
1291: PPUSH
1292: CALL_OW 297
1296: PUSH
1297: LD_INT 10
1299: GREATER
1300: IFFALSE 1323
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1302: LD_EXP 17
1306: PUSH
1307: LD_VAR 0 1
1311: ARRAY
1312: PPUSH
1313: LD_INT 49
1315: PPUSH
1316: LD_INT 39
1318: PPUSH
1319: CALL_OW 111
1323: GO 1272
1325: POP
1326: POP
// end ;
1327: PPOPN 1
1329: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1330: LD_OWVAR 1
1334: PUSH
1335: LD_INT 4200
1337: PUSH
1338: LD_INT 2100
1340: PUSH
1341: LD_INT 1050
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: LIST
1348: PUSH
1349: LD_OWVAR 67
1353: ARRAY
1354: GREATER
1355: IFFALSE 1368
1357: GO 1359
1359: DISABLE
// need_buldozer := true ;
1360: LD_ADDR_EXP 18
1364: PUSH
1365: LD_INT 1
1367: ST_TO_ADDR
1368: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1369: GO 1371
1371: DISABLE
// begin enable ;
1372: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1373: LD_ADDR_EXP 20
1377: PUSH
1378: LD_INT 22
1380: PUSH
1381: LD_INT 3
1383: PUSH
1384: EMPTY
1385: LIST
1386: LIST
1387: PUSH
1388: LD_INT 25
1390: PUSH
1391: LD_INT 1
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PPUSH
1402: CALL_OW 69
1406: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1407: LD_ADDR_EXP 21
1411: PUSH
1412: LD_INT 22
1414: PUSH
1415: LD_INT 3
1417: PUSH
1418: EMPTY
1419: LIST
1420: LIST
1421: PUSH
1422: LD_INT 25
1424: PUSH
1425: LD_INT 2
1427: PUSH
1428: EMPTY
1429: LIST
1430: LIST
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: PPUSH
1436: CALL_OW 69
1440: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1441: LD_ADDR_EXP 22
1445: PUSH
1446: LD_INT 22
1448: PUSH
1449: LD_INT 3
1451: PUSH
1452: EMPTY
1453: LIST
1454: LIST
1455: PUSH
1456: LD_INT 25
1458: PUSH
1459: LD_INT 3
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL_OW 69
1474: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1475: LD_ADDR_EXP 23
1479: PUSH
1480: LD_INT 22
1482: PUSH
1483: LD_INT 3
1485: PUSH
1486: EMPTY
1487: LIST
1488: LIST
1489: PUSH
1490: LD_INT 25
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: PPUSH
1504: CALL_OW 69
1508: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1509: LD_ADDR_EXP 24
1513: PUSH
1514: LD_INT 22
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: PUSH
1524: LD_INT 25
1526: PUSH
1527: LD_INT 9
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: PPUSH
1538: CALL_OW 69
1542: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1543: LD_ADDR_EXP 25
1547: PUSH
1548: LD_INT 2
1550: PPUSH
1551: LD_INT 22
1553: PUSH
1554: LD_INT 3
1556: PUSH
1557: EMPTY
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 21
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: PPUSH
1575: CALL_OW 70
1579: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1580: LD_ADDR_EXP 26
1584: PUSH
1585: LD_INT 34
1587: PUSH
1588: LD_INT 53
1590: PUSH
1591: EMPTY
1592: LIST
1593: LIST
1594: PPUSH
1595: CALL_OW 69
1599: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1600: LD_ADDR_EXP 27
1604: PUSH
1605: LD_INT 34
1607: PUSH
1608: LD_INT 52
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: PPUSH
1615: CALL_OW 69
1619: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1620: LD_ADDR_EXP 28
1624: PUSH
1625: LD_INT 34
1627: PUSH
1628: LD_INT 51
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PPUSH
1635: CALL_OW 69
1639: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1640: LD_ADDR_EXP 14
1644: PUSH
1645: LD_INT 3
1647: PPUSH
1648: LD_INT 1
1650: NEG
1651: PPUSH
1652: CALL 10730 0 2
1656: ST_TO_ADDR
// end ;
1657: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1658: LD_INT 22
1660: PUSH
1661: LD_INT 3
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PPUSH
1668: CALL_OW 69
1672: PUSH
1673: LD_EXP 29
1677: AND
1678: PUSH
1679: LD_EXP 1
1683: OR
1684: IFFALSE 5251
1686: GO 1688
1688: DISABLE
1689: LD_INT 0
1691: PPUSH
1692: PPUSH
1693: PPUSH
1694: PPUSH
1695: PPUSH
1696: PPUSH
1697: PPUSH
1698: PPUSH
1699: PPUSH
1700: PPUSH
// begin enable ;
1701: ENABLE
// for i = 1 to ru_eng do
1702: LD_ADDR_VAR 0 1
1706: PUSH
1707: DOUBLE
1708: LD_INT 1
1710: DEC
1711: ST_TO_ADDR
1712: LD_EXP 21
1716: PUSH
1717: FOR_TO
1718: IFFALSE 1781
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1720: LD_EXP 21
1724: PUSH
1725: LD_VAR 0 1
1729: ARRAY
1730: PPUSH
1731: CALL_OW 314
1735: NOT
1736: PUSH
1737: LD_EXP 21
1741: PUSH
1742: LD_VAR 0 1
1746: ARRAY
1747: PPUSH
1748: CALL_OW 310
1752: NOT
1753: AND
1754: IFFALSE 1779
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1756: LD_EXP 21
1760: PUSH
1761: LD_VAR 0 1
1765: ARRAY
1766: PPUSH
1767: LD_INT 3
1769: PPUSH
1770: CALL 6136 0 1
1774: PPUSH
1775: CALL_OW 120
1779: GO 1717
1781: POP
1782: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1783: LD_INT 2
1785: PPUSH
1786: LD_INT 22
1788: PUSH
1789: LD_INT 3
1791: PUSH
1792: EMPTY
1793: LIST
1794: LIST
1795: PUSH
1796: LD_INT 21
1798: PUSH
1799: LD_INT 3
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 3
1808: PUSH
1809: LD_INT 24
1811: PUSH
1812: LD_INT 1000
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: PUSH
1819: EMPTY
1820: LIST
1821: LIST
1822: PUSH
1823: EMPTY
1824: LIST
1825: LIST
1826: LIST
1827: PPUSH
1828: CALL_OW 70
1832: IFFALSE 1999
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1834: LD_ADDR_VAR 0 4
1838: PUSH
1839: LD_INT 2
1841: PPUSH
1842: LD_INT 22
1844: PUSH
1845: LD_INT 3
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: PUSH
1852: LD_INT 21
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: PUSH
1862: LD_INT 3
1864: PUSH
1865: LD_INT 24
1867: PUSH
1868: LD_INT 1000
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: PUSH
1879: EMPTY
1880: LIST
1881: LIST
1882: LIST
1883: PPUSH
1884: CALL_OW 70
1888: ST_TO_ADDR
// for i = 1 to ru_eng do
1889: LD_ADDR_VAR 0 1
1893: PUSH
1894: DOUBLE
1895: LD_INT 1
1897: DEC
1898: ST_TO_ADDR
1899: LD_EXP 21
1903: PUSH
1904: FOR_TO
1905: IFFALSE 1997
// begin if IsInUnit ( ru_eng [ i ] ) then
1907: LD_EXP 21
1911: PUSH
1912: LD_VAR 0 1
1916: ARRAY
1917: PPUSH
1918: CALL_OW 310
1922: IFFALSE 1941
// ComExitBuilding ( ru_eng [ i ] ) else
1924: LD_EXP 21
1928: PUSH
1929: LD_VAR 0 1
1933: ARRAY
1934: PPUSH
1935: CALL_OW 122
1939: GO 1995
// if not WantRepair ( ru_eng [ i ] ) then
1941: LD_EXP 21
1945: PUSH
1946: LD_VAR 0 1
1950: ARRAY
1951: PPUSH
1952: CALL 10656 0 1
1956: NOT
1957: IFFALSE 1995
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1959: LD_EXP 21
1963: PUSH
1964: LD_VAR 0 1
1968: ARRAY
1969: PPUSH
1970: LD_VAR 0 4
1974: PPUSH
1975: LD_EXP 21
1979: PUSH
1980: LD_VAR 0 1
1984: ARRAY
1985: PPUSH
1986: CALL_OW 74
1990: PPUSH
1991: CALL_OW 130
// end ;
1995: GO 1904
1997: POP
1998: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
1999: LD_OWVAR 2
2003: PPUSH
2004: LD_INT 38
2006: PPUSH
2007: LD_INT 26
2009: PPUSH
2010: CALL 5469 0 3
2014: PUSH
2015: LD_INT 0
2017: EQUAL
2018: PUSH
2019: LD_OWVAR 2
2023: PPUSH
2024: LD_INT 29
2026: PPUSH
2027: LD_INT 37
2029: PPUSH
2030: CALL 5469 0 3
2034: PUSH
2035: LD_INT 0
2037: EQUAL
2038: AND
2039: IFFALSE 2176
// begin if ru_blist > 0 then
2041: LD_EXP 13
2045: PUSH
2046: LD_INT 0
2048: GREATER
2049: IFFALSE 2176
// begin for i = 1 to ru_eng do
2051: LD_ADDR_VAR 0 1
2055: PUSH
2056: DOUBLE
2057: LD_INT 1
2059: DEC
2060: ST_TO_ADDR
2061: LD_EXP 21
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2174
// if IsInUnit ( ru_eng [ i ] ) then
2069: LD_EXP 21
2073: PUSH
2074: LD_VAR 0 1
2078: ARRAY
2079: PPUSH
2080: CALL_OW 310
2084: IFFALSE 2103
// ComExitBuilding ( ru_eng [ i ] ) else
2086: LD_EXP 21
2090: PUSH
2091: LD_VAR 0 1
2095: ARRAY
2096: PPUSH
2097: CALL_OW 122
2101: GO 2172
// if not HasTask ( ru_eng [ i ] ) then
2103: LD_EXP 21
2107: PUSH
2108: LD_VAR 0 1
2112: ARRAY
2113: PPUSH
2114: CALL_OW 314
2118: NOT
2119: IFFALSE 2172
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2121: LD_EXP 21
2125: PUSH
2126: LD_VAR 0 1
2130: ARRAY
2131: PPUSH
2132: LD_EXP 13
2136: PUSH
2137: LD_INT 1
2139: ARRAY
2140: PPUSH
2141: LD_EXP 13
2145: PUSH
2146: LD_INT 2
2148: ARRAY
2149: PPUSH
2150: LD_EXP 13
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: PPUSH
2159: LD_EXP 13
2163: PUSH
2164: LD_INT 4
2166: ARRAY
2167: PPUSH
2168: CALL_OW 145
2172: GO 2066
2174: POP
2175: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2176: LD_ADDR_EXP 12
2180: PUSH
2181: LD_INT 3
2183: PPUSH
2184: LD_EXP 12
2188: PPUSH
2189: LD_EXP 15
2193: PPUSH
2194: CALL 9143 0 3
2198: ST_TO_ADDR
// if debug then
2199: LD_EXP 1
2203: IFFALSE 2215
// display_strings := ru_heal_list ;
2205: LD_ADDR_OWVAR 47
2209: PUSH
2210: LD_EXP 12
2214: ST_TO_ADDR
// for i = 1 to ru_sci do
2215: LD_ADDR_VAR 0 1
2219: PUSH
2220: DOUBLE
2221: LD_INT 1
2223: DEC
2224: ST_TO_ADDR
2225: LD_EXP 23
2229: PUSH
2230: FOR_TO
2231: IFFALSE 2563
// begin if ru_heal_list then
2233: LD_EXP 12
2237: IFFALSE 2476
// begin list := ru_heal_list ;
2239: LD_ADDR_VAR 0 9
2243: PUSH
2244: LD_EXP 12
2248: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2249: LD_EXP 23
2253: PUSH
2254: LD_VAR 0 1
2258: ARRAY
2259: PPUSH
2260: CALL_OW 310
2264: IFFALSE 2281
// ComExitBuilding ( ru_sci [ i ] ) ;
2266: LD_EXP 23
2270: PUSH
2271: LD_VAR 0 1
2275: ARRAY
2276: PPUSH
2277: CALL_OW 122
// for p = 1 to list do
2281: LD_ADDR_VAR 0 5
2285: PUSH
2286: DOUBLE
2287: LD_INT 1
2289: DEC
2290: ST_TO_ADDR
2291: LD_VAR 0 9
2295: PUSH
2296: FOR_TO
2297: IFFALSE 2472
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2299: LD_VAR 0 9
2303: PUSH
2304: LD_VAR 0 5
2308: ARRAY
2309: PPUSH
2310: CALL_OW 110
2314: PUSH
2315: LD_INT 100
2317: EQUAL
2318: PUSH
2319: LD_EXP 23
2323: PUSH
2324: LD_VAR 0 1
2328: ARRAY
2329: PPUSH
2330: LD_INT 100
2332: PPUSH
2333: CALL 9503 0 2
2337: NOT
2338: AND
2339: IFFALSE 2367
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2341: LD_EXP 23
2345: PUSH
2346: LD_VAR 0 1
2350: ARRAY
2351: PPUSH
2352: LD_VAR 0 9
2356: PUSH
2357: LD_VAR 0 5
2361: ARRAY
2362: PPUSH
2363: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2367: LD_VAR 0 9
2371: PUSH
2372: LD_VAR 0 5
2376: ARRAY
2377: PPUSH
2378: CALL_OW 110
2382: PUSH
2383: LD_INT 100
2385: GREATER
2386: IFFALSE 2414
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2388: LD_EXP 23
2392: PUSH
2393: LD_VAR 0 1
2397: ARRAY
2398: PPUSH
2399: LD_VAR 0 9
2403: PUSH
2404: LD_VAR 0 5
2408: ARRAY
2409: PPUSH
2410: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2414: LD_VAR 0 9
2418: PUSH
2419: LD_VAR 0 5
2423: ARRAY
2424: PPUSH
2425: LD_INT 4
2427: PPUSH
2428: CALL_OW 308
2432: NOT
2433: IFFALSE 2455
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2435: LD_VAR 0 9
2439: PUSH
2440: LD_VAR 0 5
2444: ARRAY
2445: PPUSH
2446: LD_INT 4
2448: PPUSH
2449: CALL_OW 113
2453: GO 2470
// ComHold ( list [ p ] ) ;
2455: LD_VAR 0 9
2459: PUSH
2460: LD_VAR 0 5
2464: ARRAY
2465: PPUSH
2466: CALL_OW 140
// end ;
2470: GO 2296
2472: POP
2473: POP
// end else
2474: GO 2561
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2476: LD_EXP 23
2480: PUSH
2481: LD_VAR 0 1
2485: ARRAY
2486: PPUSH
2487: CALL_OW 314
2491: NOT
2492: PUSH
2493: LD_EXP 23
2497: PUSH
2498: LD_VAR 0 1
2502: ARRAY
2503: PPUSH
2504: CALL_OW 310
2508: NOT
2509: AND
2510: PUSH
2511: LD_EXP 12
2515: PUSH
2516: LD_INT 0
2518: EQUAL
2519: AND
2520: IFFALSE 2561
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2522: LD_EXP 23
2526: PUSH
2527: LD_VAR 0 1
2531: ARRAY
2532: PPUSH
2533: LD_INT 3
2535: PPUSH
2536: CALL 6376 0 1
2540: PPUSH
2541: LD_EXP 23
2545: PUSH
2546: LD_VAR 0 1
2550: ARRAY
2551: PPUSH
2552: CALL_OW 74
2556: PPUSH
2557: CALL_OW 120
// end ;
2561: GO 2230
2563: POP
2564: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2565: LD_INT 3
2567: PPUSH
2568: LD_EXP 6
2572: PPUSH
2573: CALL 6517 0 2
2577: IFFALSE 2591
// ResearchTechList ( 3 , ru_tech_list ) ;
2579: LD_INT 3
2581: PPUSH
2582: LD_EXP 6
2586: PPUSH
2587: CALL 6592 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2591: LD_EXP 21
2595: PPUSH
2596: LD_EXP 11
2600: PPUSH
2601: CALL 8499 0 2
// lab := GetLabs ( 3 ) ;
2605: LD_ADDR_VAR 0 8
2609: PUSH
2610: LD_INT 3
2612: PPUSH
2613: CALL 6376 0 1
2617: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2618: LD_VAR 0 8
2622: PUSH
2623: LD_EXP 12
2627: PUSH
2628: LD_INT 0
2630: EQUAL
2631: AND
2632: IFFALSE 2759
// for i = 1 to lab do
2634: LD_ADDR_VAR 0 1
2638: PUSH
2639: DOUBLE
2640: LD_INT 1
2642: DEC
2643: ST_TO_ADDR
2644: LD_VAR 0 8
2648: PUSH
2649: FOR_TO
2650: IFFALSE 2757
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2652: LD_VAR 0 8
2656: PUSH
2657: LD_VAR 0 1
2661: ARRAY
2662: PPUSH
2663: CALL_OW 461
2667: PUSH
2668: LD_INT 6
2670: EQUAL
2671: IFFALSE 2755
// begin for p = 1 to ru_sci do
2673: LD_ADDR_VAR 0 5
2677: PUSH
2678: DOUBLE
2679: LD_INT 1
2681: DEC
2682: ST_TO_ADDR
2683: LD_EXP 23
2687: PUSH
2688: FOR_TO
2689: IFFALSE 2753
// if IsInUnit ( ru_sci [ p ] ) then
2691: LD_EXP 23
2695: PUSH
2696: LD_VAR 0 5
2700: ARRAY
2701: PPUSH
2702: CALL_OW 310
2706: IFFALSE 2725
// ComExitBuilding ( ru_sci [ p ] ) else
2708: LD_EXP 23
2712: PUSH
2713: LD_VAR 0 5
2717: ARRAY
2718: PPUSH
2719: CALL_OW 122
2723: GO 2751
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2725: LD_EXP 23
2729: PUSH
2730: LD_VAR 0 5
2734: ARRAY
2735: PPUSH
2736: LD_VAR 0 8
2740: PUSH
2741: LD_VAR 0 1
2745: ARRAY
2746: PPUSH
2747: CALL_OW 120
2751: GO 2688
2753: POP
2754: POP
// end ;
2755: GO 2649
2757: POP
2758: POP
// if GetTowers ( 3 ) < 5 then
2759: LD_INT 3
2761: PPUSH
2762: CALL 6931 0 1
2766: PUSH
2767: LD_INT 5
2769: LESS
2770: IFFALSE 2788
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2772: LD_EXP 21
2776: PPUSH
2777: LD_EXP 7
2781: PPUSH
2782: CALL 7539 0 2
2786: GO 2800
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2788: LD_INT 3
2790: PPUSH
2791: LD_EXP 8
2795: PPUSH
2796: CALL 7830 0 2
// if GetBuilding ( 3 , b_factory ) then
2800: LD_INT 3
2802: PPUSH
2803: LD_INT 3
2805: PPUSH
2806: CALL 6227 0 2
2810: IFFALSE 3080
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2812: LD_INT 3
2814: PPUSH
2815: LD_INT 3
2817: PPUSH
2818: CALL 6227 0 2
2822: PUSH
2823: LD_INT 1
2825: ARRAY
2826: PPUSH
2827: CALL_OW 461
2831: PUSH
2832: LD_INT 2
2834: EQUAL
2835: IFFALSE 3080
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2837: LD_ADDR_VAR 0 7
2841: PUSH
2842: LD_INT 3
2844: PPUSH
2845: LD_INT 3
2847: PPUSH
2848: CALL 6227 0 2
2852: PUSH
2853: LD_INT 1
2855: ARRAY
2856: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2857: LD_INT 3
2859: PPUSH
2860: LD_INT 24
2862: PPUSH
2863: LD_INT 53
2865: PPUSH
2866: CALL 7978 0 3
2870: PUSH
2871: LD_INT 0
2873: EQUAL
2874: PUSH
2875: LD_EXP 18
2879: AND
2880: IFFALSE 2903
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2882: LD_VAR 0 7
2886: PPUSH
2887: LD_INT 24
2889: PPUSH
2890: LD_INT 1
2892: PPUSH
2893: LD_INT 1
2895: PPUSH
2896: LD_INT 53
2898: PPUSH
2899: CALL 8100 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2903: LD_INT 3
2905: PPUSH
2906: LD_INT 22
2908: PPUSH
2909: LD_INT 52
2911: PPUSH
2912: CALL 7978 0 3
2916: PUSH
2917: LD_INT 0
2919: EQUAL
2920: PUSH
2921: LD_EXP 19
2925: AND
2926: IFFALSE 2949
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2928: LD_VAR 0 7
2932: PPUSH
2933: LD_INT 22
2935: PPUSH
2936: LD_INT 1
2938: PPUSH
2939: LD_INT 3
2941: PPUSH
2942: LD_INT 52
2944: PPUSH
2945: CALL 8100 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2949: LD_INT 3
2951: PPUSH
2952: LD_INT 22
2954: PPUSH
2955: LD_INT 49
2957: PPUSH
2958: CALL 7978 0 3
2962: PUSH
2963: LD_INT 4
2965: LESS
2966: PUSH
2967: LD_INT 31
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: CALL_OW 321
2977: PUSH
2978: LD_INT 2
2980: EQUAL
2981: AND
2982: IFFALSE 3005
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
2984: LD_VAR 0 7
2988: PPUSH
2989: LD_INT 22
2991: PPUSH
2992: LD_INT 1
2994: PPUSH
2995: LD_INT 3
2997: PPUSH
2998: LD_INT 49
3000: PPUSH
3001: CALL 8100 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
3005: LD_EXP 9
3009: PUSH
3010: LD_INT 5
3012: PUSH
3013: LD_INT 6
3015: PUSH
3016: LD_INT 7
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: LIST
3023: PUSH
3024: LD_OWVAR 67
3028: ARRAY
3029: LESS
3030: IFFALSE 3080
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3032: LD_VAR 0 7
3036: PPUSH
3037: LD_INT 24
3039: PPUSH
3040: LD_INT 1
3042: PPUSH
3043: LD_INT 3
3045: PPUSH
3046: LD_INT 46
3048: PUSH
3049: LD_INT 45
3051: PUSH
3052: LD_INT 47
3054: PUSH
3055: LD_INT 46
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: LIST
3062: LIST
3063: PUSH
3064: LD_INT 1
3066: PPUSH
3067: LD_INT 4
3069: PPUSH
3070: CALL_OW 12
3074: ARRAY
3075: PPUSH
3076: CALL 8100 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3080: LD_INT 3
3082: PPUSH
3083: CALL 6136 0 1
3087: PPUSH
3088: CALL 5828 0 1
3092: PUSH
3093: LD_INT 1
3095: ARRAY
3096: PUSH
3097: LD_INT 250
3099: GREATER
3100: PUSH
3101: LD_INT 3
3103: PPUSH
3104: CALL 6136 0 1
3108: PPUSH
3109: CALL 5828 0 1
3113: PUSH
3114: LD_INT 3
3116: ARRAY
3117: PUSH
3118: LD_INT 50
3120: GREATER
3121: AND
3122: PUSH
3123: LD_INT 23
3125: PPUSH
3126: LD_INT 3
3128: PPUSH
3129: CALL_OW 321
3133: PUSH
3134: LD_INT 2
3136: EQUAL
3137: AND
3138: PUSH
3139: LD_INT 3
3141: PPUSH
3142: CALL 11454 0 1
3146: PUSH
3147: LD_INT 0
3149: EQUAL
3150: AND
3151: PUSH
3152: LD_INT 22
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: PUSH
3162: LD_INT 34
3164: PUSH
3165: LD_INT 49
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 69
3180: PUSH
3181: LD_INT 3
3183: GREATER
3184: AND
3185: PUSH
3186: LD_OWVAR 2
3190: PPUSH
3191: LD_INT 51
3193: PPUSH
3194: LD_INT 42
3196: PPUSH
3197: CALL 5469 0 3
3201: PUSH
3202: LD_INT 0
3204: EQUAL
3205: AND
3206: IFFALSE 3291
// begin for i = 1 to ru_mech do
3208: LD_ADDR_VAR 0 1
3212: PUSH
3213: DOUBLE
3214: LD_INT 1
3216: DEC
3217: ST_TO_ADDR
3218: LD_EXP 22
3222: PUSH
3223: FOR_TO
3224: IFFALSE 3289
// begin if IsInUnit ( ru_mech [ i ] ) then
3226: LD_EXP 22
3230: PUSH
3231: LD_VAR 0 1
3235: ARRAY
3236: PPUSH
3237: CALL_OW 310
3241: IFFALSE 3260
// ComExitBuilding ( ru_mech [ i ] ) else
3243: LD_EXP 22
3247: PUSH
3248: LD_VAR 0 1
3252: ARRAY
3253: PPUSH
3254: CALL_OW 122
3258: GO 3287
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3260: LD_EXP 22
3264: PUSH
3265: LD_VAR 0 1
3269: ARRAY
3270: PPUSH
3271: LD_INT 37
3273: PPUSH
3274: LD_INT 51
3276: PPUSH
3277: LD_INT 43
3279: PPUSH
3280: LD_INT 0
3282: PPUSH
3283: CALL_OW 170
// end ;
3287: GO 3223
3289: POP
3290: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3291: LD_OWVAR 1
3295: PUSH
3296: LD_INT 94500
3298: PUSH
3299: LD_INT 84000
3301: PUSH
3302: LD_INT 71400
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: LIST
3309: PUSH
3310: LD_OWVAR 67
3314: ARRAY
3315: GREATEREQUAL
3316: IFFALSE 3372
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3318: LD_OWVAR 1
3322: PUSH
3323: LD_INT 18900
3325: PUSH
3326: LD_INT 16800
3328: PUSH
3329: LD_INT 14700
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: LIST
3336: PUSH
3337: LD_OWVAR 67
3341: ARRAY
3342: MOD
3343: PUSH
3344: LD_INT 0
3346: EQUAL
3347: IFFALSE 3372
// if ru_reserve then
3349: LD_EXP 9
3353: IFFALSE 3372
// begin ru_attack_list := ru_reserve ;
3355: LD_ADDR_EXP 10
3359: PUSH
3360: LD_EXP 9
3364: ST_TO_ADDR
// ru_reserve := [ ] ;
3365: LD_ADDR_EXP 9
3369: PUSH
3370: EMPTY
3371: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3372: LD_EXP 10
3376: IFFALSE 3498
// begin for i = 1 to ru_attack_list do
3378: LD_ADDR_VAR 0 1
3382: PUSH
3383: DOUBLE
3384: LD_INT 1
3386: DEC
3387: ST_TO_ADDR
3388: LD_EXP 10
3392: PUSH
3393: FOR_TO
3394: IFFALSE 3496
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3396: LD_EXP 10
3400: PUSH
3401: LD_VAR 0 1
3405: ARRAY
3406: PPUSH
3407: CALL_OW 256
3411: PUSH
3412: LD_INT 250
3414: GREATEREQUAL
3415: PUSH
3416: LD_EXP 10
3420: PUSH
3421: LD_VAR 0 1
3425: ARRAY
3426: PPUSH
3427: CALL_OW 314
3431: NOT
3432: AND
3433: IFFALSE 3494
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3435: LD_EXP 10
3439: PUSH
3440: LD_VAR 0 1
3444: ARRAY
3445: PPUSH
3446: LD_INT 81
3448: PUSH
3449: LD_EXP 10
3453: PUSH
3454: LD_VAR 0 1
3458: ARRAY
3459: PPUSH
3460: CALL_OW 255
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: PPUSH
3469: CALL_OW 69
3473: PPUSH
3474: LD_EXP 10
3478: PUSH
3479: LD_VAR 0 1
3483: ARRAY
3484: PPUSH
3485: CALL_OW 74
3489: PPUSH
3490: CALL_OW 115
3494: GO 3393
3496: POP
3497: POP
// end ; if GetBehemoth ( 3 ) then
3498: LD_INT 3
3500: PPUSH
3501: CALL 11454 0 1
3505: IFFALSE 3877
// begin if ru_mech >= 4 then
3507: LD_EXP 22
3511: PUSH
3512: LD_INT 4
3514: GREATEREQUAL
3515: IFFALSE 3566
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3517: LD_ADDR_EXP 15
3521: PUSH
3522: LD_EXP 22
3526: PUSH
3527: LD_INT 1
3529: ARRAY
3530: PUSH
3531: LD_EXP 22
3535: PUSH
3536: LD_INT 2
3538: ARRAY
3539: PUSH
3540: LD_EXP 22
3544: PUSH
3545: LD_INT 3
3547: ARRAY
3548: PUSH
3549: LD_EXP 22
3553: PUSH
3554: LD_INT 4
3556: ARRAY
3557: PUSH
3558: EMPTY
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: ST_TO_ADDR
3564: GO 3576
// ru_behemoth_mechanic := ru_mech ;
3566: LD_ADDR_EXP 15
3570: PUSH
3571: LD_EXP 22
3575: ST_TO_ADDR
// for i = 1 to ru_mech do
3576: LD_ADDR_VAR 0 1
3580: PUSH
3581: DOUBLE
3582: LD_INT 1
3584: DEC
3585: ST_TO_ADDR
3586: LD_EXP 22
3590: PUSH
3591: FOR_TO
3592: IFFALSE 3646
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3594: LD_EXP 22
3598: PUSH
3599: LD_VAR 0 1
3603: ARRAY
3604: PPUSH
3605: CALL_OW 310
3609: PUSH
3610: LD_EXP 22
3614: PUSH
3615: LD_VAR 0 1
3619: ARRAY
3620: PUSH
3621: LD_EXP 15
3625: IN
3626: AND
3627: IFFALSE 3644
// ComExitBuilding ( ru_mech [ i ] ) ;
3629: LD_EXP 22
3633: PUSH
3634: LD_VAR 0 1
3638: ARRAY
3639: PPUSH
3640: CALL_OW 122
3644: GO 3591
3646: POP
3647: POP
// if UnitsInside ( ru_fac ) = 0 then
3648: LD_INT 14
3650: PPUSH
3651: CALL_OW 313
3655: PUSH
3656: LD_INT 0
3658: EQUAL
3659: IFFALSE 3726
// begin InitHc_All ;
3661: CALL_OW 584
// for i := 1 to 5 do
3665: LD_ADDR_VAR 0 1
3669: PUSH
3670: DOUBLE
3671: LD_INT 1
3673: DEC
3674: ST_TO_ADDR
3675: LD_INT 5
3677: PUSH
3678: FOR_TO
3679: IFFALSE 3724
// begin uc_side := 3 ;
3681: LD_ADDR_OWVAR 20
3685: PUSH
3686: LD_INT 3
3688: ST_TO_ADDR
// uc_nation := 3 ;
3689: LD_ADDR_OWVAR 21
3693: PUSH
3694: LD_INT 3
3696: ST_TO_ADDR
// PrepareHuman ( false , 3 , 7 ) ;
3697: LD_INT 0
3699: PPUSH
3700: LD_INT 3
3702: PPUSH
3703: LD_INT 7
3705: PPUSH
3706: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_fac ) ;
3710: CALL_OW 44
3714: PPUSH
3715: LD_INT 14
3717: PPUSH
3718: CALL_OW 52
// end ;
3722: GO 3678
3724: POP
3725: POP
// end ; if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3726: LD_INT 12
3728: PPUSH
3729: LD_INT 22
3731: PUSH
3732: LD_INT 1
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PUSH
3739: LD_INT 21
3741: PUSH
3742: LD_INT 3
3744: PUSH
3745: EMPTY
3746: LIST
3747: LIST
3748: PUSH
3749: EMPTY
3750: LIST
3751: LIST
3752: PPUSH
3753: CALL_OW 70
3757: PUSH
3758: LD_INT 0
3760: GREATER
3761: IFFALSE 3821
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3763: LD_INT 3
3765: PPUSH
3766: CALL 11454 0 1
3770: PUSH
3771: LD_INT 1
3773: ARRAY
3774: PPUSH
3775: LD_INT 21
3777: PUSH
3778: LD_INT 2
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PUSH
3785: LD_INT 34
3787: PUSH
3788: LD_INT 49
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: PUSH
3795: EMPTY
3796: LIST
3797: LIST
3798: PPUSH
3799: CALL_OW 69
3803: PPUSH
3804: LD_EXP 15
3808: PPUSH
3809: LD_INT 97
3811: PPUSH
3812: LD_INT 9
3814: PPUSH
3815: CALL 10951 0 5
3819: GO 3877
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3821: LD_INT 3
3823: PPUSH
3824: CALL 11454 0 1
3828: PUSH
3829: LD_INT 1
3831: ARRAY
3832: PPUSH
3833: LD_INT 21
3835: PUSH
3836: LD_INT 2
3838: PUSH
3839: EMPTY
3840: LIST
3841: LIST
3842: PUSH
3843: LD_INT 34
3845: PUSH
3846: LD_INT 49
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PUSH
3853: EMPTY
3854: LIST
3855: LIST
3856: PPUSH
3857: CALL_OW 69
3861: PPUSH
3862: LD_EXP 15
3866: PPUSH
3867: LD_INT 153
3869: PPUSH
3870: LD_INT 102
3872: PPUSH
3873: CALL 10951 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3877: LD_EXP 24
3881: PUSH
3882: LD_INT 0
3884: EQUAL
3885: PUSH
3886: LD_INT 44
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: CALL_OW 321
3896: PUSH
3897: LD_INT 2
3899: EQUAL
3900: AND
3901: IFFALSE 3912
// ComChangeClassToBazooker ( ru_sold ) ;
3903: LD_EXP 20
3907: PPUSH
3908: CALL 9888 0 1
// if ru_bazz then
3912: LD_EXP 24
3916: IFFALSE 3930
// IntBazooka ( ru_bazz , 1 ) ;
3918: LD_EXP 24
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: CALL 9607 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3930: LD_INT 67
3932: PPUSH
3933: LD_INT 39
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: CALL_OW 440
3943: PUSH
3944: LD_INT 0
3946: EQUAL
3947: PUSH
3948: LD_INT 20
3950: PPUSH
3951: LD_INT 3
3953: PPUSH
3954: CALL_OW 321
3958: PUSH
3959: LD_INT 2
3961: EQUAL
3962: AND
3963: IFFALSE 3984
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3965: LD_EXP 23
3969: PUSH
3970: LD_INT 1
3972: ARRAY
3973: PPUSH
3974: LD_INT 67
3976: PPUSH
3977: LD_INT 39
3979: PPUSH
3980: CALL 9082 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3984: LD_INT 89
3986: PPUSH
3987: LD_INT 66
3989: PPUSH
3990: LD_INT 3
3992: PPUSH
3993: CALL_OW 440
3997: PUSH
3998: LD_INT 0
4000: EQUAL
4001: IFFALSE 4022
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
4003: LD_EXP 23
4007: PUSH
4008: LD_INT 1
4010: ARRAY
4011: PPUSH
4012: LD_INT 87
4014: PPUSH
4015: LD_INT 60
4017: PPUSH
4018: CALL 9082 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
4022: LD_INT 104
4024: PPUSH
4025: LD_INT 94
4027: PPUSH
4028: LD_INT 3
4030: PPUSH
4031: CALL_OW 440
4035: PUSH
4036: LD_INT 0
4038: EQUAL
4039: PUSH
4040: LD_INT 20
4042: PPUSH
4043: LD_INT 3
4045: PPUSH
4046: CALL_OW 321
4050: PUSH
4051: LD_INT 2
4053: EQUAL
4054: AND
4055: IFFALSE 4076
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
4057: LD_EXP 23
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_INT 104
4068: PPUSH
4069: LD_INT 94
4071: PPUSH
4072: CALL 9082 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
4076: LD_INT 3
4078: PPUSH
4079: LD_INT 24
4081: PPUSH
4082: LD_INT 53
4084: PPUSH
4085: CALL 7978 0 3
4089: PUSH
4090: LD_INT 1
4092: EQUAL
4093: PUSH
4094: LD_EXP 18
4098: AND
4099: IFFALSE 4240
// begin need_buldozer := false ;
4101: LD_ADDR_EXP 18
4105: PUSH
4106: LD_INT 0
4108: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4109: LD_INT 3
4111: PPUSH
4112: LD_INT 24
4114: PPUSH
4115: LD_INT 53
4117: PPUSH
4118: CALL 7978 0 3
4122: PUSH
4123: LD_INT 1
4125: ARRAY
4126: PPUSH
4127: LD_INT 67
4129: PPUSH
4130: LD_INT 39
4132: PPUSH
4133: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4137: LD_INT 3
4139: PPUSH
4140: LD_INT 24
4142: PPUSH
4143: LD_INT 53
4145: PPUSH
4146: CALL 7978 0 3
4150: PUSH
4151: LD_INT 1
4153: ARRAY
4154: PPUSH
4155: LD_INT 71
4157: PPUSH
4158: LD_INT 10
4160: PPUSH
4161: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4165: LD_INT 3
4167: PPUSH
4168: LD_INT 24
4170: PPUSH
4171: LD_INT 53
4173: PPUSH
4174: CALL 7978 0 3
4178: PUSH
4179: LD_INT 1
4181: ARRAY
4182: PPUSH
4183: LD_INT 15
4185: PPUSH
4186: CALL 5569 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4190: LD_INT 3
4192: PPUSH
4193: LD_INT 24
4195: PPUSH
4196: LD_INT 53
4198: PPUSH
4199: CALL 7978 0 3
4203: PUSH
4204: LD_INT 1
4206: ARRAY
4207: PPUSH
4208: LD_INT 350
4210: PPUSH
4211: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4215: LD_INT 3
4217: PPUSH
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 53
4223: PPUSH
4224: CALL 7978 0 3
4228: PUSH
4229: LD_INT 1
4231: ARRAY
4232: PPUSH
4233: LD_INT 14
4235: PPUSH
4236: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4240: LD_INT 67
4242: PPUSH
4243: LD_INT 39
4245: PPUSH
4246: LD_INT 3
4248: PPUSH
4249: CALL_OW 440
4253: PUSH
4254: LD_INT 67
4256: PPUSH
4257: LD_INT 39
4259: PPUSH
4260: CALL_OW 428
4264: PUSH
4265: LD_INT 0
4267: EQUAL
4268: AND
4269: PUSH
4270: LD_INT 79
4272: PPUSH
4273: LD_INT 45
4275: PPUSH
4276: CALL_OW 428
4280: PPUSH
4281: CALL_OW 266
4285: PUSH
4286: LD_INT 0
4288: EQUAL
4289: AND
4290: PUSH
4291: LD_INT 1
4293: PPUSH
4294: LD_INT 79
4296: PPUSH
4297: LD_INT 45
4299: PPUSH
4300: CALL 5469 0 3
4304: PUSH
4305: LD_INT 0
4307: EQUAL
4308: AND
4309: IFFALSE 4412
// begin for i = 1 to ru_eng do
4311: LD_ADDR_VAR 0 1
4315: PUSH
4316: DOUBLE
4317: LD_INT 1
4319: DEC
4320: ST_TO_ADDR
4321: LD_EXP 21
4325: PUSH
4326: FOR_TO
4327: IFFALSE 4410
// if IsInUnit ( ru_eng [ i ] ) then
4329: LD_EXP 21
4333: PUSH
4334: LD_VAR 0 1
4338: ARRAY
4339: PPUSH
4340: CALL_OW 310
4344: IFFALSE 4363
// ComExitBuilding ( ru_eng [ i ] ) else
4346: LD_EXP 21
4350: PUSH
4351: LD_VAR 0 1
4355: ARRAY
4356: PPUSH
4357: CALL_OW 122
4361: GO 4408
// if not HasTask ( ru_eng [ i ] ) then
4363: LD_EXP 21
4367: PUSH
4368: LD_VAR 0 1
4372: ARRAY
4373: PPUSH
4374: CALL_OW 314
4378: NOT
4379: IFFALSE 4408
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4381: LD_EXP 21
4385: PUSH
4386: LD_VAR 0 1
4390: ARRAY
4391: PPUSH
4392: LD_INT 30
4394: PPUSH
4395: LD_INT 67
4397: PPUSH
4398: LD_INT 39
4400: PPUSH
4401: LD_INT 3
4403: PPUSH
4404: CALL_OW 145
4408: GO 4326
4410: POP
4411: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4412: LD_INT 1
4414: PPUSH
4415: LD_INT 79
4417: PPUSH
4418: LD_INT 45
4420: PPUSH
4421: CALL 5469 0 3
4425: PUSH
4426: LD_INT 0
4428: EQUAL
4429: IFFALSE 4625
// begin if HexInfo ( 79 , 45 ) = 0 then
4431: LD_INT 79
4433: PPUSH
4434: LD_INT 45
4436: PPUSH
4437: CALL_OW 428
4441: PUSH
4442: LD_INT 0
4444: EQUAL
4445: IFFALSE 4467
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4447: LD_EXP 21
4451: PPUSH
4452: LD_INT 79
4454: PPUSH
4455: LD_INT 45
4457: PPUSH
4458: LD_INT 3
4460: PPUSH
4461: CALL 6993 0 4
4465: GO 4625
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4467: LD_INT 89
4469: PPUSH
4470: LD_INT 66
4472: PPUSH
4473: CALL_OW 428
4477: PUSH
4478: LD_INT 0
4480: EQUAL
4481: PUSH
4482: LD_INT 89
4484: PPUSH
4485: LD_INT 66
4487: PPUSH
4488: LD_INT 3
4490: PPUSH
4491: CALL_OW 440
4495: AND
4496: IFFALSE 4625
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4498: LD_INT 79
4500: PPUSH
4501: LD_INT 45
4503: PPUSH
4504: CALL_OW 428
4508: PPUSH
4509: CALL_OW 274
4513: PPUSH
4514: LD_INT 1
4516: PPUSH
4517: LD_INT 100
4519: PPUSH
4520: CALL_OW 277
// for i = 1 to ru_eng do
4524: LD_ADDR_VAR 0 1
4528: PUSH
4529: DOUBLE
4530: LD_INT 1
4532: DEC
4533: ST_TO_ADDR
4534: LD_EXP 21
4538: PUSH
4539: FOR_TO
4540: IFFALSE 4623
// if IsInUnit ( ru_eng [ i ] ) then
4542: LD_EXP 21
4546: PUSH
4547: LD_VAR 0 1
4551: ARRAY
4552: PPUSH
4553: CALL_OW 310
4557: IFFALSE 4576
// ComExitBuilding ( ru_eng [ i ] ) else
4559: LD_EXP 21
4563: PUSH
4564: LD_VAR 0 1
4568: ARRAY
4569: PPUSH
4570: CALL_OW 122
4574: GO 4621
// if not HasTask ( ru_eng [ i ] ) then
4576: LD_EXP 21
4580: PUSH
4581: LD_VAR 0 1
4585: ARRAY
4586: PPUSH
4587: CALL_OW 314
4591: NOT
4592: IFFALSE 4621
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4594: LD_EXP 21
4598: PUSH
4599: LD_VAR 0 1
4603: ARRAY
4604: PPUSH
4605: LD_INT 29
4607: PPUSH
4608: LD_INT 89
4610: PPUSH
4611: LD_INT 66
4613: PPUSH
4614: LD_INT 3
4616: PPUSH
4617: CALL_OW 145
4621: GO 4539
4623: POP
4624: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4625: LD_INT 3
4627: PPUSH
4628: LD_INT 29
4630: PPUSH
4631: CALL 6227 0 2
4635: PUSH
4636: LD_INT 0
4638: EQUAL
4639: PUSH
4640: LD_INT 1
4642: PPUSH
4643: LD_INT 36
4645: PPUSH
4646: LD_INT 6
4648: PPUSH
4649: CALL 5469 0 3
4653: PUSH
4654: LD_INT 0
4656: EQUAL
4657: AND
4658: PUSH
4659: LD_INT 3
4661: PPUSH
4662: CALL 6136 0 1
4666: PPUSH
4667: LD_INT 29
4669: PPUSH
4670: CALL 5712 0 2
4674: AND
4675: IFFALSE 4778
// begin for i = 1 to ru_eng do
4677: LD_ADDR_VAR 0 1
4681: PUSH
4682: DOUBLE
4683: LD_INT 1
4685: DEC
4686: ST_TO_ADDR
4687: LD_EXP 21
4691: PUSH
4692: FOR_TO
4693: IFFALSE 4776
// begin if IsInUnit ( ru_eng [ i ] ) then
4695: LD_EXP 21
4699: PUSH
4700: LD_VAR 0 1
4704: ARRAY
4705: PPUSH
4706: CALL_OW 310
4710: IFFALSE 4729
// ComExitBuilding ( ru_eng [ i ] ) else
4712: LD_EXP 21
4716: PUSH
4717: LD_VAR 0 1
4721: ARRAY
4722: PPUSH
4723: CALL_OW 122
4727: GO 4774
// if not HasTask ( ru_eng [ i ] ) then
4729: LD_EXP 21
4733: PUSH
4734: LD_VAR 0 1
4738: ARRAY
4739: PPUSH
4740: CALL_OW 314
4744: NOT
4745: IFFALSE 4774
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4747: LD_EXP 21
4751: PUSH
4752: LD_VAR 0 1
4756: ARRAY
4757: PPUSH
4758: LD_INT 29
4760: PPUSH
4761: LD_INT 33
4763: PPUSH
4764: LD_INT 4
4766: PPUSH
4767: LD_INT 0
4769: PPUSH
4770: CALL_OW 205
// end ; end ;
4774: GO 4692
4776: POP
4777: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4778: LD_EXP 21
4782: PUSH
4783: LD_INT 79
4785: PPUSH
4786: LD_INT 45
4788: PPUSH
4789: CALL_OW 428
4793: PUSH
4794: LD_INT 0
4796: GREATER
4797: AND
4798: PUSH
4799: LD_INT 79
4801: PPUSH
4802: LD_INT 45
4804: PPUSH
4805: CALL_OW 428
4809: PPUSH
4810: CALL_OW 266
4814: PUSH
4815: LD_INT 0
4817: EQUAL
4818: AND
4819: IFFALSE 4979
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4821: LD_INT 79
4823: PPUSH
4824: LD_INT 45
4826: PPUSH
4827: CALL_OW 428
4831: PPUSH
4832: CALL_OW 255
4836: PUSH
4837: LD_INT 3
4839: EQUAL
4840: PUSH
4841: LD_INT 1
4843: PPUSH
4844: LD_INT 79
4846: PPUSH
4847: LD_INT 45
4849: PPUSH
4850: CALL 5469 0 3
4854: PUSH
4855: LD_INT 0
4857: EQUAL
4858: AND
4859: PUSH
4860: LD_INT 79
4862: PPUSH
4863: LD_INT 45
4865: PPUSH
4866: CALL_OW 428
4870: PPUSH
4871: CALL_OW 274
4875: PPUSH
4876: LD_INT 3
4878: PPUSH
4879: CALL_OW 275
4883: PUSH
4884: LD_INT 10
4886: GREATEREQUAL
4887: AND
4888: IFFALSE 4979
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4890: LD_EXP 21
4894: PUSH
4895: LD_INT 1
4897: ARRAY
4898: PPUSH
4899: CALL_OW 310
4903: IFFALSE 4920
// ComExitBuilding ( ru_eng [ 1 ] ) else
4905: LD_EXP 21
4909: PUSH
4910: LD_INT 1
4912: ARRAY
4913: PPUSH
4914: CALL_OW 122
4918: GO 4979
// if not HasTask ( ru_eng [ 1 ] ) then
4920: LD_EXP 21
4924: PUSH
4925: LD_INT 1
4927: ARRAY
4928: PPUSH
4929: CALL_OW 314
4933: NOT
4934: IFFALSE 4979
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4936: LD_EXP 21
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: PPUSH
4945: LD_INT 79
4947: PPUSH
4948: LD_INT 45
4950: PPUSH
4951: CALL_OW 428
4955: PPUSH
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4963: LD_EXP 21
4967: PUSH
4968: LD_INT 1
4970: ARRAY
4971: PPUSH
4972: LD_INT 2
4974: PPUSH
4975: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4979: LD_EXP 21
4983: PUSH
4984: LD_INT 2
4986: GREATER
4987: PUSH
4988: LD_INT 79
4990: PPUSH
4991: LD_INT 45
4993: PPUSH
4994: CALL_OW 428
4998: PUSH
4999: LD_INT 0
5001: GREATER
5002: AND
5003: PUSH
5004: LD_INT 79
5006: PPUSH
5007: LD_INT 45
5009: PPUSH
5010: CALL_OW 428
5014: PPUSH
5015: CALL_OW 266
5019: PUSH
5020: LD_INT 0
5022: EQUAL
5023: AND
5024: IFFALSE 5184
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
5026: LD_INT 79
5028: PPUSH
5029: LD_INT 45
5031: PPUSH
5032: CALL_OW 428
5036: PPUSH
5037: CALL_OW 255
5041: PUSH
5042: LD_INT 3
5044: EQUAL
5045: PUSH
5046: LD_INT 1
5048: PPUSH
5049: LD_INT 79
5051: PPUSH
5052: LD_INT 45
5054: PPUSH
5055: CALL 5469 0 3
5059: PUSH
5060: LD_INT 0
5062: EQUAL
5063: AND
5064: PUSH
5065: LD_INT 79
5067: PPUSH
5068: LD_INT 45
5070: PPUSH
5071: CALL_OW 428
5075: PPUSH
5076: CALL_OW 274
5080: PPUSH
5081: LD_INT 1
5083: PPUSH
5084: CALL_OW 275
5088: PUSH
5089: LD_INT 20
5091: GREATER
5092: AND
5093: IFFALSE 5184
// begin if IsInUnit ( ru_eng [ 2 ] ) then
5095: LD_EXP 21
5099: PUSH
5100: LD_INT 2
5102: ARRAY
5103: PPUSH
5104: CALL_OW 310
5108: IFFALSE 5125
// ComExitBuilding ( ru_eng [ 2 ] ) else
5110: LD_EXP 21
5114: PUSH
5115: LD_INT 2
5117: ARRAY
5118: PPUSH
5119: CALL_OW 122
5123: GO 5184
// if not HasTask ( ru_eng [ 2 ] ) then
5125: LD_EXP 21
5129: PUSH
5130: LD_INT 2
5132: ARRAY
5133: PPUSH
5134: CALL_OW 314
5138: NOT
5139: IFFALSE 5184
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5141: LD_EXP 21
5145: PUSH
5146: LD_INT 2
5148: ARRAY
5149: PPUSH
5150: LD_INT 79
5152: PPUSH
5153: LD_INT 45
5155: PPUSH
5156: CALL_OW 428
5160: PPUSH
5161: LD_INT 1
5163: PPUSH
5164: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5168: LD_EXP 21
5172: PUSH
5173: LD_INT 2
5175: ARRAY
5176: PPUSH
5177: LD_INT 2
5179: PPUSH
5180: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5184: LD_INT 1
5186: PPUSH
5187: LD_INT 59
5189: PPUSH
5190: LD_INT 60
5192: PPUSH
5193: CALL 5469 0 3
5197: PUSH
5198: LD_INT 0
5200: EQUAL
5201: PUSH
5202: LD_INT 1
5204: PPUSH
5205: LD_INT 67
5207: PPUSH
5208: LD_INT 76
5210: PPUSH
5211: CALL 5469 0 3
5215: PUSH
5216: LD_INT 0
5218: EQUAL
5219: AND
5220: PUSH
5221: LD_INT 1
5223: PPUSH
5224: LD_INT 79
5226: PPUSH
5227: LD_INT 100
5229: PPUSH
5230: CALL 5469 0 3
5234: PUSH
5235: LD_INT 0
5237: EQUAL
5238: AND
5239: IFFALSE 5251
// CollectCrates ( 3 , west_crates ) ;
5241: LD_INT 3
5243: PPUSH
5244: LD_INT 13
5246: PPUSH
5247: CALL 11498 0 2
// end ;
5251: PPOPN 10
5253: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5254: LD_OWVAR 1
5258: PUSH
5259: LD_INT 111300
5261: LESSEQUAL
5262: PUSH
5263: LD_EXP 30
5267: NOT
5268: OR
5269: IFFALSE 5466
5271: GO 5273
5273: DISABLE
5274: LD_INT 0
5276: PPUSH
// begin enable ;
5277: ENABLE
// uc_nation := 3 ;
5278: LD_ADDR_OWVAR 21
5282: PUSH
5283: LD_INT 3
5285: ST_TO_ADDR
// uc_side := 3 ;
5286: LD_ADDR_OWVAR 20
5290: PUSH
5291: LD_INT 3
5293: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5294: LD_ADDR_OWVAR 37
5298: PUSH
5299: LD_INT 22
5301: ST_TO_ADDR
// vc_engine := engine_siberite ;
5302: LD_ADDR_OWVAR 39
5306: PUSH
5307: LD_INT 3
5309: ST_TO_ADDR
// vc_control := control_computer ;
5310: LD_ADDR_OWVAR 38
5314: PUSH
5315: LD_INT 3
5317: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5318: LD_ADDR_OWVAR 40
5322: PUSH
5323: LD_INT 51
5325: ST_TO_ADDR
// veh := CreateVehicle ;
5326: LD_ADDR_VAR 0 1
5330: PUSH
5331: CALL_OW 45
5335: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5336: LD_VAR 0 1
5340: PPUSH
5341: LD_INT 4
5343: PPUSH
5344: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5348: LD_VAR 0 1
5352: PPUSH
5353: LD_INT 10
5355: PPUSH
5356: LD_INT 0
5358: PPUSH
5359: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5363: LD_VAR 0 1
5367: PPUSH
5368: LD_INT 1
5370: PUSH
5371: LD_INT 2
5373: PUSH
5374: LD_INT 3
5376: PUSH
5377: LD_INT 2
5379: PUSH
5380: EMPTY
5381: LIST
5382: LIST
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 1
5388: PPUSH
5389: LD_INT 4
5391: PPUSH
5392: CALL_OW 12
5396: ARRAY
5397: PPUSH
5398: LD_INT 100
5400: PPUSH
5401: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5405: LD_VAR 0 1
5409: PPUSH
5410: LD_INT 2
5412: PPUSH
5413: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5417: LD_VAR 0 1
5421: PPUSH
5422: LD_INT 10
5424: PPUSH
5425: CALL_OW 173
// Wait ( 0 0$10 ) ;
5429: LD_INT 350
5431: PPUSH
5432: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5436: LD_INT 35
5438: PPUSH
5439: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5443: LD_VAR 0 1
5447: PPUSH
5448: LD_INT 10
5450: PPUSH
5451: CALL_OW 308
5455: IFFALSE 5436
// RemoveUnit ( veh ) ;
5457: LD_VAR 0 1
5461: PPUSH
5462: CALL_OW 64
// end ; end_of_file
5466: PPOPN 1
5468: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
5469: LD_INT 0
5471: PPUSH
5472: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
5473: LD_ADDR_VAR 0 5
5477: PUSH
5478: LD_INT 22
5480: PUSH
5481: LD_VAR 0 1
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: PPUSH
5490: CALL_OW 69
5494: PPUSH
5495: LD_VAR 0 2
5499: PPUSH
5500: LD_VAR 0 3
5504: PPUSH
5505: CALL_OW 73
5509: ST_TO_ADDR
// result := GetDistUnitXY ( i , x , y ) < 15 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 ;
5510: LD_ADDR_VAR 0 4
5514: PUSH
5515: LD_VAR 0 5
5519: PPUSH
5520: LD_VAR 0 2
5524: PPUSH
5525: LD_VAR 0 3
5529: PPUSH
5530: CALL_OW 297
5534: PUSH
5535: LD_INT 15
5537: LESS
5538: PUSH
5539: LD_INT 2
5541: PPUSH
5542: LD_INT 22
5544: PUSH
5545: LD_VAR 0 1
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PPUSH
5554: CALL_OW 70
5558: PUSH
5559: LD_INT 0
5561: GREATER
5562: OR
5563: ST_TO_ADDR
// end ;
5564: LD_VAR 0 4
5568: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
5569: LD_INT 0
5571: PPUSH
5572: PPUSH
// area = ListEnvironmentArea ( area ) ;
5573: LD_ADDR_VAR 0 2
5577: PUSH
5578: LD_VAR 0 2
5582: PPUSH
5583: CALL_OW 353
5587: ST_TO_ADDR
// if bulldozer > 0 then
5588: LD_VAR 0 1
5592: PUSH
5593: LD_INT 0
5595: GREATER
5596: IFFALSE 5707
// for i = 1 to area do
5598: LD_ADDR_VAR 0 4
5602: PUSH
5603: DOUBLE
5604: LD_INT 1
5606: DEC
5607: ST_TO_ADDR
5608: LD_VAR 0 2
5612: PUSH
5613: FOR_TO
5614: IFFALSE 5705
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
5616: LD_VAR 0 2
5620: PUSH
5621: LD_VAR 0 4
5625: ARRAY
5626: PUSH
5627: LD_INT 1
5629: ARRAY
5630: PPUSH
5631: LD_VAR 0 2
5635: PUSH
5636: LD_VAR 0 4
5640: ARRAY
5641: PUSH
5642: LD_INT 2
5644: ARRAY
5645: PPUSH
5646: CALL_OW 351
5650: IFFALSE 5703
// if not HasTask ( bulldozer ) then
5652: LD_VAR 0 1
5656: PPUSH
5657: CALL_OW 314
5661: NOT
5662: IFFALSE 5703
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
5664: LD_VAR 0 1
5668: PPUSH
5669: LD_VAR 0 2
5673: PUSH
5674: LD_VAR 0 4
5678: ARRAY
5679: PUSH
5680: LD_INT 1
5682: ARRAY
5683: PPUSH
5684: LD_VAR 0 2
5688: PUSH
5689: LD_VAR 0 4
5693: ARRAY
5694: PUSH
5695: LD_INT 2
5697: ARRAY
5698: PPUSH
5699: CALL_OW 171
5703: GO 5613
5705: POP
5706: POP
// end ;
5707: LD_VAR 0 3
5711: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
5712: LD_INT 0
5714: PPUSH
5715: PPUSH
5716: PPUSH
// pom := GetBase ( bdepot ) ;
5717: LD_ADDR_VAR 0 4
5721: PUSH
5722: LD_VAR 0 1
5726: PPUSH
5727: CALL_OW 274
5731: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
5732: LD_ADDR_VAR 0 5
5736: PUSH
5737: LD_VAR 0 2
5741: PPUSH
5742: LD_VAR 0 1
5746: PPUSH
5747: CALL_OW 248
5751: PPUSH
5752: CALL_OW 450
5756: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
5757: LD_VAR 0 4
5761: PPUSH
5762: LD_INT 1
5764: PPUSH
5765: CALL_OW 275
5769: PUSH
5770: LD_VAR 0 5
5774: PUSH
5775: LD_INT 1
5777: ARRAY
5778: GREATEREQUAL
5779: PUSH
5780: LD_VAR 0 4
5784: PPUSH
5785: LD_INT 3
5787: PPUSH
5788: CALL_OW 275
5792: PUSH
5793: LD_VAR 0 5
5797: PUSH
5798: LD_INT 3
5800: ARRAY
5801: GREATEREQUAL
5802: AND
5803: IFFALSE 5815
// result := true else
5805: LD_ADDR_VAR 0 3
5809: PUSH
5810: LD_INT 1
5812: ST_TO_ADDR
5813: GO 5823
// result := false ;
5815: LD_ADDR_VAR 0 3
5819: PUSH
5820: LD_INT 0
5822: ST_TO_ADDR
// end ;
5823: LD_VAR 0 3
5827: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
5828: LD_INT 0
5830: PPUSH
5831: PPUSH
5832: PPUSH
// pom := GetBase ( bdepot ) ;
5833: LD_ADDR_VAR 0 3
5837: PUSH
5838: LD_VAR 0 1
5842: PPUSH
5843: CALL_OW 274
5847: ST_TO_ADDR
// sor := [ ] ;
5848: LD_ADDR_VAR 0 4
5852: PUSH
5853: EMPTY
5854: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
5855: LD_ADDR_VAR 0 4
5859: PUSH
5860: LD_VAR 0 4
5864: PUSH
5865: LD_VAR 0 3
5869: PPUSH
5870: LD_INT 1
5872: PPUSH
5873: CALL_OW 275
5877: ADD
5878: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
5879: LD_ADDR_VAR 0 4
5883: PUSH
5884: LD_VAR 0 4
5888: PUSH
5889: LD_VAR 0 3
5893: PPUSH
5894: LD_INT 2
5896: PPUSH
5897: CALL_OW 275
5901: ADD
5902: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
5903: LD_ADDR_VAR 0 4
5907: PUSH
5908: LD_VAR 0 4
5912: PUSH
5913: LD_VAR 0 3
5917: PPUSH
5918: LD_INT 3
5920: PPUSH
5921: CALL_OW 275
5925: ADD
5926: ST_TO_ADDR
// result := sor ;
5927: LD_ADDR_VAR 0 2
5931: PUSH
5932: LD_VAR 0 4
5936: ST_TO_ADDR
// end ;
5937: LD_VAR 0 2
5941: RET
// export function Hex ( x , y ) ; begin
5942: LD_INT 0
5944: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
5945: LD_VAR 0 1
5949: PPUSH
5950: LD_VAR 0 2
5954: PPUSH
5955: CALL_OW 488
5959: PUSH
5960: LD_VAR 0 1
5964: PPUSH
5965: LD_VAR 0 2
5969: PPUSH
5970: CALL_OW 428
5974: PUSH
5975: LD_INT 0
5977: EQUAL
5978: AND
5979: IFFALSE 5991
// result := true else
5981: LD_ADDR_VAR 0 3
5985: PUSH
5986: LD_INT 1
5988: ST_TO_ADDR
5989: GO 5999
// result := false ;
5991: LD_ADDR_VAR 0 3
5995: PUSH
5996: LD_INT 0
5998: ST_TO_ADDR
// end ;
5999: LD_VAR 0 3
6003: RET
// export function NeedBuilding ( side , btype ) ; begin
6004: LD_INT 0
6006: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
6007: LD_INT 22
6009: PUSH
6010: LD_VAR 0 1
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 30
6021: PUSH
6022: LD_VAR 0 2
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: PUSH
6031: LD_INT 3
6033: PUSH
6034: LD_INT 57
6036: PUSH
6037: EMPTY
6038: LIST
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PUSH
6044: EMPTY
6045: LIST
6046: LIST
6047: LIST
6048: PPUSH
6049: CALL_OW 69
6053: PUSH
6054: LD_INT 0
6056: EQUAL
6057: IFFALSE 6069
// result := true else
6059: LD_ADDR_VAR 0 3
6063: PUSH
6064: LD_INT 1
6066: ST_TO_ADDR
6067: GO 6077
// result := false ;
6069: LD_ADDR_VAR 0 3
6073: PUSH
6074: LD_INT 0
6076: ST_TO_ADDR
// end ;
6077: LD_VAR 0 3
6081: RET
// export function NeedBase ( side ) ; begin
6082: LD_INT 0
6084: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6085: LD_VAR 0 1
6089: PPUSH
6090: LD_INT 0
6092: PPUSH
6093: CALL 6004 0 2
6097: PUSH
6098: LD_VAR 0 1
6102: PPUSH
6103: LD_INT 1
6105: PPUSH
6106: CALL 6004 0 2
6110: AND
6111: IFFALSE 6123
// result := true else
6113: LD_ADDR_VAR 0 2
6117: PUSH
6118: LD_INT 1
6120: ST_TO_ADDR
6121: GO 6131
// result := false ;
6123: LD_ADDR_VAR 0 2
6127: PUSH
6128: LD_INT 0
6130: ST_TO_ADDR
// end ;
6131: LD_VAR 0 2
6135: RET
// export function MyBase ( side ) ; begin
6136: LD_INT 0
6138: PPUSH
// if not NeedBase ( side ) then
6139: LD_VAR 0 1
6143: PPUSH
6144: CALL 6082 0 1
6148: NOT
6149: IFFALSE 6214
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6151: LD_ADDR_VAR 0 2
6155: PUSH
6156: LD_INT 22
6158: PUSH
6159: LD_VAR 0 1
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: PUSH
6168: LD_INT 2
6170: PUSH
6171: LD_INT 30
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: PUSH
6181: LD_INT 30
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PUSH
6200: EMPTY
6201: LIST
6202: PPUSH
6203: CALL_OW 69
6207: PUSH
6208: LD_INT 1
6210: ARRAY
6211: ST_TO_ADDR
6212: GO 6222
// result := false ;
6214: LD_ADDR_VAR 0 2
6218: PUSH
6219: LD_INT 0
6221: ST_TO_ADDR
// end ;
6222: LD_VAR 0 2
6226: RET
// export function GetBuilding ( side , btype ) ; begin
6227: LD_INT 0
6229: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6230: LD_INT 22
6232: PUSH
6233: LD_VAR 0 1
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: PUSH
6242: LD_INT 30
6244: PUSH
6245: LD_VAR 0 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: PUSH
6254: EMPTY
6255: LIST
6256: LIST
6257: PPUSH
6258: CALL_OW 69
6262: PUSH
6263: LD_INT 0
6265: GREATER
6266: IFFALSE 6308
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6268: LD_ADDR_VAR 0 3
6272: PUSH
6273: LD_INT 22
6275: PUSH
6276: LD_VAR 0 1
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PUSH
6285: LD_INT 30
6287: PUSH
6288: LD_VAR 0 2
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: PPUSH
6301: CALL_OW 69
6305: ST_TO_ADDR
6306: GO 6316
// result := false ;
6308: LD_ADDR_VAR 0 3
6312: PUSH
6313: LD_INT 0
6315: ST_TO_ADDR
// end ;
6316: LD_VAR 0 3
6320: RET
// export function GetCrates ( side ) ; begin
6321: LD_INT 0
6323: PPUSH
// result := 0 ;
6324: LD_ADDR_VAR 0 2
6328: PUSH
6329: LD_INT 0
6331: ST_TO_ADDR
// if MyBase ( side ) then
6332: LD_VAR 0 1
6336: PPUSH
6337: CALL 6136 0 1
6341: IFFALSE 6371
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) ;
6343: LD_ADDR_VAR 0 2
6347: PUSH
6348: LD_VAR 0 1
6352: PPUSH
6353: CALL 6136 0 1
6357: PPUSH
6358: CALL_OW 274
6362: PPUSH
6363: LD_INT 1
6365: PPUSH
6366: CALL_OW 275
6370: ST_TO_ADDR
// end ;
6371: LD_VAR 0 2
6375: RET
// export function GetLabs ( side ) ; begin
6376: LD_INT 0
6378: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6379: LD_ADDR_VAR 0 2
6383: PUSH
6384: LD_INT 22
6386: PUSH
6387: LD_VAR 0 1
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: LD_INT 2
6398: PUSH
6399: LD_INT 30
6401: PUSH
6402: LD_INT 6
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: LD_INT 30
6411: PUSH
6412: LD_INT 8
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: PUSH
6419: LD_INT 30
6421: PUSH
6422: LD_INT 7
6424: PUSH
6425: EMPTY
6426: LIST
6427: LIST
6428: PUSH
6429: EMPTY
6430: LIST
6431: LIST
6432: LIST
6433: LIST
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: PUSH
6439: EMPTY
6440: LIST
6441: PPUSH
6442: CALL_OW 69
6446: ST_TO_ADDR
// end ;
6447: LD_VAR 0 2
6451: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
6452: LD_INT 0
6454: PPUSH
6455: PPUSH
6456: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
6457: LD_ADDR_VAR 0 3
6461: PUSH
6462: LD_VAR 0 1
6466: PPUSH
6467: LD_INT 1
6469: PPUSH
6470: CALL_OW 268
6474: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
6475: LD_ADDR_VAR 0 4
6479: PUSH
6480: LD_VAR 0 1
6484: PPUSH
6485: LD_INT 2
6487: PPUSH
6488: CALL_OW 268
6492: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
6493: LD_ADDR_VAR 0 2
6497: PUSH
6498: LD_VAR 0 3
6502: PUSH
6503: LD_VAR 0 4
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: ST_TO_ADDR
// end ;
6512: LD_VAR 0 2
6516: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
6517: LD_INT 0
6519: PPUSH
6520: PPUSH
// result := false ;
6521: LD_ADDR_VAR 0 3
6525: PUSH
6526: LD_INT 0
6528: ST_TO_ADDR
// for i = 1 to tlist do
6529: LD_ADDR_VAR 0 4
6533: PUSH
6534: DOUBLE
6535: LD_INT 1
6537: DEC
6538: ST_TO_ADDR
6539: LD_VAR 0 2
6543: PUSH
6544: FOR_TO
6545: IFFALSE 6585
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6547: LD_VAR 0 2
6551: PUSH
6552: LD_VAR 0 4
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 1
6562: PPUSH
6563: CALL_OW 321
6567: PUSH
6568: LD_INT 2
6570: NONEQUAL
6571: IFFALSE 6583
// begin result := true ;
6573: LD_ADDR_VAR 0 3
6577: PUSH
6578: LD_INT 1
6580: ST_TO_ADDR
// break ;
6581: GO 6585
// end ;
6583: GO 6544
6585: POP
6586: POP
// end ;
6587: LD_VAR 0 3
6591: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
6597: PPUSH
6598: PPUSH
6599: PPUSH
6600: PPUSH
6601: PPUSH
// lab := GetLabs ( side ) ;
6602: LD_ADDR_VAR 0 5
6606: PUSH
6607: LD_VAR 0 1
6611: PPUSH
6612: CALL 6376 0 1
6616: ST_TO_ADDR
// tmp := 0 ;
6617: LD_ADDR_VAR 0 7
6621: PUSH
6622: LD_INT 0
6624: ST_TO_ADDR
// list := [ ] ;
6625: LD_ADDR_VAR 0 8
6629: PUSH
6630: EMPTY
6631: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
6632: LD_ADDR_VAR 0 10
6636: PUSH
6637: LD_INT 35
6639: PUSH
6640: LD_INT 45
6642: PUSH
6643: LD_INT 46
6645: PUSH
6646: LD_INT 47
6648: PUSH
6649: LD_INT 1
6651: PUSH
6652: LD_INT 2
6654: PUSH
6655: LD_INT 48
6657: PUSH
6658: LD_INT 49
6660: PUSH
6661: LD_INT 50
6663: PUSH
6664: LD_INT 20
6666: PUSH
6667: EMPTY
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: ST_TO_ADDR
// for i = 1 to tlist do
6679: LD_ADDR_VAR 0 4
6683: PUSH
6684: DOUBLE
6685: LD_INT 1
6687: DEC
6688: ST_TO_ADDR
6689: LD_VAR 0 2
6693: PUSH
6694: FOR_TO
6695: IFFALSE 6747
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6697: LD_VAR 0 2
6701: PUSH
6702: LD_VAR 0 4
6706: ARRAY
6707: PPUSH
6708: LD_VAR 0 1
6712: PPUSH
6713: CALL_OW 321
6717: PUSH
6718: LD_INT 2
6720: NONEQUAL
6721: IFFALSE 6745
// list := list ^ tlist [ i ] ;
6723: LD_ADDR_VAR 0 8
6727: PUSH
6728: LD_VAR 0 8
6732: PUSH
6733: LD_VAR 0 2
6737: PUSH
6738: LD_VAR 0 4
6742: ARRAY
6743: ADD
6744: ST_TO_ADDR
6745: GO 6694
6747: POP
6748: POP
// if list then
6749: LD_VAR 0 8
6753: IFFALSE 6918
// begin for i = 1 to lab do
6755: LD_ADDR_VAR 0 4
6759: PUSH
6760: DOUBLE
6761: LD_INT 1
6763: DEC
6764: ST_TO_ADDR
6765: LD_VAR 0 5
6769: PUSH
6770: FOR_TO
6771: IFFALSE 6841
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
6773: LD_VAR 0 8
6777: PUSH
6778: LD_INT 1
6780: ARRAY
6781: PUSH
6782: LD_VAR 0 10
6786: IN
6787: PUSH
6788: LD_VAR 0 8
6792: PUSH
6793: LD_INT 1
6795: ARRAY
6796: PPUSH
6797: CALL_OW 481
6801: PUSH
6802: LD_VAR 0 5
6806: PUSH
6807: LD_VAR 0 4
6811: ARRAY
6812: PPUSH
6813: CALL 6452 0 1
6817: IN
6818: OR
6819: IFFALSE 6839
// begin mylab := lab [ i ] ;
6821: LD_ADDR_VAR 0 9
6825: PUSH
6826: LD_VAR 0 5
6830: PUSH
6831: LD_VAR 0 4
6835: ARRAY
6836: ST_TO_ADDR
// break ;
6837: GO 6841
// end ;
6839: GO 6770
6841: POP
6842: POP
// if mylab then
6843: LD_VAR 0 9
6847: IFFALSE 6908
// begin if BuildingStatus ( mylab ) = bs_idle then
6849: LD_VAR 0 9
6853: PPUSH
6854: CALL_OW 461
6858: PUSH
6859: LD_INT 2
6861: EQUAL
6862: IFFALSE 6906
// for i = 1 to list do
6864: LD_ADDR_VAR 0 4
6868: PUSH
6869: DOUBLE
6870: LD_INT 1
6872: DEC
6873: ST_TO_ADDR
6874: LD_VAR 0 8
6878: PUSH
6879: FOR_TO
6880: IFFALSE 6904
// AddComResearch ( mylab , list [ i ] ) ;
6882: LD_VAR 0 9
6886: PPUSH
6887: LD_VAR 0 8
6891: PUSH
6892: LD_VAR 0 4
6896: ARRAY
6897: PPUSH
6898: CALL_OW 184
6902: GO 6879
6904: POP
6905: POP
// end else
6906: GO 6916
// result := false ;
6908: LD_ADDR_VAR 0 3
6912: PUSH
6913: LD_INT 0
6915: ST_TO_ADDR
// end else
6916: GO 6926
// result := false ;
6918: LD_ADDR_VAR 0 3
6922: PUSH
6923: LD_INT 0
6925: ST_TO_ADDR
// end ;
6926: LD_VAR 0 3
6930: RET
// export function GetTowers ( side ) ; begin
6931: LD_INT 0
6933: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
6934: LD_ADDR_VAR 0 2
6938: PUSH
6939: LD_INT 22
6941: PUSH
6942: LD_VAR 0 1
6946: PUSH
6947: EMPTY
6948: LIST
6949: LIST
6950: PUSH
6951: LD_INT 2
6953: PUSH
6954: LD_INT 30
6956: PUSH
6957: LD_INT 32
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: PUSH
6964: LD_INT 30
6966: PUSH
6967: LD_INT 33
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: LIST
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PPUSH
6983: CALL_OW 69
6987: ST_TO_ADDR
// end ;
6988: LD_VAR 0 2
6992: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
6993: LD_INT 0
6995: PPUSH
6996: PPUSH
// if Hex ( x , y ) then
6997: LD_VAR 0 2
7001: PPUSH
7002: LD_VAR 0 3
7006: PPUSH
7007: CALL 5942 0 2
7011: IFFALSE 7086
// for i = 1 to plist do
7013: LD_ADDR_VAR 0 6
7017: PUSH
7018: DOUBLE
7019: LD_INT 1
7021: DEC
7022: ST_TO_ADDR
7023: LD_VAR 0 1
7027: PUSH
7028: FOR_TO
7029: IFFALSE 7084
// if not HasTask ( plist [ i ] ) then
7031: LD_VAR 0 1
7035: PUSH
7036: LD_VAR 0 6
7040: ARRAY
7041: PPUSH
7042: CALL_OW 314
7046: NOT
7047: IFFALSE 7082
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
7049: LD_VAR 0 1
7053: PUSH
7054: LD_VAR 0 6
7058: ARRAY
7059: PPUSH
7060: LD_INT 0
7062: PPUSH
7063: LD_VAR 0 2
7067: PPUSH
7068: LD_VAR 0 3
7072: PPUSH
7073: LD_VAR 0 4
7077: PPUSH
7078: CALL_OW 145
7082: GO 7028
7084: POP
7085: POP
// end ;
7086: LD_VAR 0 5
7090: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7095: LD_VAR 0 2
7099: PPUSH
7100: CALL_OW 266
7104: PUSH
7105: LD_INT 0
7107: EQUAL
7108: PUSH
7109: LD_VAR 0 2
7113: PPUSH
7114: LD_INT 1
7116: PPUSH
7117: CALL 5712 0 2
7121: AND
7122: PUSH
7123: LD_VAR 0 1
7127: PUSH
7128: LD_INT 1
7130: ARRAY
7131: PPUSH
7132: CALL_OW 255
7136: PPUSH
7137: CALL_OW 345
7141: NOT
7142: AND
7143: IFFALSE 7239
// begin ComUpgrade ( bident ) ;
7145: LD_VAR 0 2
7149: PPUSH
7150: CALL_OW 146
// for i = 1 to plist do
7154: LD_ADDR_VAR 0 4
7158: PUSH
7159: DOUBLE
7160: LD_INT 1
7162: DEC
7163: ST_TO_ADDR
7164: LD_VAR 0 1
7168: PUSH
7169: FOR_TO
7170: IFFALSE 7227
// if not HasTask ( plist [ i ] ) then
7172: LD_VAR 0 1
7176: PUSH
7177: LD_VAR 0 4
7181: ARRAY
7182: PPUSH
7183: CALL_OW 314
7187: NOT
7188: IFFALSE 7225
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7190: LD_VAR 0 1
7194: PUSH
7195: LD_VAR 0 4
7199: ARRAY
7200: PPUSH
7201: LD_VAR 0 2
7205: PPUSH
7206: CALL_OW 250
7210: PPUSH
7211: LD_VAR 0 2
7215: PPUSH
7216: CALL_OW 251
7220: PPUSH
7221: CALL_OW 111
7225: GO 7169
7227: POP
7228: POP
// result := true ;
7229: LD_ADDR_VAR 0 3
7233: PUSH
7234: LD_INT 1
7236: ST_TO_ADDR
// end else
7237: GO 7247
// result := false ;
7239: LD_ADDR_VAR 0 3
7243: PUSH
7244: LD_INT 0
7246: ST_TO_ADDR
// end ;
7247: LD_VAR 0 3
7251: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7252: LD_INT 0
7254: PPUSH
7255: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7256: LD_VAR 0 1
7260: PUSH
7261: LD_INT 1
7263: ARRAY
7264: PPUSH
7265: CALL_OW 255
7269: PPUSH
7270: CALL 6321 0 1
7274: PUSH
7275: LD_INT 20
7277: GREATEREQUAL
7278: PUSH
7279: LD_VAR 0 2
7283: PPUSH
7284: LD_VAR 0 3
7288: PPUSH
7289: CALL 5942 0 2
7293: AND
7294: IFFALSE 7379
// begin for i = 1 to plist do
7296: LD_ADDR_VAR 0 6
7300: PUSH
7301: DOUBLE
7302: LD_INT 1
7304: DEC
7305: ST_TO_ADDR
7306: LD_VAR 0 1
7310: PUSH
7311: FOR_TO
7312: IFFALSE 7367
// if not HasTask ( plist [ i ] ) then
7314: LD_VAR 0 1
7318: PUSH
7319: LD_VAR 0 6
7323: ARRAY
7324: PPUSH
7325: CALL_OW 314
7329: NOT
7330: IFFALSE 7365
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7332: LD_VAR 0 1
7336: PUSH
7337: LD_VAR 0 6
7341: ARRAY
7342: PPUSH
7343: LD_INT 6
7345: PPUSH
7346: LD_VAR 0 2
7350: PPUSH
7351: LD_VAR 0 3
7355: PPUSH
7356: LD_VAR 0 4
7360: PPUSH
7361: CALL_OW 145
7365: GO 7311
7367: POP
7368: POP
// result := true ;
7369: LD_ADDR_VAR 0 5
7373: PUSH
7374: LD_INT 1
7376: ST_TO_ADDR
// end else
7377: GO 7387
// result := false ;
7379: LD_ADDR_VAR 0 5
7383: PUSH
7384: LD_INT 0
7386: ST_TO_ADDR
// end ;
7387: LD_VAR 0 5
7391: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7392: LD_INT 0
7394: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7395: LD_VAR 0 1
7399: PPUSH
7400: LD_INT 1
7402: PPUSH
7403: CALL_OW 268
7407: PUSH
7408: LD_INT 9
7410: EQUAL
7411: PUSH
7412: LD_VAR 0 1
7416: PPUSH
7417: LD_INT 2
7419: PPUSH
7420: CALL_OW 268
7424: PUSH
7425: LD_INT 9
7427: EQUAL
7428: AND
7429: IFFALSE 7526
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7431: LD_VAR 0 1
7435: PPUSH
7436: LD_VAR 0 2
7440: PPUSH
7441: CALL 5712 0 2
7445: PUSH
7446: LD_VAR 0 1
7450: PPUSH
7451: LD_VAR 0 3
7455: PPUSH
7456: CALL 5712 0 2
7460: AND
7461: PUSH
7462: LD_VAR 0 1
7466: PPUSH
7467: CALL_OW 461
7471: PUSH
7472: LD_INT 2
7474: EQUAL
7475: AND
7476: IFFALSE 7516
// begin ComUpgradeLab ( lab , bkind1 ) ;
7478: LD_VAR 0 1
7482: PPUSH
7483: LD_VAR 0 2
7487: PPUSH
7488: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
7492: LD_VAR 0 1
7496: PPUSH
7497: LD_VAR 0 3
7501: PPUSH
7502: CALL_OW 207
// result := true ;
7506: LD_ADDR_VAR 0 4
7510: PUSH
7511: LD_INT 1
7513: ST_TO_ADDR
// end else
7514: GO 7524
// result := false ;
7516: LD_ADDR_VAR 0 4
7520: PUSH
7521: LD_INT 0
7523: ST_TO_ADDR
// end else
7524: GO 7534
// result := false ;
7526: LD_ADDR_VAR 0 4
7530: PUSH
7531: LD_INT 0
7533: ST_TO_ADDR
// end ;
7534: LD_VAR 0 4
7538: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
7539: LD_INT 0
7541: PPUSH
7542: PPUSH
7543: PPUSH
7544: PPUSH
7545: PPUSH
// p := 1 ;
7546: LD_ADDR_VAR 0 6
7550: PUSH
7551: LD_INT 1
7553: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
7554: LD_ADDR_VAR 0 4
7558: PUSH
7559: DOUBLE
7560: LD_INT 1
7562: DEC
7563: ST_TO_ADDR
7564: LD_VAR 0 2
7568: PUSH
7569: LD_INT 4
7571: DIVREAL
7572: PUSH
7573: FOR_TO
7574: IFFALSE 7823
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
7576: LD_VAR 0 2
7580: PUSH
7581: LD_VAR 0 6
7585: PUSH
7586: LD_INT 1
7588: PLUS
7589: ARRAY
7590: PPUSH
7591: LD_VAR 0 2
7595: PUSH
7596: LD_VAR 0 6
7600: PUSH
7601: LD_INT 2
7603: PLUS
7604: ARRAY
7605: PPUSH
7606: CALL_OW 428
7610: PUSH
7611: LD_INT 0
7613: EQUAL
7614: PUSH
7615: LD_VAR 0 2
7619: PUSH
7620: LD_VAR 0 6
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: LD_VAR 0 2
7634: PUSH
7635: LD_VAR 0 6
7639: PUSH
7640: LD_INT 2
7642: PLUS
7643: ARRAY
7644: PPUSH
7645: CALL 5942 0 2
7649: AND
7650: PUSH
7651: LD_VAR 0 1
7655: PUSH
7656: LD_INT 1
7658: ARRAY
7659: PPUSH
7660: CALL_OW 255
7664: PPUSH
7665: CALL 6321 0 1
7669: PUSH
7670: LD_INT 20
7672: GREATEREQUAL
7673: AND
7674: IFFALSE 7791
// begin for c = 1 to plist do
7676: LD_ADDR_VAR 0 7
7680: PUSH
7681: DOUBLE
7682: LD_INT 1
7684: DEC
7685: ST_TO_ADDR
7686: LD_VAR 0 1
7690: PUSH
7691: FOR_TO
7692: IFFALSE 7785
// if not HasTask ( plist [ c ] ) then
7694: LD_VAR 0 1
7698: PUSH
7699: LD_VAR 0 7
7703: ARRAY
7704: PPUSH
7705: CALL_OW 314
7709: NOT
7710: IFFALSE 7783
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
7712: LD_VAR 0 1
7716: PUSH
7717: LD_VAR 0 7
7721: ARRAY
7722: PPUSH
7723: LD_VAR 0 2
7727: PUSH
7728: LD_VAR 0 6
7732: ARRAY
7733: PPUSH
7734: LD_VAR 0 2
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: LD_INT 1
7746: PLUS
7747: ARRAY
7748: PPUSH
7749: LD_VAR 0 2
7753: PUSH
7754: LD_VAR 0 6
7758: PUSH
7759: LD_INT 2
7761: PLUS
7762: ARRAY
7763: PPUSH
7764: LD_VAR 0 2
7768: PUSH
7769: LD_VAR 0 6
7773: PUSH
7774: LD_INT 3
7776: PLUS
7777: ARRAY
7778: PPUSH
7779: CALL_OW 145
7783: GO 7691
7785: POP
7786: POP
// break ;
7787: GO 7823
// end else
7789: GO 7821
// if ( p + 4 < tlist ) then
7791: LD_VAR 0 6
7795: PUSH
7796: LD_INT 4
7798: PLUS
7799: PUSH
7800: LD_VAR 0 2
7804: LESS
7805: IFFALSE 7821
// p := p + 4 ;
7807: LD_ADDR_VAR 0 6
7811: PUSH
7812: LD_VAR 0 6
7816: PUSH
7817: LD_INT 4
7819: PLUS
7820: ST_TO_ADDR
// end ;
7821: GO 7573
7823: POP
7824: POP
// end ;
7825: LD_VAR 0 3
7829: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
7830: LD_INT 0
7832: PPUSH
7833: PPUSH
7834: PPUSH
7835: PPUSH
// tmp := GetTowers ( side ) ;
7836: LD_ADDR_VAR 0 5
7840: PUSH
7841: LD_VAR 0 1
7845: PPUSH
7846: CALL 6931 0 1
7850: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
7851: LD_ADDR_VAR 0 6
7855: PUSH
7856: LD_VAR 0 1
7860: PPUSH
7861: LD_INT 3
7863: PPUSH
7864: CALL 6227 0 2
7868: PUSH
7869: LD_INT 1
7871: ARRAY
7872: ST_TO_ADDR
// if fac then
7873: LD_VAR 0 6
7877: IFFALSE 7973
// for i = 1 to tmp do
7879: LD_ADDR_VAR 0 4
7883: PUSH
7884: DOUBLE
7885: LD_INT 1
7887: DEC
7888: ST_TO_ADDR
7889: LD_VAR 0 5
7893: PUSH
7894: FOR_TO
7895: IFFALSE 7971
// if GetBWeapon ( tmp [ i ] ) = 0 then
7897: LD_VAR 0 5
7901: PUSH
7902: LD_VAR 0 4
7906: ARRAY
7907: PPUSH
7908: CALL_OW 269
7912: PUSH
7913: LD_INT 0
7915: EQUAL
7916: IFFALSE 7969
// begin if BuildingStatus ( fac ) = bs_idle then
7918: LD_VAR 0 6
7922: PPUSH
7923: CALL_OW 461
7927: PUSH
7928: LD_INT 2
7930: EQUAL
7931: IFFALSE 7967
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
7933: LD_VAR 0 5
7937: PUSH
7938: LD_VAR 0 4
7942: ARRAY
7943: PPUSH
7944: LD_VAR 0 2
7948: PUSH
7949: LD_INT 1
7951: PPUSH
7952: LD_VAR 0 2
7956: PPUSH
7957: CALL_OW 12
7961: ARRAY
7962: PPUSH
7963: CALL_OW 148
// break ;
7967: GO 7971
// end ;
7969: GO 7894
7971: POP
7972: POP
// end ;
7973: LD_VAR 0 3
7977: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
7978: LD_INT 0
7980: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
7981: LD_INT 22
7983: PUSH
7984: LD_VAR 0 1
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 34
7995: PUSH
7996: LD_VAR 0 3
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PUSH
8005: LD_INT 31
8007: PUSH
8008: LD_VAR 0 2
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: LIST
8021: PUSH
8022: EMPTY
8023: LIST
8024: PPUSH
8025: CALL_OW 69
8029: IFFALSE 8087
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
8031: LD_ADDR_VAR 0 4
8035: PUSH
8036: LD_INT 22
8038: PUSH
8039: LD_VAR 0 1
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 34
8050: PUSH
8051: LD_VAR 0 3
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PUSH
8060: LD_INT 31
8062: PUSH
8063: LD_VAR 0 2
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: EMPTY
8078: LIST
8079: PPUSH
8080: CALL_OW 69
8084: ST_TO_ADDR
8085: GO 8095
// result := false ;
8087: LD_ADDR_VAR 0 4
8091: PUSH
8092: LD_INT 0
8094: ST_TO_ADDR
// end ;
8095: LD_VAR 0 4
8099: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8100: LD_INT 0
8102: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_VAR 0 2
8112: PPUSH
8113: LD_VAR 0 3
8117: PPUSH
8118: LD_VAR 0 4
8122: PPUSH
8123: LD_VAR 0 5
8127: PPUSH
8128: CALL_OW 448
8132: PUSH
8133: LD_VAR 0 2
8137: PPUSH
8138: LD_VAR 0 3
8142: PPUSH
8143: LD_VAR 0 4
8147: PPUSH
8148: LD_VAR 0 5
8152: PPUSH
8153: CALL_OW 449
8157: PUSH
8158: LD_INT 1
8160: ARRAY
8161: PUSH
8162: LD_VAR 0 1
8166: PPUSH
8167: CALL 5828 0 1
8171: PUSH
8172: LD_INT 1
8174: ARRAY
8175: LESSEQUAL
8176: AND
8177: PUSH
8178: LD_VAR 0 2
8182: PPUSH
8183: LD_VAR 0 3
8187: PPUSH
8188: LD_VAR 0 4
8192: PPUSH
8193: LD_VAR 0 5
8197: PPUSH
8198: CALL_OW 449
8202: PUSH
8203: LD_INT 2
8205: ARRAY
8206: PUSH
8207: LD_VAR 0 1
8211: PPUSH
8212: CALL 5828 0 1
8216: PUSH
8217: LD_INT 2
8219: ARRAY
8220: LESSEQUAL
8221: AND
8222: PUSH
8223: LD_VAR 0 2
8227: PPUSH
8228: LD_VAR 0 3
8232: PPUSH
8233: LD_VAR 0 4
8237: PPUSH
8238: LD_VAR 0 5
8242: PPUSH
8243: CALL_OW 449
8247: PUSH
8248: LD_INT 3
8250: ARRAY
8251: PUSH
8252: LD_VAR 0 1
8256: PPUSH
8257: CALL 5828 0 1
8261: PUSH
8262: LD_INT 3
8264: ARRAY
8265: LESSEQUAL
8266: AND
8267: IFFALSE 8314
// begin if debug then
8269: LD_EXP 1
8273: IFFALSE 8283
// display_strings := Factory work! ;
8275: LD_ADDR_OWVAR 47
8279: PUSH
8280: LD_STRING Factory work!
8282: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8283: LD_VAR 0 1
8287: PPUSH
8288: LD_VAR 0 2
8292: PPUSH
8293: LD_VAR 0 3
8297: PPUSH
8298: LD_VAR 0 4
8302: PPUSH
8303: LD_VAR 0 5
8307: PPUSH
8308: CALL_OW 125
// end else
8312: GO 8322
// result := false ;
8314: LD_ADDR_VAR 0 6
8318: PUSH
8319: LD_INT 0
8321: ST_TO_ADDR
// end ;
8322: LD_VAR 0 6
8326: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8327: LD_INT 0
8329: PPUSH
8330: PPUSH
8331: PPUSH
8332: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8333: LD_ADDR_VAR 0 6
8337: PUSH
8338: LD_INT 22
8340: PUSH
8341: LD_VAR 0 1
8345: PUSH
8346: EMPTY
8347: LIST
8348: LIST
8349: PUSH
8350: LD_INT 30
8352: PUSH
8353: LD_VAR 0 2
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: PPUSH
8366: CALL_OW 69
8370: ST_TO_ADDR
// tmp := [ ] ;
8371: LD_ADDR_VAR 0 5
8375: PUSH
8376: EMPTY
8377: ST_TO_ADDR
// for i = 1 to filter do
8378: LD_ADDR_VAR 0 4
8382: PUSH
8383: DOUBLE
8384: LD_INT 1
8386: DEC
8387: ST_TO_ADDR
8388: LD_VAR 0 6
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8482
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8396: LD_ADDR_VAR 0 5
8400: PUSH
8401: LD_VAR 0 5
8405: PUSH
8406: LD_VAR 0 6
8410: PUSH
8411: LD_VAR 0 4
8415: ARRAY
8416: PPUSH
8417: CALL_OW 266
8421: PUSH
8422: LD_VAR 0 6
8426: PUSH
8427: LD_VAR 0 4
8431: ARRAY
8432: PPUSH
8433: CALL_OW 250
8437: PUSH
8438: LD_VAR 0 6
8442: PUSH
8443: LD_VAR 0 4
8447: ARRAY
8448: PPUSH
8449: CALL_OW 251
8453: PUSH
8454: LD_VAR 0 6
8458: PUSH
8459: LD_VAR 0 4
8463: ARRAY
8464: PPUSH
8465: CALL_OW 254
8469: PUSH
8470: EMPTY
8471: LIST
8472: LIST
8473: LIST
8474: LIST
8475: PUSH
8476: EMPTY
8477: LIST
8478: ADD
8479: ST_TO_ADDR
// end ;
8480: GO 8393
8482: POP
8483: POP
// result := tmp ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_VAR 0 5
8493: ST_TO_ADDR
// end ;
8494: LD_VAR 0 3
8498: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
8499: LD_INT 0
8501: PPUSH
8502: PPUSH
8503: PPUSH
// for i = 1 to list do
8504: LD_ADDR_VAR 0 4
8508: PUSH
8509: DOUBLE
8510: LD_INT 1
8512: DEC
8513: ST_TO_ADDR
8514: LD_VAR 0 2
8518: PUSH
8519: FOR_TO
8520: IFFALSE 9075
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
8522: LD_VAR 0 2
8526: PUSH
8527: LD_VAR 0 4
8531: ARRAY
8532: PUSH
8533: LD_INT 1
8535: ARRAY
8536: PPUSH
8537: LD_VAR 0 2
8541: PUSH
8542: LD_VAR 0 4
8546: ARRAY
8547: PUSH
8548: LD_INT 2
8550: ARRAY
8551: PPUSH
8552: CALL_OW 428
8556: PUSH
8557: LD_INT 0
8559: GREATER
8560: IFFALSE 8846
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
8562: LD_VAR 0 2
8566: PUSH
8567: LD_VAR 0 4
8571: ARRAY
8572: PUSH
8573: LD_INT 1
8575: ARRAY
8576: PPUSH
8577: LD_VAR 0 2
8581: PUSH
8582: LD_VAR 0 4
8586: ARRAY
8587: PUSH
8588: LD_INT 2
8590: ARRAY
8591: PPUSH
8592: CALL_OW 428
8596: PPUSH
8597: CALL_OW 248
8601: PUSH
8602: LD_INT 3
8604: EQUAL
8605: IFFALSE 8731
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
8607: LD_VAR 0 2
8611: PUSH
8612: LD_VAR 0 4
8616: ARRAY
8617: PUSH
8618: LD_INT 1
8620: ARRAY
8621: PPUSH
8622: LD_VAR 0 2
8626: PUSH
8627: LD_VAR 0 4
8631: ARRAY
8632: PUSH
8633: LD_INT 2
8635: ARRAY
8636: PPUSH
8637: CALL_OW 428
8641: PPUSH
8642: CALL_OW 274
8646: PPUSH
8647: LD_INT 3
8649: PPUSH
8650: CALL_OW 275
8654: PUSH
8655: LD_INT 15
8657: GREATEREQUAL
8658: IFFALSE 8729
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
8660: LD_VAR 0 2
8664: PUSH
8665: LD_VAR 0 4
8669: ARRAY
8670: PUSH
8671: LD_INT 1
8673: ARRAY
8674: PPUSH
8675: LD_VAR 0 2
8679: PUSH
8680: LD_VAR 0 4
8684: ARRAY
8685: PUSH
8686: LD_INT 2
8688: ARRAY
8689: PPUSH
8690: CALL_OW 428
8694: PPUSH
8695: LD_VAR 0 2
8699: PUSH
8700: LD_VAR 0 4
8704: ARRAY
8705: PUSH
8706: LD_INT 4
8708: ARRAY
8709: PPUSH
8710: LD_VAR 0 2
8714: PUSH
8715: LD_VAR 0 4
8719: ARRAY
8720: PUSH
8721: LD_INT 5
8723: ARRAY
8724: PPUSH
8725: CALL 7392 0 3
// end else
8729: GO 8800
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
8731: LD_VAR 0 2
8735: PUSH
8736: LD_VAR 0 4
8740: ARRAY
8741: PUSH
8742: LD_INT 1
8744: ARRAY
8745: PPUSH
8746: LD_VAR 0 2
8750: PUSH
8751: LD_VAR 0 4
8755: ARRAY
8756: PUSH
8757: LD_INT 2
8759: ARRAY
8760: PPUSH
8761: CALL_OW 428
8765: PPUSH
8766: LD_VAR 0 2
8770: PUSH
8771: LD_VAR 0 4
8775: ARRAY
8776: PUSH
8777: LD_INT 4
8779: ARRAY
8780: PPUSH
8781: LD_VAR 0 2
8785: PUSH
8786: LD_VAR 0 4
8790: ARRAY
8791: PUSH
8792: LD_INT 5
8794: ARRAY
8795: PPUSH
8796: CALL 7392 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
8800: LD_VAR 0 1
8804: PPUSH
8805: LD_VAR 0 2
8809: PUSH
8810: LD_VAR 0 4
8814: ARRAY
8815: PUSH
8816: LD_INT 1
8818: ARRAY
8819: PPUSH
8820: LD_VAR 0 2
8824: PUSH
8825: LD_VAR 0 4
8829: ARRAY
8830: PUSH
8831: LD_INT 2
8833: ARRAY
8834: PPUSH
8835: CALL_OW 428
8839: PPUSH
8840: CALL 10448 0 2
// end else
8844: GO 9073
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
8846: LD_VAR 0 1
8850: PUSH
8851: LD_INT 1
8853: ARRAY
8854: PPUSH
8855: CALL_OW 255
8859: PPUSH
8860: CALL 6136 0 1
8864: PPUSH
8865: LD_INT 6
8867: PPUSH
8868: CALL 5712 0 2
8872: PUSH
8873: LD_VAR 0 1
8877: PUSH
8878: LD_INT 1
8880: ARRAY
8881: PPUSH
8882: CALL_OW 255
8886: PPUSH
8887: CALL 6136 0 1
8891: PPUSH
8892: LD_VAR 0 2
8896: PUSH
8897: LD_VAR 0 4
8901: ARRAY
8902: PUSH
8903: LD_INT 4
8905: ARRAY
8906: PPUSH
8907: CALL 5712 0 2
8911: AND
8912: PUSH
8913: LD_VAR 0 1
8917: PUSH
8918: LD_INT 1
8920: ARRAY
8921: PPUSH
8922: CALL_OW 255
8926: PPUSH
8927: CALL 6136 0 1
8931: PPUSH
8932: LD_VAR 0 2
8936: PUSH
8937: LD_VAR 0 4
8941: ARRAY
8942: PUSH
8943: LD_INT 5
8945: ARRAY
8946: PPUSH
8947: CALL 5712 0 2
8951: AND
8952: IFFALSE 9073
// for p = 1 to plist do
8954: LD_ADDR_VAR 0 5
8958: PUSH
8959: DOUBLE
8960: LD_INT 1
8962: DEC
8963: ST_TO_ADDR
8964: LD_VAR 0 1
8968: PUSH
8969: FOR_TO
8970: IFFALSE 9071
// if IsInUnit ( plist [ p ] ) then
8972: LD_VAR 0 1
8976: PUSH
8977: LD_VAR 0 5
8981: ARRAY
8982: PPUSH
8983: CALL_OW 310
8987: IFFALSE 9006
// ComExitBuilding ( plist [ p ] ) else
8989: LD_VAR 0 1
8993: PUSH
8994: LD_VAR 0 5
8998: ARRAY
8999: PPUSH
9000: CALL_OW 122
9004: GO 9069
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
9006: LD_VAR 0 1
9010: PUSH
9011: LD_VAR 0 5
9015: ARRAY
9016: PPUSH
9017: LD_INT 6
9019: PPUSH
9020: LD_VAR 0 2
9024: PUSH
9025: LD_VAR 0 4
9029: ARRAY
9030: PUSH
9031: LD_INT 1
9033: ARRAY
9034: PPUSH
9035: LD_VAR 0 2
9039: PUSH
9040: LD_VAR 0 4
9044: ARRAY
9045: PUSH
9046: LD_INT 2
9048: ARRAY
9049: PPUSH
9050: LD_VAR 0 2
9054: PUSH
9055: LD_VAR 0 4
9059: ARRAY
9060: PUSH
9061: LD_INT 3
9063: ARRAY
9064: PPUSH
9065: CALL_OW 145
9069: GO 8969
9071: POP
9072: POP
// end ;
9073: GO 8519
9075: POP
9076: POP
// end ;
9077: LD_VAR 0 3
9081: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9082: LD_INT 0
9084: PPUSH
// if IsInUnit ( sci ) then
9085: LD_VAR 0 1
9089: PPUSH
9090: CALL_OW 310
9094: IFFALSE 9107
// ComExitBuilding ( sci ) else
9096: LD_VAR 0 1
9100: PPUSH
9101: CALL_OW 122
9105: GO 9138
// if not HasTask ( sci ) then
9107: LD_VAR 0 1
9111: PPUSH
9112: CALL_OW 314
9116: NOT
9117: IFFALSE 9138
// begin ComMoveXY ( sci , x , y ) ;
9119: LD_VAR 0 1
9123: PPUSH
9124: LD_VAR 0 2
9128: PPUSH
9129: LD_VAR 0 3
9133: PPUSH
9134: CALL_OW 111
// end ; end ;
9138: LD_VAR 0 4
9142: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9143: LD_INT 0
9145: PPUSH
9146: PPUSH
9147: PPUSH
9148: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9149: LD_ADDR_VAR 0 6
9153: PUSH
9154: LD_INT 22
9156: PUSH
9157: LD_VAR 0 1
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: PUSH
9166: LD_INT 21
9168: PUSH
9169: LD_INT 1
9171: PUSH
9172: EMPTY
9173: LIST
9174: LIST
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PPUSH
9180: CALL_OW 69
9184: PUSH
9185: LD_VAR 0 3
9189: DIFF
9190: ST_TO_ADDR
// tmp := tag_list ;
9191: LD_ADDR_VAR 0 7
9195: PUSH
9196: LD_VAR 0 2
9200: ST_TO_ADDR
// for i = 1 to filter do
9201: LD_ADDR_VAR 0 5
9205: PUSH
9206: DOUBLE
9207: LD_INT 1
9209: DEC
9210: ST_TO_ADDR
9211: LD_VAR 0 6
9215: PUSH
9216: FOR_TO
9217: IFFALSE 9486
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9219: LD_VAR 0 6
9223: PUSH
9224: LD_VAR 0 5
9228: ARRAY
9229: PPUSH
9230: CALL_OW 256
9234: PUSH
9235: LD_INT 1000
9237: EQUAL
9238: PUSH
9239: LD_VAR 0 6
9243: PUSH
9244: LD_VAR 0 5
9248: ARRAY
9249: PPUSH
9250: CALL_OW 110
9254: PUSH
9255: LD_INT 100
9257: GREATEREQUAL
9258: AND
9259: IFFALSE 9301
// begin SetTag ( filter [ i ] , 0 ) ;
9261: LD_VAR 0 6
9265: PUSH
9266: LD_VAR 0 5
9270: ARRAY
9271: PPUSH
9272: LD_INT 0
9274: PPUSH
9275: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9279: LD_ADDR_VAR 0 7
9283: PUSH
9284: LD_VAR 0 7
9288: PUSH
9289: LD_VAR 0 6
9293: PUSH
9294: LD_VAR 0 5
9298: ARRAY
9299: DIFF
9300: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9301: LD_VAR 0 6
9305: PUSH
9306: LD_VAR 0 5
9310: ARRAY
9311: PPUSH
9312: CALL_OW 256
9316: PUSH
9317: LD_INT 1000
9319: LESS
9320: IFFALSE 9484
// begin if not filter [ i ] in tmp then
9322: LD_VAR 0 6
9326: PUSH
9327: LD_VAR 0 5
9331: ARRAY
9332: PUSH
9333: LD_VAR 0 7
9337: IN
9338: NOT
9339: IFFALSE 9363
// tmp := tmp ^ filter [ i ] ;
9341: LD_ADDR_VAR 0 7
9345: PUSH
9346: LD_VAR 0 7
9350: PUSH
9351: LD_VAR 0 6
9355: PUSH
9356: LD_VAR 0 5
9360: ARRAY
9361: ADD
9362: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9363: LD_VAR 0 6
9367: PUSH
9368: LD_VAR 0 5
9372: ARRAY
9373: PPUSH
9374: CALL_OW 256
9378: PUSH
9379: LD_INT 250
9381: LESS
9382: IFFALSE 9404
// SetTag ( filter [ i ] , 100 ) else
9384: LD_VAR 0 6
9388: PUSH
9389: LD_VAR 0 5
9393: ARRAY
9394: PPUSH
9395: LD_INT 100
9397: PPUSH
9398: CALL_OW 109
9402: GO 9484
// if GetLives ( filter [ i ] ) < 500 then
9404: LD_VAR 0 6
9408: PUSH
9409: LD_VAR 0 5
9413: ARRAY
9414: PPUSH
9415: CALL_OW 256
9419: PUSH
9420: LD_INT 500
9422: LESS
9423: IFFALSE 9445
// SetTag ( filter [ i ] , 101 ) else
9425: LD_VAR 0 6
9429: PUSH
9430: LD_VAR 0 5
9434: ARRAY
9435: PPUSH
9436: LD_INT 101
9438: PPUSH
9439: CALL_OW 109
9443: GO 9484
// if GetLives ( filter [ i ] ) < 1000 then
9445: LD_VAR 0 6
9449: PUSH
9450: LD_VAR 0 5
9454: ARRAY
9455: PPUSH
9456: CALL_OW 256
9460: PUSH
9461: LD_INT 1000
9463: LESS
9464: IFFALSE 9484
// SetTag ( filter [ i ] , 102 ) ;
9466: LD_VAR 0 6
9470: PUSH
9471: LD_VAR 0 5
9475: ARRAY
9476: PPUSH
9477: LD_INT 102
9479: PPUSH
9480: CALL_OW 109
// end ; end ;
9484: GO 9216
9486: POP
9487: POP
// result := tmp ;
9488: LD_ADDR_VAR 0 4
9492: PUSH
9493: LD_VAR 0 7
9497: ST_TO_ADDR
// end ;
9498: LD_VAR 0 4
9502: RET
// export function WantHeal ( sci , tag ) ; begin
9503: LD_INT 0
9505: PPUSH
// if GetTaskList ( sci ) > 0 then
9506: LD_VAR 0 1
9510: PPUSH
9511: CALL_OW 437
9515: PUSH
9516: LD_INT 0
9518: GREATER
9519: IFFALSE 9594
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
9521: LD_VAR 0 1
9525: PPUSH
9526: CALL_OW 437
9530: PUSH
9531: LD_INT 1
9533: ARRAY
9534: PUSH
9535: LD_INT 1
9537: ARRAY
9538: PUSH
9539: LD_STRING l
9541: EQUAL
9542: PUSH
9543: LD_VAR 0 1
9547: PPUSH
9548: CALL_OW 437
9552: PUSH
9553: LD_INT 1
9555: ARRAY
9556: PUSH
9557: LD_INT 4
9559: ARRAY
9560: PPUSH
9561: CALL_OW 110
9565: PUSH
9566: LD_VAR 0 2
9570: EQUAL
9571: AND
9572: IFFALSE 9584
// result := true else
9574: LD_ADDR_VAR 0 3
9578: PUSH
9579: LD_INT 1
9581: ST_TO_ADDR
9582: GO 9592
// result := false ;
9584: LD_ADDR_VAR 0 3
9588: PUSH
9589: LD_INT 0
9591: ST_TO_ADDR
// end else
9592: GO 9602
// result := false ;
9594: LD_ADDR_VAR 0 3
9598: PUSH
9599: LD_INT 0
9601: ST_TO_ADDR
// end ;
9602: LD_VAR 0 3
9606: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
9607: LD_INT 0
9609: PPUSH
9610: PPUSH
9611: PPUSH
9612: PPUSH
9613: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9614: LD_ADDR_VAR 0 7
9618: PUSH
9619: LD_INT 22
9621: PUSH
9622: LD_VAR 0 2
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: PUSH
9631: LD_INT 3
9633: PUSH
9634: LD_INT 21
9636: PUSH
9637: LD_INT 3
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: PUSH
9648: EMPTY
9649: LIST
9650: LIST
9651: PPUSH
9652: CALL_OW 69
9656: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_INT 1
9664: PPUSH
9665: LD_INT 3
9667: PPUSH
9668: CALL_OW 12
9672: ST_TO_ADDR
// if filter > 0 then
9673: LD_VAR 0 7
9677: PUSH
9678: LD_INT 0
9680: GREATER
9681: IFFALSE 9883
// for i = 1 to list do
9683: LD_ADDR_VAR 0 6
9687: PUSH
9688: DOUBLE
9689: LD_INT 1
9691: DEC
9692: ST_TO_ADDR
9693: LD_VAR 0 1
9697: PUSH
9698: FOR_TO
9699: IFFALSE 9881
// for ta in filter do
9701: LD_ADDR_VAR 0 4
9705: PUSH
9706: LD_VAR 0 7
9710: PUSH
9711: FOR_IN
9712: IFFALSE 9877
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
9714: LD_VAR 0 1
9718: PUSH
9719: LD_VAR 0 6
9723: ARRAY
9724: PPUSH
9725: LD_VAR 0 4
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 13
9737: LESSEQUAL
9738: IFFALSE 9875
// begin case c of 1 :
9740: LD_VAR 0 5
9744: PUSH
9745: LD_INT 1
9747: DOUBLE
9748: EQUAL
9749: IFTRUE 9753
9751: GO 9791
9753: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
9754: LD_VAR 0 1
9758: PUSH
9759: LD_VAR 0 6
9763: ARRAY
9764: PPUSH
9765: LD_VAR 0 4
9769: PPUSH
9770: CALL_OW 250
9774: PPUSH
9775: LD_VAR 0 4
9779: PPUSH
9780: CALL_OW 251
9784: PPUSH
9785: CALL_OW 154
9789: GO 9875
9791: LD_INT 2
9793: DOUBLE
9794: EQUAL
9795: IFTRUE 9799
9797: GO 9863
9799: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
9800: LD_VAR 0 1
9804: PUSH
9805: LD_VAR 0 6
9809: ARRAY
9810: PPUSH
9811: LD_VAR 0 4
9815: PPUSH
9816: CALL_OW 250
9820: PUSH
9821: LD_INT 1
9823: NEG
9824: PPUSH
9825: LD_INT 1
9827: PPUSH
9828: CALL_OW 12
9832: PLUS
9833: PPUSH
9834: LD_VAR 0 4
9838: PPUSH
9839: CALL_OW 251
9843: PUSH
9844: LD_INT 1
9846: NEG
9847: PPUSH
9848: LD_INT 1
9850: PPUSH
9851: CALL_OW 12
9855: PLUS
9856: PPUSH
9857: CALL_OW 153
9861: GO 9875
9863: LD_INT 3
9865: DOUBLE
9866: EQUAL
9867: IFTRUE 9871
9869: GO 9874
9871: POP
// ; end ;
9872: GO 9875
9874: POP
// end ; end ;
9875: GO 9711
9877: POP
9878: POP
9879: GO 9698
9881: POP
9882: POP
// end ;
9883: LD_VAR 0 3
9887: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
9888: LD_INT 0
9890: PPUSH
9891: PPUSH
// for i = 1 to plist do
9892: LD_ADDR_VAR 0 3
9896: PUSH
9897: DOUBLE
9898: LD_INT 1
9900: DEC
9901: ST_TO_ADDR
9902: LD_VAR 0 1
9906: PUSH
9907: FOR_TO
9908: IFFALSE 10110
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
9910: LD_VAR 0 1
9914: PUSH
9915: LD_VAR 0 3
9919: ARRAY
9920: PPUSH
9921: CALL_OW 310
9925: PUSH
9926: LD_INT 30
9928: PUSH
9929: LD_INT 5
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: PUSH
9936: EMPTY
9937: LIST
9938: PPUSH
9939: CALL_OW 69
9943: IN
9944: NOT
9945: IFFALSE 10090
// begin if IsInUnit ( plist [ i ] ) then
9947: LD_VAR 0 1
9951: PUSH
9952: LD_VAR 0 3
9956: ARRAY
9957: PPUSH
9958: CALL_OW 310
9962: IFFALSE 9981
// ComExitBuilding ( plist [ i ] ) else
9964: LD_VAR 0 1
9968: PUSH
9969: LD_VAR 0 3
9973: ARRAY
9974: PPUSH
9975: CALL_OW 122
9979: GO 10088
// if not HasTask ( plist [ i ] ) then
9981: LD_VAR 0 1
9985: PUSH
9986: LD_VAR 0 3
9990: ARRAY
9991: PPUSH
9992: CALL_OW 314
9996: NOT
9997: IFFALSE 10088
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
9999: LD_VAR 0 1
10003: PUSH
10004: LD_VAR 0 3
10008: ARRAY
10009: PPUSH
10010: LD_INT 22
10012: PUSH
10013: LD_VAR 0 1
10017: PUSH
10018: LD_INT 1
10020: ARRAY
10021: PPUSH
10022: CALL_OW 255
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 30
10033: PUSH
10034: LD_INT 5
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PPUSH
10045: CALL_OW 69
10049: PPUSH
10050: LD_VAR 0 1
10054: PUSH
10055: LD_VAR 0 3
10059: ARRAY
10060: PPUSH
10061: CALL_OW 74
10065: PPUSH
10066: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10070: LD_VAR 0 1
10074: PUSH
10075: LD_VAR 0 3
10079: ARRAY
10080: PPUSH
10081: LD_INT 9
10083: PPUSH
10084: CALL_OW 183
// end ; end else
10088: GO 10108
// ComChangeProfession ( plist [ i ] , 9 ) ;
10090: LD_VAR 0 1
10094: PUSH
10095: LD_VAR 0 3
10099: ARRAY
10100: PPUSH
10101: LD_INT 9
10103: PPUSH
10104: CALL_OW 123
10108: GO 9907
10110: POP
10111: POP
// end ;
10112: LD_VAR 0 2
10116: RET
// export function GetHuman ( side ) ; begin
10117: LD_INT 0
10119: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10120: LD_ADDR_VAR 0 2
10124: PUSH
10125: LD_INT 22
10127: PUSH
10128: LD_VAR 0 1
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: PUSH
10137: LD_INT 21
10139: PUSH
10140: LD_INT 1
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: PUSH
10147: LD_INT 2
10149: PUSH
10150: LD_INT 25
10152: PUSH
10153: LD_INT 1
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 25
10162: PUSH
10163: LD_INT 2
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: LD_INT 25
10172: PUSH
10173: LD_INT 3
10175: PUSH
10176: EMPTY
10177: LIST
10178: LIST
10179: PUSH
10180: LD_INT 25
10182: PUSH
10183: LD_INT 4
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: ST_TO_ADDR
// end ;
10207: LD_VAR 0 2
10211: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10212: LD_INT 0
10214: PPUSH
10215: PPUSH
10216: PPUSH
// uc_side := 0 ;
10217: LD_ADDR_OWVAR 20
10221: PUSH
10222: LD_INT 0
10224: ST_TO_ADDR
// uc_nation := 0 ;
10225: LD_ADDR_OWVAR 21
10229: PUSH
10230: LD_INT 0
10232: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10233: LD_ADDR_VAR 0 4
10237: PUSH
10238: DOUBLE
10239: LD_INT 1
10241: DEC
10242: ST_TO_ADDR
10243: LD_INT 4
10245: PUSH
10246: LD_INT 5
10248: PUSH
10249: LD_INT 6
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: LIST
10256: PUSH
10257: LD_OWVAR 67
10261: ARRAY
10262: PUSH
10263: FOR_TO
10264: IFFALSE 10335
// begin hc_class = class_tiger ;
10266: LD_ADDR_OWVAR 28
10270: PUSH
10271: LD_INT 14
10273: ST_TO_ADDR
// hc_gallery = sandnature ;
10274: LD_ADDR_OWVAR 33
10278: PUSH
10279: LD_STRING sandnature
10281: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10282: LD_ADDR_OWVAR 35
10286: PUSH
10287: LD_INT 0
10289: PPUSH
10290: LD_INT 50
10292: PPUSH
10293: CALL_OW 12
10297: ST_TO_ADDR
// hc_face_number = 3 ;
10298: LD_ADDR_OWVAR 34
10302: PUSH
10303: LD_INT 3
10305: ST_TO_ADDR
// tiger := CreateHuman ;
10306: LD_ADDR_VAR 0 3
10310: PUSH
10311: CALL_OW 44
10315: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10316: LD_VAR 0 3
10320: PPUSH
10321: LD_VAR 0 1
10325: PPUSH
10326: LD_INT 0
10328: PPUSH
10329: CALL_OW 49
// end ;
10333: GO 10263
10335: POP
10336: POP
// end ;
10337: LD_VAR 0 2
10341: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10342: LD_INT 0
10344: PPUSH
10345: PPUSH
10346: PPUSH
// uc_side := 0 ;
10347: LD_ADDR_OWVAR 20
10351: PUSH
10352: LD_INT 0
10354: ST_TO_ADDR
// uc_nation := 0 ;
10355: LD_ADDR_OWVAR 21
10359: PUSH
10360: LD_INT 0
10362: ST_TO_ADDR
// for i = 1 to 8 do
10363: LD_ADDR_VAR 0 4
10367: PUSH
10368: DOUBLE
10369: LD_INT 1
10371: DEC
10372: ST_TO_ADDR
10373: LD_INT 8
10375: PUSH
10376: FOR_TO
10377: IFFALSE 10441
// begin hc_class = class_apeman ;
10379: LD_ADDR_OWVAR 28
10383: PUSH
10384: LD_INT 12
10386: ST_TO_ADDR
// hc_gallery =  ;
10387: LD_ADDR_OWVAR 33
10391: PUSH
10392: LD_STRING 
10394: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10395: LD_ADDR_OWVAR 35
10399: PUSH
10400: LD_INT 5
10402: NEG
10403: PPUSH
10404: LD_INT 20
10406: PPUSH
10407: CALL_OW 12
10411: ST_TO_ADDR
// ape := CreateHuman ;
10412: LD_ADDR_VAR 0 3
10416: PUSH
10417: CALL_OW 44
10421: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10422: LD_VAR 0 3
10426: PPUSH
10427: LD_VAR 0 1
10431: PPUSH
10432: LD_INT 0
10434: PPUSH
10435: CALL_OW 49
// end ;
10439: GO 10376
10441: POP
10442: POP
// end ;
10443: LD_VAR 0 2
10447: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
10448: LD_INT 0
10450: PPUSH
10451: PPUSH
// if BuildingStatus ( b ) = bs_build then
10452: LD_VAR 0 2
10456: PPUSH
10457: CALL_OW 461
10461: PUSH
10462: LD_INT 1
10464: EQUAL
10465: IFFALSE 10651
// for i = 1 to plist do
10467: LD_ADDR_VAR 0 4
10471: PUSH
10472: DOUBLE
10473: LD_INT 1
10475: DEC
10476: ST_TO_ADDR
10477: LD_VAR 0 1
10481: PUSH
10482: FOR_TO
10483: IFFALSE 10649
// if IsInUnit ( plist [ i ] ) then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_VAR 0 4
10494: ARRAY
10495: PPUSH
10496: CALL_OW 310
10500: IFFALSE 10583
// begin ComExitBuilding ( plist [ i ] ) ;
10502: LD_VAR 0 1
10506: PUSH
10507: LD_VAR 0 4
10511: ARRAY
10512: PPUSH
10513: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
10517: LD_VAR 0 1
10521: PUSH
10522: LD_VAR 0 4
10526: ARRAY
10527: PPUSH
10528: LD_STRING h
10530: PUSH
10531: LD_VAR 0 2
10535: PPUSH
10536: CALL_OW 250
10540: PUSH
10541: LD_VAR 0 2
10545: PPUSH
10546: CALL_OW 251
10550: PUSH
10551: LD_VAR 0 2
10555: PUSH
10556: LD_INT 0
10558: PUSH
10559: LD_INT 0
10561: PUSH
10562: LD_INT 0
10564: PUSH
10565: EMPTY
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PUSH
10574: EMPTY
10575: LIST
10576: PPUSH
10577: CALL_OW 447
// end else
10581: GO 10647
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
10583: LD_VAR 0 1
10587: PUSH
10588: LD_VAR 0 4
10592: ARRAY
10593: PPUSH
10594: LD_STRING h
10596: PUSH
10597: LD_VAR 0 2
10601: PPUSH
10602: CALL_OW 250
10606: PUSH
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 251
10616: PUSH
10617: LD_VAR 0 2
10621: PUSH
10622: LD_INT 0
10624: PUSH
10625: LD_INT 0
10627: PUSH
10628: LD_INT 0
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: LIST
10636: LIST
10637: LIST
10638: LIST
10639: PUSH
10640: EMPTY
10641: LIST
10642: PPUSH
10643: CALL_OW 446
10647: GO 10482
10649: POP
10650: POP
// end ;
10651: LD_VAR 0 3
10655: RET
// export function WantRepair ( eng ) ; begin
10656: LD_INT 0
10658: PPUSH
// if GetTaskList ( eng ) > 0 then
10659: LD_VAR 0 1
10663: PPUSH
10664: CALL_OW 437
10668: PUSH
10669: LD_INT 0
10671: GREATER
10672: IFFALSE 10717
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
10674: LD_VAR 0 1
10678: PPUSH
10679: CALL_OW 437
10683: PUSH
10684: LD_INT 1
10686: ARRAY
10687: PUSH
10688: LD_INT 1
10690: ARRAY
10691: PUSH
10692: LD_STRING o
10694: EQUAL
10695: IFFALSE 10707
// result := true else
10697: LD_ADDR_VAR 0 2
10701: PUSH
10702: LD_INT 1
10704: ST_TO_ADDR
10705: GO 10715
// result := false ;
10707: LD_ADDR_VAR 0 2
10711: PUSH
10712: LD_INT 0
10714: ST_TO_ADDR
// end else
10715: GO 10725
// result := false ;
10717: LD_ADDR_VAR 0 2
10721: PUSH
10722: LD_INT 0
10724: ST_TO_ADDR
// end ;
10725: LD_VAR 0 2
10729: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
10730: LD_INT 0
10732: PPUSH
10733: PPUSH
10734: PPUSH
10735: PPUSH
// if btype = - 1 then
10736: LD_VAR 0 2
10740: PUSH
10741: LD_INT 1
10743: NEG
10744: EQUAL
10745: IFFALSE 10785
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
10747: LD_ADDR_VAR 0 5
10751: PUSH
10752: LD_INT 22
10754: PUSH
10755: LD_VAR 0 1
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: PUSH
10764: LD_INT 21
10766: PUSH
10767: LD_INT 3
10769: PUSH
10770: EMPTY
10771: LIST
10772: LIST
10773: PUSH
10774: EMPTY
10775: LIST
10776: LIST
10777: PPUSH
10778: CALL_OW 69
10782: ST_TO_ADDR
10783: GO 10823
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
10785: LD_ADDR_VAR 0 5
10789: PUSH
10790: LD_INT 22
10792: PUSH
10793: LD_VAR 0 1
10797: PUSH
10798: EMPTY
10799: LIST
10800: LIST
10801: PUSH
10802: LD_INT 30
10804: PUSH
10805: LD_VAR 0 2
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 69
10822: ST_TO_ADDR
// list := [ ] ;
10823: LD_ADDR_VAR 0 6
10827: PUSH
10828: EMPTY
10829: ST_TO_ADDR
// for i = 1 to tmp do
10830: LD_ADDR_VAR 0 4
10834: PUSH
10835: DOUBLE
10836: LD_INT 1
10838: DEC
10839: ST_TO_ADDR
10840: LD_VAR 0 5
10844: PUSH
10845: FOR_TO
10846: IFFALSE 10934
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
10848: LD_ADDR_VAR 0 6
10852: PUSH
10853: LD_VAR 0 6
10857: PUSH
10858: LD_VAR 0 5
10862: PUSH
10863: LD_VAR 0 4
10867: ARRAY
10868: PPUSH
10869: CALL_OW 266
10873: PUSH
10874: LD_VAR 0 5
10878: PUSH
10879: LD_VAR 0 4
10883: ARRAY
10884: PPUSH
10885: CALL_OW 250
10889: PUSH
10890: LD_VAR 0 5
10894: PUSH
10895: LD_VAR 0 4
10899: ARRAY
10900: PPUSH
10901: CALL_OW 251
10905: PUSH
10906: LD_VAR 0 5
10910: PUSH
10911: LD_VAR 0 4
10915: ARRAY
10916: PPUSH
10917: CALL_OW 254
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: LIST
10926: LIST
10927: PUSH
10928: EMPTY
10929: LIST
10930: ADD
10931: ST_TO_ADDR
10932: GO 10845
10934: POP
10935: POP
// result = list ;
10936: LD_ADDR_VAR 0 3
10940: PUSH
10941: LD_VAR 0 6
10945: ST_TO_ADDR
// end ;
10946: LD_VAR 0 3
10950: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
10951: LD_INT 0
10953: PPUSH
10954: PPUSH
10955: PPUSH
10956: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
10957: LD_VAR 0 1
10961: PPUSH
10962: LD_INT 81
10964: PUSH
10965: LD_VAR 0 1
10969: PPUSH
10970: CALL_OW 255
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 69
10983: PPUSH
10984: LD_VAR 0 1
10988: PPUSH
10989: CALL_OW 74
10993: PPUSH
10994: CALL_OW 296
10998: PUSH
10999: LD_INT 18
11001: LESS
11002: IFFALSE 11047
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
11004: LD_VAR 0 1
11008: PPUSH
11009: LD_INT 81
11011: PUSH
11012: LD_VAR 0 1
11016: PPUSH
11017: CALL_OW 255
11021: PUSH
11022: EMPTY
11023: LIST
11024: LIST
11025: PPUSH
11026: CALL_OW 69
11030: PPUSH
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 74
11040: PPUSH
11041: CALL_OW 115
11045: GO 11066
// ComMoveXY ( behemoth , x , y ) ;
11047: LD_VAR 0 1
11051: PPUSH
11052: LD_VAR 0 4
11056: PPUSH
11057: LD_VAR 0 5
11061: PPUSH
11062: CALL_OW 111
// if time_lapsers_list > 0 then
11066: LD_VAR 0 2
11070: PUSH
11071: LD_INT 0
11073: GREATER
11074: IFFALSE 11264
// begin for i = 1 to time_lapsers_list do
11076: LD_ADDR_VAR 0 7
11080: PUSH
11081: DOUBLE
11082: LD_INT 1
11084: DEC
11085: ST_TO_ADDR
11086: LD_VAR 0 2
11090: PUSH
11091: FOR_TO
11092: IFFALSE 11262
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11094: LD_VAR 0 2
11098: PUSH
11099: LD_VAR 0 7
11103: ARRAY
11104: PPUSH
11105: CALL_OW 256
11109: PUSH
11110: LD_INT 250
11112: GREATEREQUAL
11113: PUSH
11114: LD_VAR 0 2
11118: PUSH
11119: LD_VAR 0 7
11123: ARRAY
11124: PPUSH
11125: LD_VAR 0 1
11129: PPUSH
11130: CALL_OW 296
11134: PUSH
11135: LD_INT 9
11137: GREATER
11138: AND
11139: IFFALSE 11176
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11141: LD_VAR 0 2
11145: PUSH
11146: LD_VAR 0 7
11150: ARRAY
11151: PPUSH
11152: LD_VAR 0 1
11156: PPUSH
11157: CALL_OW 250
11161: PPUSH
11162: LD_VAR 0 1
11166: PPUSH
11167: CALL_OW 251
11171: PPUSH
11172: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11176: LD_VAR 0 2
11180: PUSH
11181: LD_VAR 0 7
11185: ARRAY
11186: PPUSH
11187: CALL_OW 256
11191: PUSH
11192: LD_INT 500
11194: LESS
11195: PUSH
11196: LD_VAR 0 1
11200: PPUSH
11201: CALL_OW 256
11205: PUSH
11206: LD_INT 700
11208: GREATER
11209: AND
11210: IFFALSE 11260
// for p = 1 to mechanic_list do
11212: LD_ADDR_VAR 0 8
11216: PUSH
11217: DOUBLE
11218: LD_INT 1
11220: DEC
11221: ST_TO_ADDR
11222: LD_VAR 0 3
11226: PUSH
11227: FOR_TO
11228: IFFALSE 11258
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11230: LD_VAR 0 3
11234: PUSH
11235: LD_VAR 0 8
11239: ARRAY
11240: PPUSH
11241: LD_VAR 0 2
11245: PUSH
11246: LD_VAR 0 7
11250: ARRAY
11251: PPUSH
11252: CALL_OW 129
11256: GO 11227
11258: POP
11259: POP
// end ;
11260: GO 11091
11262: POP
11263: POP
// end ; if mechanic_list then
11264: LD_VAR 0 3
11268: IFFALSE 11449
// begin for i = 1 to mechanic_list do
11270: LD_ADDR_VAR 0 7
11274: PUSH
11275: DOUBLE
11276: LD_INT 1
11278: DEC
11279: ST_TO_ADDR
11280: LD_VAR 0 3
11284: PUSH
11285: FOR_TO
11286: IFFALSE 11447
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11288: LD_VAR 0 3
11292: PUSH
11293: LD_VAR 0 7
11297: ARRAY
11298: PPUSH
11299: CALL_OW 256
11303: PUSH
11304: LD_INT 333
11306: LESS
11307: IFFALSE 11331
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11309: LD_ADDR_EXP 15
11313: PUSH
11314: LD_EXP 15
11318: PUSH
11319: LD_VAR 0 3
11323: PUSH
11324: LD_VAR 0 7
11328: ARRAY
11329: DIFF
11330: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11331: LD_VAR 0 3
11335: PUSH
11336: LD_VAR 0 7
11340: ARRAY
11341: PPUSH
11342: LD_VAR 0 1
11346: PPUSH
11347: CALL_OW 296
11351: PUSH
11352: LD_INT 9
11354: GREATER
11355: PUSH
11356: LD_VAR 0 3
11360: PUSH
11361: LD_VAR 0 7
11365: ARRAY
11366: PPUSH
11367: CALL_OW 314
11371: NOT
11372: AND
11373: IFFALSE 11410
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11375: LD_VAR 0 3
11379: PUSH
11380: LD_VAR 0 7
11384: ARRAY
11385: PPUSH
11386: LD_VAR 0 1
11390: PPUSH
11391: CALL_OW 250
11395: PPUSH
11396: LD_VAR 0 1
11400: PPUSH
11401: CALL_OW 251
11405: PPUSH
11406: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11410: LD_VAR 0 1
11414: PPUSH
11415: CALL_OW 256
11419: PUSH
11420: LD_INT 700
11422: LESS
11423: IFFALSE 11445
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11425: LD_VAR 0 3
11429: PUSH
11430: LD_VAR 0 7
11434: ARRAY
11435: PPUSH
11436: LD_VAR 0 1
11440: PPUSH
11441: CALL_OW 129
// end ;
11445: GO 11285
11447: POP
11448: POP
// end ; end ;
11449: LD_VAR 0 6
11453: RET
// export function GetBehemoth ( side ) ; begin
11454: LD_INT 0
11456: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
11457: LD_ADDR_VAR 0 2
11461: PUSH
11462: LD_INT 22
11464: PUSH
11465: LD_VAR 0 1
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: LD_INT 31
11476: PUSH
11477: LD_INT 25
11479: PUSH
11480: EMPTY
11481: LIST
11482: LIST
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: PPUSH
11488: CALL_OW 69
11492: ST_TO_ADDR
// end ;
11493: LD_VAR 0 2
11497: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
11498: LD_INT 0
11500: PPUSH
11501: PPUSH
11502: PPUSH
11503: PPUSH
11504: PPUSH
11505: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
11506: LD_ADDR_VAR 0 6
11510: PUSH
11511: LD_VAR 0 2
11515: PPUSH
11516: CALL_OW 435
11520: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
11521: LD_ADDR_VAR 0 5
11525: PUSH
11526: LD_INT 22
11528: PUSH
11529: LD_VAR 0 1
11533: PUSH
11534: EMPTY
11535: LIST
11536: LIST
11537: PUSH
11538: LD_INT 2
11540: PUSH
11541: LD_INT 25
11543: PUSH
11544: LD_INT 2
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: PUSH
11551: LD_INT 25
11553: PUSH
11554: LD_INT 16
11556: PUSH
11557: EMPTY
11558: LIST
11559: LIST
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: LIST
11565: PUSH
11566: EMPTY
11567: LIST
11568: LIST
11569: PPUSH
11570: CALL_OW 69
11574: ST_TO_ADDR
// if skr then
11575: LD_VAR 0 6
11579: IFFALSE 11744
// begin if engs then
11581: LD_VAR 0 5
11585: IFFALSE 11744
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
11587: LD_ADDR_VAR 0 8
11591: PUSH
11592: LD_VAR 0 6
11596: PUSH
11597: LD_INT 1
11599: ARRAY
11600: PPUSH
11601: LD_VAR 0 6
11605: PUSH
11606: LD_INT 2
11608: ARRAY
11609: PPUSH
11610: CALL_OW 284
11614: ST_TO_ADDR
// if am > engs then
11615: LD_VAR 0 8
11619: PUSH
11620: LD_VAR 0 5
11624: GREATER
11625: IFFALSE 11637
// am := engs ;
11627: LD_ADDR_VAR 0 8
11631: PUSH
11632: LD_VAR 0 5
11636: ST_TO_ADDR
// for i = 1 to am do
11637: LD_ADDR_VAR 0 7
11641: PUSH
11642: DOUBLE
11643: LD_INT 1
11645: DEC
11646: ST_TO_ADDR
11647: LD_VAR 0 8
11651: PUSH
11652: FOR_TO
11653: IFFALSE 11742
// begin if IsInUnit ( engs [ i ] ) then
11655: LD_VAR 0 5
11659: PUSH
11660: LD_VAR 0 7
11664: ARRAY
11665: PPUSH
11666: CALL_OW 310
11670: IFFALSE 11689
// ComExitBuilding ( engs [ i ] ) else
11672: LD_VAR 0 5
11676: PUSH
11677: LD_VAR 0 7
11681: ARRAY
11682: PPUSH
11683: CALL_OW 122
11687: GO 11740
// if not HasTask ( engs [ i ] ) then
11689: LD_VAR 0 5
11693: PUSH
11694: LD_VAR 0 7
11698: ARRAY
11699: PPUSH
11700: CALL_OW 314
11704: NOT
11705: IFFALSE 11740
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
11707: LD_VAR 0 5
11711: PUSH
11712: LD_VAR 0 7
11716: ARRAY
11717: PPUSH
11718: LD_VAR 0 6
11722: PUSH
11723: LD_INT 1
11725: ARRAY
11726: PPUSH
11727: LD_VAR 0 6
11731: PUSH
11732: LD_INT 2
11734: ARRAY
11735: PPUSH
11736: CALL_OW 117
// end ;
11740: GO 11652
11742: POP
11743: POP
// end ; end ; end ; end_of_file
11744: LD_VAR 0 3
11748: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
11749: LD_INT 0
11751: PPUSH
11752: PPUSH
// uc_side := 1 ;
11753: LD_ADDR_OWVAR 20
11757: PUSH
11758: LD_INT 1
11760: ST_TO_ADDR
// uc_nation := 1 ;
11761: LD_ADDR_OWVAR 21
11765: PUSH
11766: LD_INT 1
11768: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
11769: LD_ADDR_VAR 0 2
11773: PUSH
11774: LD_INT 6
11776: PUSH
11777: LD_INT 5
11779: PUSH
11780: LD_INT 4
11782: PUSH
11783: EMPTY
11784: LIST
11785: LIST
11786: LIST
11787: PUSH
11788: LD_OWVAR 67
11792: ARRAY
11793: ST_TO_ADDR
// game_status := false ;
11794: LD_ADDR_EXP 29
11798: PUSH
11799: LD_INT 0
11801: ST_TO_ADDR
// helps_arrive := false ;
11802: LD_ADDR_EXP 30
11806: PUSH
11807: LD_INT 0
11809: ST_TO_ADDR
// helps_can_arrive := false ;
11810: LD_ADDR_EXP 31
11814: PUSH
11815: LD_INT 0
11817: ST_TO_ADDR
// beta_come := false ;
11818: LD_ADDR_EXP 32
11822: PUSH
11823: LD_INT 0
11825: ST_TO_ADDR
// gamma_come := false ;
11826: LD_ADDR_EXP 33
11830: PUSH
11831: LD_INT 0
11833: ST_TO_ADDR
// zeta_come := false ;
11834: LD_ADDR_EXP 34
11838: PUSH
11839: LD_INT 0
11841: ST_TO_ADDR
// mine_ck := false ;
11842: LD_ADDR_EXP 35
11846: PUSH
11847: LD_INT 0
11849: ST_TO_ADDR
// sib_bomb_constructed := false ;
11850: LD_ADDR_EXP 36
11854: PUSH
11855: LD_INT 0
11857: ST_TO_ADDR
// mine_constructed := false ;
11858: LD_ADDR_EXP 37
11862: PUSH
11863: LD_INT 0
11865: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
11866: LD_INT 35
11868: PPUSH
11869: CALL_OW 274
11873: PPUSH
11874: LD_INT 1
11876: PPUSH
11877: LD_INT 200
11879: PUSH
11880: LD_INT 100
11882: PUSH
11883: LD_INT 70
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: LIST
11890: PUSH
11891: LD_OWVAR 67
11895: ARRAY
11896: PPUSH
11897: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
11901: LD_INT 35
11903: PPUSH
11904: LD_INT 4
11906: PPUSH
11907: CALL_OW 235
// hc_importance := 100 ;
11911: LD_ADDR_OWVAR 32
11915: PUSH
11916: LD_INT 100
11918: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
11919: LD_INT 1
11921: PPUSH
11922: LD_INT 2
11924: PPUSH
11925: LD_VAR 0 2
11929: PUSH
11930: LD_INT 1
11932: PLUS
11933: PPUSH
11934: CALL_OW 380
// hc_gallery := hardch ;
11938: LD_ADDR_OWVAR 33
11942: PUSH
11943: LD_STRING hardch
11945: ST_TO_ADDR
// hc_face_number := 1 ;
11946: LD_ADDR_OWVAR 34
11950: PUSH
11951: LD_INT 1
11953: ST_TO_ADDR
// guyA := CreateHuman ;
11954: LD_ADDR_EXP 38
11958: PUSH
11959: CALL_OW 44
11963: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
11964: LD_INT 1
11966: PPUSH
11967: LD_INT 1
11969: PPUSH
11970: LD_VAR 0 2
11974: PPUSH
11975: CALL_OW 380
// hc_face_number := 2 ;
11979: LD_ADDR_OWVAR 34
11983: PUSH
11984: LD_INT 2
11986: ST_TO_ADDR
// guyB := CreateHuman ;
11987: LD_ADDR_EXP 39
11991: PUSH
11992: CALL_OW 44
11996: ST_TO_ADDR
// hc_importance := 0 ;
11997: LD_ADDR_OWVAR 32
12001: PUSH
12002: LD_INT 0
12004: ST_TO_ADDR
// hc_gallery :=  ;
12005: LD_ADDR_OWVAR 33
12009: PUSH
12010: LD_STRING 
12012: ST_TO_ADDR
// end ;
12013: LD_VAR 0 1
12017: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
12018: LD_INT 0
12020: PPUSH
12021: PPUSH
12022: PPUSH
12023: PPUSH
12024: PPUSH
12025: PPUSH
12026: PPUSH
12027: PPUSH
12028: PPUSH
// uc_side := 4 ;
12029: LD_ADDR_OWVAR 20
12033: PUSH
12034: LD_INT 4
12036: ST_TO_ADDR
// uc_nation := 1 ;
12037: LD_ADDR_OWVAR 21
12041: PUSH
12042: LD_INT 1
12044: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12045: LD_ADDR_VAR 0 10
12049: PUSH
12050: LD_INT 6
12052: PUSH
12053: LD_INT 5
12055: PUSH
12056: LD_INT 4
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: LIST
12063: PUSH
12064: LD_OWVAR 67
12068: ARRAY
12069: ST_TO_ADDR
// Beta_Squad := [ ] ;
12070: LD_ADDR_EXP 40
12074: PUSH
12075: EMPTY
12076: ST_TO_ADDR
// case num of 1 :
12077: LD_VAR 0 1
12081: PUSH
12082: LD_INT 1
12084: DOUBLE
12085: EQUAL
12086: IFTRUE 12090
12088: GO 12133
12090: POP
// begin sold := 2 ;
12091: LD_ADDR_VAR 0 5
12095: PUSH
12096: LD_INT 2
12098: ST_TO_ADDR
// sci := 1 ;
12099: LD_ADDR_VAR 0 6
12103: PUSH
12104: LD_INT 1
12106: ST_TO_ADDR
// mech := 2 ;
12107: LD_ADDR_VAR 0 7
12111: PUSH
12112: LD_INT 2
12114: ST_TO_ADDR
// tank := 1 ;
12115: LD_ADDR_VAR 0 8
12119: PUSH
12120: LD_INT 1
12122: ST_TO_ADDR
// cargo := 1 ;
12123: LD_ADDR_VAR 0 9
12127: PUSH
12128: LD_INT 1
12130: ST_TO_ADDR
// end ; 2 :
12131: GO 12236
12133: LD_INT 2
12135: DOUBLE
12136: EQUAL
12137: IFTRUE 12141
12139: GO 12184
12141: POP
// begin sold := 2 ;
12142: LD_ADDR_VAR 0 5
12146: PUSH
12147: LD_INT 2
12149: ST_TO_ADDR
// sci := 1 ;
12150: LD_ADDR_VAR 0 6
12154: PUSH
12155: LD_INT 1
12157: ST_TO_ADDR
// mech := 1 ;
12158: LD_ADDR_VAR 0 7
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// tank := 1 ;
12166: LD_ADDR_VAR 0 8
12170: PUSH
12171: LD_INT 1
12173: ST_TO_ADDR
// cargo := 0 ;
12174: LD_ADDR_VAR 0 9
12178: PUSH
12179: LD_INT 0
12181: ST_TO_ADDR
// end ; 3 :
12182: GO 12236
12184: LD_INT 3
12186: DOUBLE
12187: EQUAL
12188: IFTRUE 12192
12190: GO 12235
12192: POP
// begin sold := 1 ;
12193: LD_ADDR_VAR 0 5
12197: PUSH
12198: LD_INT 1
12200: ST_TO_ADDR
// sci := 1 ;
12201: LD_ADDR_VAR 0 6
12205: PUSH
12206: LD_INT 1
12208: ST_TO_ADDR
// mech := 1 ;
12209: LD_ADDR_VAR 0 7
12213: PUSH
12214: LD_INT 1
12216: ST_TO_ADDR
// tank := 1 ;
12217: LD_ADDR_VAR 0 8
12221: PUSH
12222: LD_INT 1
12224: ST_TO_ADDR
// cargo := 0 ;
12225: LD_ADDR_VAR 0 9
12229: PUSH
12230: LD_INT 0
12232: ST_TO_ADDR
// end ; end ;
12233: GO 12236
12235: POP
// for i = 1 to sold do
12236: LD_ADDR_VAR 0 3
12240: PUSH
12241: DOUBLE
12242: LD_INT 1
12244: DEC
12245: ST_TO_ADDR
12246: LD_VAR 0 5
12250: PUSH
12251: FOR_TO
12252: IFFALSE 12324
// begin if i = 1 then
12254: LD_VAR 0 3
12258: PUSH
12259: LD_INT 1
12261: EQUAL
12262: IFFALSE 12281
// PrepareHuman ( sex_male , 1 , skill ) else
12264: LD_INT 1
12266: PPUSH
12267: LD_INT 1
12269: PPUSH
12270: LD_VAR 0 10
12274: PPUSH
12275: CALL_OW 380
12279: GO 12296
// PrepareHuman ( false , 1 , skill ) ;
12281: LD_INT 0
12283: PPUSH
12284: LD_INT 1
12286: PPUSH
12287: LD_VAR 0 10
12291: PPUSH
12292: CALL_OW 380
// un := CreateHuman ;
12296: LD_ADDR_VAR 0 4
12300: PUSH
12301: CALL_OW 44
12305: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12306: LD_ADDR_EXP 40
12310: PUSH
12311: LD_EXP 40
12315: PUSH
12316: LD_VAR 0 4
12320: ADD
12321: ST_TO_ADDR
// end ;
12322: GO 12251
12324: POP
12325: POP
// for i = 1 to mech do
12326: LD_ADDR_VAR 0 3
12330: PUSH
12331: DOUBLE
12332: LD_INT 1
12334: DEC
12335: ST_TO_ADDR
12336: LD_VAR 0 7
12340: PUSH
12341: FOR_TO
12342: IFFALSE 12399
// begin PrepareHuman ( false , 3 , skill ) ;
12344: LD_INT 0
12346: PPUSH
12347: LD_INT 3
12349: PPUSH
12350: LD_VAR 0 10
12354: PPUSH
12355: CALL_OW 380
// un := CreateHuman ;
12359: LD_ADDR_VAR 0 4
12363: PUSH
12364: CALL_OW 44
12368: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12369: LD_VAR 0 4
12373: PPUSH
12374: LD_INT 3
12376: PPUSH
12377: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12381: LD_ADDR_EXP 40
12385: PUSH
12386: LD_EXP 40
12390: PUSH
12391: LD_VAR 0 4
12395: ADD
12396: ST_TO_ADDR
// end ;
12397: GO 12341
12399: POP
12400: POP
// for i = 1 to sci do
12401: LD_ADDR_VAR 0 3
12405: PUSH
12406: DOUBLE
12407: LD_INT 1
12409: DEC
12410: ST_TO_ADDR
12411: LD_VAR 0 6
12415: PUSH
12416: FOR_TO
12417: IFFALSE 12462
// begin PrepareHuman ( false , 4 , skill ) ;
12419: LD_INT 0
12421: PPUSH
12422: LD_INT 4
12424: PPUSH
12425: LD_VAR 0 10
12429: PPUSH
12430: CALL_OW 380
// un := CreateHuman ;
12434: LD_ADDR_VAR 0 4
12438: PUSH
12439: CALL_OW 44
12443: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12444: LD_ADDR_EXP 40
12448: PUSH
12449: LD_EXP 40
12453: PUSH
12454: LD_VAR 0 4
12458: ADD
12459: ST_TO_ADDR
// end ;
12460: GO 12416
12462: POP
12463: POP
// for i = 1 to tank do
12464: LD_ADDR_VAR 0 3
12468: PUSH
12469: DOUBLE
12470: LD_INT 1
12472: DEC
12473: ST_TO_ADDR
12474: LD_VAR 0 8
12478: PUSH
12479: FOR_TO
12480: IFFALSE 12593
// begin Randomize ;
12482: CALL_OW 10
// vc_chassis := us_medium_tracked ;
12486: LD_ADDR_OWVAR 37
12490: PUSH
12491: LD_INT 3
12493: ST_TO_ADDR
// vc_engine := engine_solar ;
12494: LD_ADDR_OWVAR 39
12498: PUSH
12499: LD_INT 2
12501: ST_TO_ADDR
// vc_control := control_manual ;
12502: LD_ADDR_OWVAR 38
12506: PUSH
12507: LD_INT 1
12509: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
12510: LD_ADDR_OWVAR 40
12514: PUSH
12515: LD_INT 4
12517: PUSH
12518: LD_INT 5
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: PUSH
12525: LD_INT 1
12527: PPUSH
12528: LD_INT 2
12530: PPUSH
12531: CALL_OW 12
12535: ARRAY
12536: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
12537: LD_ADDR_OWVAR 41
12541: PUSH
12542: LD_INT 35
12544: PPUSH
12545: LD_INT 55
12547: PPUSH
12548: CALL_OW 12
12552: ST_TO_ADDR
// un := CreateVehicle ;
12553: LD_ADDR_VAR 0 4
12557: PUSH
12558: CALL_OW 45
12562: ST_TO_ADDR
// SetTag ( un , 5 ) ;
12563: LD_VAR 0 4
12567: PPUSH
12568: LD_INT 5
12570: PPUSH
12571: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12575: LD_ADDR_EXP 40
12579: PUSH
12580: LD_EXP 40
12584: PUSH
12585: LD_VAR 0 4
12589: ADD
12590: ST_TO_ADDR
// end ;
12591: GO 12479
12593: POP
12594: POP
// if cargo then
12595: LD_VAR 0 9
12599: IFFALSE 12702
// begin vc_chassis := us_medium_tracked ;
12601: LD_ADDR_OWVAR 37
12605: PUSH
12606: LD_INT 3
12608: ST_TO_ADDR
// vc_engine := engine_solar ;
12609: LD_ADDR_OWVAR 39
12613: PUSH
12614: LD_INT 2
12616: ST_TO_ADDR
// vc_control := control_manual ;
12617: LD_ADDR_OWVAR 38
12621: PUSH
12622: LD_INT 1
12624: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
12625: LD_ADDR_OWVAR 40
12629: PUSH
12630: LD_INT 12
12632: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
12633: LD_ADDR_OWVAR 41
12637: PUSH
12638: LD_INT 35
12640: PPUSH
12641: LD_INT 55
12643: PPUSH
12644: CALL_OW 12
12648: ST_TO_ADDR
// un := CreateVehicle ;
12649: LD_ADDR_VAR 0 4
12653: PUSH
12654: CALL_OW 45
12658: ST_TO_ADDR
// SetTag ( un , 5 ) ;
12659: LD_VAR 0 4
12663: PPUSH
12664: LD_INT 5
12666: PPUSH
12667: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12671: LD_ADDR_EXP 40
12675: PUSH
12676: LD_EXP 40
12680: PUSH
12681: LD_VAR 0 4
12685: ADD
12686: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
12687: LD_VAR 0 4
12691: PPUSH
12692: LD_INT 1
12694: PPUSH
12695: LD_INT 60
12697: PPUSH
12698: CALL_OW 290
// end ; end ;
12702: LD_VAR 0 2
12706: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
12707: LD_INT 0
12709: PPUSH
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
12714: PPUSH
12715: PPUSH
12716: PPUSH
12717: PPUSH
12718: PPUSH
// uc_side := 4 ;
12719: LD_ADDR_OWVAR 20
12723: PUSH
12724: LD_INT 4
12726: ST_TO_ADDR
// uc_nation := 1 ;
12727: LD_ADDR_OWVAR 21
12731: PUSH
12732: LD_INT 1
12734: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12735: LD_ADDR_VAR 0 11
12739: PUSH
12740: LD_INT 6
12742: PUSH
12743: LD_INT 5
12745: PUSH
12746: LD_INT 4
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: LIST
12753: PUSH
12754: LD_OWVAR 67
12758: ARRAY
12759: ST_TO_ADDR
// Gamma_Squad := [ ] ;
12760: LD_ADDR_EXP 41
12764: PUSH
12765: EMPTY
12766: ST_TO_ADDR
// case num of 1 :
12767: LD_VAR 0 1
12771: PUSH
12772: LD_INT 1
12774: DOUBLE
12775: EQUAL
12776: IFTRUE 12780
12778: GO 12831
12780: POP
// begin sold := 2 ;
12781: LD_ADDR_VAR 0 5
12785: PUSH
12786: LD_INT 2
12788: ST_TO_ADDR
// eng := 2 ;
12789: LD_ADDR_VAR 0 6
12793: PUSH
12794: LD_INT 2
12796: ST_TO_ADDR
// sci := 0 ;
12797: LD_ADDR_VAR 0 7
12801: PUSH
12802: LD_INT 0
12804: ST_TO_ADDR
// mech := 1 ;
12805: LD_ADDR_VAR 0 8
12809: PUSH
12810: LD_INT 1
12812: ST_TO_ADDR
// tank := 0 ;
12813: LD_ADDR_VAR 0 9
12817: PUSH
12818: LD_INT 0
12820: ST_TO_ADDR
// cargo := 1 ;
12821: LD_ADDR_VAR 0 10
12825: PUSH
12826: LD_INT 1
12828: ST_TO_ADDR
// end ; 2 :
12829: GO 12950
12831: LD_INT 2
12833: DOUBLE
12834: EQUAL
12835: IFTRUE 12839
12837: GO 12890
12839: POP
// begin sold := 1 ;
12840: LD_ADDR_VAR 0 5
12844: PUSH
12845: LD_INT 1
12847: ST_TO_ADDR
// eng := 2 ;
12848: LD_ADDR_VAR 0 6
12852: PUSH
12853: LD_INT 2
12855: ST_TO_ADDR
// sci := 0 ;
12856: LD_ADDR_VAR 0 7
12860: PUSH
12861: LD_INT 0
12863: ST_TO_ADDR
// mech := 1 ;
12864: LD_ADDR_VAR 0 8
12868: PUSH
12869: LD_INT 1
12871: ST_TO_ADDR
// tank := 0 ;
12872: LD_ADDR_VAR 0 9
12876: PUSH
12877: LD_INT 0
12879: ST_TO_ADDR
// cargo := 1 ;
12880: LD_ADDR_VAR 0 10
12884: PUSH
12885: LD_INT 1
12887: ST_TO_ADDR
// end ; 3 :
12888: GO 12950
12890: LD_INT 3
12892: DOUBLE
12893: EQUAL
12894: IFTRUE 12898
12896: GO 12949
12898: POP
// begin sold := 1 ;
12899: LD_ADDR_VAR 0 5
12903: PUSH
12904: LD_INT 1
12906: ST_TO_ADDR
// eng := 1 ;
12907: LD_ADDR_VAR 0 6
12911: PUSH
12912: LD_INT 1
12914: ST_TO_ADDR
// sci := 0 ;
12915: LD_ADDR_VAR 0 7
12919: PUSH
12920: LD_INT 0
12922: ST_TO_ADDR
// mech := 1 ;
12923: LD_ADDR_VAR 0 8
12927: PUSH
12928: LD_INT 1
12930: ST_TO_ADDR
// tank := 0 ;
12931: LD_ADDR_VAR 0 9
12935: PUSH
12936: LD_INT 0
12938: ST_TO_ADDR
// cargo := 1 ;
12939: LD_ADDR_VAR 0 10
12943: PUSH
12944: LD_INT 1
12946: ST_TO_ADDR
// end ; end ;
12947: GO 12950
12949: POP
// for i = 1 to sold do
12950: LD_ADDR_VAR 0 3
12954: PUSH
12955: DOUBLE
12956: LD_INT 1
12958: DEC
12959: ST_TO_ADDR
12960: LD_VAR 0 5
12964: PUSH
12965: FOR_TO
12966: IFFALSE 13038
// begin if i = 1 then
12968: LD_VAR 0 3
12972: PUSH
12973: LD_INT 1
12975: EQUAL
12976: IFFALSE 12995
// PrepareHuman ( sex_male , 1 , skill ) else
12978: LD_INT 1
12980: PPUSH
12981: LD_INT 1
12983: PPUSH
12984: LD_VAR 0 11
12988: PPUSH
12989: CALL_OW 380
12993: GO 13010
// PrepareHuman ( false , 1 , skill ) ;
12995: LD_INT 0
12997: PPUSH
12998: LD_INT 1
13000: PPUSH
13001: LD_VAR 0 11
13005: PPUSH
13006: CALL_OW 380
// un := CreateHuman ;
13010: LD_ADDR_VAR 0 4
13014: PUSH
13015: CALL_OW 44
13019: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13020: LD_ADDR_EXP 41
13024: PUSH
13025: LD_EXP 41
13029: PUSH
13030: LD_VAR 0 4
13034: ADD
13035: ST_TO_ADDR
// end ;
13036: GO 12965
13038: POP
13039: POP
// for i = 1 to mech do
13040: LD_ADDR_VAR 0 3
13044: PUSH
13045: DOUBLE
13046: LD_INT 1
13048: DEC
13049: ST_TO_ADDR
13050: LD_VAR 0 8
13054: PUSH
13055: FOR_TO
13056: IFFALSE 13113
// begin PrepareHuman ( false , 3 , skill ) ;
13058: LD_INT 0
13060: PPUSH
13061: LD_INT 3
13063: PPUSH
13064: LD_VAR 0 11
13068: PPUSH
13069: CALL_OW 380
// un := CreateHuman ;
13073: LD_ADDR_VAR 0 4
13077: PUSH
13078: CALL_OW 44
13082: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13083: LD_VAR 0 4
13087: PPUSH
13088: LD_INT 3
13090: PPUSH
13091: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13095: LD_ADDR_EXP 41
13099: PUSH
13100: LD_EXP 41
13104: PUSH
13105: LD_VAR 0 4
13109: ADD
13110: ST_TO_ADDR
// end ;
13111: GO 13055
13113: POP
13114: POP
// for i = 1 to eng do
13115: LD_ADDR_VAR 0 3
13119: PUSH
13120: DOUBLE
13121: LD_INT 1
13123: DEC
13124: ST_TO_ADDR
13125: LD_VAR 0 6
13129: PUSH
13130: FOR_TO
13131: IFFALSE 13176
// begin PrepareHuman ( false , 2 , skill ) ;
13133: LD_INT 0
13135: PPUSH
13136: LD_INT 2
13138: PPUSH
13139: LD_VAR 0 11
13143: PPUSH
13144: CALL_OW 380
// un := CreateHuman ;
13148: LD_ADDR_VAR 0 4
13152: PUSH
13153: CALL_OW 44
13157: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13158: LD_ADDR_EXP 41
13162: PUSH
13163: LD_EXP 41
13167: PUSH
13168: LD_VAR 0 4
13172: ADD
13173: ST_TO_ADDR
// end ;
13174: GO 13130
13176: POP
13177: POP
// for i = 1 to tank do
13178: LD_ADDR_VAR 0 3
13182: PUSH
13183: DOUBLE
13184: LD_INT 1
13186: DEC
13187: ST_TO_ADDR
13188: LD_VAR 0 9
13192: PUSH
13193: FOR_TO
13194: IFFALSE 13307
// begin Randomize ;
13196: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13200: LD_ADDR_OWVAR 37
13204: PUSH
13205: LD_INT 2
13207: ST_TO_ADDR
// vc_engine := engine_siberite ;
13208: LD_ADDR_OWVAR 39
13212: PUSH
13213: LD_INT 3
13215: ST_TO_ADDR
// vc_control := control_manual ;
13216: LD_ADDR_OWVAR 38
13220: PUSH
13221: LD_INT 1
13223: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13224: LD_ADDR_OWVAR 40
13228: PUSH
13229: LD_INT 7
13231: PUSH
13232: LD_INT 9
13234: PUSH
13235: EMPTY
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 1
13241: PPUSH
13242: LD_INT 2
13244: PPUSH
13245: CALL_OW 12
13249: ARRAY
13250: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13251: LD_ADDR_OWVAR 41
13255: PUSH
13256: LD_INT 35
13258: PPUSH
13259: LD_INT 55
13261: PPUSH
13262: CALL_OW 12
13266: ST_TO_ADDR
// un := CreateVehicle ;
13267: LD_ADDR_VAR 0 4
13271: PUSH
13272: CALL_OW 45
13276: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13277: LD_VAR 0 4
13281: PPUSH
13282: LD_INT 5
13284: PPUSH
13285: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13289: LD_ADDR_EXP 41
13293: PUSH
13294: LD_EXP 41
13298: PUSH
13299: LD_VAR 0 4
13303: ADD
13304: ST_TO_ADDR
// end ;
13305: GO 13193
13307: POP
13308: POP
// if cargo then
13309: LD_VAR 0 10
13313: IFFALSE 13431
// begin vc_chassis := us_medium_tracked ;
13315: LD_ADDR_OWVAR 37
13319: PUSH
13320: LD_INT 3
13322: ST_TO_ADDR
// vc_engine := engine_combustion ;
13323: LD_ADDR_OWVAR 39
13327: PUSH
13328: LD_INT 1
13330: ST_TO_ADDR
// vc_control := control_manual ;
13331: LD_ADDR_OWVAR 38
13335: PUSH
13336: LD_INT 1
13338: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13339: LD_ADDR_OWVAR 40
13343: PUSH
13344: LD_INT 12
13346: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13347: LD_ADDR_OWVAR 41
13351: PUSH
13352: LD_INT 35
13354: PPUSH
13355: LD_INT 55
13357: PPUSH
13358: CALL_OW 12
13362: ST_TO_ADDR
// un := CreateVehicle ;
13363: LD_ADDR_VAR 0 4
13367: PUSH
13368: CALL_OW 45
13372: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13373: LD_VAR 0 4
13377: PPUSH
13378: LD_INT 5
13380: PPUSH
13381: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13385: LD_ADDR_EXP 41
13389: PUSH
13390: LD_EXP 41
13394: PUSH
13395: LD_VAR 0 4
13399: ADD
13400: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13401: LD_VAR 0 4
13405: PPUSH
13406: LD_INT 3
13408: PPUSH
13409: LD_INT 30
13411: PPUSH
13412: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13416: LD_VAR 0 4
13420: PPUSH
13421: LD_INT 1
13423: PPUSH
13424: LD_INT 40
13426: PPUSH
13427: CALL_OW 290
// end ; end ;
13431: LD_VAR 0 2
13435: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
13444: PPUSH
13445: PPUSH
13446: PPUSH
13447: PPUSH
// uc_side := 4 ;
13448: LD_ADDR_OWVAR 20
13452: PUSH
13453: LD_INT 4
13455: ST_TO_ADDR
// uc_nation := 1 ;
13456: LD_ADDR_OWVAR 21
13460: PUSH
13461: LD_INT 1
13463: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13464: LD_ADDR_VAR 0 10
13468: PUSH
13469: LD_INT 6
13471: PUSH
13472: LD_INT 5
13474: PUSH
13475: LD_INT 4
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: LIST
13482: PUSH
13483: LD_OWVAR 67
13487: ARRAY
13488: ST_TO_ADDR
// Zeta_Squad := [ ] ;
13489: LD_ADDR_EXP 42
13493: PUSH
13494: EMPTY
13495: ST_TO_ADDR
// sold := 1 ;
13496: LD_ADDR_VAR 0 4
13500: PUSH
13501: LD_INT 1
13503: ST_TO_ADDR
// eng := 0 ;
13504: LD_ADDR_VAR 0 5
13508: PUSH
13509: LD_INT 0
13511: ST_TO_ADDR
// sci := 0 ;
13512: LD_ADDR_VAR 0 6
13516: PUSH
13517: LD_INT 0
13519: ST_TO_ADDR
// mech := 3 ;
13520: LD_ADDR_VAR 0 7
13524: PUSH
13525: LD_INT 3
13527: ST_TO_ADDR
// tank := 3 ;
13528: LD_ADDR_VAR 0 8
13532: PUSH
13533: LD_INT 3
13535: ST_TO_ADDR
// cargo := 0 ;
13536: LD_ADDR_VAR 0 9
13540: PUSH
13541: LD_INT 0
13543: ST_TO_ADDR
// for i = 1 to sold do
13544: LD_ADDR_VAR 0 2
13548: PUSH
13549: DOUBLE
13550: LD_INT 1
13552: DEC
13553: ST_TO_ADDR
13554: LD_VAR 0 4
13558: PUSH
13559: FOR_TO
13560: IFFALSE 13632
// begin if i = 1 then
13562: LD_VAR 0 2
13566: PUSH
13567: LD_INT 1
13569: EQUAL
13570: IFFALSE 13589
// PrepareHuman ( sex_male , 1 , skill ) else
13572: LD_INT 1
13574: PPUSH
13575: LD_INT 1
13577: PPUSH
13578: LD_VAR 0 10
13582: PPUSH
13583: CALL_OW 380
13587: GO 13604
// PrepareHuman ( false , 1 , skill ) ;
13589: LD_INT 0
13591: PPUSH
13592: LD_INT 1
13594: PPUSH
13595: LD_VAR 0 10
13599: PPUSH
13600: CALL_OW 380
// un := CreateHuman ;
13604: LD_ADDR_VAR 0 3
13608: PUSH
13609: CALL_OW 44
13613: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
13614: LD_ADDR_EXP 42
13618: PUSH
13619: LD_EXP 42
13623: PUSH
13624: LD_VAR 0 3
13628: ADD
13629: ST_TO_ADDR
// end ;
13630: GO 13559
13632: POP
13633: POP
// for i = 1 to mech do
13634: LD_ADDR_VAR 0 2
13638: PUSH
13639: DOUBLE
13640: LD_INT 1
13642: DEC
13643: ST_TO_ADDR
13644: LD_VAR 0 7
13648: PUSH
13649: FOR_TO
13650: IFFALSE 13707
// begin PrepareHuman ( false , 3 , skill ) ;
13652: LD_INT 0
13654: PPUSH
13655: LD_INT 3
13657: PPUSH
13658: LD_VAR 0 10
13662: PPUSH
13663: CALL_OW 380
// un := CreateHuman ;
13667: LD_ADDR_VAR 0 3
13671: PUSH
13672: CALL_OW 44
13676: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13677: LD_VAR 0 3
13681: PPUSH
13682: LD_INT 3
13684: PPUSH
13685: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
13689: LD_ADDR_EXP 42
13693: PUSH
13694: LD_EXP 42
13698: PUSH
13699: LD_VAR 0 3
13703: ADD
13704: ST_TO_ADDR
// end ;
13705: GO 13649
13707: POP
13708: POP
// for i = 1 to tank do
13709: LD_ADDR_VAR 0 2
13713: PUSH
13714: DOUBLE
13715: LD_INT 1
13717: DEC
13718: ST_TO_ADDR
13719: LD_VAR 0 8
13723: PUSH
13724: FOR_TO
13725: IFFALSE 13971
// begin Randomize ;
13727: CALL_OW 10
// if i < 3 then
13731: LD_VAR 0 2
13735: PUSH
13736: LD_INT 3
13738: LESS
13739: IFFALSE 13848
// begin vc_chassis := us_medium_tracked ;
13741: LD_ADDR_OWVAR 37
13745: PUSH
13746: LD_INT 3
13748: ST_TO_ADDR
// vc_engine := engine_combustion ;
13749: LD_ADDR_OWVAR 39
13753: PUSH
13754: LD_INT 1
13756: ST_TO_ADDR
// vc_control := control_manual ;
13757: LD_ADDR_OWVAR 38
13761: PUSH
13762: LD_INT 1
13764: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
13765: LD_ADDR_OWVAR 40
13769: PUSH
13770: LD_INT 3
13772: PUSH
13773: LD_INT 9
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: PUSH
13780: LD_INT 1
13782: PPUSH
13783: LD_INT 2
13785: PPUSH
13786: CALL_OW 12
13790: ARRAY
13791: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13792: LD_ADDR_OWVAR 41
13796: PUSH
13797: LD_INT 35
13799: PPUSH
13800: LD_INT 55
13802: PPUSH
13803: CALL_OW 12
13807: ST_TO_ADDR
// un := CreateVehicle ;
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: CALL_OW 45
13817: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13818: LD_VAR 0 3
13822: PPUSH
13823: LD_INT 5
13825: PPUSH
13826: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
13830: LD_ADDR_EXP 42
13834: PUSH
13835: LD_EXP 42
13839: PUSH
13840: LD_VAR 0 3
13844: ADD
13845: ST_TO_ADDR
// end else
13846: GO 13969
// begin uc_nation := 3 ;
13848: LD_ADDR_OWVAR 21
13852: PUSH
13853: LD_INT 3
13855: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
13856: LD_ADDR_OWVAR 37
13860: PUSH
13861: LD_INT 22
13863: ST_TO_ADDR
// vc_engine := engine_combustion ;
13864: LD_ADDR_OWVAR 39
13868: PUSH
13869: LD_INT 1
13871: ST_TO_ADDR
// vc_control := control_manual ;
13872: LD_ADDR_OWVAR 38
13876: PUSH
13877: LD_INT 1
13879: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
13880: LD_ADDR_OWVAR 40
13884: PUSH
13885: LD_INT 51
13887: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13888: LD_ADDR_OWVAR 41
13892: PUSH
13893: LD_INT 35
13895: PPUSH
13896: LD_INT 55
13898: PPUSH
13899: CALL_OW 12
13903: ST_TO_ADDR
// un := CreateVehicle ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: CALL_OW 45
13913: ST_TO_ADDR
// SetLives ( un , 496 ) ;
13914: LD_VAR 0 3
13918: PPUSH
13919: LD_INT 496
13921: PPUSH
13922: CALL_OW 234
// SetTag ( un , 5 ) ;
13926: LD_VAR 0 3
13930: PPUSH
13931: LD_INT 5
13933: PPUSH
13934: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
13938: LD_VAR 0 3
13942: PPUSH
13943: LD_INT 2
13945: PPUSH
13946: LD_INT 100
13948: PPUSH
13949: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
13953: LD_ADDR_EXP 42
13957: PUSH
13958: LD_EXP 42
13962: PUSH
13963: LD_VAR 0 3
13967: ADD
13968: ST_TO_ADDR
// end ; end ;
13969: GO 13724
13971: POP
13972: POP
// end ; end_of_file
13973: LD_VAR 0 1
13977: RET
// export function Action ; begin
13978: LD_INT 0
13980: PPUSH
// InGameOn ;
13981: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
13985: LD_INT 151
13987: PPUSH
13988: LD_INT 107
13990: PPUSH
13991: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
13995: LD_EXP 38
13999: PPUSH
14000: LD_INT 171
14002: PPUSH
14003: LD_INT 108
14005: PPUSH
14006: LD_INT 0
14008: PPUSH
14009: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
14013: LD_EXP 39
14017: PPUSH
14018: LD_INT 172
14020: PPUSH
14021: LD_INT 110
14023: PPUSH
14024: LD_INT 0
14026: PPUSH
14027: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
14031: LD_EXP 38
14035: PPUSH
14036: LD_INT 156
14038: PPUSH
14039: LD_INT 107
14041: PPUSH
14042: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
14046: LD_EXP 39
14050: PPUSH
14051: LD_INT 154
14053: PPUSH
14054: LD_INT 105
14056: PPUSH
14057: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
14061: LD_INT 4
14063: PPUSH
14064: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
14068: LD_EXP 38
14072: PPUSH
14073: CALL_OW 250
14077: PUSH
14078: LD_INT 156
14080: EQUAL
14081: PUSH
14082: LD_EXP 38
14086: PPUSH
14087: CALL_OW 251
14091: PUSH
14092: LD_INT 107
14094: EQUAL
14095: AND
14096: IFFALSE 14061
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14098: LD_EXP 38
14102: PUSH
14103: LD_EXP 39
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: PPUSH
14112: LD_INT 35
14114: PPUSH
14115: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14119: LD_EXP 38
14123: PPUSH
14124: LD_STRING D1-A-1
14126: PPUSH
14127: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14131: LD_EXP 39
14135: PPUSH
14136: LD_STRING D1-B-1
14138: PPUSH
14139: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14143: LD_EXP 38
14147: PPUSH
14148: LD_STRING D1-A-2
14150: PPUSH
14151: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14155: LD_EXP 39
14159: PPUSH
14160: LD_STRING D1-B-2
14162: PPUSH
14163: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14167: LD_EXP 38
14171: PUSH
14172: LD_EXP 39
14176: PUSH
14177: EMPTY
14178: LIST
14179: LIST
14180: PPUSH
14181: LD_INT 147
14183: PPUSH
14184: LD_INT 108
14186: PPUSH
14187: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14191: LD_EXP 38
14195: PPUSH
14196: LD_STRING D1-A-3
14198: PPUSH
14199: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14203: LD_INT 4
14205: PPUSH
14206: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14210: LD_EXP 38
14214: PPUSH
14215: LD_INT 35
14217: PPUSH
14218: CALL_OW 296
14222: PUSH
14223: LD_INT 8
14225: LESS
14226: IFFALSE 14203
// ComTurnUnit ( guyA , guyB ) ;
14228: LD_EXP 38
14232: PPUSH
14233: LD_EXP 39
14237: PPUSH
14238: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14242: LD_EXP 39
14246: PPUSH
14247: LD_EXP 38
14251: PPUSH
14252: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14256: LD_EXP 38
14260: PPUSH
14261: LD_STRING D1-A-10
14263: PPUSH
14264: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14268: LD_EXP 39
14272: PPUSH
14273: LD_STRING D1-B-10
14275: PPUSH
14276: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14280: LD_EXP 38
14284: PPUSH
14285: LD_STRING D1-A-11
14287: PPUSH
14288: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14292: LD_EXP 39
14296: PPUSH
14297: LD_STRING D1-B-11
14299: PPUSH
14300: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14304: LD_EXP 38
14308: PPUSH
14309: LD_STRING D1-A-12
14311: PPUSH
14312: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14316: LD_EXP 39
14320: PPUSH
14321: LD_STRING D1-B-12
14323: PPUSH
14324: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14328: LD_EXP 38
14332: PPUSH
14333: LD_STRING D1-A-13
14335: PPUSH
14336: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14340: LD_EXP 39
14344: PPUSH
14345: LD_STRING D1-B-13
14347: PPUSH
14348: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14352: LD_EXP 38
14356: PPUSH
14357: LD_STRING D1-A-14
14359: PPUSH
14360: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14364: LD_EXP 39
14368: PPUSH
14369: LD_STRING D1-B-14
14371: PPUSH
14372: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14376: LD_EXP 38
14380: PPUSH
14381: LD_STRING D1-A-15
14383: PPUSH
14384: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14388: LD_EXP 39
14392: PPUSH
14393: LD_STRING D1-B-15
14395: PPUSH
14396: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14400: LD_EXP 38
14404: PPUSH
14405: LD_STRING D1-A-16
14407: PPUSH
14408: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14412: LD_EXP 39
14416: PPUSH
14417: LD_STRING D1-B-16
14419: PPUSH
14420: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14424: LD_EXP 38
14428: PPUSH
14429: LD_STRING D1-A-17
14431: PPUSH
14432: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14436: LD_EXP 39
14440: PPUSH
14441: LD_STRING D1-B-17
14443: PPUSH
14444: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
14448: LD_EXP 38
14452: PPUSH
14453: LD_STRING D1-A-18
14455: PPUSH
14456: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
14460: LD_INT 35
14462: PPUSH
14463: LD_INT 1
14465: PPUSH
14466: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
14470: LD_EXP 38
14474: PUSH
14475: LD_EXP 39
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: PPUSH
14484: LD_INT 35
14486: PPUSH
14487: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
14491: LD_INT 4
14493: PPUSH
14494: CALL_OW 67
// until IsInUnit ( guyA ) ;
14498: LD_EXP 38
14502: PPUSH
14503: CALL_OW 310
14507: IFFALSE 14491
// Wait ( 0 0$02 ) ;
14509: LD_INT 70
14511: PPUSH
14512: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
14516: LD_EXP 38
14520: PPUSH
14521: LD_STRING D1-A-19
14523: PPUSH
14524: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
14528: LD_EXP 39
14532: PPUSH
14533: LD_STRING D1-B-19
14535: PPUSH
14536: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
14540: LD_EXP 38
14544: PPUSH
14545: LD_STRING D1-A-20
14547: PPUSH
14548: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
14552: LD_INT 10
14554: PPUSH
14555: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
14559: LD_EXP 39
14563: PPUSH
14564: LD_STRING D1-B-20
14566: PPUSH
14567: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
14571: LD_EXP 38
14575: PPUSH
14576: LD_STRING D1-A-21
14578: PPUSH
14579: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
14583: LD_EXP 39
14587: PPUSH
14588: LD_STRING D1-B-21
14590: PPUSH
14591: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
14595: LD_EXP 38
14599: PPUSH
14600: LD_STRING D1-A-22
14602: PPUSH
14603: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
14607: LD_EXP 39
14611: PPUSH
14612: LD_STRING D1-B-22
14614: PPUSH
14615: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
14619: LD_EXP 38
14623: PPUSH
14624: LD_STRING D1-A-23
14626: PPUSH
14627: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
14631: LD_EXP 39
14635: PPUSH
14636: LD_STRING D1-B-23
14638: PPUSH
14639: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
14643: LD_EXP 38
14647: PPUSH
14648: LD_STRING D1-A-24
14650: PPUSH
14651: CALL_OW 88
// InGameOff ;
14655: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
14659: LD_STRING M_main
14661: PPUSH
14662: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
14666: LD_INT 4
14668: PPUSH
14669: LD_INT 1
14671: PPUSH
14672: CALL_OW 343
// game_status := true ;
14676: LD_ADDR_EXP 29
14680: PUSH
14681: LD_INT 1
14683: ST_TO_ADDR
// end ;
14684: LD_VAR 0 1
14688: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
14689: LD_INT 1
14691: PPUSH
14692: CALL 6376 0 1
14696: PUSH
14697: LD_INT 0
14699: GREATER
14700: IFFALSE 14802
14702: GO 14704
14704: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
14705: LD_INT 35
14707: PPUSH
14708: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
14712: LD_INT 1
14714: PPUSH
14715: CALL 6376 0 1
14719: PUSH
14720: LD_INT 1
14722: ARRAY
14723: PPUSH
14724: CALL_OW 461
14728: PUSH
14729: LD_INT 1
14731: NONEQUAL
14732: IFFALSE 14705
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
14734: LD_EXP 38
14738: PPUSH
14739: CALL_OW 300
14743: PUSH
14744: LD_EXP 39
14748: PPUSH
14749: CALL_OW 300
14753: AND
14754: PUSH
14755: LD_EXP 30
14759: NOT
14760: AND
14761: IFFALSE 14787
// begin Say ( guyA , DL-A-1 ) ;
14763: LD_EXP 38
14767: PPUSH
14768: LD_STRING DL-A-1
14770: PPUSH
14771: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
14775: LD_EXP 39
14779: PPUSH
14780: LD_STRING DL-B-1
14782: PPUSH
14783: CALL_OW 88
// end ; if not helps_can_arrive then
14787: LD_EXP 31
14791: NOT
14792: IFFALSE 14802
// helps_can_arrive := true ;
14794: LD_ADDR_EXP 31
14798: PUSH
14799: LD_INT 1
14801: ST_TO_ADDR
// end ;
14802: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
14803: LD_INT 1
14805: PPUSH
14806: CALL 6376 0 1
14810: PUSH
14811: LD_INT 0
14813: GREATER
14814: PUSH
14815: LD_EXP 38
14819: PPUSH
14820: CALL_OW 300
14824: AND
14825: PUSH
14826: LD_EXP 39
14830: PPUSH
14831: CALL_OW 300
14835: AND
14836: PUSH
14837: LD_INT 22
14839: PUSH
14840: LD_INT 1
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: PUSH
14847: LD_INT 25
14849: PUSH
14850: LD_INT 12
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PPUSH
14861: CALL_OW 69
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: AND
14870: PUSH
14871: LD_INT 1
14873: PPUSH
14874: LD_INT 25
14876: PUSH
14877: LD_INT 12
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PPUSH
14884: CALL_OW 69
14888: PPUSH
14889: LD_EXP 38
14893: PPUSH
14894: CALL_OW 74
14898: PPUSH
14899: CALL_OW 292
14903: AND
14904: IFFALSE 14945
14906: GO 14908
14908: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
14909: LD_EXP 38
14913: PPUSH
14914: LD_STRING DA-A-1
14916: PPUSH
14917: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
14921: LD_EXP 39
14925: PPUSH
14926: LD_STRING DA-B-1
14928: PPUSH
14929: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
14933: LD_EXP 38
14937: PPUSH
14938: LD_STRING DA-A-2
14940: PPUSH
14941: CALL_OW 88
// end ;
14945: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
14946: LD_EXP 29
14950: PUSH
14951: LD_EXP 38
14955: PPUSH
14956: LD_INT 6
14958: PPUSH
14959: CALL_OW 299
14963: PUSH
14964: LD_INT 7
14966: LESS
14967: AND
14968: IFFALSE 15021
14970: GO 14972
14972: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
14973: LD_INT 117
14975: PPUSH
14976: LD_INT 50
14978: PPUSH
14979: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
14983: LD_INT 1
14985: PPUSH
14986: CALL 10117 0 1
14990: PUSH
14991: LD_INT 2
14993: ARRAY
14994: PPUSH
14995: LD_STRING D5-A-1
14997: PPUSH
14998: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 10117 0 1
15009: PUSH
15010: LD_INT 1
15012: ARRAY
15013: PPUSH
15014: LD_STRING D5-B-1
15016: PPUSH
15017: CALL_OW 88
// end ;
15021: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
15022: LD_INT 7
15024: PPUSH
15025: LD_INT 22
15027: PUSH
15028: LD_INT 1
15030: PUSH
15031: EMPTY
15032: LIST
15033: LIST
15034: PPUSH
15035: CALL_OW 70
15039: PUSH
15040: LD_INT 0
15042: GREATER
15043: IFFALSE 15188
15045: GO 15047
15047: DISABLE
// begin Wait ( 0 0$03 ) ;
15048: LD_INT 105
15050: PPUSH
15051: CALL_OW 67
// DialogueOn ;
15055: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
15059: LD_INT 1
15061: PPUSH
15062: CALL 10117 0 1
15066: PUSH
15067: LD_INT 1
15069: ARRAY
15070: PPUSH
15071: LD_STRING D6-A-1
15073: PPUSH
15074: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15078: LD_INT 1
15080: PPUSH
15081: CALL 10117 0 1
15085: PUSH
15086: LD_INT 2
15088: ARRAY
15089: PPUSH
15090: LD_STRING D6-B-1
15092: PPUSH
15093: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15097: LD_INT 95
15099: PPUSH
15100: LD_INT 8
15102: PPUSH
15103: LD_INT 1
15105: PPUSH
15106: LD_INT 20
15108: PPUSH
15109: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15113: LD_INT 10
15115: PPUSH
15116: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15120: LD_INT 1
15122: PPUSH
15123: CALL 10117 0 1
15127: PUSH
15128: LD_INT 1
15130: ARRAY
15131: PPUSH
15132: LD_STRING D6-A-2
15134: PPUSH
15135: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15139: LD_INT 1
15141: PPUSH
15142: CALL 10117 0 1
15146: PUSH
15147: LD_INT 2
15149: ARRAY
15150: PPUSH
15151: LD_STRING D6-B-2
15153: PPUSH
15154: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15158: LD_INT 1
15160: PPUSH
15161: CALL 10117 0 1
15165: PUSH
15166: LD_INT 1
15168: ARRAY
15169: PPUSH
15170: LD_STRING D6-A-3
15172: PPUSH
15173: CALL_OW 88
// DialogueOff ;
15177: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15181: LD_STRING M_base
15183: PPUSH
15184: CALL_OW 337
// end ;
15188: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15189: LD_EXP 30
15193: NOT
15194: PUSH
15195: LD_INT 22
15197: PUSH
15198: LD_INT 3
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: PUSH
15205: LD_INT 21
15207: PUSH
15208: LD_INT 2
15210: PUSH
15211: EMPTY
15212: LIST
15213: LIST
15214: PUSH
15215: EMPTY
15216: LIST
15217: LIST
15218: PPUSH
15219: CALL_OW 69
15223: PUSH
15224: LD_INT 0
15226: GREATER
15227: AND
15228: IFFALSE 15361
15230: GO 15232
15232: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15233: LD_INT 35
15235: PPUSH
15236: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15240: LD_INT 22
15242: PUSH
15243: LD_INT 3
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: PUSH
15250: LD_INT 21
15252: PUSH
15253: LD_INT 2
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: PUSH
15260: EMPTY
15261: LIST
15262: LIST
15263: PPUSH
15264: CALL_OW 69
15268: PPUSH
15269: LD_INT 1
15271: PPUSH
15272: CALL 10117 0 1
15276: PUSH
15277: LD_INT 1
15279: ARRAY
15280: PPUSH
15281: CALL_OW 74
15285: PPUSH
15286: LD_INT 1
15288: PPUSH
15289: CALL 10117 0 1
15293: PUSH
15294: LD_INT 1
15296: ARRAY
15297: PPUSH
15298: CALL_OW 296
15302: PUSH
15303: LD_INT 7
15305: LESS
15306: IFFALSE 15233
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15308: LD_INT 1
15310: PPUSH
15311: CALL 10117 0 1
15315: PUSH
15316: LD_INT 1
15318: ARRAY
15319: PPUSH
15320: LD_STRING DR-A-1
15322: PPUSH
15323: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15327: LD_INT 1
15329: PPUSH
15330: CALL 10117 0 1
15334: PUSH
15335: LD_INT 2
15337: ARRAY
15338: PPUSH
15339: LD_STRING DR-B-1
15341: PPUSH
15342: CALL_OW 88
// Wait ( 3 3$00 ) ;
15346: LD_INT 6300
15348: PPUSH
15349: CALL_OW 67
// ru_spotted := true ;
15353: LD_ADDR_EXP 16
15357: PUSH
15358: LD_INT 1
15360: ST_TO_ADDR
// end ;
15361: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15362: LD_INT 35
15364: PPUSH
15365: CALL_OW 300
15369: NOT
15370: IFFALSE 15394
15372: GO 15374
15374: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15375: LD_INT 1
15377: PPUSH
15378: CALL 10117 0 1
15382: PUSH
15383: LD_INT 1
15385: ARRAY
15386: PPUSH
15387: LD_STRING DDR-A-1
15389: PPUSH
15390: CALL_OW 88
15394: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15395: LD_INT 1
15397: PPUSH
15398: LD_INT 30
15400: PPUSH
15401: CALL 6227 0 2
15405: IFFALSE 15487
15407: GO 15409
15409: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15410: LD_INT 35
15412: PPUSH
15413: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15417: LD_INT 1
15419: PPUSH
15420: LD_INT 30
15422: PPUSH
15423: CALL 6227 0 2
15427: PUSH
15428: LD_INT 1
15430: ARRAY
15431: PPUSH
15432: CALL_OW 461
15436: PUSH
15437: LD_INT 1
15439: NONEQUAL
15440: IFFALSE 15410
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15442: LD_INT 1
15444: PPUSH
15445: CALL 10117 0 1
15449: PUSH
15450: LD_INT 1
15452: ARRAY
15453: PPUSH
15454: LD_STRING D8-A-1
15456: PPUSH
15457: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
15461: LD_INT 1
15463: PPUSH
15464: CALL 10117 0 1
15468: PUSH
15469: LD_INT 2
15471: ARRAY
15472: PPUSH
15473: LD_STRING D8-B-1
15475: PPUSH
15476: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
15480: LD_STRING M_mineok
15482: PPUSH
15483: CALL_OW 337
// end ;
15487: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
15488: LD_INT 22
15490: PUSH
15491: LD_INT 1
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: LD_INT 30
15500: PUSH
15501: LD_INT 0
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PUSH
15508: LD_INT 3
15510: PUSH
15511: LD_INT 57
15513: PUSH
15514: EMPTY
15515: LIST
15516: PUSH
15517: EMPTY
15518: LIST
15519: LIST
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: PPUSH
15526: CALL_OW 69
15530: PUSH
15531: LD_INT 1
15533: GREATER
15534: PUSH
15535: LD_INT 22
15537: PUSH
15538: LD_INT 1
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: PUSH
15545: LD_INT 30
15547: PUSH
15548: LD_INT 0
15550: PUSH
15551: EMPTY
15552: LIST
15553: LIST
15554: PUSH
15555: LD_INT 3
15557: PUSH
15558: LD_INT 57
15560: PUSH
15561: EMPTY
15562: LIST
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: LIST
15572: PPUSH
15573: CALL_OW 69
15577: PUSH
15578: LD_INT 1
15580: EQUAL
15581: PUSH
15582: LD_INT 35
15584: PPUSH
15585: CALL_OW 300
15589: NOT
15590: AND
15591: OR
15592: IFFALSE 15644
15594: GO 15596
15596: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
15597: LD_INT 22
15599: PUSH
15600: LD_INT 1
15602: PUSH
15603: EMPTY
15604: LIST
15605: LIST
15606: PUSH
15607: LD_INT 25
15609: PUSH
15610: LD_INT 2
15612: PUSH
15613: EMPTY
15614: LIST
15615: LIST
15616: PUSH
15617: EMPTY
15618: LIST
15619: LIST
15620: PPUSH
15621: CALL_OW 69
15625: PUSH
15626: LD_INT 1
15628: ARRAY
15629: PPUSH
15630: LD_STRING D7-A-1
15632: PPUSH
15633: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
15637: LD_STRING M_baseok
15639: PPUSH
15640: CALL_OW 337
// end ;
15644: END
// every 0 0$01 trigger mine_ck do
15645: LD_EXP 35
15649: IFFALSE 15680
15651: GO 15653
15653: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
15654: LD_INT 1
15656: PPUSH
15657: CALL 10117 0 1
15661: PUSH
15662: LD_INT 1
15664: ARRAY
15665: PPUSH
15666: LD_STRING D9-A-1
15668: PPUSH
15669: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
15673: LD_STRING M_minedest
15675: PPUSH
15676: CALL_OW 337
// end ;
15680: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
15681: LD_EXP 29
15685: IFFALSE 16191
15687: GO 15689
15689: DISABLE
15690: LD_INT 0
15692: PPUSH
15693: PPUSH
15694: PPUSH
15695: PPUSH
15696: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
15697: LD_OWVAR 67
15701: PPUSH
15702: CALL 12018 0 1
// if not helps_can_arrive then
15706: LD_EXP 31
15710: NOT
15711: IFFALSE 15739
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
15713: LD_EXP 40
15717: PUSH
15718: LD_INT 1
15720: ARRAY
15721: PPUSH
15722: LD_STRING DB-Delay
15724: PPUSH
15725: CALL_OW 94
// time := 10 10$00 ;
15729: LD_ADDR_VAR 0 1
15733: PUSH
15734: LD_INT 21000
15736: ST_TO_ADDR
// end else
15737: GO 15747
// time := 3 3$00 ;
15739: LD_ADDR_VAR 0 1
15743: PUSH
15744: LD_INT 6300
15746: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
15747: LD_ADDR_VAR 0 1
15751: PUSH
15752: LD_VAR 0 1
15756: PUSH
15757: LD_INT 35
15759: MINUS
15760: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
15761: LD_INT 35
15763: PPUSH
15764: CALL_OW 67
// end until time = 0 0$00 ;
15768: LD_VAR 0 1
15772: PUSH
15773: LD_INT 0
15775: EQUAL
15776: IFFALSE 15747
// helps_arrive := true ;
15778: LD_ADDR_EXP 30
15782: PUSH
15783: LD_INT 1
15785: ST_TO_ADDR
// if IsLive ( guyA ) then
15786: LD_EXP 38
15790: PPUSH
15791: CALL_OW 300
15795: IFFALSE 15809
// r := guyA else
15797: LD_ADDR_VAR 0 4
15801: PUSH
15802: LD_EXP 38
15806: ST_TO_ADDR
15807: GO 15819
// r := guyB ;
15809: LD_ADDR_VAR 0 4
15813: PUSH
15814: LD_EXP 39
15818: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
15819: LD_EXP 40
15823: PUSH
15824: LD_INT 1
15826: ARRAY
15827: PPUSH
15828: LD_STRING D2-A-1
15830: PPUSH
15831: CALL_OW 94
// Say ( r , D2-B-1 ) ;
15835: LD_VAR 0 4
15839: PPUSH
15840: LD_STRING D2-B-1
15842: PPUSH
15843: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
15847: LD_EXP 40
15851: PUSH
15852: LD_INT 1
15854: ARRAY
15855: PPUSH
15856: LD_STRING D2-A-2
15858: PPUSH
15859: CALL_OW 94
// Say ( r , D2-B-2 ) ;
15863: LD_VAR 0 4
15867: PPUSH
15868: LD_STRING D2-B-2
15870: PPUSH
15871: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
15875: LD_EXP 40
15879: PUSH
15880: LD_INT 1
15882: ARRAY
15883: PPUSH
15884: LD_STRING D2-A-3
15886: PPUSH
15887: CALL_OW 94
// Say ( r , D2-B-3 ) ;
15891: LD_VAR 0 4
15895: PPUSH
15896: LD_STRING D2-B-3
15898: PPUSH
15899: CALL_OW 88
// to_veh := [ ] ;
15903: LD_ADDR_VAR 0 5
15907: PUSH
15908: EMPTY
15909: ST_TO_ADDR
// for i = 1 to Beta_Squad do
15910: LD_ADDR_VAR 0 2
15914: PUSH
15915: DOUBLE
15916: LD_INT 1
15918: DEC
15919: ST_TO_ADDR
15920: LD_EXP 40
15924: PUSH
15925: FOR_TO
15926: IFFALSE 16189
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
15928: LD_EXP 40
15932: PUSH
15933: LD_VAR 0 2
15937: ARRAY
15938: PPUSH
15939: CALL_OW 110
15943: PUSH
15944: LD_INT 3
15946: EQUAL
15947: IFFALSE 15973
// to_veh := to_veh ^ Beta_Squad [ i ] else
15949: LD_ADDR_VAR 0 5
15953: PUSH
15954: LD_VAR 0 5
15958: PUSH
15959: LD_EXP 40
15963: PUSH
15964: LD_VAR 0 2
15968: ARRAY
15969: ADD
15970: ST_TO_ADDR
15971: GO 16098
// if GetTag ( Beta_Squad [ i ] ) = 5 then
15973: LD_EXP 40
15977: PUSH
15978: LD_VAR 0 2
15982: ARRAY
15983: PPUSH
15984: CALL_OW 110
15988: PUSH
15989: LD_INT 5
15991: EQUAL
15992: IFFALSE 16077
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
15994: LD_EXP 40
15998: PUSH
15999: LD_VAR 0 2
16003: ARRAY
16004: PPUSH
16005: LD_INT 4
16007: PPUSH
16008: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16012: LD_EXP 40
16016: PUSH
16017: LD_VAR 0 2
16021: ARRAY
16022: PPUSH
16023: LD_INT 5
16025: PPUSH
16026: LD_INT 0
16028: PPUSH
16029: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
16033: LD_VAR 0 5
16037: PUSH
16038: LD_INT 1
16040: ARRAY
16041: PPUSH
16042: LD_EXP 40
16046: PUSH
16047: LD_VAR 0 2
16051: ARRAY
16052: PPUSH
16053: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16057: LD_ADDR_VAR 0 5
16061: PUSH
16062: LD_VAR 0 5
16066: PPUSH
16067: LD_INT 1
16069: PPUSH
16070: CALL_OW 3
16074: ST_TO_ADDR
// end else
16075: GO 16098
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16077: LD_EXP 40
16081: PUSH
16082: LD_VAR 0 2
16086: ARRAY
16087: PPUSH
16088: LD_INT 5
16090: PPUSH
16091: LD_INT 0
16093: PPUSH
16094: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16098: LD_EXP 40
16102: PUSH
16103: LD_VAR 0 2
16107: ARRAY
16108: PPUSH
16109: LD_INT 165
16111: PPUSH
16112: LD_INT 105
16114: PPUSH
16115: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16119: LD_INT 70
16121: PPUSH
16122: LD_INT 140
16124: PPUSH
16125: CALL_OW 12
16129: PPUSH
16130: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16134: LD_EXP 40
16138: PUSH
16139: LD_VAR 0 2
16143: ARRAY
16144: PPUSH
16145: LD_INT 1
16147: PPUSH
16148: CALL_OW 235
// if i = 1 then
16152: LD_VAR 0 2
16156: PUSH
16157: LD_INT 1
16159: EQUAL
16160: IFFALSE 16172
// CenterNowOnXY ( 168 , 109 ) ;
16162: LD_INT 168
16164: PPUSH
16165: LD_INT 109
16167: PPUSH
16168: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16172: LD_EXP 40
16176: PUSH
16177: LD_VAR 0 2
16181: ARRAY
16182: PPUSH
16183: CALL_OW 141
// end ;
16187: GO 15925
16189: POP
16190: POP
// end ;
16191: PPOPN 5
16193: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16194: LD_EXP 30
16198: IFFALSE 17227
16200: GO 16202
16202: DISABLE
16203: LD_INT 0
16205: PPUSH
16206: PPUSH
// begin Wait ( 5 5$00 ) ;
16207: LD_INT 10500
16209: PPUSH
16210: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16214: LD_OWVAR 67
16218: PPUSH
16219: CALL 12707 0 1
// to_veh := [ ] ;
16223: LD_ADDR_VAR 0 2
16227: PUSH
16228: EMPTY
16229: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16230: LD_ADDR_VAR 0 1
16234: PUSH
16235: DOUBLE
16236: LD_INT 1
16238: DEC
16239: ST_TO_ADDR
16240: LD_EXP 41
16244: PUSH
16245: FOR_TO
16246: IFFALSE 16474
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16248: LD_EXP 41
16252: PUSH
16253: LD_VAR 0 1
16257: ARRAY
16258: PPUSH
16259: CALL_OW 110
16263: PUSH
16264: LD_INT 3
16266: EQUAL
16267: IFFALSE 16293
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16269: LD_ADDR_VAR 0 2
16273: PUSH
16274: LD_VAR 0 2
16278: PUSH
16279: LD_EXP 41
16283: PUSH
16284: LD_VAR 0 1
16288: ARRAY
16289: ADD
16290: ST_TO_ADDR
16291: GO 16418
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16293: LD_EXP 41
16297: PUSH
16298: LD_VAR 0 1
16302: ARRAY
16303: PPUSH
16304: CALL_OW 110
16308: PUSH
16309: LD_INT 5
16311: EQUAL
16312: IFFALSE 16397
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16314: LD_EXP 41
16318: PUSH
16319: LD_VAR 0 1
16323: ARRAY
16324: PPUSH
16325: LD_INT 4
16327: PPUSH
16328: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16332: LD_EXP 41
16336: PUSH
16337: LD_VAR 0 1
16341: ARRAY
16342: PPUSH
16343: LD_INT 5
16345: PPUSH
16346: LD_INT 0
16348: PPUSH
16349: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16353: LD_VAR 0 2
16357: PUSH
16358: LD_INT 1
16360: ARRAY
16361: PPUSH
16362: LD_EXP 41
16366: PUSH
16367: LD_VAR 0 1
16371: ARRAY
16372: PPUSH
16373: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16377: LD_ADDR_VAR 0 2
16381: PUSH
16382: LD_VAR 0 2
16386: PPUSH
16387: LD_INT 1
16389: PPUSH
16390: CALL_OW 3
16394: ST_TO_ADDR
// end else
16395: GO 16418
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16397: LD_EXP 41
16401: PUSH
16402: LD_VAR 0 1
16406: ARRAY
16407: PPUSH
16408: LD_INT 5
16410: PPUSH
16411: LD_INT 0
16413: PPUSH
16414: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16418: LD_EXP 41
16422: PUSH
16423: LD_VAR 0 1
16427: ARRAY
16428: PPUSH
16429: LD_INT 164
16431: PPUSH
16432: LD_INT 104
16434: PPUSH
16435: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16439: LD_INT 70
16441: PPUSH
16442: LD_INT 140
16444: PPUSH
16445: CALL_OW 12
16449: PPUSH
16450: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16454: LD_EXP 41
16458: PUSH
16459: LD_VAR 0 1
16463: ARRAY
16464: PPUSH
16465: LD_INT 1
16467: PPUSH
16468: CALL_OW 235
// end ;
16472: GO 16245
16474: POP
16475: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
16476: LD_EXP 41
16480: PUSH
16481: LD_INT 1
16483: ARRAY
16484: PPUSH
16485: LD_STRING D3-A-1
16487: PPUSH
16488: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
16492: LD_INT 1
16494: PPUSH
16495: CALL 10117 0 1
16499: PUSH
16500: LD_INT 1
16502: ARRAY
16503: PPUSH
16504: LD_STRING D3-B-1
16506: PPUSH
16507: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
16511: LD_EXP 41
16515: PUSH
16516: LD_INT 1
16518: ARRAY
16519: PPUSH
16520: LD_STRING D3-A-2
16522: PPUSH
16523: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
16527: LD_INT 1
16529: PPUSH
16530: CALL 10117 0 1
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_STRING D3-B-2
16541: PPUSH
16542: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
16546: LD_EXP 41
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_STRING D3-A-3
16557: PPUSH
16558: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
16562: LD_INT 1
16564: PPUSH
16565: CALL 10117 0 1
16569: PUSH
16570: LD_INT 1
16572: ARRAY
16573: PPUSH
16574: LD_STRING D3-B-3
16576: PPUSH
16577: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
16581: LD_EXP 41
16585: PUSH
16586: LD_INT 1
16588: ARRAY
16589: PPUSH
16590: LD_STRING D3-A-4
16592: PPUSH
16593: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
16597: LD_INT 1
16599: PPUSH
16600: CALL 10117 0 1
16604: PUSH
16605: LD_INT 1
16607: ARRAY
16608: PPUSH
16609: LD_STRING D3-B-4
16611: PPUSH
16612: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
16616: LD_EXP 41
16620: PUSH
16621: LD_INT 1
16623: ARRAY
16624: PPUSH
16625: LD_STRING D3-A-5
16627: PPUSH
16628: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
16632: LD_INT 1
16634: PPUSH
16635: CALL 10117 0 1
16639: PUSH
16640: LD_INT 1
16642: ARRAY
16643: PPUSH
16644: LD_STRING D3-B-5
16646: PPUSH
16647: CALL_OW 88
// for i = 1 to Gamma_Squad do
16651: LD_ADDR_VAR 0 1
16655: PUSH
16656: DOUBLE
16657: LD_INT 1
16659: DEC
16660: ST_TO_ADDR
16661: LD_EXP 41
16665: PUSH
16666: FOR_TO
16667: IFFALSE 16689
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16669: LD_EXP 41
16673: PUSH
16674: LD_VAR 0 1
16678: ARRAY
16679: PPUSH
16680: LD_INT 1
16682: PPUSH
16683: CALL_OW 235
16687: GO 16666
16689: POP
16690: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
16691: LD_INT 6300
16693: PUSH
16694: LD_INT 10500
16696: PUSH
16697: LD_INT 11550
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PUSH
16705: LD_OWVAR 67
16709: ARRAY
16710: PPUSH
16711: CALL_OW 67
// AddZetaSquad ;
16715: CALL 13436 0 0
// Wait ( 0 0$10 ) ;
16719: LD_INT 350
16721: PPUSH
16722: CALL_OW 67
// to_veh := [ ] ;
16726: LD_ADDR_VAR 0 2
16730: PUSH
16731: EMPTY
16732: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
16733: LD_ADDR_VAR 0 1
16737: PUSH
16738: DOUBLE
16739: LD_INT 1
16741: DEC
16742: ST_TO_ADDR
16743: LD_EXP 42
16747: PUSH
16748: FOR_TO
16749: IFFALSE 16959
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
16751: LD_EXP 42
16755: PUSH
16756: LD_VAR 0 1
16760: ARRAY
16761: PPUSH
16762: CALL_OW 110
16766: PUSH
16767: LD_INT 3
16769: EQUAL
16770: IFFALSE 16796
// to_veh := to_veh ^ Zeta_Squad [ i ] else
16772: LD_ADDR_VAR 0 2
16776: PUSH
16777: LD_VAR 0 2
16781: PUSH
16782: LD_EXP 42
16786: PUSH
16787: LD_VAR 0 1
16791: ARRAY
16792: ADD
16793: ST_TO_ADDR
16794: GO 16921
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
16796: LD_EXP 42
16800: PUSH
16801: LD_VAR 0 1
16805: ARRAY
16806: PPUSH
16807: CALL_OW 110
16811: PUSH
16812: LD_INT 5
16814: EQUAL
16815: IFFALSE 16900
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
16817: LD_EXP 42
16821: PUSH
16822: LD_VAR 0 1
16826: ARRAY
16827: PPUSH
16828: LD_INT 4
16830: PPUSH
16831: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
16835: LD_EXP 42
16839: PUSH
16840: LD_VAR 0 1
16844: ARRAY
16845: PPUSH
16846: LD_INT 5
16848: PPUSH
16849: LD_INT 0
16851: PPUSH
16852: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
16856: LD_VAR 0 2
16860: PUSH
16861: LD_INT 1
16863: ARRAY
16864: PPUSH
16865: LD_EXP 42
16869: PUSH
16870: LD_VAR 0 1
16874: ARRAY
16875: PPUSH
16876: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16880: LD_ADDR_VAR 0 2
16884: PUSH
16885: LD_VAR 0 2
16889: PPUSH
16890: LD_INT 1
16892: PPUSH
16893: CALL_OW 3
16897: ST_TO_ADDR
// end else
16898: GO 16921
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
16900: LD_EXP 42
16904: PUSH
16905: LD_VAR 0 1
16909: ARRAY
16910: PPUSH
16911: LD_INT 5
16913: PPUSH
16914: LD_INT 0
16916: PPUSH
16917: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
16921: LD_EXP 42
16925: PUSH
16926: LD_VAR 0 1
16930: ARRAY
16931: PPUSH
16932: LD_INT 165
16934: PPUSH
16935: LD_INT 105
16937: PPUSH
16938: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16942: LD_INT 70
16944: PPUSH
16945: LD_INT 140
16947: PPUSH
16948: CALL_OW 12
16952: PPUSH
16953: CALL_OW 67
// end ;
16957: GO 16748
16959: POP
16960: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
16961: LD_EXP 42
16965: PUSH
16966: LD_INT 1
16968: ARRAY
16969: PPUSH
16970: LD_STRING D4-A-1
16972: PPUSH
16973: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
16977: LD_INT 1
16979: PPUSH
16980: CALL 10117 0 1
16984: PUSH
16985: LD_INT 1
16987: ARRAY
16988: PPUSH
16989: LD_STRING D4-B-1
16991: PPUSH
16992: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
16996: LD_EXP 42
17000: PUSH
17001: LD_INT 1
17003: ARRAY
17004: PPUSH
17005: LD_STRING D4-A-2
17007: PPUSH
17008: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
17012: LD_INT 1
17014: PPUSH
17015: CALL 10117 0 1
17019: PUSH
17020: LD_INT 1
17022: ARRAY
17023: PPUSH
17024: LD_STRING D4-B-2
17026: PPUSH
17027: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
17031: LD_EXP 42
17035: PUSH
17036: LD_INT 1
17038: ARRAY
17039: PPUSH
17040: LD_STRING D4-A-3
17042: PPUSH
17043: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
17047: LD_INT 1
17049: PPUSH
17050: CALL 10117 0 1
17054: PUSH
17055: LD_INT 1
17057: ARRAY
17058: PPUSH
17059: LD_STRING D4-B-3
17061: PPUSH
17062: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
17066: LD_EXP 42
17070: PUSH
17071: LD_INT 1
17073: ARRAY
17074: PPUSH
17075: LD_STRING D4-A-4
17077: PPUSH
17078: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17082: LD_INT 1
17084: PPUSH
17085: CALL 10117 0 1
17089: PUSH
17090: LD_INT 1
17092: ARRAY
17093: PPUSH
17094: LD_STRING D4-B-4
17096: PPUSH
17097: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17101: LD_EXP 42
17105: PUSH
17106: LD_INT 1
17108: ARRAY
17109: PPUSH
17110: LD_STRING D4-A-5
17112: PPUSH
17113: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17117: LD_INT 1
17119: PPUSH
17120: CALL 10117 0 1
17124: PUSH
17125: LD_INT 1
17127: ARRAY
17128: PPUSH
17129: LD_STRING D4-B-5
17131: PPUSH
17132: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17136: LD_EXP 42
17140: PUSH
17141: LD_INT 1
17143: ARRAY
17144: PPUSH
17145: LD_STRING D4-A-6
17147: PPUSH
17148: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17152: LD_INT 1
17154: PPUSH
17155: CALL 10117 0 1
17159: PUSH
17160: LD_INT 1
17162: ARRAY
17163: PPUSH
17164: LD_STRING D4-B-6
17166: PPUSH
17167: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17171: LD_EXP 42
17175: PUSH
17176: LD_INT 1
17178: ARRAY
17179: PPUSH
17180: LD_STRING D4-A-7
17182: PPUSH
17183: CALL_OW 94
// for i = 1 to Zeta_Squad do
17187: LD_ADDR_VAR 0 1
17191: PUSH
17192: DOUBLE
17193: LD_INT 1
17195: DEC
17196: ST_TO_ADDR
17197: LD_EXP 42
17201: PUSH
17202: FOR_TO
17203: IFFALSE 17225
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17205: LD_EXP 42
17209: PUSH
17210: LD_VAR 0 1
17214: ARRAY
17215: PPUSH
17216: LD_INT 1
17218: PPUSH
17219: CALL_OW 235
17223: GO 17202
17225: POP
17226: POP
// end ;
17227: PPOPN 2
17229: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17230: LD_INT 11
17232: PPUSH
17233: LD_INT 22
17235: PUSH
17236: LD_OWVAR 2
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: PPUSH
17245: CALL_OW 70
17249: PUSH
17250: LD_INT 0
17252: GREATER
17253: IFFALSE 17278
17255: GO 17257
17257: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17258: LD_EXP 38
17262: PPUSH
17263: LD_STRING D10-A-1
17265: PPUSH
17266: CALL_OW 88
// ru_spotted := true ;
17270: LD_ADDR_EXP 16
17274: PUSH
17275: LD_INT 1
17277: ST_TO_ADDR
// end ;
17278: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17279: LD_EXP 38
17283: PPUSH
17284: CALL_OW 301
17288: PUSH
17289: LD_EXP 39
17293: PPUSH
17294: CALL_OW 301
17298: OR
17299: IFFALSE 17311
17301: GO 17303
17303: DISABLE
// begin YouLost ( DieP ) ;
17304: LD_STRING DieP
17306: PPUSH
17307: CALL_OW 104
// end ;
17311: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17312: LD_INT 34
17314: PUSH
17315: LD_INT 8
17317: PUSH
17318: EMPTY
17319: LIST
17320: LIST
17321: PPUSH
17322: CALL_OW 69
17326: IFFALSE 17339
17328: GO 17330
17330: DISABLE
// sib_bomb_constructed := true ;
17331: LD_ADDR_EXP 36
17335: PUSH
17336: LD_INT 1
17338: ST_TO_ADDR
17339: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17340: LD_EXP 29
17344: PUSH
17345: LD_INT 22
17347: PUSH
17348: LD_INT 3
17350: PUSH
17351: EMPTY
17352: LIST
17353: LIST
17354: PPUSH
17355: CALL_OW 69
17359: PUSH
17360: LD_INT 0
17362: EQUAL
17363: AND
17364: IFFALSE 17567
17366: GO 17368
17368: DISABLE
17369: LD_INT 0
17371: PPUSH
// begin game_status := false ;
17372: LD_ADDR_EXP 29
17376: PUSH
17377: LD_INT 0
17379: ST_TO_ADDR
// if not depotConstructed then
17380: LD_EXP 2
17384: NOT
17385: IFFALSE 17394
// SetAchievement ( ACH_NODEPOT ) ;
17387: LD_STRING ACH_NODEPOT
17389: PPUSH
17390: CALL_OW 543
// if Difficulty = 3 then
17394: LD_OWVAR 67
17398: PUSH
17399: LD_INT 3
17401: EQUAL
17402: IFFALSE 17411
// SetAchievement ( ACH_HARD ) ;
17404: LD_STRING ACH_HARD
17406: PPUSH
17407: CALL_OW 543
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17411: LD_OWVAR 1
17415: PUSH
17416: LD_INT 35
17418: DIVREAL
17419: PUSH
17420: LD_INT 60
17422: DIVREAL
17423: PUSH
17424: LD_INT 70
17426: PUSH
17427: LD_INT 60
17429: PUSH
17430: LD_INT 50
17432: PUSH
17433: EMPTY
17434: LIST
17435: LIST
17436: LIST
17437: PUSH
17438: LD_OWVAR 67
17442: ARRAY
17443: LESS
17444: IFFALSE 17458
// AddMedal ( play , 1 ) else
17446: LD_STRING play
17448: PPUSH
17449: LD_INT 1
17451: PPUSH
17452: CALL_OW 101
17456: GO 17469
// AddMedal ( play , - 1 ) ;
17458: LD_STRING play
17460: PPUSH
17461: LD_INT 1
17463: NEG
17464: PPUSH
17465: CALL_OW 101
// if sib_bomb_constructed then
17469: LD_EXP 36
17473: IFFALSE 17487
// AddMedal ( sibbomb , 1 ) else
17475: LD_STRING sibbomb
17477: PPUSH
17478: LD_INT 1
17480: PPUSH
17481: CALL_OW 101
17485: GO 17498
// AddMedal ( sibbomb , - 1 ) ;
17487: LD_STRING sibbomb
17489: PPUSH
17490: LD_INT 1
17492: NEG
17493: PPUSH
17494: CALL_OW 101
// if mine_constructed and not mine_ck then
17498: LD_EXP 37
17502: PUSH
17503: LD_EXP 35
17507: NOT
17508: AND
17509: IFFALSE 17521
// AddMedal ( mine , 1 ) ;
17511: LD_STRING mine
17513: PPUSH
17514: LD_INT 1
17516: PPUSH
17517: CALL_OW 101
// if mine_ck then
17521: LD_EXP 35
17525: IFFALSE 17538
// AddMedal ( mine , - 1 ) ;
17527: LD_STRING mine
17529: PPUSH
17530: LD_INT 1
17532: NEG
17533: PPUSH
17534: CALL_OW 101
// if not mine_constructed then
17538: LD_EXP 37
17542: NOT
17543: IFFALSE 17556
// AddMedal ( mine , - 2 ) ;
17545: LD_STRING mine
17547: PPUSH
17548: LD_INT 2
17550: NEG
17551: PPUSH
17552: CALL_OW 101
// GiveMedals ( Main ) ;
17556: LD_STRING Main
17558: PPUSH
17559: CALL_OW 102
// YouWin ;
17563: CALL_OW 103
// end ; end_of_file
17567: PPOPN 1
17569: END
// every 0 0$03 trigger game_status do var time ;
17570: LD_EXP 29
17574: IFFALSE 17739
17576: GO 17578
17578: DISABLE
17579: LD_INT 0
17581: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
17582: LD_ADDR_VAR 0 1
17586: PUSH
17587: LD_INT 1050
17589: PUSH
17590: LD_INT 1575
17592: PUSH
17593: LD_INT 2100
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: LIST
17600: PUSH
17601: LD_OWVAR 67
17605: ARRAY
17606: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
17607: LD_VAR 0 1
17611: PUSH
17612: LD_INT 0
17614: PPUSH
17615: LD_INT 420
17617: PPUSH
17618: CALL_OW 12
17622: PLUS
17623: PPUSH
17624: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
17628: LD_INT 1
17630: PPUSH
17631: LD_INT 5
17633: PPUSH
17634: CALL_OW 12
17638: PPUSH
17639: LD_INT 1
17641: PPUSH
17642: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
17646: LD_INT 105
17648: PPUSH
17649: LD_INT 1050
17651: PPUSH
17652: CALL_OW 12
17656: PPUSH
17657: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
17661: LD_INT 1
17663: PPUSH
17664: LD_INT 5
17666: PPUSH
17667: CALL_OW 12
17671: PPUSH
17672: LD_INT 148
17674: PPUSH
17675: LD_INT 107
17677: PPUSH
17678: LD_INT 20
17680: PPUSH
17681: LD_INT 1
17683: PPUSH
17684: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
17688: LD_OWVAR 1
17692: PUSH
17693: LD_INT 44100
17695: PUSH
17696: LD_INT 37800
17698: PUSH
17699: LD_INT 33600
17701: PUSH
17702: EMPTY
17703: LIST
17704: LIST
17705: LIST
17706: PUSH
17707: LD_OWVAR 67
17711: ARRAY
17712: MOD
17713: IFFALSE 17729
// time := time + 0 0$20 ;
17715: LD_ADDR_VAR 0 1
17719: PUSH
17720: LD_VAR 0 1
17724: PUSH
17725: LD_INT 700
17727: PLUS
17728: ST_TO_ADDR
// end until game_status = false ;
17729: LD_EXP 29
17733: PUSH
17734: LD_INT 0
17736: EQUAL
17737: IFFALSE 17607
// end ;
17739: PPOPN 1
17741: END
// every 0 0$03 trigger game_status do var time ;
17742: LD_EXP 29
17746: IFFALSE 17900
17748: GO 17750
17750: DISABLE
17751: LD_INT 0
17753: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
17754: LD_ADDR_VAR 0 1
17758: PUSH
17759: LD_INT 700
17761: PUSH
17762: LD_INT 875
17764: PUSH
17765: LD_INT 1400
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: LIST
17772: PUSH
17773: LD_OWVAR 67
17777: ARRAY
17778: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
17779: LD_VAR 0 1
17783: PUSH
17784: LD_INT 0
17786: PPUSH
17787: LD_INT 385
17789: PPUSH
17790: CALL_OW 12
17794: PLUS
17795: PPUSH
17796: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
17800: LD_INT 1
17802: PPUSH
17803: LD_INT 5
17805: PPUSH
17806: CALL_OW 12
17810: PPUSH
17811: LD_INT 102
17813: PPUSH
17814: LD_INT 6
17816: PPUSH
17817: LD_INT 25
17819: PPUSH
17820: LD_INT 1
17822: PPUSH
17823: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
17827: LD_OWVAR 1
17831: PUSH
17832: LD_INT 52500
17834: PUSH
17835: LD_INT 46200
17837: PUSH
17838: LD_INT 42000
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: LIST
17845: PUSH
17846: LD_OWVAR 67
17850: ARRAY
17851: MOD
17852: IFFALSE 17868
// time := time + 0 0$25 ;
17854: LD_ADDR_VAR 0 1
17858: PUSH
17859: LD_VAR 0 1
17863: PUSH
17864: LD_INT 875
17866: PLUS
17867: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
17868: LD_OWVAR 1
17872: PUSH
17873: LD_INT 231000
17875: MOD
17876: PUSH
17877: LD_INT 0
17879: EQUAL
17880: IFFALSE 17890
// time := 0 0$30 ;
17882: LD_ADDR_VAR 0 1
17886: PUSH
17887: LD_INT 1050
17889: ST_TO_ADDR
// end until game_status = false ;
17890: LD_EXP 29
17894: PUSH
17895: LD_INT 0
17897: EQUAL
17898: IFFALSE 17779
// end ;
17900: PPOPN 1
17902: END
// every 0 0$03 trigger game_status do var time ;
17903: LD_EXP 29
17907: IFFALSE 18043
17909: GO 17911
17911: DISABLE
17912: LD_INT 0
17914: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
17915: LD_ADDR_VAR 0 1
17919: PUSH
17920: LD_INT 1050
17922: PUSH
17923: LD_INT 1575
17925: PUSH
17926: LD_INT 1750
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: LIST
17933: PUSH
17934: LD_OWVAR 67
17938: ARRAY
17939: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
17940: LD_VAR 0 1
17944: PUSH
17945: LD_INT 0
17947: PPUSH
17948: LD_INT 385
17950: PPUSH
17951: CALL_OW 12
17955: PLUS
17956: PPUSH
17957: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
17961: LD_INT 1
17963: PPUSH
17964: LD_INT 5
17966: PPUSH
17967: CALL_OW 12
17971: PPUSH
17972: LD_INT 51
17974: PPUSH
17975: LD_INT 74
17977: PPUSH
17978: LD_INT 25
17980: PPUSH
17981: LD_INT 1
17983: PPUSH
17984: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
17988: LD_OWVAR 1
17992: PUSH
17993: LD_INT 84000
17995: PUSH
17996: LD_INT 105000
17998: PUSH
17999: LD_INT 136500
18001: PUSH
18002: EMPTY
18003: LIST
18004: LIST
18005: LIST
18006: PUSH
18007: LD_OWVAR 67
18011: ARRAY
18012: MOD
18013: PUSH
18014: LD_INT 0
18016: EQUAL
18017: IFFALSE 18033
// time := time + 0 0$15 ;
18019: LD_ADDR_VAR 0 1
18023: PUSH
18024: LD_VAR 0 1
18028: PUSH
18029: LD_INT 525
18031: PLUS
18032: ST_TO_ADDR
// end until game_status = false ;
18033: LD_EXP 29
18037: PUSH
18038: LD_INT 0
18040: EQUAL
18041: IFFALSE 17940
// end ; end_of_file
18043: PPOPN 1
18045: END
// every 0 0$01 trigger not debug do
18046: LD_EXP 1
18050: NOT
18051: IFFALSE 18074
18053: GO 18055
18055: DISABLE
// begin enable ;
18056: ENABLE
// Display_Strings := [ #tick , tick ] ;
18057: LD_ADDR_OWVAR 47
18061: PUSH
18062: LD_STRING #tick
18064: PUSH
18065: LD_OWVAR 1
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: ST_TO_ADDR
// end ; end_of_file
18074: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
18075: LD_VAR 0 1
18079: PPUSH
18080: CALL_OW 255
18084: PUSH
18085: LD_INT 3
18087: EQUAL
18088: PUSH
18089: LD_VAR 0 1
18093: PUSH
18094: LD_INT 2
18096: PUSH
18097: LD_INT 34
18099: PUSH
18100: LD_INT 46
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: PUSH
18107: LD_INT 34
18109: PUSH
18110: LD_INT 47
18112: PUSH
18113: EMPTY
18114: LIST
18115: LIST
18116: PUSH
18117: LD_INT 34
18119: PUSH
18120: LD_INT 45
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: LIST
18131: LIST
18132: PUSH
18133: EMPTY
18134: LIST
18135: PPUSH
18136: CALL_OW 69
18140: IN
18141: AND
18142: IFFALSE 18160
// ru_reserve := ru_reserve ^ un ;
18144: LD_ADDR_EXP 9
18148: PUSH
18149: LD_EXP 9
18153: PUSH
18154: LD_VAR 0 1
18158: ADD
18159: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
18160: LD_VAR 0 1
18164: PUSH
18165: LD_INT 22
18167: PUSH
18168: LD_INT 3
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PUSH
18175: LD_INT 34
18177: PUSH
18178: LD_INT 48
18180: PUSH
18181: EMPTY
18182: LIST
18183: LIST
18184: PUSH
18185: EMPTY
18186: LIST
18187: LIST
18188: PPUSH
18189: CALL_OW 69
18193: IN
18194: IFFALSE 18247
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
18196: LD_INT 12
18198: PPUSH
18199: LD_INT 22
18201: PUSH
18202: LD_INT 1
18204: PUSH
18205: EMPTY
18206: LIST
18207: LIST
18208: PPUSH
18209: CALL_OW 70
18213: IFFALSE 18232
// ComAttackPlace ( un , 98 , 10 ) else
18215: LD_VAR 0 1
18219: PPUSH
18220: LD_INT 98
18222: PPUSH
18223: LD_INT 10
18225: PPUSH
18226: CALL_OW 116
18230: GO 18247
// ComAttackPlace ( un , 134 , 99 ) ;
18232: LD_VAR 0 1
18236: PPUSH
18237: LD_INT 134
18239: PPUSH
18240: LD_INT 99
18242: PPUSH
18243: CALL_OW 116
// end ;
18247: PPOPN 2
18249: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
18250: LD_VAR 0 1
18254: PPUSH
18255: CALL 29967 0 1
// if GetChassis ( un ) = 25 then
18259: LD_VAR 0 1
18263: PPUSH
18264: CALL_OW 265
18268: PUSH
18269: LD_INT 25
18271: EQUAL
18272: IFFALSE 18281
// SetAchievement ( ACH_BEH ) ;
18274: LD_STRING ACH_BEH
18276: PPUSH
18277: CALL_OW 543
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
18281: LD_VAR 0 1
18285: PUSH
18286: LD_INT 22
18288: PUSH
18289: LD_INT 3
18291: PUSH
18292: EMPTY
18293: LIST
18294: LIST
18295: PUSH
18296: LD_INT 21
18298: PUSH
18299: LD_INT 3
18301: PUSH
18302: EMPTY
18303: LIST
18304: LIST
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: PPUSH
18310: CALL_OW 69
18314: IN
18315: PUSH
18316: LD_VAR 0 1
18320: PPUSH
18321: CALL_OW 266
18325: PUSH
18326: LD_INT 0
18328: PUSH
18329: LD_INT 29
18331: PUSH
18332: LD_INT 30
18334: PUSH
18335: LD_INT 26
18337: PUSH
18338: EMPTY
18339: LIST
18340: LIST
18341: LIST
18342: LIST
18343: IN
18344: NOT
18345: AND
18346: IFFALSE 18432
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
18348: LD_ADDR_EXP 13
18352: PUSH
18353: LD_EXP 13
18357: PUSH
18358: LD_VAR 0 1
18362: PPUSH
18363: CALL_OW 266
18367: ADD
18368: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
18369: LD_ADDR_EXP 13
18373: PUSH
18374: LD_EXP 13
18378: PUSH
18379: LD_VAR 0 1
18383: PPUSH
18384: CALL_OW 250
18388: ADD
18389: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
18390: LD_ADDR_EXP 13
18394: PUSH
18395: LD_EXP 13
18399: PUSH
18400: LD_VAR 0 1
18404: PPUSH
18405: CALL_OW 251
18409: ADD
18410: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
18411: LD_ADDR_EXP 13
18415: PUSH
18416: LD_EXP 13
18420: PUSH
18421: LD_VAR 0 1
18425: PPUSH
18426: CALL_OW 254
18430: ADD
18431: ST_TO_ADDR
// end ; if un in ru_attack_list then
18432: LD_VAR 0 1
18436: PUSH
18437: LD_EXP 10
18441: IN
18442: IFFALSE 18460
// ru_attack_list := ru_attack_list diff un ;
18444: LD_ADDR_EXP 10
18448: PUSH
18449: LD_EXP 10
18453: PUSH
18454: LD_VAR 0 1
18458: DIFF
18459: ST_TO_ADDR
// if un in ru_protector then
18460: LD_VAR 0 1
18464: PUSH
18465: LD_EXP 17
18469: IN
18470: IFFALSE 18488
// ru_protector := ru_protector diff un ;
18472: LD_ADDR_EXP 17
18476: PUSH
18477: LD_EXP 17
18481: PUSH
18482: LD_VAR 0 1
18486: DIFF
18487: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
18488: LD_VAR 0 1
18492: PPUSH
18493: CALL_OW 266
18497: PUSH
18498: LD_INT 30
18500: EQUAL
18501: PUSH
18502: LD_VAR 0 1
18506: PPUSH
18507: CALL_OW 255
18511: PUSH
18512: LD_INT 1
18514: EQUAL
18515: AND
18516: IFFALSE 18526
// mine_ck := true ;
18518: LD_ADDR_EXP 35
18522: PUSH
18523: LD_INT 1
18525: ST_TO_ADDR
// end ;
18526: PPOPN 1
18528: END
// on BuildingComplete ( un ) do var i ;
18529: LD_INT 0
18531: PPUSH
// begin if GetSide ( un ) = 1 and GetBType ( un ) = b_depot then
18532: LD_VAR 0 1
18536: PPUSH
18537: CALL_OW 255
18541: PUSH
18542: LD_INT 1
18544: EQUAL
18545: PUSH
18546: LD_VAR 0 1
18550: PPUSH
18551: CALL_OW 266
18555: PUSH
18556: LD_INT 0
18558: EQUAL
18559: AND
18560: IFFALSE 18570
// depotConstructed := true ;
18562: LD_ADDR_EXP 2
18566: PUSH
18567: LD_INT 1
18569: ST_TO_ADDR
// if GetSide ( un ) = 1 and GetBType ( un ) = b_siberite_mine then
18570: LD_VAR 0 1
18574: PPUSH
18575: CALL_OW 255
18579: PUSH
18580: LD_INT 1
18582: EQUAL
18583: PUSH
18584: LD_VAR 0 1
18588: PPUSH
18589: CALL_OW 266
18593: PUSH
18594: LD_INT 30
18596: EQUAL
18597: AND
18598: IFFALSE 18608
// mine_constructed := true ;
18600: LD_ADDR_EXP 37
18604: PUSH
18605: LD_INT 1
18607: ST_TO_ADDR
// if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
18608: LD_VAR 0 1
18612: PPUSH
18613: CALL_OW 255
18617: PUSH
18618: LD_INT 3
18620: EQUAL
18621: PUSH
18622: LD_VAR 0 1
18626: PPUSH
18627: CALL_OW 266
18631: PUSH
18632: LD_INT 0
18634: EQUAL
18635: AND
18636: IFFALSE 18693
// begin for i = 1 to 2 do
18638: LD_ADDR_VAR 0 2
18642: PUSH
18643: DOUBLE
18644: LD_INT 1
18646: DEC
18647: ST_TO_ADDR
18648: LD_INT 2
18650: PUSH
18651: FOR_TO
18652: IFFALSE 18691
// begin ComExitBuilding ( ru_sold [ i ] ) ;
18654: LD_EXP 20
18658: PUSH
18659: LD_VAR 0 2
18663: ARRAY
18664: PPUSH
18665: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
18669: LD_EXP 20
18673: PUSH
18674: LD_VAR 0 2
18678: ARRAY
18679: PPUSH
18680: LD_VAR 0 1
18684: PPUSH
18685: CALL_OW 180
// end ;
18689: GO 18651
18691: POP
18692: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
18693: LD_VAR 0 1
18697: PPUSH
18698: CALL_OW 255
18702: PUSH
18703: LD_INT 3
18705: EQUAL
18706: PUSH
18707: LD_VAR 0 1
18711: PPUSH
18712: CALL_OW 266
18716: PUSH
18717: LD_EXP 13
18721: IN
18722: AND
18723: IFFALSE 18763
// for i = 1 to 4 do
18725: LD_ADDR_VAR 0 2
18729: PUSH
18730: DOUBLE
18731: LD_INT 1
18733: DEC
18734: ST_TO_ADDR
18735: LD_INT 4
18737: PUSH
18738: FOR_TO
18739: IFFALSE 18761
// ru_blist := Delete ( ru_blist , 1 ) ;
18741: LD_ADDR_EXP 13
18745: PUSH
18746: LD_EXP 13
18750: PPUSH
18751: LD_INT 1
18753: PPUSH
18754: CALL_OW 3
18758: ST_TO_ADDR
18759: GO 18738
18761: POP
18762: POP
// end ;
18763: PPOPN 2
18765: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
18766: LD_VAR 0 1
18770: PPUSH
18771: LD_VAR 0 2
18775: PPUSH
18776: LD_VAR 0 3
18780: PPUSH
18781: CALL 30065 0 3
// end ;
18785: PPOPN 3
18787: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18788: LD_VAR 0 1
18792: PPUSH
18793: CALL 30073 0 1
// end ; end_of_file
18797: PPOPN 1
18799: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18800: GO 18802
18802: DISABLE
// begin ru_radar := 98 ;
18803: LD_ADDR_EXP 43
18807: PUSH
18808: LD_INT 98
18810: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18811: LD_ADDR_EXP 44
18815: PUSH
18816: LD_INT 89
18818: ST_TO_ADDR
// us_hack := 99 ;
18819: LD_ADDR_EXP 45
18823: PUSH
18824: LD_INT 99
18826: ST_TO_ADDR
// us_artillery := 97 ;
18827: LD_ADDR_EXP 46
18831: PUSH
18832: LD_INT 97
18834: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18835: LD_ADDR_EXP 47
18839: PUSH
18840: LD_INT 91
18842: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
18843: LD_ADDR_EXP 48
18847: PUSH
18848: LD_INT 92
18850: ST_TO_ADDR
// tech_Artillery := 80 ;
18851: LD_ADDR_EXP 49
18855: PUSH
18856: LD_INT 80
18858: ST_TO_ADDR
// tech_RadMat := 81 ;
18859: LD_ADDR_EXP 50
18863: PUSH
18864: LD_INT 81
18866: ST_TO_ADDR
// tech_BasicTools := 82 ;
18867: LD_ADDR_EXP 51
18871: PUSH
18872: LD_INT 82
18874: ST_TO_ADDR
// tech_Cargo := 83 ;
18875: LD_ADDR_EXP 52
18879: PUSH
18880: LD_INT 83
18882: ST_TO_ADDR
// tech_Track := 84 ;
18883: LD_ADDR_EXP 53
18887: PUSH
18888: LD_INT 84
18890: ST_TO_ADDR
// tech_Crane := 85 ;
18891: LD_ADDR_EXP 54
18895: PUSH
18896: LD_INT 85
18898: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18899: LD_ADDR_EXP 55
18903: PUSH
18904: LD_INT 86
18906: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18907: LD_ADDR_EXP 56
18911: PUSH
18912: LD_INT 87
18914: ST_TO_ADDR
// end ; end_of_file end_of_file
18915: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18916: GO 18918
18918: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18919: LD_STRING initStreamRollete();
18921: PPUSH
18922: CALL_OW 559
// InitStreamMode ;
18926: CALL 18935 0 0
// DefineStreamItems ( ) ;
18930: CALL 19375 0 0
// end ;
18934: END
// function InitStreamMode ; begin
18935: LD_INT 0
18937: PPUSH
// streamModeActive := false ;
18938: LD_ADDR_EXP 57
18942: PUSH
18943: LD_INT 0
18945: ST_TO_ADDR
// normalCounter := 36 ;
18946: LD_ADDR_EXP 58
18950: PUSH
18951: LD_INT 36
18953: ST_TO_ADDR
// hardcoreCounter := 16 ;
18954: LD_ADDR_EXP 59
18958: PUSH
18959: LD_INT 16
18961: ST_TO_ADDR
// sRocket := false ;
18962: LD_ADDR_EXP 62
18966: PUSH
18967: LD_INT 0
18969: ST_TO_ADDR
// sSpeed := false ;
18970: LD_ADDR_EXP 61
18974: PUSH
18975: LD_INT 0
18977: ST_TO_ADDR
// sEngine := false ;
18978: LD_ADDR_EXP 63
18982: PUSH
18983: LD_INT 0
18985: ST_TO_ADDR
// sSpec := false ;
18986: LD_ADDR_EXP 60
18990: PUSH
18991: LD_INT 0
18993: ST_TO_ADDR
// sLevel := false ;
18994: LD_ADDR_EXP 64
18998: PUSH
18999: LD_INT 0
19001: ST_TO_ADDR
// sArmoury := false ;
19002: LD_ADDR_EXP 65
19006: PUSH
19007: LD_INT 0
19009: ST_TO_ADDR
// sRadar := false ;
19010: LD_ADDR_EXP 66
19014: PUSH
19015: LD_INT 0
19017: ST_TO_ADDR
// sBunker := false ;
19018: LD_ADDR_EXP 67
19022: PUSH
19023: LD_INT 0
19025: ST_TO_ADDR
// sHack := false ;
19026: LD_ADDR_EXP 68
19030: PUSH
19031: LD_INT 0
19033: ST_TO_ADDR
// sFire := false ;
19034: LD_ADDR_EXP 69
19038: PUSH
19039: LD_INT 0
19041: ST_TO_ADDR
// sRefresh := false ;
19042: LD_ADDR_EXP 70
19046: PUSH
19047: LD_INT 0
19049: ST_TO_ADDR
// sExp := false ;
19050: LD_ADDR_EXP 71
19054: PUSH
19055: LD_INT 0
19057: ST_TO_ADDR
// sDepot := false ;
19058: LD_ADDR_EXP 72
19062: PUSH
19063: LD_INT 0
19065: ST_TO_ADDR
// sFlag := false ;
19066: LD_ADDR_EXP 73
19070: PUSH
19071: LD_INT 0
19073: ST_TO_ADDR
// sKamikadze := false ;
19074: LD_ADDR_EXP 81
19078: PUSH
19079: LD_INT 0
19081: ST_TO_ADDR
// sTroll := false ;
19082: LD_ADDR_EXP 82
19086: PUSH
19087: LD_INT 0
19089: ST_TO_ADDR
// sSlow := false ;
19090: LD_ADDR_EXP 83
19094: PUSH
19095: LD_INT 0
19097: ST_TO_ADDR
// sLack := false ;
19098: LD_ADDR_EXP 84
19102: PUSH
19103: LD_INT 0
19105: ST_TO_ADDR
// sTank := false ;
19106: LD_ADDR_EXP 86
19110: PUSH
19111: LD_INT 0
19113: ST_TO_ADDR
// sRemote := false ;
19114: LD_ADDR_EXP 87
19118: PUSH
19119: LD_INT 0
19121: ST_TO_ADDR
// sPowell := false ;
19122: LD_ADDR_EXP 88
19126: PUSH
19127: LD_INT 0
19129: ST_TO_ADDR
// sTeleport := false ;
19130: LD_ADDR_EXP 91
19134: PUSH
19135: LD_INT 0
19137: ST_TO_ADDR
// sOilTower := false ;
19138: LD_ADDR_EXP 93
19142: PUSH
19143: LD_INT 0
19145: ST_TO_ADDR
// sShovel := false ;
19146: LD_ADDR_EXP 94
19150: PUSH
19151: LD_INT 0
19153: ST_TO_ADDR
// sSheik := false ;
19154: LD_ADDR_EXP 95
19158: PUSH
19159: LD_INT 0
19161: ST_TO_ADDR
// sEarthquake := false ;
19162: LD_ADDR_EXP 97
19166: PUSH
19167: LD_INT 0
19169: ST_TO_ADDR
// sAI := false ;
19170: LD_ADDR_EXP 98
19174: PUSH
19175: LD_INT 0
19177: ST_TO_ADDR
// sCargo := false ;
19178: LD_ADDR_EXP 101
19182: PUSH
19183: LD_INT 0
19185: ST_TO_ADDR
// sDLaser := false ;
19186: LD_ADDR_EXP 102
19190: PUSH
19191: LD_INT 0
19193: ST_TO_ADDR
// sExchange := false ;
19194: LD_ADDR_EXP 103
19198: PUSH
19199: LD_INT 0
19201: ST_TO_ADDR
// sFac := false ;
19202: LD_ADDR_EXP 104
19206: PUSH
19207: LD_INT 0
19209: ST_TO_ADDR
// sPower := false ;
19210: LD_ADDR_EXP 105
19214: PUSH
19215: LD_INT 0
19217: ST_TO_ADDR
// sRandom := false ;
19218: LD_ADDR_EXP 106
19222: PUSH
19223: LD_INT 0
19225: ST_TO_ADDR
// sShield := false ;
19226: LD_ADDR_EXP 107
19230: PUSH
19231: LD_INT 0
19233: ST_TO_ADDR
// sTime := false ;
19234: LD_ADDR_EXP 108
19238: PUSH
19239: LD_INT 0
19241: ST_TO_ADDR
// sTools := false ;
19242: LD_ADDR_EXP 109
19246: PUSH
19247: LD_INT 0
19249: ST_TO_ADDR
// sSold := false ;
19250: LD_ADDR_EXP 74
19254: PUSH
19255: LD_INT 0
19257: ST_TO_ADDR
// sDiff := false ;
19258: LD_ADDR_EXP 75
19262: PUSH
19263: LD_INT 0
19265: ST_TO_ADDR
// sFog := false ;
19266: LD_ADDR_EXP 78
19270: PUSH
19271: LD_INT 0
19273: ST_TO_ADDR
// sReset := false ;
19274: LD_ADDR_EXP 79
19278: PUSH
19279: LD_INT 0
19281: ST_TO_ADDR
// sSun := false ;
19282: LD_ADDR_EXP 80
19286: PUSH
19287: LD_INT 0
19289: ST_TO_ADDR
// sTiger := false ;
19290: LD_ADDR_EXP 76
19294: PUSH
19295: LD_INT 0
19297: ST_TO_ADDR
// sBomb := false ;
19298: LD_ADDR_EXP 77
19302: PUSH
19303: LD_INT 0
19305: ST_TO_ADDR
// sWound := false ;
19306: LD_ADDR_EXP 85
19310: PUSH
19311: LD_INT 0
19313: ST_TO_ADDR
// sBetray := false ;
19314: LD_ADDR_EXP 89
19318: PUSH
19319: LD_INT 0
19321: ST_TO_ADDR
// sContamin := false ;
19322: LD_ADDR_EXP 90
19326: PUSH
19327: LD_INT 0
19329: ST_TO_ADDR
// sOil := false ;
19330: LD_ADDR_EXP 92
19334: PUSH
19335: LD_INT 0
19337: ST_TO_ADDR
// sStu := false ;
19338: LD_ADDR_EXP 96
19342: PUSH
19343: LD_INT 0
19345: ST_TO_ADDR
// sBazooka := false ;
19346: LD_ADDR_EXP 99
19350: PUSH
19351: LD_INT 0
19353: ST_TO_ADDR
// sMortar := false ;
19354: LD_ADDR_EXP 100
19358: PUSH
19359: LD_INT 0
19361: ST_TO_ADDR
// sRanger := false ;
19362: LD_ADDR_EXP 110
19366: PUSH
19367: LD_INT 0
19369: ST_TO_ADDR
// end ;
19370: LD_VAR 0 1
19374: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19375: LD_INT 0
19377: PPUSH
19378: PPUSH
19379: PPUSH
19380: PPUSH
19381: PPUSH
// result := [ ] ;
19382: LD_ADDR_VAR 0 1
19386: PUSH
19387: EMPTY
19388: ST_TO_ADDR
// if campaign_id = 1 then
19389: LD_OWVAR 69
19393: PUSH
19394: LD_INT 1
19396: EQUAL
19397: IFFALSE 22335
// begin case mission_number of 1 :
19399: LD_OWVAR 70
19403: PUSH
19404: LD_INT 1
19406: DOUBLE
19407: EQUAL
19408: IFTRUE 19412
19410: GO 19476
19412: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19413: LD_ADDR_VAR 0 1
19417: PUSH
19418: LD_INT 2
19420: PUSH
19421: LD_INT 4
19423: PUSH
19424: LD_INT 11
19426: PUSH
19427: LD_INT 12
19429: PUSH
19430: LD_INT 15
19432: PUSH
19433: LD_INT 16
19435: PUSH
19436: LD_INT 22
19438: PUSH
19439: LD_INT 23
19441: PUSH
19442: LD_INT 26
19444: PUSH
19445: EMPTY
19446: LIST
19447: LIST
19448: LIST
19449: LIST
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: PUSH
19456: LD_INT 101
19458: PUSH
19459: LD_INT 102
19461: PUSH
19462: LD_INT 106
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: LIST
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: ST_TO_ADDR
19474: GO 22333
19476: LD_INT 2
19478: DOUBLE
19479: EQUAL
19480: IFTRUE 19484
19482: GO 19556
19484: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19485: LD_ADDR_VAR 0 1
19489: PUSH
19490: LD_INT 2
19492: PUSH
19493: LD_INT 4
19495: PUSH
19496: LD_INT 11
19498: PUSH
19499: LD_INT 12
19501: PUSH
19502: LD_INT 15
19504: PUSH
19505: LD_INT 16
19507: PUSH
19508: LD_INT 22
19510: PUSH
19511: LD_INT 23
19513: PUSH
19514: LD_INT 26
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: PUSH
19528: LD_INT 101
19530: PUSH
19531: LD_INT 102
19533: PUSH
19534: LD_INT 105
19536: PUSH
19537: LD_INT 106
19539: PUSH
19540: LD_INT 108
19542: PUSH
19543: EMPTY
19544: LIST
19545: LIST
19546: LIST
19547: LIST
19548: LIST
19549: PUSH
19550: EMPTY
19551: LIST
19552: LIST
19553: ST_TO_ADDR
19554: GO 22333
19556: LD_INT 3
19558: DOUBLE
19559: EQUAL
19560: IFTRUE 19564
19562: GO 19640
19564: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19565: LD_ADDR_VAR 0 1
19569: PUSH
19570: LD_INT 2
19572: PUSH
19573: LD_INT 4
19575: PUSH
19576: LD_INT 5
19578: PUSH
19579: LD_INT 11
19581: PUSH
19582: LD_INT 12
19584: PUSH
19585: LD_INT 15
19587: PUSH
19588: LD_INT 16
19590: PUSH
19591: LD_INT 22
19593: PUSH
19594: LD_INT 26
19596: PUSH
19597: LD_INT 36
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: LIST
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: LIST
19609: LIST
19610: LIST
19611: PUSH
19612: LD_INT 101
19614: PUSH
19615: LD_INT 102
19617: PUSH
19618: LD_INT 105
19620: PUSH
19621: LD_INT 106
19623: PUSH
19624: LD_INT 108
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: ST_TO_ADDR
19638: GO 22333
19640: LD_INT 4
19642: DOUBLE
19643: EQUAL
19644: IFTRUE 19648
19646: GO 19732
19648: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19649: LD_ADDR_VAR 0 1
19653: PUSH
19654: LD_INT 2
19656: PUSH
19657: LD_INT 4
19659: PUSH
19660: LD_INT 5
19662: PUSH
19663: LD_INT 8
19665: PUSH
19666: LD_INT 11
19668: PUSH
19669: LD_INT 12
19671: PUSH
19672: LD_INT 15
19674: PUSH
19675: LD_INT 16
19677: PUSH
19678: LD_INT 22
19680: PUSH
19681: LD_INT 23
19683: PUSH
19684: LD_INT 26
19686: PUSH
19687: LD_INT 36
19689: PUSH
19690: EMPTY
19691: LIST
19692: LIST
19693: LIST
19694: LIST
19695: LIST
19696: LIST
19697: LIST
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: LIST
19703: PUSH
19704: LD_INT 101
19706: PUSH
19707: LD_INT 102
19709: PUSH
19710: LD_INT 105
19712: PUSH
19713: LD_INT 106
19715: PUSH
19716: LD_INT 108
19718: PUSH
19719: EMPTY
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: PUSH
19726: EMPTY
19727: LIST
19728: LIST
19729: ST_TO_ADDR
19730: GO 22333
19732: LD_INT 5
19734: DOUBLE
19735: EQUAL
19736: IFTRUE 19740
19738: GO 19840
19740: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_INT 2
19748: PUSH
19749: LD_INT 4
19751: PUSH
19752: LD_INT 5
19754: PUSH
19755: LD_INT 6
19757: PUSH
19758: LD_INT 8
19760: PUSH
19761: LD_INT 11
19763: PUSH
19764: LD_INT 12
19766: PUSH
19767: LD_INT 15
19769: PUSH
19770: LD_INT 16
19772: PUSH
19773: LD_INT 22
19775: PUSH
19776: LD_INT 23
19778: PUSH
19779: LD_INT 25
19781: PUSH
19782: LD_INT 26
19784: PUSH
19785: LD_INT 36
19787: PUSH
19788: EMPTY
19789: LIST
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: LIST
19795: LIST
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: LIST
19801: LIST
19802: LIST
19803: PUSH
19804: LD_INT 101
19806: PUSH
19807: LD_INT 102
19809: PUSH
19810: LD_INT 105
19812: PUSH
19813: LD_INT 106
19815: PUSH
19816: LD_INT 108
19818: PUSH
19819: LD_INT 109
19821: PUSH
19822: LD_INT 112
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: LIST
19829: LIST
19830: LIST
19831: LIST
19832: LIST
19833: PUSH
19834: EMPTY
19835: LIST
19836: LIST
19837: ST_TO_ADDR
19838: GO 22333
19840: LD_INT 6
19842: DOUBLE
19843: EQUAL
19844: IFTRUE 19848
19846: GO 19968
19848: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19849: LD_ADDR_VAR 0 1
19853: PUSH
19854: LD_INT 2
19856: PUSH
19857: LD_INT 4
19859: PUSH
19860: LD_INT 5
19862: PUSH
19863: LD_INT 6
19865: PUSH
19866: LD_INT 8
19868: PUSH
19869: LD_INT 11
19871: PUSH
19872: LD_INT 12
19874: PUSH
19875: LD_INT 15
19877: PUSH
19878: LD_INT 16
19880: PUSH
19881: LD_INT 20
19883: PUSH
19884: LD_INT 21
19886: PUSH
19887: LD_INT 22
19889: PUSH
19890: LD_INT 23
19892: PUSH
19893: LD_INT 25
19895: PUSH
19896: LD_INT 26
19898: PUSH
19899: LD_INT 30
19901: PUSH
19902: LD_INT 31
19904: PUSH
19905: LD_INT 32
19907: PUSH
19908: LD_INT 36
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: LIST
19915: LIST
19916: LIST
19917: LIST
19918: LIST
19919: LIST
19920: LIST
19921: LIST
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: LIST
19927: LIST
19928: LIST
19929: LIST
19930: LIST
19931: PUSH
19932: LD_INT 101
19934: PUSH
19935: LD_INT 102
19937: PUSH
19938: LD_INT 105
19940: PUSH
19941: LD_INT 106
19943: PUSH
19944: LD_INT 108
19946: PUSH
19947: LD_INT 109
19949: PUSH
19950: LD_INT 112
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: PUSH
19962: EMPTY
19963: LIST
19964: LIST
19965: ST_TO_ADDR
19966: GO 22333
19968: LD_INT 7
19970: DOUBLE
19971: EQUAL
19972: IFTRUE 19976
19974: GO 20076
19976: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19977: LD_ADDR_VAR 0 1
19981: PUSH
19982: LD_INT 2
19984: PUSH
19985: LD_INT 4
19987: PUSH
19988: LD_INT 5
19990: PUSH
19991: LD_INT 7
19993: PUSH
19994: LD_INT 11
19996: PUSH
19997: LD_INT 12
19999: PUSH
20000: LD_INT 15
20002: PUSH
20003: LD_INT 16
20005: PUSH
20006: LD_INT 20
20008: PUSH
20009: LD_INT 21
20011: PUSH
20012: LD_INT 22
20014: PUSH
20015: LD_INT 23
20017: PUSH
20018: LD_INT 25
20020: PUSH
20021: LD_INT 26
20023: PUSH
20024: EMPTY
20025: LIST
20026: LIST
20027: LIST
20028: LIST
20029: LIST
20030: LIST
20031: LIST
20032: LIST
20033: LIST
20034: LIST
20035: LIST
20036: LIST
20037: LIST
20038: LIST
20039: PUSH
20040: LD_INT 101
20042: PUSH
20043: LD_INT 102
20045: PUSH
20046: LD_INT 103
20048: PUSH
20049: LD_INT 105
20051: PUSH
20052: LD_INT 106
20054: PUSH
20055: LD_INT 108
20057: PUSH
20058: LD_INT 112
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: LIST
20065: LIST
20066: LIST
20067: LIST
20068: LIST
20069: PUSH
20070: EMPTY
20071: LIST
20072: LIST
20073: ST_TO_ADDR
20074: GO 22333
20076: LD_INT 8
20078: DOUBLE
20079: EQUAL
20080: IFTRUE 20084
20082: GO 20212
20084: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
20085: LD_ADDR_VAR 0 1
20089: PUSH
20090: LD_INT 2
20092: PUSH
20093: LD_INT 4
20095: PUSH
20096: LD_INT 5
20098: PUSH
20099: LD_INT 6
20101: PUSH
20102: LD_INT 7
20104: PUSH
20105: LD_INT 8
20107: PUSH
20108: LD_INT 11
20110: PUSH
20111: LD_INT 12
20113: PUSH
20114: LD_INT 15
20116: PUSH
20117: LD_INT 16
20119: PUSH
20120: LD_INT 20
20122: PUSH
20123: LD_INT 21
20125: PUSH
20126: LD_INT 22
20128: PUSH
20129: LD_INT 23
20131: PUSH
20132: LD_INT 25
20134: PUSH
20135: LD_INT 26
20137: PUSH
20138: LD_INT 30
20140: PUSH
20141: LD_INT 31
20143: PUSH
20144: LD_INT 32
20146: PUSH
20147: LD_INT 36
20149: PUSH
20150: EMPTY
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: PUSH
20172: LD_INT 101
20174: PUSH
20175: LD_INT 102
20177: PUSH
20178: LD_INT 103
20180: PUSH
20181: LD_INT 105
20183: PUSH
20184: LD_INT 106
20186: PUSH
20187: LD_INT 108
20189: PUSH
20190: LD_INT 109
20192: PUSH
20193: LD_INT 112
20195: PUSH
20196: EMPTY
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: PUSH
20206: EMPTY
20207: LIST
20208: LIST
20209: ST_TO_ADDR
20210: GO 22333
20212: LD_INT 9
20214: DOUBLE
20215: EQUAL
20216: IFTRUE 20220
20218: GO 20356
20220: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
20221: LD_ADDR_VAR 0 1
20225: PUSH
20226: LD_INT 2
20228: PUSH
20229: LD_INT 4
20231: PUSH
20232: LD_INT 5
20234: PUSH
20235: LD_INT 6
20237: PUSH
20238: LD_INT 7
20240: PUSH
20241: LD_INT 8
20243: PUSH
20244: LD_INT 11
20246: PUSH
20247: LD_INT 12
20249: PUSH
20250: LD_INT 15
20252: PUSH
20253: LD_INT 16
20255: PUSH
20256: LD_INT 20
20258: PUSH
20259: LD_INT 21
20261: PUSH
20262: LD_INT 22
20264: PUSH
20265: LD_INT 23
20267: PUSH
20268: LD_INT 25
20270: PUSH
20271: LD_INT 26
20273: PUSH
20274: LD_INT 28
20276: PUSH
20277: LD_INT 30
20279: PUSH
20280: LD_INT 31
20282: PUSH
20283: LD_INT 32
20285: PUSH
20286: LD_INT 36
20288: PUSH
20289: EMPTY
20290: LIST
20291: LIST
20292: LIST
20293: LIST
20294: LIST
20295: LIST
20296: LIST
20297: LIST
20298: LIST
20299: LIST
20300: LIST
20301: LIST
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: LIST
20307: LIST
20308: LIST
20309: LIST
20310: LIST
20311: PUSH
20312: LD_INT 101
20314: PUSH
20315: LD_INT 102
20317: PUSH
20318: LD_INT 103
20320: PUSH
20321: LD_INT 105
20323: PUSH
20324: LD_INT 106
20326: PUSH
20327: LD_INT 108
20329: PUSH
20330: LD_INT 109
20332: PUSH
20333: LD_INT 112
20335: PUSH
20336: LD_INT 114
20338: PUSH
20339: EMPTY
20340: LIST
20341: LIST
20342: LIST
20343: LIST
20344: LIST
20345: LIST
20346: LIST
20347: LIST
20348: LIST
20349: PUSH
20350: EMPTY
20351: LIST
20352: LIST
20353: ST_TO_ADDR
20354: GO 22333
20356: LD_INT 10
20358: DOUBLE
20359: EQUAL
20360: IFTRUE 20364
20362: GO 20548
20364: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20365: LD_ADDR_VAR 0 1
20369: PUSH
20370: LD_INT 2
20372: PUSH
20373: LD_INT 4
20375: PUSH
20376: LD_INT 5
20378: PUSH
20379: LD_INT 6
20381: PUSH
20382: LD_INT 7
20384: PUSH
20385: LD_INT 8
20387: PUSH
20388: LD_INT 9
20390: PUSH
20391: LD_INT 10
20393: PUSH
20394: LD_INT 11
20396: PUSH
20397: LD_INT 12
20399: PUSH
20400: LD_INT 13
20402: PUSH
20403: LD_INT 14
20405: PUSH
20406: LD_INT 15
20408: PUSH
20409: LD_INT 16
20411: PUSH
20412: LD_INT 17
20414: PUSH
20415: LD_INT 18
20417: PUSH
20418: LD_INT 19
20420: PUSH
20421: LD_INT 20
20423: PUSH
20424: LD_INT 21
20426: PUSH
20427: LD_INT 22
20429: PUSH
20430: LD_INT 23
20432: PUSH
20433: LD_INT 24
20435: PUSH
20436: LD_INT 25
20438: PUSH
20439: LD_INT 26
20441: PUSH
20442: LD_INT 28
20444: PUSH
20445: LD_INT 30
20447: PUSH
20448: LD_INT 31
20450: PUSH
20451: LD_INT 32
20453: PUSH
20454: LD_INT 36
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: LIST
20461: LIST
20462: LIST
20463: LIST
20464: LIST
20465: LIST
20466: LIST
20467: LIST
20468: LIST
20469: LIST
20470: LIST
20471: LIST
20472: LIST
20473: LIST
20474: LIST
20475: LIST
20476: LIST
20477: LIST
20478: LIST
20479: LIST
20480: LIST
20481: LIST
20482: LIST
20483: LIST
20484: LIST
20485: LIST
20486: LIST
20487: PUSH
20488: LD_INT 101
20490: PUSH
20491: LD_INT 102
20493: PUSH
20494: LD_INT 103
20496: PUSH
20497: LD_INT 104
20499: PUSH
20500: LD_INT 105
20502: PUSH
20503: LD_INT 106
20505: PUSH
20506: LD_INT 107
20508: PUSH
20509: LD_INT 108
20511: PUSH
20512: LD_INT 109
20514: PUSH
20515: LD_INT 110
20517: PUSH
20518: LD_INT 111
20520: PUSH
20521: LD_INT 112
20523: PUSH
20524: LD_INT 114
20526: PUSH
20527: EMPTY
20528: LIST
20529: LIST
20530: LIST
20531: LIST
20532: LIST
20533: LIST
20534: LIST
20535: LIST
20536: LIST
20537: LIST
20538: LIST
20539: LIST
20540: LIST
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: ST_TO_ADDR
20546: GO 22333
20548: LD_INT 11
20550: DOUBLE
20551: EQUAL
20552: IFTRUE 20556
20554: GO 20748
20556: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20557: LD_ADDR_VAR 0 1
20561: PUSH
20562: LD_INT 2
20564: PUSH
20565: LD_INT 3
20567: PUSH
20568: LD_INT 4
20570: PUSH
20571: LD_INT 5
20573: PUSH
20574: LD_INT 6
20576: PUSH
20577: LD_INT 7
20579: PUSH
20580: LD_INT 8
20582: PUSH
20583: LD_INT 9
20585: PUSH
20586: LD_INT 10
20588: PUSH
20589: LD_INT 11
20591: PUSH
20592: LD_INT 12
20594: PUSH
20595: LD_INT 13
20597: PUSH
20598: LD_INT 14
20600: PUSH
20601: LD_INT 15
20603: PUSH
20604: LD_INT 16
20606: PUSH
20607: LD_INT 17
20609: PUSH
20610: LD_INT 18
20612: PUSH
20613: LD_INT 19
20615: PUSH
20616: LD_INT 20
20618: PUSH
20619: LD_INT 21
20621: PUSH
20622: LD_INT 22
20624: PUSH
20625: LD_INT 23
20627: PUSH
20628: LD_INT 24
20630: PUSH
20631: LD_INT 25
20633: PUSH
20634: LD_INT 26
20636: PUSH
20637: LD_INT 28
20639: PUSH
20640: LD_INT 30
20642: PUSH
20643: LD_INT 31
20645: PUSH
20646: LD_INT 32
20648: PUSH
20649: LD_INT 34
20651: PUSH
20652: LD_INT 36
20654: PUSH
20655: EMPTY
20656: LIST
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: LIST
20671: LIST
20672: LIST
20673: LIST
20674: LIST
20675: LIST
20676: LIST
20677: LIST
20678: LIST
20679: LIST
20680: LIST
20681: LIST
20682: LIST
20683: LIST
20684: LIST
20685: LIST
20686: LIST
20687: PUSH
20688: LD_INT 101
20690: PUSH
20691: LD_INT 102
20693: PUSH
20694: LD_INT 103
20696: PUSH
20697: LD_INT 104
20699: PUSH
20700: LD_INT 105
20702: PUSH
20703: LD_INT 106
20705: PUSH
20706: LD_INT 107
20708: PUSH
20709: LD_INT 108
20711: PUSH
20712: LD_INT 109
20714: PUSH
20715: LD_INT 110
20717: PUSH
20718: LD_INT 111
20720: PUSH
20721: LD_INT 112
20723: PUSH
20724: LD_INT 114
20726: PUSH
20727: EMPTY
20728: LIST
20729: LIST
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: LIST
20735: LIST
20736: LIST
20737: LIST
20738: LIST
20739: LIST
20740: LIST
20741: PUSH
20742: EMPTY
20743: LIST
20744: LIST
20745: ST_TO_ADDR
20746: GO 22333
20748: LD_INT 12
20750: DOUBLE
20751: EQUAL
20752: IFTRUE 20756
20754: GO 20964
20756: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20757: LD_ADDR_VAR 0 1
20761: PUSH
20762: LD_INT 1
20764: PUSH
20765: LD_INT 2
20767: PUSH
20768: LD_INT 3
20770: PUSH
20771: LD_INT 4
20773: PUSH
20774: LD_INT 5
20776: PUSH
20777: LD_INT 6
20779: PUSH
20780: LD_INT 7
20782: PUSH
20783: LD_INT 8
20785: PUSH
20786: LD_INT 9
20788: PUSH
20789: LD_INT 10
20791: PUSH
20792: LD_INT 11
20794: PUSH
20795: LD_INT 12
20797: PUSH
20798: LD_INT 13
20800: PUSH
20801: LD_INT 14
20803: PUSH
20804: LD_INT 15
20806: PUSH
20807: LD_INT 16
20809: PUSH
20810: LD_INT 17
20812: PUSH
20813: LD_INT 18
20815: PUSH
20816: LD_INT 19
20818: PUSH
20819: LD_INT 20
20821: PUSH
20822: LD_INT 21
20824: PUSH
20825: LD_INT 22
20827: PUSH
20828: LD_INT 23
20830: PUSH
20831: LD_INT 24
20833: PUSH
20834: LD_INT 25
20836: PUSH
20837: LD_INT 26
20839: PUSH
20840: LD_INT 27
20842: PUSH
20843: LD_INT 28
20845: PUSH
20846: LD_INT 30
20848: PUSH
20849: LD_INT 31
20851: PUSH
20852: LD_INT 32
20854: PUSH
20855: LD_INT 33
20857: PUSH
20858: LD_INT 34
20860: PUSH
20861: LD_INT 36
20863: PUSH
20864: EMPTY
20865: LIST
20866: LIST
20867: LIST
20868: LIST
20869: LIST
20870: LIST
20871: LIST
20872: LIST
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: LIST
20878: LIST
20879: LIST
20880: LIST
20881: LIST
20882: LIST
20883: LIST
20884: LIST
20885: LIST
20886: LIST
20887: LIST
20888: LIST
20889: LIST
20890: LIST
20891: LIST
20892: LIST
20893: LIST
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: PUSH
20900: LD_INT 101
20902: PUSH
20903: LD_INT 102
20905: PUSH
20906: LD_INT 103
20908: PUSH
20909: LD_INT 104
20911: PUSH
20912: LD_INT 105
20914: PUSH
20915: LD_INT 106
20917: PUSH
20918: LD_INT 107
20920: PUSH
20921: LD_INT 108
20923: PUSH
20924: LD_INT 109
20926: PUSH
20927: LD_INT 110
20929: PUSH
20930: LD_INT 111
20932: PUSH
20933: LD_INT 112
20935: PUSH
20936: LD_INT 113
20938: PUSH
20939: LD_INT 114
20941: PUSH
20942: EMPTY
20943: LIST
20944: LIST
20945: LIST
20946: LIST
20947: LIST
20948: LIST
20949: LIST
20950: LIST
20951: LIST
20952: LIST
20953: LIST
20954: LIST
20955: LIST
20956: LIST
20957: PUSH
20958: EMPTY
20959: LIST
20960: LIST
20961: ST_TO_ADDR
20962: GO 22333
20964: LD_INT 13
20966: DOUBLE
20967: EQUAL
20968: IFTRUE 20972
20970: GO 21168
20972: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20973: LD_ADDR_VAR 0 1
20977: PUSH
20978: LD_INT 1
20980: PUSH
20981: LD_INT 2
20983: PUSH
20984: LD_INT 3
20986: PUSH
20987: LD_INT 4
20989: PUSH
20990: LD_INT 5
20992: PUSH
20993: LD_INT 8
20995: PUSH
20996: LD_INT 9
20998: PUSH
20999: LD_INT 10
21001: PUSH
21002: LD_INT 11
21004: PUSH
21005: LD_INT 12
21007: PUSH
21008: LD_INT 14
21010: PUSH
21011: LD_INT 15
21013: PUSH
21014: LD_INT 16
21016: PUSH
21017: LD_INT 17
21019: PUSH
21020: LD_INT 18
21022: PUSH
21023: LD_INT 19
21025: PUSH
21026: LD_INT 20
21028: PUSH
21029: LD_INT 21
21031: PUSH
21032: LD_INT 22
21034: PUSH
21035: LD_INT 23
21037: PUSH
21038: LD_INT 24
21040: PUSH
21041: LD_INT 25
21043: PUSH
21044: LD_INT 26
21046: PUSH
21047: LD_INT 27
21049: PUSH
21050: LD_INT 28
21052: PUSH
21053: LD_INT 30
21055: PUSH
21056: LD_INT 31
21058: PUSH
21059: LD_INT 32
21061: PUSH
21062: LD_INT 33
21064: PUSH
21065: LD_INT 34
21067: PUSH
21068: LD_INT 36
21070: PUSH
21071: EMPTY
21072: LIST
21073: LIST
21074: LIST
21075: LIST
21076: LIST
21077: LIST
21078: LIST
21079: LIST
21080: LIST
21081: LIST
21082: LIST
21083: LIST
21084: LIST
21085: LIST
21086: LIST
21087: LIST
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: LIST
21093: LIST
21094: LIST
21095: LIST
21096: LIST
21097: LIST
21098: LIST
21099: LIST
21100: LIST
21101: LIST
21102: LIST
21103: PUSH
21104: LD_INT 101
21106: PUSH
21107: LD_INT 102
21109: PUSH
21110: LD_INT 103
21112: PUSH
21113: LD_INT 104
21115: PUSH
21116: LD_INT 105
21118: PUSH
21119: LD_INT 106
21121: PUSH
21122: LD_INT 107
21124: PUSH
21125: LD_INT 108
21127: PUSH
21128: LD_INT 109
21130: PUSH
21131: LD_INT 110
21133: PUSH
21134: LD_INT 111
21136: PUSH
21137: LD_INT 112
21139: PUSH
21140: LD_INT 113
21142: PUSH
21143: LD_INT 114
21145: PUSH
21146: EMPTY
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: LIST
21160: LIST
21161: PUSH
21162: EMPTY
21163: LIST
21164: LIST
21165: ST_TO_ADDR
21166: GO 22333
21168: LD_INT 14
21170: DOUBLE
21171: EQUAL
21172: IFTRUE 21176
21174: GO 21388
21176: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
21177: LD_ADDR_VAR 0 1
21181: PUSH
21182: LD_INT 1
21184: PUSH
21185: LD_INT 2
21187: PUSH
21188: LD_INT 3
21190: PUSH
21191: LD_INT 4
21193: PUSH
21194: LD_INT 5
21196: PUSH
21197: LD_INT 6
21199: PUSH
21200: LD_INT 7
21202: PUSH
21203: LD_INT 8
21205: PUSH
21206: LD_INT 9
21208: PUSH
21209: LD_INT 10
21211: PUSH
21212: LD_INT 11
21214: PUSH
21215: LD_INT 12
21217: PUSH
21218: LD_INT 13
21220: PUSH
21221: LD_INT 14
21223: PUSH
21224: LD_INT 15
21226: PUSH
21227: LD_INT 16
21229: PUSH
21230: LD_INT 17
21232: PUSH
21233: LD_INT 18
21235: PUSH
21236: LD_INT 19
21238: PUSH
21239: LD_INT 20
21241: PUSH
21242: LD_INT 21
21244: PUSH
21245: LD_INT 22
21247: PUSH
21248: LD_INT 23
21250: PUSH
21251: LD_INT 24
21253: PUSH
21254: LD_INT 25
21256: PUSH
21257: LD_INT 26
21259: PUSH
21260: LD_INT 27
21262: PUSH
21263: LD_INT 28
21265: PUSH
21266: LD_INT 29
21268: PUSH
21269: LD_INT 30
21271: PUSH
21272: LD_INT 31
21274: PUSH
21275: LD_INT 32
21277: PUSH
21278: LD_INT 33
21280: PUSH
21281: LD_INT 34
21283: PUSH
21284: LD_INT 36
21286: PUSH
21287: EMPTY
21288: LIST
21289: LIST
21290: LIST
21291: LIST
21292: LIST
21293: LIST
21294: LIST
21295: LIST
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: LIST
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: LIST
21313: LIST
21314: LIST
21315: LIST
21316: LIST
21317: LIST
21318: LIST
21319: LIST
21320: LIST
21321: LIST
21322: LIST
21323: PUSH
21324: LD_INT 101
21326: PUSH
21327: LD_INT 102
21329: PUSH
21330: LD_INT 103
21332: PUSH
21333: LD_INT 104
21335: PUSH
21336: LD_INT 105
21338: PUSH
21339: LD_INT 106
21341: PUSH
21342: LD_INT 107
21344: PUSH
21345: LD_INT 108
21347: PUSH
21348: LD_INT 109
21350: PUSH
21351: LD_INT 110
21353: PUSH
21354: LD_INT 111
21356: PUSH
21357: LD_INT 112
21359: PUSH
21360: LD_INT 113
21362: PUSH
21363: LD_INT 114
21365: PUSH
21366: EMPTY
21367: LIST
21368: LIST
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: LIST
21379: LIST
21380: LIST
21381: PUSH
21382: EMPTY
21383: LIST
21384: LIST
21385: ST_TO_ADDR
21386: GO 22333
21388: LD_INT 15
21390: DOUBLE
21391: EQUAL
21392: IFTRUE 21396
21394: GO 21608
21396: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21397: LD_ADDR_VAR 0 1
21401: PUSH
21402: LD_INT 1
21404: PUSH
21405: LD_INT 2
21407: PUSH
21408: LD_INT 3
21410: PUSH
21411: LD_INT 4
21413: PUSH
21414: LD_INT 5
21416: PUSH
21417: LD_INT 6
21419: PUSH
21420: LD_INT 7
21422: PUSH
21423: LD_INT 8
21425: PUSH
21426: LD_INT 9
21428: PUSH
21429: LD_INT 10
21431: PUSH
21432: LD_INT 11
21434: PUSH
21435: LD_INT 12
21437: PUSH
21438: LD_INT 13
21440: PUSH
21441: LD_INT 14
21443: PUSH
21444: LD_INT 15
21446: PUSH
21447: LD_INT 16
21449: PUSH
21450: LD_INT 17
21452: PUSH
21453: LD_INT 18
21455: PUSH
21456: LD_INT 19
21458: PUSH
21459: LD_INT 20
21461: PUSH
21462: LD_INT 21
21464: PUSH
21465: LD_INT 22
21467: PUSH
21468: LD_INT 23
21470: PUSH
21471: LD_INT 24
21473: PUSH
21474: LD_INT 25
21476: PUSH
21477: LD_INT 26
21479: PUSH
21480: LD_INT 27
21482: PUSH
21483: LD_INT 28
21485: PUSH
21486: LD_INT 29
21488: PUSH
21489: LD_INT 30
21491: PUSH
21492: LD_INT 31
21494: PUSH
21495: LD_INT 32
21497: PUSH
21498: LD_INT 33
21500: PUSH
21501: LD_INT 34
21503: PUSH
21504: LD_INT 36
21506: PUSH
21507: EMPTY
21508: LIST
21509: LIST
21510: LIST
21511: LIST
21512: LIST
21513: LIST
21514: LIST
21515: LIST
21516: LIST
21517: LIST
21518: LIST
21519: LIST
21520: LIST
21521: LIST
21522: LIST
21523: LIST
21524: LIST
21525: LIST
21526: LIST
21527: LIST
21528: LIST
21529: LIST
21530: LIST
21531: LIST
21532: LIST
21533: LIST
21534: LIST
21535: LIST
21536: LIST
21537: LIST
21538: LIST
21539: LIST
21540: LIST
21541: LIST
21542: LIST
21543: PUSH
21544: LD_INT 101
21546: PUSH
21547: LD_INT 102
21549: PUSH
21550: LD_INT 103
21552: PUSH
21553: LD_INT 104
21555: PUSH
21556: LD_INT 105
21558: PUSH
21559: LD_INT 106
21561: PUSH
21562: LD_INT 107
21564: PUSH
21565: LD_INT 108
21567: PUSH
21568: LD_INT 109
21570: PUSH
21571: LD_INT 110
21573: PUSH
21574: LD_INT 111
21576: PUSH
21577: LD_INT 112
21579: PUSH
21580: LD_INT 113
21582: PUSH
21583: LD_INT 114
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: LIST
21590: LIST
21591: LIST
21592: LIST
21593: LIST
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: LIST
21599: LIST
21600: LIST
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: ST_TO_ADDR
21606: GO 22333
21608: LD_INT 16
21610: DOUBLE
21611: EQUAL
21612: IFTRUE 21616
21614: GO 21740
21616: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21617: LD_ADDR_VAR 0 1
21621: PUSH
21622: LD_INT 2
21624: PUSH
21625: LD_INT 4
21627: PUSH
21628: LD_INT 5
21630: PUSH
21631: LD_INT 7
21633: PUSH
21634: LD_INT 11
21636: PUSH
21637: LD_INT 12
21639: PUSH
21640: LD_INT 15
21642: PUSH
21643: LD_INT 16
21645: PUSH
21646: LD_INT 20
21648: PUSH
21649: LD_INT 21
21651: PUSH
21652: LD_INT 22
21654: PUSH
21655: LD_INT 23
21657: PUSH
21658: LD_INT 25
21660: PUSH
21661: LD_INT 26
21663: PUSH
21664: LD_INT 30
21666: PUSH
21667: LD_INT 31
21669: PUSH
21670: LD_INT 32
21672: PUSH
21673: LD_INT 33
21675: PUSH
21676: LD_INT 34
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: LIST
21683: LIST
21684: LIST
21685: LIST
21686: LIST
21687: LIST
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: LIST
21693: LIST
21694: LIST
21695: LIST
21696: LIST
21697: LIST
21698: LIST
21699: PUSH
21700: LD_INT 101
21702: PUSH
21703: LD_INT 102
21705: PUSH
21706: LD_INT 103
21708: PUSH
21709: LD_INT 106
21711: PUSH
21712: LD_INT 108
21714: PUSH
21715: LD_INT 112
21717: PUSH
21718: LD_INT 113
21720: PUSH
21721: LD_INT 114
21723: PUSH
21724: EMPTY
21725: LIST
21726: LIST
21727: LIST
21728: LIST
21729: LIST
21730: LIST
21731: LIST
21732: LIST
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: ST_TO_ADDR
21738: GO 22333
21740: LD_INT 17
21742: DOUBLE
21743: EQUAL
21744: IFTRUE 21748
21746: GO 21960
21748: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21749: LD_ADDR_VAR 0 1
21753: PUSH
21754: LD_INT 1
21756: PUSH
21757: LD_INT 2
21759: PUSH
21760: LD_INT 3
21762: PUSH
21763: LD_INT 4
21765: PUSH
21766: LD_INT 5
21768: PUSH
21769: LD_INT 6
21771: PUSH
21772: LD_INT 7
21774: PUSH
21775: LD_INT 8
21777: PUSH
21778: LD_INT 9
21780: PUSH
21781: LD_INT 10
21783: PUSH
21784: LD_INT 11
21786: PUSH
21787: LD_INT 12
21789: PUSH
21790: LD_INT 13
21792: PUSH
21793: LD_INT 14
21795: PUSH
21796: LD_INT 15
21798: PUSH
21799: LD_INT 16
21801: PUSH
21802: LD_INT 17
21804: PUSH
21805: LD_INT 18
21807: PUSH
21808: LD_INT 19
21810: PUSH
21811: LD_INT 20
21813: PUSH
21814: LD_INT 21
21816: PUSH
21817: LD_INT 22
21819: PUSH
21820: LD_INT 23
21822: PUSH
21823: LD_INT 24
21825: PUSH
21826: LD_INT 25
21828: PUSH
21829: LD_INT 26
21831: PUSH
21832: LD_INT 27
21834: PUSH
21835: LD_INT 28
21837: PUSH
21838: LD_INT 29
21840: PUSH
21841: LD_INT 30
21843: PUSH
21844: LD_INT 31
21846: PUSH
21847: LD_INT 32
21849: PUSH
21850: LD_INT 33
21852: PUSH
21853: LD_INT 34
21855: PUSH
21856: LD_INT 36
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: LIST
21863: LIST
21864: LIST
21865: LIST
21866: LIST
21867: LIST
21868: LIST
21869: LIST
21870: LIST
21871: LIST
21872: LIST
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: LIST
21878: LIST
21879: LIST
21880: LIST
21881: LIST
21882: LIST
21883: LIST
21884: LIST
21885: LIST
21886: LIST
21887: LIST
21888: LIST
21889: LIST
21890: LIST
21891: LIST
21892: LIST
21893: LIST
21894: LIST
21895: PUSH
21896: LD_INT 101
21898: PUSH
21899: LD_INT 102
21901: PUSH
21902: LD_INT 103
21904: PUSH
21905: LD_INT 104
21907: PUSH
21908: LD_INT 105
21910: PUSH
21911: LD_INT 106
21913: PUSH
21914: LD_INT 107
21916: PUSH
21917: LD_INT 108
21919: PUSH
21920: LD_INT 109
21922: PUSH
21923: LD_INT 110
21925: PUSH
21926: LD_INT 111
21928: PUSH
21929: LD_INT 112
21931: PUSH
21932: LD_INT 113
21934: PUSH
21935: LD_INT 114
21937: PUSH
21938: EMPTY
21939: LIST
21940: LIST
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: LIST
21948: LIST
21949: LIST
21950: LIST
21951: LIST
21952: LIST
21953: PUSH
21954: EMPTY
21955: LIST
21956: LIST
21957: ST_TO_ADDR
21958: GO 22333
21960: LD_INT 18
21962: DOUBLE
21963: EQUAL
21964: IFTRUE 21968
21966: GO 22104
21968: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21969: LD_ADDR_VAR 0 1
21973: PUSH
21974: LD_INT 2
21976: PUSH
21977: LD_INT 4
21979: PUSH
21980: LD_INT 5
21982: PUSH
21983: LD_INT 7
21985: PUSH
21986: LD_INT 11
21988: PUSH
21989: LD_INT 12
21991: PUSH
21992: LD_INT 15
21994: PUSH
21995: LD_INT 16
21997: PUSH
21998: LD_INT 20
22000: PUSH
22001: LD_INT 21
22003: PUSH
22004: LD_INT 22
22006: PUSH
22007: LD_INT 23
22009: PUSH
22010: LD_INT 25
22012: PUSH
22013: LD_INT 26
22015: PUSH
22016: LD_INT 30
22018: PUSH
22019: LD_INT 31
22021: PUSH
22022: LD_INT 32
22024: PUSH
22025: LD_INT 33
22027: PUSH
22028: LD_INT 34
22030: PUSH
22031: LD_INT 35
22033: PUSH
22034: LD_INT 36
22036: PUSH
22037: EMPTY
22038: LIST
22039: LIST
22040: LIST
22041: LIST
22042: LIST
22043: LIST
22044: LIST
22045: LIST
22046: LIST
22047: LIST
22048: LIST
22049: LIST
22050: LIST
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: LIST
22056: LIST
22057: LIST
22058: LIST
22059: PUSH
22060: LD_INT 101
22062: PUSH
22063: LD_INT 102
22065: PUSH
22066: LD_INT 103
22068: PUSH
22069: LD_INT 106
22071: PUSH
22072: LD_INT 108
22074: PUSH
22075: LD_INT 112
22077: PUSH
22078: LD_INT 113
22080: PUSH
22081: LD_INT 114
22083: PUSH
22084: LD_INT 115
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: LIST
22091: LIST
22092: LIST
22093: LIST
22094: LIST
22095: LIST
22096: LIST
22097: PUSH
22098: EMPTY
22099: LIST
22100: LIST
22101: ST_TO_ADDR
22102: GO 22333
22104: LD_INT 19
22106: DOUBLE
22107: EQUAL
22108: IFTRUE 22112
22110: GO 22332
22112: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
22113: LD_ADDR_VAR 0 1
22117: PUSH
22118: LD_INT 1
22120: PUSH
22121: LD_INT 2
22123: PUSH
22124: LD_INT 3
22126: PUSH
22127: LD_INT 4
22129: PUSH
22130: LD_INT 5
22132: PUSH
22133: LD_INT 6
22135: PUSH
22136: LD_INT 7
22138: PUSH
22139: LD_INT 8
22141: PUSH
22142: LD_INT 9
22144: PUSH
22145: LD_INT 10
22147: PUSH
22148: LD_INT 11
22150: PUSH
22151: LD_INT 12
22153: PUSH
22154: LD_INT 13
22156: PUSH
22157: LD_INT 14
22159: PUSH
22160: LD_INT 15
22162: PUSH
22163: LD_INT 16
22165: PUSH
22166: LD_INT 17
22168: PUSH
22169: LD_INT 18
22171: PUSH
22172: LD_INT 19
22174: PUSH
22175: LD_INT 20
22177: PUSH
22178: LD_INT 21
22180: PUSH
22181: LD_INT 22
22183: PUSH
22184: LD_INT 23
22186: PUSH
22187: LD_INT 24
22189: PUSH
22190: LD_INT 25
22192: PUSH
22193: LD_INT 26
22195: PUSH
22196: LD_INT 27
22198: PUSH
22199: LD_INT 28
22201: PUSH
22202: LD_INT 29
22204: PUSH
22205: LD_INT 30
22207: PUSH
22208: LD_INT 31
22210: PUSH
22211: LD_INT 32
22213: PUSH
22214: LD_INT 33
22216: PUSH
22217: LD_INT 34
22219: PUSH
22220: LD_INT 35
22222: PUSH
22223: LD_INT 36
22225: PUSH
22226: EMPTY
22227: LIST
22228: LIST
22229: LIST
22230: LIST
22231: LIST
22232: LIST
22233: LIST
22234: LIST
22235: LIST
22236: LIST
22237: LIST
22238: LIST
22239: LIST
22240: LIST
22241: LIST
22242: LIST
22243: LIST
22244: LIST
22245: LIST
22246: LIST
22247: LIST
22248: LIST
22249: LIST
22250: LIST
22251: LIST
22252: LIST
22253: LIST
22254: LIST
22255: LIST
22256: LIST
22257: LIST
22258: LIST
22259: LIST
22260: LIST
22261: LIST
22262: LIST
22263: PUSH
22264: LD_INT 101
22266: PUSH
22267: LD_INT 102
22269: PUSH
22270: LD_INT 103
22272: PUSH
22273: LD_INT 104
22275: PUSH
22276: LD_INT 105
22278: PUSH
22279: LD_INT 106
22281: PUSH
22282: LD_INT 107
22284: PUSH
22285: LD_INT 108
22287: PUSH
22288: LD_INT 109
22290: PUSH
22291: LD_INT 110
22293: PUSH
22294: LD_INT 111
22296: PUSH
22297: LD_INT 112
22299: PUSH
22300: LD_INT 113
22302: PUSH
22303: LD_INT 114
22305: PUSH
22306: LD_INT 115
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: LIST
22317: LIST
22318: LIST
22319: LIST
22320: LIST
22321: LIST
22322: LIST
22323: LIST
22324: LIST
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: ST_TO_ADDR
22330: GO 22333
22332: POP
// end else
22333: GO 22552
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
22335: LD_ADDR_VAR 0 1
22339: PUSH
22340: LD_INT 1
22342: PUSH
22343: LD_INT 2
22345: PUSH
22346: LD_INT 3
22348: PUSH
22349: LD_INT 4
22351: PUSH
22352: LD_INT 5
22354: PUSH
22355: LD_INT 6
22357: PUSH
22358: LD_INT 7
22360: PUSH
22361: LD_INT 8
22363: PUSH
22364: LD_INT 9
22366: PUSH
22367: LD_INT 10
22369: PUSH
22370: LD_INT 11
22372: PUSH
22373: LD_INT 12
22375: PUSH
22376: LD_INT 13
22378: PUSH
22379: LD_INT 14
22381: PUSH
22382: LD_INT 15
22384: PUSH
22385: LD_INT 16
22387: PUSH
22388: LD_INT 17
22390: PUSH
22391: LD_INT 18
22393: PUSH
22394: LD_INT 19
22396: PUSH
22397: LD_INT 20
22399: PUSH
22400: LD_INT 21
22402: PUSH
22403: LD_INT 22
22405: PUSH
22406: LD_INT 23
22408: PUSH
22409: LD_INT 24
22411: PUSH
22412: LD_INT 25
22414: PUSH
22415: LD_INT 26
22417: PUSH
22418: LD_INT 27
22420: PUSH
22421: LD_INT 28
22423: PUSH
22424: LD_INT 29
22426: PUSH
22427: LD_INT 30
22429: PUSH
22430: LD_INT 31
22432: PUSH
22433: LD_INT 32
22435: PUSH
22436: LD_INT 33
22438: PUSH
22439: LD_INT 34
22441: PUSH
22442: LD_INT 35
22444: PUSH
22445: LD_INT 36
22447: PUSH
22448: EMPTY
22449: LIST
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: LIST
22457: LIST
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: LIST
22467: LIST
22468: LIST
22469: LIST
22470: LIST
22471: LIST
22472: LIST
22473: LIST
22474: LIST
22475: LIST
22476: LIST
22477: LIST
22478: LIST
22479: LIST
22480: LIST
22481: LIST
22482: LIST
22483: LIST
22484: LIST
22485: PUSH
22486: LD_INT 101
22488: PUSH
22489: LD_INT 102
22491: PUSH
22492: LD_INT 103
22494: PUSH
22495: LD_INT 104
22497: PUSH
22498: LD_INT 105
22500: PUSH
22501: LD_INT 106
22503: PUSH
22504: LD_INT 107
22506: PUSH
22507: LD_INT 108
22509: PUSH
22510: LD_INT 109
22512: PUSH
22513: LD_INT 110
22515: PUSH
22516: LD_INT 111
22518: PUSH
22519: LD_INT 112
22521: PUSH
22522: LD_INT 113
22524: PUSH
22525: LD_INT 114
22527: PUSH
22528: LD_INT 115
22530: PUSH
22531: EMPTY
22532: LIST
22533: LIST
22534: LIST
22535: LIST
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: LIST
22543: LIST
22544: LIST
22545: LIST
22546: LIST
22547: PUSH
22548: EMPTY
22549: LIST
22550: LIST
22551: ST_TO_ADDR
// if result then
22552: LD_VAR 0 1
22556: IFFALSE 22845
// begin normal :=  ;
22558: LD_ADDR_VAR 0 3
22562: PUSH
22563: LD_STRING 
22565: ST_TO_ADDR
// hardcore :=  ;
22566: LD_ADDR_VAR 0 4
22570: PUSH
22571: LD_STRING 
22573: ST_TO_ADDR
// for i = 1 to normalCounter do
22574: LD_ADDR_VAR 0 5
22578: PUSH
22579: DOUBLE
22580: LD_INT 1
22582: DEC
22583: ST_TO_ADDR
22584: LD_EXP 58
22588: PUSH
22589: FOR_TO
22590: IFFALSE 22691
// begin tmp := 0 ;
22592: LD_ADDR_VAR 0 2
22596: PUSH
22597: LD_STRING 0
22599: ST_TO_ADDR
// if result [ 1 ] then
22600: LD_VAR 0 1
22604: PUSH
22605: LD_INT 1
22607: ARRAY
22608: IFFALSE 22673
// if result [ 1 ] [ 1 ] = i then
22610: LD_VAR 0 1
22614: PUSH
22615: LD_INT 1
22617: ARRAY
22618: PUSH
22619: LD_INT 1
22621: ARRAY
22622: PUSH
22623: LD_VAR 0 5
22627: EQUAL
22628: IFFALSE 22673
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22630: LD_ADDR_VAR 0 1
22634: PUSH
22635: LD_VAR 0 1
22639: PPUSH
22640: LD_INT 1
22642: PPUSH
22643: LD_VAR 0 1
22647: PUSH
22648: LD_INT 1
22650: ARRAY
22651: PPUSH
22652: LD_INT 1
22654: PPUSH
22655: CALL_OW 3
22659: PPUSH
22660: CALL_OW 1
22664: ST_TO_ADDR
// tmp := 1 ;
22665: LD_ADDR_VAR 0 2
22669: PUSH
22670: LD_STRING 1
22672: ST_TO_ADDR
// end ; normal := normal & tmp ;
22673: LD_ADDR_VAR 0 3
22677: PUSH
22678: LD_VAR 0 3
22682: PUSH
22683: LD_VAR 0 2
22687: STR
22688: ST_TO_ADDR
// end ;
22689: GO 22589
22691: POP
22692: POP
// for i = 1 to hardcoreCounter do
22693: LD_ADDR_VAR 0 5
22697: PUSH
22698: DOUBLE
22699: LD_INT 1
22701: DEC
22702: ST_TO_ADDR
22703: LD_EXP 59
22707: PUSH
22708: FOR_TO
22709: IFFALSE 22814
// begin tmp := 0 ;
22711: LD_ADDR_VAR 0 2
22715: PUSH
22716: LD_STRING 0
22718: ST_TO_ADDR
// if result [ 2 ] then
22719: LD_VAR 0 1
22723: PUSH
22724: LD_INT 2
22726: ARRAY
22727: IFFALSE 22796
// if result [ 2 ] [ 1 ] = 100 + i then
22729: LD_VAR 0 1
22733: PUSH
22734: LD_INT 2
22736: ARRAY
22737: PUSH
22738: LD_INT 1
22740: ARRAY
22741: PUSH
22742: LD_INT 100
22744: PUSH
22745: LD_VAR 0 5
22749: PLUS
22750: EQUAL
22751: IFFALSE 22796
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22753: LD_ADDR_VAR 0 1
22757: PUSH
22758: LD_VAR 0 1
22762: PPUSH
22763: LD_INT 2
22765: PPUSH
22766: LD_VAR 0 1
22770: PUSH
22771: LD_INT 2
22773: ARRAY
22774: PPUSH
22775: LD_INT 1
22777: PPUSH
22778: CALL_OW 3
22782: PPUSH
22783: CALL_OW 1
22787: ST_TO_ADDR
// tmp := 1 ;
22788: LD_ADDR_VAR 0 2
22792: PUSH
22793: LD_STRING 1
22795: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22796: LD_ADDR_VAR 0 4
22800: PUSH
22801: LD_VAR 0 4
22805: PUSH
22806: LD_VAR 0 2
22810: STR
22811: ST_TO_ADDR
// end ;
22812: GO 22708
22814: POP
22815: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22816: LD_STRING getStreamItemsFromMission("
22818: PUSH
22819: LD_VAR 0 3
22823: STR
22824: PUSH
22825: LD_STRING ","
22827: STR
22828: PUSH
22829: LD_VAR 0 4
22833: STR
22834: PUSH
22835: LD_STRING ")
22837: STR
22838: PPUSH
22839: CALL_OW 559
// end else
22843: GO 22852
// ToLua ( getStreamItemsFromMission("","") ) ;
22845: LD_STRING getStreamItemsFromMission("","")
22847: PPUSH
22848: CALL_OW 559
// end ;
22852: LD_VAR 0 1
22856: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22857: LD_VAR 0 2
22861: PUSH
22862: LD_INT 100
22864: EQUAL
22865: IFFALSE 23814
// begin if not StreamModeActive then
22867: LD_EXP 57
22871: NOT
22872: IFFALSE 22882
// StreamModeActive := true ;
22874: LD_ADDR_EXP 57
22878: PUSH
22879: LD_INT 1
22881: ST_TO_ADDR
// if p3 = 0 then
22882: LD_VAR 0 3
22886: PUSH
22887: LD_INT 0
22889: EQUAL
22890: IFFALSE 22896
// InitStreamMode ;
22892: CALL 18935 0 0
// if p3 = 1 then
22896: LD_VAR 0 3
22900: PUSH
22901: LD_INT 1
22903: EQUAL
22904: IFFALSE 22914
// sRocket := true ;
22906: LD_ADDR_EXP 62
22910: PUSH
22911: LD_INT 1
22913: ST_TO_ADDR
// if p3 = 2 then
22914: LD_VAR 0 3
22918: PUSH
22919: LD_INT 2
22921: EQUAL
22922: IFFALSE 22932
// sSpeed := true ;
22924: LD_ADDR_EXP 61
22928: PUSH
22929: LD_INT 1
22931: ST_TO_ADDR
// if p3 = 3 then
22932: LD_VAR 0 3
22936: PUSH
22937: LD_INT 3
22939: EQUAL
22940: IFFALSE 22950
// sEngine := true ;
22942: LD_ADDR_EXP 63
22946: PUSH
22947: LD_INT 1
22949: ST_TO_ADDR
// if p3 = 4 then
22950: LD_VAR 0 3
22954: PUSH
22955: LD_INT 4
22957: EQUAL
22958: IFFALSE 22968
// sSpec := true ;
22960: LD_ADDR_EXP 60
22964: PUSH
22965: LD_INT 1
22967: ST_TO_ADDR
// if p3 = 5 then
22968: LD_VAR 0 3
22972: PUSH
22973: LD_INT 5
22975: EQUAL
22976: IFFALSE 22986
// sLevel := true ;
22978: LD_ADDR_EXP 64
22982: PUSH
22983: LD_INT 1
22985: ST_TO_ADDR
// if p3 = 6 then
22986: LD_VAR 0 3
22990: PUSH
22991: LD_INT 6
22993: EQUAL
22994: IFFALSE 23004
// sArmoury := true ;
22996: LD_ADDR_EXP 65
23000: PUSH
23001: LD_INT 1
23003: ST_TO_ADDR
// if p3 = 7 then
23004: LD_VAR 0 3
23008: PUSH
23009: LD_INT 7
23011: EQUAL
23012: IFFALSE 23022
// sRadar := true ;
23014: LD_ADDR_EXP 66
23018: PUSH
23019: LD_INT 1
23021: ST_TO_ADDR
// if p3 = 8 then
23022: LD_VAR 0 3
23026: PUSH
23027: LD_INT 8
23029: EQUAL
23030: IFFALSE 23040
// sBunker := true ;
23032: LD_ADDR_EXP 67
23036: PUSH
23037: LD_INT 1
23039: ST_TO_ADDR
// if p3 = 9 then
23040: LD_VAR 0 3
23044: PUSH
23045: LD_INT 9
23047: EQUAL
23048: IFFALSE 23058
// sHack := true ;
23050: LD_ADDR_EXP 68
23054: PUSH
23055: LD_INT 1
23057: ST_TO_ADDR
// if p3 = 10 then
23058: LD_VAR 0 3
23062: PUSH
23063: LD_INT 10
23065: EQUAL
23066: IFFALSE 23076
// sFire := true ;
23068: LD_ADDR_EXP 69
23072: PUSH
23073: LD_INT 1
23075: ST_TO_ADDR
// if p3 = 11 then
23076: LD_VAR 0 3
23080: PUSH
23081: LD_INT 11
23083: EQUAL
23084: IFFALSE 23094
// sRefresh := true ;
23086: LD_ADDR_EXP 70
23090: PUSH
23091: LD_INT 1
23093: ST_TO_ADDR
// if p3 = 12 then
23094: LD_VAR 0 3
23098: PUSH
23099: LD_INT 12
23101: EQUAL
23102: IFFALSE 23112
// sExp := true ;
23104: LD_ADDR_EXP 71
23108: PUSH
23109: LD_INT 1
23111: ST_TO_ADDR
// if p3 = 13 then
23112: LD_VAR 0 3
23116: PUSH
23117: LD_INT 13
23119: EQUAL
23120: IFFALSE 23130
// sDepot := true ;
23122: LD_ADDR_EXP 72
23126: PUSH
23127: LD_INT 1
23129: ST_TO_ADDR
// if p3 = 14 then
23130: LD_VAR 0 3
23134: PUSH
23135: LD_INT 14
23137: EQUAL
23138: IFFALSE 23148
// sFlag := true ;
23140: LD_ADDR_EXP 73
23144: PUSH
23145: LD_INT 1
23147: ST_TO_ADDR
// if p3 = 15 then
23148: LD_VAR 0 3
23152: PUSH
23153: LD_INT 15
23155: EQUAL
23156: IFFALSE 23166
// sKamikadze := true ;
23158: LD_ADDR_EXP 81
23162: PUSH
23163: LD_INT 1
23165: ST_TO_ADDR
// if p3 = 16 then
23166: LD_VAR 0 3
23170: PUSH
23171: LD_INT 16
23173: EQUAL
23174: IFFALSE 23184
// sTroll := true ;
23176: LD_ADDR_EXP 82
23180: PUSH
23181: LD_INT 1
23183: ST_TO_ADDR
// if p3 = 17 then
23184: LD_VAR 0 3
23188: PUSH
23189: LD_INT 17
23191: EQUAL
23192: IFFALSE 23202
// sSlow := true ;
23194: LD_ADDR_EXP 83
23198: PUSH
23199: LD_INT 1
23201: ST_TO_ADDR
// if p3 = 18 then
23202: LD_VAR 0 3
23206: PUSH
23207: LD_INT 18
23209: EQUAL
23210: IFFALSE 23220
// sLack := true ;
23212: LD_ADDR_EXP 84
23216: PUSH
23217: LD_INT 1
23219: ST_TO_ADDR
// if p3 = 19 then
23220: LD_VAR 0 3
23224: PUSH
23225: LD_INT 19
23227: EQUAL
23228: IFFALSE 23238
// sTank := true ;
23230: LD_ADDR_EXP 86
23234: PUSH
23235: LD_INT 1
23237: ST_TO_ADDR
// if p3 = 20 then
23238: LD_VAR 0 3
23242: PUSH
23243: LD_INT 20
23245: EQUAL
23246: IFFALSE 23256
// sRemote := true ;
23248: LD_ADDR_EXP 87
23252: PUSH
23253: LD_INT 1
23255: ST_TO_ADDR
// if p3 = 21 then
23256: LD_VAR 0 3
23260: PUSH
23261: LD_INT 21
23263: EQUAL
23264: IFFALSE 23274
// sPowell := true ;
23266: LD_ADDR_EXP 88
23270: PUSH
23271: LD_INT 1
23273: ST_TO_ADDR
// if p3 = 22 then
23274: LD_VAR 0 3
23278: PUSH
23279: LD_INT 22
23281: EQUAL
23282: IFFALSE 23292
// sTeleport := true ;
23284: LD_ADDR_EXP 91
23288: PUSH
23289: LD_INT 1
23291: ST_TO_ADDR
// if p3 = 23 then
23292: LD_VAR 0 3
23296: PUSH
23297: LD_INT 23
23299: EQUAL
23300: IFFALSE 23310
// sOilTower := true ;
23302: LD_ADDR_EXP 93
23306: PUSH
23307: LD_INT 1
23309: ST_TO_ADDR
// if p3 = 24 then
23310: LD_VAR 0 3
23314: PUSH
23315: LD_INT 24
23317: EQUAL
23318: IFFALSE 23328
// sShovel := true ;
23320: LD_ADDR_EXP 94
23324: PUSH
23325: LD_INT 1
23327: ST_TO_ADDR
// if p3 = 25 then
23328: LD_VAR 0 3
23332: PUSH
23333: LD_INT 25
23335: EQUAL
23336: IFFALSE 23346
// sSheik := true ;
23338: LD_ADDR_EXP 95
23342: PUSH
23343: LD_INT 1
23345: ST_TO_ADDR
// if p3 = 26 then
23346: LD_VAR 0 3
23350: PUSH
23351: LD_INT 26
23353: EQUAL
23354: IFFALSE 23364
// sEarthquake := true ;
23356: LD_ADDR_EXP 97
23360: PUSH
23361: LD_INT 1
23363: ST_TO_ADDR
// if p3 = 27 then
23364: LD_VAR 0 3
23368: PUSH
23369: LD_INT 27
23371: EQUAL
23372: IFFALSE 23382
// sAI := true ;
23374: LD_ADDR_EXP 98
23378: PUSH
23379: LD_INT 1
23381: ST_TO_ADDR
// if p3 = 28 then
23382: LD_VAR 0 3
23386: PUSH
23387: LD_INT 28
23389: EQUAL
23390: IFFALSE 23400
// sCargo := true ;
23392: LD_ADDR_EXP 101
23396: PUSH
23397: LD_INT 1
23399: ST_TO_ADDR
// if p3 = 29 then
23400: LD_VAR 0 3
23404: PUSH
23405: LD_INT 29
23407: EQUAL
23408: IFFALSE 23418
// sDLaser := true ;
23410: LD_ADDR_EXP 102
23414: PUSH
23415: LD_INT 1
23417: ST_TO_ADDR
// if p3 = 30 then
23418: LD_VAR 0 3
23422: PUSH
23423: LD_INT 30
23425: EQUAL
23426: IFFALSE 23436
// sExchange := true ;
23428: LD_ADDR_EXP 103
23432: PUSH
23433: LD_INT 1
23435: ST_TO_ADDR
// if p3 = 31 then
23436: LD_VAR 0 3
23440: PUSH
23441: LD_INT 31
23443: EQUAL
23444: IFFALSE 23454
// sFac := true ;
23446: LD_ADDR_EXP 104
23450: PUSH
23451: LD_INT 1
23453: ST_TO_ADDR
// if p3 = 32 then
23454: LD_VAR 0 3
23458: PUSH
23459: LD_INT 32
23461: EQUAL
23462: IFFALSE 23472
// sPower := true ;
23464: LD_ADDR_EXP 105
23468: PUSH
23469: LD_INT 1
23471: ST_TO_ADDR
// if p3 = 33 then
23472: LD_VAR 0 3
23476: PUSH
23477: LD_INT 33
23479: EQUAL
23480: IFFALSE 23490
// sRandom := true ;
23482: LD_ADDR_EXP 106
23486: PUSH
23487: LD_INT 1
23489: ST_TO_ADDR
// if p3 = 34 then
23490: LD_VAR 0 3
23494: PUSH
23495: LD_INT 34
23497: EQUAL
23498: IFFALSE 23508
// sShield := true ;
23500: LD_ADDR_EXP 107
23504: PUSH
23505: LD_INT 1
23507: ST_TO_ADDR
// if p3 = 35 then
23508: LD_VAR 0 3
23512: PUSH
23513: LD_INT 35
23515: EQUAL
23516: IFFALSE 23526
// sTime := true ;
23518: LD_ADDR_EXP 108
23522: PUSH
23523: LD_INT 1
23525: ST_TO_ADDR
// if p3 = 36 then
23526: LD_VAR 0 3
23530: PUSH
23531: LD_INT 36
23533: EQUAL
23534: IFFALSE 23544
// sTools := true ;
23536: LD_ADDR_EXP 109
23540: PUSH
23541: LD_INT 1
23543: ST_TO_ADDR
// if p3 = 101 then
23544: LD_VAR 0 3
23548: PUSH
23549: LD_INT 101
23551: EQUAL
23552: IFFALSE 23562
// sSold := true ;
23554: LD_ADDR_EXP 74
23558: PUSH
23559: LD_INT 1
23561: ST_TO_ADDR
// if p3 = 102 then
23562: LD_VAR 0 3
23566: PUSH
23567: LD_INT 102
23569: EQUAL
23570: IFFALSE 23580
// sDiff := true ;
23572: LD_ADDR_EXP 75
23576: PUSH
23577: LD_INT 1
23579: ST_TO_ADDR
// if p3 = 103 then
23580: LD_VAR 0 3
23584: PUSH
23585: LD_INT 103
23587: EQUAL
23588: IFFALSE 23598
// sFog := true ;
23590: LD_ADDR_EXP 78
23594: PUSH
23595: LD_INT 1
23597: ST_TO_ADDR
// if p3 = 104 then
23598: LD_VAR 0 3
23602: PUSH
23603: LD_INT 104
23605: EQUAL
23606: IFFALSE 23616
// sReset := true ;
23608: LD_ADDR_EXP 79
23612: PUSH
23613: LD_INT 1
23615: ST_TO_ADDR
// if p3 = 105 then
23616: LD_VAR 0 3
23620: PUSH
23621: LD_INT 105
23623: EQUAL
23624: IFFALSE 23634
// sSun := true ;
23626: LD_ADDR_EXP 80
23630: PUSH
23631: LD_INT 1
23633: ST_TO_ADDR
// if p3 = 106 then
23634: LD_VAR 0 3
23638: PUSH
23639: LD_INT 106
23641: EQUAL
23642: IFFALSE 23652
// sTiger := true ;
23644: LD_ADDR_EXP 76
23648: PUSH
23649: LD_INT 1
23651: ST_TO_ADDR
// if p3 = 107 then
23652: LD_VAR 0 3
23656: PUSH
23657: LD_INT 107
23659: EQUAL
23660: IFFALSE 23670
// sBomb := true ;
23662: LD_ADDR_EXP 77
23666: PUSH
23667: LD_INT 1
23669: ST_TO_ADDR
// if p3 = 108 then
23670: LD_VAR 0 3
23674: PUSH
23675: LD_INT 108
23677: EQUAL
23678: IFFALSE 23688
// sWound := true ;
23680: LD_ADDR_EXP 85
23684: PUSH
23685: LD_INT 1
23687: ST_TO_ADDR
// if p3 = 109 then
23688: LD_VAR 0 3
23692: PUSH
23693: LD_INT 109
23695: EQUAL
23696: IFFALSE 23706
// sBetray := true ;
23698: LD_ADDR_EXP 89
23702: PUSH
23703: LD_INT 1
23705: ST_TO_ADDR
// if p3 = 110 then
23706: LD_VAR 0 3
23710: PUSH
23711: LD_INT 110
23713: EQUAL
23714: IFFALSE 23724
// sContamin := true ;
23716: LD_ADDR_EXP 90
23720: PUSH
23721: LD_INT 1
23723: ST_TO_ADDR
// if p3 = 111 then
23724: LD_VAR 0 3
23728: PUSH
23729: LD_INT 111
23731: EQUAL
23732: IFFALSE 23742
// sOil := true ;
23734: LD_ADDR_EXP 92
23738: PUSH
23739: LD_INT 1
23741: ST_TO_ADDR
// if p3 = 112 then
23742: LD_VAR 0 3
23746: PUSH
23747: LD_INT 112
23749: EQUAL
23750: IFFALSE 23760
// sStu := true ;
23752: LD_ADDR_EXP 96
23756: PUSH
23757: LD_INT 1
23759: ST_TO_ADDR
// if p3 = 113 then
23760: LD_VAR 0 3
23764: PUSH
23765: LD_INT 113
23767: EQUAL
23768: IFFALSE 23778
// sBazooka := true ;
23770: LD_ADDR_EXP 99
23774: PUSH
23775: LD_INT 1
23777: ST_TO_ADDR
// if p3 = 114 then
23778: LD_VAR 0 3
23782: PUSH
23783: LD_INT 114
23785: EQUAL
23786: IFFALSE 23796
// sMortar := true ;
23788: LD_ADDR_EXP 100
23792: PUSH
23793: LD_INT 1
23795: ST_TO_ADDR
// if p3 = 115 then
23796: LD_VAR 0 3
23800: PUSH
23801: LD_INT 115
23803: EQUAL
23804: IFFALSE 23814
// sRanger := true ;
23806: LD_ADDR_EXP 110
23810: PUSH
23811: LD_INT 1
23813: ST_TO_ADDR
// end ; end ;
23814: PPOPN 6
23816: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23817: LD_EXP 57
23821: PUSH
23822: LD_EXP 62
23826: AND
23827: IFFALSE 23951
23829: GO 23831
23831: DISABLE
23832: LD_INT 0
23834: PPUSH
23835: PPUSH
// begin enable ;
23836: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23837: LD_ADDR_VAR 0 2
23841: PUSH
23842: LD_INT 22
23844: PUSH
23845: LD_OWVAR 2
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: PUSH
23854: LD_INT 2
23856: PUSH
23857: LD_INT 34
23859: PUSH
23860: LD_INT 7
23862: PUSH
23863: EMPTY
23864: LIST
23865: LIST
23866: PUSH
23867: LD_INT 34
23869: PUSH
23870: LD_INT 45
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: PUSH
23877: LD_INT 34
23879: PUSH
23880: LD_INT 28
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 34
23889: PUSH
23890: LD_INT 47
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: LIST
23901: LIST
23902: LIST
23903: PUSH
23904: EMPTY
23905: LIST
23906: LIST
23907: PPUSH
23908: CALL_OW 69
23912: ST_TO_ADDR
// if not tmp then
23913: LD_VAR 0 2
23917: NOT
23918: IFFALSE 23922
// exit ;
23920: GO 23951
// for i in tmp do
23922: LD_ADDR_VAR 0 1
23926: PUSH
23927: LD_VAR 0 2
23931: PUSH
23932: FOR_IN
23933: IFFALSE 23949
// begin SetLives ( i , 0 ) ;
23935: LD_VAR 0 1
23939: PPUSH
23940: LD_INT 0
23942: PPUSH
23943: CALL_OW 234
// end ;
23947: GO 23932
23949: POP
23950: POP
// end ;
23951: PPOPN 2
23953: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23954: LD_EXP 57
23958: PUSH
23959: LD_EXP 63
23963: AND
23964: IFFALSE 24048
23966: GO 23968
23968: DISABLE
23969: LD_INT 0
23971: PPUSH
23972: PPUSH
// begin enable ;
23973: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23974: LD_ADDR_VAR 0 2
23978: PUSH
23979: LD_INT 22
23981: PUSH
23982: LD_OWVAR 2
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 32
23993: PUSH
23994: LD_INT 3
23996: PUSH
23997: EMPTY
23998: LIST
23999: LIST
24000: PUSH
24001: EMPTY
24002: LIST
24003: LIST
24004: PPUSH
24005: CALL_OW 69
24009: ST_TO_ADDR
// if not tmp then
24010: LD_VAR 0 2
24014: NOT
24015: IFFALSE 24019
// exit ;
24017: GO 24048
// for i in tmp do
24019: LD_ADDR_VAR 0 1
24023: PUSH
24024: LD_VAR 0 2
24028: PUSH
24029: FOR_IN
24030: IFFALSE 24046
// begin SetLives ( i , 0 ) ;
24032: LD_VAR 0 1
24036: PPUSH
24037: LD_INT 0
24039: PPUSH
24040: CALL_OW 234
// end ;
24044: GO 24029
24046: POP
24047: POP
// end ;
24048: PPOPN 2
24050: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
24051: LD_EXP 57
24055: PUSH
24056: LD_EXP 60
24060: AND
24061: IFFALSE 24154
24063: GO 24065
24065: DISABLE
24066: LD_INT 0
24068: PPUSH
// begin enable ;
24069: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
24070: LD_ADDR_VAR 0 1
24074: PUSH
24075: LD_INT 22
24077: PUSH
24078: LD_OWVAR 2
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: PUSH
24087: LD_INT 2
24089: PUSH
24090: LD_INT 25
24092: PUSH
24093: LD_INT 5
24095: PUSH
24096: EMPTY
24097: LIST
24098: LIST
24099: PUSH
24100: LD_INT 25
24102: PUSH
24103: LD_INT 9
24105: PUSH
24106: EMPTY
24107: LIST
24108: LIST
24109: PUSH
24110: LD_INT 25
24112: PUSH
24113: LD_INT 8
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: PPUSH
24130: CALL_OW 69
24134: PUSH
24135: FOR_IN
24136: IFFALSE 24152
// begin SetClass ( i , 1 ) ;
24138: LD_VAR 0 1
24142: PPUSH
24143: LD_INT 1
24145: PPUSH
24146: CALL_OW 336
// end ;
24150: GO 24135
24152: POP
24153: POP
// end ;
24154: PPOPN 1
24156: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
24157: LD_EXP 57
24161: PUSH
24162: LD_EXP 61
24166: AND
24167: PUSH
24168: LD_OWVAR 65
24172: PUSH
24173: LD_INT 7
24175: LESS
24176: AND
24177: IFFALSE 24191
24179: GO 24181
24181: DISABLE
// begin enable ;
24182: ENABLE
// game_speed := 7 ;
24183: LD_ADDR_OWVAR 65
24187: PUSH
24188: LD_INT 7
24190: ST_TO_ADDR
// end ;
24191: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
24192: LD_EXP 57
24196: PUSH
24197: LD_EXP 64
24201: AND
24202: IFFALSE 24404
24204: GO 24206
24206: DISABLE
24207: LD_INT 0
24209: PPUSH
24210: PPUSH
24211: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
24212: LD_ADDR_VAR 0 3
24216: PUSH
24217: LD_INT 81
24219: PUSH
24220: LD_OWVAR 2
24224: PUSH
24225: EMPTY
24226: LIST
24227: LIST
24228: PUSH
24229: LD_INT 21
24231: PUSH
24232: LD_INT 1
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: PUSH
24239: EMPTY
24240: LIST
24241: LIST
24242: PPUSH
24243: CALL_OW 69
24247: ST_TO_ADDR
// if not tmp then
24248: LD_VAR 0 3
24252: NOT
24253: IFFALSE 24257
// exit ;
24255: GO 24404
// if tmp > 5 then
24257: LD_VAR 0 3
24261: PUSH
24262: LD_INT 5
24264: GREATER
24265: IFFALSE 24277
// k := 5 else
24267: LD_ADDR_VAR 0 2
24271: PUSH
24272: LD_INT 5
24274: ST_TO_ADDR
24275: GO 24287
// k := tmp ;
24277: LD_ADDR_VAR 0 2
24281: PUSH
24282: LD_VAR 0 3
24286: ST_TO_ADDR
// for i := 1 to k do
24287: LD_ADDR_VAR 0 1
24291: PUSH
24292: DOUBLE
24293: LD_INT 1
24295: DEC
24296: ST_TO_ADDR
24297: LD_VAR 0 2
24301: PUSH
24302: FOR_TO
24303: IFFALSE 24402
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
24305: LD_VAR 0 3
24309: PUSH
24310: LD_VAR 0 1
24314: ARRAY
24315: PPUSH
24316: LD_VAR 0 1
24320: PUSH
24321: LD_INT 4
24323: MOD
24324: PUSH
24325: LD_INT 1
24327: PLUS
24328: PPUSH
24329: CALL_OW 259
24333: PUSH
24334: LD_INT 10
24336: LESS
24337: IFFALSE 24400
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
24339: LD_VAR 0 3
24343: PUSH
24344: LD_VAR 0 1
24348: ARRAY
24349: PPUSH
24350: LD_VAR 0 1
24354: PUSH
24355: LD_INT 4
24357: MOD
24358: PUSH
24359: LD_INT 1
24361: PLUS
24362: PPUSH
24363: LD_VAR 0 3
24367: PUSH
24368: LD_VAR 0 1
24372: ARRAY
24373: PPUSH
24374: LD_VAR 0 1
24378: PUSH
24379: LD_INT 4
24381: MOD
24382: PUSH
24383: LD_INT 1
24385: PLUS
24386: PPUSH
24387: CALL_OW 259
24391: PUSH
24392: LD_INT 1
24394: PLUS
24395: PPUSH
24396: CALL_OW 237
24400: GO 24302
24402: POP
24403: POP
// end ;
24404: PPOPN 3
24406: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
24407: LD_EXP 57
24411: PUSH
24412: LD_EXP 65
24416: AND
24417: IFFALSE 24437
24419: GO 24421
24421: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
24422: LD_INT 4
24424: PPUSH
24425: LD_OWVAR 2
24429: PPUSH
24430: LD_INT 0
24432: PPUSH
24433: CALL_OW 324
24437: END
// every 0 0$1 trigger StreamModeActive and sShovel do
24438: LD_EXP 57
24442: PUSH
24443: LD_EXP 94
24447: AND
24448: IFFALSE 24468
24450: GO 24452
24452: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
24453: LD_INT 19
24455: PPUSH
24456: LD_OWVAR 2
24460: PPUSH
24461: LD_INT 0
24463: PPUSH
24464: CALL_OW 324
24468: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24469: LD_EXP 57
24473: PUSH
24474: LD_EXP 66
24478: AND
24479: IFFALSE 24581
24481: GO 24483
24483: DISABLE
24484: LD_INT 0
24486: PPUSH
24487: PPUSH
// begin enable ;
24488: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24489: LD_ADDR_VAR 0 2
24493: PUSH
24494: LD_INT 22
24496: PUSH
24497: LD_OWVAR 2
24501: PUSH
24502: EMPTY
24503: LIST
24504: LIST
24505: PUSH
24506: LD_INT 2
24508: PUSH
24509: LD_INT 34
24511: PUSH
24512: LD_INT 11
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: PUSH
24519: LD_INT 34
24521: PUSH
24522: LD_INT 30
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: LIST
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: PPUSH
24538: CALL_OW 69
24542: ST_TO_ADDR
// if not tmp then
24543: LD_VAR 0 2
24547: NOT
24548: IFFALSE 24552
// exit ;
24550: GO 24581
// for i in tmp do
24552: LD_ADDR_VAR 0 1
24556: PUSH
24557: LD_VAR 0 2
24561: PUSH
24562: FOR_IN
24563: IFFALSE 24579
// begin SetLives ( i , 0 ) ;
24565: LD_VAR 0 1
24569: PPUSH
24570: LD_INT 0
24572: PPUSH
24573: CALL_OW 234
// end ;
24577: GO 24562
24579: POP
24580: POP
// end ;
24581: PPOPN 2
24583: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24584: LD_EXP 57
24588: PUSH
24589: LD_EXP 67
24593: AND
24594: IFFALSE 24614
24596: GO 24598
24598: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24599: LD_INT 32
24601: PPUSH
24602: LD_OWVAR 2
24606: PPUSH
24607: LD_INT 0
24609: PPUSH
24610: CALL_OW 324
24614: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24615: LD_EXP 57
24619: PUSH
24620: LD_EXP 68
24624: AND
24625: IFFALSE 24806
24627: GO 24629
24629: DISABLE
24630: LD_INT 0
24632: PPUSH
24633: PPUSH
24634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24635: LD_ADDR_VAR 0 2
24639: PUSH
24640: LD_INT 22
24642: PUSH
24643: LD_OWVAR 2
24647: PUSH
24648: EMPTY
24649: LIST
24650: LIST
24651: PUSH
24652: LD_INT 33
24654: PUSH
24655: LD_INT 3
24657: PUSH
24658: EMPTY
24659: LIST
24660: LIST
24661: PUSH
24662: EMPTY
24663: LIST
24664: LIST
24665: PPUSH
24666: CALL_OW 69
24670: ST_TO_ADDR
// if not tmp then
24671: LD_VAR 0 2
24675: NOT
24676: IFFALSE 24680
// exit ;
24678: GO 24806
// side := 0 ;
24680: LD_ADDR_VAR 0 3
24684: PUSH
24685: LD_INT 0
24687: ST_TO_ADDR
// for i := 1 to 8 do
24688: LD_ADDR_VAR 0 1
24692: PUSH
24693: DOUBLE
24694: LD_INT 1
24696: DEC
24697: ST_TO_ADDR
24698: LD_INT 8
24700: PUSH
24701: FOR_TO
24702: IFFALSE 24750
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24704: LD_OWVAR 2
24708: PUSH
24709: LD_VAR 0 1
24713: NONEQUAL
24714: PUSH
24715: LD_OWVAR 2
24719: PPUSH
24720: LD_VAR 0 1
24724: PPUSH
24725: CALL_OW 81
24729: PUSH
24730: LD_INT 2
24732: EQUAL
24733: AND
24734: IFFALSE 24748
// begin side := i ;
24736: LD_ADDR_VAR 0 3
24740: PUSH
24741: LD_VAR 0 1
24745: ST_TO_ADDR
// break ;
24746: GO 24750
// end ;
24748: GO 24701
24750: POP
24751: POP
// if not side then
24752: LD_VAR 0 3
24756: NOT
24757: IFFALSE 24761
// exit ;
24759: GO 24806
// for i := 1 to tmp do
24761: LD_ADDR_VAR 0 1
24765: PUSH
24766: DOUBLE
24767: LD_INT 1
24769: DEC
24770: ST_TO_ADDR
24771: LD_VAR 0 2
24775: PUSH
24776: FOR_TO
24777: IFFALSE 24804
// if Prob ( 60 ) then
24779: LD_INT 60
24781: PPUSH
24782: CALL_OW 13
24786: IFFALSE 24802
// SetSide ( i , side ) ;
24788: LD_VAR 0 1
24792: PPUSH
24793: LD_VAR 0 3
24797: PPUSH
24798: CALL_OW 235
24802: GO 24776
24804: POP
24805: POP
// end ;
24806: PPOPN 3
24808: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24809: LD_EXP 57
24813: PUSH
24814: LD_EXP 70
24818: AND
24819: IFFALSE 24938
24821: GO 24823
24823: DISABLE
24824: LD_INT 0
24826: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24827: LD_ADDR_VAR 0 1
24831: PUSH
24832: LD_INT 22
24834: PUSH
24835: LD_OWVAR 2
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PUSH
24844: LD_INT 21
24846: PUSH
24847: LD_INT 1
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: PUSH
24854: LD_INT 3
24856: PUSH
24857: LD_INT 23
24859: PUSH
24860: LD_INT 0
24862: PUSH
24863: EMPTY
24864: LIST
24865: LIST
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: LIST
24875: PPUSH
24876: CALL_OW 69
24880: PUSH
24881: FOR_IN
24882: IFFALSE 24936
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24884: LD_VAR 0 1
24888: PPUSH
24889: CALL_OW 257
24893: PUSH
24894: LD_INT 1
24896: PUSH
24897: LD_INT 2
24899: PUSH
24900: LD_INT 3
24902: PUSH
24903: LD_INT 4
24905: PUSH
24906: EMPTY
24907: LIST
24908: LIST
24909: LIST
24910: LIST
24911: IN
24912: IFFALSE 24934
// SetClass ( un , rand ( 1 , 4 ) ) ;
24914: LD_VAR 0 1
24918: PPUSH
24919: LD_INT 1
24921: PPUSH
24922: LD_INT 4
24924: PPUSH
24925: CALL_OW 12
24929: PPUSH
24930: CALL_OW 336
24934: GO 24881
24936: POP
24937: POP
// end ;
24938: PPOPN 1
24940: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24941: LD_EXP 57
24945: PUSH
24946: LD_EXP 69
24950: AND
24951: IFFALSE 25030
24953: GO 24955
24955: DISABLE
24956: LD_INT 0
24958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24959: LD_ADDR_VAR 0 1
24963: PUSH
24964: LD_INT 22
24966: PUSH
24967: LD_OWVAR 2
24971: PUSH
24972: EMPTY
24973: LIST
24974: LIST
24975: PUSH
24976: LD_INT 21
24978: PUSH
24979: LD_INT 3
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: PUSH
24986: EMPTY
24987: LIST
24988: LIST
24989: PPUSH
24990: CALL_OW 69
24994: ST_TO_ADDR
// if not tmp then
24995: LD_VAR 0 1
24999: NOT
25000: IFFALSE 25004
// exit ;
25002: GO 25030
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
25004: LD_VAR 0 1
25008: PUSH
25009: LD_INT 1
25011: PPUSH
25012: LD_VAR 0 1
25016: PPUSH
25017: CALL_OW 12
25021: ARRAY
25022: PPUSH
25023: LD_INT 100
25025: PPUSH
25026: CALL_OW 234
// end ;
25030: PPOPN 1
25032: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
25033: LD_EXP 57
25037: PUSH
25038: LD_EXP 71
25042: AND
25043: IFFALSE 25141
25045: GO 25047
25047: DISABLE
25048: LD_INT 0
25050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25051: LD_ADDR_VAR 0 1
25055: PUSH
25056: LD_INT 22
25058: PUSH
25059: LD_OWVAR 2
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: PUSH
25068: LD_INT 21
25070: PUSH
25071: LD_INT 1
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PPUSH
25082: CALL_OW 69
25086: ST_TO_ADDR
// if not tmp then
25087: LD_VAR 0 1
25091: NOT
25092: IFFALSE 25096
// exit ;
25094: GO 25141
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
25096: LD_VAR 0 1
25100: PUSH
25101: LD_INT 1
25103: PPUSH
25104: LD_VAR 0 1
25108: PPUSH
25109: CALL_OW 12
25113: ARRAY
25114: PPUSH
25115: LD_INT 1
25117: PPUSH
25118: LD_INT 4
25120: PPUSH
25121: CALL_OW 12
25125: PPUSH
25126: LD_INT 3000
25128: PPUSH
25129: LD_INT 9000
25131: PPUSH
25132: CALL_OW 12
25136: PPUSH
25137: CALL_OW 492
// end ;
25141: PPOPN 1
25143: END
// every 0 0$1 trigger StreamModeActive and sDepot do
25144: LD_EXP 57
25148: PUSH
25149: LD_EXP 72
25153: AND
25154: IFFALSE 25174
25156: GO 25158
25158: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
25159: LD_INT 1
25161: PPUSH
25162: LD_OWVAR 2
25166: PPUSH
25167: LD_INT 0
25169: PPUSH
25170: CALL_OW 324
25174: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
25175: LD_EXP 57
25179: PUSH
25180: LD_EXP 73
25184: AND
25185: IFFALSE 25268
25187: GO 25189
25189: DISABLE
25190: LD_INT 0
25192: PPUSH
25193: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
25194: LD_ADDR_VAR 0 2
25198: PUSH
25199: LD_INT 22
25201: PUSH
25202: LD_OWVAR 2
25206: PUSH
25207: EMPTY
25208: LIST
25209: LIST
25210: PUSH
25211: LD_INT 21
25213: PUSH
25214: LD_INT 3
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PPUSH
25225: CALL_OW 69
25229: ST_TO_ADDR
// if not tmp then
25230: LD_VAR 0 2
25234: NOT
25235: IFFALSE 25239
// exit ;
25237: GO 25268
// for i in tmp do
25239: LD_ADDR_VAR 0 1
25243: PUSH
25244: LD_VAR 0 2
25248: PUSH
25249: FOR_IN
25250: IFFALSE 25266
// SetBLevel ( i , 10 ) ;
25252: LD_VAR 0 1
25256: PPUSH
25257: LD_INT 10
25259: PPUSH
25260: CALL_OW 241
25264: GO 25249
25266: POP
25267: POP
// end ;
25268: PPOPN 2
25270: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
25271: LD_EXP 57
25275: PUSH
25276: LD_EXP 74
25280: AND
25281: IFFALSE 25392
25283: GO 25285
25285: DISABLE
25286: LD_INT 0
25288: PPUSH
25289: PPUSH
25290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25291: LD_ADDR_VAR 0 3
25295: PUSH
25296: LD_INT 22
25298: PUSH
25299: LD_OWVAR 2
25303: PUSH
25304: EMPTY
25305: LIST
25306: LIST
25307: PUSH
25308: LD_INT 25
25310: PUSH
25311: LD_INT 1
25313: PUSH
25314: EMPTY
25315: LIST
25316: LIST
25317: PUSH
25318: EMPTY
25319: LIST
25320: LIST
25321: PPUSH
25322: CALL_OW 69
25326: ST_TO_ADDR
// if not tmp then
25327: LD_VAR 0 3
25331: NOT
25332: IFFALSE 25336
// exit ;
25334: GO 25392
// un := tmp [ rand ( 1 , tmp ) ] ;
25336: LD_ADDR_VAR 0 2
25340: PUSH
25341: LD_VAR 0 3
25345: PUSH
25346: LD_INT 1
25348: PPUSH
25349: LD_VAR 0 3
25353: PPUSH
25354: CALL_OW 12
25358: ARRAY
25359: ST_TO_ADDR
// if Crawls ( un ) then
25360: LD_VAR 0 2
25364: PPUSH
25365: CALL_OW 318
25369: IFFALSE 25380
// ComWalk ( un ) ;
25371: LD_VAR 0 2
25375: PPUSH
25376: CALL_OW 138
// SetClass ( un , class_sniper ) ;
25380: LD_VAR 0 2
25384: PPUSH
25385: LD_INT 5
25387: PPUSH
25388: CALL_OW 336
// end ;
25392: PPOPN 3
25394: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
25395: LD_EXP 57
25399: PUSH
25400: LD_EXP 75
25404: AND
25405: PUSH
25406: LD_OWVAR 67
25410: PUSH
25411: LD_INT 3
25413: LESS
25414: AND
25415: IFFALSE 25434
25417: GO 25419
25419: DISABLE
// Difficulty := Difficulty + 1 ;
25420: LD_ADDR_OWVAR 67
25424: PUSH
25425: LD_OWVAR 67
25429: PUSH
25430: LD_INT 1
25432: PLUS
25433: ST_TO_ADDR
25434: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
25435: LD_EXP 57
25439: PUSH
25440: LD_EXP 76
25444: AND
25445: IFFALSE 25548
25447: GO 25449
25449: DISABLE
25450: LD_INT 0
25452: PPUSH
// begin for i := 1 to 5 do
25453: LD_ADDR_VAR 0 1
25457: PUSH
25458: DOUBLE
25459: LD_INT 1
25461: DEC
25462: ST_TO_ADDR
25463: LD_INT 5
25465: PUSH
25466: FOR_TO
25467: IFFALSE 25546
// begin uc_nation := nation_nature ;
25469: LD_ADDR_OWVAR 21
25473: PUSH
25474: LD_INT 0
25476: ST_TO_ADDR
// uc_side := 0 ;
25477: LD_ADDR_OWVAR 20
25481: PUSH
25482: LD_INT 0
25484: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25485: LD_ADDR_OWVAR 29
25489: PUSH
25490: LD_INT 12
25492: PUSH
25493: LD_INT 12
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: ST_TO_ADDR
// hc_agressivity := 20 ;
25500: LD_ADDR_OWVAR 35
25504: PUSH
25505: LD_INT 20
25507: ST_TO_ADDR
// hc_class := class_tiger ;
25508: LD_ADDR_OWVAR 28
25512: PUSH
25513: LD_INT 14
25515: ST_TO_ADDR
// hc_gallery :=  ;
25516: LD_ADDR_OWVAR 33
25520: PUSH
25521: LD_STRING 
25523: ST_TO_ADDR
// hc_name :=  ;
25524: LD_ADDR_OWVAR 26
25528: PUSH
25529: LD_STRING 
25531: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25532: CALL_OW 44
25536: PPUSH
25537: LD_INT 0
25539: PPUSH
25540: CALL_OW 51
// end ;
25544: GO 25466
25546: POP
25547: POP
// end ;
25548: PPOPN 1
25550: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25551: LD_EXP 57
25555: PUSH
25556: LD_EXP 77
25560: AND
25561: IFFALSE 25570
25563: GO 25565
25565: DISABLE
// StreamSibBomb ;
25566: CALL 25571 0 0
25570: END
// export function StreamSibBomb ; var i , x , y ; begin
25571: LD_INT 0
25573: PPUSH
25574: PPUSH
25575: PPUSH
25576: PPUSH
// result := false ;
25577: LD_ADDR_VAR 0 1
25581: PUSH
25582: LD_INT 0
25584: ST_TO_ADDR
// for i := 1 to 16 do
25585: LD_ADDR_VAR 0 2
25589: PUSH
25590: DOUBLE
25591: LD_INT 1
25593: DEC
25594: ST_TO_ADDR
25595: LD_INT 16
25597: PUSH
25598: FOR_TO
25599: IFFALSE 25798
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25601: LD_ADDR_VAR 0 3
25605: PUSH
25606: LD_INT 10
25608: PUSH
25609: LD_INT 20
25611: PUSH
25612: LD_INT 30
25614: PUSH
25615: LD_INT 40
25617: PUSH
25618: LD_INT 50
25620: PUSH
25621: LD_INT 60
25623: PUSH
25624: LD_INT 70
25626: PUSH
25627: LD_INT 80
25629: PUSH
25630: LD_INT 90
25632: PUSH
25633: LD_INT 100
25635: PUSH
25636: LD_INT 110
25638: PUSH
25639: LD_INT 120
25641: PUSH
25642: LD_INT 130
25644: PUSH
25645: LD_INT 140
25647: PUSH
25648: LD_INT 150
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: LIST
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: PUSH
25668: LD_INT 1
25670: PPUSH
25671: LD_INT 15
25673: PPUSH
25674: CALL_OW 12
25678: ARRAY
25679: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25680: LD_ADDR_VAR 0 4
25684: PUSH
25685: LD_INT 10
25687: PUSH
25688: LD_INT 20
25690: PUSH
25691: LD_INT 30
25693: PUSH
25694: LD_INT 40
25696: PUSH
25697: LD_INT 50
25699: PUSH
25700: LD_INT 60
25702: PUSH
25703: LD_INT 70
25705: PUSH
25706: LD_INT 80
25708: PUSH
25709: LD_INT 90
25711: PUSH
25712: LD_INT 100
25714: PUSH
25715: LD_INT 110
25717: PUSH
25718: LD_INT 120
25720: PUSH
25721: LD_INT 130
25723: PUSH
25724: LD_INT 140
25726: PUSH
25727: LD_INT 150
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: LIST
25734: LIST
25735: LIST
25736: LIST
25737: LIST
25738: LIST
25739: LIST
25740: LIST
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: PUSH
25747: LD_INT 1
25749: PPUSH
25750: LD_INT 15
25752: PPUSH
25753: CALL_OW 12
25757: ARRAY
25758: ST_TO_ADDR
// if ValidHex ( x , y ) then
25759: LD_VAR 0 3
25763: PPUSH
25764: LD_VAR 0 4
25768: PPUSH
25769: CALL_OW 488
25773: IFFALSE 25796
// begin result := [ x , y ] ;
25775: LD_ADDR_VAR 0 1
25779: PUSH
25780: LD_VAR 0 3
25784: PUSH
25785: LD_VAR 0 4
25789: PUSH
25790: EMPTY
25791: LIST
25792: LIST
25793: ST_TO_ADDR
// break ;
25794: GO 25798
// end ; end ;
25796: GO 25598
25798: POP
25799: POP
// if result then
25800: LD_VAR 0 1
25804: IFFALSE 25864
// begin ToLua ( playSibBomb() ) ;
25806: LD_STRING playSibBomb()
25808: PPUSH
25809: CALL_OW 559
// wait ( 0 0$14 ) ;
25813: LD_INT 490
25815: PPUSH
25816: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25820: LD_VAR 0 1
25824: PUSH
25825: LD_INT 1
25827: ARRAY
25828: PPUSH
25829: LD_VAR 0 1
25833: PUSH
25834: LD_INT 2
25836: ARRAY
25837: PPUSH
25838: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25842: LD_VAR 0 1
25846: PUSH
25847: LD_INT 1
25849: ARRAY
25850: PPUSH
25851: LD_VAR 0 1
25855: PUSH
25856: LD_INT 2
25858: ARRAY
25859: PPUSH
25860: CALL_OW 429
// end ; end ;
25864: LD_VAR 0 1
25868: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25869: LD_EXP 57
25873: PUSH
25874: LD_EXP 79
25878: AND
25879: IFFALSE 25891
25881: GO 25883
25883: DISABLE
// YouLost (  ) ;
25884: LD_STRING 
25886: PPUSH
25887: CALL_OW 104
25891: END
// every 0 0$1 trigger StreamModeActive and sFog do
25892: LD_EXP 57
25896: PUSH
25897: LD_EXP 78
25901: AND
25902: IFFALSE 25916
25904: GO 25906
25906: DISABLE
// FogOff ( your_side ) ;
25907: LD_OWVAR 2
25911: PPUSH
25912: CALL_OW 344
25916: END
// every 0 0$1 trigger StreamModeActive and sSun do
25917: LD_EXP 57
25921: PUSH
25922: LD_EXP 80
25926: AND
25927: IFFALSE 25955
25929: GO 25931
25931: DISABLE
// begin solar_recharge_percent := 0 ;
25932: LD_ADDR_OWVAR 79
25936: PUSH
25937: LD_INT 0
25939: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25940: LD_INT 10500
25942: PPUSH
25943: CALL_OW 67
// solar_recharge_percent := 100 ;
25947: LD_ADDR_OWVAR 79
25951: PUSH
25952: LD_INT 100
25954: ST_TO_ADDR
// end ;
25955: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25956: LD_EXP 57
25960: PUSH
25961: LD_EXP 81
25965: AND
25966: IFFALSE 26205
25968: GO 25970
25970: DISABLE
25971: LD_INT 0
25973: PPUSH
25974: PPUSH
25975: PPUSH
// begin tmp := [ ] ;
25976: LD_ADDR_VAR 0 3
25980: PUSH
25981: EMPTY
25982: ST_TO_ADDR
// for i := 1 to 6 do
25983: LD_ADDR_VAR 0 1
25987: PUSH
25988: DOUBLE
25989: LD_INT 1
25991: DEC
25992: ST_TO_ADDR
25993: LD_INT 6
25995: PUSH
25996: FOR_TO
25997: IFFALSE 26102
// begin uc_nation := nation_nature ;
25999: LD_ADDR_OWVAR 21
26003: PUSH
26004: LD_INT 0
26006: ST_TO_ADDR
// uc_side := 0 ;
26007: LD_ADDR_OWVAR 20
26011: PUSH
26012: LD_INT 0
26014: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
26015: LD_ADDR_OWVAR 29
26019: PUSH
26020: LD_INT 12
26022: PUSH
26023: LD_INT 12
26025: PUSH
26026: EMPTY
26027: LIST
26028: LIST
26029: ST_TO_ADDR
// hc_agressivity := 20 ;
26030: LD_ADDR_OWVAR 35
26034: PUSH
26035: LD_INT 20
26037: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
26038: LD_ADDR_OWVAR 28
26042: PUSH
26043: LD_INT 17
26045: ST_TO_ADDR
// hc_gallery :=  ;
26046: LD_ADDR_OWVAR 33
26050: PUSH
26051: LD_STRING 
26053: ST_TO_ADDR
// hc_name :=  ;
26054: LD_ADDR_OWVAR 26
26058: PUSH
26059: LD_STRING 
26061: ST_TO_ADDR
// un := CreateHuman ;
26062: LD_ADDR_VAR 0 2
26066: PUSH
26067: CALL_OW 44
26071: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
26072: LD_VAR 0 2
26076: PPUSH
26077: LD_INT 1
26079: PPUSH
26080: CALL_OW 51
// tmp := tmp ^ un ;
26084: LD_ADDR_VAR 0 3
26088: PUSH
26089: LD_VAR 0 3
26093: PUSH
26094: LD_VAR 0 2
26098: ADD
26099: ST_TO_ADDR
// end ;
26100: GO 25996
26102: POP
26103: POP
// repeat wait ( 0 0$1 ) ;
26104: LD_INT 35
26106: PPUSH
26107: CALL_OW 67
// for un in tmp do
26111: LD_ADDR_VAR 0 2
26115: PUSH
26116: LD_VAR 0 3
26120: PUSH
26121: FOR_IN
26122: IFFALSE 26196
// begin if IsDead ( un ) then
26124: LD_VAR 0 2
26128: PPUSH
26129: CALL_OW 301
26133: IFFALSE 26153
// begin tmp := tmp diff un ;
26135: LD_ADDR_VAR 0 3
26139: PUSH
26140: LD_VAR 0 3
26144: PUSH
26145: LD_VAR 0 2
26149: DIFF
26150: ST_TO_ADDR
// continue ;
26151: GO 26121
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
26153: LD_VAR 0 2
26157: PPUSH
26158: LD_INT 3
26160: PUSH
26161: LD_INT 22
26163: PUSH
26164: LD_INT 0
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: CALL_OW 69
26179: PPUSH
26180: LD_VAR 0 2
26184: PPUSH
26185: CALL_OW 74
26189: PPUSH
26190: CALL_OW 115
// end ;
26194: GO 26121
26196: POP
26197: POP
// until not tmp ;
26198: LD_VAR 0 3
26202: NOT
26203: IFFALSE 26104
// end ;
26205: PPOPN 3
26207: END
// every 0 0$1 trigger StreamModeActive and sTroll do
26208: LD_EXP 57
26212: PUSH
26213: LD_EXP 82
26217: AND
26218: IFFALSE 26272
26220: GO 26222
26222: DISABLE
// begin ToLua ( displayTroll(); ) ;
26223: LD_STRING displayTroll();
26225: PPUSH
26226: CALL_OW 559
// wait ( 3 3$00 ) ;
26230: LD_INT 6300
26232: PPUSH
26233: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26237: LD_STRING hideTroll();
26239: PPUSH
26240: CALL_OW 559
// wait ( 1 1$00 ) ;
26244: LD_INT 2100
26246: PPUSH
26247: CALL_OW 67
// ToLua ( displayTroll(); ) ;
26251: LD_STRING displayTroll();
26253: PPUSH
26254: CALL_OW 559
// wait ( 1 1$00 ) ;
26258: LD_INT 2100
26260: PPUSH
26261: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26265: LD_STRING hideTroll();
26267: PPUSH
26268: CALL_OW 559
// end ;
26272: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
26273: LD_EXP 57
26277: PUSH
26278: LD_EXP 83
26282: AND
26283: IFFALSE 26346
26285: GO 26287
26287: DISABLE
26288: LD_INT 0
26290: PPUSH
// begin p := 0 ;
26291: LD_ADDR_VAR 0 1
26295: PUSH
26296: LD_INT 0
26298: ST_TO_ADDR
// repeat game_speed := 1 ;
26299: LD_ADDR_OWVAR 65
26303: PUSH
26304: LD_INT 1
26306: ST_TO_ADDR
// wait ( 0 0$1 ) ;
26307: LD_INT 35
26309: PPUSH
26310: CALL_OW 67
// p := p + 1 ;
26314: LD_ADDR_VAR 0 1
26318: PUSH
26319: LD_VAR 0 1
26323: PUSH
26324: LD_INT 1
26326: PLUS
26327: ST_TO_ADDR
// until p >= 60 ;
26328: LD_VAR 0 1
26332: PUSH
26333: LD_INT 60
26335: GREATEREQUAL
26336: IFFALSE 26299
// game_speed := 4 ;
26338: LD_ADDR_OWVAR 65
26342: PUSH
26343: LD_INT 4
26345: ST_TO_ADDR
// end ;
26346: PPOPN 1
26348: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
26349: LD_EXP 57
26353: PUSH
26354: LD_EXP 84
26358: AND
26359: IFFALSE 26505
26361: GO 26363
26363: DISABLE
26364: LD_INT 0
26366: PPUSH
26367: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26368: LD_ADDR_VAR 0 1
26372: PUSH
26373: LD_INT 22
26375: PUSH
26376: LD_OWVAR 2
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 2
26387: PUSH
26388: LD_INT 30
26390: PUSH
26391: LD_INT 0
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 30
26400: PUSH
26401: LD_INT 1
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: LIST
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: PPUSH
26417: CALL_OW 69
26421: ST_TO_ADDR
// if not depot then
26422: LD_VAR 0 1
26426: NOT
26427: IFFALSE 26431
// exit ;
26429: GO 26505
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
26431: LD_ADDR_VAR 0 2
26435: PUSH
26436: LD_VAR 0 1
26440: PUSH
26441: LD_INT 1
26443: PPUSH
26444: LD_VAR 0 1
26448: PPUSH
26449: CALL_OW 12
26453: ARRAY
26454: PPUSH
26455: CALL_OW 274
26459: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
26460: LD_VAR 0 2
26464: PPUSH
26465: LD_INT 1
26467: PPUSH
26468: LD_INT 0
26470: PPUSH
26471: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26475: LD_VAR 0 2
26479: PPUSH
26480: LD_INT 2
26482: PPUSH
26483: LD_INT 0
26485: PPUSH
26486: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26490: LD_VAR 0 2
26494: PPUSH
26495: LD_INT 3
26497: PPUSH
26498: LD_INT 0
26500: PPUSH
26501: CALL_OW 277
// end ;
26505: PPOPN 2
26507: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26508: LD_EXP 57
26512: PUSH
26513: LD_EXP 85
26517: AND
26518: IFFALSE 26615
26520: GO 26522
26522: DISABLE
26523: LD_INT 0
26525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26526: LD_ADDR_VAR 0 1
26530: PUSH
26531: LD_INT 22
26533: PUSH
26534: LD_OWVAR 2
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 21
26545: PUSH
26546: LD_INT 1
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: LD_INT 3
26555: PUSH
26556: LD_INT 23
26558: PUSH
26559: LD_INT 0
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: LIST
26574: PPUSH
26575: CALL_OW 69
26579: ST_TO_ADDR
// if not tmp then
26580: LD_VAR 0 1
26584: NOT
26585: IFFALSE 26589
// exit ;
26587: GO 26615
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26589: LD_VAR 0 1
26593: PUSH
26594: LD_INT 1
26596: PPUSH
26597: LD_VAR 0 1
26601: PPUSH
26602: CALL_OW 12
26606: ARRAY
26607: PPUSH
26608: LD_INT 200
26610: PPUSH
26611: CALL_OW 234
// end ;
26615: PPOPN 1
26617: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26618: LD_EXP 57
26622: PUSH
26623: LD_EXP 86
26627: AND
26628: IFFALSE 26707
26630: GO 26632
26632: DISABLE
26633: LD_INT 0
26635: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26636: LD_ADDR_VAR 0 1
26640: PUSH
26641: LD_INT 22
26643: PUSH
26644: LD_OWVAR 2
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: LD_INT 21
26655: PUSH
26656: LD_INT 2
26658: PUSH
26659: EMPTY
26660: LIST
26661: LIST
26662: PUSH
26663: EMPTY
26664: LIST
26665: LIST
26666: PPUSH
26667: CALL_OW 69
26671: ST_TO_ADDR
// if not tmp then
26672: LD_VAR 0 1
26676: NOT
26677: IFFALSE 26681
// exit ;
26679: GO 26707
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26681: LD_VAR 0 1
26685: PUSH
26686: LD_INT 1
26688: PPUSH
26689: LD_VAR 0 1
26693: PPUSH
26694: CALL_OW 12
26698: ARRAY
26699: PPUSH
26700: LD_INT 60
26702: PPUSH
26703: CALL_OW 234
// end ;
26707: PPOPN 1
26709: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26710: LD_EXP 57
26714: PUSH
26715: LD_EXP 87
26719: AND
26720: IFFALSE 26819
26722: GO 26724
26724: DISABLE
26725: LD_INT 0
26727: PPUSH
26728: PPUSH
// begin enable ;
26729: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26730: LD_ADDR_VAR 0 1
26734: PUSH
26735: LD_INT 22
26737: PUSH
26738: LD_OWVAR 2
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PUSH
26747: LD_INT 61
26749: PUSH
26750: EMPTY
26751: LIST
26752: PUSH
26753: LD_INT 33
26755: PUSH
26756: LD_INT 2
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: LIST
26767: PPUSH
26768: CALL_OW 69
26772: ST_TO_ADDR
// if not tmp then
26773: LD_VAR 0 1
26777: NOT
26778: IFFALSE 26782
// exit ;
26780: GO 26819
// for i in tmp do
26782: LD_ADDR_VAR 0 2
26786: PUSH
26787: LD_VAR 0 1
26791: PUSH
26792: FOR_IN
26793: IFFALSE 26817
// if IsControledBy ( i ) then
26795: LD_VAR 0 2
26799: PPUSH
26800: CALL_OW 312
26804: IFFALSE 26815
// ComUnlink ( i ) ;
26806: LD_VAR 0 2
26810: PPUSH
26811: CALL_OW 136
26815: GO 26792
26817: POP
26818: POP
// end ;
26819: PPOPN 2
26821: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26822: LD_EXP 57
26826: PUSH
26827: LD_EXP 88
26831: AND
26832: IFFALSE 26972
26834: GO 26836
26836: DISABLE
26837: LD_INT 0
26839: PPUSH
26840: PPUSH
// begin ToLua ( displayPowell(); ) ;
26841: LD_STRING displayPowell();
26843: PPUSH
26844: CALL_OW 559
// uc_side := 0 ;
26848: LD_ADDR_OWVAR 20
26852: PUSH
26853: LD_INT 0
26855: ST_TO_ADDR
// uc_nation := 2 ;
26856: LD_ADDR_OWVAR 21
26860: PUSH
26861: LD_INT 2
26863: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26864: LD_ADDR_OWVAR 37
26868: PUSH
26869: LD_INT 14
26871: ST_TO_ADDR
// vc_engine := engine_siberite ;
26872: LD_ADDR_OWVAR 39
26876: PUSH
26877: LD_INT 3
26879: ST_TO_ADDR
// vc_control := control_apeman ;
26880: LD_ADDR_OWVAR 38
26884: PUSH
26885: LD_INT 5
26887: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26888: LD_ADDR_OWVAR 40
26892: PUSH
26893: LD_INT 29
26895: ST_TO_ADDR
// un := CreateVehicle ;
26896: LD_ADDR_VAR 0 2
26900: PUSH
26901: CALL_OW 45
26905: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26906: LD_VAR 0 2
26910: PPUSH
26911: LD_INT 1
26913: PPUSH
26914: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26918: LD_INT 35
26920: PPUSH
26921: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26925: LD_VAR 0 2
26929: PPUSH
26930: LD_INT 22
26932: PUSH
26933: LD_OWVAR 2
26937: PUSH
26938: EMPTY
26939: LIST
26940: LIST
26941: PPUSH
26942: CALL_OW 69
26946: PPUSH
26947: LD_VAR 0 2
26951: PPUSH
26952: CALL_OW 74
26956: PPUSH
26957: CALL_OW 115
// until IsDead ( un ) ;
26961: LD_VAR 0 2
26965: PPUSH
26966: CALL_OW 301
26970: IFFALSE 26918
// end ;
26972: PPOPN 2
26974: END
// every 0 0$1 trigger StreamModeActive and sStu do
26975: LD_EXP 57
26979: PUSH
26980: LD_EXP 96
26984: AND
26985: IFFALSE 27001
26987: GO 26989
26989: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26990: LD_STRING displayStucuk();
26992: PPUSH
26993: CALL_OW 559
// ResetFog ;
26997: CALL_OW 335
// end ;
27001: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
27002: LD_EXP 57
27006: PUSH
27007: LD_EXP 89
27011: AND
27012: IFFALSE 27153
27014: GO 27016
27016: DISABLE
27017: LD_INT 0
27019: PPUSH
27020: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27021: LD_ADDR_VAR 0 2
27025: PUSH
27026: LD_INT 22
27028: PUSH
27029: LD_OWVAR 2
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: PUSH
27038: LD_INT 21
27040: PUSH
27041: LD_INT 1
27043: PUSH
27044: EMPTY
27045: LIST
27046: LIST
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PPUSH
27052: CALL_OW 69
27056: ST_TO_ADDR
// if not tmp then
27057: LD_VAR 0 2
27061: NOT
27062: IFFALSE 27066
// exit ;
27064: GO 27153
// un := tmp [ rand ( 1 , tmp ) ] ;
27066: LD_ADDR_VAR 0 1
27070: PUSH
27071: LD_VAR 0 2
27075: PUSH
27076: LD_INT 1
27078: PPUSH
27079: LD_VAR 0 2
27083: PPUSH
27084: CALL_OW 12
27088: ARRAY
27089: ST_TO_ADDR
// SetSide ( un , 0 ) ;
27090: LD_VAR 0 1
27094: PPUSH
27095: LD_INT 0
27097: PPUSH
27098: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
27102: LD_VAR 0 1
27106: PPUSH
27107: LD_OWVAR 3
27111: PUSH
27112: LD_VAR 0 1
27116: DIFF
27117: PPUSH
27118: LD_VAR 0 1
27122: PPUSH
27123: CALL_OW 74
27127: PPUSH
27128: CALL_OW 115
// wait ( 0 0$20 ) ;
27132: LD_INT 700
27134: PPUSH
27135: CALL_OW 67
// SetSide ( un , your_side ) ;
27139: LD_VAR 0 1
27143: PPUSH
27144: LD_OWVAR 2
27148: PPUSH
27149: CALL_OW 235
// end ;
27153: PPOPN 2
27155: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
27156: LD_EXP 57
27160: PUSH
27161: LD_EXP 90
27165: AND
27166: IFFALSE 27272
27168: GO 27170
27170: DISABLE
27171: LD_INT 0
27173: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27174: LD_ADDR_VAR 0 1
27178: PUSH
27179: LD_INT 22
27181: PUSH
27182: LD_OWVAR 2
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 2
27193: PUSH
27194: LD_INT 30
27196: PUSH
27197: LD_INT 0
27199: PUSH
27200: EMPTY
27201: LIST
27202: LIST
27203: PUSH
27204: LD_INT 30
27206: PUSH
27207: LD_INT 1
27209: PUSH
27210: EMPTY
27211: LIST
27212: LIST
27213: PUSH
27214: EMPTY
27215: LIST
27216: LIST
27217: LIST
27218: PUSH
27219: EMPTY
27220: LIST
27221: LIST
27222: PPUSH
27223: CALL_OW 69
27227: ST_TO_ADDR
// if not depot then
27228: LD_VAR 0 1
27232: NOT
27233: IFFALSE 27237
// exit ;
27235: GO 27272
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
27237: LD_VAR 0 1
27241: PUSH
27242: LD_INT 1
27244: ARRAY
27245: PPUSH
27246: CALL_OW 250
27250: PPUSH
27251: LD_VAR 0 1
27255: PUSH
27256: LD_INT 1
27258: ARRAY
27259: PPUSH
27260: CALL_OW 251
27264: PPUSH
27265: LD_INT 70
27267: PPUSH
27268: CALL_OW 495
// end ;
27272: PPOPN 1
27274: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
27275: LD_EXP 57
27279: PUSH
27280: LD_EXP 91
27284: AND
27285: IFFALSE 27496
27287: GO 27289
27289: DISABLE
27290: LD_INT 0
27292: PPUSH
27293: PPUSH
27294: PPUSH
27295: PPUSH
27296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27297: LD_ADDR_VAR 0 5
27301: PUSH
27302: LD_INT 22
27304: PUSH
27305: LD_OWVAR 2
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 21
27316: PUSH
27317: LD_INT 1
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: PPUSH
27328: CALL_OW 69
27332: ST_TO_ADDR
// if not tmp then
27333: LD_VAR 0 5
27337: NOT
27338: IFFALSE 27342
// exit ;
27340: GO 27496
// for i in tmp do
27342: LD_ADDR_VAR 0 1
27346: PUSH
27347: LD_VAR 0 5
27351: PUSH
27352: FOR_IN
27353: IFFALSE 27494
// begin d := rand ( 0 , 5 ) ;
27355: LD_ADDR_VAR 0 4
27359: PUSH
27360: LD_INT 0
27362: PPUSH
27363: LD_INT 5
27365: PPUSH
27366: CALL_OW 12
27370: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
27371: LD_ADDR_VAR 0 2
27375: PUSH
27376: LD_VAR 0 1
27380: PPUSH
27381: CALL_OW 250
27385: PPUSH
27386: LD_VAR 0 4
27390: PPUSH
27391: LD_INT 3
27393: PPUSH
27394: LD_INT 12
27396: PPUSH
27397: CALL_OW 12
27401: PPUSH
27402: CALL_OW 272
27406: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
27407: LD_ADDR_VAR 0 3
27411: PUSH
27412: LD_VAR 0 1
27416: PPUSH
27417: CALL_OW 251
27421: PPUSH
27422: LD_VAR 0 4
27426: PPUSH
27427: LD_INT 3
27429: PPUSH
27430: LD_INT 12
27432: PPUSH
27433: CALL_OW 12
27437: PPUSH
27438: CALL_OW 273
27442: ST_TO_ADDR
// if ValidHex ( x , y ) then
27443: LD_VAR 0 2
27447: PPUSH
27448: LD_VAR 0 3
27452: PPUSH
27453: CALL_OW 488
27457: IFFALSE 27492
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
27459: LD_VAR 0 1
27463: PPUSH
27464: LD_VAR 0 2
27468: PPUSH
27469: LD_VAR 0 3
27473: PPUSH
27474: LD_INT 3
27476: PPUSH
27477: LD_INT 6
27479: PPUSH
27480: CALL_OW 12
27484: PPUSH
27485: LD_INT 1
27487: PPUSH
27488: CALL_OW 483
// end ;
27492: GO 27352
27494: POP
27495: POP
// end ;
27496: PPOPN 5
27498: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27499: LD_EXP 57
27503: PUSH
27504: LD_EXP 92
27508: AND
27509: IFFALSE 27603
27511: GO 27513
27513: DISABLE
27514: LD_INT 0
27516: PPUSH
27517: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27518: LD_ADDR_VAR 0 2
27522: PUSH
27523: LD_INT 22
27525: PUSH
27526: LD_OWVAR 2
27530: PUSH
27531: EMPTY
27532: LIST
27533: LIST
27534: PUSH
27535: LD_INT 32
27537: PUSH
27538: LD_INT 1
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: PUSH
27545: LD_INT 21
27547: PUSH
27548: LD_INT 2
27550: PUSH
27551: EMPTY
27552: LIST
27553: LIST
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: LIST
27559: PPUSH
27560: CALL_OW 69
27564: ST_TO_ADDR
// if not tmp then
27565: LD_VAR 0 2
27569: NOT
27570: IFFALSE 27574
// exit ;
27572: GO 27603
// for i in tmp do
27574: LD_ADDR_VAR 0 1
27578: PUSH
27579: LD_VAR 0 2
27583: PUSH
27584: FOR_IN
27585: IFFALSE 27601
// SetFuel ( i , 0 ) ;
27587: LD_VAR 0 1
27591: PPUSH
27592: LD_INT 0
27594: PPUSH
27595: CALL_OW 240
27599: GO 27584
27601: POP
27602: POP
// end ;
27603: PPOPN 2
27605: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27606: LD_EXP 57
27610: PUSH
27611: LD_EXP 93
27615: AND
27616: IFFALSE 27682
27618: GO 27620
27620: DISABLE
27621: LD_INT 0
27623: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27624: LD_ADDR_VAR 0 1
27628: PUSH
27629: LD_INT 22
27631: PUSH
27632: LD_OWVAR 2
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: PUSH
27641: LD_INT 30
27643: PUSH
27644: LD_INT 29
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PPUSH
27655: CALL_OW 69
27659: ST_TO_ADDR
// if not tmp then
27660: LD_VAR 0 1
27664: NOT
27665: IFFALSE 27669
// exit ;
27667: GO 27682
// DestroyUnit ( tmp [ 1 ] ) ;
27669: LD_VAR 0 1
27673: PUSH
27674: LD_INT 1
27676: ARRAY
27677: PPUSH
27678: CALL_OW 65
// end ;
27682: PPOPN 1
27684: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27685: LD_EXP 57
27689: PUSH
27690: LD_EXP 95
27694: AND
27695: IFFALSE 27824
27697: GO 27699
27699: DISABLE
27700: LD_INT 0
27702: PPUSH
// begin uc_side := 0 ;
27703: LD_ADDR_OWVAR 20
27707: PUSH
27708: LD_INT 0
27710: ST_TO_ADDR
// uc_nation := nation_arabian ;
27711: LD_ADDR_OWVAR 21
27715: PUSH
27716: LD_INT 2
27718: ST_TO_ADDR
// hc_gallery :=  ;
27719: LD_ADDR_OWVAR 33
27723: PUSH
27724: LD_STRING 
27726: ST_TO_ADDR
// hc_name :=  ;
27727: LD_ADDR_OWVAR 26
27731: PUSH
27732: LD_STRING 
27734: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27735: LD_INT 1
27737: PPUSH
27738: LD_INT 11
27740: PPUSH
27741: LD_INT 10
27743: PPUSH
27744: CALL_OW 380
// un := CreateHuman ;
27748: LD_ADDR_VAR 0 1
27752: PUSH
27753: CALL_OW 44
27757: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27758: LD_VAR 0 1
27762: PPUSH
27763: LD_INT 1
27765: PPUSH
27766: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27770: LD_INT 35
27772: PPUSH
27773: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27777: LD_VAR 0 1
27781: PPUSH
27782: LD_INT 22
27784: PUSH
27785: LD_OWVAR 2
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PPUSH
27794: CALL_OW 69
27798: PPUSH
27799: LD_VAR 0 1
27803: PPUSH
27804: CALL_OW 74
27808: PPUSH
27809: CALL_OW 115
// until IsDead ( un ) ;
27813: LD_VAR 0 1
27817: PPUSH
27818: CALL_OW 301
27822: IFFALSE 27770
// end ;
27824: PPOPN 1
27826: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27827: LD_EXP 57
27831: PUSH
27832: LD_EXP 97
27836: AND
27837: IFFALSE 27849
27839: GO 27841
27841: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27842: LD_STRING earthquake(getX(game), 0, 32)
27844: PPUSH
27845: CALL_OW 559
27849: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27850: LD_EXP 57
27854: PUSH
27855: LD_EXP 98
27859: AND
27860: IFFALSE 27951
27862: GO 27864
27864: DISABLE
27865: LD_INT 0
27867: PPUSH
// begin enable ;
27868: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27869: LD_ADDR_VAR 0 1
27873: PUSH
27874: LD_INT 22
27876: PUSH
27877: LD_OWVAR 2
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 21
27888: PUSH
27889: LD_INT 2
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 33
27898: PUSH
27899: LD_INT 3
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: LIST
27910: PPUSH
27911: CALL_OW 69
27915: ST_TO_ADDR
// if not tmp then
27916: LD_VAR 0 1
27920: NOT
27921: IFFALSE 27925
// exit ;
27923: GO 27951
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27925: LD_VAR 0 1
27929: PUSH
27930: LD_INT 1
27932: PPUSH
27933: LD_VAR 0 1
27937: PPUSH
27938: CALL_OW 12
27942: ARRAY
27943: PPUSH
27944: LD_INT 1
27946: PPUSH
27947: CALL_OW 234
// end ;
27951: PPOPN 1
27953: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27954: LD_EXP 57
27958: PUSH
27959: LD_EXP 99
27963: AND
27964: IFFALSE 28105
27966: GO 27968
27968: DISABLE
27969: LD_INT 0
27971: PPUSH
27972: PPUSH
27973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27974: LD_ADDR_VAR 0 3
27978: PUSH
27979: LD_INT 22
27981: PUSH
27982: LD_OWVAR 2
27986: PUSH
27987: EMPTY
27988: LIST
27989: LIST
27990: PUSH
27991: LD_INT 25
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: PPUSH
28005: CALL_OW 69
28009: ST_TO_ADDR
// if not tmp then
28010: LD_VAR 0 3
28014: NOT
28015: IFFALSE 28019
// exit ;
28017: GO 28105
// un := tmp [ rand ( 1 , tmp ) ] ;
28019: LD_ADDR_VAR 0 2
28023: PUSH
28024: LD_VAR 0 3
28028: PUSH
28029: LD_INT 1
28031: PPUSH
28032: LD_VAR 0 3
28036: PPUSH
28037: CALL_OW 12
28041: ARRAY
28042: ST_TO_ADDR
// if Crawls ( un ) then
28043: LD_VAR 0 2
28047: PPUSH
28048: CALL_OW 318
28052: IFFALSE 28063
// ComWalk ( un ) ;
28054: LD_VAR 0 2
28058: PPUSH
28059: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
28063: LD_VAR 0 2
28067: PPUSH
28068: LD_INT 9
28070: PPUSH
28071: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
28075: LD_INT 28
28077: PPUSH
28078: LD_OWVAR 2
28082: PPUSH
28083: LD_INT 2
28085: PPUSH
28086: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
28090: LD_INT 29
28092: PPUSH
28093: LD_OWVAR 2
28097: PPUSH
28098: LD_INT 2
28100: PPUSH
28101: CALL_OW 322
// end ;
28105: PPOPN 3
28107: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
28108: LD_EXP 57
28112: PUSH
28113: LD_EXP 100
28117: AND
28118: IFFALSE 28229
28120: GO 28122
28122: DISABLE
28123: LD_INT 0
28125: PPUSH
28126: PPUSH
28127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28128: LD_ADDR_VAR 0 3
28132: PUSH
28133: LD_INT 22
28135: PUSH
28136: LD_OWVAR 2
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 25
28147: PUSH
28148: LD_INT 1
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PPUSH
28159: CALL_OW 69
28163: ST_TO_ADDR
// if not tmp then
28164: LD_VAR 0 3
28168: NOT
28169: IFFALSE 28173
// exit ;
28171: GO 28229
// un := tmp [ rand ( 1 , tmp ) ] ;
28173: LD_ADDR_VAR 0 2
28177: PUSH
28178: LD_VAR 0 3
28182: PUSH
28183: LD_INT 1
28185: PPUSH
28186: LD_VAR 0 3
28190: PPUSH
28191: CALL_OW 12
28195: ARRAY
28196: ST_TO_ADDR
// if Crawls ( un ) then
28197: LD_VAR 0 2
28201: PPUSH
28202: CALL_OW 318
28206: IFFALSE 28217
// ComWalk ( un ) ;
28208: LD_VAR 0 2
28212: PPUSH
28213: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28217: LD_VAR 0 2
28221: PPUSH
28222: LD_INT 8
28224: PPUSH
28225: CALL_OW 336
// end ;
28229: PPOPN 3
28231: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
28232: LD_EXP 57
28236: PUSH
28237: LD_EXP 101
28241: AND
28242: IFFALSE 28386
28244: GO 28246
28246: DISABLE
28247: LD_INT 0
28249: PPUSH
28250: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
28251: LD_ADDR_VAR 0 2
28255: PUSH
28256: LD_INT 22
28258: PUSH
28259: LD_OWVAR 2
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 21
28270: PUSH
28271: LD_INT 2
28273: PUSH
28274: EMPTY
28275: LIST
28276: LIST
28277: PUSH
28278: LD_INT 2
28280: PUSH
28281: LD_INT 34
28283: PUSH
28284: LD_INT 12
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 34
28293: PUSH
28294: LD_INT 51
28296: PUSH
28297: EMPTY
28298: LIST
28299: LIST
28300: PUSH
28301: LD_INT 34
28303: PUSH
28304: LD_INT 32
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: LIST
28315: LIST
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: LIST
28321: PPUSH
28322: CALL_OW 69
28326: ST_TO_ADDR
// if not tmp then
28327: LD_VAR 0 2
28331: NOT
28332: IFFALSE 28336
// exit ;
28334: GO 28386
// for i in tmp do
28336: LD_ADDR_VAR 0 1
28340: PUSH
28341: LD_VAR 0 2
28345: PUSH
28346: FOR_IN
28347: IFFALSE 28384
// if GetCargo ( i , mat_artifact ) = 0 then
28349: LD_VAR 0 1
28353: PPUSH
28354: LD_INT 4
28356: PPUSH
28357: CALL_OW 289
28361: PUSH
28362: LD_INT 0
28364: EQUAL
28365: IFFALSE 28382
// SetCargo ( i , mat_siberit , 100 ) ;
28367: LD_VAR 0 1
28371: PPUSH
28372: LD_INT 3
28374: PPUSH
28375: LD_INT 100
28377: PPUSH
28378: CALL_OW 290
28382: GO 28346
28384: POP
28385: POP
// end ;
28386: PPOPN 2
28388: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
28389: LD_EXP 57
28393: PUSH
28394: LD_EXP 102
28398: AND
28399: IFFALSE 28582
28401: GO 28403
28403: DISABLE
28404: LD_INT 0
28406: PPUSH
28407: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
28408: LD_ADDR_VAR 0 2
28412: PUSH
28413: LD_INT 22
28415: PUSH
28416: LD_OWVAR 2
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PPUSH
28425: CALL_OW 69
28429: ST_TO_ADDR
// if not tmp then
28430: LD_VAR 0 2
28434: NOT
28435: IFFALSE 28439
// exit ;
28437: GO 28582
// for i := 1 to 2 do
28439: LD_ADDR_VAR 0 1
28443: PUSH
28444: DOUBLE
28445: LD_INT 1
28447: DEC
28448: ST_TO_ADDR
28449: LD_INT 2
28451: PUSH
28452: FOR_TO
28453: IFFALSE 28580
// begin uc_side := your_side ;
28455: LD_ADDR_OWVAR 20
28459: PUSH
28460: LD_OWVAR 2
28464: ST_TO_ADDR
// uc_nation := nation_american ;
28465: LD_ADDR_OWVAR 21
28469: PUSH
28470: LD_INT 1
28472: ST_TO_ADDR
// vc_chassis := us_morphling ;
28473: LD_ADDR_OWVAR 37
28477: PUSH
28478: LD_INT 5
28480: ST_TO_ADDR
// vc_engine := engine_siberite ;
28481: LD_ADDR_OWVAR 39
28485: PUSH
28486: LD_INT 3
28488: ST_TO_ADDR
// vc_control := control_computer ;
28489: LD_ADDR_OWVAR 38
28493: PUSH
28494: LD_INT 3
28496: ST_TO_ADDR
// vc_weapon := us_double_laser ;
28497: LD_ADDR_OWVAR 40
28501: PUSH
28502: LD_INT 10
28504: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
28505: LD_VAR 0 2
28509: PUSH
28510: LD_INT 1
28512: ARRAY
28513: PPUSH
28514: CALL_OW 310
28518: NOT
28519: IFFALSE 28566
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
28521: CALL_OW 45
28525: PPUSH
28526: LD_VAR 0 2
28530: PUSH
28531: LD_INT 1
28533: ARRAY
28534: PPUSH
28535: CALL_OW 250
28539: PPUSH
28540: LD_VAR 0 2
28544: PUSH
28545: LD_INT 1
28547: ARRAY
28548: PPUSH
28549: CALL_OW 251
28553: PPUSH
28554: LD_INT 12
28556: PPUSH
28557: LD_INT 1
28559: PPUSH
28560: CALL_OW 50
28564: GO 28578
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
28566: CALL_OW 45
28570: PPUSH
28571: LD_INT 1
28573: PPUSH
28574: CALL_OW 51
// end ;
28578: GO 28452
28580: POP
28581: POP
// end ;
28582: PPOPN 2
28584: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28585: LD_EXP 57
28589: PUSH
28590: LD_EXP 103
28594: AND
28595: IFFALSE 28817
28597: GO 28599
28599: DISABLE
28600: LD_INT 0
28602: PPUSH
28603: PPUSH
28604: PPUSH
28605: PPUSH
28606: PPUSH
28607: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28608: LD_ADDR_VAR 0 6
28612: PUSH
28613: LD_INT 22
28615: PUSH
28616: LD_OWVAR 2
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PUSH
28625: LD_INT 21
28627: PUSH
28628: LD_INT 1
28630: PUSH
28631: EMPTY
28632: LIST
28633: LIST
28634: PUSH
28635: LD_INT 3
28637: PUSH
28638: LD_INT 23
28640: PUSH
28641: LD_INT 0
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: EMPTY
28649: LIST
28650: LIST
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: LIST
28656: PPUSH
28657: CALL_OW 69
28661: ST_TO_ADDR
// if not tmp then
28662: LD_VAR 0 6
28666: NOT
28667: IFFALSE 28671
// exit ;
28669: GO 28817
// s1 := rand ( 1 , 4 ) ;
28671: LD_ADDR_VAR 0 2
28675: PUSH
28676: LD_INT 1
28678: PPUSH
28679: LD_INT 4
28681: PPUSH
28682: CALL_OW 12
28686: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28687: LD_ADDR_VAR 0 4
28691: PUSH
28692: LD_VAR 0 6
28696: PUSH
28697: LD_INT 1
28699: ARRAY
28700: PPUSH
28701: LD_VAR 0 2
28705: PPUSH
28706: CALL_OW 259
28710: ST_TO_ADDR
// if s1 = 1 then
28711: LD_VAR 0 2
28715: PUSH
28716: LD_INT 1
28718: EQUAL
28719: IFFALSE 28739
// s2 := rand ( 2 , 4 ) else
28721: LD_ADDR_VAR 0 3
28725: PUSH
28726: LD_INT 2
28728: PPUSH
28729: LD_INT 4
28731: PPUSH
28732: CALL_OW 12
28736: ST_TO_ADDR
28737: GO 28747
// s2 := 1 ;
28739: LD_ADDR_VAR 0 3
28743: PUSH
28744: LD_INT 1
28746: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28747: LD_ADDR_VAR 0 5
28751: PUSH
28752: LD_VAR 0 6
28756: PUSH
28757: LD_INT 1
28759: ARRAY
28760: PPUSH
28761: LD_VAR 0 3
28765: PPUSH
28766: CALL_OW 259
28770: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28771: LD_VAR 0 6
28775: PUSH
28776: LD_INT 1
28778: ARRAY
28779: PPUSH
28780: LD_VAR 0 2
28784: PPUSH
28785: LD_VAR 0 5
28789: PPUSH
28790: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28794: LD_VAR 0 6
28798: PUSH
28799: LD_INT 1
28801: ARRAY
28802: PPUSH
28803: LD_VAR 0 3
28807: PPUSH
28808: LD_VAR 0 4
28812: PPUSH
28813: CALL_OW 237
// end ;
28817: PPOPN 6
28819: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28820: LD_EXP 57
28824: PUSH
28825: LD_EXP 104
28829: AND
28830: IFFALSE 28909
28832: GO 28834
28834: DISABLE
28835: LD_INT 0
28837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28838: LD_ADDR_VAR 0 1
28842: PUSH
28843: LD_INT 22
28845: PUSH
28846: LD_OWVAR 2
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 30
28857: PUSH
28858: LD_INT 3
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: EMPTY
28866: LIST
28867: LIST
28868: PPUSH
28869: CALL_OW 69
28873: ST_TO_ADDR
// if not tmp then
28874: LD_VAR 0 1
28878: NOT
28879: IFFALSE 28883
// exit ;
28881: GO 28909
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28883: LD_VAR 0 1
28887: PUSH
28888: LD_INT 1
28890: PPUSH
28891: LD_VAR 0 1
28895: PPUSH
28896: CALL_OW 12
28900: ARRAY
28901: PPUSH
28902: LD_INT 1
28904: PPUSH
28905: CALL_OW 234
// end ;
28909: PPOPN 1
28911: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28912: LD_EXP 57
28916: PUSH
28917: LD_EXP 105
28921: AND
28922: IFFALSE 29034
28924: GO 28926
28926: DISABLE
28927: LD_INT 0
28929: PPUSH
28930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28931: LD_ADDR_VAR 0 2
28935: PUSH
28936: LD_INT 22
28938: PUSH
28939: LD_OWVAR 2
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 2
28950: PUSH
28951: LD_INT 30
28953: PUSH
28954: LD_INT 27
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 30
28963: PUSH
28964: LD_INT 26
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 30
28973: PUSH
28974: LD_INT 28
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: EMPTY
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PPUSH
28991: CALL_OW 69
28995: ST_TO_ADDR
// if not tmp then
28996: LD_VAR 0 2
29000: NOT
29001: IFFALSE 29005
// exit ;
29003: GO 29034
// for i in tmp do
29005: LD_ADDR_VAR 0 1
29009: PUSH
29010: LD_VAR 0 2
29014: PUSH
29015: FOR_IN
29016: IFFALSE 29032
// SetLives ( i , 1 ) ;
29018: LD_VAR 0 1
29022: PPUSH
29023: LD_INT 1
29025: PPUSH
29026: CALL_OW 234
29030: GO 29015
29032: POP
29033: POP
// end ;
29034: PPOPN 2
29036: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
29037: LD_EXP 57
29041: PUSH
29042: LD_EXP 106
29046: AND
29047: IFFALSE 29321
29049: GO 29051
29051: DISABLE
29052: LD_INT 0
29054: PPUSH
29055: PPUSH
29056: PPUSH
// begin i := rand ( 1 , 7 ) ;
29057: LD_ADDR_VAR 0 1
29061: PUSH
29062: LD_INT 1
29064: PPUSH
29065: LD_INT 7
29067: PPUSH
29068: CALL_OW 12
29072: ST_TO_ADDR
// case i of 1 :
29073: LD_VAR 0 1
29077: PUSH
29078: LD_INT 1
29080: DOUBLE
29081: EQUAL
29082: IFTRUE 29086
29084: GO 29096
29086: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
29087: LD_STRING earthquake(getX(game), 0, 32)
29089: PPUSH
29090: CALL_OW 559
29094: GO 29321
29096: LD_INT 2
29098: DOUBLE
29099: EQUAL
29100: IFTRUE 29104
29102: GO 29118
29104: POP
// begin ToLua ( displayStucuk(); ) ;
29105: LD_STRING displayStucuk();
29107: PPUSH
29108: CALL_OW 559
// ResetFog ;
29112: CALL_OW 335
// end ; 3 :
29116: GO 29321
29118: LD_INT 3
29120: DOUBLE
29121: EQUAL
29122: IFTRUE 29126
29124: GO 29230
29126: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29127: LD_ADDR_VAR 0 2
29131: PUSH
29132: LD_INT 22
29134: PUSH
29135: LD_OWVAR 2
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PUSH
29144: LD_INT 25
29146: PUSH
29147: LD_INT 1
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PPUSH
29158: CALL_OW 69
29162: ST_TO_ADDR
// if not tmp then
29163: LD_VAR 0 2
29167: NOT
29168: IFFALSE 29172
// exit ;
29170: GO 29321
// un := tmp [ rand ( 1 , tmp ) ] ;
29172: LD_ADDR_VAR 0 3
29176: PUSH
29177: LD_VAR 0 2
29181: PUSH
29182: LD_INT 1
29184: PPUSH
29185: LD_VAR 0 2
29189: PPUSH
29190: CALL_OW 12
29194: ARRAY
29195: ST_TO_ADDR
// if Crawls ( un ) then
29196: LD_VAR 0 3
29200: PPUSH
29201: CALL_OW 318
29205: IFFALSE 29216
// ComWalk ( un ) ;
29207: LD_VAR 0 3
29211: PPUSH
29212: CALL_OW 138
// SetClass ( un , class_mortar ) ;
29216: LD_VAR 0 3
29220: PPUSH
29221: LD_INT 8
29223: PPUSH
29224: CALL_OW 336
// end ; 4 :
29228: GO 29321
29230: LD_INT 4
29232: DOUBLE
29233: EQUAL
29234: IFTRUE 29238
29236: GO 29299
29238: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
29239: LD_ADDR_VAR 0 2
29243: PUSH
29244: LD_INT 22
29246: PUSH
29247: LD_OWVAR 2
29251: PUSH
29252: EMPTY
29253: LIST
29254: LIST
29255: PUSH
29256: LD_INT 30
29258: PUSH
29259: LD_INT 29
29261: PUSH
29262: EMPTY
29263: LIST
29264: LIST
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PPUSH
29270: CALL_OW 69
29274: ST_TO_ADDR
// if not tmp then
29275: LD_VAR 0 2
29279: NOT
29280: IFFALSE 29284
// exit ;
29282: GO 29321
// DestroyUnit ( tmp [ 1 ] ) ;
29284: LD_VAR 0 2
29288: PUSH
29289: LD_INT 1
29291: ARRAY
29292: PPUSH
29293: CALL_OW 65
// end ; 5 .. 7 :
29297: GO 29321
29299: LD_INT 5
29301: DOUBLE
29302: GREATEREQUAL
29303: IFFALSE 29311
29305: LD_INT 7
29307: DOUBLE
29308: LESSEQUAL
29309: IFTRUE 29313
29311: GO 29320
29313: POP
// StreamSibBomb ; end ;
29314: CALL 25571 0 0
29318: GO 29321
29320: POP
// end ;
29321: PPOPN 3
29323: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
29324: LD_EXP 57
29328: PUSH
29329: LD_EXP 107
29333: AND
29334: IFFALSE 29490
29336: GO 29338
29338: DISABLE
29339: LD_INT 0
29341: PPUSH
29342: PPUSH
29343: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
29344: LD_ADDR_VAR 0 2
29348: PUSH
29349: LD_INT 81
29351: PUSH
29352: LD_OWVAR 2
29356: PUSH
29357: EMPTY
29358: LIST
29359: LIST
29360: PUSH
29361: LD_INT 2
29363: PUSH
29364: LD_INT 21
29366: PUSH
29367: LD_INT 1
29369: PUSH
29370: EMPTY
29371: LIST
29372: LIST
29373: PUSH
29374: LD_INT 21
29376: PUSH
29377: LD_INT 2
29379: PUSH
29380: EMPTY
29381: LIST
29382: LIST
29383: PUSH
29384: EMPTY
29385: LIST
29386: LIST
29387: LIST
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PPUSH
29393: CALL_OW 69
29397: ST_TO_ADDR
// if not tmp then
29398: LD_VAR 0 2
29402: NOT
29403: IFFALSE 29407
// exit ;
29405: GO 29490
// p := 0 ;
29407: LD_ADDR_VAR 0 3
29411: PUSH
29412: LD_INT 0
29414: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29415: LD_INT 35
29417: PPUSH
29418: CALL_OW 67
// p := p + 1 ;
29422: LD_ADDR_VAR 0 3
29426: PUSH
29427: LD_VAR 0 3
29431: PUSH
29432: LD_INT 1
29434: PLUS
29435: ST_TO_ADDR
// for i in tmp do
29436: LD_ADDR_VAR 0 1
29440: PUSH
29441: LD_VAR 0 2
29445: PUSH
29446: FOR_IN
29447: IFFALSE 29478
// if GetLives ( i ) < 1000 then
29449: LD_VAR 0 1
29453: PPUSH
29454: CALL_OW 256
29458: PUSH
29459: LD_INT 1000
29461: LESS
29462: IFFALSE 29476
// SetLives ( i , 1000 ) ;
29464: LD_VAR 0 1
29468: PPUSH
29469: LD_INT 1000
29471: PPUSH
29472: CALL_OW 234
29476: GO 29446
29478: POP
29479: POP
// until p > 20 ;
29480: LD_VAR 0 3
29484: PUSH
29485: LD_INT 20
29487: GREATER
29488: IFFALSE 29415
// end ;
29490: PPOPN 3
29492: END
// every 0 0$1 trigger StreamModeActive and sTime do
29493: LD_EXP 57
29497: PUSH
29498: LD_EXP 108
29502: AND
29503: IFFALSE 29538
29505: GO 29507
29507: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
29508: LD_INT 28
29510: PPUSH
29511: LD_OWVAR 2
29515: PPUSH
29516: LD_INT 2
29518: PPUSH
29519: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
29523: LD_INT 30
29525: PPUSH
29526: LD_OWVAR 2
29530: PPUSH
29531: LD_INT 2
29533: PPUSH
29534: CALL_OW 322
// end ;
29538: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
29539: LD_EXP 57
29543: PUSH
29544: LD_EXP 109
29548: AND
29549: IFFALSE 29670
29551: GO 29553
29553: DISABLE
29554: LD_INT 0
29556: PPUSH
29557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29558: LD_ADDR_VAR 0 2
29562: PUSH
29563: LD_INT 22
29565: PUSH
29566: LD_OWVAR 2
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 21
29577: PUSH
29578: LD_INT 1
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PUSH
29585: LD_INT 3
29587: PUSH
29588: LD_INT 23
29590: PUSH
29591: LD_INT 0
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: LIST
29606: PPUSH
29607: CALL_OW 69
29611: ST_TO_ADDR
// if not tmp then
29612: LD_VAR 0 2
29616: NOT
29617: IFFALSE 29621
// exit ;
29619: GO 29670
// for i in tmp do
29621: LD_ADDR_VAR 0 1
29625: PUSH
29626: LD_VAR 0 2
29630: PUSH
29631: FOR_IN
29632: IFFALSE 29668
// begin if Crawls ( i ) then
29634: LD_VAR 0 1
29638: PPUSH
29639: CALL_OW 318
29643: IFFALSE 29654
// ComWalk ( i ) ;
29645: LD_VAR 0 1
29649: PPUSH
29650: CALL_OW 138
// SetClass ( i , 2 ) ;
29654: LD_VAR 0 1
29658: PPUSH
29659: LD_INT 2
29661: PPUSH
29662: CALL_OW 336
// end ;
29666: GO 29631
29668: POP
29669: POP
// end ;
29670: PPOPN 2
29672: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29673: LD_EXP 57
29677: PUSH
29678: LD_EXP 110
29682: AND
29683: IFFALSE 29964
29685: GO 29687
29687: DISABLE
29688: LD_INT 0
29690: PPUSH
29691: PPUSH
29692: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29693: LD_OWVAR 2
29697: PPUSH
29698: LD_INT 9
29700: PPUSH
29701: LD_INT 1
29703: PPUSH
29704: LD_INT 1
29706: PPUSH
29707: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29711: LD_INT 9
29713: PPUSH
29714: LD_OWVAR 2
29718: PPUSH
29719: CALL_OW 343
// uc_side := 9 ;
29723: LD_ADDR_OWVAR 20
29727: PUSH
29728: LD_INT 9
29730: ST_TO_ADDR
// uc_nation := 2 ;
29731: LD_ADDR_OWVAR 21
29735: PUSH
29736: LD_INT 2
29738: ST_TO_ADDR
// hc_name := Dark Warrior ;
29739: LD_ADDR_OWVAR 26
29743: PUSH
29744: LD_STRING Dark Warrior
29746: ST_TO_ADDR
// hc_gallery :=  ;
29747: LD_ADDR_OWVAR 33
29751: PUSH
29752: LD_STRING 
29754: ST_TO_ADDR
// hc_noskilllimit := true ;
29755: LD_ADDR_OWVAR 76
29759: PUSH
29760: LD_INT 1
29762: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
29763: LD_ADDR_OWVAR 31
29767: PUSH
29768: LD_INT 30
29770: PUSH
29771: LD_INT 30
29773: PUSH
29774: LD_INT 30
29776: PUSH
29777: LD_INT 30
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: LIST
29784: LIST
29785: ST_TO_ADDR
// un := CreateHuman ;
29786: LD_ADDR_VAR 0 3
29790: PUSH
29791: CALL_OW 44
29795: ST_TO_ADDR
// hc_noskilllimit := false ;
29796: LD_ADDR_OWVAR 76
29800: PUSH
29801: LD_INT 0
29803: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29804: LD_VAR 0 3
29808: PPUSH
29809: LD_INT 1
29811: PPUSH
29812: CALL_OW 51
// p := 0 ;
29816: LD_ADDR_VAR 0 2
29820: PUSH
29821: LD_INT 0
29823: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29824: LD_INT 35
29826: PPUSH
29827: CALL_OW 67
// p := p + 1 ;
29831: LD_ADDR_VAR 0 2
29835: PUSH
29836: LD_VAR 0 2
29840: PUSH
29841: LD_INT 1
29843: PLUS
29844: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
29845: LD_VAR 0 3
29849: PPUSH
29850: CALL_OW 256
29854: PUSH
29855: LD_INT 1000
29857: LESS
29858: IFFALSE 29872
// SetLives ( un , 1000 ) ;
29860: LD_VAR 0 3
29864: PPUSH
29865: LD_INT 1000
29867: PPUSH
29868: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
29872: LD_VAR 0 3
29876: PPUSH
29877: LD_INT 81
29879: PUSH
29880: LD_OWVAR 2
29884: PUSH
29885: EMPTY
29886: LIST
29887: LIST
29888: PUSH
29889: LD_INT 91
29891: PUSH
29892: LD_VAR 0 3
29896: PUSH
29897: LD_INT 30
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: LIST
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PPUSH
29909: CALL_OW 69
29913: PPUSH
29914: LD_VAR 0 3
29918: PPUSH
29919: CALL_OW 74
29923: PPUSH
29924: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29928: LD_VAR 0 2
29932: PUSH
29933: LD_INT 60
29935: GREATER
29936: PUSH
29937: LD_VAR 0 3
29941: PPUSH
29942: CALL_OW 301
29946: OR
29947: IFFALSE 29824
// if un then
29949: LD_VAR 0 3
29953: IFFALSE 29964
// RemoveUnit ( un ) ;
29955: LD_VAR 0 3
29959: PPUSH
29960: CALL_OW 64
// end ; end_of_file
29964: PPOPN 3
29966: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29967: LD_INT 0
29969: PPUSH
29970: PPUSH
29971: PPUSH
29972: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29973: LD_VAR 0 1
29977: PPUSH
29978: CALL_OW 264
29982: PUSH
29983: LD_EXP 47
29987: EQUAL
29988: IFFALSE 30060
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29990: LD_INT 68
29992: PPUSH
29993: LD_VAR 0 1
29997: PPUSH
29998: CALL_OW 255
30002: PPUSH
30003: CALL_OW 321
30007: PUSH
30008: LD_INT 2
30010: EQUAL
30011: IFFALSE 30023
// eff := 70 else
30013: LD_ADDR_VAR 0 4
30017: PUSH
30018: LD_INT 70
30020: ST_TO_ADDR
30021: GO 30031
// eff := 30 ;
30023: LD_ADDR_VAR 0 4
30027: PUSH
30028: LD_INT 30
30030: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
30031: LD_VAR 0 1
30035: PPUSH
30036: CALL_OW 250
30040: PPUSH
30041: LD_VAR 0 1
30045: PPUSH
30046: CALL_OW 251
30050: PPUSH
30051: LD_VAR 0 4
30055: PPUSH
30056: CALL_OW 495
// end ; end ;
30060: LD_VAR 0 2
30064: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
30065: LD_INT 0
30067: PPUSH
// end ;
30068: LD_VAR 0 4
30072: RET
// export function SOS_Command ( cmd ) ; begin
30073: LD_INT 0
30075: PPUSH
// end ;
30076: LD_VAR 0 2
30080: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
30081: LD_VAR 0 1
30085: PUSH
30086: LD_INT 255
30088: EQUAL
30089: PUSH
30090: LD_VAR 0 2
30094: PPUSH
30095: CALL_OW 264
30099: PUSH
30100: LD_INT 14
30102: PUSH
30103: LD_INT 53
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: IN
30110: AND
30111: PUSH
30112: LD_VAR 0 4
30116: PPUSH
30117: LD_VAR 0 5
30121: PPUSH
30122: CALL_OW 488
30126: AND
30127: IFFALSE 30151
// CutTreeXYR ( unit , x , y , 12 ) ;
30129: LD_VAR 0 2
30133: PPUSH
30134: LD_VAR 0 4
30138: PPUSH
30139: LD_VAR 0 5
30143: PPUSH
30144: LD_INT 12
30146: PPUSH
30147: CALL 30154 0 4
// end ;
30151: PPOPN 5
30153: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
30154: LD_INT 0
30156: PPUSH
30157: PPUSH
30158: PPUSH
30159: PPUSH
30160: PPUSH
30161: PPUSH
30162: PPUSH
30163: PPUSH
30164: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
30165: LD_VAR 0 1
30169: NOT
30170: PUSH
30171: LD_VAR 0 2
30175: PPUSH
30176: LD_VAR 0 3
30180: PPUSH
30181: CALL_OW 488
30185: NOT
30186: OR
30187: PUSH
30188: LD_VAR 0 4
30192: NOT
30193: OR
30194: IFFALSE 30198
// exit ;
30196: GO 30538
// list := [ ] ;
30198: LD_ADDR_VAR 0 13
30202: PUSH
30203: EMPTY
30204: ST_TO_ADDR
// if x - r < 0 then
30205: LD_VAR 0 2
30209: PUSH
30210: LD_VAR 0 4
30214: MINUS
30215: PUSH
30216: LD_INT 0
30218: LESS
30219: IFFALSE 30231
// min_x := 0 else
30221: LD_ADDR_VAR 0 7
30225: PUSH
30226: LD_INT 0
30228: ST_TO_ADDR
30229: GO 30247
// min_x := x - r ;
30231: LD_ADDR_VAR 0 7
30235: PUSH
30236: LD_VAR 0 2
30240: PUSH
30241: LD_VAR 0 4
30245: MINUS
30246: ST_TO_ADDR
// if y - r < 0 then
30247: LD_VAR 0 3
30251: PUSH
30252: LD_VAR 0 4
30256: MINUS
30257: PUSH
30258: LD_INT 0
30260: LESS
30261: IFFALSE 30273
// min_y := 0 else
30263: LD_ADDR_VAR 0 8
30267: PUSH
30268: LD_INT 0
30270: ST_TO_ADDR
30271: GO 30289
// min_y := y - r ;
30273: LD_ADDR_VAR 0 8
30277: PUSH
30278: LD_VAR 0 3
30282: PUSH
30283: LD_VAR 0 4
30287: MINUS
30288: ST_TO_ADDR
// max_x := x + r ;
30289: LD_ADDR_VAR 0 9
30293: PUSH
30294: LD_VAR 0 2
30298: PUSH
30299: LD_VAR 0 4
30303: PLUS
30304: ST_TO_ADDR
// max_y := y + r ;
30305: LD_ADDR_VAR 0 10
30309: PUSH
30310: LD_VAR 0 3
30314: PUSH
30315: LD_VAR 0 4
30319: PLUS
30320: ST_TO_ADDR
// for _x = min_x to max_x do
30321: LD_ADDR_VAR 0 11
30325: PUSH
30326: DOUBLE
30327: LD_VAR 0 7
30331: DEC
30332: ST_TO_ADDR
30333: LD_VAR 0 9
30337: PUSH
30338: FOR_TO
30339: IFFALSE 30456
// for _y = min_y to max_y do
30341: LD_ADDR_VAR 0 12
30345: PUSH
30346: DOUBLE
30347: LD_VAR 0 8
30351: DEC
30352: ST_TO_ADDR
30353: LD_VAR 0 10
30357: PUSH
30358: FOR_TO
30359: IFFALSE 30452
// begin if not ValidHex ( _x , _y ) then
30361: LD_VAR 0 11
30365: PPUSH
30366: LD_VAR 0 12
30370: PPUSH
30371: CALL_OW 488
30375: NOT
30376: IFFALSE 30380
// continue ;
30378: GO 30358
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
30380: LD_VAR 0 11
30384: PPUSH
30385: LD_VAR 0 12
30389: PPUSH
30390: CALL_OW 351
30394: PUSH
30395: LD_VAR 0 11
30399: PPUSH
30400: LD_VAR 0 12
30404: PPUSH
30405: CALL_OW 554
30409: AND
30410: IFFALSE 30450
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
30412: LD_ADDR_VAR 0 13
30416: PUSH
30417: LD_VAR 0 13
30421: PPUSH
30422: LD_VAR 0 13
30426: PUSH
30427: LD_INT 1
30429: PLUS
30430: PPUSH
30431: LD_VAR 0 11
30435: PUSH
30436: LD_VAR 0 12
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PPUSH
30445: CALL_OW 2
30449: ST_TO_ADDR
// end ;
30450: GO 30358
30452: POP
30453: POP
30454: GO 30338
30456: POP
30457: POP
// if not list then
30458: LD_VAR 0 13
30462: NOT
30463: IFFALSE 30467
// exit ;
30465: GO 30538
// for i in list do
30467: LD_ADDR_VAR 0 6
30471: PUSH
30472: LD_VAR 0 13
30476: PUSH
30477: FOR_IN
30478: IFFALSE 30536
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
30480: LD_VAR 0 1
30484: PPUSH
30485: LD_STRING M
30487: PUSH
30488: LD_VAR 0 6
30492: PUSH
30493: LD_INT 1
30495: ARRAY
30496: PUSH
30497: LD_VAR 0 6
30501: PUSH
30502: LD_INT 2
30504: ARRAY
30505: PUSH
30506: LD_INT 0
30508: PUSH
30509: LD_INT 0
30511: PUSH
30512: LD_INT 0
30514: PUSH
30515: LD_INT 0
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: PUSH
30527: EMPTY
30528: LIST
30529: PPUSH
30530: CALL_OW 447
30534: GO 30477
30536: POP
30537: POP
// end ;
30538: LD_VAR 0 5
30542: RET
