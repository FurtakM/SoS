// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// debug := 0 ;
  21: LD_ADDR_EXP 1
  25: PUSH
  26: LD_INT 0
  28: ST_TO_ADDR
// if debug then
  29: LD_EXP 1
  33: IFFALSE 55
// begin display_strings := Debug mode active! ;
  35: LD_ADDR_OWVAR 47
  39: PUSH
  40: LD_STRING Debug mode active!
  42: ST_TO_ADDR
// Your_Side := 1 ;
  43: LD_ADDR_OWVAR 2
  47: PUSH
  48: LD_INT 1
  50: ST_TO_ADDR
// TurnFogOff ;
  51: CALL_OW 537
// end ; Difficulty := GetMultiplayerSetting ( 0 ) ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 426
  67: ST_TO_ADDR
// if not Difficulty then
  68: LD_OWVAR 67
  72: NOT
  73: IFFALSE 83
// Difficulty := 2 ;
  75: LD_ADDR_OWVAR 67
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// PrepareTigers ( tiger_area ) ;
  83: LD_INT 8
  85: PPUSH
  86: CALL 10764 0 1
// PrepareApemans ( apeman_area ) ;
  90: LD_INT 9
  92: PPUSH
  93: CALL 10894 0 1
// PrepareRussian ;
  97: CALL 117 0 0
// PrepareAmerican ;
 101: CALL 12301 0 0
// if not debug then
 105: LD_EXP 1
 109: NOT
 110: IFFALSE 116
// Action ;
 112: CALL 14530 0 0
// end ;
 116: END
// export debug ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 117: LD_INT 0
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
// uc_side := 3 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 3
 130: ST_TO_ADDR
// uc_nation := nation_russian ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 3
 138: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 139: LD_ADDR_VAR 0 2
 143: PUSH
 144: LD_INT 6
 146: PUSH
 147: LD_INT 7
 149: PUSH
 150: LD_INT 8
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: LIST
 157: PUSH
 158: LD_OWVAR 67
 162: ARRAY
 163: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 164: LD_INT 2
 166: PPUSH
 167: CALL_OW 274
 171: PPUSH
 172: LD_INT 1
 174: PPUSH
 175: LD_INT 1200
 177: PPUSH
 178: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 182: LD_INT 2
 184: PPUSH
 185: CALL_OW 274
 189: PPUSH
 190: LD_INT 2
 192: PPUSH
 193: LD_INT 600
 195: PPUSH
 196: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 200: LD_INT 33
 202: PPUSH
 203: LD_INT 4
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 213: LD_INT 37
 215: PPUSH
 216: LD_INT 3
 218: PPUSH
 219: LD_INT 3
 221: PPUSH
 222: CALL_OW 441
// ru_force := [ ] ;
 226: LD_ADDR_EXP 2
 230: PUSH
 231: EMPTY
 232: ST_TO_ADDR
// ru_group1 := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// ru_group2 := [ ] ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: EMPTY
 246: ST_TO_ADDR
// ru_reserve := [ ] ;
 247: LD_ADDR_EXP 8
 251: PUSH
 252: EMPTY
 253: ST_TO_ADDR
// ru_attack_list := [ ] ;
 254: LD_ADDR_EXP 9
 258: PUSH
 259: EMPTY
 260: ST_TO_ADDR
// ru_protector := [ ] ;
 261: LD_ADDR_EXP 16
 265: PUSH
 266: EMPTY
 267: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 268: LD_ADDR_EXP 5
 272: PUSH
 273: LD_INT 48
 275: PUSH
 276: LD_INT 49
 278: PUSH
 279: LD_INT 50
 281: PUSH
 282: LD_INT 20
 284: PUSH
 285: LD_INT 1
 287: PUSH
 288: LD_INT 51
 290: PUSH
 291: LD_INT 52
 293: PUSH
 294: LD_INT 69
 296: PUSH
 297: LD_INT 39
 299: PUSH
 300: LD_INT 34
 302: PUSH
 303: LD_INT 40
 305: PUSH
 306: LD_INT 53
 308: PUSH
 309: LD_INT 71
 311: PUSH
 312: LD_INT 57
 314: PUSH
 315: LD_INT 58
 317: PUSH
 318: LD_INT 44
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: LD_INT 27
 326: PUSH
 327: LD_INT 23
 329: PUSH
 330: LD_INT 33
 332: PUSH
 333: LD_INT 59
 335: PUSH
 336: LD_INT 54
 338: PUSH
 339: LD_INT 55
 341: PUSH
 342: LD_INT 56
 344: PUSH
 345: LD_INT 63
 347: PUSH
 348: LD_INT 64
 350: PUSH
 351: LD_INT 65
 353: PUSH
 354: LD_INT 30
 356: PUSH
 357: LD_INT 31
 359: PUSH
 360: LD_INT 21
 362: PUSH
 363: LD_INT 22
 365: PUSH
 366: LD_INT 25
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 403: LD_ADDR_EXP 6
 407: PUSH
 408: LD_INT 3
 410: PPUSH
 411: LD_INT 33
 413: PPUSH
 414: CALL 8879 0 2
 418: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 419: LD_ADDR_EXP 7
 423: PUSH
 424: LD_INT 46
 426: PUSH
 427: LD_INT 45
 429: PUSH
 430: LD_INT 47
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 438: LD_ADDR_EXP 12
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 36
 448: PUSH
 449: LD_INT 8
 451: PUSH
 452: LD_INT 3
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// ru_buildings := [ ] ;
 461: LD_ADDR_EXP 13
 465: PUSH
 466: EMPTY
 467: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 468: LD_ADDR_EXP 10
 472: PUSH
 473: LD_INT 3
 475: PPUSH
 476: CALL 6928 0 1
 480: PUSH
 481: LD_INT 1
 483: ARRAY
 484: PPUSH
 485: CALL_OW 250
 489: PUSH
 490: LD_INT 3
 492: PPUSH
 493: CALL 6928 0 1
 497: PUSH
 498: LD_INT 1
 500: ARRAY
 501: PPUSH
 502: CALL_OW 251
 506: PUSH
 507: LD_INT 3
 509: PPUSH
 510: CALL 6928 0 1
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: CALL_OW 254
 523: PUSH
 524: LD_INT 3
 526: PPUSH
 527: CALL 6928 0 1
 531: PUSH
 532: LD_INT 1
 534: ARRAY
 535: PPUSH
 536: LD_INT 1
 538: PPUSH
 539: CALL_OW 268
 543: PUSH
 544: LD_INT 3
 546: PPUSH
 547: CALL 6928 0 1
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_INT 2
 558: PPUSH
 559: CALL_OW 268
 563: PUSH
 564: EMPTY
 565: LIST
 566: LIST
 567: LIST
 568: LIST
 569: LIST
 570: PUSH
 571: LD_INT 12
 573: PUSH
 574: LD_INT 13
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 11
 582: PUSH
 583: LD_INT 14
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: ST_TO_ADDR
// ru_heal_list := [ ] ;
 597: LD_ADDR_EXP 11
 601: PUSH
 602: EMPTY
 603: ST_TO_ADDR
// need_buldozer := false ;
 604: LD_ADDR_EXP 17
 608: PUSH
 609: LD_INT 0
 611: ST_TO_ADDR
// need_crane := true ;
 612: LD_ADDR_EXP 18
 616: PUSH
 617: LD_INT 1
 619: ST_TO_ADDR
// ru_spotted := false ;
 620: LD_ADDR_EXP 15
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// for i = 1 to 6 do
 628: LD_ADDR_VAR 0 3
 632: PUSH
 633: DOUBLE
 634: LD_INT 1
 636: DEC
 637: ST_TO_ADDR
 638: LD_INT 6
 640: PUSH
 641: FOR_TO
 642: IFFALSE 683
// begin PrepareHuman ( false , 4 , skill ) ;
 644: LD_INT 0
 646: PPUSH
 647: LD_INT 4
 649: PPUSH
 650: LD_VAR 0 2
 654: PPUSH
 655: CALL_OW 380
// un := CreateHuman ;
 659: LD_ADDR_VAR 0 4
 663: PUSH
 664: CALL_OW 44
 668: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 669: LD_VAR 0 4
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: CALL_OW 52
// end ;
 681: GO 641
 683: POP
 684: POP
// for i = 1 to 6 do
 685: LD_ADDR_VAR 0 3
 689: PUSH
 690: DOUBLE
 691: LD_INT 1
 693: DEC
 694: ST_TO_ADDR
 695: LD_INT 6
 697: PUSH
 698: FOR_TO
 699: IFFALSE 740
// begin PrepareHuman ( false , 3 , skill ) ;
 701: LD_INT 0
 703: PPUSH
 704: LD_INT 3
 706: PPUSH
 707: LD_VAR 0 2
 711: PPUSH
 712: CALL_OW 380
// un := CreateHuman ;
 716: LD_ADDR_VAR 0 4
 720: PUSH
 721: CALL_OW 44
 725: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 726: LD_VAR 0 4
 730: PPUSH
 731: LD_INT 14
 733: PPUSH
 734: CALL_OW 52
// end ;
 738: GO 698
 740: POP
 741: POP
// for i = 1 to 6 do
 742: LD_ADDR_VAR 0 3
 746: PUSH
 747: DOUBLE
 748: LD_INT 1
 750: DEC
 751: ST_TO_ADDR
 752: LD_INT 6
 754: PUSH
 755: FOR_TO
 756: IFFALSE 800
// begin PrepareHuman ( false , 2 , skill ) ;
 758: LD_INT 0
 760: PPUSH
 761: LD_INT 2
 763: PPUSH
 764: LD_VAR 0 2
 768: PPUSH
 769: CALL_OW 380
// un := CreateHuman ;
 773: LD_ADDR_VAR 0 4
 777: PUSH
 778: CALL_OW 44
 782: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 783: LD_VAR 0 4
 787: PPUSH
 788: LD_INT 1
 790: PPUSH
 791: LD_INT 0
 793: PPUSH
 794: CALL_OW 49
// end ;
 798: GO 755
 800: POP
 801: POP
// for i = 1 to 6 do
 802: LD_ADDR_VAR 0 3
 806: PUSH
 807: DOUBLE
 808: LD_INT 1
 810: DEC
 811: ST_TO_ADDR
 812: LD_INT 6
 814: PUSH
 815: FOR_TO
 816: IFFALSE 894
// begin PrepareHuman ( false , 1 , skill ) ;
 818: LD_INT 0
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: LD_VAR 0 2
 828: PPUSH
 829: CALL_OW 380
// un := CreateHuman ;
 833: LD_ADDR_VAR 0 4
 837: PUSH
 838: CALL_OW 44
 842: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 843: LD_VAR 0 4
 847: PPUSH
 848: LD_INT 1
 850: PPUSH
 851: LD_INT 0
 853: PPUSH
 854: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 858: LD_VAR 0 4
 862: PPUSH
 863: LD_INT 30
 865: PUSH
 866: LD_INT 5
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL_OW 69
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: CALL_OW 74
 887: PPUSH
 888: CALL_OW 120
// end ;
 892: GO 815
 894: POP
 895: POP
// for i = 1 to Difficulty do
 896: LD_ADDR_VAR 0 3
 900: PUSH
 901: DOUBLE
 902: LD_INT 1
 904: DEC
 905: ST_TO_ADDR
 906: LD_OWVAR 67
 910: PUSH
 911: FOR_TO
 912: IFFALSE 1023
// begin vc_chassis := ru_medium_tracked ;
 914: LD_ADDR_OWVAR 37
 918: PUSH
 919: LD_INT 22
 921: ST_TO_ADDR
// vc_engine := engine_siberite ;
 922: LD_ADDR_OWVAR 39
 926: PUSH
 927: LD_INT 3
 929: ST_TO_ADDR
// vc_control := control_computer ;
 930: LD_ADDR_OWVAR 38
 934: PUSH
 935: LD_INT 3
 937: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 938: LD_ADDR_OWVAR 40
 942: PUSH
 943: LD_INT 43
 945: PUSH
 946: LD_INT 45
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: PUSH
 953: LD_VAR 0 3
 957: PUSH
 958: LD_INT 2
 960: MOD
 961: PUSH
 962: LD_INT 1
 964: PLUS
 965: ARRAY
 966: ST_TO_ADDR
// un := CreateVehicle ;
 967: LD_ADDR_VAR 0 4
 971: PUSH
 972: CALL_OW 45
 976: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
 977: LD_VAR 0 4
 981: PPUSH
 982: LD_INT 52
 984: PPUSH
 985: LD_INT 42
 987: PPUSH
 988: LD_INT 6
 990: PPUSH
 991: LD_INT 0
 993: PPUSH
 994: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
 998: LD_ADDR_EXP 16
1002: PUSH
1003: LD_EXP 16
1007: PPUSH
1008: LD_INT 1
1010: PPUSH
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 2
1020: ST_TO_ADDR
// end ;
1021: GO 911
1023: POP
1024: POP
// end ;
1025: LD_VAR 0 1
1029: RET
// every 150 150$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1030: LD_OWVAR 67
1034: PUSH
1035: LD_INT 2
1037: EQUAL
1038: PUSH
1039: LD_INT 3
1041: PPUSH
1042: LD_INT 3
1044: PPUSH
1045: CALL 6777 0 2
1049: AND
1050: IFFALSE 1086
1052: GO 1054
1054: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 3
1060: PPUSH
1061: CALL 6777 0 2
1065: PUSH
1066: LD_INT 1
1068: ARRAY
1069: PPUSH
1070: LD_INT 24
1072: PPUSH
1073: LD_INT 1
1075: PPUSH
1076: LD_INT 3
1078: PPUSH
1079: LD_INT 48
1081: PPUSH
1082: CALL 8652 0 5
1086: END
// every 120 120$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1087: LD_OWVAR 67
1091: PUSH
1092: LD_INT 3
1094: EQUAL
1095: PUSH
1096: LD_INT 3
1098: PPUSH
1099: LD_INT 3
1101: PPUSH
1102: CALL 6777 0 2
1106: AND
1107: IFFALSE 1143
1109: GO 1111
1111: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1112: LD_INT 3
1114: PPUSH
1115: LD_INT 3
1117: PPUSH
1118: CALL 6777 0 2
1122: PUSH
1123: LD_INT 1
1125: ARRAY
1126: PPUSH
1127: LD_INT 24
1129: PPUSH
1130: LD_INT 1
1132: PPUSH
1133: LD_INT 3
1135: PPUSH
1136: LD_INT 48
1138: PPUSH
1139: CALL 8652 0 5
1143: END
// every 0 0$01 trigger ru_protector do var i ;
1144: LD_EXP 16
1148: IFFALSE 1319
1150: GO 1152
1152: DISABLE
1153: LD_INT 0
1155: PPUSH
// begin enable ;
1156: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1157: LD_INT 14
1159: PPUSH
1160: LD_INT 81
1162: PUSH
1163: LD_INT 3
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: PPUSH
1170: CALL_OW 70
1174: IFFALSE 1249
// begin for i = 1 to ru_protector do
1176: LD_ADDR_VAR 0 1
1180: PUSH
1181: DOUBLE
1182: LD_INT 1
1184: DEC
1185: ST_TO_ADDR
1186: LD_EXP 16
1190: PUSH
1191: FOR_TO
1192: IFFALSE 1245
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1194: LD_EXP 16
1198: PUSH
1199: LD_VAR 0 1
1203: ARRAY
1204: PPUSH
1205: LD_INT 14
1207: PPUSH
1208: LD_INT 81
1210: PUSH
1211: LD_INT 3
1213: PUSH
1214: EMPTY
1215: LIST
1216: LIST
1217: PPUSH
1218: CALL_OW 70
1222: PPUSH
1223: LD_EXP 16
1227: PUSH
1228: LD_VAR 0 1
1232: ARRAY
1233: PPUSH
1234: CALL_OW 74
1238: PPUSH
1239: CALL_OW 115
1243: GO 1191
1245: POP
1246: POP
// end else
1247: GO 1319
// for i = 1 to ru_protector do
1249: LD_ADDR_VAR 0 1
1253: PUSH
1254: DOUBLE
1255: LD_INT 1
1257: DEC
1258: ST_TO_ADDR
1259: LD_EXP 16
1263: PUSH
1264: FOR_TO
1265: IFFALSE 1317
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1267: LD_EXP 16
1271: PUSH
1272: LD_VAR 0 1
1276: ARRAY
1277: PPUSH
1278: LD_INT 49
1280: PPUSH
1281: LD_INT 39
1283: PPUSH
1284: CALL_OW 297
1288: PUSH
1289: LD_INT 10
1291: GREATER
1292: IFFALSE 1315
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1294: LD_EXP 16
1298: PUSH
1299: LD_VAR 0 1
1303: ARRAY
1304: PPUSH
1305: LD_INT 49
1307: PPUSH
1308: LD_INT 39
1310: PPUSH
1311: CALL_OW 111
1315: GO 1264
1317: POP
1318: POP
// end ;
1319: PPOPN 1
1321: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1322: LD_OWVAR 1
1326: PUSH
1327: LD_INT 4200
1329: PUSH
1330: LD_INT 2100
1332: PUSH
1333: LD_INT 1050
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: LD_OWVAR 67
1345: ARRAY
1346: GREATER
1347: IFFALSE 1360
1349: GO 1351
1351: DISABLE
// need_buldozer := true ;
1352: LD_ADDR_EXP 17
1356: PUSH
1357: LD_INT 1
1359: ST_TO_ADDR
1360: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1361: GO 1363
1363: DISABLE
// begin enable ;
1364: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1365: LD_ADDR_EXP 19
1369: PUSH
1370: LD_INT 22
1372: PUSH
1373: LD_INT 3
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: PUSH
1380: LD_INT 25
1382: PUSH
1383: LD_INT 1
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: PPUSH
1394: CALL_OW 69
1398: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1399: LD_ADDR_EXP 20
1403: PUSH
1404: LD_INT 22
1406: PUSH
1407: LD_INT 3
1409: PUSH
1410: EMPTY
1411: LIST
1412: LIST
1413: PUSH
1414: LD_INT 25
1416: PUSH
1417: LD_INT 2
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: PPUSH
1428: CALL_OW 69
1432: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1433: LD_ADDR_EXP 21
1437: PUSH
1438: LD_INT 22
1440: PUSH
1441: LD_INT 3
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: PUSH
1448: LD_INT 25
1450: PUSH
1451: LD_INT 3
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: EMPTY
1459: LIST
1460: LIST
1461: PPUSH
1462: CALL_OW 69
1466: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_INT 22
1474: PUSH
1475: LD_INT 3
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: LD_INT 25
1484: PUSH
1485: LD_INT 4
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PPUSH
1496: CALL_OW 69
1500: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1501: LD_ADDR_EXP 23
1505: PUSH
1506: LD_INT 22
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: LD_INT 25
1518: PUSH
1519: LD_INT 9
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL_OW 69
1534: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1535: LD_ADDR_EXP 24
1539: PUSH
1540: LD_INT 2
1542: PPUSH
1543: LD_INT 22
1545: PUSH
1546: LD_INT 3
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: PUSH
1553: LD_INT 21
1555: PUSH
1556: LD_INT 1
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: PPUSH
1567: CALL_OW 70
1571: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1572: LD_ADDR_EXP 25
1576: PUSH
1577: LD_INT 34
1579: PUSH
1580: LD_INT 53
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1592: LD_ADDR_EXP 26
1596: PUSH
1597: LD_INT 34
1599: PUSH
1600: LD_INT 52
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: PPUSH
1607: CALL_OW 69
1611: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1612: LD_ADDR_EXP 27
1616: PUSH
1617: LD_INT 34
1619: PUSH
1620: LD_INT 51
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PPUSH
1627: CALL_OW 69
1631: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1632: LD_ADDR_EXP 13
1636: PUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 1
1642: NEG
1643: PPUSH
1644: CALL 11282 0 2
1648: ST_TO_ADDR
// end ;
1649: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1650: LD_INT 22
1652: PUSH
1653: LD_INT 3
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PPUSH
1660: CALL_OW 69
1664: PUSH
1665: LD_EXP 28
1669: AND
1670: PUSH
1671: LD_EXP 1
1675: OR
1676: IFFALSE 5165
1678: GO 1680
1680: DISABLE
1681: LD_INT 0
1683: PPUSH
1684: PPUSH
1685: PPUSH
1686: PPUSH
1687: PPUSH
1688: PPUSH
1689: PPUSH
1690: PPUSH
1691: PPUSH
1692: PPUSH
// begin enable ;
1693: ENABLE
// for i = 1 to ru_eng do
1694: LD_ADDR_VAR 0 1
1698: PUSH
1699: DOUBLE
1700: LD_INT 1
1702: DEC
1703: ST_TO_ADDR
1704: LD_EXP 20
1708: PUSH
1709: FOR_TO
1710: IFFALSE 1773
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1712: LD_EXP 20
1716: PUSH
1717: LD_VAR 0 1
1721: ARRAY
1722: PPUSH
1723: CALL_OW 314
1727: NOT
1728: PUSH
1729: LD_EXP 20
1733: PUSH
1734: LD_VAR 0 1
1738: ARRAY
1739: PPUSH
1740: CALL_OW 310
1744: NOT
1745: AND
1746: IFFALSE 1771
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1748: LD_EXP 20
1752: PUSH
1753: LD_VAR 0 1
1757: ARRAY
1758: PPUSH
1759: LD_INT 3
1761: PPUSH
1762: CALL 6686 0 1
1766: PPUSH
1767: CALL_OW 120
1771: GO 1709
1773: POP
1774: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1775: LD_INT 2
1777: PPUSH
1778: LD_INT 22
1780: PUSH
1781: LD_INT 3
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 21
1790: PUSH
1791: LD_INT 3
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: LD_INT 24
1803: PUSH
1804: LD_INT 1000
1806: PUSH
1807: EMPTY
1808: LIST
1809: LIST
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 70
1824: IFFALSE 1991
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1826: LD_ADDR_VAR 0 4
1830: PUSH
1831: LD_INT 2
1833: PPUSH
1834: LD_INT 22
1836: PUSH
1837: LD_INT 3
1839: PUSH
1840: EMPTY
1841: LIST
1842: LIST
1843: PUSH
1844: LD_INT 21
1846: PUSH
1847: LD_INT 3
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: PUSH
1854: LD_INT 3
1856: PUSH
1857: LD_INT 24
1859: PUSH
1860: LD_INT 1000
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: LIST
1875: PPUSH
1876: CALL_OW 70
1880: ST_TO_ADDR
// for i = 1 to ru_eng do
1881: LD_ADDR_VAR 0 1
1885: PUSH
1886: DOUBLE
1887: LD_INT 1
1889: DEC
1890: ST_TO_ADDR
1891: LD_EXP 20
1895: PUSH
1896: FOR_TO
1897: IFFALSE 1989
// begin if IsInUnit ( ru_eng [ i ] ) then
1899: LD_EXP 20
1903: PUSH
1904: LD_VAR 0 1
1908: ARRAY
1909: PPUSH
1910: CALL_OW 310
1914: IFFALSE 1933
// ComExitBuilding ( ru_eng [ i ] ) else
1916: LD_EXP 20
1920: PUSH
1921: LD_VAR 0 1
1925: ARRAY
1926: PPUSH
1927: CALL_OW 122
1931: GO 1987
// if not WantRepair ( ru_eng [ i ] ) then
1933: LD_EXP 20
1937: PUSH
1938: LD_VAR 0 1
1942: ARRAY
1943: PPUSH
1944: CALL 11208 0 1
1948: NOT
1949: IFFALSE 1987
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1951: LD_EXP 20
1955: PUSH
1956: LD_VAR 0 1
1960: ARRAY
1961: PPUSH
1962: LD_VAR 0 4
1966: PPUSH
1967: LD_EXP 20
1971: PUSH
1972: LD_VAR 0 1
1976: ARRAY
1977: PPUSH
1978: CALL_OW 74
1982: PPUSH
1983: CALL_OW 130
// end ;
1987: GO 1896
1989: POP
1990: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
1991: LD_OWVAR 2
1995: PPUSH
1996: LD_INT 38
1998: PPUSH
1999: LD_INT 26
2001: PPUSH
2002: CALL 6005 0 3
2006: PUSH
2007: LD_INT 0
2009: EQUAL
2010: PUSH
2011: LD_OWVAR 2
2015: PPUSH
2016: LD_INT 29
2018: PPUSH
2019: LD_INT 37
2021: PPUSH
2022: CALL 6005 0 3
2026: PUSH
2027: LD_INT 0
2029: EQUAL
2030: AND
2031: IFFALSE 2168
// begin if ru_blist > 0 then
2033: LD_EXP 12
2037: PUSH
2038: LD_INT 0
2040: GREATER
2041: IFFALSE 2168
// begin for i = 1 to ru_eng do
2043: LD_ADDR_VAR 0 1
2047: PUSH
2048: DOUBLE
2049: LD_INT 1
2051: DEC
2052: ST_TO_ADDR
2053: LD_EXP 20
2057: PUSH
2058: FOR_TO
2059: IFFALSE 2166
// if IsInUnit ( ru_eng [ i ] ) then
2061: LD_EXP 20
2065: PUSH
2066: LD_VAR 0 1
2070: ARRAY
2071: PPUSH
2072: CALL_OW 310
2076: IFFALSE 2095
// ComExitBuilding ( ru_eng [ i ] ) else
2078: LD_EXP 20
2082: PUSH
2083: LD_VAR 0 1
2087: ARRAY
2088: PPUSH
2089: CALL_OW 122
2093: GO 2164
// if not HasTask ( ru_eng [ i ] ) then
2095: LD_EXP 20
2099: PUSH
2100: LD_VAR 0 1
2104: ARRAY
2105: PPUSH
2106: CALL_OW 314
2110: NOT
2111: IFFALSE 2164
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2113: LD_EXP 20
2117: PUSH
2118: LD_VAR 0 1
2122: ARRAY
2123: PPUSH
2124: LD_EXP 12
2128: PUSH
2129: LD_INT 1
2131: ARRAY
2132: PPUSH
2133: LD_EXP 12
2137: PUSH
2138: LD_INT 2
2140: ARRAY
2141: PPUSH
2142: LD_EXP 12
2146: PUSH
2147: LD_INT 3
2149: ARRAY
2150: PPUSH
2151: LD_EXP 12
2155: PUSH
2156: LD_INT 4
2158: ARRAY
2159: PPUSH
2160: CALL_OW 145
2164: GO 2058
2166: POP
2167: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2168: LD_ADDR_EXP 11
2172: PUSH
2173: LD_INT 3
2175: PPUSH
2176: LD_EXP 11
2180: PPUSH
2181: LD_EXP 14
2185: PPUSH
2186: CALL 9695 0 3
2190: ST_TO_ADDR
// if debug then
2191: LD_EXP 1
2195: IFFALSE 2207
// display_strings := ru_heal_list ;
2197: LD_ADDR_OWVAR 47
2201: PUSH
2202: LD_EXP 11
2206: ST_TO_ADDR
// for i = 1 to ru_sci do
2207: LD_ADDR_VAR 0 1
2211: PUSH
2212: DOUBLE
2213: LD_INT 1
2215: DEC
2216: ST_TO_ADDR
2217: LD_EXP 22
2221: PUSH
2222: FOR_TO
2223: IFFALSE 2555
// begin if ru_heal_list then
2225: LD_EXP 11
2229: IFFALSE 2468
// begin list := ru_heal_list ;
2231: LD_ADDR_VAR 0 9
2235: PUSH
2236: LD_EXP 11
2240: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2241: LD_EXP 22
2245: PUSH
2246: LD_VAR 0 1
2250: ARRAY
2251: PPUSH
2252: CALL_OW 310
2256: IFFALSE 2273
// ComExitBuilding ( ru_sci [ i ] ) ;
2258: LD_EXP 22
2262: PUSH
2263: LD_VAR 0 1
2267: ARRAY
2268: PPUSH
2269: CALL_OW 122
// for p = 1 to list do
2273: LD_ADDR_VAR 0 5
2277: PUSH
2278: DOUBLE
2279: LD_INT 1
2281: DEC
2282: ST_TO_ADDR
2283: LD_VAR 0 9
2287: PUSH
2288: FOR_TO
2289: IFFALSE 2464
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2291: LD_VAR 0 9
2295: PUSH
2296: LD_VAR 0 5
2300: ARRAY
2301: PPUSH
2302: CALL_OW 110
2306: PUSH
2307: LD_INT 100
2309: EQUAL
2310: PUSH
2311: LD_EXP 22
2315: PUSH
2316: LD_VAR 0 1
2320: ARRAY
2321: PPUSH
2322: LD_INT 100
2324: PPUSH
2325: CALL 10055 0 2
2329: NOT
2330: AND
2331: IFFALSE 2359
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2333: LD_EXP 22
2337: PUSH
2338: LD_VAR 0 1
2342: ARRAY
2343: PPUSH
2344: LD_VAR 0 9
2348: PUSH
2349: LD_VAR 0 5
2353: ARRAY
2354: PPUSH
2355: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2359: LD_VAR 0 9
2363: PUSH
2364: LD_VAR 0 5
2368: ARRAY
2369: PPUSH
2370: CALL_OW 110
2374: PUSH
2375: LD_INT 100
2377: GREATER
2378: IFFALSE 2406
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2380: LD_EXP 22
2384: PUSH
2385: LD_VAR 0 1
2389: ARRAY
2390: PPUSH
2391: LD_VAR 0 9
2395: PUSH
2396: LD_VAR 0 5
2400: ARRAY
2401: PPUSH
2402: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2406: LD_VAR 0 9
2410: PUSH
2411: LD_VAR 0 5
2415: ARRAY
2416: PPUSH
2417: LD_INT 4
2419: PPUSH
2420: CALL_OW 308
2424: NOT
2425: IFFALSE 2447
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2427: LD_VAR 0 9
2431: PUSH
2432: LD_VAR 0 5
2436: ARRAY
2437: PPUSH
2438: LD_INT 4
2440: PPUSH
2441: CALL_OW 113
2445: GO 2462
// ComHold ( list [ p ] ) ;
2447: LD_VAR 0 9
2451: PUSH
2452: LD_VAR 0 5
2456: ARRAY
2457: PPUSH
2458: CALL_OW 140
// end ;
2462: GO 2288
2464: POP
2465: POP
// end else
2466: GO 2553
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2468: LD_EXP 22
2472: PUSH
2473: LD_VAR 0 1
2477: ARRAY
2478: PPUSH
2479: CALL_OW 314
2483: NOT
2484: PUSH
2485: LD_EXP 22
2489: PUSH
2490: LD_VAR 0 1
2494: ARRAY
2495: PPUSH
2496: CALL_OW 310
2500: NOT
2501: AND
2502: PUSH
2503: LD_EXP 11
2507: PUSH
2508: LD_INT 0
2510: EQUAL
2511: AND
2512: IFFALSE 2553
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2514: LD_EXP 22
2518: PUSH
2519: LD_VAR 0 1
2523: ARRAY
2524: PPUSH
2525: LD_INT 3
2527: PPUSH
2528: CALL 6928 0 1
2532: PPUSH
2533: LD_EXP 22
2537: PUSH
2538: LD_VAR 0 1
2542: ARRAY
2543: PPUSH
2544: CALL_OW 74
2548: PPUSH
2549: CALL_OW 120
// end ;
2553: GO 2222
2555: POP
2556: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2557: LD_INT 3
2559: PPUSH
2560: LD_EXP 5
2564: PPUSH
2565: CALL 7069 0 2
2569: IFFALSE 2583
// ResearchTechList ( 3 , ru_tech_list ) ;
2571: LD_INT 3
2573: PPUSH
2574: LD_EXP 5
2578: PPUSH
2579: CALL 7144 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2583: LD_EXP 20
2587: PPUSH
2588: LD_EXP 10
2592: PPUSH
2593: CALL 9051 0 2
// lab := GetLabs ( 3 ) ;
2597: LD_ADDR_VAR 0 8
2601: PUSH
2602: LD_INT 3
2604: PPUSH
2605: CALL 6928 0 1
2609: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2610: LD_VAR 0 8
2614: PUSH
2615: LD_EXP 11
2619: PUSH
2620: LD_INT 0
2622: EQUAL
2623: AND
2624: IFFALSE 2751
// for i = 1 to lab do
2626: LD_ADDR_VAR 0 1
2630: PUSH
2631: DOUBLE
2632: LD_INT 1
2634: DEC
2635: ST_TO_ADDR
2636: LD_VAR 0 8
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2749
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2644: LD_VAR 0 8
2648: PUSH
2649: LD_VAR 0 1
2653: ARRAY
2654: PPUSH
2655: CALL_OW 461
2659: PUSH
2660: LD_INT 6
2662: EQUAL
2663: IFFALSE 2747
// begin for p = 1 to ru_sci do
2665: LD_ADDR_VAR 0 5
2669: PUSH
2670: DOUBLE
2671: LD_INT 1
2673: DEC
2674: ST_TO_ADDR
2675: LD_EXP 22
2679: PUSH
2680: FOR_TO
2681: IFFALSE 2745
// if IsInUnit ( ru_sci [ p ] ) then
2683: LD_EXP 22
2687: PUSH
2688: LD_VAR 0 5
2692: ARRAY
2693: PPUSH
2694: CALL_OW 310
2698: IFFALSE 2717
// ComExitBuilding ( ru_sci [ p ] ) else
2700: LD_EXP 22
2704: PUSH
2705: LD_VAR 0 5
2709: ARRAY
2710: PPUSH
2711: CALL_OW 122
2715: GO 2743
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2717: LD_EXP 22
2721: PUSH
2722: LD_VAR 0 5
2726: ARRAY
2727: PPUSH
2728: LD_VAR 0 8
2732: PUSH
2733: LD_VAR 0 1
2737: ARRAY
2738: PPUSH
2739: CALL_OW 120
2743: GO 2680
2745: POP
2746: POP
// end ;
2747: GO 2641
2749: POP
2750: POP
// if GetTowers ( 3 ) < 5 then
2751: LD_INT 3
2753: PPUSH
2754: CALL 7483 0 1
2758: PUSH
2759: LD_INT 5
2761: LESS
2762: IFFALSE 2780
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2764: LD_EXP 20
2768: PPUSH
2769: LD_EXP 6
2773: PPUSH
2774: CALL 8091 0 2
2778: GO 2792
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2780: LD_INT 3
2782: PPUSH
2783: LD_EXP 7
2787: PPUSH
2788: CALL 8382 0 2
// if GetBuilding ( 3 , b_factory ) then
2792: LD_INT 3
2794: PPUSH
2795: LD_INT 3
2797: PPUSH
2798: CALL 6777 0 2
2802: IFFALSE 3072
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2804: LD_INT 3
2806: PPUSH
2807: LD_INT 3
2809: PPUSH
2810: CALL 6777 0 2
2814: PUSH
2815: LD_INT 1
2817: ARRAY
2818: PPUSH
2819: CALL_OW 461
2823: PUSH
2824: LD_INT 2
2826: EQUAL
2827: IFFALSE 3072
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2829: LD_ADDR_VAR 0 7
2833: PUSH
2834: LD_INT 3
2836: PPUSH
2837: LD_INT 3
2839: PPUSH
2840: CALL 6777 0 2
2844: PUSH
2845: LD_INT 1
2847: ARRAY
2848: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2849: LD_INT 3
2851: PPUSH
2852: LD_INT 24
2854: PPUSH
2855: LD_INT 53
2857: PPUSH
2858: CALL 8530 0 3
2862: PUSH
2863: LD_INT 0
2865: EQUAL
2866: PUSH
2867: LD_EXP 17
2871: AND
2872: IFFALSE 2895
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2874: LD_VAR 0 7
2878: PPUSH
2879: LD_INT 24
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 53
2890: PPUSH
2891: CALL 8652 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2895: LD_INT 3
2897: PPUSH
2898: LD_INT 22
2900: PPUSH
2901: LD_INT 52
2903: PPUSH
2904: CALL 8530 0 3
2908: PUSH
2909: LD_INT 0
2911: EQUAL
2912: PUSH
2913: LD_EXP 18
2917: AND
2918: IFFALSE 2941
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2920: LD_VAR 0 7
2924: PPUSH
2925: LD_INT 22
2927: PPUSH
2928: LD_INT 1
2930: PPUSH
2931: LD_INT 3
2933: PPUSH
2934: LD_INT 52
2936: PPUSH
2937: CALL 8652 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2941: LD_INT 3
2943: PPUSH
2944: LD_INT 22
2946: PPUSH
2947: LD_INT 49
2949: PPUSH
2950: CALL 8530 0 3
2954: PUSH
2955: LD_INT 4
2957: LESS
2958: PUSH
2959: LD_INT 31
2961: PPUSH
2962: LD_INT 3
2964: PPUSH
2965: CALL_OW 321
2969: PUSH
2970: LD_INT 2
2972: EQUAL
2973: AND
2974: IFFALSE 2997
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
2976: LD_VAR 0 7
2980: PPUSH
2981: LD_INT 22
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: LD_INT 3
2989: PPUSH
2990: LD_INT 49
2992: PPUSH
2993: CALL 8652 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
2997: LD_EXP 8
3001: PUSH
3002: LD_INT 5
3004: PUSH
3005: LD_INT 6
3007: PUSH
3008: LD_INT 7
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_OWVAR 67
3020: ARRAY
3021: LESS
3022: IFFALSE 3072
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3024: LD_VAR 0 7
3028: PPUSH
3029: LD_INT 24
3031: PPUSH
3032: LD_INT 1
3034: PPUSH
3035: LD_INT 3
3037: PPUSH
3038: LD_INT 46
3040: PUSH
3041: LD_INT 45
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 46
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: LIST
3055: PUSH
3056: LD_INT 1
3058: PPUSH
3059: LD_INT 4
3061: PPUSH
3062: CALL_OW 12
3066: ARRAY
3067: PPUSH
3068: CALL 8652 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3072: LD_INT 3
3074: PPUSH
3075: CALL 6686 0 1
3079: PPUSH
3080: CALL 6378 0 1
3084: PUSH
3085: LD_INT 1
3087: ARRAY
3088: PUSH
3089: LD_INT 250
3091: GREATER
3092: PUSH
3093: LD_INT 3
3095: PPUSH
3096: CALL 6686 0 1
3100: PPUSH
3101: CALL 6378 0 1
3105: PUSH
3106: LD_INT 3
3108: ARRAY
3109: PUSH
3110: LD_INT 50
3112: GREATER
3113: AND
3114: PUSH
3115: LD_INT 23
3117: PPUSH
3118: LD_INT 3
3120: PPUSH
3121: CALL_OW 321
3125: PUSH
3126: LD_INT 2
3128: EQUAL
3129: AND
3130: PUSH
3131: LD_INT 3
3133: PPUSH
3134: CALL 12006 0 1
3138: PUSH
3139: LD_INT 0
3141: EQUAL
3142: AND
3143: PUSH
3144: LD_INT 22
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: PUSH
3154: LD_INT 34
3156: PUSH
3157: LD_INT 49
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: PUSH
3173: LD_INT 3
3175: GREATER
3176: AND
3177: PUSH
3178: LD_OWVAR 2
3182: PPUSH
3183: LD_INT 51
3185: PPUSH
3186: LD_INT 42
3188: PPUSH
3189: CALL 6005 0 3
3193: PUSH
3194: LD_INT 0
3196: EQUAL
3197: AND
3198: IFFALSE 3283
// begin for i = 1 to ru_mech do
3200: LD_ADDR_VAR 0 1
3204: PUSH
3205: DOUBLE
3206: LD_INT 1
3208: DEC
3209: ST_TO_ADDR
3210: LD_EXP 21
3214: PUSH
3215: FOR_TO
3216: IFFALSE 3281
// begin if IsInUnit ( ru_mech [ i ] ) then
3218: LD_EXP 21
3222: PUSH
3223: LD_VAR 0 1
3227: ARRAY
3228: PPUSH
3229: CALL_OW 310
3233: IFFALSE 3252
// ComExitBuilding ( ru_mech [ i ] ) else
3235: LD_EXP 21
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 122
3250: GO 3279
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3252: LD_EXP 21
3256: PUSH
3257: LD_VAR 0 1
3261: ARRAY
3262: PPUSH
3263: LD_INT 37
3265: PPUSH
3266: LD_INT 51
3268: PPUSH
3269: LD_INT 43
3271: PPUSH
3272: LD_INT 0
3274: PPUSH
3275: CALL_OW 170
// end ;
3279: GO 3215
3281: POP
3282: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3283: LD_OWVAR 1
3287: PUSH
3288: LD_INT 94500
3290: PUSH
3291: LD_INT 84000
3293: PUSH
3294: LD_INT 71400
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: PUSH
3302: LD_OWVAR 67
3306: ARRAY
3307: GREATEREQUAL
3308: IFFALSE 3364
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3310: LD_OWVAR 1
3314: PUSH
3315: LD_INT 18900
3317: PUSH
3318: LD_INT 16800
3320: PUSH
3321: LD_INT 14700
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: MOD
3335: PUSH
3336: LD_INT 0
3338: EQUAL
3339: IFFALSE 3364
// if ru_reserve then
3341: LD_EXP 8
3345: IFFALSE 3364
// begin ru_attack_list := ru_reserve ;
3347: LD_ADDR_EXP 9
3351: PUSH
3352: LD_EXP 8
3356: ST_TO_ADDR
// ru_reserve := [ ] ;
3357: LD_ADDR_EXP 8
3361: PUSH
3362: EMPTY
3363: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3364: LD_EXP 9
3368: IFFALSE 3490
// begin for i = 1 to ru_attack_list do
3370: LD_ADDR_VAR 0 1
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_EXP 9
3384: PUSH
3385: FOR_TO
3386: IFFALSE 3488
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3388: LD_EXP 9
3392: PUSH
3393: LD_VAR 0 1
3397: ARRAY
3398: PPUSH
3399: CALL_OW 256
3403: PUSH
3404: LD_INT 250
3406: GREATEREQUAL
3407: PUSH
3408: LD_EXP 9
3412: PUSH
3413: LD_VAR 0 1
3417: ARRAY
3418: PPUSH
3419: CALL_OW 314
3423: NOT
3424: AND
3425: IFFALSE 3486
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3427: LD_EXP 9
3431: PUSH
3432: LD_VAR 0 1
3436: ARRAY
3437: PPUSH
3438: LD_INT 81
3440: PUSH
3441: LD_EXP 9
3445: PUSH
3446: LD_VAR 0 1
3450: ARRAY
3451: PPUSH
3452: CALL_OW 255
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: PPUSH
3466: LD_EXP 9
3470: PUSH
3471: LD_VAR 0 1
3475: ARRAY
3476: PPUSH
3477: CALL_OW 74
3481: PPUSH
3482: CALL_OW 115
3486: GO 3385
3488: POP
3489: POP
// end ; if GetBehemoth ( 3 ) then
3490: LD_INT 3
3492: PPUSH
3493: CALL 12006 0 1
3497: IFFALSE 3791
// begin if ru_mech >= 4 then
3499: LD_EXP 21
3503: PUSH
3504: LD_INT 4
3506: GREATEREQUAL
3507: IFFALSE 3558
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3509: LD_ADDR_EXP 14
3513: PUSH
3514: LD_EXP 21
3518: PUSH
3519: LD_INT 1
3521: ARRAY
3522: PUSH
3523: LD_EXP 21
3527: PUSH
3528: LD_INT 2
3530: ARRAY
3531: PUSH
3532: LD_EXP 21
3536: PUSH
3537: LD_INT 3
3539: ARRAY
3540: PUSH
3541: LD_EXP 21
3545: PUSH
3546: LD_INT 4
3548: ARRAY
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: ST_TO_ADDR
3556: GO 3568
// ru_behemoth_mechanic := ru_mech ;
3558: LD_ADDR_EXP 14
3562: PUSH
3563: LD_EXP 21
3567: ST_TO_ADDR
// for i = 1 to ru_mech do
3568: LD_ADDR_VAR 0 1
3572: PUSH
3573: DOUBLE
3574: LD_INT 1
3576: DEC
3577: ST_TO_ADDR
3578: LD_EXP 21
3582: PUSH
3583: FOR_TO
3584: IFFALSE 3638
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3586: LD_EXP 21
3590: PUSH
3591: LD_VAR 0 1
3595: ARRAY
3596: PPUSH
3597: CALL_OW 310
3601: PUSH
3602: LD_EXP 21
3606: PUSH
3607: LD_VAR 0 1
3611: ARRAY
3612: PUSH
3613: LD_EXP 14
3617: IN
3618: AND
3619: IFFALSE 3636
// ComExitBuilding ( ru_mech [ i ] ) ;
3621: LD_EXP 21
3625: PUSH
3626: LD_VAR 0 1
3630: ARRAY
3631: PPUSH
3632: CALL_OW 122
3636: GO 3583
3638: POP
3639: POP
// if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3640: LD_INT 12
3642: PPUSH
3643: LD_INT 22
3645: PUSH
3646: LD_INT 1
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: LD_INT 21
3655: PUSH
3656: LD_INT 3
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PPUSH
3667: CALL_OW 70
3671: PUSH
3672: LD_INT 0
3674: GREATER
3675: IFFALSE 3735
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3677: LD_INT 3
3679: PPUSH
3680: CALL 12006 0 1
3684: PUSH
3685: LD_INT 1
3687: ARRAY
3688: PPUSH
3689: LD_INT 21
3691: PUSH
3692: LD_INT 2
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 34
3701: PUSH
3702: LD_INT 49
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PPUSH
3713: CALL_OW 69
3717: PPUSH
3718: LD_EXP 14
3722: PPUSH
3723: LD_INT 97
3725: PPUSH
3726: LD_INT 9
3728: PPUSH
3729: CALL 11503 0 5
3733: GO 3791
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3735: LD_INT 3
3737: PPUSH
3738: CALL 12006 0 1
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: PPUSH
3747: LD_INT 21
3749: PUSH
3750: LD_INT 2
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 34
3759: PUSH
3760: LD_INT 49
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: PPUSH
3771: CALL_OW 69
3775: PPUSH
3776: LD_EXP 14
3780: PPUSH
3781: LD_INT 153
3783: PPUSH
3784: LD_INT 102
3786: PPUSH
3787: CALL 11503 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3791: LD_EXP 23
3795: PUSH
3796: LD_INT 0
3798: EQUAL
3799: PUSH
3800: LD_INT 44
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 321
3810: PUSH
3811: LD_INT 2
3813: EQUAL
3814: AND
3815: IFFALSE 3826
// ComChangeClassToBazooker ( ru_sold ) ;
3817: LD_EXP 19
3821: PPUSH
3822: CALL 10440 0 1
// if ru_bazz then
3826: LD_EXP 23
3830: IFFALSE 3844
// IntBazooka ( ru_bazz , 1 ) ;
3832: LD_EXP 23
3836: PPUSH
3837: LD_INT 1
3839: PPUSH
3840: CALL 10159 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3844: LD_INT 67
3846: PPUSH
3847: LD_INT 39
3849: PPUSH
3850: LD_INT 3
3852: PPUSH
3853: CALL_OW 440
3857: PUSH
3858: LD_INT 0
3860: EQUAL
3861: PUSH
3862: LD_INT 20
3864: PPUSH
3865: LD_INT 3
3867: PPUSH
3868: CALL_OW 321
3872: PUSH
3873: LD_INT 2
3875: EQUAL
3876: AND
3877: IFFALSE 3898
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3879: LD_EXP 22
3883: PUSH
3884: LD_INT 1
3886: ARRAY
3887: PPUSH
3888: LD_INT 67
3890: PPUSH
3891: LD_INT 39
3893: PPUSH
3894: CALL 9634 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3898: LD_INT 89
3900: PPUSH
3901: LD_INT 66
3903: PPUSH
3904: LD_INT 3
3906: PPUSH
3907: CALL_OW 440
3911: PUSH
3912: LD_INT 0
3914: EQUAL
3915: IFFALSE 3936
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
3917: LD_EXP 22
3921: PUSH
3922: LD_INT 1
3924: ARRAY
3925: PPUSH
3926: LD_INT 87
3928: PPUSH
3929: LD_INT 60
3931: PPUSH
3932: CALL 9634 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3936: LD_INT 104
3938: PPUSH
3939: LD_INT 94
3941: PPUSH
3942: LD_INT 3
3944: PPUSH
3945: CALL_OW 440
3949: PUSH
3950: LD_INT 0
3952: EQUAL
3953: PUSH
3954: LD_INT 20
3956: PPUSH
3957: LD_INT 3
3959: PPUSH
3960: CALL_OW 321
3964: PUSH
3965: LD_INT 2
3967: EQUAL
3968: AND
3969: IFFALSE 3990
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
3971: LD_EXP 22
3975: PUSH
3976: LD_INT 1
3978: ARRAY
3979: PPUSH
3980: LD_INT 104
3982: PPUSH
3983: LD_INT 94
3985: PPUSH
3986: CALL 9634 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
3990: LD_INT 3
3992: PPUSH
3993: LD_INT 24
3995: PPUSH
3996: LD_INT 53
3998: PPUSH
3999: CALL 8530 0 3
4003: PUSH
4004: LD_INT 1
4006: EQUAL
4007: PUSH
4008: LD_EXP 17
4012: AND
4013: IFFALSE 4154
// begin need_buldozer := false ;
4015: LD_ADDR_EXP 17
4019: PUSH
4020: LD_INT 0
4022: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4023: LD_INT 3
4025: PPUSH
4026: LD_INT 24
4028: PPUSH
4029: LD_INT 53
4031: PPUSH
4032: CALL 8530 0 3
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 39
4046: PPUSH
4047: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 24
4056: PPUSH
4057: LD_INT 53
4059: PPUSH
4060: CALL 8530 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: LD_INT 71
4071: PPUSH
4072: LD_INT 10
4074: PPUSH
4075: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4079: LD_INT 3
4081: PPUSH
4082: LD_INT 24
4084: PPUSH
4085: LD_INT 53
4087: PPUSH
4088: CALL 8530 0 3
4092: PUSH
4093: LD_INT 1
4095: ARRAY
4096: PPUSH
4097: LD_INT 15
4099: PPUSH
4100: CALL 6119 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4104: LD_INT 3
4106: PPUSH
4107: LD_INT 24
4109: PPUSH
4110: LD_INT 53
4112: PPUSH
4113: CALL 8530 0 3
4117: PUSH
4118: LD_INT 1
4120: ARRAY
4121: PPUSH
4122: LD_INT 350
4124: PPUSH
4125: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4129: LD_INT 3
4131: PPUSH
4132: LD_INT 24
4134: PPUSH
4135: LD_INT 53
4137: PPUSH
4138: CALL 8530 0 3
4142: PUSH
4143: LD_INT 1
4145: ARRAY
4146: PPUSH
4147: LD_INT 14
4149: PPUSH
4150: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4154: LD_INT 67
4156: PPUSH
4157: LD_INT 39
4159: PPUSH
4160: LD_INT 3
4162: PPUSH
4163: CALL_OW 440
4167: PUSH
4168: LD_INT 67
4170: PPUSH
4171: LD_INT 39
4173: PPUSH
4174: CALL_OW 428
4178: PUSH
4179: LD_INT 0
4181: EQUAL
4182: AND
4183: PUSH
4184: LD_INT 79
4186: PPUSH
4187: LD_INT 45
4189: PPUSH
4190: CALL_OW 428
4194: PPUSH
4195: CALL_OW 266
4199: PUSH
4200: LD_INT 0
4202: EQUAL
4203: AND
4204: PUSH
4205: LD_INT 1
4207: PPUSH
4208: LD_INT 79
4210: PPUSH
4211: LD_INT 45
4213: PPUSH
4214: CALL 6005 0 3
4218: PUSH
4219: LD_INT 0
4221: EQUAL
4222: AND
4223: IFFALSE 4326
// begin for i = 1 to ru_eng do
4225: LD_ADDR_VAR 0 1
4229: PUSH
4230: DOUBLE
4231: LD_INT 1
4233: DEC
4234: ST_TO_ADDR
4235: LD_EXP 20
4239: PUSH
4240: FOR_TO
4241: IFFALSE 4324
// if IsInUnit ( ru_eng [ i ] ) then
4243: LD_EXP 20
4247: PUSH
4248: LD_VAR 0 1
4252: ARRAY
4253: PPUSH
4254: CALL_OW 310
4258: IFFALSE 4277
// ComExitBuilding ( ru_eng [ i ] ) else
4260: LD_EXP 20
4264: PUSH
4265: LD_VAR 0 1
4269: ARRAY
4270: PPUSH
4271: CALL_OW 122
4275: GO 4322
// if not HasTask ( ru_eng [ i ] ) then
4277: LD_EXP 20
4281: PUSH
4282: LD_VAR 0 1
4286: ARRAY
4287: PPUSH
4288: CALL_OW 314
4292: NOT
4293: IFFALSE 4322
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4295: LD_EXP 20
4299: PUSH
4300: LD_VAR 0 1
4304: ARRAY
4305: PPUSH
4306: LD_INT 30
4308: PPUSH
4309: LD_INT 67
4311: PPUSH
4312: LD_INT 39
4314: PPUSH
4315: LD_INT 3
4317: PPUSH
4318: CALL_OW 145
4322: GO 4240
4324: POP
4325: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4326: LD_INT 1
4328: PPUSH
4329: LD_INT 79
4331: PPUSH
4332: LD_INT 45
4334: PPUSH
4335: CALL 6005 0 3
4339: PUSH
4340: LD_INT 0
4342: EQUAL
4343: IFFALSE 4539
// begin if HexInfo ( 79 , 45 ) = 0 then
4345: LD_INT 79
4347: PPUSH
4348: LD_INT 45
4350: PPUSH
4351: CALL_OW 428
4355: PUSH
4356: LD_INT 0
4358: EQUAL
4359: IFFALSE 4381
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4361: LD_EXP 20
4365: PPUSH
4366: LD_INT 79
4368: PPUSH
4369: LD_INT 45
4371: PPUSH
4372: LD_INT 3
4374: PPUSH
4375: CALL 7545 0 4
4379: GO 4539
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4381: LD_INT 89
4383: PPUSH
4384: LD_INT 66
4386: PPUSH
4387: CALL_OW 428
4391: PUSH
4392: LD_INT 0
4394: EQUAL
4395: PUSH
4396: LD_INT 89
4398: PPUSH
4399: LD_INT 66
4401: PPUSH
4402: LD_INT 3
4404: PPUSH
4405: CALL_OW 440
4409: AND
4410: IFFALSE 4539
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4412: LD_INT 79
4414: PPUSH
4415: LD_INT 45
4417: PPUSH
4418: CALL_OW 428
4422: PPUSH
4423: CALL_OW 274
4427: PPUSH
4428: LD_INT 1
4430: PPUSH
4431: LD_INT 100
4433: PPUSH
4434: CALL_OW 277
// for i = 1 to ru_eng do
4438: LD_ADDR_VAR 0 1
4442: PUSH
4443: DOUBLE
4444: LD_INT 1
4446: DEC
4447: ST_TO_ADDR
4448: LD_EXP 20
4452: PUSH
4453: FOR_TO
4454: IFFALSE 4537
// if IsInUnit ( ru_eng [ i ] ) then
4456: LD_EXP 20
4460: PUSH
4461: LD_VAR 0 1
4465: ARRAY
4466: PPUSH
4467: CALL_OW 310
4471: IFFALSE 4490
// ComExitBuilding ( ru_eng [ i ] ) else
4473: LD_EXP 20
4477: PUSH
4478: LD_VAR 0 1
4482: ARRAY
4483: PPUSH
4484: CALL_OW 122
4488: GO 4535
// if not HasTask ( ru_eng [ i ] ) then
4490: LD_EXP 20
4494: PUSH
4495: LD_VAR 0 1
4499: ARRAY
4500: PPUSH
4501: CALL_OW 314
4505: NOT
4506: IFFALSE 4535
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4508: LD_EXP 20
4512: PUSH
4513: LD_VAR 0 1
4517: ARRAY
4518: PPUSH
4519: LD_INT 29
4521: PPUSH
4522: LD_INT 89
4524: PPUSH
4525: LD_INT 66
4527: PPUSH
4528: LD_INT 3
4530: PPUSH
4531: CALL_OW 145
4535: GO 4453
4537: POP
4538: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4539: LD_INT 3
4541: PPUSH
4542: LD_INT 29
4544: PPUSH
4545: CALL 6777 0 2
4549: PUSH
4550: LD_INT 0
4552: EQUAL
4553: PUSH
4554: LD_INT 1
4556: PPUSH
4557: LD_INT 36
4559: PPUSH
4560: LD_INT 6
4562: PPUSH
4563: CALL 6005 0 3
4567: PUSH
4568: LD_INT 0
4570: EQUAL
4571: AND
4572: PUSH
4573: LD_INT 3
4575: PPUSH
4576: CALL 6686 0 1
4580: PPUSH
4581: LD_INT 29
4583: PPUSH
4584: CALL 6262 0 2
4588: AND
4589: IFFALSE 4692
// begin for i = 1 to ru_eng do
4591: LD_ADDR_VAR 0 1
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_EXP 20
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4690
// begin if IsInUnit ( ru_eng [ i ] ) then
4609: LD_EXP 20
4613: PUSH
4614: LD_VAR 0 1
4618: ARRAY
4619: PPUSH
4620: CALL_OW 310
4624: IFFALSE 4643
// ComExitBuilding ( ru_eng [ i ] ) else
4626: LD_EXP 20
4630: PUSH
4631: LD_VAR 0 1
4635: ARRAY
4636: PPUSH
4637: CALL_OW 122
4641: GO 4688
// if not HasTask ( ru_eng [ i ] ) then
4643: LD_EXP 20
4647: PUSH
4648: LD_VAR 0 1
4652: ARRAY
4653: PPUSH
4654: CALL_OW 314
4658: NOT
4659: IFFALSE 4688
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4661: LD_EXP 20
4665: PUSH
4666: LD_VAR 0 1
4670: ARRAY
4671: PPUSH
4672: LD_INT 29
4674: PPUSH
4675: LD_INT 33
4677: PPUSH
4678: LD_INT 4
4680: PPUSH
4681: LD_INT 0
4683: PPUSH
4684: CALL_OW 205
// end ; end ;
4688: GO 4606
4690: POP
4691: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4692: LD_EXP 20
4696: PUSH
4697: LD_INT 79
4699: PPUSH
4700: LD_INT 45
4702: PPUSH
4703: CALL_OW 428
4707: PUSH
4708: LD_INT 0
4710: GREATER
4711: AND
4712: PUSH
4713: LD_INT 79
4715: PPUSH
4716: LD_INT 45
4718: PPUSH
4719: CALL_OW 428
4723: PPUSH
4724: CALL_OW 266
4728: PUSH
4729: LD_INT 0
4731: EQUAL
4732: AND
4733: IFFALSE 4893
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4735: LD_INT 79
4737: PPUSH
4738: LD_INT 45
4740: PPUSH
4741: CALL_OW 428
4745: PPUSH
4746: CALL_OW 255
4750: PUSH
4751: LD_INT 3
4753: EQUAL
4754: PUSH
4755: LD_INT 1
4757: PPUSH
4758: LD_INT 79
4760: PPUSH
4761: LD_INT 45
4763: PPUSH
4764: CALL 6005 0 3
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: AND
4773: PUSH
4774: LD_INT 79
4776: PPUSH
4777: LD_INT 45
4779: PPUSH
4780: CALL_OW 428
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 3
4792: PPUSH
4793: CALL_OW 275
4797: PUSH
4798: LD_INT 10
4800: GREATEREQUAL
4801: AND
4802: IFFALSE 4893
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4804: LD_EXP 20
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: CALL_OW 310
4817: IFFALSE 4834
// ComExitBuilding ( ru_eng [ 1 ] ) else
4819: LD_EXP 20
4823: PUSH
4824: LD_INT 1
4826: ARRAY
4827: PPUSH
4828: CALL_OW 122
4832: GO 4893
// if not HasTask ( ru_eng [ 1 ] ) then
4834: LD_EXP 20
4838: PUSH
4839: LD_INT 1
4841: ARRAY
4842: PPUSH
4843: CALL_OW 314
4847: NOT
4848: IFFALSE 4893
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4850: LD_EXP 20
4854: PUSH
4855: LD_INT 1
4857: ARRAY
4858: PPUSH
4859: LD_INT 79
4861: PPUSH
4862: LD_INT 45
4864: PPUSH
4865: CALL_OW 428
4869: PPUSH
4870: LD_INT 3
4872: PPUSH
4873: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4877: LD_EXP 20
4881: PUSH
4882: LD_INT 1
4884: ARRAY
4885: PPUSH
4886: LD_INT 2
4888: PPUSH
4889: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4893: LD_EXP 20
4897: PUSH
4898: LD_INT 2
4900: GREATER
4901: PUSH
4902: LD_INT 79
4904: PPUSH
4905: LD_INT 45
4907: PPUSH
4908: CALL_OW 428
4912: PUSH
4913: LD_INT 0
4915: GREATER
4916: AND
4917: PUSH
4918: LD_INT 79
4920: PPUSH
4921: LD_INT 45
4923: PPUSH
4924: CALL_OW 428
4928: PPUSH
4929: CALL_OW 266
4933: PUSH
4934: LD_INT 0
4936: EQUAL
4937: AND
4938: IFFALSE 5098
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
4940: LD_INT 79
4942: PPUSH
4943: LD_INT 45
4945: PPUSH
4946: CALL_OW 428
4950: PPUSH
4951: CALL_OW 255
4955: PUSH
4956: LD_INT 3
4958: EQUAL
4959: PUSH
4960: LD_INT 1
4962: PPUSH
4963: LD_INT 79
4965: PPUSH
4966: LD_INT 45
4968: PPUSH
4969: CALL 6005 0 3
4973: PUSH
4974: LD_INT 0
4976: EQUAL
4977: AND
4978: PUSH
4979: LD_INT 79
4981: PPUSH
4982: LD_INT 45
4984: PPUSH
4985: CALL_OW 428
4989: PPUSH
4990: CALL_OW 274
4994: PPUSH
4995: LD_INT 1
4997: PPUSH
4998: CALL_OW 275
5002: PUSH
5003: LD_INT 20
5005: GREATER
5006: AND
5007: IFFALSE 5098
// begin if IsInUnit ( ru_eng [ 2 ] ) then
5009: LD_EXP 20
5013: PUSH
5014: LD_INT 2
5016: ARRAY
5017: PPUSH
5018: CALL_OW 310
5022: IFFALSE 5039
// ComExitBuilding ( ru_eng [ 2 ] ) else
5024: LD_EXP 20
5028: PUSH
5029: LD_INT 2
5031: ARRAY
5032: PPUSH
5033: CALL_OW 122
5037: GO 5098
// if not HasTask ( ru_eng [ 2 ] ) then
5039: LD_EXP 20
5043: PUSH
5044: LD_INT 2
5046: ARRAY
5047: PPUSH
5048: CALL_OW 314
5052: NOT
5053: IFFALSE 5098
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5055: LD_EXP 20
5059: PUSH
5060: LD_INT 2
5062: ARRAY
5063: PPUSH
5064: LD_INT 79
5066: PPUSH
5067: LD_INT 45
5069: PPUSH
5070: CALL_OW 428
5074: PPUSH
5075: LD_INT 1
5077: PPUSH
5078: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5082: LD_EXP 20
5086: PUSH
5087: LD_INT 2
5089: ARRAY
5090: PPUSH
5091: LD_INT 2
5093: PPUSH
5094: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5098: LD_INT 1
5100: PPUSH
5101: LD_INT 59
5103: PPUSH
5104: LD_INT 60
5106: PPUSH
5107: CALL 6005 0 3
5111: PUSH
5112: LD_INT 0
5114: EQUAL
5115: PUSH
5116: LD_INT 1
5118: PPUSH
5119: LD_INT 67
5121: PPUSH
5122: LD_INT 76
5124: PPUSH
5125: CALL 6005 0 3
5129: PUSH
5130: LD_INT 0
5132: EQUAL
5133: AND
5134: PUSH
5135: LD_INT 1
5137: PPUSH
5138: LD_INT 79
5140: PPUSH
5141: LD_INT 100
5143: PPUSH
5144: CALL 6005 0 3
5148: PUSH
5149: LD_INT 0
5151: EQUAL
5152: AND
5153: IFFALSE 5165
// CollectCrates ( 3 , west_crates ) ;
5155: LD_INT 3
5157: PPUSH
5158: LD_INT 13
5160: PPUSH
5161: CALL 12050 0 2
// end ;
5165: PPOPN 10
5167: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5168: LD_OWVAR 1
5172: PUSH
5173: LD_INT 111300
5175: LESSEQUAL
5176: PUSH
5177: LD_EXP 29
5181: NOT
5182: OR
5183: IFFALSE 5380
5185: GO 5187
5187: DISABLE
5188: LD_INT 0
5190: PPUSH
// begin enable ;
5191: ENABLE
// uc_nation := 3 ;
5192: LD_ADDR_OWVAR 21
5196: PUSH
5197: LD_INT 3
5199: ST_TO_ADDR
// uc_side := 3 ;
5200: LD_ADDR_OWVAR 20
5204: PUSH
5205: LD_INT 3
5207: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5208: LD_ADDR_OWVAR 37
5212: PUSH
5213: LD_INT 22
5215: ST_TO_ADDR
// vc_engine := engine_siberite ;
5216: LD_ADDR_OWVAR 39
5220: PUSH
5221: LD_INT 3
5223: ST_TO_ADDR
// vc_control := control_computer ;
5224: LD_ADDR_OWVAR 38
5228: PUSH
5229: LD_INT 3
5231: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5232: LD_ADDR_OWVAR 40
5236: PUSH
5237: LD_INT 51
5239: ST_TO_ADDR
// veh := CreateVehicle ;
5240: LD_ADDR_VAR 0 1
5244: PUSH
5245: CALL_OW 45
5249: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5250: LD_VAR 0 1
5254: PPUSH
5255: LD_INT 4
5257: PPUSH
5258: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5262: LD_VAR 0 1
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: LD_INT 0
5272: PPUSH
5273: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5277: LD_VAR 0 1
5281: PPUSH
5282: LD_INT 1
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: LD_INT 3
5290: PUSH
5291: LD_INT 2
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: PUSH
5300: LD_INT 1
5302: PPUSH
5303: LD_INT 4
5305: PPUSH
5306: CALL_OW 12
5310: ARRAY
5311: PPUSH
5312: LD_INT 100
5314: PPUSH
5315: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5319: LD_VAR 0 1
5323: PPUSH
5324: LD_INT 2
5326: PPUSH
5327: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5331: LD_VAR 0 1
5335: PPUSH
5336: LD_INT 10
5338: PPUSH
5339: CALL_OW 173
// Wait ( 0 0$10 ) ;
5343: LD_INT 350
5345: PPUSH
5346: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5357: LD_VAR 0 1
5361: PPUSH
5362: LD_INT 10
5364: PPUSH
5365: CALL_OW 308
5369: IFFALSE 5350
// RemoveUnit ( veh ) ;
5371: LD_VAR 0 1
5375: PPUSH
5376: CALL_OW 64
// end ;
5380: PPOPN 1
5382: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
5383: LD_VAR 0 1
5387: PPUSH
5388: CALL_OW 255
5392: PUSH
5393: LD_INT 3
5395: EQUAL
5396: PUSH
5397: LD_VAR 0 1
5401: PUSH
5402: LD_INT 2
5404: PUSH
5405: LD_INT 34
5407: PUSH
5408: LD_INT 46
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PUSH
5415: LD_INT 34
5417: PUSH
5418: LD_INT 47
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: LD_INT 34
5427: PUSH
5428: LD_INT 45
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: LIST
5439: LIST
5440: PUSH
5441: EMPTY
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: IN
5449: AND
5450: IFFALSE 5468
// ru_reserve := ru_reserve ^ un ;
5452: LD_ADDR_EXP 8
5456: PUSH
5457: LD_EXP 8
5461: PUSH
5462: LD_VAR 0 1
5466: ADD
5467: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
5468: LD_VAR 0 1
5472: PUSH
5473: LD_INT 22
5475: PUSH
5476: LD_INT 3
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: PUSH
5483: LD_INT 34
5485: PUSH
5486: LD_INT 48
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PPUSH
5497: CALL_OW 69
5501: IN
5502: IFFALSE 5555
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
5504: LD_INT 12
5506: PPUSH
5507: LD_INT 22
5509: PUSH
5510: LD_INT 1
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PPUSH
5517: CALL_OW 70
5521: IFFALSE 5540
// ComAttackPlace ( un , 98 , 10 ) else
5523: LD_VAR 0 1
5527: PPUSH
5528: LD_INT 98
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 116
5538: GO 5555
// ComAttackPlace ( un , 134 , 99 ) ;
5540: LD_VAR 0 1
5544: PPUSH
5545: LD_INT 134
5547: PPUSH
5548: LD_INT 99
5550: PPUSH
5551: CALL_OW 116
// end ;
5555: PPOPN 2
5557: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
5558: LD_VAR 0 1
5562: PUSH
5563: LD_INT 22
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: PUSH
5573: LD_INT 21
5575: PUSH
5576: LD_INT 3
5578: PUSH
5579: EMPTY
5580: LIST
5581: LIST
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: PPUSH
5587: CALL_OW 69
5591: IN
5592: PUSH
5593: LD_VAR 0 1
5597: PPUSH
5598: CALL_OW 266
5602: PUSH
5603: LD_INT 0
5605: PUSH
5606: LD_INT 29
5608: PUSH
5609: LD_INT 30
5611: PUSH
5612: LD_INT 26
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: LIST
5620: IN
5621: NOT
5622: AND
5623: IFFALSE 5709
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
5625: LD_ADDR_EXP 12
5629: PUSH
5630: LD_EXP 12
5634: PUSH
5635: LD_VAR 0 1
5639: PPUSH
5640: CALL_OW 266
5644: ADD
5645: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
5646: LD_ADDR_EXP 12
5650: PUSH
5651: LD_EXP 12
5655: PUSH
5656: LD_VAR 0 1
5660: PPUSH
5661: CALL_OW 250
5665: ADD
5666: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
5667: LD_ADDR_EXP 12
5671: PUSH
5672: LD_EXP 12
5676: PUSH
5677: LD_VAR 0 1
5681: PPUSH
5682: CALL_OW 251
5686: ADD
5687: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
5688: LD_ADDR_EXP 12
5692: PUSH
5693: LD_EXP 12
5697: PUSH
5698: LD_VAR 0 1
5702: PPUSH
5703: CALL_OW 254
5707: ADD
5708: ST_TO_ADDR
// end ; if un in ru_attack_list then
5709: LD_VAR 0 1
5713: PUSH
5714: LD_EXP 9
5718: IN
5719: IFFALSE 5737
// ru_attack_list := ru_attack_list diff un ;
5721: LD_ADDR_EXP 9
5725: PUSH
5726: LD_EXP 9
5730: PUSH
5731: LD_VAR 0 1
5735: DIFF
5736: ST_TO_ADDR
// if un in ru_protector then
5737: LD_VAR 0 1
5741: PUSH
5742: LD_EXP 16
5746: IN
5747: IFFALSE 5765
// ru_protector := ru_protector diff un ;
5749: LD_ADDR_EXP 16
5753: PUSH
5754: LD_EXP 16
5758: PUSH
5759: LD_VAR 0 1
5763: DIFF
5764: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
5765: LD_VAR 0 1
5769: PPUSH
5770: CALL_OW 266
5774: PUSH
5775: LD_INT 30
5777: EQUAL
5778: PUSH
5779: LD_VAR 0 1
5783: PPUSH
5784: CALL_OW 255
5788: PUSH
5789: LD_INT 1
5791: EQUAL
5792: AND
5793: IFFALSE 5803
// mine_ck := true ;
5795: LD_ADDR_EXP 34
5799: PUSH
5800: LD_INT 1
5802: ST_TO_ADDR
// end ;
5803: PPOPN 1
5805: END
// on BuildingComplete ( un ) do var i ;
5806: LD_INT 0
5808: PPUSH
// begin if GetSide ( un ) = 1 and GetBType ( un ) = b_siberite_mine then
5809: LD_VAR 0 1
5813: PPUSH
5814: CALL_OW 255
5818: PUSH
5819: LD_INT 1
5821: EQUAL
5822: PUSH
5823: LD_VAR 0 1
5827: PPUSH
5828: CALL_OW 266
5832: PUSH
5833: LD_INT 30
5835: EQUAL
5836: AND
5837: IFFALSE 5847
// mine_constructed := true ;
5839: LD_ADDR_EXP 36
5843: PUSH
5844: LD_INT 1
5846: ST_TO_ADDR
// if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
5847: LD_VAR 0 1
5851: PPUSH
5852: CALL_OW 255
5856: PUSH
5857: LD_INT 3
5859: EQUAL
5860: PUSH
5861: LD_VAR 0 1
5865: PPUSH
5866: CALL_OW 266
5870: PUSH
5871: LD_INT 0
5873: EQUAL
5874: AND
5875: IFFALSE 5932
// begin for i = 1 to 2 do
5877: LD_ADDR_VAR 0 2
5881: PUSH
5882: DOUBLE
5883: LD_INT 1
5885: DEC
5886: ST_TO_ADDR
5887: LD_INT 2
5889: PUSH
5890: FOR_TO
5891: IFFALSE 5930
// begin ComExitBuilding ( ru_sold [ i ] ) ;
5893: LD_EXP 19
5897: PUSH
5898: LD_VAR 0 2
5902: ARRAY
5903: PPUSH
5904: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
5908: LD_EXP 19
5912: PUSH
5913: LD_VAR 0 2
5917: ARRAY
5918: PPUSH
5919: LD_VAR 0 1
5923: PPUSH
5924: CALL_OW 180
// end ;
5928: GO 5890
5930: POP
5931: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
5932: LD_VAR 0 1
5936: PPUSH
5937: CALL_OW 255
5941: PUSH
5942: LD_INT 3
5944: EQUAL
5945: PUSH
5946: LD_VAR 0 1
5950: PPUSH
5951: CALL_OW 266
5955: PUSH
5956: LD_EXP 12
5960: IN
5961: AND
5962: IFFALSE 6002
// for i = 1 to 4 do
5964: LD_ADDR_VAR 0 2
5968: PUSH
5969: DOUBLE
5970: LD_INT 1
5972: DEC
5973: ST_TO_ADDR
5974: LD_INT 4
5976: PUSH
5977: FOR_TO
5978: IFFALSE 6000
// ru_blist := Delete ( ru_blist , 1 ) ;
5980: LD_ADDR_EXP 12
5984: PUSH
5985: LD_EXP 12
5989: PPUSH
5990: LD_INT 1
5992: PPUSH
5993: CALL_OW 3
5997: ST_TO_ADDR
5998: GO 5977
6000: POP
6001: POP
// end ; end_of_file
6002: PPOPN 2
6004: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
6005: LD_INT 0
6007: PPUSH
6008: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
6009: LD_ADDR_VAR 0 5
6013: PUSH
6014: LD_INT 22
6016: PUSH
6017: LD_VAR 0 1
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: PPUSH
6026: CALL_OW 69
6030: PPUSH
6031: LD_VAR 0 2
6035: PPUSH
6036: LD_VAR 0 3
6040: PPUSH
6041: CALL_OW 73
6045: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 then
6046: LD_VAR 0 5
6050: PPUSH
6051: LD_VAR 0 2
6055: PPUSH
6056: LD_VAR 0 3
6060: PPUSH
6061: CALL_OW 297
6065: PUSH
6066: LD_INT 17
6068: LESS
6069: PUSH
6070: LD_INT 2
6072: PPUSH
6073: LD_INT 22
6075: PUSH
6076: LD_VAR 0 1
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PPUSH
6085: CALL_OW 70
6089: PUSH
6090: LD_INT 0
6092: GREATER
6093: OR
6094: IFFALSE 6106
// result := true else
6096: LD_ADDR_VAR 0 4
6100: PUSH
6101: LD_INT 1
6103: ST_TO_ADDR
6104: GO 6114
// result := false ;
6106: LD_ADDR_VAR 0 4
6110: PUSH
6111: LD_INT 0
6113: ST_TO_ADDR
// end ;
6114: LD_VAR 0 4
6118: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
6119: LD_INT 0
6121: PPUSH
6122: PPUSH
// area = ListEnvironmentArea ( area ) ;
6123: LD_ADDR_VAR 0 2
6127: PUSH
6128: LD_VAR 0 2
6132: PPUSH
6133: CALL_OW 353
6137: ST_TO_ADDR
// if bulldozer > 0 then
6138: LD_VAR 0 1
6142: PUSH
6143: LD_INT 0
6145: GREATER
6146: IFFALSE 6257
// for i = 1 to area do
6148: LD_ADDR_VAR 0 4
6152: PUSH
6153: DOUBLE
6154: LD_INT 1
6156: DEC
6157: ST_TO_ADDR
6158: LD_VAR 0 2
6162: PUSH
6163: FOR_TO
6164: IFFALSE 6255
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
6166: LD_VAR 0 2
6170: PUSH
6171: LD_VAR 0 4
6175: ARRAY
6176: PUSH
6177: LD_INT 1
6179: ARRAY
6180: PPUSH
6181: LD_VAR 0 2
6185: PUSH
6186: LD_VAR 0 4
6190: ARRAY
6191: PUSH
6192: LD_INT 2
6194: ARRAY
6195: PPUSH
6196: CALL_OW 351
6200: IFFALSE 6253
// if not HasTask ( bulldozer ) then
6202: LD_VAR 0 1
6206: PPUSH
6207: CALL_OW 314
6211: NOT
6212: IFFALSE 6253
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
6214: LD_VAR 0 1
6218: PPUSH
6219: LD_VAR 0 2
6223: PUSH
6224: LD_VAR 0 4
6228: ARRAY
6229: PUSH
6230: LD_INT 1
6232: ARRAY
6233: PPUSH
6234: LD_VAR 0 2
6238: PUSH
6239: LD_VAR 0 4
6243: ARRAY
6244: PUSH
6245: LD_INT 2
6247: ARRAY
6248: PPUSH
6249: CALL_OW 171
6253: GO 6163
6255: POP
6256: POP
// end ;
6257: LD_VAR 0 3
6261: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
6262: LD_INT 0
6264: PPUSH
6265: PPUSH
6266: PPUSH
// pom := GetBase ( bdepot ) ;
6267: LD_ADDR_VAR 0 4
6271: PUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 274
6281: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
6282: LD_ADDR_VAR 0 5
6286: PUSH
6287: LD_VAR 0 2
6291: PPUSH
6292: LD_VAR 0 1
6296: PPUSH
6297: CALL_OW 248
6301: PPUSH
6302: CALL_OW 450
6306: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
6307: LD_VAR 0 4
6311: PPUSH
6312: LD_INT 1
6314: PPUSH
6315: CALL_OW 275
6319: PUSH
6320: LD_VAR 0 5
6324: PUSH
6325: LD_INT 1
6327: ARRAY
6328: GREATEREQUAL
6329: PUSH
6330: LD_VAR 0 4
6334: PPUSH
6335: LD_INT 3
6337: PPUSH
6338: CALL_OW 275
6342: PUSH
6343: LD_VAR 0 5
6347: PUSH
6348: LD_INT 3
6350: ARRAY
6351: GREATEREQUAL
6352: AND
6353: IFFALSE 6365
// result := true else
6355: LD_ADDR_VAR 0 3
6359: PUSH
6360: LD_INT 1
6362: ST_TO_ADDR
6363: GO 6373
// result := false ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: LD_INT 0
6372: ST_TO_ADDR
// end ;
6373: LD_VAR 0 3
6377: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
6378: LD_INT 0
6380: PPUSH
6381: PPUSH
6382: PPUSH
// pom := GetBase ( bdepot ) ;
6383: LD_ADDR_VAR 0 3
6387: PUSH
6388: LD_VAR 0 1
6392: PPUSH
6393: CALL_OW 274
6397: ST_TO_ADDR
// sor := [ ] ;
6398: LD_ADDR_VAR 0 4
6402: PUSH
6403: EMPTY
6404: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
6405: LD_ADDR_VAR 0 4
6409: PUSH
6410: LD_VAR 0 4
6414: PUSH
6415: LD_VAR 0 3
6419: PPUSH
6420: LD_INT 1
6422: PPUSH
6423: CALL_OW 275
6427: ADD
6428: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
6429: LD_ADDR_VAR 0 4
6433: PUSH
6434: LD_VAR 0 4
6438: PUSH
6439: LD_VAR 0 3
6443: PPUSH
6444: LD_INT 2
6446: PPUSH
6447: CALL_OW 275
6451: ADD
6452: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
6453: LD_ADDR_VAR 0 4
6457: PUSH
6458: LD_VAR 0 4
6462: PUSH
6463: LD_VAR 0 3
6467: PPUSH
6468: LD_INT 3
6470: PPUSH
6471: CALL_OW 275
6475: ADD
6476: ST_TO_ADDR
// result := sor ;
6477: LD_ADDR_VAR 0 2
6481: PUSH
6482: LD_VAR 0 4
6486: ST_TO_ADDR
// end ;
6487: LD_VAR 0 2
6491: RET
// export function Hex ( x , y ) ; begin
6492: LD_INT 0
6494: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
6495: LD_VAR 0 1
6499: PPUSH
6500: LD_VAR 0 2
6504: PPUSH
6505: CALL_OW 488
6509: PUSH
6510: LD_VAR 0 1
6514: PPUSH
6515: LD_VAR 0 2
6519: PPUSH
6520: CALL_OW 428
6524: PUSH
6525: LD_INT 0
6527: EQUAL
6528: AND
6529: IFFALSE 6541
// result := true else
6531: LD_ADDR_VAR 0 3
6535: PUSH
6536: LD_INT 1
6538: ST_TO_ADDR
6539: GO 6549
// result := false ;
6541: LD_ADDR_VAR 0 3
6545: PUSH
6546: LD_INT 0
6548: ST_TO_ADDR
// end ;
6549: LD_VAR 0 3
6553: RET
// export function NeedBuilding ( side , btype ) ; begin
6554: LD_INT 0
6556: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
6557: LD_INT 22
6559: PUSH
6560: LD_VAR 0 1
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: LD_INT 30
6571: PUSH
6572: LD_VAR 0 2
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 57
6586: PUSH
6587: EMPTY
6588: LIST
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: PPUSH
6599: CALL_OW 69
6603: PUSH
6604: LD_INT 0
6606: EQUAL
6607: IFFALSE 6619
// result := true else
6609: LD_ADDR_VAR 0 3
6613: PUSH
6614: LD_INT 1
6616: ST_TO_ADDR
6617: GO 6627
// result := false ;
6619: LD_ADDR_VAR 0 3
6623: PUSH
6624: LD_INT 0
6626: ST_TO_ADDR
// end ;
6627: LD_VAR 0 3
6631: RET
// export function NeedBase ( side ) ; begin
6632: LD_INT 0
6634: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6635: LD_VAR 0 1
6639: PPUSH
6640: LD_INT 0
6642: PPUSH
6643: CALL 6554 0 2
6647: PUSH
6648: LD_VAR 0 1
6652: PPUSH
6653: LD_INT 1
6655: PPUSH
6656: CALL 6554 0 2
6660: AND
6661: IFFALSE 6673
// result := true else
6663: LD_ADDR_VAR 0 2
6667: PUSH
6668: LD_INT 1
6670: ST_TO_ADDR
6671: GO 6681
// result := false ;
6673: LD_ADDR_VAR 0 2
6677: PUSH
6678: LD_INT 0
6680: ST_TO_ADDR
// end ;
6681: LD_VAR 0 2
6685: RET
// export function MyBase ( side ) ; begin
6686: LD_INT 0
6688: PPUSH
// if not NeedBase ( side ) then
6689: LD_VAR 0 1
6693: PPUSH
6694: CALL 6632 0 1
6698: NOT
6699: IFFALSE 6764
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6701: LD_ADDR_VAR 0 2
6705: PUSH
6706: LD_INT 22
6708: PUSH
6709: LD_VAR 0 1
6713: PUSH
6714: EMPTY
6715: LIST
6716: LIST
6717: PUSH
6718: LD_INT 2
6720: PUSH
6721: LD_INT 30
6723: PUSH
6724: LD_INT 0
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: LD_INT 30
6733: PUSH
6734: LD_INT 1
6736: PUSH
6737: EMPTY
6738: LIST
6739: LIST
6740: PUSH
6741: EMPTY
6742: LIST
6743: LIST
6744: LIST
6745: PUSH
6746: EMPTY
6747: LIST
6748: LIST
6749: PUSH
6750: EMPTY
6751: LIST
6752: PPUSH
6753: CALL_OW 69
6757: PUSH
6758: LD_INT 1
6760: ARRAY
6761: ST_TO_ADDR
6762: GO 6772
// result := false ;
6764: LD_ADDR_VAR 0 2
6768: PUSH
6769: LD_INT 0
6771: ST_TO_ADDR
// end ;
6772: LD_VAR 0 2
6776: RET
// export function GetBuilding ( side , btype ) ; begin
6777: LD_INT 0
6779: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6780: LD_INT 22
6782: PUSH
6783: LD_VAR 0 1
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 30
6794: PUSH
6795: LD_VAR 0 2
6799: PUSH
6800: EMPTY
6801: LIST
6802: LIST
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: PPUSH
6808: CALL_OW 69
6812: PUSH
6813: LD_INT 0
6815: GREATER
6816: IFFALSE 6858
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6818: LD_ADDR_VAR 0 3
6822: PUSH
6823: LD_INT 22
6825: PUSH
6826: LD_VAR 0 1
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 30
6837: PUSH
6838: LD_VAR 0 2
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: PPUSH
6851: CALL_OW 69
6855: ST_TO_ADDR
6856: GO 6866
// result := false ;
6858: LD_ADDR_VAR 0 3
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// end ;
6866: LD_VAR 0 3
6870: RET
// export function GetCrates ( side ) ; begin
6871: LD_INT 0
6873: PPUSH
// if MyBase ( side ) then
6874: LD_VAR 0 1
6878: PPUSH
6879: CALL 6686 0 1
6883: IFFALSE 6915
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
6885: LD_ADDR_VAR 0 2
6889: PUSH
6890: LD_VAR 0 1
6894: PPUSH
6895: CALL 6686 0 1
6899: PPUSH
6900: CALL_OW 274
6904: PPUSH
6905: LD_INT 1
6907: PPUSH
6908: CALL_OW 275
6912: ST_TO_ADDR
6913: GO 6923
// result := false ;
6915: LD_ADDR_VAR 0 2
6919: PUSH
6920: LD_INT 0
6922: ST_TO_ADDR
// end ;
6923: LD_VAR 0 2
6927: RET
// export function GetLabs ( side ) ; begin
6928: LD_INT 0
6930: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6931: LD_ADDR_VAR 0 2
6935: PUSH
6936: LD_INT 22
6938: PUSH
6939: LD_VAR 0 1
6943: PUSH
6944: EMPTY
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 2
6950: PUSH
6951: LD_INT 30
6953: PUSH
6954: LD_INT 6
6956: PUSH
6957: EMPTY
6958: LIST
6959: LIST
6960: PUSH
6961: LD_INT 30
6963: PUSH
6964: LD_INT 8
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: PUSH
6971: LD_INT 30
6973: PUSH
6974: LD_INT 7
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: EMPTY
6992: LIST
6993: PPUSH
6994: CALL_OW 69
6998: ST_TO_ADDR
// end ;
6999: LD_VAR 0 2
7003: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
7004: LD_INT 0
7006: PPUSH
7007: PPUSH
7008: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
7009: LD_ADDR_VAR 0 3
7013: PUSH
7014: LD_VAR 0 1
7018: PPUSH
7019: LD_INT 1
7021: PPUSH
7022: CALL_OW 268
7026: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
7027: LD_ADDR_VAR 0 4
7031: PUSH
7032: LD_VAR 0 1
7036: PPUSH
7037: LD_INT 2
7039: PPUSH
7040: CALL_OW 268
7044: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
7045: LD_ADDR_VAR 0 2
7049: PUSH
7050: LD_VAR 0 3
7054: PUSH
7055: LD_VAR 0 4
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: ST_TO_ADDR
// end ;
7064: LD_VAR 0 2
7068: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
7069: LD_INT 0
7071: PPUSH
7072: PPUSH
// result := false ;
7073: LD_ADDR_VAR 0 3
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// for i = 1 to tlist do
7081: LD_ADDR_VAR 0 4
7085: PUSH
7086: DOUBLE
7087: LD_INT 1
7089: DEC
7090: ST_TO_ADDR
7091: LD_VAR 0 2
7095: PUSH
7096: FOR_TO
7097: IFFALSE 7137
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7099: LD_VAR 0 2
7103: PUSH
7104: LD_VAR 0 4
7108: ARRAY
7109: PPUSH
7110: LD_VAR 0 1
7114: PPUSH
7115: CALL_OW 321
7119: PUSH
7120: LD_INT 2
7122: NONEQUAL
7123: IFFALSE 7135
// begin result := true ;
7125: LD_ADDR_VAR 0 3
7129: PUSH
7130: LD_INT 1
7132: ST_TO_ADDR
// break ;
7133: GO 7137
// end ;
7135: GO 7096
7137: POP
7138: POP
// end ;
7139: LD_VAR 0 3
7143: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
7144: LD_INT 0
7146: PPUSH
7147: PPUSH
7148: PPUSH
7149: PPUSH
7150: PPUSH
7151: PPUSH
7152: PPUSH
7153: PPUSH
// lab := GetLabs ( side ) ;
7154: LD_ADDR_VAR 0 5
7158: PUSH
7159: LD_VAR 0 1
7163: PPUSH
7164: CALL 6928 0 1
7168: ST_TO_ADDR
// tmp := 0 ;
7169: LD_ADDR_VAR 0 7
7173: PUSH
7174: LD_INT 0
7176: ST_TO_ADDR
// list := [ ] ;
7177: LD_ADDR_VAR 0 8
7181: PUSH
7182: EMPTY
7183: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
7184: LD_ADDR_VAR 0 10
7188: PUSH
7189: LD_INT 35
7191: PUSH
7192: LD_INT 45
7194: PUSH
7195: LD_INT 46
7197: PUSH
7198: LD_INT 47
7200: PUSH
7201: LD_INT 1
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: LD_INT 48
7209: PUSH
7210: LD_INT 49
7212: PUSH
7213: LD_INT 50
7215: PUSH
7216: LD_INT 20
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: LIST
7230: ST_TO_ADDR
// for i = 1 to tlist do
7231: LD_ADDR_VAR 0 4
7235: PUSH
7236: DOUBLE
7237: LD_INT 1
7239: DEC
7240: ST_TO_ADDR
7241: LD_VAR 0 2
7245: PUSH
7246: FOR_TO
7247: IFFALSE 7299
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7249: LD_VAR 0 2
7253: PUSH
7254: LD_VAR 0 4
7258: ARRAY
7259: PPUSH
7260: LD_VAR 0 1
7264: PPUSH
7265: CALL_OW 321
7269: PUSH
7270: LD_INT 2
7272: NONEQUAL
7273: IFFALSE 7297
// list := list ^ tlist [ i ] ;
7275: LD_ADDR_VAR 0 8
7279: PUSH
7280: LD_VAR 0 8
7284: PUSH
7285: LD_VAR 0 2
7289: PUSH
7290: LD_VAR 0 4
7294: ARRAY
7295: ADD
7296: ST_TO_ADDR
7297: GO 7246
7299: POP
7300: POP
// if list then
7301: LD_VAR 0 8
7305: IFFALSE 7470
// begin for i = 1 to lab do
7307: LD_ADDR_VAR 0 4
7311: PUSH
7312: DOUBLE
7313: LD_INT 1
7315: DEC
7316: ST_TO_ADDR
7317: LD_VAR 0 5
7321: PUSH
7322: FOR_TO
7323: IFFALSE 7393
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
7325: LD_VAR 0 8
7329: PUSH
7330: LD_INT 1
7332: ARRAY
7333: PUSH
7334: LD_VAR 0 10
7338: IN
7339: PUSH
7340: LD_VAR 0 8
7344: PUSH
7345: LD_INT 1
7347: ARRAY
7348: PPUSH
7349: CALL_OW 481
7353: PUSH
7354: LD_VAR 0 5
7358: PUSH
7359: LD_VAR 0 4
7363: ARRAY
7364: PPUSH
7365: CALL 7004 0 1
7369: IN
7370: OR
7371: IFFALSE 7391
// begin mylab := lab [ i ] ;
7373: LD_ADDR_VAR 0 9
7377: PUSH
7378: LD_VAR 0 5
7382: PUSH
7383: LD_VAR 0 4
7387: ARRAY
7388: ST_TO_ADDR
// break ;
7389: GO 7393
// end ;
7391: GO 7322
7393: POP
7394: POP
// if mylab then
7395: LD_VAR 0 9
7399: IFFALSE 7460
// begin if BuildingStatus ( mylab ) = bs_idle then
7401: LD_VAR 0 9
7405: PPUSH
7406: CALL_OW 461
7410: PUSH
7411: LD_INT 2
7413: EQUAL
7414: IFFALSE 7458
// for i = 1 to list do
7416: LD_ADDR_VAR 0 4
7420: PUSH
7421: DOUBLE
7422: LD_INT 1
7424: DEC
7425: ST_TO_ADDR
7426: LD_VAR 0 8
7430: PUSH
7431: FOR_TO
7432: IFFALSE 7456
// AddComResearch ( mylab , list [ i ] ) ;
7434: LD_VAR 0 9
7438: PPUSH
7439: LD_VAR 0 8
7443: PUSH
7444: LD_VAR 0 4
7448: ARRAY
7449: PPUSH
7450: CALL_OW 184
7454: GO 7431
7456: POP
7457: POP
// end else
7458: GO 7468
// result := false ;
7460: LD_ADDR_VAR 0 3
7464: PUSH
7465: LD_INT 0
7467: ST_TO_ADDR
// end else
7468: GO 7478
// result := false ;
7470: LD_ADDR_VAR 0 3
7474: PUSH
7475: LD_INT 0
7477: ST_TO_ADDR
// end ;
7478: LD_VAR 0 3
7482: RET
// export function GetTowers ( side ) ; begin
7483: LD_INT 0
7485: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
7486: LD_ADDR_VAR 0 2
7490: PUSH
7491: LD_INT 22
7493: PUSH
7494: LD_VAR 0 1
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: LD_INT 2
7505: PUSH
7506: LD_INT 30
7508: PUSH
7509: LD_INT 32
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 30
7518: PUSH
7519: LD_INT 33
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: LIST
7530: PUSH
7531: EMPTY
7532: LIST
7533: LIST
7534: PPUSH
7535: CALL_OW 69
7539: ST_TO_ADDR
// end ;
7540: LD_VAR 0 2
7544: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
7545: LD_INT 0
7547: PPUSH
7548: PPUSH
// if Hex ( x , y ) then
7549: LD_VAR 0 2
7553: PPUSH
7554: LD_VAR 0 3
7558: PPUSH
7559: CALL 6492 0 2
7563: IFFALSE 7638
// for i = 1 to plist do
7565: LD_ADDR_VAR 0 6
7569: PUSH
7570: DOUBLE
7571: LD_INT 1
7573: DEC
7574: ST_TO_ADDR
7575: LD_VAR 0 1
7579: PUSH
7580: FOR_TO
7581: IFFALSE 7636
// if not HasTask ( plist [ i ] ) then
7583: LD_VAR 0 1
7587: PUSH
7588: LD_VAR 0 6
7592: ARRAY
7593: PPUSH
7594: CALL_OW 314
7598: NOT
7599: IFFALSE 7634
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
7601: LD_VAR 0 1
7605: PUSH
7606: LD_VAR 0 6
7610: ARRAY
7611: PPUSH
7612: LD_INT 0
7614: PPUSH
7615: LD_VAR 0 2
7619: PPUSH
7620: LD_VAR 0 3
7624: PPUSH
7625: LD_VAR 0 4
7629: PPUSH
7630: CALL_OW 145
7634: GO 7580
7636: POP
7637: POP
// end ;
7638: LD_VAR 0 5
7642: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7643: LD_INT 0
7645: PPUSH
7646: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7647: LD_VAR 0 2
7651: PPUSH
7652: CALL_OW 266
7656: PUSH
7657: LD_INT 0
7659: EQUAL
7660: PUSH
7661: LD_VAR 0 2
7665: PPUSH
7666: LD_INT 1
7668: PPUSH
7669: CALL 6262 0 2
7673: AND
7674: PUSH
7675: LD_VAR 0 1
7679: PUSH
7680: LD_INT 1
7682: ARRAY
7683: PPUSH
7684: CALL_OW 255
7688: PPUSH
7689: CALL_OW 345
7693: NOT
7694: AND
7695: IFFALSE 7791
// begin ComUpgrade ( bident ) ;
7697: LD_VAR 0 2
7701: PPUSH
7702: CALL_OW 146
// for i = 1 to plist do
7706: LD_ADDR_VAR 0 4
7710: PUSH
7711: DOUBLE
7712: LD_INT 1
7714: DEC
7715: ST_TO_ADDR
7716: LD_VAR 0 1
7720: PUSH
7721: FOR_TO
7722: IFFALSE 7779
// if not HasTask ( plist [ i ] ) then
7724: LD_VAR 0 1
7728: PUSH
7729: LD_VAR 0 4
7733: ARRAY
7734: PPUSH
7735: CALL_OW 314
7739: NOT
7740: IFFALSE 7777
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7742: LD_VAR 0 1
7746: PUSH
7747: LD_VAR 0 4
7751: ARRAY
7752: PPUSH
7753: LD_VAR 0 2
7757: PPUSH
7758: CALL_OW 250
7762: PPUSH
7763: LD_VAR 0 2
7767: PPUSH
7768: CALL_OW 251
7772: PPUSH
7773: CALL_OW 111
7777: GO 7721
7779: POP
7780: POP
// result := true ;
7781: LD_ADDR_VAR 0 3
7785: PUSH
7786: LD_INT 1
7788: ST_TO_ADDR
// end else
7789: GO 7799
// result := false ;
7791: LD_ADDR_VAR 0 3
7795: PUSH
7796: LD_INT 0
7798: ST_TO_ADDR
// end ;
7799: LD_VAR 0 3
7803: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7804: LD_INT 0
7806: PPUSH
7807: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7808: LD_VAR 0 1
7812: PUSH
7813: LD_INT 1
7815: ARRAY
7816: PPUSH
7817: CALL_OW 255
7821: PPUSH
7822: CALL 6871 0 1
7826: PUSH
7827: LD_INT 20
7829: GREATEREQUAL
7830: PUSH
7831: LD_VAR 0 2
7835: PPUSH
7836: LD_VAR 0 3
7840: PPUSH
7841: CALL 6492 0 2
7845: AND
7846: IFFALSE 7931
// begin for i = 1 to plist do
7848: LD_ADDR_VAR 0 6
7852: PUSH
7853: DOUBLE
7854: LD_INT 1
7856: DEC
7857: ST_TO_ADDR
7858: LD_VAR 0 1
7862: PUSH
7863: FOR_TO
7864: IFFALSE 7919
// if not HasTask ( plist [ i ] ) then
7866: LD_VAR 0 1
7870: PUSH
7871: LD_VAR 0 6
7875: ARRAY
7876: PPUSH
7877: CALL_OW 314
7881: NOT
7882: IFFALSE 7917
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7884: LD_VAR 0 1
7888: PUSH
7889: LD_VAR 0 6
7893: ARRAY
7894: PPUSH
7895: LD_INT 6
7897: PPUSH
7898: LD_VAR 0 2
7902: PPUSH
7903: LD_VAR 0 3
7907: PPUSH
7908: LD_VAR 0 4
7912: PPUSH
7913: CALL_OW 145
7917: GO 7863
7919: POP
7920: POP
// result := true ;
7921: LD_ADDR_VAR 0 5
7925: PUSH
7926: LD_INT 1
7928: ST_TO_ADDR
// end else
7929: GO 7939
// result := false ;
7931: LD_ADDR_VAR 0 5
7935: PUSH
7936: LD_INT 0
7938: ST_TO_ADDR
// end ;
7939: LD_VAR 0 5
7943: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7944: LD_INT 0
7946: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7947: LD_VAR 0 1
7951: PPUSH
7952: LD_INT 1
7954: PPUSH
7955: CALL_OW 268
7959: PUSH
7960: LD_INT 9
7962: EQUAL
7963: PUSH
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 2
7971: PPUSH
7972: CALL_OW 268
7976: PUSH
7977: LD_INT 9
7979: EQUAL
7980: AND
7981: IFFALSE 8078
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7983: LD_VAR 0 1
7987: PPUSH
7988: LD_VAR 0 2
7992: PPUSH
7993: CALL 6262 0 2
7997: PUSH
7998: LD_VAR 0 1
8002: PPUSH
8003: LD_VAR 0 3
8007: PPUSH
8008: CALL 6262 0 2
8012: AND
8013: PUSH
8014: LD_VAR 0 1
8018: PPUSH
8019: CALL_OW 461
8023: PUSH
8024: LD_INT 2
8026: EQUAL
8027: AND
8028: IFFALSE 8068
// begin ComUpgradeLab ( lab , bkind1 ) ;
8030: LD_VAR 0 1
8034: PPUSH
8035: LD_VAR 0 2
8039: PPUSH
8040: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_VAR 0 3
8053: PPUSH
8054: CALL_OW 207
// result := true ;
8058: LD_ADDR_VAR 0 4
8062: PUSH
8063: LD_INT 1
8065: ST_TO_ADDR
// end else
8066: GO 8076
// result := false ;
8068: LD_ADDR_VAR 0 4
8072: PUSH
8073: LD_INT 0
8075: ST_TO_ADDR
// end else
8076: GO 8086
// result := false ;
8078: LD_ADDR_VAR 0 4
8082: PUSH
8083: LD_INT 0
8085: ST_TO_ADDR
// end ;
8086: LD_VAR 0 4
8090: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
8091: LD_INT 0
8093: PPUSH
8094: PPUSH
8095: PPUSH
8096: PPUSH
8097: PPUSH
// p := 1 ;
8098: LD_ADDR_VAR 0 6
8102: PUSH
8103: LD_INT 1
8105: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
8106: LD_ADDR_VAR 0 4
8110: PUSH
8111: DOUBLE
8112: LD_INT 1
8114: DEC
8115: ST_TO_ADDR
8116: LD_VAR 0 2
8120: PUSH
8121: LD_INT 4
8123: DIVREAL
8124: PUSH
8125: FOR_TO
8126: IFFALSE 8375
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
8128: LD_VAR 0 2
8132: PUSH
8133: LD_VAR 0 6
8137: PUSH
8138: LD_INT 1
8140: PLUS
8141: ARRAY
8142: PPUSH
8143: LD_VAR 0 2
8147: PUSH
8148: LD_VAR 0 6
8152: PUSH
8153: LD_INT 2
8155: PLUS
8156: ARRAY
8157: PPUSH
8158: CALL_OW 428
8162: PUSH
8163: LD_INT 0
8165: EQUAL
8166: PUSH
8167: LD_VAR 0 2
8171: PUSH
8172: LD_VAR 0 6
8176: PUSH
8177: LD_INT 1
8179: PLUS
8180: ARRAY
8181: PPUSH
8182: LD_VAR 0 2
8186: PUSH
8187: LD_VAR 0 6
8191: PUSH
8192: LD_INT 2
8194: PLUS
8195: ARRAY
8196: PPUSH
8197: CALL 6492 0 2
8201: AND
8202: PUSH
8203: LD_VAR 0 1
8207: PUSH
8208: LD_INT 1
8210: ARRAY
8211: PPUSH
8212: CALL_OW 255
8216: PPUSH
8217: CALL 6871 0 1
8221: PUSH
8222: LD_INT 20
8224: GREATEREQUAL
8225: AND
8226: IFFALSE 8343
// begin for c = 1 to plist do
8228: LD_ADDR_VAR 0 7
8232: PUSH
8233: DOUBLE
8234: LD_INT 1
8236: DEC
8237: ST_TO_ADDR
8238: LD_VAR 0 1
8242: PUSH
8243: FOR_TO
8244: IFFALSE 8337
// if not HasTask ( plist [ c ] ) then
8246: LD_VAR 0 1
8250: PUSH
8251: LD_VAR 0 7
8255: ARRAY
8256: PPUSH
8257: CALL_OW 314
8261: NOT
8262: IFFALSE 8335
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
8264: LD_VAR 0 1
8268: PUSH
8269: LD_VAR 0 7
8273: ARRAY
8274: PPUSH
8275: LD_VAR 0 2
8279: PUSH
8280: LD_VAR 0 6
8284: ARRAY
8285: PPUSH
8286: LD_VAR 0 2
8290: PUSH
8291: LD_VAR 0 6
8295: PUSH
8296: LD_INT 1
8298: PLUS
8299: ARRAY
8300: PPUSH
8301: LD_VAR 0 2
8305: PUSH
8306: LD_VAR 0 6
8310: PUSH
8311: LD_INT 2
8313: PLUS
8314: ARRAY
8315: PPUSH
8316: LD_VAR 0 2
8320: PUSH
8321: LD_VAR 0 6
8325: PUSH
8326: LD_INT 3
8328: PLUS
8329: ARRAY
8330: PPUSH
8331: CALL_OW 145
8335: GO 8243
8337: POP
8338: POP
// break ;
8339: GO 8375
// end else
8341: GO 8373
// if ( p + 4 < tlist ) then
8343: LD_VAR 0 6
8347: PUSH
8348: LD_INT 4
8350: PLUS
8351: PUSH
8352: LD_VAR 0 2
8356: LESS
8357: IFFALSE 8373
// p := p + 4 ;
8359: LD_ADDR_VAR 0 6
8363: PUSH
8364: LD_VAR 0 6
8368: PUSH
8369: LD_INT 4
8371: PLUS
8372: ST_TO_ADDR
// end ;
8373: GO 8125
8375: POP
8376: POP
// end ;
8377: LD_VAR 0 3
8381: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
8382: LD_INT 0
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
// tmp := GetTowers ( side ) ;
8388: LD_ADDR_VAR 0 5
8392: PUSH
8393: LD_VAR 0 1
8397: PPUSH
8398: CALL 7483 0 1
8402: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
8403: LD_ADDR_VAR 0 6
8407: PUSH
8408: LD_VAR 0 1
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: CALL 6777 0 2
8420: PUSH
8421: LD_INT 1
8423: ARRAY
8424: ST_TO_ADDR
// if fac then
8425: LD_VAR 0 6
8429: IFFALSE 8525
// for i = 1 to tmp do
8431: LD_ADDR_VAR 0 4
8435: PUSH
8436: DOUBLE
8437: LD_INT 1
8439: DEC
8440: ST_TO_ADDR
8441: LD_VAR 0 5
8445: PUSH
8446: FOR_TO
8447: IFFALSE 8523
// if GetBWeapon ( tmp [ i ] ) = 0 then
8449: LD_VAR 0 5
8453: PUSH
8454: LD_VAR 0 4
8458: ARRAY
8459: PPUSH
8460: CALL_OW 269
8464: PUSH
8465: LD_INT 0
8467: EQUAL
8468: IFFALSE 8521
// begin if BuildingStatus ( fac ) = bs_idle then
8470: LD_VAR 0 6
8474: PPUSH
8475: CALL_OW 461
8479: PUSH
8480: LD_INT 2
8482: EQUAL
8483: IFFALSE 8519
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
8485: LD_VAR 0 5
8489: PUSH
8490: LD_VAR 0 4
8494: ARRAY
8495: PPUSH
8496: LD_VAR 0 2
8500: PUSH
8501: LD_INT 1
8503: PPUSH
8504: LD_VAR 0 2
8508: PPUSH
8509: CALL_OW 12
8513: ARRAY
8514: PPUSH
8515: CALL_OW 148
// break ;
8519: GO 8523
// end ;
8521: GO 8446
8523: POP
8524: POP
// end ;
8525: LD_VAR 0 3
8529: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
8530: LD_INT 0
8532: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
8533: LD_INT 22
8535: PUSH
8536: LD_VAR 0 1
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: PUSH
8545: LD_INT 34
8547: PUSH
8548: LD_VAR 0 3
8552: PUSH
8553: EMPTY
8554: LIST
8555: LIST
8556: PUSH
8557: LD_INT 31
8559: PUSH
8560: LD_VAR 0 2
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: LIST
8573: PUSH
8574: EMPTY
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: IFFALSE 8639
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
8583: LD_ADDR_VAR 0 4
8587: PUSH
8588: LD_INT 22
8590: PUSH
8591: LD_VAR 0 1
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 34
8602: PUSH
8603: LD_VAR 0 3
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: PUSH
8612: LD_INT 31
8614: PUSH
8615: LD_VAR 0 2
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: LIST
8628: PUSH
8629: EMPTY
8630: LIST
8631: PPUSH
8632: CALL_OW 69
8636: ST_TO_ADDR
8637: GO 8647
// result := false ;
8639: LD_ADDR_VAR 0 4
8643: PUSH
8644: LD_INT 0
8646: ST_TO_ADDR
// end ;
8647: LD_VAR 0 4
8651: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8652: LD_INT 0
8654: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_VAR 0 2
8664: PPUSH
8665: LD_VAR 0 3
8669: PPUSH
8670: LD_VAR 0 4
8674: PPUSH
8675: LD_VAR 0 5
8679: PPUSH
8680: CALL_OW 448
8684: PUSH
8685: LD_VAR 0 2
8689: PPUSH
8690: LD_VAR 0 3
8694: PPUSH
8695: LD_VAR 0 4
8699: PPUSH
8700: LD_VAR 0 5
8704: PPUSH
8705: CALL_OW 449
8709: PUSH
8710: LD_INT 1
8712: ARRAY
8713: PUSH
8714: LD_VAR 0 1
8718: PPUSH
8719: CALL 6378 0 1
8723: PUSH
8724: LD_INT 1
8726: ARRAY
8727: LESSEQUAL
8728: AND
8729: PUSH
8730: LD_VAR 0 2
8734: PPUSH
8735: LD_VAR 0 3
8739: PPUSH
8740: LD_VAR 0 4
8744: PPUSH
8745: LD_VAR 0 5
8749: PPUSH
8750: CALL_OW 449
8754: PUSH
8755: LD_INT 2
8757: ARRAY
8758: PUSH
8759: LD_VAR 0 1
8763: PPUSH
8764: CALL 6378 0 1
8768: PUSH
8769: LD_INT 2
8771: ARRAY
8772: LESSEQUAL
8773: AND
8774: PUSH
8775: LD_VAR 0 2
8779: PPUSH
8780: LD_VAR 0 3
8784: PPUSH
8785: LD_VAR 0 4
8789: PPUSH
8790: LD_VAR 0 5
8794: PPUSH
8795: CALL_OW 449
8799: PUSH
8800: LD_INT 3
8802: ARRAY
8803: PUSH
8804: LD_VAR 0 1
8808: PPUSH
8809: CALL 6378 0 1
8813: PUSH
8814: LD_INT 3
8816: ARRAY
8817: LESSEQUAL
8818: AND
8819: IFFALSE 8866
// begin if debug then
8821: LD_EXP 1
8825: IFFALSE 8835
// display_strings := Factory work! ;
8827: LD_ADDR_OWVAR 47
8831: PUSH
8832: LD_STRING Factory work!
8834: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8835: LD_VAR 0 1
8839: PPUSH
8840: LD_VAR 0 2
8844: PPUSH
8845: LD_VAR 0 3
8849: PPUSH
8850: LD_VAR 0 4
8854: PPUSH
8855: LD_VAR 0 5
8859: PPUSH
8860: CALL_OW 125
// end else
8864: GO 8874
// result := false ;
8866: LD_ADDR_VAR 0 6
8870: PUSH
8871: LD_INT 0
8873: ST_TO_ADDR
// end ;
8874: LD_VAR 0 6
8878: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8879: LD_INT 0
8881: PPUSH
8882: PPUSH
8883: PPUSH
8884: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8885: LD_ADDR_VAR 0 6
8889: PUSH
8890: LD_INT 22
8892: PUSH
8893: LD_VAR 0 1
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: PUSH
8902: LD_INT 30
8904: PUSH
8905: LD_VAR 0 2
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PPUSH
8918: CALL_OW 69
8922: ST_TO_ADDR
// tmp := [ ] ;
8923: LD_ADDR_VAR 0 5
8927: PUSH
8928: EMPTY
8929: ST_TO_ADDR
// for i = 1 to filter do
8930: LD_ADDR_VAR 0 4
8934: PUSH
8935: DOUBLE
8936: LD_INT 1
8938: DEC
8939: ST_TO_ADDR
8940: LD_VAR 0 6
8944: PUSH
8945: FOR_TO
8946: IFFALSE 9034
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8948: LD_ADDR_VAR 0 5
8952: PUSH
8953: LD_VAR 0 5
8957: PUSH
8958: LD_VAR 0 6
8962: PUSH
8963: LD_VAR 0 4
8967: ARRAY
8968: PPUSH
8969: CALL_OW 266
8973: PUSH
8974: LD_VAR 0 6
8978: PUSH
8979: LD_VAR 0 4
8983: ARRAY
8984: PPUSH
8985: CALL_OW 250
8989: PUSH
8990: LD_VAR 0 6
8994: PUSH
8995: LD_VAR 0 4
8999: ARRAY
9000: PPUSH
9001: CALL_OW 251
9005: PUSH
9006: LD_VAR 0 6
9010: PUSH
9011: LD_VAR 0 4
9015: ARRAY
9016: PPUSH
9017: CALL_OW 254
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: LIST
9027: PUSH
9028: EMPTY
9029: LIST
9030: ADD
9031: ST_TO_ADDR
// end ;
9032: GO 8945
9034: POP
9035: POP
// result := tmp ;
9036: LD_ADDR_VAR 0 3
9040: PUSH
9041: LD_VAR 0 5
9045: ST_TO_ADDR
// end ;
9046: LD_VAR 0 3
9050: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
9051: LD_INT 0
9053: PPUSH
9054: PPUSH
9055: PPUSH
// for i = 1 to list do
9056: LD_ADDR_VAR 0 4
9060: PUSH
9061: DOUBLE
9062: LD_INT 1
9064: DEC
9065: ST_TO_ADDR
9066: LD_VAR 0 2
9070: PUSH
9071: FOR_TO
9072: IFFALSE 9627
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
9074: LD_VAR 0 2
9078: PUSH
9079: LD_VAR 0 4
9083: ARRAY
9084: PUSH
9085: LD_INT 1
9087: ARRAY
9088: PPUSH
9089: LD_VAR 0 2
9093: PUSH
9094: LD_VAR 0 4
9098: ARRAY
9099: PUSH
9100: LD_INT 2
9102: ARRAY
9103: PPUSH
9104: CALL_OW 428
9108: PUSH
9109: LD_INT 0
9111: GREATER
9112: IFFALSE 9398
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
9114: LD_VAR 0 2
9118: PUSH
9119: LD_VAR 0 4
9123: ARRAY
9124: PUSH
9125: LD_INT 1
9127: ARRAY
9128: PPUSH
9129: LD_VAR 0 2
9133: PUSH
9134: LD_VAR 0 4
9138: ARRAY
9139: PUSH
9140: LD_INT 2
9142: ARRAY
9143: PPUSH
9144: CALL_OW 428
9148: PPUSH
9149: CALL_OW 248
9153: PUSH
9154: LD_INT 3
9156: EQUAL
9157: IFFALSE 9283
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
9159: LD_VAR 0 2
9163: PUSH
9164: LD_VAR 0 4
9168: ARRAY
9169: PUSH
9170: LD_INT 1
9172: ARRAY
9173: PPUSH
9174: LD_VAR 0 2
9178: PUSH
9179: LD_VAR 0 4
9183: ARRAY
9184: PUSH
9185: LD_INT 2
9187: ARRAY
9188: PPUSH
9189: CALL_OW 428
9193: PPUSH
9194: CALL_OW 274
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: CALL_OW 275
9206: PUSH
9207: LD_INT 15
9209: GREATEREQUAL
9210: IFFALSE 9281
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9212: LD_VAR 0 2
9216: PUSH
9217: LD_VAR 0 4
9221: ARRAY
9222: PUSH
9223: LD_INT 1
9225: ARRAY
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 4
9236: ARRAY
9237: PUSH
9238: LD_INT 2
9240: ARRAY
9241: PPUSH
9242: CALL_OW 428
9246: PPUSH
9247: LD_VAR 0 2
9251: PUSH
9252: LD_VAR 0 4
9256: ARRAY
9257: PUSH
9258: LD_INT 4
9260: ARRAY
9261: PPUSH
9262: LD_VAR 0 2
9266: PUSH
9267: LD_VAR 0 4
9271: ARRAY
9272: PUSH
9273: LD_INT 5
9275: ARRAY
9276: PPUSH
9277: CALL 7944 0 3
// end else
9281: GO 9352
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9283: LD_VAR 0 2
9287: PUSH
9288: LD_VAR 0 4
9292: ARRAY
9293: PUSH
9294: LD_INT 1
9296: ARRAY
9297: PPUSH
9298: LD_VAR 0 2
9302: PUSH
9303: LD_VAR 0 4
9307: ARRAY
9308: PUSH
9309: LD_INT 2
9311: ARRAY
9312: PPUSH
9313: CALL_OW 428
9317: PPUSH
9318: LD_VAR 0 2
9322: PUSH
9323: LD_VAR 0 4
9327: ARRAY
9328: PUSH
9329: LD_INT 4
9331: ARRAY
9332: PPUSH
9333: LD_VAR 0 2
9337: PUSH
9338: LD_VAR 0 4
9342: ARRAY
9343: PUSH
9344: LD_INT 5
9346: ARRAY
9347: PPUSH
9348: CALL 7944 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
9352: LD_VAR 0 1
9356: PPUSH
9357: LD_VAR 0 2
9361: PUSH
9362: LD_VAR 0 4
9366: ARRAY
9367: PUSH
9368: LD_INT 1
9370: ARRAY
9371: PPUSH
9372: LD_VAR 0 2
9376: PUSH
9377: LD_VAR 0 4
9381: ARRAY
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: CALL_OW 428
9391: PPUSH
9392: CALL 11000 0 2
// end else
9396: GO 9625
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
9398: LD_VAR 0 1
9402: PUSH
9403: LD_INT 1
9405: ARRAY
9406: PPUSH
9407: CALL_OW 255
9411: PPUSH
9412: CALL 6686 0 1
9416: PPUSH
9417: LD_INT 6
9419: PPUSH
9420: CALL 6262 0 2
9424: PUSH
9425: LD_VAR 0 1
9429: PUSH
9430: LD_INT 1
9432: ARRAY
9433: PPUSH
9434: CALL_OW 255
9438: PPUSH
9439: CALL 6686 0 1
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_VAR 0 4
9453: ARRAY
9454: PUSH
9455: LD_INT 4
9457: ARRAY
9458: PPUSH
9459: CALL 6262 0 2
9463: AND
9464: PUSH
9465: LD_VAR 0 1
9469: PUSH
9470: LD_INT 1
9472: ARRAY
9473: PPUSH
9474: CALL_OW 255
9478: PPUSH
9479: CALL 6686 0 1
9483: PPUSH
9484: LD_VAR 0 2
9488: PUSH
9489: LD_VAR 0 4
9493: ARRAY
9494: PUSH
9495: LD_INT 5
9497: ARRAY
9498: PPUSH
9499: CALL 6262 0 2
9503: AND
9504: IFFALSE 9625
// for p = 1 to plist do
9506: LD_ADDR_VAR 0 5
9510: PUSH
9511: DOUBLE
9512: LD_INT 1
9514: DEC
9515: ST_TO_ADDR
9516: LD_VAR 0 1
9520: PUSH
9521: FOR_TO
9522: IFFALSE 9623
// if IsInUnit ( plist [ p ] ) then
9524: LD_VAR 0 1
9528: PUSH
9529: LD_VAR 0 5
9533: ARRAY
9534: PPUSH
9535: CALL_OW 310
9539: IFFALSE 9558
// ComExitBuilding ( plist [ p ] ) else
9541: LD_VAR 0 1
9545: PUSH
9546: LD_VAR 0 5
9550: ARRAY
9551: PPUSH
9552: CALL_OW 122
9556: GO 9621
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
9558: LD_VAR 0 1
9562: PUSH
9563: LD_VAR 0 5
9567: ARRAY
9568: PPUSH
9569: LD_INT 6
9571: PPUSH
9572: LD_VAR 0 2
9576: PUSH
9577: LD_VAR 0 4
9581: ARRAY
9582: PUSH
9583: LD_INT 1
9585: ARRAY
9586: PPUSH
9587: LD_VAR 0 2
9591: PUSH
9592: LD_VAR 0 4
9596: ARRAY
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_VAR 0 2
9606: PUSH
9607: LD_VAR 0 4
9611: ARRAY
9612: PUSH
9613: LD_INT 3
9615: ARRAY
9616: PPUSH
9617: CALL_OW 145
9621: GO 9521
9623: POP
9624: POP
// end ;
9625: GO 9071
9627: POP
9628: POP
// end ;
9629: LD_VAR 0 3
9633: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9634: LD_INT 0
9636: PPUSH
// if IsInUnit ( sci ) then
9637: LD_VAR 0 1
9641: PPUSH
9642: CALL_OW 310
9646: IFFALSE 9659
// ComExitBuilding ( sci ) else
9648: LD_VAR 0 1
9652: PPUSH
9653: CALL_OW 122
9657: GO 9690
// if not HasTask ( sci ) then
9659: LD_VAR 0 1
9663: PPUSH
9664: CALL_OW 314
9668: NOT
9669: IFFALSE 9690
// begin ComMoveXY ( sci , x , y ) ;
9671: LD_VAR 0 1
9675: PPUSH
9676: LD_VAR 0 2
9680: PPUSH
9681: LD_VAR 0 3
9685: PPUSH
9686: CALL_OW 111
// end ; end ;
9690: LD_VAR 0 4
9694: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9695: LD_INT 0
9697: PPUSH
9698: PPUSH
9699: PPUSH
9700: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9701: LD_ADDR_VAR 0 6
9705: PUSH
9706: LD_INT 22
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PUSH
9718: LD_INT 21
9720: PUSH
9721: LD_INT 1
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: PPUSH
9732: CALL_OW 69
9736: PUSH
9737: LD_VAR 0 3
9741: DIFF
9742: ST_TO_ADDR
// tmp := tag_list ;
9743: LD_ADDR_VAR 0 7
9747: PUSH
9748: LD_VAR 0 2
9752: ST_TO_ADDR
// for i = 1 to filter do
9753: LD_ADDR_VAR 0 5
9757: PUSH
9758: DOUBLE
9759: LD_INT 1
9761: DEC
9762: ST_TO_ADDR
9763: LD_VAR 0 6
9767: PUSH
9768: FOR_TO
9769: IFFALSE 10038
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9771: LD_VAR 0 6
9775: PUSH
9776: LD_VAR 0 5
9780: ARRAY
9781: PPUSH
9782: CALL_OW 256
9786: PUSH
9787: LD_INT 1000
9789: EQUAL
9790: PUSH
9791: LD_VAR 0 6
9795: PUSH
9796: LD_VAR 0 5
9800: ARRAY
9801: PPUSH
9802: CALL_OW 110
9806: PUSH
9807: LD_INT 100
9809: GREATEREQUAL
9810: AND
9811: IFFALSE 9853
// begin SetTag ( filter [ i ] , 0 ) ;
9813: LD_VAR 0 6
9817: PUSH
9818: LD_VAR 0 5
9822: ARRAY
9823: PPUSH
9824: LD_INT 0
9826: PPUSH
9827: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9831: LD_ADDR_VAR 0 7
9835: PUSH
9836: LD_VAR 0 7
9840: PUSH
9841: LD_VAR 0 6
9845: PUSH
9846: LD_VAR 0 5
9850: ARRAY
9851: DIFF
9852: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9853: LD_VAR 0 6
9857: PUSH
9858: LD_VAR 0 5
9862: ARRAY
9863: PPUSH
9864: CALL_OW 256
9868: PUSH
9869: LD_INT 1000
9871: LESS
9872: IFFALSE 10036
// begin if not filter [ i ] in tmp then
9874: LD_VAR 0 6
9878: PUSH
9879: LD_VAR 0 5
9883: ARRAY
9884: PUSH
9885: LD_VAR 0 7
9889: IN
9890: NOT
9891: IFFALSE 9915
// tmp := tmp ^ filter [ i ] ;
9893: LD_ADDR_VAR 0 7
9897: PUSH
9898: LD_VAR 0 7
9902: PUSH
9903: LD_VAR 0 6
9907: PUSH
9908: LD_VAR 0 5
9912: ARRAY
9913: ADD
9914: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9915: LD_VAR 0 6
9919: PUSH
9920: LD_VAR 0 5
9924: ARRAY
9925: PPUSH
9926: CALL_OW 256
9930: PUSH
9931: LD_INT 250
9933: LESS
9934: IFFALSE 9956
// SetTag ( filter [ i ] , 100 ) else
9936: LD_VAR 0 6
9940: PUSH
9941: LD_VAR 0 5
9945: ARRAY
9946: PPUSH
9947: LD_INT 100
9949: PPUSH
9950: CALL_OW 109
9954: GO 10036
// if GetLives ( filter [ i ] ) < 500 then
9956: LD_VAR 0 6
9960: PUSH
9961: LD_VAR 0 5
9965: ARRAY
9966: PPUSH
9967: CALL_OW 256
9971: PUSH
9972: LD_INT 500
9974: LESS
9975: IFFALSE 9997
// SetTag ( filter [ i ] , 101 ) else
9977: LD_VAR 0 6
9981: PUSH
9982: LD_VAR 0 5
9986: ARRAY
9987: PPUSH
9988: LD_INT 101
9990: PPUSH
9991: CALL_OW 109
9995: GO 10036
// if GetLives ( filter [ i ] ) < 1000 then
9997: LD_VAR 0 6
10001: PUSH
10002: LD_VAR 0 5
10006: ARRAY
10007: PPUSH
10008: CALL_OW 256
10012: PUSH
10013: LD_INT 1000
10015: LESS
10016: IFFALSE 10036
// SetTag ( filter [ i ] , 102 ) ;
10018: LD_VAR 0 6
10022: PUSH
10023: LD_VAR 0 5
10027: ARRAY
10028: PPUSH
10029: LD_INT 102
10031: PPUSH
10032: CALL_OW 109
// end ; end ;
10036: GO 9768
10038: POP
10039: POP
// result := tmp ;
10040: LD_ADDR_VAR 0 4
10044: PUSH
10045: LD_VAR 0 7
10049: ST_TO_ADDR
// end ;
10050: LD_VAR 0 4
10054: RET
// export function WantHeal ( sci , tag ) ; begin
10055: LD_INT 0
10057: PPUSH
// if GetTaskList ( sci ) > 0 then
10058: LD_VAR 0 1
10062: PPUSH
10063: CALL_OW 437
10067: PUSH
10068: LD_INT 0
10070: GREATER
10071: IFFALSE 10146
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
10073: LD_VAR 0 1
10077: PPUSH
10078: CALL_OW 437
10082: PUSH
10083: LD_INT 1
10085: ARRAY
10086: PUSH
10087: LD_INT 1
10089: ARRAY
10090: PUSH
10091: LD_STRING l
10093: EQUAL
10094: PUSH
10095: LD_VAR 0 1
10099: PPUSH
10100: CALL_OW 437
10104: PUSH
10105: LD_INT 1
10107: ARRAY
10108: PUSH
10109: LD_INT 4
10111: ARRAY
10112: PPUSH
10113: CALL_OW 110
10117: PUSH
10118: LD_VAR 0 2
10122: EQUAL
10123: AND
10124: IFFALSE 10136
// result := true else
10126: LD_ADDR_VAR 0 3
10130: PUSH
10131: LD_INT 1
10133: ST_TO_ADDR
10134: GO 10144
// result := false ;
10136: LD_ADDR_VAR 0 3
10140: PUSH
10141: LD_INT 0
10143: ST_TO_ADDR
// end else
10144: GO 10154
// result := false ;
10146: LD_ADDR_VAR 0 3
10150: PUSH
10151: LD_INT 0
10153: ST_TO_ADDR
// end ;
10154: LD_VAR 0 3
10158: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
10159: LD_INT 0
10161: PPUSH
10162: PPUSH
10163: PPUSH
10164: PPUSH
10165: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10166: LD_ADDR_VAR 0 7
10170: PUSH
10171: LD_INT 22
10173: PUSH
10174: LD_VAR 0 2
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: LD_INT 3
10185: PUSH
10186: LD_INT 21
10188: PUSH
10189: LD_INT 3
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: EMPTY
10201: LIST
10202: LIST
10203: PPUSH
10204: CALL_OW 69
10208: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
10209: LD_ADDR_VAR 0 5
10213: PUSH
10214: LD_INT 1
10216: PPUSH
10217: LD_INT 3
10219: PPUSH
10220: CALL_OW 12
10224: ST_TO_ADDR
// if filter > 0 then
10225: LD_VAR 0 7
10229: PUSH
10230: LD_INT 0
10232: GREATER
10233: IFFALSE 10435
// for i = 1 to list do
10235: LD_ADDR_VAR 0 6
10239: PUSH
10240: DOUBLE
10241: LD_INT 1
10243: DEC
10244: ST_TO_ADDR
10245: LD_VAR 0 1
10249: PUSH
10250: FOR_TO
10251: IFFALSE 10433
// for ta in filter do
10253: LD_ADDR_VAR 0 4
10257: PUSH
10258: LD_VAR 0 7
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10429
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
10266: LD_VAR 0 1
10270: PUSH
10271: LD_VAR 0 6
10275: ARRAY
10276: PPUSH
10277: LD_VAR 0 4
10281: PPUSH
10282: CALL_OW 296
10286: PUSH
10287: LD_INT 13
10289: LESSEQUAL
10290: IFFALSE 10427
// begin case c of 1 :
10292: LD_VAR 0 5
10296: PUSH
10297: LD_INT 1
10299: DOUBLE
10300: EQUAL
10301: IFTRUE 10305
10303: GO 10343
10305: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
10306: LD_VAR 0 1
10310: PUSH
10311: LD_VAR 0 6
10315: ARRAY
10316: PPUSH
10317: LD_VAR 0 4
10321: PPUSH
10322: CALL_OW 250
10326: PPUSH
10327: LD_VAR 0 4
10331: PPUSH
10332: CALL_OW 251
10336: PPUSH
10337: CALL_OW 154
10341: GO 10427
10343: LD_INT 2
10345: DOUBLE
10346: EQUAL
10347: IFTRUE 10351
10349: GO 10415
10351: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
10352: LD_VAR 0 1
10356: PUSH
10357: LD_VAR 0 6
10361: ARRAY
10362: PPUSH
10363: LD_VAR 0 4
10367: PPUSH
10368: CALL_OW 250
10372: PUSH
10373: LD_INT 1
10375: NEG
10376: PPUSH
10377: LD_INT 1
10379: PPUSH
10380: CALL_OW 12
10384: PLUS
10385: PPUSH
10386: LD_VAR 0 4
10390: PPUSH
10391: CALL_OW 251
10395: PUSH
10396: LD_INT 1
10398: NEG
10399: PPUSH
10400: LD_INT 1
10402: PPUSH
10403: CALL_OW 12
10407: PLUS
10408: PPUSH
10409: CALL_OW 153
10413: GO 10427
10415: LD_INT 3
10417: DOUBLE
10418: EQUAL
10419: IFTRUE 10423
10421: GO 10426
10423: POP
// ; end ;
10424: GO 10427
10426: POP
// end ; end ;
10427: GO 10263
10429: POP
10430: POP
10431: GO 10250
10433: POP
10434: POP
// end ;
10435: LD_VAR 0 3
10439: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
10440: LD_INT 0
10442: PPUSH
10443: PPUSH
// for i = 1 to plist do
10444: LD_ADDR_VAR 0 3
10448: PUSH
10449: DOUBLE
10450: LD_INT 1
10452: DEC
10453: ST_TO_ADDR
10454: LD_VAR 0 1
10458: PUSH
10459: FOR_TO
10460: IFFALSE 10662
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
10462: LD_VAR 0 1
10466: PUSH
10467: LD_VAR 0 3
10471: ARRAY
10472: PPUSH
10473: CALL_OW 310
10477: PUSH
10478: LD_INT 30
10480: PUSH
10481: LD_INT 5
10483: PUSH
10484: EMPTY
10485: LIST
10486: LIST
10487: PUSH
10488: EMPTY
10489: LIST
10490: PPUSH
10491: CALL_OW 69
10495: IN
10496: NOT
10497: IFFALSE 10642
// begin if IsInUnit ( plist [ i ] ) then
10499: LD_VAR 0 1
10503: PUSH
10504: LD_VAR 0 3
10508: ARRAY
10509: PPUSH
10510: CALL_OW 310
10514: IFFALSE 10533
// ComExitBuilding ( plist [ i ] ) else
10516: LD_VAR 0 1
10520: PUSH
10521: LD_VAR 0 3
10525: ARRAY
10526: PPUSH
10527: CALL_OW 122
10531: GO 10640
// if not HasTask ( plist [ i ] ) then
10533: LD_VAR 0 1
10537: PUSH
10538: LD_VAR 0 3
10542: ARRAY
10543: PPUSH
10544: CALL_OW 314
10548: NOT
10549: IFFALSE 10640
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
10551: LD_VAR 0 1
10555: PUSH
10556: LD_VAR 0 3
10560: ARRAY
10561: PPUSH
10562: LD_INT 22
10564: PUSH
10565: LD_VAR 0 1
10569: PUSH
10570: LD_INT 1
10572: ARRAY
10573: PPUSH
10574: CALL_OW 255
10578: PUSH
10579: EMPTY
10580: LIST
10581: LIST
10582: PUSH
10583: LD_INT 30
10585: PUSH
10586: LD_INT 5
10588: PUSH
10589: EMPTY
10590: LIST
10591: LIST
10592: PUSH
10593: EMPTY
10594: LIST
10595: LIST
10596: PPUSH
10597: CALL_OW 69
10601: PPUSH
10602: LD_VAR 0 1
10606: PUSH
10607: LD_VAR 0 3
10611: ARRAY
10612: PPUSH
10613: CALL_OW 74
10617: PPUSH
10618: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10622: LD_VAR 0 1
10626: PUSH
10627: LD_VAR 0 3
10631: ARRAY
10632: PPUSH
10633: LD_INT 9
10635: PPUSH
10636: CALL_OW 183
// end ; end else
10640: GO 10660
// ComChangeProfession ( plist [ i ] , 9 ) ;
10642: LD_VAR 0 1
10646: PUSH
10647: LD_VAR 0 3
10651: ARRAY
10652: PPUSH
10653: LD_INT 9
10655: PPUSH
10656: CALL_OW 123
10660: GO 10459
10662: POP
10663: POP
// end ;
10664: LD_VAR 0 2
10668: RET
// export function GetHuman ( side ) ; begin
10669: LD_INT 0
10671: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10672: LD_ADDR_VAR 0 2
10676: PUSH
10677: LD_INT 22
10679: PUSH
10680: LD_VAR 0 1
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: PUSH
10689: LD_INT 21
10691: PUSH
10692: LD_INT 1
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: PUSH
10699: LD_INT 2
10701: PUSH
10702: LD_INT 25
10704: PUSH
10705: LD_INT 1
10707: PUSH
10708: EMPTY
10709: LIST
10710: LIST
10711: PUSH
10712: LD_INT 25
10714: PUSH
10715: LD_INT 2
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: LD_INT 25
10724: PUSH
10725: LD_INT 3
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 25
10734: PUSH
10735: LD_INT 4
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: LIST
10753: PPUSH
10754: CALL_OW 69
10758: ST_TO_ADDR
// end ;
10759: LD_VAR 0 2
10763: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10764: LD_INT 0
10766: PPUSH
10767: PPUSH
10768: PPUSH
// uc_side := 0 ;
10769: LD_ADDR_OWVAR 20
10773: PUSH
10774: LD_INT 0
10776: ST_TO_ADDR
// uc_nation := 0 ;
10777: LD_ADDR_OWVAR 21
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10785: LD_ADDR_VAR 0 4
10789: PUSH
10790: DOUBLE
10791: LD_INT 1
10793: DEC
10794: ST_TO_ADDR
10795: LD_INT 4
10797: PUSH
10798: LD_INT 5
10800: PUSH
10801: LD_INT 6
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: PUSH
10809: LD_OWVAR 67
10813: ARRAY
10814: PUSH
10815: FOR_TO
10816: IFFALSE 10887
// begin hc_class = class_tiger ;
10818: LD_ADDR_OWVAR 28
10822: PUSH
10823: LD_INT 14
10825: ST_TO_ADDR
// hc_gallery = sandnature ;
10826: LD_ADDR_OWVAR 33
10830: PUSH
10831: LD_STRING sandnature
10833: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10834: LD_ADDR_OWVAR 35
10838: PUSH
10839: LD_INT 0
10841: PPUSH
10842: LD_INT 50
10844: PPUSH
10845: CALL_OW 12
10849: ST_TO_ADDR
// hc_face_number = 3 ;
10850: LD_ADDR_OWVAR 34
10854: PUSH
10855: LD_INT 3
10857: ST_TO_ADDR
// tiger := CreateHuman ;
10858: LD_ADDR_VAR 0 3
10862: PUSH
10863: CALL_OW 44
10867: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10868: LD_VAR 0 3
10872: PPUSH
10873: LD_VAR 0 1
10877: PPUSH
10878: LD_INT 0
10880: PPUSH
10881: CALL_OW 49
// end ;
10885: GO 10815
10887: POP
10888: POP
// end ;
10889: LD_VAR 0 2
10893: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10894: LD_INT 0
10896: PPUSH
10897: PPUSH
10898: PPUSH
// uc_side := 0 ;
10899: LD_ADDR_OWVAR 20
10903: PUSH
10904: LD_INT 0
10906: ST_TO_ADDR
// uc_nation := 0 ;
10907: LD_ADDR_OWVAR 21
10911: PUSH
10912: LD_INT 0
10914: ST_TO_ADDR
// for i = 1 to 8 do
10915: LD_ADDR_VAR 0 4
10919: PUSH
10920: DOUBLE
10921: LD_INT 1
10923: DEC
10924: ST_TO_ADDR
10925: LD_INT 8
10927: PUSH
10928: FOR_TO
10929: IFFALSE 10993
// begin hc_class = class_apeman ;
10931: LD_ADDR_OWVAR 28
10935: PUSH
10936: LD_INT 12
10938: ST_TO_ADDR
// hc_gallery =  ;
10939: LD_ADDR_OWVAR 33
10943: PUSH
10944: LD_STRING 
10946: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10947: LD_ADDR_OWVAR 35
10951: PUSH
10952: LD_INT 5
10954: NEG
10955: PPUSH
10956: LD_INT 20
10958: PPUSH
10959: CALL_OW 12
10963: ST_TO_ADDR
// ape := CreateHuman ;
10964: LD_ADDR_VAR 0 3
10968: PUSH
10969: CALL_OW 44
10973: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10974: LD_VAR 0 3
10978: PPUSH
10979: LD_VAR 0 1
10983: PPUSH
10984: LD_INT 0
10986: PPUSH
10987: CALL_OW 49
// end ;
10991: GO 10928
10993: POP
10994: POP
// end ;
10995: LD_VAR 0 2
10999: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
11000: LD_INT 0
11002: PPUSH
11003: PPUSH
// if BuildingStatus ( b ) = bs_build then
11004: LD_VAR 0 2
11008: PPUSH
11009: CALL_OW 461
11013: PUSH
11014: LD_INT 1
11016: EQUAL
11017: IFFALSE 11203
// for i = 1 to plist do
11019: LD_ADDR_VAR 0 4
11023: PUSH
11024: DOUBLE
11025: LD_INT 1
11027: DEC
11028: ST_TO_ADDR
11029: LD_VAR 0 1
11033: PUSH
11034: FOR_TO
11035: IFFALSE 11201
// if IsInUnit ( plist [ i ] ) then
11037: LD_VAR 0 1
11041: PUSH
11042: LD_VAR 0 4
11046: ARRAY
11047: PPUSH
11048: CALL_OW 310
11052: IFFALSE 11135
// begin ComExitBuilding ( plist [ i ] ) ;
11054: LD_VAR 0 1
11058: PUSH
11059: LD_VAR 0 4
11063: ARRAY
11064: PPUSH
11065: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11069: LD_VAR 0 1
11073: PUSH
11074: LD_VAR 0 4
11078: ARRAY
11079: PPUSH
11080: LD_STRING h
11082: PUSH
11083: LD_VAR 0 2
11087: PPUSH
11088: CALL_OW 250
11092: PUSH
11093: LD_VAR 0 2
11097: PPUSH
11098: CALL_OW 251
11102: PUSH
11103: LD_VAR 0 2
11107: PUSH
11108: LD_INT 0
11110: PUSH
11111: LD_INT 0
11113: PUSH
11114: LD_INT 0
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: LIST
11121: LIST
11122: LIST
11123: LIST
11124: LIST
11125: PUSH
11126: EMPTY
11127: LIST
11128: PPUSH
11129: CALL_OW 447
// end else
11133: GO 11199
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11135: LD_VAR 0 1
11139: PUSH
11140: LD_VAR 0 4
11144: ARRAY
11145: PPUSH
11146: LD_STRING h
11148: PUSH
11149: LD_VAR 0 2
11153: PPUSH
11154: CALL_OW 250
11158: PUSH
11159: LD_VAR 0 2
11163: PPUSH
11164: CALL_OW 251
11168: PUSH
11169: LD_VAR 0 2
11173: PUSH
11174: LD_INT 0
11176: PUSH
11177: LD_INT 0
11179: PUSH
11180: LD_INT 0
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: LIST
11191: PUSH
11192: EMPTY
11193: LIST
11194: PPUSH
11195: CALL_OW 446
11199: GO 11034
11201: POP
11202: POP
// end ;
11203: LD_VAR 0 3
11207: RET
// export function WantRepair ( eng ) ; begin
11208: LD_INT 0
11210: PPUSH
// if GetTaskList ( eng ) > 0 then
11211: LD_VAR 0 1
11215: PPUSH
11216: CALL_OW 437
11220: PUSH
11221: LD_INT 0
11223: GREATER
11224: IFFALSE 11269
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
11226: LD_VAR 0 1
11230: PPUSH
11231: CALL_OW 437
11235: PUSH
11236: LD_INT 1
11238: ARRAY
11239: PUSH
11240: LD_INT 1
11242: ARRAY
11243: PUSH
11244: LD_STRING o
11246: EQUAL
11247: IFFALSE 11259
// result := true else
11249: LD_ADDR_VAR 0 2
11253: PUSH
11254: LD_INT 1
11256: ST_TO_ADDR
11257: GO 11267
// result := false ;
11259: LD_ADDR_VAR 0 2
11263: PUSH
11264: LD_INT 0
11266: ST_TO_ADDR
// end else
11267: GO 11277
// result := false ;
11269: LD_ADDR_VAR 0 2
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// end ;
11277: LD_VAR 0 2
11281: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
11282: LD_INT 0
11284: PPUSH
11285: PPUSH
11286: PPUSH
11287: PPUSH
// if btype = - 1 then
11288: LD_VAR 0 2
11292: PUSH
11293: LD_INT 1
11295: NEG
11296: EQUAL
11297: IFFALSE 11337
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
11299: LD_ADDR_VAR 0 5
11303: PUSH
11304: LD_INT 22
11306: PUSH
11307: LD_VAR 0 1
11311: PUSH
11312: EMPTY
11313: LIST
11314: LIST
11315: PUSH
11316: LD_INT 21
11318: PUSH
11319: LD_INT 3
11321: PUSH
11322: EMPTY
11323: LIST
11324: LIST
11325: PUSH
11326: EMPTY
11327: LIST
11328: LIST
11329: PPUSH
11330: CALL_OW 69
11334: ST_TO_ADDR
11335: GO 11375
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
11337: LD_ADDR_VAR 0 5
11341: PUSH
11342: LD_INT 22
11344: PUSH
11345: LD_VAR 0 1
11349: PUSH
11350: EMPTY
11351: LIST
11352: LIST
11353: PUSH
11354: LD_INT 30
11356: PUSH
11357: LD_VAR 0 2
11361: PUSH
11362: EMPTY
11363: LIST
11364: LIST
11365: PUSH
11366: EMPTY
11367: LIST
11368: LIST
11369: PPUSH
11370: CALL_OW 69
11374: ST_TO_ADDR
// list := [ ] ;
11375: LD_ADDR_VAR 0 6
11379: PUSH
11380: EMPTY
11381: ST_TO_ADDR
// for i = 1 to tmp do
11382: LD_ADDR_VAR 0 4
11386: PUSH
11387: DOUBLE
11388: LD_INT 1
11390: DEC
11391: ST_TO_ADDR
11392: LD_VAR 0 5
11396: PUSH
11397: FOR_TO
11398: IFFALSE 11486
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11400: LD_ADDR_VAR 0 6
11404: PUSH
11405: LD_VAR 0 6
11409: PUSH
11410: LD_VAR 0 5
11414: PUSH
11415: LD_VAR 0 4
11419: ARRAY
11420: PPUSH
11421: CALL_OW 266
11425: PUSH
11426: LD_VAR 0 5
11430: PUSH
11431: LD_VAR 0 4
11435: ARRAY
11436: PPUSH
11437: CALL_OW 250
11441: PUSH
11442: LD_VAR 0 5
11446: PUSH
11447: LD_VAR 0 4
11451: ARRAY
11452: PPUSH
11453: CALL_OW 251
11457: PUSH
11458: LD_VAR 0 5
11462: PUSH
11463: LD_VAR 0 4
11467: ARRAY
11468: PPUSH
11469: CALL_OW 254
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: EMPTY
11481: LIST
11482: ADD
11483: ST_TO_ADDR
11484: GO 11397
11486: POP
11487: POP
// result = list ;
11488: LD_ADDR_VAR 0 3
11492: PUSH
11493: LD_VAR 0 6
11497: ST_TO_ADDR
// end ;
11498: LD_VAR 0 3
11502: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
11503: LD_INT 0
11505: PPUSH
11506: PPUSH
11507: PPUSH
11508: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
11509: LD_VAR 0 1
11513: PPUSH
11514: LD_INT 81
11516: PUSH
11517: LD_VAR 0 1
11521: PPUSH
11522: CALL_OW 255
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: PPUSH
11531: CALL_OW 69
11535: PPUSH
11536: LD_VAR 0 1
11540: PPUSH
11541: CALL_OW 74
11545: PPUSH
11546: CALL_OW 296
11550: PUSH
11551: LD_INT 18
11553: LESS
11554: IFFALSE 11599
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
11556: LD_VAR 0 1
11560: PPUSH
11561: LD_INT 81
11563: PUSH
11564: LD_VAR 0 1
11568: PPUSH
11569: CALL_OW 255
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PPUSH
11578: CALL_OW 69
11582: PPUSH
11583: LD_VAR 0 1
11587: PPUSH
11588: CALL_OW 74
11592: PPUSH
11593: CALL_OW 115
11597: GO 11618
// ComMoveXY ( behemoth , x , y ) ;
11599: LD_VAR 0 1
11603: PPUSH
11604: LD_VAR 0 4
11608: PPUSH
11609: LD_VAR 0 5
11613: PPUSH
11614: CALL_OW 111
// if time_lapsers_list > 0 then
11618: LD_VAR 0 2
11622: PUSH
11623: LD_INT 0
11625: GREATER
11626: IFFALSE 11816
// begin for i = 1 to time_lapsers_list do
11628: LD_ADDR_VAR 0 7
11632: PUSH
11633: DOUBLE
11634: LD_INT 1
11636: DEC
11637: ST_TO_ADDR
11638: LD_VAR 0 2
11642: PUSH
11643: FOR_TO
11644: IFFALSE 11814
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11646: LD_VAR 0 2
11650: PUSH
11651: LD_VAR 0 7
11655: ARRAY
11656: PPUSH
11657: CALL_OW 256
11661: PUSH
11662: LD_INT 250
11664: GREATEREQUAL
11665: PUSH
11666: LD_VAR 0 2
11670: PUSH
11671: LD_VAR 0 7
11675: ARRAY
11676: PPUSH
11677: LD_VAR 0 1
11681: PPUSH
11682: CALL_OW 296
11686: PUSH
11687: LD_INT 9
11689: GREATER
11690: AND
11691: IFFALSE 11728
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11693: LD_VAR 0 2
11697: PUSH
11698: LD_VAR 0 7
11702: ARRAY
11703: PPUSH
11704: LD_VAR 0 1
11708: PPUSH
11709: CALL_OW 250
11713: PPUSH
11714: LD_VAR 0 1
11718: PPUSH
11719: CALL_OW 251
11723: PPUSH
11724: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11728: LD_VAR 0 2
11732: PUSH
11733: LD_VAR 0 7
11737: ARRAY
11738: PPUSH
11739: CALL_OW 256
11743: PUSH
11744: LD_INT 500
11746: LESS
11747: PUSH
11748: LD_VAR 0 1
11752: PPUSH
11753: CALL_OW 256
11757: PUSH
11758: LD_INT 700
11760: GREATER
11761: AND
11762: IFFALSE 11812
// for p = 1 to mechanic_list do
11764: LD_ADDR_VAR 0 8
11768: PUSH
11769: DOUBLE
11770: LD_INT 1
11772: DEC
11773: ST_TO_ADDR
11774: LD_VAR 0 3
11778: PUSH
11779: FOR_TO
11780: IFFALSE 11810
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11782: LD_VAR 0 3
11786: PUSH
11787: LD_VAR 0 8
11791: ARRAY
11792: PPUSH
11793: LD_VAR 0 2
11797: PUSH
11798: LD_VAR 0 7
11802: ARRAY
11803: PPUSH
11804: CALL_OW 129
11808: GO 11779
11810: POP
11811: POP
// end ;
11812: GO 11643
11814: POP
11815: POP
// end ; if mechanic_list then
11816: LD_VAR 0 3
11820: IFFALSE 12001
// begin for i = 1 to mechanic_list do
11822: LD_ADDR_VAR 0 7
11826: PUSH
11827: DOUBLE
11828: LD_INT 1
11830: DEC
11831: ST_TO_ADDR
11832: LD_VAR 0 3
11836: PUSH
11837: FOR_TO
11838: IFFALSE 11999
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11840: LD_VAR 0 3
11844: PUSH
11845: LD_VAR 0 7
11849: ARRAY
11850: PPUSH
11851: CALL_OW 256
11855: PUSH
11856: LD_INT 333
11858: LESS
11859: IFFALSE 11883
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11861: LD_ADDR_EXP 14
11865: PUSH
11866: LD_EXP 14
11870: PUSH
11871: LD_VAR 0 3
11875: PUSH
11876: LD_VAR 0 7
11880: ARRAY
11881: DIFF
11882: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11883: LD_VAR 0 3
11887: PUSH
11888: LD_VAR 0 7
11892: ARRAY
11893: PPUSH
11894: LD_VAR 0 1
11898: PPUSH
11899: CALL_OW 296
11903: PUSH
11904: LD_INT 9
11906: GREATER
11907: PUSH
11908: LD_VAR 0 3
11912: PUSH
11913: LD_VAR 0 7
11917: ARRAY
11918: PPUSH
11919: CALL_OW 314
11923: NOT
11924: AND
11925: IFFALSE 11962
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11927: LD_VAR 0 3
11931: PUSH
11932: LD_VAR 0 7
11936: ARRAY
11937: PPUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 250
11947: PPUSH
11948: LD_VAR 0 1
11952: PPUSH
11953: CALL_OW 251
11957: PPUSH
11958: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11962: LD_VAR 0 1
11966: PPUSH
11967: CALL_OW 256
11971: PUSH
11972: LD_INT 700
11974: LESS
11975: IFFALSE 11997
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11977: LD_VAR 0 3
11981: PUSH
11982: LD_VAR 0 7
11986: ARRAY
11987: PPUSH
11988: LD_VAR 0 1
11992: PPUSH
11993: CALL_OW 129
// end ;
11997: GO 11837
11999: POP
12000: POP
// end ; end ;
12001: LD_VAR 0 6
12005: RET
// export function GetBehemoth ( side ) ; begin
12006: LD_INT 0
12008: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
12009: LD_ADDR_VAR 0 2
12013: PUSH
12014: LD_INT 22
12016: PUSH
12017: LD_VAR 0 1
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: PUSH
12026: LD_INT 31
12028: PUSH
12029: LD_INT 25
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PPUSH
12040: CALL_OW 69
12044: ST_TO_ADDR
// end ;
12045: LD_VAR 0 2
12049: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
12050: LD_INT 0
12052: PPUSH
12053: PPUSH
12054: PPUSH
12055: PPUSH
12056: PPUSH
12057: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
12058: LD_ADDR_VAR 0 6
12062: PUSH
12063: LD_VAR 0 2
12067: PPUSH
12068: CALL_OW 435
12072: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
12073: LD_ADDR_VAR 0 5
12077: PUSH
12078: LD_INT 22
12080: PUSH
12081: LD_VAR 0 1
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PUSH
12090: LD_INT 2
12092: PUSH
12093: LD_INT 25
12095: PUSH
12096: LD_INT 2
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 16
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: LIST
12117: PUSH
12118: EMPTY
12119: LIST
12120: LIST
12121: PPUSH
12122: CALL_OW 69
12126: ST_TO_ADDR
// if skr then
12127: LD_VAR 0 6
12131: IFFALSE 12296
// begin if engs then
12133: LD_VAR 0 5
12137: IFFALSE 12296
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
12139: LD_ADDR_VAR 0 8
12143: PUSH
12144: LD_VAR 0 6
12148: PUSH
12149: LD_INT 1
12151: ARRAY
12152: PPUSH
12153: LD_VAR 0 6
12157: PUSH
12158: LD_INT 2
12160: ARRAY
12161: PPUSH
12162: CALL_OW 284
12166: ST_TO_ADDR
// if am > engs then
12167: LD_VAR 0 8
12171: PUSH
12172: LD_VAR 0 5
12176: GREATER
12177: IFFALSE 12189
// am := engs ;
12179: LD_ADDR_VAR 0 8
12183: PUSH
12184: LD_VAR 0 5
12188: ST_TO_ADDR
// for i = 1 to am do
12189: LD_ADDR_VAR 0 7
12193: PUSH
12194: DOUBLE
12195: LD_INT 1
12197: DEC
12198: ST_TO_ADDR
12199: LD_VAR 0 8
12203: PUSH
12204: FOR_TO
12205: IFFALSE 12294
// begin if IsInUnit ( engs [ i ] ) then
12207: LD_VAR 0 5
12211: PUSH
12212: LD_VAR 0 7
12216: ARRAY
12217: PPUSH
12218: CALL_OW 310
12222: IFFALSE 12241
// ComExitBuilding ( engs [ i ] ) else
12224: LD_VAR 0 5
12228: PUSH
12229: LD_VAR 0 7
12233: ARRAY
12234: PPUSH
12235: CALL_OW 122
12239: GO 12292
// if not HasTask ( engs [ i ] ) then
12241: LD_VAR 0 5
12245: PUSH
12246: LD_VAR 0 7
12250: ARRAY
12251: PPUSH
12252: CALL_OW 314
12256: NOT
12257: IFFALSE 12292
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
12259: LD_VAR 0 5
12263: PUSH
12264: LD_VAR 0 7
12268: ARRAY
12269: PPUSH
12270: LD_VAR 0 6
12274: PUSH
12275: LD_INT 1
12277: ARRAY
12278: PPUSH
12279: LD_VAR 0 6
12283: PUSH
12284: LD_INT 2
12286: ARRAY
12287: PPUSH
12288: CALL_OW 117
// end ;
12292: GO 12204
12294: POP
12295: POP
// end ; end ; end ; end_of_file
12296: LD_VAR 0 3
12300: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
12301: LD_INT 0
12303: PPUSH
12304: PPUSH
// uc_side := 1 ;
12305: LD_ADDR_OWVAR 20
12309: PUSH
12310: LD_INT 1
12312: ST_TO_ADDR
// uc_nation := 1 ;
12313: LD_ADDR_OWVAR 21
12317: PUSH
12318: LD_INT 1
12320: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12321: LD_ADDR_VAR 0 2
12325: PUSH
12326: LD_INT 6
12328: PUSH
12329: LD_INT 5
12331: PUSH
12332: LD_INT 4
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: LIST
12339: PUSH
12340: LD_OWVAR 67
12344: ARRAY
12345: ST_TO_ADDR
// game_status := false ;
12346: LD_ADDR_EXP 28
12350: PUSH
12351: LD_INT 0
12353: ST_TO_ADDR
// helps_arrive := false ;
12354: LD_ADDR_EXP 29
12358: PUSH
12359: LD_INT 0
12361: ST_TO_ADDR
// helps_can_arrive := false ;
12362: LD_ADDR_EXP 30
12366: PUSH
12367: LD_INT 0
12369: ST_TO_ADDR
// beta_come := false ;
12370: LD_ADDR_EXP 31
12374: PUSH
12375: LD_INT 0
12377: ST_TO_ADDR
// gamma_come := false ;
12378: LD_ADDR_EXP 32
12382: PUSH
12383: LD_INT 0
12385: ST_TO_ADDR
// zeta_come := false ;
12386: LD_ADDR_EXP 33
12390: PUSH
12391: LD_INT 0
12393: ST_TO_ADDR
// mine_ck := false ;
12394: LD_ADDR_EXP 34
12398: PUSH
12399: LD_INT 0
12401: ST_TO_ADDR
// sib_bomb_constructed := false ;
12402: LD_ADDR_EXP 35
12406: PUSH
12407: LD_INT 0
12409: ST_TO_ADDR
// mine_constructed := false ;
12410: LD_ADDR_EXP 36
12414: PUSH
12415: LD_INT 0
12417: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
12418: LD_INT 35
12420: PPUSH
12421: CALL_OW 274
12425: PPUSH
12426: LD_INT 1
12428: PPUSH
12429: LD_INT 200
12431: PUSH
12432: LD_INT 100
12434: PUSH
12435: LD_INT 70
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: LIST
12442: PUSH
12443: LD_OWVAR 67
12447: ARRAY
12448: PPUSH
12449: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
12453: LD_INT 35
12455: PPUSH
12456: LD_INT 4
12458: PPUSH
12459: CALL_OW 235
// hc_importance := 100 ;
12463: LD_ADDR_OWVAR 32
12467: PUSH
12468: LD_INT 100
12470: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
12471: LD_INT 1
12473: PPUSH
12474: LD_INT 2
12476: PPUSH
12477: LD_VAR 0 2
12481: PUSH
12482: LD_INT 1
12484: PLUS
12485: PPUSH
12486: CALL_OW 380
// hc_gallery := hardch ;
12490: LD_ADDR_OWVAR 33
12494: PUSH
12495: LD_STRING hardch
12497: ST_TO_ADDR
// hc_face_number := 1 ;
12498: LD_ADDR_OWVAR 34
12502: PUSH
12503: LD_INT 1
12505: ST_TO_ADDR
// guyA := CreateHuman ;
12506: LD_ADDR_EXP 37
12510: PUSH
12511: CALL_OW 44
12515: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
12516: LD_INT 1
12518: PPUSH
12519: LD_INT 1
12521: PPUSH
12522: LD_VAR 0 2
12526: PPUSH
12527: CALL_OW 380
// hc_face_number := 2 ;
12531: LD_ADDR_OWVAR 34
12535: PUSH
12536: LD_INT 2
12538: ST_TO_ADDR
// guyB := CreateHuman ;
12539: LD_ADDR_EXP 38
12543: PUSH
12544: CALL_OW 44
12548: ST_TO_ADDR
// hc_importance := 0 ;
12549: LD_ADDR_OWVAR 32
12553: PUSH
12554: LD_INT 0
12556: ST_TO_ADDR
// hc_gallery :=  ;
12557: LD_ADDR_OWVAR 33
12561: PUSH
12562: LD_STRING 
12564: ST_TO_ADDR
// end ;
12565: LD_VAR 0 1
12569: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
12570: LD_INT 0
12572: PPUSH
12573: PPUSH
12574: PPUSH
12575: PPUSH
12576: PPUSH
12577: PPUSH
12578: PPUSH
12579: PPUSH
12580: PPUSH
// uc_side := 4 ;
12581: LD_ADDR_OWVAR 20
12585: PUSH
12586: LD_INT 4
12588: ST_TO_ADDR
// uc_nation := 1 ;
12589: LD_ADDR_OWVAR 21
12593: PUSH
12594: LD_INT 1
12596: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12597: LD_ADDR_VAR 0 10
12601: PUSH
12602: LD_INT 6
12604: PUSH
12605: LD_INT 5
12607: PUSH
12608: LD_INT 4
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: PUSH
12616: LD_OWVAR 67
12620: ARRAY
12621: ST_TO_ADDR
// Beta_Squad := [ ] ;
12622: LD_ADDR_EXP 39
12626: PUSH
12627: EMPTY
12628: ST_TO_ADDR
// case num of 1 :
12629: LD_VAR 0 1
12633: PUSH
12634: LD_INT 1
12636: DOUBLE
12637: EQUAL
12638: IFTRUE 12642
12640: GO 12685
12642: POP
// begin sold := 2 ;
12643: LD_ADDR_VAR 0 5
12647: PUSH
12648: LD_INT 2
12650: ST_TO_ADDR
// sci := 1 ;
12651: LD_ADDR_VAR 0 6
12655: PUSH
12656: LD_INT 1
12658: ST_TO_ADDR
// mech := 2 ;
12659: LD_ADDR_VAR 0 7
12663: PUSH
12664: LD_INT 2
12666: ST_TO_ADDR
// tank := 1 ;
12667: LD_ADDR_VAR 0 8
12671: PUSH
12672: LD_INT 1
12674: ST_TO_ADDR
// cargo := 1 ;
12675: LD_ADDR_VAR 0 9
12679: PUSH
12680: LD_INT 1
12682: ST_TO_ADDR
// end ; 2 :
12683: GO 12788
12685: LD_INT 2
12687: DOUBLE
12688: EQUAL
12689: IFTRUE 12693
12691: GO 12736
12693: POP
// begin sold := 2 ;
12694: LD_ADDR_VAR 0 5
12698: PUSH
12699: LD_INT 2
12701: ST_TO_ADDR
// sci := 1 ;
12702: LD_ADDR_VAR 0 6
12706: PUSH
12707: LD_INT 1
12709: ST_TO_ADDR
// mech := 1 ;
12710: LD_ADDR_VAR 0 7
12714: PUSH
12715: LD_INT 1
12717: ST_TO_ADDR
// tank := 1 ;
12718: LD_ADDR_VAR 0 8
12722: PUSH
12723: LD_INT 1
12725: ST_TO_ADDR
// cargo := 0 ;
12726: LD_ADDR_VAR 0 9
12730: PUSH
12731: LD_INT 0
12733: ST_TO_ADDR
// end ; 3 :
12734: GO 12788
12736: LD_INT 3
12738: DOUBLE
12739: EQUAL
12740: IFTRUE 12744
12742: GO 12787
12744: POP
// begin sold := 1 ;
12745: LD_ADDR_VAR 0 5
12749: PUSH
12750: LD_INT 1
12752: ST_TO_ADDR
// sci := 1 ;
12753: LD_ADDR_VAR 0 6
12757: PUSH
12758: LD_INT 1
12760: ST_TO_ADDR
// mech := 1 ;
12761: LD_ADDR_VAR 0 7
12765: PUSH
12766: LD_INT 1
12768: ST_TO_ADDR
// tank := 1 ;
12769: LD_ADDR_VAR 0 8
12773: PUSH
12774: LD_INT 1
12776: ST_TO_ADDR
// cargo := 0 ;
12777: LD_ADDR_VAR 0 9
12781: PUSH
12782: LD_INT 0
12784: ST_TO_ADDR
// end ; end ;
12785: GO 12788
12787: POP
// for i = 1 to sold do
12788: LD_ADDR_VAR 0 3
12792: PUSH
12793: DOUBLE
12794: LD_INT 1
12796: DEC
12797: ST_TO_ADDR
12798: LD_VAR 0 5
12802: PUSH
12803: FOR_TO
12804: IFFALSE 12876
// begin if i = 1 then
12806: LD_VAR 0 3
12810: PUSH
12811: LD_INT 1
12813: EQUAL
12814: IFFALSE 12833
// PrepareHuman ( sex_male , 1 , skill ) else
12816: LD_INT 1
12818: PPUSH
12819: LD_INT 1
12821: PPUSH
12822: LD_VAR 0 10
12826: PPUSH
12827: CALL_OW 380
12831: GO 12848
// PrepareHuman ( false , 1 , skill ) ;
12833: LD_INT 0
12835: PPUSH
12836: LD_INT 1
12838: PPUSH
12839: LD_VAR 0 10
12843: PPUSH
12844: CALL_OW 380
// un := CreateHuman ;
12848: LD_ADDR_VAR 0 4
12852: PUSH
12853: CALL_OW 44
12857: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12858: LD_ADDR_EXP 39
12862: PUSH
12863: LD_EXP 39
12867: PUSH
12868: LD_VAR 0 4
12872: ADD
12873: ST_TO_ADDR
// end ;
12874: GO 12803
12876: POP
12877: POP
// for i = 1 to mech do
12878: LD_ADDR_VAR 0 3
12882: PUSH
12883: DOUBLE
12884: LD_INT 1
12886: DEC
12887: ST_TO_ADDR
12888: LD_VAR 0 7
12892: PUSH
12893: FOR_TO
12894: IFFALSE 12951
// begin PrepareHuman ( false , 3 , skill ) ;
12896: LD_INT 0
12898: PPUSH
12899: LD_INT 3
12901: PPUSH
12902: LD_VAR 0 10
12906: PPUSH
12907: CALL_OW 380
// un := CreateHuman ;
12911: LD_ADDR_VAR 0 4
12915: PUSH
12916: CALL_OW 44
12920: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12921: LD_VAR 0 4
12925: PPUSH
12926: LD_INT 3
12928: PPUSH
12929: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12933: LD_ADDR_EXP 39
12937: PUSH
12938: LD_EXP 39
12942: PUSH
12943: LD_VAR 0 4
12947: ADD
12948: ST_TO_ADDR
// end ;
12949: GO 12893
12951: POP
12952: POP
// for i = 1 to sci do
12953: LD_ADDR_VAR 0 3
12957: PUSH
12958: DOUBLE
12959: LD_INT 1
12961: DEC
12962: ST_TO_ADDR
12963: LD_VAR 0 6
12967: PUSH
12968: FOR_TO
12969: IFFALSE 13014
// begin PrepareHuman ( false , 4 , skill ) ;
12971: LD_INT 0
12973: PPUSH
12974: LD_INT 4
12976: PPUSH
12977: LD_VAR 0 10
12981: PPUSH
12982: CALL_OW 380
// un := CreateHuman ;
12986: LD_ADDR_VAR 0 4
12990: PUSH
12991: CALL_OW 44
12995: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12996: LD_ADDR_EXP 39
13000: PUSH
13001: LD_EXP 39
13005: PUSH
13006: LD_VAR 0 4
13010: ADD
13011: ST_TO_ADDR
// end ;
13012: GO 12968
13014: POP
13015: POP
// for i = 1 to tank do
13016: LD_ADDR_VAR 0 3
13020: PUSH
13021: DOUBLE
13022: LD_INT 1
13024: DEC
13025: ST_TO_ADDR
13026: LD_VAR 0 8
13030: PUSH
13031: FOR_TO
13032: IFFALSE 13145
// begin Randomize ;
13034: CALL_OW 10
// vc_chassis := us_medium_tracked ;
13038: LD_ADDR_OWVAR 37
13042: PUSH
13043: LD_INT 3
13045: ST_TO_ADDR
// vc_engine := engine_solar ;
13046: LD_ADDR_OWVAR 39
13050: PUSH
13051: LD_INT 2
13053: ST_TO_ADDR
// vc_control := control_manual ;
13054: LD_ADDR_OWVAR 38
13058: PUSH
13059: LD_INT 1
13061: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
13062: LD_ADDR_OWVAR 40
13066: PUSH
13067: LD_INT 4
13069: PUSH
13070: LD_INT 5
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: PUSH
13077: LD_INT 1
13079: PPUSH
13080: LD_INT 2
13082: PPUSH
13083: CALL_OW 12
13087: ARRAY
13088: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13089: LD_ADDR_OWVAR 41
13093: PUSH
13094: LD_INT 35
13096: PPUSH
13097: LD_INT 55
13099: PPUSH
13100: CALL_OW 12
13104: ST_TO_ADDR
// un := CreateVehicle ;
13105: LD_ADDR_VAR 0 4
13109: PUSH
13110: CALL_OW 45
13114: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13115: LD_VAR 0 4
13119: PPUSH
13120: LD_INT 5
13122: PPUSH
13123: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13127: LD_ADDR_EXP 39
13131: PUSH
13132: LD_EXP 39
13136: PUSH
13137: LD_VAR 0 4
13141: ADD
13142: ST_TO_ADDR
// end ;
13143: GO 13031
13145: POP
13146: POP
// if cargo then
13147: LD_VAR 0 9
13151: IFFALSE 13254
// begin vc_chassis := us_medium_tracked ;
13153: LD_ADDR_OWVAR 37
13157: PUSH
13158: LD_INT 3
13160: ST_TO_ADDR
// vc_engine := engine_solar ;
13161: LD_ADDR_OWVAR 39
13165: PUSH
13166: LD_INT 2
13168: ST_TO_ADDR
// vc_control := control_manual ;
13169: LD_ADDR_OWVAR 38
13173: PUSH
13174: LD_INT 1
13176: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13177: LD_ADDR_OWVAR 40
13181: PUSH
13182: LD_INT 12
13184: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13185: LD_ADDR_OWVAR 41
13189: PUSH
13190: LD_INT 35
13192: PPUSH
13193: LD_INT 55
13195: PPUSH
13196: CALL_OW 12
13200: ST_TO_ADDR
// un := CreateVehicle ;
13201: LD_ADDR_VAR 0 4
13205: PUSH
13206: CALL_OW 45
13210: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13211: LD_VAR 0 4
13215: PPUSH
13216: LD_INT 5
13218: PPUSH
13219: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13223: LD_ADDR_EXP 39
13227: PUSH
13228: LD_EXP 39
13232: PUSH
13233: LD_VAR 0 4
13237: ADD
13238: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
13239: LD_VAR 0 4
13243: PPUSH
13244: LD_INT 1
13246: PPUSH
13247: LD_INT 60
13249: PPUSH
13250: CALL_OW 290
// end ; end ;
13254: LD_VAR 0 2
13258: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13259: LD_INT 0
13261: PPUSH
13262: PPUSH
13263: PPUSH
13264: PPUSH
13265: PPUSH
13266: PPUSH
13267: PPUSH
13268: PPUSH
13269: PPUSH
13270: PPUSH
// uc_side := 4 ;
13271: LD_ADDR_OWVAR 20
13275: PUSH
13276: LD_INT 4
13278: ST_TO_ADDR
// uc_nation := 1 ;
13279: LD_ADDR_OWVAR 21
13283: PUSH
13284: LD_INT 1
13286: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13287: LD_ADDR_VAR 0 11
13291: PUSH
13292: LD_INT 6
13294: PUSH
13295: LD_INT 5
13297: PUSH
13298: LD_INT 4
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: LIST
13305: PUSH
13306: LD_OWVAR 67
13310: ARRAY
13311: ST_TO_ADDR
// Gamma_Squad := [ ] ;
13312: LD_ADDR_EXP 40
13316: PUSH
13317: EMPTY
13318: ST_TO_ADDR
// case num of 1 :
13319: LD_VAR 0 1
13323: PUSH
13324: LD_INT 1
13326: DOUBLE
13327: EQUAL
13328: IFTRUE 13332
13330: GO 13383
13332: POP
// begin sold := 2 ;
13333: LD_ADDR_VAR 0 5
13337: PUSH
13338: LD_INT 2
13340: ST_TO_ADDR
// eng := 2 ;
13341: LD_ADDR_VAR 0 6
13345: PUSH
13346: LD_INT 2
13348: ST_TO_ADDR
// sci := 0 ;
13349: LD_ADDR_VAR 0 7
13353: PUSH
13354: LD_INT 0
13356: ST_TO_ADDR
// mech := 1 ;
13357: LD_ADDR_VAR 0 8
13361: PUSH
13362: LD_INT 1
13364: ST_TO_ADDR
// tank := 0 ;
13365: LD_ADDR_VAR 0 9
13369: PUSH
13370: LD_INT 0
13372: ST_TO_ADDR
// cargo := 1 ;
13373: LD_ADDR_VAR 0 10
13377: PUSH
13378: LD_INT 1
13380: ST_TO_ADDR
// end ; 2 :
13381: GO 13502
13383: LD_INT 2
13385: DOUBLE
13386: EQUAL
13387: IFTRUE 13391
13389: GO 13442
13391: POP
// begin sold := 1 ;
13392: LD_ADDR_VAR 0 5
13396: PUSH
13397: LD_INT 1
13399: ST_TO_ADDR
// eng := 2 ;
13400: LD_ADDR_VAR 0 6
13404: PUSH
13405: LD_INT 2
13407: ST_TO_ADDR
// sci := 0 ;
13408: LD_ADDR_VAR 0 7
13412: PUSH
13413: LD_INT 0
13415: ST_TO_ADDR
// mech := 1 ;
13416: LD_ADDR_VAR 0 8
13420: PUSH
13421: LD_INT 1
13423: ST_TO_ADDR
// tank := 0 ;
13424: LD_ADDR_VAR 0 9
13428: PUSH
13429: LD_INT 0
13431: ST_TO_ADDR
// cargo := 1 ;
13432: LD_ADDR_VAR 0 10
13436: PUSH
13437: LD_INT 1
13439: ST_TO_ADDR
// end ; 3 :
13440: GO 13502
13442: LD_INT 3
13444: DOUBLE
13445: EQUAL
13446: IFTRUE 13450
13448: GO 13501
13450: POP
// begin sold := 1 ;
13451: LD_ADDR_VAR 0 5
13455: PUSH
13456: LD_INT 1
13458: ST_TO_ADDR
// eng := 1 ;
13459: LD_ADDR_VAR 0 6
13463: PUSH
13464: LD_INT 1
13466: ST_TO_ADDR
// sci := 0 ;
13467: LD_ADDR_VAR 0 7
13471: PUSH
13472: LD_INT 0
13474: ST_TO_ADDR
// mech := 1 ;
13475: LD_ADDR_VAR 0 8
13479: PUSH
13480: LD_INT 1
13482: ST_TO_ADDR
// tank := 0 ;
13483: LD_ADDR_VAR 0 9
13487: PUSH
13488: LD_INT 0
13490: ST_TO_ADDR
// cargo := 1 ;
13491: LD_ADDR_VAR 0 10
13495: PUSH
13496: LD_INT 1
13498: ST_TO_ADDR
// end ; end ;
13499: GO 13502
13501: POP
// for i = 1 to sold do
13502: LD_ADDR_VAR 0 3
13506: PUSH
13507: DOUBLE
13508: LD_INT 1
13510: DEC
13511: ST_TO_ADDR
13512: LD_VAR 0 5
13516: PUSH
13517: FOR_TO
13518: IFFALSE 13590
// begin if i = 1 then
13520: LD_VAR 0 3
13524: PUSH
13525: LD_INT 1
13527: EQUAL
13528: IFFALSE 13547
// PrepareHuman ( sex_male , 1 , skill ) else
13530: LD_INT 1
13532: PPUSH
13533: LD_INT 1
13535: PPUSH
13536: LD_VAR 0 11
13540: PPUSH
13541: CALL_OW 380
13545: GO 13562
// PrepareHuman ( false , 1 , skill ) ;
13547: LD_INT 0
13549: PPUSH
13550: LD_INT 1
13552: PPUSH
13553: LD_VAR 0 11
13557: PPUSH
13558: CALL_OW 380
// un := CreateHuman ;
13562: LD_ADDR_VAR 0 4
13566: PUSH
13567: CALL_OW 44
13571: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13572: LD_ADDR_EXP 40
13576: PUSH
13577: LD_EXP 40
13581: PUSH
13582: LD_VAR 0 4
13586: ADD
13587: ST_TO_ADDR
// end ;
13588: GO 13517
13590: POP
13591: POP
// for i = 1 to mech do
13592: LD_ADDR_VAR 0 3
13596: PUSH
13597: DOUBLE
13598: LD_INT 1
13600: DEC
13601: ST_TO_ADDR
13602: LD_VAR 0 8
13606: PUSH
13607: FOR_TO
13608: IFFALSE 13665
// begin PrepareHuman ( false , 3 , skill ) ;
13610: LD_INT 0
13612: PPUSH
13613: LD_INT 3
13615: PPUSH
13616: LD_VAR 0 11
13620: PPUSH
13621: CALL_OW 380
// un := CreateHuman ;
13625: LD_ADDR_VAR 0 4
13629: PUSH
13630: CALL_OW 44
13634: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13635: LD_VAR 0 4
13639: PPUSH
13640: LD_INT 3
13642: PPUSH
13643: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13647: LD_ADDR_EXP 40
13651: PUSH
13652: LD_EXP 40
13656: PUSH
13657: LD_VAR 0 4
13661: ADD
13662: ST_TO_ADDR
// end ;
13663: GO 13607
13665: POP
13666: POP
// for i = 1 to eng do
13667: LD_ADDR_VAR 0 3
13671: PUSH
13672: DOUBLE
13673: LD_INT 1
13675: DEC
13676: ST_TO_ADDR
13677: LD_VAR 0 6
13681: PUSH
13682: FOR_TO
13683: IFFALSE 13728
// begin PrepareHuman ( false , 2 , skill ) ;
13685: LD_INT 0
13687: PPUSH
13688: LD_INT 2
13690: PPUSH
13691: LD_VAR 0 11
13695: PPUSH
13696: CALL_OW 380
// un := CreateHuman ;
13700: LD_ADDR_VAR 0 4
13704: PUSH
13705: CALL_OW 44
13709: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13710: LD_ADDR_EXP 40
13714: PUSH
13715: LD_EXP 40
13719: PUSH
13720: LD_VAR 0 4
13724: ADD
13725: ST_TO_ADDR
// end ;
13726: GO 13682
13728: POP
13729: POP
// for i = 1 to tank do
13730: LD_ADDR_VAR 0 3
13734: PUSH
13735: DOUBLE
13736: LD_INT 1
13738: DEC
13739: ST_TO_ADDR
13740: LD_VAR 0 9
13744: PUSH
13745: FOR_TO
13746: IFFALSE 13859
// begin Randomize ;
13748: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13752: LD_ADDR_OWVAR 37
13756: PUSH
13757: LD_INT 2
13759: ST_TO_ADDR
// vc_engine := engine_siberite ;
13760: LD_ADDR_OWVAR 39
13764: PUSH
13765: LD_INT 3
13767: ST_TO_ADDR
// vc_control := control_manual ;
13768: LD_ADDR_OWVAR 38
13772: PUSH
13773: LD_INT 1
13775: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13776: LD_ADDR_OWVAR 40
13780: PUSH
13781: LD_INT 7
13783: PUSH
13784: LD_INT 9
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PUSH
13791: LD_INT 1
13793: PPUSH
13794: LD_INT 2
13796: PPUSH
13797: CALL_OW 12
13801: ARRAY
13802: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13803: LD_ADDR_OWVAR 41
13807: PUSH
13808: LD_INT 35
13810: PPUSH
13811: LD_INT 55
13813: PPUSH
13814: CALL_OW 12
13818: ST_TO_ADDR
// un := CreateVehicle ;
13819: LD_ADDR_VAR 0 4
13823: PUSH
13824: CALL_OW 45
13828: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13829: LD_VAR 0 4
13833: PPUSH
13834: LD_INT 5
13836: PPUSH
13837: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13841: LD_ADDR_EXP 40
13845: PUSH
13846: LD_EXP 40
13850: PUSH
13851: LD_VAR 0 4
13855: ADD
13856: ST_TO_ADDR
// end ;
13857: GO 13745
13859: POP
13860: POP
// if cargo then
13861: LD_VAR 0 10
13865: IFFALSE 13983
// begin vc_chassis := us_medium_tracked ;
13867: LD_ADDR_OWVAR 37
13871: PUSH
13872: LD_INT 3
13874: ST_TO_ADDR
// vc_engine := engine_combustion ;
13875: LD_ADDR_OWVAR 39
13879: PUSH
13880: LD_INT 1
13882: ST_TO_ADDR
// vc_control := control_manual ;
13883: LD_ADDR_OWVAR 38
13887: PUSH
13888: LD_INT 1
13890: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13891: LD_ADDR_OWVAR 40
13895: PUSH
13896: LD_INT 12
13898: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13899: LD_ADDR_OWVAR 41
13903: PUSH
13904: LD_INT 35
13906: PPUSH
13907: LD_INT 55
13909: PPUSH
13910: CALL_OW 12
13914: ST_TO_ADDR
// un := CreateVehicle ;
13915: LD_ADDR_VAR 0 4
13919: PUSH
13920: CALL_OW 45
13924: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13925: LD_VAR 0 4
13929: PPUSH
13930: LD_INT 5
13932: PPUSH
13933: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13937: LD_ADDR_EXP 40
13941: PUSH
13942: LD_EXP 40
13946: PUSH
13947: LD_VAR 0 4
13951: ADD
13952: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13953: LD_VAR 0 4
13957: PPUSH
13958: LD_INT 3
13960: PPUSH
13961: LD_INT 30
13963: PPUSH
13964: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13968: LD_VAR 0 4
13972: PPUSH
13973: LD_INT 1
13975: PPUSH
13976: LD_INT 40
13978: PPUSH
13979: CALL_OW 290
// end ; end ;
13983: LD_VAR 0 2
13987: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13988: LD_INT 0
13990: PPUSH
13991: PPUSH
13992: PPUSH
13993: PPUSH
13994: PPUSH
13995: PPUSH
13996: PPUSH
13997: PPUSH
13998: PPUSH
13999: PPUSH
// uc_side := 4 ;
14000: LD_ADDR_OWVAR 20
14004: PUSH
14005: LD_INT 4
14007: ST_TO_ADDR
// uc_nation := 1 ;
14008: LD_ADDR_OWVAR 21
14012: PUSH
14013: LD_INT 1
14015: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
14016: LD_ADDR_VAR 0 10
14020: PUSH
14021: LD_INT 6
14023: PUSH
14024: LD_INT 5
14026: PUSH
14027: LD_INT 4
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: PUSH
14035: LD_OWVAR 67
14039: ARRAY
14040: ST_TO_ADDR
// Zeta_Squad := [ ] ;
14041: LD_ADDR_EXP 41
14045: PUSH
14046: EMPTY
14047: ST_TO_ADDR
// sold := 1 ;
14048: LD_ADDR_VAR 0 4
14052: PUSH
14053: LD_INT 1
14055: ST_TO_ADDR
// eng := 0 ;
14056: LD_ADDR_VAR 0 5
14060: PUSH
14061: LD_INT 0
14063: ST_TO_ADDR
// sci := 0 ;
14064: LD_ADDR_VAR 0 6
14068: PUSH
14069: LD_INT 0
14071: ST_TO_ADDR
// mech := 3 ;
14072: LD_ADDR_VAR 0 7
14076: PUSH
14077: LD_INT 3
14079: ST_TO_ADDR
// tank := 3 ;
14080: LD_ADDR_VAR 0 8
14084: PUSH
14085: LD_INT 3
14087: ST_TO_ADDR
// cargo := 0 ;
14088: LD_ADDR_VAR 0 9
14092: PUSH
14093: LD_INT 0
14095: ST_TO_ADDR
// for i = 1 to sold do
14096: LD_ADDR_VAR 0 2
14100: PUSH
14101: DOUBLE
14102: LD_INT 1
14104: DEC
14105: ST_TO_ADDR
14106: LD_VAR 0 4
14110: PUSH
14111: FOR_TO
14112: IFFALSE 14184
// begin if i = 1 then
14114: LD_VAR 0 2
14118: PUSH
14119: LD_INT 1
14121: EQUAL
14122: IFFALSE 14141
// PrepareHuman ( sex_male , 1 , skill ) else
14124: LD_INT 1
14126: PPUSH
14127: LD_INT 1
14129: PPUSH
14130: LD_VAR 0 10
14134: PPUSH
14135: CALL_OW 380
14139: GO 14156
// PrepareHuman ( false , 1 , skill ) ;
14141: LD_INT 0
14143: PPUSH
14144: LD_INT 1
14146: PPUSH
14147: LD_VAR 0 10
14151: PPUSH
14152: CALL_OW 380
// un := CreateHuman ;
14156: LD_ADDR_VAR 0 3
14160: PUSH
14161: CALL_OW 44
14165: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
14166: LD_ADDR_EXP 41
14170: PUSH
14171: LD_EXP 41
14175: PUSH
14176: LD_VAR 0 3
14180: ADD
14181: ST_TO_ADDR
// end ;
14182: GO 14111
14184: POP
14185: POP
// for i = 1 to mech do
14186: LD_ADDR_VAR 0 2
14190: PUSH
14191: DOUBLE
14192: LD_INT 1
14194: DEC
14195: ST_TO_ADDR
14196: LD_VAR 0 7
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14259
// begin PrepareHuman ( false , 3 , skill ) ;
14204: LD_INT 0
14206: PPUSH
14207: LD_INT 3
14209: PPUSH
14210: LD_VAR 0 10
14214: PPUSH
14215: CALL_OW 380
// un := CreateHuman ;
14219: LD_ADDR_VAR 0 3
14223: PUSH
14224: CALL_OW 44
14228: ST_TO_ADDR
// SetTag ( un , 3 ) ;
14229: LD_VAR 0 3
14233: PPUSH
14234: LD_INT 3
14236: PPUSH
14237: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14241: LD_ADDR_EXP 41
14245: PUSH
14246: LD_EXP 41
14250: PUSH
14251: LD_VAR 0 3
14255: ADD
14256: ST_TO_ADDR
// end ;
14257: GO 14201
14259: POP
14260: POP
// for i = 1 to tank do
14261: LD_ADDR_VAR 0 2
14265: PUSH
14266: DOUBLE
14267: LD_INT 1
14269: DEC
14270: ST_TO_ADDR
14271: LD_VAR 0 8
14275: PUSH
14276: FOR_TO
14277: IFFALSE 14523
// begin Randomize ;
14279: CALL_OW 10
// if i < 3 then
14283: LD_VAR 0 2
14287: PUSH
14288: LD_INT 3
14290: LESS
14291: IFFALSE 14400
// begin vc_chassis := us_medium_tracked ;
14293: LD_ADDR_OWVAR 37
14297: PUSH
14298: LD_INT 3
14300: ST_TO_ADDR
// vc_engine := engine_combustion ;
14301: LD_ADDR_OWVAR 39
14305: PUSH
14306: LD_INT 1
14308: ST_TO_ADDR
// vc_control := control_manual ;
14309: LD_ADDR_OWVAR 38
14313: PUSH
14314: LD_INT 1
14316: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
14317: LD_ADDR_OWVAR 40
14321: PUSH
14322: LD_INT 3
14324: PUSH
14325: LD_INT 9
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: PUSH
14332: LD_INT 1
14334: PPUSH
14335: LD_INT 2
14337: PPUSH
14338: CALL_OW 12
14342: ARRAY
14343: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14344: LD_ADDR_OWVAR 41
14348: PUSH
14349: LD_INT 35
14351: PPUSH
14352: LD_INT 55
14354: PPUSH
14355: CALL_OW 12
14359: ST_TO_ADDR
// un := CreateVehicle ;
14360: LD_ADDR_VAR 0 3
14364: PUSH
14365: CALL_OW 45
14369: ST_TO_ADDR
// SetTag ( un , 5 ) ;
14370: LD_VAR 0 3
14374: PPUSH
14375: LD_INT 5
14377: PPUSH
14378: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14382: LD_ADDR_EXP 41
14386: PUSH
14387: LD_EXP 41
14391: PUSH
14392: LD_VAR 0 3
14396: ADD
14397: ST_TO_ADDR
// end else
14398: GO 14521
// begin uc_nation := 3 ;
14400: LD_ADDR_OWVAR 21
14404: PUSH
14405: LD_INT 3
14407: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
14408: LD_ADDR_OWVAR 37
14412: PUSH
14413: LD_INT 22
14415: ST_TO_ADDR
// vc_engine := engine_combustion ;
14416: LD_ADDR_OWVAR 39
14420: PUSH
14421: LD_INT 1
14423: ST_TO_ADDR
// vc_control := control_manual ;
14424: LD_ADDR_OWVAR 38
14428: PUSH
14429: LD_INT 1
14431: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
14432: LD_ADDR_OWVAR 40
14436: PUSH
14437: LD_INT 51
14439: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14440: LD_ADDR_OWVAR 41
14444: PUSH
14445: LD_INT 35
14447: PPUSH
14448: LD_INT 55
14450: PPUSH
14451: CALL_OW 12
14455: ST_TO_ADDR
// un := CreateVehicle ;
14456: LD_ADDR_VAR 0 3
14460: PUSH
14461: CALL_OW 45
14465: ST_TO_ADDR
// SetLives ( un , 496 ) ;
14466: LD_VAR 0 3
14470: PPUSH
14471: LD_INT 496
14473: PPUSH
14474: CALL_OW 234
// SetTag ( un , 5 ) ;
14478: LD_VAR 0 3
14482: PPUSH
14483: LD_INT 5
14485: PPUSH
14486: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
14490: LD_VAR 0 3
14494: PPUSH
14495: LD_INT 2
14497: PPUSH
14498: LD_INT 100
14500: PPUSH
14501: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
14505: LD_ADDR_EXP 41
14509: PUSH
14510: LD_EXP 41
14514: PUSH
14515: LD_VAR 0 3
14519: ADD
14520: ST_TO_ADDR
// end ; end ;
14521: GO 14276
14523: POP
14524: POP
// end ; end_of_file
14525: LD_VAR 0 1
14529: RET
// export function Action ; begin
14530: LD_INT 0
14532: PPUSH
// InGameOn ;
14533: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
14537: LD_INT 151
14539: PPUSH
14540: LD_INT 107
14542: PPUSH
14543: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
14547: LD_EXP 37
14551: PPUSH
14552: LD_INT 171
14554: PPUSH
14555: LD_INT 108
14557: PPUSH
14558: LD_INT 0
14560: PPUSH
14561: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
14565: LD_EXP 38
14569: PPUSH
14570: LD_INT 172
14572: PPUSH
14573: LD_INT 110
14575: PPUSH
14576: LD_INT 0
14578: PPUSH
14579: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
14583: LD_EXP 37
14587: PPUSH
14588: LD_INT 156
14590: PPUSH
14591: LD_INT 107
14593: PPUSH
14594: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
14598: LD_EXP 38
14602: PPUSH
14603: LD_INT 154
14605: PPUSH
14606: LD_INT 105
14608: PPUSH
14609: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
14613: LD_INT 4
14615: PPUSH
14616: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
14620: LD_EXP 37
14624: PPUSH
14625: CALL_OW 250
14629: PUSH
14630: LD_INT 156
14632: EQUAL
14633: PUSH
14634: LD_EXP 37
14638: PPUSH
14639: CALL_OW 251
14643: PUSH
14644: LD_INT 107
14646: EQUAL
14647: AND
14648: IFFALSE 14613
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14650: LD_EXP 37
14654: PUSH
14655: LD_EXP 38
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PPUSH
14664: LD_INT 35
14666: PPUSH
14667: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14671: LD_EXP 37
14675: PPUSH
14676: LD_STRING D1-A-1
14678: PPUSH
14679: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14683: LD_EXP 38
14687: PPUSH
14688: LD_STRING D1-B-1
14690: PPUSH
14691: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14695: LD_EXP 37
14699: PPUSH
14700: LD_STRING D1-A-2
14702: PPUSH
14703: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14707: LD_EXP 38
14711: PPUSH
14712: LD_STRING D1-B-2
14714: PPUSH
14715: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14719: LD_EXP 37
14723: PUSH
14724: LD_EXP 38
14728: PUSH
14729: EMPTY
14730: LIST
14731: LIST
14732: PPUSH
14733: LD_INT 147
14735: PPUSH
14736: LD_INT 108
14738: PPUSH
14739: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14743: LD_EXP 37
14747: PPUSH
14748: LD_STRING D1-A-3
14750: PPUSH
14751: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14755: LD_INT 4
14757: PPUSH
14758: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14762: LD_EXP 37
14766: PPUSH
14767: LD_INT 35
14769: PPUSH
14770: CALL_OW 296
14774: PUSH
14775: LD_INT 8
14777: LESS
14778: IFFALSE 14755
// ComTurnUnit ( guyA , guyB ) ;
14780: LD_EXP 37
14784: PPUSH
14785: LD_EXP 38
14789: PPUSH
14790: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14794: LD_EXP 38
14798: PPUSH
14799: LD_EXP 37
14803: PPUSH
14804: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14808: LD_EXP 37
14812: PPUSH
14813: LD_STRING D1-A-10
14815: PPUSH
14816: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14820: LD_EXP 38
14824: PPUSH
14825: LD_STRING D1-B-10
14827: PPUSH
14828: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14832: LD_EXP 37
14836: PPUSH
14837: LD_STRING D1-A-11
14839: PPUSH
14840: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14844: LD_EXP 38
14848: PPUSH
14849: LD_STRING D1-B-11
14851: PPUSH
14852: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14856: LD_EXP 37
14860: PPUSH
14861: LD_STRING D1-A-12
14863: PPUSH
14864: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14868: LD_EXP 38
14872: PPUSH
14873: LD_STRING D1-B-12
14875: PPUSH
14876: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14880: LD_EXP 37
14884: PPUSH
14885: LD_STRING D1-A-13
14887: PPUSH
14888: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14892: LD_EXP 38
14896: PPUSH
14897: LD_STRING D1-B-13
14899: PPUSH
14900: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14904: LD_EXP 37
14908: PPUSH
14909: LD_STRING D1-A-14
14911: PPUSH
14912: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14916: LD_EXP 38
14920: PPUSH
14921: LD_STRING D1-B-14
14923: PPUSH
14924: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14928: LD_EXP 37
14932: PPUSH
14933: LD_STRING D1-A-15
14935: PPUSH
14936: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14940: LD_EXP 38
14944: PPUSH
14945: LD_STRING D1-B-15
14947: PPUSH
14948: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14952: LD_EXP 37
14956: PPUSH
14957: LD_STRING D1-A-16
14959: PPUSH
14960: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14964: LD_EXP 38
14968: PPUSH
14969: LD_STRING D1-B-16
14971: PPUSH
14972: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14976: LD_EXP 37
14980: PPUSH
14981: LD_STRING D1-A-17
14983: PPUSH
14984: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14988: LD_EXP 38
14992: PPUSH
14993: LD_STRING D1-B-17
14995: PPUSH
14996: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
15000: LD_EXP 37
15004: PPUSH
15005: LD_STRING D1-A-18
15007: PPUSH
15008: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
15012: LD_INT 35
15014: PPUSH
15015: LD_INT 1
15017: PPUSH
15018: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
15022: LD_EXP 37
15026: PUSH
15027: LD_EXP 38
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: PPUSH
15036: LD_INT 35
15038: PPUSH
15039: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
15043: LD_INT 4
15045: PPUSH
15046: CALL_OW 67
// until IsInUnit ( guyA ) ;
15050: LD_EXP 37
15054: PPUSH
15055: CALL_OW 310
15059: IFFALSE 15043
// Wait ( 0 0$02 ) ;
15061: LD_INT 70
15063: PPUSH
15064: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
15068: LD_EXP 37
15072: PPUSH
15073: LD_STRING D1-A-19
15075: PPUSH
15076: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
15080: LD_EXP 38
15084: PPUSH
15085: LD_STRING D1-B-19
15087: PPUSH
15088: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
15092: LD_EXP 37
15096: PPUSH
15097: LD_STRING D1-A-20
15099: PPUSH
15100: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
15104: LD_INT 10
15106: PPUSH
15107: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
15111: LD_EXP 38
15115: PPUSH
15116: LD_STRING D1-B-20
15118: PPUSH
15119: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
15123: LD_EXP 37
15127: PPUSH
15128: LD_STRING D1-A-21
15130: PPUSH
15131: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
15135: LD_EXP 38
15139: PPUSH
15140: LD_STRING D1-B-21
15142: PPUSH
15143: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
15147: LD_EXP 37
15151: PPUSH
15152: LD_STRING D1-A-22
15154: PPUSH
15155: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
15159: LD_EXP 38
15163: PPUSH
15164: LD_STRING D1-B-22
15166: PPUSH
15167: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
15171: LD_EXP 37
15175: PPUSH
15176: LD_STRING D1-A-23
15178: PPUSH
15179: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
15183: LD_EXP 38
15187: PPUSH
15188: LD_STRING D1-B-23
15190: PPUSH
15191: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
15195: LD_EXP 37
15199: PPUSH
15200: LD_STRING D1-A-24
15202: PPUSH
15203: CALL_OW 88
// InGameOff ;
15207: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
15211: LD_STRING M_main
15213: PPUSH
15214: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
15218: LD_INT 4
15220: PPUSH
15221: LD_INT 1
15223: PPUSH
15224: CALL_OW 343
// game_status := true ;
15228: LD_ADDR_EXP 28
15232: PUSH
15233: LD_INT 1
15235: ST_TO_ADDR
// end ;
15236: LD_VAR 0 1
15240: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
15241: LD_INT 1
15243: PPUSH
15244: CALL 6928 0 1
15248: PUSH
15249: LD_INT 0
15251: GREATER
15252: IFFALSE 15354
15254: GO 15256
15256: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15257: LD_INT 35
15259: PPUSH
15260: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
15264: LD_INT 1
15266: PPUSH
15267: CALL 6928 0 1
15271: PUSH
15272: LD_INT 1
15274: ARRAY
15275: PPUSH
15276: CALL_OW 461
15280: PUSH
15281: LD_INT 1
15283: NONEQUAL
15284: IFFALSE 15257
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
15286: LD_EXP 37
15290: PPUSH
15291: CALL_OW 300
15295: PUSH
15296: LD_EXP 38
15300: PPUSH
15301: CALL_OW 300
15305: AND
15306: PUSH
15307: LD_EXP 29
15311: NOT
15312: AND
15313: IFFALSE 15339
// begin Say ( guyA , DL-A-1 ) ;
15315: LD_EXP 37
15319: PPUSH
15320: LD_STRING DL-A-1
15322: PPUSH
15323: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
15327: LD_EXP 38
15331: PPUSH
15332: LD_STRING DL-B-1
15334: PPUSH
15335: CALL_OW 88
// end ; if not helps_can_arrive then
15339: LD_EXP 30
15343: NOT
15344: IFFALSE 15354
// helps_can_arrive := true ;
15346: LD_ADDR_EXP 30
15350: PUSH
15351: LD_INT 1
15353: ST_TO_ADDR
// end ;
15354: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
15355: LD_INT 1
15357: PPUSH
15358: CALL 6928 0 1
15362: PUSH
15363: LD_INT 0
15365: GREATER
15366: PUSH
15367: LD_EXP 37
15371: PPUSH
15372: CALL_OW 300
15376: AND
15377: PUSH
15378: LD_EXP 38
15382: PPUSH
15383: CALL_OW 300
15387: AND
15388: PUSH
15389: LD_INT 22
15391: PUSH
15392: LD_INT 1
15394: PUSH
15395: EMPTY
15396: LIST
15397: LIST
15398: PUSH
15399: LD_INT 25
15401: PUSH
15402: LD_INT 12
15404: PUSH
15405: EMPTY
15406: LIST
15407: LIST
15408: PUSH
15409: EMPTY
15410: LIST
15411: LIST
15412: PPUSH
15413: CALL_OW 69
15417: PUSH
15418: LD_INT 0
15420: EQUAL
15421: AND
15422: PUSH
15423: LD_INT 1
15425: PPUSH
15426: LD_INT 25
15428: PUSH
15429: LD_INT 12
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PPUSH
15436: CALL_OW 69
15440: PPUSH
15441: LD_EXP 37
15445: PPUSH
15446: CALL_OW 74
15450: PPUSH
15451: CALL_OW 292
15455: AND
15456: IFFALSE 15497
15458: GO 15460
15460: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
15461: LD_EXP 37
15465: PPUSH
15466: LD_STRING DA-A-1
15468: PPUSH
15469: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
15473: LD_EXP 38
15477: PPUSH
15478: LD_STRING DA-B-1
15480: PPUSH
15481: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
15485: LD_EXP 37
15489: PPUSH
15490: LD_STRING DA-A-2
15492: PPUSH
15493: CALL_OW 88
// end ;
15497: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
15498: LD_EXP 28
15502: PUSH
15503: LD_EXP 37
15507: PPUSH
15508: LD_INT 6
15510: PPUSH
15511: CALL_OW 299
15515: PUSH
15516: LD_INT 7
15518: LESS
15519: AND
15520: IFFALSE 15573
15522: GO 15524
15524: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
15525: LD_INT 117
15527: PPUSH
15528: LD_INT 50
15530: PPUSH
15531: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
15535: LD_INT 1
15537: PPUSH
15538: CALL 10669 0 1
15542: PUSH
15543: LD_INT 2
15545: ARRAY
15546: PPUSH
15547: LD_STRING D5-A-1
15549: PPUSH
15550: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
15554: LD_INT 1
15556: PPUSH
15557: CALL 10669 0 1
15561: PUSH
15562: LD_INT 1
15564: ARRAY
15565: PPUSH
15566: LD_STRING D5-B-1
15568: PPUSH
15569: CALL_OW 88
// end ;
15573: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
15574: LD_INT 7
15576: PPUSH
15577: LD_INT 22
15579: PUSH
15580: LD_INT 1
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: PPUSH
15587: CALL_OW 70
15591: PUSH
15592: LD_INT 0
15594: GREATER
15595: IFFALSE 15740
15597: GO 15599
15599: DISABLE
// begin Wait ( 0 0$03 ) ;
15600: LD_INT 105
15602: PPUSH
15603: CALL_OW 67
// DialogueOn ;
15607: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
15611: LD_INT 1
15613: PPUSH
15614: CALL 10669 0 1
15618: PUSH
15619: LD_INT 1
15621: ARRAY
15622: PPUSH
15623: LD_STRING D6-A-1
15625: PPUSH
15626: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15630: LD_INT 1
15632: PPUSH
15633: CALL 10669 0 1
15637: PUSH
15638: LD_INT 2
15640: ARRAY
15641: PPUSH
15642: LD_STRING D6-B-1
15644: PPUSH
15645: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15649: LD_INT 95
15651: PPUSH
15652: LD_INT 8
15654: PPUSH
15655: LD_INT 1
15657: PPUSH
15658: LD_INT 20
15660: PPUSH
15661: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15665: LD_INT 10
15667: PPUSH
15668: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15672: LD_INT 1
15674: PPUSH
15675: CALL 10669 0 1
15679: PUSH
15680: LD_INT 1
15682: ARRAY
15683: PPUSH
15684: LD_STRING D6-A-2
15686: PPUSH
15687: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15691: LD_INT 1
15693: PPUSH
15694: CALL 10669 0 1
15698: PUSH
15699: LD_INT 2
15701: ARRAY
15702: PPUSH
15703: LD_STRING D6-B-2
15705: PPUSH
15706: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15710: LD_INT 1
15712: PPUSH
15713: CALL 10669 0 1
15717: PUSH
15718: LD_INT 1
15720: ARRAY
15721: PPUSH
15722: LD_STRING D6-A-3
15724: PPUSH
15725: CALL_OW 88
// DialogueOff ;
15729: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15733: LD_STRING M_base
15735: PPUSH
15736: CALL_OW 337
// end ;
15740: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15741: LD_EXP 29
15745: NOT
15746: PUSH
15747: LD_INT 22
15749: PUSH
15750: LD_INT 3
15752: PUSH
15753: EMPTY
15754: LIST
15755: LIST
15756: PUSH
15757: LD_INT 21
15759: PUSH
15760: LD_INT 2
15762: PUSH
15763: EMPTY
15764: LIST
15765: LIST
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PPUSH
15771: CALL_OW 69
15775: PUSH
15776: LD_INT 0
15778: GREATER
15779: AND
15780: IFFALSE 15913
15782: GO 15784
15784: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15785: LD_INT 35
15787: PPUSH
15788: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15792: LD_INT 22
15794: PUSH
15795: LD_INT 3
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: LD_INT 21
15804: PUSH
15805: LD_INT 2
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PPUSH
15816: CALL_OW 69
15820: PPUSH
15821: LD_INT 1
15823: PPUSH
15824: CALL 10669 0 1
15828: PUSH
15829: LD_INT 1
15831: ARRAY
15832: PPUSH
15833: CALL_OW 74
15837: PPUSH
15838: LD_INT 1
15840: PPUSH
15841: CALL 10669 0 1
15845: PUSH
15846: LD_INT 1
15848: ARRAY
15849: PPUSH
15850: CALL_OW 296
15854: PUSH
15855: LD_INT 7
15857: LESS
15858: IFFALSE 15785
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15860: LD_INT 1
15862: PPUSH
15863: CALL 10669 0 1
15867: PUSH
15868: LD_INT 1
15870: ARRAY
15871: PPUSH
15872: LD_STRING DR-A-1
15874: PPUSH
15875: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15879: LD_INT 1
15881: PPUSH
15882: CALL 10669 0 1
15886: PUSH
15887: LD_INT 2
15889: ARRAY
15890: PPUSH
15891: LD_STRING DR-B-1
15893: PPUSH
15894: CALL_OW 88
// Wait ( 3 3$00 ) ;
15898: LD_INT 6300
15900: PPUSH
15901: CALL_OW 67
// ru_spotted := true ;
15905: LD_ADDR_EXP 15
15909: PUSH
15910: LD_INT 1
15912: ST_TO_ADDR
// end ;
15913: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15914: LD_INT 35
15916: PPUSH
15917: CALL_OW 300
15921: NOT
15922: IFFALSE 15946
15924: GO 15926
15926: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15927: LD_INT 1
15929: PPUSH
15930: CALL 10669 0 1
15934: PUSH
15935: LD_INT 1
15937: ARRAY
15938: PPUSH
15939: LD_STRING DDR-A-1
15941: PPUSH
15942: CALL_OW 88
15946: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15947: LD_INT 1
15949: PPUSH
15950: LD_INT 30
15952: PPUSH
15953: CALL 6777 0 2
15957: IFFALSE 16039
15959: GO 15961
15961: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15962: LD_INT 35
15964: PPUSH
15965: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15969: LD_INT 1
15971: PPUSH
15972: LD_INT 30
15974: PPUSH
15975: CALL 6777 0 2
15979: PUSH
15980: LD_INT 1
15982: ARRAY
15983: PPUSH
15984: CALL_OW 461
15988: PUSH
15989: LD_INT 1
15991: NONEQUAL
15992: IFFALSE 15962
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15994: LD_INT 1
15996: PPUSH
15997: CALL 10669 0 1
16001: PUSH
16002: LD_INT 1
16004: ARRAY
16005: PPUSH
16006: LD_STRING D8-A-1
16008: PPUSH
16009: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
16013: LD_INT 1
16015: PPUSH
16016: CALL 10669 0 1
16020: PUSH
16021: LD_INT 2
16023: ARRAY
16024: PPUSH
16025: LD_STRING D8-B-1
16027: PPUSH
16028: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
16032: LD_STRING M_mineok
16034: PPUSH
16035: CALL_OW 337
// end ;
16039: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
16040: LD_INT 22
16042: PUSH
16043: LD_INT 1
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: PUSH
16050: LD_INT 30
16052: PUSH
16053: LD_INT 0
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: PUSH
16060: LD_INT 3
16062: PUSH
16063: LD_INT 57
16065: PUSH
16066: EMPTY
16067: LIST
16068: PUSH
16069: EMPTY
16070: LIST
16071: LIST
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: LIST
16077: PPUSH
16078: CALL_OW 69
16082: PUSH
16083: LD_INT 1
16085: GREATER
16086: PUSH
16087: LD_INT 22
16089: PUSH
16090: LD_INT 1
16092: PUSH
16093: EMPTY
16094: LIST
16095: LIST
16096: PUSH
16097: LD_INT 30
16099: PUSH
16100: LD_INT 0
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PUSH
16107: LD_INT 3
16109: PUSH
16110: LD_INT 57
16112: PUSH
16113: EMPTY
16114: LIST
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: PUSH
16120: EMPTY
16121: LIST
16122: LIST
16123: LIST
16124: PPUSH
16125: CALL_OW 69
16129: PUSH
16130: LD_INT 1
16132: EQUAL
16133: PUSH
16134: LD_INT 35
16136: PPUSH
16137: CALL_OW 300
16141: NOT
16142: AND
16143: OR
16144: IFFALSE 16196
16146: GO 16148
16148: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
16149: LD_INT 22
16151: PUSH
16152: LD_INT 1
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: PUSH
16159: LD_INT 25
16161: PUSH
16162: LD_INT 2
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PPUSH
16173: CALL_OW 69
16177: PUSH
16178: LD_INT 1
16180: ARRAY
16181: PPUSH
16182: LD_STRING D7-A-1
16184: PPUSH
16185: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
16189: LD_STRING M_baseok
16191: PPUSH
16192: CALL_OW 337
// end ;
16196: END
// every 0 0$01 trigger mine_ck do
16197: LD_EXP 34
16201: IFFALSE 16232
16203: GO 16205
16205: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
16206: LD_INT 1
16208: PPUSH
16209: CALL 10669 0 1
16213: PUSH
16214: LD_INT 1
16216: ARRAY
16217: PPUSH
16218: LD_STRING D9-A-1
16220: PPUSH
16221: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
16225: LD_STRING M_minedest
16227: PPUSH
16228: CALL_OW 337
// end ;
16232: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
16233: LD_EXP 28
16237: IFFALSE 16743
16239: GO 16241
16241: DISABLE
16242: LD_INT 0
16244: PPUSH
16245: PPUSH
16246: PPUSH
16247: PPUSH
16248: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
16249: LD_OWVAR 67
16253: PPUSH
16254: CALL 12570 0 1
// if not helps_can_arrive then
16258: LD_EXP 30
16262: NOT
16263: IFFALSE 16291
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
16265: LD_EXP 39
16269: PUSH
16270: LD_INT 1
16272: ARRAY
16273: PPUSH
16274: LD_STRING DB-Delay
16276: PPUSH
16277: CALL_OW 94
// time := 10 10$00 ;
16281: LD_ADDR_VAR 0 1
16285: PUSH
16286: LD_INT 21000
16288: ST_TO_ADDR
// end else
16289: GO 16299
// time := 3 3$00 ;
16291: LD_ADDR_VAR 0 1
16295: PUSH
16296: LD_INT 6300
16298: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
16299: LD_ADDR_VAR 0 1
16303: PUSH
16304: LD_VAR 0 1
16308: PUSH
16309: LD_INT 35
16311: MINUS
16312: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
16313: LD_INT 35
16315: PPUSH
16316: CALL_OW 67
// end until time = 0 0$00 ;
16320: LD_VAR 0 1
16324: PUSH
16325: LD_INT 0
16327: EQUAL
16328: IFFALSE 16299
// helps_arrive := true ;
16330: LD_ADDR_EXP 29
16334: PUSH
16335: LD_INT 1
16337: ST_TO_ADDR
// if IsLive ( guyA ) then
16338: LD_EXP 37
16342: PPUSH
16343: CALL_OW 300
16347: IFFALSE 16361
// r := guyA else
16349: LD_ADDR_VAR 0 4
16353: PUSH
16354: LD_EXP 37
16358: ST_TO_ADDR
16359: GO 16371
// r := guyB ;
16361: LD_ADDR_VAR 0 4
16365: PUSH
16366: LD_EXP 38
16370: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
16371: LD_EXP 39
16375: PUSH
16376: LD_INT 1
16378: ARRAY
16379: PPUSH
16380: LD_STRING D2-A-1
16382: PPUSH
16383: CALL_OW 94
// Say ( r , D2-B-1 ) ;
16387: LD_VAR 0 4
16391: PPUSH
16392: LD_STRING D2-B-1
16394: PPUSH
16395: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
16399: LD_EXP 39
16403: PUSH
16404: LD_INT 1
16406: ARRAY
16407: PPUSH
16408: LD_STRING D2-A-2
16410: PPUSH
16411: CALL_OW 94
// Say ( r , D2-B-2 ) ;
16415: LD_VAR 0 4
16419: PPUSH
16420: LD_STRING D2-B-2
16422: PPUSH
16423: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
16427: LD_EXP 39
16431: PUSH
16432: LD_INT 1
16434: ARRAY
16435: PPUSH
16436: LD_STRING D2-A-3
16438: PPUSH
16439: CALL_OW 94
// Say ( r , D2-B-3 ) ;
16443: LD_VAR 0 4
16447: PPUSH
16448: LD_STRING D2-B-3
16450: PPUSH
16451: CALL_OW 88
// to_veh := [ ] ;
16455: LD_ADDR_VAR 0 5
16459: PUSH
16460: EMPTY
16461: ST_TO_ADDR
// for i = 1 to Beta_Squad do
16462: LD_ADDR_VAR 0 2
16466: PUSH
16467: DOUBLE
16468: LD_INT 1
16470: DEC
16471: ST_TO_ADDR
16472: LD_EXP 39
16476: PUSH
16477: FOR_TO
16478: IFFALSE 16741
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
16480: LD_EXP 39
16484: PUSH
16485: LD_VAR 0 2
16489: ARRAY
16490: PPUSH
16491: CALL_OW 110
16495: PUSH
16496: LD_INT 3
16498: EQUAL
16499: IFFALSE 16525
// to_veh := to_veh ^ Beta_Squad [ i ] else
16501: LD_ADDR_VAR 0 5
16505: PUSH
16506: LD_VAR 0 5
16510: PUSH
16511: LD_EXP 39
16515: PUSH
16516: LD_VAR 0 2
16520: ARRAY
16521: ADD
16522: ST_TO_ADDR
16523: GO 16650
// if GetTag ( Beta_Squad [ i ] ) = 5 then
16525: LD_EXP 39
16529: PUSH
16530: LD_VAR 0 2
16534: ARRAY
16535: PPUSH
16536: CALL_OW 110
16540: PUSH
16541: LD_INT 5
16543: EQUAL
16544: IFFALSE 16629
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
16546: LD_EXP 39
16550: PUSH
16551: LD_VAR 0 2
16555: ARRAY
16556: PPUSH
16557: LD_INT 4
16559: PPUSH
16560: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16564: LD_EXP 39
16568: PUSH
16569: LD_VAR 0 2
16573: ARRAY
16574: PPUSH
16575: LD_INT 5
16577: PPUSH
16578: LD_INT 0
16580: PPUSH
16581: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
16585: LD_VAR 0 5
16589: PUSH
16590: LD_INT 1
16592: ARRAY
16593: PPUSH
16594: LD_EXP 39
16598: PUSH
16599: LD_VAR 0 2
16603: ARRAY
16604: PPUSH
16605: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16609: LD_ADDR_VAR 0 5
16613: PUSH
16614: LD_VAR 0 5
16618: PPUSH
16619: LD_INT 1
16621: PPUSH
16622: CALL_OW 3
16626: ST_TO_ADDR
// end else
16627: GO 16650
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16629: LD_EXP 39
16633: PUSH
16634: LD_VAR 0 2
16638: ARRAY
16639: PPUSH
16640: LD_INT 5
16642: PPUSH
16643: LD_INT 0
16645: PPUSH
16646: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16650: LD_EXP 39
16654: PUSH
16655: LD_VAR 0 2
16659: ARRAY
16660: PPUSH
16661: LD_INT 165
16663: PPUSH
16664: LD_INT 105
16666: PPUSH
16667: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16671: LD_INT 70
16673: PPUSH
16674: LD_INT 140
16676: PPUSH
16677: CALL_OW 12
16681: PPUSH
16682: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16686: LD_EXP 39
16690: PUSH
16691: LD_VAR 0 2
16695: ARRAY
16696: PPUSH
16697: LD_INT 1
16699: PPUSH
16700: CALL_OW 235
// if i = 1 then
16704: LD_VAR 0 2
16708: PUSH
16709: LD_INT 1
16711: EQUAL
16712: IFFALSE 16724
// CenterNowOnXY ( 168 , 109 ) ;
16714: LD_INT 168
16716: PPUSH
16717: LD_INT 109
16719: PPUSH
16720: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16724: LD_EXP 39
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: CALL_OW 141
// end ;
16739: GO 16477
16741: POP
16742: POP
// end ;
16743: PPOPN 5
16745: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16746: LD_EXP 29
16750: IFFALSE 17779
16752: GO 16754
16754: DISABLE
16755: LD_INT 0
16757: PPUSH
16758: PPUSH
// begin Wait ( 5 5$00 ) ;
16759: LD_INT 10500
16761: PPUSH
16762: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16766: LD_OWVAR 67
16770: PPUSH
16771: CALL 13259 0 1
// to_veh := [ ] ;
16775: LD_ADDR_VAR 0 2
16779: PUSH
16780: EMPTY
16781: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16782: LD_ADDR_VAR 0 1
16786: PUSH
16787: DOUBLE
16788: LD_INT 1
16790: DEC
16791: ST_TO_ADDR
16792: LD_EXP 40
16796: PUSH
16797: FOR_TO
16798: IFFALSE 17026
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16800: LD_EXP 40
16804: PUSH
16805: LD_VAR 0 1
16809: ARRAY
16810: PPUSH
16811: CALL_OW 110
16815: PUSH
16816: LD_INT 3
16818: EQUAL
16819: IFFALSE 16845
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16821: LD_ADDR_VAR 0 2
16825: PUSH
16826: LD_VAR 0 2
16830: PUSH
16831: LD_EXP 40
16835: PUSH
16836: LD_VAR 0 1
16840: ARRAY
16841: ADD
16842: ST_TO_ADDR
16843: GO 16970
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16845: LD_EXP 40
16849: PUSH
16850: LD_VAR 0 1
16854: ARRAY
16855: PPUSH
16856: CALL_OW 110
16860: PUSH
16861: LD_INT 5
16863: EQUAL
16864: IFFALSE 16949
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16866: LD_EXP 40
16870: PUSH
16871: LD_VAR 0 1
16875: ARRAY
16876: PPUSH
16877: LD_INT 4
16879: PPUSH
16880: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16884: LD_EXP 40
16888: PUSH
16889: LD_VAR 0 1
16893: ARRAY
16894: PPUSH
16895: LD_INT 5
16897: PPUSH
16898: LD_INT 0
16900: PPUSH
16901: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16905: LD_VAR 0 2
16909: PUSH
16910: LD_INT 1
16912: ARRAY
16913: PPUSH
16914: LD_EXP 40
16918: PUSH
16919: LD_VAR 0 1
16923: ARRAY
16924: PPUSH
16925: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16929: LD_ADDR_VAR 0 2
16933: PUSH
16934: LD_VAR 0 2
16938: PPUSH
16939: LD_INT 1
16941: PPUSH
16942: CALL_OW 3
16946: ST_TO_ADDR
// end else
16947: GO 16970
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16949: LD_EXP 40
16953: PUSH
16954: LD_VAR 0 1
16958: ARRAY
16959: PPUSH
16960: LD_INT 5
16962: PPUSH
16963: LD_INT 0
16965: PPUSH
16966: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16970: LD_EXP 40
16974: PUSH
16975: LD_VAR 0 1
16979: ARRAY
16980: PPUSH
16981: LD_INT 164
16983: PPUSH
16984: LD_INT 104
16986: PPUSH
16987: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16991: LD_INT 70
16993: PPUSH
16994: LD_INT 140
16996: PPUSH
16997: CALL_OW 12
17001: PPUSH
17002: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
17006: LD_EXP 40
17010: PUSH
17011: LD_VAR 0 1
17015: ARRAY
17016: PPUSH
17017: LD_INT 1
17019: PPUSH
17020: CALL_OW 235
// end ;
17024: GO 16797
17026: POP
17027: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
17028: LD_EXP 40
17032: PUSH
17033: LD_INT 1
17035: ARRAY
17036: PPUSH
17037: LD_STRING D3-A-1
17039: PPUSH
17040: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
17044: LD_INT 1
17046: PPUSH
17047: CALL 10669 0 1
17051: PUSH
17052: LD_INT 1
17054: ARRAY
17055: PPUSH
17056: LD_STRING D3-B-1
17058: PPUSH
17059: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
17063: LD_EXP 40
17067: PUSH
17068: LD_INT 1
17070: ARRAY
17071: PPUSH
17072: LD_STRING D3-A-2
17074: PPUSH
17075: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
17079: LD_INT 1
17081: PPUSH
17082: CALL 10669 0 1
17086: PUSH
17087: LD_INT 1
17089: ARRAY
17090: PPUSH
17091: LD_STRING D3-B-2
17093: PPUSH
17094: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
17098: LD_EXP 40
17102: PUSH
17103: LD_INT 1
17105: ARRAY
17106: PPUSH
17107: LD_STRING D3-A-3
17109: PPUSH
17110: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
17114: LD_INT 1
17116: PPUSH
17117: CALL 10669 0 1
17121: PUSH
17122: LD_INT 1
17124: ARRAY
17125: PPUSH
17126: LD_STRING D3-B-3
17128: PPUSH
17129: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
17133: LD_EXP 40
17137: PUSH
17138: LD_INT 1
17140: ARRAY
17141: PPUSH
17142: LD_STRING D3-A-4
17144: PPUSH
17145: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
17149: LD_INT 1
17151: PPUSH
17152: CALL 10669 0 1
17156: PUSH
17157: LD_INT 1
17159: ARRAY
17160: PPUSH
17161: LD_STRING D3-B-4
17163: PPUSH
17164: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
17168: LD_EXP 40
17172: PUSH
17173: LD_INT 1
17175: ARRAY
17176: PPUSH
17177: LD_STRING D3-A-5
17179: PPUSH
17180: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
17184: LD_INT 1
17186: PPUSH
17187: CALL 10669 0 1
17191: PUSH
17192: LD_INT 1
17194: ARRAY
17195: PPUSH
17196: LD_STRING D3-B-5
17198: PPUSH
17199: CALL_OW 88
// for i = 1 to Gamma_Squad do
17203: LD_ADDR_VAR 0 1
17207: PUSH
17208: DOUBLE
17209: LD_INT 1
17211: DEC
17212: ST_TO_ADDR
17213: LD_EXP 40
17217: PUSH
17218: FOR_TO
17219: IFFALSE 17241
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
17221: LD_EXP 40
17225: PUSH
17226: LD_VAR 0 1
17230: ARRAY
17231: PPUSH
17232: LD_INT 1
17234: PPUSH
17235: CALL_OW 235
17239: GO 17218
17241: POP
17242: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
17243: LD_INT 6300
17245: PUSH
17246: LD_INT 10500
17248: PUSH
17249: LD_INT 11550
17251: PUSH
17252: EMPTY
17253: LIST
17254: LIST
17255: LIST
17256: PUSH
17257: LD_OWVAR 67
17261: ARRAY
17262: PPUSH
17263: CALL_OW 67
// AddZetaSquad ;
17267: CALL 13988 0 0
// Wait ( 0 0$10 ) ;
17271: LD_INT 350
17273: PPUSH
17274: CALL_OW 67
// to_veh := [ ] ;
17278: LD_ADDR_VAR 0 2
17282: PUSH
17283: EMPTY
17284: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
17285: LD_ADDR_VAR 0 1
17289: PUSH
17290: DOUBLE
17291: LD_INT 1
17293: DEC
17294: ST_TO_ADDR
17295: LD_EXP 41
17299: PUSH
17300: FOR_TO
17301: IFFALSE 17511
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
17303: LD_EXP 41
17307: PUSH
17308: LD_VAR 0 1
17312: ARRAY
17313: PPUSH
17314: CALL_OW 110
17318: PUSH
17319: LD_INT 3
17321: EQUAL
17322: IFFALSE 17348
// to_veh := to_veh ^ Zeta_Squad [ i ] else
17324: LD_ADDR_VAR 0 2
17328: PUSH
17329: LD_VAR 0 2
17333: PUSH
17334: LD_EXP 41
17338: PUSH
17339: LD_VAR 0 1
17343: ARRAY
17344: ADD
17345: ST_TO_ADDR
17346: GO 17473
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
17348: LD_EXP 41
17352: PUSH
17353: LD_VAR 0 1
17357: ARRAY
17358: PPUSH
17359: CALL_OW 110
17363: PUSH
17364: LD_INT 5
17366: EQUAL
17367: IFFALSE 17452
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
17369: LD_EXP 41
17373: PUSH
17374: LD_VAR 0 1
17378: ARRAY
17379: PPUSH
17380: LD_INT 4
17382: PPUSH
17383: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17387: LD_EXP 41
17391: PUSH
17392: LD_VAR 0 1
17396: ARRAY
17397: PPUSH
17398: LD_INT 5
17400: PPUSH
17401: LD_INT 0
17403: PPUSH
17404: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
17408: LD_VAR 0 2
17412: PUSH
17413: LD_INT 1
17415: ARRAY
17416: PPUSH
17417: LD_EXP 41
17421: PUSH
17422: LD_VAR 0 1
17426: ARRAY
17427: PPUSH
17428: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
17432: LD_ADDR_VAR 0 2
17436: PUSH
17437: LD_VAR 0 2
17441: PPUSH
17442: LD_INT 1
17444: PPUSH
17445: CALL_OW 3
17449: ST_TO_ADDR
// end else
17450: GO 17473
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17452: LD_EXP 41
17456: PUSH
17457: LD_VAR 0 1
17461: ARRAY
17462: PPUSH
17463: LD_INT 5
17465: PPUSH
17466: LD_INT 0
17468: PPUSH
17469: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
17473: LD_EXP 41
17477: PUSH
17478: LD_VAR 0 1
17482: ARRAY
17483: PPUSH
17484: LD_INT 165
17486: PPUSH
17487: LD_INT 105
17489: PPUSH
17490: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
17494: LD_INT 70
17496: PPUSH
17497: LD_INT 140
17499: PPUSH
17500: CALL_OW 12
17504: PPUSH
17505: CALL_OW 67
// end ;
17509: GO 17300
17511: POP
17512: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
17513: LD_EXP 41
17517: PUSH
17518: LD_INT 1
17520: ARRAY
17521: PPUSH
17522: LD_STRING D4-A-1
17524: PPUSH
17525: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
17529: LD_INT 1
17531: PPUSH
17532: CALL 10669 0 1
17536: PUSH
17537: LD_INT 1
17539: ARRAY
17540: PPUSH
17541: LD_STRING D4-B-1
17543: PPUSH
17544: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
17548: LD_EXP 41
17552: PUSH
17553: LD_INT 1
17555: ARRAY
17556: PPUSH
17557: LD_STRING D4-A-2
17559: PPUSH
17560: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
17564: LD_INT 1
17566: PPUSH
17567: CALL 10669 0 1
17571: PUSH
17572: LD_INT 1
17574: ARRAY
17575: PPUSH
17576: LD_STRING D4-B-2
17578: PPUSH
17579: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
17583: LD_EXP 41
17587: PUSH
17588: LD_INT 1
17590: ARRAY
17591: PPUSH
17592: LD_STRING D4-A-3
17594: PPUSH
17595: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
17599: LD_INT 1
17601: PPUSH
17602: CALL 10669 0 1
17606: PUSH
17607: LD_INT 1
17609: ARRAY
17610: PPUSH
17611: LD_STRING D4-B-3
17613: PPUSH
17614: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
17618: LD_EXP 41
17622: PUSH
17623: LD_INT 1
17625: ARRAY
17626: PPUSH
17627: LD_STRING D4-A-4
17629: PPUSH
17630: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17634: LD_INT 1
17636: PPUSH
17637: CALL 10669 0 1
17641: PUSH
17642: LD_INT 1
17644: ARRAY
17645: PPUSH
17646: LD_STRING D4-B-4
17648: PPUSH
17649: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17653: LD_EXP 41
17657: PUSH
17658: LD_INT 1
17660: ARRAY
17661: PPUSH
17662: LD_STRING D4-A-5
17664: PPUSH
17665: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17669: LD_INT 1
17671: PPUSH
17672: CALL 10669 0 1
17676: PUSH
17677: LD_INT 1
17679: ARRAY
17680: PPUSH
17681: LD_STRING D4-B-5
17683: PPUSH
17684: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17688: LD_EXP 41
17692: PUSH
17693: LD_INT 1
17695: ARRAY
17696: PPUSH
17697: LD_STRING D4-A-6
17699: PPUSH
17700: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17704: LD_INT 1
17706: PPUSH
17707: CALL 10669 0 1
17711: PUSH
17712: LD_INT 1
17714: ARRAY
17715: PPUSH
17716: LD_STRING D4-B-6
17718: PPUSH
17719: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17723: LD_EXP 41
17727: PUSH
17728: LD_INT 1
17730: ARRAY
17731: PPUSH
17732: LD_STRING D4-A-7
17734: PPUSH
17735: CALL_OW 94
// for i = 1 to Zeta_Squad do
17739: LD_ADDR_VAR 0 1
17743: PUSH
17744: DOUBLE
17745: LD_INT 1
17747: DEC
17748: ST_TO_ADDR
17749: LD_EXP 41
17753: PUSH
17754: FOR_TO
17755: IFFALSE 17777
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17757: LD_EXP 41
17761: PUSH
17762: LD_VAR 0 1
17766: ARRAY
17767: PPUSH
17768: LD_INT 1
17770: PPUSH
17771: CALL_OW 235
17775: GO 17754
17777: POP
17778: POP
// end ;
17779: PPOPN 2
17781: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17782: LD_INT 11
17784: PPUSH
17785: LD_INT 22
17787: PUSH
17788: LD_OWVAR 2
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: PPUSH
17797: CALL_OW 70
17801: PUSH
17802: LD_INT 0
17804: GREATER
17805: IFFALSE 17830
17807: GO 17809
17809: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17810: LD_EXP 37
17814: PPUSH
17815: LD_STRING D10-A-1
17817: PPUSH
17818: CALL_OW 88
// ru_spotted := true ;
17822: LD_ADDR_EXP 15
17826: PUSH
17827: LD_INT 1
17829: ST_TO_ADDR
// end ;
17830: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17831: LD_EXP 37
17835: PPUSH
17836: CALL_OW 301
17840: PUSH
17841: LD_EXP 38
17845: PPUSH
17846: CALL_OW 301
17850: OR
17851: IFFALSE 17863
17853: GO 17855
17855: DISABLE
// begin YouLost ( DieP ) ;
17856: LD_STRING DieP
17858: PPUSH
17859: CALL_OW 104
// end ;
17863: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17864: LD_INT 34
17866: PUSH
17867: LD_INT 8
17869: PUSH
17870: EMPTY
17871: LIST
17872: LIST
17873: PPUSH
17874: CALL_OW 69
17878: IFFALSE 17891
17880: GO 17882
17882: DISABLE
// sib_bomb_constructed := true ;
17883: LD_ADDR_EXP 35
17887: PUSH
17888: LD_INT 1
17890: ST_TO_ADDR
17891: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17892: LD_EXP 28
17896: PUSH
17897: LD_INT 22
17899: PUSH
17900: LD_INT 3
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PPUSH
17907: CALL_OW 69
17911: PUSH
17912: LD_INT 0
17914: EQUAL
17915: AND
17916: IFFALSE 18105
17918: GO 17920
17920: DISABLE
17921: LD_INT 0
17923: PPUSH
// begin game_status := false ;
17924: LD_ADDR_EXP 28
17928: PUSH
17929: LD_INT 0
17931: ST_TO_ADDR
// if Difficulty = 3 then
17932: LD_OWVAR 67
17936: PUSH
17937: LD_INT 3
17939: EQUAL
17940: IFFALSE 17949
// SetAchievement ( ACH_HARD ) ;
17942: LD_STRING ACH_HARD
17944: PPUSH
17945: CALL_OW 543
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17949: LD_OWVAR 1
17953: PUSH
17954: LD_INT 35
17956: DIVREAL
17957: PUSH
17958: LD_INT 60
17960: DIVREAL
17961: PUSH
17962: LD_INT 70
17964: PUSH
17965: LD_INT 60
17967: PUSH
17968: LD_INT 50
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: LIST
17975: PUSH
17976: LD_OWVAR 67
17980: ARRAY
17981: LESS
17982: IFFALSE 17996
// AddMedal ( play , 1 ) else
17984: LD_STRING play
17986: PPUSH
17987: LD_INT 1
17989: PPUSH
17990: CALL_OW 101
17994: GO 18007
// AddMedal ( play , - 1 ) ;
17996: LD_STRING play
17998: PPUSH
17999: LD_INT 1
18001: NEG
18002: PPUSH
18003: CALL_OW 101
// if sib_bomb_constructed then
18007: LD_EXP 35
18011: IFFALSE 18025
// AddMedal ( sibbomb , 1 ) else
18013: LD_STRING sibbomb
18015: PPUSH
18016: LD_INT 1
18018: PPUSH
18019: CALL_OW 101
18023: GO 18036
// AddMedal ( sibbomb , - 1 ) ;
18025: LD_STRING sibbomb
18027: PPUSH
18028: LD_INT 1
18030: NEG
18031: PPUSH
18032: CALL_OW 101
// if mine_constructed and not mine_ck then
18036: LD_EXP 36
18040: PUSH
18041: LD_EXP 34
18045: NOT
18046: AND
18047: IFFALSE 18059
// AddMedal ( mine , 1 ) ;
18049: LD_STRING mine
18051: PPUSH
18052: LD_INT 1
18054: PPUSH
18055: CALL_OW 101
// if mine_ck then
18059: LD_EXP 34
18063: IFFALSE 18076
// AddMedal ( mine , - 1 ) ;
18065: LD_STRING mine
18067: PPUSH
18068: LD_INT 1
18070: NEG
18071: PPUSH
18072: CALL_OW 101
// if not mine_constructed then
18076: LD_EXP 36
18080: NOT
18081: IFFALSE 18094
// AddMedal ( mine , - 2 ) ;
18083: LD_STRING mine
18085: PPUSH
18086: LD_INT 2
18088: NEG
18089: PPUSH
18090: CALL_OW 101
// GiveMedals ( Main ) ;
18094: LD_STRING Main
18096: PPUSH
18097: CALL_OW 102
// YouWin ;
18101: CALL_OW 103
// end ; end_of_file
18105: PPOPN 1
18107: END
// every 0 0$03 trigger game_status do var time ;
18108: LD_EXP 28
18112: IFFALSE 18277
18114: GO 18116
18116: DISABLE
18117: LD_INT 0
18119: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
18120: LD_ADDR_VAR 0 1
18124: PUSH
18125: LD_INT 1050
18127: PUSH
18128: LD_INT 1575
18130: PUSH
18131: LD_INT 2100
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: LD_OWVAR 67
18143: ARRAY
18144: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
18145: LD_VAR 0 1
18149: PUSH
18150: LD_INT 0
18152: PPUSH
18153: LD_INT 420
18155: PPUSH
18156: CALL_OW 12
18160: PLUS
18161: PPUSH
18162: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
18166: LD_INT 1
18168: PPUSH
18169: LD_INT 5
18171: PPUSH
18172: CALL_OW 12
18176: PPUSH
18177: LD_INT 1
18179: PPUSH
18180: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
18184: LD_INT 105
18186: PPUSH
18187: LD_INT 1050
18189: PPUSH
18190: CALL_OW 12
18194: PPUSH
18195: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
18199: LD_INT 1
18201: PPUSH
18202: LD_INT 5
18204: PPUSH
18205: CALL_OW 12
18209: PPUSH
18210: LD_INT 148
18212: PPUSH
18213: LD_INT 107
18215: PPUSH
18216: LD_INT 20
18218: PPUSH
18219: LD_INT 1
18221: PPUSH
18222: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
18226: LD_OWVAR 1
18230: PUSH
18231: LD_INT 44100
18233: PUSH
18234: LD_INT 37800
18236: PUSH
18237: LD_INT 33600
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: LIST
18244: PUSH
18245: LD_OWVAR 67
18249: ARRAY
18250: MOD
18251: IFFALSE 18267
// time := time + 0 0$20 ;
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: LD_VAR 0 1
18262: PUSH
18263: LD_INT 700
18265: PLUS
18266: ST_TO_ADDR
// end until game_status = false ;
18267: LD_EXP 28
18271: PUSH
18272: LD_INT 0
18274: EQUAL
18275: IFFALSE 18145
// end ;
18277: PPOPN 1
18279: END
// every 0 0$03 trigger game_status do var time ;
18280: LD_EXP 28
18284: IFFALSE 18438
18286: GO 18288
18288: DISABLE
18289: LD_INT 0
18291: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
18292: LD_ADDR_VAR 0 1
18296: PUSH
18297: LD_INT 700
18299: PUSH
18300: LD_INT 875
18302: PUSH
18303: LD_INT 1400
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: LIST
18310: PUSH
18311: LD_OWVAR 67
18315: ARRAY
18316: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18317: LD_VAR 0 1
18321: PUSH
18322: LD_INT 0
18324: PPUSH
18325: LD_INT 385
18327: PPUSH
18328: CALL_OW 12
18332: PLUS
18333: PPUSH
18334: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
18338: LD_INT 1
18340: PPUSH
18341: LD_INT 5
18343: PPUSH
18344: CALL_OW 12
18348: PPUSH
18349: LD_INT 102
18351: PPUSH
18352: LD_INT 6
18354: PPUSH
18355: LD_INT 25
18357: PPUSH
18358: LD_INT 1
18360: PPUSH
18361: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
18365: LD_OWVAR 1
18369: PUSH
18370: LD_INT 52500
18372: PUSH
18373: LD_INT 46200
18375: PUSH
18376: LD_INT 42000
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: LIST
18383: PUSH
18384: LD_OWVAR 67
18388: ARRAY
18389: MOD
18390: IFFALSE 18406
// time := time + 0 0$25 ;
18392: LD_ADDR_VAR 0 1
18396: PUSH
18397: LD_VAR 0 1
18401: PUSH
18402: LD_INT 875
18404: PLUS
18405: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
18406: LD_OWVAR 1
18410: PUSH
18411: LD_INT 231000
18413: MOD
18414: PUSH
18415: LD_INT 0
18417: EQUAL
18418: IFFALSE 18428
// time := 0 0$30 ;
18420: LD_ADDR_VAR 0 1
18424: PUSH
18425: LD_INT 1050
18427: ST_TO_ADDR
// end until game_status = false ;
18428: LD_EXP 28
18432: PUSH
18433: LD_INT 0
18435: EQUAL
18436: IFFALSE 18317
// end ;
18438: PPOPN 1
18440: END
// every 0 0$03 trigger game_status do var time ;
18441: LD_EXP 28
18445: IFFALSE 18581
18447: GO 18449
18449: DISABLE
18450: LD_INT 0
18452: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
18453: LD_ADDR_VAR 0 1
18457: PUSH
18458: LD_INT 1050
18460: PUSH
18461: LD_INT 1575
18463: PUSH
18464: LD_INT 1750
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: LIST
18471: PUSH
18472: LD_OWVAR 67
18476: ARRAY
18477: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18478: LD_VAR 0 1
18482: PUSH
18483: LD_INT 0
18485: PPUSH
18486: LD_INT 385
18488: PPUSH
18489: CALL_OW 12
18493: PLUS
18494: PPUSH
18495: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
18499: LD_INT 1
18501: PPUSH
18502: LD_INT 5
18504: PPUSH
18505: CALL_OW 12
18509: PPUSH
18510: LD_INT 51
18512: PPUSH
18513: LD_INT 74
18515: PPUSH
18516: LD_INT 25
18518: PPUSH
18519: LD_INT 1
18521: PPUSH
18522: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
18526: LD_OWVAR 1
18530: PUSH
18531: LD_INT 84000
18533: PUSH
18534: LD_INT 105000
18536: PUSH
18537: LD_INT 136500
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: LIST
18544: PUSH
18545: LD_OWVAR 67
18549: ARRAY
18550: MOD
18551: PUSH
18552: LD_INT 0
18554: EQUAL
18555: IFFALSE 18571
// time := time + 0 0$15 ;
18557: LD_ADDR_VAR 0 1
18561: PUSH
18562: LD_VAR 0 1
18566: PUSH
18567: LD_INT 525
18569: PLUS
18570: ST_TO_ADDR
// end until game_status = false ;
18571: LD_EXP 28
18575: PUSH
18576: LD_INT 0
18578: EQUAL
18579: IFFALSE 18478
// end ; end_of_file
18581: PPOPN 1
18583: END
// every 0 0$01 trigger not debug do
18584: LD_EXP 1
18588: NOT
18589: IFFALSE 18612
18591: GO 18593
18593: DISABLE
// begin enable ;
18594: ENABLE
// Display_Strings := [ #tick , tick ] ;
18595: LD_ADDR_OWVAR 47
18599: PUSH
18600: LD_STRING #tick
18602: PUSH
18603: LD_OWVAR 1
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: ST_TO_ADDR
// end ; end_of_file
18612: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
18613: LD_VAR 0 1
18617: PPUSH
18618: LD_VAR 0 2
18622: PPUSH
18623: LD_VAR 0 3
18627: PPUSH
18628: CALL 23449 0 3
// end ;
18632: PPOPN 3
18634: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18635: LD_VAR 0 1
18639: PPUSH
18640: CALL 23547 0 1
// end ; end_of_file
18644: PPOPN 1
18646: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18647: GO 18649
18649: DISABLE
// begin ru_radar := 98 ;
18650: LD_ADDR_EXP 42
18654: PUSH
18655: LD_INT 98
18657: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18658: LD_ADDR_EXP 43
18662: PUSH
18663: LD_INT 89
18665: ST_TO_ADDR
// us_hack := 99 ;
18666: LD_ADDR_EXP 44
18670: PUSH
18671: LD_INT 99
18673: ST_TO_ADDR
// us_artillery := 97 ;
18674: LD_ADDR_EXP 45
18678: PUSH
18679: LD_INT 97
18681: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18682: LD_ADDR_EXP 46
18686: PUSH
18687: LD_INT 91
18689: ST_TO_ADDR
// end ; end_of_file end_of_file
18690: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
18691: GO 18693
18693: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18694: LD_STRING initStreamRollete();
18696: PPUSH
18697: CALL_OW 559
// InitStreamMode ;
18701: CALL 18706 0 0
// end ;
18705: END
// function InitStreamMode ; begin
18706: LD_INT 0
18708: PPUSH
// streamModeActive := false ;
18709: LD_ADDR_EXP 47
18713: PUSH
18714: LD_INT 0
18716: ST_TO_ADDR
// sRocket := false ;
18717: LD_ADDR_EXP 50
18721: PUSH
18722: LD_INT 0
18724: ST_TO_ADDR
// sSpeed := false ;
18725: LD_ADDR_EXP 49
18729: PUSH
18730: LD_INT 0
18732: ST_TO_ADDR
// sEngine := false ;
18733: LD_ADDR_EXP 51
18737: PUSH
18738: LD_INT 0
18740: ST_TO_ADDR
// sSpec := false ;
18741: LD_ADDR_EXP 48
18745: PUSH
18746: LD_INT 0
18748: ST_TO_ADDR
// sLevel := false ;
18749: LD_ADDR_EXP 52
18753: PUSH
18754: LD_INT 0
18756: ST_TO_ADDR
// sArmoury := false ;
18757: LD_ADDR_EXP 53
18761: PUSH
18762: LD_INT 0
18764: ST_TO_ADDR
// sRadar := false ;
18765: LD_ADDR_EXP 54
18769: PUSH
18770: LD_INT 0
18772: ST_TO_ADDR
// sBunker := false ;
18773: LD_ADDR_EXP 55
18777: PUSH
18778: LD_INT 0
18780: ST_TO_ADDR
// sHack := false ;
18781: LD_ADDR_EXP 56
18785: PUSH
18786: LD_INT 0
18788: ST_TO_ADDR
// sFire := false ;
18789: LD_ADDR_EXP 57
18793: PUSH
18794: LD_INT 0
18796: ST_TO_ADDR
// sRefresh := false ;
18797: LD_ADDR_EXP 58
18801: PUSH
18802: LD_INT 0
18804: ST_TO_ADDR
// sExp := false ;
18805: LD_ADDR_EXP 59
18809: PUSH
18810: LD_INT 0
18812: ST_TO_ADDR
// sDepot := false ;
18813: LD_ADDR_EXP 60
18817: PUSH
18818: LD_INT 0
18820: ST_TO_ADDR
// sFlag := false ;
18821: LD_ADDR_EXP 61
18825: PUSH
18826: LD_INT 0
18828: ST_TO_ADDR
// sKamikadze := false ;
18829: LD_ADDR_EXP 69
18833: PUSH
18834: LD_INT 0
18836: ST_TO_ADDR
// sTroll := false ;
18837: LD_ADDR_EXP 70
18841: PUSH
18842: LD_INT 0
18844: ST_TO_ADDR
// sSlow := false ;
18845: LD_ADDR_EXP 71
18849: PUSH
18850: LD_INT 0
18852: ST_TO_ADDR
// sLack := false ;
18853: LD_ADDR_EXP 72
18857: PUSH
18858: LD_INT 0
18860: ST_TO_ADDR
// sTank := false ;
18861: LD_ADDR_EXP 74
18865: PUSH
18866: LD_INT 0
18868: ST_TO_ADDR
// sRemote := false ;
18869: LD_ADDR_EXP 75
18873: PUSH
18874: LD_INT 0
18876: ST_TO_ADDR
// sPowell := false ;
18877: LD_ADDR_EXP 76
18881: PUSH
18882: LD_INT 0
18884: ST_TO_ADDR
// sTeleport := false ;
18885: LD_ADDR_EXP 79
18889: PUSH
18890: LD_INT 0
18892: ST_TO_ADDR
// sOilTower := false ;
18893: LD_ADDR_EXP 81
18897: PUSH
18898: LD_INT 0
18900: ST_TO_ADDR
// sShovel := false ;
18901: LD_ADDR_EXP 82
18905: PUSH
18906: LD_INT 0
18908: ST_TO_ADDR
// sSheik := false ;
18909: LD_ADDR_EXP 83
18913: PUSH
18914: LD_INT 0
18916: ST_TO_ADDR
// sSold := false ;
18917: LD_ADDR_EXP 62
18921: PUSH
18922: LD_INT 0
18924: ST_TO_ADDR
// sDiff := false ;
18925: LD_ADDR_EXP 63
18929: PUSH
18930: LD_INT 0
18932: ST_TO_ADDR
// sFog := false ;
18933: LD_ADDR_EXP 66
18937: PUSH
18938: LD_INT 0
18940: ST_TO_ADDR
// sReset := false ;
18941: LD_ADDR_EXP 67
18945: PUSH
18946: LD_INT 0
18948: ST_TO_ADDR
// sSun := false ;
18949: LD_ADDR_EXP 68
18953: PUSH
18954: LD_INT 0
18956: ST_TO_ADDR
// sTiger := false ;
18957: LD_ADDR_EXP 64
18961: PUSH
18962: LD_INT 0
18964: ST_TO_ADDR
// sBomb := false ;
18965: LD_ADDR_EXP 65
18969: PUSH
18970: LD_INT 0
18972: ST_TO_ADDR
// sWound := false ;
18973: LD_ADDR_EXP 73
18977: PUSH
18978: LD_INT 0
18980: ST_TO_ADDR
// sBetray := false ;
18981: LD_ADDR_EXP 77
18985: PUSH
18986: LD_INT 0
18988: ST_TO_ADDR
// sContamin := false ;
18989: LD_ADDR_EXP 78
18993: PUSH
18994: LD_INT 0
18996: ST_TO_ADDR
// sOil := false ;
18997: LD_ADDR_EXP 80
19001: PUSH
19002: LD_INT 0
19004: ST_TO_ADDR
// sStu := false ;
19005: LD_ADDR_EXP 84
19009: PUSH
19010: LD_INT 0
19012: ST_TO_ADDR
// end ;
19013: LD_VAR 0 1
19017: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19018: LD_VAR 0 2
19022: PUSH
19023: LD_INT 100
19025: EQUAL
19026: IFFALSE 19723
// begin if not StreamModeActive then
19028: LD_EXP 47
19032: NOT
19033: IFFALSE 19043
// StreamModeActive := true ;
19035: LD_ADDR_EXP 47
19039: PUSH
19040: LD_INT 1
19042: ST_TO_ADDR
// if p3 = 0 then
19043: LD_VAR 0 3
19047: PUSH
19048: LD_INT 0
19050: EQUAL
19051: IFFALSE 19057
// InitStreamMode ;
19053: CALL 18706 0 0
// if p3 = 1 then
19057: LD_VAR 0 3
19061: PUSH
19062: LD_INT 1
19064: EQUAL
19065: IFFALSE 19075
// sRocket := true ;
19067: LD_ADDR_EXP 50
19071: PUSH
19072: LD_INT 1
19074: ST_TO_ADDR
// if p3 = 2 then
19075: LD_VAR 0 3
19079: PUSH
19080: LD_INT 2
19082: EQUAL
19083: IFFALSE 19093
// sSpeed := true ;
19085: LD_ADDR_EXP 49
19089: PUSH
19090: LD_INT 1
19092: ST_TO_ADDR
// if p3 = 3 then
19093: LD_VAR 0 3
19097: PUSH
19098: LD_INT 3
19100: EQUAL
19101: IFFALSE 19111
// sEngine := true ;
19103: LD_ADDR_EXP 51
19107: PUSH
19108: LD_INT 1
19110: ST_TO_ADDR
// if p3 = 4 then
19111: LD_VAR 0 3
19115: PUSH
19116: LD_INT 4
19118: EQUAL
19119: IFFALSE 19129
// sSpec := true ;
19121: LD_ADDR_EXP 48
19125: PUSH
19126: LD_INT 1
19128: ST_TO_ADDR
// if p3 = 5 then
19129: LD_VAR 0 3
19133: PUSH
19134: LD_INT 5
19136: EQUAL
19137: IFFALSE 19147
// sLevel := true ;
19139: LD_ADDR_EXP 52
19143: PUSH
19144: LD_INT 1
19146: ST_TO_ADDR
// if p3 = 6 then
19147: LD_VAR 0 3
19151: PUSH
19152: LD_INT 6
19154: EQUAL
19155: IFFALSE 19165
// sArmoury := true ;
19157: LD_ADDR_EXP 53
19161: PUSH
19162: LD_INT 1
19164: ST_TO_ADDR
// if p3 = 7 then
19165: LD_VAR 0 3
19169: PUSH
19170: LD_INT 7
19172: EQUAL
19173: IFFALSE 19183
// sRadar := true ;
19175: LD_ADDR_EXP 54
19179: PUSH
19180: LD_INT 1
19182: ST_TO_ADDR
// if p3 = 8 then
19183: LD_VAR 0 3
19187: PUSH
19188: LD_INT 8
19190: EQUAL
19191: IFFALSE 19201
// sBunker := true ;
19193: LD_ADDR_EXP 55
19197: PUSH
19198: LD_INT 1
19200: ST_TO_ADDR
// if p3 = 9 then
19201: LD_VAR 0 3
19205: PUSH
19206: LD_INT 9
19208: EQUAL
19209: IFFALSE 19219
// sHack := true ;
19211: LD_ADDR_EXP 56
19215: PUSH
19216: LD_INT 1
19218: ST_TO_ADDR
// if p3 = 10 then
19219: LD_VAR 0 3
19223: PUSH
19224: LD_INT 10
19226: EQUAL
19227: IFFALSE 19237
// sFire := true ;
19229: LD_ADDR_EXP 57
19233: PUSH
19234: LD_INT 1
19236: ST_TO_ADDR
// if p3 = 11 then
19237: LD_VAR 0 3
19241: PUSH
19242: LD_INT 11
19244: EQUAL
19245: IFFALSE 19255
// sRefresh := true ;
19247: LD_ADDR_EXP 58
19251: PUSH
19252: LD_INT 1
19254: ST_TO_ADDR
// if p3 = 12 then
19255: LD_VAR 0 3
19259: PUSH
19260: LD_INT 12
19262: EQUAL
19263: IFFALSE 19273
// sExp := true ;
19265: LD_ADDR_EXP 59
19269: PUSH
19270: LD_INT 1
19272: ST_TO_ADDR
// if p3 = 13 then
19273: LD_VAR 0 3
19277: PUSH
19278: LD_INT 13
19280: EQUAL
19281: IFFALSE 19291
// sDepot := true ;
19283: LD_ADDR_EXP 60
19287: PUSH
19288: LD_INT 1
19290: ST_TO_ADDR
// if p3 = 14 then
19291: LD_VAR 0 3
19295: PUSH
19296: LD_INT 14
19298: EQUAL
19299: IFFALSE 19309
// sFlag := true ;
19301: LD_ADDR_EXP 61
19305: PUSH
19306: LD_INT 1
19308: ST_TO_ADDR
// if p3 = 15 then
19309: LD_VAR 0 3
19313: PUSH
19314: LD_INT 15
19316: EQUAL
19317: IFFALSE 19327
// sKamikadze := true ;
19319: LD_ADDR_EXP 69
19323: PUSH
19324: LD_INT 1
19326: ST_TO_ADDR
// if p3 = 16 then
19327: LD_VAR 0 3
19331: PUSH
19332: LD_INT 16
19334: EQUAL
19335: IFFALSE 19345
// sTroll := true ;
19337: LD_ADDR_EXP 70
19341: PUSH
19342: LD_INT 1
19344: ST_TO_ADDR
// if p3 = 17 then
19345: LD_VAR 0 3
19349: PUSH
19350: LD_INT 17
19352: EQUAL
19353: IFFALSE 19363
// sSlow := true ;
19355: LD_ADDR_EXP 71
19359: PUSH
19360: LD_INT 1
19362: ST_TO_ADDR
// if p3 = 18 then
19363: LD_VAR 0 3
19367: PUSH
19368: LD_INT 18
19370: EQUAL
19371: IFFALSE 19381
// sLack := true ;
19373: LD_ADDR_EXP 72
19377: PUSH
19378: LD_INT 1
19380: ST_TO_ADDR
// if p3 = 19 then
19381: LD_VAR 0 3
19385: PUSH
19386: LD_INT 19
19388: EQUAL
19389: IFFALSE 19399
// sTank := true ;
19391: LD_ADDR_EXP 74
19395: PUSH
19396: LD_INT 1
19398: ST_TO_ADDR
// if p3 = 20 then
19399: LD_VAR 0 3
19403: PUSH
19404: LD_INT 20
19406: EQUAL
19407: IFFALSE 19417
// sRemote := true ;
19409: LD_ADDR_EXP 75
19413: PUSH
19414: LD_INT 1
19416: ST_TO_ADDR
// if p3 = 21 then
19417: LD_VAR 0 3
19421: PUSH
19422: LD_INT 21
19424: EQUAL
19425: IFFALSE 19435
// sPowell := true ;
19427: LD_ADDR_EXP 76
19431: PUSH
19432: LD_INT 1
19434: ST_TO_ADDR
// if p3 = 22 then
19435: LD_VAR 0 3
19439: PUSH
19440: LD_INT 22
19442: EQUAL
19443: IFFALSE 19453
// sTeleport := true ;
19445: LD_ADDR_EXP 79
19449: PUSH
19450: LD_INT 1
19452: ST_TO_ADDR
// if p3 = 23 then
19453: LD_VAR 0 3
19457: PUSH
19458: LD_INT 23
19460: EQUAL
19461: IFFALSE 19471
// sOilTower := true ;
19463: LD_ADDR_EXP 81
19467: PUSH
19468: LD_INT 1
19470: ST_TO_ADDR
// if p3 = 24 then
19471: LD_VAR 0 3
19475: PUSH
19476: LD_INT 24
19478: EQUAL
19479: IFFALSE 19489
// sShovel := true ;
19481: LD_ADDR_EXP 82
19485: PUSH
19486: LD_INT 1
19488: ST_TO_ADDR
// if p3 = 25 then
19489: LD_VAR 0 3
19493: PUSH
19494: LD_INT 25
19496: EQUAL
19497: IFFALSE 19507
// sSheik := true ;
19499: LD_ADDR_EXP 83
19503: PUSH
19504: LD_INT 1
19506: ST_TO_ADDR
// if p3 = 101 then
19507: LD_VAR 0 3
19511: PUSH
19512: LD_INT 101
19514: EQUAL
19515: IFFALSE 19525
// sSold := true ;
19517: LD_ADDR_EXP 62
19521: PUSH
19522: LD_INT 1
19524: ST_TO_ADDR
// if p3 = 102 then
19525: LD_VAR 0 3
19529: PUSH
19530: LD_INT 102
19532: EQUAL
19533: IFFALSE 19543
// sDiff := true ;
19535: LD_ADDR_EXP 63
19539: PUSH
19540: LD_INT 1
19542: ST_TO_ADDR
// if p3 = 103 then
19543: LD_VAR 0 3
19547: PUSH
19548: LD_INT 103
19550: EQUAL
19551: IFFALSE 19561
// sFog := true ;
19553: LD_ADDR_EXP 66
19557: PUSH
19558: LD_INT 1
19560: ST_TO_ADDR
// if p3 = 104 then
19561: LD_VAR 0 3
19565: PUSH
19566: LD_INT 104
19568: EQUAL
19569: IFFALSE 19579
// sReset := true ;
19571: LD_ADDR_EXP 67
19575: PUSH
19576: LD_INT 1
19578: ST_TO_ADDR
// if p3 = 105 then
19579: LD_VAR 0 3
19583: PUSH
19584: LD_INT 105
19586: EQUAL
19587: IFFALSE 19597
// sSun := true ;
19589: LD_ADDR_EXP 68
19593: PUSH
19594: LD_INT 1
19596: ST_TO_ADDR
// if p3 = 106 then
19597: LD_VAR 0 3
19601: PUSH
19602: LD_INT 106
19604: EQUAL
19605: IFFALSE 19615
// sTiger := true ;
19607: LD_ADDR_EXP 64
19611: PUSH
19612: LD_INT 1
19614: ST_TO_ADDR
// if p3 = 107 then
19615: LD_VAR 0 3
19619: PUSH
19620: LD_INT 107
19622: EQUAL
19623: IFFALSE 19633
// sBomb := true ;
19625: LD_ADDR_EXP 65
19629: PUSH
19630: LD_INT 1
19632: ST_TO_ADDR
// if p3 = 108 then
19633: LD_VAR 0 3
19637: PUSH
19638: LD_INT 108
19640: EQUAL
19641: IFFALSE 19651
// sWound := true ;
19643: LD_ADDR_EXP 73
19647: PUSH
19648: LD_INT 1
19650: ST_TO_ADDR
// if p3 = 109 then
19651: LD_VAR 0 3
19655: PUSH
19656: LD_INT 109
19658: EQUAL
19659: IFFALSE 19669
// sBetray := true ;
19661: LD_ADDR_EXP 77
19665: PUSH
19666: LD_INT 1
19668: ST_TO_ADDR
// if p3 = 110 then
19669: LD_VAR 0 3
19673: PUSH
19674: LD_INT 110
19676: EQUAL
19677: IFFALSE 19687
// sContamin := true ;
19679: LD_ADDR_EXP 78
19683: PUSH
19684: LD_INT 1
19686: ST_TO_ADDR
// if p3 = 111 then
19687: LD_VAR 0 3
19691: PUSH
19692: LD_INT 111
19694: EQUAL
19695: IFFALSE 19705
// sOil := true ;
19697: LD_ADDR_EXP 80
19701: PUSH
19702: LD_INT 1
19704: ST_TO_ADDR
// if p3 = 112 then
19705: LD_VAR 0 3
19709: PUSH
19710: LD_INT 112
19712: EQUAL
19713: IFFALSE 19723
// sStu := true ;
19715: LD_ADDR_EXP 84
19719: PUSH
19720: LD_INT 1
19722: ST_TO_ADDR
// end ; end ;
19723: PPOPN 6
19725: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
19726: LD_EXP 47
19730: PUSH
19731: LD_EXP 50
19735: AND
19736: IFFALSE 19860
19738: GO 19740
19740: DISABLE
19741: LD_INT 0
19743: PPUSH
19744: PPUSH
// begin enable ;
19745: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
19746: LD_ADDR_VAR 0 2
19750: PUSH
19751: LD_INT 22
19753: PUSH
19754: LD_OWVAR 2
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 2
19765: PUSH
19766: LD_INT 34
19768: PUSH
19769: LD_INT 7
19771: PUSH
19772: EMPTY
19773: LIST
19774: LIST
19775: PUSH
19776: LD_INT 34
19778: PUSH
19779: LD_INT 45
19781: PUSH
19782: EMPTY
19783: LIST
19784: LIST
19785: PUSH
19786: LD_INT 34
19788: PUSH
19789: LD_INT 28
19791: PUSH
19792: EMPTY
19793: LIST
19794: LIST
19795: PUSH
19796: LD_INT 34
19798: PUSH
19799: LD_INT 47
19801: PUSH
19802: EMPTY
19803: LIST
19804: LIST
19805: PUSH
19806: EMPTY
19807: LIST
19808: LIST
19809: LIST
19810: LIST
19811: LIST
19812: PUSH
19813: EMPTY
19814: LIST
19815: LIST
19816: PPUSH
19817: CALL_OW 69
19821: ST_TO_ADDR
// if not tmp then
19822: LD_VAR 0 2
19826: NOT
19827: IFFALSE 19831
// exit ;
19829: GO 19860
// for i in tmp do
19831: LD_ADDR_VAR 0 1
19835: PUSH
19836: LD_VAR 0 2
19840: PUSH
19841: FOR_IN
19842: IFFALSE 19858
// begin SetLives ( i , 0 ) ;
19844: LD_VAR 0 1
19848: PPUSH
19849: LD_INT 0
19851: PPUSH
19852: CALL_OW 234
// end ;
19856: GO 19841
19858: POP
19859: POP
// end ;
19860: PPOPN 2
19862: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
19863: LD_EXP 47
19867: PUSH
19868: LD_EXP 51
19872: AND
19873: IFFALSE 19954
19875: GO 19877
19877: DISABLE
19878: LD_INT 0
19880: PPUSH
19881: PPUSH
// begin enable ;
19882: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
19883: LD_ADDR_VAR 0 2
19887: PUSH
19888: LD_INT 22
19890: PUSH
19891: LD_OWVAR 2
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: PUSH
19900: LD_INT 32
19902: PUSH
19903: LD_INT 3
19905: PUSH
19906: EMPTY
19907: LIST
19908: LIST
19909: PUSH
19910: EMPTY
19911: LIST
19912: LIST
19913: PPUSH
19914: CALL_OW 69
19918: ST_TO_ADDR
// if not tmp then
19919: LD_VAR 0 2
19923: NOT
19924: IFFALSE 19928
// exit ;
19926: GO 19954
// for i in tmp do
19928: LD_ADDR_VAR 0 1
19932: PUSH
19933: LD_VAR 0 2
19937: PUSH
19938: FOR_IN
19939: IFFALSE 19952
// begin DestroyUnit ( i ) ;
19941: LD_VAR 0 1
19945: PPUSH
19946: CALL_OW 65
// end ;
19950: GO 19938
19952: POP
19953: POP
// end ;
19954: PPOPN 2
19956: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
19957: LD_EXP 47
19961: PUSH
19962: LD_EXP 48
19966: AND
19967: IFFALSE 20060
19969: GO 19971
19971: DISABLE
19972: LD_INT 0
19974: PPUSH
// begin enable ;
19975: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
19976: LD_ADDR_VAR 0 1
19980: PUSH
19981: LD_INT 22
19983: PUSH
19984: LD_OWVAR 2
19988: PUSH
19989: EMPTY
19990: LIST
19991: LIST
19992: PUSH
19993: LD_INT 2
19995: PUSH
19996: LD_INT 25
19998: PUSH
19999: LD_INT 5
20001: PUSH
20002: EMPTY
20003: LIST
20004: LIST
20005: PUSH
20006: LD_INT 25
20008: PUSH
20009: LD_INT 9
20011: PUSH
20012: EMPTY
20013: LIST
20014: LIST
20015: PUSH
20016: LD_INT 25
20018: PUSH
20019: LD_INT 8
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: PUSH
20026: EMPTY
20027: LIST
20028: LIST
20029: LIST
20030: LIST
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PPUSH
20036: CALL_OW 69
20040: PUSH
20041: FOR_IN
20042: IFFALSE 20058
// begin SetClass ( i , 1 ) ;
20044: LD_VAR 0 1
20048: PPUSH
20049: LD_INT 1
20051: PPUSH
20052: CALL_OW 336
// end ;
20056: GO 20041
20058: POP
20059: POP
// end ;
20060: PPOPN 1
20062: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
20063: LD_EXP 47
20067: PUSH
20068: LD_EXP 49
20072: AND
20073: PUSH
20074: LD_OWVAR 65
20078: PUSH
20079: LD_INT 7
20081: LESS
20082: AND
20083: IFFALSE 20097
20085: GO 20087
20087: DISABLE
// begin enable ;
20088: ENABLE
// game_speed := 7 ;
20089: LD_ADDR_OWVAR 65
20093: PUSH
20094: LD_INT 7
20096: ST_TO_ADDR
// end ;
20097: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
20098: LD_EXP 47
20102: PUSH
20103: LD_EXP 52
20107: AND
20108: IFFALSE 20310
20110: GO 20112
20112: DISABLE
20113: LD_INT 0
20115: PPUSH
20116: PPUSH
20117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
20118: LD_ADDR_VAR 0 3
20122: PUSH
20123: LD_INT 81
20125: PUSH
20126: LD_OWVAR 2
20130: PUSH
20131: EMPTY
20132: LIST
20133: LIST
20134: PUSH
20135: LD_INT 21
20137: PUSH
20138: LD_INT 1
20140: PUSH
20141: EMPTY
20142: LIST
20143: LIST
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: PPUSH
20149: CALL_OW 69
20153: ST_TO_ADDR
// if not tmp then
20154: LD_VAR 0 3
20158: NOT
20159: IFFALSE 20163
// exit ;
20161: GO 20310
// if tmp > 5 then
20163: LD_VAR 0 3
20167: PUSH
20168: LD_INT 5
20170: GREATER
20171: IFFALSE 20183
// k := 5 else
20173: LD_ADDR_VAR 0 2
20177: PUSH
20178: LD_INT 5
20180: ST_TO_ADDR
20181: GO 20193
// k := tmp ;
20183: LD_ADDR_VAR 0 2
20187: PUSH
20188: LD_VAR 0 3
20192: ST_TO_ADDR
// for i := 1 to k do
20193: LD_ADDR_VAR 0 1
20197: PUSH
20198: DOUBLE
20199: LD_INT 1
20201: DEC
20202: ST_TO_ADDR
20203: LD_VAR 0 2
20207: PUSH
20208: FOR_TO
20209: IFFALSE 20308
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
20211: LD_VAR 0 3
20215: PUSH
20216: LD_VAR 0 1
20220: ARRAY
20221: PPUSH
20222: LD_VAR 0 1
20226: PUSH
20227: LD_INT 4
20229: MOD
20230: PUSH
20231: LD_INT 1
20233: PLUS
20234: PPUSH
20235: CALL_OW 259
20239: PUSH
20240: LD_INT 10
20242: LESS
20243: IFFALSE 20306
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
20245: LD_VAR 0 3
20249: PUSH
20250: LD_VAR 0 1
20254: ARRAY
20255: PPUSH
20256: LD_VAR 0 1
20260: PUSH
20261: LD_INT 4
20263: MOD
20264: PUSH
20265: LD_INT 1
20267: PLUS
20268: PPUSH
20269: LD_VAR 0 3
20273: PUSH
20274: LD_VAR 0 1
20278: ARRAY
20279: PPUSH
20280: LD_VAR 0 1
20284: PUSH
20285: LD_INT 4
20287: MOD
20288: PUSH
20289: LD_INT 1
20291: PLUS
20292: PPUSH
20293: CALL_OW 259
20297: PUSH
20298: LD_INT 1
20300: PLUS
20301: PPUSH
20302: CALL_OW 237
20306: GO 20208
20308: POP
20309: POP
// end ;
20310: PPOPN 3
20312: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
20313: LD_EXP 47
20317: PUSH
20318: LD_EXP 53
20322: AND
20323: IFFALSE 20343
20325: GO 20327
20327: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
20328: LD_INT 4
20330: PPUSH
20331: LD_OWVAR 2
20335: PPUSH
20336: LD_INT 0
20338: PPUSH
20339: CALL_OW 324
20343: END
// every 0 0$1 trigger StreamModeActive and sShovel do
20344: LD_EXP 47
20348: PUSH
20349: LD_EXP 82
20353: AND
20354: IFFALSE 20374
20356: GO 20358
20358: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
20359: LD_INT 19
20361: PPUSH
20362: LD_OWVAR 2
20366: PPUSH
20367: LD_INT 0
20369: PPUSH
20370: CALL_OW 324
20374: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
20375: LD_EXP 47
20379: PUSH
20380: LD_EXP 54
20384: AND
20385: IFFALSE 20484
20387: GO 20389
20389: DISABLE
20390: LD_INT 0
20392: PPUSH
20393: PPUSH
// begin enable ;
20394: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
20395: LD_ADDR_VAR 0 2
20399: PUSH
20400: LD_INT 22
20402: PUSH
20403: LD_OWVAR 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: LD_INT 2
20414: PUSH
20415: LD_INT 34
20417: PUSH
20418: LD_INT 11
20420: PUSH
20421: EMPTY
20422: LIST
20423: LIST
20424: PUSH
20425: LD_INT 34
20427: PUSH
20428: LD_INT 30
20430: PUSH
20431: EMPTY
20432: LIST
20433: LIST
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: LIST
20439: PUSH
20440: EMPTY
20441: LIST
20442: LIST
20443: PPUSH
20444: CALL_OW 69
20448: ST_TO_ADDR
// if not tmp then
20449: LD_VAR 0 2
20453: NOT
20454: IFFALSE 20458
// exit ;
20456: GO 20484
// for i in tmp do
20458: LD_ADDR_VAR 0 1
20462: PUSH
20463: LD_VAR 0 2
20467: PUSH
20468: FOR_IN
20469: IFFALSE 20482
// begin DestroyUnit ( i ) ;
20471: LD_VAR 0 1
20475: PPUSH
20476: CALL_OW 65
// end ;
20480: GO 20468
20482: POP
20483: POP
// end ;
20484: PPOPN 2
20486: END
// every 0 0$1 trigger StreamModeActive and sBunker do
20487: LD_EXP 47
20491: PUSH
20492: LD_EXP 55
20496: AND
20497: IFFALSE 20517
20499: GO 20501
20501: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
20502: LD_INT 32
20504: PPUSH
20505: LD_OWVAR 2
20509: PPUSH
20510: LD_INT 0
20512: PPUSH
20513: CALL_OW 324
20517: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
20518: LD_EXP 47
20522: PUSH
20523: LD_EXP 56
20527: AND
20528: IFFALSE 20709
20530: GO 20532
20532: DISABLE
20533: LD_INT 0
20535: PPUSH
20536: PPUSH
20537: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
20538: LD_ADDR_VAR 0 2
20542: PUSH
20543: LD_INT 22
20545: PUSH
20546: LD_OWVAR 2
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: PUSH
20555: LD_INT 33
20557: PUSH
20558: LD_INT 3
20560: PUSH
20561: EMPTY
20562: LIST
20563: LIST
20564: PUSH
20565: EMPTY
20566: LIST
20567: LIST
20568: PPUSH
20569: CALL_OW 69
20573: ST_TO_ADDR
// if not tmp then
20574: LD_VAR 0 2
20578: NOT
20579: IFFALSE 20583
// exit ;
20581: GO 20709
// side := 0 ;
20583: LD_ADDR_VAR 0 3
20587: PUSH
20588: LD_INT 0
20590: ST_TO_ADDR
// for i := 1 to 8 do
20591: LD_ADDR_VAR 0 1
20595: PUSH
20596: DOUBLE
20597: LD_INT 1
20599: DEC
20600: ST_TO_ADDR
20601: LD_INT 8
20603: PUSH
20604: FOR_TO
20605: IFFALSE 20653
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
20607: LD_OWVAR 2
20611: PUSH
20612: LD_VAR 0 1
20616: NONEQUAL
20617: PUSH
20618: LD_OWVAR 2
20622: PPUSH
20623: LD_VAR 0 1
20627: PPUSH
20628: CALL_OW 81
20632: PUSH
20633: LD_INT 2
20635: EQUAL
20636: AND
20637: IFFALSE 20651
// begin side := i ;
20639: LD_ADDR_VAR 0 3
20643: PUSH
20644: LD_VAR 0 1
20648: ST_TO_ADDR
// break ;
20649: GO 20653
// end ;
20651: GO 20604
20653: POP
20654: POP
// if not side then
20655: LD_VAR 0 3
20659: NOT
20660: IFFALSE 20664
// exit ;
20662: GO 20709
// for i := 1 to tmp do
20664: LD_ADDR_VAR 0 1
20668: PUSH
20669: DOUBLE
20670: LD_INT 1
20672: DEC
20673: ST_TO_ADDR
20674: LD_VAR 0 2
20678: PUSH
20679: FOR_TO
20680: IFFALSE 20707
// if Prob ( 30 ) then
20682: LD_INT 30
20684: PPUSH
20685: CALL_OW 13
20689: IFFALSE 20705
// SetSide ( i , side ) ;
20691: LD_VAR 0 1
20695: PPUSH
20696: LD_VAR 0 3
20700: PPUSH
20701: CALL_OW 235
20705: GO 20679
20707: POP
20708: POP
// end ;
20709: PPOPN 3
20711: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
20712: LD_EXP 47
20716: PUSH
20717: LD_EXP 58
20721: AND
20722: IFFALSE 20841
20724: GO 20726
20726: DISABLE
20727: LD_INT 0
20729: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
20730: LD_ADDR_VAR 0 1
20734: PUSH
20735: LD_INT 22
20737: PUSH
20738: LD_OWVAR 2
20742: PUSH
20743: EMPTY
20744: LIST
20745: LIST
20746: PUSH
20747: LD_INT 21
20749: PUSH
20750: LD_INT 1
20752: PUSH
20753: EMPTY
20754: LIST
20755: LIST
20756: PUSH
20757: LD_INT 3
20759: PUSH
20760: LD_INT 23
20762: PUSH
20763: LD_INT 0
20765: PUSH
20766: EMPTY
20767: LIST
20768: LIST
20769: PUSH
20770: EMPTY
20771: LIST
20772: LIST
20773: PUSH
20774: EMPTY
20775: LIST
20776: LIST
20777: LIST
20778: PPUSH
20779: CALL_OW 69
20783: PUSH
20784: FOR_IN
20785: IFFALSE 20839
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
20787: LD_VAR 0 1
20791: PPUSH
20792: CALL_OW 257
20796: PUSH
20797: LD_INT 1
20799: PUSH
20800: LD_INT 2
20802: PUSH
20803: LD_INT 3
20805: PUSH
20806: LD_INT 4
20808: PUSH
20809: EMPTY
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: IN
20815: IFFALSE 20837
// SetClass ( un , rand ( 1 , 4 ) ) ;
20817: LD_VAR 0 1
20821: PPUSH
20822: LD_INT 1
20824: PPUSH
20825: LD_INT 4
20827: PPUSH
20828: CALL_OW 12
20832: PPUSH
20833: CALL_OW 336
20837: GO 20784
20839: POP
20840: POP
// end ;
20841: PPOPN 1
20843: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
20844: LD_EXP 47
20848: PUSH
20849: LD_EXP 57
20853: AND
20854: IFFALSE 20933
20856: GO 20858
20858: DISABLE
20859: LD_INT 0
20861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
20862: LD_ADDR_VAR 0 1
20866: PUSH
20867: LD_INT 22
20869: PUSH
20870: LD_OWVAR 2
20874: PUSH
20875: EMPTY
20876: LIST
20877: LIST
20878: PUSH
20879: LD_INT 21
20881: PUSH
20882: LD_INT 3
20884: PUSH
20885: EMPTY
20886: LIST
20887: LIST
20888: PUSH
20889: EMPTY
20890: LIST
20891: LIST
20892: PPUSH
20893: CALL_OW 69
20897: ST_TO_ADDR
// if not tmp then
20898: LD_VAR 0 1
20902: NOT
20903: IFFALSE 20907
// exit ;
20905: GO 20933
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
20907: LD_VAR 0 1
20911: PUSH
20912: LD_INT 1
20914: PPUSH
20915: LD_VAR 0 1
20919: PPUSH
20920: CALL_OW 12
20924: ARRAY
20925: PPUSH
20926: LD_INT 100
20928: PPUSH
20929: CALL_OW 234
// end ;
20933: PPOPN 1
20935: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
20936: LD_EXP 47
20940: PUSH
20941: LD_EXP 59
20945: AND
20946: IFFALSE 21044
20948: GO 20950
20950: DISABLE
20951: LD_INT 0
20953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20954: LD_ADDR_VAR 0 1
20958: PUSH
20959: LD_INT 22
20961: PUSH
20962: LD_OWVAR 2
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PUSH
20971: LD_INT 21
20973: PUSH
20974: LD_INT 1
20976: PUSH
20977: EMPTY
20978: LIST
20979: LIST
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: PPUSH
20985: CALL_OW 69
20989: ST_TO_ADDR
// if not tmp then
20990: LD_VAR 0 1
20994: NOT
20995: IFFALSE 20999
// exit ;
20997: GO 21044
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
20999: LD_VAR 0 1
21003: PUSH
21004: LD_INT 1
21006: PPUSH
21007: LD_VAR 0 1
21011: PPUSH
21012: CALL_OW 12
21016: ARRAY
21017: PPUSH
21018: LD_INT 1
21020: PPUSH
21021: LD_INT 4
21023: PPUSH
21024: CALL_OW 12
21028: PPUSH
21029: LD_INT 3000
21031: PPUSH
21032: LD_INT 9000
21034: PPUSH
21035: CALL_OW 12
21039: PPUSH
21040: CALL_OW 492
// end ;
21044: PPOPN 1
21046: END
// every 0 0$1 trigger StreamModeActive and sDepot do
21047: LD_EXP 47
21051: PUSH
21052: LD_EXP 60
21056: AND
21057: IFFALSE 21077
21059: GO 21061
21061: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
21062: LD_INT 1
21064: PPUSH
21065: LD_OWVAR 2
21069: PPUSH
21070: LD_INT 0
21072: PPUSH
21073: CALL_OW 324
21077: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
21078: LD_EXP 47
21082: PUSH
21083: LD_EXP 61
21087: AND
21088: IFFALSE 21171
21090: GO 21092
21092: DISABLE
21093: LD_INT 0
21095: PPUSH
21096: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21097: LD_ADDR_VAR 0 2
21101: PUSH
21102: LD_INT 22
21104: PUSH
21105: LD_OWVAR 2
21109: PUSH
21110: EMPTY
21111: LIST
21112: LIST
21113: PUSH
21114: LD_INT 21
21116: PUSH
21117: LD_INT 3
21119: PUSH
21120: EMPTY
21121: LIST
21122: LIST
21123: PUSH
21124: EMPTY
21125: LIST
21126: LIST
21127: PPUSH
21128: CALL_OW 69
21132: ST_TO_ADDR
// if not tmp then
21133: LD_VAR 0 2
21137: NOT
21138: IFFALSE 21142
// exit ;
21140: GO 21171
// for i in tmp do
21142: LD_ADDR_VAR 0 1
21146: PUSH
21147: LD_VAR 0 2
21151: PUSH
21152: FOR_IN
21153: IFFALSE 21169
// SetBLevel ( i , 10 ) ;
21155: LD_VAR 0 1
21159: PPUSH
21160: LD_INT 10
21162: PPUSH
21163: CALL_OW 241
21167: GO 21152
21169: POP
21170: POP
// end ;
21171: PPOPN 2
21173: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
21174: LD_EXP 47
21178: PUSH
21179: LD_EXP 62
21183: AND
21184: IFFALSE 21295
21186: GO 21188
21188: DISABLE
21189: LD_INT 0
21191: PPUSH
21192: PPUSH
21193: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21194: LD_ADDR_VAR 0 3
21198: PUSH
21199: LD_INT 22
21201: PUSH
21202: LD_OWVAR 2
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: LD_INT 25
21213: PUSH
21214: LD_INT 1
21216: PUSH
21217: EMPTY
21218: LIST
21219: LIST
21220: PUSH
21221: EMPTY
21222: LIST
21223: LIST
21224: PPUSH
21225: CALL_OW 69
21229: ST_TO_ADDR
// if not tmp then
21230: LD_VAR 0 3
21234: NOT
21235: IFFALSE 21239
// exit ;
21237: GO 21295
// un := tmp [ rand ( 1 , tmp ) ] ;
21239: LD_ADDR_VAR 0 2
21243: PUSH
21244: LD_VAR 0 3
21248: PUSH
21249: LD_INT 1
21251: PPUSH
21252: LD_VAR 0 3
21256: PPUSH
21257: CALL_OW 12
21261: ARRAY
21262: ST_TO_ADDR
// if Crawls ( un ) then
21263: LD_VAR 0 2
21267: PPUSH
21268: CALL_OW 318
21272: IFFALSE 21283
// ComWalk ( un ) ;
21274: LD_VAR 0 2
21278: PPUSH
21279: CALL_OW 138
// SetClass ( un , class_sniper ) ;
21283: LD_VAR 0 2
21287: PPUSH
21288: LD_INT 5
21290: PPUSH
21291: CALL_OW 336
// end ;
21295: PPOPN 3
21297: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
21298: LD_EXP 47
21302: PUSH
21303: LD_EXP 63
21307: AND
21308: PUSH
21309: LD_OWVAR 67
21313: PUSH
21314: LD_INT 3
21316: LESS
21317: AND
21318: IFFALSE 21337
21320: GO 21322
21322: DISABLE
// Difficulty := Difficulty + 1 ;
21323: LD_ADDR_OWVAR 67
21327: PUSH
21328: LD_OWVAR 67
21332: PUSH
21333: LD_INT 1
21335: PLUS
21336: ST_TO_ADDR
21337: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
21338: LD_EXP 47
21342: PUSH
21343: LD_EXP 64
21347: AND
21348: IFFALSE 21451
21350: GO 21352
21352: DISABLE
21353: LD_INT 0
21355: PPUSH
// begin for i := 1 to 5 do
21356: LD_ADDR_VAR 0 1
21360: PUSH
21361: DOUBLE
21362: LD_INT 1
21364: DEC
21365: ST_TO_ADDR
21366: LD_INT 5
21368: PUSH
21369: FOR_TO
21370: IFFALSE 21449
// begin uc_nation := nation_nature ;
21372: LD_ADDR_OWVAR 21
21376: PUSH
21377: LD_INT 0
21379: ST_TO_ADDR
// uc_side := 0 ;
21380: LD_ADDR_OWVAR 20
21384: PUSH
21385: LD_INT 0
21387: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
21388: LD_ADDR_OWVAR 29
21392: PUSH
21393: LD_INT 12
21395: PUSH
21396: LD_INT 12
21398: PUSH
21399: EMPTY
21400: LIST
21401: LIST
21402: ST_TO_ADDR
// hc_agressivity := 20 ;
21403: LD_ADDR_OWVAR 35
21407: PUSH
21408: LD_INT 20
21410: ST_TO_ADDR
// hc_class := class_tiger ;
21411: LD_ADDR_OWVAR 28
21415: PUSH
21416: LD_INT 14
21418: ST_TO_ADDR
// hc_gallery :=  ;
21419: LD_ADDR_OWVAR 33
21423: PUSH
21424: LD_STRING 
21426: ST_TO_ADDR
// hc_name :=  ;
21427: LD_ADDR_OWVAR 26
21431: PUSH
21432: LD_STRING 
21434: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
21435: CALL_OW 44
21439: PPUSH
21440: LD_INT 0
21442: PPUSH
21443: CALL_OW 51
// end ;
21447: GO 21369
21449: POP
21450: POP
// end ;
21451: PPOPN 1
21453: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
21454: LD_EXP 47
21458: PUSH
21459: LD_EXP 65
21463: AND
21464: IFFALSE 21638
21466: GO 21468
21468: DISABLE
21469: LD_INT 0
21471: PPUSH
21472: PPUSH
21473: PPUSH
21474: PPUSH
// begin result := false ;
21475: LD_ADDR_VAR 0 4
21479: PUSH
21480: LD_INT 0
21482: ST_TO_ADDR
// for i := 1 to 8 do
21483: LD_ADDR_VAR 0 1
21487: PUSH
21488: DOUBLE
21489: LD_INT 1
21491: DEC
21492: ST_TO_ADDR
21493: LD_INT 8
21495: PUSH
21496: FOR_TO
21497: IFFALSE 21608
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
21499: LD_ADDR_VAR 0 2
21503: PUSH
21504: LD_INT 10
21506: PUSH
21507: LD_INT 50
21509: PUSH
21510: LD_INT 90
21512: PUSH
21513: LD_INT 140
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: LIST
21520: LIST
21521: PUSH
21522: LD_INT 1
21524: PPUSH
21525: LD_INT 4
21527: PPUSH
21528: CALL_OW 12
21532: ARRAY
21533: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
21534: LD_ADDR_VAR 0 3
21538: PUSH
21539: LD_INT 10
21541: PUSH
21542: LD_INT 50
21544: PUSH
21545: LD_INT 90
21547: PUSH
21548: LD_INT 140
21550: PUSH
21551: EMPTY
21552: LIST
21553: LIST
21554: LIST
21555: LIST
21556: PUSH
21557: LD_INT 1
21559: PPUSH
21560: LD_INT 4
21562: PPUSH
21563: CALL_OW 12
21567: ARRAY
21568: ST_TO_ADDR
// if ValidHex ( x , y ) then
21569: LD_VAR 0 2
21573: PPUSH
21574: LD_VAR 0 3
21578: PPUSH
21579: CALL_OW 488
21583: IFFALSE 21606
// begin result := [ x , y ] ;
21585: LD_ADDR_VAR 0 4
21589: PUSH
21590: LD_VAR 0 2
21594: PUSH
21595: LD_VAR 0 3
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: ST_TO_ADDR
// break ;
21604: GO 21608
// end ; end ;
21606: GO 21496
21608: POP
21609: POP
// if result then
21610: LD_VAR 0 4
21614: IFFALSE 21638
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
21616: LD_VAR 0 4
21620: PUSH
21621: LD_INT 1
21623: ARRAY
21624: PPUSH
21625: LD_VAR 0 4
21629: PUSH
21630: LD_INT 2
21632: ARRAY
21633: PPUSH
21634: CALL_OW 429
// end ;
21638: PPOPN 4
21640: END
// every 0 0$1 trigger StreamModeActive and sReset do
21641: LD_EXP 47
21645: PUSH
21646: LD_EXP 67
21650: AND
21651: IFFALSE 21663
21653: GO 21655
21655: DISABLE
// YouLost (  ) ;
21656: LD_STRING 
21658: PPUSH
21659: CALL_OW 104
21663: END
// every 0 0$1 trigger StreamModeActive and sFog do
21664: LD_EXP 47
21668: PUSH
21669: LD_EXP 66
21673: AND
21674: IFFALSE 21688
21676: GO 21678
21678: DISABLE
// FogOff ( your_side ) ;
21679: LD_OWVAR 2
21683: PPUSH
21684: CALL_OW 344
21688: END
// every 0 0$1 trigger StreamModeActive and sSun do
21689: LD_EXP 47
21693: PUSH
21694: LD_EXP 68
21698: AND
21699: IFFALSE 21727
21701: GO 21703
21703: DISABLE
// begin solar_recharge_percent := 0 ;
21704: LD_ADDR_OWVAR 79
21708: PUSH
21709: LD_INT 0
21711: ST_TO_ADDR
// wait ( 5 5$00 ) ;
21712: LD_INT 10500
21714: PPUSH
21715: CALL_OW 67
// solar_recharge_percent := 100 ;
21719: LD_ADDR_OWVAR 79
21723: PUSH
21724: LD_INT 100
21726: ST_TO_ADDR
// end ;
21727: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
21728: LD_EXP 47
21732: PUSH
21733: LD_EXP 69
21737: AND
21738: IFFALSE 21977
21740: GO 21742
21742: DISABLE
21743: LD_INT 0
21745: PPUSH
21746: PPUSH
21747: PPUSH
// begin tmp := [ ] ;
21748: LD_ADDR_VAR 0 3
21752: PUSH
21753: EMPTY
21754: ST_TO_ADDR
// for i := 1 to 6 do
21755: LD_ADDR_VAR 0 1
21759: PUSH
21760: DOUBLE
21761: LD_INT 1
21763: DEC
21764: ST_TO_ADDR
21765: LD_INT 6
21767: PUSH
21768: FOR_TO
21769: IFFALSE 21874
// begin uc_nation := nation_nature ;
21771: LD_ADDR_OWVAR 21
21775: PUSH
21776: LD_INT 0
21778: ST_TO_ADDR
// uc_side := 0 ;
21779: LD_ADDR_OWVAR 20
21783: PUSH
21784: LD_INT 0
21786: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
21787: LD_ADDR_OWVAR 29
21791: PUSH
21792: LD_INT 12
21794: PUSH
21795: LD_INT 12
21797: PUSH
21798: EMPTY
21799: LIST
21800: LIST
21801: ST_TO_ADDR
// hc_agressivity := 20 ;
21802: LD_ADDR_OWVAR 35
21806: PUSH
21807: LD_INT 20
21809: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
21810: LD_ADDR_OWVAR 28
21814: PUSH
21815: LD_INT 17
21817: ST_TO_ADDR
// hc_gallery :=  ;
21818: LD_ADDR_OWVAR 33
21822: PUSH
21823: LD_STRING 
21825: ST_TO_ADDR
// hc_name :=  ;
21826: LD_ADDR_OWVAR 26
21830: PUSH
21831: LD_STRING 
21833: ST_TO_ADDR
// un := CreateHuman ;
21834: LD_ADDR_VAR 0 2
21838: PUSH
21839: CALL_OW 44
21843: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
21844: LD_VAR 0 2
21848: PPUSH
21849: LD_INT 1
21851: PPUSH
21852: CALL_OW 51
// tmp := tmp * un ;
21856: LD_ADDR_VAR 0 3
21860: PUSH
21861: LD_VAR 0 3
21865: PUSH
21866: LD_VAR 0 2
21870: MUL
21871: ST_TO_ADDR
// end ;
21872: GO 21768
21874: POP
21875: POP
// repeat wait ( 0 0$1 ) ;
21876: LD_INT 35
21878: PPUSH
21879: CALL_OW 67
// for un in tmp do
21883: LD_ADDR_VAR 0 2
21887: PUSH
21888: LD_VAR 0 3
21892: PUSH
21893: FOR_IN
21894: IFFALSE 21968
// begin if IsDead ( un ) then
21896: LD_VAR 0 2
21900: PPUSH
21901: CALL_OW 301
21905: IFFALSE 21925
// begin tmp := tmp diff un ;
21907: LD_ADDR_VAR 0 3
21911: PUSH
21912: LD_VAR 0 3
21916: PUSH
21917: LD_VAR 0 2
21921: DIFF
21922: ST_TO_ADDR
// continue ;
21923: GO 21893
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
21925: LD_VAR 0 2
21929: PPUSH
21930: LD_INT 3
21932: PUSH
21933: LD_INT 22
21935: PUSH
21936: LD_INT 0
21938: PUSH
21939: EMPTY
21940: LIST
21941: LIST
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: PPUSH
21947: CALL_OW 69
21951: PPUSH
21952: LD_VAR 0 2
21956: PPUSH
21957: CALL_OW 74
21961: PPUSH
21962: CALL_OW 115
// end ;
21966: GO 21893
21968: POP
21969: POP
// until not tmp ;
21970: LD_VAR 0 3
21974: NOT
21975: IFFALSE 21876
// end ;
21977: PPOPN 3
21979: END
// every 0 0$1 trigger StreamModeActive and sTroll do
21980: LD_EXP 47
21984: PUSH
21985: LD_EXP 70
21989: AND
21990: IFFALSE 22016
21992: GO 21994
21994: DISABLE
// begin ToLua ( displayTroll(); ) ;
21995: LD_STRING displayTroll();
21997: PPUSH
21998: CALL_OW 559
// wait ( 3 3$00 ) ;
22002: LD_INT 6300
22004: PPUSH
22005: CALL_OW 67
// ToLua ( hideTroll(); ) ;
22009: LD_STRING hideTroll();
22011: PPUSH
22012: CALL_OW 559
// end ;
22016: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
22017: LD_EXP 47
22021: PUSH
22022: LD_EXP 71
22026: AND
22027: IFFALSE 22090
22029: GO 22031
22031: DISABLE
22032: LD_INT 0
22034: PPUSH
// begin p := 0 ;
22035: LD_ADDR_VAR 0 1
22039: PUSH
22040: LD_INT 0
22042: ST_TO_ADDR
// repeat game_speed := 1 ;
22043: LD_ADDR_OWVAR 65
22047: PUSH
22048: LD_INT 1
22050: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22051: LD_INT 35
22053: PPUSH
22054: CALL_OW 67
// p := p + 1 ;
22058: LD_ADDR_VAR 0 1
22062: PUSH
22063: LD_VAR 0 1
22067: PUSH
22068: LD_INT 1
22070: PLUS
22071: ST_TO_ADDR
// until p >= 60 ;
22072: LD_VAR 0 1
22076: PUSH
22077: LD_INT 60
22079: GREATEREQUAL
22080: IFFALSE 22043
// game_speed := 4 ;
22082: LD_ADDR_OWVAR 65
22086: PUSH
22087: LD_INT 4
22089: ST_TO_ADDR
// end ;
22090: PPOPN 1
22092: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
22093: LD_EXP 47
22097: PUSH
22098: LD_EXP 72
22102: AND
22103: IFFALSE 22249
22105: GO 22107
22107: DISABLE
22108: LD_INT 0
22110: PPUSH
22111: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22112: LD_ADDR_VAR 0 1
22116: PUSH
22117: LD_INT 22
22119: PUSH
22120: LD_OWVAR 2
22124: PUSH
22125: EMPTY
22126: LIST
22127: LIST
22128: PUSH
22129: LD_INT 2
22131: PUSH
22132: LD_INT 30
22134: PUSH
22135: LD_INT 0
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: PUSH
22142: LD_INT 30
22144: PUSH
22145: LD_INT 1
22147: PUSH
22148: EMPTY
22149: LIST
22150: LIST
22151: PUSH
22152: EMPTY
22153: LIST
22154: LIST
22155: LIST
22156: PUSH
22157: EMPTY
22158: LIST
22159: LIST
22160: PPUSH
22161: CALL_OW 69
22165: ST_TO_ADDR
// if not depot then
22166: LD_VAR 0 1
22170: NOT
22171: IFFALSE 22175
// exit ;
22173: GO 22249
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
22175: LD_ADDR_VAR 0 2
22179: PUSH
22180: LD_VAR 0 1
22184: PUSH
22185: LD_INT 1
22187: PPUSH
22188: LD_VAR 0 1
22192: PPUSH
22193: CALL_OW 12
22197: ARRAY
22198: PPUSH
22199: CALL_OW 274
22203: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
22204: LD_VAR 0 2
22208: PPUSH
22209: LD_INT 1
22211: PPUSH
22212: LD_INT 0
22214: PPUSH
22215: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
22219: LD_VAR 0 2
22223: PPUSH
22224: LD_INT 2
22226: PPUSH
22227: LD_INT 0
22229: PPUSH
22230: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
22234: LD_VAR 0 2
22238: PPUSH
22239: LD_INT 3
22241: PPUSH
22242: LD_INT 0
22244: PPUSH
22245: CALL_OW 277
// end ;
22249: PPOPN 2
22251: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
22252: LD_EXP 47
22256: PUSH
22257: LD_EXP 73
22261: AND
22262: IFFALSE 22359
22264: GO 22266
22266: DISABLE
22267: LD_INT 0
22269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22270: LD_ADDR_VAR 0 1
22274: PUSH
22275: LD_INT 22
22277: PUSH
22278: LD_OWVAR 2
22282: PUSH
22283: EMPTY
22284: LIST
22285: LIST
22286: PUSH
22287: LD_INT 21
22289: PUSH
22290: LD_INT 1
22292: PUSH
22293: EMPTY
22294: LIST
22295: LIST
22296: PUSH
22297: LD_INT 3
22299: PUSH
22300: LD_INT 23
22302: PUSH
22303: LD_INT 0
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: LIST
22318: PPUSH
22319: CALL_OW 69
22323: ST_TO_ADDR
// if not tmp then
22324: LD_VAR 0 1
22328: NOT
22329: IFFALSE 22333
// exit ;
22331: GO 22359
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
22333: LD_VAR 0 1
22337: PUSH
22338: LD_INT 1
22340: PPUSH
22341: LD_VAR 0 1
22345: PPUSH
22346: CALL_OW 12
22350: ARRAY
22351: PPUSH
22352: LD_INT 200
22354: PPUSH
22355: CALL_OW 234
// end ;
22359: PPOPN 1
22361: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
22362: LD_EXP 47
22366: PUSH
22367: LD_EXP 74
22371: AND
22372: IFFALSE 22451
22374: GO 22376
22376: DISABLE
22377: LD_INT 0
22379: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
22380: LD_ADDR_VAR 0 1
22384: PUSH
22385: LD_INT 22
22387: PUSH
22388: LD_OWVAR 2
22392: PUSH
22393: EMPTY
22394: LIST
22395: LIST
22396: PUSH
22397: LD_INT 21
22399: PUSH
22400: LD_INT 2
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: EMPTY
22408: LIST
22409: LIST
22410: PPUSH
22411: CALL_OW 69
22415: ST_TO_ADDR
// if not tmp then
22416: LD_VAR 0 1
22420: NOT
22421: IFFALSE 22425
// exit ;
22423: GO 22451
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
22425: LD_VAR 0 1
22429: PUSH
22430: LD_INT 1
22432: PPUSH
22433: LD_VAR 0 1
22437: PPUSH
22438: CALL_OW 12
22442: ARRAY
22443: PPUSH
22444: LD_INT 60
22446: PPUSH
22447: CALL_OW 234
// end ;
22451: PPOPN 1
22453: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
22454: LD_EXP 47
22458: PUSH
22459: LD_EXP 75
22463: AND
22464: IFFALSE 22563
22466: GO 22468
22468: DISABLE
22469: LD_INT 0
22471: PPUSH
22472: PPUSH
// begin enable ;
22473: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
22474: LD_ADDR_VAR 0 1
22478: PUSH
22479: LD_INT 22
22481: PUSH
22482: LD_OWVAR 2
22486: PUSH
22487: EMPTY
22488: LIST
22489: LIST
22490: PUSH
22491: LD_INT 61
22493: PUSH
22494: EMPTY
22495: LIST
22496: PUSH
22497: LD_INT 33
22499: PUSH
22500: LD_INT 2
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: LIST
22511: PPUSH
22512: CALL_OW 69
22516: ST_TO_ADDR
// if not tmp then
22517: LD_VAR 0 1
22521: NOT
22522: IFFALSE 22526
// exit ;
22524: GO 22563
// for i in tmp do
22526: LD_ADDR_VAR 0 2
22530: PUSH
22531: LD_VAR 0 1
22535: PUSH
22536: FOR_IN
22537: IFFALSE 22561
// if IsControledBy ( i ) then
22539: LD_VAR 0 2
22543: PPUSH
22544: CALL_OW 312
22548: IFFALSE 22559
// ComUnlink ( i ) ;
22550: LD_VAR 0 2
22554: PPUSH
22555: CALL_OW 136
22559: GO 22536
22561: POP
22562: POP
// end ;
22563: PPOPN 2
22565: END
// every 0 0$1 trigger StreamModeActive and sPowell do
22566: LD_EXP 47
22570: PUSH
22571: LD_EXP 76
22575: AND
22576: IFFALSE 22616
22578: GO 22580
22580: DISABLE
// begin ToLua ( displayPowell(); ) ;
22581: LD_STRING displayPowell();
22583: PPUSH
22584: CALL_OW 559
// wait ( 0 0$20 ) ;
22588: LD_INT 700
22590: PPUSH
22591: CALL_OW 67
// ToLua ( displayPowell(); ) ;
22595: LD_STRING displayPowell();
22597: PPUSH
22598: CALL_OW 559
// wait ( 0 0$40 ) ;
22602: LD_INT 1400
22604: PPUSH
22605: CALL_OW 67
// ToLua ( displayPowell(); ) ;
22609: LD_STRING displayPowell();
22611: PPUSH
22612: CALL_OW 559
// end ;
22616: END
// every 0 0$1 trigger StreamModeActive and sStu do
22617: LD_EXP 47
22621: PUSH
22622: LD_EXP 84
22626: AND
22627: IFFALSE 22639
22629: GO 22631
22631: DISABLE
// begin ToLua ( displayStucuk(); ) ;
22632: LD_STRING displayStucuk();
22634: PPUSH
22635: CALL_OW 559
// end ;
22639: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
22640: LD_EXP 47
22644: PUSH
22645: LD_EXP 77
22649: AND
22650: IFFALSE 22791
22652: GO 22654
22654: DISABLE
22655: LD_INT 0
22657: PPUSH
22658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
22659: LD_ADDR_VAR 0 2
22663: PUSH
22664: LD_INT 22
22666: PUSH
22667: LD_OWVAR 2
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: PUSH
22676: LD_INT 21
22678: PUSH
22679: LD_INT 1
22681: PUSH
22682: EMPTY
22683: LIST
22684: LIST
22685: PUSH
22686: EMPTY
22687: LIST
22688: LIST
22689: PPUSH
22690: CALL_OW 69
22694: ST_TO_ADDR
// if not tmp then
22695: LD_VAR 0 2
22699: NOT
22700: IFFALSE 22704
// exit ;
22702: GO 22791
// un := tmp [ rand ( 1 , tmp ) ] ;
22704: LD_ADDR_VAR 0 1
22708: PUSH
22709: LD_VAR 0 2
22713: PUSH
22714: LD_INT 1
22716: PPUSH
22717: LD_VAR 0 2
22721: PPUSH
22722: CALL_OW 12
22726: ARRAY
22727: ST_TO_ADDR
// SetSide ( un , 0 ) ;
22728: LD_VAR 0 1
22732: PPUSH
22733: LD_INT 0
22735: PPUSH
22736: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
22740: LD_VAR 0 1
22744: PPUSH
22745: LD_OWVAR 3
22749: PUSH
22750: LD_VAR 0 1
22754: DIFF
22755: PPUSH
22756: LD_VAR 0 1
22760: PPUSH
22761: CALL_OW 74
22765: PPUSH
22766: CALL_OW 115
// wait ( 0 0$20 ) ;
22770: LD_INT 700
22772: PPUSH
22773: CALL_OW 67
// SetSide ( un , your_side ) ;
22777: LD_VAR 0 1
22781: PPUSH
22782: LD_OWVAR 2
22786: PPUSH
22787: CALL_OW 235
// end ;
22791: PPOPN 2
22793: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
22794: LD_EXP 47
22798: PUSH
22799: LD_EXP 78
22803: AND
22804: IFFALSE 22910
22806: GO 22808
22808: DISABLE
22809: LD_INT 0
22811: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22812: LD_ADDR_VAR 0 1
22816: PUSH
22817: LD_INT 22
22819: PUSH
22820: LD_OWVAR 2
22824: PUSH
22825: EMPTY
22826: LIST
22827: LIST
22828: PUSH
22829: LD_INT 2
22831: PUSH
22832: LD_INT 30
22834: PUSH
22835: LD_INT 0
22837: PUSH
22838: EMPTY
22839: LIST
22840: LIST
22841: PUSH
22842: LD_INT 30
22844: PUSH
22845: LD_INT 1
22847: PUSH
22848: EMPTY
22849: LIST
22850: LIST
22851: PUSH
22852: EMPTY
22853: LIST
22854: LIST
22855: LIST
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: PPUSH
22861: CALL_OW 69
22865: ST_TO_ADDR
// if not depot then
22866: LD_VAR 0 1
22870: NOT
22871: IFFALSE 22875
// exit ;
22873: GO 22910
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
22875: LD_VAR 0 1
22879: PUSH
22880: LD_INT 1
22882: ARRAY
22883: PPUSH
22884: CALL_OW 250
22888: PPUSH
22889: LD_VAR 0 1
22893: PUSH
22894: LD_INT 1
22896: ARRAY
22897: PPUSH
22898: CALL_OW 251
22902: PPUSH
22903: LD_INT 70
22905: PPUSH
22906: CALL_OW 495
// end ;
22910: PPOPN 1
22912: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
22913: LD_EXP 47
22917: PUSH
22918: LD_EXP 79
22922: AND
22923: IFFALSE 23134
22925: GO 22927
22927: DISABLE
22928: LD_INT 0
22930: PPUSH
22931: PPUSH
22932: PPUSH
22933: PPUSH
22934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
22935: LD_ADDR_VAR 0 5
22939: PUSH
22940: LD_INT 22
22942: PUSH
22943: LD_OWVAR 2
22947: PUSH
22948: EMPTY
22949: LIST
22950: LIST
22951: PUSH
22952: LD_INT 21
22954: PUSH
22955: LD_INT 1
22957: PUSH
22958: EMPTY
22959: LIST
22960: LIST
22961: PUSH
22962: EMPTY
22963: LIST
22964: LIST
22965: PPUSH
22966: CALL_OW 69
22970: ST_TO_ADDR
// if not tmp then
22971: LD_VAR 0 5
22975: NOT
22976: IFFALSE 22980
// exit ;
22978: GO 23134
// for i in tmp do
22980: LD_ADDR_VAR 0 1
22984: PUSH
22985: LD_VAR 0 5
22989: PUSH
22990: FOR_IN
22991: IFFALSE 23132
// begin d := rand ( 0 , 5 ) ;
22993: LD_ADDR_VAR 0 4
22997: PUSH
22998: LD_INT 0
23000: PPUSH
23001: LD_INT 5
23003: PPUSH
23004: CALL_OW 12
23008: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
23009: LD_ADDR_VAR 0 2
23013: PUSH
23014: LD_VAR 0 1
23018: PPUSH
23019: CALL_OW 250
23023: PPUSH
23024: LD_VAR 0 4
23028: PPUSH
23029: LD_INT 3
23031: PPUSH
23032: LD_INT 12
23034: PPUSH
23035: CALL_OW 12
23039: PPUSH
23040: CALL_OW 272
23044: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
23045: LD_ADDR_VAR 0 3
23049: PUSH
23050: LD_VAR 0 1
23054: PPUSH
23055: CALL_OW 251
23059: PPUSH
23060: LD_VAR 0 4
23064: PPUSH
23065: LD_INT 3
23067: PPUSH
23068: LD_INT 12
23070: PPUSH
23071: CALL_OW 12
23075: PPUSH
23076: CALL_OW 273
23080: ST_TO_ADDR
// if ValidHex ( x , y ) then
23081: LD_VAR 0 2
23085: PPUSH
23086: LD_VAR 0 3
23090: PPUSH
23091: CALL_OW 488
23095: IFFALSE 23130
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
23097: LD_VAR 0 1
23101: PPUSH
23102: LD_VAR 0 2
23106: PPUSH
23107: LD_VAR 0 3
23111: PPUSH
23112: LD_INT 3
23114: PPUSH
23115: LD_INT 6
23117: PPUSH
23118: CALL_OW 12
23122: PPUSH
23123: LD_INT 1
23125: PPUSH
23126: CALL_OW 483
// end ;
23130: GO 22990
23132: POP
23133: POP
// end ;
23134: PPOPN 5
23136: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
23137: LD_EXP 47
23141: PUSH
23142: LD_EXP 80
23146: AND
23147: IFFALSE 23241
23149: GO 23151
23151: DISABLE
23152: LD_INT 0
23154: PPUSH
23155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
23156: LD_ADDR_VAR 0 2
23160: PUSH
23161: LD_INT 22
23163: PUSH
23164: LD_OWVAR 2
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PUSH
23173: LD_INT 32
23175: PUSH
23176: LD_INT 1
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: PUSH
23183: LD_INT 21
23185: PUSH
23186: LD_INT 2
23188: PUSH
23189: EMPTY
23190: LIST
23191: LIST
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: LIST
23197: PPUSH
23198: CALL_OW 69
23202: ST_TO_ADDR
// if not tmp then
23203: LD_VAR 0 2
23207: NOT
23208: IFFALSE 23212
// exit ;
23210: GO 23241
// for i in tmp do
23212: LD_ADDR_VAR 0 1
23216: PUSH
23217: LD_VAR 0 2
23221: PUSH
23222: FOR_IN
23223: IFFALSE 23239
// SetFuel ( i , 0 ) ;
23225: LD_VAR 0 1
23229: PPUSH
23230: LD_INT 0
23232: PPUSH
23233: CALL_OW 240
23237: GO 23222
23239: POP
23240: POP
// end ;
23241: PPOPN 2
23243: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
23244: LD_EXP 47
23248: PUSH
23249: LD_EXP 81
23253: AND
23254: IFFALSE 23320
23256: GO 23258
23258: DISABLE
23259: LD_INT 0
23261: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
23262: LD_ADDR_VAR 0 1
23266: PUSH
23267: LD_INT 22
23269: PUSH
23270: LD_OWVAR 2
23274: PUSH
23275: EMPTY
23276: LIST
23277: LIST
23278: PUSH
23279: LD_INT 30
23281: PUSH
23282: LD_INT 29
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: PPUSH
23293: CALL_OW 69
23297: ST_TO_ADDR
// if not tmp then
23298: LD_VAR 0 1
23302: NOT
23303: IFFALSE 23307
// exit ;
23305: GO 23320
// DestroyUnit ( tmp [ 1 ] ) ;
23307: LD_VAR 0 1
23311: PUSH
23312: LD_INT 1
23314: ARRAY
23315: PPUSH
23316: CALL_OW 65
// end ;
23320: PPOPN 1
23322: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
23323: LD_EXP 47
23327: PUSH
23328: LD_EXP 83
23332: AND
23333: IFFALSE 23446
23335: GO 23337
23337: DISABLE
23338: LD_INT 0
23340: PPUSH
// begin uc_side := 0 ;
23341: LD_ADDR_OWVAR 20
23345: PUSH
23346: LD_INT 0
23348: ST_TO_ADDR
// uc_nation := nation_arabian ;
23349: LD_ADDR_OWVAR 21
23353: PUSH
23354: LD_INT 2
23356: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
23357: LD_INT 1
23359: PPUSH
23360: LD_INT 10
23362: PPUSH
23363: LD_INT 11
23365: PPUSH
23366: CALL_OW 380
// un := CreateHuman ;
23370: LD_ADDR_VAR 0 1
23374: PUSH
23375: CALL_OW 44
23379: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23380: LD_VAR 0 1
23384: PPUSH
23385: LD_INT 1
23387: PPUSH
23388: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
23392: LD_INT 35
23394: PPUSH
23395: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
23399: LD_VAR 0 1
23403: PPUSH
23404: LD_INT 22
23406: PUSH
23407: LD_OWVAR 2
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: PPUSH
23416: CALL_OW 69
23420: PPUSH
23421: LD_VAR 0 1
23425: PPUSH
23426: CALL_OW 74
23430: PPUSH
23431: CALL_OW 115
// until IsDead ( un ) ;
23435: LD_VAR 0 1
23439: PPUSH
23440: CALL_OW 301
23444: IFFALSE 23392
// end ; end_of_file
23446: PPOPN 1
23448: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
23449: LD_INT 0
23451: PPUSH
23452: PPUSH
23453: PPUSH
23454: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
23455: LD_VAR 0 1
23459: PPUSH
23460: CALL_OW 264
23464: PUSH
23465: LD_EXP 46
23469: EQUAL
23470: IFFALSE 23542
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
23472: LD_INT 68
23474: PPUSH
23475: LD_VAR 0 1
23479: PPUSH
23480: CALL_OW 255
23484: PPUSH
23485: CALL_OW 321
23489: PUSH
23490: LD_INT 2
23492: EQUAL
23493: IFFALSE 23505
// eff := 70 else
23495: LD_ADDR_VAR 0 6
23499: PUSH
23500: LD_INT 70
23502: ST_TO_ADDR
23503: GO 23513
// eff := 30 ;
23505: LD_ADDR_VAR 0 6
23509: PUSH
23510: LD_INT 30
23512: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
23513: LD_VAR 0 1
23517: PPUSH
23518: CALL_OW 250
23522: PPUSH
23523: LD_VAR 0 1
23527: PPUSH
23528: CALL_OW 251
23532: PPUSH
23533: LD_VAR 0 6
23537: PPUSH
23538: CALL_OW 495
// end ; end ;
23542: LD_VAR 0 4
23546: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
23547: LD_INT 0
23549: PPUSH
23550: PPUSH
23551: PPUSH
23552: PPUSH
23553: PPUSH
23554: PPUSH
// if cmd = 124 then
23555: LD_VAR 0 1
23559: PUSH
23560: LD_INT 124
23562: EQUAL
23563: IFFALSE 23769
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
23565: LD_ADDR_VAR 0 5
23569: PUSH
23570: LD_INT 2
23572: PUSH
23573: LD_INT 34
23575: PUSH
23576: LD_INT 53
23578: PUSH
23579: EMPTY
23580: LIST
23581: LIST
23582: PUSH
23583: LD_INT 34
23585: PUSH
23586: LD_INT 14
23588: PUSH
23589: EMPTY
23590: LIST
23591: LIST
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: LIST
23597: PPUSH
23598: CALL_OW 69
23602: ST_TO_ADDR
// if not tmp then
23603: LD_VAR 0 5
23607: NOT
23608: IFFALSE 23612
// exit ;
23610: GO 23769
// for i in tmp do
23612: LD_ADDR_VAR 0 3
23616: PUSH
23617: LD_VAR 0 5
23621: PUSH
23622: FOR_IN
23623: IFFALSE 23767
// begin taskList := GetTaskList ( i ) ;
23625: LD_ADDR_VAR 0 6
23629: PUSH
23630: LD_VAR 0 3
23634: PPUSH
23635: CALL_OW 437
23639: ST_TO_ADDR
// if not taskList then
23640: LD_VAR 0 6
23644: NOT
23645: IFFALSE 23649
// continue ;
23647: GO 23622
// for j = 1 to taskList do
23649: LD_ADDR_VAR 0 4
23653: PUSH
23654: DOUBLE
23655: LD_INT 1
23657: DEC
23658: ST_TO_ADDR
23659: LD_VAR 0 6
23663: PUSH
23664: FOR_TO
23665: IFFALSE 23763
// if taskList [ j ] [ 1 ] = | then
23667: LD_VAR 0 6
23671: PUSH
23672: LD_VAR 0 4
23676: ARRAY
23677: PUSH
23678: LD_INT 1
23680: ARRAY
23681: PUSH
23682: LD_STRING |
23684: EQUAL
23685: IFFALSE 23761
// begin _taskList := Delete ( taskList , 1 ) ;
23687: LD_ADDR_VAR 0 7
23691: PUSH
23692: LD_VAR 0 6
23696: PPUSH
23697: LD_INT 1
23699: PPUSH
23700: CALL_OW 3
23704: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
23705: LD_VAR 0 3
23709: PPUSH
23710: LD_VAR 0 7
23714: PPUSH
23715: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
23719: LD_VAR 0 3
23723: PPUSH
23724: LD_VAR 0 6
23728: PUSH
23729: LD_VAR 0 4
23733: ARRAY
23734: PUSH
23735: LD_INT 2
23737: ARRAY
23738: PPUSH
23739: LD_VAR 0 6
23743: PUSH
23744: LD_VAR 0 4
23748: ARRAY
23749: PUSH
23750: LD_INT 3
23752: ARRAY
23753: PPUSH
23754: LD_INT 8
23756: PPUSH
23757: CALL 23774 0 4
// end ;
23761: GO 23664
23763: POP
23764: POP
// end ;
23765: GO 23622
23767: POP
23768: POP
// end ; end ;
23769: LD_VAR 0 2
23773: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
23774: LD_INT 0
23776: PPUSH
23777: PPUSH
23778: PPUSH
23779: PPUSH
23780: PPUSH
23781: PPUSH
23782: PPUSH
23783: PPUSH
23784: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
23785: LD_VAR 0 1
23789: NOT
23790: PUSH
23791: LD_VAR 0 2
23795: PPUSH
23796: LD_VAR 0 3
23800: PPUSH
23801: CALL_OW 488
23805: NOT
23806: OR
23807: PUSH
23808: LD_VAR 0 4
23812: NOT
23813: OR
23814: IFFALSE 23818
// exit ;
23816: GO 24158
// list := [ ] ;
23818: LD_ADDR_VAR 0 13
23822: PUSH
23823: EMPTY
23824: ST_TO_ADDR
// if x - r < 0 then
23825: LD_VAR 0 2
23829: PUSH
23830: LD_VAR 0 4
23834: MINUS
23835: PUSH
23836: LD_INT 0
23838: LESS
23839: IFFALSE 23851
// min_x := 0 else
23841: LD_ADDR_VAR 0 7
23845: PUSH
23846: LD_INT 0
23848: ST_TO_ADDR
23849: GO 23867
// min_x := x - r ;
23851: LD_ADDR_VAR 0 7
23855: PUSH
23856: LD_VAR 0 2
23860: PUSH
23861: LD_VAR 0 4
23865: MINUS
23866: ST_TO_ADDR
// if y - r < 0 then
23867: LD_VAR 0 3
23871: PUSH
23872: LD_VAR 0 4
23876: MINUS
23877: PUSH
23878: LD_INT 0
23880: LESS
23881: IFFALSE 23893
// min_y := 0 else
23883: LD_ADDR_VAR 0 8
23887: PUSH
23888: LD_INT 0
23890: ST_TO_ADDR
23891: GO 23909
// min_y := y - r ;
23893: LD_ADDR_VAR 0 8
23897: PUSH
23898: LD_VAR 0 3
23902: PUSH
23903: LD_VAR 0 4
23907: MINUS
23908: ST_TO_ADDR
// max_x := x + r ;
23909: LD_ADDR_VAR 0 9
23913: PUSH
23914: LD_VAR 0 2
23918: PUSH
23919: LD_VAR 0 4
23923: PLUS
23924: ST_TO_ADDR
// max_y := y + r ;
23925: LD_ADDR_VAR 0 10
23929: PUSH
23930: LD_VAR 0 3
23934: PUSH
23935: LD_VAR 0 4
23939: PLUS
23940: ST_TO_ADDR
// for _x = min_x to max_x do
23941: LD_ADDR_VAR 0 11
23945: PUSH
23946: DOUBLE
23947: LD_VAR 0 7
23951: DEC
23952: ST_TO_ADDR
23953: LD_VAR 0 9
23957: PUSH
23958: FOR_TO
23959: IFFALSE 24076
// for _y = min_y to max_y do
23961: LD_ADDR_VAR 0 12
23965: PUSH
23966: DOUBLE
23967: LD_VAR 0 8
23971: DEC
23972: ST_TO_ADDR
23973: LD_VAR 0 10
23977: PUSH
23978: FOR_TO
23979: IFFALSE 24072
// begin if not ValidHex ( _x , _y ) then
23981: LD_VAR 0 11
23985: PPUSH
23986: LD_VAR 0 12
23990: PPUSH
23991: CALL_OW 488
23995: NOT
23996: IFFALSE 24000
// continue ;
23998: GO 23978
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
24000: LD_VAR 0 11
24004: PPUSH
24005: LD_VAR 0 12
24009: PPUSH
24010: CALL_OW 351
24014: PUSH
24015: LD_VAR 0 11
24019: PPUSH
24020: LD_VAR 0 12
24024: PPUSH
24025: CALL_OW 554
24029: AND
24030: IFFALSE 24070
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
24032: LD_ADDR_VAR 0 13
24036: PUSH
24037: LD_VAR 0 13
24041: PPUSH
24042: LD_VAR 0 13
24046: PUSH
24047: LD_INT 1
24049: PLUS
24050: PPUSH
24051: LD_VAR 0 11
24055: PUSH
24056: LD_VAR 0 12
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PPUSH
24065: CALL_OW 2
24069: ST_TO_ADDR
// end ;
24070: GO 23978
24072: POP
24073: POP
24074: GO 23958
24076: POP
24077: POP
// if not list then
24078: LD_VAR 0 13
24082: NOT
24083: IFFALSE 24087
// exit ;
24085: GO 24158
// for i in list do
24087: LD_ADDR_VAR 0 6
24091: PUSH
24092: LD_VAR 0 13
24096: PUSH
24097: FOR_IN
24098: IFFALSE 24156
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
24100: LD_VAR 0 1
24104: PPUSH
24105: LD_STRING M
24107: PUSH
24108: LD_VAR 0 6
24112: PUSH
24113: LD_INT 1
24115: ARRAY
24116: PUSH
24117: LD_VAR 0 6
24121: PUSH
24122: LD_INT 2
24124: ARRAY
24125: PUSH
24126: LD_INT 0
24128: PUSH
24129: LD_INT 0
24131: PUSH
24132: LD_INT 0
24134: PUSH
24135: LD_INT 0
24137: PUSH
24138: EMPTY
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: LIST
24144: LIST
24145: LIST
24146: PUSH
24147: EMPTY
24148: LIST
24149: PPUSH
24150: CALL_OW 447
24154: GO 24097
24156: POP
24157: POP
// end ;
24158: LD_VAR 0 5
24162: RET
