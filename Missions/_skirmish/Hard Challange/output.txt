// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// debug := 0 ;
  21: LD_ADDR_EXP 1
  25: PUSH
  26: LD_INT 0
  28: ST_TO_ADDR
// if debug then
  29: LD_EXP 1
  33: IFFALSE 55
// begin display_strings := Debug mode active! ;
  35: LD_ADDR_OWVAR 47
  39: PUSH
  40: LD_STRING Debug mode active!
  42: ST_TO_ADDR
// Your_Side := 1 ;
  43: LD_ADDR_OWVAR 2
  47: PUSH
  48: LD_INT 1
  50: ST_TO_ADDR
// TurnFogOff ;
  51: CALL_OW 537
// end ; Difficulty := GetMultiplayerSetting ( 0 ) ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 426
  67: ST_TO_ADDR
// if not Difficulty then
  68: LD_OWVAR 67
  72: NOT
  73: IFFALSE 83
// Difficulty := 2 ;
  75: LD_ADDR_OWVAR 67
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// PrepareTigers ( tiger_area ) ;
  83: LD_INT 8
  85: PPUSH
  86: CALL 10726 0 1
// PrepareApemans ( apeman_area ) ;
  90: LD_INT 9
  92: PPUSH
  93: CALL 10856 0 1
// PrepareRussian ;
  97: CALL 117 0 0
// PrepareAmerican ;
 101: CALL 12263 0 0
// if not debug then
 105: LD_EXP 1
 109: NOT
 110: IFFALSE 116
// Action ;
 112: CALL 14492 0 0
// end ;
 116: END
// export debug ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 117: LD_INT 0
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
// uc_side := 3 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 3
 130: ST_TO_ADDR
// uc_nation := nation_russian ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 3
 138: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 139: LD_ADDR_VAR 0 2
 143: PUSH
 144: LD_INT 6
 146: PUSH
 147: LD_INT 7
 149: PUSH
 150: LD_INT 8
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: LIST
 157: PUSH
 158: LD_OWVAR 67
 162: ARRAY
 163: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 164: LD_INT 2
 166: PPUSH
 167: CALL_OW 274
 171: PPUSH
 172: LD_INT 1
 174: PPUSH
 175: LD_INT 1200
 177: PPUSH
 178: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 182: LD_INT 2
 184: PPUSH
 185: CALL_OW 274
 189: PPUSH
 190: LD_INT 2
 192: PPUSH
 193: LD_INT 600
 195: PPUSH
 196: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 200: LD_INT 33
 202: PPUSH
 203: LD_INT 4
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 213: LD_INT 37
 215: PPUSH
 216: LD_INT 3
 218: PPUSH
 219: LD_INT 3
 221: PPUSH
 222: CALL_OW 441
// ru_force := [ ] ;
 226: LD_ADDR_EXP 2
 230: PUSH
 231: EMPTY
 232: ST_TO_ADDR
// ru_group1 := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// ru_group2 := [ ] ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: EMPTY
 246: ST_TO_ADDR
// ru_reserve := [ ] ;
 247: LD_ADDR_EXP 8
 251: PUSH
 252: EMPTY
 253: ST_TO_ADDR
// ru_attack_list := [ ] ;
 254: LD_ADDR_EXP 9
 258: PUSH
 259: EMPTY
 260: ST_TO_ADDR
// ru_protector := [ ] ;
 261: LD_ADDR_EXP 16
 265: PUSH
 266: EMPTY
 267: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 268: LD_ADDR_EXP 5
 272: PUSH
 273: LD_INT 48
 275: PUSH
 276: LD_INT 49
 278: PUSH
 279: LD_INT 50
 281: PUSH
 282: LD_INT 20
 284: PUSH
 285: LD_INT 1
 287: PUSH
 288: LD_INT 51
 290: PUSH
 291: LD_INT 52
 293: PUSH
 294: LD_INT 69
 296: PUSH
 297: LD_INT 39
 299: PUSH
 300: LD_INT 34
 302: PUSH
 303: LD_INT 40
 305: PUSH
 306: LD_INT 53
 308: PUSH
 309: LD_INT 71
 311: PUSH
 312: LD_INT 57
 314: PUSH
 315: LD_INT 58
 317: PUSH
 318: LD_INT 44
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: LD_INT 27
 326: PUSH
 327: LD_INT 23
 329: PUSH
 330: LD_INT 33
 332: PUSH
 333: LD_INT 59
 335: PUSH
 336: LD_INT 54
 338: PUSH
 339: LD_INT 55
 341: PUSH
 342: LD_INT 56
 344: PUSH
 345: LD_INT 63
 347: PUSH
 348: LD_INT 64
 350: PUSH
 351: LD_INT 65
 353: PUSH
 354: LD_INT 30
 356: PUSH
 357: LD_INT 31
 359: PUSH
 360: LD_INT 21
 362: PUSH
 363: LD_INT 22
 365: PUSH
 366: LD_INT 25
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 403: LD_ADDR_EXP 6
 407: PUSH
 408: LD_INT 3
 410: PPUSH
 411: LD_INT 33
 413: PPUSH
 414: CALL 8841 0 2
 418: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 419: LD_ADDR_EXP 7
 423: PUSH
 424: LD_INT 46
 426: PUSH
 427: LD_INT 45
 429: PUSH
 430: LD_INT 47
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 438: LD_ADDR_EXP 12
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 36
 448: PUSH
 449: LD_INT 8
 451: PUSH
 452: LD_INT 3
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// ru_buildings := [ ] ;
 461: LD_ADDR_EXP 13
 465: PUSH
 466: EMPTY
 467: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 468: LD_ADDR_EXP 10
 472: PUSH
 473: LD_INT 3
 475: PPUSH
 476: CALL 6890 0 1
 480: PUSH
 481: LD_INT 1
 483: ARRAY
 484: PPUSH
 485: CALL_OW 250
 489: PUSH
 490: LD_INT 3
 492: PPUSH
 493: CALL 6890 0 1
 497: PUSH
 498: LD_INT 1
 500: ARRAY
 501: PPUSH
 502: CALL_OW 251
 506: PUSH
 507: LD_INT 3
 509: PPUSH
 510: CALL 6890 0 1
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: CALL_OW 254
 523: PUSH
 524: LD_INT 3
 526: PPUSH
 527: CALL 6890 0 1
 531: PUSH
 532: LD_INT 1
 534: ARRAY
 535: PPUSH
 536: LD_INT 1
 538: PPUSH
 539: CALL_OW 268
 543: PUSH
 544: LD_INT 3
 546: PPUSH
 547: CALL 6890 0 1
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_INT 2
 558: PPUSH
 559: CALL_OW 268
 563: PUSH
 564: EMPTY
 565: LIST
 566: LIST
 567: LIST
 568: LIST
 569: LIST
 570: PUSH
 571: LD_INT 12
 573: PUSH
 574: LD_INT 13
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 11
 582: PUSH
 583: LD_INT 14
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: ST_TO_ADDR
// ru_heal_list := [ ] ;
 597: LD_ADDR_EXP 11
 601: PUSH
 602: EMPTY
 603: ST_TO_ADDR
// need_buldozer := false ;
 604: LD_ADDR_EXP 17
 608: PUSH
 609: LD_INT 0
 611: ST_TO_ADDR
// need_crane := true ;
 612: LD_ADDR_EXP 18
 616: PUSH
 617: LD_INT 1
 619: ST_TO_ADDR
// ru_spotted := false ;
 620: LD_ADDR_EXP 15
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// for i = 1 to 6 do
 628: LD_ADDR_VAR 0 3
 632: PUSH
 633: DOUBLE
 634: LD_INT 1
 636: DEC
 637: ST_TO_ADDR
 638: LD_INT 6
 640: PUSH
 641: FOR_TO
 642: IFFALSE 683
// begin PrepareHuman ( false , 4 , skill ) ;
 644: LD_INT 0
 646: PPUSH
 647: LD_INT 4
 649: PPUSH
 650: LD_VAR 0 2
 654: PPUSH
 655: CALL_OW 380
// un := CreateHuman ;
 659: LD_ADDR_VAR 0 4
 663: PUSH
 664: CALL_OW 44
 668: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 669: LD_VAR 0 4
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: CALL_OW 52
// end ;
 681: GO 641
 683: POP
 684: POP
// for i = 1 to 6 do
 685: LD_ADDR_VAR 0 3
 689: PUSH
 690: DOUBLE
 691: LD_INT 1
 693: DEC
 694: ST_TO_ADDR
 695: LD_INT 6
 697: PUSH
 698: FOR_TO
 699: IFFALSE 740
// begin PrepareHuman ( false , 3 , skill ) ;
 701: LD_INT 0
 703: PPUSH
 704: LD_INT 3
 706: PPUSH
 707: LD_VAR 0 2
 711: PPUSH
 712: CALL_OW 380
// un := CreateHuman ;
 716: LD_ADDR_VAR 0 4
 720: PUSH
 721: CALL_OW 44
 725: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 726: LD_VAR 0 4
 730: PPUSH
 731: LD_INT 14
 733: PPUSH
 734: CALL_OW 52
// end ;
 738: GO 698
 740: POP
 741: POP
// for i = 1 to 6 do
 742: LD_ADDR_VAR 0 3
 746: PUSH
 747: DOUBLE
 748: LD_INT 1
 750: DEC
 751: ST_TO_ADDR
 752: LD_INT 6
 754: PUSH
 755: FOR_TO
 756: IFFALSE 800
// begin PrepareHuman ( false , 2 , skill ) ;
 758: LD_INT 0
 760: PPUSH
 761: LD_INT 2
 763: PPUSH
 764: LD_VAR 0 2
 768: PPUSH
 769: CALL_OW 380
// un := CreateHuman ;
 773: LD_ADDR_VAR 0 4
 777: PUSH
 778: CALL_OW 44
 782: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 783: LD_VAR 0 4
 787: PPUSH
 788: LD_INT 1
 790: PPUSH
 791: LD_INT 0
 793: PPUSH
 794: CALL_OW 49
// end ;
 798: GO 755
 800: POP
 801: POP
// for i = 1 to 6 do
 802: LD_ADDR_VAR 0 3
 806: PUSH
 807: DOUBLE
 808: LD_INT 1
 810: DEC
 811: ST_TO_ADDR
 812: LD_INT 6
 814: PUSH
 815: FOR_TO
 816: IFFALSE 894
// begin PrepareHuman ( false , 1 , skill ) ;
 818: LD_INT 0
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: LD_VAR 0 2
 828: PPUSH
 829: CALL_OW 380
// un := CreateHuman ;
 833: LD_ADDR_VAR 0 4
 837: PUSH
 838: CALL_OW 44
 842: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 843: LD_VAR 0 4
 847: PPUSH
 848: LD_INT 1
 850: PPUSH
 851: LD_INT 0
 853: PPUSH
 854: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 858: LD_VAR 0 4
 862: PPUSH
 863: LD_INT 30
 865: PUSH
 866: LD_INT 5
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL_OW 69
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: CALL_OW 74
 887: PPUSH
 888: CALL_OW 120
// end ;
 892: GO 815
 894: POP
 895: POP
// for i = 1 to Difficulty do
 896: LD_ADDR_VAR 0 3
 900: PUSH
 901: DOUBLE
 902: LD_INT 1
 904: DEC
 905: ST_TO_ADDR
 906: LD_OWVAR 67
 910: PUSH
 911: FOR_TO
 912: IFFALSE 1023
// begin vc_chassis := ru_medium_tracked ;
 914: LD_ADDR_OWVAR 37
 918: PUSH
 919: LD_INT 22
 921: ST_TO_ADDR
// vc_engine := engine_siberite ;
 922: LD_ADDR_OWVAR 39
 926: PUSH
 927: LD_INT 3
 929: ST_TO_ADDR
// vc_control := control_computer ;
 930: LD_ADDR_OWVAR 38
 934: PUSH
 935: LD_INT 3
 937: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 938: LD_ADDR_OWVAR 40
 942: PUSH
 943: LD_INT 43
 945: PUSH
 946: LD_INT 45
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: PUSH
 953: LD_VAR 0 3
 957: PUSH
 958: LD_INT 2
 960: MOD
 961: PUSH
 962: LD_INT 1
 964: PLUS
 965: ARRAY
 966: ST_TO_ADDR
// un := CreateVehicle ;
 967: LD_ADDR_VAR 0 4
 971: PUSH
 972: CALL_OW 45
 976: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
 977: LD_VAR 0 4
 981: PPUSH
 982: LD_INT 52
 984: PPUSH
 985: LD_INT 42
 987: PPUSH
 988: LD_INT 6
 990: PPUSH
 991: LD_INT 0
 993: PPUSH
 994: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
 998: LD_ADDR_EXP 16
1002: PUSH
1003: LD_EXP 16
1007: PPUSH
1008: LD_INT 1
1010: PPUSH
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 2
1020: ST_TO_ADDR
// end ;
1021: GO 911
1023: POP
1024: POP
// end ;
1025: LD_VAR 0 1
1029: RET
// every 150 150$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1030: LD_OWVAR 67
1034: PUSH
1035: LD_INT 2
1037: EQUAL
1038: PUSH
1039: LD_INT 3
1041: PPUSH
1042: LD_INT 3
1044: PPUSH
1045: CALL 6739 0 2
1049: AND
1050: IFFALSE 1086
1052: GO 1054
1054: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 3
1060: PPUSH
1061: CALL 6739 0 2
1065: PUSH
1066: LD_INT 1
1068: ARRAY
1069: PPUSH
1070: LD_INT 24
1072: PPUSH
1073: LD_INT 1
1075: PPUSH
1076: LD_INT 3
1078: PPUSH
1079: LD_INT 48
1081: PPUSH
1082: CALL 8614 0 5
1086: END
// every 120 120$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1087: LD_OWVAR 67
1091: PUSH
1092: LD_INT 3
1094: EQUAL
1095: PUSH
1096: LD_INT 3
1098: PPUSH
1099: LD_INT 3
1101: PPUSH
1102: CALL 6739 0 2
1106: AND
1107: IFFALSE 1143
1109: GO 1111
1111: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1112: LD_INT 3
1114: PPUSH
1115: LD_INT 3
1117: PPUSH
1118: CALL 6739 0 2
1122: PUSH
1123: LD_INT 1
1125: ARRAY
1126: PPUSH
1127: LD_INT 24
1129: PPUSH
1130: LD_INT 1
1132: PPUSH
1133: LD_INT 3
1135: PPUSH
1136: LD_INT 48
1138: PPUSH
1139: CALL 8614 0 5
1143: END
// every 0 0$01 trigger ru_protector do var i ;
1144: LD_EXP 16
1148: IFFALSE 1319
1150: GO 1152
1152: DISABLE
1153: LD_INT 0
1155: PPUSH
// begin enable ;
1156: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1157: LD_INT 14
1159: PPUSH
1160: LD_INT 81
1162: PUSH
1163: LD_INT 3
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: PPUSH
1170: CALL_OW 70
1174: IFFALSE 1249
// begin for i = 1 to ru_protector do
1176: LD_ADDR_VAR 0 1
1180: PUSH
1181: DOUBLE
1182: LD_INT 1
1184: DEC
1185: ST_TO_ADDR
1186: LD_EXP 16
1190: PUSH
1191: FOR_TO
1192: IFFALSE 1245
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1194: LD_EXP 16
1198: PUSH
1199: LD_VAR 0 1
1203: ARRAY
1204: PPUSH
1205: LD_INT 14
1207: PPUSH
1208: LD_INT 81
1210: PUSH
1211: LD_INT 3
1213: PUSH
1214: EMPTY
1215: LIST
1216: LIST
1217: PPUSH
1218: CALL_OW 70
1222: PPUSH
1223: LD_EXP 16
1227: PUSH
1228: LD_VAR 0 1
1232: ARRAY
1233: PPUSH
1234: CALL_OW 74
1238: PPUSH
1239: CALL_OW 115
1243: GO 1191
1245: POP
1246: POP
// end else
1247: GO 1319
// for i = 1 to ru_protector do
1249: LD_ADDR_VAR 0 1
1253: PUSH
1254: DOUBLE
1255: LD_INT 1
1257: DEC
1258: ST_TO_ADDR
1259: LD_EXP 16
1263: PUSH
1264: FOR_TO
1265: IFFALSE 1317
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1267: LD_EXP 16
1271: PUSH
1272: LD_VAR 0 1
1276: ARRAY
1277: PPUSH
1278: LD_INT 49
1280: PPUSH
1281: LD_INT 39
1283: PPUSH
1284: CALL_OW 297
1288: PUSH
1289: LD_INT 10
1291: GREATER
1292: IFFALSE 1315
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1294: LD_EXP 16
1298: PUSH
1299: LD_VAR 0 1
1303: ARRAY
1304: PPUSH
1305: LD_INT 49
1307: PPUSH
1308: LD_INT 39
1310: PPUSH
1311: CALL_OW 111
1315: GO 1264
1317: POP
1318: POP
// end ;
1319: PPOPN 1
1321: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1322: LD_OWVAR 1
1326: PUSH
1327: LD_INT 4200
1329: PUSH
1330: LD_INT 2100
1332: PUSH
1333: LD_INT 1050
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: LD_OWVAR 67
1345: ARRAY
1346: GREATER
1347: IFFALSE 1360
1349: GO 1351
1351: DISABLE
// need_buldozer := true ;
1352: LD_ADDR_EXP 17
1356: PUSH
1357: LD_INT 1
1359: ST_TO_ADDR
1360: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1361: GO 1363
1363: DISABLE
// begin enable ;
1364: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1365: LD_ADDR_EXP 19
1369: PUSH
1370: LD_INT 22
1372: PUSH
1373: LD_INT 3
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: PUSH
1380: LD_INT 25
1382: PUSH
1383: LD_INT 1
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: PPUSH
1394: CALL_OW 69
1398: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1399: LD_ADDR_EXP 20
1403: PUSH
1404: LD_INT 22
1406: PUSH
1407: LD_INT 3
1409: PUSH
1410: EMPTY
1411: LIST
1412: LIST
1413: PUSH
1414: LD_INT 25
1416: PUSH
1417: LD_INT 2
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: PPUSH
1428: CALL_OW 69
1432: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1433: LD_ADDR_EXP 21
1437: PUSH
1438: LD_INT 22
1440: PUSH
1441: LD_INT 3
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: PUSH
1448: LD_INT 25
1450: PUSH
1451: LD_INT 3
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: EMPTY
1459: LIST
1460: LIST
1461: PPUSH
1462: CALL_OW 69
1466: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_INT 22
1474: PUSH
1475: LD_INT 3
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: LD_INT 25
1484: PUSH
1485: LD_INT 4
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PPUSH
1496: CALL_OW 69
1500: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1501: LD_ADDR_EXP 23
1505: PUSH
1506: LD_INT 22
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: LD_INT 25
1518: PUSH
1519: LD_INT 9
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL_OW 69
1534: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1535: LD_ADDR_EXP 24
1539: PUSH
1540: LD_INT 2
1542: PPUSH
1543: LD_INT 22
1545: PUSH
1546: LD_INT 3
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: PUSH
1553: LD_INT 21
1555: PUSH
1556: LD_INT 1
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: PPUSH
1567: CALL_OW 70
1571: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1572: LD_ADDR_EXP 25
1576: PUSH
1577: LD_INT 34
1579: PUSH
1580: LD_INT 53
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1592: LD_ADDR_EXP 26
1596: PUSH
1597: LD_INT 34
1599: PUSH
1600: LD_INT 52
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: PPUSH
1607: CALL_OW 69
1611: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1612: LD_ADDR_EXP 27
1616: PUSH
1617: LD_INT 34
1619: PUSH
1620: LD_INT 51
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PPUSH
1627: CALL_OW 69
1631: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1632: LD_ADDR_EXP 13
1636: PUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 1
1642: NEG
1643: PPUSH
1644: CALL 11244 0 2
1648: ST_TO_ADDR
// end ;
1649: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1650: LD_INT 22
1652: PUSH
1653: LD_INT 3
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PPUSH
1660: CALL_OW 69
1664: PUSH
1665: LD_EXP 28
1669: AND
1670: PUSH
1671: LD_EXP 1
1675: OR
1676: IFFALSE 5165
1678: GO 1680
1680: DISABLE
1681: LD_INT 0
1683: PPUSH
1684: PPUSH
1685: PPUSH
1686: PPUSH
1687: PPUSH
1688: PPUSH
1689: PPUSH
1690: PPUSH
1691: PPUSH
1692: PPUSH
// begin enable ;
1693: ENABLE
// for i = 1 to ru_eng do
1694: LD_ADDR_VAR 0 1
1698: PUSH
1699: DOUBLE
1700: LD_INT 1
1702: DEC
1703: ST_TO_ADDR
1704: LD_EXP 20
1708: PUSH
1709: FOR_TO
1710: IFFALSE 1773
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1712: LD_EXP 20
1716: PUSH
1717: LD_VAR 0 1
1721: ARRAY
1722: PPUSH
1723: CALL_OW 314
1727: NOT
1728: PUSH
1729: LD_EXP 20
1733: PUSH
1734: LD_VAR 0 1
1738: ARRAY
1739: PPUSH
1740: CALL_OW 310
1744: NOT
1745: AND
1746: IFFALSE 1771
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1748: LD_EXP 20
1752: PUSH
1753: LD_VAR 0 1
1757: ARRAY
1758: PPUSH
1759: LD_INT 3
1761: PPUSH
1762: CALL 6648 0 1
1766: PPUSH
1767: CALL_OW 120
1771: GO 1709
1773: POP
1774: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1775: LD_INT 2
1777: PPUSH
1778: LD_INT 22
1780: PUSH
1781: LD_INT 3
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 21
1790: PUSH
1791: LD_INT 3
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: LD_INT 24
1803: PUSH
1804: LD_INT 1000
1806: PUSH
1807: EMPTY
1808: LIST
1809: LIST
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 70
1824: IFFALSE 1991
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1826: LD_ADDR_VAR 0 4
1830: PUSH
1831: LD_INT 2
1833: PPUSH
1834: LD_INT 22
1836: PUSH
1837: LD_INT 3
1839: PUSH
1840: EMPTY
1841: LIST
1842: LIST
1843: PUSH
1844: LD_INT 21
1846: PUSH
1847: LD_INT 3
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: PUSH
1854: LD_INT 3
1856: PUSH
1857: LD_INT 24
1859: PUSH
1860: LD_INT 1000
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: LIST
1875: PPUSH
1876: CALL_OW 70
1880: ST_TO_ADDR
// for i = 1 to ru_eng do
1881: LD_ADDR_VAR 0 1
1885: PUSH
1886: DOUBLE
1887: LD_INT 1
1889: DEC
1890: ST_TO_ADDR
1891: LD_EXP 20
1895: PUSH
1896: FOR_TO
1897: IFFALSE 1989
// begin if IsInUnit ( ru_eng [ i ] ) then
1899: LD_EXP 20
1903: PUSH
1904: LD_VAR 0 1
1908: ARRAY
1909: PPUSH
1910: CALL_OW 310
1914: IFFALSE 1933
// ComExitBuilding ( ru_eng [ i ] ) else
1916: LD_EXP 20
1920: PUSH
1921: LD_VAR 0 1
1925: ARRAY
1926: PPUSH
1927: CALL_OW 122
1931: GO 1987
// if not WantRepair ( ru_eng [ i ] ) then
1933: LD_EXP 20
1937: PUSH
1938: LD_VAR 0 1
1942: ARRAY
1943: PPUSH
1944: CALL 11170 0 1
1948: NOT
1949: IFFALSE 1987
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1951: LD_EXP 20
1955: PUSH
1956: LD_VAR 0 1
1960: ARRAY
1961: PPUSH
1962: LD_VAR 0 4
1966: PPUSH
1967: LD_EXP 20
1971: PUSH
1972: LD_VAR 0 1
1976: ARRAY
1977: PPUSH
1978: CALL_OW 74
1982: PPUSH
1983: CALL_OW 130
// end ;
1987: GO 1896
1989: POP
1990: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
1991: LD_OWVAR 2
1995: PPUSH
1996: LD_INT 38
1998: PPUSH
1999: LD_INT 26
2001: PPUSH
2002: CALL 5967 0 3
2006: PUSH
2007: LD_INT 0
2009: EQUAL
2010: PUSH
2011: LD_OWVAR 2
2015: PPUSH
2016: LD_INT 29
2018: PPUSH
2019: LD_INT 37
2021: PPUSH
2022: CALL 5967 0 3
2026: PUSH
2027: LD_INT 0
2029: EQUAL
2030: AND
2031: IFFALSE 2168
// begin if ru_blist > 0 then
2033: LD_EXP 12
2037: PUSH
2038: LD_INT 0
2040: GREATER
2041: IFFALSE 2168
// begin for i = 1 to ru_eng do
2043: LD_ADDR_VAR 0 1
2047: PUSH
2048: DOUBLE
2049: LD_INT 1
2051: DEC
2052: ST_TO_ADDR
2053: LD_EXP 20
2057: PUSH
2058: FOR_TO
2059: IFFALSE 2166
// if IsInUnit ( ru_eng [ i ] ) then
2061: LD_EXP 20
2065: PUSH
2066: LD_VAR 0 1
2070: ARRAY
2071: PPUSH
2072: CALL_OW 310
2076: IFFALSE 2095
// ComExitBuilding ( ru_eng [ i ] ) else
2078: LD_EXP 20
2082: PUSH
2083: LD_VAR 0 1
2087: ARRAY
2088: PPUSH
2089: CALL_OW 122
2093: GO 2164
// if not HasTask ( ru_eng [ i ] ) then
2095: LD_EXP 20
2099: PUSH
2100: LD_VAR 0 1
2104: ARRAY
2105: PPUSH
2106: CALL_OW 314
2110: NOT
2111: IFFALSE 2164
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2113: LD_EXP 20
2117: PUSH
2118: LD_VAR 0 1
2122: ARRAY
2123: PPUSH
2124: LD_EXP 12
2128: PUSH
2129: LD_INT 1
2131: ARRAY
2132: PPUSH
2133: LD_EXP 12
2137: PUSH
2138: LD_INT 2
2140: ARRAY
2141: PPUSH
2142: LD_EXP 12
2146: PUSH
2147: LD_INT 3
2149: ARRAY
2150: PPUSH
2151: LD_EXP 12
2155: PUSH
2156: LD_INT 4
2158: ARRAY
2159: PPUSH
2160: CALL_OW 145
2164: GO 2058
2166: POP
2167: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2168: LD_ADDR_EXP 11
2172: PUSH
2173: LD_INT 3
2175: PPUSH
2176: LD_EXP 11
2180: PPUSH
2181: LD_EXP 14
2185: PPUSH
2186: CALL 9657 0 3
2190: ST_TO_ADDR
// if debug then
2191: LD_EXP 1
2195: IFFALSE 2207
// display_strings := ru_heal_list ;
2197: LD_ADDR_OWVAR 47
2201: PUSH
2202: LD_EXP 11
2206: ST_TO_ADDR
// for i = 1 to ru_sci do
2207: LD_ADDR_VAR 0 1
2211: PUSH
2212: DOUBLE
2213: LD_INT 1
2215: DEC
2216: ST_TO_ADDR
2217: LD_EXP 22
2221: PUSH
2222: FOR_TO
2223: IFFALSE 2555
// begin if ru_heal_list then
2225: LD_EXP 11
2229: IFFALSE 2468
// begin list := ru_heal_list ;
2231: LD_ADDR_VAR 0 9
2235: PUSH
2236: LD_EXP 11
2240: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2241: LD_EXP 22
2245: PUSH
2246: LD_VAR 0 1
2250: ARRAY
2251: PPUSH
2252: CALL_OW 310
2256: IFFALSE 2273
// ComExitBuilding ( ru_sci [ i ] ) ;
2258: LD_EXP 22
2262: PUSH
2263: LD_VAR 0 1
2267: ARRAY
2268: PPUSH
2269: CALL_OW 122
// for p = 1 to list do
2273: LD_ADDR_VAR 0 5
2277: PUSH
2278: DOUBLE
2279: LD_INT 1
2281: DEC
2282: ST_TO_ADDR
2283: LD_VAR 0 9
2287: PUSH
2288: FOR_TO
2289: IFFALSE 2464
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2291: LD_VAR 0 9
2295: PUSH
2296: LD_VAR 0 5
2300: ARRAY
2301: PPUSH
2302: CALL_OW 110
2306: PUSH
2307: LD_INT 100
2309: EQUAL
2310: PUSH
2311: LD_EXP 22
2315: PUSH
2316: LD_VAR 0 1
2320: ARRAY
2321: PPUSH
2322: LD_INT 100
2324: PPUSH
2325: CALL 10017 0 2
2329: NOT
2330: AND
2331: IFFALSE 2359
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2333: LD_EXP 22
2337: PUSH
2338: LD_VAR 0 1
2342: ARRAY
2343: PPUSH
2344: LD_VAR 0 9
2348: PUSH
2349: LD_VAR 0 5
2353: ARRAY
2354: PPUSH
2355: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2359: LD_VAR 0 9
2363: PUSH
2364: LD_VAR 0 5
2368: ARRAY
2369: PPUSH
2370: CALL_OW 110
2374: PUSH
2375: LD_INT 100
2377: GREATER
2378: IFFALSE 2406
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2380: LD_EXP 22
2384: PUSH
2385: LD_VAR 0 1
2389: ARRAY
2390: PPUSH
2391: LD_VAR 0 9
2395: PUSH
2396: LD_VAR 0 5
2400: ARRAY
2401: PPUSH
2402: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2406: LD_VAR 0 9
2410: PUSH
2411: LD_VAR 0 5
2415: ARRAY
2416: PPUSH
2417: LD_INT 4
2419: PPUSH
2420: CALL_OW 308
2424: NOT
2425: IFFALSE 2447
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2427: LD_VAR 0 9
2431: PUSH
2432: LD_VAR 0 5
2436: ARRAY
2437: PPUSH
2438: LD_INT 4
2440: PPUSH
2441: CALL_OW 113
2445: GO 2462
// ComHold ( list [ p ] ) ;
2447: LD_VAR 0 9
2451: PUSH
2452: LD_VAR 0 5
2456: ARRAY
2457: PPUSH
2458: CALL_OW 140
// end ;
2462: GO 2288
2464: POP
2465: POP
// end else
2466: GO 2553
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2468: LD_EXP 22
2472: PUSH
2473: LD_VAR 0 1
2477: ARRAY
2478: PPUSH
2479: CALL_OW 314
2483: NOT
2484: PUSH
2485: LD_EXP 22
2489: PUSH
2490: LD_VAR 0 1
2494: ARRAY
2495: PPUSH
2496: CALL_OW 310
2500: NOT
2501: AND
2502: PUSH
2503: LD_EXP 11
2507: PUSH
2508: LD_INT 0
2510: EQUAL
2511: AND
2512: IFFALSE 2553
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2514: LD_EXP 22
2518: PUSH
2519: LD_VAR 0 1
2523: ARRAY
2524: PPUSH
2525: LD_INT 3
2527: PPUSH
2528: CALL 6890 0 1
2532: PPUSH
2533: LD_EXP 22
2537: PUSH
2538: LD_VAR 0 1
2542: ARRAY
2543: PPUSH
2544: CALL_OW 74
2548: PPUSH
2549: CALL_OW 120
// end ;
2553: GO 2222
2555: POP
2556: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2557: LD_INT 3
2559: PPUSH
2560: LD_EXP 5
2564: PPUSH
2565: CALL 7031 0 2
2569: IFFALSE 2583
// ResearchTechList ( 3 , ru_tech_list ) ;
2571: LD_INT 3
2573: PPUSH
2574: LD_EXP 5
2578: PPUSH
2579: CALL 7106 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2583: LD_EXP 20
2587: PPUSH
2588: LD_EXP 10
2592: PPUSH
2593: CALL 9013 0 2
// lab := GetLabs ( 3 ) ;
2597: LD_ADDR_VAR 0 8
2601: PUSH
2602: LD_INT 3
2604: PPUSH
2605: CALL 6890 0 1
2609: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2610: LD_VAR 0 8
2614: PUSH
2615: LD_EXP 11
2619: PUSH
2620: LD_INT 0
2622: EQUAL
2623: AND
2624: IFFALSE 2751
// for i = 1 to lab do
2626: LD_ADDR_VAR 0 1
2630: PUSH
2631: DOUBLE
2632: LD_INT 1
2634: DEC
2635: ST_TO_ADDR
2636: LD_VAR 0 8
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2749
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2644: LD_VAR 0 8
2648: PUSH
2649: LD_VAR 0 1
2653: ARRAY
2654: PPUSH
2655: CALL_OW 461
2659: PUSH
2660: LD_INT 6
2662: EQUAL
2663: IFFALSE 2747
// begin for p = 1 to ru_sci do
2665: LD_ADDR_VAR 0 5
2669: PUSH
2670: DOUBLE
2671: LD_INT 1
2673: DEC
2674: ST_TO_ADDR
2675: LD_EXP 22
2679: PUSH
2680: FOR_TO
2681: IFFALSE 2745
// if IsInUnit ( ru_sci [ p ] ) then
2683: LD_EXP 22
2687: PUSH
2688: LD_VAR 0 5
2692: ARRAY
2693: PPUSH
2694: CALL_OW 310
2698: IFFALSE 2717
// ComExitBuilding ( ru_sci [ p ] ) else
2700: LD_EXP 22
2704: PUSH
2705: LD_VAR 0 5
2709: ARRAY
2710: PPUSH
2711: CALL_OW 122
2715: GO 2743
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2717: LD_EXP 22
2721: PUSH
2722: LD_VAR 0 5
2726: ARRAY
2727: PPUSH
2728: LD_VAR 0 8
2732: PUSH
2733: LD_VAR 0 1
2737: ARRAY
2738: PPUSH
2739: CALL_OW 120
2743: GO 2680
2745: POP
2746: POP
// end ;
2747: GO 2641
2749: POP
2750: POP
// if GetTowers ( 3 ) < 5 then
2751: LD_INT 3
2753: PPUSH
2754: CALL 7445 0 1
2758: PUSH
2759: LD_INT 5
2761: LESS
2762: IFFALSE 2780
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2764: LD_EXP 20
2768: PPUSH
2769: LD_EXP 6
2773: PPUSH
2774: CALL 8053 0 2
2778: GO 2792
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2780: LD_INT 3
2782: PPUSH
2783: LD_EXP 7
2787: PPUSH
2788: CALL 8344 0 2
// if GetBuilding ( 3 , b_factory ) then
2792: LD_INT 3
2794: PPUSH
2795: LD_INT 3
2797: PPUSH
2798: CALL 6739 0 2
2802: IFFALSE 3072
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2804: LD_INT 3
2806: PPUSH
2807: LD_INT 3
2809: PPUSH
2810: CALL 6739 0 2
2814: PUSH
2815: LD_INT 1
2817: ARRAY
2818: PPUSH
2819: CALL_OW 461
2823: PUSH
2824: LD_INT 2
2826: EQUAL
2827: IFFALSE 3072
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2829: LD_ADDR_VAR 0 7
2833: PUSH
2834: LD_INT 3
2836: PPUSH
2837: LD_INT 3
2839: PPUSH
2840: CALL 6739 0 2
2844: PUSH
2845: LD_INT 1
2847: ARRAY
2848: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2849: LD_INT 3
2851: PPUSH
2852: LD_INT 24
2854: PPUSH
2855: LD_INT 53
2857: PPUSH
2858: CALL 8492 0 3
2862: PUSH
2863: LD_INT 0
2865: EQUAL
2866: PUSH
2867: LD_EXP 17
2871: AND
2872: IFFALSE 2895
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2874: LD_VAR 0 7
2878: PPUSH
2879: LD_INT 24
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 53
2890: PPUSH
2891: CALL 8614 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2895: LD_INT 3
2897: PPUSH
2898: LD_INT 22
2900: PPUSH
2901: LD_INT 52
2903: PPUSH
2904: CALL 8492 0 3
2908: PUSH
2909: LD_INT 0
2911: EQUAL
2912: PUSH
2913: LD_EXP 18
2917: AND
2918: IFFALSE 2941
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2920: LD_VAR 0 7
2924: PPUSH
2925: LD_INT 22
2927: PPUSH
2928: LD_INT 1
2930: PPUSH
2931: LD_INT 3
2933: PPUSH
2934: LD_INT 52
2936: PPUSH
2937: CALL 8614 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2941: LD_INT 3
2943: PPUSH
2944: LD_INT 22
2946: PPUSH
2947: LD_INT 49
2949: PPUSH
2950: CALL 8492 0 3
2954: PUSH
2955: LD_INT 4
2957: LESS
2958: PUSH
2959: LD_INT 31
2961: PPUSH
2962: LD_INT 3
2964: PPUSH
2965: CALL_OW 321
2969: PUSH
2970: LD_INT 2
2972: EQUAL
2973: AND
2974: IFFALSE 2997
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
2976: LD_VAR 0 7
2980: PPUSH
2981: LD_INT 22
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: LD_INT 3
2989: PPUSH
2990: LD_INT 49
2992: PPUSH
2993: CALL 8614 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
2997: LD_EXP 8
3001: PUSH
3002: LD_INT 5
3004: PUSH
3005: LD_INT 6
3007: PUSH
3008: LD_INT 7
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_OWVAR 67
3020: ARRAY
3021: LESS
3022: IFFALSE 3072
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3024: LD_VAR 0 7
3028: PPUSH
3029: LD_INT 24
3031: PPUSH
3032: LD_INT 1
3034: PPUSH
3035: LD_INT 3
3037: PPUSH
3038: LD_INT 46
3040: PUSH
3041: LD_INT 45
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 46
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: LIST
3055: PUSH
3056: LD_INT 1
3058: PPUSH
3059: LD_INT 4
3061: PPUSH
3062: CALL_OW 12
3066: ARRAY
3067: PPUSH
3068: CALL 8614 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3072: LD_INT 3
3074: PPUSH
3075: CALL 6648 0 1
3079: PPUSH
3080: CALL 6340 0 1
3084: PUSH
3085: LD_INT 1
3087: ARRAY
3088: PUSH
3089: LD_INT 250
3091: GREATER
3092: PUSH
3093: LD_INT 3
3095: PPUSH
3096: CALL 6648 0 1
3100: PPUSH
3101: CALL 6340 0 1
3105: PUSH
3106: LD_INT 3
3108: ARRAY
3109: PUSH
3110: LD_INT 50
3112: GREATER
3113: AND
3114: PUSH
3115: LD_INT 23
3117: PPUSH
3118: LD_INT 3
3120: PPUSH
3121: CALL_OW 321
3125: PUSH
3126: LD_INT 2
3128: EQUAL
3129: AND
3130: PUSH
3131: LD_INT 3
3133: PPUSH
3134: CALL 11968 0 1
3138: PUSH
3139: LD_INT 0
3141: EQUAL
3142: AND
3143: PUSH
3144: LD_INT 22
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: PUSH
3154: LD_INT 34
3156: PUSH
3157: LD_INT 49
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: PUSH
3173: LD_INT 3
3175: GREATER
3176: AND
3177: PUSH
3178: LD_OWVAR 2
3182: PPUSH
3183: LD_INT 51
3185: PPUSH
3186: LD_INT 42
3188: PPUSH
3189: CALL 5967 0 3
3193: PUSH
3194: LD_INT 0
3196: EQUAL
3197: AND
3198: IFFALSE 3283
// begin for i = 1 to ru_mech do
3200: LD_ADDR_VAR 0 1
3204: PUSH
3205: DOUBLE
3206: LD_INT 1
3208: DEC
3209: ST_TO_ADDR
3210: LD_EXP 21
3214: PUSH
3215: FOR_TO
3216: IFFALSE 3281
// begin if IsInUnit ( ru_mech [ i ] ) then
3218: LD_EXP 21
3222: PUSH
3223: LD_VAR 0 1
3227: ARRAY
3228: PPUSH
3229: CALL_OW 310
3233: IFFALSE 3252
// ComExitBuilding ( ru_mech [ i ] ) else
3235: LD_EXP 21
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 122
3250: GO 3279
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3252: LD_EXP 21
3256: PUSH
3257: LD_VAR 0 1
3261: ARRAY
3262: PPUSH
3263: LD_INT 37
3265: PPUSH
3266: LD_INT 51
3268: PPUSH
3269: LD_INT 43
3271: PPUSH
3272: LD_INT 0
3274: PPUSH
3275: CALL_OW 170
// end ;
3279: GO 3215
3281: POP
3282: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3283: LD_OWVAR 1
3287: PUSH
3288: LD_INT 94500
3290: PUSH
3291: LD_INT 84000
3293: PUSH
3294: LD_INT 71400
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: PUSH
3302: LD_OWVAR 67
3306: ARRAY
3307: GREATEREQUAL
3308: IFFALSE 3364
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3310: LD_OWVAR 1
3314: PUSH
3315: LD_INT 18900
3317: PUSH
3318: LD_INT 16800
3320: PUSH
3321: LD_INT 14700
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: MOD
3335: PUSH
3336: LD_INT 0
3338: EQUAL
3339: IFFALSE 3364
// if ru_reserve then
3341: LD_EXP 8
3345: IFFALSE 3364
// begin ru_attack_list := ru_reserve ;
3347: LD_ADDR_EXP 9
3351: PUSH
3352: LD_EXP 8
3356: ST_TO_ADDR
// ru_reserve := [ ] ;
3357: LD_ADDR_EXP 8
3361: PUSH
3362: EMPTY
3363: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3364: LD_EXP 9
3368: IFFALSE 3490
// begin for i = 1 to ru_attack_list do
3370: LD_ADDR_VAR 0 1
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_EXP 9
3384: PUSH
3385: FOR_TO
3386: IFFALSE 3488
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3388: LD_EXP 9
3392: PUSH
3393: LD_VAR 0 1
3397: ARRAY
3398: PPUSH
3399: CALL_OW 256
3403: PUSH
3404: LD_INT 250
3406: GREATEREQUAL
3407: PUSH
3408: LD_EXP 9
3412: PUSH
3413: LD_VAR 0 1
3417: ARRAY
3418: PPUSH
3419: CALL_OW 314
3423: NOT
3424: AND
3425: IFFALSE 3486
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3427: LD_EXP 9
3431: PUSH
3432: LD_VAR 0 1
3436: ARRAY
3437: PPUSH
3438: LD_INT 81
3440: PUSH
3441: LD_EXP 9
3445: PUSH
3446: LD_VAR 0 1
3450: ARRAY
3451: PPUSH
3452: CALL_OW 255
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: PPUSH
3466: LD_EXP 9
3470: PUSH
3471: LD_VAR 0 1
3475: ARRAY
3476: PPUSH
3477: CALL_OW 74
3481: PPUSH
3482: CALL_OW 115
3486: GO 3385
3488: POP
3489: POP
// end ; if GetBehemoth ( 3 ) then
3490: LD_INT 3
3492: PPUSH
3493: CALL 11968 0 1
3497: IFFALSE 3791
// begin if ru_mech >= 4 then
3499: LD_EXP 21
3503: PUSH
3504: LD_INT 4
3506: GREATEREQUAL
3507: IFFALSE 3558
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3509: LD_ADDR_EXP 14
3513: PUSH
3514: LD_EXP 21
3518: PUSH
3519: LD_INT 1
3521: ARRAY
3522: PUSH
3523: LD_EXP 21
3527: PUSH
3528: LD_INT 2
3530: ARRAY
3531: PUSH
3532: LD_EXP 21
3536: PUSH
3537: LD_INT 3
3539: ARRAY
3540: PUSH
3541: LD_EXP 21
3545: PUSH
3546: LD_INT 4
3548: ARRAY
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: ST_TO_ADDR
3556: GO 3568
// ru_behemoth_mechanic := ru_mech ;
3558: LD_ADDR_EXP 14
3562: PUSH
3563: LD_EXP 21
3567: ST_TO_ADDR
// for i = 1 to ru_mech do
3568: LD_ADDR_VAR 0 1
3572: PUSH
3573: DOUBLE
3574: LD_INT 1
3576: DEC
3577: ST_TO_ADDR
3578: LD_EXP 21
3582: PUSH
3583: FOR_TO
3584: IFFALSE 3638
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3586: LD_EXP 21
3590: PUSH
3591: LD_VAR 0 1
3595: ARRAY
3596: PPUSH
3597: CALL_OW 310
3601: PUSH
3602: LD_EXP 21
3606: PUSH
3607: LD_VAR 0 1
3611: ARRAY
3612: PUSH
3613: LD_EXP 14
3617: IN
3618: AND
3619: IFFALSE 3636
// ComExitBuilding ( ru_mech [ i ] ) ;
3621: LD_EXP 21
3625: PUSH
3626: LD_VAR 0 1
3630: ARRAY
3631: PPUSH
3632: CALL_OW 122
3636: GO 3583
3638: POP
3639: POP
// if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3640: LD_INT 12
3642: PPUSH
3643: LD_INT 22
3645: PUSH
3646: LD_INT 1
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: LD_INT 21
3655: PUSH
3656: LD_INT 3
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PPUSH
3667: CALL_OW 70
3671: PUSH
3672: LD_INT 0
3674: GREATER
3675: IFFALSE 3735
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3677: LD_INT 3
3679: PPUSH
3680: CALL 11968 0 1
3684: PUSH
3685: LD_INT 1
3687: ARRAY
3688: PPUSH
3689: LD_INT 21
3691: PUSH
3692: LD_INT 2
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 34
3701: PUSH
3702: LD_INT 49
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PPUSH
3713: CALL_OW 69
3717: PPUSH
3718: LD_EXP 14
3722: PPUSH
3723: LD_INT 97
3725: PPUSH
3726: LD_INT 9
3728: PPUSH
3729: CALL 11465 0 5
3733: GO 3791
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3735: LD_INT 3
3737: PPUSH
3738: CALL 11968 0 1
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: PPUSH
3747: LD_INT 21
3749: PUSH
3750: LD_INT 2
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 34
3759: PUSH
3760: LD_INT 49
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: PPUSH
3771: CALL_OW 69
3775: PPUSH
3776: LD_EXP 14
3780: PPUSH
3781: LD_INT 153
3783: PPUSH
3784: LD_INT 102
3786: PPUSH
3787: CALL 11465 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3791: LD_EXP 23
3795: PUSH
3796: LD_INT 0
3798: EQUAL
3799: PUSH
3800: LD_INT 44
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 321
3810: PUSH
3811: LD_INT 2
3813: EQUAL
3814: AND
3815: IFFALSE 3826
// ComChangeClassToBazooker ( ru_sold ) ;
3817: LD_EXP 19
3821: PPUSH
3822: CALL 10402 0 1
// if ru_bazz then
3826: LD_EXP 23
3830: IFFALSE 3844
// IntBazooka ( ru_bazz , 1 ) ;
3832: LD_EXP 23
3836: PPUSH
3837: LD_INT 1
3839: PPUSH
3840: CALL 10121 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3844: LD_INT 67
3846: PPUSH
3847: LD_INT 39
3849: PPUSH
3850: LD_INT 3
3852: PPUSH
3853: CALL_OW 440
3857: PUSH
3858: LD_INT 0
3860: EQUAL
3861: PUSH
3862: LD_INT 20
3864: PPUSH
3865: LD_INT 3
3867: PPUSH
3868: CALL_OW 321
3872: PUSH
3873: LD_INT 2
3875: EQUAL
3876: AND
3877: IFFALSE 3898
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3879: LD_EXP 22
3883: PUSH
3884: LD_INT 1
3886: ARRAY
3887: PPUSH
3888: LD_INT 67
3890: PPUSH
3891: LD_INT 39
3893: PPUSH
3894: CALL 9596 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3898: LD_INT 89
3900: PPUSH
3901: LD_INT 66
3903: PPUSH
3904: LD_INT 3
3906: PPUSH
3907: CALL_OW 440
3911: PUSH
3912: LD_INT 0
3914: EQUAL
3915: IFFALSE 3936
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
3917: LD_EXP 22
3921: PUSH
3922: LD_INT 1
3924: ARRAY
3925: PPUSH
3926: LD_INT 87
3928: PPUSH
3929: LD_INT 60
3931: PPUSH
3932: CALL 9596 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3936: LD_INT 104
3938: PPUSH
3939: LD_INT 94
3941: PPUSH
3942: LD_INT 3
3944: PPUSH
3945: CALL_OW 440
3949: PUSH
3950: LD_INT 0
3952: EQUAL
3953: PUSH
3954: LD_INT 20
3956: PPUSH
3957: LD_INT 3
3959: PPUSH
3960: CALL_OW 321
3964: PUSH
3965: LD_INT 2
3967: EQUAL
3968: AND
3969: IFFALSE 3990
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
3971: LD_EXP 22
3975: PUSH
3976: LD_INT 1
3978: ARRAY
3979: PPUSH
3980: LD_INT 104
3982: PPUSH
3983: LD_INT 94
3985: PPUSH
3986: CALL 9596 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
3990: LD_INT 3
3992: PPUSH
3993: LD_INT 24
3995: PPUSH
3996: LD_INT 53
3998: PPUSH
3999: CALL 8492 0 3
4003: PUSH
4004: LD_INT 1
4006: EQUAL
4007: PUSH
4008: LD_EXP 17
4012: AND
4013: IFFALSE 4154
// begin need_buldozer := false ;
4015: LD_ADDR_EXP 17
4019: PUSH
4020: LD_INT 0
4022: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4023: LD_INT 3
4025: PPUSH
4026: LD_INT 24
4028: PPUSH
4029: LD_INT 53
4031: PPUSH
4032: CALL 8492 0 3
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 39
4046: PPUSH
4047: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 24
4056: PPUSH
4057: LD_INT 53
4059: PPUSH
4060: CALL 8492 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: LD_INT 71
4071: PPUSH
4072: LD_INT 10
4074: PPUSH
4075: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4079: LD_INT 3
4081: PPUSH
4082: LD_INT 24
4084: PPUSH
4085: LD_INT 53
4087: PPUSH
4088: CALL 8492 0 3
4092: PUSH
4093: LD_INT 1
4095: ARRAY
4096: PPUSH
4097: LD_INT 15
4099: PPUSH
4100: CALL 6081 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4104: LD_INT 3
4106: PPUSH
4107: LD_INT 24
4109: PPUSH
4110: LD_INT 53
4112: PPUSH
4113: CALL 8492 0 3
4117: PUSH
4118: LD_INT 1
4120: ARRAY
4121: PPUSH
4122: LD_INT 350
4124: PPUSH
4125: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4129: LD_INT 3
4131: PPUSH
4132: LD_INT 24
4134: PPUSH
4135: LD_INT 53
4137: PPUSH
4138: CALL 8492 0 3
4142: PUSH
4143: LD_INT 1
4145: ARRAY
4146: PPUSH
4147: LD_INT 14
4149: PPUSH
4150: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4154: LD_INT 67
4156: PPUSH
4157: LD_INT 39
4159: PPUSH
4160: LD_INT 3
4162: PPUSH
4163: CALL_OW 440
4167: PUSH
4168: LD_INT 67
4170: PPUSH
4171: LD_INT 39
4173: PPUSH
4174: CALL_OW 428
4178: PUSH
4179: LD_INT 0
4181: EQUAL
4182: AND
4183: PUSH
4184: LD_INT 79
4186: PPUSH
4187: LD_INT 45
4189: PPUSH
4190: CALL_OW 428
4194: PPUSH
4195: CALL_OW 266
4199: PUSH
4200: LD_INT 0
4202: EQUAL
4203: AND
4204: PUSH
4205: LD_INT 1
4207: PPUSH
4208: LD_INT 79
4210: PPUSH
4211: LD_INT 45
4213: PPUSH
4214: CALL 5967 0 3
4218: PUSH
4219: LD_INT 0
4221: EQUAL
4222: AND
4223: IFFALSE 4326
// begin for i = 1 to ru_eng do
4225: LD_ADDR_VAR 0 1
4229: PUSH
4230: DOUBLE
4231: LD_INT 1
4233: DEC
4234: ST_TO_ADDR
4235: LD_EXP 20
4239: PUSH
4240: FOR_TO
4241: IFFALSE 4324
// if IsInUnit ( ru_eng [ i ] ) then
4243: LD_EXP 20
4247: PUSH
4248: LD_VAR 0 1
4252: ARRAY
4253: PPUSH
4254: CALL_OW 310
4258: IFFALSE 4277
// ComExitBuilding ( ru_eng [ i ] ) else
4260: LD_EXP 20
4264: PUSH
4265: LD_VAR 0 1
4269: ARRAY
4270: PPUSH
4271: CALL_OW 122
4275: GO 4322
// if not HasTask ( ru_eng [ i ] ) then
4277: LD_EXP 20
4281: PUSH
4282: LD_VAR 0 1
4286: ARRAY
4287: PPUSH
4288: CALL_OW 314
4292: NOT
4293: IFFALSE 4322
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4295: LD_EXP 20
4299: PUSH
4300: LD_VAR 0 1
4304: ARRAY
4305: PPUSH
4306: LD_INT 30
4308: PPUSH
4309: LD_INT 67
4311: PPUSH
4312: LD_INT 39
4314: PPUSH
4315: LD_INT 3
4317: PPUSH
4318: CALL_OW 145
4322: GO 4240
4324: POP
4325: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4326: LD_INT 1
4328: PPUSH
4329: LD_INT 79
4331: PPUSH
4332: LD_INT 45
4334: PPUSH
4335: CALL 5967 0 3
4339: PUSH
4340: LD_INT 0
4342: EQUAL
4343: IFFALSE 4539
// begin if HexInfo ( 79 , 45 ) = 0 then
4345: LD_INT 79
4347: PPUSH
4348: LD_INT 45
4350: PPUSH
4351: CALL_OW 428
4355: PUSH
4356: LD_INT 0
4358: EQUAL
4359: IFFALSE 4381
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4361: LD_EXP 20
4365: PPUSH
4366: LD_INT 79
4368: PPUSH
4369: LD_INT 45
4371: PPUSH
4372: LD_INT 3
4374: PPUSH
4375: CALL 7507 0 4
4379: GO 4539
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4381: LD_INT 89
4383: PPUSH
4384: LD_INT 66
4386: PPUSH
4387: CALL_OW 428
4391: PUSH
4392: LD_INT 0
4394: EQUAL
4395: PUSH
4396: LD_INT 89
4398: PPUSH
4399: LD_INT 66
4401: PPUSH
4402: LD_INT 3
4404: PPUSH
4405: CALL_OW 440
4409: AND
4410: IFFALSE 4539
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4412: LD_INT 79
4414: PPUSH
4415: LD_INT 45
4417: PPUSH
4418: CALL_OW 428
4422: PPUSH
4423: CALL_OW 274
4427: PPUSH
4428: LD_INT 1
4430: PPUSH
4431: LD_INT 100
4433: PPUSH
4434: CALL_OW 277
// for i = 1 to ru_eng do
4438: LD_ADDR_VAR 0 1
4442: PUSH
4443: DOUBLE
4444: LD_INT 1
4446: DEC
4447: ST_TO_ADDR
4448: LD_EXP 20
4452: PUSH
4453: FOR_TO
4454: IFFALSE 4537
// if IsInUnit ( ru_eng [ i ] ) then
4456: LD_EXP 20
4460: PUSH
4461: LD_VAR 0 1
4465: ARRAY
4466: PPUSH
4467: CALL_OW 310
4471: IFFALSE 4490
// ComExitBuilding ( ru_eng [ i ] ) else
4473: LD_EXP 20
4477: PUSH
4478: LD_VAR 0 1
4482: ARRAY
4483: PPUSH
4484: CALL_OW 122
4488: GO 4535
// if not HasTask ( ru_eng [ i ] ) then
4490: LD_EXP 20
4494: PUSH
4495: LD_VAR 0 1
4499: ARRAY
4500: PPUSH
4501: CALL_OW 314
4505: NOT
4506: IFFALSE 4535
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4508: LD_EXP 20
4512: PUSH
4513: LD_VAR 0 1
4517: ARRAY
4518: PPUSH
4519: LD_INT 29
4521: PPUSH
4522: LD_INT 89
4524: PPUSH
4525: LD_INT 66
4527: PPUSH
4528: LD_INT 3
4530: PPUSH
4531: CALL_OW 145
4535: GO 4453
4537: POP
4538: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4539: LD_INT 3
4541: PPUSH
4542: LD_INT 29
4544: PPUSH
4545: CALL 6739 0 2
4549: PUSH
4550: LD_INT 0
4552: EQUAL
4553: PUSH
4554: LD_INT 1
4556: PPUSH
4557: LD_INT 36
4559: PPUSH
4560: LD_INT 6
4562: PPUSH
4563: CALL 5967 0 3
4567: PUSH
4568: LD_INT 0
4570: EQUAL
4571: AND
4572: PUSH
4573: LD_INT 3
4575: PPUSH
4576: CALL 6648 0 1
4580: PPUSH
4581: LD_INT 29
4583: PPUSH
4584: CALL 6224 0 2
4588: AND
4589: IFFALSE 4692
// begin for i = 1 to ru_eng do
4591: LD_ADDR_VAR 0 1
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_EXP 20
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4690
// begin if IsInUnit ( ru_eng [ i ] ) then
4609: LD_EXP 20
4613: PUSH
4614: LD_VAR 0 1
4618: ARRAY
4619: PPUSH
4620: CALL_OW 310
4624: IFFALSE 4643
// ComExitBuilding ( ru_eng [ i ] ) else
4626: LD_EXP 20
4630: PUSH
4631: LD_VAR 0 1
4635: ARRAY
4636: PPUSH
4637: CALL_OW 122
4641: GO 4688
// if not HasTask ( ru_eng [ i ] ) then
4643: LD_EXP 20
4647: PUSH
4648: LD_VAR 0 1
4652: ARRAY
4653: PPUSH
4654: CALL_OW 314
4658: NOT
4659: IFFALSE 4688
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4661: LD_EXP 20
4665: PUSH
4666: LD_VAR 0 1
4670: ARRAY
4671: PPUSH
4672: LD_INT 29
4674: PPUSH
4675: LD_INT 33
4677: PPUSH
4678: LD_INT 4
4680: PPUSH
4681: LD_INT 0
4683: PPUSH
4684: CALL_OW 205
// end ; end ;
4688: GO 4606
4690: POP
4691: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4692: LD_EXP 20
4696: PUSH
4697: LD_INT 79
4699: PPUSH
4700: LD_INT 45
4702: PPUSH
4703: CALL_OW 428
4707: PUSH
4708: LD_INT 0
4710: GREATER
4711: AND
4712: PUSH
4713: LD_INT 79
4715: PPUSH
4716: LD_INT 45
4718: PPUSH
4719: CALL_OW 428
4723: PPUSH
4724: CALL_OW 266
4728: PUSH
4729: LD_INT 0
4731: EQUAL
4732: AND
4733: IFFALSE 4893
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4735: LD_INT 79
4737: PPUSH
4738: LD_INT 45
4740: PPUSH
4741: CALL_OW 428
4745: PPUSH
4746: CALL_OW 255
4750: PUSH
4751: LD_INT 3
4753: EQUAL
4754: PUSH
4755: LD_INT 1
4757: PPUSH
4758: LD_INT 79
4760: PPUSH
4761: LD_INT 45
4763: PPUSH
4764: CALL 5967 0 3
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: AND
4773: PUSH
4774: LD_INT 79
4776: PPUSH
4777: LD_INT 45
4779: PPUSH
4780: CALL_OW 428
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 3
4792: PPUSH
4793: CALL_OW 275
4797: PUSH
4798: LD_INT 10
4800: GREATEREQUAL
4801: AND
4802: IFFALSE 4893
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4804: LD_EXP 20
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: CALL_OW 310
4817: IFFALSE 4834
// ComExitBuilding ( ru_eng [ 1 ] ) else
4819: LD_EXP 20
4823: PUSH
4824: LD_INT 1
4826: ARRAY
4827: PPUSH
4828: CALL_OW 122
4832: GO 4893
// if not HasTask ( ru_eng [ 1 ] ) then
4834: LD_EXP 20
4838: PUSH
4839: LD_INT 1
4841: ARRAY
4842: PPUSH
4843: CALL_OW 314
4847: NOT
4848: IFFALSE 4893
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4850: LD_EXP 20
4854: PUSH
4855: LD_INT 1
4857: ARRAY
4858: PPUSH
4859: LD_INT 79
4861: PPUSH
4862: LD_INT 45
4864: PPUSH
4865: CALL_OW 428
4869: PPUSH
4870: LD_INT 3
4872: PPUSH
4873: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4877: LD_EXP 20
4881: PUSH
4882: LD_INT 1
4884: ARRAY
4885: PPUSH
4886: LD_INT 2
4888: PPUSH
4889: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4893: LD_EXP 20
4897: PUSH
4898: LD_INT 2
4900: GREATER
4901: PUSH
4902: LD_INT 79
4904: PPUSH
4905: LD_INT 45
4907: PPUSH
4908: CALL_OW 428
4912: PUSH
4913: LD_INT 0
4915: GREATER
4916: AND
4917: PUSH
4918: LD_INT 79
4920: PPUSH
4921: LD_INT 45
4923: PPUSH
4924: CALL_OW 428
4928: PPUSH
4929: CALL_OW 266
4933: PUSH
4934: LD_INT 0
4936: EQUAL
4937: AND
4938: IFFALSE 5098
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
4940: LD_INT 79
4942: PPUSH
4943: LD_INT 45
4945: PPUSH
4946: CALL_OW 428
4950: PPUSH
4951: CALL_OW 255
4955: PUSH
4956: LD_INT 3
4958: EQUAL
4959: PUSH
4960: LD_INT 1
4962: PPUSH
4963: LD_INT 79
4965: PPUSH
4966: LD_INT 45
4968: PPUSH
4969: CALL 5967 0 3
4973: PUSH
4974: LD_INT 0
4976: EQUAL
4977: AND
4978: PUSH
4979: LD_INT 79
4981: PPUSH
4982: LD_INT 45
4984: PPUSH
4985: CALL_OW 428
4989: PPUSH
4990: CALL_OW 274
4994: PPUSH
4995: LD_INT 1
4997: PPUSH
4998: CALL_OW 275
5002: PUSH
5003: LD_INT 20
5005: GREATER
5006: AND
5007: IFFALSE 5098
// begin if IsInUnit ( ru_eng [ 2 ] ) then
5009: LD_EXP 20
5013: PUSH
5014: LD_INT 2
5016: ARRAY
5017: PPUSH
5018: CALL_OW 310
5022: IFFALSE 5039
// ComExitBuilding ( ru_eng [ 2 ] ) else
5024: LD_EXP 20
5028: PUSH
5029: LD_INT 2
5031: ARRAY
5032: PPUSH
5033: CALL_OW 122
5037: GO 5098
// if not HasTask ( ru_eng [ 2 ] ) then
5039: LD_EXP 20
5043: PUSH
5044: LD_INT 2
5046: ARRAY
5047: PPUSH
5048: CALL_OW 314
5052: NOT
5053: IFFALSE 5098
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5055: LD_EXP 20
5059: PUSH
5060: LD_INT 2
5062: ARRAY
5063: PPUSH
5064: LD_INT 79
5066: PPUSH
5067: LD_INT 45
5069: PPUSH
5070: CALL_OW 428
5074: PPUSH
5075: LD_INT 1
5077: PPUSH
5078: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5082: LD_EXP 20
5086: PUSH
5087: LD_INT 2
5089: ARRAY
5090: PPUSH
5091: LD_INT 2
5093: PPUSH
5094: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5098: LD_INT 1
5100: PPUSH
5101: LD_INT 59
5103: PPUSH
5104: LD_INT 60
5106: PPUSH
5107: CALL 5967 0 3
5111: PUSH
5112: LD_INT 0
5114: EQUAL
5115: PUSH
5116: LD_INT 1
5118: PPUSH
5119: LD_INT 67
5121: PPUSH
5122: LD_INT 76
5124: PPUSH
5125: CALL 5967 0 3
5129: PUSH
5130: LD_INT 0
5132: EQUAL
5133: AND
5134: PUSH
5135: LD_INT 1
5137: PPUSH
5138: LD_INT 79
5140: PPUSH
5141: LD_INT 100
5143: PPUSH
5144: CALL 5967 0 3
5148: PUSH
5149: LD_INT 0
5151: EQUAL
5152: AND
5153: IFFALSE 5165
// CollectCrates ( 3 , west_crates ) ;
5155: LD_INT 3
5157: PPUSH
5158: LD_INT 13
5160: PPUSH
5161: CALL 12012 0 2
// end ;
5165: PPOPN 10
5167: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5168: LD_OWVAR 1
5172: PUSH
5173: LD_INT 111300
5175: LESSEQUAL
5176: PUSH
5177: LD_EXP 29
5181: NOT
5182: OR
5183: IFFALSE 5380
5185: GO 5187
5187: DISABLE
5188: LD_INT 0
5190: PPUSH
// begin enable ;
5191: ENABLE
// uc_nation := 3 ;
5192: LD_ADDR_OWVAR 21
5196: PUSH
5197: LD_INT 3
5199: ST_TO_ADDR
// uc_side := 3 ;
5200: LD_ADDR_OWVAR 20
5204: PUSH
5205: LD_INT 3
5207: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5208: LD_ADDR_OWVAR 37
5212: PUSH
5213: LD_INT 22
5215: ST_TO_ADDR
// vc_engine := engine_siberite ;
5216: LD_ADDR_OWVAR 39
5220: PUSH
5221: LD_INT 3
5223: ST_TO_ADDR
// vc_control := control_computer ;
5224: LD_ADDR_OWVAR 38
5228: PUSH
5229: LD_INT 3
5231: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5232: LD_ADDR_OWVAR 40
5236: PUSH
5237: LD_INT 51
5239: ST_TO_ADDR
// veh := CreateVehicle ;
5240: LD_ADDR_VAR 0 1
5244: PUSH
5245: CALL_OW 45
5249: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5250: LD_VAR 0 1
5254: PPUSH
5255: LD_INT 4
5257: PPUSH
5258: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5262: LD_VAR 0 1
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: LD_INT 0
5272: PPUSH
5273: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5277: LD_VAR 0 1
5281: PPUSH
5282: LD_INT 1
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: LD_INT 3
5290: PUSH
5291: LD_INT 2
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: PUSH
5300: LD_INT 1
5302: PPUSH
5303: LD_INT 4
5305: PPUSH
5306: CALL_OW 12
5310: ARRAY
5311: PPUSH
5312: LD_INT 100
5314: PPUSH
5315: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5319: LD_VAR 0 1
5323: PPUSH
5324: LD_INT 2
5326: PPUSH
5327: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5331: LD_VAR 0 1
5335: PPUSH
5336: LD_INT 10
5338: PPUSH
5339: CALL_OW 173
// Wait ( 0 0$10 ) ;
5343: LD_INT 350
5345: PPUSH
5346: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5357: LD_VAR 0 1
5361: PPUSH
5362: LD_INT 10
5364: PPUSH
5365: CALL_OW 308
5369: IFFALSE 5350
// RemoveUnit ( veh ) ;
5371: LD_VAR 0 1
5375: PPUSH
5376: CALL_OW 64
// end ;
5380: PPOPN 1
5382: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
5383: LD_VAR 0 1
5387: PPUSH
5388: CALL_OW 255
5392: PUSH
5393: LD_INT 3
5395: EQUAL
5396: PUSH
5397: LD_VAR 0 1
5401: PUSH
5402: LD_INT 2
5404: PUSH
5405: LD_INT 34
5407: PUSH
5408: LD_INT 46
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PUSH
5415: LD_INT 34
5417: PUSH
5418: LD_INT 47
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: LD_INT 34
5427: PUSH
5428: LD_INT 45
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: LIST
5439: LIST
5440: PUSH
5441: EMPTY
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: IN
5449: AND
5450: IFFALSE 5468
// ru_reserve := ru_reserve ^ un ;
5452: LD_ADDR_EXP 8
5456: PUSH
5457: LD_EXP 8
5461: PUSH
5462: LD_VAR 0 1
5466: ADD
5467: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
5468: LD_VAR 0 1
5472: PUSH
5473: LD_INT 22
5475: PUSH
5476: LD_INT 3
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: PUSH
5483: LD_INT 34
5485: PUSH
5486: LD_INT 48
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PPUSH
5497: CALL_OW 69
5501: IN
5502: IFFALSE 5555
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
5504: LD_INT 12
5506: PPUSH
5507: LD_INT 22
5509: PUSH
5510: LD_INT 1
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PPUSH
5517: CALL_OW 70
5521: IFFALSE 5540
// ComAttackPlace ( un , 98 , 10 ) else
5523: LD_VAR 0 1
5527: PPUSH
5528: LD_INT 98
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 116
5538: GO 5555
// ComAttackPlace ( un , 134 , 99 ) ;
5540: LD_VAR 0 1
5544: PPUSH
5545: LD_INT 134
5547: PPUSH
5548: LD_INT 99
5550: PPUSH
5551: CALL_OW 116
// end ;
5555: PPOPN 2
5557: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
5558: LD_VAR 0 1
5562: PUSH
5563: LD_INT 22
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: PUSH
5573: LD_INT 21
5575: PUSH
5576: LD_INT 3
5578: PUSH
5579: EMPTY
5580: LIST
5581: LIST
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: PPUSH
5587: CALL_OW 69
5591: IN
5592: PUSH
5593: LD_VAR 0 1
5597: PPUSH
5598: CALL_OW 266
5602: PUSH
5603: LD_INT 0
5605: PUSH
5606: LD_INT 29
5608: PUSH
5609: LD_INT 30
5611: PUSH
5612: LD_INT 26
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: LIST
5620: IN
5621: NOT
5622: AND
5623: IFFALSE 5709
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
5625: LD_ADDR_EXP 12
5629: PUSH
5630: LD_EXP 12
5634: PUSH
5635: LD_VAR 0 1
5639: PPUSH
5640: CALL_OW 266
5644: ADD
5645: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
5646: LD_ADDR_EXP 12
5650: PUSH
5651: LD_EXP 12
5655: PUSH
5656: LD_VAR 0 1
5660: PPUSH
5661: CALL_OW 250
5665: ADD
5666: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
5667: LD_ADDR_EXP 12
5671: PUSH
5672: LD_EXP 12
5676: PUSH
5677: LD_VAR 0 1
5681: PPUSH
5682: CALL_OW 251
5686: ADD
5687: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
5688: LD_ADDR_EXP 12
5692: PUSH
5693: LD_EXP 12
5697: PUSH
5698: LD_VAR 0 1
5702: PPUSH
5703: CALL_OW 254
5707: ADD
5708: ST_TO_ADDR
// end ; if un in ru_attack_list then
5709: LD_VAR 0 1
5713: PUSH
5714: LD_EXP 9
5718: IN
5719: IFFALSE 5737
// ru_attack_list := ru_attack_list diff un ;
5721: LD_ADDR_EXP 9
5725: PUSH
5726: LD_EXP 9
5730: PUSH
5731: LD_VAR 0 1
5735: DIFF
5736: ST_TO_ADDR
// if un in ru_protector then
5737: LD_VAR 0 1
5741: PUSH
5742: LD_EXP 16
5746: IN
5747: IFFALSE 5765
// ru_protector := ru_protector diff un ;
5749: LD_ADDR_EXP 16
5753: PUSH
5754: LD_EXP 16
5758: PUSH
5759: LD_VAR 0 1
5763: DIFF
5764: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
5765: LD_VAR 0 1
5769: PPUSH
5770: CALL_OW 266
5774: PUSH
5775: LD_INT 30
5777: EQUAL
5778: PUSH
5779: LD_VAR 0 1
5783: PPUSH
5784: CALL_OW 255
5788: PUSH
5789: LD_INT 1
5791: EQUAL
5792: AND
5793: IFFALSE 5803
// mine_ck := true ;
5795: LD_ADDR_EXP 34
5799: PUSH
5800: LD_INT 1
5802: ST_TO_ADDR
// end ;
5803: PPOPN 1
5805: END
// on BuildingComplete ( un ) do var i ;
5806: LD_INT 0
5808: PPUSH
// begin if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
5809: LD_VAR 0 1
5813: PPUSH
5814: CALL_OW 255
5818: PUSH
5819: LD_INT 3
5821: EQUAL
5822: PUSH
5823: LD_VAR 0 1
5827: PPUSH
5828: CALL_OW 266
5832: PUSH
5833: LD_INT 0
5835: EQUAL
5836: AND
5837: IFFALSE 5894
// begin for i = 1 to 2 do
5839: LD_ADDR_VAR 0 2
5843: PUSH
5844: DOUBLE
5845: LD_INT 1
5847: DEC
5848: ST_TO_ADDR
5849: LD_INT 2
5851: PUSH
5852: FOR_TO
5853: IFFALSE 5892
// begin ComExitBuilding ( ru_sold [ i ] ) ;
5855: LD_EXP 19
5859: PUSH
5860: LD_VAR 0 2
5864: ARRAY
5865: PPUSH
5866: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
5870: LD_EXP 19
5874: PUSH
5875: LD_VAR 0 2
5879: ARRAY
5880: PPUSH
5881: LD_VAR 0 1
5885: PPUSH
5886: CALL_OW 180
// end ;
5890: GO 5852
5892: POP
5893: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
5894: LD_VAR 0 1
5898: PPUSH
5899: CALL_OW 255
5903: PUSH
5904: LD_INT 3
5906: EQUAL
5907: PUSH
5908: LD_VAR 0 1
5912: PPUSH
5913: CALL_OW 266
5917: PUSH
5918: LD_EXP 12
5922: IN
5923: AND
5924: IFFALSE 5964
// for i = 1 to 4 do
5926: LD_ADDR_VAR 0 2
5930: PUSH
5931: DOUBLE
5932: LD_INT 1
5934: DEC
5935: ST_TO_ADDR
5936: LD_INT 4
5938: PUSH
5939: FOR_TO
5940: IFFALSE 5962
// ru_blist := Delete ( ru_blist , 1 ) ;
5942: LD_ADDR_EXP 12
5946: PUSH
5947: LD_EXP 12
5951: PPUSH
5952: LD_INT 1
5954: PPUSH
5955: CALL_OW 3
5959: ST_TO_ADDR
5960: GO 5939
5962: POP
5963: POP
// end ; end_of_file
5964: PPOPN 2
5966: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
5967: LD_INT 0
5969: PPUSH
5970: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
5971: LD_ADDR_VAR 0 5
5975: PUSH
5976: LD_INT 22
5978: PUSH
5979: LD_VAR 0 1
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: PPUSH
5988: CALL_OW 69
5992: PPUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: LD_VAR 0 3
6002: PPUSH
6003: CALL_OW 73
6007: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 then
6008: LD_VAR 0 5
6012: PPUSH
6013: LD_VAR 0 2
6017: PPUSH
6018: LD_VAR 0 3
6022: PPUSH
6023: CALL_OW 297
6027: PUSH
6028: LD_INT 17
6030: LESS
6031: PUSH
6032: LD_INT 2
6034: PPUSH
6035: LD_INT 22
6037: PUSH
6038: LD_VAR 0 1
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: PPUSH
6047: CALL_OW 70
6051: PUSH
6052: LD_INT 0
6054: GREATER
6055: OR
6056: IFFALSE 6068
// result := true else
6058: LD_ADDR_VAR 0 4
6062: PUSH
6063: LD_INT 1
6065: ST_TO_ADDR
6066: GO 6076
// result := false ;
6068: LD_ADDR_VAR 0 4
6072: PUSH
6073: LD_INT 0
6075: ST_TO_ADDR
// end ;
6076: LD_VAR 0 4
6080: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
6081: LD_INT 0
6083: PPUSH
6084: PPUSH
// area = ListEnvironmentArea ( area ) ;
6085: LD_ADDR_VAR 0 2
6089: PUSH
6090: LD_VAR 0 2
6094: PPUSH
6095: CALL_OW 353
6099: ST_TO_ADDR
// if bulldozer > 0 then
6100: LD_VAR 0 1
6104: PUSH
6105: LD_INT 0
6107: GREATER
6108: IFFALSE 6219
// for i = 1 to area do
6110: LD_ADDR_VAR 0 4
6114: PUSH
6115: DOUBLE
6116: LD_INT 1
6118: DEC
6119: ST_TO_ADDR
6120: LD_VAR 0 2
6124: PUSH
6125: FOR_TO
6126: IFFALSE 6217
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
6128: LD_VAR 0 2
6132: PUSH
6133: LD_VAR 0 4
6137: ARRAY
6138: PUSH
6139: LD_INT 1
6141: ARRAY
6142: PPUSH
6143: LD_VAR 0 2
6147: PUSH
6148: LD_VAR 0 4
6152: ARRAY
6153: PUSH
6154: LD_INT 2
6156: ARRAY
6157: PPUSH
6158: CALL_OW 351
6162: IFFALSE 6215
// if not HasTask ( bulldozer ) then
6164: LD_VAR 0 1
6168: PPUSH
6169: CALL_OW 314
6173: NOT
6174: IFFALSE 6215
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
6176: LD_VAR 0 1
6180: PPUSH
6181: LD_VAR 0 2
6185: PUSH
6186: LD_VAR 0 4
6190: ARRAY
6191: PUSH
6192: LD_INT 1
6194: ARRAY
6195: PPUSH
6196: LD_VAR 0 2
6200: PUSH
6201: LD_VAR 0 4
6205: ARRAY
6206: PUSH
6207: LD_INT 2
6209: ARRAY
6210: PPUSH
6211: CALL_OW 171
6215: GO 6125
6217: POP
6218: POP
// end ;
6219: LD_VAR 0 3
6223: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
6224: LD_INT 0
6226: PPUSH
6227: PPUSH
6228: PPUSH
// pom := GetBase ( bdepot ) ;
6229: LD_ADDR_VAR 0 4
6233: PUSH
6234: LD_VAR 0 1
6238: PPUSH
6239: CALL_OW 274
6243: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
6244: LD_ADDR_VAR 0 5
6248: PUSH
6249: LD_VAR 0 2
6253: PPUSH
6254: LD_VAR 0 1
6258: PPUSH
6259: CALL_OW 248
6263: PPUSH
6264: CALL_OW 450
6268: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
6269: LD_VAR 0 4
6273: PPUSH
6274: LD_INT 1
6276: PPUSH
6277: CALL_OW 275
6281: PUSH
6282: LD_VAR 0 5
6286: PUSH
6287: LD_INT 1
6289: ARRAY
6290: GREATEREQUAL
6291: PUSH
6292: LD_VAR 0 4
6296: PPUSH
6297: LD_INT 3
6299: PPUSH
6300: CALL_OW 275
6304: PUSH
6305: LD_VAR 0 5
6309: PUSH
6310: LD_INT 3
6312: ARRAY
6313: GREATEREQUAL
6314: AND
6315: IFFALSE 6327
// result := true else
6317: LD_ADDR_VAR 0 3
6321: PUSH
6322: LD_INT 1
6324: ST_TO_ADDR
6325: GO 6335
// result := false ;
6327: LD_ADDR_VAR 0 3
6331: PUSH
6332: LD_INT 0
6334: ST_TO_ADDR
// end ;
6335: LD_VAR 0 3
6339: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
6340: LD_INT 0
6342: PPUSH
6343: PPUSH
6344: PPUSH
// pom := GetBase ( bdepot ) ;
6345: LD_ADDR_VAR 0 3
6349: PUSH
6350: LD_VAR 0 1
6354: PPUSH
6355: CALL_OW 274
6359: ST_TO_ADDR
// sor := [ ] ;
6360: LD_ADDR_VAR 0 4
6364: PUSH
6365: EMPTY
6366: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
6367: LD_ADDR_VAR 0 4
6371: PUSH
6372: LD_VAR 0 4
6376: PUSH
6377: LD_VAR 0 3
6381: PPUSH
6382: LD_INT 1
6384: PPUSH
6385: CALL_OW 275
6389: ADD
6390: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
6391: LD_ADDR_VAR 0 4
6395: PUSH
6396: LD_VAR 0 4
6400: PUSH
6401: LD_VAR 0 3
6405: PPUSH
6406: LD_INT 2
6408: PPUSH
6409: CALL_OW 275
6413: ADD
6414: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
6415: LD_ADDR_VAR 0 4
6419: PUSH
6420: LD_VAR 0 4
6424: PUSH
6425: LD_VAR 0 3
6429: PPUSH
6430: LD_INT 3
6432: PPUSH
6433: CALL_OW 275
6437: ADD
6438: ST_TO_ADDR
// result := sor ;
6439: LD_ADDR_VAR 0 2
6443: PUSH
6444: LD_VAR 0 4
6448: ST_TO_ADDR
// end ;
6449: LD_VAR 0 2
6453: RET
// export function Hex ( x , y ) ; begin
6454: LD_INT 0
6456: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
6457: LD_VAR 0 1
6461: PPUSH
6462: LD_VAR 0 2
6466: PPUSH
6467: CALL_OW 488
6471: PUSH
6472: LD_VAR 0 1
6476: PPUSH
6477: LD_VAR 0 2
6481: PPUSH
6482: CALL_OW 428
6486: PUSH
6487: LD_INT 0
6489: EQUAL
6490: AND
6491: IFFALSE 6503
// result := true else
6493: LD_ADDR_VAR 0 3
6497: PUSH
6498: LD_INT 1
6500: ST_TO_ADDR
6501: GO 6511
// result := false ;
6503: LD_ADDR_VAR 0 3
6507: PUSH
6508: LD_INT 0
6510: ST_TO_ADDR
// end ;
6511: LD_VAR 0 3
6515: RET
// export function NeedBuilding ( side , btype ) ; begin
6516: LD_INT 0
6518: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
6519: LD_INT 22
6521: PUSH
6522: LD_VAR 0 1
6526: PUSH
6527: EMPTY
6528: LIST
6529: LIST
6530: PUSH
6531: LD_INT 30
6533: PUSH
6534: LD_VAR 0 2
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: PUSH
6543: LD_INT 3
6545: PUSH
6546: LD_INT 57
6548: PUSH
6549: EMPTY
6550: LIST
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: PPUSH
6561: CALL_OW 69
6565: PUSH
6566: LD_INT 0
6568: EQUAL
6569: IFFALSE 6581
// result := true else
6571: LD_ADDR_VAR 0 3
6575: PUSH
6576: LD_INT 1
6578: ST_TO_ADDR
6579: GO 6589
// result := false ;
6581: LD_ADDR_VAR 0 3
6585: PUSH
6586: LD_INT 0
6588: ST_TO_ADDR
// end ;
6589: LD_VAR 0 3
6593: RET
// export function NeedBase ( side ) ; begin
6594: LD_INT 0
6596: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6597: LD_VAR 0 1
6601: PPUSH
6602: LD_INT 0
6604: PPUSH
6605: CALL 6516 0 2
6609: PUSH
6610: LD_VAR 0 1
6614: PPUSH
6615: LD_INT 1
6617: PPUSH
6618: CALL 6516 0 2
6622: AND
6623: IFFALSE 6635
// result := true else
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: LD_INT 1
6632: ST_TO_ADDR
6633: GO 6643
// result := false ;
6635: LD_ADDR_VAR 0 2
6639: PUSH
6640: LD_INT 0
6642: ST_TO_ADDR
// end ;
6643: LD_VAR 0 2
6647: RET
// export function MyBase ( side ) ; begin
6648: LD_INT 0
6650: PPUSH
// if not NeedBase ( side ) then
6651: LD_VAR 0 1
6655: PPUSH
6656: CALL 6594 0 1
6660: NOT
6661: IFFALSE 6726
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6663: LD_ADDR_VAR 0 2
6667: PUSH
6668: LD_INT 22
6670: PUSH
6671: LD_VAR 0 1
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 2
6682: PUSH
6683: LD_INT 30
6685: PUSH
6686: LD_INT 0
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: PUSH
6693: LD_INT 30
6695: PUSH
6696: LD_INT 1
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PUSH
6712: EMPTY
6713: LIST
6714: PPUSH
6715: CALL_OW 69
6719: PUSH
6720: LD_INT 1
6722: ARRAY
6723: ST_TO_ADDR
6724: GO 6734
// result := false ;
6726: LD_ADDR_VAR 0 2
6730: PUSH
6731: LD_INT 0
6733: ST_TO_ADDR
// end ;
6734: LD_VAR 0 2
6738: RET
// export function GetBuilding ( side , btype ) ; begin
6739: LD_INT 0
6741: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6742: LD_INT 22
6744: PUSH
6745: LD_VAR 0 1
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 30
6756: PUSH
6757: LD_VAR 0 2
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: PPUSH
6770: CALL_OW 69
6774: PUSH
6775: LD_INT 0
6777: GREATER
6778: IFFALSE 6820
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6780: LD_ADDR_VAR 0 3
6784: PUSH
6785: LD_INT 22
6787: PUSH
6788: LD_VAR 0 1
6792: PUSH
6793: EMPTY
6794: LIST
6795: LIST
6796: PUSH
6797: LD_INT 30
6799: PUSH
6800: LD_VAR 0 2
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: PUSH
6809: EMPTY
6810: LIST
6811: LIST
6812: PPUSH
6813: CALL_OW 69
6817: ST_TO_ADDR
6818: GO 6828
// result := false ;
6820: LD_ADDR_VAR 0 3
6824: PUSH
6825: LD_INT 0
6827: ST_TO_ADDR
// end ;
6828: LD_VAR 0 3
6832: RET
// export function GetCrates ( side ) ; begin
6833: LD_INT 0
6835: PPUSH
// if MyBase ( side ) then
6836: LD_VAR 0 1
6840: PPUSH
6841: CALL 6648 0 1
6845: IFFALSE 6877
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
6847: LD_ADDR_VAR 0 2
6851: PUSH
6852: LD_VAR 0 1
6856: PPUSH
6857: CALL 6648 0 1
6861: PPUSH
6862: CALL_OW 274
6866: PPUSH
6867: LD_INT 1
6869: PPUSH
6870: CALL_OW 275
6874: ST_TO_ADDR
6875: GO 6885
// result := false ;
6877: LD_ADDR_VAR 0 2
6881: PUSH
6882: LD_INT 0
6884: ST_TO_ADDR
// end ;
6885: LD_VAR 0 2
6889: RET
// export function GetLabs ( side ) ; begin
6890: LD_INT 0
6892: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6893: LD_ADDR_VAR 0 2
6897: PUSH
6898: LD_INT 22
6900: PUSH
6901: LD_VAR 0 1
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: PUSH
6910: LD_INT 2
6912: PUSH
6913: LD_INT 30
6915: PUSH
6916: LD_INT 6
6918: PUSH
6919: EMPTY
6920: LIST
6921: LIST
6922: PUSH
6923: LD_INT 30
6925: PUSH
6926: LD_INT 8
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PUSH
6933: LD_INT 30
6935: PUSH
6936: LD_INT 7
6938: PUSH
6939: EMPTY
6940: LIST
6941: LIST
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: LIST
6947: LIST
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: PUSH
6953: EMPTY
6954: LIST
6955: PPUSH
6956: CALL_OW 69
6960: ST_TO_ADDR
// end ;
6961: LD_VAR 0 2
6965: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
6966: LD_INT 0
6968: PPUSH
6969: PPUSH
6970: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
6971: LD_ADDR_VAR 0 3
6975: PUSH
6976: LD_VAR 0 1
6980: PPUSH
6981: LD_INT 1
6983: PPUSH
6984: CALL_OW 268
6988: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
6989: LD_ADDR_VAR 0 4
6993: PUSH
6994: LD_VAR 0 1
6998: PPUSH
6999: LD_INT 2
7001: PPUSH
7002: CALL_OW 268
7006: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
7007: LD_ADDR_VAR 0 2
7011: PUSH
7012: LD_VAR 0 3
7016: PUSH
7017: LD_VAR 0 4
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: ST_TO_ADDR
// end ;
7026: LD_VAR 0 2
7030: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
7031: LD_INT 0
7033: PPUSH
7034: PPUSH
// result := false ;
7035: LD_ADDR_VAR 0 3
7039: PUSH
7040: LD_INT 0
7042: ST_TO_ADDR
// for i = 1 to tlist do
7043: LD_ADDR_VAR 0 4
7047: PUSH
7048: DOUBLE
7049: LD_INT 1
7051: DEC
7052: ST_TO_ADDR
7053: LD_VAR 0 2
7057: PUSH
7058: FOR_TO
7059: IFFALSE 7099
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7061: LD_VAR 0 2
7065: PUSH
7066: LD_VAR 0 4
7070: ARRAY
7071: PPUSH
7072: LD_VAR 0 1
7076: PPUSH
7077: CALL_OW 321
7081: PUSH
7082: LD_INT 2
7084: NONEQUAL
7085: IFFALSE 7097
// begin result := true ;
7087: LD_ADDR_VAR 0 3
7091: PUSH
7092: LD_INT 1
7094: ST_TO_ADDR
// break ;
7095: GO 7099
// end ;
7097: GO 7058
7099: POP
7100: POP
// end ;
7101: LD_VAR 0 3
7105: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
7106: LD_INT 0
7108: PPUSH
7109: PPUSH
7110: PPUSH
7111: PPUSH
7112: PPUSH
7113: PPUSH
7114: PPUSH
7115: PPUSH
// lab := GetLabs ( side ) ;
7116: LD_ADDR_VAR 0 5
7120: PUSH
7121: LD_VAR 0 1
7125: PPUSH
7126: CALL 6890 0 1
7130: ST_TO_ADDR
// tmp := 0 ;
7131: LD_ADDR_VAR 0 7
7135: PUSH
7136: LD_INT 0
7138: ST_TO_ADDR
// list := [ ] ;
7139: LD_ADDR_VAR 0 8
7143: PUSH
7144: EMPTY
7145: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
7146: LD_ADDR_VAR 0 10
7150: PUSH
7151: LD_INT 35
7153: PUSH
7154: LD_INT 45
7156: PUSH
7157: LD_INT 46
7159: PUSH
7160: LD_INT 47
7162: PUSH
7163: LD_INT 1
7165: PUSH
7166: LD_INT 2
7168: PUSH
7169: LD_INT 48
7171: PUSH
7172: LD_INT 49
7174: PUSH
7175: LD_INT 50
7177: PUSH
7178: LD_INT 20
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: LIST
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: LIST
7191: LIST
7192: ST_TO_ADDR
// for i = 1 to tlist do
7193: LD_ADDR_VAR 0 4
7197: PUSH
7198: DOUBLE
7199: LD_INT 1
7201: DEC
7202: ST_TO_ADDR
7203: LD_VAR 0 2
7207: PUSH
7208: FOR_TO
7209: IFFALSE 7261
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7211: LD_VAR 0 2
7215: PUSH
7216: LD_VAR 0 4
7220: ARRAY
7221: PPUSH
7222: LD_VAR 0 1
7226: PPUSH
7227: CALL_OW 321
7231: PUSH
7232: LD_INT 2
7234: NONEQUAL
7235: IFFALSE 7259
// list := list ^ tlist [ i ] ;
7237: LD_ADDR_VAR 0 8
7241: PUSH
7242: LD_VAR 0 8
7246: PUSH
7247: LD_VAR 0 2
7251: PUSH
7252: LD_VAR 0 4
7256: ARRAY
7257: ADD
7258: ST_TO_ADDR
7259: GO 7208
7261: POP
7262: POP
// if list then
7263: LD_VAR 0 8
7267: IFFALSE 7432
// begin for i = 1 to lab do
7269: LD_ADDR_VAR 0 4
7273: PUSH
7274: DOUBLE
7275: LD_INT 1
7277: DEC
7278: ST_TO_ADDR
7279: LD_VAR 0 5
7283: PUSH
7284: FOR_TO
7285: IFFALSE 7355
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
7287: LD_VAR 0 8
7291: PUSH
7292: LD_INT 1
7294: ARRAY
7295: PUSH
7296: LD_VAR 0 10
7300: IN
7301: PUSH
7302: LD_VAR 0 8
7306: PUSH
7307: LD_INT 1
7309: ARRAY
7310: PPUSH
7311: CALL_OW 481
7315: PUSH
7316: LD_VAR 0 5
7320: PUSH
7321: LD_VAR 0 4
7325: ARRAY
7326: PPUSH
7327: CALL 6966 0 1
7331: IN
7332: OR
7333: IFFALSE 7353
// begin mylab := lab [ i ] ;
7335: LD_ADDR_VAR 0 9
7339: PUSH
7340: LD_VAR 0 5
7344: PUSH
7345: LD_VAR 0 4
7349: ARRAY
7350: ST_TO_ADDR
// break ;
7351: GO 7355
// end ;
7353: GO 7284
7355: POP
7356: POP
// if mylab then
7357: LD_VAR 0 9
7361: IFFALSE 7422
// begin if BuildingStatus ( mylab ) = bs_idle then
7363: LD_VAR 0 9
7367: PPUSH
7368: CALL_OW 461
7372: PUSH
7373: LD_INT 2
7375: EQUAL
7376: IFFALSE 7420
// for i = 1 to list do
7378: LD_ADDR_VAR 0 4
7382: PUSH
7383: DOUBLE
7384: LD_INT 1
7386: DEC
7387: ST_TO_ADDR
7388: LD_VAR 0 8
7392: PUSH
7393: FOR_TO
7394: IFFALSE 7418
// AddComResearch ( mylab , list [ i ] ) ;
7396: LD_VAR 0 9
7400: PPUSH
7401: LD_VAR 0 8
7405: PUSH
7406: LD_VAR 0 4
7410: ARRAY
7411: PPUSH
7412: CALL_OW 184
7416: GO 7393
7418: POP
7419: POP
// end else
7420: GO 7430
// result := false ;
7422: LD_ADDR_VAR 0 3
7426: PUSH
7427: LD_INT 0
7429: ST_TO_ADDR
// end else
7430: GO 7440
// result := false ;
7432: LD_ADDR_VAR 0 3
7436: PUSH
7437: LD_INT 0
7439: ST_TO_ADDR
// end ;
7440: LD_VAR 0 3
7444: RET
// export function GetTowers ( side ) ; begin
7445: LD_INT 0
7447: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
7448: LD_ADDR_VAR 0 2
7452: PUSH
7453: LD_INT 22
7455: PUSH
7456: LD_VAR 0 1
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: LD_INT 2
7467: PUSH
7468: LD_INT 30
7470: PUSH
7471: LD_INT 32
7473: PUSH
7474: EMPTY
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 30
7480: PUSH
7481: LD_INT 33
7483: PUSH
7484: EMPTY
7485: LIST
7486: LIST
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: LIST
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PPUSH
7497: CALL_OW 69
7501: ST_TO_ADDR
// end ;
7502: LD_VAR 0 2
7506: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
7507: LD_INT 0
7509: PPUSH
7510: PPUSH
// if Hex ( x , y ) then
7511: LD_VAR 0 2
7515: PPUSH
7516: LD_VAR 0 3
7520: PPUSH
7521: CALL 6454 0 2
7525: IFFALSE 7600
// for i = 1 to plist do
7527: LD_ADDR_VAR 0 6
7531: PUSH
7532: DOUBLE
7533: LD_INT 1
7535: DEC
7536: ST_TO_ADDR
7537: LD_VAR 0 1
7541: PUSH
7542: FOR_TO
7543: IFFALSE 7598
// if not HasTask ( plist [ i ] ) then
7545: LD_VAR 0 1
7549: PUSH
7550: LD_VAR 0 6
7554: ARRAY
7555: PPUSH
7556: CALL_OW 314
7560: NOT
7561: IFFALSE 7596
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
7563: LD_VAR 0 1
7567: PUSH
7568: LD_VAR 0 6
7572: ARRAY
7573: PPUSH
7574: LD_INT 0
7576: PPUSH
7577: LD_VAR 0 2
7581: PPUSH
7582: LD_VAR 0 3
7586: PPUSH
7587: LD_VAR 0 4
7591: PPUSH
7592: CALL_OW 145
7596: GO 7542
7598: POP
7599: POP
// end ;
7600: LD_VAR 0 5
7604: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7605: LD_INT 0
7607: PPUSH
7608: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7609: LD_VAR 0 2
7613: PPUSH
7614: CALL_OW 266
7618: PUSH
7619: LD_INT 0
7621: EQUAL
7622: PUSH
7623: LD_VAR 0 2
7627: PPUSH
7628: LD_INT 1
7630: PPUSH
7631: CALL 6224 0 2
7635: AND
7636: PUSH
7637: LD_VAR 0 1
7641: PUSH
7642: LD_INT 1
7644: ARRAY
7645: PPUSH
7646: CALL_OW 255
7650: PPUSH
7651: CALL_OW 345
7655: NOT
7656: AND
7657: IFFALSE 7753
// begin ComUpgrade ( bident ) ;
7659: LD_VAR 0 2
7663: PPUSH
7664: CALL_OW 146
// for i = 1 to plist do
7668: LD_ADDR_VAR 0 4
7672: PUSH
7673: DOUBLE
7674: LD_INT 1
7676: DEC
7677: ST_TO_ADDR
7678: LD_VAR 0 1
7682: PUSH
7683: FOR_TO
7684: IFFALSE 7741
// if not HasTask ( plist [ i ] ) then
7686: LD_VAR 0 1
7690: PUSH
7691: LD_VAR 0 4
7695: ARRAY
7696: PPUSH
7697: CALL_OW 314
7701: NOT
7702: IFFALSE 7739
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7704: LD_VAR 0 1
7708: PUSH
7709: LD_VAR 0 4
7713: ARRAY
7714: PPUSH
7715: LD_VAR 0 2
7719: PPUSH
7720: CALL_OW 250
7724: PPUSH
7725: LD_VAR 0 2
7729: PPUSH
7730: CALL_OW 251
7734: PPUSH
7735: CALL_OW 111
7739: GO 7683
7741: POP
7742: POP
// result := true ;
7743: LD_ADDR_VAR 0 3
7747: PUSH
7748: LD_INT 1
7750: ST_TO_ADDR
// end else
7751: GO 7761
// result := false ;
7753: LD_ADDR_VAR 0 3
7757: PUSH
7758: LD_INT 0
7760: ST_TO_ADDR
// end ;
7761: LD_VAR 0 3
7765: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7766: LD_INT 0
7768: PPUSH
7769: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7770: LD_VAR 0 1
7774: PUSH
7775: LD_INT 1
7777: ARRAY
7778: PPUSH
7779: CALL_OW 255
7783: PPUSH
7784: CALL 6833 0 1
7788: PUSH
7789: LD_INT 20
7791: GREATEREQUAL
7792: PUSH
7793: LD_VAR 0 2
7797: PPUSH
7798: LD_VAR 0 3
7802: PPUSH
7803: CALL 6454 0 2
7807: AND
7808: IFFALSE 7893
// begin for i = 1 to plist do
7810: LD_ADDR_VAR 0 6
7814: PUSH
7815: DOUBLE
7816: LD_INT 1
7818: DEC
7819: ST_TO_ADDR
7820: LD_VAR 0 1
7824: PUSH
7825: FOR_TO
7826: IFFALSE 7881
// if not HasTask ( plist [ i ] ) then
7828: LD_VAR 0 1
7832: PUSH
7833: LD_VAR 0 6
7837: ARRAY
7838: PPUSH
7839: CALL_OW 314
7843: NOT
7844: IFFALSE 7879
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7846: LD_VAR 0 1
7850: PUSH
7851: LD_VAR 0 6
7855: ARRAY
7856: PPUSH
7857: LD_INT 6
7859: PPUSH
7860: LD_VAR 0 2
7864: PPUSH
7865: LD_VAR 0 3
7869: PPUSH
7870: LD_VAR 0 4
7874: PPUSH
7875: CALL_OW 145
7879: GO 7825
7881: POP
7882: POP
// result := true ;
7883: LD_ADDR_VAR 0 5
7887: PUSH
7888: LD_INT 1
7890: ST_TO_ADDR
// end else
7891: GO 7901
// result := false ;
7893: LD_ADDR_VAR 0 5
7897: PUSH
7898: LD_INT 0
7900: ST_TO_ADDR
// end ;
7901: LD_VAR 0 5
7905: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7906: LD_INT 0
7908: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7909: LD_VAR 0 1
7913: PPUSH
7914: LD_INT 1
7916: PPUSH
7917: CALL_OW 268
7921: PUSH
7922: LD_INT 9
7924: EQUAL
7925: PUSH
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 2
7933: PPUSH
7934: CALL_OW 268
7938: PUSH
7939: LD_INT 9
7941: EQUAL
7942: AND
7943: IFFALSE 8040
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7945: LD_VAR 0 1
7949: PPUSH
7950: LD_VAR 0 2
7954: PPUSH
7955: CALL 6224 0 2
7959: PUSH
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 3
7969: PPUSH
7970: CALL 6224 0 2
7974: AND
7975: PUSH
7976: LD_VAR 0 1
7980: PPUSH
7981: CALL_OW 461
7985: PUSH
7986: LD_INT 2
7988: EQUAL
7989: AND
7990: IFFALSE 8030
// begin ComUpgradeLab ( lab , bkind1 ) ;
7992: LD_VAR 0 1
7996: PPUSH
7997: LD_VAR 0 2
8001: PPUSH
8002: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
8006: LD_VAR 0 1
8010: PPUSH
8011: LD_VAR 0 3
8015: PPUSH
8016: CALL_OW 207
// result := true ;
8020: LD_ADDR_VAR 0 4
8024: PUSH
8025: LD_INT 1
8027: ST_TO_ADDR
// end else
8028: GO 8038
// result := false ;
8030: LD_ADDR_VAR 0 4
8034: PUSH
8035: LD_INT 0
8037: ST_TO_ADDR
// end else
8038: GO 8048
// result := false ;
8040: LD_ADDR_VAR 0 4
8044: PUSH
8045: LD_INT 0
8047: ST_TO_ADDR
// end ;
8048: LD_VAR 0 4
8052: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
8053: LD_INT 0
8055: PPUSH
8056: PPUSH
8057: PPUSH
8058: PPUSH
8059: PPUSH
// p := 1 ;
8060: LD_ADDR_VAR 0 6
8064: PUSH
8065: LD_INT 1
8067: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
8068: LD_ADDR_VAR 0 4
8072: PUSH
8073: DOUBLE
8074: LD_INT 1
8076: DEC
8077: ST_TO_ADDR
8078: LD_VAR 0 2
8082: PUSH
8083: LD_INT 4
8085: DIVREAL
8086: PUSH
8087: FOR_TO
8088: IFFALSE 8337
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
8090: LD_VAR 0 2
8094: PUSH
8095: LD_VAR 0 6
8099: PUSH
8100: LD_INT 1
8102: PLUS
8103: ARRAY
8104: PPUSH
8105: LD_VAR 0 2
8109: PUSH
8110: LD_VAR 0 6
8114: PUSH
8115: LD_INT 2
8117: PLUS
8118: ARRAY
8119: PPUSH
8120: CALL_OW 428
8124: PUSH
8125: LD_INT 0
8127: EQUAL
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: LD_VAR 0 6
8138: PUSH
8139: LD_INT 1
8141: PLUS
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 2
8148: PUSH
8149: LD_VAR 0 6
8153: PUSH
8154: LD_INT 2
8156: PLUS
8157: ARRAY
8158: PPUSH
8159: CALL 6454 0 2
8163: AND
8164: PUSH
8165: LD_VAR 0 1
8169: PUSH
8170: LD_INT 1
8172: ARRAY
8173: PPUSH
8174: CALL_OW 255
8178: PPUSH
8179: CALL 6833 0 1
8183: PUSH
8184: LD_INT 20
8186: GREATEREQUAL
8187: AND
8188: IFFALSE 8305
// begin for c = 1 to plist do
8190: LD_ADDR_VAR 0 7
8194: PUSH
8195: DOUBLE
8196: LD_INT 1
8198: DEC
8199: ST_TO_ADDR
8200: LD_VAR 0 1
8204: PUSH
8205: FOR_TO
8206: IFFALSE 8299
// if not HasTask ( plist [ c ] ) then
8208: LD_VAR 0 1
8212: PUSH
8213: LD_VAR 0 7
8217: ARRAY
8218: PPUSH
8219: CALL_OW 314
8223: NOT
8224: IFFALSE 8297
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
8226: LD_VAR 0 1
8230: PUSH
8231: LD_VAR 0 7
8235: ARRAY
8236: PPUSH
8237: LD_VAR 0 2
8241: PUSH
8242: LD_VAR 0 6
8246: ARRAY
8247: PPUSH
8248: LD_VAR 0 2
8252: PUSH
8253: LD_VAR 0 6
8257: PUSH
8258: LD_INT 1
8260: PLUS
8261: ARRAY
8262: PPUSH
8263: LD_VAR 0 2
8267: PUSH
8268: LD_VAR 0 6
8272: PUSH
8273: LD_INT 2
8275: PLUS
8276: ARRAY
8277: PPUSH
8278: LD_VAR 0 2
8282: PUSH
8283: LD_VAR 0 6
8287: PUSH
8288: LD_INT 3
8290: PLUS
8291: ARRAY
8292: PPUSH
8293: CALL_OW 145
8297: GO 8205
8299: POP
8300: POP
// break ;
8301: GO 8337
// end else
8303: GO 8335
// if ( p + 4 < tlist ) then
8305: LD_VAR 0 6
8309: PUSH
8310: LD_INT 4
8312: PLUS
8313: PUSH
8314: LD_VAR 0 2
8318: LESS
8319: IFFALSE 8335
// p := p + 4 ;
8321: LD_ADDR_VAR 0 6
8325: PUSH
8326: LD_VAR 0 6
8330: PUSH
8331: LD_INT 4
8333: PLUS
8334: ST_TO_ADDR
// end ;
8335: GO 8087
8337: POP
8338: POP
// end ;
8339: LD_VAR 0 3
8343: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
8344: LD_INT 0
8346: PPUSH
8347: PPUSH
8348: PPUSH
8349: PPUSH
// tmp := GetTowers ( side ) ;
8350: LD_ADDR_VAR 0 5
8354: PUSH
8355: LD_VAR 0 1
8359: PPUSH
8360: CALL 7445 0 1
8364: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
8365: LD_ADDR_VAR 0 6
8369: PUSH
8370: LD_VAR 0 1
8374: PPUSH
8375: LD_INT 3
8377: PPUSH
8378: CALL 6739 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: ST_TO_ADDR
// if fac then
8387: LD_VAR 0 6
8391: IFFALSE 8487
// for i = 1 to tmp do
8393: LD_ADDR_VAR 0 4
8397: PUSH
8398: DOUBLE
8399: LD_INT 1
8401: DEC
8402: ST_TO_ADDR
8403: LD_VAR 0 5
8407: PUSH
8408: FOR_TO
8409: IFFALSE 8485
// if GetBWeapon ( tmp [ i ] ) = 0 then
8411: LD_VAR 0 5
8415: PUSH
8416: LD_VAR 0 4
8420: ARRAY
8421: PPUSH
8422: CALL_OW 269
8426: PUSH
8427: LD_INT 0
8429: EQUAL
8430: IFFALSE 8483
// begin if BuildingStatus ( fac ) = bs_idle then
8432: LD_VAR 0 6
8436: PPUSH
8437: CALL_OW 461
8441: PUSH
8442: LD_INT 2
8444: EQUAL
8445: IFFALSE 8481
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
8447: LD_VAR 0 5
8451: PUSH
8452: LD_VAR 0 4
8456: ARRAY
8457: PPUSH
8458: LD_VAR 0 2
8462: PUSH
8463: LD_INT 1
8465: PPUSH
8466: LD_VAR 0 2
8470: PPUSH
8471: CALL_OW 12
8475: ARRAY
8476: PPUSH
8477: CALL_OW 148
// break ;
8481: GO 8485
// end ;
8483: GO 8408
8485: POP
8486: POP
// end ;
8487: LD_VAR 0 3
8491: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
8492: LD_INT 0
8494: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
8495: LD_INT 22
8497: PUSH
8498: LD_VAR 0 1
8502: PUSH
8503: EMPTY
8504: LIST
8505: LIST
8506: PUSH
8507: LD_INT 34
8509: PUSH
8510: LD_VAR 0 3
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: PUSH
8519: LD_INT 31
8521: PUSH
8522: LD_VAR 0 2
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: LIST
8535: PUSH
8536: EMPTY
8537: LIST
8538: PPUSH
8539: CALL_OW 69
8543: IFFALSE 8601
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
8545: LD_ADDR_VAR 0 4
8549: PUSH
8550: LD_INT 22
8552: PUSH
8553: LD_VAR 0 1
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PUSH
8562: LD_INT 34
8564: PUSH
8565: LD_VAR 0 3
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: PUSH
8574: LD_INT 31
8576: PUSH
8577: LD_VAR 0 2
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: EMPTY
8592: LIST
8593: PPUSH
8594: CALL_OW 69
8598: ST_TO_ADDR
8599: GO 8609
// result := false ;
8601: LD_ADDR_VAR 0 4
8605: PUSH
8606: LD_INT 0
8608: ST_TO_ADDR
// end ;
8609: LD_VAR 0 4
8613: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8614: LD_INT 0
8616: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8617: LD_VAR 0 1
8621: PPUSH
8622: LD_VAR 0 2
8626: PPUSH
8627: LD_VAR 0 3
8631: PPUSH
8632: LD_VAR 0 4
8636: PPUSH
8637: LD_VAR 0 5
8641: PPUSH
8642: CALL_OW 448
8646: PUSH
8647: LD_VAR 0 2
8651: PPUSH
8652: LD_VAR 0 3
8656: PPUSH
8657: LD_VAR 0 4
8661: PPUSH
8662: LD_VAR 0 5
8666: PPUSH
8667: CALL_OW 449
8671: PUSH
8672: LD_INT 1
8674: ARRAY
8675: PUSH
8676: LD_VAR 0 1
8680: PPUSH
8681: CALL 6340 0 1
8685: PUSH
8686: LD_INT 1
8688: ARRAY
8689: LESSEQUAL
8690: AND
8691: PUSH
8692: LD_VAR 0 2
8696: PPUSH
8697: LD_VAR 0 3
8701: PPUSH
8702: LD_VAR 0 4
8706: PPUSH
8707: LD_VAR 0 5
8711: PPUSH
8712: CALL_OW 449
8716: PUSH
8717: LD_INT 2
8719: ARRAY
8720: PUSH
8721: LD_VAR 0 1
8725: PPUSH
8726: CALL 6340 0 1
8730: PUSH
8731: LD_INT 2
8733: ARRAY
8734: LESSEQUAL
8735: AND
8736: PUSH
8737: LD_VAR 0 2
8741: PPUSH
8742: LD_VAR 0 3
8746: PPUSH
8747: LD_VAR 0 4
8751: PPUSH
8752: LD_VAR 0 5
8756: PPUSH
8757: CALL_OW 449
8761: PUSH
8762: LD_INT 3
8764: ARRAY
8765: PUSH
8766: LD_VAR 0 1
8770: PPUSH
8771: CALL 6340 0 1
8775: PUSH
8776: LD_INT 3
8778: ARRAY
8779: LESSEQUAL
8780: AND
8781: IFFALSE 8828
// begin if debug then
8783: LD_EXP 1
8787: IFFALSE 8797
// display_strings := Factory work! ;
8789: LD_ADDR_OWVAR 47
8793: PUSH
8794: LD_STRING Factory work!
8796: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8797: LD_VAR 0 1
8801: PPUSH
8802: LD_VAR 0 2
8806: PPUSH
8807: LD_VAR 0 3
8811: PPUSH
8812: LD_VAR 0 4
8816: PPUSH
8817: LD_VAR 0 5
8821: PPUSH
8822: CALL_OW 125
// end else
8826: GO 8836
// result := false ;
8828: LD_ADDR_VAR 0 6
8832: PUSH
8833: LD_INT 0
8835: ST_TO_ADDR
// end ;
8836: LD_VAR 0 6
8840: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8841: LD_INT 0
8843: PPUSH
8844: PPUSH
8845: PPUSH
8846: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8847: LD_ADDR_VAR 0 6
8851: PUSH
8852: LD_INT 22
8854: PUSH
8855: LD_VAR 0 1
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: LD_INT 30
8866: PUSH
8867: LD_VAR 0 2
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PPUSH
8880: CALL_OW 69
8884: ST_TO_ADDR
// tmp := [ ] ;
8885: LD_ADDR_VAR 0 5
8889: PUSH
8890: EMPTY
8891: ST_TO_ADDR
// for i = 1 to filter do
8892: LD_ADDR_VAR 0 4
8896: PUSH
8897: DOUBLE
8898: LD_INT 1
8900: DEC
8901: ST_TO_ADDR
8902: LD_VAR 0 6
8906: PUSH
8907: FOR_TO
8908: IFFALSE 8996
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8910: LD_ADDR_VAR 0 5
8914: PUSH
8915: LD_VAR 0 5
8919: PUSH
8920: LD_VAR 0 6
8924: PUSH
8925: LD_VAR 0 4
8929: ARRAY
8930: PPUSH
8931: CALL_OW 266
8935: PUSH
8936: LD_VAR 0 6
8940: PUSH
8941: LD_VAR 0 4
8945: ARRAY
8946: PPUSH
8947: CALL_OW 250
8951: PUSH
8952: LD_VAR 0 6
8956: PUSH
8957: LD_VAR 0 4
8961: ARRAY
8962: PPUSH
8963: CALL_OW 251
8967: PUSH
8968: LD_VAR 0 6
8972: PUSH
8973: LD_VAR 0 4
8977: ARRAY
8978: PPUSH
8979: CALL_OW 254
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: LIST
8988: LIST
8989: PUSH
8990: EMPTY
8991: LIST
8992: ADD
8993: ST_TO_ADDR
// end ;
8994: GO 8907
8996: POP
8997: POP
// result := tmp ;
8998: LD_ADDR_VAR 0 3
9002: PUSH
9003: LD_VAR 0 5
9007: ST_TO_ADDR
// end ;
9008: LD_VAR 0 3
9012: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
9013: LD_INT 0
9015: PPUSH
9016: PPUSH
9017: PPUSH
// for i = 1 to list do
9018: LD_ADDR_VAR 0 4
9022: PUSH
9023: DOUBLE
9024: LD_INT 1
9026: DEC
9027: ST_TO_ADDR
9028: LD_VAR 0 2
9032: PUSH
9033: FOR_TO
9034: IFFALSE 9589
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
9036: LD_VAR 0 2
9040: PUSH
9041: LD_VAR 0 4
9045: ARRAY
9046: PUSH
9047: LD_INT 1
9049: ARRAY
9050: PPUSH
9051: LD_VAR 0 2
9055: PUSH
9056: LD_VAR 0 4
9060: ARRAY
9061: PUSH
9062: LD_INT 2
9064: ARRAY
9065: PPUSH
9066: CALL_OW 428
9070: PUSH
9071: LD_INT 0
9073: GREATER
9074: IFFALSE 9360
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
9076: LD_VAR 0 2
9080: PUSH
9081: LD_VAR 0 4
9085: ARRAY
9086: PUSH
9087: LD_INT 1
9089: ARRAY
9090: PPUSH
9091: LD_VAR 0 2
9095: PUSH
9096: LD_VAR 0 4
9100: ARRAY
9101: PUSH
9102: LD_INT 2
9104: ARRAY
9105: PPUSH
9106: CALL_OW 428
9110: PPUSH
9111: CALL_OW 248
9115: PUSH
9116: LD_INT 3
9118: EQUAL
9119: IFFALSE 9245
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
9121: LD_VAR 0 2
9125: PUSH
9126: LD_VAR 0 4
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 2
9140: PUSH
9141: LD_VAR 0 4
9145: ARRAY
9146: PUSH
9147: LD_INT 2
9149: ARRAY
9150: PPUSH
9151: CALL_OW 428
9155: PPUSH
9156: CALL_OW 274
9160: PPUSH
9161: LD_INT 3
9163: PPUSH
9164: CALL_OW 275
9168: PUSH
9169: LD_INT 15
9171: GREATEREQUAL
9172: IFFALSE 9243
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9174: LD_VAR 0 2
9178: PUSH
9179: LD_VAR 0 4
9183: ARRAY
9184: PUSH
9185: LD_INT 1
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 2
9193: PUSH
9194: LD_VAR 0 4
9198: ARRAY
9199: PUSH
9200: LD_INT 2
9202: ARRAY
9203: PPUSH
9204: CALL_OW 428
9208: PPUSH
9209: LD_VAR 0 2
9213: PUSH
9214: LD_VAR 0 4
9218: ARRAY
9219: PUSH
9220: LD_INT 4
9222: ARRAY
9223: PPUSH
9224: LD_VAR 0 2
9228: PUSH
9229: LD_VAR 0 4
9233: ARRAY
9234: PUSH
9235: LD_INT 5
9237: ARRAY
9238: PPUSH
9239: CALL 7906 0 3
// end else
9243: GO 9314
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9245: LD_VAR 0 2
9249: PUSH
9250: LD_VAR 0 4
9254: ARRAY
9255: PUSH
9256: LD_INT 1
9258: ARRAY
9259: PPUSH
9260: LD_VAR 0 2
9264: PUSH
9265: LD_VAR 0 4
9269: ARRAY
9270: PUSH
9271: LD_INT 2
9273: ARRAY
9274: PPUSH
9275: CALL_OW 428
9279: PPUSH
9280: LD_VAR 0 2
9284: PUSH
9285: LD_VAR 0 4
9289: ARRAY
9290: PUSH
9291: LD_INT 4
9293: ARRAY
9294: PPUSH
9295: LD_VAR 0 2
9299: PUSH
9300: LD_VAR 0 4
9304: ARRAY
9305: PUSH
9306: LD_INT 5
9308: ARRAY
9309: PPUSH
9310: CALL 7906 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
9314: LD_VAR 0 1
9318: PPUSH
9319: LD_VAR 0 2
9323: PUSH
9324: LD_VAR 0 4
9328: ARRAY
9329: PUSH
9330: LD_INT 1
9332: ARRAY
9333: PPUSH
9334: LD_VAR 0 2
9338: PUSH
9339: LD_VAR 0 4
9343: ARRAY
9344: PUSH
9345: LD_INT 2
9347: ARRAY
9348: PPUSH
9349: CALL_OW 428
9353: PPUSH
9354: CALL 10962 0 2
// end else
9358: GO 9587
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
9360: LD_VAR 0 1
9364: PUSH
9365: LD_INT 1
9367: ARRAY
9368: PPUSH
9369: CALL_OW 255
9373: PPUSH
9374: CALL 6648 0 1
9378: PPUSH
9379: LD_INT 6
9381: PPUSH
9382: CALL 6224 0 2
9386: PUSH
9387: LD_VAR 0 1
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 255
9400: PPUSH
9401: CALL 6648 0 1
9405: PPUSH
9406: LD_VAR 0 2
9410: PUSH
9411: LD_VAR 0 4
9415: ARRAY
9416: PUSH
9417: LD_INT 4
9419: ARRAY
9420: PPUSH
9421: CALL 6224 0 2
9425: AND
9426: PUSH
9427: LD_VAR 0 1
9431: PUSH
9432: LD_INT 1
9434: ARRAY
9435: PPUSH
9436: CALL_OW 255
9440: PPUSH
9441: CALL 6648 0 1
9445: PPUSH
9446: LD_VAR 0 2
9450: PUSH
9451: LD_VAR 0 4
9455: ARRAY
9456: PUSH
9457: LD_INT 5
9459: ARRAY
9460: PPUSH
9461: CALL 6224 0 2
9465: AND
9466: IFFALSE 9587
// for p = 1 to plist do
9468: LD_ADDR_VAR 0 5
9472: PUSH
9473: DOUBLE
9474: LD_INT 1
9476: DEC
9477: ST_TO_ADDR
9478: LD_VAR 0 1
9482: PUSH
9483: FOR_TO
9484: IFFALSE 9585
// if IsInUnit ( plist [ p ] ) then
9486: LD_VAR 0 1
9490: PUSH
9491: LD_VAR 0 5
9495: ARRAY
9496: PPUSH
9497: CALL_OW 310
9501: IFFALSE 9520
// ComExitBuilding ( plist [ p ] ) else
9503: LD_VAR 0 1
9507: PUSH
9508: LD_VAR 0 5
9512: ARRAY
9513: PPUSH
9514: CALL_OW 122
9518: GO 9583
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
9520: LD_VAR 0 1
9524: PUSH
9525: LD_VAR 0 5
9529: ARRAY
9530: PPUSH
9531: LD_INT 6
9533: PPUSH
9534: LD_VAR 0 2
9538: PUSH
9539: LD_VAR 0 4
9543: ARRAY
9544: PUSH
9545: LD_INT 1
9547: ARRAY
9548: PPUSH
9549: LD_VAR 0 2
9553: PUSH
9554: LD_VAR 0 4
9558: ARRAY
9559: PUSH
9560: LD_INT 2
9562: ARRAY
9563: PPUSH
9564: LD_VAR 0 2
9568: PUSH
9569: LD_VAR 0 4
9573: ARRAY
9574: PUSH
9575: LD_INT 3
9577: ARRAY
9578: PPUSH
9579: CALL_OW 145
9583: GO 9483
9585: POP
9586: POP
// end ;
9587: GO 9033
9589: POP
9590: POP
// end ;
9591: LD_VAR 0 3
9595: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9596: LD_INT 0
9598: PPUSH
// if IsInUnit ( sci ) then
9599: LD_VAR 0 1
9603: PPUSH
9604: CALL_OW 310
9608: IFFALSE 9621
// ComExitBuilding ( sci ) else
9610: LD_VAR 0 1
9614: PPUSH
9615: CALL_OW 122
9619: GO 9652
// if not HasTask ( sci ) then
9621: LD_VAR 0 1
9625: PPUSH
9626: CALL_OW 314
9630: NOT
9631: IFFALSE 9652
// begin ComMoveXY ( sci , x , y ) ;
9633: LD_VAR 0 1
9637: PPUSH
9638: LD_VAR 0 2
9642: PPUSH
9643: LD_VAR 0 3
9647: PPUSH
9648: CALL_OW 111
// end ; end ;
9652: LD_VAR 0 4
9656: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9657: LD_INT 0
9659: PPUSH
9660: PPUSH
9661: PPUSH
9662: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9663: LD_ADDR_VAR 0 6
9667: PUSH
9668: LD_INT 22
9670: PUSH
9671: LD_VAR 0 1
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: PUSH
9680: LD_INT 21
9682: PUSH
9683: LD_INT 1
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PPUSH
9694: CALL_OW 69
9698: PUSH
9699: LD_VAR 0 3
9703: DIFF
9704: ST_TO_ADDR
// tmp := tag_list ;
9705: LD_ADDR_VAR 0 7
9709: PUSH
9710: LD_VAR 0 2
9714: ST_TO_ADDR
// for i = 1 to filter do
9715: LD_ADDR_VAR 0 5
9719: PUSH
9720: DOUBLE
9721: LD_INT 1
9723: DEC
9724: ST_TO_ADDR
9725: LD_VAR 0 6
9729: PUSH
9730: FOR_TO
9731: IFFALSE 10000
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9733: LD_VAR 0 6
9737: PUSH
9738: LD_VAR 0 5
9742: ARRAY
9743: PPUSH
9744: CALL_OW 256
9748: PUSH
9749: LD_INT 1000
9751: EQUAL
9752: PUSH
9753: LD_VAR 0 6
9757: PUSH
9758: LD_VAR 0 5
9762: ARRAY
9763: PPUSH
9764: CALL_OW 110
9768: PUSH
9769: LD_INT 100
9771: GREATEREQUAL
9772: AND
9773: IFFALSE 9815
// begin SetTag ( filter [ i ] , 0 ) ;
9775: LD_VAR 0 6
9779: PUSH
9780: LD_VAR 0 5
9784: ARRAY
9785: PPUSH
9786: LD_INT 0
9788: PPUSH
9789: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9793: LD_ADDR_VAR 0 7
9797: PUSH
9798: LD_VAR 0 7
9802: PUSH
9803: LD_VAR 0 6
9807: PUSH
9808: LD_VAR 0 5
9812: ARRAY
9813: DIFF
9814: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9815: LD_VAR 0 6
9819: PUSH
9820: LD_VAR 0 5
9824: ARRAY
9825: PPUSH
9826: CALL_OW 256
9830: PUSH
9831: LD_INT 1000
9833: LESS
9834: IFFALSE 9998
// begin if not filter [ i ] in tmp then
9836: LD_VAR 0 6
9840: PUSH
9841: LD_VAR 0 5
9845: ARRAY
9846: PUSH
9847: LD_VAR 0 7
9851: IN
9852: NOT
9853: IFFALSE 9877
// tmp := tmp ^ filter [ i ] ;
9855: LD_ADDR_VAR 0 7
9859: PUSH
9860: LD_VAR 0 7
9864: PUSH
9865: LD_VAR 0 6
9869: PUSH
9870: LD_VAR 0 5
9874: ARRAY
9875: ADD
9876: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9877: LD_VAR 0 6
9881: PUSH
9882: LD_VAR 0 5
9886: ARRAY
9887: PPUSH
9888: CALL_OW 256
9892: PUSH
9893: LD_INT 250
9895: LESS
9896: IFFALSE 9918
// SetTag ( filter [ i ] , 100 ) else
9898: LD_VAR 0 6
9902: PUSH
9903: LD_VAR 0 5
9907: ARRAY
9908: PPUSH
9909: LD_INT 100
9911: PPUSH
9912: CALL_OW 109
9916: GO 9998
// if GetLives ( filter [ i ] ) < 500 then
9918: LD_VAR 0 6
9922: PUSH
9923: LD_VAR 0 5
9927: ARRAY
9928: PPUSH
9929: CALL_OW 256
9933: PUSH
9934: LD_INT 500
9936: LESS
9937: IFFALSE 9959
// SetTag ( filter [ i ] , 101 ) else
9939: LD_VAR 0 6
9943: PUSH
9944: LD_VAR 0 5
9948: ARRAY
9949: PPUSH
9950: LD_INT 101
9952: PPUSH
9953: CALL_OW 109
9957: GO 9998
// if GetLives ( filter [ i ] ) < 1000 then
9959: LD_VAR 0 6
9963: PUSH
9964: LD_VAR 0 5
9968: ARRAY
9969: PPUSH
9970: CALL_OW 256
9974: PUSH
9975: LD_INT 1000
9977: LESS
9978: IFFALSE 9998
// SetTag ( filter [ i ] , 102 ) ;
9980: LD_VAR 0 6
9984: PUSH
9985: LD_VAR 0 5
9989: ARRAY
9990: PPUSH
9991: LD_INT 102
9993: PPUSH
9994: CALL_OW 109
// end ; end ;
9998: GO 9730
10000: POP
10001: POP
// result := tmp ;
10002: LD_ADDR_VAR 0 4
10006: PUSH
10007: LD_VAR 0 7
10011: ST_TO_ADDR
// end ;
10012: LD_VAR 0 4
10016: RET
// export function WantHeal ( sci , tag ) ; begin
10017: LD_INT 0
10019: PPUSH
// if GetTaskList ( sci ) > 0 then
10020: LD_VAR 0 1
10024: PPUSH
10025: CALL_OW 437
10029: PUSH
10030: LD_INT 0
10032: GREATER
10033: IFFALSE 10108
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
10035: LD_VAR 0 1
10039: PPUSH
10040: CALL_OW 437
10044: PUSH
10045: LD_INT 1
10047: ARRAY
10048: PUSH
10049: LD_INT 1
10051: ARRAY
10052: PUSH
10053: LD_STRING l
10055: EQUAL
10056: PUSH
10057: LD_VAR 0 1
10061: PPUSH
10062: CALL_OW 437
10066: PUSH
10067: LD_INT 1
10069: ARRAY
10070: PUSH
10071: LD_INT 4
10073: ARRAY
10074: PPUSH
10075: CALL_OW 110
10079: PUSH
10080: LD_VAR 0 2
10084: EQUAL
10085: AND
10086: IFFALSE 10098
// result := true else
10088: LD_ADDR_VAR 0 3
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
10096: GO 10106
// result := false ;
10098: LD_ADDR_VAR 0 3
10102: PUSH
10103: LD_INT 0
10105: ST_TO_ADDR
// end else
10106: GO 10116
// result := false ;
10108: LD_ADDR_VAR 0 3
10112: PUSH
10113: LD_INT 0
10115: ST_TO_ADDR
// end ;
10116: LD_VAR 0 3
10120: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
10121: LD_INT 0
10123: PPUSH
10124: PPUSH
10125: PPUSH
10126: PPUSH
10127: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10128: LD_ADDR_VAR 0 7
10132: PUSH
10133: LD_INT 22
10135: PUSH
10136: LD_VAR 0 2
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 3
10147: PUSH
10148: LD_INT 21
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: PPUSH
10166: CALL_OW 69
10170: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
10171: LD_ADDR_VAR 0 5
10175: PUSH
10176: LD_INT 1
10178: PPUSH
10179: LD_INT 3
10181: PPUSH
10182: CALL_OW 12
10186: ST_TO_ADDR
// if filter > 0 then
10187: LD_VAR 0 7
10191: PUSH
10192: LD_INT 0
10194: GREATER
10195: IFFALSE 10397
// for i = 1 to list do
10197: LD_ADDR_VAR 0 6
10201: PUSH
10202: DOUBLE
10203: LD_INT 1
10205: DEC
10206: ST_TO_ADDR
10207: LD_VAR 0 1
10211: PUSH
10212: FOR_TO
10213: IFFALSE 10395
// for ta in filter do
10215: LD_ADDR_VAR 0 4
10219: PUSH
10220: LD_VAR 0 7
10224: PUSH
10225: FOR_IN
10226: IFFALSE 10391
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
10228: LD_VAR 0 1
10232: PUSH
10233: LD_VAR 0 6
10237: ARRAY
10238: PPUSH
10239: LD_VAR 0 4
10243: PPUSH
10244: CALL_OW 296
10248: PUSH
10249: LD_INT 13
10251: LESSEQUAL
10252: IFFALSE 10389
// begin case c of 1 :
10254: LD_VAR 0 5
10258: PUSH
10259: LD_INT 1
10261: DOUBLE
10262: EQUAL
10263: IFTRUE 10267
10265: GO 10305
10267: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
10268: LD_VAR 0 1
10272: PUSH
10273: LD_VAR 0 6
10277: ARRAY
10278: PPUSH
10279: LD_VAR 0 4
10283: PPUSH
10284: CALL_OW 250
10288: PPUSH
10289: LD_VAR 0 4
10293: PPUSH
10294: CALL_OW 251
10298: PPUSH
10299: CALL_OW 154
10303: GO 10389
10305: LD_INT 2
10307: DOUBLE
10308: EQUAL
10309: IFTRUE 10313
10311: GO 10377
10313: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
10314: LD_VAR 0 1
10318: PUSH
10319: LD_VAR 0 6
10323: ARRAY
10324: PPUSH
10325: LD_VAR 0 4
10329: PPUSH
10330: CALL_OW 250
10334: PUSH
10335: LD_INT 1
10337: NEG
10338: PPUSH
10339: LD_INT 1
10341: PPUSH
10342: CALL_OW 12
10346: PLUS
10347: PPUSH
10348: LD_VAR 0 4
10352: PPUSH
10353: CALL_OW 251
10357: PUSH
10358: LD_INT 1
10360: NEG
10361: PPUSH
10362: LD_INT 1
10364: PPUSH
10365: CALL_OW 12
10369: PLUS
10370: PPUSH
10371: CALL_OW 153
10375: GO 10389
10377: LD_INT 3
10379: DOUBLE
10380: EQUAL
10381: IFTRUE 10385
10383: GO 10388
10385: POP
// ; end ;
10386: GO 10389
10388: POP
// end ; end ;
10389: GO 10225
10391: POP
10392: POP
10393: GO 10212
10395: POP
10396: POP
// end ;
10397: LD_VAR 0 3
10401: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
10402: LD_INT 0
10404: PPUSH
10405: PPUSH
// for i = 1 to plist do
10406: LD_ADDR_VAR 0 3
10410: PUSH
10411: DOUBLE
10412: LD_INT 1
10414: DEC
10415: ST_TO_ADDR
10416: LD_VAR 0 1
10420: PUSH
10421: FOR_TO
10422: IFFALSE 10624
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
10424: LD_VAR 0 1
10428: PUSH
10429: LD_VAR 0 3
10433: ARRAY
10434: PPUSH
10435: CALL_OW 310
10439: PUSH
10440: LD_INT 30
10442: PUSH
10443: LD_INT 5
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PUSH
10450: EMPTY
10451: LIST
10452: PPUSH
10453: CALL_OW 69
10457: IN
10458: NOT
10459: IFFALSE 10604
// begin if IsInUnit ( plist [ i ] ) then
10461: LD_VAR 0 1
10465: PUSH
10466: LD_VAR 0 3
10470: ARRAY
10471: PPUSH
10472: CALL_OW 310
10476: IFFALSE 10495
// ComExitBuilding ( plist [ i ] ) else
10478: LD_VAR 0 1
10482: PUSH
10483: LD_VAR 0 3
10487: ARRAY
10488: PPUSH
10489: CALL_OW 122
10493: GO 10602
// if not HasTask ( plist [ i ] ) then
10495: LD_VAR 0 1
10499: PUSH
10500: LD_VAR 0 3
10504: ARRAY
10505: PPUSH
10506: CALL_OW 314
10510: NOT
10511: IFFALSE 10602
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
10513: LD_VAR 0 1
10517: PUSH
10518: LD_VAR 0 3
10522: ARRAY
10523: PPUSH
10524: LD_INT 22
10526: PUSH
10527: LD_VAR 0 1
10531: PUSH
10532: LD_INT 1
10534: ARRAY
10535: PPUSH
10536: CALL_OW 255
10540: PUSH
10541: EMPTY
10542: LIST
10543: LIST
10544: PUSH
10545: LD_INT 30
10547: PUSH
10548: LD_INT 5
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: EMPTY
10556: LIST
10557: LIST
10558: PPUSH
10559: CALL_OW 69
10563: PPUSH
10564: LD_VAR 0 1
10568: PUSH
10569: LD_VAR 0 3
10573: ARRAY
10574: PPUSH
10575: CALL_OW 74
10579: PPUSH
10580: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10584: LD_VAR 0 1
10588: PUSH
10589: LD_VAR 0 3
10593: ARRAY
10594: PPUSH
10595: LD_INT 9
10597: PPUSH
10598: CALL_OW 183
// end ; end else
10602: GO 10622
// ComChangeProfession ( plist [ i ] , 9 ) ;
10604: LD_VAR 0 1
10608: PUSH
10609: LD_VAR 0 3
10613: ARRAY
10614: PPUSH
10615: LD_INT 9
10617: PPUSH
10618: CALL_OW 123
10622: GO 10421
10624: POP
10625: POP
// end ;
10626: LD_VAR 0 2
10630: RET
// export function GetHuman ( side ) ; begin
10631: LD_INT 0
10633: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10634: LD_ADDR_VAR 0 2
10638: PUSH
10639: LD_INT 22
10641: PUSH
10642: LD_VAR 0 1
10646: PUSH
10647: EMPTY
10648: LIST
10649: LIST
10650: PUSH
10651: LD_INT 21
10653: PUSH
10654: LD_INT 1
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PUSH
10661: LD_INT 2
10663: PUSH
10664: LD_INT 25
10666: PUSH
10667: LD_INT 1
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: LD_INT 25
10676: PUSH
10677: LD_INT 2
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 25
10686: PUSH
10687: LD_INT 3
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 25
10696: PUSH
10697: LD_INT 4
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: LIST
10708: LIST
10709: LIST
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: LIST
10715: PPUSH
10716: CALL_OW 69
10720: ST_TO_ADDR
// end ;
10721: LD_VAR 0 2
10725: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10726: LD_INT 0
10728: PPUSH
10729: PPUSH
10730: PPUSH
// uc_side := 0 ;
10731: LD_ADDR_OWVAR 20
10735: PUSH
10736: LD_INT 0
10738: ST_TO_ADDR
// uc_nation := 0 ;
10739: LD_ADDR_OWVAR 21
10743: PUSH
10744: LD_INT 0
10746: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10747: LD_ADDR_VAR 0 4
10751: PUSH
10752: DOUBLE
10753: LD_INT 1
10755: DEC
10756: ST_TO_ADDR
10757: LD_INT 4
10759: PUSH
10760: LD_INT 5
10762: PUSH
10763: LD_INT 6
10765: PUSH
10766: EMPTY
10767: LIST
10768: LIST
10769: LIST
10770: PUSH
10771: LD_OWVAR 67
10775: ARRAY
10776: PUSH
10777: FOR_TO
10778: IFFALSE 10849
// begin hc_class = class_tiger ;
10780: LD_ADDR_OWVAR 28
10784: PUSH
10785: LD_INT 14
10787: ST_TO_ADDR
// hc_gallery = sandnature ;
10788: LD_ADDR_OWVAR 33
10792: PUSH
10793: LD_STRING sandnature
10795: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10796: LD_ADDR_OWVAR 35
10800: PUSH
10801: LD_INT 0
10803: PPUSH
10804: LD_INT 50
10806: PPUSH
10807: CALL_OW 12
10811: ST_TO_ADDR
// hc_face_number = 3 ;
10812: LD_ADDR_OWVAR 34
10816: PUSH
10817: LD_INT 3
10819: ST_TO_ADDR
// tiger := CreateHuman ;
10820: LD_ADDR_VAR 0 3
10824: PUSH
10825: CALL_OW 44
10829: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10830: LD_VAR 0 3
10834: PPUSH
10835: LD_VAR 0 1
10839: PPUSH
10840: LD_INT 0
10842: PPUSH
10843: CALL_OW 49
// end ;
10847: GO 10777
10849: POP
10850: POP
// end ;
10851: LD_VAR 0 2
10855: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10856: LD_INT 0
10858: PPUSH
10859: PPUSH
10860: PPUSH
// uc_side := 0 ;
10861: LD_ADDR_OWVAR 20
10865: PUSH
10866: LD_INT 0
10868: ST_TO_ADDR
// uc_nation := 0 ;
10869: LD_ADDR_OWVAR 21
10873: PUSH
10874: LD_INT 0
10876: ST_TO_ADDR
// for i = 1 to 8 do
10877: LD_ADDR_VAR 0 4
10881: PUSH
10882: DOUBLE
10883: LD_INT 1
10885: DEC
10886: ST_TO_ADDR
10887: LD_INT 8
10889: PUSH
10890: FOR_TO
10891: IFFALSE 10955
// begin hc_class = class_apeman ;
10893: LD_ADDR_OWVAR 28
10897: PUSH
10898: LD_INT 12
10900: ST_TO_ADDR
// hc_gallery =  ;
10901: LD_ADDR_OWVAR 33
10905: PUSH
10906: LD_STRING 
10908: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10909: LD_ADDR_OWVAR 35
10913: PUSH
10914: LD_INT 5
10916: NEG
10917: PPUSH
10918: LD_INT 20
10920: PPUSH
10921: CALL_OW 12
10925: ST_TO_ADDR
// ape := CreateHuman ;
10926: LD_ADDR_VAR 0 3
10930: PUSH
10931: CALL_OW 44
10935: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10936: LD_VAR 0 3
10940: PPUSH
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_INT 0
10948: PPUSH
10949: CALL_OW 49
// end ;
10953: GO 10890
10955: POP
10956: POP
// end ;
10957: LD_VAR 0 2
10961: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
10962: LD_INT 0
10964: PPUSH
10965: PPUSH
// if BuildingStatus ( b ) = bs_build then
10966: LD_VAR 0 2
10970: PPUSH
10971: CALL_OW 461
10975: PUSH
10976: LD_INT 1
10978: EQUAL
10979: IFFALSE 11165
// for i = 1 to plist do
10981: LD_ADDR_VAR 0 4
10985: PUSH
10986: DOUBLE
10987: LD_INT 1
10989: DEC
10990: ST_TO_ADDR
10991: LD_VAR 0 1
10995: PUSH
10996: FOR_TO
10997: IFFALSE 11163
// if IsInUnit ( plist [ i ] ) then
10999: LD_VAR 0 1
11003: PUSH
11004: LD_VAR 0 4
11008: ARRAY
11009: PPUSH
11010: CALL_OW 310
11014: IFFALSE 11097
// begin ComExitBuilding ( plist [ i ] ) ;
11016: LD_VAR 0 1
11020: PUSH
11021: LD_VAR 0 4
11025: ARRAY
11026: PPUSH
11027: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11031: LD_VAR 0 1
11035: PUSH
11036: LD_VAR 0 4
11040: ARRAY
11041: PPUSH
11042: LD_STRING h
11044: PUSH
11045: LD_VAR 0 2
11049: PPUSH
11050: CALL_OW 250
11054: PUSH
11055: LD_VAR 0 2
11059: PPUSH
11060: CALL_OW 251
11064: PUSH
11065: LD_VAR 0 2
11069: PUSH
11070: LD_INT 0
11072: PUSH
11073: LD_INT 0
11075: PUSH
11076: LD_INT 0
11078: PUSH
11079: EMPTY
11080: LIST
11081: LIST
11082: LIST
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: PUSH
11088: EMPTY
11089: LIST
11090: PPUSH
11091: CALL_OW 447
// end else
11095: GO 11161
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11097: LD_VAR 0 1
11101: PUSH
11102: LD_VAR 0 4
11106: ARRAY
11107: PPUSH
11108: LD_STRING h
11110: PUSH
11111: LD_VAR 0 2
11115: PPUSH
11116: CALL_OW 250
11120: PUSH
11121: LD_VAR 0 2
11125: PPUSH
11126: CALL_OW 251
11130: PUSH
11131: LD_VAR 0 2
11135: PUSH
11136: LD_INT 0
11138: PUSH
11139: LD_INT 0
11141: PUSH
11142: LD_INT 0
11144: PUSH
11145: EMPTY
11146: LIST
11147: LIST
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: LIST
11153: PUSH
11154: EMPTY
11155: LIST
11156: PPUSH
11157: CALL_OW 446
11161: GO 10996
11163: POP
11164: POP
// end ;
11165: LD_VAR 0 3
11169: RET
// export function WantRepair ( eng ) ; begin
11170: LD_INT 0
11172: PPUSH
// if GetTaskList ( eng ) > 0 then
11173: LD_VAR 0 1
11177: PPUSH
11178: CALL_OW 437
11182: PUSH
11183: LD_INT 0
11185: GREATER
11186: IFFALSE 11231
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
11188: LD_VAR 0 1
11192: PPUSH
11193: CALL_OW 437
11197: PUSH
11198: LD_INT 1
11200: ARRAY
11201: PUSH
11202: LD_INT 1
11204: ARRAY
11205: PUSH
11206: LD_STRING o
11208: EQUAL
11209: IFFALSE 11221
// result := true else
11211: LD_ADDR_VAR 0 2
11215: PUSH
11216: LD_INT 1
11218: ST_TO_ADDR
11219: GO 11229
// result := false ;
11221: LD_ADDR_VAR 0 2
11225: PUSH
11226: LD_INT 0
11228: ST_TO_ADDR
// end else
11229: GO 11239
// result := false ;
11231: LD_ADDR_VAR 0 2
11235: PUSH
11236: LD_INT 0
11238: ST_TO_ADDR
// end ;
11239: LD_VAR 0 2
11243: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
11244: LD_INT 0
11246: PPUSH
11247: PPUSH
11248: PPUSH
11249: PPUSH
// if btype = - 1 then
11250: LD_VAR 0 2
11254: PUSH
11255: LD_INT 1
11257: NEG
11258: EQUAL
11259: IFFALSE 11299
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 22
11268: PUSH
11269: LD_VAR 0 1
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: PUSH
11278: LD_INT 21
11280: PUSH
11281: LD_INT 3
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PPUSH
11292: CALL_OW 69
11296: ST_TO_ADDR
11297: GO 11337
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
11299: LD_ADDR_VAR 0 5
11303: PUSH
11304: LD_INT 22
11306: PUSH
11307: LD_VAR 0 1
11311: PUSH
11312: EMPTY
11313: LIST
11314: LIST
11315: PUSH
11316: LD_INT 30
11318: PUSH
11319: LD_VAR 0 2
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PUSH
11328: EMPTY
11329: LIST
11330: LIST
11331: PPUSH
11332: CALL_OW 69
11336: ST_TO_ADDR
// list := [ ] ;
11337: LD_ADDR_VAR 0 6
11341: PUSH
11342: EMPTY
11343: ST_TO_ADDR
// for i = 1 to tmp do
11344: LD_ADDR_VAR 0 4
11348: PUSH
11349: DOUBLE
11350: LD_INT 1
11352: DEC
11353: ST_TO_ADDR
11354: LD_VAR 0 5
11358: PUSH
11359: FOR_TO
11360: IFFALSE 11448
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11362: LD_ADDR_VAR 0 6
11366: PUSH
11367: LD_VAR 0 6
11371: PUSH
11372: LD_VAR 0 5
11376: PUSH
11377: LD_VAR 0 4
11381: ARRAY
11382: PPUSH
11383: CALL_OW 266
11387: PUSH
11388: LD_VAR 0 5
11392: PUSH
11393: LD_VAR 0 4
11397: ARRAY
11398: PPUSH
11399: CALL_OW 250
11403: PUSH
11404: LD_VAR 0 5
11408: PUSH
11409: LD_VAR 0 4
11413: ARRAY
11414: PPUSH
11415: CALL_OW 251
11419: PUSH
11420: LD_VAR 0 5
11424: PUSH
11425: LD_VAR 0 4
11429: ARRAY
11430: PPUSH
11431: CALL_OW 254
11435: PUSH
11436: EMPTY
11437: LIST
11438: LIST
11439: LIST
11440: LIST
11441: PUSH
11442: EMPTY
11443: LIST
11444: ADD
11445: ST_TO_ADDR
11446: GO 11359
11448: POP
11449: POP
// result = list ;
11450: LD_ADDR_VAR 0 3
11454: PUSH
11455: LD_VAR 0 6
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 3
11464: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
11465: LD_INT 0
11467: PPUSH
11468: PPUSH
11469: PPUSH
11470: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
11471: LD_VAR 0 1
11475: PPUSH
11476: LD_INT 81
11478: PUSH
11479: LD_VAR 0 1
11483: PPUSH
11484: CALL_OW 255
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PPUSH
11493: CALL_OW 69
11497: PPUSH
11498: LD_VAR 0 1
11502: PPUSH
11503: CALL_OW 74
11507: PPUSH
11508: CALL_OW 296
11512: PUSH
11513: LD_INT 18
11515: LESS
11516: IFFALSE 11561
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
11518: LD_VAR 0 1
11522: PPUSH
11523: LD_INT 81
11525: PUSH
11526: LD_VAR 0 1
11530: PPUSH
11531: CALL_OW 255
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: PPUSH
11540: CALL_OW 69
11544: PPUSH
11545: LD_VAR 0 1
11549: PPUSH
11550: CALL_OW 74
11554: PPUSH
11555: CALL_OW 115
11559: GO 11580
// ComMoveXY ( behemoth , x , y ) ;
11561: LD_VAR 0 1
11565: PPUSH
11566: LD_VAR 0 4
11570: PPUSH
11571: LD_VAR 0 5
11575: PPUSH
11576: CALL_OW 111
// if time_lapsers_list > 0 then
11580: LD_VAR 0 2
11584: PUSH
11585: LD_INT 0
11587: GREATER
11588: IFFALSE 11778
// begin for i = 1 to time_lapsers_list do
11590: LD_ADDR_VAR 0 7
11594: PUSH
11595: DOUBLE
11596: LD_INT 1
11598: DEC
11599: ST_TO_ADDR
11600: LD_VAR 0 2
11604: PUSH
11605: FOR_TO
11606: IFFALSE 11776
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11608: LD_VAR 0 2
11612: PUSH
11613: LD_VAR 0 7
11617: ARRAY
11618: PPUSH
11619: CALL_OW 256
11623: PUSH
11624: LD_INT 250
11626: GREATEREQUAL
11627: PUSH
11628: LD_VAR 0 2
11632: PUSH
11633: LD_VAR 0 7
11637: ARRAY
11638: PPUSH
11639: LD_VAR 0 1
11643: PPUSH
11644: CALL_OW 296
11648: PUSH
11649: LD_INT 9
11651: GREATER
11652: AND
11653: IFFALSE 11690
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11655: LD_VAR 0 2
11659: PUSH
11660: LD_VAR 0 7
11664: ARRAY
11665: PPUSH
11666: LD_VAR 0 1
11670: PPUSH
11671: CALL_OW 250
11675: PPUSH
11676: LD_VAR 0 1
11680: PPUSH
11681: CALL_OW 251
11685: PPUSH
11686: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11690: LD_VAR 0 2
11694: PUSH
11695: LD_VAR 0 7
11699: ARRAY
11700: PPUSH
11701: CALL_OW 256
11705: PUSH
11706: LD_INT 500
11708: LESS
11709: PUSH
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 256
11719: PUSH
11720: LD_INT 700
11722: GREATER
11723: AND
11724: IFFALSE 11774
// for p = 1 to mechanic_list do
11726: LD_ADDR_VAR 0 8
11730: PUSH
11731: DOUBLE
11732: LD_INT 1
11734: DEC
11735: ST_TO_ADDR
11736: LD_VAR 0 3
11740: PUSH
11741: FOR_TO
11742: IFFALSE 11772
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11744: LD_VAR 0 3
11748: PUSH
11749: LD_VAR 0 8
11753: ARRAY
11754: PPUSH
11755: LD_VAR 0 2
11759: PUSH
11760: LD_VAR 0 7
11764: ARRAY
11765: PPUSH
11766: CALL_OW 129
11770: GO 11741
11772: POP
11773: POP
// end ;
11774: GO 11605
11776: POP
11777: POP
// end ; if mechanic_list then
11778: LD_VAR 0 3
11782: IFFALSE 11963
// begin for i = 1 to mechanic_list do
11784: LD_ADDR_VAR 0 7
11788: PUSH
11789: DOUBLE
11790: LD_INT 1
11792: DEC
11793: ST_TO_ADDR
11794: LD_VAR 0 3
11798: PUSH
11799: FOR_TO
11800: IFFALSE 11961
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11802: LD_VAR 0 3
11806: PUSH
11807: LD_VAR 0 7
11811: ARRAY
11812: PPUSH
11813: CALL_OW 256
11817: PUSH
11818: LD_INT 333
11820: LESS
11821: IFFALSE 11845
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11823: LD_ADDR_EXP 14
11827: PUSH
11828: LD_EXP 14
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_VAR 0 7
11842: ARRAY
11843: DIFF
11844: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11845: LD_VAR 0 3
11849: PUSH
11850: LD_VAR 0 7
11854: ARRAY
11855: PPUSH
11856: LD_VAR 0 1
11860: PPUSH
11861: CALL_OW 296
11865: PUSH
11866: LD_INT 9
11868: GREATER
11869: PUSH
11870: LD_VAR 0 3
11874: PUSH
11875: LD_VAR 0 7
11879: ARRAY
11880: PPUSH
11881: CALL_OW 314
11885: NOT
11886: AND
11887: IFFALSE 11924
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11889: LD_VAR 0 3
11893: PUSH
11894: LD_VAR 0 7
11898: ARRAY
11899: PPUSH
11900: LD_VAR 0 1
11904: PPUSH
11905: CALL_OW 250
11909: PPUSH
11910: LD_VAR 0 1
11914: PPUSH
11915: CALL_OW 251
11919: PPUSH
11920: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11924: LD_VAR 0 1
11928: PPUSH
11929: CALL_OW 256
11933: PUSH
11934: LD_INT 700
11936: LESS
11937: IFFALSE 11959
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11939: LD_VAR 0 3
11943: PUSH
11944: LD_VAR 0 7
11948: ARRAY
11949: PPUSH
11950: LD_VAR 0 1
11954: PPUSH
11955: CALL_OW 129
// end ;
11959: GO 11799
11961: POP
11962: POP
// end ; end ;
11963: LD_VAR 0 6
11967: RET
// export function GetBehemoth ( side ) ; begin
11968: LD_INT 0
11970: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
11971: LD_ADDR_VAR 0 2
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_VAR 0 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 31
11990: PUSH
11991: LD_INT 25
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PPUSH
12002: CALL_OW 69
12006: ST_TO_ADDR
// end ;
12007: LD_VAR 0 2
12011: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
12012: LD_INT 0
12014: PPUSH
12015: PPUSH
12016: PPUSH
12017: PPUSH
12018: PPUSH
12019: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
12020: LD_ADDR_VAR 0 6
12024: PUSH
12025: LD_VAR 0 2
12029: PPUSH
12030: CALL_OW 435
12034: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
12035: LD_ADDR_VAR 0 5
12039: PUSH
12040: LD_INT 22
12042: PUSH
12043: LD_VAR 0 1
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: LD_INT 2
12054: PUSH
12055: LD_INT 25
12057: PUSH
12058: LD_INT 2
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: LD_INT 25
12067: PUSH
12068: LD_INT 16
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: LIST
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PPUSH
12084: CALL_OW 69
12088: ST_TO_ADDR
// if skr then
12089: LD_VAR 0 6
12093: IFFALSE 12258
// begin if engs then
12095: LD_VAR 0 5
12099: IFFALSE 12258
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
12101: LD_ADDR_VAR 0 8
12105: PUSH
12106: LD_VAR 0 6
12110: PUSH
12111: LD_INT 1
12113: ARRAY
12114: PPUSH
12115: LD_VAR 0 6
12119: PUSH
12120: LD_INT 2
12122: ARRAY
12123: PPUSH
12124: CALL_OW 284
12128: ST_TO_ADDR
// if am > engs then
12129: LD_VAR 0 8
12133: PUSH
12134: LD_VAR 0 5
12138: GREATER
12139: IFFALSE 12151
// am := engs ;
12141: LD_ADDR_VAR 0 8
12145: PUSH
12146: LD_VAR 0 5
12150: ST_TO_ADDR
// for i = 1 to am do
12151: LD_ADDR_VAR 0 7
12155: PUSH
12156: DOUBLE
12157: LD_INT 1
12159: DEC
12160: ST_TO_ADDR
12161: LD_VAR 0 8
12165: PUSH
12166: FOR_TO
12167: IFFALSE 12256
// begin if IsInUnit ( engs [ i ] ) then
12169: LD_VAR 0 5
12173: PUSH
12174: LD_VAR 0 7
12178: ARRAY
12179: PPUSH
12180: CALL_OW 310
12184: IFFALSE 12203
// ComExitBuilding ( engs [ i ] ) else
12186: LD_VAR 0 5
12190: PUSH
12191: LD_VAR 0 7
12195: ARRAY
12196: PPUSH
12197: CALL_OW 122
12201: GO 12254
// if not HasTask ( engs [ i ] ) then
12203: LD_VAR 0 5
12207: PUSH
12208: LD_VAR 0 7
12212: ARRAY
12213: PPUSH
12214: CALL_OW 314
12218: NOT
12219: IFFALSE 12254
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
12221: LD_VAR 0 5
12225: PUSH
12226: LD_VAR 0 7
12230: ARRAY
12231: PPUSH
12232: LD_VAR 0 6
12236: PUSH
12237: LD_INT 1
12239: ARRAY
12240: PPUSH
12241: LD_VAR 0 6
12245: PUSH
12246: LD_INT 2
12248: ARRAY
12249: PPUSH
12250: CALL_OW 117
// end ;
12254: GO 12166
12256: POP
12257: POP
// end ; end ; end ; end_of_file
12258: LD_VAR 0 3
12262: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
12263: LD_INT 0
12265: PPUSH
12266: PPUSH
// uc_side := 1 ;
12267: LD_ADDR_OWVAR 20
12271: PUSH
12272: LD_INT 1
12274: ST_TO_ADDR
// uc_nation := 1 ;
12275: LD_ADDR_OWVAR 21
12279: PUSH
12280: LD_INT 1
12282: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12283: LD_ADDR_VAR 0 2
12287: PUSH
12288: LD_INT 6
12290: PUSH
12291: LD_INT 5
12293: PUSH
12294: LD_INT 4
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: LIST
12301: PUSH
12302: LD_OWVAR 67
12306: ARRAY
12307: ST_TO_ADDR
// game_status := false ;
12308: LD_ADDR_EXP 28
12312: PUSH
12313: LD_INT 0
12315: ST_TO_ADDR
// helps_arrive := false ;
12316: LD_ADDR_EXP 29
12320: PUSH
12321: LD_INT 0
12323: ST_TO_ADDR
// helps_can_arrive := false ;
12324: LD_ADDR_EXP 30
12328: PUSH
12329: LD_INT 0
12331: ST_TO_ADDR
// beta_come := false ;
12332: LD_ADDR_EXP 31
12336: PUSH
12337: LD_INT 0
12339: ST_TO_ADDR
// gamma_come := false ;
12340: LD_ADDR_EXP 32
12344: PUSH
12345: LD_INT 0
12347: ST_TO_ADDR
// zeta_come := false ;
12348: LD_ADDR_EXP 33
12352: PUSH
12353: LD_INT 0
12355: ST_TO_ADDR
// mine_ck := false ;
12356: LD_ADDR_EXP 34
12360: PUSH
12361: LD_INT 0
12363: ST_TO_ADDR
// sib_bomb_constructed := false ;
12364: LD_ADDR_EXP 35
12368: PUSH
12369: LD_INT 0
12371: ST_TO_ADDR
// mine_constructed := false ;
12372: LD_ADDR_EXP 36
12376: PUSH
12377: LD_INT 0
12379: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
12380: LD_INT 35
12382: PPUSH
12383: CALL_OW 274
12387: PPUSH
12388: LD_INT 1
12390: PPUSH
12391: LD_INT 200
12393: PUSH
12394: LD_INT 100
12396: PUSH
12397: LD_INT 70
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: LIST
12404: PUSH
12405: LD_OWVAR 67
12409: ARRAY
12410: PPUSH
12411: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
12415: LD_INT 35
12417: PPUSH
12418: LD_INT 4
12420: PPUSH
12421: CALL_OW 235
// hc_importance := 100 ;
12425: LD_ADDR_OWVAR 32
12429: PUSH
12430: LD_INT 100
12432: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
12433: LD_INT 1
12435: PPUSH
12436: LD_INT 2
12438: PPUSH
12439: LD_VAR 0 2
12443: PUSH
12444: LD_INT 1
12446: PLUS
12447: PPUSH
12448: CALL_OW 380
// hc_gallery := hardch ;
12452: LD_ADDR_OWVAR 33
12456: PUSH
12457: LD_STRING hardch
12459: ST_TO_ADDR
// hc_face_number := 1 ;
12460: LD_ADDR_OWVAR 34
12464: PUSH
12465: LD_INT 1
12467: ST_TO_ADDR
// guyA := CreateHuman ;
12468: LD_ADDR_EXP 37
12472: PUSH
12473: CALL_OW 44
12477: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
12478: LD_INT 1
12480: PPUSH
12481: LD_INT 1
12483: PPUSH
12484: LD_VAR 0 2
12488: PPUSH
12489: CALL_OW 380
// hc_face_number := 2 ;
12493: LD_ADDR_OWVAR 34
12497: PUSH
12498: LD_INT 2
12500: ST_TO_ADDR
// guyB := CreateHuman ;
12501: LD_ADDR_EXP 38
12505: PUSH
12506: CALL_OW 44
12510: ST_TO_ADDR
// hc_importance := 0 ;
12511: LD_ADDR_OWVAR 32
12515: PUSH
12516: LD_INT 0
12518: ST_TO_ADDR
// hc_gallery :=  ;
12519: LD_ADDR_OWVAR 33
12523: PUSH
12524: LD_STRING 
12526: ST_TO_ADDR
// end ;
12527: LD_VAR 0 1
12531: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
12532: LD_INT 0
12534: PPUSH
12535: PPUSH
12536: PPUSH
12537: PPUSH
12538: PPUSH
12539: PPUSH
12540: PPUSH
12541: PPUSH
12542: PPUSH
// uc_side := 4 ;
12543: LD_ADDR_OWVAR 20
12547: PUSH
12548: LD_INT 4
12550: ST_TO_ADDR
// uc_nation := 1 ;
12551: LD_ADDR_OWVAR 21
12555: PUSH
12556: LD_INT 1
12558: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12559: LD_ADDR_VAR 0 10
12563: PUSH
12564: LD_INT 6
12566: PUSH
12567: LD_INT 5
12569: PUSH
12570: LD_INT 4
12572: PUSH
12573: EMPTY
12574: LIST
12575: LIST
12576: LIST
12577: PUSH
12578: LD_OWVAR 67
12582: ARRAY
12583: ST_TO_ADDR
// Beta_Squad := [ ] ;
12584: LD_ADDR_EXP 39
12588: PUSH
12589: EMPTY
12590: ST_TO_ADDR
// case num of 1 :
12591: LD_VAR 0 1
12595: PUSH
12596: LD_INT 1
12598: DOUBLE
12599: EQUAL
12600: IFTRUE 12604
12602: GO 12647
12604: POP
// begin sold := 2 ;
12605: LD_ADDR_VAR 0 5
12609: PUSH
12610: LD_INT 2
12612: ST_TO_ADDR
// sci := 1 ;
12613: LD_ADDR_VAR 0 6
12617: PUSH
12618: LD_INT 1
12620: ST_TO_ADDR
// mech := 2 ;
12621: LD_ADDR_VAR 0 7
12625: PUSH
12626: LD_INT 2
12628: ST_TO_ADDR
// tank := 1 ;
12629: LD_ADDR_VAR 0 8
12633: PUSH
12634: LD_INT 1
12636: ST_TO_ADDR
// cargo := 1 ;
12637: LD_ADDR_VAR 0 9
12641: PUSH
12642: LD_INT 1
12644: ST_TO_ADDR
// end ; 2 :
12645: GO 12750
12647: LD_INT 2
12649: DOUBLE
12650: EQUAL
12651: IFTRUE 12655
12653: GO 12698
12655: POP
// begin sold := 2 ;
12656: LD_ADDR_VAR 0 5
12660: PUSH
12661: LD_INT 2
12663: ST_TO_ADDR
// sci := 1 ;
12664: LD_ADDR_VAR 0 6
12668: PUSH
12669: LD_INT 1
12671: ST_TO_ADDR
// mech := 1 ;
12672: LD_ADDR_VAR 0 7
12676: PUSH
12677: LD_INT 1
12679: ST_TO_ADDR
// tank := 1 ;
12680: LD_ADDR_VAR 0 8
12684: PUSH
12685: LD_INT 1
12687: ST_TO_ADDR
// cargo := 0 ;
12688: LD_ADDR_VAR 0 9
12692: PUSH
12693: LD_INT 0
12695: ST_TO_ADDR
// end ; 3 :
12696: GO 12750
12698: LD_INT 3
12700: DOUBLE
12701: EQUAL
12702: IFTRUE 12706
12704: GO 12749
12706: POP
// begin sold := 1 ;
12707: LD_ADDR_VAR 0 5
12711: PUSH
12712: LD_INT 1
12714: ST_TO_ADDR
// sci := 1 ;
12715: LD_ADDR_VAR 0 6
12719: PUSH
12720: LD_INT 1
12722: ST_TO_ADDR
// mech := 1 ;
12723: LD_ADDR_VAR 0 7
12727: PUSH
12728: LD_INT 1
12730: ST_TO_ADDR
// tank := 1 ;
12731: LD_ADDR_VAR 0 8
12735: PUSH
12736: LD_INT 1
12738: ST_TO_ADDR
// cargo := 0 ;
12739: LD_ADDR_VAR 0 9
12743: PUSH
12744: LD_INT 0
12746: ST_TO_ADDR
// end ; end ;
12747: GO 12750
12749: POP
// for i = 1 to sold do
12750: LD_ADDR_VAR 0 3
12754: PUSH
12755: DOUBLE
12756: LD_INT 1
12758: DEC
12759: ST_TO_ADDR
12760: LD_VAR 0 5
12764: PUSH
12765: FOR_TO
12766: IFFALSE 12838
// begin if i = 1 then
12768: LD_VAR 0 3
12772: PUSH
12773: LD_INT 1
12775: EQUAL
12776: IFFALSE 12795
// PrepareHuman ( sex_male , 1 , skill ) else
12778: LD_INT 1
12780: PPUSH
12781: LD_INT 1
12783: PPUSH
12784: LD_VAR 0 10
12788: PPUSH
12789: CALL_OW 380
12793: GO 12810
// PrepareHuman ( false , 1 , skill ) ;
12795: LD_INT 0
12797: PPUSH
12798: LD_INT 1
12800: PPUSH
12801: LD_VAR 0 10
12805: PPUSH
12806: CALL_OW 380
// un := CreateHuman ;
12810: LD_ADDR_VAR 0 4
12814: PUSH
12815: CALL_OW 44
12819: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12820: LD_ADDR_EXP 39
12824: PUSH
12825: LD_EXP 39
12829: PUSH
12830: LD_VAR 0 4
12834: ADD
12835: ST_TO_ADDR
// end ;
12836: GO 12765
12838: POP
12839: POP
// for i = 1 to mech do
12840: LD_ADDR_VAR 0 3
12844: PUSH
12845: DOUBLE
12846: LD_INT 1
12848: DEC
12849: ST_TO_ADDR
12850: LD_VAR 0 7
12854: PUSH
12855: FOR_TO
12856: IFFALSE 12913
// begin PrepareHuman ( false , 3 , skill ) ;
12858: LD_INT 0
12860: PPUSH
12861: LD_INT 3
12863: PPUSH
12864: LD_VAR 0 10
12868: PPUSH
12869: CALL_OW 380
// un := CreateHuman ;
12873: LD_ADDR_VAR 0 4
12877: PUSH
12878: CALL_OW 44
12882: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12883: LD_VAR 0 4
12887: PPUSH
12888: LD_INT 3
12890: PPUSH
12891: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12895: LD_ADDR_EXP 39
12899: PUSH
12900: LD_EXP 39
12904: PUSH
12905: LD_VAR 0 4
12909: ADD
12910: ST_TO_ADDR
// end ;
12911: GO 12855
12913: POP
12914: POP
// for i = 1 to sci do
12915: LD_ADDR_VAR 0 3
12919: PUSH
12920: DOUBLE
12921: LD_INT 1
12923: DEC
12924: ST_TO_ADDR
12925: LD_VAR 0 6
12929: PUSH
12930: FOR_TO
12931: IFFALSE 12976
// begin PrepareHuman ( false , 4 , skill ) ;
12933: LD_INT 0
12935: PPUSH
12936: LD_INT 4
12938: PPUSH
12939: LD_VAR 0 10
12943: PPUSH
12944: CALL_OW 380
// un := CreateHuman ;
12948: LD_ADDR_VAR 0 4
12952: PUSH
12953: CALL_OW 44
12957: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12958: LD_ADDR_EXP 39
12962: PUSH
12963: LD_EXP 39
12967: PUSH
12968: LD_VAR 0 4
12972: ADD
12973: ST_TO_ADDR
// end ;
12974: GO 12930
12976: POP
12977: POP
// for i = 1 to tank do
12978: LD_ADDR_VAR 0 3
12982: PUSH
12983: DOUBLE
12984: LD_INT 1
12986: DEC
12987: ST_TO_ADDR
12988: LD_VAR 0 8
12992: PUSH
12993: FOR_TO
12994: IFFALSE 13107
// begin Randomize ;
12996: CALL_OW 10
// vc_chassis := us_medium_tracked ;
13000: LD_ADDR_OWVAR 37
13004: PUSH
13005: LD_INT 3
13007: ST_TO_ADDR
// vc_engine := engine_solar ;
13008: LD_ADDR_OWVAR 39
13012: PUSH
13013: LD_INT 2
13015: ST_TO_ADDR
// vc_control := control_manual ;
13016: LD_ADDR_OWVAR 38
13020: PUSH
13021: LD_INT 1
13023: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
13024: LD_ADDR_OWVAR 40
13028: PUSH
13029: LD_INT 4
13031: PUSH
13032: LD_INT 5
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PUSH
13039: LD_INT 1
13041: PPUSH
13042: LD_INT 2
13044: PPUSH
13045: CALL_OW 12
13049: ARRAY
13050: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13051: LD_ADDR_OWVAR 41
13055: PUSH
13056: LD_INT 35
13058: PPUSH
13059: LD_INT 55
13061: PPUSH
13062: CALL_OW 12
13066: ST_TO_ADDR
// un := CreateVehicle ;
13067: LD_ADDR_VAR 0 4
13071: PUSH
13072: CALL_OW 45
13076: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13077: LD_VAR 0 4
13081: PPUSH
13082: LD_INT 5
13084: PPUSH
13085: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13089: LD_ADDR_EXP 39
13093: PUSH
13094: LD_EXP 39
13098: PUSH
13099: LD_VAR 0 4
13103: ADD
13104: ST_TO_ADDR
// end ;
13105: GO 12993
13107: POP
13108: POP
// if cargo then
13109: LD_VAR 0 9
13113: IFFALSE 13216
// begin vc_chassis := us_medium_tracked ;
13115: LD_ADDR_OWVAR 37
13119: PUSH
13120: LD_INT 3
13122: ST_TO_ADDR
// vc_engine := engine_solar ;
13123: LD_ADDR_OWVAR 39
13127: PUSH
13128: LD_INT 2
13130: ST_TO_ADDR
// vc_control := control_manual ;
13131: LD_ADDR_OWVAR 38
13135: PUSH
13136: LD_INT 1
13138: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13139: LD_ADDR_OWVAR 40
13143: PUSH
13144: LD_INT 12
13146: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13147: LD_ADDR_OWVAR 41
13151: PUSH
13152: LD_INT 35
13154: PPUSH
13155: LD_INT 55
13157: PPUSH
13158: CALL_OW 12
13162: ST_TO_ADDR
// un := CreateVehicle ;
13163: LD_ADDR_VAR 0 4
13167: PUSH
13168: CALL_OW 45
13172: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13173: LD_VAR 0 4
13177: PPUSH
13178: LD_INT 5
13180: PPUSH
13181: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13185: LD_ADDR_EXP 39
13189: PUSH
13190: LD_EXP 39
13194: PUSH
13195: LD_VAR 0 4
13199: ADD
13200: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
13201: LD_VAR 0 4
13205: PPUSH
13206: LD_INT 1
13208: PPUSH
13209: LD_INT 60
13211: PPUSH
13212: CALL_OW 290
// end ; end ;
13216: LD_VAR 0 2
13220: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13221: LD_INT 0
13223: PPUSH
13224: PPUSH
13225: PPUSH
13226: PPUSH
13227: PPUSH
13228: PPUSH
13229: PPUSH
13230: PPUSH
13231: PPUSH
13232: PPUSH
// uc_side := 4 ;
13233: LD_ADDR_OWVAR 20
13237: PUSH
13238: LD_INT 4
13240: ST_TO_ADDR
// uc_nation := 1 ;
13241: LD_ADDR_OWVAR 21
13245: PUSH
13246: LD_INT 1
13248: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13249: LD_ADDR_VAR 0 11
13253: PUSH
13254: LD_INT 6
13256: PUSH
13257: LD_INT 5
13259: PUSH
13260: LD_INT 4
13262: PUSH
13263: EMPTY
13264: LIST
13265: LIST
13266: LIST
13267: PUSH
13268: LD_OWVAR 67
13272: ARRAY
13273: ST_TO_ADDR
// Gamma_Squad := [ ] ;
13274: LD_ADDR_EXP 40
13278: PUSH
13279: EMPTY
13280: ST_TO_ADDR
// case num of 1 :
13281: LD_VAR 0 1
13285: PUSH
13286: LD_INT 1
13288: DOUBLE
13289: EQUAL
13290: IFTRUE 13294
13292: GO 13345
13294: POP
// begin sold := 2 ;
13295: LD_ADDR_VAR 0 5
13299: PUSH
13300: LD_INT 2
13302: ST_TO_ADDR
// eng := 2 ;
13303: LD_ADDR_VAR 0 6
13307: PUSH
13308: LD_INT 2
13310: ST_TO_ADDR
// sci := 0 ;
13311: LD_ADDR_VAR 0 7
13315: PUSH
13316: LD_INT 0
13318: ST_TO_ADDR
// mech := 1 ;
13319: LD_ADDR_VAR 0 8
13323: PUSH
13324: LD_INT 1
13326: ST_TO_ADDR
// tank := 0 ;
13327: LD_ADDR_VAR 0 9
13331: PUSH
13332: LD_INT 0
13334: ST_TO_ADDR
// cargo := 1 ;
13335: LD_ADDR_VAR 0 10
13339: PUSH
13340: LD_INT 1
13342: ST_TO_ADDR
// end ; 2 :
13343: GO 13464
13345: LD_INT 2
13347: DOUBLE
13348: EQUAL
13349: IFTRUE 13353
13351: GO 13404
13353: POP
// begin sold := 1 ;
13354: LD_ADDR_VAR 0 5
13358: PUSH
13359: LD_INT 1
13361: ST_TO_ADDR
// eng := 2 ;
13362: LD_ADDR_VAR 0 6
13366: PUSH
13367: LD_INT 2
13369: ST_TO_ADDR
// sci := 0 ;
13370: LD_ADDR_VAR 0 7
13374: PUSH
13375: LD_INT 0
13377: ST_TO_ADDR
// mech := 1 ;
13378: LD_ADDR_VAR 0 8
13382: PUSH
13383: LD_INT 1
13385: ST_TO_ADDR
// tank := 0 ;
13386: LD_ADDR_VAR 0 9
13390: PUSH
13391: LD_INT 0
13393: ST_TO_ADDR
// cargo := 1 ;
13394: LD_ADDR_VAR 0 10
13398: PUSH
13399: LD_INT 1
13401: ST_TO_ADDR
// end ; 3 :
13402: GO 13464
13404: LD_INT 3
13406: DOUBLE
13407: EQUAL
13408: IFTRUE 13412
13410: GO 13463
13412: POP
// begin sold := 1 ;
13413: LD_ADDR_VAR 0 5
13417: PUSH
13418: LD_INT 1
13420: ST_TO_ADDR
// eng := 1 ;
13421: LD_ADDR_VAR 0 6
13425: PUSH
13426: LD_INT 1
13428: ST_TO_ADDR
// sci := 0 ;
13429: LD_ADDR_VAR 0 7
13433: PUSH
13434: LD_INT 0
13436: ST_TO_ADDR
// mech := 1 ;
13437: LD_ADDR_VAR 0 8
13441: PUSH
13442: LD_INT 1
13444: ST_TO_ADDR
// tank := 0 ;
13445: LD_ADDR_VAR 0 9
13449: PUSH
13450: LD_INT 0
13452: ST_TO_ADDR
// cargo := 1 ;
13453: LD_ADDR_VAR 0 10
13457: PUSH
13458: LD_INT 1
13460: ST_TO_ADDR
// end ; end ;
13461: GO 13464
13463: POP
// for i = 1 to sold do
13464: LD_ADDR_VAR 0 3
13468: PUSH
13469: DOUBLE
13470: LD_INT 1
13472: DEC
13473: ST_TO_ADDR
13474: LD_VAR 0 5
13478: PUSH
13479: FOR_TO
13480: IFFALSE 13552
// begin if i = 1 then
13482: LD_VAR 0 3
13486: PUSH
13487: LD_INT 1
13489: EQUAL
13490: IFFALSE 13509
// PrepareHuman ( sex_male , 1 , skill ) else
13492: LD_INT 1
13494: PPUSH
13495: LD_INT 1
13497: PPUSH
13498: LD_VAR 0 11
13502: PPUSH
13503: CALL_OW 380
13507: GO 13524
// PrepareHuman ( false , 1 , skill ) ;
13509: LD_INT 0
13511: PPUSH
13512: LD_INT 1
13514: PPUSH
13515: LD_VAR 0 11
13519: PPUSH
13520: CALL_OW 380
// un := CreateHuman ;
13524: LD_ADDR_VAR 0 4
13528: PUSH
13529: CALL_OW 44
13533: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13534: LD_ADDR_EXP 40
13538: PUSH
13539: LD_EXP 40
13543: PUSH
13544: LD_VAR 0 4
13548: ADD
13549: ST_TO_ADDR
// end ;
13550: GO 13479
13552: POP
13553: POP
// for i = 1 to mech do
13554: LD_ADDR_VAR 0 3
13558: PUSH
13559: DOUBLE
13560: LD_INT 1
13562: DEC
13563: ST_TO_ADDR
13564: LD_VAR 0 8
13568: PUSH
13569: FOR_TO
13570: IFFALSE 13627
// begin PrepareHuman ( false , 3 , skill ) ;
13572: LD_INT 0
13574: PPUSH
13575: LD_INT 3
13577: PPUSH
13578: LD_VAR 0 11
13582: PPUSH
13583: CALL_OW 380
// un := CreateHuman ;
13587: LD_ADDR_VAR 0 4
13591: PUSH
13592: CALL_OW 44
13596: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13597: LD_VAR 0 4
13601: PPUSH
13602: LD_INT 3
13604: PPUSH
13605: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13609: LD_ADDR_EXP 40
13613: PUSH
13614: LD_EXP 40
13618: PUSH
13619: LD_VAR 0 4
13623: ADD
13624: ST_TO_ADDR
// end ;
13625: GO 13569
13627: POP
13628: POP
// for i = 1 to eng do
13629: LD_ADDR_VAR 0 3
13633: PUSH
13634: DOUBLE
13635: LD_INT 1
13637: DEC
13638: ST_TO_ADDR
13639: LD_VAR 0 6
13643: PUSH
13644: FOR_TO
13645: IFFALSE 13690
// begin PrepareHuman ( false , 2 , skill ) ;
13647: LD_INT 0
13649: PPUSH
13650: LD_INT 2
13652: PPUSH
13653: LD_VAR 0 11
13657: PPUSH
13658: CALL_OW 380
// un := CreateHuman ;
13662: LD_ADDR_VAR 0 4
13666: PUSH
13667: CALL_OW 44
13671: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13672: LD_ADDR_EXP 40
13676: PUSH
13677: LD_EXP 40
13681: PUSH
13682: LD_VAR 0 4
13686: ADD
13687: ST_TO_ADDR
// end ;
13688: GO 13644
13690: POP
13691: POP
// for i = 1 to tank do
13692: LD_ADDR_VAR 0 3
13696: PUSH
13697: DOUBLE
13698: LD_INT 1
13700: DEC
13701: ST_TO_ADDR
13702: LD_VAR 0 9
13706: PUSH
13707: FOR_TO
13708: IFFALSE 13821
// begin Randomize ;
13710: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13714: LD_ADDR_OWVAR 37
13718: PUSH
13719: LD_INT 2
13721: ST_TO_ADDR
// vc_engine := engine_siberite ;
13722: LD_ADDR_OWVAR 39
13726: PUSH
13727: LD_INT 3
13729: ST_TO_ADDR
// vc_control := control_manual ;
13730: LD_ADDR_OWVAR 38
13734: PUSH
13735: LD_INT 1
13737: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13738: LD_ADDR_OWVAR 40
13742: PUSH
13743: LD_INT 7
13745: PUSH
13746: LD_INT 9
13748: PUSH
13749: EMPTY
13750: LIST
13751: LIST
13752: PUSH
13753: LD_INT 1
13755: PPUSH
13756: LD_INT 2
13758: PPUSH
13759: CALL_OW 12
13763: ARRAY
13764: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13765: LD_ADDR_OWVAR 41
13769: PUSH
13770: LD_INT 35
13772: PPUSH
13773: LD_INT 55
13775: PPUSH
13776: CALL_OW 12
13780: ST_TO_ADDR
// un := CreateVehicle ;
13781: LD_ADDR_VAR 0 4
13785: PUSH
13786: CALL_OW 45
13790: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13791: LD_VAR 0 4
13795: PPUSH
13796: LD_INT 5
13798: PPUSH
13799: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13803: LD_ADDR_EXP 40
13807: PUSH
13808: LD_EXP 40
13812: PUSH
13813: LD_VAR 0 4
13817: ADD
13818: ST_TO_ADDR
// end ;
13819: GO 13707
13821: POP
13822: POP
// if cargo then
13823: LD_VAR 0 10
13827: IFFALSE 13945
// begin vc_chassis := us_medium_tracked ;
13829: LD_ADDR_OWVAR 37
13833: PUSH
13834: LD_INT 3
13836: ST_TO_ADDR
// vc_engine := engine_combustion ;
13837: LD_ADDR_OWVAR 39
13841: PUSH
13842: LD_INT 1
13844: ST_TO_ADDR
// vc_control := control_manual ;
13845: LD_ADDR_OWVAR 38
13849: PUSH
13850: LD_INT 1
13852: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13853: LD_ADDR_OWVAR 40
13857: PUSH
13858: LD_INT 12
13860: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13861: LD_ADDR_OWVAR 41
13865: PUSH
13866: LD_INT 35
13868: PPUSH
13869: LD_INT 55
13871: PPUSH
13872: CALL_OW 12
13876: ST_TO_ADDR
// un := CreateVehicle ;
13877: LD_ADDR_VAR 0 4
13881: PUSH
13882: CALL_OW 45
13886: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13887: LD_VAR 0 4
13891: PPUSH
13892: LD_INT 5
13894: PPUSH
13895: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13899: LD_ADDR_EXP 40
13903: PUSH
13904: LD_EXP 40
13908: PUSH
13909: LD_VAR 0 4
13913: ADD
13914: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13915: LD_VAR 0 4
13919: PPUSH
13920: LD_INT 3
13922: PPUSH
13923: LD_INT 30
13925: PPUSH
13926: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13930: LD_VAR 0 4
13934: PPUSH
13935: LD_INT 1
13937: PPUSH
13938: LD_INT 40
13940: PPUSH
13941: CALL_OW 290
// end ; end ;
13945: LD_VAR 0 2
13949: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13950: LD_INT 0
13952: PPUSH
13953: PPUSH
13954: PPUSH
13955: PPUSH
13956: PPUSH
13957: PPUSH
13958: PPUSH
13959: PPUSH
13960: PPUSH
13961: PPUSH
// uc_side := 4 ;
13962: LD_ADDR_OWVAR 20
13966: PUSH
13967: LD_INT 4
13969: ST_TO_ADDR
// uc_nation := 1 ;
13970: LD_ADDR_OWVAR 21
13974: PUSH
13975: LD_INT 1
13977: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13978: LD_ADDR_VAR 0 10
13982: PUSH
13983: LD_INT 6
13985: PUSH
13986: LD_INT 5
13988: PUSH
13989: LD_INT 4
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: LIST
13996: PUSH
13997: LD_OWVAR 67
14001: ARRAY
14002: ST_TO_ADDR
// Zeta_Squad := [ ] ;
14003: LD_ADDR_EXP 41
14007: PUSH
14008: EMPTY
14009: ST_TO_ADDR
// sold := 1 ;
14010: LD_ADDR_VAR 0 4
14014: PUSH
14015: LD_INT 1
14017: ST_TO_ADDR
// eng := 0 ;
14018: LD_ADDR_VAR 0 5
14022: PUSH
14023: LD_INT 0
14025: ST_TO_ADDR
// sci := 0 ;
14026: LD_ADDR_VAR 0 6
14030: PUSH
14031: LD_INT 0
14033: ST_TO_ADDR
// mech := 3 ;
14034: LD_ADDR_VAR 0 7
14038: PUSH
14039: LD_INT 3
14041: ST_TO_ADDR
// tank := 3 ;
14042: LD_ADDR_VAR 0 8
14046: PUSH
14047: LD_INT 3
14049: ST_TO_ADDR
// cargo := 0 ;
14050: LD_ADDR_VAR 0 9
14054: PUSH
14055: LD_INT 0
14057: ST_TO_ADDR
// for i = 1 to sold do
14058: LD_ADDR_VAR 0 2
14062: PUSH
14063: DOUBLE
14064: LD_INT 1
14066: DEC
14067: ST_TO_ADDR
14068: LD_VAR 0 4
14072: PUSH
14073: FOR_TO
14074: IFFALSE 14146
// begin if i = 1 then
14076: LD_VAR 0 2
14080: PUSH
14081: LD_INT 1
14083: EQUAL
14084: IFFALSE 14103
// PrepareHuman ( sex_male , 1 , skill ) else
14086: LD_INT 1
14088: PPUSH
14089: LD_INT 1
14091: PPUSH
14092: LD_VAR 0 10
14096: PPUSH
14097: CALL_OW 380
14101: GO 14118
// PrepareHuman ( false , 1 , skill ) ;
14103: LD_INT 0
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: LD_VAR 0 10
14113: PPUSH
14114: CALL_OW 380
// un := CreateHuman ;
14118: LD_ADDR_VAR 0 3
14122: PUSH
14123: CALL_OW 44
14127: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
14128: LD_ADDR_EXP 41
14132: PUSH
14133: LD_EXP 41
14137: PUSH
14138: LD_VAR 0 3
14142: ADD
14143: ST_TO_ADDR
// end ;
14144: GO 14073
14146: POP
14147: POP
// for i = 1 to mech do
14148: LD_ADDR_VAR 0 2
14152: PUSH
14153: DOUBLE
14154: LD_INT 1
14156: DEC
14157: ST_TO_ADDR
14158: LD_VAR 0 7
14162: PUSH
14163: FOR_TO
14164: IFFALSE 14221
// begin PrepareHuman ( false , 3 , skill ) ;
14166: LD_INT 0
14168: PPUSH
14169: LD_INT 3
14171: PPUSH
14172: LD_VAR 0 10
14176: PPUSH
14177: CALL_OW 380
// un := CreateHuman ;
14181: LD_ADDR_VAR 0 3
14185: PUSH
14186: CALL_OW 44
14190: ST_TO_ADDR
// SetTag ( un , 3 ) ;
14191: LD_VAR 0 3
14195: PPUSH
14196: LD_INT 3
14198: PPUSH
14199: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14203: LD_ADDR_EXP 41
14207: PUSH
14208: LD_EXP 41
14212: PUSH
14213: LD_VAR 0 3
14217: ADD
14218: ST_TO_ADDR
// end ;
14219: GO 14163
14221: POP
14222: POP
// for i = 1 to tank do
14223: LD_ADDR_VAR 0 2
14227: PUSH
14228: DOUBLE
14229: LD_INT 1
14231: DEC
14232: ST_TO_ADDR
14233: LD_VAR 0 8
14237: PUSH
14238: FOR_TO
14239: IFFALSE 14485
// begin Randomize ;
14241: CALL_OW 10
// if i < 3 then
14245: LD_VAR 0 2
14249: PUSH
14250: LD_INT 3
14252: LESS
14253: IFFALSE 14362
// begin vc_chassis := us_medium_tracked ;
14255: LD_ADDR_OWVAR 37
14259: PUSH
14260: LD_INT 3
14262: ST_TO_ADDR
// vc_engine := engine_combustion ;
14263: LD_ADDR_OWVAR 39
14267: PUSH
14268: LD_INT 1
14270: ST_TO_ADDR
// vc_control := control_manual ;
14271: LD_ADDR_OWVAR 38
14275: PUSH
14276: LD_INT 1
14278: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
14279: LD_ADDR_OWVAR 40
14283: PUSH
14284: LD_INT 3
14286: PUSH
14287: LD_INT 9
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: PUSH
14294: LD_INT 1
14296: PPUSH
14297: LD_INT 2
14299: PPUSH
14300: CALL_OW 12
14304: ARRAY
14305: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14306: LD_ADDR_OWVAR 41
14310: PUSH
14311: LD_INT 35
14313: PPUSH
14314: LD_INT 55
14316: PPUSH
14317: CALL_OW 12
14321: ST_TO_ADDR
// un := CreateVehicle ;
14322: LD_ADDR_VAR 0 3
14326: PUSH
14327: CALL_OW 45
14331: ST_TO_ADDR
// SetTag ( un , 5 ) ;
14332: LD_VAR 0 3
14336: PPUSH
14337: LD_INT 5
14339: PPUSH
14340: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14344: LD_ADDR_EXP 41
14348: PUSH
14349: LD_EXP 41
14353: PUSH
14354: LD_VAR 0 3
14358: ADD
14359: ST_TO_ADDR
// end else
14360: GO 14483
// begin uc_nation := 3 ;
14362: LD_ADDR_OWVAR 21
14366: PUSH
14367: LD_INT 3
14369: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
14370: LD_ADDR_OWVAR 37
14374: PUSH
14375: LD_INT 22
14377: ST_TO_ADDR
// vc_engine := engine_combustion ;
14378: LD_ADDR_OWVAR 39
14382: PUSH
14383: LD_INT 1
14385: ST_TO_ADDR
// vc_control := control_manual ;
14386: LD_ADDR_OWVAR 38
14390: PUSH
14391: LD_INT 1
14393: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
14394: LD_ADDR_OWVAR 40
14398: PUSH
14399: LD_INT 51
14401: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14402: LD_ADDR_OWVAR 41
14406: PUSH
14407: LD_INT 35
14409: PPUSH
14410: LD_INT 55
14412: PPUSH
14413: CALL_OW 12
14417: ST_TO_ADDR
// un := CreateVehicle ;
14418: LD_ADDR_VAR 0 3
14422: PUSH
14423: CALL_OW 45
14427: ST_TO_ADDR
// SetLives ( un , 496 ) ;
14428: LD_VAR 0 3
14432: PPUSH
14433: LD_INT 496
14435: PPUSH
14436: CALL_OW 234
// SetTag ( un , 5 ) ;
14440: LD_VAR 0 3
14444: PPUSH
14445: LD_INT 5
14447: PPUSH
14448: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
14452: LD_VAR 0 3
14456: PPUSH
14457: LD_INT 2
14459: PPUSH
14460: LD_INT 100
14462: PPUSH
14463: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
14467: LD_ADDR_EXP 41
14471: PUSH
14472: LD_EXP 41
14476: PUSH
14477: LD_VAR 0 3
14481: ADD
14482: ST_TO_ADDR
// end ; end ;
14483: GO 14238
14485: POP
14486: POP
// end ; end_of_file
14487: LD_VAR 0 1
14491: RET
// export function Action ; begin
14492: LD_INT 0
14494: PPUSH
// InGameOn ;
14495: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
14499: LD_INT 151
14501: PPUSH
14502: LD_INT 107
14504: PPUSH
14505: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
14509: LD_EXP 37
14513: PPUSH
14514: LD_INT 171
14516: PPUSH
14517: LD_INT 108
14519: PPUSH
14520: LD_INT 0
14522: PPUSH
14523: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
14527: LD_EXP 38
14531: PPUSH
14532: LD_INT 172
14534: PPUSH
14535: LD_INT 110
14537: PPUSH
14538: LD_INT 0
14540: PPUSH
14541: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
14545: LD_EXP 37
14549: PPUSH
14550: LD_INT 156
14552: PPUSH
14553: LD_INT 107
14555: PPUSH
14556: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
14560: LD_EXP 38
14564: PPUSH
14565: LD_INT 154
14567: PPUSH
14568: LD_INT 105
14570: PPUSH
14571: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
14575: LD_INT 4
14577: PPUSH
14578: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
14582: LD_EXP 37
14586: PPUSH
14587: CALL_OW 250
14591: PUSH
14592: LD_INT 156
14594: EQUAL
14595: PUSH
14596: LD_EXP 37
14600: PPUSH
14601: CALL_OW 251
14605: PUSH
14606: LD_INT 107
14608: EQUAL
14609: AND
14610: IFFALSE 14575
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14612: LD_EXP 37
14616: PUSH
14617: LD_EXP 38
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: PPUSH
14626: LD_INT 35
14628: PPUSH
14629: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14633: LD_EXP 37
14637: PPUSH
14638: LD_STRING D1-A-1
14640: PPUSH
14641: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14645: LD_EXP 38
14649: PPUSH
14650: LD_STRING D1-B-1
14652: PPUSH
14653: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14657: LD_EXP 37
14661: PPUSH
14662: LD_STRING D1-A-2
14664: PPUSH
14665: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14669: LD_EXP 38
14673: PPUSH
14674: LD_STRING D1-B-2
14676: PPUSH
14677: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14681: LD_EXP 37
14685: PUSH
14686: LD_EXP 38
14690: PUSH
14691: EMPTY
14692: LIST
14693: LIST
14694: PPUSH
14695: LD_INT 147
14697: PPUSH
14698: LD_INT 108
14700: PPUSH
14701: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14705: LD_EXP 37
14709: PPUSH
14710: LD_STRING D1-A-3
14712: PPUSH
14713: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14717: LD_INT 4
14719: PPUSH
14720: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14724: LD_EXP 37
14728: PPUSH
14729: LD_INT 35
14731: PPUSH
14732: CALL_OW 296
14736: PUSH
14737: LD_INT 8
14739: LESS
14740: IFFALSE 14717
// ComTurnUnit ( guyA , guyB ) ;
14742: LD_EXP 37
14746: PPUSH
14747: LD_EXP 38
14751: PPUSH
14752: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14756: LD_EXP 38
14760: PPUSH
14761: LD_EXP 37
14765: PPUSH
14766: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14770: LD_EXP 37
14774: PPUSH
14775: LD_STRING D1-A-10
14777: PPUSH
14778: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14782: LD_EXP 38
14786: PPUSH
14787: LD_STRING D1-B-10
14789: PPUSH
14790: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14794: LD_EXP 37
14798: PPUSH
14799: LD_STRING D1-A-11
14801: PPUSH
14802: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14806: LD_EXP 38
14810: PPUSH
14811: LD_STRING D1-B-11
14813: PPUSH
14814: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14818: LD_EXP 37
14822: PPUSH
14823: LD_STRING D1-A-12
14825: PPUSH
14826: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14830: LD_EXP 38
14834: PPUSH
14835: LD_STRING D1-B-12
14837: PPUSH
14838: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14842: LD_EXP 37
14846: PPUSH
14847: LD_STRING D1-A-13
14849: PPUSH
14850: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14854: LD_EXP 38
14858: PPUSH
14859: LD_STRING D1-B-13
14861: PPUSH
14862: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14866: LD_EXP 37
14870: PPUSH
14871: LD_STRING D1-A-14
14873: PPUSH
14874: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14878: LD_EXP 38
14882: PPUSH
14883: LD_STRING D1-B-14
14885: PPUSH
14886: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14890: LD_EXP 37
14894: PPUSH
14895: LD_STRING D1-A-15
14897: PPUSH
14898: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14902: LD_EXP 38
14906: PPUSH
14907: LD_STRING D1-B-15
14909: PPUSH
14910: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14914: LD_EXP 37
14918: PPUSH
14919: LD_STRING D1-A-16
14921: PPUSH
14922: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14926: LD_EXP 38
14930: PPUSH
14931: LD_STRING D1-B-16
14933: PPUSH
14934: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14938: LD_EXP 37
14942: PPUSH
14943: LD_STRING D1-A-17
14945: PPUSH
14946: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14950: LD_EXP 38
14954: PPUSH
14955: LD_STRING D1-B-17
14957: PPUSH
14958: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
14962: LD_EXP 37
14966: PPUSH
14967: LD_STRING D1-A-18
14969: PPUSH
14970: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
14974: LD_INT 35
14976: PPUSH
14977: LD_INT 1
14979: PPUSH
14980: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
14984: LD_EXP 37
14988: PUSH
14989: LD_EXP 38
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PPUSH
14998: LD_INT 35
15000: PPUSH
15001: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
15005: LD_INT 4
15007: PPUSH
15008: CALL_OW 67
// until IsInUnit ( guyA ) ;
15012: LD_EXP 37
15016: PPUSH
15017: CALL_OW 310
15021: IFFALSE 15005
// Wait ( 0 0$02 ) ;
15023: LD_INT 70
15025: PPUSH
15026: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
15030: LD_EXP 37
15034: PPUSH
15035: LD_STRING D1-A-19
15037: PPUSH
15038: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
15042: LD_EXP 38
15046: PPUSH
15047: LD_STRING D1-B-19
15049: PPUSH
15050: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
15054: LD_EXP 37
15058: PPUSH
15059: LD_STRING D1-A-20
15061: PPUSH
15062: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
15066: LD_INT 10
15068: PPUSH
15069: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
15073: LD_EXP 38
15077: PPUSH
15078: LD_STRING D1-B-20
15080: PPUSH
15081: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
15085: LD_EXP 37
15089: PPUSH
15090: LD_STRING D1-A-21
15092: PPUSH
15093: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
15097: LD_EXP 38
15101: PPUSH
15102: LD_STRING D1-B-21
15104: PPUSH
15105: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
15109: LD_EXP 37
15113: PPUSH
15114: LD_STRING D1-A-22
15116: PPUSH
15117: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
15121: LD_EXP 38
15125: PPUSH
15126: LD_STRING D1-B-22
15128: PPUSH
15129: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
15133: LD_EXP 37
15137: PPUSH
15138: LD_STRING D1-A-23
15140: PPUSH
15141: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
15145: LD_EXP 38
15149: PPUSH
15150: LD_STRING D1-B-23
15152: PPUSH
15153: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
15157: LD_EXP 37
15161: PPUSH
15162: LD_STRING D1-A-24
15164: PPUSH
15165: CALL_OW 88
// InGameOff ;
15169: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
15173: LD_STRING M_main
15175: PPUSH
15176: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
15180: LD_INT 4
15182: PPUSH
15183: LD_INT 1
15185: PPUSH
15186: CALL_OW 343
// game_status := true ;
15190: LD_ADDR_EXP 28
15194: PUSH
15195: LD_INT 1
15197: ST_TO_ADDR
// end ;
15198: LD_VAR 0 1
15202: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
15203: LD_INT 1
15205: PPUSH
15206: CALL 6890 0 1
15210: PUSH
15211: LD_INT 0
15213: GREATER
15214: IFFALSE 15316
15216: GO 15218
15218: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15219: LD_INT 35
15221: PPUSH
15222: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
15226: LD_INT 1
15228: PPUSH
15229: CALL 6890 0 1
15233: PUSH
15234: LD_INT 1
15236: ARRAY
15237: PPUSH
15238: CALL_OW 461
15242: PUSH
15243: LD_INT 1
15245: NONEQUAL
15246: IFFALSE 15219
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
15248: LD_EXP 37
15252: PPUSH
15253: CALL_OW 300
15257: PUSH
15258: LD_EXP 38
15262: PPUSH
15263: CALL_OW 300
15267: AND
15268: PUSH
15269: LD_EXP 29
15273: NOT
15274: AND
15275: IFFALSE 15301
// begin Say ( guyA , DL-A-1 ) ;
15277: LD_EXP 37
15281: PPUSH
15282: LD_STRING DL-A-1
15284: PPUSH
15285: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
15289: LD_EXP 38
15293: PPUSH
15294: LD_STRING DL-B-1
15296: PPUSH
15297: CALL_OW 88
// end ; if not helps_can_arrive then
15301: LD_EXP 30
15305: NOT
15306: IFFALSE 15316
// helps_can_arrive := true ;
15308: LD_ADDR_EXP 30
15312: PUSH
15313: LD_INT 1
15315: ST_TO_ADDR
// end ;
15316: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
15317: LD_INT 1
15319: PPUSH
15320: CALL 6890 0 1
15324: PUSH
15325: LD_INT 0
15327: GREATER
15328: PUSH
15329: LD_EXP 37
15333: PPUSH
15334: CALL_OW 300
15338: AND
15339: PUSH
15340: LD_EXP 38
15344: PPUSH
15345: CALL_OW 300
15349: AND
15350: PUSH
15351: LD_INT 22
15353: PUSH
15354: LD_INT 1
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: PUSH
15361: LD_INT 25
15363: PUSH
15364: LD_INT 12
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PPUSH
15375: CALL_OW 69
15379: PUSH
15380: LD_INT 0
15382: EQUAL
15383: AND
15384: PUSH
15385: LD_INT 1
15387: PPUSH
15388: LD_INT 25
15390: PUSH
15391: LD_INT 12
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: PPUSH
15398: CALL_OW 69
15402: PPUSH
15403: LD_EXP 37
15407: PPUSH
15408: CALL_OW 74
15412: PPUSH
15413: CALL_OW 292
15417: AND
15418: IFFALSE 15459
15420: GO 15422
15422: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
15423: LD_EXP 37
15427: PPUSH
15428: LD_STRING DA-A-1
15430: PPUSH
15431: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
15435: LD_EXP 38
15439: PPUSH
15440: LD_STRING DA-B-1
15442: PPUSH
15443: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
15447: LD_EXP 37
15451: PPUSH
15452: LD_STRING DA-A-2
15454: PPUSH
15455: CALL_OW 88
// end ;
15459: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
15460: LD_EXP 28
15464: PUSH
15465: LD_EXP 37
15469: PPUSH
15470: LD_INT 6
15472: PPUSH
15473: CALL_OW 299
15477: PUSH
15478: LD_INT 7
15480: LESS
15481: AND
15482: IFFALSE 15535
15484: GO 15486
15486: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
15487: LD_INT 117
15489: PPUSH
15490: LD_INT 50
15492: PPUSH
15493: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
15497: LD_INT 1
15499: PPUSH
15500: CALL 10631 0 1
15504: PUSH
15505: LD_INT 2
15507: ARRAY
15508: PPUSH
15509: LD_STRING D5-A-1
15511: PPUSH
15512: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
15516: LD_INT 1
15518: PPUSH
15519: CALL 10631 0 1
15523: PUSH
15524: LD_INT 1
15526: ARRAY
15527: PPUSH
15528: LD_STRING D5-B-1
15530: PPUSH
15531: CALL_OW 88
// end ;
15535: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
15536: LD_INT 7
15538: PPUSH
15539: LD_INT 22
15541: PUSH
15542: LD_INT 1
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: PPUSH
15549: CALL_OW 70
15553: PUSH
15554: LD_INT 0
15556: GREATER
15557: IFFALSE 15702
15559: GO 15561
15561: DISABLE
// begin Wait ( 0 0$03 ) ;
15562: LD_INT 105
15564: PPUSH
15565: CALL_OW 67
// DialogueOn ;
15569: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
15573: LD_INT 1
15575: PPUSH
15576: CALL 10631 0 1
15580: PUSH
15581: LD_INT 1
15583: ARRAY
15584: PPUSH
15585: LD_STRING D6-A-1
15587: PPUSH
15588: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15592: LD_INT 1
15594: PPUSH
15595: CALL 10631 0 1
15599: PUSH
15600: LD_INT 2
15602: ARRAY
15603: PPUSH
15604: LD_STRING D6-B-1
15606: PPUSH
15607: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15611: LD_INT 95
15613: PPUSH
15614: LD_INT 8
15616: PPUSH
15617: LD_INT 1
15619: PPUSH
15620: LD_INT 20
15622: PPUSH
15623: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15627: LD_INT 10
15629: PPUSH
15630: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15634: LD_INT 1
15636: PPUSH
15637: CALL 10631 0 1
15641: PUSH
15642: LD_INT 1
15644: ARRAY
15645: PPUSH
15646: LD_STRING D6-A-2
15648: PPUSH
15649: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15653: LD_INT 1
15655: PPUSH
15656: CALL 10631 0 1
15660: PUSH
15661: LD_INT 2
15663: ARRAY
15664: PPUSH
15665: LD_STRING D6-B-2
15667: PPUSH
15668: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15672: LD_INT 1
15674: PPUSH
15675: CALL 10631 0 1
15679: PUSH
15680: LD_INT 1
15682: ARRAY
15683: PPUSH
15684: LD_STRING D6-A-3
15686: PPUSH
15687: CALL_OW 88
// DialogueOff ;
15691: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15695: LD_STRING M_base
15697: PPUSH
15698: CALL_OW 337
// end ;
15702: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15703: LD_EXP 29
15707: NOT
15708: PUSH
15709: LD_INT 22
15711: PUSH
15712: LD_INT 3
15714: PUSH
15715: EMPTY
15716: LIST
15717: LIST
15718: PUSH
15719: LD_INT 21
15721: PUSH
15722: LD_INT 2
15724: PUSH
15725: EMPTY
15726: LIST
15727: LIST
15728: PUSH
15729: EMPTY
15730: LIST
15731: LIST
15732: PPUSH
15733: CALL_OW 69
15737: PUSH
15738: LD_INT 0
15740: GREATER
15741: AND
15742: IFFALSE 15875
15744: GO 15746
15746: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15747: LD_INT 35
15749: PPUSH
15750: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15754: LD_INT 22
15756: PUSH
15757: LD_INT 3
15759: PUSH
15760: EMPTY
15761: LIST
15762: LIST
15763: PUSH
15764: LD_INT 21
15766: PUSH
15767: LD_INT 2
15769: PUSH
15770: EMPTY
15771: LIST
15772: LIST
15773: PUSH
15774: EMPTY
15775: LIST
15776: LIST
15777: PPUSH
15778: CALL_OW 69
15782: PPUSH
15783: LD_INT 1
15785: PPUSH
15786: CALL 10631 0 1
15790: PUSH
15791: LD_INT 1
15793: ARRAY
15794: PPUSH
15795: CALL_OW 74
15799: PPUSH
15800: LD_INT 1
15802: PPUSH
15803: CALL 10631 0 1
15807: PUSH
15808: LD_INT 1
15810: ARRAY
15811: PPUSH
15812: CALL_OW 296
15816: PUSH
15817: LD_INT 7
15819: LESS
15820: IFFALSE 15747
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15822: LD_INT 1
15824: PPUSH
15825: CALL 10631 0 1
15829: PUSH
15830: LD_INT 1
15832: ARRAY
15833: PPUSH
15834: LD_STRING DR-A-1
15836: PPUSH
15837: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15841: LD_INT 1
15843: PPUSH
15844: CALL 10631 0 1
15848: PUSH
15849: LD_INT 2
15851: ARRAY
15852: PPUSH
15853: LD_STRING DR-B-1
15855: PPUSH
15856: CALL_OW 88
// Wait ( 3 3$00 ) ;
15860: LD_INT 6300
15862: PPUSH
15863: CALL_OW 67
// ru_spotted := true ;
15867: LD_ADDR_EXP 15
15871: PUSH
15872: LD_INT 1
15874: ST_TO_ADDR
// end ;
15875: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15876: LD_INT 35
15878: PPUSH
15879: CALL_OW 300
15883: NOT
15884: IFFALSE 15908
15886: GO 15888
15888: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15889: LD_INT 1
15891: PPUSH
15892: CALL 10631 0 1
15896: PUSH
15897: LD_INT 1
15899: ARRAY
15900: PPUSH
15901: LD_STRING DDR-A-1
15903: PPUSH
15904: CALL_OW 88
15908: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15909: LD_INT 1
15911: PPUSH
15912: LD_INT 30
15914: PPUSH
15915: CALL 6739 0 2
15919: IFFALSE 16001
15921: GO 15923
15923: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15924: LD_INT 35
15926: PPUSH
15927: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15931: LD_INT 1
15933: PPUSH
15934: LD_INT 30
15936: PPUSH
15937: CALL 6739 0 2
15941: PUSH
15942: LD_INT 1
15944: ARRAY
15945: PPUSH
15946: CALL_OW 461
15950: PUSH
15951: LD_INT 1
15953: NONEQUAL
15954: IFFALSE 15924
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15956: LD_INT 1
15958: PPUSH
15959: CALL 10631 0 1
15963: PUSH
15964: LD_INT 1
15966: ARRAY
15967: PPUSH
15968: LD_STRING D8-A-1
15970: PPUSH
15971: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
15975: LD_INT 1
15977: PPUSH
15978: CALL 10631 0 1
15982: PUSH
15983: LD_INT 2
15985: ARRAY
15986: PPUSH
15987: LD_STRING D8-B-1
15989: PPUSH
15990: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
15994: LD_STRING M_mineok
15996: PPUSH
15997: CALL_OW 337
// end ;
16001: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
16002: LD_INT 22
16004: PUSH
16005: LD_INT 1
16007: PUSH
16008: EMPTY
16009: LIST
16010: LIST
16011: PUSH
16012: LD_INT 30
16014: PUSH
16015: LD_INT 0
16017: PUSH
16018: EMPTY
16019: LIST
16020: LIST
16021: PUSH
16022: LD_INT 3
16024: PUSH
16025: LD_INT 57
16027: PUSH
16028: EMPTY
16029: LIST
16030: PUSH
16031: EMPTY
16032: LIST
16033: LIST
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: LIST
16039: PPUSH
16040: CALL_OW 69
16044: PUSH
16045: LD_INT 1
16047: GREATER
16048: PUSH
16049: LD_INT 22
16051: PUSH
16052: LD_INT 1
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: PUSH
16059: LD_INT 30
16061: PUSH
16062: LD_INT 0
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: PUSH
16069: LD_INT 3
16071: PUSH
16072: LD_INT 57
16074: PUSH
16075: EMPTY
16076: LIST
16077: PUSH
16078: EMPTY
16079: LIST
16080: LIST
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: LIST
16086: PPUSH
16087: CALL_OW 69
16091: PUSH
16092: LD_INT 1
16094: EQUAL
16095: PUSH
16096: LD_INT 35
16098: PPUSH
16099: CALL_OW 300
16103: NOT
16104: AND
16105: OR
16106: IFFALSE 16158
16108: GO 16110
16110: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
16111: LD_INT 22
16113: PUSH
16114: LD_INT 1
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: PUSH
16121: LD_INT 25
16123: PUSH
16124: LD_INT 2
16126: PUSH
16127: EMPTY
16128: LIST
16129: LIST
16130: PUSH
16131: EMPTY
16132: LIST
16133: LIST
16134: PPUSH
16135: CALL_OW 69
16139: PUSH
16140: LD_INT 1
16142: ARRAY
16143: PPUSH
16144: LD_STRING D7-A-1
16146: PPUSH
16147: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
16151: LD_STRING M_baseok
16153: PPUSH
16154: CALL_OW 337
// end ;
16158: END
// every 0 0$01 trigger mine_ck do
16159: LD_EXP 34
16163: IFFALSE 16194
16165: GO 16167
16167: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
16168: LD_INT 1
16170: PPUSH
16171: CALL 10631 0 1
16175: PUSH
16176: LD_INT 1
16178: ARRAY
16179: PPUSH
16180: LD_STRING D9-A-1
16182: PPUSH
16183: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
16187: LD_STRING M_minedest
16189: PPUSH
16190: CALL_OW 337
// end ;
16194: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
16195: LD_EXP 28
16199: IFFALSE 16705
16201: GO 16203
16203: DISABLE
16204: LD_INT 0
16206: PPUSH
16207: PPUSH
16208: PPUSH
16209: PPUSH
16210: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
16211: LD_OWVAR 67
16215: PPUSH
16216: CALL 12532 0 1
// if not helps_can_arrive then
16220: LD_EXP 30
16224: NOT
16225: IFFALSE 16253
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
16227: LD_EXP 39
16231: PUSH
16232: LD_INT 1
16234: ARRAY
16235: PPUSH
16236: LD_STRING DB-Delay
16238: PPUSH
16239: CALL_OW 94
// time := 10 10$00 ;
16243: LD_ADDR_VAR 0 1
16247: PUSH
16248: LD_INT 21000
16250: ST_TO_ADDR
// end else
16251: GO 16261
// time := 3 3$00 ;
16253: LD_ADDR_VAR 0 1
16257: PUSH
16258: LD_INT 6300
16260: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
16261: LD_ADDR_VAR 0 1
16265: PUSH
16266: LD_VAR 0 1
16270: PUSH
16271: LD_INT 35
16273: MINUS
16274: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
16275: LD_INT 35
16277: PPUSH
16278: CALL_OW 67
// end until time = 0 0$00 ;
16282: LD_VAR 0 1
16286: PUSH
16287: LD_INT 0
16289: EQUAL
16290: IFFALSE 16261
// helps_arrive := true ;
16292: LD_ADDR_EXP 29
16296: PUSH
16297: LD_INT 1
16299: ST_TO_ADDR
// if IsLive ( guyA ) then
16300: LD_EXP 37
16304: PPUSH
16305: CALL_OW 300
16309: IFFALSE 16323
// r := guyA else
16311: LD_ADDR_VAR 0 4
16315: PUSH
16316: LD_EXP 37
16320: ST_TO_ADDR
16321: GO 16333
// r := guyB ;
16323: LD_ADDR_VAR 0 4
16327: PUSH
16328: LD_EXP 38
16332: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
16333: LD_EXP 39
16337: PUSH
16338: LD_INT 1
16340: ARRAY
16341: PPUSH
16342: LD_STRING D2-A-1
16344: PPUSH
16345: CALL_OW 94
// Say ( r , D2-B-1 ) ;
16349: LD_VAR 0 4
16353: PPUSH
16354: LD_STRING D2-B-1
16356: PPUSH
16357: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
16361: LD_EXP 39
16365: PUSH
16366: LD_INT 1
16368: ARRAY
16369: PPUSH
16370: LD_STRING D2-A-2
16372: PPUSH
16373: CALL_OW 94
// Say ( r , D2-B-2 ) ;
16377: LD_VAR 0 4
16381: PPUSH
16382: LD_STRING D2-B-2
16384: PPUSH
16385: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
16389: LD_EXP 39
16393: PUSH
16394: LD_INT 1
16396: ARRAY
16397: PPUSH
16398: LD_STRING D2-A-3
16400: PPUSH
16401: CALL_OW 94
// Say ( r , D2-B-3 ) ;
16405: LD_VAR 0 4
16409: PPUSH
16410: LD_STRING D2-B-3
16412: PPUSH
16413: CALL_OW 88
// to_veh := [ ] ;
16417: LD_ADDR_VAR 0 5
16421: PUSH
16422: EMPTY
16423: ST_TO_ADDR
// for i = 1 to Beta_Squad do
16424: LD_ADDR_VAR 0 2
16428: PUSH
16429: DOUBLE
16430: LD_INT 1
16432: DEC
16433: ST_TO_ADDR
16434: LD_EXP 39
16438: PUSH
16439: FOR_TO
16440: IFFALSE 16703
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
16442: LD_EXP 39
16446: PUSH
16447: LD_VAR 0 2
16451: ARRAY
16452: PPUSH
16453: CALL_OW 110
16457: PUSH
16458: LD_INT 3
16460: EQUAL
16461: IFFALSE 16487
// to_veh := to_veh ^ Beta_Squad [ i ] else
16463: LD_ADDR_VAR 0 5
16467: PUSH
16468: LD_VAR 0 5
16472: PUSH
16473: LD_EXP 39
16477: PUSH
16478: LD_VAR 0 2
16482: ARRAY
16483: ADD
16484: ST_TO_ADDR
16485: GO 16612
// if GetTag ( Beta_Squad [ i ] ) = 5 then
16487: LD_EXP 39
16491: PUSH
16492: LD_VAR 0 2
16496: ARRAY
16497: PPUSH
16498: CALL_OW 110
16502: PUSH
16503: LD_INT 5
16505: EQUAL
16506: IFFALSE 16591
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
16508: LD_EXP 39
16512: PUSH
16513: LD_VAR 0 2
16517: ARRAY
16518: PPUSH
16519: LD_INT 4
16521: PPUSH
16522: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16526: LD_EXP 39
16530: PUSH
16531: LD_VAR 0 2
16535: ARRAY
16536: PPUSH
16537: LD_INT 5
16539: PPUSH
16540: LD_INT 0
16542: PPUSH
16543: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
16547: LD_VAR 0 5
16551: PUSH
16552: LD_INT 1
16554: ARRAY
16555: PPUSH
16556: LD_EXP 39
16560: PUSH
16561: LD_VAR 0 2
16565: ARRAY
16566: PPUSH
16567: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16571: LD_ADDR_VAR 0 5
16575: PUSH
16576: LD_VAR 0 5
16580: PPUSH
16581: LD_INT 1
16583: PPUSH
16584: CALL_OW 3
16588: ST_TO_ADDR
// end else
16589: GO 16612
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16591: LD_EXP 39
16595: PUSH
16596: LD_VAR 0 2
16600: ARRAY
16601: PPUSH
16602: LD_INT 5
16604: PPUSH
16605: LD_INT 0
16607: PPUSH
16608: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16612: LD_EXP 39
16616: PUSH
16617: LD_VAR 0 2
16621: ARRAY
16622: PPUSH
16623: LD_INT 165
16625: PPUSH
16626: LD_INT 105
16628: PPUSH
16629: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16633: LD_INT 70
16635: PPUSH
16636: LD_INT 140
16638: PPUSH
16639: CALL_OW 12
16643: PPUSH
16644: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16648: LD_EXP 39
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: PPUSH
16659: LD_INT 1
16661: PPUSH
16662: CALL_OW 235
// if i = 1 then
16666: LD_VAR 0 2
16670: PUSH
16671: LD_INT 1
16673: EQUAL
16674: IFFALSE 16686
// CenterNowOnXY ( 168 , 109 ) ;
16676: LD_INT 168
16678: PPUSH
16679: LD_INT 109
16681: PPUSH
16682: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16686: LD_EXP 39
16690: PUSH
16691: LD_VAR 0 2
16695: ARRAY
16696: PPUSH
16697: CALL_OW 141
// end ;
16701: GO 16439
16703: POP
16704: POP
// end ;
16705: PPOPN 5
16707: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16708: LD_EXP 29
16712: IFFALSE 17741
16714: GO 16716
16716: DISABLE
16717: LD_INT 0
16719: PPUSH
16720: PPUSH
// begin Wait ( 5 5$00 ) ;
16721: LD_INT 10500
16723: PPUSH
16724: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16728: LD_OWVAR 67
16732: PPUSH
16733: CALL 13221 0 1
// to_veh := [ ] ;
16737: LD_ADDR_VAR 0 2
16741: PUSH
16742: EMPTY
16743: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16744: LD_ADDR_VAR 0 1
16748: PUSH
16749: DOUBLE
16750: LD_INT 1
16752: DEC
16753: ST_TO_ADDR
16754: LD_EXP 40
16758: PUSH
16759: FOR_TO
16760: IFFALSE 16988
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16762: LD_EXP 40
16766: PUSH
16767: LD_VAR 0 1
16771: ARRAY
16772: PPUSH
16773: CALL_OW 110
16777: PUSH
16778: LD_INT 3
16780: EQUAL
16781: IFFALSE 16807
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16783: LD_ADDR_VAR 0 2
16787: PUSH
16788: LD_VAR 0 2
16792: PUSH
16793: LD_EXP 40
16797: PUSH
16798: LD_VAR 0 1
16802: ARRAY
16803: ADD
16804: ST_TO_ADDR
16805: GO 16932
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16807: LD_EXP 40
16811: PUSH
16812: LD_VAR 0 1
16816: ARRAY
16817: PPUSH
16818: CALL_OW 110
16822: PUSH
16823: LD_INT 5
16825: EQUAL
16826: IFFALSE 16911
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16828: LD_EXP 40
16832: PUSH
16833: LD_VAR 0 1
16837: ARRAY
16838: PPUSH
16839: LD_INT 4
16841: PPUSH
16842: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16846: LD_EXP 40
16850: PUSH
16851: LD_VAR 0 1
16855: ARRAY
16856: PPUSH
16857: LD_INT 5
16859: PPUSH
16860: LD_INT 0
16862: PPUSH
16863: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16867: LD_VAR 0 2
16871: PUSH
16872: LD_INT 1
16874: ARRAY
16875: PPUSH
16876: LD_EXP 40
16880: PUSH
16881: LD_VAR 0 1
16885: ARRAY
16886: PPUSH
16887: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16891: LD_ADDR_VAR 0 2
16895: PUSH
16896: LD_VAR 0 2
16900: PPUSH
16901: LD_INT 1
16903: PPUSH
16904: CALL_OW 3
16908: ST_TO_ADDR
// end else
16909: GO 16932
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16911: LD_EXP 40
16915: PUSH
16916: LD_VAR 0 1
16920: ARRAY
16921: PPUSH
16922: LD_INT 5
16924: PPUSH
16925: LD_INT 0
16927: PPUSH
16928: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16932: LD_EXP 40
16936: PUSH
16937: LD_VAR 0 1
16941: ARRAY
16942: PPUSH
16943: LD_INT 164
16945: PPUSH
16946: LD_INT 104
16948: PPUSH
16949: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16953: LD_INT 70
16955: PPUSH
16956: LD_INT 140
16958: PPUSH
16959: CALL_OW 12
16963: PPUSH
16964: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16968: LD_EXP 40
16972: PUSH
16973: LD_VAR 0 1
16977: ARRAY
16978: PPUSH
16979: LD_INT 1
16981: PPUSH
16982: CALL_OW 235
// end ;
16986: GO 16759
16988: POP
16989: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
16990: LD_EXP 40
16994: PUSH
16995: LD_INT 1
16997: ARRAY
16998: PPUSH
16999: LD_STRING D3-A-1
17001: PPUSH
17002: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
17006: LD_INT 1
17008: PPUSH
17009: CALL 10631 0 1
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: PPUSH
17018: LD_STRING D3-B-1
17020: PPUSH
17021: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
17025: LD_EXP 40
17029: PUSH
17030: LD_INT 1
17032: ARRAY
17033: PPUSH
17034: LD_STRING D3-A-2
17036: PPUSH
17037: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
17041: LD_INT 1
17043: PPUSH
17044: CALL 10631 0 1
17048: PUSH
17049: LD_INT 1
17051: ARRAY
17052: PPUSH
17053: LD_STRING D3-B-2
17055: PPUSH
17056: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
17060: LD_EXP 40
17064: PUSH
17065: LD_INT 1
17067: ARRAY
17068: PPUSH
17069: LD_STRING D3-A-3
17071: PPUSH
17072: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
17076: LD_INT 1
17078: PPUSH
17079: CALL 10631 0 1
17083: PUSH
17084: LD_INT 1
17086: ARRAY
17087: PPUSH
17088: LD_STRING D3-B-3
17090: PPUSH
17091: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
17095: LD_EXP 40
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: PPUSH
17104: LD_STRING D3-A-4
17106: PPUSH
17107: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
17111: LD_INT 1
17113: PPUSH
17114: CALL 10631 0 1
17118: PUSH
17119: LD_INT 1
17121: ARRAY
17122: PPUSH
17123: LD_STRING D3-B-4
17125: PPUSH
17126: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
17130: LD_EXP 40
17134: PUSH
17135: LD_INT 1
17137: ARRAY
17138: PPUSH
17139: LD_STRING D3-A-5
17141: PPUSH
17142: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
17146: LD_INT 1
17148: PPUSH
17149: CALL 10631 0 1
17153: PUSH
17154: LD_INT 1
17156: ARRAY
17157: PPUSH
17158: LD_STRING D3-B-5
17160: PPUSH
17161: CALL_OW 88
// for i = 1 to Gamma_Squad do
17165: LD_ADDR_VAR 0 1
17169: PUSH
17170: DOUBLE
17171: LD_INT 1
17173: DEC
17174: ST_TO_ADDR
17175: LD_EXP 40
17179: PUSH
17180: FOR_TO
17181: IFFALSE 17203
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
17183: LD_EXP 40
17187: PUSH
17188: LD_VAR 0 1
17192: ARRAY
17193: PPUSH
17194: LD_INT 1
17196: PPUSH
17197: CALL_OW 235
17201: GO 17180
17203: POP
17204: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
17205: LD_INT 6300
17207: PUSH
17208: LD_INT 10500
17210: PUSH
17211: LD_INT 11550
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: PUSH
17219: LD_OWVAR 67
17223: ARRAY
17224: PPUSH
17225: CALL_OW 67
// AddZetaSquad ;
17229: CALL 13950 0 0
// Wait ( 0 0$10 ) ;
17233: LD_INT 350
17235: PPUSH
17236: CALL_OW 67
// to_veh := [ ] ;
17240: LD_ADDR_VAR 0 2
17244: PUSH
17245: EMPTY
17246: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
17247: LD_ADDR_VAR 0 1
17251: PUSH
17252: DOUBLE
17253: LD_INT 1
17255: DEC
17256: ST_TO_ADDR
17257: LD_EXP 41
17261: PUSH
17262: FOR_TO
17263: IFFALSE 17473
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
17265: LD_EXP 41
17269: PUSH
17270: LD_VAR 0 1
17274: ARRAY
17275: PPUSH
17276: CALL_OW 110
17280: PUSH
17281: LD_INT 3
17283: EQUAL
17284: IFFALSE 17310
// to_veh := to_veh ^ Zeta_Squad [ i ] else
17286: LD_ADDR_VAR 0 2
17290: PUSH
17291: LD_VAR 0 2
17295: PUSH
17296: LD_EXP 41
17300: PUSH
17301: LD_VAR 0 1
17305: ARRAY
17306: ADD
17307: ST_TO_ADDR
17308: GO 17435
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
17310: LD_EXP 41
17314: PUSH
17315: LD_VAR 0 1
17319: ARRAY
17320: PPUSH
17321: CALL_OW 110
17325: PUSH
17326: LD_INT 5
17328: EQUAL
17329: IFFALSE 17414
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
17331: LD_EXP 41
17335: PUSH
17336: LD_VAR 0 1
17340: ARRAY
17341: PPUSH
17342: LD_INT 4
17344: PPUSH
17345: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17349: LD_EXP 41
17353: PUSH
17354: LD_VAR 0 1
17358: ARRAY
17359: PPUSH
17360: LD_INT 5
17362: PPUSH
17363: LD_INT 0
17365: PPUSH
17366: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 1
17377: ARRAY
17378: PPUSH
17379: LD_EXP 41
17383: PUSH
17384: LD_VAR 0 1
17388: ARRAY
17389: PPUSH
17390: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
17394: LD_ADDR_VAR 0 2
17398: PUSH
17399: LD_VAR 0 2
17403: PPUSH
17404: LD_INT 1
17406: PPUSH
17407: CALL_OW 3
17411: ST_TO_ADDR
// end else
17412: GO 17435
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17414: LD_EXP 41
17418: PUSH
17419: LD_VAR 0 1
17423: ARRAY
17424: PPUSH
17425: LD_INT 5
17427: PPUSH
17428: LD_INT 0
17430: PPUSH
17431: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
17435: LD_EXP 41
17439: PUSH
17440: LD_VAR 0 1
17444: ARRAY
17445: PPUSH
17446: LD_INT 165
17448: PPUSH
17449: LD_INT 105
17451: PPUSH
17452: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
17456: LD_INT 70
17458: PPUSH
17459: LD_INT 140
17461: PPUSH
17462: CALL_OW 12
17466: PPUSH
17467: CALL_OW 67
// end ;
17471: GO 17262
17473: POP
17474: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
17475: LD_EXP 41
17479: PUSH
17480: LD_INT 1
17482: ARRAY
17483: PPUSH
17484: LD_STRING D4-A-1
17486: PPUSH
17487: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
17491: LD_INT 1
17493: PPUSH
17494: CALL 10631 0 1
17498: PUSH
17499: LD_INT 1
17501: ARRAY
17502: PPUSH
17503: LD_STRING D4-B-1
17505: PPUSH
17506: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
17510: LD_EXP 41
17514: PUSH
17515: LD_INT 1
17517: ARRAY
17518: PPUSH
17519: LD_STRING D4-A-2
17521: PPUSH
17522: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
17526: LD_INT 1
17528: PPUSH
17529: CALL 10631 0 1
17533: PUSH
17534: LD_INT 1
17536: ARRAY
17537: PPUSH
17538: LD_STRING D4-B-2
17540: PPUSH
17541: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
17545: LD_EXP 41
17549: PUSH
17550: LD_INT 1
17552: ARRAY
17553: PPUSH
17554: LD_STRING D4-A-3
17556: PPUSH
17557: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
17561: LD_INT 1
17563: PPUSH
17564: CALL 10631 0 1
17568: PUSH
17569: LD_INT 1
17571: ARRAY
17572: PPUSH
17573: LD_STRING D4-B-3
17575: PPUSH
17576: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
17580: LD_EXP 41
17584: PUSH
17585: LD_INT 1
17587: ARRAY
17588: PPUSH
17589: LD_STRING D4-A-4
17591: PPUSH
17592: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17596: LD_INT 1
17598: PPUSH
17599: CALL 10631 0 1
17603: PUSH
17604: LD_INT 1
17606: ARRAY
17607: PPUSH
17608: LD_STRING D4-B-4
17610: PPUSH
17611: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17615: LD_EXP 41
17619: PUSH
17620: LD_INT 1
17622: ARRAY
17623: PPUSH
17624: LD_STRING D4-A-5
17626: PPUSH
17627: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17631: LD_INT 1
17633: PPUSH
17634: CALL 10631 0 1
17638: PUSH
17639: LD_INT 1
17641: ARRAY
17642: PPUSH
17643: LD_STRING D4-B-5
17645: PPUSH
17646: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17650: LD_EXP 41
17654: PUSH
17655: LD_INT 1
17657: ARRAY
17658: PPUSH
17659: LD_STRING D4-A-6
17661: PPUSH
17662: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17666: LD_INT 1
17668: PPUSH
17669: CALL 10631 0 1
17673: PUSH
17674: LD_INT 1
17676: ARRAY
17677: PPUSH
17678: LD_STRING D4-B-6
17680: PPUSH
17681: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17685: LD_EXP 41
17689: PUSH
17690: LD_INT 1
17692: ARRAY
17693: PPUSH
17694: LD_STRING D4-A-7
17696: PPUSH
17697: CALL_OW 94
// for i = 1 to Zeta_Squad do
17701: LD_ADDR_VAR 0 1
17705: PUSH
17706: DOUBLE
17707: LD_INT 1
17709: DEC
17710: ST_TO_ADDR
17711: LD_EXP 41
17715: PUSH
17716: FOR_TO
17717: IFFALSE 17739
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17719: LD_EXP 41
17723: PUSH
17724: LD_VAR 0 1
17728: ARRAY
17729: PPUSH
17730: LD_INT 1
17732: PPUSH
17733: CALL_OW 235
17737: GO 17716
17739: POP
17740: POP
// end ;
17741: PPOPN 2
17743: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17744: LD_INT 11
17746: PPUSH
17747: LD_INT 22
17749: PUSH
17750: LD_OWVAR 2
17754: PUSH
17755: EMPTY
17756: LIST
17757: LIST
17758: PPUSH
17759: CALL_OW 70
17763: PUSH
17764: LD_INT 0
17766: GREATER
17767: IFFALSE 17792
17769: GO 17771
17771: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17772: LD_EXP 37
17776: PPUSH
17777: LD_STRING D10-A-1
17779: PPUSH
17780: CALL_OW 88
// ru_spotted := true ;
17784: LD_ADDR_EXP 15
17788: PUSH
17789: LD_INT 1
17791: ST_TO_ADDR
// end ;
17792: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17793: LD_EXP 37
17797: PPUSH
17798: CALL_OW 301
17802: PUSH
17803: LD_EXP 38
17807: PPUSH
17808: CALL_OW 301
17812: OR
17813: IFFALSE 17825
17815: GO 17817
17817: DISABLE
// begin YouLost ( DieP ) ;
17818: LD_STRING DieP
17820: PPUSH
17821: CALL_OW 104
// end ;
17825: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17826: LD_INT 34
17828: PUSH
17829: LD_INT 8
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: PPUSH
17836: CALL_OW 69
17840: IFFALSE 17853
17842: GO 17844
17844: DISABLE
// sib_bomb_constructed := true ;
17845: LD_ADDR_EXP 35
17849: PUSH
17850: LD_INT 1
17852: ST_TO_ADDR
17853: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17854: LD_EXP 28
17858: PUSH
17859: LD_INT 22
17861: PUSH
17862: LD_INT 3
17864: PUSH
17865: EMPTY
17866: LIST
17867: LIST
17868: PPUSH
17869: CALL_OW 69
17873: PUSH
17874: LD_INT 0
17876: EQUAL
17877: AND
17878: IFFALSE 18050
17880: GO 17882
17882: DISABLE
17883: LD_INT 0
17885: PPUSH
// begin game_status := false ;
17886: LD_ADDR_EXP 28
17890: PUSH
17891: LD_INT 0
17893: ST_TO_ADDR
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17894: LD_OWVAR 1
17898: PUSH
17899: LD_INT 35
17901: DIVREAL
17902: PUSH
17903: LD_INT 60
17905: DIVREAL
17906: PUSH
17907: LD_INT 70
17909: PUSH
17910: LD_INT 60
17912: PUSH
17913: LD_INT 50
17915: PUSH
17916: EMPTY
17917: LIST
17918: LIST
17919: LIST
17920: PUSH
17921: LD_OWVAR 67
17925: ARRAY
17926: LESS
17927: IFFALSE 17941
// AddMedal ( play , 1 ) else
17929: LD_STRING play
17931: PPUSH
17932: LD_INT 1
17934: PPUSH
17935: CALL_OW 101
17939: GO 17952
// AddMedal ( play , - 1 ) ;
17941: LD_STRING play
17943: PPUSH
17944: LD_INT 1
17946: NEG
17947: PPUSH
17948: CALL_OW 101
// if sib_bomb_constructed then
17952: LD_EXP 35
17956: IFFALSE 17970
// AddMedal ( sibbomb , 1 ) else
17958: LD_STRING sibbomb
17960: PPUSH
17961: LD_INT 1
17963: PPUSH
17964: CALL_OW 101
17968: GO 17981
// AddMedal ( sibbomb , - 1 ) ;
17970: LD_STRING sibbomb
17972: PPUSH
17973: LD_INT 1
17975: NEG
17976: PPUSH
17977: CALL_OW 101
// if mine_constructed and not mine_ck then
17981: LD_EXP 36
17985: PUSH
17986: LD_EXP 34
17990: NOT
17991: AND
17992: IFFALSE 18004
// AddMedal ( mine , 1 ) ;
17994: LD_STRING mine
17996: PPUSH
17997: LD_INT 1
17999: PPUSH
18000: CALL_OW 101
// if mine_ck then
18004: LD_EXP 34
18008: IFFALSE 18021
// AddMedal ( mine , - 1 ) ;
18010: LD_STRING mine
18012: PPUSH
18013: LD_INT 1
18015: NEG
18016: PPUSH
18017: CALL_OW 101
// if not mine_constructed then
18021: LD_EXP 36
18025: NOT
18026: IFFALSE 18039
// AddMedal ( mine , - 2 ) ;
18028: LD_STRING mine
18030: PPUSH
18031: LD_INT 2
18033: NEG
18034: PPUSH
18035: CALL_OW 101
// GiveMedals ( Main ) ;
18039: LD_STRING Main
18041: PPUSH
18042: CALL_OW 102
// YouWin ;
18046: CALL_OW 103
// end ; end_of_file
18050: PPOPN 1
18052: END
// every 0 0$03 trigger game_status do var time ;
18053: LD_EXP 28
18057: IFFALSE 18222
18059: GO 18061
18061: DISABLE
18062: LD_INT 0
18064: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
18065: LD_ADDR_VAR 0 1
18069: PUSH
18070: LD_INT 1050
18072: PUSH
18073: LD_INT 1575
18075: PUSH
18076: LD_INT 2100
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: LIST
18083: PUSH
18084: LD_OWVAR 67
18088: ARRAY
18089: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
18090: LD_VAR 0 1
18094: PUSH
18095: LD_INT 0
18097: PPUSH
18098: LD_INT 420
18100: PPUSH
18101: CALL_OW 12
18105: PLUS
18106: PPUSH
18107: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
18111: LD_INT 1
18113: PPUSH
18114: LD_INT 5
18116: PPUSH
18117: CALL_OW 12
18121: PPUSH
18122: LD_INT 1
18124: PPUSH
18125: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
18129: LD_INT 105
18131: PPUSH
18132: LD_INT 1050
18134: PPUSH
18135: CALL_OW 12
18139: PPUSH
18140: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
18144: LD_INT 1
18146: PPUSH
18147: LD_INT 5
18149: PPUSH
18150: CALL_OW 12
18154: PPUSH
18155: LD_INT 148
18157: PPUSH
18158: LD_INT 107
18160: PPUSH
18161: LD_INT 20
18163: PPUSH
18164: LD_INT 1
18166: PPUSH
18167: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
18171: LD_OWVAR 1
18175: PUSH
18176: LD_INT 44100
18178: PUSH
18179: LD_INT 37800
18181: PUSH
18182: LD_INT 33600
18184: PUSH
18185: EMPTY
18186: LIST
18187: LIST
18188: LIST
18189: PUSH
18190: LD_OWVAR 67
18194: ARRAY
18195: MOD
18196: IFFALSE 18212
// time := time + 0 0$20 ;
18198: LD_ADDR_VAR 0 1
18202: PUSH
18203: LD_VAR 0 1
18207: PUSH
18208: LD_INT 700
18210: PLUS
18211: ST_TO_ADDR
// end until game_status = false ;
18212: LD_EXP 28
18216: PUSH
18217: LD_INT 0
18219: EQUAL
18220: IFFALSE 18090
// end ;
18222: PPOPN 1
18224: END
// every 0 0$03 trigger game_status do var time ;
18225: LD_EXP 28
18229: IFFALSE 18383
18231: GO 18233
18233: DISABLE
18234: LD_INT 0
18236: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
18237: LD_ADDR_VAR 0 1
18241: PUSH
18242: LD_INT 700
18244: PUSH
18245: LD_INT 875
18247: PUSH
18248: LD_INT 1400
18250: PUSH
18251: EMPTY
18252: LIST
18253: LIST
18254: LIST
18255: PUSH
18256: LD_OWVAR 67
18260: ARRAY
18261: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18262: LD_VAR 0 1
18266: PUSH
18267: LD_INT 0
18269: PPUSH
18270: LD_INT 385
18272: PPUSH
18273: CALL_OW 12
18277: PLUS
18278: PPUSH
18279: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
18283: LD_INT 1
18285: PPUSH
18286: LD_INT 5
18288: PPUSH
18289: CALL_OW 12
18293: PPUSH
18294: LD_INT 102
18296: PPUSH
18297: LD_INT 6
18299: PPUSH
18300: LD_INT 25
18302: PPUSH
18303: LD_INT 1
18305: PPUSH
18306: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
18310: LD_OWVAR 1
18314: PUSH
18315: LD_INT 52500
18317: PUSH
18318: LD_INT 46200
18320: PUSH
18321: LD_INT 42000
18323: PUSH
18324: EMPTY
18325: LIST
18326: LIST
18327: LIST
18328: PUSH
18329: LD_OWVAR 67
18333: ARRAY
18334: MOD
18335: IFFALSE 18351
// time := time + 0 0$25 ;
18337: LD_ADDR_VAR 0 1
18341: PUSH
18342: LD_VAR 0 1
18346: PUSH
18347: LD_INT 875
18349: PLUS
18350: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
18351: LD_OWVAR 1
18355: PUSH
18356: LD_INT 231000
18358: MOD
18359: PUSH
18360: LD_INT 0
18362: EQUAL
18363: IFFALSE 18373
// time := 0 0$30 ;
18365: LD_ADDR_VAR 0 1
18369: PUSH
18370: LD_INT 1050
18372: ST_TO_ADDR
// end until game_status = false ;
18373: LD_EXP 28
18377: PUSH
18378: LD_INT 0
18380: EQUAL
18381: IFFALSE 18262
// end ;
18383: PPOPN 1
18385: END
// every 0 0$03 trigger game_status do var time ;
18386: LD_EXP 28
18390: IFFALSE 18526
18392: GO 18394
18394: DISABLE
18395: LD_INT 0
18397: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
18398: LD_ADDR_VAR 0 1
18402: PUSH
18403: LD_INT 1050
18405: PUSH
18406: LD_INT 1575
18408: PUSH
18409: LD_INT 1750
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: LIST
18416: PUSH
18417: LD_OWVAR 67
18421: ARRAY
18422: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18423: LD_VAR 0 1
18427: PUSH
18428: LD_INT 0
18430: PPUSH
18431: LD_INT 385
18433: PPUSH
18434: CALL_OW 12
18438: PLUS
18439: PPUSH
18440: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
18444: LD_INT 1
18446: PPUSH
18447: LD_INT 5
18449: PPUSH
18450: CALL_OW 12
18454: PPUSH
18455: LD_INT 51
18457: PPUSH
18458: LD_INT 74
18460: PPUSH
18461: LD_INT 25
18463: PPUSH
18464: LD_INT 1
18466: PPUSH
18467: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
18471: LD_OWVAR 1
18475: PUSH
18476: LD_INT 84000
18478: PUSH
18479: LD_INT 105000
18481: PUSH
18482: LD_INT 136500
18484: PUSH
18485: EMPTY
18486: LIST
18487: LIST
18488: LIST
18489: PUSH
18490: LD_OWVAR 67
18494: ARRAY
18495: MOD
18496: PUSH
18497: LD_INT 0
18499: EQUAL
18500: IFFALSE 18516
// time := time + 0 0$15 ;
18502: LD_ADDR_VAR 0 1
18506: PUSH
18507: LD_VAR 0 1
18511: PUSH
18512: LD_INT 525
18514: PLUS
18515: ST_TO_ADDR
// end until game_status = false ;
18516: LD_EXP 28
18520: PUSH
18521: LD_INT 0
18523: EQUAL
18524: IFFALSE 18423
// end ; end_of_file
18526: PPOPN 1
18528: END
// every 0 0$01 trigger not debug do
18529: LD_EXP 1
18533: NOT
18534: IFFALSE 18557
18536: GO 18538
18538: DISABLE
// begin enable ;
18539: ENABLE
// Display_Strings := [ #tick , tick ] ;
18540: LD_ADDR_OWVAR 47
18544: PUSH
18545: LD_STRING #tick
18547: PUSH
18548: LD_OWVAR 1
18552: PUSH
18553: EMPTY
18554: LIST
18555: LIST
18556: ST_TO_ADDR
// end ;
18557: END
