// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// debug := 0 ;
  21: LD_ADDR_EXP 1
  25: PUSH
  26: LD_INT 0
  28: ST_TO_ADDR
// if debug then
  29: LD_EXP 1
  33: IFFALSE 55
// begin display_strings := Debug mode active! ;
  35: LD_ADDR_OWVAR 47
  39: PUSH
  40: LD_STRING Debug mode active!
  42: ST_TO_ADDR
// Your_Side := 1 ;
  43: LD_ADDR_OWVAR 2
  47: PUSH
  48: LD_INT 1
  50: ST_TO_ADDR
// TurnFogOff ;
  51: CALL_OW 537
// end ; Difficulty := GetMultiplayerSetting ( 0 ) ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 426
  67: ST_TO_ADDR
// if not Difficulty then
  68: LD_OWVAR 67
  72: NOT
  73: IFFALSE 83
// Difficulty := 2 ;
  75: LD_ADDR_OWVAR 67
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// PrepareTigers ( tiger_area ) ;
  83: LD_INT 8
  85: PPUSH
  86: CALL 10142 0 1
// PrepareApemans ( apeman_area ) ;
  90: LD_INT 9
  92: PPUSH
  93: CALL 10272 0 1
// PrepareRussian ;
  97: CALL 117 0 0
// PrepareAmerican ;
 101: CALL 11679 0 0
// if not debug then
 105: LD_EXP 1
 109: NOT
 110: IFFALSE 116
// Action ;
 112: CALL 13908 0 0
// end ;
 116: END
// export debug ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 117: LD_INT 0
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
// uc_side := 3 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 3
 130: ST_TO_ADDR
// uc_nation := nation_russian ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 3
 138: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 139: LD_ADDR_VAR 0 2
 143: PUSH
 144: LD_INT 6
 146: PUSH
 147: LD_INT 7
 149: PUSH
 150: LD_INT 8
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: LIST
 157: PUSH
 158: LD_OWVAR 67
 162: ARRAY
 163: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 164: LD_INT 2
 166: PPUSH
 167: CALL_OW 274
 171: PPUSH
 172: LD_INT 1
 174: PPUSH
 175: LD_INT 1200
 177: PPUSH
 178: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 182: LD_INT 2
 184: PPUSH
 185: CALL_OW 274
 189: PPUSH
 190: LD_INT 2
 192: PPUSH
 193: LD_INT 600
 195: PPUSH
 196: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 200: LD_INT 33
 202: PPUSH
 203: LD_INT 4
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 213: LD_INT 37
 215: PPUSH
 216: LD_INT 3
 218: PPUSH
 219: LD_INT 3
 221: PPUSH
 222: CALL_OW 441
// ru_force := [ ] ;
 226: LD_ADDR_EXP 2
 230: PUSH
 231: EMPTY
 232: ST_TO_ADDR
// ru_group1 := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// ru_group2 := [ ] ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: EMPTY
 246: ST_TO_ADDR
// ru_reserve := [ ] ;
 247: LD_ADDR_EXP 8
 251: PUSH
 252: EMPTY
 253: ST_TO_ADDR
// ru_attack_list := [ ] ;
 254: LD_ADDR_EXP 9
 258: PUSH
 259: EMPTY
 260: ST_TO_ADDR
// ru_protector := [ ] ;
 261: LD_ADDR_EXP 16
 265: PUSH
 266: EMPTY
 267: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 268: LD_ADDR_EXP 5
 272: PUSH
 273: LD_INT 48
 275: PUSH
 276: LD_INT 49
 278: PUSH
 279: LD_INT 50
 281: PUSH
 282: LD_INT 20
 284: PUSH
 285: LD_INT 1
 287: PUSH
 288: LD_INT 51
 290: PUSH
 291: LD_INT 52
 293: PUSH
 294: LD_INT 69
 296: PUSH
 297: LD_INT 39
 299: PUSH
 300: LD_INT 34
 302: PUSH
 303: LD_INT 40
 305: PUSH
 306: LD_INT 53
 308: PUSH
 309: LD_INT 71
 311: PUSH
 312: LD_INT 57
 314: PUSH
 315: LD_INT 58
 317: PUSH
 318: LD_INT 44
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: LD_INT 27
 326: PUSH
 327: LD_INT 23
 329: PUSH
 330: LD_INT 33
 332: PUSH
 333: LD_INT 59
 335: PUSH
 336: LD_INT 54
 338: PUSH
 339: LD_INT 55
 341: PUSH
 342: LD_INT 56
 344: PUSH
 345: LD_INT 63
 347: PUSH
 348: LD_INT 64
 350: PUSH
 351: LD_INT 65
 353: PUSH
 354: LD_INT 30
 356: PUSH
 357: LD_INT 31
 359: PUSH
 360: LD_INT 21
 362: PUSH
 363: LD_INT 22
 365: PUSH
 366: LD_INT 25
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 403: LD_ADDR_EXP 6
 407: PUSH
 408: LD_INT 3
 410: PPUSH
 411: LD_INT 33
 413: PPUSH
 414: CALL 8257 0 2
 418: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 419: LD_ADDR_EXP 7
 423: PUSH
 424: LD_INT 46
 426: PUSH
 427: LD_INT 45
 429: PUSH
 430: LD_INT 47
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 438: LD_ADDR_EXP 12
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 36
 448: PUSH
 449: LD_INT 8
 451: PUSH
 452: LD_INT 3
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// ru_buildings := [ ] ;
 461: LD_ADDR_EXP 13
 465: PUSH
 466: EMPTY
 467: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 468: LD_ADDR_EXP 10
 472: PUSH
 473: LD_INT 3
 475: PPUSH
 476: CALL 6306 0 1
 480: PUSH
 481: LD_INT 1
 483: ARRAY
 484: PPUSH
 485: CALL_OW 250
 489: PUSH
 490: LD_INT 3
 492: PPUSH
 493: CALL 6306 0 1
 497: PUSH
 498: LD_INT 1
 500: ARRAY
 501: PPUSH
 502: CALL_OW 251
 506: PUSH
 507: LD_INT 3
 509: PPUSH
 510: CALL 6306 0 1
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: CALL_OW 254
 523: PUSH
 524: LD_INT 3
 526: PPUSH
 527: CALL 6306 0 1
 531: PUSH
 532: LD_INT 1
 534: ARRAY
 535: PPUSH
 536: LD_INT 1
 538: PPUSH
 539: CALL_OW 268
 543: PUSH
 544: LD_INT 3
 546: PPUSH
 547: CALL 6306 0 1
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_INT 2
 558: PPUSH
 559: CALL_OW 268
 563: PUSH
 564: EMPTY
 565: LIST
 566: LIST
 567: LIST
 568: LIST
 569: LIST
 570: PUSH
 571: LD_INT 12
 573: PUSH
 574: LD_INT 13
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 11
 582: PUSH
 583: LD_INT 14
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: ST_TO_ADDR
// ru_heal_list := [ ] ;
 597: LD_ADDR_EXP 11
 601: PUSH
 602: EMPTY
 603: ST_TO_ADDR
// need_buldozer := false ;
 604: LD_ADDR_EXP 17
 608: PUSH
 609: LD_INT 0
 611: ST_TO_ADDR
// need_crane := true ;
 612: LD_ADDR_EXP 18
 616: PUSH
 617: LD_INT 1
 619: ST_TO_ADDR
// ru_spotted := false ;
 620: LD_ADDR_EXP 15
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// for i = 1 to 6 do
 628: LD_ADDR_VAR 0 3
 632: PUSH
 633: DOUBLE
 634: LD_INT 1
 636: DEC
 637: ST_TO_ADDR
 638: LD_INT 6
 640: PUSH
 641: FOR_TO
 642: IFFALSE 683
// begin PrepareHuman ( false , 4 , skill ) ;
 644: LD_INT 0
 646: PPUSH
 647: LD_INT 4
 649: PPUSH
 650: LD_VAR 0 2
 654: PPUSH
 655: CALL_OW 380
// un := CreateHuman ;
 659: LD_ADDR_VAR 0 4
 663: PUSH
 664: CALL_OW 44
 668: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 669: LD_VAR 0 4
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: CALL_OW 52
// end ;
 681: GO 641
 683: POP
 684: POP
// for i = 1 to 6 do
 685: LD_ADDR_VAR 0 3
 689: PUSH
 690: DOUBLE
 691: LD_INT 1
 693: DEC
 694: ST_TO_ADDR
 695: LD_INT 6
 697: PUSH
 698: FOR_TO
 699: IFFALSE 740
// begin PrepareHuman ( false , 3 , skill ) ;
 701: LD_INT 0
 703: PPUSH
 704: LD_INT 3
 706: PPUSH
 707: LD_VAR 0 2
 711: PPUSH
 712: CALL_OW 380
// un := CreateHuman ;
 716: LD_ADDR_VAR 0 4
 720: PUSH
 721: CALL_OW 44
 725: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 726: LD_VAR 0 4
 730: PPUSH
 731: LD_INT 14
 733: PPUSH
 734: CALL_OW 52
// end ;
 738: GO 698
 740: POP
 741: POP
// for i = 1 to 6 do
 742: LD_ADDR_VAR 0 3
 746: PUSH
 747: DOUBLE
 748: LD_INT 1
 750: DEC
 751: ST_TO_ADDR
 752: LD_INT 6
 754: PUSH
 755: FOR_TO
 756: IFFALSE 800
// begin PrepareHuman ( false , 2 , skill ) ;
 758: LD_INT 0
 760: PPUSH
 761: LD_INT 2
 763: PPUSH
 764: LD_VAR 0 2
 768: PPUSH
 769: CALL_OW 380
// un := CreateHuman ;
 773: LD_ADDR_VAR 0 4
 777: PUSH
 778: CALL_OW 44
 782: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 783: LD_VAR 0 4
 787: PPUSH
 788: LD_INT 1
 790: PPUSH
 791: LD_INT 0
 793: PPUSH
 794: CALL_OW 49
// end ;
 798: GO 755
 800: POP
 801: POP
// for i = 1 to 6 do
 802: LD_ADDR_VAR 0 3
 806: PUSH
 807: DOUBLE
 808: LD_INT 1
 810: DEC
 811: ST_TO_ADDR
 812: LD_INT 6
 814: PUSH
 815: FOR_TO
 816: IFFALSE 894
// begin PrepareHuman ( false , 1 , skill ) ;
 818: LD_INT 0
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: LD_VAR 0 2
 828: PPUSH
 829: CALL_OW 380
// un := CreateHuman ;
 833: LD_ADDR_VAR 0 4
 837: PUSH
 838: CALL_OW 44
 842: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 843: LD_VAR 0 4
 847: PPUSH
 848: LD_INT 1
 850: PPUSH
 851: LD_INT 0
 853: PPUSH
 854: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 858: LD_VAR 0 4
 862: PPUSH
 863: LD_INT 30
 865: PUSH
 866: LD_INT 5
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL_OW 69
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: CALL_OW 74
 887: PPUSH
 888: CALL_OW 120
// end ;
 892: GO 815
 894: POP
 895: POP
// for i = 1 to Difficulty do
 896: LD_ADDR_VAR 0 3
 900: PUSH
 901: DOUBLE
 902: LD_INT 1
 904: DEC
 905: ST_TO_ADDR
 906: LD_OWVAR 67
 910: PUSH
 911: FOR_TO
 912: IFFALSE 1023
// begin vc_chassis := ru_medium_tracked ;
 914: LD_ADDR_OWVAR 37
 918: PUSH
 919: LD_INT 22
 921: ST_TO_ADDR
// vc_engine := engine_siberite ;
 922: LD_ADDR_OWVAR 39
 926: PUSH
 927: LD_INT 3
 929: ST_TO_ADDR
// vc_control := control_computer ;
 930: LD_ADDR_OWVAR 38
 934: PUSH
 935: LD_INT 3
 937: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 938: LD_ADDR_OWVAR 40
 942: PUSH
 943: LD_INT 43
 945: PUSH
 946: LD_INT 45
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: PUSH
 953: LD_VAR 0 3
 957: PUSH
 958: LD_INT 2
 960: MOD
 961: PUSH
 962: LD_INT 1
 964: PLUS
 965: ARRAY
 966: ST_TO_ADDR
// un := CreateVehicle ;
 967: LD_ADDR_VAR 0 4
 971: PUSH
 972: CALL_OW 45
 976: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
 977: LD_VAR 0 4
 981: PPUSH
 982: LD_INT 52
 984: PPUSH
 985: LD_INT 42
 987: PPUSH
 988: LD_INT 6
 990: PPUSH
 991: LD_INT 0
 993: PPUSH
 994: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
 998: LD_ADDR_EXP 16
1002: PUSH
1003: LD_EXP 16
1007: PPUSH
1008: LD_INT 1
1010: PPUSH
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 2
1020: ST_TO_ADDR
// end ;
1021: GO 911
1023: POP
1024: POP
// end ;
1025: LD_VAR 0 1
1029: RET
// every 150 150$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1030: LD_OWVAR 67
1034: PUSH
1035: LD_INT 2
1037: EQUAL
1038: PUSH
1039: LD_INT 3
1041: PPUSH
1042: LD_INT 3
1044: PPUSH
1045: CALL 6155 0 2
1049: AND
1050: IFFALSE 1086
1052: GO 1054
1054: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 3
1060: PPUSH
1061: CALL 6155 0 2
1065: PUSH
1066: LD_INT 1
1068: ARRAY
1069: PPUSH
1070: LD_INT 24
1072: PPUSH
1073: LD_INT 1
1075: PPUSH
1076: LD_INT 3
1078: PPUSH
1079: LD_INT 48
1081: PPUSH
1082: CALL 8030 0 5
1086: END
// every 120 120$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1087: LD_OWVAR 67
1091: PUSH
1092: LD_INT 3
1094: EQUAL
1095: PUSH
1096: LD_INT 3
1098: PPUSH
1099: LD_INT 3
1101: PPUSH
1102: CALL 6155 0 2
1106: AND
1107: IFFALSE 1143
1109: GO 1111
1111: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1112: LD_INT 3
1114: PPUSH
1115: LD_INT 3
1117: PPUSH
1118: CALL 6155 0 2
1122: PUSH
1123: LD_INT 1
1125: ARRAY
1126: PPUSH
1127: LD_INT 24
1129: PPUSH
1130: LD_INT 1
1132: PPUSH
1133: LD_INT 3
1135: PPUSH
1136: LD_INT 48
1138: PPUSH
1139: CALL 8030 0 5
1143: END
// every 0 0$01 trigger ru_protector do var i ;
1144: LD_EXP 16
1148: IFFALSE 1319
1150: GO 1152
1152: DISABLE
1153: LD_INT 0
1155: PPUSH
// begin enable ;
1156: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1157: LD_INT 14
1159: PPUSH
1160: LD_INT 81
1162: PUSH
1163: LD_INT 3
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: PPUSH
1170: CALL_OW 70
1174: IFFALSE 1249
// begin for i = 1 to ru_protector do
1176: LD_ADDR_VAR 0 1
1180: PUSH
1181: DOUBLE
1182: LD_INT 1
1184: DEC
1185: ST_TO_ADDR
1186: LD_EXP 16
1190: PUSH
1191: FOR_TO
1192: IFFALSE 1245
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1194: LD_EXP 16
1198: PUSH
1199: LD_VAR 0 1
1203: ARRAY
1204: PPUSH
1205: LD_INT 14
1207: PPUSH
1208: LD_INT 81
1210: PUSH
1211: LD_INT 3
1213: PUSH
1214: EMPTY
1215: LIST
1216: LIST
1217: PPUSH
1218: CALL_OW 70
1222: PPUSH
1223: LD_EXP 16
1227: PUSH
1228: LD_VAR 0 1
1232: ARRAY
1233: PPUSH
1234: CALL_OW 74
1238: PPUSH
1239: CALL_OW 115
1243: GO 1191
1245: POP
1246: POP
// end else
1247: GO 1319
// for i = 1 to ru_protector do
1249: LD_ADDR_VAR 0 1
1253: PUSH
1254: DOUBLE
1255: LD_INT 1
1257: DEC
1258: ST_TO_ADDR
1259: LD_EXP 16
1263: PUSH
1264: FOR_TO
1265: IFFALSE 1317
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1267: LD_EXP 16
1271: PUSH
1272: LD_VAR 0 1
1276: ARRAY
1277: PPUSH
1278: LD_INT 49
1280: PPUSH
1281: LD_INT 39
1283: PPUSH
1284: CALL_OW 297
1288: PUSH
1289: LD_INT 10
1291: GREATER
1292: IFFALSE 1315
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1294: LD_EXP 16
1298: PUSH
1299: LD_VAR 0 1
1303: ARRAY
1304: PPUSH
1305: LD_INT 49
1307: PPUSH
1308: LD_INT 39
1310: PPUSH
1311: CALL_OW 111
1315: GO 1264
1317: POP
1318: POP
// end ;
1319: PPOPN 1
1321: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1322: LD_OWVAR 1
1326: PUSH
1327: LD_INT 4200
1329: PUSH
1330: LD_INT 2100
1332: PUSH
1333: LD_INT 1050
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: LD_OWVAR 67
1345: ARRAY
1346: GREATER
1347: IFFALSE 1360
1349: GO 1351
1351: DISABLE
// need_buldozer := true ;
1352: LD_ADDR_EXP 17
1356: PUSH
1357: LD_INT 1
1359: ST_TO_ADDR
1360: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1361: GO 1363
1363: DISABLE
// begin enable ;
1364: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1365: LD_ADDR_EXP 19
1369: PUSH
1370: LD_INT 22
1372: PUSH
1373: LD_INT 3
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: PUSH
1380: LD_INT 25
1382: PUSH
1383: LD_INT 1
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: PPUSH
1394: CALL_OW 69
1398: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1399: LD_ADDR_EXP 20
1403: PUSH
1404: LD_INT 22
1406: PUSH
1407: LD_INT 3
1409: PUSH
1410: EMPTY
1411: LIST
1412: LIST
1413: PUSH
1414: LD_INT 25
1416: PUSH
1417: LD_INT 2
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: PPUSH
1428: CALL_OW 69
1432: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1433: LD_ADDR_EXP 21
1437: PUSH
1438: LD_INT 22
1440: PUSH
1441: LD_INT 3
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: PUSH
1448: LD_INT 25
1450: PUSH
1451: LD_INT 3
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: EMPTY
1459: LIST
1460: LIST
1461: PPUSH
1462: CALL_OW 69
1466: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_INT 22
1474: PUSH
1475: LD_INT 3
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: LD_INT 25
1484: PUSH
1485: LD_INT 4
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PPUSH
1496: CALL_OW 69
1500: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1501: LD_ADDR_EXP 23
1505: PUSH
1506: LD_INT 22
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: LD_INT 25
1518: PUSH
1519: LD_INT 9
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL_OW 69
1534: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1535: LD_ADDR_EXP 24
1539: PUSH
1540: LD_INT 2
1542: PPUSH
1543: LD_INT 22
1545: PUSH
1546: LD_INT 3
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: PUSH
1553: LD_INT 21
1555: PUSH
1556: LD_INT 1
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: PPUSH
1567: CALL_OW 70
1571: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1572: LD_ADDR_EXP 25
1576: PUSH
1577: LD_INT 34
1579: PUSH
1580: LD_INT 53
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1592: LD_ADDR_EXP 26
1596: PUSH
1597: LD_INT 34
1599: PUSH
1600: LD_INT 52
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: PPUSH
1607: CALL_OW 69
1611: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1612: LD_ADDR_EXP 27
1616: PUSH
1617: LD_INT 34
1619: PUSH
1620: LD_INT 51
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PPUSH
1627: CALL_OW 69
1631: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1632: LD_ADDR_EXP 13
1636: PUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 1
1642: NEG
1643: PPUSH
1644: CALL 10660 0 2
1648: ST_TO_ADDR
// end ;
1649: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1650: LD_INT 22
1652: PUSH
1653: LD_INT 3
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PPUSH
1660: CALL_OW 69
1664: PUSH
1665: LD_EXP 28
1669: AND
1670: PUSH
1671: LD_EXP 1
1675: OR
1676: IFFALSE 5165
1678: GO 1680
1680: DISABLE
1681: LD_INT 0
1683: PPUSH
1684: PPUSH
1685: PPUSH
1686: PPUSH
1687: PPUSH
1688: PPUSH
1689: PPUSH
1690: PPUSH
1691: PPUSH
1692: PPUSH
// begin enable ;
1693: ENABLE
// for i = 1 to ru_eng do
1694: LD_ADDR_VAR 0 1
1698: PUSH
1699: DOUBLE
1700: LD_INT 1
1702: DEC
1703: ST_TO_ADDR
1704: LD_EXP 20
1708: PUSH
1709: FOR_TO
1710: IFFALSE 1773
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1712: LD_EXP 20
1716: PUSH
1717: LD_VAR 0 1
1721: ARRAY
1722: PPUSH
1723: CALL_OW 314
1727: NOT
1728: PUSH
1729: LD_EXP 20
1733: PUSH
1734: LD_VAR 0 1
1738: ARRAY
1739: PPUSH
1740: CALL_OW 310
1744: NOT
1745: AND
1746: IFFALSE 1771
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1748: LD_EXP 20
1752: PUSH
1753: LD_VAR 0 1
1757: ARRAY
1758: PPUSH
1759: LD_INT 3
1761: PPUSH
1762: CALL 6064 0 1
1766: PPUSH
1767: CALL_OW 120
1771: GO 1709
1773: POP
1774: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1775: LD_INT 2
1777: PPUSH
1778: LD_INT 22
1780: PUSH
1781: LD_INT 3
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 21
1790: PUSH
1791: LD_INT 3
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: LD_INT 24
1803: PUSH
1804: LD_INT 1000
1806: PUSH
1807: EMPTY
1808: LIST
1809: LIST
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 70
1824: IFFALSE 1991
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1826: LD_ADDR_VAR 0 4
1830: PUSH
1831: LD_INT 2
1833: PPUSH
1834: LD_INT 22
1836: PUSH
1837: LD_INT 3
1839: PUSH
1840: EMPTY
1841: LIST
1842: LIST
1843: PUSH
1844: LD_INT 21
1846: PUSH
1847: LD_INT 3
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: PUSH
1854: LD_INT 3
1856: PUSH
1857: LD_INT 24
1859: PUSH
1860: LD_INT 1000
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: LIST
1875: PPUSH
1876: CALL_OW 70
1880: ST_TO_ADDR
// for i = 1 to ru_eng do
1881: LD_ADDR_VAR 0 1
1885: PUSH
1886: DOUBLE
1887: LD_INT 1
1889: DEC
1890: ST_TO_ADDR
1891: LD_EXP 20
1895: PUSH
1896: FOR_TO
1897: IFFALSE 1989
// begin if IsInUnit ( ru_eng [ i ] ) then
1899: LD_EXP 20
1903: PUSH
1904: LD_VAR 0 1
1908: ARRAY
1909: PPUSH
1910: CALL_OW 310
1914: IFFALSE 1933
// ComExitBuilding ( ru_eng [ i ] ) else
1916: LD_EXP 20
1920: PUSH
1921: LD_VAR 0 1
1925: ARRAY
1926: PPUSH
1927: CALL_OW 122
1931: GO 1987
// if not WantRepair ( ru_eng [ i ] ) then
1933: LD_EXP 20
1937: PUSH
1938: LD_VAR 0 1
1942: ARRAY
1943: PPUSH
1944: CALL 10586 0 1
1948: NOT
1949: IFFALSE 1987
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1951: LD_EXP 20
1955: PUSH
1956: LD_VAR 0 1
1960: ARRAY
1961: PPUSH
1962: LD_VAR 0 4
1966: PPUSH
1967: LD_EXP 20
1971: PUSH
1972: LD_VAR 0 1
1976: ARRAY
1977: PPUSH
1978: CALL_OW 74
1982: PPUSH
1983: CALL_OW 130
// end ;
1987: GO 1896
1989: POP
1990: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
1991: LD_OWVAR 2
1995: PPUSH
1996: LD_INT 38
1998: PPUSH
1999: LD_INT 26
2001: PPUSH
2002: CALL 5383 0 3
2006: PUSH
2007: LD_INT 0
2009: EQUAL
2010: PUSH
2011: LD_OWVAR 2
2015: PPUSH
2016: LD_INT 29
2018: PPUSH
2019: LD_INT 37
2021: PPUSH
2022: CALL 5383 0 3
2026: PUSH
2027: LD_INT 0
2029: EQUAL
2030: AND
2031: IFFALSE 2168
// begin if ru_blist > 0 then
2033: LD_EXP 12
2037: PUSH
2038: LD_INT 0
2040: GREATER
2041: IFFALSE 2168
// begin for i = 1 to ru_eng do
2043: LD_ADDR_VAR 0 1
2047: PUSH
2048: DOUBLE
2049: LD_INT 1
2051: DEC
2052: ST_TO_ADDR
2053: LD_EXP 20
2057: PUSH
2058: FOR_TO
2059: IFFALSE 2166
// if IsInUnit ( ru_eng [ i ] ) then
2061: LD_EXP 20
2065: PUSH
2066: LD_VAR 0 1
2070: ARRAY
2071: PPUSH
2072: CALL_OW 310
2076: IFFALSE 2095
// ComExitBuilding ( ru_eng [ i ] ) else
2078: LD_EXP 20
2082: PUSH
2083: LD_VAR 0 1
2087: ARRAY
2088: PPUSH
2089: CALL_OW 122
2093: GO 2164
// if not HasTask ( ru_eng [ i ] ) then
2095: LD_EXP 20
2099: PUSH
2100: LD_VAR 0 1
2104: ARRAY
2105: PPUSH
2106: CALL_OW 314
2110: NOT
2111: IFFALSE 2164
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2113: LD_EXP 20
2117: PUSH
2118: LD_VAR 0 1
2122: ARRAY
2123: PPUSH
2124: LD_EXP 12
2128: PUSH
2129: LD_INT 1
2131: ARRAY
2132: PPUSH
2133: LD_EXP 12
2137: PUSH
2138: LD_INT 2
2140: ARRAY
2141: PPUSH
2142: LD_EXP 12
2146: PUSH
2147: LD_INT 3
2149: ARRAY
2150: PPUSH
2151: LD_EXP 12
2155: PUSH
2156: LD_INT 4
2158: ARRAY
2159: PPUSH
2160: CALL_OW 145
2164: GO 2058
2166: POP
2167: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2168: LD_ADDR_EXP 11
2172: PUSH
2173: LD_INT 3
2175: PPUSH
2176: LD_EXP 11
2180: PPUSH
2181: LD_EXP 14
2185: PPUSH
2186: CALL 9073 0 3
2190: ST_TO_ADDR
// if debug then
2191: LD_EXP 1
2195: IFFALSE 2207
// display_strings := ru_heal_list ;
2197: LD_ADDR_OWVAR 47
2201: PUSH
2202: LD_EXP 11
2206: ST_TO_ADDR
// for i = 1 to ru_sci do
2207: LD_ADDR_VAR 0 1
2211: PUSH
2212: DOUBLE
2213: LD_INT 1
2215: DEC
2216: ST_TO_ADDR
2217: LD_EXP 22
2221: PUSH
2222: FOR_TO
2223: IFFALSE 2555
// begin if ru_heal_list then
2225: LD_EXP 11
2229: IFFALSE 2468
// begin list := ru_heal_list ;
2231: LD_ADDR_VAR 0 9
2235: PUSH
2236: LD_EXP 11
2240: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2241: LD_EXP 22
2245: PUSH
2246: LD_VAR 0 1
2250: ARRAY
2251: PPUSH
2252: CALL_OW 310
2256: IFFALSE 2273
// ComExitBuilding ( ru_sci [ i ] ) ;
2258: LD_EXP 22
2262: PUSH
2263: LD_VAR 0 1
2267: ARRAY
2268: PPUSH
2269: CALL_OW 122
// for p = 1 to list do
2273: LD_ADDR_VAR 0 5
2277: PUSH
2278: DOUBLE
2279: LD_INT 1
2281: DEC
2282: ST_TO_ADDR
2283: LD_VAR 0 9
2287: PUSH
2288: FOR_TO
2289: IFFALSE 2464
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2291: LD_VAR 0 9
2295: PUSH
2296: LD_VAR 0 5
2300: ARRAY
2301: PPUSH
2302: CALL_OW 110
2306: PUSH
2307: LD_INT 100
2309: EQUAL
2310: PUSH
2311: LD_EXP 22
2315: PUSH
2316: LD_VAR 0 1
2320: ARRAY
2321: PPUSH
2322: LD_INT 100
2324: PPUSH
2325: CALL 9433 0 2
2329: NOT
2330: AND
2331: IFFALSE 2359
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2333: LD_EXP 22
2337: PUSH
2338: LD_VAR 0 1
2342: ARRAY
2343: PPUSH
2344: LD_VAR 0 9
2348: PUSH
2349: LD_VAR 0 5
2353: ARRAY
2354: PPUSH
2355: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2359: LD_VAR 0 9
2363: PUSH
2364: LD_VAR 0 5
2368: ARRAY
2369: PPUSH
2370: CALL_OW 110
2374: PUSH
2375: LD_INT 100
2377: GREATER
2378: IFFALSE 2406
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2380: LD_EXP 22
2384: PUSH
2385: LD_VAR 0 1
2389: ARRAY
2390: PPUSH
2391: LD_VAR 0 9
2395: PUSH
2396: LD_VAR 0 5
2400: ARRAY
2401: PPUSH
2402: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2406: LD_VAR 0 9
2410: PUSH
2411: LD_VAR 0 5
2415: ARRAY
2416: PPUSH
2417: LD_INT 4
2419: PPUSH
2420: CALL_OW 308
2424: NOT
2425: IFFALSE 2447
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2427: LD_VAR 0 9
2431: PUSH
2432: LD_VAR 0 5
2436: ARRAY
2437: PPUSH
2438: LD_INT 4
2440: PPUSH
2441: CALL_OW 113
2445: GO 2462
// ComHold ( list [ p ] ) ;
2447: LD_VAR 0 9
2451: PUSH
2452: LD_VAR 0 5
2456: ARRAY
2457: PPUSH
2458: CALL_OW 140
// end ;
2462: GO 2288
2464: POP
2465: POP
// end else
2466: GO 2553
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2468: LD_EXP 22
2472: PUSH
2473: LD_VAR 0 1
2477: ARRAY
2478: PPUSH
2479: CALL_OW 314
2483: NOT
2484: PUSH
2485: LD_EXP 22
2489: PUSH
2490: LD_VAR 0 1
2494: ARRAY
2495: PPUSH
2496: CALL_OW 310
2500: NOT
2501: AND
2502: PUSH
2503: LD_EXP 11
2507: PUSH
2508: LD_INT 0
2510: EQUAL
2511: AND
2512: IFFALSE 2553
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2514: LD_EXP 22
2518: PUSH
2519: LD_VAR 0 1
2523: ARRAY
2524: PPUSH
2525: LD_INT 3
2527: PPUSH
2528: CALL 6306 0 1
2532: PPUSH
2533: LD_EXP 22
2537: PUSH
2538: LD_VAR 0 1
2542: ARRAY
2543: PPUSH
2544: CALL_OW 74
2548: PPUSH
2549: CALL_OW 120
// end ;
2553: GO 2222
2555: POP
2556: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2557: LD_INT 3
2559: PPUSH
2560: LD_EXP 5
2564: PPUSH
2565: CALL 6447 0 2
2569: IFFALSE 2583
// ResearchTechList ( 3 , ru_tech_list ) ;
2571: LD_INT 3
2573: PPUSH
2574: LD_EXP 5
2578: PPUSH
2579: CALL 6522 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2583: LD_EXP 20
2587: PPUSH
2588: LD_EXP 10
2592: PPUSH
2593: CALL 8429 0 2
// lab := GetLabs ( 3 ) ;
2597: LD_ADDR_VAR 0 8
2601: PUSH
2602: LD_INT 3
2604: PPUSH
2605: CALL 6306 0 1
2609: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2610: LD_VAR 0 8
2614: PUSH
2615: LD_EXP 11
2619: PUSH
2620: LD_INT 0
2622: EQUAL
2623: AND
2624: IFFALSE 2751
// for i = 1 to lab do
2626: LD_ADDR_VAR 0 1
2630: PUSH
2631: DOUBLE
2632: LD_INT 1
2634: DEC
2635: ST_TO_ADDR
2636: LD_VAR 0 8
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2749
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2644: LD_VAR 0 8
2648: PUSH
2649: LD_VAR 0 1
2653: ARRAY
2654: PPUSH
2655: CALL_OW 461
2659: PUSH
2660: LD_INT 6
2662: EQUAL
2663: IFFALSE 2747
// begin for p = 1 to ru_sci do
2665: LD_ADDR_VAR 0 5
2669: PUSH
2670: DOUBLE
2671: LD_INT 1
2673: DEC
2674: ST_TO_ADDR
2675: LD_EXP 22
2679: PUSH
2680: FOR_TO
2681: IFFALSE 2745
// if IsInUnit ( ru_sci [ p ] ) then
2683: LD_EXP 22
2687: PUSH
2688: LD_VAR 0 5
2692: ARRAY
2693: PPUSH
2694: CALL_OW 310
2698: IFFALSE 2717
// ComExitBuilding ( ru_sci [ p ] ) else
2700: LD_EXP 22
2704: PUSH
2705: LD_VAR 0 5
2709: ARRAY
2710: PPUSH
2711: CALL_OW 122
2715: GO 2743
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2717: LD_EXP 22
2721: PUSH
2722: LD_VAR 0 5
2726: ARRAY
2727: PPUSH
2728: LD_VAR 0 8
2732: PUSH
2733: LD_VAR 0 1
2737: ARRAY
2738: PPUSH
2739: CALL_OW 120
2743: GO 2680
2745: POP
2746: POP
// end ;
2747: GO 2641
2749: POP
2750: POP
// if GetTowers ( 3 ) < 5 then
2751: LD_INT 3
2753: PPUSH
2754: CALL 6861 0 1
2758: PUSH
2759: LD_INT 5
2761: LESS
2762: IFFALSE 2780
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2764: LD_EXP 20
2768: PPUSH
2769: LD_EXP 6
2773: PPUSH
2774: CALL 7469 0 2
2778: GO 2792
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2780: LD_INT 3
2782: PPUSH
2783: LD_EXP 7
2787: PPUSH
2788: CALL 7760 0 2
// if GetBuilding ( 3 , b_factory ) then
2792: LD_INT 3
2794: PPUSH
2795: LD_INT 3
2797: PPUSH
2798: CALL 6155 0 2
2802: IFFALSE 3072
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2804: LD_INT 3
2806: PPUSH
2807: LD_INT 3
2809: PPUSH
2810: CALL 6155 0 2
2814: PUSH
2815: LD_INT 1
2817: ARRAY
2818: PPUSH
2819: CALL_OW 461
2823: PUSH
2824: LD_INT 2
2826: EQUAL
2827: IFFALSE 3072
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2829: LD_ADDR_VAR 0 7
2833: PUSH
2834: LD_INT 3
2836: PPUSH
2837: LD_INT 3
2839: PPUSH
2840: CALL 6155 0 2
2844: PUSH
2845: LD_INT 1
2847: ARRAY
2848: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2849: LD_INT 3
2851: PPUSH
2852: LD_INT 24
2854: PPUSH
2855: LD_INT 53
2857: PPUSH
2858: CALL 7908 0 3
2862: PUSH
2863: LD_INT 0
2865: EQUAL
2866: PUSH
2867: LD_EXP 17
2871: AND
2872: IFFALSE 2895
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2874: LD_VAR 0 7
2878: PPUSH
2879: LD_INT 24
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 53
2890: PPUSH
2891: CALL 8030 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2895: LD_INT 3
2897: PPUSH
2898: LD_INT 22
2900: PPUSH
2901: LD_INT 52
2903: PPUSH
2904: CALL 7908 0 3
2908: PUSH
2909: LD_INT 0
2911: EQUAL
2912: PUSH
2913: LD_EXP 18
2917: AND
2918: IFFALSE 2941
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2920: LD_VAR 0 7
2924: PPUSH
2925: LD_INT 22
2927: PPUSH
2928: LD_INT 1
2930: PPUSH
2931: LD_INT 3
2933: PPUSH
2934: LD_INT 52
2936: PPUSH
2937: CALL 8030 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2941: LD_INT 3
2943: PPUSH
2944: LD_INT 22
2946: PPUSH
2947: LD_INT 49
2949: PPUSH
2950: CALL 7908 0 3
2954: PUSH
2955: LD_INT 4
2957: LESS
2958: PUSH
2959: LD_INT 31
2961: PPUSH
2962: LD_INT 3
2964: PPUSH
2965: CALL_OW 321
2969: PUSH
2970: LD_INT 2
2972: EQUAL
2973: AND
2974: IFFALSE 2997
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
2976: LD_VAR 0 7
2980: PPUSH
2981: LD_INT 22
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: LD_INT 3
2989: PPUSH
2990: LD_INT 49
2992: PPUSH
2993: CALL 8030 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
2997: LD_EXP 8
3001: PUSH
3002: LD_INT 5
3004: PUSH
3005: LD_INT 6
3007: PUSH
3008: LD_INT 7
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_OWVAR 67
3020: ARRAY
3021: LESS
3022: IFFALSE 3072
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3024: LD_VAR 0 7
3028: PPUSH
3029: LD_INT 24
3031: PPUSH
3032: LD_INT 1
3034: PPUSH
3035: LD_INT 3
3037: PPUSH
3038: LD_INT 46
3040: PUSH
3041: LD_INT 45
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 46
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: LIST
3055: PUSH
3056: LD_INT 1
3058: PPUSH
3059: LD_INT 4
3061: PPUSH
3062: CALL_OW 12
3066: ARRAY
3067: PPUSH
3068: CALL 8030 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3072: LD_INT 3
3074: PPUSH
3075: CALL 6064 0 1
3079: PPUSH
3080: CALL 5756 0 1
3084: PUSH
3085: LD_INT 1
3087: ARRAY
3088: PUSH
3089: LD_INT 250
3091: GREATER
3092: PUSH
3093: LD_INT 3
3095: PPUSH
3096: CALL 6064 0 1
3100: PPUSH
3101: CALL 5756 0 1
3105: PUSH
3106: LD_INT 3
3108: ARRAY
3109: PUSH
3110: LD_INT 50
3112: GREATER
3113: AND
3114: PUSH
3115: LD_INT 23
3117: PPUSH
3118: LD_INT 3
3120: PPUSH
3121: CALL_OW 321
3125: PUSH
3126: LD_INT 2
3128: EQUAL
3129: AND
3130: PUSH
3131: LD_INT 3
3133: PPUSH
3134: CALL 11384 0 1
3138: PUSH
3139: LD_INT 0
3141: EQUAL
3142: AND
3143: PUSH
3144: LD_INT 22
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: PUSH
3154: LD_INT 34
3156: PUSH
3157: LD_INT 49
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: PUSH
3173: LD_INT 3
3175: GREATER
3176: AND
3177: PUSH
3178: LD_OWVAR 2
3182: PPUSH
3183: LD_INT 51
3185: PPUSH
3186: LD_INT 42
3188: PPUSH
3189: CALL 5383 0 3
3193: PUSH
3194: LD_INT 0
3196: EQUAL
3197: AND
3198: IFFALSE 3283
// begin for i = 1 to ru_mech do
3200: LD_ADDR_VAR 0 1
3204: PUSH
3205: DOUBLE
3206: LD_INT 1
3208: DEC
3209: ST_TO_ADDR
3210: LD_EXP 21
3214: PUSH
3215: FOR_TO
3216: IFFALSE 3281
// begin if IsInUnit ( ru_mech [ i ] ) then
3218: LD_EXP 21
3222: PUSH
3223: LD_VAR 0 1
3227: ARRAY
3228: PPUSH
3229: CALL_OW 310
3233: IFFALSE 3252
// ComExitBuilding ( ru_mech [ i ] ) else
3235: LD_EXP 21
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 122
3250: GO 3279
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3252: LD_EXP 21
3256: PUSH
3257: LD_VAR 0 1
3261: ARRAY
3262: PPUSH
3263: LD_INT 37
3265: PPUSH
3266: LD_INT 51
3268: PPUSH
3269: LD_INT 43
3271: PPUSH
3272: LD_INT 0
3274: PPUSH
3275: CALL_OW 170
// end ;
3279: GO 3215
3281: POP
3282: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3283: LD_OWVAR 1
3287: PUSH
3288: LD_INT 94500
3290: PUSH
3291: LD_INT 84000
3293: PUSH
3294: LD_INT 71400
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: PUSH
3302: LD_OWVAR 67
3306: ARRAY
3307: GREATEREQUAL
3308: IFFALSE 3364
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3310: LD_OWVAR 1
3314: PUSH
3315: LD_INT 18900
3317: PUSH
3318: LD_INT 16800
3320: PUSH
3321: LD_INT 14700
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: MOD
3335: PUSH
3336: LD_INT 0
3338: EQUAL
3339: IFFALSE 3364
// if ru_reserve then
3341: LD_EXP 8
3345: IFFALSE 3364
// begin ru_attack_list := ru_reserve ;
3347: LD_ADDR_EXP 9
3351: PUSH
3352: LD_EXP 8
3356: ST_TO_ADDR
// ru_reserve := [ ] ;
3357: LD_ADDR_EXP 8
3361: PUSH
3362: EMPTY
3363: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3364: LD_EXP 9
3368: IFFALSE 3490
// begin for i = 1 to ru_attack_list do
3370: LD_ADDR_VAR 0 1
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_EXP 9
3384: PUSH
3385: FOR_TO
3386: IFFALSE 3488
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3388: LD_EXP 9
3392: PUSH
3393: LD_VAR 0 1
3397: ARRAY
3398: PPUSH
3399: CALL_OW 256
3403: PUSH
3404: LD_INT 250
3406: GREATEREQUAL
3407: PUSH
3408: LD_EXP 9
3412: PUSH
3413: LD_VAR 0 1
3417: ARRAY
3418: PPUSH
3419: CALL_OW 314
3423: NOT
3424: AND
3425: IFFALSE 3486
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3427: LD_EXP 9
3431: PUSH
3432: LD_VAR 0 1
3436: ARRAY
3437: PPUSH
3438: LD_INT 81
3440: PUSH
3441: LD_EXP 9
3445: PUSH
3446: LD_VAR 0 1
3450: ARRAY
3451: PPUSH
3452: CALL_OW 255
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: PPUSH
3466: LD_EXP 9
3470: PUSH
3471: LD_VAR 0 1
3475: ARRAY
3476: PPUSH
3477: CALL_OW 74
3481: PPUSH
3482: CALL_OW 115
3486: GO 3385
3488: POP
3489: POP
// end ; if GetBehemoth ( 3 ) then
3490: LD_INT 3
3492: PPUSH
3493: CALL 11384 0 1
3497: IFFALSE 3791
// begin if ru_mech >= 4 then
3499: LD_EXP 21
3503: PUSH
3504: LD_INT 4
3506: GREATEREQUAL
3507: IFFALSE 3558
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3509: LD_ADDR_EXP 14
3513: PUSH
3514: LD_EXP 21
3518: PUSH
3519: LD_INT 1
3521: ARRAY
3522: PUSH
3523: LD_EXP 21
3527: PUSH
3528: LD_INT 2
3530: ARRAY
3531: PUSH
3532: LD_EXP 21
3536: PUSH
3537: LD_INT 3
3539: ARRAY
3540: PUSH
3541: LD_EXP 21
3545: PUSH
3546: LD_INT 4
3548: ARRAY
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: ST_TO_ADDR
3556: GO 3568
// ru_behemoth_mechanic := ru_mech ;
3558: LD_ADDR_EXP 14
3562: PUSH
3563: LD_EXP 21
3567: ST_TO_ADDR
// for i = 1 to ru_mech do
3568: LD_ADDR_VAR 0 1
3572: PUSH
3573: DOUBLE
3574: LD_INT 1
3576: DEC
3577: ST_TO_ADDR
3578: LD_EXP 21
3582: PUSH
3583: FOR_TO
3584: IFFALSE 3638
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3586: LD_EXP 21
3590: PUSH
3591: LD_VAR 0 1
3595: ARRAY
3596: PPUSH
3597: CALL_OW 310
3601: PUSH
3602: LD_EXP 21
3606: PUSH
3607: LD_VAR 0 1
3611: ARRAY
3612: PUSH
3613: LD_EXP 14
3617: IN
3618: AND
3619: IFFALSE 3636
// ComExitBuilding ( ru_mech [ i ] ) ;
3621: LD_EXP 21
3625: PUSH
3626: LD_VAR 0 1
3630: ARRAY
3631: PPUSH
3632: CALL_OW 122
3636: GO 3583
3638: POP
3639: POP
// if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3640: LD_INT 12
3642: PPUSH
3643: LD_INT 22
3645: PUSH
3646: LD_INT 1
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: LD_INT 21
3655: PUSH
3656: LD_INT 3
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PPUSH
3667: CALL_OW 70
3671: PUSH
3672: LD_INT 0
3674: GREATER
3675: IFFALSE 3735
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3677: LD_INT 3
3679: PPUSH
3680: CALL 11384 0 1
3684: PUSH
3685: LD_INT 1
3687: ARRAY
3688: PPUSH
3689: LD_INT 21
3691: PUSH
3692: LD_INT 2
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 34
3701: PUSH
3702: LD_INT 49
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PPUSH
3713: CALL_OW 69
3717: PPUSH
3718: LD_EXP 14
3722: PPUSH
3723: LD_INT 97
3725: PPUSH
3726: LD_INT 9
3728: PPUSH
3729: CALL 10881 0 5
3733: GO 3791
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3735: LD_INT 3
3737: PPUSH
3738: CALL 11384 0 1
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: PPUSH
3747: LD_INT 21
3749: PUSH
3750: LD_INT 2
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 34
3759: PUSH
3760: LD_INT 49
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: PPUSH
3771: CALL_OW 69
3775: PPUSH
3776: LD_EXP 14
3780: PPUSH
3781: LD_INT 153
3783: PPUSH
3784: LD_INT 102
3786: PPUSH
3787: CALL 10881 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3791: LD_EXP 23
3795: PUSH
3796: LD_INT 0
3798: EQUAL
3799: PUSH
3800: LD_INT 44
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 321
3810: PUSH
3811: LD_INT 2
3813: EQUAL
3814: AND
3815: IFFALSE 3826
// ComChangeClassToBazooker ( ru_sold ) ;
3817: LD_EXP 19
3821: PPUSH
3822: CALL 9818 0 1
// if ru_bazz then
3826: LD_EXP 23
3830: IFFALSE 3844
// IntBazooka ( ru_bazz , 1 ) ;
3832: LD_EXP 23
3836: PPUSH
3837: LD_INT 1
3839: PPUSH
3840: CALL 9537 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3844: LD_INT 67
3846: PPUSH
3847: LD_INT 39
3849: PPUSH
3850: LD_INT 3
3852: PPUSH
3853: CALL_OW 440
3857: PUSH
3858: LD_INT 0
3860: EQUAL
3861: PUSH
3862: LD_INT 20
3864: PPUSH
3865: LD_INT 3
3867: PPUSH
3868: CALL_OW 321
3872: PUSH
3873: LD_INT 2
3875: EQUAL
3876: AND
3877: IFFALSE 3898
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3879: LD_EXP 22
3883: PUSH
3884: LD_INT 1
3886: ARRAY
3887: PPUSH
3888: LD_INT 67
3890: PPUSH
3891: LD_INT 39
3893: PPUSH
3894: CALL 9012 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3898: LD_INT 89
3900: PPUSH
3901: LD_INT 66
3903: PPUSH
3904: LD_INT 3
3906: PPUSH
3907: CALL_OW 440
3911: PUSH
3912: LD_INT 0
3914: EQUAL
3915: IFFALSE 3936
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
3917: LD_EXP 22
3921: PUSH
3922: LD_INT 1
3924: ARRAY
3925: PPUSH
3926: LD_INT 87
3928: PPUSH
3929: LD_INT 60
3931: PPUSH
3932: CALL 9012 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3936: LD_INT 104
3938: PPUSH
3939: LD_INT 94
3941: PPUSH
3942: LD_INT 3
3944: PPUSH
3945: CALL_OW 440
3949: PUSH
3950: LD_INT 0
3952: EQUAL
3953: PUSH
3954: LD_INT 20
3956: PPUSH
3957: LD_INT 3
3959: PPUSH
3960: CALL_OW 321
3964: PUSH
3965: LD_INT 2
3967: EQUAL
3968: AND
3969: IFFALSE 3990
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
3971: LD_EXP 22
3975: PUSH
3976: LD_INT 1
3978: ARRAY
3979: PPUSH
3980: LD_INT 104
3982: PPUSH
3983: LD_INT 94
3985: PPUSH
3986: CALL 9012 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
3990: LD_INT 3
3992: PPUSH
3993: LD_INT 24
3995: PPUSH
3996: LD_INT 53
3998: PPUSH
3999: CALL 7908 0 3
4003: PUSH
4004: LD_INT 1
4006: EQUAL
4007: PUSH
4008: LD_EXP 17
4012: AND
4013: IFFALSE 4154
// begin need_buldozer := false ;
4015: LD_ADDR_EXP 17
4019: PUSH
4020: LD_INT 0
4022: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4023: LD_INT 3
4025: PPUSH
4026: LD_INT 24
4028: PPUSH
4029: LD_INT 53
4031: PPUSH
4032: CALL 7908 0 3
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 39
4046: PPUSH
4047: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 24
4056: PPUSH
4057: LD_INT 53
4059: PPUSH
4060: CALL 7908 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: LD_INT 71
4071: PPUSH
4072: LD_INT 10
4074: PPUSH
4075: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4079: LD_INT 3
4081: PPUSH
4082: LD_INT 24
4084: PPUSH
4085: LD_INT 53
4087: PPUSH
4088: CALL 7908 0 3
4092: PUSH
4093: LD_INT 1
4095: ARRAY
4096: PPUSH
4097: LD_INT 15
4099: PPUSH
4100: CALL 5497 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4104: LD_INT 3
4106: PPUSH
4107: LD_INT 24
4109: PPUSH
4110: LD_INT 53
4112: PPUSH
4113: CALL 7908 0 3
4117: PUSH
4118: LD_INT 1
4120: ARRAY
4121: PPUSH
4122: LD_INT 350
4124: PPUSH
4125: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4129: LD_INT 3
4131: PPUSH
4132: LD_INT 24
4134: PPUSH
4135: LD_INT 53
4137: PPUSH
4138: CALL 7908 0 3
4142: PUSH
4143: LD_INT 1
4145: ARRAY
4146: PPUSH
4147: LD_INT 14
4149: PPUSH
4150: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4154: LD_INT 67
4156: PPUSH
4157: LD_INT 39
4159: PPUSH
4160: LD_INT 3
4162: PPUSH
4163: CALL_OW 440
4167: PUSH
4168: LD_INT 67
4170: PPUSH
4171: LD_INT 39
4173: PPUSH
4174: CALL_OW 428
4178: PUSH
4179: LD_INT 0
4181: EQUAL
4182: AND
4183: PUSH
4184: LD_INT 79
4186: PPUSH
4187: LD_INT 45
4189: PPUSH
4190: CALL_OW 428
4194: PPUSH
4195: CALL_OW 266
4199: PUSH
4200: LD_INT 0
4202: EQUAL
4203: AND
4204: PUSH
4205: LD_INT 1
4207: PPUSH
4208: LD_INT 79
4210: PPUSH
4211: LD_INT 45
4213: PPUSH
4214: CALL 5383 0 3
4218: PUSH
4219: LD_INT 0
4221: EQUAL
4222: AND
4223: IFFALSE 4326
// begin for i = 1 to ru_eng do
4225: LD_ADDR_VAR 0 1
4229: PUSH
4230: DOUBLE
4231: LD_INT 1
4233: DEC
4234: ST_TO_ADDR
4235: LD_EXP 20
4239: PUSH
4240: FOR_TO
4241: IFFALSE 4324
// if IsInUnit ( ru_eng [ i ] ) then
4243: LD_EXP 20
4247: PUSH
4248: LD_VAR 0 1
4252: ARRAY
4253: PPUSH
4254: CALL_OW 310
4258: IFFALSE 4277
// ComExitBuilding ( ru_eng [ i ] ) else
4260: LD_EXP 20
4264: PUSH
4265: LD_VAR 0 1
4269: ARRAY
4270: PPUSH
4271: CALL_OW 122
4275: GO 4322
// if not HasTask ( ru_eng [ i ] ) then
4277: LD_EXP 20
4281: PUSH
4282: LD_VAR 0 1
4286: ARRAY
4287: PPUSH
4288: CALL_OW 314
4292: NOT
4293: IFFALSE 4322
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4295: LD_EXP 20
4299: PUSH
4300: LD_VAR 0 1
4304: ARRAY
4305: PPUSH
4306: LD_INT 30
4308: PPUSH
4309: LD_INT 67
4311: PPUSH
4312: LD_INT 39
4314: PPUSH
4315: LD_INT 3
4317: PPUSH
4318: CALL_OW 145
4322: GO 4240
4324: POP
4325: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4326: LD_INT 1
4328: PPUSH
4329: LD_INT 79
4331: PPUSH
4332: LD_INT 45
4334: PPUSH
4335: CALL 5383 0 3
4339: PUSH
4340: LD_INT 0
4342: EQUAL
4343: IFFALSE 4539
// begin if HexInfo ( 79 , 45 ) = 0 then
4345: LD_INT 79
4347: PPUSH
4348: LD_INT 45
4350: PPUSH
4351: CALL_OW 428
4355: PUSH
4356: LD_INT 0
4358: EQUAL
4359: IFFALSE 4381
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4361: LD_EXP 20
4365: PPUSH
4366: LD_INT 79
4368: PPUSH
4369: LD_INT 45
4371: PPUSH
4372: LD_INT 3
4374: PPUSH
4375: CALL 6923 0 4
4379: GO 4539
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4381: LD_INT 89
4383: PPUSH
4384: LD_INT 66
4386: PPUSH
4387: CALL_OW 428
4391: PUSH
4392: LD_INT 0
4394: EQUAL
4395: PUSH
4396: LD_INT 89
4398: PPUSH
4399: LD_INT 66
4401: PPUSH
4402: LD_INT 3
4404: PPUSH
4405: CALL_OW 440
4409: AND
4410: IFFALSE 4539
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4412: LD_INT 79
4414: PPUSH
4415: LD_INT 45
4417: PPUSH
4418: CALL_OW 428
4422: PPUSH
4423: CALL_OW 274
4427: PPUSH
4428: LD_INT 1
4430: PPUSH
4431: LD_INT 100
4433: PPUSH
4434: CALL_OW 277
// for i = 1 to ru_eng do
4438: LD_ADDR_VAR 0 1
4442: PUSH
4443: DOUBLE
4444: LD_INT 1
4446: DEC
4447: ST_TO_ADDR
4448: LD_EXP 20
4452: PUSH
4453: FOR_TO
4454: IFFALSE 4537
// if IsInUnit ( ru_eng [ i ] ) then
4456: LD_EXP 20
4460: PUSH
4461: LD_VAR 0 1
4465: ARRAY
4466: PPUSH
4467: CALL_OW 310
4471: IFFALSE 4490
// ComExitBuilding ( ru_eng [ i ] ) else
4473: LD_EXP 20
4477: PUSH
4478: LD_VAR 0 1
4482: ARRAY
4483: PPUSH
4484: CALL_OW 122
4488: GO 4535
// if not HasTask ( ru_eng [ i ] ) then
4490: LD_EXP 20
4494: PUSH
4495: LD_VAR 0 1
4499: ARRAY
4500: PPUSH
4501: CALL_OW 314
4505: NOT
4506: IFFALSE 4535
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4508: LD_EXP 20
4512: PUSH
4513: LD_VAR 0 1
4517: ARRAY
4518: PPUSH
4519: LD_INT 29
4521: PPUSH
4522: LD_INT 89
4524: PPUSH
4525: LD_INT 66
4527: PPUSH
4528: LD_INT 3
4530: PPUSH
4531: CALL_OW 145
4535: GO 4453
4537: POP
4538: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4539: LD_INT 3
4541: PPUSH
4542: LD_INT 29
4544: PPUSH
4545: CALL 6155 0 2
4549: PUSH
4550: LD_INT 0
4552: EQUAL
4553: PUSH
4554: LD_INT 1
4556: PPUSH
4557: LD_INT 36
4559: PPUSH
4560: LD_INT 6
4562: PPUSH
4563: CALL 5383 0 3
4567: PUSH
4568: LD_INT 0
4570: EQUAL
4571: AND
4572: PUSH
4573: LD_INT 3
4575: PPUSH
4576: CALL 6064 0 1
4580: PPUSH
4581: LD_INT 29
4583: PPUSH
4584: CALL 5640 0 2
4588: AND
4589: IFFALSE 4692
// begin for i = 1 to ru_eng do
4591: LD_ADDR_VAR 0 1
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_EXP 20
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4690
// begin if IsInUnit ( ru_eng [ i ] ) then
4609: LD_EXP 20
4613: PUSH
4614: LD_VAR 0 1
4618: ARRAY
4619: PPUSH
4620: CALL_OW 310
4624: IFFALSE 4643
// ComExitBuilding ( ru_eng [ i ] ) else
4626: LD_EXP 20
4630: PUSH
4631: LD_VAR 0 1
4635: ARRAY
4636: PPUSH
4637: CALL_OW 122
4641: GO 4688
// if not HasTask ( ru_eng [ i ] ) then
4643: LD_EXP 20
4647: PUSH
4648: LD_VAR 0 1
4652: ARRAY
4653: PPUSH
4654: CALL_OW 314
4658: NOT
4659: IFFALSE 4688
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4661: LD_EXP 20
4665: PUSH
4666: LD_VAR 0 1
4670: ARRAY
4671: PPUSH
4672: LD_INT 29
4674: PPUSH
4675: LD_INT 33
4677: PPUSH
4678: LD_INT 4
4680: PPUSH
4681: LD_INT 0
4683: PPUSH
4684: CALL_OW 205
// end ; end ;
4688: GO 4606
4690: POP
4691: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4692: LD_EXP 20
4696: PUSH
4697: LD_INT 79
4699: PPUSH
4700: LD_INT 45
4702: PPUSH
4703: CALL_OW 428
4707: PUSH
4708: LD_INT 0
4710: GREATER
4711: AND
4712: PUSH
4713: LD_INT 79
4715: PPUSH
4716: LD_INT 45
4718: PPUSH
4719: CALL_OW 428
4723: PPUSH
4724: CALL_OW 266
4728: PUSH
4729: LD_INT 0
4731: EQUAL
4732: AND
4733: IFFALSE 4893
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4735: LD_INT 79
4737: PPUSH
4738: LD_INT 45
4740: PPUSH
4741: CALL_OW 428
4745: PPUSH
4746: CALL_OW 255
4750: PUSH
4751: LD_INT 3
4753: EQUAL
4754: PUSH
4755: LD_INT 1
4757: PPUSH
4758: LD_INT 79
4760: PPUSH
4761: LD_INT 45
4763: PPUSH
4764: CALL 5383 0 3
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: AND
4773: PUSH
4774: LD_INT 79
4776: PPUSH
4777: LD_INT 45
4779: PPUSH
4780: CALL_OW 428
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 3
4792: PPUSH
4793: CALL_OW 275
4797: PUSH
4798: LD_INT 10
4800: GREATEREQUAL
4801: AND
4802: IFFALSE 4893
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4804: LD_EXP 20
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: CALL_OW 310
4817: IFFALSE 4834
// ComExitBuilding ( ru_eng [ 1 ] ) else
4819: LD_EXP 20
4823: PUSH
4824: LD_INT 1
4826: ARRAY
4827: PPUSH
4828: CALL_OW 122
4832: GO 4893
// if not HasTask ( ru_eng [ 1 ] ) then
4834: LD_EXP 20
4838: PUSH
4839: LD_INT 1
4841: ARRAY
4842: PPUSH
4843: CALL_OW 314
4847: NOT
4848: IFFALSE 4893
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4850: LD_EXP 20
4854: PUSH
4855: LD_INT 1
4857: ARRAY
4858: PPUSH
4859: LD_INT 79
4861: PPUSH
4862: LD_INT 45
4864: PPUSH
4865: CALL_OW 428
4869: PPUSH
4870: LD_INT 3
4872: PPUSH
4873: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4877: LD_EXP 20
4881: PUSH
4882: LD_INT 1
4884: ARRAY
4885: PPUSH
4886: LD_INT 2
4888: PPUSH
4889: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4893: LD_EXP 20
4897: PUSH
4898: LD_INT 2
4900: GREATER
4901: PUSH
4902: LD_INT 79
4904: PPUSH
4905: LD_INT 45
4907: PPUSH
4908: CALL_OW 428
4912: PUSH
4913: LD_INT 0
4915: GREATER
4916: AND
4917: PUSH
4918: LD_INT 79
4920: PPUSH
4921: LD_INT 45
4923: PPUSH
4924: CALL_OW 428
4928: PPUSH
4929: CALL_OW 266
4933: PUSH
4934: LD_INT 0
4936: EQUAL
4937: AND
4938: IFFALSE 5098
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
4940: LD_INT 79
4942: PPUSH
4943: LD_INT 45
4945: PPUSH
4946: CALL_OW 428
4950: PPUSH
4951: CALL_OW 255
4955: PUSH
4956: LD_INT 3
4958: EQUAL
4959: PUSH
4960: LD_INT 1
4962: PPUSH
4963: LD_INT 79
4965: PPUSH
4966: LD_INT 45
4968: PPUSH
4969: CALL 5383 0 3
4973: PUSH
4974: LD_INT 0
4976: EQUAL
4977: AND
4978: PUSH
4979: LD_INT 79
4981: PPUSH
4982: LD_INT 45
4984: PPUSH
4985: CALL_OW 428
4989: PPUSH
4990: CALL_OW 274
4994: PPUSH
4995: LD_INT 1
4997: PPUSH
4998: CALL_OW 275
5002: PUSH
5003: LD_INT 20
5005: GREATER
5006: AND
5007: IFFALSE 5098
// begin if IsInUnit ( ru_eng [ 2 ] ) then
5009: LD_EXP 20
5013: PUSH
5014: LD_INT 2
5016: ARRAY
5017: PPUSH
5018: CALL_OW 310
5022: IFFALSE 5039
// ComExitBuilding ( ru_eng [ 2 ] ) else
5024: LD_EXP 20
5028: PUSH
5029: LD_INT 2
5031: ARRAY
5032: PPUSH
5033: CALL_OW 122
5037: GO 5098
// if not HasTask ( ru_eng [ 2 ] ) then
5039: LD_EXP 20
5043: PUSH
5044: LD_INT 2
5046: ARRAY
5047: PPUSH
5048: CALL_OW 314
5052: NOT
5053: IFFALSE 5098
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5055: LD_EXP 20
5059: PUSH
5060: LD_INT 2
5062: ARRAY
5063: PPUSH
5064: LD_INT 79
5066: PPUSH
5067: LD_INT 45
5069: PPUSH
5070: CALL_OW 428
5074: PPUSH
5075: LD_INT 1
5077: PPUSH
5078: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5082: LD_EXP 20
5086: PUSH
5087: LD_INT 2
5089: ARRAY
5090: PPUSH
5091: LD_INT 2
5093: PPUSH
5094: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5098: LD_INT 1
5100: PPUSH
5101: LD_INT 59
5103: PPUSH
5104: LD_INT 60
5106: PPUSH
5107: CALL 5383 0 3
5111: PUSH
5112: LD_INT 0
5114: EQUAL
5115: PUSH
5116: LD_INT 1
5118: PPUSH
5119: LD_INT 67
5121: PPUSH
5122: LD_INT 76
5124: PPUSH
5125: CALL 5383 0 3
5129: PUSH
5130: LD_INT 0
5132: EQUAL
5133: AND
5134: PUSH
5135: LD_INT 1
5137: PPUSH
5138: LD_INT 79
5140: PPUSH
5141: LD_INT 100
5143: PPUSH
5144: CALL 5383 0 3
5148: PUSH
5149: LD_INT 0
5151: EQUAL
5152: AND
5153: IFFALSE 5165
// CollectCrates ( 3 , west_crates ) ;
5155: LD_INT 3
5157: PPUSH
5158: LD_INT 13
5160: PPUSH
5161: CALL 11428 0 2
// end ;
5165: PPOPN 10
5167: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5168: LD_OWVAR 1
5172: PUSH
5173: LD_INT 111300
5175: LESSEQUAL
5176: PUSH
5177: LD_EXP 29
5181: NOT
5182: OR
5183: IFFALSE 5380
5185: GO 5187
5187: DISABLE
5188: LD_INT 0
5190: PPUSH
// begin enable ;
5191: ENABLE
// uc_nation := 3 ;
5192: LD_ADDR_OWVAR 21
5196: PUSH
5197: LD_INT 3
5199: ST_TO_ADDR
// uc_side := 3 ;
5200: LD_ADDR_OWVAR 20
5204: PUSH
5205: LD_INT 3
5207: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5208: LD_ADDR_OWVAR 37
5212: PUSH
5213: LD_INT 22
5215: ST_TO_ADDR
// vc_engine := engine_siberite ;
5216: LD_ADDR_OWVAR 39
5220: PUSH
5221: LD_INT 3
5223: ST_TO_ADDR
// vc_control := control_computer ;
5224: LD_ADDR_OWVAR 38
5228: PUSH
5229: LD_INT 3
5231: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5232: LD_ADDR_OWVAR 40
5236: PUSH
5237: LD_INT 51
5239: ST_TO_ADDR
// veh := CreateVehicle ;
5240: LD_ADDR_VAR 0 1
5244: PUSH
5245: CALL_OW 45
5249: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5250: LD_VAR 0 1
5254: PPUSH
5255: LD_INT 4
5257: PPUSH
5258: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5262: LD_VAR 0 1
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: LD_INT 0
5272: PPUSH
5273: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5277: LD_VAR 0 1
5281: PPUSH
5282: LD_INT 1
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: LD_INT 3
5290: PUSH
5291: LD_INT 2
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: PUSH
5300: LD_INT 1
5302: PPUSH
5303: LD_INT 4
5305: PPUSH
5306: CALL_OW 12
5310: ARRAY
5311: PPUSH
5312: LD_INT 100
5314: PPUSH
5315: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5319: LD_VAR 0 1
5323: PPUSH
5324: LD_INT 2
5326: PPUSH
5327: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5331: LD_VAR 0 1
5335: PPUSH
5336: LD_INT 10
5338: PPUSH
5339: CALL_OW 173
// Wait ( 0 0$10 ) ;
5343: LD_INT 350
5345: PPUSH
5346: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5357: LD_VAR 0 1
5361: PPUSH
5362: LD_INT 10
5364: PPUSH
5365: CALL_OW 308
5369: IFFALSE 5350
// RemoveUnit ( veh ) ;
5371: LD_VAR 0 1
5375: PPUSH
5376: CALL_OW 64
// end ; end_of_file
5380: PPOPN 1
5382: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
5383: LD_INT 0
5385: PPUSH
5386: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
5387: LD_ADDR_VAR 0 5
5391: PUSH
5392: LD_INT 22
5394: PUSH
5395: LD_VAR 0 1
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: PPUSH
5404: CALL_OW 69
5408: PPUSH
5409: LD_VAR 0 2
5413: PPUSH
5414: LD_VAR 0 3
5418: PPUSH
5419: CALL_OW 73
5423: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 then
5424: LD_VAR 0 5
5428: PPUSH
5429: LD_VAR 0 2
5433: PPUSH
5434: LD_VAR 0 3
5438: PPUSH
5439: CALL_OW 297
5443: PUSH
5444: LD_INT 17
5446: LESS
5447: PUSH
5448: LD_INT 2
5450: PPUSH
5451: LD_INT 22
5453: PUSH
5454: LD_VAR 0 1
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL_OW 70
5467: PUSH
5468: LD_INT 0
5470: GREATER
5471: OR
5472: IFFALSE 5484
// result := true else
5474: LD_ADDR_VAR 0 4
5478: PUSH
5479: LD_INT 1
5481: ST_TO_ADDR
5482: GO 5492
// result := false ;
5484: LD_ADDR_VAR 0 4
5488: PUSH
5489: LD_INT 0
5491: ST_TO_ADDR
// end ;
5492: LD_VAR 0 4
5496: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
5497: LD_INT 0
5499: PPUSH
5500: PPUSH
// area = ListEnvironmentArea ( area ) ;
5501: LD_ADDR_VAR 0 2
5505: PUSH
5506: LD_VAR 0 2
5510: PPUSH
5511: CALL_OW 353
5515: ST_TO_ADDR
// if bulldozer > 0 then
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 0
5523: GREATER
5524: IFFALSE 5635
// for i = 1 to area do
5526: LD_ADDR_VAR 0 4
5530: PUSH
5531: DOUBLE
5532: LD_INT 1
5534: DEC
5535: ST_TO_ADDR
5536: LD_VAR 0 2
5540: PUSH
5541: FOR_TO
5542: IFFALSE 5633
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
5544: LD_VAR 0 2
5548: PUSH
5549: LD_VAR 0 4
5553: ARRAY
5554: PUSH
5555: LD_INT 1
5557: ARRAY
5558: PPUSH
5559: LD_VAR 0 2
5563: PUSH
5564: LD_VAR 0 4
5568: ARRAY
5569: PUSH
5570: LD_INT 2
5572: ARRAY
5573: PPUSH
5574: CALL_OW 351
5578: IFFALSE 5631
// if not HasTask ( bulldozer ) then
5580: LD_VAR 0 1
5584: PPUSH
5585: CALL_OW 314
5589: NOT
5590: IFFALSE 5631
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
5592: LD_VAR 0 1
5596: PPUSH
5597: LD_VAR 0 2
5601: PUSH
5602: LD_VAR 0 4
5606: ARRAY
5607: PUSH
5608: LD_INT 1
5610: ARRAY
5611: PPUSH
5612: LD_VAR 0 2
5616: PUSH
5617: LD_VAR 0 4
5621: ARRAY
5622: PUSH
5623: LD_INT 2
5625: ARRAY
5626: PPUSH
5627: CALL_OW 171
5631: GO 5541
5633: POP
5634: POP
// end ;
5635: LD_VAR 0 3
5639: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
5640: LD_INT 0
5642: PPUSH
5643: PPUSH
5644: PPUSH
// pom := GetBase ( bdepot ) ;
5645: LD_ADDR_VAR 0 4
5649: PUSH
5650: LD_VAR 0 1
5654: PPUSH
5655: CALL_OW 274
5659: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
5660: LD_ADDR_VAR 0 5
5664: PUSH
5665: LD_VAR 0 2
5669: PPUSH
5670: LD_VAR 0 1
5674: PPUSH
5675: CALL_OW 248
5679: PPUSH
5680: CALL_OW 450
5684: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
5685: LD_VAR 0 4
5689: PPUSH
5690: LD_INT 1
5692: PPUSH
5693: CALL_OW 275
5697: PUSH
5698: LD_VAR 0 5
5702: PUSH
5703: LD_INT 1
5705: ARRAY
5706: GREATEREQUAL
5707: PUSH
5708: LD_VAR 0 4
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 275
5720: PUSH
5721: LD_VAR 0 5
5725: PUSH
5726: LD_INT 3
5728: ARRAY
5729: GREATEREQUAL
5730: AND
5731: IFFALSE 5743
// result := true else
5733: LD_ADDR_VAR 0 3
5737: PUSH
5738: LD_INT 1
5740: ST_TO_ADDR
5741: GO 5751
// result := false ;
5743: LD_ADDR_VAR 0 3
5747: PUSH
5748: LD_INT 0
5750: ST_TO_ADDR
// end ;
5751: LD_VAR 0 3
5755: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
5756: LD_INT 0
5758: PPUSH
5759: PPUSH
5760: PPUSH
// pom := GetBase ( bdepot ) ;
5761: LD_ADDR_VAR 0 3
5765: PUSH
5766: LD_VAR 0 1
5770: PPUSH
5771: CALL_OW 274
5775: ST_TO_ADDR
// sor := [ ] ;
5776: LD_ADDR_VAR 0 4
5780: PUSH
5781: EMPTY
5782: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
5783: LD_ADDR_VAR 0 4
5787: PUSH
5788: LD_VAR 0 4
5792: PUSH
5793: LD_VAR 0 3
5797: PPUSH
5798: LD_INT 1
5800: PPUSH
5801: CALL_OW 275
5805: ADD
5806: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
5807: LD_ADDR_VAR 0 4
5811: PUSH
5812: LD_VAR 0 4
5816: PUSH
5817: LD_VAR 0 3
5821: PPUSH
5822: LD_INT 2
5824: PPUSH
5825: CALL_OW 275
5829: ADD
5830: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
5831: LD_ADDR_VAR 0 4
5835: PUSH
5836: LD_VAR 0 4
5840: PUSH
5841: LD_VAR 0 3
5845: PPUSH
5846: LD_INT 3
5848: PPUSH
5849: CALL_OW 275
5853: ADD
5854: ST_TO_ADDR
// result := sor ;
5855: LD_ADDR_VAR 0 2
5859: PUSH
5860: LD_VAR 0 4
5864: ST_TO_ADDR
// end ;
5865: LD_VAR 0 2
5869: RET
// export function Hex ( x , y ) ; begin
5870: LD_INT 0
5872: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
5873: LD_VAR 0 1
5877: PPUSH
5878: LD_VAR 0 2
5882: PPUSH
5883: CALL_OW 488
5887: PUSH
5888: LD_VAR 0 1
5892: PPUSH
5893: LD_VAR 0 2
5897: PPUSH
5898: CALL_OW 428
5902: PUSH
5903: LD_INT 0
5905: EQUAL
5906: AND
5907: IFFALSE 5919
// result := true else
5909: LD_ADDR_VAR 0 3
5913: PUSH
5914: LD_INT 1
5916: ST_TO_ADDR
5917: GO 5927
// result := false ;
5919: LD_ADDR_VAR 0 3
5923: PUSH
5924: LD_INT 0
5926: ST_TO_ADDR
// end ;
5927: LD_VAR 0 3
5931: RET
// export function NeedBuilding ( side , btype ) ; begin
5932: LD_INT 0
5934: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
5935: LD_INT 22
5937: PUSH
5938: LD_VAR 0 1
5942: PUSH
5943: EMPTY
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 30
5949: PUSH
5950: LD_VAR 0 2
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 3
5961: PUSH
5962: LD_INT 57
5964: PUSH
5965: EMPTY
5966: LIST
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: LIST
5976: PPUSH
5977: CALL_OW 69
5981: PUSH
5982: LD_INT 0
5984: EQUAL
5985: IFFALSE 5997
// result := true else
5987: LD_ADDR_VAR 0 3
5991: PUSH
5992: LD_INT 1
5994: ST_TO_ADDR
5995: GO 6005
// result := false ;
5997: LD_ADDR_VAR 0 3
6001: PUSH
6002: LD_INT 0
6004: ST_TO_ADDR
// end ;
6005: LD_VAR 0 3
6009: RET
// export function NeedBase ( side ) ; begin
6010: LD_INT 0
6012: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6013: LD_VAR 0 1
6017: PPUSH
6018: LD_INT 0
6020: PPUSH
6021: CALL 5932 0 2
6025: PUSH
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 1
6033: PPUSH
6034: CALL 5932 0 2
6038: AND
6039: IFFALSE 6051
// result := true else
6041: LD_ADDR_VAR 0 2
6045: PUSH
6046: LD_INT 1
6048: ST_TO_ADDR
6049: GO 6059
// result := false ;
6051: LD_ADDR_VAR 0 2
6055: PUSH
6056: LD_INT 0
6058: ST_TO_ADDR
// end ;
6059: LD_VAR 0 2
6063: RET
// export function MyBase ( side ) ; begin
6064: LD_INT 0
6066: PPUSH
// if not NeedBase ( side ) then
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL 6010 0 1
6076: NOT
6077: IFFALSE 6142
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6079: LD_ADDR_VAR 0 2
6083: PUSH
6084: LD_INT 22
6086: PUSH
6087: LD_VAR 0 1
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: LD_INT 2
6098: PUSH
6099: LD_INT 30
6101: PUSH
6102: LD_INT 0
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 30
6111: PUSH
6112: LD_INT 1
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: EMPTY
6129: LIST
6130: PPUSH
6131: CALL_OW 69
6135: PUSH
6136: LD_INT 1
6138: ARRAY
6139: ST_TO_ADDR
6140: GO 6150
// result := false ;
6142: LD_ADDR_VAR 0 2
6146: PUSH
6147: LD_INT 0
6149: ST_TO_ADDR
// end ;
6150: LD_VAR 0 2
6154: RET
// export function GetBuilding ( side , btype ) ; begin
6155: LD_INT 0
6157: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6158: LD_INT 22
6160: PUSH
6161: LD_VAR 0 1
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 30
6172: PUSH
6173: LD_VAR 0 2
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PPUSH
6186: CALL_OW 69
6190: PUSH
6191: LD_INT 0
6193: GREATER
6194: IFFALSE 6236
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6196: LD_ADDR_VAR 0 3
6200: PUSH
6201: LD_INT 22
6203: PUSH
6204: LD_VAR 0 1
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PUSH
6213: LD_INT 30
6215: PUSH
6216: LD_VAR 0 2
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: PPUSH
6229: CALL_OW 69
6233: ST_TO_ADDR
6234: GO 6244
// result := false ;
6236: LD_ADDR_VAR 0 3
6240: PUSH
6241: LD_INT 0
6243: ST_TO_ADDR
// end ;
6244: LD_VAR 0 3
6248: RET
// export function GetCrates ( side ) ; begin
6249: LD_INT 0
6251: PPUSH
// if MyBase ( side ) then
6252: LD_VAR 0 1
6256: PPUSH
6257: CALL 6064 0 1
6261: IFFALSE 6293
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
6263: LD_ADDR_VAR 0 2
6267: PUSH
6268: LD_VAR 0 1
6272: PPUSH
6273: CALL 6064 0 1
6277: PPUSH
6278: CALL_OW 274
6282: PPUSH
6283: LD_INT 1
6285: PPUSH
6286: CALL_OW 275
6290: ST_TO_ADDR
6291: GO 6301
// result := false ;
6293: LD_ADDR_VAR 0 2
6297: PUSH
6298: LD_INT 0
6300: ST_TO_ADDR
// end ;
6301: LD_VAR 0 2
6305: RET
// export function GetLabs ( side ) ; begin
6306: LD_INT 0
6308: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6309: LD_ADDR_VAR 0 2
6313: PUSH
6314: LD_INT 22
6316: PUSH
6317: LD_VAR 0 1
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PUSH
6326: LD_INT 2
6328: PUSH
6329: LD_INT 30
6331: PUSH
6332: LD_INT 6
6334: PUSH
6335: EMPTY
6336: LIST
6337: LIST
6338: PUSH
6339: LD_INT 30
6341: PUSH
6342: LD_INT 8
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PUSH
6349: LD_INT 30
6351: PUSH
6352: LD_INT 7
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: PUSH
6369: EMPTY
6370: LIST
6371: PPUSH
6372: CALL_OW 69
6376: ST_TO_ADDR
// end ;
6377: LD_VAR 0 2
6381: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
6382: LD_INT 0
6384: PPUSH
6385: PPUSH
6386: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
6387: LD_ADDR_VAR 0 3
6391: PUSH
6392: LD_VAR 0 1
6396: PPUSH
6397: LD_INT 1
6399: PPUSH
6400: CALL_OW 268
6404: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
6405: LD_ADDR_VAR 0 4
6409: PUSH
6410: LD_VAR 0 1
6414: PPUSH
6415: LD_INT 2
6417: PPUSH
6418: CALL_OW 268
6422: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
6423: LD_ADDR_VAR 0 2
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_VAR 0 4
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: ST_TO_ADDR
// end ;
6442: LD_VAR 0 2
6446: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
6447: LD_INT 0
6449: PPUSH
6450: PPUSH
// result := false ;
6451: LD_ADDR_VAR 0 3
6455: PUSH
6456: LD_INT 0
6458: ST_TO_ADDR
// for i = 1 to tlist do
6459: LD_ADDR_VAR 0 4
6463: PUSH
6464: DOUBLE
6465: LD_INT 1
6467: DEC
6468: ST_TO_ADDR
6469: LD_VAR 0 2
6473: PUSH
6474: FOR_TO
6475: IFFALSE 6515
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6477: LD_VAR 0 2
6481: PUSH
6482: LD_VAR 0 4
6486: ARRAY
6487: PPUSH
6488: LD_VAR 0 1
6492: PPUSH
6493: CALL_OW 321
6497: PUSH
6498: LD_INT 2
6500: NONEQUAL
6501: IFFALSE 6513
// begin result := true ;
6503: LD_ADDR_VAR 0 3
6507: PUSH
6508: LD_INT 1
6510: ST_TO_ADDR
// break ;
6511: GO 6515
// end ;
6513: GO 6474
6515: POP
6516: POP
// end ;
6517: LD_VAR 0 3
6521: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
6522: LD_INT 0
6524: PPUSH
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
6529: PPUSH
6530: PPUSH
6531: PPUSH
// lab := GetLabs ( side ) ;
6532: LD_ADDR_VAR 0 5
6536: PUSH
6537: LD_VAR 0 1
6541: PPUSH
6542: CALL 6306 0 1
6546: ST_TO_ADDR
// tmp := 0 ;
6547: LD_ADDR_VAR 0 7
6551: PUSH
6552: LD_INT 0
6554: ST_TO_ADDR
// list := [ ] ;
6555: LD_ADDR_VAR 0 8
6559: PUSH
6560: EMPTY
6561: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
6562: LD_ADDR_VAR 0 10
6566: PUSH
6567: LD_INT 35
6569: PUSH
6570: LD_INT 45
6572: PUSH
6573: LD_INT 46
6575: PUSH
6576: LD_INT 47
6578: PUSH
6579: LD_INT 1
6581: PUSH
6582: LD_INT 2
6584: PUSH
6585: LD_INT 48
6587: PUSH
6588: LD_INT 49
6590: PUSH
6591: LD_INT 50
6593: PUSH
6594: LD_INT 20
6596: PUSH
6597: EMPTY
6598: LIST
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: LIST
6606: LIST
6607: LIST
6608: ST_TO_ADDR
// for i = 1 to tlist do
6609: LD_ADDR_VAR 0 4
6613: PUSH
6614: DOUBLE
6615: LD_INT 1
6617: DEC
6618: ST_TO_ADDR
6619: LD_VAR 0 2
6623: PUSH
6624: FOR_TO
6625: IFFALSE 6677
// if GetTech ( tlist [ i ] , side ) <> state_researched then
6627: LD_VAR 0 2
6631: PUSH
6632: LD_VAR 0 4
6636: ARRAY
6637: PPUSH
6638: LD_VAR 0 1
6642: PPUSH
6643: CALL_OW 321
6647: PUSH
6648: LD_INT 2
6650: NONEQUAL
6651: IFFALSE 6675
// list := list ^ tlist [ i ] ;
6653: LD_ADDR_VAR 0 8
6657: PUSH
6658: LD_VAR 0 8
6662: PUSH
6663: LD_VAR 0 2
6667: PUSH
6668: LD_VAR 0 4
6672: ARRAY
6673: ADD
6674: ST_TO_ADDR
6675: GO 6624
6677: POP
6678: POP
// if list then
6679: LD_VAR 0 8
6683: IFFALSE 6848
// begin for i = 1 to lab do
6685: LD_ADDR_VAR 0 4
6689: PUSH
6690: DOUBLE
6691: LD_INT 1
6693: DEC
6694: ST_TO_ADDR
6695: LD_VAR 0 5
6699: PUSH
6700: FOR_TO
6701: IFFALSE 6771
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
6703: LD_VAR 0 8
6707: PUSH
6708: LD_INT 1
6710: ARRAY
6711: PUSH
6712: LD_VAR 0 10
6716: IN
6717: PUSH
6718: LD_VAR 0 8
6722: PUSH
6723: LD_INT 1
6725: ARRAY
6726: PPUSH
6727: CALL_OW 481
6731: PUSH
6732: LD_VAR 0 5
6736: PUSH
6737: LD_VAR 0 4
6741: ARRAY
6742: PPUSH
6743: CALL 6382 0 1
6747: IN
6748: OR
6749: IFFALSE 6769
// begin mylab := lab [ i ] ;
6751: LD_ADDR_VAR 0 9
6755: PUSH
6756: LD_VAR 0 5
6760: PUSH
6761: LD_VAR 0 4
6765: ARRAY
6766: ST_TO_ADDR
// break ;
6767: GO 6771
// end ;
6769: GO 6700
6771: POP
6772: POP
// if mylab then
6773: LD_VAR 0 9
6777: IFFALSE 6838
// begin if BuildingStatus ( mylab ) = bs_idle then
6779: LD_VAR 0 9
6783: PPUSH
6784: CALL_OW 461
6788: PUSH
6789: LD_INT 2
6791: EQUAL
6792: IFFALSE 6836
// for i = 1 to list do
6794: LD_ADDR_VAR 0 4
6798: PUSH
6799: DOUBLE
6800: LD_INT 1
6802: DEC
6803: ST_TO_ADDR
6804: LD_VAR 0 8
6808: PUSH
6809: FOR_TO
6810: IFFALSE 6834
// AddComResearch ( mylab , list [ i ] ) ;
6812: LD_VAR 0 9
6816: PPUSH
6817: LD_VAR 0 8
6821: PUSH
6822: LD_VAR 0 4
6826: ARRAY
6827: PPUSH
6828: CALL_OW 184
6832: GO 6809
6834: POP
6835: POP
// end else
6836: GO 6846
// result := false ;
6838: LD_ADDR_VAR 0 3
6842: PUSH
6843: LD_INT 0
6845: ST_TO_ADDR
// end else
6846: GO 6856
// result := false ;
6848: LD_ADDR_VAR 0 3
6852: PUSH
6853: LD_INT 0
6855: ST_TO_ADDR
// end ;
6856: LD_VAR 0 3
6860: RET
// export function GetTowers ( side ) ; begin
6861: LD_INT 0
6863: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
6864: LD_ADDR_VAR 0 2
6868: PUSH
6869: LD_INT 22
6871: PUSH
6872: LD_VAR 0 1
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: PUSH
6881: LD_INT 2
6883: PUSH
6884: LD_INT 30
6886: PUSH
6887: LD_INT 32
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PUSH
6894: LD_INT 30
6896: PUSH
6897: LD_INT 33
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: LIST
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: CALL_OW 69
6917: ST_TO_ADDR
// end ;
6918: LD_VAR 0 2
6922: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
6923: LD_INT 0
6925: PPUSH
6926: PPUSH
// if Hex ( x , y ) then
6927: LD_VAR 0 2
6931: PPUSH
6932: LD_VAR 0 3
6936: PPUSH
6937: CALL 5870 0 2
6941: IFFALSE 7016
// for i = 1 to plist do
6943: LD_ADDR_VAR 0 6
6947: PUSH
6948: DOUBLE
6949: LD_INT 1
6951: DEC
6952: ST_TO_ADDR
6953: LD_VAR 0 1
6957: PUSH
6958: FOR_TO
6959: IFFALSE 7014
// if not HasTask ( plist [ i ] ) then
6961: LD_VAR 0 1
6965: PUSH
6966: LD_VAR 0 6
6970: ARRAY
6971: PPUSH
6972: CALL_OW 314
6976: NOT
6977: IFFALSE 7012
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
6979: LD_VAR 0 1
6983: PUSH
6984: LD_VAR 0 6
6988: ARRAY
6989: PPUSH
6990: LD_INT 0
6992: PPUSH
6993: LD_VAR 0 2
6997: PPUSH
6998: LD_VAR 0 3
7002: PPUSH
7003: LD_VAR 0 4
7007: PPUSH
7008: CALL_OW 145
7012: GO 6958
7014: POP
7015: POP
// end ;
7016: LD_VAR 0 5
7020: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7021: LD_INT 0
7023: PPUSH
7024: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7025: LD_VAR 0 2
7029: PPUSH
7030: CALL_OW 266
7034: PUSH
7035: LD_INT 0
7037: EQUAL
7038: PUSH
7039: LD_VAR 0 2
7043: PPUSH
7044: LD_INT 1
7046: PPUSH
7047: CALL 5640 0 2
7051: AND
7052: PUSH
7053: LD_VAR 0 1
7057: PUSH
7058: LD_INT 1
7060: ARRAY
7061: PPUSH
7062: CALL_OW 255
7066: PPUSH
7067: CALL_OW 345
7071: NOT
7072: AND
7073: IFFALSE 7169
// begin ComUpgrade ( bident ) ;
7075: LD_VAR 0 2
7079: PPUSH
7080: CALL_OW 146
// for i = 1 to plist do
7084: LD_ADDR_VAR 0 4
7088: PUSH
7089: DOUBLE
7090: LD_INT 1
7092: DEC
7093: ST_TO_ADDR
7094: LD_VAR 0 1
7098: PUSH
7099: FOR_TO
7100: IFFALSE 7157
// if not HasTask ( plist [ i ] ) then
7102: LD_VAR 0 1
7106: PUSH
7107: LD_VAR 0 4
7111: ARRAY
7112: PPUSH
7113: CALL_OW 314
7117: NOT
7118: IFFALSE 7155
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7120: LD_VAR 0 1
7124: PUSH
7125: LD_VAR 0 4
7129: ARRAY
7130: PPUSH
7131: LD_VAR 0 2
7135: PPUSH
7136: CALL_OW 250
7140: PPUSH
7141: LD_VAR 0 2
7145: PPUSH
7146: CALL_OW 251
7150: PPUSH
7151: CALL_OW 111
7155: GO 7099
7157: POP
7158: POP
// result := true ;
7159: LD_ADDR_VAR 0 3
7163: PUSH
7164: LD_INT 1
7166: ST_TO_ADDR
// end else
7167: GO 7177
// result := false ;
7169: LD_ADDR_VAR 0 3
7173: PUSH
7174: LD_INT 0
7176: ST_TO_ADDR
// end ;
7177: LD_VAR 0 3
7181: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7182: LD_INT 0
7184: PPUSH
7185: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7186: LD_VAR 0 1
7190: PUSH
7191: LD_INT 1
7193: ARRAY
7194: PPUSH
7195: CALL_OW 255
7199: PPUSH
7200: CALL 6249 0 1
7204: PUSH
7205: LD_INT 20
7207: GREATEREQUAL
7208: PUSH
7209: LD_VAR 0 2
7213: PPUSH
7214: LD_VAR 0 3
7218: PPUSH
7219: CALL 5870 0 2
7223: AND
7224: IFFALSE 7309
// begin for i = 1 to plist do
7226: LD_ADDR_VAR 0 6
7230: PUSH
7231: DOUBLE
7232: LD_INT 1
7234: DEC
7235: ST_TO_ADDR
7236: LD_VAR 0 1
7240: PUSH
7241: FOR_TO
7242: IFFALSE 7297
// if not HasTask ( plist [ i ] ) then
7244: LD_VAR 0 1
7248: PUSH
7249: LD_VAR 0 6
7253: ARRAY
7254: PPUSH
7255: CALL_OW 314
7259: NOT
7260: IFFALSE 7295
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7262: LD_VAR 0 1
7266: PUSH
7267: LD_VAR 0 6
7271: ARRAY
7272: PPUSH
7273: LD_INT 6
7275: PPUSH
7276: LD_VAR 0 2
7280: PPUSH
7281: LD_VAR 0 3
7285: PPUSH
7286: LD_VAR 0 4
7290: PPUSH
7291: CALL_OW 145
7295: GO 7241
7297: POP
7298: POP
// result := true ;
7299: LD_ADDR_VAR 0 5
7303: PUSH
7304: LD_INT 1
7306: ST_TO_ADDR
// end else
7307: GO 7317
// result := false ;
7309: LD_ADDR_VAR 0 5
7313: PUSH
7314: LD_INT 0
7316: ST_TO_ADDR
// end ;
7317: LD_VAR 0 5
7321: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7322: LD_INT 0
7324: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7325: LD_VAR 0 1
7329: PPUSH
7330: LD_INT 1
7332: PPUSH
7333: CALL_OW 268
7337: PUSH
7338: LD_INT 9
7340: EQUAL
7341: PUSH
7342: LD_VAR 0 1
7346: PPUSH
7347: LD_INT 2
7349: PPUSH
7350: CALL_OW 268
7354: PUSH
7355: LD_INT 9
7357: EQUAL
7358: AND
7359: IFFALSE 7456
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7361: LD_VAR 0 1
7365: PPUSH
7366: LD_VAR 0 2
7370: PPUSH
7371: CALL 5640 0 2
7375: PUSH
7376: LD_VAR 0 1
7380: PPUSH
7381: LD_VAR 0 3
7385: PPUSH
7386: CALL 5640 0 2
7390: AND
7391: PUSH
7392: LD_VAR 0 1
7396: PPUSH
7397: CALL_OW 461
7401: PUSH
7402: LD_INT 2
7404: EQUAL
7405: AND
7406: IFFALSE 7446
// begin ComUpgradeLab ( lab , bkind1 ) ;
7408: LD_VAR 0 1
7412: PPUSH
7413: LD_VAR 0 2
7417: PPUSH
7418: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
7422: LD_VAR 0 1
7426: PPUSH
7427: LD_VAR 0 3
7431: PPUSH
7432: CALL_OW 207
// result := true ;
7436: LD_ADDR_VAR 0 4
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// end else
7444: GO 7454
// result := false ;
7446: LD_ADDR_VAR 0 4
7450: PUSH
7451: LD_INT 0
7453: ST_TO_ADDR
// end else
7454: GO 7464
// result := false ;
7456: LD_ADDR_VAR 0 4
7460: PUSH
7461: LD_INT 0
7463: ST_TO_ADDR
// end ;
7464: LD_VAR 0 4
7468: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
7469: LD_INT 0
7471: PPUSH
7472: PPUSH
7473: PPUSH
7474: PPUSH
7475: PPUSH
// p := 1 ;
7476: LD_ADDR_VAR 0 6
7480: PUSH
7481: LD_INT 1
7483: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
7484: LD_ADDR_VAR 0 4
7488: PUSH
7489: DOUBLE
7490: LD_INT 1
7492: DEC
7493: ST_TO_ADDR
7494: LD_VAR 0 2
7498: PUSH
7499: LD_INT 4
7501: DIVREAL
7502: PUSH
7503: FOR_TO
7504: IFFALSE 7753
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
7506: LD_VAR 0 2
7510: PUSH
7511: LD_VAR 0 6
7515: PUSH
7516: LD_INT 1
7518: PLUS
7519: ARRAY
7520: PPUSH
7521: LD_VAR 0 2
7525: PUSH
7526: LD_VAR 0 6
7530: PUSH
7531: LD_INT 2
7533: PLUS
7534: ARRAY
7535: PPUSH
7536: CALL_OW 428
7540: PUSH
7541: LD_INT 0
7543: EQUAL
7544: PUSH
7545: LD_VAR 0 2
7549: PUSH
7550: LD_VAR 0 6
7554: PUSH
7555: LD_INT 1
7557: PLUS
7558: ARRAY
7559: PPUSH
7560: LD_VAR 0 2
7564: PUSH
7565: LD_VAR 0 6
7569: PUSH
7570: LD_INT 2
7572: PLUS
7573: ARRAY
7574: PPUSH
7575: CALL 5870 0 2
7579: AND
7580: PUSH
7581: LD_VAR 0 1
7585: PUSH
7586: LD_INT 1
7588: ARRAY
7589: PPUSH
7590: CALL_OW 255
7594: PPUSH
7595: CALL 6249 0 1
7599: PUSH
7600: LD_INT 20
7602: GREATEREQUAL
7603: AND
7604: IFFALSE 7721
// begin for c = 1 to plist do
7606: LD_ADDR_VAR 0 7
7610: PUSH
7611: DOUBLE
7612: LD_INT 1
7614: DEC
7615: ST_TO_ADDR
7616: LD_VAR 0 1
7620: PUSH
7621: FOR_TO
7622: IFFALSE 7715
// if not HasTask ( plist [ c ] ) then
7624: LD_VAR 0 1
7628: PUSH
7629: LD_VAR 0 7
7633: ARRAY
7634: PPUSH
7635: CALL_OW 314
7639: NOT
7640: IFFALSE 7713
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
7642: LD_VAR 0 1
7646: PUSH
7647: LD_VAR 0 7
7651: ARRAY
7652: PPUSH
7653: LD_VAR 0 2
7657: PUSH
7658: LD_VAR 0 6
7662: ARRAY
7663: PPUSH
7664: LD_VAR 0 2
7668: PUSH
7669: LD_VAR 0 6
7673: PUSH
7674: LD_INT 1
7676: PLUS
7677: ARRAY
7678: PPUSH
7679: LD_VAR 0 2
7683: PUSH
7684: LD_VAR 0 6
7688: PUSH
7689: LD_INT 2
7691: PLUS
7692: ARRAY
7693: PPUSH
7694: LD_VAR 0 2
7698: PUSH
7699: LD_VAR 0 6
7703: PUSH
7704: LD_INT 3
7706: PLUS
7707: ARRAY
7708: PPUSH
7709: CALL_OW 145
7713: GO 7621
7715: POP
7716: POP
// break ;
7717: GO 7753
// end else
7719: GO 7751
// if ( p + 4 < tlist ) then
7721: LD_VAR 0 6
7725: PUSH
7726: LD_INT 4
7728: PLUS
7729: PUSH
7730: LD_VAR 0 2
7734: LESS
7735: IFFALSE 7751
// p := p + 4 ;
7737: LD_ADDR_VAR 0 6
7741: PUSH
7742: LD_VAR 0 6
7746: PUSH
7747: LD_INT 4
7749: PLUS
7750: ST_TO_ADDR
// end ;
7751: GO 7503
7753: POP
7754: POP
// end ;
7755: LD_VAR 0 3
7759: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
7760: LD_INT 0
7762: PPUSH
7763: PPUSH
7764: PPUSH
7765: PPUSH
// tmp := GetTowers ( side ) ;
7766: LD_ADDR_VAR 0 5
7770: PUSH
7771: LD_VAR 0 1
7775: PPUSH
7776: CALL 6861 0 1
7780: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
7781: LD_ADDR_VAR 0 6
7785: PUSH
7786: LD_VAR 0 1
7790: PPUSH
7791: LD_INT 3
7793: PPUSH
7794: CALL 6155 0 2
7798: PUSH
7799: LD_INT 1
7801: ARRAY
7802: ST_TO_ADDR
// if fac then
7803: LD_VAR 0 6
7807: IFFALSE 7903
// for i = 1 to tmp do
7809: LD_ADDR_VAR 0 4
7813: PUSH
7814: DOUBLE
7815: LD_INT 1
7817: DEC
7818: ST_TO_ADDR
7819: LD_VAR 0 5
7823: PUSH
7824: FOR_TO
7825: IFFALSE 7901
// if GetBWeapon ( tmp [ i ] ) = 0 then
7827: LD_VAR 0 5
7831: PUSH
7832: LD_VAR 0 4
7836: ARRAY
7837: PPUSH
7838: CALL_OW 269
7842: PUSH
7843: LD_INT 0
7845: EQUAL
7846: IFFALSE 7899
// begin if BuildingStatus ( fac ) = bs_idle then
7848: LD_VAR 0 6
7852: PPUSH
7853: CALL_OW 461
7857: PUSH
7858: LD_INT 2
7860: EQUAL
7861: IFFALSE 7897
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
7863: LD_VAR 0 5
7867: PUSH
7868: LD_VAR 0 4
7872: ARRAY
7873: PPUSH
7874: LD_VAR 0 2
7878: PUSH
7879: LD_INT 1
7881: PPUSH
7882: LD_VAR 0 2
7886: PPUSH
7887: CALL_OW 12
7891: ARRAY
7892: PPUSH
7893: CALL_OW 148
// break ;
7897: GO 7901
// end ;
7899: GO 7824
7901: POP
7902: POP
// end ;
7903: LD_VAR 0 3
7907: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
7908: LD_INT 0
7910: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
7911: LD_INT 22
7913: PUSH
7914: LD_VAR 0 1
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: PUSH
7923: LD_INT 34
7925: PUSH
7926: LD_VAR 0 3
7930: PUSH
7931: EMPTY
7932: LIST
7933: LIST
7934: PUSH
7935: LD_INT 31
7937: PUSH
7938: LD_VAR 0 2
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: LIST
7951: PUSH
7952: EMPTY
7953: LIST
7954: PPUSH
7955: CALL_OW 69
7959: IFFALSE 8017
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
7961: LD_ADDR_VAR 0 4
7965: PUSH
7966: LD_INT 22
7968: PUSH
7969: LD_VAR 0 1
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PUSH
7978: LD_INT 34
7980: PUSH
7981: LD_VAR 0 3
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: PUSH
7990: LD_INT 31
7992: PUSH
7993: LD_VAR 0 2
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: EMPTY
8008: LIST
8009: PPUSH
8010: CALL_OW 69
8014: ST_TO_ADDR
8015: GO 8025
// result := false ;
8017: LD_ADDR_VAR 0 4
8021: PUSH
8022: LD_INT 0
8024: ST_TO_ADDR
// end ;
8025: LD_VAR 0 4
8029: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8030: LD_INT 0
8032: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8033: LD_VAR 0 1
8037: PPUSH
8038: LD_VAR 0 2
8042: PPUSH
8043: LD_VAR 0 3
8047: PPUSH
8048: LD_VAR 0 4
8052: PPUSH
8053: LD_VAR 0 5
8057: PPUSH
8058: CALL_OW 448
8062: PUSH
8063: LD_VAR 0 2
8067: PPUSH
8068: LD_VAR 0 3
8072: PPUSH
8073: LD_VAR 0 4
8077: PPUSH
8078: LD_VAR 0 5
8082: PPUSH
8083: CALL_OW 449
8087: PUSH
8088: LD_INT 1
8090: ARRAY
8091: PUSH
8092: LD_VAR 0 1
8096: PPUSH
8097: CALL 5756 0 1
8101: PUSH
8102: LD_INT 1
8104: ARRAY
8105: LESSEQUAL
8106: AND
8107: PUSH
8108: LD_VAR 0 2
8112: PPUSH
8113: LD_VAR 0 3
8117: PPUSH
8118: LD_VAR 0 4
8122: PPUSH
8123: LD_VAR 0 5
8127: PPUSH
8128: CALL_OW 449
8132: PUSH
8133: LD_INT 2
8135: ARRAY
8136: PUSH
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL 5756 0 1
8146: PUSH
8147: LD_INT 2
8149: ARRAY
8150: LESSEQUAL
8151: AND
8152: PUSH
8153: LD_VAR 0 2
8157: PPUSH
8158: LD_VAR 0 3
8162: PPUSH
8163: LD_VAR 0 4
8167: PPUSH
8168: LD_VAR 0 5
8172: PPUSH
8173: CALL_OW 449
8177: PUSH
8178: LD_INT 3
8180: ARRAY
8181: PUSH
8182: LD_VAR 0 1
8186: PPUSH
8187: CALL 5756 0 1
8191: PUSH
8192: LD_INT 3
8194: ARRAY
8195: LESSEQUAL
8196: AND
8197: IFFALSE 8244
// begin if debug then
8199: LD_EXP 1
8203: IFFALSE 8213
// display_strings := Factory work! ;
8205: LD_ADDR_OWVAR 47
8209: PUSH
8210: LD_STRING Factory work!
8212: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8213: LD_VAR 0 1
8217: PPUSH
8218: LD_VAR 0 2
8222: PPUSH
8223: LD_VAR 0 3
8227: PPUSH
8228: LD_VAR 0 4
8232: PPUSH
8233: LD_VAR 0 5
8237: PPUSH
8238: CALL_OW 125
// end else
8242: GO 8252
// result := false ;
8244: LD_ADDR_VAR 0 6
8248: PUSH
8249: LD_INT 0
8251: ST_TO_ADDR
// end ;
8252: LD_VAR 0 6
8256: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8257: LD_INT 0
8259: PPUSH
8260: PPUSH
8261: PPUSH
8262: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8263: LD_ADDR_VAR 0 6
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_VAR 0 1
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PUSH
8280: LD_INT 30
8282: PUSH
8283: LD_VAR 0 2
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PPUSH
8296: CALL_OW 69
8300: ST_TO_ADDR
// tmp := [ ] ;
8301: LD_ADDR_VAR 0 5
8305: PUSH
8306: EMPTY
8307: ST_TO_ADDR
// for i = 1 to filter do
8308: LD_ADDR_VAR 0 4
8312: PUSH
8313: DOUBLE
8314: LD_INT 1
8316: DEC
8317: ST_TO_ADDR
8318: LD_VAR 0 6
8322: PUSH
8323: FOR_TO
8324: IFFALSE 8412
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8326: LD_ADDR_VAR 0 5
8330: PUSH
8331: LD_VAR 0 5
8335: PUSH
8336: LD_VAR 0 6
8340: PUSH
8341: LD_VAR 0 4
8345: ARRAY
8346: PPUSH
8347: CALL_OW 266
8351: PUSH
8352: LD_VAR 0 6
8356: PUSH
8357: LD_VAR 0 4
8361: ARRAY
8362: PPUSH
8363: CALL_OW 250
8367: PUSH
8368: LD_VAR 0 6
8372: PUSH
8373: LD_VAR 0 4
8377: ARRAY
8378: PPUSH
8379: CALL_OW 251
8383: PUSH
8384: LD_VAR 0 6
8388: PUSH
8389: LD_VAR 0 4
8393: ARRAY
8394: PPUSH
8395: CALL_OW 254
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: LIST
8404: LIST
8405: PUSH
8406: EMPTY
8407: LIST
8408: ADD
8409: ST_TO_ADDR
// end ;
8410: GO 8323
8412: POP
8413: POP
// result := tmp ;
8414: LD_ADDR_VAR 0 3
8418: PUSH
8419: LD_VAR 0 5
8423: ST_TO_ADDR
// end ;
8424: LD_VAR 0 3
8428: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
8429: LD_INT 0
8431: PPUSH
8432: PPUSH
8433: PPUSH
// for i = 1 to list do
8434: LD_ADDR_VAR 0 4
8438: PUSH
8439: DOUBLE
8440: LD_INT 1
8442: DEC
8443: ST_TO_ADDR
8444: LD_VAR 0 2
8448: PUSH
8449: FOR_TO
8450: IFFALSE 9005
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
8452: LD_VAR 0 2
8456: PUSH
8457: LD_VAR 0 4
8461: ARRAY
8462: PUSH
8463: LD_INT 1
8465: ARRAY
8466: PPUSH
8467: LD_VAR 0 2
8471: PUSH
8472: LD_VAR 0 4
8476: ARRAY
8477: PUSH
8478: LD_INT 2
8480: ARRAY
8481: PPUSH
8482: CALL_OW 428
8486: PUSH
8487: LD_INT 0
8489: GREATER
8490: IFFALSE 8776
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
8492: LD_VAR 0 2
8496: PUSH
8497: LD_VAR 0 4
8501: ARRAY
8502: PUSH
8503: LD_INT 1
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_VAR 0 4
8516: ARRAY
8517: PUSH
8518: LD_INT 2
8520: ARRAY
8521: PPUSH
8522: CALL_OW 428
8526: PPUSH
8527: CALL_OW 248
8531: PUSH
8532: LD_INT 3
8534: EQUAL
8535: IFFALSE 8661
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
8537: LD_VAR 0 2
8541: PUSH
8542: LD_VAR 0 4
8546: ARRAY
8547: PUSH
8548: LD_INT 1
8550: ARRAY
8551: PPUSH
8552: LD_VAR 0 2
8556: PUSH
8557: LD_VAR 0 4
8561: ARRAY
8562: PUSH
8563: LD_INT 2
8565: ARRAY
8566: PPUSH
8567: CALL_OW 428
8571: PPUSH
8572: CALL_OW 274
8576: PPUSH
8577: LD_INT 3
8579: PPUSH
8580: CALL_OW 275
8584: PUSH
8585: LD_INT 15
8587: GREATEREQUAL
8588: IFFALSE 8659
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
8590: LD_VAR 0 2
8594: PUSH
8595: LD_VAR 0 4
8599: ARRAY
8600: PUSH
8601: LD_INT 1
8603: ARRAY
8604: PPUSH
8605: LD_VAR 0 2
8609: PUSH
8610: LD_VAR 0 4
8614: ARRAY
8615: PUSH
8616: LD_INT 2
8618: ARRAY
8619: PPUSH
8620: CALL_OW 428
8624: PPUSH
8625: LD_VAR 0 2
8629: PUSH
8630: LD_VAR 0 4
8634: ARRAY
8635: PUSH
8636: LD_INT 4
8638: ARRAY
8639: PPUSH
8640: LD_VAR 0 2
8644: PUSH
8645: LD_VAR 0 4
8649: ARRAY
8650: PUSH
8651: LD_INT 5
8653: ARRAY
8654: PPUSH
8655: CALL 7322 0 3
// end else
8659: GO 8730
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
8661: LD_VAR 0 2
8665: PUSH
8666: LD_VAR 0 4
8670: ARRAY
8671: PUSH
8672: LD_INT 1
8674: ARRAY
8675: PPUSH
8676: LD_VAR 0 2
8680: PUSH
8681: LD_VAR 0 4
8685: ARRAY
8686: PUSH
8687: LD_INT 2
8689: ARRAY
8690: PPUSH
8691: CALL_OW 428
8695: PPUSH
8696: LD_VAR 0 2
8700: PUSH
8701: LD_VAR 0 4
8705: ARRAY
8706: PUSH
8707: LD_INT 4
8709: ARRAY
8710: PPUSH
8711: LD_VAR 0 2
8715: PUSH
8716: LD_VAR 0 4
8720: ARRAY
8721: PUSH
8722: LD_INT 5
8724: ARRAY
8725: PPUSH
8726: CALL 7322 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
8730: LD_VAR 0 1
8734: PPUSH
8735: LD_VAR 0 2
8739: PUSH
8740: LD_VAR 0 4
8744: ARRAY
8745: PUSH
8746: LD_INT 1
8748: ARRAY
8749: PPUSH
8750: LD_VAR 0 2
8754: PUSH
8755: LD_VAR 0 4
8759: ARRAY
8760: PUSH
8761: LD_INT 2
8763: ARRAY
8764: PPUSH
8765: CALL_OW 428
8769: PPUSH
8770: CALL 10378 0 2
// end else
8774: GO 9003
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
8776: LD_VAR 0 1
8780: PUSH
8781: LD_INT 1
8783: ARRAY
8784: PPUSH
8785: CALL_OW 255
8789: PPUSH
8790: CALL 6064 0 1
8794: PPUSH
8795: LD_INT 6
8797: PPUSH
8798: CALL 5640 0 2
8802: PUSH
8803: LD_VAR 0 1
8807: PUSH
8808: LD_INT 1
8810: ARRAY
8811: PPUSH
8812: CALL_OW 255
8816: PPUSH
8817: CALL 6064 0 1
8821: PPUSH
8822: LD_VAR 0 2
8826: PUSH
8827: LD_VAR 0 4
8831: ARRAY
8832: PUSH
8833: LD_INT 4
8835: ARRAY
8836: PPUSH
8837: CALL 5640 0 2
8841: AND
8842: PUSH
8843: LD_VAR 0 1
8847: PUSH
8848: LD_INT 1
8850: ARRAY
8851: PPUSH
8852: CALL_OW 255
8856: PPUSH
8857: CALL 6064 0 1
8861: PPUSH
8862: LD_VAR 0 2
8866: PUSH
8867: LD_VAR 0 4
8871: ARRAY
8872: PUSH
8873: LD_INT 5
8875: ARRAY
8876: PPUSH
8877: CALL 5640 0 2
8881: AND
8882: IFFALSE 9003
// for p = 1 to plist do
8884: LD_ADDR_VAR 0 5
8888: PUSH
8889: DOUBLE
8890: LD_INT 1
8892: DEC
8893: ST_TO_ADDR
8894: LD_VAR 0 1
8898: PUSH
8899: FOR_TO
8900: IFFALSE 9001
// if IsInUnit ( plist [ p ] ) then
8902: LD_VAR 0 1
8906: PUSH
8907: LD_VAR 0 5
8911: ARRAY
8912: PPUSH
8913: CALL_OW 310
8917: IFFALSE 8936
// ComExitBuilding ( plist [ p ] ) else
8919: LD_VAR 0 1
8923: PUSH
8924: LD_VAR 0 5
8928: ARRAY
8929: PPUSH
8930: CALL_OW 122
8934: GO 8999
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
8936: LD_VAR 0 1
8940: PUSH
8941: LD_VAR 0 5
8945: ARRAY
8946: PPUSH
8947: LD_INT 6
8949: PPUSH
8950: LD_VAR 0 2
8954: PUSH
8955: LD_VAR 0 4
8959: ARRAY
8960: PUSH
8961: LD_INT 1
8963: ARRAY
8964: PPUSH
8965: LD_VAR 0 2
8969: PUSH
8970: LD_VAR 0 4
8974: ARRAY
8975: PUSH
8976: LD_INT 2
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 2
8984: PUSH
8985: LD_VAR 0 4
8989: ARRAY
8990: PUSH
8991: LD_INT 3
8993: ARRAY
8994: PPUSH
8995: CALL_OW 145
8999: GO 8899
9001: POP
9002: POP
// end ;
9003: GO 8449
9005: POP
9006: POP
// end ;
9007: LD_VAR 0 3
9011: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9012: LD_INT 0
9014: PPUSH
// if IsInUnit ( sci ) then
9015: LD_VAR 0 1
9019: PPUSH
9020: CALL_OW 310
9024: IFFALSE 9037
// ComExitBuilding ( sci ) else
9026: LD_VAR 0 1
9030: PPUSH
9031: CALL_OW 122
9035: GO 9068
// if not HasTask ( sci ) then
9037: LD_VAR 0 1
9041: PPUSH
9042: CALL_OW 314
9046: NOT
9047: IFFALSE 9068
// begin ComMoveXY ( sci , x , y ) ;
9049: LD_VAR 0 1
9053: PPUSH
9054: LD_VAR 0 2
9058: PPUSH
9059: LD_VAR 0 3
9063: PPUSH
9064: CALL_OW 111
// end ; end ;
9068: LD_VAR 0 4
9072: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9073: LD_INT 0
9075: PPUSH
9076: PPUSH
9077: PPUSH
9078: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9079: LD_ADDR_VAR 0 6
9083: PUSH
9084: LD_INT 22
9086: PUSH
9087: LD_VAR 0 1
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 21
9098: PUSH
9099: LD_INT 1
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: PUSH
9106: EMPTY
9107: LIST
9108: LIST
9109: PPUSH
9110: CALL_OW 69
9114: PUSH
9115: LD_VAR 0 3
9119: DIFF
9120: ST_TO_ADDR
// tmp := tag_list ;
9121: LD_ADDR_VAR 0 7
9125: PUSH
9126: LD_VAR 0 2
9130: ST_TO_ADDR
// for i = 1 to filter do
9131: LD_ADDR_VAR 0 5
9135: PUSH
9136: DOUBLE
9137: LD_INT 1
9139: DEC
9140: ST_TO_ADDR
9141: LD_VAR 0 6
9145: PUSH
9146: FOR_TO
9147: IFFALSE 9416
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9149: LD_VAR 0 6
9153: PUSH
9154: LD_VAR 0 5
9158: ARRAY
9159: PPUSH
9160: CALL_OW 256
9164: PUSH
9165: LD_INT 1000
9167: EQUAL
9168: PUSH
9169: LD_VAR 0 6
9173: PUSH
9174: LD_VAR 0 5
9178: ARRAY
9179: PPUSH
9180: CALL_OW 110
9184: PUSH
9185: LD_INT 100
9187: GREATEREQUAL
9188: AND
9189: IFFALSE 9231
// begin SetTag ( filter [ i ] , 0 ) ;
9191: LD_VAR 0 6
9195: PUSH
9196: LD_VAR 0 5
9200: ARRAY
9201: PPUSH
9202: LD_INT 0
9204: PPUSH
9205: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9209: LD_ADDR_VAR 0 7
9213: PUSH
9214: LD_VAR 0 7
9218: PUSH
9219: LD_VAR 0 6
9223: PUSH
9224: LD_VAR 0 5
9228: ARRAY
9229: DIFF
9230: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9231: LD_VAR 0 6
9235: PUSH
9236: LD_VAR 0 5
9240: ARRAY
9241: PPUSH
9242: CALL_OW 256
9246: PUSH
9247: LD_INT 1000
9249: LESS
9250: IFFALSE 9414
// begin if not filter [ i ] in tmp then
9252: LD_VAR 0 6
9256: PUSH
9257: LD_VAR 0 5
9261: ARRAY
9262: PUSH
9263: LD_VAR 0 7
9267: IN
9268: NOT
9269: IFFALSE 9293
// tmp := tmp ^ filter [ i ] ;
9271: LD_ADDR_VAR 0 7
9275: PUSH
9276: LD_VAR 0 7
9280: PUSH
9281: LD_VAR 0 6
9285: PUSH
9286: LD_VAR 0 5
9290: ARRAY
9291: ADD
9292: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9293: LD_VAR 0 6
9297: PUSH
9298: LD_VAR 0 5
9302: ARRAY
9303: PPUSH
9304: CALL_OW 256
9308: PUSH
9309: LD_INT 250
9311: LESS
9312: IFFALSE 9334
// SetTag ( filter [ i ] , 100 ) else
9314: LD_VAR 0 6
9318: PUSH
9319: LD_VAR 0 5
9323: ARRAY
9324: PPUSH
9325: LD_INT 100
9327: PPUSH
9328: CALL_OW 109
9332: GO 9414
// if GetLives ( filter [ i ] ) < 500 then
9334: LD_VAR 0 6
9338: PUSH
9339: LD_VAR 0 5
9343: ARRAY
9344: PPUSH
9345: CALL_OW 256
9349: PUSH
9350: LD_INT 500
9352: LESS
9353: IFFALSE 9375
// SetTag ( filter [ i ] , 101 ) else
9355: LD_VAR 0 6
9359: PUSH
9360: LD_VAR 0 5
9364: ARRAY
9365: PPUSH
9366: LD_INT 101
9368: PPUSH
9369: CALL_OW 109
9373: GO 9414
// if GetLives ( filter [ i ] ) < 1000 then
9375: LD_VAR 0 6
9379: PUSH
9380: LD_VAR 0 5
9384: ARRAY
9385: PPUSH
9386: CALL_OW 256
9390: PUSH
9391: LD_INT 1000
9393: LESS
9394: IFFALSE 9414
// SetTag ( filter [ i ] , 102 ) ;
9396: LD_VAR 0 6
9400: PUSH
9401: LD_VAR 0 5
9405: ARRAY
9406: PPUSH
9407: LD_INT 102
9409: PPUSH
9410: CALL_OW 109
// end ; end ;
9414: GO 9146
9416: POP
9417: POP
// result := tmp ;
9418: LD_ADDR_VAR 0 4
9422: PUSH
9423: LD_VAR 0 7
9427: ST_TO_ADDR
// end ;
9428: LD_VAR 0 4
9432: RET
// export function WantHeal ( sci , tag ) ; begin
9433: LD_INT 0
9435: PPUSH
// if GetTaskList ( sci ) > 0 then
9436: LD_VAR 0 1
9440: PPUSH
9441: CALL_OW 437
9445: PUSH
9446: LD_INT 0
9448: GREATER
9449: IFFALSE 9524
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
9451: LD_VAR 0 1
9455: PPUSH
9456: CALL_OW 437
9460: PUSH
9461: LD_INT 1
9463: ARRAY
9464: PUSH
9465: LD_INT 1
9467: ARRAY
9468: PUSH
9469: LD_STRING l
9471: EQUAL
9472: PUSH
9473: LD_VAR 0 1
9477: PPUSH
9478: CALL_OW 437
9482: PUSH
9483: LD_INT 1
9485: ARRAY
9486: PUSH
9487: LD_INT 4
9489: ARRAY
9490: PPUSH
9491: CALL_OW 110
9495: PUSH
9496: LD_VAR 0 2
9500: EQUAL
9501: AND
9502: IFFALSE 9514
// result := true else
9504: LD_ADDR_VAR 0 3
9508: PUSH
9509: LD_INT 1
9511: ST_TO_ADDR
9512: GO 9522
// result := false ;
9514: LD_ADDR_VAR 0 3
9518: PUSH
9519: LD_INT 0
9521: ST_TO_ADDR
// end else
9522: GO 9532
// result := false ;
9524: LD_ADDR_VAR 0 3
9528: PUSH
9529: LD_INT 0
9531: ST_TO_ADDR
// end ;
9532: LD_VAR 0 3
9536: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
9537: LD_INT 0
9539: PPUSH
9540: PPUSH
9541: PPUSH
9542: PPUSH
9543: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9544: LD_ADDR_VAR 0 7
9548: PUSH
9549: LD_INT 22
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 21
9566: PUSH
9567: LD_INT 3
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PPUSH
9582: CALL_OW 69
9586: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
9587: LD_ADDR_VAR 0 5
9591: PUSH
9592: LD_INT 1
9594: PPUSH
9595: LD_INT 3
9597: PPUSH
9598: CALL_OW 12
9602: ST_TO_ADDR
// if filter > 0 then
9603: LD_VAR 0 7
9607: PUSH
9608: LD_INT 0
9610: GREATER
9611: IFFALSE 9813
// for i = 1 to list do
9613: LD_ADDR_VAR 0 6
9617: PUSH
9618: DOUBLE
9619: LD_INT 1
9621: DEC
9622: ST_TO_ADDR
9623: LD_VAR 0 1
9627: PUSH
9628: FOR_TO
9629: IFFALSE 9811
// for ta in filter do
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_VAR 0 7
9640: PUSH
9641: FOR_IN
9642: IFFALSE 9807
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
9644: LD_VAR 0 1
9648: PUSH
9649: LD_VAR 0 6
9653: ARRAY
9654: PPUSH
9655: LD_VAR 0 4
9659: PPUSH
9660: CALL_OW 296
9664: PUSH
9665: LD_INT 13
9667: LESSEQUAL
9668: IFFALSE 9805
// begin case c of 1 :
9670: LD_VAR 0 5
9674: PUSH
9675: LD_INT 1
9677: DOUBLE
9678: EQUAL
9679: IFTRUE 9683
9681: GO 9721
9683: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
9684: LD_VAR 0 1
9688: PUSH
9689: LD_VAR 0 6
9693: ARRAY
9694: PPUSH
9695: LD_VAR 0 4
9699: PPUSH
9700: CALL_OW 250
9704: PPUSH
9705: LD_VAR 0 4
9709: PPUSH
9710: CALL_OW 251
9714: PPUSH
9715: CALL_OW 154
9719: GO 9805
9721: LD_INT 2
9723: DOUBLE
9724: EQUAL
9725: IFTRUE 9729
9727: GO 9793
9729: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
9730: LD_VAR 0 1
9734: PUSH
9735: LD_VAR 0 6
9739: ARRAY
9740: PPUSH
9741: LD_VAR 0 4
9745: PPUSH
9746: CALL_OW 250
9750: PUSH
9751: LD_INT 1
9753: NEG
9754: PPUSH
9755: LD_INT 1
9757: PPUSH
9758: CALL_OW 12
9762: PLUS
9763: PPUSH
9764: LD_VAR 0 4
9768: PPUSH
9769: CALL_OW 251
9773: PUSH
9774: LD_INT 1
9776: NEG
9777: PPUSH
9778: LD_INT 1
9780: PPUSH
9781: CALL_OW 12
9785: PLUS
9786: PPUSH
9787: CALL_OW 153
9791: GO 9805
9793: LD_INT 3
9795: DOUBLE
9796: EQUAL
9797: IFTRUE 9801
9799: GO 9804
9801: POP
// ; end ;
9802: GO 9805
9804: POP
// end ; end ;
9805: GO 9641
9807: POP
9808: POP
9809: GO 9628
9811: POP
9812: POP
// end ;
9813: LD_VAR 0 3
9817: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
9818: LD_INT 0
9820: PPUSH
9821: PPUSH
// for i = 1 to plist do
9822: LD_ADDR_VAR 0 3
9826: PUSH
9827: DOUBLE
9828: LD_INT 1
9830: DEC
9831: ST_TO_ADDR
9832: LD_VAR 0 1
9836: PUSH
9837: FOR_TO
9838: IFFALSE 10040
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
9840: LD_VAR 0 1
9844: PUSH
9845: LD_VAR 0 3
9849: ARRAY
9850: PPUSH
9851: CALL_OW 310
9855: PUSH
9856: LD_INT 30
9858: PUSH
9859: LD_INT 5
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: PUSH
9866: EMPTY
9867: LIST
9868: PPUSH
9869: CALL_OW 69
9873: IN
9874: NOT
9875: IFFALSE 10020
// begin if IsInUnit ( plist [ i ] ) then
9877: LD_VAR 0 1
9881: PUSH
9882: LD_VAR 0 3
9886: ARRAY
9887: PPUSH
9888: CALL_OW 310
9892: IFFALSE 9911
// ComExitBuilding ( plist [ i ] ) else
9894: LD_VAR 0 1
9898: PUSH
9899: LD_VAR 0 3
9903: ARRAY
9904: PPUSH
9905: CALL_OW 122
9909: GO 10018
// if not HasTask ( plist [ i ] ) then
9911: LD_VAR 0 1
9915: PUSH
9916: LD_VAR 0 3
9920: ARRAY
9921: PPUSH
9922: CALL_OW 314
9926: NOT
9927: IFFALSE 10018
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
9929: LD_VAR 0 1
9933: PUSH
9934: LD_VAR 0 3
9938: ARRAY
9939: PPUSH
9940: LD_INT 22
9942: PUSH
9943: LD_VAR 0 1
9947: PUSH
9948: LD_INT 1
9950: ARRAY
9951: PPUSH
9952: CALL_OW 255
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: PUSH
9961: LD_INT 30
9963: PUSH
9964: LD_INT 5
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: PPUSH
9975: CALL_OW 69
9979: PPUSH
9980: LD_VAR 0 1
9984: PUSH
9985: LD_VAR 0 3
9989: ARRAY
9990: PPUSH
9991: CALL_OW 74
9995: PPUSH
9996: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10000: LD_VAR 0 1
10004: PUSH
10005: LD_VAR 0 3
10009: ARRAY
10010: PPUSH
10011: LD_INT 9
10013: PPUSH
10014: CALL_OW 183
// end ; end else
10018: GO 10038
// ComChangeProfession ( plist [ i ] , 9 ) ;
10020: LD_VAR 0 1
10024: PUSH
10025: LD_VAR 0 3
10029: ARRAY
10030: PPUSH
10031: LD_INT 9
10033: PPUSH
10034: CALL_OW 123
10038: GO 9837
10040: POP
10041: POP
// end ;
10042: LD_VAR 0 2
10046: RET
// export function GetHuman ( side ) ; begin
10047: LD_INT 0
10049: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10050: LD_ADDR_VAR 0 2
10054: PUSH
10055: LD_INT 22
10057: PUSH
10058: LD_VAR 0 1
10062: PUSH
10063: EMPTY
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 21
10069: PUSH
10070: LD_INT 1
10072: PUSH
10073: EMPTY
10074: LIST
10075: LIST
10076: PUSH
10077: LD_INT 2
10079: PUSH
10080: LD_INT 25
10082: PUSH
10083: LD_INT 1
10085: PUSH
10086: EMPTY
10087: LIST
10088: LIST
10089: PUSH
10090: LD_INT 25
10092: PUSH
10093: LD_INT 2
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: PUSH
10100: LD_INT 25
10102: PUSH
10103: LD_INT 3
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: PUSH
10110: LD_INT 25
10112: PUSH
10113: LD_INT 4
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: LIST
10131: PPUSH
10132: CALL_OW 69
10136: ST_TO_ADDR
// end ;
10137: LD_VAR 0 2
10141: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10142: LD_INT 0
10144: PPUSH
10145: PPUSH
10146: PPUSH
// uc_side := 0 ;
10147: LD_ADDR_OWVAR 20
10151: PUSH
10152: LD_INT 0
10154: ST_TO_ADDR
// uc_nation := 0 ;
10155: LD_ADDR_OWVAR 21
10159: PUSH
10160: LD_INT 0
10162: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10163: LD_ADDR_VAR 0 4
10167: PUSH
10168: DOUBLE
10169: LD_INT 1
10171: DEC
10172: ST_TO_ADDR
10173: LD_INT 4
10175: PUSH
10176: LD_INT 5
10178: PUSH
10179: LD_INT 6
10181: PUSH
10182: EMPTY
10183: LIST
10184: LIST
10185: LIST
10186: PUSH
10187: LD_OWVAR 67
10191: ARRAY
10192: PUSH
10193: FOR_TO
10194: IFFALSE 10265
// begin hc_class = class_tiger ;
10196: LD_ADDR_OWVAR 28
10200: PUSH
10201: LD_INT 14
10203: ST_TO_ADDR
// hc_gallery = sandnature ;
10204: LD_ADDR_OWVAR 33
10208: PUSH
10209: LD_STRING sandnature
10211: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10212: LD_ADDR_OWVAR 35
10216: PUSH
10217: LD_INT 0
10219: PPUSH
10220: LD_INT 50
10222: PPUSH
10223: CALL_OW 12
10227: ST_TO_ADDR
// hc_face_number = 3 ;
10228: LD_ADDR_OWVAR 34
10232: PUSH
10233: LD_INT 3
10235: ST_TO_ADDR
// tiger := CreateHuman ;
10236: LD_ADDR_VAR 0 3
10240: PUSH
10241: CALL_OW 44
10245: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10246: LD_VAR 0 3
10250: PPUSH
10251: LD_VAR 0 1
10255: PPUSH
10256: LD_INT 0
10258: PPUSH
10259: CALL_OW 49
// end ;
10263: GO 10193
10265: POP
10266: POP
// end ;
10267: LD_VAR 0 2
10271: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10272: LD_INT 0
10274: PPUSH
10275: PPUSH
10276: PPUSH
// uc_side := 0 ;
10277: LD_ADDR_OWVAR 20
10281: PUSH
10282: LD_INT 0
10284: ST_TO_ADDR
// uc_nation := 0 ;
10285: LD_ADDR_OWVAR 21
10289: PUSH
10290: LD_INT 0
10292: ST_TO_ADDR
// for i = 1 to 8 do
10293: LD_ADDR_VAR 0 4
10297: PUSH
10298: DOUBLE
10299: LD_INT 1
10301: DEC
10302: ST_TO_ADDR
10303: LD_INT 8
10305: PUSH
10306: FOR_TO
10307: IFFALSE 10371
// begin hc_class = class_apeman ;
10309: LD_ADDR_OWVAR 28
10313: PUSH
10314: LD_INT 12
10316: ST_TO_ADDR
// hc_gallery =  ;
10317: LD_ADDR_OWVAR 33
10321: PUSH
10322: LD_STRING 
10324: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10325: LD_ADDR_OWVAR 35
10329: PUSH
10330: LD_INT 5
10332: NEG
10333: PPUSH
10334: LD_INT 20
10336: PPUSH
10337: CALL_OW 12
10341: ST_TO_ADDR
// ape := CreateHuman ;
10342: LD_ADDR_VAR 0 3
10346: PUSH
10347: CALL_OW 44
10351: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10352: LD_VAR 0 3
10356: PPUSH
10357: LD_VAR 0 1
10361: PPUSH
10362: LD_INT 0
10364: PPUSH
10365: CALL_OW 49
// end ;
10369: GO 10306
10371: POP
10372: POP
// end ;
10373: LD_VAR 0 2
10377: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
10378: LD_INT 0
10380: PPUSH
10381: PPUSH
// if BuildingStatus ( b ) = bs_build then
10382: LD_VAR 0 2
10386: PPUSH
10387: CALL_OW 461
10391: PUSH
10392: LD_INT 1
10394: EQUAL
10395: IFFALSE 10581
// for i = 1 to plist do
10397: LD_ADDR_VAR 0 4
10401: PUSH
10402: DOUBLE
10403: LD_INT 1
10405: DEC
10406: ST_TO_ADDR
10407: LD_VAR 0 1
10411: PUSH
10412: FOR_TO
10413: IFFALSE 10579
// if IsInUnit ( plist [ i ] ) then
10415: LD_VAR 0 1
10419: PUSH
10420: LD_VAR 0 4
10424: ARRAY
10425: PPUSH
10426: CALL_OW 310
10430: IFFALSE 10513
// begin ComExitBuilding ( plist [ i ] ) ;
10432: LD_VAR 0 1
10436: PUSH
10437: LD_VAR 0 4
10441: ARRAY
10442: PPUSH
10443: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
10447: LD_VAR 0 1
10451: PUSH
10452: LD_VAR 0 4
10456: ARRAY
10457: PPUSH
10458: LD_STRING h
10460: PUSH
10461: LD_VAR 0 2
10465: PPUSH
10466: CALL_OW 250
10470: PUSH
10471: LD_VAR 0 2
10475: PPUSH
10476: CALL_OW 251
10480: PUSH
10481: LD_VAR 0 2
10485: PUSH
10486: LD_INT 0
10488: PUSH
10489: LD_INT 0
10491: PUSH
10492: LD_INT 0
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: EMPTY
10505: LIST
10506: PPUSH
10507: CALL_OW 447
// end else
10511: GO 10577
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
10513: LD_VAR 0 1
10517: PUSH
10518: LD_VAR 0 4
10522: ARRAY
10523: PPUSH
10524: LD_STRING h
10526: PUSH
10527: LD_VAR 0 2
10531: PPUSH
10532: CALL_OW 250
10536: PUSH
10537: LD_VAR 0 2
10541: PPUSH
10542: CALL_OW 251
10546: PUSH
10547: LD_VAR 0 2
10551: PUSH
10552: LD_INT 0
10554: PUSH
10555: LD_INT 0
10557: PUSH
10558: LD_INT 0
10560: PUSH
10561: EMPTY
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: PUSH
10570: EMPTY
10571: LIST
10572: PPUSH
10573: CALL_OW 446
10577: GO 10412
10579: POP
10580: POP
// end ;
10581: LD_VAR 0 3
10585: RET
// export function WantRepair ( eng ) ; begin
10586: LD_INT 0
10588: PPUSH
// if GetTaskList ( eng ) > 0 then
10589: LD_VAR 0 1
10593: PPUSH
10594: CALL_OW 437
10598: PUSH
10599: LD_INT 0
10601: GREATER
10602: IFFALSE 10647
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
10604: LD_VAR 0 1
10608: PPUSH
10609: CALL_OW 437
10613: PUSH
10614: LD_INT 1
10616: ARRAY
10617: PUSH
10618: LD_INT 1
10620: ARRAY
10621: PUSH
10622: LD_STRING o
10624: EQUAL
10625: IFFALSE 10637
// result := true else
10627: LD_ADDR_VAR 0 2
10631: PUSH
10632: LD_INT 1
10634: ST_TO_ADDR
10635: GO 10645
// result := false ;
10637: LD_ADDR_VAR 0 2
10641: PUSH
10642: LD_INT 0
10644: ST_TO_ADDR
// end else
10645: GO 10655
// result := false ;
10647: LD_ADDR_VAR 0 2
10651: PUSH
10652: LD_INT 0
10654: ST_TO_ADDR
// end ;
10655: LD_VAR 0 2
10659: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
10660: LD_INT 0
10662: PPUSH
10663: PPUSH
10664: PPUSH
10665: PPUSH
// if btype = - 1 then
10666: LD_VAR 0 2
10670: PUSH
10671: LD_INT 1
10673: NEG
10674: EQUAL
10675: IFFALSE 10715
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
10677: LD_ADDR_VAR 0 5
10681: PUSH
10682: LD_INT 22
10684: PUSH
10685: LD_VAR 0 1
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 21
10696: PUSH
10697: LD_INT 3
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: PPUSH
10708: CALL_OW 69
10712: ST_TO_ADDR
10713: GO 10753
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
10715: LD_ADDR_VAR 0 5
10719: PUSH
10720: LD_INT 22
10722: PUSH
10723: LD_VAR 0 1
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 30
10734: PUSH
10735: LD_VAR 0 2
10739: PUSH
10740: EMPTY
10741: LIST
10742: LIST
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: PPUSH
10748: CALL_OW 69
10752: ST_TO_ADDR
// list := [ ] ;
10753: LD_ADDR_VAR 0 6
10757: PUSH
10758: EMPTY
10759: ST_TO_ADDR
// for i = 1 to tmp do
10760: LD_ADDR_VAR 0 4
10764: PUSH
10765: DOUBLE
10766: LD_INT 1
10768: DEC
10769: ST_TO_ADDR
10770: LD_VAR 0 5
10774: PUSH
10775: FOR_TO
10776: IFFALSE 10864
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
10778: LD_ADDR_VAR 0 6
10782: PUSH
10783: LD_VAR 0 6
10787: PUSH
10788: LD_VAR 0 5
10792: PUSH
10793: LD_VAR 0 4
10797: ARRAY
10798: PPUSH
10799: CALL_OW 266
10803: PUSH
10804: LD_VAR 0 5
10808: PUSH
10809: LD_VAR 0 4
10813: ARRAY
10814: PPUSH
10815: CALL_OW 250
10819: PUSH
10820: LD_VAR 0 5
10824: PUSH
10825: LD_VAR 0 4
10829: ARRAY
10830: PPUSH
10831: CALL_OW 251
10835: PUSH
10836: LD_VAR 0 5
10840: PUSH
10841: LD_VAR 0 4
10845: ARRAY
10846: PPUSH
10847: CALL_OW 254
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: LIST
10856: LIST
10857: PUSH
10858: EMPTY
10859: LIST
10860: ADD
10861: ST_TO_ADDR
10862: GO 10775
10864: POP
10865: POP
// result = list ;
10866: LD_ADDR_VAR 0 3
10870: PUSH
10871: LD_VAR 0 6
10875: ST_TO_ADDR
// end ;
10876: LD_VAR 0 3
10880: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
10881: LD_INT 0
10883: PPUSH
10884: PPUSH
10885: PPUSH
10886: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
10887: LD_VAR 0 1
10891: PPUSH
10892: LD_INT 81
10894: PUSH
10895: LD_VAR 0 1
10899: PPUSH
10900: CALL_OW 255
10904: PUSH
10905: EMPTY
10906: LIST
10907: LIST
10908: PPUSH
10909: CALL_OW 69
10913: PPUSH
10914: LD_VAR 0 1
10918: PPUSH
10919: CALL_OW 74
10923: PPUSH
10924: CALL_OW 296
10928: PUSH
10929: LD_INT 18
10931: LESS
10932: IFFALSE 10977
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
10934: LD_VAR 0 1
10938: PPUSH
10939: LD_INT 81
10941: PUSH
10942: LD_VAR 0 1
10946: PPUSH
10947: CALL_OW 255
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PPUSH
10961: LD_VAR 0 1
10965: PPUSH
10966: CALL_OW 74
10970: PPUSH
10971: CALL_OW 115
10975: GO 10996
// ComMoveXY ( behemoth , x , y ) ;
10977: LD_VAR 0 1
10981: PPUSH
10982: LD_VAR 0 4
10986: PPUSH
10987: LD_VAR 0 5
10991: PPUSH
10992: CALL_OW 111
// if time_lapsers_list > 0 then
10996: LD_VAR 0 2
11000: PUSH
11001: LD_INT 0
11003: GREATER
11004: IFFALSE 11194
// begin for i = 1 to time_lapsers_list do
11006: LD_ADDR_VAR 0 7
11010: PUSH
11011: DOUBLE
11012: LD_INT 1
11014: DEC
11015: ST_TO_ADDR
11016: LD_VAR 0 2
11020: PUSH
11021: FOR_TO
11022: IFFALSE 11192
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11024: LD_VAR 0 2
11028: PUSH
11029: LD_VAR 0 7
11033: ARRAY
11034: PPUSH
11035: CALL_OW 256
11039: PUSH
11040: LD_INT 250
11042: GREATEREQUAL
11043: PUSH
11044: LD_VAR 0 2
11048: PUSH
11049: LD_VAR 0 7
11053: ARRAY
11054: PPUSH
11055: LD_VAR 0 1
11059: PPUSH
11060: CALL_OW 296
11064: PUSH
11065: LD_INT 9
11067: GREATER
11068: AND
11069: IFFALSE 11106
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11071: LD_VAR 0 2
11075: PUSH
11076: LD_VAR 0 7
11080: ARRAY
11081: PPUSH
11082: LD_VAR 0 1
11086: PPUSH
11087: CALL_OW 250
11091: PPUSH
11092: LD_VAR 0 1
11096: PPUSH
11097: CALL_OW 251
11101: PPUSH
11102: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11106: LD_VAR 0 2
11110: PUSH
11111: LD_VAR 0 7
11115: ARRAY
11116: PPUSH
11117: CALL_OW 256
11121: PUSH
11122: LD_INT 500
11124: LESS
11125: PUSH
11126: LD_VAR 0 1
11130: PPUSH
11131: CALL_OW 256
11135: PUSH
11136: LD_INT 700
11138: GREATER
11139: AND
11140: IFFALSE 11190
// for p = 1 to mechanic_list do
11142: LD_ADDR_VAR 0 8
11146: PUSH
11147: DOUBLE
11148: LD_INT 1
11150: DEC
11151: ST_TO_ADDR
11152: LD_VAR 0 3
11156: PUSH
11157: FOR_TO
11158: IFFALSE 11188
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11160: LD_VAR 0 3
11164: PUSH
11165: LD_VAR 0 8
11169: ARRAY
11170: PPUSH
11171: LD_VAR 0 2
11175: PUSH
11176: LD_VAR 0 7
11180: ARRAY
11181: PPUSH
11182: CALL_OW 129
11186: GO 11157
11188: POP
11189: POP
// end ;
11190: GO 11021
11192: POP
11193: POP
// end ; if mechanic_list then
11194: LD_VAR 0 3
11198: IFFALSE 11379
// begin for i = 1 to mechanic_list do
11200: LD_ADDR_VAR 0 7
11204: PUSH
11205: DOUBLE
11206: LD_INT 1
11208: DEC
11209: ST_TO_ADDR
11210: LD_VAR 0 3
11214: PUSH
11215: FOR_TO
11216: IFFALSE 11377
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11218: LD_VAR 0 3
11222: PUSH
11223: LD_VAR 0 7
11227: ARRAY
11228: PPUSH
11229: CALL_OW 256
11233: PUSH
11234: LD_INT 333
11236: LESS
11237: IFFALSE 11261
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11239: LD_ADDR_EXP 14
11243: PUSH
11244: LD_EXP 14
11248: PUSH
11249: LD_VAR 0 3
11253: PUSH
11254: LD_VAR 0 7
11258: ARRAY
11259: DIFF
11260: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11261: LD_VAR 0 3
11265: PUSH
11266: LD_VAR 0 7
11270: ARRAY
11271: PPUSH
11272: LD_VAR 0 1
11276: PPUSH
11277: CALL_OW 296
11281: PUSH
11282: LD_INT 9
11284: GREATER
11285: PUSH
11286: LD_VAR 0 3
11290: PUSH
11291: LD_VAR 0 7
11295: ARRAY
11296: PPUSH
11297: CALL_OW 314
11301: NOT
11302: AND
11303: IFFALSE 11340
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11305: LD_VAR 0 3
11309: PUSH
11310: LD_VAR 0 7
11314: ARRAY
11315: PPUSH
11316: LD_VAR 0 1
11320: PPUSH
11321: CALL_OW 250
11325: PPUSH
11326: LD_VAR 0 1
11330: PPUSH
11331: CALL_OW 251
11335: PPUSH
11336: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11340: LD_VAR 0 1
11344: PPUSH
11345: CALL_OW 256
11349: PUSH
11350: LD_INT 700
11352: LESS
11353: IFFALSE 11375
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11355: LD_VAR 0 3
11359: PUSH
11360: LD_VAR 0 7
11364: ARRAY
11365: PPUSH
11366: LD_VAR 0 1
11370: PPUSH
11371: CALL_OW 129
// end ;
11375: GO 11215
11377: POP
11378: POP
// end ; end ;
11379: LD_VAR 0 6
11383: RET
// export function GetBehemoth ( side ) ; begin
11384: LD_INT 0
11386: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
11387: LD_ADDR_VAR 0 2
11391: PUSH
11392: LD_INT 22
11394: PUSH
11395: LD_VAR 0 1
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: PUSH
11404: LD_INT 31
11406: PUSH
11407: LD_INT 25
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: EMPTY
11415: LIST
11416: LIST
11417: PPUSH
11418: CALL_OW 69
11422: ST_TO_ADDR
// end ;
11423: LD_VAR 0 2
11427: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
11428: LD_INT 0
11430: PPUSH
11431: PPUSH
11432: PPUSH
11433: PPUSH
11434: PPUSH
11435: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
11436: LD_ADDR_VAR 0 6
11440: PUSH
11441: LD_VAR 0 2
11445: PPUSH
11446: CALL_OW 435
11450: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
11451: LD_ADDR_VAR 0 5
11455: PUSH
11456: LD_INT 22
11458: PUSH
11459: LD_VAR 0 1
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: LD_INT 2
11470: PUSH
11471: LD_INT 25
11473: PUSH
11474: LD_INT 2
11476: PUSH
11477: EMPTY
11478: LIST
11479: LIST
11480: PUSH
11481: LD_INT 25
11483: PUSH
11484: LD_INT 16
11486: PUSH
11487: EMPTY
11488: LIST
11489: LIST
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: LIST
11495: PUSH
11496: EMPTY
11497: LIST
11498: LIST
11499: PPUSH
11500: CALL_OW 69
11504: ST_TO_ADDR
// if skr then
11505: LD_VAR 0 6
11509: IFFALSE 11674
// begin if engs then
11511: LD_VAR 0 5
11515: IFFALSE 11674
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
11517: LD_ADDR_VAR 0 8
11521: PUSH
11522: LD_VAR 0 6
11526: PUSH
11527: LD_INT 1
11529: ARRAY
11530: PPUSH
11531: LD_VAR 0 6
11535: PUSH
11536: LD_INT 2
11538: ARRAY
11539: PPUSH
11540: CALL_OW 284
11544: ST_TO_ADDR
// if am > engs then
11545: LD_VAR 0 8
11549: PUSH
11550: LD_VAR 0 5
11554: GREATER
11555: IFFALSE 11567
// am := engs ;
11557: LD_ADDR_VAR 0 8
11561: PUSH
11562: LD_VAR 0 5
11566: ST_TO_ADDR
// for i = 1 to am do
11567: LD_ADDR_VAR 0 7
11571: PUSH
11572: DOUBLE
11573: LD_INT 1
11575: DEC
11576: ST_TO_ADDR
11577: LD_VAR 0 8
11581: PUSH
11582: FOR_TO
11583: IFFALSE 11672
// begin if IsInUnit ( engs [ i ] ) then
11585: LD_VAR 0 5
11589: PUSH
11590: LD_VAR 0 7
11594: ARRAY
11595: PPUSH
11596: CALL_OW 310
11600: IFFALSE 11619
// ComExitBuilding ( engs [ i ] ) else
11602: LD_VAR 0 5
11606: PUSH
11607: LD_VAR 0 7
11611: ARRAY
11612: PPUSH
11613: CALL_OW 122
11617: GO 11670
// if not HasTask ( engs [ i ] ) then
11619: LD_VAR 0 5
11623: PUSH
11624: LD_VAR 0 7
11628: ARRAY
11629: PPUSH
11630: CALL_OW 314
11634: NOT
11635: IFFALSE 11670
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
11637: LD_VAR 0 5
11641: PUSH
11642: LD_VAR 0 7
11646: ARRAY
11647: PPUSH
11648: LD_VAR 0 6
11652: PUSH
11653: LD_INT 1
11655: ARRAY
11656: PPUSH
11657: LD_VAR 0 6
11661: PUSH
11662: LD_INT 2
11664: ARRAY
11665: PPUSH
11666: CALL_OW 117
// end ;
11670: GO 11582
11672: POP
11673: POP
// end ; end ; end ; end_of_file
11674: LD_VAR 0 3
11678: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
11679: LD_INT 0
11681: PPUSH
11682: PPUSH
// uc_side := 1 ;
11683: LD_ADDR_OWVAR 20
11687: PUSH
11688: LD_INT 1
11690: ST_TO_ADDR
// uc_nation := 1 ;
11691: LD_ADDR_OWVAR 21
11695: PUSH
11696: LD_INT 1
11698: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
11699: LD_ADDR_VAR 0 2
11703: PUSH
11704: LD_INT 6
11706: PUSH
11707: LD_INT 5
11709: PUSH
11710: LD_INT 4
11712: PUSH
11713: EMPTY
11714: LIST
11715: LIST
11716: LIST
11717: PUSH
11718: LD_OWVAR 67
11722: ARRAY
11723: ST_TO_ADDR
// game_status := false ;
11724: LD_ADDR_EXP 28
11728: PUSH
11729: LD_INT 0
11731: ST_TO_ADDR
// helps_arrive := false ;
11732: LD_ADDR_EXP 29
11736: PUSH
11737: LD_INT 0
11739: ST_TO_ADDR
// helps_can_arrive := false ;
11740: LD_ADDR_EXP 30
11744: PUSH
11745: LD_INT 0
11747: ST_TO_ADDR
// beta_come := false ;
11748: LD_ADDR_EXP 31
11752: PUSH
11753: LD_INT 0
11755: ST_TO_ADDR
// gamma_come := false ;
11756: LD_ADDR_EXP 32
11760: PUSH
11761: LD_INT 0
11763: ST_TO_ADDR
// zeta_come := false ;
11764: LD_ADDR_EXP 33
11768: PUSH
11769: LD_INT 0
11771: ST_TO_ADDR
// mine_ck := false ;
11772: LD_ADDR_EXP 34
11776: PUSH
11777: LD_INT 0
11779: ST_TO_ADDR
// sib_bomb_constructed := false ;
11780: LD_ADDR_EXP 35
11784: PUSH
11785: LD_INT 0
11787: ST_TO_ADDR
// mine_constructed := false ;
11788: LD_ADDR_EXP 36
11792: PUSH
11793: LD_INT 0
11795: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
11796: LD_INT 35
11798: PPUSH
11799: CALL_OW 274
11803: PPUSH
11804: LD_INT 1
11806: PPUSH
11807: LD_INT 200
11809: PUSH
11810: LD_INT 100
11812: PUSH
11813: LD_INT 70
11815: PUSH
11816: EMPTY
11817: LIST
11818: LIST
11819: LIST
11820: PUSH
11821: LD_OWVAR 67
11825: ARRAY
11826: PPUSH
11827: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
11831: LD_INT 35
11833: PPUSH
11834: LD_INT 4
11836: PPUSH
11837: CALL_OW 235
// hc_importance := 100 ;
11841: LD_ADDR_OWVAR 32
11845: PUSH
11846: LD_INT 100
11848: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
11849: LD_INT 1
11851: PPUSH
11852: LD_INT 2
11854: PPUSH
11855: LD_VAR 0 2
11859: PUSH
11860: LD_INT 1
11862: PLUS
11863: PPUSH
11864: CALL_OW 380
// hc_gallery := hardch ;
11868: LD_ADDR_OWVAR 33
11872: PUSH
11873: LD_STRING hardch
11875: ST_TO_ADDR
// hc_face_number := 1 ;
11876: LD_ADDR_OWVAR 34
11880: PUSH
11881: LD_INT 1
11883: ST_TO_ADDR
// guyA := CreateHuman ;
11884: LD_ADDR_EXP 37
11888: PUSH
11889: CALL_OW 44
11893: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
11894: LD_INT 1
11896: PPUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_VAR 0 2
11904: PPUSH
11905: CALL_OW 380
// hc_face_number := 2 ;
11909: LD_ADDR_OWVAR 34
11913: PUSH
11914: LD_INT 2
11916: ST_TO_ADDR
// guyB := CreateHuman ;
11917: LD_ADDR_EXP 38
11921: PUSH
11922: CALL_OW 44
11926: ST_TO_ADDR
// hc_importance := 0 ;
11927: LD_ADDR_OWVAR 32
11931: PUSH
11932: LD_INT 0
11934: ST_TO_ADDR
// hc_gallery :=  ;
11935: LD_ADDR_OWVAR 33
11939: PUSH
11940: LD_STRING 
11942: ST_TO_ADDR
// end ;
11943: LD_VAR 0 1
11947: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
11948: LD_INT 0
11950: PPUSH
11951: PPUSH
11952: PPUSH
11953: PPUSH
11954: PPUSH
11955: PPUSH
11956: PPUSH
11957: PPUSH
11958: PPUSH
// uc_side := 4 ;
11959: LD_ADDR_OWVAR 20
11963: PUSH
11964: LD_INT 4
11966: ST_TO_ADDR
// uc_nation := 1 ;
11967: LD_ADDR_OWVAR 21
11971: PUSH
11972: LD_INT 1
11974: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
11975: LD_ADDR_VAR 0 10
11979: PUSH
11980: LD_INT 6
11982: PUSH
11983: LD_INT 5
11985: PUSH
11986: LD_INT 4
11988: PUSH
11989: EMPTY
11990: LIST
11991: LIST
11992: LIST
11993: PUSH
11994: LD_OWVAR 67
11998: ARRAY
11999: ST_TO_ADDR
// Beta_Squad := [ ] ;
12000: LD_ADDR_EXP 39
12004: PUSH
12005: EMPTY
12006: ST_TO_ADDR
// case num of 1 :
12007: LD_VAR 0 1
12011: PUSH
12012: LD_INT 1
12014: DOUBLE
12015: EQUAL
12016: IFTRUE 12020
12018: GO 12063
12020: POP
// begin sold := 2 ;
12021: LD_ADDR_VAR 0 5
12025: PUSH
12026: LD_INT 2
12028: ST_TO_ADDR
// sci := 1 ;
12029: LD_ADDR_VAR 0 6
12033: PUSH
12034: LD_INT 1
12036: ST_TO_ADDR
// mech := 2 ;
12037: LD_ADDR_VAR 0 7
12041: PUSH
12042: LD_INT 2
12044: ST_TO_ADDR
// tank := 1 ;
12045: LD_ADDR_VAR 0 8
12049: PUSH
12050: LD_INT 1
12052: ST_TO_ADDR
// cargo := 1 ;
12053: LD_ADDR_VAR 0 9
12057: PUSH
12058: LD_INT 1
12060: ST_TO_ADDR
// end ; 2 :
12061: GO 12166
12063: LD_INT 2
12065: DOUBLE
12066: EQUAL
12067: IFTRUE 12071
12069: GO 12114
12071: POP
// begin sold := 2 ;
12072: LD_ADDR_VAR 0 5
12076: PUSH
12077: LD_INT 2
12079: ST_TO_ADDR
// sci := 1 ;
12080: LD_ADDR_VAR 0 6
12084: PUSH
12085: LD_INT 1
12087: ST_TO_ADDR
// mech := 1 ;
12088: LD_ADDR_VAR 0 7
12092: PUSH
12093: LD_INT 1
12095: ST_TO_ADDR
// tank := 1 ;
12096: LD_ADDR_VAR 0 8
12100: PUSH
12101: LD_INT 1
12103: ST_TO_ADDR
// cargo := 0 ;
12104: LD_ADDR_VAR 0 9
12108: PUSH
12109: LD_INT 0
12111: ST_TO_ADDR
// end ; 3 :
12112: GO 12166
12114: LD_INT 3
12116: DOUBLE
12117: EQUAL
12118: IFTRUE 12122
12120: GO 12165
12122: POP
// begin sold := 1 ;
12123: LD_ADDR_VAR 0 5
12127: PUSH
12128: LD_INT 1
12130: ST_TO_ADDR
// sci := 1 ;
12131: LD_ADDR_VAR 0 6
12135: PUSH
12136: LD_INT 1
12138: ST_TO_ADDR
// mech := 1 ;
12139: LD_ADDR_VAR 0 7
12143: PUSH
12144: LD_INT 1
12146: ST_TO_ADDR
// tank := 1 ;
12147: LD_ADDR_VAR 0 8
12151: PUSH
12152: LD_INT 1
12154: ST_TO_ADDR
// cargo := 0 ;
12155: LD_ADDR_VAR 0 9
12159: PUSH
12160: LD_INT 0
12162: ST_TO_ADDR
// end ; end ;
12163: GO 12166
12165: POP
// for i = 1 to sold do
12166: LD_ADDR_VAR 0 3
12170: PUSH
12171: DOUBLE
12172: LD_INT 1
12174: DEC
12175: ST_TO_ADDR
12176: LD_VAR 0 5
12180: PUSH
12181: FOR_TO
12182: IFFALSE 12254
// begin if i = 1 then
12184: LD_VAR 0 3
12188: PUSH
12189: LD_INT 1
12191: EQUAL
12192: IFFALSE 12211
// PrepareHuman ( sex_male , 1 , skill ) else
12194: LD_INT 1
12196: PPUSH
12197: LD_INT 1
12199: PPUSH
12200: LD_VAR 0 10
12204: PPUSH
12205: CALL_OW 380
12209: GO 12226
// PrepareHuman ( false , 1 , skill ) ;
12211: LD_INT 0
12213: PPUSH
12214: LD_INT 1
12216: PPUSH
12217: LD_VAR 0 10
12221: PPUSH
12222: CALL_OW 380
// un := CreateHuman ;
12226: LD_ADDR_VAR 0 4
12230: PUSH
12231: CALL_OW 44
12235: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12236: LD_ADDR_EXP 39
12240: PUSH
12241: LD_EXP 39
12245: PUSH
12246: LD_VAR 0 4
12250: ADD
12251: ST_TO_ADDR
// end ;
12252: GO 12181
12254: POP
12255: POP
// for i = 1 to mech do
12256: LD_ADDR_VAR 0 3
12260: PUSH
12261: DOUBLE
12262: LD_INT 1
12264: DEC
12265: ST_TO_ADDR
12266: LD_VAR 0 7
12270: PUSH
12271: FOR_TO
12272: IFFALSE 12329
// begin PrepareHuman ( false , 3 , skill ) ;
12274: LD_INT 0
12276: PPUSH
12277: LD_INT 3
12279: PPUSH
12280: LD_VAR 0 10
12284: PPUSH
12285: CALL_OW 380
// un := CreateHuman ;
12289: LD_ADDR_VAR 0 4
12293: PUSH
12294: CALL_OW 44
12298: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12299: LD_VAR 0 4
12303: PPUSH
12304: LD_INT 3
12306: PPUSH
12307: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12311: LD_ADDR_EXP 39
12315: PUSH
12316: LD_EXP 39
12320: PUSH
12321: LD_VAR 0 4
12325: ADD
12326: ST_TO_ADDR
// end ;
12327: GO 12271
12329: POP
12330: POP
// for i = 1 to sci do
12331: LD_ADDR_VAR 0 3
12335: PUSH
12336: DOUBLE
12337: LD_INT 1
12339: DEC
12340: ST_TO_ADDR
12341: LD_VAR 0 6
12345: PUSH
12346: FOR_TO
12347: IFFALSE 12392
// begin PrepareHuman ( false , 4 , skill ) ;
12349: LD_INT 0
12351: PPUSH
12352: LD_INT 4
12354: PPUSH
12355: LD_VAR 0 10
12359: PPUSH
12360: CALL_OW 380
// un := CreateHuman ;
12364: LD_ADDR_VAR 0 4
12368: PUSH
12369: CALL_OW 44
12373: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12374: LD_ADDR_EXP 39
12378: PUSH
12379: LD_EXP 39
12383: PUSH
12384: LD_VAR 0 4
12388: ADD
12389: ST_TO_ADDR
// end ;
12390: GO 12346
12392: POP
12393: POP
// for i = 1 to tank do
12394: LD_ADDR_VAR 0 3
12398: PUSH
12399: DOUBLE
12400: LD_INT 1
12402: DEC
12403: ST_TO_ADDR
12404: LD_VAR 0 8
12408: PUSH
12409: FOR_TO
12410: IFFALSE 12523
// begin Randomize ;
12412: CALL_OW 10
// vc_chassis := us_medium_tracked ;
12416: LD_ADDR_OWVAR 37
12420: PUSH
12421: LD_INT 3
12423: ST_TO_ADDR
// vc_engine := engine_solar ;
12424: LD_ADDR_OWVAR 39
12428: PUSH
12429: LD_INT 2
12431: ST_TO_ADDR
// vc_control := control_manual ;
12432: LD_ADDR_OWVAR 38
12436: PUSH
12437: LD_INT 1
12439: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
12440: LD_ADDR_OWVAR 40
12444: PUSH
12445: LD_INT 4
12447: PUSH
12448: LD_INT 5
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PUSH
12455: LD_INT 1
12457: PPUSH
12458: LD_INT 2
12460: PPUSH
12461: CALL_OW 12
12465: ARRAY
12466: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
12467: LD_ADDR_OWVAR 41
12471: PUSH
12472: LD_INT 35
12474: PPUSH
12475: LD_INT 55
12477: PPUSH
12478: CALL_OW 12
12482: ST_TO_ADDR
// un := CreateVehicle ;
12483: LD_ADDR_VAR 0 4
12487: PUSH
12488: CALL_OW 45
12492: ST_TO_ADDR
// SetTag ( un , 5 ) ;
12493: LD_VAR 0 4
12497: PPUSH
12498: LD_INT 5
12500: PPUSH
12501: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12505: LD_ADDR_EXP 39
12509: PUSH
12510: LD_EXP 39
12514: PUSH
12515: LD_VAR 0 4
12519: ADD
12520: ST_TO_ADDR
// end ;
12521: GO 12409
12523: POP
12524: POP
// if cargo then
12525: LD_VAR 0 9
12529: IFFALSE 12632
// begin vc_chassis := us_medium_tracked ;
12531: LD_ADDR_OWVAR 37
12535: PUSH
12536: LD_INT 3
12538: ST_TO_ADDR
// vc_engine := engine_solar ;
12539: LD_ADDR_OWVAR 39
12543: PUSH
12544: LD_INT 2
12546: ST_TO_ADDR
// vc_control := control_manual ;
12547: LD_ADDR_OWVAR 38
12551: PUSH
12552: LD_INT 1
12554: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
12555: LD_ADDR_OWVAR 40
12559: PUSH
12560: LD_INT 12
12562: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
12563: LD_ADDR_OWVAR 41
12567: PUSH
12568: LD_INT 35
12570: PPUSH
12571: LD_INT 55
12573: PPUSH
12574: CALL_OW 12
12578: ST_TO_ADDR
// un := CreateVehicle ;
12579: LD_ADDR_VAR 0 4
12583: PUSH
12584: CALL_OW 45
12588: ST_TO_ADDR
// SetTag ( un , 5 ) ;
12589: LD_VAR 0 4
12593: PPUSH
12594: LD_INT 5
12596: PPUSH
12597: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12601: LD_ADDR_EXP 39
12605: PUSH
12606: LD_EXP 39
12610: PUSH
12611: LD_VAR 0 4
12615: ADD
12616: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
12617: LD_VAR 0 4
12621: PPUSH
12622: LD_INT 1
12624: PPUSH
12625: LD_INT 60
12627: PPUSH
12628: CALL_OW 290
// end ; end ;
12632: LD_VAR 0 2
12636: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
12637: LD_INT 0
12639: PPUSH
12640: PPUSH
12641: PPUSH
12642: PPUSH
12643: PPUSH
12644: PPUSH
12645: PPUSH
12646: PPUSH
12647: PPUSH
12648: PPUSH
// uc_side := 4 ;
12649: LD_ADDR_OWVAR 20
12653: PUSH
12654: LD_INT 4
12656: ST_TO_ADDR
// uc_nation := 1 ;
12657: LD_ADDR_OWVAR 21
12661: PUSH
12662: LD_INT 1
12664: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12665: LD_ADDR_VAR 0 11
12669: PUSH
12670: LD_INT 6
12672: PUSH
12673: LD_INT 5
12675: PUSH
12676: LD_INT 4
12678: PUSH
12679: EMPTY
12680: LIST
12681: LIST
12682: LIST
12683: PUSH
12684: LD_OWVAR 67
12688: ARRAY
12689: ST_TO_ADDR
// Gamma_Squad := [ ] ;
12690: LD_ADDR_EXP 40
12694: PUSH
12695: EMPTY
12696: ST_TO_ADDR
// case num of 1 :
12697: LD_VAR 0 1
12701: PUSH
12702: LD_INT 1
12704: DOUBLE
12705: EQUAL
12706: IFTRUE 12710
12708: GO 12761
12710: POP
// begin sold := 2 ;
12711: LD_ADDR_VAR 0 5
12715: PUSH
12716: LD_INT 2
12718: ST_TO_ADDR
// eng := 2 ;
12719: LD_ADDR_VAR 0 6
12723: PUSH
12724: LD_INT 2
12726: ST_TO_ADDR
// sci := 0 ;
12727: LD_ADDR_VAR 0 7
12731: PUSH
12732: LD_INT 0
12734: ST_TO_ADDR
// mech := 1 ;
12735: LD_ADDR_VAR 0 8
12739: PUSH
12740: LD_INT 1
12742: ST_TO_ADDR
// tank := 0 ;
12743: LD_ADDR_VAR 0 9
12747: PUSH
12748: LD_INT 0
12750: ST_TO_ADDR
// cargo := 1 ;
12751: LD_ADDR_VAR 0 10
12755: PUSH
12756: LD_INT 1
12758: ST_TO_ADDR
// end ; 2 :
12759: GO 12880
12761: LD_INT 2
12763: DOUBLE
12764: EQUAL
12765: IFTRUE 12769
12767: GO 12820
12769: POP
// begin sold := 1 ;
12770: LD_ADDR_VAR 0 5
12774: PUSH
12775: LD_INT 1
12777: ST_TO_ADDR
// eng := 2 ;
12778: LD_ADDR_VAR 0 6
12782: PUSH
12783: LD_INT 2
12785: ST_TO_ADDR
// sci := 0 ;
12786: LD_ADDR_VAR 0 7
12790: PUSH
12791: LD_INT 0
12793: ST_TO_ADDR
// mech := 1 ;
12794: LD_ADDR_VAR 0 8
12798: PUSH
12799: LD_INT 1
12801: ST_TO_ADDR
// tank := 0 ;
12802: LD_ADDR_VAR 0 9
12806: PUSH
12807: LD_INT 0
12809: ST_TO_ADDR
// cargo := 1 ;
12810: LD_ADDR_VAR 0 10
12814: PUSH
12815: LD_INT 1
12817: ST_TO_ADDR
// end ; 3 :
12818: GO 12880
12820: LD_INT 3
12822: DOUBLE
12823: EQUAL
12824: IFTRUE 12828
12826: GO 12879
12828: POP
// begin sold := 1 ;
12829: LD_ADDR_VAR 0 5
12833: PUSH
12834: LD_INT 1
12836: ST_TO_ADDR
// eng := 1 ;
12837: LD_ADDR_VAR 0 6
12841: PUSH
12842: LD_INT 1
12844: ST_TO_ADDR
// sci := 0 ;
12845: LD_ADDR_VAR 0 7
12849: PUSH
12850: LD_INT 0
12852: ST_TO_ADDR
// mech := 1 ;
12853: LD_ADDR_VAR 0 8
12857: PUSH
12858: LD_INT 1
12860: ST_TO_ADDR
// tank := 0 ;
12861: LD_ADDR_VAR 0 9
12865: PUSH
12866: LD_INT 0
12868: ST_TO_ADDR
// cargo := 1 ;
12869: LD_ADDR_VAR 0 10
12873: PUSH
12874: LD_INT 1
12876: ST_TO_ADDR
// end ; end ;
12877: GO 12880
12879: POP
// for i = 1 to sold do
12880: LD_ADDR_VAR 0 3
12884: PUSH
12885: DOUBLE
12886: LD_INT 1
12888: DEC
12889: ST_TO_ADDR
12890: LD_VAR 0 5
12894: PUSH
12895: FOR_TO
12896: IFFALSE 12968
// begin if i = 1 then
12898: LD_VAR 0 3
12902: PUSH
12903: LD_INT 1
12905: EQUAL
12906: IFFALSE 12925
// PrepareHuman ( sex_male , 1 , skill ) else
12908: LD_INT 1
12910: PPUSH
12911: LD_INT 1
12913: PPUSH
12914: LD_VAR 0 11
12918: PPUSH
12919: CALL_OW 380
12923: GO 12940
// PrepareHuman ( false , 1 , skill ) ;
12925: LD_INT 0
12927: PPUSH
12928: LD_INT 1
12930: PPUSH
12931: LD_VAR 0 11
12935: PPUSH
12936: CALL_OW 380
// un := CreateHuman ;
12940: LD_ADDR_VAR 0 4
12944: PUSH
12945: CALL_OW 44
12949: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
12950: LD_ADDR_EXP 40
12954: PUSH
12955: LD_EXP 40
12959: PUSH
12960: LD_VAR 0 4
12964: ADD
12965: ST_TO_ADDR
// end ;
12966: GO 12895
12968: POP
12969: POP
// for i = 1 to mech do
12970: LD_ADDR_VAR 0 3
12974: PUSH
12975: DOUBLE
12976: LD_INT 1
12978: DEC
12979: ST_TO_ADDR
12980: LD_VAR 0 8
12984: PUSH
12985: FOR_TO
12986: IFFALSE 13043
// begin PrepareHuman ( false , 3 , skill ) ;
12988: LD_INT 0
12990: PPUSH
12991: LD_INT 3
12993: PPUSH
12994: LD_VAR 0 11
12998: PPUSH
12999: CALL_OW 380
// un := CreateHuman ;
13003: LD_ADDR_VAR 0 4
13007: PUSH
13008: CALL_OW 44
13012: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13013: LD_VAR 0 4
13017: PPUSH
13018: LD_INT 3
13020: PPUSH
13021: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13025: LD_ADDR_EXP 40
13029: PUSH
13030: LD_EXP 40
13034: PUSH
13035: LD_VAR 0 4
13039: ADD
13040: ST_TO_ADDR
// end ;
13041: GO 12985
13043: POP
13044: POP
// for i = 1 to eng do
13045: LD_ADDR_VAR 0 3
13049: PUSH
13050: DOUBLE
13051: LD_INT 1
13053: DEC
13054: ST_TO_ADDR
13055: LD_VAR 0 6
13059: PUSH
13060: FOR_TO
13061: IFFALSE 13106
// begin PrepareHuman ( false , 2 , skill ) ;
13063: LD_INT 0
13065: PPUSH
13066: LD_INT 2
13068: PPUSH
13069: LD_VAR 0 11
13073: PPUSH
13074: CALL_OW 380
// un := CreateHuman ;
13078: LD_ADDR_VAR 0 4
13082: PUSH
13083: CALL_OW 44
13087: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13088: LD_ADDR_EXP 40
13092: PUSH
13093: LD_EXP 40
13097: PUSH
13098: LD_VAR 0 4
13102: ADD
13103: ST_TO_ADDR
// end ;
13104: GO 13060
13106: POP
13107: POP
// for i = 1 to tank do
13108: LD_ADDR_VAR 0 3
13112: PUSH
13113: DOUBLE
13114: LD_INT 1
13116: DEC
13117: ST_TO_ADDR
13118: LD_VAR 0 9
13122: PUSH
13123: FOR_TO
13124: IFFALSE 13237
// begin Randomize ;
13126: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13130: LD_ADDR_OWVAR 37
13134: PUSH
13135: LD_INT 2
13137: ST_TO_ADDR
// vc_engine := engine_siberite ;
13138: LD_ADDR_OWVAR 39
13142: PUSH
13143: LD_INT 3
13145: ST_TO_ADDR
// vc_control := control_manual ;
13146: LD_ADDR_OWVAR 38
13150: PUSH
13151: LD_INT 1
13153: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13154: LD_ADDR_OWVAR 40
13158: PUSH
13159: LD_INT 7
13161: PUSH
13162: LD_INT 9
13164: PUSH
13165: EMPTY
13166: LIST
13167: LIST
13168: PUSH
13169: LD_INT 1
13171: PPUSH
13172: LD_INT 2
13174: PPUSH
13175: CALL_OW 12
13179: ARRAY
13180: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13181: LD_ADDR_OWVAR 41
13185: PUSH
13186: LD_INT 35
13188: PPUSH
13189: LD_INT 55
13191: PPUSH
13192: CALL_OW 12
13196: ST_TO_ADDR
// un := CreateVehicle ;
13197: LD_ADDR_VAR 0 4
13201: PUSH
13202: CALL_OW 45
13206: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13207: LD_VAR 0 4
13211: PPUSH
13212: LD_INT 5
13214: PPUSH
13215: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13219: LD_ADDR_EXP 40
13223: PUSH
13224: LD_EXP 40
13228: PUSH
13229: LD_VAR 0 4
13233: ADD
13234: ST_TO_ADDR
// end ;
13235: GO 13123
13237: POP
13238: POP
// if cargo then
13239: LD_VAR 0 10
13243: IFFALSE 13361
// begin vc_chassis := us_medium_tracked ;
13245: LD_ADDR_OWVAR 37
13249: PUSH
13250: LD_INT 3
13252: ST_TO_ADDR
// vc_engine := engine_combustion ;
13253: LD_ADDR_OWVAR 39
13257: PUSH
13258: LD_INT 1
13260: ST_TO_ADDR
// vc_control := control_manual ;
13261: LD_ADDR_OWVAR 38
13265: PUSH
13266: LD_INT 1
13268: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13269: LD_ADDR_OWVAR 40
13273: PUSH
13274: LD_INT 12
13276: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13277: LD_ADDR_OWVAR 41
13281: PUSH
13282: LD_INT 35
13284: PPUSH
13285: LD_INT 55
13287: PPUSH
13288: CALL_OW 12
13292: ST_TO_ADDR
// un := CreateVehicle ;
13293: LD_ADDR_VAR 0 4
13297: PUSH
13298: CALL_OW 45
13302: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13303: LD_VAR 0 4
13307: PPUSH
13308: LD_INT 5
13310: PPUSH
13311: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13315: LD_ADDR_EXP 40
13319: PUSH
13320: LD_EXP 40
13324: PUSH
13325: LD_VAR 0 4
13329: ADD
13330: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13331: LD_VAR 0 4
13335: PPUSH
13336: LD_INT 3
13338: PPUSH
13339: LD_INT 30
13341: PPUSH
13342: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13346: LD_VAR 0 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: LD_INT 40
13356: PPUSH
13357: CALL_OW 290
// end ; end ;
13361: LD_VAR 0 2
13365: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13366: LD_INT 0
13368: PPUSH
13369: PPUSH
13370: PPUSH
13371: PPUSH
13372: PPUSH
13373: PPUSH
13374: PPUSH
13375: PPUSH
13376: PPUSH
13377: PPUSH
// uc_side := 4 ;
13378: LD_ADDR_OWVAR 20
13382: PUSH
13383: LD_INT 4
13385: ST_TO_ADDR
// uc_nation := 1 ;
13386: LD_ADDR_OWVAR 21
13390: PUSH
13391: LD_INT 1
13393: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13394: LD_ADDR_VAR 0 10
13398: PUSH
13399: LD_INT 6
13401: PUSH
13402: LD_INT 5
13404: PUSH
13405: LD_INT 4
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: LIST
13412: PUSH
13413: LD_OWVAR 67
13417: ARRAY
13418: ST_TO_ADDR
// Zeta_Squad := [ ] ;
13419: LD_ADDR_EXP 41
13423: PUSH
13424: EMPTY
13425: ST_TO_ADDR
// sold := 1 ;
13426: LD_ADDR_VAR 0 4
13430: PUSH
13431: LD_INT 1
13433: ST_TO_ADDR
// eng := 0 ;
13434: LD_ADDR_VAR 0 5
13438: PUSH
13439: LD_INT 0
13441: ST_TO_ADDR
// sci := 0 ;
13442: LD_ADDR_VAR 0 6
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// mech := 3 ;
13450: LD_ADDR_VAR 0 7
13454: PUSH
13455: LD_INT 3
13457: ST_TO_ADDR
// tank := 3 ;
13458: LD_ADDR_VAR 0 8
13462: PUSH
13463: LD_INT 3
13465: ST_TO_ADDR
// cargo := 0 ;
13466: LD_ADDR_VAR 0 9
13470: PUSH
13471: LD_INT 0
13473: ST_TO_ADDR
// for i = 1 to sold do
13474: LD_ADDR_VAR 0 2
13478: PUSH
13479: DOUBLE
13480: LD_INT 1
13482: DEC
13483: ST_TO_ADDR
13484: LD_VAR 0 4
13488: PUSH
13489: FOR_TO
13490: IFFALSE 13562
// begin if i = 1 then
13492: LD_VAR 0 2
13496: PUSH
13497: LD_INT 1
13499: EQUAL
13500: IFFALSE 13519
// PrepareHuman ( sex_male , 1 , skill ) else
13502: LD_INT 1
13504: PPUSH
13505: LD_INT 1
13507: PPUSH
13508: LD_VAR 0 10
13512: PPUSH
13513: CALL_OW 380
13517: GO 13534
// PrepareHuman ( false , 1 , skill ) ;
13519: LD_INT 0
13521: PPUSH
13522: LD_INT 1
13524: PPUSH
13525: LD_VAR 0 10
13529: PPUSH
13530: CALL_OW 380
// un := CreateHuman ;
13534: LD_ADDR_VAR 0 3
13538: PUSH
13539: CALL_OW 44
13543: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
13544: LD_ADDR_EXP 41
13548: PUSH
13549: LD_EXP 41
13553: PUSH
13554: LD_VAR 0 3
13558: ADD
13559: ST_TO_ADDR
// end ;
13560: GO 13489
13562: POP
13563: POP
// for i = 1 to mech do
13564: LD_ADDR_VAR 0 2
13568: PUSH
13569: DOUBLE
13570: LD_INT 1
13572: DEC
13573: ST_TO_ADDR
13574: LD_VAR 0 7
13578: PUSH
13579: FOR_TO
13580: IFFALSE 13637
// begin PrepareHuman ( false , 3 , skill ) ;
13582: LD_INT 0
13584: PPUSH
13585: LD_INT 3
13587: PPUSH
13588: LD_VAR 0 10
13592: PPUSH
13593: CALL_OW 380
// un := CreateHuman ;
13597: LD_ADDR_VAR 0 3
13601: PUSH
13602: CALL_OW 44
13606: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13607: LD_VAR 0 3
13611: PPUSH
13612: LD_INT 3
13614: PPUSH
13615: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
13619: LD_ADDR_EXP 41
13623: PUSH
13624: LD_EXP 41
13628: PUSH
13629: LD_VAR 0 3
13633: ADD
13634: ST_TO_ADDR
// end ;
13635: GO 13579
13637: POP
13638: POP
// for i = 1 to tank do
13639: LD_ADDR_VAR 0 2
13643: PUSH
13644: DOUBLE
13645: LD_INT 1
13647: DEC
13648: ST_TO_ADDR
13649: LD_VAR 0 8
13653: PUSH
13654: FOR_TO
13655: IFFALSE 13901
// begin Randomize ;
13657: CALL_OW 10
// if i < 3 then
13661: LD_VAR 0 2
13665: PUSH
13666: LD_INT 3
13668: LESS
13669: IFFALSE 13778
// begin vc_chassis := us_medium_tracked ;
13671: LD_ADDR_OWVAR 37
13675: PUSH
13676: LD_INT 3
13678: ST_TO_ADDR
// vc_engine := engine_combustion ;
13679: LD_ADDR_OWVAR 39
13683: PUSH
13684: LD_INT 1
13686: ST_TO_ADDR
// vc_control := control_manual ;
13687: LD_ADDR_OWVAR 38
13691: PUSH
13692: LD_INT 1
13694: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
13695: LD_ADDR_OWVAR 40
13699: PUSH
13700: LD_INT 3
13702: PUSH
13703: LD_INT 9
13705: PUSH
13706: EMPTY
13707: LIST
13708: LIST
13709: PUSH
13710: LD_INT 1
13712: PPUSH
13713: LD_INT 2
13715: PPUSH
13716: CALL_OW 12
13720: ARRAY
13721: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13722: LD_ADDR_OWVAR 41
13726: PUSH
13727: LD_INT 35
13729: PPUSH
13730: LD_INT 55
13732: PPUSH
13733: CALL_OW 12
13737: ST_TO_ADDR
// un := CreateVehicle ;
13738: LD_ADDR_VAR 0 3
13742: PUSH
13743: CALL_OW 45
13747: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13748: LD_VAR 0 3
13752: PPUSH
13753: LD_INT 5
13755: PPUSH
13756: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
13760: LD_ADDR_EXP 41
13764: PUSH
13765: LD_EXP 41
13769: PUSH
13770: LD_VAR 0 3
13774: ADD
13775: ST_TO_ADDR
// end else
13776: GO 13899
// begin uc_nation := 3 ;
13778: LD_ADDR_OWVAR 21
13782: PUSH
13783: LD_INT 3
13785: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
13786: LD_ADDR_OWVAR 37
13790: PUSH
13791: LD_INT 22
13793: ST_TO_ADDR
// vc_engine := engine_combustion ;
13794: LD_ADDR_OWVAR 39
13798: PUSH
13799: LD_INT 1
13801: ST_TO_ADDR
// vc_control := control_manual ;
13802: LD_ADDR_OWVAR 38
13806: PUSH
13807: LD_INT 1
13809: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
13810: LD_ADDR_OWVAR 40
13814: PUSH
13815: LD_INT 51
13817: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13818: LD_ADDR_OWVAR 41
13822: PUSH
13823: LD_INT 35
13825: PPUSH
13826: LD_INT 55
13828: PPUSH
13829: CALL_OW 12
13833: ST_TO_ADDR
// un := CreateVehicle ;
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: CALL_OW 45
13843: ST_TO_ADDR
// SetLives ( un , 496 ) ;
13844: LD_VAR 0 3
13848: PPUSH
13849: LD_INT 496
13851: PPUSH
13852: CALL_OW 234
// SetTag ( un , 5 ) ;
13856: LD_VAR 0 3
13860: PPUSH
13861: LD_INT 5
13863: PPUSH
13864: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
13868: LD_VAR 0 3
13872: PPUSH
13873: LD_INT 2
13875: PPUSH
13876: LD_INT 100
13878: PPUSH
13879: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
13883: LD_ADDR_EXP 41
13887: PUSH
13888: LD_EXP 41
13892: PUSH
13893: LD_VAR 0 3
13897: ADD
13898: ST_TO_ADDR
// end ; end ;
13899: GO 13654
13901: POP
13902: POP
// end ; end_of_file
13903: LD_VAR 0 1
13907: RET
// export function Action ; begin
13908: LD_INT 0
13910: PPUSH
// InGameOn ;
13911: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
13915: LD_INT 151
13917: PPUSH
13918: LD_INT 107
13920: PPUSH
13921: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
13925: LD_EXP 37
13929: PPUSH
13930: LD_INT 171
13932: PPUSH
13933: LD_INT 108
13935: PPUSH
13936: LD_INT 0
13938: PPUSH
13939: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
13943: LD_EXP 38
13947: PPUSH
13948: LD_INT 172
13950: PPUSH
13951: LD_INT 110
13953: PPUSH
13954: LD_INT 0
13956: PPUSH
13957: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
13961: LD_EXP 37
13965: PPUSH
13966: LD_INT 156
13968: PPUSH
13969: LD_INT 107
13971: PPUSH
13972: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
13976: LD_EXP 38
13980: PPUSH
13981: LD_INT 154
13983: PPUSH
13984: LD_INT 105
13986: PPUSH
13987: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
13991: LD_INT 4
13993: PPUSH
13994: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
13998: LD_EXP 37
14002: PPUSH
14003: CALL_OW 250
14007: PUSH
14008: LD_INT 156
14010: EQUAL
14011: PUSH
14012: LD_EXP 37
14016: PPUSH
14017: CALL_OW 251
14021: PUSH
14022: LD_INT 107
14024: EQUAL
14025: AND
14026: IFFALSE 13991
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14028: LD_EXP 37
14032: PUSH
14033: LD_EXP 38
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: PPUSH
14042: LD_INT 35
14044: PPUSH
14045: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14049: LD_EXP 37
14053: PPUSH
14054: LD_STRING D1-A-1
14056: PPUSH
14057: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14061: LD_EXP 38
14065: PPUSH
14066: LD_STRING D1-B-1
14068: PPUSH
14069: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14073: LD_EXP 37
14077: PPUSH
14078: LD_STRING D1-A-2
14080: PPUSH
14081: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14085: LD_EXP 38
14089: PPUSH
14090: LD_STRING D1-B-2
14092: PPUSH
14093: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14097: LD_EXP 37
14101: PUSH
14102: LD_EXP 38
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: PPUSH
14111: LD_INT 147
14113: PPUSH
14114: LD_INT 108
14116: PPUSH
14117: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14121: LD_EXP 37
14125: PPUSH
14126: LD_STRING D1-A-3
14128: PPUSH
14129: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14133: LD_INT 4
14135: PPUSH
14136: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14140: LD_EXP 37
14144: PPUSH
14145: LD_INT 35
14147: PPUSH
14148: CALL_OW 296
14152: PUSH
14153: LD_INT 8
14155: LESS
14156: IFFALSE 14133
// ComTurnUnit ( guyA , guyB ) ;
14158: LD_EXP 37
14162: PPUSH
14163: LD_EXP 38
14167: PPUSH
14168: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14172: LD_EXP 38
14176: PPUSH
14177: LD_EXP 37
14181: PPUSH
14182: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14186: LD_EXP 37
14190: PPUSH
14191: LD_STRING D1-A-10
14193: PPUSH
14194: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14198: LD_EXP 38
14202: PPUSH
14203: LD_STRING D1-B-10
14205: PPUSH
14206: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14210: LD_EXP 37
14214: PPUSH
14215: LD_STRING D1-A-11
14217: PPUSH
14218: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14222: LD_EXP 38
14226: PPUSH
14227: LD_STRING D1-B-11
14229: PPUSH
14230: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14234: LD_EXP 37
14238: PPUSH
14239: LD_STRING D1-A-12
14241: PPUSH
14242: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14246: LD_EXP 38
14250: PPUSH
14251: LD_STRING D1-B-12
14253: PPUSH
14254: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14258: LD_EXP 37
14262: PPUSH
14263: LD_STRING D1-A-13
14265: PPUSH
14266: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14270: LD_EXP 38
14274: PPUSH
14275: LD_STRING D1-B-13
14277: PPUSH
14278: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14282: LD_EXP 37
14286: PPUSH
14287: LD_STRING D1-A-14
14289: PPUSH
14290: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14294: LD_EXP 38
14298: PPUSH
14299: LD_STRING D1-B-14
14301: PPUSH
14302: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14306: LD_EXP 37
14310: PPUSH
14311: LD_STRING D1-A-15
14313: PPUSH
14314: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14318: LD_EXP 38
14322: PPUSH
14323: LD_STRING D1-B-15
14325: PPUSH
14326: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14330: LD_EXP 37
14334: PPUSH
14335: LD_STRING D1-A-16
14337: PPUSH
14338: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14342: LD_EXP 38
14346: PPUSH
14347: LD_STRING D1-B-16
14349: PPUSH
14350: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14354: LD_EXP 37
14358: PPUSH
14359: LD_STRING D1-A-17
14361: PPUSH
14362: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14366: LD_EXP 38
14370: PPUSH
14371: LD_STRING D1-B-17
14373: PPUSH
14374: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
14378: LD_EXP 37
14382: PPUSH
14383: LD_STRING D1-A-18
14385: PPUSH
14386: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
14390: LD_INT 35
14392: PPUSH
14393: LD_INT 1
14395: PPUSH
14396: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
14400: LD_EXP 37
14404: PUSH
14405: LD_EXP 38
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PPUSH
14414: LD_INT 35
14416: PPUSH
14417: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
14421: LD_INT 4
14423: PPUSH
14424: CALL_OW 67
// until IsInUnit ( guyA ) ;
14428: LD_EXP 37
14432: PPUSH
14433: CALL_OW 310
14437: IFFALSE 14421
// Wait ( 0 0$02 ) ;
14439: LD_INT 70
14441: PPUSH
14442: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
14446: LD_EXP 37
14450: PPUSH
14451: LD_STRING D1-A-19
14453: PPUSH
14454: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
14458: LD_EXP 38
14462: PPUSH
14463: LD_STRING D1-B-19
14465: PPUSH
14466: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
14470: LD_EXP 37
14474: PPUSH
14475: LD_STRING D1-A-20
14477: PPUSH
14478: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
14482: LD_INT 10
14484: PPUSH
14485: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
14489: LD_EXP 38
14493: PPUSH
14494: LD_STRING D1-B-20
14496: PPUSH
14497: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
14501: LD_EXP 37
14505: PPUSH
14506: LD_STRING D1-A-21
14508: PPUSH
14509: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
14513: LD_EXP 38
14517: PPUSH
14518: LD_STRING D1-B-21
14520: PPUSH
14521: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
14525: LD_EXP 37
14529: PPUSH
14530: LD_STRING D1-A-22
14532: PPUSH
14533: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
14537: LD_EXP 38
14541: PPUSH
14542: LD_STRING D1-B-22
14544: PPUSH
14545: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
14549: LD_EXP 37
14553: PPUSH
14554: LD_STRING D1-A-23
14556: PPUSH
14557: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
14561: LD_EXP 38
14565: PPUSH
14566: LD_STRING D1-B-23
14568: PPUSH
14569: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
14573: LD_EXP 37
14577: PPUSH
14578: LD_STRING D1-A-24
14580: PPUSH
14581: CALL_OW 88
// InGameOff ;
14585: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
14589: LD_STRING M_main
14591: PPUSH
14592: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
14596: LD_INT 4
14598: PPUSH
14599: LD_INT 1
14601: PPUSH
14602: CALL_OW 343
// game_status := true ;
14606: LD_ADDR_EXP 28
14610: PUSH
14611: LD_INT 1
14613: ST_TO_ADDR
// end ;
14614: LD_VAR 0 1
14618: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
14619: LD_INT 1
14621: PPUSH
14622: CALL 6306 0 1
14626: PUSH
14627: LD_INT 0
14629: GREATER
14630: IFFALSE 14732
14632: GO 14634
14634: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
14635: LD_INT 35
14637: PPUSH
14638: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
14642: LD_INT 1
14644: PPUSH
14645: CALL 6306 0 1
14649: PUSH
14650: LD_INT 1
14652: ARRAY
14653: PPUSH
14654: CALL_OW 461
14658: PUSH
14659: LD_INT 1
14661: NONEQUAL
14662: IFFALSE 14635
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
14664: LD_EXP 37
14668: PPUSH
14669: CALL_OW 300
14673: PUSH
14674: LD_EXP 38
14678: PPUSH
14679: CALL_OW 300
14683: AND
14684: PUSH
14685: LD_EXP 29
14689: NOT
14690: AND
14691: IFFALSE 14717
// begin Say ( guyA , DL-A-1 ) ;
14693: LD_EXP 37
14697: PPUSH
14698: LD_STRING DL-A-1
14700: PPUSH
14701: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
14705: LD_EXP 38
14709: PPUSH
14710: LD_STRING DL-B-1
14712: PPUSH
14713: CALL_OW 88
// end ; if not helps_can_arrive then
14717: LD_EXP 30
14721: NOT
14722: IFFALSE 14732
// helps_can_arrive := true ;
14724: LD_ADDR_EXP 30
14728: PUSH
14729: LD_INT 1
14731: ST_TO_ADDR
// end ;
14732: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
14733: LD_INT 1
14735: PPUSH
14736: CALL 6306 0 1
14740: PUSH
14741: LD_INT 0
14743: GREATER
14744: PUSH
14745: LD_EXP 37
14749: PPUSH
14750: CALL_OW 300
14754: AND
14755: PUSH
14756: LD_EXP 38
14760: PPUSH
14761: CALL_OW 300
14765: AND
14766: PUSH
14767: LD_INT 22
14769: PUSH
14770: LD_INT 1
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PUSH
14777: LD_INT 25
14779: PUSH
14780: LD_INT 12
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: PPUSH
14791: CALL_OW 69
14795: PUSH
14796: LD_INT 0
14798: EQUAL
14799: AND
14800: PUSH
14801: LD_INT 1
14803: PPUSH
14804: LD_INT 25
14806: PUSH
14807: LD_INT 12
14809: PUSH
14810: EMPTY
14811: LIST
14812: LIST
14813: PPUSH
14814: CALL_OW 69
14818: PPUSH
14819: LD_EXP 37
14823: PPUSH
14824: CALL_OW 74
14828: PPUSH
14829: CALL_OW 292
14833: AND
14834: IFFALSE 14875
14836: GO 14838
14838: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
14839: LD_EXP 37
14843: PPUSH
14844: LD_STRING DA-A-1
14846: PPUSH
14847: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
14851: LD_EXP 38
14855: PPUSH
14856: LD_STRING DA-B-1
14858: PPUSH
14859: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
14863: LD_EXP 37
14867: PPUSH
14868: LD_STRING DA-A-2
14870: PPUSH
14871: CALL_OW 88
// end ;
14875: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
14876: LD_EXP 28
14880: PUSH
14881: LD_EXP 37
14885: PPUSH
14886: LD_INT 6
14888: PPUSH
14889: CALL_OW 299
14893: PUSH
14894: LD_INT 7
14896: LESS
14897: AND
14898: IFFALSE 14951
14900: GO 14902
14902: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
14903: LD_INT 117
14905: PPUSH
14906: LD_INT 50
14908: PPUSH
14909: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
14913: LD_INT 1
14915: PPUSH
14916: CALL 10047 0 1
14920: PUSH
14921: LD_INT 2
14923: ARRAY
14924: PPUSH
14925: LD_STRING D5-A-1
14927: PPUSH
14928: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
14932: LD_INT 1
14934: PPUSH
14935: CALL 10047 0 1
14939: PUSH
14940: LD_INT 1
14942: ARRAY
14943: PPUSH
14944: LD_STRING D5-B-1
14946: PPUSH
14947: CALL_OW 88
// end ;
14951: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
14952: LD_INT 7
14954: PPUSH
14955: LD_INT 22
14957: PUSH
14958: LD_INT 1
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: PPUSH
14965: CALL_OW 70
14969: PUSH
14970: LD_INT 0
14972: GREATER
14973: IFFALSE 15118
14975: GO 14977
14977: DISABLE
// begin Wait ( 0 0$03 ) ;
14978: LD_INT 105
14980: PPUSH
14981: CALL_OW 67
// DialogueOn ;
14985: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
14989: LD_INT 1
14991: PPUSH
14992: CALL 10047 0 1
14996: PUSH
14997: LD_INT 1
14999: ARRAY
15000: PPUSH
15001: LD_STRING D6-A-1
15003: PPUSH
15004: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15008: LD_INT 1
15010: PPUSH
15011: CALL 10047 0 1
15015: PUSH
15016: LD_INT 2
15018: ARRAY
15019: PPUSH
15020: LD_STRING D6-B-1
15022: PPUSH
15023: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15027: LD_INT 95
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: LD_INT 1
15035: PPUSH
15036: LD_INT 20
15038: PPUSH
15039: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15043: LD_INT 10
15045: PPUSH
15046: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15050: LD_INT 1
15052: PPUSH
15053: CALL 10047 0 1
15057: PUSH
15058: LD_INT 1
15060: ARRAY
15061: PPUSH
15062: LD_STRING D6-A-2
15064: PPUSH
15065: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15069: LD_INT 1
15071: PPUSH
15072: CALL 10047 0 1
15076: PUSH
15077: LD_INT 2
15079: ARRAY
15080: PPUSH
15081: LD_STRING D6-B-2
15083: PPUSH
15084: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15088: LD_INT 1
15090: PPUSH
15091: CALL 10047 0 1
15095: PUSH
15096: LD_INT 1
15098: ARRAY
15099: PPUSH
15100: LD_STRING D6-A-3
15102: PPUSH
15103: CALL_OW 88
// DialogueOff ;
15107: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15111: LD_STRING M_base
15113: PPUSH
15114: CALL_OW 337
// end ;
15118: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15119: LD_EXP 29
15123: NOT
15124: PUSH
15125: LD_INT 22
15127: PUSH
15128: LD_INT 3
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 21
15137: PUSH
15138: LD_INT 2
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL_OW 69
15153: PUSH
15154: LD_INT 0
15156: GREATER
15157: AND
15158: IFFALSE 15291
15160: GO 15162
15162: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15163: LD_INT 35
15165: PPUSH
15166: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15170: LD_INT 22
15172: PUSH
15173: LD_INT 3
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: PUSH
15180: LD_INT 21
15182: PUSH
15183: LD_INT 2
15185: PUSH
15186: EMPTY
15187: LIST
15188: LIST
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PPUSH
15194: CALL_OW 69
15198: PPUSH
15199: LD_INT 1
15201: PPUSH
15202: CALL 10047 0 1
15206: PUSH
15207: LD_INT 1
15209: ARRAY
15210: PPUSH
15211: CALL_OW 74
15215: PPUSH
15216: LD_INT 1
15218: PPUSH
15219: CALL 10047 0 1
15223: PUSH
15224: LD_INT 1
15226: ARRAY
15227: PPUSH
15228: CALL_OW 296
15232: PUSH
15233: LD_INT 7
15235: LESS
15236: IFFALSE 15163
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15238: LD_INT 1
15240: PPUSH
15241: CALL 10047 0 1
15245: PUSH
15246: LD_INT 1
15248: ARRAY
15249: PPUSH
15250: LD_STRING DR-A-1
15252: PPUSH
15253: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15257: LD_INT 1
15259: PPUSH
15260: CALL 10047 0 1
15264: PUSH
15265: LD_INT 2
15267: ARRAY
15268: PPUSH
15269: LD_STRING DR-B-1
15271: PPUSH
15272: CALL_OW 88
// Wait ( 3 3$00 ) ;
15276: LD_INT 6300
15278: PPUSH
15279: CALL_OW 67
// ru_spotted := true ;
15283: LD_ADDR_EXP 15
15287: PUSH
15288: LD_INT 1
15290: ST_TO_ADDR
// end ;
15291: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15292: LD_INT 35
15294: PPUSH
15295: CALL_OW 300
15299: NOT
15300: IFFALSE 15324
15302: GO 15304
15304: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15305: LD_INT 1
15307: PPUSH
15308: CALL 10047 0 1
15312: PUSH
15313: LD_INT 1
15315: ARRAY
15316: PPUSH
15317: LD_STRING DDR-A-1
15319: PPUSH
15320: CALL_OW 88
15324: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15325: LD_INT 1
15327: PPUSH
15328: LD_INT 30
15330: PPUSH
15331: CALL 6155 0 2
15335: IFFALSE 15417
15337: GO 15339
15339: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15340: LD_INT 35
15342: PPUSH
15343: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15347: LD_INT 1
15349: PPUSH
15350: LD_INT 30
15352: PPUSH
15353: CALL 6155 0 2
15357: PUSH
15358: LD_INT 1
15360: ARRAY
15361: PPUSH
15362: CALL_OW 461
15366: PUSH
15367: LD_INT 1
15369: NONEQUAL
15370: IFFALSE 15340
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15372: LD_INT 1
15374: PPUSH
15375: CALL 10047 0 1
15379: PUSH
15380: LD_INT 1
15382: ARRAY
15383: PPUSH
15384: LD_STRING D8-A-1
15386: PPUSH
15387: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
15391: LD_INT 1
15393: PPUSH
15394: CALL 10047 0 1
15398: PUSH
15399: LD_INT 2
15401: ARRAY
15402: PPUSH
15403: LD_STRING D8-B-1
15405: PPUSH
15406: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
15410: LD_STRING M_mineok
15412: PPUSH
15413: CALL_OW 337
// end ;
15417: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
15418: LD_INT 22
15420: PUSH
15421: LD_INT 1
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: LD_INT 30
15430: PUSH
15431: LD_INT 0
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PUSH
15438: LD_INT 3
15440: PUSH
15441: LD_INT 57
15443: PUSH
15444: EMPTY
15445: LIST
15446: PUSH
15447: EMPTY
15448: LIST
15449: LIST
15450: PUSH
15451: EMPTY
15452: LIST
15453: LIST
15454: LIST
15455: PPUSH
15456: CALL_OW 69
15460: PUSH
15461: LD_INT 1
15463: GREATER
15464: PUSH
15465: LD_INT 22
15467: PUSH
15468: LD_INT 1
15470: PUSH
15471: EMPTY
15472: LIST
15473: LIST
15474: PUSH
15475: LD_INT 30
15477: PUSH
15478: LD_INT 0
15480: PUSH
15481: EMPTY
15482: LIST
15483: LIST
15484: PUSH
15485: LD_INT 3
15487: PUSH
15488: LD_INT 57
15490: PUSH
15491: EMPTY
15492: LIST
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: LIST
15502: PPUSH
15503: CALL_OW 69
15507: PUSH
15508: LD_INT 1
15510: EQUAL
15511: PUSH
15512: LD_INT 35
15514: PPUSH
15515: CALL_OW 300
15519: NOT
15520: AND
15521: OR
15522: IFFALSE 15574
15524: GO 15526
15526: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
15527: LD_INT 22
15529: PUSH
15530: LD_INT 1
15532: PUSH
15533: EMPTY
15534: LIST
15535: LIST
15536: PUSH
15537: LD_INT 25
15539: PUSH
15540: LD_INT 2
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PPUSH
15551: CALL_OW 69
15555: PUSH
15556: LD_INT 1
15558: ARRAY
15559: PPUSH
15560: LD_STRING D7-A-1
15562: PPUSH
15563: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
15567: LD_STRING M_baseok
15569: PPUSH
15570: CALL_OW 337
// end ;
15574: END
// every 0 0$01 trigger mine_ck do
15575: LD_EXP 34
15579: IFFALSE 15610
15581: GO 15583
15583: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
15584: LD_INT 1
15586: PPUSH
15587: CALL 10047 0 1
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: LD_STRING D9-A-1
15598: PPUSH
15599: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
15603: LD_STRING M_minedest
15605: PPUSH
15606: CALL_OW 337
// end ;
15610: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
15611: LD_EXP 28
15615: IFFALSE 16121
15617: GO 15619
15619: DISABLE
15620: LD_INT 0
15622: PPUSH
15623: PPUSH
15624: PPUSH
15625: PPUSH
15626: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
15627: LD_OWVAR 67
15631: PPUSH
15632: CALL 11948 0 1
// if not helps_can_arrive then
15636: LD_EXP 30
15640: NOT
15641: IFFALSE 15669
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
15643: LD_EXP 39
15647: PUSH
15648: LD_INT 1
15650: ARRAY
15651: PPUSH
15652: LD_STRING DB-Delay
15654: PPUSH
15655: CALL_OW 94
// time := 10 10$00 ;
15659: LD_ADDR_VAR 0 1
15663: PUSH
15664: LD_INT 21000
15666: ST_TO_ADDR
// end else
15667: GO 15677
// time := 3 3$00 ;
15669: LD_ADDR_VAR 0 1
15673: PUSH
15674: LD_INT 6300
15676: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
15677: LD_ADDR_VAR 0 1
15681: PUSH
15682: LD_VAR 0 1
15686: PUSH
15687: LD_INT 35
15689: MINUS
15690: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
15691: LD_INT 35
15693: PPUSH
15694: CALL_OW 67
// end until time = 0 0$00 ;
15698: LD_VAR 0 1
15702: PUSH
15703: LD_INT 0
15705: EQUAL
15706: IFFALSE 15677
// helps_arrive := true ;
15708: LD_ADDR_EXP 29
15712: PUSH
15713: LD_INT 1
15715: ST_TO_ADDR
// if IsLive ( guyA ) then
15716: LD_EXP 37
15720: PPUSH
15721: CALL_OW 300
15725: IFFALSE 15739
// r := guyA else
15727: LD_ADDR_VAR 0 4
15731: PUSH
15732: LD_EXP 37
15736: ST_TO_ADDR
15737: GO 15749
// r := guyB ;
15739: LD_ADDR_VAR 0 4
15743: PUSH
15744: LD_EXP 38
15748: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
15749: LD_EXP 39
15753: PUSH
15754: LD_INT 1
15756: ARRAY
15757: PPUSH
15758: LD_STRING D2-A-1
15760: PPUSH
15761: CALL_OW 94
// Say ( r , D2-B-1 ) ;
15765: LD_VAR 0 4
15769: PPUSH
15770: LD_STRING D2-B-1
15772: PPUSH
15773: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
15777: LD_EXP 39
15781: PUSH
15782: LD_INT 1
15784: ARRAY
15785: PPUSH
15786: LD_STRING D2-A-2
15788: PPUSH
15789: CALL_OW 94
// Say ( r , D2-B-2 ) ;
15793: LD_VAR 0 4
15797: PPUSH
15798: LD_STRING D2-B-2
15800: PPUSH
15801: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
15805: LD_EXP 39
15809: PUSH
15810: LD_INT 1
15812: ARRAY
15813: PPUSH
15814: LD_STRING D2-A-3
15816: PPUSH
15817: CALL_OW 94
// Say ( r , D2-B-3 ) ;
15821: LD_VAR 0 4
15825: PPUSH
15826: LD_STRING D2-B-3
15828: PPUSH
15829: CALL_OW 88
// to_veh := [ ] ;
15833: LD_ADDR_VAR 0 5
15837: PUSH
15838: EMPTY
15839: ST_TO_ADDR
// for i = 1 to Beta_Squad do
15840: LD_ADDR_VAR 0 2
15844: PUSH
15845: DOUBLE
15846: LD_INT 1
15848: DEC
15849: ST_TO_ADDR
15850: LD_EXP 39
15854: PUSH
15855: FOR_TO
15856: IFFALSE 16119
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
15858: LD_EXP 39
15862: PUSH
15863: LD_VAR 0 2
15867: ARRAY
15868: PPUSH
15869: CALL_OW 110
15873: PUSH
15874: LD_INT 3
15876: EQUAL
15877: IFFALSE 15903
// to_veh := to_veh ^ Beta_Squad [ i ] else
15879: LD_ADDR_VAR 0 5
15883: PUSH
15884: LD_VAR 0 5
15888: PUSH
15889: LD_EXP 39
15893: PUSH
15894: LD_VAR 0 2
15898: ARRAY
15899: ADD
15900: ST_TO_ADDR
15901: GO 16028
// if GetTag ( Beta_Squad [ i ] ) = 5 then
15903: LD_EXP 39
15907: PUSH
15908: LD_VAR 0 2
15912: ARRAY
15913: PPUSH
15914: CALL_OW 110
15918: PUSH
15919: LD_INT 5
15921: EQUAL
15922: IFFALSE 16007
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
15924: LD_EXP 39
15928: PUSH
15929: LD_VAR 0 2
15933: ARRAY
15934: PPUSH
15935: LD_INT 4
15937: PPUSH
15938: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
15942: LD_EXP 39
15946: PUSH
15947: LD_VAR 0 2
15951: ARRAY
15952: PPUSH
15953: LD_INT 5
15955: PPUSH
15956: LD_INT 0
15958: PPUSH
15959: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
15963: LD_VAR 0 5
15967: PUSH
15968: LD_INT 1
15970: ARRAY
15971: PPUSH
15972: LD_EXP 39
15976: PUSH
15977: LD_VAR 0 2
15981: ARRAY
15982: PPUSH
15983: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
15987: LD_ADDR_VAR 0 5
15991: PUSH
15992: LD_VAR 0 5
15996: PPUSH
15997: LD_INT 1
15999: PPUSH
16000: CALL_OW 3
16004: ST_TO_ADDR
// end else
16005: GO 16028
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16007: LD_EXP 39
16011: PUSH
16012: LD_VAR 0 2
16016: ARRAY
16017: PPUSH
16018: LD_INT 5
16020: PPUSH
16021: LD_INT 0
16023: PPUSH
16024: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16028: LD_EXP 39
16032: PUSH
16033: LD_VAR 0 2
16037: ARRAY
16038: PPUSH
16039: LD_INT 165
16041: PPUSH
16042: LD_INT 105
16044: PPUSH
16045: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16049: LD_INT 70
16051: PPUSH
16052: LD_INT 140
16054: PPUSH
16055: CALL_OW 12
16059: PPUSH
16060: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16064: LD_EXP 39
16068: PUSH
16069: LD_VAR 0 2
16073: ARRAY
16074: PPUSH
16075: LD_INT 1
16077: PPUSH
16078: CALL_OW 235
// if i = 1 then
16082: LD_VAR 0 2
16086: PUSH
16087: LD_INT 1
16089: EQUAL
16090: IFFALSE 16102
// CenterNowOnXY ( 168 , 109 ) ;
16092: LD_INT 168
16094: PPUSH
16095: LD_INT 109
16097: PPUSH
16098: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16102: LD_EXP 39
16106: PUSH
16107: LD_VAR 0 2
16111: ARRAY
16112: PPUSH
16113: CALL_OW 141
// end ;
16117: GO 15855
16119: POP
16120: POP
// end ;
16121: PPOPN 5
16123: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16124: LD_EXP 29
16128: IFFALSE 17157
16130: GO 16132
16132: DISABLE
16133: LD_INT 0
16135: PPUSH
16136: PPUSH
// begin Wait ( 5 5$00 ) ;
16137: LD_INT 10500
16139: PPUSH
16140: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16144: LD_OWVAR 67
16148: PPUSH
16149: CALL 12637 0 1
// to_veh := [ ] ;
16153: LD_ADDR_VAR 0 2
16157: PUSH
16158: EMPTY
16159: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16160: LD_ADDR_VAR 0 1
16164: PUSH
16165: DOUBLE
16166: LD_INT 1
16168: DEC
16169: ST_TO_ADDR
16170: LD_EXP 40
16174: PUSH
16175: FOR_TO
16176: IFFALSE 16404
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16178: LD_EXP 40
16182: PUSH
16183: LD_VAR 0 1
16187: ARRAY
16188: PPUSH
16189: CALL_OW 110
16193: PUSH
16194: LD_INT 3
16196: EQUAL
16197: IFFALSE 16223
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16199: LD_ADDR_VAR 0 2
16203: PUSH
16204: LD_VAR 0 2
16208: PUSH
16209: LD_EXP 40
16213: PUSH
16214: LD_VAR 0 1
16218: ARRAY
16219: ADD
16220: ST_TO_ADDR
16221: GO 16348
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16223: LD_EXP 40
16227: PUSH
16228: LD_VAR 0 1
16232: ARRAY
16233: PPUSH
16234: CALL_OW 110
16238: PUSH
16239: LD_INT 5
16241: EQUAL
16242: IFFALSE 16327
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16244: LD_EXP 40
16248: PUSH
16249: LD_VAR 0 1
16253: ARRAY
16254: PPUSH
16255: LD_INT 4
16257: PPUSH
16258: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16262: LD_EXP 40
16266: PUSH
16267: LD_VAR 0 1
16271: ARRAY
16272: PPUSH
16273: LD_INT 5
16275: PPUSH
16276: LD_INT 0
16278: PPUSH
16279: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16283: LD_VAR 0 2
16287: PUSH
16288: LD_INT 1
16290: ARRAY
16291: PPUSH
16292: LD_EXP 40
16296: PUSH
16297: LD_VAR 0 1
16301: ARRAY
16302: PPUSH
16303: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16307: LD_ADDR_VAR 0 2
16311: PUSH
16312: LD_VAR 0 2
16316: PPUSH
16317: LD_INT 1
16319: PPUSH
16320: CALL_OW 3
16324: ST_TO_ADDR
// end else
16325: GO 16348
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16327: LD_EXP 40
16331: PUSH
16332: LD_VAR 0 1
16336: ARRAY
16337: PPUSH
16338: LD_INT 5
16340: PPUSH
16341: LD_INT 0
16343: PPUSH
16344: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16348: LD_EXP 40
16352: PUSH
16353: LD_VAR 0 1
16357: ARRAY
16358: PPUSH
16359: LD_INT 164
16361: PPUSH
16362: LD_INT 104
16364: PPUSH
16365: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16369: LD_INT 70
16371: PPUSH
16372: LD_INT 140
16374: PPUSH
16375: CALL_OW 12
16379: PPUSH
16380: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16384: LD_EXP 40
16388: PUSH
16389: LD_VAR 0 1
16393: ARRAY
16394: PPUSH
16395: LD_INT 1
16397: PPUSH
16398: CALL_OW 235
// end ;
16402: GO 16175
16404: POP
16405: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
16406: LD_EXP 40
16410: PUSH
16411: LD_INT 1
16413: ARRAY
16414: PPUSH
16415: LD_STRING D3-A-1
16417: PPUSH
16418: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
16422: LD_INT 1
16424: PPUSH
16425: CALL 10047 0 1
16429: PUSH
16430: LD_INT 1
16432: ARRAY
16433: PPUSH
16434: LD_STRING D3-B-1
16436: PPUSH
16437: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
16441: LD_EXP 40
16445: PUSH
16446: LD_INT 1
16448: ARRAY
16449: PPUSH
16450: LD_STRING D3-A-2
16452: PPUSH
16453: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
16457: LD_INT 1
16459: PPUSH
16460: CALL 10047 0 1
16464: PUSH
16465: LD_INT 1
16467: ARRAY
16468: PPUSH
16469: LD_STRING D3-B-2
16471: PPUSH
16472: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
16476: LD_EXP 40
16480: PUSH
16481: LD_INT 1
16483: ARRAY
16484: PPUSH
16485: LD_STRING D3-A-3
16487: PPUSH
16488: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
16492: LD_INT 1
16494: PPUSH
16495: CALL 10047 0 1
16499: PUSH
16500: LD_INT 1
16502: ARRAY
16503: PPUSH
16504: LD_STRING D3-B-3
16506: PPUSH
16507: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
16511: LD_EXP 40
16515: PUSH
16516: LD_INT 1
16518: ARRAY
16519: PPUSH
16520: LD_STRING D3-A-4
16522: PPUSH
16523: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
16527: LD_INT 1
16529: PPUSH
16530: CALL 10047 0 1
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_STRING D3-B-4
16541: PPUSH
16542: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
16546: LD_EXP 40
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_STRING D3-A-5
16557: PPUSH
16558: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
16562: LD_INT 1
16564: PPUSH
16565: CALL 10047 0 1
16569: PUSH
16570: LD_INT 1
16572: ARRAY
16573: PPUSH
16574: LD_STRING D3-B-5
16576: PPUSH
16577: CALL_OW 88
// for i = 1 to Gamma_Squad do
16581: LD_ADDR_VAR 0 1
16585: PUSH
16586: DOUBLE
16587: LD_INT 1
16589: DEC
16590: ST_TO_ADDR
16591: LD_EXP 40
16595: PUSH
16596: FOR_TO
16597: IFFALSE 16619
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
16599: LD_EXP 40
16603: PUSH
16604: LD_VAR 0 1
16608: ARRAY
16609: PPUSH
16610: LD_INT 1
16612: PPUSH
16613: CALL_OW 235
16617: GO 16596
16619: POP
16620: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
16621: LD_INT 6300
16623: PUSH
16624: LD_INT 10500
16626: PUSH
16627: LD_INT 11550
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: LIST
16634: PUSH
16635: LD_OWVAR 67
16639: ARRAY
16640: PPUSH
16641: CALL_OW 67
// AddZetaSquad ;
16645: CALL 13366 0 0
// Wait ( 0 0$10 ) ;
16649: LD_INT 350
16651: PPUSH
16652: CALL_OW 67
// to_veh := [ ] ;
16656: LD_ADDR_VAR 0 2
16660: PUSH
16661: EMPTY
16662: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
16663: LD_ADDR_VAR 0 1
16667: PUSH
16668: DOUBLE
16669: LD_INT 1
16671: DEC
16672: ST_TO_ADDR
16673: LD_EXP 41
16677: PUSH
16678: FOR_TO
16679: IFFALSE 16889
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
16681: LD_EXP 41
16685: PUSH
16686: LD_VAR 0 1
16690: ARRAY
16691: PPUSH
16692: CALL_OW 110
16696: PUSH
16697: LD_INT 3
16699: EQUAL
16700: IFFALSE 16726
// to_veh := to_veh ^ Zeta_Squad [ i ] else
16702: LD_ADDR_VAR 0 2
16706: PUSH
16707: LD_VAR 0 2
16711: PUSH
16712: LD_EXP 41
16716: PUSH
16717: LD_VAR 0 1
16721: ARRAY
16722: ADD
16723: ST_TO_ADDR
16724: GO 16851
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
16726: LD_EXP 41
16730: PUSH
16731: LD_VAR 0 1
16735: ARRAY
16736: PPUSH
16737: CALL_OW 110
16741: PUSH
16742: LD_INT 5
16744: EQUAL
16745: IFFALSE 16830
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
16747: LD_EXP 41
16751: PUSH
16752: LD_VAR 0 1
16756: ARRAY
16757: PPUSH
16758: LD_INT 4
16760: PPUSH
16761: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
16765: LD_EXP 41
16769: PUSH
16770: LD_VAR 0 1
16774: ARRAY
16775: PPUSH
16776: LD_INT 5
16778: PPUSH
16779: LD_INT 0
16781: PPUSH
16782: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
16786: LD_VAR 0 2
16790: PUSH
16791: LD_INT 1
16793: ARRAY
16794: PPUSH
16795: LD_EXP 41
16799: PUSH
16800: LD_VAR 0 1
16804: ARRAY
16805: PPUSH
16806: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16810: LD_ADDR_VAR 0 2
16814: PUSH
16815: LD_VAR 0 2
16819: PPUSH
16820: LD_INT 1
16822: PPUSH
16823: CALL_OW 3
16827: ST_TO_ADDR
// end else
16828: GO 16851
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
16830: LD_EXP 41
16834: PUSH
16835: LD_VAR 0 1
16839: ARRAY
16840: PPUSH
16841: LD_INT 5
16843: PPUSH
16844: LD_INT 0
16846: PPUSH
16847: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
16851: LD_EXP 41
16855: PUSH
16856: LD_VAR 0 1
16860: ARRAY
16861: PPUSH
16862: LD_INT 165
16864: PPUSH
16865: LD_INT 105
16867: PPUSH
16868: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16872: LD_INT 70
16874: PPUSH
16875: LD_INT 140
16877: PPUSH
16878: CALL_OW 12
16882: PPUSH
16883: CALL_OW 67
// end ;
16887: GO 16678
16889: POP
16890: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
16891: LD_EXP 41
16895: PUSH
16896: LD_INT 1
16898: ARRAY
16899: PPUSH
16900: LD_STRING D4-A-1
16902: PPUSH
16903: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
16907: LD_INT 1
16909: PPUSH
16910: CALL 10047 0 1
16914: PUSH
16915: LD_INT 1
16917: ARRAY
16918: PPUSH
16919: LD_STRING D4-B-1
16921: PPUSH
16922: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
16926: LD_EXP 41
16930: PUSH
16931: LD_INT 1
16933: ARRAY
16934: PPUSH
16935: LD_STRING D4-A-2
16937: PPUSH
16938: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
16942: LD_INT 1
16944: PPUSH
16945: CALL 10047 0 1
16949: PUSH
16950: LD_INT 1
16952: ARRAY
16953: PPUSH
16954: LD_STRING D4-B-2
16956: PPUSH
16957: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
16961: LD_EXP 41
16965: PUSH
16966: LD_INT 1
16968: ARRAY
16969: PPUSH
16970: LD_STRING D4-A-3
16972: PPUSH
16973: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
16977: LD_INT 1
16979: PPUSH
16980: CALL 10047 0 1
16984: PUSH
16985: LD_INT 1
16987: ARRAY
16988: PPUSH
16989: LD_STRING D4-B-3
16991: PPUSH
16992: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
16996: LD_EXP 41
17000: PUSH
17001: LD_INT 1
17003: ARRAY
17004: PPUSH
17005: LD_STRING D4-A-4
17007: PPUSH
17008: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17012: LD_INT 1
17014: PPUSH
17015: CALL 10047 0 1
17019: PUSH
17020: LD_INT 1
17022: ARRAY
17023: PPUSH
17024: LD_STRING D4-B-4
17026: PPUSH
17027: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17031: LD_EXP 41
17035: PUSH
17036: LD_INT 1
17038: ARRAY
17039: PPUSH
17040: LD_STRING D4-A-5
17042: PPUSH
17043: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17047: LD_INT 1
17049: PPUSH
17050: CALL 10047 0 1
17054: PUSH
17055: LD_INT 1
17057: ARRAY
17058: PPUSH
17059: LD_STRING D4-B-5
17061: PPUSH
17062: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17066: LD_EXP 41
17070: PUSH
17071: LD_INT 1
17073: ARRAY
17074: PPUSH
17075: LD_STRING D4-A-6
17077: PPUSH
17078: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17082: LD_INT 1
17084: PPUSH
17085: CALL 10047 0 1
17089: PUSH
17090: LD_INT 1
17092: ARRAY
17093: PPUSH
17094: LD_STRING D4-B-6
17096: PPUSH
17097: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17101: LD_EXP 41
17105: PUSH
17106: LD_INT 1
17108: ARRAY
17109: PPUSH
17110: LD_STRING D4-A-7
17112: PPUSH
17113: CALL_OW 94
// for i = 1 to Zeta_Squad do
17117: LD_ADDR_VAR 0 1
17121: PUSH
17122: DOUBLE
17123: LD_INT 1
17125: DEC
17126: ST_TO_ADDR
17127: LD_EXP 41
17131: PUSH
17132: FOR_TO
17133: IFFALSE 17155
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17135: LD_EXP 41
17139: PUSH
17140: LD_VAR 0 1
17144: ARRAY
17145: PPUSH
17146: LD_INT 1
17148: PPUSH
17149: CALL_OW 235
17153: GO 17132
17155: POP
17156: POP
// end ;
17157: PPOPN 2
17159: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17160: LD_INT 11
17162: PPUSH
17163: LD_INT 22
17165: PUSH
17166: LD_OWVAR 2
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PPUSH
17175: CALL_OW 70
17179: PUSH
17180: LD_INT 0
17182: GREATER
17183: IFFALSE 17208
17185: GO 17187
17187: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17188: LD_EXP 37
17192: PPUSH
17193: LD_STRING D10-A-1
17195: PPUSH
17196: CALL_OW 88
// ru_spotted := true ;
17200: LD_ADDR_EXP 15
17204: PUSH
17205: LD_INT 1
17207: ST_TO_ADDR
// end ;
17208: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17209: LD_EXP 37
17213: PPUSH
17214: CALL_OW 301
17218: PUSH
17219: LD_EXP 38
17223: PPUSH
17224: CALL_OW 301
17228: OR
17229: IFFALSE 17241
17231: GO 17233
17233: DISABLE
// begin YouLost ( DieP ) ;
17234: LD_STRING DieP
17236: PPUSH
17237: CALL_OW 104
// end ;
17241: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17242: LD_INT 34
17244: PUSH
17245: LD_INT 8
17247: PUSH
17248: EMPTY
17249: LIST
17250: LIST
17251: PPUSH
17252: CALL_OW 69
17256: IFFALSE 17269
17258: GO 17260
17260: DISABLE
// sib_bomb_constructed := true ;
17261: LD_ADDR_EXP 35
17265: PUSH
17266: LD_INT 1
17268: ST_TO_ADDR
17269: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17270: LD_EXP 28
17274: PUSH
17275: LD_INT 22
17277: PUSH
17278: LD_INT 3
17280: PUSH
17281: EMPTY
17282: LIST
17283: LIST
17284: PPUSH
17285: CALL_OW 69
17289: PUSH
17290: LD_INT 0
17292: EQUAL
17293: AND
17294: IFFALSE 17483
17296: GO 17298
17298: DISABLE
17299: LD_INT 0
17301: PPUSH
// begin game_status := false ;
17302: LD_ADDR_EXP 28
17306: PUSH
17307: LD_INT 0
17309: ST_TO_ADDR
// if Difficulty = 3 then
17310: LD_OWVAR 67
17314: PUSH
17315: LD_INT 3
17317: EQUAL
17318: IFFALSE 17327
// SetAchievement ( ACH_HARD ) ;
17320: LD_STRING ACH_HARD
17322: PPUSH
17323: CALL_OW 543
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17327: LD_OWVAR 1
17331: PUSH
17332: LD_INT 35
17334: DIVREAL
17335: PUSH
17336: LD_INT 60
17338: DIVREAL
17339: PUSH
17340: LD_INT 70
17342: PUSH
17343: LD_INT 60
17345: PUSH
17346: LD_INT 50
17348: PUSH
17349: EMPTY
17350: LIST
17351: LIST
17352: LIST
17353: PUSH
17354: LD_OWVAR 67
17358: ARRAY
17359: LESS
17360: IFFALSE 17374
// AddMedal ( play , 1 ) else
17362: LD_STRING play
17364: PPUSH
17365: LD_INT 1
17367: PPUSH
17368: CALL_OW 101
17372: GO 17385
// AddMedal ( play , - 1 ) ;
17374: LD_STRING play
17376: PPUSH
17377: LD_INT 1
17379: NEG
17380: PPUSH
17381: CALL_OW 101
// if sib_bomb_constructed then
17385: LD_EXP 35
17389: IFFALSE 17403
// AddMedal ( sibbomb , 1 ) else
17391: LD_STRING sibbomb
17393: PPUSH
17394: LD_INT 1
17396: PPUSH
17397: CALL_OW 101
17401: GO 17414
// AddMedal ( sibbomb , - 1 ) ;
17403: LD_STRING sibbomb
17405: PPUSH
17406: LD_INT 1
17408: NEG
17409: PPUSH
17410: CALL_OW 101
// if mine_constructed and not mine_ck then
17414: LD_EXP 36
17418: PUSH
17419: LD_EXP 34
17423: NOT
17424: AND
17425: IFFALSE 17437
// AddMedal ( mine , 1 ) ;
17427: LD_STRING mine
17429: PPUSH
17430: LD_INT 1
17432: PPUSH
17433: CALL_OW 101
// if mine_ck then
17437: LD_EXP 34
17441: IFFALSE 17454
// AddMedal ( mine , - 1 ) ;
17443: LD_STRING mine
17445: PPUSH
17446: LD_INT 1
17448: NEG
17449: PPUSH
17450: CALL_OW 101
// if not mine_constructed then
17454: LD_EXP 36
17458: NOT
17459: IFFALSE 17472
// AddMedal ( mine , - 2 ) ;
17461: LD_STRING mine
17463: PPUSH
17464: LD_INT 2
17466: NEG
17467: PPUSH
17468: CALL_OW 101
// GiveMedals ( Main ) ;
17472: LD_STRING Main
17474: PPUSH
17475: CALL_OW 102
// YouWin ;
17479: CALL_OW 103
// end ; end_of_file
17483: PPOPN 1
17485: END
// every 0 0$03 trigger game_status do var time ;
17486: LD_EXP 28
17490: IFFALSE 17655
17492: GO 17494
17494: DISABLE
17495: LD_INT 0
17497: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
17498: LD_ADDR_VAR 0 1
17502: PUSH
17503: LD_INT 1050
17505: PUSH
17506: LD_INT 1575
17508: PUSH
17509: LD_INT 2100
17511: PUSH
17512: EMPTY
17513: LIST
17514: LIST
17515: LIST
17516: PUSH
17517: LD_OWVAR 67
17521: ARRAY
17522: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
17523: LD_VAR 0 1
17527: PUSH
17528: LD_INT 0
17530: PPUSH
17531: LD_INT 420
17533: PPUSH
17534: CALL_OW 12
17538: PLUS
17539: PPUSH
17540: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
17544: LD_INT 1
17546: PPUSH
17547: LD_INT 5
17549: PPUSH
17550: CALL_OW 12
17554: PPUSH
17555: LD_INT 1
17557: PPUSH
17558: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
17562: LD_INT 105
17564: PPUSH
17565: LD_INT 1050
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 148
17590: PPUSH
17591: LD_INT 107
17593: PPUSH
17594: LD_INT 20
17596: PPUSH
17597: LD_INT 1
17599: PPUSH
17600: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
17604: LD_OWVAR 1
17608: PUSH
17609: LD_INT 44100
17611: PUSH
17612: LD_INT 37800
17614: PUSH
17615: LD_INT 33600
17617: PUSH
17618: EMPTY
17619: LIST
17620: LIST
17621: LIST
17622: PUSH
17623: LD_OWVAR 67
17627: ARRAY
17628: MOD
17629: IFFALSE 17645
// time := time + 0 0$20 ;
17631: LD_ADDR_VAR 0 1
17635: PUSH
17636: LD_VAR 0 1
17640: PUSH
17641: LD_INT 700
17643: PLUS
17644: ST_TO_ADDR
// end until game_status = false ;
17645: LD_EXP 28
17649: PUSH
17650: LD_INT 0
17652: EQUAL
17653: IFFALSE 17523
// end ;
17655: PPOPN 1
17657: END
// every 0 0$03 trigger game_status do var time ;
17658: LD_EXP 28
17662: IFFALSE 17816
17664: GO 17666
17666: DISABLE
17667: LD_INT 0
17669: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
17670: LD_ADDR_VAR 0 1
17674: PUSH
17675: LD_INT 700
17677: PUSH
17678: LD_INT 875
17680: PUSH
17681: LD_INT 1400
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: LIST
17688: PUSH
17689: LD_OWVAR 67
17693: ARRAY
17694: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
17695: LD_VAR 0 1
17699: PUSH
17700: LD_INT 0
17702: PPUSH
17703: LD_INT 385
17705: PPUSH
17706: CALL_OW 12
17710: PLUS
17711: PPUSH
17712: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
17716: LD_INT 1
17718: PPUSH
17719: LD_INT 5
17721: PPUSH
17722: CALL_OW 12
17726: PPUSH
17727: LD_INT 102
17729: PPUSH
17730: LD_INT 6
17732: PPUSH
17733: LD_INT 25
17735: PPUSH
17736: LD_INT 1
17738: PPUSH
17739: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
17743: LD_OWVAR 1
17747: PUSH
17748: LD_INT 52500
17750: PUSH
17751: LD_INT 46200
17753: PUSH
17754: LD_INT 42000
17756: PUSH
17757: EMPTY
17758: LIST
17759: LIST
17760: LIST
17761: PUSH
17762: LD_OWVAR 67
17766: ARRAY
17767: MOD
17768: IFFALSE 17784
// time := time + 0 0$25 ;
17770: LD_ADDR_VAR 0 1
17774: PUSH
17775: LD_VAR 0 1
17779: PUSH
17780: LD_INT 875
17782: PLUS
17783: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
17784: LD_OWVAR 1
17788: PUSH
17789: LD_INT 231000
17791: MOD
17792: PUSH
17793: LD_INT 0
17795: EQUAL
17796: IFFALSE 17806
// time := 0 0$30 ;
17798: LD_ADDR_VAR 0 1
17802: PUSH
17803: LD_INT 1050
17805: ST_TO_ADDR
// end until game_status = false ;
17806: LD_EXP 28
17810: PUSH
17811: LD_INT 0
17813: EQUAL
17814: IFFALSE 17695
// end ;
17816: PPOPN 1
17818: END
// every 0 0$03 trigger game_status do var time ;
17819: LD_EXP 28
17823: IFFALSE 17959
17825: GO 17827
17827: DISABLE
17828: LD_INT 0
17830: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
17831: LD_ADDR_VAR 0 1
17835: PUSH
17836: LD_INT 1050
17838: PUSH
17839: LD_INT 1575
17841: PUSH
17842: LD_INT 1750
17844: PUSH
17845: EMPTY
17846: LIST
17847: LIST
17848: LIST
17849: PUSH
17850: LD_OWVAR 67
17854: ARRAY
17855: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
17856: LD_VAR 0 1
17860: PUSH
17861: LD_INT 0
17863: PPUSH
17864: LD_INT 385
17866: PPUSH
17867: CALL_OW 12
17871: PLUS
17872: PPUSH
17873: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
17877: LD_INT 1
17879: PPUSH
17880: LD_INT 5
17882: PPUSH
17883: CALL_OW 12
17887: PPUSH
17888: LD_INT 51
17890: PPUSH
17891: LD_INT 74
17893: PPUSH
17894: LD_INT 25
17896: PPUSH
17897: LD_INT 1
17899: PPUSH
17900: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
17904: LD_OWVAR 1
17908: PUSH
17909: LD_INT 84000
17911: PUSH
17912: LD_INT 105000
17914: PUSH
17915: LD_INT 136500
17917: PUSH
17918: EMPTY
17919: LIST
17920: LIST
17921: LIST
17922: PUSH
17923: LD_OWVAR 67
17927: ARRAY
17928: MOD
17929: PUSH
17930: LD_INT 0
17932: EQUAL
17933: IFFALSE 17949
// time := time + 0 0$15 ;
17935: LD_ADDR_VAR 0 1
17939: PUSH
17940: LD_VAR 0 1
17944: PUSH
17945: LD_INT 525
17947: PLUS
17948: ST_TO_ADDR
// end until game_status = false ;
17949: LD_EXP 28
17953: PUSH
17954: LD_INT 0
17956: EQUAL
17957: IFFALSE 17856
// end ; end_of_file
17959: PPOPN 1
17961: END
// every 0 0$01 trigger not debug do
17962: LD_EXP 1
17966: NOT
17967: IFFALSE 17990
17969: GO 17971
17971: DISABLE
// begin enable ;
17972: ENABLE
// Display_Strings := [ #tick , tick ] ;
17973: LD_ADDR_OWVAR 47
17977: PUSH
17978: LD_STRING #tick
17980: PUSH
17981: LD_OWVAR 1
17985: PUSH
17986: EMPTY
17987: LIST
17988: LIST
17989: ST_TO_ADDR
// end ; end_of_file
17990: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
17991: LD_VAR 0 1
17995: PPUSH
17996: CALL_OW 255
18000: PUSH
18001: LD_INT 3
18003: EQUAL
18004: PUSH
18005: LD_VAR 0 1
18009: PUSH
18010: LD_INT 2
18012: PUSH
18013: LD_INT 34
18015: PUSH
18016: LD_INT 46
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: PUSH
18023: LD_INT 34
18025: PUSH
18026: LD_INT 47
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: PUSH
18033: LD_INT 34
18035: PUSH
18036: LD_INT 45
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: PUSH
18049: EMPTY
18050: LIST
18051: PPUSH
18052: CALL_OW 69
18056: IN
18057: AND
18058: IFFALSE 18076
// ru_reserve := ru_reserve ^ un ;
18060: LD_ADDR_EXP 8
18064: PUSH
18065: LD_EXP 8
18069: PUSH
18070: LD_VAR 0 1
18074: ADD
18075: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
18076: LD_VAR 0 1
18080: PUSH
18081: LD_INT 22
18083: PUSH
18084: LD_INT 3
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: PUSH
18091: LD_INT 34
18093: PUSH
18094: LD_INT 48
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PUSH
18101: EMPTY
18102: LIST
18103: LIST
18104: PPUSH
18105: CALL_OW 69
18109: IN
18110: IFFALSE 18163
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
18112: LD_INT 12
18114: PPUSH
18115: LD_INT 22
18117: PUSH
18118: LD_INT 1
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PPUSH
18125: CALL_OW 70
18129: IFFALSE 18148
// ComAttackPlace ( un , 98 , 10 ) else
18131: LD_VAR 0 1
18135: PPUSH
18136: LD_INT 98
18138: PPUSH
18139: LD_INT 10
18141: PPUSH
18142: CALL_OW 116
18146: GO 18163
// ComAttackPlace ( un , 134 , 99 ) ;
18148: LD_VAR 0 1
18152: PPUSH
18153: LD_INT 134
18155: PPUSH
18156: LD_INT 99
18158: PPUSH
18159: CALL_OW 116
// end ;
18163: PPOPN 2
18165: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
18166: LD_VAR 0 1
18170: PPUSH
18171: CALL 29785 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
18175: LD_VAR 0 1
18179: PUSH
18180: LD_INT 22
18182: PUSH
18183: LD_INT 3
18185: PUSH
18186: EMPTY
18187: LIST
18188: LIST
18189: PUSH
18190: LD_INT 21
18192: PUSH
18193: LD_INT 3
18195: PUSH
18196: EMPTY
18197: LIST
18198: LIST
18199: PUSH
18200: EMPTY
18201: LIST
18202: LIST
18203: PPUSH
18204: CALL_OW 69
18208: IN
18209: PUSH
18210: LD_VAR 0 1
18214: PPUSH
18215: CALL_OW 266
18219: PUSH
18220: LD_INT 0
18222: PUSH
18223: LD_INT 29
18225: PUSH
18226: LD_INT 30
18228: PUSH
18229: LD_INT 26
18231: PUSH
18232: EMPTY
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: IN
18238: NOT
18239: AND
18240: IFFALSE 18326
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
18242: LD_ADDR_EXP 12
18246: PUSH
18247: LD_EXP 12
18251: PUSH
18252: LD_VAR 0 1
18256: PPUSH
18257: CALL_OW 266
18261: ADD
18262: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
18263: LD_ADDR_EXP 12
18267: PUSH
18268: LD_EXP 12
18272: PUSH
18273: LD_VAR 0 1
18277: PPUSH
18278: CALL_OW 250
18282: ADD
18283: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
18284: LD_ADDR_EXP 12
18288: PUSH
18289: LD_EXP 12
18293: PUSH
18294: LD_VAR 0 1
18298: PPUSH
18299: CALL_OW 251
18303: ADD
18304: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
18305: LD_ADDR_EXP 12
18309: PUSH
18310: LD_EXP 12
18314: PUSH
18315: LD_VAR 0 1
18319: PPUSH
18320: CALL_OW 254
18324: ADD
18325: ST_TO_ADDR
// end ; if un in ru_attack_list then
18326: LD_VAR 0 1
18330: PUSH
18331: LD_EXP 9
18335: IN
18336: IFFALSE 18354
// ru_attack_list := ru_attack_list diff un ;
18338: LD_ADDR_EXP 9
18342: PUSH
18343: LD_EXP 9
18347: PUSH
18348: LD_VAR 0 1
18352: DIFF
18353: ST_TO_ADDR
// if un in ru_protector then
18354: LD_VAR 0 1
18358: PUSH
18359: LD_EXP 16
18363: IN
18364: IFFALSE 18382
// ru_protector := ru_protector diff un ;
18366: LD_ADDR_EXP 16
18370: PUSH
18371: LD_EXP 16
18375: PUSH
18376: LD_VAR 0 1
18380: DIFF
18381: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
18382: LD_VAR 0 1
18386: PPUSH
18387: CALL_OW 266
18391: PUSH
18392: LD_INT 30
18394: EQUAL
18395: PUSH
18396: LD_VAR 0 1
18400: PPUSH
18401: CALL_OW 255
18405: PUSH
18406: LD_INT 1
18408: EQUAL
18409: AND
18410: IFFALSE 18420
// mine_ck := true ;
18412: LD_ADDR_EXP 34
18416: PUSH
18417: LD_INT 1
18419: ST_TO_ADDR
// end ;
18420: PPOPN 1
18422: END
// on BuildingComplete ( un ) do var i ;
18423: LD_INT 0
18425: PPUSH
// begin if GetSide ( un ) = 1 and GetBType ( un ) = b_siberite_mine then
18426: LD_VAR 0 1
18430: PPUSH
18431: CALL_OW 255
18435: PUSH
18436: LD_INT 1
18438: EQUAL
18439: PUSH
18440: LD_VAR 0 1
18444: PPUSH
18445: CALL_OW 266
18449: PUSH
18450: LD_INT 30
18452: EQUAL
18453: AND
18454: IFFALSE 18464
// mine_constructed := true ;
18456: LD_ADDR_EXP 36
18460: PUSH
18461: LD_INT 1
18463: ST_TO_ADDR
// if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
18464: LD_VAR 0 1
18468: PPUSH
18469: CALL_OW 255
18473: PUSH
18474: LD_INT 3
18476: EQUAL
18477: PUSH
18478: LD_VAR 0 1
18482: PPUSH
18483: CALL_OW 266
18487: PUSH
18488: LD_INT 0
18490: EQUAL
18491: AND
18492: IFFALSE 18549
// begin for i = 1 to 2 do
18494: LD_ADDR_VAR 0 2
18498: PUSH
18499: DOUBLE
18500: LD_INT 1
18502: DEC
18503: ST_TO_ADDR
18504: LD_INT 2
18506: PUSH
18507: FOR_TO
18508: IFFALSE 18547
// begin ComExitBuilding ( ru_sold [ i ] ) ;
18510: LD_EXP 19
18514: PUSH
18515: LD_VAR 0 2
18519: ARRAY
18520: PPUSH
18521: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
18525: LD_EXP 19
18529: PUSH
18530: LD_VAR 0 2
18534: ARRAY
18535: PPUSH
18536: LD_VAR 0 1
18540: PPUSH
18541: CALL_OW 180
// end ;
18545: GO 18507
18547: POP
18548: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
18549: LD_VAR 0 1
18553: PPUSH
18554: CALL_OW 255
18558: PUSH
18559: LD_INT 3
18561: EQUAL
18562: PUSH
18563: LD_VAR 0 1
18567: PPUSH
18568: CALL_OW 266
18572: PUSH
18573: LD_EXP 12
18577: IN
18578: AND
18579: IFFALSE 18619
// for i = 1 to 4 do
18581: LD_ADDR_VAR 0 2
18585: PUSH
18586: DOUBLE
18587: LD_INT 1
18589: DEC
18590: ST_TO_ADDR
18591: LD_INT 4
18593: PUSH
18594: FOR_TO
18595: IFFALSE 18617
// ru_blist := Delete ( ru_blist , 1 ) ;
18597: LD_ADDR_EXP 12
18601: PUSH
18602: LD_EXP 12
18606: PPUSH
18607: LD_INT 1
18609: PPUSH
18610: CALL_OW 3
18614: ST_TO_ADDR
18615: GO 18594
18617: POP
18618: POP
// end ;
18619: PPOPN 2
18621: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
18622: LD_VAR 0 1
18626: PPUSH
18627: LD_VAR 0 2
18631: PPUSH
18632: LD_VAR 0 3
18636: PPUSH
18637: CALL 29883 0 3
// end ;
18641: PPOPN 3
18643: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18644: LD_VAR 0 1
18648: PPUSH
18649: CALL 29891 0 1
// end ; end_of_file
18653: PPOPN 1
18655: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18656: GO 18658
18658: DISABLE
// begin ru_radar := 98 ;
18659: LD_ADDR_EXP 42
18663: PUSH
18664: LD_INT 98
18666: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18667: LD_ADDR_EXP 43
18671: PUSH
18672: LD_INT 89
18674: ST_TO_ADDR
// us_hack := 99 ;
18675: LD_ADDR_EXP 44
18679: PUSH
18680: LD_INT 99
18682: ST_TO_ADDR
// us_artillery := 97 ;
18683: LD_ADDR_EXP 45
18687: PUSH
18688: LD_INT 97
18690: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18691: LD_ADDR_EXP 46
18695: PUSH
18696: LD_INT 91
18698: ST_TO_ADDR
// tech_Artillery := 80 ;
18699: LD_ADDR_EXP 47
18703: PUSH
18704: LD_INT 80
18706: ST_TO_ADDR
// tech_RadMat := 81 ;
18707: LD_ADDR_EXP 48
18711: PUSH
18712: LD_INT 81
18714: ST_TO_ADDR
// tech_BasicTools := 82 ;
18715: LD_ADDR_EXP 49
18719: PUSH
18720: LD_INT 82
18722: ST_TO_ADDR
// tech_Cargo := 83 ;
18723: LD_ADDR_EXP 50
18727: PUSH
18728: LD_INT 83
18730: ST_TO_ADDR
// tech_Track := 84 ;
18731: LD_ADDR_EXP 51
18735: PUSH
18736: LD_INT 84
18738: ST_TO_ADDR
// tech_Crane := 85 ;
18739: LD_ADDR_EXP 52
18743: PUSH
18744: LD_INT 85
18746: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18747: LD_ADDR_EXP 53
18751: PUSH
18752: LD_INT 86
18754: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18755: LD_ADDR_EXP 54
18759: PUSH
18760: LD_INT 87
18762: ST_TO_ADDR
// end ; end_of_file end_of_file
18763: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18764: GO 18766
18766: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18767: LD_STRING initStreamRollete();
18769: PPUSH
18770: CALL_OW 559
// InitStreamMode ;
18774: CALL 18783 0 0
// DefineStreamItems ( ) ;
18778: CALL 19223 0 0
// end ;
18782: END
// function InitStreamMode ; begin
18783: LD_INT 0
18785: PPUSH
// streamModeActive := false ;
18786: LD_ADDR_EXP 55
18790: PUSH
18791: LD_INT 0
18793: ST_TO_ADDR
// normalCounter := 36 ;
18794: LD_ADDR_EXP 56
18798: PUSH
18799: LD_INT 36
18801: ST_TO_ADDR
// hardcoreCounter := 16 ;
18802: LD_ADDR_EXP 57
18806: PUSH
18807: LD_INT 16
18809: ST_TO_ADDR
// sRocket := false ;
18810: LD_ADDR_EXP 60
18814: PUSH
18815: LD_INT 0
18817: ST_TO_ADDR
// sSpeed := false ;
18818: LD_ADDR_EXP 59
18822: PUSH
18823: LD_INT 0
18825: ST_TO_ADDR
// sEngine := false ;
18826: LD_ADDR_EXP 61
18830: PUSH
18831: LD_INT 0
18833: ST_TO_ADDR
// sSpec := false ;
18834: LD_ADDR_EXP 58
18838: PUSH
18839: LD_INT 0
18841: ST_TO_ADDR
// sLevel := false ;
18842: LD_ADDR_EXP 62
18846: PUSH
18847: LD_INT 0
18849: ST_TO_ADDR
// sArmoury := false ;
18850: LD_ADDR_EXP 63
18854: PUSH
18855: LD_INT 0
18857: ST_TO_ADDR
// sRadar := false ;
18858: LD_ADDR_EXP 64
18862: PUSH
18863: LD_INT 0
18865: ST_TO_ADDR
// sBunker := false ;
18866: LD_ADDR_EXP 65
18870: PUSH
18871: LD_INT 0
18873: ST_TO_ADDR
// sHack := false ;
18874: LD_ADDR_EXP 66
18878: PUSH
18879: LD_INT 0
18881: ST_TO_ADDR
// sFire := false ;
18882: LD_ADDR_EXP 67
18886: PUSH
18887: LD_INT 0
18889: ST_TO_ADDR
// sRefresh := false ;
18890: LD_ADDR_EXP 68
18894: PUSH
18895: LD_INT 0
18897: ST_TO_ADDR
// sExp := false ;
18898: LD_ADDR_EXP 69
18902: PUSH
18903: LD_INT 0
18905: ST_TO_ADDR
// sDepot := false ;
18906: LD_ADDR_EXP 70
18910: PUSH
18911: LD_INT 0
18913: ST_TO_ADDR
// sFlag := false ;
18914: LD_ADDR_EXP 71
18918: PUSH
18919: LD_INT 0
18921: ST_TO_ADDR
// sKamikadze := false ;
18922: LD_ADDR_EXP 79
18926: PUSH
18927: LD_INT 0
18929: ST_TO_ADDR
// sTroll := false ;
18930: LD_ADDR_EXP 80
18934: PUSH
18935: LD_INT 0
18937: ST_TO_ADDR
// sSlow := false ;
18938: LD_ADDR_EXP 81
18942: PUSH
18943: LD_INT 0
18945: ST_TO_ADDR
// sLack := false ;
18946: LD_ADDR_EXP 82
18950: PUSH
18951: LD_INT 0
18953: ST_TO_ADDR
// sTank := false ;
18954: LD_ADDR_EXP 84
18958: PUSH
18959: LD_INT 0
18961: ST_TO_ADDR
// sRemote := false ;
18962: LD_ADDR_EXP 85
18966: PUSH
18967: LD_INT 0
18969: ST_TO_ADDR
// sPowell := false ;
18970: LD_ADDR_EXP 86
18974: PUSH
18975: LD_INT 0
18977: ST_TO_ADDR
// sTeleport := false ;
18978: LD_ADDR_EXP 89
18982: PUSH
18983: LD_INT 0
18985: ST_TO_ADDR
// sOilTower := false ;
18986: LD_ADDR_EXP 91
18990: PUSH
18991: LD_INT 0
18993: ST_TO_ADDR
// sShovel := false ;
18994: LD_ADDR_EXP 92
18998: PUSH
18999: LD_INT 0
19001: ST_TO_ADDR
// sSheik := false ;
19002: LD_ADDR_EXP 93
19006: PUSH
19007: LD_INT 0
19009: ST_TO_ADDR
// sEarthquake := false ;
19010: LD_ADDR_EXP 95
19014: PUSH
19015: LD_INT 0
19017: ST_TO_ADDR
// sAI := false ;
19018: LD_ADDR_EXP 96
19022: PUSH
19023: LD_INT 0
19025: ST_TO_ADDR
// sCargo := false ;
19026: LD_ADDR_EXP 99
19030: PUSH
19031: LD_INT 0
19033: ST_TO_ADDR
// sDLaser := false ;
19034: LD_ADDR_EXP 100
19038: PUSH
19039: LD_INT 0
19041: ST_TO_ADDR
// sExchange := false ;
19042: LD_ADDR_EXP 101
19046: PUSH
19047: LD_INT 0
19049: ST_TO_ADDR
// sFac := false ;
19050: LD_ADDR_EXP 102
19054: PUSH
19055: LD_INT 0
19057: ST_TO_ADDR
// sPower := false ;
19058: LD_ADDR_EXP 103
19062: PUSH
19063: LD_INT 0
19065: ST_TO_ADDR
// sRandom := false ;
19066: LD_ADDR_EXP 104
19070: PUSH
19071: LD_INT 0
19073: ST_TO_ADDR
// sShield := false ;
19074: LD_ADDR_EXP 105
19078: PUSH
19079: LD_INT 0
19081: ST_TO_ADDR
// sTime := false ;
19082: LD_ADDR_EXP 106
19086: PUSH
19087: LD_INT 0
19089: ST_TO_ADDR
// sTools := false ;
19090: LD_ADDR_EXP 107
19094: PUSH
19095: LD_INT 0
19097: ST_TO_ADDR
// sSold := false ;
19098: LD_ADDR_EXP 72
19102: PUSH
19103: LD_INT 0
19105: ST_TO_ADDR
// sDiff := false ;
19106: LD_ADDR_EXP 73
19110: PUSH
19111: LD_INT 0
19113: ST_TO_ADDR
// sFog := false ;
19114: LD_ADDR_EXP 76
19118: PUSH
19119: LD_INT 0
19121: ST_TO_ADDR
// sReset := false ;
19122: LD_ADDR_EXP 77
19126: PUSH
19127: LD_INT 0
19129: ST_TO_ADDR
// sSun := false ;
19130: LD_ADDR_EXP 78
19134: PUSH
19135: LD_INT 0
19137: ST_TO_ADDR
// sTiger := false ;
19138: LD_ADDR_EXP 74
19142: PUSH
19143: LD_INT 0
19145: ST_TO_ADDR
// sBomb := false ;
19146: LD_ADDR_EXP 75
19150: PUSH
19151: LD_INT 0
19153: ST_TO_ADDR
// sWound := false ;
19154: LD_ADDR_EXP 83
19158: PUSH
19159: LD_INT 0
19161: ST_TO_ADDR
// sBetray := false ;
19162: LD_ADDR_EXP 87
19166: PUSH
19167: LD_INT 0
19169: ST_TO_ADDR
// sContamin := false ;
19170: LD_ADDR_EXP 88
19174: PUSH
19175: LD_INT 0
19177: ST_TO_ADDR
// sOil := false ;
19178: LD_ADDR_EXP 90
19182: PUSH
19183: LD_INT 0
19185: ST_TO_ADDR
// sStu := false ;
19186: LD_ADDR_EXP 94
19190: PUSH
19191: LD_INT 0
19193: ST_TO_ADDR
// sBazooka := false ;
19194: LD_ADDR_EXP 97
19198: PUSH
19199: LD_INT 0
19201: ST_TO_ADDR
// sMortar := false ;
19202: LD_ADDR_EXP 98
19206: PUSH
19207: LD_INT 0
19209: ST_TO_ADDR
// sRanger := false ;
19210: LD_ADDR_EXP 108
19214: PUSH
19215: LD_INT 0
19217: ST_TO_ADDR
// end ;
19218: LD_VAR 0 1
19222: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19223: LD_INT 0
19225: PPUSH
19226: PPUSH
19227: PPUSH
19228: PPUSH
19229: PPUSH
// result := [ ] ;
19230: LD_ADDR_VAR 0 1
19234: PUSH
19235: EMPTY
19236: ST_TO_ADDR
// if campaign_id = 1 then
19237: LD_OWVAR 69
19241: PUSH
19242: LD_INT 1
19244: EQUAL
19245: IFFALSE 22183
// begin case mission_number of 1 :
19247: LD_OWVAR 70
19251: PUSH
19252: LD_INT 1
19254: DOUBLE
19255: EQUAL
19256: IFTRUE 19260
19258: GO 19324
19260: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19261: LD_ADDR_VAR 0 1
19265: PUSH
19266: LD_INT 2
19268: PUSH
19269: LD_INT 4
19271: PUSH
19272: LD_INT 11
19274: PUSH
19275: LD_INT 12
19277: PUSH
19278: LD_INT 15
19280: PUSH
19281: LD_INT 16
19283: PUSH
19284: LD_INT 22
19286: PUSH
19287: LD_INT 23
19289: PUSH
19290: LD_INT 26
19292: PUSH
19293: EMPTY
19294: LIST
19295: LIST
19296: LIST
19297: LIST
19298: LIST
19299: LIST
19300: LIST
19301: LIST
19302: LIST
19303: PUSH
19304: LD_INT 101
19306: PUSH
19307: LD_INT 102
19309: PUSH
19310: LD_INT 106
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: LIST
19317: PUSH
19318: EMPTY
19319: LIST
19320: LIST
19321: ST_TO_ADDR
19322: GO 22181
19324: LD_INT 2
19326: DOUBLE
19327: EQUAL
19328: IFTRUE 19332
19330: GO 19404
19332: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19333: LD_ADDR_VAR 0 1
19337: PUSH
19338: LD_INT 2
19340: PUSH
19341: LD_INT 4
19343: PUSH
19344: LD_INT 11
19346: PUSH
19347: LD_INT 12
19349: PUSH
19350: LD_INT 15
19352: PUSH
19353: LD_INT 16
19355: PUSH
19356: LD_INT 22
19358: PUSH
19359: LD_INT 23
19361: PUSH
19362: LD_INT 26
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: PUSH
19376: LD_INT 101
19378: PUSH
19379: LD_INT 102
19381: PUSH
19382: LD_INT 105
19384: PUSH
19385: LD_INT 106
19387: PUSH
19388: LD_INT 108
19390: PUSH
19391: EMPTY
19392: LIST
19393: LIST
19394: LIST
19395: LIST
19396: LIST
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: ST_TO_ADDR
19402: GO 22181
19404: LD_INT 3
19406: DOUBLE
19407: EQUAL
19408: IFTRUE 19412
19410: GO 19488
19412: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19413: LD_ADDR_VAR 0 1
19417: PUSH
19418: LD_INT 2
19420: PUSH
19421: LD_INT 4
19423: PUSH
19424: LD_INT 5
19426: PUSH
19427: LD_INT 11
19429: PUSH
19430: LD_INT 12
19432: PUSH
19433: LD_INT 15
19435: PUSH
19436: LD_INT 16
19438: PUSH
19439: LD_INT 22
19441: PUSH
19442: LD_INT 26
19444: PUSH
19445: LD_INT 36
19447: PUSH
19448: EMPTY
19449: LIST
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: LIST
19456: LIST
19457: LIST
19458: LIST
19459: PUSH
19460: LD_INT 101
19462: PUSH
19463: LD_INT 102
19465: PUSH
19466: LD_INT 105
19468: PUSH
19469: LD_INT 106
19471: PUSH
19472: LD_INT 108
19474: PUSH
19475: EMPTY
19476: LIST
19477: LIST
19478: LIST
19479: LIST
19480: LIST
19481: PUSH
19482: EMPTY
19483: LIST
19484: LIST
19485: ST_TO_ADDR
19486: GO 22181
19488: LD_INT 4
19490: DOUBLE
19491: EQUAL
19492: IFTRUE 19496
19494: GO 19580
19496: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19497: LD_ADDR_VAR 0 1
19501: PUSH
19502: LD_INT 2
19504: PUSH
19505: LD_INT 4
19507: PUSH
19508: LD_INT 5
19510: PUSH
19511: LD_INT 8
19513: PUSH
19514: LD_INT 11
19516: PUSH
19517: LD_INT 12
19519: PUSH
19520: LD_INT 15
19522: PUSH
19523: LD_INT 16
19525: PUSH
19526: LD_INT 22
19528: PUSH
19529: LD_INT 23
19531: PUSH
19532: LD_INT 26
19534: PUSH
19535: LD_INT 36
19537: PUSH
19538: EMPTY
19539: LIST
19540: LIST
19541: LIST
19542: LIST
19543: LIST
19544: LIST
19545: LIST
19546: LIST
19547: LIST
19548: LIST
19549: LIST
19550: LIST
19551: PUSH
19552: LD_INT 101
19554: PUSH
19555: LD_INT 102
19557: PUSH
19558: LD_INT 105
19560: PUSH
19561: LD_INT 106
19563: PUSH
19564: LD_INT 108
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: LIST
19571: LIST
19572: LIST
19573: PUSH
19574: EMPTY
19575: LIST
19576: LIST
19577: ST_TO_ADDR
19578: GO 22181
19580: LD_INT 5
19582: DOUBLE
19583: EQUAL
19584: IFTRUE 19588
19586: GO 19688
19588: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19589: LD_ADDR_VAR 0 1
19593: PUSH
19594: LD_INT 2
19596: PUSH
19597: LD_INT 4
19599: PUSH
19600: LD_INT 5
19602: PUSH
19603: LD_INT 6
19605: PUSH
19606: LD_INT 8
19608: PUSH
19609: LD_INT 11
19611: PUSH
19612: LD_INT 12
19614: PUSH
19615: LD_INT 15
19617: PUSH
19618: LD_INT 16
19620: PUSH
19621: LD_INT 22
19623: PUSH
19624: LD_INT 23
19626: PUSH
19627: LD_INT 25
19629: PUSH
19630: LD_INT 26
19632: PUSH
19633: LD_INT 36
19635: PUSH
19636: EMPTY
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: PUSH
19652: LD_INT 101
19654: PUSH
19655: LD_INT 102
19657: PUSH
19658: LD_INT 105
19660: PUSH
19661: LD_INT 106
19663: PUSH
19664: LD_INT 108
19666: PUSH
19667: LD_INT 109
19669: PUSH
19670: LD_INT 112
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: LIST
19677: LIST
19678: LIST
19679: LIST
19680: LIST
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: ST_TO_ADDR
19686: GO 22181
19688: LD_INT 6
19690: DOUBLE
19691: EQUAL
19692: IFTRUE 19696
19694: GO 19816
19696: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19697: LD_ADDR_VAR 0 1
19701: PUSH
19702: LD_INT 2
19704: PUSH
19705: LD_INT 4
19707: PUSH
19708: LD_INT 5
19710: PUSH
19711: LD_INT 6
19713: PUSH
19714: LD_INT 8
19716: PUSH
19717: LD_INT 11
19719: PUSH
19720: LD_INT 12
19722: PUSH
19723: LD_INT 15
19725: PUSH
19726: LD_INT 16
19728: PUSH
19729: LD_INT 20
19731: PUSH
19732: LD_INT 21
19734: PUSH
19735: LD_INT 22
19737: PUSH
19738: LD_INT 23
19740: PUSH
19741: LD_INT 25
19743: PUSH
19744: LD_INT 26
19746: PUSH
19747: LD_INT 30
19749: PUSH
19750: LD_INT 31
19752: PUSH
19753: LD_INT 32
19755: PUSH
19756: LD_INT 36
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: LIST
19766: LIST
19767: LIST
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: LIST
19779: PUSH
19780: LD_INT 101
19782: PUSH
19783: LD_INT 102
19785: PUSH
19786: LD_INT 105
19788: PUSH
19789: LD_INT 106
19791: PUSH
19792: LD_INT 108
19794: PUSH
19795: LD_INT 109
19797: PUSH
19798: LD_INT 112
19800: PUSH
19801: EMPTY
19802: LIST
19803: LIST
19804: LIST
19805: LIST
19806: LIST
19807: LIST
19808: LIST
19809: PUSH
19810: EMPTY
19811: LIST
19812: LIST
19813: ST_TO_ADDR
19814: GO 22181
19816: LD_INT 7
19818: DOUBLE
19819: EQUAL
19820: IFTRUE 19824
19822: GO 19924
19824: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19825: LD_ADDR_VAR 0 1
19829: PUSH
19830: LD_INT 2
19832: PUSH
19833: LD_INT 4
19835: PUSH
19836: LD_INT 5
19838: PUSH
19839: LD_INT 7
19841: PUSH
19842: LD_INT 11
19844: PUSH
19845: LD_INT 12
19847: PUSH
19848: LD_INT 15
19850: PUSH
19851: LD_INT 16
19853: PUSH
19854: LD_INT 20
19856: PUSH
19857: LD_INT 21
19859: PUSH
19860: LD_INT 22
19862: PUSH
19863: LD_INT 23
19865: PUSH
19866: LD_INT 25
19868: PUSH
19869: LD_INT 26
19871: PUSH
19872: EMPTY
19873: LIST
19874: LIST
19875: LIST
19876: LIST
19877: LIST
19878: LIST
19879: LIST
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 101
19890: PUSH
19891: LD_INT 102
19893: PUSH
19894: LD_INT 103
19896: PUSH
19897: LD_INT 105
19899: PUSH
19900: LD_INT 106
19902: PUSH
19903: LD_INT 108
19905: PUSH
19906: LD_INT 112
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: LIST
19913: LIST
19914: LIST
19915: LIST
19916: LIST
19917: PUSH
19918: EMPTY
19919: LIST
19920: LIST
19921: ST_TO_ADDR
19922: GO 22181
19924: LD_INT 8
19926: DOUBLE
19927: EQUAL
19928: IFTRUE 19932
19930: GO 20060
19932: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19933: LD_ADDR_VAR 0 1
19937: PUSH
19938: LD_INT 2
19940: PUSH
19941: LD_INT 4
19943: PUSH
19944: LD_INT 5
19946: PUSH
19947: LD_INT 6
19949: PUSH
19950: LD_INT 7
19952: PUSH
19953: LD_INT 8
19955: PUSH
19956: LD_INT 11
19958: PUSH
19959: LD_INT 12
19961: PUSH
19962: LD_INT 15
19964: PUSH
19965: LD_INT 16
19967: PUSH
19968: LD_INT 20
19970: PUSH
19971: LD_INT 21
19973: PUSH
19974: LD_INT 22
19976: PUSH
19977: LD_INT 23
19979: PUSH
19980: LD_INT 25
19982: PUSH
19983: LD_INT 26
19985: PUSH
19986: LD_INT 30
19988: PUSH
19989: LD_INT 31
19991: PUSH
19992: LD_INT 32
19994: PUSH
19995: LD_INT 36
19997: PUSH
19998: EMPTY
19999: LIST
20000: LIST
20001: LIST
20002: LIST
20003: LIST
20004: LIST
20005: LIST
20006: LIST
20007: LIST
20008: LIST
20009: LIST
20010: LIST
20011: LIST
20012: LIST
20013: LIST
20014: LIST
20015: LIST
20016: LIST
20017: LIST
20018: LIST
20019: PUSH
20020: LD_INT 101
20022: PUSH
20023: LD_INT 102
20025: PUSH
20026: LD_INT 103
20028: PUSH
20029: LD_INT 105
20031: PUSH
20032: LD_INT 106
20034: PUSH
20035: LD_INT 108
20037: PUSH
20038: LD_INT 109
20040: PUSH
20041: LD_INT 112
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: LIST
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: LIST
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: ST_TO_ADDR
20058: GO 22181
20060: LD_INT 9
20062: DOUBLE
20063: EQUAL
20064: IFTRUE 20068
20066: GO 20204
20068: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
20069: LD_ADDR_VAR 0 1
20073: PUSH
20074: LD_INT 2
20076: PUSH
20077: LD_INT 4
20079: PUSH
20080: LD_INT 5
20082: PUSH
20083: LD_INT 6
20085: PUSH
20086: LD_INT 7
20088: PUSH
20089: LD_INT 8
20091: PUSH
20092: LD_INT 11
20094: PUSH
20095: LD_INT 12
20097: PUSH
20098: LD_INT 15
20100: PUSH
20101: LD_INT 16
20103: PUSH
20104: LD_INT 20
20106: PUSH
20107: LD_INT 21
20109: PUSH
20110: LD_INT 22
20112: PUSH
20113: LD_INT 23
20115: PUSH
20116: LD_INT 25
20118: PUSH
20119: LD_INT 26
20121: PUSH
20122: LD_INT 28
20124: PUSH
20125: LD_INT 30
20127: PUSH
20128: LD_INT 31
20130: PUSH
20131: LD_INT 32
20133: PUSH
20134: LD_INT 36
20136: PUSH
20137: EMPTY
20138: LIST
20139: LIST
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: PUSH
20160: LD_INT 101
20162: PUSH
20163: LD_INT 102
20165: PUSH
20166: LD_INT 103
20168: PUSH
20169: LD_INT 105
20171: PUSH
20172: LD_INT 106
20174: PUSH
20175: LD_INT 108
20177: PUSH
20178: LD_INT 109
20180: PUSH
20181: LD_INT 112
20183: PUSH
20184: LD_INT 114
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: PUSH
20198: EMPTY
20199: LIST
20200: LIST
20201: ST_TO_ADDR
20202: GO 22181
20204: LD_INT 10
20206: DOUBLE
20207: EQUAL
20208: IFTRUE 20212
20210: GO 20396
20212: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20213: LD_ADDR_VAR 0 1
20217: PUSH
20218: LD_INT 2
20220: PUSH
20221: LD_INT 4
20223: PUSH
20224: LD_INT 5
20226: PUSH
20227: LD_INT 6
20229: PUSH
20230: LD_INT 7
20232: PUSH
20233: LD_INT 8
20235: PUSH
20236: LD_INT 9
20238: PUSH
20239: LD_INT 10
20241: PUSH
20242: LD_INT 11
20244: PUSH
20245: LD_INT 12
20247: PUSH
20248: LD_INT 13
20250: PUSH
20251: LD_INT 14
20253: PUSH
20254: LD_INT 15
20256: PUSH
20257: LD_INT 16
20259: PUSH
20260: LD_INT 17
20262: PUSH
20263: LD_INT 18
20265: PUSH
20266: LD_INT 19
20268: PUSH
20269: LD_INT 20
20271: PUSH
20272: LD_INT 21
20274: PUSH
20275: LD_INT 22
20277: PUSH
20278: LD_INT 23
20280: PUSH
20281: LD_INT 24
20283: PUSH
20284: LD_INT 25
20286: PUSH
20287: LD_INT 26
20289: PUSH
20290: LD_INT 28
20292: PUSH
20293: LD_INT 30
20295: PUSH
20296: LD_INT 31
20298: PUSH
20299: LD_INT 32
20301: PUSH
20302: LD_INT 36
20304: PUSH
20305: EMPTY
20306: LIST
20307: LIST
20308: LIST
20309: LIST
20310: LIST
20311: LIST
20312: LIST
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: LIST
20328: LIST
20329: LIST
20330: LIST
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: PUSH
20336: LD_INT 101
20338: PUSH
20339: LD_INT 102
20341: PUSH
20342: LD_INT 103
20344: PUSH
20345: LD_INT 104
20347: PUSH
20348: LD_INT 105
20350: PUSH
20351: LD_INT 106
20353: PUSH
20354: LD_INT 107
20356: PUSH
20357: LD_INT 108
20359: PUSH
20360: LD_INT 109
20362: PUSH
20363: LD_INT 110
20365: PUSH
20366: LD_INT 111
20368: PUSH
20369: LD_INT 112
20371: PUSH
20372: LD_INT 114
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: PUSH
20390: EMPTY
20391: LIST
20392: LIST
20393: ST_TO_ADDR
20394: GO 22181
20396: LD_INT 11
20398: DOUBLE
20399: EQUAL
20400: IFTRUE 20404
20402: GO 20596
20404: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20405: LD_ADDR_VAR 0 1
20409: PUSH
20410: LD_INT 2
20412: PUSH
20413: LD_INT 3
20415: PUSH
20416: LD_INT 4
20418: PUSH
20419: LD_INT 5
20421: PUSH
20422: LD_INT 6
20424: PUSH
20425: LD_INT 7
20427: PUSH
20428: LD_INT 8
20430: PUSH
20431: LD_INT 9
20433: PUSH
20434: LD_INT 10
20436: PUSH
20437: LD_INT 11
20439: PUSH
20440: LD_INT 12
20442: PUSH
20443: LD_INT 13
20445: PUSH
20446: LD_INT 14
20448: PUSH
20449: LD_INT 15
20451: PUSH
20452: LD_INT 16
20454: PUSH
20455: LD_INT 17
20457: PUSH
20458: LD_INT 18
20460: PUSH
20461: LD_INT 19
20463: PUSH
20464: LD_INT 20
20466: PUSH
20467: LD_INT 21
20469: PUSH
20470: LD_INT 22
20472: PUSH
20473: LD_INT 23
20475: PUSH
20476: LD_INT 24
20478: PUSH
20479: LD_INT 25
20481: PUSH
20482: LD_INT 26
20484: PUSH
20485: LD_INT 28
20487: PUSH
20488: LD_INT 30
20490: PUSH
20491: LD_INT 31
20493: PUSH
20494: LD_INT 32
20496: PUSH
20497: LD_INT 34
20499: PUSH
20500: LD_INT 36
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: LIST
20507: LIST
20508: LIST
20509: LIST
20510: LIST
20511: LIST
20512: LIST
20513: LIST
20514: LIST
20515: LIST
20516: LIST
20517: LIST
20518: LIST
20519: LIST
20520: LIST
20521: LIST
20522: LIST
20523: LIST
20524: LIST
20525: LIST
20526: LIST
20527: LIST
20528: LIST
20529: LIST
20530: LIST
20531: LIST
20532: LIST
20533: LIST
20534: LIST
20535: PUSH
20536: LD_INT 101
20538: PUSH
20539: LD_INT 102
20541: PUSH
20542: LD_INT 103
20544: PUSH
20545: LD_INT 104
20547: PUSH
20548: LD_INT 105
20550: PUSH
20551: LD_INT 106
20553: PUSH
20554: LD_INT 107
20556: PUSH
20557: LD_INT 108
20559: PUSH
20560: LD_INT 109
20562: PUSH
20563: LD_INT 110
20565: PUSH
20566: LD_INT 111
20568: PUSH
20569: LD_INT 112
20571: PUSH
20572: LD_INT 114
20574: PUSH
20575: EMPTY
20576: LIST
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: PUSH
20590: EMPTY
20591: LIST
20592: LIST
20593: ST_TO_ADDR
20594: GO 22181
20596: LD_INT 12
20598: DOUBLE
20599: EQUAL
20600: IFTRUE 20604
20602: GO 20812
20604: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20605: LD_ADDR_VAR 0 1
20609: PUSH
20610: LD_INT 1
20612: PUSH
20613: LD_INT 2
20615: PUSH
20616: LD_INT 3
20618: PUSH
20619: LD_INT 4
20621: PUSH
20622: LD_INT 5
20624: PUSH
20625: LD_INT 6
20627: PUSH
20628: LD_INT 7
20630: PUSH
20631: LD_INT 8
20633: PUSH
20634: LD_INT 9
20636: PUSH
20637: LD_INT 10
20639: PUSH
20640: LD_INT 11
20642: PUSH
20643: LD_INT 12
20645: PUSH
20646: LD_INT 13
20648: PUSH
20649: LD_INT 14
20651: PUSH
20652: LD_INT 15
20654: PUSH
20655: LD_INT 16
20657: PUSH
20658: LD_INT 17
20660: PUSH
20661: LD_INT 18
20663: PUSH
20664: LD_INT 19
20666: PUSH
20667: LD_INT 20
20669: PUSH
20670: LD_INT 21
20672: PUSH
20673: LD_INT 22
20675: PUSH
20676: LD_INT 23
20678: PUSH
20679: LD_INT 24
20681: PUSH
20682: LD_INT 25
20684: PUSH
20685: LD_INT 26
20687: PUSH
20688: LD_INT 27
20690: PUSH
20691: LD_INT 28
20693: PUSH
20694: LD_INT 30
20696: PUSH
20697: LD_INT 31
20699: PUSH
20700: LD_INT 32
20702: PUSH
20703: LD_INT 33
20705: PUSH
20706: LD_INT 34
20708: PUSH
20709: LD_INT 36
20711: PUSH
20712: EMPTY
20713: LIST
20714: LIST
20715: LIST
20716: LIST
20717: LIST
20718: LIST
20719: LIST
20720: LIST
20721: LIST
20722: LIST
20723: LIST
20724: LIST
20725: LIST
20726: LIST
20727: LIST
20728: LIST
20729: LIST
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: LIST
20735: LIST
20736: LIST
20737: LIST
20738: LIST
20739: LIST
20740: LIST
20741: LIST
20742: LIST
20743: LIST
20744: LIST
20745: LIST
20746: LIST
20747: PUSH
20748: LD_INT 101
20750: PUSH
20751: LD_INT 102
20753: PUSH
20754: LD_INT 103
20756: PUSH
20757: LD_INT 104
20759: PUSH
20760: LD_INT 105
20762: PUSH
20763: LD_INT 106
20765: PUSH
20766: LD_INT 107
20768: PUSH
20769: LD_INT 108
20771: PUSH
20772: LD_INT 109
20774: PUSH
20775: LD_INT 110
20777: PUSH
20778: LD_INT 111
20780: PUSH
20781: LD_INT 112
20783: PUSH
20784: LD_INT 113
20786: PUSH
20787: LD_INT 114
20789: PUSH
20790: EMPTY
20791: LIST
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: PUSH
20806: EMPTY
20807: LIST
20808: LIST
20809: ST_TO_ADDR
20810: GO 22181
20812: LD_INT 13
20814: DOUBLE
20815: EQUAL
20816: IFTRUE 20820
20818: GO 21016
20820: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20821: LD_ADDR_VAR 0 1
20825: PUSH
20826: LD_INT 1
20828: PUSH
20829: LD_INT 2
20831: PUSH
20832: LD_INT 3
20834: PUSH
20835: LD_INT 4
20837: PUSH
20838: LD_INT 5
20840: PUSH
20841: LD_INT 8
20843: PUSH
20844: LD_INT 9
20846: PUSH
20847: LD_INT 10
20849: PUSH
20850: LD_INT 11
20852: PUSH
20853: LD_INT 12
20855: PUSH
20856: LD_INT 14
20858: PUSH
20859: LD_INT 15
20861: PUSH
20862: LD_INT 16
20864: PUSH
20865: LD_INT 17
20867: PUSH
20868: LD_INT 18
20870: PUSH
20871: LD_INT 19
20873: PUSH
20874: LD_INT 20
20876: PUSH
20877: LD_INT 21
20879: PUSH
20880: LD_INT 22
20882: PUSH
20883: LD_INT 23
20885: PUSH
20886: LD_INT 24
20888: PUSH
20889: LD_INT 25
20891: PUSH
20892: LD_INT 26
20894: PUSH
20895: LD_INT 27
20897: PUSH
20898: LD_INT 28
20900: PUSH
20901: LD_INT 30
20903: PUSH
20904: LD_INT 31
20906: PUSH
20907: LD_INT 32
20909: PUSH
20910: LD_INT 33
20912: PUSH
20913: LD_INT 34
20915: PUSH
20916: LD_INT 36
20918: PUSH
20919: EMPTY
20920: LIST
20921: LIST
20922: LIST
20923: LIST
20924: LIST
20925: LIST
20926: LIST
20927: LIST
20928: LIST
20929: LIST
20930: LIST
20931: LIST
20932: LIST
20933: LIST
20934: LIST
20935: LIST
20936: LIST
20937: LIST
20938: LIST
20939: LIST
20940: LIST
20941: LIST
20942: LIST
20943: LIST
20944: LIST
20945: LIST
20946: LIST
20947: LIST
20948: LIST
20949: LIST
20950: LIST
20951: PUSH
20952: LD_INT 101
20954: PUSH
20955: LD_INT 102
20957: PUSH
20958: LD_INT 103
20960: PUSH
20961: LD_INT 104
20963: PUSH
20964: LD_INT 105
20966: PUSH
20967: LD_INT 106
20969: PUSH
20970: LD_INT 107
20972: PUSH
20973: LD_INT 108
20975: PUSH
20976: LD_INT 109
20978: PUSH
20979: LD_INT 110
20981: PUSH
20982: LD_INT 111
20984: PUSH
20985: LD_INT 112
20987: PUSH
20988: LD_INT 113
20990: PUSH
20991: LD_INT 114
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: LIST
21003: LIST
21004: LIST
21005: LIST
21006: LIST
21007: LIST
21008: LIST
21009: PUSH
21010: EMPTY
21011: LIST
21012: LIST
21013: ST_TO_ADDR
21014: GO 22181
21016: LD_INT 14
21018: DOUBLE
21019: EQUAL
21020: IFTRUE 21024
21022: GO 21236
21024: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
21025: LD_ADDR_VAR 0 1
21029: PUSH
21030: LD_INT 1
21032: PUSH
21033: LD_INT 2
21035: PUSH
21036: LD_INT 3
21038: PUSH
21039: LD_INT 4
21041: PUSH
21042: LD_INT 5
21044: PUSH
21045: LD_INT 6
21047: PUSH
21048: LD_INT 7
21050: PUSH
21051: LD_INT 8
21053: PUSH
21054: LD_INT 9
21056: PUSH
21057: LD_INT 10
21059: PUSH
21060: LD_INT 11
21062: PUSH
21063: LD_INT 12
21065: PUSH
21066: LD_INT 13
21068: PUSH
21069: LD_INT 14
21071: PUSH
21072: LD_INT 15
21074: PUSH
21075: LD_INT 16
21077: PUSH
21078: LD_INT 17
21080: PUSH
21081: LD_INT 18
21083: PUSH
21084: LD_INT 19
21086: PUSH
21087: LD_INT 20
21089: PUSH
21090: LD_INT 21
21092: PUSH
21093: LD_INT 22
21095: PUSH
21096: LD_INT 23
21098: PUSH
21099: LD_INT 24
21101: PUSH
21102: LD_INT 25
21104: PUSH
21105: LD_INT 26
21107: PUSH
21108: LD_INT 27
21110: PUSH
21111: LD_INT 28
21113: PUSH
21114: LD_INT 29
21116: PUSH
21117: LD_INT 30
21119: PUSH
21120: LD_INT 31
21122: PUSH
21123: LD_INT 32
21125: PUSH
21126: LD_INT 33
21128: PUSH
21129: LD_INT 34
21131: PUSH
21132: LD_INT 36
21134: PUSH
21135: EMPTY
21136: LIST
21137: LIST
21138: LIST
21139: LIST
21140: LIST
21141: LIST
21142: LIST
21143: LIST
21144: LIST
21145: LIST
21146: LIST
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: LIST
21160: LIST
21161: LIST
21162: LIST
21163: LIST
21164: LIST
21165: LIST
21166: LIST
21167: LIST
21168: LIST
21169: LIST
21170: LIST
21171: PUSH
21172: LD_INT 101
21174: PUSH
21175: LD_INT 102
21177: PUSH
21178: LD_INT 103
21180: PUSH
21181: LD_INT 104
21183: PUSH
21184: LD_INT 105
21186: PUSH
21187: LD_INT 106
21189: PUSH
21190: LD_INT 107
21192: PUSH
21193: LD_INT 108
21195: PUSH
21196: LD_INT 109
21198: PUSH
21199: LD_INT 110
21201: PUSH
21202: LD_INT 111
21204: PUSH
21205: LD_INT 112
21207: PUSH
21208: LD_INT 113
21210: PUSH
21211: LD_INT 114
21213: PUSH
21214: EMPTY
21215: LIST
21216: LIST
21217: LIST
21218: LIST
21219: LIST
21220: LIST
21221: LIST
21222: LIST
21223: LIST
21224: LIST
21225: LIST
21226: LIST
21227: LIST
21228: LIST
21229: PUSH
21230: EMPTY
21231: LIST
21232: LIST
21233: ST_TO_ADDR
21234: GO 22181
21236: LD_INT 15
21238: DOUBLE
21239: EQUAL
21240: IFTRUE 21244
21242: GO 21456
21244: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21245: LD_ADDR_VAR 0 1
21249: PUSH
21250: LD_INT 1
21252: PUSH
21253: LD_INT 2
21255: PUSH
21256: LD_INT 3
21258: PUSH
21259: LD_INT 4
21261: PUSH
21262: LD_INT 5
21264: PUSH
21265: LD_INT 6
21267: PUSH
21268: LD_INT 7
21270: PUSH
21271: LD_INT 8
21273: PUSH
21274: LD_INT 9
21276: PUSH
21277: LD_INT 10
21279: PUSH
21280: LD_INT 11
21282: PUSH
21283: LD_INT 12
21285: PUSH
21286: LD_INT 13
21288: PUSH
21289: LD_INT 14
21291: PUSH
21292: LD_INT 15
21294: PUSH
21295: LD_INT 16
21297: PUSH
21298: LD_INT 17
21300: PUSH
21301: LD_INT 18
21303: PUSH
21304: LD_INT 19
21306: PUSH
21307: LD_INT 20
21309: PUSH
21310: LD_INT 21
21312: PUSH
21313: LD_INT 22
21315: PUSH
21316: LD_INT 23
21318: PUSH
21319: LD_INT 24
21321: PUSH
21322: LD_INT 25
21324: PUSH
21325: LD_INT 26
21327: PUSH
21328: LD_INT 27
21330: PUSH
21331: LD_INT 28
21333: PUSH
21334: LD_INT 29
21336: PUSH
21337: LD_INT 30
21339: PUSH
21340: LD_INT 31
21342: PUSH
21343: LD_INT 32
21345: PUSH
21346: LD_INT 33
21348: PUSH
21349: LD_INT 34
21351: PUSH
21352: LD_INT 36
21354: PUSH
21355: EMPTY
21356: LIST
21357: LIST
21358: LIST
21359: LIST
21360: LIST
21361: LIST
21362: LIST
21363: LIST
21364: LIST
21365: LIST
21366: LIST
21367: LIST
21368: LIST
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: LIST
21379: LIST
21380: LIST
21381: LIST
21382: LIST
21383: LIST
21384: LIST
21385: LIST
21386: LIST
21387: LIST
21388: LIST
21389: LIST
21390: LIST
21391: PUSH
21392: LD_INT 101
21394: PUSH
21395: LD_INT 102
21397: PUSH
21398: LD_INT 103
21400: PUSH
21401: LD_INT 104
21403: PUSH
21404: LD_INT 105
21406: PUSH
21407: LD_INT 106
21409: PUSH
21410: LD_INT 107
21412: PUSH
21413: LD_INT 108
21415: PUSH
21416: LD_INT 109
21418: PUSH
21419: LD_INT 110
21421: PUSH
21422: LD_INT 111
21424: PUSH
21425: LD_INT 112
21427: PUSH
21428: LD_INT 113
21430: PUSH
21431: LD_INT 114
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: LIST
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: LIST
21448: LIST
21449: PUSH
21450: EMPTY
21451: LIST
21452: LIST
21453: ST_TO_ADDR
21454: GO 22181
21456: LD_INT 16
21458: DOUBLE
21459: EQUAL
21460: IFTRUE 21464
21462: GO 21588
21464: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21465: LD_ADDR_VAR 0 1
21469: PUSH
21470: LD_INT 2
21472: PUSH
21473: LD_INT 4
21475: PUSH
21476: LD_INT 5
21478: PUSH
21479: LD_INT 7
21481: PUSH
21482: LD_INT 11
21484: PUSH
21485: LD_INT 12
21487: PUSH
21488: LD_INT 15
21490: PUSH
21491: LD_INT 16
21493: PUSH
21494: LD_INT 20
21496: PUSH
21497: LD_INT 21
21499: PUSH
21500: LD_INT 22
21502: PUSH
21503: LD_INT 23
21505: PUSH
21506: LD_INT 25
21508: PUSH
21509: LD_INT 26
21511: PUSH
21512: LD_INT 30
21514: PUSH
21515: LD_INT 31
21517: PUSH
21518: LD_INT 32
21520: PUSH
21521: LD_INT 33
21523: PUSH
21524: LD_INT 34
21526: PUSH
21527: EMPTY
21528: LIST
21529: LIST
21530: LIST
21531: LIST
21532: LIST
21533: LIST
21534: LIST
21535: LIST
21536: LIST
21537: LIST
21538: LIST
21539: LIST
21540: LIST
21541: LIST
21542: LIST
21543: LIST
21544: LIST
21545: LIST
21546: LIST
21547: PUSH
21548: LD_INT 101
21550: PUSH
21551: LD_INT 102
21553: PUSH
21554: LD_INT 103
21556: PUSH
21557: LD_INT 106
21559: PUSH
21560: LD_INT 108
21562: PUSH
21563: LD_INT 112
21565: PUSH
21566: LD_INT 113
21568: PUSH
21569: LD_INT 114
21571: PUSH
21572: EMPTY
21573: LIST
21574: LIST
21575: LIST
21576: LIST
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: PUSH
21582: EMPTY
21583: LIST
21584: LIST
21585: ST_TO_ADDR
21586: GO 22181
21588: LD_INT 17
21590: DOUBLE
21591: EQUAL
21592: IFTRUE 21596
21594: GO 21808
21596: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21597: LD_ADDR_VAR 0 1
21601: PUSH
21602: LD_INT 1
21604: PUSH
21605: LD_INT 2
21607: PUSH
21608: LD_INT 3
21610: PUSH
21611: LD_INT 4
21613: PUSH
21614: LD_INT 5
21616: PUSH
21617: LD_INT 6
21619: PUSH
21620: LD_INT 7
21622: PUSH
21623: LD_INT 8
21625: PUSH
21626: LD_INT 9
21628: PUSH
21629: LD_INT 10
21631: PUSH
21632: LD_INT 11
21634: PUSH
21635: LD_INT 12
21637: PUSH
21638: LD_INT 13
21640: PUSH
21641: LD_INT 14
21643: PUSH
21644: LD_INT 15
21646: PUSH
21647: LD_INT 16
21649: PUSH
21650: LD_INT 17
21652: PUSH
21653: LD_INT 18
21655: PUSH
21656: LD_INT 19
21658: PUSH
21659: LD_INT 20
21661: PUSH
21662: LD_INT 21
21664: PUSH
21665: LD_INT 22
21667: PUSH
21668: LD_INT 23
21670: PUSH
21671: LD_INT 24
21673: PUSH
21674: LD_INT 25
21676: PUSH
21677: LD_INT 26
21679: PUSH
21680: LD_INT 27
21682: PUSH
21683: LD_INT 28
21685: PUSH
21686: LD_INT 29
21688: PUSH
21689: LD_INT 30
21691: PUSH
21692: LD_INT 31
21694: PUSH
21695: LD_INT 32
21697: PUSH
21698: LD_INT 33
21700: PUSH
21701: LD_INT 34
21703: PUSH
21704: LD_INT 36
21706: PUSH
21707: EMPTY
21708: LIST
21709: LIST
21710: LIST
21711: LIST
21712: LIST
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: LIST
21718: LIST
21719: LIST
21720: LIST
21721: LIST
21722: LIST
21723: LIST
21724: LIST
21725: LIST
21726: LIST
21727: LIST
21728: LIST
21729: LIST
21730: LIST
21731: LIST
21732: LIST
21733: LIST
21734: LIST
21735: LIST
21736: LIST
21737: LIST
21738: LIST
21739: LIST
21740: LIST
21741: LIST
21742: LIST
21743: PUSH
21744: LD_INT 101
21746: PUSH
21747: LD_INT 102
21749: PUSH
21750: LD_INT 103
21752: PUSH
21753: LD_INT 104
21755: PUSH
21756: LD_INT 105
21758: PUSH
21759: LD_INT 106
21761: PUSH
21762: LD_INT 107
21764: PUSH
21765: LD_INT 108
21767: PUSH
21768: LD_INT 109
21770: PUSH
21771: LD_INT 110
21773: PUSH
21774: LD_INT 111
21776: PUSH
21777: LD_INT 112
21779: PUSH
21780: LD_INT 113
21782: PUSH
21783: LD_INT 114
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: LIST
21790: LIST
21791: LIST
21792: LIST
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: LIST
21801: PUSH
21802: EMPTY
21803: LIST
21804: LIST
21805: ST_TO_ADDR
21806: GO 22181
21808: LD_INT 18
21810: DOUBLE
21811: EQUAL
21812: IFTRUE 21816
21814: GO 21952
21816: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21817: LD_ADDR_VAR 0 1
21821: PUSH
21822: LD_INT 2
21824: PUSH
21825: LD_INT 4
21827: PUSH
21828: LD_INT 5
21830: PUSH
21831: LD_INT 7
21833: PUSH
21834: LD_INT 11
21836: PUSH
21837: LD_INT 12
21839: PUSH
21840: LD_INT 15
21842: PUSH
21843: LD_INT 16
21845: PUSH
21846: LD_INT 20
21848: PUSH
21849: LD_INT 21
21851: PUSH
21852: LD_INT 22
21854: PUSH
21855: LD_INT 23
21857: PUSH
21858: LD_INT 25
21860: PUSH
21861: LD_INT 26
21863: PUSH
21864: LD_INT 30
21866: PUSH
21867: LD_INT 31
21869: PUSH
21870: LD_INT 32
21872: PUSH
21873: LD_INT 33
21875: PUSH
21876: LD_INT 34
21878: PUSH
21879: LD_INT 35
21881: PUSH
21882: LD_INT 36
21884: PUSH
21885: EMPTY
21886: LIST
21887: LIST
21888: LIST
21889: LIST
21890: LIST
21891: LIST
21892: LIST
21893: LIST
21894: LIST
21895: LIST
21896: LIST
21897: LIST
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: LIST
21903: LIST
21904: LIST
21905: LIST
21906: LIST
21907: PUSH
21908: LD_INT 101
21910: PUSH
21911: LD_INT 102
21913: PUSH
21914: LD_INT 103
21916: PUSH
21917: LD_INT 106
21919: PUSH
21920: LD_INT 108
21922: PUSH
21923: LD_INT 112
21925: PUSH
21926: LD_INT 113
21928: PUSH
21929: LD_INT 114
21931: PUSH
21932: LD_INT 115
21934: PUSH
21935: EMPTY
21936: LIST
21937: LIST
21938: LIST
21939: LIST
21940: LIST
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: PUSH
21946: EMPTY
21947: LIST
21948: LIST
21949: ST_TO_ADDR
21950: GO 22181
21952: LD_INT 19
21954: DOUBLE
21955: EQUAL
21956: IFTRUE 21960
21958: GO 22180
21960: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21961: LD_ADDR_VAR 0 1
21965: PUSH
21966: LD_INT 1
21968: PUSH
21969: LD_INT 2
21971: PUSH
21972: LD_INT 3
21974: PUSH
21975: LD_INT 4
21977: PUSH
21978: LD_INT 5
21980: PUSH
21981: LD_INT 6
21983: PUSH
21984: LD_INT 7
21986: PUSH
21987: LD_INT 8
21989: PUSH
21990: LD_INT 9
21992: PUSH
21993: LD_INT 10
21995: PUSH
21996: LD_INT 11
21998: PUSH
21999: LD_INT 12
22001: PUSH
22002: LD_INT 13
22004: PUSH
22005: LD_INT 14
22007: PUSH
22008: LD_INT 15
22010: PUSH
22011: LD_INT 16
22013: PUSH
22014: LD_INT 17
22016: PUSH
22017: LD_INT 18
22019: PUSH
22020: LD_INT 19
22022: PUSH
22023: LD_INT 20
22025: PUSH
22026: LD_INT 21
22028: PUSH
22029: LD_INT 22
22031: PUSH
22032: LD_INT 23
22034: PUSH
22035: LD_INT 24
22037: PUSH
22038: LD_INT 25
22040: PUSH
22041: LD_INT 26
22043: PUSH
22044: LD_INT 27
22046: PUSH
22047: LD_INT 28
22049: PUSH
22050: LD_INT 29
22052: PUSH
22053: LD_INT 30
22055: PUSH
22056: LD_INT 31
22058: PUSH
22059: LD_INT 32
22061: PUSH
22062: LD_INT 33
22064: PUSH
22065: LD_INT 34
22067: PUSH
22068: LD_INT 35
22070: PUSH
22071: LD_INT 36
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: LIST
22080: LIST
22081: LIST
22082: LIST
22083: LIST
22084: LIST
22085: LIST
22086: LIST
22087: LIST
22088: LIST
22089: LIST
22090: LIST
22091: LIST
22092: LIST
22093: LIST
22094: LIST
22095: LIST
22096: LIST
22097: LIST
22098: LIST
22099: LIST
22100: LIST
22101: LIST
22102: LIST
22103: LIST
22104: LIST
22105: LIST
22106: LIST
22107: LIST
22108: LIST
22109: LIST
22110: LIST
22111: PUSH
22112: LD_INT 101
22114: PUSH
22115: LD_INT 102
22117: PUSH
22118: LD_INT 103
22120: PUSH
22121: LD_INT 104
22123: PUSH
22124: LD_INT 105
22126: PUSH
22127: LD_INT 106
22129: PUSH
22130: LD_INT 107
22132: PUSH
22133: LD_INT 108
22135: PUSH
22136: LD_INT 109
22138: PUSH
22139: LD_INT 110
22141: PUSH
22142: LD_INT 111
22144: PUSH
22145: LD_INT 112
22147: PUSH
22148: LD_INT 113
22150: PUSH
22151: LD_INT 114
22153: PUSH
22154: LD_INT 115
22156: PUSH
22157: EMPTY
22158: LIST
22159: LIST
22160: LIST
22161: LIST
22162: LIST
22163: LIST
22164: LIST
22165: LIST
22166: LIST
22167: LIST
22168: LIST
22169: LIST
22170: LIST
22171: LIST
22172: LIST
22173: PUSH
22174: EMPTY
22175: LIST
22176: LIST
22177: ST_TO_ADDR
22178: GO 22181
22180: POP
// end else
22181: GO 22400
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
22183: LD_ADDR_VAR 0 1
22187: PUSH
22188: LD_INT 1
22190: PUSH
22191: LD_INT 2
22193: PUSH
22194: LD_INT 3
22196: PUSH
22197: LD_INT 4
22199: PUSH
22200: LD_INT 5
22202: PUSH
22203: LD_INT 6
22205: PUSH
22206: LD_INT 7
22208: PUSH
22209: LD_INT 8
22211: PUSH
22212: LD_INT 9
22214: PUSH
22215: LD_INT 10
22217: PUSH
22218: LD_INT 11
22220: PUSH
22221: LD_INT 12
22223: PUSH
22224: LD_INT 13
22226: PUSH
22227: LD_INT 14
22229: PUSH
22230: LD_INT 15
22232: PUSH
22233: LD_INT 16
22235: PUSH
22236: LD_INT 17
22238: PUSH
22239: LD_INT 18
22241: PUSH
22242: LD_INT 19
22244: PUSH
22245: LD_INT 20
22247: PUSH
22248: LD_INT 21
22250: PUSH
22251: LD_INT 22
22253: PUSH
22254: LD_INT 23
22256: PUSH
22257: LD_INT 24
22259: PUSH
22260: LD_INT 25
22262: PUSH
22263: LD_INT 26
22265: PUSH
22266: LD_INT 27
22268: PUSH
22269: LD_INT 28
22271: PUSH
22272: LD_INT 29
22274: PUSH
22275: LD_INT 30
22277: PUSH
22278: LD_INT 31
22280: PUSH
22281: LD_INT 32
22283: PUSH
22284: LD_INT 33
22286: PUSH
22287: LD_INT 34
22289: PUSH
22290: LD_INT 35
22292: PUSH
22293: LD_INT 36
22295: PUSH
22296: EMPTY
22297: LIST
22298: LIST
22299: LIST
22300: LIST
22301: LIST
22302: LIST
22303: LIST
22304: LIST
22305: LIST
22306: LIST
22307: LIST
22308: LIST
22309: LIST
22310: LIST
22311: LIST
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: LIST
22317: LIST
22318: LIST
22319: LIST
22320: LIST
22321: LIST
22322: LIST
22323: LIST
22324: LIST
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: LIST
22330: LIST
22331: LIST
22332: LIST
22333: PUSH
22334: LD_INT 101
22336: PUSH
22337: LD_INT 102
22339: PUSH
22340: LD_INT 103
22342: PUSH
22343: LD_INT 104
22345: PUSH
22346: LD_INT 105
22348: PUSH
22349: LD_INT 106
22351: PUSH
22352: LD_INT 107
22354: PUSH
22355: LD_INT 108
22357: PUSH
22358: LD_INT 109
22360: PUSH
22361: LD_INT 110
22363: PUSH
22364: LD_INT 111
22366: PUSH
22367: LD_INT 112
22369: PUSH
22370: LD_INT 113
22372: PUSH
22373: LD_INT 114
22375: PUSH
22376: LD_INT 115
22378: PUSH
22379: EMPTY
22380: LIST
22381: LIST
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: LIST
22387: LIST
22388: LIST
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: LIST
22394: LIST
22395: PUSH
22396: EMPTY
22397: LIST
22398: LIST
22399: ST_TO_ADDR
// if result then
22400: LD_VAR 0 1
22404: IFFALSE 22693
// begin normal :=  ;
22406: LD_ADDR_VAR 0 3
22410: PUSH
22411: LD_STRING 
22413: ST_TO_ADDR
// hardcore :=  ;
22414: LD_ADDR_VAR 0 4
22418: PUSH
22419: LD_STRING 
22421: ST_TO_ADDR
// for i = 1 to normalCounter do
22422: LD_ADDR_VAR 0 5
22426: PUSH
22427: DOUBLE
22428: LD_INT 1
22430: DEC
22431: ST_TO_ADDR
22432: LD_EXP 56
22436: PUSH
22437: FOR_TO
22438: IFFALSE 22539
// begin tmp := 0 ;
22440: LD_ADDR_VAR 0 2
22444: PUSH
22445: LD_STRING 0
22447: ST_TO_ADDR
// if result [ 1 ] then
22448: LD_VAR 0 1
22452: PUSH
22453: LD_INT 1
22455: ARRAY
22456: IFFALSE 22521
// if result [ 1 ] [ 1 ] = i then
22458: LD_VAR 0 1
22462: PUSH
22463: LD_INT 1
22465: ARRAY
22466: PUSH
22467: LD_INT 1
22469: ARRAY
22470: PUSH
22471: LD_VAR 0 5
22475: EQUAL
22476: IFFALSE 22521
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22478: LD_ADDR_VAR 0 1
22482: PUSH
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: LD_VAR 0 1
22495: PUSH
22496: LD_INT 1
22498: ARRAY
22499: PPUSH
22500: LD_INT 1
22502: PPUSH
22503: CALL_OW 3
22507: PPUSH
22508: CALL_OW 1
22512: ST_TO_ADDR
// tmp := 1 ;
22513: LD_ADDR_VAR 0 2
22517: PUSH
22518: LD_STRING 1
22520: ST_TO_ADDR
// end ; normal := normal & tmp ;
22521: LD_ADDR_VAR 0 3
22525: PUSH
22526: LD_VAR 0 3
22530: PUSH
22531: LD_VAR 0 2
22535: STR
22536: ST_TO_ADDR
// end ;
22537: GO 22437
22539: POP
22540: POP
// for i = 1 to hardcoreCounter do
22541: LD_ADDR_VAR 0 5
22545: PUSH
22546: DOUBLE
22547: LD_INT 1
22549: DEC
22550: ST_TO_ADDR
22551: LD_EXP 57
22555: PUSH
22556: FOR_TO
22557: IFFALSE 22662
// begin tmp := 0 ;
22559: LD_ADDR_VAR 0 2
22563: PUSH
22564: LD_STRING 0
22566: ST_TO_ADDR
// if result [ 2 ] then
22567: LD_VAR 0 1
22571: PUSH
22572: LD_INT 2
22574: ARRAY
22575: IFFALSE 22644
// if result [ 2 ] [ 1 ] = 100 + i then
22577: LD_VAR 0 1
22581: PUSH
22582: LD_INT 2
22584: ARRAY
22585: PUSH
22586: LD_INT 1
22588: ARRAY
22589: PUSH
22590: LD_INT 100
22592: PUSH
22593: LD_VAR 0 5
22597: PLUS
22598: EQUAL
22599: IFFALSE 22644
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22601: LD_ADDR_VAR 0 1
22605: PUSH
22606: LD_VAR 0 1
22610: PPUSH
22611: LD_INT 2
22613: PPUSH
22614: LD_VAR 0 1
22618: PUSH
22619: LD_INT 2
22621: ARRAY
22622: PPUSH
22623: LD_INT 1
22625: PPUSH
22626: CALL_OW 3
22630: PPUSH
22631: CALL_OW 1
22635: ST_TO_ADDR
// tmp := 1 ;
22636: LD_ADDR_VAR 0 2
22640: PUSH
22641: LD_STRING 1
22643: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22644: LD_ADDR_VAR 0 4
22648: PUSH
22649: LD_VAR 0 4
22653: PUSH
22654: LD_VAR 0 2
22658: STR
22659: ST_TO_ADDR
// end ;
22660: GO 22556
22662: POP
22663: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22664: LD_STRING getStreamItemsFromMission("
22666: PUSH
22667: LD_VAR 0 3
22671: STR
22672: PUSH
22673: LD_STRING ","
22675: STR
22676: PUSH
22677: LD_VAR 0 4
22681: STR
22682: PUSH
22683: LD_STRING ")
22685: STR
22686: PPUSH
22687: CALL_OW 559
// end else
22691: GO 22700
// ToLua ( getStreamItemsFromMission("","") ) ;
22693: LD_STRING getStreamItemsFromMission("","")
22695: PPUSH
22696: CALL_OW 559
// end ;
22700: LD_VAR 0 1
22704: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22705: LD_VAR 0 2
22709: PUSH
22710: LD_INT 100
22712: EQUAL
22713: IFFALSE 23662
// begin if not StreamModeActive then
22715: LD_EXP 55
22719: NOT
22720: IFFALSE 22730
// StreamModeActive := true ;
22722: LD_ADDR_EXP 55
22726: PUSH
22727: LD_INT 1
22729: ST_TO_ADDR
// if p3 = 0 then
22730: LD_VAR 0 3
22734: PUSH
22735: LD_INT 0
22737: EQUAL
22738: IFFALSE 22744
// InitStreamMode ;
22740: CALL 18783 0 0
// if p3 = 1 then
22744: LD_VAR 0 3
22748: PUSH
22749: LD_INT 1
22751: EQUAL
22752: IFFALSE 22762
// sRocket := true ;
22754: LD_ADDR_EXP 60
22758: PUSH
22759: LD_INT 1
22761: ST_TO_ADDR
// if p3 = 2 then
22762: LD_VAR 0 3
22766: PUSH
22767: LD_INT 2
22769: EQUAL
22770: IFFALSE 22780
// sSpeed := true ;
22772: LD_ADDR_EXP 59
22776: PUSH
22777: LD_INT 1
22779: ST_TO_ADDR
// if p3 = 3 then
22780: LD_VAR 0 3
22784: PUSH
22785: LD_INT 3
22787: EQUAL
22788: IFFALSE 22798
// sEngine := true ;
22790: LD_ADDR_EXP 61
22794: PUSH
22795: LD_INT 1
22797: ST_TO_ADDR
// if p3 = 4 then
22798: LD_VAR 0 3
22802: PUSH
22803: LD_INT 4
22805: EQUAL
22806: IFFALSE 22816
// sSpec := true ;
22808: LD_ADDR_EXP 58
22812: PUSH
22813: LD_INT 1
22815: ST_TO_ADDR
// if p3 = 5 then
22816: LD_VAR 0 3
22820: PUSH
22821: LD_INT 5
22823: EQUAL
22824: IFFALSE 22834
// sLevel := true ;
22826: LD_ADDR_EXP 62
22830: PUSH
22831: LD_INT 1
22833: ST_TO_ADDR
// if p3 = 6 then
22834: LD_VAR 0 3
22838: PUSH
22839: LD_INT 6
22841: EQUAL
22842: IFFALSE 22852
// sArmoury := true ;
22844: LD_ADDR_EXP 63
22848: PUSH
22849: LD_INT 1
22851: ST_TO_ADDR
// if p3 = 7 then
22852: LD_VAR 0 3
22856: PUSH
22857: LD_INT 7
22859: EQUAL
22860: IFFALSE 22870
// sRadar := true ;
22862: LD_ADDR_EXP 64
22866: PUSH
22867: LD_INT 1
22869: ST_TO_ADDR
// if p3 = 8 then
22870: LD_VAR 0 3
22874: PUSH
22875: LD_INT 8
22877: EQUAL
22878: IFFALSE 22888
// sBunker := true ;
22880: LD_ADDR_EXP 65
22884: PUSH
22885: LD_INT 1
22887: ST_TO_ADDR
// if p3 = 9 then
22888: LD_VAR 0 3
22892: PUSH
22893: LD_INT 9
22895: EQUAL
22896: IFFALSE 22906
// sHack := true ;
22898: LD_ADDR_EXP 66
22902: PUSH
22903: LD_INT 1
22905: ST_TO_ADDR
// if p3 = 10 then
22906: LD_VAR 0 3
22910: PUSH
22911: LD_INT 10
22913: EQUAL
22914: IFFALSE 22924
// sFire := true ;
22916: LD_ADDR_EXP 67
22920: PUSH
22921: LD_INT 1
22923: ST_TO_ADDR
// if p3 = 11 then
22924: LD_VAR 0 3
22928: PUSH
22929: LD_INT 11
22931: EQUAL
22932: IFFALSE 22942
// sRefresh := true ;
22934: LD_ADDR_EXP 68
22938: PUSH
22939: LD_INT 1
22941: ST_TO_ADDR
// if p3 = 12 then
22942: LD_VAR 0 3
22946: PUSH
22947: LD_INT 12
22949: EQUAL
22950: IFFALSE 22960
// sExp := true ;
22952: LD_ADDR_EXP 69
22956: PUSH
22957: LD_INT 1
22959: ST_TO_ADDR
// if p3 = 13 then
22960: LD_VAR 0 3
22964: PUSH
22965: LD_INT 13
22967: EQUAL
22968: IFFALSE 22978
// sDepot := true ;
22970: LD_ADDR_EXP 70
22974: PUSH
22975: LD_INT 1
22977: ST_TO_ADDR
// if p3 = 14 then
22978: LD_VAR 0 3
22982: PUSH
22983: LD_INT 14
22985: EQUAL
22986: IFFALSE 22996
// sFlag := true ;
22988: LD_ADDR_EXP 71
22992: PUSH
22993: LD_INT 1
22995: ST_TO_ADDR
// if p3 = 15 then
22996: LD_VAR 0 3
23000: PUSH
23001: LD_INT 15
23003: EQUAL
23004: IFFALSE 23014
// sKamikadze := true ;
23006: LD_ADDR_EXP 79
23010: PUSH
23011: LD_INT 1
23013: ST_TO_ADDR
// if p3 = 16 then
23014: LD_VAR 0 3
23018: PUSH
23019: LD_INT 16
23021: EQUAL
23022: IFFALSE 23032
// sTroll := true ;
23024: LD_ADDR_EXP 80
23028: PUSH
23029: LD_INT 1
23031: ST_TO_ADDR
// if p3 = 17 then
23032: LD_VAR 0 3
23036: PUSH
23037: LD_INT 17
23039: EQUAL
23040: IFFALSE 23050
// sSlow := true ;
23042: LD_ADDR_EXP 81
23046: PUSH
23047: LD_INT 1
23049: ST_TO_ADDR
// if p3 = 18 then
23050: LD_VAR 0 3
23054: PUSH
23055: LD_INT 18
23057: EQUAL
23058: IFFALSE 23068
// sLack := true ;
23060: LD_ADDR_EXP 82
23064: PUSH
23065: LD_INT 1
23067: ST_TO_ADDR
// if p3 = 19 then
23068: LD_VAR 0 3
23072: PUSH
23073: LD_INT 19
23075: EQUAL
23076: IFFALSE 23086
// sTank := true ;
23078: LD_ADDR_EXP 84
23082: PUSH
23083: LD_INT 1
23085: ST_TO_ADDR
// if p3 = 20 then
23086: LD_VAR 0 3
23090: PUSH
23091: LD_INT 20
23093: EQUAL
23094: IFFALSE 23104
// sRemote := true ;
23096: LD_ADDR_EXP 85
23100: PUSH
23101: LD_INT 1
23103: ST_TO_ADDR
// if p3 = 21 then
23104: LD_VAR 0 3
23108: PUSH
23109: LD_INT 21
23111: EQUAL
23112: IFFALSE 23122
// sPowell := true ;
23114: LD_ADDR_EXP 86
23118: PUSH
23119: LD_INT 1
23121: ST_TO_ADDR
// if p3 = 22 then
23122: LD_VAR 0 3
23126: PUSH
23127: LD_INT 22
23129: EQUAL
23130: IFFALSE 23140
// sTeleport := true ;
23132: LD_ADDR_EXP 89
23136: PUSH
23137: LD_INT 1
23139: ST_TO_ADDR
// if p3 = 23 then
23140: LD_VAR 0 3
23144: PUSH
23145: LD_INT 23
23147: EQUAL
23148: IFFALSE 23158
// sOilTower := true ;
23150: LD_ADDR_EXP 91
23154: PUSH
23155: LD_INT 1
23157: ST_TO_ADDR
// if p3 = 24 then
23158: LD_VAR 0 3
23162: PUSH
23163: LD_INT 24
23165: EQUAL
23166: IFFALSE 23176
// sShovel := true ;
23168: LD_ADDR_EXP 92
23172: PUSH
23173: LD_INT 1
23175: ST_TO_ADDR
// if p3 = 25 then
23176: LD_VAR 0 3
23180: PUSH
23181: LD_INT 25
23183: EQUAL
23184: IFFALSE 23194
// sSheik := true ;
23186: LD_ADDR_EXP 93
23190: PUSH
23191: LD_INT 1
23193: ST_TO_ADDR
// if p3 = 26 then
23194: LD_VAR 0 3
23198: PUSH
23199: LD_INT 26
23201: EQUAL
23202: IFFALSE 23212
// sEarthquake := true ;
23204: LD_ADDR_EXP 95
23208: PUSH
23209: LD_INT 1
23211: ST_TO_ADDR
// if p3 = 27 then
23212: LD_VAR 0 3
23216: PUSH
23217: LD_INT 27
23219: EQUAL
23220: IFFALSE 23230
// sAI := true ;
23222: LD_ADDR_EXP 96
23226: PUSH
23227: LD_INT 1
23229: ST_TO_ADDR
// if p3 = 28 then
23230: LD_VAR 0 3
23234: PUSH
23235: LD_INT 28
23237: EQUAL
23238: IFFALSE 23248
// sCargo := true ;
23240: LD_ADDR_EXP 99
23244: PUSH
23245: LD_INT 1
23247: ST_TO_ADDR
// if p3 = 29 then
23248: LD_VAR 0 3
23252: PUSH
23253: LD_INT 29
23255: EQUAL
23256: IFFALSE 23266
// sDLaser := true ;
23258: LD_ADDR_EXP 100
23262: PUSH
23263: LD_INT 1
23265: ST_TO_ADDR
// if p3 = 30 then
23266: LD_VAR 0 3
23270: PUSH
23271: LD_INT 30
23273: EQUAL
23274: IFFALSE 23284
// sExchange := true ;
23276: LD_ADDR_EXP 101
23280: PUSH
23281: LD_INT 1
23283: ST_TO_ADDR
// if p3 = 31 then
23284: LD_VAR 0 3
23288: PUSH
23289: LD_INT 31
23291: EQUAL
23292: IFFALSE 23302
// sFac := true ;
23294: LD_ADDR_EXP 102
23298: PUSH
23299: LD_INT 1
23301: ST_TO_ADDR
// if p3 = 32 then
23302: LD_VAR 0 3
23306: PUSH
23307: LD_INT 32
23309: EQUAL
23310: IFFALSE 23320
// sPower := true ;
23312: LD_ADDR_EXP 103
23316: PUSH
23317: LD_INT 1
23319: ST_TO_ADDR
// if p3 = 33 then
23320: LD_VAR 0 3
23324: PUSH
23325: LD_INT 33
23327: EQUAL
23328: IFFALSE 23338
// sRandom := true ;
23330: LD_ADDR_EXP 104
23334: PUSH
23335: LD_INT 1
23337: ST_TO_ADDR
// if p3 = 34 then
23338: LD_VAR 0 3
23342: PUSH
23343: LD_INT 34
23345: EQUAL
23346: IFFALSE 23356
// sShield := true ;
23348: LD_ADDR_EXP 105
23352: PUSH
23353: LD_INT 1
23355: ST_TO_ADDR
// if p3 = 35 then
23356: LD_VAR 0 3
23360: PUSH
23361: LD_INT 35
23363: EQUAL
23364: IFFALSE 23374
// sTime := true ;
23366: LD_ADDR_EXP 106
23370: PUSH
23371: LD_INT 1
23373: ST_TO_ADDR
// if p3 = 36 then
23374: LD_VAR 0 3
23378: PUSH
23379: LD_INT 36
23381: EQUAL
23382: IFFALSE 23392
// sTools := true ;
23384: LD_ADDR_EXP 107
23388: PUSH
23389: LD_INT 1
23391: ST_TO_ADDR
// if p3 = 101 then
23392: LD_VAR 0 3
23396: PUSH
23397: LD_INT 101
23399: EQUAL
23400: IFFALSE 23410
// sSold := true ;
23402: LD_ADDR_EXP 72
23406: PUSH
23407: LD_INT 1
23409: ST_TO_ADDR
// if p3 = 102 then
23410: LD_VAR 0 3
23414: PUSH
23415: LD_INT 102
23417: EQUAL
23418: IFFALSE 23428
// sDiff := true ;
23420: LD_ADDR_EXP 73
23424: PUSH
23425: LD_INT 1
23427: ST_TO_ADDR
// if p3 = 103 then
23428: LD_VAR 0 3
23432: PUSH
23433: LD_INT 103
23435: EQUAL
23436: IFFALSE 23446
// sFog := true ;
23438: LD_ADDR_EXP 76
23442: PUSH
23443: LD_INT 1
23445: ST_TO_ADDR
// if p3 = 104 then
23446: LD_VAR 0 3
23450: PUSH
23451: LD_INT 104
23453: EQUAL
23454: IFFALSE 23464
// sReset := true ;
23456: LD_ADDR_EXP 77
23460: PUSH
23461: LD_INT 1
23463: ST_TO_ADDR
// if p3 = 105 then
23464: LD_VAR 0 3
23468: PUSH
23469: LD_INT 105
23471: EQUAL
23472: IFFALSE 23482
// sSun := true ;
23474: LD_ADDR_EXP 78
23478: PUSH
23479: LD_INT 1
23481: ST_TO_ADDR
// if p3 = 106 then
23482: LD_VAR 0 3
23486: PUSH
23487: LD_INT 106
23489: EQUAL
23490: IFFALSE 23500
// sTiger := true ;
23492: LD_ADDR_EXP 74
23496: PUSH
23497: LD_INT 1
23499: ST_TO_ADDR
// if p3 = 107 then
23500: LD_VAR 0 3
23504: PUSH
23505: LD_INT 107
23507: EQUAL
23508: IFFALSE 23518
// sBomb := true ;
23510: LD_ADDR_EXP 75
23514: PUSH
23515: LD_INT 1
23517: ST_TO_ADDR
// if p3 = 108 then
23518: LD_VAR 0 3
23522: PUSH
23523: LD_INT 108
23525: EQUAL
23526: IFFALSE 23536
// sWound := true ;
23528: LD_ADDR_EXP 83
23532: PUSH
23533: LD_INT 1
23535: ST_TO_ADDR
// if p3 = 109 then
23536: LD_VAR 0 3
23540: PUSH
23541: LD_INT 109
23543: EQUAL
23544: IFFALSE 23554
// sBetray := true ;
23546: LD_ADDR_EXP 87
23550: PUSH
23551: LD_INT 1
23553: ST_TO_ADDR
// if p3 = 110 then
23554: LD_VAR 0 3
23558: PUSH
23559: LD_INT 110
23561: EQUAL
23562: IFFALSE 23572
// sContamin := true ;
23564: LD_ADDR_EXP 88
23568: PUSH
23569: LD_INT 1
23571: ST_TO_ADDR
// if p3 = 111 then
23572: LD_VAR 0 3
23576: PUSH
23577: LD_INT 111
23579: EQUAL
23580: IFFALSE 23590
// sOil := true ;
23582: LD_ADDR_EXP 90
23586: PUSH
23587: LD_INT 1
23589: ST_TO_ADDR
// if p3 = 112 then
23590: LD_VAR 0 3
23594: PUSH
23595: LD_INT 112
23597: EQUAL
23598: IFFALSE 23608
// sStu := true ;
23600: LD_ADDR_EXP 94
23604: PUSH
23605: LD_INT 1
23607: ST_TO_ADDR
// if p3 = 113 then
23608: LD_VAR 0 3
23612: PUSH
23613: LD_INT 113
23615: EQUAL
23616: IFFALSE 23626
// sBazooka := true ;
23618: LD_ADDR_EXP 97
23622: PUSH
23623: LD_INT 1
23625: ST_TO_ADDR
// if p3 = 114 then
23626: LD_VAR 0 3
23630: PUSH
23631: LD_INT 114
23633: EQUAL
23634: IFFALSE 23644
// sMortar := true ;
23636: LD_ADDR_EXP 98
23640: PUSH
23641: LD_INT 1
23643: ST_TO_ADDR
// if p3 = 115 then
23644: LD_VAR 0 3
23648: PUSH
23649: LD_INT 115
23651: EQUAL
23652: IFFALSE 23662
// sRanger := true ;
23654: LD_ADDR_EXP 108
23658: PUSH
23659: LD_INT 1
23661: ST_TO_ADDR
// end ; end ;
23662: PPOPN 6
23664: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23665: LD_EXP 55
23669: PUSH
23670: LD_EXP 60
23674: AND
23675: IFFALSE 23799
23677: GO 23679
23679: DISABLE
23680: LD_INT 0
23682: PPUSH
23683: PPUSH
// begin enable ;
23684: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23685: LD_ADDR_VAR 0 2
23689: PUSH
23690: LD_INT 22
23692: PUSH
23693: LD_OWVAR 2
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PUSH
23702: LD_INT 2
23704: PUSH
23705: LD_INT 34
23707: PUSH
23708: LD_INT 7
23710: PUSH
23711: EMPTY
23712: LIST
23713: LIST
23714: PUSH
23715: LD_INT 34
23717: PUSH
23718: LD_INT 45
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: PUSH
23725: LD_INT 34
23727: PUSH
23728: LD_INT 28
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: PUSH
23735: LD_INT 34
23737: PUSH
23738: LD_INT 47
23740: PUSH
23741: EMPTY
23742: LIST
23743: LIST
23744: PUSH
23745: EMPTY
23746: LIST
23747: LIST
23748: LIST
23749: LIST
23750: LIST
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: PPUSH
23756: CALL_OW 69
23760: ST_TO_ADDR
// if not tmp then
23761: LD_VAR 0 2
23765: NOT
23766: IFFALSE 23770
// exit ;
23768: GO 23799
// for i in tmp do
23770: LD_ADDR_VAR 0 1
23774: PUSH
23775: LD_VAR 0 2
23779: PUSH
23780: FOR_IN
23781: IFFALSE 23797
// begin SetLives ( i , 0 ) ;
23783: LD_VAR 0 1
23787: PPUSH
23788: LD_INT 0
23790: PPUSH
23791: CALL_OW 234
// end ;
23795: GO 23780
23797: POP
23798: POP
// end ;
23799: PPOPN 2
23801: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23802: LD_EXP 55
23806: PUSH
23807: LD_EXP 61
23811: AND
23812: IFFALSE 23896
23814: GO 23816
23816: DISABLE
23817: LD_INT 0
23819: PPUSH
23820: PPUSH
// begin enable ;
23821: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23822: LD_ADDR_VAR 0 2
23826: PUSH
23827: LD_INT 22
23829: PUSH
23830: LD_OWVAR 2
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 32
23841: PUSH
23842: LD_INT 3
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: ST_TO_ADDR
// if not tmp then
23858: LD_VAR 0 2
23862: NOT
23863: IFFALSE 23867
// exit ;
23865: GO 23896
// for i in tmp do
23867: LD_ADDR_VAR 0 1
23871: PUSH
23872: LD_VAR 0 2
23876: PUSH
23877: FOR_IN
23878: IFFALSE 23894
// begin SetLives ( i , 0 ) ;
23880: LD_VAR 0 1
23884: PPUSH
23885: LD_INT 0
23887: PPUSH
23888: CALL_OW 234
// end ;
23892: GO 23877
23894: POP
23895: POP
// end ;
23896: PPOPN 2
23898: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23899: LD_EXP 55
23903: PUSH
23904: LD_EXP 58
23908: AND
23909: IFFALSE 24002
23911: GO 23913
23913: DISABLE
23914: LD_INT 0
23916: PPUSH
// begin enable ;
23917: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23918: LD_ADDR_VAR 0 1
23922: PUSH
23923: LD_INT 22
23925: PUSH
23926: LD_OWVAR 2
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: PUSH
23935: LD_INT 2
23937: PUSH
23938: LD_INT 25
23940: PUSH
23941: LD_INT 5
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: PUSH
23948: LD_INT 25
23950: PUSH
23951: LD_INT 9
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: LD_INT 25
23960: PUSH
23961: LD_INT 8
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: LIST
23972: LIST
23973: PUSH
23974: EMPTY
23975: LIST
23976: LIST
23977: PPUSH
23978: CALL_OW 69
23982: PUSH
23983: FOR_IN
23984: IFFALSE 24000
// begin SetClass ( i , 1 ) ;
23986: LD_VAR 0 1
23990: PPUSH
23991: LD_INT 1
23993: PPUSH
23994: CALL_OW 336
// end ;
23998: GO 23983
24000: POP
24001: POP
// end ;
24002: PPOPN 1
24004: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
24005: LD_EXP 55
24009: PUSH
24010: LD_EXP 59
24014: AND
24015: PUSH
24016: LD_OWVAR 65
24020: PUSH
24021: LD_INT 7
24023: LESS
24024: AND
24025: IFFALSE 24039
24027: GO 24029
24029: DISABLE
// begin enable ;
24030: ENABLE
// game_speed := 7 ;
24031: LD_ADDR_OWVAR 65
24035: PUSH
24036: LD_INT 7
24038: ST_TO_ADDR
// end ;
24039: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
24040: LD_EXP 55
24044: PUSH
24045: LD_EXP 62
24049: AND
24050: IFFALSE 24252
24052: GO 24054
24054: DISABLE
24055: LD_INT 0
24057: PPUSH
24058: PPUSH
24059: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
24060: LD_ADDR_VAR 0 3
24064: PUSH
24065: LD_INT 81
24067: PUSH
24068: LD_OWVAR 2
24072: PUSH
24073: EMPTY
24074: LIST
24075: LIST
24076: PUSH
24077: LD_INT 21
24079: PUSH
24080: LD_INT 1
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: PPUSH
24091: CALL_OW 69
24095: ST_TO_ADDR
// if not tmp then
24096: LD_VAR 0 3
24100: NOT
24101: IFFALSE 24105
// exit ;
24103: GO 24252
// if tmp > 5 then
24105: LD_VAR 0 3
24109: PUSH
24110: LD_INT 5
24112: GREATER
24113: IFFALSE 24125
// k := 5 else
24115: LD_ADDR_VAR 0 2
24119: PUSH
24120: LD_INT 5
24122: ST_TO_ADDR
24123: GO 24135
// k := tmp ;
24125: LD_ADDR_VAR 0 2
24129: PUSH
24130: LD_VAR 0 3
24134: ST_TO_ADDR
// for i := 1 to k do
24135: LD_ADDR_VAR 0 1
24139: PUSH
24140: DOUBLE
24141: LD_INT 1
24143: DEC
24144: ST_TO_ADDR
24145: LD_VAR 0 2
24149: PUSH
24150: FOR_TO
24151: IFFALSE 24250
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
24153: LD_VAR 0 3
24157: PUSH
24158: LD_VAR 0 1
24162: ARRAY
24163: PPUSH
24164: LD_VAR 0 1
24168: PUSH
24169: LD_INT 4
24171: MOD
24172: PUSH
24173: LD_INT 1
24175: PLUS
24176: PPUSH
24177: CALL_OW 259
24181: PUSH
24182: LD_INT 10
24184: LESS
24185: IFFALSE 24248
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
24187: LD_VAR 0 3
24191: PUSH
24192: LD_VAR 0 1
24196: ARRAY
24197: PPUSH
24198: LD_VAR 0 1
24202: PUSH
24203: LD_INT 4
24205: MOD
24206: PUSH
24207: LD_INT 1
24209: PLUS
24210: PPUSH
24211: LD_VAR 0 3
24215: PUSH
24216: LD_VAR 0 1
24220: ARRAY
24221: PPUSH
24222: LD_VAR 0 1
24226: PUSH
24227: LD_INT 4
24229: MOD
24230: PUSH
24231: LD_INT 1
24233: PLUS
24234: PPUSH
24235: CALL_OW 259
24239: PUSH
24240: LD_INT 1
24242: PLUS
24243: PPUSH
24244: CALL_OW 237
24248: GO 24150
24250: POP
24251: POP
// end ;
24252: PPOPN 3
24254: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
24255: LD_EXP 55
24259: PUSH
24260: LD_EXP 63
24264: AND
24265: IFFALSE 24285
24267: GO 24269
24269: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
24270: LD_INT 4
24272: PPUSH
24273: LD_OWVAR 2
24277: PPUSH
24278: LD_INT 0
24280: PPUSH
24281: CALL_OW 324
24285: END
// every 0 0$1 trigger StreamModeActive and sShovel do
24286: LD_EXP 55
24290: PUSH
24291: LD_EXP 92
24295: AND
24296: IFFALSE 24316
24298: GO 24300
24300: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
24301: LD_INT 19
24303: PPUSH
24304: LD_OWVAR 2
24308: PPUSH
24309: LD_INT 0
24311: PPUSH
24312: CALL_OW 324
24316: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24317: LD_EXP 55
24321: PUSH
24322: LD_EXP 64
24326: AND
24327: IFFALSE 24429
24329: GO 24331
24331: DISABLE
24332: LD_INT 0
24334: PPUSH
24335: PPUSH
// begin enable ;
24336: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24337: LD_ADDR_VAR 0 2
24341: PUSH
24342: LD_INT 22
24344: PUSH
24345: LD_OWVAR 2
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: PUSH
24354: LD_INT 2
24356: PUSH
24357: LD_INT 34
24359: PUSH
24360: LD_INT 11
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: PUSH
24367: LD_INT 34
24369: PUSH
24370: LD_INT 30
24372: PUSH
24373: EMPTY
24374: LIST
24375: LIST
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: LIST
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: PPUSH
24386: CALL_OW 69
24390: ST_TO_ADDR
// if not tmp then
24391: LD_VAR 0 2
24395: NOT
24396: IFFALSE 24400
// exit ;
24398: GO 24429
// for i in tmp do
24400: LD_ADDR_VAR 0 1
24404: PUSH
24405: LD_VAR 0 2
24409: PUSH
24410: FOR_IN
24411: IFFALSE 24427
// begin SetLives ( i , 0 ) ;
24413: LD_VAR 0 1
24417: PPUSH
24418: LD_INT 0
24420: PPUSH
24421: CALL_OW 234
// end ;
24425: GO 24410
24427: POP
24428: POP
// end ;
24429: PPOPN 2
24431: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24432: LD_EXP 55
24436: PUSH
24437: LD_EXP 65
24441: AND
24442: IFFALSE 24462
24444: GO 24446
24446: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24447: LD_INT 32
24449: PPUSH
24450: LD_OWVAR 2
24454: PPUSH
24455: LD_INT 0
24457: PPUSH
24458: CALL_OW 324
24462: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24463: LD_EXP 55
24467: PUSH
24468: LD_EXP 66
24472: AND
24473: IFFALSE 24654
24475: GO 24477
24477: DISABLE
24478: LD_INT 0
24480: PPUSH
24481: PPUSH
24482: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24483: LD_ADDR_VAR 0 2
24487: PUSH
24488: LD_INT 22
24490: PUSH
24491: LD_OWVAR 2
24495: PUSH
24496: EMPTY
24497: LIST
24498: LIST
24499: PUSH
24500: LD_INT 33
24502: PUSH
24503: LD_INT 3
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PPUSH
24514: CALL_OW 69
24518: ST_TO_ADDR
// if not tmp then
24519: LD_VAR 0 2
24523: NOT
24524: IFFALSE 24528
// exit ;
24526: GO 24654
// side := 0 ;
24528: LD_ADDR_VAR 0 3
24532: PUSH
24533: LD_INT 0
24535: ST_TO_ADDR
// for i := 1 to 8 do
24536: LD_ADDR_VAR 0 1
24540: PUSH
24541: DOUBLE
24542: LD_INT 1
24544: DEC
24545: ST_TO_ADDR
24546: LD_INT 8
24548: PUSH
24549: FOR_TO
24550: IFFALSE 24598
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24552: LD_OWVAR 2
24556: PUSH
24557: LD_VAR 0 1
24561: NONEQUAL
24562: PUSH
24563: LD_OWVAR 2
24567: PPUSH
24568: LD_VAR 0 1
24572: PPUSH
24573: CALL_OW 81
24577: PUSH
24578: LD_INT 2
24580: EQUAL
24581: AND
24582: IFFALSE 24596
// begin side := i ;
24584: LD_ADDR_VAR 0 3
24588: PUSH
24589: LD_VAR 0 1
24593: ST_TO_ADDR
// break ;
24594: GO 24598
// end ;
24596: GO 24549
24598: POP
24599: POP
// if not side then
24600: LD_VAR 0 3
24604: NOT
24605: IFFALSE 24609
// exit ;
24607: GO 24654
// for i := 1 to tmp do
24609: LD_ADDR_VAR 0 1
24613: PUSH
24614: DOUBLE
24615: LD_INT 1
24617: DEC
24618: ST_TO_ADDR
24619: LD_VAR 0 2
24623: PUSH
24624: FOR_TO
24625: IFFALSE 24652
// if Prob ( 60 ) then
24627: LD_INT 60
24629: PPUSH
24630: CALL_OW 13
24634: IFFALSE 24650
// SetSide ( i , side ) ;
24636: LD_VAR 0 1
24640: PPUSH
24641: LD_VAR 0 3
24645: PPUSH
24646: CALL_OW 235
24650: GO 24624
24652: POP
24653: POP
// end ;
24654: PPOPN 3
24656: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24657: LD_EXP 55
24661: PUSH
24662: LD_EXP 68
24666: AND
24667: IFFALSE 24786
24669: GO 24671
24671: DISABLE
24672: LD_INT 0
24674: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24675: LD_ADDR_VAR 0 1
24679: PUSH
24680: LD_INT 22
24682: PUSH
24683: LD_OWVAR 2
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: PUSH
24692: LD_INT 21
24694: PUSH
24695: LD_INT 1
24697: PUSH
24698: EMPTY
24699: LIST
24700: LIST
24701: PUSH
24702: LD_INT 3
24704: PUSH
24705: LD_INT 23
24707: PUSH
24708: LD_INT 0
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: LIST
24723: PPUSH
24724: CALL_OW 69
24728: PUSH
24729: FOR_IN
24730: IFFALSE 24784
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24732: LD_VAR 0 1
24736: PPUSH
24737: CALL_OW 257
24741: PUSH
24742: LD_INT 1
24744: PUSH
24745: LD_INT 2
24747: PUSH
24748: LD_INT 3
24750: PUSH
24751: LD_INT 4
24753: PUSH
24754: EMPTY
24755: LIST
24756: LIST
24757: LIST
24758: LIST
24759: IN
24760: IFFALSE 24782
// SetClass ( un , rand ( 1 , 4 ) ) ;
24762: LD_VAR 0 1
24766: PPUSH
24767: LD_INT 1
24769: PPUSH
24770: LD_INT 4
24772: PPUSH
24773: CALL_OW 12
24777: PPUSH
24778: CALL_OW 336
24782: GO 24729
24784: POP
24785: POP
// end ;
24786: PPOPN 1
24788: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24789: LD_EXP 55
24793: PUSH
24794: LD_EXP 67
24798: AND
24799: IFFALSE 24878
24801: GO 24803
24803: DISABLE
24804: LD_INT 0
24806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24807: LD_ADDR_VAR 0 1
24811: PUSH
24812: LD_INT 22
24814: PUSH
24815: LD_OWVAR 2
24819: PUSH
24820: EMPTY
24821: LIST
24822: LIST
24823: PUSH
24824: LD_INT 21
24826: PUSH
24827: LD_INT 3
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: PUSH
24834: EMPTY
24835: LIST
24836: LIST
24837: PPUSH
24838: CALL_OW 69
24842: ST_TO_ADDR
// if not tmp then
24843: LD_VAR 0 1
24847: NOT
24848: IFFALSE 24852
// exit ;
24850: GO 24878
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24852: LD_VAR 0 1
24856: PUSH
24857: LD_INT 1
24859: PPUSH
24860: LD_VAR 0 1
24864: PPUSH
24865: CALL_OW 12
24869: ARRAY
24870: PPUSH
24871: LD_INT 100
24873: PPUSH
24874: CALL_OW 234
// end ;
24878: PPOPN 1
24880: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24881: LD_EXP 55
24885: PUSH
24886: LD_EXP 69
24890: AND
24891: IFFALSE 24989
24893: GO 24895
24895: DISABLE
24896: LD_INT 0
24898: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24899: LD_ADDR_VAR 0 1
24903: PUSH
24904: LD_INT 22
24906: PUSH
24907: LD_OWVAR 2
24911: PUSH
24912: EMPTY
24913: LIST
24914: LIST
24915: PUSH
24916: LD_INT 21
24918: PUSH
24919: LD_INT 1
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PPUSH
24930: CALL_OW 69
24934: ST_TO_ADDR
// if not tmp then
24935: LD_VAR 0 1
24939: NOT
24940: IFFALSE 24944
// exit ;
24942: GO 24989
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24944: LD_VAR 0 1
24948: PUSH
24949: LD_INT 1
24951: PPUSH
24952: LD_VAR 0 1
24956: PPUSH
24957: CALL_OW 12
24961: ARRAY
24962: PPUSH
24963: LD_INT 1
24965: PPUSH
24966: LD_INT 4
24968: PPUSH
24969: CALL_OW 12
24973: PPUSH
24974: LD_INT 3000
24976: PPUSH
24977: LD_INT 9000
24979: PPUSH
24980: CALL_OW 12
24984: PPUSH
24985: CALL_OW 492
// end ;
24989: PPOPN 1
24991: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24992: LD_EXP 55
24996: PUSH
24997: LD_EXP 70
25001: AND
25002: IFFALSE 25022
25004: GO 25006
25006: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
25007: LD_INT 1
25009: PPUSH
25010: LD_OWVAR 2
25014: PPUSH
25015: LD_INT 0
25017: PPUSH
25018: CALL_OW 324
25022: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
25023: LD_EXP 55
25027: PUSH
25028: LD_EXP 71
25032: AND
25033: IFFALSE 25116
25035: GO 25037
25037: DISABLE
25038: LD_INT 0
25040: PPUSH
25041: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
25042: LD_ADDR_VAR 0 2
25046: PUSH
25047: LD_INT 22
25049: PUSH
25050: LD_OWVAR 2
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: LD_INT 21
25061: PUSH
25062: LD_INT 3
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: PUSH
25069: EMPTY
25070: LIST
25071: LIST
25072: PPUSH
25073: CALL_OW 69
25077: ST_TO_ADDR
// if not tmp then
25078: LD_VAR 0 2
25082: NOT
25083: IFFALSE 25087
// exit ;
25085: GO 25116
// for i in tmp do
25087: LD_ADDR_VAR 0 1
25091: PUSH
25092: LD_VAR 0 2
25096: PUSH
25097: FOR_IN
25098: IFFALSE 25114
// SetBLevel ( i , 10 ) ;
25100: LD_VAR 0 1
25104: PPUSH
25105: LD_INT 10
25107: PPUSH
25108: CALL_OW 241
25112: GO 25097
25114: POP
25115: POP
// end ;
25116: PPOPN 2
25118: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
25119: LD_EXP 55
25123: PUSH
25124: LD_EXP 72
25128: AND
25129: IFFALSE 25240
25131: GO 25133
25133: DISABLE
25134: LD_INT 0
25136: PPUSH
25137: PPUSH
25138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25139: LD_ADDR_VAR 0 3
25143: PUSH
25144: LD_INT 22
25146: PUSH
25147: LD_OWVAR 2
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: PUSH
25156: LD_INT 25
25158: PUSH
25159: LD_INT 1
25161: PUSH
25162: EMPTY
25163: LIST
25164: LIST
25165: PUSH
25166: EMPTY
25167: LIST
25168: LIST
25169: PPUSH
25170: CALL_OW 69
25174: ST_TO_ADDR
// if not tmp then
25175: LD_VAR 0 3
25179: NOT
25180: IFFALSE 25184
// exit ;
25182: GO 25240
// un := tmp [ rand ( 1 , tmp ) ] ;
25184: LD_ADDR_VAR 0 2
25188: PUSH
25189: LD_VAR 0 3
25193: PUSH
25194: LD_INT 1
25196: PPUSH
25197: LD_VAR 0 3
25201: PPUSH
25202: CALL_OW 12
25206: ARRAY
25207: ST_TO_ADDR
// if Crawls ( un ) then
25208: LD_VAR 0 2
25212: PPUSH
25213: CALL_OW 318
25217: IFFALSE 25228
// ComWalk ( un ) ;
25219: LD_VAR 0 2
25223: PPUSH
25224: CALL_OW 138
// SetClass ( un , class_sniper ) ;
25228: LD_VAR 0 2
25232: PPUSH
25233: LD_INT 5
25235: PPUSH
25236: CALL_OW 336
// end ;
25240: PPOPN 3
25242: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
25243: LD_EXP 55
25247: PUSH
25248: LD_EXP 73
25252: AND
25253: PUSH
25254: LD_OWVAR 67
25258: PUSH
25259: LD_INT 3
25261: LESS
25262: AND
25263: IFFALSE 25282
25265: GO 25267
25267: DISABLE
// Difficulty := Difficulty + 1 ;
25268: LD_ADDR_OWVAR 67
25272: PUSH
25273: LD_OWVAR 67
25277: PUSH
25278: LD_INT 1
25280: PLUS
25281: ST_TO_ADDR
25282: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
25283: LD_EXP 55
25287: PUSH
25288: LD_EXP 74
25292: AND
25293: IFFALSE 25396
25295: GO 25297
25297: DISABLE
25298: LD_INT 0
25300: PPUSH
// begin for i := 1 to 5 do
25301: LD_ADDR_VAR 0 1
25305: PUSH
25306: DOUBLE
25307: LD_INT 1
25309: DEC
25310: ST_TO_ADDR
25311: LD_INT 5
25313: PUSH
25314: FOR_TO
25315: IFFALSE 25394
// begin uc_nation := nation_nature ;
25317: LD_ADDR_OWVAR 21
25321: PUSH
25322: LD_INT 0
25324: ST_TO_ADDR
// uc_side := 0 ;
25325: LD_ADDR_OWVAR 20
25329: PUSH
25330: LD_INT 0
25332: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25333: LD_ADDR_OWVAR 29
25337: PUSH
25338: LD_INT 12
25340: PUSH
25341: LD_INT 12
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: ST_TO_ADDR
// hc_agressivity := 20 ;
25348: LD_ADDR_OWVAR 35
25352: PUSH
25353: LD_INT 20
25355: ST_TO_ADDR
// hc_class := class_tiger ;
25356: LD_ADDR_OWVAR 28
25360: PUSH
25361: LD_INT 14
25363: ST_TO_ADDR
// hc_gallery :=  ;
25364: LD_ADDR_OWVAR 33
25368: PUSH
25369: LD_STRING 
25371: ST_TO_ADDR
// hc_name :=  ;
25372: LD_ADDR_OWVAR 26
25376: PUSH
25377: LD_STRING 
25379: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25380: CALL_OW 44
25384: PPUSH
25385: LD_INT 0
25387: PPUSH
25388: CALL_OW 51
// end ;
25392: GO 25314
25394: POP
25395: POP
// end ;
25396: PPOPN 1
25398: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25399: LD_EXP 55
25403: PUSH
25404: LD_EXP 75
25408: AND
25409: IFFALSE 25418
25411: GO 25413
25413: DISABLE
// StreamSibBomb ;
25414: CALL 25419 0 0
25418: END
// export function StreamSibBomb ; var i , x , y ; begin
25419: LD_INT 0
25421: PPUSH
25422: PPUSH
25423: PPUSH
25424: PPUSH
// result := false ;
25425: LD_ADDR_VAR 0 1
25429: PUSH
25430: LD_INT 0
25432: ST_TO_ADDR
// for i := 1 to 16 do
25433: LD_ADDR_VAR 0 2
25437: PUSH
25438: DOUBLE
25439: LD_INT 1
25441: DEC
25442: ST_TO_ADDR
25443: LD_INT 16
25445: PUSH
25446: FOR_TO
25447: IFFALSE 25646
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25449: LD_ADDR_VAR 0 3
25453: PUSH
25454: LD_INT 10
25456: PUSH
25457: LD_INT 20
25459: PUSH
25460: LD_INT 30
25462: PUSH
25463: LD_INT 40
25465: PUSH
25466: LD_INT 50
25468: PUSH
25469: LD_INT 60
25471: PUSH
25472: LD_INT 70
25474: PUSH
25475: LD_INT 80
25477: PUSH
25478: LD_INT 90
25480: PUSH
25481: LD_INT 100
25483: PUSH
25484: LD_INT 110
25486: PUSH
25487: LD_INT 120
25489: PUSH
25490: LD_INT 130
25492: PUSH
25493: LD_INT 140
25495: PUSH
25496: LD_INT 150
25498: PUSH
25499: EMPTY
25500: LIST
25501: LIST
25502: LIST
25503: LIST
25504: LIST
25505: LIST
25506: LIST
25507: LIST
25508: LIST
25509: LIST
25510: LIST
25511: LIST
25512: LIST
25513: LIST
25514: LIST
25515: PUSH
25516: LD_INT 1
25518: PPUSH
25519: LD_INT 15
25521: PPUSH
25522: CALL_OW 12
25526: ARRAY
25527: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25528: LD_ADDR_VAR 0 4
25532: PUSH
25533: LD_INT 10
25535: PUSH
25536: LD_INT 20
25538: PUSH
25539: LD_INT 30
25541: PUSH
25542: LD_INT 40
25544: PUSH
25545: LD_INT 50
25547: PUSH
25548: LD_INT 60
25550: PUSH
25551: LD_INT 70
25553: PUSH
25554: LD_INT 80
25556: PUSH
25557: LD_INT 90
25559: PUSH
25560: LD_INT 100
25562: PUSH
25563: LD_INT 110
25565: PUSH
25566: LD_INT 120
25568: PUSH
25569: LD_INT 130
25571: PUSH
25572: LD_INT 140
25574: PUSH
25575: LD_INT 150
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: LIST
25594: PUSH
25595: LD_INT 1
25597: PPUSH
25598: LD_INT 15
25600: PPUSH
25601: CALL_OW 12
25605: ARRAY
25606: ST_TO_ADDR
// if ValidHex ( x , y ) then
25607: LD_VAR 0 3
25611: PPUSH
25612: LD_VAR 0 4
25616: PPUSH
25617: CALL_OW 488
25621: IFFALSE 25644
// begin result := [ x , y ] ;
25623: LD_ADDR_VAR 0 1
25627: PUSH
25628: LD_VAR 0 3
25632: PUSH
25633: LD_VAR 0 4
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: ST_TO_ADDR
// break ;
25642: GO 25646
// end ; end ;
25644: GO 25446
25646: POP
25647: POP
// if result then
25648: LD_VAR 0 1
25652: IFFALSE 25712
// begin ToLua ( playSibBomb() ) ;
25654: LD_STRING playSibBomb()
25656: PPUSH
25657: CALL_OW 559
// wait ( 0 0$14 ) ;
25661: LD_INT 490
25663: PPUSH
25664: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25668: LD_VAR 0 1
25672: PUSH
25673: LD_INT 1
25675: ARRAY
25676: PPUSH
25677: LD_VAR 0 1
25681: PUSH
25682: LD_INT 2
25684: ARRAY
25685: PPUSH
25686: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25690: LD_VAR 0 1
25694: PUSH
25695: LD_INT 1
25697: ARRAY
25698: PPUSH
25699: LD_VAR 0 1
25703: PUSH
25704: LD_INT 2
25706: ARRAY
25707: PPUSH
25708: CALL_OW 429
// end ; end ;
25712: LD_VAR 0 1
25716: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25717: LD_EXP 55
25721: PUSH
25722: LD_EXP 77
25726: AND
25727: IFFALSE 25739
25729: GO 25731
25731: DISABLE
// YouLost (  ) ;
25732: LD_STRING 
25734: PPUSH
25735: CALL_OW 104
25739: END
// every 0 0$1 trigger StreamModeActive and sFog do
25740: LD_EXP 55
25744: PUSH
25745: LD_EXP 76
25749: AND
25750: IFFALSE 25764
25752: GO 25754
25754: DISABLE
// FogOff ( your_side ) ;
25755: LD_OWVAR 2
25759: PPUSH
25760: CALL_OW 344
25764: END
// every 0 0$1 trigger StreamModeActive and sSun do
25765: LD_EXP 55
25769: PUSH
25770: LD_EXP 78
25774: AND
25775: IFFALSE 25803
25777: GO 25779
25779: DISABLE
// begin solar_recharge_percent := 0 ;
25780: LD_ADDR_OWVAR 79
25784: PUSH
25785: LD_INT 0
25787: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25788: LD_INT 10500
25790: PPUSH
25791: CALL_OW 67
// solar_recharge_percent := 100 ;
25795: LD_ADDR_OWVAR 79
25799: PUSH
25800: LD_INT 100
25802: ST_TO_ADDR
// end ;
25803: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25804: LD_EXP 55
25808: PUSH
25809: LD_EXP 79
25813: AND
25814: IFFALSE 26053
25816: GO 25818
25818: DISABLE
25819: LD_INT 0
25821: PPUSH
25822: PPUSH
25823: PPUSH
// begin tmp := [ ] ;
25824: LD_ADDR_VAR 0 3
25828: PUSH
25829: EMPTY
25830: ST_TO_ADDR
// for i := 1 to 6 do
25831: LD_ADDR_VAR 0 1
25835: PUSH
25836: DOUBLE
25837: LD_INT 1
25839: DEC
25840: ST_TO_ADDR
25841: LD_INT 6
25843: PUSH
25844: FOR_TO
25845: IFFALSE 25950
// begin uc_nation := nation_nature ;
25847: LD_ADDR_OWVAR 21
25851: PUSH
25852: LD_INT 0
25854: ST_TO_ADDR
// uc_side := 0 ;
25855: LD_ADDR_OWVAR 20
25859: PUSH
25860: LD_INT 0
25862: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25863: LD_ADDR_OWVAR 29
25867: PUSH
25868: LD_INT 12
25870: PUSH
25871: LD_INT 12
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: ST_TO_ADDR
// hc_agressivity := 20 ;
25878: LD_ADDR_OWVAR 35
25882: PUSH
25883: LD_INT 20
25885: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25886: LD_ADDR_OWVAR 28
25890: PUSH
25891: LD_INT 17
25893: ST_TO_ADDR
// hc_gallery :=  ;
25894: LD_ADDR_OWVAR 33
25898: PUSH
25899: LD_STRING 
25901: ST_TO_ADDR
// hc_name :=  ;
25902: LD_ADDR_OWVAR 26
25906: PUSH
25907: LD_STRING 
25909: ST_TO_ADDR
// un := CreateHuman ;
25910: LD_ADDR_VAR 0 2
25914: PUSH
25915: CALL_OW 44
25919: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25920: LD_VAR 0 2
25924: PPUSH
25925: LD_INT 1
25927: PPUSH
25928: CALL_OW 51
// tmp := tmp ^ un ;
25932: LD_ADDR_VAR 0 3
25936: PUSH
25937: LD_VAR 0 3
25941: PUSH
25942: LD_VAR 0 2
25946: ADD
25947: ST_TO_ADDR
// end ;
25948: GO 25844
25950: POP
25951: POP
// repeat wait ( 0 0$1 ) ;
25952: LD_INT 35
25954: PPUSH
25955: CALL_OW 67
// for un in tmp do
25959: LD_ADDR_VAR 0 2
25963: PUSH
25964: LD_VAR 0 3
25968: PUSH
25969: FOR_IN
25970: IFFALSE 26044
// begin if IsDead ( un ) then
25972: LD_VAR 0 2
25976: PPUSH
25977: CALL_OW 301
25981: IFFALSE 26001
// begin tmp := tmp diff un ;
25983: LD_ADDR_VAR 0 3
25987: PUSH
25988: LD_VAR 0 3
25992: PUSH
25993: LD_VAR 0 2
25997: DIFF
25998: ST_TO_ADDR
// continue ;
25999: GO 25969
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
26001: LD_VAR 0 2
26005: PPUSH
26006: LD_INT 3
26008: PUSH
26009: LD_INT 22
26011: PUSH
26012: LD_INT 0
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PPUSH
26023: CALL_OW 69
26027: PPUSH
26028: LD_VAR 0 2
26032: PPUSH
26033: CALL_OW 74
26037: PPUSH
26038: CALL_OW 115
// end ;
26042: GO 25969
26044: POP
26045: POP
// until not tmp ;
26046: LD_VAR 0 3
26050: NOT
26051: IFFALSE 25952
// end ;
26053: PPOPN 3
26055: END
// every 0 0$1 trigger StreamModeActive and sTroll do
26056: LD_EXP 55
26060: PUSH
26061: LD_EXP 80
26065: AND
26066: IFFALSE 26120
26068: GO 26070
26070: DISABLE
// begin ToLua ( displayTroll(); ) ;
26071: LD_STRING displayTroll();
26073: PPUSH
26074: CALL_OW 559
// wait ( 3 3$00 ) ;
26078: LD_INT 6300
26080: PPUSH
26081: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26085: LD_STRING hideTroll();
26087: PPUSH
26088: CALL_OW 559
// wait ( 1 1$00 ) ;
26092: LD_INT 2100
26094: PPUSH
26095: CALL_OW 67
// ToLua ( displayTroll(); ) ;
26099: LD_STRING displayTroll();
26101: PPUSH
26102: CALL_OW 559
// wait ( 1 1$00 ) ;
26106: LD_INT 2100
26108: PPUSH
26109: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26113: LD_STRING hideTroll();
26115: PPUSH
26116: CALL_OW 559
// end ;
26120: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
26121: LD_EXP 55
26125: PUSH
26126: LD_EXP 81
26130: AND
26131: IFFALSE 26194
26133: GO 26135
26135: DISABLE
26136: LD_INT 0
26138: PPUSH
// begin p := 0 ;
26139: LD_ADDR_VAR 0 1
26143: PUSH
26144: LD_INT 0
26146: ST_TO_ADDR
// repeat game_speed := 1 ;
26147: LD_ADDR_OWVAR 65
26151: PUSH
26152: LD_INT 1
26154: ST_TO_ADDR
// wait ( 0 0$1 ) ;
26155: LD_INT 35
26157: PPUSH
26158: CALL_OW 67
// p := p + 1 ;
26162: LD_ADDR_VAR 0 1
26166: PUSH
26167: LD_VAR 0 1
26171: PUSH
26172: LD_INT 1
26174: PLUS
26175: ST_TO_ADDR
// until p >= 60 ;
26176: LD_VAR 0 1
26180: PUSH
26181: LD_INT 60
26183: GREATEREQUAL
26184: IFFALSE 26147
// game_speed := 4 ;
26186: LD_ADDR_OWVAR 65
26190: PUSH
26191: LD_INT 4
26193: ST_TO_ADDR
// end ;
26194: PPOPN 1
26196: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
26197: LD_EXP 55
26201: PUSH
26202: LD_EXP 82
26206: AND
26207: IFFALSE 26353
26209: GO 26211
26211: DISABLE
26212: LD_INT 0
26214: PPUSH
26215: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26216: LD_ADDR_VAR 0 1
26220: PUSH
26221: LD_INT 22
26223: PUSH
26224: LD_OWVAR 2
26228: PUSH
26229: EMPTY
26230: LIST
26231: LIST
26232: PUSH
26233: LD_INT 2
26235: PUSH
26236: LD_INT 30
26238: PUSH
26239: LD_INT 0
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: PUSH
26246: LD_INT 30
26248: PUSH
26249: LD_INT 1
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: LIST
26260: PUSH
26261: EMPTY
26262: LIST
26263: LIST
26264: PPUSH
26265: CALL_OW 69
26269: ST_TO_ADDR
// if not depot then
26270: LD_VAR 0 1
26274: NOT
26275: IFFALSE 26279
// exit ;
26277: GO 26353
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
26279: LD_ADDR_VAR 0 2
26283: PUSH
26284: LD_VAR 0 1
26288: PUSH
26289: LD_INT 1
26291: PPUSH
26292: LD_VAR 0 1
26296: PPUSH
26297: CALL_OW 12
26301: ARRAY
26302: PPUSH
26303: CALL_OW 274
26307: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
26308: LD_VAR 0 2
26312: PPUSH
26313: LD_INT 1
26315: PPUSH
26316: LD_INT 0
26318: PPUSH
26319: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26323: LD_VAR 0 2
26327: PPUSH
26328: LD_INT 2
26330: PPUSH
26331: LD_INT 0
26333: PPUSH
26334: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26338: LD_VAR 0 2
26342: PPUSH
26343: LD_INT 3
26345: PPUSH
26346: LD_INT 0
26348: PPUSH
26349: CALL_OW 277
// end ;
26353: PPOPN 2
26355: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26356: LD_EXP 55
26360: PUSH
26361: LD_EXP 83
26365: AND
26366: IFFALSE 26463
26368: GO 26370
26370: DISABLE
26371: LD_INT 0
26373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26374: LD_ADDR_VAR 0 1
26378: PUSH
26379: LD_INT 22
26381: PUSH
26382: LD_OWVAR 2
26386: PUSH
26387: EMPTY
26388: LIST
26389: LIST
26390: PUSH
26391: LD_INT 21
26393: PUSH
26394: LD_INT 1
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: LD_INT 3
26403: PUSH
26404: LD_INT 23
26406: PUSH
26407: LD_INT 0
26409: PUSH
26410: EMPTY
26411: LIST
26412: LIST
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: LIST
26422: PPUSH
26423: CALL_OW 69
26427: ST_TO_ADDR
// if not tmp then
26428: LD_VAR 0 1
26432: NOT
26433: IFFALSE 26437
// exit ;
26435: GO 26463
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26437: LD_VAR 0 1
26441: PUSH
26442: LD_INT 1
26444: PPUSH
26445: LD_VAR 0 1
26449: PPUSH
26450: CALL_OW 12
26454: ARRAY
26455: PPUSH
26456: LD_INT 200
26458: PPUSH
26459: CALL_OW 234
// end ;
26463: PPOPN 1
26465: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26466: LD_EXP 55
26470: PUSH
26471: LD_EXP 84
26475: AND
26476: IFFALSE 26555
26478: GO 26480
26480: DISABLE
26481: LD_INT 0
26483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26484: LD_ADDR_VAR 0 1
26488: PUSH
26489: LD_INT 22
26491: PUSH
26492: LD_OWVAR 2
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PUSH
26501: LD_INT 21
26503: PUSH
26504: LD_INT 2
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PPUSH
26515: CALL_OW 69
26519: ST_TO_ADDR
// if not tmp then
26520: LD_VAR 0 1
26524: NOT
26525: IFFALSE 26529
// exit ;
26527: GO 26555
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26529: LD_VAR 0 1
26533: PUSH
26534: LD_INT 1
26536: PPUSH
26537: LD_VAR 0 1
26541: PPUSH
26542: CALL_OW 12
26546: ARRAY
26547: PPUSH
26548: LD_INT 60
26550: PPUSH
26551: CALL_OW 234
// end ;
26555: PPOPN 1
26557: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26558: LD_EXP 55
26562: PUSH
26563: LD_EXP 85
26567: AND
26568: IFFALSE 26667
26570: GO 26572
26572: DISABLE
26573: LD_INT 0
26575: PPUSH
26576: PPUSH
// begin enable ;
26577: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26578: LD_ADDR_VAR 0 1
26582: PUSH
26583: LD_INT 22
26585: PUSH
26586: LD_OWVAR 2
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 61
26597: PUSH
26598: EMPTY
26599: LIST
26600: PUSH
26601: LD_INT 33
26603: PUSH
26604: LD_INT 2
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: LIST
26615: PPUSH
26616: CALL_OW 69
26620: ST_TO_ADDR
// if not tmp then
26621: LD_VAR 0 1
26625: NOT
26626: IFFALSE 26630
// exit ;
26628: GO 26667
// for i in tmp do
26630: LD_ADDR_VAR 0 2
26634: PUSH
26635: LD_VAR 0 1
26639: PUSH
26640: FOR_IN
26641: IFFALSE 26665
// if IsControledBy ( i ) then
26643: LD_VAR 0 2
26647: PPUSH
26648: CALL_OW 312
26652: IFFALSE 26663
// ComUnlink ( i ) ;
26654: LD_VAR 0 2
26658: PPUSH
26659: CALL_OW 136
26663: GO 26640
26665: POP
26666: POP
// end ;
26667: PPOPN 2
26669: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26670: LD_EXP 55
26674: PUSH
26675: LD_EXP 86
26679: AND
26680: IFFALSE 26820
26682: GO 26684
26684: DISABLE
26685: LD_INT 0
26687: PPUSH
26688: PPUSH
// begin ToLua ( displayPowell(); ) ;
26689: LD_STRING displayPowell();
26691: PPUSH
26692: CALL_OW 559
// uc_side := 0 ;
26696: LD_ADDR_OWVAR 20
26700: PUSH
26701: LD_INT 0
26703: ST_TO_ADDR
// uc_nation := 2 ;
26704: LD_ADDR_OWVAR 21
26708: PUSH
26709: LD_INT 2
26711: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26712: LD_ADDR_OWVAR 37
26716: PUSH
26717: LD_INT 14
26719: ST_TO_ADDR
// vc_engine := engine_siberite ;
26720: LD_ADDR_OWVAR 39
26724: PUSH
26725: LD_INT 3
26727: ST_TO_ADDR
// vc_control := control_apeman ;
26728: LD_ADDR_OWVAR 38
26732: PUSH
26733: LD_INT 5
26735: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26736: LD_ADDR_OWVAR 40
26740: PUSH
26741: LD_INT 29
26743: ST_TO_ADDR
// un := CreateVehicle ;
26744: LD_ADDR_VAR 0 2
26748: PUSH
26749: CALL_OW 45
26753: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26754: LD_VAR 0 2
26758: PPUSH
26759: LD_INT 1
26761: PPUSH
26762: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26766: LD_INT 35
26768: PPUSH
26769: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26773: LD_VAR 0 2
26777: PPUSH
26778: LD_INT 22
26780: PUSH
26781: LD_OWVAR 2
26785: PUSH
26786: EMPTY
26787: LIST
26788: LIST
26789: PPUSH
26790: CALL_OW 69
26794: PPUSH
26795: LD_VAR 0 2
26799: PPUSH
26800: CALL_OW 74
26804: PPUSH
26805: CALL_OW 115
// until IsDead ( un ) ;
26809: LD_VAR 0 2
26813: PPUSH
26814: CALL_OW 301
26818: IFFALSE 26766
// end ;
26820: PPOPN 2
26822: END
// every 0 0$1 trigger StreamModeActive and sStu do
26823: LD_EXP 55
26827: PUSH
26828: LD_EXP 94
26832: AND
26833: IFFALSE 26849
26835: GO 26837
26837: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26838: LD_STRING displayStucuk();
26840: PPUSH
26841: CALL_OW 559
// ResetFog ;
26845: CALL_OW 335
// end ;
26849: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26850: LD_EXP 55
26854: PUSH
26855: LD_EXP 87
26859: AND
26860: IFFALSE 27001
26862: GO 26864
26864: DISABLE
26865: LD_INT 0
26867: PPUSH
26868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26869: LD_ADDR_VAR 0 2
26873: PUSH
26874: LD_INT 22
26876: PUSH
26877: LD_OWVAR 2
26881: PUSH
26882: EMPTY
26883: LIST
26884: LIST
26885: PUSH
26886: LD_INT 21
26888: PUSH
26889: LD_INT 1
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PPUSH
26900: CALL_OW 69
26904: ST_TO_ADDR
// if not tmp then
26905: LD_VAR 0 2
26909: NOT
26910: IFFALSE 26914
// exit ;
26912: GO 27001
// un := tmp [ rand ( 1 , tmp ) ] ;
26914: LD_ADDR_VAR 0 1
26918: PUSH
26919: LD_VAR 0 2
26923: PUSH
26924: LD_INT 1
26926: PPUSH
26927: LD_VAR 0 2
26931: PPUSH
26932: CALL_OW 12
26936: ARRAY
26937: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26938: LD_VAR 0 1
26942: PPUSH
26943: LD_INT 0
26945: PPUSH
26946: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26950: LD_VAR 0 1
26954: PPUSH
26955: LD_OWVAR 3
26959: PUSH
26960: LD_VAR 0 1
26964: DIFF
26965: PPUSH
26966: LD_VAR 0 1
26970: PPUSH
26971: CALL_OW 74
26975: PPUSH
26976: CALL_OW 115
// wait ( 0 0$20 ) ;
26980: LD_INT 700
26982: PPUSH
26983: CALL_OW 67
// SetSide ( un , your_side ) ;
26987: LD_VAR 0 1
26991: PPUSH
26992: LD_OWVAR 2
26996: PPUSH
26997: CALL_OW 235
// end ;
27001: PPOPN 2
27003: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
27004: LD_EXP 55
27008: PUSH
27009: LD_EXP 88
27013: AND
27014: IFFALSE 27120
27016: GO 27018
27018: DISABLE
27019: LD_INT 0
27021: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27022: LD_ADDR_VAR 0 1
27026: PUSH
27027: LD_INT 22
27029: PUSH
27030: LD_OWVAR 2
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: LD_INT 2
27041: PUSH
27042: LD_INT 30
27044: PUSH
27045: LD_INT 0
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: LD_INT 30
27054: PUSH
27055: LD_INT 1
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: LIST
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PPUSH
27071: CALL_OW 69
27075: ST_TO_ADDR
// if not depot then
27076: LD_VAR 0 1
27080: NOT
27081: IFFALSE 27085
// exit ;
27083: GO 27120
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
27085: LD_VAR 0 1
27089: PUSH
27090: LD_INT 1
27092: ARRAY
27093: PPUSH
27094: CALL_OW 250
27098: PPUSH
27099: LD_VAR 0 1
27103: PUSH
27104: LD_INT 1
27106: ARRAY
27107: PPUSH
27108: CALL_OW 251
27112: PPUSH
27113: LD_INT 70
27115: PPUSH
27116: CALL_OW 495
// end ;
27120: PPOPN 1
27122: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
27123: LD_EXP 55
27127: PUSH
27128: LD_EXP 89
27132: AND
27133: IFFALSE 27344
27135: GO 27137
27137: DISABLE
27138: LD_INT 0
27140: PPUSH
27141: PPUSH
27142: PPUSH
27143: PPUSH
27144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27145: LD_ADDR_VAR 0 5
27149: PUSH
27150: LD_INT 22
27152: PUSH
27153: LD_OWVAR 2
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: PUSH
27162: LD_INT 21
27164: PUSH
27165: LD_INT 1
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PPUSH
27176: CALL_OW 69
27180: ST_TO_ADDR
// if not tmp then
27181: LD_VAR 0 5
27185: NOT
27186: IFFALSE 27190
// exit ;
27188: GO 27344
// for i in tmp do
27190: LD_ADDR_VAR 0 1
27194: PUSH
27195: LD_VAR 0 5
27199: PUSH
27200: FOR_IN
27201: IFFALSE 27342
// begin d := rand ( 0 , 5 ) ;
27203: LD_ADDR_VAR 0 4
27207: PUSH
27208: LD_INT 0
27210: PPUSH
27211: LD_INT 5
27213: PPUSH
27214: CALL_OW 12
27218: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
27219: LD_ADDR_VAR 0 2
27223: PUSH
27224: LD_VAR 0 1
27228: PPUSH
27229: CALL_OW 250
27233: PPUSH
27234: LD_VAR 0 4
27238: PPUSH
27239: LD_INT 3
27241: PPUSH
27242: LD_INT 12
27244: PPUSH
27245: CALL_OW 12
27249: PPUSH
27250: CALL_OW 272
27254: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
27255: LD_ADDR_VAR 0 3
27259: PUSH
27260: LD_VAR 0 1
27264: PPUSH
27265: CALL_OW 251
27269: PPUSH
27270: LD_VAR 0 4
27274: PPUSH
27275: LD_INT 3
27277: PPUSH
27278: LD_INT 12
27280: PPUSH
27281: CALL_OW 12
27285: PPUSH
27286: CALL_OW 273
27290: ST_TO_ADDR
// if ValidHex ( x , y ) then
27291: LD_VAR 0 2
27295: PPUSH
27296: LD_VAR 0 3
27300: PPUSH
27301: CALL_OW 488
27305: IFFALSE 27340
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
27307: LD_VAR 0 1
27311: PPUSH
27312: LD_VAR 0 2
27316: PPUSH
27317: LD_VAR 0 3
27321: PPUSH
27322: LD_INT 3
27324: PPUSH
27325: LD_INT 6
27327: PPUSH
27328: CALL_OW 12
27332: PPUSH
27333: LD_INT 1
27335: PPUSH
27336: CALL_OW 483
// end ;
27340: GO 27200
27342: POP
27343: POP
// end ;
27344: PPOPN 5
27346: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27347: LD_EXP 55
27351: PUSH
27352: LD_EXP 90
27356: AND
27357: IFFALSE 27451
27359: GO 27361
27361: DISABLE
27362: LD_INT 0
27364: PPUSH
27365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27366: LD_ADDR_VAR 0 2
27370: PUSH
27371: LD_INT 22
27373: PUSH
27374: LD_OWVAR 2
27378: PUSH
27379: EMPTY
27380: LIST
27381: LIST
27382: PUSH
27383: LD_INT 32
27385: PUSH
27386: LD_INT 1
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: PUSH
27393: LD_INT 21
27395: PUSH
27396: LD_INT 2
27398: PUSH
27399: EMPTY
27400: LIST
27401: LIST
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: LIST
27407: PPUSH
27408: CALL_OW 69
27412: ST_TO_ADDR
// if not tmp then
27413: LD_VAR 0 2
27417: NOT
27418: IFFALSE 27422
// exit ;
27420: GO 27451
// for i in tmp do
27422: LD_ADDR_VAR 0 1
27426: PUSH
27427: LD_VAR 0 2
27431: PUSH
27432: FOR_IN
27433: IFFALSE 27449
// SetFuel ( i , 0 ) ;
27435: LD_VAR 0 1
27439: PPUSH
27440: LD_INT 0
27442: PPUSH
27443: CALL_OW 240
27447: GO 27432
27449: POP
27450: POP
// end ;
27451: PPOPN 2
27453: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27454: LD_EXP 55
27458: PUSH
27459: LD_EXP 91
27463: AND
27464: IFFALSE 27530
27466: GO 27468
27468: DISABLE
27469: LD_INT 0
27471: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27472: LD_ADDR_VAR 0 1
27476: PUSH
27477: LD_INT 22
27479: PUSH
27480: LD_OWVAR 2
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PUSH
27489: LD_INT 30
27491: PUSH
27492: LD_INT 29
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: PUSH
27499: EMPTY
27500: LIST
27501: LIST
27502: PPUSH
27503: CALL_OW 69
27507: ST_TO_ADDR
// if not tmp then
27508: LD_VAR 0 1
27512: NOT
27513: IFFALSE 27517
// exit ;
27515: GO 27530
// DestroyUnit ( tmp [ 1 ] ) ;
27517: LD_VAR 0 1
27521: PUSH
27522: LD_INT 1
27524: ARRAY
27525: PPUSH
27526: CALL_OW 65
// end ;
27530: PPOPN 1
27532: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27533: LD_EXP 55
27537: PUSH
27538: LD_EXP 93
27542: AND
27543: IFFALSE 27672
27545: GO 27547
27547: DISABLE
27548: LD_INT 0
27550: PPUSH
// begin uc_side := 0 ;
27551: LD_ADDR_OWVAR 20
27555: PUSH
27556: LD_INT 0
27558: ST_TO_ADDR
// uc_nation := nation_arabian ;
27559: LD_ADDR_OWVAR 21
27563: PUSH
27564: LD_INT 2
27566: ST_TO_ADDR
// hc_gallery :=  ;
27567: LD_ADDR_OWVAR 33
27571: PUSH
27572: LD_STRING 
27574: ST_TO_ADDR
// hc_name :=  ;
27575: LD_ADDR_OWVAR 26
27579: PUSH
27580: LD_STRING 
27582: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27583: LD_INT 1
27585: PPUSH
27586: LD_INT 11
27588: PPUSH
27589: LD_INT 10
27591: PPUSH
27592: CALL_OW 380
// un := CreateHuman ;
27596: LD_ADDR_VAR 0 1
27600: PUSH
27601: CALL_OW 44
27605: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27606: LD_VAR 0 1
27610: PPUSH
27611: LD_INT 1
27613: PPUSH
27614: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27618: LD_INT 35
27620: PPUSH
27621: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27625: LD_VAR 0 1
27629: PPUSH
27630: LD_INT 22
27632: PUSH
27633: LD_OWVAR 2
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: PPUSH
27642: CALL_OW 69
27646: PPUSH
27647: LD_VAR 0 1
27651: PPUSH
27652: CALL_OW 74
27656: PPUSH
27657: CALL_OW 115
// until IsDead ( un ) ;
27661: LD_VAR 0 1
27665: PPUSH
27666: CALL_OW 301
27670: IFFALSE 27618
// end ;
27672: PPOPN 1
27674: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27675: LD_EXP 55
27679: PUSH
27680: LD_EXP 95
27684: AND
27685: IFFALSE 27697
27687: GO 27689
27689: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27690: LD_STRING earthquake(getX(game), 0, 32)
27692: PPUSH
27693: CALL_OW 559
27697: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27698: LD_EXP 55
27702: PUSH
27703: LD_EXP 96
27707: AND
27708: IFFALSE 27799
27710: GO 27712
27712: DISABLE
27713: LD_INT 0
27715: PPUSH
// begin enable ;
27716: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27717: LD_ADDR_VAR 0 1
27721: PUSH
27722: LD_INT 22
27724: PUSH
27725: LD_OWVAR 2
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: LD_INT 21
27736: PUSH
27737: LD_INT 2
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PUSH
27744: LD_INT 33
27746: PUSH
27747: LD_INT 3
27749: PUSH
27750: EMPTY
27751: LIST
27752: LIST
27753: PUSH
27754: EMPTY
27755: LIST
27756: LIST
27757: LIST
27758: PPUSH
27759: CALL_OW 69
27763: ST_TO_ADDR
// if not tmp then
27764: LD_VAR 0 1
27768: NOT
27769: IFFALSE 27773
// exit ;
27771: GO 27799
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27773: LD_VAR 0 1
27777: PUSH
27778: LD_INT 1
27780: PPUSH
27781: LD_VAR 0 1
27785: PPUSH
27786: CALL_OW 12
27790: ARRAY
27791: PPUSH
27792: LD_INT 1
27794: PPUSH
27795: CALL_OW 234
// end ;
27799: PPOPN 1
27801: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27802: LD_EXP 55
27806: PUSH
27807: LD_EXP 97
27811: AND
27812: IFFALSE 27953
27814: GO 27816
27816: DISABLE
27817: LD_INT 0
27819: PPUSH
27820: PPUSH
27821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27822: LD_ADDR_VAR 0 3
27826: PUSH
27827: LD_INT 22
27829: PUSH
27830: LD_OWVAR 2
27834: PUSH
27835: EMPTY
27836: LIST
27837: LIST
27838: PUSH
27839: LD_INT 25
27841: PUSH
27842: LD_INT 1
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: PPUSH
27853: CALL_OW 69
27857: ST_TO_ADDR
// if not tmp then
27858: LD_VAR 0 3
27862: NOT
27863: IFFALSE 27867
// exit ;
27865: GO 27953
// un := tmp [ rand ( 1 , tmp ) ] ;
27867: LD_ADDR_VAR 0 2
27871: PUSH
27872: LD_VAR 0 3
27876: PUSH
27877: LD_INT 1
27879: PPUSH
27880: LD_VAR 0 3
27884: PPUSH
27885: CALL_OW 12
27889: ARRAY
27890: ST_TO_ADDR
// if Crawls ( un ) then
27891: LD_VAR 0 2
27895: PPUSH
27896: CALL_OW 318
27900: IFFALSE 27911
// ComWalk ( un ) ;
27902: LD_VAR 0 2
27906: PPUSH
27907: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27911: LD_VAR 0 2
27915: PPUSH
27916: LD_INT 9
27918: PPUSH
27919: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27923: LD_INT 28
27925: PPUSH
27926: LD_OWVAR 2
27930: PPUSH
27931: LD_INT 2
27933: PPUSH
27934: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27938: LD_INT 29
27940: PPUSH
27941: LD_OWVAR 2
27945: PPUSH
27946: LD_INT 2
27948: PPUSH
27949: CALL_OW 322
// end ;
27953: PPOPN 3
27955: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27956: LD_EXP 55
27960: PUSH
27961: LD_EXP 98
27965: AND
27966: IFFALSE 28077
27968: GO 27970
27970: DISABLE
27971: LD_INT 0
27973: PPUSH
27974: PPUSH
27975: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27976: LD_ADDR_VAR 0 3
27980: PUSH
27981: LD_INT 22
27983: PUSH
27984: LD_OWVAR 2
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: LD_INT 25
27995: PUSH
27996: LD_INT 1
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PPUSH
28007: CALL_OW 69
28011: ST_TO_ADDR
// if not tmp then
28012: LD_VAR 0 3
28016: NOT
28017: IFFALSE 28021
// exit ;
28019: GO 28077
// un := tmp [ rand ( 1 , tmp ) ] ;
28021: LD_ADDR_VAR 0 2
28025: PUSH
28026: LD_VAR 0 3
28030: PUSH
28031: LD_INT 1
28033: PPUSH
28034: LD_VAR 0 3
28038: PPUSH
28039: CALL_OW 12
28043: ARRAY
28044: ST_TO_ADDR
// if Crawls ( un ) then
28045: LD_VAR 0 2
28049: PPUSH
28050: CALL_OW 318
28054: IFFALSE 28065
// ComWalk ( un ) ;
28056: LD_VAR 0 2
28060: PPUSH
28061: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28065: LD_VAR 0 2
28069: PPUSH
28070: LD_INT 8
28072: PPUSH
28073: CALL_OW 336
// end ;
28077: PPOPN 3
28079: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
28080: LD_EXP 55
28084: PUSH
28085: LD_EXP 99
28089: AND
28090: IFFALSE 28234
28092: GO 28094
28094: DISABLE
28095: LD_INT 0
28097: PPUSH
28098: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
28099: LD_ADDR_VAR 0 2
28103: PUSH
28104: LD_INT 22
28106: PUSH
28107: LD_OWVAR 2
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 21
28118: PUSH
28119: LD_INT 2
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 2
28128: PUSH
28129: LD_INT 34
28131: PUSH
28132: LD_INT 12
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 34
28141: PUSH
28142: LD_INT 51
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 34
28151: PUSH
28152: LD_INT 32
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: EMPTY
28160: LIST
28161: LIST
28162: LIST
28163: LIST
28164: PUSH
28165: EMPTY
28166: LIST
28167: LIST
28168: LIST
28169: PPUSH
28170: CALL_OW 69
28174: ST_TO_ADDR
// if not tmp then
28175: LD_VAR 0 2
28179: NOT
28180: IFFALSE 28184
// exit ;
28182: GO 28234
// for i in tmp do
28184: LD_ADDR_VAR 0 1
28188: PUSH
28189: LD_VAR 0 2
28193: PUSH
28194: FOR_IN
28195: IFFALSE 28232
// if GetCargo ( i , mat_artifact ) = 0 then
28197: LD_VAR 0 1
28201: PPUSH
28202: LD_INT 4
28204: PPUSH
28205: CALL_OW 289
28209: PUSH
28210: LD_INT 0
28212: EQUAL
28213: IFFALSE 28230
// SetCargo ( i , mat_siberit , 100 ) ;
28215: LD_VAR 0 1
28219: PPUSH
28220: LD_INT 3
28222: PPUSH
28223: LD_INT 100
28225: PPUSH
28226: CALL_OW 290
28230: GO 28194
28232: POP
28233: POP
// end ;
28234: PPOPN 2
28236: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
28237: LD_EXP 55
28241: PUSH
28242: LD_EXP 100
28246: AND
28247: IFFALSE 28400
28249: GO 28251
28251: DISABLE
28252: LD_INT 0
28254: PPUSH
28255: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
28256: LD_ADDR_VAR 0 2
28260: PUSH
28261: LD_INT 22
28263: PUSH
28264: LD_OWVAR 2
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PPUSH
28273: CALL_OW 69
28277: ST_TO_ADDR
// if not tmp then
28278: LD_VAR 0 2
28282: NOT
28283: IFFALSE 28287
// exit ;
28285: GO 28400
// for i := 1 to 2 do
28287: LD_ADDR_VAR 0 1
28291: PUSH
28292: DOUBLE
28293: LD_INT 1
28295: DEC
28296: ST_TO_ADDR
28297: LD_INT 2
28299: PUSH
28300: FOR_TO
28301: IFFALSE 28398
// begin uc_side := your_side ;
28303: LD_ADDR_OWVAR 20
28307: PUSH
28308: LD_OWVAR 2
28312: ST_TO_ADDR
// uc_nation := nation_american ;
28313: LD_ADDR_OWVAR 21
28317: PUSH
28318: LD_INT 1
28320: ST_TO_ADDR
// vc_chassis := us_morphling ;
28321: LD_ADDR_OWVAR 37
28325: PUSH
28326: LD_INT 5
28328: ST_TO_ADDR
// vc_engine := engine_siberite ;
28329: LD_ADDR_OWVAR 39
28333: PUSH
28334: LD_INT 3
28336: ST_TO_ADDR
// vc_control := control_computer ;
28337: LD_ADDR_OWVAR 38
28341: PUSH
28342: LD_INT 3
28344: ST_TO_ADDR
// vc_weapon := us_double_laser ;
28345: LD_ADDR_OWVAR 40
28349: PUSH
28350: LD_INT 10
28352: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
28353: CALL_OW 45
28357: PPUSH
28358: LD_VAR 0 2
28362: PUSH
28363: LD_INT 1
28365: ARRAY
28366: PPUSH
28367: CALL_OW 250
28371: PPUSH
28372: LD_VAR 0 2
28376: PUSH
28377: LD_INT 1
28379: ARRAY
28380: PPUSH
28381: CALL_OW 251
28385: PPUSH
28386: LD_INT 12
28388: PPUSH
28389: LD_INT 1
28391: PPUSH
28392: CALL_OW 50
// end ;
28396: GO 28300
28398: POP
28399: POP
// end ;
28400: PPOPN 2
28402: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28403: LD_EXP 55
28407: PUSH
28408: LD_EXP 101
28412: AND
28413: IFFALSE 28635
28415: GO 28417
28417: DISABLE
28418: LD_INT 0
28420: PPUSH
28421: PPUSH
28422: PPUSH
28423: PPUSH
28424: PPUSH
28425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28426: LD_ADDR_VAR 0 6
28430: PUSH
28431: LD_INT 22
28433: PUSH
28434: LD_OWVAR 2
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 21
28445: PUSH
28446: LD_INT 1
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: LD_INT 3
28455: PUSH
28456: LD_INT 23
28458: PUSH
28459: LD_INT 0
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: LIST
28474: PPUSH
28475: CALL_OW 69
28479: ST_TO_ADDR
// if not tmp then
28480: LD_VAR 0 6
28484: NOT
28485: IFFALSE 28489
// exit ;
28487: GO 28635
// s1 := rand ( 1 , 4 ) ;
28489: LD_ADDR_VAR 0 2
28493: PUSH
28494: LD_INT 1
28496: PPUSH
28497: LD_INT 4
28499: PPUSH
28500: CALL_OW 12
28504: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28505: LD_ADDR_VAR 0 4
28509: PUSH
28510: LD_VAR 0 6
28514: PUSH
28515: LD_INT 1
28517: ARRAY
28518: PPUSH
28519: LD_VAR 0 2
28523: PPUSH
28524: CALL_OW 259
28528: ST_TO_ADDR
// if s1 = 1 then
28529: LD_VAR 0 2
28533: PUSH
28534: LD_INT 1
28536: EQUAL
28537: IFFALSE 28557
// s2 := rand ( 2 , 4 ) else
28539: LD_ADDR_VAR 0 3
28543: PUSH
28544: LD_INT 2
28546: PPUSH
28547: LD_INT 4
28549: PPUSH
28550: CALL_OW 12
28554: ST_TO_ADDR
28555: GO 28565
// s2 := 1 ;
28557: LD_ADDR_VAR 0 3
28561: PUSH
28562: LD_INT 1
28564: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28565: LD_ADDR_VAR 0 5
28569: PUSH
28570: LD_VAR 0 6
28574: PUSH
28575: LD_INT 1
28577: ARRAY
28578: PPUSH
28579: LD_VAR 0 3
28583: PPUSH
28584: CALL_OW 259
28588: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28589: LD_VAR 0 6
28593: PUSH
28594: LD_INT 1
28596: ARRAY
28597: PPUSH
28598: LD_VAR 0 2
28602: PPUSH
28603: LD_VAR 0 5
28607: PPUSH
28608: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28612: LD_VAR 0 6
28616: PUSH
28617: LD_INT 1
28619: ARRAY
28620: PPUSH
28621: LD_VAR 0 3
28625: PPUSH
28626: LD_VAR 0 4
28630: PPUSH
28631: CALL_OW 237
// end ;
28635: PPOPN 6
28637: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28638: LD_EXP 55
28642: PUSH
28643: LD_EXP 102
28647: AND
28648: IFFALSE 28727
28650: GO 28652
28652: DISABLE
28653: LD_INT 0
28655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28656: LD_ADDR_VAR 0 1
28660: PUSH
28661: LD_INT 22
28663: PUSH
28664: LD_OWVAR 2
28668: PUSH
28669: EMPTY
28670: LIST
28671: LIST
28672: PUSH
28673: LD_INT 30
28675: PUSH
28676: LD_INT 3
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: PPUSH
28687: CALL_OW 69
28691: ST_TO_ADDR
// if not tmp then
28692: LD_VAR 0 1
28696: NOT
28697: IFFALSE 28701
// exit ;
28699: GO 28727
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28701: LD_VAR 0 1
28705: PUSH
28706: LD_INT 1
28708: PPUSH
28709: LD_VAR 0 1
28713: PPUSH
28714: CALL_OW 12
28718: ARRAY
28719: PPUSH
28720: LD_INT 1
28722: PPUSH
28723: CALL_OW 234
// end ;
28727: PPOPN 1
28729: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28730: LD_EXP 55
28734: PUSH
28735: LD_EXP 103
28739: AND
28740: IFFALSE 28852
28742: GO 28744
28744: DISABLE
28745: LD_INT 0
28747: PPUSH
28748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28749: LD_ADDR_VAR 0 2
28753: PUSH
28754: LD_INT 22
28756: PUSH
28757: LD_OWVAR 2
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: PUSH
28766: LD_INT 2
28768: PUSH
28769: LD_INT 30
28771: PUSH
28772: LD_INT 27
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: LD_INT 30
28781: PUSH
28782: LD_INT 26
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 30
28791: PUSH
28792: LD_INT 28
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PPUSH
28809: CALL_OW 69
28813: ST_TO_ADDR
// if not tmp then
28814: LD_VAR 0 2
28818: NOT
28819: IFFALSE 28823
// exit ;
28821: GO 28852
// for i in tmp do
28823: LD_ADDR_VAR 0 1
28827: PUSH
28828: LD_VAR 0 2
28832: PUSH
28833: FOR_IN
28834: IFFALSE 28850
// SetLives ( i , 1 ) ;
28836: LD_VAR 0 1
28840: PPUSH
28841: LD_INT 1
28843: PPUSH
28844: CALL_OW 234
28848: GO 28833
28850: POP
28851: POP
// end ;
28852: PPOPN 2
28854: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28855: LD_EXP 55
28859: PUSH
28860: LD_EXP 104
28864: AND
28865: IFFALSE 29139
28867: GO 28869
28869: DISABLE
28870: LD_INT 0
28872: PPUSH
28873: PPUSH
28874: PPUSH
// begin i := rand ( 1 , 7 ) ;
28875: LD_ADDR_VAR 0 1
28879: PUSH
28880: LD_INT 1
28882: PPUSH
28883: LD_INT 7
28885: PPUSH
28886: CALL_OW 12
28890: ST_TO_ADDR
// case i of 1 :
28891: LD_VAR 0 1
28895: PUSH
28896: LD_INT 1
28898: DOUBLE
28899: EQUAL
28900: IFTRUE 28904
28902: GO 28914
28904: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28905: LD_STRING earthquake(getX(game), 0, 32)
28907: PPUSH
28908: CALL_OW 559
28912: GO 29139
28914: LD_INT 2
28916: DOUBLE
28917: EQUAL
28918: IFTRUE 28922
28920: GO 28936
28922: POP
// begin ToLua ( displayStucuk(); ) ;
28923: LD_STRING displayStucuk();
28925: PPUSH
28926: CALL_OW 559
// ResetFog ;
28930: CALL_OW 335
// end ; 3 :
28934: GO 29139
28936: LD_INT 3
28938: DOUBLE
28939: EQUAL
28940: IFTRUE 28944
28942: GO 29048
28944: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28945: LD_ADDR_VAR 0 2
28949: PUSH
28950: LD_INT 22
28952: PUSH
28953: LD_OWVAR 2
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 25
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: PPUSH
28976: CALL_OW 69
28980: ST_TO_ADDR
// if not tmp then
28981: LD_VAR 0 2
28985: NOT
28986: IFFALSE 28990
// exit ;
28988: GO 29139
// un := tmp [ rand ( 1 , tmp ) ] ;
28990: LD_ADDR_VAR 0 3
28994: PUSH
28995: LD_VAR 0 2
28999: PUSH
29000: LD_INT 1
29002: PPUSH
29003: LD_VAR 0 2
29007: PPUSH
29008: CALL_OW 12
29012: ARRAY
29013: ST_TO_ADDR
// if Crawls ( un ) then
29014: LD_VAR 0 3
29018: PPUSH
29019: CALL_OW 318
29023: IFFALSE 29034
// ComWalk ( un ) ;
29025: LD_VAR 0 3
29029: PPUSH
29030: CALL_OW 138
// SetClass ( un , class_mortar ) ;
29034: LD_VAR 0 3
29038: PPUSH
29039: LD_INT 8
29041: PPUSH
29042: CALL_OW 336
// end ; 4 :
29046: GO 29139
29048: LD_INT 4
29050: DOUBLE
29051: EQUAL
29052: IFTRUE 29056
29054: GO 29117
29056: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
29057: LD_ADDR_VAR 0 2
29061: PUSH
29062: LD_INT 22
29064: PUSH
29065: LD_OWVAR 2
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 30
29076: PUSH
29077: LD_INT 29
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PPUSH
29088: CALL_OW 69
29092: ST_TO_ADDR
// if not tmp then
29093: LD_VAR 0 2
29097: NOT
29098: IFFALSE 29102
// exit ;
29100: GO 29139
// DestroyUnit ( tmp [ 1 ] ) ;
29102: LD_VAR 0 2
29106: PUSH
29107: LD_INT 1
29109: ARRAY
29110: PPUSH
29111: CALL_OW 65
// end ; 5 .. 7 :
29115: GO 29139
29117: LD_INT 5
29119: DOUBLE
29120: GREATEREQUAL
29121: IFFALSE 29129
29123: LD_INT 7
29125: DOUBLE
29126: LESSEQUAL
29127: IFTRUE 29131
29129: GO 29138
29131: POP
// StreamSibBomb ; end ;
29132: CALL 25419 0 0
29136: GO 29139
29138: POP
// end ;
29139: PPOPN 3
29141: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
29142: LD_EXP 55
29146: PUSH
29147: LD_EXP 105
29151: AND
29152: IFFALSE 29308
29154: GO 29156
29156: DISABLE
29157: LD_INT 0
29159: PPUSH
29160: PPUSH
29161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
29162: LD_ADDR_VAR 0 2
29166: PUSH
29167: LD_INT 81
29169: PUSH
29170: LD_OWVAR 2
29174: PUSH
29175: EMPTY
29176: LIST
29177: LIST
29178: PUSH
29179: LD_INT 2
29181: PUSH
29182: LD_INT 21
29184: PUSH
29185: LD_INT 1
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 21
29194: PUSH
29195: LD_INT 2
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: PPUSH
29211: CALL_OW 69
29215: ST_TO_ADDR
// if not tmp then
29216: LD_VAR 0 2
29220: NOT
29221: IFFALSE 29225
// exit ;
29223: GO 29308
// p := 0 ;
29225: LD_ADDR_VAR 0 3
29229: PUSH
29230: LD_INT 0
29232: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29233: LD_INT 35
29235: PPUSH
29236: CALL_OW 67
// p := p + 1 ;
29240: LD_ADDR_VAR 0 3
29244: PUSH
29245: LD_VAR 0 3
29249: PUSH
29250: LD_INT 1
29252: PLUS
29253: ST_TO_ADDR
// for i in tmp do
29254: LD_ADDR_VAR 0 1
29258: PUSH
29259: LD_VAR 0 2
29263: PUSH
29264: FOR_IN
29265: IFFALSE 29296
// if GetLives ( i ) < 1000 then
29267: LD_VAR 0 1
29271: PPUSH
29272: CALL_OW 256
29276: PUSH
29277: LD_INT 1000
29279: LESS
29280: IFFALSE 29294
// SetLives ( i , 1000 ) ;
29282: LD_VAR 0 1
29286: PPUSH
29287: LD_INT 1000
29289: PPUSH
29290: CALL_OW 234
29294: GO 29264
29296: POP
29297: POP
// until p > 20 ;
29298: LD_VAR 0 3
29302: PUSH
29303: LD_INT 20
29305: GREATER
29306: IFFALSE 29233
// end ;
29308: PPOPN 3
29310: END
// every 0 0$1 trigger StreamModeActive and sTime do
29311: LD_EXP 55
29315: PUSH
29316: LD_EXP 106
29320: AND
29321: IFFALSE 29356
29323: GO 29325
29325: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
29326: LD_INT 28
29328: PPUSH
29329: LD_OWVAR 2
29333: PPUSH
29334: LD_INT 2
29336: PPUSH
29337: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
29341: LD_INT 30
29343: PPUSH
29344: LD_OWVAR 2
29348: PPUSH
29349: LD_INT 2
29351: PPUSH
29352: CALL_OW 322
// end ;
29356: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
29357: LD_EXP 55
29361: PUSH
29362: LD_EXP 107
29366: AND
29367: IFFALSE 29488
29369: GO 29371
29371: DISABLE
29372: LD_INT 0
29374: PPUSH
29375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29376: LD_ADDR_VAR 0 2
29380: PUSH
29381: LD_INT 22
29383: PUSH
29384: LD_OWVAR 2
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 21
29395: PUSH
29396: LD_INT 1
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 3
29405: PUSH
29406: LD_INT 23
29408: PUSH
29409: LD_INT 0
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: LIST
29424: PPUSH
29425: CALL_OW 69
29429: ST_TO_ADDR
// if not tmp then
29430: LD_VAR 0 2
29434: NOT
29435: IFFALSE 29439
// exit ;
29437: GO 29488
// for i in tmp do
29439: LD_ADDR_VAR 0 1
29443: PUSH
29444: LD_VAR 0 2
29448: PUSH
29449: FOR_IN
29450: IFFALSE 29486
// begin if Crawls ( i ) then
29452: LD_VAR 0 1
29456: PPUSH
29457: CALL_OW 318
29461: IFFALSE 29472
// ComWalk ( i ) ;
29463: LD_VAR 0 1
29467: PPUSH
29468: CALL_OW 138
// SetClass ( i , 2 ) ;
29472: LD_VAR 0 1
29476: PPUSH
29477: LD_INT 2
29479: PPUSH
29480: CALL_OW 336
// end ;
29484: GO 29449
29486: POP
29487: POP
// end ;
29488: PPOPN 2
29490: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29491: LD_EXP 55
29495: PUSH
29496: LD_EXP 108
29500: AND
29501: IFFALSE 29782
29503: GO 29505
29505: DISABLE
29506: LD_INT 0
29508: PPUSH
29509: PPUSH
29510: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29511: LD_OWVAR 2
29515: PPUSH
29516: LD_INT 9
29518: PPUSH
29519: LD_INT 1
29521: PPUSH
29522: LD_INT 1
29524: PPUSH
29525: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29529: LD_INT 9
29531: PPUSH
29532: LD_OWVAR 2
29536: PPUSH
29537: CALL_OW 343
// uc_side := 9 ;
29541: LD_ADDR_OWVAR 20
29545: PUSH
29546: LD_INT 9
29548: ST_TO_ADDR
// uc_nation := 2 ;
29549: LD_ADDR_OWVAR 21
29553: PUSH
29554: LD_INT 2
29556: ST_TO_ADDR
// hc_name := Dark Warrior ;
29557: LD_ADDR_OWVAR 26
29561: PUSH
29562: LD_STRING Dark Warrior
29564: ST_TO_ADDR
// hc_gallery :=  ;
29565: LD_ADDR_OWVAR 33
29569: PUSH
29570: LD_STRING 
29572: ST_TO_ADDR
// hc_noskilllimit := true ;
29573: LD_ADDR_OWVAR 76
29577: PUSH
29578: LD_INT 1
29580: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
29581: LD_ADDR_OWVAR 31
29585: PUSH
29586: LD_INT 30
29588: PUSH
29589: LD_INT 30
29591: PUSH
29592: LD_INT 30
29594: PUSH
29595: LD_INT 30
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: ST_TO_ADDR
// un := CreateHuman ;
29604: LD_ADDR_VAR 0 3
29608: PUSH
29609: CALL_OW 44
29613: ST_TO_ADDR
// hc_noskilllimit := false ;
29614: LD_ADDR_OWVAR 76
29618: PUSH
29619: LD_INT 0
29621: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29622: LD_VAR 0 3
29626: PPUSH
29627: LD_INT 1
29629: PPUSH
29630: CALL_OW 51
// p := 0 ;
29634: LD_ADDR_VAR 0 2
29638: PUSH
29639: LD_INT 0
29641: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29642: LD_INT 35
29644: PPUSH
29645: CALL_OW 67
// p := p + 1 ;
29649: LD_ADDR_VAR 0 2
29653: PUSH
29654: LD_VAR 0 2
29658: PUSH
29659: LD_INT 1
29661: PLUS
29662: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
29663: LD_VAR 0 3
29667: PPUSH
29668: CALL_OW 256
29672: PUSH
29673: LD_INT 1000
29675: LESS
29676: IFFALSE 29690
// SetLives ( un , 1000 ) ;
29678: LD_VAR 0 3
29682: PPUSH
29683: LD_INT 1000
29685: PPUSH
29686: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
29690: LD_VAR 0 3
29694: PPUSH
29695: LD_INT 81
29697: PUSH
29698: LD_OWVAR 2
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 91
29709: PUSH
29710: LD_VAR 0 3
29714: PUSH
29715: LD_INT 30
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: LIST
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PPUSH
29727: CALL_OW 69
29731: PPUSH
29732: LD_VAR 0 3
29736: PPUSH
29737: CALL_OW 74
29741: PPUSH
29742: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29746: LD_VAR 0 2
29750: PUSH
29751: LD_INT 60
29753: GREATER
29754: PUSH
29755: LD_VAR 0 3
29759: PPUSH
29760: CALL_OW 301
29764: OR
29765: IFFALSE 29642
// if un then
29767: LD_VAR 0 3
29771: IFFALSE 29782
// RemoveUnit ( un ) ;
29773: LD_VAR 0 3
29777: PPUSH
29778: CALL_OW 64
// end ; end_of_file
29782: PPOPN 3
29784: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29785: LD_INT 0
29787: PPUSH
29788: PPUSH
29789: PPUSH
29790: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29791: LD_VAR 0 1
29795: PPUSH
29796: CALL_OW 264
29800: PUSH
29801: LD_EXP 46
29805: EQUAL
29806: IFFALSE 29878
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29808: LD_INT 68
29810: PPUSH
29811: LD_VAR 0 1
29815: PPUSH
29816: CALL_OW 255
29820: PPUSH
29821: CALL_OW 321
29825: PUSH
29826: LD_INT 2
29828: EQUAL
29829: IFFALSE 29841
// eff := 70 else
29831: LD_ADDR_VAR 0 4
29835: PUSH
29836: LD_INT 70
29838: ST_TO_ADDR
29839: GO 29849
// eff := 30 ;
29841: LD_ADDR_VAR 0 4
29845: PUSH
29846: LD_INT 30
29848: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29849: LD_VAR 0 1
29853: PPUSH
29854: CALL_OW 250
29858: PPUSH
29859: LD_VAR 0 1
29863: PPUSH
29864: CALL_OW 251
29868: PPUSH
29869: LD_VAR 0 4
29873: PPUSH
29874: CALL_OW 495
// end ; end ;
29878: LD_VAR 0 2
29882: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29883: LD_INT 0
29885: PPUSH
// end ;
29886: LD_VAR 0 4
29890: RET
// export function SOS_Command ( cmd ) ; begin
29891: LD_INT 0
29893: PPUSH
// end ;
29894: LD_VAR 0 2
29898: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
29899: LD_VAR 0 1
29903: PUSH
29904: LD_INT 255
29906: EQUAL
29907: PUSH
29908: LD_VAR 0 2
29912: PPUSH
29913: CALL_OW 264
29917: PUSH
29918: LD_INT 14
29920: PUSH
29921: LD_INT 53
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: IN
29928: AND
29929: PUSH
29930: LD_VAR 0 4
29934: PPUSH
29935: LD_VAR 0 5
29939: PPUSH
29940: CALL_OW 488
29944: AND
29945: IFFALSE 29969
// CutTreeXYR ( unit , x , y , 12 ) ;
29947: LD_VAR 0 2
29951: PPUSH
29952: LD_VAR 0 4
29956: PPUSH
29957: LD_VAR 0 5
29961: PPUSH
29962: LD_INT 12
29964: PPUSH
29965: CALL 29972 0 4
// end ;
29969: PPOPN 5
29971: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29972: LD_INT 0
29974: PPUSH
29975: PPUSH
29976: PPUSH
29977: PPUSH
29978: PPUSH
29979: PPUSH
29980: PPUSH
29981: PPUSH
29982: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29983: LD_VAR 0 1
29987: NOT
29988: PUSH
29989: LD_VAR 0 2
29993: PPUSH
29994: LD_VAR 0 3
29998: PPUSH
29999: CALL_OW 488
30003: NOT
30004: OR
30005: PUSH
30006: LD_VAR 0 4
30010: NOT
30011: OR
30012: IFFALSE 30016
// exit ;
30014: GO 30356
// list := [ ] ;
30016: LD_ADDR_VAR 0 13
30020: PUSH
30021: EMPTY
30022: ST_TO_ADDR
// if x - r < 0 then
30023: LD_VAR 0 2
30027: PUSH
30028: LD_VAR 0 4
30032: MINUS
30033: PUSH
30034: LD_INT 0
30036: LESS
30037: IFFALSE 30049
// min_x := 0 else
30039: LD_ADDR_VAR 0 7
30043: PUSH
30044: LD_INT 0
30046: ST_TO_ADDR
30047: GO 30065
// min_x := x - r ;
30049: LD_ADDR_VAR 0 7
30053: PUSH
30054: LD_VAR 0 2
30058: PUSH
30059: LD_VAR 0 4
30063: MINUS
30064: ST_TO_ADDR
// if y - r < 0 then
30065: LD_VAR 0 3
30069: PUSH
30070: LD_VAR 0 4
30074: MINUS
30075: PUSH
30076: LD_INT 0
30078: LESS
30079: IFFALSE 30091
// min_y := 0 else
30081: LD_ADDR_VAR 0 8
30085: PUSH
30086: LD_INT 0
30088: ST_TO_ADDR
30089: GO 30107
// min_y := y - r ;
30091: LD_ADDR_VAR 0 8
30095: PUSH
30096: LD_VAR 0 3
30100: PUSH
30101: LD_VAR 0 4
30105: MINUS
30106: ST_TO_ADDR
// max_x := x + r ;
30107: LD_ADDR_VAR 0 9
30111: PUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_VAR 0 4
30121: PLUS
30122: ST_TO_ADDR
// max_y := y + r ;
30123: LD_ADDR_VAR 0 10
30127: PUSH
30128: LD_VAR 0 3
30132: PUSH
30133: LD_VAR 0 4
30137: PLUS
30138: ST_TO_ADDR
// for _x = min_x to max_x do
30139: LD_ADDR_VAR 0 11
30143: PUSH
30144: DOUBLE
30145: LD_VAR 0 7
30149: DEC
30150: ST_TO_ADDR
30151: LD_VAR 0 9
30155: PUSH
30156: FOR_TO
30157: IFFALSE 30274
// for _y = min_y to max_y do
30159: LD_ADDR_VAR 0 12
30163: PUSH
30164: DOUBLE
30165: LD_VAR 0 8
30169: DEC
30170: ST_TO_ADDR
30171: LD_VAR 0 10
30175: PUSH
30176: FOR_TO
30177: IFFALSE 30270
// begin if not ValidHex ( _x , _y ) then
30179: LD_VAR 0 11
30183: PPUSH
30184: LD_VAR 0 12
30188: PPUSH
30189: CALL_OW 488
30193: NOT
30194: IFFALSE 30198
// continue ;
30196: GO 30176
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
30198: LD_VAR 0 11
30202: PPUSH
30203: LD_VAR 0 12
30207: PPUSH
30208: CALL_OW 351
30212: PUSH
30213: LD_VAR 0 11
30217: PPUSH
30218: LD_VAR 0 12
30222: PPUSH
30223: CALL_OW 554
30227: AND
30228: IFFALSE 30268
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
30230: LD_ADDR_VAR 0 13
30234: PUSH
30235: LD_VAR 0 13
30239: PPUSH
30240: LD_VAR 0 13
30244: PUSH
30245: LD_INT 1
30247: PLUS
30248: PPUSH
30249: LD_VAR 0 11
30253: PUSH
30254: LD_VAR 0 12
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PPUSH
30263: CALL_OW 2
30267: ST_TO_ADDR
// end ;
30268: GO 30176
30270: POP
30271: POP
30272: GO 30156
30274: POP
30275: POP
// if not list then
30276: LD_VAR 0 13
30280: NOT
30281: IFFALSE 30285
// exit ;
30283: GO 30356
// for i in list do
30285: LD_ADDR_VAR 0 6
30289: PUSH
30290: LD_VAR 0 13
30294: PUSH
30295: FOR_IN
30296: IFFALSE 30354
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
30298: LD_VAR 0 1
30302: PPUSH
30303: LD_STRING M
30305: PUSH
30306: LD_VAR 0 6
30310: PUSH
30311: LD_INT 1
30313: ARRAY
30314: PUSH
30315: LD_VAR 0 6
30319: PUSH
30320: LD_INT 2
30322: ARRAY
30323: PUSH
30324: LD_INT 0
30326: PUSH
30327: LD_INT 0
30329: PUSH
30330: LD_INT 0
30332: PUSH
30333: LD_INT 0
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: LIST
30343: LIST
30344: PUSH
30345: EMPTY
30346: LIST
30347: PPUSH
30348: CALL_OW 447
30352: GO 30295
30354: POP
30355: POP
// end ;
30356: LD_VAR 0 5
30360: RET
