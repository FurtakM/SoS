// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 0 , 0 ) ;
   4: LD_INT 0
   6: PPUSH
   7: LD_INT 0
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// debug := 0 ;
  21: LD_ADDR_EXP 1
  25: PUSH
  26: LD_INT 0
  28: ST_TO_ADDR
// if debug then
  29: LD_EXP 1
  33: IFFALSE 55
// begin display_strings := Debug mode active! ;
  35: LD_ADDR_OWVAR 47
  39: PUSH
  40: LD_STRING Debug mode active!
  42: ST_TO_ADDR
// Your_Side := 1 ;
  43: LD_ADDR_OWVAR 2
  47: PUSH
  48: LD_INT 1
  50: ST_TO_ADDR
// TurnFogOff ;
  51: CALL_OW 537
// end ; Difficulty := GetMultiplayerSetting ( 0 ) ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 426
  67: ST_TO_ADDR
// if not Difficulty then
  68: LD_OWVAR 67
  72: NOT
  73: IFFALSE 83
// Difficulty := 2 ;
  75: LD_ADDR_OWVAR 67
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// PrepareTigers ( tiger_area ) ;
  83: LD_INT 8
  85: PPUSH
  86: CALL 10764 0 1
// PrepareApemans ( apeman_area ) ;
  90: LD_INT 9
  92: PPUSH
  93: CALL 10894 0 1
// PrepareRussian ;
  97: CALL 117 0 0
// PrepareAmerican ;
 101: CALL 12301 0 0
// if not debug then
 105: LD_EXP 1
 109: NOT
 110: IFFALSE 116
// Action ;
 112: CALL 14530 0 0
// end ;
 116: END
// export debug ; end_of_file export ru_force , ru_group1 , ru_group2 , ru_tech_list , ru_towers_list , ru_weapon_list , ru_reserve , ru_attack_list ; export ru_lab_list , ru_heal_list , ru_blist , ru_buildings , ru_behemoth_mechanic , ru_spotted , ru_protector ; export need_buldozer , need_crane ; export function PrepareRussian ; var skill , i , un ; begin
 117: LD_INT 0
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
// uc_side := 3 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 3
 130: ST_TO_ADDR
// uc_nation := nation_russian ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 3
 138: ST_TO_ADDR
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
 139: LD_ADDR_VAR 0 2
 143: PUSH
 144: LD_INT 6
 146: PUSH
 147: LD_INT 7
 149: PUSH
 150: LD_INT 8
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: LIST
 157: PUSH
 158: LD_OWVAR 67
 162: ARRAY
 163: ST_TO_ADDR
// SetResourceType ( GetBase ( ru_depot ) , mat_cans , 1200 ) ;
 164: LD_INT 2
 166: PPUSH
 167: CALL_OW 274
 171: PPUSH
 172: LD_INT 1
 174: PPUSH
 175: LD_INT 1200
 177: PPUSH
 178: CALL_OW 277
// SetResourceType ( GetBase ( ru_depot ) , mat_oil , 600 ) ;
 182: LD_INT 2
 184: PPUSH
 185: CALL_OW 274
 189: PPUSH
 190: LD_INT 2
 192: PPUSH
 193: LD_INT 600
 195: PPUSH
 196: CALL_OW 277
// SetResourceVisibility ( 33 , 4 , 3 ) ;
 200: LD_INT 33
 202: PPUSH
 203: LD_INT 4
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL_OW 441
// SetResourceVisibility ( 37 , 3 , 3 ) ;
 213: LD_INT 37
 215: PPUSH
 216: LD_INT 3
 218: PPUSH
 219: LD_INT 3
 221: PPUSH
 222: CALL_OW 441
// ru_force := [ ] ;
 226: LD_ADDR_EXP 2
 230: PUSH
 231: EMPTY
 232: ST_TO_ADDR
// ru_group1 := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// ru_group2 := [ ] ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: EMPTY
 246: ST_TO_ADDR
// ru_reserve := [ ] ;
 247: LD_ADDR_EXP 8
 251: PUSH
 252: EMPTY
 253: ST_TO_ADDR
// ru_attack_list := [ ] ;
 254: LD_ADDR_EXP 9
 258: PUSH
 259: EMPTY
 260: ST_TO_ADDR
// ru_protector := [ ] ;
 261: LD_ADDR_EXP 16
 265: PUSH
 266: EMPTY
 267: ST_TO_ADDR
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
 268: LD_ADDR_EXP 5
 272: PUSH
 273: LD_INT 48
 275: PUSH
 276: LD_INT 49
 278: PUSH
 279: LD_INT 50
 281: PUSH
 282: LD_INT 20
 284: PUSH
 285: LD_INT 1
 287: PUSH
 288: LD_INT 51
 290: PUSH
 291: LD_INT 52
 293: PUSH
 294: LD_INT 69
 296: PUSH
 297: LD_INT 39
 299: PUSH
 300: LD_INT 34
 302: PUSH
 303: LD_INT 40
 305: PUSH
 306: LD_INT 53
 308: PUSH
 309: LD_INT 71
 311: PUSH
 312: LD_INT 57
 314: PUSH
 315: LD_INT 58
 317: PUSH
 318: LD_INT 44
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: LD_INT 27
 326: PUSH
 327: LD_INT 23
 329: PUSH
 330: LD_INT 33
 332: PUSH
 333: LD_INT 59
 335: PUSH
 336: LD_INT 54
 338: PUSH
 339: LD_INT 55
 341: PUSH
 342: LD_INT 56
 344: PUSH
 345: LD_INT 63
 347: PUSH
 348: LD_INT 64
 350: PUSH
 351: LD_INT 65
 353: PUSH
 354: LD_INT 30
 356: PUSH
 357: LD_INT 31
 359: PUSH
 360: LD_INT 21
 362: PUSH
 363: LD_INT 22
 365: PUSH
 366: LD_INT 25
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: ST_TO_ADDR
// ru_towers_list := GetBuildingList ( 3 , b_turret ) ;
 403: LD_ADDR_EXP 6
 407: PUSH
 408: LD_INT 3
 410: PPUSH
 411: LD_INT 33
 413: PPUSH
 414: CALL 8879 0 2
 418: ST_TO_ADDR
// ru_weapon_list := [ ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
 419: LD_ADDR_EXP 7
 423: PUSH
 424: LD_INT 46
 426: PUSH
 427: LD_INT 45
 429: PUSH
 430: LD_INT 47
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: ST_TO_ADDR
// ru_blist := [ b_turret , 36 , 8 , 3 ] ;
 438: LD_ADDR_EXP 12
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 36
 448: PUSH
 449: LD_INT 8
 451: PUSH
 452: LD_INT 3
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// ru_buildings := [ ] ;
 461: LD_ADDR_EXP 13
 465: PUSH
 466: EMPTY
 467: ST_TO_ADDR
// ru_lab_list := [ [ GetX ( GetLabs ( 3 ) [ 1 ] ) , GetY ( GetLabs ( 3 ) [ 1 ] ) , GetDir ( GetLabs ( 3 ) [ 1 ] ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 1 ) , GetLabKind ( GetLabs ( 3 ) [ 1 ] , 2 ) ] , [ 12 , 13 , 1 , b_lab_siberium , b_lab_spacetime ] ] ;
 468: LD_ADDR_EXP 10
 472: PUSH
 473: LD_INT 3
 475: PPUSH
 476: CALL 6928 0 1
 480: PUSH
 481: LD_INT 1
 483: ARRAY
 484: PPUSH
 485: CALL_OW 250
 489: PUSH
 490: LD_INT 3
 492: PPUSH
 493: CALL 6928 0 1
 497: PUSH
 498: LD_INT 1
 500: ARRAY
 501: PPUSH
 502: CALL_OW 251
 506: PUSH
 507: LD_INT 3
 509: PPUSH
 510: CALL 6928 0 1
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: CALL_OW 254
 523: PUSH
 524: LD_INT 3
 526: PPUSH
 527: CALL 6928 0 1
 531: PUSH
 532: LD_INT 1
 534: ARRAY
 535: PPUSH
 536: LD_INT 1
 538: PPUSH
 539: CALL_OW 268
 543: PUSH
 544: LD_INT 3
 546: PPUSH
 547: CALL 6928 0 1
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_INT 2
 558: PPUSH
 559: CALL_OW 268
 563: PUSH
 564: EMPTY
 565: LIST
 566: LIST
 567: LIST
 568: LIST
 569: LIST
 570: PUSH
 571: LD_INT 12
 573: PUSH
 574: LD_INT 13
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 11
 582: PUSH
 583: LD_INT 14
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: ST_TO_ADDR
// ru_heal_list := [ ] ;
 597: LD_ADDR_EXP 11
 601: PUSH
 602: EMPTY
 603: ST_TO_ADDR
// need_buldozer := false ;
 604: LD_ADDR_EXP 17
 608: PUSH
 609: LD_INT 0
 611: ST_TO_ADDR
// need_crane := true ;
 612: LD_ADDR_EXP 18
 616: PUSH
 617: LD_INT 1
 619: ST_TO_ADDR
// ru_spotted := false ;
 620: LD_ADDR_EXP 15
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// for i = 1 to 6 do
 628: LD_ADDR_VAR 0 3
 632: PUSH
 633: DOUBLE
 634: LD_INT 1
 636: DEC
 637: ST_TO_ADDR
 638: LD_INT 6
 640: PUSH
 641: FOR_TO
 642: IFFALSE 683
// begin PrepareHuman ( false , 4 , skill ) ;
 644: LD_INT 0
 646: PPUSH
 647: LD_INT 4
 649: PPUSH
 650: LD_VAR 0 2
 654: PPUSH
 655: CALL_OW 380
// un := CreateHuman ;
 659: LD_ADDR_VAR 0 4
 663: PUSH
 664: CALL_OW 44
 668: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
 669: LD_VAR 0 4
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: CALL_OW 52
// end ;
 681: GO 641
 683: POP
 684: POP
// for i = 1 to 6 do
 685: LD_ADDR_VAR 0 3
 689: PUSH
 690: DOUBLE
 691: LD_INT 1
 693: DEC
 694: ST_TO_ADDR
 695: LD_INT 6
 697: PUSH
 698: FOR_TO
 699: IFFALSE 740
// begin PrepareHuman ( false , 3 , skill ) ;
 701: LD_INT 0
 703: PPUSH
 704: LD_INT 3
 706: PPUSH
 707: LD_VAR 0 2
 711: PPUSH
 712: CALL_OW 380
// un := CreateHuman ;
 716: LD_ADDR_VAR 0 4
 720: PUSH
 721: CALL_OW 44
 725: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_fac ) ;
 726: LD_VAR 0 4
 730: PPUSH
 731: LD_INT 14
 733: PPUSH
 734: CALL_OW 52
// end ;
 738: GO 698
 740: POP
 741: POP
// for i = 1 to 6 do
 742: LD_ADDR_VAR 0 3
 746: PUSH
 747: DOUBLE
 748: LD_INT 1
 750: DEC
 751: ST_TO_ADDR
 752: LD_INT 6
 754: PUSH
 755: FOR_TO
 756: IFFALSE 800
// begin PrepareHuman ( false , 2 , skill ) ;
 758: LD_INT 0
 760: PPUSH
 761: LD_INT 2
 763: PPUSH
 764: LD_VAR 0 2
 768: PPUSH
 769: CALL_OW 380
// un := CreateHuman ;
 773: LD_ADDR_VAR 0 4
 777: PUSH
 778: CALL_OW 44
 782: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 783: LD_VAR 0 4
 787: PPUSH
 788: LD_INT 1
 790: PPUSH
 791: LD_INT 0
 793: PPUSH
 794: CALL_OW 49
// end ;
 798: GO 755
 800: POP
 801: POP
// for i = 1 to 6 do
 802: LD_ADDR_VAR 0 3
 806: PUSH
 807: DOUBLE
 808: LD_INT 1
 810: DEC
 811: ST_TO_ADDR
 812: LD_INT 6
 814: PUSH
 815: FOR_TO
 816: IFFALSE 894
// begin PrepareHuman ( false , 1 , skill ) ;
 818: LD_INT 0
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: LD_VAR 0 2
 828: PPUSH
 829: CALL_OW 380
// un := CreateHuman ;
 833: LD_ADDR_VAR 0 4
 837: PUSH
 838: CALL_OW 44
 842: ST_TO_ADDR
// PlaceUnitArea ( un , ru_spawn , false ) ;
 843: LD_VAR 0 4
 847: PPUSH
 848: LD_INT 1
 850: PPUSH
 851: LD_INT 0
 853: PPUSH
 854: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_barracks ] ) , un ) ) ;
 858: LD_VAR 0 4
 862: PPUSH
 863: LD_INT 30
 865: PUSH
 866: LD_INT 5
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL_OW 69
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: CALL_OW 74
 887: PPUSH
 888: CALL_OW 120
// end ;
 892: GO 815
 894: POP
 895: POP
// for i = 1 to Difficulty do
 896: LD_ADDR_VAR 0 3
 900: PUSH
 901: DOUBLE
 902: LD_INT 1
 904: DEC
 905: ST_TO_ADDR
 906: LD_OWVAR 67
 910: PUSH
 911: FOR_TO
 912: IFFALSE 1023
// begin vc_chassis := ru_medium_tracked ;
 914: LD_ADDR_OWVAR 37
 918: PUSH
 919: LD_INT 22
 921: ST_TO_ADDR
// vc_engine := engine_siberite ;
 922: LD_ADDR_OWVAR 39
 926: PUSH
 927: LD_INT 3
 929: ST_TO_ADDR
// vc_control := control_computer ;
 930: LD_ADDR_OWVAR 38
 934: PUSH
 935: LD_INT 3
 937: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_rocket_launcher ] [ i mod 2 + 1 ] ;
 938: LD_ADDR_OWVAR 40
 942: PUSH
 943: LD_INT 43
 945: PUSH
 946: LD_INT 45
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: PUSH
 953: LD_VAR 0 3
 957: PUSH
 958: LD_INT 2
 960: MOD
 961: PUSH
 962: LD_INT 1
 964: PLUS
 965: ARRAY
 966: ST_TO_ADDR
// un := CreateVehicle ;
 967: LD_ADDR_VAR 0 4
 971: PUSH
 972: CALL_OW 45
 976: ST_TO_ADDR
// PlaceUnitXYR ( un , 52 , 42 , 6 , false ) ;
 977: LD_VAR 0 4
 981: PPUSH
 982: LD_INT 52
 984: PPUSH
 985: LD_INT 42
 987: PPUSH
 988: LD_INT 6
 990: PPUSH
 991: LD_INT 0
 993: PPUSH
 994: CALL_OW 50
// ru_protector := Insert ( ru_protector , 1 , un ) ;
 998: LD_ADDR_EXP 16
1002: PUSH
1003: LD_EXP 16
1007: PPUSH
1008: LD_INT 1
1010: PPUSH
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 2
1020: ST_TO_ADDR
// end ;
1021: GO 911
1023: POP
1024: POP
// end ;
1025: LD_VAR 0 1
1029: RET
// every 150 150$00 trigger Difficulty = 2 and GetBuilding ( 3 , b_factory ) do
1030: LD_OWVAR 67
1034: PUSH
1035: LD_INT 2
1037: EQUAL
1038: PUSH
1039: LD_INT 3
1041: PPUSH
1042: LD_INT 3
1044: PPUSH
1045: CALL 6777 0 2
1049: AND
1050: IFFALSE 1086
1052: GO 1054
1054: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 3
1060: PPUSH
1061: CALL 6777 0 2
1065: PUSH
1066: LD_INT 1
1068: ARRAY
1069: PPUSH
1070: LD_INT 24
1072: PPUSH
1073: LD_INT 1
1075: PPUSH
1076: LD_INT 3
1078: PPUSH
1079: LD_INT 48
1081: PPUSH
1082: CALL 8652 0 5
1086: END
// every 120 120$00 trigger Difficulty = 3 and GetBuilding ( 3 , b_factory ) do
1087: LD_OWVAR 67
1091: PUSH
1092: LD_INT 3
1094: EQUAL
1095: PUSH
1096: LD_INT 3
1098: PPUSH
1099: LD_INT 3
1101: PPUSH
1102: CALL 6777 0 2
1106: AND
1107: IFFALSE 1143
1109: GO 1111
1111: DISABLE
// ComProduce ( GetBuilding ( 3 , b_factory ) [ 1 ] , ru_heavy_tracked , engine_combustion , control_computer , ru_siberium_rocket ) ;
1112: LD_INT 3
1114: PPUSH
1115: LD_INT 3
1117: PPUSH
1118: CALL 6777 0 2
1122: PUSH
1123: LD_INT 1
1125: ARRAY
1126: PPUSH
1127: LD_INT 24
1129: PPUSH
1130: LD_INT 1
1132: PPUSH
1133: LD_INT 3
1135: PPUSH
1136: LD_INT 48
1138: PPUSH
1139: CALL 8652 0 5
1143: END
// every 0 0$01 trigger ru_protector do var i ;
1144: LD_EXP 16
1148: IFFALSE 1319
1150: GO 1152
1152: DISABLE
1153: LD_INT 0
1155: PPUSH
// begin enable ;
1156: ENABLE
// if FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) then
1157: LD_INT 14
1159: PPUSH
1160: LD_INT 81
1162: PUSH
1163: LD_INT 3
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: PPUSH
1170: CALL_OW 70
1174: IFFALSE 1249
// begin for i = 1 to ru_protector do
1176: LD_ADDR_VAR 0 1
1180: PUSH
1181: DOUBLE
1182: LD_INT 1
1184: DEC
1185: ST_TO_ADDR
1186: LD_EXP 16
1190: PUSH
1191: FOR_TO
1192: IFFALSE 1245
// ComAttackUnit ( ru_protector [ i ] , NearestUnitToUnit ( FilterUnitsInArea ( ru_protect_area , [ f_enemy , 3 ] ) , ru_protector [ i ] ) ) ;
1194: LD_EXP 16
1198: PUSH
1199: LD_VAR 0 1
1203: ARRAY
1204: PPUSH
1205: LD_INT 14
1207: PPUSH
1208: LD_INT 81
1210: PUSH
1211: LD_INT 3
1213: PUSH
1214: EMPTY
1215: LIST
1216: LIST
1217: PPUSH
1218: CALL_OW 70
1222: PPUSH
1223: LD_EXP 16
1227: PUSH
1228: LD_VAR 0 1
1232: ARRAY
1233: PPUSH
1234: CALL_OW 74
1238: PPUSH
1239: CALL_OW 115
1243: GO 1191
1245: POP
1246: POP
// end else
1247: GO 1319
// for i = 1 to ru_protector do
1249: LD_ADDR_VAR 0 1
1253: PUSH
1254: DOUBLE
1255: LD_INT 1
1257: DEC
1258: ST_TO_ADDR
1259: LD_EXP 16
1263: PUSH
1264: FOR_TO
1265: IFFALSE 1317
// if GetDistUnitXY ( ru_protector [ i ] , 49 , 39 ) > 10 then
1267: LD_EXP 16
1271: PUSH
1272: LD_VAR 0 1
1276: ARRAY
1277: PPUSH
1278: LD_INT 49
1280: PPUSH
1281: LD_INT 39
1283: PPUSH
1284: CALL_OW 297
1288: PUSH
1289: LD_INT 10
1291: GREATER
1292: IFFALSE 1315
// ComMoveXY ( ru_protector [ i ] , 49 , 39 ) ;
1294: LD_EXP 16
1298: PUSH
1299: LD_VAR 0 1
1303: ARRAY
1304: PPUSH
1305: LD_INT 49
1307: PPUSH
1308: LD_INT 39
1310: PPUSH
1311: CALL_OW 111
1315: GO 1264
1317: POP
1318: POP
// end ;
1319: PPOPN 1
1321: END
// every 0 0$01 trigger tick > [ 2 2$00 , 1 1$00 , 0 0$30 ] [ Difficulty ] do
1322: LD_OWVAR 1
1326: PUSH
1327: LD_INT 4200
1329: PUSH
1330: LD_INT 2100
1332: PUSH
1333: LD_INT 1050
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: LD_OWVAR 67
1345: ARRAY
1346: GREATER
1347: IFFALSE 1360
1349: GO 1351
1351: DISABLE
// need_buldozer := true ;
1352: LD_ADDR_EXP 17
1356: PUSH
1357: LD_INT 1
1359: ST_TO_ADDR
1360: END
// export ru_sold , ru_eng , ru_mech , ru_sci , ru_bazz , ru_base_personel , ru_bulldozers , ru_crans , ru_cargos ; every 0 0$01 do
1361: GO 1363
1363: DISABLE
// begin enable ;
1364: ENABLE
// ru_sold := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
1365: LD_ADDR_EXP 19
1369: PUSH
1370: LD_INT 22
1372: PUSH
1373: LD_INT 3
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: PUSH
1380: LD_INT 25
1382: PUSH
1383: LD_INT 1
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: PPUSH
1394: CALL_OW 69
1398: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
1399: LD_ADDR_EXP 20
1403: PUSH
1404: LD_INT 22
1406: PUSH
1407: LD_INT 3
1409: PUSH
1410: EMPTY
1411: LIST
1412: LIST
1413: PUSH
1414: LD_INT 25
1416: PUSH
1417: LD_INT 2
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: PPUSH
1428: CALL_OW 69
1432: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
1433: LD_ADDR_EXP 21
1437: PUSH
1438: LD_INT 22
1440: PUSH
1441: LD_INT 3
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: PUSH
1448: LD_INT 25
1450: PUSH
1451: LD_INT 3
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: EMPTY
1459: LIST
1460: LIST
1461: PPUSH
1462: CALL_OW 69
1466: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_INT 22
1474: PUSH
1475: LD_INT 3
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: LD_INT 25
1484: PUSH
1485: LD_INT 4
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: PPUSH
1496: CALL_OW 69
1500: ST_TO_ADDR
// ru_bazz := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 9 ] ] ) ;
1501: LD_ADDR_EXP 23
1505: PUSH
1506: LD_INT 22
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: LD_INT 25
1518: PUSH
1519: LD_INT 9
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL_OW 69
1534: ST_TO_ADDR
// ru_base_personel := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
1535: LD_ADDR_EXP 24
1539: PUSH
1540: LD_INT 2
1542: PPUSH
1543: LD_INT 22
1545: PUSH
1546: LD_INT 3
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: PUSH
1553: LD_INT 21
1555: PUSH
1556: LD_INT 1
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: PPUSH
1567: CALL_OW 70
1571: ST_TO_ADDR
// ru_bulldozers := FilterAllUnits ( [ f_weapon , ru_bulldozer ] ) ;
1572: LD_ADDR_EXP 25
1576: PUSH
1577: LD_INT 34
1579: PUSH
1580: LD_INT 53
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: ST_TO_ADDR
// ru_crans := FilterAllUnits ( [ f_weapon , ru_crane ] ) ;
1592: LD_ADDR_EXP 26
1596: PUSH
1597: LD_INT 34
1599: PUSH
1600: LD_INT 52
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: PPUSH
1607: CALL_OW 69
1611: ST_TO_ADDR
// ru_cargos := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
1612: LD_ADDR_EXP 27
1616: PUSH
1617: LD_INT 34
1619: PUSH
1620: LD_INT 51
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PPUSH
1627: CALL_OW 69
1631: ST_TO_ADDR
// ru_buildings := GetBuildingsList ( 3 , - 1 ) ;
1632: LD_ADDR_EXP 13
1636: PUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 1
1642: NEG
1643: PPUSH
1644: CALL 11282 0 2
1648: ST_TO_ADDR
// end ;
1649: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 3 ] ) and game_status or debug do var i , j , un , b , p , l , fac , lab , list , c ;
1650: LD_INT 22
1652: PUSH
1653: LD_INT 3
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PPUSH
1660: CALL_OW 69
1664: PUSH
1665: LD_EXP 28
1669: AND
1670: PUSH
1671: LD_EXP 1
1675: OR
1676: IFFALSE 5165
1678: GO 1680
1680: DISABLE
1681: LD_INT 0
1683: PPUSH
1684: PPUSH
1685: PPUSH
1686: PPUSH
1687: PPUSH
1688: PPUSH
1689: PPUSH
1690: PPUSH
1691: PPUSH
1692: PPUSH
// begin enable ;
1693: ENABLE
// for i = 1 to ru_eng do
1694: LD_ADDR_VAR 0 1
1698: PUSH
1699: DOUBLE
1700: LD_INT 1
1702: DEC
1703: ST_TO_ADDR
1704: LD_EXP 20
1708: PUSH
1709: FOR_TO
1710: IFFALSE 1773
// if not HasTask ( ru_eng [ i ] ) and not IsInUnit ( ru_eng [ i ] ) then
1712: LD_EXP 20
1716: PUSH
1717: LD_VAR 0 1
1721: ARRAY
1722: PPUSH
1723: CALL_OW 314
1727: NOT
1728: PUSH
1729: LD_EXP 20
1733: PUSH
1734: LD_VAR 0 1
1738: ARRAY
1739: PPUSH
1740: CALL_OW 310
1744: NOT
1745: AND
1746: IFFALSE 1771
// ComEnterUnit ( ru_eng [ i ] , MyBase ( 3 ) ) ;
1748: LD_EXP 20
1752: PUSH
1753: LD_VAR 0 1
1757: ARRAY
1758: PPUSH
1759: LD_INT 3
1761: PPUSH
1762: CALL 6686 0 1
1766: PPUSH
1767: CALL_OW 120
1771: GO 1709
1773: POP
1774: POP
// if FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
1775: LD_INT 2
1777: PPUSH
1778: LD_INT 22
1780: PUSH
1781: LD_INT 3
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 21
1790: PUSH
1791: LD_INT 3
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: LD_INT 24
1803: PUSH
1804: LD_INT 1000
1806: PUSH
1807: EMPTY
1808: LIST
1809: LIST
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 70
1824: IFFALSE 1991
// begin b := FilterUnitsInArea ( ru_base_area , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
1826: LD_ADDR_VAR 0 4
1830: PUSH
1831: LD_INT 2
1833: PPUSH
1834: LD_INT 22
1836: PUSH
1837: LD_INT 3
1839: PUSH
1840: EMPTY
1841: LIST
1842: LIST
1843: PUSH
1844: LD_INT 21
1846: PUSH
1847: LD_INT 3
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: PUSH
1854: LD_INT 3
1856: PUSH
1857: LD_INT 24
1859: PUSH
1860: LD_INT 1000
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: LIST
1875: PPUSH
1876: CALL_OW 70
1880: ST_TO_ADDR
// for i = 1 to ru_eng do
1881: LD_ADDR_VAR 0 1
1885: PUSH
1886: DOUBLE
1887: LD_INT 1
1889: DEC
1890: ST_TO_ADDR
1891: LD_EXP 20
1895: PUSH
1896: FOR_TO
1897: IFFALSE 1989
// begin if IsInUnit ( ru_eng [ i ] ) then
1899: LD_EXP 20
1903: PUSH
1904: LD_VAR 0 1
1908: ARRAY
1909: PPUSH
1910: CALL_OW 310
1914: IFFALSE 1933
// ComExitBuilding ( ru_eng [ i ] ) else
1916: LD_EXP 20
1920: PUSH
1921: LD_VAR 0 1
1925: ARRAY
1926: PPUSH
1927: CALL_OW 122
1931: GO 1987
// if not WantRepair ( ru_eng [ i ] ) then
1933: LD_EXP 20
1937: PUSH
1938: LD_VAR 0 1
1942: ARRAY
1943: PPUSH
1944: CALL 11208 0 1
1948: NOT
1949: IFFALSE 1987
// ComRepairBuilding ( ru_eng [ i ] , NearestUnitToUnit ( b , ru_eng [ i ] ) ) ;
1951: LD_EXP 20
1955: PUSH
1956: LD_VAR 0 1
1960: ARRAY
1961: PPUSH
1962: LD_VAR 0 4
1966: PPUSH
1967: LD_EXP 20
1971: PUSH
1972: LD_VAR 0 1
1976: ARRAY
1977: PPUSH
1978: CALL_OW 74
1982: PPUSH
1983: CALL_OW 130
// end ;
1987: GO 1896
1989: POP
1990: POP
// end ; if EnemyNearbyBase ( your_side , 38 , 26 ) = false and EnemyNearbyBase ( your_side , 29 , 37 ) = false then
1991: LD_OWVAR 2
1995: PPUSH
1996: LD_INT 38
1998: PPUSH
1999: LD_INT 26
2001: PPUSH
2002: CALL 6005 0 3
2006: PUSH
2007: LD_INT 0
2009: EQUAL
2010: PUSH
2011: LD_OWVAR 2
2015: PPUSH
2016: LD_INT 29
2018: PPUSH
2019: LD_INT 37
2021: PPUSH
2022: CALL 6005 0 3
2026: PUSH
2027: LD_INT 0
2029: EQUAL
2030: AND
2031: IFFALSE 2168
// begin if ru_blist > 0 then
2033: LD_EXP 12
2037: PUSH
2038: LD_INT 0
2040: GREATER
2041: IFFALSE 2168
// begin for i = 1 to ru_eng do
2043: LD_ADDR_VAR 0 1
2047: PUSH
2048: DOUBLE
2049: LD_INT 1
2051: DEC
2052: ST_TO_ADDR
2053: LD_EXP 20
2057: PUSH
2058: FOR_TO
2059: IFFALSE 2166
// if IsInUnit ( ru_eng [ i ] ) then
2061: LD_EXP 20
2065: PUSH
2066: LD_VAR 0 1
2070: ARRAY
2071: PPUSH
2072: CALL_OW 310
2076: IFFALSE 2095
// ComExitBuilding ( ru_eng [ i ] ) else
2078: LD_EXP 20
2082: PUSH
2083: LD_VAR 0 1
2087: ARRAY
2088: PPUSH
2089: CALL_OW 122
2093: GO 2164
// if not HasTask ( ru_eng [ i ] ) then
2095: LD_EXP 20
2099: PUSH
2100: LD_VAR 0 1
2104: ARRAY
2105: PPUSH
2106: CALL_OW 314
2110: NOT
2111: IFFALSE 2164
// ComBuild ( ru_eng [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
2113: LD_EXP 20
2117: PUSH
2118: LD_VAR 0 1
2122: ARRAY
2123: PPUSH
2124: LD_EXP 12
2128: PUSH
2129: LD_INT 1
2131: ARRAY
2132: PPUSH
2133: LD_EXP 12
2137: PUSH
2138: LD_INT 2
2140: ARRAY
2141: PPUSH
2142: LD_EXP 12
2146: PUSH
2147: LD_INT 3
2149: ARRAY
2150: PPUSH
2151: LD_EXP 12
2155: PUSH
2156: LD_INT 4
2158: ARRAY
2159: PPUSH
2160: CALL_OW 145
2164: GO 2058
2166: POP
2167: POP
// end ; end ; ru_heal_list := NeedHeal ( 3 , ru_heal_list , ru_behemoth_mechanic ) ;
2168: LD_ADDR_EXP 11
2172: PUSH
2173: LD_INT 3
2175: PPUSH
2176: LD_EXP 11
2180: PPUSH
2181: LD_EXP 14
2185: PPUSH
2186: CALL 9695 0 3
2190: ST_TO_ADDR
// if debug then
2191: LD_EXP 1
2195: IFFALSE 2207
// display_strings := ru_heal_list ;
2197: LD_ADDR_OWVAR 47
2201: PUSH
2202: LD_EXP 11
2206: ST_TO_ADDR
// for i = 1 to ru_sci do
2207: LD_ADDR_VAR 0 1
2211: PUSH
2212: DOUBLE
2213: LD_INT 1
2215: DEC
2216: ST_TO_ADDR
2217: LD_EXP 22
2221: PUSH
2222: FOR_TO
2223: IFFALSE 2555
// begin if ru_heal_list then
2225: LD_EXP 11
2229: IFFALSE 2468
// begin list := ru_heal_list ;
2231: LD_ADDR_VAR 0 9
2235: PUSH
2236: LD_EXP 11
2240: ST_TO_ADDR
// if IsInUnit ( ru_sci [ i ] ) then
2241: LD_EXP 22
2245: PUSH
2246: LD_VAR 0 1
2250: ARRAY
2251: PPUSH
2252: CALL_OW 310
2256: IFFALSE 2273
// ComExitBuilding ( ru_sci [ i ] ) ;
2258: LD_EXP 22
2262: PUSH
2263: LD_VAR 0 1
2267: ARRAY
2268: PPUSH
2269: CALL_OW 122
// for p = 1 to list do
2273: LD_ADDR_VAR 0 5
2277: PUSH
2278: DOUBLE
2279: LD_INT 1
2281: DEC
2282: ST_TO_ADDR
2283: LD_VAR 0 9
2287: PUSH
2288: FOR_TO
2289: IFFALSE 2464
// begin if GetTag ( list [ p ] ) = 100 and not WantHeal ( ru_sci [ i ] , 100 ) then
2291: LD_VAR 0 9
2295: PUSH
2296: LD_VAR 0 5
2300: ARRAY
2301: PPUSH
2302: CALL_OW 110
2306: PUSH
2307: LD_INT 100
2309: EQUAL
2310: PUSH
2311: LD_EXP 22
2315: PUSH
2316: LD_VAR 0 1
2320: ARRAY
2321: PPUSH
2322: LD_INT 100
2324: PPUSH
2325: CALL 10055 0 2
2329: NOT
2330: AND
2331: IFFALSE 2359
// ComHeal ( ru_sci [ i ] , list [ p ] ) ;
2333: LD_EXP 22
2337: PUSH
2338: LD_VAR 0 1
2342: ARRAY
2343: PPUSH
2344: LD_VAR 0 9
2348: PUSH
2349: LD_VAR 0 5
2353: ARRAY
2354: PPUSH
2355: CALL_OW 128
// if GetTag ( list [ p ] ) > 100 then
2359: LD_VAR 0 9
2363: PUSH
2364: LD_VAR 0 5
2368: ARRAY
2369: PPUSH
2370: CALL_OW 110
2374: PUSH
2375: LD_INT 100
2377: GREATER
2378: IFFALSE 2406
// AddComHeal ( ru_sci [ i ] , list [ p ] ) ;
2380: LD_EXP 22
2384: PUSH
2385: LD_VAR 0 1
2389: ARRAY
2390: PPUSH
2391: LD_VAR 0 9
2395: PUSH
2396: LD_VAR 0 5
2400: ARRAY
2401: PPUSH
2402: CALL_OW 188
// if not IsInArea ( list [ p ] , ru_heal_area ) then
2406: LD_VAR 0 9
2410: PUSH
2411: LD_VAR 0 5
2415: ARRAY
2416: PPUSH
2417: LD_INT 4
2419: PPUSH
2420: CALL_OW 308
2424: NOT
2425: IFFALSE 2447
// ComMoveToArea ( list [ p ] , ru_heal_area ) else
2427: LD_VAR 0 9
2431: PUSH
2432: LD_VAR 0 5
2436: ARRAY
2437: PPUSH
2438: LD_INT 4
2440: PPUSH
2441: CALL_OW 113
2445: GO 2462
// ComHold ( list [ p ] ) ;
2447: LD_VAR 0 9
2451: PUSH
2452: LD_VAR 0 5
2456: ARRAY
2457: PPUSH
2458: CALL_OW 140
// end ;
2462: GO 2288
2464: POP
2465: POP
// end else
2466: GO 2553
// if not HasTask ( ru_sci [ i ] ) and not IsInUnit ( ru_sci [ i ] ) and ru_heal_list = 0 then
2468: LD_EXP 22
2472: PUSH
2473: LD_VAR 0 1
2477: ARRAY
2478: PPUSH
2479: CALL_OW 314
2483: NOT
2484: PUSH
2485: LD_EXP 22
2489: PUSH
2490: LD_VAR 0 1
2494: ARRAY
2495: PPUSH
2496: CALL_OW 310
2500: NOT
2501: AND
2502: PUSH
2503: LD_EXP 11
2507: PUSH
2508: LD_INT 0
2510: EQUAL
2511: AND
2512: IFFALSE 2553
// ComEnterUnit ( ru_sci [ i ] , NearestUnitToUnit ( GetLabs ( 3 ) , ru_sci [ i ] ) ) ;
2514: LD_EXP 22
2518: PUSH
2519: LD_VAR 0 1
2523: ARRAY
2524: PPUSH
2525: LD_INT 3
2527: PPUSH
2528: CALL 6928 0 1
2532: PPUSH
2533: LD_EXP 22
2537: PUSH
2538: LD_VAR 0 1
2542: ARRAY
2543: PPUSH
2544: CALL_OW 74
2548: PPUSH
2549: CALL_OW 120
// end ;
2553: GO 2222
2555: POP
2556: POP
// if CheckTechList ( 3 , ru_tech_list ) then
2557: LD_INT 3
2559: PPUSH
2560: LD_EXP 5
2564: PPUSH
2565: CALL 7069 0 2
2569: IFFALSE 2583
// ResearchTechList ( 3 , ru_tech_list ) ;
2571: LD_INT 3
2573: PPUSH
2574: LD_EXP 5
2578: PPUSH
2579: CALL 7144 0 2
// ComBuildLabList ( ru_eng , ru_lab_list ) ;
2583: LD_EXP 20
2587: PPUSH
2588: LD_EXP 10
2592: PPUSH
2593: CALL 9051 0 2
// lab := GetLabs ( 3 ) ;
2597: LD_ADDR_VAR 0 8
2601: PUSH
2602: LD_INT 3
2604: PPUSH
2605: CALL 6928 0 1
2609: ST_TO_ADDR
// if lab and ru_heal_list = 0 then
2610: LD_VAR 0 8
2614: PUSH
2615: LD_EXP 11
2619: PUSH
2620: LD_INT 0
2622: EQUAL
2623: AND
2624: IFFALSE 2751
// for i = 1 to lab do
2626: LD_ADDR_VAR 0 1
2630: PUSH
2631: DOUBLE
2632: LD_INT 1
2634: DEC
2635: ST_TO_ADDR
2636: LD_VAR 0 8
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2749
// if BuildingStatus ( lab [ i ] ) = bs_need_people then
2644: LD_VAR 0 8
2648: PUSH
2649: LD_VAR 0 1
2653: ARRAY
2654: PPUSH
2655: CALL_OW 461
2659: PUSH
2660: LD_INT 6
2662: EQUAL
2663: IFFALSE 2747
// begin for p = 1 to ru_sci do
2665: LD_ADDR_VAR 0 5
2669: PUSH
2670: DOUBLE
2671: LD_INT 1
2673: DEC
2674: ST_TO_ADDR
2675: LD_EXP 22
2679: PUSH
2680: FOR_TO
2681: IFFALSE 2745
// if IsInUnit ( ru_sci [ p ] ) then
2683: LD_EXP 22
2687: PUSH
2688: LD_VAR 0 5
2692: ARRAY
2693: PPUSH
2694: CALL_OW 310
2698: IFFALSE 2717
// ComExitBuilding ( ru_sci [ p ] ) else
2700: LD_EXP 22
2704: PUSH
2705: LD_VAR 0 5
2709: ARRAY
2710: PPUSH
2711: CALL_OW 122
2715: GO 2743
// ComEnterUnit ( ru_sci [ p ] , lab [ i ] ) ;
2717: LD_EXP 22
2721: PUSH
2722: LD_VAR 0 5
2726: ARRAY
2727: PPUSH
2728: LD_VAR 0 8
2732: PUSH
2733: LD_VAR 0 1
2737: ARRAY
2738: PPUSH
2739: CALL_OW 120
2743: GO 2680
2745: POP
2746: POP
// end ;
2747: GO 2641
2749: POP
2750: POP
// if GetTowers ( 3 ) < 5 then
2751: LD_INT 3
2753: PPUSH
2754: CALL 7483 0 1
2758: PUSH
2759: LD_INT 5
2761: LESS
2762: IFFALSE 2780
// CheckTowersStatus ( ru_eng , ru_towers_list ) else
2764: LD_EXP 20
2768: PPUSH
2769: LD_EXP 6
2773: PPUSH
2774: CALL 8091 0 2
2778: GO 2792
// CheckWeaponOnTowers ( 3 , ru_weapon_list ) ;
2780: LD_INT 3
2782: PPUSH
2783: LD_EXP 7
2787: PPUSH
2788: CALL 8382 0 2
// if GetBuilding ( 3 , b_factory ) then
2792: LD_INT 3
2794: PPUSH
2795: LD_INT 3
2797: PPUSH
2798: CALL 6777 0 2
2802: IFFALSE 3072
// if BuildingStatus ( GetBuilding ( 3 , b_factory ) [ 1 ] ) = bs_idle then
2804: LD_INT 3
2806: PPUSH
2807: LD_INT 3
2809: PPUSH
2810: CALL 6777 0 2
2814: PUSH
2815: LD_INT 1
2817: ARRAY
2818: PPUSH
2819: CALL_OW 461
2823: PUSH
2824: LD_INT 2
2826: EQUAL
2827: IFFALSE 3072
// begin fac := GetBuilding ( 3 , b_factory ) [ 1 ] ;
2829: LD_ADDR_VAR 0 7
2833: PUSH
2834: LD_INT 3
2836: PPUSH
2837: LD_INT 3
2839: PPUSH
2840: CALL 6777 0 2
2844: PUSH
2845: LD_INT 1
2847: ARRAY
2848: ST_TO_ADDR
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 0 and need_buldozer then
2849: LD_INT 3
2851: PPUSH
2852: LD_INT 24
2854: PPUSH
2855: LD_INT 53
2857: PPUSH
2858: CALL 8530 0 3
2862: PUSH
2863: LD_INT 0
2865: EQUAL
2866: PUSH
2867: LD_EXP 17
2871: AND
2872: IFFALSE 2895
// ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ) ;
2874: LD_VAR 0 7
2878: PPUSH
2879: LD_INT 24
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 53
2890: PPUSH
2891: CALL 8652 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_crane ) = 0 and need_crane then
2895: LD_INT 3
2897: PPUSH
2898: LD_INT 22
2900: PPUSH
2901: LD_INT 52
2903: PPUSH
2904: CALL 8530 0 3
2908: PUSH
2909: LD_INT 0
2911: EQUAL
2912: PUSH
2913: LD_EXP 18
2917: AND
2918: IFFALSE 2941
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_crane ) ;
2920: LD_VAR 0 7
2924: PPUSH
2925: LD_INT 22
2927: PPUSH
2928: LD_INT 1
2930: PPUSH
2931: LD_INT 3
2933: PPUSH
2934: LD_INT 52
2936: PPUSH
2937: CALL 8652 0 5
// if GetVehicle ( 3 , ru_medium_tracked , ru_time_lapser ) < 4 and GetTech ( tech_lapser , 3 ) = state_researched then
2941: LD_INT 3
2943: PPUSH
2944: LD_INT 22
2946: PPUSH
2947: LD_INT 49
2949: PPUSH
2950: CALL 8530 0 3
2954: PUSH
2955: LD_INT 4
2957: LESS
2958: PUSH
2959: LD_INT 31
2961: PPUSH
2962: LD_INT 3
2964: PPUSH
2965: CALL_OW 321
2969: PUSH
2970: LD_INT 2
2972: EQUAL
2973: AND
2974: IFFALSE 2997
// ComProduce ( fac , ru_medium_tracked , engine_combustion , control_computer , ru_time_lapser ) ;
2976: LD_VAR 0 7
2980: PPUSH
2981: LD_INT 22
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: LD_INT 3
2989: PPUSH
2990: LD_INT 49
2992: PPUSH
2993: CALL 8652 0 5
// if ru_reserve < [ 5 , 6 , 7 ] [ Difficulty ] then
2997: LD_EXP 8
3001: PUSH
3002: LD_INT 5
3004: PUSH
3005: LD_INT 6
3007: PUSH
3008: LD_INT 7
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_OWVAR 67
3020: ARRAY
3021: LESS
3022: IFFALSE 3072
// begin ComProduce ( fac , ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_heavy_gun ] [ Rand ( 1 , 4 ) ] ) ;
3024: LD_VAR 0 7
3028: PPUSH
3029: LD_INT 24
3031: PPUSH
3032: LD_INT 1
3034: PPUSH
3035: LD_INT 3
3037: PPUSH
3038: LD_INT 46
3040: PUSH
3041: LD_INT 45
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 46
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: LIST
3055: PUSH
3056: LD_INT 1
3058: PPUSH
3059: LD_INT 4
3061: PPUSH
3062: CALL_OW 12
3066: ARRAY
3067: PPUSH
3068: CALL 8652 0 5
// end ; end ; if GetBaseSource ( MyBase ( 3 ) ) [ 1 ] > 250 and GetBaseSource ( MyBase ( 3 ) ) [ 3 ] > 50 and GetTech ( tech_behemoth , 3 ) = state_researched and GetBehemoth ( 3 ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_time_lapser ] ] ) > 3 and EnemyNearbyBase ( your_side , 51 , 42 ) = false then
3072: LD_INT 3
3074: PPUSH
3075: CALL 6686 0 1
3079: PPUSH
3080: CALL 6378 0 1
3084: PUSH
3085: LD_INT 1
3087: ARRAY
3088: PUSH
3089: LD_INT 250
3091: GREATER
3092: PUSH
3093: LD_INT 3
3095: PPUSH
3096: CALL 6686 0 1
3100: PPUSH
3101: CALL 6378 0 1
3105: PUSH
3106: LD_INT 3
3108: ARRAY
3109: PUSH
3110: LD_INT 50
3112: GREATER
3113: AND
3114: PUSH
3115: LD_INT 23
3117: PPUSH
3118: LD_INT 3
3120: PPUSH
3121: CALL_OW 321
3125: PUSH
3126: LD_INT 2
3128: EQUAL
3129: AND
3130: PUSH
3131: LD_INT 3
3133: PPUSH
3134: CALL 12006 0 1
3138: PUSH
3139: LD_INT 0
3141: EQUAL
3142: AND
3143: PUSH
3144: LD_INT 22
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: PUSH
3154: LD_INT 34
3156: PUSH
3157: LD_INT 49
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: PUSH
3173: LD_INT 3
3175: GREATER
3176: AND
3177: PUSH
3178: LD_OWVAR 2
3182: PPUSH
3183: LD_INT 51
3185: PPUSH
3186: LD_INT 42
3188: PPUSH
3189: CALL 6005 0 3
3193: PUSH
3194: LD_INT 0
3196: EQUAL
3197: AND
3198: IFFALSE 3283
// begin for i = 1 to ru_mech do
3200: LD_ADDR_VAR 0 1
3204: PUSH
3205: DOUBLE
3206: LD_INT 1
3208: DEC
3209: ST_TO_ADDR
3210: LD_EXP 21
3214: PUSH
3215: FOR_TO
3216: IFFALSE 3281
// begin if IsInUnit ( ru_mech [ i ] ) then
3218: LD_EXP 21
3222: PUSH
3223: LD_VAR 0 1
3227: ARRAY
3228: PPUSH
3229: CALL_OW 310
3233: IFFALSE 3252
// ComExitBuilding ( ru_mech [ i ] ) else
3235: LD_EXP 21
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 122
3250: GO 3279
// ComBuildBehemoth ( ru_mech [ i ] , b_behemoth , 51 , 43 , 0 ) ;
3252: LD_EXP 21
3256: PUSH
3257: LD_VAR 0 1
3261: ARRAY
3262: PPUSH
3263: LD_INT 37
3265: PPUSH
3266: LD_INT 51
3268: PPUSH
3269: LD_INT 43
3271: PPUSH
3272: LD_INT 0
3274: PPUSH
3275: CALL_OW 170
// end ;
3279: GO 3215
3281: POP
3282: POP
// end ; if tick >= [ 45 45$00 , 40 40$00 , 34 34$00 ] [ Difficulty ] then
3283: LD_OWVAR 1
3287: PUSH
3288: LD_INT 94500
3290: PUSH
3291: LD_INT 84000
3293: PUSH
3294: LD_INT 71400
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: PUSH
3302: LD_OWVAR 67
3306: ARRAY
3307: GREATEREQUAL
3308: IFFALSE 3364
// begin if tick mod [ 9 9$00 , 8 8$00 , 7 7$00 ] [ Difficulty ] = 0 then
3310: LD_OWVAR 1
3314: PUSH
3315: LD_INT 18900
3317: PUSH
3318: LD_INT 16800
3320: PUSH
3321: LD_INT 14700
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: MOD
3335: PUSH
3336: LD_INT 0
3338: EQUAL
3339: IFFALSE 3364
// if ru_reserve then
3341: LD_EXP 8
3345: IFFALSE 3364
// begin ru_attack_list := ru_reserve ;
3347: LD_ADDR_EXP 9
3351: PUSH
3352: LD_EXP 8
3356: ST_TO_ADDR
// ru_reserve := [ ] ;
3357: LD_ADDR_EXP 8
3361: PUSH
3362: EMPTY
3363: ST_TO_ADDR
// end ; end ; if ru_attack_list then
3364: LD_EXP 9
3368: IFFALSE 3490
// begin for i = 1 to ru_attack_list do
3370: LD_ADDR_VAR 0 1
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_EXP 9
3384: PUSH
3385: FOR_TO
3386: IFFALSE 3488
// if GetLives ( ru_attack_list [ i ] ) >= 250 and not HasTask ( ru_attack_list [ i ] ) then
3388: LD_EXP 9
3392: PUSH
3393: LD_VAR 0 1
3397: ARRAY
3398: PPUSH
3399: CALL_OW 256
3403: PUSH
3404: LD_INT 250
3406: GREATEREQUAL
3407: PUSH
3408: LD_EXP 9
3412: PUSH
3413: LD_VAR 0 1
3417: ARRAY
3418: PPUSH
3419: CALL_OW 314
3423: NOT
3424: AND
3425: IFFALSE 3486
// ComAttackUnit ( ru_attack_list [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( ru_attack_list [ i ] ) ] ) , ru_attack_list [ i ] ) ) ;
3427: LD_EXP 9
3431: PUSH
3432: LD_VAR 0 1
3436: ARRAY
3437: PPUSH
3438: LD_INT 81
3440: PUSH
3441: LD_EXP 9
3445: PUSH
3446: LD_VAR 0 1
3450: ARRAY
3451: PPUSH
3452: CALL_OW 255
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: PPUSH
3466: LD_EXP 9
3470: PUSH
3471: LD_VAR 0 1
3475: ARRAY
3476: PPUSH
3477: CALL_OW 74
3481: PPUSH
3482: CALL_OW 115
3486: GO 3385
3488: POP
3489: POP
// end ; if GetBehemoth ( 3 ) then
3490: LD_INT 3
3492: PPUSH
3493: CALL 12006 0 1
3497: IFFALSE 3791
// begin if ru_mech >= 4 then
3499: LD_EXP 21
3503: PUSH
3504: LD_INT 4
3506: GREATEREQUAL
3507: IFFALSE 3558
// ru_behemoth_mechanic := [ ru_mech [ 1 ] , ru_mech [ 2 ] , ru_mech [ 3 ] , ru_mech [ 4 ] ] else
3509: LD_ADDR_EXP 14
3513: PUSH
3514: LD_EXP 21
3518: PUSH
3519: LD_INT 1
3521: ARRAY
3522: PUSH
3523: LD_EXP 21
3527: PUSH
3528: LD_INT 2
3530: ARRAY
3531: PUSH
3532: LD_EXP 21
3536: PUSH
3537: LD_INT 3
3539: ARRAY
3540: PUSH
3541: LD_EXP 21
3545: PUSH
3546: LD_INT 4
3548: ARRAY
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: ST_TO_ADDR
3556: GO 3568
// ru_behemoth_mechanic := ru_mech ;
3558: LD_ADDR_EXP 14
3562: PUSH
3563: LD_EXP 21
3567: ST_TO_ADDR
// for i = 1 to ru_mech do
3568: LD_ADDR_VAR 0 1
3572: PUSH
3573: DOUBLE
3574: LD_INT 1
3576: DEC
3577: ST_TO_ADDR
3578: LD_EXP 21
3582: PUSH
3583: FOR_TO
3584: IFFALSE 3638
// if IsInUnit ( ru_mech [ i ] ) and ru_mech [ i ] in ru_behemoth_mechanic then
3586: LD_EXP 21
3590: PUSH
3591: LD_VAR 0 1
3595: ARRAY
3596: PPUSH
3597: CALL_OW 310
3601: PUSH
3602: LD_EXP 21
3606: PUSH
3607: LD_VAR 0 1
3611: ARRAY
3612: PUSH
3613: LD_EXP 14
3617: IN
3618: AND
3619: IFFALSE 3636
// ComExitBuilding ( ru_mech [ i ] ) ;
3621: LD_EXP 21
3625: PUSH
3626: LD_VAR 0 1
3630: ARRAY
3631: PPUSH
3632: CALL_OW 122
3636: GO 3583
3638: POP
3639: POP
// if FilterUnitsInArea ( alt_base , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) > 0 then
3640: LD_INT 12
3642: PPUSH
3643: LD_INT 22
3645: PUSH
3646: LD_INT 1
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: LD_INT 21
3655: PUSH
3656: LD_INT 3
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PPUSH
3667: CALL_OW 70
3671: PUSH
3672: LD_INT 0
3674: GREATER
3675: IFFALSE 3735
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 97 , 9 ) else
3677: LD_INT 3
3679: PPUSH
3680: CALL 12006 0 1
3684: PUSH
3685: LD_INT 1
3687: ARRAY
3688: PPUSH
3689: LD_INT 21
3691: PUSH
3692: LD_INT 2
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 34
3701: PUSH
3702: LD_INT 49
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PPUSH
3713: CALL_OW 69
3717: PPUSH
3718: LD_EXP 14
3722: PPUSH
3723: LD_INT 97
3725: PPUSH
3726: LD_INT 9
3728: PPUSH
3729: CALL 11503 0 5
3733: GO 3791
// BehemothAttack ( GetBehemoth ( 3 ) [ 1 ] , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_weapon , ru_time_lapser ] ] ) , ru_behemoth_mechanic , 153 , 102 ) ;
3735: LD_INT 3
3737: PPUSH
3738: CALL 12006 0 1
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: PPUSH
3747: LD_INT 21
3749: PUSH
3750: LD_INT 2
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 34
3759: PUSH
3760: LD_INT 49
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: PPUSH
3771: CALL_OW 69
3775: PPUSH
3776: LD_EXP 14
3780: PPUSH
3781: LD_INT 153
3783: PPUSH
3784: LD_INT 102
3786: PPUSH
3787: CALL 11503 0 5
// end ; if ru_bazz = 0 and GetTech ( tech_bazooka , 3 ) = state_researched then
3791: LD_EXP 23
3795: PUSH
3796: LD_INT 0
3798: EQUAL
3799: PUSH
3800: LD_INT 44
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 321
3810: PUSH
3811: LD_INT 2
3813: EQUAL
3814: AND
3815: IFFALSE 3826
// ComChangeClassToBazooker ( ru_sold ) ;
3817: LD_EXP 19
3821: PPUSH
3822: CALL 10440 0 1
// if ru_bazz then
3826: LD_EXP 23
3830: IFFALSE 3844
// IntBazooka ( ru_bazz , 1 ) ;
3832: LD_EXP 23
3836: PPUSH
3837: LD_INT 1
3839: PPUSH
3840: CALL 10159 0 2
// if GetResourceVisibility ( 67 , 39 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3844: LD_INT 67
3846: PPUSH
3847: LD_INT 39
3849: PPUSH
3850: LD_INT 3
3852: PPUSH
3853: CALL_OW 440
3857: PUSH
3858: LD_INT 0
3860: EQUAL
3861: PUSH
3862: LD_INT 20
3864: PPUSH
3865: LD_INT 3
3867: PPUSH
3868: CALL_OW 321
3872: PUSH
3873: LD_INT 2
3875: EQUAL
3876: AND
3877: IFFALSE 3898
// ComFindDeposit ( ru_sci [ 1 ] , 67 , 39 ) ;
3879: LD_EXP 22
3883: PUSH
3884: LD_INT 1
3886: ARRAY
3887: PPUSH
3888: LD_INT 67
3890: PPUSH
3891: LD_INT 39
3893: PPUSH
3894: CALL 9634 0 3
// if GetResourceVisibility ( 89 , 66 , 3 ) = false then
3898: LD_INT 89
3900: PPUSH
3901: LD_INT 66
3903: PPUSH
3904: LD_INT 3
3906: PPUSH
3907: CALL_OW 440
3911: PUSH
3912: LD_INT 0
3914: EQUAL
3915: IFFALSE 3936
// ComFindDeposit ( ru_sci [ 1 ] , 87 , 60 ) ;
3917: LD_EXP 22
3921: PUSH
3922: LD_INT 1
3924: ARRAY
3925: PPUSH
3926: LD_INT 87
3928: PPUSH
3929: LD_INT 60
3931: PPUSH
3932: CALL 9634 0 3
// if GetResourceVisibility ( 104 , 94 , 3 ) = false and GetTech ( tech_SibDet , 3 ) = state_researched then
3936: LD_INT 104
3938: PPUSH
3939: LD_INT 94
3941: PPUSH
3942: LD_INT 3
3944: PPUSH
3945: CALL_OW 440
3949: PUSH
3950: LD_INT 0
3952: EQUAL
3953: PUSH
3954: LD_INT 20
3956: PPUSH
3957: LD_INT 3
3959: PPUSH
3960: CALL_OW 321
3964: PUSH
3965: LD_INT 2
3967: EQUAL
3968: AND
3969: IFFALSE 3990
// ComFindDeposit ( ru_sci [ 1 ] , 104 , 94 ) ;
3971: LD_EXP 22
3975: PUSH
3976: LD_INT 1
3978: ARRAY
3979: PPUSH
3980: LD_INT 104
3982: PPUSH
3983: LD_INT 94
3985: PPUSH
3986: CALL 9634 0 3
// if GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) = 1 and need_buldozer then
3990: LD_INT 3
3992: PPUSH
3993: LD_INT 24
3995: PPUSH
3996: LD_INT 53
3998: PPUSH
3999: CALL 8530 0 3
4003: PUSH
4004: LD_INT 1
4006: EQUAL
4007: PUSH
4008: LD_EXP 17
4012: AND
4013: IFFALSE 4154
// begin need_buldozer := false ;
4015: LD_ADDR_EXP 17
4019: PUSH
4020: LD_INT 0
4022: ST_TO_ADDR
// ComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 67 , 39 ) ;
4023: LD_INT 3
4025: PPUSH
4026: LD_INT 24
4028: PPUSH
4029: LD_INT 53
4031: PPUSH
4032: CALL 8530 0 3
4036: PUSH
4037: LD_INT 1
4039: ARRAY
4040: PPUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 39
4046: PPUSH
4047: CALL_OW 111
// AddComMoveXY ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 71 , 10 ) ;
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 24
4056: PPUSH
4057: LD_INT 53
4059: PPUSH
4060: CALL 8530 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: LD_INT 71
4071: PPUSH
4072: LD_INT 10
4074: PPUSH
4075: CALL_OW 171
// CutTreeInArea ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , cut_area ) ;
4079: LD_INT 3
4081: PPUSH
4082: LD_INT 24
4084: PPUSH
4085: LD_INT 53
4087: PPUSH
4088: CALL 8530 0 3
4092: PUSH
4093: LD_INT 1
4095: ARRAY
4096: PPUSH
4097: LD_INT 15
4099: PPUSH
4100: CALL 6119 0 2
// AddComWait ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , 0 0$10 ) ;
4104: LD_INT 3
4106: PPUSH
4107: LD_INT 24
4109: PPUSH
4110: LD_INT 53
4112: PPUSH
4113: CALL 8530 0 3
4117: PUSH
4118: LD_INT 1
4120: ARRAY
4121: PPUSH
4122: LD_INT 350
4124: PPUSH
4125: CALL_OW 202
// AddComRecycle ( GetVehicle ( 3 , ru_heavy_tracked , ru_bulldozer ) [ 1 ] , ru_fac ) ;
4129: LD_INT 3
4131: PPUSH
4132: LD_INT 24
4134: PPUSH
4135: LD_INT 53
4137: PPUSH
4138: CALL 8530 0 3
4142: PUSH
4143: LD_INT 1
4145: ARRAY
4146: PPUSH
4147: LD_INT 14
4149: PPUSH
4150: CALL_OW 228
// end ; if GetResourceVisibility ( 67 , 39 , 3 ) and HexInfo ( 67 , 39 ) = 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot and EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4154: LD_INT 67
4156: PPUSH
4157: LD_INT 39
4159: PPUSH
4160: LD_INT 3
4162: PPUSH
4163: CALL_OW 440
4167: PUSH
4168: LD_INT 67
4170: PPUSH
4171: LD_INT 39
4173: PPUSH
4174: CALL_OW 428
4178: PUSH
4179: LD_INT 0
4181: EQUAL
4182: AND
4183: PUSH
4184: LD_INT 79
4186: PPUSH
4187: LD_INT 45
4189: PPUSH
4190: CALL_OW 428
4194: PPUSH
4195: CALL_OW 266
4199: PUSH
4200: LD_INT 0
4202: EQUAL
4203: AND
4204: PUSH
4205: LD_INT 1
4207: PPUSH
4208: LD_INT 79
4210: PPUSH
4211: LD_INT 45
4213: PPUSH
4214: CALL 6005 0 3
4218: PUSH
4219: LD_INT 0
4221: EQUAL
4222: AND
4223: IFFALSE 4326
// begin for i = 1 to ru_eng do
4225: LD_ADDR_VAR 0 1
4229: PUSH
4230: DOUBLE
4231: LD_INT 1
4233: DEC
4234: ST_TO_ADDR
4235: LD_EXP 20
4239: PUSH
4240: FOR_TO
4241: IFFALSE 4324
// if IsInUnit ( ru_eng [ i ] ) then
4243: LD_EXP 20
4247: PUSH
4248: LD_VAR 0 1
4252: ARRAY
4253: PPUSH
4254: CALL_OW 310
4258: IFFALSE 4277
// ComExitBuilding ( ru_eng [ i ] ) else
4260: LD_EXP 20
4264: PUSH
4265: LD_VAR 0 1
4269: ARRAY
4270: PPUSH
4271: CALL_OW 122
4275: GO 4322
// if not HasTask ( ru_eng [ i ] ) then
4277: LD_EXP 20
4281: PUSH
4282: LD_VAR 0 1
4286: ARRAY
4287: PPUSH
4288: CALL_OW 314
4292: NOT
4293: IFFALSE 4322
// ComBuild ( ru_eng [ i ] , b_siberite_mine , 67 , 39 , 3 ) ;
4295: LD_EXP 20
4299: PUSH
4300: LD_VAR 0 1
4304: ARRAY
4305: PPUSH
4306: LD_INT 30
4308: PPUSH
4309: LD_INT 67
4311: PPUSH
4312: LD_INT 39
4314: PPUSH
4315: LD_INT 3
4317: PPUSH
4318: CALL_OW 145
4322: GO 4240
4324: POP
4325: POP
// end ; if EnemyNearbyBase ( 1 , 79 , 45 ) = false then
4326: LD_INT 1
4328: PPUSH
4329: LD_INT 79
4331: PPUSH
4332: LD_INT 45
4334: PPUSH
4335: CALL 6005 0 3
4339: PUSH
4340: LD_INT 0
4342: EQUAL
4343: IFFALSE 4539
// begin if HexInfo ( 79 , 45 ) = 0 then
4345: LD_INT 79
4347: PPUSH
4348: LD_INT 45
4350: PPUSH
4351: CALL_OW 428
4355: PUSH
4356: LD_INT 0
4358: EQUAL
4359: IFFALSE 4381
// ComBuildDepot ( ru_eng , 79 , 45 , 3 ) else
4361: LD_EXP 20
4365: PPUSH
4366: LD_INT 79
4368: PPUSH
4369: LD_INT 45
4371: PPUSH
4372: LD_INT 3
4374: PPUSH
4375: CALL 7545 0 4
4379: GO 4539
// if HexInfo ( 89 , 66 ) = 0 and GetResourceVisibility ( 89 , 66 , 3 ) then
4381: LD_INT 89
4383: PPUSH
4384: LD_INT 66
4386: PPUSH
4387: CALL_OW 428
4391: PUSH
4392: LD_INT 0
4394: EQUAL
4395: PUSH
4396: LD_INT 89
4398: PPUSH
4399: LD_INT 66
4401: PPUSH
4402: LD_INT 3
4404: PPUSH
4405: CALL_OW 440
4409: AND
4410: IFFALSE 4539
// begin SetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , mat_cans , 100 ) ;
4412: LD_INT 79
4414: PPUSH
4415: LD_INT 45
4417: PPUSH
4418: CALL_OW 428
4422: PPUSH
4423: CALL_OW 274
4427: PPUSH
4428: LD_INT 1
4430: PPUSH
4431: LD_INT 100
4433: PPUSH
4434: CALL_OW 277
// for i = 1 to ru_eng do
4438: LD_ADDR_VAR 0 1
4442: PUSH
4443: DOUBLE
4444: LD_INT 1
4446: DEC
4447: ST_TO_ADDR
4448: LD_EXP 20
4452: PUSH
4453: FOR_TO
4454: IFFALSE 4537
// if IsInUnit ( ru_eng [ i ] ) then
4456: LD_EXP 20
4460: PUSH
4461: LD_VAR 0 1
4465: ARRAY
4466: PPUSH
4467: CALL_OW 310
4471: IFFALSE 4490
// ComExitBuilding ( ru_eng [ i ] ) else
4473: LD_EXP 20
4477: PUSH
4478: LD_VAR 0 1
4482: ARRAY
4483: PPUSH
4484: CALL_OW 122
4488: GO 4535
// if not HasTask ( ru_eng [ i ] ) then
4490: LD_EXP 20
4494: PUSH
4495: LD_VAR 0 1
4499: ARRAY
4500: PPUSH
4501: CALL_OW 314
4505: NOT
4506: IFFALSE 4535
// ComBuild ( ru_eng [ i ] , b_oil_mine , 89 , 66 , 3 ) ;
4508: LD_EXP 20
4512: PUSH
4513: LD_VAR 0 1
4517: ARRAY
4518: PPUSH
4519: LD_INT 29
4521: PPUSH
4522: LD_INT 89
4524: PPUSH
4525: LD_INT 66
4527: PPUSH
4528: LD_INT 3
4530: PPUSH
4531: CALL_OW 145
4535: GO 4453
4537: POP
4538: POP
// end ; end ; if GetBuilding ( 3 , b_oil_mine ) = 0 and EnemyNearbyBase ( 1 , 36 , 6 ) = false and Cost ( MyBase ( 3 ) , b_oil_mine ) then
4539: LD_INT 3
4541: PPUSH
4542: LD_INT 29
4544: PPUSH
4545: CALL 6777 0 2
4549: PUSH
4550: LD_INT 0
4552: EQUAL
4553: PUSH
4554: LD_INT 1
4556: PPUSH
4557: LD_INT 36
4559: PPUSH
4560: LD_INT 6
4562: PPUSH
4563: CALL 6005 0 3
4567: PUSH
4568: LD_INT 0
4570: EQUAL
4571: AND
4572: PUSH
4573: LD_INT 3
4575: PPUSH
4576: CALL 6686 0 1
4580: PPUSH
4581: LD_INT 29
4583: PPUSH
4584: CALL 6262 0 2
4588: AND
4589: IFFALSE 4692
// begin for i = 1 to ru_eng do
4591: LD_ADDR_VAR 0 1
4595: PUSH
4596: DOUBLE
4597: LD_INT 1
4599: DEC
4600: ST_TO_ADDR
4601: LD_EXP 20
4605: PUSH
4606: FOR_TO
4607: IFFALSE 4690
// begin if IsInUnit ( ru_eng [ i ] ) then
4609: LD_EXP 20
4613: PUSH
4614: LD_VAR 0 1
4618: ARRAY
4619: PPUSH
4620: CALL_OW 310
4624: IFFALSE 4643
// ComExitBuilding ( ru_eng [ i ] ) else
4626: LD_EXP 20
4630: PUSH
4631: LD_VAR 0 1
4635: ARRAY
4636: PPUSH
4637: CALL_OW 122
4641: GO 4688
// if not HasTask ( ru_eng [ i ] ) then
4643: LD_EXP 20
4647: PUSH
4648: LD_VAR 0 1
4652: ARRAY
4653: PPUSH
4654: CALL_OW 314
4658: NOT
4659: IFFALSE 4688
// begin AddComBuild ( ru_eng [ i ] , b_oil_mine , 33 , 4 , 0 ) ;
4661: LD_EXP 20
4665: PUSH
4666: LD_VAR 0 1
4670: ARRAY
4671: PPUSH
4672: LD_INT 29
4674: PPUSH
4675: LD_INT 33
4677: PPUSH
4678: LD_INT 4
4680: PPUSH
4681: LD_INT 0
4683: PPUSH
4684: CALL_OW 205
// end ; end ;
4688: GO 4606
4690: POP
4691: POP
// end ; if ru_eng and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4692: LD_EXP 20
4696: PUSH
4697: LD_INT 79
4699: PPUSH
4700: LD_INT 45
4702: PPUSH
4703: CALL_OW 428
4707: PUSH
4708: LD_INT 0
4710: GREATER
4711: AND
4712: PUSH
4713: LD_INT 79
4715: PPUSH
4716: LD_INT 45
4718: PPUSH
4719: CALL_OW 428
4723: PPUSH
4724: CALL_OW 266
4728: PUSH
4729: LD_INT 0
4731: EQUAL
4732: AND
4733: IFFALSE 4893
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 3 ) >= 10 then
4735: LD_INT 79
4737: PPUSH
4738: LD_INT 45
4740: PPUSH
4741: CALL_OW 428
4745: PPUSH
4746: CALL_OW 255
4750: PUSH
4751: LD_INT 3
4753: EQUAL
4754: PUSH
4755: LD_INT 1
4757: PPUSH
4758: LD_INT 79
4760: PPUSH
4761: LD_INT 45
4763: PPUSH
4764: CALL 6005 0 3
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: AND
4773: PUSH
4774: LD_INT 79
4776: PPUSH
4777: LD_INT 45
4779: PPUSH
4780: CALL_OW 428
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 3
4792: PPUSH
4793: CALL_OW 275
4797: PUSH
4798: LD_INT 10
4800: GREATEREQUAL
4801: AND
4802: IFFALSE 4893
// begin if IsInUnit ( ru_eng [ 1 ] ) then
4804: LD_EXP 20
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: CALL_OW 310
4817: IFFALSE 4834
// ComExitBuilding ( ru_eng [ 1 ] ) else
4819: LD_EXP 20
4823: PUSH
4824: LD_INT 1
4826: ARRAY
4827: PPUSH
4828: CALL_OW 122
4832: GO 4893
// if not HasTask ( ru_eng [ 1 ] ) then
4834: LD_EXP 20
4838: PUSH
4839: LD_INT 1
4841: ARRAY
4842: PPUSH
4843: CALL_OW 314
4847: NOT
4848: IFFALSE 4893
// begin ComTransport ( ru_eng [ 1 ] , HexInfo ( 79 , 45 ) , 3 ) ;
4850: LD_EXP 20
4854: PUSH
4855: LD_INT 1
4857: ARRAY
4858: PPUSH
4859: LD_INT 79
4861: PPUSH
4862: LD_INT 45
4864: PPUSH
4865: CALL_OW 428
4869: PPUSH
4870: LD_INT 3
4872: PPUSH
4873: CALL_OW 151
// AddComGive ( ru_eng [ 1 ] , ru_depot ) ;
4877: LD_EXP 20
4881: PUSH
4882: LD_INT 1
4884: ARRAY
4885: PPUSH
4886: LD_INT 2
4888: PPUSH
4889: CALL_OW 221
// end ; end ; if ru_eng > 2 and HexInfo ( 79 , 45 ) > 0 and GetBType ( HexInfo ( 79 , 45 ) ) = b_depot then
4893: LD_EXP 20
4897: PUSH
4898: LD_INT 2
4900: GREATER
4901: PUSH
4902: LD_INT 79
4904: PPUSH
4905: LD_INT 45
4907: PPUSH
4908: CALL_OW 428
4912: PUSH
4913: LD_INT 0
4915: GREATER
4916: AND
4917: PUSH
4918: LD_INT 79
4920: PPUSH
4921: LD_INT 45
4923: PPUSH
4924: CALL_OW 428
4928: PPUSH
4929: CALL_OW 266
4933: PUSH
4934: LD_INT 0
4936: EQUAL
4937: AND
4938: IFFALSE 5098
// if GetSide ( HexInfo ( 79 , 45 ) ) = 3 and EnemyNearbyBase ( 1 , 79 , 45 ) = false and GetResourceType ( GetBase ( HexInfo ( 79 , 45 ) ) , 1 ) > 20 then
4940: LD_INT 79
4942: PPUSH
4943: LD_INT 45
4945: PPUSH
4946: CALL_OW 428
4950: PPUSH
4951: CALL_OW 255
4955: PUSH
4956: LD_INT 3
4958: EQUAL
4959: PUSH
4960: LD_INT 1
4962: PPUSH
4963: LD_INT 79
4965: PPUSH
4966: LD_INT 45
4968: PPUSH
4969: CALL 6005 0 3
4973: PUSH
4974: LD_INT 0
4976: EQUAL
4977: AND
4978: PUSH
4979: LD_INT 79
4981: PPUSH
4982: LD_INT 45
4984: PPUSH
4985: CALL_OW 428
4989: PPUSH
4990: CALL_OW 274
4994: PPUSH
4995: LD_INT 1
4997: PPUSH
4998: CALL_OW 275
5002: PUSH
5003: LD_INT 20
5005: GREATER
5006: AND
5007: IFFALSE 5098
// begin if IsInUnit ( ru_eng [ 2 ] ) then
5009: LD_EXP 20
5013: PUSH
5014: LD_INT 2
5016: ARRAY
5017: PPUSH
5018: CALL_OW 310
5022: IFFALSE 5039
// ComExitBuilding ( ru_eng [ 2 ] ) else
5024: LD_EXP 20
5028: PUSH
5029: LD_INT 2
5031: ARRAY
5032: PPUSH
5033: CALL_OW 122
5037: GO 5098
// if not HasTask ( ru_eng [ 2 ] ) then
5039: LD_EXP 20
5043: PUSH
5044: LD_INT 2
5046: ARRAY
5047: PPUSH
5048: CALL_OW 314
5052: NOT
5053: IFFALSE 5098
// begin ComTransport ( ru_eng [ 2 ] , HexInfo ( 79 , 45 ) , 1 ) ;
5055: LD_EXP 20
5059: PUSH
5060: LD_INT 2
5062: ARRAY
5063: PPUSH
5064: LD_INT 79
5066: PPUSH
5067: LD_INT 45
5069: PPUSH
5070: CALL_OW 428
5074: PPUSH
5075: LD_INT 1
5077: PPUSH
5078: CALL_OW 151
// AddComGive ( ru_eng [ 2 ] , ru_depot ) ;
5082: LD_EXP 20
5086: PUSH
5087: LD_INT 2
5089: ARRAY
5090: PPUSH
5091: LD_INT 2
5093: PPUSH
5094: CALL_OW 221
// end ; end ; if EnemyNearbyBase ( 1 , 59 , 60 ) = false and EnemyNearbyBase ( 1 , 67 , 76 ) = false and EnemyNearbyBase ( 1 , 79 , 100 ) = false then
5098: LD_INT 1
5100: PPUSH
5101: LD_INT 59
5103: PPUSH
5104: LD_INT 60
5106: PPUSH
5107: CALL 6005 0 3
5111: PUSH
5112: LD_INT 0
5114: EQUAL
5115: PUSH
5116: LD_INT 1
5118: PPUSH
5119: LD_INT 67
5121: PPUSH
5122: LD_INT 76
5124: PPUSH
5125: CALL 6005 0 3
5129: PUSH
5130: LD_INT 0
5132: EQUAL
5133: AND
5134: PUSH
5135: LD_INT 1
5137: PPUSH
5138: LD_INT 79
5140: PPUSH
5141: LD_INT 100
5143: PPUSH
5144: CALL 6005 0 3
5148: PUSH
5149: LD_INT 0
5151: EQUAL
5152: AND
5153: IFFALSE 5165
// CollectCrates ( 3 , west_crates ) ;
5155: LD_INT 3
5157: PPUSH
5158: LD_INT 13
5160: PPUSH
5161: CALL 12050 0 2
// end ;
5165: PPOPN 10
5167: END
// every 4 4$00 + 2 2$00 trigger tick <= 53 53$00 or not helps_arrive do var veh ;
5168: LD_OWVAR 1
5172: PUSH
5173: LD_INT 111300
5175: LESSEQUAL
5176: PUSH
5177: LD_EXP 29
5181: NOT
5182: OR
5183: IFFALSE 5380
5185: GO 5187
5187: DISABLE
5188: LD_INT 0
5190: PPUSH
// begin enable ;
5191: ENABLE
// uc_nation := 3 ;
5192: LD_ADDR_OWVAR 21
5196: PUSH
5197: LD_INT 3
5199: ST_TO_ADDR
// uc_side := 3 ;
5200: LD_ADDR_OWVAR 20
5204: PUSH
5205: LD_INT 3
5207: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
5208: LD_ADDR_OWVAR 37
5212: PUSH
5213: LD_INT 22
5215: ST_TO_ADDR
// vc_engine := engine_siberite ;
5216: LD_ADDR_OWVAR 39
5220: PUSH
5221: LD_INT 3
5223: ST_TO_ADDR
// vc_control := control_computer ;
5224: LD_ADDR_OWVAR 38
5228: PUSH
5229: LD_INT 3
5231: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
5232: LD_ADDR_OWVAR 40
5236: PUSH
5237: LD_INT 51
5239: ST_TO_ADDR
// veh := CreateVehicle ;
5240: LD_ADDR_VAR 0 1
5244: PUSH
5245: CALL_OW 45
5249: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5250: LD_VAR 0 1
5254: PPUSH
5255: LD_INT 4
5257: PPUSH
5258: CALL_OW 233
// PlaceUnitArea ( veh , upper_road_area , false ) ;
5262: LD_VAR 0 1
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: LD_INT 0
5272: PPUSH
5273: CALL_OW 49
// SetCargo ( veh , [ 1 , 2 , 3 , 2 ] [ Rand ( 1 , 4 ) ] , 100 ) ;
5277: LD_VAR 0 1
5281: PPUSH
5282: LD_INT 1
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: LD_INT 3
5290: PUSH
5291: LD_INT 2
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: PUSH
5300: LD_INT 1
5302: PPUSH
5303: LD_INT 4
5305: PPUSH
5306: CALL_OW 12
5310: ARRAY
5311: PPUSH
5312: LD_INT 100
5314: PPUSH
5315: CALL_OW 290
// ComGive ( veh , ru_depot ) ;
5319: LD_VAR 0 1
5323: PPUSH
5324: LD_INT 2
5326: PPUSH
5327: CALL_OW 161
// AddComMoveToArea ( veh , upper_road_area ) ;
5331: LD_VAR 0 1
5335: PPUSH
5336: LD_INT 10
5338: PPUSH
5339: CALL_OW 173
// Wait ( 0 0$10 ) ;
5343: LD_INT 350
5345: PPUSH
5346: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// until IsInArea ( veh , upper_road_area ) ;
5357: LD_VAR 0 1
5361: PPUSH
5362: LD_INT 10
5364: PPUSH
5365: CALL_OW 308
5369: IFFALSE 5350
// RemoveUnit ( veh ) ;
5371: LD_VAR 0 1
5375: PPUSH
5376: CALL_OW 64
// end ;
5380: PPOPN 1
5382: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 3 and un in FilterAllUnits ( [ [ f_or , [ f_weapon , ru_heavy_gun ] , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ] ) then
5383: LD_VAR 0 1
5387: PPUSH
5388: CALL_OW 255
5392: PUSH
5393: LD_INT 3
5395: EQUAL
5396: PUSH
5397: LD_VAR 0 1
5401: PUSH
5402: LD_INT 2
5404: PUSH
5405: LD_INT 34
5407: PUSH
5408: LD_INT 46
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PUSH
5415: LD_INT 34
5417: PUSH
5418: LD_INT 47
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: LD_INT 34
5427: PUSH
5428: LD_INT 45
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: LIST
5439: LIST
5440: PUSH
5441: EMPTY
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: IN
5449: AND
5450: IFFALSE 5468
// ru_reserve := ru_reserve ^ un ;
5452: LD_ADDR_EXP 8
5456: PUSH
5457: LD_EXP 8
5461: PUSH
5462: LD_VAR 0 1
5466: ADD
5467: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
5468: LD_VAR 0 1
5472: PUSH
5473: LD_INT 22
5475: PUSH
5476: LD_INT 3
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: PUSH
5483: LD_INT 34
5485: PUSH
5486: LD_INT 48
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PPUSH
5497: CALL_OW 69
5501: IN
5502: IFFALSE 5555
// if FilterUnitsInArea ( alt_base , [ f_side , 1 ] ) then
5504: LD_INT 12
5506: PPUSH
5507: LD_INT 22
5509: PUSH
5510: LD_INT 1
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PPUSH
5517: CALL_OW 70
5521: IFFALSE 5540
// ComAttackPlace ( un , 98 , 10 ) else
5523: LD_VAR 0 1
5527: PPUSH
5528: LD_INT 98
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 116
5538: GO 5555
// ComAttackPlace ( un , 134 , 99 ) ;
5540: LD_VAR 0 1
5544: PPUSH
5545: LD_INT 134
5547: PPUSH
5548: LD_INT 99
5550: PPUSH
5551: CALL_OW 116
// end ;
5555: PPOPN 2
5557: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not GetBType ( un ) in [ b_depot , b_oil_mine , b_siberite_mine , b_oil_power ] then
5558: LD_VAR 0 1
5562: PUSH
5563: LD_INT 22
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: PUSH
5573: LD_INT 21
5575: PUSH
5576: LD_INT 3
5578: PUSH
5579: EMPTY
5580: LIST
5581: LIST
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: PPUSH
5587: CALL_OW 69
5591: IN
5592: PUSH
5593: LD_VAR 0 1
5597: PPUSH
5598: CALL_OW 266
5602: PUSH
5603: LD_INT 0
5605: PUSH
5606: LD_INT 29
5608: PUSH
5609: LD_INT 30
5611: PUSH
5612: LD_INT 26
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: LIST
5620: IN
5621: NOT
5622: AND
5623: IFFALSE 5709
// begin ru_blist := ru_blist ^ GetBType ( un ) ;
5625: LD_ADDR_EXP 12
5629: PUSH
5630: LD_EXP 12
5634: PUSH
5635: LD_VAR 0 1
5639: PPUSH
5640: CALL_OW 266
5644: ADD
5645: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( un ) ;
5646: LD_ADDR_EXP 12
5650: PUSH
5651: LD_EXP 12
5655: PUSH
5656: LD_VAR 0 1
5660: PPUSH
5661: CALL_OW 250
5665: ADD
5666: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( un ) ;
5667: LD_ADDR_EXP 12
5671: PUSH
5672: LD_EXP 12
5676: PUSH
5677: LD_VAR 0 1
5681: PPUSH
5682: CALL_OW 251
5686: ADD
5687: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( un ) ;
5688: LD_ADDR_EXP 12
5692: PUSH
5693: LD_EXP 12
5697: PUSH
5698: LD_VAR 0 1
5702: PPUSH
5703: CALL_OW 254
5707: ADD
5708: ST_TO_ADDR
// end ; if un in ru_attack_list then
5709: LD_VAR 0 1
5713: PUSH
5714: LD_EXP 9
5718: IN
5719: IFFALSE 5737
// ru_attack_list := ru_attack_list diff un ;
5721: LD_ADDR_EXP 9
5725: PUSH
5726: LD_EXP 9
5730: PUSH
5731: LD_VAR 0 1
5735: DIFF
5736: ST_TO_ADDR
// if un in ru_protector then
5737: LD_VAR 0 1
5741: PUSH
5742: LD_EXP 16
5746: IN
5747: IFFALSE 5765
// ru_protector := ru_protector diff un ;
5749: LD_ADDR_EXP 16
5753: PUSH
5754: LD_EXP 16
5758: PUSH
5759: LD_VAR 0 1
5763: DIFF
5764: ST_TO_ADDR
// if GetBType ( un ) = b_siberite_mine and GetSide ( un ) = 1 then
5765: LD_VAR 0 1
5769: PPUSH
5770: CALL_OW 266
5774: PUSH
5775: LD_INT 30
5777: EQUAL
5778: PUSH
5779: LD_VAR 0 1
5783: PPUSH
5784: CALL_OW 255
5788: PUSH
5789: LD_INT 1
5791: EQUAL
5792: AND
5793: IFFALSE 5803
// mine_ck := true ;
5795: LD_ADDR_EXP 34
5799: PUSH
5800: LD_INT 1
5802: ST_TO_ADDR
// end ;
5803: PPOPN 1
5805: END
// on BuildingComplete ( un ) do var i ;
5806: LD_INT 0
5808: PPUSH
// begin if GetSide ( un ) = 1 and GetBType ( un ) = b_siberite_mine then
5809: LD_VAR 0 1
5813: PPUSH
5814: CALL_OW 255
5818: PUSH
5819: LD_INT 1
5821: EQUAL
5822: PUSH
5823: LD_VAR 0 1
5827: PPUSH
5828: CALL_OW 266
5832: PUSH
5833: LD_INT 30
5835: EQUAL
5836: AND
5837: IFFALSE 5847
// mine_constructed := true ;
5839: LD_ADDR_EXP 36
5843: PUSH
5844: LD_INT 1
5846: ST_TO_ADDR
// if GetSide ( un ) = 3 and GetBType ( un ) = b_depot then
5847: LD_VAR 0 1
5851: PPUSH
5852: CALL_OW 255
5856: PUSH
5857: LD_INT 3
5859: EQUAL
5860: PUSH
5861: LD_VAR 0 1
5865: PPUSH
5866: CALL_OW 266
5870: PUSH
5871: LD_INT 0
5873: EQUAL
5874: AND
5875: IFFALSE 5932
// begin for i = 1 to 2 do
5877: LD_ADDR_VAR 0 2
5881: PUSH
5882: DOUBLE
5883: LD_INT 1
5885: DEC
5886: ST_TO_ADDR
5887: LD_INT 2
5889: PUSH
5890: FOR_TO
5891: IFFALSE 5930
// begin ComExitBuilding ( ru_sold [ i ] ) ;
5893: LD_EXP 19
5897: PUSH
5898: LD_VAR 0 2
5902: ARRAY
5903: PPUSH
5904: CALL_OW 122
// AddComEnterUnit ( ru_sold [ i ] , un ) ;
5908: LD_EXP 19
5912: PUSH
5913: LD_VAR 0 2
5917: ARRAY
5918: PPUSH
5919: LD_VAR 0 1
5923: PPUSH
5924: CALL_OW 180
// end ;
5928: GO 5890
5930: POP
5931: POP
// end ; if GetSide ( un ) = 3 and GetBType ( un ) in ru_blist then
5932: LD_VAR 0 1
5936: PPUSH
5937: CALL_OW 255
5941: PUSH
5942: LD_INT 3
5944: EQUAL
5945: PUSH
5946: LD_VAR 0 1
5950: PPUSH
5951: CALL_OW 266
5955: PUSH
5956: LD_EXP 12
5960: IN
5961: AND
5962: IFFALSE 6002
// for i = 1 to 4 do
5964: LD_ADDR_VAR 0 2
5968: PUSH
5969: DOUBLE
5970: LD_INT 1
5972: DEC
5973: ST_TO_ADDR
5974: LD_INT 4
5976: PUSH
5977: FOR_TO
5978: IFFALSE 6000
// ru_blist := Delete ( ru_blist , 1 ) ;
5980: LD_ADDR_EXP 12
5984: PUSH
5985: LD_EXP 12
5989: PPUSH
5990: LD_INT 1
5992: PPUSH
5993: CALL_OW 3
5997: ST_TO_ADDR
5998: GO 5977
6000: POP
6001: POP
// end ; end_of_file
6002: PPOPN 2
6004: END
// export function EnemyNearbyBase ( side , x , y ) ; var i ; begin
6005: LD_INT 0
6007: PPUSH
6008: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
6009: LD_ADDR_VAR 0 5
6013: PUSH
6014: LD_INT 22
6016: PUSH
6017: LD_VAR 0 1
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: PPUSH
6026: CALL_OW 69
6030: PPUSH
6031: LD_VAR 0 2
6035: PPUSH
6036: LD_VAR 0 3
6040: PPUSH
6041: CALL_OW 73
6045: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( ru_base_area , [ f_side , side ] ) > 0 then
6046: LD_VAR 0 5
6050: PPUSH
6051: LD_VAR 0 2
6055: PPUSH
6056: LD_VAR 0 3
6060: PPUSH
6061: CALL_OW 297
6065: PUSH
6066: LD_INT 17
6068: LESS
6069: PUSH
6070: LD_INT 2
6072: PPUSH
6073: LD_INT 22
6075: PUSH
6076: LD_VAR 0 1
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PPUSH
6085: CALL_OW 70
6089: PUSH
6090: LD_INT 0
6092: GREATER
6093: OR
6094: IFFALSE 6106
// result := true else
6096: LD_ADDR_VAR 0 4
6100: PUSH
6101: LD_INT 1
6103: ST_TO_ADDR
6104: GO 6114
// result := false ;
6106: LD_ADDR_VAR 0 4
6110: PUSH
6111: LD_INT 0
6113: ST_TO_ADDR
// end ;
6114: LD_VAR 0 4
6118: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
6119: LD_INT 0
6121: PPUSH
6122: PPUSH
// area = ListEnvironmentArea ( area ) ;
6123: LD_ADDR_VAR 0 2
6127: PUSH
6128: LD_VAR 0 2
6132: PPUSH
6133: CALL_OW 353
6137: ST_TO_ADDR
// if bulldozer > 0 then
6138: LD_VAR 0 1
6142: PUSH
6143: LD_INT 0
6145: GREATER
6146: IFFALSE 6257
// for i = 1 to area do
6148: LD_ADDR_VAR 0 4
6152: PUSH
6153: DOUBLE
6154: LD_INT 1
6156: DEC
6157: ST_TO_ADDR
6158: LD_VAR 0 2
6162: PUSH
6163: FOR_TO
6164: IFFALSE 6255
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
6166: LD_VAR 0 2
6170: PUSH
6171: LD_VAR 0 4
6175: ARRAY
6176: PUSH
6177: LD_INT 1
6179: ARRAY
6180: PPUSH
6181: LD_VAR 0 2
6185: PUSH
6186: LD_VAR 0 4
6190: ARRAY
6191: PUSH
6192: LD_INT 2
6194: ARRAY
6195: PPUSH
6196: CALL_OW 351
6200: IFFALSE 6253
// if not HasTask ( bulldozer ) then
6202: LD_VAR 0 1
6206: PPUSH
6207: CALL_OW 314
6211: NOT
6212: IFFALSE 6253
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
6214: LD_VAR 0 1
6218: PPUSH
6219: LD_VAR 0 2
6223: PUSH
6224: LD_VAR 0 4
6228: ARRAY
6229: PUSH
6230: LD_INT 1
6232: ARRAY
6233: PPUSH
6234: LD_VAR 0 2
6238: PUSH
6239: LD_VAR 0 4
6243: ARRAY
6244: PUSH
6245: LD_INT 2
6247: ARRAY
6248: PPUSH
6249: CALL_OW 171
6253: GO 6163
6255: POP
6256: POP
// end ;
6257: LD_VAR 0 3
6261: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
6262: LD_INT 0
6264: PPUSH
6265: PPUSH
6266: PPUSH
// pom := GetBase ( bdepot ) ;
6267: LD_ADDR_VAR 0 4
6271: PUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 274
6281: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
6282: LD_ADDR_VAR 0 5
6286: PUSH
6287: LD_VAR 0 2
6291: PPUSH
6292: LD_VAR 0 1
6296: PPUSH
6297: CALL_OW 248
6301: PPUSH
6302: CALL_OW 450
6306: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
6307: LD_VAR 0 4
6311: PPUSH
6312: LD_INT 1
6314: PPUSH
6315: CALL_OW 275
6319: PUSH
6320: LD_VAR 0 5
6324: PUSH
6325: LD_INT 1
6327: ARRAY
6328: GREATEREQUAL
6329: PUSH
6330: LD_VAR 0 4
6334: PPUSH
6335: LD_INT 3
6337: PPUSH
6338: CALL_OW 275
6342: PUSH
6343: LD_VAR 0 5
6347: PUSH
6348: LD_INT 3
6350: ARRAY
6351: GREATEREQUAL
6352: AND
6353: IFFALSE 6365
// result := true else
6355: LD_ADDR_VAR 0 3
6359: PUSH
6360: LD_INT 1
6362: ST_TO_ADDR
6363: GO 6373
// result := false ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: LD_INT 0
6372: ST_TO_ADDR
// end ;
6373: LD_VAR 0 3
6377: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
6378: LD_INT 0
6380: PPUSH
6381: PPUSH
6382: PPUSH
// pom := GetBase ( bdepot ) ;
6383: LD_ADDR_VAR 0 3
6387: PUSH
6388: LD_VAR 0 1
6392: PPUSH
6393: CALL_OW 274
6397: ST_TO_ADDR
// sor := [ ] ;
6398: LD_ADDR_VAR 0 4
6402: PUSH
6403: EMPTY
6404: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
6405: LD_ADDR_VAR 0 4
6409: PUSH
6410: LD_VAR 0 4
6414: PUSH
6415: LD_VAR 0 3
6419: PPUSH
6420: LD_INT 1
6422: PPUSH
6423: CALL_OW 275
6427: ADD
6428: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
6429: LD_ADDR_VAR 0 4
6433: PUSH
6434: LD_VAR 0 4
6438: PUSH
6439: LD_VAR 0 3
6443: PPUSH
6444: LD_INT 2
6446: PPUSH
6447: CALL_OW 275
6451: ADD
6452: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
6453: LD_ADDR_VAR 0 4
6457: PUSH
6458: LD_VAR 0 4
6462: PUSH
6463: LD_VAR 0 3
6467: PPUSH
6468: LD_INT 3
6470: PPUSH
6471: CALL_OW 275
6475: ADD
6476: ST_TO_ADDR
// result := sor ;
6477: LD_ADDR_VAR 0 2
6481: PUSH
6482: LD_VAR 0 4
6486: ST_TO_ADDR
// end ;
6487: LD_VAR 0 2
6491: RET
// export function Hex ( x , y ) ; begin
6492: LD_INT 0
6494: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
6495: LD_VAR 0 1
6499: PPUSH
6500: LD_VAR 0 2
6504: PPUSH
6505: CALL_OW 488
6509: PUSH
6510: LD_VAR 0 1
6514: PPUSH
6515: LD_VAR 0 2
6519: PPUSH
6520: CALL_OW 428
6524: PUSH
6525: LD_INT 0
6527: EQUAL
6528: AND
6529: IFFALSE 6541
// result := true else
6531: LD_ADDR_VAR 0 3
6535: PUSH
6536: LD_INT 1
6538: ST_TO_ADDR
6539: GO 6549
// result := false ;
6541: LD_ADDR_VAR 0 3
6545: PUSH
6546: LD_INT 0
6548: ST_TO_ADDR
// end ;
6549: LD_VAR 0 3
6553: RET
// export function NeedBuilding ( side , btype ) ; begin
6554: LD_INT 0
6556: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
6557: LD_INT 22
6559: PUSH
6560: LD_VAR 0 1
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: LD_INT 30
6571: PUSH
6572: LD_VAR 0 2
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 57
6586: PUSH
6587: EMPTY
6588: LIST
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: PPUSH
6599: CALL_OW 69
6603: PUSH
6604: LD_INT 0
6606: EQUAL
6607: IFFALSE 6619
// result := true else
6609: LD_ADDR_VAR 0 3
6613: PUSH
6614: LD_INT 1
6616: ST_TO_ADDR
6617: GO 6627
// result := false ;
6619: LD_ADDR_VAR 0 3
6623: PUSH
6624: LD_INT 0
6626: ST_TO_ADDR
// end ;
6627: LD_VAR 0 3
6631: RET
// export function NeedBase ( side ) ; begin
6632: LD_INT 0
6634: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
6635: LD_VAR 0 1
6639: PPUSH
6640: LD_INT 0
6642: PPUSH
6643: CALL 6554 0 2
6647: PUSH
6648: LD_VAR 0 1
6652: PPUSH
6653: LD_INT 1
6655: PPUSH
6656: CALL 6554 0 2
6660: AND
6661: IFFALSE 6673
// result := true else
6663: LD_ADDR_VAR 0 2
6667: PUSH
6668: LD_INT 1
6670: ST_TO_ADDR
6671: GO 6681
// result := false ;
6673: LD_ADDR_VAR 0 2
6677: PUSH
6678: LD_INT 0
6680: ST_TO_ADDR
// end ;
6681: LD_VAR 0 2
6685: RET
// export function MyBase ( side ) ; begin
6686: LD_INT 0
6688: PPUSH
// if not NeedBase ( side ) then
6689: LD_VAR 0 1
6693: PPUSH
6694: CALL 6632 0 1
6698: NOT
6699: IFFALSE 6764
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
6701: LD_ADDR_VAR 0 2
6705: PUSH
6706: LD_INT 22
6708: PUSH
6709: LD_VAR 0 1
6713: PUSH
6714: EMPTY
6715: LIST
6716: LIST
6717: PUSH
6718: LD_INT 2
6720: PUSH
6721: LD_INT 30
6723: PUSH
6724: LD_INT 0
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: LD_INT 30
6733: PUSH
6734: LD_INT 1
6736: PUSH
6737: EMPTY
6738: LIST
6739: LIST
6740: PUSH
6741: EMPTY
6742: LIST
6743: LIST
6744: LIST
6745: PUSH
6746: EMPTY
6747: LIST
6748: LIST
6749: PUSH
6750: EMPTY
6751: LIST
6752: PPUSH
6753: CALL_OW 69
6757: PUSH
6758: LD_INT 1
6760: ARRAY
6761: ST_TO_ADDR
6762: GO 6772
// result := false ;
6764: LD_ADDR_VAR 0 2
6768: PUSH
6769: LD_INT 0
6771: ST_TO_ADDR
// end ;
6772: LD_VAR 0 2
6776: RET
// export function GetBuilding ( side , btype ) ; begin
6777: LD_INT 0
6779: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
6780: LD_INT 22
6782: PUSH
6783: LD_VAR 0 1
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 30
6794: PUSH
6795: LD_VAR 0 2
6799: PUSH
6800: EMPTY
6801: LIST
6802: LIST
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: PPUSH
6808: CALL_OW 69
6812: PUSH
6813: LD_INT 0
6815: GREATER
6816: IFFALSE 6858
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
6818: LD_ADDR_VAR 0 3
6822: PUSH
6823: LD_INT 22
6825: PUSH
6826: LD_VAR 0 1
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 30
6837: PUSH
6838: LD_VAR 0 2
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: PPUSH
6851: CALL_OW 69
6855: ST_TO_ADDR
6856: GO 6866
// result := false ;
6858: LD_ADDR_VAR 0 3
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// end ;
6866: LD_VAR 0 3
6870: RET
// export function GetCrates ( side ) ; begin
6871: LD_INT 0
6873: PPUSH
// if MyBase ( side ) then
6874: LD_VAR 0 1
6878: PPUSH
6879: CALL 6686 0 1
6883: IFFALSE 6915
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
6885: LD_ADDR_VAR 0 2
6889: PUSH
6890: LD_VAR 0 1
6894: PPUSH
6895: CALL 6686 0 1
6899: PPUSH
6900: CALL_OW 274
6904: PPUSH
6905: LD_INT 1
6907: PPUSH
6908: CALL_OW 275
6912: ST_TO_ADDR
6913: GO 6923
// result := false ;
6915: LD_ADDR_VAR 0 2
6919: PUSH
6920: LD_INT 0
6922: ST_TO_ADDR
// end ;
6923: LD_VAR 0 2
6927: RET
// export function GetLabs ( side ) ; begin
6928: LD_INT 0
6930: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
6931: LD_ADDR_VAR 0 2
6935: PUSH
6936: LD_INT 22
6938: PUSH
6939: LD_VAR 0 1
6943: PUSH
6944: EMPTY
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 2
6950: PUSH
6951: LD_INT 30
6953: PUSH
6954: LD_INT 6
6956: PUSH
6957: EMPTY
6958: LIST
6959: LIST
6960: PUSH
6961: LD_INT 30
6963: PUSH
6964: LD_INT 8
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: PUSH
6971: LD_INT 30
6973: PUSH
6974: LD_INT 7
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: EMPTY
6992: LIST
6993: PPUSH
6994: CALL_OW 69
6998: ST_TO_ADDR
// end ;
6999: LD_VAR 0 2
7003: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
7004: LD_INT 0
7006: PPUSH
7007: PPUSH
7008: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
7009: LD_ADDR_VAR 0 3
7013: PUSH
7014: LD_VAR 0 1
7018: PPUSH
7019: LD_INT 1
7021: PPUSH
7022: CALL_OW 268
7026: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
7027: LD_ADDR_VAR 0 4
7031: PUSH
7032: LD_VAR 0 1
7036: PPUSH
7037: LD_INT 2
7039: PPUSH
7040: CALL_OW 268
7044: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
7045: LD_ADDR_VAR 0 2
7049: PUSH
7050: LD_VAR 0 3
7054: PUSH
7055: LD_VAR 0 4
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: ST_TO_ADDR
// end ;
7064: LD_VAR 0 2
7068: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
7069: LD_INT 0
7071: PPUSH
7072: PPUSH
// result := false ;
7073: LD_ADDR_VAR 0 3
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// for i = 1 to tlist do
7081: LD_ADDR_VAR 0 4
7085: PUSH
7086: DOUBLE
7087: LD_INT 1
7089: DEC
7090: ST_TO_ADDR
7091: LD_VAR 0 2
7095: PUSH
7096: FOR_TO
7097: IFFALSE 7137
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7099: LD_VAR 0 2
7103: PUSH
7104: LD_VAR 0 4
7108: ARRAY
7109: PPUSH
7110: LD_VAR 0 1
7114: PPUSH
7115: CALL_OW 321
7119: PUSH
7120: LD_INT 2
7122: NONEQUAL
7123: IFFALSE 7135
// begin result := true ;
7125: LD_ADDR_VAR 0 3
7129: PUSH
7130: LD_INT 1
7132: ST_TO_ADDR
// break ;
7133: GO 7137
// end ;
7135: GO 7096
7137: POP
7138: POP
// end ;
7139: LD_VAR 0 3
7143: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
7144: LD_INT 0
7146: PPUSH
7147: PPUSH
7148: PPUSH
7149: PPUSH
7150: PPUSH
7151: PPUSH
7152: PPUSH
7153: PPUSH
// lab := GetLabs ( side ) ;
7154: LD_ADDR_VAR 0 5
7158: PUSH
7159: LD_VAR 0 1
7163: PPUSH
7164: CALL 6928 0 1
7168: ST_TO_ADDR
// tmp := 0 ;
7169: LD_ADDR_VAR 0 7
7173: PUSH
7174: LD_INT 0
7176: ST_TO_ADDR
// list := [ ] ;
7177: LD_ADDR_VAR 0 8
7181: PUSH
7182: EMPTY
7183: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
7184: LD_ADDR_VAR 0 10
7188: PUSH
7189: LD_INT 35
7191: PUSH
7192: LD_INT 45
7194: PUSH
7195: LD_INT 46
7197: PUSH
7198: LD_INT 47
7200: PUSH
7201: LD_INT 1
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: LD_INT 48
7209: PUSH
7210: LD_INT 49
7212: PUSH
7213: LD_INT 50
7215: PUSH
7216: LD_INT 20
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: LIST
7230: ST_TO_ADDR
// for i = 1 to tlist do
7231: LD_ADDR_VAR 0 4
7235: PUSH
7236: DOUBLE
7237: LD_INT 1
7239: DEC
7240: ST_TO_ADDR
7241: LD_VAR 0 2
7245: PUSH
7246: FOR_TO
7247: IFFALSE 7299
// if GetTech ( tlist [ i ] , side ) <> state_researched then
7249: LD_VAR 0 2
7253: PUSH
7254: LD_VAR 0 4
7258: ARRAY
7259: PPUSH
7260: LD_VAR 0 1
7264: PPUSH
7265: CALL_OW 321
7269: PUSH
7270: LD_INT 2
7272: NONEQUAL
7273: IFFALSE 7297
// list := list ^ tlist [ i ] ;
7275: LD_ADDR_VAR 0 8
7279: PUSH
7280: LD_VAR 0 8
7284: PUSH
7285: LD_VAR 0 2
7289: PUSH
7290: LD_VAR 0 4
7294: ARRAY
7295: ADD
7296: ST_TO_ADDR
7297: GO 7246
7299: POP
7300: POP
// if list then
7301: LD_VAR 0 8
7305: IFFALSE 7470
// begin for i = 1 to lab do
7307: LD_ADDR_VAR 0 4
7311: PUSH
7312: DOUBLE
7313: LD_INT 1
7315: DEC
7316: ST_TO_ADDR
7317: LD_VAR 0 5
7321: PUSH
7322: FOR_TO
7323: IFFALSE 7393
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
7325: LD_VAR 0 8
7329: PUSH
7330: LD_INT 1
7332: ARRAY
7333: PUSH
7334: LD_VAR 0 10
7338: IN
7339: PUSH
7340: LD_VAR 0 8
7344: PUSH
7345: LD_INT 1
7347: ARRAY
7348: PPUSH
7349: CALL_OW 481
7353: PUSH
7354: LD_VAR 0 5
7358: PUSH
7359: LD_VAR 0 4
7363: ARRAY
7364: PPUSH
7365: CALL 7004 0 1
7369: IN
7370: OR
7371: IFFALSE 7391
// begin mylab := lab [ i ] ;
7373: LD_ADDR_VAR 0 9
7377: PUSH
7378: LD_VAR 0 5
7382: PUSH
7383: LD_VAR 0 4
7387: ARRAY
7388: ST_TO_ADDR
// break ;
7389: GO 7393
// end ;
7391: GO 7322
7393: POP
7394: POP
// if mylab then
7395: LD_VAR 0 9
7399: IFFALSE 7460
// begin if BuildingStatus ( mylab ) = bs_idle then
7401: LD_VAR 0 9
7405: PPUSH
7406: CALL_OW 461
7410: PUSH
7411: LD_INT 2
7413: EQUAL
7414: IFFALSE 7458
// for i = 1 to list do
7416: LD_ADDR_VAR 0 4
7420: PUSH
7421: DOUBLE
7422: LD_INT 1
7424: DEC
7425: ST_TO_ADDR
7426: LD_VAR 0 8
7430: PUSH
7431: FOR_TO
7432: IFFALSE 7456
// AddComResearch ( mylab , list [ i ] ) ;
7434: LD_VAR 0 9
7438: PPUSH
7439: LD_VAR 0 8
7443: PUSH
7444: LD_VAR 0 4
7448: ARRAY
7449: PPUSH
7450: CALL_OW 184
7454: GO 7431
7456: POP
7457: POP
// end else
7458: GO 7468
// result := false ;
7460: LD_ADDR_VAR 0 3
7464: PUSH
7465: LD_INT 0
7467: ST_TO_ADDR
// end else
7468: GO 7478
// result := false ;
7470: LD_ADDR_VAR 0 3
7474: PUSH
7475: LD_INT 0
7477: ST_TO_ADDR
// end ;
7478: LD_VAR 0 3
7482: RET
// export function GetTowers ( side ) ; begin
7483: LD_INT 0
7485: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
7486: LD_ADDR_VAR 0 2
7490: PUSH
7491: LD_INT 22
7493: PUSH
7494: LD_VAR 0 1
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: LD_INT 2
7505: PUSH
7506: LD_INT 30
7508: PUSH
7509: LD_INT 32
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 30
7518: PUSH
7519: LD_INT 33
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: LIST
7530: PUSH
7531: EMPTY
7532: LIST
7533: LIST
7534: PPUSH
7535: CALL_OW 69
7539: ST_TO_ADDR
// end ;
7540: LD_VAR 0 2
7544: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
7545: LD_INT 0
7547: PPUSH
7548: PPUSH
// if Hex ( x , y ) then
7549: LD_VAR 0 2
7553: PPUSH
7554: LD_VAR 0 3
7558: PPUSH
7559: CALL 6492 0 2
7563: IFFALSE 7638
// for i = 1 to plist do
7565: LD_ADDR_VAR 0 6
7569: PUSH
7570: DOUBLE
7571: LD_INT 1
7573: DEC
7574: ST_TO_ADDR
7575: LD_VAR 0 1
7579: PUSH
7580: FOR_TO
7581: IFFALSE 7636
// if not HasTask ( plist [ i ] ) then
7583: LD_VAR 0 1
7587: PUSH
7588: LD_VAR 0 6
7592: ARRAY
7593: PPUSH
7594: CALL_OW 314
7598: NOT
7599: IFFALSE 7634
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
7601: LD_VAR 0 1
7605: PUSH
7606: LD_VAR 0 6
7610: ARRAY
7611: PPUSH
7612: LD_INT 0
7614: PPUSH
7615: LD_VAR 0 2
7619: PPUSH
7620: LD_VAR 0 3
7624: PPUSH
7625: LD_VAR 0 4
7629: PPUSH
7630: CALL_OW 145
7634: GO 7580
7636: POP
7637: POP
// end ;
7638: LD_VAR 0 5
7642: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
7643: LD_INT 0
7645: PPUSH
7646: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
7647: LD_VAR 0 2
7651: PPUSH
7652: CALL_OW 266
7656: PUSH
7657: LD_INT 0
7659: EQUAL
7660: PUSH
7661: LD_VAR 0 2
7665: PPUSH
7666: LD_INT 1
7668: PPUSH
7669: CALL 6262 0 2
7673: AND
7674: PUSH
7675: LD_VAR 0 1
7679: PUSH
7680: LD_INT 1
7682: ARRAY
7683: PPUSH
7684: CALL_OW 255
7688: PPUSH
7689: CALL_OW 345
7693: NOT
7694: AND
7695: IFFALSE 7791
// begin ComUpgrade ( bident ) ;
7697: LD_VAR 0 2
7701: PPUSH
7702: CALL_OW 146
// for i = 1 to plist do
7706: LD_ADDR_VAR 0 4
7710: PUSH
7711: DOUBLE
7712: LD_INT 1
7714: DEC
7715: ST_TO_ADDR
7716: LD_VAR 0 1
7720: PUSH
7721: FOR_TO
7722: IFFALSE 7779
// if not HasTask ( plist [ i ] ) then
7724: LD_VAR 0 1
7728: PUSH
7729: LD_VAR 0 4
7733: ARRAY
7734: PPUSH
7735: CALL_OW 314
7739: NOT
7740: IFFALSE 7777
// ComMoveXY ( plist [ i ] , GetX ( bident ) , GetY ( bident ) ) ;
7742: LD_VAR 0 1
7746: PUSH
7747: LD_VAR 0 4
7751: ARRAY
7752: PPUSH
7753: LD_VAR 0 2
7757: PPUSH
7758: CALL_OW 250
7762: PPUSH
7763: LD_VAR 0 2
7767: PPUSH
7768: CALL_OW 251
7772: PPUSH
7773: CALL_OW 111
7777: GO 7721
7779: POP
7780: POP
// result := true ;
7781: LD_ADDR_VAR 0 3
7785: PUSH
7786: LD_INT 1
7788: ST_TO_ADDR
// end else
7789: GO 7799
// result := false ;
7791: LD_ADDR_VAR 0 3
7795: PUSH
7796: LD_INT 0
7798: ST_TO_ADDR
// end ;
7799: LD_VAR 0 3
7803: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
7804: LD_INT 0
7806: PPUSH
7807: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
7808: LD_VAR 0 1
7812: PUSH
7813: LD_INT 1
7815: ARRAY
7816: PPUSH
7817: CALL_OW 255
7821: PPUSH
7822: CALL 6871 0 1
7826: PUSH
7827: LD_INT 20
7829: GREATEREQUAL
7830: PUSH
7831: LD_VAR 0 2
7835: PPUSH
7836: LD_VAR 0 3
7840: PPUSH
7841: CALL 6492 0 2
7845: AND
7846: IFFALSE 7931
// begin for i = 1 to plist do
7848: LD_ADDR_VAR 0 6
7852: PUSH
7853: DOUBLE
7854: LD_INT 1
7856: DEC
7857: ST_TO_ADDR
7858: LD_VAR 0 1
7862: PUSH
7863: FOR_TO
7864: IFFALSE 7919
// if not HasTask ( plist [ i ] ) then
7866: LD_VAR 0 1
7870: PUSH
7871: LD_VAR 0 6
7875: ARRAY
7876: PPUSH
7877: CALL_OW 314
7881: NOT
7882: IFFALSE 7917
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
7884: LD_VAR 0 1
7888: PUSH
7889: LD_VAR 0 6
7893: ARRAY
7894: PPUSH
7895: LD_INT 6
7897: PPUSH
7898: LD_VAR 0 2
7902: PPUSH
7903: LD_VAR 0 3
7907: PPUSH
7908: LD_VAR 0 4
7912: PPUSH
7913: CALL_OW 145
7917: GO 7863
7919: POP
7920: POP
// result := true ;
7921: LD_ADDR_VAR 0 5
7925: PUSH
7926: LD_INT 1
7928: ST_TO_ADDR
// end else
7929: GO 7939
// result := false ;
7931: LD_ADDR_VAR 0 5
7935: PUSH
7936: LD_INT 0
7938: ST_TO_ADDR
// end ;
7939: LD_VAR 0 5
7943: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; begin
7944: LD_INT 0
7946: PPUSH
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
7947: LD_VAR 0 1
7951: PPUSH
7952: LD_INT 1
7954: PPUSH
7955: CALL_OW 268
7959: PUSH
7960: LD_INT 9
7962: EQUAL
7963: PUSH
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 2
7971: PPUSH
7972: CALL_OW 268
7976: PUSH
7977: LD_INT 9
7979: EQUAL
7980: AND
7981: IFFALSE 8078
// begin if Cost ( lab , bkind1 ) and Cost ( lab , bkind2 ) and BuildingStatus ( lab ) = bs_idle then
7983: LD_VAR 0 1
7987: PPUSH
7988: LD_VAR 0 2
7992: PPUSH
7993: CALL 6262 0 2
7997: PUSH
7998: LD_VAR 0 1
8002: PPUSH
8003: LD_VAR 0 3
8007: PPUSH
8008: CALL 6262 0 2
8012: AND
8013: PUSH
8014: LD_VAR 0 1
8018: PPUSH
8019: CALL_OW 461
8023: PUSH
8024: LD_INT 2
8026: EQUAL
8027: AND
8028: IFFALSE 8068
// begin ComUpgradeLab ( lab , bkind1 ) ;
8030: LD_VAR 0 1
8034: PPUSH
8035: LD_VAR 0 2
8039: PPUSH
8040: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_VAR 0 3
8053: PPUSH
8054: CALL_OW 207
// result := true ;
8058: LD_ADDR_VAR 0 4
8062: PUSH
8063: LD_INT 1
8065: ST_TO_ADDR
// end else
8066: GO 8076
// result := false ;
8068: LD_ADDR_VAR 0 4
8072: PUSH
8073: LD_INT 0
8075: ST_TO_ADDR
// end else
8076: GO 8086
// result := false ;
8078: LD_ADDR_VAR 0 4
8082: PUSH
8083: LD_INT 0
8085: ST_TO_ADDR
// end ;
8086: LD_VAR 0 4
8090: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
8091: LD_INT 0
8093: PPUSH
8094: PPUSH
8095: PPUSH
8096: PPUSH
8097: PPUSH
// p := 1 ;
8098: LD_ADDR_VAR 0 6
8102: PUSH
8103: LD_INT 1
8105: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
8106: LD_ADDR_VAR 0 4
8110: PUSH
8111: DOUBLE
8112: LD_INT 1
8114: DEC
8115: ST_TO_ADDR
8116: LD_VAR 0 2
8120: PUSH
8121: LD_INT 4
8123: DIVREAL
8124: PUSH
8125: FOR_TO
8126: IFFALSE 8375
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
8128: LD_VAR 0 2
8132: PUSH
8133: LD_VAR 0 6
8137: PUSH
8138: LD_INT 1
8140: PLUS
8141: ARRAY
8142: PPUSH
8143: LD_VAR 0 2
8147: PUSH
8148: LD_VAR 0 6
8152: PUSH
8153: LD_INT 2
8155: PLUS
8156: ARRAY
8157: PPUSH
8158: CALL_OW 428
8162: PUSH
8163: LD_INT 0
8165: EQUAL
8166: PUSH
8167: LD_VAR 0 2
8171: PUSH
8172: LD_VAR 0 6
8176: PUSH
8177: LD_INT 1
8179: PLUS
8180: ARRAY
8181: PPUSH
8182: LD_VAR 0 2
8186: PUSH
8187: LD_VAR 0 6
8191: PUSH
8192: LD_INT 2
8194: PLUS
8195: ARRAY
8196: PPUSH
8197: CALL 6492 0 2
8201: AND
8202: PUSH
8203: LD_VAR 0 1
8207: PUSH
8208: LD_INT 1
8210: ARRAY
8211: PPUSH
8212: CALL_OW 255
8216: PPUSH
8217: CALL 6871 0 1
8221: PUSH
8222: LD_INT 20
8224: GREATEREQUAL
8225: AND
8226: IFFALSE 8343
// begin for c = 1 to plist do
8228: LD_ADDR_VAR 0 7
8232: PUSH
8233: DOUBLE
8234: LD_INT 1
8236: DEC
8237: ST_TO_ADDR
8238: LD_VAR 0 1
8242: PUSH
8243: FOR_TO
8244: IFFALSE 8337
// if not HasTask ( plist [ c ] ) then
8246: LD_VAR 0 1
8250: PUSH
8251: LD_VAR 0 7
8255: ARRAY
8256: PPUSH
8257: CALL_OW 314
8261: NOT
8262: IFFALSE 8335
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
8264: LD_VAR 0 1
8268: PUSH
8269: LD_VAR 0 7
8273: ARRAY
8274: PPUSH
8275: LD_VAR 0 2
8279: PUSH
8280: LD_VAR 0 6
8284: ARRAY
8285: PPUSH
8286: LD_VAR 0 2
8290: PUSH
8291: LD_VAR 0 6
8295: PUSH
8296: LD_INT 1
8298: PLUS
8299: ARRAY
8300: PPUSH
8301: LD_VAR 0 2
8305: PUSH
8306: LD_VAR 0 6
8310: PUSH
8311: LD_INT 2
8313: PLUS
8314: ARRAY
8315: PPUSH
8316: LD_VAR 0 2
8320: PUSH
8321: LD_VAR 0 6
8325: PUSH
8326: LD_INT 3
8328: PLUS
8329: ARRAY
8330: PPUSH
8331: CALL_OW 145
8335: GO 8243
8337: POP
8338: POP
// break ;
8339: GO 8375
// end else
8341: GO 8373
// if ( p + 4 < tlist ) then
8343: LD_VAR 0 6
8347: PUSH
8348: LD_INT 4
8350: PLUS
8351: PUSH
8352: LD_VAR 0 2
8356: LESS
8357: IFFALSE 8373
// p := p + 4 ;
8359: LD_ADDR_VAR 0 6
8363: PUSH
8364: LD_VAR 0 6
8368: PUSH
8369: LD_INT 4
8371: PLUS
8372: ST_TO_ADDR
// end ;
8373: GO 8125
8375: POP
8376: POP
// end ;
8377: LD_VAR 0 3
8381: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
8382: LD_INT 0
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
// tmp := GetTowers ( side ) ;
8388: LD_ADDR_VAR 0 5
8392: PUSH
8393: LD_VAR 0 1
8397: PPUSH
8398: CALL 7483 0 1
8402: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
8403: LD_ADDR_VAR 0 6
8407: PUSH
8408: LD_VAR 0 1
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: CALL 6777 0 2
8420: PUSH
8421: LD_INT 1
8423: ARRAY
8424: ST_TO_ADDR
// if fac then
8425: LD_VAR 0 6
8429: IFFALSE 8525
// for i = 1 to tmp do
8431: LD_ADDR_VAR 0 4
8435: PUSH
8436: DOUBLE
8437: LD_INT 1
8439: DEC
8440: ST_TO_ADDR
8441: LD_VAR 0 5
8445: PUSH
8446: FOR_TO
8447: IFFALSE 8523
// if GetBWeapon ( tmp [ i ] ) = 0 then
8449: LD_VAR 0 5
8453: PUSH
8454: LD_VAR 0 4
8458: ARRAY
8459: PPUSH
8460: CALL_OW 269
8464: PUSH
8465: LD_INT 0
8467: EQUAL
8468: IFFALSE 8521
// begin if BuildingStatus ( fac ) = bs_idle then
8470: LD_VAR 0 6
8474: PPUSH
8475: CALL_OW 461
8479: PUSH
8480: LD_INT 2
8482: EQUAL
8483: IFFALSE 8519
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
8485: LD_VAR 0 5
8489: PUSH
8490: LD_VAR 0 4
8494: ARRAY
8495: PPUSH
8496: LD_VAR 0 2
8500: PUSH
8501: LD_INT 1
8503: PPUSH
8504: LD_VAR 0 2
8508: PPUSH
8509: CALL_OW 12
8513: ARRAY
8514: PPUSH
8515: CALL_OW 148
// break ;
8519: GO 8523
// end ;
8521: GO 8446
8523: POP
8524: POP
// end ;
8525: LD_VAR 0 3
8529: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
8530: LD_INT 0
8532: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
8533: LD_INT 22
8535: PUSH
8536: LD_VAR 0 1
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: PUSH
8545: LD_INT 34
8547: PUSH
8548: LD_VAR 0 3
8552: PUSH
8553: EMPTY
8554: LIST
8555: LIST
8556: PUSH
8557: LD_INT 31
8559: PUSH
8560: LD_VAR 0 2
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: LIST
8573: PUSH
8574: EMPTY
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: IFFALSE 8639
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
8583: LD_ADDR_VAR 0 4
8587: PUSH
8588: LD_INT 22
8590: PUSH
8591: LD_VAR 0 1
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 34
8602: PUSH
8603: LD_VAR 0 3
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: PUSH
8612: LD_INT 31
8614: PUSH
8615: LD_VAR 0 2
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: LIST
8628: PUSH
8629: EMPTY
8630: LIST
8631: PPUSH
8632: CALL_OW 69
8636: ST_TO_ADDR
8637: GO 8647
// result := false ;
8639: LD_ADDR_VAR 0 4
8643: PUSH
8644: LD_INT 0
8646: ST_TO_ADDR
// end ;
8647: LD_VAR 0 4
8651: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
8652: LD_INT 0
8654: PPUSH
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_VAR 0 2
8664: PPUSH
8665: LD_VAR 0 3
8669: PPUSH
8670: LD_VAR 0 4
8674: PPUSH
8675: LD_VAR 0 5
8679: PPUSH
8680: CALL_OW 448
8684: PUSH
8685: LD_VAR 0 2
8689: PPUSH
8690: LD_VAR 0 3
8694: PPUSH
8695: LD_VAR 0 4
8699: PPUSH
8700: LD_VAR 0 5
8704: PPUSH
8705: CALL_OW 449
8709: PUSH
8710: LD_INT 1
8712: ARRAY
8713: PUSH
8714: LD_VAR 0 1
8718: PPUSH
8719: CALL 6378 0 1
8723: PUSH
8724: LD_INT 1
8726: ARRAY
8727: LESSEQUAL
8728: AND
8729: PUSH
8730: LD_VAR 0 2
8734: PPUSH
8735: LD_VAR 0 3
8739: PPUSH
8740: LD_VAR 0 4
8744: PPUSH
8745: LD_VAR 0 5
8749: PPUSH
8750: CALL_OW 449
8754: PUSH
8755: LD_INT 2
8757: ARRAY
8758: PUSH
8759: LD_VAR 0 1
8763: PPUSH
8764: CALL 6378 0 1
8768: PUSH
8769: LD_INT 2
8771: ARRAY
8772: LESSEQUAL
8773: AND
8774: PUSH
8775: LD_VAR 0 2
8779: PPUSH
8780: LD_VAR 0 3
8784: PPUSH
8785: LD_VAR 0 4
8789: PPUSH
8790: LD_VAR 0 5
8794: PPUSH
8795: CALL_OW 449
8799: PUSH
8800: LD_INT 3
8802: ARRAY
8803: PUSH
8804: LD_VAR 0 1
8808: PPUSH
8809: CALL 6378 0 1
8813: PUSH
8814: LD_INT 3
8816: ARRAY
8817: LESSEQUAL
8818: AND
8819: IFFALSE 8866
// begin if debug then
8821: LD_EXP 1
8825: IFFALSE 8835
// display_strings := Factory work! ;
8827: LD_ADDR_OWVAR 47
8831: PUSH
8832: LD_STRING Factory work!
8834: ST_TO_ADDR
// ComConstruct ( factory , chassis , engine , control , weapon ) ;
8835: LD_VAR 0 1
8839: PPUSH
8840: LD_VAR 0 2
8844: PPUSH
8845: LD_VAR 0 3
8849: PPUSH
8850: LD_VAR 0 4
8854: PPUSH
8855: LD_VAR 0 5
8859: PPUSH
8860: CALL_OW 125
// end else
8864: GO 8874
// result := false ;
8866: LD_ADDR_VAR 0 6
8870: PUSH
8871: LD_INT 0
8873: ST_TO_ADDR
// end ;
8874: LD_VAR 0 6
8878: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
8879: LD_INT 0
8881: PPUSH
8882: PPUSH
8883: PPUSH
8884: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
8885: LD_ADDR_VAR 0 6
8889: PUSH
8890: LD_INT 22
8892: PUSH
8893: LD_VAR 0 1
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: PUSH
8902: LD_INT 30
8904: PUSH
8905: LD_VAR 0 2
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PPUSH
8918: CALL_OW 69
8922: ST_TO_ADDR
// tmp := [ ] ;
8923: LD_ADDR_VAR 0 5
8927: PUSH
8928: EMPTY
8929: ST_TO_ADDR
// for i = 1 to filter do
8930: LD_ADDR_VAR 0 4
8934: PUSH
8935: DOUBLE
8936: LD_INT 1
8938: DEC
8939: ST_TO_ADDR
8940: LD_VAR 0 6
8944: PUSH
8945: FOR_TO
8946: IFFALSE 9034
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
8948: LD_ADDR_VAR 0 5
8952: PUSH
8953: LD_VAR 0 5
8957: PUSH
8958: LD_VAR 0 6
8962: PUSH
8963: LD_VAR 0 4
8967: ARRAY
8968: PPUSH
8969: CALL_OW 266
8973: PUSH
8974: LD_VAR 0 6
8978: PUSH
8979: LD_VAR 0 4
8983: ARRAY
8984: PPUSH
8985: CALL_OW 250
8989: PUSH
8990: LD_VAR 0 6
8994: PUSH
8995: LD_VAR 0 4
8999: ARRAY
9000: PPUSH
9001: CALL_OW 251
9005: PUSH
9006: LD_VAR 0 6
9010: PUSH
9011: LD_VAR 0 4
9015: ARRAY
9016: PPUSH
9017: CALL_OW 254
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: LIST
9027: PUSH
9028: EMPTY
9029: LIST
9030: ADD
9031: ST_TO_ADDR
// end ;
9032: GO 8945
9034: POP
9035: POP
// result := tmp ;
9036: LD_ADDR_VAR 0 3
9040: PUSH
9041: LD_VAR 0 5
9045: ST_TO_ADDR
// end ;
9046: LD_VAR 0 3
9050: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
9051: LD_INT 0
9053: PPUSH
9054: PPUSH
9055: PPUSH
// for i = 1 to list do
9056: LD_ADDR_VAR 0 4
9060: PUSH
9061: DOUBLE
9062: LD_INT 1
9064: DEC
9065: ST_TO_ADDR
9066: LD_VAR 0 2
9070: PUSH
9071: FOR_TO
9072: IFFALSE 9627
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
9074: LD_VAR 0 2
9078: PUSH
9079: LD_VAR 0 4
9083: ARRAY
9084: PUSH
9085: LD_INT 1
9087: ARRAY
9088: PPUSH
9089: LD_VAR 0 2
9093: PUSH
9094: LD_VAR 0 4
9098: ARRAY
9099: PUSH
9100: LD_INT 2
9102: ARRAY
9103: PPUSH
9104: CALL_OW 428
9108: PUSH
9109: LD_INT 0
9111: GREATER
9112: IFFALSE 9398
// begin if GetNation ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) = nation_russian then
9114: LD_VAR 0 2
9118: PUSH
9119: LD_VAR 0 4
9123: ARRAY
9124: PUSH
9125: LD_INT 1
9127: ARRAY
9128: PPUSH
9129: LD_VAR 0 2
9133: PUSH
9134: LD_VAR 0 4
9138: ARRAY
9139: PUSH
9140: LD_INT 2
9142: ARRAY
9143: PPUSH
9144: CALL_OW 428
9148: PPUSH
9149: CALL_OW 248
9153: PUSH
9154: LD_INT 3
9156: EQUAL
9157: IFFALSE 9283
// begin if GetResourceType ( GetBase ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) , 3 ) >= 15 then
9159: LD_VAR 0 2
9163: PUSH
9164: LD_VAR 0 4
9168: ARRAY
9169: PUSH
9170: LD_INT 1
9172: ARRAY
9173: PPUSH
9174: LD_VAR 0 2
9178: PUSH
9179: LD_VAR 0 4
9183: ARRAY
9184: PUSH
9185: LD_INT 2
9187: ARRAY
9188: PPUSH
9189: CALL_OW 428
9193: PPUSH
9194: CALL_OW 274
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: CALL_OW 275
9206: PUSH
9207: LD_INT 15
9209: GREATEREQUAL
9210: IFFALSE 9281
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9212: LD_VAR 0 2
9216: PUSH
9217: LD_VAR 0 4
9221: ARRAY
9222: PUSH
9223: LD_INT 1
9225: ARRAY
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 4
9236: ARRAY
9237: PUSH
9238: LD_INT 2
9240: ARRAY
9241: PPUSH
9242: CALL_OW 428
9246: PPUSH
9247: LD_VAR 0 2
9251: PUSH
9252: LD_VAR 0 4
9256: ARRAY
9257: PUSH
9258: LD_INT 4
9260: ARRAY
9261: PPUSH
9262: LD_VAR 0 2
9266: PUSH
9267: LD_VAR 0 4
9271: ARRAY
9272: PUSH
9273: LD_INT 5
9275: ARRAY
9276: PPUSH
9277: CALL 7944 0 3
// end else
9281: GO 9352
// ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
9283: LD_VAR 0 2
9287: PUSH
9288: LD_VAR 0 4
9292: ARRAY
9293: PUSH
9294: LD_INT 1
9296: ARRAY
9297: PPUSH
9298: LD_VAR 0 2
9302: PUSH
9303: LD_VAR 0 4
9307: ARRAY
9308: PUSH
9309: LD_INT 2
9311: ARRAY
9312: PPUSH
9313: CALL_OW 428
9317: PPUSH
9318: LD_VAR 0 2
9322: PUSH
9323: LD_VAR 0 4
9327: ARRAY
9328: PUSH
9329: LD_INT 4
9331: ARRAY
9332: PPUSH
9333: LD_VAR 0 2
9337: PUSH
9338: LD_VAR 0 4
9342: ARRAY
9343: PUSH
9344: LD_INT 5
9346: ARRAY
9347: PPUSH
9348: CALL 7944 0 3
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
9352: LD_VAR 0 1
9356: PPUSH
9357: LD_VAR 0 2
9361: PUSH
9362: LD_VAR 0 4
9366: ARRAY
9367: PUSH
9368: LD_INT 1
9370: ARRAY
9371: PPUSH
9372: LD_VAR 0 2
9376: PUSH
9377: LD_VAR 0 4
9381: ARRAY
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: CALL_OW 428
9391: PPUSH
9392: CALL 11000 0 2
// end else
9396: GO 9625
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
9398: LD_VAR 0 1
9402: PUSH
9403: LD_INT 1
9405: ARRAY
9406: PPUSH
9407: CALL_OW 255
9411: PPUSH
9412: CALL 6686 0 1
9416: PPUSH
9417: LD_INT 6
9419: PPUSH
9420: CALL 6262 0 2
9424: PUSH
9425: LD_VAR 0 1
9429: PUSH
9430: LD_INT 1
9432: ARRAY
9433: PPUSH
9434: CALL_OW 255
9438: PPUSH
9439: CALL 6686 0 1
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_VAR 0 4
9453: ARRAY
9454: PUSH
9455: LD_INT 4
9457: ARRAY
9458: PPUSH
9459: CALL 6262 0 2
9463: AND
9464: PUSH
9465: LD_VAR 0 1
9469: PUSH
9470: LD_INT 1
9472: ARRAY
9473: PPUSH
9474: CALL_OW 255
9478: PPUSH
9479: CALL 6686 0 1
9483: PPUSH
9484: LD_VAR 0 2
9488: PUSH
9489: LD_VAR 0 4
9493: ARRAY
9494: PUSH
9495: LD_INT 5
9497: ARRAY
9498: PPUSH
9499: CALL 6262 0 2
9503: AND
9504: IFFALSE 9625
// for p = 1 to plist do
9506: LD_ADDR_VAR 0 5
9510: PUSH
9511: DOUBLE
9512: LD_INT 1
9514: DEC
9515: ST_TO_ADDR
9516: LD_VAR 0 1
9520: PUSH
9521: FOR_TO
9522: IFFALSE 9623
// if IsInUnit ( plist [ p ] ) then
9524: LD_VAR 0 1
9528: PUSH
9529: LD_VAR 0 5
9533: ARRAY
9534: PPUSH
9535: CALL_OW 310
9539: IFFALSE 9558
// ComExitBuilding ( plist [ p ] ) else
9541: LD_VAR 0 1
9545: PUSH
9546: LD_VAR 0 5
9550: ARRAY
9551: PPUSH
9552: CALL_OW 122
9556: GO 9621
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
9558: LD_VAR 0 1
9562: PUSH
9563: LD_VAR 0 5
9567: ARRAY
9568: PPUSH
9569: LD_INT 6
9571: PPUSH
9572: LD_VAR 0 2
9576: PUSH
9577: LD_VAR 0 4
9581: ARRAY
9582: PUSH
9583: LD_INT 1
9585: ARRAY
9586: PPUSH
9587: LD_VAR 0 2
9591: PUSH
9592: LD_VAR 0 4
9596: ARRAY
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_VAR 0 2
9606: PUSH
9607: LD_VAR 0 4
9611: ARRAY
9612: PUSH
9613: LD_INT 3
9615: ARRAY
9616: PPUSH
9617: CALL_OW 145
9621: GO 9521
9623: POP
9624: POP
// end ;
9625: GO 9071
9627: POP
9628: POP
// end ;
9629: LD_VAR 0 3
9633: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
9634: LD_INT 0
9636: PPUSH
// if IsInUnit ( sci ) then
9637: LD_VAR 0 1
9641: PPUSH
9642: CALL_OW 310
9646: IFFALSE 9659
// ComExitBuilding ( sci ) else
9648: LD_VAR 0 1
9652: PPUSH
9653: CALL_OW 122
9657: GO 9690
// if not HasTask ( sci ) then
9659: LD_VAR 0 1
9663: PPUSH
9664: CALL_OW 314
9668: NOT
9669: IFFALSE 9690
// begin ComMoveXY ( sci , x , y ) ;
9671: LD_VAR 0 1
9675: PPUSH
9676: LD_VAR 0 2
9680: PPUSH
9681: LD_VAR 0 3
9685: PPUSH
9686: CALL_OW 111
// end ; end ;
9690: LD_VAR 0 4
9694: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
9695: LD_INT 0
9697: PPUSH
9698: PPUSH
9699: PPUSH
9700: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
9701: LD_ADDR_VAR 0 6
9705: PUSH
9706: LD_INT 22
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PUSH
9718: LD_INT 21
9720: PUSH
9721: LD_INT 1
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: PPUSH
9732: CALL_OW 69
9736: PUSH
9737: LD_VAR 0 3
9741: DIFF
9742: ST_TO_ADDR
// tmp := tag_list ;
9743: LD_ADDR_VAR 0 7
9747: PUSH
9748: LD_VAR 0 2
9752: ST_TO_ADDR
// for i = 1 to filter do
9753: LD_ADDR_VAR 0 5
9757: PUSH
9758: DOUBLE
9759: LD_INT 1
9761: DEC
9762: ST_TO_ADDR
9763: LD_VAR 0 6
9767: PUSH
9768: FOR_TO
9769: IFFALSE 10038
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
9771: LD_VAR 0 6
9775: PUSH
9776: LD_VAR 0 5
9780: ARRAY
9781: PPUSH
9782: CALL_OW 256
9786: PUSH
9787: LD_INT 1000
9789: EQUAL
9790: PUSH
9791: LD_VAR 0 6
9795: PUSH
9796: LD_VAR 0 5
9800: ARRAY
9801: PPUSH
9802: CALL_OW 110
9806: PUSH
9807: LD_INT 100
9809: GREATEREQUAL
9810: AND
9811: IFFALSE 9853
// begin SetTag ( filter [ i ] , 0 ) ;
9813: LD_VAR 0 6
9817: PUSH
9818: LD_VAR 0 5
9822: ARRAY
9823: PPUSH
9824: LD_INT 0
9826: PPUSH
9827: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
9831: LD_ADDR_VAR 0 7
9835: PUSH
9836: LD_VAR 0 7
9840: PUSH
9841: LD_VAR 0 6
9845: PUSH
9846: LD_VAR 0 5
9850: ARRAY
9851: DIFF
9852: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
9853: LD_VAR 0 6
9857: PUSH
9858: LD_VAR 0 5
9862: ARRAY
9863: PPUSH
9864: CALL_OW 256
9868: PUSH
9869: LD_INT 1000
9871: LESS
9872: IFFALSE 10036
// begin if not filter [ i ] in tmp then
9874: LD_VAR 0 6
9878: PUSH
9879: LD_VAR 0 5
9883: ARRAY
9884: PUSH
9885: LD_VAR 0 7
9889: IN
9890: NOT
9891: IFFALSE 9915
// tmp := tmp ^ filter [ i ] ;
9893: LD_ADDR_VAR 0 7
9897: PUSH
9898: LD_VAR 0 7
9902: PUSH
9903: LD_VAR 0 6
9907: PUSH
9908: LD_VAR 0 5
9912: ARRAY
9913: ADD
9914: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
9915: LD_VAR 0 6
9919: PUSH
9920: LD_VAR 0 5
9924: ARRAY
9925: PPUSH
9926: CALL_OW 256
9930: PUSH
9931: LD_INT 250
9933: LESS
9934: IFFALSE 9956
// SetTag ( filter [ i ] , 100 ) else
9936: LD_VAR 0 6
9940: PUSH
9941: LD_VAR 0 5
9945: ARRAY
9946: PPUSH
9947: LD_INT 100
9949: PPUSH
9950: CALL_OW 109
9954: GO 10036
// if GetLives ( filter [ i ] ) < 500 then
9956: LD_VAR 0 6
9960: PUSH
9961: LD_VAR 0 5
9965: ARRAY
9966: PPUSH
9967: CALL_OW 256
9971: PUSH
9972: LD_INT 500
9974: LESS
9975: IFFALSE 9997
// SetTag ( filter [ i ] , 101 ) else
9977: LD_VAR 0 6
9981: PUSH
9982: LD_VAR 0 5
9986: ARRAY
9987: PPUSH
9988: LD_INT 101
9990: PPUSH
9991: CALL_OW 109
9995: GO 10036
// if GetLives ( filter [ i ] ) < 1000 then
9997: LD_VAR 0 6
10001: PUSH
10002: LD_VAR 0 5
10006: ARRAY
10007: PPUSH
10008: CALL_OW 256
10012: PUSH
10013: LD_INT 1000
10015: LESS
10016: IFFALSE 10036
// SetTag ( filter [ i ] , 102 ) ;
10018: LD_VAR 0 6
10022: PUSH
10023: LD_VAR 0 5
10027: ARRAY
10028: PPUSH
10029: LD_INT 102
10031: PPUSH
10032: CALL_OW 109
// end ; end ;
10036: GO 9768
10038: POP
10039: POP
// result := tmp ;
10040: LD_ADDR_VAR 0 4
10044: PUSH
10045: LD_VAR 0 7
10049: ST_TO_ADDR
// end ;
10050: LD_VAR 0 4
10054: RET
// export function WantHeal ( sci , tag ) ; begin
10055: LD_INT 0
10057: PPUSH
// if GetTaskList ( sci ) > 0 then
10058: LD_VAR 0 1
10062: PPUSH
10063: CALL_OW 437
10067: PUSH
10068: LD_INT 0
10070: GREATER
10071: IFFALSE 10146
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
10073: LD_VAR 0 1
10077: PPUSH
10078: CALL_OW 437
10082: PUSH
10083: LD_INT 1
10085: ARRAY
10086: PUSH
10087: LD_INT 1
10089: ARRAY
10090: PUSH
10091: LD_STRING l
10093: EQUAL
10094: PUSH
10095: LD_VAR 0 1
10099: PPUSH
10100: CALL_OW 437
10104: PUSH
10105: LD_INT 1
10107: ARRAY
10108: PUSH
10109: LD_INT 4
10111: ARRAY
10112: PPUSH
10113: CALL_OW 110
10117: PUSH
10118: LD_VAR 0 2
10122: EQUAL
10123: AND
10124: IFFALSE 10136
// result := true else
10126: LD_ADDR_VAR 0 3
10130: PUSH
10131: LD_INT 1
10133: ST_TO_ADDR
10134: GO 10144
// result := false ;
10136: LD_ADDR_VAR 0 3
10140: PUSH
10141: LD_INT 0
10143: ST_TO_ADDR
// end else
10144: GO 10154
// result := false ;
10146: LD_ADDR_VAR 0 3
10150: PUSH
10151: LD_INT 0
10153: ST_TO_ADDR
// end ;
10154: LD_VAR 0 3
10158: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
10159: LD_INT 0
10161: PPUSH
10162: PPUSH
10163: PPUSH
10164: PPUSH
10165: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10166: LD_ADDR_VAR 0 7
10170: PUSH
10171: LD_INT 22
10173: PUSH
10174: LD_VAR 0 2
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: LD_INT 3
10185: PUSH
10186: LD_INT 21
10188: PUSH
10189: LD_INT 3
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: EMPTY
10201: LIST
10202: LIST
10203: PPUSH
10204: CALL_OW 69
10208: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
10209: LD_ADDR_VAR 0 5
10213: PUSH
10214: LD_INT 1
10216: PPUSH
10217: LD_INT 3
10219: PPUSH
10220: CALL_OW 12
10224: ST_TO_ADDR
// if filter > 0 then
10225: LD_VAR 0 7
10229: PUSH
10230: LD_INT 0
10232: GREATER
10233: IFFALSE 10435
// for i = 1 to list do
10235: LD_ADDR_VAR 0 6
10239: PUSH
10240: DOUBLE
10241: LD_INT 1
10243: DEC
10244: ST_TO_ADDR
10245: LD_VAR 0 1
10249: PUSH
10250: FOR_TO
10251: IFFALSE 10433
// for ta in filter do
10253: LD_ADDR_VAR 0 4
10257: PUSH
10258: LD_VAR 0 7
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10429
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
10266: LD_VAR 0 1
10270: PUSH
10271: LD_VAR 0 6
10275: ARRAY
10276: PPUSH
10277: LD_VAR 0 4
10281: PPUSH
10282: CALL_OW 296
10286: PUSH
10287: LD_INT 13
10289: LESSEQUAL
10290: IFFALSE 10427
// begin case c of 1 :
10292: LD_VAR 0 5
10296: PUSH
10297: LD_INT 1
10299: DOUBLE
10300: EQUAL
10301: IFTRUE 10305
10303: GO 10343
10305: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
10306: LD_VAR 0 1
10310: PUSH
10311: LD_VAR 0 6
10315: ARRAY
10316: PPUSH
10317: LD_VAR 0 4
10321: PPUSH
10322: CALL_OW 250
10326: PPUSH
10327: LD_VAR 0 4
10331: PPUSH
10332: CALL_OW 251
10336: PPUSH
10337: CALL_OW 154
10341: GO 10427
10343: LD_INT 2
10345: DOUBLE
10346: EQUAL
10347: IFTRUE 10351
10349: GO 10415
10351: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
10352: LD_VAR 0 1
10356: PUSH
10357: LD_VAR 0 6
10361: ARRAY
10362: PPUSH
10363: LD_VAR 0 4
10367: PPUSH
10368: CALL_OW 250
10372: PUSH
10373: LD_INT 1
10375: NEG
10376: PPUSH
10377: LD_INT 1
10379: PPUSH
10380: CALL_OW 12
10384: PLUS
10385: PPUSH
10386: LD_VAR 0 4
10390: PPUSH
10391: CALL_OW 251
10395: PUSH
10396: LD_INT 1
10398: NEG
10399: PPUSH
10400: LD_INT 1
10402: PPUSH
10403: CALL_OW 12
10407: PLUS
10408: PPUSH
10409: CALL_OW 153
10413: GO 10427
10415: LD_INT 3
10417: DOUBLE
10418: EQUAL
10419: IFTRUE 10423
10421: GO 10426
10423: POP
// ; end ;
10424: GO 10427
10426: POP
// end ; end ;
10427: GO 10263
10429: POP
10430: POP
10431: GO 10250
10433: POP
10434: POP
// end ;
10435: LD_VAR 0 3
10439: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
10440: LD_INT 0
10442: PPUSH
10443: PPUSH
// for i = 1 to plist do
10444: LD_ADDR_VAR 0 3
10448: PUSH
10449: DOUBLE
10450: LD_INT 1
10452: DEC
10453: ST_TO_ADDR
10454: LD_VAR 0 1
10458: PUSH
10459: FOR_TO
10460: IFFALSE 10662
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
10462: LD_VAR 0 1
10466: PUSH
10467: LD_VAR 0 3
10471: ARRAY
10472: PPUSH
10473: CALL_OW 310
10477: PUSH
10478: LD_INT 30
10480: PUSH
10481: LD_INT 5
10483: PUSH
10484: EMPTY
10485: LIST
10486: LIST
10487: PUSH
10488: EMPTY
10489: LIST
10490: PPUSH
10491: CALL_OW 69
10495: IN
10496: NOT
10497: IFFALSE 10642
// begin if IsInUnit ( plist [ i ] ) then
10499: LD_VAR 0 1
10503: PUSH
10504: LD_VAR 0 3
10508: ARRAY
10509: PPUSH
10510: CALL_OW 310
10514: IFFALSE 10533
// ComExitBuilding ( plist [ i ] ) else
10516: LD_VAR 0 1
10520: PUSH
10521: LD_VAR 0 3
10525: ARRAY
10526: PPUSH
10527: CALL_OW 122
10531: GO 10640
// if not HasTask ( plist [ i ] ) then
10533: LD_VAR 0 1
10537: PUSH
10538: LD_VAR 0 3
10542: ARRAY
10543: PPUSH
10544: CALL_OW 314
10548: NOT
10549: IFFALSE 10640
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
10551: LD_VAR 0 1
10555: PUSH
10556: LD_VAR 0 3
10560: ARRAY
10561: PPUSH
10562: LD_INT 22
10564: PUSH
10565: LD_VAR 0 1
10569: PUSH
10570: LD_INT 1
10572: ARRAY
10573: PPUSH
10574: CALL_OW 255
10578: PUSH
10579: EMPTY
10580: LIST
10581: LIST
10582: PUSH
10583: LD_INT 30
10585: PUSH
10586: LD_INT 5
10588: PUSH
10589: EMPTY
10590: LIST
10591: LIST
10592: PUSH
10593: EMPTY
10594: LIST
10595: LIST
10596: PPUSH
10597: CALL_OW 69
10601: PPUSH
10602: LD_VAR 0 1
10606: PUSH
10607: LD_VAR 0 3
10611: ARRAY
10612: PPUSH
10613: CALL_OW 74
10617: PPUSH
10618: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
10622: LD_VAR 0 1
10626: PUSH
10627: LD_VAR 0 3
10631: ARRAY
10632: PPUSH
10633: LD_INT 9
10635: PPUSH
10636: CALL_OW 183
// end ; end else
10640: GO 10660
// ComChangeProfession ( plist [ i ] , 9 ) ;
10642: LD_VAR 0 1
10646: PUSH
10647: LD_VAR 0 3
10651: ARRAY
10652: PPUSH
10653: LD_INT 9
10655: PPUSH
10656: CALL_OW 123
10660: GO 10459
10662: POP
10663: POP
// end ;
10664: LD_VAR 0 2
10668: RET
// export function GetHuman ( side ) ; begin
10669: LD_INT 0
10671: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10672: LD_ADDR_VAR 0 2
10676: PUSH
10677: LD_INT 22
10679: PUSH
10680: LD_VAR 0 1
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: PUSH
10689: LD_INT 21
10691: PUSH
10692: LD_INT 1
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: PUSH
10699: LD_INT 2
10701: PUSH
10702: LD_INT 25
10704: PUSH
10705: LD_INT 1
10707: PUSH
10708: EMPTY
10709: LIST
10710: LIST
10711: PUSH
10712: LD_INT 25
10714: PUSH
10715: LD_INT 2
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: LD_INT 25
10724: PUSH
10725: LD_INT 3
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 25
10734: PUSH
10735: LD_INT 4
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: LIST
10753: PPUSH
10754: CALL_OW 69
10758: ST_TO_ADDR
// end ;
10759: LD_VAR 0 2
10763: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
10764: LD_INT 0
10766: PPUSH
10767: PPUSH
10768: PPUSH
// uc_side := 0 ;
10769: LD_ADDR_OWVAR 20
10773: PUSH
10774: LD_INT 0
10776: ST_TO_ADDR
// uc_nation := 0 ;
10777: LD_ADDR_OWVAR 21
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
10785: LD_ADDR_VAR 0 4
10789: PUSH
10790: DOUBLE
10791: LD_INT 1
10793: DEC
10794: ST_TO_ADDR
10795: LD_INT 4
10797: PUSH
10798: LD_INT 5
10800: PUSH
10801: LD_INT 6
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: PUSH
10809: LD_OWVAR 67
10813: ARRAY
10814: PUSH
10815: FOR_TO
10816: IFFALSE 10887
// begin hc_class = class_tiger ;
10818: LD_ADDR_OWVAR 28
10822: PUSH
10823: LD_INT 14
10825: ST_TO_ADDR
// hc_gallery = sandnature ;
10826: LD_ADDR_OWVAR 33
10830: PUSH
10831: LD_STRING sandnature
10833: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
10834: LD_ADDR_OWVAR 35
10838: PUSH
10839: LD_INT 0
10841: PPUSH
10842: LD_INT 50
10844: PPUSH
10845: CALL_OW 12
10849: ST_TO_ADDR
// hc_face_number = 3 ;
10850: LD_ADDR_OWVAR 34
10854: PUSH
10855: LD_INT 3
10857: ST_TO_ADDR
// tiger := CreateHuman ;
10858: LD_ADDR_VAR 0 3
10862: PUSH
10863: CALL_OW 44
10867: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10868: LD_VAR 0 3
10872: PPUSH
10873: LD_VAR 0 1
10877: PPUSH
10878: LD_INT 0
10880: PPUSH
10881: CALL_OW 49
// end ;
10885: GO 10815
10887: POP
10888: POP
// end ;
10889: LD_VAR 0 2
10893: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
10894: LD_INT 0
10896: PPUSH
10897: PPUSH
10898: PPUSH
// uc_side := 0 ;
10899: LD_ADDR_OWVAR 20
10903: PUSH
10904: LD_INT 0
10906: ST_TO_ADDR
// uc_nation := 0 ;
10907: LD_ADDR_OWVAR 21
10911: PUSH
10912: LD_INT 0
10914: ST_TO_ADDR
// for i = 1 to 8 do
10915: LD_ADDR_VAR 0 4
10919: PUSH
10920: DOUBLE
10921: LD_INT 1
10923: DEC
10924: ST_TO_ADDR
10925: LD_INT 8
10927: PUSH
10928: FOR_TO
10929: IFFALSE 10993
// begin hc_class = class_apeman ;
10931: LD_ADDR_OWVAR 28
10935: PUSH
10936: LD_INT 12
10938: ST_TO_ADDR
// hc_gallery =  ;
10939: LD_ADDR_OWVAR 33
10943: PUSH
10944: LD_STRING 
10946: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
10947: LD_ADDR_OWVAR 35
10951: PUSH
10952: LD_INT 5
10954: NEG
10955: PPUSH
10956: LD_INT 20
10958: PPUSH
10959: CALL_OW 12
10963: ST_TO_ADDR
// ape := CreateHuman ;
10964: LD_ADDR_VAR 0 3
10968: PUSH
10969: CALL_OW 44
10973: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
10974: LD_VAR 0 3
10978: PPUSH
10979: LD_VAR 0 1
10983: PPUSH
10984: LD_INT 0
10986: PPUSH
10987: CALL_OW 49
// end ;
10991: GO 10928
10993: POP
10994: POP
// end ;
10995: LD_VAR 0 2
10999: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
11000: LD_INT 0
11002: PPUSH
11003: PPUSH
// if BuildingStatus ( b ) = bs_build then
11004: LD_VAR 0 2
11008: PPUSH
11009: CALL_OW 461
11013: PUSH
11014: LD_INT 1
11016: EQUAL
11017: IFFALSE 11203
// for i = 1 to plist do
11019: LD_ADDR_VAR 0 4
11023: PUSH
11024: DOUBLE
11025: LD_INT 1
11027: DEC
11028: ST_TO_ADDR
11029: LD_VAR 0 1
11033: PUSH
11034: FOR_TO
11035: IFFALSE 11201
// if IsInUnit ( plist [ i ] ) then
11037: LD_VAR 0 1
11041: PUSH
11042: LD_VAR 0 4
11046: ARRAY
11047: PPUSH
11048: CALL_OW 310
11052: IFFALSE 11135
// begin ComExitBuilding ( plist [ i ] ) ;
11054: LD_VAR 0 1
11058: PUSH
11059: LD_VAR 0 4
11063: ARRAY
11064: PPUSH
11065: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11069: LD_VAR 0 1
11073: PUSH
11074: LD_VAR 0 4
11078: ARRAY
11079: PPUSH
11080: LD_STRING h
11082: PUSH
11083: LD_VAR 0 2
11087: PPUSH
11088: CALL_OW 250
11092: PUSH
11093: LD_VAR 0 2
11097: PPUSH
11098: CALL_OW 251
11102: PUSH
11103: LD_VAR 0 2
11107: PUSH
11108: LD_INT 0
11110: PUSH
11111: LD_INT 0
11113: PUSH
11114: LD_INT 0
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: LIST
11121: LIST
11122: LIST
11123: LIST
11124: LIST
11125: PUSH
11126: EMPTY
11127: LIST
11128: PPUSH
11129: CALL_OW 447
// end else
11133: GO 11199
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
11135: LD_VAR 0 1
11139: PUSH
11140: LD_VAR 0 4
11144: ARRAY
11145: PPUSH
11146: LD_STRING h
11148: PUSH
11149: LD_VAR 0 2
11153: PPUSH
11154: CALL_OW 250
11158: PUSH
11159: LD_VAR 0 2
11163: PPUSH
11164: CALL_OW 251
11168: PUSH
11169: LD_VAR 0 2
11173: PUSH
11174: LD_INT 0
11176: PUSH
11177: LD_INT 0
11179: PUSH
11180: LD_INT 0
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: LIST
11191: PUSH
11192: EMPTY
11193: LIST
11194: PPUSH
11195: CALL_OW 446
11199: GO 11034
11201: POP
11202: POP
// end ;
11203: LD_VAR 0 3
11207: RET
// export function WantRepair ( eng ) ; begin
11208: LD_INT 0
11210: PPUSH
// if GetTaskList ( eng ) > 0 then
11211: LD_VAR 0 1
11215: PPUSH
11216: CALL_OW 437
11220: PUSH
11221: LD_INT 0
11223: GREATER
11224: IFFALSE 11269
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o then
11226: LD_VAR 0 1
11230: PPUSH
11231: CALL_OW 437
11235: PUSH
11236: LD_INT 1
11238: ARRAY
11239: PUSH
11240: LD_INT 1
11242: ARRAY
11243: PUSH
11244: LD_STRING o
11246: EQUAL
11247: IFFALSE 11259
// result := true else
11249: LD_ADDR_VAR 0 2
11253: PUSH
11254: LD_INT 1
11256: ST_TO_ADDR
11257: GO 11267
// result := false ;
11259: LD_ADDR_VAR 0 2
11263: PUSH
11264: LD_INT 0
11266: ST_TO_ADDR
// end else
11267: GO 11277
// result := false ;
11269: LD_ADDR_VAR 0 2
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// end ;
11277: LD_VAR 0 2
11281: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
11282: LD_INT 0
11284: PPUSH
11285: PPUSH
11286: PPUSH
11287: PPUSH
// if btype = - 1 then
11288: LD_VAR 0 2
11292: PUSH
11293: LD_INT 1
11295: NEG
11296: EQUAL
11297: IFFALSE 11337
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
11299: LD_ADDR_VAR 0 5
11303: PUSH
11304: LD_INT 22
11306: PUSH
11307: LD_VAR 0 1
11311: PUSH
11312: EMPTY
11313: LIST
11314: LIST
11315: PUSH
11316: LD_INT 21
11318: PUSH
11319: LD_INT 3
11321: PUSH
11322: EMPTY
11323: LIST
11324: LIST
11325: PUSH
11326: EMPTY
11327: LIST
11328: LIST
11329: PPUSH
11330: CALL_OW 69
11334: ST_TO_ADDR
11335: GO 11375
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
11337: LD_ADDR_VAR 0 5
11341: PUSH
11342: LD_INT 22
11344: PUSH
11345: LD_VAR 0 1
11349: PUSH
11350: EMPTY
11351: LIST
11352: LIST
11353: PUSH
11354: LD_INT 30
11356: PUSH
11357: LD_VAR 0 2
11361: PUSH
11362: EMPTY
11363: LIST
11364: LIST
11365: PUSH
11366: EMPTY
11367: LIST
11368: LIST
11369: PPUSH
11370: CALL_OW 69
11374: ST_TO_ADDR
// list := [ ] ;
11375: LD_ADDR_VAR 0 6
11379: PUSH
11380: EMPTY
11381: ST_TO_ADDR
// for i = 1 to tmp do
11382: LD_ADDR_VAR 0 4
11386: PUSH
11387: DOUBLE
11388: LD_INT 1
11390: DEC
11391: ST_TO_ADDR
11392: LD_VAR 0 5
11396: PUSH
11397: FOR_TO
11398: IFFALSE 11486
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11400: LD_ADDR_VAR 0 6
11404: PUSH
11405: LD_VAR 0 6
11409: PUSH
11410: LD_VAR 0 5
11414: PUSH
11415: LD_VAR 0 4
11419: ARRAY
11420: PPUSH
11421: CALL_OW 266
11425: PUSH
11426: LD_VAR 0 5
11430: PUSH
11431: LD_VAR 0 4
11435: ARRAY
11436: PPUSH
11437: CALL_OW 250
11441: PUSH
11442: LD_VAR 0 5
11446: PUSH
11447: LD_VAR 0 4
11451: ARRAY
11452: PPUSH
11453: CALL_OW 251
11457: PUSH
11458: LD_VAR 0 5
11462: PUSH
11463: LD_VAR 0 4
11467: ARRAY
11468: PPUSH
11469: CALL_OW 254
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: EMPTY
11481: LIST
11482: ADD
11483: ST_TO_ADDR
11484: GO 11397
11486: POP
11487: POP
// result = list ;
11488: LD_ADDR_VAR 0 3
11492: PUSH
11493: LD_VAR 0 6
11497: ST_TO_ADDR
// end ;
11498: LD_VAR 0 3
11502: RET
// export function BehemothAttack ( behemoth , time_lapsers_list , mechanic_list , x , y ) ; var i , p , dist ; begin
11503: LD_INT 0
11505: PPUSH
11506: PPUSH
11507: PPUSH
11508: PPUSH
// if GetDistUnits ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) < 18 then
11509: LD_VAR 0 1
11513: PPUSH
11514: LD_INT 81
11516: PUSH
11517: LD_VAR 0 1
11521: PPUSH
11522: CALL_OW 255
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: PPUSH
11531: CALL_OW 69
11535: PPUSH
11536: LD_VAR 0 1
11540: PPUSH
11541: CALL_OW 74
11545: PPUSH
11546: CALL_OW 296
11550: PUSH
11551: LD_INT 18
11553: LESS
11554: IFFALSE 11599
// ComAttackUnit ( behemoth , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( behemoth ) ] ) , behemoth ) ) else
11556: LD_VAR 0 1
11560: PPUSH
11561: LD_INT 81
11563: PUSH
11564: LD_VAR 0 1
11568: PPUSH
11569: CALL_OW 255
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PPUSH
11578: CALL_OW 69
11582: PPUSH
11583: LD_VAR 0 1
11587: PPUSH
11588: CALL_OW 74
11592: PPUSH
11593: CALL_OW 115
11597: GO 11618
// ComMoveXY ( behemoth , x , y ) ;
11599: LD_VAR 0 1
11603: PPUSH
11604: LD_VAR 0 4
11608: PPUSH
11609: LD_VAR 0 5
11613: PPUSH
11614: CALL_OW 111
// if time_lapsers_list > 0 then
11618: LD_VAR 0 2
11622: PUSH
11623: LD_INT 0
11625: GREATER
11626: IFFALSE 11816
// begin for i = 1 to time_lapsers_list do
11628: LD_ADDR_VAR 0 7
11632: PUSH
11633: DOUBLE
11634: LD_INT 1
11636: DEC
11637: ST_TO_ADDR
11638: LD_VAR 0 2
11642: PUSH
11643: FOR_TO
11644: IFFALSE 11814
// begin if GetLives ( time_lapsers_list [ i ] ) >= 250 and GetDistUnits ( time_lapsers_list [ i ] , behemoth ) > 9 then
11646: LD_VAR 0 2
11650: PUSH
11651: LD_VAR 0 7
11655: ARRAY
11656: PPUSH
11657: CALL_OW 256
11661: PUSH
11662: LD_INT 250
11664: GREATEREQUAL
11665: PUSH
11666: LD_VAR 0 2
11670: PUSH
11671: LD_VAR 0 7
11675: ARRAY
11676: PPUSH
11677: LD_VAR 0 1
11681: PPUSH
11682: CALL_OW 296
11686: PUSH
11687: LD_INT 9
11689: GREATER
11690: AND
11691: IFFALSE 11728
// ComMoveXY ( time_lapsers_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11693: LD_VAR 0 2
11697: PUSH
11698: LD_VAR 0 7
11702: ARRAY
11703: PPUSH
11704: LD_VAR 0 1
11708: PPUSH
11709: CALL_OW 250
11713: PPUSH
11714: LD_VAR 0 1
11718: PPUSH
11719: CALL_OW 251
11723: PPUSH
11724: CALL_OW 111
// if GetLives ( time_lapsers_list [ i ] ) < 500 and GetLives ( behemoth ) > 700 then
11728: LD_VAR 0 2
11732: PUSH
11733: LD_VAR 0 7
11737: ARRAY
11738: PPUSH
11739: CALL_OW 256
11743: PUSH
11744: LD_INT 500
11746: LESS
11747: PUSH
11748: LD_VAR 0 1
11752: PPUSH
11753: CALL_OW 256
11757: PUSH
11758: LD_INT 700
11760: GREATER
11761: AND
11762: IFFALSE 11812
// for p = 1 to mechanic_list do
11764: LD_ADDR_VAR 0 8
11768: PUSH
11769: DOUBLE
11770: LD_INT 1
11772: DEC
11773: ST_TO_ADDR
11774: LD_VAR 0 3
11778: PUSH
11779: FOR_TO
11780: IFFALSE 11810
// ComRepairVehicle ( mechanic_list [ p ] , time_lapsers_list [ i ] ) ;
11782: LD_VAR 0 3
11786: PUSH
11787: LD_VAR 0 8
11791: ARRAY
11792: PPUSH
11793: LD_VAR 0 2
11797: PUSH
11798: LD_VAR 0 7
11802: ARRAY
11803: PPUSH
11804: CALL_OW 129
11808: GO 11779
11810: POP
11811: POP
// end ;
11812: GO 11643
11814: POP
11815: POP
// end ; if mechanic_list then
11816: LD_VAR 0 3
11820: IFFALSE 12001
// begin for i = 1 to mechanic_list do
11822: LD_ADDR_VAR 0 7
11826: PUSH
11827: DOUBLE
11828: LD_INT 1
11830: DEC
11831: ST_TO_ADDR
11832: LD_VAR 0 3
11836: PUSH
11837: FOR_TO
11838: IFFALSE 11999
// begin if GetLives ( mechanic_list [ i ] ) < 333 then
11840: LD_VAR 0 3
11844: PUSH
11845: LD_VAR 0 7
11849: ARRAY
11850: PPUSH
11851: CALL_OW 256
11855: PUSH
11856: LD_INT 333
11858: LESS
11859: IFFALSE 11883
// ru_behemoth_mechanic := ru_behemoth_mechanic diff mechanic_list [ i ] ;
11861: LD_ADDR_EXP 14
11865: PUSH
11866: LD_EXP 14
11870: PUSH
11871: LD_VAR 0 3
11875: PUSH
11876: LD_VAR 0 7
11880: ARRAY
11881: DIFF
11882: ST_TO_ADDR
// if GetDistUnits ( mechanic_list [ i ] , behemoth ) > 9 and not HasTask ( mechanic_list [ i ] ) then
11883: LD_VAR 0 3
11887: PUSH
11888: LD_VAR 0 7
11892: ARRAY
11893: PPUSH
11894: LD_VAR 0 1
11898: PPUSH
11899: CALL_OW 296
11903: PUSH
11904: LD_INT 9
11906: GREATER
11907: PUSH
11908: LD_VAR 0 3
11912: PUSH
11913: LD_VAR 0 7
11917: ARRAY
11918: PPUSH
11919: CALL_OW 314
11923: NOT
11924: AND
11925: IFFALSE 11962
// ComMoveXY ( mechanic_list [ i ] , GetX ( behemoth ) , GetY ( behemoth ) ) ;
11927: LD_VAR 0 3
11931: PUSH
11932: LD_VAR 0 7
11936: ARRAY
11937: PPUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 250
11947: PPUSH
11948: LD_VAR 0 1
11952: PPUSH
11953: CALL_OW 251
11957: PPUSH
11958: CALL_OW 111
// if GetLives ( behemoth ) < 700 then
11962: LD_VAR 0 1
11966: PPUSH
11967: CALL_OW 256
11971: PUSH
11972: LD_INT 700
11974: LESS
11975: IFFALSE 11997
// ComRepairVehicle ( mechanic_list [ i ] , behemoth ) ;
11977: LD_VAR 0 3
11981: PUSH
11982: LD_VAR 0 7
11986: ARRAY
11987: PPUSH
11988: LD_VAR 0 1
11992: PPUSH
11993: CALL_OW 129
// end ;
11997: GO 11837
11999: POP
12000: POP
// end ; end ;
12001: LD_VAR 0 6
12005: RET
// export function GetBehemoth ( side ) ; begin
12006: LD_INT 0
12008: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
12009: LD_ADDR_VAR 0 2
12013: PUSH
12014: LD_INT 22
12016: PUSH
12017: LD_VAR 0 1
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: PUSH
12026: LD_INT 31
12028: PUSH
12029: LD_INT 25
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PPUSH
12040: CALL_OW 69
12044: ST_TO_ADDR
// end ;
12045: LD_VAR 0 2
12049: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr , i , am ; begin
12050: LD_INT 0
12052: PPUSH
12053: PPUSH
12054: PPUSH
12055: PPUSH
12056: PPUSH
12057: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
12058: LD_ADDR_VAR 0 6
12062: PUSH
12063: LD_VAR 0 2
12067: PPUSH
12068: CALL_OW 435
12072: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
12073: LD_ADDR_VAR 0 5
12077: PUSH
12078: LD_INT 22
12080: PUSH
12081: LD_VAR 0 1
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PUSH
12090: LD_INT 2
12092: PUSH
12093: LD_INT 25
12095: PUSH
12096: LD_INT 2
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 16
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: LIST
12117: PUSH
12118: EMPTY
12119: LIST
12120: LIST
12121: PPUSH
12122: CALL_OW 69
12126: ST_TO_ADDR
// if skr then
12127: LD_VAR 0 6
12131: IFFALSE 12296
// begin if engs then
12133: LD_VAR 0 5
12137: IFFALSE 12296
// begin am := GetResourceAmountXY ( skr [ 1 ] , skr [ 2 ] ) ;
12139: LD_ADDR_VAR 0 8
12143: PUSH
12144: LD_VAR 0 6
12148: PUSH
12149: LD_INT 1
12151: ARRAY
12152: PPUSH
12153: LD_VAR 0 6
12157: PUSH
12158: LD_INT 2
12160: ARRAY
12161: PPUSH
12162: CALL_OW 284
12166: ST_TO_ADDR
// if am > engs then
12167: LD_VAR 0 8
12171: PUSH
12172: LD_VAR 0 5
12176: GREATER
12177: IFFALSE 12189
// am := engs ;
12179: LD_ADDR_VAR 0 8
12183: PUSH
12184: LD_VAR 0 5
12188: ST_TO_ADDR
// for i = 1 to am do
12189: LD_ADDR_VAR 0 7
12193: PUSH
12194: DOUBLE
12195: LD_INT 1
12197: DEC
12198: ST_TO_ADDR
12199: LD_VAR 0 8
12203: PUSH
12204: FOR_TO
12205: IFFALSE 12294
// begin if IsInUnit ( engs [ i ] ) then
12207: LD_VAR 0 5
12211: PUSH
12212: LD_VAR 0 7
12216: ARRAY
12217: PPUSH
12218: CALL_OW 310
12222: IFFALSE 12241
// ComExitBuilding ( engs [ i ] ) else
12224: LD_VAR 0 5
12228: PUSH
12229: LD_VAR 0 7
12233: ARRAY
12234: PPUSH
12235: CALL_OW 122
12239: GO 12292
// if not HasTask ( engs [ i ] ) then
12241: LD_VAR 0 5
12245: PUSH
12246: LD_VAR 0 7
12250: ARRAY
12251: PPUSH
12252: CALL_OW 314
12256: NOT
12257: IFFALSE 12292
// ComCollect ( engs [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
12259: LD_VAR 0 5
12263: PUSH
12264: LD_VAR 0 7
12268: ARRAY
12269: PPUSH
12270: LD_VAR 0 6
12274: PUSH
12275: LD_INT 1
12277: ARRAY
12278: PPUSH
12279: LD_VAR 0 6
12283: PUSH
12284: LD_INT 2
12286: ARRAY
12287: PPUSH
12288: CALL_OW 117
// end ;
12292: GO 12204
12294: POP
12295: POP
// end ; end ; end ; end_of_file
12296: LD_VAR 0 3
12300: RET
// export game_status ; export helps_arrive , helps_can_arrive ; export beta_come , gamma_come , zeta_come , mine_ck , sib_bomb_constructed , mine_constructed ; export guyA , guyB ; export function PrepareAmerican ; var skill ; begin
12301: LD_INT 0
12303: PPUSH
12304: PPUSH
// uc_side := 1 ;
12305: LD_ADDR_OWVAR 20
12309: PUSH
12310: LD_INT 1
12312: ST_TO_ADDR
// uc_nation := 1 ;
12313: LD_ADDR_OWVAR 21
12317: PUSH
12318: LD_INT 1
12320: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12321: LD_ADDR_VAR 0 2
12325: PUSH
12326: LD_INT 6
12328: PUSH
12329: LD_INT 5
12331: PUSH
12332: LD_INT 4
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: LIST
12339: PUSH
12340: LD_OWVAR 67
12344: ARRAY
12345: ST_TO_ADDR
// game_status := false ;
12346: LD_ADDR_EXP 28
12350: PUSH
12351: LD_INT 0
12353: ST_TO_ADDR
// helps_arrive := false ;
12354: LD_ADDR_EXP 29
12358: PUSH
12359: LD_INT 0
12361: ST_TO_ADDR
// helps_can_arrive := false ;
12362: LD_ADDR_EXP 30
12366: PUSH
12367: LD_INT 0
12369: ST_TO_ADDR
// beta_come := false ;
12370: LD_ADDR_EXP 31
12374: PUSH
12375: LD_INT 0
12377: ST_TO_ADDR
// gamma_come := false ;
12378: LD_ADDR_EXP 32
12382: PUSH
12383: LD_INT 0
12385: ST_TO_ADDR
// zeta_come := false ;
12386: LD_ADDR_EXP 33
12390: PUSH
12391: LD_INT 0
12393: ST_TO_ADDR
// mine_ck := false ;
12394: LD_ADDR_EXP 34
12398: PUSH
12399: LD_INT 0
12401: ST_TO_ADDR
// sib_bomb_constructed := false ;
12402: LD_ADDR_EXP 35
12406: PUSH
12407: LD_INT 0
12409: ST_TO_ADDR
// mine_constructed := false ;
12410: LD_ADDR_EXP 36
12414: PUSH
12415: LD_INT 0
12417: ST_TO_ADDR
// SetResourceType ( GetBase ( us_dep1 ) , mat_cans , [ 200 , 100 , 70 ] [ Difficulty ] ) ;
12418: LD_INT 35
12420: PPUSH
12421: CALL_OW 274
12425: PPUSH
12426: LD_INT 1
12428: PPUSH
12429: LD_INT 200
12431: PUSH
12432: LD_INT 100
12434: PUSH
12435: LD_INT 70
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: LIST
12442: PUSH
12443: LD_OWVAR 67
12447: ARRAY
12448: PPUSH
12449: CALL_OW 277
// SetSide ( us_dep1 , 4 ) ;
12453: LD_INT 35
12455: PPUSH
12456: LD_INT 4
12458: PPUSH
12459: CALL_OW 235
// hc_importance := 100 ;
12463: LD_ADDR_OWVAR 32
12467: PUSH
12468: LD_INT 100
12470: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , skill + 1 ) ;
12471: LD_INT 1
12473: PPUSH
12474: LD_INT 2
12476: PPUSH
12477: LD_VAR 0 2
12481: PUSH
12482: LD_INT 1
12484: PLUS
12485: PPUSH
12486: CALL_OW 380
// hc_gallery := hardch ;
12490: LD_ADDR_OWVAR 33
12494: PUSH
12495: LD_STRING hardch
12497: ST_TO_ADDR
// hc_face_number := 1 ;
12498: LD_ADDR_OWVAR 34
12502: PUSH
12503: LD_INT 1
12505: ST_TO_ADDR
// guyA := CreateHuman ;
12506: LD_ADDR_EXP 37
12510: PUSH
12511: CALL_OW 44
12515: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
12516: LD_INT 1
12518: PPUSH
12519: LD_INT 1
12521: PPUSH
12522: LD_VAR 0 2
12526: PPUSH
12527: CALL_OW 380
// hc_face_number := 2 ;
12531: LD_ADDR_OWVAR 34
12535: PUSH
12536: LD_INT 2
12538: ST_TO_ADDR
// guyB := CreateHuman ;
12539: LD_ADDR_EXP 38
12543: PUSH
12544: CALL_OW 44
12548: ST_TO_ADDR
// hc_importance := 0 ;
12549: LD_ADDR_OWVAR 32
12553: PUSH
12554: LD_INT 0
12556: ST_TO_ADDR
// hc_gallery :=  ;
12557: LD_ADDR_OWVAR 33
12561: PUSH
12562: LD_STRING 
12564: ST_TO_ADDR
// end ;
12565: LD_VAR 0 1
12569: RET
// export Beta_Squad ; export function AddBetaSquad ( num ) ; var i , un , sold , sci , mech , tank , cargo , skill ; begin
12570: LD_INT 0
12572: PPUSH
12573: PPUSH
12574: PPUSH
12575: PPUSH
12576: PPUSH
12577: PPUSH
12578: PPUSH
12579: PPUSH
12580: PPUSH
// uc_side := 4 ;
12581: LD_ADDR_OWVAR 20
12585: PUSH
12586: LD_INT 4
12588: ST_TO_ADDR
// uc_nation := 1 ;
12589: LD_ADDR_OWVAR 21
12593: PUSH
12594: LD_INT 1
12596: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
12597: LD_ADDR_VAR 0 10
12601: PUSH
12602: LD_INT 6
12604: PUSH
12605: LD_INT 5
12607: PUSH
12608: LD_INT 4
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: PUSH
12616: LD_OWVAR 67
12620: ARRAY
12621: ST_TO_ADDR
// Beta_Squad := [ ] ;
12622: LD_ADDR_EXP 39
12626: PUSH
12627: EMPTY
12628: ST_TO_ADDR
// case num of 1 :
12629: LD_VAR 0 1
12633: PUSH
12634: LD_INT 1
12636: DOUBLE
12637: EQUAL
12638: IFTRUE 12642
12640: GO 12685
12642: POP
// begin sold := 2 ;
12643: LD_ADDR_VAR 0 5
12647: PUSH
12648: LD_INT 2
12650: ST_TO_ADDR
// sci := 1 ;
12651: LD_ADDR_VAR 0 6
12655: PUSH
12656: LD_INT 1
12658: ST_TO_ADDR
// mech := 2 ;
12659: LD_ADDR_VAR 0 7
12663: PUSH
12664: LD_INT 2
12666: ST_TO_ADDR
// tank := 1 ;
12667: LD_ADDR_VAR 0 8
12671: PUSH
12672: LD_INT 1
12674: ST_TO_ADDR
// cargo := 1 ;
12675: LD_ADDR_VAR 0 9
12679: PUSH
12680: LD_INT 1
12682: ST_TO_ADDR
// end ; 2 :
12683: GO 12788
12685: LD_INT 2
12687: DOUBLE
12688: EQUAL
12689: IFTRUE 12693
12691: GO 12736
12693: POP
// begin sold := 2 ;
12694: LD_ADDR_VAR 0 5
12698: PUSH
12699: LD_INT 2
12701: ST_TO_ADDR
// sci := 1 ;
12702: LD_ADDR_VAR 0 6
12706: PUSH
12707: LD_INT 1
12709: ST_TO_ADDR
// mech := 1 ;
12710: LD_ADDR_VAR 0 7
12714: PUSH
12715: LD_INT 1
12717: ST_TO_ADDR
// tank := 1 ;
12718: LD_ADDR_VAR 0 8
12722: PUSH
12723: LD_INT 1
12725: ST_TO_ADDR
// cargo := 0 ;
12726: LD_ADDR_VAR 0 9
12730: PUSH
12731: LD_INT 0
12733: ST_TO_ADDR
// end ; 3 :
12734: GO 12788
12736: LD_INT 3
12738: DOUBLE
12739: EQUAL
12740: IFTRUE 12744
12742: GO 12787
12744: POP
// begin sold := 1 ;
12745: LD_ADDR_VAR 0 5
12749: PUSH
12750: LD_INT 1
12752: ST_TO_ADDR
// sci := 1 ;
12753: LD_ADDR_VAR 0 6
12757: PUSH
12758: LD_INT 1
12760: ST_TO_ADDR
// mech := 1 ;
12761: LD_ADDR_VAR 0 7
12765: PUSH
12766: LD_INT 1
12768: ST_TO_ADDR
// tank := 1 ;
12769: LD_ADDR_VAR 0 8
12773: PUSH
12774: LD_INT 1
12776: ST_TO_ADDR
// cargo := 0 ;
12777: LD_ADDR_VAR 0 9
12781: PUSH
12782: LD_INT 0
12784: ST_TO_ADDR
// end ; end ;
12785: GO 12788
12787: POP
// for i = 1 to sold do
12788: LD_ADDR_VAR 0 3
12792: PUSH
12793: DOUBLE
12794: LD_INT 1
12796: DEC
12797: ST_TO_ADDR
12798: LD_VAR 0 5
12802: PUSH
12803: FOR_TO
12804: IFFALSE 12876
// begin if i = 1 then
12806: LD_VAR 0 3
12810: PUSH
12811: LD_INT 1
12813: EQUAL
12814: IFFALSE 12833
// PrepareHuman ( sex_male , 1 , skill ) else
12816: LD_INT 1
12818: PPUSH
12819: LD_INT 1
12821: PPUSH
12822: LD_VAR 0 10
12826: PPUSH
12827: CALL_OW 380
12831: GO 12848
// PrepareHuman ( false , 1 , skill ) ;
12833: LD_INT 0
12835: PPUSH
12836: LD_INT 1
12838: PPUSH
12839: LD_VAR 0 10
12843: PPUSH
12844: CALL_OW 380
// un := CreateHuman ;
12848: LD_ADDR_VAR 0 4
12852: PUSH
12853: CALL_OW 44
12857: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12858: LD_ADDR_EXP 39
12862: PUSH
12863: LD_EXP 39
12867: PUSH
12868: LD_VAR 0 4
12872: ADD
12873: ST_TO_ADDR
// end ;
12874: GO 12803
12876: POP
12877: POP
// for i = 1 to mech do
12878: LD_ADDR_VAR 0 3
12882: PUSH
12883: DOUBLE
12884: LD_INT 1
12886: DEC
12887: ST_TO_ADDR
12888: LD_VAR 0 7
12892: PUSH
12893: FOR_TO
12894: IFFALSE 12951
// begin PrepareHuman ( false , 3 , skill ) ;
12896: LD_INT 0
12898: PPUSH
12899: LD_INT 3
12901: PPUSH
12902: LD_VAR 0 10
12906: PPUSH
12907: CALL_OW 380
// un := CreateHuman ;
12911: LD_ADDR_VAR 0 4
12915: PUSH
12916: CALL_OW 44
12920: ST_TO_ADDR
// SetTag ( un , 3 ) ;
12921: LD_VAR 0 4
12925: PPUSH
12926: LD_INT 3
12928: PPUSH
12929: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
12933: LD_ADDR_EXP 39
12937: PUSH
12938: LD_EXP 39
12942: PUSH
12943: LD_VAR 0 4
12947: ADD
12948: ST_TO_ADDR
// end ;
12949: GO 12893
12951: POP
12952: POP
// for i = 1 to sci do
12953: LD_ADDR_VAR 0 3
12957: PUSH
12958: DOUBLE
12959: LD_INT 1
12961: DEC
12962: ST_TO_ADDR
12963: LD_VAR 0 6
12967: PUSH
12968: FOR_TO
12969: IFFALSE 13014
// begin PrepareHuman ( false , 4 , skill ) ;
12971: LD_INT 0
12973: PPUSH
12974: LD_INT 4
12976: PPUSH
12977: LD_VAR 0 10
12981: PPUSH
12982: CALL_OW 380
// un := CreateHuman ;
12986: LD_ADDR_VAR 0 4
12990: PUSH
12991: CALL_OW 44
12995: ST_TO_ADDR
// Beta_Squad := Beta_Squad ^ un ;
12996: LD_ADDR_EXP 39
13000: PUSH
13001: LD_EXP 39
13005: PUSH
13006: LD_VAR 0 4
13010: ADD
13011: ST_TO_ADDR
// end ;
13012: GO 12968
13014: POP
13015: POP
// for i = 1 to tank do
13016: LD_ADDR_VAR 0 3
13020: PUSH
13021: DOUBLE
13022: LD_INT 1
13024: DEC
13025: ST_TO_ADDR
13026: LD_VAR 0 8
13030: PUSH
13031: FOR_TO
13032: IFFALSE 13145
// begin Randomize ;
13034: CALL_OW 10
// vc_chassis := us_medium_tracked ;
13038: LD_ADDR_OWVAR 37
13042: PUSH
13043: LD_INT 3
13045: ST_TO_ADDR
// vc_engine := engine_solar ;
13046: LD_ADDR_OWVAR 39
13050: PUSH
13051: LD_INT 2
13053: ST_TO_ADDR
// vc_control := control_manual ;
13054: LD_ADDR_OWVAR 38
13058: PUSH
13059: LD_INT 1
13061: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun ] [ Rand ( 1 , 2 ) ] ;
13062: LD_ADDR_OWVAR 40
13066: PUSH
13067: LD_INT 4
13069: PUSH
13070: LD_INT 5
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: PUSH
13077: LD_INT 1
13079: PPUSH
13080: LD_INT 2
13082: PPUSH
13083: CALL_OW 12
13087: ARRAY
13088: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13089: LD_ADDR_OWVAR 41
13093: PUSH
13094: LD_INT 35
13096: PPUSH
13097: LD_INT 55
13099: PPUSH
13100: CALL_OW 12
13104: ST_TO_ADDR
// un := CreateVehicle ;
13105: LD_ADDR_VAR 0 4
13109: PUSH
13110: CALL_OW 45
13114: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13115: LD_VAR 0 4
13119: PPUSH
13120: LD_INT 5
13122: PPUSH
13123: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13127: LD_ADDR_EXP 39
13131: PUSH
13132: LD_EXP 39
13136: PUSH
13137: LD_VAR 0 4
13141: ADD
13142: ST_TO_ADDR
// end ;
13143: GO 13031
13145: POP
13146: POP
// if cargo then
13147: LD_VAR 0 9
13151: IFFALSE 13254
// begin vc_chassis := us_medium_tracked ;
13153: LD_ADDR_OWVAR 37
13157: PUSH
13158: LD_INT 3
13160: ST_TO_ADDR
// vc_engine := engine_solar ;
13161: LD_ADDR_OWVAR 39
13165: PUSH
13166: LD_INT 2
13168: ST_TO_ADDR
// vc_control := control_manual ;
13169: LD_ADDR_OWVAR 38
13173: PUSH
13174: LD_INT 1
13176: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13177: LD_ADDR_OWVAR 40
13181: PUSH
13182: LD_INT 12
13184: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13185: LD_ADDR_OWVAR 41
13189: PUSH
13190: LD_INT 35
13192: PPUSH
13193: LD_INT 55
13195: PPUSH
13196: CALL_OW 12
13200: ST_TO_ADDR
// un := CreateVehicle ;
13201: LD_ADDR_VAR 0 4
13205: PUSH
13206: CALL_OW 45
13210: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13211: LD_VAR 0 4
13215: PPUSH
13216: LD_INT 5
13218: PPUSH
13219: CALL_OW 109
// Beta_Squad := Beta_Squad ^ un ;
13223: LD_ADDR_EXP 39
13227: PUSH
13228: LD_EXP 39
13232: PUSH
13233: LD_VAR 0 4
13237: ADD
13238: ST_TO_ADDR
// SetCargo ( un , mat_cans , 60 ) ;
13239: LD_VAR 0 4
13243: PPUSH
13244: LD_INT 1
13246: PPUSH
13247: LD_INT 60
13249: PPUSH
13250: CALL_OW 290
// end ; end ;
13254: LD_VAR 0 2
13258: RET
// export Gamma_Squad ; export function AddGammaSquad ( num ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13259: LD_INT 0
13261: PPUSH
13262: PPUSH
13263: PPUSH
13264: PPUSH
13265: PPUSH
13266: PPUSH
13267: PPUSH
13268: PPUSH
13269: PPUSH
13270: PPUSH
// uc_side := 4 ;
13271: LD_ADDR_OWVAR 20
13275: PUSH
13276: LD_INT 4
13278: ST_TO_ADDR
// uc_nation := 1 ;
13279: LD_ADDR_OWVAR 21
13283: PUSH
13284: LD_INT 1
13286: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
13287: LD_ADDR_VAR 0 11
13291: PUSH
13292: LD_INT 6
13294: PUSH
13295: LD_INT 5
13297: PUSH
13298: LD_INT 4
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: LIST
13305: PUSH
13306: LD_OWVAR 67
13310: ARRAY
13311: ST_TO_ADDR
// Gamma_Squad := [ ] ;
13312: LD_ADDR_EXP 40
13316: PUSH
13317: EMPTY
13318: ST_TO_ADDR
// case num of 1 :
13319: LD_VAR 0 1
13323: PUSH
13324: LD_INT 1
13326: DOUBLE
13327: EQUAL
13328: IFTRUE 13332
13330: GO 13383
13332: POP
// begin sold := 2 ;
13333: LD_ADDR_VAR 0 5
13337: PUSH
13338: LD_INT 2
13340: ST_TO_ADDR
// eng := 2 ;
13341: LD_ADDR_VAR 0 6
13345: PUSH
13346: LD_INT 2
13348: ST_TO_ADDR
// sci := 0 ;
13349: LD_ADDR_VAR 0 7
13353: PUSH
13354: LD_INT 0
13356: ST_TO_ADDR
// mech := 1 ;
13357: LD_ADDR_VAR 0 8
13361: PUSH
13362: LD_INT 1
13364: ST_TO_ADDR
// tank := 0 ;
13365: LD_ADDR_VAR 0 9
13369: PUSH
13370: LD_INT 0
13372: ST_TO_ADDR
// cargo := 1 ;
13373: LD_ADDR_VAR 0 10
13377: PUSH
13378: LD_INT 1
13380: ST_TO_ADDR
// end ; 2 :
13381: GO 13502
13383: LD_INT 2
13385: DOUBLE
13386: EQUAL
13387: IFTRUE 13391
13389: GO 13442
13391: POP
// begin sold := 1 ;
13392: LD_ADDR_VAR 0 5
13396: PUSH
13397: LD_INT 1
13399: ST_TO_ADDR
// eng := 2 ;
13400: LD_ADDR_VAR 0 6
13404: PUSH
13405: LD_INT 2
13407: ST_TO_ADDR
// sci := 0 ;
13408: LD_ADDR_VAR 0 7
13412: PUSH
13413: LD_INT 0
13415: ST_TO_ADDR
// mech := 1 ;
13416: LD_ADDR_VAR 0 8
13420: PUSH
13421: LD_INT 1
13423: ST_TO_ADDR
// tank := 0 ;
13424: LD_ADDR_VAR 0 9
13428: PUSH
13429: LD_INT 0
13431: ST_TO_ADDR
// cargo := 1 ;
13432: LD_ADDR_VAR 0 10
13436: PUSH
13437: LD_INT 1
13439: ST_TO_ADDR
// end ; 3 :
13440: GO 13502
13442: LD_INT 3
13444: DOUBLE
13445: EQUAL
13446: IFTRUE 13450
13448: GO 13501
13450: POP
// begin sold := 1 ;
13451: LD_ADDR_VAR 0 5
13455: PUSH
13456: LD_INT 1
13458: ST_TO_ADDR
// eng := 1 ;
13459: LD_ADDR_VAR 0 6
13463: PUSH
13464: LD_INT 1
13466: ST_TO_ADDR
// sci := 0 ;
13467: LD_ADDR_VAR 0 7
13471: PUSH
13472: LD_INT 0
13474: ST_TO_ADDR
// mech := 1 ;
13475: LD_ADDR_VAR 0 8
13479: PUSH
13480: LD_INT 1
13482: ST_TO_ADDR
// tank := 0 ;
13483: LD_ADDR_VAR 0 9
13487: PUSH
13488: LD_INT 0
13490: ST_TO_ADDR
// cargo := 1 ;
13491: LD_ADDR_VAR 0 10
13495: PUSH
13496: LD_INT 1
13498: ST_TO_ADDR
// end ; end ;
13499: GO 13502
13501: POP
// for i = 1 to sold do
13502: LD_ADDR_VAR 0 3
13506: PUSH
13507: DOUBLE
13508: LD_INT 1
13510: DEC
13511: ST_TO_ADDR
13512: LD_VAR 0 5
13516: PUSH
13517: FOR_TO
13518: IFFALSE 13590
// begin if i = 1 then
13520: LD_VAR 0 3
13524: PUSH
13525: LD_INT 1
13527: EQUAL
13528: IFFALSE 13547
// PrepareHuman ( sex_male , 1 , skill ) else
13530: LD_INT 1
13532: PPUSH
13533: LD_INT 1
13535: PPUSH
13536: LD_VAR 0 11
13540: PPUSH
13541: CALL_OW 380
13545: GO 13562
// PrepareHuman ( false , 1 , skill ) ;
13547: LD_INT 0
13549: PPUSH
13550: LD_INT 1
13552: PPUSH
13553: LD_VAR 0 11
13557: PPUSH
13558: CALL_OW 380
// un := CreateHuman ;
13562: LD_ADDR_VAR 0 4
13566: PUSH
13567: CALL_OW 44
13571: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13572: LD_ADDR_EXP 40
13576: PUSH
13577: LD_EXP 40
13581: PUSH
13582: LD_VAR 0 4
13586: ADD
13587: ST_TO_ADDR
// end ;
13588: GO 13517
13590: POP
13591: POP
// for i = 1 to mech do
13592: LD_ADDR_VAR 0 3
13596: PUSH
13597: DOUBLE
13598: LD_INT 1
13600: DEC
13601: ST_TO_ADDR
13602: LD_VAR 0 8
13606: PUSH
13607: FOR_TO
13608: IFFALSE 13665
// begin PrepareHuman ( false , 3 , skill ) ;
13610: LD_INT 0
13612: PPUSH
13613: LD_INT 3
13615: PPUSH
13616: LD_VAR 0 11
13620: PPUSH
13621: CALL_OW 380
// un := CreateHuman ;
13625: LD_ADDR_VAR 0 4
13629: PUSH
13630: CALL_OW 44
13634: ST_TO_ADDR
// SetTag ( un , 3 ) ;
13635: LD_VAR 0 4
13639: PPUSH
13640: LD_INT 3
13642: PPUSH
13643: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13647: LD_ADDR_EXP 40
13651: PUSH
13652: LD_EXP 40
13656: PUSH
13657: LD_VAR 0 4
13661: ADD
13662: ST_TO_ADDR
// end ;
13663: GO 13607
13665: POP
13666: POP
// for i = 1 to eng do
13667: LD_ADDR_VAR 0 3
13671: PUSH
13672: DOUBLE
13673: LD_INT 1
13675: DEC
13676: ST_TO_ADDR
13677: LD_VAR 0 6
13681: PUSH
13682: FOR_TO
13683: IFFALSE 13728
// begin PrepareHuman ( false , 2 , skill ) ;
13685: LD_INT 0
13687: PPUSH
13688: LD_INT 2
13690: PPUSH
13691: LD_VAR 0 11
13695: PPUSH
13696: CALL_OW 380
// un := CreateHuman ;
13700: LD_ADDR_VAR 0 4
13704: PUSH
13705: CALL_OW 44
13709: ST_TO_ADDR
// Gamma_Squad := Gamma_Squad ^ un ;
13710: LD_ADDR_EXP 40
13714: PUSH
13715: LD_EXP 40
13719: PUSH
13720: LD_VAR 0 4
13724: ADD
13725: ST_TO_ADDR
// end ;
13726: GO 13682
13728: POP
13729: POP
// for i = 1 to tank do
13730: LD_ADDR_VAR 0 3
13734: PUSH
13735: DOUBLE
13736: LD_INT 1
13738: DEC
13739: ST_TO_ADDR
13740: LD_VAR 0 9
13744: PUSH
13745: FOR_TO
13746: IFFALSE 13859
// begin Randomize ;
13748: CALL_OW 10
// vc_chassis := us_medium_wheeled ;
13752: LD_ADDR_OWVAR 37
13756: PUSH
13757: LD_INT 2
13759: ST_TO_ADDR
// vc_engine := engine_siberite ;
13760: LD_ADDR_OWVAR 39
13764: PUSH
13765: LD_INT 3
13767: ST_TO_ADDR
// vc_control := control_manual ;
13768: LD_ADDR_OWVAR 38
13772: PUSH
13773: LD_INT 1
13775: ST_TO_ADDR
// vc_weapon := [ us_rocket_launcher , us_laser ] [ Rand ( 1 , 2 ) ] ;
13776: LD_ADDR_OWVAR 40
13780: PUSH
13781: LD_INT 7
13783: PUSH
13784: LD_INT 9
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PUSH
13791: LD_INT 1
13793: PPUSH
13794: LD_INT 2
13796: PPUSH
13797: CALL_OW 12
13801: ARRAY
13802: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13803: LD_ADDR_OWVAR 41
13807: PUSH
13808: LD_INT 35
13810: PPUSH
13811: LD_INT 55
13813: PPUSH
13814: CALL_OW 12
13818: ST_TO_ADDR
// un := CreateVehicle ;
13819: LD_ADDR_VAR 0 4
13823: PUSH
13824: CALL_OW 45
13828: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13829: LD_VAR 0 4
13833: PPUSH
13834: LD_INT 5
13836: PPUSH
13837: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13841: LD_ADDR_EXP 40
13845: PUSH
13846: LD_EXP 40
13850: PUSH
13851: LD_VAR 0 4
13855: ADD
13856: ST_TO_ADDR
// end ;
13857: GO 13745
13859: POP
13860: POP
// if cargo then
13861: LD_VAR 0 10
13865: IFFALSE 13983
// begin vc_chassis := us_medium_tracked ;
13867: LD_ADDR_OWVAR 37
13871: PUSH
13872: LD_INT 3
13874: ST_TO_ADDR
// vc_engine := engine_combustion ;
13875: LD_ADDR_OWVAR 39
13879: PUSH
13880: LD_INT 1
13882: ST_TO_ADDR
// vc_control := control_manual ;
13883: LD_ADDR_OWVAR 38
13887: PUSH
13888: LD_INT 1
13890: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
13891: LD_ADDR_OWVAR 40
13895: PUSH
13896: LD_INT 12
13898: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
13899: LD_ADDR_OWVAR 41
13903: PUSH
13904: LD_INT 35
13906: PPUSH
13907: LD_INT 55
13909: PPUSH
13910: CALL_OW 12
13914: ST_TO_ADDR
// un := CreateVehicle ;
13915: LD_ADDR_VAR 0 4
13919: PUSH
13920: CALL_OW 45
13924: ST_TO_ADDR
// SetTag ( un , 5 ) ;
13925: LD_VAR 0 4
13929: PPUSH
13930: LD_INT 5
13932: PPUSH
13933: CALL_OW 109
// Gamma_Squad := Gamma_Squad ^ un ;
13937: LD_ADDR_EXP 40
13941: PUSH
13942: LD_EXP 40
13946: PUSH
13947: LD_VAR 0 4
13951: ADD
13952: ST_TO_ADDR
// SetCargo ( un , 3 , 30 ) ;
13953: LD_VAR 0 4
13957: PPUSH
13958: LD_INT 3
13960: PPUSH
13961: LD_INT 30
13963: PPUSH
13964: CALL_OW 290
// SetCargo ( un , 1 , 40 ) ;
13968: LD_VAR 0 4
13972: PPUSH
13973: LD_INT 1
13975: PPUSH
13976: LD_INT 40
13978: PPUSH
13979: CALL_OW 290
// end ; end ;
13983: LD_VAR 0 2
13987: RET
// export Zeta_Squad ; export function AddZetaSquad ( ) ; var i , un , sold , eng , sci , mech , tank , cargo , skill ; begin
13988: LD_INT 0
13990: PPUSH
13991: PPUSH
13992: PPUSH
13993: PPUSH
13994: PPUSH
13995: PPUSH
13996: PPUSH
13997: PPUSH
13998: PPUSH
13999: PPUSH
// uc_side := 4 ;
14000: LD_ADDR_OWVAR 20
14004: PUSH
14005: LD_INT 4
14007: ST_TO_ADDR
// uc_nation := 1 ;
14008: LD_ADDR_OWVAR 21
14012: PUSH
14013: LD_INT 1
14015: ST_TO_ADDR
// skill := [ 6 , 5 , 4 ] [ Difficulty ] ;
14016: LD_ADDR_VAR 0 10
14020: PUSH
14021: LD_INT 6
14023: PUSH
14024: LD_INT 5
14026: PUSH
14027: LD_INT 4
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: PUSH
14035: LD_OWVAR 67
14039: ARRAY
14040: ST_TO_ADDR
// Zeta_Squad := [ ] ;
14041: LD_ADDR_EXP 41
14045: PUSH
14046: EMPTY
14047: ST_TO_ADDR
// sold := 1 ;
14048: LD_ADDR_VAR 0 4
14052: PUSH
14053: LD_INT 1
14055: ST_TO_ADDR
// eng := 0 ;
14056: LD_ADDR_VAR 0 5
14060: PUSH
14061: LD_INT 0
14063: ST_TO_ADDR
// sci := 0 ;
14064: LD_ADDR_VAR 0 6
14068: PUSH
14069: LD_INT 0
14071: ST_TO_ADDR
// mech := 3 ;
14072: LD_ADDR_VAR 0 7
14076: PUSH
14077: LD_INT 3
14079: ST_TO_ADDR
// tank := 3 ;
14080: LD_ADDR_VAR 0 8
14084: PUSH
14085: LD_INT 3
14087: ST_TO_ADDR
// cargo := 0 ;
14088: LD_ADDR_VAR 0 9
14092: PUSH
14093: LD_INT 0
14095: ST_TO_ADDR
// for i = 1 to sold do
14096: LD_ADDR_VAR 0 2
14100: PUSH
14101: DOUBLE
14102: LD_INT 1
14104: DEC
14105: ST_TO_ADDR
14106: LD_VAR 0 4
14110: PUSH
14111: FOR_TO
14112: IFFALSE 14184
// begin if i = 1 then
14114: LD_VAR 0 2
14118: PUSH
14119: LD_INT 1
14121: EQUAL
14122: IFFALSE 14141
// PrepareHuman ( sex_male , 1 , skill ) else
14124: LD_INT 1
14126: PPUSH
14127: LD_INT 1
14129: PPUSH
14130: LD_VAR 0 10
14134: PPUSH
14135: CALL_OW 380
14139: GO 14156
// PrepareHuman ( false , 1 , skill ) ;
14141: LD_INT 0
14143: PPUSH
14144: LD_INT 1
14146: PPUSH
14147: LD_VAR 0 10
14151: PPUSH
14152: CALL_OW 380
// un := CreateHuman ;
14156: LD_ADDR_VAR 0 3
14160: PUSH
14161: CALL_OW 44
14165: ST_TO_ADDR
// Zeta_Squad := Zeta_Squad ^ un ;
14166: LD_ADDR_EXP 41
14170: PUSH
14171: LD_EXP 41
14175: PUSH
14176: LD_VAR 0 3
14180: ADD
14181: ST_TO_ADDR
// end ;
14182: GO 14111
14184: POP
14185: POP
// for i = 1 to mech do
14186: LD_ADDR_VAR 0 2
14190: PUSH
14191: DOUBLE
14192: LD_INT 1
14194: DEC
14195: ST_TO_ADDR
14196: LD_VAR 0 7
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14259
// begin PrepareHuman ( false , 3 , skill ) ;
14204: LD_INT 0
14206: PPUSH
14207: LD_INT 3
14209: PPUSH
14210: LD_VAR 0 10
14214: PPUSH
14215: CALL_OW 380
// un := CreateHuman ;
14219: LD_ADDR_VAR 0 3
14223: PUSH
14224: CALL_OW 44
14228: ST_TO_ADDR
// SetTag ( un , 3 ) ;
14229: LD_VAR 0 3
14233: PPUSH
14234: LD_INT 3
14236: PPUSH
14237: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14241: LD_ADDR_EXP 41
14245: PUSH
14246: LD_EXP 41
14250: PUSH
14251: LD_VAR 0 3
14255: ADD
14256: ST_TO_ADDR
// end ;
14257: GO 14201
14259: POP
14260: POP
// for i = 1 to tank do
14261: LD_ADDR_VAR 0 2
14265: PUSH
14266: DOUBLE
14267: LD_INT 1
14269: DEC
14270: ST_TO_ADDR
14271: LD_VAR 0 8
14275: PUSH
14276: FOR_TO
14277: IFFALSE 14523
// begin Randomize ;
14279: CALL_OW 10
// if i < 3 then
14283: LD_VAR 0 2
14287: PUSH
14288: LD_INT 3
14290: LESS
14291: IFFALSE 14400
// begin vc_chassis := us_medium_tracked ;
14293: LD_ADDR_OWVAR 37
14297: PUSH
14298: LD_INT 3
14300: ST_TO_ADDR
// vc_engine := engine_combustion ;
14301: LD_ADDR_OWVAR 39
14305: PUSH
14306: LD_INT 1
14308: ST_TO_ADDR
// vc_control := control_manual ;
14309: LD_ADDR_OWVAR 38
14313: PUSH
14314: LD_INT 1
14316: ST_TO_ADDR
// vc_weapon := [ us_light_gun , us_laser ] [ Rand ( 1 , 2 ) ] ;
14317: LD_ADDR_OWVAR 40
14321: PUSH
14322: LD_INT 3
14324: PUSH
14325: LD_INT 9
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: PUSH
14332: LD_INT 1
14334: PPUSH
14335: LD_INT 2
14337: PPUSH
14338: CALL_OW 12
14342: ARRAY
14343: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14344: LD_ADDR_OWVAR 41
14348: PUSH
14349: LD_INT 35
14351: PPUSH
14352: LD_INT 55
14354: PPUSH
14355: CALL_OW 12
14359: ST_TO_ADDR
// un := CreateVehicle ;
14360: LD_ADDR_VAR 0 3
14364: PUSH
14365: CALL_OW 45
14369: ST_TO_ADDR
// SetTag ( un , 5 ) ;
14370: LD_VAR 0 3
14374: PPUSH
14375: LD_INT 5
14377: PPUSH
14378: CALL_OW 109
// Zeta_Squad := Zeta_Squad ^ un ;
14382: LD_ADDR_EXP 41
14386: PUSH
14387: LD_EXP 41
14391: PUSH
14392: LD_VAR 0 3
14396: ADD
14397: ST_TO_ADDR
// end else
14398: GO 14521
// begin uc_nation := 3 ;
14400: LD_ADDR_OWVAR 21
14404: PUSH
14405: LD_INT 3
14407: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
14408: LD_ADDR_OWVAR 37
14412: PUSH
14413: LD_INT 22
14415: ST_TO_ADDR
// vc_engine := engine_combustion ;
14416: LD_ADDR_OWVAR 39
14420: PUSH
14421: LD_INT 1
14423: ST_TO_ADDR
// vc_control := control_manual ;
14424: LD_ADDR_OWVAR 38
14428: PUSH
14429: LD_INT 1
14431: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
14432: LD_ADDR_OWVAR 40
14436: PUSH
14437: LD_INT 51
14439: ST_TO_ADDR
// vc_fuel_battery := Rand ( 35 , 55 ) ;
14440: LD_ADDR_OWVAR 41
14444: PUSH
14445: LD_INT 35
14447: PPUSH
14448: LD_INT 55
14450: PPUSH
14451: CALL_OW 12
14455: ST_TO_ADDR
// un := CreateVehicle ;
14456: LD_ADDR_VAR 0 3
14460: PUSH
14461: CALL_OW 45
14465: ST_TO_ADDR
// SetLives ( un , 496 ) ;
14466: LD_VAR 0 3
14470: PPUSH
14471: LD_INT 496
14473: PPUSH
14474: CALL_OW 234
// SetTag ( un , 5 ) ;
14478: LD_VAR 0 3
14482: PPUSH
14483: LD_INT 5
14485: PPUSH
14486: CALL_OW 109
// SetCargo ( un , mat_oil , 100 ) ;
14490: LD_VAR 0 3
14494: PPUSH
14495: LD_INT 2
14497: PPUSH
14498: LD_INT 100
14500: PPUSH
14501: CALL_OW 290
// Zeta_Squad := Zeta_Squad ^ un ;
14505: LD_ADDR_EXP 41
14509: PUSH
14510: LD_EXP 41
14514: PUSH
14515: LD_VAR 0 3
14519: ADD
14520: ST_TO_ADDR
// end ; end ;
14521: GO 14276
14523: POP
14524: POP
// end ; end_of_file
14525: LD_VAR 0 1
14529: RET
// export function Action ; begin
14530: LD_INT 0
14532: PPUSH
// InGameOn ;
14533: CALL_OW 8
// CenterNowOnXY ( 151 , 107 ) ;
14537: LD_INT 151
14539: PPUSH
14540: LD_INT 107
14542: PPUSH
14543: CALL_OW 86
// PlaceUnitXY ( guyA , 171 , 108 , false ) ;
14547: LD_EXP 37
14551: PPUSH
14552: LD_INT 171
14554: PPUSH
14555: LD_INT 108
14557: PPUSH
14558: LD_INT 0
14560: PPUSH
14561: CALL_OW 48
// PlaceUnitXY ( guyB , 172 , 110 , false ) ;
14565: LD_EXP 38
14569: PPUSH
14570: LD_INT 172
14572: PPUSH
14573: LD_INT 110
14575: PPUSH
14576: LD_INT 0
14578: PPUSH
14579: CALL_OW 48
// ComMoveXY ( guyA , 156 , 107 ) ;
14583: LD_EXP 37
14587: PPUSH
14588: LD_INT 156
14590: PPUSH
14591: LD_INT 107
14593: PPUSH
14594: CALL_OW 111
// ComMoveXY ( guyB , 154 , 105 ) ;
14598: LD_EXP 38
14602: PPUSH
14603: LD_INT 154
14605: PPUSH
14606: LD_INT 105
14608: PPUSH
14609: CALL_OW 111
// repeat Wait ( 0 0$0.1 ) ;
14613: LD_INT 4
14615: PPUSH
14616: CALL_OW 67
// until GetX ( guyA ) = 156 and GetY ( guyA ) = 107 ;
14620: LD_EXP 37
14624: PPUSH
14625: CALL_OW 250
14629: PUSH
14630: LD_INT 156
14632: EQUAL
14633: PUSH
14634: LD_EXP 37
14638: PPUSH
14639: CALL_OW 251
14643: PUSH
14644: LD_INT 107
14646: EQUAL
14647: AND
14648: IFFALSE 14613
// ComTurnUnit ( [ guyA , guyB ] , us_dep1 ) ;
14650: LD_EXP 37
14654: PUSH
14655: LD_EXP 38
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PPUSH
14664: LD_INT 35
14666: PPUSH
14667: CALL_OW 119
// Say ( guyA , D1-A-1 ) ;
14671: LD_EXP 37
14675: PPUSH
14676: LD_STRING D1-A-1
14678: PPUSH
14679: CALL_OW 88
// Say ( guyB , D1-B-1 ) ;
14683: LD_EXP 38
14687: PPUSH
14688: LD_STRING D1-B-1
14690: PPUSH
14691: CALL_OW 88
// Say ( guyA , D1-A-2 ) ;
14695: LD_EXP 37
14699: PPUSH
14700: LD_STRING D1-A-2
14702: PPUSH
14703: CALL_OW 88
// Say ( guyB , D1-B-2 ) ;
14707: LD_EXP 38
14711: PPUSH
14712: LD_STRING D1-B-2
14714: PPUSH
14715: CALL_OW 88
// ComMoveXY ( [ guyA , guyB ] , 147 , 108 ) ;
14719: LD_EXP 37
14723: PUSH
14724: LD_EXP 38
14728: PUSH
14729: EMPTY
14730: LIST
14731: LIST
14732: PPUSH
14733: LD_INT 147
14735: PPUSH
14736: LD_INT 108
14738: PPUSH
14739: CALL_OW 111
// Say ( guyA , D1-A-3 ) ;
14743: LD_EXP 37
14747: PPUSH
14748: LD_STRING D1-A-3
14750: PPUSH
14751: CALL_OW 88
// repeat Wait ( 0 0$0.1 ) ;
14755: LD_INT 4
14757: PPUSH
14758: CALL_OW 67
// until GetDistUnits ( guyA , us_dep1 ) < 8 ;
14762: LD_EXP 37
14766: PPUSH
14767: LD_INT 35
14769: PPUSH
14770: CALL_OW 296
14774: PUSH
14775: LD_INT 8
14777: LESS
14778: IFFALSE 14755
// ComTurnUnit ( guyA , guyB ) ;
14780: LD_EXP 37
14784: PPUSH
14785: LD_EXP 38
14789: PPUSH
14790: CALL_OW 119
// ComTurnUnit ( guyB , guyA ) ;
14794: LD_EXP 38
14798: PPUSH
14799: LD_EXP 37
14803: PPUSH
14804: CALL_OW 119
// Say ( guyA , D1-A-10 ) ;
14808: LD_EXP 37
14812: PPUSH
14813: LD_STRING D1-A-10
14815: PPUSH
14816: CALL_OW 88
// Say ( guyB , D1-B-10 ) ;
14820: LD_EXP 38
14824: PPUSH
14825: LD_STRING D1-B-10
14827: PPUSH
14828: CALL_OW 88
// Say ( guyA , D1-A-11 ) ;
14832: LD_EXP 37
14836: PPUSH
14837: LD_STRING D1-A-11
14839: PPUSH
14840: CALL_OW 88
// Say ( guyB , D1-B-11 ) ;
14844: LD_EXP 38
14848: PPUSH
14849: LD_STRING D1-B-11
14851: PPUSH
14852: CALL_OW 88
// Say ( guyA , D1-A-12 ) ;
14856: LD_EXP 37
14860: PPUSH
14861: LD_STRING D1-A-12
14863: PPUSH
14864: CALL_OW 88
// Say ( guyB , D1-B-12 ) ;
14868: LD_EXP 38
14872: PPUSH
14873: LD_STRING D1-B-12
14875: PPUSH
14876: CALL_OW 88
// Say ( guyA , D1-A-13 ) ;
14880: LD_EXP 37
14884: PPUSH
14885: LD_STRING D1-A-13
14887: PPUSH
14888: CALL_OW 88
// Say ( guyB , D1-B-13 ) ;
14892: LD_EXP 38
14896: PPUSH
14897: LD_STRING D1-B-13
14899: PPUSH
14900: CALL_OW 88
// Say ( guyA , D1-A-14 ) ;
14904: LD_EXP 37
14908: PPUSH
14909: LD_STRING D1-A-14
14911: PPUSH
14912: CALL_OW 88
// Say ( guyB , D1-B-14 ) ;
14916: LD_EXP 38
14920: PPUSH
14921: LD_STRING D1-B-14
14923: PPUSH
14924: CALL_OW 88
// Say ( guyA , D1-A-15 ) ;
14928: LD_EXP 37
14932: PPUSH
14933: LD_STRING D1-A-15
14935: PPUSH
14936: CALL_OW 88
// Say ( guyB , D1-B-15 ) ;
14940: LD_EXP 38
14944: PPUSH
14945: LD_STRING D1-B-15
14947: PPUSH
14948: CALL_OW 88
// Say ( guyA , D1-A-16 ) ;
14952: LD_EXP 37
14956: PPUSH
14957: LD_STRING D1-A-16
14959: PPUSH
14960: CALL_OW 88
// Say ( guyB , D1-B-16 ) ;
14964: LD_EXP 38
14968: PPUSH
14969: LD_STRING D1-B-16
14971: PPUSH
14972: CALL_OW 88
// Say ( guyA , D1-A-17 ) ;
14976: LD_EXP 37
14980: PPUSH
14981: LD_STRING D1-A-17
14983: PPUSH
14984: CALL_OW 88
// Say ( guyB , D1-B-17 ) ;
14988: LD_EXP 38
14992: PPUSH
14993: LD_STRING D1-B-17
14995: PPUSH
14996: CALL_OW 88
// Say ( guyA , D1-A-18 ) ;
15000: LD_EXP 37
15004: PPUSH
15005: LD_STRING D1-A-18
15007: PPUSH
15008: CALL_OW 88
// SetSide ( us_dep1 , 1 ) ;
15012: LD_INT 35
15014: PPUSH
15015: LD_INT 1
15017: PPUSH
15018: CALL_OW 235
// ComEnterUnit ( [ guyA , guyB ] , us_dep1 ) ;
15022: LD_EXP 37
15026: PUSH
15027: LD_EXP 38
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: PPUSH
15036: LD_INT 35
15038: PPUSH
15039: CALL_OW 120
// repeat Wait ( 0 0$0.1 ) ;
15043: LD_INT 4
15045: PPUSH
15046: CALL_OW 67
// until IsInUnit ( guyA ) ;
15050: LD_EXP 37
15054: PPUSH
15055: CALL_OW 310
15059: IFFALSE 15043
// Wait ( 0 0$02 ) ;
15061: LD_INT 70
15063: PPUSH
15064: CALL_OW 67
// Say ( guyA , D1-A-19 ) ;
15068: LD_EXP 37
15072: PPUSH
15073: LD_STRING D1-A-19
15075: PPUSH
15076: CALL_OW 88
// Say ( guyB , D1-B-19 ) ;
15080: LD_EXP 38
15084: PPUSH
15085: LD_STRING D1-B-19
15087: PPUSH
15088: CALL_OW 88
// Say ( guyA , D1-A-20 ) ;
15092: LD_EXP 37
15096: PPUSH
15097: LD_STRING D1-A-20
15099: PPUSH
15100: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
15104: LD_INT 10
15106: PPUSH
15107: CALL_OW 67
// Say ( guyB , D1-B-20 ) ;
15111: LD_EXP 38
15115: PPUSH
15116: LD_STRING D1-B-20
15118: PPUSH
15119: CALL_OW 88
// Say ( guyA , D1-A-21 ) ;
15123: LD_EXP 37
15127: PPUSH
15128: LD_STRING D1-A-21
15130: PPUSH
15131: CALL_OW 88
// Say ( guyB , D1-B-21 ) ;
15135: LD_EXP 38
15139: PPUSH
15140: LD_STRING D1-B-21
15142: PPUSH
15143: CALL_OW 88
// Say ( guyA , D1-A-22 ) ;
15147: LD_EXP 37
15151: PPUSH
15152: LD_STRING D1-A-22
15154: PPUSH
15155: CALL_OW 88
// Say ( guyB , D1-B-22 ) ;
15159: LD_EXP 38
15163: PPUSH
15164: LD_STRING D1-B-22
15166: PPUSH
15167: CALL_OW 88
// Say ( guyA , D1-A-23 ) ;
15171: LD_EXP 37
15175: PPUSH
15176: LD_STRING D1-A-23
15178: PPUSH
15179: CALL_OW 88
// Say ( guyB , D1-B-23 ) ;
15183: LD_EXP 38
15187: PPUSH
15188: LD_STRING D1-B-23
15190: PPUSH
15191: CALL_OW 88
// Say ( guyA , D1-A-24 ) ;
15195: LD_EXP 37
15199: PPUSH
15200: LD_STRING D1-A-24
15202: PPUSH
15203: CALL_OW 88
// InGameOff ;
15207: CALL_OW 9
// ChangeMissionObjectives ( M_main ) ;
15211: LD_STRING M_main
15213: PPUSH
15214: CALL_OW 337
// ChangeSideFog ( 4 , 1 ) ;
15218: LD_INT 4
15220: PPUSH
15221: LD_INT 1
15223: PPUSH
15224: CALL_OW 343
// game_status := true ;
15228: LD_ADDR_EXP 28
15232: PUSH
15233: LD_INT 1
15235: ST_TO_ADDR
// end ;
15236: LD_VAR 0 1
15240: RET
// every 0 0$01 trigger GetLabs ( 1 ) > 0 do
15241: LD_INT 1
15243: PPUSH
15244: CALL 6928 0 1
15248: PUSH
15249: LD_INT 0
15251: GREATER
15252: IFFALSE 15354
15254: GO 15256
15256: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15257: LD_INT 35
15259: PPUSH
15260: CALL_OW 67
// until BuildingStatus ( GetLabs ( 1 ) [ 1 ] ) <> bs_build ;
15264: LD_INT 1
15266: PPUSH
15267: CALL 6928 0 1
15271: PUSH
15272: LD_INT 1
15274: ARRAY
15275: PPUSH
15276: CALL_OW 461
15280: PUSH
15281: LD_INT 1
15283: NONEQUAL
15284: IFFALSE 15257
// if IsLive ( guyA ) and IsLive ( guyB ) and not helps_arrive then
15286: LD_EXP 37
15290: PPUSH
15291: CALL_OW 300
15295: PUSH
15296: LD_EXP 38
15300: PPUSH
15301: CALL_OW 300
15305: AND
15306: PUSH
15307: LD_EXP 29
15311: NOT
15312: AND
15313: IFFALSE 15339
// begin Say ( guyA , DL-A-1 ) ;
15315: LD_EXP 37
15319: PPUSH
15320: LD_STRING DL-A-1
15322: PPUSH
15323: CALL_OW 88
// Say ( guyB , DL-B-1 ) ;
15327: LD_EXP 38
15331: PPUSH
15332: LD_STRING DL-B-1
15334: PPUSH
15335: CALL_OW 88
// end ; if not helps_can_arrive then
15339: LD_EXP 30
15343: NOT
15344: IFFALSE 15354
// helps_can_arrive := true ;
15346: LD_ADDR_EXP 30
15350: PUSH
15351: LD_INT 1
15353: ST_TO_ADDR
// end ;
15354: END
// every 0 0$01 trigger GetLabs ( 1 ) > 0 and IsLive ( guyA ) and IsLive ( guyB ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman ] ] ) = 0 and See ( 1 , NearestUnitToUnit ( FilterAllUnits ( [ f_class , class_apeman ] ) , guyA ) ) do
15355: LD_INT 1
15357: PPUSH
15358: CALL 6928 0 1
15362: PUSH
15363: LD_INT 0
15365: GREATER
15366: PUSH
15367: LD_EXP 37
15371: PPUSH
15372: CALL_OW 300
15376: AND
15377: PUSH
15378: LD_EXP 38
15382: PPUSH
15383: CALL_OW 300
15387: AND
15388: PUSH
15389: LD_INT 22
15391: PUSH
15392: LD_INT 1
15394: PUSH
15395: EMPTY
15396: LIST
15397: LIST
15398: PUSH
15399: LD_INT 25
15401: PUSH
15402: LD_INT 12
15404: PUSH
15405: EMPTY
15406: LIST
15407: LIST
15408: PUSH
15409: EMPTY
15410: LIST
15411: LIST
15412: PPUSH
15413: CALL_OW 69
15417: PUSH
15418: LD_INT 0
15420: EQUAL
15421: AND
15422: PUSH
15423: LD_INT 1
15425: PPUSH
15426: LD_INT 25
15428: PUSH
15429: LD_INT 12
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PPUSH
15436: CALL_OW 69
15440: PPUSH
15441: LD_EXP 37
15445: PPUSH
15446: CALL_OW 74
15450: PPUSH
15451: CALL_OW 292
15455: AND
15456: IFFALSE 15497
15458: GO 15460
15460: DISABLE
// begin Say ( guyA , DA-A-1 ) ;
15461: LD_EXP 37
15465: PPUSH
15466: LD_STRING DA-A-1
15468: PPUSH
15469: CALL_OW 88
// Say ( guyB , DA-B-1 ) ;
15473: LD_EXP 38
15477: PPUSH
15478: LD_STRING DA-B-1
15480: PPUSH
15481: CALL_OW 88
// Say ( guyA , DA-A-2 ) ;
15485: LD_EXP 37
15489: PPUSH
15490: LD_STRING DA-A-2
15492: PPUSH
15493: CALL_OW 88
// end ;
15497: END
// every 0 0$01 trigger game_status and GetDistUnitArea ( guyA , forest_path ) < 7 do
15498: LD_EXP 28
15502: PUSH
15503: LD_EXP 37
15507: PPUSH
15508: LD_INT 6
15510: PPUSH
15511: CALL_OW 299
15515: PUSH
15516: LD_INT 7
15518: LESS
15519: AND
15520: IFFALSE 15573
15522: GO 15524
15524: DISABLE
// begin CenterNowOnXY ( 117 , 50 ) ;
15525: LD_INT 117
15527: PPUSH
15528: LD_INT 50
15530: PPUSH
15531: CALL_OW 86
// Say ( GetHuman ( 1 ) [ 2 ] , D5-A-1 ) ;
15535: LD_INT 1
15537: PPUSH
15538: CALL 10669 0 1
15542: PUSH
15543: LD_INT 2
15545: ARRAY
15546: PPUSH
15547: LD_STRING D5-A-1
15549: PPUSH
15550: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D5-B-1 ) ;
15554: LD_INT 1
15556: PPUSH
15557: CALL 10669 0 1
15561: PUSH
15562: LD_INT 1
15564: ARRAY
15565: PPUSH
15566: LD_STRING D5-B-1
15568: PPUSH
15569: CALL_OW 88
// end ;
15573: END
// every 0 0$01 trigger FilterUnitsInArea ( river , [ f_side , 1 ] ) > 0 do
15574: LD_INT 7
15576: PPUSH
15577: LD_INT 22
15579: PUSH
15580: LD_INT 1
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: PPUSH
15587: CALL_OW 70
15591: PUSH
15592: LD_INT 0
15594: GREATER
15595: IFFALSE 15740
15597: GO 15599
15599: DISABLE
// begin Wait ( 0 0$03 ) ;
15600: LD_INT 105
15602: PPUSH
15603: CALL_OW 67
// DialogueOn ;
15607: CALL_OW 6
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-1 ) ;
15611: LD_INT 1
15613: PPUSH
15614: CALL 10669 0 1
15618: PUSH
15619: LD_INT 1
15621: ARRAY
15622: PPUSH
15623: LD_STRING D6-A-1
15625: PPUSH
15626: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-1 ) ;
15630: LD_INT 1
15632: PPUSH
15633: CALL 10669 0 1
15637: PUSH
15638: LD_INT 2
15640: ARRAY
15641: PPUSH
15642: LD_STRING D6-B-1
15644: PPUSH
15645: CALL_OW 88
// PlaceSeeing ( 95 , 8 , 1 , 20 ) ;
15649: LD_INT 95
15651: PPUSH
15652: LD_INT 8
15654: PPUSH
15655: LD_INT 1
15657: PPUSH
15658: LD_INT 20
15660: PPUSH
15661: CALL_OW 330
// DWait ( 0 0$0.3 ) ;
15665: LD_INT 10
15667: PPUSH
15668: CALL_OW 68
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-2 ) ;
15672: LD_INT 1
15674: PPUSH
15675: CALL 10669 0 1
15679: PUSH
15680: LD_INT 1
15682: ARRAY
15683: PPUSH
15684: LD_STRING D6-A-2
15686: PPUSH
15687: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D6-B-2 ) ;
15691: LD_INT 1
15693: PPUSH
15694: CALL 10669 0 1
15698: PUSH
15699: LD_INT 2
15701: ARRAY
15702: PPUSH
15703: LD_STRING D6-B-2
15705: PPUSH
15706: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 1 ] , D6-A-3 ) ;
15710: LD_INT 1
15712: PPUSH
15713: CALL 10669 0 1
15717: PUSH
15718: LD_INT 1
15720: ARRAY
15721: PPUSH
15722: LD_STRING D6-A-3
15724: PPUSH
15725: CALL_OW 88
// DialogueOff ;
15729: CALL_OW 7
// ChangeMissionObjectives ( M_base ) ;
15733: LD_STRING M_base
15735: PPUSH
15736: CALL_OW 337
// end ;
15740: END
// every 0 0$01 trigger not helps_arrive and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) > 0 do
15741: LD_EXP 29
15745: NOT
15746: PUSH
15747: LD_INT 22
15749: PUSH
15750: LD_INT 3
15752: PUSH
15753: EMPTY
15754: LIST
15755: LIST
15756: PUSH
15757: LD_INT 21
15759: PUSH
15760: LD_INT 2
15762: PUSH
15763: EMPTY
15764: LIST
15765: LIST
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PPUSH
15771: CALL_OW 69
15775: PUSH
15776: LD_INT 0
15778: GREATER
15779: AND
15780: IFFALSE 15913
15782: GO 15784
15784: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15785: LD_INT 35
15787: PPUSH
15788: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) , GetHuman ( 1 ) [ 1 ] ) , GetHuman ( 1 ) [ 1 ] ) < 7 ;
15792: LD_INT 22
15794: PUSH
15795: LD_INT 3
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: LD_INT 21
15804: PUSH
15805: LD_INT 2
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PPUSH
15816: CALL_OW 69
15820: PPUSH
15821: LD_INT 1
15823: PPUSH
15824: CALL 10669 0 1
15828: PUSH
15829: LD_INT 1
15831: ARRAY
15832: PPUSH
15833: CALL_OW 74
15837: PPUSH
15838: LD_INT 1
15840: PPUSH
15841: CALL 10669 0 1
15845: PUSH
15846: LD_INT 1
15848: ARRAY
15849: PPUSH
15850: CALL_OW 296
15854: PUSH
15855: LD_INT 7
15857: LESS
15858: IFFALSE 15785
// Say ( GetHuman ( 1 ) [ 1 ] , DR-A-1 ) ;
15860: LD_INT 1
15862: PPUSH
15863: CALL 10669 0 1
15867: PUSH
15868: LD_INT 1
15870: ARRAY
15871: PPUSH
15872: LD_STRING DR-A-1
15874: PPUSH
15875: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , DR-B-1 ) ;
15879: LD_INT 1
15881: PPUSH
15882: CALL 10669 0 1
15886: PUSH
15887: LD_INT 2
15889: ARRAY
15890: PPUSH
15891: LD_STRING DR-B-1
15893: PPUSH
15894: CALL_OW 88
// Wait ( 3 3$00 ) ;
15898: LD_INT 6300
15900: PPUSH
15901: CALL_OW 67
// ru_spotted := true ;
15905: LD_ADDR_EXP 15
15909: PUSH
15910: LD_INT 1
15912: ST_TO_ADDR
// end ;
15913: END
// every 0 0$01 trigger not IsLive ( us_dep1 ) do
15914: LD_INT 35
15916: PPUSH
15917: CALL_OW 300
15921: NOT
15922: IFFALSE 15946
15924: GO 15926
15926: DISABLE
// Say ( GetHuman ( 1 ) [ 1 ] , DDR-A-1 ) ;
15927: LD_INT 1
15929: PPUSH
15930: CALL 10669 0 1
15934: PUSH
15935: LD_INT 1
15937: ARRAY
15938: PPUSH
15939: LD_STRING DDR-A-1
15941: PPUSH
15942: CALL_OW 88
15946: END
// every 0 0$05 trigger GetBuilding ( 1 , b_siberite_mine ) do
15947: LD_INT 1
15949: PPUSH
15950: LD_INT 30
15952: PPUSH
15953: CALL 6777 0 2
15957: IFFALSE 16039
15959: GO 15961
15961: DISABLE
// begin repeat Wait ( 0 0$01 ) ;
15962: LD_INT 35
15964: PPUSH
15965: CALL_OW 67
// until BuildingStatus ( GetBuilding ( 1 , b_siberite_mine ) [ 1 ] ) <> bs_build ;
15969: LD_INT 1
15971: PPUSH
15972: LD_INT 30
15974: PPUSH
15975: CALL 6777 0 2
15979: PUSH
15980: LD_INT 1
15982: ARRAY
15983: PPUSH
15984: CALL_OW 461
15988: PUSH
15989: LD_INT 1
15991: NONEQUAL
15992: IFFALSE 15962
// Say ( GetHuman ( 1 ) [ 1 ] , D8-A-1 ) ;
15994: LD_INT 1
15996: PPUSH
15997: CALL 10669 0 1
16001: PUSH
16002: LD_INT 1
16004: ARRAY
16005: PPUSH
16006: LD_STRING D8-A-1
16008: PPUSH
16009: CALL_OW 88
// Say ( GetHuman ( 1 ) [ 2 ] , D8-B-1 ) ;
16013: LD_INT 1
16015: PPUSH
16016: CALL 10669 0 1
16020: PUSH
16021: LD_INT 2
16023: ARRAY
16024: PPUSH
16025: LD_STRING D8-B-1
16027: PPUSH
16028: CALL_OW 88
// ChangeMissionObjectives ( M_mineok ) ;
16032: LD_STRING M_mineok
16034: PPUSH
16035: CALL_OW 337
// end ;
16039: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) > 1 or ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) = 1 and not IsLive ( us_dep1 ) ) do
16040: LD_INT 22
16042: PUSH
16043: LD_INT 1
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: PUSH
16050: LD_INT 30
16052: PUSH
16053: LD_INT 0
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: PUSH
16060: LD_INT 3
16062: PUSH
16063: LD_INT 57
16065: PUSH
16066: EMPTY
16067: LIST
16068: PUSH
16069: EMPTY
16070: LIST
16071: LIST
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: LIST
16077: PPUSH
16078: CALL_OW 69
16082: PUSH
16083: LD_INT 1
16085: GREATER
16086: PUSH
16087: LD_INT 22
16089: PUSH
16090: LD_INT 1
16092: PUSH
16093: EMPTY
16094: LIST
16095: LIST
16096: PUSH
16097: LD_INT 30
16099: PUSH
16100: LD_INT 0
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PUSH
16107: LD_INT 3
16109: PUSH
16110: LD_INT 57
16112: PUSH
16113: EMPTY
16114: LIST
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: PUSH
16120: EMPTY
16121: LIST
16122: LIST
16123: LIST
16124: PPUSH
16125: CALL_OW 69
16129: PUSH
16130: LD_INT 1
16132: EQUAL
16133: PUSH
16134: LD_INT 35
16136: PPUSH
16137: CALL_OW 300
16141: NOT
16142: AND
16143: OR
16144: IFFALSE 16196
16146: GO 16148
16148: DISABLE
// begin Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , D7-A-1 ) ;
16149: LD_INT 22
16151: PUSH
16152: LD_INT 1
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: PUSH
16159: LD_INT 25
16161: PUSH
16162: LD_INT 2
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PPUSH
16173: CALL_OW 69
16177: PUSH
16178: LD_INT 1
16180: ARRAY
16181: PPUSH
16182: LD_STRING D7-A-1
16184: PPUSH
16185: CALL_OW 88
// ChangeMissionObjectives ( M_baseok ) ;
16189: LD_STRING M_baseok
16191: PPUSH
16192: CALL_OW 337
// end ;
16196: END
// every 0 0$01 trigger mine_ck do
16197: LD_EXP 34
16201: IFFALSE 16232
16203: GO 16205
16205: DISABLE
// begin Say ( GetHuman ( 1 ) [ 1 ] , D9-A-1 ) ;
16206: LD_INT 1
16208: PPUSH
16209: CALL 10669 0 1
16213: PUSH
16214: LD_INT 1
16216: ARRAY
16217: PPUSH
16218: LD_STRING D9-A-1
16220: PPUSH
16221: CALL_OW 88
// ChangeMissionObjectives ( M_minedest ) ;
16225: LD_STRING M_minedest
16227: PPUSH
16228: CALL_OW 337
// end ;
16232: END
// every 7 7$00 trigger game_status do var time , i , un , r , to_veh ;
16233: LD_EXP 28
16237: IFFALSE 16743
16239: GO 16241
16241: DISABLE
16242: LD_INT 0
16244: PPUSH
16245: PPUSH
16246: PPUSH
16247: PPUSH
16248: PPUSH
// begin AddBetaSquad ( Difficulty ) ;
16249: LD_OWVAR 67
16253: PPUSH
16254: CALL 12570 0 1
// if not helps_can_arrive then
16258: LD_EXP 30
16262: NOT
16263: IFFALSE 16291
// begin SayRadio ( Beta_Squad [ 1 ] , DB-Delay ) ;
16265: LD_EXP 39
16269: PUSH
16270: LD_INT 1
16272: ARRAY
16273: PPUSH
16274: LD_STRING DB-Delay
16276: PPUSH
16277: CALL_OW 94
// time := 10 10$00 ;
16281: LD_ADDR_VAR 0 1
16285: PUSH
16286: LD_INT 21000
16288: ST_TO_ADDR
// end else
16289: GO 16299
// time := 3 3$00 ;
16291: LD_ADDR_VAR 0 1
16295: PUSH
16296: LD_INT 6300
16298: ST_TO_ADDR
// repeat begin time := time - 0 0$01 ;
16299: LD_ADDR_VAR 0 1
16303: PUSH
16304: LD_VAR 0 1
16308: PUSH
16309: LD_INT 35
16311: MINUS
16312: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
16313: LD_INT 35
16315: PPUSH
16316: CALL_OW 67
// end until time = 0 0$00 ;
16320: LD_VAR 0 1
16324: PUSH
16325: LD_INT 0
16327: EQUAL
16328: IFFALSE 16299
// helps_arrive := true ;
16330: LD_ADDR_EXP 29
16334: PUSH
16335: LD_INT 1
16337: ST_TO_ADDR
// if IsLive ( guyA ) then
16338: LD_EXP 37
16342: PPUSH
16343: CALL_OW 300
16347: IFFALSE 16361
// r := guyA else
16349: LD_ADDR_VAR 0 4
16353: PUSH
16354: LD_EXP 37
16358: ST_TO_ADDR
16359: GO 16371
// r := guyB ;
16361: LD_ADDR_VAR 0 4
16365: PUSH
16366: LD_EXP 38
16370: ST_TO_ADDR
// SayRadio ( Beta_Squad [ 1 ] , D2-A-1 ) ;
16371: LD_EXP 39
16375: PUSH
16376: LD_INT 1
16378: ARRAY
16379: PPUSH
16380: LD_STRING D2-A-1
16382: PPUSH
16383: CALL_OW 94
// Say ( r , D2-B-1 ) ;
16387: LD_VAR 0 4
16391: PPUSH
16392: LD_STRING D2-B-1
16394: PPUSH
16395: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-2 ) ;
16399: LD_EXP 39
16403: PUSH
16404: LD_INT 1
16406: ARRAY
16407: PPUSH
16408: LD_STRING D2-A-2
16410: PPUSH
16411: CALL_OW 94
// Say ( r , D2-B-2 ) ;
16415: LD_VAR 0 4
16419: PPUSH
16420: LD_STRING D2-B-2
16422: PPUSH
16423: CALL_OW 88
// SayRadio ( Beta_Squad [ 1 ] , D2-A-3 ) ;
16427: LD_EXP 39
16431: PUSH
16432: LD_INT 1
16434: ARRAY
16435: PPUSH
16436: LD_STRING D2-A-3
16438: PPUSH
16439: CALL_OW 94
// Say ( r , D2-B-3 ) ;
16443: LD_VAR 0 4
16447: PPUSH
16448: LD_STRING D2-B-3
16450: PPUSH
16451: CALL_OW 88
// to_veh := [ ] ;
16455: LD_ADDR_VAR 0 5
16459: PUSH
16460: EMPTY
16461: ST_TO_ADDR
// for i = 1 to Beta_Squad do
16462: LD_ADDR_VAR 0 2
16466: PUSH
16467: DOUBLE
16468: LD_INT 1
16470: DEC
16471: ST_TO_ADDR
16472: LD_EXP 39
16476: PUSH
16477: FOR_TO
16478: IFFALSE 16741
// begin if GetTag ( Beta_Squad [ i ] ) = 3 then
16480: LD_EXP 39
16484: PUSH
16485: LD_VAR 0 2
16489: ARRAY
16490: PPUSH
16491: CALL_OW 110
16495: PUSH
16496: LD_INT 3
16498: EQUAL
16499: IFFALSE 16525
// to_veh := to_veh ^ Beta_Squad [ i ] else
16501: LD_ADDR_VAR 0 5
16505: PUSH
16506: LD_VAR 0 5
16510: PUSH
16511: LD_EXP 39
16515: PUSH
16516: LD_VAR 0 2
16520: ARRAY
16521: ADD
16522: ST_TO_ADDR
16523: GO 16650
// if GetTag ( Beta_Squad [ i ] ) = 5 then
16525: LD_EXP 39
16529: PUSH
16530: LD_VAR 0 2
16534: ARRAY
16535: PPUSH
16536: CALL_OW 110
16540: PUSH
16541: LD_INT 5
16543: EQUAL
16544: IFFALSE 16629
// begin SetDir ( Beta_Squad [ i ] , 4 ) ;
16546: LD_EXP 39
16550: PUSH
16551: LD_VAR 0 2
16555: ARRAY
16556: PPUSH
16557: LD_INT 4
16559: PPUSH
16560: CALL_OW 233
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16564: LD_EXP 39
16568: PUSH
16569: LD_VAR 0 2
16573: ARRAY
16574: PPUSH
16575: LD_INT 5
16577: PPUSH
16578: LD_INT 0
16580: PPUSH
16581: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Beta_Squad [ i ] ) ;
16585: LD_VAR 0 5
16589: PUSH
16590: LD_INT 1
16592: ARRAY
16593: PPUSH
16594: LD_EXP 39
16598: PUSH
16599: LD_VAR 0 2
16603: ARRAY
16604: PPUSH
16605: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16609: LD_ADDR_VAR 0 5
16613: PUSH
16614: LD_VAR 0 5
16618: PPUSH
16619: LD_INT 1
16621: PPUSH
16622: CALL_OW 3
16626: ST_TO_ADDR
// end else
16627: GO 16650
// PlaceUnitArea ( Beta_Squad [ i ] , road_vehicle , false ) ;
16629: LD_EXP 39
16633: PUSH
16634: LD_VAR 0 2
16638: ARRAY
16639: PPUSH
16640: LD_INT 5
16642: PPUSH
16643: LD_INT 0
16645: PPUSH
16646: CALL_OW 49
// ComMoveXY ( Beta_Squad [ i ] , 165 , 105 ) ;
16650: LD_EXP 39
16654: PUSH
16655: LD_VAR 0 2
16659: ARRAY
16660: PPUSH
16661: LD_INT 165
16663: PPUSH
16664: LD_INT 105
16666: PPUSH
16667: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16671: LD_INT 70
16673: PPUSH
16674: LD_INT 140
16676: PPUSH
16677: CALL_OW 12
16681: PPUSH
16682: CALL_OW 67
// SetSide ( Beta_Squad [ i ] , 1 ) ;
16686: LD_EXP 39
16690: PUSH
16691: LD_VAR 0 2
16695: ARRAY
16696: PPUSH
16697: LD_INT 1
16699: PPUSH
16700: CALL_OW 235
// if i = 1 then
16704: LD_VAR 0 2
16708: PUSH
16709: LD_INT 1
16711: EQUAL
16712: IFFALSE 16724
// CenterNowOnXY ( 168 , 109 ) ;
16714: LD_INT 168
16716: PPUSH
16717: LD_INT 109
16719: PPUSH
16720: CALL_OW 86
// ComStop ( Beta_Squad [ i ] ) ;
16724: LD_EXP 39
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: CALL_OW 141
// end ;
16739: GO 16477
16741: POP
16742: POP
// end ;
16743: PPOPN 5
16745: END
// every 0 0$10 trigger helps_arrive do var i , to_veh ;
16746: LD_EXP 29
16750: IFFALSE 17779
16752: GO 16754
16754: DISABLE
16755: LD_INT 0
16757: PPUSH
16758: PPUSH
// begin Wait ( 5 5$00 ) ;
16759: LD_INT 10500
16761: PPUSH
16762: CALL_OW 67
// AddGammaSquad ( Difficulty ) ;
16766: LD_OWVAR 67
16770: PPUSH
16771: CALL 13259 0 1
// to_veh := [ ] ;
16775: LD_ADDR_VAR 0 2
16779: PUSH
16780: EMPTY
16781: ST_TO_ADDR
// for i = 1 to Gamma_Squad do
16782: LD_ADDR_VAR 0 1
16786: PUSH
16787: DOUBLE
16788: LD_INT 1
16790: DEC
16791: ST_TO_ADDR
16792: LD_EXP 40
16796: PUSH
16797: FOR_TO
16798: IFFALSE 17026
// begin if GetTag ( Gamma_Squad [ i ] ) = 3 then
16800: LD_EXP 40
16804: PUSH
16805: LD_VAR 0 1
16809: ARRAY
16810: PPUSH
16811: CALL_OW 110
16815: PUSH
16816: LD_INT 3
16818: EQUAL
16819: IFFALSE 16845
// to_veh := to_veh ^ Gamma_Squad [ i ] else
16821: LD_ADDR_VAR 0 2
16825: PUSH
16826: LD_VAR 0 2
16830: PUSH
16831: LD_EXP 40
16835: PUSH
16836: LD_VAR 0 1
16840: ARRAY
16841: ADD
16842: ST_TO_ADDR
16843: GO 16970
// if GetTag ( Gamma_Squad [ i ] ) = 5 then
16845: LD_EXP 40
16849: PUSH
16850: LD_VAR 0 1
16854: ARRAY
16855: PPUSH
16856: CALL_OW 110
16860: PUSH
16861: LD_INT 5
16863: EQUAL
16864: IFFALSE 16949
// begin SetDir ( Gamma_Squad [ i ] , 4 ) ;
16866: LD_EXP 40
16870: PUSH
16871: LD_VAR 0 1
16875: ARRAY
16876: PPUSH
16877: LD_INT 4
16879: PPUSH
16880: CALL_OW 233
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16884: LD_EXP 40
16888: PUSH
16889: LD_VAR 0 1
16893: ARRAY
16894: PPUSH
16895: LD_INT 5
16897: PPUSH
16898: LD_INT 0
16900: PPUSH
16901: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Gamma_Squad [ i ] ) ;
16905: LD_VAR 0 2
16909: PUSH
16910: LD_INT 1
16912: ARRAY
16913: PPUSH
16914: LD_EXP 40
16918: PUSH
16919: LD_VAR 0 1
16923: ARRAY
16924: PPUSH
16925: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
16929: LD_ADDR_VAR 0 2
16933: PUSH
16934: LD_VAR 0 2
16938: PPUSH
16939: LD_INT 1
16941: PPUSH
16942: CALL_OW 3
16946: ST_TO_ADDR
// end else
16947: GO 16970
// PlaceUnitArea ( Gamma_Squad [ i ] , road_vehicle , false ) ;
16949: LD_EXP 40
16953: PUSH
16954: LD_VAR 0 1
16958: ARRAY
16959: PPUSH
16960: LD_INT 5
16962: PPUSH
16963: LD_INT 0
16965: PPUSH
16966: CALL_OW 49
// ComMoveXY ( Gamma_Squad [ i ] , 164 , 104 ) ;
16970: LD_EXP 40
16974: PUSH
16975: LD_VAR 0 1
16979: ARRAY
16980: PPUSH
16981: LD_INT 164
16983: PPUSH
16984: LD_INT 104
16986: PPUSH
16987: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
16991: LD_INT 70
16993: PPUSH
16994: LD_INT 140
16996: PPUSH
16997: CALL_OW 12
17001: PPUSH
17002: CALL_OW 67
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
17006: LD_EXP 40
17010: PUSH
17011: LD_VAR 0 1
17015: ARRAY
17016: PPUSH
17017: LD_INT 1
17019: PPUSH
17020: CALL_OW 235
// end ;
17024: GO 16797
17026: POP
17027: POP
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-1 ) ;
17028: LD_EXP 40
17032: PUSH
17033: LD_INT 1
17035: ARRAY
17036: PPUSH
17037: LD_STRING D3-A-1
17039: PPUSH
17040: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-1 ) ;
17044: LD_INT 1
17046: PPUSH
17047: CALL 10669 0 1
17051: PUSH
17052: LD_INT 1
17054: ARRAY
17055: PPUSH
17056: LD_STRING D3-B-1
17058: PPUSH
17059: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-2 ) ;
17063: LD_EXP 40
17067: PUSH
17068: LD_INT 1
17070: ARRAY
17071: PPUSH
17072: LD_STRING D3-A-2
17074: PPUSH
17075: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-2 ) ;
17079: LD_INT 1
17081: PPUSH
17082: CALL 10669 0 1
17086: PUSH
17087: LD_INT 1
17089: ARRAY
17090: PPUSH
17091: LD_STRING D3-B-2
17093: PPUSH
17094: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-3 ) ;
17098: LD_EXP 40
17102: PUSH
17103: LD_INT 1
17105: ARRAY
17106: PPUSH
17107: LD_STRING D3-A-3
17109: PPUSH
17110: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-3 ) ;
17114: LD_INT 1
17116: PPUSH
17117: CALL 10669 0 1
17121: PUSH
17122: LD_INT 1
17124: ARRAY
17125: PPUSH
17126: LD_STRING D3-B-3
17128: PPUSH
17129: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-4 ) ;
17133: LD_EXP 40
17137: PUSH
17138: LD_INT 1
17140: ARRAY
17141: PPUSH
17142: LD_STRING D3-A-4
17144: PPUSH
17145: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-4 ) ;
17149: LD_INT 1
17151: PPUSH
17152: CALL 10669 0 1
17156: PUSH
17157: LD_INT 1
17159: ARRAY
17160: PPUSH
17161: LD_STRING D3-B-4
17163: PPUSH
17164: CALL_OW 88
// SayRadio ( Gamma_Squad [ 1 ] , D3-A-5 ) ;
17168: LD_EXP 40
17172: PUSH
17173: LD_INT 1
17175: ARRAY
17176: PPUSH
17177: LD_STRING D3-A-5
17179: PPUSH
17180: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D3-B-5 ) ;
17184: LD_INT 1
17186: PPUSH
17187: CALL 10669 0 1
17191: PUSH
17192: LD_INT 1
17194: ARRAY
17195: PPUSH
17196: LD_STRING D3-B-5
17198: PPUSH
17199: CALL_OW 88
// for i = 1 to Gamma_Squad do
17203: LD_ADDR_VAR 0 1
17207: PUSH
17208: DOUBLE
17209: LD_INT 1
17211: DEC
17212: ST_TO_ADDR
17213: LD_EXP 40
17217: PUSH
17218: FOR_TO
17219: IFFALSE 17241
// SetSide ( Gamma_Squad [ i ] , 1 ) ;
17221: LD_EXP 40
17225: PUSH
17226: LD_VAR 0 1
17230: ARRAY
17231: PPUSH
17232: LD_INT 1
17234: PPUSH
17235: CALL_OW 235
17239: GO 17218
17241: POP
17242: POP
// Wait ( [ 3 3$00 , 5 5$00 , 5 5$30 ] [ Difficulty ] ) ;
17243: LD_INT 6300
17245: PUSH
17246: LD_INT 10500
17248: PUSH
17249: LD_INT 11550
17251: PUSH
17252: EMPTY
17253: LIST
17254: LIST
17255: LIST
17256: PUSH
17257: LD_OWVAR 67
17261: ARRAY
17262: PPUSH
17263: CALL_OW 67
// AddZetaSquad ;
17267: CALL 13988 0 0
// Wait ( 0 0$10 ) ;
17271: LD_INT 350
17273: PPUSH
17274: CALL_OW 67
// to_veh := [ ] ;
17278: LD_ADDR_VAR 0 2
17282: PUSH
17283: EMPTY
17284: ST_TO_ADDR
// for i = 1 to Zeta_Squad do
17285: LD_ADDR_VAR 0 1
17289: PUSH
17290: DOUBLE
17291: LD_INT 1
17293: DEC
17294: ST_TO_ADDR
17295: LD_EXP 41
17299: PUSH
17300: FOR_TO
17301: IFFALSE 17511
// begin if GetTag ( Zeta_Squad [ i ] ) = 3 then
17303: LD_EXP 41
17307: PUSH
17308: LD_VAR 0 1
17312: ARRAY
17313: PPUSH
17314: CALL_OW 110
17318: PUSH
17319: LD_INT 3
17321: EQUAL
17322: IFFALSE 17348
// to_veh := to_veh ^ Zeta_Squad [ i ] else
17324: LD_ADDR_VAR 0 2
17328: PUSH
17329: LD_VAR 0 2
17333: PUSH
17334: LD_EXP 41
17338: PUSH
17339: LD_VAR 0 1
17343: ARRAY
17344: ADD
17345: ST_TO_ADDR
17346: GO 17473
// if GetTag ( Zeta_Squad [ i ] ) = 5 then
17348: LD_EXP 41
17352: PUSH
17353: LD_VAR 0 1
17357: ARRAY
17358: PPUSH
17359: CALL_OW 110
17363: PUSH
17364: LD_INT 5
17366: EQUAL
17367: IFFALSE 17452
// begin SetDir ( Zeta_Squad [ i ] , 4 ) ;
17369: LD_EXP 41
17373: PUSH
17374: LD_VAR 0 1
17378: ARRAY
17379: PPUSH
17380: LD_INT 4
17382: PPUSH
17383: CALL_OW 233
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17387: LD_EXP 41
17391: PUSH
17392: LD_VAR 0 1
17396: ARRAY
17397: PPUSH
17398: LD_INT 5
17400: PPUSH
17401: LD_INT 0
17403: PPUSH
17404: CALL_OW 49
// PlaceHumanInUnit ( to_veh [ 1 ] , Zeta_Squad [ i ] ) ;
17408: LD_VAR 0 2
17412: PUSH
17413: LD_INT 1
17415: ARRAY
17416: PPUSH
17417: LD_EXP 41
17421: PUSH
17422: LD_VAR 0 1
17426: ARRAY
17427: PPUSH
17428: CALL_OW 52
// to_veh := Delete ( to_veh , 1 ) ;
17432: LD_ADDR_VAR 0 2
17436: PUSH
17437: LD_VAR 0 2
17441: PPUSH
17442: LD_INT 1
17444: PPUSH
17445: CALL_OW 3
17449: ST_TO_ADDR
// end else
17450: GO 17473
// PlaceUnitArea ( Zeta_Squad [ i ] , road_vehicle , false ) ;
17452: LD_EXP 41
17456: PUSH
17457: LD_VAR 0 1
17461: ARRAY
17462: PPUSH
17463: LD_INT 5
17465: PPUSH
17466: LD_INT 0
17468: PPUSH
17469: CALL_OW 49
// ComMoveXY ( Zeta_Squad [ i ] , 165 , 105 ) ;
17473: LD_EXP 41
17477: PUSH
17478: LD_VAR 0 1
17482: ARRAY
17483: PPUSH
17484: LD_INT 165
17486: PPUSH
17487: LD_INT 105
17489: PPUSH
17490: CALL_OW 111
// Wait ( Rand ( 0 0$02 , 0 0$04 ) ) ;
17494: LD_INT 70
17496: PPUSH
17497: LD_INT 140
17499: PPUSH
17500: CALL_OW 12
17504: PPUSH
17505: CALL_OW 67
// end ;
17509: GO 17300
17511: POP
17512: POP
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-1 ) ;
17513: LD_EXP 41
17517: PUSH
17518: LD_INT 1
17520: ARRAY
17521: PPUSH
17522: LD_STRING D4-A-1
17524: PPUSH
17525: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-1 ) ;
17529: LD_INT 1
17531: PPUSH
17532: CALL 10669 0 1
17536: PUSH
17537: LD_INT 1
17539: ARRAY
17540: PPUSH
17541: LD_STRING D4-B-1
17543: PPUSH
17544: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-2 ) ;
17548: LD_EXP 41
17552: PUSH
17553: LD_INT 1
17555: ARRAY
17556: PPUSH
17557: LD_STRING D4-A-2
17559: PPUSH
17560: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-2 ) ;
17564: LD_INT 1
17566: PPUSH
17567: CALL 10669 0 1
17571: PUSH
17572: LD_INT 1
17574: ARRAY
17575: PPUSH
17576: LD_STRING D4-B-2
17578: PPUSH
17579: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-3 ) ;
17583: LD_EXP 41
17587: PUSH
17588: LD_INT 1
17590: ARRAY
17591: PPUSH
17592: LD_STRING D4-A-3
17594: PPUSH
17595: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-3 ) ;
17599: LD_INT 1
17601: PPUSH
17602: CALL 10669 0 1
17606: PUSH
17607: LD_INT 1
17609: ARRAY
17610: PPUSH
17611: LD_STRING D4-B-3
17613: PPUSH
17614: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-4 ) ;
17618: LD_EXP 41
17622: PUSH
17623: LD_INT 1
17625: ARRAY
17626: PPUSH
17627: LD_STRING D4-A-4
17629: PPUSH
17630: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-4 ) ;
17634: LD_INT 1
17636: PPUSH
17637: CALL 10669 0 1
17641: PUSH
17642: LD_INT 1
17644: ARRAY
17645: PPUSH
17646: LD_STRING D4-B-4
17648: PPUSH
17649: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-5 ) ;
17653: LD_EXP 41
17657: PUSH
17658: LD_INT 1
17660: ARRAY
17661: PPUSH
17662: LD_STRING D4-A-5
17664: PPUSH
17665: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-5 ) ;
17669: LD_INT 1
17671: PPUSH
17672: CALL 10669 0 1
17676: PUSH
17677: LD_INT 1
17679: ARRAY
17680: PPUSH
17681: LD_STRING D4-B-5
17683: PPUSH
17684: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-6 ) ;
17688: LD_EXP 41
17692: PUSH
17693: LD_INT 1
17695: ARRAY
17696: PPUSH
17697: LD_STRING D4-A-6
17699: PPUSH
17700: CALL_OW 94
// Say ( GetHuman ( 1 ) [ 1 ] , D4-B-6 ) ;
17704: LD_INT 1
17706: PPUSH
17707: CALL 10669 0 1
17711: PUSH
17712: LD_INT 1
17714: ARRAY
17715: PPUSH
17716: LD_STRING D4-B-6
17718: PPUSH
17719: CALL_OW 88
// SayRadio ( Zeta_Squad [ 1 ] , D4-A-7 ) ;
17723: LD_EXP 41
17727: PUSH
17728: LD_INT 1
17730: ARRAY
17731: PPUSH
17732: LD_STRING D4-A-7
17734: PPUSH
17735: CALL_OW 94
// for i = 1 to Zeta_Squad do
17739: LD_ADDR_VAR 0 1
17743: PUSH
17744: DOUBLE
17745: LD_INT 1
17747: DEC
17748: ST_TO_ADDR
17749: LD_EXP 41
17753: PUSH
17754: FOR_TO
17755: IFFALSE 17777
// SetSide ( Zeta_Squad [ i ] , 1 ) ;
17757: LD_EXP 41
17761: PUSH
17762: LD_VAR 0 1
17766: ARRAY
17767: PPUSH
17768: LD_INT 1
17770: PPUSH
17771: CALL_OW 235
17775: GO 17754
17777: POP
17778: POP
// end ;
17779: PPOPN 2
17781: END
// every 0 0$01 trigger FilterUnitsInArea ( rus_spot , [ f_side , your_side ] ) > 0 do
17782: LD_INT 11
17784: PPUSH
17785: LD_INT 22
17787: PUSH
17788: LD_OWVAR 2
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: PPUSH
17797: CALL_OW 70
17801: PUSH
17802: LD_INT 0
17804: GREATER
17805: IFFALSE 17830
17807: GO 17809
17809: DISABLE
// begin Say ( guyA , D10-A-1 ) ;
17810: LD_EXP 37
17814: PPUSH
17815: LD_STRING D10-A-1
17817: PPUSH
17818: CALL_OW 88
// ru_spotted := true ;
17822: LD_ADDR_EXP 15
17826: PUSH
17827: LD_INT 1
17829: ST_TO_ADDR
// end ;
17830: END
// every 0 0$01 trigger IsDead ( guyA ) or IsDead ( guyB ) do
17831: LD_EXP 37
17835: PPUSH
17836: CALL_OW 301
17840: PUSH
17841: LD_EXP 38
17845: PPUSH
17846: CALL_OW 301
17850: OR
17851: IFFALSE 17863
17853: GO 17855
17855: DISABLE
// begin YouLost ( DieP ) ;
17856: LD_STRING DieP
17858: PPUSH
17859: CALL_OW 104
// end ;
17863: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , us_siberium_rocket ] ) do
17864: LD_INT 34
17866: PUSH
17867: LD_INT 8
17869: PUSH
17870: EMPTY
17871: LIST
17872: LIST
17873: PPUSH
17874: CALL_OW 69
17878: IFFALSE 17891
17880: GO 17882
17882: DISABLE
// sib_bomb_constructed := true ;
17883: LD_ADDR_EXP 35
17887: PUSH
17888: LD_INT 1
17890: ST_TO_ADDR
17891: END
// every 0 0$01 trigger game_status and FilterAllUnits ( [ f_side , 3 ] ) = 0 do var i ;
17892: LD_EXP 28
17896: PUSH
17897: LD_INT 22
17899: PUSH
17900: LD_INT 3
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PPUSH
17907: CALL_OW 69
17911: PUSH
17912: LD_INT 0
17914: EQUAL
17915: AND
17916: IFFALSE 18105
17918: GO 17920
17920: DISABLE
17921: LD_INT 0
17923: PPUSH
// begin game_status := false ;
17924: LD_ADDR_EXP 28
17928: PUSH
17929: LD_INT 0
17931: ST_TO_ADDR
// if Difficulty = 3 then
17932: LD_OWVAR 67
17936: PUSH
17937: LD_INT 3
17939: EQUAL
17940: IFFALSE 17949
// SetAchievement ( ACH_HARD ) ;
17942: LD_STRING ACH_HARD
17944: PPUSH
17945: CALL_OW 543
// if ( ( tick / 35 ) / 60 ) < [ 70 , 60 , 50 ] [ Difficulty ] then
17949: LD_OWVAR 1
17953: PUSH
17954: LD_INT 35
17956: DIVREAL
17957: PUSH
17958: LD_INT 60
17960: DIVREAL
17961: PUSH
17962: LD_INT 70
17964: PUSH
17965: LD_INT 60
17967: PUSH
17968: LD_INT 50
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: LIST
17975: PUSH
17976: LD_OWVAR 67
17980: ARRAY
17981: LESS
17982: IFFALSE 17996
// AddMedal ( play , 1 ) else
17984: LD_STRING play
17986: PPUSH
17987: LD_INT 1
17989: PPUSH
17990: CALL_OW 101
17994: GO 18007
// AddMedal ( play , - 1 ) ;
17996: LD_STRING play
17998: PPUSH
17999: LD_INT 1
18001: NEG
18002: PPUSH
18003: CALL_OW 101
// if sib_bomb_constructed then
18007: LD_EXP 35
18011: IFFALSE 18025
// AddMedal ( sibbomb , 1 ) else
18013: LD_STRING sibbomb
18015: PPUSH
18016: LD_INT 1
18018: PPUSH
18019: CALL_OW 101
18023: GO 18036
// AddMedal ( sibbomb , - 1 ) ;
18025: LD_STRING sibbomb
18027: PPUSH
18028: LD_INT 1
18030: NEG
18031: PPUSH
18032: CALL_OW 101
// if mine_constructed and not mine_ck then
18036: LD_EXP 36
18040: PUSH
18041: LD_EXP 34
18045: NOT
18046: AND
18047: IFFALSE 18059
// AddMedal ( mine , 1 ) ;
18049: LD_STRING mine
18051: PPUSH
18052: LD_INT 1
18054: PPUSH
18055: CALL_OW 101
// if mine_ck then
18059: LD_EXP 34
18063: IFFALSE 18076
// AddMedal ( mine , - 1 ) ;
18065: LD_STRING mine
18067: PPUSH
18068: LD_INT 1
18070: NEG
18071: PPUSH
18072: CALL_OW 101
// if not mine_constructed then
18076: LD_EXP 36
18080: NOT
18081: IFFALSE 18094
// AddMedal ( mine , - 2 ) ;
18083: LD_STRING mine
18085: PPUSH
18086: LD_INT 2
18088: NEG
18089: PPUSH
18090: CALL_OW 101
// GiveMedals ( Main ) ;
18094: LD_STRING Main
18096: PPUSH
18097: CALL_OW 102
// YouWin ;
18101: CALL_OW 103
// end ; end_of_file
18105: PPOPN 1
18107: END
// every 0 0$03 trigger game_status do var time ;
18108: LD_EXP 28
18112: IFFALSE 18277
18114: GO 18116
18116: DISABLE
18117: LD_INT 0
18119: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 1 1$00 ] [ Difficulty ] ;
18120: LD_ADDR_VAR 0 1
18124: PUSH
18125: LD_INT 1050
18127: PUSH
18128: LD_INT 1575
18130: PUSH
18131: LD_INT 2100
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: LD_OWVAR 67
18143: ARRAY
18144: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$12 ) ) ;
18145: LD_VAR 0 1
18149: PUSH
18150: LD_INT 0
18152: PPUSH
18153: LD_INT 420
18155: PPUSH
18156: CALL_OW 12
18160: PLUS
18161: PPUSH
18162: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
18166: LD_INT 1
18168: PPUSH
18169: LD_INT 5
18171: PPUSH
18172: CALL_OW 12
18176: PPUSH
18177: LD_INT 1
18179: PPUSH
18180: CALL_OW 57
// Wait ( Rand ( 0 0$03 , 0 0$30 ) ) ;
18184: LD_INT 105
18186: PPUSH
18187: LD_INT 1050
18189: PPUSH
18190: CALL_OW 12
18194: PPUSH
18195: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 148 , 107 , 20 , true ) ;
18199: LD_INT 1
18201: PPUSH
18202: LD_INT 5
18204: PPUSH
18205: CALL_OW 12
18209: PPUSH
18210: LD_INT 148
18212: PPUSH
18213: LD_INT 107
18215: PPUSH
18216: LD_INT 20
18218: PPUSH
18219: LD_INT 1
18221: PPUSH
18222: CALL_OW 56
// if tick mod [ 21 21$00 , 18 18$00 , 16 16$00 ] [ Difficulty ] then
18226: LD_OWVAR 1
18230: PUSH
18231: LD_INT 44100
18233: PUSH
18234: LD_INT 37800
18236: PUSH
18237: LD_INT 33600
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: LIST
18244: PUSH
18245: LD_OWVAR 67
18249: ARRAY
18250: MOD
18251: IFFALSE 18267
// time := time + 0 0$20 ;
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: LD_VAR 0 1
18262: PUSH
18263: LD_INT 700
18265: PLUS
18266: ST_TO_ADDR
// end until game_status = false ;
18267: LD_EXP 28
18271: PUSH
18272: LD_INT 0
18274: EQUAL
18275: IFFALSE 18145
// end ;
18277: PPOPN 1
18279: END
// every 0 0$03 trigger game_status do var time ;
18280: LD_EXP 28
18284: IFFALSE 18438
18286: GO 18288
18288: DISABLE
18289: LD_INT 0
18291: PPUSH
// begin time := [ 0 0$20 , 0 0$25 , 0 0$40 ] [ Difficulty ] ;
18292: LD_ADDR_VAR 0 1
18296: PUSH
18297: LD_INT 700
18299: PUSH
18300: LD_INT 875
18302: PUSH
18303: LD_INT 1400
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: LIST
18310: PUSH
18311: LD_OWVAR 67
18315: ARRAY
18316: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18317: LD_VAR 0 1
18321: PUSH
18322: LD_INT 0
18324: PPUSH
18325: LD_INT 385
18327: PPUSH
18328: CALL_OW 12
18332: PLUS
18333: PPUSH
18334: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 102 , 6 , 25 , true ) ;
18338: LD_INT 1
18340: PPUSH
18341: LD_INT 5
18343: PPUSH
18344: CALL_OW 12
18348: PPUSH
18349: LD_INT 102
18351: PPUSH
18352: LD_INT 6
18354: PPUSH
18355: LD_INT 25
18357: PPUSH
18358: LD_INT 1
18360: PPUSH
18361: CALL_OW 56
// if tick mod [ 25 25$00 , 22 22$00 , 20 20$00 ] [ Difficulty ] then
18365: LD_OWVAR 1
18369: PUSH
18370: LD_INT 52500
18372: PUSH
18373: LD_INT 46200
18375: PUSH
18376: LD_INT 42000
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: LIST
18383: PUSH
18384: LD_OWVAR 67
18388: ARRAY
18389: MOD
18390: IFFALSE 18406
// time := time + 0 0$25 ;
18392: LD_ADDR_VAR 0 1
18396: PUSH
18397: LD_VAR 0 1
18401: PUSH
18402: LD_INT 875
18404: PLUS
18405: ST_TO_ADDR
// if tick mod 110 110$00 = 0 then
18406: LD_OWVAR 1
18410: PUSH
18411: LD_INT 231000
18413: MOD
18414: PUSH
18415: LD_INT 0
18417: EQUAL
18418: IFFALSE 18428
// time := 0 0$30 ;
18420: LD_ADDR_VAR 0 1
18424: PUSH
18425: LD_INT 1050
18427: ST_TO_ADDR
// end until game_status = false ;
18428: LD_EXP 28
18432: PUSH
18433: LD_INT 0
18435: EQUAL
18436: IFFALSE 18317
// end ;
18438: PPOPN 1
18440: END
// every 0 0$03 trigger game_status do var time ;
18441: LD_EXP 28
18445: IFFALSE 18581
18447: GO 18449
18449: DISABLE
18450: LD_INT 0
18452: PPUSH
// begin time := [ 0 0$30 , 0 0$45 , 0 0$50 ] [ Difficulty ] ;
18453: LD_ADDR_VAR 0 1
18457: PUSH
18458: LD_INT 1050
18460: PUSH
18461: LD_INT 1575
18463: PUSH
18464: LD_INT 1750
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: LIST
18471: PUSH
18472: LD_OWVAR 67
18476: ARRAY
18477: ST_TO_ADDR
// repeat begin Wait ( time + Rand ( 0 0$00 , 0 0$11 ) ) ;
18478: LD_VAR 0 1
18482: PUSH
18483: LD_INT 0
18485: PPUSH
18486: LD_INT 385
18488: PPUSH
18489: CALL_OW 12
18493: PLUS
18494: PPUSH
18495: CALL_OW 67
// CreateCratesXYR ( Rand ( 1 , 5 ) , 51 , 74 , 25 , true ) ;
18499: LD_INT 1
18501: PPUSH
18502: LD_INT 5
18504: PPUSH
18505: CALL_OW 12
18509: PPUSH
18510: LD_INT 51
18512: PPUSH
18513: LD_INT 74
18515: PPUSH
18516: LD_INT 25
18518: PPUSH
18519: LD_INT 1
18521: PPUSH
18522: CALL_OW 56
// if tick mod [ 40 40$00 , 50 50$00 , 65 65$00 ] [ Difficulty ] = 0 then
18526: LD_OWVAR 1
18530: PUSH
18531: LD_INT 84000
18533: PUSH
18534: LD_INT 105000
18536: PUSH
18537: LD_INT 136500
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: LIST
18544: PUSH
18545: LD_OWVAR 67
18549: ARRAY
18550: MOD
18551: PUSH
18552: LD_INT 0
18554: EQUAL
18555: IFFALSE 18571
// time := time + 0 0$15 ;
18557: LD_ADDR_VAR 0 1
18561: PUSH
18562: LD_VAR 0 1
18566: PUSH
18567: LD_INT 525
18569: PLUS
18570: ST_TO_ADDR
// end until game_status = false ;
18571: LD_EXP 28
18575: PUSH
18576: LD_INT 0
18578: EQUAL
18579: IFFALSE 18478
// end ; end_of_file
18581: PPOPN 1
18583: END
// every 0 0$01 trigger not debug do
18584: LD_EXP 1
18588: NOT
18589: IFFALSE 18612
18591: GO 18593
18593: DISABLE
// begin enable ;
18594: ENABLE
// Display_Strings := [ #tick , tick ] ;
18595: LD_ADDR_OWVAR 47
18599: PUSH
18600: LD_STRING #tick
18602: PUSH
18603: LD_OWVAR 1
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: ST_TO_ADDR
// end ; end_of_file
18612: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
18613: LD_VAR 0 1
18617: PPUSH
18618: LD_VAR 0 2
18622: PPUSH
18623: LD_VAR 0 3
18627: PPUSH
18628: CALL 22206 0 3
// end ;
18632: PPOPN 3
18634: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18635: LD_VAR 0 1
18639: PPUSH
18640: CALL 22304 0 1
// end ; end_of_file
18644: PPOPN 1
18646: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18647: GO 18649
18649: DISABLE
// begin ru_radar := 98 ;
18650: LD_ADDR_EXP 42
18654: PUSH
18655: LD_INT 98
18657: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18658: LD_ADDR_EXP 43
18662: PUSH
18663: LD_INT 89
18665: ST_TO_ADDR
// us_hack := 99 ;
18666: LD_ADDR_EXP 44
18670: PUSH
18671: LD_INT 99
18673: ST_TO_ADDR
// us_artillery := 97 ;
18674: LD_ADDR_EXP 45
18678: PUSH
18679: LD_INT 97
18681: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18682: LD_ADDR_EXP 46
18686: PUSH
18687: LD_INT 91
18689: ST_TO_ADDR
// end ; end_of_file end_of_file
18690: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
18691: GO 18693
18693: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18694: LD_STRING initStreamRollete();
18696: PPUSH
18697: CALL_OW 559
// InitStreamMode ;
18701: CALL 18706 0 0
// end ;
18705: END
// function InitStreamMode ; begin
18706: LD_INT 0
18708: PPUSH
// streamModeActive := false ;
18709: LD_ADDR_EXP 47
18713: PUSH
18714: LD_INT 0
18716: ST_TO_ADDR
// sRocket := false ;
18717: LD_ADDR_EXP 50
18721: PUSH
18722: LD_INT 0
18724: ST_TO_ADDR
// sSpeed := false ;
18725: LD_ADDR_EXP 49
18729: PUSH
18730: LD_INT 0
18732: ST_TO_ADDR
// sEngine := false ;
18733: LD_ADDR_EXP 51
18737: PUSH
18738: LD_INT 0
18740: ST_TO_ADDR
// sSpec := false ;
18741: LD_ADDR_EXP 48
18745: PUSH
18746: LD_INT 0
18748: ST_TO_ADDR
// sLevel := false ;
18749: LD_ADDR_EXP 52
18753: PUSH
18754: LD_INT 0
18756: ST_TO_ADDR
// sArmoury := false ;
18757: LD_ADDR_EXP 53
18761: PUSH
18762: LD_INT 0
18764: ST_TO_ADDR
// sRadar := false ;
18765: LD_ADDR_EXP 54
18769: PUSH
18770: LD_INT 0
18772: ST_TO_ADDR
// sBunker := false ;
18773: LD_ADDR_EXP 55
18777: PUSH
18778: LD_INT 0
18780: ST_TO_ADDR
// sHack := false ;
18781: LD_ADDR_EXP 56
18785: PUSH
18786: LD_INT 0
18788: ST_TO_ADDR
// sFire := false ;
18789: LD_ADDR_EXP 57
18793: PUSH
18794: LD_INT 0
18796: ST_TO_ADDR
// sRefresh := false ;
18797: LD_ADDR_EXP 58
18801: PUSH
18802: LD_INT 0
18804: ST_TO_ADDR
// sExp := false ;
18805: LD_ADDR_EXP 59
18809: PUSH
18810: LD_INT 0
18812: ST_TO_ADDR
// sDepot := false ;
18813: LD_ADDR_EXP 60
18817: PUSH
18818: LD_INT 0
18820: ST_TO_ADDR
// sFlag := false ;
18821: LD_ADDR_EXP 61
18825: PUSH
18826: LD_INT 0
18828: ST_TO_ADDR
// sKamikadze := false ;
18829: LD_ADDR_EXP 69
18833: PUSH
18834: LD_INT 0
18836: ST_TO_ADDR
// sTroll := false ;
18837: LD_ADDR_EXP 70
18841: PUSH
18842: LD_INT 0
18844: ST_TO_ADDR
// sSlow := false ;
18845: LD_ADDR_EXP 71
18849: PUSH
18850: LD_INT 0
18852: ST_TO_ADDR
// sLack := false ;
18853: LD_ADDR_EXP 72
18857: PUSH
18858: LD_INT 0
18860: ST_TO_ADDR
// sTank := false ;
18861: LD_ADDR_EXP 74
18865: PUSH
18866: LD_INT 0
18868: ST_TO_ADDR
// sRemote := false ;
18869: LD_ADDR_EXP 75
18873: PUSH
18874: LD_INT 0
18876: ST_TO_ADDR
// sSold := false ;
18877: LD_ADDR_EXP 62
18881: PUSH
18882: LD_INT 0
18884: ST_TO_ADDR
// sDiff := false ;
18885: LD_ADDR_EXP 63
18889: PUSH
18890: LD_INT 0
18892: ST_TO_ADDR
// sFog := false ;
18893: LD_ADDR_EXP 66
18897: PUSH
18898: LD_INT 0
18900: ST_TO_ADDR
// sReset := false ;
18901: LD_ADDR_EXP 67
18905: PUSH
18906: LD_INT 0
18908: ST_TO_ADDR
// sSun := false ;
18909: LD_ADDR_EXP 68
18913: PUSH
18914: LD_INT 0
18916: ST_TO_ADDR
// sTiger := false ;
18917: LD_ADDR_EXP 64
18921: PUSH
18922: LD_INT 0
18924: ST_TO_ADDR
// sBomb := false ;
18925: LD_ADDR_EXP 65
18929: PUSH
18930: LD_INT 0
18932: ST_TO_ADDR
// sWound := false ;
18933: LD_ADDR_EXP 73
18937: PUSH
18938: LD_INT 0
18940: ST_TO_ADDR
// end ;
18941: LD_VAR 0 1
18945: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
18946: LD_VAR 0 2
18950: PUSH
18951: LD_INT 100
18953: EQUAL
18954: IFFALSE 19489
// begin if not StreamModeActive then
18956: LD_EXP 47
18960: NOT
18961: IFFALSE 18971
// StreamModeActive := true ;
18963: LD_ADDR_EXP 47
18967: PUSH
18968: LD_INT 1
18970: ST_TO_ADDR
// if p3 = 0 then
18971: LD_VAR 0 3
18975: PUSH
18976: LD_INT 0
18978: EQUAL
18979: IFFALSE 18985
// InitStreamMode ;
18981: CALL 18706 0 0
// if p3 = 1 then
18985: LD_VAR 0 3
18989: PUSH
18990: LD_INT 1
18992: EQUAL
18993: IFFALSE 19003
// sRocket := true ;
18995: LD_ADDR_EXP 50
18999: PUSH
19000: LD_INT 1
19002: ST_TO_ADDR
// if p3 = 2 then
19003: LD_VAR 0 3
19007: PUSH
19008: LD_INT 2
19010: EQUAL
19011: IFFALSE 19021
// sSpeed := true ;
19013: LD_ADDR_EXP 49
19017: PUSH
19018: LD_INT 1
19020: ST_TO_ADDR
// if p3 = 3 then
19021: LD_VAR 0 3
19025: PUSH
19026: LD_INT 3
19028: EQUAL
19029: IFFALSE 19039
// sEngine := true ;
19031: LD_ADDR_EXP 51
19035: PUSH
19036: LD_INT 1
19038: ST_TO_ADDR
// if p3 = 4 then
19039: LD_VAR 0 3
19043: PUSH
19044: LD_INT 4
19046: EQUAL
19047: IFFALSE 19057
// sSpec := true ;
19049: LD_ADDR_EXP 48
19053: PUSH
19054: LD_INT 1
19056: ST_TO_ADDR
// if p3 = 5 then
19057: LD_VAR 0 3
19061: PUSH
19062: LD_INT 5
19064: EQUAL
19065: IFFALSE 19075
// sLevel := true ;
19067: LD_ADDR_EXP 52
19071: PUSH
19072: LD_INT 1
19074: ST_TO_ADDR
// if p3 = 6 then
19075: LD_VAR 0 3
19079: PUSH
19080: LD_INT 6
19082: EQUAL
19083: IFFALSE 19093
// sArmoury := true ;
19085: LD_ADDR_EXP 53
19089: PUSH
19090: LD_INT 1
19092: ST_TO_ADDR
// if p3 = 7 then
19093: LD_VAR 0 3
19097: PUSH
19098: LD_INT 7
19100: EQUAL
19101: IFFALSE 19111
// sRadar := true ;
19103: LD_ADDR_EXP 54
19107: PUSH
19108: LD_INT 1
19110: ST_TO_ADDR
// if p3 = 8 then
19111: LD_VAR 0 3
19115: PUSH
19116: LD_INT 8
19118: EQUAL
19119: IFFALSE 19129
// sBunker := true ;
19121: LD_ADDR_EXP 55
19125: PUSH
19126: LD_INT 1
19128: ST_TO_ADDR
// if p3 = 9 then
19129: LD_VAR 0 3
19133: PUSH
19134: LD_INT 9
19136: EQUAL
19137: IFFALSE 19147
// sHack := true ;
19139: LD_ADDR_EXP 56
19143: PUSH
19144: LD_INT 1
19146: ST_TO_ADDR
// if p3 = 10 then
19147: LD_VAR 0 3
19151: PUSH
19152: LD_INT 10
19154: EQUAL
19155: IFFALSE 19165
// sFire := true ;
19157: LD_ADDR_EXP 57
19161: PUSH
19162: LD_INT 1
19164: ST_TO_ADDR
// if p3 = 11 then
19165: LD_VAR 0 3
19169: PUSH
19170: LD_INT 11
19172: EQUAL
19173: IFFALSE 19183
// sRefresh := true ;
19175: LD_ADDR_EXP 58
19179: PUSH
19180: LD_INT 1
19182: ST_TO_ADDR
// if p3 = 12 then
19183: LD_VAR 0 3
19187: PUSH
19188: LD_INT 12
19190: EQUAL
19191: IFFALSE 19201
// sExp := true ;
19193: LD_ADDR_EXP 59
19197: PUSH
19198: LD_INT 1
19200: ST_TO_ADDR
// if p3 = 13 then
19201: LD_VAR 0 3
19205: PUSH
19206: LD_INT 13
19208: EQUAL
19209: IFFALSE 19219
// sDepot := true ;
19211: LD_ADDR_EXP 60
19215: PUSH
19216: LD_INT 1
19218: ST_TO_ADDR
// if p3 = 14 then
19219: LD_VAR 0 3
19223: PUSH
19224: LD_INT 14
19226: EQUAL
19227: IFFALSE 19237
// sFlag := true ;
19229: LD_ADDR_EXP 61
19233: PUSH
19234: LD_INT 1
19236: ST_TO_ADDR
// if p3 = 15 then
19237: LD_VAR 0 3
19241: PUSH
19242: LD_INT 15
19244: EQUAL
19245: IFFALSE 19255
// sKamikadze := true ;
19247: LD_ADDR_EXP 69
19251: PUSH
19252: LD_INT 1
19254: ST_TO_ADDR
// if p3 = 16 then
19255: LD_VAR 0 3
19259: PUSH
19260: LD_INT 16
19262: EQUAL
19263: IFFALSE 19273
// sTroll := true ;
19265: LD_ADDR_EXP 70
19269: PUSH
19270: LD_INT 1
19272: ST_TO_ADDR
// if p3 = 17 then
19273: LD_VAR 0 3
19277: PUSH
19278: LD_INT 17
19280: EQUAL
19281: IFFALSE 19291
// sSlow := true ;
19283: LD_ADDR_EXP 71
19287: PUSH
19288: LD_INT 1
19290: ST_TO_ADDR
// if p3 = 18 then
19291: LD_VAR 0 3
19295: PUSH
19296: LD_INT 18
19298: EQUAL
19299: IFFALSE 19309
// sLack := true ;
19301: LD_ADDR_EXP 72
19305: PUSH
19306: LD_INT 1
19308: ST_TO_ADDR
// if p3 = 19 then
19309: LD_VAR 0 3
19313: PUSH
19314: LD_INT 19
19316: EQUAL
19317: IFFALSE 19327
// sTank := true ;
19319: LD_ADDR_EXP 74
19323: PUSH
19324: LD_INT 1
19326: ST_TO_ADDR
// if p3 = 20 then
19327: LD_VAR 0 3
19331: PUSH
19332: LD_INT 20
19334: EQUAL
19335: IFFALSE 19345
// sRemote := true ;
19337: LD_ADDR_EXP 75
19341: PUSH
19342: LD_INT 1
19344: ST_TO_ADDR
// if p3 = 101 then
19345: LD_VAR 0 3
19349: PUSH
19350: LD_INT 101
19352: EQUAL
19353: IFFALSE 19363
// sSold := true ;
19355: LD_ADDR_EXP 62
19359: PUSH
19360: LD_INT 1
19362: ST_TO_ADDR
// if p3 = 102 then
19363: LD_VAR 0 3
19367: PUSH
19368: LD_INT 102
19370: EQUAL
19371: IFFALSE 19381
// sDiff := true ;
19373: LD_ADDR_EXP 63
19377: PUSH
19378: LD_INT 1
19380: ST_TO_ADDR
// if p3 = 103 then
19381: LD_VAR 0 3
19385: PUSH
19386: LD_INT 103
19388: EQUAL
19389: IFFALSE 19399
// sFog := true ;
19391: LD_ADDR_EXP 66
19395: PUSH
19396: LD_INT 1
19398: ST_TO_ADDR
// if p3 = 104 then
19399: LD_VAR 0 3
19403: PUSH
19404: LD_INT 104
19406: EQUAL
19407: IFFALSE 19417
// sReset := true ;
19409: LD_ADDR_EXP 67
19413: PUSH
19414: LD_INT 1
19416: ST_TO_ADDR
// if p3 = 105 then
19417: LD_VAR 0 3
19421: PUSH
19422: LD_INT 105
19424: EQUAL
19425: IFFALSE 19435
// sSun := true ;
19427: LD_ADDR_EXP 68
19431: PUSH
19432: LD_INT 1
19434: ST_TO_ADDR
// if p3 = 106 then
19435: LD_VAR 0 3
19439: PUSH
19440: LD_INT 106
19442: EQUAL
19443: IFFALSE 19453
// sTiger := true ;
19445: LD_ADDR_EXP 64
19449: PUSH
19450: LD_INT 1
19452: ST_TO_ADDR
// if p3 = 107 then
19453: LD_VAR 0 3
19457: PUSH
19458: LD_INT 107
19460: EQUAL
19461: IFFALSE 19471
// sBomb := true ;
19463: LD_ADDR_EXP 65
19467: PUSH
19468: LD_INT 1
19470: ST_TO_ADDR
// if p3 = 108 then
19471: LD_VAR 0 3
19475: PUSH
19476: LD_INT 108
19478: EQUAL
19479: IFFALSE 19489
// sWound := true ;
19481: LD_ADDR_EXP 73
19485: PUSH
19486: LD_INT 1
19488: ST_TO_ADDR
// end ; end ;
19489: PPOPN 6
19491: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
19492: LD_EXP 47
19496: PUSH
19497: LD_EXP 50
19501: AND
19502: IFFALSE 19623
19504: GO 19506
19506: DISABLE
19507: LD_INT 0
19509: PPUSH
19510: PPUSH
// begin enable ;
19511: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
19512: LD_ADDR_VAR 0 2
19516: PUSH
19517: LD_INT 22
19519: PUSH
19520: LD_OWVAR 2
19524: PUSH
19525: EMPTY
19526: LIST
19527: LIST
19528: PUSH
19529: LD_INT 2
19531: PUSH
19532: LD_INT 34
19534: PUSH
19535: LD_INT 7
19537: PUSH
19538: EMPTY
19539: LIST
19540: LIST
19541: PUSH
19542: LD_INT 34
19544: PUSH
19545: LD_INT 45
19547: PUSH
19548: EMPTY
19549: LIST
19550: LIST
19551: PUSH
19552: LD_INT 34
19554: PUSH
19555: LD_INT 28
19557: PUSH
19558: EMPTY
19559: LIST
19560: LIST
19561: PUSH
19562: LD_INT 34
19564: PUSH
19565: LD_INT 47
19567: PUSH
19568: EMPTY
19569: LIST
19570: LIST
19571: PUSH
19572: EMPTY
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: PPUSH
19583: CALL_OW 69
19587: ST_TO_ADDR
// if not tmp then
19588: LD_VAR 0 2
19592: NOT
19593: IFFALSE 19597
// exit ;
19595: GO 19623
// for i in tmp do
19597: LD_ADDR_VAR 0 1
19601: PUSH
19602: LD_VAR 0 2
19606: PUSH
19607: FOR_IN
19608: IFFALSE 19621
// begin DestroyUnit ( i ) ;
19610: LD_VAR 0 1
19614: PPUSH
19615: CALL_OW 65
// end ;
19619: GO 19607
19621: POP
19622: POP
// end ;
19623: PPOPN 2
19625: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
19626: LD_EXP 47
19630: PUSH
19631: LD_EXP 51
19635: AND
19636: IFFALSE 19717
19638: GO 19640
19640: DISABLE
19641: LD_INT 0
19643: PPUSH
19644: PPUSH
// begin enable ;
19645: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
19646: LD_ADDR_VAR 0 2
19650: PUSH
19651: LD_INT 22
19653: PUSH
19654: LD_OWVAR 2
19658: PUSH
19659: EMPTY
19660: LIST
19661: LIST
19662: PUSH
19663: LD_INT 32
19665: PUSH
19666: LD_INT 3
19668: PUSH
19669: EMPTY
19670: LIST
19671: LIST
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: PPUSH
19677: CALL_OW 69
19681: ST_TO_ADDR
// if not tmp then
19682: LD_VAR 0 2
19686: NOT
19687: IFFALSE 19691
// exit ;
19689: GO 19717
// for i in tmp do
19691: LD_ADDR_VAR 0 1
19695: PUSH
19696: LD_VAR 0 2
19700: PUSH
19701: FOR_IN
19702: IFFALSE 19715
// begin DestroyUnit ( i ) ;
19704: LD_VAR 0 1
19708: PPUSH
19709: CALL_OW 65
// end ;
19713: GO 19701
19715: POP
19716: POP
// end ;
19717: PPOPN 2
19719: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
19720: LD_EXP 47
19724: PUSH
19725: LD_EXP 48
19729: AND
19730: IFFALSE 19823
19732: GO 19734
19734: DISABLE
19735: LD_INT 0
19737: PPUSH
// begin enable ;
19738: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
19739: LD_ADDR_VAR 0 1
19743: PUSH
19744: LD_INT 22
19746: PUSH
19747: LD_OWVAR 2
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: LD_INT 2
19758: PUSH
19759: LD_INT 25
19761: PUSH
19762: LD_INT 5
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: PUSH
19769: LD_INT 25
19771: PUSH
19772: LD_INT 9
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 25
19781: PUSH
19782: LD_INT 8
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PPUSH
19799: CALL_OW 69
19803: PUSH
19804: FOR_IN
19805: IFFALSE 19821
// begin SetClass ( i , 1 ) ;
19807: LD_VAR 0 1
19811: PPUSH
19812: LD_INT 1
19814: PPUSH
19815: CALL_OW 336
// end ;
19819: GO 19804
19821: POP
19822: POP
// end ;
19823: PPOPN 1
19825: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
19826: LD_EXP 47
19830: PUSH
19831: LD_EXP 49
19835: AND
19836: PUSH
19837: LD_OWVAR 65
19841: PUSH
19842: LD_INT 7
19844: LESS
19845: AND
19846: IFFALSE 19860
19848: GO 19850
19850: DISABLE
// begin enable ;
19851: ENABLE
// game_speed := 7 ;
19852: LD_ADDR_OWVAR 65
19856: PUSH
19857: LD_INT 7
19859: ST_TO_ADDR
// end ;
19860: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
19861: LD_EXP 47
19865: PUSH
19866: LD_EXP 52
19870: AND
19871: IFFALSE 20073
19873: GO 19875
19875: DISABLE
19876: LD_INT 0
19878: PPUSH
19879: PPUSH
19880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
19881: LD_ADDR_VAR 0 3
19885: PUSH
19886: LD_INT 81
19888: PUSH
19889: LD_OWVAR 2
19893: PUSH
19894: EMPTY
19895: LIST
19896: LIST
19897: PUSH
19898: LD_INT 21
19900: PUSH
19901: LD_INT 1
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: EMPTY
19909: LIST
19910: LIST
19911: PPUSH
19912: CALL_OW 69
19916: ST_TO_ADDR
// if not tmp then
19917: LD_VAR 0 3
19921: NOT
19922: IFFALSE 19926
// exit ;
19924: GO 20073
// if tmp > 5 then
19926: LD_VAR 0 3
19930: PUSH
19931: LD_INT 5
19933: GREATER
19934: IFFALSE 19946
// k := 5 else
19936: LD_ADDR_VAR 0 2
19940: PUSH
19941: LD_INT 5
19943: ST_TO_ADDR
19944: GO 19956
// k := tmp ;
19946: LD_ADDR_VAR 0 2
19950: PUSH
19951: LD_VAR 0 3
19955: ST_TO_ADDR
// for i := 1 to k do
19956: LD_ADDR_VAR 0 1
19960: PUSH
19961: DOUBLE
19962: LD_INT 1
19964: DEC
19965: ST_TO_ADDR
19966: LD_VAR 0 2
19970: PUSH
19971: FOR_TO
19972: IFFALSE 20071
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
19974: LD_VAR 0 3
19978: PUSH
19979: LD_VAR 0 1
19983: ARRAY
19984: PPUSH
19985: LD_VAR 0 1
19989: PUSH
19990: LD_INT 4
19992: MOD
19993: PUSH
19994: LD_INT 1
19996: PLUS
19997: PPUSH
19998: CALL_OW 259
20002: PUSH
20003: LD_INT 10
20005: LESS
20006: IFFALSE 20069
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
20008: LD_VAR 0 3
20012: PUSH
20013: LD_VAR 0 1
20017: ARRAY
20018: PPUSH
20019: LD_VAR 0 1
20023: PUSH
20024: LD_INT 4
20026: MOD
20027: PUSH
20028: LD_INT 1
20030: PLUS
20031: PPUSH
20032: LD_VAR 0 3
20036: PUSH
20037: LD_VAR 0 1
20041: ARRAY
20042: PPUSH
20043: LD_VAR 0 1
20047: PUSH
20048: LD_INT 4
20050: MOD
20051: PUSH
20052: LD_INT 1
20054: PLUS
20055: PPUSH
20056: CALL_OW 259
20060: PUSH
20061: LD_INT 1
20063: PLUS
20064: PPUSH
20065: CALL_OW 237
20069: GO 19971
20071: POP
20072: POP
// end ;
20073: PPOPN 3
20075: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
20076: LD_EXP 47
20080: PUSH
20081: LD_EXP 53
20085: AND
20086: IFFALSE 20106
20088: GO 20090
20090: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
20091: LD_INT 4
20093: PPUSH
20094: LD_OWVAR 2
20098: PPUSH
20099: LD_INT 0
20101: PPUSH
20102: CALL_OW 324
20106: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
20107: LD_EXP 47
20111: PUSH
20112: LD_EXP 54
20116: AND
20117: IFFALSE 20216
20119: GO 20121
20121: DISABLE
20122: LD_INT 0
20124: PPUSH
20125: PPUSH
// begin enable ;
20126: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
20127: LD_ADDR_VAR 0 2
20131: PUSH
20132: LD_INT 22
20134: PUSH
20135: LD_OWVAR 2
20139: PUSH
20140: EMPTY
20141: LIST
20142: LIST
20143: PUSH
20144: LD_INT 2
20146: PUSH
20147: LD_INT 34
20149: PUSH
20150: LD_INT 11
20152: PUSH
20153: EMPTY
20154: LIST
20155: LIST
20156: PUSH
20157: LD_INT 34
20159: PUSH
20160: LD_INT 30
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: PUSH
20167: EMPTY
20168: LIST
20169: LIST
20170: LIST
20171: PUSH
20172: EMPTY
20173: LIST
20174: LIST
20175: PPUSH
20176: CALL_OW 69
20180: ST_TO_ADDR
// if not tmp then
20181: LD_VAR 0 2
20185: NOT
20186: IFFALSE 20190
// exit ;
20188: GO 20216
// for i in tmp do
20190: LD_ADDR_VAR 0 1
20194: PUSH
20195: LD_VAR 0 2
20199: PUSH
20200: FOR_IN
20201: IFFALSE 20214
// begin DestroyUnit ( i ) ;
20203: LD_VAR 0 1
20207: PPUSH
20208: CALL_OW 65
// end ;
20212: GO 20200
20214: POP
20215: POP
// end ;
20216: PPOPN 2
20218: END
// every 0 0$1 trigger StreamModeActive and sBunker do
20219: LD_EXP 47
20223: PUSH
20224: LD_EXP 55
20228: AND
20229: IFFALSE 20249
20231: GO 20233
20233: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
20234: LD_INT 32
20236: PPUSH
20237: LD_OWVAR 2
20241: PPUSH
20242: LD_INT 0
20244: PPUSH
20245: CALL_OW 324
20249: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
20250: LD_EXP 47
20254: PUSH
20255: LD_EXP 56
20259: AND
20260: IFFALSE 20441
20262: GO 20264
20264: DISABLE
20265: LD_INT 0
20267: PPUSH
20268: PPUSH
20269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
20270: LD_ADDR_VAR 0 2
20274: PUSH
20275: LD_INT 22
20277: PUSH
20278: LD_OWVAR 2
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: PUSH
20287: LD_INT 33
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: EMPTY
20294: LIST
20295: LIST
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: PPUSH
20301: CALL_OW 69
20305: ST_TO_ADDR
// if not tmp then
20306: LD_VAR 0 2
20310: NOT
20311: IFFALSE 20315
// exit ;
20313: GO 20441
// side := 0 ;
20315: LD_ADDR_VAR 0 3
20319: PUSH
20320: LD_INT 0
20322: ST_TO_ADDR
// for i := 1 to 8 do
20323: LD_ADDR_VAR 0 1
20327: PUSH
20328: DOUBLE
20329: LD_INT 1
20331: DEC
20332: ST_TO_ADDR
20333: LD_INT 8
20335: PUSH
20336: FOR_TO
20337: IFFALSE 20385
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
20339: LD_OWVAR 2
20343: PUSH
20344: LD_VAR 0 1
20348: NONEQUAL
20349: PUSH
20350: LD_OWVAR 2
20354: PPUSH
20355: LD_VAR 0 1
20359: PPUSH
20360: CALL_OW 81
20364: PUSH
20365: LD_INT 2
20367: EQUAL
20368: AND
20369: IFFALSE 20383
// begin side := i ;
20371: LD_ADDR_VAR 0 3
20375: PUSH
20376: LD_VAR 0 1
20380: ST_TO_ADDR
// break ;
20381: GO 20385
// end ;
20383: GO 20336
20385: POP
20386: POP
// if not side then
20387: LD_VAR 0 3
20391: NOT
20392: IFFALSE 20396
// exit ;
20394: GO 20441
// for i := 1 to tmp do
20396: LD_ADDR_VAR 0 1
20400: PUSH
20401: DOUBLE
20402: LD_INT 1
20404: DEC
20405: ST_TO_ADDR
20406: LD_VAR 0 2
20410: PUSH
20411: FOR_TO
20412: IFFALSE 20439
// if Prob ( 30 ) then
20414: LD_INT 30
20416: PPUSH
20417: CALL_OW 13
20421: IFFALSE 20437
// SetSide ( i , side ) ;
20423: LD_VAR 0 1
20427: PPUSH
20428: LD_VAR 0 3
20432: PPUSH
20433: CALL_OW 235
20437: GO 20411
20439: POP
20440: POP
// end ;
20441: PPOPN 3
20443: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
20444: LD_EXP 47
20448: PUSH
20449: LD_EXP 58
20453: AND
20454: IFFALSE 20573
20456: GO 20458
20458: DISABLE
20459: LD_INT 0
20461: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
20462: LD_ADDR_VAR 0 1
20466: PUSH
20467: LD_INT 22
20469: PUSH
20470: LD_OWVAR 2
20474: PUSH
20475: EMPTY
20476: LIST
20477: LIST
20478: PUSH
20479: LD_INT 21
20481: PUSH
20482: LD_INT 1
20484: PUSH
20485: EMPTY
20486: LIST
20487: LIST
20488: PUSH
20489: LD_INT 3
20491: PUSH
20492: LD_INT 23
20494: PUSH
20495: LD_INT 0
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: PUSH
20502: EMPTY
20503: LIST
20504: LIST
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: LIST
20510: PPUSH
20511: CALL_OW 69
20515: PUSH
20516: FOR_IN
20517: IFFALSE 20571
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
20519: LD_VAR 0 1
20523: PPUSH
20524: CALL_OW 257
20528: PUSH
20529: LD_INT 1
20531: PUSH
20532: LD_INT 2
20534: PUSH
20535: LD_INT 3
20537: PUSH
20538: LD_INT 4
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: LIST
20545: LIST
20546: IN
20547: IFFALSE 20569
// SetClass ( un , rand ( 1 , 4 ) ) ;
20549: LD_VAR 0 1
20553: PPUSH
20554: LD_INT 1
20556: PPUSH
20557: LD_INT 4
20559: PPUSH
20560: CALL_OW 12
20564: PPUSH
20565: CALL_OW 336
20569: GO 20516
20571: POP
20572: POP
// end ;
20573: PPOPN 1
20575: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
20576: LD_EXP 47
20580: PUSH
20581: LD_EXP 57
20585: AND
20586: IFFALSE 20665
20588: GO 20590
20590: DISABLE
20591: LD_INT 0
20593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
20594: LD_ADDR_VAR 0 1
20598: PUSH
20599: LD_INT 22
20601: PUSH
20602: LD_OWVAR 2
20606: PUSH
20607: EMPTY
20608: LIST
20609: LIST
20610: PUSH
20611: LD_INT 21
20613: PUSH
20614: LD_INT 3
20616: PUSH
20617: EMPTY
20618: LIST
20619: LIST
20620: PUSH
20621: EMPTY
20622: LIST
20623: LIST
20624: PPUSH
20625: CALL_OW 69
20629: ST_TO_ADDR
// if not tmp then
20630: LD_VAR 0 1
20634: NOT
20635: IFFALSE 20639
// exit ;
20637: GO 20665
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
20639: LD_VAR 0 1
20643: PUSH
20644: LD_INT 1
20646: PPUSH
20647: LD_VAR 0 1
20651: PPUSH
20652: CALL_OW 12
20656: ARRAY
20657: PPUSH
20658: LD_INT 100
20660: PPUSH
20661: CALL_OW 234
// end ;
20665: PPOPN 1
20667: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
20668: LD_EXP 47
20672: PUSH
20673: LD_EXP 59
20677: AND
20678: IFFALSE 20776
20680: GO 20682
20682: DISABLE
20683: LD_INT 0
20685: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20686: LD_ADDR_VAR 0 1
20690: PUSH
20691: LD_INT 22
20693: PUSH
20694: LD_OWVAR 2
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: PUSH
20703: LD_INT 21
20705: PUSH
20706: LD_INT 1
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: PUSH
20713: EMPTY
20714: LIST
20715: LIST
20716: PPUSH
20717: CALL_OW 69
20721: ST_TO_ADDR
// if not tmp then
20722: LD_VAR 0 1
20726: NOT
20727: IFFALSE 20731
// exit ;
20729: GO 20776
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
20731: LD_VAR 0 1
20735: PUSH
20736: LD_INT 1
20738: PPUSH
20739: LD_VAR 0 1
20743: PPUSH
20744: CALL_OW 12
20748: ARRAY
20749: PPUSH
20750: LD_INT 1
20752: PPUSH
20753: LD_INT 4
20755: PPUSH
20756: CALL_OW 12
20760: PPUSH
20761: LD_INT 3000
20763: PPUSH
20764: LD_INT 9000
20766: PPUSH
20767: CALL_OW 12
20771: PPUSH
20772: CALL_OW 492
// end ;
20776: PPOPN 1
20778: END
// every 0 0$1 trigger StreamModeActive and sDepot do
20779: LD_EXP 47
20783: PUSH
20784: LD_EXP 60
20788: AND
20789: IFFALSE 20809
20791: GO 20793
20793: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
20794: LD_INT 1
20796: PPUSH
20797: LD_OWVAR 2
20801: PPUSH
20802: LD_INT 0
20804: PPUSH
20805: CALL_OW 324
20809: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
20810: LD_EXP 47
20814: PUSH
20815: LD_EXP 61
20819: AND
20820: IFFALSE 20903
20822: GO 20824
20824: DISABLE
20825: LD_INT 0
20827: PPUSH
20828: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
20829: LD_ADDR_VAR 0 2
20833: PUSH
20834: LD_INT 22
20836: PUSH
20837: LD_OWVAR 2
20841: PUSH
20842: EMPTY
20843: LIST
20844: LIST
20845: PUSH
20846: LD_INT 21
20848: PUSH
20849: LD_INT 3
20851: PUSH
20852: EMPTY
20853: LIST
20854: LIST
20855: PUSH
20856: EMPTY
20857: LIST
20858: LIST
20859: PPUSH
20860: CALL_OW 69
20864: ST_TO_ADDR
// if not tmp then
20865: LD_VAR 0 2
20869: NOT
20870: IFFALSE 20874
// exit ;
20872: GO 20903
// for i in tmp do
20874: LD_ADDR_VAR 0 1
20878: PUSH
20879: LD_VAR 0 2
20883: PUSH
20884: FOR_IN
20885: IFFALSE 20901
// SetBLevel ( i , 10 ) ;
20887: LD_VAR 0 1
20891: PPUSH
20892: LD_INT 10
20894: PPUSH
20895: CALL_OW 241
20899: GO 20884
20901: POP
20902: POP
// end ;
20903: PPOPN 2
20905: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
20906: LD_EXP 47
20910: PUSH
20911: LD_EXP 62
20915: AND
20916: IFFALSE 21019
20918: GO 20920
20920: DISABLE
20921: LD_INT 0
20923: PPUSH
20924: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20925: LD_ADDR_VAR 0 2
20929: PUSH
20930: LD_INT 22
20932: PUSH
20933: LD_OWVAR 2
20937: PUSH
20938: EMPTY
20939: LIST
20940: LIST
20941: PUSH
20942: LD_INT 25
20944: PUSH
20945: LD_INT 1
20947: PUSH
20948: EMPTY
20949: LIST
20950: LIST
20951: PUSH
20952: EMPTY
20953: LIST
20954: LIST
20955: PPUSH
20956: CALL_OW 69
20960: ST_TO_ADDR
// if not tmp then
20961: LD_VAR 0 2
20965: NOT
20966: IFFALSE 20970
// exit ;
20968: GO 21019
// for i in tmp do
20970: LD_ADDR_VAR 0 1
20974: PUSH
20975: LD_VAR 0 2
20979: PUSH
20980: FOR_IN
20981: IFFALSE 21017
// begin if Crawls ( i ) then
20983: LD_VAR 0 1
20987: PPUSH
20988: CALL_OW 318
20992: IFFALSE 21003
// ComWalk ( i ) ;
20994: LD_VAR 0 1
20998: PPUSH
20999: CALL_OW 138
// SetClass ( i , 4 ) ;
21003: LD_VAR 0 1
21007: PPUSH
21008: LD_INT 4
21010: PPUSH
21011: CALL_OW 336
// end ;
21015: GO 20980
21017: POP
21018: POP
// end ;
21019: PPOPN 2
21021: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
21022: LD_EXP 47
21026: PUSH
21027: LD_EXP 63
21031: AND
21032: PUSH
21033: LD_OWVAR 67
21037: PUSH
21038: LD_INT 3
21040: LESS
21041: AND
21042: IFFALSE 21061
21044: GO 21046
21046: DISABLE
// Difficulty := Difficulty + 1 ;
21047: LD_ADDR_OWVAR 67
21051: PUSH
21052: LD_OWVAR 67
21056: PUSH
21057: LD_INT 1
21059: PLUS
21060: ST_TO_ADDR
21061: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
21062: LD_EXP 47
21066: PUSH
21067: LD_EXP 64
21071: AND
21072: IFFALSE 21175
21074: GO 21076
21076: DISABLE
21077: LD_INT 0
21079: PPUSH
// begin for i := 1 to 5 do
21080: LD_ADDR_VAR 0 1
21084: PUSH
21085: DOUBLE
21086: LD_INT 1
21088: DEC
21089: ST_TO_ADDR
21090: LD_INT 5
21092: PUSH
21093: FOR_TO
21094: IFFALSE 21173
// begin uc_nation := nation_nature ;
21096: LD_ADDR_OWVAR 21
21100: PUSH
21101: LD_INT 0
21103: ST_TO_ADDR
// uc_side := 0 ;
21104: LD_ADDR_OWVAR 20
21108: PUSH
21109: LD_INT 0
21111: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
21112: LD_ADDR_OWVAR 29
21116: PUSH
21117: LD_INT 12
21119: PUSH
21120: LD_INT 12
21122: PUSH
21123: EMPTY
21124: LIST
21125: LIST
21126: ST_TO_ADDR
// hc_agressivity := 20 ;
21127: LD_ADDR_OWVAR 35
21131: PUSH
21132: LD_INT 20
21134: ST_TO_ADDR
// hc_class := class_tiger ;
21135: LD_ADDR_OWVAR 28
21139: PUSH
21140: LD_INT 14
21142: ST_TO_ADDR
// hc_gallery :=  ;
21143: LD_ADDR_OWVAR 33
21147: PUSH
21148: LD_STRING 
21150: ST_TO_ADDR
// hc_name :=  ;
21151: LD_ADDR_OWVAR 26
21155: PUSH
21156: LD_STRING 
21158: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
21159: CALL_OW 44
21163: PPUSH
21164: LD_INT 0
21166: PPUSH
21167: CALL_OW 51
// end ;
21171: GO 21093
21173: POP
21174: POP
// end ;
21175: PPOPN 1
21177: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
21178: LD_EXP 47
21182: PUSH
21183: LD_EXP 65
21187: AND
21188: IFFALSE 21362
21190: GO 21192
21192: DISABLE
21193: LD_INT 0
21195: PPUSH
21196: PPUSH
21197: PPUSH
21198: PPUSH
// begin result := false ;
21199: LD_ADDR_VAR 0 4
21203: PUSH
21204: LD_INT 0
21206: ST_TO_ADDR
// for i := 1 to 8 do
21207: LD_ADDR_VAR 0 1
21211: PUSH
21212: DOUBLE
21213: LD_INT 1
21215: DEC
21216: ST_TO_ADDR
21217: LD_INT 8
21219: PUSH
21220: FOR_TO
21221: IFFALSE 21332
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
21223: LD_ADDR_VAR 0 2
21227: PUSH
21228: LD_INT 10
21230: PUSH
21231: LD_INT 50
21233: PUSH
21234: LD_INT 90
21236: PUSH
21237: LD_INT 140
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: LIST
21244: LIST
21245: PUSH
21246: LD_INT 1
21248: PPUSH
21249: LD_INT 4
21251: PPUSH
21252: CALL_OW 12
21256: ARRAY
21257: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
21258: LD_ADDR_VAR 0 3
21262: PUSH
21263: LD_INT 10
21265: PUSH
21266: LD_INT 50
21268: PUSH
21269: LD_INT 90
21271: PUSH
21272: LD_INT 140
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: PUSH
21281: LD_INT 1
21283: PPUSH
21284: LD_INT 4
21286: PPUSH
21287: CALL_OW 12
21291: ARRAY
21292: ST_TO_ADDR
// if ValidHex ( x , y ) then
21293: LD_VAR 0 2
21297: PPUSH
21298: LD_VAR 0 3
21302: PPUSH
21303: CALL_OW 488
21307: IFFALSE 21330
// begin result := [ x , y ] ;
21309: LD_ADDR_VAR 0 4
21313: PUSH
21314: LD_VAR 0 2
21318: PUSH
21319: LD_VAR 0 3
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: ST_TO_ADDR
// break ;
21328: GO 21332
// end ; end ;
21330: GO 21220
21332: POP
21333: POP
// if result then
21334: LD_VAR 0 4
21338: IFFALSE 21362
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
21340: LD_VAR 0 4
21344: PUSH
21345: LD_INT 1
21347: ARRAY
21348: PPUSH
21349: LD_VAR 0 4
21353: PUSH
21354: LD_INT 2
21356: ARRAY
21357: PPUSH
21358: CALL_OW 429
// end ;
21362: PPOPN 4
21364: END
// every 0 0$1 trigger StreamModeActive and sReset do
21365: LD_EXP 47
21369: PUSH
21370: LD_EXP 67
21374: AND
21375: IFFALSE 21387
21377: GO 21379
21379: DISABLE
// YouLost (  ) ;
21380: LD_STRING 
21382: PPUSH
21383: CALL_OW 104
21387: END
// every 0 0$1 trigger StreamModeActive and sFog do
21388: LD_EXP 47
21392: PUSH
21393: LD_EXP 66
21397: AND
21398: IFFALSE 21412
21400: GO 21402
21402: DISABLE
// FogOff ( your_side ) ;
21403: LD_OWVAR 2
21407: PPUSH
21408: CALL_OW 344
21412: END
// every 0 0$1 trigger StreamModeActive and sSun do
21413: LD_EXP 47
21417: PUSH
21418: LD_EXP 68
21422: AND
21423: IFFALSE 21451
21425: GO 21427
21427: DISABLE
// begin solar_recharge_percent := 0 ;
21428: LD_ADDR_OWVAR 79
21432: PUSH
21433: LD_INT 0
21435: ST_TO_ADDR
// wait ( 5 5$00 ) ;
21436: LD_INT 10500
21438: PPUSH
21439: CALL_OW 67
// solar_recharge_percent := 100 ;
21443: LD_ADDR_OWVAR 79
21447: PUSH
21448: LD_INT 100
21450: ST_TO_ADDR
// end ;
21451: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
21452: LD_EXP 47
21456: PUSH
21457: LD_EXP 69
21461: AND
21462: IFFALSE 21617
21464: GO 21466
21466: DISABLE
21467: LD_INT 0
21469: PPUSH
21470: PPUSH
// begin for i := 1 to 6 do
21471: LD_ADDR_VAR 0 1
21475: PUSH
21476: DOUBLE
21477: LD_INT 1
21479: DEC
21480: ST_TO_ADDR
21481: LD_INT 6
21483: PUSH
21484: FOR_TO
21485: IFFALSE 21615
// begin uc_nation := nation_nature ;
21487: LD_ADDR_OWVAR 21
21491: PUSH
21492: LD_INT 0
21494: ST_TO_ADDR
// uc_side := 0 ;
21495: LD_ADDR_OWVAR 20
21499: PUSH
21500: LD_INT 0
21502: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
21503: LD_ADDR_OWVAR 29
21507: PUSH
21508: LD_INT 12
21510: PUSH
21511: LD_INT 12
21513: PUSH
21514: EMPTY
21515: LIST
21516: LIST
21517: ST_TO_ADDR
// hc_agressivity := 20 ;
21518: LD_ADDR_OWVAR 35
21522: PUSH
21523: LD_INT 20
21525: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
21526: LD_ADDR_OWVAR 28
21530: PUSH
21531: LD_INT 17
21533: ST_TO_ADDR
// hc_gallery :=  ;
21534: LD_ADDR_OWVAR 33
21538: PUSH
21539: LD_STRING 
21541: ST_TO_ADDR
// hc_name :=  ;
21542: LD_ADDR_OWVAR 26
21546: PUSH
21547: LD_STRING 
21549: ST_TO_ADDR
// un := CreateHuman ;
21550: LD_ADDR_VAR 0 2
21554: PUSH
21555: CALL_OW 44
21559: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
21560: LD_VAR 0 2
21564: PPUSH
21565: LD_INT 1
21567: PPUSH
21568: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
21572: LD_VAR 0 2
21576: PPUSH
21577: LD_INT 3
21579: PUSH
21580: LD_INT 22
21582: PUSH
21583: LD_INT 0
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: PUSH
21590: EMPTY
21591: LIST
21592: LIST
21593: PPUSH
21594: CALL_OW 69
21598: PPUSH
21599: LD_VAR 0 2
21603: PPUSH
21604: CALL_OW 74
21608: PPUSH
21609: CALL_OW 115
// end ;
21613: GO 21484
21615: POP
21616: POP
// end ;
21617: PPOPN 2
21619: END
// every 0 0$1 trigger StreamModeActive and sTroll do
21620: LD_EXP 47
21624: PUSH
21625: LD_EXP 70
21629: AND
21630: IFFALSE 21656
21632: GO 21634
21634: DISABLE
// begin ToLua ( displayTroll(); ) ;
21635: LD_STRING displayTroll();
21637: PPUSH
21638: CALL_OW 559
// wait ( 3 3$00 ) ;
21642: LD_INT 6300
21644: PPUSH
21645: CALL_OW 67
// ToLua ( hideTroll(); ) ;
21649: LD_STRING hideTroll();
21651: PPUSH
21652: CALL_OW 559
// end ;
21656: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
21657: LD_EXP 47
21661: PUSH
21662: LD_EXP 71
21666: AND
21667: IFFALSE 21730
21669: GO 21671
21671: DISABLE
21672: LD_INT 0
21674: PPUSH
// begin p := 0 ;
21675: LD_ADDR_VAR 0 1
21679: PUSH
21680: LD_INT 0
21682: ST_TO_ADDR
// repeat game_speed := 1 ;
21683: LD_ADDR_OWVAR 65
21687: PUSH
21688: LD_INT 1
21690: ST_TO_ADDR
// wait ( 0 0$1 ) ;
21691: LD_INT 35
21693: PPUSH
21694: CALL_OW 67
// p := p + 1 ;
21698: LD_ADDR_VAR 0 1
21702: PUSH
21703: LD_VAR 0 1
21707: PUSH
21708: LD_INT 1
21710: PLUS
21711: ST_TO_ADDR
// until p >= 60 ;
21712: LD_VAR 0 1
21716: PUSH
21717: LD_INT 60
21719: GREATEREQUAL
21720: IFFALSE 21683
// game_speed := 4 ;
21722: LD_ADDR_OWVAR 65
21726: PUSH
21727: LD_INT 4
21729: ST_TO_ADDR
// end ;
21730: PPOPN 1
21732: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
21733: LD_EXP 47
21737: PUSH
21738: LD_EXP 72
21742: AND
21743: IFFALSE 21889
21745: GO 21747
21747: DISABLE
21748: LD_INT 0
21750: PPUSH
21751: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21752: LD_ADDR_VAR 0 1
21756: PUSH
21757: LD_INT 22
21759: PUSH
21760: LD_OWVAR 2
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: PUSH
21769: LD_INT 2
21771: PUSH
21772: LD_INT 30
21774: PUSH
21775: LD_INT 0
21777: PUSH
21778: EMPTY
21779: LIST
21780: LIST
21781: PUSH
21782: LD_INT 30
21784: PUSH
21785: LD_INT 1
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: PUSH
21797: EMPTY
21798: LIST
21799: LIST
21800: PPUSH
21801: CALL_OW 69
21805: ST_TO_ADDR
// if not depot then
21806: LD_VAR 0 1
21810: NOT
21811: IFFALSE 21815
// exit ;
21813: GO 21889
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
21815: LD_ADDR_VAR 0 2
21819: PUSH
21820: LD_VAR 0 1
21824: PUSH
21825: LD_INT 1
21827: PPUSH
21828: LD_VAR 0 1
21832: PPUSH
21833: CALL_OW 12
21837: ARRAY
21838: PPUSH
21839: CALL_OW 274
21843: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
21844: LD_VAR 0 2
21848: PPUSH
21849: LD_INT 1
21851: PPUSH
21852: LD_INT 0
21854: PPUSH
21855: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
21859: LD_VAR 0 2
21863: PPUSH
21864: LD_INT 2
21866: PPUSH
21867: LD_INT 0
21869: PPUSH
21870: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
21874: LD_VAR 0 2
21878: PPUSH
21879: LD_INT 3
21881: PPUSH
21882: LD_INT 0
21884: PPUSH
21885: CALL_OW 277
// end ;
21889: PPOPN 2
21891: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
21892: LD_EXP 47
21896: PUSH
21897: LD_EXP 73
21901: AND
21902: IFFALSE 21999
21904: GO 21906
21906: DISABLE
21907: LD_INT 0
21909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21910: LD_ADDR_VAR 0 1
21914: PUSH
21915: LD_INT 22
21917: PUSH
21918: LD_OWVAR 2
21922: PUSH
21923: EMPTY
21924: LIST
21925: LIST
21926: PUSH
21927: LD_INT 21
21929: PUSH
21930: LD_INT 1
21932: PUSH
21933: EMPTY
21934: LIST
21935: LIST
21936: PUSH
21937: LD_INT 3
21939: PUSH
21940: LD_INT 23
21942: PUSH
21943: LD_INT 0
21945: PUSH
21946: EMPTY
21947: LIST
21948: LIST
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: PUSH
21954: EMPTY
21955: LIST
21956: LIST
21957: LIST
21958: PPUSH
21959: CALL_OW 69
21963: ST_TO_ADDR
// if not tmp then
21964: LD_VAR 0 1
21968: NOT
21969: IFFALSE 21973
// exit ;
21971: GO 21999
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
21973: LD_VAR 0 1
21977: PUSH
21978: LD_INT 1
21980: PPUSH
21981: LD_VAR 0 1
21985: PPUSH
21986: CALL_OW 12
21990: ARRAY
21991: PPUSH
21992: LD_INT 200
21994: PPUSH
21995: CALL_OW 234
// end ;
21999: PPOPN 1
22001: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
22002: LD_EXP 47
22006: PUSH
22007: LD_EXP 74
22011: AND
22012: IFFALSE 22091
22014: GO 22016
22016: DISABLE
22017: LD_INT 0
22019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
22020: LD_ADDR_VAR 0 1
22024: PUSH
22025: LD_INT 22
22027: PUSH
22028: LD_OWVAR 2
22032: PUSH
22033: EMPTY
22034: LIST
22035: LIST
22036: PUSH
22037: LD_INT 21
22039: PUSH
22040: LD_INT 2
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: PUSH
22047: EMPTY
22048: LIST
22049: LIST
22050: PPUSH
22051: CALL_OW 69
22055: ST_TO_ADDR
// if not tmp then
22056: LD_VAR 0 1
22060: NOT
22061: IFFALSE 22065
// exit ;
22063: GO 22091
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
22065: LD_VAR 0 1
22069: PUSH
22070: LD_INT 1
22072: PPUSH
22073: LD_VAR 0 1
22077: PPUSH
22078: CALL_OW 12
22082: ARRAY
22083: PPUSH
22084: LD_INT 10
22086: PPUSH
22087: CALL_OW 234
// end ;
22091: PPOPN 1
22093: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
22094: LD_EXP 47
22098: PUSH
22099: LD_EXP 75
22103: AND
22104: IFFALSE 22203
22106: GO 22108
22108: DISABLE
22109: LD_INT 0
22111: PPUSH
22112: PPUSH
// begin enable ;
22113: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
22114: LD_ADDR_VAR 0 1
22118: PUSH
22119: LD_INT 22
22121: PUSH
22122: LD_OWVAR 2
22126: PUSH
22127: EMPTY
22128: LIST
22129: LIST
22130: PUSH
22131: LD_INT 61
22133: PUSH
22134: EMPTY
22135: LIST
22136: PUSH
22137: LD_INT 33
22139: PUSH
22140: LD_INT 2
22142: PUSH
22143: EMPTY
22144: LIST
22145: LIST
22146: PUSH
22147: EMPTY
22148: LIST
22149: LIST
22150: LIST
22151: PPUSH
22152: CALL_OW 69
22156: ST_TO_ADDR
// if not tmp then
22157: LD_VAR 0 1
22161: NOT
22162: IFFALSE 22166
// exit ;
22164: GO 22203
// for i in tmp do
22166: LD_ADDR_VAR 0 2
22170: PUSH
22171: LD_VAR 0 1
22175: PUSH
22176: FOR_IN
22177: IFFALSE 22201
// if IsControledBy ( i ) then
22179: LD_VAR 0 2
22183: PPUSH
22184: CALL_OW 312
22188: IFFALSE 22199
// ComUnlink ( i ) ;
22190: LD_VAR 0 2
22194: PPUSH
22195: CALL_OW 136
22199: GO 22176
22201: POP
22202: POP
// end ; end_of_file
22203: PPOPN 2
22205: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
22206: LD_INT 0
22208: PPUSH
22209: PPUSH
22210: PPUSH
22211: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
22212: LD_VAR 0 1
22216: PPUSH
22217: CALL_OW 264
22221: PUSH
22222: LD_EXP 46
22226: EQUAL
22227: IFFALSE 22299
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
22229: LD_INT 68
22231: PPUSH
22232: LD_VAR 0 1
22236: PPUSH
22237: CALL_OW 255
22241: PPUSH
22242: CALL_OW 321
22246: PUSH
22247: LD_INT 2
22249: EQUAL
22250: IFFALSE 22262
// eff := 70 else
22252: LD_ADDR_VAR 0 6
22256: PUSH
22257: LD_INT 70
22259: ST_TO_ADDR
22260: GO 22270
// eff := 30 ;
22262: LD_ADDR_VAR 0 6
22266: PUSH
22267: LD_INT 30
22269: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
22270: LD_VAR 0 1
22274: PPUSH
22275: CALL_OW 250
22279: PPUSH
22280: LD_VAR 0 1
22284: PPUSH
22285: CALL_OW 251
22289: PPUSH
22290: LD_VAR 0 6
22294: PPUSH
22295: CALL_OW 495
// end ; end ;
22299: LD_VAR 0 4
22303: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
22304: LD_INT 0
22306: PPUSH
22307: PPUSH
22308: PPUSH
22309: PPUSH
22310: PPUSH
22311: PPUSH
// if cmd = 124 then
22312: LD_VAR 0 1
22316: PUSH
22317: LD_INT 124
22319: EQUAL
22320: IFFALSE 22526
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
22322: LD_ADDR_VAR 0 5
22326: PUSH
22327: LD_INT 2
22329: PUSH
22330: LD_INT 34
22332: PUSH
22333: LD_INT 53
22335: PUSH
22336: EMPTY
22337: LIST
22338: LIST
22339: PUSH
22340: LD_INT 34
22342: PUSH
22343: LD_INT 14
22345: PUSH
22346: EMPTY
22347: LIST
22348: LIST
22349: PUSH
22350: EMPTY
22351: LIST
22352: LIST
22353: LIST
22354: PPUSH
22355: CALL_OW 69
22359: ST_TO_ADDR
// if not tmp then
22360: LD_VAR 0 5
22364: NOT
22365: IFFALSE 22369
// exit ;
22367: GO 22526
// for i in tmp do
22369: LD_ADDR_VAR 0 3
22373: PUSH
22374: LD_VAR 0 5
22378: PUSH
22379: FOR_IN
22380: IFFALSE 22524
// begin taskList := GetTaskList ( i ) ;
22382: LD_ADDR_VAR 0 6
22386: PUSH
22387: LD_VAR 0 3
22391: PPUSH
22392: CALL_OW 437
22396: ST_TO_ADDR
// if not taskList then
22397: LD_VAR 0 6
22401: NOT
22402: IFFALSE 22406
// continue ;
22404: GO 22379
// for j = 1 to taskList do
22406: LD_ADDR_VAR 0 4
22410: PUSH
22411: DOUBLE
22412: LD_INT 1
22414: DEC
22415: ST_TO_ADDR
22416: LD_VAR 0 6
22420: PUSH
22421: FOR_TO
22422: IFFALSE 22520
// if taskList [ j ] [ 1 ] = | then
22424: LD_VAR 0 6
22428: PUSH
22429: LD_VAR 0 4
22433: ARRAY
22434: PUSH
22435: LD_INT 1
22437: ARRAY
22438: PUSH
22439: LD_STRING |
22441: EQUAL
22442: IFFALSE 22518
// begin _taskList := Delete ( taskList , 1 ) ;
22444: LD_ADDR_VAR 0 7
22448: PUSH
22449: LD_VAR 0 6
22453: PPUSH
22454: LD_INT 1
22456: PPUSH
22457: CALL_OW 3
22461: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
22462: LD_VAR 0 3
22466: PPUSH
22467: LD_VAR 0 7
22471: PPUSH
22472: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
22476: LD_VAR 0 3
22480: PPUSH
22481: LD_VAR 0 6
22485: PUSH
22486: LD_VAR 0 4
22490: ARRAY
22491: PUSH
22492: LD_INT 2
22494: ARRAY
22495: PPUSH
22496: LD_VAR 0 6
22500: PUSH
22501: LD_VAR 0 4
22505: ARRAY
22506: PUSH
22507: LD_INT 3
22509: ARRAY
22510: PPUSH
22511: LD_INT 8
22513: PPUSH
22514: CALL 22531 0 4
// end ;
22518: GO 22421
22520: POP
22521: POP
// end ;
22522: GO 22379
22524: POP
22525: POP
// end ; end ;
22526: LD_VAR 0 2
22530: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22531: LD_INT 0
22533: PPUSH
22534: PPUSH
22535: PPUSH
22536: PPUSH
22537: PPUSH
22538: PPUSH
22539: PPUSH
22540: PPUSH
22541: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22542: LD_VAR 0 1
22546: NOT
22547: PUSH
22548: LD_VAR 0 2
22552: PPUSH
22553: LD_VAR 0 3
22557: PPUSH
22558: CALL_OW 488
22562: NOT
22563: OR
22564: PUSH
22565: LD_VAR 0 4
22569: NOT
22570: OR
22571: IFFALSE 22575
// exit ;
22573: GO 22915
// list := [ ] ;
22575: LD_ADDR_VAR 0 13
22579: PUSH
22580: EMPTY
22581: ST_TO_ADDR
// if x - r < 0 then
22582: LD_VAR 0 2
22586: PUSH
22587: LD_VAR 0 4
22591: MINUS
22592: PUSH
22593: LD_INT 0
22595: LESS
22596: IFFALSE 22608
// min_x := 0 else
22598: LD_ADDR_VAR 0 7
22602: PUSH
22603: LD_INT 0
22605: ST_TO_ADDR
22606: GO 22624
// min_x := x - r ;
22608: LD_ADDR_VAR 0 7
22612: PUSH
22613: LD_VAR 0 2
22617: PUSH
22618: LD_VAR 0 4
22622: MINUS
22623: ST_TO_ADDR
// if y - r < 0 then
22624: LD_VAR 0 3
22628: PUSH
22629: LD_VAR 0 4
22633: MINUS
22634: PUSH
22635: LD_INT 0
22637: LESS
22638: IFFALSE 22650
// min_y := 0 else
22640: LD_ADDR_VAR 0 8
22644: PUSH
22645: LD_INT 0
22647: ST_TO_ADDR
22648: GO 22666
// min_y := y - r ;
22650: LD_ADDR_VAR 0 8
22654: PUSH
22655: LD_VAR 0 3
22659: PUSH
22660: LD_VAR 0 4
22664: MINUS
22665: ST_TO_ADDR
// max_x := x + r ;
22666: LD_ADDR_VAR 0 9
22670: PUSH
22671: LD_VAR 0 2
22675: PUSH
22676: LD_VAR 0 4
22680: PLUS
22681: ST_TO_ADDR
// max_y := y + r ;
22682: LD_ADDR_VAR 0 10
22686: PUSH
22687: LD_VAR 0 3
22691: PUSH
22692: LD_VAR 0 4
22696: PLUS
22697: ST_TO_ADDR
// for _x = min_x to max_x do
22698: LD_ADDR_VAR 0 11
22702: PUSH
22703: DOUBLE
22704: LD_VAR 0 7
22708: DEC
22709: ST_TO_ADDR
22710: LD_VAR 0 9
22714: PUSH
22715: FOR_TO
22716: IFFALSE 22833
// for _y = min_y to max_y do
22718: LD_ADDR_VAR 0 12
22722: PUSH
22723: DOUBLE
22724: LD_VAR 0 8
22728: DEC
22729: ST_TO_ADDR
22730: LD_VAR 0 10
22734: PUSH
22735: FOR_TO
22736: IFFALSE 22829
// begin if not ValidHex ( _x , _y ) then
22738: LD_VAR 0 11
22742: PPUSH
22743: LD_VAR 0 12
22747: PPUSH
22748: CALL_OW 488
22752: NOT
22753: IFFALSE 22757
// continue ;
22755: GO 22735
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22757: LD_VAR 0 11
22761: PPUSH
22762: LD_VAR 0 12
22766: PPUSH
22767: CALL_OW 351
22771: PUSH
22772: LD_VAR 0 11
22776: PPUSH
22777: LD_VAR 0 12
22781: PPUSH
22782: CALL_OW 554
22786: AND
22787: IFFALSE 22827
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22789: LD_ADDR_VAR 0 13
22793: PUSH
22794: LD_VAR 0 13
22798: PPUSH
22799: LD_VAR 0 13
22803: PUSH
22804: LD_INT 1
22806: PLUS
22807: PPUSH
22808: LD_VAR 0 11
22812: PUSH
22813: LD_VAR 0 12
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: PPUSH
22822: CALL_OW 2
22826: ST_TO_ADDR
// end ;
22827: GO 22735
22829: POP
22830: POP
22831: GO 22715
22833: POP
22834: POP
// if not list then
22835: LD_VAR 0 13
22839: NOT
22840: IFFALSE 22844
// exit ;
22842: GO 22915
// for i in list do
22844: LD_ADDR_VAR 0 6
22848: PUSH
22849: LD_VAR 0 13
22853: PUSH
22854: FOR_IN
22855: IFFALSE 22913
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22857: LD_VAR 0 1
22861: PPUSH
22862: LD_STRING M
22864: PUSH
22865: LD_VAR 0 6
22869: PUSH
22870: LD_INT 1
22872: ARRAY
22873: PUSH
22874: LD_VAR 0 6
22878: PUSH
22879: LD_INT 2
22881: ARRAY
22882: PUSH
22883: LD_INT 0
22885: PUSH
22886: LD_INT 0
22888: PUSH
22889: LD_INT 0
22891: PUSH
22892: LD_INT 0
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: LIST
22899: LIST
22900: LIST
22901: LIST
22902: LIST
22903: PUSH
22904: EMPTY
22905: LIST
22906: PPUSH
22907: CALL_OW 447
22911: GO 22854
22913: POP
22914: POP
// end ;
22915: LD_VAR 0 5
22919: RET
