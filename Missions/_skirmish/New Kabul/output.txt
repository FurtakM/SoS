// export side_Neutral , side_Ru , side_Ru2 , side_Ar , side_Xavier , side_Heike , side_Strazci ; export VsevSaved , HeikeCaptured ; export Burlak , Vsevolod , Popov , Yelena , Gleb , Petrosyan , Karamazov , Petrovova , Dolgov , Titov , Platonov , Lipshchin ; export Rusaci , WithVsevolod ; export Konvoj ; export Xavier , Heike , Heikeovci ; export ContactIn5Min , PropaslQuickly ; export Minuty ; var FalesnaYelena ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: NOP4
   7: PPUSH
   8: NOP4
  12: IFFALSE 59
// begin Result = CreateCharacter ( Ident ) ;
  14: NOP4
  18: PUSH
  19: NOP4
  23: PPUSH
  24: NOP4
  28: ST_TO_ADDR
// if IsDead ( Result ) then
  29: NOP4
  33: PPUSH
  34: NOP4
  38: IFFALSE 57
// begin DestroyUnit ( Result ) ;
  40: NOP4
  44: PPUSH
  45: NOP4
// Result = 0 ;
  49: NOP4
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// end ; end else
  57: GO 74
// Result = NewCharacter ( Ident ) ;
  59: NOP4
  63: PUSH
  64: NOP4
  68: PPUSH
  69: NOP4
  73: ST_TO_ADDR
// end ;
  74: LD_VAR 0 2
  78: RET
// function load_set ( Ident ) ; begin
  79: LD_INT 0
  81: PPUSH
// if TestCharacters ( Ident ) then
  82: NOP4
  86: PPUSH
  87: NOP4
  91: IFFALSE 110
// Result = CreateCharacterSet ( Ident ) else
  93: NOP4
  97: PUSH
  98: NOP4
 102: PPUSH
 103: NOP4
 107: ST_TO_ADDR
 108: GO 117
// Result = [ ] ;
 110: NOP4
 114: PUSH
 115: EMPTY
 116: ST_TO_ADDR
// end ;
 117: LD_VAR 0 2
 121: RET
// function save_char ( Handle , Ident ) ; begin
 122: LD_INT 0
 124: PPUSH
// if Handle then
 125: NOP4
 129: IFFALSE 148
// SaveCharacters ( [ Handle ] , Ident ) ;
 131: NOP4
 135: PUSH
 136: EMPTY
 137: LIST
 138: PPUSH
 139: NOP4
 143: PPUSH
 144: NOP4
// end ;
 148: LD_VAR 0 3
 152: RET
// function vytvor_yelenu ; begin
 153: LD_INT 0
 155: PPUSH
// UC_Nation = NATION_RUSSIAN ;
 156: LD_ADDR_OWVAR 21
 160: PUSH
 161: LD_INT 3
 163: ST_TO_ADDR
// UC_Side = side_Ru2 ;
 164: LD_ADDR_OWVAR 20
 168: PUSH
 169: NOP4
 173: ST_TO_ADDR
// HC_name = Yelena Trajkov ;
 174: LD_ADDR_OWVAR 26
 178: PUSH
 179: LD_STRING Yelena Trajkov
 181: ST_TO_ADDR
// HC_sex = SEX_FEMALE ;
 182: LD_ADDR_OWVAR 27
 186: PUSH
 187: LD_INT 2
 189: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 190: LD_ADDR_OWVAR 28
 194: PUSH
 195: LD_INT 1
 197: ST_TO_ADDR
// PrepareSoldierSkills ( 5 ) ;
 198: LD_INT 5
 200: PPUSH
 201: NOP4
// Result = CreateHuman ;
 205: NOP4
 209: PUSH
 210: NOP4
 214: ST_TO_ADDR
// end ;
 215: LD_VAR 0 1
 219: RET
// function load_konvoj ; var Convoy_06 , Spec , Tmp ; var MaxCnt , MaxCans , MaxOil , MaxSib , Cans , Oil , Sib ; var TedCans , TedOil , TedSib ; begin
 220: LD_INT 0
 222: PPUSH
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
 235: PPUSH
// Convoy_06 = LoadVariable ( Convoy_06 , [ ] ) ;
 236: NOP4
 240: PUSH
 241: LD_STRING Convoy_06
 243: PPUSH
 244: EMPTY
 245: PPUSH
 246: NOP4
 250: ST_TO_ADDR
// DeleteVariable ( Convoy_06 ) ;
 251: LD_STRING Convoy_06
 253: PPUSH
 254: NOP4
// if not Convoy_06 then
 258: NOP4
 262: NOT
 263: IFFALSE 377
// Convoy_06 = [ [ NATION_RUSSIAN , RU_HEAVY_MACHINE_GUN , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 0 , 0 , 0 ] , [ NATION_RUSSIAN , RU_CARGO_BAY , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 30 , 50 , 20 ] , [ NATION_RUSSIAN , RU_CARGO_BAY , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 40 , 50 , 10 ] ] ;
 265: NOP4
 269: PUSH
 270: LD_INT 3
 272: PUSH
 273: LD_INT 42
 275: PUSH
 276: LD_INT 1
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 21
 284: PUSH
 285: LD_INT 0
 287: PUSH
 288: LD_INT 0
 290: PUSH
 291: LD_INT 0
 293: PUSH
 294: EMPTY
 295: LIST
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_INT 3
 306: PUSH
 307: LD_INT 51
 309: PUSH
 310: LD_INT 1
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 30
 321: PUSH
 322: LD_INT 50
 324: PUSH
 325: LD_INT 20
 327: PUSH
 328: EMPTY
 329: LIST
 330: LIST
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: LIST
 336: LIST
 337: PUSH
 338: LD_INT 3
 340: PUSH
 341: LD_INT 51
 343: PUSH
 344: LD_INT 1
 346: PUSH
 347: LD_INT 1
 349: PUSH
 350: LD_INT 21
 352: PUSH
 353: LD_INT 40
 355: PUSH
 356: LD_INT 50
 358: PUSH
 359: LD_INT 10
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: LIST
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: LIST
 376: ST_TO_ADDR
// UC_Side = side_Ru ;
 377: LD_ADDR_OWVAR 20
 381: PUSH
 382: NOP4
 386: ST_TO_ADDR
// Konvoj = [ ] ;
 387: NOP4
 391: PUSH
 392: EMPTY
 393: ST_TO_ADDR
// Tmp = dif_MaxKonvojCargo [ Difficulty ] ;
 394: NOP4
 398: PUSH
 399: NOP4
 403: PUSH
 404: NOP4
 408: ARRAY
 409: ST_TO_ADDR
// MaxCnt = Tmp [ 1 ] ;
 410: NOP4
 414: PUSH
 415: NOP4
 419: PUSH
 420: LD_INT 1
 422: ARRAY
 423: ST_TO_ADDR
// MaxCans = Tmp [ 2 ] ;
 424: NOP4
 428: PUSH
 429: NOP4
 433: PUSH
 434: LD_INT 2
 436: ARRAY
 437: ST_TO_ADDR
// MaxOil = Tmp [ 3 ] ;
 438: NOP4
 442: PUSH
 443: NOP4
 447: PUSH
 448: LD_INT 3
 450: ARRAY
 451: ST_TO_ADDR
// MaxSib = Tmp [ 4 ] ;
 452: NOP4
 456: PUSH
 457: NOP4
 461: PUSH
 462: LD_INT 4
 464: ARRAY
 465: ST_TO_ADDR
// for Spec in Convoy_06 do
 466: NOP4
 470: PUSH
 471: NOP4
 475: PUSH
 476: FOR_IN
 477: IFFALSE 657
// begin UC_Nation = Spec [ 1 ] ;
 479: LD_ADDR_OWVAR 21
 483: PUSH
 484: NOP4
 488: PUSH
 489: LD_INT 1
 491: ARRAY
 492: ST_TO_ADDR
// VC_Weapon = Spec [ 2 ] ;
 493: LD_ADDR_OWVAR 40
 497: PUSH
 498: NOP4
 502: PUSH
 503: LD_INT 2
 505: ARRAY
 506: ST_TO_ADDR
// VC_Control = Spec [ 3 ] ;
 507: LD_ADDR_OWVAR 38
 511: PUSH
 512: NOP4
 516: PUSH
 517: LD_INT 3
 519: ARRAY
 520: ST_TO_ADDR
// VC_Engine = Spec [ 4 ] ;
 521: LD_ADDR_OWVAR 39
 525: PUSH
 526: NOP4
 530: PUSH
 531: LD_INT 4
 533: ARRAY
 534: ST_TO_ADDR
// VC_Chassis = Spec [ 5 ] ;
 535: LD_ADDR_OWVAR 37
 539: PUSH
 540: NOP4
 544: PUSH
 545: LD_INT 5
 547: ARRAY
 548: ST_TO_ADDR
// Tmp = CreateVehicle ;
 549: NOP4
 553: PUSH
 554: NOP4
 558: ST_TO_ADDR
// AddCargo ( Tmp , MAT_CANS , Spec [ 6 ] ) ;
 559: NOP4
 563: PPUSH
 564: LD_INT 1
 566: PPUSH
 567: NOP4
 571: PUSH
 572: LD_INT 6
 574: ARRAY
 575: PPUSH
 576: NOP4
// AddCargo ( Tmp , MAT_OIL , Spec [ 7 ] ) ;
 580: NOP4
 584: PPUSH
 585: LD_INT 2
 587: PPUSH
 588: NOP4
 592: PUSH
 593: LD_INT 7
 595: ARRAY
 596: PPUSH
 597: NOP4
// AddCargo ( Tmp , MAT_SIBERIT , Spec [ 8 ] ) ;
 601: NOP4
 605: PPUSH
 606: LD_INT 3
 608: PPUSH
 609: NOP4
 613: PUSH
 614: LD_INT 8
 616: ARRAY
 617: PPUSH
 618: NOP4
// Konvoj = Konvoj union [ Tmp ] ;
 622: NOP4
 626: PUSH
 627: NOP4
 631: PUSH
 632: NOP4
 636: PUSH
 637: EMPTY
 638: LIST
 639: UNION
 640: ST_TO_ADDR
// if Konvoj >= MaxCnt then
 641: NOP4
 645: PUSH
 646: NOP4
 650: GREATEREQUAL
 651: IFFALSE 655
// break ;
 653: GO 657
// end ;
 655: GO 476
 657: POP
 658: POP
// Cans = 0 ;
 659: NOP4
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// Oil = 0 ;
 667: NOP4
 671: PUSH
 672: LD_INT 0
 674: ST_TO_ADDR
// Sib = 0 ;
 675: NOP4
 679: PUSH
 680: LD_INT 0
 682: ST_TO_ADDR
// for Spec in Konvoj do
 683: NOP4
 687: PUSH
 688: NOP4
 692: PUSH
 693: FOR_IN
 694: IFFALSE 998
// begin TedCans = GetCargo ( Spec , MAT_CANS ) ;
 696: NOP4
 700: PUSH
 701: NOP4
 705: PPUSH
 706: LD_INT 1
 708: PPUSH
 709: NOP4
 713: ST_TO_ADDR
// TedOil = GetCargo ( Spec , MAT_OIL ) ;
 714: NOP4
 718: PUSH
 719: NOP4
 723: PPUSH
 724: LD_INT 2
 726: PPUSH
 727: NOP4
 731: ST_TO_ADDR
// TedSib = GetCargo ( Spec , MAT_SIBERIT ) ;
 732: NOP4
 736: PUSH
 737: NOP4
 741: PPUSH
 742: LD_INT 3
 744: PPUSH
 745: NOP4
 749: ST_TO_ADDR
// if Cans + TedCans > MaxCans then
 750: NOP4
 754: PUSH
 755: NOP4
 759: PLUS
 760: PUSH
 761: NOP4
 765: GREATER
 766: IFFALSE 784
// TedCans = MaxCans - Cans ;
 768: NOP4
 772: PUSH
 773: NOP4
 777: PUSH
 778: NOP4
 782: MINUS
 783: ST_TO_ADDR
// if Oil + TedOil > MaxOil then
 784: NOP4
 788: PUSH
 789: NOP4
 793: PLUS
 794: PUSH
 795: NOP4
 799: GREATER
 800: IFFALSE 818
// TedOil = MaxOil - Oil ;
 802: NOP4
 806: PUSH
 807: NOP4
 811: PUSH
 812: NOP4
 816: MINUS
 817: ST_TO_ADDR
// if Sib + TedSib > MaxSib then
 818: NOP4
 822: PUSH
 823: NOP4
 827: PLUS
 828: PUSH
 829: NOP4
 833: GREATER
 834: IFFALSE 852
// TedSib = MaxSib - Sib ;
 836: NOP4
 840: PUSH
 841: NOP4
 845: PUSH
 846: NOP4
 850: MINUS
 851: ST_TO_ADDR
// SetCargo ( Spec , MAT_CANS , 0 ) ;
 852: NOP4
 856: PPUSH
 857: LD_INT 1
 859: PPUSH
 860: LD_INT 0
 862: PPUSH
 863: NOP4
// SetCargo ( Spec , MAT_OIL , 0 ) ;
 867: NOP4
 871: PPUSH
 872: LD_INT 2
 874: PPUSH
 875: LD_INT 0
 877: PPUSH
 878: NOP4
// SetCargo ( Spec , MAT_SIBERIT , 0 ) ;
 882: NOP4
 886: PPUSH
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: NOP4
// AddCargo ( Spec , MAT_CANS , TedCans ) ;
 897: NOP4
 901: PPUSH
 902: LD_INT 1
 904: PPUSH
 905: NOP4
 909: PPUSH
 910: NOP4
// AddCargo ( Spec , MAT_SIBERIT , TedSib ) ;
 914: NOP4
 918: PPUSH
 919: LD_INT 3
 921: PPUSH
 922: NOP4
 926: PPUSH
 927: NOP4
// AddCargo ( Spec , MAT_OIL , TedOil ) ;
 931: NOP4
 935: PPUSH
 936: LD_INT 2
 938: PPUSH
 939: NOP4
 943: PPUSH
 944: NOP4
// Cans = Cans + TedCans ;
 948: NOP4
 952: PUSH
 953: NOP4
 957: PUSH
 958: NOP4
 962: PLUS
 963: ST_TO_ADDR
// Oil = Oil + TedOil ;
 964: NOP4
 968: PUSH
 969: NOP4
 973: PUSH
 974: NOP4
 978: PLUS
 979: ST_TO_ADDR
// Sib = Sib + TedSib ;
 980: NOP4
 984: PUSH
 985: NOP4
 989: PUSH
 990: NOP4
 994: PLUS
 995: ST_TO_ADDR
// end ;
 996: GO 693
 998: POP
 999: POP
// end ;
1000: LD_VAR 0 1
1004: RET
// function load ; begin
1005: LD_INT 0
1007: PPUSH
// UC_Nation = NATION_RUSSIAN ;
1008: LD_ADDR_OWVAR 21
1012: PUSH
1013: LD_INT 3
1015: ST_TO_ADDR
// UC_Side = side_Ru ;
1016: LD_ADDR_OWVAR 20
1020: PUSH
1021: NOP4
1025: ST_TO_ADDR
// VsevSaved = LoadVariable ( VsevSaved , false ) ;
1026: NOP4
1030: PUSH
1031: LD_STRING VsevSaved
1033: PPUSH
1034: LD_INT 0
1036: PPUSH
1037: NOP4
1041: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
1042: NOP4
1046: PUSH
1047: LD_STRING Burlak
1049: PPUSH
1050: NOP4
1054: ST_TO_ADDR
// Vsevolod = load_char ( Vsevolod ) ;
1055: NOP4
1059: PUSH
1060: LD_STRING Vsevolod
1062: PPUSH
1063: NOP4
1067: ST_TO_ADDR
// if IsDead ( Vsevolod ) then
1068: NOP4
1072: PPUSH
1073: NOP4
1077: IFFALSE 1087
// VsevSaved = false ;
1079: NOP4
1083: PUSH
1084: LD_INT 0
1086: ST_TO_ADDR
// Yelena = load_char ( Kirilenkova ) ;
1087: NOP4
1091: PUSH
1092: LD_STRING Kirilenkova
1094: PPUSH
1095: NOP4
1099: ST_TO_ADDR
// if not Yelena or IsDead ( Yelena ) then
1100: NOP4
1104: NOT
1105: PUSH
1106: NOP4
1110: PPUSH
1111: NOP4
1115: OR
1116: IFFALSE 1138
// begin Yelena = vytvor_yelenu ;
1118: NOP4
1122: PUSH
1123: NOP4
1127: ST_TO_ADDR
// FalesnaYelena = true ;
1128: NOP4
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// end else
1136: GO 1146
// FalesnaYelena = false ;
1138: NOP4
1142: PUSH
1143: LD_INT 0
1145: ST_TO_ADDR
// if VsevSaved then
1146: NOP4
1150: IFFALSE 1158
// load_vs else
1152: NOP4
1156: GO 1162
// load_nv ;
1158: NOP4
// end ;
1162: LD_VAR 0 1
1166: RET
// function load_nv ; var Ostatni ; begin
1167: LD_INT 0
1169: PPUSH
1170: PPUSH
// Karamazov = load_char ( Karamazov ) ;
1171: NOP4
1175: PUSH
1176: LD_STRING Karamazov
1178: PPUSH
1179: NOP4
1183: ST_TO_ADDR
// Petrovova = load_char ( Petrovova ) ;
1184: NOP4
1188: PUSH
1189: LD_STRING Petrovova
1191: PPUSH
1192: NOP4
1196: ST_TO_ADDR
// Gleb = load_char ( Gleb ) ;
1197: NOP4
1201: PUSH
1202: LD_STRING Gleb
1204: PPUSH
1205: NOP4
1209: ST_TO_ADDR
// Petrosyan = load_char ( Petrosyan ) ;
1210: NOP4
1214: PUSH
1215: LD_STRING Petrosyan
1217: PPUSH
1218: NOP4
1222: ST_TO_ADDR
// Lipshchin = load_char ( Lipshchin ) ;
1223: NOP4
1227: PUSH
1228: LD_STRING Lipshchin
1230: PPUSH
1231: NOP4
1235: ST_TO_ADDR
// Titov = load_char ( Titov ) ;
1236: NOP4
1240: PUSH
1241: LD_STRING Titov
1243: PPUSH
1244: NOP4
1248: ST_TO_ADDR
// Dolgov = load_char ( Dolgov ) ;
1249: NOP4
1253: PUSH
1254: LD_STRING Dolgov
1256: PPUSH
1257: NOP4
1261: ST_TO_ADDR
// Popov = NewCharacter ( Popov ) ;
1262: NOP4
1266: PUSH
1267: LD_STRING Popov
1269: PPUSH
1270: NOP4
1274: ST_TO_ADDR
// Platonov = NewCharacter ( Platonov ) ;
1275: NOP4
1279: PUSH
1280: LD_STRING Platonov
1282: PPUSH
1283: NOP4
1287: ST_TO_ADDR
// Ostatni = load_set ( Survivors2 ) ;
1288: NOP4
1292: PUSH
1293: LD_STRING Survivors2
1295: PPUSH
1296: NOP4
1300: ST_TO_ADDR
// Rusaci = Ostatni union [ Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov ] diff [ 0 ] ;
1301: NOP4
1305: PUSH
1306: NOP4
1310: PUSH
1311: NOP4
1315: PUSH
1316: NOP4
1320: PUSH
1321: NOP4
1325: PUSH
1326: NOP4
1330: PUSH
1331: NOP4
1335: PUSH
1336: NOP4
1340: PUSH
1341: NOP4
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: UNION
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: DIFF
1362: ST_TO_ADDR
// SetSide ( Rusaci , side_Ru ) ;
1363: NOP4
1367: PPUSH
1368: NOP4
1372: PPUSH
1373: NOP4
// end ;
1377: LD_VAR 0 1
1381: RET
// function load_vs ; var Ostatni ; var KaramazovLoc , PetrovovaLoc , GlebLoc , PetrosyanLoc ; var LipshchinLoc , TitovLoc , DolgovLoc ; begin
1382: LD_INT 0
1384: PPUSH
1385: PPUSH
1386: PPUSH
1387: PPUSH
1388: PPUSH
1389: PPUSH
1390: PPUSH
1391: PPUSH
1392: PPUSH
// KaramazovLoc = LoadVariable ( KaramazovLoc , 0 ) ;
1393: NOP4
1397: PUSH
1398: LD_STRING KaramazovLoc
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: NOP4
1408: ST_TO_ADDR
// PetrovovaLoc = LoadVariable ( PetrovovaLoc , 0 ) ;
1409: NOP4
1413: PUSH
1414: LD_STRING PetrovovaLoc
1416: PPUSH
1417: LD_INT 0
1419: PPUSH
1420: NOP4
1424: ST_TO_ADDR
// GlebLoc = LoadVariable ( GlebLoc , 0 ) ;
1425: NOP4
1429: PUSH
1430: LD_STRING GlebLoc
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: NOP4
1440: ST_TO_ADDR
// PetrosyanLoc = LoadVariable ( PetrosyanLoc , 0 ) ;
1441: NOP4
1445: PUSH
1446: LD_STRING PetrosyanLoc
1448: PPUSH
1449: LD_INT 0
1451: PPUSH
1452: NOP4
1456: ST_TO_ADDR
// LipshchinLoc = LoadVariable ( LipshchinLoc , 0 ) ;
1457: NOP4
1461: PUSH
1462: LD_STRING LipshchinLoc
1464: PPUSH
1465: LD_INT 0
1467: PPUSH
1468: NOP4
1472: ST_TO_ADDR
// TitovLoc = LoadVariable ( TitovLoc , 0 ) ;
1473: NOP4
1477: PUSH
1478: LD_STRING TitovLoc
1480: PPUSH
1481: LD_INT 0
1483: PPUSH
1484: NOP4
1488: ST_TO_ADDR
// DolgovLoc = LoadVariable ( DolgovLoc , 0 ) ;
1489: NOP4
1493: PUSH
1494: LD_STRING DolgovLoc
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: NOP4
1504: ST_TO_ADDR
// if KaramazovLoc in [ 7 , - 7 ] then
1505: NOP4
1509: PUSH
1510: LD_INT 7
1512: PUSH
1513: LD_INT 7
1515: NEG
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: IN
1521: IFFALSE 1536
// Karamazov = load_char ( Karamazov ) ;
1523: NOP4
1527: PUSH
1528: LD_STRING Karamazov
1530: PPUSH
1531: NOP4
1535: ST_TO_ADDR
// if PetrovovaLoc in [ 7 , - 7 ] then
1536: NOP4
1540: PUSH
1541: LD_INT 7
1543: PUSH
1544: LD_INT 7
1546: NEG
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: IN
1552: IFFALSE 1567
// Petrovova = load_char ( Petrovova ) ;
1554: NOP4
1558: PUSH
1559: LD_STRING Petrovova
1561: PPUSH
1562: NOP4
1566: ST_TO_ADDR
// if GlebLoc in [ 7 , - 7 ] then
1567: NOP4
1571: PUSH
1572: LD_INT 7
1574: PUSH
1575: LD_INT 7
1577: NEG
1578: PUSH
1579: EMPTY
1580: LIST
1581: LIST
1582: IN
1583: IFFALSE 1598
// Gleb = load_char ( Gleb ) ;
1585: NOP4
1589: PUSH
1590: LD_STRING Gleb
1592: PPUSH
1593: NOP4
1597: ST_TO_ADDR
// if PetrosyanLoc in [ 7 , - 7 ] then
1598: NOP4
1602: PUSH
1603: LD_INT 7
1605: PUSH
1606: LD_INT 7
1608: NEG
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: IN
1614: IFFALSE 1629
// Petrosyan = load_char ( Petrosyan ) ;
1616: NOP4
1620: PUSH
1621: LD_STRING Petrosyan
1623: PPUSH
1624: NOP4
1628: ST_TO_ADDR
// if LipshchinLoc in [ 7 , - 7 ] then
1629: NOP4
1633: PUSH
1634: LD_INT 7
1636: PUSH
1637: LD_INT 7
1639: NEG
1640: PUSH
1641: EMPTY
1642: LIST
1643: LIST
1644: IN
1645: IFFALSE 1660
// Lipshchin = load_char ( Lipshchin ) ;
1647: NOP4
1651: PUSH
1652: LD_STRING Lipshchin
1654: PPUSH
1655: NOP4
1659: ST_TO_ADDR
// if TitovLoc in [ 7 , - 7 ] then
1660: NOP4
1664: PUSH
1665: LD_INT 7
1667: PUSH
1668: LD_INT 7
1670: NEG
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: IN
1676: IFFALSE 1691
// Titov = load_char ( Titov ) ;
1678: NOP4
1682: PUSH
1683: LD_STRING Titov
1685: PPUSH
1686: NOP4
1690: ST_TO_ADDR
// if DolgovLoc in [ 7 , - 7 ] then
1691: NOP4
1695: PUSH
1696: LD_INT 7
1698: PUSH
1699: LD_INT 7
1701: NEG
1702: PUSH
1703: EMPTY
1704: LIST
1705: LIST
1706: IN
1707: IFFALSE 1722
// Dolgov = load_char ( Dolgov ) ;
1709: NOP4
1713: PUSH
1714: LD_STRING Dolgov
1716: PPUSH
1717: NOP4
1721: ST_TO_ADDR
// Ostatni = load_set ( Survivors2 ) ;
1722: NOP4
1726: PUSH
1727: LD_STRING Survivors2
1729: PPUSH
1730: NOP4
1734: ST_TO_ADDR
// Popov = NewCharacter ( Popov ) ;
1735: NOP4
1739: PUSH
1740: LD_STRING Popov
1742: PPUSH
1743: NOP4
1747: ST_TO_ADDR
// Platonov = NewCharacter ( Platonov ) ;
1748: NOP4
1752: PUSH
1753: LD_STRING Platonov
1755: PPUSH
1756: NOP4
1760: ST_TO_ADDR
// WithVsevolod = [ Yelena ] union load_set ( WithVsevolod ) ;
1761: NOP4
1765: PUSH
1766: NOP4
1770: PUSH
1771: EMPTY
1772: LIST
1773: PUSH
1774: LD_STRING WithVsevolod
1776: PPUSH
1777: NOP4
1781: UNION
1782: ST_TO_ADDR
// Rusaci = Ostatni ;
1783: NOP4
1787: PUSH
1788: NOP4
1792: ST_TO_ADDR
// if KaramazovLoc = 7 then
1793: NOP4
1797: PUSH
1798: LD_INT 7
1800: EQUAL
1801: IFFALSE 1824
// Rusaci = Rusaci union [ Karamazov ] else
1803: NOP4
1807: PUSH
1808: NOP4
1812: PUSH
1813: NOP4
1817: PUSH
1818: EMPTY
1819: LIST
1820: UNION
1821: ST_TO_ADDR
1822: GO 1854
// if KaramazovLoc = - 7 then
1824: NOP4
1828: PUSH
1829: LD_INT 7
1831: NEG
1832: EQUAL
1833: IFFALSE 1854
// WithVsevolod = WithVsevolod union [ Karamazov ] ;
1835: NOP4
1839: PUSH
1840: NOP4
1844: PUSH
1845: NOP4
1849: PUSH
1850: EMPTY
1851: LIST
1852: UNION
1853: ST_TO_ADDR
// if PetrovovaLoc = 7 then
1854: NOP4
1858: PUSH
1859: LD_INT 7
1861: EQUAL
1862: IFFALSE 1885
// Rusaci = Rusaci union [ Petrovova ] else
1864: NOP4
1868: PUSH
1869: NOP4
1873: PUSH
1874: NOP4
1878: PUSH
1879: EMPTY
1880: LIST
1881: UNION
1882: ST_TO_ADDR
1883: GO 1915
// if PetrovovaLoc = - 7 then
1885: NOP4
1889: PUSH
1890: LD_INT 7
1892: NEG
1893: EQUAL
1894: IFFALSE 1915
// WithVsevolod = WithVsevolod union [ Petrovova ] ;
1896: NOP4
1900: PUSH
1901: NOP4
1905: PUSH
1906: NOP4
1910: PUSH
1911: EMPTY
1912: LIST
1913: UNION
1914: ST_TO_ADDR
// if GlebLoc = 7 then
1915: NOP4
1919: PUSH
1920: LD_INT 7
1922: EQUAL
1923: IFFALSE 1946
// Rusaci = Rusaci union [ Gleb ] else
1925: NOP4
1929: PUSH
1930: NOP4
1934: PUSH
1935: NOP4
1939: PUSH
1940: EMPTY
1941: LIST
1942: UNION
1943: ST_TO_ADDR
1944: GO 1976
// if GlebLoc = - 7 then
1946: NOP4
1950: PUSH
1951: LD_INT 7
1953: NEG
1954: EQUAL
1955: IFFALSE 1976
// WithVsevolod = WithVsevolod union [ Gleb ] ;
1957: NOP4
1961: PUSH
1962: NOP4
1966: PUSH
1967: NOP4
1971: PUSH
1972: EMPTY
1973: LIST
1974: UNION
1975: ST_TO_ADDR
// if PetrosyanLoc = 7 then
1976: NOP4
1980: PUSH
1981: LD_INT 7
1983: EQUAL
1984: IFFALSE 2007
// Rusaci = Rusaci union [ Petrosyan ] else
1986: NOP4
1990: PUSH
1991: NOP4
1995: PUSH
1996: NOP4
2000: PUSH
2001: EMPTY
2002: LIST
2003: UNION
2004: ST_TO_ADDR
2005: GO 2037
// if PetrosyanLoc = - 7 then
2007: NOP4
2011: PUSH
2012: LD_INT 7
2014: NEG
2015: EQUAL
2016: IFFALSE 2037
// WithVsevolod = WithVsevolod union [ Petrosyan ] ;
2018: NOP4
2022: PUSH
2023: NOP4
2027: PUSH
2028: NOP4
2032: PUSH
2033: EMPTY
2034: LIST
2035: UNION
2036: ST_TO_ADDR
// if LipshchinLoc = 7 then
2037: NOP4
2041: PUSH
2042: LD_INT 7
2044: EQUAL
2045: IFFALSE 2068
// Rusaci = Rusaci union [ Lipshchin ] else
2047: NOP4
2051: PUSH
2052: NOP4
2056: PUSH
2057: NOP4
2061: PUSH
2062: EMPTY
2063: LIST
2064: UNION
2065: ST_TO_ADDR
2066: GO 2098
// if LipshchinLoc = - 7 then
2068: NOP4
2072: PUSH
2073: LD_INT 7
2075: NEG
2076: EQUAL
2077: IFFALSE 2098
// WithVsevolod = WithVsevolod union [ Lipshchin ] ;
2079: NOP4
2083: PUSH
2084: NOP4
2088: PUSH
2089: NOP4
2093: PUSH
2094: EMPTY
2095: LIST
2096: UNION
2097: ST_TO_ADDR
// if TitovLoc = 7 then
2098: NOP4
2102: PUSH
2103: LD_INT 7
2105: EQUAL
2106: IFFALSE 2129
// Rusaci = Rusaci union [ Titov ] else
2108: NOP4
2112: PUSH
2113: NOP4
2117: PUSH
2118: NOP4
2122: PUSH
2123: EMPTY
2124: LIST
2125: UNION
2126: ST_TO_ADDR
2127: GO 2159
// if TitovLoc = - 7 then
2129: NOP4
2133: PUSH
2134: LD_INT 7
2136: NEG
2137: EQUAL
2138: IFFALSE 2159
// WithVsevolod = WithVsevolod union [ Titov ] ;
2140: NOP4
2144: PUSH
2145: NOP4
2149: PUSH
2150: NOP4
2154: PUSH
2155: EMPTY
2156: LIST
2157: UNION
2158: ST_TO_ADDR
// if DolgovLoc = 7 then
2159: NOP4
2163: PUSH
2164: LD_INT 7
2166: EQUAL
2167: IFFALSE 2190
// Rusaci = Rusaci union [ Dolgov ] else
2169: NOP4
2173: PUSH
2174: NOP4
2178: PUSH
2179: NOP4
2183: PUSH
2184: EMPTY
2185: LIST
2186: UNION
2187: ST_TO_ADDR
2188: GO 2220
// if DolgovLoc = - 7 then
2190: NOP4
2194: PUSH
2195: LD_INT 7
2197: NEG
2198: EQUAL
2199: IFFALSE 2220
// WithVsevolod = WithVsevolod union [ Dolgov ] ;
2201: NOP4
2205: PUSH
2206: NOP4
2210: PUSH
2211: NOP4
2215: PUSH
2216: EMPTY
2217: LIST
2218: UNION
2219: ST_TO_ADDR
// while ( Rusaci union WithVsevolod ) < 6 do
2220: NOP4
2224: PUSH
2225: NOP4
2229: UNION
2230: PUSH
2231: LD_INT 6
2233: LESS
2234: IFFALSE 2257
// WithVsevolod = WithVsevolod union [ vytvor_rusaka ] ;
2236: NOP4
2240: PUSH
2241: NOP4
2245: PUSH
2246: NOP4
2250: PUSH
2251: EMPTY
2252: LIST
2253: UNION
2254: ST_TO_ADDR
2255: GO 2220
// load_konvoj ;
2257: NOP4
// SetSide ( Rusaci , side_Ru ) ;
2261: NOP4
2265: PPUSH
2266: NOP4
2270: PPUSH
2271: NOP4
// SetSide ( Konvoj , side_Ru ) ;
2275: NOP4
2279: PPUSH
2280: NOP4
2284: PPUSH
2285: NOP4
// SetSide ( Vsevolod , side_Ru2 ) ;
2289: NOP4
2293: PPUSH
2294: NOP4
2298: PPUSH
2299: NOP4
// SetSide ( WithVsevolod , side_Ru2 ) ;
2303: NOP4
2307: PPUSH
2308: NOP4
2312: PPUSH
2313: NOP4
// end ;
2317: LD_VAR 0 1
2321: RET
// function save ; var Lidi , Ostatni , Opice ; begin
2322: LD_INT 0
2324: PPUSH
2325: PPUSH
2326: PPUSH
2327: PPUSH
// DeleteVariable ( Convoy_06 ) ;
2328: LD_STRING Convoy_06
2330: PPUSH
2331: NOP4
// HeikeCaptured = Heike and IsOK ( Heike ) ;
2335: NOP4
2339: PUSH
2340: NOP4
2344: PUSH
2345: NOP4
2349: PPUSH
2350: NOP4
2354: AND
2355: ST_TO_ADDR
// SaveVariable ( HeikeCaptured , HeikeCaptured ) ;
2356: NOP4
2360: PPUSH
2361: LD_STRING HeikeCaptured
2363: PPUSH
2364: NOP4
// SaveVariable ( not HeikeCaptured , HeikeKilled ) ;
2368: NOP4
2372: NOT
2373: PPUSH
2374: LD_STRING HeikeKilled
2376: PPUSH
2377: NOP4
// save_char ( Burlak , Burlak ) ;
2381: NOP4
2385: PPUSH
2386: LD_STRING Burlak
2388: PPUSH
2389: NOP4
// if not FalesnaYelena then
2393: NOP4
2397: NOT
2398: IFFALSE 2412
// save_char ( Yelena , Kirilenkova ) ;
2400: NOP4
2404: PPUSH
2405: LD_STRING Kirilenkova
2407: PPUSH
2408: NOP4
// save_char ( Karamazov , Karamazov ) ;
2412: NOP4
2416: PPUSH
2417: LD_STRING Karamazov
2419: PPUSH
2420: NOP4
// save_char ( Petrovova , Petrovova ) ;
2424: NOP4
2428: PPUSH
2429: LD_STRING Petrovova
2431: PPUSH
2432: NOP4
// save_char ( Gleb , Gleb ) ;
2436: NOP4
2440: PPUSH
2441: LD_STRING Gleb
2443: PPUSH
2444: NOP4
// save_char ( Petrosyan , Petrosyan ) ;
2448: NOP4
2452: PPUSH
2453: LD_STRING Petrosyan
2455: PPUSH
2456: NOP4
// save_char ( Lipshchin , Lipshchin ) ;
2460: NOP4
2464: PPUSH
2465: LD_STRING Lipshchin
2467: PPUSH
2468: NOP4
// save_char ( Titov , Titov ) ;
2472: NOP4
2476: PPUSH
2477: LD_STRING Titov
2479: PPUSH
2480: NOP4
// save_char ( Dolgov , Dolgov ) ;
2484: NOP4
2488: PPUSH
2489: LD_STRING Dolgov
2491: PPUSH
2492: NOP4
// save_char ( Vsevolod , Vsevolod ) ;
2496: NOP4
2500: PPUSH
2501: LD_STRING Vsevolod
2503: PPUSH
2504: NOP4
// SaveCharacters ( [ Xavier ] , Xavier ) ;
2508: NOP4
2512: PUSH
2513: EMPTY
2514: LIST
2515: PPUSH
2516: LD_STRING Xavier
2518: PPUSH
2519: NOP4
// SaveCharacters ( [ Heike ] , Heike ) ;
2523: NOP4
2527: PUSH
2528: EMPTY
2529: LIST
2530: PPUSH
2531: LD_STRING Heike
2533: PPUSH
2534: NOP4
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_ALIVE ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
2538: NOP4
2542: PUSH
2543: LD_INT 22
2545: PUSH
2546: NOP4
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: LD_INT 51
2557: PUSH
2558: EMPTY
2559: LIST
2560: PUSH
2561: LD_INT 21
2563: PUSH
2564: LD_INT 1
2566: PUSH
2567: EMPTY
2568: LIST
2569: LIST
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: LIST
2575: PPUSH
2576: NOP4
2580: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2581: NOP4
2585: PUSH
2586: NOP4
2590: PPUSH
2591: LD_INT 2
2593: PUSH
2594: LD_INT 25
2596: PUSH
2597: LD_INT 12
2599: PUSH
2600: EMPTY
2601: LIST
2602: LIST
2603: PUSH
2604: LD_INT 25
2606: PUSH
2607: LD_INT 15
2609: PUSH
2610: EMPTY
2611: LIST
2612: LIST
2613: PUSH
2614: LD_INT 25
2616: PUSH
2617: LD_INT 16
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 25
2626: PUSH
2627: LD_INT 17
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: EMPTY
2642: LIST
2643: PPUSH
2644: NOP4
2648: ST_TO_ADDR
// Ostatni = Lidi diff [ 0 , Burlak , Vsevolod , Heike , Yelena , Popov , Gleb , Petrosyan , Karamazov , Petrovova , Dolgov , Titov , Platonov , Lipshchin , Yashin , Xavier ] ;
2649: NOP4
2653: PUSH
2654: NOP4
2658: PUSH
2659: LD_INT 0
2661: PUSH
2662: NOP4
2666: PUSH
2667: NOP4
2671: PUSH
2672: NOP4
2676: PUSH
2677: NOP4
2681: PUSH
2682: NOP4
2686: PUSH
2687: NOP4
2691: PUSH
2692: NOP4
2696: PUSH
2697: NOP4
2701: PUSH
2702: NOP4
2706: PUSH
2707: NOP4
2711: PUSH
2712: NOP4
2716: PUSH
2717: NOP4
2721: PUSH
2722: NOP4
2726: PUSH
2727: NOP4
2731: PUSH
2732: NOP4
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: LIST
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: LIST
2754: DIFF
2755: ST_TO_ADDR
// Ostatni = Ostatni diff Opice ;
2756: NOP4
2760: PUSH
2761: NOP4
2765: PUSH
2766: NOP4
2770: DIFF
2771: ST_TO_ADDR
// if FalesnaYelena and IsOk ( Yelena ) then
2772: NOP4
2776: PUSH
2777: NOP4
2781: PPUSH
2782: NOP4
2786: AND
2787: IFFALSE 2808
// Ostatni = Ostatni union [ Yelena ] ;
2789: NOP4
2793: PUSH
2794: NOP4
2798: PUSH
2799: NOP4
2803: PUSH
2804: EMPTY
2805: LIST
2806: UNION
2807: ST_TO_ADDR
// SaveCharacters ( Ostatni , Survivors2 ) ;
2808: NOP4
2812: PPUSH
2813: LD_STRING Survivors2
2815: PPUSH
2816: NOP4
// end ;
2820: LD_VAR 0 1
2824: RET
// function dej_medaile ; begin
2825: LD_INT 0
2827: PPUSH
// if Xavier and IsOK ( Xavier ) then
2828: NOP4
2832: PUSH
2833: NOP4
2837: PPUSH
2838: NOP4
2842: AND
2843: IFFALSE 2857
// AddMedal ( Xavier , 1 ) else
2845: LD_STRING Xavier
2847: PPUSH
2848: LD_INT 1
2850: PPUSH
2851: NOP4
2855: GO 2868
// AddMedal ( Xavier , - 1 ) ;
2857: LD_STRING Xavier
2859: PPUSH
2860: LD_INT 1
2862: NEG
2863: PPUSH
2864: NOP4
// if VsevSaved then
2868: NOP4
2872: IFFALSE 2905
// if PropaslQuickly then
2874: NOP4
2878: IFFALSE 2893
// AddMedal ( TimeVS , - 1 ) else
2880: LD_STRING TimeVS
2882: PPUSH
2883: LD_INT 1
2885: NEG
2886: PPUSH
2887: NOP4
2891: GO 2903
// AddMedal ( TimeVS , 1 ) else
2893: LD_STRING TimeVS
2895: PPUSH
2896: LD_INT 1
2898: PPUSH
2899: NOP4
2903: GO 2934
// if ContactIn5Min then
2905: NOP4
2909: IFFALSE 2923
// AddMedal ( TimeNV , 1 ) else
2911: LD_STRING TimeNV
2913: PPUSH
2914: LD_INT 1
2916: PPUSH
2917: NOP4
2921: GO 2934
// AddMedal ( TimeNV , - 1 ) ;
2923: LD_STRING TimeNV
2925: PPUSH
2926: LD_INT 1
2928: NEG
2929: PPUSH
2930: NOP4
// if IsOK ( Heike ) then
2934: NOP4
2938: PPUSH
2939: NOP4
2943: IFFALSE 2957
// AddMedal ( Heike , 1 ) else
2945: LD_STRING Heike
2947: PPUSH
2948: LD_INT 1
2950: PPUSH
2951: NOP4
2955: GO 2968
// AddMedal ( Heike , - 1 ) ;
2957: LD_STRING Heike
2959: PPUSH
2960: LD_INT 1
2962: NEG
2963: PPUSH
2964: NOP4
// end ;
2968: LD_VAR 0 1
2972: RET
// export function vyhral ( Ident ) ; var Lidi , Opice ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
2977: PPUSH
// dej_medaile ;
2978: NOP4
// GiveMedals ( Ident ) ;
2982: NOP4
2986: PPUSH
2987: NOP4
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
2991: NOP4
2995: PUSH
2996: LD_INT 22
2998: PUSH
2999: NOP4
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PUSH
3008: LD_INT 21
3010: PUSH
3011: LD_INT 1
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: PUSH
3018: LD_INT 51
3020: PUSH
3021: EMPTY
3022: LIST
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: LIST
3028: PPUSH
3029: NOP4
3033: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
3034: NOP4
3038: PUSH
3039: NOP4
3043: PPUSH
3044: LD_INT 2
3046: PUSH
3047: LD_INT 25
3049: PUSH
3050: LD_INT 12
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: PUSH
3057: LD_INT 25
3059: PUSH
3060: LD_INT 15
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: LD_INT 25
3069: PUSH
3070: LD_INT 16
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PUSH
3077: LD_INT 25
3079: PUSH
3080: LD_INT 17
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: LIST
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: PPUSH
3097: NOP4
3101: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
3102: NOP4
3106: PUSH
3107: NOP4
3111: DIFF
3112: PPUSH
3113: NOP4
// save ;
3117: NOP4
// YouWin ;
3121: NOP4
// end ;
3125: LD_VAR 0 2
3129: RET
// function set_attitudes ; begin
3130: LD_INT 0
3132: PPUSH
// ChangeSideFog ( side_Xavier , GetSideFog ( side_Ru ) ) ;
3133: NOP4
3137: PPUSH
3138: NOP4
3142: PPUSH
3143: NOP4
3147: PPUSH
3148: NOP4
// ChangeSideFog ( side_Ru2 , GetSideFog ( side_Ru ) ) ;
3152: NOP4
3156: PPUSH
3157: NOP4
3161: PPUSH
3162: NOP4
3166: PPUSH
3167: NOP4
// SetAttitude ( side_Ru2 , side_Ru , ATT_FRIEND , true ) ;
3171: NOP4
3175: PPUSH
3176: NOP4
3180: PPUSH
3181: LD_INT 1
3183: PPUSH
3184: LD_INT 1
3186: PPUSH
3187: NOP4
// SetAttitude ( side_Ru2 , side_Ar , ATT_ENEMY , false ) ;
3191: NOP4
3195: PPUSH
3196: NOP4
3200: PPUSH
3201: LD_INT 2
3203: PPUSH
3204: LD_INT 0
3206: PPUSH
3207: NOP4
// SetAttitude ( side_Ar , side_Ru2 , ATT_FRIEND , false ) ;
3211: NOP4
3215: PPUSH
3216: NOP4
3220: PPUSH
3221: LD_INT 1
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: NOP4
// SetAttitude ( side_Ru2 , side_Strazci , ATT_ENEMY , false ) ;
3231: NOP4
3235: PPUSH
3236: NOP4
3240: PPUSH
3241: LD_INT 2
3243: PPUSH
3244: LD_INT 0
3246: PPUSH
3247: NOP4
// SetAttitude ( side_Ru2 , side_Heike , ATT_NEUTRAL , false ) ;
3251: NOP4
3255: PPUSH
3256: NOP4
3260: PPUSH
3261: LD_INT 0
3263: PPUSH
3264: LD_INT 0
3266: PPUSH
3267: NOP4
// SetAttitude ( side_Strazci , side_Ru2 , ATT_NEUTRAL , false ) ;
3271: NOP4
3275: PPUSH
3276: NOP4
3280: PPUSH
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 0
3286: PPUSH
3287: NOP4
// SetAttitude ( side_Heike , side_Ru2 , ATT_NEUTRAL , false ) ;
3291: NOP4
3295: PPUSH
3296: NOP4
3300: PPUSH
3301: LD_INT 0
3303: PPUSH
3304: LD_INT 0
3306: PPUSH
3307: NOP4
// SetAttitude ( side_Ru , side_Xavier , ATT_FRIEND , true ) ;
3311: NOP4
3315: PPUSH
3316: NOP4
3320: PPUSH
3321: LD_INT 1
3323: PPUSH
3324: LD_INT 1
3326: PPUSH
3327: NOP4
// SetAttitude ( side_Ru2 , side_Xavier , ATT_FRIEND , true ) ;
3331: NOP4
3335: PPUSH
3336: NOP4
3340: PPUSH
3341: LD_INT 1
3343: PPUSH
3344: LD_INT 1
3346: PPUSH
3347: NOP4
// SetAttitude ( side_Ar , side_Xavier , ATT_FRIEND , true ) ;
3351: NOP4
3355: PPUSH
3356: NOP4
3360: PPUSH
3361: LD_INT 1
3363: PPUSH
3364: LD_INT 1
3366: PPUSH
3367: NOP4
// SetAttitude ( side_Heike , side_Xavier , ATT_NEUTRAL , true ) ;
3371: NOP4
3375: PPUSH
3376: NOP4
3380: PPUSH
3381: LD_INT 0
3383: PPUSH
3384: LD_INT 1
3386: PPUSH
3387: NOP4
// SetAttitude ( side_Strazci , side_Xavier , ATT_NEUTRAL , true ) ;
3391: NOP4
3395: PPUSH
3396: NOP4
3400: PPUSH
3401: LD_INT 0
3403: PPUSH
3404: LD_INT 1
3406: PPUSH
3407: NOP4
// SetAttitude ( side_Ru , side_Heike , ATT_NEUTRAL , false ) ;
3411: NOP4
3415: PPUSH
3416: NOP4
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 0
3426: PPUSH
3427: NOP4
// SetAttitude ( side_Heike , side_Ru , ATT_ENEMY , false ) ;
3431: NOP4
3435: PPUSH
3436: NOP4
3440: PPUSH
3441: LD_INT 2
3443: PPUSH
3444: LD_INT 0
3446: PPUSH
3447: NOP4
// SetAttitude ( side_Heike , side_Ar , ATT_FRIEND , true ) ;
3451: NOP4
3455: PPUSH
3456: NOP4
3460: PPUSH
3461: LD_INT 1
3463: PPUSH
3464: LD_INT 1
3466: PPUSH
3467: NOP4
// SetAttitude ( side_Heike , side_Strazci , ATT_FRIEND , true ) ;
3471: NOP4
3475: PPUSH
3476: NOP4
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: NOP4
// SetAttitude ( side_Ar , side_Strazci , ATT_FRIEND , true ) ;
3491: NOP4
3495: PPUSH
3496: NOP4
3500: PPUSH
3501: LD_INT 1
3503: PPUSH
3504: LD_INT 1
3506: PPUSH
3507: NOP4
// end ;
3511: LD_VAR 0 1
3515: RET
// starting begin AutoEnemy = false ;
3516: LD_ADDR_OWVAR 74
3520: PUSH
3521: LD_INT 0
3523: ST_TO_ADDR
// side_Neutral = 0 ;
3524: NOP4
3528: PUSH
3529: LD_INT 0
3531: ST_TO_ADDR
// side_Ar = 2 ;
3532: NOP4
3536: PUSH
3537: LD_INT 2
3539: ST_TO_ADDR
// side_Ru = 3 ;
3540: NOP4
3544: PUSH
3545: LD_INT 3
3547: ST_TO_ADDR
// side_Ru2 = 6 ;
3548: NOP4
3552: PUSH
3553: LD_INT 6
3555: ST_TO_ADDR
// side_Xavier = 5 ;
3556: NOP4
3560: PUSH
3561: LD_INT 5
3563: ST_TO_ADDR
// side_Heike = 7 ;
3564: NOP4
3568: PUSH
3569: LD_INT 7
3571: ST_TO_ADDR
// side_Strazci = 8 ;
3572: NOP4
3576: PUSH
3577: LD_INT 8
3579: ST_TO_ADDR
// set_attitudes ;
3580: NOP4
// ContactIn5Min = 0 ;
3584: NOP4
3588: PUSH
3589: LD_INT 0
3591: ST_TO_ADDR
// PropaslQuickly = 0 ;
3592: NOP4
3596: PUSH
3597: LD_INT 0
3599: ST_TO_ADDR
// Minuty = 0 ;
3600: NOP4
3604: PUSH
3605: LD_INT 0
3607: ST_TO_ADDR
// InitUc ;
3608: NOP4
// InitBc ;
3612: NOP4
// InitHc ;
3616: NOP4
// InitVc ;
3620: NOP4
// RandomizeAll ;
3624: NOP4
// init_difficulty ;
3628: NOP4
// load ;
3632: NOP4
// init_nature ;
3636: NOP4
// init_suroviny ;
3640: NOP4
// init_arabi ;
3644: NOP4
// init_rusove ;
3648: NOP4
// init_xavier ;
3652: NOP4
// init_heike ;
3656: NOP4
// init_yashin ;
3660: NOP4
// uvod ;
3664: NOP4
// end ;
3668: END
// every 1 1$0 do
3669: GO 3671
3671: DISABLE
// begin Minuty = Minuty + 1 ;
3672: NOP4
3676: PUSH
3677: NOP4
3681: PUSH
3682: LD_INT 1
3684: PLUS
3685: ST_TO_ADDR
// enable ;
3686: ENABLE
// end ; end_of_file
3687: END
// export RuDepot , RuLab , RuOil ; var VidelAraby ; var YashinZacal ; var KdoSlaplNaMinu ; export function init_rusove ; begin
3688: LD_INT 0
3690: PPUSH
// disable ( 1 ) ;
3691: LD_INT 1
3693: DISABLE_MARKED
// disable ( 2 ) ;
3694: LD_INT 2
3696: DISABLE_MARKED
// disable ( 3 ) ;
3697: LD_INT 3
3699: DISABLE_MARKED
// disable ( 4 ) ;
3700: LD_INT 4
3702: DISABLE_MARKED
// disable ( 5 ) ;
3703: LD_INT 5
3705: DISABLE_MARKED
// RuDepot = 0 ;
3706: NOP4
3710: PUSH
3711: LD_INT 0
3713: ST_TO_ADDR
// RuLab = 0 ;
3714: NOP4
3718: PUSH
3719: LD_INT 0
3721: ST_TO_ADDR
// RuOil = 0 ;
3722: NOP4
3726: PUSH
3727: LD_INT 0
3729: ST_TO_ADDR
// VidelAraby = false ;
3730: NOP4
3734: PUSH
3735: LD_INT 0
3737: ST_TO_ADDR
// YashinZacal = false ;
3738: NOP4
3742: PUSH
3743: LD_INT 0
3745: ST_TO_ADDR
// end ;
3746: LD_VAR 0 1
3750: RET
// export function uvod ; begin
3751: LD_INT 0
3753: PPUSH
// SetResourceVisibility ( 47 , 75 , side_Ru ) ;
3754: LD_INT 47
3756: PPUSH
3757: LD_INT 75
3759: PPUSH
3760: NOP4
3764: PPUSH
3765: NOP4
// if VsevSaved then
3769: NOP4
3773: IFFALSE 3781
// uvod_vsevolod else
3775: NOP4
3779: GO 3785
// uvod_sam ;
3781: NOP4
// Hint ( NonCombat ) ;
3785: LD_STRING NonCombat
3787: PPUSH
3788: NOP4
// end ;
3792: LD_VAR 0 1
3796: RET
// function priprav_zakladnu ; var Base ; begin
3797: LD_INT 0
3799: PPUSH
3800: PPUSH
// UC_Nation = NATION_RUSSIAN ;
3801: LD_ADDR_OWVAR 21
3805: PUSH
3806: LD_INT 3
3808: ST_TO_ADDR
// UC_side = side_Ru ;
3809: LD_ADDR_OWVAR 20
3813: PUSH
3814: NOP4
3818: ST_TO_ADDR
// BC_Level = 4 ;
3819: LD_ADDR_OWVAR 43
3823: PUSH
3824: LD_INT 4
3826: ST_TO_ADDR
// BC_Type = B_DEPOT ;
3827: LD_ADDR_OWVAR 42
3831: PUSH
3832: LD_INT 0
3834: ST_TO_ADDR
// RuDepot = CreateAndPlaceBuildingXYD ( 35 , 58 , 1 ) ;
3835: NOP4
3839: PUSH
3840: LD_INT 35
3842: PPUSH
3843: LD_INT 58
3845: PPUSH
3846: LD_INT 1
3848: PPUSH
3849: NOP4
3853: ST_TO_ADDR
// BC_Type = B_OIL_POWER ;
3854: LD_ADDR_OWVAR 42
3858: PUSH
3859: LD_INT 26
3861: ST_TO_ADDR
// RuOil = CreateAndPlaceBuildingXYD ( 31 , 45 , 1 ) ;
3862: NOP4
3866: PUSH
3867: LD_INT 31
3869: PPUSH
3870: LD_INT 45
3872: PPUSH
3873: LD_INT 1
3875: PPUSH
3876: NOP4
3880: ST_TO_ADDR
// BC_Type = B_LAB_HALF ;
3881: LD_ADDR_OWVAR 42
3885: PUSH
3886: LD_INT 7
3888: ST_TO_ADDR
// BC_Kind1 = B_LAB_SPACETIME ;
3889: LD_ADDR_OWVAR 44
3893: PUSH
3894: LD_INT 14
3896: ST_TO_ADDR
// BC_Kind2 = B_LAB_BASIC ;
3897: LD_ADDR_OWVAR 45
3901: PUSH
3902: LD_INT 9
3904: ST_TO_ADDR
// RuLab = CreateAndPlaceBuildingXYD ( 37 , 52 , 2 ) ;
3905: NOP4
3909: PUSH
3910: LD_INT 37
3912: PPUSH
3913: LD_INT 52
3915: PPUSH
3916: LD_INT 2
3918: PPUSH
3919: NOP4
3923: ST_TO_ADDR
// Base = GetBase ( RuDepot ) ;
3924: NOP4
3928: PUSH
3929: NOP4
3933: PPUSH
3934: NOP4
3938: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , dif_Cans [ Difficulty ] ) ;
3939: NOP4
3943: PPUSH
3944: LD_INT 1
3946: PPUSH
3947: NOP4
3951: PUSH
3952: NOP4
3956: ARRAY
3957: PPUSH
3958: NOP4
// SetResourceType ( Base , MAT_OIL , dif_Oil [ Difficulty ] ) ;
3962: NOP4
3966: PPUSH
3967: LD_INT 2
3969: PPUSH
3970: NOP4
3974: PUSH
3975: NOP4
3979: ARRAY
3980: PPUSH
3981: NOP4
// SetResourceType ( Base , MAT_SIBERIT , dif_Siberit [ Difficulty ] ) ;
3985: NOP4
3989: PPUSH
3990: LD_INT 3
3992: PPUSH
3993: NOP4
3997: PUSH
3998: NOP4
4002: ARRAY
4003: PPUSH
4004: NOP4
// end ;
4008: LD_VAR 0 1
4012: RET
// export function vytvor_rusaka ; begin
4013: LD_INT 0
4015: PPUSH
// UC_Nation = NATION_RUSSIAN ;
4016: LD_ADDR_OWVAR 21
4020: PUSH
4021: LD_INT 3
4023: ST_TO_ADDR
// UC_side = side_Ru ;
4024: LD_ADDR_OWVAR 20
4028: PUSH
4029: NOP4
4033: ST_TO_ADDR
// HC_name =  ;
4034: LD_ADDR_OWVAR 26
4038: PUSH
4039: LD_STRING 
4041: ST_TO_ADDR
// HC_sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
4042: LD_ADDR_OWVAR 27
4046: PUSH
4047: LD_INT 1
4049: PPUSH
4050: LD_INT 2
4052: PPUSH
4053: NOP4
4057: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
4058: LD_ADDR_OWVAR 28
4062: PUSH
4063: LD_INT 1
4065: ST_TO_ADDR
// PrepareSoldierSkills ( 4 ) ;
4066: LD_INT 4
4068: PPUSH
4069: NOP4
// Result = CreateHuman ;
4073: NOP4
4077: PUSH
4078: NOP4
4082: ST_TO_ADDR
// end ;
4083: LD_VAR 0 1
4087: RET
// function uvod_vsevolod ; var I , Counter , X , Y , Seznam , Ridici ; begin
4088: LD_INT 0
4090: PPUSH
4091: PPUSH
4092: PPUSH
4093: PPUSH
4094: PPUSH
4095: PPUSH
4096: PPUSH
// priprav_zakladnu ;
4097: NOP4
// if GetClass ( Yelena ) = CLASS_SCIENTISTIC then
4101: NOP4
4105: PPUSH
4106: NOP4
4110: PUSH
4111: LD_INT 4
4113: EQUAL
4114: IFFALSE 4128
// SetClass ( Yelena , CLASS_ENGINEER ) ;
4116: NOP4
4120: PPUSH
4121: LD_INT 2
4123: PPUSH
4124: NOP4
// if GetClass ( Burlak ) = CLASS_SCIENTISTIC then
4128: NOP4
4132: PPUSH
4133: NOP4
4137: PUSH
4138: LD_INT 4
4140: EQUAL
4141: IFFALSE 4155
// SetClass ( Burlak , CLASS_ENGINEER ) ;
4143: NOP4
4147: PPUSH
4148: LD_INT 2
4150: PPUSH
4151: NOP4
// Seznam = UnitFilter ( Rusaci union WithVsevolod , [ [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
4155: NOP4
4159: PUSH
4160: NOP4
4164: PUSH
4165: NOP4
4169: UNION
4170: PPUSH
4171: LD_INT 25
4173: PUSH
4174: LD_INT 4
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: PPUSH
4184: NOP4
4188: ST_TO_ADDR
// for I in Seznam do
4189: NOP4
4193: PUSH
4194: NOP4
4198: PUSH
4199: FOR_IN
4200: IFFALSE 4216
// SetClass ( I , CLASS_SOLDIER ) ;
4202: NOP4
4206: PPUSH
4207: LD_INT 1
4209: PPUSH
4210: NOP4
4214: GO 4199
4216: POP
4217: POP
// SetTech ( TECH_TAUFIELD , side_Ru , STATE_RESEARCHED ) ;
4218: LD_INT 30
4220: PPUSH
4221: NOP4
4225: PPUSH
4226: LD_INT 2
4228: PPUSH
4229: NOP4
// SetTech ( TECH_TAUFIELD , side_Ru2 , STATE_RESEARCHED ) ;
4233: LD_INT 30
4235: PPUSH
4236: NOP4
4240: PPUSH
4241: LD_INT 2
4243: PPUSH
4244: NOP4
// PlaceUnitArea ( Vsevolod , Start1Vsevolod , false ) ;
4248: NOP4
4252: PPUSH
4253: NOP4
4257: PPUSH
4258: LD_INT 0
4260: PPUSH
4261: NOP4
// X = GetX ( Vsevolod ) ;
4265: NOP4
4269: PUSH
4270: NOP4
4274: PPUSH
4275: NOP4
4279: ST_TO_ADDR
// Y = GetY ( Vsevolod ) ;
4280: NOP4
4284: PUSH
4285: NOP4
4289: PPUSH
4290: NOP4
4294: ST_TO_ADDR
// PlaceUnitXYR ( Burlak , X , Y , 6 , false ) ;
4295: NOP4
4299: PPUSH
4300: NOP4
4304: PPUSH
4305: NOP4
4309: PPUSH
4310: LD_INT 6
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: NOP4
// Seznam = UnitFilter ( Konvoj , [ [ F_CONTROL , CONTROL_MANUAL ] ] ) ;
4320: NOP4
4324: PUSH
4325: NOP4
4329: PPUSH
4330: LD_INT 33
4332: PUSH
4333: LD_INT 1
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PUSH
4340: EMPTY
4341: LIST
4342: PPUSH
4343: NOP4
4347: ST_TO_ADDR
// Ridici = zjisti_ridice ( Rusaci , Seznam ) ;
4348: NOP4
4352: PUSH
4353: NOP4
4357: PPUSH
4358: NOP4
4362: PPUSH
4363: NOP4
4367: ST_TO_ADDR
// for I = 1 to Seznam do
4368: NOP4
4372: PUSH
4373: DOUBLE
4374: LD_INT 1
4376: DEC
4377: ST_TO_ADDR
4378: NOP4
4382: PUSH
4383: FOR_TO
4384: IFFALSE 4426
// if Ridici >= I then
4386: NOP4
4390: PUSH
4391: NOP4
4395: GREATEREQUAL
4396: IFFALSE 4424
// PlaceHumanInUnit ( Ridici [ I ] , Seznam [ I ] ) ;
4398: NOP4
4402: PUSH
4403: NOP4
4407: ARRAY
4408: PPUSH
4409: NOP4
4413: PUSH
4414: NOP4
4418: ARRAY
4419: PPUSH
4420: NOP4
4424: GO 4383
4426: POP
4427: POP
// place_list ( Konvoj , Start1 ) ;
4428: NOP4
4432: PPUSH
4433: NOP4
4437: PPUSH
4438: NOP4
// place_list ( Rusaci diff Ridici , Start1 ) ;
4442: NOP4
4446: PUSH
4447: NOP4
4451: DIFF
4452: PPUSH
4453: NOP4
4457: PPUSH
4458: NOP4
// place_list ( Yelena , Start1Vsevolod ) ;
4462: NOP4
4466: PPUSH
4467: NOP4
4471: PPUSH
4472: NOP4
// place_list ( WithVsevolod , Start1Vsevolod ) ;
4476: NOP4
4480: PPUSH
4481: NOP4
4485: PPUSH
4486: NOP4
// InGameOn ;
4490: NOP4
// CenterNowOnUnits ( Burlak ) ;
4494: NOP4
4498: PPUSH
4499: NOP4
// AddComHold ( [ Burlak ] ) ;
4503: NOP4
4507: PUSH
4508: EMPTY
4509: LIST
4510: PPUSH
4511: NOP4
// CenterOnUnits ( [ Burlak ] ) ;
4515: NOP4
4519: PUSH
4520: EMPTY
4521: LIST
4522: PPUSH
4523: NOP4
// dialog_Start ;
4527: NOP4
// dialog_StartVS ;
4531: NOP4
// dialog_Start2 ;
4535: NOP4
// ChangeMissionObjectives ( MStart ) ;
4539: LD_STRING MStart
4541: PPUSH
4542: NOP4
// jdete_k_sobe ( Burlak , Vsevolod ) ;
4546: NOP4
4550: PPUSH
4551: NOP4
4555: PPUSH
4556: NOP4
// AddComHold ( [ Burlak , Vsevolod ] ) ;
4560: NOP4
4564: PUSH
4565: NOP4
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PPUSH
4574: NOP4
// CenterOnUnits ( [ Burlak , Vsevolod ] ) ;
4578: NOP4
4582: PUSH
4583: NOP4
4587: PUSH
4588: EMPTY
4589: LIST
4590: LIST
4591: PPUSH
4592: NOP4
// RevealFogArea ( side_Ru , RuDepotFog ) ;
4596: NOP4
4600: PPUSH
4601: NOP4
4605: PPUSH
4606: NOP4
// dialog_MeetVsevolodVS ;
4610: NOP4
// CenterOnUnits ( [ RuDepot , RuLab , RuOil ] ) ;
4614: NOP4
4618: PUSH
4619: NOP4
4623: PUSH
4624: NOP4
4628: PUSH
4629: EMPTY
4630: LIST
4631: LIST
4632: LIST
4633: PPUSH
4634: NOP4
// Wait ( 0 0$2 ) ;
4638: LD_INT 70
4640: PPUSH
4641: NOP4
// CenterOnUnits ( Burlak ) ;
4645: NOP4
4649: PPUSH
4650: NOP4
// ComMoveToArea ( Vsevolod , Mina ) ;
4654: NOP4
4658: PPUSH
4659: NOP4
4663: PPUSH
4664: NOP4
// ComWait ( WithVsevolod , 0 0$5 ) ;
4668: NOP4
4672: PPUSH
4673: LD_INT 175
4675: PPUSH
4676: NOP4
// AddComMoveToArea ( WithVsevolod , Mina ) ;
4680: NOP4
4684: PPUSH
4685: NOP4
4689: PPUSH
4690: NOP4
// AddComMoveToArea ( Vsevolod , RuDepotFog ) ;
4694: NOP4
4698: PPUSH
4699: NOP4
4703: PPUSH
4704: NOP4
// AddComMoveToArea ( WithVsevolod , RuDepotFog ) ;
4708: NOP4
4712: PPUSH
4713: NOP4
4717: PPUSH
4718: NOP4
// Counter = 0 ;
4722: NOP4
4726: PUSH
4727: LD_INT 0
4729: ST_TO_ADDR
// while not IsInArea ( Vsevolod , Mina ) do
4730: NOP4
4734: PPUSH
4735: NOP4
4739: PPUSH
4740: NOP4
4744: NOT
4745: IFFALSE 4793
// begin Wait ( 0 0$0.5 ) ;
4747: LD_INT 18
4749: PPUSH
4750: NOP4
// Counter = Counter + 1 ;
4754: NOP4
4758: PUSH
4759: NOP4
4763: PUSH
4764: LD_INT 1
4766: PLUS
4767: ST_TO_ADDR
// if Counter mod 10 = 0 then
4768: NOP4
4772: PUSH
4773: LD_INT 10
4775: MOD
4776: PUSH
4777: LD_INT 0
4779: EQUAL
4780: IFFALSE 4791
// CenterOnUnits ( Vsevolod ) ;
4782: NOP4
4786: PPUSH
4787: NOP4
// end ;
4791: GO 4730
// CenterOnUnits ( Vsevolod ) ;
4793: NOP4
4797: PPUSH
4798: NOP4
// Wait ( 0 0$1 ) ;
4802: LD_INT 35
4804: PPUSH
4805: NOP4
// ComHold ( Vsevolod ) ;
4809: NOP4
4813: PPUSH
4814: NOP4
// X = GetX ( Vsevolod ) ;
4818: NOP4
4822: PUSH
4823: NOP4
4827: PPUSH
4828: NOP4
4832: ST_TO_ADDR
// Y = GetY ( Vsevolod ) ;
4833: NOP4
4837: PUSH
4838: NOP4
4842: PPUSH
4843: NOP4
4847: ST_TO_ADDR
// MineExplosion ( X , Y , false ) ;
4848: NOP4
4852: PPUSH
4853: NOP4
4857: PPUSH
4858: LD_INT 0
4860: PPUSH
4861: NOP4
// SetLives ( [ RuLab , RuOil ] , 25 ) ;
4865: NOP4
4869: PUSH
4870: NOP4
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: PPUSH
4879: LD_INT 25
4881: PPUSH
4882: NOP4
// MineExplosion ( GetX ( RuLab ) , GetY ( RuLab ) , true ) ;
4886: NOP4
4890: PPUSH
4891: NOP4
4895: PPUSH
4896: NOP4
4900: PPUSH
4901: NOP4
4905: PPUSH
4906: LD_INT 1
4908: PPUSH
4909: NOP4
// MineExplosion ( GetX ( RuOil ) , GetY ( RuOil ) , true ) ;
4913: NOP4
4917: PPUSH
4918: NOP4
4922: PPUSH
4923: NOP4
4927: PPUSH
4928: NOP4
4932: PPUSH
4933: LD_INT 1
4935: PPUSH
4936: NOP4
// Wait ( 0 0$0.5 ) ;
4940: LD_INT 18
4942: PPUSH
4943: NOP4
// SetLives ( Vsevolod , HRANICE_UMIRANI ) ;
4947: NOP4
4951: PPUSH
4952: LD_INT 250
4954: PPUSH
4955: NOP4
// KdoSlaplNaMinu = [ Vsevolod ] ;
4959: NOP4
4963: PUSH
4964: NOP4
4968: PUSH
4969: EMPTY
4970: LIST
4971: ST_TO_ADDR
// for I in FilterAllUnits ( [ [ F_PLACED ] ] ) do
4972: NOP4
4976: PUSH
4977: LD_INT 52
4979: PUSH
4980: EMPTY
4981: LIST
4982: PUSH
4983: EMPTY
4984: LIST
4985: PPUSH
4986: NOP4
4990: PUSH
4991: FOR_IN
4992: IFFALSE 5074
// begin if I = Vsevolod then
4994: NOP4
4998: PUSH
4999: NOP4
5003: EQUAL
5004: IFFALSE 5008
// continue ;
5006: GO 4991
// if IsInUnit ( I ) then
5008: NOP4
5012: PPUSH
5013: NOP4
5017: IFFALSE 5021
// continue ;
5019: GO 4991
// if GetDistUnits ( Vsevolod , I ) <= 3 then
5021: NOP4
5025: PPUSH
5026: NOP4
5030: PPUSH
5031: NOP4
5035: PUSH
5036: LD_INT 3
5038: LESSEQUAL
5039: IFFALSE 5072
// begin SetLives ( I , HRANICE_UMIRANI ) ;
5041: NOP4
5045: PPUSH
5046: LD_INT 250
5048: PPUSH
5049: NOP4
// KdoSlaplNaMinu = KdoSlaplNaMinu union [ I ] ;
5053: NOP4
5057: PUSH
5058: NOP4
5062: PUSH
5063: NOP4
5067: PUSH
5068: EMPTY
5069: LIST
5070: UNION
5071: ST_TO_ADDR
// end ; end ;
5072: GO 4991
5074: POP
5075: POP
// ComCancel ( WithVsevolod ) ;
5076: NOP4
5080: PPUSH
5081: NOP4
// ComHold ( WithVsevolod ) ;
5085: NOP4
5089: PPUSH
5090: NOP4
// dialog_StasisVS ;
5094: NOP4
// Wait ( 0 0$2 ) ;
5098: LD_INT 70
5100: PPUSH
5101: NOP4
// ChangeMissionObjectives ( MVsevolod ) ;
5105: LD_STRING MVsevolod
5107: PPUSH
5108: NOP4
// enable ( 1 ) ;
5112: LD_INT 1
5114: ENABLE_MARKED
// enable ( 2 ) ;
5115: LD_INT 2
5117: ENABLE_MARKED
// SetLives ( KdoSlaplNaMinu , HRANICE_UMIRANI ) ;
5118: NOP4
5122: PPUSH
5123: LD_INT 250
5125: PPUSH
5126: NOP4
// SetSide ( Vsevolod , side_Ru ) ;
5130: NOP4
5134: PPUSH
5135: NOP4
5139: PPUSH
5140: NOP4
// SetSide ( WithVsevolod , side_Ru ) ;
5144: NOP4
5148: PPUSH
5149: NOP4
5153: PPUSH
5154: NOP4
// ComFree ( [ Burlak , Vsevolod ] ) ;
5158: NOP4
5162: PUSH
5163: NOP4
5167: PUSH
5168: EMPTY
5169: LIST
5170: LIST
5171: PPUSH
5172: NOP4
// SaveForQuickRestart ;
5176: NOP4
// InGameOff ;
5180: NOP4
// enable ( 5 ) ;
5184: LD_INT 5
5186: ENABLE_MARKED
// end ;
5187: LD_VAR 0 1
5191: RET
// every 0 0$5 marked 5 do var Kolik , I ;
5192: GO 5194
5194: DISABLE
5195: LD_INT 0
5197: PPUSH
5198: PPUSH
// begin if Difficulty = 1 then
5199: NOP4
5203: PUSH
5204: LD_INT 1
5206: EQUAL
5207: IFFALSE 5219
// Kolik = 20 else
5209: NOP4
5213: PUSH
5214: LD_INT 20
5216: ST_TO_ADDR
5217: GO 5241
// if Difficulty = 2 then
5219: NOP4
5223: PUSH
5224: LD_INT 2
5226: EQUAL
5227: IFFALSE 5239
// Kolik = 10 else
5229: NOP4
5233: PUSH
5234: LD_INT 10
5236: ST_TO_ADDR
5237: GO 5241
// exit ;
5239: GO 5282
// for I = 1 to Kolik do
5241: NOP4
5245: PUSH
5246: DOUBLE
5247: LD_INT 1
5249: DEC
5250: ST_TO_ADDR
5251: NOP4
5255: PUSH
5256: FOR_TO
5257: IFFALSE 5280
// begin SetLives ( KdoSlaplNaMinu , HRANICE_UMIRANI ) ;
5259: NOP4
5263: PPUSH
5264: LD_INT 250
5266: PPUSH
5267: NOP4
// Wait ( 0 0$1 ) ;
5271: LD_INT 35
5273: PPUSH
5274: NOP4
// end ;
5278: GO 5256
5280: POP
5281: POP
// end ;
5282: PPOPN 2
5284: END
// function vytvor_nakladaky ; var N1 , N2 ; begin
5285: LD_INT 0
5287: PPUSH
5288: PPUSH
5289: PPUSH
// UC_side = side_Ru ;
5290: LD_ADDR_OWVAR 20
5294: PUSH
5295: NOP4
5299: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
5300: LD_ADDR_OWVAR 21
5304: PUSH
5305: LD_INT 3
5307: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
5308: LD_ADDR_OWVAR 37
5312: PUSH
5313: LD_INT 21
5315: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
5316: LD_ADDR_OWVAR 38
5320: PUSH
5321: LD_INT 1
5323: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
5324: LD_ADDR_OWVAR 39
5328: PUSH
5329: LD_INT 1
5331: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
5332: LD_ADDR_OWVAR 40
5336: PUSH
5337: LD_INT 51
5339: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 75 , 100 ) ;
5340: LD_ADDR_OWVAR 41
5344: PUSH
5345: LD_INT 75
5347: PPUSH
5348: LD_INT 100
5350: PPUSH
5351: NOP4
5355: ST_TO_ADDR
// N1 = CreateVehicle ;
5356: NOP4
5360: PUSH
5361: NOP4
5365: ST_TO_ADDR
// N2 = CreateVehicle ;
5366: NOP4
5370: PUSH
5371: NOP4
5375: ST_TO_ADDR
// SetCargo ( N1 , MAT_CANS , 100 ) ;
5376: NOP4
5380: PPUSH
5381: LD_INT 1
5383: PPUSH
5384: LD_INT 100
5386: PPUSH
5387: NOP4
// SetCargo ( N2 , MAT_SIBERIT , 100 ) ;
5391: NOP4
5395: PPUSH
5396: LD_INT 3
5398: PPUSH
5399: LD_INT 100
5401: PPUSH
5402: NOP4
// Result = [ N1 , N2 ] ;
5406: NOP4
5410: PUSH
5411: NOP4
5415: PUSH
5416: NOP4
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: ST_TO_ADDR
// end ;
5425: LD_VAR 0 1
5429: RET
// function zjisti_ridice ( Seznam , Pocet ) ; var I , Ted ; begin
5430: LD_INT 0
5432: PPUSH
5433: PPUSH
5434: PPUSH
// Result = [ ] ;
5435: NOP4
5439: PUSH
5440: EMPTY
5441: ST_TO_ADDR
// while ( Result < Pocet ) and Seznam do
5442: NOP4
5446: PUSH
5447: NOP4
5451: LESS
5452: PUSH
5453: NOP4
5457: AND
5458: IFFALSE 5519
// begin Ted = Seznam [ 1 ] ;
5460: NOP4
5464: PUSH
5465: NOP4
5469: PUSH
5470: LD_INT 1
5472: ARRAY
5473: ST_TO_ADDR
// Seznam = Delete ( Seznam , 1 ) ;
5474: NOP4
5478: PUSH
5479: NOP4
5483: PPUSH
5484: LD_INT 1
5486: PPUSH
5487: NOP4
5491: ST_TO_ADDR
// if Ted then
5492: NOP4
5496: IFFALSE 5517
// Result = Result union [ Ted ] ;
5498: NOP4
5502: PUSH
5503: NOP4
5507: PUSH
5508: NOP4
5512: PUSH
5513: EMPTY
5514: LIST
5515: UNION
5516: ST_TO_ADDR
// end ;
5517: GO 5442
// end ;
5519: LD_VAR 0 3
5523: RET
// function uvod_sam ; var I , Seznam , Ridici ; begin
5524: LD_INT 0
5526: PPUSH
5527: PPUSH
5528: PPUSH
5529: PPUSH
// SetSide ( Rusaci , side_Ru ) ;
5530: NOP4
5534: PPUSH
5535: NOP4
5539: PPUSH
5540: NOP4
// SetSide ( Yelena , side_Ru ) ;
5544: NOP4
5548: PPUSH
5549: NOP4
5553: PPUSH
5554: NOP4
// while Rusaci <= 7 do
5558: NOP4
5562: PUSH
5563: LD_INT 7
5565: LESSEQUAL
5566: IFFALSE 5589
// Rusaci = Rusaci union [ vytvor_rusaka ] ;
5568: NOP4
5572: PUSH
5573: NOP4
5577: PUSH
5578: NOP4
5582: PUSH
5583: EMPTY
5584: LIST
5585: UNION
5586: ST_TO_ADDR
5587: GO 5558
// Rusaci = Rusaci union [ Yelena ] ;
5589: NOP4
5593: PUSH
5594: NOP4
5598: PUSH
5599: NOP4
5603: PUSH
5604: EMPTY
5605: LIST
5606: UNION
5607: ST_TO_ADDR
// SetTech ( TECH_SIBDET , side_Ru , STATE_RESEARCHED ) ;
5608: LD_INT 20
5610: PPUSH
5611: NOP4
5615: PPUSH
5616: LD_INT 2
5618: PPUSH
5619: NOP4
// Seznam = UnitFilter ( Rusaci union [ Burlak ] , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
5623: NOP4
5627: PUSH
5628: NOP4
5632: PUSH
5633: NOP4
5637: PUSH
5638: EMPTY
5639: LIST
5640: UNION
5641: PPUSH
5642: LD_INT 22
5644: PUSH
5645: NOP4
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: LD_INT 21
5656: PUSH
5657: LD_INT 1
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: PUSH
5664: LD_INT 25
5666: PUSH
5667: LD_INT 2
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: PPUSH
5679: NOP4
5683: ST_TO_ADDR
// if not Seznam then
5684: NOP4
5688: NOT
5689: IFFALSE 5703
// SetClass ( Burlak , CLASS_ENGINEER ) ;
5691: NOP4
5695: PPUSH
5696: LD_INT 2
5698: PPUSH
5699: NOP4
// Seznam = vytvor_nakladaky ;
5703: NOP4
5707: PUSH
5708: NOP4
5712: ST_TO_ADDR
// Ridici = zjisti_ridice ( Rusaci , 2 ) ;
5713: NOP4
5717: PUSH
5718: NOP4
5722: PPUSH
5723: LD_INT 2
5725: PPUSH
5726: NOP4
5730: ST_TO_ADDR
// if Ridici >= 1 then
5731: NOP4
5735: PUSH
5736: LD_INT 1
5738: GREATEREQUAL
5739: IFFALSE 5763
// PlaceHumanInUnit ( Ridici [ 1 ] , Seznam [ 1 ] ) ;
5741: NOP4
5745: PUSH
5746: LD_INT 1
5748: ARRAY
5749: PPUSH
5750: NOP4
5754: PUSH
5755: LD_INT 1
5757: ARRAY
5758: PPUSH
5759: NOP4
// if Ridici >= 2 then
5763: NOP4
5767: PUSH
5768: LD_INT 2
5770: GREATEREQUAL
5771: IFFALSE 5795
// PlaceHumanInUnit ( Ridici [ 2 ] , Seznam [ 2 ] ) ;
5773: NOP4
5777: PUSH
5778: LD_INT 2
5780: ARRAY
5781: PPUSH
5782: NOP4
5786: PUSH
5787: LD_INT 2
5789: ARRAY
5790: PPUSH
5791: NOP4
// PlaceUnitArea ( Burlak , Start1a , false ) ;
5795: NOP4
5799: PPUSH
5800: NOP4
5804: PPUSH
5805: LD_INT 0
5807: PPUSH
5808: NOP4
// Place_list ( Seznam , Start1a ) ;
5812: NOP4
5816: PPUSH
5817: NOP4
5821: PPUSH
5822: NOP4
// place_list ( Rusaci diff Ridici , Start1a ) ;
5826: NOP4
5830: PUSH
5831: NOP4
5835: DIFF
5836: PPUSH
5837: NOP4
5841: PPUSH
5842: NOP4
// for I = 1 to Rand ( 2 , 4 ) do
5846: NOP4
5850: PUSH
5851: DOUBLE
5852: LD_INT 1
5854: DEC
5855: ST_TO_ADDR
5856: LD_INT 2
5858: PPUSH
5859: LD_INT 4
5861: PPUSH
5862: NOP4
5866: PUSH
5867: FOR_TO
5868: IFFALSE 5895
// CreateCratesArea ( Rand ( 1 , 5 ) , BednyRusoveV , false ) ;
5870: LD_INT 1
5872: PPUSH
5873: LD_INT 5
5875: PPUSH
5876: NOP4
5880: PPUSH
5881: NOP4
5885: PPUSH
5886: LD_INT 0
5888: PPUSH
5889: NOP4
5893: GO 5867
5895: POP
5896: POP
// InGameOn ;
5897: NOP4
// CenterNowOnUnits ( Burlak ) ;
5901: NOP4
5905: PPUSH
5906: NOP4
// AddComHold ( [ Burlak ] ) ;
5910: NOP4
5914: PUSH
5915: EMPTY
5916: LIST
5917: PPUSH
5918: NOP4
// CenterOnUnits ( [ Burlak ] ) ;
5922: NOP4
5926: PUSH
5927: EMPTY
5928: LIST
5929: PPUSH
5930: NOP4
// dialog_Start ;
5934: NOP4
// dialog_StartNV ;
5938: NOP4
// dialog_Start2 ;
5942: NOP4
// ChangeMissionObjectives ( MStart ) ;
5946: LD_STRING MStart
5948: PPUSH
5949: NOP4
// enable ( 4 ) ;
5953: LD_INT 4
5955: ENABLE_MARKED
// AddComFree ( Burlak ) ;
5956: NOP4
5960: PPUSH
5961: NOP4
// SaveForQuickRestart ;
5965: NOP4
// InGameOff ;
5969: NOP4
// arabi_muzete_utocit ;
5973: NOP4
// end ;
5977: LD_VAR 0 1
5981: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
5982: LD_INT 0
5984: PPUSH
// if Un = Burlak then
5985: NOP4
5989: PUSH
5990: NOP4
5994: EQUAL
5995: IFFALSE 6006
// begin YouLost ( Burlak ) ;
5997: LD_STRING Burlak
5999: PPUSH
6000: NOP4
// exit ;
6004: GO 6027
// end ; if Un = Vsevolod then
6006: NOP4
6010: PUSH
6011: NOP4
6015: EQUAL
6016: IFFALSE 6027
// begin YouLost ( Sevi ) ;
6018: LD_STRING Sevi
6020: PPUSH
6021: NOP4
// exit ;
6025: GO 6027
// end ; end ;
6027: LD_VAR 0 2
6031: RET
// function mozny_prichod_yashina ; begin
6032: LD_INT 0
6034: PPUSH
// if not YashinZacal then
6035: NOP4
6039: NOT
6040: IFFALSE 6054
// begin YashinZacal = true ;
6042: NOP4
6046: PUSH
6047: LD_INT 1
6049: ST_TO_ADDR
// yashin_start_timer ;
6050: NOP4
// end ; end ;
6054: LD_VAR 0 1
6058: RET
// export function rusove_BuildingComplete ( Un ) ; begin
6059: LD_INT 0
6061: PPUSH
// if ( GetSide ( Un ) = side_Ru ) and ( GetBType ( Un ) in [ B_WORKSHOP , B_FACTORY ] ) then
6062: NOP4
6066: PPUSH
6067: NOP4
6071: PUSH
6072: NOP4
6076: EQUAL
6077: PUSH
6078: NOP4
6082: PPUSH
6083: NOP4
6087: PUSH
6088: LD_INT 2
6090: PUSH
6091: LD_INT 3
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: IN
6098: AND
6099: IFFALSE 6105
// begin mozny_prichod_yashina ;
6101: NOP4
// end ; end ;
6105: LD_VAR 0 2
6109: RET
// every 25 25$0 do
6110: GO 6112
6112: DISABLE
// begin mozny_prichod_yashina ;
6113: NOP4
// end ;
6117: END
// every 0 0$3 + 0 0$1.2 marked 2 do
6118: GO 6120
6120: DISABLE
// begin if not IsOK ( Vsevolod ) then
6121: NOP4
6125: PPUSH
6126: NOP4
6130: NOT
6131: IFFALSE 6136
// enable else
6133: ENABLE
6134: GO 6183
// begin DialogueOn ;
6136: NOP4
// dialog_SeviSaved ;
6140: NOP4
// SetSide ( Vsevolod , side_Ru ) ;
6144: NOP4
6148: PPUSH
6149: NOP4
6153: PPUSH
6154: NOP4
// SetSide ( WithVsevolod , side_Ru ) ;
6158: NOP4
6162: PPUSH
6163: NOP4
6167: PPUSH
6168: NOP4
// DialogueOff ;
6172: NOP4
// enable ( 3 ) ;
6176: LD_INT 3
6178: ENABLE_MARKED
// arabi_muzete_utocit ;
6179: NOP4
// end ; end ;
6183: END
// export function rusove_Contact ( Side1 , Side2 ) ; begin
6184: LD_INT 0
6186: PPUSH
// if ( ( Side1 = side_Ru ) and ( Side2 = side_Ar ) ) or ( ( Side1 = side_Ar ) and ( Side2 = side_Ru ) ) then
6187: NOP4
6191: PUSH
6192: NOP4
6196: EQUAL
6197: PUSH
6198: NOP4
6202: PUSH
6203: NOP4
6207: EQUAL
6208: AND
6209: PUSH
6210: NOP4
6214: PUSH
6215: NOP4
6219: EQUAL
6220: PUSH
6221: NOP4
6225: PUSH
6226: NOP4
6230: EQUAL
6231: AND
6232: OR
6233: IFFALSE 6243
// VidelAraby = true ;
6235: NOP4
6239: PUSH
6240: LD_INT 1
6242: ST_TO_ADDR
// end ;
6243: LD_VAR 0 3
6247: RET
// every 5 5$0 do
6248: GO 6250
6250: DISABLE
// begin ContactIn5Min = VidelAraby ;
6251: NOP4
6255: PUSH
6256: NOP4
6260: ST_TO_ADDR
// end ;
6261: END
// every 30 30$0 do
6262: GO 6264
6264: DISABLE
// begin if Difficulty = 1 then
6265: NOP4
6269: PUSH
6270: LD_INT 1
6272: EQUAL
6273: IFFALSE 6284
// wait ( 15 15$0 ) else
6275: LD_INT 31500
6277: PPUSH
6278: NOP4
6282: GO 6301
// if Difficulty = 2 then
6284: NOP4
6288: PUSH
6289: LD_INT 2
6291: EQUAL
6292: IFFALSE 6301
// Wait ( 5 5$0 ) ;
6294: LD_INT 10500
6296: PPUSH
6297: NOP4
// PropaslQuickly = true ;
6301: NOP4
6305: PUSH
6306: LD_INT 1
6308: ST_TO_ADDR
// end ;
6309: END
// every 2 2$35 marked 3 do
6310: GO 6312
6312: DISABLE
// begin Wait ( Rand ( 0 0$1 , 0 0$30 ) ) ;
6313: LD_INT 35
6315: PPUSH
6316: LD_INT 1050
6318: PPUSH
6319: NOP4
6323: PPUSH
6324: NOP4
// xavier_start ;
6328: NOP4
// end ;
6332: END
// every 4 4$45 marked 4 do
6333: GO 6335
6335: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
6336: LD_INT 35
6338: PPUSH
6339: LD_INT 2100
6341: PPUSH
6342: NOP4
6346: PPUSH
6347: NOP4
// xavier_start ;
6351: NOP4
// end ; end_of_file
6355: END
// var Zniceno ; var Autaky ; var Obranci ; var VolnyLidi ; var Utok_Auta ; var Utok_ZbyvaMinut ; var CasyUtoku ; var VidelRusa ; var PstZbrane ; var ProbihaUtok ; var CisloUtoku ; var Patrola ; var PatrolaZrusena ; var Registry ; var RegUtok ; var MakroObrana ; var MakroUtok ; var MakroBunkry ; var MakroPresunZakladna ; var BeziStahovani ; var ArDalkar ; var KolikDalkovych ; var DelamDalkare ; var Miny ; var ProbihaOprava ; var ProbihaLeceni ; export function init_arabi ; var Kdo , Budovy ; begin
6356: LD_INT 0
6358: PPUSH
6359: PPUSH
6360: PPUSH
// disable ( 43 ) ;
6361: LD_INT 43
6363: DISABLE_MARKED
// disable ( 44 ) ;
6364: LD_INT 44
6366: DISABLE_MARKED
// disable ( 45 ) ;
6367: LD_INT 45
6369: DISABLE_MARKED
// disable ( 46 ) ;
6370: LD_INT 46
6372: DISABLE_MARKED
// disable ( 47 ) ;
6373: LD_INT 47
6375: DISABLE_MARKED
// SetBName ( ArDepot , newkabul ) ;
6376: NOP4
6380: PPUSH
6381: LD_STRING newkabul
6383: PPUSH
6384: NOP4
// Autaky = [ ArTank1 , ArTank2 ] ;
6388: NOP4
6392: PUSH
6393: NOP4
6397: PUSH
6398: NOP4
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: ST_TO_ADDR
// Patrola = [ ArTank1 ] ;
6407: NOP4
6411: PUSH
6412: NOP4
6416: PUSH
6417: EMPTY
6418: LIST
6419: ST_TO_ADDR
// Obranci = vytvor_obrance ;
6420: NOP4
6424: PUSH
6425: NOP4
6429: ST_TO_ADDR
// place_list ( Obranci , AraboveParkoviste ) ;
6430: NOP4
6434: PPUSH
6435: NOP4
6439: PPUSH
6440: NOP4
// Obranci = Obranci union [ ArSolBunk1 , ArSolBunk4 , ArSolBunk6 ] ;
6444: NOP4
6448: PUSH
6449: NOP4
6453: PUSH
6454: NOP4
6458: PUSH
6459: NOP4
6463: PUSH
6464: NOP4
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: LIST
6473: UNION
6474: ST_TO_ADDR
// VolnyLidi = vytvor_volny ;
6475: NOP4
6479: PUSH
6480: NOP4
6484: ST_TO_ADDR
// place_list ( VolnyLidi , AraboveVolni ) ;
6485: NOP4
6489: PPUSH
6490: NOP4
6494: PPUSH
6495: NOP4
// VolnyLidi = VolnyLidi union [ ArMech1 , ArMech2 ] ;
6499: NOP4
6503: PUSH
6504: NOP4
6508: PUSH
6509: NOP4
6513: PUSH
6514: NOP4
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: UNION
6523: ST_TO_ADDR
// Utok_Auta = [ ] ;
6524: NOP4
6528: PUSH
6529: EMPTY
6530: ST_TO_ADDR
// ArDalkar = 0 ;
6531: NOP4
6535: PUSH
6536: LD_INT 0
6538: ST_TO_ADDR
// KolikDalkovych = 0 ;
6539: NOP4
6543: PUSH
6544: LD_INT 0
6546: ST_TO_ADDR
// DelamDalkare = false ;
6547: NOP4
6551: PUSH
6552: LD_INT 0
6554: ST_TO_ADDR
// Zniceno = false ;
6555: NOP4
6559: PUSH
6560: LD_INT 0
6562: ST_TO_ADDR
// VidelRusa = false ;
6563: NOP4
6567: PUSH
6568: LD_INT 0
6570: ST_TO_ADDR
// ProbihaUtok = false ;
6571: NOP4
6575: PUSH
6576: LD_INT 0
6578: ST_TO_ADDR
// PatrolaZrusena = false ;
6579: NOP4
6583: PUSH
6584: LD_INT 0
6586: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
6587: NOP4
6591: PUSH
6592: NOP4
6596: PUSH
6597: NOP4
6601: ARRAY
6602: ST_TO_ADDR
// PstZbrane = dif_PstZbrane [ Difficulty ] ;
6603: NOP4
6607: PUSH
6608: NOP4
6612: PUSH
6613: NOP4
6617: ARRAY
6618: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
6619: NOP4
6623: PUSH
6624: LD_INT 1
6626: NEG
6627: ST_TO_ADDR
// CisloUtoku = 1 ;
6628: NOP4
6632: PUSH
6633: LD_INT 1
6635: ST_TO_ADDR
// BeziStahovani = false ;
6636: NOP4
6640: PUSH
6641: LD_INT 0
6643: ST_TO_ADDR
// ProbihaOprava = false ;
6644: NOP4
6648: PUSH
6649: LD_INT 0
6651: ST_TO_ADDR
// ProbihaLeceni = false ;
6652: NOP4
6656: PUSH
6657: LD_INT 0
6659: ST_TO_ADDR
// if Difficulty = 1 then
6660: NOP4
6664: PUSH
6665: LD_INT 1
6667: EQUAL
6668: IFFALSE 6706
// begin DestroyUnit ( ArObr2 ) ;
6670: NOP4
6674: PPUSH
6675: NOP4
// DestroyUnit ( ArObrM1 ) ;
6679: NOP4
6683: PPUSH
6684: NOP4
// DestroyUnit ( ArObr1 ) ;
6688: NOP4
6692: PPUSH
6693: NOP4
// DestroyUnit ( ArObrM2 ) ;
6697: NOP4
6701: PPUSH
6702: NOP4
// end ; lidi_do_budov ;
6706: NOP4
// Kdo = Obranci union [ ArMech1 , ArMech2 , ArTank1 , ArTank2 ] union [ ArSolPBunk1 , ArSolPBunk2 , ArSolPBunk3 ] ;
6710: NOP4
6714: PUSH
6715: NOP4
6719: PUSH
6720: NOP4
6724: PUSH
6725: NOP4
6729: PUSH
6730: NOP4
6734: PUSH
6735: NOP4
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: LIST
6744: LIST
6745: UNION
6746: PUSH
6747: NOP4
6751: PUSH
6752: NOP4
6756: PUSH
6757: NOP4
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: LIST
6766: UNION
6767: ST_TO_ADDR
// if Difficulty > 1 then
6768: NOP4
6772: PUSH
6773: LD_INT 1
6775: GREATER
6776: IFFALSE 6815
// Kdo = Kdo union [ ArObr1 , ArObr2 , ArObrM1 , ArObrM2 ] ;
6778: NOP4
6782: PUSH
6783: NOP4
6787: PUSH
6788: NOP4
6792: PUSH
6793: NOP4
6797: PUSH
6798: NOP4
6802: PUSH
6803: NOP4
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: LIST
6812: LIST
6813: UNION
6814: ST_TO_ADDR
// Kdo = Kdo diff [ Obranci [ 1 ] , Obranci [ 2 ] ] ;
6815: NOP4
6819: PUSH
6820: NOP4
6824: PUSH
6825: NOP4
6829: PUSH
6830: LD_INT 1
6832: ARRAY
6833: PUSH
6834: NOP4
6838: PUSH
6839: LD_INT 2
6841: ARRAY
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: DIFF
6847: ST_TO_ADDR
// Registry = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_PROTECT , Obrana ] ] ) ;
6848: NOP4
6852: PUSH
6853: NOP4
6857: PPUSH
6858: LD_INT 3
6860: PUSH
6861: NOP4
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: PUSH
6870: EMPTY
6871: LIST
6872: PPUSH
6873: NOP4
6877: ST_TO_ADDR
// MakroBunkry = McCustom ( 20 , [ ArSolPBunk1 , ArSolPBunk2 , ArSolPBunk3 ] ) ;
6878: NOP4
6882: PUSH
6883: LD_INT 20
6885: PPUSH
6886: NOP4
6890: PUSH
6891: NOP4
6895: PUSH
6896: NOP4
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: LIST
6905: PPUSH
6906: NOP4
6910: ST_TO_ADDR
// MakroObrana = McDefend ( 5 , Registry , Kdo union [ ArBunk1 , ArBunk3 , ArBunk4 , ArBunk5 ] , [ ] ) ;
6911: NOP4
6915: PUSH
6916: LD_INT 5
6918: PPUSH
6919: NOP4
6923: PPUSH
6924: NOP4
6928: PUSH
6929: NOP4
6933: PUSH
6934: NOP4
6938: PUSH
6939: NOP4
6943: PUSH
6944: NOP4
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: LIST
6953: LIST
6954: UNION
6955: PPUSH
6956: EMPTY
6957: PPUSH
6958: NOP4
6962: ST_TO_ADDR
// MakroPresunZakladna = McCustom ( 1 , Kdo ) ;
6963: NOP4
6967: PUSH
6968: LD_INT 1
6970: PPUSH
6971: NOP4
6975: PPUSH
6976: NOP4
6980: ST_TO_ADDR
// RegUtok = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_GUARD , Rusove ] , MC_REG_IGNORE_FOG ] ) ;
6981: NOP4
6985: PUSH
6986: NOP4
6990: PPUSH
6991: LD_INT 2
6993: PUSH
6994: NOP4
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: LD_INT 7
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PPUSH
7010: NOP4
7014: ST_TO_ADDR
// init_miny ;
7015: NOP4
// end ;
7019: LD_VAR 0 1
7023: RET
// function init_miny ; var M ; begin
7024: LD_INT 0
7026: PPUSH
7027: PPUSH
// if Difficulty = 1 then
7028: NOP4
7032: PUSH
7033: LD_INT 1
7035: EQUAL
7036: IFFALSE 7047
// Miny = [ ] else
7038: NOP4
7042: PUSH
7043: EMPTY
7044: ST_TO_ADDR
7045: GO 7255
// begin Miny = [ [ 62 , 14 ] , [ 64 , 17 ] , [ 66 , 17 ] , [ 65 , 12 ] , [ 68 , 15 ] , [ 64 , 14 ] , [ 60 , 5 ] , [ 60 , 15 ] , [ 59 , 18 ] , [ 56 , 16 ] , [ 49 , 15 ] , [ 33 , 18 ] , [ 42 , 42 ] , [ 112 , 42 ] ] ;
7047: NOP4
7051: PUSH
7052: LD_INT 62
7054: PUSH
7055: LD_INT 14
7057: PUSH
7058: EMPTY
7059: LIST
7060: LIST
7061: PUSH
7062: LD_INT 64
7064: PUSH
7065: LD_INT 17
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 66
7074: PUSH
7075: LD_INT 17
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 65
7084: PUSH
7085: LD_INT 12
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: LD_INT 68
7094: PUSH
7095: LD_INT 15
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: PUSH
7102: LD_INT 64
7104: PUSH
7105: LD_INT 14
7107: PUSH
7108: EMPTY
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 60
7114: PUSH
7115: LD_INT 5
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 60
7124: PUSH
7125: LD_INT 15
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 59
7134: PUSH
7135: LD_INT 18
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PUSH
7142: LD_INT 56
7144: PUSH
7145: LD_INT 16
7147: PUSH
7148: EMPTY
7149: LIST
7150: LIST
7151: PUSH
7152: LD_INT 49
7154: PUSH
7155: LD_INT 15
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: PUSH
7162: LD_INT 33
7164: PUSH
7165: LD_INT 18
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: PUSH
7172: LD_INT 42
7174: PUSH
7175: LD_INT 42
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: PUSH
7182: LD_INT 112
7184: PUSH
7185: LD_INT 42
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: LIST
7199: LIST
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: LIST
7205: LIST
7206: LIST
7207: ST_TO_ADDR
// for M in Miny do
7208: NOP4
7212: PUSH
7213: NOP4
7217: PUSH
7218: FOR_IN
7219: IFFALSE 7253
// PlaceMine ( M [ 1 ] , M [ 2 ] , side_Ar , 0 ) ;
7221: NOP4
7225: PUSH
7226: LD_INT 1
7228: ARRAY
7229: PPUSH
7230: NOP4
7234: PUSH
7235: LD_INT 2
7237: ARRAY
7238: PPUSH
7239: NOP4
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: NOP4
7251: GO 7218
7253: POP
7254: POP
// end ; end ;
7255: LD_VAR 0 1
7259: RET
// function vytvor_cloveka ( Cls ) ; begin
7260: LD_INT 0
7262: PPUSH
// UC_Side = side_Ar ;
7263: LD_ADDR_OWVAR 20
7267: PUSH
7268: NOP4
7272: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
7273: LD_ADDR_OWVAR 21
7277: PUSH
7278: LD_INT 2
7280: ST_TO_ADDR
// HC_Sex = Rand ( 1 , 2 ) ;
7281: LD_ADDR_OWVAR 27
7285: PUSH
7286: LD_INT 1
7288: PPUSH
7289: LD_INT 2
7291: PPUSH
7292: NOP4
7296: ST_TO_ADDR
// HC_Class = Cls ;
7297: LD_ADDR_OWVAR 28
7301: PUSH
7302: NOP4
7306: ST_TO_ADDR
// HC_Name =  ;
7307: LD_ADDR_OWVAR 26
7311: PUSH
7312: LD_STRING 
7314: ST_TO_ADDR
// PrepareClassSkills ( Cls , dif_ArabiLevel [ Difficulty ] ) ;
7315: NOP4
7319: PPUSH
7320: NOP4
7324: PUSH
7325: NOP4
7329: ARRAY
7330: PPUSH
7331: NOP4
// Result = CreateHuman ;
7335: NOP4
7339: PUSH
7340: NOP4
7344: ST_TO_ADDR
// end ;
7345: LD_VAR 0 2
7349: RET
// function vytvor_obrance ; var I ; begin
7350: LD_INT 0
7352: PPUSH
7353: PPUSH
// Result = [ ] ;
7354: NOP4
7358: PUSH
7359: EMPTY
7360: ST_TO_ADDR
// for I = 1 to dif_ObranciArabi [ Difficulty ] do
7361: NOP4
7365: PUSH
7366: DOUBLE
7367: LD_INT 1
7369: DEC
7370: ST_TO_ADDR
7371: NOP4
7375: PUSH
7376: NOP4
7380: ARRAY
7381: PUSH
7382: FOR_TO
7383: IFFALSE 7409
// Result = Result union [ vytvor_cloveka ( CLASS_SOLDIER ) ] ;
7385: NOP4
7389: PUSH
7390: NOP4
7394: PUSH
7395: LD_INT 1
7397: PPUSH
7398: NOP4
7402: PUSH
7403: EMPTY
7404: LIST
7405: UNION
7406: ST_TO_ADDR
7407: GO 7382
7409: POP
7410: POP
// end ;
7411: LD_VAR 0 1
7415: RET
// function vytvor_volny ; var I ; begin
7416: LD_INT 0
7418: PPUSH
7419: PPUSH
// Result = [ ] ;
7420: NOP4
7424: PUSH
7425: EMPTY
7426: ST_TO_ADDR
// for I = 1 to dif_VolnyArabi [ Difficulty ] do
7427: NOP4
7431: PUSH
7432: DOUBLE
7433: LD_INT 1
7435: DEC
7436: ST_TO_ADDR
7437: NOP4
7441: PUSH
7442: NOP4
7446: ARRAY
7447: PUSH
7448: FOR_TO
7449: IFFALSE 7508
// if Prob ( 25 ) then
7451: LD_INT 25
7453: PPUSH
7454: NOP4
7458: IFFALSE 7484
// Result = Result union [ vytvor_cloveka ( CLASS_SOLDIER ) ] else
7460: NOP4
7464: PUSH
7465: NOP4
7469: PUSH
7470: LD_INT 1
7472: PPUSH
7473: NOP4
7477: PUSH
7478: EMPTY
7479: LIST
7480: UNION
7481: ST_TO_ADDR
7482: GO 7506
// Result = Result union [ vytvor_cloveka ( CLASS_MECHANIC ) ] ;
7484: NOP4
7488: PUSH
7489: NOP4
7493: PUSH
7494: LD_INT 3
7496: PPUSH
7497: NOP4
7501: PUSH
7502: EMPTY
7503: LIST
7504: UNION
7505: ST_TO_ADDR
7506: GO 7448
7508: POP
7509: POP
// end ;
7510: LD_VAR 0 1
7514: RET
// function lidi_do_budov ; begin
7515: LD_INT 0
7517: PPUSH
// ComEnterUnit ( ArMech1 , ArTank1 ) ;
7518: NOP4
7522: PPUSH
7523: NOP4
7527: PPUSH
7528: NOP4
// ComEnterUnit ( ArMech , ArFact ) ;
7532: NOP4
7536: PPUSH
7537: NOP4
7541: PPUSH
7542: NOP4
// ComEnterUnit ( ArSolPBunk1 , ArPBunk1 ) ;
7546: NOP4
7550: PPUSH
7551: NOP4
7555: PPUSH
7556: NOP4
// ComEnterUnit ( ArSolPBunk2 , ArPBunk2 ) ;
7560: NOP4
7564: PPUSH
7565: NOP4
7569: PPUSH
7570: NOP4
// if Difficulty < 3 then
7574: NOP4
7578: PUSH
7579: LD_INT 3
7581: LESS
7582: IFFALSE 7596
// SetClass ( ArSolPBunk3 , CLASS_SOLDIER ) ;
7584: NOP4
7588: PPUSH
7589: LD_INT 1
7591: PPUSH
7592: NOP4
// if Difficulty > 1 then
7596: NOP4
7600: PUSH
7601: LD_INT 1
7603: GREATER
7604: IFFALSE 7634
// begin ComEnterUnit ( ArObrM1 , ArObr1 ) ;
7606: NOP4
7610: PPUSH
7611: NOP4
7615: PPUSH
7616: NOP4
// ComEnterUnit ( ArObrM2 , ArObr2 ) ;
7620: NOP4
7624: PPUSH
7625: NOP4
7629: PPUSH
7630: NOP4
// end ; ComEnterUnit ( ArSolPBunk3 , ArPBunk3 ) ;
7634: NOP4
7638: PPUSH
7639: NOP4
7643: PPUSH
7644: NOP4
// ComEnterUnit ( ArSolRadar , ArRadar ) ;
7648: NOP4
7652: PPUSH
7653: NOP4
7657: PPUSH
7658: NOP4
// ComEnterUnit ( ArSolBunk1 , ArBunk1 ) ;
7662: NOP4
7666: PPUSH
7667: NOP4
7671: PPUSH
7672: NOP4
// ComEnterUnit ( ArSolBunk4 , ArBunk4 ) ;
7676: NOP4
7680: PPUSH
7681: NOP4
7685: PPUSH
7686: NOP4
// ComEnterUnit ( ArSolBunk6 , ArBunk6 ) ;
7690: NOP4
7694: PPUSH
7695: NOP4
7699: PPUSH
7700: NOP4
// ComEnterUnit ( ArSci1 , ArLab1 ) ;
7704: NOP4
7708: PPUSH
7709: NOP4
7713: PPUSH
7714: NOP4
// ComEnterUnit ( ArSci2 , ArLab2 ) ;
7718: NOP4
7722: PPUSH
7723: NOP4
7727: PPUSH
7728: NOP4
// end ;
7732: LD_VAR 0 1
7736: RET
// function kontrola_zniceno ; var Jednotky ; begin
7737: LD_INT 0
7739: PPUSH
7740: PPUSH
// if not Zniceno then
7741: NOP4
7745: NOT
7746: IFFALSE 7805
// begin Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] ] ) ;
7748: NOP4
7752: PUSH
7753: LD_INT 22
7755: PUSH
7756: NOP4
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 50
7767: PUSH
7768: EMPTY
7769: LIST
7770: PUSH
7771: LD_INT 52
7773: PUSH
7774: EMPTY
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: PPUSH
7782: NOP4
7786: ST_TO_ADDR
// if not Jednotky then
7787: NOP4
7791: NOT
7792: IFFALSE 7805
// begin Zniceno = true ;
7794: NOP4
7798: PUSH
7799: LD_INT 1
7801: ST_TO_ADDR
// disable ( 43 ) ;
7802: LD_INT 43
7804: DISABLE_MARKED
// end ; end ; end ;
7805: LD_VAR 0 1
7809: RET
// function vyber_zbran ; var P ; begin
7810: LD_INT 0
7812: PPUSH
7813: PPUSH
// P = Rand ( 1 , 100 ) ;
7814: NOP4
7818: PUSH
7819: LD_INT 1
7821: PPUSH
7822: LD_INT 100
7824: PPUSH
7825: NOP4
7829: ST_TO_ADDR
// if P < PstZbrane [ 1 ] then
7830: NOP4
7834: PUSH
7835: NOP4
7839: PUSH
7840: LD_INT 1
7842: ARRAY
7843: LESS
7844: IFFALSE 7856
// Result = AR_FLAME_THROWER else
7846: NOP4
7850: PUSH
7851: LD_INT 26
7853: ST_TO_ADDR
7854: GO 7916
// if P < PstZbrane [ 2 ] then
7856: NOP4
7860: PUSH
7861: NOP4
7865: PUSH
7866: LD_INT 2
7868: ARRAY
7869: LESS
7870: IFFALSE 7882
// Result = AR_GUN else
7872: NOP4
7876: PUSH
7877: LD_INT 27
7879: ST_TO_ADDR
7880: GO 7916
// if P < PstZbrane [ 3 ] then
7882: NOP4
7886: PUSH
7887: NOP4
7891: PUSH
7892: LD_INT 3
7894: ARRAY
7895: LESS
7896: IFFALSE 7908
// Result = AR_DOUBLE_MACHINE_GUN else
7898: NOP4
7902: PUSH
7903: LD_INT 24
7905: ST_TO_ADDR
7906: GO 7916
// Result = AR_ROCKET_LAUNCHER ;
7908: NOP4
7912: PUSH
7913: LD_INT 28
7915: ST_TO_ADDR
// end ;
7916: LD_VAR 0 1
7920: RET
// function vyber_ovladani ; begin
7921: LD_INT 0
7923: PPUSH
// Result = CONTROL_MANUAL ;
7924: NOP4
7928: PUSH
7929: LD_INT 1
7931: ST_TO_ADDR
// if not ArDalkar or not IsOk ( ArDalkar ) then
7932: NOP4
7936: NOT
7937: PUSH
7938: NOP4
7942: PPUSH
7943: NOP4
7947: NOT
7948: OR
7949: IFFALSE 7953
// exit ;
7951: GO 8009
// if not ArMechDalkar or not IsOk ( ArMechDalkar ) then
7953: NOP4
7957: NOT
7958: PUSH
7959: NOP4
7963: PPUSH
7964: NOP4
7968: NOT
7969: OR
7970: IFFALSE 7974
// exit ;
7972: GO 8009
// if UnitsLinked ( ArMechDalkar ) >= GetSkill ( ArMechDalkar , SKILL_MECHANICAL ) then
7974: NOP4
7978: PPUSH
7979: NOP4
7983: PUSH
7984: NOP4
7988: PPUSH
7989: LD_INT 3
7991: PPUSH
7992: NOP4
7996: GREATEREQUAL
7997: IFFALSE 8001
// exit ;
7999: GO 8009
// Result = CONTROL_REMOTE ;
8001: NOP4
8005: PUSH
8006: LD_INT 2
8008: ST_TO_ADDR
// end ;
8009: LD_VAR 0 1
8013: RET
// function kontrola_vyroby ; var Base , Chassis , Weapon , Control ; begin
8014: LD_INT 0
8016: PPUSH
8017: PPUSH
8018: PPUSH
8019: PPUSH
8020: PPUSH
// if not IsOK ( ArFact ) or HasTask ( ArFact ) then
8021: NOP4
8025: PPUSH
8026: NOP4
8030: NOT
8031: PUSH
8032: NOP4
8036: PPUSH
8037: NOP4
8041: OR
8042: IFFALSE 8046
// exit ;
8044: GO 8370
// if GetSide ( ArFact ) <> side_Ar then
8046: NOP4
8050: PPUSH
8051: NOP4
8055: PUSH
8056: NOP4
8060: NONEQUAL
8061: IFFALSE 8065
// exit ;
8063: GO 8370
// if not UnitsInside ( ArFact ) then
8065: NOP4
8069: PPUSH
8070: NOP4
8074: NOT
8075: IFFALSE 8079
// exit ;
8077: GO 8370
// if ( GetTech ( TECH_REMCONT , side_Ar ) = STATE_RESEARCHED ) and not ArDalkar and not DelamDalkare and Prob ( 75 ) then
8079: LD_INT 15
8081: PPUSH
8082: NOP4
8086: PPUSH
8087: NOP4
8091: PUSH
8092: LD_INT 2
8094: EQUAL
8095: PUSH
8096: NOP4
8100: NOT
8101: AND
8102: PUSH
8103: NOP4
8107: NOT
8108: AND
8109: PUSH
8110: LD_INT 75
8112: PPUSH
8113: NOP4
8117: AND
8118: IFFALSE 8146
// begin Chassis = AR_MEDIUM_TRIKE ;
8120: NOP4
8124: PUSH
8125: LD_INT 13
8127: ST_TO_ADDR
// Weapon = AR_CONTROL_TOWER ;
8128: NOP4
8132: PUSH
8133: LD_INT 31
8135: ST_TO_ADDR
// Control = CONTROL_MANUAL ;
8136: NOP4
8140: PUSH
8141: LD_INT 1
8143: ST_TO_ADDR
// end else
8144: GO 8193
// begin if Prob ( 50 ) then
8146: LD_INT 50
8148: PPUSH
8149: NOP4
8153: IFFALSE 8165
// Chassis = AR_MEDIUM_TRIKE else
8155: NOP4
8159: PUSH
8160: LD_INT 13
8162: ST_TO_ADDR
8163: GO 8173
// Chassis = AR_HALF_TRACKED ;
8165: NOP4
8169: PUSH
8170: LD_INT 14
8172: ST_TO_ADDR
// Weapon = vyber_zbran ;
8173: NOP4
8177: PUSH
8178: NOP4
8182: ST_TO_ADDR
// Control = vyber_ovladani ;
8183: NOP4
8187: PUSH
8188: NOP4
8192: ST_TO_ADDR
// end ; if not CanBeConstructed ( ArFact , Chassis , ENGINE_COMBUSTION , Control , Weapon ) then
8193: NOP4
8197: PPUSH
8198: NOP4
8202: PPUSH
8203: LD_INT 1
8205: PPUSH
8206: NOP4
8210: PPUSH
8211: NOP4
8215: PPUSH
8216: NOP4
8220: NOT
8221: IFFALSE 8267
// begin if not CanBeConstructed ( ArFact , AR_LIGHT_TRIKE , ENGINE_COMBUSTION , Control , AR_LIGHT_GUN ) then
8223: NOP4
8227: PPUSH
8228: LD_INT 12
8230: PPUSH
8231: LD_INT 1
8233: PPUSH
8234: NOP4
8238: PPUSH
8239: LD_INT 23
8241: PPUSH
8242: NOP4
8246: NOT
8247: IFFALSE 8251
// exit ;
8249: GO 8370
// Chassis = AR_LIGHT_TRIKE ;
8251: NOP4
8255: PUSH
8256: LD_INT 12
8258: ST_TO_ADDR
// Weapon = AR_LIGHT_GUN ;
8259: NOP4
8263: PUSH
8264: LD_INT 23
8266: ST_TO_ADDR
// end ; Base = GetBase ( ArFact ) ;
8267: NOP4
8271: PUSH
8272: NOP4
8276: PPUSH
8277: NOP4
8281: ST_TO_ADDR
// if GetResourceType ( Base , MAT_CANS ) < 120 then
8282: NOP4
8286: PPUSH
8287: LD_INT 1
8289: PPUSH
8290: NOP4
8294: PUSH
8295: LD_INT 120
8297: LESS
8298: IFFALSE 8302
// exit ;
8300: GO 8370
// if GetResourceType ( Base , MAT_OIL ) < 50 then
8302: NOP4
8306: PPUSH
8307: LD_INT 2
8309: PPUSH
8310: NOP4
8314: PUSH
8315: LD_INT 50
8317: LESS
8318: IFFALSE 8322
// exit ;
8320: GO 8370
// AddComConstruct ( ArFact , Chassis , ENGINE_COMBUSTION , Control , Weapon ) ;
8322: NOP4
8326: PPUSH
8327: NOP4
8331: PPUSH
8332: LD_INT 1
8334: PPUSH
8335: NOP4
8339: PPUSH
8340: NOP4
8344: PPUSH
8345: NOP4
// if Weapon = AR_CONTROL_TOWER then
8349: NOP4
8353: PUSH
8354: LD_INT 31
8356: EQUAL
8357: IFFALSE 8370
// begin DelamDalkare = true ;
8359: NOP4
8363: PUSH
8364: LD_INT 1
8366: ST_TO_ADDR
// enable ( 47 ) ;
8367: LD_INT 47
8369: ENABLE_MARKED
// end ; end ;
8370: LD_VAR 0 1
8374: RET
// every 5 5$1 marked 47 do
8375: GO 8377
8377: DISABLE
// begin if not ArDalkar then
8378: NOP4
8382: NOT
8383: IFFALSE 8393
// DelamDalkare = false ;
8385: NOP4
8389: PUSH
8390: LD_INT 0
8392: ST_TO_ADDR
// end ;
8393: END
// function zacni_vynalezat ; begin
8394: LD_INT 0
8396: PPUSH
// AddComResearch ( ArLab1 , TECH_GUN ) ;
8397: NOP4
8401: PPUSH
8402: LD_INT 39
8404: PPUSH
8405: NOP4
// AddComResearch ( ArLab1 , TECH_FLAME ) ;
8409: NOP4
8413: PPUSH
8414: LD_INT 70
8416: PPUSH
8417: NOP4
// AddComResearch ( ArLab1 , TECH_ROCKET ) ;
8421: NOP4
8425: PPUSH
8426: LD_INT 40
8428: PPUSH
8429: NOP4
// AddComResearch ( ArLab1 , TECH_GATLING ) ;
8433: NOP4
8437: PPUSH
8438: LD_INT 69
8440: PPUSH
8441: NOP4
// AddComResearch ( ArLab1 , TECH_STIMDRUGS ) ;
8445: NOP4
8449: PPUSH
8450: LD_INT 5
8452: PPUSH
8453: NOP4
// AddComResearch ( ArLab1 , TECH_EXPLOS ) ;
8457: NOP4
8461: PPUSH
8462: LD_INT 42
8464: PPUSH
8465: NOP4
// AddComResearch ( ArLab1 , TECH_SELFDEST ) ;
8469: NOP4
8473: PPUSH
8474: LD_INT 43
8476: PPUSH
8477: NOP4
// AddComResearch ( ArLab1 , TECH_WEAP1 ) ;
8481: NOP4
8485: PPUSH
8486: LD_INT 51
8488: PPUSH
8489: NOP4
// AddComResearch ( ArLab1 , TECH_WEAP2 ) ;
8493: NOP4
8497: PPUSH
8498: LD_INT 52
8500: PPUSH
8501: NOP4
// AddComResearch ( ArLab1 , TECH_BIO2 ) ;
8505: NOP4
8509: PPUSH
8510: LD_INT 67
8512: PPUSH
8513: NOP4
// AddComResearch ( ArLab1 , TECH_BIO2 ) ;
8517: NOP4
8521: PPUSH
8522: LD_INT 67
8524: PPUSH
8525: NOP4
// AddComResearch ( ArLab2 , TECH_RADAR ) ;
8529: NOP4
8533: PPUSH
8534: LD_INT 6
8536: PPUSH
8537: NOP4
// AddComResearch ( ArLab2 , TECH_REMCONT ) ;
8541: NOP4
8545: PPUSH
8546: LD_INT 15
8548: PPUSH
8549: NOP4
// AddComResearch ( ArLab2 , TECH_MATDET ) ;
8553: NOP4
8557: PPUSH
8558: LD_INT 7
8560: PPUSH
8561: NOP4
// AddComResearch ( ArLab2 , TECH_TECH1 ) ;
8565: NOP4
8569: PPUSH
8570: LD_INT 48
8572: PPUSH
8573: NOP4
// AddComResearch ( ArLab2 , TECH_TECH2 ) ;
8577: NOP4
8581: PPUSH
8582: LD_INT 49
8584: PPUSH
8585: NOP4
// AddComResearch ( ArLab2 , TECH_SIBDET ) ;
8589: NOP4
8593: PPUSH
8594: LD_INT 20
8596: PPUSH
8597: NOP4
// AddComResearch ( ArLab2 , TECH_OPTO1 ) ;
8601: NOP4
8605: PPUSH
8606: LD_INT 60
8608: PPUSH
8609: NOP4
// AddComResearch ( ArLab2 , TECH_OPTO2 ) ;
8613: NOP4
8617: PPUSH
8618: LD_INT 61
8620: PPUSH
8621: NOP4
// end ;
8625: LD_VAR 0 1
8629: RET
// function zacni_utok ; begin
8630: LD_INT 0
8632: PPUSH
// ProbihaUtok = true ;
8633: NOP4
8637: PUSH
8638: LD_INT 1
8640: ST_TO_ADDR
// MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , AraboveParkoviste ] , [ MC_RETREAT_AREA_VEHICLES , AraboveParkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
8641: NOP4
8645: PUSH
8646: LD_INT 10
8648: PPUSH
8649: NOP4
8653: PPUSH
8654: NOP4
8658: PPUSH
8659: LD_INT 7
8661: PUSH
8662: NOP4
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PUSH
8671: LD_INT 8
8673: PUSH
8674: NOP4
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PUSH
8683: LD_INT 5
8685: PUSH
8686: LD_INT 10
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: PUSH
8693: LD_INT 6
8695: PUSH
8696: LD_INT 10
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: LIST
8708: PPUSH
8709: NOP4
8713: ST_TO_ADDR
// end ;
8714: LD_VAR 0 1
8718: RET
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne ; begin
8719: LD_INT 0
8721: PPUSH
8722: PPUSH
8723: PPUSH
8724: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
8725: NOP4
8729: PUSH
8730: NOP4
8734: PUSH
8735: NOP4
8739: ARRAY
8740: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
8741: NOP4
8745: PUSH
8746: LD_INT 1
8748: PPUSH
8749: LD_INT 100
8751: PPUSH
8752: NOP4
8756: ST_TO_ADDR
// if ( I < 25 ) then
8757: NOP4
8761: PUSH
8762: LD_INT 25
8764: LESS
8765: IFFALSE 8783
// KolikChci = KolikChci - 1 else
8767: NOP4
8771: PUSH
8772: NOP4
8776: PUSH
8777: LD_INT 1
8779: MINUS
8780: ST_TO_ADDR
8781: GO 8817
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
8783: NOP4
8787: PUSH
8788: LD_INT 75
8790: GREATER
8791: PUSH
8792: NOP4
8796: PUSH
8797: LD_INT 1
8799: GREATER
8800: AND
8801: IFFALSE 8817
// KolikChci = KolikChci + 1 ;
8803: NOP4
8807: PUSH
8808: NOP4
8812: PUSH
8813: LD_INT 1
8815: PLUS
8816: ST_TO_ADDR
// Riditelne = [ ] ;
8817: NOP4
8821: PUSH
8822: EMPTY
8823: ST_TO_ADDR
// for I in Autaky diff Patrola do
8824: NOP4
8828: PUSH
8829: NOP4
8833: PUSH
8834: NOP4
8838: DIFF
8839: PUSH
8840: FOR_IN
8841: IFFALSE 8927
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
8843: NOP4
8847: PPUSH
8848: NOP4
8852: PUSH
8853: LD_INT 1
8855: EQUAL
8856: PUSH
8857: NOP4
8861: PPUSH
8862: NOP4
8866: NOT
8867: AND
8868: IFFALSE 8872
// continue ;
8870: GO 8840
// if ( GetWeapon ( I ) = AR_CONTROL_TOWER ) then
8872: NOP4
8876: PPUSH
8877: NOP4
8881: PUSH
8882: LD_INT 31
8884: EQUAL
8885: IFFALSE 8889
// continue ;
8887: GO 8840
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
8889: NOP4
8893: PPUSH
8894: NOP4
8898: PUSH
8899: LD_INT 1000
8901: LESS
8902: IFFALSE 8906
// continue ;
8904: GO 8840
// Riditelne = Riditelne union [ I ] ;
8906: NOP4
8910: PUSH
8911: NOP4
8915: PUSH
8916: NOP4
8920: PUSH
8921: EMPTY
8922: LIST
8923: UNION
8924: ST_TO_ADDR
// end ;
8925: GO 8840
8927: POP
8928: POP
// if Riditelne >= KolikChci then
8929: NOP4
8933: PUSH
8934: NOP4
8938: GREATEREQUAL
8939: IFFALSE 8994
// begin Result = [ ] ;
8941: NOP4
8945: PUSH
8946: EMPTY
8947: ST_TO_ADDR
// for I = 1 to KolikChci do
8948: NOP4
8952: PUSH
8953: DOUBLE
8954: LD_INT 1
8956: DEC
8957: ST_TO_ADDR
8958: NOP4
8962: PUSH
8963: FOR_TO
8964: IFFALSE 8990
// Result = Result union Riditelne [ I ] ;
8966: NOP4
8970: PUSH
8971: NOP4
8975: PUSH
8976: NOP4
8980: PUSH
8981: NOP4
8985: ARRAY
8986: UNION
8987: ST_TO_ADDR
8988: GO 8963
8990: POP
8991: POP
// end else
8992: GO 9001
// Result = [ ] ;
8994: NOP4
8998: PUSH
8999: EMPTY
9000: ST_TO_ADDR
// end ;
9001: LD_VAR 0 1
9005: RET
// function vrat_utok ; var I ; begin
9006: LD_INT 0
9008: PPUSH
9009: PPUSH
// ProbihaUtok = false ;
9010: NOP4
9014: PUSH
9015: LD_INT 0
9017: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
9018: NOP4
9022: PUSH
9023: NOP4
9027: PUSH
9028: LD_INT 1
9030: PLUS
9031: ST_TO_ADDR
// MakroUtok = 0 ;
9032: NOP4
9036: PUSH
9037: LD_INT 0
9039: ST_TO_ADDR
// AddComMoveUnit ( Utok_Auta , ArDepot ) ;
9040: NOP4
9044: PPUSH
9045: NOP4
9049: PPUSH
9050: NOP4
// AddComMoveToArea ( Utok_Auta , AraboveParkoviste ) ;
9054: NOP4
9058: PPUSH
9059: NOP4
9063: PPUSH
9064: NOP4
// end ;
9068: LD_VAR 0 1
9072: RET
// export function arabi_McAttackDone ( McId , Un ) ; begin
9073: LD_INT 0
9075: PPUSH
// vrat_utok ;
9076: NOP4
// end ;
9080: LD_VAR 0 3
9084: RET
// function oprava_utok ; var JsouOK , JsouTam , Auto , Task , Budova ; begin
9085: LD_INT 0
9087: PPUSH
9088: PPUSH
9089: PPUSH
9090: PPUSH
9091: PPUSH
9092: PPUSH
// JsouOK = false ;
9093: NOP4
9097: PUSH
9098: LD_INT 0
9100: ST_TO_ADDR
// JsouTam = true ;
9101: NOP4
9105: PUSH
9106: LD_INT 1
9108: ST_TO_ADDR
// Task = false ;
9109: NOP4
9113: PUSH
9114: LD_INT 0
9116: ST_TO_ADDR
// for Auto in Utok_Auta do
9117: NOP4
9121: PUSH
9122: NOP4
9126: PUSH
9127: FOR_IN
9128: IFFALSE 9195
// begin if IsOK ( Auto ) then
9130: NOP4
9134: PPUSH
9135: NOP4
9139: IFFALSE 9193
// begin JsouOK = true ;
9141: NOP4
9145: PUSH
9146: LD_INT 1
9148: ST_TO_ADDR
// if not IsInArea ( Auto , ArabskaBaze ) then
9149: NOP4
9153: PPUSH
9154: NOP4
9158: PPUSH
9159: NOP4
9163: NOT
9164: IFFALSE 9174
// JsouTam = false ;
9166: NOP4
9170: PUSH
9171: LD_INT 0
9173: ST_TO_ADDR
// if HasTask ( Auto ) then
9174: NOP4
9178: PPUSH
9179: NOP4
9183: IFFALSE 9193
// Task = true ;
9185: NOP4
9189: PUSH
9190: LD_INT 1
9192: ST_TO_ADDR
// end ; end ;
9193: GO 9127
9195: POP
9196: POP
// if not Utok_Auta or not JsouOK then
9197: NOP4
9201: NOT
9202: PUSH
9203: NOP4
9207: NOT
9208: OR
9209: IFFALSE 9221
// begin Result = true ;
9211: NOP4
9215: PUSH
9216: LD_INT 1
9218: ST_TO_ADDR
// exit ;
9219: GO 9382
// end ; if ( not JsouTam ) or Task then
9221: NOP4
9225: NOT
9226: PUSH
9227: NOP4
9231: OR
9232: IFFALSE 9244
// begin Result = false ;
9234: NOP4
9238: PUSH
9239: LD_INT 0
9241: ST_TO_ADDR
// exit ;
9242: GO 9382
// end ; Result = true ;
9244: NOP4
9248: PUSH
9249: LD_INT 1
9251: ST_TO_ADDR
// if not IsOK ( ArMech ) then
9252: NOP4
9256: PPUSH
9257: NOP4
9261: NOT
9262: IFFALSE 9266
// exit ;
9264: GO 9382
// Budova = IsInUnit ( ArMech ) ;
9266: NOP4
9270: PUSH
9271: NOP4
9275: PPUSH
9276: NOP4
9280: ST_TO_ADDR
// if ( Budova <> ArFact ) and ( Budova <> 0 ) then
9281: NOP4
9285: PUSH
9286: NOP4
9290: NONEQUAL
9291: PUSH
9292: NOP4
9296: PUSH
9297: LD_INT 0
9299: NONEQUAL
9300: AND
9301: IFFALSE 9305
// exit ;
9303: GO 9382
// ComExitBuilding ( ArMech ) ;
9305: NOP4
9309: PPUSH
9310: NOP4
// Wait ( 0 0$1.3 ) ;
9314: LD_INT 46
9316: PPUSH
9317: NOP4
// for Auto in Utok_Auta do
9321: NOP4
9325: PUSH
9326: NOP4
9330: PUSH
9331: FOR_IN
9332: IFFALSE 9366
// begin if IsInArea ( Auto , ArabskaBaze ) then
9334: NOP4
9338: PPUSH
9339: NOP4
9343: PPUSH
9344: NOP4
9348: IFFALSE 9364
// AddComRepairVehicle ( ArMech , Auto ) ;
9350: NOP4
9354: PPUSH
9355: NOP4
9359: PPUSH
9360: NOP4
// end ;
9364: GO 9331
9366: POP
9367: POP
// AddComEnterUnit ( ArMech , ArFact ) ;
9368: NOP4
9372: PPUSH
9373: NOP4
9377: PPUSH
9378: NOP4
// end ;
9382: LD_VAR 0 1
9386: RET
// function zjisti_cas_utoku ; begin
9387: LD_INT 0
9389: PPUSH
// if CasyUtoku then
9390: NOP4
9394: IFFALSE 9440
// begin Result = CasyUtoku [ 1 ] ;
9396: NOP4
9400: PUSH
9401: NOP4
9405: PUSH
9406: LD_INT 1
9408: ARRAY
9409: ST_TO_ADDR
// if CasyUtoku > 1 then
9410: NOP4
9414: PUSH
9415: LD_INT 1
9417: GREATER
9418: IFFALSE 9438
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
9420: NOP4
9424: PUSH
9425: NOP4
9429: PPUSH
9430: LD_INT 1
9432: PPUSH
9433: NOP4
9437: ST_TO_ADDR
// end else
9438: GO 9448
// Result = 5 ;
9440: NOP4
9444: PUSH
9445: LD_INT 5
9447: ST_TO_ADDR
// end ;
9448: LD_VAR 0 1
9452: RET
// function utoceni_splneny_predpoklady ; begin
9453: LD_INT 0
9455: PPUSH
// Result = VidelRusa or ( Minuty > 15 ) ;
9456: NOP4
9460: PUSH
9461: NOP4
9465: PUSH
9466: NOP4
9470: PUSH
9471: LD_INT 15
9473: GREATER
9474: OR
9475: ST_TO_ADDR
// if Prob ( 25 ) then
9476: LD_INT 25
9478: PPUSH
9479: NOP4
9483: IFFALSE 9493
// Result = false ;
9485: NOP4
9489: PUSH
9490: LD_INT 0
9492: ST_TO_ADDR
// end ;
9493: LD_VAR 0 1
9497: RET
// function casovac_utok ; begin
9498: LD_INT 0
9500: PPUSH
// if ProbihaUtok then
9501: NOP4
9505: IFFALSE 9509
// exit ;
9507: GO 9608
// if Utok_ZbyvaMinut = - 1 then
9509: NOP4
9513: PUSH
9514: LD_INT 1
9516: NEG
9517: EQUAL
9518: IFFALSE 9530
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
9520: NOP4
9524: PUSH
9525: NOP4
9529: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
9530: NOP4
9534: PUSH
9535: LD_INT 0
9537: GREATER
9538: IFFALSE 9554
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
9540: NOP4
9544: PUSH
9545: NOP4
9549: PUSH
9550: LD_INT 1
9552: MINUS
9553: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
9554: NOP4
9558: NOT
9559: IFFALSE 9563
// exit ;
9561: GO 9608
// if Utok_ZbyvaMinut > 0 then
9563: NOP4
9567: PUSH
9568: LD_INT 0
9570: GREATER
9571: IFFALSE 9575
// exit ;
9573: GO 9608
// Utok_Auta = zjisti_auta_na_utok ;
9575: NOP4
9579: PUSH
9580: NOP4
9584: ST_TO_ADDR
// if not Utok_Auta then
9585: NOP4
9589: NOT
9590: IFFALSE 9594
// exit ;
9592: GO 9608
// zacni_utok ;
9594: NOP4
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
9598: NOP4
9602: PUSH
9603: NOP4
9607: ST_TO_ADDR
// end ;
9608: LD_VAR 0 1
9612: RET
// every 0 0$6 do
9613: GO 9615
9615: DISABLE
// begin zacni_vynalezat ;
9616: NOP4
// patrola_kolecko ;
9620: NOP4
// end ;
9624: END
// every 0 0$19 do
9625: GO 9627
9627: DISABLE
// begin kontrola_vyroby ;
9628: NOP4
// enable ;
9632: ENABLE
// end ;
9633: END
// export function arabi_VehicleConstructed ( Veh , Fact ) ; var Ridic , NovyRidic ; begin
9634: LD_INT 0
9636: PPUSH
9637: PPUSH
9638: PPUSH
// if GetSide ( Veh ) = side_Ar then
9639: NOP4
9643: PPUSH
9644: NOP4
9648: PUSH
9649: NOP4
9653: EQUAL
9654: IFFALSE 9936
// begin NovyRidic = 0 ;
9656: NOP4
9660: PUSH
9661: LD_INT 0
9663: ST_TO_ADDR
// Autaky = Autaky union [ Veh ] ;
9664: NOP4
9668: PUSH
9669: NOP4
9673: PUSH
9674: NOP4
9678: PUSH
9679: EMPTY
9680: LIST
9681: UNION
9682: ST_TO_ADDR
// if ( GetWeapon ( Veh ) = AR_CONTROL_TOWER ) then
9683: NOP4
9687: PPUSH
9688: NOP4
9692: PUSH
9693: LD_INT 31
9695: EQUAL
9696: IFFALSE 9726
// begin ArDalkar = Veh ;
9698: NOP4
9702: PUSH
9703: NOP4
9707: ST_TO_ADDR
// NovyRidic = ArMechDalkar ;
9708: NOP4
9712: PUSH
9713: NOP4
9717: ST_TO_ADDR
// DelamDalkare = false ;
9718: NOP4
9722: PUSH
9723: LD_INT 0
9725: ST_TO_ADDR
// end ; if ( GetControl ( Veh ) = CONTROL_MANUAL ) and VolnyLidi then
9726: NOP4
9730: PPUSH
9731: NOP4
9735: PUSH
9736: LD_INT 1
9738: EQUAL
9739: PUSH
9740: NOP4
9744: AND
9745: IFFALSE 9869
// begin Ridic = IsDrivenBy ( Veh ) ;
9747: NOP4
9751: PUSH
9752: NOP4
9756: PPUSH
9757: NOP4
9761: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
9762: LD_INT 105
9764: PPUSH
9765: NOP4
// ComExitVehicle ( Ridic ) ;
9769: NOP4
9773: PPUSH
9774: NOP4
// Wait ( 0 0$1 ) ;
9778: LD_INT 35
9780: PPUSH
9781: NOP4
// while IsDrivenBy ( Veh ) = Ridic do
9785: NOP4
9789: PPUSH
9790: NOP4
9794: PUSH
9795: NOP4
9799: EQUAL
9800: IFFALSE 9811
// Wait ( 0 0$1 ) ;
9802: LD_INT 35
9804: PPUSH
9805: NOP4
9809: GO 9785
// AddComEnterUnit ( Ridic , Fact ) ;
9811: NOP4
9815: PPUSH
9816: NOP4
9820: PPUSH
9821: NOP4
// if NovyRidic then
9825: NOP4
9829: IFFALSE 9845
// ComEnterUnit ( NovyRidic , Veh ) ;
9831: NOP4
9835: PPUSH
9836: NOP4
9840: PPUSH
9841: NOP4
// Wait ( 0 0$3 ) ;
9845: LD_INT 105
9847: PPUSH
9848: NOP4
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
9852: NOP4
9856: PPUSH
9857: NOP4
9861: PUSH
9862: EMPTY
9863: LIST
9864: PPUSH
9865: NOP4
// end ; if ( GetControl ( Veh ) = CONTROL_REMOTE ) then
9869: NOP4
9873: PPUSH
9874: NOP4
9878: PUSH
9879: LD_INT 2
9881: EQUAL
9882: IFFALSE 9936
// begin LinkVehicleToHuman ( Veh , ArMechDalkar ) ;
9884: NOP4
9888: PPUSH
9889: NOP4
9893: PPUSH
9894: NOP4
// KolikDalkovych = KolikDalkovych + 1 ;
9898: NOP4
9902: PUSH
9903: NOP4
9907: PUSH
9908: LD_INT 1
9910: PLUS
9911: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
9912: LD_INT 105
9914: PPUSH
9915: NOP4
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
9919: NOP4
9923: PPUSH
9924: NOP4
9928: PUSH
9929: EMPTY
9930: LIST
9931: PPUSH
9932: NOP4
// end ; end ; end ;
9936: LD_VAR 0 3
9940: RET
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
9941: LD_INT 0
9943: PPUSH
9944: PPUSH
9945: PPUSH
// if Veh = ArDalkar then
9946: NOP4
9950: PUSH
9951: NOP4
9955: EQUAL
9956: IFFALSE 9997
// begin if IsOk ( ArMechDalkar ) and not IsInUnit ( ArMechDalkar ) then
9958: NOP4
9962: PPUSH
9963: NOP4
9967: PUSH
9968: NOP4
9972: PPUSH
9973: NOP4
9977: NOT
9978: AND
9979: IFFALSE 9997
// begin ComEnterUnit ( ArMechDalkar , Veh ) ;
9981: NOP4
9985: PPUSH
9986: NOP4
9990: PPUSH
9991: NOP4
// exit ;
9995: GO 10068
// end ; end ; Lidi = UnitFilter ( VolnyLidi , [ [ F_OUTSIDE ] ] ) ;
9997: NOP4
10001: PUSH
10002: NOP4
10006: PPUSH
10007: LD_INT 56
10009: PUSH
10010: EMPTY
10011: LIST
10012: PUSH
10013: EMPTY
10014: LIST
10015: PPUSH
10016: NOP4
10020: ST_TO_ADDR
// for I in Lidi do
10021: NOP4
10025: PUSH
10026: NOP4
10030: PUSH
10031: FOR_IN
10032: IFFALSE 10066
// if not HasTask ( I ) then
10034: NOP4
10038: PPUSH
10039: NOP4
10043: NOT
10044: IFFALSE 10064
// begin ComEnterUnit ( I , Veh ) ;
10046: NOP4
10050: PPUSH
10051: NOP4
10055: PPUSH
10056: NOP4
// exit ;
10060: POP
10061: POP
10062: GO 10068
// end ;
10064: GO 10031
10066: POP
10067: POP
// end ;
10068: LD_VAR 0 2
10072: RET
// function nastupuj_auta ; var Auta , I ; begin
10073: LD_INT 0
10075: PPUSH
10076: PPUSH
10077: PPUSH
// Auta = FilterUnitsInArea ( Obrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
10078: NOP4
10082: PUSH
10083: NOP4
10087: PPUSH
10088: LD_INT 21
10090: PUSH
10091: LD_INT 2
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: LD_INT 33
10100: PUSH
10101: LD_INT 1
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: PUSH
10108: LD_INT 58
10110: PUSH
10111: EMPTY
10112: LIST
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: PPUSH
10119: NOP4
10123: ST_TO_ADDR
// if not Auta then
10124: NOP4
10128: NOT
10129: IFFALSE 10133
// exit ;
10131: GO 10159
// for I in Auta do
10133: NOP4
10137: PUSH
10138: NOP4
10142: PUSH
10143: FOR_IN
10144: IFFALSE 10157
// zarid_ridice ( I ) ;
10146: NOP4
10150: PPUSH
10151: NOP4
10155: GO 10143
10157: POP
10158: POP
// end ;
10159: LD_VAR 0 1
10163: RET
// every 0 0$17 do
10164: GO 10166
10166: DISABLE
// begin nastupuj_auta ;
10167: NOP4
// enable ;
10171: ENABLE
// end ;
10172: END
// export function arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
10173: LD_INT 0
10175: PPUSH
// if VehOld in Patrola then
10176: NOP4
10180: PUSH
10181: NOP4
10185: IN
10186: IFFALSE 10207
// Patrola = Patrola diff [ VehOld ] ;
10188: NOP4
10192: PUSH
10193: NOP4
10197: PUSH
10198: NOP4
10202: PUSH
10203: EMPTY
10204: LIST
10205: DIFF
10206: ST_TO_ADDR
// if VehOld in Autaky then
10207: NOP4
10211: PUSH
10212: NOP4
10216: IN
10217: IFFALSE 10238
// Autaky = Autaky diff [ VehOld ] ;
10219: NOP4
10223: PUSH
10224: NOP4
10228: PUSH
10229: NOP4
10233: PUSH
10234: EMPTY
10235: LIST
10236: DIFF
10237: ST_TO_ADDR
// if VehOld in Utok_Auta then
10238: NOP4
10242: PUSH
10243: NOP4
10247: IN
10248: IFFALSE 10269
// Utok_Auta = Utok_Auta diff [ VehOld ] ;
10250: NOP4
10254: PUSH
10255: NOP4
10259: PUSH
10260: NOP4
10264: PUSH
10265: EMPTY
10266: LIST
10267: DIFF
10268: ST_TO_ADDR
// if GetSide ( VehNew ) = side_Ar then
10269: NOP4
10273: PPUSH
10274: NOP4
10278: PUSH
10279: NOP4
10283: EQUAL
10284: IFFALSE 10333
// begin Autaky = Autaky union [ VehNew ] ;
10286: NOP4
10290: PUSH
10291: NOP4
10295: PUSH
10296: NOP4
10300: PUSH
10301: EMPTY
10302: LIST
10303: UNION
10304: ST_TO_ADDR
// AddMcUnits ( MakroObrana , VehNew ) ;
10305: NOP4
10309: PPUSH
10310: NOP4
10314: PPUSH
10315: NOP4
// AddMcUnits ( MakroPresunZakladna , VehNew ) ;
10319: NOP4
10323: PPUSH
10324: NOP4
10328: PPUSH
10329: NOP4
// end ; if GetSide ( VehOld ) = side_Ar then
10333: NOP4
10337: PPUSH
10338: NOP4
10342: PUSH
10343: NOP4
10347: EQUAL
10348: IFFALSE 10398
// begin RemoveMcUnits ( MakroObrana , VehOld ) ;
10350: NOP4
10354: PPUSH
10355: NOP4
10359: PPUSH
10360: NOP4
// RemoveMcUnits ( MakroPresunZakladna , VehOld ) ;
10364: NOP4
10368: PPUSH
10369: NOP4
10373: PPUSH
10374: NOP4
// if MakroUtok then
10378: NOP4
10382: IFFALSE 10398
// RemoveMcUnits ( MakroUtok , VehOld ) ;
10384: NOP4
10388: PPUSH
10389: NOP4
10393: PPUSH
10394: NOP4
// end ; kontrola_zniceno ;
10398: NOP4
// end ;
10402: LD_VAR 0 5
10406: RET
// export function arabi_UnitDestroyed ( Un ) ; begin
10407: LD_INT 0
10409: PPUSH
// if Un in Patrola then
10410: NOP4
10414: PUSH
10415: NOP4
10419: IN
10420: IFFALSE 10441
// Patrola = Patrola diff [ Un ] ;
10422: NOP4
10426: PUSH
10427: NOP4
10431: PUSH
10432: NOP4
10436: PUSH
10437: EMPTY
10438: LIST
10439: DIFF
10440: ST_TO_ADDR
// if Un in Autaky then
10441: NOP4
10445: PUSH
10446: NOP4
10450: IN
10451: IFFALSE 10472
// Autaky = Autaky diff [ Un ] ;
10453: NOP4
10457: PUSH
10458: NOP4
10462: PUSH
10463: NOP4
10467: PUSH
10468: EMPTY
10469: LIST
10470: DIFF
10471: ST_TO_ADDR
// if Un in Utok_Auta then
10472: NOP4
10476: PUSH
10477: NOP4
10481: IN
10482: IFFALSE 10503
// Utok_Auta = Utok_Auta diff [ Un ] ;
10484: NOP4
10488: PUSH
10489: NOP4
10493: PUSH
10494: NOP4
10498: PUSH
10499: EMPTY
10500: LIST
10501: DIFF
10502: ST_TO_ADDR
// if Un in VolnyLidi then
10503: NOP4
10507: PUSH
10508: NOP4
10512: IN
10513: IFFALSE 10534
// VolnyLidi = VolnyLidi diff [ Un ] ;
10515: NOP4
10519: PUSH
10520: NOP4
10524: PUSH
10525: NOP4
10529: PUSH
10530: EMPTY
10531: LIST
10532: DIFF
10533: ST_TO_ADDR
// kontrola_zniceno ;
10534: NOP4
// end ;
10538: LD_VAR 0 2
10542: RET
// export function arabi_UnitGoesToRed ( Un ) ; begin
10543: LD_INT 0
10545: PPUSH
// if ( Un = ArPBunk1 ) then
10546: NOP4
10550: PUSH
10551: NOP4
10555: EQUAL
10556: IFFALSE 10591
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk1 ] ;
10558: NOP4
10562: PUSH
10563: NOP4
10567: PUSH
10568: NOP4
10572: PUSH
10573: EMPTY
10574: LIST
10575: UNION
10576: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk1 ) ;
10577: NOP4
10581: PPUSH
10582: NOP4
10586: PPUSH
10587: NOP4
// end ; if ( Un = ArPBunk2 ) then
10591: NOP4
10595: PUSH
10596: NOP4
10600: EQUAL
10601: IFFALSE 10636
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk2 ] ;
10603: NOP4
10607: PUSH
10608: NOP4
10612: PUSH
10613: NOP4
10617: PUSH
10618: EMPTY
10619: LIST
10620: UNION
10621: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk2 ) ;
10622: NOP4
10626: PPUSH
10627: NOP4
10631: PPUSH
10632: NOP4
// end ; if ( Un = ArPBunk3 ) then
10636: NOP4
10640: PUSH
10641: NOP4
10645: EQUAL
10646: IFFALSE 10681
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk3 ] ;
10648: NOP4
10652: PUSH
10653: NOP4
10657: PUSH
10658: NOP4
10662: PUSH
10663: EMPTY
10664: LIST
10665: UNION
10666: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk3 ) ;
10667: NOP4
10671: PPUSH
10672: NOP4
10676: PPUSH
10677: NOP4
// end ; end ;
10681: LD_VAR 0 2
10685: RET
// export function arabi_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
10686: LD_INT 0
10688: PPUSH
// kontrola_zniceno ;
10689: NOP4
// end ;
10693: LD_VAR 0 4
10697: RET
// export function arabi_muzete_utocit ; begin
10698: LD_INT 0
10700: PPUSH
// enable ( 43 ) ;
10701: LD_INT 43
10703: ENABLE_MARKED
// end ;
10704: LD_VAR 0 1
10708: RET
// every 0 0$45 marked 43 do
10709: GO 10711
10711: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
10712: LD_INT 0
10714: PPUSH
10715: LD_INT 1050
10717: PPUSH
10718: NOP4
10722: PPUSH
10723: NOP4
// casovac_utok ;
10727: NOP4
// enable ;
10731: ENABLE
// end ;
10732: END
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Ar , side_Ru ) do
10733: NOP4
10737: PPUSH
10738: NOP4
10742: PPUSH
10743: NOP4
10747: IFFALSE 10764
10749: GO 10751
10751: DISABLE
// begin VidelRusa = true ;
10752: NOP4
10756: PUSH
10757: LD_INT 1
10759: ST_TO_ADDR
// zrus_patrolu ;
10760: NOP4
// end ;
10764: END
// function zrus_patrolu ; begin
10765: LD_INT 0
10767: PPUSH
// ComAgressiveMove ( Patrola , 73 , 13 ) ;
10768: NOP4
10772: PPUSH
10773: LD_INT 73
10775: PPUSH
10776: LD_INT 13
10778: PPUSH
10779: NOP4
// AddComMoveUnit ( Patrola , ArDepot ) ;
10783: NOP4
10787: PPUSH
10788: NOP4
10792: PPUSH
10793: NOP4
// AddComMoveToArea ( Patrola , AraboveParkoviste ) ;
10797: NOP4
10801: PPUSH
10802: NOP4
10806: PPUSH
10807: NOP4
// Patrola = [ ] ;
10811: NOP4
10815: PUSH
10816: EMPTY
10817: ST_TO_ADDR
// PatrolaZrusena = true ;
10818: NOP4
10822: PUSH
10823: LD_INT 1
10825: ST_TO_ADDR
// disable ( 45 ) ;
10826: LD_INT 45
10828: DISABLE_MARKED
// end ;
10829: LD_VAR 0 1
10833: RET
// function patrola_kolecko ; begin
10834: LD_INT 0
10836: PPUSH
// ComMoveUnit ( Patrola , ArDepot ) ;
10837: NOP4
10841: PPUSH
10842: NOP4
10846: PPUSH
10847: NOP4
// AddComMoveXY ( Patrola , 83 , 12 ) ;
10851: NOP4
10855: PPUSH
10856: LD_INT 83
10858: PPUSH
10859: LD_INT 12
10861: PPUSH
10862: NOP4
// AddComMoveXY ( Patrola , 68 , 13 ) ;
10866: NOP4
10870: PPUSH
10871: LD_INT 68
10873: PPUSH
10874: LD_INT 13
10876: PPUSH
10877: NOP4
// AddComMoveXY ( Patrola , 62 , 15 ) ;
10881: NOP4
10885: PPUSH
10886: LD_INT 62
10888: PPUSH
10889: LD_INT 15
10891: PPUSH
10892: NOP4
// AddComMoveXY ( Patrola , 54 , 15 ) ;
10896: NOP4
10900: PPUSH
10901: LD_INT 54
10903: PPUSH
10904: LD_INT 15
10906: PPUSH
10907: NOP4
// AddComMoveXY ( Patrola , 46 , 13 ) ;
10911: NOP4
10915: PPUSH
10916: LD_INT 46
10918: PPUSH
10919: LD_INT 13
10921: PPUSH
10922: NOP4
// AddComMoveXY ( Patrola , 36 , 13 ) ;
10926: NOP4
10930: PPUSH
10931: LD_INT 36
10933: PPUSH
10934: LD_INT 13
10936: PPUSH
10937: NOP4
// AddComMoveXY ( Patrola , 31 , 17 ) ;
10941: NOP4
10945: PPUSH
10946: LD_INT 31
10948: PPUSH
10949: LD_INT 17
10951: PPUSH
10952: NOP4
// AddComWait ( Patrola , 0 0$4.7 ) ;
10956: NOP4
10960: PPUSH
10961: LD_INT 165
10963: PPUSH
10964: NOP4
// AddComMoveXY ( Patrola , 20 , 16 ) ;
10968: NOP4
10972: PPUSH
10973: LD_INT 20
10975: PPUSH
10976: LD_INT 16
10978: PPUSH
10979: NOP4
// AddComMoveXY ( Patrola , 4 , 3 ) ;
10983: NOP4
10987: PPUSH
10988: LD_INT 4
10990: PPUSH
10991: LD_INT 3
10993: PPUSH
10994: NOP4
// AddComWait ( Patrola , 0 0$4 ) ;
10998: NOP4
11002: PPUSH
11003: LD_INT 140
11005: PPUSH
11006: NOP4
// AddComMoveXY ( Patrola , 6 , 7 ) ;
11010: NOP4
11014: PPUSH
11015: LD_INT 6
11017: PPUSH
11018: LD_INT 7
11020: PPUSH
11021: NOP4
// AddComMoveXY ( Patrola , 20 , 17 ) ;
11025: NOP4
11029: PPUSH
11030: LD_INT 20
11032: PPUSH
11033: LD_INT 17
11035: PPUSH
11036: NOP4
// AddComMoveXY ( Patrola , 28 , 18 ) ;
11040: NOP4
11044: PPUSH
11045: LD_INT 28
11047: PPUSH
11048: LD_INT 18
11050: PPUSH
11051: NOP4
// AddComWait ( Patrola , 0 0$5.2 ) ;
11055: NOP4
11059: PPUSH
11060: LD_INT 182
11062: PPUSH
11063: NOP4
// if not VsevSaved then
11067: NOP4
11071: NOT
11072: IFFALSE 11392
// begin AddComMoveXY ( Patrola , 33 , 21 ) ;
11074: NOP4
11078: PPUSH
11079: LD_INT 33
11081: PPUSH
11082: LD_INT 21
11084: PPUSH
11085: NOP4
// AddComMoveXY ( Patrola , 37 , 34 ) ;
11089: NOP4
11093: PPUSH
11094: LD_INT 37
11096: PPUSH
11097: LD_INT 34
11099: PPUSH
11100: NOP4
// AddComMoveXY ( Patrola , 43 , 45 ) ;
11104: NOP4
11108: PPUSH
11109: LD_INT 43
11111: PPUSH
11112: LD_INT 45
11114: PPUSH
11115: NOP4
// AddComMoveXY ( Patrola , 55 , 59 ) ;
11119: NOP4
11123: PPUSH
11124: LD_INT 55
11126: PPUSH
11127: LD_INT 59
11129: PPUSH
11130: NOP4
// AddComMoveXY ( Patrola , 66 , 80 ) ;
11134: NOP4
11138: PPUSH
11139: LD_INT 66
11141: PPUSH
11142: LD_INT 80
11144: PPUSH
11145: NOP4
// AddComWait ( Patrola , 0 0$1.2 ) ;
11149: NOP4
11153: PPUSH
11154: LD_INT 42
11156: PPUSH
11157: NOP4
// AddComMoveXY ( Patrola , 73 , 95 ) ;
11161: NOP4
11165: PPUSH
11166: LD_INT 73
11168: PPUSH
11169: LD_INT 95
11171: PPUSH
11172: NOP4
// AddComMoveXY ( Patrola , 74 , 100 ) ;
11176: NOP4
11180: PPUSH
11181: LD_INT 74
11183: PPUSH
11184: LD_INT 100
11186: PPUSH
11187: NOP4
// AddComMoveXY ( Patrola , 82 , 116 ) ;
11191: NOP4
11195: PPUSH
11196: LD_INT 82
11198: PPUSH
11199: LD_INT 116
11201: PPUSH
11202: NOP4
// AddComMoveXY ( Patrola , 92 , 131 ) ;
11206: NOP4
11210: PPUSH
11211: LD_INT 92
11213: PPUSH
11214: LD_INT 131
11216: PPUSH
11217: NOP4
// AddComWait ( Patrola , 0 0$3.4 ) ;
11221: NOP4
11225: PPUSH
11226: LD_INT 119
11228: PPUSH
11229: NOP4
// AddComMoveXY ( Patrola , 93 , 129 ) ;
11233: NOP4
11237: PPUSH
11238: LD_INT 93
11240: PPUSH
11241: LD_INT 129
11243: PPUSH
11244: NOP4
// AddComWait ( Patrola , 0 0$4.1 ) ;
11248: NOP4
11252: PPUSH
11253: LD_INT 143
11255: PPUSH
11256: NOP4
// AddComMoveXY ( Patrola , 87 , 119 ) ;
11260: NOP4
11264: PPUSH
11265: LD_INT 87
11267: PPUSH
11268: LD_INT 119
11270: PPUSH
11271: NOP4
// AddComMoveXY ( Patrola , 77 , 100 ) ;
11275: NOP4
11279: PPUSH
11280: LD_INT 77
11282: PPUSH
11283: LD_INT 100
11285: PPUSH
11286: NOP4
// AddComMoveXY ( Patrola , 73 , 91 ) ;
11290: NOP4
11294: PPUSH
11295: LD_INT 73
11297: PPUSH
11298: LD_INT 91
11300: PPUSH
11301: NOP4
// AddComMoveXY ( Patrola , 65 , 73 ) ;
11305: NOP4
11309: PPUSH
11310: LD_INT 65
11312: PPUSH
11313: LD_INT 73
11315: PPUSH
11316: NOP4
// AddComMoveXY ( Patrola , 56 , 58 ) ;
11320: NOP4
11324: PPUSH
11325: LD_INT 56
11327: PPUSH
11328: LD_INT 58
11330: PPUSH
11331: NOP4
// AddComMoveXY ( Patrola , 47 , 47 ) ;
11335: NOP4
11339: PPUSH
11340: LD_INT 47
11342: PPUSH
11343: LD_INT 47
11345: PPUSH
11346: NOP4
// AddComMoveXY ( Patrola , 40 , 36 ) ;
11350: NOP4
11354: PPUSH
11355: LD_INT 40
11357: PPUSH
11358: LD_INT 36
11360: PPUSH
11361: NOP4
// AddComMoveXY ( Patrola , 35 , 25 ) ;
11365: NOP4
11369: PPUSH
11370: LD_INT 35
11372: PPUSH
11373: LD_INT 25
11375: PPUSH
11376: NOP4
// AddComWait ( Patrola , 0 0$3.3 ) ;
11380: NOP4
11384: PPUSH
11385: LD_INT 115
11387: PPUSH
11388: NOP4
// end ; AddComMoveXY ( Patrola , 34 , 18 ) ;
11392: NOP4
11396: PPUSH
11397: LD_INT 34
11399: PPUSH
11400: LD_INT 18
11402: PPUSH
11403: NOP4
// AddComMoveXY ( Patrola , 38 , 14 ) ;
11407: NOP4
11411: PPUSH
11412: LD_INT 38
11414: PPUSH
11415: LD_INT 14
11417: PPUSH
11418: NOP4
// AddComMoveXY ( Patrola , 46 , 14 ) ;
11422: NOP4
11426: PPUSH
11427: LD_INT 46
11429: PPUSH
11430: LD_INT 14
11432: PPUSH
11433: NOP4
// AddComMoveXY ( Patrola , 51 , 16 ) ;
11437: NOP4
11441: PPUSH
11442: LD_INT 51
11444: PPUSH
11445: LD_INT 16
11447: PPUSH
11448: NOP4
// AddComMoveXY ( Patrola , 61 , 16 ) ;
11452: NOP4
11456: PPUSH
11457: LD_INT 61
11459: PPUSH
11460: LD_INT 16
11462: PPUSH
11463: NOP4
// AddComMoveXY ( Patrola , 75 , 14 ) ;
11467: NOP4
11471: PPUSH
11472: LD_INT 75
11474: PPUSH
11475: LD_INT 14
11477: PPUSH
11478: NOP4
// AddComMoveXY ( Patrola , 86 , 18 ) ;
11482: NOP4
11486: PPUSH
11487: LD_INT 86
11489: PPUSH
11490: LD_INT 18
11492: PPUSH
11493: NOP4
// AddComWait ( Patrola , 0 0$2.9 ) ;
11497: NOP4
11501: PPUSH
11502: LD_INT 101
11504: PPUSH
11505: NOP4
// AddComSailEvent ( Patrola , 101 ) ;
11509: NOP4
11513: PPUSH
11514: LD_INT 101
11516: PPUSH
11517: NOP4
// end ;
11521: LD_VAR 0 1
11525: RET
// export function event_Patrola ; begin
11526: LD_INT 0
11528: PPUSH
// if Patrola and not PatrolaZrusena then
11529: NOP4
11533: PUSH
11534: NOP4
11538: NOT
11539: AND
11540: IFFALSE 11546
// patrola_kolecko ;
11542: NOP4
// end ;
11546: LD_VAR 0 1
11550: RET
// every 0 0$27.1 marked 45 do var Kdo ;
11551: GO 11553
11553: DISABLE
11554: LD_INT 0
11556: PPUSH
// begin if not Patrola then
11557: NOP4
11561: NOT
11562: IFFALSE 11566
// exit ;
11564: GO 11607
// for Kdo in Patrola do
11566: NOP4
11570: PUSH
11571: NOP4
11575: PUSH
11576: FOR_IN
11577: IFFALSE 11604
// if GetFuel ( Kdo ) < 25 then
11579: NOP4
11583: PPUSH
11584: NOP4
11588: PUSH
11589: LD_INT 25
11591: LESS
11592: IFFALSE 11602
// begin zrus_patrolu ;
11594: NOP4
// exit ;
11598: POP
11599: POP
11600: GO 11607
// end ;
11602: GO 11576
11604: POP
11605: POP
// enable ;
11606: ENABLE
// end ;
11607: PPOPN 1
11609: END
// every 0 0$5.1 do var I , Stahnout ;
11610: GO 11612
11612: DISABLE
11613: LD_INT 0
11615: PPUSH
11616: PPUSH
// begin Stahnout = true ;
11617: NOP4
11621: PUSH
11622: LD_INT 1
11624: ST_TO_ADDR
// for I in GetMcUnits ( MakroObrana ) do
11625: NOP4
11629: PUSH
11630: NOP4
11634: PPUSH
11635: NOP4
11639: PUSH
11640: FOR_IN
11641: IFFALSE 11672
// if ( GetUnitMc ( I ) = MakroObrana ) then
11643: NOP4
11647: PPUSH
11648: NOP4
11652: PUSH
11653: NOP4
11657: EQUAL
11658: IFFALSE 11670
// begin Stahnout = false ;
11660: NOP4
11664: PUSH
11665: LD_INT 0
11667: ST_TO_ADDR
// break ;
11668: GO 11672
// end ;
11670: GO 11640
11672: POP
11673: POP
// enable ;
11674: ENABLE
// if Stahnout <> BeziStahovani then
11675: NOP4
11679: PUSH
11680: NOP4
11684: NONEQUAL
11685: IFFALSE 11711
// begin if Stahnout then
11687: NOP4
11691: IFFALSE 11698
// enable ( 46 ) else
11693: LD_INT 46
11695: ENABLE_MARKED
11696: GO 11701
// disable ( 46 ) ;
11698: LD_INT 46
11700: DISABLE_MARKED
// BeziStahovani = Stahnout ;
11701: NOP4
11705: PUSH
11706: NOP4
11710: ST_TO_ADDR
// end ; end ;
11711: PPOPN 2
11713: END
// every 0 0$30 marked 46 do var I ;
11714: GO 11716
11716: DISABLE
11717: LD_INT 0
11719: PPUSH
// begin for I in GetMcUnits ( MakroPresunZakladna ) do
11720: NOP4
11724: PUSH
11725: NOP4
11729: PPUSH
11730: NOP4
11734: PUSH
11735: FOR_IN
11736: IFFALSE 11815
// if ( GetUnitMc ( I ) = MakroPresunZakladna ) and ( GetDistUnitArea ( I , ArabskaBaze ) > 0 ) and not IsInUnit ( I ) and not HasTask ( I ) then
11738: NOP4
11742: PPUSH
11743: NOP4
11747: PUSH
11748: NOP4
11752: EQUAL
11753: PUSH
11754: NOP4
11758: PPUSH
11759: NOP4
11763: PPUSH
11764: NOP4
11768: PUSH
11769: LD_INT 0
11771: GREATER
11772: AND
11773: PUSH
11774: NOP4
11778: PPUSH
11779: NOP4
11783: NOT
11784: AND
11785: PUSH
11786: NOP4
11790: PPUSH
11791: NOP4
11795: NOT
11796: AND
11797: IFFALSE 11813
// ComMoveToArea ( I , ArabskaBaze ) ;
11799: NOP4
11803: PPUSH
11804: NOP4
11808: PPUSH
11809: NOP4
11813: GO 11735
11815: POP
11816: POP
// BeziStahovani = false ;
11817: NOP4
11821: PUSH
11822: LD_INT 0
11824: ST_TO_ADDR
// end ;
11825: PPOPN 1
11827: END
// function posila_tank ; begin
11828: LD_INT 0
11830: PPUSH
// UC_Side = side_Ar ;
11831: LD_ADDR_OWVAR 20
11835: PUSH
11836: NOP4
11840: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
11841: LD_ADDR_OWVAR 21
11845: PUSH
11846: LD_INT 2
11848: ST_TO_ADDR
// VC_Chassis = AR_MEDIUM_TRIKE ;
11849: LD_ADDR_OWVAR 37
11853: PUSH
11854: LD_INT 13
11856: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
11857: LD_ADDR_OWVAR 38
11861: PUSH
11862: LD_INT 1
11864: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
11865: LD_ADDR_OWVAR 39
11869: PUSH
11870: LD_INT 1
11872: ST_TO_ADDR
// VC_Weapon = nahoda_seznam ( [ AR_FLAME_THROWER , AR_ROCKET_LAUNCHER , AR_MULTIMISSILE_BALLISTA ] ) ;
11873: LD_ADDR_OWVAR 40
11877: PUSH
11878: LD_INT 26
11880: PUSH
11881: LD_INT 28
11883: PUSH
11884: LD_INT 22
11886: PUSH
11887: EMPTY
11888: LIST
11889: LIST
11890: LIST
11891: PPUSH
11892: NOP4
11896: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 85 , 100 ) ;
11897: LD_ADDR_OWVAR 41
11901: PUSH
11902: LD_INT 85
11904: PPUSH
11905: LD_INT 100
11907: PPUSH
11908: NOP4
11912: ST_TO_ADDR
// Result = CreateVehicle ;
11913: NOP4
11917: PUSH
11918: NOP4
11922: ST_TO_ADDR
// PlaceHumanInUnit ( vytvor_cloveka ( CLASS_MECHANIC ) , Result ) ;
11923: LD_INT 3
11925: PPUSH
11926: NOP4
11930: PPUSH
11931: NOP4
11935: PPUSH
11936: NOP4
// end ;
11940: LD_VAR 0 1
11944: RET
// function vytvor_posily ; begin
11945: LD_INT 0
11947: PPUSH
// Result = [ ] ;
11948: NOP4
11952: PUSH
11953: EMPTY
11954: ST_TO_ADDR
// if Difficulty = 1 then
11955: NOP4
11959: PUSH
11960: LD_INT 1
11962: EQUAL
11963: IFFALSE 11967
// exit ;
11965: GO 12055
// Result = Result union [ posila_tank ] ;
11967: NOP4
11971: PUSH
11972: NOP4
11976: PUSH
11977: NOP4
11981: PUSH
11982: EMPTY
11983: LIST
11984: UNION
11985: ST_TO_ADDR
// if Difficulty = 2 then
11986: NOP4
11990: PUSH
11991: LD_INT 2
11993: EQUAL
11994: IFFALSE 11998
// exit ;
11996: GO 12055
// Result = Result union [ posila_tank ] ;
11998: NOP4
12002: PUSH
12003: NOP4
12007: PUSH
12008: NOP4
12012: PUSH
12013: EMPTY
12014: LIST
12015: UNION
12016: ST_TO_ADDR
// Result = Result union [ posila_tank ] ;
12017: NOP4
12021: PUSH
12022: NOP4
12026: PUSH
12027: NOP4
12031: PUSH
12032: EMPTY
12033: LIST
12034: UNION
12035: ST_TO_ADDR
// Result = Result union [ posila_tank ] ;
12036: NOP4
12040: PUSH
12041: NOP4
12045: PUSH
12046: NOP4
12050: PUSH
12051: EMPTY
12052: LIST
12053: UNION
12054: ST_TO_ADDR
// end ;
12055: LD_VAR 0 1
12059: RET
// every 13 13$1 do var Posily , Lidi , I , J ;
12060: GO 12062
12062: DISABLE
12063: LD_INT 0
12065: PPUSH
12066: PPUSH
12067: PPUSH
12068: PPUSH
// begin Posily = vytvor_posily ;
12069: NOP4
12073: PUSH
12074: NOP4
12078: ST_TO_ADDR
// place_list ( Posily , ArabovePosily ) ;
12079: NOP4
12083: PPUSH
12084: NOP4
12088: PPUSH
12089: NOP4
// Lidi = [ ] ;
12093: NOP4
12097: PUSH
12098: EMPTY
12099: ST_TO_ADDR
// for I in Posily do
12100: NOP4
12104: PUSH
12105: NOP4
12109: PUSH
12110: FOR_IN
12111: IFFALSE 12155
// begin J = IsDrivenBy ( I ) ;
12113: NOP4
12117: PUSH
12118: NOP4
12122: PPUSH
12123: NOP4
12127: ST_TO_ADDR
// if J then
12128: NOP4
12132: IFFALSE 12153
// Lidi = Lidi union [ J ] ;
12134: NOP4
12138: PUSH
12139: NOP4
12143: PUSH
12144: NOP4
12148: PUSH
12149: EMPTY
12150: LIST
12151: UNION
12152: ST_TO_ADDR
// end ;
12153: GO 12110
12155: POP
12156: POP
// Autaky = Autaky union Posily ;
12157: NOP4
12161: PUSH
12162: NOP4
12166: PUSH
12167: NOP4
12171: UNION
12172: ST_TO_ADDR
// AddMcUnits ( MakroObrana , Lidi union Posily ) ;
12173: NOP4
12177: PPUSH
12178: NOP4
12182: PUSH
12183: NOP4
12187: UNION
12188: PPUSH
12189: NOP4
// AddMcUnits ( MakroPresunZakladna , Lidi union Posily ) ;
12193: NOP4
12197: PPUSH
12198: NOP4
12202: PUSH
12203: NOP4
12207: UNION
12208: PPUSH
12209: NOP4
// end ;
12213: PPOPN 4
12215: END
// every 2 2$7 do
12216: GO 12218
12218: DISABLE
// begin opravuj_budovy ;
12219: NOP4
// kuryruj_lidi ;
12223: NOP4
// opravuj_auta ;
12227: NOP4
// sbirej_bedny ;
12231: NOP4
// enable ;
12235: ENABLE
// end ;
12236: END
// function opravuj_budovy ; var Budovy , Opravit , I , Kde ; begin
12237: LD_INT 0
12239: PPUSH
12240: PPUSH
12241: PPUSH
12242: PPUSH
12243: PPUSH
// if not IsOk ( ArEng ) then
12244: NOP4
12248: PPUSH
12249: NOP4
12253: NOT
12254: IFFALSE 12258
// exit ;
12256: GO 12417
// Budovy = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , side_Ar ] ] ) ;
12258: NOP4
12262: PUSH
12263: NOP4
12267: PPUSH
12268: LD_INT 21
12270: PUSH
12271: LD_INT 3
12273: PUSH
12274: EMPTY
12275: LIST
12276: LIST
12277: PUSH
12278: LD_INT 22
12280: PUSH
12281: NOP4
12285: PUSH
12286: EMPTY
12287: LIST
12288: LIST
12289: PUSH
12290: EMPTY
12291: LIST
12292: LIST
12293: PPUSH
12294: NOP4
12298: ST_TO_ADDR
// Opravit = [ ] ;
12299: NOP4
12303: PUSH
12304: EMPTY
12305: ST_TO_ADDR
// for I in Budovy do
12306: NOP4
12310: PUSH
12311: NOP4
12315: PUSH
12316: FOR_IN
12317: IFFALSE 12355
// if GetLives ( I ) < HRANICE_ZDRAVI then
12319: NOP4
12323: PPUSH
12324: NOP4
12328: PUSH
12329: LD_INT 1000
12331: LESS
12332: IFFALSE 12353
// Opravit = Opravit union [ I ] ;
12334: NOP4
12338: PUSH
12339: NOP4
12343: PUSH
12344: NOP4
12348: PUSH
12349: EMPTY
12350: LIST
12351: UNION
12352: ST_TO_ADDR
12353: GO 12316
12355: POP
12356: POP
// ComCancel ( ArEng ) ;
12357: NOP4
12361: PPUSH
12362: NOP4
// if Opravit then
12366: NOP4
12370: IFFALSE 12417
// begin for I in Opravit do
12372: NOP4
12376: PUSH
12377: NOP4
12381: PUSH
12382: FOR_IN
12383: IFFALSE 12401
// AddComRepairBuilding ( ArEng , I ) ;
12385: NOP4
12389: PPUSH
12390: NOP4
12394: PPUSH
12395: NOP4
12399: GO 12382
12401: POP
12402: POP
// AddComMoveToArea ( ArEng , BednyArabi ) ;
12403: NOP4
12407: PPUSH
12408: NOP4
12412: PPUSH
12413: NOP4
// end ; end ;
12417: LD_VAR 0 1
12421: RET
// function sbirej_bedny ; begin
12422: LD_INT 0
12424: PPUSH
// if ArEng and IsOk ( ArEng ) then
12425: NOP4
12429: PUSH
12430: NOP4
12434: PPUSH
12435: NOP4
12439: AND
12440: IFFALSE 12457
// AddComCollect ( ArEng , 85 , 10 ) ;
12442: NOP4
12446: PPUSH
12447: LD_INT 85
12449: PPUSH
12450: LD_INT 10
12452: PPUSH
12453: NOP4
// end ;
12457: LD_VAR 0 1
12461: RET
// function opravuj_auta ; var Auta , Opravit , I , Kde ; begin
12462: LD_INT 0
12464: PPUSH
12465: PPUSH
12466: PPUSH
12467: PPUSH
12468: PPUSH
// if ProbihaOprava then
12469: NOP4
12473: IFFALSE 12477
// exit ;
12475: GO 12709
// if not IsOk ( ArMech ) then
12477: NOP4
12481: PPUSH
12482: NOP4
12486: NOT
12487: IFFALSE 12491
// exit ;
12489: GO 12709
// Auta = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , side_Ar ] ] ) diff Utok_Auta ;
12491: NOP4
12495: PUSH
12496: NOP4
12500: PPUSH
12501: LD_INT 21
12503: PUSH
12504: LD_INT 2
12506: PUSH
12507: EMPTY
12508: LIST
12509: LIST
12510: PUSH
12511: LD_INT 22
12513: PUSH
12514: NOP4
12518: PUSH
12519: EMPTY
12520: LIST
12521: LIST
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: NOP4
12531: PUSH
12532: NOP4
12536: DIFF
12537: ST_TO_ADDR
// Opravit = [ ] ;
12538: NOP4
12542: PUSH
12543: EMPTY
12544: ST_TO_ADDR
// for I in Auta do
12545: NOP4
12549: PUSH
12550: NOP4
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12594
// if GetLives ( I ) < HRANICE_ZDRAVI then
12558: NOP4
12562: PPUSH
12563: NOP4
12567: PUSH
12568: LD_INT 1000
12570: LESS
12571: IFFALSE 12592
// Opravit = Opravit union [ I ] ;
12573: NOP4
12577: PUSH
12578: NOP4
12582: PUSH
12583: NOP4
12587: PUSH
12588: EMPTY
12589: LIST
12590: UNION
12591: ST_TO_ADDR
12592: GO 12555
12594: POP
12595: POP
// if Opravit then
12596: NOP4
12600: IFFALSE 12709
// begin Kde = IsInUnit ( ArMech ) ;
12602: NOP4
12606: PUSH
12607: NOP4
12611: PPUSH
12612: NOP4
12616: ST_TO_ADDR
// if Kde then
12617: NOP4
12621: IFFALSE 12658
// if GetType ( Kde ) = UNIT_BUILDING then
12623: NOP4
12627: PPUSH
12628: NOP4
12632: PUSH
12633: LD_INT 3
12635: EQUAL
12636: IFFALSE 12649
// ComExitBuilding ( ArMech ) else
12638: NOP4
12642: PPUSH
12643: NOP4
12647: GO 12658
// ComExitVehicle ( ArMech ) ;
12649: NOP4
12653: PPUSH
12654: NOP4
// for I in Opravit do
12658: NOP4
12662: PUSH
12663: NOP4
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12687
// AddComRepairVehicle ( ArMech , I ) ;
12671: NOP4
12675: PPUSH
12676: NOP4
12680: PPUSH
12681: NOP4
12685: GO 12668
12687: POP
12688: POP
// AddComSailEvent ( ArMech , 102 ) ;
12689: NOP4
12693: PPUSH
12694: LD_INT 102
12696: PPUSH
12697: NOP4
// ProbihaOprava = true ;
12701: NOP4
12705: PUSH
12706: LD_INT 1
12708: ST_TO_ADDR
// end ; end ;
12709: LD_VAR 0 1
12713: RET
// function kuryruj_lidi ; var Lidi , Opravit , I , Kde , Felcar , Budova , Event ; begin
12714: LD_INT 0
12716: PPUSH
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
// if ProbihaLeceni then
12724: NOP4
12728: IFFALSE 12732
// exit ;
12730: GO 13030
// if IsOk ( ArSci1 ) then
12732: NOP4
12736: PPUSH
12737: NOP4
12741: IFFALSE 12773
// begin Felcar = ArSci1 ;
12743: NOP4
12747: PUSH
12748: NOP4
12752: ST_TO_ADDR
// Budova = ArLab1 ;
12753: NOP4
12757: PUSH
12758: NOP4
12762: ST_TO_ADDR
// Event = 103 ;
12763: NOP4
12767: PUSH
12768: LD_INT 103
12770: ST_TO_ADDR
// end else
12771: GO 12816
// if IsOk ( ArSci2 ) then
12773: NOP4
12777: PPUSH
12778: NOP4
12782: IFFALSE 12814
// begin Felcar = ArSci2 ;
12784: NOP4
12788: PUSH
12789: NOP4
12793: ST_TO_ADDR
// Budova = ArLab2 ;
12794: NOP4
12798: PUSH
12799: NOP4
12803: ST_TO_ADDR
// Event = 104 ;
12804: NOP4
12808: PUSH
12809: LD_INT 104
12811: ST_TO_ADDR
// end else
12812: GO 12816
// exit ;
12814: GO 13030
// Lidi = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , side_Ar ] ] ) ;
12816: NOP4
12820: PUSH
12821: NOP4
12825: PPUSH
12826: LD_INT 21
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 22
12838: PUSH
12839: NOP4
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PPUSH
12852: NOP4
12856: ST_TO_ADDR
// Opravit = [ ] ;
12857: NOP4
12861: PUSH
12862: EMPTY
12863: ST_TO_ADDR
// for I in Lidi do
12864: NOP4
12868: PUSH
12869: NOP4
12873: PUSH
12874: FOR_IN
12875: IFFALSE 12913
// if GetLives ( I ) < HRANICE_ZDRAVI then
12877: NOP4
12881: PPUSH
12882: NOP4
12886: PUSH
12887: LD_INT 1000
12889: LESS
12890: IFFALSE 12911
// Opravit = Opravit union [ I ] ;
12892: NOP4
12896: PUSH
12897: NOP4
12901: PUSH
12902: NOP4
12906: PUSH
12907: EMPTY
12908: LIST
12909: UNION
12910: ST_TO_ADDR
12911: GO 12874
12913: POP
12914: POP
// if Opravit then
12915: NOP4
12919: IFFALSE 13030
// begin Kde = IsInUnit ( Felcar ) ;
12921: NOP4
12925: PUSH
12926: NOP4
12930: PPUSH
12931: NOP4
12935: ST_TO_ADDR
// if Kde then
12936: NOP4
12940: IFFALSE 12977
// if GetType ( Kde ) = UNIT_BUILDING then
12942: NOP4
12946: PPUSH
12947: NOP4
12951: PUSH
12952: LD_INT 3
12954: EQUAL
12955: IFFALSE 12968
// ComExitBuilding ( Felcar ) else
12957: NOP4
12961: PPUSH
12962: NOP4
12966: GO 12977
// ComExitVehicle ( Felcar ) ;
12968: NOP4
12972: PPUSH
12973: NOP4
// for I in Opravit do
12977: NOP4
12981: PUSH
12982: NOP4
12986: PUSH
12987: FOR_IN
12988: IFFALSE 13006
// AddComHeal ( Felcar , I ) ;
12990: NOP4
12994: PPUSH
12995: NOP4
12999: PPUSH
13000: NOP4
13004: GO 12987
13006: POP
13007: POP
// AddComSailEvent ( Felcar , Event ) ;
13008: NOP4
13012: PPUSH
13013: NOP4
13017: PPUSH
13018: NOP4
// ProbihaLeceni = true ;
13022: NOP4
13026: PUSH
13027: LD_INT 1
13029: ST_TO_ADDR
// end ; end ;
13030: LD_VAR 0 1
13034: RET
// export function event_OpravaHotova ( Num ) ; begin
13035: LD_INT 0
13037: PPUSH
// case Num of 102 :
13038: NOP4
13042: PUSH
13043: LD_INT 102
13045: DOUBLE
13046: EQUAL
13047: IFTRUE 13051
13049: GO 13076
13051: POP
// begin ComEnterUnit ( ArMech , ArFact ) ;
13052: NOP4
13056: PPUSH
13057: NOP4
13061: PPUSH
13062: NOP4
// ProbihaOprava = false ;
13066: NOP4
13070: PUSH
13071: LD_INT 0
13073: ST_TO_ADDR
// end ; 103 :
13074: GO 13143
13076: LD_INT 103
13078: DOUBLE
13079: EQUAL
13080: IFTRUE 13084
13082: GO 13109
13084: POP
// begin ComEnterUnit ( ArSci1 , ArLab1 ) ;
13085: NOP4
13089: PPUSH
13090: NOP4
13094: PPUSH
13095: NOP4
// ProbihaLeceni = false ;
13099: NOP4
13103: PUSH
13104: LD_INT 0
13106: ST_TO_ADDR
// end ; 104 :
13107: GO 13143
13109: LD_INT 104
13111: DOUBLE
13112: EQUAL
13113: IFTRUE 13117
13115: GO 13142
13117: POP
// begin ComEnterUnit ( ArSci2 , ArLab2 ) ;
13118: NOP4
13122: PPUSH
13123: NOP4
13127: PPUSH
13128: NOP4
// ProbihaLeceni = false ;
13132: NOP4
13136: PUSH
13137: LD_INT 0
13139: ST_TO_ADDR
// end ; end ;
13140: GO 13143
13142: POP
// end ;
13143: LD_VAR 0 2
13147: RET
// function testuj_minu ( X , Y ) ; var Jednotky ; begin
13148: LD_INT 0
13150: PPUSH
13151: PPUSH
// Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_DISTXY , X , Y , 2 ] ] ) ;
13152: NOP4
13156: PUSH
13157: LD_INT 22
13159: PUSH
13160: NOP4
13164: PUSH
13165: EMPTY
13166: LIST
13167: LIST
13168: PUSH
13169: LD_INT 92
13171: PUSH
13172: NOP4
13176: PUSH
13177: NOP4
13181: PUSH
13182: LD_INT 2
13184: PUSH
13185: EMPTY
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: PUSH
13191: EMPTY
13192: LIST
13193: LIST
13194: PPUSH
13195: NOP4
13199: ST_TO_ADDR
// if Jednotky then
13200: NOP4
13204: IFFALSE 13235
// begin LaunchMineAtPos ( X , Y , side_Ar ) ;
13206: NOP4
13210: PPUSH
13211: NOP4
13215: PPUSH
13216: NOP4
13220: PPUSH
13221: NOP4
// Result = true ;
13225: NOP4
13229: PUSH
13230: LD_INT 1
13232: ST_TO_ADDR
// end else
13233: GO 13243
// Result = false ;
13235: NOP4
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// end ;
13243: LD_VAR 0 3
13247: RET
// every 0 0$1.1 + 0 0$0.7 do var M , Bouchlo ;
13248: GO 13250
13250: DISABLE
13251: LD_INT 0
13253: PPUSH
13254: PPUSH
// begin if not Miny then
13255: NOP4
13259: NOT
13260: IFFALSE 13264
// exit ;
13262: GO 13360
// Bouchlo = [ ] ;
13264: NOP4
13268: PUSH
13269: EMPTY
13270: ST_TO_ADDR
// for M in Miny do
13271: NOP4
13275: PUSH
13276: NOP4
13280: PUSH
13281: FOR_IN
13282: IFFALSE 13329
// if testuj_minu ( M [ 1 ] , M [ 2 ] ) then
13284: NOP4
13288: PUSH
13289: LD_INT 1
13291: ARRAY
13292: PPUSH
13293: NOP4
13297: PUSH
13298: LD_INT 2
13300: ARRAY
13301: PPUSH
13302: NOP4
13306: IFFALSE 13327
// Bouchlo = Bouchlo ^ [ M ] ;
13308: NOP4
13312: PUSH
13313: NOP4
13317: PUSH
13318: NOP4
13322: PUSH
13323: EMPTY
13324: LIST
13325: ADD
13326: ST_TO_ADDR
13327: GO 13281
13329: POP
13330: POP
// if Bouchlo then
13331: NOP4
13335: IFFALSE 13353
// Miny = Miny diff Bouchlo ;
13337: NOP4
13341: PUSH
13342: NOP4
13346: PUSH
13347: NOP4
13351: DIFF
13352: ST_TO_ADDR
// if Miny then
13353: NOP4
13357: IFFALSE 13360
// enable ;
13359: ENABLE
// end ; end_of_file
13360: PPOPN 2
13362: END
// export Yashin , YashinAutak ; var Zacal , Nastupuje , Nastoupil , Odjizdi ; var Bunkr ; var YashinPovoleneZbrane ; export function init_yashin ; begin
13363: LD_INT 0
13365: PPUSH
// disable ( 51 ) ;
13366: LD_INT 51
13368: DISABLE_MARKED
// disable ( 52 ) ;
13369: LD_INT 52
13371: DISABLE_MARKED
// disable ( 53 ) ;
13372: LD_INT 53
13374: DISABLE_MARKED
// disable ( 54 ) ;
13375: LD_INT 54
13377: DISABLE_MARKED
// disable ( 55 ) ;
13378: LD_INT 55
13380: DISABLE_MARKED
// disable ( 56 ) ;
13381: LD_INT 56
13383: DISABLE_MARKED
// disable ( 57 ) ;
13384: LD_INT 57
13386: DISABLE_MARKED
// Yashin = 0 ;
13387: NOP4
13391: PUSH
13392: LD_INT 0
13394: ST_TO_ADDR
// YashinAutak = 0 ;
13395: NOP4
13399: PUSH
13400: LD_INT 0
13402: ST_TO_ADDR
// Zacal = false ;
13403: NOP4
13407: PUSH
13408: LD_INT 0
13410: ST_TO_ADDR
// Nastupuje = false ;
13411: NOP4
13415: PUSH
13416: LD_INT 0
13418: ST_TO_ADDR
// Nastoupil = false ;
13419: NOP4
13423: PUSH
13424: LD_INT 0
13426: ST_TO_ADDR
// Odjizdi = false ;
13427: NOP4
13431: PUSH
13432: LD_INT 0
13434: ST_TO_ADDR
// Bunkr = 0 ;
13435: NOP4
13439: PUSH
13440: LD_INT 0
13442: ST_TO_ADDR
// YashinPovoleneZbrane = [ RU_HEAVY_MACHINE_GUN , RU_GATLING_GUN , RU_GUN , RU_ROCKET_LAUNCHER , RU_HEAVY_GUN , RU_ROCKET ] ;
13443: NOP4
13447: PUSH
13448: LD_INT 42
13450: PUSH
13451: LD_INT 43
13453: PUSH
13454: LD_INT 44
13456: PUSH
13457: LD_INT 45
13459: PUSH
13460: LD_INT 46
13462: PUSH
13463: LD_INT 47
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: LIST
13470: LIST
13471: LIST
13472: LIST
13473: ST_TO_ADDR
// end ;
13474: LD_VAR 0 1
13478: RET
// export function yashin_start_timer ; begin
13479: LD_INT 0
13481: PPUSH
// if not Zacal then
13482: NOP4
13486: NOT
13487: IFFALSE 13500
// begin enable ( 51 ) ;
13489: LD_INT 51
13491: ENABLE_MARKED
// Zacal = true ;
13492: NOP4
13496: PUSH
13497: LD_INT 1
13499: ST_TO_ADDR
// end ; end ;
13500: LD_VAR 0 1
13504: RET
// function vytvor_yashina ; begin
13505: LD_INT 0
13507: PPUSH
// Yashin = NewCharacter ( Yashin ) ;
13508: NOP4
13512: PUSH
13513: LD_STRING Yashin
13515: PPUSH
13516: NOP4
13520: ST_TO_ADDR
// SetClass ( Yashin , CLASS_BAZOOKER ) ;
13521: NOP4
13525: PPUSH
13526: LD_INT 9
13528: PPUSH
13529: NOP4
// SetSide ( Yashin , side_Ru2 ) ;
13533: NOP4
13537: PPUSH
13538: NOP4
13542: PPUSH
13543: NOP4
// DoNotAttack ( side_Ar , Yashin ) ;
13547: NOP4
13551: PPUSH
13552: NOP4
13556: PPUSH
13557: NOP4
// end ;
13561: LD_VAR 0 1
13565: RET
// function yashin_start ; var Vysledek , Area , Bunkry ; begin
13566: LD_INT 0
13568: PPUSH
13569: PPUSH
13570: PPUSH
13571: PPUSH
// vytvor_yashina ;
13572: NOP4
// if VsevSaved then
13576: NOP4
13580: IFFALSE 13611
// begin PlaceUnitArea ( Yashin , YashinStart , false ) ;
13582: NOP4
13586: PPUSH
13587: NOP4
13591: PPUSH
13592: LD_INT 0
13594: PPUSH
13595: NOP4
// Area = YashinCil1 ;
13599: NOP4
13603: PUSH
13604: NOP4
13608: ST_TO_ADDR
// end else
13609: GO 13638
// begin PlaceUnitArea ( Yashin , YashinStart , false ) ;
13611: NOP4
13615: PPUSH
13616: NOP4
13620: PPUSH
13621: LD_INT 0
13623: PPUSH
13624: NOP4
// Area = YashinCil1a ;
13628: NOP4
13632: PUSH
13633: NOP4
13637: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Area ) then
13638: NOP4
13642: PPUSH
13643: NOP4
13647: PPUSH
13648: NOP4
13652: IFFALSE 13685
// ComMoveXY ( Yashin , GetX ( Burlak ) , GetY ( Burlak ) ) else
13654: NOP4
13658: PPUSH
13659: NOP4
13663: PPUSH
13664: NOP4
13668: PPUSH
13669: NOP4
13673: PPUSH
13674: NOP4
13678: PPUSH
13679: NOP4
13683: GO 13699
// ComMoveToArea ( Yashin , Area ) ;
13685: NOP4
13689: PPUSH
13690: NOP4
13694: PPUSH
13695: NOP4
// CenterOnUnits ( Yashin ) ;
13699: NOP4
13703: PPUSH
13704: NOP4
// Wait ( 0 0$4 ) ;
13708: LD_INT 140
13710: PPUSH
13711: NOP4
// DialogueOn ;
13715: NOP4
// dialog_YashinArrives ;
13719: NOP4
// Bunkry = yashin_zjisti_bunkry ;
13723: NOP4
13727: PUSH
13728: NOP4
13732: ST_TO_ADDR
// if Bunkry then
13733: NOP4
13737: IFFALSE 13751
// Vysledek = query_YashinHelp else
13739: NOP4
13743: PUSH
13744: NOP4
13748: ST_TO_ADDR
13749: GO 13761
// Vysledek = query_YashinHelpNB ;
13751: NOP4
13755: PUSH
13756: NOP4
13760: ST_TO_ADDR
// if Vysledek = 1 then
13761: NOP4
13765: PUSH
13766: LD_INT 1
13768: EQUAL
13769: IFFALSE 13814
// begin dialog_QrYashinHelp1 ;
13771: NOP4
// DialogueOff ;
13775: NOP4
// Bunkr = Bunkry [ Rand ( 1 , Bunkry ) ] ;
13779: NOP4
13783: PUSH
13784: NOP4
13788: PUSH
13789: LD_INT 1
13791: PPUSH
13792: NOP4
13796: PPUSH
13797: NOP4
13801: ARRAY
13802: ST_TO_ADDR
// yashin_znic_bunkr ( Area ) ;
13803: NOP4
13807: PPUSH
13808: NOP4
// end else
13812: GO 13846
// begin if Vysledek = 2 then
13814: NOP4
13818: PUSH
13819: LD_INT 2
13821: EQUAL
13822: IFFALSE 13830
// dialog_QrYashinHelp2 else
13824: NOP4
13828: GO 13834
// dialog_QrYashinHelp3 ;
13830: NOP4
// dialog_YashinLeave ;
13834: NOP4
// DialogueOff ;
13838: NOP4
// yashin_vyzadej_autak ;
13842: NOP4
// end ; enable ( 53 ) ;
13846: LD_INT 53
13848: ENABLE_MARKED
// enable ( 57 ) ;
13849: LD_INT 57
13851: ENABLE_MARKED
// end ;
13852: LD_VAR 0 1
13856: RET
// function yashin_chci_autak ; var I , Temp , Kde , Volne , Dalka , Ridic ; begin
13857: LD_INT 0
13859: PPUSH
13860: PPUSH
13861: PPUSH
13862: PPUSH
13863: PPUSH
13864: PPUSH
13865: PPUSH
// if YashinAutak then
13866: NOP4
13870: IFFALSE 14022
// begin if not IsOK ( YashinAutak ) or ( GetSide ( YashinAutak ) <> side_Ru2 ) then
13872: NOP4
13876: PPUSH
13877: NOP4
13881: NOT
13882: PUSH
13883: NOP4
13887: PPUSH
13888: NOP4
13892: PUSH
13893: NOP4
13897: NONEQUAL
13898: OR
13899: IFFALSE 13911
// begin YashinAutak = 0 ;
13901: NOP4
13905: PUSH
13906: LD_INT 0
13908: ST_TO_ADDR
// end else
13909: GO 14022
// begin Ridic = IsDrivenBy ( YashinAutak ) ;
13911: NOP4
13915: PUSH
13916: NOP4
13920: PPUSH
13921: NOP4
13925: ST_TO_ADDR
// if Ridic = Yashin then
13926: NOP4
13930: PUSH
13931: NOP4
13935: EQUAL
13936: IFFALSE 13971
// begin Nastupuje = false ;
13938: NOP4
13942: PUSH
13943: LD_INT 0
13945: ST_TO_ADDR
// Nastoupil = true ;
13946: NOP4
13950: PUSH
13951: LD_INT 1
13953: ST_TO_ADDR
// disable ( 55 ) ;
13954: LD_INT 55
13956: DISABLE_MARKED
// yashin_zacni_odjizdet ;
13957: NOP4
// Result = true ;
13961: NOP4
13965: PUSH
13966: LD_INT 1
13968: ST_TO_ADDR
// exit ;
13969: GO 14473
// end ; if Ridic then
13971: NOP4
13975: IFFALSE 13996
// begin ComCancel ( Yashin ) ;
13977: NOP4
13981: PPUSH
13982: NOP4
// YashinAutak = 0 ;
13986: NOP4
13990: PUSH
13991: LD_INT 0
13993: ST_TO_ADDR
// end else
13994: GO 14022
// begin if not HasTask ( Yashin ) then
13996: NOP4
14000: PPUSH
14001: NOP4
14005: NOT
14006: IFFALSE 14022
// ComEnterUnit ( Yashin , YashinAutak ) ;
14008: NOP4
14012: PPUSH
14013: NOP4
14017: PPUSH
14018: NOP4
// end ; end ; end ; Kde = IsInUnit ( Yashin ) ;
14022: NOP4
14026: PUSH
14027: NOP4
14031: PPUSH
14032: NOP4
14036: ST_TO_ADDR
// if ( Kde <> 0 ) then
14037: NOP4
14041: PUSH
14042: LD_INT 0
14044: NONEQUAL
14045: IFFALSE 14136
// begin if GetType ( Kde ) = UNIT_VEHICLE then
14047: NOP4
14051: PPUSH
14052: NOP4
14056: PUSH
14057: LD_INT 2
14059: EQUAL
14060: IFFALSE 14105
// begin Nastupuje = false ;
14062: NOP4
14066: PUSH
14067: LD_INT 0
14069: ST_TO_ADDR
// Nastoupil = true ;
14070: NOP4
14074: PUSH
14075: LD_INT 1
14077: ST_TO_ADDR
// disable ( 55 ) ;
14078: LD_INT 55
14080: DISABLE_MARKED
// YashinAutak = Kde ;
14081: NOP4
14085: PUSH
14086: NOP4
14090: ST_TO_ADDR
// yashin_zacni_odjizdet ;
14091: NOP4
// Result = true ;
14095: NOP4
14099: PUSH
14100: LD_INT 1
14102: ST_TO_ADDR
// exit ;
14103: GO 14473
// end ; if GetType ( Kde ) = UNIT_BUILDING then
14105: NOP4
14109: PPUSH
14110: NOP4
14114: PUSH
14115: LD_INT 3
14117: EQUAL
14118: IFFALSE 14136
// begin ComExitBuilding ( Yashin ) ;
14120: NOP4
14124: PPUSH
14125: NOP4
// Wait ( 0 0$0.25 ) ;
14129: LD_INT 9
14131: PPUSH
14132: NOP4
// end ; end ; Result = false ;
14136: NOP4
14140: PUSH
14141: LD_INT 0
14143: ST_TO_ADDR
// if HasTask ( Yashin ) then
14144: NOP4
14148: PPUSH
14149: NOP4
14153: IFFALSE 14157
// exit ;
14155: GO 14473
// Volne = [ ] ;
14157: NOP4
14161: PUSH
14162: EMPTY
14163: ST_TO_ADDR
// Temp = FilterUnitsExceptArea ( Nebezpeci , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_OK ] , [ F_CONTROL , CONTROL_MANUAL ] ] ) ;
14164: NOP4
14168: PUSH
14169: NOP4
14173: PPUSH
14174: LD_INT 22
14176: PUSH
14177: NOP4
14181: PUSH
14182: EMPTY
14183: LIST
14184: LIST
14185: PUSH
14186: LD_INT 21
14188: PUSH
14189: LD_INT 2
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PUSH
14196: LD_INT 50
14198: PUSH
14199: EMPTY
14200: LIST
14201: PUSH
14202: LD_INT 33
14204: PUSH
14205: LD_INT 1
14207: PUSH
14208: EMPTY
14209: LIST
14210: LIST
14211: PUSH
14212: EMPTY
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: PPUSH
14218: NOP4
14222: ST_TO_ADDR
// for I in Temp do
14223: NOP4
14227: PUSH
14228: NOP4
14232: PUSH
14233: FOR_IN
14234: IFFALSE 14322
// begin if IsDrivenBy ( I ) then
14236: NOP4
14240: PPUSH
14241: NOP4
14245: IFFALSE 14249
// continue ;
14247: GO 14233
// if ( GetEngine ( I ) = ENGINE_COMBUSTION ) and ( GetFuel ( I ) < 50 ) then
14249: NOP4
14253: PPUSH
14254: NOP4
14258: PUSH
14259: LD_INT 1
14261: EQUAL
14262: PUSH
14263: NOP4
14267: PPUSH
14268: NOP4
14272: PUSH
14273: LD_INT 50
14275: LESS
14276: AND
14277: IFFALSE 14281
// continue ;
14279: GO 14233
// if not GetWeapon ( I ) in YashinPovoleneZbrane then
14281: NOP4
14285: PPUSH
14286: NOP4
14290: PUSH
14291: NOP4
14295: IN
14296: NOT
14297: IFFALSE 14301
// continue ;
14299: GO 14233
// Volne = Volne union [ I ] ;
14301: NOP4
14305: PUSH
14306: NOP4
14310: PUSH
14311: NOP4
14315: PUSH
14316: EMPTY
14317: LIST
14318: UNION
14319: ST_TO_ADDR
// end ;
14320: GO 14233
14322: POP
14323: POP
// if not Volne then
14324: NOP4
14328: NOT
14329: IFFALSE 14333
// exit ;
14331: GO 14473
// YashinAutak = Volne [ 1 ] ;
14333: NOP4
14337: PUSH
14338: NOP4
14342: PUSH
14343: LD_INT 1
14345: ARRAY
14346: ST_TO_ADDR
// Dalka = GetDistUnits ( Yashin , YashinAutak ) ;
14347: NOP4
14351: PUSH
14352: NOP4
14356: PPUSH
14357: NOP4
14361: PPUSH
14362: NOP4
14366: ST_TO_ADDR
// for I in ( Volne diff [ YashinAutak ] ) do
14367: NOP4
14371: PUSH
14372: NOP4
14376: PUSH
14377: NOP4
14381: PUSH
14382: EMPTY
14383: LIST
14384: DIFF
14385: PUSH
14386: FOR_IN
14387: IFFALSE 14443
// begin Temp = GetDistUnits ( Yashin , I ) ;
14389: NOP4
14393: PUSH
14394: NOP4
14398: PPUSH
14399: NOP4
14403: PPUSH
14404: NOP4
14408: ST_TO_ADDR
// if Temp < Dalka then
14409: NOP4
14413: PUSH
14414: NOP4
14418: LESS
14419: IFFALSE 14441
// begin Dalka = Temp ;
14421: NOP4
14425: PUSH
14426: NOP4
14430: ST_TO_ADDR
// YashinAutak = I ;
14431: NOP4
14435: PUSH
14436: NOP4
14440: ST_TO_ADDR
// end ; end ;
14441: GO 14386
14443: POP
14444: POP
// ComEnterUnit ( Yashin , YashinAutak ) ;
14445: NOP4
14449: PPUSH
14450: NOP4
14454: PPUSH
14455: NOP4
// SetSide ( YashinAutak , side_Ru2 ) ;
14459: NOP4
14463: PPUSH
14464: NOP4
14468: PPUSH
14469: NOP4
// end ;
14473: LD_VAR 0 1
14477: RET
// function yashin_vyzadej_autak ; begin
14478: LD_INT 0
14480: PPUSH
// Nastupuje = true ;
14481: NOP4
14485: PUSH
14486: LD_INT 1
14488: ST_TO_ADDR
// ComCancel ( Yashin ) ;
14489: NOP4
14493: PPUSH
14494: NOP4
// if not yashin_chci_autak then
14498: NOP4
14502: NOT
14503: IFFALSE 14511
// begin enable ( 54 ) ;
14505: LD_INT 54
14507: ENABLE_MARKED
// enable ( 55 ) ;
14508: LD_INT 55
14510: ENABLE_MARKED
// end ; end ;
14511: LD_VAR 0 1
14515: RET
// function yashin_zacni_odjizdet ; begin
14516: LD_INT 0
14518: PPUSH
// Odjizdi = true ;
14519: NOP4
14523: PUSH
14524: LD_INT 1
14526: ST_TO_ADDR
// disable ( 54 ) ;
14527: LD_INT 54
14529: DISABLE_MARKED
// disable ( 55 ) ;
14530: LD_INT 55
14532: DISABLE_MARKED
// disable ( 56 ) ;
14533: LD_INT 56
14535: DISABLE_MARKED
// if not yashin_odjizdi then
14536: NOP4
14540: NOT
14541: IFFALSE 14546
// enable ( 52 ) ;
14543: LD_INT 52
14545: ENABLE_MARKED
// end ;
14546: LD_VAR 0 1
14550: RET
// function yashin_odjizdi ; var Jednotka ; begin
14551: LD_INT 0
14553: PPUSH
14554: PPUSH
// if YashinAutak then
14555: NOP4
14559: IFFALSE 14573
// Jednotka = YashinAutak else
14561: NOP4
14565: PUSH
14566: NOP4
14570: ST_TO_ADDR
14571: GO 14583
// Jednotka = Yashin ;
14573: NOP4
14577: PUSH
14578: NOP4
14582: ST_TO_ADDR
// if IsInArea ( Jednotka , YashinExit ) then
14583: NOP4
14587: PPUSH
14588: NOP4
14592: PPUSH
14593: NOP4
14597: IFFALSE 14613
// begin yashin_odstran ;
14599: NOP4
// Result = true ;
14603: NOP4
14607: PUSH
14608: LD_INT 1
14610: ST_TO_ADDR
// end else
14611: GO 14627
// begin ComMoveToArea ( Jednotka , YashinExit ) ;
14613: NOP4
14617: PPUSH
14618: NOP4
14622: PPUSH
14623: NOP4
// end ; end ;
14627: LD_VAR 0 1
14631: RET
// function yashin_zjisti_bunkry ; var Domy ; begin
14632: LD_INT 0
14634: PPUSH
14635: PPUSH
// Domy = FilterUnitsInArea ( AraboveBunkry , [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
14636: NOP4
14640: PUSH
14641: NOP4
14645: PPUSH
14646: LD_INT 22
14648: PUSH
14649: NOP4
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PUSH
14658: LD_INT 50
14660: PUSH
14661: EMPTY
14662: LIST
14663: PUSH
14664: LD_INT 21
14666: PUSH
14667: LD_INT 3
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: PUSH
14674: EMPTY
14675: LIST
14676: LIST
14677: LIST
14678: PPUSH
14679: NOP4
14683: ST_TO_ADDR
// Result = UnitFilter ( Domy , [ [ F_BTYPE , B_BREASTWORK ] ] ) union UnitFilter ( Domy , [ [ F_BTYPE , B_BUNKER ] ] ) union UnitFilter ( Domy , [ [ F_BTYPE , B_TURRET ] ] ) ;
14684: NOP4
14688: PUSH
14689: NOP4
14693: PPUSH
14694: LD_INT 30
14696: PUSH
14697: LD_INT 31
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: PUSH
14704: EMPTY
14705: LIST
14706: PPUSH
14707: NOP4
14711: PUSH
14712: NOP4
14716: PPUSH
14717: LD_INT 30
14719: PUSH
14720: LD_INT 32
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: EMPTY
14728: LIST
14729: PPUSH
14730: NOP4
14734: UNION
14735: PUSH
14736: NOP4
14740: PPUSH
14741: LD_INT 30
14743: PUSH
14744: LD_INT 33
14746: PUSH
14747: EMPTY
14748: LIST
14749: LIST
14750: PUSH
14751: EMPTY
14752: LIST
14753: PPUSH
14754: NOP4
14758: UNION
14759: ST_TO_ADDR
// end ;
14760: LD_VAR 0 1
14764: RET
// function yashin_znic_bunkr ( Zpatky ) ; begin
14765: LD_INT 0
14767: PPUSH
// ComAgressiveMove ( Yashin , 32 , 29 ) ;
14768: NOP4
14772: PPUSH
14773: LD_INT 32
14775: PPUSH
14776: LD_INT 29
14778: PPUSH
14779: NOP4
// AddComSailEvent ( Yashin , 111 ) ;
14783: NOP4
14787: PPUSH
14788: LD_INT 111
14790: PPUSH
14791: NOP4
// AddComAttackUnit ( Yashin , Bunkr ) ;
14795: NOP4
14799: PPUSH
14800: NOP4
14804: PPUSH
14805: NOP4
// AddComAgressiveMove ( Yashin , 33 , 35 ) ;
14809: NOP4
14813: PPUSH
14814: LD_INT 33
14816: PPUSH
14817: LD_INT 35
14819: PPUSH
14820: NOP4
// AddComMoveToArea ( Yashin , Zpatky ) ;
14824: NOP4
14828: PPUSH
14829: NOP4
14833: PPUSH
14834: NOP4
// enable ( 56 ) ;
14838: LD_INT 56
14840: ENABLE_MARKED
// end ;
14841: LD_VAR 0 2
14845: RET
// export function event_YashinUtoci ; begin
14846: LD_INT 0
14848: PPUSH
// RevealFogArea ( side_Ru , AraboveBunkry ) ;
14849: NOP4
14853: PPUSH
14854: NOP4
14858: PPUSH
14859: NOP4
// end ;
14863: LD_VAR 0 1
14867: RET
// export function yashin_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
14868: LD_INT 0
14870: PPUSH
// if Nastupuje and ( VehOld = YashinAutak ) then
14871: NOP4
14875: PUSH
14876: NOP4
14880: PUSH
14881: NOP4
14885: EQUAL
14886: AND
14887: IFFALSE 14899
// YashinAutak = VehNew ;
14889: NOP4
14893: PUSH
14894: NOP4
14898: ST_TO_ADDR
// end ;
14899: LD_VAR 0 5
14903: RET
// every 0 0$1.3 marked 52 do
14904: GO 14906
14906: DISABLE
// begin if not yashin_odjizdi then
14907: NOP4
14911: NOT
14912: IFFALSE 14915
// enable ;
14914: ENABLE
// end ;
14915: END
// every 0 0$2.7 marked 54 do
14916: GO 14918
14918: DISABLE
// begin if not yashin_chci_autak then
14919: NOP4
14923: NOT
14924: IFFALSE 14927
// enable ;
14926: ENABLE
// end ;
14927: END
// every 5 5$3 marked 55 do
14928: GO 14930
14930: DISABLE
// begin if Nastoupil then
14931: NOP4
14935: IFFALSE 14939
// exit ;
14937: GO 14961
// DialogueOn ;
14939: NOP4
// CenterOnUnits ( Yashin ) ;
14943: NOP4
14947: PPUSH
14948: NOP4
// dialog_YashinLeave ;
14952: NOP4
// DialogueOff ;
14956: NOP4
// enable ;
14960: ENABLE
// end ;
14961: END
// every 0 0$7.1 trigger ( not IsOK ( Bunkr ) ) or ( GetSide ( Bunkr ) <> side_Ar ) marked 56 do
14962: NOP4
14966: PPUSH
14967: NOP4
14971: NOT
14972: PUSH
14973: NOP4
14977: PPUSH
14978: NOP4
14982: PUSH
14983: NOP4
14987: NONEQUAL
14988: OR
14989: IFFALSE 15024
14991: GO 14993
14993: DISABLE
// begin RevealFogArea ( side_Ru , AraboveBunkry ) ;
14994: NOP4
14998: PPUSH
14999: NOP4
15003: PPUSH
15004: NOP4
// DialogueOn ;
15008: NOP4
// dialog_YashinLeave ;
15012: NOP4
// dialogueOff ;
15016: NOP4
// yashin_vyzadej_autak ;
15020: NOP4
// end ;
15024: END
// every 2 2$55 marked 51 do
15025: GO 15027
15027: DISABLE
// begin Wait ( MultiRand ( 0 0$1 , 2 2$0 , 2 ) ) ;
15028: LD_INT 35
15030: PPUSH
15031: LD_INT 4200
15033: PPUSH
15034: LD_INT 2
15036: PPUSH
15037: NOP4
15041: PPUSH
15042: NOP4
// yashin_start ;
15046: NOP4
// end ;
15050: END
// every 0 0$0.7 marked 53 do var Jednotky , Kdo , Cile , Utoci ;
15051: GO 15053
15053: DISABLE
15054: LD_INT 0
15056: PPUSH
15057: PPUSH
15058: PPUSH
15059: PPUSH
// begin Kdo = IsInUnit ( Yashin ) ;
15060: NOP4
15064: PUSH
15065: NOP4
15069: PPUSH
15070: NOP4
15074: ST_TO_ADDR
// if Kdo then
15075: NOP4
15079: IFFALSE 15102
// Cile = [ Yashin , Kdo ] else
15081: NOP4
15085: PUSH
15086: NOP4
15090: PUSH
15091: NOP4
15095: PUSH
15096: EMPTY
15097: LIST
15098: LIST
15099: ST_TO_ADDR
15100: GO 15115
// Cile = [ Yashin ] ;
15102: NOP4
15106: PUSH
15107: NOP4
15111: PUSH
15112: EMPTY
15113: LIST
15114: ST_TO_ADDR
// Utoci = false ;
15115: NOP4
15119: PUSH
15120: LD_INT 0
15122: ST_TO_ADDR
// Jednotky = FilterAllUnits ( [ [ F_OK ] , [ F_SIDE , side_Ru ] ] ) ;
15123: NOP4
15127: PUSH
15128: LD_INT 50
15130: PUSH
15131: EMPTY
15132: LIST
15133: PUSH
15134: LD_INT 22
15136: PUSH
15137: NOP4
15141: PUSH
15142: EMPTY
15143: LIST
15144: LIST
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: PPUSH
15150: NOP4
15154: ST_TO_ADDR
// for Kdo in Jednotky do
15155: NOP4
15159: PUSH
15160: NOP4
15164: PUSH
15165: FOR_IN
15166: IFFALSE 15230
// begin if ( WantsToAttack ( Kdo ) in Cile ) or ( Attacks ( Kdo ) in Cile ) then
15168: NOP4
15172: PPUSH
15173: NOP4
15177: PUSH
15178: NOP4
15182: IN
15183: PUSH
15184: NOP4
15188: PPUSH
15189: NOP4
15193: PUSH
15194: NOP4
15198: IN
15199: OR
15200: IFFALSE 15228
// begin ComCancel ( Kdo ) ;
15202: NOP4
15206: PPUSH
15207: NOP4
// ComHold ( Kdo ) ;
15211: NOP4
15215: PPUSH
15216: NOP4
// Utoci = true ;
15220: NOP4
15224: PUSH
15225: LD_INT 1
15227: ST_TO_ADDR
// end ; end ;
15228: GO 15165
15230: POP
15231: POP
// if Utoci then
15232: NOP4
15236: IFFALSE 15261
// begin DialogueOn ;
15238: NOP4
// dialog_YashinAttack ;
15242: NOP4
// DialogueOff ;
15246: NOP4
// if not Odjizdi then
15250: NOP4
15254: NOT
15255: IFFALSE 15261
// yashin_zacni_odjizdet ;
15257: NOP4
// end ; enable ;
15261: ENABLE
// end ;
15262: PPOPN 4
15264: END
// every 0 0$0.6 marked 57 do var L ;
15265: GO 15267
15267: DISABLE
15268: LD_INT 0
15270: PPUSH
// begin L = GetLives ( Yashin ) ;
15271: NOP4
15275: PUSH
15276: NOP4
15280: PPUSH
15281: NOP4
15285: ST_TO_ADDR
// if L < 1000 then
15286: NOP4
15290: PUSH
15291: LD_INT 1000
15293: LESS
15294: IFFALSE 15342
// begin L = L + 20 ;
15296: NOP4
15300: PUSH
15301: NOP4
15305: PUSH
15306: LD_INT 20
15308: PLUS
15309: ST_TO_ADDR
// if L > 1000 then
15310: NOP4
15314: PUSH
15315: LD_INT 1000
15317: GREATER
15318: IFFALSE 15328
// L = 1000 ;
15320: NOP4
15324: PUSH
15325: LD_INT 1000
15327: ST_TO_ADDR
// SetLives ( Yashin , L ) ;
15328: NOP4
15332: PPUSH
15333: NOP4
15337: PPUSH
15338: NOP4
// end ; enable ;
15342: ENABLE
// end ;
15343: PPOPN 1
15345: END
// export function yashin_UnitGoesToRed ( Un ) ; begin
15346: LD_INT 0
15348: PPUSH
// if Un = Yashin then
15349: NOP4
15353: PUSH
15354: NOP4
15358: EQUAL
15359: IFFALSE 15373
// SetLives ( Yashin , 300 ) ;
15361: NOP4
15365: PPUSH
15366: LD_INT 300
15368: PPUSH
15369: NOP4
// end ;
15373: LD_VAR 0 2
15377: RET
// function yashin_odstran ; begin
15378: LD_INT 0
15380: PPUSH
// if YashinAutak then
15381: NOP4
15385: IFFALSE 15396
// RemoveUnit ( YashinAutak ) ;
15387: NOP4
15391: PPUSH
15392: NOP4
// RemoveUnit ( Yashin ) ;
15396: NOP4
15400: PPUSH
15401: NOP4
// disable ( 53 ) ;
15405: LD_INT 53
15407: DISABLE_MARKED
// end ; end_of_file
15408: LD_VAR 0 1
15412: RET
// var KamArea , VraciSe ; var Krade , Nastupuje , KradenyVuz ; export function init_xavier ; begin
15413: LD_INT 0
15415: PPUSH
// KamArea = 0 ;
15416: NOP4
15420: PUSH
15421: LD_INT 0
15423: ST_TO_ADDR
// VraciSe = false ;
15424: NOP4
15428: PUSH
15429: LD_INT 0
15431: ST_TO_ADDR
// Krade = false ;
15432: NOP4
15436: PUSH
15437: LD_INT 0
15439: ST_TO_ADDR
// KradenyVuz = 0 ;
15440: NOP4
15444: PUSH
15445: LD_INT 0
15447: ST_TO_ADDR
// disable ( 21 ) ;
15448: LD_INT 21
15450: DISABLE_MARKED
// disable ( 22 ) ;
15451: LD_INT 22
15453: DISABLE_MARKED
// disable ( 23 ) ;
15454: LD_INT 23
15456: DISABLE_MARKED
// disable ( 24 ) ;
15457: LD_INT 24
15459: DISABLE_MARKED
// disable ( 26 ) ;
15460: LD_INT 26
15462: DISABLE_MARKED
// end ;
15463: LD_VAR 0 1
15467: RET
// function vytvor_xaviera ; begin
15468: LD_INT 0
15470: PPUSH
// Xavier = NewCharacter ( Xavier ) ;
15471: NOP4
15475: PUSH
15476: LD_STRING Xavier
15478: PPUSH
15479: NOP4
15483: ST_TO_ADDR
// SetSide ( Xavier , side_Xavier ) ;
15484: NOP4
15488: PPUSH
15489: NOP4
15493: PPUSH
15494: NOP4
// end ;
15498: LD_VAR 0 1
15502: RET
// export function xavier_start ; var Vysledek ; begin
15503: LD_INT 0
15505: PPUSH
15506: PPUSH
// vytvor_xaviera ;
15507: NOP4
// if not Yelena or not IsOk ( Yelena ) then
15511: NOP4
15515: NOT
15516: PUSH
15517: NOP4
15521: PPUSH
15522: NOP4
15526: NOT
15527: OR
15528: IFFALSE 15626
// begin SetSide ( Xavier , side_Ar ) ;
15530: NOP4
15534: PPUSH
15535: NOP4
15539: PPUSH
15540: NOP4
// PlaceUnitXYR ( Xavier , GetX ( Burlak ) , GetY ( Burlak ) , 6 , true ) ;
15544: NOP4
15548: PPUSH
15549: NOP4
15553: PPUSH
15554: NOP4
15558: PPUSH
15559: NOP4
15563: PPUSH
15564: NOP4
15568: PPUSH
15569: LD_INT 6
15571: PPUSH
15572: LD_INT 1
15574: PPUSH
15575: NOP4
// Wait ( 0 0$4 ) ;
15579: LD_INT 140
15581: PPUSH
15582: NOP4
// ComAttackUnit ( Xavier , Burlak ) ;
15586: NOP4
15590: PPUSH
15591: NOP4
15595: PPUSH
15596: NOP4
// if Difficulty = 3 then
15600: NOP4
15604: PUSH
15605: LD_INT 3
15607: EQUAL
15608: IFFALSE 15624
// PriorityAttack ( side_Ar , Burlak ) ;
15610: NOP4
15614: PPUSH
15615: NOP4
15619: PPUSH
15620: NOP4
// exit ;
15624: GO 15866
// end ; PlaceUnitXYR ( Xavier , GetX ( Yelena ) , GetY ( Yelena ) , 6 , true ) ;
15626: NOP4
15630: PPUSH
15631: NOP4
15635: PPUSH
15636: NOP4
15640: PPUSH
15641: NOP4
15645: PPUSH
15646: NOP4
15650: PPUSH
15651: LD_INT 6
15653: PPUSH
15654: LD_INT 1
15656: PPUSH
15657: NOP4
// ComHold ( Xavier ) ;
15661: NOP4
15665: PPUSH
15666: NOP4
// Wait ( 0 0$4 ) ;
15670: LD_INT 140
15672: PPUSH
15673: NOP4
// if not IsInUnit ( Yelena ) then
15677: NOP4
15681: PPUSH
15682: NOP4
15686: NOT
15687: IFFALSE 15703
// ComTurnUnit ( Yelena , Xavier ) ;
15689: NOP4
15693: PPUSH
15694: NOP4
15698: PPUSH
15699: NOP4
// ComTurnUnit ( Xavier , Yelena ) ;
15703: NOP4
15707: PPUSH
15708: NOP4
15712: PPUSH
15713: NOP4
// DialogueOn ;
15717: NOP4
// CenterOnUnits ( Yelena ) ;
15721: NOP4
15725: PPUSH
15726: NOP4
// dialog_MeetXavier ;
15730: NOP4
// Vysledek = query_Xavier ;
15734: NOP4
15738: PUSH
15739: NOP4
15743: ST_TO_ADDR
// if Vysledek = 1 then
15744: NOP4
15748: PUSH
15749: LD_INT 1
15751: EQUAL
15752: IFFALSE 15778
// begin dialog_QrXavier1 ;
15754: NOP4
// SetSide ( Xavier , side_Ru ) ;
15758: NOP4
15762: PPUSH
15763: NOP4
15767: PPUSH
15768: NOP4
// zkopiruj_xaviera_jako_rus ;
15772: NOP4
// end else
15776: GO 15862
// begin dialog_QrXavier2 ;
15778: NOP4
// ComWait ( Xavier , Rand ( 0 0$1 , 0 0$10 ) ) ;
15782: NOP4
15786: PPUSH
15787: LD_INT 35
15789: PPUSH
15790: LD_INT 350
15792: PPUSH
15793: NOP4
15797: PPUSH
15798: NOP4
// if Prob ( 50 ) then
15802: LD_INT 50
15804: PPUSH
15805: NOP4
15809: IFFALSE 15845
// begin AddComMoveToArea ( Xavier , DropBox ) ;
15811: NOP4
15815: PPUSH
15816: NOP4
15820: PPUSH
15821: NOP4
// AddComWait ( Xavier , Rand ( 0 0$5 , 0 0$15 ) ) ;
15825: NOP4
15829: PPUSH
15830: LD_INT 175
15832: PPUSH
15833: LD_INT 525
15835: PPUSH
15836: NOP4
15840: PPUSH
15841: NOP4
// end ; AddComMoveToArea ( Xavier , AraboveParkoviste ) ;
15845: NOP4
15849: PPUSH
15850: NOP4
15854: PPUSH
15855: NOP4
// enable ( 21 ) ;
15859: LD_INT 21
15861: ENABLE_MARKED
// end ; DialogueOff ;
15862: NOP4
// end ;
15866: LD_VAR 0 1
15870: RET
// function xavier_kolecko ; begin
15871: LD_INT 0
15873: PPUSH
// AddComMoveXY ( Xavier , 82 , 1 ) ;
15874: NOP4
15878: PPUSH
15879: LD_INT 82
15881: PPUSH
15882: LD_INT 1
15884: PPUSH
15885: NOP4
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15889: NOP4
15893: PPUSH
15894: LD_INT 35
15896: PPUSH
15897: LD_INT 175
15899: PPUSH
15900: NOP4
15904: PPUSH
15905: NOP4
// AddComMoveXY ( Xavier , 72 , 7 ) ;
15909: NOP4
15913: PPUSH
15914: LD_INT 72
15916: PPUSH
15917: LD_INT 7
15919: PPUSH
15920: NOP4
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15924: NOP4
15928: PPUSH
15929: LD_INT 35
15931: PPUSH
15932: LD_INT 175
15934: PPUSH
15935: NOP4
15939: PPUSH
15940: NOP4
// AddComMoveXY ( Xavier , 76 , 17 ) ;
15944: NOP4
15948: PPUSH
15949: LD_INT 76
15951: PPUSH
15952: LD_INT 17
15954: PPUSH
15955: NOP4
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15959: NOP4
15963: PPUSH
15964: LD_INT 35
15966: PPUSH
15967: LD_INT 175
15969: PPUSH
15970: NOP4
15974: PPUSH
15975: NOP4
// AddComMoveXY ( Xavier , 85 , 17 ) ;
15979: NOP4
15983: PPUSH
15984: LD_INT 85
15986: PPUSH
15987: LD_INT 17
15989: PPUSH
15990: NOP4
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15994: NOP4
15998: PPUSH
15999: LD_INT 35
16001: PPUSH
16002: LD_INT 175
16004: PPUSH
16005: NOP4
16009: PPUSH
16010: NOP4
// AddComMoveXY ( Xavier , 91 , 14 ) ;
16014: NOP4
16018: PPUSH
16019: LD_INT 91
16021: PPUSH
16022: LD_INT 14
16024: PPUSH
16025: NOP4
// AddComWait ( Xavier , Rand ( 0 0$5 , 0 0$10 ) ) ;
16029: NOP4
16033: PPUSH
16034: LD_INT 175
16036: PPUSH
16037: LD_INT 350
16039: PPUSH
16040: NOP4
16044: PPUSH
16045: NOP4
// AddComMoveXY ( Xavier , 89 , 24 ) ;
16049: NOP4
16053: PPUSH
16054: LD_INT 89
16056: PPUSH
16057: LD_INT 24
16059: PPUSH
16060: NOP4
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
16064: NOP4
16068: PPUSH
16069: LD_INT 35
16071: PPUSH
16072: LD_INT 175
16074: PPUSH
16075: NOP4
16079: PPUSH
16080: NOP4
// AddComMoveXY ( Xavier , 102 , 21 ) ;
16084: NOP4
16088: PPUSH
16089: LD_INT 102
16091: PPUSH
16092: LD_INT 21
16094: PPUSH
16095: NOP4
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
16099: NOP4
16103: PPUSH
16104: LD_INT 35
16106: PPUSH
16107: LD_INT 175
16109: PPUSH
16110: NOP4
16114: PPUSH
16115: NOP4
// AddComMoveXY ( Xavier , 102 , 8 ) ;
16119: NOP4
16123: PPUSH
16124: LD_INT 102
16126: PPUSH
16127: LD_INT 8
16129: PPUSH
16130: NOP4
// AddComWait ( Xavier , Rand ( 0 0$0.1 , 0 0$2 ) ) ;
16134: NOP4
16138: PPUSH
16139: LD_INT 4
16141: PPUSH
16142: LD_INT 70
16144: PPUSH
16145: NOP4
16149: PPUSH
16150: NOP4
// AddComMoveXY ( Xavier , 91 , 5 ) ;
16154: NOP4
16158: PPUSH
16159: LD_INT 91
16161: PPUSH
16162: LD_INT 5
16164: PPUSH
16165: NOP4
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
16169: NOP4
16173: PPUSH
16174: LD_INT 35
16176: PPUSH
16177: LD_INT 175
16179: PPUSH
16180: NOP4
16184: PPUSH
16185: NOP4
// AddComMoveXY ( Xavier , 82 , 1 ) ;
16189: NOP4
16193: PPUSH
16194: LD_INT 82
16196: PPUSH
16197: LD_INT 1
16199: PPUSH
16200: NOP4
// end ;
16204: LD_VAR 0 1
16208: RET
// function xavier_u_arabu ; begin
16209: LD_INT 0
16211: PPUSH
// xavier_kolecko ;
16212: NOP4
// enable ( 22 ) ;
16216: LD_INT 22
16218: ENABLE_MARKED
// end ;
16219: LD_VAR 0 1
16223: RET
// function xavier_timeout ; begin
16224: LD_INT 0
16226: PPUSH
// ComMoveToArea ( Xavier , DropBox ) ;
16227: NOP4
16231: PPUSH
16232: NOP4
16236: PPUSH
16237: NOP4
// enable ( 23 ) ;
16241: LD_INT 23
16243: ENABLE_MARKED
// end ;
16244: LD_VAR 0 1
16248: RET
// function xavier_dropbox ; begin
16249: LD_INT 0
16251: PPUSH
// InGameOn ;
16252: NOP4
// CenterOnUnits ( Xavier ) ;
16256: NOP4
16260: PPUSH
16261: NOP4
// dialog_PointXavier ;
16265: NOP4
// SetAreaMapShow ( DropBoxShow , 1 ) ;
16269: NOP4
16273: PPUSH
16274: LD_INT 1
16276: PPUSH
16277: NOP4
// Hint ( Xavier ) ;
16281: LD_STRING Xavier
16283: PPUSH
16284: NOP4
// ComWait ( Xavier , Rand ( 0 0$1 , 0 0$10 ) ) ;
16288: NOP4
16292: PPUSH
16293: LD_INT 35
16295: PPUSH
16296: LD_INT 350
16298: PPUSH
16299: NOP4
16303: PPUSH
16304: NOP4
// xavier_kolecko ;
16308: NOP4
// enable ( 24 ) ;
16312: LD_INT 24
16314: ENABLE_MARKED
// InGameOff ;
16315: NOP4
// end ;
16319: LD_VAR 0 1
16323: RET
// function xavier_zpatky ; var Depoty , Kdo ; begin
16324: LD_INT 0
16326: PPUSH
16327: PPUSH
16328: PPUSH
// Kdo = IsInUnit ( Xavier ) ;
16329: NOP4
16333: PUSH
16334: NOP4
16338: PPUSH
16339: NOP4
16343: ST_TO_ADDR
// if not Kdo then
16344: NOP4
16348: NOT
16349: IFFALSE 16361
// Kdo = Xavier ;
16351: NOP4
16355: PUSH
16356: NOP4
16360: ST_TO_ADDR
// ComAgressiveMove ( Kdo , 32 , 19 ) ;
16361: NOP4
16365: PPUSH
16366: LD_INT 32
16368: PPUSH
16369: LD_INT 19
16371: PPUSH
16372: NOP4
// if VsevSaved then
16376: NOP4
16380: IFFALSE 16394
// KamArea = YashinCil1 else
16382: NOP4
16386: PUSH
16387: NOP4
16391: ST_TO_ADDR
16392: GO 16404
// KamArea = YashinCil1a ;
16394: NOP4
16398: PUSH
16399: NOP4
16403: ST_TO_ADDR
// AddComMoveToArea ( Kdo , KamArea ) ;
16404: NOP4
16408: PPUSH
16409: NOP4
16413: PPUSH
16414: NOP4
// AddComSailEvent ( Kdo , 121 ) ;
16418: NOP4
16422: PPUSH
16423: LD_INT 121
16425: PPUSH
16426: NOP4
// VraciSe = true ;
16430: NOP4
16434: PUSH
16435: LD_INT 1
16437: ST_TO_ADDR
// end ;
16438: LD_VAR 0 1
16442: RET
// function xavier_autak ; begin
16443: LD_INT 0
16445: PPUSH
// Krade = true ;
16446: NOP4
16450: PUSH
16451: LD_INT 1
16453: ST_TO_ADDR
// Nastupuje = false ;
16454: NOP4
16458: PUSH
16459: LD_INT 0
16461: ST_TO_ADDR
// enable ( 26 ) ;
16462: LD_INT 26
16464: ENABLE_MARKED
// end ;
16465: LD_VAR 0 1
16469: RET
// function xavier_zkus_krast ; var Volne , Ridic ; begin
16470: LD_INT 0
16472: PPUSH
16473: PPUSH
16474: PPUSH
// Volne = FilterUnitsInArea ( AraboveParkoviste , [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_OK ] ] ) ;
16475: NOP4
16479: PUSH
16480: NOP4
16484: PPUSH
16485: LD_INT 22
16487: PUSH
16488: NOP4
16492: PUSH
16493: EMPTY
16494: LIST
16495: LIST
16496: PUSH
16497: LD_INT 21
16499: PUSH
16500: LD_INT 2
16502: PUSH
16503: EMPTY
16504: LIST
16505: LIST
16506: PUSH
16507: LD_INT 33
16509: PUSH
16510: LD_INT 1
16512: PUSH
16513: EMPTY
16514: LIST
16515: LIST
16516: PUSH
16517: LD_INT 50
16519: PUSH
16520: EMPTY
16521: LIST
16522: PUSH
16523: EMPTY
16524: LIST
16525: LIST
16526: LIST
16527: LIST
16528: PPUSH
16529: NOP4
16533: ST_TO_ADDR
// Volne = Volne diff UnitFilter ( Volne , [ [ F_WEAPON , AR_CONTROL_TOWER ] ] ) ;
16534: NOP4
16538: PUSH
16539: NOP4
16543: PUSH
16544: NOP4
16548: PPUSH
16549: LD_INT 34
16551: PUSH
16552: LD_INT 31
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PUSH
16559: EMPTY
16560: LIST
16561: PPUSH
16562: NOP4
16566: DIFF
16567: ST_TO_ADDR
// if not Volne then
16568: NOP4
16572: NOT
16573: IFFALSE 16580
// begin enable ( 26 ) ;
16575: LD_INT 26
16577: ENABLE_MARKED
// exit ;
16578: GO 16789
// end ; Nastupuje = true ;
16580: NOP4
16584: PUSH
16585: LD_INT 1
16587: ST_TO_ADDR
// KradenyVuz = Volne [ 1 ] ;
16588: NOP4
16592: PUSH
16593: NOP4
16597: PUSH
16598: LD_INT 1
16600: ARRAY
16601: ST_TO_ADDR
// Ridic = IsDrivenBy ( KradenyVuz ) ;
16602: NOP4
16606: PUSH
16607: NOP4
16611: PPUSH
16612: NOP4
16616: ST_TO_ADDR
// if Ridic then
16617: NOP4
16621: IFFALSE 16644
// begin ComExitVehicle ( Ridic ) ;
16623: NOP4
16627: PPUSH
16628: NOP4
// AddComWait ( Ridic , 0 0$5 ) ;
16632: NOP4
16636: PPUSH
16637: LD_INT 175
16639: PPUSH
16640: NOP4
// end ; ComEnterUnit ( Xavier , KradenyVuz ) ;
16644: NOP4
16648: PPUSH
16649: NOP4
16653: PPUSH
16654: NOP4
// Wait ( 0 0$3.2 ) ;
16658: LD_INT 112
16660: PPUSH
16661: NOP4
// while Xavier <> IsDrivenBy ( KradenyVuz ) do
16665: NOP4
16669: PUSH
16670: NOP4
16674: PPUSH
16675: NOP4
16679: NONEQUAL
16680: IFFALSE 16761
// begin Ridic = IsDrivenBy ( KradenyVuz ) ;
16682: NOP4
16686: PUSH
16687: NOP4
16691: PPUSH
16692: NOP4
16696: ST_TO_ADDR
// if Ridic = Xavier then
16697: NOP4
16701: PUSH
16702: NOP4
16706: EQUAL
16707: IFFALSE 16711
// break ;
16709: GO 16761
// if Ridic then
16711: NOP4
16715: IFFALSE 16738
// begin ComExitVehicle ( Ridic ) ;
16717: NOP4
16721: PPUSH
16722: NOP4
// AddComWait ( Ridic , 0 0$5 ) ;
16726: NOP4
16730: PPUSH
16731: LD_INT 175
16733: PPUSH
16734: NOP4
// end ; ComEnterUnit ( Xavier , KradenyVuz ) ;
16738: NOP4
16742: PPUSH
16743: NOP4
16747: PPUSH
16748: NOP4
// Wait ( 0 0$7.1 ) ;
16752: LD_INT 248
16754: PPUSH
16755: NOP4
// end ;
16759: GO 16665
// Krade = false ;
16761: NOP4
16765: PUSH
16766: LD_INT 0
16768: ST_TO_ADDR
// Nastupuje = false ;
16769: NOP4
16773: PUSH
16774: LD_INT 0
16776: ST_TO_ADDR
// xavier_zpatky ;
16777: NOP4
// KradenyVuz = 0 ;
16781: NOP4
16785: PUSH
16786: LD_INT 0
16788: ST_TO_ADDR
// end ;
16789: LD_VAR 0 1
16793: RET
// every 0 0$11.7 marked 26 do
16794: GO 16796
16796: DISABLE
// begin xavier_zkus_krast ;
16797: NOP4
// end ;
16801: END
// function xavier_zprava ; var Vysledek ; begin
16802: LD_INT 0
16804: PPUSH
16805: PPUSH
// DialogueOn ;
16806: NOP4
// Vysledek = query_QActivateXavier ;
16810: NOP4
16814: PUSH
16815: NOP4
16819: ST_TO_ADDR
// case Vysledek of 1 :
16820: NOP4
16824: PUSH
16825: LD_INT 1
16827: DOUBLE
16828: EQUAL
16829: IFTRUE 16833
16831: GO 16864
16833: POP
// begin dialog_QrActivateXavier1 ;
16834: NOP4
// xavier_zpatky ;
16838: NOP4
// SetAreaMapShow ( DropBoxShow , 0 ) ;
16842: NOP4
16846: PPUSH
16847: LD_INT 0
16849: PPUSH
16850: NOP4
// Result = true ;
16854: NOP4
16858: PUSH
16859: LD_INT 1
16861: ST_TO_ADDR
// end ; 2 :
16862: GO 16912
16864: LD_INT 2
16866: DOUBLE
16867: EQUAL
16868: IFTRUE 16872
16870: GO 16903
16872: POP
// begin dialog_QrActivateXavier2 ;
16873: NOP4
// xavier_autak ;
16877: NOP4
// SetAreaMapShow ( DropBoxShow , 0 ) ;
16881: NOP4
16885: PPUSH
16886: LD_INT 0
16888: PPUSH
16889: NOP4
// Result = true ;
16893: NOP4
16897: PUSH
16898: LD_INT 1
16900: ST_TO_ADDR
// end ; else
16901: GO 16912
16903: POP
// Result = false ; end ;
16904: NOP4
16908: PUSH
16909: LD_INT 0
16911: ST_TO_ADDR
// DialogueOff ;
16912: NOP4
// end ;
16916: LD_VAR 0 1
16920: RET
// export function xavier_prisel ; var Autak ; begin
16921: LD_INT 0
16923: PPUSH
16924: PPUSH
// VraciSe = false ;
16925: NOP4
16929: PUSH
16930: LD_INT 0
16932: ST_TO_ADDR
// Autak = IsInUnit ( Xavier ) ;
16933: NOP4
16937: PUSH
16938: NOP4
16942: PPUSH
16943: NOP4
16947: ST_TO_ADDR
// if Autak then
16948: NOP4
16952: IFFALSE 16968
// SetSide ( Autak , side_Ru ) ;
16954: NOP4
16958: PPUSH
16959: NOP4
16963: PPUSH
16964: NOP4
// SetSide ( Xavier , side_Ru ) ;
16968: NOP4
16972: PPUSH
16973: NOP4
16977: PPUSH
16978: NOP4
// zkopiruj_xaviera_jako_rus ;
16982: NOP4
// end ;
16986: LD_VAR 0 1
16990: RET
// every 0 0$2.7 trigger IsInArea ( Xavier , AraboveParkoviste ) marked 21 do
16991: NOP4
16995: PPUSH
16996: NOP4
17000: PPUSH
17001: NOP4
17005: IFFALSE 17014
17007: GO 17009
17009: DISABLE
// begin xavier_u_arabu ;
17010: NOP4
// end ;
17014: END
// every 1 1$0 marked 22 do
17015: GO 17017
17017: DISABLE
// begin Wait ( Rand ( 0 0$1 , 6 6$0 ) ) ;
17018: LD_INT 35
17020: PPUSH
17021: LD_INT 12600
17023: PPUSH
17024: NOP4
17028: PPUSH
17029: NOP4
// xavier_timeout ;
17033: NOP4
// end ;
17037: END
// every 0 0$4.2 trigger IsInArea ( Xavier , DropBox ) marked 23 do
17038: NOP4
17042: PPUSH
17043: NOP4
17047: PPUSH
17048: NOP4
17052: IFFALSE 17061
17054: GO 17056
17056: DISABLE
// begin ; xavier_dropbox ;
17057: NOP4
// end ;
17061: END
// every 0 0$3.7 trigger FilterUnitsInArea ( DropBox , [ [ F_SIDE , side_Ru ] , [ F_OK ] ] ) marked 24 do
17062: NOP4
17066: PPUSH
17067: LD_INT 22
17069: PUSH
17070: NOP4
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PUSH
17079: LD_INT 50
17081: PUSH
17082: EMPTY
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PPUSH
17089: NOP4
17093: IFFALSE 17113
17095: GO 17097
17097: DISABLE
// begin if not xavier_zprava then
17098: NOP4
17102: NOT
17103: IFFALSE 17113
// begin Wait ( 1 1$0 ) ;
17105: LD_INT 2100
17107: PPUSH
17108: NOP4
// enable ;
17112: ENABLE
// end ; end ;
17113: END
// export function event_XavierPrisel ; begin
17114: LD_INT 0
17116: PPUSH
// xavier_prisel ;
17117: NOP4
// end ;
17121: LD_VAR 0 1
17125: RET
// export function xavier_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
17126: LD_INT 0
17128: PPUSH
// if Nastupuje and ( VehOld = KradenyVuz ) then
17129: NOP4
17133: PUSH
17134: NOP4
17138: PUSH
17139: NOP4
17143: EQUAL
17144: AND
17145: IFFALSE 17157
// KradenyVuz = VehNew ;
17147: NOP4
17151: PUSH
17152: NOP4
17156: ST_TO_ADDR
// end ;
17157: LD_VAR 0 5
17161: RET
// function zkopiruj_xaviera_jako_rus ; var Xav , X , Y , Dir , InUnit ; begin
17162: LD_INT 0
17164: PPUSH
17165: PPUSH
17166: PPUSH
17167: PPUSH
17168: PPUSH
17169: PPUSH
// X = GetX ( Xavier ) ;
17170: NOP4
17174: PUSH
17175: NOP4
17179: PPUSH
17180: NOP4
17184: ST_TO_ADDR
// Y = GetY ( Xavier ) ;
17185: NOP4
17189: PUSH
17190: NOP4
17194: PPUSH
17195: NOP4
17199: ST_TO_ADDR
// Dir = GetDir ( Xavier ) ;
17200: NOP4
17204: PUSH
17205: NOP4
17209: PPUSH
17210: NOP4
17214: ST_TO_ADDR
// InUnit = IsInUnit ( Xavier ) ;
17215: NOP4
17219: PUSH
17220: NOP4
17224: PPUSH
17225: NOP4
17229: ST_TO_ADDR
// RemoveUnit ( Xavier ) ;
17230: NOP4
17234: PPUSH
17235: NOP4
// PrepareNewCharacter ( Xavier ) ;
17239: LD_STRING Xavier
17241: PPUSH
17242: NOP4
// UC_Side = side_Ru ;
17246: LD_ADDR_OWVAR 20
17250: PUSH
17251: NOP4
17255: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
17256: LD_ADDR_OWVAR 21
17260: PUSH
17261: LD_INT 3
17263: ST_TO_ADDR
// UC_Placed = false ;
17264: LD_ADDR_OWVAR 25
17268: PUSH
17269: LD_INT 0
17271: ST_TO_ADDR
// Xav = CreateHuman ;
17272: NOP4
17276: PUSH
17277: NOP4
17281: ST_TO_ADDR
// SetLives ( Xav , GetLives ( Xavier ) ) ;
17282: NOP4
17286: PPUSH
17287: NOP4
17291: PPUSH
17292: NOP4
17296: PPUSH
17297: NOP4
// DestroyUnit ( Xavier ) ;
17301: NOP4
17305: PPUSH
17306: NOP4
// Xavier = Xav ;
17310: NOP4
17314: PUSH
17315: NOP4
17319: ST_TO_ADDR
// if InUnit then
17320: NOP4
17324: IFFALSE 17342
// PlaceHumanInUnit ( Xavier , InUnit ) else
17326: NOP4
17330: PPUSH
17331: NOP4
17335: PPUSH
17336: NOP4
17340: GO 17378
// begin PlaceUnitXY ( Xavier , X , Y , false ) ;
17342: NOP4
17346: PPUSH
17347: NOP4
17351: PPUSH
17352: NOP4
17356: PPUSH
17357: LD_INT 0
17359: PPUSH
17360: NOP4
// SetDir ( Xavier , Dir ) ;
17364: NOP4
17368: PPUSH
17369: NOP4
17373: PPUSH
17374: NOP4
// end ; end ; end_of_file
17378: LD_VAR 0 1
17382: RET
// var Uniky ; var HeikeVytvorena ; var HeikeUtika ; var HeikeJdeKam ; var Start_Budovy , Start_Auta , Start_Lidi ; var Registry , Makro ; var HeikeVCervenem ; var Zajmuta ; export function init_heike ; begin
17383: LD_INT 0
17385: PPUSH
// disable ( 31 ) ;
17386: LD_INT 31
17388: DISABLE_MARKED
// disable ( 32 ) ;
17389: LD_INT 32
17391: DISABLE_MARKED
// Uniky = [ [ Unik1 , HeikeCil1 ] , [ Unik2 , HeikeCil2 ] , [ Unik3 , HeikeCil3 ] , [ Unik4 , HeikeCil4 ] , [ Unik5 , HeikeCil5 ] , [ Unik6 , HeikeCil6 ] , [ Unik7 , HeikeCil7 ] ] ;
17392: NOP4
17396: PUSH
17397: NOP4
17401: PUSH
17402: NOP4
17406: PUSH
17407: EMPTY
17408: LIST
17409: LIST
17410: PUSH
17411: NOP4
17415: PUSH
17416: NOP4
17420: PUSH
17421: EMPTY
17422: LIST
17423: LIST
17424: PUSH
17425: NOP4
17429: PUSH
17430: NOP4
17434: PUSH
17435: EMPTY
17436: LIST
17437: LIST
17438: PUSH
17439: NOP4
17443: PUSH
17444: NOP4
17448: PUSH
17449: EMPTY
17450: LIST
17451: LIST
17452: PUSH
17453: NOP4
17457: PUSH
17458: NOP4
17462: PUSH
17463: EMPTY
17464: LIST
17465: LIST
17466: PUSH
17467: NOP4
17471: PUSH
17472: NOP4
17476: PUSH
17477: EMPTY
17478: LIST
17479: LIST
17480: PUSH
17481: NOP4
17485: PUSH
17486: NOP4
17490: PUSH
17491: EMPTY
17492: LIST
17493: LIST
17494: PUSH
17495: EMPTY
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: LIST
17502: LIST
17503: ST_TO_ADDR
// HeikeVytvorena = false ;
17504: NOP4
17508: PUSH
17509: LD_INT 0
17511: ST_TO_ADDR
// HeikeUtika = false ;
17512: NOP4
17516: PUSH
17517: LD_INT 0
17519: ST_TO_ADDR
// HeikeVCervenem = false ;
17520: NOP4
17524: PUSH
17525: LD_INT 0
17527: ST_TO_ADDR
// Zajmuta = false ;
17528: NOP4
17532: PUSH
17533: LD_INT 0
17535: ST_TO_ADDR
// Start_Budovy = dif_HeikeBudovy [ Difficulty ] ;
17536: NOP4
17540: PUSH
17541: NOP4
17545: PUSH
17546: NOP4
17550: ARRAY
17551: ST_TO_ADDR
// Start_Auta = dif_HeikeAuta [ Difficulty ] ;
17552: NOP4
17556: PUSH
17557: NOP4
17561: PUSH
17562: NOP4
17566: ARRAY
17567: ST_TO_ADDR
// Start_Lidi = dif_HeikeLidi [ Difficulty ] ;
17568: NOP4
17572: PUSH
17573: NOP4
17577: PUSH
17578: NOP4
17582: ARRAY
17583: ST_TO_ADDR
// end ;
17584: LD_VAR 0 1
17588: RET
// function vytvor_heike ; var I ; begin
17589: LD_INT 0
17591: PPUSH
17592: PPUSH
// Heike = NewCharacter ( Heike ) ;
17593: NOP4
17597: PUSH
17598: LD_STRING Heike
17600: PPUSH
17601: NOP4
17605: ST_TO_ADDR
// SetSide ( Heike , side_Heike ) ;
17606: NOP4
17610: PPUSH
17611: NOP4
17615: PPUSH
17616: NOP4
// Heikeovci = [ ] ;
17620: NOP4
17624: PUSH
17625: EMPTY
17626: ST_TO_ADDR
// InitHC ;
17627: NOP4
// InitUC ;
17631: NOP4
// UC_Side = side_Strazci ;
17635: LD_ADDR_OWVAR 20
17639: PUSH
17640: NOP4
17644: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
17645: LD_ADDR_OWVAR 21
17649: PUSH
17650: LD_INT 2
17652: ST_TO_ADDR
// HC_Name =  ;
17653: LD_ADDR_OWVAR 26
17657: PUSH
17658: LD_STRING 
17660: ST_TO_ADDR
// HC_Class = CLASS_SOLDIER ;
17661: LD_ADDR_OWVAR 28
17665: PUSH
17666: LD_INT 1
17668: ST_TO_ADDR
// UC_Placed = false ;
17669: LD_ADDR_OWVAR 25
17673: PUSH
17674: LD_INT 0
17676: ST_TO_ADDR
// PrepareSoldierSkills ( 5 ) ;
17677: LD_INT 5
17679: PPUSH
17680: NOP4
// for I = 1 to dif_HeikeovciPocet [ Difficulty ] do
17684: NOP4
17688: PUSH
17689: DOUBLE
17690: LD_INT 1
17692: DEC
17693: ST_TO_ADDR
17694: NOP4
17698: PUSH
17699: NOP4
17703: ARRAY
17704: PUSH
17705: FOR_TO
17706: IFFALSE 17745
// begin HC_Sex = Rand ( 1 , 2 ) ;
17708: LD_ADDR_OWVAR 27
17712: PUSH
17713: LD_INT 1
17715: PPUSH
17716: LD_INT 2
17718: PPUSH
17719: NOP4
17723: ST_TO_ADDR
// Heikeovci = Heikeovci union [ CreateHuman ] ;
17724: NOP4
17728: PUSH
17729: NOP4
17733: PUSH
17734: NOP4
17738: PUSH
17739: EMPTY
17740: LIST
17741: UNION
17742: ST_TO_ADDR
// end ;
17743: GO 17705
17745: POP
17746: POP
// Heikeovci = Heikeovci diff [ 0 ] ;
17747: NOP4
17751: PUSH
17752: NOP4
17756: PUSH
17757: LD_INT 0
17759: PUSH
17760: EMPTY
17761: LIST
17762: DIFF
17763: ST_TO_ADDR
// SetLives ( Heikeovci , dif_HeikeovciLives [ Difficulty ] ) ;
17764: NOP4
17768: PPUSH
17769: NOP4
17773: PUSH
17774: NOP4
17778: ARRAY
17779: PPUSH
17780: NOP4
// end ;
17784: LD_VAR 0 1
17788: RET
// function heike_do_zakladny ; begin
17789: LD_INT 0
17791: PPUSH
// AddComMoveXY ( Heike , 87 , 120 ) ;
17792: NOP4
17796: PPUSH
17797: LD_INT 87
17799: PPUSH
17800: LD_INT 120
17802: PPUSH
17803: NOP4
// AddComMoveXY ( Heike , 83 , 114 ) ;
17807: NOP4
17811: PPUSH
17812: LD_INT 83
17814: PPUSH
17815: LD_INT 114
17817: PPUSH
17818: NOP4
// AddComMoveXY ( Heike , 74 , 97 ) ;
17822: NOP4
17826: PPUSH
17827: LD_INT 74
17829: PPUSH
17830: LD_INT 97
17832: PPUSH
17833: NOP4
// AddComMoveXY ( Heike , 66 , 78 ) ;
17837: NOP4
17841: PPUSH
17842: LD_INT 66
17844: PPUSH
17845: LD_INT 78
17847: PPUSH
17848: NOP4
// if VsevSaved then
17852: NOP4
17856: IFFALSE 17905
// begin AddComMoveXY ( Heike , 61 , 70 ) ;
17858: NOP4
17862: PPUSH
17863: LD_INT 61
17865: PPUSH
17866: LD_INT 70
17868: PPUSH
17869: NOP4
// AddComMoveXY ( Heike , 56 , 59 ) ;
17873: NOP4
17877: PPUSH
17878: LD_INT 56
17880: PPUSH
17881: LD_INT 59
17883: PPUSH
17884: NOP4
// AddComMoveXY ( Heike , 44 , 44 ) ;
17888: NOP4
17892: PPUSH
17893: LD_INT 44
17895: PPUSH
17896: LD_INT 44
17898: PPUSH
17899: NOP4
// end else
17903: GO 17980
// begin AddComMoveXY ( Heike , 44 , 73 ) ;
17905: NOP4
17909: PPUSH
17910: LD_INT 44
17912: PPUSH
17913: LD_INT 73
17915: PPUSH
17916: NOP4
// AddComMoveXY ( Heike , 36 , 65 ) ;
17920: NOP4
17924: PPUSH
17925: LD_INT 36
17927: PPUSH
17928: LD_INT 65
17930: PPUSH
17931: NOP4
// AddComMoveXY ( Heike , 47 , 59 ) ;
17935: NOP4
17939: PPUSH
17940: LD_INT 47
17942: PPUSH
17943: LD_INT 59
17945: PPUSH
17946: NOP4
// AddComMoveXY ( Heike , 28 , 51 ) ;
17950: NOP4
17954: PPUSH
17955: LD_INT 28
17957: PPUSH
17958: LD_INT 51
17960: PPUSH
17961: NOP4
// AddComMoveXY ( Heike , 29 , 42 ) ;
17965: NOP4
17969: PPUSH
17970: LD_INT 29
17972: PPUSH
17973: LD_INT 42
17975: PPUSH
17976: NOP4
// end ; AddComMoveXY ( Heike , 40 , 37 ) ;
17980: NOP4
17984: PPUSH
17985: LD_INT 40
17987: PPUSH
17988: LD_INT 37
17990: PPUSH
17991: NOP4
// AddComMoveXY ( Heike , 33 , 22 ) ;
17995: NOP4
17999: PPUSH
18000: LD_INT 33
18002: PPUSH
18003: LD_INT 22
18005: PPUSH
18006: NOP4
// AddComMoveXY ( Heike , 33 , 16 ) ;
18010: NOP4
18014: PPUSH
18015: LD_INT 33
18017: PPUSH
18018: LD_INT 16
18020: PPUSH
18021: NOP4
// AddComMoveXY ( Heike , 38 , 13 ) ;
18025: NOP4
18029: PPUSH
18030: LD_INT 38
18032: PPUSH
18033: LD_INT 13
18035: PPUSH
18036: NOP4
// AddComMoveXY ( Heike , 46 , 13 ) ;
18040: NOP4
18044: PPUSH
18045: LD_INT 46
18047: PPUSH
18048: LD_INT 13
18050: PPUSH
18051: NOP4
// AddComMoveXY ( Heike , 54 , 16 ) ;
18055: NOP4
18059: PPUSH
18060: LD_INT 54
18062: PPUSH
18063: LD_INT 16
18065: PPUSH
18066: NOP4
// AddComMoveXY ( Heike , 62 , 15 ) ;
18070: NOP4
18074: PPUSH
18075: LD_INT 62
18077: PPUSH
18078: LD_INT 15
18080: PPUSH
18081: NOP4
// AddComMoveXY ( Heike , 73 , 14 ) ;
18085: NOP4
18089: PPUSH
18090: LD_INT 73
18092: PPUSH
18093: LD_INT 14
18095: PPUSH
18096: NOP4
// AddComMoveXY ( Heike , 91 , 13 ) ;
18100: NOP4
18104: PPUSH
18105: LD_INT 91
18107: PPUSH
18108: LD_INT 13
18110: PPUSH
18111: NOP4
// AddComMoveToArea ( Heike , HeikeCil ) ;
18115: NOP4
18119: PPUSH
18120: NOP4
18124: PPUSH
18125: NOP4
// end ;
18129: LD_VAR 0 1
18133: RET
// function heike_start ; var Auto ; begin
18134: LD_INT 0
18136: PPUSH
18137: PPUSH
// if GetSide ( Xavier ) <> side_Ru then
18138: NOP4
18142: PPUSH
18143: NOP4
18147: PUSH
18148: NOP4
18152: NONEQUAL
18153: IFFALSE 18159
// xavier_prisel ;
18155: NOP4
// vytvor_heike ;
18159: NOP4
// PlaceUnitArea ( Heike , HeikeStart , false ) ;
18163: NOP4
18167: PPUSH
18168: NOP4
18172: PPUSH
18173: LD_INT 0
18175: PPUSH
18176: NOP4
// place_list ( Heikeovci , HeikeStart ) ;
18180: NOP4
18184: PPUSH
18185: NOP4
18189: PPUSH
18190: NOP4
// Wait ( Rand ( 0 0$1 , 0 0$5 ) ) ;
18194: LD_INT 35
18196: PPUSH
18197: LD_INT 175
18199: PPUSH
18200: NOP4
18204: PPUSH
18205: NOP4
// Registry = McRegistry ( side_Heike , [ [ MC_REG_UNITS_TO_PROTECT , [ Heike ] ] ] ) ;
18209: NOP4
18213: PUSH
18214: NOP4
18218: PPUSH
18219: LD_INT 4
18221: PUSH
18222: NOP4
18226: PUSH
18227: EMPTY
18228: LIST
18229: PUSH
18230: EMPTY
18231: LIST
18232: LIST
18233: PUSH
18234: EMPTY
18235: LIST
18236: PPUSH
18237: NOP4
18241: ST_TO_ADDR
// Makro = McDefend ( 0 , Registry , Heikeovci , [ ] ) ;
18242: NOP4
18246: PUSH
18247: LD_INT 0
18249: PPUSH
18250: NOP4
18254: PPUSH
18255: NOP4
18259: PPUSH
18260: EMPTY
18261: PPUSH
18262: NOP4
18266: ST_TO_ADDR
// DialogueOn ;
18267: NOP4
// dialog_HeikeObj ;
18271: NOP4
// ChangeMissionObjectives ( MHeike ) ;
18275: LD_STRING MHeike
18277: PPUSH
18278: NOP4
// Query ( QHeike ) ;
18282: LD_STRING QHeike
18284: PPUSH
18285: NOP4
// DialogueOff ;
18289: NOP4
// RevealFogArea ( side_Ru , HeikeStart ) ;
18293: NOP4
18297: PPUSH
18298: NOP4
18302: PPUSH
18303: NOP4
// CenterOnUnits ( Heike ) ;
18307: NOP4
18311: PPUSH
18312: NOP4
// heike_do_zakladny ;
18316: NOP4
// ComMoveUnit ( Heikeovci , Heike ) ;
18320: NOP4
18324: PPUSH
18325: NOP4
18329: PPUSH
18330: NOP4
// enable ( 32 ) ;
18334: LD_INT 32
18336: ENABLE_MARKED
// end ;
18337: LD_VAR 0 1
18341: RET
// function heike_kontrola_start ; var Budovy , Auta , Lidi ; begin
18342: LD_INT 0
18344: PPUSH
18345: PPUSH
18346: PPUSH
18347: PPUSH
// if HeikeVytvorena then
18348: NOP4
18352: IFFALSE 18356
// exit ;
18354: GO 18569
// Budovy = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18356: NOP4
18360: PUSH
18361: LD_INT 22
18363: PUSH
18364: NOP4
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PUSH
18373: LD_INT 21
18375: PUSH
18376: LD_INT 3
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 50
18385: PUSH
18386: EMPTY
18387: LIST
18388: PUSH
18389: LD_INT 52
18391: PUSH
18392: EMPTY
18393: LIST
18394: PUSH
18395: EMPTY
18396: LIST
18397: LIST
18398: LIST
18399: LIST
18400: PPUSH
18401: NOP4
18405: ST_TO_ADDR
// Auta = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18406: NOP4
18410: PUSH
18411: LD_INT 22
18413: PUSH
18414: NOP4
18418: PUSH
18419: EMPTY
18420: LIST
18421: LIST
18422: PUSH
18423: LD_INT 21
18425: PUSH
18426: LD_INT 2
18428: PUSH
18429: EMPTY
18430: LIST
18431: LIST
18432: PUSH
18433: LD_INT 50
18435: PUSH
18436: EMPTY
18437: LIST
18438: PUSH
18439: LD_INT 52
18441: PUSH
18442: EMPTY
18443: LIST
18444: PUSH
18445: EMPTY
18446: LIST
18447: LIST
18448: LIST
18449: LIST
18450: PPUSH
18451: NOP4
18455: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18456: NOP4
18460: PUSH
18461: LD_INT 22
18463: PUSH
18464: NOP4
18468: PUSH
18469: EMPTY
18470: LIST
18471: LIST
18472: PUSH
18473: LD_INT 21
18475: PUSH
18476: LD_INT 1
18478: PUSH
18479: EMPTY
18480: LIST
18481: LIST
18482: PUSH
18483: LD_INT 50
18485: PUSH
18486: EMPTY
18487: LIST
18488: PUSH
18489: LD_INT 52
18491: PUSH
18492: EMPTY
18493: LIST
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: PPUSH
18501: NOP4
18505: ST_TO_ADDR
// if ( ( Budovy <= Start_Budovy ) and ( Auta <= Start_Auta ) ) or ( Lidi <= Start_Lidi ) then
18506: NOP4
18510: PUSH
18511: NOP4
18515: LESSEQUAL
18516: PUSH
18517: NOP4
18521: PUSH
18522: NOP4
18526: LESSEQUAL
18527: AND
18528: PUSH
18529: NOP4
18533: PUSH
18534: NOP4
18538: LESSEQUAL
18539: OR
18540: IFFALSE 18569
// begin HeikeVytvorena = true ;
18542: NOP4
18546: PUSH
18547: LD_INT 1
18549: ST_TO_ADDR
// Wait ( Rand ( 0 0$3 , 0 0$20 ) ) ;
18550: LD_INT 105
18552: PPUSH
18553: LD_INT 700
18555: PPUSH
18556: NOP4
18560: PPUSH
18561: NOP4
// heike_start ;
18565: NOP4
// end ; end ;
18569: LD_VAR 0 1
18573: RET
// function je_volny_unik ( Area ) ; var KdoTam ; begin
18574: LD_INT 0
18576: PPUSH
18577: PPUSH
// KdoTam = FilterUnitsInArea ( Area , [ [ F_SIDE , side_Ru ] , [ F_OK ] ] ) ;
18578: NOP4
18582: PUSH
18583: NOP4
18587: PPUSH
18588: LD_INT 22
18590: PUSH
18591: NOP4
18595: PUSH
18596: EMPTY
18597: LIST
18598: LIST
18599: PUSH
18600: LD_INT 50
18602: PUSH
18603: EMPTY
18604: LIST
18605: PUSH
18606: EMPTY
18607: LIST
18608: LIST
18609: PPUSH
18610: NOP4
18614: ST_TO_ADDR
// if KdoTam then
18615: NOP4
18619: IFFALSE 18631
// Result = false else
18621: NOP4
18625: PUSH
18626: LD_INT 0
18628: ST_TO_ADDR
18629: GO 18639
// Result = true ;
18631: NOP4
18635: PUSH
18636: LD_INT 1
18638: ST_TO_ADDR
// end ;
18639: LD_VAR 0 2
18643: RET
// function zjisti_volne ; var Akt , Jednotky ; begin
18644: LD_INT 0
18646: PPUSH
18647: PPUSH
18648: PPUSH
// Result = [ ] ;
18649: NOP4
18653: PUSH
18654: EMPTY
18655: ST_TO_ADDR
// for Akt in Uniky do
18656: NOP4
18660: PUSH
18661: NOP4
18665: PUSH
18666: FOR_IN
18667: IFFALSE 18705
// begin if je_volny_unik ( Akt [ 1 ] ) then
18669: NOP4
18673: PUSH
18674: LD_INT 1
18676: ARRAY
18677: PPUSH
18678: NOP4
18682: IFFALSE 18703
// Result = Result union [ Akt ] ;
18684: NOP4
18688: PUSH
18689: NOP4
18693: PUSH
18694: NOP4
18698: PUSH
18699: EMPTY
18700: LIST
18701: UNION
18702: ST_TO_ADDR
// end ;
18703: GO 18666
18705: POP
18706: POP
// end ;
18707: LD_VAR 0 1
18711: RET
// function zjisti_heike_utekla ; var Akt ; begin
18712: LD_INT 0
18714: PPUSH
18715: PPUSH
// Result = false ;
18716: NOP4
18720: PUSH
18721: LD_INT 0
18723: ST_TO_ADDR
// if not IsOk ( Heike ) then
18724: NOP4
18728: PPUSH
18729: NOP4
18733: NOT
18734: IFFALSE 18738
// exit ;
18736: GO 18819
// Result = true ;
18738: NOP4
18742: PUSH
18743: LD_INT 1
18745: ST_TO_ADDR
// if IsInArea ( Heike , HeikeCil ) then
18746: NOP4
18750: PPUSH
18751: NOP4
18755: PPUSH
18756: NOP4
18760: IFFALSE 18764
// exit ;
18762: GO 18819
// if HeikeUtika then
18764: NOP4
18768: IFFALSE 18811
// begin for Akt in Uniky do
18770: NOP4
18774: PUSH
18775: NOP4
18779: PUSH
18780: FOR_IN
18781: IFFALSE 18809
// if IsInArea ( Heike , Akt [ 2 ] ) then
18783: NOP4
18787: PPUSH
18788: NOP4
18792: PUSH
18793: LD_INT 2
18795: ARRAY
18796: PPUSH
18797: NOP4
18801: IFFALSE 18807
// exit ;
18803: POP
18804: POP
18805: GO 18819
18807: GO 18780
18809: POP
18810: POP
// end ; Result = false ;
18811: NOP4
18815: PUSH
18816: LD_INT 0
18818: ST_TO_ADDR
// end ;
18819: LD_VAR 0 1
18823: RET
// function GetDistUnitArea2 ( Un , Area ) ; var Hex ; begin
18824: LD_INT 0
18826: PPUSH
18827: PPUSH
// Hex = RandHexArea ( Area , false ) ;
18828: NOP4
18832: PUSH
18833: NOP4
18837: PPUSH
18838: LD_INT 0
18840: PPUSH
18841: NOP4
18845: ST_TO_ADDR
// Result = GetDistUnitXY ( Un , Hex [ 1 ] , Hex [ 2 ] ) ;
18846: NOP4
18850: PUSH
18851: NOP4
18855: PPUSH
18856: NOP4
18860: PUSH
18861: LD_INT 1
18863: ARRAY
18864: PPUSH
18865: NOP4
18869: PUSH
18870: LD_INT 2
18872: ARRAY
18873: PPUSH
18874: NOP4
18878: ST_TO_ADDR
// end ;
18879: LD_VAR 0 3
18883: RET
// function zjisti_nejlepsi_unik ( Seznam ) ; var Min , Akt , AktDal ; begin
18884: LD_INT 0
18886: PPUSH
18887: PPUSH
18888: PPUSH
18889: PPUSH
// Result = [ ] ;
18890: NOP4
18894: PUSH
18895: EMPTY
18896: ST_TO_ADDR
// Min = 99999 ;
18897: NOP4
18901: PUSH
18902: LD_INT 99999
18904: ST_TO_ADDR
// for Akt in Seznam do
18905: NOP4
18909: PUSH
18910: NOP4
18914: PUSH
18915: FOR_IN
18916: IFFALSE 18976
// begin AktDal = GetDistUnitArea2 ( Heike , Akt [ 1 ] ) ;
18918: NOP4
18922: PUSH
18923: NOP4
18927: PPUSH
18928: NOP4
18932: PUSH
18933: LD_INT 1
18935: ARRAY
18936: PPUSH
18937: NOP4
18941: ST_TO_ADDR
// if AktDal < Min then
18942: NOP4
18946: PUSH
18947: NOP4
18951: LESS
18952: IFFALSE 18974
// begin Result = Akt ;
18954: NOP4
18958: PUSH
18959: NOP4
18963: ST_TO_ADDR
// Min = AktDal ;
18964: NOP4
18968: PUSH
18969: NOP4
18973: ST_TO_ADDR
// end ; end ;
18974: GO 18915
18976: POP
18977: POP
// end ;
18978: LD_VAR 0 2
18982: RET
// function heike_utika ; var Volno , Hex ; begin
18983: LD_INT 0
18985: PPUSH
18986: PPUSH
18987: PPUSH
// if zjisti_heike_utekla then
18988: NOP4
18992: IFFALSE 19000
// begin heike_utekla ;
18994: NOP4
// exit ;
18998: GO 19092
// end ; Volno = zjisti_volne ;
19000: NOP4
19004: PUSH
19005: NOP4
19009: ST_TO_ADDR
// if HeikeUtika then
19010: NOP4
19014: IFFALSE 19033
// begin if je_volny_unik ( HeikeJdeKam [ 1 ] ) then
19016: NOP4
19020: PUSH
19021: LD_INT 1
19023: ARRAY
19024: PPUSH
19025: NOP4
19029: IFFALSE 19033
// exit ;
19031: GO 19092
// end ; HeikeJdeKam = zjisti_nejlepsi_unik ( Volno ) ;
19033: NOP4
19037: PUSH
19038: NOP4
19042: PPUSH
19043: NOP4
19047: ST_TO_ADDR
// ComMoveToArea ( Heike , HeikeJdeKam [ 1 ] ) ;
19048: NOP4
19052: PPUSH
19053: NOP4
19057: PUSH
19058: LD_INT 1
19060: ARRAY
19061: PPUSH
19062: NOP4
// AddComMoveToArea ( Heike , HeikeJdeKam [ 2 ] ) ;
19066: NOP4
19070: PPUSH
19071: NOP4
19075: PUSH
19076: LD_INT 2
19078: ARRAY
19079: PPUSH
19080: NOP4
// HeikeUtika = true ;
19084: NOP4
19088: PUSH
19089: LD_INT 1
19091: ST_TO_ADDR
// end ;
19092: LD_VAR 0 1
19096: RET
// function strazci_mrtvi ; begin
19097: LD_INT 0
19099: PPUSH
// heike_utec ;
19100: NOP4
// end ;
19104: LD_VAR 0 1
19108: RET
// every 0 0$1.3 marked 32 do
19109: GO 19111
19111: DISABLE
// begin if zjisti_heike_utekla then
19112: NOP4
19116: IFFALSE 19124
// begin heike_utekla ;
19118: NOP4
// exit ;
19122: GO 19124
// end ; end ;
19124: END
// every 0 0$1.1 marked 31 do
19125: GO 19127
19127: DISABLE
// begin heike_utika ;
19128: NOP4
// enable ;
19132: ENABLE
// end ;
19133: END
// function heike_utec ; begin
19134: LD_INT 0
19136: PPUSH
// if IsInArea ( Heike , Obkliceni ) then
19137: NOP4
19141: PPUSH
19142: NOP4
19146: PPUSH
19147: NOP4
19151: IFFALSE 19162
// begin enable ( 31 ) ;
19153: LD_INT 31
19155: ENABLE_MARKED
// heike_utika ;
19156: NOP4
// end else
19160: GO 19179
// begin enable ( 32 ) ;
19162: LD_INT 32
19164: ENABLE_MARKED
// ComMoveToArea ( Heike , HeikeCil ) ;
19165: NOP4
19169: PPUSH
19170: NOP4
19174: PPUSH
19175: NOP4
// end ; end ;
19179: LD_VAR 0 1
19183: RET
// function heike_utekla ; begin
19184: LD_INT 0
19186: PPUSH
// InGameOn ;
19187: NOP4
// CenterOnUnits ( Heike ) ;
19191: NOP4
19195: PPUSH
19196: NOP4
// Wait ( 0 0$2 ) ;
19200: LD_INT 70
19202: PPUSH
19203: NOP4
// if not IsOk ( Heike ) then
19207: NOP4
19211: PPUSH
19212: NOP4
19216: NOT
19217: IFFALSE 19229
// begin InGameOff ;
19219: NOP4
// heike_mrtva ;
19223: NOP4
// exit ;
19227: GO 19256
// end ; RemoveUnit ( Heike ) ;
19229: NOP4
19233: PPUSH
19234: NOP4
// Wait ( 0 0$2 ) ;
19238: LD_INT 70
19240: PPUSH
19241: NOP4
// YouLost ( Heike ) ;
19245: LD_STRING Heike
19247: PPUSH
19248: NOP4
// InGameOff ;
19252: NOP4
// end ;
19256: LD_VAR 0 1
19260: RET
// function heike_zajata ; begin
19261: LD_INT 0
19263: PPUSH
// if Zajmuta then
19264: NOP4
19268: IFFALSE 19272
// exit ;
19270: GO 19384
// Zajmuta = true ;
19272: NOP4
19276: PUSH
19277: LD_INT 1
19279: ST_TO_ADDR
// SetAttitude ( side_Ru , side_Heike , ATT_FRIEND , true ) ;
19280: NOP4
19284: PPUSH
19285: NOP4
19289: PPUSH
19290: LD_INT 1
19292: PPUSH
19293: LD_INT 1
19295: PPUSH
19296: NOP4
// ComHold ( Heike ) ;
19300: NOP4
19304: PPUSH
19305: NOP4
// if ( GetLives ( Heike ) <= HRANICE_UMIRANI ) then
19309: NOP4
19313: PPUSH
19314: NOP4
19318: PUSH
19319: LD_INT 250
19321: LESSEQUAL
19322: IFFALSE 19340
// SetLives ( Heike , HRANICE_UMIRANI + 1 ) ;
19324: NOP4
19328: PPUSH
19329: LD_INT 250
19331: PUSH
19332: LD_INT 1
19334: PLUS
19335: PPUSH
19336: NOP4
// ComCancel ( Heike ) ;
19340: NOP4
19344: PPUSH
19345: NOP4
// ComHold ( Heike ) ;
19349: NOP4
19353: PPUSH
19354: NOP4
// DialogueOn ;
19358: NOP4
// dialog_HeikeCapt ;
19362: NOP4
// DialogueOff ;
19366: NOP4
// Wait ( 0 0$2 ) ;
19370: LD_INT 70
19372: PPUSH
19373: NOP4
// vyhral ( Main2 ) ;
19377: LD_STRING Main2
19379: PPUSH
19380: NOP4
// end ;
19384: LD_VAR 0 1
19388: RET
// function heike_mrtva ; begin
19389: LD_INT 0
19391: PPUSH
// DialogueOn ;
19392: NOP4
// Wait ( 0 0$3 ) ;
19396: LD_INT 105
19398: PPUSH
19399: NOP4
// vyhral ( Main1 ) ;
19403: LD_STRING Main1
19405: PPUSH
19406: NOP4
// DialogueOff ;
19410: NOP4
// end ;
19414: LD_VAR 0 1
19418: RET
// function straz_umrela ( Un ) ; begin
19419: LD_INT 0
19421: PPUSH
// if Un in Heikeovci then
19422: NOP4
19426: PUSH
19427: NOP4
19431: IN
19432: IFFALSE 19464
// begin Heikeovci = Heikeovci diff [ Un ] ;
19434: NOP4
19438: PUSH
19439: NOP4
19443: PUSH
19444: NOP4
19448: PUSH
19449: EMPTY
19450: LIST
19451: DIFF
19452: ST_TO_ADDR
// if not Heikeovci then
19453: NOP4
19457: NOT
19458: IFFALSE 19464
// strazci_mrtvi ;
19460: NOP4
// end ; end ;
19464: LD_VAR 0 2
19468: RET
// export function heike_UnitDestroyed ( Un ) ; begin
19469: LD_INT 0
19471: PPUSH
// if Un = Heike then
19472: NOP4
19476: PUSH
19477: NOP4
19481: EQUAL
19482: IFFALSE 19490
// begin heike_mrtva ;
19484: NOP4
// exit ;
19488: GO 19503
// end ; straz_umrela ( Un ) ;
19490: NOP4
19494: PPUSH
19495: NOP4
// heike_kontrola_start ;
19499: NOP4
// end ;
19503: LD_VAR 0 2
19507: RET
// export function heike_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
19508: LD_INT 0
19510: PPUSH
// heike_kontrola_start ;
19511: NOP4
// end ;
19515: LD_VAR 0 5
19519: RET
// export function heike_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
19520: LD_INT 0
19522: PPUSH
// heike_kontrola_start ;
19523: NOP4
// end ;
19527: LD_VAR 0 4
19531: RET
// export function heike_UnitGoesToRed ( Un ) ; begin
19532: LD_INT 0
19534: PPUSH
// if Un = Heike then
19535: NOP4
19539: PUSH
19540: NOP4
19544: EQUAL
19545: IFFALSE 19555
// HeikeVCervenem = true ;
19547: NOP4
19551: PUSH
19552: LD_INT 1
19554: ST_TO_ADDR
// straz_umrela ( Un ) ;
19555: NOP4
19559: PPUSH
19560: NOP4
// heike_kontrola_start ;
19564: NOP4
// end ;
19568: LD_VAR 0 2
19572: RET
// export function heike_StartHeal ( Un , Medic ) ; begin
19573: LD_INT 0
19575: PPUSH
// if Un <> Heike then
19576: NOP4
19580: PUSH
19581: NOP4
19585: NONEQUAL
19586: IFFALSE 19590
// exit ;
19588: GO 19630
// if not HeikeVCervenem then
19590: NOP4
19594: NOT
19595: IFFALSE 19599
// exit ;
19597: GO 19630
// if Heikeovci then
19599: NOP4
19603: IFFALSE 19607
// exit ;
19605: GO 19630
// if GetSide ( Medic ) <> side_Ru then
19607: NOP4
19611: PPUSH
19612: NOP4
19616: PUSH
19617: NOP4
19621: NONEQUAL
19622: IFFALSE 19626
// exit ;
19624: GO 19630
// heike_zajata ;
19626: NOP4
// end ; end_of_file
19630: LD_VAR 0 3
19634: RET
// var BednyA ; var BednyRZ , BednyRV ; export function init_Suroviny ; begin
19635: LD_INT 0
19637: PPUSH
// BednyA = dif_BednyA [ Difficulty ] ;
19638: NOP4
19642: PUSH
19643: NOP4
19647: PUSH
19648: NOP4
19652: ARRAY
19653: ST_TO_ADDR
// if VsevSaved then
19654: NOP4
19658: IFFALSE 19694
// begin BednyRZ = dif_BednyR1 [ Difficulty ] ;
19660: NOP4
19664: PUSH
19665: NOP4
19669: PUSH
19670: NOP4
19674: ARRAY
19675: ST_TO_ADDR
// BednyRV = dif_BednyR2 [ Difficulty ] ;
19676: NOP4
19680: PUSH
19681: NOP4
19685: PUSH
19686: NOP4
19690: ARRAY
19691: ST_TO_ADDR
// end else
19692: GO 19726
// begin BednyRZ = dif_BednyR2 [ Difficulty ] ;
19694: NOP4
19698: PUSH
19699: NOP4
19703: PUSH
19704: NOP4
19708: ARRAY
19709: ST_TO_ADDR
// BednyRV = dif_BednyR1 [ Difficulty ] ;
19710: NOP4
19714: PUSH
19715: NOP4
19719: PUSH
19720: NOP4
19724: ARRAY
19725: ST_TO_ADDR
// end ; end ;
19726: LD_VAR 0 1
19730: RET
// every 5 5$13.7 + 5 5$9 do var Pocet ;
19731: GO 19733
19733: DISABLE
19734: LD_INT 0
19736: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$30 ) ) ;
19737: LD_INT 35
19739: PPUSH
19740: LD_INT 3150
19742: PPUSH
19743: NOP4
19747: PPUSH
19748: NOP4
// Pocet = Rand ( 0 , 5 ) ;
19752: NOP4
19756: PUSH
19757: LD_INT 0
19759: PPUSH
19760: LD_INT 5
19762: PPUSH
19763: NOP4
19767: ST_TO_ADDR
// if Pocet > 0 then
19768: NOP4
19772: PUSH
19773: LD_INT 0
19775: GREATER
19776: IFFALSE 19790
// CreateCratesAnywhere ( Pocet , true ) ;
19778: NOP4
19782: PPUSH
19783: LD_INT 1
19785: PPUSH
19786: NOP4
// enable ;
19790: ENABLE
// end ;
19791: PPOPN 1
19793: END
// every 1 1$49 do
19794: GO 19796
19796: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$30 ) ) ;
19797: LD_INT 35
19799: PPUSH
19800: LD_INT 3150
19802: PPUSH
19803: NOP4
19807: PPUSH
19808: NOP4
// if ( BednyA <> 0 ) then
19812: NOP4
19816: PUSH
19817: LD_INT 0
19819: NONEQUAL
19820: IFFALSE 19881
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyArabi , true ) ;
19822: LD_INT 3
19824: PPUSH
19825: LD_INT 5
19827: PPUSH
19828: NOP4
19832: PPUSH
19833: NOP4
19837: PPUSH
19838: LD_INT 1
19840: PPUSH
19841: NOP4
// if ( BednyA <> - 1 ) then
19845: NOP4
19849: PUSH
19850: LD_INT 1
19852: NEG
19853: NONEQUAL
19854: IFFALSE 19870
// BednyA = BednyA - 1 ;
19856: NOP4
19860: PUSH
19861: NOP4
19865: PUSH
19866: LD_INT 1
19868: MINUS
19869: ST_TO_ADDR
// if ( BednyA <> 0 ) then
19870: NOP4
19874: PUSH
19875: LD_INT 0
19877: NONEQUAL
19878: IFFALSE 19881
// enable ;
19880: ENABLE
// end ; end ;
19881: END
// every 2 2$5 + 1 1$39 do
19882: GO 19884
19884: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
19885: LD_INT 35
19887: PPUSH
19888: LD_INT 4200
19890: PPUSH
19891: NOP4
19895: PPUSH
19896: NOP4
// if ( BednyRZ <> 0 ) then
19900: NOP4
19904: PUSH
19905: LD_INT 0
19907: NONEQUAL
19908: IFFALSE 19969
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveZ , true ) ;
19910: LD_INT 3
19912: PPUSH
19913: LD_INT 5
19915: PPUSH
19916: NOP4
19920: PPUSH
19921: NOP4
19925: PPUSH
19926: LD_INT 1
19928: PPUSH
19929: NOP4
// if ( BednyRZ <> - 1 ) then
19933: NOP4
19937: PUSH
19938: LD_INT 1
19940: NEG
19941: NONEQUAL
19942: IFFALSE 19958
// BednyRZ = BednyRZ - 1 ;
19944: NOP4
19948: PUSH
19949: NOP4
19953: PUSH
19954: LD_INT 1
19956: MINUS
19957: ST_TO_ADDR
// if ( BednyRZ <> 0 ) then
19958: NOP4
19962: PUSH
19963: LD_INT 0
19965: NONEQUAL
19966: IFFALSE 19969
// enable ;
19968: ENABLE
// end ; end ;
19969: END
// every 2 2$23 + 0 0$53 do
19970: GO 19972
19972: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
19973: LD_INT 35
19975: PPUSH
19976: LD_INT 4200
19978: PPUSH
19979: NOP4
19983: PPUSH
19984: NOP4
// if ( BednyRV <> 0 ) then
19988: NOP4
19992: PUSH
19993: LD_INT 0
19995: NONEQUAL
19996: IFFALSE 20057
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveV , true ) ;
19998: LD_INT 3
20000: PPUSH
20001: LD_INT 5
20003: PPUSH
20004: NOP4
20008: PPUSH
20009: NOP4
20013: PPUSH
20014: LD_INT 1
20016: PPUSH
20017: NOP4
// if ( BednyRV <> - 1 ) then
20021: NOP4
20025: PUSH
20026: LD_INT 1
20028: NEG
20029: NONEQUAL
20030: IFFALSE 20046
// BednyRV = BednyRV - 1 ;
20032: NOP4
20036: PUSH
20037: NOP4
20041: PUSH
20042: LD_INT 1
20044: MINUS
20045: ST_TO_ADDR
// if ( BednyRV <> 0 ) then
20046: NOP4
20050: PUSH
20051: LD_INT 0
20053: NONEQUAL
20054: IFFALSE 20057
// enable ;
20056: ENABLE
// end ; end ; end_of_file
20057: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin xavier_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
20058: NOP4
20062: PPUSH
20063: NOP4
20067: PPUSH
20068: NOP4
20072: PPUSH
20073: NOP4
20077: PPUSH
20078: NOP4
// yashin_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
20082: NOP4
20086: PPUSH
20087: NOP4
20091: PPUSH
20092: NOP4
20096: PPUSH
20097: NOP4
20101: PPUSH
20102: NOP4
// arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
20106: NOP4
20110: PPUSH
20111: NOP4
20115: PPUSH
20116: NOP4
20120: PPUSH
20121: NOP4
20125: PPUSH
20126: NOP4
// heike_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
20130: NOP4
20134: PPUSH
20135: NOP4
20139: PPUSH
20140: NOP4
20144: PPUSH
20145: NOP4
20149: PPUSH
20150: NOP4
// end ;
20154: PPOPN 4
20156: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin heike_BuildingCaptured ( Build , OrigSide , Eng ) ;
20157: NOP4
20161: PPUSH
20162: NOP4
20166: PPUSH
20167: NOP4
20171: PPUSH
20172: NOP4
// arabi_BuildingCaptured ( Build , OrigSide , Eng ) ;
20176: NOP4
20180: PPUSH
20181: NOP4
20185: PPUSH
20186: NOP4
20190: PPUSH
20191: NOP4
// end ;
20195: PPOPN 3
20197: END
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
20198: NOP4
20202: PPUSH
20203: NOP4
// heike_UnitDestroyed ( Un ) ;
20207: NOP4
20211: PPUSH
20212: NOP4
// arabi_UnitDestroyed ( Un ) ;
20216: NOP4
20220: PPUSH
20221: NOP4
// end ;
20225: PPOPN 1
20227: END
// on UnitGoesToRed ( Un ) do begin yashin_UnitGoesToRed ( Un ) ;
20228: NOP4
20232: PPUSH
20233: NOP4
// arabi_UnitGoesToRed ( Un ) ;
20237: NOP4
20241: PPUSH
20242: NOP4
// heike_UnitGoesToRed ( Un ) ;
20246: NOP4
20250: PPUSH
20251: NOP4
// end ;
20255: PPOPN 1
20257: END
// on VehicleConstructed ( Veh , Fact ) do begin arabi_VehicleConstructed ( Veh , Fact ) ;
20258: NOP4
20262: PPUSH
20263: NOP4
20267: PPUSH
20268: NOP4
// end ;
20272: PPOPN 2
20274: END
// on BuildingComplete ( Un ) do begin rusove_BuildingComplete ( Un ) ;
20275: NOP4
20279: PPUSH
20280: NOP4
// end ;
20284: PPOPN 1
20286: END
// on SailEvent ( Num ) do begin case Num of 101 :
20287: NOP4
20291: PUSH
20292: LD_INT 101
20294: DOUBLE
20295: EQUAL
20296: IFTRUE 20300
20298: GO 20307
20300: POP
// event_Patrola ; 102 , 103 , 103 :
20301: NOP4
20305: GO 20370
20307: LD_INT 102
20309: DOUBLE
20310: EQUAL
20311: IFTRUE 20327
20313: LD_INT 103
20315: DOUBLE
20316: EQUAL
20317: IFTRUE 20327
20319: LD_INT 103
20321: DOUBLE
20322: EQUAL
20323: IFTRUE 20327
20325: GO 20339
20327: POP
// event_OpravaHotova ( Num ) ; 111 :
20328: NOP4
20332: PPUSH
20333: NOP4
20337: GO 20370
20339: LD_INT 111
20341: DOUBLE
20342: EQUAL
20343: IFTRUE 20347
20345: GO 20354
20347: POP
// event_YashinUtoci ; 121 :
20348: NOP4
20352: GO 20370
20354: LD_INT 121
20356: DOUBLE
20357: EQUAL
20358: IFTRUE 20362
20360: GO 20369
20362: POP
// event_XavierPrisel ; end ;
20363: NOP4
20367: GO 20370
20369: POP
// end ;
20370: PPOPN 1
20372: END
// on Contact ( Side1 , Side2 ) do begin rusove_Contact ( Side1 , Side2 ) ;
20373: NOP4
20377: PPUSH
20378: NOP4
20382: PPUSH
20383: NOP4
// end ;
20387: PPOPN 2
20389: END
// on McAttackDone ( McId , Un ) do begin arabi_McAttackDone ( McId , Un ) ;
20390: NOP4
20394: PPUSH
20395: NOP4
20399: PPUSH
20400: NOP4
// end ;
20404: PPOPN 2
20406: END
// on StartHeal ( Un , Medic ) do begin heike_StartHeal ( Un , Medic ) ;
20407: NOP4
20411: PPUSH
20412: NOP4
20416: PPUSH
20417: NOP4
// end ;
20421: PPOPN 2
20423: END
// every 1 1$59 do
20424: GO 20426
20426: DISABLE
// begin RandomizeAll ;
20427: NOP4
// end ; end_of_file
20431: END
// export dif_BednyA , dif_BednyR1 , dif_BednyR2 ; export dif_HeikeBudovy , dif_HeikeAuta , dif_HeikeLidi ; export dif_HeikeovciLives , dif_HeikeovciPocet ; export dif_Cans , dif_Oil , dif_Siberit ; export dif_ArabiLevel , dif_VolnyArabi , dif_ObranciArabi ; export dif_UtokSkupina , dif_PstZbrane ; export dif_CasovacUtoku ; export dif_MaxKonvojCargo ; export function init_difficulty ; begin
20432: LD_INT 0
20434: PPUSH
// dif_BednyR1 = [ 25 , 20 , 15 ] ;
20435: NOP4
20439: PUSH
20440: LD_INT 25
20442: PUSH
20443: LD_INT 20
20445: PUSH
20446: LD_INT 15
20448: PUSH
20449: EMPTY
20450: LIST
20451: LIST
20452: LIST
20453: ST_TO_ADDR
// dif_BednyR2 = [ 30 , 25 , 20 ] ;
20454: NOP4
20458: PUSH
20459: LD_INT 30
20461: PUSH
20462: LD_INT 25
20464: PUSH
20465: LD_INT 20
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: LIST
20472: ST_TO_ADDR
// dif_BednyA = [ 25 , 35 , 60 ] ;
20473: NOP4
20477: PUSH
20478: LD_INT 25
20480: PUSH
20481: LD_INT 35
20483: PUSH
20484: LD_INT 60
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: LIST
20491: ST_TO_ADDR
// dif_HeikeBudovy = [ 8 , 5 , 2 ] ;
20492: NOP4
20496: PUSH
20497: LD_INT 8
20499: PUSH
20500: LD_INT 5
20502: PUSH
20503: LD_INT 2
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: LIST
20510: ST_TO_ADDR
// dif_HeikeAuta = [ 2 , 1 , 0 ] ;
20511: NOP4
20515: PUSH
20516: LD_INT 2
20518: PUSH
20519: LD_INT 1
20521: PUSH
20522: LD_INT 0
20524: PUSH
20525: EMPTY
20526: LIST
20527: LIST
20528: LIST
20529: ST_TO_ADDR
// dif_HeikeLidi = [ 2 , 1 , 0 ] ;
20530: NOP4
20534: PUSH
20535: LD_INT 2
20537: PUSH
20538: LD_INT 1
20540: PUSH
20541: LD_INT 0
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: LIST
20548: ST_TO_ADDR
// dif_HeikeovciLives = [ 750 , 900 , 1000 ] ;
20549: NOP4
20553: PUSH
20554: LD_INT 750
20556: PUSH
20557: LD_INT 900
20559: PUSH
20560: LD_INT 1000
20562: PUSH
20563: EMPTY
20564: LIST
20565: LIST
20566: LIST
20567: ST_TO_ADDR
// dif_HeikeovciPocet = [ 2 , 4 , 7 ] ;
20568: NOP4
20572: PUSH
20573: LD_INT 2
20575: PUSH
20576: LD_INT 4
20578: PUSH
20579: LD_INT 7
20581: PUSH
20582: EMPTY
20583: LIST
20584: LIST
20585: LIST
20586: ST_TO_ADDR
// dif_ArabiLevel = [ 3 , 5 , 7 ] ;
20587: NOP4
20591: PUSH
20592: LD_INT 3
20594: PUSH
20595: LD_INT 5
20597: PUSH
20598: LD_INT 7
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: ST_TO_ADDR
// dif_VolnyArabi = [ 2 , 5 , 10 ] ;
20606: NOP4
20610: PUSH
20611: LD_INT 2
20613: PUSH
20614: LD_INT 5
20616: PUSH
20617: LD_INT 10
20619: PUSH
20620: EMPTY
20621: LIST
20622: LIST
20623: LIST
20624: ST_TO_ADDR
// dif_ObranciArabi = [ 1 , 3 , 5 ] ;
20625: NOP4
20629: PUSH
20630: LD_INT 1
20632: PUSH
20633: LD_INT 3
20635: PUSH
20636: LD_INT 5
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: LIST
20643: ST_TO_ADDR
// dif_UtokSkupina = [ 3 , 4 , 6 ] ;
20644: NOP4
20648: PUSH
20649: LD_INT 3
20651: PUSH
20652: LD_INT 4
20654: PUSH
20655: LD_INT 6
20657: PUSH
20658: EMPTY
20659: LIST
20660: LIST
20661: LIST
20662: ST_TO_ADDR
// dif_Cans = [ 200 , 170 , 130 ] ;
20663: NOP4
20667: PUSH
20668: LD_INT 200
20670: PUSH
20671: LD_INT 170
20673: PUSH
20674: LD_INT 130
20676: PUSH
20677: EMPTY
20678: LIST
20679: LIST
20680: LIST
20681: ST_TO_ADDR
// dif_Oil = [ 100 , 50 , 0 ] ;
20682: NOP4
20686: PUSH
20687: LD_INT 100
20689: PUSH
20690: LD_INT 50
20692: PUSH
20693: LD_INT 0
20695: PUSH
20696: EMPTY
20697: LIST
20698: LIST
20699: LIST
20700: ST_TO_ADDR
// dif_Siberit = [ 100 , 100 , 100 ] ;
20701: NOP4
20705: PUSH
20706: LD_INT 100
20708: PUSH
20709: LD_INT 100
20711: PUSH
20712: LD_INT 100
20714: PUSH
20715: EMPTY
20716: LIST
20717: LIST
20718: LIST
20719: ST_TO_ADDR
// if VsevSaved then
20720: NOP4
20724: IFFALSE 20768
// dif_CasovacUtoku = [ [ 8 , 10 ] , [ 7 , 9 ] , [ 6 , 8 ] ] else
20726: NOP4
20730: PUSH
20731: LD_INT 8
20733: PUSH
20734: LD_INT 10
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: PUSH
20741: LD_INT 7
20743: PUSH
20744: LD_INT 9
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: PUSH
20751: LD_INT 6
20753: PUSH
20754: LD_INT 8
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: LIST
20765: ST_TO_ADDR
20766: GO 20816
// dif_CasovacUtoku = [ [ 8 , 8 , 7 ] , [ 8 , 7 , 6 ] , [ 4 , 5 ] ] ;
20768: NOP4
20772: PUSH
20773: LD_INT 8
20775: PUSH
20776: LD_INT 8
20778: PUSH
20779: LD_INT 7
20781: PUSH
20782: EMPTY
20783: LIST
20784: LIST
20785: LIST
20786: PUSH
20787: LD_INT 8
20789: PUSH
20790: LD_INT 7
20792: PUSH
20793: LD_INT 6
20795: PUSH
20796: EMPTY
20797: LIST
20798: LIST
20799: LIST
20800: PUSH
20801: LD_INT 4
20803: PUSH
20804: LD_INT 5
20806: PUSH
20807: EMPTY
20808: LIST
20809: LIST
20810: PUSH
20811: EMPTY
20812: LIST
20813: LIST
20814: LIST
20815: ST_TO_ADDR
// dif_PstZbrane = [ [ 20 , 40 , 80 , 100 ] , [ 30 , 50 , 80 , 100 ] , [ 30 , 60 , 75 , 100 ] ] ;
20816: NOP4
20820: PUSH
20821: LD_INT 20
20823: PUSH
20824: LD_INT 40
20826: PUSH
20827: LD_INT 80
20829: PUSH
20830: LD_INT 100
20832: PUSH
20833: EMPTY
20834: LIST
20835: LIST
20836: LIST
20837: LIST
20838: PUSH
20839: LD_INT 30
20841: PUSH
20842: LD_INT 50
20844: PUSH
20845: LD_INT 80
20847: PUSH
20848: LD_INT 100
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: LIST
20855: LIST
20856: PUSH
20857: LD_INT 30
20859: PUSH
20860: LD_INT 60
20862: PUSH
20863: LD_INT 75
20865: PUSH
20866: LD_INT 100
20868: PUSH
20869: EMPTY
20870: LIST
20871: LIST
20872: LIST
20873: LIST
20874: PUSH
20875: EMPTY
20876: LIST
20877: LIST
20878: LIST
20879: ST_TO_ADDR
// dif_MaxKonvojCargo = [ [ 5 , 200 , 100 , 0 ] , [ 5 , 160 , 60 , 0 ] , [ 5 , 50 , 50 , 0 ] ] ;
20880: NOP4
20884: PUSH
20885: LD_INT 5
20887: PUSH
20888: LD_INT 200
20890: PUSH
20891: LD_INT 100
20893: PUSH
20894: LD_INT 0
20896: PUSH
20897: EMPTY
20898: LIST
20899: LIST
20900: LIST
20901: LIST
20902: PUSH
20903: LD_INT 5
20905: PUSH
20906: LD_INT 160
20908: PUSH
20909: LD_INT 60
20911: PUSH
20912: LD_INT 0
20914: PUSH
20915: EMPTY
20916: LIST
20917: LIST
20918: LIST
20919: LIST
20920: PUSH
20921: LD_INT 5
20923: PUSH
20924: LD_INT 50
20926: PUSH
20927: LD_INT 50
20929: PUSH
20930: LD_INT 0
20932: PUSH
20933: EMPTY
20934: LIST
20935: LIST
20936: LIST
20937: LIST
20938: PUSH
20939: EMPTY
20940: LIST
20941: LIST
20942: LIST
20943: ST_TO_ADDR
// end ; end_of_file
20944: LD_VAR 0 1
20948: RET
// export function jdete_k_sobe ( Kdo , Kam ) ; begin
20949: LD_INT 0
20951: PPUSH
// ComMoveUnit ( Kdo , Kam ) ;
20952: NOP4
20956: PPUSH
20957: NOP4
20961: PPUSH
20962: NOP4
// while GetDistUnits ( Kdo , Kam ) > 3 do
20966: NOP4
20970: PPUSH
20971: NOP4
20975: PPUSH
20976: NOP4
20980: PUSH
20981: LD_INT 3
20983: GREATER
20984: IFFALSE 20995
// Wait ( 0 0$0.5 ) ;
20986: LD_INT 18
20988: PPUSH
20989: NOP4
20993: GO 20966
// AddComTurnUnit ( Kdo , Kam ) ;
20995: NOP4
20999: PPUSH
21000: NOP4
21004: PPUSH
21005: NOP4
// AddComTurnUnit ( Kam , Kdo ) ;
21009: NOP4
21013: PPUSH
21014: NOP4
21018: PPUSH
21019: NOP4
// end ;
21023: LD_VAR 0 3
21027: RET
// export function place_list ( List , Area ) ; var I ; begin
21028: LD_INT 0
21030: PPUSH
21031: PPUSH
// for I in List do
21032: NOP4
21036: PUSH
21037: NOP4
21041: PUSH
21042: FOR_IN
21043: IFFALSE 21064
// PlaceUnitArea ( I , Area , false ) ;
21045: NOP4
21049: PPUSH
21050: NOP4
21054: PPUSH
21055: LD_INT 0
21057: PPUSH
21058: NOP4
21062: GO 21042
21064: POP
21065: POP
// end ;
21066: LD_VAR 0 3
21070: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
21071: LD_INT 0
21073: PPUSH
21074: PPUSH
21075: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
21076: NOP4
21080: PUSH
21081: LD_INT 22
21083: PUSH
21084: NOP4
21088: PUSH
21089: EMPTY
21090: LIST
21091: LIST
21092: PUSH
21093: EMPTY
21094: LIST
21095: PPUSH
21096: NOP4
21100: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21101: NOP4
21105: PUSH
21106: NOP4
21110: PUSH
21111: FOR_IN
21112: IFFALSE 21144
// if See ( Kdo , Jednotka ) then
21114: NOP4
21118: PPUSH
21119: NOP4
21123: PPUSH
21124: NOP4
21128: IFFALSE 21142
// begin Result = true ;
21130: NOP4
21134: PUSH
21135: LD_INT 1
21137: ST_TO_ADDR
// exit ;
21138: POP
21139: POP
21140: GO 21154
// end ;
21142: GO 21111
21144: POP
21145: POP
// Result = false ;
21146: NOP4
21150: PUSH
21151: LD_INT 0
21153: ST_TO_ADDR
// end ;
21154: LD_VAR 0 3
21158: RET
// export function vidi_strana_jednotky ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
21159: LD_INT 0
21161: PPUSH
21162: PPUSH
21163: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
21164: NOP4
21168: PUSH
21169: LD_INT 22
21171: PUSH
21172: NOP4
21176: PUSH
21177: EMPTY
21178: LIST
21179: LIST
21180: PUSH
21181: EMPTY
21182: LIST
21183: PPUSH
21184: NOP4
21188: ST_TO_ADDR
// Result = [ ] ;
21189: NOP4
21193: PUSH
21194: EMPTY
21195: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21196: NOP4
21200: PUSH
21201: NOP4
21205: PUSH
21206: FOR_IN
21207: IFFALSE 21246
// if See ( Kdo , Jednotka ) then
21209: NOP4
21213: PPUSH
21214: NOP4
21218: PPUSH
21219: NOP4
21223: IFFALSE 21244
// Result = Result union [ Jednotka ] ;
21225: NOP4
21229: PUSH
21230: NOP4
21234: PUSH
21235: NOP4
21239: PUSH
21240: EMPTY
21241: LIST
21242: UNION
21243: ST_TO_ADDR
21244: GO 21206
21246: POP
21247: POP
// end ;
21248: LD_VAR 0 3
21252: RET
// export function jednotky_blizko ( Kdo , Koho , Dalka ) ; var KohoJednotky , Jednotka ; begin
21253: LD_INT 0
21255: PPUSH
21256: PPUSH
21257: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
21258: NOP4
21262: PUSH
21263: LD_INT 22
21265: PUSH
21266: NOP4
21270: PUSH
21271: EMPTY
21272: LIST
21273: LIST
21274: PUSH
21275: EMPTY
21276: LIST
21277: PPUSH
21278: NOP4
21282: ST_TO_ADDR
// Result = [ ] ;
21283: NOP4
21287: PUSH
21288: EMPTY
21289: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21290: NOP4
21294: PUSH
21295: NOP4
21299: PUSH
21300: FOR_IN
21301: IFFALSE 21346
// if GetDistUnits ( Kdo , Jednotka ) <= Dalka then
21303: NOP4
21307: PPUSH
21308: NOP4
21312: PPUSH
21313: NOP4
21317: PUSH
21318: NOP4
21322: LESSEQUAL
21323: IFFALSE 21344
// Result = Result union [ Jednotka ] ;
21325: NOP4
21329: PUSH
21330: NOP4
21334: PUSH
21335: NOP4
21339: PUSH
21340: EMPTY
21341: LIST
21342: UNION
21343: ST_TO_ADDR
21344: GO 21300
21346: POP
21347: POP
// end ;
21348: LD_VAR 0 4
21352: RET
// export function nahoda_seznam ( Seznam ) ; begin
21353: LD_INT 0
21355: PPUSH
// if Seznam then
21356: NOP4
21360: IFFALSE 21388
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
21362: NOP4
21366: PUSH
21367: NOP4
21371: PUSH
21372: LD_INT 1
21374: PPUSH
21375: NOP4
21379: PPUSH
21380: NOP4
21384: ARRAY
21385: ST_TO_ADDR
21386: GO 21396
// Result = 0 ;
21388: NOP4
21392: PUSH
21393: LD_INT 0
21395: ST_TO_ADDR
// end ;
21396: LD_VAR 0 2
21400: RET
// export function bez_opic ( List ) ; var Opice ; begin
21401: LD_INT 0
21403: PPUSH
21404: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
21405: NOP4
21409: PUSH
21410: NOP4
21414: PPUSH
21415: LD_INT 2
21417: PUSH
21418: LD_INT 25
21420: PUSH
21421: LD_INT 12
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 25
21430: PUSH
21431: LD_INT 15
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: PUSH
21438: LD_INT 25
21440: PUSH
21441: LD_INT 16
21443: PUSH
21444: EMPTY
21445: LIST
21446: LIST
21447: PUSH
21448: LD_INT 25
21450: PUSH
21451: LD_INT 17
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: PUSH
21458: EMPTY
21459: LIST
21460: LIST
21461: LIST
21462: LIST
21463: LIST
21464: PUSH
21465: EMPTY
21466: LIST
21467: PPUSH
21468: NOP4
21472: ST_TO_ADDR
// Result = List diff Opice ;
21473: NOP4
21477: PUSH
21478: NOP4
21482: PUSH
21483: NOP4
21487: DIFF
21488: ST_TO_ADDR
// end ; end_of_file
21489: LD_VAR 0 2
21493: RET
// function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
21494: LD_INT 0
21496: PPUSH
21497: PPUSH
21498: PPUSH
// Result = [ ] ;
21499: NOP4
21503: PUSH
21504: EMPTY
21505: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
21506: LD_ADDR_OWVAR 21
21510: PUSH
21511: LD_INT 0
21513: ST_TO_ADDR
// UC_side = side_neutral ;
21514: LD_ADDR_OWVAR 20
21518: PUSH
21519: NOP4
21523: ST_TO_ADDR
// HC_Class = Cls ;
21524: LD_ADDR_OWVAR 28
21528: PUSH
21529: NOP4
21533: ST_TO_ADDR
// HC_Name =  ;
21534: LD_ADDR_OWVAR 26
21538: PUSH
21539: LD_STRING 
21541: ST_TO_ADDR
// for i = 1 to Cnt do
21542: NOP4
21546: PUSH
21547: DOUBLE
21548: LD_INT 1
21550: DEC
21551: ST_TO_ADDR
21552: NOP4
21556: PUSH
21557: FOR_TO
21558: IFFALSE 21608
// begin h = CreateHuman ;
21560: NOP4
21564: PUSH
21565: NOP4
21569: ST_TO_ADDR
// Result = Result union [ h ] ;
21570: NOP4
21574: PUSH
21575: NOP4
21579: PUSH
21580: NOP4
21584: PUSH
21585: EMPTY
21586: LIST
21587: UNION
21588: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
21589: NOP4
21593: PPUSH
21594: NOP4
21598: PPUSH
21599: LD_INT 0
21601: PPUSH
21602: NOP4
// end ;
21606: GO 21557
21608: POP
21609: POP
// end ;
21610: LD_VAR 0 4
21614: RET
// export function init_nature ; begin
21615: LD_INT 0
21617: PPUSH
// create_nature ( CLASS_TIGER , Rand ( 1 , 3 ) , Les ) ;
21618: LD_INT 14
21620: PPUSH
21621: LD_INT 1
21623: PPUSH
21624: LD_INT 3
21626: PPUSH
21627: NOP4
21631: PPUSH
21632: NOP4
21636: PPUSH
21637: NOP4
// create_nature ( CLASS_APEMAN , Rand ( 5 , 10 ) - Difficulty , Les ) ;
21641: LD_INT 12
21643: PPUSH
21644: LD_INT 5
21646: PPUSH
21647: LD_INT 10
21649: PPUSH
21650: NOP4
21654: PUSH
21655: NOP4
21659: MINUS
21660: PPUSH
21661: NOP4
21665: PPUSH
21666: NOP4
// end ; end_of_file
21670: LD_VAR 0 1
21674: RET
// export function dialog_Start ; begin
21675: LD_INT 0
21677: PPUSH
// SayRadio ( Platonov , DStart-Pla-1 ) ;
21678: NOP4
21682: PPUSH
21683: LD_STRING DStart-Pla-1
21685: PPUSH
21686: NOP4
// end ;
21690: LD_VAR 0 1
21694: RET
// export function dialog_StartVS ; begin
21695: LD_INT 0
21697: PPUSH
// SayRadio ( Platonov , DStartVS-Pla-1 ) ;
21698: NOP4
21702: PPUSH
21703: LD_STRING DStartVS-Pla-1
21705: PPUSH
21706: NOP4
// end ;
21710: LD_VAR 0 1
21714: RET
// export function dialog_StartNV ; begin
21715: LD_INT 0
21717: PPUSH
// SayRadio ( Platonov , DStartNV-Pla-1 ) ;
21718: NOP4
21722: PPUSH
21723: LD_STRING DStartNV-Pla-1
21725: PPUSH
21726: NOP4
// end ;
21730: LD_VAR 0 1
21734: RET
// export function dialog_Start2 ; begin
21735: LD_INT 0
21737: PPUSH
// SayRadio ( Platonov , DStart2-Pla-1 ) ;
21738: NOP4
21742: PPUSH
21743: LD_STRING DStart2-Pla-1
21745: PPUSH
21746: NOP4
// Say ( Burlak , DStart2-Bur-1 ) ;
21750: NOP4
21754: PPUSH
21755: LD_STRING DStart2-Bur-1
21757: PPUSH
21758: NOP4
// end ;
21762: LD_VAR 0 1
21766: RET
// export function dialog_MeetVsevolodVS ; begin
21767: LD_INT 0
21769: PPUSH
// Say ( Burlak , DMeetVsevolodVS-Bur-1 ) ;
21770: NOP4
21774: PPUSH
21775: LD_STRING DMeetVsevolodVS-Bur-1
21777: PPUSH
21778: NOP4
// Say ( Vsevolod , DMeetVsevolodVS-Vse-1 ) ;
21782: NOP4
21786: PPUSH
21787: LD_STRING DMeetVsevolodVS-Vse-1
21789: PPUSH
21790: NOP4
// Say ( Burlak , DMeetVsevolodVS-Bur-2 ) ;
21794: NOP4
21798: PPUSH
21799: LD_STRING DMeetVsevolodVS-Bur-2
21801: PPUSH
21802: NOP4
// Say ( Vsevolod , DMeetVsevolodVS-Vse-2 ) ;
21806: NOP4
21810: PPUSH
21811: LD_STRING DMeetVsevolodVS-Vse-2
21813: PPUSH
21814: NOP4
// end ;
21818: LD_VAR 0 1
21822: RET
// export function dialog_StasisVS ; begin
21823: LD_INT 0
21825: PPUSH
// if Titov and IsOK ( Titov ) then
21826: NOP4
21830: PUSH
21831: NOP4
21835: PPUSH
21836: NOP4
21840: AND
21841: IFFALSE 21857
// Say ( Titov , DStasisVS-Tit-1 ) else
21843: NOP4
21847: PPUSH
21848: LD_STRING DStasisVS-Tit-1
21850: PPUSH
21851: NOP4
21855: GO 21869
// Say ( Yelena , DStasisVS-Kir-1 ) ;
21857: NOP4
21861: PPUSH
21862: LD_STRING DStasisVS-Kir-1
21864: PPUSH
21865: NOP4
// Say ( Burlak , DStasisVS-Bur-1 ) ;
21869: NOP4
21873: PPUSH
21874: LD_STRING DStasisVS-Bur-1
21876: PPUSH
21877: NOP4
// if Titov and IsOK ( Titov ) then
21881: NOP4
21885: PUSH
21886: NOP4
21890: PPUSH
21891: NOP4
21895: AND
21896: IFFALSE 21912
// Say ( Titov , DStasisVS-Tit-2 ) else
21898: NOP4
21902: PPUSH
21903: LD_STRING DStasisVS-Tit-2
21905: PPUSH
21906: NOP4
21910: GO 21924
// Say ( Yelena , DStasisVS-Kir-2 ) ;
21912: NOP4
21916: PPUSH
21917: LD_STRING DStasisVS-Kir-2
21919: PPUSH
21920: NOP4
// Say ( Burlak , DStasisVS-Bur-2 ) ;
21924: NOP4
21928: PPUSH
21929: LD_STRING DStasisVS-Bur-2
21931: PPUSH
21932: NOP4
// wait ( 0 0$3 ) ;
21936: LD_INT 105
21938: PPUSH
21939: NOP4
// SayRadio ( Popov , DStasisVS-Pop-2 ) ;
21943: NOP4
21947: PPUSH
21948: LD_STRING DStasisVS-Pop-2
21950: PPUSH
21951: NOP4
// if Gleb and IsOK ( Gleb ) then
21955: NOP4
21959: PUSH
21960: NOP4
21964: PPUSH
21965: NOP4
21969: AND
21970: IFFALSE 21984
// Say ( Gleb , DStasisVS-Glb-2 ) ;
21972: NOP4
21976: PPUSH
21977: LD_STRING DStasisVS-Glb-2
21979: PPUSH
21980: NOP4
// end ;
21984: LD_VAR 0 1
21988: RET
// export function dialog_SeviSaved ; begin
21989: LD_INT 0
21991: PPUSH
// Say ( Burlak , DSeviSaved-Bur-1 ) ;
21992: NOP4
21996: PPUSH
21997: LD_STRING DSeviSaved-Bur-1
21999: PPUSH
22000: NOP4
// Say ( Vsevolod , DSeviSaved-Vse-1 ) ;
22004: NOP4
22008: PPUSH
22009: LD_STRING DSeviSaved-Vse-1
22011: PPUSH
22012: NOP4
// Say ( Burlak , DSeviSaved-Bur-2 ) ;
22016: NOP4
22020: PPUSH
22021: LD_STRING DSeviSaved-Bur-2
22023: PPUSH
22024: NOP4
// Say ( Vsevolod , DSeviSaved-Vse-2 ) ;
22028: NOP4
22032: PPUSH
22033: LD_STRING DSeviSaved-Vse-2
22035: PPUSH
22036: NOP4
// end ;
22040: LD_VAR 0 1
22044: RET
// export function dialog_MeetXavier ; begin
22045: LD_INT 0
22047: PPUSH
// Say ( Xavier , DMeetXavier-Xav-1 ) ;
22048: NOP4
22052: PPUSH
22053: LD_STRING DMeetXavier-Xav-1
22055: PPUSH
22056: NOP4
// Say ( Yelena , DMeetXavier-Kir-1 ) ;
22060: NOP4
22064: PPUSH
22065: LD_STRING DMeetXavier-Kir-1
22067: PPUSH
22068: NOP4
// Say ( Xavier , DMeetXavier-Xav-2 ) ;
22072: NOP4
22076: PPUSH
22077: LD_STRING DMeetXavier-Xav-2
22079: PPUSH
22080: NOP4
// end ;
22084: LD_VAR 0 1
22088: RET
// export function query_Xavier ; begin
22089: LD_INT 0
22091: PPUSH
// Result = Query ( QXavier ) ;
22092: NOP4
22096: PUSH
22097: LD_STRING QXavier
22099: PPUSH
22100: NOP4
22104: ST_TO_ADDR
// end ;
22105: LD_VAR 0 1
22109: RET
// export function dialog_QrXavier1 ; begin
22110: LD_INT 0
22112: PPUSH
// Say ( Burlak , DQrXavier#1-Bur-1 ) ;
22113: NOP4
22117: PPUSH
22118: LD_STRING DQrXavier#1-Bur-1
22120: PPUSH
22121: NOP4
// Say ( Yelena , DQrXavier#1-Kir-1 ) ;
22125: NOP4
22129: PPUSH
22130: LD_STRING DQrXavier#1-Kir-1
22132: PPUSH
22133: NOP4
// Say ( Xavier , DQrXavier#1-Xav-1 ) ;
22137: NOP4
22141: PPUSH
22142: LD_STRING DQrXavier#1-Xav-1
22144: PPUSH
22145: NOP4
// Say ( Yelena , DQrXavier#1-Kir-2 ) ;
22149: NOP4
22153: PPUSH
22154: LD_STRING DQrXavier#1-Kir-2
22156: PPUSH
22157: NOP4
// Say ( Xavier , DQrXavier#1-Xav-2 ) ;
22161: NOP4
22165: PPUSH
22166: LD_STRING DQrXavier#1-Xav-2
22168: PPUSH
22169: NOP4
// Say ( Yelena , DQrXavier#1-Kir-3 ) ;
22173: NOP4
22177: PPUSH
22178: LD_STRING DQrXavier#1-Kir-3
22180: PPUSH
22181: NOP4
// Say ( Xavier , DQrXavier#1-Xav-3 ) ;
22185: NOP4
22189: PPUSH
22190: LD_STRING DQrXavier#1-Xav-3
22192: PPUSH
22193: NOP4
// Say ( Yelena , DQrXavier#1-Kir-4 ) ;
22197: NOP4
22201: PPUSH
22202: LD_STRING DQrXavier#1-Kir-4
22204: PPUSH
22205: NOP4
// if Gleb and IsOK ( Gleb ) then
22209: NOP4
22213: PUSH
22214: NOP4
22218: PPUSH
22219: NOP4
22223: AND
22224: IFFALSE 22238
// Say ( Gleb , DQrXavier#1-Glb-4 ) ;
22226: NOP4
22230: PPUSH
22231: LD_STRING DQrXavier#1-Glb-4
22233: PPUSH
22234: NOP4
// end ;
22238: LD_VAR 0 1
22242: RET
// export function dialog_QrXavier2 ; begin
22243: LD_INT 0
22245: PPUSH
// Say ( Burlak , DQrXavier#2-Bur-1 ) ;
22246: NOP4
22250: PPUSH
22251: LD_STRING DQrXavier#2-Bur-1
22253: PPUSH
22254: NOP4
// Say ( Yelena , DQrXavier#2-Kir-1 ) ;
22258: NOP4
22262: PPUSH
22263: LD_STRING DQrXavier#2-Kir-1
22265: PPUSH
22266: NOP4
// Say ( Xavier , DQrXavier#2-Xav-1 ) ;
22270: NOP4
22274: PPUSH
22275: LD_STRING DQrXavier#2-Xav-1
22277: PPUSH
22278: NOP4
// Say ( Yelena , DQrXavier#2-Kir-2 ) ;
22282: NOP4
22286: PPUSH
22287: LD_STRING DQrXavier#2-Kir-2
22289: PPUSH
22290: NOP4
// Say ( Xavier , DQrXavier#2-Xav-2 ) ;
22294: NOP4
22298: PPUSH
22299: LD_STRING DQrXavier#2-Xav-2
22301: PPUSH
22302: NOP4
// Say ( Yelena , DQrXavier#2-Kir-3 ) ;
22306: NOP4
22310: PPUSH
22311: LD_STRING DQrXavier#2-Kir-3
22313: PPUSH
22314: NOP4
// Say ( Xavier , DQrXavier#2-Xav-3 ) ;
22318: NOP4
22322: PPUSH
22323: LD_STRING DQrXavier#2-Xav-3
22325: PPUSH
22326: NOP4
// Say ( Yelena , DQrXavier#2-Kir-4 ) ;
22330: NOP4
22334: PPUSH
22335: LD_STRING DQrXavier#2-Kir-4
22337: PPUSH
22338: NOP4
// Say ( Xavier , DQrXavier#2-Xav-4 ) ;
22342: NOP4
22346: PPUSH
22347: LD_STRING DQrXavier#2-Xav-4
22349: PPUSH
22350: NOP4
// Say ( Yelena , DQrXavier#2-Kir-5 ) ;
22354: NOP4
22358: PPUSH
22359: LD_STRING DQrXavier#2-Kir-5
22361: PPUSH
22362: NOP4
// if Gleb and IsOK ( Gleb ) then
22366: NOP4
22370: PUSH
22371: NOP4
22375: PPUSH
22376: NOP4
22380: AND
22381: IFFALSE 22395
// Say ( Gleb , DQrXavier#2-Glb-5 ) ;
22383: NOP4
22387: PPUSH
22388: LD_STRING DQrXavier#2-Glb-5
22390: PPUSH
22391: NOP4
// end ;
22395: LD_VAR 0 1
22399: RET
// export function dialog_PointXavier ; begin
22400: LD_INT 0
22402: PPUSH
// if IsOk ( Yelena ) then
22403: NOP4
22407: PPUSH
22408: NOP4
22412: IFFALSE 22438
// begin Say ( Xavier , DPointXavier-Xav-1 ) ;
22414: NOP4
22418: PPUSH
22419: LD_STRING DPointXavier-Xav-1
22421: PPUSH
22422: NOP4
// Say ( Yelena , DPointXavier-Kir-1 ) ;
22426: NOP4
22430: PPUSH
22431: LD_STRING DPointXavier-Kir-1
22433: PPUSH
22434: NOP4
// end ; Say ( Xavier , DPointXavier-Xav-2 ) ;
22438: NOP4
22442: PPUSH
22443: LD_STRING DPointXavier-Xav-2
22445: PPUSH
22446: NOP4
// end ;
22450: LD_VAR 0 1
22454: RET
// export function query_QActivateXavier ; begin
22455: LD_INT 0
22457: PPUSH
// Result = Query ( QActivateXavier ) ;
22458: NOP4
22462: PUSH
22463: LD_STRING QActivateXavier
22465: PPUSH
22466: NOP4
22470: ST_TO_ADDR
// end ;
22471: LD_VAR 0 1
22475: RET
// export function dialog_QrActivateXavier1 ; begin
22476: LD_INT 0
22478: PPUSH
// Say ( Burlak , DQrActivateXavier#1-Bur-1 ) ;
22479: NOP4
22483: PPUSH
22484: LD_STRING DQrActivateXavier#1-Bur-1
22486: PPUSH
22487: NOP4
// end ;
22491: LD_VAR 0 1
22495: RET
// export function dialog_QrActivateXavier2 ; begin
22496: LD_INT 0
22498: PPUSH
// Say ( Burlak , DQrActivateXavier#2-Bur-1 ) ;
22499: NOP4
22503: PPUSH
22504: LD_STRING DQrActivateXavier#2-Bur-1
22506: PPUSH
22507: NOP4
// end ;
22511: LD_VAR 0 1
22515: RET
// export function dialog_YashinArrives ; begin
22516: LD_INT 0
22518: PPUSH
// Say ( Yashin , DYashinArrives-Yas-1 ) ;
22519: NOP4
22523: PPUSH
22524: LD_STRING DYashinArrives-Yas-1
22526: PPUSH
22527: NOP4
// if VsevSaved and IsOk ( Vsevolod ) then
22531: NOP4
22535: PUSH
22536: NOP4
22540: PPUSH
22541: NOP4
22545: AND
22546: IFFALSE 22562
// Say ( Vsevolod , DYashinArrives-Vse-1 ) else
22548: NOP4
22552: PPUSH
22553: LD_STRING DYashinArrives-Vse-1
22555: PPUSH
22556: NOP4
22560: GO 22574
// Say ( Burlak , DYashinArrives-Bur-1 ) ;
22562: NOP4
22566: PPUSH
22567: LD_STRING DYashinArrives-Bur-1
22569: PPUSH
22570: NOP4
// Say ( Yashin , DYashinArrives-Yas-2 ) ;
22574: NOP4
22578: PPUSH
22579: LD_STRING DYashinArrives-Yas-2
22581: PPUSH
22582: NOP4
// if VsevSaved and IsOk ( Vsevolod ) then
22586: NOP4
22590: PUSH
22591: NOP4
22595: PPUSH
22596: NOP4
22600: AND
22601: IFFALSE 22641
// begin Say ( Vsevolod , DYashinArrives-Vse-2 ) ;
22603: NOP4
22607: PPUSH
22608: LD_STRING DYashinArrives-Vse-2
22610: PPUSH
22611: NOP4
// Say ( Yashin , DYashinArrives-Yas-3 ) ;
22615: NOP4
22619: PPUSH
22620: LD_STRING DYashinArrives-Yas-3
22622: PPUSH
22623: NOP4
// Say ( Vsevolod , DYashinArrives-Vse-3 ) ;
22627: NOP4
22631: PPUSH
22632: LD_STRING DYashinArrives-Vse-3
22634: PPUSH
22635: NOP4
// end else
22639: GO 22689
// begin Say ( Burlak , DYashinArrives-Bur-3 ) ;
22641: NOP4
22645: PPUSH
22646: LD_STRING DYashinArrives-Bur-3
22648: PPUSH
22649: NOP4
// Say ( Yashin , DYashinArrives-Yas-4 ) ;
22653: NOP4
22657: PPUSH
22658: LD_STRING DYashinArrives-Yas-4
22660: PPUSH
22661: NOP4
// Say ( Burlak , DYashinArrives-Bur-4 ) ;
22665: NOP4
22669: PPUSH
22670: LD_STRING DYashinArrives-Bur-4
22672: PPUSH
22673: NOP4
// Say ( Yashin , DYashinArrives-Yas-5 ) ;
22677: NOP4
22681: PPUSH
22682: LD_STRING DYashinArrives-Yas-5
22684: PPUSH
22685: NOP4
// end ; Say ( Burlak , DYashinArrives-Bur-5 ) ;
22689: NOP4
22693: PPUSH
22694: LD_STRING DYashinArrives-Bur-5
22696: PPUSH
22697: NOP4
// Say ( Yashin , DYashinArrives-Yas-6 ) ;
22701: NOP4
22705: PPUSH
22706: LD_STRING DYashinArrives-Yas-6
22708: PPUSH
22709: NOP4
// Say ( Burlak , DYashinArrives-Bur-6 ) ;
22713: NOP4
22717: PPUSH
22718: LD_STRING DYashinArrives-Bur-6
22720: PPUSH
22721: NOP4
// Say ( Yashin , DYashinArrives-Yas-7 ) ;
22725: NOP4
22729: PPUSH
22730: LD_STRING DYashinArrives-Yas-7
22732: PPUSH
22733: NOP4
// end ;
22737: LD_VAR 0 1
22741: RET
// export function query_YashinHelp ; begin
22742: LD_INT 0
22744: PPUSH
// Result = Query ( QYashinHelp ) ;
22745: NOP4
22749: PUSH
22750: LD_STRING QYashinHelp
22752: PPUSH
22753: NOP4
22757: ST_TO_ADDR
// end ;
22758: LD_VAR 0 1
22762: RET
// export function query_YashinHelpNB ; begin
22763: LD_INT 0
22765: PPUSH
// Result = SelectiveQuery ( QYashinHelp , [ 2 , 3 ] ) ;
22766: NOP4
22770: PUSH
22771: LD_STRING QYashinHelp
22773: PPUSH
22774: LD_INT 2
22776: PUSH
22777: LD_INT 3
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: PPUSH
22784: NOP4
22788: ST_TO_ADDR
// end ;
22789: LD_VAR 0 1
22793: RET
// export function dialog_QrYashinHelp1 ; begin
22794: LD_INT 0
22796: PPUSH
// Say ( Burlak , DQrYashinHelp#1-Bur-1 ) ;
22797: NOP4
22801: PPUSH
22802: LD_STRING DQrYashinHelp#1-Bur-1
22804: PPUSH
22805: NOP4
// Say ( Yashin , DQrYashinHelp#1-Yas-1 ) ;
22809: NOP4
22813: PPUSH
22814: LD_STRING DQrYashinHelp#1-Yas-1
22816: PPUSH
22817: NOP4
// Say ( Burlak , DQrYashinHelp#1-Bur-2 ) ;
22821: NOP4
22825: PPUSH
22826: LD_STRING DQrYashinHelp#1-Bur-2
22828: PPUSH
22829: NOP4
// Say ( Yashin , DQrYashinHelp#1-Yas-2 ) ;
22833: NOP4
22837: PPUSH
22838: LD_STRING DQrYashinHelp#1-Yas-2
22840: PPUSH
22841: NOP4
// end ;
22845: LD_VAR 0 1
22849: RET
// export function dialog_QrYashinHelp2 ; begin
22850: LD_INT 0
22852: PPUSH
// Say ( Burlak , DQrYashinHelp#2-Bur-1 ) ;
22853: NOP4
22857: PPUSH
22858: LD_STRING DQrYashinHelp#2-Bur-1
22860: PPUSH
22861: NOP4
// Say ( Yashin , DQrYashinHelp#2-Yas-1 ) ;
22865: NOP4
22869: PPUSH
22870: LD_STRING DQrYashinHelp#2-Yas-1
22872: PPUSH
22873: NOP4
// end ;
22877: LD_VAR 0 1
22881: RET
// export function dialog_QrYashinHelp3 ; begin
22882: LD_INT 0
22884: PPUSH
// Say ( Burlak , DQrYashinHelp#3-Bur-1 ) ;
22885: NOP4
22889: PPUSH
22890: LD_STRING DQrYashinHelp#3-Bur-1
22892: PPUSH
22893: NOP4
// Say ( Yashin , DQrYashinHelp#3-Yas-1 ) ;
22897: NOP4
22901: PPUSH
22902: LD_STRING DQrYashinHelp#3-Yas-1
22904: PPUSH
22905: NOP4
// end ;
22909: LD_VAR 0 1
22913: RET
// var BylHint ; export function dialog_YashinLeave ; begin
22914: LD_INT 0
22916: PPUSH
// Say ( Yashin , DYashinLeave-Yas-1 ) ;
22917: NOP4
22921: PPUSH
22922: LD_STRING DYashinLeave-Yas-1
22924: PPUSH
22925: NOP4
// Say ( Burlak , DYashinLeave-Bur-1 ) ;
22929: NOP4
22933: PPUSH
22934: LD_STRING DYashinLeave-Bur-1
22936: PPUSH
22937: NOP4
// if not BylHint then
22941: NOP4
22945: NOT
22946: IFFALSE 22963
// begin Hint ( YashinVeh ) ;
22948: LD_STRING YashinVeh
22950: PPUSH
22951: NOP4
// BylHint = true ;
22955: NOP4
22959: PUSH
22960: LD_INT 1
22962: ST_TO_ADDR
// end ; end ;
22963: LD_VAR 0 1
22967: RET
// export function dialog_YashinAttack ; begin
22968: LD_INT 0
22970: PPUSH
// Say ( Burlak , DYashinAttack-Bur-1 ) ;
22971: NOP4
22975: PPUSH
22976: LD_STRING DYashinAttack-Bur-1
22978: PPUSH
22979: NOP4
// end ;
22983: LD_VAR 0 1
22987: RET
// export function dialog_HeikeObj ; begin
22988: LD_INT 0
22990: PPUSH
// SayRadio ( Popov , DHeikeObj-Pop-1 ) ;
22991: NOP4
22995: PPUSH
22996: LD_STRING DHeikeObj-Pop-1
22998: PPUSH
22999: NOP4
// Say ( Burlak , DHeikeObj-Bur-1 ) ;
23003: NOP4
23007: PPUSH
23008: LD_STRING DHeikeObj-Bur-1
23010: PPUSH
23011: NOP4
// SayRadio ( Popov , DHeikeObj-Pop-2 ) ;
23015: NOP4
23019: PPUSH
23020: LD_STRING DHeikeObj-Pop-2
23022: PPUSH
23023: NOP4
// Say ( Burlak , DHeikeObj-Bur-2 ) ;
23027: NOP4
23031: PPUSH
23032: LD_STRING DHeikeObj-Bur-2
23034: PPUSH
23035: NOP4
// end ;
23039: LD_VAR 0 1
23043: RET
// export function dialog_HeikeCapt ; begin
23044: LD_INT 0
23046: PPUSH
// Say ( Heike , DHeikeCapt-Hke-1 ) ;
23047: NOP4
23051: PPUSH
23052: LD_STRING DHeikeCapt-Hke-1
23054: PPUSH
23055: NOP4
// Say ( Burlak , DHeikeCapt-Bur-1 ) ;
23059: NOP4
23063: PPUSH
23064: LD_STRING DHeikeCapt-Bur-1
23066: PPUSH
23067: NOP4
// Say ( Heike , DHeikeCapt-Hke-2 ) ;
23071: NOP4
23075: PPUSH
23076: LD_STRING DHeikeCapt-Hke-2
23078: PPUSH
23079: NOP4
// end ; end_of_file
23083: LD_VAR 0 1
23087: RET
// every 0 0$2 + 0 0$0.1 do
23088: GO 23090
23090: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
23091: LD_INT 22
23093: PUSH
23094: LD_INT 3
23096: PUSH
23097: EMPTY
23098: LIST
23099: LIST
23100: PUSH
23101: LD_INT 2
23103: PUSH
23104: LD_INT 25
23106: PUSH
23107: LD_INT 12
23109: PUSH
23110: EMPTY
23111: LIST
23112: LIST
23113: PUSH
23114: LD_INT 25
23116: PUSH
23117: LD_INT 16
23119: PUSH
23120: EMPTY
23121: LIST
23122: LIST
23123: PUSH
23124: LD_INT 25
23126: PUSH
23127: LD_INT 15
23129: PUSH
23130: EMPTY
23131: LIST
23132: LIST
23133: PUSH
23134: LD_INT 25
23136: PUSH
23137: LD_INT 17
23139: PUSH
23140: EMPTY
23141: LIST
23142: LIST
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: LIST
23148: LIST
23149: LIST
23150: PUSH
23151: EMPTY
23152: LIST
23153: LIST
23154: PPUSH
23155: NOP4
23159: PUSH
23160: LD_INT 22
23162: PUSH
23163: LD_INT 3
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: PUSH
23170: LD_INT 21
23172: PUSH
23173: LD_INT 1
23175: PUSH
23176: EMPTY
23177: LIST
23178: LIST
23179: PUSH
23180: LD_INT 3
23182: PUSH
23183: LD_INT 2
23185: PUSH
23186: LD_INT 25
23188: PUSH
23189: LD_INT 12
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: PUSH
23196: LD_INT 25
23198: PUSH
23199: LD_INT 16
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: PUSH
23206: LD_INT 25
23208: PUSH
23209: LD_INT 15
23211: PUSH
23212: EMPTY
23213: LIST
23214: LIST
23215: PUSH
23216: LD_INT 25
23218: PUSH
23219: LD_INT 17
23221: PUSH
23222: EMPTY
23223: LIST
23224: LIST
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: LIST
23241: PPUSH
23242: NOP4
23246: GREATER
23247: IFFALSE 23258
// begin SetAchievement ( ACH_POTA ) ;
23249: LD_STRING ACH_POTA
23251: PPUSH
23252: NOP4
// exit ;
23256: GO 23259
// end ; enable ;
23258: ENABLE
// end ;
23259: END
