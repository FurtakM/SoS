Export Function CreateArtifact(type, x, y);
begin
CreateResourcesXY(mat_artifact, type, x, y, false);
End;

Export Function GetDriver(veh);
var i, filter;
begin
if not GetControl(veh) = control_manual then
   result := false
    else
     if veh in FilterAllUnits([f_empty]) then
        result := false
         else
          begin                   
          filter := FilterAllUnits([[f_side, GetSide(veh)], [f_driving]]);

          if not filter then
             result := false
              else
               for i = 1 to filter do
                   if IsDriver(filter[i]) = veh then
                      begin
                      result := filter[i];
                      break;
                      end;
         end;
End;

Export Function GetSibResources(side);
var i, deps;
begin
result := 0;
deps := FilterAllUnits([[f_side, side], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]);

if deps then
   for i in deps do
       result := result + GetResourceType(GetBase(i), mat_siberit);
End;

Export Function SetSibResources(side, val);
var i, deps, s;
begin
if val <= 0 then
   exit;

deps := FilterAllUnits([[f_side, side], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]);

if deps then
   for i in deps do
       begin
       s := GetResourceType(GetBase(i), mat_siberit);

       if val < s then
          begin
          s := s - val;
          SetResourceType(GetBase(i), mat_siberit, s);
          exit;
          end
           else
            begin
            val := val - s;
            SetResourceType(GetBase(i), mat_siberit, 0);
            end;
       end;
End;

Export Function IsDriver(unit);
begin
if unit in FilterAllUnits([f_driving]) then
   result := IsInUnit(unit)
    else
     result := false;
End;


// arr - tablica
// pos - tablica pozycji
// value - nowa wartoœæ do wstawienia
Export Function ReplaceIn(arr, pos, value);
var i, tmp, s_arr;
begin
if pos < 1 then
   exit;

if pos = 1 then
   result := Replace(arr, pos[1], value)
    else
     begin
     tmp := arr;
     s_arr := [tmp];

     for i = 1 to pos-1 do
         begin
         tmp := tmp[pos[i]];
         s_arr := s_arr ^ [tmp];
         end;

     tmp := Replace(tmp, pos[pos], value);
     s_arr := Replace(s_arr, s_arr, tmp);

     for i = s_arr downto 2 do
         begin
         tmp := Replace(s_arr[i-1], pos[i-1], s_arr[i]);
         s_arr := Replace(s_arr, i-1, tmp);
         end;

     result := s_arr[1];
     end;

End;

//Destination Reachable Function by Serpent
Export unreachableList;
On DestinationUnreachable(unit) Do
begin
if not unit in unreachableList then
   unreachableList := Insert(unreachableList, unreachableList+1, unit);
end;

Export Function DestinationReachable(unit, x, y);
begin
if unit in unreachableList then
   unreachableList := unreachableList diff unit;

   if ValidHex(x, y) then
      ComAttackUnit(unit, HexInfo(x, y));

   Wait(3);

if unit in unreachableList then
   result := false
    else
     result := true;
End;

Export Function ComBombAttack(unit, side);
var i, enemy, t, x, y, change_target_counter, last_target;
begin
enemy := FilterAllUnits([f_side, side]);
change_target_counter := 0;
last_target := 0;

if not enemy then
   exit;

while (IsLive(unit) and change_target_counter < 4) do
   begin
   if UnitFilter(enemy, [f_occupied]) then
      begin
      t := NearestUnitToUnit(UnitFilter(enemy, [f_occupied]), unit);

      if (last_target <> t) then
         change_target_counter := change_target_counter + 1;

      last_target := t;

      x := GetX(t);
      y := GetY(t);

      if DestinationReachable(unit, x, y) then
         ComAttackUnit(unit, t);
      end
       else
        ComAttackUnit(unit, NearestUnitToUnit(enemy, unit));

   Wait(0$0.3);
   end;
End;

Export Function ComBrutalAttack(units, side);
var i, enemy, t, x, y, target, unit;
begin
enemy := FilterAllUnits([f_side, side]);
target := 0;

if not enemy then
   exit;

while units do
    begin
    wait(0$0.3);

    for unit in units do
        begin

        if not IsPlaced(unit) then
           begin
           units := units diff unit;
           continue;
           end;

        if not IsPlaced(target) then
           target := 0;

        if not target and UnitFilter(enemy, [[f_type, unit_human], [f_not, [f_inside]]]) then
           begin
           t := NearestUnitToUnit(UnitFilter(enemy, [[f_type, unit_human], [f_not, [f_inside]]]), unit);

           x := GetX(t);
           y := GetY(t);

           if DestinationReachable(unit, x, y) then
              target := t
               else
                if UnitFilter(enemy, [f_occupied]) then
                   begin
                   t := NearestUnitToUnit(UnitFilter(enemy, [f_occupied]), unit);

                   x := GetX(t);
                   y := GetY(t);

                   if DestinationReachable(unit, x, y) then
                      target := t
                     else
                      ComAttackUnit(unit, NearestUnitToUnit(FilterAllUnits([f_side, 6]), unit));
                   end;
           end;

        if not target or not DestinationReachable(unit, GetX(target), GetY(target)) then
           target := NearestUnitToUnit(FilterAllUnits([f_side, side]), unit);

        if (GetDistUnits(target, unit) < 4 and GetLives(unit) < 600) or (GetLives(unit) < 200 and GetSide(NearestUnitToUnit(all_units diff unit, unit)) <> GetSide(unit)) then
           begin
           for i = 1 to 4 do
               MineExplosion(GetX(unit), GetY(unit), 1);
           end
            else
             if GetType(target) <> unit_human then
                ComAttackUnit(unit, target)
                 else
                  ComMoveXY(unit, GetX(target), GetY(target));
        end;
    end;

End;


{
[istnieje, wysokoœæ, zbocze, woda, typ, teren]

Wysokoœæ - Wysokoœæ danego hexu.
Zbocze - osobny numer dla ka¿dego kierunku i nachylenia
bia³e:
nachylenie 1 w kierunkach od 0 do 5:
8, 9, 10, 11, 12, 13
nachylenie 2 w kierunkach od 0 do 5:
16, 17, 18, 19, 20, 21

¿ó³te:
nachylenie 3 w kierunkach od 0 do 5:
24, 25, 26, 27, 28, 29
nachylenie 4 w kierunkach od 0 do 5:
32, 33, 34, 35, 36, 37

czerwone:
nachylenie 5 w kierunkach od 0 do 5:
40, 41, 42, 43, 44, 45
nachylenie 6 w kierunkach od 0 do 5:
48, 49, 50, 51, 52, 53

Woda - G³êbokoœæ, dla obu typów wód i bagna
typ - 1 dla wody i bagna lub stoków (chyba chodzi o hexy przez które jednostki musz¹ zwalniaæ), 0 dla p³askich hexów
Teren - w tej samej kolejnoœci co w edytorze:
1: earth
2: needles
3: don't enter
4: don't enter water
5: water
6: don't enter rock
7: rock
8: swamp
9: snee
10: road
11: bank}
