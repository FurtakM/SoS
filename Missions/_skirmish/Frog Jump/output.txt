// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// debug := false ;
   8: LD_ADDR_EXP 6
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// InitVariables ;
  16: CALL 63 0 0
// InitArtifactsPos ;
  20: CALL 8869 0 0
// PrepareAnimals ( 7 , 2 , 2 , cratesArea ) ;
  24: LD_INT 7
  26: PPUSH
  27: LD_INT 2
  29: PPUSH
  30: LD_INT 2
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: CALL 8248 0 4
// PrepareAlliance ;
  40: CALL 308 0 0
// PrepareLegion ;
  44: CALL 1792 0 0
// if debug then
  48: LD_EXP 6
  52: IFFALSE 58
// DebugMode ;
  54: CALL 10844 0 0
// Action ;
  58: CALL 7017 0 0
// end ;
  62: END
// export Bagins , Davidov , Vervecken ; export player_start_res_sib_bomb , player_start_res_artifact , debug , legion_attacks_active , legion_attack_strenght , alliance_attack_active , alliance_used_artifact_1 , alliance_used_artifact_2 , player_used_sib_bomb , artifacts_mode , artifacts_type , artifacts_pos , artifact_destroyed , sib_rocket_range , player_artifact_loaded , player_artifact_number , player_artifact_icon , player_artifact_icon_2 , player_artifact_researched , player_artifact_active_distance , player_artifact_icon_type , player_artifact_icon_res , player_artifact_time_refresh , player_artifact_time_res , player_side , player_artifact_ready , player_artifact_selected_unit , alliance_attack_strength ; function InitVariables ; begin
  63: LD_INT 0
  65: PPUSH
// player_start_res_sib_bomb := false ;
  66: LD_ADDR_EXP 4
  70: PUSH
  71: LD_INT 0
  73: ST_TO_ADDR
// player_start_res_artifact := false ;
  74: LD_ADDR_EXP 5
  78: PUSH
  79: LD_INT 0
  81: ST_TO_ADDR
// legion_attacks_active := false ;
  82: LD_ADDR_EXP 7
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// legion_attack_strenght := 3 ;
  90: LD_ADDR_EXP 8
  94: PUSH
  95: LD_INT 3
  97: ST_TO_ADDR
// alliance_attack_strength := 1 ;
  98: LD_ADDR_EXP 31
 102: PUSH
 103: LD_INT 1
 105: ST_TO_ADDR
// alliance_attack_active := false ;
 106: LD_ADDR_EXP 9
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// alliance_used_artifact_1 := false ;
 114: LD_ADDR_EXP 10
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// alliance_used_artifact_2 := false ;
 122: LD_ADDR_EXP 11
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// artifacts_mode := [ 0 , 0 , 0 ] ;
 130: LD_ADDR_EXP 13
 134: PUSH
 135: LD_INT 0
 137: PUSH
 138: LD_INT 0
 140: PUSH
 141: LD_INT 0
 143: PUSH
 144: EMPTY
 145: LIST
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// artifacts_type := [ 2 , 3 , 5 ] ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 2
 156: PUSH
 157: LD_INT 3
 159: PUSH
 160: LD_INT 5
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: ST_TO_ADDR
// artifacts_pos := [ ] ;
 168: LD_ADDR_EXP 15
 172: PUSH
 173: EMPTY
 174: ST_TO_ADDR
// artifact_destroyed := false ;
 175: LD_ADDR_EXP 16
 179: PUSH
 180: LD_INT 0
 182: ST_TO_ADDR
// sib_rocket_range := 25 ;
 183: LD_ADDR_EXP 17
 187: PUSH
 188: LD_INT 25
 190: ST_TO_ADDR
// player_used_sib_bomb := false ;
 191: LD_ADDR_EXP 12
 195: PUSH
 196: LD_INT 0
 198: ST_TO_ADDR
// player_artifact_loaded := true ;
 199: LD_ADDR_EXP 18
 203: PUSH
 204: LD_INT 1
 206: ST_TO_ADDR
// player_artifact_number := 6 ;
 207: LD_ADDR_EXP 19
 211: PUSH
 212: LD_INT 6
 214: ST_TO_ADDR
// player_artifact_icon := art_use_human ;
 215: LD_ADDR_EXP 20
 219: PUSH
 220: LD_INT 10
 222: ST_TO_ADDR
// player_artifact_icon_2 := art_use_teleport ;
 223: LD_ADDR_EXP 21
 227: PUSH
 228: LD_INT 6
 230: ST_TO_ADDR
// player_artifact_researched := false ;
 231: LD_ADDR_EXP 22
 235: PUSH
 236: LD_INT 0
 238: ST_TO_ADDR
// player_artifact_active_distance := 5 ;
 239: LD_ADDR_EXP 23
 243: PUSH
 244: LD_INT 5
 246: ST_TO_ADDR
// player_artifact_time_refresh := 8500 ;
 247: LD_ADDR_EXP 26
 251: PUSH
 252: LD_INT 8500
 254: ST_TO_ADDR
// player_artifact_icon_type := art_place ;
 255: LD_ADDR_EXP 24
 259: PUSH
 260: LD_INT 3
 262: ST_TO_ADDR
// player_artifact_icon_res := art_exp_left ;
 263: LD_ADDR_EXP 25
 267: PUSH
 268: LD_INT 1
 270: ST_TO_ADDR
// player_artifact_time_res := 300 ;
 271: LD_ADDR_EXP 27
 275: PUSH
 276: LD_INT 300
 278: ST_TO_ADDR
// player_artifact_ready := false ;
 279: LD_ADDR_EXP 29
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// player_artifact_selected_unit := 0 ;
 287: LD_ADDR_EXP 30
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// player_side := 6 ;
 295: LD_ADDR_EXP 28
 299: PUSH
 300: LD_INT 6
 302: ST_TO_ADDR
// end ; end_of_file
 303: LD_VAR 0 1
 307: RET
// export al_force ; export function PrepareAlliance ; var i , un , skill ; begin
 308: LD_INT 0
 310: PPUSH
 311: PPUSH
 312: PPUSH
 313: PPUSH
// uc_side := 7 ;
 314: LD_ADDR_OWVAR 20
 318: PUSH
 319: LD_INT 7
 321: ST_TO_ADDR
// uc_nation := nation_american ;
 322: LD_ADDR_OWVAR 21
 326: PUSH
 327: LD_INT 1
 329: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
 330: LD_ADDR_VAR 0 4
 334: PUSH
 335: LD_INT 7
 337: PUSH
 338: LD_INT 8
 340: PUSH
 341: LD_INT 9
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: LIST
 348: PUSH
 349: LD_OWVAR 67
 353: ARRAY
 354: ST_TO_ADDR
// al_force := [ ] ;
 355: LD_ADDR_EXP 32
 359: PUSH
 360: EMPTY
 361: ST_TO_ADDR
// SetResourceType ( GetBase ( al_dep ) , mat_cans , 999999 ) ;
 362: LD_INT 1
 364: PPUSH
 365: CALL_OW 274
 369: PPUSH
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 999999
 375: PPUSH
 376: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_oil , 10000 ) ;
 380: LD_INT 1
 382: PPUSH
 383: CALL_OW 274
 387: PPUSH
 388: LD_INT 2
 390: PPUSH
 391: LD_INT 10000
 393: PPUSH
 394: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_siberit , 10000 ) ;
 398: LD_INT 1
 400: PPUSH
 401: CALL_OW 274
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 10000
 411: PPUSH
 412: CALL_OW 277
// hc_gallery := sandal ;
 416: LD_ADDR_OWVAR 33
 420: PUSH
 421: LD_STRING sandal
 423: ST_TO_ADDR
// hc_face_number := 13 ;
 424: LD_ADDR_OWVAR 34
 428: PUSH
 429: LD_INT 13
 431: ST_TO_ADDR
// hc_class := 1 ;
 432: LD_ADDR_OWVAR 28
 436: PUSH
 437: LD_INT 1
 439: ST_TO_ADDR
// hc_name := Matthew Bagins ;
 440: LD_ADDR_OWVAR 26
 444: PUSH
 445: LD_STRING Matthew Bagins
 447: ST_TO_ADDR
// hc_skills := [ 10 , 5 , 8 , 5 ] ;
 448: LD_ADDR_OWVAR 31
 452: PUSH
 453: LD_INT 10
 455: PUSH
 456: LD_INT 5
 458: PUSH
 459: LD_INT 8
 461: PUSH
 462: LD_INT 5
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: ST_TO_ADDR
// hc_attr := [ 11 , 12 ] ;
 471: LD_ADDR_OWVAR 29
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// Bagins := CreateHuman ;
 486: LD_ADDR_EXP 1
 490: PUSH
 491: CALL_OW 44
 495: ST_TO_ADDR
// PlaceHumanInUnit ( Bagins , al_dep ) ;
 496: LD_EXP 1
 500: PPUSH
 501: LD_INT 1
 503: PPUSH
 504: CALL_OW 52
// hc_gallery :=  ;
 508: LD_ADDR_OWVAR 33
 512: PUSH
 513: LD_STRING 
 515: ST_TO_ADDR
// hc_name :=  ;
 516: LD_ADDR_OWVAR 26
 520: PUSH
 521: LD_STRING 
 523: ST_TO_ADDR
// for i = 1 to 6 do
 524: LD_ADDR_VAR 0 2
 528: PUSH
 529: DOUBLE
 530: LD_INT 1
 532: DEC
 533: ST_TO_ADDR
 534: LD_INT 6
 536: PUSH
 537: FOR_TO
 538: IFFALSE 599
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 540: LD_ADDR_OWVAR 21
 544: PUSH
 545: LD_INT 1
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: PUSH
 555: LD_INT 1
 557: PPUSH
 558: LD_INT 2
 560: PPUSH
 561: CALL_OW 12
 565: ARRAY
 566: ST_TO_ADDR
// PrepareHuman ( false , class_engineer , skill ) ;
 567: LD_INT 0
 569: PPUSH
 570: LD_INT 2
 572: PPUSH
 573: LD_VAR 0 4
 577: PPUSH
 578: CALL_OW 380
// PlaceUnitArea ( CreateHuman , al_base , false ) ;
 582: CALL_OW 44
 586: PPUSH
 587: LD_INT 1
 589: PPUSH
 590: LD_INT 0
 592: PPUSH
 593: CALL_OW 49
// end ;
 597: GO 537
 599: POP
 600: POP
// for i = 1 to 6 do
 601: LD_ADDR_VAR 0 2
 605: PUSH
 606: DOUBLE
 607: LD_INT 1
 609: DEC
 610: ST_TO_ADDR
 611: LD_INT 6
 613: PUSH
 614: FOR_TO
 615: IFFALSE 673
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 617: LD_ADDR_OWVAR 21
 621: PUSH
 622: LD_INT 1
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: PUSH
 632: LD_INT 1
 634: PPUSH
 635: LD_INT 2
 637: PPUSH
 638: CALL_OW 12
 642: ARRAY
 643: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 644: LD_INT 0
 646: PPUSH
 647: LD_INT 3
 649: PPUSH
 650: LD_VAR 0 4
 654: PPUSH
 655: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_ru ) ;
 659: CALL_OW 44
 663: PPUSH
 664: LD_INT 6
 666: PPUSH
 667: CALL_OW 52
// end ;
 671: GO 614
 673: POP
 674: POP
// for i = 1 to 6 do
 675: LD_ADDR_VAR 0 2
 679: PUSH
 680: DOUBLE
 681: LD_INT 1
 683: DEC
 684: ST_TO_ADDR
 685: LD_INT 6
 687: PUSH
 688: FOR_TO
 689: IFFALSE 747
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 691: LD_ADDR_OWVAR 21
 695: PUSH
 696: LD_INT 1
 698: PUSH
 699: LD_INT 3
 701: PUSH
 702: EMPTY
 703: LIST
 704: LIST
 705: PUSH
 706: LD_INT 1
 708: PPUSH
 709: LD_INT 2
 711: PPUSH
 712: CALL_OW 12
 716: ARRAY
 717: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 718: LD_INT 0
 720: PPUSH
 721: LD_INT 3
 723: PPUSH
 724: LD_VAR 0 4
 728: PPUSH
 729: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_us ) ;
 733: CALL_OW 44
 737: PPUSH
 738: LD_INT 11
 740: PPUSH
 741: CALL_OW 52
// end ;
 745: GO 688
 747: POP
 748: POP
// for i = 1 to 6 do
 749: LD_ADDR_VAR 0 2
 753: PUSH
 754: DOUBLE
 755: LD_INT 1
 757: DEC
 758: ST_TO_ADDR
 759: LD_INT 6
 761: PUSH
 762: FOR_TO
 763: IFFALSE 840
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 765: LD_ADDR_OWVAR 21
 769: PUSH
 770: LD_INT 1
 772: PUSH
 773: LD_INT 3
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 1
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: CALL_OW 12
 790: ARRAY
 791: ST_TO_ADDR
// PrepareHuman ( false , class_scientistic , skill ) ;
 792: LD_INT 0
 794: PPUSH
 795: LD_INT 4
 797: PPUSH
 798: LD_VAR 0 4
 802: PPUSH
 803: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , [ al_lab_us , al_lab_ru ] [ Rand ( 1 , 2 ) ] ) ;
 807: CALL_OW 44
 811: PPUSH
 812: LD_INT 2
 814: PUSH
 815: LD_INT 5
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: PUSH
 822: LD_INT 1
 824: PPUSH
 825: LD_INT 2
 827: PPUSH
 828: CALL_OW 12
 832: ARRAY
 833: PPUSH
 834: CALL_OW 52
// end ;
 838: GO 762
 840: POP
 841: POP
// for i = 1 to 6 do
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: DOUBLE
 848: LD_INT 1
 850: DEC
 851: ST_TO_ADDR
 852: LD_INT 6
 854: PUSH
 855: FOR_TO
 856: IFFALSE 963
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 858: LD_ADDR_OWVAR 21
 862: PUSH
 863: LD_INT 1
 865: PUSH
 866: LD_INT 3
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: LD_INT 1
 875: PPUSH
 876: LD_INT 2
 878: PPUSH
 879: CALL_OW 12
 883: ARRAY
 884: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker ] [ Rand ( 1 , 2 ) ] , skill ) ;
 885: LD_INT 0
 887: PPUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 9
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 1
 900: PPUSH
 901: LD_INT 2
 903: PPUSH
 904: CALL_OW 12
 908: ARRAY
 909: PPUSH
 910: LD_VAR 0 4
 914: PPUSH
 915: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 919: CALL_OW 44
 923: PPUSH
 924: LD_INT 22
 926: PUSH
 927: LD_INT 7
 929: PUSH
 930: EMPTY
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 30
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: PPUSH
 948: CALL_OW 69
 952: PUSH
 953: LD_INT 1
 955: ARRAY
 956: PPUSH
 957: CALL_OW 52
// end ;
 961: GO 855
 963: POP
 964: POP
// uc_nation := 3 ;
 965: LD_ADDR_OWVAR 21
 969: PUSH
 970: LD_INT 3
 972: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , skill ) ;
 973: LD_INT 0
 975: PPUSH
 976: LD_INT 5
 978: PPUSH
 979: LD_VAR 0 4
 983: PPUSH
 984: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_bun ) ;
 988: CALL_OW 44
 992: PPUSH
 993: LD_INT 50
 995: PPUSH
 996: CALL_OW 52
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) do
1000: LD_ADDR_VAR 0 2
1004: PUSH
1005: LD_INT 22
1007: PUSH
1008: LD_INT 7
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 30
1017: PUSH
1018: LD_INT 33
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: PPUSH
1029: CALL_OW 69
1033: PUSH
1034: FOR_IN
1035: IFFALSE 1099
// if GetNation ( i ) = 1 then
1037: LD_VAR 0 2
1041: PPUSH
1042: CALL_OW 248
1046: PUSH
1047: LD_INT 1
1049: EQUAL
1050: IFFALSE 1066
// AddComPlaceWeapon ( i , us_double_laser ) else
1052: LD_VAR 0 2
1056: PPUSH
1057: LD_INT 10
1059: PPUSH
1060: CALL_OW 208
1064: GO 1097
// AddComPlaceWeapon ( i , [ ru_rocket , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
1066: LD_VAR 0 2
1070: PPUSH
1071: LD_INT 47
1073: PUSH
1074: LD_INT 45
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: PUSH
1081: LD_INT 1
1083: PPUSH
1084: LD_INT 2
1086: PPUSH
1087: CALL_OW 12
1091: ARRAY
1092: PPUSH
1093: CALL_OW 208
1097: GO 1034
1099: POP
1100: POP
// end ;
1101: LD_VAR 0 1
1105: RET
// export function ConstructAlVeh ( nation ) ; var i , un , fac , chassis , engine , control , weapon ; begin
1106: LD_INT 0
1108: PPUSH
1109: PPUSH
1110: PPUSH
1111: PPUSH
1112: PPUSH
1113: PPUSH
1114: PPUSH
1115: PPUSH
// if nation = 2 then
1116: LD_VAR 0 1
1120: PUSH
1121: LD_INT 2
1123: EQUAL
1124: IFFALSE 1128
// exit ;
1126: GO 1347
// if nation = 1 then
1128: LD_VAR 0 1
1132: PUSH
1133: LD_INT 1
1135: EQUAL
1136: IFFALSE 1154
// if al_fac_us then
1138: LD_INT 11
1140: IFFALSE 1152
// fac := al_fac_us else
1142: LD_ADDR_VAR 0 5
1146: PUSH
1147: LD_INT 11
1149: ST_TO_ADDR
1150: GO 1154
// exit ;
1152: GO 1347
// if nation = 3 then
1154: LD_VAR 0 1
1158: PUSH
1159: LD_INT 3
1161: EQUAL
1162: IFFALSE 1180
// if al_fac_ru then
1164: LD_INT 6
1166: IFFALSE 1178
// fac := al_fac_ru else
1168: LD_ADDR_VAR 0 5
1172: PUSH
1173: LD_INT 6
1175: ST_TO_ADDR
1176: GO 1180
// exit ;
1178: GO 1347
// if nation = 1 then
1180: LD_VAR 0 1
1184: PUSH
1185: LD_INT 1
1187: EQUAL
1188: IFFALSE 1200
// chassis := us_morphling else
1190: LD_ADDR_VAR 0 6
1194: PUSH
1195: LD_INT 5
1197: ST_TO_ADDR
1198: GO 1208
// chassis := ru_heavy_tracked ;
1200: LD_ADDR_VAR 0 6
1204: PUSH
1205: LD_INT 24
1207: ST_TO_ADDR
// if nation = 1 then
1208: LD_VAR 0 1
1212: PUSH
1213: LD_INT 1
1215: EQUAL
1216: IFFALSE 1228
// engine := engine_combustion else
1218: LD_ADDR_VAR 0 7
1222: PUSH
1223: LD_INT 1
1225: ST_TO_ADDR
1226: GO 1236
// engine := engine_siberite ;
1228: LD_ADDR_VAR 0 7
1232: PUSH
1233: LD_INT 3
1235: ST_TO_ADDR
// control := control_computer ;
1236: LD_ADDR_VAR 0 8
1240: PUSH
1241: LD_INT 3
1243: ST_TO_ADDR
// if nation = 3 then
1244: LD_VAR 0 1
1248: PUSH
1249: LD_INT 3
1251: EQUAL
1252: IFFALSE 1275
// weapon := [ ru_rocket , ru_rocket_launcher , ru_gatling_gun ] else
1254: LD_ADDR_VAR 0 9
1258: PUSH
1259: LD_INT 47
1261: PUSH
1262: LD_INT 45
1264: PUSH
1265: LD_INT 43
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: LIST
1272: ST_TO_ADDR
1273: GO 1294
// weapon := [ us_heavy_gun , us_laser , us_double_laser ] ;
1275: LD_ADDR_VAR 0 9
1279: PUSH
1280: LD_INT 6
1282: PUSH
1283: LD_INT 9
1285: PUSH
1286: LD_INT 10
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: ST_TO_ADDR
// weapon := weapon [ rand ( 1 , weapon ) ] ;
1294: LD_ADDR_VAR 0 9
1298: PUSH
1299: LD_VAR 0 9
1303: PUSH
1304: LD_INT 1
1306: PPUSH
1307: LD_VAR 0 9
1311: PPUSH
1312: CALL_OW 12
1316: ARRAY
1317: ST_TO_ADDR
// AddComConstruct ( fac , chassis , engine , control , weapon ) ;
1318: LD_VAR 0 5
1322: PPUSH
1323: LD_VAR 0 6
1327: PPUSH
1328: LD_VAR 0 7
1332: PPUSH
1333: LD_VAR 0 8
1337: PPUSH
1338: LD_VAR 0 9
1342: PPUSH
1343: CALL_OW 185
// end ;
1347: LD_VAR 0 2
1351: RET
// every 0 0$01 trigger FilterUnitsInArea ( al_teleport_enter , [ f_not , [ f_type , unit_building ] ] ) do
1352: LD_INT 4
1354: PPUSH
1355: LD_INT 3
1357: PUSH
1358: LD_INT 21
1360: PUSH
1361: LD_INT 3
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: PPUSH
1372: CALL_OW 70
1376: IFFALSE 1417
1378: GO 1380
1380: DISABLE
// begin enable ;
1381: ENABLE
// CheckBuildUpArea ( al_teleport_enter , al_teleport_exit , FilterUnitsInArea ( al_teleport_enter , [ f_not , [ f_type , unit_building ] ] ) ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 5
1387: PPUSH
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 3
1393: PUSH
1394: LD_INT 21
1396: PUSH
1397: LD_INT 3
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: PUSH
1404: EMPTY
1405: LIST
1406: LIST
1407: PPUSH
1408: CALL_OW 70
1412: PPUSH
1413: CALL_OW 513
// end ;
1417: END
// every 12 12$00 trigger FilterAllUnits ( [ f_side , 7 ] ) and alliance_attack_active do var i ;
1418: LD_INT 22
1420: PUSH
1421: LD_INT 7
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: PPUSH
1428: CALL_OW 69
1432: PUSH
1433: LD_EXP 9
1437: AND
1438: IFFALSE 1585
1440: GO 1442
1442: DISABLE
1443: LD_INT 0
1445: PPUSH
// begin enable ;
1446: ENABLE
// alliance_attack_strength := alliance_attack_strength + 1 ;
1447: LD_ADDR_EXP 31
1451: PUSH
1452: LD_EXP 31
1456: PUSH
1457: LD_INT 1
1459: PLUS
1460: ST_TO_ADDR
// for i = 1 to ( [ 4 , 5 , 6 ] [ Difficulty ] ) + alliance_attack_strength do
1461: LD_ADDR_VAR 0 1
1465: PUSH
1466: DOUBLE
1467: LD_INT 1
1469: DEC
1470: ST_TO_ADDR
1471: LD_INT 4
1473: PUSH
1474: LD_INT 5
1476: PUSH
1477: LD_INT 6
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: LIST
1484: PUSH
1485: LD_OWVAR 67
1489: ARRAY
1490: PUSH
1491: LD_EXP 31
1495: PLUS
1496: PUSH
1497: FOR_TO
1498: IFFALSE 1528
// begin ConstructAlVeh ( [ 1 , 3 ] [ rand ( 1 , 2 ) ] ) ;
1500: LD_INT 1
1502: PUSH
1503: LD_INT 3
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PUSH
1510: LD_INT 1
1512: PPUSH
1513: LD_INT 2
1515: PPUSH
1516: CALL_OW 12
1520: ARRAY
1521: PPUSH
1522: CALL 1106 0 1
// end ;
1526: GO 1497
1528: POP
1529: POP
// repeat wait ( 0 0$01 ) ;
1530: LD_INT 35
1532: PPUSH
1533: CALL_OW 67
// until al_force >= ( [ 4 , 5 , 6 ] [ Difficulty ] ) + alliance_attack_strength ;
1537: LD_EXP 32
1541: PUSH
1542: LD_INT 4
1544: PUSH
1545: LD_INT 5
1547: PUSH
1548: LD_INT 6
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: LIST
1555: PUSH
1556: LD_OWVAR 67
1560: ARRAY
1561: PUSH
1562: LD_EXP 31
1566: PLUS
1567: GREATEREQUAL
1568: IFFALSE 1530
// AddComMoveXY ( al_force , 143 , 178 ) ;
1570: LD_EXP 32
1574: PPUSH
1575: LD_INT 143
1577: PPUSH
1578: LD_INT 178
1580: PPUSH
1581: CALL_OW 171
// end ;
1585: PPOPN 1
1587: END
// every 0 0$01 trigger FilterUnitsInArea ( islandArea , [ f_side , 7 ] ) do var i ;
1588: LD_INT 6
1590: PPUSH
1591: LD_INT 22
1593: PUSH
1594: LD_INT 7
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: PPUSH
1601: CALL_OW 70
1605: IFFALSE 1685
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
// begin enable ;
1613: ENABLE
// for i in FilterUnitsInArea ( islandArea , [ f_side , 7 ] ) do
1614: LD_ADDR_VAR 0 1
1618: PUSH
1619: LD_INT 6
1621: PPUSH
1622: LD_INT 22
1624: PUSH
1625: LD_INT 7
1627: PUSH
1628: EMPTY
1629: LIST
1630: LIST
1631: PPUSH
1632: CALL_OW 70
1636: PUSH
1637: FOR_IN
1638: IFFALSE 1683
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ) ;
1640: LD_VAR 0 1
1644: PPUSH
1645: LD_INT 81
1647: PUSH
1648: LD_VAR 0 1
1652: PPUSH
1653: CALL_OW 255
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: PPUSH
1662: CALL_OW 69
1666: PPUSH
1667: LD_VAR 0 1
1671: PPUSH
1672: CALL_OW 74
1676: PPUSH
1677: CALL_OW 115
1681: GO 1637
1683: POP
1684: POP
// end ;
1685: PPOPN 1
1687: END
// every 7 7$30 trigger alliance_attack_active do var reload_time ;
1688: LD_EXP 9
1692: IFFALSE 1789
1694: GO 1696
1696: DISABLE
1697: LD_INT 0
1699: PPUSH
// begin reload_time := [ 9 9$00 , 8 8$40 , 7 7$50 ] [ Difficulty ] ;
1700: LD_ADDR_VAR 0 1
1704: PUSH
1705: LD_INT 18900
1707: PUSH
1708: LD_INT 18200
1710: PUSH
1711: LD_INT 16450
1713: PUSH
1714: EMPTY
1715: LIST
1716: LIST
1717: LIST
1718: PUSH
1719: LD_OWVAR 67
1723: ARRAY
1724: ST_TO_ADDR
// repeat ActiveArtifact1 ( ) ;
1725: CALL 10279 0 0
// wait ( reload_time / 2 ) ;
1729: LD_VAR 0 1
1733: PUSH
1734: LD_INT 2
1736: DIVREAL
1737: PPUSH
1738: CALL_OW 67
// ActiveArtifact2 ( ) ;
1742: CALL 10664 0 0
// wait ( reload_time / 2 ) ;
1746: LD_VAR 0 1
1750: PUSH
1751: LD_INT 2
1753: DIVREAL
1754: PPUSH
1755: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) ;
1759: LD_INT 22
1761: PUSH
1762: LD_INT 7
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: PUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 8
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: PPUSH
1783: CALL_OW 69
1787: IFFALSE 1725
// end ; end_of_file
1789: PPOPN 1
1791: END
// export function PrepareLegion ; var i , un , skill , dep , fac ; begin
1792: LD_INT 0
1794: PPUSH
1795: PPUSH
1796: PPUSH
1797: PPUSH
1798: PPUSH
1799: PPUSH
// uc_side := 8 ;
1800: LD_ADDR_OWVAR 20
1804: PUSH
1805: LD_INT 8
1807: ST_TO_ADDR
// uc_nation := 2 ;
1808: LD_ADDR_OWVAR 21
1812: PUSH
1813: LD_INT 2
1815: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
1816: LD_ADDR_VAR 0 4
1820: PUSH
1821: LD_INT 7
1823: PUSH
1824: LD_INT 8
1826: PUSH
1827: LD_INT 9
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: PUSH
1835: LD_OWVAR 67
1839: ARRAY
1840: ST_TO_ADDR
// dep := ar_base ;
1841: LD_ADDR_VAR 0 5
1845: PUSH
1846: LD_INT 57
1848: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
1849: LD_ADDR_VAR 0 6
1853: PUSH
1854: LD_INT 22
1856: PUSH
1857: LD_INT 8
1859: PUSH
1860: EMPTY
1861: LIST
1862: LIST
1863: PUSH
1864: LD_INT 30
1866: PUSH
1867: LD_INT 3
1869: PUSH
1870: EMPTY
1871: LIST
1872: LIST
1873: PUSH
1874: EMPTY
1875: LIST
1876: LIST
1877: PPUSH
1878: CALL_OW 69
1882: PUSH
1883: LD_INT 1
1885: ARRAY
1886: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 999999 ) ;
1887: LD_VAR 0 5
1891: PPUSH
1892: CALL_OW 274
1896: PPUSH
1897: LD_INT 1
1899: PPUSH
1900: LD_INT 999999
1902: PPUSH
1903: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1907: LD_VAR 0 5
1911: PPUSH
1912: CALL_OW 274
1916: PPUSH
1917: LD_INT 2
1919: PPUSH
1920: LD_INT 10000
1922: PPUSH
1923: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 10000 ) ;
1927: LD_VAR 0 5
1931: PPUSH
1932: CALL_OW 274
1936: PPUSH
1937: LD_INT 3
1939: PPUSH
1940: LD_INT 10000
1942: PPUSH
1943: CALL_OW 277
// TeleportExit ( legion_telep , 224 , 5 ) ;
1947: LD_INT 68
1949: PPUSH
1950: LD_INT 224
1952: PPUSH
1953: LD_INT 5
1955: PPUSH
1956: CALL_OW 243
// PrepareHuman ( sex_male , 1 , 6 ) ;
1960: LD_INT 1
1962: PPUSH
1963: LD_INT 1
1965: PPUSH
1966: LD_INT 6
1968: PPUSH
1969: CALL_OW 380
// hc_name := Nicolas Vervecken ;
1973: LD_ADDR_OWVAR 26
1977: PUSH
1978: LD_STRING Nicolas Vervecken
1980: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1981: LD_ADDR_OWVAR 33
1985: PUSH
1986: LD_STRING SecondCharsGal
1988: ST_TO_ADDR
// hc_face_number := 3 ;
1989: LD_ADDR_OWVAR 34
1993: PUSH
1994: LD_INT 3
1996: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
1997: LD_ADDR_OWVAR 29
2001: PUSH
2002: LD_INT 11
2004: PUSH
2005: LD_INT 10
2007: PUSH
2008: EMPTY
2009: LIST
2010: LIST
2011: ST_TO_ADDR
// Vervecken := CreateHuman ;
2012: LD_ADDR_EXP 3
2016: PUSH
2017: CALL_OW 44
2021: ST_TO_ADDR
// PlaceHumanInUnit ( Vervecken , dep ) ;
2022: LD_EXP 3
2026: PPUSH
2027: LD_VAR 0 5
2031: PPUSH
2032: CALL_OW 52
// InitHc ;
2036: CALL_OW 19
// for i = 1 to 4 do
2040: LD_ADDR_VAR 0 2
2044: PUSH
2045: DOUBLE
2046: LD_INT 1
2048: DEC
2049: ST_TO_ADDR
2050: LD_INT 4
2052: PUSH
2053: FOR_TO
2054: IFFALSE 2115
// begin PrepareHuman ( false , class_bazooker , skill ) ;
2056: LD_INT 0
2058: PPUSH
2059: LD_INT 9
2061: PPUSH
2062: LD_VAR 0 4
2066: PPUSH
2067: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
2071: CALL_OW 44
2075: PPUSH
2076: LD_INT 22
2078: PUSH
2079: LD_INT 8
2081: PUSH
2082: EMPTY
2083: LIST
2084: LIST
2085: PUSH
2086: LD_INT 30
2088: PUSH
2089: LD_INT 5
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: PUSH
2096: EMPTY
2097: LIST
2098: LIST
2099: PPUSH
2100: CALL_OW 69
2104: PUSH
2105: LD_INT 1
2107: ARRAY
2108: PPUSH
2109: CALL_OW 52
// end ;
2113: GO 2053
2115: POP
2116: POP
// for i = 1 to 2 do
2117: LD_ADDR_VAR 0 2
2121: PUSH
2122: DOUBLE
2123: LD_INT 1
2125: DEC
2126: ST_TO_ADDR
2127: LD_INT 2
2129: PUSH
2130: FOR_TO
2131: IFFALSE 2192
// begin PrepareHuman ( false , 4 , skill ) ;
2133: LD_INT 0
2135: PPUSH
2136: LD_INT 4
2138: PPUSH
2139: LD_VAR 0 4
2143: PPUSH
2144: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
2148: CALL_OW 44
2152: PPUSH
2153: LD_INT 22
2155: PUSH
2156: LD_INT 8
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: LD_INT 30
2165: PUSH
2166: LD_INT 8
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: PPUSH
2177: CALL_OW 69
2181: PUSH
2182: LD_INT 1
2184: ARRAY
2185: PPUSH
2186: CALL_OW 52
// end ;
2190: GO 2130
2192: POP
2193: POP
// for i = 1 to 6 do
2194: LD_ADDR_VAR 0 2
2198: PUSH
2199: DOUBLE
2200: LD_INT 1
2202: DEC
2203: ST_TO_ADDR
2204: LD_INT 6
2206: PUSH
2207: FOR_TO
2208: IFFALSE 2245
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
2210: LD_INT 0
2212: PPUSH
2213: LD_INT 3
2215: PPUSH
2216: LD_VAR 0 4
2220: PUSH
2221: LD_INT 1
2223: PLUS
2224: PPUSH
2225: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac ) ;
2229: CALL_OW 44
2233: PPUSH
2234: LD_VAR 0 6
2238: PPUSH
2239: CALL_OW 52
// end ;
2243: GO 2207
2245: POP
2246: POP
// uc_nation := 0 ;
2247: LD_ADDR_OWVAR 21
2251: PUSH
2252: LD_INT 0
2254: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) do
2255: LD_ADDR_VAR 0 2
2259: PUSH
2260: LD_INT 22
2262: PUSH
2263: LD_INT 8
2265: PUSH
2266: EMPTY
2267: LIST
2268: LIST
2269: PUSH
2270: LD_INT 30
2272: PUSH
2273: LD_INT 32
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: PPUSH
2284: CALL_OW 69
2288: PUSH
2289: FOR_IN
2290: IFFALSE 2327
// begin PrepareHuman ( false , class_apeman_soldier , skill + 1 ) ;
2292: LD_INT 0
2294: PPUSH
2295: LD_INT 15
2297: PPUSH
2298: LD_VAR 0 4
2302: PUSH
2303: LD_INT 1
2305: PLUS
2306: PPUSH
2307: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
2311: CALL_OW 44
2315: PPUSH
2316: LD_VAR 0 2
2320: PPUSH
2321: CALL_OW 52
// end ;
2325: GO 2289
2327: POP
2328: POP
// PrepareHuman ( false , class_sniper , 10 ) ;
2329: LD_INT 0
2331: PPUSH
2332: LD_INT 5
2334: PPUSH
2335: LD_INT 10
2337: PPUSH
2338: CALL_OW 380
// un := CreateHuman ;
2342: LD_ADDR_VAR 0 3
2346: PUSH
2347: CALL_OW 44
2351: ST_TO_ADDR
// PlaceUnitXY ( un , 175 , 128 , false ) ;
2352: LD_VAR 0 3
2356: PPUSH
2357: LD_INT 175
2359: PPUSH
2360: LD_INT 128
2362: PPUSH
2363: LD_INT 0
2365: PPUSH
2366: CALL_OW 48
// ComEnterUnit ( un , ar_ibun ) ;
2370: LD_VAR 0 3
2374: PPUSH
2375: LD_INT 115
2377: PPUSH
2378: CALL_OW 120
// for i = 1 to 2 do
2382: LD_ADDR_VAR 0 2
2386: PUSH
2387: DOUBLE
2388: LD_INT 1
2390: DEC
2391: ST_TO_ADDR
2392: LD_INT 2
2394: PUSH
2395: FOR_TO
2396: IFFALSE 2421
// AddComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
2398: LD_VAR 0 6
2402: PPUSH
2403: LD_INT 14
2405: PPUSH
2406: LD_INT 2
2408: PPUSH
2409: LD_INT 1
2411: PPUSH
2412: LD_INT 31
2414: PPUSH
2415: CALL_OW 185
2419: GO 2395
2421: POP
2422: POP
// end ;
2423: LD_VAR 0 1
2427: RET
// export function PrepareHovercraft ( num ) ; var i ; begin
2428: LD_INT 0
2430: PPUSH
2431: PPUSH
// for i = 1 to num do
2432: LD_ADDR_VAR 0 3
2436: PUSH
2437: DOUBLE
2438: LD_INT 1
2440: DEC
2441: ST_TO_ADDR
2442: LD_VAR 0 1
2446: PUSH
2447: FOR_TO
2448: IFFALSE 2520
// AddComConstruct ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] , ar_hovercraft , engine_combustion , control_remote , [ ar_light_gun , ar_double_machine_gun ] [ rand ( 1 , 2 ) ] ) ;
2450: LD_INT 22
2452: PUSH
2453: LD_INT 8
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: PUSH
2460: LD_INT 30
2462: PUSH
2463: LD_INT 3
2465: PUSH
2466: EMPTY
2467: LIST
2468: LIST
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: PPUSH
2474: CALL_OW 69
2478: PUSH
2479: LD_INT 1
2481: ARRAY
2482: PPUSH
2483: LD_INT 11
2485: PPUSH
2486: LD_INT 1
2488: PPUSH
2489: LD_INT 2
2491: PPUSH
2492: LD_INT 23
2494: PUSH
2495: LD_INT 24
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 2
2507: PPUSH
2508: CALL_OW 12
2512: ARRAY
2513: PPUSH
2514: CALL_OW 185
2518: GO 2447
2520: POP
2521: POP
// end ;
2522: LD_VAR 0 2
2526: RET
// export function AddKamikaze ( ) ; var i , un ; begin
2527: LD_INT 0
2529: PPUSH
2530: PPUSH
2531: PPUSH
// uc_side := 8 ;
2532: LD_ADDR_OWVAR 20
2536: PUSH
2537: LD_INT 8
2539: ST_TO_ADDR
// uc_nation := 0 ;
2540: LD_ADDR_OWVAR 21
2544: PUSH
2545: LD_INT 0
2547: ST_TO_ADDR
// hc_class := 17 ;
2548: LD_ADDR_OWVAR 28
2552: PUSH
2553: LD_INT 17
2555: ST_TO_ADDR
// hc_gallery :=  ;
2556: LD_ADDR_OWVAR 33
2560: PUSH
2561: LD_STRING 
2563: ST_TO_ADDR
// hc_name :=  ;
2564: LD_ADDR_OWVAR 26
2568: PUSH
2569: LD_STRING 
2571: ST_TO_ADDR
// hc_importance := 0 ;
2572: LD_ADDR_OWVAR 32
2576: PUSH
2577: LD_INT 0
2579: ST_TO_ADDR
// hc_skills := [ 10 , 10 , 10 , 10 ] ;
2580: LD_ADDR_OWVAR 31
2584: PUSH
2585: LD_INT 10
2587: PUSH
2588: LD_INT 10
2590: PUSH
2591: LD_INT 10
2593: PUSH
2594: LD_INT 10
2596: PUSH
2597: EMPTY
2598: LIST
2599: LIST
2600: LIST
2601: LIST
2602: ST_TO_ADDR
// if ar_base then
2603: LD_INT 57
2605: IFFALSE 2650
// begin un := CreateHuman ;
2607: LD_ADDR_VAR 0 3
2611: PUSH
2612: CALL_OW 44
2616: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_base ) ;
2617: LD_VAR 0 3
2621: PPUSH
2622: LD_INT 57
2624: PPUSH
2625: CALL_OW 52
// ComExitBuilding ( un ) ;
2629: LD_VAR 0 3
2633: PPUSH
2634: CALL_OW 122
// AddComEnterUnit ( un , legion_telep ) ;
2638: LD_VAR 0 3
2642: PPUSH
2643: LD_INT 68
2645: PPUSH
2646: CALL_OW 180
// end ; end ;
2650: LD_VAR 0 1
2654: RET
// export legion_force , l_allow_attack ; export function PrepareAttack ( n1 , n2 ) ; var i ; begin
2655: LD_INT 0
2657: PPUSH
2658: PPUSH
// legion_force := [ ] ;
2659: LD_ADDR_EXP 33
2663: PUSH
2664: EMPTY
2665: ST_TO_ADDR
// l_allow_attack := false ;
2666: LD_ADDR_EXP 34
2670: PUSH
2671: LD_INT 0
2673: ST_TO_ADDR
// PrepareHovercraft ( n1 ) ;
2674: LD_VAR 0 1
2678: PPUSH
2679: CALL 2428 0 1
// repeat wait ( 0 0$01 ) ;
2683: LD_INT 35
2685: PPUSH
2686: CALL_OW 67
// until legion_force = n1 ;
2690: LD_EXP 33
2694: PUSH
2695: LD_VAR 0 1
2699: EQUAL
2700: IFFALSE 2683
// l_allow_attack := true ;
2702: LD_ADDR_EXP 34
2706: PUSH
2707: LD_INT 1
2709: ST_TO_ADDR
// for i = 1 to n2 do
2710: LD_ADDR_VAR 0 4
2714: PUSH
2715: DOUBLE
2716: LD_INT 1
2718: DEC
2719: ST_TO_ADDR
2720: LD_VAR 0 2
2724: PUSH
2725: FOR_TO
2726: IFFALSE 2734
// begin AddKamikaze ( ) ;
2728: CALL 2527 0 0
// end ;
2732: GO 2725
2734: POP
2735: POP
// ComBrutalAttack ( legion_force , 6 ) ;
2736: LD_EXP 33
2740: PPUSH
2741: LD_INT 6
2743: PPUSH
2744: CALL 6308 0 2
// end ;
2748: LD_VAR 0 3
2752: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
2753: LD_INT 22
2755: PUSH
2756: LD_INT 8
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: PUSH
2763: LD_INT 33
2765: PUSH
2766: LD_INT 2
2768: PUSH
2769: EMPTY
2770: LIST
2771: LIST
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PPUSH
2777: CALL_OW 69
2781: IFFALSE 2993
2783: GO 2785
2785: DISABLE
2786: LD_INT 0
2788: PPUSH
2789: PPUSH
2790: PPUSH
2791: PPUSH
2792: PPUSH
2793: PPUSH
2794: PPUSH
// begin enable ;
2795: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
2796: LD_ADDR_VAR 0 4
2800: PUSH
2801: LD_INT 22
2803: PUSH
2804: LD_INT 8
2806: PUSH
2807: EMPTY
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 33
2813: PUSH
2814: LD_INT 2
2816: PUSH
2817: EMPTY
2818: LIST
2819: LIST
2820: PUSH
2821: LD_INT 3
2823: PUSH
2824: LD_INT 61
2826: PUSH
2827: EMPTY
2828: LIST
2829: PUSH
2830: EMPTY
2831: LIST
2832: LIST
2833: PUSH
2834: EMPTY
2835: LIST
2836: LIST
2837: LIST
2838: PPUSH
2839: CALL_OW 69
2843: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ;
2844: LD_ADDR_VAR 0 3
2848: PUSH
2849: LD_INT 22
2851: PUSH
2852: LD_INT 8
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: LD_INT 34
2861: PUSH
2862: LD_INT 31
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PPUSH
2873: CALL_OW 69
2877: ST_TO_ADDR
// best := 10 ;
2878: LD_ADDR_VAR 0 5
2882: PUSH
2883: LD_INT 10
2885: ST_TO_ADDR
// best_mechanic := - 1 ;
2886: LD_ADDR_VAR 0 6
2890: PUSH
2891: LD_INT 1
2893: NEG
2894: ST_TO_ADDR
// if vehs then
2895: LD_VAR 0 4
2899: IFFALSE 2993
// begin for j in cts do
2901: LD_ADDR_VAR 0 2
2905: PUSH
2906: LD_VAR 0 3
2910: PUSH
2911: FOR_IN
2912: IFFALSE 2973
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
2914: LD_ADDR_VAR 0 7
2918: PUSH
2919: LD_VAR 0 2
2923: PPUSH
2924: CALL 4986 0 1
2928: PPUSH
2929: CALL_OW 432
2933: ST_TO_ADDR
// if p < best then
2934: LD_VAR 0 7
2938: PUSH
2939: LD_VAR 0 5
2943: LESS
2944: IFFALSE 2971
// begin best := p ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 7
2955: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
2956: LD_ADDR_VAR 0 6
2960: PUSH
2961: LD_VAR 0 2
2965: PPUSH
2966: CALL 4986 0 1
2970: ST_TO_ADDR
// end ; end ;
2971: GO 2911
2973: POP
2974: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
2975: LD_VAR 0 4
2979: PUSH
2980: LD_INT 1
2982: ARRAY
2983: PPUSH
2984: LD_VAR 0 6
2988: PPUSH
2989: CALL_OW 135
// end ; end ;
2993: PPOPN 7
2995: END
// every 5 5$00 trigger legion_attacks_active do
2996: LD_EXP 7
3000: IFFALSE 3052
3002: GO 3004
3004: DISABLE
// begin enable ;
3005: ENABLE
// Wait ( [ 2 2$30 , 1 1$00 , 0 0$30 ] [ Difficulty ] ) ;
3006: LD_INT 5250
3008: PUSH
3009: LD_INT 2100
3011: PUSH
3012: LD_INT 1050
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: LIST
3019: PUSH
3020: LD_OWVAR 67
3024: ARRAY
3025: PPUSH
3026: CALL_OW 67
// PrepareAttack ( ( legion_attack_strenght - 2 + Difficulty ) , 2 ) ;
3030: LD_EXP 8
3034: PUSH
3035: LD_INT 2
3037: MINUS
3038: PUSH
3039: LD_OWVAR 67
3043: PLUS
3044: PPUSH
3045: LD_INT 2
3047: PPUSH
3048: CALL 2655 0 2
// end ;
3052: END
// every 0 0$01 trigger FilterUnitsInArea ( islandArea , [ [ f_side , 8 ] , [ f_class , 17 ] ] ) do var i ;
3053: LD_INT 6
3055: PPUSH
3056: LD_INT 22
3058: PUSH
3059: LD_INT 8
3061: PUSH
3062: EMPTY
3063: LIST
3064: LIST
3065: PUSH
3066: LD_INT 25
3068: PUSH
3069: LD_INT 17
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: PPUSH
3080: CALL_OW 70
3084: IFFALSE 3171
3086: GO 3088
3088: DISABLE
3089: LD_INT 0
3091: PPUSH
// begin enable ;
3092: ENABLE
// for i in FilterUnitsInArea ( islandArea , [ [ f_side , 8 ] , [ f_class , 17 ] ] ) do
3093: LD_ADDR_VAR 0 1
3097: PUSH
3098: LD_INT 6
3100: PPUSH
3101: LD_INT 22
3103: PUSH
3104: LD_INT 8
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: PUSH
3111: LD_INT 25
3113: PUSH
3114: LD_INT 17
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: PPUSH
3125: CALL_OW 70
3129: PUSH
3130: FOR_IN
3131: IFFALSE 3169
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , i ) ) ;
3133: LD_VAR 0 1
3137: PPUSH
3138: LD_INT 22
3140: PUSH
3141: LD_INT 6
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PPUSH
3148: CALL_OW 69
3152: PPUSH
3153: LD_VAR 0 1
3157: PPUSH
3158: CALL_OW 74
3162: PPUSH
3163: CALL_OW 115
3167: GO 3130
3169: POP
3170: POP
// end ;
3171: PPOPN 1
3173: END
// every 6 6$00 trigger legion_telep do var k , xy , i ;
3174: LD_INT 68
3176: IFFALSE 3407
3178: GO 3180
3180: DISABLE
3181: LD_INT 0
3183: PPUSH
3184: PPUSH
3185: PPUSH
// begin enable ;
3186: ENABLE
// xy := [ [ 224 , 5 ] , [ 160 , 4 ] , [ 228 , 56 ] , [ 271 , 87 ] ] ;
3187: LD_ADDR_VAR 0 2
3191: PUSH
3192: LD_INT 224
3194: PUSH
3195: LD_INT 5
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 160
3204: PUSH
3205: LD_INT 4
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 228
3214: PUSH
3215: LD_INT 56
3217: PUSH
3218: EMPTY
3219: LIST
3220: LIST
3221: PUSH
3222: LD_INT 271
3224: PUSH
3225: LD_INT 87
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: ST_TO_ADDR
// for i = 1 to 3 do
3238: LD_ADDR_VAR 0 3
3242: PUSH
3243: DOUBLE
3244: LD_INT 1
3246: DEC
3247: ST_TO_ADDR
3248: LD_INT 3
3250: PUSH
3251: FOR_TO
3252: IFFALSE 3268
// EraseResourceArea ( telArea , i ) ;
3254: LD_INT 7
3256: PPUSH
3257: LD_VAR 0 3
3261: PPUSH
3262: CALL_OW 286
3266: GO 3251
3268: POP
3269: POP
// for i = xy downto 1 do
3270: LD_ADDR_VAR 0 3
3274: PUSH
3275: DOUBLE
3276: LD_VAR 0 2
3280: INC
3281: ST_TO_ADDR
3282: LD_INT 1
3284: PUSH
3285: FOR_DOWNTO
3286: IFFALSE 3368
// begin k := rand ( 1 , xy ) ;
3288: LD_ADDR_VAR 0 1
3292: PUSH
3293: LD_INT 1
3295: PPUSH
3296: LD_VAR 0 2
3300: PPUSH
3301: CALL_OW 12
3305: ST_TO_ADDR
// if HexInfo ( xy [ k ] [ 1 ] , xy [ k ] [ 2 ] ) then
3306: LD_VAR 0 2
3310: PUSH
3311: LD_VAR 0 1
3315: ARRAY
3316: PUSH
3317: LD_INT 1
3319: ARRAY
3320: PPUSH
3321: LD_VAR 0 2
3325: PUSH
3326: LD_VAR 0 1
3330: ARRAY
3331: PUSH
3332: LD_INT 2
3334: ARRAY
3335: PPUSH
3336: CALL_OW 428
3340: IFFALSE 3364
// xy := Delete ( xy , k ) else
3342: LD_ADDR_VAR 0 2
3346: PUSH
3347: LD_VAR 0 2
3351: PPUSH
3352: LD_VAR 0 1
3356: PPUSH
3357: CALL_OW 3
3361: ST_TO_ADDR
3362: GO 3366
// break ;
3364: GO 3368
// end ;
3366: GO 3285
3368: POP
3369: POP
// TeleportExit ( legion_telep , xy [ k ] [ 1 ] , xy [ k ] [ 2 ] ) ;
3370: LD_INT 68
3372: PPUSH
3373: LD_VAR 0 2
3377: PUSH
3378: LD_VAR 0 1
3382: ARRAY
3383: PUSH
3384: LD_INT 1
3386: ARRAY
3387: PPUSH
3388: LD_VAR 0 2
3392: PUSH
3393: LD_VAR 0 1
3397: ARRAY
3398: PUSH
3399: LD_INT 2
3401: ARRAY
3402: PPUSH
3403: CALL_OW 243
// end ; end_of_file
3407: PPOPN 3
3409: END
// export function PrepareRussian ; var i , skill , un , tmp , amount , k ; begin
3410: LD_INT 0
3412: PPUSH
3413: PPUSH
3414: PPUSH
3415: PPUSH
3416: PPUSH
3417: PPUSH
3418: PPUSH
// uc_side := 6 ;
3419: LD_ADDR_OWVAR 20
3423: PUSH
3424: LD_INT 6
3426: ST_TO_ADDR
// uc_nation := nation_russian ;
3427: LD_ADDR_OWVAR 21
3431: PUSH
3432: LD_INT 3
3434: ST_TO_ADDR
// SetArtifactRes ( 6 , true ) ;
3435: LD_INT 6
3437: PPUSH
3438: LD_INT 1
3440: PPUSH
3441: CALL_OW 467
// amount := [ [ 9 , 4 ] , [ 8 , 3 ] , [ 8 , 2 ] ] [ Difficulty ] ;
3445: LD_ADDR_VAR 0 6
3449: PUSH
3450: LD_INT 9
3452: PUSH
3453: LD_INT 4
3455: PUSH
3456: EMPTY
3457: LIST
3458: LIST
3459: PUSH
3460: LD_INT 8
3462: PUSH
3463: LD_INT 3
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: PUSH
3470: LD_INT 8
3472: PUSH
3473: LD_INT 2
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: PUSH
3480: EMPTY
3481: LIST
3482: LIST
3483: LIST
3484: PUSH
3485: LD_OWVAR 67
3489: ARRAY
3490: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
3491: LD_ADDR_VAR 0 3
3495: PUSH
3496: LD_INT 9
3498: PUSH
3499: LD_INT 8
3501: PUSH
3502: LD_INT 7
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: PUSH
3510: LD_OWVAR 67
3514: ARRAY
3515: ST_TO_ADDR
// tmp := [ ] ;
3516: LD_ADDR_VAR 0 5
3520: PUSH
3521: EMPTY
3522: ST_TO_ADDR
// Davidov := NewCharacter ( Davidov ) ;
3523: LD_ADDR_EXP 2
3527: PUSH
3528: LD_STRING Davidov
3530: PPUSH
3531: CALL_OW 25
3535: ST_TO_ADDR
// SetSkill ( Davidov , 1 , 7 ) ;
3536: LD_EXP 2
3540: PPUSH
3541: LD_INT 1
3543: PPUSH
3544: LD_INT 7
3546: PPUSH
3547: CALL_OW 237
// SetSkill ( Davidov , 2 , 8 ) ;
3551: LD_EXP 2
3555: PPUSH
3556: LD_INT 2
3558: PPUSH
3559: LD_INT 8
3561: PPUSH
3562: CALL_OW 237
// SetSkill ( Davidov , 3 , 6 ) ;
3566: LD_EXP 2
3570: PPUSH
3571: LD_INT 3
3573: PPUSH
3574: LD_INT 6
3576: PPUSH
3577: CALL_OW 237
// SetSkill ( Davidov , 4 , 10 ) ;
3581: LD_EXP 2
3585: PPUSH
3586: LD_INT 4
3588: PPUSH
3589: LD_INT 10
3591: PPUSH
3592: CALL_OW 237
// SetClass ( Davidov , 4 ) ;
3596: LD_EXP 2
3600: PPUSH
3601: LD_INT 4
3603: PPUSH
3604: CALL_OW 336
// hc_importance := 0 ;
3608: LD_ADDR_OWVAR 32
3612: PUSH
3613: LD_INT 0
3615: ST_TO_ADDR
// while amount [ 1 ] do
3616: LD_VAR 0 6
3620: PUSH
3621: LD_INT 1
3623: ARRAY
3624: IFFALSE 3957
// begin Wait ( 1 ) ;
3626: LD_INT 1
3628: PPUSH
3629: CALL_OW 67
// k := rand ( 1 , 4 ) ;
3633: LD_ADDR_VAR 0 7
3637: PUSH
3638: LD_INT 1
3640: PPUSH
3641: LD_INT 4
3643: PPUSH
3644: CALL_OW 12
3648: ST_TO_ADDR
// if amount [ 2 ] and tmp then
3649: LD_VAR 0 6
3653: PUSH
3654: LD_INT 2
3656: ARRAY
3657: PUSH
3658: LD_VAR 0 5
3662: AND
3663: IFFALSE 3818
// begin if k in [ 1 , 2 ] then
3665: LD_VAR 0 7
3669: PUSH
3670: LD_INT 1
3672: PUSH
3673: LD_INT 2
3675: PUSH
3676: EMPTY
3677: LIST
3678: LIST
3679: IN
3680: IFFALSE 3690
// k := 3 ;
3682: LD_ADDR_VAR 0 7
3686: PUSH
3687: LD_INT 3
3689: ST_TO_ADDR
// vc_chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
3690: LD_ADDR_OWVAR 37
3694: PUSH
3695: LD_INT 22
3697: PUSH
3698: LD_INT 24
3700: PUSH
3701: EMPTY
3702: LIST
3703: LIST
3704: PUSH
3705: LD_INT 1
3707: PPUSH
3708: LD_INT 2
3710: PPUSH
3711: CALL_OW 12
3715: ARRAY
3716: ST_TO_ADDR
// vc_engine := engine_siberite ;
3717: LD_ADDR_OWVAR 39
3721: PUSH
3722: LD_INT 3
3724: ST_TO_ADDR
// vc_control := control_manual ;
3725: LD_ADDR_OWVAR 38
3729: PUSH
3730: LD_INT 1
3732: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_rocket_launcher , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ;
3733: LD_ADDR_OWVAR 40
3737: PUSH
3738: LD_INT 44
3740: PUSH
3741: LD_INT 45
3743: PUSH
3744: LD_INT 43
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: LIST
3751: PUSH
3752: LD_INT 1
3754: PPUSH
3755: LD_INT 3
3757: PPUSH
3758: CALL_OW 12
3762: ARRAY
3763: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , CreateVehicle ) ;
3764: LD_ADDR_VAR 0 5
3768: PUSH
3769: LD_VAR 0 5
3773: PPUSH
3774: LD_INT 1
3776: PPUSH
3777: CALL_OW 45
3781: PPUSH
3782: CALL_OW 2
3786: ST_TO_ADDR
// amount := Replace ( amount , 2 , amount [ 2 ] - 1 ) ;
3787: LD_ADDR_VAR 0 6
3791: PUSH
3792: LD_VAR 0 6
3796: PPUSH
3797: LD_INT 2
3799: PPUSH
3800: LD_VAR 0 6
3804: PUSH
3805: LD_INT 2
3807: ARRAY
3808: PUSH
3809: LD_INT 1
3811: MINUS
3812: PPUSH
3813: CALL_OW 1
3817: ST_TO_ADDR
// end ; if not tmp then
3818: LD_VAR 0 5
3822: NOT
3823: IFFALSE 3833
// k := 2 ;
3825: LD_ADDR_VAR 0 7
3829: PUSH
3830: LD_INT 2
3832: ST_TO_ADDR
// if amount [ 2 ] = 0 and k = 3 then
3833: LD_VAR 0 6
3837: PUSH
3838: LD_INT 2
3840: ARRAY
3841: PUSH
3842: LD_INT 0
3844: EQUAL
3845: PUSH
3846: LD_VAR 0 7
3850: PUSH
3851: LD_INT 3
3853: EQUAL
3854: AND
3855: IFFALSE 3884
// k := [ class_bazooker , class_scientistic ] [ rand ( 1 , 2 ) ] ;
3857: LD_ADDR_VAR 0 7
3861: PUSH
3862: LD_INT 9
3864: PUSH
3865: LD_INT 4
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 1
3874: PPUSH
3875: LD_INT 2
3877: PPUSH
3878: CALL_OW 12
3882: ARRAY
3883: ST_TO_ADDR
// PrepareHuman ( false , k , skill ) ;
3884: LD_INT 0
3886: PPUSH
3887: LD_VAR 0 7
3891: PPUSH
3892: LD_VAR 0 3
3896: PPUSH
3897: CALL_OW 380
// tmp := Insert ( tmp , 1 , CreateHuman ) ;
3901: LD_ADDR_VAR 0 5
3905: PUSH
3906: LD_VAR 0 5
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: CALL_OW 44
3918: PPUSH
3919: CALL_OW 2
3923: ST_TO_ADDR
// amount := Replace ( amount , 1 , amount [ 1 ] - 1 ) ;
3924: LD_ADDR_VAR 0 6
3928: PUSH
3929: LD_VAR 0 6
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: LD_VAR 0 6
3941: PUSH
3942: LD_INT 1
3944: ARRAY
3945: PUSH
3946: LD_INT 1
3948: MINUS
3949: PPUSH
3950: CALL_OW 1
3954: ST_TO_ADDR
// end ;
3955: GO 3616
// tmp := Insert ( tmp , tmp + 1 , Davidov ) ;
3957: LD_ADDR_VAR 0 5
3961: PUSH
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_VAR 0 5
3971: PUSH
3972: LD_INT 1
3974: PLUS
3975: PPUSH
3976: LD_EXP 2
3980: PPUSH
3981: CALL_OW 2
3985: ST_TO_ADDR
// for i = tmp downto 1 do
3986: LD_ADDR_VAR 0 2
3990: PUSH
3991: DOUBLE
3992: LD_VAR 0 5
3996: INC
3997: ST_TO_ADDR
3998: LD_INT 1
4000: PUSH
4001: FOR_DOWNTO
4002: IFFALSE 4164
// begin if GetType ( tmp [ i ] ) = unit_vehicle then
4004: LD_VAR 0 5
4008: PUSH
4009: LD_VAR 0 2
4013: ARRAY
4014: PPUSH
4015: CALL_OW 247
4019: PUSH
4020: LD_INT 2
4022: EQUAL
4023: IFFALSE 4113
// begin SetDir ( tmp [ i ] , 3 ) ;
4025: LD_VAR 0 5
4029: PUSH
4030: LD_VAR 0 2
4034: ARRAY
4035: PPUSH
4036: LD_INT 3
4038: PPUSH
4039: CALL_OW 233
// PlaceUnitXY ( tmp [ i ] , 193 , 3 , false ) ;
4043: LD_VAR 0 5
4047: PUSH
4048: LD_VAR 0 2
4052: ARRAY
4053: PPUSH
4054: LD_INT 193
4056: PPUSH
4057: LD_INT 3
4059: PPUSH
4060: LD_INT 0
4062: PPUSH
4063: CALL_OW 48
// PlaceHumanInUnit ( tmp [ i - 1 ] , tmp [ i ] ) ;
4067: LD_VAR 0 5
4071: PUSH
4072: LD_VAR 0 2
4076: PUSH
4077: LD_INT 1
4079: MINUS
4080: ARRAY
4081: PPUSH
4082: LD_VAR 0 5
4086: PUSH
4087: LD_VAR 0 2
4091: ARRAY
4092: PPUSH
4093: CALL_OW 52
// i := i - 1 ;
4097: LD_ADDR_VAR 0 2
4101: PUSH
4102: LD_VAR 0 2
4106: PUSH
4107: LD_INT 1
4109: MINUS
4110: ST_TO_ADDR
// end else
4111: GO 4134
// PlaceUnitArea ( tmp [ i ] , start_area , false ) ;
4113: LD_VAR 0 5
4117: PUSH
4118: LD_VAR 0 2
4122: ARRAY
4123: PPUSH
4124: LD_INT 2
4126: PPUSH
4127: LD_INT 0
4129: PPUSH
4130: CALL_OW 49
// ComMoveXY ( tmp [ i ] , 197 , 22 ) ;
4134: LD_VAR 0 5
4138: PUSH
4139: LD_VAR 0 2
4143: ARRAY
4144: PPUSH
4145: LD_INT 197
4147: PPUSH
4148: LD_INT 22
4150: PPUSH
4151: CALL_OW 111
// Wait ( 0 0$02 ) ;
4155: LD_INT 70
4157: PPUSH
4158: CALL_OW 67
// end ;
4162: GO 4001
4164: POP
4165: POP
// Wait ( 0 0$02 ) ;
4166: LD_INT 70
4168: PPUSH
4169: CALL_OW 67
// vc_chassis := ru_medium_tracked ;
4173: LD_ADDR_OWVAR 37
4177: PUSH
4178: LD_INT 22
4180: ST_TO_ADDR
// vc_engine := engine_siberite ;
4181: LD_ADDR_OWVAR 39
4185: PUSH
4186: LD_INT 3
4188: ST_TO_ADDR
// vc_control := control_computer ;
4189: LD_ADDR_OWVAR 38
4193: PUSH
4194: LD_INT 3
4196: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4197: LD_ADDR_OWVAR 40
4201: PUSH
4202: LD_INT 51
4204: ST_TO_ADDR
// tmp := CreateVehicle ;
4205: LD_ADDR_VAR 0 5
4209: PUSH
4210: CALL_OW 45
4214: ST_TO_ADDR
// SetDir ( tmp , 3 ) ;
4215: LD_VAR 0 5
4219: PPUSH
4220: LD_INT 3
4222: PPUSH
4223: CALL_OW 233
// PlaceUnitXY ( tmp , 193 , 3 , false ) ;
4227: LD_VAR 0 5
4231: PPUSH
4232: LD_INT 193
4234: PPUSH
4235: LD_INT 3
4237: PPUSH
4238: LD_INT 0
4240: PPUSH
4241: CALL_OW 48
// SetCargo ( tmp , mat_artifact , 60 ) ;
4245: LD_VAR 0 5
4249: PPUSH
4250: LD_INT 4
4252: PPUSH
4253: LD_INT 60
4255: PPUSH
4256: CALL_OW 290
// ComMoveXY ( tmp , 197 , 22 ) ;
4260: LD_VAR 0 5
4264: PPUSH
4265: LD_INT 197
4267: PPUSH
4268: LD_INT 22
4270: PPUSH
4271: CALL_OW 111
// end ; end_of_file
4275: LD_VAR 0 1
4279: RET
// on VehicleConstructed ( veh , fac ) do var side ;
4280: LD_INT 0
4282: PPUSH
// begin side := GetSide ( fac ) ;
4283: LD_ADDR_VAR 0 3
4287: PUSH
4288: LD_VAR 0 2
4292: PPUSH
4293: CALL_OW 255
4297: ST_TO_ADDR
// case side of 7 :
4298: LD_VAR 0 3
4302: PUSH
4303: LD_INT 7
4305: DOUBLE
4306: EQUAL
4307: IFTRUE 4311
4309: GO 4345
4311: POP
// begin al_force := al_force ^ veh ;
4312: LD_ADDR_EXP 32
4316: PUSH
4317: LD_EXP 32
4321: PUSH
4322: LD_VAR 0 1
4326: ADD
4327: ST_TO_ADDR
// AddComMoveXY ( veh , 112 , 175 ) ;
4328: LD_VAR 0 1
4332: PPUSH
4333: LD_INT 112
4335: PPUSH
4336: LD_INT 175
4338: PPUSH
4339: CALL_OW 171
// end ; 8 :
4343: GO 4431
4345: LD_INT 8
4347: DOUBLE
4348: EQUAL
4349: IFTRUE 4353
4351: GO 4430
4353: POP
// begin if GetWeapon ( veh ) = ar_control_tower then
4354: LD_VAR 0 1
4358: PPUSH
4359: CALL_OW 264
4363: PUSH
4364: LD_INT 31
4366: EQUAL
4367: IFFALSE 4384
// ComMoveXY ( veh , 145 , 66 ) ;
4369: LD_VAR 0 1
4373: PPUSH
4374: LD_INT 145
4376: PPUSH
4377: LD_INT 66
4379: PPUSH
4380: CALL_OW 111
// if GetChassis ( veh ) = ar_hovercraft then
4384: LD_VAR 0 1
4388: PPUSH
4389: CALL_OW 265
4393: PUSH
4394: LD_INT 11
4396: EQUAL
4397: IFFALSE 4428
// legion_force := Insert ( legion_force , legion_force + 1 , veh ) ;
4399: LD_ADDR_EXP 33
4403: PUSH
4404: LD_EXP 33
4408: PPUSH
4409: LD_EXP 33
4413: PUSH
4414: LD_INT 1
4416: PLUS
4417: PPUSH
4418: LD_VAR 0 1
4422: PPUSH
4423: CALL_OW 2
4427: ST_TO_ADDR
// end ; end ;
4428: GO 4431
4430: POP
// end ;
4431: PPOPN 3
4433: END
// on UnitTeleported ( b , un ) do begin if b = legion_telep and GetClass ( un ) = 17 then
4434: LD_VAR 0 1
4438: PUSH
4439: LD_INT 68
4441: EQUAL
4442: PUSH
4443: LD_VAR 0 2
4447: PPUSH
4448: CALL_OW 257
4452: PUSH
4453: LD_INT 17
4455: EQUAL
4456: AND
4457: IFFALSE 4500
// begin Wait ( 0 0$01 ) ;
4459: LD_INT 35
4461: PPUSH
4462: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , un ) ) ;
4466: LD_VAR 0 2
4470: PPUSH
4471: LD_INT 22
4473: PUSH
4474: LD_INT 6
4476: PUSH
4477: EMPTY
4478: LIST
4479: LIST
4480: PPUSH
4481: CALL_OW 69
4485: PPUSH
4486: LD_VAR 0 2
4490: PPUSH
4491: CALL_OW 74
4495: PPUSH
4496: CALL_OW 115
// end ; end ;
4500: PPOPN 2
4502: END
// on CrateSpawn ( id , x , y , amount , mode ) do var i , apes , n ;
4503: LD_INT 0
4505: PPUSH
4506: PPUSH
4507: PPUSH
// begin if InArea ( x , y , cratesArea ) and FilterUnitsInArea ( islandArea , [ f_enemy , 6 ] ) = 0 then
4508: LD_VAR 0 2
4512: PPUSH
4513: LD_VAR 0 3
4517: PPUSH
4518: LD_INT 3
4520: PPUSH
4521: CALL_OW 309
4525: PUSH
4526: LD_INT 6
4528: PPUSH
4529: LD_INT 81
4531: PUSH
4532: LD_INT 6
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: PPUSH
4539: CALL_OW 70
4543: PUSH
4544: LD_INT 0
4546: EQUAL
4547: AND
4548: IFFALSE 4711
// begin apes := FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 16 ] ] ) ;
4550: LD_ADDR_VAR 0 7
4554: PUSH
4555: LD_INT 22
4557: PUSH
4558: LD_INT 6
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: PUSH
4565: LD_INT 25
4567: PUSH
4568: LD_INT 16
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PPUSH
4579: CALL_OW 69
4583: ST_TO_ADDR
// if apes = 0 or FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 then
4584: LD_VAR 0 7
4588: PUSH
4589: LD_INT 0
4591: EQUAL
4592: PUSH
4593: LD_INT 22
4595: PUSH
4596: LD_INT 6
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: PUSH
4603: LD_INT 2
4605: PUSH
4606: LD_INT 30
4608: PUSH
4609: LD_INT 0
4611: PUSH
4612: EMPTY
4613: LIST
4614: LIST
4615: PUSH
4616: LD_INT 30
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: EMPTY
4632: LIST
4633: LIST
4634: PPUSH
4635: CALL_OW 69
4639: PUSH
4640: LD_INT 0
4642: EQUAL
4643: OR
4644: IFFALSE 4648
// exit ;
4646: GO 4711
// if UnitFilter ( apes , [ f_inside ] ) then
4648: LD_VAR 0 7
4652: PPUSH
4653: LD_INT 54
4655: PUSH
4656: EMPTY
4657: LIST
4658: PPUSH
4659: CALL_OW 72
4663: IFFALSE 4692
// begin ComExitBuilding ( UnitFilter ( apes , [ f_inside ] ) ) ;
4665: LD_VAR 0 7
4669: PPUSH
4670: LD_INT 54
4672: PUSH
4673: EMPTY
4674: LIST
4675: PPUSH
4676: CALL_OW 72
4680: PPUSH
4681: CALL_OW 122
// wait ( 3 ) ;
4685: LD_INT 3
4687: PPUSH
4688: CALL_OW 67
// end ; AddComCollect ( apes , x , y ) ;
4692: LD_VAR 0 7
4696: PPUSH
4697: LD_VAR 0 2
4701: PPUSH
4702: LD_VAR 0 3
4706: PPUSH
4707: CALL_OW 177
// end ; end ;
4711: PPOPN 8
4713: END
// on UnitGoesToRed ( un ) do begin if un in al_force then
4714: LD_VAR 0 1
4718: PUSH
4719: LD_EXP 32
4723: IN
4724: IFFALSE 4742
// al_force := al_force diff un ;
4726: LD_ADDR_EXP 32
4730: PUSH
4731: LD_EXP 32
4735: PUSH
4736: LD_VAR 0 1
4740: DIFF
4741: ST_TO_ADDR
// if GetControl ( un ) = control_remote then
4742: LD_VAR 0 1
4746: PPUSH
4747: CALL_OW 263
4751: PUSH
4752: LD_INT 2
4754: EQUAL
4755: IFFALSE 4766
// ComUnlink ( un ) ;
4757: LD_VAR 0 1
4761: PPUSH
4762: CALL_OW 136
// end ;
4766: PPOPN 1
4768: END
// on ResearchStarted ( tech , lab ) do begin if tech = tech_sibfiss then
4769: LD_VAR 0 1
4773: PUSH
4774: LD_INT 25
4776: EQUAL
4777: IFFALSE 4787
// player_start_res_sib_bomb := true ;
4779: LD_ADDR_EXP 4
4783: PUSH
4784: LD_INT 1
4786: ST_TO_ADDR
// if tech = tech_artifact then
4787: LD_VAR 0 1
4791: PUSH
4792: LD_INT 24
4794: EQUAL
4795: IFFALSE 4805
// player_start_res_artifact := true ;
4797: LD_ADDR_EXP 5
4801: PUSH
4802: LD_INT 1
4804: ST_TO_ADDR
// end ;
4805: PPOPN 2
4807: END
// on ArtifactUnloaded ( cargo , artifact_num ) do begin if artifact_num = 6 then
4808: LD_VAR 0 2
4812: PUSH
4813: LD_INT 6
4815: EQUAL
4816: IFFALSE 4826
// player_artifact_loaded := false ;
4818: LD_ADDR_EXP 18
4822: PUSH
4823: LD_INT 0
4825: ST_TO_ADDR
// end ;
4826: PPOPN 2
4828: END
// on ArtifactLoaded ( cargo , artifact_num ) do begin if artifact_num = 6 then
4829: LD_VAR 0 2
4833: PUSH
4834: LD_INT 6
4836: EQUAL
4837: IFFALSE 4847
// player_artifact_loaded := true ;
4839: LD_ADDR_EXP 18
4843: PUSH
4844: LD_INT 1
4846: ST_TO_ADDR
// end ;
4847: PPOPN 2
4849: END
// on SiberiteRocketExploded ( rocket , x , y ) do var i ;
4850: LD_INT 0
4852: PPUSH
// begin player_used_sib_bomb := true ;
4853: LD_ADDR_EXP 12
4857: PUSH
4858: LD_INT 1
4860: ST_TO_ADDR
// for i = 1 to 3 do
4861: LD_ADDR_VAR 0 4
4865: PUSH
4866: DOUBLE
4867: LD_INT 1
4869: DEC
4870: ST_TO_ADDR
4871: LD_INT 3
4873: PUSH
4874: FOR_TO
4875: IFFALSE 4948
// begin if GetDistXY ( x , y , artifacts_pos [ i ] [ 1 ] , artifacts_pos [ i ] [ 2 ] ) <= sib_rocket_range then
4877: LD_VAR 0 2
4881: PPUSH
4882: LD_VAR 0 3
4886: PPUSH
4887: LD_EXP 15
4891: PUSH
4892: LD_VAR 0 4
4896: ARRAY
4897: PUSH
4898: LD_INT 1
4900: ARRAY
4901: PPUSH
4902: LD_EXP 15
4906: PUSH
4907: LD_VAR 0 4
4911: ARRAY
4912: PUSH
4913: LD_INT 2
4915: ARRAY
4916: PPUSH
4917: CALL_OW 298
4921: PUSH
4922: LD_EXP 17
4926: LESSEQUAL
4927: IFFALSE 4946
// begin wait ( 0 0$5 ) ;
4929: LD_INT 175
4931: PPUSH
4932: CALL_OW 67
// artifact_destroyed := true ;
4936: LD_ADDR_EXP 16
4940: PUSH
4941: LD_INT 1
4943: ST_TO_ADDR
// break ;
4944: GO 4948
// end ; end ;
4946: GO 4874
4948: POP
4949: POP
// end ; end_of_file
4950: PPOPN 4
4952: END
// export function CreateArtifact ( type , x , y ) ; begin
4953: LD_INT 0
4955: PPUSH
// CreateResourcesXY ( mat_artifact , type , x , y , false ) ;
4956: LD_INT 4
4958: PPUSH
4959: LD_VAR 0 1
4963: PPUSH
4964: LD_VAR 0 2
4968: PPUSH
4969: LD_VAR 0 3
4973: PPUSH
4974: LD_INT 0
4976: PPUSH
4977: CALL_OW 58
// end ;
4981: LD_VAR 0 4
4985: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
4986: LD_INT 0
4988: PPUSH
4989: PPUSH
4990: PPUSH
// if not GetControl ( veh ) = control_manual then
4991: LD_VAR 0 1
4995: PPUSH
4996: CALL_OW 263
5000: PUSH
5001: LD_INT 1
5003: EQUAL
5004: NOT
5005: IFFALSE 5017
// result := false else
5007: LD_ADDR_VAR 0 2
5011: PUSH
5012: LD_INT 0
5014: ST_TO_ADDR
5015: GO 5162
// if veh in FilterAllUnits ( [ f_empty ] ) then
5017: LD_VAR 0 1
5021: PUSH
5022: LD_INT 58
5024: PUSH
5025: EMPTY
5026: LIST
5027: PPUSH
5028: CALL_OW 69
5032: IN
5033: IFFALSE 5045
// result := false else
5035: LD_ADDR_VAR 0 2
5039: PUSH
5040: LD_INT 0
5042: ST_TO_ADDR
5043: GO 5162
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5045: LD_ADDR_VAR 0 4
5049: PUSH
5050: LD_INT 22
5052: PUSH
5053: LD_VAR 0 1
5057: PPUSH
5058: CALL_OW 255
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: PUSH
5067: LD_INT 55
5069: PUSH
5070: EMPTY
5071: LIST
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PPUSH
5077: CALL_OW 69
5081: ST_TO_ADDR
// if not filter then
5082: LD_VAR 0 4
5086: NOT
5087: IFFALSE 5099
// result := false else
5089: LD_ADDR_VAR 0 2
5093: PUSH
5094: LD_INT 0
5096: ST_TO_ADDR
5097: GO 5162
// for i = 1 to filter do
5099: LD_ADDR_VAR 0 3
5103: PUSH
5104: DOUBLE
5105: LD_INT 1
5107: DEC
5108: ST_TO_ADDR
5109: LD_VAR 0 4
5113: PUSH
5114: FOR_TO
5115: IFFALSE 5160
// if IsDriver ( filter [ i ] ) = veh then
5117: LD_VAR 0 4
5121: PUSH
5122: LD_VAR 0 3
5126: ARRAY
5127: PPUSH
5128: CALL 5506 0 1
5132: PUSH
5133: LD_VAR 0 1
5137: EQUAL
5138: IFFALSE 5158
// begin result := filter [ i ] ;
5140: LD_ADDR_VAR 0 2
5144: PUSH
5145: LD_VAR 0 4
5149: PUSH
5150: LD_VAR 0 3
5154: ARRAY
5155: ST_TO_ADDR
// break ;
5156: GO 5160
// end ;
5158: GO 5114
5160: POP
5161: POP
// end ; end ;
5162: LD_VAR 0 2
5166: RET
// export function GetSibResources ( side ) ; var i , deps ; begin
5167: LD_INT 0
5169: PPUSH
5170: PPUSH
5171: PPUSH
// result := 0 ;
5172: LD_ADDR_VAR 0 2
5176: PUSH
5177: LD_INT 0
5179: ST_TO_ADDR
// deps := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5180: LD_ADDR_VAR 0 4
5184: PUSH
5185: LD_INT 22
5187: PUSH
5188: LD_VAR 0 1
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 2
5199: PUSH
5200: LD_INT 30
5202: PUSH
5203: LD_INT 0
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 30
5212: PUSH
5213: LD_INT 1
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: LIST
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: PPUSH
5229: CALL_OW 69
5233: ST_TO_ADDR
// if deps then
5234: LD_VAR 0 4
5238: IFFALSE 5286
// for i in deps do
5240: LD_ADDR_VAR 0 3
5244: PUSH
5245: LD_VAR 0 4
5249: PUSH
5250: FOR_IN
5251: IFFALSE 5284
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
5253: LD_ADDR_VAR 0 2
5257: PUSH
5258: LD_VAR 0 2
5262: PUSH
5263: LD_VAR 0 3
5267: PPUSH
5268: CALL_OW 274
5272: PPUSH
5273: LD_INT 3
5275: PPUSH
5276: CALL_OW 275
5280: PLUS
5281: ST_TO_ADDR
5282: GO 5250
5284: POP
5285: POP
// end ;
5286: LD_VAR 0 2
5290: RET
// export function SetSibResources ( side , val ) ; var i , deps , s ; begin
5291: LD_INT 0
5293: PPUSH
5294: PPUSH
5295: PPUSH
5296: PPUSH
// if val <= 0 then
5297: LD_VAR 0 2
5301: PUSH
5302: LD_INT 0
5304: LESSEQUAL
5305: IFFALSE 5309
// exit ;
5307: GO 5501
// deps := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5309: LD_ADDR_VAR 0 5
5313: PUSH
5314: LD_INT 22
5316: PUSH
5317: LD_VAR 0 1
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: PUSH
5326: LD_INT 2
5328: PUSH
5329: LD_INT 30
5331: PUSH
5332: LD_INT 0
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: PUSH
5339: LD_INT 30
5341: PUSH
5342: LD_INT 1
5344: PUSH
5345: EMPTY
5346: LIST
5347: LIST
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: LIST
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PPUSH
5358: CALL_OW 69
5362: ST_TO_ADDR
// if deps then
5363: LD_VAR 0 5
5367: IFFALSE 5501
// for i in deps do
5369: LD_ADDR_VAR 0 4
5373: PUSH
5374: LD_VAR 0 5
5378: PUSH
5379: FOR_IN
5380: IFFALSE 5499
// begin s := GetResourceType ( GetBase ( i ) , mat_siberit ) ;
5382: LD_ADDR_VAR 0 6
5386: PUSH
5387: LD_VAR 0 4
5391: PPUSH
5392: CALL_OW 274
5396: PPUSH
5397: LD_INT 3
5399: PPUSH
5400: CALL_OW 275
5404: ST_TO_ADDR
// if val < s then
5405: LD_VAR 0 2
5409: PUSH
5410: LD_VAR 0 6
5414: LESS
5415: IFFALSE 5461
// begin s := s - val ;
5417: LD_ADDR_VAR 0 6
5421: PUSH
5422: LD_VAR 0 6
5426: PUSH
5427: LD_VAR 0 2
5431: MINUS
5432: ST_TO_ADDR
// SetResourceType ( GetBase ( i ) , mat_siberit , s ) ;
5433: LD_VAR 0 4
5437: PPUSH
5438: CALL_OW 274
5442: PPUSH
5443: LD_INT 3
5445: PPUSH
5446: LD_VAR 0 6
5450: PPUSH
5451: CALL_OW 277
// exit ;
5455: POP
5456: POP
5457: GO 5501
// end else
5459: GO 5497
// begin val := val - s ;
5461: LD_ADDR_VAR 0 2
5465: PUSH
5466: LD_VAR 0 2
5470: PUSH
5471: LD_VAR 0 6
5475: MINUS
5476: ST_TO_ADDR
// SetResourceType ( GetBase ( i ) , mat_siberit , 0 ) ;
5477: LD_VAR 0 4
5481: PPUSH
5482: CALL_OW 274
5486: PPUSH
5487: LD_INT 3
5489: PPUSH
5490: LD_INT 0
5492: PPUSH
5493: CALL_OW 277
// end ; end ;
5497: GO 5379
5499: POP
5500: POP
// end ;
5501: LD_VAR 0 3
5505: RET
// export function IsDriver ( unit ) ; begin
5506: LD_INT 0
5508: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5509: LD_VAR 0 1
5513: PUSH
5514: LD_INT 55
5516: PUSH
5517: EMPTY
5518: LIST
5519: PPUSH
5520: CALL_OW 69
5524: IN
5525: IFFALSE 5544
// result := IsInUnit ( unit ) else
5527: LD_ADDR_VAR 0 2
5531: PUSH
5532: LD_VAR 0 1
5536: PPUSH
5537: CALL_OW 310
5541: ST_TO_ADDR
5542: GO 5552
// result := false ;
5544: LD_ADDR_VAR 0 2
5548: PUSH
5549: LD_INT 0
5551: ST_TO_ADDR
// end ;
5552: LD_VAR 0 2
5556: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
5557: LD_INT 0
5559: PPUSH
5560: PPUSH
5561: PPUSH
5562: PPUSH
// if pos < 1 then
5563: LD_VAR 0 2
5567: PUSH
5568: LD_INT 1
5570: LESS
5571: IFFALSE 5575
// exit ;
5573: GO 5878
// if pos = 1 then
5575: LD_VAR 0 2
5579: PUSH
5580: LD_INT 1
5582: EQUAL
5583: IFFALSE 5616
// result := Replace ( arr , pos [ 1 ] , value ) else
5585: LD_ADDR_VAR 0 4
5589: PUSH
5590: LD_VAR 0 1
5594: PPUSH
5595: LD_VAR 0 2
5599: PUSH
5600: LD_INT 1
5602: ARRAY
5603: PPUSH
5604: LD_VAR 0 3
5608: PPUSH
5609: CALL_OW 1
5613: ST_TO_ADDR
5614: GO 5878
// begin tmp := arr ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: LD_VAR 0 1
5625: ST_TO_ADDR
// s_arr := [ tmp ] ;
5626: LD_ADDR_VAR 0 7
5630: PUSH
5631: LD_VAR 0 6
5635: PUSH
5636: EMPTY
5637: LIST
5638: ST_TO_ADDR
// for i = 1 to pos - 1 do
5639: LD_ADDR_VAR 0 5
5643: PUSH
5644: DOUBLE
5645: LD_INT 1
5647: DEC
5648: ST_TO_ADDR
5649: LD_VAR 0 2
5653: PUSH
5654: LD_INT 1
5656: MINUS
5657: PUSH
5658: FOR_TO
5659: IFFALSE 5704
// begin tmp := tmp [ pos [ i ] ] ;
5661: LD_ADDR_VAR 0 6
5665: PUSH
5666: LD_VAR 0 6
5670: PUSH
5671: LD_VAR 0 2
5675: PUSH
5676: LD_VAR 0 5
5680: ARRAY
5681: ARRAY
5682: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
5683: LD_ADDR_VAR 0 7
5687: PUSH
5688: LD_VAR 0 7
5692: PUSH
5693: LD_VAR 0 6
5697: PUSH
5698: EMPTY
5699: LIST
5700: ADD
5701: ST_TO_ADDR
// end ;
5702: GO 5658
5704: POP
5705: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
5706: LD_ADDR_VAR 0 6
5710: PUSH
5711: LD_VAR 0 6
5715: PPUSH
5716: LD_VAR 0 2
5720: PUSH
5721: LD_VAR 0 2
5725: ARRAY
5726: PPUSH
5727: LD_VAR 0 3
5731: PPUSH
5732: CALL_OW 1
5736: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
5737: LD_ADDR_VAR 0 7
5741: PUSH
5742: LD_VAR 0 7
5746: PPUSH
5747: LD_VAR 0 7
5751: PPUSH
5752: LD_VAR 0 6
5756: PPUSH
5757: CALL_OW 1
5761: ST_TO_ADDR
// for i = s_arr downto 2 do
5762: LD_ADDR_VAR 0 5
5766: PUSH
5767: DOUBLE
5768: LD_VAR 0 7
5772: INC
5773: ST_TO_ADDR
5774: LD_INT 2
5776: PUSH
5777: FOR_DOWNTO
5778: IFFALSE 5862
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
5780: LD_ADDR_VAR 0 6
5784: PUSH
5785: LD_VAR 0 7
5789: PUSH
5790: LD_VAR 0 5
5794: PUSH
5795: LD_INT 1
5797: MINUS
5798: ARRAY
5799: PPUSH
5800: LD_VAR 0 2
5804: PUSH
5805: LD_VAR 0 5
5809: PUSH
5810: LD_INT 1
5812: MINUS
5813: ARRAY
5814: PPUSH
5815: LD_VAR 0 7
5819: PUSH
5820: LD_VAR 0 5
5824: ARRAY
5825: PPUSH
5826: CALL_OW 1
5830: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
5831: LD_ADDR_VAR 0 7
5835: PUSH
5836: LD_VAR 0 7
5840: PPUSH
5841: LD_VAR 0 5
5845: PUSH
5846: LD_INT 1
5848: MINUS
5849: PPUSH
5850: LD_VAR 0 6
5854: PPUSH
5855: CALL_OW 1
5859: ST_TO_ADDR
// end ;
5860: GO 5777
5862: POP
5863: POP
// result := s_arr [ 1 ] ;
5864: LD_ADDR_VAR 0 4
5868: PUSH
5869: LD_VAR 0 7
5873: PUSH
5874: LD_INT 1
5876: ARRAY
5877: ST_TO_ADDR
// end ; end ;
5878: LD_VAR 0 4
5882: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
5883: LD_VAR 0 1
5887: PUSH
5888: LD_EXP 35
5892: IN
5893: NOT
5894: IFFALSE 5925
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
5896: LD_ADDR_EXP 35
5900: PUSH
5901: LD_EXP 35
5905: PPUSH
5906: LD_EXP 35
5910: PUSH
5911: LD_INT 1
5913: PLUS
5914: PPUSH
5915: LD_VAR 0 1
5919: PPUSH
5920: CALL_OW 2
5924: ST_TO_ADDR
// end ;
5925: PPOPN 1
5927: END
// export function DestinationReachable ( unit , x , y ) ; begin
5928: LD_INT 0
5930: PPUSH
// if unit in unreachableList then
5931: LD_VAR 0 1
5935: PUSH
5936: LD_EXP 35
5940: IN
5941: IFFALSE 5959
// unreachableList := unreachableList diff unit ;
5943: LD_ADDR_EXP 35
5947: PUSH
5948: LD_EXP 35
5952: PUSH
5953: LD_VAR 0 1
5957: DIFF
5958: ST_TO_ADDR
// if ValidHex ( x , y ) then
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_VAR 0 3
5968: PPUSH
5969: CALL_OW 488
5973: IFFALSE 5999
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
5975: LD_VAR 0 1
5979: PPUSH
5980: LD_VAR 0 2
5984: PPUSH
5985: LD_VAR 0 3
5989: PPUSH
5990: CALL_OW 428
5994: PPUSH
5995: CALL_OW 115
// Wait ( 3 ) ;
5999: LD_INT 3
6001: PPUSH
6002: CALL_OW 67
// if unit in unreachableList then
6006: LD_VAR 0 1
6010: PUSH
6011: LD_EXP 35
6015: IN
6016: IFFALSE 6028
// result := false else
6018: LD_ADDR_VAR 0 4
6022: PUSH
6023: LD_INT 0
6025: ST_TO_ADDR
6026: GO 6036
// result := true ;
6028: LD_ADDR_VAR 0 4
6032: PUSH
6033: LD_INT 1
6035: ST_TO_ADDR
// end ;
6036: LD_VAR 0 4
6040: RET
// export function ComBombAttack ( unit , side ) ; var i , enemy , t , x , y , change_target_counter , last_target ; begin
6041: LD_INT 0
6043: PPUSH
6044: PPUSH
6045: PPUSH
6046: PPUSH
6047: PPUSH
6048: PPUSH
6049: PPUSH
6050: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 22
6058: PUSH
6059: LD_VAR 0 2
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 69
6072: ST_TO_ADDR
// change_target_counter := 0 ;
6073: LD_ADDR_VAR 0 9
6077: PUSH
6078: LD_INT 0
6080: ST_TO_ADDR
// last_target := 0 ;
6081: LD_ADDR_VAR 0 10
6085: PUSH
6086: LD_INT 0
6088: ST_TO_ADDR
// if not enemy then
6089: LD_VAR 0 5
6093: NOT
6094: IFFALSE 6098
// exit ;
6096: GO 6303
// while ( IsLive ( unit ) and change_target_counter < 4 ) do
6098: LD_VAR 0 1
6102: PPUSH
6103: CALL_OW 300
6107: PUSH
6108: LD_VAR 0 9
6112: PUSH
6113: LD_INT 4
6115: LESS
6116: AND
6117: IFFALSE 6303
// begin if UnitFilter ( enemy , [ f_occupied ] ) then
6119: LD_VAR 0 5
6123: PPUSH
6124: LD_INT 59
6126: PUSH
6127: EMPTY
6128: LIST
6129: PPUSH
6130: CALL_OW 72
6134: IFFALSE 6270
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
6136: LD_ADDR_VAR 0 6
6140: PUSH
6141: LD_VAR 0 5
6145: PPUSH
6146: LD_INT 59
6148: PUSH
6149: EMPTY
6150: LIST
6151: PPUSH
6152: CALL_OW 72
6156: PPUSH
6157: LD_VAR 0 1
6161: PPUSH
6162: CALL_OW 74
6166: ST_TO_ADDR
// if ( last_target <> t ) then
6167: LD_VAR 0 10
6171: PUSH
6172: LD_VAR 0 6
6176: NONEQUAL
6177: IFFALSE 6193
// change_target_counter := change_target_counter + 1 ;
6179: LD_ADDR_VAR 0 9
6183: PUSH
6184: LD_VAR 0 9
6188: PUSH
6189: LD_INT 1
6191: PLUS
6192: ST_TO_ADDR
// last_target := t ;
6193: LD_ADDR_VAR 0 10
6197: PUSH
6198: LD_VAR 0 6
6202: ST_TO_ADDR
// x := GetX ( t ) ;
6203: LD_ADDR_VAR 0 7
6207: PUSH
6208: LD_VAR 0 6
6212: PPUSH
6213: CALL_OW 250
6217: ST_TO_ADDR
// y := GetY ( t ) ;
6218: LD_ADDR_VAR 0 8
6222: PUSH
6223: LD_VAR 0 6
6227: PPUSH
6228: CALL_OW 251
6232: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6233: LD_VAR 0 1
6237: PPUSH
6238: LD_VAR 0 7
6242: PPUSH
6243: LD_VAR 0 8
6247: PPUSH
6248: CALL 5928 0 3
6252: IFFALSE 6268
// ComAttackUnit ( unit , t ) ;
6254: LD_VAR 0 1
6258: PPUSH
6259: LD_VAR 0 6
6263: PPUSH
6264: CALL_OW 115
// end else
6268: GO 6294
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
6270: LD_VAR 0 1
6274: PPUSH
6275: LD_VAR 0 5
6279: PPUSH
6280: LD_VAR 0 1
6284: PPUSH
6285: CALL_OW 74
6289: PPUSH
6290: CALL_OW 115
// Wait ( 0 0$0.3 ) ;
6294: LD_INT 10
6296: PPUSH
6297: CALL_OW 67
// end ;
6301: GO 6098
// end ;
6303: LD_VAR 0 3
6307: RET
// export function ComBrutalAttack ( units , side ) ; var i , enemy , t , x , y , target , unit ; begin
6308: LD_INT 0
6310: PPUSH
6311: PPUSH
6312: PPUSH
6313: PPUSH
6314: PPUSH
6315: PPUSH
6316: PPUSH
6317: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
6318: LD_ADDR_VAR 0 5
6322: PUSH
6323: LD_INT 22
6325: PUSH
6326: LD_VAR 0 2
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PPUSH
6335: CALL_OW 69
6339: ST_TO_ADDR
// target := 0 ;
6340: LD_ADDR_VAR 0 9
6344: PUSH
6345: LD_INT 0
6347: ST_TO_ADDR
// if not enemy then
6348: LD_VAR 0 5
6352: NOT
6353: IFFALSE 6357
// exit ;
6355: GO 7012
// while units do
6357: LD_VAR 0 1
6361: IFFALSE 7012
// begin wait ( 0 0$0.3 ) ;
6363: LD_INT 10
6365: PPUSH
6366: CALL_OW 67
// for unit in units do
6370: LD_ADDR_VAR 0 10
6374: PUSH
6375: LD_VAR 0 1
6379: PUSH
6380: FOR_IN
6381: IFFALSE 7008
// begin if not IsPlaced ( unit ) then
6383: LD_VAR 0 10
6387: PPUSH
6388: CALL_OW 305
6392: NOT
6393: IFFALSE 6413
// begin units := units diff unit ;
6395: LD_ADDR_VAR 0 1
6399: PUSH
6400: LD_VAR 0 1
6404: PUSH
6405: LD_VAR 0 10
6409: DIFF
6410: ST_TO_ADDR
// continue ;
6411: GO 6380
// end ; if not IsPlaced ( target ) then
6413: LD_VAR 0 9
6417: PPUSH
6418: CALL_OW 305
6422: NOT
6423: IFFALSE 6433
// target := 0 ;
6425: LD_ADDR_VAR 0 9
6429: PUSH
6430: LD_INT 0
6432: ST_TO_ADDR
// if not target and UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) then
6433: LD_VAR 0 9
6437: NOT
6438: PUSH
6439: LD_VAR 0 5
6443: PPUSH
6444: LD_INT 21
6446: PUSH
6447: LD_INT 1
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 3
6456: PUSH
6457: LD_INT 54
6459: PUSH
6460: EMPTY
6461: LIST
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PPUSH
6471: CALL_OW 72
6475: AND
6476: IFFALSE 6738
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , unit ) ;
6478: LD_ADDR_VAR 0 6
6482: PUSH
6483: LD_VAR 0 5
6487: PPUSH
6488: LD_INT 21
6490: PUSH
6491: LD_INT 1
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 3
6500: PUSH
6501: LD_INT 54
6503: PUSH
6504: EMPTY
6505: LIST
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: PPUSH
6515: CALL_OW 72
6519: PPUSH
6520: LD_VAR 0 10
6524: PPUSH
6525: CALL_OW 74
6529: ST_TO_ADDR
// x := GetX ( t ) ;
6530: LD_ADDR_VAR 0 7
6534: PUSH
6535: LD_VAR 0 6
6539: PPUSH
6540: CALL_OW 250
6544: ST_TO_ADDR
// y := GetY ( t ) ;
6545: LD_ADDR_VAR 0 8
6549: PUSH
6550: LD_VAR 0 6
6554: PPUSH
6555: CALL_OW 251
6559: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6560: LD_VAR 0 10
6564: PPUSH
6565: LD_VAR 0 7
6569: PPUSH
6570: LD_VAR 0 8
6574: PPUSH
6575: CALL 5928 0 3
6579: IFFALSE 6593
// target := t else
6581: LD_ADDR_VAR 0 9
6585: PUSH
6586: LD_VAR 0 6
6590: ST_TO_ADDR
6591: GO 6738
// if UnitFilter ( enemy , [ f_occupied ] ) then
6593: LD_VAR 0 5
6597: PPUSH
6598: LD_INT 59
6600: PUSH
6601: EMPTY
6602: LIST
6603: PPUSH
6604: CALL_OW 72
6608: IFFALSE 6738
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
6610: LD_ADDR_VAR 0 6
6614: PUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_INT 59
6622: PUSH
6623: EMPTY
6624: LIST
6625: PPUSH
6626: CALL_OW 72
6630: PPUSH
6631: LD_VAR 0 10
6635: PPUSH
6636: CALL_OW 74
6640: ST_TO_ADDR
// x := GetX ( t ) ;
6641: LD_ADDR_VAR 0 7
6645: PUSH
6646: LD_VAR 0 6
6650: PPUSH
6651: CALL_OW 250
6655: ST_TO_ADDR
// y := GetY ( t ) ;
6656: LD_ADDR_VAR 0 8
6660: PUSH
6661: LD_VAR 0 6
6665: PPUSH
6666: CALL_OW 251
6670: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6671: LD_VAR 0 10
6675: PPUSH
6676: LD_VAR 0 7
6680: PPUSH
6681: LD_VAR 0 8
6685: PPUSH
6686: CALL 5928 0 3
6690: IFFALSE 6704
// target := t else
6692: LD_ADDR_VAR 0 9
6696: PUSH
6697: LD_VAR 0 6
6701: ST_TO_ADDR
6702: GO 6738
// ComAttackUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , unit ) ) ;
6704: LD_VAR 0 10
6708: PPUSH
6709: LD_INT 22
6711: PUSH
6712: LD_INT 6
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: PPUSH
6719: CALL_OW 69
6723: PPUSH
6724: LD_VAR 0 10
6728: PPUSH
6729: CALL_OW 74
6733: PPUSH
6734: CALL_OW 115
// end ; end ; if not target or not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
6738: LD_VAR 0 9
6742: NOT
6743: PUSH
6744: LD_VAR 0 10
6748: PPUSH
6749: LD_VAR 0 9
6753: PPUSH
6754: CALL_OW 250
6758: PPUSH
6759: LD_VAR 0 9
6763: PPUSH
6764: CALL_OW 251
6768: PPUSH
6769: CALL 5928 0 3
6773: NOT
6774: OR
6775: IFFALSE 6809
// target := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
6777: LD_ADDR_VAR 0 9
6781: PUSH
6782: LD_INT 22
6784: PUSH
6785: LD_VAR 0 2
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PPUSH
6794: CALL_OW 69
6798: PPUSH
6799: LD_VAR 0 10
6803: PPUSH
6804: CALL_OW 74
6808: ST_TO_ADDR
// if ( GetDistUnits ( target , unit ) < 4 and GetLives ( unit ) < 600 ) or ( GetLives ( unit ) < 200 and GetSide ( NearestUnitToUnit ( all_units diff unit , unit ) ) <> GetSide ( unit ) ) then
6809: LD_VAR 0 9
6813: PPUSH
6814: LD_VAR 0 10
6818: PPUSH
6819: CALL_OW 296
6823: PUSH
6824: LD_INT 4
6826: LESS
6827: PUSH
6828: LD_VAR 0 10
6832: PPUSH
6833: CALL_OW 256
6837: PUSH
6838: LD_INT 600
6840: LESS
6841: AND
6842: PUSH
6843: LD_VAR 0 10
6847: PPUSH
6848: CALL_OW 256
6852: PUSH
6853: LD_INT 200
6855: LESS
6856: PUSH
6857: LD_OWVAR 3
6861: PUSH
6862: LD_VAR 0 10
6866: DIFF
6867: PPUSH
6868: LD_VAR 0 10
6872: PPUSH
6873: CALL_OW 74
6877: PPUSH
6878: CALL_OW 255
6882: PUSH
6883: LD_VAR 0 10
6887: PPUSH
6888: CALL_OW 255
6892: NONEQUAL
6893: AND
6894: OR
6895: IFFALSE 6946
// begin for i = 1 to 4 do
6897: LD_ADDR_VAR 0 4
6901: PUSH
6902: DOUBLE
6903: LD_INT 1
6905: DEC
6906: ST_TO_ADDR
6907: LD_INT 4
6909: PUSH
6910: FOR_TO
6911: IFFALSE 6942
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
6913: LD_VAR 0 10
6917: PPUSH
6918: CALL_OW 250
6922: PPUSH
6923: LD_VAR 0 10
6927: PPUSH
6928: CALL_OW 251
6932: PPUSH
6933: LD_INT 1
6935: PPUSH
6936: CALL_OW 453
6940: GO 6910
6942: POP
6943: POP
// end else
6944: GO 7006
// if GetType ( target ) <> unit_human then
6946: LD_VAR 0 9
6950: PPUSH
6951: CALL_OW 247
6955: PUSH
6956: LD_INT 1
6958: NONEQUAL
6959: IFFALSE 6977
// ComAttackUnit ( unit , target ) else
6961: LD_VAR 0 10
6965: PPUSH
6966: LD_VAR 0 9
6970: PPUSH
6971: CALL_OW 115
6975: GO 7006
// ComMoveXY ( unit , GetX ( target ) , GetY ( target ) ) ;
6977: LD_VAR 0 10
6981: PPUSH
6982: LD_VAR 0 9
6986: PPUSH
6987: CALL_OW 250
6991: PPUSH
6992: LD_VAR 0 9
6996: PPUSH
6997: CALL_OW 251
7001: PPUSH
7002: CALL_OW 111
// end ;
7006: GO 6380
7008: POP
7009: POP
// end ;
7010: GO 6357
// end ; end_of_file
7012: LD_VAR 0 3
7016: RET
// export function Action ; var dial ; begin
7017: LD_INT 0
7019: PPUSH
7020: PPUSH
// CenterNowOnXY ( 192 , 1 ) ;
7021: LD_INT 192
7023: PPUSH
7024: LD_INT 1
7026: PPUSH
7027: CALL_OW 86
// InGameOn ;
7031: CALL_OW 8
// case query ( textdiff ) of 1 :
7035: LD_STRING textdiff
7037: PPUSH
7038: CALL_OW 97
7042: PUSH
7043: LD_INT 1
7045: DOUBLE
7046: EQUAL
7047: IFTRUE 7051
7049: GO 7062
7051: POP
// Difficulty := 1 ; 2 :
7052: LD_ADDR_OWVAR 67
7056: PUSH
7057: LD_INT 1
7059: ST_TO_ADDR
7060: GO 7101
7062: LD_INT 2
7064: DOUBLE
7065: EQUAL
7066: IFTRUE 7070
7068: GO 7081
7070: POP
// Difficulty := 2 ; 3 :
7071: LD_ADDR_OWVAR 67
7075: PUSH
7076: LD_INT 2
7078: ST_TO_ADDR
7079: GO 7101
7081: LD_INT 3
7083: DOUBLE
7084: EQUAL
7085: IFTRUE 7089
7087: GO 7100
7089: POP
// Difficulty := 3 ; end ;
7090: LD_ADDR_OWVAR 67
7094: PUSH
7095: LD_INT 3
7097: ST_TO_ADDR
7098: GO 7101
7100: POP
// case query ( finfo ) of 1 :
7101: LD_STRING finfo
7103: PPUSH
7104: CALL_OW 97
7108: PUSH
7109: LD_INT 1
7111: DOUBLE
7112: EQUAL
7113: IFTRUE 7117
7115: GO 7120
7117: POP
// ; end ;
7118: GO 7121
7120: POP
// PrepareRussian ;
7121: CALL 3410 0 0
// dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff Davidov ;
7125: LD_ADDR_VAR 0 2
7129: PUSH
7130: LD_INT 22
7132: PUSH
7133: LD_INT 6
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PUSH
7140: LD_INT 2
7142: PUSH
7143: LD_INT 25
7145: PUSH
7146: LD_INT 1
7148: PUSH
7149: EMPTY
7150: LIST
7151: LIST
7152: PUSH
7153: LD_INT 25
7155: PUSH
7156: LD_INT 2
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: PUSH
7163: LD_INT 25
7165: PUSH
7166: LD_INT 3
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 25
7175: PUSH
7176: LD_INT 4
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: LIST
7187: LIST
7188: LIST
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PPUSH
7194: CALL_OW 69
7198: PUSH
7199: LD_EXP 2
7203: DIFF
7204: ST_TO_ADDR
// ComMoveXY ( dial [ 1 ] , 202 , 40 ) ;
7205: LD_VAR 0 2
7209: PUSH
7210: LD_INT 1
7212: ARRAY
7213: PPUSH
7214: LD_INT 202
7216: PPUSH
7217: LD_INT 40
7219: PPUSH
7220: CALL_OW 111
// Wait ( 0 0$03 ) ;
7224: LD_INT 105
7226: PPUSH
7227: CALL_OW 67
// Say ( Davidov , DDav-1 ) ;
7231: LD_EXP 2
7235: PPUSH
7236: LD_STRING DDav-1
7238: PPUSH
7239: CALL_OW 88
// ComTurnUnit ( dial [ 1 ] , Davidov ) ;
7243: LD_VAR 0 2
7247: PUSH
7248: LD_INT 1
7250: ARRAY
7251: PPUSH
7252: LD_EXP 2
7256: PPUSH
7257: CALL_OW 119
// ComTurnUnit ( Davidov , dial [ 1 ] ) ;
7261: LD_EXP 2
7265: PPUSH
7266: LD_VAR 0 2
7270: PUSH
7271: LD_INT 1
7273: ARRAY
7274: PPUSH
7275: CALL_OW 119
// CenterOnXY ( 202 , 40 ) ;
7279: LD_INT 202
7281: PPUSH
7282: LD_INT 40
7284: PPUSH
7285: CALL_OW 84
// Say ( dial [ 1 ] , DRus-1 ) ;
7289: LD_VAR 0 2
7293: PUSH
7294: LD_INT 1
7296: ARRAY
7297: PPUSH
7298: LD_STRING DRus-1
7300: PPUSH
7301: CALL_OW 88
// Say ( Davidov , DDav-2 ) ;
7305: LD_EXP 2
7309: PPUSH
7310: LD_STRING DDav-2
7312: PPUSH
7313: CALL_OW 88
// Say ( dial [ 1 ] , DRus-2 ) ;
7317: LD_VAR 0 2
7321: PUSH
7322: LD_INT 1
7324: ARRAY
7325: PPUSH
7326: LD_STRING DRus-2
7328: PPUSH
7329: CALL_OW 88
// Say ( Davidov , DDav-3 ) ;
7333: LD_EXP 2
7337: PPUSH
7338: LD_STRING DDav-3
7340: PPUSH
7341: CALL_OW 88
// InGameOff ;
7345: CALL_OW 9
// Wait ( 0 0$0.3 ) ;
7349: LD_INT 10
7351: PPUSH
7352: CALL_OW 67
// ChangeMissionObjectives ( C1 ) ;
7356: LD_STRING C1
7358: PPUSH
7359: CALL_OW 337
// end ;
7363: LD_VAR 0 1
7367: RET
// every 0 0$30 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_lab ] ] ) do
7368: LD_INT 22
7370: PUSH
7371: LD_INT 6
7373: PUSH
7374: EMPTY
7375: LIST
7376: LIST
7377: PUSH
7378: LD_INT 30
7380: PUSH
7381: LD_INT 6
7383: PUSH
7384: EMPTY
7385: LIST
7386: LIST
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: PPUSH
7392: CALL_OW 69
7396: IFFALSE 7496
7398: GO 7400
7400: DISABLE
// begin Say ( Davidov , DDav-4 ) ;
7401: LD_EXP 2
7405: PPUSH
7406: LD_STRING DDav-4
7408: PPUSH
7409: CALL_OW 88
// Wait ( 0 0$40 ) ;
7413: LD_INT 1400
7415: PPUSH
7416: CALL_OW 67
// DialogueOn ;
7420: CALL_OW 6
// SayRadio ( Vervecken , Dver-Meet-1 ) ;
7424: LD_EXP 3
7428: PPUSH
7429: LD_STRING Dver-Meet-1
7431: PPUSH
7432: CALL_OW 94
// Say ( Davidov , DDav-Meet-1 ) ;
7436: LD_EXP 2
7440: PPUSH
7441: LD_STRING DDav-Meet-1
7443: PPUSH
7444: CALL_OW 88
// SayRadio ( Vervecken , Dver-Meet-2 ) ;
7448: LD_EXP 3
7452: PPUSH
7453: LD_STRING Dver-Meet-2
7455: PPUSH
7456: CALL_OW 94
// DialogueOff ;
7460: CALL_OW 7
// Wait ( [ 9 9$20 , 7 7$20 , 6 6$20 ] [ Difficulty ] ) ;
7464: LD_INT 19600
7466: PUSH
7467: LD_INT 15400
7469: PUSH
7470: LD_INT 13300
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_OWVAR 67
7482: ARRAY
7483: PPUSH
7484: CALL_OW 67
// legion_attacks_active := true ;
7488: LD_ADDR_EXP 7
7492: PUSH
7493: LD_INT 1
7495: ST_TO_ADDR
// end ;
7496: END
// every 0 0$02 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) or tick > 10 10$00 do var dial ;
7497: LD_INT 22
7499: PUSH
7500: LD_INT 6
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 30
7509: PUSH
7510: LD_INT 3
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PPUSH
7521: CALL_OW 69
7525: PUSH
7526: LD_OWVAR 1
7530: PUSH
7531: LD_INT 21000
7533: GREATER
7534: OR
7535: IFFALSE 7769
7537: GO 7539
7539: DISABLE
7540: LD_INT 0
7542: PPUSH
// begin dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff Davidov ;
7543: LD_ADDR_VAR 0 1
7547: PUSH
7548: LD_INT 22
7550: PUSH
7551: LD_INT 6
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 2
7560: PUSH
7561: LD_INT 25
7563: PUSH
7564: LD_INT 1
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 25
7573: PUSH
7574: LD_INT 2
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 25
7583: PUSH
7584: LD_INT 3
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: PUSH
7591: LD_INT 25
7593: PUSH
7594: LD_INT 4
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: LIST
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PPUSH
7612: CALL_OW 69
7616: PUSH
7617: LD_EXP 2
7621: DIFF
7622: ST_TO_ADDR
// Say ( dial [ 1 ] , DRus-3 ) ;
7623: LD_VAR 0 1
7627: PUSH
7628: LD_INT 1
7630: ARRAY
7631: PPUSH
7632: LD_STRING DRus-3
7634: PPUSH
7635: CALL_OW 88
// Say ( Davidov , DDav-5 ) ;
7639: LD_EXP 2
7643: PPUSH
7644: LD_STRING DDav-5
7646: PPUSH
7647: CALL_OW 88
// Say ( dial [ 1 ] , DRus-4 ) ;
7651: LD_VAR 0 1
7655: PUSH
7656: LD_INT 1
7658: ARRAY
7659: PPUSH
7660: LD_STRING DRus-4
7662: PPUSH
7663: CALL_OW 88
// Say ( Davidov , DDav-6 ) ;
7667: LD_EXP 2
7671: PPUSH
7672: LD_STRING DDav-6
7674: PPUSH
7675: CALL_OW 88
// ChangeMissionObjectives ( C2 ) ;
7679: LD_STRING C2
7681: PPUSH
7682: CALL_OW 337
// Wait ( 5 5$00 ) ;
7686: LD_INT 10500
7688: PPUSH
7689: CALL_OW 67
// DialogueOn ;
7693: CALL_OW 6
// SayRadio ( Bagins , DBag-1 ) ;
7697: LD_EXP 1
7701: PPUSH
7702: LD_STRING DBag-1
7704: PPUSH
7705: CALL_OW 94
// Say ( Davidov , DDavB-1 ) ;
7709: LD_EXP 2
7713: PPUSH
7714: LD_STRING DDavB-1
7716: PPUSH
7717: CALL_OW 88
// SayRadio ( Bagins , DBag-2 ) ;
7721: LD_EXP 1
7725: PPUSH
7726: LD_STRING DBag-2
7728: PPUSH
7729: CALL_OW 94
// Say ( Davidov , DDavB-2 ) ;
7733: LD_EXP 2
7737: PPUSH
7738: LD_STRING DDavB-2
7740: PPUSH
7741: CALL_OW 88
// SayRadio ( Bagins , DBag-3 ) ;
7745: LD_EXP 1
7749: PPUSH
7750: LD_STRING DBag-3
7752: PPUSH
7753: CALL_OW 94
// DialogueOff ;
7757: CALL_OW 7
// alliance_attack_active := true ;
7761: LD_ADDR_EXP 9
7765: PUSH
7766: LD_INT 1
7768: ST_TO_ADDR
// end ;
7769: PPOPN 1
7771: END
// every 0 0$1 trigger alliance_used_artifact_1 do
7772: LD_EXP 10
7776: IFFALSE 7823
7778: GO 7780
7780: DISABLE
// begin DialogueOn ;
7781: CALL_OW 6
// CenterNowOnXY ( alliance_used_artifact_1 [ 1 ] , alliance_used_artifact_1 [ 2 ] ) ;
7785: LD_EXP 10
7789: PUSH
7790: LD_INT 1
7792: ARRAY
7793: PPUSH
7794: LD_EXP 10
7798: PUSH
7799: LD_INT 2
7801: ARRAY
7802: PPUSH
7803: CALL_OW 86
// Say ( Davidov , DDav-Artifact1-1 ) ;
7807: LD_EXP 2
7811: PPUSH
7812: LD_STRING DDav-Artifact1-1
7814: PPUSH
7815: CALL_OW 88
// DialogueOff ;
7819: CALL_OW 7
// end ;
7823: END
// every 0 0$1 trigger alliance_used_artifact_2 do
7824: LD_EXP 11
7828: IFFALSE 7875
7830: GO 7832
7832: DISABLE
// begin DialogueOn ;
7833: CALL_OW 6
// CenterNowOnXY ( alliance_used_artifact_2 [ 1 ] , alliance_used_artifact_2 [ 2 ] ) ;
7837: LD_EXP 11
7841: PUSH
7842: LD_INT 1
7844: ARRAY
7845: PPUSH
7846: LD_EXP 11
7850: PUSH
7851: LD_INT 2
7853: ARRAY
7854: PPUSH
7855: CALL_OW 86
// Say ( Davidov , DDav-Artifact2-1 ) ;
7859: LD_EXP 2
7863: PPUSH
7864: LD_STRING DDav-Artifact2-1
7866: PPUSH
7867: CALL_OW 88
// DialogueOff ;
7871: CALL_OW 7
// end ;
7875: END
// every 0 0$01 trigger artifact_destroyed or ( not FindArtifact ( 6 ) and not player_artifact_loaded ) do
7876: LD_EXP 16
7880: PUSH
7881: LD_INT 6
7883: PPUSH
7884: CALL_OW 469
7888: NOT
7889: PUSH
7890: LD_EXP 18
7894: NOT
7895: AND
7896: OR
7897: IFFALSE 7909
7899: GO 7901
7901: DISABLE
// YouLost ( artifact_destroyed ) ;
7902: LD_STRING artifact_destroyed
7904: PPUSH
7905: CALL_OW 104
7909: END
// every 0 0$01 trigger IsDead ( Davidov ) do
7910: LD_EXP 2
7914: PPUSH
7915: CALL_OW 301
7919: IFFALSE 7931
7921: GO 7923
7923: DISABLE
// YouLost ( dead ) ;
7924: LD_STRING dead
7926: PPUSH
7927: CALL_OW 104
7931: END
// every 0 0$3 trigger FilterAllUnits ( [ f_side , 7 ] ) = 0 do
7932: LD_INT 22
7934: PUSH
7935: LD_INT 7
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PPUSH
7942: CALL_OW 69
7946: PUSH
7947: LD_INT 0
7949: EQUAL
7950: IFFALSE 8092
7952: GO 7954
7954: DISABLE
// begin DialogueOn ;
7955: CALL_OW 6
// if tick < [ 120 120$00 , 100 100$00 , 90 90$00 ] [ Difficulty ] then
7959: LD_OWVAR 1
7963: PUSH
7964: LD_INT 252000
7966: PUSH
7967: LD_INT 210000
7969: PUSH
7970: LD_INT 189000
7972: PUSH
7973: EMPTY
7974: LIST
7975: LIST
7976: LIST
7977: PUSH
7978: LD_OWVAR 67
7982: ARRAY
7983: LESS
7984: IFFALSE 7998
// AddMedal ( med1 , 1 ) else
7986: LD_STRING med1
7988: PPUSH
7989: LD_INT 1
7991: PPUSH
7992: CALL_OW 101
7996: GO 8009
// AddMedal ( med1 , - 1 ) ;
7998: LD_STRING med1
8000: PPUSH
8001: LD_INT 1
8003: NEG
8004: PPUSH
8005: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) then
8009: LD_INT 22
8011: PUSH
8012: LD_INT 8
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PPUSH
8019: CALL_OW 69
8023: IFFALSE 8038
// AddMedal ( med2 , - 1 ) else
8025: LD_STRING med2
8027: PPUSH
8028: LD_INT 1
8030: NEG
8031: PPUSH
8032: CALL_OW 101
8036: GO 8048
// AddMedal ( med2 , 1 ) ;
8038: LD_STRING med2
8040: PPUSH
8041: LD_INT 1
8043: PPUSH
8044: CALL_OW 101
// if player_used_sib_bomb then
8048: LD_EXP 12
8052: IFFALSE 8067
// AddMedal ( med3 , - 1 ) else
8054: LD_STRING med3
8056: PPUSH
8057: LD_INT 1
8059: NEG
8060: PPUSH
8061: CALL_OW 101
8065: GO 8077
// AddMedal ( med3 , 1 ) ;
8067: LD_STRING med3
8069: PPUSH
8070: LD_INT 1
8072: PPUSH
8073: CALL_OW 101
// GiveMedals ( MAIN ) ;
8077: LD_STRING MAIN
8079: PPUSH
8080: CALL_OW 102
// YouWin ;
8084: CALL_OW 103
// DialogueOff ;
8088: CALL_OW 7
// end ; end_of_file
8092: END
// every 0 0$22 + 0 0$2 do
8093: GO 8095
8095: DISABLE
// begin enable ;
8096: ENABLE
// CreateCratesArea ( Rand ( 4 , 5 ) , cratesArea , true ) ;
8097: LD_INT 4
8099: PPUSH
8100: LD_INT 5
8102: PPUSH
8103: CALL_OW 12
8107: PPUSH
8108: LD_INT 3
8110: PPUSH
8111: LD_INT 1
8113: PPUSH
8114: CALL_OW 55
// if tick >= 4 4$00 then
8118: LD_OWVAR 1
8122: PUSH
8123: LD_INT 8400
8125: GREATEREQUAL
8126: IFFALSE 8133
// begin disable ;
8128: DISABLE
// CratesSpawn ( ) ;
8129: CALL 8134 0 0
// end ; end ;
8133: END
// function CratesSpawn ( ) ; var i , amount , cr ; begin
8134: LD_INT 0
8136: PPUSH
8137: PPUSH
8138: PPUSH
8139: PPUSH
// amount := [ 30000 , 20000 , 10000 ] [ Difficulty ] ;
8140: LD_ADDR_VAR 0 3
8144: PUSH
8145: LD_INT 30000
8147: PUSH
8148: LD_INT 20000
8150: PUSH
8151: LD_INT 10000
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: LIST
8158: PUSH
8159: LD_OWVAR 67
8163: ARRAY
8164: ST_TO_ADDR
// while amount > 0 do
8165: LD_VAR 0 3
8169: PUSH
8170: LD_INT 0
8172: GREATER
8173: IFFALSE 8243
// begin Wait ( rand ( 0 0$30 , 1 1$30 ) ) ;
8175: LD_INT 1050
8177: PPUSH
8178: LD_INT 3150
8180: PPUSH
8181: CALL_OW 12
8185: PPUSH
8186: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
8190: LD_ADDR_VAR 0 4
8194: PUSH
8195: LD_INT 1
8197: PPUSH
8198: LD_INT 5
8200: PPUSH
8201: CALL_OW 12
8205: ST_TO_ADDR
// amount := amount - ( cr * 10 ) ;
8206: LD_ADDR_VAR 0 3
8210: PUSH
8211: LD_VAR 0 3
8215: PUSH
8216: LD_VAR 0 4
8220: PUSH
8221: LD_INT 10
8223: MUL
8224: MINUS
8225: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
8226: LD_VAR 0 4
8230: PPUSH
8231: LD_INT 3
8233: PPUSH
8234: LD_INT 1
8236: PPUSH
8237: CALL_OW 55
// end ;
8241: GO 8165
// end ; end_of_file
8243: LD_VAR 0 1
8247: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird , horse ; begin
8248: LD_INT 0
8250: PPUSH
8251: PPUSH
8252: PPUSH
8253: PPUSH
8254: PPUSH
8255: PPUSH
// uc_nation = nation_nature ;
8256: LD_ADDR_OWVAR 21
8260: PUSH
8261: LD_INT 0
8263: ST_TO_ADDR
// uc_side = 0 ;
8264: LD_ADDR_OWVAR 20
8268: PUSH
8269: LD_INT 0
8271: ST_TO_ADDR
// l = 0 ;
8272: LD_ADDR_VAR 0 6
8276: PUSH
8277: LD_INT 0
8279: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
8280: LD_ADDR_OWVAR 24
8284: PUSH
8285: LD_INT 0
8287: PPUSH
8288: LD_INT 5
8290: PPUSH
8291: CALL_OW 12
8295: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
8296: LD_ADDR_OWVAR 35
8300: PUSH
8301: LD_INT 5
8303: NEG
8304: PPUSH
8305: LD_INT 5
8307: PPUSH
8308: CALL_OW 12
8312: ST_TO_ADDR
// hc_gallery =  ;
8313: LD_ADDR_OWVAR 33
8317: PUSH
8318: LD_STRING 
8320: ST_TO_ADDR
// hc_class = class_apeman ;
8321: LD_ADDR_OWVAR 28
8325: PUSH
8326: LD_INT 12
8328: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
8329: LD_ADDR_OWVAR 29
8333: PUSH
8334: LD_INT 11
8336: PPUSH
8337: LD_INT 13
8339: PPUSH
8340: CALL_OW 12
8344: PUSH
8345: LD_INT 10
8347: PPUSH
8348: LD_INT 11
8350: PPUSH
8351: CALL_OW 12
8355: PUSH
8356: EMPTY
8357: LIST
8358: LIST
8359: ST_TO_ADDR
// hc_sex = sex_male ;
8360: LD_ADDR_OWVAR 27
8364: PUSH
8365: LD_INT 1
8367: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
8368: LD_ADDR_OWVAR 31
8372: PUSH
8373: LD_INT 0
8375: PPUSH
8376: LD_INT 2
8378: PPUSH
8379: CALL_OW 12
8383: PUSH
8384: LD_INT 0
8386: PUSH
8387: LD_INT 0
8389: PUSH
8390: LD_INT 0
8392: PUSH
8393: EMPTY
8394: LIST
8395: LIST
8396: LIST
8397: LIST
8398: ST_TO_ADDR
// apeman = CreateHuman ;
8399: LD_ADDR_VAR 0 7
8403: PUSH
8404: CALL_OW 44
8408: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
8409: LD_VAR 0 7
8413: PPUSH
8414: LD_VAR 0 4
8418: PPUSH
8419: LD_INT 0
8421: PPUSH
8422: CALL_OW 49
// l = l + 1 ;
8426: LD_ADDR_VAR 0 6
8430: PUSH
8431: LD_VAR 0 6
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ST_TO_ADDR
// end until l = num1 ;
8440: LD_VAR 0 6
8444: PUSH
8445: LD_VAR 0 1
8449: EQUAL
8450: IFFALSE 8280
// l = 0 ;
8452: LD_ADDR_VAR 0 6
8456: PUSH
8457: LD_INT 0
8459: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
8460: LD_ADDR_OWVAR 35
8464: PUSH
8465: LD_INT 0
8467: PPUSH
8468: LD_INT 25
8470: PPUSH
8471: CALL_OW 12
8475: ST_TO_ADDR
// hc_class = class_tiger ;
8476: LD_ADDR_OWVAR 28
8480: PUSH
8481: LD_INT 14
8483: ST_TO_ADDR
// hc_sex = sex_male ;
8484: LD_ADDR_OWVAR 27
8488: PUSH
8489: LD_INT 1
8491: ST_TO_ADDR
// hc_gallery = sandnature ;
8492: LD_ADDR_OWVAR 33
8496: PUSH
8497: LD_STRING sandnature
8499: ST_TO_ADDR
// hc_face_number = 3 ;
8500: LD_ADDR_OWVAR 34
8504: PUSH
8505: LD_INT 3
8507: ST_TO_ADDR
// tiger = CreateHuman ;
8508: LD_ADDR_VAR 0 8
8512: PUSH
8513: CALL_OW 44
8517: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8518: LD_VAR 0 8
8522: PPUSH
8523: LD_VAR 0 4
8527: PPUSH
8528: LD_INT 0
8530: PPUSH
8531: CALL_OW 49
// l = l + 1 ;
8535: LD_ADDR_VAR 0 6
8539: PUSH
8540: LD_VAR 0 6
8544: PUSH
8545: LD_INT 1
8547: PLUS
8548: ST_TO_ADDR
// end until l = num2 ;
8549: LD_VAR 0 6
8553: PUSH
8554: LD_VAR 0 2
8558: EQUAL
8559: IFFALSE 8460
// l = 0 ;
8561: LD_ADDR_VAR 0 6
8565: PUSH
8566: LD_INT 0
8568: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8569: LD_ADDR_OWVAR 28
8573: PUSH
8574: LD_INT 18
8576: ST_TO_ADDR
// hc_gallery = sandnature ;
8577: LD_ADDR_OWVAR 33
8581: PUSH
8582: LD_STRING sandnature
8584: ST_TO_ADDR
// hc_face_number = 1 ;
8585: LD_ADDR_OWVAR 34
8589: PUSH
8590: LD_INT 1
8592: ST_TO_ADDR
// bird = CreateHuman ;
8593: LD_ADDR_VAR 0 9
8597: PUSH
8598: CALL_OW 44
8602: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8603: LD_VAR 0 9
8607: PPUSH
8608: LD_INT 0
8610: PPUSH
8611: CALL_OW 51
// l = l + 1 ;
8615: LD_ADDR_VAR 0 6
8619: PUSH
8620: LD_VAR 0 6
8624: PUSH
8625: LD_INT 1
8627: PLUS
8628: ST_TO_ADDR
// end until l = num3 ;
8629: LD_VAR 0 6
8633: PUSH
8634: LD_VAR 0 3
8638: EQUAL
8639: IFFALSE 8569
// for l = 1 to 2 do
8641: LD_ADDR_VAR 0 6
8645: PUSH
8646: DOUBLE
8647: LD_INT 1
8649: DEC
8650: ST_TO_ADDR
8651: LD_INT 2
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8713
// begin hc_class = 21 ;
8657: LD_ADDR_OWVAR 28
8661: PUSH
8662: LD_INT 21
8664: ST_TO_ADDR
// hc_gallery =  ;
8665: LD_ADDR_OWVAR 33
8669: PUSH
8670: LD_STRING 
8672: ST_TO_ADDR
// hc_agressivity = 0 ;
8673: LD_ADDR_OWVAR 35
8677: PUSH
8678: LD_INT 0
8680: ST_TO_ADDR
// hc_face_number = 5 ;
8681: LD_ADDR_OWVAR 34
8685: PUSH
8686: LD_INT 5
8688: ST_TO_ADDR
// horse := CreateHuman ;
8689: LD_ADDR_VAR 0 10
8693: PUSH
8694: CALL_OW 44
8698: ST_TO_ADDR
// PlaceUnitAnywhere ( horse , false ) ;
8699: LD_VAR 0 10
8703: PPUSH
8704: LD_INT 0
8706: PPUSH
8707: CALL_OW 51
// end ;
8711: GO 8654
8713: POP
8714: POP
// hc_gallery :=  ;
8715: LD_ADDR_OWVAR 33
8719: PUSH
8720: LD_STRING 
8722: ST_TO_ADDR
// hc_name :=  ;
8723: LD_ADDR_OWVAR 26
8727: PUSH
8728: LD_STRING 
8730: ST_TO_ADDR
// end ; end_of_file
8731: LD_VAR 0 5
8735: RET
// every 0 0$01 trigger not debug do var timer ;
8736: LD_EXP 6
8740: NOT
8741: IFFALSE 8801
8743: GO 8745
8745: DISABLE
8746: LD_INT 0
8748: PPUSH
// begin timer := 0 0$00 ;
8749: LD_ADDR_VAR 0 1
8753: PUSH
8754: LD_INT 0
8756: ST_TO_ADDR
// while ( true ) do
8757: LD_INT 1
8759: IFFALSE 8801
// begin timer := timer + 0 0$01 ;
8761: LD_ADDR_VAR 0 1
8765: PUSH
8766: LD_VAR 0 1
8770: PUSH
8771: LD_INT 35
8773: PLUS
8774: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
8775: LD_ADDR_OWVAR 47
8779: PUSH
8780: LD_STRING #tick
8782: PUSH
8783: LD_VAR 0 1
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
8792: LD_INT 35
8794: PPUSH
8795: CALL_OW 67
// end ;
8799: GO 8757
// end ; end_of_file
8801: PPOPN 1
8803: END
// export function DebugArtifact ; begin
8804: LD_INT 0
8806: PPUSH
// AddToLog ( Artifact is loaded:  & player_artifact_loaded ) ;
8807: LD_STRING Artifact is loaded: 
8809: PUSH
8810: LD_EXP 18
8814: STR
8815: PPUSH
8816: CALL_OW 561
// AddToLog ( Artifact is active:  & player_artifact_ready ) ;
8820: LD_STRING Artifact is active: 
8822: PUSH
8823: LD_EXP 29
8827: STR
8828: PPUSH
8829: CALL_OW 561
// AddToLog ( Artifact is researched:  & player_artifact_researched ) ;
8833: LD_STRING Artifact is researched: 
8835: PUSH
8836: LD_EXP 22
8840: STR
8841: PPUSH
8842: CALL_OW 561
// AddToLog ( Artifact coords  & FindArtifact ( player_artifact_number ) ) ;
8846: LD_STRING Artifact coords 
8848: PUSH
8849: LD_EXP 19
8853: PPUSH
8854: CALL_OW 469
8858: STR
8859: PPUSH
8860: CALL_OW 561
// end ;
8864: LD_VAR 0 1
8868: RET
// export function InitArtifactsPos ( ) ; var i , tmp , possible_pos ; begin
8869: LD_INT 0
8871: PPUSH
8872: PPUSH
8873: PPUSH
8874: PPUSH
// possible_pos := [ [ 100 , 185 ] , [ 99 , 175 ] , [ 117 , 191 ] ] ;
8875: LD_ADDR_VAR 0 4
8879: PUSH
8880: LD_INT 100
8882: PUSH
8883: LD_INT 185
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: PUSH
8890: LD_INT 99
8892: PUSH
8893: LD_INT 175
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: LD_INT 117
8902: PUSH
8903: LD_INT 191
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: LIST
8914: ST_TO_ADDR
// for i = 1 to artifacts_type do
8915: LD_ADDR_VAR 0 2
8919: PUSH
8920: DOUBLE
8921: LD_INT 1
8923: DEC
8924: ST_TO_ADDR
8925: LD_EXP 14
8929: PUSH
8930: FOR_TO
8931: IFFALSE 9033
// begin tmp := possible_pos [ rand ( 1 , possible_pos ) ] ;
8933: LD_ADDR_VAR 0 3
8937: PUSH
8938: LD_VAR 0 4
8942: PUSH
8943: LD_INT 1
8945: PPUSH
8946: LD_VAR 0 4
8950: PPUSH
8951: CALL_OW 12
8955: ARRAY
8956: ST_TO_ADDR
// possible_pos := possible_pos diff tmp ;
8957: LD_ADDR_VAR 0 4
8961: PUSH
8962: LD_VAR 0 4
8966: PUSH
8967: LD_VAR 0 3
8971: DIFF
8972: ST_TO_ADDR
// artifacts_pos := Insert ( artifacts_pos , i , tmp ) ;
8973: LD_ADDR_EXP 15
8977: PUSH
8978: LD_EXP 15
8982: PPUSH
8983: LD_VAR 0 2
8987: PPUSH
8988: LD_VAR 0 3
8992: PPUSH
8993: CALL_OW 2
8997: ST_TO_ADDR
// CreateArtifact ( artifacts_type [ i ] , tmp [ 1 ] , tmp [ 2 ] ) ;
8998: LD_EXP 14
9002: PUSH
9003: LD_VAR 0 2
9007: ARRAY
9008: PPUSH
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 1
9016: ARRAY
9017: PPUSH
9018: LD_VAR 0 3
9022: PUSH
9023: LD_INT 2
9025: ARRAY
9026: PPUSH
9027: CALL 4953 0 3
// end ;
9031: GO 8930
9033: POP
9034: POP
// end ;
9035: LD_VAR 0 1
9039: RET
// export function GetUseCost ( dist ) ; begin
9040: LD_INT 0
9042: PPUSH
// if dist < 30 then
9043: LD_VAR 0 1
9047: PUSH
9048: LD_INT 30
9050: LESS
9051: IFFALSE 9061
// result := 10 ;
9053: LD_ADDR_VAR 0 2
9057: PUSH
9058: LD_INT 10
9060: ST_TO_ADDR
// if dist >= 30 and dist < 50 then
9061: LD_VAR 0 1
9065: PUSH
9066: LD_INT 30
9068: GREATEREQUAL
9069: PUSH
9070: LD_VAR 0 1
9074: PUSH
9075: LD_INT 50
9077: LESS
9078: AND
9079: IFFALSE 9089
// result := 35 ;
9081: LD_ADDR_VAR 0 2
9085: PUSH
9086: LD_INT 35
9088: ST_TO_ADDR
// if dist >= 50 and dist < 80 then
9089: LD_VAR 0 1
9093: PUSH
9094: LD_INT 50
9096: GREATEREQUAL
9097: PUSH
9098: LD_VAR 0 1
9102: PUSH
9103: LD_INT 80
9105: LESS
9106: AND
9107: IFFALSE 9117
// result := 70 ;
9109: LD_ADDR_VAR 0 2
9113: PUSH
9114: LD_INT 70
9116: ST_TO_ADDR
// if dist >= 80 and dist < 120 then
9117: LD_VAR 0 1
9121: PUSH
9122: LD_INT 80
9124: GREATEREQUAL
9125: PUSH
9126: LD_VAR 0 1
9130: PUSH
9131: LD_INT 120
9133: LESS
9134: AND
9135: IFFALSE 9145
// result := 100 ;
9137: LD_ADDR_VAR 0 2
9141: PUSH
9142: LD_INT 100
9144: ST_TO_ADDR
// if dist >= 120 then
9145: LD_VAR 0 1
9149: PUSH
9150: LD_INT 120
9152: GREATEREQUAL
9153: IFFALSE 9163
// result := 150 ;
9155: LD_ADDR_VAR 0 2
9159: PUSH
9160: LD_INT 150
9162: ST_TO_ADDR
// end ;
9163: LD_VAR 0 2
9167: RET
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
9168: LD_VAR 0 1
9172: PPUSH
9173: CALL_OW 255
9177: PUSH
9178: LD_OWVAR 2
9182: EQUAL
9183: IFFALSE 9193
// player_artifact_researched := true ;
9185: LD_ADDR_EXP 22
9189: PUSH
9190: LD_INT 1
9192: ST_TO_ADDR
// end ;
9193: PPOPN 1
9195: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_artifact_researched and not player_artifact_loaded do var lab , coords ;
9196: LD_INT 22
9198: PUSH
9199: LD_OWVAR 2
9203: PUSH
9204: EMPTY
9205: LIST
9206: LIST
9207: PUSH
9208: LD_INT 2
9210: PUSH
9211: LD_INT 30
9213: PUSH
9214: LD_INT 8
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: LD_INT 30
9223: PUSH
9224: LD_INT 11
9226: PUSH
9227: EMPTY
9228: LIST
9229: LIST
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: LIST
9235: PUSH
9236: EMPTY
9237: LIST
9238: LIST
9239: PPUSH
9240: CALL_OW 69
9244: PUSH
9245: LD_EXP 22
9249: AND
9250: PUSH
9251: LD_EXP 18
9255: NOT
9256: AND
9257: IFFALSE 9711
9259: GO 9261
9261: DISABLE
9262: LD_INT 0
9264: PPUSH
9265: PPUSH
// begin enable ;
9266: ENABLE
// coords := FindArtifact ( player_artifact_number ) ;
9267: LD_ADDR_VAR 0 2
9271: PUSH
9272: LD_EXP 19
9276: PPUSH
9277: CALL_OW 469
9281: ST_TO_ADDR
// if not coords then
9282: LD_VAR 0 2
9286: NOT
9287: IFFALSE 9291
// exit ;
9289: GO 9711
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , coords [ 1 ] , coords [ 2 ] ) ;
9291: LD_ADDR_VAR 0 1
9295: PUSH
9296: LD_INT 22
9298: PUSH
9299: LD_OWVAR 2
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: PUSH
9308: LD_INT 2
9310: PUSH
9311: LD_INT 30
9313: PUSH
9314: LD_INT 8
9316: PUSH
9317: EMPTY
9318: LIST
9319: LIST
9320: PUSH
9321: LD_INT 30
9323: PUSH
9324: LD_INT 11
9326: PUSH
9327: EMPTY
9328: LIST
9329: LIST
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: LIST
9335: PUSH
9336: EMPTY
9337: LIST
9338: LIST
9339: PPUSH
9340: CALL_OW 69
9344: PPUSH
9345: LD_VAR 0 2
9349: PUSH
9350: LD_INT 1
9352: ARRAY
9353: PPUSH
9354: LD_VAR 0 2
9358: PUSH
9359: LD_INT 2
9361: ARRAY
9362: PPUSH
9363: CALL_OW 73
9367: ST_TO_ADDR
// if not lab then
9368: LD_VAR 0 1
9372: NOT
9373: IFFALSE 9390
// begin if debug then
9375: LD_EXP 6
9379: IFFALSE 9388
// AddToLog ( Cannot find lab for artifact! ) ;
9381: LD_STRING Cannot find lab for artifact!
9383: PPUSH
9384: CALL_OW 561
// exit ;
9388: GO 9711
// end ; if not player_artifact_ready then
9390: LD_EXP 29
9394: NOT
9395: IFFALSE 9519
// begin if GetDistUnitXY ( lab , coords [ 1 ] , coords [ 2 ] ) < player_artifact_active_distance then
9397: LD_VAR 0 1
9401: PPUSH
9402: LD_VAR 0 2
9406: PUSH
9407: LD_INT 1
9409: ARRAY
9410: PPUSH
9411: LD_VAR 0 2
9415: PUSH
9416: LD_INT 2
9418: ARRAY
9419: PPUSH
9420: CALL_OW 297
9424: PUSH
9425: LD_EXP 23
9429: LESS
9430: IFFALSE 9495
// begin if BuildingStatus ( lab ) = bs_idle then
9432: LD_VAR 0 1
9436: PPUSH
9437: CALL_OW 461
9441: PUSH
9442: LD_INT 2
9444: EQUAL
9445: IFFALSE 9471
// SetArtifactUse ( your_side , player_artifact_icon_res , art_instant , lab ) else
9447: LD_OWVAR 2
9451: PPUSH
9452: LD_EXP 25
9456: PPUSH
9457: LD_INT 2
9459: PPUSH
9460: LD_VAR 0 1
9464: PPUSH
9465: CALL_OW 468
9469: GO 9493
// SetArtifactUse ( your_side , player_artifact_icon_res , art_gray , lab ) ;
9471: LD_OWVAR 2
9475: PPUSH
9476: LD_EXP 25
9480: PPUSH
9481: LD_INT 1
9483: PPUSH
9484: LD_VAR 0 1
9488: PPUSH
9489: CALL_OW 468
// end else
9493: GO 9517
// SetArtifactUse ( your_side , player_artifact_icon_res , art_gray , lab ) ;
9495: LD_OWVAR 2
9499: PPUSH
9500: LD_EXP 25
9504: PPUSH
9505: LD_INT 1
9507: PPUSH
9508: LD_VAR 0 1
9512: PPUSH
9513: CALL_OW 468
// end else
9517: GO 9711
// if GetDistUnitXY ( lab , coords [ 1 ] , coords [ 2 ] ) < player_artifact_active_distance then
9519: LD_VAR 0 1
9523: PPUSH
9524: LD_VAR 0 2
9528: PUSH
9529: LD_INT 1
9531: ARRAY
9532: PPUSH
9533: LD_VAR 0 2
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: CALL_OW 297
9546: PUSH
9547: LD_EXP 23
9551: LESS
9552: IFFALSE 9667
// begin if BuildingStatus ( lab ) = bs_idle then
9554: LD_VAR 0 1
9558: PPUSH
9559: CALL_OW 461
9563: PUSH
9564: LD_INT 2
9566: EQUAL
9567: IFFALSE 9621
// begin SetArtifactUse ( your_side , player_artifact_icon , art_unit , lab ) ;
9569: LD_OWVAR 2
9573: PPUSH
9574: LD_EXP 20
9578: PPUSH
9579: LD_INT 4
9581: PPUSH
9582: LD_VAR 0 1
9586: PPUSH
9587: CALL_OW 468
// if player_artifact_selected_unit then
9591: LD_EXP 30
9595: IFFALSE 9619
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_place , lab ) ;
9597: LD_OWVAR 2
9601: PPUSH
9602: LD_EXP 21
9606: PPUSH
9607: LD_INT 3
9609: PPUSH
9610: LD_VAR 0 1
9614: PPUSH
9615: CALL_OW 468
// end else
9619: GO 9665
// begin SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
9621: LD_OWVAR 2
9625: PPUSH
9626: LD_EXP 20
9630: PPUSH
9631: LD_INT 1
9633: PPUSH
9634: LD_VAR 0 1
9638: PPUSH
9639: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_gray , lab ) ;
9643: LD_OWVAR 2
9647: PPUSH
9648: LD_EXP 21
9652: PPUSH
9653: LD_INT 1
9655: PPUSH
9656: LD_VAR 0 1
9660: PPUSH
9661: CALL_OW 468
// end ; end else
9665: GO 9711
// begin SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
9667: LD_OWVAR 2
9671: PPUSH
9672: LD_EXP 20
9676: PPUSH
9677: LD_INT 1
9679: PPUSH
9680: LD_VAR 0 1
9684: PPUSH
9685: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_gray , lab ) ;
9689: LD_OWVAR 2
9693: PPUSH
9694: LD_EXP 21
9698: PPUSH
9699: LD_INT 1
9701: PPUSH
9702: LD_VAR 0 1
9706: PPUSH
9707: CALL_OW 468
// end ; end ;
9711: PPOPN 2
9713: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var coords , i , lab , side , dist , cost ;
9714: LD_INT 0
9716: PPUSH
9717: PPUSH
9718: PPUSH
9719: PPUSH
9720: PPUSH
9721: PPUSH
// begin coords := FindArtifact ( player_artifact_number ) ;
9722: LD_ADDR_VAR 0 5
9726: PUSH
9727: LD_EXP 19
9731: PPUSH
9732: CALL_OW 469
9736: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , coords [ 1 ] , coords [ 2 ] ) ;
9737: LD_ADDR_VAR 0 7
9741: PUSH
9742: LD_INT 22
9744: PUSH
9745: LD_OWVAR 2
9749: PUSH
9750: EMPTY
9751: LIST
9752: LIST
9753: PUSH
9754: LD_INT 2
9756: PUSH
9757: LD_INT 30
9759: PUSH
9760: LD_INT 8
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PUSH
9767: LD_INT 30
9769: PUSH
9770: LD_INT 11
9772: PUSH
9773: EMPTY
9774: LIST
9775: LIST
9776: PUSH
9777: EMPTY
9778: LIST
9779: LIST
9780: LIST
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PPUSH
9786: CALL_OW 69
9790: PPUSH
9791: LD_VAR 0 5
9795: PUSH
9796: LD_INT 1
9798: ARRAY
9799: PPUSH
9800: LD_VAR 0 5
9804: PUSH
9805: LD_INT 2
9807: ARRAY
9808: PPUSH
9809: CALL_OW 73
9813: ST_TO_ADDR
// if not lab then
9814: LD_VAR 0 7
9818: NOT
9819: IFFALSE 9836
// begin if debug then
9821: LD_EXP 6
9825: IFFALSE 9834
// AddToLog ( Cannot find lab! ) ;
9827: LD_STRING Cannot find lab!
9829: PPUSH
9830: CALL_OW 561
// exit ;
9834: GO 10194
// end ; if icon = player_artifact_icon_res then
9836: LD_VAR 0 2
9840: PUSH
9841: LD_EXP 25
9845: EQUAL
9846: IFFALSE 9887
// begin SetSpecResearch ( lab , player_artifact_time_res , true ) ;
9848: LD_VAR 0 7
9852: PPUSH
9853: LD_EXP 27
9857: PPUSH
9858: LD_INT 1
9860: PPUSH
9861: CALL_OW 486
// SetArtifactUse ( your_side , player_artifact_icon_res , art_no , lab ) ;
9865: LD_OWVAR 2
9869: PPUSH
9870: LD_EXP 25
9874: PPUSH
9875: LD_INT 0
9877: PPUSH
9878: LD_VAR 0 7
9882: PPUSH
9883: CALL_OW 468
// end ; if icon = player_artifact_icon then
9887: LD_VAR 0 2
9891: PUSH
9892: LD_EXP 20
9896: EQUAL
9897: IFFALSE 9936
// begin if GetType ( cr1 ) = unit_human and not IsInUnit ( cr1 ) then
9899: LD_VAR 0 3
9903: PPUSH
9904: CALL_OW 247
9908: PUSH
9909: LD_INT 1
9911: EQUAL
9912: PUSH
9913: LD_VAR 0 3
9917: PPUSH
9918: CALL_OW 310
9922: NOT
9923: AND
9924: IFFALSE 9936
// player_artifact_selected_unit := cr1 ;
9926: LD_ADDR_EXP 30
9930: PUSH
9931: LD_VAR 0 3
9935: ST_TO_ADDR
// end ; if icon = player_artifact_icon_2 then
9936: LD_VAR 0 2
9940: PUSH
9941: LD_EXP 21
9945: EQUAL
9946: IFFALSE 10184
// begin if HexInfo ( cr1 , cr2 ) <> 0 then
9948: LD_VAR 0 3
9952: PPUSH
9953: LD_VAR 0 4
9957: PPUSH
9958: CALL_OW 428
9962: PUSH
9963: LD_INT 0
9965: NONEQUAL
9966: IFFALSE 9970
// exit ;
9968: GO 10194
// dist := GetDistXY ( GetX ( player_artifact_selected_unit ) , GetY ( player_artifact_selected_unit ) , cr1 , cr2 ) ;
9970: LD_ADDR_VAR 0 9
9974: PUSH
9975: LD_EXP 30
9979: PPUSH
9980: CALL_OW 250
9984: PPUSH
9985: LD_EXP 30
9989: PPUSH
9990: CALL_OW 251
9994: PPUSH
9995: LD_VAR 0 3
9999: PPUSH
10000: LD_VAR 0 4
10004: PPUSH
10005: CALL_OW 298
10009: ST_TO_ADDR
// cost := GetUseCost ( dist ) ;
10010: LD_ADDR_VAR 0 10
10014: PUSH
10015: LD_VAR 0 9
10019: PPUSH
10020: CALL 9040 0 1
10024: ST_TO_ADDR
// if cost > GetSibResources ( your_side ) then
10025: LD_VAR 0 10
10029: PUSH
10030: LD_OWVAR 2
10034: PPUSH
10035: CALL 5167 0 1
10039: GREATER
10040: IFFALSE 10054
// begin HintSpec ( ArtFrogJumpCost , 2 ) ;
10042: LD_STRING ArtFrogJumpCost
10044: PPUSH
10045: LD_INT 2
10047: PPUSH
10048: CALL_OW 338
// exit ;
10052: GO 10194
// end ; SetSibResources ( your_side , cost ) ;
10054: LD_OWVAR 2
10058: PPUSH
10059: LD_VAR 0 10
10063: PPUSH
10064: CALL 5291 0 2
// TeleportUnit ( player_artifact_selected_unit , cr1 , cr2 , 0 , true ) ;
10068: LD_EXP 30
10072: PPUSH
10073: LD_VAR 0 3
10077: PPUSH
10078: LD_VAR 0 4
10082: PPUSH
10083: LD_INT 0
10085: PPUSH
10086: LD_INT 1
10088: PPUSH
10089: CALL_OW 483
// CenterOnXY ( cr1 , cr2 ) ;
10093: LD_VAR 0 3
10097: PPUSH
10098: LD_VAR 0 4
10102: PPUSH
10103: CALL_OW 84
// player_artifact_selected_unit := 0 ;
10107: LD_ADDR_EXP 30
10111: PUSH
10112: LD_INT 0
10114: ST_TO_ADDR
// player_artifact_researched := false ;
10115: LD_ADDR_EXP 22
10119: PUSH
10120: LD_INT 0
10122: ST_TO_ADDR
// SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
10123: LD_OWVAR 2
10127: PPUSH
10128: LD_EXP 20
10132: PPUSH
10133: LD_INT 1
10135: PPUSH
10136: LD_VAR 0 7
10140: PPUSH
10141: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_no , lab ) ;
10145: LD_OWVAR 2
10149: PPUSH
10150: LD_EXP 21
10154: PPUSH
10155: LD_INT 0
10157: PPUSH
10158: LD_VAR 0 7
10162: PPUSH
10163: CALL_OW 468
// Wait ( player_artifact_time_refresh ) ;
10167: LD_EXP 26
10171: PPUSH
10172: CALL_OW 67
// player_artifact_researched := true ;
10176: LD_ADDR_EXP 22
10180: PUSH
10181: LD_INT 1
10183: ST_TO_ADDR
// end ; if debug then
10184: LD_EXP 6
10188: IFFALSE 10194
// DebugArtifact ;
10190: CALL 8804 0 0
// end ;
10194: PPOPN 10
10196: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 255
10206: PUSH
10207: LD_OWVAR 2
10211: EQUAL
10212: IFFALSE 10251
// begin SetArtifactUse ( your_side , player_artifact_icon_res , art_no , lab ) ;
10214: LD_OWVAR 2
10218: PPUSH
10219: LD_EXP 25
10223: PPUSH
10224: LD_INT 0
10226: PPUSH
10227: LD_VAR 0 1
10231: PPUSH
10232: CALL_OW 468
// player_artifact_ready := true ;
10236: LD_ADDR_EXP 29
10240: PUSH
10241: LD_INT 1
10243: ST_TO_ADDR
// Hint ( ArtFrogJump ) ;
10244: LD_STRING ArtFrogJump
10246: PPUSH
10247: CALL_OW 339
// end ; end ;
10251: PPOPN 1
10253: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , player_artifact_icon_res , art_instant , lab ) ;
10254: LD_OWVAR 2
10258: PPUSH
10259: LD_EXP 25
10263: PPUSH
10264: LD_INT 2
10266: PPUSH
10267: LD_VAR 0 1
10271: PPUSH
10272: CALL_OW 468
// end ;
10276: PPOPN 2
10278: END
// export function ActiveArtifact1 ( ) ; var i , tmp , un ; begin
10279: LD_INT 0
10281: PPUSH
10282: PPUSH
10283: PPUSH
10284: PPUSH
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_weapon , ru_siberium_rocket ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_siberite_power ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_siberite_mine ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_ext_siberium ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_teleport ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_bweapon , ru_time_lapser ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_bweapon , ru_rocket ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_engine , engine_siberite ] ] ) ;
10285: LD_ADDR_VAR 0 3
10289: PUSH
10290: LD_INT 81
10292: PUSH
10293: LD_INT 7
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 34
10302: PUSH
10303: LD_INT 48
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: PPUSH
10314: CALL_OW 69
10318: PUSH
10319: LD_INT 81
10321: PUSH
10322: LD_INT 7
10324: PUSH
10325: EMPTY
10326: LIST
10327: LIST
10328: PUSH
10329: LD_INT 30
10331: PUSH
10332: LD_INT 28
10334: PUSH
10335: EMPTY
10336: LIST
10337: LIST
10338: PUSH
10339: EMPTY
10340: LIST
10341: LIST
10342: PPUSH
10343: CALL_OW 69
10347: ADD
10348: PUSH
10349: LD_INT 81
10351: PUSH
10352: LD_INT 7
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: PUSH
10359: LD_INT 30
10361: PUSH
10362: LD_INT 30
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: PUSH
10369: EMPTY
10370: LIST
10371: LIST
10372: PPUSH
10373: CALL_OW 69
10377: ADD
10378: PUSH
10379: LD_INT 81
10381: PUSH
10382: LD_INT 7
10384: PUSH
10385: EMPTY
10386: LIST
10387: LIST
10388: PUSH
10389: LD_INT 30
10391: PUSH
10392: LD_INT 21
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: PPUSH
10403: CALL_OW 69
10407: ADD
10408: PUSH
10409: LD_INT 81
10411: PUSH
10412: LD_INT 7
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 30
10421: PUSH
10422: LD_INT 34
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PUSH
10429: EMPTY
10430: LIST
10431: LIST
10432: PPUSH
10433: CALL_OW 69
10437: ADD
10438: PUSH
10439: LD_INT 81
10441: PUSH
10442: LD_INT 7
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: LD_INT 35
10451: PUSH
10452: LD_INT 49
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: PPUSH
10463: CALL_OW 69
10467: ADD
10468: PUSH
10469: LD_INT 81
10471: PUSH
10472: LD_INT 7
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: PUSH
10479: LD_INT 35
10481: PUSH
10482: LD_INT 47
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PUSH
10489: EMPTY
10490: LIST
10491: LIST
10492: PPUSH
10493: CALL_OW 69
10497: ADD
10498: PUSH
10499: LD_INT 81
10501: PUSH
10502: LD_INT 7
10504: PUSH
10505: EMPTY
10506: LIST
10507: LIST
10508: PUSH
10509: LD_INT 32
10511: PUSH
10512: LD_INT 3
10514: PUSH
10515: EMPTY
10516: LIST
10517: LIST
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: PPUSH
10523: CALL_OW 69
10527: ADD
10528: ST_TO_ADDR
// if not tmp then
10529: LD_VAR 0 3
10533: NOT
10534: IFFALSE 10538
// exit ;
10536: GO 10659
// if UnitFilter ( tmp , [ f_weapon , ru_siberium_rocket ] ) then
10538: LD_VAR 0 3
10542: PPUSH
10543: LD_INT 34
10545: PUSH
10546: LD_INT 48
10548: PUSH
10549: EMPTY
10550: LIST
10551: LIST
10552: PPUSH
10553: CALL_OW 72
10557: IFFALSE 10590
// un := UnitFilter ( tmp , [ f_weapon , ru_siberium_rocket ] ) [ 1 ] else
10559: LD_ADDR_VAR 0 4
10563: PUSH
10564: LD_VAR 0 3
10568: PPUSH
10569: LD_INT 34
10571: PUSH
10572: LD_INT 48
10574: PUSH
10575: EMPTY
10576: LIST
10577: LIST
10578: PPUSH
10579: CALL_OW 72
10583: PUSH
10584: LD_INT 1
10586: ARRAY
10587: ST_TO_ADDR
10588: GO 10614
// un := tmp [ rand ( 1 , tmp ) ] ;
10590: LD_ADDR_VAR 0 4
10594: PUSH
10595: LD_VAR 0 3
10599: PUSH
10600: LD_INT 1
10602: PPUSH
10603: LD_VAR 0 3
10607: PPUSH
10608: CALL_OW 12
10612: ARRAY
10613: ST_TO_ADDR
// if not alliance_used_artifact_1 then
10614: LD_EXP 10
10618: NOT
10619: IFFALSE 10650
// alliance_used_artifact_1 := [ GetX ( un ) , GetY ( un ) ] ;
10621: LD_ADDR_EXP 10
10625: PUSH
10626: LD_VAR 0 4
10630: PPUSH
10631: CALL_OW 250
10635: PUSH
10636: LD_VAR 0 4
10640: PPUSH
10641: CALL_OW 251
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: ST_TO_ADDR
// KillUnit ( un ) ;
10650: LD_VAR 0 4
10654: PPUSH
10655: CALL_OW 66
// end ;
10659: LD_VAR 0 1
10663: RET
// export function ActiveArtifact2 ( ) ; var i , un , tmp ; begin
10664: LD_INT 0
10666: PPUSH
10667: PPUSH
10668: PPUSH
10669: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , 6 ] , [ f_control , control_computer ] ] ) ;
10670: LD_ADDR_VAR 0 4
10674: PUSH
10675: LD_INT 22
10677: PUSH
10678: LD_INT 6
10680: PUSH
10681: EMPTY
10682: LIST
10683: LIST
10684: PUSH
10685: LD_INT 33
10687: PUSH
10688: LD_INT 3
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: PPUSH
10699: CALL_OW 69
10703: ST_TO_ADDR
// if not tmp then
10704: LD_VAR 0 4
10708: NOT
10709: IFFALSE 10713
// exit ;
10711: GO 10839
// un := tmp [ rand ( 1 , tmp ) ] ;
10713: LD_ADDR_VAR 0 3
10717: PUSH
10718: LD_VAR 0 4
10722: PUSH
10723: LD_INT 1
10725: PPUSH
10726: LD_VAR 0 4
10730: PPUSH
10731: CALL_OW 12
10735: ARRAY
10736: ST_TO_ADDR
// if GetWeapon ( un ) = ru_siberium_rocket then
10737: LD_VAR 0 3
10741: PPUSH
10742: CALL_OW 264
10746: PUSH
10747: LD_INT 48
10749: EQUAL
10750: IFFALSE 10769
// ComAttackPlace ( un , 194 , 19 ) else
10752: LD_VAR 0 3
10756: PPUSH
10757: LD_INT 194
10759: PPUSH
10760: LD_INT 19
10762: PPUSH
10763: CALL_OW 116
10767: GO 10803
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , un ) ) ;
10769: LD_VAR 0 3
10773: PPUSH
10774: LD_INT 81
10776: PUSH
10777: LD_INT 7
10779: PUSH
10780: EMPTY
10781: LIST
10782: LIST
10783: PPUSH
10784: CALL_OW 69
10788: PPUSH
10789: LD_VAR 0 3
10793: PPUSH
10794: CALL_OW 74
10798: PPUSH
10799: CALL_OW 115
// if not alliance_used_artifact_2 then
10803: LD_EXP 11
10807: NOT
10808: IFFALSE 10839
// alliance_used_artifact_2 := [ GetX ( un ) , GetY ( un ) ] ;
10810: LD_ADDR_EXP 11
10814: PUSH
10815: LD_VAR 0 3
10819: PPUSH
10820: CALL_OW 250
10824: PUSH
10825: LD_VAR 0 3
10829: PPUSH
10830: CALL_OW 251
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: ST_TO_ADDR
// end ; end_of_file
10839: LD_VAR 0 1
10843: RET
// export function DebugMode ; var i , j , b ; begin
10844: LD_INT 0
10846: PPUSH
10847: PPUSH
10848: PPUSH
10849: PPUSH
// enable_addtolog = true ;
10850: LD_ADDR_OWVAR 81
10854: PUSH
10855: LD_INT 1
10857: ST_TO_ADDR
// FogOff ( 6 ) ;
10858: LD_INT 6
10860: PPUSH
10861: CALL_OW 344
// uc_side = 6 ;
10865: LD_ADDR_OWVAR 20
10869: PUSH
10870: LD_INT 6
10872: ST_TO_ADDR
// uc_nation = 3 ;
10873: LD_ADDR_OWVAR 21
10877: PUSH
10878: LD_INT 3
10880: ST_TO_ADDR
// bc_level = 10 ;
10881: LD_ADDR_OWVAR 43
10885: PUSH
10886: LD_INT 10
10888: ST_TO_ADDR
// bc_type := b_lab_full ;
10889: LD_ADDR_OWVAR 42
10893: PUSH
10894: LD_INT 8
10896: ST_TO_ADDR
// bc_kind1 := 11 ;
10897: LD_ADDR_OWVAR 44
10901: PUSH
10902: LD_INT 11
10904: ST_TO_ADDR
// bc_kind2 := 12 ;
10905: LD_ADDR_OWVAR 45
10909: PUSH
10910: LD_INT 12
10912: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 189 , 20 , 1 ) ;
10913: LD_INT 189
10915: PPUSH
10916: LD_INT 20
10918: PPUSH
10919: LD_INT 1
10921: PPUSH
10922: CALL_OW 47
// bc_type := b_warehouse ;
10926: LD_ADDR_OWVAR 42
10930: PUSH
10931: LD_INT 1
10933: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 201 , 22 , 4 ) ;
10934: LD_ADDR_VAR 0 4
10938: PUSH
10939: LD_INT 201
10941: PPUSH
10942: LD_INT 22
10944: PPUSH
10945: LD_INT 4
10947: PPUSH
10948: CALL_OW 47
10952: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , 10000 ) ;
10953: LD_VAR 0 4
10957: PPUSH
10958: CALL_OW 274
10962: PPUSH
10963: LD_INT 1
10965: PPUSH
10966: LD_INT 10000
10968: PPUSH
10969: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , 10000 ) ;
10973: LD_VAR 0 4
10977: PPUSH
10978: CALL_OW 274
10982: PPUSH
10983: LD_INT 2
10985: PPUSH
10986: LD_INT 10000
10988: PPUSH
10989: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , 10000 ) ;
10993: LD_VAR 0 4
10997: PPUSH
10998: CALL_OW 274
11002: PPUSH
11003: LD_INT 3
11005: PPUSH
11006: LD_INT 10000
11008: PPUSH
11009: CALL_OW 277
// bc_type := b_siberite_power ;
11013: LD_ADDR_OWVAR 42
11017: PUSH
11018: LD_INT 28
11020: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 216 , 16 , 4 ) ;
11021: LD_ADDR_VAR 0 4
11025: PUSH
11026: LD_INT 216
11028: PPUSH
11029: LD_INT 16
11031: PPUSH
11032: LD_INT 4
11034: PPUSH
11035: CALL_OW 47
11039: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 219 , 16 , 4 ) ;
11040: LD_ADDR_VAR 0 4
11044: PUSH
11045: LD_INT 219
11047: PPUSH
11048: LD_INT 16
11050: PPUSH
11051: LD_INT 4
11053: PPUSH
11054: CALL_OW 47
11058: ST_TO_ADDR
// SetTech ( tech_sib2 , 6 , state_researched ) ;
11059: LD_INT 55
11061: PPUSH
11062: LD_INT 6
11064: PPUSH
11065: LD_INT 2
11067: PPUSH
11068: CALL_OW 322
// SetTech ( tech_sib3 , 6 , state_researched ) ;
11072: LD_INT 56
11074: PPUSH
11075: LD_INT 6
11077: PPUSH
11078: LD_INT 2
11080: PPUSH
11081: CALL_OW 322
// end ;
11085: LD_VAR 0 1
11089: RET
