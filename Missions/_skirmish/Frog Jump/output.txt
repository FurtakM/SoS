// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// debug := false ;
   8: LD_ADDR_EXP 6
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// InitVariables ;
  16: CALL 94 0 0
// InitArtifactsPos ;
  20: CALL 9074 0 0
// PrepareAnimals ( 6 , 1 , 1 , cratesArea ) ;
  24: LD_INT 6
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 1
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: CALL 8453 0 4
// PrepareAlliance ;
  40: CALL 339 0 0
// PrepareLegion ;
  44: CALL 1942 0 0
// if debug then
  48: LD_EXP 6
  52: IFFALSE 76
// begin alliance_attack_active := true ;
  54: LD_ADDR_EXP 9
  58: PUSH
  59: LD_INT 1
  61: ST_TO_ADDR
// Difficulty := 2 ;
  62: LD_ADDR_OWVAR 67
  66: PUSH
  67: LD_INT 2
  69: ST_TO_ADDR
// DebugMode ;
  70: CALL 11049 0 0
// end else
  74: GO 89
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  76: LD_ADDR_OWVAR 67
  80: PUSH
  81: LD_INT 0
  83: PPUSH
  84: CALL_OW 426
  88: ST_TO_ADDR
// Action ;
  89: CALL 7273 0 0
// end ;
  93: END
// export Bagins , Davidov , Vervecken ; export player_start_res_sib_bomb , player_start_res_artifact , debug , legion_attacks_active , legion_attack_strenght , alliance_attack_active , alliance_used_artifact_1 , alliance_used_artifact_2 , player_used_sib_bomb , artifacts_mode , artifacts_type , artifacts_pos , artifact_destroyed , sib_rocket_range , player_artifact_loaded , player_artifact_number , player_artifact_icon , player_artifact_icon_2 , player_artifact_researched , player_artifact_active_distance , player_artifact_icon_type , player_artifact_icon_res , player_artifact_time_refresh , player_artifact_time_res , player_side , player_artifact_ready , player_artifact_selected_unit , alliance_attack_strength ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// player_start_res_sib_bomb := false ;
  97: LD_ADDR_EXP 4
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// player_start_res_artifact := false ;
 105: LD_ADDR_EXP 5
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// legion_attacks_active := false ;
 113: LD_ADDR_EXP 7
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// legion_attack_strenght := 3 ;
 121: LD_ADDR_EXP 8
 125: PUSH
 126: LD_INT 3
 128: ST_TO_ADDR
// alliance_attack_strength := 0 ;
 129: LD_ADDR_EXP 31
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// alliance_attack_active := false ;
 137: LD_ADDR_EXP 9
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// alliance_used_artifact_1 := false ;
 145: LD_ADDR_EXP 10
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// alliance_used_artifact_2 := false ;
 153: LD_ADDR_EXP 11
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// artifacts_mode := [ 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: EMPTY
 176: LIST
 177: LIST
 178: LIST
 179: ST_TO_ADDR
// artifacts_type := [ 2 , 3 , 5 ] ;
 180: LD_ADDR_EXP 14
 184: PUSH
 185: LD_INT 2
 187: PUSH
 188: LD_INT 3
 190: PUSH
 191: LD_INT 5
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// artifacts_pos := [ ] ;
 199: LD_ADDR_EXP 15
 203: PUSH
 204: EMPTY
 205: ST_TO_ADDR
// artifact_destroyed := false ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_INT 0
 213: ST_TO_ADDR
// sib_rocket_range := 25 ;
 214: LD_ADDR_EXP 17
 218: PUSH
 219: LD_INT 25
 221: ST_TO_ADDR
// player_used_sib_bomb := false ;
 222: LD_ADDR_EXP 12
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// player_artifact_loaded := true ;
 230: LD_ADDR_EXP 18
 234: PUSH
 235: LD_INT 1
 237: ST_TO_ADDR
// player_artifact_number := 6 ;
 238: LD_ADDR_EXP 19
 242: PUSH
 243: LD_INT 6
 245: ST_TO_ADDR
// player_artifact_icon := art_use_human ;
 246: LD_ADDR_EXP 20
 250: PUSH
 251: LD_INT 10
 253: ST_TO_ADDR
// player_artifact_icon_2 := art_use_teleport ;
 254: LD_ADDR_EXP 21
 258: PUSH
 259: LD_INT 6
 261: ST_TO_ADDR
// player_artifact_researched := false ;
 262: LD_ADDR_EXP 22
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// player_artifact_active_distance := 5 ;
 270: LD_ADDR_EXP 23
 274: PUSH
 275: LD_INT 5
 277: ST_TO_ADDR
// player_artifact_time_refresh := 8500 ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 8500
 285: ST_TO_ADDR
// player_artifact_icon_type := art_place ;
 286: LD_ADDR_EXP 24
 290: PUSH
 291: LD_INT 3
 293: ST_TO_ADDR
// player_artifact_icon_res := art_exp_left ;
 294: LD_ADDR_EXP 25
 298: PUSH
 299: LD_INT 1
 301: ST_TO_ADDR
// player_artifact_time_res := 300 ;
 302: LD_ADDR_EXP 27
 306: PUSH
 307: LD_INT 300
 309: ST_TO_ADDR
// player_artifact_ready := false ;
 310: LD_ADDR_EXP 29
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// player_artifact_selected_unit := 0 ;
 318: LD_ADDR_EXP 30
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// player_side := 6 ;
 326: LD_ADDR_EXP 28
 330: PUSH
 331: LD_INT 6
 333: ST_TO_ADDR
// end ; end_of_file
 334: LD_VAR 0 1
 338: RET
// export al_force ; export function PrepareAlliance ; var i , un , skill ; begin
 339: LD_INT 0
 341: PPUSH
 342: PPUSH
 343: PPUSH
 344: PPUSH
// uc_side := 7 ;
 345: LD_ADDR_OWVAR 20
 349: PUSH
 350: LD_INT 7
 352: ST_TO_ADDR
// uc_nation := nation_american ;
 353: LD_ADDR_OWVAR 21
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
 361: LD_ADDR_VAR 0 4
 365: PUSH
 366: LD_INT 7
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 9
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: PUSH
 380: LD_OWVAR 67
 384: ARRAY
 385: ST_TO_ADDR
// al_force := [ ] ;
 386: LD_ADDR_EXP 32
 390: PUSH
 391: EMPTY
 392: ST_TO_ADDR
// SetResourceType ( GetBase ( al_dep ) , mat_cans , 999999 ) ;
 393: LD_INT 1
 395: PPUSH
 396: CALL_OW 274
 400: PPUSH
 401: LD_INT 1
 403: PPUSH
 404: LD_INT 999999
 406: PPUSH
 407: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_oil , 10000 ) ;
 411: LD_INT 1
 413: PPUSH
 414: CALL_OW 274
 418: PPUSH
 419: LD_INT 2
 421: PPUSH
 422: LD_INT 10000
 424: PPUSH
 425: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_siberit , 10000 ) ;
 429: LD_INT 1
 431: PPUSH
 432: CALL_OW 274
 436: PPUSH
 437: LD_INT 3
 439: PPUSH
 440: LD_INT 10000
 442: PPUSH
 443: CALL_OW 277
// hc_gallery := sandal ;
 447: LD_ADDR_OWVAR 33
 451: PUSH
 452: LD_STRING sandal
 454: ST_TO_ADDR
// hc_face_number := 13 ;
 455: LD_ADDR_OWVAR 34
 459: PUSH
 460: LD_INT 13
 462: ST_TO_ADDR
// hc_class := 1 ;
 463: LD_ADDR_OWVAR 28
 467: PUSH
 468: LD_INT 1
 470: ST_TO_ADDR
// hc_name := Matthew Bagins ;
 471: LD_ADDR_OWVAR 26
 475: PUSH
 476: LD_STRING Matthew Bagins
 478: ST_TO_ADDR
// hc_skills := [ 10 , 5 , 8 , 5 ] ;
 479: LD_ADDR_OWVAR 31
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: LD_INT 5
 489: PUSH
 490: LD_INT 8
 492: PUSH
 493: LD_INT 5
 495: PUSH
 496: EMPTY
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: ST_TO_ADDR
// hc_attr := [ 11 , 12 ] ;
 502: LD_ADDR_OWVAR 29
 506: PUSH
 507: LD_INT 11
 509: PUSH
 510: LD_INT 12
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: ST_TO_ADDR
// Bagins := CreateHuman ;
 517: LD_ADDR_EXP 1
 521: PUSH
 522: CALL_OW 44
 526: ST_TO_ADDR
// PlaceHumanInUnit ( Bagins , al_dep ) ;
 527: LD_EXP 1
 531: PPUSH
 532: LD_INT 1
 534: PPUSH
 535: CALL_OW 52
// hc_gallery :=  ;
 539: LD_ADDR_OWVAR 33
 543: PUSH
 544: LD_STRING 
 546: ST_TO_ADDR
// hc_name :=  ;
 547: LD_ADDR_OWVAR 26
 551: PUSH
 552: LD_STRING 
 554: ST_TO_ADDR
// for i = 1 to 6 do
 555: LD_ADDR_VAR 0 2
 559: PUSH
 560: DOUBLE
 561: LD_INT 1
 563: DEC
 564: ST_TO_ADDR
 565: LD_INT 6
 567: PUSH
 568: FOR_TO
 569: IFFALSE 630
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 571: LD_ADDR_OWVAR 21
 575: PUSH
 576: LD_INT 1
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: PUSH
 586: LD_INT 1
 588: PPUSH
 589: LD_INT 2
 591: PPUSH
 592: CALL_OW 12
 596: ARRAY
 597: ST_TO_ADDR
// PrepareHuman ( false , class_engineer , skill ) ;
 598: LD_INT 0
 600: PPUSH
 601: LD_INT 2
 603: PPUSH
 604: LD_VAR 0 4
 608: PPUSH
 609: CALL_OW 380
// PlaceUnitArea ( CreateHuman , al_base , false ) ;
 613: CALL_OW 44
 617: PPUSH
 618: LD_INT 1
 620: PPUSH
 621: LD_INT 0
 623: PPUSH
 624: CALL_OW 49
// end ;
 628: GO 568
 630: POP
 631: POP
// for i = 1 to 6 do
 632: LD_ADDR_VAR 0 2
 636: PUSH
 637: DOUBLE
 638: LD_INT 1
 640: DEC
 641: ST_TO_ADDR
 642: LD_INT 6
 644: PUSH
 645: FOR_TO
 646: IFFALSE 704
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 648: LD_ADDR_OWVAR 21
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 3
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: PUSH
 663: LD_INT 1
 665: PPUSH
 666: LD_INT 2
 668: PPUSH
 669: CALL_OW 12
 673: ARRAY
 674: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 675: LD_INT 0
 677: PPUSH
 678: LD_INT 3
 680: PPUSH
 681: LD_VAR 0 4
 685: PPUSH
 686: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_ru ) ;
 690: CALL_OW 44
 694: PPUSH
 695: LD_INT 6
 697: PPUSH
 698: CALL_OW 52
// end ;
 702: GO 645
 704: POP
 705: POP
// for i = 1 to 6 do
 706: LD_ADDR_VAR 0 2
 710: PUSH
 711: DOUBLE
 712: LD_INT 1
 714: DEC
 715: ST_TO_ADDR
 716: LD_INT 6
 718: PUSH
 719: FOR_TO
 720: IFFALSE 778
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 722: LD_ADDR_OWVAR 21
 726: PUSH
 727: LD_INT 1
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: PUSH
 737: LD_INT 1
 739: PPUSH
 740: LD_INT 2
 742: PPUSH
 743: CALL_OW 12
 747: ARRAY
 748: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 749: LD_INT 0
 751: PPUSH
 752: LD_INT 3
 754: PPUSH
 755: LD_VAR 0 4
 759: PPUSH
 760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_us ) ;
 764: CALL_OW 44
 768: PPUSH
 769: LD_INT 11
 771: PPUSH
 772: CALL_OW 52
// end ;
 776: GO 719
 778: POP
 779: POP
// for i = 1 to 6 do
 780: LD_ADDR_VAR 0 2
 784: PUSH
 785: DOUBLE
 786: LD_INT 1
 788: DEC
 789: ST_TO_ADDR
 790: LD_INT 6
 792: PUSH
 793: FOR_TO
 794: IFFALSE 871
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 796: LD_ADDR_OWVAR 21
 800: PUSH
 801: LD_INT 1
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: PUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 2
 816: PPUSH
 817: CALL_OW 12
 821: ARRAY
 822: ST_TO_ADDR
// PrepareHuman ( false , class_scientistic , skill ) ;
 823: LD_INT 0
 825: PPUSH
 826: LD_INT 4
 828: PPUSH
 829: LD_VAR 0 4
 833: PPUSH
 834: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , [ al_lab_us , al_lab_ru ] [ Rand ( 1 , 2 ) ] ) ;
 838: CALL_OW 44
 842: PPUSH
 843: LD_INT 2
 845: PUSH
 846: LD_INT 5
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_INT 2
 858: PPUSH
 859: CALL_OW 12
 863: ARRAY
 864: PPUSH
 865: CALL_OW 52
// end ;
 869: GO 793
 871: POP
 872: POP
// for i = 1 to 6 do
 873: LD_ADDR_VAR 0 2
 877: PUSH
 878: DOUBLE
 879: LD_INT 1
 881: DEC
 882: ST_TO_ADDR
 883: LD_INT 6
 885: PUSH
 886: FOR_TO
 887: IFFALSE 994
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 889: LD_ADDR_OWVAR 21
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 3
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PUSH
 904: LD_INT 1
 906: PPUSH
 907: LD_INT 2
 909: PPUSH
 910: CALL_OW 12
 914: ARRAY
 915: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker ] [ Rand ( 1 , 2 ) ] , skill ) ;
 916: LD_INT 0
 918: PPUSH
 919: LD_INT 5
 921: PUSH
 922: LD_INT 9
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PUSH
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 2
 934: PPUSH
 935: CALL_OW 12
 939: ARRAY
 940: PPUSH
 941: LD_VAR 0 4
 945: PPUSH
 946: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 950: CALL_OW 44
 954: PPUSH
 955: LD_INT 22
 957: PUSH
 958: LD_INT 7
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PUSH
 965: LD_INT 30
 967: PUSH
 968: LD_INT 5
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PPUSH
 979: CALL_OW 69
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: CALL_OW 52
// end ;
 992: GO 886
 994: POP
 995: POP
// uc_nation := 3 ;
 996: LD_ADDR_OWVAR 21
1000: PUSH
1001: LD_INT 3
1003: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , skill ) ;
1004: LD_INT 0
1006: PPUSH
1007: LD_INT 5
1009: PPUSH
1010: LD_VAR 0 4
1014: PPUSH
1015: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_bun ) ;
1019: CALL_OW 44
1023: PPUSH
1024: LD_INT 50
1026: PPUSH
1027: CALL_OW 52
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) do
1031: LD_ADDR_VAR 0 2
1035: PUSH
1036: LD_INT 22
1038: PUSH
1039: LD_INT 7
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: PUSH
1046: LD_INT 30
1048: PUSH
1049: LD_INT 33
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: PUSH
1056: EMPTY
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL_OW 69
1064: PUSH
1065: FOR_IN
1066: IFFALSE 1130
// if GetNation ( i ) = 1 then
1068: LD_VAR 0 2
1072: PPUSH
1073: CALL_OW 248
1077: PUSH
1078: LD_INT 1
1080: EQUAL
1081: IFFALSE 1097
// AddComPlaceWeapon ( i , us_double_laser ) else
1083: LD_VAR 0 2
1087: PPUSH
1088: LD_INT 10
1090: PPUSH
1091: CALL_OW 208
1095: GO 1128
// AddComPlaceWeapon ( i , [ ru_rocket , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
1097: LD_VAR 0 2
1101: PPUSH
1102: LD_INT 47
1104: PUSH
1105: LD_INT 45
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PUSH
1112: LD_INT 1
1114: PPUSH
1115: LD_INT 2
1117: PPUSH
1118: CALL_OW 12
1122: ARRAY
1123: PPUSH
1124: CALL_OW 208
1128: GO 1065
1130: POP
1131: POP
// end ;
1132: LD_VAR 0 1
1136: RET
// export function ConstructAlVeh ( nation ) ; var i , un , fac , chassis , engine , control , weapon ; begin
1137: LD_INT 0
1139: PPUSH
1140: PPUSH
1141: PPUSH
1142: PPUSH
1143: PPUSH
1144: PPUSH
1145: PPUSH
1146: PPUSH
// if nation = 2 then
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 2
1154: EQUAL
1155: IFFALSE 1159
// exit ;
1157: GO 1378
// if nation = 1 then
1159: LD_VAR 0 1
1163: PUSH
1164: LD_INT 1
1166: EQUAL
1167: IFFALSE 1185
// if al_fac_us then
1169: LD_INT 11
1171: IFFALSE 1183
// fac := al_fac_us else
1173: LD_ADDR_VAR 0 5
1177: PUSH
1178: LD_INT 11
1180: ST_TO_ADDR
1181: GO 1185
// exit ;
1183: GO 1378
// if nation = 3 then
1185: LD_VAR 0 1
1189: PUSH
1190: LD_INT 3
1192: EQUAL
1193: IFFALSE 1211
// if al_fac_ru then
1195: LD_INT 6
1197: IFFALSE 1209
// fac := al_fac_ru else
1199: LD_ADDR_VAR 0 5
1203: PUSH
1204: LD_INT 6
1206: ST_TO_ADDR
1207: GO 1211
// exit ;
1209: GO 1378
// if nation = 1 then
1211: LD_VAR 0 1
1215: PUSH
1216: LD_INT 1
1218: EQUAL
1219: IFFALSE 1231
// chassis := us_morphling else
1221: LD_ADDR_VAR 0 6
1225: PUSH
1226: LD_INT 5
1228: ST_TO_ADDR
1229: GO 1239
// chassis := ru_heavy_tracked ;
1231: LD_ADDR_VAR 0 6
1235: PUSH
1236: LD_INT 24
1238: ST_TO_ADDR
// if nation = 1 then
1239: LD_VAR 0 1
1243: PUSH
1244: LD_INT 1
1246: EQUAL
1247: IFFALSE 1259
// engine := engine_combustion else
1249: LD_ADDR_VAR 0 7
1253: PUSH
1254: LD_INT 1
1256: ST_TO_ADDR
1257: GO 1267
// engine := engine_siberite ;
1259: LD_ADDR_VAR 0 7
1263: PUSH
1264: LD_INT 3
1266: ST_TO_ADDR
// control := control_computer ;
1267: LD_ADDR_VAR 0 8
1271: PUSH
1272: LD_INT 3
1274: ST_TO_ADDR
// if nation = 3 then
1275: LD_VAR 0 1
1279: PUSH
1280: LD_INT 3
1282: EQUAL
1283: IFFALSE 1306
// weapon := [ ru_rocket , ru_rocket_launcher , ru_gatling_gun ] else
1285: LD_ADDR_VAR 0 9
1289: PUSH
1290: LD_INT 47
1292: PUSH
1293: LD_INT 45
1295: PUSH
1296: LD_INT 43
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: LIST
1303: ST_TO_ADDR
1304: GO 1325
// weapon := [ us_heavy_gun , us_laser , us_double_laser ] ;
1306: LD_ADDR_VAR 0 9
1310: PUSH
1311: LD_INT 6
1313: PUSH
1314: LD_INT 9
1316: PUSH
1317: LD_INT 10
1319: PUSH
1320: EMPTY
1321: LIST
1322: LIST
1323: LIST
1324: ST_TO_ADDR
// weapon := weapon [ rand ( 1 , weapon ) ] ;
1325: LD_ADDR_VAR 0 9
1329: PUSH
1330: LD_VAR 0 9
1334: PUSH
1335: LD_INT 1
1337: PPUSH
1338: LD_VAR 0 9
1342: PPUSH
1343: CALL_OW 12
1347: ARRAY
1348: ST_TO_ADDR
// AddComConstruct ( fac , chassis , engine , control , weapon ) ;
1349: LD_VAR 0 5
1353: PPUSH
1354: LD_VAR 0 6
1358: PPUSH
1359: LD_VAR 0 7
1363: PPUSH
1364: LD_VAR 0 8
1368: PPUSH
1369: LD_VAR 0 9
1373: PPUSH
1374: CALL_OW 185
// end ;
1378: LD_VAR 0 2
1382: RET
// every 0 0$01 trigger FilterUnitsInArea ( al_teleport_enter , [ [ f_side , 7 ] , [ f_not , [ f_type , unit_building ] ] ] ) do var tmp , i , xy ;
1383: LD_INT 4
1385: PPUSH
1386: LD_INT 22
1388: PUSH
1389: LD_INT 7
1391: PUSH
1392: EMPTY
1393: LIST
1394: LIST
1395: PUSH
1396: LD_INT 3
1398: PUSH
1399: LD_INT 21
1401: PUSH
1402: LD_INT 3
1404: PUSH
1405: EMPTY
1406: LIST
1407: LIST
1408: PUSH
1409: EMPTY
1410: LIST
1411: LIST
1412: PUSH
1413: EMPTY
1414: LIST
1415: LIST
1416: PPUSH
1417: CALL_OW 70
1421: IFFALSE 1565
1423: GO 1425
1425: DISABLE
1426: LD_INT 0
1428: PPUSH
1429: PPUSH
1430: PPUSH
// begin enable ;
1431: ENABLE
// tmp := FilterUnitsInArea ( al_teleport_enter , [ [ f_side , 7 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
1432: LD_ADDR_VAR 0 1
1436: PUSH
1437: LD_INT 4
1439: PPUSH
1440: LD_INT 22
1442: PUSH
1443: LD_INT 7
1445: PUSH
1446: EMPTY
1447: LIST
1448: LIST
1449: PUSH
1450: LD_INT 3
1452: PUSH
1453: LD_INT 21
1455: PUSH
1456: LD_INT 3
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: PPUSH
1471: CALL_OW 70
1475: ST_TO_ADDR
// xy := [ 225 , 16 ] ;
1476: LD_ADDR_VAR 0 3
1480: PUSH
1481: LD_INT 225
1483: PUSH
1484: LD_INT 16
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// if Prob ( 50 ) then
1491: LD_INT 50
1493: PPUSH
1494: CALL_OW 13
1498: IFFALSE 1515
// xy := [ 170 , 13 ] ;
1500: LD_ADDR_VAR 0 3
1504: PUSH
1505: LD_INT 170
1507: PUSH
1508: LD_INT 13
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: ST_TO_ADDR
// for i in tmp do
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 1
1524: PUSH
1525: FOR_IN
1526: IFFALSE 1563
// TeleportUnit ( i , xy [ 1 ] , xy [ 2 ] , 12 , true ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_VAR 0 3
1537: PUSH
1538: LD_INT 1
1540: ARRAY
1541: PPUSH
1542: LD_VAR 0 3
1546: PUSH
1547: LD_INT 2
1549: ARRAY
1550: PPUSH
1551: LD_INT 12
1553: PPUSH
1554: LD_INT 1
1556: PPUSH
1557: CALL_OW 483
1561: GO 1525
1563: POP
1564: POP
// end ;
1565: PPOPN 3
1567: END
// every 12 12$00 trigger FilterAllUnits ( [ f_side , 7 ] ) and alliance_attack_active do var i ;
1568: LD_INT 22
1570: PUSH
1571: LD_INT 7
1573: PUSH
1574: EMPTY
1575: LIST
1576: LIST
1577: PPUSH
1578: CALL_OW 69
1582: PUSH
1583: LD_EXP 9
1587: AND
1588: IFFALSE 1735
1590: GO 1592
1592: DISABLE
1593: LD_INT 0
1595: PPUSH
// begin enable ;
1596: ENABLE
// alliance_attack_strength := alliance_attack_strength + 1 ;
1597: LD_ADDR_EXP 31
1601: PUSH
1602: LD_EXP 31
1606: PUSH
1607: LD_INT 1
1609: PLUS
1610: ST_TO_ADDR
// for i = 1 to ( [ 4 , 5 , 5 ] [ Difficulty ] ) + alliance_attack_strength do
1611: LD_ADDR_VAR 0 1
1615: PUSH
1616: DOUBLE
1617: LD_INT 1
1619: DEC
1620: ST_TO_ADDR
1621: LD_INT 4
1623: PUSH
1624: LD_INT 5
1626: PUSH
1627: LD_INT 5
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: LIST
1634: PUSH
1635: LD_OWVAR 67
1639: ARRAY
1640: PUSH
1641: LD_EXP 31
1645: PLUS
1646: PUSH
1647: FOR_TO
1648: IFFALSE 1678
// begin ConstructAlVeh ( [ 1 , 3 ] [ rand ( 1 , 2 ) ] ) ;
1650: LD_INT 1
1652: PUSH
1653: LD_INT 3
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: LD_INT 1
1662: PPUSH
1663: LD_INT 2
1665: PPUSH
1666: CALL_OW 12
1670: ARRAY
1671: PPUSH
1672: CALL 1137 0 1
// end ;
1676: GO 1647
1678: POP
1679: POP
// repeat wait ( 0 0$01 ) ;
1680: LD_INT 35
1682: PPUSH
1683: CALL_OW 67
// until al_force >= ( [ 4 , 5 , 5 ] [ Difficulty ] ) + alliance_attack_strength ;
1687: LD_EXP 32
1691: PUSH
1692: LD_INT 4
1694: PUSH
1695: LD_INT 5
1697: PUSH
1698: LD_INT 5
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: PUSH
1706: LD_OWVAR 67
1710: ARRAY
1711: PUSH
1712: LD_EXP 31
1716: PLUS
1717: GREATEREQUAL
1718: IFFALSE 1680
// AddComMoveXY ( al_force , 143 , 178 ) ;
1720: LD_EXP 32
1724: PPUSH
1725: LD_INT 143
1727: PPUSH
1728: LD_INT 178
1730: PPUSH
1731: CALL_OW 171
// end ;
1735: PPOPN 1
1737: END
// every 0 0$01 trigger FilterUnitsInArea ( islandArea , [ f_side , 7 ] ) do var i ;
1738: LD_INT 6
1740: PPUSH
1741: LD_INT 22
1743: PUSH
1744: LD_INT 7
1746: PUSH
1747: EMPTY
1748: LIST
1749: LIST
1750: PPUSH
1751: CALL_OW 70
1755: IFFALSE 1835
1757: GO 1759
1759: DISABLE
1760: LD_INT 0
1762: PPUSH
// begin enable ;
1763: ENABLE
// for i in FilterUnitsInArea ( islandArea , [ f_side , 7 ] ) do
1764: LD_ADDR_VAR 0 1
1768: PUSH
1769: LD_INT 6
1771: PPUSH
1772: LD_INT 22
1774: PUSH
1775: LD_INT 7
1777: PUSH
1778: EMPTY
1779: LIST
1780: LIST
1781: PPUSH
1782: CALL_OW 70
1786: PUSH
1787: FOR_IN
1788: IFFALSE 1833
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ) ;
1790: LD_VAR 0 1
1794: PPUSH
1795: LD_INT 81
1797: PUSH
1798: LD_VAR 0 1
1802: PPUSH
1803: CALL_OW 255
1807: PUSH
1808: EMPTY
1809: LIST
1810: LIST
1811: PPUSH
1812: CALL_OW 69
1816: PPUSH
1817: LD_VAR 0 1
1821: PPUSH
1822: CALL_OW 74
1826: PPUSH
1827: CALL_OW 115
1831: GO 1787
1833: POP
1834: POP
// end ;
1835: PPOPN 1
1837: END
// every 7 7$30 trigger alliance_attack_active do var reload_time ;
1838: LD_EXP 9
1842: IFFALSE 1939
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
// begin reload_time := [ 9 9$00 , 8 8$40 , 7 7$50 ] [ Difficulty ] ;
1850: LD_ADDR_VAR 0 1
1854: PUSH
1855: LD_INT 18900
1857: PUSH
1858: LD_INT 18200
1860: PUSH
1861: LD_INT 16450
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: LIST
1868: PUSH
1869: LD_OWVAR 67
1873: ARRAY
1874: ST_TO_ADDR
// repeat ActiveArtifact1 ( ) ;
1875: CALL 10484 0 0
// wait ( reload_time / 2 ) ;
1879: LD_VAR 0 1
1883: PUSH
1884: LD_INT 2
1886: DIVREAL
1887: PPUSH
1888: CALL_OW 67
// ActiveArtifact2 ( ) ;
1892: CALL 10869 0 0
// wait ( reload_time / 2 ) ;
1896: LD_VAR 0 1
1900: PUSH
1901: LD_INT 2
1903: DIVREAL
1904: PPUSH
1905: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) ;
1909: LD_INT 22
1911: PUSH
1912: LD_INT 7
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: PUSH
1919: LD_INT 30
1921: PUSH
1922: LD_INT 8
1924: PUSH
1925: EMPTY
1926: LIST
1927: LIST
1928: PUSH
1929: EMPTY
1930: LIST
1931: LIST
1932: PPUSH
1933: CALL_OW 69
1937: IFFALSE 1875
// end ; end_of_file
1939: PPOPN 1
1941: END
// export function PrepareLegion ; var i , un , skill , dep , fac ; begin
1942: LD_INT 0
1944: PPUSH
1945: PPUSH
1946: PPUSH
1947: PPUSH
1948: PPUSH
1949: PPUSH
// uc_side := 8 ;
1950: LD_ADDR_OWVAR 20
1954: PUSH
1955: LD_INT 8
1957: ST_TO_ADDR
// uc_nation := 2 ;
1958: LD_ADDR_OWVAR 21
1962: PUSH
1963: LD_INT 2
1965: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
1966: LD_ADDR_VAR 0 4
1970: PUSH
1971: LD_INT 7
1973: PUSH
1974: LD_INT 8
1976: PUSH
1977: LD_INT 9
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_OWVAR 67
1989: ARRAY
1990: ST_TO_ADDR
// dep := ar_base ;
1991: LD_ADDR_VAR 0 5
1995: PUSH
1996: LD_INT 57
1998: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
1999: LD_ADDR_VAR 0 6
2003: PUSH
2004: LD_INT 22
2006: PUSH
2007: LD_INT 8
2009: PUSH
2010: EMPTY
2011: LIST
2012: LIST
2013: PUSH
2014: LD_INT 30
2016: PUSH
2017: LD_INT 3
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: PUSH
2024: EMPTY
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 69
2032: PUSH
2033: LD_INT 1
2035: ARRAY
2036: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 999999 ) ;
2037: LD_VAR 0 5
2041: PPUSH
2042: CALL_OW 274
2046: PPUSH
2047: LD_INT 1
2049: PPUSH
2050: LD_INT 999999
2052: PPUSH
2053: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
2057: LD_VAR 0 5
2061: PPUSH
2062: CALL_OW 274
2066: PPUSH
2067: LD_INT 2
2069: PPUSH
2070: LD_INT 10000
2072: PPUSH
2073: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 10000 ) ;
2077: LD_VAR 0 5
2081: PPUSH
2082: CALL_OW 274
2086: PPUSH
2087: LD_INT 3
2089: PPUSH
2090: LD_INT 10000
2092: PPUSH
2093: CALL_OW 277
// TeleportExit ( legion_telep , 224 , 5 ) ;
2097: LD_INT 68
2099: PPUSH
2100: LD_INT 224
2102: PPUSH
2103: LD_INT 5
2105: PPUSH
2106: CALL_OW 243
// PrepareHuman ( sex_male , 1 , 6 ) ;
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 1
2115: PPUSH
2116: LD_INT 6
2118: PPUSH
2119: CALL_OW 380
// hc_name := Nicolas Vervecken ;
2123: LD_ADDR_OWVAR 26
2127: PUSH
2128: LD_STRING Nicolas Vervecken
2130: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2131: LD_ADDR_OWVAR 33
2135: PUSH
2136: LD_STRING SecondCharsGal
2138: ST_TO_ADDR
// hc_face_number := 3 ;
2139: LD_ADDR_OWVAR 34
2143: PUSH
2144: LD_INT 3
2146: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2147: LD_ADDR_OWVAR 29
2151: PUSH
2152: LD_INT 11
2154: PUSH
2155: LD_INT 10
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: ST_TO_ADDR
// Vervecken := CreateHuman ;
2162: LD_ADDR_EXP 3
2166: PUSH
2167: CALL_OW 44
2171: ST_TO_ADDR
// PlaceHumanInUnit ( Vervecken , dep ) ;
2172: LD_EXP 3
2176: PPUSH
2177: LD_VAR 0 5
2181: PPUSH
2182: CALL_OW 52
// InitHc ;
2186: CALL_OW 19
// for i = 1 to 4 do
2190: LD_ADDR_VAR 0 2
2194: PUSH
2195: DOUBLE
2196: LD_INT 1
2198: DEC
2199: ST_TO_ADDR
2200: LD_INT 4
2202: PUSH
2203: FOR_TO
2204: IFFALSE 2265
// begin PrepareHuman ( false , class_bazooker , skill ) ;
2206: LD_INT 0
2208: PPUSH
2209: LD_INT 9
2211: PPUSH
2212: LD_VAR 0 4
2216: PPUSH
2217: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
2221: CALL_OW 44
2225: PPUSH
2226: LD_INT 22
2228: PUSH
2229: LD_INT 8
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: PUSH
2236: LD_INT 30
2238: PUSH
2239: LD_INT 5
2241: PUSH
2242: EMPTY
2243: LIST
2244: LIST
2245: PUSH
2246: EMPTY
2247: LIST
2248: LIST
2249: PPUSH
2250: CALL_OW 69
2254: PUSH
2255: LD_INT 1
2257: ARRAY
2258: PPUSH
2259: CALL_OW 52
// end ;
2263: GO 2203
2265: POP
2266: POP
// for i = 1 to 2 do
2267: LD_ADDR_VAR 0 2
2271: PUSH
2272: DOUBLE
2273: LD_INT 1
2275: DEC
2276: ST_TO_ADDR
2277: LD_INT 2
2279: PUSH
2280: FOR_TO
2281: IFFALSE 2342
// begin PrepareHuman ( false , 4 , skill ) ;
2283: LD_INT 0
2285: PPUSH
2286: LD_INT 4
2288: PPUSH
2289: LD_VAR 0 4
2293: PPUSH
2294: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
2298: CALL_OW 44
2302: PPUSH
2303: LD_INT 22
2305: PUSH
2306: LD_INT 8
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PUSH
2313: LD_INT 30
2315: PUSH
2316: LD_INT 8
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PPUSH
2327: CALL_OW 69
2331: PUSH
2332: LD_INT 1
2334: ARRAY
2335: PPUSH
2336: CALL_OW 52
// end ;
2340: GO 2280
2342: POP
2343: POP
// for i = 1 to 6 do
2344: LD_ADDR_VAR 0 2
2348: PUSH
2349: DOUBLE
2350: LD_INT 1
2352: DEC
2353: ST_TO_ADDR
2354: LD_INT 6
2356: PUSH
2357: FOR_TO
2358: IFFALSE 2395
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
2360: LD_INT 0
2362: PPUSH
2363: LD_INT 3
2365: PPUSH
2366: LD_VAR 0 4
2370: PUSH
2371: LD_INT 1
2373: PLUS
2374: PPUSH
2375: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac ) ;
2379: CALL_OW 44
2383: PPUSH
2384: LD_VAR 0 6
2388: PPUSH
2389: CALL_OW 52
// end ;
2393: GO 2357
2395: POP
2396: POP
// uc_nation := 0 ;
2397: LD_ADDR_OWVAR 21
2401: PUSH
2402: LD_INT 0
2404: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) do
2405: LD_ADDR_VAR 0 2
2409: PUSH
2410: LD_INT 22
2412: PUSH
2413: LD_INT 8
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: PUSH
2420: LD_INT 30
2422: PUSH
2423: LD_INT 32
2425: PUSH
2426: EMPTY
2427: LIST
2428: LIST
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: PPUSH
2434: CALL_OW 69
2438: PUSH
2439: FOR_IN
2440: IFFALSE 2477
// begin PrepareHuman ( false , class_apeman_soldier , skill + 1 ) ;
2442: LD_INT 0
2444: PPUSH
2445: LD_INT 15
2447: PPUSH
2448: LD_VAR 0 4
2452: PUSH
2453: LD_INT 1
2455: PLUS
2456: PPUSH
2457: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
2461: CALL_OW 44
2465: PPUSH
2466: LD_VAR 0 2
2470: PPUSH
2471: CALL_OW 52
// end ;
2475: GO 2439
2477: POP
2478: POP
// PrepareHuman ( false , class_sniper , 10 ) ;
2479: LD_INT 0
2481: PPUSH
2482: LD_INT 5
2484: PPUSH
2485: LD_INT 10
2487: PPUSH
2488: CALL_OW 380
// un := CreateHuman ;
2492: LD_ADDR_VAR 0 3
2496: PUSH
2497: CALL_OW 44
2501: ST_TO_ADDR
// PlaceUnitXY ( un , 175 , 128 , false ) ;
2502: LD_VAR 0 3
2506: PPUSH
2507: LD_INT 175
2509: PPUSH
2510: LD_INT 128
2512: PPUSH
2513: LD_INT 0
2515: PPUSH
2516: CALL_OW 48
// ComEnterUnit ( un , ar_ibun ) ;
2520: LD_VAR 0 3
2524: PPUSH
2525: LD_INT 115
2527: PPUSH
2528: CALL_OW 120
// for i = 1 to 2 do
2532: LD_ADDR_VAR 0 2
2536: PUSH
2537: DOUBLE
2538: LD_INT 1
2540: DEC
2541: ST_TO_ADDR
2542: LD_INT 2
2544: PUSH
2545: FOR_TO
2546: IFFALSE 2571
// AddComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
2548: LD_VAR 0 6
2552: PPUSH
2553: LD_INT 14
2555: PPUSH
2556: LD_INT 2
2558: PPUSH
2559: LD_INT 1
2561: PPUSH
2562: LD_INT 31
2564: PPUSH
2565: CALL_OW 185
2569: GO 2545
2571: POP
2572: POP
// end ;
2573: LD_VAR 0 1
2577: RET
// export function PrepareHovercraft ( num ) ; var i ; begin
2578: LD_INT 0
2580: PPUSH
2581: PPUSH
// for i = 1 to num do
2582: LD_ADDR_VAR 0 3
2586: PUSH
2587: DOUBLE
2588: LD_INT 1
2590: DEC
2591: ST_TO_ADDR
2592: LD_VAR 0 1
2596: PUSH
2597: FOR_TO
2598: IFFALSE 2670
// AddComConstruct ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] , ar_hovercraft , engine_combustion , control_remote , [ ar_light_gun , ar_double_machine_gun ] [ rand ( 1 , 2 ) ] ) ;
2600: LD_INT 22
2602: PUSH
2603: LD_INT 8
2605: PUSH
2606: EMPTY
2607: LIST
2608: LIST
2609: PUSH
2610: LD_INT 30
2612: PUSH
2613: LD_INT 3
2615: PUSH
2616: EMPTY
2617: LIST
2618: LIST
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PPUSH
2624: CALL_OW 69
2628: PUSH
2629: LD_INT 1
2631: ARRAY
2632: PPUSH
2633: LD_INT 11
2635: PPUSH
2636: LD_INT 1
2638: PPUSH
2639: LD_INT 2
2641: PPUSH
2642: LD_INT 23
2644: PUSH
2645: LD_INT 24
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PUSH
2652: LD_INT 1
2654: PPUSH
2655: LD_INT 2
2657: PPUSH
2658: CALL_OW 12
2662: ARRAY
2663: PPUSH
2664: CALL_OW 185
2668: GO 2597
2670: POP
2671: POP
// end ;
2672: LD_VAR 0 2
2676: RET
// export function AddKamikaze ( ) ; var i , un ; begin
2677: LD_INT 0
2679: PPUSH
2680: PPUSH
2681: PPUSH
// uc_side := 8 ;
2682: LD_ADDR_OWVAR 20
2686: PUSH
2687: LD_INT 8
2689: ST_TO_ADDR
// uc_nation := 0 ;
2690: LD_ADDR_OWVAR 21
2694: PUSH
2695: LD_INT 0
2697: ST_TO_ADDR
// hc_class := 17 ;
2698: LD_ADDR_OWVAR 28
2702: PUSH
2703: LD_INT 17
2705: ST_TO_ADDR
// hc_gallery :=  ;
2706: LD_ADDR_OWVAR 33
2710: PUSH
2711: LD_STRING 
2713: ST_TO_ADDR
// hc_name :=  ;
2714: LD_ADDR_OWVAR 26
2718: PUSH
2719: LD_STRING 
2721: ST_TO_ADDR
// hc_importance := 0 ;
2722: LD_ADDR_OWVAR 32
2726: PUSH
2727: LD_INT 0
2729: ST_TO_ADDR
// hc_skills := [ 10 , 10 , 10 , 10 ] ;
2730: LD_ADDR_OWVAR 31
2734: PUSH
2735: LD_INT 10
2737: PUSH
2738: LD_INT 10
2740: PUSH
2741: LD_INT 10
2743: PUSH
2744: LD_INT 10
2746: PUSH
2747: EMPTY
2748: LIST
2749: LIST
2750: LIST
2751: LIST
2752: ST_TO_ADDR
// if ar_base then
2753: LD_INT 57
2755: IFFALSE 2800
// begin un := CreateHuman ;
2757: LD_ADDR_VAR 0 3
2761: PUSH
2762: CALL_OW 44
2766: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_base ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 57
2774: PPUSH
2775: CALL_OW 52
// ComExitBuilding ( un ) ;
2779: LD_VAR 0 3
2783: PPUSH
2784: CALL_OW 122
// AddComEnterUnit ( un , legion_telep ) ;
2788: LD_VAR 0 3
2792: PPUSH
2793: LD_INT 68
2795: PPUSH
2796: CALL_OW 180
// end ; end ;
2800: LD_VAR 0 1
2804: RET
// export legion_force , l_allow_attack ; export function PrepareAttack ( n1 , n2 ) ; var i ; begin
2805: LD_INT 0
2807: PPUSH
2808: PPUSH
// legion_force := [ ] ;
2809: LD_ADDR_EXP 33
2813: PUSH
2814: EMPTY
2815: ST_TO_ADDR
// l_allow_attack := false ;
2816: LD_ADDR_EXP 34
2820: PUSH
2821: LD_INT 0
2823: ST_TO_ADDR
// PrepareHovercraft ( n1 ) ;
2824: LD_VAR 0 1
2828: PPUSH
2829: CALL 2578 0 1
// repeat wait ( 0 0$01 ) ;
2833: LD_INT 35
2835: PPUSH
2836: CALL_OW 67
// until legion_force = n1 ;
2840: LD_EXP 33
2844: PUSH
2845: LD_VAR 0 1
2849: EQUAL
2850: IFFALSE 2833
// l_allow_attack := true ;
2852: LD_ADDR_EXP 34
2856: PUSH
2857: LD_INT 1
2859: ST_TO_ADDR
// for i = 1 to n2 do
2860: LD_ADDR_VAR 0 4
2864: PUSH
2865: DOUBLE
2866: LD_INT 1
2868: DEC
2869: ST_TO_ADDR
2870: LD_VAR 0 2
2874: PUSH
2875: FOR_TO
2876: IFFALSE 2884
// begin AddKamikaze ( ) ;
2878: CALL 2677 0 0
// end ;
2882: GO 2875
2884: POP
2885: POP
// ComBrutalAttack ( legion_force , 6 ) ;
2886: LD_EXP 33
2890: PPUSH
2891: LD_INT 6
2893: PPUSH
2894: CALL 6564 0 2
// end ;
2898: LD_VAR 0 3
2902: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
2903: LD_INT 22
2905: PUSH
2906: LD_INT 8
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: PUSH
2913: LD_INT 33
2915: PUSH
2916: LD_INT 2
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: PPUSH
2927: CALL_OW 69
2931: IFFALSE 3143
2933: GO 2935
2935: DISABLE
2936: LD_INT 0
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
2942: PPUSH
2943: PPUSH
2944: PPUSH
// begin enable ;
2945: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
2946: LD_ADDR_VAR 0 4
2950: PUSH
2951: LD_INT 22
2953: PUSH
2954: LD_INT 8
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 33
2963: PUSH
2964: LD_INT 2
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: LD_INT 3
2973: PUSH
2974: LD_INT 61
2976: PUSH
2977: EMPTY
2978: LIST
2979: PUSH
2980: EMPTY
2981: LIST
2982: LIST
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: PPUSH
2989: CALL_OW 69
2993: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ;
2994: LD_ADDR_VAR 0 3
2998: PUSH
2999: LD_INT 22
3001: PUSH
3002: LD_INT 8
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PUSH
3009: LD_INT 34
3011: PUSH
3012: LD_INT 31
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PPUSH
3023: CALL_OW 69
3027: ST_TO_ADDR
// best := 10 ;
3028: LD_ADDR_VAR 0 5
3032: PUSH
3033: LD_INT 10
3035: ST_TO_ADDR
// best_mechanic := - 1 ;
3036: LD_ADDR_VAR 0 6
3040: PUSH
3041: LD_INT 1
3043: NEG
3044: ST_TO_ADDR
// if vehs then
3045: LD_VAR 0 4
3049: IFFALSE 3143
// begin for j in cts do
3051: LD_ADDR_VAR 0 2
3055: PUSH
3056: LD_VAR 0 3
3060: PUSH
3061: FOR_IN
3062: IFFALSE 3123
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
3064: LD_ADDR_VAR 0 7
3068: PUSH
3069: LD_VAR 0 2
3073: PPUSH
3074: CALL 5242 0 1
3078: PPUSH
3079: CALL_OW 432
3083: ST_TO_ADDR
// if p < best then
3084: LD_VAR 0 7
3088: PUSH
3089: LD_VAR 0 5
3093: LESS
3094: IFFALSE 3121
// begin best := p ;
3096: LD_ADDR_VAR 0 5
3100: PUSH
3101: LD_VAR 0 7
3105: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
3106: LD_ADDR_VAR 0 6
3110: PUSH
3111: LD_VAR 0 2
3115: PPUSH
3116: CALL 5242 0 1
3120: ST_TO_ADDR
// end ; end ;
3121: GO 3061
3123: POP
3124: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
3125: LD_VAR 0 4
3129: PUSH
3130: LD_INT 1
3132: ARRAY
3133: PPUSH
3134: LD_VAR 0 6
3138: PPUSH
3139: CALL_OW 135
// end ; end ;
3143: PPOPN 7
3145: END
// every 5 5$00 trigger legion_attacks_active do
3146: LD_EXP 7
3150: IFFALSE 3202
3152: GO 3154
3154: DISABLE
// begin enable ;
3155: ENABLE
// Wait ( [ 2 2$30 , 1 1$00 , 0 0$30 ] [ Difficulty ] ) ;
3156: LD_INT 5250
3158: PUSH
3159: LD_INT 2100
3161: PUSH
3162: LD_INT 1050
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: LIST
3169: PUSH
3170: LD_OWVAR 67
3174: ARRAY
3175: PPUSH
3176: CALL_OW 67
// PrepareAttack ( ( legion_attack_strenght - 2 + Difficulty ) , 2 ) ;
3180: LD_EXP 8
3184: PUSH
3185: LD_INT 2
3187: MINUS
3188: PUSH
3189: LD_OWVAR 67
3193: PLUS
3194: PPUSH
3195: LD_INT 2
3197: PPUSH
3198: CALL 2805 0 2
// end ;
3202: END
// every 0 0$01 trigger FilterUnitsInArea ( islandArea , [ [ f_side , 8 ] , [ f_class , 17 ] ] ) do var i ;
3203: LD_INT 6
3205: PPUSH
3206: LD_INT 22
3208: PUSH
3209: LD_INT 8
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: PUSH
3216: LD_INT 25
3218: PUSH
3219: LD_INT 17
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: PPUSH
3230: CALL_OW 70
3234: IFFALSE 3321
3236: GO 3238
3238: DISABLE
3239: LD_INT 0
3241: PPUSH
// begin enable ;
3242: ENABLE
// for i in FilterUnitsInArea ( islandArea , [ [ f_side , 8 ] , [ f_class , 17 ] ] ) do
3243: LD_ADDR_VAR 0 1
3247: PUSH
3248: LD_INT 6
3250: PPUSH
3251: LD_INT 22
3253: PUSH
3254: LD_INT 8
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 25
3263: PUSH
3264: LD_INT 17
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: PPUSH
3275: CALL_OW 70
3279: PUSH
3280: FOR_IN
3281: IFFALSE 3319
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , i ) ) ;
3283: LD_VAR 0 1
3287: PPUSH
3288: LD_INT 22
3290: PUSH
3291: LD_INT 6
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL_OW 69
3302: PPUSH
3303: LD_VAR 0 1
3307: PPUSH
3308: CALL_OW 74
3312: PPUSH
3313: CALL_OW 115
3317: GO 3280
3319: POP
3320: POP
// end ;
3321: PPOPN 1
3323: END
// every 6 6$00 trigger legion_telep do var k , xy , i ;
3324: LD_INT 68
3326: IFFALSE 3557
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
// begin enable ;
3336: ENABLE
// xy := [ [ 224 , 5 ] , [ 160 , 4 ] , [ 228 , 56 ] , [ 271 , 87 ] ] ;
3337: LD_ADDR_VAR 0 2
3341: PUSH
3342: LD_INT 224
3344: PUSH
3345: LD_INT 5
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: PUSH
3352: LD_INT 160
3354: PUSH
3355: LD_INT 4
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: PUSH
3362: LD_INT 228
3364: PUSH
3365: LD_INT 56
3367: PUSH
3368: EMPTY
3369: LIST
3370: LIST
3371: PUSH
3372: LD_INT 271
3374: PUSH
3375: LD_INT 87
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: PUSH
3382: EMPTY
3383: LIST
3384: LIST
3385: LIST
3386: LIST
3387: ST_TO_ADDR
// for i = 1 to 3 do
3388: LD_ADDR_VAR 0 3
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_INT 3
3400: PUSH
3401: FOR_TO
3402: IFFALSE 3418
// EraseResourceArea ( telArea , i ) ;
3404: LD_INT 7
3406: PPUSH
3407: LD_VAR 0 3
3411: PPUSH
3412: CALL_OW 286
3416: GO 3401
3418: POP
3419: POP
// for i = xy downto 1 do
3420: LD_ADDR_VAR 0 3
3424: PUSH
3425: DOUBLE
3426: LD_VAR 0 2
3430: INC
3431: ST_TO_ADDR
3432: LD_INT 1
3434: PUSH
3435: FOR_DOWNTO
3436: IFFALSE 3518
// begin k := rand ( 1 , xy ) ;
3438: LD_ADDR_VAR 0 1
3442: PUSH
3443: LD_INT 1
3445: PPUSH
3446: LD_VAR 0 2
3450: PPUSH
3451: CALL_OW 12
3455: ST_TO_ADDR
// if HexInfo ( xy [ k ] [ 1 ] , xy [ k ] [ 2 ] ) then
3456: LD_VAR 0 2
3460: PUSH
3461: LD_VAR 0 1
3465: ARRAY
3466: PUSH
3467: LD_INT 1
3469: ARRAY
3470: PPUSH
3471: LD_VAR 0 2
3475: PUSH
3476: LD_VAR 0 1
3480: ARRAY
3481: PUSH
3482: LD_INT 2
3484: ARRAY
3485: PPUSH
3486: CALL_OW 428
3490: IFFALSE 3514
// xy := Delete ( xy , k ) else
3492: LD_ADDR_VAR 0 2
3496: PUSH
3497: LD_VAR 0 2
3501: PPUSH
3502: LD_VAR 0 1
3506: PPUSH
3507: CALL_OW 3
3511: ST_TO_ADDR
3512: GO 3516
// break ;
3514: GO 3518
// end ;
3516: GO 3435
3518: POP
3519: POP
// TeleportExit ( legion_telep , xy [ k ] [ 1 ] , xy [ k ] [ 2 ] ) ;
3520: LD_INT 68
3522: PPUSH
3523: LD_VAR 0 2
3527: PUSH
3528: LD_VAR 0 1
3532: ARRAY
3533: PUSH
3534: LD_INT 1
3536: ARRAY
3537: PPUSH
3538: LD_VAR 0 2
3542: PUSH
3543: LD_VAR 0 1
3547: ARRAY
3548: PUSH
3549: LD_INT 2
3551: ARRAY
3552: PPUSH
3553: CALL_OW 243
// end ; end_of_file
3557: PPOPN 3
3559: END
// export function PrepareRussian ; var i , skill , un , tmp , amount , k ; begin
3560: LD_INT 0
3562: PPUSH
3563: PPUSH
3564: PPUSH
3565: PPUSH
3566: PPUSH
3567: PPUSH
3568: PPUSH
// uc_side := 6 ;
3569: LD_ADDR_OWVAR 20
3573: PUSH
3574: LD_INT 6
3576: ST_TO_ADDR
// uc_nation := nation_russian ;
3577: LD_ADDR_OWVAR 21
3581: PUSH
3582: LD_INT 3
3584: ST_TO_ADDR
// SetArtifactRes ( 6 , true ) ;
3585: LD_INT 6
3587: PPUSH
3588: LD_INT 1
3590: PPUSH
3591: CALL_OW 467
// amount := [ [ 9 , 4 ] , [ 8 , 3 ] , [ 8 , 2 ] ] [ Difficulty ] ;
3595: LD_ADDR_VAR 0 6
3599: PUSH
3600: LD_INT 9
3602: PUSH
3603: LD_INT 4
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: PUSH
3610: LD_INT 8
3612: PUSH
3613: LD_INT 3
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: LD_INT 8
3622: PUSH
3623: LD_INT 2
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: LIST
3634: PUSH
3635: LD_OWVAR 67
3639: ARRAY
3640: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
3641: LD_ADDR_VAR 0 3
3645: PUSH
3646: LD_INT 9
3648: PUSH
3649: LD_INT 8
3651: PUSH
3652: LD_INT 7
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: LIST
3659: PUSH
3660: LD_OWVAR 67
3664: ARRAY
3665: ST_TO_ADDR
// tmp := [ ] ;
3666: LD_ADDR_VAR 0 5
3670: PUSH
3671: EMPTY
3672: ST_TO_ADDR
// Davidov := NewCharacter ( Davidov ) ;
3673: LD_ADDR_EXP 2
3677: PUSH
3678: LD_STRING Davidov
3680: PPUSH
3681: CALL_OW 25
3685: ST_TO_ADDR
// SetSkill ( Davidov , 1 , 7 ) ;
3686: LD_EXP 2
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 7
3696: PPUSH
3697: CALL_OW 237
// SetSkill ( Davidov , 2 , 8 ) ;
3701: LD_EXP 2
3705: PPUSH
3706: LD_INT 2
3708: PPUSH
3709: LD_INT 8
3711: PPUSH
3712: CALL_OW 237
// SetSkill ( Davidov , 3 , 6 ) ;
3716: LD_EXP 2
3720: PPUSH
3721: LD_INT 3
3723: PPUSH
3724: LD_INT 6
3726: PPUSH
3727: CALL_OW 237
// SetSkill ( Davidov , 4 , 10 ) ;
3731: LD_EXP 2
3735: PPUSH
3736: LD_INT 4
3738: PPUSH
3739: LD_INT 10
3741: PPUSH
3742: CALL_OW 237
// SetClass ( Davidov , 4 ) ;
3746: LD_EXP 2
3750: PPUSH
3751: LD_INT 4
3753: PPUSH
3754: CALL_OW 336
// hc_importance := 0 ;
3758: LD_ADDR_OWVAR 32
3762: PUSH
3763: LD_INT 0
3765: ST_TO_ADDR
// while amount [ 1 ] do
3766: LD_VAR 0 6
3770: PUSH
3771: LD_INT 1
3773: ARRAY
3774: IFFALSE 4107
// begin Wait ( 1 ) ;
3776: LD_INT 1
3778: PPUSH
3779: CALL_OW 67
// k := rand ( 1 , 4 ) ;
3783: LD_ADDR_VAR 0 7
3787: PUSH
3788: LD_INT 1
3790: PPUSH
3791: LD_INT 4
3793: PPUSH
3794: CALL_OW 12
3798: ST_TO_ADDR
// if amount [ 2 ] and tmp then
3799: LD_VAR 0 6
3803: PUSH
3804: LD_INT 2
3806: ARRAY
3807: PUSH
3808: LD_VAR 0 5
3812: AND
3813: IFFALSE 3968
// begin if k in [ 1 , 2 ] then
3815: LD_VAR 0 7
3819: PUSH
3820: LD_INT 1
3822: PUSH
3823: LD_INT 2
3825: PUSH
3826: EMPTY
3827: LIST
3828: LIST
3829: IN
3830: IFFALSE 3840
// k := 3 ;
3832: LD_ADDR_VAR 0 7
3836: PUSH
3837: LD_INT 3
3839: ST_TO_ADDR
// vc_chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
3840: LD_ADDR_OWVAR 37
3844: PUSH
3845: LD_INT 22
3847: PUSH
3848: LD_INT 24
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: PUSH
3855: LD_INT 1
3857: PPUSH
3858: LD_INT 2
3860: PPUSH
3861: CALL_OW 12
3865: ARRAY
3866: ST_TO_ADDR
// vc_engine := engine_siberite ;
3867: LD_ADDR_OWVAR 39
3871: PUSH
3872: LD_INT 3
3874: ST_TO_ADDR
// vc_control := control_manual ;
3875: LD_ADDR_OWVAR 38
3879: PUSH
3880: LD_INT 1
3882: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_rocket_launcher , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ;
3883: LD_ADDR_OWVAR 40
3887: PUSH
3888: LD_INT 44
3890: PUSH
3891: LD_INT 45
3893: PUSH
3894: LD_INT 43
3896: PUSH
3897: EMPTY
3898: LIST
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 1
3904: PPUSH
3905: LD_INT 3
3907: PPUSH
3908: CALL_OW 12
3912: ARRAY
3913: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , CreateVehicle ) ;
3914: LD_ADDR_VAR 0 5
3918: PUSH
3919: LD_VAR 0 5
3923: PPUSH
3924: LD_INT 1
3926: PPUSH
3927: CALL_OW 45
3931: PPUSH
3932: CALL_OW 2
3936: ST_TO_ADDR
// amount := Replace ( amount , 2 , amount [ 2 ] - 1 ) ;
3937: LD_ADDR_VAR 0 6
3941: PUSH
3942: LD_VAR 0 6
3946: PPUSH
3947: LD_INT 2
3949: PPUSH
3950: LD_VAR 0 6
3954: PUSH
3955: LD_INT 2
3957: ARRAY
3958: PUSH
3959: LD_INT 1
3961: MINUS
3962: PPUSH
3963: CALL_OW 1
3967: ST_TO_ADDR
// end ; if not tmp then
3968: LD_VAR 0 5
3972: NOT
3973: IFFALSE 3983
// k := 2 ;
3975: LD_ADDR_VAR 0 7
3979: PUSH
3980: LD_INT 2
3982: ST_TO_ADDR
// if amount [ 2 ] = 0 and k = 3 then
3983: LD_VAR 0 6
3987: PUSH
3988: LD_INT 2
3990: ARRAY
3991: PUSH
3992: LD_INT 0
3994: EQUAL
3995: PUSH
3996: LD_VAR 0 7
4000: PUSH
4001: LD_INT 3
4003: EQUAL
4004: AND
4005: IFFALSE 4034
// k := [ class_bazooker , class_scientistic ] [ rand ( 1 , 2 ) ] ;
4007: LD_ADDR_VAR 0 7
4011: PUSH
4012: LD_INT 9
4014: PUSH
4015: LD_INT 4
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: PUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 2
4027: PPUSH
4028: CALL_OW 12
4032: ARRAY
4033: ST_TO_ADDR
// PrepareHuman ( false , k , skill ) ;
4034: LD_INT 0
4036: PPUSH
4037: LD_VAR 0 7
4041: PPUSH
4042: LD_VAR 0 3
4046: PPUSH
4047: CALL_OW 380
// tmp := Insert ( tmp , 1 , CreateHuman ) ;
4051: LD_ADDR_VAR 0 5
4055: PUSH
4056: LD_VAR 0 5
4060: PPUSH
4061: LD_INT 1
4063: PPUSH
4064: CALL_OW 44
4068: PPUSH
4069: CALL_OW 2
4073: ST_TO_ADDR
// amount := Replace ( amount , 1 , amount [ 1 ] - 1 ) ;
4074: LD_ADDR_VAR 0 6
4078: PUSH
4079: LD_VAR 0 6
4083: PPUSH
4084: LD_INT 1
4086: PPUSH
4087: LD_VAR 0 6
4091: PUSH
4092: LD_INT 1
4094: ARRAY
4095: PUSH
4096: LD_INT 1
4098: MINUS
4099: PPUSH
4100: CALL_OW 1
4104: ST_TO_ADDR
// end ;
4105: GO 3766
// tmp := Insert ( tmp , tmp + 1 , Davidov ) ;
4107: LD_ADDR_VAR 0 5
4111: PUSH
4112: LD_VAR 0 5
4116: PPUSH
4117: LD_VAR 0 5
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: PPUSH
4126: LD_EXP 2
4130: PPUSH
4131: CALL_OW 2
4135: ST_TO_ADDR
// for i = tmp downto 1 do
4136: LD_ADDR_VAR 0 2
4140: PUSH
4141: DOUBLE
4142: LD_VAR 0 5
4146: INC
4147: ST_TO_ADDR
4148: LD_INT 1
4150: PUSH
4151: FOR_DOWNTO
4152: IFFALSE 4314
// begin if GetType ( tmp [ i ] ) = unit_vehicle then
4154: LD_VAR 0 5
4158: PUSH
4159: LD_VAR 0 2
4163: ARRAY
4164: PPUSH
4165: CALL_OW 247
4169: PUSH
4170: LD_INT 2
4172: EQUAL
4173: IFFALSE 4263
// begin SetDir ( tmp [ i ] , 3 ) ;
4175: LD_VAR 0 5
4179: PUSH
4180: LD_VAR 0 2
4184: ARRAY
4185: PPUSH
4186: LD_INT 3
4188: PPUSH
4189: CALL_OW 233
// PlaceUnitXY ( tmp [ i ] , 193 , 3 , false ) ;
4193: LD_VAR 0 5
4197: PUSH
4198: LD_VAR 0 2
4202: ARRAY
4203: PPUSH
4204: LD_INT 193
4206: PPUSH
4207: LD_INT 3
4209: PPUSH
4210: LD_INT 0
4212: PPUSH
4213: CALL_OW 48
// PlaceHumanInUnit ( tmp [ i - 1 ] , tmp [ i ] ) ;
4217: LD_VAR 0 5
4221: PUSH
4222: LD_VAR 0 2
4226: PUSH
4227: LD_INT 1
4229: MINUS
4230: ARRAY
4231: PPUSH
4232: LD_VAR 0 5
4236: PUSH
4237: LD_VAR 0 2
4241: ARRAY
4242: PPUSH
4243: CALL_OW 52
// i := i - 1 ;
4247: LD_ADDR_VAR 0 2
4251: PUSH
4252: LD_VAR 0 2
4256: PUSH
4257: LD_INT 1
4259: MINUS
4260: ST_TO_ADDR
// end else
4261: GO 4284
// PlaceUnitArea ( tmp [ i ] , start_area , false ) ;
4263: LD_VAR 0 5
4267: PUSH
4268: LD_VAR 0 2
4272: ARRAY
4273: PPUSH
4274: LD_INT 2
4276: PPUSH
4277: LD_INT 0
4279: PPUSH
4280: CALL_OW 49
// ComMoveXY ( tmp [ i ] , 197 , 22 ) ;
4284: LD_VAR 0 5
4288: PUSH
4289: LD_VAR 0 2
4293: ARRAY
4294: PPUSH
4295: LD_INT 197
4297: PPUSH
4298: LD_INT 22
4300: PPUSH
4301: CALL_OW 111
// Wait ( 0 0$02 ) ;
4305: LD_INT 70
4307: PPUSH
4308: CALL_OW 67
// end ;
4312: GO 4151
4314: POP
4315: POP
// Wait ( 0 0$02 ) ;
4316: LD_INT 70
4318: PPUSH
4319: CALL_OW 67
// vc_chassis := ru_medium_tracked ;
4323: LD_ADDR_OWVAR 37
4327: PUSH
4328: LD_INT 22
4330: ST_TO_ADDR
// vc_engine := engine_siberite ;
4331: LD_ADDR_OWVAR 39
4335: PUSH
4336: LD_INT 3
4338: ST_TO_ADDR
// vc_control := control_computer ;
4339: LD_ADDR_OWVAR 38
4343: PUSH
4344: LD_INT 3
4346: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4347: LD_ADDR_OWVAR 40
4351: PUSH
4352: LD_INT 51
4354: ST_TO_ADDR
// tmp := CreateVehicle ;
4355: LD_ADDR_VAR 0 5
4359: PUSH
4360: CALL_OW 45
4364: ST_TO_ADDR
// SetDir ( tmp , 3 ) ;
4365: LD_VAR 0 5
4369: PPUSH
4370: LD_INT 3
4372: PPUSH
4373: CALL_OW 233
// PlaceUnitXY ( tmp , 193 , 3 , false ) ;
4377: LD_VAR 0 5
4381: PPUSH
4382: LD_INT 193
4384: PPUSH
4385: LD_INT 3
4387: PPUSH
4388: LD_INT 0
4390: PPUSH
4391: CALL_OW 48
// SetCargo ( tmp , mat_artifact , 60 ) ;
4395: LD_VAR 0 5
4399: PPUSH
4400: LD_INT 4
4402: PPUSH
4403: LD_INT 60
4405: PPUSH
4406: CALL_OW 290
// ComMoveXY ( tmp , 197 , 22 ) ;
4410: LD_VAR 0 5
4414: PPUSH
4415: LD_INT 197
4417: PPUSH
4418: LD_INT 22
4420: PPUSH
4421: CALL_OW 111
// end ; end_of_file
4425: LD_VAR 0 1
4429: RET
// on VehicleConstructed ( veh , fac ) do var side ;
4430: LD_INT 0
4432: PPUSH
// begin side := GetSide ( fac ) ;
4433: LD_ADDR_VAR 0 3
4437: PUSH
4438: LD_VAR 0 2
4442: PPUSH
4443: CALL_OW 255
4447: ST_TO_ADDR
// case side of 7 :
4448: LD_VAR 0 3
4452: PUSH
4453: LD_INT 7
4455: DOUBLE
4456: EQUAL
4457: IFTRUE 4461
4459: GO 4508
4461: POP
// begin al_force := Replace ( al_force , al_force + 1 , veh ) ;
4462: LD_ADDR_EXP 32
4466: PUSH
4467: LD_EXP 32
4471: PPUSH
4472: LD_EXP 32
4476: PUSH
4477: LD_INT 1
4479: PLUS
4480: PPUSH
4481: LD_VAR 0 1
4485: PPUSH
4486: CALL_OW 1
4490: ST_TO_ADDR
// AddComMoveXY ( veh , 112 , 175 ) ;
4491: LD_VAR 0 1
4495: PPUSH
4496: LD_INT 112
4498: PPUSH
4499: LD_INT 175
4501: PPUSH
4502: CALL_OW 171
// end ; 8 :
4506: GO 4594
4508: LD_INT 8
4510: DOUBLE
4511: EQUAL
4512: IFTRUE 4516
4514: GO 4593
4516: POP
// begin if GetWeapon ( veh ) = ar_control_tower then
4517: LD_VAR 0 1
4521: PPUSH
4522: CALL_OW 264
4526: PUSH
4527: LD_INT 31
4529: EQUAL
4530: IFFALSE 4547
// ComMoveXY ( veh , 145 , 66 ) ;
4532: LD_VAR 0 1
4536: PPUSH
4537: LD_INT 145
4539: PPUSH
4540: LD_INT 66
4542: PPUSH
4543: CALL_OW 111
// if GetChassis ( veh ) = ar_hovercraft then
4547: LD_VAR 0 1
4551: PPUSH
4552: CALL_OW 265
4556: PUSH
4557: LD_INT 11
4559: EQUAL
4560: IFFALSE 4591
// legion_force := Replace ( legion_force , legion_force + 1 , veh ) ;
4562: LD_ADDR_EXP 33
4566: PUSH
4567: LD_EXP 33
4571: PPUSH
4572: LD_EXP 33
4576: PUSH
4577: LD_INT 1
4579: PLUS
4580: PPUSH
4581: LD_VAR 0 1
4585: PPUSH
4586: CALL_OW 1
4590: ST_TO_ADDR
// end ; end ;
4591: GO 4594
4593: POP
// end ;
4594: PPOPN 3
4596: END
// on UnitDestroyed ( un ) do begin if un in legion_force then
4597: LD_VAR 0 1
4601: PUSH
4602: LD_EXP 33
4606: IN
4607: IFFALSE 4625
// legion_force := legion_force diff un ;
4609: LD_ADDR_EXP 33
4613: PUSH
4614: LD_EXP 33
4618: PUSH
4619: LD_VAR 0 1
4623: DIFF
4624: ST_TO_ADDR
// if un in al_force then
4625: LD_VAR 0 1
4629: PUSH
4630: LD_EXP 32
4634: IN
4635: IFFALSE 4653
// al_force := al_force diff un ;
4637: LD_ADDR_EXP 32
4641: PUSH
4642: LD_EXP 32
4646: PUSH
4647: LD_VAR 0 1
4651: DIFF
4652: ST_TO_ADDR
// end ;
4653: PPOPN 1
4655: END
// on UnitTeleported ( b , un ) do begin if b = legion_telep and GetClass ( un ) = 17 then
4656: LD_VAR 0 1
4660: PUSH
4661: LD_INT 68
4663: EQUAL
4664: PUSH
4665: LD_VAR 0 2
4669: PPUSH
4670: CALL_OW 257
4674: PUSH
4675: LD_INT 17
4677: EQUAL
4678: AND
4679: IFFALSE 4722
// begin Wait ( 0 0$01 ) ;
4681: LD_INT 35
4683: PPUSH
4684: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , un ) ) ;
4688: LD_VAR 0 2
4692: PPUSH
4693: LD_INT 22
4695: PUSH
4696: LD_INT 6
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 2
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
// end ; end ;
4722: PPOPN 2
4724: END
// on CrateSpawn ( id , x , y , amount , mode ) do var i , apes , n ;
4725: LD_INT 0
4727: PPUSH
4728: PPUSH
4729: PPUSH
// begin if InArea ( x , y , cratesArea ) and FilterUnitsInArea ( islandArea , [ f_enemy , 6 ] ) = 0 then
4730: LD_VAR 0 2
4734: PPUSH
4735: LD_VAR 0 3
4739: PPUSH
4740: LD_INT 3
4742: PPUSH
4743: CALL_OW 309
4747: PUSH
4748: LD_INT 6
4750: PPUSH
4751: LD_INT 81
4753: PUSH
4754: LD_INT 6
4756: PUSH
4757: EMPTY
4758: LIST
4759: LIST
4760: PPUSH
4761: CALL_OW 70
4765: PUSH
4766: LD_INT 0
4768: EQUAL
4769: AND
4770: IFFALSE 4933
// begin apes := FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 16 ] ] ) ;
4772: LD_ADDR_VAR 0 7
4776: PUSH
4777: LD_INT 22
4779: PUSH
4780: LD_INT 6
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 25
4789: PUSH
4790: LD_INT 16
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PPUSH
4801: CALL_OW 69
4805: ST_TO_ADDR
// if apes = 0 or FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 then
4806: LD_VAR 0 7
4810: PUSH
4811: LD_INT 0
4813: EQUAL
4814: PUSH
4815: LD_INT 22
4817: PUSH
4818: LD_INT 6
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: LD_INT 2
4827: PUSH
4828: LD_INT 30
4830: PUSH
4831: LD_INT 0
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 30
4840: PUSH
4841: LD_INT 1
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: LIST
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: PPUSH
4857: CALL_OW 69
4861: PUSH
4862: LD_INT 0
4864: EQUAL
4865: OR
4866: IFFALSE 4870
// exit ;
4868: GO 4933
// if UnitFilter ( apes , [ f_inside ] ) then
4870: LD_VAR 0 7
4874: PPUSH
4875: LD_INT 54
4877: PUSH
4878: EMPTY
4879: LIST
4880: PPUSH
4881: CALL_OW 72
4885: IFFALSE 4914
// begin ComExitBuilding ( UnitFilter ( apes , [ f_inside ] ) ) ;
4887: LD_VAR 0 7
4891: PPUSH
4892: LD_INT 54
4894: PUSH
4895: EMPTY
4896: LIST
4897: PPUSH
4898: CALL_OW 72
4902: PPUSH
4903: CALL_OW 122
// wait ( 3 ) ;
4907: LD_INT 3
4909: PPUSH
4910: CALL_OW 67
// end ; AddComCollect ( apes , x , y ) ;
4914: LD_VAR 0 7
4918: PPUSH
4919: LD_VAR 0 2
4923: PPUSH
4924: LD_VAR 0 3
4928: PPUSH
4929: CALL_OW 177
// end ; end ;
4933: PPOPN 8
4935: END
// on UnitGoesToRed ( un ) do begin if un in al_force then
4936: LD_VAR 0 1
4940: PUSH
4941: LD_EXP 32
4945: IN
4946: IFFALSE 4964
// al_force := al_force diff un ;
4948: LD_ADDR_EXP 32
4952: PUSH
4953: LD_EXP 32
4957: PUSH
4958: LD_VAR 0 1
4962: DIFF
4963: ST_TO_ADDR
// if GetControl ( un ) = control_remote then
4964: LD_VAR 0 1
4968: PPUSH
4969: CALL_OW 263
4973: PUSH
4974: LD_INT 2
4976: EQUAL
4977: IFFALSE 4988
// ComUnlink ( un ) ;
4979: LD_VAR 0 1
4983: PPUSH
4984: CALL_OW 136
// end ;
4988: PPOPN 1
4990: END
// on ResearchStarted ( tech , lab ) do begin if tech = tech_sibfiss then
4991: LD_VAR 0 1
4995: PUSH
4996: LD_INT 25
4998: EQUAL
4999: IFFALSE 5009
// player_start_res_sib_bomb := true ;
5001: LD_ADDR_EXP 4
5005: PUSH
5006: LD_INT 1
5008: ST_TO_ADDR
// if tech = tech_artifact then
5009: LD_VAR 0 1
5013: PUSH
5014: LD_INT 24
5016: EQUAL
5017: IFFALSE 5027
// player_start_res_artifact := true ;
5019: LD_ADDR_EXP 5
5023: PUSH
5024: LD_INT 1
5026: ST_TO_ADDR
// end ;
5027: PPOPN 2
5029: END
// on ArtifactUnloaded ( cargo , artifact_num ) do begin if artifact_num = 6 then
5030: LD_VAR 0 2
5034: PUSH
5035: LD_INT 6
5037: EQUAL
5038: IFFALSE 5048
// player_artifact_loaded := false ;
5040: LD_ADDR_EXP 18
5044: PUSH
5045: LD_INT 0
5047: ST_TO_ADDR
// end ;
5048: PPOPN 2
5050: END
// on ArtifactLoaded ( cargo , artifact_num ) do begin if artifact_num = 6 then
5051: LD_VAR 0 2
5055: PUSH
5056: LD_INT 6
5058: EQUAL
5059: IFFALSE 5069
// player_artifact_loaded := true ;
5061: LD_ADDR_EXP 18
5065: PUSH
5066: LD_INT 1
5068: ST_TO_ADDR
// end ;
5069: PPOPN 2
5071: END
// on SiberiteRocketExploded ( rocket , x , y ) do var i ;
5072: LD_INT 0
5074: PPUSH
// begin player_used_sib_bomb := true ;
5075: LD_ADDR_EXP 12
5079: PUSH
5080: LD_INT 1
5082: ST_TO_ADDR
// for i = 1 to 3 do
5083: LD_ADDR_VAR 0 4
5087: PUSH
5088: DOUBLE
5089: LD_INT 1
5091: DEC
5092: ST_TO_ADDR
5093: LD_INT 3
5095: PUSH
5096: FOR_TO
5097: IFFALSE 5170
// begin if GetDistXY ( x , y , artifacts_pos [ i ] [ 1 ] , artifacts_pos [ i ] [ 2 ] ) <= sib_rocket_range then
5099: LD_VAR 0 2
5103: PPUSH
5104: LD_VAR 0 3
5108: PPUSH
5109: LD_EXP 15
5113: PUSH
5114: LD_VAR 0 4
5118: ARRAY
5119: PUSH
5120: LD_INT 1
5122: ARRAY
5123: PPUSH
5124: LD_EXP 15
5128: PUSH
5129: LD_VAR 0 4
5133: ARRAY
5134: PUSH
5135: LD_INT 2
5137: ARRAY
5138: PPUSH
5139: CALL_OW 298
5143: PUSH
5144: LD_EXP 17
5148: LESSEQUAL
5149: IFFALSE 5168
// begin wait ( 0 0$5 ) ;
5151: LD_INT 175
5153: PPUSH
5154: CALL_OW 67
// artifact_destroyed := true ;
5158: LD_ADDR_EXP 16
5162: PUSH
5163: LD_INT 1
5165: ST_TO_ADDR
// break ;
5166: GO 5170
// end ; end ;
5168: GO 5096
5170: POP
5171: POP
// end ;
5172: PPOPN 4
5174: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
5175: LD_VAR 0 1
5179: PPUSH
5180: LD_VAR 0 2
5184: PPUSH
5185: LD_VAR 0 3
5189: PPUSH
5190: CALL 11393 0 3
// end ;
5194: PPOPN 3
5196: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
5197: LD_VAR 0 1
5201: PPUSH
5202: CALL 11401 0 1
// end ; end_of_file
5206: PPOPN 1
5208: END
// export function CreateArtifact ( type , x , y ) ; begin
5209: LD_INT 0
5211: PPUSH
// CreateResourcesXY ( mat_artifact , type , x , y , false ) ;
5212: LD_INT 4
5214: PPUSH
5215: LD_VAR 0 1
5219: PPUSH
5220: LD_VAR 0 2
5224: PPUSH
5225: LD_VAR 0 3
5229: PPUSH
5230: LD_INT 0
5232: PPUSH
5233: CALL_OW 58
// end ;
5237: LD_VAR 0 4
5241: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5242: LD_INT 0
5244: PPUSH
5245: PPUSH
5246: PPUSH
// if not GetControl ( veh ) = control_manual then
5247: LD_VAR 0 1
5251: PPUSH
5252: CALL_OW 263
5256: PUSH
5257: LD_INT 1
5259: EQUAL
5260: NOT
5261: IFFALSE 5273
// result := false else
5263: LD_ADDR_VAR 0 2
5267: PUSH
5268: LD_INT 0
5270: ST_TO_ADDR
5271: GO 5418
// if veh in FilterAllUnits ( [ f_empty ] ) then
5273: LD_VAR 0 1
5277: PUSH
5278: LD_INT 58
5280: PUSH
5281: EMPTY
5282: LIST
5283: PPUSH
5284: CALL_OW 69
5288: IN
5289: IFFALSE 5301
// result := false else
5291: LD_ADDR_VAR 0 2
5295: PUSH
5296: LD_INT 0
5298: ST_TO_ADDR
5299: GO 5418
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5301: LD_ADDR_VAR 0 4
5305: PUSH
5306: LD_INT 22
5308: PUSH
5309: LD_VAR 0 1
5313: PPUSH
5314: CALL_OW 255
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PUSH
5323: LD_INT 55
5325: PUSH
5326: EMPTY
5327: LIST
5328: PUSH
5329: EMPTY
5330: LIST
5331: LIST
5332: PPUSH
5333: CALL_OW 69
5337: ST_TO_ADDR
// if not filter then
5338: LD_VAR 0 4
5342: NOT
5343: IFFALSE 5355
// result := false else
5345: LD_ADDR_VAR 0 2
5349: PUSH
5350: LD_INT 0
5352: ST_TO_ADDR
5353: GO 5418
// for i = 1 to filter do
5355: LD_ADDR_VAR 0 3
5359: PUSH
5360: DOUBLE
5361: LD_INT 1
5363: DEC
5364: ST_TO_ADDR
5365: LD_VAR 0 4
5369: PUSH
5370: FOR_TO
5371: IFFALSE 5416
// if IsDriver ( filter [ i ] ) = veh then
5373: LD_VAR 0 4
5377: PUSH
5378: LD_VAR 0 3
5382: ARRAY
5383: PPUSH
5384: CALL 5762 0 1
5388: PUSH
5389: LD_VAR 0 1
5393: EQUAL
5394: IFFALSE 5414
// begin result := filter [ i ] ;
5396: LD_ADDR_VAR 0 2
5400: PUSH
5401: LD_VAR 0 4
5405: PUSH
5406: LD_VAR 0 3
5410: ARRAY
5411: ST_TO_ADDR
// break ;
5412: GO 5416
// end ;
5414: GO 5370
5416: POP
5417: POP
// end ; end ;
5418: LD_VAR 0 2
5422: RET
// export function GetSibResources ( side ) ; var i , deps ; begin
5423: LD_INT 0
5425: PPUSH
5426: PPUSH
5427: PPUSH
// result := 0 ;
5428: LD_ADDR_VAR 0 2
5432: PUSH
5433: LD_INT 0
5435: ST_TO_ADDR
// deps := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5436: LD_ADDR_VAR 0 4
5440: PUSH
5441: LD_INT 22
5443: PUSH
5444: LD_VAR 0 1
5448: PUSH
5449: EMPTY
5450: LIST
5451: LIST
5452: PUSH
5453: LD_INT 2
5455: PUSH
5456: LD_INT 30
5458: PUSH
5459: LD_INT 0
5461: PUSH
5462: EMPTY
5463: LIST
5464: LIST
5465: PUSH
5466: LD_INT 30
5468: PUSH
5469: LD_INT 1
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: LIST
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PPUSH
5485: CALL_OW 69
5489: ST_TO_ADDR
// if deps then
5490: LD_VAR 0 4
5494: IFFALSE 5542
// for i in deps do
5496: LD_ADDR_VAR 0 3
5500: PUSH
5501: LD_VAR 0 4
5505: PUSH
5506: FOR_IN
5507: IFFALSE 5540
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
5509: LD_ADDR_VAR 0 2
5513: PUSH
5514: LD_VAR 0 2
5518: PUSH
5519: LD_VAR 0 3
5523: PPUSH
5524: CALL_OW 274
5528: PPUSH
5529: LD_INT 3
5531: PPUSH
5532: CALL_OW 275
5536: PLUS
5537: ST_TO_ADDR
5538: GO 5506
5540: POP
5541: POP
// end ;
5542: LD_VAR 0 2
5546: RET
// export function SetSibResources ( side , val ) ; var i , deps , s ; begin
5547: LD_INT 0
5549: PPUSH
5550: PPUSH
5551: PPUSH
5552: PPUSH
// if val <= 0 then
5553: LD_VAR 0 2
5557: PUSH
5558: LD_INT 0
5560: LESSEQUAL
5561: IFFALSE 5565
// exit ;
5563: GO 5757
// deps := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5565: LD_ADDR_VAR 0 5
5569: PUSH
5570: LD_INT 22
5572: PUSH
5573: LD_VAR 0 1
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: PUSH
5582: LD_INT 2
5584: PUSH
5585: LD_INT 30
5587: PUSH
5588: LD_INT 0
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 30
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: LIST
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 69
5618: ST_TO_ADDR
// if deps then
5619: LD_VAR 0 5
5623: IFFALSE 5757
// for i in deps do
5625: LD_ADDR_VAR 0 4
5629: PUSH
5630: LD_VAR 0 5
5634: PUSH
5635: FOR_IN
5636: IFFALSE 5755
// begin s := GetResourceType ( GetBase ( i ) , mat_siberit ) ;
5638: LD_ADDR_VAR 0 6
5642: PUSH
5643: LD_VAR 0 4
5647: PPUSH
5648: CALL_OW 274
5652: PPUSH
5653: LD_INT 3
5655: PPUSH
5656: CALL_OW 275
5660: ST_TO_ADDR
// if val < s then
5661: LD_VAR 0 2
5665: PUSH
5666: LD_VAR 0 6
5670: LESS
5671: IFFALSE 5717
// begin s := s - val ;
5673: LD_ADDR_VAR 0 6
5677: PUSH
5678: LD_VAR 0 6
5682: PUSH
5683: LD_VAR 0 2
5687: MINUS
5688: ST_TO_ADDR
// SetResourceType ( GetBase ( i ) , mat_siberit , s ) ;
5689: LD_VAR 0 4
5693: PPUSH
5694: CALL_OW 274
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_VAR 0 6
5706: PPUSH
5707: CALL_OW 277
// exit ;
5711: POP
5712: POP
5713: GO 5757
// end else
5715: GO 5753
// begin val := val - s ;
5717: LD_ADDR_VAR 0 2
5721: PUSH
5722: LD_VAR 0 2
5726: PUSH
5727: LD_VAR 0 6
5731: MINUS
5732: ST_TO_ADDR
// SetResourceType ( GetBase ( i ) , mat_siberit , 0 ) ;
5733: LD_VAR 0 4
5737: PPUSH
5738: CALL_OW 274
5742: PPUSH
5743: LD_INT 3
5745: PPUSH
5746: LD_INT 0
5748: PPUSH
5749: CALL_OW 277
// end ; end ;
5753: GO 5635
5755: POP
5756: POP
// end ;
5757: LD_VAR 0 3
5761: RET
// export function IsDriver ( unit ) ; begin
5762: LD_INT 0
5764: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5765: LD_VAR 0 1
5769: PUSH
5770: LD_INT 55
5772: PUSH
5773: EMPTY
5774: LIST
5775: PPUSH
5776: CALL_OW 69
5780: IN
5781: IFFALSE 5800
// result := IsInUnit ( unit ) else
5783: LD_ADDR_VAR 0 2
5787: PUSH
5788: LD_VAR 0 1
5792: PPUSH
5793: CALL_OW 310
5797: ST_TO_ADDR
5798: GO 5808
// result := false ;
5800: LD_ADDR_VAR 0 2
5804: PUSH
5805: LD_INT 0
5807: ST_TO_ADDR
// end ;
5808: LD_VAR 0 2
5812: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
5813: LD_INT 0
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
// if pos < 1 then
5819: LD_VAR 0 2
5823: PUSH
5824: LD_INT 1
5826: LESS
5827: IFFALSE 5831
// exit ;
5829: GO 6134
// if pos = 1 then
5831: LD_VAR 0 2
5835: PUSH
5836: LD_INT 1
5838: EQUAL
5839: IFFALSE 5872
// result := Replace ( arr , pos [ 1 ] , value ) else
5841: LD_ADDR_VAR 0 4
5845: PUSH
5846: LD_VAR 0 1
5850: PPUSH
5851: LD_VAR 0 2
5855: PUSH
5856: LD_INT 1
5858: ARRAY
5859: PPUSH
5860: LD_VAR 0 3
5864: PPUSH
5865: CALL_OW 1
5869: ST_TO_ADDR
5870: GO 6134
// begin tmp := arr ;
5872: LD_ADDR_VAR 0 6
5876: PUSH
5877: LD_VAR 0 1
5881: ST_TO_ADDR
// s_arr := [ tmp ] ;
5882: LD_ADDR_VAR 0 7
5886: PUSH
5887: LD_VAR 0 6
5891: PUSH
5892: EMPTY
5893: LIST
5894: ST_TO_ADDR
// for i = 1 to pos - 1 do
5895: LD_ADDR_VAR 0 5
5899: PUSH
5900: DOUBLE
5901: LD_INT 1
5903: DEC
5904: ST_TO_ADDR
5905: LD_VAR 0 2
5909: PUSH
5910: LD_INT 1
5912: MINUS
5913: PUSH
5914: FOR_TO
5915: IFFALSE 5960
// begin tmp := tmp [ pos [ i ] ] ;
5917: LD_ADDR_VAR 0 6
5921: PUSH
5922: LD_VAR 0 6
5926: PUSH
5927: LD_VAR 0 2
5931: PUSH
5932: LD_VAR 0 5
5936: ARRAY
5937: ARRAY
5938: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
5939: LD_ADDR_VAR 0 7
5943: PUSH
5944: LD_VAR 0 7
5948: PUSH
5949: LD_VAR 0 6
5953: PUSH
5954: EMPTY
5955: LIST
5956: ADD
5957: ST_TO_ADDR
// end ;
5958: GO 5914
5960: POP
5961: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
5962: LD_ADDR_VAR 0 6
5966: PUSH
5967: LD_VAR 0 6
5971: PPUSH
5972: LD_VAR 0 2
5976: PUSH
5977: LD_VAR 0 2
5981: ARRAY
5982: PPUSH
5983: LD_VAR 0 3
5987: PPUSH
5988: CALL_OW 1
5992: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
5993: LD_ADDR_VAR 0 7
5997: PUSH
5998: LD_VAR 0 7
6002: PPUSH
6003: LD_VAR 0 7
6007: PPUSH
6008: LD_VAR 0 6
6012: PPUSH
6013: CALL_OW 1
6017: ST_TO_ADDR
// for i = s_arr downto 2 do
6018: LD_ADDR_VAR 0 5
6022: PUSH
6023: DOUBLE
6024: LD_VAR 0 7
6028: INC
6029: ST_TO_ADDR
6030: LD_INT 2
6032: PUSH
6033: FOR_DOWNTO
6034: IFFALSE 6118
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
6036: LD_ADDR_VAR 0 6
6040: PUSH
6041: LD_VAR 0 7
6045: PUSH
6046: LD_VAR 0 5
6050: PUSH
6051: LD_INT 1
6053: MINUS
6054: ARRAY
6055: PPUSH
6056: LD_VAR 0 2
6060: PUSH
6061: LD_VAR 0 5
6065: PUSH
6066: LD_INT 1
6068: MINUS
6069: ARRAY
6070: PPUSH
6071: LD_VAR 0 7
6075: PUSH
6076: LD_VAR 0 5
6080: ARRAY
6081: PPUSH
6082: CALL_OW 1
6086: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
6087: LD_ADDR_VAR 0 7
6091: PUSH
6092: LD_VAR 0 7
6096: PPUSH
6097: LD_VAR 0 5
6101: PUSH
6102: LD_INT 1
6104: MINUS
6105: PPUSH
6106: LD_VAR 0 6
6110: PPUSH
6111: CALL_OW 1
6115: ST_TO_ADDR
// end ;
6116: GO 6033
6118: POP
6119: POP
// result := s_arr [ 1 ] ;
6120: LD_ADDR_VAR 0 4
6124: PUSH
6125: LD_VAR 0 7
6129: PUSH
6130: LD_INT 1
6132: ARRAY
6133: ST_TO_ADDR
// end ; end ;
6134: LD_VAR 0 4
6138: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
6139: LD_VAR 0 1
6143: PUSH
6144: LD_EXP 35
6148: IN
6149: NOT
6150: IFFALSE 6181
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
6152: LD_ADDR_EXP 35
6156: PUSH
6157: LD_EXP 35
6161: PPUSH
6162: LD_EXP 35
6166: PUSH
6167: LD_INT 1
6169: PLUS
6170: PPUSH
6171: LD_VAR 0 1
6175: PPUSH
6176: CALL_OW 2
6180: ST_TO_ADDR
// end ;
6181: PPOPN 1
6183: END
// export function DestinationReachable ( unit , x , y ) ; begin
6184: LD_INT 0
6186: PPUSH
// if unit in unreachableList then
6187: LD_VAR 0 1
6191: PUSH
6192: LD_EXP 35
6196: IN
6197: IFFALSE 6215
// unreachableList := unreachableList diff unit ;
6199: LD_ADDR_EXP 35
6203: PUSH
6204: LD_EXP 35
6208: PUSH
6209: LD_VAR 0 1
6213: DIFF
6214: ST_TO_ADDR
// if ValidHex ( x , y ) then
6215: LD_VAR 0 2
6219: PPUSH
6220: LD_VAR 0 3
6224: PPUSH
6225: CALL_OW 488
6229: IFFALSE 6255
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
6231: LD_VAR 0 1
6235: PPUSH
6236: LD_VAR 0 2
6240: PPUSH
6241: LD_VAR 0 3
6245: PPUSH
6246: CALL_OW 428
6250: PPUSH
6251: CALL_OW 115
// Wait ( 3 ) ;
6255: LD_INT 3
6257: PPUSH
6258: CALL_OW 67
// if unit in unreachableList then
6262: LD_VAR 0 1
6266: PUSH
6267: LD_EXP 35
6271: IN
6272: IFFALSE 6284
// result := false else
6274: LD_ADDR_VAR 0 4
6278: PUSH
6279: LD_INT 0
6281: ST_TO_ADDR
6282: GO 6292
// result := true ;
6284: LD_ADDR_VAR 0 4
6288: PUSH
6289: LD_INT 1
6291: ST_TO_ADDR
// end ;
6292: LD_VAR 0 4
6296: RET
// export function ComBombAttack ( unit , side ) ; var i , enemy , t , x , y , change_target_counter , last_target ; begin
6297: LD_INT 0
6299: PPUSH
6300: PPUSH
6301: PPUSH
6302: PPUSH
6303: PPUSH
6304: PPUSH
6305: PPUSH
6306: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
6307: LD_ADDR_VAR 0 5
6311: PUSH
6312: LD_INT 22
6314: PUSH
6315: LD_VAR 0 2
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: PPUSH
6324: CALL_OW 69
6328: ST_TO_ADDR
// change_target_counter := 0 ;
6329: LD_ADDR_VAR 0 9
6333: PUSH
6334: LD_INT 0
6336: ST_TO_ADDR
// last_target := 0 ;
6337: LD_ADDR_VAR 0 10
6341: PUSH
6342: LD_INT 0
6344: ST_TO_ADDR
// if not enemy then
6345: LD_VAR 0 5
6349: NOT
6350: IFFALSE 6354
// exit ;
6352: GO 6559
// while ( IsLive ( unit ) and change_target_counter < 4 ) do
6354: LD_VAR 0 1
6358: PPUSH
6359: CALL_OW 300
6363: PUSH
6364: LD_VAR 0 9
6368: PUSH
6369: LD_INT 4
6371: LESS
6372: AND
6373: IFFALSE 6559
// begin if UnitFilter ( enemy , [ f_occupied ] ) then
6375: LD_VAR 0 5
6379: PPUSH
6380: LD_INT 59
6382: PUSH
6383: EMPTY
6384: LIST
6385: PPUSH
6386: CALL_OW 72
6390: IFFALSE 6526
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
6392: LD_ADDR_VAR 0 6
6396: PUSH
6397: LD_VAR 0 5
6401: PPUSH
6402: LD_INT 59
6404: PUSH
6405: EMPTY
6406: LIST
6407: PPUSH
6408: CALL_OW 72
6412: PPUSH
6413: LD_VAR 0 1
6417: PPUSH
6418: CALL_OW 74
6422: ST_TO_ADDR
// if ( last_target <> t ) then
6423: LD_VAR 0 10
6427: PUSH
6428: LD_VAR 0 6
6432: NONEQUAL
6433: IFFALSE 6449
// change_target_counter := change_target_counter + 1 ;
6435: LD_ADDR_VAR 0 9
6439: PUSH
6440: LD_VAR 0 9
6444: PUSH
6445: LD_INT 1
6447: PLUS
6448: ST_TO_ADDR
// last_target := t ;
6449: LD_ADDR_VAR 0 10
6453: PUSH
6454: LD_VAR 0 6
6458: ST_TO_ADDR
// x := GetX ( t ) ;
6459: LD_ADDR_VAR 0 7
6463: PUSH
6464: LD_VAR 0 6
6468: PPUSH
6469: CALL_OW 250
6473: ST_TO_ADDR
// y := GetY ( t ) ;
6474: LD_ADDR_VAR 0 8
6478: PUSH
6479: LD_VAR 0 6
6483: PPUSH
6484: CALL_OW 251
6488: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6489: LD_VAR 0 1
6493: PPUSH
6494: LD_VAR 0 7
6498: PPUSH
6499: LD_VAR 0 8
6503: PPUSH
6504: CALL 6184 0 3
6508: IFFALSE 6524
// ComAttackUnit ( unit , t ) ;
6510: LD_VAR 0 1
6514: PPUSH
6515: LD_VAR 0 6
6519: PPUSH
6520: CALL_OW 115
// end else
6524: GO 6550
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
6526: LD_VAR 0 1
6530: PPUSH
6531: LD_VAR 0 5
6535: PPUSH
6536: LD_VAR 0 1
6540: PPUSH
6541: CALL_OW 74
6545: PPUSH
6546: CALL_OW 115
// Wait ( 0 0$0.3 ) ;
6550: LD_INT 10
6552: PPUSH
6553: CALL_OW 67
// end ;
6557: GO 6354
// end ;
6559: LD_VAR 0 3
6563: RET
// export function ComBrutalAttack ( units , side ) ; var i , enemy , t , x , y , target , unit ; begin
6564: LD_INT 0
6566: PPUSH
6567: PPUSH
6568: PPUSH
6569: PPUSH
6570: PPUSH
6571: PPUSH
6572: PPUSH
6573: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
6574: LD_ADDR_VAR 0 5
6578: PUSH
6579: LD_INT 22
6581: PUSH
6582: LD_VAR 0 2
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PPUSH
6591: CALL_OW 69
6595: ST_TO_ADDR
// target := 0 ;
6596: LD_ADDR_VAR 0 9
6600: PUSH
6601: LD_INT 0
6603: ST_TO_ADDR
// if not enemy then
6604: LD_VAR 0 5
6608: NOT
6609: IFFALSE 6613
// exit ;
6611: GO 7268
// while units do
6613: LD_VAR 0 1
6617: IFFALSE 7268
// begin wait ( 0 0$0.3 ) ;
6619: LD_INT 10
6621: PPUSH
6622: CALL_OW 67
// for unit in units do
6626: LD_ADDR_VAR 0 10
6630: PUSH
6631: LD_VAR 0 1
6635: PUSH
6636: FOR_IN
6637: IFFALSE 7264
// begin if not IsPlaced ( unit ) then
6639: LD_VAR 0 10
6643: PPUSH
6644: CALL_OW 305
6648: NOT
6649: IFFALSE 6669
// begin units := units diff unit ;
6651: LD_ADDR_VAR 0 1
6655: PUSH
6656: LD_VAR 0 1
6660: PUSH
6661: LD_VAR 0 10
6665: DIFF
6666: ST_TO_ADDR
// continue ;
6667: GO 6636
// end ; if not IsPlaced ( target ) then
6669: LD_VAR 0 9
6673: PPUSH
6674: CALL_OW 305
6678: NOT
6679: IFFALSE 6689
// target := 0 ;
6681: LD_ADDR_VAR 0 9
6685: PUSH
6686: LD_INT 0
6688: ST_TO_ADDR
// if not target and UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) then
6689: LD_VAR 0 9
6693: NOT
6694: PUSH
6695: LD_VAR 0 5
6699: PPUSH
6700: LD_INT 21
6702: PUSH
6703: LD_INT 1
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: PUSH
6710: LD_INT 3
6712: PUSH
6713: LD_INT 54
6715: PUSH
6716: EMPTY
6717: LIST
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PPUSH
6727: CALL_OW 72
6731: AND
6732: IFFALSE 6994
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , unit ) ;
6734: LD_ADDR_VAR 0 6
6738: PUSH
6739: LD_VAR 0 5
6743: PPUSH
6744: LD_INT 21
6746: PUSH
6747: LD_INT 1
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 3
6756: PUSH
6757: LD_INT 54
6759: PUSH
6760: EMPTY
6761: LIST
6762: PUSH
6763: EMPTY
6764: LIST
6765: LIST
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: PPUSH
6771: CALL_OW 72
6775: PPUSH
6776: LD_VAR 0 10
6780: PPUSH
6781: CALL_OW 74
6785: ST_TO_ADDR
// x := GetX ( t ) ;
6786: LD_ADDR_VAR 0 7
6790: PUSH
6791: LD_VAR 0 6
6795: PPUSH
6796: CALL_OW 250
6800: ST_TO_ADDR
// y := GetY ( t ) ;
6801: LD_ADDR_VAR 0 8
6805: PUSH
6806: LD_VAR 0 6
6810: PPUSH
6811: CALL_OW 251
6815: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6816: LD_VAR 0 10
6820: PPUSH
6821: LD_VAR 0 7
6825: PPUSH
6826: LD_VAR 0 8
6830: PPUSH
6831: CALL 6184 0 3
6835: IFFALSE 6849
// target := t else
6837: LD_ADDR_VAR 0 9
6841: PUSH
6842: LD_VAR 0 6
6846: ST_TO_ADDR
6847: GO 6994
// if UnitFilter ( enemy , [ f_occupied ] ) then
6849: LD_VAR 0 5
6853: PPUSH
6854: LD_INT 59
6856: PUSH
6857: EMPTY
6858: LIST
6859: PPUSH
6860: CALL_OW 72
6864: IFFALSE 6994
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
6866: LD_ADDR_VAR 0 6
6870: PUSH
6871: LD_VAR 0 5
6875: PPUSH
6876: LD_INT 59
6878: PUSH
6879: EMPTY
6880: LIST
6881: PPUSH
6882: CALL_OW 72
6886: PPUSH
6887: LD_VAR 0 10
6891: PPUSH
6892: CALL_OW 74
6896: ST_TO_ADDR
// x := GetX ( t ) ;
6897: LD_ADDR_VAR 0 7
6901: PUSH
6902: LD_VAR 0 6
6906: PPUSH
6907: CALL_OW 250
6911: ST_TO_ADDR
// y := GetY ( t ) ;
6912: LD_ADDR_VAR 0 8
6916: PUSH
6917: LD_VAR 0 6
6921: PPUSH
6922: CALL_OW 251
6926: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6927: LD_VAR 0 10
6931: PPUSH
6932: LD_VAR 0 7
6936: PPUSH
6937: LD_VAR 0 8
6941: PPUSH
6942: CALL 6184 0 3
6946: IFFALSE 6960
// target := t else
6948: LD_ADDR_VAR 0 9
6952: PUSH
6953: LD_VAR 0 6
6957: ST_TO_ADDR
6958: GO 6994
// ComAttackUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , unit ) ) ;
6960: LD_VAR 0 10
6964: PPUSH
6965: LD_INT 22
6967: PUSH
6968: LD_INT 6
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: PPUSH
6975: CALL_OW 69
6979: PPUSH
6980: LD_VAR 0 10
6984: PPUSH
6985: CALL_OW 74
6989: PPUSH
6990: CALL_OW 115
// end ; end ; if not target or not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
6994: LD_VAR 0 9
6998: NOT
6999: PUSH
7000: LD_VAR 0 10
7004: PPUSH
7005: LD_VAR 0 9
7009: PPUSH
7010: CALL_OW 250
7014: PPUSH
7015: LD_VAR 0 9
7019: PPUSH
7020: CALL_OW 251
7024: PPUSH
7025: CALL 6184 0 3
7029: NOT
7030: OR
7031: IFFALSE 7065
// target := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
7033: LD_ADDR_VAR 0 9
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_VAR 0 2
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PPUSH
7050: CALL_OW 69
7054: PPUSH
7055: LD_VAR 0 10
7059: PPUSH
7060: CALL_OW 74
7064: ST_TO_ADDR
// if ( GetDistUnits ( target , unit ) < 4 and GetLives ( unit ) < 600 ) or ( GetLives ( unit ) < 200 and GetSide ( NearestUnitToUnit ( all_units diff unit , unit ) ) <> GetSide ( unit ) ) then
7065: LD_VAR 0 9
7069: PPUSH
7070: LD_VAR 0 10
7074: PPUSH
7075: CALL_OW 296
7079: PUSH
7080: LD_INT 4
7082: LESS
7083: PUSH
7084: LD_VAR 0 10
7088: PPUSH
7089: CALL_OW 256
7093: PUSH
7094: LD_INT 600
7096: LESS
7097: AND
7098: PUSH
7099: LD_VAR 0 10
7103: PPUSH
7104: CALL_OW 256
7108: PUSH
7109: LD_INT 200
7111: LESS
7112: PUSH
7113: LD_OWVAR 3
7117: PUSH
7118: LD_VAR 0 10
7122: DIFF
7123: PPUSH
7124: LD_VAR 0 10
7128: PPUSH
7129: CALL_OW 74
7133: PPUSH
7134: CALL_OW 255
7138: PUSH
7139: LD_VAR 0 10
7143: PPUSH
7144: CALL_OW 255
7148: NONEQUAL
7149: AND
7150: OR
7151: IFFALSE 7202
// begin for i = 1 to 4 do
7153: LD_ADDR_VAR 0 4
7157: PUSH
7158: DOUBLE
7159: LD_INT 1
7161: DEC
7162: ST_TO_ADDR
7163: LD_INT 4
7165: PUSH
7166: FOR_TO
7167: IFFALSE 7198
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
7169: LD_VAR 0 10
7173: PPUSH
7174: CALL_OW 250
7178: PPUSH
7179: LD_VAR 0 10
7183: PPUSH
7184: CALL_OW 251
7188: PPUSH
7189: LD_INT 1
7191: PPUSH
7192: CALL_OW 453
7196: GO 7166
7198: POP
7199: POP
// end else
7200: GO 7262
// if GetType ( target ) <> unit_human then
7202: LD_VAR 0 9
7206: PPUSH
7207: CALL_OW 247
7211: PUSH
7212: LD_INT 1
7214: NONEQUAL
7215: IFFALSE 7233
// ComAttackUnit ( unit , target ) else
7217: LD_VAR 0 10
7221: PPUSH
7222: LD_VAR 0 9
7226: PPUSH
7227: CALL_OW 115
7231: GO 7262
// ComMoveXY ( unit , GetX ( target ) , GetY ( target ) ) ;
7233: LD_VAR 0 10
7237: PPUSH
7238: LD_VAR 0 9
7242: PPUSH
7243: CALL_OW 250
7247: PPUSH
7248: LD_VAR 0 9
7252: PPUSH
7253: CALL_OW 251
7257: PPUSH
7258: CALL_OW 111
// end ;
7262: GO 6636
7264: POP
7265: POP
// end ;
7266: GO 6613
// end ; end_of_file
7268: LD_VAR 0 3
7272: RET
// export function Action ; var dial ; begin
7273: LD_INT 0
7275: PPUSH
7276: PPUSH
// CenterNowOnXY ( 192 , 1 ) ;
7277: LD_INT 192
7279: PPUSH
7280: LD_INT 1
7282: PPUSH
7283: CALL_OW 86
// InGameOn ;
7287: CALL_OW 8
// PrepareRussian ;
7291: CALL 3560 0 0
// dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff Davidov ;
7295: LD_ADDR_VAR 0 2
7299: PUSH
7300: LD_INT 22
7302: PUSH
7303: LD_INT 6
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PUSH
7310: LD_INT 2
7312: PUSH
7313: LD_INT 25
7315: PUSH
7316: LD_INT 1
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PUSH
7323: LD_INT 25
7325: PUSH
7326: LD_INT 2
7328: PUSH
7329: EMPTY
7330: LIST
7331: LIST
7332: PUSH
7333: LD_INT 25
7335: PUSH
7336: LD_INT 3
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PUSH
7343: LD_INT 25
7345: PUSH
7346: LD_INT 4
7348: PUSH
7349: EMPTY
7350: LIST
7351: LIST
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: LIST
7358: LIST
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: PPUSH
7364: CALL_OW 69
7368: PUSH
7369: LD_EXP 2
7373: DIFF
7374: ST_TO_ADDR
// ComMoveXY ( dial [ 1 ] , 202 , 40 ) ;
7375: LD_VAR 0 2
7379: PUSH
7380: LD_INT 1
7382: ARRAY
7383: PPUSH
7384: LD_INT 202
7386: PPUSH
7387: LD_INT 40
7389: PPUSH
7390: CALL_OW 111
// Wait ( 0 0$03 ) ;
7394: LD_INT 105
7396: PPUSH
7397: CALL_OW 67
// Say ( Davidov , DDav-1 ) ;
7401: LD_EXP 2
7405: PPUSH
7406: LD_STRING DDav-1
7408: PPUSH
7409: CALL_OW 88
// ComTurnUnit ( dial [ 1 ] , Davidov ) ;
7413: LD_VAR 0 2
7417: PUSH
7418: LD_INT 1
7420: ARRAY
7421: PPUSH
7422: LD_EXP 2
7426: PPUSH
7427: CALL_OW 119
// ComTurnUnit ( Davidov , dial [ 1 ] ) ;
7431: LD_EXP 2
7435: PPUSH
7436: LD_VAR 0 2
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 119
// CenterOnXY ( 202 , 40 ) ;
7449: LD_INT 202
7451: PPUSH
7452: LD_INT 40
7454: PPUSH
7455: CALL_OW 84
// Say ( dial [ 1 ] , DRus-1 ) ;
7459: LD_VAR 0 2
7463: PUSH
7464: LD_INT 1
7466: ARRAY
7467: PPUSH
7468: LD_STRING DRus-1
7470: PPUSH
7471: CALL_OW 88
// Say ( Davidov , DDav-2 ) ;
7475: LD_EXP 2
7479: PPUSH
7480: LD_STRING DDav-2
7482: PPUSH
7483: CALL_OW 88
// Say ( dial [ 1 ] , DRus-2 ) ;
7487: LD_VAR 0 2
7491: PUSH
7492: LD_INT 1
7494: ARRAY
7495: PPUSH
7496: LD_STRING DRus-2
7498: PPUSH
7499: CALL_OW 88
// Say ( Davidov , DDav-3 ) ;
7503: LD_EXP 2
7507: PPUSH
7508: LD_STRING DDav-3
7510: PPUSH
7511: CALL_OW 88
// InGameOff ;
7515: CALL_OW 9
// Wait ( 0 0$0.3 ) ;
7519: LD_INT 10
7521: PPUSH
7522: CALL_OW 67
// ChangeMissionObjectives ( C1 ) ;
7526: LD_STRING C1
7528: PPUSH
7529: CALL_OW 337
// end ;
7533: LD_VAR 0 1
7537: RET
// every 0 0$30 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
7538: LD_INT 22
7540: PUSH
7541: LD_INT 6
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 2
7550: PUSH
7551: LD_INT 30
7553: PUSH
7554: LD_INT 6
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 30
7563: PUSH
7564: LD_INT 7
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 30
7573: PUSH
7574: LD_INT 8
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: LIST
7585: LIST
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: PPUSH
7591: CALL_OW 69
7595: IFFALSE 7695
7597: GO 7599
7599: DISABLE
// begin Say ( Davidov , DDav-4 ) ;
7600: LD_EXP 2
7604: PPUSH
7605: LD_STRING DDav-4
7607: PPUSH
7608: CALL_OW 88
// Wait ( 0 0$40 ) ;
7612: LD_INT 1400
7614: PPUSH
7615: CALL_OW 67
// DialogueOn ;
7619: CALL_OW 6
// SayRadio ( Vervecken , Dver-Meet-1 ) ;
7623: LD_EXP 3
7627: PPUSH
7628: LD_STRING Dver-Meet-1
7630: PPUSH
7631: CALL_OW 94
// Say ( Davidov , DDav-Meet-1 ) ;
7635: LD_EXP 2
7639: PPUSH
7640: LD_STRING DDav-Meet-1
7642: PPUSH
7643: CALL_OW 88
// SayRadio ( Vervecken , Dver-Meet-2 ) ;
7647: LD_EXP 3
7651: PPUSH
7652: LD_STRING Dver-Meet-2
7654: PPUSH
7655: CALL_OW 94
// DialogueOff ;
7659: CALL_OW 7
// Wait ( [ 9 9$20 , 7 7$20 , 6 6$20 ] [ Difficulty ] ) ;
7663: LD_INT 19600
7665: PUSH
7666: LD_INT 15400
7668: PUSH
7669: LD_INT 13300
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: LIST
7676: PUSH
7677: LD_OWVAR 67
7681: ARRAY
7682: PPUSH
7683: CALL_OW 67
// legion_attacks_active := true ;
7687: LD_ADDR_EXP 7
7691: PUSH
7692: LD_INT 1
7694: ST_TO_ADDR
// end ;
7695: END
// every 0 0$02 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) or tick > 10 10$00 do var dial ;
7696: LD_INT 22
7698: PUSH
7699: LD_INT 6
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: LD_INT 30
7708: PUSH
7709: LD_INT 3
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: PUSH
7725: LD_OWVAR 1
7729: PUSH
7730: LD_INT 21000
7732: GREATER
7733: OR
7734: IFFALSE 7968
7736: GO 7738
7738: DISABLE
7739: LD_INT 0
7741: PPUSH
// begin dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff Davidov ;
7742: LD_ADDR_VAR 0 1
7746: PUSH
7747: LD_INT 22
7749: PUSH
7750: LD_INT 6
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: PUSH
7757: LD_INT 2
7759: PUSH
7760: LD_INT 25
7762: PUSH
7763: LD_INT 1
7765: PUSH
7766: EMPTY
7767: LIST
7768: LIST
7769: PUSH
7770: LD_INT 25
7772: PUSH
7773: LD_INT 2
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 25
7782: PUSH
7783: LD_INT 3
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 25
7792: PUSH
7793: LD_INT 4
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PPUSH
7811: CALL_OW 69
7815: PUSH
7816: LD_EXP 2
7820: DIFF
7821: ST_TO_ADDR
// Say ( dial [ 1 ] , DRus-3 ) ;
7822: LD_VAR 0 1
7826: PUSH
7827: LD_INT 1
7829: ARRAY
7830: PPUSH
7831: LD_STRING DRus-3
7833: PPUSH
7834: CALL_OW 88
// Say ( Davidov , DDav-5 ) ;
7838: LD_EXP 2
7842: PPUSH
7843: LD_STRING DDav-5
7845: PPUSH
7846: CALL_OW 88
// Say ( dial [ 1 ] , DRus-4 ) ;
7850: LD_VAR 0 1
7854: PUSH
7855: LD_INT 1
7857: ARRAY
7858: PPUSH
7859: LD_STRING DRus-4
7861: PPUSH
7862: CALL_OW 88
// Say ( Davidov , DDav-6 ) ;
7866: LD_EXP 2
7870: PPUSH
7871: LD_STRING DDav-6
7873: PPUSH
7874: CALL_OW 88
// ChangeMissionObjectives ( C2 ) ;
7878: LD_STRING C2
7880: PPUSH
7881: CALL_OW 337
// Wait ( 5 5$00 ) ;
7885: LD_INT 10500
7887: PPUSH
7888: CALL_OW 67
// DialogueOn ;
7892: CALL_OW 6
// SayRadio ( Bagins , DBag-1 ) ;
7896: LD_EXP 1
7900: PPUSH
7901: LD_STRING DBag-1
7903: PPUSH
7904: CALL_OW 94
// Say ( Davidov , DDavB-1 ) ;
7908: LD_EXP 2
7912: PPUSH
7913: LD_STRING DDavB-1
7915: PPUSH
7916: CALL_OW 88
// SayRadio ( Bagins , DBag-2 ) ;
7920: LD_EXP 1
7924: PPUSH
7925: LD_STRING DBag-2
7927: PPUSH
7928: CALL_OW 94
// Say ( Davidov , DDavB-2 ) ;
7932: LD_EXP 2
7936: PPUSH
7937: LD_STRING DDavB-2
7939: PPUSH
7940: CALL_OW 88
// SayRadio ( Bagins , DBag-3 ) ;
7944: LD_EXP 1
7948: PPUSH
7949: LD_STRING DBag-3
7951: PPUSH
7952: CALL_OW 94
// DialogueOff ;
7956: CALL_OW 7
// alliance_attack_active := true ;
7960: LD_ADDR_EXP 9
7964: PUSH
7965: LD_INT 1
7967: ST_TO_ADDR
// end ;
7968: PPOPN 1
7970: END
// every 0 0$1 trigger alliance_used_artifact_1 do
7971: LD_EXP 10
7975: IFFALSE 8022
7977: GO 7979
7979: DISABLE
// begin DialogueOn ;
7980: CALL_OW 6
// CenterNowOnXY ( alliance_used_artifact_1 [ 1 ] , alliance_used_artifact_1 [ 2 ] ) ;
7984: LD_EXP 10
7988: PUSH
7989: LD_INT 1
7991: ARRAY
7992: PPUSH
7993: LD_EXP 10
7997: PUSH
7998: LD_INT 2
8000: ARRAY
8001: PPUSH
8002: CALL_OW 86
// Say ( Davidov , DDav-Artifact1-1 ) ;
8006: LD_EXP 2
8010: PPUSH
8011: LD_STRING DDav-Artifact1-1
8013: PPUSH
8014: CALL_OW 88
// DialogueOff ;
8018: CALL_OW 7
// end ;
8022: END
// every 0 0$1 trigger alliance_used_artifact_2 do
8023: LD_EXP 11
8027: IFFALSE 8074
8029: GO 8031
8031: DISABLE
// begin DialogueOn ;
8032: CALL_OW 6
// CenterNowOnXY ( alliance_used_artifact_2 [ 1 ] , alliance_used_artifact_2 [ 2 ] ) ;
8036: LD_EXP 11
8040: PUSH
8041: LD_INT 1
8043: ARRAY
8044: PPUSH
8045: LD_EXP 11
8049: PUSH
8050: LD_INT 2
8052: ARRAY
8053: PPUSH
8054: CALL_OW 86
// Say ( Davidov , DDav-Artifact2-1 ) ;
8058: LD_EXP 2
8062: PPUSH
8063: LD_STRING DDav-Artifact2-1
8065: PPUSH
8066: CALL_OW 88
// DialogueOff ;
8070: CALL_OW 7
// end ;
8074: END
// every 0 0$01 trigger artifact_destroyed or ( not FindArtifact ( 6 ) and not player_artifact_loaded ) do
8075: LD_EXP 16
8079: PUSH
8080: LD_INT 6
8082: PPUSH
8083: CALL_OW 469
8087: NOT
8088: PUSH
8089: LD_EXP 18
8093: NOT
8094: AND
8095: OR
8096: IFFALSE 8108
8098: GO 8100
8100: DISABLE
// YouLost ( artifact_destroyed ) ;
8101: LD_STRING artifact_destroyed
8103: PPUSH
8104: CALL_OW 104
8108: END
// every 0 0$01 trigger IsDead ( Davidov ) do
8109: LD_EXP 2
8113: PPUSH
8114: CALL_OW 301
8118: IFFALSE 8130
8120: GO 8122
8122: DISABLE
// YouLost ( dead ) ;
8123: LD_STRING dead
8125: PPUSH
8126: CALL_OW 104
8130: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) = 0 do
8131: LD_INT 22
8133: PUSH
8134: LD_INT 7
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: PUSH
8141: LD_INT 21
8143: PUSH
8144: LD_INT 1
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PPUSH
8155: CALL_OW 69
8159: PUSH
8160: LD_INT 0
8162: EQUAL
8163: IFFALSE 8297
8165: GO 8167
8167: DISABLE
// begin if tick < [ 120 120$00 , 100 100$00 , 90 90$00 ] [ Difficulty ] then
8168: LD_OWVAR 1
8172: PUSH
8173: LD_INT 252000
8175: PUSH
8176: LD_INT 210000
8178: PUSH
8179: LD_INT 189000
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: LIST
8186: PUSH
8187: LD_OWVAR 67
8191: ARRAY
8192: LESS
8193: IFFALSE 8207
// AddMedal ( med1 , 1 ) else
8195: LD_STRING med1
8197: PPUSH
8198: LD_INT 1
8200: PPUSH
8201: CALL_OW 101
8205: GO 8218
// AddMedal ( med1 , - 1 ) ;
8207: LD_STRING med1
8209: PPUSH
8210: LD_INT 1
8212: NEG
8213: PPUSH
8214: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) then
8218: LD_INT 22
8220: PUSH
8221: LD_INT 8
8223: PUSH
8224: EMPTY
8225: LIST
8226: LIST
8227: PPUSH
8228: CALL_OW 69
8232: IFFALSE 8247
// AddMedal ( med2 , - 1 ) else
8234: LD_STRING med2
8236: PPUSH
8237: LD_INT 1
8239: NEG
8240: PPUSH
8241: CALL_OW 101
8245: GO 8257
// AddMedal ( med2 , 1 ) ;
8247: LD_STRING med2
8249: PPUSH
8250: LD_INT 1
8252: PPUSH
8253: CALL_OW 101
// if player_used_sib_bomb then
8257: LD_EXP 12
8261: IFFALSE 8276
// AddMedal ( med3 , - 1 ) else
8263: LD_STRING med3
8265: PPUSH
8266: LD_INT 1
8268: NEG
8269: PPUSH
8270: CALL_OW 101
8274: GO 8286
// AddMedal ( med3 , 1 ) ;
8276: LD_STRING med3
8278: PPUSH
8279: LD_INT 1
8281: PPUSH
8282: CALL_OW 101
// GiveMedals ( MAIN ) ;
8286: LD_STRING MAIN
8288: PPUSH
8289: CALL_OW 102
// YouWin ;
8293: CALL_OW 103
// end ; end_of_file
8297: END
// every 0 0$22 + 0 0$2 do
8298: GO 8300
8300: DISABLE
// begin enable ;
8301: ENABLE
// CreateCratesArea ( Rand ( 4 , 5 ) , cratesArea , true ) ;
8302: LD_INT 4
8304: PPUSH
8305: LD_INT 5
8307: PPUSH
8308: CALL_OW 12
8312: PPUSH
8313: LD_INT 3
8315: PPUSH
8316: LD_INT 1
8318: PPUSH
8319: CALL_OW 55
// if tick >= 4 4$00 then
8323: LD_OWVAR 1
8327: PUSH
8328: LD_INT 8400
8330: GREATEREQUAL
8331: IFFALSE 8338
// begin disable ;
8333: DISABLE
// CratesSpawn ( ) ;
8334: CALL 8339 0 0
// end ; end ;
8338: END
// function CratesSpawn ( ) ; var i , amount , cr ; begin
8339: LD_INT 0
8341: PPUSH
8342: PPUSH
8343: PPUSH
8344: PPUSH
// amount := [ 30000 , 20000 , 10000 ] [ Difficulty ] ;
8345: LD_ADDR_VAR 0 3
8349: PUSH
8350: LD_INT 30000
8352: PUSH
8353: LD_INT 20000
8355: PUSH
8356: LD_INT 10000
8358: PUSH
8359: EMPTY
8360: LIST
8361: LIST
8362: LIST
8363: PUSH
8364: LD_OWVAR 67
8368: ARRAY
8369: ST_TO_ADDR
// while amount > 0 do
8370: LD_VAR 0 3
8374: PUSH
8375: LD_INT 0
8377: GREATER
8378: IFFALSE 8448
// begin Wait ( rand ( 0 0$30 , 1 1$30 ) ) ;
8380: LD_INT 1050
8382: PPUSH
8383: LD_INT 3150
8385: PPUSH
8386: CALL_OW 12
8390: PPUSH
8391: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
8395: LD_ADDR_VAR 0 4
8399: PUSH
8400: LD_INT 1
8402: PPUSH
8403: LD_INT 5
8405: PPUSH
8406: CALL_OW 12
8410: ST_TO_ADDR
// amount := amount - ( cr * 10 ) ;
8411: LD_ADDR_VAR 0 3
8415: PUSH
8416: LD_VAR 0 3
8420: PUSH
8421: LD_VAR 0 4
8425: PUSH
8426: LD_INT 10
8428: MUL
8429: MINUS
8430: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
8431: LD_VAR 0 4
8435: PPUSH
8436: LD_INT 3
8438: PPUSH
8439: LD_INT 1
8441: PPUSH
8442: CALL_OW 55
// end ;
8446: GO 8370
// end ; end_of_file
8448: LD_VAR 0 1
8452: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird , horse ; begin
8453: LD_INT 0
8455: PPUSH
8456: PPUSH
8457: PPUSH
8458: PPUSH
8459: PPUSH
8460: PPUSH
// uc_nation = nation_nature ;
8461: LD_ADDR_OWVAR 21
8465: PUSH
8466: LD_INT 0
8468: ST_TO_ADDR
// uc_side = 0 ;
8469: LD_ADDR_OWVAR 20
8473: PUSH
8474: LD_INT 0
8476: ST_TO_ADDR
// l = 0 ;
8477: LD_ADDR_VAR 0 6
8481: PUSH
8482: LD_INT 0
8484: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
8485: LD_ADDR_OWVAR 24
8489: PUSH
8490: LD_INT 0
8492: PPUSH
8493: LD_INT 5
8495: PPUSH
8496: CALL_OW 12
8500: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
8501: LD_ADDR_OWVAR 35
8505: PUSH
8506: LD_INT 5
8508: NEG
8509: PPUSH
8510: LD_INT 5
8512: PPUSH
8513: CALL_OW 12
8517: ST_TO_ADDR
// hc_gallery =  ;
8518: LD_ADDR_OWVAR 33
8522: PUSH
8523: LD_STRING 
8525: ST_TO_ADDR
// hc_class = class_apeman ;
8526: LD_ADDR_OWVAR 28
8530: PUSH
8531: LD_INT 12
8533: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
8534: LD_ADDR_OWVAR 29
8538: PUSH
8539: LD_INT 11
8541: PPUSH
8542: LD_INT 13
8544: PPUSH
8545: CALL_OW 12
8549: PUSH
8550: LD_INT 10
8552: PPUSH
8553: LD_INT 11
8555: PPUSH
8556: CALL_OW 12
8560: PUSH
8561: EMPTY
8562: LIST
8563: LIST
8564: ST_TO_ADDR
// hc_sex = sex_male ;
8565: LD_ADDR_OWVAR 27
8569: PUSH
8570: LD_INT 1
8572: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
8573: LD_ADDR_OWVAR 31
8577: PUSH
8578: LD_INT 0
8580: PPUSH
8581: LD_INT 2
8583: PPUSH
8584: CALL_OW 12
8588: PUSH
8589: LD_INT 0
8591: PUSH
8592: LD_INT 0
8594: PUSH
8595: LD_INT 0
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: ST_TO_ADDR
// apeman = CreateHuman ;
8604: LD_ADDR_VAR 0 7
8608: PUSH
8609: CALL_OW 44
8613: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
8614: LD_VAR 0 7
8618: PPUSH
8619: LD_VAR 0 4
8623: PPUSH
8624: LD_INT 0
8626: PPUSH
8627: CALL_OW 49
// l = l + 1 ;
8631: LD_ADDR_VAR 0 6
8635: PUSH
8636: LD_VAR 0 6
8640: PUSH
8641: LD_INT 1
8643: PLUS
8644: ST_TO_ADDR
// end until l = num1 ;
8645: LD_VAR 0 6
8649: PUSH
8650: LD_VAR 0 1
8654: EQUAL
8655: IFFALSE 8485
// l = 0 ;
8657: LD_ADDR_VAR 0 6
8661: PUSH
8662: LD_INT 0
8664: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
8665: LD_ADDR_OWVAR 35
8669: PUSH
8670: LD_INT 0
8672: PPUSH
8673: LD_INT 25
8675: PPUSH
8676: CALL_OW 12
8680: ST_TO_ADDR
// hc_class = class_tiger ;
8681: LD_ADDR_OWVAR 28
8685: PUSH
8686: LD_INT 14
8688: ST_TO_ADDR
// hc_sex = sex_male ;
8689: LD_ADDR_OWVAR 27
8693: PUSH
8694: LD_INT 1
8696: ST_TO_ADDR
// hc_gallery = sandnature ;
8697: LD_ADDR_OWVAR 33
8701: PUSH
8702: LD_STRING sandnature
8704: ST_TO_ADDR
// hc_face_number = 3 ;
8705: LD_ADDR_OWVAR 34
8709: PUSH
8710: LD_INT 3
8712: ST_TO_ADDR
// tiger = CreateHuman ;
8713: LD_ADDR_VAR 0 8
8717: PUSH
8718: CALL_OW 44
8722: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8723: LD_VAR 0 8
8727: PPUSH
8728: LD_VAR 0 4
8732: PPUSH
8733: LD_INT 0
8735: PPUSH
8736: CALL_OW 49
// l = l + 1 ;
8740: LD_ADDR_VAR 0 6
8744: PUSH
8745: LD_VAR 0 6
8749: PUSH
8750: LD_INT 1
8752: PLUS
8753: ST_TO_ADDR
// end until l = num2 ;
8754: LD_VAR 0 6
8758: PUSH
8759: LD_VAR 0 2
8763: EQUAL
8764: IFFALSE 8665
// l = 0 ;
8766: LD_ADDR_VAR 0 6
8770: PUSH
8771: LD_INT 0
8773: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8774: LD_ADDR_OWVAR 28
8778: PUSH
8779: LD_INT 18
8781: ST_TO_ADDR
// hc_gallery = sandnature ;
8782: LD_ADDR_OWVAR 33
8786: PUSH
8787: LD_STRING sandnature
8789: ST_TO_ADDR
// hc_face_number = 1 ;
8790: LD_ADDR_OWVAR 34
8794: PUSH
8795: LD_INT 1
8797: ST_TO_ADDR
// bird = CreateHuman ;
8798: LD_ADDR_VAR 0 9
8802: PUSH
8803: CALL_OW 44
8807: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8808: LD_VAR 0 9
8812: PPUSH
8813: LD_INT 0
8815: PPUSH
8816: CALL_OW 51
// l = l + 1 ;
8820: LD_ADDR_VAR 0 6
8824: PUSH
8825: LD_VAR 0 6
8829: PUSH
8830: LD_INT 1
8832: PLUS
8833: ST_TO_ADDR
// end until l = num3 ;
8834: LD_VAR 0 6
8838: PUSH
8839: LD_VAR 0 3
8843: EQUAL
8844: IFFALSE 8774
// for l = 1 to 2 do
8846: LD_ADDR_VAR 0 6
8850: PUSH
8851: DOUBLE
8852: LD_INT 1
8854: DEC
8855: ST_TO_ADDR
8856: LD_INT 2
8858: PUSH
8859: FOR_TO
8860: IFFALSE 8918
// begin hc_class = 21 ;
8862: LD_ADDR_OWVAR 28
8866: PUSH
8867: LD_INT 21
8869: ST_TO_ADDR
// hc_gallery =  ;
8870: LD_ADDR_OWVAR 33
8874: PUSH
8875: LD_STRING 
8877: ST_TO_ADDR
// hc_agressivity = 0 ;
8878: LD_ADDR_OWVAR 35
8882: PUSH
8883: LD_INT 0
8885: ST_TO_ADDR
// hc_face_number = 5 ;
8886: LD_ADDR_OWVAR 34
8890: PUSH
8891: LD_INT 5
8893: ST_TO_ADDR
// horse := CreateHuman ;
8894: LD_ADDR_VAR 0 10
8898: PUSH
8899: CALL_OW 44
8903: ST_TO_ADDR
// PlaceUnitAnywhere ( horse , false ) ;
8904: LD_VAR 0 10
8908: PPUSH
8909: LD_INT 0
8911: PPUSH
8912: CALL_OW 51
// end ;
8916: GO 8859
8918: POP
8919: POP
// hc_gallery :=  ;
8920: LD_ADDR_OWVAR 33
8924: PUSH
8925: LD_STRING 
8927: ST_TO_ADDR
// hc_name :=  ;
8928: LD_ADDR_OWVAR 26
8932: PUSH
8933: LD_STRING 
8935: ST_TO_ADDR
// end ; end_of_file
8936: LD_VAR 0 5
8940: RET
// every 0 0$01 trigger not debug do var timer ;
8941: LD_EXP 6
8945: NOT
8946: IFFALSE 9006
8948: GO 8950
8950: DISABLE
8951: LD_INT 0
8953: PPUSH
// begin timer := 0 0$00 ;
8954: LD_ADDR_VAR 0 1
8958: PUSH
8959: LD_INT 0
8961: ST_TO_ADDR
// while ( true ) do
8962: LD_INT 1
8964: IFFALSE 9006
// begin timer := timer + 0 0$01 ;
8966: LD_ADDR_VAR 0 1
8970: PUSH
8971: LD_VAR 0 1
8975: PUSH
8976: LD_INT 35
8978: PLUS
8979: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
8980: LD_ADDR_OWVAR 47
8984: PUSH
8985: LD_STRING #tick
8987: PUSH
8988: LD_VAR 0 1
8992: PUSH
8993: EMPTY
8994: LIST
8995: LIST
8996: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
8997: LD_INT 35
8999: PPUSH
9000: CALL_OW 67
// end ;
9004: GO 8962
// end ; end_of_file
9006: PPOPN 1
9008: END
// export function DebugArtifact ; begin
9009: LD_INT 0
9011: PPUSH
// AddToLog ( Artifact is loaded:  & player_artifact_loaded ) ;
9012: LD_STRING Artifact is loaded: 
9014: PUSH
9015: LD_EXP 18
9019: STR
9020: PPUSH
9021: CALL_OW 561
// AddToLog ( Artifact is active:  & player_artifact_ready ) ;
9025: LD_STRING Artifact is active: 
9027: PUSH
9028: LD_EXP 29
9032: STR
9033: PPUSH
9034: CALL_OW 561
// AddToLog ( Artifact is researched:  & player_artifact_researched ) ;
9038: LD_STRING Artifact is researched: 
9040: PUSH
9041: LD_EXP 22
9045: STR
9046: PPUSH
9047: CALL_OW 561
// AddToLog ( Artifact coords  & FindArtifact ( player_artifact_number ) ) ;
9051: LD_STRING Artifact coords 
9053: PUSH
9054: LD_EXP 19
9058: PPUSH
9059: CALL_OW 469
9063: STR
9064: PPUSH
9065: CALL_OW 561
// end ;
9069: LD_VAR 0 1
9073: RET
// export function InitArtifactsPos ( ) ; var i , tmp , possible_pos ; begin
9074: LD_INT 0
9076: PPUSH
9077: PPUSH
9078: PPUSH
9079: PPUSH
// possible_pos := [ [ 100 , 185 ] , [ 99 , 175 ] , [ 117 , 191 ] ] ;
9080: LD_ADDR_VAR 0 4
9084: PUSH
9085: LD_INT 100
9087: PUSH
9088: LD_INT 185
9090: PUSH
9091: EMPTY
9092: LIST
9093: LIST
9094: PUSH
9095: LD_INT 99
9097: PUSH
9098: LD_INT 175
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: PUSH
9105: LD_INT 117
9107: PUSH
9108: LD_INT 191
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: PUSH
9115: EMPTY
9116: LIST
9117: LIST
9118: LIST
9119: ST_TO_ADDR
// for i = 1 to artifacts_type do
9120: LD_ADDR_VAR 0 2
9124: PUSH
9125: DOUBLE
9126: LD_INT 1
9128: DEC
9129: ST_TO_ADDR
9130: LD_EXP 14
9134: PUSH
9135: FOR_TO
9136: IFFALSE 9238
// begin tmp := possible_pos [ rand ( 1 , possible_pos ) ] ;
9138: LD_ADDR_VAR 0 3
9142: PUSH
9143: LD_VAR 0 4
9147: PUSH
9148: LD_INT 1
9150: PPUSH
9151: LD_VAR 0 4
9155: PPUSH
9156: CALL_OW 12
9160: ARRAY
9161: ST_TO_ADDR
// possible_pos := possible_pos diff tmp ;
9162: LD_ADDR_VAR 0 4
9166: PUSH
9167: LD_VAR 0 4
9171: PUSH
9172: LD_VAR 0 3
9176: DIFF
9177: ST_TO_ADDR
// artifacts_pos := Insert ( artifacts_pos , i , tmp ) ;
9178: LD_ADDR_EXP 15
9182: PUSH
9183: LD_EXP 15
9187: PPUSH
9188: LD_VAR 0 2
9192: PPUSH
9193: LD_VAR 0 3
9197: PPUSH
9198: CALL_OW 2
9202: ST_TO_ADDR
// CreateArtifact ( artifacts_type [ i ] , tmp [ 1 ] , tmp [ 2 ] ) ;
9203: LD_EXP 14
9207: PUSH
9208: LD_VAR 0 2
9212: ARRAY
9213: PPUSH
9214: LD_VAR 0 3
9218: PUSH
9219: LD_INT 1
9221: ARRAY
9222: PPUSH
9223: LD_VAR 0 3
9227: PUSH
9228: LD_INT 2
9230: ARRAY
9231: PPUSH
9232: CALL 5209 0 3
// end ;
9236: GO 9135
9238: POP
9239: POP
// end ;
9240: LD_VAR 0 1
9244: RET
// export function GetUseCost ( dist ) ; begin
9245: LD_INT 0
9247: PPUSH
// if dist < 30 then
9248: LD_VAR 0 1
9252: PUSH
9253: LD_INT 30
9255: LESS
9256: IFFALSE 9266
// result := 10 ;
9258: LD_ADDR_VAR 0 2
9262: PUSH
9263: LD_INT 10
9265: ST_TO_ADDR
// if dist >= 30 and dist < 50 then
9266: LD_VAR 0 1
9270: PUSH
9271: LD_INT 30
9273: GREATEREQUAL
9274: PUSH
9275: LD_VAR 0 1
9279: PUSH
9280: LD_INT 50
9282: LESS
9283: AND
9284: IFFALSE 9294
// result := 35 ;
9286: LD_ADDR_VAR 0 2
9290: PUSH
9291: LD_INT 35
9293: ST_TO_ADDR
// if dist >= 50 and dist < 80 then
9294: LD_VAR 0 1
9298: PUSH
9299: LD_INT 50
9301: GREATEREQUAL
9302: PUSH
9303: LD_VAR 0 1
9307: PUSH
9308: LD_INT 80
9310: LESS
9311: AND
9312: IFFALSE 9322
// result := 70 ;
9314: LD_ADDR_VAR 0 2
9318: PUSH
9319: LD_INT 70
9321: ST_TO_ADDR
// if dist >= 80 and dist < 120 then
9322: LD_VAR 0 1
9326: PUSH
9327: LD_INT 80
9329: GREATEREQUAL
9330: PUSH
9331: LD_VAR 0 1
9335: PUSH
9336: LD_INT 120
9338: LESS
9339: AND
9340: IFFALSE 9350
// result := 100 ;
9342: LD_ADDR_VAR 0 2
9346: PUSH
9347: LD_INT 100
9349: ST_TO_ADDR
// if dist >= 120 then
9350: LD_VAR 0 1
9354: PUSH
9355: LD_INT 120
9357: GREATEREQUAL
9358: IFFALSE 9368
// result := 150 ;
9360: LD_ADDR_VAR 0 2
9364: PUSH
9365: LD_INT 150
9367: ST_TO_ADDR
// end ;
9368: LD_VAR 0 2
9372: RET
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
9373: LD_VAR 0 1
9377: PPUSH
9378: CALL_OW 255
9382: PUSH
9383: LD_OWVAR 2
9387: EQUAL
9388: IFFALSE 9398
// player_artifact_researched := true ;
9390: LD_ADDR_EXP 22
9394: PUSH
9395: LD_INT 1
9397: ST_TO_ADDR
// end ;
9398: PPOPN 1
9400: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_artifact_researched and not player_artifact_loaded do var lab , coords ;
9401: LD_INT 22
9403: PUSH
9404: LD_OWVAR 2
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PUSH
9413: LD_INT 2
9415: PUSH
9416: LD_INT 30
9418: PUSH
9419: LD_INT 8
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PUSH
9426: LD_INT 30
9428: PUSH
9429: LD_INT 11
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PUSH
9436: EMPTY
9437: LIST
9438: LIST
9439: LIST
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PPUSH
9445: CALL_OW 69
9449: PUSH
9450: LD_EXP 22
9454: AND
9455: PUSH
9456: LD_EXP 18
9460: NOT
9461: AND
9462: IFFALSE 9916
9464: GO 9466
9466: DISABLE
9467: LD_INT 0
9469: PPUSH
9470: PPUSH
// begin enable ;
9471: ENABLE
// coords := FindArtifact ( player_artifact_number ) ;
9472: LD_ADDR_VAR 0 2
9476: PUSH
9477: LD_EXP 19
9481: PPUSH
9482: CALL_OW 469
9486: ST_TO_ADDR
// if not coords then
9487: LD_VAR 0 2
9491: NOT
9492: IFFALSE 9496
// exit ;
9494: GO 9916
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , coords [ 1 ] , coords [ 2 ] ) ;
9496: LD_ADDR_VAR 0 1
9500: PUSH
9501: LD_INT 22
9503: PUSH
9504: LD_OWVAR 2
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: PUSH
9513: LD_INT 2
9515: PUSH
9516: LD_INT 30
9518: PUSH
9519: LD_INT 8
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PUSH
9526: LD_INT 30
9528: PUSH
9529: LD_INT 11
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: LIST
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PPUSH
9545: CALL_OW 69
9549: PPUSH
9550: LD_VAR 0 2
9554: PUSH
9555: LD_INT 1
9557: ARRAY
9558: PPUSH
9559: LD_VAR 0 2
9563: PUSH
9564: LD_INT 2
9566: ARRAY
9567: PPUSH
9568: CALL_OW 73
9572: ST_TO_ADDR
// if not lab then
9573: LD_VAR 0 1
9577: NOT
9578: IFFALSE 9595
// begin if debug then
9580: LD_EXP 6
9584: IFFALSE 9593
// AddToLog ( Cannot find lab for artifact! ) ;
9586: LD_STRING Cannot find lab for artifact!
9588: PPUSH
9589: CALL_OW 561
// exit ;
9593: GO 9916
// end ; if not player_artifact_ready then
9595: LD_EXP 29
9599: NOT
9600: IFFALSE 9724
// begin if GetDistUnitXY ( lab , coords [ 1 ] , coords [ 2 ] ) < player_artifact_active_distance then
9602: LD_VAR 0 1
9606: PPUSH
9607: LD_VAR 0 2
9611: PUSH
9612: LD_INT 1
9614: ARRAY
9615: PPUSH
9616: LD_VAR 0 2
9620: PUSH
9621: LD_INT 2
9623: ARRAY
9624: PPUSH
9625: CALL_OW 297
9629: PUSH
9630: LD_EXP 23
9634: LESS
9635: IFFALSE 9700
// begin if BuildingStatus ( lab ) = bs_idle then
9637: LD_VAR 0 1
9641: PPUSH
9642: CALL_OW 461
9646: PUSH
9647: LD_INT 2
9649: EQUAL
9650: IFFALSE 9676
// SetArtifactUse ( your_side , player_artifact_icon_res , art_instant , lab ) else
9652: LD_OWVAR 2
9656: PPUSH
9657: LD_EXP 25
9661: PPUSH
9662: LD_INT 2
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 468
9674: GO 9698
// SetArtifactUse ( your_side , player_artifact_icon_res , art_gray , lab ) ;
9676: LD_OWVAR 2
9680: PPUSH
9681: LD_EXP 25
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: LD_VAR 0 1
9693: PPUSH
9694: CALL_OW 468
// end else
9698: GO 9722
// SetArtifactUse ( your_side , player_artifact_icon_res , art_gray , lab ) ;
9700: LD_OWVAR 2
9704: PPUSH
9705: LD_EXP 25
9709: PPUSH
9710: LD_INT 1
9712: PPUSH
9713: LD_VAR 0 1
9717: PPUSH
9718: CALL_OW 468
// end else
9722: GO 9916
// if GetDistUnitXY ( lab , coords [ 1 ] , coords [ 2 ] ) < player_artifact_active_distance then
9724: LD_VAR 0 1
9728: PPUSH
9729: LD_VAR 0 2
9733: PUSH
9734: LD_INT 1
9736: ARRAY
9737: PPUSH
9738: LD_VAR 0 2
9742: PUSH
9743: LD_INT 2
9745: ARRAY
9746: PPUSH
9747: CALL_OW 297
9751: PUSH
9752: LD_EXP 23
9756: LESS
9757: IFFALSE 9872
// begin if BuildingStatus ( lab ) = bs_idle then
9759: LD_VAR 0 1
9763: PPUSH
9764: CALL_OW 461
9768: PUSH
9769: LD_INT 2
9771: EQUAL
9772: IFFALSE 9826
// begin SetArtifactUse ( your_side , player_artifact_icon , art_unit , lab ) ;
9774: LD_OWVAR 2
9778: PPUSH
9779: LD_EXP 20
9783: PPUSH
9784: LD_INT 4
9786: PPUSH
9787: LD_VAR 0 1
9791: PPUSH
9792: CALL_OW 468
// if player_artifact_selected_unit then
9796: LD_EXP 30
9800: IFFALSE 9824
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_place , lab ) ;
9802: LD_OWVAR 2
9806: PPUSH
9807: LD_EXP 21
9811: PPUSH
9812: LD_INT 3
9814: PPUSH
9815: LD_VAR 0 1
9819: PPUSH
9820: CALL_OW 468
// end else
9824: GO 9870
// begin SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
9826: LD_OWVAR 2
9830: PPUSH
9831: LD_EXP 20
9835: PPUSH
9836: LD_INT 1
9838: PPUSH
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_gray , lab ) ;
9848: LD_OWVAR 2
9852: PPUSH
9853: LD_EXP 21
9857: PPUSH
9858: LD_INT 1
9860: PPUSH
9861: LD_VAR 0 1
9865: PPUSH
9866: CALL_OW 468
// end ; end else
9870: GO 9916
// begin SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
9872: LD_OWVAR 2
9876: PPUSH
9877: LD_EXP 20
9881: PPUSH
9882: LD_INT 1
9884: PPUSH
9885: LD_VAR 0 1
9889: PPUSH
9890: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_gray , lab ) ;
9894: LD_OWVAR 2
9898: PPUSH
9899: LD_EXP 21
9903: PPUSH
9904: LD_INT 1
9906: PPUSH
9907: LD_VAR 0 1
9911: PPUSH
9912: CALL_OW 468
// end ; end ;
9916: PPOPN 2
9918: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var coords , i , lab , side , dist , cost ;
9919: LD_INT 0
9921: PPUSH
9922: PPUSH
9923: PPUSH
9924: PPUSH
9925: PPUSH
9926: PPUSH
// begin coords := FindArtifact ( player_artifact_number ) ;
9927: LD_ADDR_VAR 0 5
9931: PUSH
9932: LD_EXP 19
9936: PPUSH
9937: CALL_OW 469
9941: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , coords [ 1 ] , coords [ 2 ] ) ;
9942: LD_ADDR_VAR 0 7
9946: PUSH
9947: LD_INT 22
9949: PUSH
9950: LD_OWVAR 2
9954: PUSH
9955: EMPTY
9956: LIST
9957: LIST
9958: PUSH
9959: LD_INT 2
9961: PUSH
9962: LD_INT 30
9964: PUSH
9965: LD_INT 8
9967: PUSH
9968: EMPTY
9969: LIST
9970: LIST
9971: PUSH
9972: LD_INT 30
9974: PUSH
9975: LD_INT 11
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: EMPTY
9983: LIST
9984: LIST
9985: LIST
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: PPUSH
9991: CALL_OW 69
9995: PPUSH
9996: LD_VAR 0 5
10000: PUSH
10001: LD_INT 1
10003: ARRAY
10004: PPUSH
10005: LD_VAR 0 5
10009: PUSH
10010: LD_INT 2
10012: ARRAY
10013: PPUSH
10014: CALL_OW 73
10018: ST_TO_ADDR
// if not lab then
10019: LD_VAR 0 7
10023: NOT
10024: IFFALSE 10041
// begin if debug then
10026: LD_EXP 6
10030: IFFALSE 10039
// AddToLog ( Cannot find lab! ) ;
10032: LD_STRING Cannot find lab!
10034: PPUSH
10035: CALL_OW 561
// exit ;
10039: GO 10399
// end ; if icon = player_artifact_icon_res then
10041: LD_VAR 0 2
10045: PUSH
10046: LD_EXP 25
10050: EQUAL
10051: IFFALSE 10092
// begin SetSpecResearch ( lab , player_artifact_time_res , true ) ;
10053: LD_VAR 0 7
10057: PPUSH
10058: LD_EXP 27
10062: PPUSH
10063: LD_INT 1
10065: PPUSH
10066: CALL_OW 486
// SetArtifactUse ( your_side , player_artifact_icon_res , art_no , lab ) ;
10070: LD_OWVAR 2
10074: PPUSH
10075: LD_EXP 25
10079: PPUSH
10080: LD_INT 0
10082: PPUSH
10083: LD_VAR 0 7
10087: PPUSH
10088: CALL_OW 468
// end ; if icon = player_artifact_icon then
10092: LD_VAR 0 2
10096: PUSH
10097: LD_EXP 20
10101: EQUAL
10102: IFFALSE 10141
// begin if GetType ( cr1 ) = unit_human and not IsInUnit ( cr1 ) then
10104: LD_VAR 0 3
10108: PPUSH
10109: CALL_OW 247
10113: PUSH
10114: LD_INT 1
10116: EQUAL
10117: PUSH
10118: LD_VAR 0 3
10122: PPUSH
10123: CALL_OW 310
10127: NOT
10128: AND
10129: IFFALSE 10141
// player_artifact_selected_unit := cr1 ;
10131: LD_ADDR_EXP 30
10135: PUSH
10136: LD_VAR 0 3
10140: ST_TO_ADDR
// end ; if icon = player_artifact_icon_2 then
10141: LD_VAR 0 2
10145: PUSH
10146: LD_EXP 21
10150: EQUAL
10151: IFFALSE 10389
// begin if HexInfo ( cr1 , cr2 ) <> 0 then
10153: LD_VAR 0 3
10157: PPUSH
10158: LD_VAR 0 4
10162: PPUSH
10163: CALL_OW 428
10167: PUSH
10168: LD_INT 0
10170: NONEQUAL
10171: IFFALSE 10175
// exit ;
10173: GO 10399
// dist := GetDistXY ( GetX ( player_artifact_selected_unit ) , GetY ( player_artifact_selected_unit ) , cr1 , cr2 ) ;
10175: LD_ADDR_VAR 0 9
10179: PUSH
10180: LD_EXP 30
10184: PPUSH
10185: CALL_OW 250
10189: PPUSH
10190: LD_EXP 30
10194: PPUSH
10195: CALL_OW 251
10199: PPUSH
10200: LD_VAR 0 3
10204: PPUSH
10205: LD_VAR 0 4
10209: PPUSH
10210: CALL_OW 298
10214: ST_TO_ADDR
// cost := GetUseCost ( dist ) ;
10215: LD_ADDR_VAR 0 10
10219: PUSH
10220: LD_VAR 0 9
10224: PPUSH
10225: CALL 9245 0 1
10229: ST_TO_ADDR
// if cost > GetSibResources ( your_side ) then
10230: LD_VAR 0 10
10234: PUSH
10235: LD_OWVAR 2
10239: PPUSH
10240: CALL 5423 0 1
10244: GREATER
10245: IFFALSE 10259
// begin HintSpec ( ArtFrogJumpCost , 2 ) ;
10247: LD_STRING ArtFrogJumpCost
10249: PPUSH
10250: LD_INT 2
10252: PPUSH
10253: CALL_OW 338
// exit ;
10257: GO 10399
// end ; SetSibResources ( your_side , cost ) ;
10259: LD_OWVAR 2
10263: PPUSH
10264: LD_VAR 0 10
10268: PPUSH
10269: CALL 5547 0 2
// TeleportUnit ( player_artifact_selected_unit , cr1 , cr2 , 0 , true ) ;
10273: LD_EXP 30
10277: PPUSH
10278: LD_VAR 0 3
10282: PPUSH
10283: LD_VAR 0 4
10287: PPUSH
10288: LD_INT 0
10290: PPUSH
10291: LD_INT 1
10293: PPUSH
10294: CALL_OW 483
// CenterOnXY ( cr1 , cr2 ) ;
10298: LD_VAR 0 3
10302: PPUSH
10303: LD_VAR 0 4
10307: PPUSH
10308: CALL_OW 84
// player_artifact_selected_unit := 0 ;
10312: LD_ADDR_EXP 30
10316: PUSH
10317: LD_INT 0
10319: ST_TO_ADDR
// player_artifact_researched := false ;
10320: LD_ADDR_EXP 22
10324: PUSH
10325: LD_INT 0
10327: ST_TO_ADDR
// SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
10328: LD_OWVAR 2
10332: PPUSH
10333: LD_EXP 20
10337: PPUSH
10338: LD_INT 1
10340: PPUSH
10341: LD_VAR 0 7
10345: PPUSH
10346: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_no , lab ) ;
10350: LD_OWVAR 2
10354: PPUSH
10355: LD_EXP 21
10359: PPUSH
10360: LD_INT 0
10362: PPUSH
10363: LD_VAR 0 7
10367: PPUSH
10368: CALL_OW 468
// Wait ( player_artifact_time_refresh ) ;
10372: LD_EXP 26
10376: PPUSH
10377: CALL_OW 67
// player_artifact_researched := true ;
10381: LD_ADDR_EXP 22
10385: PUSH
10386: LD_INT 1
10388: ST_TO_ADDR
// end ; if debug then
10389: LD_EXP 6
10393: IFFALSE 10399
// DebugArtifact ;
10395: CALL 9009 0 0
// end ;
10399: PPOPN 10
10401: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
10402: LD_VAR 0 1
10406: PPUSH
10407: CALL_OW 255
10411: PUSH
10412: LD_OWVAR 2
10416: EQUAL
10417: IFFALSE 10456
// begin SetArtifactUse ( your_side , player_artifact_icon_res , art_no , lab ) ;
10419: LD_OWVAR 2
10423: PPUSH
10424: LD_EXP 25
10428: PPUSH
10429: LD_INT 0
10431: PPUSH
10432: LD_VAR 0 1
10436: PPUSH
10437: CALL_OW 468
// player_artifact_ready := true ;
10441: LD_ADDR_EXP 29
10445: PUSH
10446: LD_INT 1
10448: ST_TO_ADDR
// Hint ( ArtFrogJump ) ;
10449: LD_STRING ArtFrogJump
10451: PPUSH
10452: CALL_OW 339
// end ; end ;
10456: PPOPN 1
10458: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , player_artifact_icon_res , art_instant , lab ) ;
10459: LD_OWVAR 2
10463: PPUSH
10464: LD_EXP 25
10468: PPUSH
10469: LD_INT 2
10471: PPUSH
10472: LD_VAR 0 1
10476: PPUSH
10477: CALL_OW 468
// end ;
10481: PPOPN 2
10483: END
// export function ActiveArtifact1 ( ) ; var i , tmp , un ; begin
10484: LD_INT 0
10486: PPUSH
10487: PPUSH
10488: PPUSH
10489: PPUSH
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_weapon , ru_siberium_rocket ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_siberite_power ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_siberite_mine ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_ext_siberium ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_teleport ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_bweapon , ru_time_lapser ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_bweapon , ru_rocket ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_engine , engine_siberite ] ] ) ;
10490: LD_ADDR_VAR 0 3
10494: PUSH
10495: LD_INT 81
10497: PUSH
10498: LD_INT 7
10500: PUSH
10501: EMPTY
10502: LIST
10503: LIST
10504: PUSH
10505: LD_INT 34
10507: PUSH
10508: LD_INT 48
10510: PUSH
10511: EMPTY
10512: LIST
10513: LIST
10514: PUSH
10515: EMPTY
10516: LIST
10517: LIST
10518: PPUSH
10519: CALL_OW 69
10523: PUSH
10524: LD_INT 81
10526: PUSH
10527: LD_INT 7
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PUSH
10534: LD_INT 30
10536: PUSH
10537: LD_INT 28
10539: PUSH
10540: EMPTY
10541: LIST
10542: LIST
10543: PUSH
10544: EMPTY
10545: LIST
10546: LIST
10547: PPUSH
10548: CALL_OW 69
10552: ADD
10553: PUSH
10554: LD_INT 81
10556: PUSH
10557: LD_INT 7
10559: PUSH
10560: EMPTY
10561: LIST
10562: LIST
10563: PUSH
10564: LD_INT 30
10566: PUSH
10567: LD_INT 30
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PPUSH
10578: CALL_OW 69
10582: ADD
10583: PUSH
10584: LD_INT 81
10586: PUSH
10587: LD_INT 7
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PUSH
10594: LD_INT 30
10596: PUSH
10597: LD_INT 21
10599: PUSH
10600: EMPTY
10601: LIST
10602: LIST
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: ADD
10613: PUSH
10614: LD_INT 81
10616: PUSH
10617: LD_INT 7
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: PUSH
10624: LD_INT 30
10626: PUSH
10627: LD_INT 34
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: PPUSH
10638: CALL_OW 69
10642: ADD
10643: PUSH
10644: LD_INT 81
10646: PUSH
10647: LD_INT 7
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PUSH
10654: LD_INT 35
10656: PUSH
10657: LD_INT 49
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: EMPTY
10665: LIST
10666: LIST
10667: PPUSH
10668: CALL_OW 69
10672: ADD
10673: PUSH
10674: LD_INT 81
10676: PUSH
10677: LD_INT 7
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 35
10686: PUSH
10687: LD_INT 47
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PPUSH
10698: CALL_OW 69
10702: ADD
10703: PUSH
10704: LD_INT 81
10706: PUSH
10707: LD_INT 7
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: LD_INT 32
10716: PUSH
10717: LD_INT 3
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: PPUSH
10728: CALL_OW 69
10732: ADD
10733: ST_TO_ADDR
// if not tmp then
10734: LD_VAR 0 3
10738: NOT
10739: IFFALSE 10743
// exit ;
10741: GO 10864
// if UnitFilter ( tmp , [ f_weapon , ru_siberium_rocket ] ) then
10743: LD_VAR 0 3
10747: PPUSH
10748: LD_INT 34
10750: PUSH
10751: LD_INT 48
10753: PUSH
10754: EMPTY
10755: LIST
10756: LIST
10757: PPUSH
10758: CALL_OW 72
10762: IFFALSE 10795
// un := UnitFilter ( tmp , [ f_weapon , ru_siberium_rocket ] ) [ 1 ] else
10764: LD_ADDR_VAR 0 4
10768: PUSH
10769: LD_VAR 0 3
10773: PPUSH
10774: LD_INT 34
10776: PUSH
10777: LD_INT 48
10779: PUSH
10780: EMPTY
10781: LIST
10782: LIST
10783: PPUSH
10784: CALL_OW 72
10788: PUSH
10789: LD_INT 1
10791: ARRAY
10792: ST_TO_ADDR
10793: GO 10819
// un := tmp [ rand ( 1 , tmp ) ] ;
10795: LD_ADDR_VAR 0 4
10799: PUSH
10800: LD_VAR 0 3
10804: PUSH
10805: LD_INT 1
10807: PPUSH
10808: LD_VAR 0 3
10812: PPUSH
10813: CALL_OW 12
10817: ARRAY
10818: ST_TO_ADDR
// if not alliance_used_artifact_1 then
10819: LD_EXP 10
10823: NOT
10824: IFFALSE 10855
// alliance_used_artifact_1 := [ GetX ( un ) , GetY ( un ) ] ;
10826: LD_ADDR_EXP 10
10830: PUSH
10831: LD_VAR 0 4
10835: PPUSH
10836: CALL_OW 250
10840: PUSH
10841: LD_VAR 0 4
10845: PPUSH
10846: CALL_OW 251
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: ST_TO_ADDR
// KillUnit ( un ) ;
10855: LD_VAR 0 4
10859: PPUSH
10860: CALL_OW 66
// end ;
10864: LD_VAR 0 1
10868: RET
// export function ActiveArtifact2 ( ) ; var i , un , tmp ; begin
10869: LD_INT 0
10871: PPUSH
10872: PPUSH
10873: PPUSH
10874: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , 6 ] , [ f_control , control_computer ] ] ) ;
10875: LD_ADDR_VAR 0 4
10879: PUSH
10880: LD_INT 22
10882: PUSH
10883: LD_INT 6
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: PUSH
10890: LD_INT 33
10892: PUSH
10893: LD_INT 3
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: PUSH
10900: EMPTY
10901: LIST
10902: LIST
10903: PPUSH
10904: CALL_OW 69
10908: ST_TO_ADDR
// if not tmp then
10909: LD_VAR 0 4
10913: NOT
10914: IFFALSE 10918
// exit ;
10916: GO 11044
// un := tmp [ rand ( 1 , tmp ) ] ;
10918: LD_ADDR_VAR 0 3
10922: PUSH
10923: LD_VAR 0 4
10927: PUSH
10928: LD_INT 1
10930: PPUSH
10931: LD_VAR 0 4
10935: PPUSH
10936: CALL_OW 12
10940: ARRAY
10941: ST_TO_ADDR
// if GetWeapon ( un ) = ru_siberium_rocket then
10942: LD_VAR 0 3
10946: PPUSH
10947: CALL_OW 264
10951: PUSH
10952: LD_INT 48
10954: EQUAL
10955: IFFALSE 10974
// ComAttackPlace ( un , 194 , 19 ) else
10957: LD_VAR 0 3
10961: PPUSH
10962: LD_INT 194
10964: PPUSH
10965: LD_INT 19
10967: PPUSH
10968: CALL_OW 116
10972: GO 11008
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , un ) ) ;
10974: LD_VAR 0 3
10978: PPUSH
10979: LD_INT 81
10981: PUSH
10982: LD_INT 7
10984: PUSH
10985: EMPTY
10986: LIST
10987: LIST
10988: PPUSH
10989: CALL_OW 69
10993: PPUSH
10994: LD_VAR 0 3
10998: PPUSH
10999: CALL_OW 74
11003: PPUSH
11004: CALL_OW 115
// if not alliance_used_artifact_2 then
11008: LD_EXP 11
11012: NOT
11013: IFFALSE 11044
// alliance_used_artifact_2 := [ GetX ( un ) , GetY ( un ) ] ;
11015: LD_ADDR_EXP 11
11019: PUSH
11020: LD_VAR 0 3
11024: PPUSH
11025: CALL_OW 250
11029: PUSH
11030: LD_VAR 0 3
11034: PPUSH
11035: CALL_OW 251
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: ST_TO_ADDR
// end ; end_of_file
11044: LD_VAR 0 1
11048: RET
// export function DebugMode ; var i , j , b ; begin
11049: LD_INT 0
11051: PPUSH
11052: PPUSH
11053: PPUSH
11054: PPUSH
// enable_addtolog = true ;
11055: LD_ADDR_OWVAR 81
11059: PUSH
11060: LD_INT 1
11062: ST_TO_ADDR
// FogOff ( 6 ) ;
11063: LD_INT 6
11065: PPUSH
11066: CALL_OW 344
// uc_side = 6 ;
11070: LD_ADDR_OWVAR 20
11074: PUSH
11075: LD_INT 6
11077: ST_TO_ADDR
// uc_nation = 3 ;
11078: LD_ADDR_OWVAR 21
11082: PUSH
11083: LD_INT 3
11085: ST_TO_ADDR
// bc_level = 10 ;
11086: LD_ADDR_OWVAR 43
11090: PUSH
11091: LD_INT 10
11093: ST_TO_ADDR
// bc_type := b_lab_full ;
11094: LD_ADDR_OWVAR 42
11098: PUSH
11099: LD_INT 8
11101: ST_TO_ADDR
// bc_kind1 := 11 ;
11102: LD_ADDR_OWVAR 44
11106: PUSH
11107: LD_INT 11
11109: ST_TO_ADDR
// bc_kind2 := 12 ;
11110: LD_ADDR_OWVAR 45
11114: PUSH
11115: LD_INT 12
11117: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 189 , 20 , 1 ) ;
11118: LD_INT 189
11120: PPUSH
11121: LD_INT 20
11123: PPUSH
11124: LD_INT 1
11126: PPUSH
11127: CALL_OW 47
// bc_type := b_warehouse ;
11131: LD_ADDR_OWVAR 42
11135: PUSH
11136: LD_INT 1
11138: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 201 , 22 , 4 ) ;
11139: LD_ADDR_VAR 0 4
11143: PUSH
11144: LD_INT 201
11146: PPUSH
11147: LD_INT 22
11149: PPUSH
11150: LD_INT 4
11152: PPUSH
11153: CALL_OW 47
11157: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , 10000 ) ;
11158: LD_VAR 0 4
11162: PPUSH
11163: CALL_OW 274
11167: PPUSH
11168: LD_INT 1
11170: PPUSH
11171: LD_INT 10000
11173: PPUSH
11174: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , 10000 ) ;
11178: LD_VAR 0 4
11182: PPUSH
11183: CALL_OW 274
11187: PPUSH
11188: LD_INT 2
11190: PPUSH
11191: LD_INT 10000
11193: PPUSH
11194: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , 10000 ) ;
11198: LD_VAR 0 4
11202: PPUSH
11203: CALL_OW 274
11207: PPUSH
11208: LD_INT 3
11210: PPUSH
11211: LD_INT 10000
11213: PPUSH
11214: CALL_OW 277
// bc_type := b_siberite_power ;
11218: LD_ADDR_OWVAR 42
11222: PUSH
11223: LD_INT 28
11225: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 216 , 16 , 4 ) ;
11226: LD_ADDR_VAR 0 4
11230: PUSH
11231: LD_INT 216
11233: PPUSH
11234: LD_INT 16
11236: PPUSH
11237: LD_INT 4
11239: PPUSH
11240: CALL_OW 47
11244: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 219 , 16 , 4 ) ;
11245: LD_ADDR_VAR 0 4
11249: PUSH
11250: LD_INT 219
11252: PPUSH
11253: LD_INT 16
11255: PPUSH
11256: LD_INT 4
11258: PPUSH
11259: CALL_OW 47
11263: ST_TO_ADDR
// SetTech ( tech_sib2 , 6 , state_researched ) ;
11264: LD_INT 55
11266: PPUSH
11267: LD_INT 6
11269: PPUSH
11270: LD_INT 2
11272: PPUSH
11273: CALL_OW 322
// SetTech ( tech_sib3 , 6 , state_researched ) ;
11277: LD_INT 56
11279: PPUSH
11280: LD_INT 6
11282: PPUSH
11283: LD_INT 2
11285: PPUSH
11286: CALL_OW 322
// end ; end_of_file
11290: LD_VAR 0 1
11294: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
11295: LD_INT 0
11297: PPUSH
11298: PPUSH
11299: PPUSH
11300: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11301: LD_VAR 0 1
11305: PPUSH
11306: CALL_OW 264
11310: PUSH
11311: LD_EXP 94
11315: EQUAL
11316: IFFALSE 11388
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11318: LD_INT 68
11320: PPUSH
11321: LD_VAR 0 1
11325: PPUSH
11326: CALL_OW 255
11330: PPUSH
11331: CALL_OW 321
11335: PUSH
11336: LD_INT 2
11338: EQUAL
11339: IFFALSE 11351
// eff := 70 else
11341: LD_ADDR_VAR 0 4
11345: PUSH
11346: LD_INT 70
11348: ST_TO_ADDR
11349: GO 11359
// eff := 30 ;
11351: LD_ADDR_VAR 0 4
11355: PUSH
11356: LD_INT 30
11358: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11359: LD_VAR 0 1
11363: PPUSH
11364: CALL_OW 250
11368: PPUSH
11369: LD_VAR 0 1
11373: PPUSH
11374: CALL_OW 251
11378: PPUSH
11379: LD_VAR 0 4
11383: PPUSH
11384: CALL_OW 495
// end ; end ;
11388: LD_VAR 0 2
11392: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
11393: LD_INT 0
11395: PPUSH
// end ;
11396: LD_VAR 0 4
11400: RET
// export function SOS_Command ( cmd ) ; begin
11401: LD_INT 0
11403: PPUSH
// end ;
11404: LD_VAR 0 2
11408: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 255
11416: EQUAL
11417: PUSH
11418: LD_VAR 0 2
11422: PPUSH
11423: CALL_OW 264
11427: PUSH
11428: LD_INT 14
11430: PUSH
11431: LD_INT 53
11433: PUSH
11434: EMPTY
11435: LIST
11436: LIST
11437: IN
11438: AND
11439: PUSH
11440: LD_VAR 0 4
11444: PPUSH
11445: LD_VAR 0 5
11449: PPUSH
11450: CALL_OW 488
11454: AND
11455: IFFALSE 11479
// CutTreeXYR ( unit , x , y , 12 ) ;
11457: LD_VAR 0 2
11461: PPUSH
11462: LD_VAR 0 4
11466: PPUSH
11467: LD_VAR 0 5
11471: PPUSH
11472: LD_INT 12
11474: PPUSH
11475: CALL 11482 0 4
// end ;
11479: PPOPN 5
11481: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11482: LD_INT 0
11484: PPUSH
11485: PPUSH
11486: PPUSH
11487: PPUSH
11488: PPUSH
11489: PPUSH
11490: PPUSH
11491: PPUSH
11492: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11493: LD_VAR 0 1
11497: NOT
11498: PUSH
11499: LD_VAR 0 2
11503: PPUSH
11504: LD_VAR 0 3
11508: PPUSH
11509: CALL_OW 488
11513: NOT
11514: OR
11515: PUSH
11516: LD_VAR 0 4
11520: NOT
11521: OR
11522: IFFALSE 11526
// exit ;
11524: GO 11866
// list := [ ] ;
11526: LD_ADDR_VAR 0 13
11530: PUSH
11531: EMPTY
11532: ST_TO_ADDR
// if x - r < 0 then
11533: LD_VAR 0 2
11537: PUSH
11538: LD_VAR 0 4
11542: MINUS
11543: PUSH
11544: LD_INT 0
11546: LESS
11547: IFFALSE 11559
// min_x := 0 else
11549: LD_ADDR_VAR 0 7
11553: PUSH
11554: LD_INT 0
11556: ST_TO_ADDR
11557: GO 11575
// min_x := x - r ;
11559: LD_ADDR_VAR 0 7
11563: PUSH
11564: LD_VAR 0 2
11568: PUSH
11569: LD_VAR 0 4
11573: MINUS
11574: ST_TO_ADDR
// if y - r < 0 then
11575: LD_VAR 0 3
11579: PUSH
11580: LD_VAR 0 4
11584: MINUS
11585: PUSH
11586: LD_INT 0
11588: LESS
11589: IFFALSE 11601
// min_y := 0 else
11591: LD_ADDR_VAR 0 8
11595: PUSH
11596: LD_INT 0
11598: ST_TO_ADDR
11599: GO 11617
// min_y := y - r ;
11601: LD_ADDR_VAR 0 8
11605: PUSH
11606: LD_VAR 0 3
11610: PUSH
11611: LD_VAR 0 4
11615: MINUS
11616: ST_TO_ADDR
// max_x := x + r ;
11617: LD_ADDR_VAR 0 9
11621: PUSH
11622: LD_VAR 0 2
11626: PUSH
11627: LD_VAR 0 4
11631: PLUS
11632: ST_TO_ADDR
// max_y := y + r ;
11633: LD_ADDR_VAR 0 10
11637: PUSH
11638: LD_VAR 0 3
11642: PUSH
11643: LD_VAR 0 4
11647: PLUS
11648: ST_TO_ADDR
// for _x = min_x to max_x do
11649: LD_ADDR_VAR 0 11
11653: PUSH
11654: DOUBLE
11655: LD_VAR 0 7
11659: DEC
11660: ST_TO_ADDR
11661: LD_VAR 0 9
11665: PUSH
11666: FOR_TO
11667: IFFALSE 11784
// for _y = min_y to max_y do
11669: LD_ADDR_VAR 0 12
11673: PUSH
11674: DOUBLE
11675: LD_VAR 0 8
11679: DEC
11680: ST_TO_ADDR
11681: LD_VAR 0 10
11685: PUSH
11686: FOR_TO
11687: IFFALSE 11780
// begin if not ValidHex ( _x , _y ) then
11689: LD_VAR 0 11
11693: PPUSH
11694: LD_VAR 0 12
11698: PPUSH
11699: CALL_OW 488
11703: NOT
11704: IFFALSE 11708
// continue ;
11706: GO 11686
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
11708: LD_VAR 0 11
11712: PPUSH
11713: LD_VAR 0 12
11717: PPUSH
11718: CALL_OW 351
11722: PUSH
11723: LD_VAR 0 11
11727: PPUSH
11728: LD_VAR 0 12
11732: PPUSH
11733: CALL_OW 554
11737: AND
11738: IFFALSE 11778
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
11740: LD_ADDR_VAR 0 13
11744: PUSH
11745: LD_VAR 0 13
11749: PPUSH
11750: LD_VAR 0 13
11754: PUSH
11755: LD_INT 1
11757: PLUS
11758: PPUSH
11759: LD_VAR 0 11
11763: PUSH
11764: LD_VAR 0 12
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PPUSH
11773: CALL_OW 2
11777: ST_TO_ADDR
// end ;
11778: GO 11686
11780: POP
11781: POP
11782: GO 11666
11784: POP
11785: POP
// if not list then
11786: LD_VAR 0 13
11790: NOT
11791: IFFALSE 11795
// exit ;
11793: GO 11866
// for i in list do
11795: LD_ADDR_VAR 0 6
11799: PUSH
11800: LD_VAR 0 13
11804: PUSH
11805: FOR_IN
11806: IFFALSE 11864
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
11808: LD_VAR 0 1
11812: PPUSH
11813: LD_STRING M
11815: PUSH
11816: LD_VAR 0 6
11820: PUSH
11821: LD_INT 1
11823: ARRAY
11824: PUSH
11825: LD_VAR 0 6
11829: PUSH
11830: LD_INT 2
11832: ARRAY
11833: PUSH
11834: LD_INT 0
11836: PUSH
11837: LD_INT 0
11839: PUSH
11840: LD_INT 0
11842: PUSH
11843: LD_INT 0
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: PUSH
11855: EMPTY
11856: LIST
11857: PPUSH
11858: CALL_OW 447
11862: GO 11805
11864: POP
11865: POP
// end ; end_of_file
11866: LD_VAR 0 5
11870: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
11871: GO 11873
11873: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11874: LD_STRING initStreamRollete();
11876: PPUSH
11877: CALL_OW 559
// InitStreamMode ;
11881: CALL 11890 0 0
// DefineStreamItems ( ) ;
11885: CALL 12330 0 0
// end ;
11889: END
// function InitStreamMode ; begin
11890: LD_INT 0
11892: PPUSH
// streamModeActive := false ;
11893: LD_ADDR_EXP 36
11897: PUSH
11898: LD_INT 0
11900: ST_TO_ADDR
// normalCounter := 36 ;
11901: LD_ADDR_EXP 37
11905: PUSH
11906: LD_INT 36
11908: ST_TO_ADDR
// hardcoreCounter := 16 ;
11909: LD_ADDR_EXP 38
11913: PUSH
11914: LD_INT 16
11916: ST_TO_ADDR
// sRocket := false ;
11917: LD_ADDR_EXP 41
11921: PUSH
11922: LD_INT 0
11924: ST_TO_ADDR
// sSpeed := false ;
11925: LD_ADDR_EXP 40
11929: PUSH
11930: LD_INT 0
11932: ST_TO_ADDR
// sEngine := false ;
11933: LD_ADDR_EXP 42
11937: PUSH
11938: LD_INT 0
11940: ST_TO_ADDR
// sSpec := false ;
11941: LD_ADDR_EXP 39
11945: PUSH
11946: LD_INT 0
11948: ST_TO_ADDR
// sLevel := false ;
11949: LD_ADDR_EXP 43
11953: PUSH
11954: LD_INT 0
11956: ST_TO_ADDR
// sArmoury := false ;
11957: LD_ADDR_EXP 44
11961: PUSH
11962: LD_INT 0
11964: ST_TO_ADDR
// sRadar := false ;
11965: LD_ADDR_EXP 45
11969: PUSH
11970: LD_INT 0
11972: ST_TO_ADDR
// sBunker := false ;
11973: LD_ADDR_EXP 46
11977: PUSH
11978: LD_INT 0
11980: ST_TO_ADDR
// sHack := false ;
11981: LD_ADDR_EXP 47
11985: PUSH
11986: LD_INT 0
11988: ST_TO_ADDR
// sFire := false ;
11989: LD_ADDR_EXP 48
11993: PUSH
11994: LD_INT 0
11996: ST_TO_ADDR
// sRefresh := false ;
11997: LD_ADDR_EXP 49
12001: PUSH
12002: LD_INT 0
12004: ST_TO_ADDR
// sExp := false ;
12005: LD_ADDR_EXP 50
12009: PUSH
12010: LD_INT 0
12012: ST_TO_ADDR
// sDepot := false ;
12013: LD_ADDR_EXP 51
12017: PUSH
12018: LD_INT 0
12020: ST_TO_ADDR
// sFlag := false ;
12021: LD_ADDR_EXP 52
12025: PUSH
12026: LD_INT 0
12028: ST_TO_ADDR
// sKamikadze := false ;
12029: LD_ADDR_EXP 60
12033: PUSH
12034: LD_INT 0
12036: ST_TO_ADDR
// sTroll := false ;
12037: LD_ADDR_EXP 61
12041: PUSH
12042: LD_INT 0
12044: ST_TO_ADDR
// sSlow := false ;
12045: LD_ADDR_EXP 62
12049: PUSH
12050: LD_INT 0
12052: ST_TO_ADDR
// sLack := false ;
12053: LD_ADDR_EXP 63
12057: PUSH
12058: LD_INT 0
12060: ST_TO_ADDR
// sTank := false ;
12061: LD_ADDR_EXP 65
12065: PUSH
12066: LD_INT 0
12068: ST_TO_ADDR
// sRemote := false ;
12069: LD_ADDR_EXP 66
12073: PUSH
12074: LD_INT 0
12076: ST_TO_ADDR
// sPowell := false ;
12077: LD_ADDR_EXP 67
12081: PUSH
12082: LD_INT 0
12084: ST_TO_ADDR
// sTeleport := false ;
12085: LD_ADDR_EXP 70
12089: PUSH
12090: LD_INT 0
12092: ST_TO_ADDR
// sOilTower := false ;
12093: LD_ADDR_EXP 72
12097: PUSH
12098: LD_INT 0
12100: ST_TO_ADDR
// sShovel := false ;
12101: LD_ADDR_EXP 73
12105: PUSH
12106: LD_INT 0
12108: ST_TO_ADDR
// sSheik := false ;
12109: LD_ADDR_EXP 74
12113: PUSH
12114: LD_INT 0
12116: ST_TO_ADDR
// sEarthquake := false ;
12117: LD_ADDR_EXP 76
12121: PUSH
12122: LD_INT 0
12124: ST_TO_ADDR
// sAI := false ;
12125: LD_ADDR_EXP 77
12129: PUSH
12130: LD_INT 0
12132: ST_TO_ADDR
// sCargo := false ;
12133: LD_ADDR_EXP 80
12137: PUSH
12138: LD_INT 0
12140: ST_TO_ADDR
// sDLaser := false ;
12141: LD_ADDR_EXP 81
12145: PUSH
12146: LD_INT 0
12148: ST_TO_ADDR
// sExchange := false ;
12149: LD_ADDR_EXP 82
12153: PUSH
12154: LD_INT 0
12156: ST_TO_ADDR
// sFac := false ;
12157: LD_ADDR_EXP 83
12161: PUSH
12162: LD_INT 0
12164: ST_TO_ADDR
// sPower := false ;
12165: LD_ADDR_EXP 84
12169: PUSH
12170: LD_INT 0
12172: ST_TO_ADDR
// sRandom := false ;
12173: LD_ADDR_EXP 85
12177: PUSH
12178: LD_INT 0
12180: ST_TO_ADDR
// sShield := false ;
12181: LD_ADDR_EXP 86
12185: PUSH
12186: LD_INT 0
12188: ST_TO_ADDR
// sTime := false ;
12189: LD_ADDR_EXP 87
12193: PUSH
12194: LD_INT 0
12196: ST_TO_ADDR
// sTools := false ;
12197: LD_ADDR_EXP 88
12201: PUSH
12202: LD_INT 0
12204: ST_TO_ADDR
// sSold := false ;
12205: LD_ADDR_EXP 53
12209: PUSH
12210: LD_INT 0
12212: ST_TO_ADDR
// sDiff := false ;
12213: LD_ADDR_EXP 54
12217: PUSH
12218: LD_INT 0
12220: ST_TO_ADDR
// sFog := false ;
12221: LD_ADDR_EXP 57
12225: PUSH
12226: LD_INT 0
12228: ST_TO_ADDR
// sReset := false ;
12229: LD_ADDR_EXP 58
12233: PUSH
12234: LD_INT 0
12236: ST_TO_ADDR
// sSun := false ;
12237: LD_ADDR_EXP 59
12241: PUSH
12242: LD_INT 0
12244: ST_TO_ADDR
// sTiger := false ;
12245: LD_ADDR_EXP 55
12249: PUSH
12250: LD_INT 0
12252: ST_TO_ADDR
// sBomb := false ;
12253: LD_ADDR_EXP 56
12257: PUSH
12258: LD_INT 0
12260: ST_TO_ADDR
// sWound := false ;
12261: LD_ADDR_EXP 64
12265: PUSH
12266: LD_INT 0
12268: ST_TO_ADDR
// sBetray := false ;
12269: LD_ADDR_EXP 68
12273: PUSH
12274: LD_INT 0
12276: ST_TO_ADDR
// sContamin := false ;
12277: LD_ADDR_EXP 69
12281: PUSH
12282: LD_INT 0
12284: ST_TO_ADDR
// sOil := false ;
12285: LD_ADDR_EXP 71
12289: PUSH
12290: LD_INT 0
12292: ST_TO_ADDR
// sStu := false ;
12293: LD_ADDR_EXP 75
12297: PUSH
12298: LD_INT 0
12300: ST_TO_ADDR
// sBazooka := false ;
12301: LD_ADDR_EXP 78
12305: PUSH
12306: LD_INT 0
12308: ST_TO_ADDR
// sMortar := false ;
12309: LD_ADDR_EXP 79
12313: PUSH
12314: LD_INT 0
12316: ST_TO_ADDR
// sRanger := false ;
12317: LD_ADDR_EXP 89
12321: PUSH
12322: LD_INT 0
12324: ST_TO_ADDR
// end ;
12325: LD_VAR 0 1
12329: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
12330: LD_INT 0
12332: PPUSH
12333: PPUSH
12334: PPUSH
12335: PPUSH
12336: PPUSH
// result := [ ] ;
12337: LD_ADDR_VAR 0 1
12341: PUSH
12342: EMPTY
12343: ST_TO_ADDR
// if campaign_id = 1 then
12344: LD_OWVAR 69
12348: PUSH
12349: LD_INT 1
12351: EQUAL
12352: IFFALSE 15290
// begin case mission_number of 1 :
12354: LD_OWVAR 70
12358: PUSH
12359: LD_INT 1
12361: DOUBLE
12362: EQUAL
12363: IFTRUE 12367
12365: GO 12431
12367: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
12368: LD_ADDR_VAR 0 1
12372: PUSH
12373: LD_INT 2
12375: PUSH
12376: LD_INT 4
12378: PUSH
12379: LD_INT 11
12381: PUSH
12382: LD_INT 12
12384: PUSH
12385: LD_INT 15
12387: PUSH
12388: LD_INT 16
12390: PUSH
12391: LD_INT 22
12393: PUSH
12394: LD_INT 23
12396: PUSH
12397: LD_INT 26
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: LIST
12409: LIST
12410: PUSH
12411: LD_INT 101
12413: PUSH
12414: LD_INT 102
12416: PUSH
12417: LD_INT 106
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: LIST
12424: PUSH
12425: EMPTY
12426: LIST
12427: LIST
12428: ST_TO_ADDR
12429: GO 15288
12431: LD_INT 2
12433: DOUBLE
12434: EQUAL
12435: IFTRUE 12439
12437: GO 12511
12439: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
12440: LD_ADDR_VAR 0 1
12444: PUSH
12445: LD_INT 2
12447: PUSH
12448: LD_INT 4
12450: PUSH
12451: LD_INT 11
12453: PUSH
12454: LD_INT 12
12456: PUSH
12457: LD_INT 15
12459: PUSH
12460: LD_INT 16
12462: PUSH
12463: LD_INT 22
12465: PUSH
12466: LD_INT 23
12468: PUSH
12469: LD_INT 26
12471: PUSH
12472: EMPTY
12473: LIST
12474: LIST
12475: LIST
12476: LIST
12477: LIST
12478: LIST
12479: LIST
12480: LIST
12481: LIST
12482: PUSH
12483: LD_INT 101
12485: PUSH
12486: LD_INT 102
12488: PUSH
12489: LD_INT 105
12491: PUSH
12492: LD_INT 106
12494: PUSH
12495: LD_INT 108
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: ST_TO_ADDR
12509: GO 15288
12511: LD_INT 3
12513: DOUBLE
12514: EQUAL
12515: IFTRUE 12519
12517: GO 12595
12519: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
12520: LD_ADDR_VAR 0 1
12524: PUSH
12525: LD_INT 2
12527: PUSH
12528: LD_INT 4
12530: PUSH
12531: LD_INT 5
12533: PUSH
12534: LD_INT 11
12536: PUSH
12537: LD_INT 12
12539: PUSH
12540: LD_INT 15
12542: PUSH
12543: LD_INT 16
12545: PUSH
12546: LD_INT 22
12548: PUSH
12549: LD_INT 26
12551: PUSH
12552: LD_INT 36
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PUSH
12567: LD_INT 101
12569: PUSH
12570: LD_INT 102
12572: PUSH
12573: LD_INT 105
12575: PUSH
12576: LD_INT 106
12578: PUSH
12579: LD_INT 108
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: ST_TO_ADDR
12593: GO 15288
12595: LD_INT 4
12597: DOUBLE
12598: EQUAL
12599: IFTRUE 12603
12601: GO 12687
12603: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
12604: LD_ADDR_VAR 0 1
12608: PUSH
12609: LD_INT 2
12611: PUSH
12612: LD_INT 4
12614: PUSH
12615: LD_INT 5
12617: PUSH
12618: LD_INT 8
12620: PUSH
12621: LD_INT 11
12623: PUSH
12624: LD_INT 12
12626: PUSH
12627: LD_INT 15
12629: PUSH
12630: LD_INT 16
12632: PUSH
12633: LD_INT 22
12635: PUSH
12636: LD_INT 23
12638: PUSH
12639: LD_INT 26
12641: PUSH
12642: LD_INT 36
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: LIST
12651: LIST
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: LIST
12658: PUSH
12659: LD_INT 101
12661: PUSH
12662: LD_INT 102
12664: PUSH
12665: LD_INT 105
12667: PUSH
12668: LD_INT 106
12670: PUSH
12671: LD_INT 108
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: ST_TO_ADDR
12685: GO 15288
12687: LD_INT 5
12689: DOUBLE
12690: EQUAL
12691: IFTRUE 12695
12693: GO 12795
12695: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
12696: LD_ADDR_VAR 0 1
12700: PUSH
12701: LD_INT 2
12703: PUSH
12704: LD_INT 4
12706: PUSH
12707: LD_INT 5
12709: PUSH
12710: LD_INT 6
12712: PUSH
12713: LD_INT 8
12715: PUSH
12716: LD_INT 11
12718: PUSH
12719: LD_INT 12
12721: PUSH
12722: LD_INT 15
12724: PUSH
12725: LD_INT 16
12727: PUSH
12728: LD_INT 22
12730: PUSH
12731: LD_INT 23
12733: PUSH
12734: LD_INT 25
12736: PUSH
12737: LD_INT 26
12739: PUSH
12740: LD_INT 36
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: LIST
12750: LIST
12751: LIST
12752: LIST
12753: LIST
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: PUSH
12759: LD_INT 101
12761: PUSH
12762: LD_INT 102
12764: PUSH
12765: LD_INT 105
12767: PUSH
12768: LD_INT 106
12770: PUSH
12771: LD_INT 108
12773: PUSH
12774: LD_INT 109
12776: PUSH
12777: LD_INT 112
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: ST_TO_ADDR
12793: GO 15288
12795: LD_INT 6
12797: DOUBLE
12798: EQUAL
12799: IFTRUE 12803
12801: GO 12923
12803: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
12804: LD_ADDR_VAR 0 1
12808: PUSH
12809: LD_INT 2
12811: PUSH
12812: LD_INT 4
12814: PUSH
12815: LD_INT 5
12817: PUSH
12818: LD_INT 6
12820: PUSH
12821: LD_INT 8
12823: PUSH
12824: LD_INT 11
12826: PUSH
12827: LD_INT 12
12829: PUSH
12830: LD_INT 15
12832: PUSH
12833: LD_INT 16
12835: PUSH
12836: LD_INT 20
12838: PUSH
12839: LD_INT 21
12841: PUSH
12842: LD_INT 22
12844: PUSH
12845: LD_INT 23
12847: PUSH
12848: LD_INT 25
12850: PUSH
12851: LD_INT 26
12853: PUSH
12854: LD_INT 30
12856: PUSH
12857: LD_INT 31
12859: PUSH
12860: LD_INT 32
12862: PUSH
12863: LD_INT 36
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: PUSH
12887: LD_INT 101
12889: PUSH
12890: LD_INT 102
12892: PUSH
12893: LD_INT 105
12895: PUSH
12896: LD_INT 106
12898: PUSH
12899: LD_INT 108
12901: PUSH
12902: LD_INT 109
12904: PUSH
12905: LD_INT 112
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: LIST
12916: PUSH
12917: EMPTY
12918: LIST
12919: LIST
12920: ST_TO_ADDR
12921: GO 15288
12923: LD_INT 7
12925: DOUBLE
12926: EQUAL
12927: IFTRUE 12931
12929: GO 13031
12931: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12932: LD_ADDR_VAR 0 1
12936: PUSH
12937: LD_INT 2
12939: PUSH
12940: LD_INT 4
12942: PUSH
12943: LD_INT 5
12945: PUSH
12946: LD_INT 7
12948: PUSH
12949: LD_INT 11
12951: PUSH
12952: LD_INT 12
12954: PUSH
12955: LD_INT 15
12957: PUSH
12958: LD_INT 16
12960: PUSH
12961: LD_INT 20
12963: PUSH
12964: LD_INT 21
12966: PUSH
12967: LD_INT 22
12969: PUSH
12970: LD_INT 23
12972: PUSH
12973: LD_INT 25
12975: PUSH
12976: LD_INT 26
12978: PUSH
12979: EMPTY
12980: LIST
12981: LIST
12982: LIST
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: LIST
12992: LIST
12993: LIST
12994: PUSH
12995: LD_INT 101
12997: PUSH
12998: LD_INT 102
13000: PUSH
13001: LD_INT 103
13003: PUSH
13004: LD_INT 105
13006: PUSH
13007: LD_INT 106
13009: PUSH
13010: LD_INT 108
13012: PUSH
13013: LD_INT 112
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: LIST
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: ST_TO_ADDR
13029: GO 15288
13031: LD_INT 8
13033: DOUBLE
13034: EQUAL
13035: IFTRUE 13039
13037: GO 13167
13039: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
13040: LD_ADDR_VAR 0 1
13044: PUSH
13045: LD_INT 2
13047: PUSH
13048: LD_INT 4
13050: PUSH
13051: LD_INT 5
13053: PUSH
13054: LD_INT 6
13056: PUSH
13057: LD_INT 7
13059: PUSH
13060: LD_INT 8
13062: PUSH
13063: LD_INT 11
13065: PUSH
13066: LD_INT 12
13068: PUSH
13069: LD_INT 15
13071: PUSH
13072: LD_INT 16
13074: PUSH
13075: LD_INT 20
13077: PUSH
13078: LD_INT 21
13080: PUSH
13081: LD_INT 22
13083: PUSH
13084: LD_INT 23
13086: PUSH
13087: LD_INT 25
13089: PUSH
13090: LD_INT 26
13092: PUSH
13093: LD_INT 30
13095: PUSH
13096: LD_INT 31
13098: PUSH
13099: LD_INT 32
13101: PUSH
13102: LD_INT 36
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: PUSH
13127: LD_INT 101
13129: PUSH
13130: LD_INT 102
13132: PUSH
13133: LD_INT 103
13135: PUSH
13136: LD_INT 105
13138: PUSH
13139: LD_INT 106
13141: PUSH
13142: LD_INT 108
13144: PUSH
13145: LD_INT 109
13147: PUSH
13148: LD_INT 112
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: LIST
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: ST_TO_ADDR
13165: GO 15288
13167: LD_INT 9
13169: DOUBLE
13170: EQUAL
13171: IFTRUE 13175
13173: GO 13311
13175: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
13176: LD_ADDR_VAR 0 1
13180: PUSH
13181: LD_INT 2
13183: PUSH
13184: LD_INT 4
13186: PUSH
13187: LD_INT 5
13189: PUSH
13190: LD_INT 6
13192: PUSH
13193: LD_INT 7
13195: PUSH
13196: LD_INT 8
13198: PUSH
13199: LD_INT 11
13201: PUSH
13202: LD_INT 12
13204: PUSH
13205: LD_INT 15
13207: PUSH
13208: LD_INT 16
13210: PUSH
13211: LD_INT 20
13213: PUSH
13214: LD_INT 21
13216: PUSH
13217: LD_INT 22
13219: PUSH
13220: LD_INT 23
13222: PUSH
13223: LD_INT 25
13225: PUSH
13226: LD_INT 26
13228: PUSH
13229: LD_INT 28
13231: PUSH
13232: LD_INT 30
13234: PUSH
13235: LD_INT 31
13237: PUSH
13238: LD_INT 32
13240: PUSH
13241: LD_INT 36
13243: PUSH
13244: EMPTY
13245: LIST
13246: LIST
13247: LIST
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: PUSH
13267: LD_INT 101
13269: PUSH
13270: LD_INT 102
13272: PUSH
13273: LD_INT 103
13275: PUSH
13276: LD_INT 105
13278: PUSH
13279: LD_INT 106
13281: PUSH
13282: LD_INT 108
13284: PUSH
13285: LD_INT 109
13287: PUSH
13288: LD_INT 112
13290: PUSH
13291: LD_INT 114
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: LIST
13302: LIST
13303: LIST
13304: PUSH
13305: EMPTY
13306: LIST
13307: LIST
13308: ST_TO_ADDR
13309: GO 15288
13311: LD_INT 10
13313: DOUBLE
13314: EQUAL
13315: IFTRUE 13319
13317: GO 13503
13319: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
13320: LD_ADDR_VAR 0 1
13324: PUSH
13325: LD_INT 2
13327: PUSH
13328: LD_INT 4
13330: PUSH
13331: LD_INT 5
13333: PUSH
13334: LD_INT 6
13336: PUSH
13337: LD_INT 7
13339: PUSH
13340: LD_INT 8
13342: PUSH
13343: LD_INT 9
13345: PUSH
13346: LD_INT 10
13348: PUSH
13349: LD_INT 11
13351: PUSH
13352: LD_INT 12
13354: PUSH
13355: LD_INT 13
13357: PUSH
13358: LD_INT 14
13360: PUSH
13361: LD_INT 15
13363: PUSH
13364: LD_INT 16
13366: PUSH
13367: LD_INT 17
13369: PUSH
13370: LD_INT 18
13372: PUSH
13373: LD_INT 19
13375: PUSH
13376: LD_INT 20
13378: PUSH
13379: LD_INT 21
13381: PUSH
13382: LD_INT 22
13384: PUSH
13385: LD_INT 23
13387: PUSH
13388: LD_INT 24
13390: PUSH
13391: LD_INT 25
13393: PUSH
13394: LD_INT 26
13396: PUSH
13397: LD_INT 28
13399: PUSH
13400: LD_INT 30
13402: PUSH
13403: LD_INT 31
13405: PUSH
13406: LD_INT 32
13408: PUSH
13409: LD_INT 36
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: LIST
13429: LIST
13430: LIST
13431: LIST
13432: LIST
13433: LIST
13434: LIST
13435: LIST
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: PUSH
13443: LD_INT 101
13445: PUSH
13446: LD_INT 102
13448: PUSH
13449: LD_INT 103
13451: PUSH
13452: LD_INT 104
13454: PUSH
13455: LD_INT 105
13457: PUSH
13458: LD_INT 106
13460: PUSH
13461: LD_INT 107
13463: PUSH
13464: LD_INT 108
13466: PUSH
13467: LD_INT 109
13469: PUSH
13470: LD_INT 110
13472: PUSH
13473: LD_INT 111
13475: PUSH
13476: LD_INT 112
13478: PUSH
13479: LD_INT 114
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: LIST
13489: LIST
13490: LIST
13491: LIST
13492: LIST
13493: LIST
13494: LIST
13495: LIST
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: ST_TO_ADDR
13501: GO 15288
13503: LD_INT 11
13505: DOUBLE
13506: EQUAL
13507: IFTRUE 13511
13509: GO 13703
13511: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
13512: LD_ADDR_VAR 0 1
13516: PUSH
13517: LD_INT 2
13519: PUSH
13520: LD_INT 3
13522: PUSH
13523: LD_INT 4
13525: PUSH
13526: LD_INT 5
13528: PUSH
13529: LD_INT 6
13531: PUSH
13532: LD_INT 7
13534: PUSH
13535: LD_INT 8
13537: PUSH
13538: LD_INT 9
13540: PUSH
13541: LD_INT 10
13543: PUSH
13544: LD_INT 11
13546: PUSH
13547: LD_INT 12
13549: PUSH
13550: LD_INT 13
13552: PUSH
13553: LD_INT 14
13555: PUSH
13556: LD_INT 15
13558: PUSH
13559: LD_INT 16
13561: PUSH
13562: LD_INT 17
13564: PUSH
13565: LD_INT 18
13567: PUSH
13568: LD_INT 19
13570: PUSH
13571: LD_INT 20
13573: PUSH
13574: LD_INT 21
13576: PUSH
13577: LD_INT 22
13579: PUSH
13580: LD_INT 23
13582: PUSH
13583: LD_INT 24
13585: PUSH
13586: LD_INT 25
13588: PUSH
13589: LD_INT 26
13591: PUSH
13592: LD_INT 28
13594: PUSH
13595: LD_INT 30
13597: PUSH
13598: LD_INT 31
13600: PUSH
13601: LD_INT 32
13603: PUSH
13604: LD_INT 34
13606: PUSH
13607: LD_INT 36
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: LIST
13636: LIST
13637: LIST
13638: LIST
13639: LIST
13640: LIST
13641: LIST
13642: PUSH
13643: LD_INT 101
13645: PUSH
13646: LD_INT 102
13648: PUSH
13649: LD_INT 103
13651: PUSH
13652: LD_INT 104
13654: PUSH
13655: LD_INT 105
13657: PUSH
13658: LD_INT 106
13660: PUSH
13661: LD_INT 107
13663: PUSH
13664: LD_INT 108
13666: PUSH
13667: LD_INT 109
13669: PUSH
13670: LD_INT 110
13672: PUSH
13673: LD_INT 111
13675: PUSH
13676: LD_INT 112
13678: PUSH
13679: LD_INT 114
13681: PUSH
13682: EMPTY
13683: LIST
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: ST_TO_ADDR
13701: GO 15288
13703: LD_INT 12
13705: DOUBLE
13706: EQUAL
13707: IFTRUE 13711
13709: GO 13919
13711: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
13712: LD_ADDR_VAR 0 1
13716: PUSH
13717: LD_INT 1
13719: PUSH
13720: LD_INT 2
13722: PUSH
13723: LD_INT 3
13725: PUSH
13726: LD_INT 4
13728: PUSH
13729: LD_INT 5
13731: PUSH
13732: LD_INT 6
13734: PUSH
13735: LD_INT 7
13737: PUSH
13738: LD_INT 8
13740: PUSH
13741: LD_INT 9
13743: PUSH
13744: LD_INT 10
13746: PUSH
13747: LD_INT 11
13749: PUSH
13750: LD_INT 12
13752: PUSH
13753: LD_INT 13
13755: PUSH
13756: LD_INT 14
13758: PUSH
13759: LD_INT 15
13761: PUSH
13762: LD_INT 16
13764: PUSH
13765: LD_INT 17
13767: PUSH
13768: LD_INT 18
13770: PUSH
13771: LD_INT 19
13773: PUSH
13774: LD_INT 20
13776: PUSH
13777: LD_INT 21
13779: PUSH
13780: LD_INT 22
13782: PUSH
13783: LD_INT 23
13785: PUSH
13786: LD_INT 24
13788: PUSH
13789: LD_INT 25
13791: PUSH
13792: LD_INT 26
13794: PUSH
13795: LD_INT 27
13797: PUSH
13798: LD_INT 28
13800: PUSH
13801: LD_INT 30
13803: PUSH
13804: LD_INT 31
13806: PUSH
13807: LD_INT 32
13809: PUSH
13810: LD_INT 33
13812: PUSH
13813: LD_INT 34
13815: PUSH
13816: LD_INT 36
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: LIST
13829: LIST
13830: LIST
13831: LIST
13832: LIST
13833: LIST
13834: LIST
13835: LIST
13836: LIST
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: LIST
13852: LIST
13853: LIST
13854: PUSH
13855: LD_INT 101
13857: PUSH
13858: LD_INT 102
13860: PUSH
13861: LD_INT 103
13863: PUSH
13864: LD_INT 104
13866: PUSH
13867: LD_INT 105
13869: PUSH
13870: LD_INT 106
13872: PUSH
13873: LD_INT 107
13875: PUSH
13876: LD_INT 108
13878: PUSH
13879: LD_INT 109
13881: PUSH
13882: LD_INT 110
13884: PUSH
13885: LD_INT 111
13887: PUSH
13888: LD_INT 112
13890: PUSH
13891: LD_INT 113
13893: PUSH
13894: LD_INT 114
13896: PUSH
13897: EMPTY
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: ST_TO_ADDR
13917: GO 15288
13919: LD_INT 13
13921: DOUBLE
13922: EQUAL
13923: IFTRUE 13927
13925: GO 14123
13927: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13928: LD_ADDR_VAR 0 1
13932: PUSH
13933: LD_INT 1
13935: PUSH
13936: LD_INT 2
13938: PUSH
13939: LD_INT 3
13941: PUSH
13942: LD_INT 4
13944: PUSH
13945: LD_INT 5
13947: PUSH
13948: LD_INT 8
13950: PUSH
13951: LD_INT 9
13953: PUSH
13954: LD_INT 10
13956: PUSH
13957: LD_INT 11
13959: PUSH
13960: LD_INT 12
13962: PUSH
13963: LD_INT 14
13965: PUSH
13966: LD_INT 15
13968: PUSH
13969: LD_INT 16
13971: PUSH
13972: LD_INT 17
13974: PUSH
13975: LD_INT 18
13977: PUSH
13978: LD_INT 19
13980: PUSH
13981: LD_INT 20
13983: PUSH
13984: LD_INT 21
13986: PUSH
13987: LD_INT 22
13989: PUSH
13990: LD_INT 23
13992: PUSH
13993: LD_INT 24
13995: PUSH
13996: LD_INT 25
13998: PUSH
13999: LD_INT 26
14001: PUSH
14002: LD_INT 27
14004: PUSH
14005: LD_INT 28
14007: PUSH
14008: LD_INT 30
14010: PUSH
14011: LD_INT 31
14013: PUSH
14014: LD_INT 32
14016: PUSH
14017: LD_INT 33
14019: PUSH
14020: LD_INT 34
14022: PUSH
14023: LD_INT 36
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: LIST
14045: LIST
14046: LIST
14047: LIST
14048: LIST
14049: LIST
14050: LIST
14051: LIST
14052: LIST
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: LIST
14058: PUSH
14059: LD_INT 101
14061: PUSH
14062: LD_INT 102
14064: PUSH
14065: LD_INT 103
14067: PUSH
14068: LD_INT 104
14070: PUSH
14071: LD_INT 105
14073: PUSH
14074: LD_INT 106
14076: PUSH
14077: LD_INT 107
14079: PUSH
14080: LD_INT 108
14082: PUSH
14083: LD_INT 109
14085: PUSH
14086: LD_INT 110
14088: PUSH
14089: LD_INT 111
14091: PUSH
14092: LD_INT 112
14094: PUSH
14095: LD_INT 113
14097: PUSH
14098: LD_INT 114
14100: PUSH
14101: EMPTY
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: PUSH
14117: EMPTY
14118: LIST
14119: LIST
14120: ST_TO_ADDR
14121: GO 15288
14123: LD_INT 14
14125: DOUBLE
14126: EQUAL
14127: IFTRUE 14131
14129: GO 14343
14131: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
14132: LD_ADDR_VAR 0 1
14136: PUSH
14137: LD_INT 1
14139: PUSH
14140: LD_INT 2
14142: PUSH
14143: LD_INT 3
14145: PUSH
14146: LD_INT 4
14148: PUSH
14149: LD_INT 5
14151: PUSH
14152: LD_INT 6
14154: PUSH
14155: LD_INT 7
14157: PUSH
14158: LD_INT 8
14160: PUSH
14161: LD_INT 9
14163: PUSH
14164: LD_INT 10
14166: PUSH
14167: LD_INT 11
14169: PUSH
14170: LD_INT 12
14172: PUSH
14173: LD_INT 13
14175: PUSH
14176: LD_INT 14
14178: PUSH
14179: LD_INT 15
14181: PUSH
14182: LD_INT 16
14184: PUSH
14185: LD_INT 17
14187: PUSH
14188: LD_INT 18
14190: PUSH
14191: LD_INT 19
14193: PUSH
14194: LD_INT 20
14196: PUSH
14197: LD_INT 21
14199: PUSH
14200: LD_INT 22
14202: PUSH
14203: LD_INT 23
14205: PUSH
14206: LD_INT 24
14208: PUSH
14209: LD_INT 25
14211: PUSH
14212: LD_INT 26
14214: PUSH
14215: LD_INT 27
14217: PUSH
14218: LD_INT 28
14220: PUSH
14221: LD_INT 29
14223: PUSH
14224: LD_INT 30
14226: PUSH
14227: LD_INT 31
14229: PUSH
14230: LD_INT 32
14232: PUSH
14233: LD_INT 33
14235: PUSH
14236: LD_INT 34
14238: PUSH
14239: LD_INT 36
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: LIST
14250: LIST
14251: LIST
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: LIST
14257: LIST
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: LIST
14264: LIST
14265: LIST
14266: LIST
14267: LIST
14268: LIST
14269: LIST
14270: LIST
14271: LIST
14272: LIST
14273: LIST
14274: LIST
14275: LIST
14276: LIST
14277: LIST
14278: PUSH
14279: LD_INT 101
14281: PUSH
14282: LD_INT 102
14284: PUSH
14285: LD_INT 103
14287: PUSH
14288: LD_INT 104
14290: PUSH
14291: LD_INT 105
14293: PUSH
14294: LD_INT 106
14296: PUSH
14297: LD_INT 107
14299: PUSH
14300: LD_INT 108
14302: PUSH
14303: LD_INT 109
14305: PUSH
14306: LD_INT 110
14308: PUSH
14309: LD_INT 111
14311: PUSH
14312: LD_INT 112
14314: PUSH
14315: LD_INT 113
14317: PUSH
14318: LD_INT 114
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: ST_TO_ADDR
14341: GO 15288
14343: LD_INT 15
14345: DOUBLE
14346: EQUAL
14347: IFTRUE 14351
14349: GO 14563
14351: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
14352: LD_ADDR_VAR 0 1
14356: PUSH
14357: LD_INT 1
14359: PUSH
14360: LD_INT 2
14362: PUSH
14363: LD_INT 3
14365: PUSH
14366: LD_INT 4
14368: PUSH
14369: LD_INT 5
14371: PUSH
14372: LD_INT 6
14374: PUSH
14375: LD_INT 7
14377: PUSH
14378: LD_INT 8
14380: PUSH
14381: LD_INT 9
14383: PUSH
14384: LD_INT 10
14386: PUSH
14387: LD_INT 11
14389: PUSH
14390: LD_INT 12
14392: PUSH
14393: LD_INT 13
14395: PUSH
14396: LD_INT 14
14398: PUSH
14399: LD_INT 15
14401: PUSH
14402: LD_INT 16
14404: PUSH
14405: LD_INT 17
14407: PUSH
14408: LD_INT 18
14410: PUSH
14411: LD_INT 19
14413: PUSH
14414: LD_INT 20
14416: PUSH
14417: LD_INT 21
14419: PUSH
14420: LD_INT 22
14422: PUSH
14423: LD_INT 23
14425: PUSH
14426: LD_INT 24
14428: PUSH
14429: LD_INT 25
14431: PUSH
14432: LD_INT 26
14434: PUSH
14435: LD_INT 27
14437: PUSH
14438: LD_INT 28
14440: PUSH
14441: LD_INT 29
14443: PUSH
14444: LD_INT 30
14446: PUSH
14447: LD_INT 31
14449: PUSH
14450: LD_INT 32
14452: PUSH
14453: LD_INT 33
14455: PUSH
14456: LD_INT 34
14458: PUSH
14459: LD_INT 36
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: LIST
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: LIST
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: LIST
14476: LIST
14477: LIST
14478: LIST
14479: LIST
14480: LIST
14481: LIST
14482: LIST
14483: LIST
14484: LIST
14485: LIST
14486: LIST
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: LIST
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 101
14501: PUSH
14502: LD_INT 102
14504: PUSH
14505: LD_INT 103
14507: PUSH
14508: LD_INT 104
14510: PUSH
14511: LD_INT 105
14513: PUSH
14514: LD_INT 106
14516: PUSH
14517: LD_INT 107
14519: PUSH
14520: LD_INT 108
14522: PUSH
14523: LD_INT 109
14525: PUSH
14526: LD_INT 110
14528: PUSH
14529: LD_INT 111
14531: PUSH
14532: LD_INT 112
14534: PUSH
14535: LD_INT 113
14537: PUSH
14538: LD_INT 114
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: ST_TO_ADDR
14561: GO 15288
14563: LD_INT 16
14565: DOUBLE
14566: EQUAL
14567: IFTRUE 14571
14569: GO 14695
14571: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14572: LD_ADDR_VAR 0 1
14576: PUSH
14577: LD_INT 2
14579: PUSH
14580: LD_INT 4
14582: PUSH
14583: LD_INT 5
14585: PUSH
14586: LD_INT 7
14588: PUSH
14589: LD_INT 11
14591: PUSH
14592: LD_INT 12
14594: PUSH
14595: LD_INT 15
14597: PUSH
14598: LD_INT 16
14600: PUSH
14601: LD_INT 20
14603: PUSH
14604: LD_INT 21
14606: PUSH
14607: LD_INT 22
14609: PUSH
14610: LD_INT 23
14612: PUSH
14613: LD_INT 25
14615: PUSH
14616: LD_INT 26
14618: PUSH
14619: LD_INT 30
14621: PUSH
14622: LD_INT 31
14624: PUSH
14625: LD_INT 32
14627: PUSH
14628: LD_INT 33
14630: PUSH
14631: LD_INT 34
14633: PUSH
14634: EMPTY
14635: LIST
14636: LIST
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: LIST
14643: LIST
14644: LIST
14645: LIST
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: PUSH
14655: LD_INT 101
14657: PUSH
14658: LD_INT 102
14660: PUSH
14661: LD_INT 103
14663: PUSH
14664: LD_INT 106
14666: PUSH
14667: LD_INT 108
14669: PUSH
14670: LD_INT 112
14672: PUSH
14673: LD_INT 113
14675: PUSH
14676: LD_INT 114
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: LIST
14687: LIST
14688: PUSH
14689: EMPTY
14690: LIST
14691: LIST
14692: ST_TO_ADDR
14693: GO 15288
14695: LD_INT 17
14697: DOUBLE
14698: EQUAL
14699: IFTRUE 14703
14701: GO 14915
14703: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
14704: LD_ADDR_VAR 0 1
14708: PUSH
14709: LD_INT 1
14711: PUSH
14712: LD_INT 2
14714: PUSH
14715: LD_INT 3
14717: PUSH
14718: LD_INT 4
14720: PUSH
14721: LD_INT 5
14723: PUSH
14724: LD_INT 6
14726: PUSH
14727: LD_INT 7
14729: PUSH
14730: LD_INT 8
14732: PUSH
14733: LD_INT 9
14735: PUSH
14736: LD_INT 10
14738: PUSH
14739: LD_INT 11
14741: PUSH
14742: LD_INT 12
14744: PUSH
14745: LD_INT 13
14747: PUSH
14748: LD_INT 14
14750: PUSH
14751: LD_INT 15
14753: PUSH
14754: LD_INT 16
14756: PUSH
14757: LD_INT 17
14759: PUSH
14760: LD_INT 18
14762: PUSH
14763: LD_INT 19
14765: PUSH
14766: LD_INT 20
14768: PUSH
14769: LD_INT 21
14771: PUSH
14772: LD_INT 22
14774: PUSH
14775: LD_INT 23
14777: PUSH
14778: LD_INT 24
14780: PUSH
14781: LD_INT 25
14783: PUSH
14784: LD_INT 26
14786: PUSH
14787: LD_INT 27
14789: PUSH
14790: LD_INT 28
14792: PUSH
14793: LD_INT 29
14795: PUSH
14796: LD_INT 30
14798: PUSH
14799: LD_INT 31
14801: PUSH
14802: LD_INT 32
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 34
14810: PUSH
14811: LD_INT 36
14813: PUSH
14814: EMPTY
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: LIST
14830: LIST
14831: LIST
14832: LIST
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: PUSH
14851: LD_INT 101
14853: PUSH
14854: LD_INT 102
14856: PUSH
14857: LD_INT 103
14859: PUSH
14860: LD_INT 104
14862: PUSH
14863: LD_INT 105
14865: PUSH
14866: LD_INT 106
14868: PUSH
14869: LD_INT 107
14871: PUSH
14872: LD_INT 108
14874: PUSH
14875: LD_INT 109
14877: PUSH
14878: LD_INT 110
14880: PUSH
14881: LD_INT 111
14883: PUSH
14884: LD_INT 112
14886: PUSH
14887: LD_INT 113
14889: PUSH
14890: LD_INT 114
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: LIST
14897: LIST
14898: LIST
14899: LIST
14900: LIST
14901: LIST
14902: LIST
14903: LIST
14904: LIST
14905: LIST
14906: LIST
14907: LIST
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: ST_TO_ADDR
14913: GO 15288
14915: LD_INT 18
14917: DOUBLE
14918: EQUAL
14919: IFTRUE 14923
14921: GO 15059
14923: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14924: LD_ADDR_VAR 0 1
14928: PUSH
14929: LD_INT 2
14931: PUSH
14932: LD_INT 4
14934: PUSH
14935: LD_INT 5
14937: PUSH
14938: LD_INT 7
14940: PUSH
14941: LD_INT 11
14943: PUSH
14944: LD_INT 12
14946: PUSH
14947: LD_INT 15
14949: PUSH
14950: LD_INT 16
14952: PUSH
14953: LD_INT 20
14955: PUSH
14956: LD_INT 21
14958: PUSH
14959: LD_INT 22
14961: PUSH
14962: LD_INT 23
14964: PUSH
14965: LD_INT 25
14967: PUSH
14968: LD_INT 26
14970: PUSH
14971: LD_INT 30
14973: PUSH
14974: LD_INT 31
14976: PUSH
14977: LD_INT 32
14979: PUSH
14980: LD_INT 33
14982: PUSH
14983: LD_INT 34
14985: PUSH
14986: LD_INT 35
14988: PUSH
14989: LD_INT 36
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: LIST
14996: LIST
14997: LIST
14998: LIST
14999: LIST
15000: LIST
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: LIST
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: PUSH
15015: LD_INT 101
15017: PUSH
15018: LD_INT 102
15020: PUSH
15021: LD_INT 103
15023: PUSH
15024: LD_INT 106
15026: PUSH
15027: LD_INT 108
15029: PUSH
15030: LD_INT 112
15032: PUSH
15033: LD_INT 113
15035: PUSH
15036: LD_INT 114
15038: PUSH
15039: LD_INT 115
15041: PUSH
15042: EMPTY
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: PUSH
15053: EMPTY
15054: LIST
15055: LIST
15056: ST_TO_ADDR
15057: GO 15288
15059: LD_INT 19
15061: DOUBLE
15062: EQUAL
15063: IFTRUE 15067
15065: GO 15287
15067: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
15068: LD_ADDR_VAR 0 1
15072: PUSH
15073: LD_INT 1
15075: PUSH
15076: LD_INT 2
15078: PUSH
15079: LD_INT 3
15081: PUSH
15082: LD_INT 4
15084: PUSH
15085: LD_INT 5
15087: PUSH
15088: LD_INT 6
15090: PUSH
15091: LD_INT 7
15093: PUSH
15094: LD_INT 8
15096: PUSH
15097: LD_INT 9
15099: PUSH
15100: LD_INT 10
15102: PUSH
15103: LD_INT 11
15105: PUSH
15106: LD_INT 12
15108: PUSH
15109: LD_INT 13
15111: PUSH
15112: LD_INT 14
15114: PUSH
15115: LD_INT 15
15117: PUSH
15118: LD_INT 16
15120: PUSH
15121: LD_INT 17
15123: PUSH
15124: LD_INT 18
15126: PUSH
15127: LD_INT 19
15129: PUSH
15130: LD_INT 20
15132: PUSH
15133: LD_INT 21
15135: PUSH
15136: LD_INT 22
15138: PUSH
15139: LD_INT 23
15141: PUSH
15142: LD_INT 24
15144: PUSH
15145: LD_INT 25
15147: PUSH
15148: LD_INT 26
15150: PUSH
15151: LD_INT 27
15153: PUSH
15154: LD_INT 28
15156: PUSH
15157: LD_INT 29
15159: PUSH
15160: LD_INT 30
15162: PUSH
15163: LD_INT 31
15165: PUSH
15166: LD_INT 32
15168: PUSH
15169: LD_INT 33
15171: PUSH
15172: LD_INT 34
15174: PUSH
15175: LD_INT 35
15177: PUSH
15178: LD_INT 36
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: LIST
15185: LIST
15186: LIST
15187: LIST
15188: LIST
15189: LIST
15190: LIST
15191: LIST
15192: LIST
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: LIST
15204: LIST
15205: LIST
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: PUSH
15219: LD_INT 101
15221: PUSH
15222: LD_INT 102
15224: PUSH
15225: LD_INT 103
15227: PUSH
15228: LD_INT 104
15230: PUSH
15231: LD_INT 105
15233: PUSH
15234: LD_INT 106
15236: PUSH
15237: LD_INT 107
15239: PUSH
15240: LD_INT 108
15242: PUSH
15243: LD_INT 109
15245: PUSH
15246: LD_INT 110
15248: PUSH
15249: LD_INT 111
15251: PUSH
15252: LD_INT 112
15254: PUSH
15255: LD_INT 113
15257: PUSH
15258: LD_INT 114
15260: PUSH
15261: LD_INT 115
15263: PUSH
15264: EMPTY
15265: LIST
15266: LIST
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: LIST
15278: LIST
15279: LIST
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: ST_TO_ADDR
15285: GO 15288
15287: POP
// end else
15288: GO 15507
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
15290: LD_ADDR_VAR 0 1
15294: PUSH
15295: LD_INT 1
15297: PUSH
15298: LD_INT 2
15300: PUSH
15301: LD_INT 3
15303: PUSH
15304: LD_INT 4
15306: PUSH
15307: LD_INT 5
15309: PUSH
15310: LD_INT 6
15312: PUSH
15313: LD_INT 7
15315: PUSH
15316: LD_INT 8
15318: PUSH
15319: LD_INT 9
15321: PUSH
15322: LD_INT 10
15324: PUSH
15325: LD_INT 11
15327: PUSH
15328: LD_INT 12
15330: PUSH
15331: LD_INT 13
15333: PUSH
15334: LD_INT 14
15336: PUSH
15337: LD_INT 15
15339: PUSH
15340: LD_INT 16
15342: PUSH
15343: LD_INT 17
15345: PUSH
15346: LD_INT 18
15348: PUSH
15349: LD_INT 19
15351: PUSH
15352: LD_INT 20
15354: PUSH
15355: LD_INT 21
15357: PUSH
15358: LD_INT 22
15360: PUSH
15361: LD_INT 23
15363: PUSH
15364: LD_INT 24
15366: PUSH
15367: LD_INT 25
15369: PUSH
15370: LD_INT 26
15372: PUSH
15373: LD_INT 27
15375: PUSH
15376: LD_INT 28
15378: PUSH
15379: LD_INT 29
15381: PUSH
15382: LD_INT 30
15384: PUSH
15385: LD_INT 31
15387: PUSH
15388: LD_INT 32
15390: PUSH
15391: LD_INT 33
15393: PUSH
15394: LD_INT 34
15396: PUSH
15397: LD_INT 35
15399: PUSH
15400: LD_INT 36
15402: PUSH
15403: EMPTY
15404: LIST
15405: LIST
15406: LIST
15407: LIST
15408: LIST
15409: LIST
15410: LIST
15411: LIST
15412: LIST
15413: LIST
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: LIST
15419: LIST
15420: LIST
15421: LIST
15422: LIST
15423: LIST
15424: LIST
15425: LIST
15426: LIST
15427: LIST
15428: LIST
15429: LIST
15430: LIST
15431: LIST
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: LIST
15437: LIST
15438: LIST
15439: LIST
15440: PUSH
15441: LD_INT 101
15443: PUSH
15444: LD_INT 102
15446: PUSH
15447: LD_INT 103
15449: PUSH
15450: LD_INT 104
15452: PUSH
15453: LD_INT 105
15455: PUSH
15456: LD_INT 106
15458: PUSH
15459: LD_INT 107
15461: PUSH
15462: LD_INT 108
15464: PUSH
15465: LD_INT 109
15467: PUSH
15468: LD_INT 110
15470: PUSH
15471: LD_INT 111
15473: PUSH
15474: LD_INT 112
15476: PUSH
15477: LD_INT 113
15479: PUSH
15480: LD_INT 114
15482: PUSH
15483: LD_INT 115
15485: PUSH
15486: EMPTY
15487: LIST
15488: LIST
15489: LIST
15490: LIST
15491: LIST
15492: LIST
15493: LIST
15494: LIST
15495: LIST
15496: LIST
15497: LIST
15498: LIST
15499: LIST
15500: LIST
15501: LIST
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: ST_TO_ADDR
// if result then
15507: LD_VAR 0 1
15511: IFFALSE 15800
// begin normal :=  ;
15513: LD_ADDR_VAR 0 3
15517: PUSH
15518: LD_STRING 
15520: ST_TO_ADDR
// hardcore :=  ;
15521: LD_ADDR_VAR 0 4
15525: PUSH
15526: LD_STRING 
15528: ST_TO_ADDR
// for i = 1 to normalCounter do
15529: LD_ADDR_VAR 0 5
15533: PUSH
15534: DOUBLE
15535: LD_INT 1
15537: DEC
15538: ST_TO_ADDR
15539: LD_EXP 37
15543: PUSH
15544: FOR_TO
15545: IFFALSE 15646
// begin tmp := 0 ;
15547: LD_ADDR_VAR 0 2
15551: PUSH
15552: LD_STRING 0
15554: ST_TO_ADDR
// if result [ 1 ] then
15555: LD_VAR 0 1
15559: PUSH
15560: LD_INT 1
15562: ARRAY
15563: IFFALSE 15628
// if result [ 1 ] [ 1 ] = i then
15565: LD_VAR 0 1
15569: PUSH
15570: LD_INT 1
15572: ARRAY
15573: PUSH
15574: LD_INT 1
15576: ARRAY
15577: PUSH
15578: LD_VAR 0 5
15582: EQUAL
15583: IFFALSE 15628
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15585: LD_ADDR_VAR 0 1
15589: PUSH
15590: LD_VAR 0 1
15594: PPUSH
15595: LD_INT 1
15597: PPUSH
15598: LD_VAR 0 1
15602: PUSH
15603: LD_INT 1
15605: ARRAY
15606: PPUSH
15607: LD_INT 1
15609: PPUSH
15610: CALL_OW 3
15614: PPUSH
15615: CALL_OW 1
15619: ST_TO_ADDR
// tmp := 1 ;
15620: LD_ADDR_VAR 0 2
15624: PUSH
15625: LD_STRING 1
15627: ST_TO_ADDR
// end ; normal := normal & tmp ;
15628: LD_ADDR_VAR 0 3
15632: PUSH
15633: LD_VAR 0 3
15637: PUSH
15638: LD_VAR 0 2
15642: STR
15643: ST_TO_ADDR
// end ;
15644: GO 15544
15646: POP
15647: POP
// for i = 1 to hardcoreCounter do
15648: LD_ADDR_VAR 0 5
15652: PUSH
15653: DOUBLE
15654: LD_INT 1
15656: DEC
15657: ST_TO_ADDR
15658: LD_EXP 38
15662: PUSH
15663: FOR_TO
15664: IFFALSE 15769
// begin tmp := 0 ;
15666: LD_ADDR_VAR 0 2
15670: PUSH
15671: LD_STRING 0
15673: ST_TO_ADDR
// if result [ 2 ] then
15674: LD_VAR 0 1
15678: PUSH
15679: LD_INT 2
15681: ARRAY
15682: IFFALSE 15751
// if result [ 2 ] [ 1 ] = 100 + i then
15684: LD_VAR 0 1
15688: PUSH
15689: LD_INT 2
15691: ARRAY
15692: PUSH
15693: LD_INT 1
15695: ARRAY
15696: PUSH
15697: LD_INT 100
15699: PUSH
15700: LD_VAR 0 5
15704: PLUS
15705: EQUAL
15706: IFFALSE 15751
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
15708: LD_ADDR_VAR 0 1
15712: PUSH
15713: LD_VAR 0 1
15717: PPUSH
15718: LD_INT 2
15720: PPUSH
15721: LD_VAR 0 1
15725: PUSH
15726: LD_INT 2
15728: ARRAY
15729: PPUSH
15730: LD_INT 1
15732: PPUSH
15733: CALL_OW 3
15737: PPUSH
15738: CALL_OW 1
15742: ST_TO_ADDR
// tmp := 1 ;
15743: LD_ADDR_VAR 0 2
15747: PUSH
15748: LD_STRING 1
15750: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
15751: LD_ADDR_VAR 0 4
15755: PUSH
15756: LD_VAR 0 4
15760: PUSH
15761: LD_VAR 0 2
15765: STR
15766: ST_TO_ADDR
// end ;
15767: GO 15663
15769: POP
15770: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
15771: LD_STRING getStreamItemsFromMission("
15773: PUSH
15774: LD_VAR 0 3
15778: STR
15779: PUSH
15780: LD_STRING ","
15782: STR
15783: PUSH
15784: LD_VAR 0 4
15788: STR
15789: PUSH
15790: LD_STRING ")
15792: STR
15793: PPUSH
15794: CALL_OW 559
// end else
15798: GO 15807
// ToLua ( getStreamItemsFromMission("","") ) ;
15800: LD_STRING getStreamItemsFromMission("","")
15802: PPUSH
15803: CALL_OW 559
// end ;
15807: LD_VAR 0 1
15811: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15812: LD_VAR 0 2
15816: PUSH
15817: LD_INT 100
15819: EQUAL
15820: IFFALSE 16769
// begin if not StreamModeActive then
15822: LD_EXP 36
15826: NOT
15827: IFFALSE 15837
// StreamModeActive := true ;
15829: LD_ADDR_EXP 36
15833: PUSH
15834: LD_INT 1
15836: ST_TO_ADDR
// if p3 = 0 then
15837: LD_VAR 0 3
15841: PUSH
15842: LD_INT 0
15844: EQUAL
15845: IFFALSE 15851
// InitStreamMode ;
15847: CALL 11890 0 0
// if p3 = 1 then
15851: LD_VAR 0 3
15855: PUSH
15856: LD_INT 1
15858: EQUAL
15859: IFFALSE 15869
// sRocket := true ;
15861: LD_ADDR_EXP 41
15865: PUSH
15866: LD_INT 1
15868: ST_TO_ADDR
// if p3 = 2 then
15869: LD_VAR 0 3
15873: PUSH
15874: LD_INT 2
15876: EQUAL
15877: IFFALSE 15887
// sSpeed := true ;
15879: LD_ADDR_EXP 40
15883: PUSH
15884: LD_INT 1
15886: ST_TO_ADDR
// if p3 = 3 then
15887: LD_VAR 0 3
15891: PUSH
15892: LD_INT 3
15894: EQUAL
15895: IFFALSE 15905
// sEngine := true ;
15897: LD_ADDR_EXP 42
15901: PUSH
15902: LD_INT 1
15904: ST_TO_ADDR
// if p3 = 4 then
15905: LD_VAR 0 3
15909: PUSH
15910: LD_INT 4
15912: EQUAL
15913: IFFALSE 15923
// sSpec := true ;
15915: LD_ADDR_EXP 39
15919: PUSH
15920: LD_INT 1
15922: ST_TO_ADDR
// if p3 = 5 then
15923: LD_VAR 0 3
15927: PUSH
15928: LD_INT 5
15930: EQUAL
15931: IFFALSE 15941
// sLevel := true ;
15933: LD_ADDR_EXP 43
15937: PUSH
15938: LD_INT 1
15940: ST_TO_ADDR
// if p3 = 6 then
15941: LD_VAR 0 3
15945: PUSH
15946: LD_INT 6
15948: EQUAL
15949: IFFALSE 15959
// sArmoury := true ;
15951: LD_ADDR_EXP 44
15955: PUSH
15956: LD_INT 1
15958: ST_TO_ADDR
// if p3 = 7 then
15959: LD_VAR 0 3
15963: PUSH
15964: LD_INT 7
15966: EQUAL
15967: IFFALSE 15977
// sRadar := true ;
15969: LD_ADDR_EXP 45
15973: PUSH
15974: LD_INT 1
15976: ST_TO_ADDR
// if p3 = 8 then
15977: LD_VAR 0 3
15981: PUSH
15982: LD_INT 8
15984: EQUAL
15985: IFFALSE 15995
// sBunker := true ;
15987: LD_ADDR_EXP 46
15991: PUSH
15992: LD_INT 1
15994: ST_TO_ADDR
// if p3 = 9 then
15995: LD_VAR 0 3
15999: PUSH
16000: LD_INT 9
16002: EQUAL
16003: IFFALSE 16013
// sHack := true ;
16005: LD_ADDR_EXP 47
16009: PUSH
16010: LD_INT 1
16012: ST_TO_ADDR
// if p3 = 10 then
16013: LD_VAR 0 3
16017: PUSH
16018: LD_INT 10
16020: EQUAL
16021: IFFALSE 16031
// sFire := true ;
16023: LD_ADDR_EXP 48
16027: PUSH
16028: LD_INT 1
16030: ST_TO_ADDR
// if p3 = 11 then
16031: LD_VAR 0 3
16035: PUSH
16036: LD_INT 11
16038: EQUAL
16039: IFFALSE 16049
// sRefresh := true ;
16041: LD_ADDR_EXP 49
16045: PUSH
16046: LD_INT 1
16048: ST_TO_ADDR
// if p3 = 12 then
16049: LD_VAR 0 3
16053: PUSH
16054: LD_INT 12
16056: EQUAL
16057: IFFALSE 16067
// sExp := true ;
16059: LD_ADDR_EXP 50
16063: PUSH
16064: LD_INT 1
16066: ST_TO_ADDR
// if p3 = 13 then
16067: LD_VAR 0 3
16071: PUSH
16072: LD_INT 13
16074: EQUAL
16075: IFFALSE 16085
// sDepot := true ;
16077: LD_ADDR_EXP 51
16081: PUSH
16082: LD_INT 1
16084: ST_TO_ADDR
// if p3 = 14 then
16085: LD_VAR 0 3
16089: PUSH
16090: LD_INT 14
16092: EQUAL
16093: IFFALSE 16103
// sFlag := true ;
16095: LD_ADDR_EXP 52
16099: PUSH
16100: LD_INT 1
16102: ST_TO_ADDR
// if p3 = 15 then
16103: LD_VAR 0 3
16107: PUSH
16108: LD_INT 15
16110: EQUAL
16111: IFFALSE 16121
// sKamikadze := true ;
16113: LD_ADDR_EXP 60
16117: PUSH
16118: LD_INT 1
16120: ST_TO_ADDR
// if p3 = 16 then
16121: LD_VAR 0 3
16125: PUSH
16126: LD_INT 16
16128: EQUAL
16129: IFFALSE 16139
// sTroll := true ;
16131: LD_ADDR_EXP 61
16135: PUSH
16136: LD_INT 1
16138: ST_TO_ADDR
// if p3 = 17 then
16139: LD_VAR 0 3
16143: PUSH
16144: LD_INT 17
16146: EQUAL
16147: IFFALSE 16157
// sSlow := true ;
16149: LD_ADDR_EXP 62
16153: PUSH
16154: LD_INT 1
16156: ST_TO_ADDR
// if p3 = 18 then
16157: LD_VAR 0 3
16161: PUSH
16162: LD_INT 18
16164: EQUAL
16165: IFFALSE 16175
// sLack := true ;
16167: LD_ADDR_EXP 63
16171: PUSH
16172: LD_INT 1
16174: ST_TO_ADDR
// if p3 = 19 then
16175: LD_VAR 0 3
16179: PUSH
16180: LD_INT 19
16182: EQUAL
16183: IFFALSE 16193
// sTank := true ;
16185: LD_ADDR_EXP 65
16189: PUSH
16190: LD_INT 1
16192: ST_TO_ADDR
// if p3 = 20 then
16193: LD_VAR 0 3
16197: PUSH
16198: LD_INT 20
16200: EQUAL
16201: IFFALSE 16211
// sRemote := true ;
16203: LD_ADDR_EXP 66
16207: PUSH
16208: LD_INT 1
16210: ST_TO_ADDR
// if p3 = 21 then
16211: LD_VAR 0 3
16215: PUSH
16216: LD_INT 21
16218: EQUAL
16219: IFFALSE 16229
// sPowell := true ;
16221: LD_ADDR_EXP 67
16225: PUSH
16226: LD_INT 1
16228: ST_TO_ADDR
// if p3 = 22 then
16229: LD_VAR 0 3
16233: PUSH
16234: LD_INT 22
16236: EQUAL
16237: IFFALSE 16247
// sTeleport := true ;
16239: LD_ADDR_EXP 70
16243: PUSH
16244: LD_INT 1
16246: ST_TO_ADDR
// if p3 = 23 then
16247: LD_VAR 0 3
16251: PUSH
16252: LD_INT 23
16254: EQUAL
16255: IFFALSE 16265
// sOilTower := true ;
16257: LD_ADDR_EXP 72
16261: PUSH
16262: LD_INT 1
16264: ST_TO_ADDR
// if p3 = 24 then
16265: LD_VAR 0 3
16269: PUSH
16270: LD_INT 24
16272: EQUAL
16273: IFFALSE 16283
// sShovel := true ;
16275: LD_ADDR_EXP 73
16279: PUSH
16280: LD_INT 1
16282: ST_TO_ADDR
// if p3 = 25 then
16283: LD_VAR 0 3
16287: PUSH
16288: LD_INT 25
16290: EQUAL
16291: IFFALSE 16301
// sSheik := true ;
16293: LD_ADDR_EXP 74
16297: PUSH
16298: LD_INT 1
16300: ST_TO_ADDR
// if p3 = 26 then
16301: LD_VAR 0 3
16305: PUSH
16306: LD_INT 26
16308: EQUAL
16309: IFFALSE 16319
// sEarthquake := true ;
16311: LD_ADDR_EXP 76
16315: PUSH
16316: LD_INT 1
16318: ST_TO_ADDR
// if p3 = 27 then
16319: LD_VAR 0 3
16323: PUSH
16324: LD_INT 27
16326: EQUAL
16327: IFFALSE 16337
// sAI := true ;
16329: LD_ADDR_EXP 77
16333: PUSH
16334: LD_INT 1
16336: ST_TO_ADDR
// if p3 = 28 then
16337: LD_VAR 0 3
16341: PUSH
16342: LD_INT 28
16344: EQUAL
16345: IFFALSE 16355
// sCargo := true ;
16347: LD_ADDR_EXP 80
16351: PUSH
16352: LD_INT 1
16354: ST_TO_ADDR
// if p3 = 29 then
16355: LD_VAR 0 3
16359: PUSH
16360: LD_INT 29
16362: EQUAL
16363: IFFALSE 16373
// sDLaser := true ;
16365: LD_ADDR_EXP 81
16369: PUSH
16370: LD_INT 1
16372: ST_TO_ADDR
// if p3 = 30 then
16373: LD_VAR 0 3
16377: PUSH
16378: LD_INT 30
16380: EQUAL
16381: IFFALSE 16391
// sExchange := true ;
16383: LD_ADDR_EXP 82
16387: PUSH
16388: LD_INT 1
16390: ST_TO_ADDR
// if p3 = 31 then
16391: LD_VAR 0 3
16395: PUSH
16396: LD_INT 31
16398: EQUAL
16399: IFFALSE 16409
// sFac := true ;
16401: LD_ADDR_EXP 83
16405: PUSH
16406: LD_INT 1
16408: ST_TO_ADDR
// if p3 = 32 then
16409: LD_VAR 0 3
16413: PUSH
16414: LD_INT 32
16416: EQUAL
16417: IFFALSE 16427
// sPower := true ;
16419: LD_ADDR_EXP 84
16423: PUSH
16424: LD_INT 1
16426: ST_TO_ADDR
// if p3 = 33 then
16427: LD_VAR 0 3
16431: PUSH
16432: LD_INT 33
16434: EQUAL
16435: IFFALSE 16445
// sRandom := true ;
16437: LD_ADDR_EXP 85
16441: PUSH
16442: LD_INT 1
16444: ST_TO_ADDR
// if p3 = 34 then
16445: LD_VAR 0 3
16449: PUSH
16450: LD_INT 34
16452: EQUAL
16453: IFFALSE 16463
// sShield := true ;
16455: LD_ADDR_EXP 86
16459: PUSH
16460: LD_INT 1
16462: ST_TO_ADDR
// if p3 = 35 then
16463: LD_VAR 0 3
16467: PUSH
16468: LD_INT 35
16470: EQUAL
16471: IFFALSE 16481
// sTime := true ;
16473: LD_ADDR_EXP 87
16477: PUSH
16478: LD_INT 1
16480: ST_TO_ADDR
// if p3 = 36 then
16481: LD_VAR 0 3
16485: PUSH
16486: LD_INT 36
16488: EQUAL
16489: IFFALSE 16499
// sTools := true ;
16491: LD_ADDR_EXP 88
16495: PUSH
16496: LD_INT 1
16498: ST_TO_ADDR
// if p3 = 101 then
16499: LD_VAR 0 3
16503: PUSH
16504: LD_INT 101
16506: EQUAL
16507: IFFALSE 16517
// sSold := true ;
16509: LD_ADDR_EXP 53
16513: PUSH
16514: LD_INT 1
16516: ST_TO_ADDR
// if p3 = 102 then
16517: LD_VAR 0 3
16521: PUSH
16522: LD_INT 102
16524: EQUAL
16525: IFFALSE 16535
// sDiff := true ;
16527: LD_ADDR_EXP 54
16531: PUSH
16532: LD_INT 1
16534: ST_TO_ADDR
// if p3 = 103 then
16535: LD_VAR 0 3
16539: PUSH
16540: LD_INT 103
16542: EQUAL
16543: IFFALSE 16553
// sFog := true ;
16545: LD_ADDR_EXP 57
16549: PUSH
16550: LD_INT 1
16552: ST_TO_ADDR
// if p3 = 104 then
16553: LD_VAR 0 3
16557: PUSH
16558: LD_INT 104
16560: EQUAL
16561: IFFALSE 16571
// sReset := true ;
16563: LD_ADDR_EXP 58
16567: PUSH
16568: LD_INT 1
16570: ST_TO_ADDR
// if p3 = 105 then
16571: LD_VAR 0 3
16575: PUSH
16576: LD_INT 105
16578: EQUAL
16579: IFFALSE 16589
// sSun := true ;
16581: LD_ADDR_EXP 59
16585: PUSH
16586: LD_INT 1
16588: ST_TO_ADDR
// if p3 = 106 then
16589: LD_VAR 0 3
16593: PUSH
16594: LD_INT 106
16596: EQUAL
16597: IFFALSE 16607
// sTiger := true ;
16599: LD_ADDR_EXP 55
16603: PUSH
16604: LD_INT 1
16606: ST_TO_ADDR
// if p3 = 107 then
16607: LD_VAR 0 3
16611: PUSH
16612: LD_INT 107
16614: EQUAL
16615: IFFALSE 16625
// sBomb := true ;
16617: LD_ADDR_EXP 56
16621: PUSH
16622: LD_INT 1
16624: ST_TO_ADDR
// if p3 = 108 then
16625: LD_VAR 0 3
16629: PUSH
16630: LD_INT 108
16632: EQUAL
16633: IFFALSE 16643
// sWound := true ;
16635: LD_ADDR_EXP 64
16639: PUSH
16640: LD_INT 1
16642: ST_TO_ADDR
// if p3 = 109 then
16643: LD_VAR 0 3
16647: PUSH
16648: LD_INT 109
16650: EQUAL
16651: IFFALSE 16661
// sBetray := true ;
16653: LD_ADDR_EXP 68
16657: PUSH
16658: LD_INT 1
16660: ST_TO_ADDR
// if p3 = 110 then
16661: LD_VAR 0 3
16665: PUSH
16666: LD_INT 110
16668: EQUAL
16669: IFFALSE 16679
// sContamin := true ;
16671: LD_ADDR_EXP 69
16675: PUSH
16676: LD_INT 1
16678: ST_TO_ADDR
// if p3 = 111 then
16679: LD_VAR 0 3
16683: PUSH
16684: LD_INT 111
16686: EQUAL
16687: IFFALSE 16697
// sOil := true ;
16689: LD_ADDR_EXP 71
16693: PUSH
16694: LD_INT 1
16696: ST_TO_ADDR
// if p3 = 112 then
16697: LD_VAR 0 3
16701: PUSH
16702: LD_INT 112
16704: EQUAL
16705: IFFALSE 16715
// sStu := true ;
16707: LD_ADDR_EXP 75
16711: PUSH
16712: LD_INT 1
16714: ST_TO_ADDR
// if p3 = 113 then
16715: LD_VAR 0 3
16719: PUSH
16720: LD_INT 113
16722: EQUAL
16723: IFFALSE 16733
// sBazooka := true ;
16725: LD_ADDR_EXP 78
16729: PUSH
16730: LD_INT 1
16732: ST_TO_ADDR
// if p3 = 114 then
16733: LD_VAR 0 3
16737: PUSH
16738: LD_INT 114
16740: EQUAL
16741: IFFALSE 16751
// sMortar := true ;
16743: LD_ADDR_EXP 79
16747: PUSH
16748: LD_INT 1
16750: ST_TO_ADDR
// if p3 = 115 then
16751: LD_VAR 0 3
16755: PUSH
16756: LD_INT 115
16758: EQUAL
16759: IFFALSE 16769
// sRanger := true ;
16761: LD_ADDR_EXP 89
16765: PUSH
16766: LD_INT 1
16768: ST_TO_ADDR
// end ; end ;
16769: PPOPN 6
16771: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
16772: LD_EXP 36
16776: PUSH
16777: LD_EXP 41
16781: AND
16782: IFFALSE 16906
16784: GO 16786
16786: DISABLE
16787: LD_INT 0
16789: PPUSH
16790: PPUSH
// begin enable ;
16791: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
16792: LD_ADDR_VAR 0 2
16796: PUSH
16797: LD_INT 22
16799: PUSH
16800: LD_OWVAR 2
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: LD_INT 2
16811: PUSH
16812: LD_INT 34
16814: PUSH
16815: LD_INT 7
16817: PUSH
16818: EMPTY
16819: LIST
16820: LIST
16821: PUSH
16822: LD_INT 34
16824: PUSH
16825: LD_INT 45
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 34
16834: PUSH
16835: LD_INT 28
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: LD_INT 34
16844: PUSH
16845: LD_INT 47
16847: PUSH
16848: EMPTY
16849: LIST
16850: LIST
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: LIST
16856: LIST
16857: LIST
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL_OW 69
16867: ST_TO_ADDR
// if not tmp then
16868: LD_VAR 0 2
16872: NOT
16873: IFFALSE 16877
// exit ;
16875: GO 16906
// for i in tmp do
16877: LD_ADDR_VAR 0 1
16881: PUSH
16882: LD_VAR 0 2
16886: PUSH
16887: FOR_IN
16888: IFFALSE 16904
// begin SetLives ( i , 0 ) ;
16890: LD_VAR 0 1
16894: PPUSH
16895: LD_INT 0
16897: PPUSH
16898: CALL_OW 234
// end ;
16902: GO 16887
16904: POP
16905: POP
// end ;
16906: PPOPN 2
16908: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
16909: LD_EXP 36
16913: PUSH
16914: LD_EXP 42
16918: AND
16919: IFFALSE 17003
16921: GO 16923
16923: DISABLE
16924: LD_INT 0
16926: PPUSH
16927: PPUSH
// begin enable ;
16928: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
16929: LD_ADDR_VAR 0 2
16933: PUSH
16934: LD_INT 22
16936: PUSH
16937: LD_OWVAR 2
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: PUSH
16946: LD_INT 32
16948: PUSH
16949: LD_INT 3
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: PPUSH
16960: CALL_OW 69
16964: ST_TO_ADDR
// if not tmp then
16965: LD_VAR 0 2
16969: NOT
16970: IFFALSE 16974
// exit ;
16972: GO 17003
// for i in tmp do
16974: LD_ADDR_VAR 0 1
16978: PUSH
16979: LD_VAR 0 2
16983: PUSH
16984: FOR_IN
16985: IFFALSE 17001
// begin SetLives ( i , 0 ) ;
16987: LD_VAR 0 1
16991: PPUSH
16992: LD_INT 0
16994: PPUSH
16995: CALL_OW 234
// end ;
16999: GO 16984
17001: POP
17002: POP
// end ;
17003: PPOPN 2
17005: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
17006: LD_EXP 36
17010: PUSH
17011: LD_EXP 39
17015: AND
17016: IFFALSE 17109
17018: GO 17020
17020: DISABLE
17021: LD_INT 0
17023: PPUSH
// begin enable ;
17024: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
17025: LD_ADDR_VAR 0 1
17029: PUSH
17030: LD_INT 22
17032: PUSH
17033: LD_OWVAR 2
17037: PUSH
17038: EMPTY
17039: LIST
17040: LIST
17041: PUSH
17042: LD_INT 2
17044: PUSH
17045: LD_INT 25
17047: PUSH
17048: LD_INT 5
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: PUSH
17055: LD_INT 25
17057: PUSH
17058: LD_INT 9
17060: PUSH
17061: EMPTY
17062: LIST
17063: LIST
17064: PUSH
17065: LD_INT 25
17067: PUSH
17068: LD_INT 8
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PPUSH
17085: CALL_OW 69
17089: PUSH
17090: FOR_IN
17091: IFFALSE 17107
// begin SetClass ( i , 1 ) ;
17093: LD_VAR 0 1
17097: PPUSH
17098: LD_INT 1
17100: PPUSH
17101: CALL_OW 336
// end ;
17105: GO 17090
17107: POP
17108: POP
// end ;
17109: PPOPN 1
17111: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
17112: LD_EXP 36
17116: PUSH
17117: LD_EXP 40
17121: AND
17122: PUSH
17123: LD_OWVAR 65
17127: PUSH
17128: LD_INT 7
17130: LESS
17131: AND
17132: IFFALSE 17146
17134: GO 17136
17136: DISABLE
// begin enable ;
17137: ENABLE
// game_speed := 7 ;
17138: LD_ADDR_OWVAR 65
17142: PUSH
17143: LD_INT 7
17145: ST_TO_ADDR
// end ;
17146: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
17147: LD_EXP 36
17151: PUSH
17152: LD_EXP 43
17156: AND
17157: IFFALSE 17359
17159: GO 17161
17161: DISABLE
17162: LD_INT 0
17164: PPUSH
17165: PPUSH
17166: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
17167: LD_ADDR_VAR 0 3
17171: PUSH
17172: LD_INT 81
17174: PUSH
17175: LD_OWVAR 2
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 21
17186: PUSH
17187: LD_INT 1
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: PUSH
17194: EMPTY
17195: LIST
17196: LIST
17197: PPUSH
17198: CALL_OW 69
17202: ST_TO_ADDR
// if not tmp then
17203: LD_VAR 0 3
17207: NOT
17208: IFFALSE 17212
// exit ;
17210: GO 17359
// if tmp > 5 then
17212: LD_VAR 0 3
17216: PUSH
17217: LD_INT 5
17219: GREATER
17220: IFFALSE 17232
// k := 5 else
17222: LD_ADDR_VAR 0 2
17226: PUSH
17227: LD_INT 5
17229: ST_TO_ADDR
17230: GO 17242
// k := tmp ;
17232: LD_ADDR_VAR 0 2
17236: PUSH
17237: LD_VAR 0 3
17241: ST_TO_ADDR
// for i := 1 to k do
17242: LD_ADDR_VAR 0 1
17246: PUSH
17247: DOUBLE
17248: LD_INT 1
17250: DEC
17251: ST_TO_ADDR
17252: LD_VAR 0 2
17256: PUSH
17257: FOR_TO
17258: IFFALSE 17357
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
17260: LD_VAR 0 3
17264: PUSH
17265: LD_VAR 0 1
17269: ARRAY
17270: PPUSH
17271: LD_VAR 0 1
17275: PUSH
17276: LD_INT 4
17278: MOD
17279: PUSH
17280: LD_INT 1
17282: PLUS
17283: PPUSH
17284: CALL_OW 259
17288: PUSH
17289: LD_INT 10
17291: LESS
17292: IFFALSE 17355
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
17294: LD_VAR 0 3
17298: PUSH
17299: LD_VAR 0 1
17303: ARRAY
17304: PPUSH
17305: LD_VAR 0 1
17309: PUSH
17310: LD_INT 4
17312: MOD
17313: PUSH
17314: LD_INT 1
17316: PLUS
17317: PPUSH
17318: LD_VAR 0 3
17322: PUSH
17323: LD_VAR 0 1
17327: ARRAY
17328: PPUSH
17329: LD_VAR 0 1
17333: PUSH
17334: LD_INT 4
17336: MOD
17337: PUSH
17338: LD_INT 1
17340: PLUS
17341: PPUSH
17342: CALL_OW 259
17346: PUSH
17347: LD_INT 1
17349: PLUS
17350: PPUSH
17351: CALL_OW 237
17355: GO 17257
17357: POP
17358: POP
// end ;
17359: PPOPN 3
17361: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
17362: LD_EXP 36
17366: PUSH
17367: LD_EXP 44
17371: AND
17372: IFFALSE 17392
17374: GO 17376
17376: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
17377: LD_INT 4
17379: PPUSH
17380: LD_OWVAR 2
17384: PPUSH
17385: LD_INT 0
17387: PPUSH
17388: CALL_OW 324
17392: END
// every 0 0$1 trigger StreamModeActive and sShovel do
17393: LD_EXP 36
17397: PUSH
17398: LD_EXP 73
17402: AND
17403: IFFALSE 17423
17405: GO 17407
17407: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
17408: LD_INT 19
17410: PPUSH
17411: LD_OWVAR 2
17415: PPUSH
17416: LD_INT 0
17418: PPUSH
17419: CALL_OW 324
17423: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
17424: LD_EXP 36
17428: PUSH
17429: LD_EXP 45
17433: AND
17434: IFFALSE 17536
17436: GO 17438
17438: DISABLE
17439: LD_INT 0
17441: PPUSH
17442: PPUSH
// begin enable ;
17443: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
17444: LD_ADDR_VAR 0 2
17448: PUSH
17449: LD_INT 22
17451: PUSH
17452: LD_OWVAR 2
17456: PUSH
17457: EMPTY
17458: LIST
17459: LIST
17460: PUSH
17461: LD_INT 2
17463: PUSH
17464: LD_INT 34
17466: PUSH
17467: LD_INT 11
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: PUSH
17474: LD_INT 34
17476: PUSH
17477: LD_INT 30
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: LIST
17488: PUSH
17489: EMPTY
17490: LIST
17491: LIST
17492: PPUSH
17493: CALL_OW 69
17497: ST_TO_ADDR
// if not tmp then
17498: LD_VAR 0 2
17502: NOT
17503: IFFALSE 17507
// exit ;
17505: GO 17536
// for i in tmp do
17507: LD_ADDR_VAR 0 1
17511: PUSH
17512: LD_VAR 0 2
17516: PUSH
17517: FOR_IN
17518: IFFALSE 17534
// begin SetLives ( i , 0 ) ;
17520: LD_VAR 0 1
17524: PPUSH
17525: LD_INT 0
17527: PPUSH
17528: CALL_OW 234
// end ;
17532: GO 17517
17534: POP
17535: POP
// end ;
17536: PPOPN 2
17538: END
// every 0 0$1 trigger StreamModeActive and sBunker do
17539: LD_EXP 36
17543: PUSH
17544: LD_EXP 46
17548: AND
17549: IFFALSE 17569
17551: GO 17553
17553: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
17554: LD_INT 32
17556: PPUSH
17557: LD_OWVAR 2
17561: PPUSH
17562: LD_INT 0
17564: PPUSH
17565: CALL_OW 324
17569: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
17570: LD_EXP 36
17574: PUSH
17575: LD_EXP 47
17579: AND
17580: IFFALSE 17761
17582: GO 17584
17584: DISABLE
17585: LD_INT 0
17587: PPUSH
17588: PPUSH
17589: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17590: LD_ADDR_VAR 0 2
17594: PUSH
17595: LD_INT 22
17597: PUSH
17598: LD_OWVAR 2
17602: PUSH
17603: EMPTY
17604: LIST
17605: LIST
17606: PUSH
17607: LD_INT 33
17609: PUSH
17610: LD_INT 3
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PUSH
17617: EMPTY
17618: LIST
17619: LIST
17620: PPUSH
17621: CALL_OW 69
17625: ST_TO_ADDR
// if not tmp then
17626: LD_VAR 0 2
17630: NOT
17631: IFFALSE 17635
// exit ;
17633: GO 17761
// side := 0 ;
17635: LD_ADDR_VAR 0 3
17639: PUSH
17640: LD_INT 0
17642: ST_TO_ADDR
// for i := 1 to 8 do
17643: LD_ADDR_VAR 0 1
17647: PUSH
17648: DOUBLE
17649: LD_INT 1
17651: DEC
17652: ST_TO_ADDR
17653: LD_INT 8
17655: PUSH
17656: FOR_TO
17657: IFFALSE 17705
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
17659: LD_OWVAR 2
17663: PUSH
17664: LD_VAR 0 1
17668: NONEQUAL
17669: PUSH
17670: LD_OWVAR 2
17674: PPUSH
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL_OW 81
17684: PUSH
17685: LD_INT 2
17687: EQUAL
17688: AND
17689: IFFALSE 17703
// begin side := i ;
17691: LD_ADDR_VAR 0 3
17695: PUSH
17696: LD_VAR 0 1
17700: ST_TO_ADDR
// break ;
17701: GO 17705
// end ;
17703: GO 17656
17705: POP
17706: POP
// if not side then
17707: LD_VAR 0 3
17711: NOT
17712: IFFALSE 17716
// exit ;
17714: GO 17761
// for i := 1 to tmp do
17716: LD_ADDR_VAR 0 1
17720: PUSH
17721: DOUBLE
17722: LD_INT 1
17724: DEC
17725: ST_TO_ADDR
17726: LD_VAR 0 2
17730: PUSH
17731: FOR_TO
17732: IFFALSE 17759
// if Prob ( 60 ) then
17734: LD_INT 60
17736: PPUSH
17737: CALL_OW 13
17741: IFFALSE 17757
// SetSide ( i , side ) ;
17743: LD_VAR 0 1
17747: PPUSH
17748: LD_VAR 0 3
17752: PPUSH
17753: CALL_OW 235
17757: GO 17731
17759: POP
17760: POP
// end ;
17761: PPOPN 3
17763: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
17764: LD_EXP 36
17768: PUSH
17769: LD_EXP 49
17773: AND
17774: IFFALSE 17893
17776: GO 17778
17778: DISABLE
17779: LD_INT 0
17781: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
17782: LD_ADDR_VAR 0 1
17786: PUSH
17787: LD_INT 22
17789: PUSH
17790: LD_OWVAR 2
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: PUSH
17799: LD_INT 21
17801: PUSH
17802: LD_INT 1
17804: PUSH
17805: EMPTY
17806: LIST
17807: LIST
17808: PUSH
17809: LD_INT 3
17811: PUSH
17812: LD_INT 23
17814: PUSH
17815: LD_INT 0
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: PUSH
17822: EMPTY
17823: LIST
17824: LIST
17825: PUSH
17826: EMPTY
17827: LIST
17828: LIST
17829: LIST
17830: PPUSH
17831: CALL_OW 69
17835: PUSH
17836: FOR_IN
17837: IFFALSE 17891
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17839: LD_VAR 0 1
17843: PPUSH
17844: CALL_OW 257
17848: PUSH
17849: LD_INT 1
17851: PUSH
17852: LD_INT 2
17854: PUSH
17855: LD_INT 3
17857: PUSH
17858: LD_INT 4
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: LIST
17866: IN
17867: IFFALSE 17889
// SetClass ( un , rand ( 1 , 4 ) ) ;
17869: LD_VAR 0 1
17873: PPUSH
17874: LD_INT 1
17876: PPUSH
17877: LD_INT 4
17879: PPUSH
17880: CALL_OW 12
17884: PPUSH
17885: CALL_OW 336
17889: GO 17836
17891: POP
17892: POP
// end ;
17893: PPOPN 1
17895: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
17896: LD_EXP 36
17900: PUSH
17901: LD_EXP 48
17905: AND
17906: IFFALSE 17985
17908: GO 17910
17910: DISABLE
17911: LD_INT 0
17913: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17914: LD_ADDR_VAR 0 1
17918: PUSH
17919: LD_INT 22
17921: PUSH
17922: LD_OWVAR 2
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: PUSH
17931: LD_INT 21
17933: PUSH
17934: LD_INT 3
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: PPUSH
17945: CALL_OW 69
17949: ST_TO_ADDR
// if not tmp then
17950: LD_VAR 0 1
17954: NOT
17955: IFFALSE 17959
// exit ;
17957: GO 17985
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
17959: LD_VAR 0 1
17963: PUSH
17964: LD_INT 1
17966: PPUSH
17967: LD_VAR 0 1
17971: PPUSH
17972: CALL_OW 12
17976: ARRAY
17977: PPUSH
17978: LD_INT 100
17980: PPUSH
17981: CALL_OW 234
// end ;
17985: PPOPN 1
17987: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
17988: LD_EXP 36
17992: PUSH
17993: LD_EXP 50
17997: AND
17998: IFFALSE 18096
18000: GO 18002
18002: DISABLE
18003: LD_INT 0
18005: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18006: LD_ADDR_VAR 0 1
18010: PUSH
18011: LD_INT 22
18013: PUSH
18014: LD_OWVAR 2
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: PUSH
18023: LD_INT 21
18025: PUSH
18026: LD_INT 1
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: PUSH
18033: EMPTY
18034: LIST
18035: LIST
18036: PPUSH
18037: CALL_OW 69
18041: ST_TO_ADDR
// if not tmp then
18042: LD_VAR 0 1
18046: NOT
18047: IFFALSE 18051
// exit ;
18049: GO 18096
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
18051: LD_VAR 0 1
18055: PUSH
18056: LD_INT 1
18058: PPUSH
18059: LD_VAR 0 1
18063: PPUSH
18064: CALL_OW 12
18068: ARRAY
18069: PPUSH
18070: LD_INT 1
18072: PPUSH
18073: LD_INT 4
18075: PPUSH
18076: CALL_OW 12
18080: PPUSH
18081: LD_INT 3000
18083: PPUSH
18084: LD_INT 9000
18086: PPUSH
18087: CALL_OW 12
18091: PPUSH
18092: CALL_OW 492
// end ;
18096: PPOPN 1
18098: END
// every 0 0$1 trigger StreamModeActive and sDepot do
18099: LD_EXP 36
18103: PUSH
18104: LD_EXP 51
18108: AND
18109: IFFALSE 18129
18111: GO 18113
18113: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
18114: LD_INT 1
18116: PPUSH
18117: LD_OWVAR 2
18121: PPUSH
18122: LD_INT 0
18124: PPUSH
18125: CALL_OW 324
18129: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
18130: LD_EXP 36
18134: PUSH
18135: LD_EXP 52
18139: AND
18140: IFFALSE 18223
18142: GO 18144
18144: DISABLE
18145: LD_INT 0
18147: PPUSH
18148: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18149: LD_ADDR_VAR 0 2
18153: PUSH
18154: LD_INT 22
18156: PUSH
18157: LD_OWVAR 2
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: PUSH
18166: LD_INT 21
18168: PUSH
18169: LD_INT 3
18171: PUSH
18172: EMPTY
18173: LIST
18174: LIST
18175: PUSH
18176: EMPTY
18177: LIST
18178: LIST
18179: PPUSH
18180: CALL_OW 69
18184: ST_TO_ADDR
// if not tmp then
18185: LD_VAR 0 2
18189: NOT
18190: IFFALSE 18194
// exit ;
18192: GO 18223
// for i in tmp do
18194: LD_ADDR_VAR 0 1
18198: PUSH
18199: LD_VAR 0 2
18203: PUSH
18204: FOR_IN
18205: IFFALSE 18221
// SetBLevel ( i , 10 ) ;
18207: LD_VAR 0 1
18211: PPUSH
18212: LD_INT 10
18214: PPUSH
18215: CALL_OW 241
18219: GO 18204
18221: POP
18222: POP
// end ;
18223: PPOPN 2
18225: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
18226: LD_EXP 36
18230: PUSH
18231: LD_EXP 53
18235: AND
18236: IFFALSE 18347
18238: GO 18240
18240: DISABLE
18241: LD_INT 0
18243: PPUSH
18244: PPUSH
18245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18246: LD_ADDR_VAR 0 3
18250: PUSH
18251: LD_INT 22
18253: PUSH
18254: LD_OWVAR 2
18258: PUSH
18259: EMPTY
18260: LIST
18261: LIST
18262: PUSH
18263: LD_INT 25
18265: PUSH
18266: LD_INT 1
18268: PUSH
18269: EMPTY
18270: LIST
18271: LIST
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: PPUSH
18277: CALL_OW 69
18281: ST_TO_ADDR
// if not tmp then
18282: LD_VAR 0 3
18286: NOT
18287: IFFALSE 18291
// exit ;
18289: GO 18347
// un := tmp [ rand ( 1 , tmp ) ] ;
18291: LD_ADDR_VAR 0 2
18295: PUSH
18296: LD_VAR 0 3
18300: PUSH
18301: LD_INT 1
18303: PPUSH
18304: LD_VAR 0 3
18308: PPUSH
18309: CALL_OW 12
18313: ARRAY
18314: ST_TO_ADDR
// if Crawls ( un ) then
18315: LD_VAR 0 2
18319: PPUSH
18320: CALL_OW 318
18324: IFFALSE 18335
// ComWalk ( un ) ;
18326: LD_VAR 0 2
18330: PPUSH
18331: CALL_OW 138
// SetClass ( un , class_sniper ) ;
18335: LD_VAR 0 2
18339: PPUSH
18340: LD_INT 5
18342: PPUSH
18343: CALL_OW 336
// end ;
18347: PPOPN 3
18349: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
18350: LD_EXP 36
18354: PUSH
18355: LD_EXP 54
18359: AND
18360: PUSH
18361: LD_OWVAR 67
18365: PUSH
18366: LD_INT 3
18368: LESS
18369: AND
18370: IFFALSE 18389
18372: GO 18374
18374: DISABLE
// Difficulty := Difficulty + 1 ;
18375: LD_ADDR_OWVAR 67
18379: PUSH
18380: LD_OWVAR 67
18384: PUSH
18385: LD_INT 1
18387: PLUS
18388: ST_TO_ADDR
18389: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
18390: LD_EXP 36
18394: PUSH
18395: LD_EXP 55
18399: AND
18400: IFFALSE 18503
18402: GO 18404
18404: DISABLE
18405: LD_INT 0
18407: PPUSH
// begin for i := 1 to 5 do
18408: LD_ADDR_VAR 0 1
18412: PUSH
18413: DOUBLE
18414: LD_INT 1
18416: DEC
18417: ST_TO_ADDR
18418: LD_INT 5
18420: PUSH
18421: FOR_TO
18422: IFFALSE 18501
// begin uc_nation := nation_nature ;
18424: LD_ADDR_OWVAR 21
18428: PUSH
18429: LD_INT 0
18431: ST_TO_ADDR
// uc_side := 0 ;
18432: LD_ADDR_OWVAR 20
18436: PUSH
18437: LD_INT 0
18439: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18440: LD_ADDR_OWVAR 29
18444: PUSH
18445: LD_INT 12
18447: PUSH
18448: LD_INT 12
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: ST_TO_ADDR
// hc_agressivity := 20 ;
18455: LD_ADDR_OWVAR 35
18459: PUSH
18460: LD_INT 20
18462: ST_TO_ADDR
// hc_class := class_tiger ;
18463: LD_ADDR_OWVAR 28
18467: PUSH
18468: LD_INT 14
18470: ST_TO_ADDR
// hc_gallery :=  ;
18471: LD_ADDR_OWVAR 33
18475: PUSH
18476: LD_STRING 
18478: ST_TO_ADDR
// hc_name :=  ;
18479: LD_ADDR_OWVAR 26
18483: PUSH
18484: LD_STRING 
18486: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
18487: CALL_OW 44
18491: PPUSH
18492: LD_INT 0
18494: PPUSH
18495: CALL_OW 51
// end ;
18499: GO 18421
18501: POP
18502: POP
// end ;
18503: PPOPN 1
18505: END
// every 0 0$1 trigger StreamModeActive and sBomb do
18506: LD_EXP 36
18510: PUSH
18511: LD_EXP 56
18515: AND
18516: IFFALSE 18525
18518: GO 18520
18520: DISABLE
// StreamSibBomb ;
18521: CALL 18526 0 0
18525: END
// export function StreamSibBomb ; var i , x , y ; begin
18526: LD_INT 0
18528: PPUSH
18529: PPUSH
18530: PPUSH
18531: PPUSH
// result := false ;
18532: LD_ADDR_VAR 0 1
18536: PUSH
18537: LD_INT 0
18539: ST_TO_ADDR
// for i := 1 to 16 do
18540: LD_ADDR_VAR 0 2
18544: PUSH
18545: DOUBLE
18546: LD_INT 1
18548: DEC
18549: ST_TO_ADDR
18550: LD_INT 16
18552: PUSH
18553: FOR_TO
18554: IFFALSE 18753
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18556: LD_ADDR_VAR 0 3
18560: PUSH
18561: LD_INT 10
18563: PUSH
18564: LD_INT 20
18566: PUSH
18567: LD_INT 30
18569: PUSH
18570: LD_INT 40
18572: PUSH
18573: LD_INT 50
18575: PUSH
18576: LD_INT 60
18578: PUSH
18579: LD_INT 70
18581: PUSH
18582: LD_INT 80
18584: PUSH
18585: LD_INT 90
18587: PUSH
18588: LD_INT 100
18590: PUSH
18591: LD_INT 110
18593: PUSH
18594: LD_INT 120
18596: PUSH
18597: LD_INT 130
18599: PUSH
18600: LD_INT 140
18602: PUSH
18603: LD_INT 150
18605: PUSH
18606: EMPTY
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: LIST
18612: LIST
18613: LIST
18614: LIST
18615: LIST
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: LIST
18622: PUSH
18623: LD_INT 1
18625: PPUSH
18626: LD_INT 15
18628: PPUSH
18629: CALL_OW 12
18633: ARRAY
18634: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18635: LD_ADDR_VAR 0 4
18639: PUSH
18640: LD_INT 10
18642: PUSH
18643: LD_INT 20
18645: PUSH
18646: LD_INT 30
18648: PUSH
18649: LD_INT 40
18651: PUSH
18652: LD_INT 50
18654: PUSH
18655: LD_INT 60
18657: PUSH
18658: LD_INT 70
18660: PUSH
18661: LD_INT 80
18663: PUSH
18664: LD_INT 90
18666: PUSH
18667: LD_INT 100
18669: PUSH
18670: LD_INT 110
18672: PUSH
18673: LD_INT 120
18675: PUSH
18676: LD_INT 130
18678: PUSH
18679: LD_INT 140
18681: PUSH
18682: LD_INT 150
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: LIST
18700: LIST
18701: PUSH
18702: LD_INT 1
18704: PPUSH
18705: LD_INT 15
18707: PPUSH
18708: CALL_OW 12
18712: ARRAY
18713: ST_TO_ADDR
// if ValidHex ( x , y ) then
18714: LD_VAR 0 3
18718: PPUSH
18719: LD_VAR 0 4
18723: PPUSH
18724: CALL_OW 488
18728: IFFALSE 18751
// begin result := [ x , y ] ;
18730: LD_ADDR_VAR 0 1
18734: PUSH
18735: LD_VAR 0 3
18739: PUSH
18740: LD_VAR 0 4
18744: PUSH
18745: EMPTY
18746: LIST
18747: LIST
18748: ST_TO_ADDR
// break ;
18749: GO 18753
// end ; end ;
18751: GO 18553
18753: POP
18754: POP
// if result then
18755: LD_VAR 0 1
18759: IFFALSE 18819
// begin ToLua ( playSibBomb() ) ;
18761: LD_STRING playSibBomb()
18763: PPUSH
18764: CALL_OW 559
// wait ( 0 0$14 ) ;
18768: LD_INT 490
18770: PPUSH
18771: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
18775: LD_VAR 0 1
18779: PUSH
18780: LD_INT 1
18782: ARRAY
18783: PPUSH
18784: LD_VAR 0 1
18788: PUSH
18789: LD_INT 2
18791: ARRAY
18792: PPUSH
18793: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
18797: LD_VAR 0 1
18801: PUSH
18802: LD_INT 1
18804: ARRAY
18805: PPUSH
18806: LD_VAR 0 1
18810: PUSH
18811: LD_INT 2
18813: ARRAY
18814: PPUSH
18815: CALL_OW 429
// end ; end ;
18819: LD_VAR 0 1
18823: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18824: LD_EXP 36
18828: PUSH
18829: LD_EXP 58
18833: AND
18834: IFFALSE 18846
18836: GO 18838
18838: DISABLE
// YouLost (  ) ;
18839: LD_STRING 
18841: PPUSH
18842: CALL_OW 104
18846: END
// every 0 0$1 trigger StreamModeActive and sFog do
18847: LD_EXP 36
18851: PUSH
18852: LD_EXP 57
18856: AND
18857: IFFALSE 18871
18859: GO 18861
18861: DISABLE
// FogOff ( your_side ) ;
18862: LD_OWVAR 2
18866: PPUSH
18867: CALL_OW 344
18871: END
// every 0 0$1 trigger StreamModeActive and sSun do
18872: LD_EXP 36
18876: PUSH
18877: LD_EXP 59
18881: AND
18882: IFFALSE 18910
18884: GO 18886
18886: DISABLE
// begin solar_recharge_percent := 0 ;
18887: LD_ADDR_OWVAR 79
18891: PUSH
18892: LD_INT 0
18894: ST_TO_ADDR
// wait ( 5 5$00 ) ;
18895: LD_INT 10500
18897: PPUSH
18898: CALL_OW 67
// solar_recharge_percent := 100 ;
18902: LD_ADDR_OWVAR 79
18906: PUSH
18907: LD_INT 100
18909: ST_TO_ADDR
// end ;
18910: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
18911: LD_EXP 36
18915: PUSH
18916: LD_EXP 60
18920: AND
18921: IFFALSE 19160
18923: GO 18925
18925: DISABLE
18926: LD_INT 0
18928: PPUSH
18929: PPUSH
18930: PPUSH
// begin tmp := [ ] ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: EMPTY
18937: ST_TO_ADDR
// for i := 1 to 6 do
18938: LD_ADDR_VAR 0 1
18942: PUSH
18943: DOUBLE
18944: LD_INT 1
18946: DEC
18947: ST_TO_ADDR
18948: LD_INT 6
18950: PUSH
18951: FOR_TO
18952: IFFALSE 19057
// begin uc_nation := nation_nature ;
18954: LD_ADDR_OWVAR 21
18958: PUSH
18959: LD_INT 0
18961: ST_TO_ADDR
// uc_side := 0 ;
18962: LD_ADDR_OWVAR 20
18966: PUSH
18967: LD_INT 0
18969: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18970: LD_ADDR_OWVAR 29
18974: PUSH
18975: LD_INT 12
18977: PUSH
18978: LD_INT 12
18980: PUSH
18981: EMPTY
18982: LIST
18983: LIST
18984: ST_TO_ADDR
// hc_agressivity := 20 ;
18985: LD_ADDR_OWVAR 35
18989: PUSH
18990: LD_INT 20
18992: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
18993: LD_ADDR_OWVAR 28
18997: PUSH
18998: LD_INT 17
19000: ST_TO_ADDR
// hc_gallery :=  ;
19001: LD_ADDR_OWVAR 33
19005: PUSH
19006: LD_STRING 
19008: ST_TO_ADDR
// hc_name :=  ;
19009: LD_ADDR_OWVAR 26
19013: PUSH
19014: LD_STRING 
19016: ST_TO_ADDR
// un := CreateHuman ;
19017: LD_ADDR_VAR 0 2
19021: PUSH
19022: CALL_OW 44
19026: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
19027: LD_VAR 0 2
19031: PPUSH
19032: LD_INT 1
19034: PPUSH
19035: CALL_OW 51
// tmp := tmp ^ un ;
19039: LD_ADDR_VAR 0 3
19043: PUSH
19044: LD_VAR 0 3
19048: PUSH
19049: LD_VAR 0 2
19053: ADD
19054: ST_TO_ADDR
// end ;
19055: GO 18951
19057: POP
19058: POP
// repeat wait ( 0 0$1 ) ;
19059: LD_INT 35
19061: PPUSH
19062: CALL_OW 67
// for un in tmp do
19066: LD_ADDR_VAR 0 2
19070: PUSH
19071: LD_VAR 0 3
19075: PUSH
19076: FOR_IN
19077: IFFALSE 19151
// begin if IsDead ( un ) then
19079: LD_VAR 0 2
19083: PPUSH
19084: CALL_OW 301
19088: IFFALSE 19108
// begin tmp := tmp diff un ;
19090: LD_ADDR_VAR 0 3
19094: PUSH
19095: LD_VAR 0 3
19099: PUSH
19100: LD_VAR 0 2
19104: DIFF
19105: ST_TO_ADDR
// continue ;
19106: GO 19076
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
19108: LD_VAR 0 2
19112: PPUSH
19113: LD_INT 3
19115: PUSH
19116: LD_INT 22
19118: PUSH
19119: LD_INT 0
19121: PUSH
19122: EMPTY
19123: LIST
19124: LIST
19125: PUSH
19126: EMPTY
19127: LIST
19128: LIST
19129: PPUSH
19130: CALL_OW 69
19134: PPUSH
19135: LD_VAR 0 2
19139: PPUSH
19140: CALL_OW 74
19144: PPUSH
19145: CALL_OW 115
// end ;
19149: GO 19076
19151: POP
19152: POP
// until not tmp ;
19153: LD_VAR 0 3
19157: NOT
19158: IFFALSE 19059
// end ;
19160: PPOPN 3
19162: END
// every 0 0$1 trigger StreamModeActive and sTroll do
19163: LD_EXP 36
19167: PUSH
19168: LD_EXP 61
19172: AND
19173: IFFALSE 19227
19175: GO 19177
19177: DISABLE
// begin ToLua ( displayTroll(); ) ;
19178: LD_STRING displayTroll();
19180: PPUSH
19181: CALL_OW 559
// wait ( 3 3$00 ) ;
19185: LD_INT 6300
19187: PPUSH
19188: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19192: LD_STRING hideTroll();
19194: PPUSH
19195: CALL_OW 559
// wait ( 1 1$00 ) ;
19199: LD_INT 2100
19201: PPUSH
19202: CALL_OW 67
// ToLua ( displayTroll(); ) ;
19206: LD_STRING displayTroll();
19208: PPUSH
19209: CALL_OW 559
// wait ( 1 1$00 ) ;
19213: LD_INT 2100
19215: PPUSH
19216: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19220: LD_STRING hideTroll();
19222: PPUSH
19223: CALL_OW 559
// end ;
19227: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
19228: LD_EXP 36
19232: PUSH
19233: LD_EXP 62
19237: AND
19238: IFFALSE 19301
19240: GO 19242
19242: DISABLE
19243: LD_INT 0
19245: PPUSH
// begin p := 0 ;
19246: LD_ADDR_VAR 0 1
19250: PUSH
19251: LD_INT 0
19253: ST_TO_ADDR
// repeat game_speed := 1 ;
19254: LD_ADDR_OWVAR 65
19258: PUSH
19259: LD_INT 1
19261: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19262: LD_INT 35
19264: PPUSH
19265: CALL_OW 67
// p := p + 1 ;
19269: LD_ADDR_VAR 0 1
19273: PUSH
19274: LD_VAR 0 1
19278: PUSH
19279: LD_INT 1
19281: PLUS
19282: ST_TO_ADDR
// until p >= 60 ;
19283: LD_VAR 0 1
19287: PUSH
19288: LD_INT 60
19290: GREATEREQUAL
19291: IFFALSE 19254
// game_speed := 4 ;
19293: LD_ADDR_OWVAR 65
19297: PUSH
19298: LD_INT 4
19300: ST_TO_ADDR
// end ;
19301: PPOPN 1
19303: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
19304: LD_EXP 36
19308: PUSH
19309: LD_EXP 63
19313: AND
19314: IFFALSE 19460
19316: GO 19318
19318: DISABLE
19319: LD_INT 0
19321: PPUSH
19322: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19323: LD_ADDR_VAR 0 1
19327: PUSH
19328: LD_INT 22
19330: PUSH
19331: LD_OWVAR 2
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PUSH
19340: LD_INT 2
19342: PUSH
19343: LD_INT 30
19345: PUSH
19346: LD_INT 0
19348: PUSH
19349: EMPTY
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 30
19355: PUSH
19356: LD_INT 1
19358: PUSH
19359: EMPTY
19360: LIST
19361: LIST
19362: PUSH
19363: EMPTY
19364: LIST
19365: LIST
19366: LIST
19367: PUSH
19368: EMPTY
19369: LIST
19370: LIST
19371: PPUSH
19372: CALL_OW 69
19376: ST_TO_ADDR
// if not depot then
19377: LD_VAR 0 1
19381: NOT
19382: IFFALSE 19386
// exit ;
19384: GO 19460
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
19386: LD_ADDR_VAR 0 2
19390: PUSH
19391: LD_VAR 0 1
19395: PUSH
19396: LD_INT 1
19398: PPUSH
19399: LD_VAR 0 1
19403: PPUSH
19404: CALL_OW 12
19408: ARRAY
19409: PPUSH
19410: CALL_OW 274
19414: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
19415: LD_VAR 0 2
19419: PPUSH
19420: LD_INT 1
19422: PPUSH
19423: LD_INT 0
19425: PPUSH
19426: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
19430: LD_VAR 0 2
19434: PPUSH
19435: LD_INT 2
19437: PPUSH
19438: LD_INT 0
19440: PPUSH
19441: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
19445: LD_VAR 0 2
19449: PPUSH
19450: LD_INT 3
19452: PPUSH
19453: LD_INT 0
19455: PPUSH
19456: CALL_OW 277
// end ;
19460: PPOPN 2
19462: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
19463: LD_EXP 36
19467: PUSH
19468: LD_EXP 64
19472: AND
19473: IFFALSE 19570
19475: GO 19477
19477: DISABLE
19478: LD_INT 0
19480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19481: LD_ADDR_VAR 0 1
19485: PUSH
19486: LD_INT 22
19488: PUSH
19489: LD_OWVAR 2
19493: PUSH
19494: EMPTY
19495: LIST
19496: LIST
19497: PUSH
19498: LD_INT 21
19500: PUSH
19501: LD_INT 1
19503: PUSH
19504: EMPTY
19505: LIST
19506: LIST
19507: PUSH
19508: LD_INT 3
19510: PUSH
19511: LD_INT 23
19513: PUSH
19514: LD_INT 0
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: PUSH
19521: EMPTY
19522: LIST
19523: LIST
19524: PUSH
19525: EMPTY
19526: LIST
19527: LIST
19528: LIST
19529: PPUSH
19530: CALL_OW 69
19534: ST_TO_ADDR
// if not tmp then
19535: LD_VAR 0 1
19539: NOT
19540: IFFALSE 19544
// exit ;
19542: GO 19570
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
19544: LD_VAR 0 1
19548: PUSH
19549: LD_INT 1
19551: PPUSH
19552: LD_VAR 0 1
19556: PPUSH
19557: CALL_OW 12
19561: ARRAY
19562: PPUSH
19563: LD_INT 200
19565: PPUSH
19566: CALL_OW 234
// end ;
19570: PPOPN 1
19572: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19573: LD_EXP 36
19577: PUSH
19578: LD_EXP 65
19582: AND
19583: IFFALSE 19662
19585: GO 19587
19587: DISABLE
19588: LD_INT 0
19590: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19591: LD_ADDR_VAR 0 1
19595: PUSH
19596: LD_INT 22
19598: PUSH
19599: LD_OWVAR 2
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: PUSH
19608: LD_INT 21
19610: PUSH
19611: LD_INT 2
19613: PUSH
19614: EMPTY
19615: LIST
19616: LIST
19617: PUSH
19618: EMPTY
19619: LIST
19620: LIST
19621: PPUSH
19622: CALL_OW 69
19626: ST_TO_ADDR
// if not tmp then
19627: LD_VAR 0 1
19631: NOT
19632: IFFALSE 19636
// exit ;
19634: GO 19662
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
19636: LD_VAR 0 1
19640: PUSH
19641: LD_INT 1
19643: PPUSH
19644: LD_VAR 0 1
19648: PPUSH
19649: CALL_OW 12
19653: ARRAY
19654: PPUSH
19655: LD_INT 60
19657: PPUSH
19658: CALL_OW 234
// end ;
19662: PPOPN 1
19664: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
19665: LD_EXP 36
19669: PUSH
19670: LD_EXP 66
19674: AND
19675: IFFALSE 19774
19677: GO 19679
19679: DISABLE
19680: LD_INT 0
19682: PPUSH
19683: PPUSH
// begin enable ;
19684: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
19685: LD_ADDR_VAR 0 1
19689: PUSH
19690: LD_INT 22
19692: PUSH
19693: LD_OWVAR 2
19697: PUSH
19698: EMPTY
19699: LIST
19700: LIST
19701: PUSH
19702: LD_INT 61
19704: PUSH
19705: EMPTY
19706: LIST
19707: PUSH
19708: LD_INT 33
19710: PUSH
19711: LD_INT 2
19713: PUSH
19714: EMPTY
19715: LIST
19716: LIST
19717: PUSH
19718: EMPTY
19719: LIST
19720: LIST
19721: LIST
19722: PPUSH
19723: CALL_OW 69
19727: ST_TO_ADDR
// if not tmp then
19728: LD_VAR 0 1
19732: NOT
19733: IFFALSE 19737
// exit ;
19735: GO 19774
// for i in tmp do
19737: LD_ADDR_VAR 0 2
19741: PUSH
19742: LD_VAR 0 1
19746: PUSH
19747: FOR_IN
19748: IFFALSE 19772
// if IsControledBy ( i ) then
19750: LD_VAR 0 2
19754: PPUSH
19755: CALL_OW 312
19759: IFFALSE 19770
// ComUnlink ( i ) ;
19761: LD_VAR 0 2
19765: PPUSH
19766: CALL_OW 136
19770: GO 19747
19772: POP
19773: POP
// end ;
19774: PPOPN 2
19776: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
19777: LD_EXP 36
19781: PUSH
19782: LD_EXP 67
19786: AND
19787: IFFALSE 19927
19789: GO 19791
19791: DISABLE
19792: LD_INT 0
19794: PPUSH
19795: PPUSH
// begin ToLua ( displayPowell(); ) ;
19796: LD_STRING displayPowell();
19798: PPUSH
19799: CALL_OW 559
// uc_side := 0 ;
19803: LD_ADDR_OWVAR 20
19807: PUSH
19808: LD_INT 0
19810: ST_TO_ADDR
// uc_nation := 2 ;
19811: LD_ADDR_OWVAR 21
19815: PUSH
19816: LD_INT 2
19818: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19819: LD_ADDR_OWVAR 37
19823: PUSH
19824: LD_INT 14
19826: ST_TO_ADDR
// vc_engine := engine_siberite ;
19827: LD_ADDR_OWVAR 39
19831: PUSH
19832: LD_INT 3
19834: ST_TO_ADDR
// vc_control := control_apeman ;
19835: LD_ADDR_OWVAR 38
19839: PUSH
19840: LD_INT 5
19842: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19843: LD_ADDR_OWVAR 40
19847: PUSH
19848: LD_INT 29
19850: ST_TO_ADDR
// un := CreateVehicle ;
19851: LD_ADDR_VAR 0 2
19855: PUSH
19856: CALL_OW 45
19860: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19861: LD_VAR 0 2
19865: PPUSH
19866: LD_INT 1
19868: PPUSH
19869: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19873: LD_INT 35
19875: PPUSH
19876: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19880: LD_VAR 0 2
19884: PPUSH
19885: LD_INT 22
19887: PUSH
19888: LD_OWVAR 2
19892: PUSH
19893: EMPTY
19894: LIST
19895: LIST
19896: PPUSH
19897: CALL_OW 69
19901: PPUSH
19902: LD_VAR 0 2
19906: PPUSH
19907: CALL_OW 74
19911: PPUSH
19912: CALL_OW 115
// until IsDead ( un ) ;
19916: LD_VAR 0 2
19920: PPUSH
19921: CALL_OW 301
19925: IFFALSE 19873
// end ;
19927: PPOPN 2
19929: END
// every 0 0$1 trigger StreamModeActive and sStu do
19930: LD_EXP 36
19934: PUSH
19935: LD_EXP 75
19939: AND
19940: IFFALSE 19956
19942: GO 19944
19944: DISABLE
// begin ToLua ( displayStucuk(); ) ;
19945: LD_STRING displayStucuk();
19947: PPUSH
19948: CALL_OW 559
// ResetFog ;
19952: CALL_OW 335
// end ;
19956: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
19957: LD_EXP 36
19961: PUSH
19962: LD_EXP 68
19966: AND
19967: IFFALSE 20108
19969: GO 19971
19971: DISABLE
19972: LD_INT 0
19974: PPUSH
19975: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19976: LD_ADDR_VAR 0 2
19980: PUSH
19981: LD_INT 22
19983: PUSH
19984: LD_OWVAR 2
19988: PUSH
19989: EMPTY
19990: LIST
19991: LIST
19992: PUSH
19993: LD_INT 21
19995: PUSH
19996: LD_INT 1
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: PPUSH
20007: CALL_OW 69
20011: ST_TO_ADDR
// if not tmp then
20012: LD_VAR 0 2
20016: NOT
20017: IFFALSE 20021
// exit ;
20019: GO 20108
// un := tmp [ rand ( 1 , tmp ) ] ;
20021: LD_ADDR_VAR 0 1
20025: PUSH
20026: LD_VAR 0 2
20030: PUSH
20031: LD_INT 1
20033: PPUSH
20034: LD_VAR 0 2
20038: PPUSH
20039: CALL_OW 12
20043: ARRAY
20044: ST_TO_ADDR
// SetSide ( un , 0 ) ;
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_INT 0
20052: PPUSH
20053: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
20057: LD_VAR 0 1
20061: PPUSH
20062: LD_OWVAR 3
20066: PUSH
20067: LD_VAR 0 1
20071: DIFF
20072: PPUSH
20073: LD_VAR 0 1
20077: PPUSH
20078: CALL_OW 74
20082: PPUSH
20083: CALL_OW 115
// wait ( 0 0$20 ) ;
20087: LD_INT 700
20089: PPUSH
20090: CALL_OW 67
// SetSide ( un , your_side ) ;
20094: LD_VAR 0 1
20098: PPUSH
20099: LD_OWVAR 2
20103: PPUSH
20104: CALL_OW 235
// end ;
20108: PPOPN 2
20110: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
20111: LD_EXP 36
20115: PUSH
20116: LD_EXP 69
20120: AND
20121: IFFALSE 20227
20123: GO 20125
20125: DISABLE
20126: LD_INT 0
20128: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
20129: LD_ADDR_VAR 0 1
20133: PUSH
20134: LD_INT 22
20136: PUSH
20137: LD_OWVAR 2
20141: PUSH
20142: EMPTY
20143: LIST
20144: LIST
20145: PUSH
20146: LD_INT 2
20148: PUSH
20149: LD_INT 30
20151: PUSH
20152: LD_INT 0
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: PUSH
20159: LD_INT 30
20161: PUSH
20162: LD_INT 1
20164: PUSH
20165: EMPTY
20166: LIST
20167: LIST
20168: PUSH
20169: EMPTY
20170: LIST
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PPUSH
20178: CALL_OW 69
20182: ST_TO_ADDR
// if not depot then
20183: LD_VAR 0 1
20187: NOT
20188: IFFALSE 20192
// exit ;
20190: GO 20227
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
20192: LD_VAR 0 1
20196: PUSH
20197: LD_INT 1
20199: ARRAY
20200: PPUSH
20201: CALL_OW 250
20205: PPUSH
20206: LD_VAR 0 1
20210: PUSH
20211: LD_INT 1
20213: ARRAY
20214: PPUSH
20215: CALL_OW 251
20219: PPUSH
20220: LD_INT 70
20222: PPUSH
20223: CALL_OW 495
// end ;
20227: PPOPN 1
20229: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
20230: LD_EXP 36
20234: PUSH
20235: LD_EXP 70
20239: AND
20240: IFFALSE 20451
20242: GO 20244
20244: DISABLE
20245: LD_INT 0
20247: PPUSH
20248: PPUSH
20249: PPUSH
20250: PPUSH
20251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20252: LD_ADDR_VAR 0 5
20256: PUSH
20257: LD_INT 22
20259: PUSH
20260: LD_OWVAR 2
20264: PUSH
20265: EMPTY
20266: LIST
20267: LIST
20268: PUSH
20269: LD_INT 21
20271: PUSH
20272: LD_INT 1
20274: PUSH
20275: EMPTY
20276: LIST
20277: LIST
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: PPUSH
20283: CALL_OW 69
20287: ST_TO_ADDR
// if not tmp then
20288: LD_VAR 0 5
20292: NOT
20293: IFFALSE 20297
// exit ;
20295: GO 20451
// for i in tmp do
20297: LD_ADDR_VAR 0 1
20301: PUSH
20302: LD_VAR 0 5
20306: PUSH
20307: FOR_IN
20308: IFFALSE 20449
// begin d := rand ( 0 , 5 ) ;
20310: LD_ADDR_VAR 0 4
20314: PUSH
20315: LD_INT 0
20317: PPUSH
20318: LD_INT 5
20320: PPUSH
20321: CALL_OW 12
20325: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
20326: LD_ADDR_VAR 0 2
20330: PUSH
20331: LD_VAR 0 1
20335: PPUSH
20336: CALL_OW 250
20340: PPUSH
20341: LD_VAR 0 4
20345: PPUSH
20346: LD_INT 3
20348: PPUSH
20349: LD_INT 12
20351: PPUSH
20352: CALL_OW 12
20356: PPUSH
20357: CALL_OW 272
20361: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
20362: LD_ADDR_VAR 0 3
20366: PUSH
20367: LD_VAR 0 1
20371: PPUSH
20372: CALL_OW 251
20376: PPUSH
20377: LD_VAR 0 4
20381: PPUSH
20382: LD_INT 3
20384: PPUSH
20385: LD_INT 12
20387: PPUSH
20388: CALL_OW 12
20392: PPUSH
20393: CALL_OW 273
20397: ST_TO_ADDR
// if ValidHex ( x , y ) then
20398: LD_VAR 0 2
20402: PPUSH
20403: LD_VAR 0 3
20407: PPUSH
20408: CALL_OW 488
20412: IFFALSE 20447
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
20414: LD_VAR 0 1
20418: PPUSH
20419: LD_VAR 0 2
20423: PPUSH
20424: LD_VAR 0 3
20428: PPUSH
20429: LD_INT 3
20431: PPUSH
20432: LD_INT 6
20434: PPUSH
20435: CALL_OW 12
20439: PPUSH
20440: LD_INT 1
20442: PPUSH
20443: CALL_OW 483
// end ;
20447: GO 20307
20449: POP
20450: POP
// end ;
20451: PPOPN 5
20453: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
20454: LD_EXP 36
20458: PUSH
20459: LD_EXP 71
20463: AND
20464: IFFALSE 20558
20466: GO 20468
20468: DISABLE
20469: LD_INT 0
20471: PPUSH
20472: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
20473: LD_ADDR_VAR 0 2
20477: PUSH
20478: LD_INT 22
20480: PUSH
20481: LD_OWVAR 2
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: PUSH
20490: LD_INT 32
20492: PUSH
20493: LD_INT 1
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PUSH
20500: LD_INT 21
20502: PUSH
20503: LD_INT 2
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: PUSH
20510: EMPTY
20511: LIST
20512: LIST
20513: LIST
20514: PPUSH
20515: CALL_OW 69
20519: ST_TO_ADDR
// if not tmp then
20520: LD_VAR 0 2
20524: NOT
20525: IFFALSE 20529
// exit ;
20527: GO 20558
// for i in tmp do
20529: LD_ADDR_VAR 0 1
20533: PUSH
20534: LD_VAR 0 2
20538: PUSH
20539: FOR_IN
20540: IFFALSE 20556
// SetFuel ( i , 0 ) ;
20542: LD_VAR 0 1
20546: PPUSH
20547: LD_INT 0
20549: PPUSH
20550: CALL_OW 240
20554: GO 20539
20556: POP
20557: POP
// end ;
20558: PPOPN 2
20560: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
20561: LD_EXP 36
20565: PUSH
20566: LD_EXP 72
20570: AND
20571: IFFALSE 20637
20573: GO 20575
20575: DISABLE
20576: LD_INT 0
20578: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20579: LD_ADDR_VAR 0 1
20583: PUSH
20584: LD_INT 22
20586: PUSH
20587: LD_OWVAR 2
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 29
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: ST_TO_ADDR
// if not tmp then
20615: LD_VAR 0 1
20619: NOT
20620: IFFALSE 20624
// exit ;
20622: GO 20637
// DestroyUnit ( tmp [ 1 ] ) ;
20624: LD_VAR 0 1
20628: PUSH
20629: LD_INT 1
20631: ARRAY
20632: PPUSH
20633: CALL_OW 65
// end ;
20637: PPOPN 1
20639: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
20640: LD_EXP 36
20644: PUSH
20645: LD_EXP 74
20649: AND
20650: IFFALSE 20779
20652: GO 20654
20654: DISABLE
20655: LD_INT 0
20657: PPUSH
// begin uc_side := 0 ;
20658: LD_ADDR_OWVAR 20
20662: PUSH
20663: LD_INT 0
20665: ST_TO_ADDR
// uc_nation := nation_arabian ;
20666: LD_ADDR_OWVAR 21
20670: PUSH
20671: LD_INT 2
20673: ST_TO_ADDR
// hc_gallery :=  ;
20674: LD_ADDR_OWVAR 33
20678: PUSH
20679: LD_STRING 
20681: ST_TO_ADDR
// hc_name :=  ;
20682: LD_ADDR_OWVAR 26
20686: PUSH
20687: LD_STRING 
20689: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
20690: LD_INT 1
20692: PPUSH
20693: LD_INT 11
20695: PPUSH
20696: LD_INT 10
20698: PPUSH
20699: CALL_OW 380
// un := CreateHuman ;
20703: LD_ADDR_VAR 0 1
20707: PUSH
20708: CALL_OW 44
20712: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20713: LD_VAR 0 1
20717: PPUSH
20718: LD_INT 1
20720: PPUSH
20721: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20725: LD_INT 35
20727: PPUSH
20728: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20732: LD_VAR 0 1
20736: PPUSH
20737: LD_INT 22
20739: PUSH
20740: LD_OWVAR 2
20744: PUSH
20745: EMPTY
20746: LIST
20747: LIST
20748: PPUSH
20749: CALL_OW 69
20753: PPUSH
20754: LD_VAR 0 1
20758: PPUSH
20759: CALL_OW 74
20763: PPUSH
20764: CALL_OW 115
// until IsDead ( un ) ;
20768: LD_VAR 0 1
20772: PPUSH
20773: CALL_OW 301
20777: IFFALSE 20725
// end ;
20779: PPOPN 1
20781: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
20782: LD_EXP 36
20786: PUSH
20787: LD_EXP 76
20791: AND
20792: IFFALSE 20804
20794: GO 20796
20796: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
20797: LD_STRING earthquake(getX(game), 0, 32)
20799: PPUSH
20800: CALL_OW 559
20804: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20805: LD_EXP 36
20809: PUSH
20810: LD_EXP 77
20814: AND
20815: IFFALSE 20906
20817: GO 20819
20819: DISABLE
20820: LD_INT 0
20822: PPUSH
// begin enable ;
20823: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20824: LD_ADDR_VAR 0 1
20828: PUSH
20829: LD_INT 22
20831: PUSH
20832: LD_OWVAR 2
20836: PUSH
20837: EMPTY
20838: LIST
20839: LIST
20840: PUSH
20841: LD_INT 21
20843: PUSH
20844: LD_INT 2
20846: PUSH
20847: EMPTY
20848: LIST
20849: LIST
20850: PUSH
20851: LD_INT 33
20853: PUSH
20854: LD_INT 3
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: LIST
20865: PPUSH
20866: CALL_OW 69
20870: ST_TO_ADDR
// if not tmp then
20871: LD_VAR 0 1
20875: NOT
20876: IFFALSE 20880
// exit ;
20878: GO 20906
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20880: LD_VAR 0 1
20884: PUSH
20885: LD_INT 1
20887: PPUSH
20888: LD_VAR 0 1
20892: PPUSH
20893: CALL_OW 12
20897: ARRAY
20898: PPUSH
20899: LD_INT 1
20901: PPUSH
20902: CALL_OW 234
// end ;
20906: PPOPN 1
20908: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
20909: LD_EXP 36
20913: PUSH
20914: LD_EXP 78
20918: AND
20919: IFFALSE 21060
20921: GO 20923
20923: DISABLE
20924: LD_INT 0
20926: PPUSH
20927: PPUSH
20928: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20929: LD_ADDR_VAR 0 3
20933: PUSH
20934: LD_INT 22
20936: PUSH
20937: LD_OWVAR 2
20941: PUSH
20942: EMPTY
20943: LIST
20944: LIST
20945: PUSH
20946: LD_INT 25
20948: PUSH
20949: LD_INT 1
20951: PUSH
20952: EMPTY
20953: LIST
20954: LIST
20955: PUSH
20956: EMPTY
20957: LIST
20958: LIST
20959: PPUSH
20960: CALL_OW 69
20964: ST_TO_ADDR
// if not tmp then
20965: LD_VAR 0 3
20969: NOT
20970: IFFALSE 20974
// exit ;
20972: GO 21060
// un := tmp [ rand ( 1 , tmp ) ] ;
20974: LD_ADDR_VAR 0 2
20978: PUSH
20979: LD_VAR 0 3
20983: PUSH
20984: LD_INT 1
20986: PPUSH
20987: LD_VAR 0 3
20991: PPUSH
20992: CALL_OW 12
20996: ARRAY
20997: ST_TO_ADDR
// if Crawls ( un ) then
20998: LD_VAR 0 2
21002: PPUSH
21003: CALL_OW 318
21007: IFFALSE 21018
// ComWalk ( un ) ;
21009: LD_VAR 0 2
21013: PPUSH
21014: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
21018: LD_VAR 0 2
21022: PPUSH
21023: LD_INT 9
21025: PPUSH
21026: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
21030: LD_INT 28
21032: PPUSH
21033: LD_OWVAR 2
21037: PPUSH
21038: LD_INT 2
21040: PPUSH
21041: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
21045: LD_INT 29
21047: PPUSH
21048: LD_OWVAR 2
21052: PPUSH
21053: LD_INT 2
21055: PPUSH
21056: CALL_OW 322
// end ;
21060: PPOPN 3
21062: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
21063: LD_EXP 36
21067: PUSH
21068: LD_EXP 79
21072: AND
21073: IFFALSE 21184
21075: GO 21077
21077: DISABLE
21078: LD_INT 0
21080: PPUSH
21081: PPUSH
21082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21083: LD_ADDR_VAR 0 3
21087: PUSH
21088: LD_INT 22
21090: PUSH
21091: LD_OWVAR 2
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: PUSH
21100: LD_INT 25
21102: PUSH
21103: LD_INT 1
21105: PUSH
21106: EMPTY
21107: LIST
21108: LIST
21109: PUSH
21110: EMPTY
21111: LIST
21112: LIST
21113: PPUSH
21114: CALL_OW 69
21118: ST_TO_ADDR
// if not tmp then
21119: LD_VAR 0 3
21123: NOT
21124: IFFALSE 21128
// exit ;
21126: GO 21184
// un := tmp [ rand ( 1 , tmp ) ] ;
21128: LD_ADDR_VAR 0 2
21132: PUSH
21133: LD_VAR 0 3
21137: PUSH
21138: LD_INT 1
21140: PPUSH
21141: LD_VAR 0 3
21145: PPUSH
21146: CALL_OW 12
21150: ARRAY
21151: ST_TO_ADDR
// if Crawls ( un ) then
21152: LD_VAR 0 2
21156: PPUSH
21157: CALL_OW 318
21161: IFFALSE 21172
// ComWalk ( un ) ;
21163: LD_VAR 0 2
21167: PPUSH
21168: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21172: LD_VAR 0 2
21176: PPUSH
21177: LD_INT 8
21179: PPUSH
21180: CALL_OW 336
// end ;
21184: PPOPN 3
21186: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
21187: LD_EXP 36
21191: PUSH
21192: LD_EXP 80
21196: AND
21197: IFFALSE 21341
21199: GO 21201
21201: DISABLE
21202: LD_INT 0
21204: PPUSH
21205: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
21206: LD_ADDR_VAR 0 2
21210: PUSH
21211: LD_INT 22
21213: PUSH
21214: LD_OWVAR 2
21218: PUSH
21219: EMPTY
21220: LIST
21221: LIST
21222: PUSH
21223: LD_INT 21
21225: PUSH
21226: LD_INT 2
21228: PUSH
21229: EMPTY
21230: LIST
21231: LIST
21232: PUSH
21233: LD_INT 2
21235: PUSH
21236: LD_INT 34
21238: PUSH
21239: LD_INT 12
21241: PUSH
21242: EMPTY
21243: LIST
21244: LIST
21245: PUSH
21246: LD_INT 34
21248: PUSH
21249: LD_INT 51
21251: PUSH
21252: EMPTY
21253: LIST
21254: LIST
21255: PUSH
21256: LD_INT 34
21258: PUSH
21259: LD_INT 32
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: PUSH
21266: EMPTY
21267: LIST
21268: LIST
21269: LIST
21270: LIST
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: LIST
21276: PPUSH
21277: CALL_OW 69
21281: ST_TO_ADDR
// if not tmp then
21282: LD_VAR 0 2
21286: NOT
21287: IFFALSE 21291
// exit ;
21289: GO 21341
// for i in tmp do
21291: LD_ADDR_VAR 0 1
21295: PUSH
21296: LD_VAR 0 2
21300: PUSH
21301: FOR_IN
21302: IFFALSE 21339
// if GetCargo ( i , mat_artifact ) = 0 then
21304: LD_VAR 0 1
21308: PPUSH
21309: LD_INT 4
21311: PPUSH
21312: CALL_OW 289
21316: PUSH
21317: LD_INT 0
21319: EQUAL
21320: IFFALSE 21337
// SetCargo ( i , mat_siberit , 100 ) ;
21322: LD_VAR 0 1
21326: PPUSH
21327: LD_INT 3
21329: PPUSH
21330: LD_INT 100
21332: PPUSH
21333: CALL_OW 290
21337: GO 21301
21339: POP
21340: POP
// end ;
21341: PPOPN 2
21343: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
21344: LD_EXP 36
21348: PUSH
21349: LD_EXP 81
21353: AND
21354: IFFALSE 21507
21356: GO 21358
21358: DISABLE
21359: LD_INT 0
21361: PPUSH
21362: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
21363: LD_ADDR_VAR 0 2
21367: PUSH
21368: LD_INT 22
21370: PUSH
21371: LD_OWVAR 2
21375: PUSH
21376: EMPTY
21377: LIST
21378: LIST
21379: PPUSH
21380: CALL_OW 69
21384: ST_TO_ADDR
// if not tmp then
21385: LD_VAR 0 2
21389: NOT
21390: IFFALSE 21394
// exit ;
21392: GO 21507
// for i := 1 to 2 do
21394: LD_ADDR_VAR 0 1
21398: PUSH
21399: DOUBLE
21400: LD_INT 1
21402: DEC
21403: ST_TO_ADDR
21404: LD_INT 2
21406: PUSH
21407: FOR_TO
21408: IFFALSE 21505
// begin uc_side := your_side ;
21410: LD_ADDR_OWVAR 20
21414: PUSH
21415: LD_OWVAR 2
21419: ST_TO_ADDR
// uc_nation := nation_american ;
21420: LD_ADDR_OWVAR 21
21424: PUSH
21425: LD_INT 1
21427: ST_TO_ADDR
// vc_chassis := us_morphling ;
21428: LD_ADDR_OWVAR 37
21432: PUSH
21433: LD_INT 5
21435: ST_TO_ADDR
// vc_engine := engine_siberite ;
21436: LD_ADDR_OWVAR 39
21440: PUSH
21441: LD_INT 3
21443: ST_TO_ADDR
// vc_control := control_computer ;
21444: LD_ADDR_OWVAR 38
21448: PUSH
21449: LD_INT 3
21451: ST_TO_ADDR
// vc_weapon := us_double_laser ;
21452: LD_ADDR_OWVAR 40
21456: PUSH
21457: LD_INT 10
21459: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
21460: CALL_OW 45
21464: PPUSH
21465: LD_VAR 0 2
21469: PUSH
21470: LD_INT 1
21472: ARRAY
21473: PPUSH
21474: CALL_OW 250
21478: PPUSH
21479: LD_VAR 0 2
21483: PUSH
21484: LD_INT 1
21486: ARRAY
21487: PPUSH
21488: CALL_OW 251
21492: PPUSH
21493: LD_INT 12
21495: PPUSH
21496: LD_INT 1
21498: PPUSH
21499: CALL_OW 50
// end ;
21503: GO 21407
21505: POP
21506: POP
// end ;
21507: PPOPN 2
21509: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
21510: LD_EXP 36
21514: PUSH
21515: LD_EXP 82
21519: AND
21520: IFFALSE 21742
21522: GO 21524
21524: DISABLE
21525: LD_INT 0
21527: PPUSH
21528: PPUSH
21529: PPUSH
21530: PPUSH
21531: PPUSH
21532: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21533: LD_ADDR_VAR 0 6
21537: PUSH
21538: LD_INT 22
21540: PUSH
21541: LD_OWVAR 2
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: PUSH
21550: LD_INT 21
21552: PUSH
21553: LD_INT 1
21555: PUSH
21556: EMPTY
21557: LIST
21558: LIST
21559: PUSH
21560: LD_INT 3
21562: PUSH
21563: LD_INT 23
21565: PUSH
21566: LD_INT 0
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: PUSH
21577: EMPTY
21578: LIST
21579: LIST
21580: LIST
21581: PPUSH
21582: CALL_OW 69
21586: ST_TO_ADDR
// if not tmp then
21587: LD_VAR 0 6
21591: NOT
21592: IFFALSE 21596
// exit ;
21594: GO 21742
// s1 := rand ( 1 , 4 ) ;
21596: LD_ADDR_VAR 0 2
21600: PUSH
21601: LD_INT 1
21603: PPUSH
21604: LD_INT 4
21606: PPUSH
21607: CALL_OW 12
21611: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
21612: LD_ADDR_VAR 0 4
21616: PUSH
21617: LD_VAR 0 6
21621: PUSH
21622: LD_INT 1
21624: ARRAY
21625: PPUSH
21626: LD_VAR 0 2
21630: PPUSH
21631: CALL_OW 259
21635: ST_TO_ADDR
// if s1 = 1 then
21636: LD_VAR 0 2
21640: PUSH
21641: LD_INT 1
21643: EQUAL
21644: IFFALSE 21664
// s2 := rand ( 2 , 4 ) else
21646: LD_ADDR_VAR 0 3
21650: PUSH
21651: LD_INT 2
21653: PPUSH
21654: LD_INT 4
21656: PPUSH
21657: CALL_OW 12
21661: ST_TO_ADDR
21662: GO 21672
// s2 := 1 ;
21664: LD_ADDR_VAR 0 3
21668: PUSH
21669: LD_INT 1
21671: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
21672: LD_ADDR_VAR 0 5
21676: PUSH
21677: LD_VAR 0 6
21681: PUSH
21682: LD_INT 1
21684: ARRAY
21685: PPUSH
21686: LD_VAR 0 3
21690: PPUSH
21691: CALL_OW 259
21695: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
21696: LD_VAR 0 6
21700: PUSH
21701: LD_INT 1
21703: ARRAY
21704: PPUSH
21705: LD_VAR 0 2
21709: PPUSH
21710: LD_VAR 0 5
21714: PPUSH
21715: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
21719: LD_VAR 0 6
21723: PUSH
21724: LD_INT 1
21726: ARRAY
21727: PPUSH
21728: LD_VAR 0 3
21732: PPUSH
21733: LD_VAR 0 4
21737: PPUSH
21738: CALL_OW 237
// end ;
21742: PPOPN 6
21744: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
21745: LD_EXP 36
21749: PUSH
21750: LD_EXP 83
21754: AND
21755: IFFALSE 21834
21757: GO 21759
21759: DISABLE
21760: LD_INT 0
21762: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
21763: LD_ADDR_VAR 0 1
21767: PUSH
21768: LD_INT 22
21770: PUSH
21771: LD_OWVAR 2
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: PUSH
21780: LD_INT 30
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PPUSH
21794: CALL_OW 69
21798: ST_TO_ADDR
// if not tmp then
21799: LD_VAR 0 1
21803: NOT
21804: IFFALSE 21808
// exit ;
21806: GO 21834
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21808: LD_VAR 0 1
21812: PUSH
21813: LD_INT 1
21815: PPUSH
21816: LD_VAR 0 1
21820: PPUSH
21821: CALL_OW 12
21825: ARRAY
21826: PPUSH
21827: LD_INT 1
21829: PPUSH
21830: CALL_OW 234
// end ;
21834: PPOPN 1
21836: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21837: LD_EXP 36
21841: PUSH
21842: LD_EXP 84
21846: AND
21847: IFFALSE 21959
21849: GO 21851
21851: DISABLE
21852: LD_INT 0
21854: PPUSH
21855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
21856: LD_ADDR_VAR 0 2
21860: PUSH
21861: LD_INT 22
21863: PUSH
21864: LD_OWVAR 2
21868: PUSH
21869: EMPTY
21870: LIST
21871: LIST
21872: PUSH
21873: LD_INT 2
21875: PUSH
21876: LD_INT 30
21878: PUSH
21879: LD_INT 27
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PUSH
21886: LD_INT 30
21888: PUSH
21889: LD_INT 26
21891: PUSH
21892: EMPTY
21893: LIST
21894: LIST
21895: PUSH
21896: LD_INT 30
21898: PUSH
21899: LD_INT 28
21901: PUSH
21902: EMPTY
21903: LIST
21904: LIST
21905: PUSH
21906: EMPTY
21907: LIST
21908: LIST
21909: LIST
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PPUSH
21916: CALL_OW 69
21920: ST_TO_ADDR
// if not tmp then
21921: LD_VAR 0 2
21925: NOT
21926: IFFALSE 21930
// exit ;
21928: GO 21959
// for i in tmp do
21930: LD_ADDR_VAR 0 1
21934: PUSH
21935: LD_VAR 0 2
21939: PUSH
21940: FOR_IN
21941: IFFALSE 21957
// SetLives ( i , 1 ) ;
21943: LD_VAR 0 1
21947: PPUSH
21948: LD_INT 1
21950: PPUSH
21951: CALL_OW 234
21955: GO 21940
21957: POP
21958: POP
// end ;
21959: PPOPN 2
21961: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
21962: LD_EXP 36
21966: PUSH
21967: LD_EXP 85
21971: AND
21972: IFFALSE 22246
21974: GO 21976
21976: DISABLE
21977: LD_INT 0
21979: PPUSH
21980: PPUSH
21981: PPUSH
// begin i := rand ( 1 , 7 ) ;
21982: LD_ADDR_VAR 0 1
21986: PUSH
21987: LD_INT 1
21989: PPUSH
21990: LD_INT 7
21992: PPUSH
21993: CALL_OW 12
21997: ST_TO_ADDR
// case i of 1 :
21998: LD_VAR 0 1
22002: PUSH
22003: LD_INT 1
22005: DOUBLE
22006: EQUAL
22007: IFTRUE 22011
22009: GO 22021
22011: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
22012: LD_STRING earthquake(getX(game), 0, 32)
22014: PPUSH
22015: CALL_OW 559
22019: GO 22246
22021: LD_INT 2
22023: DOUBLE
22024: EQUAL
22025: IFTRUE 22029
22027: GO 22043
22029: POP
// begin ToLua ( displayStucuk(); ) ;
22030: LD_STRING displayStucuk();
22032: PPUSH
22033: CALL_OW 559
// ResetFog ;
22037: CALL_OW 335
// end ; 3 :
22041: GO 22246
22043: LD_INT 3
22045: DOUBLE
22046: EQUAL
22047: IFTRUE 22051
22049: GO 22155
22051: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22052: LD_ADDR_VAR 0 2
22056: PUSH
22057: LD_INT 22
22059: PUSH
22060: LD_OWVAR 2
22064: PUSH
22065: EMPTY
22066: LIST
22067: LIST
22068: PUSH
22069: LD_INT 25
22071: PUSH
22072: LD_INT 1
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: EMPTY
22080: LIST
22081: LIST
22082: PPUSH
22083: CALL_OW 69
22087: ST_TO_ADDR
// if not tmp then
22088: LD_VAR 0 2
22092: NOT
22093: IFFALSE 22097
// exit ;
22095: GO 22246
// un := tmp [ rand ( 1 , tmp ) ] ;
22097: LD_ADDR_VAR 0 3
22101: PUSH
22102: LD_VAR 0 2
22106: PUSH
22107: LD_INT 1
22109: PPUSH
22110: LD_VAR 0 2
22114: PPUSH
22115: CALL_OW 12
22119: ARRAY
22120: ST_TO_ADDR
// if Crawls ( un ) then
22121: LD_VAR 0 3
22125: PPUSH
22126: CALL_OW 318
22130: IFFALSE 22141
// ComWalk ( un ) ;
22132: LD_VAR 0 3
22136: PPUSH
22137: CALL_OW 138
// SetClass ( un , class_mortar ) ;
22141: LD_VAR 0 3
22145: PPUSH
22146: LD_INT 8
22148: PPUSH
22149: CALL_OW 336
// end ; 4 :
22153: GO 22246
22155: LD_INT 4
22157: DOUBLE
22158: EQUAL
22159: IFTRUE 22163
22161: GO 22224
22163: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
22164: LD_ADDR_VAR 0 2
22168: PUSH
22169: LD_INT 22
22171: PUSH
22172: LD_OWVAR 2
22176: PUSH
22177: EMPTY
22178: LIST
22179: LIST
22180: PUSH
22181: LD_INT 30
22183: PUSH
22184: LD_INT 29
22186: PUSH
22187: EMPTY
22188: LIST
22189: LIST
22190: PUSH
22191: EMPTY
22192: LIST
22193: LIST
22194: PPUSH
22195: CALL_OW 69
22199: ST_TO_ADDR
// if not tmp then
22200: LD_VAR 0 2
22204: NOT
22205: IFFALSE 22209
// exit ;
22207: GO 22246
// DestroyUnit ( tmp [ 1 ] ) ;
22209: LD_VAR 0 2
22213: PUSH
22214: LD_INT 1
22216: ARRAY
22217: PPUSH
22218: CALL_OW 65
// end ; 5 .. 7 :
22222: GO 22246
22224: LD_INT 5
22226: DOUBLE
22227: GREATEREQUAL
22228: IFFALSE 22236
22230: LD_INT 7
22232: DOUBLE
22233: LESSEQUAL
22234: IFTRUE 22238
22236: GO 22245
22238: POP
// StreamSibBomb ; end ;
22239: CALL 18526 0 0
22243: GO 22246
22245: POP
// end ;
22246: PPOPN 3
22248: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
22249: LD_EXP 36
22253: PUSH
22254: LD_EXP 86
22258: AND
22259: IFFALSE 22415
22261: GO 22263
22263: DISABLE
22264: LD_INT 0
22266: PPUSH
22267: PPUSH
22268: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
22269: LD_ADDR_VAR 0 2
22273: PUSH
22274: LD_INT 81
22276: PUSH
22277: LD_OWVAR 2
22281: PUSH
22282: EMPTY
22283: LIST
22284: LIST
22285: PUSH
22286: LD_INT 2
22288: PUSH
22289: LD_INT 21
22291: PUSH
22292: LD_INT 1
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PUSH
22299: LD_INT 21
22301: PUSH
22302: LD_INT 2
22304: PUSH
22305: EMPTY
22306: LIST
22307: LIST
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: LIST
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: PPUSH
22318: CALL_OW 69
22322: ST_TO_ADDR
// if not tmp then
22323: LD_VAR 0 2
22327: NOT
22328: IFFALSE 22332
// exit ;
22330: GO 22415
// p := 0 ;
22332: LD_ADDR_VAR 0 3
22336: PUSH
22337: LD_INT 0
22339: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22340: LD_INT 35
22342: PPUSH
22343: CALL_OW 67
// p := p + 1 ;
22347: LD_ADDR_VAR 0 3
22351: PUSH
22352: LD_VAR 0 3
22356: PUSH
22357: LD_INT 1
22359: PLUS
22360: ST_TO_ADDR
// for i in tmp do
22361: LD_ADDR_VAR 0 1
22365: PUSH
22366: LD_VAR 0 2
22370: PUSH
22371: FOR_IN
22372: IFFALSE 22403
// if GetLives ( i ) < 1000 then
22374: LD_VAR 0 1
22378: PPUSH
22379: CALL_OW 256
22383: PUSH
22384: LD_INT 1000
22386: LESS
22387: IFFALSE 22401
// SetLives ( i , 1000 ) ;
22389: LD_VAR 0 1
22393: PPUSH
22394: LD_INT 1000
22396: PPUSH
22397: CALL_OW 234
22401: GO 22371
22403: POP
22404: POP
// until p > 20 ;
22405: LD_VAR 0 3
22409: PUSH
22410: LD_INT 20
22412: GREATER
22413: IFFALSE 22340
// end ;
22415: PPOPN 3
22417: END
// every 0 0$1 trigger StreamModeActive and sTime do
22418: LD_EXP 36
22422: PUSH
22423: LD_EXP 87
22427: AND
22428: IFFALSE 22463
22430: GO 22432
22432: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
22433: LD_INT 28
22435: PPUSH
22436: LD_OWVAR 2
22440: PPUSH
22441: LD_INT 2
22443: PPUSH
22444: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
22448: LD_INT 30
22450: PPUSH
22451: LD_OWVAR 2
22455: PPUSH
22456: LD_INT 2
22458: PPUSH
22459: CALL_OW 322
// end ;
22463: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
22464: LD_EXP 36
22468: PUSH
22469: LD_EXP 88
22473: AND
22474: IFFALSE 22595
22476: GO 22478
22478: DISABLE
22479: LD_INT 0
22481: PPUSH
22482: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22483: LD_ADDR_VAR 0 2
22487: PUSH
22488: LD_INT 22
22490: PUSH
22491: LD_OWVAR 2
22495: PUSH
22496: EMPTY
22497: LIST
22498: LIST
22499: PUSH
22500: LD_INT 21
22502: PUSH
22503: LD_INT 1
22505: PUSH
22506: EMPTY
22507: LIST
22508: LIST
22509: PUSH
22510: LD_INT 3
22512: PUSH
22513: LD_INT 23
22515: PUSH
22516: LD_INT 0
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: PUSH
22523: EMPTY
22524: LIST
22525: LIST
22526: PUSH
22527: EMPTY
22528: LIST
22529: LIST
22530: LIST
22531: PPUSH
22532: CALL_OW 69
22536: ST_TO_ADDR
// if not tmp then
22537: LD_VAR 0 2
22541: NOT
22542: IFFALSE 22546
// exit ;
22544: GO 22595
// for i in tmp do
22546: LD_ADDR_VAR 0 1
22550: PUSH
22551: LD_VAR 0 2
22555: PUSH
22556: FOR_IN
22557: IFFALSE 22593
// begin if Crawls ( i ) then
22559: LD_VAR 0 1
22563: PPUSH
22564: CALL_OW 318
22568: IFFALSE 22579
// ComWalk ( i ) ;
22570: LD_VAR 0 1
22574: PPUSH
22575: CALL_OW 138
// SetClass ( i , 2 ) ;
22579: LD_VAR 0 1
22583: PPUSH
22584: LD_INT 2
22586: PPUSH
22587: CALL_OW 336
// end ;
22591: GO 22556
22593: POP
22594: POP
// end ;
22595: PPOPN 2
22597: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
22598: LD_EXP 36
22602: PUSH
22603: LD_EXP 89
22607: AND
22608: IFFALSE 22889
22610: GO 22612
22612: DISABLE
22613: LD_INT 0
22615: PPUSH
22616: PPUSH
22617: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
22618: LD_OWVAR 2
22622: PPUSH
22623: LD_INT 9
22625: PPUSH
22626: LD_INT 1
22628: PPUSH
22629: LD_INT 1
22631: PPUSH
22632: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
22636: LD_INT 9
22638: PPUSH
22639: LD_OWVAR 2
22643: PPUSH
22644: CALL_OW 343
// uc_side := 9 ;
22648: LD_ADDR_OWVAR 20
22652: PUSH
22653: LD_INT 9
22655: ST_TO_ADDR
// uc_nation := 2 ;
22656: LD_ADDR_OWVAR 21
22660: PUSH
22661: LD_INT 2
22663: ST_TO_ADDR
// hc_name := Dark Warrior ;
22664: LD_ADDR_OWVAR 26
22668: PUSH
22669: LD_STRING Dark Warrior
22671: ST_TO_ADDR
// hc_gallery :=  ;
22672: LD_ADDR_OWVAR 33
22676: PUSH
22677: LD_STRING 
22679: ST_TO_ADDR
// hc_noskilllimit := true ;
22680: LD_ADDR_OWVAR 76
22684: PUSH
22685: LD_INT 1
22687: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
22688: LD_ADDR_OWVAR 31
22692: PUSH
22693: LD_INT 30
22695: PUSH
22696: LD_INT 30
22698: PUSH
22699: LD_INT 30
22701: PUSH
22702: LD_INT 30
22704: PUSH
22705: EMPTY
22706: LIST
22707: LIST
22708: LIST
22709: LIST
22710: ST_TO_ADDR
// un := CreateHuman ;
22711: LD_ADDR_VAR 0 3
22715: PUSH
22716: CALL_OW 44
22720: ST_TO_ADDR
// hc_noskilllimit := false ;
22721: LD_ADDR_OWVAR 76
22725: PUSH
22726: LD_INT 0
22728: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22729: LD_VAR 0 3
22733: PPUSH
22734: LD_INT 1
22736: PPUSH
22737: CALL_OW 51
// p := 0 ;
22741: LD_ADDR_VAR 0 2
22745: PUSH
22746: LD_INT 0
22748: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22749: LD_INT 35
22751: PPUSH
22752: CALL_OW 67
// p := p + 1 ;
22756: LD_ADDR_VAR 0 2
22760: PUSH
22761: LD_VAR 0 2
22765: PUSH
22766: LD_INT 1
22768: PLUS
22769: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
22770: LD_VAR 0 3
22774: PPUSH
22775: CALL_OW 256
22779: PUSH
22780: LD_INT 1000
22782: LESS
22783: IFFALSE 22797
// SetLives ( un , 1000 ) ;
22785: LD_VAR 0 3
22789: PPUSH
22790: LD_INT 1000
22792: PPUSH
22793: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
22797: LD_VAR 0 3
22801: PPUSH
22802: LD_INT 81
22804: PUSH
22805: LD_OWVAR 2
22809: PUSH
22810: EMPTY
22811: LIST
22812: LIST
22813: PUSH
22814: LD_INT 91
22816: PUSH
22817: LD_VAR 0 3
22821: PUSH
22822: LD_INT 30
22824: PUSH
22825: EMPTY
22826: LIST
22827: LIST
22828: LIST
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: PPUSH
22834: CALL_OW 69
22838: PPUSH
22839: LD_VAR 0 3
22843: PPUSH
22844: CALL_OW 74
22848: PPUSH
22849: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
22853: LD_VAR 0 2
22857: PUSH
22858: LD_INT 60
22860: GREATER
22861: PUSH
22862: LD_VAR 0 3
22866: PPUSH
22867: CALL_OW 301
22871: OR
22872: IFFALSE 22749
// if un then
22874: LD_VAR 0 3
22878: IFFALSE 22889
// RemoveUnit ( un ) ;
22880: LD_VAR 0 3
22884: PPUSH
22885: CALL_OW 64
// end ; end_of_file end_of_file
22889: PPOPN 3
22891: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
22892: GO 22894
22894: DISABLE
// begin ru_radar := 98 ;
22895: LD_ADDR_EXP 90
22899: PUSH
22900: LD_INT 98
22902: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
22903: LD_ADDR_EXP 91
22907: PUSH
22908: LD_INT 89
22910: ST_TO_ADDR
// us_hack := 99 ;
22911: LD_ADDR_EXP 92
22915: PUSH
22916: LD_INT 99
22918: ST_TO_ADDR
// us_artillery := 97 ;
22919: LD_ADDR_EXP 93
22923: PUSH
22924: LD_INT 97
22926: ST_TO_ADDR
// ar_bio_bomb := 91 ;
22927: LD_ADDR_EXP 94
22931: PUSH
22932: LD_INT 91
22934: ST_TO_ADDR
// tech_Artillery := 80 ;
22935: LD_ADDR_EXP 95
22939: PUSH
22940: LD_INT 80
22942: ST_TO_ADDR
// tech_RadMat := 81 ;
22943: LD_ADDR_EXP 96
22947: PUSH
22948: LD_INT 81
22950: ST_TO_ADDR
// tech_BasicTools := 82 ;
22951: LD_ADDR_EXP 97
22955: PUSH
22956: LD_INT 82
22958: ST_TO_ADDR
// tech_Cargo := 83 ;
22959: LD_ADDR_EXP 98
22963: PUSH
22964: LD_INT 83
22966: ST_TO_ADDR
// tech_Track := 84 ;
22967: LD_ADDR_EXP 99
22971: PUSH
22972: LD_INT 84
22974: ST_TO_ADDR
// tech_Crane := 85 ;
22975: LD_ADDR_EXP 100
22979: PUSH
22980: LD_INT 85
22982: ST_TO_ADDR
// tech_Bulldozer := 86 ;
22983: LD_ADDR_EXP 101
22987: PUSH
22988: LD_INT 86
22990: ST_TO_ADDR
// tech_Hovercraft := 87 ;
22991: LD_ADDR_EXP 102
22995: PUSH
22996: LD_INT 87
22998: ST_TO_ADDR
// end ;
22999: END
