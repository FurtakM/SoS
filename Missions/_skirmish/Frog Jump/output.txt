// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// debug := false ;
   8: LD_ADDR_EXP 6
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// InitVariables ;
  16: CALL 94 0 0
// InitArtifactsPos ;
  20: CALL 9040 0 0
// PrepareAnimals ( 6 , 1 , 1 , cratesArea ) ;
  24: LD_INT 6
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 1
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: CALL 8419 0 4
// PrepareAlliance ;
  40: CALL 339 0 0
// PrepareLegion ;
  44: CALL 1942 0 0
// if debug then
  48: LD_EXP 6
  52: IFFALSE 76
// begin alliance_attack_active := true ;
  54: LD_ADDR_EXP 9
  58: PUSH
  59: LD_INT 1
  61: ST_TO_ADDR
// Difficulty := 2 ;
  62: LD_ADDR_OWVAR 67
  66: PUSH
  67: LD_INT 2
  69: ST_TO_ADDR
// DebugMode ;
  70: CALL 11015 0 0
// end else
  74: GO 89
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  76: LD_ADDR_OWVAR 67
  80: PUSH
  81: LD_INT 0
  83: PPUSH
  84: CALL_OW 426
  88: ST_TO_ADDR
// Action ;
  89: CALL 7239 0 0
// end ;
  93: END
// export Bagins , Davidov , Vervecken ; export player_start_res_sib_bomb , player_start_res_artifact , debug , legion_attacks_active , legion_attack_strenght , alliance_attack_active , alliance_used_artifact_1 , alliance_used_artifact_2 , player_used_sib_bomb , artifacts_mode , artifacts_type , artifacts_pos , artifact_destroyed , sib_rocket_range , player_artifact_loaded , player_artifact_number , player_artifact_icon , player_artifact_icon_2 , player_artifact_researched , player_artifact_active_distance , player_artifact_icon_type , player_artifact_icon_res , player_artifact_time_refresh , player_artifact_time_res , player_side , player_artifact_ready , player_artifact_selected_unit , alliance_attack_strength ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// player_start_res_sib_bomb := false ;
  97: LD_ADDR_EXP 4
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// player_start_res_artifact := false ;
 105: LD_ADDR_EXP 5
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// legion_attacks_active := false ;
 113: LD_ADDR_EXP 7
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// legion_attack_strenght := 3 ;
 121: LD_ADDR_EXP 8
 125: PUSH
 126: LD_INT 3
 128: ST_TO_ADDR
// alliance_attack_strength := 0 ;
 129: LD_ADDR_EXP 31
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// alliance_attack_active := false ;
 137: LD_ADDR_EXP 9
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// alliance_used_artifact_1 := false ;
 145: LD_ADDR_EXP 10
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// alliance_used_artifact_2 := false ;
 153: LD_ADDR_EXP 11
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// artifacts_mode := [ 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: EMPTY
 176: LIST
 177: LIST
 178: LIST
 179: ST_TO_ADDR
// artifacts_type := [ 2 , 3 , 5 ] ;
 180: LD_ADDR_EXP 14
 184: PUSH
 185: LD_INT 2
 187: PUSH
 188: LD_INT 3
 190: PUSH
 191: LD_INT 5
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// artifacts_pos := [ ] ;
 199: LD_ADDR_EXP 15
 203: PUSH
 204: EMPTY
 205: ST_TO_ADDR
// artifact_destroyed := false ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_INT 0
 213: ST_TO_ADDR
// sib_rocket_range := 25 ;
 214: LD_ADDR_EXP 17
 218: PUSH
 219: LD_INT 25
 221: ST_TO_ADDR
// player_used_sib_bomb := false ;
 222: LD_ADDR_EXP 12
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// player_artifact_loaded := true ;
 230: LD_ADDR_EXP 18
 234: PUSH
 235: LD_INT 1
 237: ST_TO_ADDR
// player_artifact_number := 6 ;
 238: LD_ADDR_EXP 19
 242: PUSH
 243: LD_INT 6
 245: ST_TO_ADDR
// player_artifact_icon := art_use_human ;
 246: LD_ADDR_EXP 20
 250: PUSH
 251: LD_INT 10
 253: ST_TO_ADDR
// player_artifact_icon_2 := art_use_teleport ;
 254: LD_ADDR_EXP 21
 258: PUSH
 259: LD_INT 6
 261: ST_TO_ADDR
// player_artifact_researched := false ;
 262: LD_ADDR_EXP 22
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// player_artifact_active_distance := 5 ;
 270: LD_ADDR_EXP 23
 274: PUSH
 275: LD_INT 5
 277: ST_TO_ADDR
// player_artifact_time_refresh := 8500 ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 8500
 285: ST_TO_ADDR
// player_artifact_icon_type := art_place ;
 286: LD_ADDR_EXP 24
 290: PUSH
 291: LD_INT 3
 293: ST_TO_ADDR
// player_artifact_icon_res := art_exp_left ;
 294: LD_ADDR_EXP 25
 298: PUSH
 299: LD_INT 1
 301: ST_TO_ADDR
// player_artifact_time_res := 300 ;
 302: LD_ADDR_EXP 27
 306: PUSH
 307: LD_INT 300
 309: ST_TO_ADDR
// player_artifact_ready := false ;
 310: LD_ADDR_EXP 29
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// player_artifact_selected_unit := 0 ;
 318: LD_ADDR_EXP 30
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// player_side := 6 ;
 326: LD_ADDR_EXP 28
 330: PUSH
 331: LD_INT 6
 333: ST_TO_ADDR
// end ; end_of_file
 334: LD_VAR 0 1
 338: RET
// export al_force ; export function PrepareAlliance ; var i , un , skill ; begin
 339: LD_INT 0
 341: PPUSH
 342: PPUSH
 343: PPUSH
 344: PPUSH
// uc_side := 7 ;
 345: LD_ADDR_OWVAR 20
 349: PUSH
 350: LD_INT 7
 352: ST_TO_ADDR
// uc_nation := nation_american ;
 353: LD_ADDR_OWVAR 21
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
 361: LD_ADDR_VAR 0 4
 365: PUSH
 366: LD_INT 7
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 9
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: PUSH
 380: LD_OWVAR 67
 384: ARRAY
 385: ST_TO_ADDR
// al_force := [ ] ;
 386: LD_ADDR_EXP 32
 390: PUSH
 391: EMPTY
 392: ST_TO_ADDR
// SetResourceType ( GetBase ( al_dep ) , mat_cans , 999999 ) ;
 393: LD_INT 1
 395: PPUSH
 396: CALL_OW 274
 400: PPUSH
 401: LD_INT 1
 403: PPUSH
 404: LD_INT 999999
 406: PPUSH
 407: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_oil , 10000 ) ;
 411: LD_INT 1
 413: PPUSH
 414: CALL_OW 274
 418: PPUSH
 419: LD_INT 2
 421: PPUSH
 422: LD_INT 10000
 424: PPUSH
 425: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_siberit , 10000 ) ;
 429: LD_INT 1
 431: PPUSH
 432: CALL_OW 274
 436: PPUSH
 437: LD_INT 3
 439: PPUSH
 440: LD_INT 10000
 442: PPUSH
 443: CALL_OW 277
// hc_gallery := sandal ;
 447: LD_ADDR_OWVAR 33
 451: PUSH
 452: LD_STRING sandal
 454: ST_TO_ADDR
// hc_face_number := 13 ;
 455: LD_ADDR_OWVAR 34
 459: PUSH
 460: LD_INT 13
 462: ST_TO_ADDR
// hc_class := 1 ;
 463: LD_ADDR_OWVAR 28
 467: PUSH
 468: LD_INT 1
 470: ST_TO_ADDR
// hc_name := Matthew Bagins ;
 471: LD_ADDR_OWVAR 26
 475: PUSH
 476: LD_STRING Matthew Bagins
 478: ST_TO_ADDR
// hc_skills := [ 10 , 5 , 8 , 5 ] ;
 479: LD_ADDR_OWVAR 31
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: LD_INT 5
 489: PUSH
 490: LD_INT 8
 492: PUSH
 493: LD_INT 5
 495: PUSH
 496: EMPTY
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: ST_TO_ADDR
// hc_attr := [ 11 , 12 ] ;
 502: LD_ADDR_OWVAR 29
 506: PUSH
 507: LD_INT 11
 509: PUSH
 510: LD_INT 12
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: ST_TO_ADDR
// Bagins := CreateHuman ;
 517: LD_ADDR_EXP 1
 521: PUSH
 522: CALL_OW 44
 526: ST_TO_ADDR
// PlaceHumanInUnit ( Bagins , al_dep ) ;
 527: LD_EXP 1
 531: PPUSH
 532: LD_INT 1
 534: PPUSH
 535: CALL_OW 52
// hc_gallery :=  ;
 539: LD_ADDR_OWVAR 33
 543: PUSH
 544: LD_STRING 
 546: ST_TO_ADDR
// hc_name :=  ;
 547: LD_ADDR_OWVAR 26
 551: PUSH
 552: LD_STRING 
 554: ST_TO_ADDR
// for i = 1 to 6 do
 555: LD_ADDR_VAR 0 2
 559: PUSH
 560: DOUBLE
 561: LD_INT 1
 563: DEC
 564: ST_TO_ADDR
 565: LD_INT 6
 567: PUSH
 568: FOR_TO
 569: IFFALSE 630
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 571: LD_ADDR_OWVAR 21
 575: PUSH
 576: LD_INT 1
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: PUSH
 586: LD_INT 1
 588: PPUSH
 589: LD_INT 2
 591: PPUSH
 592: CALL_OW 12
 596: ARRAY
 597: ST_TO_ADDR
// PrepareHuman ( false , class_engineer , skill ) ;
 598: LD_INT 0
 600: PPUSH
 601: LD_INT 2
 603: PPUSH
 604: LD_VAR 0 4
 608: PPUSH
 609: CALL_OW 380
// PlaceUnitArea ( CreateHuman , al_base , false ) ;
 613: CALL_OW 44
 617: PPUSH
 618: LD_INT 1
 620: PPUSH
 621: LD_INT 0
 623: PPUSH
 624: CALL_OW 49
// end ;
 628: GO 568
 630: POP
 631: POP
// for i = 1 to 6 do
 632: LD_ADDR_VAR 0 2
 636: PUSH
 637: DOUBLE
 638: LD_INT 1
 640: DEC
 641: ST_TO_ADDR
 642: LD_INT 6
 644: PUSH
 645: FOR_TO
 646: IFFALSE 704
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 648: LD_ADDR_OWVAR 21
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 3
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: PUSH
 663: LD_INT 1
 665: PPUSH
 666: LD_INT 2
 668: PPUSH
 669: CALL_OW 12
 673: ARRAY
 674: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 675: LD_INT 0
 677: PPUSH
 678: LD_INT 3
 680: PPUSH
 681: LD_VAR 0 4
 685: PPUSH
 686: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_ru ) ;
 690: CALL_OW 44
 694: PPUSH
 695: LD_INT 6
 697: PPUSH
 698: CALL_OW 52
// end ;
 702: GO 645
 704: POP
 705: POP
// for i = 1 to 6 do
 706: LD_ADDR_VAR 0 2
 710: PUSH
 711: DOUBLE
 712: LD_INT 1
 714: DEC
 715: ST_TO_ADDR
 716: LD_INT 6
 718: PUSH
 719: FOR_TO
 720: IFFALSE 778
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 722: LD_ADDR_OWVAR 21
 726: PUSH
 727: LD_INT 1
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: PUSH
 737: LD_INT 1
 739: PPUSH
 740: LD_INT 2
 742: PPUSH
 743: CALL_OW 12
 747: ARRAY
 748: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 749: LD_INT 0
 751: PPUSH
 752: LD_INT 3
 754: PPUSH
 755: LD_VAR 0 4
 759: PPUSH
 760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_us ) ;
 764: CALL_OW 44
 768: PPUSH
 769: LD_INT 11
 771: PPUSH
 772: CALL_OW 52
// end ;
 776: GO 719
 778: POP
 779: POP
// for i = 1 to 6 do
 780: LD_ADDR_VAR 0 2
 784: PUSH
 785: DOUBLE
 786: LD_INT 1
 788: DEC
 789: ST_TO_ADDR
 790: LD_INT 6
 792: PUSH
 793: FOR_TO
 794: IFFALSE 871
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 796: LD_ADDR_OWVAR 21
 800: PUSH
 801: LD_INT 1
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: PUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 2
 816: PPUSH
 817: CALL_OW 12
 821: ARRAY
 822: ST_TO_ADDR
// PrepareHuman ( false , class_scientistic , skill ) ;
 823: LD_INT 0
 825: PPUSH
 826: LD_INT 4
 828: PPUSH
 829: LD_VAR 0 4
 833: PPUSH
 834: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , [ al_lab_us , al_lab_ru ] [ Rand ( 1 , 2 ) ] ) ;
 838: CALL_OW 44
 842: PPUSH
 843: LD_INT 2
 845: PUSH
 846: LD_INT 5
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_INT 2
 858: PPUSH
 859: CALL_OW 12
 863: ARRAY
 864: PPUSH
 865: CALL_OW 52
// end ;
 869: GO 793
 871: POP
 872: POP
// for i = 1 to 6 do
 873: LD_ADDR_VAR 0 2
 877: PUSH
 878: DOUBLE
 879: LD_INT 1
 881: DEC
 882: ST_TO_ADDR
 883: LD_INT 6
 885: PUSH
 886: FOR_TO
 887: IFFALSE 994
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 889: LD_ADDR_OWVAR 21
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 3
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PUSH
 904: LD_INT 1
 906: PPUSH
 907: LD_INT 2
 909: PPUSH
 910: CALL_OW 12
 914: ARRAY
 915: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker ] [ Rand ( 1 , 2 ) ] , skill ) ;
 916: LD_INT 0
 918: PPUSH
 919: LD_INT 5
 921: PUSH
 922: LD_INT 9
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PUSH
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 2
 934: PPUSH
 935: CALL_OW 12
 939: ARRAY
 940: PPUSH
 941: LD_VAR 0 4
 945: PPUSH
 946: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 950: CALL_OW 44
 954: PPUSH
 955: LD_INT 22
 957: PUSH
 958: LD_INT 7
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PUSH
 965: LD_INT 30
 967: PUSH
 968: LD_INT 5
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PPUSH
 979: CALL_OW 69
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: CALL_OW 52
// end ;
 992: GO 886
 994: POP
 995: POP
// uc_nation := 3 ;
 996: LD_ADDR_OWVAR 21
1000: PUSH
1001: LD_INT 3
1003: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , skill ) ;
1004: LD_INT 0
1006: PPUSH
1007: LD_INT 5
1009: PPUSH
1010: LD_VAR 0 4
1014: PPUSH
1015: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_bun ) ;
1019: CALL_OW 44
1023: PPUSH
1024: LD_INT 50
1026: PPUSH
1027: CALL_OW 52
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) do
1031: LD_ADDR_VAR 0 2
1035: PUSH
1036: LD_INT 22
1038: PUSH
1039: LD_INT 7
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: PUSH
1046: LD_INT 30
1048: PUSH
1049: LD_INT 33
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: PUSH
1056: EMPTY
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL_OW 69
1064: PUSH
1065: FOR_IN
1066: IFFALSE 1130
// if GetNation ( i ) = 1 then
1068: LD_VAR 0 2
1072: PPUSH
1073: CALL_OW 248
1077: PUSH
1078: LD_INT 1
1080: EQUAL
1081: IFFALSE 1097
// AddComPlaceWeapon ( i , us_double_laser ) else
1083: LD_VAR 0 2
1087: PPUSH
1088: LD_INT 10
1090: PPUSH
1091: CALL_OW 208
1095: GO 1128
// AddComPlaceWeapon ( i , [ ru_rocket , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
1097: LD_VAR 0 2
1101: PPUSH
1102: LD_INT 47
1104: PUSH
1105: LD_INT 45
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PUSH
1112: LD_INT 1
1114: PPUSH
1115: LD_INT 2
1117: PPUSH
1118: CALL_OW 12
1122: ARRAY
1123: PPUSH
1124: CALL_OW 208
1128: GO 1065
1130: POP
1131: POP
// end ;
1132: LD_VAR 0 1
1136: RET
// export function ConstructAlVeh ( nation ) ; var i , un , fac , chassis , engine , control , weapon ; begin
1137: LD_INT 0
1139: PPUSH
1140: PPUSH
1141: PPUSH
1142: PPUSH
1143: PPUSH
1144: PPUSH
1145: PPUSH
1146: PPUSH
// if nation = 2 then
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 2
1154: EQUAL
1155: IFFALSE 1159
// exit ;
1157: GO 1378
// if nation = 1 then
1159: LD_VAR 0 1
1163: PUSH
1164: LD_INT 1
1166: EQUAL
1167: IFFALSE 1185
// if al_fac_us then
1169: LD_INT 11
1171: IFFALSE 1183
// fac := al_fac_us else
1173: LD_ADDR_VAR 0 5
1177: PUSH
1178: LD_INT 11
1180: ST_TO_ADDR
1181: GO 1185
// exit ;
1183: GO 1378
// if nation = 3 then
1185: LD_VAR 0 1
1189: PUSH
1190: LD_INT 3
1192: EQUAL
1193: IFFALSE 1211
// if al_fac_ru then
1195: LD_INT 6
1197: IFFALSE 1209
// fac := al_fac_ru else
1199: LD_ADDR_VAR 0 5
1203: PUSH
1204: LD_INT 6
1206: ST_TO_ADDR
1207: GO 1211
// exit ;
1209: GO 1378
// if nation = 1 then
1211: LD_VAR 0 1
1215: PUSH
1216: LD_INT 1
1218: EQUAL
1219: IFFALSE 1231
// chassis := us_morphling else
1221: LD_ADDR_VAR 0 6
1225: PUSH
1226: LD_INT 5
1228: ST_TO_ADDR
1229: GO 1239
// chassis := ru_heavy_tracked ;
1231: LD_ADDR_VAR 0 6
1235: PUSH
1236: LD_INT 24
1238: ST_TO_ADDR
// if nation = 1 then
1239: LD_VAR 0 1
1243: PUSH
1244: LD_INT 1
1246: EQUAL
1247: IFFALSE 1259
// engine := engine_combustion else
1249: LD_ADDR_VAR 0 7
1253: PUSH
1254: LD_INT 1
1256: ST_TO_ADDR
1257: GO 1267
// engine := engine_siberite ;
1259: LD_ADDR_VAR 0 7
1263: PUSH
1264: LD_INT 3
1266: ST_TO_ADDR
// control := control_computer ;
1267: LD_ADDR_VAR 0 8
1271: PUSH
1272: LD_INT 3
1274: ST_TO_ADDR
// if nation = 3 then
1275: LD_VAR 0 1
1279: PUSH
1280: LD_INT 3
1282: EQUAL
1283: IFFALSE 1306
// weapon := [ ru_rocket , ru_rocket_launcher , ru_gatling_gun ] else
1285: LD_ADDR_VAR 0 9
1289: PUSH
1290: LD_INT 47
1292: PUSH
1293: LD_INT 45
1295: PUSH
1296: LD_INT 43
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: LIST
1303: ST_TO_ADDR
1304: GO 1325
// weapon := [ us_heavy_gun , us_laser , us_double_laser ] ;
1306: LD_ADDR_VAR 0 9
1310: PUSH
1311: LD_INT 6
1313: PUSH
1314: LD_INT 9
1316: PUSH
1317: LD_INT 10
1319: PUSH
1320: EMPTY
1321: LIST
1322: LIST
1323: LIST
1324: ST_TO_ADDR
// weapon := weapon [ rand ( 1 , weapon ) ] ;
1325: LD_ADDR_VAR 0 9
1329: PUSH
1330: LD_VAR 0 9
1334: PUSH
1335: LD_INT 1
1337: PPUSH
1338: LD_VAR 0 9
1342: PPUSH
1343: CALL_OW 12
1347: ARRAY
1348: ST_TO_ADDR
// AddComConstruct ( fac , chassis , engine , control , weapon ) ;
1349: LD_VAR 0 5
1353: PPUSH
1354: LD_VAR 0 6
1358: PPUSH
1359: LD_VAR 0 7
1363: PPUSH
1364: LD_VAR 0 8
1368: PPUSH
1369: LD_VAR 0 9
1373: PPUSH
1374: CALL_OW 185
// end ;
1378: LD_VAR 0 2
1382: RET
// every 0 0$01 trigger FilterUnitsInArea ( al_teleport_enter , [ [ f_side , 7 ] , [ f_not , [ f_type , unit_building ] ] ] ) do var tmp , i , xy ;
1383: LD_INT 4
1385: PPUSH
1386: LD_INT 22
1388: PUSH
1389: LD_INT 7
1391: PUSH
1392: EMPTY
1393: LIST
1394: LIST
1395: PUSH
1396: LD_INT 3
1398: PUSH
1399: LD_INT 21
1401: PUSH
1402: LD_INT 3
1404: PUSH
1405: EMPTY
1406: LIST
1407: LIST
1408: PUSH
1409: EMPTY
1410: LIST
1411: LIST
1412: PUSH
1413: EMPTY
1414: LIST
1415: LIST
1416: PPUSH
1417: CALL_OW 70
1421: IFFALSE 1565
1423: GO 1425
1425: DISABLE
1426: LD_INT 0
1428: PPUSH
1429: PPUSH
1430: PPUSH
// begin enable ;
1431: ENABLE
// tmp := FilterUnitsInArea ( al_teleport_enter , [ [ f_side , 7 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
1432: LD_ADDR_VAR 0 1
1436: PUSH
1437: LD_INT 4
1439: PPUSH
1440: LD_INT 22
1442: PUSH
1443: LD_INT 7
1445: PUSH
1446: EMPTY
1447: LIST
1448: LIST
1449: PUSH
1450: LD_INT 3
1452: PUSH
1453: LD_INT 21
1455: PUSH
1456: LD_INT 3
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: PPUSH
1471: CALL_OW 70
1475: ST_TO_ADDR
// xy := [ 225 , 16 ] ;
1476: LD_ADDR_VAR 0 3
1480: PUSH
1481: LD_INT 225
1483: PUSH
1484: LD_INT 16
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// if Prob ( 50 ) then
1491: LD_INT 50
1493: PPUSH
1494: CALL_OW 13
1498: IFFALSE 1515
// xy := [ 170 , 13 ] ;
1500: LD_ADDR_VAR 0 3
1504: PUSH
1505: LD_INT 170
1507: PUSH
1508: LD_INT 13
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: ST_TO_ADDR
// for i in tmp do
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 1
1524: PUSH
1525: FOR_IN
1526: IFFALSE 1563
// TeleportUnit ( i , xy [ 1 ] , xy [ 2 ] , 12 , true ) ;
1528: LD_VAR 0 2
1532: PPUSH
1533: LD_VAR 0 3
1537: PUSH
1538: LD_INT 1
1540: ARRAY
1541: PPUSH
1542: LD_VAR 0 3
1546: PUSH
1547: LD_INT 2
1549: ARRAY
1550: PPUSH
1551: LD_INT 12
1553: PPUSH
1554: LD_INT 1
1556: PPUSH
1557: CALL_OW 483
1561: GO 1525
1563: POP
1564: POP
// end ;
1565: PPOPN 3
1567: END
// every 12 12$00 trigger FilterAllUnits ( [ f_side , 7 ] ) and alliance_attack_active do var i ;
1568: LD_INT 22
1570: PUSH
1571: LD_INT 7
1573: PUSH
1574: EMPTY
1575: LIST
1576: LIST
1577: PPUSH
1578: CALL_OW 69
1582: PUSH
1583: LD_EXP 9
1587: AND
1588: IFFALSE 1735
1590: GO 1592
1592: DISABLE
1593: LD_INT 0
1595: PPUSH
// begin enable ;
1596: ENABLE
// alliance_attack_strength := alliance_attack_strength + 1 ;
1597: LD_ADDR_EXP 31
1601: PUSH
1602: LD_EXP 31
1606: PUSH
1607: LD_INT 1
1609: PLUS
1610: ST_TO_ADDR
// for i = 1 to ( [ 4 , 5 , 5 ] [ Difficulty ] ) + alliance_attack_strength do
1611: LD_ADDR_VAR 0 1
1615: PUSH
1616: DOUBLE
1617: LD_INT 1
1619: DEC
1620: ST_TO_ADDR
1621: LD_INT 4
1623: PUSH
1624: LD_INT 5
1626: PUSH
1627: LD_INT 5
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: LIST
1634: PUSH
1635: LD_OWVAR 67
1639: ARRAY
1640: PUSH
1641: LD_EXP 31
1645: PLUS
1646: PUSH
1647: FOR_TO
1648: IFFALSE 1678
// begin ConstructAlVeh ( [ 1 , 3 ] [ rand ( 1 , 2 ) ] ) ;
1650: LD_INT 1
1652: PUSH
1653: LD_INT 3
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: LD_INT 1
1662: PPUSH
1663: LD_INT 2
1665: PPUSH
1666: CALL_OW 12
1670: ARRAY
1671: PPUSH
1672: CALL 1137 0 1
// end ;
1676: GO 1647
1678: POP
1679: POP
// repeat wait ( 0 0$01 ) ;
1680: LD_INT 35
1682: PPUSH
1683: CALL_OW 67
// until al_force >= ( [ 4 , 5 , 5 ] [ Difficulty ] ) + alliance_attack_strength ;
1687: LD_EXP 32
1691: PUSH
1692: LD_INT 4
1694: PUSH
1695: LD_INT 5
1697: PUSH
1698: LD_INT 5
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: PUSH
1706: LD_OWVAR 67
1710: ARRAY
1711: PUSH
1712: LD_EXP 31
1716: PLUS
1717: GREATEREQUAL
1718: IFFALSE 1680
// AddComMoveXY ( al_force , 143 , 178 ) ;
1720: LD_EXP 32
1724: PPUSH
1725: LD_INT 143
1727: PPUSH
1728: LD_INT 178
1730: PPUSH
1731: CALL_OW 171
// end ;
1735: PPOPN 1
1737: END
// every 0 0$01 trigger FilterUnitsInArea ( islandArea , [ f_side , 7 ] ) do var i ;
1738: LD_INT 6
1740: PPUSH
1741: LD_INT 22
1743: PUSH
1744: LD_INT 7
1746: PUSH
1747: EMPTY
1748: LIST
1749: LIST
1750: PPUSH
1751: CALL_OW 70
1755: IFFALSE 1835
1757: GO 1759
1759: DISABLE
1760: LD_INT 0
1762: PPUSH
// begin enable ;
1763: ENABLE
// for i in FilterUnitsInArea ( islandArea , [ f_side , 7 ] ) do
1764: LD_ADDR_VAR 0 1
1768: PUSH
1769: LD_INT 6
1771: PPUSH
1772: LD_INT 22
1774: PUSH
1775: LD_INT 7
1777: PUSH
1778: EMPTY
1779: LIST
1780: LIST
1781: PPUSH
1782: CALL_OW 70
1786: PUSH
1787: FOR_IN
1788: IFFALSE 1833
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ) ;
1790: LD_VAR 0 1
1794: PPUSH
1795: LD_INT 81
1797: PUSH
1798: LD_VAR 0 1
1802: PPUSH
1803: CALL_OW 255
1807: PUSH
1808: EMPTY
1809: LIST
1810: LIST
1811: PPUSH
1812: CALL_OW 69
1816: PPUSH
1817: LD_VAR 0 1
1821: PPUSH
1822: CALL_OW 74
1826: PPUSH
1827: CALL_OW 115
1831: GO 1787
1833: POP
1834: POP
// end ;
1835: PPOPN 1
1837: END
// every 7 7$30 trigger alliance_attack_active do var reload_time ;
1838: LD_EXP 9
1842: IFFALSE 1939
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
// begin reload_time := [ 9 9$00 , 8 8$40 , 7 7$50 ] [ Difficulty ] ;
1850: LD_ADDR_VAR 0 1
1854: PUSH
1855: LD_INT 18900
1857: PUSH
1858: LD_INT 18200
1860: PUSH
1861: LD_INT 16450
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: LIST
1868: PUSH
1869: LD_OWVAR 67
1873: ARRAY
1874: ST_TO_ADDR
// repeat ActiveArtifact1 ( ) ;
1875: CALL 10450 0 0
// wait ( reload_time / 2 ) ;
1879: LD_VAR 0 1
1883: PUSH
1884: LD_INT 2
1886: DIVREAL
1887: PPUSH
1888: CALL_OW 67
// ActiveArtifact2 ( ) ;
1892: CALL 10835 0 0
// wait ( reload_time / 2 ) ;
1896: LD_VAR 0 1
1900: PUSH
1901: LD_INT 2
1903: DIVREAL
1904: PPUSH
1905: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) ;
1909: LD_INT 22
1911: PUSH
1912: LD_INT 7
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: PUSH
1919: LD_INT 30
1921: PUSH
1922: LD_INT 8
1924: PUSH
1925: EMPTY
1926: LIST
1927: LIST
1928: PUSH
1929: EMPTY
1930: LIST
1931: LIST
1932: PPUSH
1933: CALL_OW 69
1937: IFFALSE 1875
// end ; end_of_file
1939: PPOPN 1
1941: END
// export function PrepareLegion ; var i , un , skill , dep , fac ; begin
1942: LD_INT 0
1944: PPUSH
1945: PPUSH
1946: PPUSH
1947: PPUSH
1948: PPUSH
1949: PPUSH
// uc_side := 8 ;
1950: LD_ADDR_OWVAR 20
1954: PUSH
1955: LD_INT 8
1957: ST_TO_ADDR
// uc_nation := 2 ;
1958: LD_ADDR_OWVAR 21
1962: PUSH
1963: LD_INT 2
1965: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
1966: LD_ADDR_VAR 0 4
1970: PUSH
1971: LD_INT 7
1973: PUSH
1974: LD_INT 8
1976: PUSH
1977: LD_INT 9
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_OWVAR 67
1989: ARRAY
1990: ST_TO_ADDR
// dep := ar_base ;
1991: LD_ADDR_VAR 0 5
1995: PUSH
1996: LD_INT 57
1998: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
1999: LD_ADDR_VAR 0 6
2003: PUSH
2004: LD_INT 22
2006: PUSH
2007: LD_INT 8
2009: PUSH
2010: EMPTY
2011: LIST
2012: LIST
2013: PUSH
2014: LD_INT 30
2016: PUSH
2017: LD_INT 3
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: PUSH
2024: EMPTY
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 69
2032: PUSH
2033: LD_INT 1
2035: ARRAY
2036: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 999999 ) ;
2037: LD_VAR 0 5
2041: PPUSH
2042: CALL_OW 274
2046: PPUSH
2047: LD_INT 1
2049: PPUSH
2050: LD_INT 999999
2052: PPUSH
2053: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
2057: LD_VAR 0 5
2061: PPUSH
2062: CALL_OW 274
2066: PPUSH
2067: LD_INT 2
2069: PPUSH
2070: LD_INT 10000
2072: PPUSH
2073: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 10000 ) ;
2077: LD_VAR 0 5
2081: PPUSH
2082: CALL_OW 274
2086: PPUSH
2087: LD_INT 3
2089: PPUSH
2090: LD_INT 10000
2092: PPUSH
2093: CALL_OW 277
// TeleportExit ( legion_telep , 224 , 5 ) ;
2097: LD_INT 68
2099: PPUSH
2100: LD_INT 224
2102: PPUSH
2103: LD_INT 5
2105: PPUSH
2106: CALL_OW 243
// PrepareHuman ( sex_male , 1 , 6 ) ;
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 1
2115: PPUSH
2116: LD_INT 6
2118: PPUSH
2119: CALL_OW 380
// hc_name := Nicolas Vervecken ;
2123: LD_ADDR_OWVAR 26
2127: PUSH
2128: LD_STRING Nicolas Vervecken
2130: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2131: LD_ADDR_OWVAR 33
2135: PUSH
2136: LD_STRING SecondCharsGal
2138: ST_TO_ADDR
// hc_face_number := 3 ;
2139: LD_ADDR_OWVAR 34
2143: PUSH
2144: LD_INT 3
2146: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2147: LD_ADDR_OWVAR 29
2151: PUSH
2152: LD_INT 11
2154: PUSH
2155: LD_INT 10
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: ST_TO_ADDR
// Vervecken := CreateHuman ;
2162: LD_ADDR_EXP 3
2166: PUSH
2167: CALL_OW 44
2171: ST_TO_ADDR
// PlaceHumanInUnit ( Vervecken , dep ) ;
2172: LD_EXP 3
2176: PPUSH
2177: LD_VAR 0 5
2181: PPUSH
2182: CALL_OW 52
// InitHc ;
2186: CALL_OW 19
// for i = 1 to 4 do
2190: LD_ADDR_VAR 0 2
2194: PUSH
2195: DOUBLE
2196: LD_INT 1
2198: DEC
2199: ST_TO_ADDR
2200: LD_INT 4
2202: PUSH
2203: FOR_TO
2204: IFFALSE 2265
// begin PrepareHuman ( false , class_bazooker , skill ) ;
2206: LD_INT 0
2208: PPUSH
2209: LD_INT 9
2211: PPUSH
2212: LD_VAR 0 4
2216: PPUSH
2217: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
2221: CALL_OW 44
2225: PPUSH
2226: LD_INT 22
2228: PUSH
2229: LD_INT 8
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: PUSH
2236: LD_INT 30
2238: PUSH
2239: LD_INT 5
2241: PUSH
2242: EMPTY
2243: LIST
2244: LIST
2245: PUSH
2246: EMPTY
2247: LIST
2248: LIST
2249: PPUSH
2250: CALL_OW 69
2254: PUSH
2255: LD_INT 1
2257: ARRAY
2258: PPUSH
2259: CALL_OW 52
// end ;
2263: GO 2203
2265: POP
2266: POP
// for i = 1 to 2 do
2267: LD_ADDR_VAR 0 2
2271: PUSH
2272: DOUBLE
2273: LD_INT 1
2275: DEC
2276: ST_TO_ADDR
2277: LD_INT 2
2279: PUSH
2280: FOR_TO
2281: IFFALSE 2342
// begin PrepareHuman ( false , 4 , skill ) ;
2283: LD_INT 0
2285: PPUSH
2286: LD_INT 4
2288: PPUSH
2289: LD_VAR 0 4
2293: PPUSH
2294: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
2298: CALL_OW 44
2302: PPUSH
2303: LD_INT 22
2305: PUSH
2306: LD_INT 8
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PUSH
2313: LD_INT 30
2315: PUSH
2316: LD_INT 8
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PPUSH
2327: CALL_OW 69
2331: PUSH
2332: LD_INT 1
2334: ARRAY
2335: PPUSH
2336: CALL_OW 52
// end ;
2340: GO 2280
2342: POP
2343: POP
// for i = 1 to 6 do
2344: LD_ADDR_VAR 0 2
2348: PUSH
2349: DOUBLE
2350: LD_INT 1
2352: DEC
2353: ST_TO_ADDR
2354: LD_INT 6
2356: PUSH
2357: FOR_TO
2358: IFFALSE 2395
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
2360: LD_INT 0
2362: PPUSH
2363: LD_INT 3
2365: PPUSH
2366: LD_VAR 0 4
2370: PUSH
2371: LD_INT 1
2373: PLUS
2374: PPUSH
2375: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac ) ;
2379: CALL_OW 44
2383: PPUSH
2384: LD_VAR 0 6
2388: PPUSH
2389: CALL_OW 52
// end ;
2393: GO 2357
2395: POP
2396: POP
// uc_nation := 0 ;
2397: LD_ADDR_OWVAR 21
2401: PUSH
2402: LD_INT 0
2404: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) do
2405: LD_ADDR_VAR 0 2
2409: PUSH
2410: LD_INT 22
2412: PUSH
2413: LD_INT 8
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: PUSH
2420: LD_INT 30
2422: PUSH
2423: LD_INT 32
2425: PUSH
2426: EMPTY
2427: LIST
2428: LIST
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: PPUSH
2434: CALL_OW 69
2438: PUSH
2439: FOR_IN
2440: IFFALSE 2477
// begin PrepareHuman ( false , class_apeman_soldier , skill + 1 ) ;
2442: LD_INT 0
2444: PPUSH
2445: LD_INT 15
2447: PPUSH
2448: LD_VAR 0 4
2452: PUSH
2453: LD_INT 1
2455: PLUS
2456: PPUSH
2457: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
2461: CALL_OW 44
2465: PPUSH
2466: LD_VAR 0 2
2470: PPUSH
2471: CALL_OW 52
// end ;
2475: GO 2439
2477: POP
2478: POP
// PrepareHuman ( false , class_sniper , 10 ) ;
2479: LD_INT 0
2481: PPUSH
2482: LD_INT 5
2484: PPUSH
2485: LD_INT 10
2487: PPUSH
2488: CALL_OW 380
// un := CreateHuman ;
2492: LD_ADDR_VAR 0 3
2496: PUSH
2497: CALL_OW 44
2501: ST_TO_ADDR
// PlaceUnitXY ( un , 175 , 128 , false ) ;
2502: LD_VAR 0 3
2506: PPUSH
2507: LD_INT 175
2509: PPUSH
2510: LD_INT 128
2512: PPUSH
2513: LD_INT 0
2515: PPUSH
2516: CALL_OW 48
// ComEnterUnit ( un , ar_ibun ) ;
2520: LD_VAR 0 3
2524: PPUSH
2525: LD_INT 115
2527: PPUSH
2528: CALL_OW 120
// for i = 1 to 2 do
2532: LD_ADDR_VAR 0 2
2536: PUSH
2537: DOUBLE
2538: LD_INT 1
2540: DEC
2541: ST_TO_ADDR
2542: LD_INT 2
2544: PUSH
2545: FOR_TO
2546: IFFALSE 2571
// AddComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
2548: LD_VAR 0 6
2552: PPUSH
2553: LD_INT 14
2555: PPUSH
2556: LD_INT 2
2558: PPUSH
2559: LD_INT 1
2561: PPUSH
2562: LD_INT 31
2564: PPUSH
2565: CALL_OW 185
2569: GO 2545
2571: POP
2572: POP
// end ;
2573: LD_VAR 0 1
2577: RET
// export function PrepareHovercraft ( num ) ; var i ; begin
2578: LD_INT 0
2580: PPUSH
2581: PPUSH
// for i = 1 to num do
2582: LD_ADDR_VAR 0 3
2586: PUSH
2587: DOUBLE
2588: LD_INT 1
2590: DEC
2591: ST_TO_ADDR
2592: LD_VAR 0 1
2596: PUSH
2597: FOR_TO
2598: IFFALSE 2670
// AddComConstruct ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] , ar_hovercraft , engine_combustion , control_remote , [ ar_light_gun , ar_double_machine_gun ] [ rand ( 1 , 2 ) ] ) ;
2600: LD_INT 22
2602: PUSH
2603: LD_INT 8
2605: PUSH
2606: EMPTY
2607: LIST
2608: LIST
2609: PUSH
2610: LD_INT 30
2612: PUSH
2613: LD_INT 3
2615: PUSH
2616: EMPTY
2617: LIST
2618: LIST
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PPUSH
2624: CALL_OW 69
2628: PUSH
2629: LD_INT 1
2631: ARRAY
2632: PPUSH
2633: LD_INT 11
2635: PPUSH
2636: LD_INT 1
2638: PPUSH
2639: LD_INT 2
2641: PPUSH
2642: LD_INT 23
2644: PUSH
2645: LD_INT 24
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PUSH
2652: LD_INT 1
2654: PPUSH
2655: LD_INT 2
2657: PPUSH
2658: CALL_OW 12
2662: ARRAY
2663: PPUSH
2664: CALL_OW 185
2668: GO 2597
2670: POP
2671: POP
// end ;
2672: LD_VAR 0 2
2676: RET
// export function AddKamikaze ( ) ; var i , un ; begin
2677: LD_INT 0
2679: PPUSH
2680: PPUSH
2681: PPUSH
// uc_side := 8 ;
2682: LD_ADDR_OWVAR 20
2686: PUSH
2687: LD_INT 8
2689: ST_TO_ADDR
// uc_nation := 0 ;
2690: LD_ADDR_OWVAR 21
2694: PUSH
2695: LD_INT 0
2697: ST_TO_ADDR
// hc_class := 17 ;
2698: LD_ADDR_OWVAR 28
2702: PUSH
2703: LD_INT 17
2705: ST_TO_ADDR
// hc_gallery :=  ;
2706: LD_ADDR_OWVAR 33
2710: PUSH
2711: LD_STRING 
2713: ST_TO_ADDR
// hc_name :=  ;
2714: LD_ADDR_OWVAR 26
2718: PUSH
2719: LD_STRING 
2721: ST_TO_ADDR
// hc_importance := 0 ;
2722: LD_ADDR_OWVAR 32
2726: PUSH
2727: LD_INT 0
2729: ST_TO_ADDR
// hc_skills := [ 10 , 10 , 10 , 10 ] ;
2730: LD_ADDR_OWVAR 31
2734: PUSH
2735: LD_INT 10
2737: PUSH
2738: LD_INT 10
2740: PUSH
2741: LD_INT 10
2743: PUSH
2744: LD_INT 10
2746: PUSH
2747: EMPTY
2748: LIST
2749: LIST
2750: LIST
2751: LIST
2752: ST_TO_ADDR
// if ar_base then
2753: LD_INT 57
2755: IFFALSE 2800
// begin un := CreateHuman ;
2757: LD_ADDR_VAR 0 3
2761: PUSH
2762: CALL_OW 44
2766: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_base ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 57
2774: PPUSH
2775: CALL_OW 52
// ComExitBuilding ( un ) ;
2779: LD_VAR 0 3
2783: PPUSH
2784: CALL_OW 122
// AddComEnterUnit ( un , legion_telep ) ;
2788: LD_VAR 0 3
2792: PPUSH
2793: LD_INT 68
2795: PPUSH
2796: CALL_OW 180
// end ; end ;
2800: LD_VAR 0 1
2804: RET
// export legion_force , l_allow_attack ; export function PrepareAttack ( n1 , n2 ) ; var i ; begin
2805: LD_INT 0
2807: PPUSH
2808: PPUSH
// legion_force := [ ] ;
2809: LD_ADDR_EXP 33
2813: PUSH
2814: EMPTY
2815: ST_TO_ADDR
// l_allow_attack := false ;
2816: LD_ADDR_EXP 34
2820: PUSH
2821: LD_INT 0
2823: ST_TO_ADDR
// PrepareHovercraft ( n1 ) ;
2824: LD_VAR 0 1
2828: PPUSH
2829: CALL 2578 0 1
// repeat wait ( 0 0$01 ) ;
2833: LD_INT 35
2835: PPUSH
2836: CALL_OW 67
// until legion_force = n1 ;
2840: LD_EXP 33
2844: PUSH
2845: LD_VAR 0 1
2849: EQUAL
2850: IFFALSE 2833
// l_allow_attack := true ;
2852: LD_ADDR_EXP 34
2856: PUSH
2857: LD_INT 1
2859: ST_TO_ADDR
// for i = 1 to n2 do
2860: LD_ADDR_VAR 0 4
2864: PUSH
2865: DOUBLE
2866: LD_INT 1
2868: DEC
2869: ST_TO_ADDR
2870: LD_VAR 0 2
2874: PUSH
2875: FOR_TO
2876: IFFALSE 2884
// begin AddKamikaze ( ) ;
2878: CALL 2677 0 0
// end ;
2882: GO 2875
2884: POP
2885: POP
// ComBrutalAttack ( legion_force , 6 ) ;
2886: LD_EXP 33
2890: PPUSH
2891: LD_INT 6
2893: PPUSH
2894: CALL 6530 0 2
// end ;
2898: LD_VAR 0 3
2902: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
2903: LD_INT 22
2905: PUSH
2906: LD_INT 8
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: PUSH
2913: LD_INT 33
2915: PUSH
2916: LD_INT 2
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: PPUSH
2927: CALL_OW 69
2931: IFFALSE 3143
2933: GO 2935
2935: DISABLE
2936: LD_INT 0
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
2942: PPUSH
2943: PPUSH
2944: PPUSH
// begin enable ;
2945: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
2946: LD_ADDR_VAR 0 4
2950: PUSH
2951: LD_INT 22
2953: PUSH
2954: LD_INT 8
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 33
2963: PUSH
2964: LD_INT 2
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: LD_INT 3
2973: PUSH
2974: LD_INT 61
2976: PUSH
2977: EMPTY
2978: LIST
2979: PUSH
2980: EMPTY
2981: LIST
2982: LIST
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: PPUSH
2989: CALL_OW 69
2993: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ;
2994: LD_ADDR_VAR 0 3
2998: PUSH
2999: LD_INT 22
3001: PUSH
3002: LD_INT 8
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PUSH
3009: LD_INT 34
3011: PUSH
3012: LD_INT 31
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PPUSH
3023: CALL_OW 69
3027: ST_TO_ADDR
// best := 10 ;
3028: LD_ADDR_VAR 0 5
3032: PUSH
3033: LD_INT 10
3035: ST_TO_ADDR
// best_mechanic := - 1 ;
3036: LD_ADDR_VAR 0 6
3040: PUSH
3041: LD_INT 1
3043: NEG
3044: ST_TO_ADDR
// if vehs then
3045: LD_VAR 0 4
3049: IFFALSE 3143
// begin for j in cts do
3051: LD_ADDR_VAR 0 2
3055: PUSH
3056: LD_VAR 0 3
3060: PUSH
3061: FOR_IN
3062: IFFALSE 3123
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
3064: LD_ADDR_VAR 0 7
3068: PUSH
3069: LD_VAR 0 2
3073: PPUSH
3074: CALL 5208 0 1
3078: PPUSH
3079: CALL_OW 432
3083: ST_TO_ADDR
// if p < best then
3084: LD_VAR 0 7
3088: PUSH
3089: LD_VAR 0 5
3093: LESS
3094: IFFALSE 3121
// begin best := p ;
3096: LD_ADDR_VAR 0 5
3100: PUSH
3101: LD_VAR 0 7
3105: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
3106: LD_ADDR_VAR 0 6
3110: PUSH
3111: LD_VAR 0 2
3115: PPUSH
3116: CALL 5208 0 1
3120: ST_TO_ADDR
// end ; end ;
3121: GO 3061
3123: POP
3124: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
3125: LD_VAR 0 4
3129: PUSH
3130: LD_INT 1
3132: ARRAY
3133: PPUSH
3134: LD_VAR 0 6
3138: PPUSH
3139: CALL_OW 135
// end ; end ;
3143: PPOPN 7
3145: END
// every 5 5$00 trigger legion_attacks_active do
3146: LD_EXP 7
3150: IFFALSE 3202
3152: GO 3154
3154: DISABLE
// begin enable ;
3155: ENABLE
// Wait ( [ 2 2$30 , 1 1$00 , 0 0$30 ] [ Difficulty ] ) ;
3156: LD_INT 5250
3158: PUSH
3159: LD_INT 2100
3161: PUSH
3162: LD_INT 1050
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: LIST
3169: PUSH
3170: LD_OWVAR 67
3174: ARRAY
3175: PPUSH
3176: CALL_OW 67
// PrepareAttack ( ( legion_attack_strenght - 2 + Difficulty ) , 2 ) ;
3180: LD_EXP 8
3184: PUSH
3185: LD_INT 2
3187: MINUS
3188: PUSH
3189: LD_OWVAR 67
3193: PLUS
3194: PPUSH
3195: LD_INT 2
3197: PPUSH
3198: CALL 2805 0 2
// end ;
3202: END
// every 0 0$01 trigger FilterUnitsInArea ( islandArea , [ [ f_side , 8 ] , [ f_class , 17 ] ] ) do var i ;
3203: LD_INT 6
3205: PPUSH
3206: LD_INT 22
3208: PUSH
3209: LD_INT 8
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: PUSH
3216: LD_INT 25
3218: PUSH
3219: LD_INT 17
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: PPUSH
3230: CALL_OW 70
3234: IFFALSE 3321
3236: GO 3238
3238: DISABLE
3239: LD_INT 0
3241: PPUSH
// begin enable ;
3242: ENABLE
// for i in FilterUnitsInArea ( islandArea , [ [ f_side , 8 ] , [ f_class , 17 ] ] ) do
3243: LD_ADDR_VAR 0 1
3247: PUSH
3248: LD_INT 6
3250: PPUSH
3251: LD_INT 22
3253: PUSH
3254: LD_INT 8
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 25
3263: PUSH
3264: LD_INT 17
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: PPUSH
3275: CALL_OW 70
3279: PUSH
3280: FOR_IN
3281: IFFALSE 3319
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , i ) ) ;
3283: LD_VAR 0 1
3287: PPUSH
3288: LD_INT 22
3290: PUSH
3291: LD_INT 6
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL_OW 69
3302: PPUSH
3303: LD_VAR 0 1
3307: PPUSH
3308: CALL_OW 74
3312: PPUSH
3313: CALL_OW 115
3317: GO 3280
3319: POP
3320: POP
// end ;
3321: PPOPN 1
3323: END
// every 6 6$00 trigger legion_telep do var k , xy , i ;
3324: LD_INT 68
3326: IFFALSE 3557
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
// begin enable ;
3336: ENABLE
// xy := [ [ 224 , 5 ] , [ 160 , 4 ] , [ 228 , 56 ] , [ 271 , 87 ] ] ;
3337: LD_ADDR_VAR 0 2
3341: PUSH
3342: LD_INT 224
3344: PUSH
3345: LD_INT 5
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: PUSH
3352: LD_INT 160
3354: PUSH
3355: LD_INT 4
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: PUSH
3362: LD_INT 228
3364: PUSH
3365: LD_INT 56
3367: PUSH
3368: EMPTY
3369: LIST
3370: LIST
3371: PUSH
3372: LD_INT 271
3374: PUSH
3375: LD_INT 87
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: PUSH
3382: EMPTY
3383: LIST
3384: LIST
3385: LIST
3386: LIST
3387: ST_TO_ADDR
// for i = 1 to 3 do
3388: LD_ADDR_VAR 0 3
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_INT 3
3400: PUSH
3401: FOR_TO
3402: IFFALSE 3418
// EraseResourceArea ( telArea , i ) ;
3404: LD_INT 7
3406: PPUSH
3407: LD_VAR 0 3
3411: PPUSH
3412: CALL_OW 286
3416: GO 3401
3418: POP
3419: POP
// for i = xy downto 1 do
3420: LD_ADDR_VAR 0 3
3424: PUSH
3425: DOUBLE
3426: LD_VAR 0 2
3430: INC
3431: ST_TO_ADDR
3432: LD_INT 1
3434: PUSH
3435: FOR_DOWNTO
3436: IFFALSE 3518
// begin k := rand ( 1 , xy ) ;
3438: LD_ADDR_VAR 0 1
3442: PUSH
3443: LD_INT 1
3445: PPUSH
3446: LD_VAR 0 2
3450: PPUSH
3451: CALL_OW 12
3455: ST_TO_ADDR
// if HexInfo ( xy [ k ] [ 1 ] , xy [ k ] [ 2 ] ) then
3456: LD_VAR 0 2
3460: PUSH
3461: LD_VAR 0 1
3465: ARRAY
3466: PUSH
3467: LD_INT 1
3469: ARRAY
3470: PPUSH
3471: LD_VAR 0 2
3475: PUSH
3476: LD_VAR 0 1
3480: ARRAY
3481: PUSH
3482: LD_INT 2
3484: ARRAY
3485: PPUSH
3486: CALL_OW 428
3490: IFFALSE 3514
// xy := Delete ( xy , k ) else
3492: LD_ADDR_VAR 0 2
3496: PUSH
3497: LD_VAR 0 2
3501: PPUSH
3502: LD_VAR 0 1
3506: PPUSH
3507: CALL_OW 3
3511: ST_TO_ADDR
3512: GO 3516
// break ;
3514: GO 3518
// end ;
3516: GO 3435
3518: POP
3519: POP
// TeleportExit ( legion_telep , xy [ k ] [ 1 ] , xy [ k ] [ 2 ] ) ;
3520: LD_INT 68
3522: PPUSH
3523: LD_VAR 0 2
3527: PUSH
3528: LD_VAR 0 1
3532: ARRAY
3533: PUSH
3534: LD_INT 1
3536: ARRAY
3537: PPUSH
3538: LD_VAR 0 2
3542: PUSH
3543: LD_VAR 0 1
3547: ARRAY
3548: PUSH
3549: LD_INT 2
3551: ARRAY
3552: PPUSH
3553: CALL_OW 243
// end ; end_of_file
3557: PPOPN 3
3559: END
// export function PrepareRussian ; var i , skill , un , tmp , amount , k ; begin
3560: LD_INT 0
3562: PPUSH
3563: PPUSH
3564: PPUSH
3565: PPUSH
3566: PPUSH
3567: PPUSH
3568: PPUSH
// uc_side := 6 ;
3569: LD_ADDR_OWVAR 20
3573: PUSH
3574: LD_INT 6
3576: ST_TO_ADDR
// uc_nation := nation_russian ;
3577: LD_ADDR_OWVAR 21
3581: PUSH
3582: LD_INT 3
3584: ST_TO_ADDR
// SetArtifactRes ( 6 , true ) ;
3585: LD_INT 6
3587: PPUSH
3588: LD_INT 1
3590: PPUSH
3591: CALL_OW 467
// amount := [ [ 9 , 4 ] , [ 8 , 3 ] , [ 8 , 2 ] ] [ Difficulty ] ;
3595: LD_ADDR_VAR 0 6
3599: PUSH
3600: LD_INT 9
3602: PUSH
3603: LD_INT 4
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: PUSH
3610: LD_INT 8
3612: PUSH
3613: LD_INT 3
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: LD_INT 8
3622: PUSH
3623: LD_INT 2
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: LIST
3634: PUSH
3635: LD_OWVAR 67
3639: ARRAY
3640: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
3641: LD_ADDR_VAR 0 3
3645: PUSH
3646: LD_INT 9
3648: PUSH
3649: LD_INT 8
3651: PUSH
3652: LD_INT 7
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: LIST
3659: PUSH
3660: LD_OWVAR 67
3664: ARRAY
3665: ST_TO_ADDR
// tmp := [ ] ;
3666: LD_ADDR_VAR 0 5
3670: PUSH
3671: EMPTY
3672: ST_TO_ADDR
// Davidov := NewCharacter ( Davidov ) ;
3673: LD_ADDR_EXP 2
3677: PUSH
3678: LD_STRING Davidov
3680: PPUSH
3681: CALL_OW 25
3685: ST_TO_ADDR
// SetSkill ( Davidov , 1 , 7 ) ;
3686: LD_EXP 2
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 7
3696: PPUSH
3697: CALL_OW 237
// SetSkill ( Davidov , 2 , 8 ) ;
3701: LD_EXP 2
3705: PPUSH
3706: LD_INT 2
3708: PPUSH
3709: LD_INT 8
3711: PPUSH
3712: CALL_OW 237
// SetSkill ( Davidov , 3 , 6 ) ;
3716: LD_EXP 2
3720: PPUSH
3721: LD_INT 3
3723: PPUSH
3724: LD_INT 6
3726: PPUSH
3727: CALL_OW 237
// SetSkill ( Davidov , 4 , 10 ) ;
3731: LD_EXP 2
3735: PPUSH
3736: LD_INT 4
3738: PPUSH
3739: LD_INT 10
3741: PPUSH
3742: CALL_OW 237
// SetClass ( Davidov , 4 ) ;
3746: LD_EXP 2
3750: PPUSH
3751: LD_INT 4
3753: PPUSH
3754: CALL_OW 336
// hc_importance := 0 ;
3758: LD_ADDR_OWVAR 32
3762: PUSH
3763: LD_INT 0
3765: ST_TO_ADDR
// while amount [ 1 ] do
3766: LD_VAR 0 6
3770: PUSH
3771: LD_INT 1
3773: ARRAY
3774: IFFALSE 4107
// begin Wait ( 1 ) ;
3776: LD_INT 1
3778: PPUSH
3779: CALL_OW 67
// k := rand ( 1 , 4 ) ;
3783: LD_ADDR_VAR 0 7
3787: PUSH
3788: LD_INT 1
3790: PPUSH
3791: LD_INT 4
3793: PPUSH
3794: CALL_OW 12
3798: ST_TO_ADDR
// if amount [ 2 ] and tmp then
3799: LD_VAR 0 6
3803: PUSH
3804: LD_INT 2
3806: ARRAY
3807: PUSH
3808: LD_VAR 0 5
3812: AND
3813: IFFALSE 3968
// begin if k in [ 1 , 2 ] then
3815: LD_VAR 0 7
3819: PUSH
3820: LD_INT 1
3822: PUSH
3823: LD_INT 2
3825: PUSH
3826: EMPTY
3827: LIST
3828: LIST
3829: IN
3830: IFFALSE 3840
// k := 3 ;
3832: LD_ADDR_VAR 0 7
3836: PUSH
3837: LD_INT 3
3839: ST_TO_ADDR
// vc_chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
3840: LD_ADDR_OWVAR 37
3844: PUSH
3845: LD_INT 22
3847: PUSH
3848: LD_INT 24
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: PUSH
3855: LD_INT 1
3857: PPUSH
3858: LD_INT 2
3860: PPUSH
3861: CALL_OW 12
3865: ARRAY
3866: ST_TO_ADDR
// vc_engine := engine_siberite ;
3867: LD_ADDR_OWVAR 39
3871: PUSH
3872: LD_INT 3
3874: ST_TO_ADDR
// vc_control := control_manual ;
3875: LD_ADDR_OWVAR 38
3879: PUSH
3880: LD_INT 1
3882: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_rocket_launcher , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ;
3883: LD_ADDR_OWVAR 40
3887: PUSH
3888: LD_INT 44
3890: PUSH
3891: LD_INT 45
3893: PUSH
3894: LD_INT 43
3896: PUSH
3897: EMPTY
3898: LIST
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 1
3904: PPUSH
3905: LD_INT 3
3907: PPUSH
3908: CALL_OW 12
3912: ARRAY
3913: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , CreateVehicle ) ;
3914: LD_ADDR_VAR 0 5
3918: PUSH
3919: LD_VAR 0 5
3923: PPUSH
3924: LD_INT 1
3926: PPUSH
3927: CALL_OW 45
3931: PPUSH
3932: CALL_OW 2
3936: ST_TO_ADDR
// amount := Replace ( amount , 2 , amount [ 2 ] - 1 ) ;
3937: LD_ADDR_VAR 0 6
3941: PUSH
3942: LD_VAR 0 6
3946: PPUSH
3947: LD_INT 2
3949: PPUSH
3950: LD_VAR 0 6
3954: PUSH
3955: LD_INT 2
3957: ARRAY
3958: PUSH
3959: LD_INT 1
3961: MINUS
3962: PPUSH
3963: CALL_OW 1
3967: ST_TO_ADDR
// end ; if not tmp then
3968: LD_VAR 0 5
3972: NOT
3973: IFFALSE 3983
// k := 2 ;
3975: LD_ADDR_VAR 0 7
3979: PUSH
3980: LD_INT 2
3982: ST_TO_ADDR
// if amount [ 2 ] = 0 and k = 3 then
3983: LD_VAR 0 6
3987: PUSH
3988: LD_INT 2
3990: ARRAY
3991: PUSH
3992: LD_INT 0
3994: EQUAL
3995: PUSH
3996: LD_VAR 0 7
4000: PUSH
4001: LD_INT 3
4003: EQUAL
4004: AND
4005: IFFALSE 4034
// k := [ class_bazooker , class_scientistic ] [ rand ( 1 , 2 ) ] ;
4007: LD_ADDR_VAR 0 7
4011: PUSH
4012: LD_INT 9
4014: PUSH
4015: LD_INT 4
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: PUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 2
4027: PPUSH
4028: CALL_OW 12
4032: ARRAY
4033: ST_TO_ADDR
// PrepareHuman ( false , k , skill ) ;
4034: LD_INT 0
4036: PPUSH
4037: LD_VAR 0 7
4041: PPUSH
4042: LD_VAR 0 3
4046: PPUSH
4047: CALL_OW 380
// tmp := Insert ( tmp , 1 , CreateHuman ) ;
4051: LD_ADDR_VAR 0 5
4055: PUSH
4056: LD_VAR 0 5
4060: PPUSH
4061: LD_INT 1
4063: PPUSH
4064: CALL_OW 44
4068: PPUSH
4069: CALL_OW 2
4073: ST_TO_ADDR
// amount := Replace ( amount , 1 , amount [ 1 ] - 1 ) ;
4074: LD_ADDR_VAR 0 6
4078: PUSH
4079: LD_VAR 0 6
4083: PPUSH
4084: LD_INT 1
4086: PPUSH
4087: LD_VAR 0 6
4091: PUSH
4092: LD_INT 1
4094: ARRAY
4095: PUSH
4096: LD_INT 1
4098: MINUS
4099: PPUSH
4100: CALL_OW 1
4104: ST_TO_ADDR
// end ;
4105: GO 3766
// tmp := Insert ( tmp , tmp + 1 , Davidov ) ;
4107: LD_ADDR_VAR 0 5
4111: PUSH
4112: LD_VAR 0 5
4116: PPUSH
4117: LD_VAR 0 5
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: PPUSH
4126: LD_EXP 2
4130: PPUSH
4131: CALL_OW 2
4135: ST_TO_ADDR
// for i = tmp downto 1 do
4136: LD_ADDR_VAR 0 2
4140: PUSH
4141: DOUBLE
4142: LD_VAR 0 5
4146: INC
4147: ST_TO_ADDR
4148: LD_INT 1
4150: PUSH
4151: FOR_DOWNTO
4152: IFFALSE 4314
// begin if GetType ( tmp [ i ] ) = unit_vehicle then
4154: LD_VAR 0 5
4158: PUSH
4159: LD_VAR 0 2
4163: ARRAY
4164: PPUSH
4165: CALL_OW 247
4169: PUSH
4170: LD_INT 2
4172: EQUAL
4173: IFFALSE 4263
// begin SetDir ( tmp [ i ] , 3 ) ;
4175: LD_VAR 0 5
4179: PUSH
4180: LD_VAR 0 2
4184: ARRAY
4185: PPUSH
4186: LD_INT 3
4188: PPUSH
4189: CALL_OW 233
// PlaceUnitXY ( tmp [ i ] , 193 , 3 , false ) ;
4193: LD_VAR 0 5
4197: PUSH
4198: LD_VAR 0 2
4202: ARRAY
4203: PPUSH
4204: LD_INT 193
4206: PPUSH
4207: LD_INT 3
4209: PPUSH
4210: LD_INT 0
4212: PPUSH
4213: CALL_OW 48
// PlaceHumanInUnit ( tmp [ i - 1 ] , tmp [ i ] ) ;
4217: LD_VAR 0 5
4221: PUSH
4222: LD_VAR 0 2
4226: PUSH
4227: LD_INT 1
4229: MINUS
4230: ARRAY
4231: PPUSH
4232: LD_VAR 0 5
4236: PUSH
4237: LD_VAR 0 2
4241: ARRAY
4242: PPUSH
4243: CALL_OW 52
// i := i - 1 ;
4247: LD_ADDR_VAR 0 2
4251: PUSH
4252: LD_VAR 0 2
4256: PUSH
4257: LD_INT 1
4259: MINUS
4260: ST_TO_ADDR
// end else
4261: GO 4284
// PlaceUnitArea ( tmp [ i ] , start_area , false ) ;
4263: LD_VAR 0 5
4267: PUSH
4268: LD_VAR 0 2
4272: ARRAY
4273: PPUSH
4274: LD_INT 2
4276: PPUSH
4277: LD_INT 0
4279: PPUSH
4280: CALL_OW 49
// ComMoveXY ( tmp [ i ] , 197 , 22 ) ;
4284: LD_VAR 0 5
4288: PUSH
4289: LD_VAR 0 2
4293: ARRAY
4294: PPUSH
4295: LD_INT 197
4297: PPUSH
4298: LD_INT 22
4300: PPUSH
4301: CALL_OW 111
// Wait ( 0 0$02 ) ;
4305: LD_INT 70
4307: PPUSH
4308: CALL_OW 67
// end ;
4312: GO 4151
4314: POP
4315: POP
// Wait ( 0 0$02 ) ;
4316: LD_INT 70
4318: PPUSH
4319: CALL_OW 67
// vc_chassis := ru_medium_tracked ;
4323: LD_ADDR_OWVAR 37
4327: PUSH
4328: LD_INT 22
4330: ST_TO_ADDR
// vc_engine := engine_siberite ;
4331: LD_ADDR_OWVAR 39
4335: PUSH
4336: LD_INT 3
4338: ST_TO_ADDR
// vc_control := control_computer ;
4339: LD_ADDR_OWVAR 38
4343: PUSH
4344: LD_INT 3
4346: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4347: LD_ADDR_OWVAR 40
4351: PUSH
4352: LD_INT 51
4354: ST_TO_ADDR
// tmp := CreateVehicle ;
4355: LD_ADDR_VAR 0 5
4359: PUSH
4360: CALL_OW 45
4364: ST_TO_ADDR
// SetDir ( tmp , 3 ) ;
4365: LD_VAR 0 5
4369: PPUSH
4370: LD_INT 3
4372: PPUSH
4373: CALL_OW 233
// PlaceUnitXY ( tmp , 193 , 3 , false ) ;
4377: LD_VAR 0 5
4381: PPUSH
4382: LD_INT 193
4384: PPUSH
4385: LD_INT 3
4387: PPUSH
4388: LD_INT 0
4390: PPUSH
4391: CALL_OW 48
// SetCargo ( tmp , mat_artifact , 60 ) ;
4395: LD_VAR 0 5
4399: PPUSH
4400: LD_INT 4
4402: PPUSH
4403: LD_INT 60
4405: PPUSH
4406: CALL_OW 290
// ComMoveXY ( tmp , 197 , 22 ) ;
4410: LD_VAR 0 5
4414: PPUSH
4415: LD_INT 197
4417: PPUSH
4418: LD_INT 22
4420: PPUSH
4421: CALL_OW 111
// end ; end_of_file
4425: LD_VAR 0 1
4429: RET
// on VehicleConstructed ( veh , fac ) do var side ;
4430: LD_INT 0
4432: PPUSH
// begin side := GetSide ( fac ) ;
4433: LD_ADDR_VAR 0 3
4437: PUSH
4438: LD_VAR 0 2
4442: PPUSH
4443: CALL_OW 255
4447: ST_TO_ADDR
// case side of 7 :
4448: LD_VAR 0 3
4452: PUSH
4453: LD_INT 7
4455: DOUBLE
4456: EQUAL
4457: IFTRUE 4461
4459: GO 4508
4461: POP
// begin al_force := Replace ( al_force , al_force + 1 , veh ) ;
4462: LD_ADDR_EXP 32
4466: PUSH
4467: LD_EXP 32
4471: PPUSH
4472: LD_EXP 32
4476: PUSH
4477: LD_INT 1
4479: PLUS
4480: PPUSH
4481: LD_VAR 0 1
4485: PPUSH
4486: CALL_OW 1
4490: ST_TO_ADDR
// AddComMoveXY ( veh , 112 , 175 ) ;
4491: LD_VAR 0 1
4495: PPUSH
4496: LD_INT 112
4498: PPUSH
4499: LD_INT 175
4501: PPUSH
4502: CALL_OW 171
// end ; 8 :
4506: GO 4594
4508: LD_INT 8
4510: DOUBLE
4511: EQUAL
4512: IFTRUE 4516
4514: GO 4593
4516: POP
// begin if GetWeapon ( veh ) = ar_control_tower then
4517: LD_VAR 0 1
4521: PPUSH
4522: CALL_OW 264
4526: PUSH
4527: LD_INT 31
4529: EQUAL
4530: IFFALSE 4547
// ComMoveXY ( veh , 145 , 66 ) ;
4532: LD_VAR 0 1
4536: PPUSH
4537: LD_INT 145
4539: PPUSH
4540: LD_INT 66
4542: PPUSH
4543: CALL_OW 111
// if GetChassis ( veh ) = ar_hovercraft then
4547: LD_VAR 0 1
4551: PPUSH
4552: CALL_OW 265
4556: PUSH
4557: LD_INT 11
4559: EQUAL
4560: IFFALSE 4591
// legion_force := Replace ( legion_force , legion_force + 1 , veh ) ;
4562: LD_ADDR_EXP 33
4566: PUSH
4567: LD_EXP 33
4571: PPUSH
4572: LD_EXP 33
4576: PUSH
4577: LD_INT 1
4579: PLUS
4580: PPUSH
4581: LD_VAR 0 1
4585: PPUSH
4586: CALL_OW 1
4590: ST_TO_ADDR
// end ; end ;
4591: GO 4594
4593: POP
// end ;
4594: PPOPN 3
4596: END
// on UnitDestroyed ( un ) do begin if un in legion_force then
4597: LD_VAR 0 1
4601: PUSH
4602: LD_EXP 33
4606: IN
4607: IFFALSE 4625
// legion_force := legion_force diff un ;
4609: LD_ADDR_EXP 33
4613: PUSH
4614: LD_EXP 33
4618: PUSH
4619: LD_VAR 0 1
4623: DIFF
4624: ST_TO_ADDR
// if un in al_force then
4625: LD_VAR 0 1
4629: PUSH
4630: LD_EXP 32
4634: IN
4635: IFFALSE 4653
// al_force := al_force diff un ;
4637: LD_ADDR_EXP 32
4641: PUSH
4642: LD_EXP 32
4646: PUSH
4647: LD_VAR 0 1
4651: DIFF
4652: ST_TO_ADDR
// end ;
4653: PPOPN 1
4655: END
// on UnitTeleported ( b , un ) do begin if b = legion_telep and GetClass ( un ) = 17 then
4656: LD_VAR 0 1
4660: PUSH
4661: LD_INT 68
4663: EQUAL
4664: PUSH
4665: LD_VAR 0 2
4669: PPUSH
4670: CALL_OW 257
4674: PUSH
4675: LD_INT 17
4677: EQUAL
4678: AND
4679: IFFALSE 4722
// begin Wait ( 0 0$01 ) ;
4681: LD_INT 35
4683: PPUSH
4684: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , un ) ) ;
4688: LD_VAR 0 2
4692: PPUSH
4693: LD_INT 22
4695: PUSH
4696: LD_INT 6
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 2
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
// end ; end ;
4722: PPOPN 2
4724: END
// on CrateSpawn ( id , x , y , amount , mode ) do var i , apes , n ;
4725: LD_INT 0
4727: PPUSH
4728: PPUSH
4729: PPUSH
// begin if InArea ( x , y , cratesArea ) and FilterUnitsInArea ( islandArea , [ f_enemy , 6 ] ) = 0 then
4730: LD_VAR 0 2
4734: PPUSH
4735: LD_VAR 0 3
4739: PPUSH
4740: LD_INT 3
4742: PPUSH
4743: CALL_OW 309
4747: PUSH
4748: LD_INT 6
4750: PPUSH
4751: LD_INT 81
4753: PUSH
4754: LD_INT 6
4756: PUSH
4757: EMPTY
4758: LIST
4759: LIST
4760: PPUSH
4761: CALL_OW 70
4765: PUSH
4766: LD_INT 0
4768: EQUAL
4769: AND
4770: IFFALSE 4933
// begin apes := FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 16 ] ] ) ;
4772: LD_ADDR_VAR 0 7
4776: PUSH
4777: LD_INT 22
4779: PUSH
4780: LD_INT 6
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 25
4789: PUSH
4790: LD_INT 16
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PPUSH
4801: CALL_OW 69
4805: ST_TO_ADDR
// if apes = 0 or FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 then
4806: LD_VAR 0 7
4810: PUSH
4811: LD_INT 0
4813: EQUAL
4814: PUSH
4815: LD_INT 22
4817: PUSH
4818: LD_INT 6
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: LD_INT 2
4827: PUSH
4828: LD_INT 30
4830: PUSH
4831: LD_INT 0
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 30
4840: PUSH
4841: LD_INT 1
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: LIST
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: PPUSH
4857: CALL_OW 69
4861: PUSH
4862: LD_INT 0
4864: EQUAL
4865: OR
4866: IFFALSE 4870
// exit ;
4868: GO 4933
// if UnitFilter ( apes , [ f_inside ] ) then
4870: LD_VAR 0 7
4874: PPUSH
4875: LD_INT 54
4877: PUSH
4878: EMPTY
4879: LIST
4880: PPUSH
4881: CALL_OW 72
4885: IFFALSE 4914
// begin ComExitBuilding ( UnitFilter ( apes , [ f_inside ] ) ) ;
4887: LD_VAR 0 7
4891: PPUSH
4892: LD_INT 54
4894: PUSH
4895: EMPTY
4896: LIST
4897: PPUSH
4898: CALL_OW 72
4902: PPUSH
4903: CALL_OW 122
// wait ( 3 ) ;
4907: LD_INT 3
4909: PPUSH
4910: CALL_OW 67
// end ; AddComCollect ( apes , x , y ) ;
4914: LD_VAR 0 7
4918: PPUSH
4919: LD_VAR 0 2
4923: PPUSH
4924: LD_VAR 0 3
4928: PPUSH
4929: CALL_OW 177
// end ; end ;
4933: PPOPN 8
4935: END
// on UnitGoesToRed ( un ) do begin if un in al_force then
4936: LD_VAR 0 1
4940: PUSH
4941: LD_EXP 32
4945: IN
4946: IFFALSE 4964
// al_force := al_force diff un ;
4948: LD_ADDR_EXP 32
4952: PUSH
4953: LD_EXP 32
4957: PUSH
4958: LD_VAR 0 1
4962: DIFF
4963: ST_TO_ADDR
// if GetControl ( un ) = control_remote then
4964: LD_VAR 0 1
4968: PPUSH
4969: CALL_OW 263
4973: PUSH
4974: LD_INT 2
4976: EQUAL
4977: IFFALSE 4988
// ComUnlink ( un ) ;
4979: LD_VAR 0 1
4983: PPUSH
4984: CALL_OW 136
// end ;
4988: PPOPN 1
4990: END
// on ResearchStarted ( tech , lab ) do begin if tech = tech_sibfiss then
4991: LD_VAR 0 1
4995: PUSH
4996: LD_INT 25
4998: EQUAL
4999: IFFALSE 5009
// player_start_res_sib_bomb := true ;
5001: LD_ADDR_EXP 4
5005: PUSH
5006: LD_INT 1
5008: ST_TO_ADDR
// if tech = tech_artifact then
5009: LD_VAR 0 1
5013: PUSH
5014: LD_INT 24
5016: EQUAL
5017: IFFALSE 5027
// player_start_res_artifact := true ;
5019: LD_ADDR_EXP 5
5023: PUSH
5024: LD_INT 1
5026: ST_TO_ADDR
// end ;
5027: PPOPN 2
5029: END
// on ArtifactUnloaded ( cargo , artifact_num ) do begin if artifact_num = 6 then
5030: LD_VAR 0 2
5034: PUSH
5035: LD_INT 6
5037: EQUAL
5038: IFFALSE 5048
// player_artifact_loaded := false ;
5040: LD_ADDR_EXP 18
5044: PUSH
5045: LD_INT 0
5047: ST_TO_ADDR
// end ;
5048: PPOPN 2
5050: END
// on ArtifactLoaded ( cargo , artifact_num ) do begin if artifact_num = 6 then
5051: LD_VAR 0 2
5055: PUSH
5056: LD_INT 6
5058: EQUAL
5059: IFFALSE 5069
// player_artifact_loaded := true ;
5061: LD_ADDR_EXP 18
5065: PUSH
5066: LD_INT 1
5068: ST_TO_ADDR
// end ;
5069: PPOPN 2
5071: END
// on SiberiteRocketExploded ( rocket , x , y ) do var i ;
5072: LD_INT 0
5074: PPUSH
// begin player_used_sib_bomb := true ;
5075: LD_ADDR_EXP 12
5079: PUSH
5080: LD_INT 1
5082: ST_TO_ADDR
// for i = 1 to 3 do
5083: LD_ADDR_VAR 0 4
5087: PUSH
5088: DOUBLE
5089: LD_INT 1
5091: DEC
5092: ST_TO_ADDR
5093: LD_INT 3
5095: PUSH
5096: FOR_TO
5097: IFFALSE 5170
// begin if GetDistXY ( x , y , artifacts_pos [ i ] [ 1 ] , artifacts_pos [ i ] [ 2 ] ) <= sib_rocket_range then
5099: LD_VAR 0 2
5103: PPUSH
5104: LD_VAR 0 3
5108: PPUSH
5109: LD_EXP 15
5113: PUSH
5114: LD_VAR 0 4
5118: ARRAY
5119: PUSH
5120: LD_INT 1
5122: ARRAY
5123: PPUSH
5124: LD_EXP 15
5128: PUSH
5129: LD_VAR 0 4
5133: ARRAY
5134: PUSH
5135: LD_INT 2
5137: ARRAY
5138: PPUSH
5139: CALL_OW 298
5143: PUSH
5144: LD_EXP 17
5148: LESSEQUAL
5149: IFFALSE 5168
// begin wait ( 0 0$5 ) ;
5151: LD_INT 175
5153: PPUSH
5154: CALL_OW 67
// artifact_destroyed := true ;
5158: LD_ADDR_EXP 16
5162: PUSH
5163: LD_INT 1
5165: ST_TO_ADDR
// break ;
5166: GO 5170
// end ; end ;
5168: GO 5096
5170: POP
5171: POP
// end ; end_of_file
5172: PPOPN 4
5174: END
// export function CreateArtifact ( type , x , y ) ; begin
5175: LD_INT 0
5177: PPUSH
// CreateResourcesXY ( mat_artifact , type , x , y , false ) ;
5178: LD_INT 4
5180: PPUSH
5181: LD_VAR 0 1
5185: PPUSH
5186: LD_VAR 0 2
5190: PPUSH
5191: LD_VAR 0 3
5195: PPUSH
5196: LD_INT 0
5198: PPUSH
5199: CALL_OW 58
// end ;
5203: LD_VAR 0 4
5207: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5208: LD_INT 0
5210: PPUSH
5211: PPUSH
5212: PPUSH
// if not GetControl ( veh ) = control_manual then
5213: LD_VAR 0 1
5217: PPUSH
5218: CALL_OW 263
5222: PUSH
5223: LD_INT 1
5225: EQUAL
5226: NOT
5227: IFFALSE 5239
// result := false else
5229: LD_ADDR_VAR 0 2
5233: PUSH
5234: LD_INT 0
5236: ST_TO_ADDR
5237: GO 5384
// if veh in FilterAllUnits ( [ f_empty ] ) then
5239: LD_VAR 0 1
5243: PUSH
5244: LD_INT 58
5246: PUSH
5247: EMPTY
5248: LIST
5249: PPUSH
5250: CALL_OW 69
5254: IN
5255: IFFALSE 5267
// result := false else
5257: LD_ADDR_VAR 0 2
5261: PUSH
5262: LD_INT 0
5264: ST_TO_ADDR
5265: GO 5384
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5267: LD_ADDR_VAR 0 4
5271: PUSH
5272: LD_INT 22
5274: PUSH
5275: LD_VAR 0 1
5279: PPUSH
5280: CALL_OW 255
5284: PUSH
5285: EMPTY
5286: LIST
5287: LIST
5288: PUSH
5289: LD_INT 55
5291: PUSH
5292: EMPTY
5293: LIST
5294: PUSH
5295: EMPTY
5296: LIST
5297: LIST
5298: PPUSH
5299: CALL_OW 69
5303: ST_TO_ADDR
// if not filter then
5304: LD_VAR 0 4
5308: NOT
5309: IFFALSE 5321
// result := false else
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: LD_INT 0
5318: ST_TO_ADDR
5319: GO 5384
// for i = 1 to filter do
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: DOUBLE
5327: LD_INT 1
5329: DEC
5330: ST_TO_ADDR
5331: LD_VAR 0 4
5335: PUSH
5336: FOR_TO
5337: IFFALSE 5382
// if IsDriver ( filter [ i ] ) = veh then
5339: LD_VAR 0 4
5343: PUSH
5344: LD_VAR 0 3
5348: ARRAY
5349: PPUSH
5350: CALL 5728 0 1
5354: PUSH
5355: LD_VAR 0 1
5359: EQUAL
5360: IFFALSE 5380
// begin result := filter [ i ] ;
5362: LD_ADDR_VAR 0 2
5366: PUSH
5367: LD_VAR 0 4
5371: PUSH
5372: LD_VAR 0 3
5376: ARRAY
5377: ST_TO_ADDR
// break ;
5378: GO 5382
// end ;
5380: GO 5336
5382: POP
5383: POP
// end ; end ;
5384: LD_VAR 0 2
5388: RET
// export function GetSibResources ( side ) ; var i , deps ; begin
5389: LD_INT 0
5391: PPUSH
5392: PPUSH
5393: PPUSH
// result := 0 ;
5394: LD_ADDR_VAR 0 2
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// deps := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5402: LD_ADDR_VAR 0 4
5406: PUSH
5407: LD_INT 22
5409: PUSH
5410: LD_VAR 0 1
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: PUSH
5419: LD_INT 2
5421: PUSH
5422: LD_INT 30
5424: PUSH
5425: LD_INT 0
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PUSH
5432: LD_INT 30
5434: PUSH
5435: LD_INT 1
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: PPUSH
5451: CALL_OW 69
5455: ST_TO_ADDR
// if deps then
5456: LD_VAR 0 4
5460: IFFALSE 5508
// for i in deps do
5462: LD_ADDR_VAR 0 3
5466: PUSH
5467: LD_VAR 0 4
5471: PUSH
5472: FOR_IN
5473: IFFALSE 5506
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
5475: LD_ADDR_VAR 0 2
5479: PUSH
5480: LD_VAR 0 2
5484: PUSH
5485: LD_VAR 0 3
5489: PPUSH
5490: CALL_OW 274
5494: PPUSH
5495: LD_INT 3
5497: PPUSH
5498: CALL_OW 275
5502: PLUS
5503: ST_TO_ADDR
5504: GO 5472
5506: POP
5507: POP
// end ;
5508: LD_VAR 0 2
5512: RET
// export function SetSibResources ( side , val ) ; var i , deps , s ; begin
5513: LD_INT 0
5515: PPUSH
5516: PPUSH
5517: PPUSH
5518: PPUSH
// if val <= 0 then
5519: LD_VAR 0 2
5523: PUSH
5524: LD_INT 0
5526: LESSEQUAL
5527: IFFALSE 5531
// exit ;
5529: GO 5723
// deps := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5531: LD_ADDR_VAR 0 5
5535: PUSH
5536: LD_INT 22
5538: PUSH
5539: LD_VAR 0 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PUSH
5548: LD_INT 2
5550: PUSH
5551: LD_INT 30
5553: PUSH
5554: LD_INT 0
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PUSH
5561: LD_INT 30
5563: PUSH
5564: LD_INT 1
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: LIST
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: PPUSH
5580: CALL_OW 69
5584: ST_TO_ADDR
// if deps then
5585: LD_VAR 0 5
5589: IFFALSE 5723
// for i in deps do
5591: LD_ADDR_VAR 0 4
5595: PUSH
5596: LD_VAR 0 5
5600: PUSH
5601: FOR_IN
5602: IFFALSE 5721
// begin s := GetResourceType ( GetBase ( i ) , mat_siberit ) ;
5604: LD_ADDR_VAR 0 6
5608: PUSH
5609: LD_VAR 0 4
5613: PPUSH
5614: CALL_OW 274
5618: PPUSH
5619: LD_INT 3
5621: PPUSH
5622: CALL_OW 275
5626: ST_TO_ADDR
// if val < s then
5627: LD_VAR 0 2
5631: PUSH
5632: LD_VAR 0 6
5636: LESS
5637: IFFALSE 5683
// begin s := s - val ;
5639: LD_ADDR_VAR 0 6
5643: PUSH
5644: LD_VAR 0 6
5648: PUSH
5649: LD_VAR 0 2
5653: MINUS
5654: ST_TO_ADDR
// SetResourceType ( GetBase ( i ) , mat_siberit , s ) ;
5655: LD_VAR 0 4
5659: PPUSH
5660: CALL_OW 274
5664: PPUSH
5665: LD_INT 3
5667: PPUSH
5668: LD_VAR 0 6
5672: PPUSH
5673: CALL_OW 277
// exit ;
5677: POP
5678: POP
5679: GO 5723
// end else
5681: GO 5719
// begin val := val - s ;
5683: LD_ADDR_VAR 0 2
5687: PUSH
5688: LD_VAR 0 2
5692: PUSH
5693: LD_VAR 0 6
5697: MINUS
5698: ST_TO_ADDR
// SetResourceType ( GetBase ( i ) , mat_siberit , 0 ) ;
5699: LD_VAR 0 4
5703: PPUSH
5704: CALL_OW 274
5708: PPUSH
5709: LD_INT 3
5711: PPUSH
5712: LD_INT 0
5714: PPUSH
5715: CALL_OW 277
// end ; end ;
5719: GO 5601
5721: POP
5722: POP
// end ;
5723: LD_VAR 0 3
5727: RET
// export function IsDriver ( unit ) ; begin
5728: LD_INT 0
5730: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5731: LD_VAR 0 1
5735: PUSH
5736: LD_INT 55
5738: PUSH
5739: EMPTY
5740: LIST
5741: PPUSH
5742: CALL_OW 69
5746: IN
5747: IFFALSE 5766
// result := IsInUnit ( unit ) else
5749: LD_ADDR_VAR 0 2
5753: PUSH
5754: LD_VAR 0 1
5758: PPUSH
5759: CALL_OW 310
5763: ST_TO_ADDR
5764: GO 5774
// result := false ;
5766: LD_ADDR_VAR 0 2
5770: PUSH
5771: LD_INT 0
5773: ST_TO_ADDR
// end ;
5774: LD_VAR 0 2
5778: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
5779: LD_INT 0
5781: PPUSH
5782: PPUSH
5783: PPUSH
5784: PPUSH
// if pos < 1 then
5785: LD_VAR 0 2
5789: PUSH
5790: LD_INT 1
5792: LESS
5793: IFFALSE 5797
// exit ;
5795: GO 6100
// if pos = 1 then
5797: LD_VAR 0 2
5801: PUSH
5802: LD_INT 1
5804: EQUAL
5805: IFFALSE 5838
// result := Replace ( arr , pos [ 1 ] , value ) else
5807: LD_ADDR_VAR 0 4
5811: PUSH
5812: LD_VAR 0 1
5816: PPUSH
5817: LD_VAR 0 2
5821: PUSH
5822: LD_INT 1
5824: ARRAY
5825: PPUSH
5826: LD_VAR 0 3
5830: PPUSH
5831: CALL_OW 1
5835: ST_TO_ADDR
5836: GO 6100
// begin tmp := arr ;
5838: LD_ADDR_VAR 0 6
5842: PUSH
5843: LD_VAR 0 1
5847: ST_TO_ADDR
// s_arr := [ tmp ] ;
5848: LD_ADDR_VAR 0 7
5852: PUSH
5853: LD_VAR 0 6
5857: PUSH
5858: EMPTY
5859: LIST
5860: ST_TO_ADDR
// for i = 1 to pos - 1 do
5861: LD_ADDR_VAR 0 5
5865: PUSH
5866: DOUBLE
5867: LD_INT 1
5869: DEC
5870: ST_TO_ADDR
5871: LD_VAR 0 2
5875: PUSH
5876: LD_INT 1
5878: MINUS
5879: PUSH
5880: FOR_TO
5881: IFFALSE 5926
// begin tmp := tmp [ pos [ i ] ] ;
5883: LD_ADDR_VAR 0 6
5887: PUSH
5888: LD_VAR 0 6
5892: PUSH
5893: LD_VAR 0 2
5897: PUSH
5898: LD_VAR 0 5
5902: ARRAY
5903: ARRAY
5904: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
5905: LD_ADDR_VAR 0 7
5909: PUSH
5910: LD_VAR 0 7
5914: PUSH
5915: LD_VAR 0 6
5919: PUSH
5920: EMPTY
5921: LIST
5922: ADD
5923: ST_TO_ADDR
// end ;
5924: GO 5880
5926: POP
5927: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
5928: LD_ADDR_VAR 0 6
5932: PUSH
5933: LD_VAR 0 6
5937: PPUSH
5938: LD_VAR 0 2
5942: PUSH
5943: LD_VAR 0 2
5947: ARRAY
5948: PPUSH
5949: LD_VAR 0 3
5953: PPUSH
5954: CALL_OW 1
5958: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
5959: LD_ADDR_VAR 0 7
5963: PUSH
5964: LD_VAR 0 7
5968: PPUSH
5969: LD_VAR 0 7
5973: PPUSH
5974: LD_VAR 0 6
5978: PPUSH
5979: CALL_OW 1
5983: ST_TO_ADDR
// for i = s_arr downto 2 do
5984: LD_ADDR_VAR 0 5
5988: PUSH
5989: DOUBLE
5990: LD_VAR 0 7
5994: INC
5995: ST_TO_ADDR
5996: LD_INT 2
5998: PUSH
5999: FOR_DOWNTO
6000: IFFALSE 6084
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
6002: LD_ADDR_VAR 0 6
6006: PUSH
6007: LD_VAR 0 7
6011: PUSH
6012: LD_VAR 0 5
6016: PUSH
6017: LD_INT 1
6019: MINUS
6020: ARRAY
6021: PPUSH
6022: LD_VAR 0 2
6026: PUSH
6027: LD_VAR 0 5
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: ARRAY
6036: PPUSH
6037: LD_VAR 0 7
6041: PUSH
6042: LD_VAR 0 5
6046: ARRAY
6047: PPUSH
6048: CALL_OW 1
6052: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
6053: LD_ADDR_VAR 0 7
6057: PUSH
6058: LD_VAR 0 7
6062: PPUSH
6063: LD_VAR 0 5
6067: PUSH
6068: LD_INT 1
6070: MINUS
6071: PPUSH
6072: LD_VAR 0 6
6076: PPUSH
6077: CALL_OW 1
6081: ST_TO_ADDR
// end ;
6082: GO 5999
6084: POP
6085: POP
// result := s_arr [ 1 ] ;
6086: LD_ADDR_VAR 0 4
6090: PUSH
6091: LD_VAR 0 7
6095: PUSH
6096: LD_INT 1
6098: ARRAY
6099: ST_TO_ADDR
// end ; end ;
6100: LD_VAR 0 4
6104: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
6105: LD_VAR 0 1
6109: PUSH
6110: LD_EXP 35
6114: IN
6115: NOT
6116: IFFALSE 6147
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
6118: LD_ADDR_EXP 35
6122: PUSH
6123: LD_EXP 35
6127: PPUSH
6128: LD_EXP 35
6132: PUSH
6133: LD_INT 1
6135: PLUS
6136: PPUSH
6137: LD_VAR 0 1
6141: PPUSH
6142: CALL_OW 2
6146: ST_TO_ADDR
// end ;
6147: PPOPN 1
6149: END
// export function DestinationReachable ( unit , x , y ) ; begin
6150: LD_INT 0
6152: PPUSH
// if unit in unreachableList then
6153: LD_VAR 0 1
6157: PUSH
6158: LD_EXP 35
6162: IN
6163: IFFALSE 6181
// unreachableList := unreachableList diff unit ;
6165: LD_ADDR_EXP 35
6169: PUSH
6170: LD_EXP 35
6174: PUSH
6175: LD_VAR 0 1
6179: DIFF
6180: ST_TO_ADDR
// if ValidHex ( x , y ) then
6181: LD_VAR 0 2
6185: PPUSH
6186: LD_VAR 0 3
6190: PPUSH
6191: CALL_OW 488
6195: IFFALSE 6221
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
6197: LD_VAR 0 1
6201: PPUSH
6202: LD_VAR 0 2
6206: PPUSH
6207: LD_VAR 0 3
6211: PPUSH
6212: CALL_OW 428
6216: PPUSH
6217: CALL_OW 115
// Wait ( 3 ) ;
6221: LD_INT 3
6223: PPUSH
6224: CALL_OW 67
// if unit in unreachableList then
6228: LD_VAR 0 1
6232: PUSH
6233: LD_EXP 35
6237: IN
6238: IFFALSE 6250
// result := false else
6240: LD_ADDR_VAR 0 4
6244: PUSH
6245: LD_INT 0
6247: ST_TO_ADDR
6248: GO 6258
// result := true ;
6250: LD_ADDR_VAR 0 4
6254: PUSH
6255: LD_INT 1
6257: ST_TO_ADDR
// end ;
6258: LD_VAR 0 4
6262: RET
// export function ComBombAttack ( unit , side ) ; var i , enemy , t , x , y , change_target_counter , last_target ; begin
6263: LD_INT 0
6265: PPUSH
6266: PPUSH
6267: PPUSH
6268: PPUSH
6269: PPUSH
6270: PPUSH
6271: PPUSH
6272: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
6273: LD_ADDR_VAR 0 5
6277: PUSH
6278: LD_INT 22
6280: PUSH
6281: LD_VAR 0 2
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PPUSH
6290: CALL_OW 69
6294: ST_TO_ADDR
// change_target_counter := 0 ;
6295: LD_ADDR_VAR 0 9
6299: PUSH
6300: LD_INT 0
6302: ST_TO_ADDR
// last_target := 0 ;
6303: LD_ADDR_VAR 0 10
6307: PUSH
6308: LD_INT 0
6310: ST_TO_ADDR
// if not enemy then
6311: LD_VAR 0 5
6315: NOT
6316: IFFALSE 6320
// exit ;
6318: GO 6525
// while ( IsLive ( unit ) and change_target_counter < 4 ) do
6320: LD_VAR 0 1
6324: PPUSH
6325: CALL_OW 300
6329: PUSH
6330: LD_VAR 0 9
6334: PUSH
6335: LD_INT 4
6337: LESS
6338: AND
6339: IFFALSE 6525
// begin if UnitFilter ( enemy , [ f_occupied ] ) then
6341: LD_VAR 0 5
6345: PPUSH
6346: LD_INT 59
6348: PUSH
6349: EMPTY
6350: LIST
6351: PPUSH
6352: CALL_OW 72
6356: IFFALSE 6492
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
6358: LD_ADDR_VAR 0 6
6362: PUSH
6363: LD_VAR 0 5
6367: PPUSH
6368: LD_INT 59
6370: PUSH
6371: EMPTY
6372: LIST
6373: PPUSH
6374: CALL_OW 72
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: ST_TO_ADDR
// if ( last_target <> t ) then
6389: LD_VAR 0 10
6393: PUSH
6394: LD_VAR 0 6
6398: NONEQUAL
6399: IFFALSE 6415
// change_target_counter := change_target_counter + 1 ;
6401: LD_ADDR_VAR 0 9
6405: PUSH
6406: LD_VAR 0 9
6410: PUSH
6411: LD_INT 1
6413: PLUS
6414: ST_TO_ADDR
// last_target := t ;
6415: LD_ADDR_VAR 0 10
6419: PUSH
6420: LD_VAR 0 6
6424: ST_TO_ADDR
// x := GetX ( t ) ;
6425: LD_ADDR_VAR 0 7
6429: PUSH
6430: LD_VAR 0 6
6434: PPUSH
6435: CALL_OW 250
6439: ST_TO_ADDR
// y := GetY ( t ) ;
6440: LD_ADDR_VAR 0 8
6444: PUSH
6445: LD_VAR 0 6
6449: PPUSH
6450: CALL_OW 251
6454: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6455: LD_VAR 0 1
6459: PPUSH
6460: LD_VAR 0 7
6464: PPUSH
6465: LD_VAR 0 8
6469: PPUSH
6470: CALL 6150 0 3
6474: IFFALSE 6490
// ComAttackUnit ( unit , t ) ;
6476: LD_VAR 0 1
6480: PPUSH
6481: LD_VAR 0 6
6485: PPUSH
6486: CALL_OW 115
// end else
6490: GO 6516
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
6492: LD_VAR 0 1
6496: PPUSH
6497: LD_VAR 0 5
6501: PPUSH
6502: LD_VAR 0 1
6506: PPUSH
6507: CALL_OW 74
6511: PPUSH
6512: CALL_OW 115
// Wait ( 0 0$0.3 ) ;
6516: LD_INT 10
6518: PPUSH
6519: CALL_OW 67
// end ;
6523: GO 6320
// end ;
6525: LD_VAR 0 3
6529: RET
// export function ComBrutalAttack ( units , side ) ; var i , enemy , t , x , y , target , unit ; begin
6530: LD_INT 0
6532: PPUSH
6533: PPUSH
6534: PPUSH
6535: PPUSH
6536: PPUSH
6537: PPUSH
6538: PPUSH
6539: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
6540: LD_ADDR_VAR 0 5
6544: PUSH
6545: LD_INT 22
6547: PUSH
6548: LD_VAR 0 2
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: PPUSH
6557: CALL_OW 69
6561: ST_TO_ADDR
// target := 0 ;
6562: LD_ADDR_VAR 0 9
6566: PUSH
6567: LD_INT 0
6569: ST_TO_ADDR
// if not enemy then
6570: LD_VAR 0 5
6574: NOT
6575: IFFALSE 6579
// exit ;
6577: GO 7234
// while units do
6579: LD_VAR 0 1
6583: IFFALSE 7234
// begin wait ( 0 0$0.3 ) ;
6585: LD_INT 10
6587: PPUSH
6588: CALL_OW 67
// for unit in units do
6592: LD_ADDR_VAR 0 10
6596: PUSH
6597: LD_VAR 0 1
6601: PUSH
6602: FOR_IN
6603: IFFALSE 7230
// begin if not IsPlaced ( unit ) then
6605: LD_VAR 0 10
6609: PPUSH
6610: CALL_OW 305
6614: NOT
6615: IFFALSE 6635
// begin units := units diff unit ;
6617: LD_ADDR_VAR 0 1
6621: PUSH
6622: LD_VAR 0 1
6626: PUSH
6627: LD_VAR 0 10
6631: DIFF
6632: ST_TO_ADDR
// continue ;
6633: GO 6602
// end ; if not IsPlaced ( target ) then
6635: LD_VAR 0 9
6639: PPUSH
6640: CALL_OW 305
6644: NOT
6645: IFFALSE 6655
// target := 0 ;
6647: LD_ADDR_VAR 0 9
6651: PUSH
6652: LD_INT 0
6654: ST_TO_ADDR
// if not target and UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) then
6655: LD_VAR 0 9
6659: NOT
6660: PUSH
6661: LD_VAR 0 5
6665: PPUSH
6666: LD_INT 21
6668: PUSH
6669: LD_INT 1
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: PUSH
6676: LD_INT 3
6678: PUSH
6679: LD_INT 54
6681: PUSH
6682: EMPTY
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: PPUSH
6693: CALL_OW 72
6697: AND
6698: IFFALSE 6960
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , unit ) ;
6700: LD_ADDR_VAR 0 6
6704: PUSH
6705: LD_VAR 0 5
6709: PPUSH
6710: LD_INT 21
6712: PUSH
6713: LD_INT 1
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: PUSH
6720: LD_INT 3
6722: PUSH
6723: LD_INT 54
6725: PUSH
6726: EMPTY
6727: LIST
6728: PUSH
6729: EMPTY
6730: LIST
6731: LIST
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PPUSH
6737: CALL_OW 72
6741: PPUSH
6742: LD_VAR 0 10
6746: PPUSH
6747: CALL_OW 74
6751: ST_TO_ADDR
// x := GetX ( t ) ;
6752: LD_ADDR_VAR 0 7
6756: PUSH
6757: LD_VAR 0 6
6761: PPUSH
6762: CALL_OW 250
6766: ST_TO_ADDR
// y := GetY ( t ) ;
6767: LD_ADDR_VAR 0 8
6771: PUSH
6772: LD_VAR 0 6
6776: PPUSH
6777: CALL_OW 251
6781: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6782: LD_VAR 0 10
6786: PPUSH
6787: LD_VAR 0 7
6791: PPUSH
6792: LD_VAR 0 8
6796: PPUSH
6797: CALL 6150 0 3
6801: IFFALSE 6815
// target := t else
6803: LD_ADDR_VAR 0 9
6807: PUSH
6808: LD_VAR 0 6
6812: ST_TO_ADDR
6813: GO 6960
// if UnitFilter ( enemy , [ f_occupied ] ) then
6815: LD_VAR 0 5
6819: PPUSH
6820: LD_INT 59
6822: PUSH
6823: EMPTY
6824: LIST
6825: PPUSH
6826: CALL_OW 72
6830: IFFALSE 6960
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
6832: LD_ADDR_VAR 0 6
6836: PUSH
6837: LD_VAR 0 5
6841: PPUSH
6842: LD_INT 59
6844: PUSH
6845: EMPTY
6846: LIST
6847: PPUSH
6848: CALL_OW 72
6852: PPUSH
6853: LD_VAR 0 10
6857: PPUSH
6858: CALL_OW 74
6862: ST_TO_ADDR
// x := GetX ( t ) ;
6863: LD_ADDR_VAR 0 7
6867: PUSH
6868: LD_VAR 0 6
6872: PPUSH
6873: CALL_OW 250
6877: ST_TO_ADDR
// y := GetY ( t ) ;
6878: LD_ADDR_VAR 0 8
6882: PUSH
6883: LD_VAR 0 6
6887: PPUSH
6888: CALL_OW 251
6892: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6893: LD_VAR 0 10
6897: PPUSH
6898: LD_VAR 0 7
6902: PPUSH
6903: LD_VAR 0 8
6907: PPUSH
6908: CALL 6150 0 3
6912: IFFALSE 6926
// target := t else
6914: LD_ADDR_VAR 0 9
6918: PUSH
6919: LD_VAR 0 6
6923: ST_TO_ADDR
6924: GO 6960
// ComAttackUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , unit ) ) ;
6926: LD_VAR 0 10
6930: PPUSH
6931: LD_INT 22
6933: PUSH
6934: LD_INT 6
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PPUSH
6941: CALL_OW 69
6945: PPUSH
6946: LD_VAR 0 10
6950: PPUSH
6951: CALL_OW 74
6955: PPUSH
6956: CALL_OW 115
// end ; end ; if not target or not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
6960: LD_VAR 0 9
6964: NOT
6965: PUSH
6966: LD_VAR 0 10
6970: PPUSH
6971: LD_VAR 0 9
6975: PPUSH
6976: CALL_OW 250
6980: PPUSH
6981: LD_VAR 0 9
6985: PPUSH
6986: CALL_OW 251
6990: PPUSH
6991: CALL 6150 0 3
6995: NOT
6996: OR
6997: IFFALSE 7031
// target := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
6999: LD_ADDR_VAR 0 9
7003: PUSH
7004: LD_INT 22
7006: PUSH
7007: LD_VAR 0 2
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PPUSH
7016: CALL_OW 69
7020: PPUSH
7021: LD_VAR 0 10
7025: PPUSH
7026: CALL_OW 74
7030: ST_TO_ADDR
// if ( GetDistUnits ( target , unit ) < 4 and GetLives ( unit ) < 600 ) or ( GetLives ( unit ) < 200 and GetSide ( NearestUnitToUnit ( all_units diff unit , unit ) ) <> GetSide ( unit ) ) then
7031: LD_VAR 0 9
7035: PPUSH
7036: LD_VAR 0 10
7040: PPUSH
7041: CALL_OW 296
7045: PUSH
7046: LD_INT 4
7048: LESS
7049: PUSH
7050: LD_VAR 0 10
7054: PPUSH
7055: CALL_OW 256
7059: PUSH
7060: LD_INT 600
7062: LESS
7063: AND
7064: PUSH
7065: LD_VAR 0 10
7069: PPUSH
7070: CALL_OW 256
7074: PUSH
7075: LD_INT 200
7077: LESS
7078: PUSH
7079: LD_OWVAR 3
7083: PUSH
7084: LD_VAR 0 10
7088: DIFF
7089: PPUSH
7090: LD_VAR 0 10
7094: PPUSH
7095: CALL_OW 74
7099: PPUSH
7100: CALL_OW 255
7104: PUSH
7105: LD_VAR 0 10
7109: PPUSH
7110: CALL_OW 255
7114: NONEQUAL
7115: AND
7116: OR
7117: IFFALSE 7168
// begin for i = 1 to 4 do
7119: LD_ADDR_VAR 0 4
7123: PUSH
7124: DOUBLE
7125: LD_INT 1
7127: DEC
7128: ST_TO_ADDR
7129: LD_INT 4
7131: PUSH
7132: FOR_TO
7133: IFFALSE 7164
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
7135: LD_VAR 0 10
7139: PPUSH
7140: CALL_OW 250
7144: PPUSH
7145: LD_VAR 0 10
7149: PPUSH
7150: CALL_OW 251
7154: PPUSH
7155: LD_INT 1
7157: PPUSH
7158: CALL_OW 453
7162: GO 7132
7164: POP
7165: POP
// end else
7166: GO 7228
// if GetType ( target ) <> unit_human then
7168: LD_VAR 0 9
7172: PPUSH
7173: CALL_OW 247
7177: PUSH
7178: LD_INT 1
7180: NONEQUAL
7181: IFFALSE 7199
// ComAttackUnit ( unit , target ) else
7183: LD_VAR 0 10
7187: PPUSH
7188: LD_VAR 0 9
7192: PPUSH
7193: CALL_OW 115
7197: GO 7228
// ComMoveXY ( unit , GetX ( target ) , GetY ( target ) ) ;
7199: LD_VAR 0 10
7203: PPUSH
7204: LD_VAR 0 9
7208: PPUSH
7209: CALL_OW 250
7213: PPUSH
7214: LD_VAR 0 9
7218: PPUSH
7219: CALL_OW 251
7223: PPUSH
7224: CALL_OW 111
// end ;
7228: GO 6602
7230: POP
7231: POP
// end ;
7232: GO 6579
// end ; end_of_file
7234: LD_VAR 0 3
7238: RET
// export function Action ; var dial ; begin
7239: LD_INT 0
7241: PPUSH
7242: PPUSH
// CenterNowOnXY ( 192 , 1 ) ;
7243: LD_INT 192
7245: PPUSH
7246: LD_INT 1
7248: PPUSH
7249: CALL_OW 86
// InGameOn ;
7253: CALL_OW 8
// PrepareRussian ;
7257: CALL 3560 0 0
// dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff Davidov ;
7261: LD_ADDR_VAR 0 2
7265: PUSH
7266: LD_INT 22
7268: PUSH
7269: LD_INT 6
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: PUSH
7276: LD_INT 2
7278: PUSH
7279: LD_INT 25
7281: PUSH
7282: LD_INT 1
7284: PUSH
7285: EMPTY
7286: LIST
7287: LIST
7288: PUSH
7289: LD_INT 25
7291: PUSH
7292: LD_INT 2
7294: PUSH
7295: EMPTY
7296: LIST
7297: LIST
7298: PUSH
7299: LD_INT 25
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: PUSH
7309: LD_INT 25
7311: PUSH
7312: LD_INT 4
7314: PUSH
7315: EMPTY
7316: LIST
7317: LIST
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: PPUSH
7330: CALL_OW 69
7334: PUSH
7335: LD_EXP 2
7339: DIFF
7340: ST_TO_ADDR
// ComMoveXY ( dial [ 1 ] , 202 , 40 ) ;
7341: LD_VAR 0 2
7345: PUSH
7346: LD_INT 1
7348: ARRAY
7349: PPUSH
7350: LD_INT 202
7352: PPUSH
7353: LD_INT 40
7355: PPUSH
7356: CALL_OW 111
// Wait ( 0 0$03 ) ;
7360: LD_INT 105
7362: PPUSH
7363: CALL_OW 67
// Say ( Davidov , DDav-1 ) ;
7367: LD_EXP 2
7371: PPUSH
7372: LD_STRING DDav-1
7374: PPUSH
7375: CALL_OW 88
// ComTurnUnit ( dial [ 1 ] , Davidov ) ;
7379: LD_VAR 0 2
7383: PUSH
7384: LD_INT 1
7386: ARRAY
7387: PPUSH
7388: LD_EXP 2
7392: PPUSH
7393: CALL_OW 119
// ComTurnUnit ( Davidov , dial [ 1 ] ) ;
7397: LD_EXP 2
7401: PPUSH
7402: LD_VAR 0 2
7406: PUSH
7407: LD_INT 1
7409: ARRAY
7410: PPUSH
7411: CALL_OW 119
// CenterOnXY ( 202 , 40 ) ;
7415: LD_INT 202
7417: PPUSH
7418: LD_INT 40
7420: PPUSH
7421: CALL_OW 84
// Say ( dial [ 1 ] , DRus-1 ) ;
7425: LD_VAR 0 2
7429: PUSH
7430: LD_INT 1
7432: ARRAY
7433: PPUSH
7434: LD_STRING DRus-1
7436: PPUSH
7437: CALL_OW 88
// Say ( Davidov , DDav-2 ) ;
7441: LD_EXP 2
7445: PPUSH
7446: LD_STRING DDav-2
7448: PPUSH
7449: CALL_OW 88
// Say ( dial [ 1 ] , DRus-2 ) ;
7453: LD_VAR 0 2
7457: PUSH
7458: LD_INT 1
7460: ARRAY
7461: PPUSH
7462: LD_STRING DRus-2
7464: PPUSH
7465: CALL_OW 88
// Say ( Davidov , DDav-3 ) ;
7469: LD_EXP 2
7473: PPUSH
7474: LD_STRING DDav-3
7476: PPUSH
7477: CALL_OW 88
// InGameOff ;
7481: CALL_OW 9
// Wait ( 0 0$0.3 ) ;
7485: LD_INT 10
7487: PPUSH
7488: CALL_OW 67
// ChangeMissionObjectives ( C1 ) ;
7492: LD_STRING C1
7494: PPUSH
7495: CALL_OW 337
// end ;
7499: LD_VAR 0 1
7503: RET
// every 0 0$30 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
7504: LD_INT 22
7506: PUSH
7507: LD_INT 6
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: PUSH
7514: LD_INT 2
7516: PUSH
7517: LD_INT 30
7519: PUSH
7520: LD_INT 6
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: LD_INT 30
7529: PUSH
7530: LD_INT 7
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 30
7539: PUSH
7540: LD_INT 8
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PPUSH
7557: CALL_OW 69
7561: IFFALSE 7661
7563: GO 7565
7565: DISABLE
// begin Say ( Davidov , DDav-4 ) ;
7566: LD_EXP 2
7570: PPUSH
7571: LD_STRING DDav-4
7573: PPUSH
7574: CALL_OW 88
// Wait ( 0 0$40 ) ;
7578: LD_INT 1400
7580: PPUSH
7581: CALL_OW 67
// DialogueOn ;
7585: CALL_OW 6
// SayRadio ( Vervecken , Dver-Meet-1 ) ;
7589: LD_EXP 3
7593: PPUSH
7594: LD_STRING Dver-Meet-1
7596: PPUSH
7597: CALL_OW 94
// Say ( Davidov , DDav-Meet-1 ) ;
7601: LD_EXP 2
7605: PPUSH
7606: LD_STRING DDav-Meet-1
7608: PPUSH
7609: CALL_OW 88
// SayRadio ( Vervecken , Dver-Meet-2 ) ;
7613: LD_EXP 3
7617: PPUSH
7618: LD_STRING Dver-Meet-2
7620: PPUSH
7621: CALL_OW 94
// DialogueOff ;
7625: CALL_OW 7
// Wait ( [ 9 9$20 , 7 7$20 , 6 6$20 ] [ Difficulty ] ) ;
7629: LD_INT 19600
7631: PUSH
7632: LD_INT 15400
7634: PUSH
7635: LD_INT 13300
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: LIST
7642: PUSH
7643: LD_OWVAR 67
7647: ARRAY
7648: PPUSH
7649: CALL_OW 67
// legion_attacks_active := true ;
7653: LD_ADDR_EXP 7
7657: PUSH
7658: LD_INT 1
7660: ST_TO_ADDR
// end ;
7661: END
// every 0 0$02 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) or tick > 10 10$00 do var dial ;
7662: LD_INT 22
7664: PUSH
7665: LD_INT 6
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: LD_INT 30
7674: PUSH
7675: LD_INT 3
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PPUSH
7686: CALL_OW 69
7690: PUSH
7691: LD_OWVAR 1
7695: PUSH
7696: LD_INT 21000
7698: GREATER
7699: OR
7700: IFFALSE 7934
7702: GO 7704
7704: DISABLE
7705: LD_INT 0
7707: PPUSH
// begin dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff Davidov ;
7708: LD_ADDR_VAR 0 1
7712: PUSH
7713: LD_INT 22
7715: PUSH
7716: LD_INT 6
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 2
7725: PUSH
7726: LD_INT 25
7728: PUSH
7729: LD_INT 1
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 25
7738: PUSH
7739: LD_INT 2
7741: PUSH
7742: EMPTY
7743: LIST
7744: LIST
7745: PUSH
7746: LD_INT 25
7748: PUSH
7749: LD_INT 3
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: PUSH
7756: LD_INT 25
7758: PUSH
7759: LD_INT 4
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PUSH
7766: EMPTY
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: LIST
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PPUSH
7777: CALL_OW 69
7781: PUSH
7782: LD_EXP 2
7786: DIFF
7787: ST_TO_ADDR
// Say ( dial [ 1 ] , DRus-3 ) ;
7788: LD_VAR 0 1
7792: PUSH
7793: LD_INT 1
7795: ARRAY
7796: PPUSH
7797: LD_STRING DRus-3
7799: PPUSH
7800: CALL_OW 88
// Say ( Davidov , DDav-5 ) ;
7804: LD_EXP 2
7808: PPUSH
7809: LD_STRING DDav-5
7811: PPUSH
7812: CALL_OW 88
// Say ( dial [ 1 ] , DRus-4 ) ;
7816: LD_VAR 0 1
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PPUSH
7825: LD_STRING DRus-4
7827: PPUSH
7828: CALL_OW 88
// Say ( Davidov , DDav-6 ) ;
7832: LD_EXP 2
7836: PPUSH
7837: LD_STRING DDav-6
7839: PPUSH
7840: CALL_OW 88
// ChangeMissionObjectives ( C2 ) ;
7844: LD_STRING C2
7846: PPUSH
7847: CALL_OW 337
// Wait ( 5 5$00 ) ;
7851: LD_INT 10500
7853: PPUSH
7854: CALL_OW 67
// DialogueOn ;
7858: CALL_OW 6
// SayRadio ( Bagins , DBag-1 ) ;
7862: LD_EXP 1
7866: PPUSH
7867: LD_STRING DBag-1
7869: PPUSH
7870: CALL_OW 94
// Say ( Davidov , DDavB-1 ) ;
7874: LD_EXP 2
7878: PPUSH
7879: LD_STRING DDavB-1
7881: PPUSH
7882: CALL_OW 88
// SayRadio ( Bagins , DBag-2 ) ;
7886: LD_EXP 1
7890: PPUSH
7891: LD_STRING DBag-2
7893: PPUSH
7894: CALL_OW 94
// Say ( Davidov , DDavB-2 ) ;
7898: LD_EXP 2
7902: PPUSH
7903: LD_STRING DDavB-2
7905: PPUSH
7906: CALL_OW 88
// SayRadio ( Bagins , DBag-3 ) ;
7910: LD_EXP 1
7914: PPUSH
7915: LD_STRING DBag-3
7917: PPUSH
7918: CALL_OW 94
// DialogueOff ;
7922: CALL_OW 7
// alliance_attack_active := true ;
7926: LD_ADDR_EXP 9
7930: PUSH
7931: LD_INT 1
7933: ST_TO_ADDR
// end ;
7934: PPOPN 1
7936: END
// every 0 0$1 trigger alliance_used_artifact_1 do
7937: LD_EXP 10
7941: IFFALSE 7988
7943: GO 7945
7945: DISABLE
// begin DialogueOn ;
7946: CALL_OW 6
// CenterNowOnXY ( alliance_used_artifact_1 [ 1 ] , alliance_used_artifact_1 [ 2 ] ) ;
7950: LD_EXP 10
7954: PUSH
7955: LD_INT 1
7957: ARRAY
7958: PPUSH
7959: LD_EXP 10
7963: PUSH
7964: LD_INT 2
7966: ARRAY
7967: PPUSH
7968: CALL_OW 86
// Say ( Davidov , DDav-Artifact1-1 ) ;
7972: LD_EXP 2
7976: PPUSH
7977: LD_STRING DDav-Artifact1-1
7979: PPUSH
7980: CALL_OW 88
// DialogueOff ;
7984: CALL_OW 7
// end ;
7988: END
// every 0 0$1 trigger alliance_used_artifact_2 do
7989: LD_EXP 11
7993: IFFALSE 8040
7995: GO 7997
7997: DISABLE
// begin DialogueOn ;
7998: CALL_OW 6
// CenterNowOnXY ( alliance_used_artifact_2 [ 1 ] , alliance_used_artifact_2 [ 2 ] ) ;
8002: LD_EXP 11
8006: PUSH
8007: LD_INT 1
8009: ARRAY
8010: PPUSH
8011: LD_EXP 11
8015: PUSH
8016: LD_INT 2
8018: ARRAY
8019: PPUSH
8020: CALL_OW 86
// Say ( Davidov , DDav-Artifact2-1 ) ;
8024: LD_EXP 2
8028: PPUSH
8029: LD_STRING DDav-Artifact2-1
8031: PPUSH
8032: CALL_OW 88
// DialogueOff ;
8036: CALL_OW 7
// end ;
8040: END
// every 0 0$01 trigger artifact_destroyed or ( not FindArtifact ( 6 ) and not player_artifact_loaded ) do
8041: LD_EXP 16
8045: PUSH
8046: LD_INT 6
8048: PPUSH
8049: CALL_OW 469
8053: NOT
8054: PUSH
8055: LD_EXP 18
8059: NOT
8060: AND
8061: OR
8062: IFFALSE 8074
8064: GO 8066
8066: DISABLE
// YouLost ( artifact_destroyed ) ;
8067: LD_STRING artifact_destroyed
8069: PPUSH
8070: CALL_OW 104
8074: END
// every 0 0$01 trigger IsDead ( Davidov ) do
8075: LD_EXP 2
8079: PPUSH
8080: CALL_OW 301
8084: IFFALSE 8096
8086: GO 8088
8088: DISABLE
// YouLost ( dead ) ;
8089: LD_STRING dead
8091: PPUSH
8092: CALL_OW 104
8096: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) = 0 do
8097: LD_INT 22
8099: PUSH
8100: LD_INT 7
8102: PUSH
8103: EMPTY
8104: LIST
8105: LIST
8106: PUSH
8107: LD_INT 21
8109: PUSH
8110: LD_INT 1
8112: PUSH
8113: EMPTY
8114: LIST
8115: LIST
8116: PUSH
8117: EMPTY
8118: LIST
8119: LIST
8120: PPUSH
8121: CALL_OW 69
8125: PUSH
8126: LD_INT 0
8128: EQUAL
8129: IFFALSE 8263
8131: GO 8133
8133: DISABLE
// begin if tick < [ 120 120$00 , 100 100$00 , 90 90$00 ] [ Difficulty ] then
8134: LD_OWVAR 1
8138: PUSH
8139: LD_INT 252000
8141: PUSH
8142: LD_INT 210000
8144: PUSH
8145: LD_INT 189000
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: PUSH
8153: LD_OWVAR 67
8157: ARRAY
8158: LESS
8159: IFFALSE 8173
// AddMedal ( med1 , 1 ) else
8161: LD_STRING med1
8163: PPUSH
8164: LD_INT 1
8166: PPUSH
8167: CALL_OW 101
8171: GO 8184
// AddMedal ( med1 , - 1 ) ;
8173: LD_STRING med1
8175: PPUSH
8176: LD_INT 1
8178: NEG
8179: PPUSH
8180: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) then
8184: LD_INT 22
8186: PUSH
8187: LD_INT 8
8189: PUSH
8190: EMPTY
8191: LIST
8192: LIST
8193: PPUSH
8194: CALL_OW 69
8198: IFFALSE 8213
// AddMedal ( med2 , - 1 ) else
8200: LD_STRING med2
8202: PPUSH
8203: LD_INT 1
8205: NEG
8206: PPUSH
8207: CALL_OW 101
8211: GO 8223
// AddMedal ( med2 , 1 ) ;
8213: LD_STRING med2
8215: PPUSH
8216: LD_INT 1
8218: PPUSH
8219: CALL_OW 101
// if player_used_sib_bomb then
8223: LD_EXP 12
8227: IFFALSE 8242
// AddMedal ( med3 , - 1 ) else
8229: LD_STRING med3
8231: PPUSH
8232: LD_INT 1
8234: NEG
8235: PPUSH
8236: CALL_OW 101
8240: GO 8252
// AddMedal ( med3 , 1 ) ;
8242: LD_STRING med3
8244: PPUSH
8245: LD_INT 1
8247: PPUSH
8248: CALL_OW 101
// GiveMedals ( MAIN ) ;
8252: LD_STRING MAIN
8254: PPUSH
8255: CALL_OW 102
// YouWin ;
8259: CALL_OW 103
// end ; end_of_file
8263: END
// every 0 0$22 + 0 0$2 do
8264: GO 8266
8266: DISABLE
// begin enable ;
8267: ENABLE
// CreateCratesArea ( Rand ( 4 , 5 ) , cratesArea , true ) ;
8268: LD_INT 4
8270: PPUSH
8271: LD_INT 5
8273: PPUSH
8274: CALL_OW 12
8278: PPUSH
8279: LD_INT 3
8281: PPUSH
8282: LD_INT 1
8284: PPUSH
8285: CALL_OW 55
// if tick >= 4 4$00 then
8289: LD_OWVAR 1
8293: PUSH
8294: LD_INT 8400
8296: GREATEREQUAL
8297: IFFALSE 8304
// begin disable ;
8299: DISABLE
// CratesSpawn ( ) ;
8300: CALL 8305 0 0
// end ; end ;
8304: END
// function CratesSpawn ( ) ; var i , amount , cr ; begin
8305: LD_INT 0
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// amount := [ 30000 , 20000 , 10000 ] [ Difficulty ] ;
8311: LD_ADDR_VAR 0 3
8315: PUSH
8316: LD_INT 30000
8318: PUSH
8319: LD_INT 20000
8321: PUSH
8322: LD_INT 10000
8324: PUSH
8325: EMPTY
8326: LIST
8327: LIST
8328: LIST
8329: PUSH
8330: LD_OWVAR 67
8334: ARRAY
8335: ST_TO_ADDR
// while amount > 0 do
8336: LD_VAR 0 3
8340: PUSH
8341: LD_INT 0
8343: GREATER
8344: IFFALSE 8414
// begin Wait ( rand ( 0 0$30 , 1 1$30 ) ) ;
8346: LD_INT 1050
8348: PPUSH
8349: LD_INT 3150
8351: PPUSH
8352: CALL_OW 12
8356: PPUSH
8357: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
8361: LD_ADDR_VAR 0 4
8365: PUSH
8366: LD_INT 1
8368: PPUSH
8369: LD_INT 5
8371: PPUSH
8372: CALL_OW 12
8376: ST_TO_ADDR
// amount := amount - ( cr * 10 ) ;
8377: LD_ADDR_VAR 0 3
8381: PUSH
8382: LD_VAR 0 3
8386: PUSH
8387: LD_VAR 0 4
8391: PUSH
8392: LD_INT 10
8394: MUL
8395: MINUS
8396: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
8397: LD_VAR 0 4
8401: PPUSH
8402: LD_INT 3
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 55
// end ;
8412: GO 8336
// end ; end_of_file
8414: LD_VAR 0 1
8418: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird , horse ; begin
8419: LD_INT 0
8421: PPUSH
8422: PPUSH
8423: PPUSH
8424: PPUSH
8425: PPUSH
8426: PPUSH
// uc_nation = nation_nature ;
8427: LD_ADDR_OWVAR 21
8431: PUSH
8432: LD_INT 0
8434: ST_TO_ADDR
// uc_side = 0 ;
8435: LD_ADDR_OWVAR 20
8439: PUSH
8440: LD_INT 0
8442: ST_TO_ADDR
// l = 0 ;
8443: LD_ADDR_VAR 0 6
8447: PUSH
8448: LD_INT 0
8450: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
8451: LD_ADDR_OWVAR 24
8455: PUSH
8456: LD_INT 0
8458: PPUSH
8459: LD_INT 5
8461: PPUSH
8462: CALL_OW 12
8466: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
8467: LD_ADDR_OWVAR 35
8471: PUSH
8472: LD_INT 5
8474: NEG
8475: PPUSH
8476: LD_INT 5
8478: PPUSH
8479: CALL_OW 12
8483: ST_TO_ADDR
// hc_gallery =  ;
8484: LD_ADDR_OWVAR 33
8488: PUSH
8489: LD_STRING 
8491: ST_TO_ADDR
// hc_class = class_apeman ;
8492: LD_ADDR_OWVAR 28
8496: PUSH
8497: LD_INT 12
8499: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
8500: LD_ADDR_OWVAR 29
8504: PUSH
8505: LD_INT 11
8507: PPUSH
8508: LD_INT 13
8510: PPUSH
8511: CALL_OW 12
8515: PUSH
8516: LD_INT 10
8518: PPUSH
8519: LD_INT 11
8521: PPUSH
8522: CALL_OW 12
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: ST_TO_ADDR
// hc_sex = sex_male ;
8531: LD_ADDR_OWVAR 27
8535: PUSH
8536: LD_INT 1
8538: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
8539: LD_ADDR_OWVAR 31
8543: PUSH
8544: LD_INT 0
8546: PPUSH
8547: LD_INT 2
8549: PPUSH
8550: CALL_OW 12
8554: PUSH
8555: LD_INT 0
8557: PUSH
8558: LD_INT 0
8560: PUSH
8561: LD_INT 0
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: ST_TO_ADDR
// apeman = CreateHuman ;
8570: LD_ADDR_VAR 0 7
8574: PUSH
8575: CALL_OW 44
8579: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
8580: LD_VAR 0 7
8584: PPUSH
8585: LD_VAR 0 4
8589: PPUSH
8590: LD_INT 0
8592: PPUSH
8593: CALL_OW 49
// l = l + 1 ;
8597: LD_ADDR_VAR 0 6
8601: PUSH
8602: LD_VAR 0 6
8606: PUSH
8607: LD_INT 1
8609: PLUS
8610: ST_TO_ADDR
// end until l = num1 ;
8611: LD_VAR 0 6
8615: PUSH
8616: LD_VAR 0 1
8620: EQUAL
8621: IFFALSE 8451
// l = 0 ;
8623: LD_ADDR_VAR 0 6
8627: PUSH
8628: LD_INT 0
8630: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
8631: LD_ADDR_OWVAR 35
8635: PUSH
8636: LD_INT 0
8638: PPUSH
8639: LD_INT 25
8641: PPUSH
8642: CALL_OW 12
8646: ST_TO_ADDR
// hc_class = class_tiger ;
8647: LD_ADDR_OWVAR 28
8651: PUSH
8652: LD_INT 14
8654: ST_TO_ADDR
// hc_sex = sex_male ;
8655: LD_ADDR_OWVAR 27
8659: PUSH
8660: LD_INT 1
8662: ST_TO_ADDR
// hc_gallery = sandnature ;
8663: LD_ADDR_OWVAR 33
8667: PUSH
8668: LD_STRING sandnature
8670: ST_TO_ADDR
// hc_face_number = 3 ;
8671: LD_ADDR_OWVAR 34
8675: PUSH
8676: LD_INT 3
8678: ST_TO_ADDR
// tiger = CreateHuman ;
8679: LD_ADDR_VAR 0 8
8683: PUSH
8684: CALL_OW 44
8688: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8689: LD_VAR 0 8
8693: PPUSH
8694: LD_VAR 0 4
8698: PPUSH
8699: LD_INT 0
8701: PPUSH
8702: CALL_OW 49
// l = l + 1 ;
8706: LD_ADDR_VAR 0 6
8710: PUSH
8711: LD_VAR 0 6
8715: PUSH
8716: LD_INT 1
8718: PLUS
8719: ST_TO_ADDR
// end until l = num2 ;
8720: LD_VAR 0 6
8724: PUSH
8725: LD_VAR 0 2
8729: EQUAL
8730: IFFALSE 8631
// l = 0 ;
8732: LD_ADDR_VAR 0 6
8736: PUSH
8737: LD_INT 0
8739: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8740: LD_ADDR_OWVAR 28
8744: PUSH
8745: LD_INT 18
8747: ST_TO_ADDR
// hc_gallery = sandnature ;
8748: LD_ADDR_OWVAR 33
8752: PUSH
8753: LD_STRING sandnature
8755: ST_TO_ADDR
// hc_face_number = 1 ;
8756: LD_ADDR_OWVAR 34
8760: PUSH
8761: LD_INT 1
8763: ST_TO_ADDR
// bird = CreateHuman ;
8764: LD_ADDR_VAR 0 9
8768: PUSH
8769: CALL_OW 44
8773: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8774: LD_VAR 0 9
8778: PPUSH
8779: LD_INT 0
8781: PPUSH
8782: CALL_OW 51
// l = l + 1 ;
8786: LD_ADDR_VAR 0 6
8790: PUSH
8791: LD_VAR 0 6
8795: PUSH
8796: LD_INT 1
8798: PLUS
8799: ST_TO_ADDR
// end until l = num3 ;
8800: LD_VAR 0 6
8804: PUSH
8805: LD_VAR 0 3
8809: EQUAL
8810: IFFALSE 8740
// for l = 1 to 2 do
8812: LD_ADDR_VAR 0 6
8816: PUSH
8817: DOUBLE
8818: LD_INT 1
8820: DEC
8821: ST_TO_ADDR
8822: LD_INT 2
8824: PUSH
8825: FOR_TO
8826: IFFALSE 8884
// begin hc_class = 21 ;
8828: LD_ADDR_OWVAR 28
8832: PUSH
8833: LD_INT 21
8835: ST_TO_ADDR
// hc_gallery =  ;
8836: LD_ADDR_OWVAR 33
8840: PUSH
8841: LD_STRING 
8843: ST_TO_ADDR
// hc_agressivity = 0 ;
8844: LD_ADDR_OWVAR 35
8848: PUSH
8849: LD_INT 0
8851: ST_TO_ADDR
// hc_face_number = 5 ;
8852: LD_ADDR_OWVAR 34
8856: PUSH
8857: LD_INT 5
8859: ST_TO_ADDR
// horse := CreateHuman ;
8860: LD_ADDR_VAR 0 10
8864: PUSH
8865: CALL_OW 44
8869: ST_TO_ADDR
// PlaceUnitAnywhere ( horse , false ) ;
8870: LD_VAR 0 10
8874: PPUSH
8875: LD_INT 0
8877: PPUSH
8878: CALL_OW 51
// end ;
8882: GO 8825
8884: POP
8885: POP
// hc_gallery :=  ;
8886: LD_ADDR_OWVAR 33
8890: PUSH
8891: LD_STRING 
8893: ST_TO_ADDR
// hc_name :=  ;
8894: LD_ADDR_OWVAR 26
8898: PUSH
8899: LD_STRING 
8901: ST_TO_ADDR
// end ; end_of_file
8902: LD_VAR 0 5
8906: RET
// every 0 0$01 trigger not debug do var timer ;
8907: LD_EXP 6
8911: NOT
8912: IFFALSE 8972
8914: GO 8916
8916: DISABLE
8917: LD_INT 0
8919: PPUSH
// begin timer := 0 0$00 ;
8920: LD_ADDR_VAR 0 1
8924: PUSH
8925: LD_INT 0
8927: ST_TO_ADDR
// while ( true ) do
8928: LD_INT 1
8930: IFFALSE 8972
// begin timer := timer + 0 0$01 ;
8932: LD_ADDR_VAR 0 1
8936: PUSH
8937: LD_VAR 0 1
8941: PUSH
8942: LD_INT 35
8944: PLUS
8945: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
8946: LD_ADDR_OWVAR 47
8950: PUSH
8951: LD_STRING #tick
8953: PUSH
8954: LD_VAR 0 1
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
8963: LD_INT 35
8965: PPUSH
8966: CALL_OW 67
// end ;
8970: GO 8928
// end ; end_of_file
8972: PPOPN 1
8974: END
// export function DebugArtifact ; begin
8975: LD_INT 0
8977: PPUSH
// AddToLog ( Artifact is loaded:  & player_artifact_loaded ) ;
8978: LD_STRING Artifact is loaded: 
8980: PUSH
8981: LD_EXP 18
8985: STR
8986: PPUSH
8987: CALL_OW 561
// AddToLog ( Artifact is active:  & player_artifact_ready ) ;
8991: LD_STRING Artifact is active: 
8993: PUSH
8994: LD_EXP 29
8998: STR
8999: PPUSH
9000: CALL_OW 561
// AddToLog ( Artifact is researched:  & player_artifact_researched ) ;
9004: LD_STRING Artifact is researched: 
9006: PUSH
9007: LD_EXP 22
9011: STR
9012: PPUSH
9013: CALL_OW 561
// AddToLog ( Artifact coords  & FindArtifact ( player_artifact_number ) ) ;
9017: LD_STRING Artifact coords 
9019: PUSH
9020: LD_EXP 19
9024: PPUSH
9025: CALL_OW 469
9029: STR
9030: PPUSH
9031: CALL_OW 561
// end ;
9035: LD_VAR 0 1
9039: RET
// export function InitArtifactsPos ( ) ; var i , tmp , possible_pos ; begin
9040: LD_INT 0
9042: PPUSH
9043: PPUSH
9044: PPUSH
9045: PPUSH
// possible_pos := [ [ 100 , 185 ] , [ 99 , 175 ] , [ 117 , 191 ] ] ;
9046: LD_ADDR_VAR 0 4
9050: PUSH
9051: LD_INT 100
9053: PUSH
9054: LD_INT 185
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: PUSH
9061: LD_INT 99
9063: PUSH
9064: LD_INT 175
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: PUSH
9071: LD_INT 117
9073: PUSH
9074: LD_INT 191
9076: PUSH
9077: EMPTY
9078: LIST
9079: LIST
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// for i = 1 to artifacts_type do
9086: LD_ADDR_VAR 0 2
9090: PUSH
9091: DOUBLE
9092: LD_INT 1
9094: DEC
9095: ST_TO_ADDR
9096: LD_EXP 14
9100: PUSH
9101: FOR_TO
9102: IFFALSE 9204
// begin tmp := possible_pos [ rand ( 1 , possible_pos ) ] ;
9104: LD_ADDR_VAR 0 3
9108: PUSH
9109: LD_VAR 0 4
9113: PUSH
9114: LD_INT 1
9116: PPUSH
9117: LD_VAR 0 4
9121: PPUSH
9122: CALL_OW 12
9126: ARRAY
9127: ST_TO_ADDR
// possible_pos := possible_pos diff tmp ;
9128: LD_ADDR_VAR 0 4
9132: PUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 3
9142: DIFF
9143: ST_TO_ADDR
// artifacts_pos := Insert ( artifacts_pos , i , tmp ) ;
9144: LD_ADDR_EXP 15
9148: PUSH
9149: LD_EXP 15
9153: PPUSH
9154: LD_VAR 0 2
9158: PPUSH
9159: LD_VAR 0 3
9163: PPUSH
9164: CALL_OW 2
9168: ST_TO_ADDR
// CreateArtifact ( artifacts_type [ i ] , tmp [ 1 ] , tmp [ 2 ] ) ;
9169: LD_EXP 14
9173: PUSH
9174: LD_VAR 0 2
9178: ARRAY
9179: PPUSH
9180: LD_VAR 0 3
9184: PUSH
9185: LD_INT 1
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_INT 2
9196: ARRAY
9197: PPUSH
9198: CALL 5175 0 3
// end ;
9202: GO 9101
9204: POP
9205: POP
// end ;
9206: LD_VAR 0 1
9210: RET
// export function GetUseCost ( dist ) ; begin
9211: LD_INT 0
9213: PPUSH
// if dist < 30 then
9214: LD_VAR 0 1
9218: PUSH
9219: LD_INT 30
9221: LESS
9222: IFFALSE 9232
// result := 10 ;
9224: LD_ADDR_VAR 0 2
9228: PUSH
9229: LD_INT 10
9231: ST_TO_ADDR
// if dist >= 30 and dist < 50 then
9232: LD_VAR 0 1
9236: PUSH
9237: LD_INT 30
9239: GREATEREQUAL
9240: PUSH
9241: LD_VAR 0 1
9245: PUSH
9246: LD_INT 50
9248: LESS
9249: AND
9250: IFFALSE 9260
// result := 35 ;
9252: LD_ADDR_VAR 0 2
9256: PUSH
9257: LD_INT 35
9259: ST_TO_ADDR
// if dist >= 50 and dist < 80 then
9260: LD_VAR 0 1
9264: PUSH
9265: LD_INT 50
9267: GREATEREQUAL
9268: PUSH
9269: LD_VAR 0 1
9273: PUSH
9274: LD_INT 80
9276: LESS
9277: AND
9278: IFFALSE 9288
// result := 70 ;
9280: LD_ADDR_VAR 0 2
9284: PUSH
9285: LD_INT 70
9287: ST_TO_ADDR
// if dist >= 80 and dist < 120 then
9288: LD_VAR 0 1
9292: PUSH
9293: LD_INT 80
9295: GREATEREQUAL
9296: PUSH
9297: LD_VAR 0 1
9301: PUSH
9302: LD_INT 120
9304: LESS
9305: AND
9306: IFFALSE 9316
// result := 100 ;
9308: LD_ADDR_VAR 0 2
9312: PUSH
9313: LD_INT 100
9315: ST_TO_ADDR
// if dist >= 120 then
9316: LD_VAR 0 1
9320: PUSH
9321: LD_INT 120
9323: GREATEREQUAL
9324: IFFALSE 9334
// result := 150 ;
9326: LD_ADDR_VAR 0 2
9330: PUSH
9331: LD_INT 150
9333: ST_TO_ADDR
// end ;
9334: LD_VAR 0 2
9338: RET
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
9339: LD_VAR 0 1
9343: PPUSH
9344: CALL_OW 255
9348: PUSH
9349: LD_OWVAR 2
9353: EQUAL
9354: IFFALSE 9364
// player_artifact_researched := true ;
9356: LD_ADDR_EXP 22
9360: PUSH
9361: LD_INT 1
9363: ST_TO_ADDR
// end ;
9364: PPOPN 1
9366: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_artifact_researched and not player_artifact_loaded do var lab , coords ;
9367: LD_INT 22
9369: PUSH
9370: LD_OWVAR 2
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PUSH
9379: LD_INT 2
9381: PUSH
9382: LD_INT 30
9384: PUSH
9385: LD_INT 8
9387: PUSH
9388: EMPTY
9389: LIST
9390: LIST
9391: PUSH
9392: LD_INT 30
9394: PUSH
9395: LD_INT 11
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: LIST
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PPUSH
9411: CALL_OW 69
9415: PUSH
9416: LD_EXP 22
9420: AND
9421: PUSH
9422: LD_EXP 18
9426: NOT
9427: AND
9428: IFFALSE 9882
9430: GO 9432
9432: DISABLE
9433: LD_INT 0
9435: PPUSH
9436: PPUSH
// begin enable ;
9437: ENABLE
// coords := FindArtifact ( player_artifact_number ) ;
9438: LD_ADDR_VAR 0 2
9442: PUSH
9443: LD_EXP 19
9447: PPUSH
9448: CALL_OW 469
9452: ST_TO_ADDR
// if not coords then
9453: LD_VAR 0 2
9457: NOT
9458: IFFALSE 9462
// exit ;
9460: GO 9882
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , coords [ 1 ] , coords [ 2 ] ) ;
9462: LD_ADDR_VAR 0 1
9466: PUSH
9467: LD_INT 22
9469: PUSH
9470: LD_OWVAR 2
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 2
9481: PUSH
9482: LD_INT 30
9484: PUSH
9485: LD_INT 8
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: PUSH
9492: LD_INT 30
9494: PUSH
9495: LD_INT 11
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: PPUSH
9511: CALL_OW 69
9515: PPUSH
9516: LD_VAR 0 2
9520: PUSH
9521: LD_INT 1
9523: ARRAY
9524: PPUSH
9525: LD_VAR 0 2
9529: PUSH
9530: LD_INT 2
9532: ARRAY
9533: PPUSH
9534: CALL_OW 73
9538: ST_TO_ADDR
// if not lab then
9539: LD_VAR 0 1
9543: NOT
9544: IFFALSE 9561
// begin if debug then
9546: LD_EXP 6
9550: IFFALSE 9559
// AddToLog ( Cannot find lab for artifact! ) ;
9552: LD_STRING Cannot find lab for artifact!
9554: PPUSH
9555: CALL_OW 561
// exit ;
9559: GO 9882
// end ; if not player_artifact_ready then
9561: LD_EXP 29
9565: NOT
9566: IFFALSE 9690
// begin if GetDistUnitXY ( lab , coords [ 1 ] , coords [ 2 ] ) < player_artifact_active_distance then
9568: LD_VAR 0 1
9572: PPUSH
9573: LD_VAR 0 2
9577: PUSH
9578: LD_INT 1
9580: ARRAY
9581: PPUSH
9582: LD_VAR 0 2
9586: PUSH
9587: LD_INT 2
9589: ARRAY
9590: PPUSH
9591: CALL_OW 297
9595: PUSH
9596: LD_EXP 23
9600: LESS
9601: IFFALSE 9666
// begin if BuildingStatus ( lab ) = bs_idle then
9603: LD_VAR 0 1
9607: PPUSH
9608: CALL_OW 461
9612: PUSH
9613: LD_INT 2
9615: EQUAL
9616: IFFALSE 9642
// SetArtifactUse ( your_side , player_artifact_icon_res , art_instant , lab ) else
9618: LD_OWVAR 2
9622: PPUSH
9623: LD_EXP 25
9627: PPUSH
9628: LD_INT 2
9630: PPUSH
9631: LD_VAR 0 1
9635: PPUSH
9636: CALL_OW 468
9640: GO 9664
// SetArtifactUse ( your_side , player_artifact_icon_res , art_gray , lab ) ;
9642: LD_OWVAR 2
9646: PPUSH
9647: LD_EXP 25
9651: PPUSH
9652: LD_INT 1
9654: PPUSH
9655: LD_VAR 0 1
9659: PPUSH
9660: CALL_OW 468
// end else
9664: GO 9688
// SetArtifactUse ( your_side , player_artifact_icon_res , art_gray , lab ) ;
9666: LD_OWVAR 2
9670: PPUSH
9671: LD_EXP 25
9675: PPUSH
9676: LD_INT 1
9678: PPUSH
9679: LD_VAR 0 1
9683: PPUSH
9684: CALL_OW 468
// end else
9688: GO 9882
// if GetDistUnitXY ( lab , coords [ 1 ] , coords [ 2 ] ) < player_artifact_active_distance then
9690: LD_VAR 0 1
9694: PPUSH
9695: LD_VAR 0 2
9699: PUSH
9700: LD_INT 1
9702: ARRAY
9703: PPUSH
9704: LD_VAR 0 2
9708: PUSH
9709: LD_INT 2
9711: ARRAY
9712: PPUSH
9713: CALL_OW 297
9717: PUSH
9718: LD_EXP 23
9722: LESS
9723: IFFALSE 9838
// begin if BuildingStatus ( lab ) = bs_idle then
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 461
9734: PUSH
9735: LD_INT 2
9737: EQUAL
9738: IFFALSE 9792
// begin SetArtifactUse ( your_side , player_artifact_icon , art_unit , lab ) ;
9740: LD_OWVAR 2
9744: PPUSH
9745: LD_EXP 20
9749: PPUSH
9750: LD_INT 4
9752: PPUSH
9753: LD_VAR 0 1
9757: PPUSH
9758: CALL_OW 468
// if player_artifact_selected_unit then
9762: LD_EXP 30
9766: IFFALSE 9790
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_place , lab ) ;
9768: LD_OWVAR 2
9772: PPUSH
9773: LD_EXP 21
9777: PPUSH
9778: LD_INT 3
9780: PPUSH
9781: LD_VAR 0 1
9785: PPUSH
9786: CALL_OW 468
// end else
9790: GO 9836
// begin SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
9792: LD_OWVAR 2
9796: PPUSH
9797: LD_EXP 20
9801: PPUSH
9802: LD_INT 1
9804: PPUSH
9805: LD_VAR 0 1
9809: PPUSH
9810: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_gray , lab ) ;
9814: LD_OWVAR 2
9818: PPUSH
9819: LD_EXP 21
9823: PPUSH
9824: LD_INT 1
9826: PPUSH
9827: LD_VAR 0 1
9831: PPUSH
9832: CALL_OW 468
// end ; end else
9836: GO 9882
// begin SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
9838: LD_OWVAR 2
9842: PPUSH
9843: LD_EXP 20
9847: PPUSH
9848: LD_INT 1
9850: PPUSH
9851: LD_VAR 0 1
9855: PPUSH
9856: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_gray , lab ) ;
9860: LD_OWVAR 2
9864: PPUSH
9865: LD_EXP 21
9869: PPUSH
9870: LD_INT 1
9872: PPUSH
9873: LD_VAR 0 1
9877: PPUSH
9878: CALL_OW 468
// end ; end ;
9882: PPOPN 2
9884: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var coords , i , lab , side , dist , cost ;
9885: LD_INT 0
9887: PPUSH
9888: PPUSH
9889: PPUSH
9890: PPUSH
9891: PPUSH
9892: PPUSH
// begin coords := FindArtifact ( player_artifact_number ) ;
9893: LD_ADDR_VAR 0 5
9897: PUSH
9898: LD_EXP 19
9902: PPUSH
9903: CALL_OW 469
9907: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , coords [ 1 ] , coords [ 2 ] ) ;
9908: LD_ADDR_VAR 0 7
9912: PUSH
9913: LD_INT 22
9915: PUSH
9916: LD_OWVAR 2
9920: PUSH
9921: EMPTY
9922: LIST
9923: LIST
9924: PUSH
9925: LD_INT 2
9927: PUSH
9928: LD_INT 30
9930: PUSH
9931: LD_INT 8
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: PUSH
9938: LD_INT 30
9940: PUSH
9941: LD_INT 11
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: PUSH
9948: EMPTY
9949: LIST
9950: LIST
9951: LIST
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PPUSH
9957: CALL_OW 69
9961: PPUSH
9962: LD_VAR 0 5
9966: PUSH
9967: LD_INT 1
9969: ARRAY
9970: PPUSH
9971: LD_VAR 0 5
9975: PUSH
9976: LD_INT 2
9978: ARRAY
9979: PPUSH
9980: CALL_OW 73
9984: ST_TO_ADDR
// if not lab then
9985: LD_VAR 0 7
9989: NOT
9990: IFFALSE 10007
// begin if debug then
9992: LD_EXP 6
9996: IFFALSE 10005
// AddToLog ( Cannot find lab! ) ;
9998: LD_STRING Cannot find lab!
10000: PPUSH
10001: CALL_OW 561
// exit ;
10005: GO 10365
// end ; if icon = player_artifact_icon_res then
10007: LD_VAR 0 2
10011: PUSH
10012: LD_EXP 25
10016: EQUAL
10017: IFFALSE 10058
// begin SetSpecResearch ( lab , player_artifact_time_res , true ) ;
10019: LD_VAR 0 7
10023: PPUSH
10024: LD_EXP 27
10028: PPUSH
10029: LD_INT 1
10031: PPUSH
10032: CALL_OW 486
// SetArtifactUse ( your_side , player_artifact_icon_res , art_no , lab ) ;
10036: LD_OWVAR 2
10040: PPUSH
10041: LD_EXP 25
10045: PPUSH
10046: LD_INT 0
10048: PPUSH
10049: LD_VAR 0 7
10053: PPUSH
10054: CALL_OW 468
// end ; if icon = player_artifact_icon then
10058: LD_VAR 0 2
10062: PUSH
10063: LD_EXP 20
10067: EQUAL
10068: IFFALSE 10107
// begin if GetType ( cr1 ) = unit_human and not IsInUnit ( cr1 ) then
10070: LD_VAR 0 3
10074: PPUSH
10075: CALL_OW 247
10079: PUSH
10080: LD_INT 1
10082: EQUAL
10083: PUSH
10084: LD_VAR 0 3
10088: PPUSH
10089: CALL_OW 310
10093: NOT
10094: AND
10095: IFFALSE 10107
// player_artifact_selected_unit := cr1 ;
10097: LD_ADDR_EXP 30
10101: PUSH
10102: LD_VAR 0 3
10106: ST_TO_ADDR
// end ; if icon = player_artifact_icon_2 then
10107: LD_VAR 0 2
10111: PUSH
10112: LD_EXP 21
10116: EQUAL
10117: IFFALSE 10355
// begin if HexInfo ( cr1 , cr2 ) <> 0 then
10119: LD_VAR 0 3
10123: PPUSH
10124: LD_VAR 0 4
10128: PPUSH
10129: CALL_OW 428
10133: PUSH
10134: LD_INT 0
10136: NONEQUAL
10137: IFFALSE 10141
// exit ;
10139: GO 10365
// dist := GetDistXY ( GetX ( player_artifact_selected_unit ) , GetY ( player_artifact_selected_unit ) , cr1 , cr2 ) ;
10141: LD_ADDR_VAR 0 9
10145: PUSH
10146: LD_EXP 30
10150: PPUSH
10151: CALL_OW 250
10155: PPUSH
10156: LD_EXP 30
10160: PPUSH
10161: CALL_OW 251
10165: PPUSH
10166: LD_VAR 0 3
10170: PPUSH
10171: LD_VAR 0 4
10175: PPUSH
10176: CALL_OW 298
10180: ST_TO_ADDR
// cost := GetUseCost ( dist ) ;
10181: LD_ADDR_VAR 0 10
10185: PUSH
10186: LD_VAR 0 9
10190: PPUSH
10191: CALL 9211 0 1
10195: ST_TO_ADDR
// if cost > GetSibResources ( your_side ) then
10196: LD_VAR 0 10
10200: PUSH
10201: LD_OWVAR 2
10205: PPUSH
10206: CALL 5389 0 1
10210: GREATER
10211: IFFALSE 10225
// begin HintSpec ( ArtFrogJumpCost , 2 ) ;
10213: LD_STRING ArtFrogJumpCost
10215: PPUSH
10216: LD_INT 2
10218: PPUSH
10219: CALL_OW 338
// exit ;
10223: GO 10365
// end ; SetSibResources ( your_side , cost ) ;
10225: LD_OWVAR 2
10229: PPUSH
10230: LD_VAR 0 10
10234: PPUSH
10235: CALL 5513 0 2
// TeleportUnit ( player_artifact_selected_unit , cr1 , cr2 , 0 , true ) ;
10239: LD_EXP 30
10243: PPUSH
10244: LD_VAR 0 3
10248: PPUSH
10249: LD_VAR 0 4
10253: PPUSH
10254: LD_INT 0
10256: PPUSH
10257: LD_INT 1
10259: PPUSH
10260: CALL_OW 483
// CenterOnXY ( cr1 , cr2 ) ;
10264: LD_VAR 0 3
10268: PPUSH
10269: LD_VAR 0 4
10273: PPUSH
10274: CALL_OW 84
// player_artifact_selected_unit := 0 ;
10278: LD_ADDR_EXP 30
10282: PUSH
10283: LD_INT 0
10285: ST_TO_ADDR
// player_artifact_researched := false ;
10286: LD_ADDR_EXP 22
10290: PUSH
10291: LD_INT 0
10293: ST_TO_ADDR
// SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
10294: LD_OWVAR 2
10298: PPUSH
10299: LD_EXP 20
10303: PPUSH
10304: LD_INT 1
10306: PPUSH
10307: LD_VAR 0 7
10311: PPUSH
10312: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_no , lab ) ;
10316: LD_OWVAR 2
10320: PPUSH
10321: LD_EXP 21
10325: PPUSH
10326: LD_INT 0
10328: PPUSH
10329: LD_VAR 0 7
10333: PPUSH
10334: CALL_OW 468
// Wait ( player_artifact_time_refresh ) ;
10338: LD_EXP 26
10342: PPUSH
10343: CALL_OW 67
// player_artifact_researched := true ;
10347: LD_ADDR_EXP 22
10351: PUSH
10352: LD_INT 1
10354: ST_TO_ADDR
// end ; if debug then
10355: LD_EXP 6
10359: IFFALSE 10365
// DebugArtifact ;
10361: CALL 8975 0 0
// end ;
10365: PPOPN 10
10367: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
10368: LD_VAR 0 1
10372: PPUSH
10373: CALL_OW 255
10377: PUSH
10378: LD_OWVAR 2
10382: EQUAL
10383: IFFALSE 10422
// begin SetArtifactUse ( your_side , player_artifact_icon_res , art_no , lab ) ;
10385: LD_OWVAR 2
10389: PPUSH
10390: LD_EXP 25
10394: PPUSH
10395: LD_INT 0
10397: PPUSH
10398: LD_VAR 0 1
10402: PPUSH
10403: CALL_OW 468
// player_artifact_ready := true ;
10407: LD_ADDR_EXP 29
10411: PUSH
10412: LD_INT 1
10414: ST_TO_ADDR
// Hint ( ArtFrogJump ) ;
10415: LD_STRING ArtFrogJump
10417: PPUSH
10418: CALL_OW 339
// end ; end ;
10422: PPOPN 1
10424: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , player_artifact_icon_res , art_instant , lab ) ;
10425: LD_OWVAR 2
10429: PPUSH
10430: LD_EXP 25
10434: PPUSH
10435: LD_INT 2
10437: PPUSH
10438: LD_VAR 0 1
10442: PPUSH
10443: CALL_OW 468
// end ;
10447: PPOPN 2
10449: END
// export function ActiveArtifact1 ( ) ; var i , tmp , un ; begin
10450: LD_INT 0
10452: PPUSH
10453: PPUSH
10454: PPUSH
10455: PPUSH
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_weapon , ru_siberium_rocket ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_siberite_power ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_siberite_mine ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_ext_siberium ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_teleport ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_bweapon , ru_time_lapser ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_bweapon , ru_rocket ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_engine , engine_siberite ] ] ) ;
10456: LD_ADDR_VAR 0 3
10460: PUSH
10461: LD_INT 81
10463: PUSH
10464: LD_INT 7
10466: PUSH
10467: EMPTY
10468: LIST
10469: LIST
10470: PUSH
10471: LD_INT 34
10473: PUSH
10474: LD_INT 48
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PPUSH
10485: CALL_OW 69
10489: PUSH
10490: LD_INT 81
10492: PUSH
10493: LD_INT 7
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PUSH
10500: LD_INT 30
10502: PUSH
10503: LD_INT 28
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: PPUSH
10514: CALL_OW 69
10518: ADD
10519: PUSH
10520: LD_INT 81
10522: PUSH
10523: LD_INT 7
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: LD_INT 30
10532: PUSH
10533: LD_INT 30
10535: PUSH
10536: EMPTY
10537: LIST
10538: LIST
10539: PUSH
10540: EMPTY
10541: LIST
10542: LIST
10543: PPUSH
10544: CALL_OW 69
10548: ADD
10549: PUSH
10550: LD_INT 81
10552: PUSH
10553: LD_INT 7
10555: PUSH
10556: EMPTY
10557: LIST
10558: LIST
10559: PUSH
10560: LD_INT 30
10562: PUSH
10563: LD_INT 21
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: PPUSH
10574: CALL_OW 69
10578: ADD
10579: PUSH
10580: LD_INT 81
10582: PUSH
10583: LD_INT 7
10585: PUSH
10586: EMPTY
10587: LIST
10588: LIST
10589: PUSH
10590: LD_INT 30
10592: PUSH
10593: LD_INT 34
10595: PUSH
10596: EMPTY
10597: LIST
10598: LIST
10599: PUSH
10600: EMPTY
10601: LIST
10602: LIST
10603: PPUSH
10604: CALL_OW 69
10608: ADD
10609: PUSH
10610: LD_INT 81
10612: PUSH
10613: LD_INT 7
10615: PUSH
10616: EMPTY
10617: LIST
10618: LIST
10619: PUSH
10620: LD_INT 35
10622: PUSH
10623: LD_INT 49
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PPUSH
10634: CALL_OW 69
10638: ADD
10639: PUSH
10640: LD_INT 81
10642: PUSH
10643: LD_INT 7
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PUSH
10650: LD_INT 35
10652: PUSH
10653: LD_INT 47
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PPUSH
10664: CALL_OW 69
10668: ADD
10669: PUSH
10670: LD_INT 81
10672: PUSH
10673: LD_INT 7
10675: PUSH
10676: EMPTY
10677: LIST
10678: LIST
10679: PUSH
10680: LD_INT 32
10682: PUSH
10683: LD_INT 3
10685: PUSH
10686: EMPTY
10687: LIST
10688: LIST
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PPUSH
10694: CALL_OW 69
10698: ADD
10699: ST_TO_ADDR
// if not tmp then
10700: LD_VAR 0 3
10704: NOT
10705: IFFALSE 10709
// exit ;
10707: GO 10830
// if UnitFilter ( tmp , [ f_weapon , ru_siberium_rocket ] ) then
10709: LD_VAR 0 3
10713: PPUSH
10714: LD_INT 34
10716: PUSH
10717: LD_INT 48
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: PPUSH
10724: CALL_OW 72
10728: IFFALSE 10761
// un := UnitFilter ( tmp , [ f_weapon , ru_siberium_rocket ] ) [ 1 ] else
10730: LD_ADDR_VAR 0 4
10734: PUSH
10735: LD_VAR 0 3
10739: PPUSH
10740: LD_INT 34
10742: PUSH
10743: LD_INT 48
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PPUSH
10750: CALL_OW 72
10754: PUSH
10755: LD_INT 1
10757: ARRAY
10758: ST_TO_ADDR
10759: GO 10785
// un := tmp [ rand ( 1 , tmp ) ] ;
10761: LD_ADDR_VAR 0 4
10765: PUSH
10766: LD_VAR 0 3
10770: PUSH
10771: LD_INT 1
10773: PPUSH
10774: LD_VAR 0 3
10778: PPUSH
10779: CALL_OW 12
10783: ARRAY
10784: ST_TO_ADDR
// if not alliance_used_artifact_1 then
10785: LD_EXP 10
10789: NOT
10790: IFFALSE 10821
// alliance_used_artifact_1 := [ GetX ( un ) , GetY ( un ) ] ;
10792: LD_ADDR_EXP 10
10796: PUSH
10797: LD_VAR 0 4
10801: PPUSH
10802: CALL_OW 250
10806: PUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL_OW 251
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: ST_TO_ADDR
// KillUnit ( un ) ;
10821: LD_VAR 0 4
10825: PPUSH
10826: CALL_OW 66
// end ;
10830: LD_VAR 0 1
10834: RET
// export function ActiveArtifact2 ( ) ; var i , un , tmp ; begin
10835: LD_INT 0
10837: PPUSH
10838: PPUSH
10839: PPUSH
10840: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , 6 ] , [ f_control , control_computer ] ] ) ;
10841: LD_ADDR_VAR 0 4
10845: PUSH
10846: LD_INT 22
10848: PUSH
10849: LD_INT 6
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: PUSH
10856: LD_INT 33
10858: PUSH
10859: LD_INT 3
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PUSH
10866: EMPTY
10867: LIST
10868: LIST
10869: PPUSH
10870: CALL_OW 69
10874: ST_TO_ADDR
// if not tmp then
10875: LD_VAR 0 4
10879: NOT
10880: IFFALSE 10884
// exit ;
10882: GO 11010
// un := tmp [ rand ( 1 , tmp ) ] ;
10884: LD_ADDR_VAR 0 3
10888: PUSH
10889: LD_VAR 0 4
10893: PUSH
10894: LD_INT 1
10896: PPUSH
10897: LD_VAR 0 4
10901: PPUSH
10902: CALL_OW 12
10906: ARRAY
10907: ST_TO_ADDR
// if GetWeapon ( un ) = ru_siberium_rocket then
10908: LD_VAR 0 3
10912: PPUSH
10913: CALL_OW 264
10917: PUSH
10918: LD_INT 48
10920: EQUAL
10921: IFFALSE 10940
// ComAttackPlace ( un , 194 , 19 ) else
10923: LD_VAR 0 3
10927: PPUSH
10928: LD_INT 194
10930: PPUSH
10931: LD_INT 19
10933: PPUSH
10934: CALL_OW 116
10938: GO 10974
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , un ) ) ;
10940: LD_VAR 0 3
10944: PPUSH
10945: LD_INT 81
10947: PUSH
10948: LD_INT 7
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: PPUSH
10955: CALL_OW 69
10959: PPUSH
10960: LD_VAR 0 3
10964: PPUSH
10965: CALL_OW 74
10969: PPUSH
10970: CALL_OW 115
// if not alliance_used_artifact_2 then
10974: LD_EXP 11
10978: NOT
10979: IFFALSE 11010
// alliance_used_artifact_2 := [ GetX ( un ) , GetY ( un ) ] ;
10981: LD_ADDR_EXP 11
10985: PUSH
10986: LD_VAR 0 3
10990: PPUSH
10991: CALL_OW 250
10995: PUSH
10996: LD_VAR 0 3
11000: PPUSH
11001: CALL_OW 251
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: ST_TO_ADDR
// end ; end_of_file
11010: LD_VAR 0 1
11014: RET
// export function DebugMode ; var i , j , b ; begin
11015: LD_INT 0
11017: PPUSH
11018: PPUSH
11019: PPUSH
11020: PPUSH
// enable_addtolog = true ;
11021: LD_ADDR_OWVAR 81
11025: PUSH
11026: LD_INT 1
11028: ST_TO_ADDR
// FogOff ( 6 ) ;
11029: LD_INT 6
11031: PPUSH
11032: CALL_OW 344
// uc_side = 6 ;
11036: LD_ADDR_OWVAR 20
11040: PUSH
11041: LD_INT 6
11043: ST_TO_ADDR
// uc_nation = 3 ;
11044: LD_ADDR_OWVAR 21
11048: PUSH
11049: LD_INT 3
11051: ST_TO_ADDR
// bc_level = 10 ;
11052: LD_ADDR_OWVAR 43
11056: PUSH
11057: LD_INT 10
11059: ST_TO_ADDR
// bc_type := b_lab_full ;
11060: LD_ADDR_OWVAR 42
11064: PUSH
11065: LD_INT 8
11067: ST_TO_ADDR
// bc_kind1 := 11 ;
11068: LD_ADDR_OWVAR 44
11072: PUSH
11073: LD_INT 11
11075: ST_TO_ADDR
// bc_kind2 := 12 ;
11076: LD_ADDR_OWVAR 45
11080: PUSH
11081: LD_INT 12
11083: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 189 , 20 , 1 ) ;
11084: LD_INT 189
11086: PPUSH
11087: LD_INT 20
11089: PPUSH
11090: LD_INT 1
11092: PPUSH
11093: CALL_OW 47
// bc_type := b_warehouse ;
11097: LD_ADDR_OWVAR 42
11101: PUSH
11102: LD_INT 1
11104: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 201 , 22 , 4 ) ;
11105: LD_ADDR_VAR 0 4
11109: PUSH
11110: LD_INT 201
11112: PPUSH
11113: LD_INT 22
11115: PPUSH
11116: LD_INT 4
11118: PPUSH
11119: CALL_OW 47
11123: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , 10000 ) ;
11124: LD_VAR 0 4
11128: PPUSH
11129: CALL_OW 274
11133: PPUSH
11134: LD_INT 1
11136: PPUSH
11137: LD_INT 10000
11139: PPUSH
11140: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , 10000 ) ;
11144: LD_VAR 0 4
11148: PPUSH
11149: CALL_OW 274
11153: PPUSH
11154: LD_INT 2
11156: PPUSH
11157: LD_INT 10000
11159: PPUSH
11160: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , 10000 ) ;
11164: LD_VAR 0 4
11168: PPUSH
11169: CALL_OW 274
11173: PPUSH
11174: LD_INT 3
11176: PPUSH
11177: LD_INT 10000
11179: PPUSH
11180: CALL_OW 277
// bc_type := b_siberite_power ;
11184: LD_ADDR_OWVAR 42
11188: PUSH
11189: LD_INT 28
11191: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 216 , 16 , 4 ) ;
11192: LD_ADDR_VAR 0 4
11196: PUSH
11197: LD_INT 216
11199: PPUSH
11200: LD_INT 16
11202: PPUSH
11203: LD_INT 4
11205: PPUSH
11206: CALL_OW 47
11210: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 219 , 16 , 4 ) ;
11211: LD_ADDR_VAR 0 4
11215: PUSH
11216: LD_INT 219
11218: PPUSH
11219: LD_INT 16
11221: PPUSH
11222: LD_INT 4
11224: PPUSH
11225: CALL_OW 47
11229: ST_TO_ADDR
// SetTech ( tech_sib2 , 6 , state_researched ) ;
11230: LD_INT 55
11232: PPUSH
11233: LD_INT 6
11235: PPUSH
11236: LD_INT 2
11238: PPUSH
11239: CALL_OW 322
// SetTech ( tech_sib3 , 6 , state_researched ) ;
11243: LD_INT 56
11245: PPUSH
11246: LD_INT 6
11248: PPUSH
11249: LD_INT 2
11251: PPUSH
11252: CALL_OW 322
// end ; end_of_file
11256: LD_VAR 0 1
11260: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
11261: LD_INT 0
11263: PPUSH
11264: PPUSH
11265: PPUSH
11266: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11267: LD_VAR 0 1
11271: PPUSH
11272: CALL_OW 264
11276: PUSH
11277: LD_EXP 94
11281: EQUAL
11282: IFFALSE 11354
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11284: LD_INT 68
11286: PPUSH
11287: LD_VAR 0 1
11291: PPUSH
11292: CALL_OW 255
11296: PPUSH
11297: CALL_OW 321
11301: PUSH
11302: LD_INT 2
11304: EQUAL
11305: IFFALSE 11317
// eff := 70 else
11307: LD_ADDR_VAR 0 4
11311: PUSH
11312: LD_INT 70
11314: ST_TO_ADDR
11315: GO 11325
// eff := 30 ;
11317: LD_ADDR_VAR 0 4
11321: PUSH
11322: LD_INT 30
11324: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11325: LD_VAR 0 1
11329: PPUSH
11330: CALL_OW 250
11334: PPUSH
11335: LD_VAR 0 1
11339: PPUSH
11340: CALL_OW 251
11344: PPUSH
11345: LD_VAR 0 4
11349: PPUSH
11350: CALL_OW 495
// end ; end ;
11354: LD_VAR 0 2
11358: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
11359: LD_INT 0
11361: PPUSH
// end ;
11362: LD_VAR 0 4
11366: RET
// export function SOS_Command ( cmd ) ; begin
11367: LD_INT 0
11369: PPUSH
// end ;
11370: LD_VAR 0 2
11374: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
11375: LD_VAR 0 1
11379: PUSH
11380: LD_INT 255
11382: EQUAL
11383: PUSH
11384: LD_VAR 0 2
11388: PPUSH
11389: CALL_OW 264
11393: PUSH
11394: LD_INT 14
11396: PUSH
11397: LD_INT 53
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: IN
11404: AND
11405: PUSH
11406: LD_VAR 0 4
11410: PPUSH
11411: LD_VAR 0 5
11415: PPUSH
11416: CALL_OW 488
11420: AND
11421: IFFALSE 11445
// CutTreeXYR ( unit , x , y , 12 ) ;
11423: LD_VAR 0 2
11427: PPUSH
11428: LD_VAR 0 4
11432: PPUSH
11433: LD_VAR 0 5
11437: PPUSH
11438: LD_INT 12
11440: PPUSH
11441: CALL 11448 0 4
// end ;
11445: PPOPN 5
11447: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11448: LD_INT 0
11450: PPUSH
11451: PPUSH
11452: PPUSH
11453: PPUSH
11454: PPUSH
11455: PPUSH
11456: PPUSH
11457: PPUSH
11458: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11459: LD_VAR 0 1
11463: NOT
11464: PUSH
11465: LD_VAR 0 2
11469: PPUSH
11470: LD_VAR 0 3
11474: PPUSH
11475: CALL_OW 488
11479: NOT
11480: OR
11481: PUSH
11482: LD_VAR 0 4
11486: NOT
11487: OR
11488: IFFALSE 11492
// exit ;
11490: GO 11832
// list := [ ] ;
11492: LD_ADDR_VAR 0 13
11496: PUSH
11497: EMPTY
11498: ST_TO_ADDR
// if x - r < 0 then
11499: LD_VAR 0 2
11503: PUSH
11504: LD_VAR 0 4
11508: MINUS
11509: PUSH
11510: LD_INT 0
11512: LESS
11513: IFFALSE 11525
// min_x := 0 else
11515: LD_ADDR_VAR 0 7
11519: PUSH
11520: LD_INT 0
11522: ST_TO_ADDR
11523: GO 11541
// min_x := x - r ;
11525: LD_ADDR_VAR 0 7
11529: PUSH
11530: LD_VAR 0 2
11534: PUSH
11535: LD_VAR 0 4
11539: MINUS
11540: ST_TO_ADDR
// if y - r < 0 then
11541: LD_VAR 0 3
11545: PUSH
11546: LD_VAR 0 4
11550: MINUS
11551: PUSH
11552: LD_INT 0
11554: LESS
11555: IFFALSE 11567
// min_y := 0 else
11557: LD_ADDR_VAR 0 8
11561: PUSH
11562: LD_INT 0
11564: ST_TO_ADDR
11565: GO 11583
// min_y := y - r ;
11567: LD_ADDR_VAR 0 8
11571: PUSH
11572: LD_VAR 0 3
11576: PUSH
11577: LD_VAR 0 4
11581: MINUS
11582: ST_TO_ADDR
// max_x := x + r ;
11583: LD_ADDR_VAR 0 9
11587: PUSH
11588: LD_VAR 0 2
11592: PUSH
11593: LD_VAR 0 4
11597: PLUS
11598: ST_TO_ADDR
// max_y := y + r ;
11599: LD_ADDR_VAR 0 10
11603: PUSH
11604: LD_VAR 0 3
11608: PUSH
11609: LD_VAR 0 4
11613: PLUS
11614: ST_TO_ADDR
// for _x = min_x to max_x do
11615: LD_ADDR_VAR 0 11
11619: PUSH
11620: DOUBLE
11621: LD_VAR 0 7
11625: DEC
11626: ST_TO_ADDR
11627: LD_VAR 0 9
11631: PUSH
11632: FOR_TO
11633: IFFALSE 11750
// for _y = min_y to max_y do
11635: LD_ADDR_VAR 0 12
11639: PUSH
11640: DOUBLE
11641: LD_VAR 0 8
11645: DEC
11646: ST_TO_ADDR
11647: LD_VAR 0 10
11651: PUSH
11652: FOR_TO
11653: IFFALSE 11746
// begin if not ValidHex ( _x , _y ) then
11655: LD_VAR 0 11
11659: PPUSH
11660: LD_VAR 0 12
11664: PPUSH
11665: CALL_OW 488
11669: NOT
11670: IFFALSE 11674
// continue ;
11672: GO 11652
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
11674: LD_VAR 0 11
11678: PPUSH
11679: LD_VAR 0 12
11683: PPUSH
11684: CALL_OW 351
11688: PUSH
11689: LD_VAR 0 11
11693: PPUSH
11694: LD_VAR 0 12
11698: PPUSH
11699: CALL_OW 554
11703: AND
11704: IFFALSE 11744
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
11706: LD_ADDR_VAR 0 13
11710: PUSH
11711: LD_VAR 0 13
11715: PPUSH
11716: LD_VAR 0 13
11720: PUSH
11721: LD_INT 1
11723: PLUS
11724: PPUSH
11725: LD_VAR 0 11
11729: PUSH
11730: LD_VAR 0 12
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PPUSH
11739: CALL_OW 2
11743: ST_TO_ADDR
// end ;
11744: GO 11652
11746: POP
11747: POP
11748: GO 11632
11750: POP
11751: POP
// if not list then
11752: LD_VAR 0 13
11756: NOT
11757: IFFALSE 11761
// exit ;
11759: GO 11832
// for i in list do
11761: LD_ADDR_VAR 0 6
11765: PUSH
11766: LD_VAR 0 13
11770: PUSH
11771: FOR_IN
11772: IFFALSE 11830
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
11774: LD_VAR 0 1
11778: PPUSH
11779: LD_STRING M
11781: PUSH
11782: LD_VAR 0 6
11786: PUSH
11787: LD_INT 1
11789: ARRAY
11790: PUSH
11791: LD_VAR 0 6
11795: PUSH
11796: LD_INT 2
11798: ARRAY
11799: PUSH
11800: LD_INT 0
11802: PUSH
11803: LD_INT 0
11805: PUSH
11806: LD_INT 0
11808: PUSH
11809: LD_INT 0
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: PUSH
11821: EMPTY
11822: LIST
11823: PPUSH
11824: CALL_OW 447
11828: GO 11771
11830: POP
11831: POP
// end ; end_of_file
11832: LD_VAR 0 5
11836: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
11837: GO 11839
11839: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11840: LD_STRING initStreamRollete();
11842: PPUSH
11843: CALL_OW 559
// InitStreamMode ;
11847: CALL 11856 0 0
// DefineStreamItems ( ) ;
11851: CALL 12296 0 0
// end ;
11855: END
// function InitStreamMode ; begin
11856: LD_INT 0
11858: PPUSH
// streamModeActive := false ;
11859: LD_ADDR_EXP 36
11863: PUSH
11864: LD_INT 0
11866: ST_TO_ADDR
// normalCounter := 36 ;
11867: LD_ADDR_EXP 37
11871: PUSH
11872: LD_INT 36
11874: ST_TO_ADDR
// hardcoreCounter := 16 ;
11875: LD_ADDR_EXP 38
11879: PUSH
11880: LD_INT 16
11882: ST_TO_ADDR
// sRocket := false ;
11883: LD_ADDR_EXP 41
11887: PUSH
11888: LD_INT 0
11890: ST_TO_ADDR
// sSpeed := false ;
11891: LD_ADDR_EXP 40
11895: PUSH
11896: LD_INT 0
11898: ST_TO_ADDR
// sEngine := false ;
11899: LD_ADDR_EXP 42
11903: PUSH
11904: LD_INT 0
11906: ST_TO_ADDR
// sSpec := false ;
11907: LD_ADDR_EXP 39
11911: PUSH
11912: LD_INT 0
11914: ST_TO_ADDR
// sLevel := false ;
11915: LD_ADDR_EXP 43
11919: PUSH
11920: LD_INT 0
11922: ST_TO_ADDR
// sArmoury := false ;
11923: LD_ADDR_EXP 44
11927: PUSH
11928: LD_INT 0
11930: ST_TO_ADDR
// sRadar := false ;
11931: LD_ADDR_EXP 45
11935: PUSH
11936: LD_INT 0
11938: ST_TO_ADDR
// sBunker := false ;
11939: LD_ADDR_EXP 46
11943: PUSH
11944: LD_INT 0
11946: ST_TO_ADDR
// sHack := false ;
11947: LD_ADDR_EXP 47
11951: PUSH
11952: LD_INT 0
11954: ST_TO_ADDR
// sFire := false ;
11955: LD_ADDR_EXP 48
11959: PUSH
11960: LD_INT 0
11962: ST_TO_ADDR
// sRefresh := false ;
11963: LD_ADDR_EXP 49
11967: PUSH
11968: LD_INT 0
11970: ST_TO_ADDR
// sExp := false ;
11971: LD_ADDR_EXP 50
11975: PUSH
11976: LD_INT 0
11978: ST_TO_ADDR
// sDepot := false ;
11979: LD_ADDR_EXP 51
11983: PUSH
11984: LD_INT 0
11986: ST_TO_ADDR
// sFlag := false ;
11987: LD_ADDR_EXP 52
11991: PUSH
11992: LD_INT 0
11994: ST_TO_ADDR
// sKamikadze := false ;
11995: LD_ADDR_EXP 60
11999: PUSH
12000: LD_INT 0
12002: ST_TO_ADDR
// sTroll := false ;
12003: LD_ADDR_EXP 61
12007: PUSH
12008: LD_INT 0
12010: ST_TO_ADDR
// sSlow := false ;
12011: LD_ADDR_EXP 62
12015: PUSH
12016: LD_INT 0
12018: ST_TO_ADDR
// sLack := false ;
12019: LD_ADDR_EXP 63
12023: PUSH
12024: LD_INT 0
12026: ST_TO_ADDR
// sTank := false ;
12027: LD_ADDR_EXP 65
12031: PUSH
12032: LD_INT 0
12034: ST_TO_ADDR
// sRemote := false ;
12035: LD_ADDR_EXP 66
12039: PUSH
12040: LD_INT 0
12042: ST_TO_ADDR
// sPowell := false ;
12043: LD_ADDR_EXP 67
12047: PUSH
12048: LD_INT 0
12050: ST_TO_ADDR
// sTeleport := false ;
12051: LD_ADDR_EXP 70
12055: PUSH
12056: LD_INT 0
12058: ST_TO_ADDR
// sOilTower := false ;
12059: LD_ADDR_EXP 72
12063: PUSH
12064: LD_INT 0
12066: ST_TO_ADDR
// sShovel := false ;
12067: LD_ADDR_EXP 73
12071: PUSH
12072: LD_INT 0
12074: ST_TO_ADDR
// sSheik := false ;
12075: LD_ADDR_EXP 74
12079: PUSH
12080: LD_INT 0
12082: ST_TO_ADDR
// sEarthquake := false ;
12083: LD_ADDR_EXP 76
12087: PUSH
12088: LD_INT 0
12090: ST_TO_ADDR
// sAI := false ;
12091: LD_ADDR_EXP 77
12095: PUSH
12096: LD_INT 0
12098: ST_TO_ADDR
// sCargo := false ;
12099: LD_ADDR_EXP 80
12103: PUSH
12104: LD_INT 0
12106: ST_TO_ADDR
// sDLaser := false ;
12107: LD_ADDR_EXP 81
12111: PUSH
12112: LD_INT 0
12114: ST_TO_ADDR
// sExchange := false ;
12115: LD_ADDR_EXP 82
12119: PUSH
12120: LD_INT 0
12122: ST_TO_ADDR
// sFac := false ;
12123: LD_ADDR_EXP 83
12127: PUSH
12128: LD_INT 0
12130: ST_TO_ADDR
// sPower := false ;
12131: LD_ADDR_EXP 84
12135: PUSH
12136: LD_INT 0
12138: ST_TO_ADDR
// sRandom := false ;
12139: LD_ADDR_EXP 85
12143: PUSH
12144: LD_INT 0
12146: ST_TO_ADDR
// sShield := false ;
12147: LD_ADDR_EXP 86
12151: PUSH
12152: LD_INT 0
12154: ST_TO_ADDR
// sTime := false ;
12155: LD_ADDR_EXP 87
12159: PUSH
12160: LD_INT 0
12162: ST_TO_ADDR
// sTools := false ;
12163: LD_ADDR_EXP 88
12167: PUSH
12168: LD_INT 0
12170: ST_TO_ADDR
// sSold := false ;
12171: LD_ADDR_EXP 53
12175: PUSH
12176: LD_INT 0
12178: ST_TO_ADDR
// sDiff := false ;
12179: LD_ADDR_EXP 54
12183: PUSH
12184: LD_INT 0
12186: ST_TO_ADDR
// sFog := false ;
12187: LD_ADDR_EXP 57
12191: PUSH
12192: LD_INT 0
12194: ST_TO_ADDR
// sReset := false ;
12195: LD_ADDR_EXP 58
12199: PUSH
12200: LD_INT 0
12202: ST_TO_ADDR
// sSun := false ;
12203: LD_ADDR_EXP 59
12207: PUSH
12208: LD_INT 0
12210: ST_TO_ADDR
// sTiger := false ;
12211: LD_ADDR_EXP 55
12215: PUSH
12216: LD_INT 0
12218: ST_TO_ADDR
// sBomb := false ;
12219: LD_ADDR_EXP 56
12223: PUSH
12224: LD_INT 0
12226: ST_TO_ADDR
// sWound := false ;
12227: LD_ADDR_EXP 64
12231: PUSH
12232: LD_INT 0
12234: ST_TO_ADDR
// sBetray := false ;
12235: LD_ADDR_EXP 68
12239: PUSH
12240: LD_INT 0
12242: ST_TO_ADDR
// sContamin := false ;
12243: LD_ADDR_EXP 69
12247: PUSH
12248: LD_INT 0
12250: ST_TO_ADDR
// sOil := false ;
12251: LD_ADDR_EXP 71
12255: PUSH
12256: LD_INT 0
12258: ST_TO_ADDR
// sStu := false ;
12259: LD_ADDR_EXP 75
12263: PUSH
12264: LD_INT 0
12266: ST_TO_ADDR
// sBazooka := false ;
12267: LD_ADDR_EXP 78
12271: PUSH
12272: LD_INT 0
12274: ST_TO_ADDR
// sMortar := false ;
12275: LD_ADDR_EXP 79
12279: PUSH
12280: LD_INT 0
12282: ST_TO_ADDR
// sRanger := false ;
12283: LD_ADDR_EXP 89
12287: PUSH
12288: LD_INT 0
12290: ST_TO_ADDR
// end ;
12291: LD_VAR 0 1
12295: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
12296: LD_INT 0
12298: PPUSH
12299: PPUSH
12300: PPUSH
12301: PPUSH
12302: PPUSH
// result := [ ] ;
12303: LD_ADDR_VAR 0 1
12307: PUSH
12308: EMPTY
12309: ST_TO_ADDR
// if campaign_id = 1 then
12310: LD_OWVAR 69
12314: PUSH
12315: LD_INT 1
12317: EQUAL
12318: IFFALSE 15256
// begin case mission_number of 1 :
12320: LD_OWVAR 70
12324: PUSH
12325: LD_INT 1
12327: DOUBLE
12328: EQUAL
12329: IFTRUE 12333
12331: GO 12397
12333: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
12334: LD_ADDR_VAR 0 1
12338: PUSH
12339: LD_INT 2
12341: PUSH
12342: LD_INT 4
12344: PUSH
12345: LD_INT 11
12347: PUSH
12348: LD_INT 12
12350: PUSH
12351: LD_INT 15
12353: PUSH
12354: LD_INT 16
12356: PUSH
12357: LD_INT 22
12359: PUSH
12360: LD_INT 23
12362: PUSH
12363: LD_INT 26
12365: PUSH
12366: EMPTY
12367: LIST
12368: LIST
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PUSH
12377: LD_INT 101
12379: PUSH
12380: LD_INT 102
12382: PUSH
12383: LD_INT 106
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: LIST
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: ST_TO_ADDR
12395: GO 15254
12397: LD_INT 2
12399: DOUBLE
12400: EQUAL
12401: IFTRUE 12405
12403: GO 12477
12405: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
12406: LD_ADDR_VAR 0 1
12410: PUSH
12411: LD_INT 2
12413: PUSH
12414: LD_INT 4
12416: PUSH
12417: LD_INT 11
12419: PUSH
12420: LD_INT 12
12422: PUSH
12423: LD_INT 15
12425: PUSH
12426: LD_INT 16
12428: PUSH
12429: LD_INT 22
12431: PUSH
12432: LD_INT 23
12434: PUSH
12435: LD_INT 26
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: PUSH
12449: LD_INT 101
12451: PUSH
12452: LD_INT 102
12454: PUSH
12455: LD_INT 105
12457: PUSH
12458: LD_INT 106
12460: PUSH
12461: LD_INT 108
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: LIST
12468: LIST
12469: LIST
12470: PUSH
12471: EMPTY
12472: LIST
12473: LIST
12474: ST_TO_ADDR
12475: GO 15254
12477: LD_INT 3
12479: DOUBLE
12480: EQUAL
12481: IFTRUE 12485
12483: GO 12561
12485: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
12486: LD_ADDR_VAR 0 1
12490: PUSH
12491: LD_INT 2
12493: PUSH
12494: LD_INT 4
12496: PUSH
12497: LD_INT 5
12499: PUSH
12500: LD_INT 11
12502: PUSH
12503: LD_INT 12
12505: PUSH
12506: LD_INT 15
12508: PUSH
12509: LD_INT 16
12511: PUSH
12512: LD_INT 22
12514: PUSH
12515: LD_INT 26
12517: PUSH
12518: LD_INT 36
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: LIST
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: PUSH
12533: LD_INT 101
12535: PUSH
12536: LD_INT 102
12538: PUSH
12539: LD_INT 105
12541: PUSH
12542: LD_INT 106
12544: PUSH
12545: LD_INT 108
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: LIST
12552: LIST
12553: LIST
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: ST_TO_ADDR
12559: GO 15254
12561: LD_INT 4
12563: DOUBLE
12564: EQUAL
12565: IFTRUE 12569
12567: GO 12653
12569: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_INT 2
12577: PUSH
12578: LD_INT 4
12580: PUSH
12581: LD_INT 5
12583: PUSH
12584: LD_INT 8
12586: PUSH
12587: LD_INT 11
12589: PUSH
12590: LD_INT 12
12592: PUSH
12593: LD_INT 15
12595: PUSH
12596: LD_INT 16
12598: PUSH
12599: LD_INT 22
12601: PUSH
12602: LD_INT 23
12604: PUSH
12605: LD_INT 26
12607: PUSH
12608: LD_INT 36
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: LIST
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: PUSH
12625: LD_INT 101
12627: PUSH
12628: LD_INT 102
12630: PUSH
12631: LD_INT 105
12633: PUSH
12634: LD_INT 106
12636: PUSH
12637: LD_INT 108
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: ST_TO_ADDR
12651: GO 15254
12653: LD_INT 5
12655: DOUBLE
12656: EQUAL
12657: IFTRUE 12661
12659: GO 12761
12661: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
12662: LD_ADDR_VAR 0 1
12666: PUSH
12667: LD_INT 2
12669: PUSH
12670: LD_INT 4
12672: PUSH
12673: LD_INT 5
12675: PUSH
12676: LD_INT 6
12678: PUSH
12679: LD_INT 8
12681: PUSH
12682: LD_INT 11
12684: PUSH
12685: LD_INT 12
12687: PUSH
12688: LD_INT 15
12690: PUSH
12691: LD_INT 16
12693: PUSH
12694: LD_INT 22
12696: PUSH
12697: LD_INT 23
12699: PUSH
12700: LD_INT 25
12702: PUSH
12703: LD_INT 26
12705: PUSH
12706: LD_INT 36
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: LIST
12713: LIST
12714: LIST
12715: LIST
12716: LIST
12717: LIST
12718: LIST
12719: LIST
12720: LIST
12721: LIST
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 101
12727: PUSH
12728: LD_INT 102
12730: PUSH
12731: LD_INT 105
12733: PUSH
12734: LD_INT 106
12736: PUSH
12737: LD_INT 108
12739: PUSH
12740: LD_INT 109
12742: PUSH
12743: LD_INT 112
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: LIST
12750: LIST
12751: LIST
12752: LIST
12753: LIST
12754: PUSH
12755: EMPTY
12756: LIST
12757: LIST
12758: ST_TO_ADDR
12759: GO 15254
12761: LD_INT 6
12763: DOUBLE
12764: EQUAL
12765: IFTRUE 12769
12767: GO 12889
12769: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
12770: LD_ADDR_VAR 0 1
12774: PUSH
12775: LD_INT 2
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: LD_INT 5
12783: PUSH
12784: LD_INT 6
12786: PUSH
12787: LD_INT 8
12789: PUSH
12790: LD_INT 11
12792: PUSH
12793: LD_INT 12
12795: PUSH
12796: LD_INT 15
12798: PUSH
12799: LD_INT 16
12801: PUSH
12802: LD_INT 20
12804: PUSH
12805: LD_INT 21
12807: PUSH
12808: LD_INT 22
12810: PUSH
12811: LD_INT 23
12813: PUSH
12814: LD_INT 25
12816: PUSH
12817: LD_INT 26
12819: PUSH
12820: LD_INT 30
12822: PUSH
12823: LD_INT 31
12825: PUSH
12826: LD_INT 32
12828: PUSH
12829: LD_INT 36
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: LIST
12847: LIST
12848: LIST
12849: LIST
12850: LIST
12851: LIST
12852: PUSH
12853: LD_INT 101
12855: PUSH
12856: LD_INT 102
12858: PUSH
12859: LD_INT 105
12861: PUSH
12862: LD_INT 106
12864: PUSH
12865: LD_INT 108
12867: PUSH
12868: LD_INT 109
12870: PUSH
12871: LD_INT 112
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: ST_TO_ADDR
12887: GO 15254
12889: LD_INT 7
12891: DOUBLE
12892: EQUAL
12893: IFTRUE 12897
12895: GO 12997
12897: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12898: LD_ADDR_VAR 0 1
12902: PUSH
12903: LD_INT 2
12905: PUSH
12906: LD_INT 4
12908: PUSH
12909: LD_INT 5
12911: PUSH
12912: LD_INT 7
12914: PUSH
12915: LD_INT 11
12917: PUSH
12918: LD_INT 12
12920: PUSH
12921: LD_INT 15
12923: PUSH
12924: LD_INT 16
12926: PUSH
12927: LD_INT 20
12929: PUSH
12930: LD_INT 21
12932: PUSH
12933: LD_INT 22
12935: PUSH
12936: LD_INT 23
12938: PUSH
12939: LD_INT 25
12941: PUSH
12942: LD_INT 26
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 101
12963: PUSH
12964: LD_INT 102
12966: PUSH
12967: LD_INT 103
12969: PUSH
12970: LD_INT 105
12972: PUSH
12973: LD_INT 106
12975: PUSH
12976: LD_INT 108
12978: PUSH
12979: LD_INT 112
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: ST_TO_ADDR
12995: GO 15254
12997: LD_INT 8
12999: DOUBLE
13000: EQUAL
13001: IFTRUE 13005
13003: GO 13133
13005: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
13006: LD_ADDR_VAR 0 1
13010: PUSH
13011: LD_INT 2
13013: PUSH
13014: LD_INT 4
13016: PUSH
13017: LD_INT 5
13019: PUSH
13020: LD_INT 6
13022: PUSH
13023: LD_INT 7
13025: PUSH
13026: LD_INT 8
13028: PUSH
13029: LD_INT 11
13031: PUSH
13032: LD_INT 12
13034: PUSH
13035: LD_INT 15
13037: PUSH
13038: LD_INT 16
13040: PUSH
13041: LD_INT 20
13043: PUSH
13044: LD_INT 21
13046: PUSH
13047: LD_INT 22
13049: PUSH
13050: LD_INT 23
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 26
13058: PUSH
13059: LD_INT 30
13061: PUSH
13062: LD_INT 31
13064: PUSH
13065: LD_INT 32
13067: PUSH
13068: LD_INT 36
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 101
13095: PUSH
13096: LD_INT 102
13098: PUSH
13099: LD_INT 103
13101: PUSH
13102: LD_INT 105
13104: PUSH
13105: LD_INT 106
13107: PUSH
13108: LD_INT 108
13110: PUSH
13111: LD_INT 109
13113: PUSH
13114: LD_INT 112
13116: PUSH
13117: EMPTY
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: PUSH
13127: EMPTY
13128: LIST
13129: LIST
13130: ST_TO_ADDR
13131: GO 15254
13133: LD_INT 9
13135: DOUBLE
13136: EQUAL
13137: IFTRUE 13141
13139: GO 13277
13141: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
13142: LD_ADDR_VAR 0 1
13146: PUSH
13147: LD_INT 2
13149: PUSH
13150: LD_INT 4
13152: PUSH
13153: LD_INT 5
13155: PUSH
13156: LD_INT 6
13158: PUSH
13159: LD_INT 7
13161: PUSH
13162: LD_INT 8
13164: PUSH
13165: LD_INT 11
13167: PUSH
13168: LD_INT 12
13170: PUSH
13171: LD_INT 15
13173: PUSH
13174: LD_INT 16
13176: PUSH
13177: LD_INT 20
13179: PUSH
13180: LD_INT 21
13182: PUSH
13183: LD_INT 22
13185: PUSH
13186: LD_INT 23
13188: PUSH
13189: LD_INT 25
13191: PUSH
13192: LD_INT 26
13194: PUSH
13195: LD_INT 28
13197: PUSH
13198: LD_INT 30
13200: PUSH
13201: LD_INT 31
13203: PUSH
13204: LD_INT 32
13206: PUSH
13207: LD_INT 36
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: PUSH
13233: LD_INT 101
13235: PUSH
13236: LD_INT 102
13238: PUSH
13239: LD_INT 103
13241: PUSH
13242: LD_INT 105
13244: PUSH
13245: LD_INT 106
13247: PUSH
13248: LD_INT 108
13250: PUSH
13251: LD_INT 109
13253: PUSH
13254: LD_INT 112
13256: PUSH
13257: LD_INT 114
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: LIST
13267: LIST
13268: LIST
13269: LIST
13270: PUSH
13271: EMPTY
13272: LIST
13273: LIST
13274: ST_TO_ADDR
13275: GO 15254
13277: LD_INT 10
13279: DOUBLE
13280: EQUAL
13281: IFTRUE 13285
13283: GO 13469
13285: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
13286: LD_ADDR_VAR 0 1
13290: PUSH
13291: LD_INT 2
13293: PUSH
13294: LD_INT 4
13296: PUSH
13297: LD_INT 5
13299: PUSH
13300: LD_INT 6
13302: PUSH
13303: LD_INT 7
13305: PUSH
13306: LD_INT 8
13308: PUSH
13309: LD_INT 9
13311: PUSH
13312: LD_INT 10
13314: PUSH
13315: LD_INT 11
13317: PUSH
13318: LD_INT 12
13320: PUSH
13321: LD_INT 13
13323: PUSH
13324: LD_INT 14
13326: PUSH
13327: LD_INT 15
13329: PUSH
13330: LD_INT 16
13332: PUSH
13333: LD_INT 17
13335: PUSH
13336: LD_INT 18
13338: PUSH
13339: LD_INT 19
13341: PUSH
13342: LD_INT 20
13344: PUSH
13345: LD_INT 21
13347: PUSH
13348: LD_INT 22
13350: PUSH
13351: LD_INT 23
13353: PUSH
13354: LD_INT 24
13356: PUSH
13357: LD_INT 25
13359: PUSH
13360: LD_INT 26
13362: PUSH
13363: LD_INT 28
13365: PUSH
13366: LD_INT 30
13368: PUSH
13369: LD_INT 31
13371: PUSH
13372: LD_INT 32
13374: PUSH
13375: LD_INT 36
13377: PUSH
13378: EMPTY
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: LIST
13396: LIST
13397: LIST
13398: LIST
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: LIST
13405: LIST
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 101
13411: PUSH
13412: LD_INT 102
13414: PUSH
13415: LD_INT 103
13417: PUSH
13418: LD_INT 104
13420: PUSH
13421: LD_INT 105
13423: PUSH
13424: LD_INT 106
13426: PUSH
13427: LD_INT 107
13429: PUSH
13430: LD_INT 108
13432: PUSH
13433: LD_INT 109
13435: PUSH
13436: LD_INT 110
13438: PUSH
13439: LD_INT 111
13441: PUSH
13442: LD_INT 112
13444: PUSH
13445: LD_INT 114
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: LIST
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: PUSH
13463: EMPTY
13464: LIST
13465: LIST
13466: ST_TO_ADDR
13467: GO 15254
13469: LD_INT 11
13471: DOUBLE
13472: EQUAL
13473: IFTRUE 13477
13475: GO 13669
13477: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
13478: LD_ADDR_VAR 0 1
13482: PUSH
13483: LD_INT 2
13485: PUSH
13486: LD_INT 3
13488: PUSH
13489: LD_INT 4
13491: PUSH
13492: LD_INT 5
13494: PUSH
13495: LD_INT 6
13497: PUSH
13498: LD_INT 7
13500: PUSH
13501: LD_INT 8
13503: PUSH
13504: LD_INT 9
13506: PUSH
13507: LD_INT 10
13509: PUSH
13510: LD_INT 11
13512: PUSH
13513: LD_INT 12
13515: PUSH
13516: LD_INT 13
13518: PUSH
13519: LD_INT 14
13521: PUSH
13522: LD_INT 15
13524: PUSH
13525: LD_INT 16
13527: PUSH
13528: LD_INT 17
13530: PUSH
13531: LD_INT 18
13533: PUSH
13534: LD_INT 19
13536: PUSH
13537: LD_INT 20
13539: PUSH
13540: LD_INT 21
13542: PUSH
13543: LD_INT 22
13545: PUSH
13546: LD_INT 23
13548: PUSH
13549: LD_INT 24
13551: PUSH
13552: LD_INT 25
13554: PUSH
13555: LD_INT 26
13557: PUSH
13558: LD_INT 28
13560: PUSH
13561: LD_INT 30
13563: PUSH
13564: LD_INT 31
13566: PUSH
13567: LD_INT 32
13569: PUSH
13570: LD_INT 34
13572: PUSH
13573: LD_INT 36
13575: PUSH
13576: EMPTY
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: LIST
13602: LIST
13603: LIST
13604: LIST
13605: LIST
13606: LIST
13607: LIST
13608: PUSH
13609: LD_INT 101
13611: PUSH
13612: LD_INT 102
13614: PUSH
13615: LD_INT 103
13617: PUSH
13618: LD_INT 104
13620: PUSH
13621: LD_INT 105
13623: PUSH
13624: LD_INT 106
13626: PUSH
13627: LD_INT 107
13629: PUSH
13630: LD_INT 108
13632: PUSH
13633: LD_INT 109
13635: PUSH
13636: LD_INT 110
13638: PUSH
13639: LD_INT 111
13641: PUSH
13642: LD_INT 112
13644: PUSH
13645: LD_INT 114
13647: PUSH
13648: EMPTY
13649: LIST
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: LIST
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: ST_TO_ADDR
13667: GO 15254
13669: LD_INT 12
13671: DOUBLE
13672: EQUAL
13673: IFTRUE 13677
13675: GO 13885
13677: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
13678: LD_ADDR_VAR 0 1
13682: PUSH
13683: LD_INT 1
13685: PUSH
13686: LD_INT 2
13688: PUSH
13689: LD_INT 3
13691: PUSH
13692: LD_INT 4
13694: PUSH
13695: LD_INT 5
13697: PUSH
13698: LD_INT 6
13700: PUSH
13701: LD_INT 7
13703: PUSH
13704: LD_INT 8
13706: PUSH
13707: LD_INT 9
13709: PUSH
13710: LD_INT 10
13712: PUSH
13713: LD_INT 11
13715: PUSH
13716: LD_INT 12
13718: PUSH
13719: LD_INT 13
13721: PUSH
13722: LD_INT 14
13724: PUSH
13725: LD_INT 15
13727: PUSH
13728: LD_INT 16
13730: PUSH
13731: LD_INT 17
13733: PUSH
13734: LD_INT 18
13736: PUSH
13737: LD_INT 19
13739: PUSH
13740: LD_INT 20
13742: PUSH
13743: LD_INT 21
13745: PUSH
13746: LD_INT 22
13748: PUSH
13749: LD_INT 23
13751: PUSH
13752: LD_INT 24
13754: PUSH
13755: LD_INT 25
13757: PUSH
13758: LD_INT 26
13760: PUSH
13761: LD_INT 27
13763: PUSH
13764: LD_INT 28
13766: PUSH
13767: LD_INT 30
13769: PUSH
13770: LD_INT 31
13772: PUSH
13773: LD_INT 32
13775: PUSH
13776: LD_INT 33
13778: PUSH
13779: LD_INT 34
13781: PUSH
13782: LD_INT 36
13784: PUSH
13785: EMPTY
13786: LIST
13787: LIST
13788: LIST
13789: LIST
13790: LIST
13791: LIST
13792: LIST
13793: LIST
13794: LIST
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: LIST
13811: LIST
13812: LIST
13813: LIST
13814: LIST
13815: LIST
13816: LIST
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_INT 101
13823: PUSH
13824: LD_INT 102
13826: PUSH
13827: LD_INT 103
13829: PUSH
13830: LD_INT 104
13832: PUSH
13833: LD_INT 105
13835: PUSH
13836: LD_INT 106
13838: PUSH
13839: LD_INT 107
13841: PUSH
13842: LD_INT 108
13844: PUSH
13845: LD_INT 109
13847: PUSH
13848: LD_INT 110
13850: PUSH
13851: LD_INT 111
13853: PUSH
13854: LD_INT 112
13856: PUSH
13857: LD_INT 113
13859: PUSH
13860: LD_INT 114
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: PUSH
13879: EMPTY
13880: LIST
13881: LIST
13882: ST_TO_ADDR
13883: GO 15254
13885: LD_INT 13
13887: DOUBLE
13888: EQUAL
13889: IFTRUE 13893
13891: GO 14089
13893: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13894: LD_ADDR_VAR 0 1
13898: PUSH
13899: LD_INT 1
13901: PUSH
13902: LD_INT 2
13904: PUSH
13905: LD_INT 3
13907: PUSH
13908: LD_INT 4
13910: PUSH
13911: LD_INT 5
13913: PUSH
13914: LD_INT 8
13916: PUSH
13917: LD_INT 9
13919: PUSH
13920: LD_INT 10
13922: PUSH
13923: LD_INT 11
13925: PUSH
13926: LD_INT 12
13928: PUSH
13929: LD_INT 14
13931: PUSH
13932: LD_INT 15
13934: PUSH
13935: LD_INT 16
13937: PUSH
13938: LD_INT 17
13940: PUSH
13941: LD_INT 18
13943: PUSH
13944: LD_INT 19
13946: PUSH
13947: LD_INT 20
13949: PUSH
13950: LD_INT 21
13952: PUSH
13953: LD_INT 22
13955: PUSH
13956: LD_INT 23
13958: PUSH
13959: LD_INT 24
13961: PUSH
13962: LD_INT 25
13964: PUSH
13965: LD_INT 26
13967: PUSH
13968: LD_INT 27
13970: PUSH
13971: LD_INT 28
13973: PUSH
13974: LD_INT 30
13976: PUSH
13977: LD_INT 31
13979: PUSH
13980: LD_INT 32
13982: PUSH
13983: LD_INT 33
13985: PUSH
13986: LD_INT 34
13988: PUSH
13989: LD_INT 36
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: LIST
14006: LIST
14007: LIST
14008: LIST
14009: LIST
14010: LIST
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: LIST
14022: LIST
14023: LIST
14024: PUSH
14025: LD_INT 101
14027: PUSH
14028: LD_INT 102
14030: PUSH
14031: LD_INT 103
14033: PUSH
14034: LD_INT 104
14036: PUSH
14037: LD_INT 105
14039: PUSH
14040: LD_INT 106
14042: PUSH
14043: LD_INT 107
14045: PUSH
14046: LD_INT 108
14048: PUSH
14049: LD_INT 109
14051: PUSH
14052: LD_INT 110
14054: PUSH
14055: LD_INT 111
14057: PUSH
14058: LD_INT 112
14060: PUSH
14061: LD_INT 113
14063: PUSH
14064: LD_INT 114
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: LIST
14071: LIST
14072: LIST
14073: LIST
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: PUSH
14083: EMPTY
14084: LIST
14085: LIST
14086: ST_TO_ADDR
14087: GO 15254
14089: LD_INT 14
14091: DOUBLE
14092: EQUAL
14093: IFTRUE 14097
14095: GO 14309
14097: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
14098: LD_ADDR_VAR 0 1
14102: PUSH
14103: LD_INT 1
14105: PUSH
14106: LD_INT 2
14108: PUSH
14109: LD_INT 3
14111: PUSH
14112: LD_INT 4
14114: PUSH
14115: LD_INT 5
14117: PUSH
14118: LD_INT 6
14120: PUSH
14121: LD_INT 7
14123: PUSH
14124: LD_INT 8
14126: PUSH
14127: LD_INT 9
14129: PUSH
14130: LD_INT 10
14132: PUSH
14133: LD_INT 11
14135: PUSH
14136: LD_INT 12
14138: PUSH
14139: LD_INT 13
14141: PUSH
14142: LD_INT 14
14144: PUSH
14145: LD_INT 15
14147: PUSH
14148: LD_INT 16
14150: PUSH
14151: LD_INT 17
14153: PUSH
14154: LD_INT 18
14156: PUSH
14157: LD_INT 19
14159: PUSH
14160: LD_INT 20
14162: PUSH
14163: LD_INT 21
14165: PUSH
14166: LD_INT 22
14168: PUSH
14169: LD_INT 23
14171: PUSH
14172: LD_INT 24
14174: PUSH
14175: LD_INT 25
14177: PUSH
14178: LD_INT 26
14180: PUSH
14181: LD_INT 27
14183: PUSH
14184: LD_INT 28
14186: PUSH
14187: LD_INT 29
14189: PUSH
14190: LD_INT 30
14192: PUSH
14193: LD_INT 31
14195: PUSH
14196: LD_INT 32
14198: PUSH
14199: LD_INT 33
14201: PUSH
14202: LD_INT 34
14204: PUSH
14205: LD_INT 36
14207: PUSH
14208: EMPTY
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: LIST
14219: LIST
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: LIST
14240: LIST
14241: LIST
14242: LIST
14243: LIST
14244: PUSH
14245: LD_INT 101
14247: PUSH
14248: LD_INT 102
14250: PUSH
14251: LD_INT 103
14253: PUSH
14254: LD_INT 104
14256: PUSH
14257: LD_INT 105
14259: PUSH
14260: LD_INT 106
14262: PUSH
14263: LD_INT 107
14265: PUSH
14266: LD_INT 108
14268: PUSH
14269: LD_INT 109
14271: PUSH
14272: LD_INT 110
14274: PUSH
14275: LD_INT 111
14277: PUSH
14278: LD_INT 112
14280: PUSH
14281: LD_INT 113
14283: PUSH
14284: LD_INT 114
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: PUSH
14303: EMPTY
14304: LIST
14305: LIST
14306: ST_TO_ADDR
14307: GO 15254
14309: LD_INT 15
14311: DOUBLE
14312: EQUAL
14313: IFTRUE 14317
14315: GO 14529
14317: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
14318: LD_ADDR_VAR 0 1
14322: PUSH
14323: LD_INT 1
14325: PUSH
14326: LD_INT 2
14328: PUSH
14329: LD_INT 3
14331: PUSH
14332: LD_INT 4
14334: PUSH
14335: LD_INT 5
14337: PUSH
14338: LD_INT 6
14340: PUSH
14341: LD_INT 7
14343: PUSH
14344: LD_INT 8
14346: PUSH
14347: LD_INT 9
14349: PUSH
14350: LD_INT 10
14352: PUSH
14353: LD_INT 11
14355: PUSH
14356: LD_INT 12
14358: PUSH
14359: LD_INT 13
14361: PUSH
14362: LD_INT 14
14364: PUSH
14365: LD_INT 15
14367: PUSH
14368: LD_INT 16
14370: PUSH
14371: LD_INT 17
14373: PUSH
14374: LD_INT 18
14376: PUSH
14377: LD_INT 19
14379: PUSH
14380: LD_INT 20
14382: PUSH
14383: LD_INT 21
14385: PUSH
14386: LD_INT 22
14388: PUSH
14389: LD_INT 23
14391: PUSH
14392: LD_INT 24
14394: PUSH
14395: LD_INT 25
14397: PUSH
14398: LD_INT 26
14400: PUSH
14401: LD_INT 27
14403: PUSH
14404: LD_INT 28
14406: PUSH
14407: LD_INT 29
14409: PUSH
14410: LD_INT 30
14412: PUSH
14413: LD_INT 31
14415: PUSH
14416: LD_INT 32
14418: PUSH
14419: LD_INT 33
14421: PUSH
14422: LD_INT 34
14424: PUSH
14425: LD_INT 36
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: LIST
14432: LIST
14433: LIST
14434: LIST
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: LIST
14440: LIST
14441: LIST
14442: LIST
14443: LIST
14444: LIST
14445: LIST
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: LIST
14462: LIST
14463: LIST
14464: PUSH
14465: LD_INT 101
14467: PUSH
14468: LD_INT 102
14470: PUSH
14471: LD_INT 103
14473: PUSH
14474: LD_INT 104
14476: PUSH
14477: LD_INT 105
14479: PUSH
14480: LD_INT 106
14482: PUSH
14483: LD_INT 107
14485: PUSH
14486: LD_INT 108
14488: PUSH
14489: LD_INT 109
14491: PUSH
14492: LD_INT 110
14494: PUSH
14495: LD_INT 111
14497: PUSH
14498: LD_INT 112
14500: PUSH
14501: LD_INT 113
14503: PUSH
14504: LD_INT 114
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: ST_TO_ADDR
14527: GO 15254
14529: LD_INT 16
14531: DOUBLE
14532: EQUAL
14533: IFTRUE 14537
14535: GO 14661
14537: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14538: LD_ADDR_VAR 0 1
14542: PUSH
14543: LD_INT 2
14545: PUSH
14546: LD_INT 4
14548: PUSH
14549: LD_INT 5
14551: PUSH
14552: LD_INT 7
14554: PUSH
14555: LD_INT 11
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: LD_INT 15
14563: PUSH
14564: LD_INT 16
14566: PUSH
14567: LD_INT 20
14569: PUSH
14570: LD_INT 21
14572: PUSH
14573: LD_INT 22
14575: PUSH
14576: LD_INT 23
14578: PUSH
14579: LD_INT 25
14581: PUSH
14582: LD_INT 26
14584: PUSH
14585: LD_INT 30
14587: PUSH
14588: LD_INT 31
14590: PUSH
14591: LD_INT 32
14593: PUSH
14594: LD_INT 33
14596: PUSH
14597: LD_INT 34
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 101
14623: PUSH
14624: LD_INT 102
14626: PUSH
14627: LD_INT 103
14629: PUSH
14630: LD_INT 106
14632: PUSH
14633: LD_INT 108
14635: PUSH
14636: LD_INT 112
14638: PUSH
14639: LD_INT 113
14641: PUSH
14642: LD_INT 114
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: ST_TO_ADDR
14659: GO 15254
14661: LD_INT 17
14663: DOUBLE
14664: EQUAL
14665: IFTRUE 14669
14667: GO 14881
14669: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
14670: LD_ADDR_VAR 0 1
14674: PUSH
14675: LD_INT 1
14677: PUSH
14678: LD_INT 2
14680: PUSH
14681: LD_INT 3
14683: PUSH
14684: LD_INT 4
14686: PUSH
14687: LD_INT 5
14689: PUSH
14690: LD_INT 6
14692: PUSH
14693: LD_INT 7
14695: PUSH
14696: LD_INT 8
14698: PUSH
14699: LD_INT 9
14701: PUSH
14702: LD_INT 10
14704: PUSH
14705: LD_INT 11
14707: PUSH
14708: LD_INT 12
14710: PUSH
14711: LD_INT 13
14713: PUSH
14714: LD_INT 14
14716: PUSH
14717: LD_INT 15
14719: PUSH
14720: LD_INT 16
14722: PUSH
14723: LD_INT 17
14725: PUSH
14726: LD_INT 18
14728: PUSH
14729: LD_INT 19
14731: PUSH
14732: LD_INT 20
14734: PUSH
14735: LD_INT 21
14737: PUSH
14738: LD_INT 22
14740: PUSH
14741: LD_INT 23
14743: PUSH
14744: LD_INT 24
14746: PUSH
14747: LD_INT 25
14749: PUSH
14750: LD_INT 26
14752: PUSH
14753: LD_INT 27
14755: PUSH
14756: LD_INT 28
14758: PUSH
14759: LD_INT 29
14761: PUSH
14762: LD_INT 30
14764: PUSH
14765: LD_INT 31
14767: PUSH
14768: LD_INT 32
14770: PUSH
14771: LD_INT 33
14773: PUSH
14774: LD_INT 34
14776: PUSH
14777: LD_INT 36
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: PUSH
14817: LD_INT 101
14819: PUSH
14820: LD_INT 102
14822: PUSH
14823: LD_INT 103
14825: PUSH
14826: LD_INT 104
14828: PUSH
14829: LD_INT 105
14831: PUSH
14832: LD_INT 106
14834: PUSH
14835: LD_INT 107
14837: PUSH
14838: LD_INT 108
14840: PUSH
14841: LD_INT 109
14843: PUSH
14844: LD_INT 110
14846: PUSH
14847: LD_INT 111
14849: PUSH
14850: LD_INT 112
14852: PUSH
14853: LD_INT 113
14855: PUSH
14856: LD_INT 114
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: LIST
14863: LIST
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: LIST
14869: LIST
14870: LIST
14871: LIST
14872: LIST
14873: LIST
14874: PUSH
14875: EMPTY
14876: LIST
14877: LIST
14878: ST_TO_ADDR
14879: GO 15254
14881: LD_INT 18
14883: DOUBLE
14884: EQUAL
14885: IFTRUE 14889
14887: GO 15025
14889: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14890: LD_ADDR_VAR 0 1
14894: PUSH
14895: LD_INT 2
14897: PUSH
14898: LD_INT 4
14900: PUSH
14901: LD_INT 5
14903: PUSH
14904: LD_INT 7
14906: PUSH
14907: LD_INT 11
14909: PUSH
14910: LD_INT 12
14912: PUSH
14913: LD_INT 15
14915: PUSH
14916: LD_INT 16
14918: PUSH
14919: LD_INT 20
14921: PUSH
14922: LD_INT 21
14924: PUSH
14925: LD_INT 22
14927: PUSH
14928: LD_INT 23
14930: PUSH
14931: LD_INT 25
14933: PUSH
14934: LD_INT 26
14936: PUSH
14937: LD_INT 30
14939: PUSH
14940: LD_INT 31
14942: PUSH
14943: LD_INT 32
14945: PUSH
14946: LD_INT 33
14948: PUSH
14949: LD_INT 34
14951: PUSH
14952: LD_INT 35
14954: PUSH
14955: LD_INT 36
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: LIST
14965: LIST
14966: LIST
14967: LIST
14968: LIST
14969: LIST
14970: LIST
14971: LIST
14972: LIST
14973: LIST
14974: LIST
14975: LIST
14976: LIST
14977: LIST
14978: LIST
14979: LIST
14980: PUSH
14981: LD_INT 101
14983: PUSH
14984: LD_INT 102
14986: PUSH
14987: LD_INT 103
14989: PUSH
14990: LD_INT 106
14992: PUSH
14993: LD_INT 108
14995: PUSH
14996: LD_INT 112
14998: PUSH
14999: LD_INT 113
15001: PUSH
15002: LD_INT 114
15004: PUSH
15005: LD_INT 115
15007: PUSH
15008: EMPTY
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: ST_TO_ADDR
15023: GO 15254
15025: LD_INT 19
15027: DOUBLE
15028: EQUAL
15029: IFTRUE 15033
15031: GO 15253
15033: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
15034: LD_ADDR_VAR 0 1
15038: PUSH
15039: LD_INT 1
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: LD_INT 3
15047: PUSH
15048: LD_INT 4
15050: PUSH
15051: LD_INT 5
15053: PUSH
15054: LD_INT 6
15056: PUSH
15057: LD_INT 7
15059: PUSH
15060: LD_INT 8
15062: PUSH
15063: LD_INT 9
15065: PUSH
15066: LD_INT 10
15068: PUSH
15069: LD_INT 11
15071: PUSH
15072: LD_INT 12
15074: PUSH
15075: LD_INT 13
15077: PUSH
15078: LD_INT 14
15080: PUSH
15081: LD_INT 15
15083: PUSH
15084: LD_INT 16
15086: PUSH
15087: LD_INT 17
15089: PUSH
15090: LD_INT 18
15092: PUSH
15093: LD_INT 19
15095: PUSH
15096: LD_INT 20
15098: PUSH
15099: LD_INT 21
15101: PUSH
15102: LD_INT 22
15104: PUSH
15105: LD_INT 23
15107: PUSH
15108: LD_INT 24
15110: PUSH
15111: LD_INT 25
15113: PUSH
15114: LD_INT 26
15116: PUSH
15117: LD_INT 27
15119: PUSH
15120: LD_INT 28
15122: PUSH
15123: LD_INT 29
15125: PUSH
15126: LD_INT 30
15128: PUSH
15129: LD_INT 31
15131: PUSH
15132: LD_INT 32
15134: PUSH
15135: LD_INT 33
15137: PUSH
15138: LD_INT 34
15140: PUSH
15141: LD_INT 35
15143: PUSH
15144: LD_INT 36
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: LIST
15170: LIST
15171: LIST
15172: LIST
15173: LIST
15174: LIST
15175: LIST
15176: LIST
15177: LIST
15178: LIST
15179: LIST
15180: LIST
15181: LIST
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 101
15187: PUSH
15188: LD_INT 102
15190: PUSH
15191: LD_INT 103
15193: PUSH
15194: LD_INT 104
15196: PUSH
15197: LD_INT 105
15199: PUSH
15200: LD_INT 106
15202: PUSH
15203: LD_INT 107
15205: PUSH
15206: LD_INT 108
15208: PUSH
15209: LD_INT 109
15211: PUSH
15212: LD_INT 110
15214: PUSH
15215: LD_INT 111
15217: PUSH
15218: LD_INT 112
15220: PUSH
15221: LD_INT 113
15223: PUSH
15224: LD_INT 114
15226: PUSH
15227: LD_INT 115
15229: PUSH
15230: EMPTY
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: ST_TO_ADDR
15251: GO 15254
15253: POP
// end else
15254: GO 15473
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
15256: LD_ADDR_VAR 0 1
15260: PUSH
15261: LD_INT 1
15263: PUSH
15264: LD_INT 2
15266: PUSH
15267: LD_INT 3
15269: PUSH
15270: LD_INT 4
15272: PUSH
15273: LD_INT 5
15275: PUSH
15276: LD_INT 6
15278: PUSH
15279: LD_INT 7
15281: PUSH
15282: LD_INT 8
15284: PUSH
15285: LD_INT 9
15287: PUSH
15288: LD_INT 10
15290: PUSH
15291: LD_INT 11
15293: PUSH
15294: LD_INT 12
15296: PUSH
15297: LD_INT 13
15299: PUSH
15300: LD_INT 14
15302: PUSH
15303: LD_INT 15
15305: PUSH
15306: LD_INT 16
15308: PUSH
15309: LD_INT 17
15311: PUSH
15312: LD_INT 18
15314: PUSH
15315: LD_INT 19
15317: PUSH
15318: LD_INT 20
15320: PUSH
15321: LD_INT 21
15323: PUSH
15324: LD_INT 22
15326: PUSH
15327: LD_INT 23
15329: PUSH
15330: LD_INT 24
15332: PUSH
15333: LD_INT 25
15335: PUSH
15336: LD_INT 26
15338: PUSH
15339: LD_INT 27
15341: PUSH
15342: LD_INT 28
15344: PUSH
15345: LD_INT 29
15347: PUSH
15348: LD_INT 30
15350: PUSH
15351: LD_INT 31
15353: PUSH
15354: LD_INT 32
15356: PUSH
15357: LD_INT 33
15359: PUSH
15360: LD_INT 34
15362: PUSH
15363: LD_INT 35
15365: PUSH
15366: LD_INT 36
15368: PUSH
15369: EMPTY
15370: LIST
15371: LIST
15372: LIST
15373: LIST
15374: LIST
15375: LIST
15376: LIST
15377: LIST
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: LIST
15383: LIST
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: LIST
15392: LIST
15393: LIST
15394: LIST
15395: LIST
15396: LIST
15397: LIST
15398: LIST
15399: LIST
15400: LIST
15401: LIST
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PUSH
15407: LD_INT 101
15409: PUSH
15410: LD_INT 102
15412: PUSH
15413: LD_INT 103
15415: PUSH
15416: LD_INT 104
15418: PUSH
15419: LD_INT 105
15421: PUSH
15422: LD_INT 106
15424: PUSH
15425: LD_INT 107
15427: PUSH
15428: LD_INT 108
15430: PUSH
15431: LD_INT 109
15433: PUSH
15434: LD_INT 110
15436: PUSH
15437: LD_INT 111
15439: PUSH
15440: LD_INT 112
15442: PUSH
15443: LD_INT 113
15445: PUSH
15446: LD_INT 114
15448: PUSH
15449: LD_INT 115
15451: PUSH
15452: EMPTY
15453: LIST
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: PUSH
15469: EMPTY
15470: LIST
15471: LIST
15472: ST_TO_ADDR
// if result then
15473: LD_VAR 0 1
15477: IFFALSE 15766
// begin normal :=  ;
15479: LD_ADDR_VAR 0 3
15483: PUSH
15484: LD_STRING 
15486: ST_TO_ADDR
// hardcore :=  ;
15487: LD_ADDR_VAR 0 4
15491: PUSH
15492: LD_STRING 
15494: ST_TO_ADDR
// for i = 1 to normalCounter do
15495: LD_ADDR_VAR 0 5
15499: PUSH
15500: DOUBLE
15501: LD_INT 1
15503: DEC
15504: ST_TO_ADDR
15505: LD_EXP 37
15509: PUSH
15510: FOR_TO
15511: IFFALSE 15612
// begin tmp := 0 ;
15513: LD_ADDR_VAR 0 2
15517: PUSH
15518: LD_STRING 0
15520: ST_TO_ADDR
// if result [ 1 ] then
15521: LD_VAR 0 1
15525: PUSH
15526: LD_INT 1
15528: ARRAY
15529: IFFALSE 15594
// if result [ 1 ] [ 1 ] = i then
15531: LD_VAR 0 1
15535: PUSH
15536: LD_INT 1
15538: ARRAY
15539: PUSH
15540: LD_INT 1
15542: ARRAY
15543: PUSH
15544: LD_VAR 0 5
15548: EQUAL
15549: IFFALSE 15594
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15551: LD_ADDR_VAR 0 1
15555: PUSH
15556: LD_VAR 0 1
15560: PPUSH
15561: LD_INT 1
15563: PPUSH
15564: LD_VAR 0 1
15568: PUSH
15569: LD_INT 1
15571: ARRAY
15572: PPUSH
15573: LD_INT 1
15575: PPUSH
15576: CALL_OW 3
15580: PPUSH
15581: CALL_OW 1
15585: ST_TO_ADDR
// tmp := 1 ;
15586: LD_ADDR_VAR 0 2
15590: PUSH
15591: LD_STRING 1
15593: ST_TO_ADDR
// end ; normal := normal & tmp ;
15594: LD_ADDR_VAR 0 3
15598: PUSH
15599: LD_VAR 0 3
15603: PUSH
15604: LD_VAR 0 2
15608: STR
15609: ST_TO_ADDR
// end ;
15610: GO 15510
15612: POP
15613: POP
// for i = 1 to hardcoreCounter do
15614: LD_ADDR_VAR 0 5
15618: PUSH
15619: DOUBLE
15620: LD_INT 1
15622: DEC
15623: ST_TO_ADDR
15624: LD_EXP 38
15628: PUSH
15629: FOR_TO
15630: IFFALSE 15735
// begin tmp := 0 ;
15632: LD_ADDR_VAR 0 2
15636: PUSH
15637: LD_STRING 0
15639: ST_TO_ADDR
// if result [ 2 ] then
15640: LD_VAR 0 1
15644: PUSH
15645: LD_INT 2
15647: ARRAY
15648: IFFALSE 15717
// if result [ 2 ] [ 1 ] = 100 + i then
15650: LD_VAR 0 1
15654: PUSH
15655: LD_INT 2
15657: ARRAY
15658: PUSH
15659: LD_INT 1
15661: ARRAY
15662: PUSH
15663: LD_INT 100
15665: PUSH
15666: LD_VAR 0 5
15670: PLUS
15671: EQUAL
15672: IFFALSE 15717
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
15674: LD_ADDR_VAR 0 1
15678: PUSH
15679: LD_VAR 0 1
15683: PPUSH
15684: LD_INT 2
15686: PPUSH
15687: LD_VAR 0 1
15691: PUSH
15692: LD_INT 2
15694: ARRAY
15695: PPUSH
15696: LD_INT 1
15698: PPUSH
15699: CALL_OW 3
15703: PPUSH
15704: CALL_OW 1
15708: ST_TO_ADDR
// tmp := 1 ;
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: LD_STRING 1
15716: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
15717: LD_ADDR_VAR 0 4
15721: PUSH
15722: LD_VAR 0 4
15726: PUSH
15727: LD_VAR 0 2
15731: STR
15732: ST_TO_ADDR
// end ;
15733: GO 15629
15735: POP
15736: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
15737: LD_STRING getStreamItemsFromMission("
15739: PUSH
15740: LD_VAR 0 3
15744: STR
15745: PUSH
15746: LD_STRING ","
15748: STR
15749: PUSH
15750: LD_VAR 0 4
15754: STR
15755: PUSH
15756: LD_STRING ")
15758: STR
15759: PPUSH
15760: CALL_OW 559
// end else
15764: GO 15773
// ToLua ( getStreamItemsFromMission("","") ) ;
15766: LD_STRING getStreamItemsFromMission("","")
15768: PPUSH
15769: CALL_OW 559
// end ;
15773: LD_VAR 0 1
15777: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15778: LD_VAR 0 2
15782: PUSH
15783: LD_INT 100
15785: EQUAL
15786: IFFALSE 16735
// begin if not StreamModeActive then
15788: LD_EXP 36
15792: NOT
15793: IFFALSE 15803
// StreamModeActive := true ;
15795: LD_ADDR_EXP 36
15799: PUSH
15800: LD_INT 1
15802: ST_TO_ADDR
// if p3 = 0 then
15803: LD_VAR 0 3
15807: PUSH
15808: LD_INT 0
15810: EQUAL
15811: IFFALSE 15817
// InitStreamMode ;
15813: CALL 11856 0 0
// if p3 = 1 then
15817: LD_VAR 0 3
15821: PUSH
15822: LD_INT 1
15824: EQUAL
15825: IFFALSE 15835
// sRocket := true ;
15827: LD_ADDR_EXP 41
15831: PUSH
15832: LD_INT 1
15834: ST_TO_ADDR
// if p3 = 2 then
15835: LD_VAR 0 3
15839: PUSH
15840: LD_INT 2
15842: EQUAL
15843: IFFALSE 15853
// sSpeed := true ;
15845: LD_ADDR_EXP 40
15849: PUSH
15850: LD_INT 1
15852: ST_TO_ADDR
// if p3 = 3 then
15853: LD_VAR 0 3
15857: PUSH
15858: LD_INT 3
15860: EQUAL
15861: IFFALSE 15871
// sEngine := true ;
15863: LD_ADDR_EXP 42
15867: PUSH
15868: LD_INT 1
15870: ST_TO_ADDR
// if p3 = 4 then
15871: LD_VAR 0 3
15875: PUSH
15876: LD_INT 4
15878: EQUAL
15879: IFFALSE 15889
// sSpec := true ;
15881: LD_ADDR_EXP 39
15885: PUSH
15886: LD_INT 1
15888: ST_TO_ADDR
// if p3 = 5 then
15889: LD_VAR 0 3
15893: PUSH
15894: LD_INT 5
15896: EQUAL
15897: IFFALSE 15907
// sLevel := true ;
15899: LD_ADDR_EXP 43
15903: PUSH
15904: LD_INT 1
15906: ST_TO_ADDR
// if p3 = 6 then
15907: LD_VAR 0 3
15911: PUSH
15912: LD_INT 6
15914: EQUAL
15915: IFFALSE 15925
// sArmoury := true ;
15917: LD_ADDR_EXP 44
15921: PUSH
15922: LD_INT 1
15924: ST_TO_ADDR
// if p3 = 7 then
15925: LD_VAR 0 3
15929: PUSH
15930: LD_INT 7
15932: EQUAL
15933: IFFALSE 15943
// sRadar := true ;
15935: LD_ADDR_EXP 45
15939: PUSH
15940: LD_INT 1
15942: ST_TO_ADDR
// if p3 = 8 then
15943: LD_VAR 0 3
15947: PUSH
15948: LD_INT 8
15950: EQUAL
15951: IFFALSE 15961
// sBunker := true ;
15953: LD_ADDR_EXP 46
15957: PUSH
15958: LD_INT 1
15960: ST_TO_ADDR
// if p3 = 9 then
15961: LD_VAR 0 3
15965: PUSH
15966: LD_INT 9
15968: EQUAL
15969: IFFALSE 15979
// sHack := true ;
15971: LD_ADDR_EXP 47
15975: PUSH
15976: LD_INT 1
15978: ST_TO_ADDR
// if p3 = 10 then
15979: LD_VAR 0 3
15983: PUSH
15984: LD_INT 10
15986: EQUAL
15987: IFFALSE 15997
// sFire := true ;
15989: LD_ADDR_EXP 48
15993: PUSH
15994: LD_INT 1
15996: ST_TO_ADDR
// if p3 = 11 then
15997: LD_VAR 0 3
16001: PUSH
16002: LD_INT 11
16004: EQUAL
16005: IFFALSE 16015
// sRefresh := true ;
16007: LD_ADDR_EXP 49
16011: PUSH
16012: LD_INT 1
16014: ST_TO_ADDR
// if p3 = 12 then
16015: LD_VAR 0 3
16019: PUSH
16020: LD_INT 12
16022: EQUAL
16023: IFFALSE 16033
// sExp := true ;
16025: LD_ADDR_EXP 50
16029: PUSH
16030: LD_INT 1
16032: ST_TO_ADDR
// if p3 = 13 then
16033: LD_VAR 0 3
16037: PUSH
16038: LD_INT 13
16040: EQUAL
16041: IFFALSE 16051
// sDepot := true ;
16043: LD_ADDR_EXP 51
16047: PUSH
16048: LD_INT 1
16050: ST_TO_ADDR
// if p3 = 14 then
16051: LD_VAR 0 3
16055: PUSH
16056: LD_INT 14
16058: EQUAL
16059: IFFALSE 16069
// sFlag := true ;
16061: LD_ADDR_EXP 52
16065: PUSH
16066: LD_INT 1
16068: ST_TO_ADDR
// if p3 = 15 then
16069: LD_VAR 0 3
16073: PUSH
16074: LD_INT 15
16076: EQUAL
16077: IFFALSE 16087
// sKamikadze := true ;
16079: LD_ADDR_EXP 60
16083: PUSH
16084: LD_INT 1
16086: ST_TO_ADDR
// if p3 = 16 then
16087: LD_VAR 0 3
16091: PUSH
16092: LD_INT 16
16094: EQUAL
16095: IFFALSE 16105
// sTroll := true ;
16097: LD_ADDR_EXP 61
16101: PUSH
16102: LD_INT 1
16104: ST_TO_ADDR
// if p3 = 17 then
16105: LD_VAR 0 3
16109: PUSH
16110: LD_INT 17
16112: EQUAL
16113: IFFALSE 16123
// sSlow := true ;
16115: LD_ADDR_EXP 62
16119: PUSH
16120: LD_INT 1
16122: ST_TO_ADDR
// if p3 = 18 then
16123: LD_VAR 0 3
16127: PUSH
16128: LD_INT 18
16130: EQUAL
16131: IFFALSE 16141
// sLack := true ;
16133: LD_ADDR_EXP 63
16137: PUSH
16138: LD_INT 1
16140: ST_TO_ADDR
// if p3 = 19 then
16141: LD_VAR 0 3
16145: PUSH
16146: LD_INT 19
16148: EQUAL
16149: IFFALSE 16159
// sTank := true ;
16151: LD_ADDR_EXP 65
16155: PUSH
16156: LD_INT 1
16158: ST_TO_ADDR
// if p3 = 20 then
16159: LD_VAR 0 3
16163: PUSH
16164: LD_INT 20
16166: EQUAL
16167: IFFALSE 16177
// sRemote := true ;
16169: LD_ADDR_EXP 66
16173: PUSH
16174: LD_INT 1
16176: ST_TO_ADDR
// if p3 = 21 then
16177: LD_VAR 0 3
16181: PUSH
16182: LD_INT 21
16184: EQUAL
16185: IFFALSE 16195
// sPowell := true ;
16187: LD_ADDR_EXP 67
16191: PUSH
16192: LD_INT 1
16194: ST_TO_ADDR
// if p3 = 22 then
16195: LD_VAR 0 3
16199: PUSH
16200: LD_INT 22
16202: EQUAL
16203: IFFALSE 16213
// sTeleport := true ;
16205: LD_ADDR_EXP 70
16209: PUSH
16210: LD_INT 1
16212: ST_TO_ADDR
// if p3 = 23 then
16213: LD_VAR 0 3
16217: PUSH
16218: LD_INT 23
16220: EQUAL
16221: IFFALSE 16231
// sOilTower := true ;
16223: LD_ADDR_EXP 72
16227: PUSH
16228: LD_INT 1
16230: ST_TO_ADDR
// if p3 = 24 then
16231: LD_VAR 0 3
16235: PUSH
16236: LD_INT 24
16238: EQUAL
16239: IFFALSE 16249
// sShovel := true ;
16241: LD_ADDR_EXP 73
16245: PUSH
16246: LD_INT 1
16248: ST_TO_ADDR
// if p3 = 25 then
16249: LD_VAR 0 3
16253: PUSH
16254: LD_INT 25
16256: EQUAL
16257: IFFALSE 16267
// sSheik := true ;
16259: LD_ADDR_EXP 74
16263: PUSH
16264: LD_INT 1
16266: ST_TO_ADDR
// if p3 = 26 then
16267: LD_VAR 0 3
16271: PUSH
16272: LD_INT 26
16274: EQUAL
16275: IFFALSE 16285
// sEarthquake := true ;
16277: LD_ADDR_EXP 76
16281: PUSH
16282: LD_INT 1
16284: ST_TO_ADDR
// if p3 = 27 then
16285: LD_VAR 0 3
16289: PUSH
16290: LD_INT 27
16292: EQUAL
16293: IFFALSE 16303
// sAI := true ;
16295: LD_ADDR_EXP 77
16299: PUSH
16300: LD_INT 1
16302: ST_TO_ADDR
// if p3 = 28 then
16303: LD_VAR 0 3
16307: PUSH
16308: LD_INT 28
16310: EQUAL
16311: IFFALSE 16321
// sCargo := true ;
16313: LD_ADDR_EXP 80
16317: PUSH
16318: LD_INT 1
16320: ST_TO_ADDR
// if p3 = 29 then
16321: LD_VAR 0 3
16325: PUSH
16326: LD_INT 29
16328: EQUAL
16329: IFFALSE 16339
// sDLaser := true ;
16331: LD_ADDR_EXP 81
16335: PUSH
16336: LD_INT 1
16338: ST_TO_ADDR
// if p3 = 30 then
16339: LD_VAR 0 3
16343: PUSH
16344: LD_INT 30
16346: EQUAL
16347: IFFALSE 16357
// sExchange := true ;
16349: LD_ADDR_EXP 82
16353: PUSH
16354: LD_INT 1
16356: ST_TO_ADDR
// if p3 = 31 then
16357: LD_VAR 0 3
16361: PUSH
16362: LD_INT 31
16364: EQUAL
16365: IFFALSE 16375
// sFac := true ;
16367: LD_ADDR_EXP 83
16371: PUSH
16372: LD_INT 1
16374: ST_TO_ADDR
// if p3 = 32 then
16375: LD_VAR 0 3
16379: PUSH
16380: LD_INT 32
16382: EQUAL
16383: IFFALSE 16393
// sPower := true ;
16385: LD_ADDR_EXP 84
16389: PUSH
16390: LD_INT 1
16392: ST_TO_ADDR
// if p3 = 33 then
16393: LD_VAR 0 3
16397: PUSH
16398: LD_INT 33
16400: EQUAL
16401: IFFALSE 16411
// sRandom := true ;
16403: LD_ADDR_EXP 85
16407: PUSH
16408: LD_INT 1
16410: ST_TO_ADDR
// if p3 = 34 then
16411: LD_VAR 0 3
16415: PUSH
16416: LD_INT 34
16418: EQUAL
16419: IFFALSE 16429
// sShield := true ;
16421: LD_ADDR_EXP 86
16425: PUSH
16426: LD_INT 1
16428: ST_TO_ADDR
// if p3 = 35 then
16429: LD_VAR 0 3
16433: PUSH
16434: LD_INT 35
16436: EQUAL
16437: IFFALSE 16447
// sTime := true ;
16439: LD_ADDR_EXP 87
16443: PUSH
16444: LD_INT 1
16446: ST_TO_ADDR
// if p3 = 36 then
16447: LD_VAR 0 3
16451: PUSH
16452: LD_INT 36
16454: EQUAL
16455: IFFALSE 16465
// sTools := true ;
16457: LD_ADDR_EXP 88
16461: PUSH
16462: LD_INT 1
16464: ST_TO_ADDR
// if p3 = 101 then
16465: LD_VAR 0 3
16469: PUSH
16470: LD_INT 101
16472: EQUAL
16473: IFFALSE 16483
// sSold := true ;
16475: LD_ADDR_EXP 53
16479: PUSH
16480: LD_INT 1
16482: ST_TO_ADDR
// if p3 = 102 then
16483: LD_VAR 0 3
16487: PUSH
16488: LD_INT 102
16490: EQUAL
16491: IFFALSE 16501
// sDiff := true ;
16493: LD_ADDR_EXP 54
16497: PUSH
16498: LD_INT 1
16500: ST_TO_ADDR
// if p3 = 103 then
16501: LD_VAR 0 3
16505: PUSH
16506: LD_INT 103
16508: EQUAL
16509: IFFALSE 16519
// sFog := true ;
16511: LD_ADDR_EXP 57
16515: PUSH
16516: LD_INT 1
16518: ST_TO_ADDR
// if p3 = 104 then
16519: LD_VAR 0 3
16523: PUSH
16524: LD_INT 104
16526: EQUAL
16527: IFFALSE 16537
// sReset := true ;
16529: LD_ADDR_EXP 58
16533: PUSH
16534: LD_INT 1
16536: ST_TO_ADDR
// if p3 = 105 then
16537: LD_VAR 0 3
16541: PUSH
16542: LD_INT 105
16544: EQUAL
16545: IFFALSE 16555
// sSun := true ;
16547: LD_ADDR_EXP 59
16551: PUSH
16552: LD_INT 1
16554: ST_TO_ADDR
// if p3 = 106 then
16555: LD_VAR 0 3
16559: PUSH
16560: LD_INT 106
16562: EQUAL
16563: IFFALSE 16573
// sTiger := true ;
16565: LD_ADDR_EXP 55
16569: PUSH
16570: LD_INT 1
16572: ST_TO_ADDR
// if p3 = 107 then
16573: LD_VAR 0 3
16577: PUSH
16578: LD_INT 107
16580: EQUAL
16581: IFFALSE 16591
// sBomb := true ;
16583: LD_ADDR_EXP 56
16587: PUSH
16588: LD_INT 1
16590: ST_TO_ADDR
// if p3 = 108 then
16591: LD_VAR 0 3
16595: PUSH
16596: LD_INT 108
16598: EQUAL
16599: IFFALSE 16609
// sWound := true ;
16601: LD_ADDR_EXP 64
16605: PUSH
16606: LD_INT 1
16608: ST_TO_ADDR
// if p3 = 109 then
16609: LD_VAR 0 3
16613: PUSH
16614: LD_INT 109
16616: EQUAL
16617: IFFALSE 16627
// sBetray := true ;
16619: LD_ADDR_EXP 68
16623: PUSH
16624: LD_INT 1
16626: ST_TO_ADDR
// if p3 = 110 then
16627: LD_VAR 0 3
16631: PUSH
16632: LD_INT 110
16634: EQUAL
16635: IFFALSE 16645
// sContamin := true ;
16637: LD_ADDR_EXP 69
16641: PUSH
16642: LD_INT 1
16644: ST_TO_ADDR
// if p3 = 111 then
16645: LD_VAR 0 3
16649: PUSH
16650: LD_INT 111
16652: EQUAL
16653: IFFALSE 16663
// sOil := true ;
16655: LD_ADDR_EXP 71
16659: PUSH
16660: LD_INT 1
16662: ST_TO_ADDR
// if p3 = 112 then
16663: LD_VAR 0 3
16667: PUSH
16668: LD_INT 112
16670: EQUAL
16671: IFFALSE 16681
// sStu := true ;
16673: LD_ADDR_EXP 75
16677: PUSH
16678: LD_INT 1
16680: ST_TO_ADDR
// if p3 = 113 then
16681: LD_VAR 0 3
16685: PUSH
16686: LD_INT 113
16688: EQUAL
16689: IFFALSE 16699
// sBazooka := true ;
16691: LD_ADDR_EXP 78
16695: PUSH
16696: LD_INT 1
16698: ST_TO_ADDR
// if p3 = 114 then
16699: LD_VAR 0 3
16703: PUSH
16704: LD_INT 114
16706: EQUAL
16707: IFFALSE 16717
// sMortar := true ;
16709: LD_ADDR_EXP 79
16713: PUSH
16714: LD_INT 1
16716: ST_TO_ADDR
// if p3 = 115 then
16717: LD_VAR 0 3
16721: PUSH
16722: LD_INT 115
16724: EQUAL
16725: IFFALSE 16735
// sRanger := true ;
16727: LD_ADDR_EXP 89
16731: PUSH
16732: LD_INT 1
16734: ST_TO_ADDR
// end ; end ;
16735: PPOPN 6
16737: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
16738: LD_EXP 36
16742: PUSH
16743: LD_EXP 41
16747: AND
16748: IFFALSE 16872
16750: GO 16752
16752: DISABLE
16753: LD_INT 0
16755: PPUSH
16756: PPUSH
// begin enable ;
16757: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
16758: LD_ADDR_VAR 0 2
16762: PUSH
16763: LD_INT 22
16765: PUSH
16766: LD_OWVAR 2
16770: PUSH
16771: EMPTY
16772: LIST
16773: LIST
16774: PUSH
16775: LD_INT 2
16777: PUSH
16778: LD_INT 34
16780: PUSH
16781: LD_INT 7
16783: PUSH
16784: EMPTY
16785: LIST
16786: LIST
16787: PUSH
16788: LD_INT 34
16790: PUSH
16791: LD_INT 45
16793: PUSH
16794: EMPTY
16795: LIST
16796: LIST
16797: PUSH
16798: LD_INT 34
16800: PUSH
16801: LD_INT 28
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 34
16810: PUSH
16811: LD_INT 47
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PUSH
16818: EMPTY
16819: LIST
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: PPUSH
16829: CALL_OW 69
16833: ST_TO_ADDR
// if not tmp then
16834: LD_VAR 0 2
16838: NOT
16839: IFFALSE 16843
// exit ;
16841: GO 16872
// for i in tmp do
16843: LD_ADDR_VAR 0 1
16847: PUSH
16848: LD_VAR 0 2
16852: PUSH
16853: FOR_IN
16854: IFFALSE 16870
// begin SetLives ( i , 0 ) ;
16856: LD_VAR 0 1
16860: PPUSH
16861: LD_INT 0
16863: PPUSH
16864: CALL_OW 234
// end ;
16868: GO 16853
16870: POP
16871: POP
// end ;
16872: PPOPN 2
16874: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
16875: LD_EXP 36
16879: PUSH
16880: LD_EXP 42
16884: AND
16885: IFFALSE 16969
16887: GO 16889
16889: DISABLE
16890: LD_INT 0
16892: PPUSH
16893: PPUSH
// begin enable ;
16894: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
16895: LD_ADDR_VAR 0 2
16899: PUSH
16900: LD_INT 22
16902: PUSH
16903: LD_OWVAR 2
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: PUSH
16912: LD_INT 32
16914: PUSH
16915: LD_INT 3
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL_OW 69
16930: ST_TO_ADDR
// if not tmp then
16931: LD_VAR 0 2
16935: NOT
16936: IFFALSE 16940
// exit ;
16938: GO 16969
// for i in tmp do
16940: LD_ADDR_VAR 0 1
16944: PUSH
16945: LD_VAR 0 2
16949: PUSH
16950: FOR_IN
16951: IFFALSE 16967
// begin SetLives ( i , 0 ) ;
16953: LD_VAR 0 1
16957: PPUSH
16958: LD_INT 0
16960: PPUSH
16961: CALL_OW 234
// end ;
16965: GO 16950
16967: POP
16968: POP
// end ;
16969: PPOPN 2
16971: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
16972: LD_EXP 36
16976: PUSH
16977: LD_EXP 39
16981: AND
16982: IFFALSE 17075
16984: GO 16986
16986: DISABLE
16987: LD_INT 0
16989: PPUSH
// begin enable ;
16990: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
16991: LD_ADDR_VAR 0 1
16995: PUSH
16996: LD_INT 22
16998: PUSH
16999: LD_OWVAR 2
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PUSH
17008: LD_INT 2
17010: PUSH
17011: LD_INT 25
17013: PUSH
17014: LD_INT 5
17016: PUSH
17017: EMPTY
17018: LIST
17019: LIST
17020: PUSH
17021: LD_INT 25
17023: PUSH
17024: LD_INT 9
17026: PUSH
17027: EMPTY
17028: LIST
17029: LIST
17030: PUSH
17031: LD_INT 25
17033: PUSH
17034: LD_INT 8
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: LIST
17045: LIST
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PPUSH
17051: CALL_OW 69
17055: PUSH
17056: FOR_IN
17057: IFFALSE 17073
// begin SetClass ( i , 1 ) ;
17059: LD_VAR 0 1
17063: PPUSH
17064: LD_INT 1
17066: PPUSH
17067: CALL_OW 336
// end ;
17071: GO 17056
17073: POP
17074: POP
// end ;
17075: PPOPN 1
17077: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
17078: LD_EXP 36
17082: PUSH
17083: LD_EXP 40
17087: AND
17088: PUSH
17089: LD_OWVAR 65
17093: PUSH
17094: LD_INT 7
17096: LESS
17097: AND
17098: IFFALSE 17112
17100: GO 17102
17102: DISABLE
// begin enable ;
17103: ENABLE
// game_speed := 7 ;
17104: LD_ADDR_OWVAR 65
17108: PUSH
17109: LD_INT 7
17111: ST_TO_ADDR
// end ;
17112: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
17113: LD_EXP 36
17117: PUSH
17118: LD_EXP 43
17122: AND
17123: IFFALSE 17325
17125: GO 17127
17127: DISABLE
17128: LD_INT 0
17130: PPUSH
17131: PPUSH
17132: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
17133: LD_ADDR_VAR 0 3
17137: PUSH
17138: LD_INT 81
17140: PUSH
17141: LD_OWVAR 2
17145: PUSH
17146: EMPTY
17147: LIST
17148: LIST
17149: PUSH
17150: LD_INT 21
17152: PUSH
17153: LD_INT 1
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: PUSH
17160: EMPTY
17161: LIST
17162: LIST
17163: PPUSH
17164: CALL_OW 69
17168: ST_TO_ADDR
// if not tmp then
17169: LD_VAR 0 3
17173: NOT
17174: IFFALSE 17178
// exit ;
17176: GO 17325
// if tmp > 5 then
17178: LD_VAR 0 3
17182: PUSH
17183: LD_INT 5
17185: GREATER
17186: IFFALSE 17198
// k := 5 else
17188: LD_ADDR_VAR 0 2
17192: PUSH
17193: LD_INT 5
17195: ST_TO_ADDR
17196: GO 17208
// k := tmp ;
17198: LD_ADDR_VAR 0 2
17202: PUSH
17203: LD_VAR 0 3
17207: ST_TO_ADDR
// for i := 1 to k do
17208: LD_ADDR_VAR 0 1
17212: PUSH
17213: DOUBLE
17214: LD_INT 1
17216: DEC
17217: ST_TO_ADDR
17218: LD_VAR 0 2
17222: PUSH
17223: FOR_TO
17224: IFFALSE 17323
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
17226: LD_VAR 0 3
17230: PUSH
17231: LD_VAR 0 1
17235: ARRAY
17236: PPUSH
17237: LD_VAR 0 1
17241: PUSH
17242: LD_INT 4
17244: MOD
17245: PUSH
17246: LD_INT 1
17248: PLUS
17249: PPUSH
17250: CALL_OW 259
17254: PUSH
17255: LD_INT 10
17257: LESS
17258: IFFALSE 17321
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
17260: LD_VAR 0 3
17264: PUSH
17265: LD_VAR 0 1
17269: ARRAY
17270: PPUSH
17271: LD_VAR 0 1
17275: PUSH
17276: LD_INT 4
17278: MOD
17279: PUSH
17280: LD_INT 1
17282: PLUS
17283: PPUSH
17284: LD_VAR 0 3
17288: PUSH
17289: LD_VAR 0 1
17293: ARRAY
17294: PPUSH
17295: LD_VAR 0 1
17299: PUSH
17300: LD_INT 4
17302: MOD
17303: PUSH
17304: LD_INT 1
17306: PLUS
17307: PPUSH
17308: CALL_OW 259
17312: PUSH
17313: LD_INT 1
17315: PLUS
17316: PPUSH
17317: CALL_OW 237
17321: GO 17223
17323: POP
17324: POP
// end ;
17325: PPOPN 3
17327: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
17328: LD_EXP 36
17332: PUSH
17333: LD_EXP 44
17337: AND
17338: IFFALSE 17358
17340: GO 17342
17342: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
17343: LD_INT 4
17345: PPUSH
17346: LD_OWVAR 2
17350: PPUSH
17351: LD_INT 0
17353: PPUSH
17354: CALL_OW 324
17358: END
// every 0 0$1 trigger StreamModeActive and sShovel do
17359: LD_EXP 36
17363: PUSH
17364: LD_EXP 73
17368: AND
17369: IFFALSE 17389
17371: GO 17373
17373: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
17374: LD_INT 19
17376: PPUSH
17377: LD_OWVAR 2
17381: PPUSH
17382: LD_INT 0
17384: PPUSH
17385: CALL_OW 324
17389: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
17390: LD_EXP 36
17394: PUSH
17395: LD_EXP 45
17399: AND
17400: IFFALSE 17502
17402: GO 17404
17404: DISABLE
17405: LD_INT 0
17407: PPUSH
17408: PPUSH
// begin enable ;
17409: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
17410: LD_ADDR_VAR 0 2
17414: PUSH
17415: LD_INT 22
17417: PUSH
17418: LD_OWVAR 2
17422: PUSH
17423: EMPTY
17424: LIST
17425: LIST
17426: PUSH
17427: LD_INT 2
17429: PUSH
17430: LD_INT 34
17432: PUSH
17433: LD_INT 11
17435: PUSH
17436: EMPTY
17437: LIST
17438: LIST
17439: PUSH
17440: LD_INT 34
17442: PUSH
17443: LD_INT 30
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: PUSH
17450: EMPTY
17451: LIST
17452: LIST
17453: LIST
17454: PUSH
17455: EMPTY
17456: LIST
17457: LIST
17458: PPUSH
17459: CALL_OW 69
17463: ST_TO_ADDR
// if not tmp then
17464: LD_VAR 0 2
17468: NOT
17469: IFFALSE 17473
// exit ;
17471: GO 17502
// for i in tmp do
17473: LD_ADDR_VAR 0 1
17477: PUSH
17478: LD_VAR 0 2
17482: PUSH
17483: FOR_IN
17484: IFFALSE 17500
// begin SetLives ( i , 0 ) ;
17486: LD_VAR 0 1
17490: PPUSH
17491: LD_INT 0
17493: PPUSH
17494: CALL_OW 234
// end ;
17498: GO 17483
17500: POP
17501: POP
// end ;
17502: PPOPN 2
17504: END
// every 0 0$1 trigger StreamModeActive and sBunker do
17505: LD_EXP 36
17509: PUSH
17510: LD_EXP 46
17514: AND
17515: IFFALSE 17535
17517: GO 17519
17519: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
17520: LD_INT 32
17522: PPUSH
17523: LD_OWVAR 2
17527: PPUSH
17528: LD_INT 0
17530: PPUSH
17531: CALL_OW 324
17535: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
17536: LD_EXP 36
17540: PUSH
17541: LD_EXP 47
17545: AND
17546: IFFALSE 17727
17548: GO 17550
17550: DISABLE
17551: LD_INT 0
17553: PPUSH
17554: PPUSH
17555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17556: LD_ADDR_VAR 0 2
17560: PUSH
17561: LD_INT 22
17563: PUSH
17564: LD_OWVAR 2
17568: PUSH
17569: EMPTY
17570: LIST
17571: LIST
17572: PUSH
17573: LD_INT 33
17575: PUSH
17576: LD_INT 3
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: PPUSH
17587: CALL_OW 69
17591: ST_TO_ADDR
// if not tmp then
17592: LD_VAR 0 2
17596: NOT
17597: IFFALSE 17601
// exit ;
17599: GO 17727
// side := 0 ;
17601: LD_ADDR_VAR 0 3
17605: PUSH
17606: LD_INT 0
17608: ST_TO_ADDR
// for i := 1 to 8 do
17609: LD_ADDR_VAR 0 1
17613: PUSH
17614: DOUBLE
17615: LD_INT 1
17617: DEC
17618: ST_TO_ADDR
17619: LD_INT 8
17621: PUSH
17622: FOR_TO
17623: IFFALSE 17671
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
17625: LD_OWVAR 2
17629: PUSH
17630: LD_VAR 0 1
17634: NONEQUAL
17635: PUSH
17636: LD_OWVAR 2
17640: PPUSH
17641: LD_VAR 0 1
17645: PPUSH
17646: CALL_OW 81
17650: PUSH
17651: LD_INT 2
17653: EQUAL
17654: AND
17655: IFFALSE 17669
// begin side := i ;
17657: LD_ADDR_VAR 0 3
17661: PUSH
17662: LD_VAR 0 1
17666: ST_TO_ADDR
// break ;
17667: GO 17671
// end ;
17669: GO 17622
17671: POP
17672: POP
// if not side then
17673: LD_VAR 0 3
17677: NOT
17678: IFFALSE 17682
// exit ;
17680: GO 17727
// for i := 1 to tmp do
17682: LD_ADDR_VAR 0 1
17686: PUSH
17687: DOUBLE
17688: LD_INT 1
17690: DEC
17691: ST_TO_ADDR
17692: LD_VAR 0 2
17696: PUSH
17697: FOR_TO
17698: IFFALSE 17725
// if Prob ( 60 ) then
17700: LD_INT 60
17702: PPUSH
17703: CALL_OW 13
17707: IFFALSE 17723
// SetSide ( i , side ) ;
17709: LD_VAR 0 1
17713: PPUSH
17714: LD_VAR 0 3
17718: PPUSH
17719: CALL_OW 235
17723: GO 17697
17725: POP
17726: POP
// end ;
17727: PPOPN 3
17729: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
17730: LD_EXP 36
17734: PUSH
17735: LD_EXP 49
17739: AND
17740: IFFALSE 17859
17742: GO 17744
17744: DISABLE
17745: LD_INT 0
17747: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
17748: LD_ADDR_VAR 0 1
17752: PUSH
17753: LD_INT 22
17755: PUSH
17756: LD_OWVAR 2
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 21
17767: PUSH
17768: LD_INT 1
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: LD_INT 3
17777: PUSH
17778: LD_INT 23
17780: PUSH
17781: LD_INT 0
17783: PUSH
17784: EMPTY
17785: LIST
17786: LIST
17787: PUSH
17788: EMPTY
17789: LIST
17790: LIST
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: LIST
17796: PPUSH
17797: CALL_OW 69
17801: PUSH
17802: FOR_IN
17803: IFFALSE 17857
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17805: LD_VAR 0 1
17809: PPUSH
17810: CALL_OW 257
17814: PUSH
17815: LD_INT 1
17817: PUSH
17818: LD_INT 2
17820: PUSH
17821: LD_INT 3
17823: PUSH
17824: LD_INT 4
17826: PUSH
17827: EMPTY
17828: LIST
17829: LIST
17830: LIST
17831: LIST
17832: IN
17833: IFFALSE 17855
// SetClass ( un , rand ( 1 , 4 ) ) ;
17835: LD_VAR 0 1
17839: PPUSH
17840: LD_INT 1
17842: PPUSH
17843: LD_INT 4
17845: PPUSH
17846: CALL_OW 12
17850: PPUSH
17851: CALL_OW 336
17855: GO 17802
17857: POP
17858: POP
// end ;
17859: PPOPN 1
17861: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
17862: LD_EXP 36
17866: PUSH
17867: LD_EXP 48
17871: AND
17872: IFFALSE 17951
17874: GO 17876
17876: DISABLE
17877: LD_INT 0
17879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17880: LD_ADDR_VAR 0 1
17884: PUSH
17885: LD_INT 22
17887: PUSH
17888: LD_OWVAR 2
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: PUSH
17897: LD_INT 21
17899: PUSH
17900: LD_INT 3
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: PPUSH
17911: CALL_OW 69
17915: ST_TO_ADDR
// if not tmp then
17916: LD_VAR 0 1
17920: NOT
17921: IFFALSE 17925
// exit ;
17923: GO 17951
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
17925: LD_VAR 0 1
17929: PUSH
17930: LD_INT 1
17932: PPUSH
17933: LD_VAR 0 1
17937: PPUSH
17938: CALL_OW 12
17942: ARRAY
17943: PPUSH
17944: LD_INT 100
17946: PPUSH
17947: CALL_OW 234
// end ;
17951: PPOPN 1
17953: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
17954: LD_EXP 36
17958: PUSH
17959: LD_EXP 50
17963: AND
17964: IFFALSE 18062
17966: GO 17968
17968: DISABLE
17969: LD_INT 0
17971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17972: LD_ADDR_VAR 0 1
17976: PUSH
17977: LD_INT 22
17979: PUSH
17980: LD_OWVAR 2
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: PUSH
17989: LD_INT 21
17991: PUSH
17992: LD_INT 1
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: PPUSH
18003: CALL_OW 69
18007: ST_TO_ADDR
// if not tmp then
18008: LD_VAR 0 1
18012: NOT
18013: IFFALSE 18017
// exit ;
18015: GO 18062
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
18017: LD_VAR 0 1
18021: PUSH
18022: LD_INT 1
18024: PPUSH
18025: LD_VAR 0 1
18029: PPUSH
18030: CALL_OW 12
18034: ARRAY
18035: PPUSH
18036: LD_INT 1
18038: PPUSH
18039: LD_INT 4
18041: PPUSH
18042: CALL_OW 12
18046: PPUSH
18047: LD_INT 3000
18049: PPUSH
18050: LD_INT 9000
18052: PPUSH
18053: CALL_OW 12
18057: PPUSH
18058: CALL_OW 492
// end ;
18062: PPOPN 1
18064: END
// every 0 0$1 trigger StreamModeActive and sDepot do
18065: LD_EXP 36
18069: PUSH
18070: LD_EXP 51
18074: AND
18075: IFFALSE 18095
18077: GO 18079
18079: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
18080: LD_INT 1
18082: PPUSH
18083: LD_OWVAR 2
18087: PPUSH
18088: LD_INT 0
18090: PPUSH
18091: CALL_OW 324
18095: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
18096: LD_EXP 36
18100: PUSH
18101: LD_EXP 52
18105: AND
18106: IFFALSE 18189
18108: GO 18110
18110: DISABLE
18111: LD_INT 0
18113: PPUSH
18114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18115: LD_ADDR_VAR 0 2
18119: PUSH
18120: LD_INT 22
18122: PUSH
18123: LD_OWVAR 2
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: PUSH
18132: LD_INT 21
18134: PUSH
18135: LD_INT 3
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: PUSH
18142: EMPTY
18143: LIST
18144: LIST
18145: PPUSH
18146: CALL_OW 69
18150: ST_TO_ADDR
// if not tmp then
18151: LD_VAR 0 2
18155: NOT
18156: IFFALSE 18160
// exit ;
18158: GO 18189
// for i in tmp do
18160: LD_ADDR_VAR 0 1
18164: PUSH
18165: LD_VAR 0 2
18169: PUSH
18170: FOR_IN
18171: IFFALSE 18187
// SetBLevel ( i , 10 ) ;
18173: LD_VAR 0 1
18177: PPUSH
18178: LD_INT 10
18180: PPUSH
18181: CALL_OW 241
18185: GO 18170
18187: POP
18188: POP
// end ;
18189: PPOPN 2
18191: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
18192: LD_EXP 36
18196: PUSH
18197: LD_EXP 53
18201: AND
18202: IFFALSE 18313
18204: GO 18206
18206: DISABLE
18207: LD_INT 0
18209: PPUSH
18210: PPUSH
18211: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18212: LD_ADDR_VAR 0 3
18216: PUSH
18217: LD_INT 22
18219: PUSH
18220: LD_OWVAR 2
18224: PUSH
18225: EMPTY
18226: LIST
18227: LIST
18228: PUSH
18229: LD_INT 25
18231: PUSH
18232: LD_INT 1
18234: PUSH
18235: EMPTY
18236: LIST
18237: LIST
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: PPUSH
18243: CALL_OW 69
18247: ST_TO_ADDR
// if not tmp then
18248: LD_VAR 0 3
18252: NOT
18253: IFFALSE 18257
// exit ;
18255: GO 18313
// un := tmp [ rand ( 1 , tmp ) ] ;
18257: LD_ADDR_VAR 0 2
18261: PUSH
18262: LD_VAR 0 3
18266: PUSH
18267: LD_INT 1
18269: PPUSH
18270: LD_VAR 0 3
18274: PPUSH
18275: CALL_OW 12
18279: ARRAY
18280: ST_TO_ADDR
// if Crawls ( un ) then
18281: LD_VAR 0 2
18285: PPUSH
18286: CALL_OW 318
18290: IFFALSE 18301
// ComWalk ( un ) ;
18292: LD_VAR 0 2
18296: PPUSH
18297: CALL_OW 138
// SetClass ( un , class_sniper ) ;
18301: LD_VAR 0 2
18305: PPUSH
18306: LD_INT 5
18308: PPUSH
18309: CALL_OW 336
// end ;
18313: PPOPN 3
18315: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
18316: LD_EXP 36
18320: PUSH
18321: LD_EXP 54
18325: AND
18326: PUSH
18327: LD_OWVAR 67
18331: PUSH
18332: LD_INT 3
18334: LESS
18335: AND
18336: IFFALSE 18355
18338: GO 18340
18340: DISABLE
// Difficulty := Difficulty + 1 ;
18341: LD_ADDR_OWVAR 67
18345: PUSH
18346: LD_OWVAR 67
18350: PUSH
18351: LD_INT 1
18353: PLUS
18354: ST_TO_ADDR
18355: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
18356: LD_EXP 36
18360: PUSH
18361: LD_EXP 55
18365: AND
18366: IFFALSE 18469
18368: GO 18370
18370: DISABLE
18371: LD_INT 0
18373: PPUSH
// begin for i := 1 to 5 do
18374: LD_ADDR_VAR 0 1
18378: PUSH
18379: DOUBLE
18380: LD_INT 1
18382: DEC
18383: ST_TO_ADDR
18384: LD_INT 5
18386: PUSH
18387: FOR_TO
18388: IFFALSE 18467
// begin uc_nation := nation_nature ;
18390: LD_ADDR_OWVAR 21
18394: PUSH
18395: LD_INT 0
18397: ST_TO_ADDR
// uc_side := 0 ;
18398: LD_ADDR_OWVAR 20
18402: PUSH
18403: LD_INT 0
18405: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18406: LD_ADDR_OWVAR 29
18410: PUSH
18411: LD_INT 12
18413: PUSH
18414: LD_INT 12
18416: PUSH
18417: EMPTY
18418: LIST
18419: LIST
18420: ST_TO_ADDR
// hc_agressivity := 20 ;
18421: LD_ADDR_OWVAR 35
18425: PUSH
18426: LD_INT 20
18428: ST_TO_ADDR
// hc_class := class_tiger ;
18429: LD_ADDR_OWVAR 28
18433: PUSH
18434: LD_INT 14
18436: ST_TO_ADDR
// hc_gallery :=  ;
18437: LD_ADDR_OWVAR 33
18441: PUSH
18442: LD_STRING 
18444: ST_TO_ADDR
// hc_name :=  ;
18445: LD_ADDR_OWVAR 26
18449: PUSH
18450: LD_STRING 
18452: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
18453: CALL_OW 44
18457: PPUSH
18458: LD_INT 0
18460: PPUSH
18461: CALL_OW 51
// end ;
18465: GO 18387
18467: POP
18468: POP
// end ;
18469: PPOPN 1
18471: END
// every 0 0$1 trigger StreamModeActive and sBomb do
18472: LD_EXP 36
18476: PUSH
18477: LD_EXP 56
18481: AND
18482: IFFALSE 18491
18484: GO 18486
18486: DISABLE
// StreamSibBomb ;
18487: CALL 18492 0 0
18491: END
// export function StreamSibBomb ; var i , x , y ; begin
18492: LD_INT 0
18494: PPUSH
18495: PPUSH
18496: PPUSH
18497: PPUSH
// result := false ;
18498: LD_ADDR_VAR 0 1
18502: PUSH
18503: LD_INT 0
18505: ST_TO_ADDR
// for i := 1 to 16 do
18506: LD_ADDR_VAR 0 2
18510: PUSH
18511: DOUBLE
18512: LD_INT 1
18514: DEC
18515: ST_TO_ADDR
18516: LD_INT 16
18518: PUSH
18519: FOR_TO
18520: IFFALSE 18719
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18522: LD_ADDR_VAR 0 3
18526: PUSH
18527: LD_INT 10
18529: PUSH
18530: LD_INT 20
18532: PUSH
18533: LD_INT 30
18535: PUSH
18536: LD_INT 40
18538: PUSH
18539: LD_INT 50
18541: PUSH
18542: LD_INT 60
18544: PUSH
18545: LD_INT 70
18547: PUSH
18548: LD_INT 80
18550: PUSH
18551: LD_INT 90
18553: PUSH
18554: LD_INT 100
18556: PUSH
18557: LD_INT 110
18559: PUSH
18560: LD_INT 120
18562: PUSH
18563: LD_INT 130
18565: PUSH
18566: LD_INT 140
18568: PUSH
18569: LD_INT 150
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: LIST
18576: LIST
18577: LIST
18578: LIST
18579: LIST
18580: LIST
18581: LIST
18582: LIST
18583: LIST
18584: LIST
18585: LIST
18586: LIST
18587: LIST
18588: PUSH
18589: LD_INT 1
18591: PPUSH
18592: LD_INT 15
18594: PPUSH
18595: CALL_OW 12
18599: ARRAY
18600: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18601: LD_ADDR_VAR 0 4
18605: PUSH
18606: LD_INT 10
18608: PUSH
18609: LD_INT 20
18611: PUSH
18612: LD_INT 30
18614: PUSH
18615: LD_INT 40
18617: PUSH
18618: LD_INT 50
18620: PUSH
18621: LD_INT 60
18623: PUSH
18624: LD_INT 70
18626: PUSH
18627: LD_INT 80
18629: PUSH
18630: LD_INT 90
18632: PUSH
18633: LD_INT 100
18635: PUSH
18636: LD_INT 110
18638: PUSH
18639: LD_INT 120
18641: PUSH
18642: LD_INT 130
18644: PUSH
18645: LD_INT 140
18647: PUSH
18648: LD_INT 150
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: LIST
18655: LIST
18656: LIST
18657: LIST
18658: LIST
18659: LIST
18660: LIST
18661: LIST
18662: LIST
18663: LIST
18664: LIST
18665: LIST
18666: LIST
18667: PUSH
18668: LD_INT 1
18670: PPUSH
18671: LD_INT 15
18673: PPUSH
18674: CALL_OW 12
18678: ARRAY
18679: ST_TO_ADDR
// if ValidHex ( x , y ) then
18680: LD_VAR 0 3
18684: PPUSH
18685: LD_VAR 0 4
18689: PPUSH
18690: CALL_OW 488
18694: IFFALSE 18717
// begin result := [ x , y ] ;
18696: LD_ADDR_VAR 0 1
18700: PUSH
18701: LD_VAR 0 3
18705: PUSH
18706: LD_VAR 0 4
18710: PUSH
18711: EMPTY
18712: LIST
18713: LIST
18714: ST_TO_ADDR
// break ;
18715: GO 18719
// end ; end ;
18717: GO 18519
18719: POP
18720: POP
// if result then
18721: LD_VAR 0 1
18725: IFFALSE 18785
// begin ToLua ( playSibBomb() ) ;
18727: LD_STRING playSibBomb()
18729: PPUSH
18730: CALL_OW 559
// wait ( 0 0$14 ) ;
18734: LD_INT 490
18736: PPUSH
18737: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
18741: LD_VAR 0 1
18745: PUSH
18746: LD_INT 1
18748: ARRAY
18749: PPUSH
18750: LD_VAR 0 1
18754: PUSH
18755: LD_INT 2
18757: ARRAY
18758: PPUSH
18759: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
18763: LD_VAR 0 1
18767: PUSH
18768: LD_INT 1
18770: ARRAY
18771: PPUSH
18772: LD_VAR 0 1
18776: PUSH
18777: LD_INT 2
18779: ARRAY
18780: PPUSH
18781: CALL_OW 429
// end ; end ;
18785: LD_VAR 0 1
18789: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18790: LD_EXP 36
18794: PUSH
18795: LD_EXP 58
18799: AND
18800: IFFALSE 18812
18802: GO 18804
18804: DISABLE
// YouLost (  ) ;
18805: LD_STRING 
18807: PPUSH
18808: CALL_OW 104
18812: END
// every 0 0$1 trigger StreamModeActive and sFog do
18813: LD_EXP 36
18817: PUSH
18818: LD_EXP 57
18822: AND
18823: IFFALSE 18837
18825: GO 18827
18827: DISABLE
// FogOff ( your_side ) ;
18828: LD_OWVAR 2
18832: PPUSH
18833: CALL_OW 344
18837: END
// every 0 0$1 trigger StreamModeActive and sSun do
18838: LD_EXP 36
18842: PUSH
18843: LD_EXP 59
18847: AND
18848: IFFALSE 18876
18850: GO 18852
18852: DISABLE
// begin solar_recharge_percent := 0 ;
18853: LD_ADDR_OWVAR 79
18857: PUSH
18858: LD_INT 0
18860: ST_TO_ADDR
// wait ( 5 5$00 ) ;
18861: LD_INT 10500
18863: PPUSH
18864: CALL_OW 67
// solar_recharge_percent := 100 ;
18868: LD_ADDR_OWVAR 79
18872: PUSH
18873: LD_INT 100
18875: ST_TO_ADDR
// end ;
18876: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
18877: LD_EXP 36
18881: PUSH
18882: LD_EXP 60
18886: AND
18887: IFFALSE 19126
18889: GO 18891
18891: DISABLE
18892: LD_INT 0
18894: PPUSH
18895: PPUSH
18896: PPUSH
// begin tmp := [ ] ;
18897: LD_ADDR_VAR 0 3
18901: PUSH
18902: EMPTY
18903: ST_TO_ADDR
// for i := 1 to 6 do
18904: LD_ADDR_VAR 0 1
18908: PUSH
18909: DOUBLE
18910: LD_INT 1
18912: DEC
18913: ST_TO_ADDR
18914: LD_INT 6
18916: PUSH
18917: FOR_TO
18918: IFFALSE 19023
// begin uc_nation := nation_nature ;
18920: LD_ADDR_OWVAR 21
18924: PUSH
18925: LD_INT 0
18927: ST_TO_ADDR
// uc_side := 0 ;
18928: LD_ADDR_OWVAR 20
18932: PUSH
18933: LD_INT 0
18935: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18936: LD_ADDR_OWVAR 29
18940: PUSH
18941: LD_INT 12
18943: PUSH
18944: LD_INT 12
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: ST_TO_ADDR
// hc_agressivity := 20 ;
18951: LD_ADDR_OWVAR 35
18955: PUSH
18956: LD_INT 20
18958: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
18959: LD_ADDR_OWVAR 28
18963: PUSH
18964: LD_INT 17
18966: ST_TO_ADDR
// hc_gallery :=  ;
18967: LD_ADDR_OWVAR 33
18971: PUSH
18972: LD_STRING 
18974: ST_TO_ADDR
// hc_name :=  ;
18975: LD_ADDR_OWVAR 26
18979: PUSH
18980: LD_STRING 
18982: ST_TO_ADDR
// un := CreateHuman ;
18983: LD_ADDR_VAR 0 2
18987: PUSH
18988: CALL_OW 44
18992: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
18993: LD_VAR 0 2
18997: PPUSH
18998: LD_INT 1
19000: PPUSH
19001: CALL_OW 51
// tmp := tmp ^ un ;
19005: LD_ADDR_VAR 0 3
19009: PUSH
19010: LD_VAR 0 3
19014: PUSH
19015: LD_VAR 0 2
19019: ADD
19020: ST_TO_ADDR
// end ;
19021: GO 18917
19023: POP
19024: POP
// repeat wait ( 0 0$1 ) ;
19025: LD_INT 35
19027: PPUSH
19028: CALL_OW 67
// for un in tmp do
19032: LD_ADDR_VAR 0 2
19036: PUSH
19037: LD_VAR 0 3
19041: PUSH
19042: FOR_IN
19043: IFFALSE 19117
// begin if IsDead ( un ) then
19045: LD_VAR 0 2
19049: PPUSH
19050: CALL_OW 301
19054: IFFALSE 19074
// begin tmp := tmp diff un ;
19056: LD_ADDR_VAR 0 3
19060: PUSH
19061: LD_VAR 0 3
19065: PUSH
19066: LD_VAR 0 2
19070: DIFF
19071: ST_TO_ADDR
// continue ;
19072: GO 19042
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
19074: LD_VAR 0 2
19078: PPUSH
19079: LD_INT 3
19081: PUSH
19082: LD_INT 22
19084: PUSH
19085: LD_INT 0
19087: PUSH
19088: EMPTY
19089: LIST
19090: LIST
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: PPUSH
19096: CALL_OW 69
19100: PPUSH
19101: LD_VAR 0 2
19105: PPUSH
19106: CALL_OW 74
19110: PPUSH
19111: CALL_OW 115
// end ;
19115: GO 19042
19117: POP
19118: POP
// until not tmp ;
19119: LD_VAR 0 3
19123: NOT
19124: IFFALSE 19025
// end ;
19126: PPOPN 3
19128: END
// every 0 0$1 trigger StreamModeActive and sTroll do
19129: LD_EXP 36
19133: PUSH
19134: LD_EXP 61
19138: AND
19139: IFFALSE 19193
19141: GO 19143
19143: DISABLE
// begin ToLua ( displayTroll(); ) ;
19144: LD_STRING displayTroll();
19146: PPUSH
19147: CALL_OW 559
// wait ( 3 3$00 ) ;
19151: LD_INT 6300
19153: PPUSH
19154: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19158: LD_STRING hideTroll();
19160: PPUSH
19161: CALL_OW 559
// wait ( 1 1$00 ) ;
19165: LD_INT 2100
19167: PPUSH
19168: CALL_OW 67
// ToLua ( displayTroll(); ) ;
19172: LD_STRING displayTroll();
19174: PPUSH
19175: CALL_OW 559
// wait ( 1 1$00 ) ;
19179: LD_INT 2100
19181: PPUSH
19182: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19186: LD_STRING hideTroll();
19188: PPUSH
19189: CALL_OW 559
// end ;
19193: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
19194: LD_EXP 36
19198: PUSH
19199: LD_EXP 62
19203: AND
19204: IFFALSE 19267
19206: GO 19208
19208: DISABLE
19209: LD_INT 0
19211: PPUSH
// begin p := 0 ;
19212: LD_ADDR_VAR 0 1
19216: PUSH
19217: LD_INT 0
19219: ST_TO_ADDR
// repeat game_speed := 1 ;
19220: LD_ADDR_OWVAR 65
19224: PUSH
19225: LD_INT 1
19227: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19228: LD_INT 35
19230: PPUSH
19231: CALL_OW 67
// p := p + 1 ;
19235: LD_ADDR_VAR 0 1
19239: PUSH
19240: LD_VAR 0 1
19244: PUSH
19245: LD_INT 1
19247: PLUS
19248: ST_TO_ADDR
// until p >= 60 ;
19249: LD_VAR 0 1
19253: PUSH
19254: LD_INT 60
19256: GREATEREQUAL
19257: IFFALSE 19220
// game_speed := 4 ;
19259: LD_ADDR_OWVAR 65
19263: PUSH
19264: LD_INT 4
19266: ST_TO_ADDR
// end ;
19267: PPOPN 1
19269: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
19270: LD_EXP 36
19274: PUSH
19275: LD_EXP 63
19279: AND
19280: IFFALSE 19426
19282: GO 19284
19284: DISABLE
19285: LD_INT 0
19287: PPUSH
19288: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19289: LD_ADDR_VAR 0 1
19293: PUSH
19294: LD_INT 22
19296: PUSH
19297: LD_OWVAR 2
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PUSH
19306: LD_INT 2
19308: PUSH
19309: LD_INT 30
19311: PUSH
19312: LD_INT 0
19314: PUSH
19315: EMPTY
19316: LIST
19317: LIST
19318: PUSH
19319: LD_INT 30
19321: PUSH
19322: LD_INT 1
19324: PUSH
19325: EMPTY
19326: LIST
19327: LIST
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: LIST
19333: PUSH
19334: EMPTY
19335: LIST
19336: LIST
19337: PPUSH
19338: CALL_OW 69
19342: ST_TO_ADDR
// if not depot then
19343: LD_VAR 0 1
19347: NOT
19348: IFFALSE 19352
// exit ;
19350: GO 19426
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
19352: LD_ADDR_VAR 0 2
19356: PUSH
19357: LD_VAR 0 1
19361: PUSH
19362: LD_INT 1
19364: PPUSH
19365: LD_VAR 0 1
19369: PPUSH
19370: CALL_OW 12
19374: ARRAY
19375: PPUSH
19376: CALL_OW 274
19380: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
19381: LD_VAR 0 2
19385: PPUSH
19386: LD_INT 1
19388: PPUSH
19389: LD_INT 0
19391: PPUSH
19392: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
19396: LD_VAR 0 2
19400: PPUSH
19401: LD_INT 2
19403: PPUSH
19404: LD_INT 0
19406: PPUSH
19407: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
19411: LD_VAR 0 2
19415: PPUSH
19416: LD_INT 3
19418: PPUSH
19419: LD_INT 0
19421: PPUSH
19422: CALL_OW 277
// end ;
19426: PPOPN 2
19428: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
19429: LD_EXP 36
19433: PUSH
19434: LD_EXP 64
19438: AND
19439: IFFALSE 19536
19441: GO 19443
19443: DISABLE
19444: LD_INT 0
19446: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19447: LD_ADDR_VAR 0 1
19451: PUSH
19452: LD_INT 22
19454: PUSH
19455: LD_OWVAR 2
19459: PUSH
19460: EMPTY
19461: LIST
19462: LIST
19463: PUSH
19464: LD_INT 21
19466: PUSH
19467: LD_INT 1
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: PUSH
19474: LD_INT 3
19476: PUSH
19477: LD_INT 23
19479: PUSH
19480: LD_INT 0
19482: PUSH
19483: EMPTY
19484: LIST
19485: LIST
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PUSH
19491: EMPTY
19492: LIST
19493: LIST
19494: LIST
19495: PPUSH
19496: CALL_OW 69
19500: ST_TO_ADDR
// if not tmp then
19501: LD_VAR 0 1
19505: NOT
19506: IFFALSE 19510
// exit ;
19508: GO 19536
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
19510: LD_VAR 0 1
19514: PUSH
19515: LD_INT 1
19517: PPUSH
19518: LD_VAR 0 1
19522: PPUSH
19523: CALL_OW 12
19527: ARRAY
19528: PPUSH
19529: LD_INT 200
19531: PPUSH
19532: CALL_OW 234
// end ;
19536: PPOPN 1
19538: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19539: LD_EXP 36
19543: PUSH
19544: LD_EXP 65
19548: AND
19549: IFFALSE 19628
19551: GO 19553
19553: DISABLE
19554: LD_INT 0
19556: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19557: LD_ADDR_VAR 0 1
19561: PUSH
19562: LD_INT 22
19564: PUSH
19565: LD_OWVAR 2
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: PUSH
19574: LD_INT 21
19576: PUSH
19577: LD_INT 2
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: PUSH
19584: EMPTY
19585: LIST
19586: LIST
19587: PPUSH
19588: CALL_OW 69
19592: ST_TO_ADDR
// if not tmp then
19593: LD_VAR 0 1
19597: NOT
19598: IFFALSE 19602
// exit ;
19600: GO 19628
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
19602: LD_VAR 0 1
19606: PUSH
19607: LD_INT 1
19609: PPUSH
19610: LD_VAR 0 1
19614: PPUSH
19615: CALL_OW 12
19619: ARRAY
19620: PPUSH
19621: LD_INT 60
19623: PPUSH
19624: CALL_OW 234
// end ;
19628: PPOPN 1
19630: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
19631: LD_EXP 36
19635: PUSH
19636: LD_EXP 66
19640: AND
19641: IFFALSE 19740
19643: GO 19645
19645: DISABLE
19646: LD_INT 0
19648: PPUSH
19649: PPUSH
// begin enable ;
19650: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
19651: LD_ADDR_VAR 0 1
19655: PUSH
19656: LD_INT 22
19658: PUSH
19659: LD_OWVAR 2
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: PUSH
19668: LD_INT 61
19670: PUSH
19671: EMPTY
19672: LIST
19673: PUSH
19674: LD_INT 33
19676: PUSH
19677: LD_INT 2
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: PUSH
19684: EMPTY
19685: LIST
19686: LIST
19687: LIST
19688: PPUSH
19689: CALL_OW 69
19693: ST_TO_ADDR
// if not tmp then
19694: LD_VAR 0 1
19698: NOT
19699: IFFALSE 19703
// exit ;
19701: GO 19740
// for i in tmp do
19703: LD_ADDR_VAR 0 2
19707: PUSH
19708: LD_VAR 0 1
19712: PUSH
19713: FOR_IN
19714: IFFALSE 19738
// if IsControledBy ( i ) then
19716: LD_VAR 0 2
19720: PPUSH
19721: CALL_OW 312
19725: IFFALSE 19736
// ComUnlink ( i ) ;
19727: LD_VAR 0 2
19731: PPUSH
19732: CALL_OW 136
19736: GO 19713
19738: POP
19739: POP
// end ;
19740: PPOPN 2
19742: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
19743: LD_EXP 36
19747: PUSH
19748: LD_EXP 67
19752: AND
19753: IFFALSE 19893
19755: GO 19757
19757: DISABLE
19758: LD_INT 0
19760: PPUSH
19761: PPUSH
// begin ToLua ( displayPowell(); ) ;
19762: LD_STRING displayPowell();
19764: PPUSH
19765: CALL_OW 559
// uc_side := 0 ;
19769: LD_ADDR_OWVAR 20
19773: PUSH
19774: LD_INT 0
19776: ST_TO_ADDR
// uc_nation := 2 ;
19777: LD_ADDR_OWVAR 21
19781: PUSH
19782: LD_INT 2
19784: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19785: LD_ADDR_OWVAR 37
19789: PUSH
19790: LD_INT 14
19792: ST_TO_ADDR
// vc_engine := engine_siberite ;
19793: LD_ADDR_OWVAR 39
19797: PUSH
19798: LD_INT 3
19800: ST_TO_ADDR
// vc_control := control_apeman ;
19801: LD_ADDR_OWVAR 38
19805: PUSH
19806: LD_INT 5
19808: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19809: LD_ADDR_OWVAR 40
19813: PUSH
19814: LD_INT 29
19816: ST_TO_ADDR
// un := CreateVehicle ;
19817: LD_ADDR_VAR 0 2
19821: PUSH
19822: CALL_OW 45
19826: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19827: LD_VAR 0 2
19831: PPUSH
19832: LD_INT 1
19834: PPUSH
19835: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19839: LD_INT 35
19841: PPUSH
19842: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19846: LD_VAR 0 2
19850: PPUSH
19851: LD_INT 22
19853: PUSH
19854: LD_OWVAR 2
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: PPUSH
19863: CALL_OW 69
19867: PPUSH
19868: LD_VAR 0 2
19872: PPUSH
19873: CALL_OW 74
19877: PPUSH
19878: CALL_OW 115
// until IsDead ( un ) ;
19882: LD_VAR 0 2
19886: PPUSH
19887: CALL_OW 301
19891: IFFALSE 19839
// end ;
19893: PPOPN 2
19895: END
// every 0 0$1 trigger StreamModeActive and sStu do
19896: LD_EXP 36
19900: PUSH
19901: LD_EXP 75
19905: AND
19906: IFFALSE 19922
19908: GO 19910
19910: DISABLE
// begin ToLua ( displayStucuk(); ) ;
19911: LD_STRING displayStucuk();
19913: PPUSH
19914: CALL_OW 559
// ResetFog ;
19918: CALL_OW 335
// end ;
19922: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
19923: LD_EXP 36
19927: PUSH
19928: LD_EXP 68
19932: AND
19933: IFFALSE 20074
19935: GO 19937
19937: DISABLE
19938: LD_INT 0
19940: PPUSH
19941: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19942: LD_ADDR_VAR 0 2
19946: PUSH
19947: LD_INT 22
19949: PUSH
19950: LD_OWVAR 2
19954: PUSH
19955: EMPTY
19956: LIST
19957: LIST
19958: PUSH
19959: LD_INT 21
19961: PUSH
19962: LD_INT 1
19964: PUSH
19965: EMPTY
19966: LIST
19967: LIST
19968: PUSH
19969: EMPTY
19970: LIST
19971: LIST
19972: PPUSH
19973: CALL_OW 69
19977: ST_TO_ADDR
// if not tmp then
19978: LD_VAR 0 2
19982: NOT
19983: IFFALSE 19987
// exit ;
19985: GO 20074
// un := tmp [ rand ( 1 , tmp ) ] ;
19987: LD_ADDR_VAR 0 1
19991: PUSH
19992: LD_VAR 0 2
19996: PUSH
19997: LD_INT 1
19999: PPUSH
20000: LD_VAR 0 2
20004: PPUSH
20005: CALL_OW 12
20009: ARRAY
20010: ST_TO_ADDR
// SetSide ( un , 0 ) ;
20011: LD_VAR 0 1
20015: PPUSH
20016: LD_INT 0
20018: PPUSH
20019: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
20023: LD_VAR 0 1
20027: PPUSH
20028: LD_OWVAR 3
20032: PUSH
20033: LD_VAR 0 1
20037: DIFF
20038: PPUSH
20039: LD_VAR 0 1
20043: PPUSH
20044: CALL_OW 74
20048: PPUSH
20049: CALL_OW 115
// wait ( 0 0$20 ) ;
20053: LD_INT 700
20055: PPUSH
20056: CALL_OW 67
// SetSide ( un , your_side ) ;
20060: LD_VAR 0 1
20064: PPUSH
20065: LD_OWVAR 2
20069: PPUSH
20070: CALL_OW 235
// end ;
20074: PPOPN 2
20076: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
20077: LD_EXP 36
20081: PUSH
20082: LD_EXP 69
20086: AND
20087: IFFALSE 20193
20089: GO 20091
20091: DISABLE
20092: LD_INT 0
20094: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
20095: LD_ADDR_VAR 0 1
20099: PUSH
20100: LD_INT 22
20102: PUSH
20103: LD_OWVAR 2
20107: PUSH
20108: EMPTY
20109: LIST
20110: LIST
20111: PUSH
20112: LD_INT 2
20114: PUSH
20115: LD_INT 30
20117: PUSH
20118: LD_INT 0
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: PUSH
20125: LD_INT 30
20127: PUSH
20128: LD_INT 1
20130: PUSH
20131: EMPTY
20132: LIST
20133: LIST
20134: PUSH
20135: EMPTY
20136: LIST
20137: LIST
20138: LIST
20139: PUSH
20140: EMPTY
20141: LIST
20142: LIST
20143: PPUSH
20144: CALL_OW 69
20148: ST_TO_ADDR
// if not depot then
20149: LD_VAR 0 1
20153: NOT
20154: IFFALSE 20158
// exit ;
20156: GO 20193
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
20158: LD_VAR 0 1
20162: PUSH
20163: LD_INT 1
20165: ARRAY
20166: PPUSH
20167: CALL_OW 250
20171: PPUSH
20172: LD_VAR 0 1
20176: PUSH
20177: LD_INT 1
20179: ARRAY
20180: PPUSH
20181: CALL_OW 251
20185: PPUSH
20186: LD_INT 70
20188: PPUSH
20189: CALL_OW 495
// end ;
20193: PPOPN 1
20195: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
20196: LD_EXP 36
20200: PUSH
20201: LD_EXP 70
20205: AND
20206: IFFALSE 20417
20208: GO 20210
20210: DISABLE
20211: LD_INT 0
20213: PPUSH
20214: PPUSH
20215: PPUSH
20216: PPUSH
20217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20218: LD_ADDR_VAR 0 5
20222: PUSH
20223: LD_INT 22
20225: PUSH
20226: LD_OWVAR 2
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: LD_INT 21
20237: PUSH
20238: LD_INT 1
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: PPUSH
20249: CALL_OW 69
20253: ST_TO_ADDR
// if not tmp then
20254: LD_VAR 0 5
20258: NOT
20259: IFFALSE 20263
// exit ;
20261: GO 20417
// for i in tmp do
20263: LD_ADDR_VAR 0 1
20267: PUSH
20268: LD_VAR 0 5
20272: PUSH
20273: FOR_IN
20274: IFFALSE 20415
// begin d := rand ( 0 , 5 ) ;
20276: LD_ADDR_VAR 0 4
20280: PUSH
20281: LD_INT 0
20283: PPUSH
20284: LD_INT 5
20286: PPUSH
20287: CALL_OW 12
20291: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
20292: LD_ADDR_VAR 0 2
20296: PUSH
20297: LD_VAR 0 1
20301: PPUSH
20302: CALL_OW 250
20306: PPUSH
20307: LD_VAR 0 4
20311: PPUSH
20312: LD_INT 3
20314: PPUSH
20315: LD_INT 12
20317: PPUSH
20318: CALL_OW 12
20322: PPUSH
20323: CALL_OW 272
20327: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
20328: LD_ADDR_VAR 0 3
20332: PUSH
20333: LD_VAR 0 1
20337: PPUSH
20338: CALL_OW 251
20342: PPUSH
20343: LD_VAR 0 4
20347: PPUSH
20348: LD_INT 3
20350: PPUSH
20351: LD_INT 12
20353: PPUSH
20354: CALL_OW 12
20358: PPUSH
20359: CALL_OW 273
20363: ST_TO_ADDR
// if ValidHex ( x , y ) then
20364: LD_VAR 0 2
20368: PPUSH
20369: LD_VAR 0 3
20373: PPUSH
20374: CALL_OW 488
20378: IFFALSE 20413
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
20380: LD_VAR 0 1
20384: PPUSH
20385: LD_VAR 0 2
20389: PPUSH
20390: LD_VAR 0 3
20394: PPUSH
20395: LD_INT 3
20397: PPUSH
20398: LD_INT 6
20400: PPUSH
20401: CALL_OW 12
20405: PPUSH
20406: LD_INT 1
20408: PPUSH
20409: CALL_OW 483
// end ;
20413: GO 20273
20415: POP
20416: POP
// end ;
20417: PPOPN 5
20419: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
20420: LD_EXP 36
20424: PUSH
20425: LD_EXP 71
20429: AND
20430: IFFALSE 20524
20432: GO 20434
20434: DISABLE
20435: LD_INT 0
20437: PPUSH
20438: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
20439: LD_ADDR_VAR 0 2
20443: PUSH
20444: LD_INT 22
20446: PUSH
20447: LD_OWVAR 2
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: LD_INT 32
20458: PUSH
20459: LD_INT 1
20461: PUSH
20462: EMPTY
20463: LIST
20464: LIST
20465: PUSH
20466: LD_INT 21
20468: PUSH
20469: LD_INT 2
20471: PUSH
20472: EMPTY
20473: LIST
20474: LIST
20475: PUSH
20476: EMPTY
20477: LIST
20478: LIST
20479: LIST
20480: PPUSH
20481: CALL_OW 69
20485: ST_TO_ADDR
// if not tmp then
20486: LD_VAR 0 2
20490: NOT
20491: IFFALSE 20495
// exit ;
20493: GO 20524
// for i in tmp do
20495: LD_ADDR_VAR 0 1
20499: PUSH
20500: LD_VAR 0 2
20504: PUSH
20505: FOR_IN
20506: IFFALSE 20522
// SetFuel ( i , 0 ) ;
20508: LD_VAR 0 1
20512: PPUSH
20513: LD_INT 0
20515: PPUSH
20516: CALL_OW 240
20520: GO 20505
20522: POP
20523: POP
// end ;
20524: PPOPN 2
20526: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
20527: LD_EXP 36
20531: PUSH
20532: LD_EXP 72
20536: AND
20537: IFFALSE 20603
20539: GO 20541
20541: DISABLE
20542: LD_INT 0
20544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20545: LD_ADDR_VAR 0 1
20549: PUSH
20550: LD_INT 22
20552: PUSH
20553: LD_OWVAR 2
20557: PUSH
20558: EMPTY
20559: LIST
20560: LIST
20561: PUSH
20562: LD_INT 30
20564: PUSH
20565: LD_INT 29
20567: PUSH
20568: EMPTY
20569: LIST
20570: LIST
20571: PUSH
20572: EMPTY
20573: LIST
20574: LIST
20575: PPUSH
20576: CALL_OW 69
20580: ST_TO_ADDR
// if not tmp then
20581: LD_VAR 0 1
20585: NOT
20586: IFFALSE 20590
// exit ;
20588: GO 20603
// DestroyUnit ( tmp [ 1 ] ) ;
20590: LD_VAR 0 1
20594: PUSH
20595: LD_INT 1
20597: ARRAY
20598: PPUSH
20599: CALL_OW 65
// end ;
20603: PPOPN 1
20605: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
20606: LD_EXP 36
20610: PUSH
20611: LD_EXP 74
20615: AND
20616: IFFALSE 20745
20618: GO 20620
20620: DISABLE
20621: LD_INT 0
20623: PPUSH
// begin uc_side := 0 ;
20624: LD_ADDR_OWVAR 20
20628: PUSH
20629: LD_INT 0
20631: ST_TO_ADDR
// uc_nation := nation_arabian ;
20632: LD_ADDR_OWVAR 21
20636: PUSH
20637: LD_INT 2
20639: ST_TO_ADDR
// hc_gallery :=  ;
20640: LD_ADDR_OWVAR 33
20644: PUSH
20645: LD_STRING 
20647: ST_TO_ADDR
// hc_name :=  ;
20648: LD_ADDR_OWVAR 26
20652: PUSH
20653: LD_STRING 
20655: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
20656: LD_INT 1
20658: PPUSH
20659: LD_INT 11
20661: PPUSH
20662: LD_INT 10
20664: PPUSH
20665: CALL_OW 380
// un := CreateHuman ;
20669: LD_ADDR_VAR 0 1
20673: PUSH
20674: CALL_OW 44
20678: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20679: LD_VAR 0 1
20683: PPUSH
20684: LD_INT 1
20686: PPUSH
20687: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20691: LD_INT 35
20693: PPUSH
20694: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20698: LD_VAR 0 1
20702: PPUSH
20703: LD_INT 22
20705: PUSH
20706: LD_OWVAR 2
20710: PUSH
20711: EMPTY
20712: LIST
20713: LIST
20714: PPUSH
20715: CALL_OW 69
20719: PPUSH
20720: LD_VAR 0 1
20724: PPUSH
20725: CALL_OW 74
20729: PPUSH
20730: CALL_OW 115
// until IsDead ( un ) ;
20734: LD_VAR 0 1
20738: PPUSH
20739: CALL_OW 301
20743: IFFALSE 20691
// end ;
20745: PPOPN 1
20747: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
20748: LD_EXP 36
20752: PUSH
20753: LD_EXP 76
20757: AND
20758: IFFALSE 20770
20760: GO 20762
20762: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
20763: LD_STRING earthquake(getX(game), 0, 32)
20765: PPUSH
20766: CALL_OW 559
20770: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20771: LD_EXP 36
20775: PUSH
20776: LD_EXP 77
20780: AND
20781: IFFALSE 20872
20783: GO 20785
20785: DISABLE
20786: LD_INT 0
20788: PPUSH
// begin enable ;
20789: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20790: LD_ADDR_VAR 0 1
20794: PUSH
20795: LD_INT 22
20797: PUSH
20798: LD_OWVAR 2
20802: PUSH
20803: EMPTY
20804: LIST
20805: LIST
20806: PUSH
20807: LD_INT 21
20809: PUSH
20810: LD_INT 2
20812: PUSH
20813: EMPTY
20814: LIST
20815: LIST
20816: PUSH
20817: LD_INT 33
20819: PUSH
20820: LD_INT 3
20822: PUSH
20823: EMPTY
20824: LIST
20825: LIST
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: LIST
20831: PPUSH
20832: CALL_OW 69
20836: ST_TO_ADDR
// if not tmp then
20837: LD_VAR 0 1
20841: NOT
20842: IFFALSE 20846
// exit ;
20844: GO 20872
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20846: LD_VAR 0 1
20850: PUSH
20851: LD_INT 1
20853: PPUSH
20854: LD_VAR 0 1
20858: PPUSH
20859: CALL_OW 12
20863: ARRAY
20864: PPUSH
20865: LD_INT 1
20867: PPUSH
20868: CALL_OW 234
// end ;
20872: PPOPN 1
20874: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
20875: LD_EXP 36
20879: PUSH
20880: LD_EXP 78
20884: AND
20885: IFFALSE 21026
20887: GO 20889
20889: DISABLE
20890: LD_INT 0
20892: PPUSH
20893: PPUSH
20894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20895: LD_ADDR_VAR 0 3
20899: PUSH
20900: LD_INT 22
20902: PUSH
20903: LD_OWVAR 2
20907: PUSH
20908: EMPTY
20909: LIST
20910: LIST
20911: PUSH
20912: LD_INT 25
20914: PUSH
20915: LD_INT 1
20917: PUSH
20918: EMPTY
20919: LIST
20920: LIST
20921: PUSH
20922: EMPTY
20923: LIST
20924: LIST
20925: PPUSH
20926: CALL_OW 69
20930: ST_TO_ADDR
// if not tmp then
20931: LD_VAR 0 3
20935: NOT
20936: IFFALSE 20940
// exit ;
20938: GO 21026
// un := tmp [ rand ( 1 , tmp ) ] ;
20940: LD_ADDR_VAR 0 2
20944: PUSH
20945: LD_VAR 0 3
20949: PUSH
20950: LD_INT 1
20952: PPUSH
20953: LD_VAR 0 3
20957: PPUSH
20958: CALL_OW 12
20962: ARRAY
20963: ST_TO_ADDR
// if Crawls ( un ) then
20964: LD_VAR 0 2
20968: PPUSH
20969: CALL_OW 318
20973: IFFALSE 20984
// ComWalk ( un ) ;
20975: LD_VAR 0 2
20979: PPUSH
20980: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
20984: LD_VAR 0 2
20988: PPUSH
20989: LD_INT 9
20991: PPUSH
20992: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
20996: LD_INT 28
20998: PPUSH
20999: LD_OWVAR 2
21003: PPUSH
21004: LD_INT 2
21006: PPUSH
21007: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
21011: LD_INT 29
21013: PPUSH
21014: LD_OWVAR 2
21018: PPUSH
21019: LD_INT 2
21021: PPUSH
21022: CALL_OW 322
// end ;
21026: PPOPN 3
21028: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
21029: LD_EXP 36
21033: PUSH
21034: LD_EXP 79
21038: AND
21039: IFFALSE 21150
21041: GO 21043
21043: DISABLE
21044: LD_INT 0
21046: PPUSH
21047: PPUSH
21048: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21049: LD_ADDR_VAR 0 3
21053: PUSH
21054: LD_INT 22
21056: PUSH
21057: LD_OWVAR 2
21061: PUSH
21062: EMPTY
21063: LIST
21064: LIST
21065: PUSH
21066: LD_INT 25
21068: PUSH
21069: LD_INT 1
21071: PUSH
21072: EMPTY
21073: LIST
21074: LIST
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: PPUSH
21080: CALL_OW 69
21084: ST_TO_ADDR
// if not tmp then
21085: LD_VAR 0 3
21089: NOT
21090: IFFALSE 21094
// exit ;
21092: GO 21150
// un := tmp [ rand ( 1 , tmp ) ] ;
21094: LD_ADDR_VAR 0 2
21098: PUSH
21099: LD_VAR 0 3
21103: PUSH
21104: LD_INT 1
21106: PPUSH
21107: LD_VAR 0 3
21111: PPUSH
21112: CALL_OW 12
21116: ARRAY
21117: ST_TO_ADDR
// if Crawls ( un ) then
21118: LD_VAR 0 2
21122: PPUSH
21123: CALL_OW 318
21127: IFFALSE 21138
// ComWalk ( un ) ;
21129: LD_VAR 0 2
21133: PPUSH
21134: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21138: LD_VAR 0 2
21142: PPUSH
21143: LD_INT 8
21145: PPUSH
21146: CALL_OW 336
// end ;
21150: PPOPN 3
21152: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
21153: LD_EXP 36
21157: PUSH
21158: LD_EXP 80
21162: AND
21163: IFFALSE 21307
21165: GO 21167
21167: DISABLE
21168: LD_INT 0
21170: PPUSH
21171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
21172: LD_ADDR_VAR 0 2
21176: PUSH
21177: LD_INT 22
21179: PUSH
21180: LD_OWVAR 2
21184: PUSH
21185: EMPTY
21186: LIST
21187: LIST
21188: PUSH
21189: LD_INT 21
21191: PUSH
21192: LD_INT 2
21194: PUSH
21195: EMPTY
21196: LIST
21197: LIST
21198: PUSH
21199: LD_INT 2
21201: PUSH
21202: LD_INT 34
21204: PUSH
21205: LD_INT 12
21207: PUSH
21208: EMPTY
21209: LIST
21210: LIST
21211: PUSH
21212: LD_INT 34
21214: PUSH
21215: LD_INT 51
21217: PUSH
21218: EMPTY
21219: LIST
21220: LIST
21221: PUSH
21222: LD_INT 34
21224: PUSH
21225: LD_INT 32
21227: PUSH
21228: EMPTY
21229: LIST
21230: LIST
21231: PUSH
21232: EMPTY
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: LIST
21242: PPUSH
21243: CALL_OW 69
21247: ST_TO_ADDR
// if not tmp then
21248: LD_VAR 0 2
21252: NOT
21253: IFFALSE 21257
// exit ;
21255: GO 21307
// for i in tmp do
21257: LD_ADDR_VAR 0 1
21261: PUSH
21262: LD_VAR 0 2
21266: PUSH
21267: FOR_IN
21268: IFFALSE 21305
// if GetCargo ( i , mat_artifact ) = 0 then
21270: LD_VAR 0 1
21274: PPUSH
21275: LD_INT 4
21277: PPUSH
21278: CALL_OW 289
21282: PUSH
21283: LD_INT 0
21285: EQUAL
21286: IFFALSE 21303
// SetCargo ( i , mat_siberit , 100 ) ;
21288: LD_VAR 0 1
21292: PPUSH
21293: LD_INT 3
21295: PPUSH
21296: LD_INT 100
21298: PPUSH
21299: CALL_OW 290
21303: GO 21267
21305: POP
21306: POP
// end ;
21307: PPOPN 2
21309: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
21310: LD_EXP 36
21314: PUSH
21315: LD_EXP 81
21319: AND
21320: IFFALSE 21473
21322: GO 21324
21324: DISABLE
21325: LD_INT 0
21327: PPUSH
21328: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
21329: LD_ADDR_VAR 0 2
21333: PUSH
21334: LD_INT 22
21336: PUSH
21337: LD_OWVAR 2
21341: PUSH
21342: EMPTY
21343: LIST
21344: LIST
21345: PPUSH
21346: CALL_OW 69
21350: ST_TO_ADDR
// if not tmp then
21351: LD_VAR 0 2
21355: NOT
21356: IFFALSE 21360
// exit ;
21358: GO 21473
// for i := 1 to 2 do
21360: LD_ADDR_VAR 0 1
21364: PUSH
21365: DOUBLE
21366: LD_INT 1
21368: DEC
21369: ST_TO_ADDR
21370: LD_INT 2
21372: PUSH
21373: FOR_TO
21374: IFFALSE 21471
// begin uc_side := your_side ;
21376: LD_ADDR_OWVAR 20
21380: PUSH
21381: LD_OWVAR 2
21385: ST_TO_ADDR
// uc_nation := nation_american ;
21386: LD_ADDR_OWVAR 21
21390: PUSH
21391: LD_INT 1
21393: ST_TO_ADDR
// vc_chassis := us_morphling ;
21394: LD_ADDR_OWVAR 37
21398: PUSH
21399: LD_INT 5
21401: ST_TO_ADDR
// vc_engine := engine_siberite ;
21402: LD_ADDR_OWVAR 39
21406: PUSH
21407: LD_INT 3
21409: ST_TO_ADDR
// vc_control := control_computer ;
21410: LD_ADDR_OWVAR 38
21414: PUSH
21415: LD_INT 3
21417: ST_TO_ADDR
// vc_weapon := us_double_laser ;
21418: LD_ADDR_OWVAR 40
21422: PUSH
21423: LD_INT 10
21425: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
21426: CALL_OW 45
21430: PPUSH
21431: LD_VAR 0 2
21435: PUSH
21436: LD_INT 1
21438: ARRAY
21439: PPUSH
21440: CALL_OW 250
21444: PPUSH
21445: LD_VAR 0 2
21449: PUSH
21450: LD_INT 1
21452: ARRAY
21453: PPUSH
21454: CALL_OW 251
21458: PPUSH
21459: LD_INT 12
21461: PPUSH
21462: LD_INT 1
21464: PPUSH
21465: CALL_OW 50
// end ;
21469: GO 21373
21471: POP
21472: POP
// end ;
21473: PPOPN 2
21475: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
21476: LD_EXP 36
21480: PUSH
21481: LD_EXP 82
21485: AND
21486: IFFALSE 21708
21488: GO 21490
21490: DISABLE
21491: LD_INT 0
21493: PPUSH
21494: PPUSH
21495: PPUSH
21496: PPUSH
21497: PPUSH
21498: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21499: LD_ADDR_VAR 0 6
21503: PUSH
21504: LD_INT 22
21506: PUSH
21507: LD_OWVAR 2
21511: PUSH
21512: EMPTY
21513: LIST
21514: LIST
21515: PUSH
21516: LD_INT 21
21518: PUSH
21519: LD_INT 1
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: PUSH
21526: LD_INT 3
21528: PUSH
21529: LD_INT 23
21531: PUSH
21532: LD_INT 0
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: EMPTY
21540: LIST
21541: LIST
21542: PUSH
21543: EMPTY
21544: LIST
21545: LIST
21546: LIST
21547: PPUSH
21548: CALL_OW 69
21552: ST_TO_ADDR
// if not tmp then
21553: LD_VAR 0 6
21557: NOT
21558: IFFALSE 21562
// exit ;
21560: GO 21708
// s1 := rand ( 1 , 4 ) ;
21562: LD_ADDR_VAR 0 2
21566: PUSH
21567: LD_INT 1
21569: PPUSH
21570: LD_INT 4
21572: PPUSH
21573: CALL_OW 12
21577: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
21578: LD_ADDR_VAR 0 4
21582: PUSH
21583: LD_VAR 0 6
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_VAR 0 2
21596: PPUSH
21597: CALL_OW 259
21601: ST_TO_ADDR
// if s1 = 1 then
21602: LD_VAR 0 2
21606: PUSH
21607: LD_INT 1
21609: EQUAL
21610: IFFALSE 21630
// s2 := rand ( 2 , 4 ) else
21612: LD_ADDR_VAR 0 3
21616: PUSH
21617: LD_INT 2
21619: PPUSH
21620: LD_INT 4
21622: PPUSH
21623: CALL_OW 12
21627: ST_TO_ADDR
21628: GO 21638
// s2 := 1 ;
21630: LD_ADDR_VAR 0 3
21634: PUSH
21635: LD_INT 1
21637: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
21638: LD_ADDR_VAR 0 5
21642: PUSH
21643: LD_VAR 0 6
21647: PUSH
21648: LD_INT 1
21650: ARRAY
21651: PPUSH
21652: LD_VAR 0 3
21656: PPUSH
21657: CALL_OW 259
21661: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
21662: LD_VAR 0 6
21666: PUSH
21667: LD_INT 1
21669: ARRAY
21670: PPUSH
21671: LD_VAR 0 2
21675: PPUSH
21676: LD_VAR 0 5
21680: PPUSH
21681: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
21685: LD_VAR 0 6
21689: PUSH
21690: LD_INT 1
21692: ARRAY
21693: PPUSH
21694: LD_VAR 0 3
21698: PPUSH
21699: LD_VAR 0 4
21703: PPUSH
21704: CALL_OW 237
// end ;
21708: PPOPN 6
21710: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
21711: LD_EXP 36
21715: PUSH
21716: LD_EXP 83
21720: AND
21721: IFFALSE 21800
21723: GO 21725
21725: DISABLE
21726: LD_INT 0
21728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
21729: LD_ADDR_VAR 0 1
21733: PUSH
21734: LD_INT 22
21736: PUSH
21737: LD_OWVAR 2
21741: PUSH
21742: EMPTY
21743: LIST
21744: LIST
21745: PUSH
21746: LD_INT 30
21748: PUSH
21749: LD_INT 3
21751: PUSH
21752: EMPTY
21753: LIST
21754: LIST
21755: PUSH
21756: EMPTY
21757: LIST
21758: LIST
21759: PPUSH
21760: CALL_OW 69
21764: ST_TO_ADDR
// if not tmp then
21765: LD_VAR 0 1
21769: NOT
21770: IFFALSE 21774
// exit ;
21772: GO 21800
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21774: LD_VAR 0 1
21778: PUSH
21779: LD_INT 1
21781: PPUSH
21782: LD_VAR 0 1
21786: PPUSH
21787: CALL_OW 12
21791: ARRAY
21792: PPUSH
21793: LD_INT 1
21795: PPUSH
21796: CALL_OW 234
// end ;
21800: PPOPN 1
21802: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21803: LD_EXP 36
21807: PUSH
21808: LD_EXP 84
21812: AND
21813: IFFALSE 21925
21815: GO 21817
21817: DISABLE
21818: LD_INT 0
21820: PPUSH
21821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
21822: LD_ADDR_VAR 0 2
21826: PUSH
21827: LD_INT 22
21829: PUSH
21830: LD_OWVAR 2
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: PUSH
21839: LD_INT 2
21841: PUSH
21842: LD_INT 30
21844: PUSH
21845: LD_INT 27
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: PUSH
21852: LD_INT 30
21854: PUSH
21855: LD_INT 26
21857: PUSH
21858: EMPTY
21859: LIST
21860: LIST
21861: PUSH
21862: LD_INT 30
21864: PUSH
21865: LD_INT 28
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: PUSH
21878: EMPTY
21879: LIST
21880: LIST
21881: PPUSH
21882: CALL_OW 69
21886: ST_TO_ADDR
// if not tmp then
21887: LD_VAR 0 2
21891: NOT
21892: IFFALSE 21896
// exit ;
21894: GO 21925
// for i in tmp do
21896: LD_ADDR_VAR 0 1
21900: PUSH
21901: LD_VAR 0 2
21905: PUSH
21906: FOR_IN
21907: IFFALSE 21923
// SetLives ( i , 1 ) ;
21909: LD_VAR 0 1
21913: PPUSH
21914: LD_INT 1
21916: PPUSH
21917: CALL_OW 234
21921: GO 21906
21923: POP
21924: POP
// end ;
21925: PPOPN 2
21927: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
21928: LD_EXP 36
21932: PUSH
21933: LD_EXP 85
21937: AND
21938: IFFALSE 22212
21940: GO 21942
21942: DISABLE
21943: LD_INT 0
21945: PPUSH
21946: PPUSH
21947: PPUSH
// begin i := rand ( 1 , 7 ) ;
21948: LD_ADDR_VAR 0 1
21952: PUSH
21953: LD_INT 1
21955: PPUSH
21956: LD_INT 7
21958: PPUSH
21959: CALL_OW 12
21963: ST_TO_ADDR
// case i of 1 :
21964: LD_VAR 0 1
21968: PUSH
21969: LD_INT 1
21971: DOUBLE
21972: EQUAL
21973: IFTRUE 21977
21975: GO 21987
21977: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
21978: LD_STRING earthquake(getX(game), 0, 32)
21980: PPUSH
21981: CALL_OW 559
21985: GO 22212
21987: LD_INT 2
21989: DOUBLE
21990: EQUAL
21991: IFTRUE 21995
21993: GO 22009
21995: POP
// begin ToLua ( displayStucuk(); ) ;
21996: LD_STRING displayStucuk();
21998: PPUSH
21999: CALL_OW 559
// ResetFog ;
22003: CALL_OW 335
// end ; 3 :
22007: GO 22212
22009: LD_INT 3
22011: DOUBLE
22012: EQUAL
22013: IFTRUE 22017
22015: GO 22121
22017: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22018: LD_ADDR_VAR 0 2
22022: PUSH
22023: LD_INT 22
22025: PUSH
22026: LD_OWVAR 2
22030: PUSH
22031: EMPTY
22032: LIST
22033: LIST
22034: PUSH
22035: LD_INT 25
22037: PUSH
22038: LD_INT 1
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: PPUSH
22049: CALL_OW 69
22053: ST_TO_ADDR
// if not tmp then
22054: LD_VAR 0 2
22058: NOT
22059: IFFALSE 22063
// exit ;
22061: GO 22212
// un := tmp [ rand ( 1 , tmp ) ] ;
22063: LD_ADDR_VAR 0 3
22067: PUSH
22068: LD_VAR 0 2
22072: PUSH
22073: LD_INT 1
22075: PPUSH
22076: LD_VAR 0 2
22080: PPUSH
22081: CALL_OW 12
22085: ARRAY
22086: ST_TO_ADDR
// if Crawls ( un ) then
22087: LD_VAR 0 3
22091: PPUSH
22092: CALL_OW 318
22096: IFFALSE 22107
// ComWalk ( un ) ;
22098: LD_VAR 0 3
22102: PPUSH
22103: CALL_OW 138
// SetClass ( un , class_mortar ) ;
22107: LD_VAR 0 3
22111: PPUSH
22112: LD_INT 8
22114: PPUSH
22115: CALL_OW 336
// end ; 4 :
22119: GO 22212
22121: LD_INT 4
22123: DOUBLE
22124: EQUAL
22125: IFTRUE 22129
22127: GO 22190
22129: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
22130: LD_ADDR_VAR 0 2
22134: PUSH
22135: LD_INT 22
22137: PUSH
22138: LD_OWVAR 2
22142: PUSH
22143: EMPTY
22144: LIST
22145: LIST
22146: PUSH
22147: LD_INT 30
22149: PUSH
22150: LD_INT 29
22152: PUSH
22153: EMPTY
22154: LIST
22155: LIST
22156: PUSH
22157: EMPTY
22158: LIST
22159: LIST
22160: PPUSH
22161: CALL_OW 69
22165: ST_TO_ADDR
// if not tmp then
22166: LD_VAR 0 2
22170: NOT
22171: IFFALSE 22175
// exit ;
22173: GO 22212
// DestroyUnit ( tmp [ 1 ] ) ;
22175: LD_VAR 0 2
22179: PUSH
22180: LD_INT 1
22182: ARRAY
22183: PPUSH
22184: CALL_OW 65
// end ; 5 .. 7 :
22188: GO 22212
22190: LD_INT 5
22192: DOUBLE
22193: GREATEREQUAL
22194: IFFALSE 22202
22196: LD_INT 7
22198: DOUBLE
22199: LESSEQUAL
22200: IFTRUE 22204
22202: GO 22211
22204: POP
// StreamSibBomb ; end ;
22205: CALL 18492 0 0
22209: GO 22212
22211: POP
// end ;
22212: PPOPN 3
22214: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
22215: LD_EXP 36
22219: PUSH
22220: LD_EXP 86
22224: AND
22225: IFFALSE 22381
22227: GO 22229
22229: DISABLE
22230: LD_INT 0
22232: PPUSH
22233: PPUSH
22234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
22235: LD_ADDR_VAR 0 2
22239: PUSH
22240: LD_INT 81
22242: PUSH
22243: LD_OWVAR 2
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: LD_INT 2
22254: PUSH
22255: LD_INT 21
22257: PUSH
22258: LD_INT 1
22260: PUSH
22261: EMPTY
22262: LIST
22263: LIST
22264: PUSH
22265: LD_INT 21
22267: PUSH
22268: LD_INT 2
22270: PUSH
22271: EMPTY
22272: LIST
22273: LIST
22274: PUSH
22275: EMPTY
22276: LIST
22277: LIST
22278: LIST
22279: PUSH
22280: EMPTY
22281: LIST
22282: LIST
22283: PPUSH
22284: CALL_OW 69
22288: ST_TO_ADDR
// if not tmp then
22289: LD_VAR 0 2
22293: NOT
22294: IFFALSE 22298
// exit ;
22296: GO 22381
// p := 0 ;
22298: LD_ADDR_VAR 0 3
22302: PUSH
22303: LD_INT 0
22305: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22306: LD_INT 35
22308: PPUSH
22309: CALL_OW 67
// p := p + 1 ;
22313: LD_ADDR_VAR 0 3
22317: PUSH
22318: LD_VAR 0 3
22322: PUSH
22323: LD_INT 1
22325: PLUS
22326: ST_TO_ADDR
// for i in tmp do
22327: LD_ADDR_VAR 0 1
22331: PUSH
22332: LD_VAR 0 2
22336: PUSH
22337: FOR_IN
22338: IFFALSE 22369
// if GetLives ( i ) < 1000 then
22340: LD_VAR 0 1
22344: PPUSH
22345: CALL_OW 256
22349: PUSH
22350: LD_INT 1000
22352: LESS
22353: IFFALSE 22367
// SetLives ( i , 1000 ) ;
22355: LD_VAR 0 1
22359: PPUSH
22360: LD_INT 1000
22362: PPUSH
22363: CALL_OW 234
22367: GO 22337
22369: POP
22370: POP
// until p > 20 ;
22371: LD_VAR 0 3
22375: PUSH
22376: LD_INT 20
22378: GREATER
22379: IFFALSE 22306
// end ;
22381: PPOPN 3
22383: END
// every 0 0$1 trigger StreamModeActive and sTime do
22384: LD_EXP 36
22388: PUSH
22389: LD_EXP 87
22393: AND
22394: IFFALSE 22429
22396: GO 22398
22398: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
22399: LD_INT 28
22401: PPUSH
22402: LD_OWVAR 2
22406: PPUSH
22407: LD_INT 2
22409: PPUSH
22410: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
22414: LD_INT 30
22416: PPUSH
22417: LD_OWVAR 2
22421: PPUSH
22422: LD_INT 2
22424: PPUSH
22425: CALL_OW 322
// end ;
22429: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
22430: LD_EXP 36
22434: PUSH
22435: LD_EXP 88
22439: AND
22440: IFFALSE 22561
22442: GO 22444
22444: DISABLE
22445: LD_INT 0
22447: PPUSH
22448: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22449: LD_ADDR_VAR 0 2
22453: PUSH
22454: LD_INT 22
22456: PUSH
22457: LD_OWVAR 2
22461: PUSH
22462: EMPTY
22463: LIST
22464: LIST
22465: PUSH
22466: LD_INT 21
22468: PUSH
22469: LD_INT 1
22471: PUSH
22472: EMPTY
22473: LIST
22474: LIST
22475: PUSH
22476: LD_INT 3
22478: PUSH
22479: LD_INT 23
22481: PUSH
22482: LD_INT 0
22484: PUSH
22485: EMPTY
22486: LIST
22487: LIST
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: LIST
22497: PPUSH
22498: CALL_OW 69
22502: ST_TO_ADDR
// if not tmp then
22503: LD_VAR 0 2
22507: NOT
22508: IFFALSE 22512
// exit ;
22510: GO 22561
// for i in tmp do
22512: LD_ADDR_VAR 0 1
22516: PUSH
22517: LD_VAR 0 2
22521: PUSH
22522: FOR_IN
22523: IFFALSE 22559
// begin if Crawls ( i ) then
22525: LD_VAR 0 1
22529: PPUSH
22530: CALL_OW 318
22534: IFFALSE 22545
// ComWalk ( i ) ;
22536: LD_VAR 0 1
22540: PPUSH
22541: CALL_OW 138
// SetClass ( i , 2 ) ;
22545: LD_VAR 0 1
22549: PPUSH
22550: LD_INT 2
22552: PPUSH
22553: CALL_OW 336
// end ;
22557: GO 22522
22559: POP
22560: POP
// end ;
22561: PPOPN 2
22563: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
22564: LD_EXP 36
22568: PUSH
22569: LD_EXP 89
22573: AND
22574: IFFALSE 22855
22576: GO 22578
22578: DISABLE
22579: LD_INT 0
22581: PPUSH
22582: PPUSH
22583: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
22584: LD_OWVAR 2
22588: PPUSH
22589: LD_INT 9
22591: PPUSH
22592: LD_INT 1
22594: PPUSH
22595: LD_INT 1
22597: PPUSH
22598: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
22602: LD_INT 9
22604: PPUSH
22605: LD_OWVAR 2
22609: PPUSH
22610: CALL_OW 343
// uc_side := 9 ;
22614: LD_ADDR_OWVAR 20
22618: PUSH
22619: LD_INT 9
22621: ST_TO_ADDR
// uc_nation := 2 ;
22622: LD_ADDR_OWVAR 21
22626: PUSH
22627: LD_INT 2
22629: ST_TO_ADDR
// hc_name := Dark Warrior ;
22630: LD_ADDR_OWVAR 26
22634: PUSH
22635: LD_STRING Dark Warrior
22637: ST_TO_ADDR
// hc_gallery :=  ;
22638: LD_ADDR_OWVAR 33
22642: PUSH
22643: LD_STRING 
22645: ST_TO_ADDR
// hc_noskilllimit := true ;
22646: LD_ADDR_OWVAR 76
22650: PUSH
22651: LD_INT 1
22653: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
22654: LD_ADDR_OWVAR 31
22658: PUSH
22659: LD_INT 30
22661: PUSH
22662: LD_INT 30
22664: PUSH
22665: LD_INT 30
22667: PUSH
22668: LD_INT 30
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: ST_TO_ADDR
// un := CreateHuman ;
22677: LD_ADDR_VAR 0 3
22681: PUSH
22682: CALL_OW 44
22686: ST_TO_ADDR
// hc_noskilllimit := false ;
22687: LD_ADDR_OWVAR 76
22691: PUSH
22692: LD_INT 0
22694: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22695: LD_VAR 0 3
22699: PPUSH
22700: LD_INT 1
22702: PPUSH
22703: CALL_OW 51
// p := 0 ;
22707: LD_ADDR_VAR 0 2
22711: PUSH
22712: LD_INT 0
22714: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22715: LD_INT 35
22717: PPUSH
22718: CALL_OW 67
// p := p + 1 ;
22722: LD_ADDR_VAR 0 2
22726: PUSH
22727: LD_VAR 0 2
22731: PUSH
22732: LD_INT 1
22734: PLUS
22735: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
22736: LD_VAR 0 3
22740: PPUSH
22741: CALL_OW 256
22745: PUSH
22746: LD_INT 1000
22748: LESS
22749: IFFALSE 22763
// SetLives ( un , 1000 ) ;
22751: LD_VAR 0 3
22755: PPUSH
22756: LD_INT 1000
22758: PPUSH
22759: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
22763: LD_VAR 0 3
22767: PPUSH
22768: LD_INT 81
22770: PUSH
22771: LD_OWVAR 2
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: LD_INT 91
22782: PUSH
22783: LD_VAR 0 3
22787: PUSH
22788: LD_INT 30
22790: PUSH
22791: EMPTY
22792: LIST
22793: LIST
22794: LIST
22795: PUSH
22796: EMPTY
22797: LIST
22798: LIST
22799: PPUSH
22800: CALL_OW 69
22804: PPUSH
22805: LD_VAR 0 3
22809: PPUSH
22810: CALL_OW 74
22814: PPUSH
22815: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
22819: LD_VAR 0 2
22823: PUSH
22824: LD_INT 60
22826: GREATER
22827: PUSH
22828: LD_VAR 0 3
22832: PPUSH
22833: CALL_OW 301
22837: OR
22838: IFFALSE 22715
// if un then
22840: LD_VAR 0 3
22844: IFFALSE 22855
// RemoveUnit ( un ) ;
22846: LD_VAR 0 3
22850: PPUSH
22851: CALL_OW 64
// end ; end_of_file end_of_file
22855: PPOPN 3
22857: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
22858: GO 22860
22860: DISABLE
// begin ru_radar := 98 ;
22861: LD_ADDR_EXP 90
22865: PUSH
22866: LD_INT 98
22868: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
22869: LD_ADDR_EXP 91
22873: PUSH
22874: LD_INT 89
22876: ST_TO_ADDR
// us_hack := 99 ;
22877: LD_ADDR_EXP 92
22881: PUSH
22882: LD_INT 99
22884: ST_TO_ADDR
// us_artillery := 97 ;
22885: LD_ADDR_EXP 93
22889: PUSH
22890: LD_INT 97
22892: ST_TO_ADDR
// ar_bio_bomb := 91 ;
22893: LD_ADDR_EXP 94
22897: PUSH
22898: LD_INT 91
22900: ST_TO_ADDR
// tech_Artillery := 80 ;
22901: LD_ADDR_EXP 95
22905: PUSH
22906: LD_INT 80
22908: ST_TO_ADDR
// tech_RadMat := 81 ;
22909: LD_ADDR_EXP 96
22913: PUSH
22914: LD_INT 81
22916: ST_TO_ADDR
// tech_BasicTools := 82 ;
22917: LD_ADDR_EXP 97
22921: PUSH
22922: LD_INT 82
22924: ST_TO_ADDR
// tech_Cargo := 83 ;
22925: LD_ADDR_EXP 98
22929: PUSH
22930: LD_INT 83
22932: ST_TO_ADDR
// tech_Track := 84 ;
22933: LD_ADDR_EXP 99
22937: PUSH
22938: LD_INT 84
22940: ST_TO_ADDR
// tech_Crane := 85 ;
22941: LD_ADDR_EXP 100
22945: PUSH
22946: LD_INT 85
22948: ST_TO_ADDR
// tech_Bulldozer := 86 ;
22949: LD_ADDR_EXP 101
22953: PUSH
22954: LD_INT 86
22956: ST_TO_ADDR
// tech_Hovercraft := 87 ;
22957: LD_ADDR_EXP 102
22961: PUSH
22962: LD_INT 87
22964: ST_TO_ADDR
// end ;
22965: END
