// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// if isEditor then
   8: LD_INT 1
  10: IFFALSE 19
// FogOff ( 6 ) ;
  12: LD_INT 6
  14: PPUSH
  15: CALL_OW 344
// PrepareAnimals ( 7 , 2 , 2 , cratesArea ) ;
  19: LD_INT 7
  21: PPUSH
  22: LD_INT 2
  24: PPUSH
  25: LD_INT 2
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: CALL 5205 0 4
// PrepareAlliance ;
  35: CALL 48 0 0
// PrepareLegion ;
  39: CALL 723 0 0
// Action ;
  43: CALL 4534 0 0
// end ; end_of_file
  47: END
// export function PrepareAlliance ; var i , un , skill ; begin
  48: LD_INT 0
  50: PPUSH
  51: PPUSH
  52: PPUSH
  53: PPUSH
// uc_side := 7 ;
  54: LD_ADDR_OWVAR 20
  58: PUSH
  59: LD_INT 7
  61: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
  62: LD_ADDR_VAR 0 4
  66: PUSH
  67: LD_INT 7
  69: PUSH
  70: LD_INT 8
  72: PUSH
  73: LD_INT 9
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: LIST
  80: PUSH
  81: LD_OWVAR 67
  85: ARRAY
  86: ST_TO_ADDR
// SetResourceType ( GetBase ( al_dep ) , mat_cans , 999999 ) ;
  87: LD_INT 1
  89: PPUSH
  90: CALL_OW 274
  94: PPUSH
  95: LD_INT 1
  97: PPUSH
  98: LD_INT 999999
 100: PPUSH
 101: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_oil , 10000 ) ;
 105: LD_INT 1
 107: PPUSH
 108: CALL_OW 274
 112: PPUSH
 113: LD_INT 2
 115: PPUSH
 116: LD_INT 10000
 118: PPUSH
 119: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_siberit , 10000 ) ;
 123: LD_INT 1
 125: PPUSH
 126: CALL_OW 274
 130: PPUSH
 131: LD_INT 3
 133: PPUSH
 134: LD_INT 10000
 136: PPUSH
 137: CALL_OW 277
// for i = 1 to 6 do
 141: LD_ADDR_VAR 0 2
 145: PUSH
 146: DOUBLE
 147: LD_INT 1
 149: DEC
 150: ST_TO_ADDR
 151: LD_INT 6
 153: PUSH
 154: FOR_TO
 155: IFFALSE 216
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 157: LD_ADDR_OWVAR 21
 161: PUSH
 162: LD_INT 1
 164: PUSH
 165: LD_INT 3
 167: PUSH
 168: EMPTY
 169: LIST
 170: LIST
 171: PUSH
 172: LD_INT 1
 174: PPUSH
 175: LD_INT 2
 177: PPUSH
 178: CALL_OW 12
 182: ARRAY
 183: ST_TO_ADDR
// PrepareHuman ( false , class_engineer , skill ) ;
 184: LD_INT 0
 186: PPUSH
 187: LD_INT 2
 189: PPUSH
 190: LD_VAR 0 4
 194: PPUSH
 195: CALL_OW 380
// PlaceUnitArea ( CreateHuman , al_base , false ) ;
 199: CALL_OW 44
 203: PPUSH
 204: LD_INT 1
 206: PPUSH
 207: LD_INT 0
 209: PPUSH
 210: CALL_OW 49
// end ;
 214: GO 154
 216: POP
 217: POP
// for i = 1 to 6 do
 218: LD_ADDR_VAR 0 2
 222: PUSH
 223: DOUBLE
 224: LD_INT 1
 226: DEC
 227: ST_TO_ADDR
 228: LD_INT 6
 230: PUSH
 231: FOR_TO
 232: IFFALSE 290
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 234: LD_ADDR_OWVAR 21
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 3
 244: PUSH
 245: EMPTY
 246: LIST
 247: LIST
 248: PUSH
 249: LD_INT 1
 251: PPUSH
 252: LD_INT 2
 254: PPUSH
 255: CALL_OW 12
 259: ARRAY
 260: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 261: LD_INT 0
 263: PPUSH
 264: LD_INT 3
 266: PPUSH
 267: LD_VAR 0 4
 271: PPUSH
 272: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_ru ) ;
 276: CALL_OW 44
 280: PPUSH
 281: LD_INT 6
 283: PPUSH
 284: CALL_OW 52
// end ;
 288: GO 231
 290: POP
 291: POP
// for i = 1 to 6 do
 292: LD_ADDR_VAR 0 2
 296: PUSH
 297: DOUBLE
 298: LD_INT 1
 300: DEC
 301: ST_TO_ADDR
 302: LD_INT 6
 304: PUSH
 305: FOR_TO
 306: IFFALSE 364
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 308: LD_ADDR_OWVAR 21
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 3
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 2
 328: PPUSH
 329: CALL_OW 12
 333: ARRAY
 334: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 335: LD_INT 0
 337: PPUSH
 338: LD_INT 3
 340: PPUSH
 341: LD_VAR 0 4
 345: PPUSH
 346: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_us ) ;
 350: CALL_OW 44
 354: PPUSH
 355: LD_INT 11
 357: PPUSH
 358: CALL_OW 52
// end ;
 362: GO 305
 364: POP
 365: POP
// for i = 1 to 6 do
 366: LD_ADDR_VAR 0 2
 370: PUSH
 371: DOUBLE
 372: LD_INT 1
 374: DEC
 375: ST_TO_ADDR
 376: LD_INT 6
 378: PUSH
 379: FOR_TO
 380: IFFALSE 457
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 382: LD_ADDR_OWVAR 21
 386: PUSH
 387: LD_INT 1
 389: PUSH
 390: LD_INT 3
 392: PUSH
 393: EMPTY
 394: LIST
 395: LIST
 396: PUSH
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 2
 402: PPUSH
 403: CALL_OW 12
 407: ARRAY
 408: ST_TO_ADDR
// PrepareHuman ( false , class_scientistic , skill ) ;
 409: LD_INT 0
 411: PPUSH
 412: LD_INT 4
 414: PPUSH
 415: LD_VAR 0 4
 419: PPUSH
 420: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , [ al_lab_us , al_lab_ru ] [ Rand ( 1 , 2 ) ] ) ;
 424: CALL_OW 44
 428: PPUSH
 429: LD_INT 2
 431: PUSH
 432: LD_INT 5
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 1
 441: PPUSH
 442: LD_INT 2
 444: PPUSH
 445: CALL_OW 12
 449: ARRAY
 450: PPUSH
 451: CALL_OW 52
// end ;
 455: GO 379
 457: POP
 458: POP
// for i = 1 to 6 do
 459: LD_ADDR_VAR 0 2
 463: PUSH
 464: DOUBLE
 465: LD_INT 1
 467: DEC
 468: ST_TO_ADDR
 469: LD_INT 6
 471: PUSH
 472: FOR_TO
 473: IFFALSE 580
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 475: LD_ADDR_OWVAR 21
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 3
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 2
 495: PPUSH
 496: CALL_OW 12
 500: ARRAY
 501: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker ] [ Rand ( 1 , 2 ) ] , skill ) ;
 502: LD_INT 0
 504: PPUSH
 505: LD_INT 5
 507: PUSH
 508: LD_INT 9
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 1
 517: PPUSH
 518: LD_INT 2
 520: PPUSH
 521: CALL_OW 12
 525: ARRAY
 526: PPUSH
 527: LD_VAR 0 4
 531: PPUSH
 532: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 536: CALL_OW 44
 540: PPUSH
 541: LD_INT 22
 543: PUSH
 544: LD_INT 7
 546: PUSH
 547: EMPTY
 548: LIST
 549: LIST
 550: PUSH
 551: LD_INT 30
 553: PUSH
 554: LD_INT 5
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: PUSH
 561: EMPTY
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL_OW 69
 569: PUSH
 570: LD_INT 1
 572: ARRAY
 573: PPUSH
 574: CALL_OW 52
// end ;
 578: GO 472
 580: POP
 581: POP
// uc_nation := 3 ;
 582: LD_ADDR_OWVAR 21
 586: PUSH
 587: LD_INT 3
 589: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , skill ) ;
 590: LD_INT 0
 592: PPUSH
 593: LD_INT 5
 595: PPUSH
 596: LD_VAR 0 4
 600: PPUSH
 601: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_bun ) ;
 605: CALL_OW 44
 609: PPUSH
 610: LD_INT 50
 612: PPUSH
 613: CALL_OW 52
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) do
 617: LD_ADDR_VAR 0 2
 621: PUSH
 622: LD_INT 22
 624: PUSH
 625: LD_INT 7
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: PUSH
 632: LD_INT 30
 634: PUSH
 635: LD_INT 33
 637: PUSH
 638: EMPTY
 639: LIST
 640: LIST
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: PPUSH
 646: CALL_OW 69
 650: PUSH
 651: FOR_IN
 652: IFFALSE 716
// if GetNation ( i ) = 1 then
 654: LD_VAR 0 2
 658: PPUSH
 659: CALL_OW 248
 663: PUSH
 664: LD_INT 1
 666: EQUAL
 667: IFFALSE 683
// AddComPlaceWeapon ( i , us_double_laser ) else
 669: LD_VAR 0 2
 673: PPUSH
 674: LD_INT 10
 676: PPUSH
 677: CALL_OW 208
 681: GO 714
// AddComPlaceWeapon ( i , [ ru_rocket , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
 683: LD_VAR 0 2
 687: PPUSH
 688: LD_INT 47
 690: PUSH
 691: LD_INT 45
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: PUSH
 698: LD_INT 1
 700: PPUSH
 701: LD_INT 2
 703: PPUSH
 704: CALL_OW 12
 708: ARRAY
 709: PPUSH
 710: CALL_OW 208
 714: GO 651
 716: POP
 717: POP
// end ; end_of_file
 718: LD_VAR 0 1
 722: RET
// export function PrepareLegion ; var i , un , skill , dep , fac ; begin
 723: LD_INT 0
 725: PPUSH
 726: PPUSH
 727: PPUSH
 728: PPUSH
 729: PPUSH
 730: PPUSH
// uc_side := 8 ;
 731: LD_ADDR_OWVAR 20
 735: PUSH
 736: LD_INT 8
 738: ST_TO_ADDR
// uc_nation := 2 ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_INT 2
 746: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
 747: LD_ADDR_VAR 0 4
 751: PUSH
 752: LD_INT 7
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 9
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: ST_TO_ADDR
// dep := ar_base ;
 772: LD_ADDR_VAR 0 5
 776: PUSH
 777: LD_INT 57
 779: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
 780: LD_ADDR_VAR 0 6
 784: PUSH
 785: LD_INT 22
 787: PUSH
 788: LD_INT 8
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: EMPTY
 806: LIST
 807: LIST
 808: PPUSH
 809: CALL_OW 69
 813: PUSH
 814: LD_INT 1
 816: ARRAY
 817: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 999999 ) ;
 818: LD_VAR 0 5
 822: PPUSH
 823: CALL_OW 274
 827: PPUSH
 828: LD_INT 1
 830: PPUSH
 831: LD_INT 999999
 833: PPUSH
 834: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 838: LD_VAR 0 5
 842: PPUSH
 843: CALL_OW 274
 847: PPUSH
 848: LD_INT 2
 850: PPUSH
 851: LD_INT 10000
 853: PPUSH
 854: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 10000 ) ;
 858: LD_VAR 0 5
 862: PPUSH
 863: CALL_OW 274
 867: PPUSH
 868: LD_INT 3
 870: PPUSH
 871: LD_INT 10000
 873: PPUSH
 874: CALL_OW 277
// TeleportExit ( legion_telep , 224 , 5 ) ;
 878: LD_INT 68
 880: PPUSH
 881: LD_INT 224
 883: PPUSH
 884: LD_INT 5
 886: PPUSH
 887: CALL_OW 243
// for i = 1 to 4 do
 891: LD_ADDR_VAR 0 2
 895: PUSH
 896: DOUBLE
 897: LD_INT 1
 899: DEC
 900: ST_TO_ADDR
 901: LD_INT 4
 903: PUSH
 904: FOR_TO
 905: IFFALSE 966
// begin PrepareHuman ( false , class_bazooker , skill ) ;
 907: LD_INT 0
 909: PPUSH
 910: LD_INT 9
 912: PPUSH
 913: LD_VAR 0 4
 917: PPUSH
 918: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 922: CALL_OW 44
 926: PPUSH
 927: LD_INT 22
 929: PUSH
 930: LD_INT 8
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 30
 939: PUSH
 940: LD_INT 5
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PPUSH
 951: CALL_OW 69
 955: PUSH
 956: LD_INT 1
 958: ARRAY
 959: PPUSH
 960: CALL_OW 52
// end ;
 964: GO 904
 966: POP
 967: POP
// for i = 1 to 2 do
 968: LD_ADDR_VAR 0 2
 972: PUSH
 973: DOUBLE
 974: LD_INT 1
 976: DEC
 977: ST_TO_ADDR
 978: LD_INT 2
 980: PUSH
 981: FOR_TO
 982: IFFALSE 1043
// begin PrepareHuman ( false , 4 , skill ) ;
 984: LD_INT 0
 986: PPUSH
 987: LD_INT 4
 989: PPUSH
 990: LD_VAR 0 4
 994: PPUSH
 995: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
 999: CALL_OW 44
1003: PPUSH
1004: LD_INT 22
1006: PUSH
1007: LD_INT 8
1009: PUSH
1010: EMPTY
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 30
1016: PUSH
1017: LD_INT 8
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL_OW 69
1032: PUSH
1033: LD_INT 1
1035: ARRAY
1036: PPUSH
1037: CALL_OW 52
// end ;
1041: GO 981
1043: POP
1044: POP
// for i = 1 to 6 do
1045: LD_ADDR_VAR 0 2
1049: PUSH
1050: DOUBLE
1051: LD_INT 1
1053: DEC
1054: ST_TO_ADDR
1055: LD_INT 6
1057: PUSH
1058: FOR_TO
1059: IFFALSE 1096
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
1061: LD_INT 0
1063: PPUSH
1064: LD_INT 3
1066: PPUSH
1067: LD_VAR 0 4
1071: PUSH
1072: LD_INT 1
1074: PLUS
1075: PPUSH
1076: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac ) ;
1080: CALL_OW 44
1084: PPUSH
1085: LD_VAR 0 6
1089: PPUSH
1090: CALL_OW 52
// end ;
1094: GO 1058
1096: POP
1097: POP
// uc_nation := 0 ;
1098: LD_ADDR_OWVAR 21
1102: PUSH
1103: LD_INT 0
1105: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) do
1106: LD_ADDR_VAR 0 2
1110: PUSH
1111: LD_INT 22
1113: PUSH
1114: LD_INT 8
1116: PUSH
1117: EMPTY
1118: LIST
1119: LIST
1120: PUSH
1121: LD_INT 30
1123: PUSH
1124: LD_INT 32
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: PPUSH
1135: CALL_OW 69
1139: PUSH
1140: FOR_IN
1141: IFFALSE 1178
// begin PrepareHuman ( false , class_apeman_soldier , skill + 1 ) ;
1143: LD_INT 0
1145: PPUSH
1146: LD_INT 15
1148: PPUSH
1149: LD_VAR 0 4
1153: PUSH
1154: LD_INT 1
1156: PLUS
1157: PPUSH
1158: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
1162: CALL_OW 44
1166: PPUSH
1167: LD_VAR 0 2
1171: PPUSH
1172: CALL_OW 52
// end ;
1176: GO 1140
1178: POP
1179: POP
// for i = 1 to 2 do
1180: LD_ADDR_VAR 0 2
1184: PUSH
1185: DOUBLE
1186: LD_INT 1
1188: DEC
1189: ST_TO_ADDR
1190: LD_INT 2
1192: PUSH
1193: FOR_TO
1194: IFFALSE 1219
// AddComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
1196: LD_VAR 0 6
1200: PPUSH
1201: LD_INT 14
1203: PPUSH
1204: LD_INT 2
1206: PPUSH
1207: LD_INT 1
1209: PPUSH
1210: LD_INT 31
1212: PPUSH
1213: CALL_OW 185
1217: GO 1193
1219: POP
1220: POP
// end ;
1221: LD_VAR 0 1
1225: RET
// export function PrepareHovercraft ( num ) ; var i ; begin
1226: LD_INT 0
1228: PPUSH
1229: PPUSH
// for i = 1 to num do
1230: LD_ADDR_VAR 0 3
1234: PUSH
1235: DOUBLE
1236: LD_INT 1
1238: DEC
1239: ST_TO_ADDR
1240: LD_VAR 0 1
1244: PUSH
1245: FOR_TO
1246: IFFALSE 1318
// AddComConstruct ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] , ar_hovercraft , engine_combustion , control_remote , [ ar_light_gun , ar_double_machine_gun ] [ rand ( 1 , 2 ) ] ) ;
1248: LD_INT 22
1250: PUSH
1251: LD_INT 8
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: PUSH
1277: LD_INT 1
1279: ARRAY
1280: PPUSH
1281: LD_INT 11
1283: PPUSH
1284: LD_INT 1
1286: PPUSH
1287: LD_INT 2
1289: PPUSH
1290: LD_INT 23
1292: PUSH
1293: LD_INT 24
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: LD_INT 1
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: CALL_OW 12
1310: ARRAY
1311: PPUSH
1312: CALL_OW 185
1316: GO 1245
1318: POP
1319: POP
// end ;
1320: LD_VAR 0 2
1324: RET
// export function AddKamikaze ( ) ; var i , un ; begin
1325: LD_INT 0
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side := 8 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 8
1337: ST_TO_ADDR
// uc_nation := 0 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 0
1345: ST_TO_ADDR
// hc_class := 17 ;
1346: LD_ADDR_OWVAR 28
1350: PUSH
1351: LD_INT 17
1353: ST_TO_ADDR
// hc_gallery :=  ;
1354: LD_ADDR_OWVAR 33
1358: PUSH
1359: LD_STRING 
1361: ST_TO_ADDR
// hc_name :=  ;
1362: LD_ADDR_OWVAR 26
1366: PUSH
1367: LD_STRING 
1369: ST_TO_ADDR
// hc_importance := 0 ;
1370: LD_ADDR_OWVAR 32
1374: PUSH
1375: LD_INT 0
1377: ST_TO_ADDR
// hc_skills := [ 10 , 10 , 10 , 10 ] ;
1378: LD_ADDR_OWVAR 31
1382: PUSH
1383: LD_INT 10
1385: PUSH
1386: LD_INT 10
1388: PUSH
1389: LD_INT 10
1391: PUSH
1392: LD_INT 10
1394: PUSH
1395: EMPTY
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: ST_TO_ADDR
// if ar_base then
1401: LD_INT 57
1403: IFFALSE 1448
// begin un := CreateHuman ;
1405: LD_ADDR_VAR 0 3
1409: PUSH
1410: CALL_OW 44
1414: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_base ) ;
1415: LD_VAR 0 3
1419: PPUSH
1420: LD_INT 57
1422: PPUSH
1423: CALL_OW 52
// ComExitBuilding ( un ) ;
1427: LD_VAR 0 3
1431: PPUSH
1432: CALL_OW 122
// AddComEnterUnit ( un , legion_telep ) ;
1436: LD_VAR 0 3
1440: PPUSH
1441: LD_INT 68
1443: PPUSH
1444: CALL_OW 180
// end ; end ;
1448: LD_VAR 0 1
1452: RET
// export legion_force , l_allow_attack ; export function PrepareAttack ( n1 , n2 ) ; var i ; begin
1453: LD_INT 0
1455: PPUSH
1456: PPUSH
// legion_force := [ ] ;
1457: LD_ADDR_EXP 1
1461: PUSH
1462: EMPTY
1463: ST_TO_ADDR
// l_allow_attack := false ;
1464: LD_ADDR_EXP 2
1468: PUSH
1469: LD_INT 0
1471: ST_TO_ADDR
// PrepareHovercraft ( n1 ) ;
1472: LD_VAR 0 1
1476: PPUSH
1477: CALL 1226 0 1
// repeat wait ( 0 0$01 ) ;
1481: LD_INT 35
1483: PPUSH
1484: CALL_OW 67
// until legion_force = n1 ;
1488: LD_EXP 1
1492: PUSH
1493: LD_VAR 0 1
1497: EQUAL
1498: IFFALSE 1481
// l_allow_attack := true ;
1500: LD_ADDR_EXP 2
1504: PUSH
1505: LD_INT 1
1507: ST_TO_ADDR
// for i = 1 to legion_force do
1508: LD_ADDR_VAR 0 4
1512: PUSH
1513: DOUBLE
1514: LD_INT 1
1516: DEC
1517: ST_TO_ADDR
1518: LD_EXP 1
1522: PUSH
1523: FOR_TO
1524: IFFALSE 1546
// ComBrutalAttack ( legion_force [ i ] , 6 ) ;
1526: LD_EXP 1
1530: PUSH
1531: LD_VAR 0 4
1535: ARRAY
1536: PPUSH
1537: LD_INT 6
1539: PPUSH
1540: CALL 4038 0 2
1544: GO 1523
1546: POP
1547: POP
// wait ( 0 0$05 ) ;
1548: LD_INT 175
1550: PPUSH
1551: CALL_OW 67
// for i = 1 to n2 do
1555: LD_ADDR_VAR 0 4
1559: PUSH
1560: DOUBLE
1561: LD_INT 1
1563: DEC
1564: ST_TO_ADDR
1565: LD_VAR 0 2
1569: PUSH
1570: FOR_TO
1571: IFFALSE 1579
// begin AddKamikaze ( ) ;
1573: CALL 1325 0 0
// end ;
1577: GO 1570
1579: POP
1580: POP
// end ;
1581: LD_VAR 0 3
1585: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) > 1 do
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PUSH
1596: LD_INT 21
1598: PUSH
1599: LD_INT 3
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PPUSH
1610: CALL_OW 69
1614: PUSH
1615: LD_INT 1
1617: GREATER
1618: IFFALSE 1640
1620: GO 1622
1622: DISABLE
// begin wait ( 3 3$00 ) ;
1623: LD_INT 6300
1625: PPUSH
1626: CALL_OW 67
// PrepareAttack ( 4 , 2 ) ;
1630: LD_INT 4
1632: PPUSH
1633: LD_INT 2
1635: PPUSH
1636: CALL 1453 0 2
// end ;
1640: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
1641: LD_INT 22
1643: PUSH
1644: LD_INT 8
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: PUSH
1651: LD_INT 33
1653: PUSH
1654: LD_INT 2
1656: PUSH
1657: EMPTY
1658: LIST
1659: LIST
1660: PUSH
1661: EMPTY
1662: LIST
1663: LIST
1664: PPUSH
1665: CALL_OW 69
1669: IFFALSE 1881
1671: GO 1673
1673: DISABLE
1674: LD_INT 0
1676: PPUSH
1677: PPUSH
1678: PPUSH
1679: PPUSH
1680: PPUSH
1681: PPUSH
1682: PPUSH
// begin enable ;
1683: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
1684: LD_ADDR_VAR 0 4
1688: PUSH
1689: LD_INT 22
1691: PUSH
1692: LD_INT 8
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: PUSH
1699: LD_INT 33
1701: PUSH
1702: LD_INT 2
1704: PUSH
1705: EMPTY
1706: LIST
1707: LIST
1708: PUSH
1709: LD_INT 3
1711: PUSH
1712: LD_INT 61
1714: PUSH
1715: EMPTY
1716: LIST
1717: PUSH
1718: EMPTY
1719: LIST
1720: LIST
1721: PUSH
1722: EMPTY
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL_OW 69
1731: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ;
1732: LD_ADDR_VAR 0 3
1736: PUSH
1737: LD_INT 22
1739: PUSH
1740: LD_INT 8
1742: PUSH
1743: EMPTY
1744: LIST
1745: LIST
1746: PUSH
1747: LD_INT 34
1749: PUSH
1750: LD_INT 31
1752: PUSH
1753: EMPTY
1754: LIST
1755: LIST
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL_OW 69
1765: ST_TO_ADDR
// best := 10 ;
1766: LD_ADDR_VAR 0 5
1770: PUSH
1771: LD_INT 10
1773: ST_TO_ADDR
// best_mechanic := - 1 ;
1774: LD_ADDR_VAR 0 6
1778: PUSH
1779: LD_INT 1
1781: NEG
1782: ST_TO_ADDR
// if vehs then
1783: LD_VAR 0 4
1787: IFFALSE 1881
// begin for j in cts do
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: LD_VAR 0 3
1798: PUSH
1799: FOR_IN
1800: IFFALSE 1861
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
1802: LD_ADDR_VAR 0 7
1806: PUSH
1807: LD_VAR 0 2
1811: PPUSH
1812: CALL 3071 0 1
1816: PPUSH
1817: CALL_OW 432
1821: ST_TO_ADDR
// if p < best then
1822: LD_VAR 0 7
1826: PUSH
1827: LD_VAR 0 5
1831: LESS
1832: IFFALSE 1859
// begin best := p ;
1834: LD_ADDR_VAR 0 5
1838: PUSH
1839: LD_VAR 0 7
1843: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
1844: LD_ADDR_VAR 0 6
1848: PUSH
1849: LD_VAR 0 2
1853: PPUSH
1854: CALL 3071 0 1
1858: ST_TO_ADDR
// end ; end ;
1859: GO 1799
1861: POP
1862: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
1863: LD_VAR 0 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PPUSH
1872: LD_VAR 0 6
1876: PPUSH
1877: CALL_OW 135
// end ; end ; end_of_file
1881: PPOPN 7
1883: END
// export Davidov ; export function PrepareRussian ; var i , skill , un , tmp , amount , k ; begin
1884: LD_INT 0
1886: PPUSH
1887: PPUSH
1888: PPUSH
1889: PPUSH
1890: PPUSH
1891: PPUSH
1892: PPUSH
// uc_side := 6 ;
1893: LD_ADDR_OWVAR 20
1897: PUSH
1898: LD_INT 6
1900: ST_TO_ADDR
// uc_nation := nation_russian ;
1901: LD_ADDR_OWVAR 21
1905: PUSH
1906: LD_INT 3
1908: ST_TO_ADDR
// amount := [ [ 8 , 4 ] , [ 7 , 3 ] , [ 6 , 2 ] ] [ Difficulty ] ;
1909: LD_ADDR_VAR 0 6
1913: PUSH
1914: LD_INT 8
1916: PUSH
1917: LD_INT 4
1919: PUSH
1920: EMPTY
1921: LIST
1922: LIST
1923: PUSH
1924: LD_INT 7
1926: PUSH
1927: LD_INT 3
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: PUSH
1934: LD_INT 6
1936: PUSH
1937: LD_INT 2
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: PUSH
1944: EMPTY
1945: LIST
1946: LIST
1947: LIST
1948: PUSH
1949: LD_OWVAR 67
1953: ARRAY
1954: ST_TO_ADDR
// skill := [ 9 , 7 , 6 ] [ Difficulty ] ;
1955: LD_ADDR_VAR 0 3
1959: PUSH
1960: LD_INT 9
1962: PUSH
1963: LD_INT 7
1965: PUSH
1966: LD_INT 6
1968: PUSH
1969: EMPTY
1970: LIST
1971: LIST
1972: LIST
1973: PUSH
1974: LD_OWVAR 67
1978: ARRAY
1979: ST_TO_ADDR
// tmp := [ ] ;
1980: LD_ADDR_VAR 0 5
1984: PUSH
1985: EMPTY
1986: ST_TO_ADDR
// Davidov := NewCharacter ( Davidov ) ;
1987: LD_ADDR_EXP 3
1991: PUSH
1992: LD_STRING Davidov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// SetSkill ( Davidov , 1 , 7 ) ;
2000: LD_EXP 3
2004: PPUSH
2005: LD_INT 1
2007: PPUSH
2008: LD_INT 7
2010: PPUSH
2011: CALL_OW 237
// SetSkill ( Davidov , 2 , 8 ) ;
2015: LD_EXP 3
2019: PPUSH
2020: LD_INT 2
2022: PPUSH
2023: LD_INT 8
2025: PPUSH
2026: CALL_OW 237
// SetSkill ( Davidov , 3 , 6 ) ;
2030: LD_EXP 3
2034: PPUSH
2035: LD_INT 3
2037: PPUSH
2038: LD_INT 6
2040: PPUSH
2041: CALL_OW 237
// SetSkill ( Davidov , 4 , 10 ) ;
2045: LD_EXP 3
2049: PPUSH
2050: LD_INT 4
2052: PPUSH
2053: LD_INT 10
2055: PPUSH
2056: CALL_OW 237
// SetClass ( Davidov , 4 ) ;
2060: LD_EXP 3
2064: PPUSH
2065: LD_INT 4
2067: PPUSH
2068: CALL_OW 336
// hc_importance := 0 ;
2072: LD_ADDR_OWVAR 32
2076: PUSH
2077: LD_INT 0
2079: ST_TO_ADDR
// while amount [ 1 ] do
2080: LD_VAR 0 6
2084: PUSH
2085: LD_INT 1
2087: ARRAY
2088: IFFALSE 2421
// begin Wait ( 1 ) ;
2090: LD_INT 1
2092: PPUSH
2093: CALL_OW 67
// k := rand ( 2 , 4 ) ;
2097: LD_ADDR_VAR 0 7
2101: PUSH
2102: LD_INT 2
2104: PPUSH
2105: LD_INT 4
2107: PPUSH
2108: CALL_OW 12
2112: ST_TO_ADDR
// if amount [ 2 ] and tmp then
2113: LD_VAR 0 6
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: PUSH
2122: LD_VAR 0 5
2126: AND
2127: IFFALSE 2282
// begin if k in [ 1 , 2 ] then
2129: LD_VAR 0 7
2133: PUSH
2134: LD_INT 1
2136: PUSH
2137: LD_INT 2
2139: PUSH
2140: EMPTY
2141: LIST
2142: LIST
2143: IN
2144: IFFALSE 2154
// k := 3 ;
2146: LD_ADDR_VAR 0 7
2150: PUSH
2151: LD_INT 3
2153: ST_TO_ADDR
// vc_chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
2154: LD_ADDR_OWVAR 37
2158: PUSH
2159: LD_INT 22
2161: PUSH
2162: LD_INT 24
2164: PUSH
2165: EMPTY
2166: LIST
2167: LIST
2168: PUSH
2169: LD_INT 1
2171: PPUSH
2172: LD_INT 2
2174: PPUSH
2175: CALL_OW 12
2179: ARRAY
2180: ST_TO_ADDR
// vc_engine := engine_siberite ;
2181: LD_ADDR_OWVAR 39
2185: PUSH
2186: LD_INT 3
2188: ST_TO_ADDR
// vc_control := control_manual ;
2189: LD_ADDR_OWVAR 38
2193: PUSH
2194: LD_INT 1
2196: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_rocket_launcher , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ;
2197: LD_ADDR_OWVAR 40
2201: PUSH
2202: LD_INT 44
2204: PUSH
2205: LD_INT 45
2207: PUSH
2208: LD_INT 43
2210: PUSH
2211: EMPTY
2212: LIST
2213: LIST
2214: LIST
2215: PUSH
2216: LD_INT 1
2218: PPUSH
2219: LD_INT 3
2221: PPUSH
2222: CALL_OW 12
2226: ARRAY
2227: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , CreateVehicle ) ;
2228: LD_ADDR_VAR 0 5
2232: PUSH
2233: LD_VAR 0 5
2237: PPUSH
2238: LD_INT 1
2240: PPUSH
2241: CALL_OW 45
2245: PPUSH
2246: CALL_OW 2
2250: ST_TO_ADDR
// amount := Replace ( amount , 2 , amount [ 2 ] - 1 ) ;
2251: LD_ADDR_VAR 0 6
2255: PUSH
2256: LD_VAR 0 6
2260: PPUSH
2261: LD_INT 2
2263: PPUSH
2264: LD_VAR 0 6
2268: PUSH
2269: LD_INT 2
2271: ARRAY
2272: PUSH
2273: LD_INT 1
2275: MINUS
2276: PPUSH
2277: CALL_OW 1
2281: ST_TO_ADDR
// end ; if not tmp then
2282: LD_VAR 0 5
2286: NOT
2287: IFFALSE 2297
// k := 2 ;
2289: LD_ADDR_VAR 0 7
2293: PUSH
2294: LD_INT 2
2296: ST_TO_ADDR
// if amount [ 2 ] = 0 and k = 3 then
2297: LD_VAR 0 6
2301: PUSH
2302: LD_INT 2
2304: ARRAY
2305: PUSH
2306: LD_INT 0
2308: EQUAL
2309: PUSH
2310: LD_VAR 0 7
2314: PUSH
2315: LD_INT 3
2317: EQUAL
2318: AND
2319: IFFALSE 2348
// k := [ class_bazooker , class_scientistic ] [ rand ( 1 , 2 ) ] ;
2321: LD_ADDR_VAR 0 7
2325: PUSH
2326: LD_INT 9
2328: PUSH
2329: LD_INT 4
2331: PUSH
2332: EMPTY
2333: LIST
2334: LIST
2335: PUSH
2336: LD_INT 1
2338: PPUSH
2339: LD_INT 2
2341: PPUSH
2342: CALL_OW 12
2346: ARRAY
2347: ST_TO_ADDR
// PrepareHuman ( false , k , skill ) ;
2348: LD_INT 0
2350: PPUSH
2351: LD_VAR 0 7
2355: PPUSH
2356: LD_VAR 0 3
2360: PPUSH
2361: CALL_OW 380
// tmp := Insert ( tmp , 1 , CreateHuman ) ;
2365: LD_ADDR_VAR 0 5
2369: PUSH
2370: LD_VAR 0 5
2374: PPUSH
2375: LD_INT 1
2377: PPUSH
2378: CALL_OW 44
2382: PPUSH
2383: CALL_OW 2
2387: ST_TO_ADDR
// amount := Replace ( amount , 1 , amount [ 1 ] - 1 ) ;
2388: LD_ADDR_VAR 0 6
2392: PUSH
2393: LD_VAR 0 6
2397: PPUSH
2398: LD_INT 1
2400: PPUSH
2401: LD_VAR 0 6
2405: PUSH
2406: LD_INT 1
2408: ARRAY
2409: PUSH
2410: LD_INT 1
2412: MINUS
2413: PPUSH
2414: CALL_OW 1
2418: ST_TO_ADDR
// end ;
2419: GO 2080
// tmp := Insert ( tmp , tmp + 1 , Davidov ) ;
2421: LD_ADDR_VAR 0 5
2425: PUSH
2426: LD_VAR 0 5
2430: PPUSH
2431: LD_VAR 0 5
2435: PUSH
2436: LD_INT 1
2438: PLUS
2439: PPUSH
2440: LD_EXP 3
2444: PPUSH
2445: CALL_OW 2
2449: ST_TO_ADDR
// for i = tmp downto 1 do
2450: LD_ADDR_VAR 0 2
2454: PUSH
2455: DOUBLE
2456: LD_VAR 0 5
2460: INC
2461: ST_TO_ADDR
2462: LD_INT 1
2464: PUSH
2465: FOR_DOWNTO
2466: IFFALSE 2628
// begin if GetType ( tmp [ i ] ) = unit_vehicle then
2468: LD_VAR 0 5
2472: PUSH
2473: LD_VAR 0 2
2477: ARRAY
2478: PPUSH
2479: CALL_OW 247
2483: PUSH
2484: LD_INT 2
2486: EQUAL
2487: IFFALSE 2577
// begin SetDir ( tmp [ i ] , 3 ) ;
2489: LD_VAR 0 5
2493: PUSH
2494: LD_VAR 0 2
2498: ARRAY
2499: PPUSH
2500: LD_INT 3
2502: PPUSH
2503: CALL_OW 233
// PlaceUnitXY ( tmp [ i ] , 193 , 3 , false ) ;
2507: LD_VAR 0 5
2511: PUSH
2512: LD_VAR 0 2
2516: ARRAY
2517: PPUSH
2518: LD_INT 193
2520: PPUSH
2521: LD_INT 3
2523: PPUSH
2524: LD_INT 0
2526: PPUSH
2527: CALL_OW 48
// PlaceHumanInUnit ( tmp [ i - 1 ] , tmp [ i ] ) ;
2531: LD_VAR 0 5
2535: PUSH
2536: LD_VAR 0 2
2540: PUSH
2541: LD_INT 1
2543: MINUS
2544: ARRAY
2545: PPUSH
2546: LD_VAR 0 5
2550: PUSH
2551: LD_VAR 0 2
2555: ARRAY
2556: PPUSH
2557: CALL_OW 52
// i := i - 1 ;
2561: LD_ADDR_VAR 0 2
2565: PUSH
2566: LD_VAR 0 2
2570: PUSH
2571: LD_INT 1
2573: MINUS
2574: ST_TO_ADDR
// end else
2575: GO 2598
// PlaceUnitArea ( tmp [ i ] , start_area , false ) ;
2577: LD_VAR 0 5
2581: PUSH
2582: LD_VAR 0 2
2586: ARRAY
2587: PPUSH
2588: LD_INT 2
2590: PPUSH
2591: LD_INT 0
2593: PPUSH
2594: CALL_OW 49
// ComMoveXY ( tmp [ i ] , 197 , 22 ) ;
2598: LD_VAR 0 5
2602: PUSH
2603: LD_VAR 0 2
2607: ARRAY
2608: PPUSH
2609: LD_INT 197
2611: PPUSH
2612: LD_INT 22
2614: PPUSH
2615: CALL_OW 111
// Wait ( 0 0$02 ) ;
2619: LD_INT 70
2621: PPUSH
2622: CALL_OW 67
// end ;
2626: GO 2465
2628: POP
2629: POP
// end ; end_of_file
2630: LD_VAR 0 1
2634: RET
// on VehicleConstructed ( veh , fac ) do var side ;
2635: LD_INT 0
2637: PPUSH
// begin side := GetSide ( fac ) ;
2638: LD_ADDR_VAR 0 3
2642: PUSH
2643: LD_VAR 0 2
2647: PPUSH
2648: CALL_OW 255
2652: ST_TO_ADDR
// case side of 8 :
2653: LD_VAR 0 3
2657: PUSH
2658: LD_INT 8
2660: DOUBLE
2661: EQUAL
2662: IFTRUE 2666
2664: GO 2737
2666: POP
// begin if GetWeapon ( veh ) = ar_control_tower then
2667: LD_VAR 0 1
2671: PPUSH
2672: CALL_OW 264
2676: PUSH
2677: LD_INT 31
2679: EQUAL
2680: IFFALSE 2697
// ComMoveXY ( veh , 145 , 66 ) ;
2682: LD_VAR 0 1
2686: PPUSH
2687: LD_INT 145
2689: PPUSH
2690: LD_INT 66
2692: PPUSH
2693: CALL_OW 111
// if GetChassis ( veh ) = ar_hovercraft then
2697: LD_VAR 0 1
2701: PPUSH
2702: CALL_OW 265
2706: PUSH
2707: LD_INT 11
2709: EQUAL
2710: IFFALSE 2735
// legion_force := Insert ( legion_force , 1 , veh ) ;
2712: LD_ADDR_EXP 1
2716: PUSH
2717: LD_EXP 1
2721: PPUSH
2722: LD_INT 1
2724: PPUSH
2725: LD_VAR 0 1
2729: PPUSH
2730: CALL_OW 2
2734: ST_TO_ADDR
// end ; end ;
2735: GO 2738
2737: POP
// end ;
2738: PPOPN 3
2740: END
// on UnitTeleported ( b , un ) do begin if b = legion_telep and GetClass ( un ) = 17 then
2741: LD_VAR 0 1
2745: PUSH
2746: LD_INT 68
2748: EQUAL
2749: PUSH
2750: LD_VAR 0 2
2754: PPUSH
2755: CALL_OW 257
2759: PUSH
2760: LD_INT 17
2762: EQUAL
2763: AND
2764: IFFALSE 2807
// begin Wait ( 0 0$03 ) ;
2766: LD_INT 105
2768: PPUSH
2769: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , un ) ) ;
2773: LD_VAR 0 2
2777: PPUSH
2778: LD_INT 22
2780: PUSH
2781: LD_INT 6
2783: PUSH
2784: EMPTY
2785: LIST
2786: LIST
2787: PPUSH
2788: CALL_OW 69
2792: PPUSH
2793: LD_VAR 0 2
2797: PPUSH
2798: CALL_OW 74
2802: PPUSH
2803: CALL_OW 115
// end ; end ;
2807: PPOPN 2
2809: END
// on CrateSpawn ( id , x , y , amount , mode ) do var i , apes , n ;
2810: LD_INT 0
2812: PPUSH
2813: PPUSH
2814: PPUSH
// begin if InArea ( x , y , cratesArea ) then
2815: LD_VAR 0 2
2819: PPUSH
2820: LD_VAR 0 3
2824: PPUSH
2825: LD_INT 3
2827: PPUSH
2828: CALL_OW 309
2832: IFFALSE 3041
// begin apes := FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 16 ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_hastask ] ] ] ) ;
2834: LD_ADDR_VAR 0 7
2838: PUSH
2839: LD_INT 22
2841: PUSH
2842: LD_INT 6
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: PUSH
2849: LD_INT 25
2851: PUSH
2852: LD_INT 16
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: LD_INT 3
2861: PUSH
2862: LD_INT 54
2864: PUSH
2865: EMPTY
2866: LIST
2867: PUSH
2868: EMPTY
2869: LIST
2870: LIST
2871: PUSH
2872: LD_INT 3
2874: PUSH
2875: LD_INT 60
2877: PUSH
2878: EMPTY
2879: LIST
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: LIST
2889: LIST
2890: PPUSH
2891: CALL_OW 69
2895: ST_TO_ADDR
// if apes = 0 or FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 then
2896: LD_VAR 0 7
2900: PUSH
2901: LD_INT 0
2903: EQUAL
2904: PUSH
2905: LD_INT 22
2907: PUSH
2908: LD_INT 6
2910: PUSH
2911: EMPTY
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 2
2917: PUSH
2918: LD_INT 30
2920: PUSH
2921: LD_INT 0
2923: PUSH
2924: EMPTY
2925: LIST
2926: LIST
2927: PUSH
2928: LD_INT 30
2930: PUSH
2931: LD_INT 1
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: LIST
2942: PUSH
2943: EMPTY
2944: LIST
2945: LIST
2946: PPUSH
2947: CALL_OW 69
2951: PUSH
2952: LD_INT 0
2954: EQUAL
2955: OR
2956: IFFALSE 2960
// exit ;
2958: GO 3041
// if apes < amount then
2960: LD_VAR 0 7
2964: PUSH
2965: LD_VAR 0 4
2969: LESS
2970: IFFALSE 2984
// n := apes else
2972: LD_ADDR_VAR 0 8
2976: PUSH
2977: LD_VAR 0 7
2981: ST_TO_ADDR
2982: GO 2994
// n := amount ;
2984: LD_ADDR_VAR 0 8
2988: PUSH
2989: LD_VAR 0 4
2993: ST_TO_ADDR
// for i = 1 to n do
2994: LD_ADDR_VAR 0 6
2998: PUSH
2999: DOUBLE
3000: LD_INT 1
3002: DEC
3003: ST_TO_ADDR
3004: LD_VAR 0 8
3008: PUSH
3009: FOR_TO
3010: IFFALSE 3039
// AddComCollect ( apes [ i ] , x , y ) ;
3012: LD_VAR 0 7
3016: PUSH
3017: LD_VAR 0 6
3021: ARRAY
3022: PPUSH
3023: LD_VAR 0 2
3027: PPUSH
3028: LD_VAR 0 3
3032: PPUSH
3033: CALL_OW 177
3037: GO 3009
3039: POP
3040: POP
// end ; end ;
3041: PPOPN 8
3043: END
// on UnitGoesToRed ( un ) do begin if GetControl ( un ) = control_remote then
3044: LD_VAR 0 1
3048: PPUSH
3049: CALL_OW 263
3053: PUSH
3054: LD_INT 2
3056: EQUAL
3057: IFFALSE 3068
// ComUnlink ( un ) ;
3059: LD_VAR 0 1
3063: PPUSH
3064: CALL_OW 136
// end ; end_of_file
3068: PPOPN 1
3070: END
// export function GetDriver ( veh ) ; var i , filter ; begin
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
3075: PPUSH
// if not GetControl ( veh ) = control_manual then
3076: LD_VAR 0 1
3080: PPUSH
3081: CALL_OW 263
3085: PUSH
3086: LD_INT 1
3088: EQUAL
3089: NOT
3090: IFFALSE 3102
// result := false else
3092: LD_ADDR_VAR 0 2
3096: PUSH
3097: LD_INT 0
3099: ST_TO_ADDR
3100: GO 3247
// if veh in FilterAllUnits ( [ f_empty ] ) then
3102: LD_VAR 0 1
3106: PUSH
3107: LD_INT 58
3109: PUSH
3110: EMPTY
3111: LIST
3112: PPUSH
3113: CALL_OW 69
3117: IN
3118: IFFALSE 3130
// result := false else
3120: LD_ADDR_VAR 0 2
3124: PUSH
3125: LD_INT 0
3127: ST_TO_ADDR
3128: GO 3247
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3130: LD_ADDR_VAR 0 4
3134: PUSH
3135: LD_INT 22
3137: PUSH
3138: LD_VAR 0 1
3142: PPUSH
3143: CALL_OW 255
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: PUSH
3152: LD_INT 55
3154: PUSH
3155: EMPTY
3156: LIST
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: PPUSH
3162: CALL_OW 69
3166: ST_TO_ADDR
// if not filter then
3167: LD_VAR 0 4
3171: NOT
3172: IFFALSE 3184
// result := false else
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: LD_INT 0
3181: ST_TO_ADDR
3182: GO 3247
// for i = 1 to filter do
3184: LD_ADDR_VAR 0 3
3188: PUSH
3189: DOUBLE
3190: LD_INT 1
3192: DEC
3193: ST_TO_ADDR
3194: LD_VAR 0 4
3198: PUSH
3199: FOR_TO
3200: IFFALSE 3245
// if IsDriver ( filter [ i ] ) = veh then
3202: LD_VAR 0 4
3206: PUSH
3207: LD_VAR 0 3
3211: ARRAY
3212: PPUSH
3213: CALL 3252 0 1
3217: PUSH
3218: LD_VAR 0 1
3222: EQUAL
3223: IFFALSE 3243
// begin result := filter [ i ] ;
3225: LD_ADDR_VAR 0 2
3229: PUSH
3230: LD_VAR 0 4
3234: PUSH
3235: LD_VAR 0 3
3239: ARRAY
3240: ST_TO_ADDR
// break ;
3241: GO 3245
// end ;
3243: GO 3199
3245: POP
3246: POP
// end ; end ;
3247: LD_VAR 0 2
3251: RET
// export function IsDriver ( unit ) ; begin
3252: LD_INT 0
3254: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3255: LD_VAR 0 1
3259: PUSH
3260: LD_INT 55
3262: PUSH
3263: EMPTY
3264: LIST
3265: PPUSH
3266: CALL_OW 69
3270: IN
3271: IFFALSE 3290
// result := IsInUnit ( unit ) else
3273: LD_ADDR_VAR 0 2
3277: PUSH
3278: LD_VAR 0 1
3282: PPUSH
3283: CALL_OW 310
3287: ST_TO_ADDR
3288: GO 3298
// result := false ;
3290: LD_ADDR_VAR 0 2
3294: PUSH
3295: LD_INT 0
3297: ST_TO_ADDR
// end ;
3298: LD_VAR 0 2
3302: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
3303: LD_INT 0
3305: PPUSH
3306: PPUSH
3307: PPUSH
3308: PPUSH
// if pos < 1 then
3309: LD_VAR 0 2
3313: PUSH
3314: LD_INT 1
3316: LESS
3317: IFFALSE 3321
// exit ;
3319: GO 3624
// if pos = 1 then
3321: LD_VAR 0 2
3325: PUSH
3326: LD_INT 1
3328: EQUAL
3329: IFFALSE 3362
// result := Replace ( arr , pos [ 1 ] , value ) else
3331: LD_ADDR_VAR 0 4
3335: PUSH
3336: LD_VAR 0 1
3340: PPUSH
3341: LD_VAR 0 2
3345: PUSH
3346: LD_INT 1
3348: ARRAY
3349: PPUSH
3350: LD_VAR 0 3
3354: PPUSH
3355: CALL_OW 1
3359: ST_TO_ADDR
3360: GO 3624
// begin tmp := arr ;
3362: LD_ADDR_VAR 0 6
3366: PUSH
3367: LD_VAR 0 1
3371: ST_TO_ADDR
// s_arr := [ tmp ] ;
3372: LD_ADDR_VAR 0 7
3376: PUSH
3377: LD_VAR 0 6
3381: PUSH
3382: EMPTY
3383: LIST
3384: ST_TO_ADDR
// for i = 1 to pos - 1 do
3385: LD_ADDR_VAR 0 5
3389: PUSH
3390: DOUBLE
3391: LD_INT 1
3393: DEC
3394: ST_TO_ADDR
3395: LD_VAR 0 2
3399: PUSH
3400: LD_INT 1
3402: MINUS
3403: PUSH
3404: FOR_TO
3405: IFFALSE 3450
// begin tmp := tmp [ pos [ i ] ] ;
3407: LD_ADDR_VAR 0 6
3411: PUSH
3412: LD_VAR 0 6
3416: PUSH
3417: LD_VAR 0 2
3421: PUSH
3422: LD_VAR 0 5
3426: ARRAY
3427: ARRAY
3428: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
3429: LD_ADDR_VAR 0 7
3433: PUSH
3434: LD_VAR 0 7
3438: PUSH
3439: LD_VAR 0 6
3443: PUSH
3444: EMPTY
3445: LIST
3446: ADD
3447: ST_TO_ADDR
// end ;
3448: GO 3404
3450: POP
3451: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PPUSH
3462: LD_VAR 0 2
3466: PUSH
3467: LD_VAR 0 2
3471: ARRAY
3472: PPUSH
3473: LD_VAR 0 3
3477: PPUSH
3478: CALL_OW 1
3482: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
3483: LD_ADDR_VAR 0 7
3487: PUSH
3488: LD_VAR 0 7
3492: PPUSH
3493: LD_VAR 0 7
3497: PPUSH
3498: LD_VAR 0 6
3502: PPUSH
3503: CALL_OW 1
3507: ST_TO_ADDR
// for i = s_arr downto 2 do
3508: LD_ADDR_VAR 0 5
3512: PUSH
3513: DOUBLE
3514: LD_VAR 0 7
3518: INC
3519: ST_TO_ADDR
3520: LD_INT 2
3522: PUSH
3523: FOR_DOWNTO
3524: IFFALSE 3608
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
3526: LD_ADDR_VAR 0 6
3530: PUSH
3531: LD_VAR 0 7
3535: PUSH
3536: LD_VAR 0 5
3540: PUSH
3541: LD_INT 1
3543: MINUS
3544: ARRAY
3545: PPUSH
3546: LD_VAR 0 2
3550: PUSH
3551: LD_VAR 0 5
3555: PUSH
3556: LD_INT 1
3558: MINUS
3559: ARRAY
3560: PPUSH
3561: LD_VAR 0 7
3565: PUSH
3566: LD_VAR 0 5
3570: ARRAY
3571: PPUSH
3572: CALL_OW 1
3576: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
3577: LD_ADDR_VAR 0 7
3581: PUSH
3582: LD_VAR 0 7
3586: PPUSH
3587: LD_VAR 0 5
3591: PUSH
3592: LD_INT 1
3594: MINUS
3595: PPUSH
3596: LD_VAR 0 6
3600: PPUSH
3601: CALL_OW 1
3605: ST_TO_ADDR
// end ;
3606: GO 3523
3608: POP
3609: POP
// result := s_arr [ 1 ] ;
3610: LD_ADDR_VAR 0 4
3614: PUSH
3615: LD_VAR 0 7
3619: PUSH
3620: LD_INT 1
3622: ARRAY
3623: ST_TO_ADDR
// end ; end ;
3624: LD_VAR 0 4
3628: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
3629: LD_VAR 0 1
3633: PUSH
3634: LD_EXP 4
3638: IN
3639: NOT
3640: IFFALSE 3671
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
3642: LD_ADDR_EXP 4
3646: PUSH
3647: LD_EXP 4
3651: PPUSH
3652: LD_EXP 4
3656: PUSH
3657: LD_INT 1
3659: PLUS
3660: PPUSH
3661: LD_VAR 0 1
3665: PPUSH
3666: CALL_OW 2
3670: ST_TO_ADDR
// end ;
3671: PPOPN 1
3673: END
// export function DestinationReachable ( unit , x , y ) ; begin
3674: LD_INT 0
3676: PPUSH
// if unit in unreachableList then
3677: LD_VAR 0 1
3681: PUSH
3682: LD_EXP 4
3686: IN
3687: IFFALSE 3705
// unreachableList := unreachableList diff unit ;
3689: LD_ADDR_EXP 4
3693: PUSH
3694: LD_EXP 4
3698: PUSH
3699: LD_VAR 0 1
3703: DIFF
3704: ST_TO_ADDR
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
3705: LD_VAR 0 1
3709: PPUSH
3710: LD_VAR 0 2
3714: PPUSH
3715: LD_VAR 0 3
3719: PPUSH
3720: CALL_OW 428
3724: PPUSH
3725: CALL_OW 115
// Wait ( 1 ) ;
3729: LD_INT 1
3731: PPUSH
3732: CALL_OW 67
// if unit in unreachableList then
3736: LD_VAR 0 1
3740: PUSH
3741: LD_EXP 4
3745: IN
3746: IFFALSE 3758
// result := false else
3748: LD_ADDR_VAR 0 4
3752: PUSH
3753: LD_INT 0
3755: ST_TO_ADDR
3756: GO 3766
// result := true ;
3758: LD_ADDR_VAR 0 4
3762: PUSH
3763: LD_INT 1
3765: ST_TO_ADDR
// end ;
3766: LD_VAR 0 4
3770: RET
// export function ComBombAttack ( unit , side ) ; var i , enemy , t , x , y , change_target_counter , last_target ; begin
3771: LD_INT 0
3773: PPUSH
3774: PPUSH
3775: PPUSH
3776: PPUSH
3777: PPUSH
3778: PPUSH
3779: PPUSH
3780: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
3781: LD_ADDR_VAR 0 5
3785: PUSH
3786: LD_INT 22
3788: PUSH
3789: LD_VAR 0 2
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PPUSH
3798: CALL_OW 69
3802: ST_TO_ADDR
// change_target_counter := 0 ;
3803: LD_ADDR_VAR 0 9
3807: PUSH
3808: LD_INT 0
3810: ST_TO_ADDR
// last_target := 0 ;
3811: LD_ADDR_VAR 0 10
3815: PUSH
3816: LD_INT 0
3818: ST_TO_ADDR
// if not enemy then
3819: LD_VAR 0 5
3823: NOT
3824: IFFALSE 3828
// exit ;
3826: GO 4033
// while ( IsLive ( unit ) and change_target_counter < 4 ) do
3828: LD_VAR 0 1
3832: PPUSH
3833: CALL_OW 300
3837: PUSH
3838: LD_VAR 0 9
3842: PUSH
3843: LD_INT 4
3845: LESS
3846: AND
3847: IFFALSE 4033
// begin if UnitFilter ( enemy , [ f_occupied ] ) then
3849: LD_VAR 0 5
3853: PPUSH
3854: LD_INT 59
3856: PUSH
3857: EMPTY
3858: LIST
3859: PPUSH
3860: CALL_OW 72
3864: IFFALSE 4000
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
3866: LD_ADDR_VAR 0 6
3870: PUSH
3871: LD_VAR 0 5
3875: PPUSH
3876: LD_INT 59
3878: PUSH
3879: EMPTY
3880: LIST
3881: PPUSH
3882: CALL_OW 72
3886: PPUSH
3887: LD_VAR 0 1
3891: PPUSH
3892: CALL_OW 74
3896: ST_TO_ADDR
// if ( last_target <> t ) then
3897: LD_VAR 0 10
3901: PUSH
3902: LD_VAR 0 6
3906: NONEQUAL
3907: IFFALSE 3923
// change_target_counter := change_target_counter + 1 ;
3909: LD_ADDR_VAR 0 9
3913: PUSH
3914: LD_VAR 0 9
3918: PUSH
3919: LD_INT 1
3921: PLUS
3922: ST_TO_ADDR
// last_target := t ;
3923: LD_ADDR_VAR 0 10
3927: PUSH
3928: LD_VAR 0 6
3932: ST_TO_ADDR
// x := GetX ( t ) ;
3933: LD_ADDR_VAR 0 7
3937: PUSH
3938: LD_VAR 0 6
3942: PPUSH
3943: CALL_OW 250
3947: ST_TO_ADDR
// y := GetY ( t ) ;
3948: LD_ADDR_VAR 0 8
3952: PUSH
3953: LD_VAR 0 6
3957: PPUSH
3958: CALL_OW 251
3962: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
3963: LD_VAR 0 1
3967: PPUSH
3968: LD_VAR 0 7
3972: PPUSH
3973: LD_VAR 0 8
3977: PPUSH
3978: CALL 3674 0 3
3982: IFFALSE 3998
// ComAttackUnit ( unit , t ) ;
3984: LD_VAR 0 1
3988: PPUSH
3989: LD_VAR 0 6
3993: PPUSH
3994: CALL_OW 115
// end else
3998: GO 4024
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
4000: LD_VAR 0 1
4004: PPUSH
4005: LD_VAR 0 5
4009: PPUSH
4010: LD_VAR 0 1
4014: PPUSH
4015: CALL_OW 74
4019: PPUSH
4020: CALL_OW 115
// Wait ( 0 0$0.3 ) ;
4024: LD_INT 10
4026: PPUSH
4027: CALL_OW 67
// end ;
4031: GO 3828
// end ;
4033: LD_VAR 0 3
4037: RET
// export function ComBrutalAttack ( unit , side ) ; var i , enemy , t , x , y , target ; begin
4038: LD_INT 0
4040: PPUSH
4041: PPUSH
4042: PPUSH
4043: PPUSH
4044: PPUSH
4045: PPUSH
4046: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
4047: LD_ADDR_VAR 0 5
4051: PUSH
4052: LD_INT 22
4054: PUSH
4055: LD_VAR 0 2
4059: PUSH
4060: EMPTY
4061: LIST
4062: LIST
4063: PPUSH
4064: CALL_OW 69
4068: ST_TO_ADDR
// target := 0 ;
4069: LD_ADDR_VAR 0 9
4073: PUSH
4074: LD_INT 0
4076: ST_TO_ADDR
// if not enemy then
4077: LD_VAR 0 5
4081: NOT
4082: IFFALSE 4086
// exit ;
4084: GO 4529
// if UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) then
4086: LD_VAR 0 5
4090: PPUSH
4091: LD_INT 21
4093: PUSH
4094: LD_INT 1
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PUSH
4101: LD_INT 3
4103: PUSH
4104: LD_INT 54
4106: PUSH
4107: EMPTY
4108: LIST
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: PPUSH
4118: CALL_OW 72
4122: IFFALSE 4348
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , unit ) ;
4124: LD_ADDR_VAR 0 6
4128: PUSH
4129: LD_VAR 0 5
4133: PPUSH
4134: LD_INT 21
4136: PUSH
4137: LD_INT 1
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: PUSH
4144: LD_INT 3
4146: PUSH
4147: LD_INT 54
4149: PUSH
4150: EMPTY
4151: LIST
4152: PUSH
4153: EMPTY
4154: LIST
4155: LIST
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: PPUSH
4161: CALL_OW 72
4165: PPUSH
4166: LD_VAR 0 1
4170: PPUSH
4171: CALL_OW 74
4175: ST_TO_ADDR
// x := GetX ( t ) ;
4176: LD_ADDR_VAR 0 7
4180: PUSH
4181: LD_VAR 0 6
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// y := GetY ( t ) ;
4191: LD_ADDR_VAR 0 8
4195: PUSH
4196: LD_VAR 0 6
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
4206: LD_VAR 0 1
4210: PPUSH
4211: LD_VAR 0 7
4215: PPUSH
4216: LD_VAR 0 8
4220: PPUSH
4221: CALL 3674 0 3
4225: IFFALSE 4239
// target := t else
4227: LD_ADDR_VAR 0 9
4231: PUSH
4232: LD_VAR 0 6
4236: ST_TO_ADDR
4237: GO 4348
// if UnitFilter ( enemy , [ f_occupied ] ) then
4239: LD_VAR 0 5
4243: PPUSH
4244: LD_INT 59
4246: PUSH
4247: EMPTY
4248: LIST
4249: PPUSH
4250: CALL_OW 72
4254: IFFALSE 4348
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
4256: LD_ADDR_VAR 0 6
4260: PUSH
4261: LD_VAR 0 5
4265: PPUSH
4266: LD_INT 59
4268: PUSH
4269: EMPTY
4270: LIST
4271: PPUSH
4272: CALL_OW 72
4276: PPUSH
4277: LD_VAR 0 1
4281: PPUSH
4282: CALL_OW 74
4286: ST_TO_ADDR
// x := GetX ( t ) ;
4287: LD_ADDR_VAR 0 7
4291: PUSH
4292: LD_VAR 0 6
4296: PPUSH
4297: CALL_OW 250
4301: ST_TO_ADDR
// y := GetY ( t ) ;
4302: LD_ADDR_VAR 0 8
4306: PUSH
4307: LD_VAR 0 6
4311: PPUSH
4312: CALL_OW 251
4316: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
4317: LD_VAR 0 1
4321: PPUSH
4322: LD_VAR 0 7
4326: PPUSH
4327: LD_VAR 0 8
4331: PPUSH
4332: CALL 3674 0 3
4336: IFFALSE 4348
// target := t ;
4338: LD_ADDR_VAR 0 9
4342: PUSH
4343: LD_VAR 0 6
4347: ST_TO_ADDR
// end ; end ; if not target then
4348: LD_VAR 0 9
4352: NOT
4353: IFFALSE 4375
// target := NearestUnitToUnit ( enemy , unit ) ;
4355: LD_ADDR_VAR 0 9
4359: PUSH
4360: LD_VAR 0 5
4364: PPUSH
4365: LD_VAR 0 1
4369: PPUSH
4370: CALL_OW 74
4374: ST_TO_ADDR
// while ( IsLive ( unit ) and target ) do
4375: LD_VAR 0 1
4379: PPUSH
4380: CALL_OW 300
4384: PUSH
4385: LD_VAR 0 9
4389: AND
4390: IFFALSE 4529
// begin if ( GetDistUnits ( target , unit ) < 4 and GetLives ( unit ) < 600 ) or GetLives ( unit ) < 200 then
4392: LD_VAR 0 9
4396: PPUSH
4397: LD_VAR 0 1
4401: PPUSH
4402: CALL_OW 296
4406: PUSH
4407: LD_INT 4
4409: LESS
4410: PUSH
4411: LD_VAR 0 1
4415: PPUSH
4416: CALL_OW 256
4420: PUSH
4421: LD_INT 600
4423: LESS
4424: AND
4425: PUSH
4426: LD_VAR 0 1
4430: PPUSH
4431: CALL_OW 256
4435: PUSH
4436: LD_INT 200
4438: LESS
4439: OR
4440: IFFALSE 4491
// begin for i = 1 to 4 do
4442: LD_ADDR_VAR 0 4
4446: PUSH
4447: DOUBLE
4448: LD_INT 1
4450: DEC
4451: ST_TO_ADDR
4452: LD_INT 4
4454: PUSH
4455: FOR_TO
4456: IFFALSE 4487
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
4458: LD_VAR 0 1
4462: PPUSH
4463: CALL_OW 250
4467: PPUSH
4468: LD_VAR 0 1
4472: PPUSH
4473: CALL_OW 251
4477: PPUSH
4478: LD_INT 1
4480: PPUSH
4481: CALL_OW 453
4485: GO 4455
4487: POP
4488: POP
// end else
4489: GO 4520
// ComMoveXY ( unit , GetX ( target ) , GetY ( target ) ) ;
4491: LD_VAR 0 1
4495: PPUSH
4496: LD_VAR 0 9
4500: PPUSH
4501: CALL_OW 250
4505: PPUSH
4506: LD_VAR 0 9
4510: PPUSH
4511: CALL_OW 251
4515: PPUSH
4516: CALL_OW 111
// Wait ( 0 0$0.3 ) ;
4520: LD_INT 10
4522: PPUSH
4523: CALL_OW 67
// end ;
4527: GO 4375
// end ; end_of_file
4529: LD_VAR 0 3
4533: RET
// export function Action ; var dial ; begin
4534: LD_INT 0
4536: PPUSH
4537: PPUSH
// CenterNowOnXY ( 192 , 1 ) ;
4538: LD_INT 192
4540: PPUSH
4541: LD_INT 1
4543: PPUSH
4544: CALL_OW 86
// InGameOn ;
4548: CALL_OW 8
// case query ( textdiff ) of 1 :
4552: LD_STRING textdiff
4554: PPUSH
4555: CALL_OW 97
4559: PUSH
4560: LD_INT 1
4562: DOUBLE
4563: EQUAL
4564: IFTRUE 4568
4566: GO 4579
4568: POP
// Difficulty := 1 ; 2 :
4569: LD_ADDR_OWVAR 67
4573: PUSH
4574: LD_INT 1
4576: ST_TO_ADDR
4577: GO 4618
4579: LD_INT 2
4581: DOUBLE
4582: EQUAL
4583: IFTRUE 4587
4585: GO 4598
4587: POP
// Difficulty := 2 ; 3 :
4588: LD_ADDR_OWVAR 67
4592: PUSH
4593: LD_INT 2
4595: ST_TO_ADDR
4596: GO 4618
4598: LD_INT 3
4600: DOUBLE
4601: EQUAL
4602: IFTRUE 4606
4604: GO 4617
4606: POP
// Difficulty := 3 ; end ;
4607: LD_ADDR_OWVAR 67
4611: PUSH
4612: LD_INT 3
4614: ST_TO_ADDR
4615: GO 4618
4617: POP
// case query ( info ) of 1 :
4618: LD_STRING info
4620: PPUSH
4621: CALL_OW 97
4625: PUSH
4626: LD_INT 1
4628: DOUBLE
4629: EQUAL
4630: IFTRUE 4634
4632: GO 4637
4634: POP
// ; end ;
4635: GO 4638
4637: POP
// PrepareRussian ;
4638: CALL 1884 0 0
// dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Davidov ;
4642: LD_ADDR_VAR 0 2
4646: PUSH
4647: LD_INT 22
4649: PUSH
4650: LD_INT 6
4652: PUSH
4653: EMPTY
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 21
4659: PUSH
4660: LD_INT 1
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PPUSH
4671: CALL_OW 69
4675: PUSH
4676: LD_EXP 3
4680: DIFF
4681: ST_TO_ADDR
// ComMoveXY ( dial [ 1 ] , 202 , 40 ) ;
4682: LD_VAR 0 2
4686: PUSH
4687: LD_INT 1
4689: ARRAY
4690: PPUSH
4691: LD_INT 202
4693: PPUSH
4694: LD_INT 40
4696: PPUSH
4697: CALL_OW 111
// Wait ( 0 0$03 ) ;
4701: LD_INT 105
4703: PPUSH
4704: CALL_OW 67
// Say ( Davidov , DD1 ) ;
4708: LD_EXP 3
4712: PPUSH
4713: LD_STRING DD1
4715: PPUSH
4716: CALL_OW 88
// ComTurnUnit ( dial [ 1 ] , Davidov ) ;
4720: LD_VAR 0 2
4724: PUSH
4725: LD_INT 1
4727: ARRAY
4728: PPUSH
4729: LD_EXP 3
4733: PPUSH
4734: CALL_OW 119
// ComTurnUnit ( Davidov , dial [ 1 ] ) ;
4738: LD_EXP 3
4742: PPUSH
4743: LD_VAR 0 2
4747: PUSH
4748: LD_INT 1
4750: ARRAY
4751: PPUSH
4752: CALL_OW 119
// CenterOnXY ( 202 , 40 ) ;
4756: LD_INT 202
4758: PPUSH
4759: LD_INT 40
4761: PPUSH
4762: CALL_OW 84
// Say ( dial [ 1 ] , DV1 ) ;
4766: LD_VAR 0 2
4770: PUSH
4771: LD_INT 1
4773: ARRAY
4774: PPUSH
4775: LD_STRING DV1
4777: PPUSH
4778: CALL_OW 88
// Say ( Davidov , DD2 ) ;
4782: LD_EXP 3
4786: PPUSH
4787: LD_STRING DD2
4789: PPUSH
4790: CALL_OW 88
// Say ( dial [ 1 ] , DV2 ) ;
4794: LD_VAR 0 2
4798: PUSH
4799: LD_INT 1
4801: ARRAY
4802: PPUSH
4803: LD_STRING DV2
4805: PPUSH
4806: CALL_OW 88
// Say ( Davidov , DD3 ) ;
4810: LD_EXP 3
4814: PPUSH
4815: LD_STRING DD3
4817: PPUSH
4818: CALL_OW 88
// InGameOff ;
4822: CALL_OW 9
// Wait ( 0 0$0.3 ) ;
4826: LD_INT 10
4828: PPUSH
4829: CALL_OW 67
// ChangeMissionObjectives ( C1 ) ;
4833: LD_STRING C1
4835: PPUSH
4836: CALL_OW 337
// end ;
4840: LD_VAR 0 1
4844: RET
// every 0 0$30 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_lab ] ] ) do
4845: LD_INT 22
4847: PUSH
4848: LD_INT 6
4850: PUSH
4851: EMPTY
4852: LIST
4853: LIST
4854: PUSH
4855: LD_INT 30
4857: PUSH
4858: LD_INT 6
4860: PUSH
4861: EMPTY
4862: LIST
4863: LIST
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: PPUSH
4869: CALL_OW 69
4873: IFFALSE 4890
4875: GO 4877
4877: DISABLE
// begin Say ( Davidov , DD4 ) ;
4878: LD_EXP 3
4882: PPUSH
4883: LD_STRING DD4
4885: PPUSH
4886: CALL_OW 88
// end ;
4890: END
// every 0 0$02 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_lab_siberium ] ] ) do var dial ;
4891: LD_INT 22
4893: PUSH
4894: LD_INT 6
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 30
4903: PUSH
4904: LD_INT 11
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 69
4919: IFFALSE 5002
4921: GO 4923
4923: DISABLE
4924: LD_INT 0
4926: PPUSH
// begin dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Davidov ;
4927: LD_ADDR_VAR 0 1
4931: PUSH
4932: LD_INT 22
4934: PUSH
4935: LD_INT 6
4937: PUSH
4938: EMPTY
4939: LIST
4940: LIST
4941: PUSH
4942: LD_INT 21
4944: PUSH
4945: LD_INT 1
4947: PUSH
4948: EMPTY
4949: LIST
4950: LIST
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: PPUSH
4956: CALL_OW 69
4960: PUSH
4961: LD_EXP 3
4965: DIFF
4966: ST_TO_ADDR
// Say ( dial [ 1 ] , DV3 ) ;
4967: LD_VAR 0 1
4971: PUSH
4972: LD_INT 1
4974: ARRAY
4975: PPUSH
4976: LD_STRING DV3
4978: PPUSH
4979: CALL_OW 88
// Say ( Davidov , DD5 ) ;
4983: LD_EXP 3
4987: PPUSH
4988: LD_STRING DD5
4990: PPUSH
4991: CALL_OW 88
// ChangeMissionObjectives ( C2 ) ;
4995: LD_STRING C2
4997: PPUSH
4998: CALL_OW 337
// end ; end_of_file
5002: PPOPN 1
5004: END
// every 0 0$22 + 0 0$2 do
5005: GO 5007
5007: DISABLE
// begin enable ;
5008: ENABLE
// CreateCratesArea ( Rand ( 4 , 5 ) , cratesArea , true ) ;
5009: LD_INT 4
5011: PPUSH
5012: LD_INT 5
5014: PPUSH
5015: CALL_OW 12
5019: PPUSH
5020: LD_INT 3
5022: PPUSH
5023: LD_INT 1
5025: PPUSH
5026: CALL_OW 55
// if tick >= 4 4$00 then
5030: LD_OWVAR 1
5034: PUSH
5035: LD_INT 8400
5037: GREATEREQUAL
5038: IFFALSE 5045
// begin disable ;
5040: DISABLE
// CratesSpawn ( ) ;
5041: CALL 5046 0 0
// end ; end ;
5045: END
// function CratesSpawn ( ) ; var i , amount , cr ; begin
5046: LD_INT 0
5048: PPUSH
5049: PPUSH
5050: PPUSH
5051: PPUSH
// amount := [ 30000 , 20000 , 10000 ] [ Difficulty ] ;
5052: LD_ADDR_VAR 0 3
5056: PUSH
5057: LD_INT 30000
5059: PUSH
5060: LD_INT 20000
5062: PUSH
5063: LD_INT 10000
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: LIST
5070: PUSH
5071: LD_OWVAR 67
5075: ARRAY
5076: ST_TO_ADDR
// while amount > 0 do
5077: LD_VAR 0 3
5081: PUSH
5082: LD_INT 0
5084: GREATER
5085: IFFALSE 5155
// begin Wait ( rand ( 0 0$30 , 1 1$30 ) ) ;
5087: LD_INT 1050
5089: PPUSH
5090: LD_INT 3150
5092: PPUSH
5093: CALL_OW 12
5097: PPUSH
5098: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
5102: LD_ADDR_VAR 0 4
5106: PUSH
5107: LD_INT 1
5109: PPUSH
5110: LD_INT 5
5112: PPUSH
5113: CALL_OW 12
5117: ST_TO_ADDR
// amount := amount - ( cr * 10 ) ;
5118: LD_ADDR_VAR 0 3
5122: PUSH
5123: LD_VAR 0 3
5127: PUSH
5128: LD_VAR 0 4
5132: PUSH
5133: LD_INT 10
5135: MUL
5136: MINUS
5137: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
5138: LD_VAR 0 4
5142: PPUSH
5143: LD_INT 3
5145: PPUSH
5146: LD_INT 1
5148: PPUSH
5149: CALL_OW 55
// end ;
5153: GO 5077
// end ; end_of_file
5155: LD_VAR 0 1
5159: RET
// every 2 2$10 do
5160: GO 5162
5162: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
5163: LD_INT 1
5165: PPUSH
5166: LD_INT 210
5168: PPUSH
5169: LD_INT 110
5171: PPUSH
5172: CALL_OW 550
// Wait ( Rand ( 7 7$00 , 10 10$00 ) ) ;
5176: LD_INT 14700
5178: PPUSH
5179: LD_INT 21000
5181: PPUSH
5182: CALL_OW 12
5186: PPUSH
5187: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
5191: LD_INT 0
5193: PPUSH
5194: LD_INT 210
5196: PPUSH
5197: LD_INT 110
5199: PPUSH
5200: CALL_OW 550
// end ;
5204: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
5205: LD_INT 0
5207: PPUSH
5208: PPUSH
5209: PPUSH
5210: PPUSH
5211: PPUSH
// uc_nation = nation_nature ;
5212: LD_ADDR_OWVAR 21
5216: PUSH
5217: LD_INT 0
5219: ST_TO_ADDR
// uc_side = 0 ;
5220: LD_ADDR_OWVAR 20
5224: PUSH
5225: LD_INT 0
5227: ST_TO_ADDR
// l = 0 ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_INT 0
5235: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
5236: LD_ADDR_OWVAR 24
5240: PUSH
5241: LD_INT 0
5243: PPUSH
5244: LD_INT 5
5246: PPUSH
5247: CALL_OW 12
5251: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
5252: LD_ADDR_OWVAR 35
5256: PUSH
5257: LD_INT 5
5259: NEG
5260: PPUSH
5261: LD_INT 5
5263: PPUSH
5264: CALL_OW 12
5268: ST_TO_ADDR
// hc_gallery =  ;
5269: LD_ADDR_OWVAR 33
5273: PUSH
5274: LD_STRING 
5276: ST_TO_ADDR
// hc_class = class_apeman ;
5277: LD_ADDR_OWVAR 28
5281: PUSH
5282: LD_INT 12
5284: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
5285: LD_ADDR_OWVAR 29
5289: PUSH
5290: LD_INT 11
5292: PPUSH
5293: LD_INT 13
5295: PPUSH
5296: CALL_OW 12
5300: PUSH
5301: LD_INT 10
5303: PPUSH
5304: LD_INT 11
5306: PPUSH
5307: CALL_OW 12
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: ST_TO_ADDR
// hc_sex = sex_male ;
5316: LD_ADDR_OWVAR 27
5320: PUSH
5321: LD_INT 1
5323: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
5324: LD_ADDR_OWVAR 31
5328: PUSH
5329: LD_INT 0
5331: PPUSH
5332: LD_INT 2
5334: PPUSH
5335: CALL_OW 12
5339: PUSH
5340: LD_INT 0
5342: PUSH
5343: LD_INT 0
5345: PUSH
5346: LD_INT 0
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: ST_TO_ADDR
// apeman = CreateHuman ;
5355: LD_ADDR_VAR 0 7
5359: PUSH
5360: CALL_OW 44
5364: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
5365: LD_VAR 0 7
5369: PPUSH
5370: LD_VAR 0 4
5374: PPUSH
5375: LD_INT 0
5377: PPUSH
5378: CALL_OW 49
// l = l + 1 ;
5382: LD_ADDR_VAR 0 6
5386: PUSH
5387: LD_VAR 0 6
5391: PUSH
5392: LD_INT 1
5394: PLUS
5395: ST_TO_ADDR
// end until l = num1 ;
5396: LD_VAR 0 6
5400: PUSH
5401: LD_VAR 0 1
5405: EQUAL
5406: IFFALSE 5236
// l = 0 ;
5408: LD_ADDR_VAR 0 6
5412: PUSH
5413: LD_INT 0
5415: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
5416: LD_ADDR_OWVAR 35
5420: PUSH
5421: LD_INT 0
5423: PPUSH
5424: LD_INT 25
5426: PPUSH
5427: CALL_OW 12
5431: ST_TO_ADDR
// hc_class = class_tiger ;
5432: LD_ADDR_OWVAR 28
5436: PUSH
5437: LD_INT 14
5439: ST_TO_ADDR
// hc_sex = sex_male ;
5440: LD_ADDR_OWVAR 27
5444: PUSH
5445: LD_INT 1
5447: ST_TO_ADDR
// hc_gallery = sandnature ;
5448: LD_ADDR_OWVAR 33
5452: PUSH
5453: LD_STRING sandnature
5455: ST_TO_ADDR
// hc_face_number = 3 ;
5456: LD_ADDR_OWVAR 34
5460: PUSH
5461: LD_INT 3
5463: ST_TO_ADDR
// tiger = CreateHuman ;
5464: LD_ADDR_VAR 0 8
5468: PUSH
5469: CALL_OW 44
5473: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
5474: LD_VAR 0 8
5478: PPUSH
5479: LD_VAR 0 4
5483: PPUSH
5484: LD_INT 0
5486: PPUSH
5487: CALL_OW 49
// l = l + 1 ;
5491: LD_ADDR_VAR 0 6
5495: PUSH
5496: LD_VAR 0 6
5500: PUSH
5501: LD_INT 1
5503: PLUS
5504: ST_TO_ADDR
// end until l = num2 ;
5505: LD_VAR 0 6
5509: PUSH
5510: LD_VAR 0 2
5514: EQUAL
5515: IFFALSE 5416
// l = 0 ;
5517: LD_ADDR_VAR 0 6
5521: PUSH
5522: LD_INT 0
5524: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
5525: LD_ADDR_OWVAR 28
5529: PUSH
5530: LD_INT 18
5532: ST_TO_ADDR
// hc_gallery = sandnature ;
5533: LD_ADDR_OWVAR 33
5537: PUSH
5538: LD_STRING sandnature
5540: ST_TO_ADDR
// hc_face_number = 1 ;
5541: LD_ADDR_OWVAR 34
5545: PUSH
5546: LD_INT 1
5548: ST_TO_ADDR
// bird = CreateHuman ;
5549: LD_ADDR_VAR 0 9
5553: PUSH
5554: CALL_OW 44
5558: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
5559: LD_VAR 0 9
5563: PPUSH
5564: LD_INT 0
5566: PPUSH
5567: CALL_OW 51
// l = l + 1 ;
5571: LD_ADDR_VAR 0 6
5575: PUSH
5576: LD_VAR 0 6
5580: PUSH
5581: LD_INT 1
5583: PLUS
5584: ST_TO_ADDR
// end until l = num3 ;
5585: LD_VAR 0 6
5589: PUSH
5590: LD_VAR 0 3
5594: EQUAL
5595: IFFALSE 5525
// hc_gallery :=  ;
5597: LD_ADDR_OWVAR 33
5601: PUSH
5602: LD_STRING 
5604: ST_TO_ADDR
// hc_name :=  ;
5605: LD_ADDR_OWVAR 26
5609: PUSH
5610: LD_STRING 
5612: ST_TO_ADDR
// end ; end_of_file
5613: LD_VAR 0 5
5617: RET
// every 0 0$01 do var timer ;
5618: GO 5620
5620: DISABLE
5621: LD_INT 0
5623: PPUSH
// begin timer := 0 0$00 ;
5624: LD_ADDR_VAR 0 1
5628: PUSH
5629: LD_INT 0
5631: ST_TO_ADDR
// while ( true ) do
5632: LD_INT 1
5634: IFFALSE 5676
// begin timer := timer + 0 0$01 ;
5636: LD_ADDR_VAR 0 1
5640: PUSH
5641: LD_VAR 0 1
5645: PUSH
5646: LD_INT 35
5648: PLUS
5649: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
5650: LD_ADDR_OWVAR 47
5654: PUSH
5655: LD_STRING #tick
5657: PUSH
5658: LD_VAR 0 1
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5667: LD_INT 35
5669: PPUSH
5670: CALL_OW 67
// end ;
5674: GO 5632
// end ;
5676: PPOPN 1
5678: END
