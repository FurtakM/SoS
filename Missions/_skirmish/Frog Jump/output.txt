// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// if isEditor then
   8: LD_INT 1
  10: IFFALSE 19
// FogOff ( 6 ) ;
  12: LD_INT 6
  14: PPUSH
  15: CALL_OW 344
// PrepareAnimals ( 7 , 2 , 2 , cratesArea ) ;
  19: LD_INT 7
  21: PPUSH
  22: LD_INT 2
  24: PPUSH
  25: LD_INT 2
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: CALL 5331 0 4
// PrepareAlliance ;
  35: CALL 48 0 0
// PrepareLegion ;
  39: CALL 723 0 0
// Action ;
  43: CALL 4660 0 0
// end ; end_of_file
  47: END
// export function PrepareAlliance ; var i , un , skill ; begin
  48: LD_INT 0
  50: PPUSH
  51: PPUSH
  52: PPUSH
  53: PPUSH
// uc_side := 7 ;
  54: LD_ADDR_OWVAR 20
  58: PUSH
  59: LD_INT 7
  61: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
  62: LD_ADDR_VAR 0 4
  66: PUSH
  67: LD_INT 7
  69: PUSH
  70: LD_INT 8
  72: PUSH
  73: LD_INT 9
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: LIST
  80: PUSH
  81: LD_OWVAR 67
  85: ARRAY
  86: ST_TO_ADDR
// SetResourceType ( GetBase ( al_dep ) , mat_cans , 999999 ) ;
  87: LD_INT 1
  89: PPUSH
  90: CALL_OW 274
  94: PPUSH
  95: LD_INT 1
  97: PPUSH
  98: LD_INT 999999
 100: PPUSH
 101: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_oil , 10000 ) ;
 105: LD_INT 1
 107: PPUSH
 108: CALL_OW 274
 112: PPUSH
 113: LD_INT 2
 115: PPUSH
 116: LD_INT 10000
 118: PPUSH
 119: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_siberit , 10000 ) ;
 123: LD_INT 1
 125: PPUSH
 126: CALL_OW 274
 130: PPUSH
 131: LD_INT 3
 133: PPUSH
 134: LD_INT 10000
 136: PPUSH
 137: CALL_OW 277
// for i = 1 to 6 do
 141: LD_ADDR_VAR 0 2
 145: PUSH
 146: DOUBLE
 147: LD_INT 1
 149: DEC
 150: ST_TO_ADDR
 151: LD_INT 6
 153: PUSH
 154: FOR_TO
 155: IFFALSE 216
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 157: LD_ADDR_OWVAR 21
 161: PUSH
 162: LD_INT 1
 164: PUSH
 165: LD_INT 3
 167: PUSH
 168: EMPTY
 169: LIST
 170: LIST
 171: PUSH
 172: LD_INT 1
 174: PPUSH
 175: LD_INT 2
 177: PPUSH
 178: CALL_OW 12
 182: ARRAY
 183: ST_TO_ADDR
// PrepareHuman ( false , class_engineer , skill ) ;
 184: LD_INT 0
 186: PPUSH
 187: LD_INT 2
 189: PPUSH
 190: LD_VAR 0 4
 194: PPUSH
 195: CALL_OW 380
// PlaceUnitArea ( CreateHuman , al_base , false ) ;
 199: CALL_OW 44
 203: PPUSH
 204: LD_INT 1
 206: PPUSH
 207: LD_INT 0
 209: PPUSH
 210: CALL_OW 49
// end ;
 214: GO 154
 216: POP
 217: POP
// for i = 1 to 6 do
 218: LD_ADDR_VAR 0 2
 222: PUSH
 223: DOUBLE
 224: LD_INT 1
 226: DEC
 227: ST_TO_ADDR
 228: LD_INT 6
 230: PUSH
 231: FOR_TO
 232: IFFALSE 290
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 234: LD_ADDR_OWVAR 21
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 3
 244: PUSH
 245: EMPTY
 246: LIST
 247: LIST
 248: PUSH
 249: LD_INT 1
 251: PPUSH
 252: LD_INT 2
 254: PPUSH
 255: CALL_OW 12
 259: ARRAY
 260: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 261: LD_INT 0
 263: PPUSH
 264: LD_INT 3
 266: PPUSH
 267: LD_VAR 0 4
 271: PPUSH
 272: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_ru ) ;
 276: CALL_OW 44
 280: PPUSH
 281: LD_INT 6
 283: PPUSH
 284: CALL_OW 52
// end ;
 288: GO 231
 290: POP
 291: POP
// for i = 1 to 6 do
 292: LD_ADDR_VAR 0 2
 296: PUSH
 297: DOUBLE
 298: LD_INT 1
 300: DEC
 301: ST_TO_ADDR
 302: LD_INT 6
 304: PUSH
 305: FOR_TO
 306: IFFALSE 364
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 308: LD_ADDR_OWVAR 21
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 3
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 2
 328: PPUSH
 329: CALL_OW 12
 333: ARRAY
 334: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 335: LD_INT 0
 337: PPUSH
 338: LD_INT 3
 340: PPUSH
 341: LD_VAR 0 4
 345: PPUSH
 346: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_us ) ;
 350: CALL_OW 44
 354: PPUSH
 355: LD_INT 11
 357: PPUSH
 358: CALL_OW 52
// end ;
 362: GO 305
 364: POP
 365: POP
// for i = 1 to 6 do
 366: LD_ADDR_VAR 0 2
 370: PUSH
 371: DOUBLE
 372: LD_INT 1
 374: DEC
 375: ST_TO_ADDR
 376: LD_INT 6
 378: PUSH
 379: FOR_TO
 380: IFFALSE 457
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 382: LD_ADDR_OWVAR 21
 386: PUSH
 387: LD_INT 1
 389: PUSH
 390: LD_INT 3
 392: PUSH
 393: EMPTY
 394: LIST
 395: LIST
 396: PUSH
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 2
 402: PPUSH
 403: CALL_OW 12
 407: ARRAY
 408: ST_TO_ADDR
// PrepareHuman ( false , class_scientistic , skill ) ;
 409: LD_INT 0
 411: PPUSH
 412: LD_INT 4
 414: PPUSH
 415: LD_VAR 0 4
 419: PPUSH
 420: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , [ al_lab_us , al_lab_ru ] [ Rand ( 1 , 2 ) ] ) ;
 424: CALL_OW 44
 428: PPUSH
 429: LD_INT 2
 431: PUSH
 432: LD_INT 5
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 1
 441: PPUSH
 442: LD_INT 2
 444: PPUSH
 445: CALL_OW 12
 449: ARRAY
 450: PPUSH
 451: CALL_OW 52
// end ;
 455: GO 379
 457: POP
 458: POP
// for i = 1 to 6 do
 459: LD_ADDR_VAR 0 2
 463: PUSH
 464: DOUBLE
 465: LD_INT 1
 467: DEC
 468: ST_TO_ADDR
 469: LD_INT 6
 471: PUSH
 472: FOR_TO
 473: IFFALSE 580
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 475: LD_ADDR_OWVAR 21
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 3
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 2
 495: PPUSH
 496: CALL_OW 12
 500: ARRAY
 501: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker ] [ Rand ( 1 , 2 ) ] , skill ) ;
 502: LD_INT 0
 504: PPUSH
 505: LD_INT 5
 507: PUSH
 508: LD_INT 9
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 1
 517: PPUSH
 518: LD_INT 2
 520: PPUSH
 521: CALL_OW 12
 525: ARRAY
 526: PPUSH
 527: LD_VAR 0 4
 531: PPUSH
 532: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 536: CALL_OW 44
 540: PPUSH
 541: LD_INT 22
 543: PUSH
 544: LD_INT 7
 546: PUSH
 547: EMPTY
 548: LIST
 549: LIST
 550: PUSH
 551: LD_INT 30
 553: PUSH
 554: LD_INT 5
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: PUSH
 561: EMPTY
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL_OW 69
 569: PUSH
 570: LD_INT 1
 572: ARRAY
 573: PPUSH
 574: CALL_OW 52
// end ;
 578: GO 472
 580: POP
 581: POP
// uc_nation := 3 ;
 582: LD_ADDR_OWVAR 21
 586: PUSH
 587: LD_INT 3
 589: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , skill ) ;
 590: LD_INT 0
 592: PPUSH
 593: LD_INT 5
 595: PPUSH
 596: LD_VAR 0 4
 600: PPUSH
 601: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_bun ) ;
 605: CALL_OW 44
 609: PPUSH
 610: LD_INT 50
 612: PPUSH
 613: CALL_OW 52
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) do
 617: LD_ADDR_VAR 0 2
 621: PUSH
 622: LD_INT 22
 624: PUSH
 625: LD_INT 7
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: PUSH
 632: LD_INT 30
 634: PUSH
 635: LD_INT 33
 637: PUSH
 638: EMPTY
 639: LIST
 640: LIST
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: PPUSH
 646: CALL_OW 69
 650: PUSH
 651: FOR_IN
 652: IFFALSE 716
// if GetNation ( i ) = 1 then
 654: LD_VAR 0 2
 658: PPUSH
 659: CALL_OW 248
 663: PUSH
 664: LD_INT 1
 666: EQUAL
 667: IFFALSE 683
// AddComPlaceWeapon ( i , us_double_laser ) else
 669: LD_VAR 0 2
 673: PPUSH
 674: LD_INT 10
 676: PPUSH
 677: CALL_OW 208
 681: GO 714
// AddComPlaceWeapon ( i , [ ru_rocket , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
 683: LD_VAR 0 2
 687: PPUSH
 688: LD_INT 47
 690: PUSH
 691: LD_INT 45
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: PUSH
 698: LD_INT 1
 700: PPUSH
 701: LD_INT 2
 703: PPUSH
 704: CALL_OW 12
 708: ARRAY
 709: PPUSH
 710: CALL_OW 208
 714: GO 651
 716: POP
 717: POP
// end ; end_of_file
 718: LD_VAR 0 1
 722: RET
// export function PrepareLegion ; var i , un , skill , dep , fac ; begin
 723: LD_INT 0
 725: PPUSH
 726: PPUSH
 727: PPUSH
 728: PPUSH
 729: PPUSH
 730: PPUSH
// uc_side := 8 ;
 731: LD_ADDR_OWVAR 20
 735: PUSH
 736: LD_INT 8
 738: ST_TO_ADDR
// uc_nation := 2 ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_INT 2
 746: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
 747: LD_ADDR_VAR 0 4
 751: PUSH
 752: LD_INT 7
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 9
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: ST_TO_ADDR
// dep := ar_base ;
 772: LD_ADDR_VAR 0 5
 776: PUSH
 777: LD_INT 57
 779: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
 780: LD_ADDR_VAR 0 6
 784: PUSH
 785: LD_INT 22
 787: PUSH
 788: LD_INT 8
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: EMPTY
 806: LIST
 807: LIST
 808: PPUSH
 809: CALL_OW 69
 813: PUSH
 814: LD_INT 1
 816: ARRAY
 817: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 999999 ) ;
 818: LD_VAR 0 5
 822: PPUSH
 823: CALL_OW 274
 827: PPUSH
 828: LD_INT 1
 830: PPUSH
 831: LD_INT 999999
 833: PPUSH
 834: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 838: LD_VAR 0 5
 842: PPUSH
 843: CALL_OW 274
 847: PPUSH
 848: LD_INT 2
 850: PPUSH
 851: LD_INT 10000
 853: PPUSH
 854: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 10000 ) ;
 858: LD_VAR 0 5
 862: PPUSH
 863: CALL_OW 274
 867: PPUSH
 868: LD_INT 3
 870: PPUSH
 871: LD_INT 10000
 873: PPUSH
 874: CALL_OW 277
// TeleportExit ( legion_telep , 224 , 5 ) ;
 878: LD_INT 68
 880: PPUSH
 881: LD_INT 224
 883: PPUSH
 884: LD_INT 5
 886: PPUSH
 887: CALL_OW 243
// for i = 1 to 4 do
 891: LD_ADDR_VAR 0 2
 895: PUSH
 896: DOUBLE
 897: LD_INT 1
 899: DEC
 900: ST_TO_ADDR
 901: LD_INT 4
 903: PUSH
 904: FOR_TO
 905: IFFALSE 966
// begin PrepareHuman ( false , class_bazooker , skill ) ;
 907: LD_INT 0
 909: PPUSH
 910: LD_INT 9
 912: PPUSH
 913: LD_VAR 0 4
 917: PPUSH
 918: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 922: CALL_OW 44
 926: PPUSH
 927: LD_INT 22
 929: PUSH
 930: LD_INT 8
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 30
 939: PUSH
 940: LD_INT 5
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PPUSH
 951: CALL_OW 69
 955: PUSH
 956: LD_INT 1
 958: ARRAY
 959: PPUSH
 960: CALL_OW 52
// end ;
 964: GO 904
 966: POP
 967: POP
// for i = 1 to 2 do
 968: LD_ADDR_VAR 0 2
 972: PUSH
 973: DOUBLE
 974: LD_INT 1
 976: DEC
 977: ST_TO_ADDR
 978: LD_INT 2
 980: PUSH
 981: FOR_TO
 982: IFFALSE 1043
// begin PrepareHuman ( false , 4 , skill ) ;
 984: LD_INT 0
 986: PPUSH
 987: LD_INT 4
 989: PPUSH
 990: LD_VAR 0 4
 994: PPUSH
 995: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
 999: CALL_OW 44
1003: PPUSH
1004: LD_INT 22
1006: PUSH
1007: LD_INT 8
1009: PUSH
1010: EMPTY
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 30
1016: PUSH
1017: LD_INT 8
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL_OW 69
1032: PUSH
1033: LD_INT 1
1035: ARRAY
1036: PPUSH
1037: CALL_OW 52
// end ;
1041: GO 981
1043: POP
1044: POP
// for i = 1 to 6 do
1045: LD_ADDR_VAR 0 2
1049: PUSH
1050: DOUBLE
1051: LD_INT 1
1053: DEC
1054: ST_TO_ADDR
1055: LD_INT 6
1057: PUSH
1058: FOR_TO
1059: IFFALSE 1096
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
1061: LD_INT 0
1063: PPUSH
1064: LD_INT 3
1066: PPUSH
1067: LD_VAR 0 4
1071: PUSH
1072: LD_INT 1
1074: PLUS
1075: PPUSH
1076: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac ) ;
1080: CALL_OW 44
1084: PPUSH
1085: LD_VAR 0 6
1089: PPUSH
1090: CALL_OW 52
// end ;
1094: GO 1058
1096: POP
1097: POP
// uc_nation := 0 ;
1098: LD_ADDR_OWVAR 21
1102: PUSH
1103: LD_INT 0
1105: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) do
1106: LD_ADDR_VAR 0 2
1110: PUSH
1111: LD_INT 22
1113: PUSH
1114: LD_INT 8
1116: PUSH
1117: EMPTY
1118: LIST
1119: LIST
1120: PUSH
1121: LD_INT 30
1123: PUSH
1124: LD_INT 32
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: PPUSH
1135: CALL_OW 69
1139: PUSH
1140: FOR_IN
1141: IFFALSE 1178
// begin PrepareHuman ( false , class_apeman_soldier , skill + 1 ) ;
1143: LD_INT 0
1145: PPUSH
1146: LD_INT 15
1148: PPUSH
1149: LD_VAR 0 4
1153: PUSH
1154: LD_INT 1
1156: PLUS
1157: PPUSH
1158: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
1162: CALL_OW 44
1166: PPUSH
1167: LD_VAR 0 2
1171: PPUSH
1172: CALL_OW 52
// end ;
1176: GO 1140
1178: POP
1179: POP
// for i = 1 to 2 do
1180: LD_ADDR_VAR 0 2
1184: PUSH
1185: DOUBLE
1186: LD_INT 1
1188: DEC
1189: ST_TO_ADDR
1190: LD_INT 2
1192: PUSH
1193: FOR_TO
1194: IFFALSE 1219
// AddComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
1196: LD_VAR 0 6
1200: PPUSH
1201: LD_INT 14
1203: PPUSH
1204: LD_INT 2
1206: PPUSH
1207: LD_INT 1
1209: PPUSH
1210: LD_INT 31
1212: PPUSH
1213: CALL_OW 185
1217: GO 1193
1219: POP
1220: POP
// end ;
1221: LD_VAR 0 1
1225: RET
// export function PrepareHovercraft ( num ) ; var i ; begin
1226: LD_INT 0
1228: PPUSH
1229: PPUSH
// for i = 1 to num do
1230: LD_ADDR_VAR 0 3
1234: PUSH
1235: DOUBLE
1236: LD_INT 1
1238: DEC
1239: ST_TO_ADDR
1240: LD_VAR 0 1
1244: PUSH
1245: FOR_TO
1246: IFFALSE 1318
// AddComConstruct ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] , ar_hovercraft , engine_combustion , control_remote , [ ar_light_gun , ar_double_machine_gun ] [ rand ( 1 , 2 ) ] ) ;
1248: LD_INT 22
1250: PUSH
1251: LD_INT 8
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: PUSH
1277: LD_INT 1
1279: ARRAY
1280: PPUSH
1281: LD_INT 11
1283: PPUSH
1284: LD_INT 1
1286: PPUSH
1287: LD_INT 2
1289: PPUSH
1290: LD_INT 23
1292: PUSH
1293: LD_INT 24
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: LD_INT 1
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: CALL_OW 12
1310: ARRAY
1311: PPUSH
1312: CALL_OW 185
1316: GO 1245
1318: POP
1319: POP
// end ;
1320: LD_VAR 0 2
1324: RET
// export function AddKamikaze ( ) ; var i , un ; begin
1325: LD_INT 0
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side := 8 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 8
1337: ST_TO_ADDR
// uc_nation := 0 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 0
1345: ST_TO_ADDR
// hc_class := 17 ;
1346: LD_ADDR_OWVAR 28
1350: PUSH
1351: LD_INT 17
1353: ST_TO_ADDR
// hc_gallery :=  ;
1354: LD_ADDR_OWVAR 33
1358: PUSH
1359: LD_STRING 
1361: ST_TO_ADDR
// hc_name :=  ;
1362: LD_ADDR_OWVAR 26
1366: PUSH
1367: LD_STRING 
1369: ST_TO_ADDR
// hc_importance := 0 ;
1370: LD_ADDR_OWVAR 32
1374: PUSH
1375: LD_INT 0
1377: ST_TO_ADDR
// hc_skills := [ 10 , 10 , 10 , 10 ] ;
1378: LD_ADDR_OWVAR 31
1382: PUSH
1383: LD_INT 10
1385: PUSH
1386: LD_INT 10
1388: PUSH
1389: LD_INT 10
1391: PUSH
1392: LD_INT 10
1394: PUSH
1395: EMPTY
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: ST_TO_ADDR
// if ar_base then
1401: LD_INT 57
1403: IFFALSE 1448
// begin un := CreateHuman ;
1405: LD_ADDR_VAR 0 3
1409: PUSH
1410: CALL_OW 44
1414: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_base ) ;
1415: LD_VAR 0 3
1419: PPUSH
1420: LD_INT 57
1422: PPUSH
1423: CALL_OW 52
// ComExitBuilding ( un ) ;
1427: LD_VAR 0 3
1431: PPUSH
1432: CALL_OW 122
// AddComEnterUnit ( un , legion_telep ) ;
1436: LD_VAR 0 3
1440: PPUSH
1441: LD_INT 68
1443: PPUSH
1444: CALL_OW 180
// end ; end ;
1448: LD_VAR 0 1
1452: RET
// export legion_force , l_allow_attack ; export function PrepareAttack ( n1 , n2 ) ; var i ; begin
1453: LD_INT 0
1455: PPUSH
1456: PPUSH
// legion_force := [ ] ;
1457: LD_ADDR_EXP 1
1461: PUSH
1462: EMPTY
1463: ST_TO_ADDR
// l_allow_attack := false ;
1464: LD_ADDR_EXP 2
1468: PUSH
1469: LD_INT 0
1471: ST_TO_ADDR
// PrepareHovercraft ( n1 ) ;
1472: LD_VAR 0 1
1476: PPUSH
1477: CALL 1226 0 1
// repeat wait ( 0 0$01 ) ;
1481: LD_INT 35
1483: PPUSH
1484: CALL_OW 67
// until legion_force = n1 ;
1488: LD_EXP 1
1492: PUSH
1493: LD_VAR 0 1
1497: EQUAL
1498: IFFALSE 1481
// l_allow_attack := true ;
1500: LD_ADDR_EXP 2
1504: PUSH
1505: LD_INT 1
1507: ST_TO_ADDR
// for i = 1 to n2 do
1508: LD_ADDR_VAR 0 4
1512: PUSH
1513: DOUBLE
1514: LD_INT 1
1516: DEC
1517: ST_TO_ADDR
1518: LD_VAR 0 2
1522: PUSH
1523: FOR_TO
1524: IFFALSE 1532
// begin AddKamikaze ( ) ;
1526: CALL 1325 0 0
// end ;
1530: GO 1523
1532: POP
1533: POP
// ComBrutalAttack ( legion_force , 6 ) ;
1534: LD_EXP 1
1538: PPUSH
1539: LD_INT 6
1541: PPUSH
1542: CALL 4025 0 2
// end ;
1546: LD_VAR 0 3
1550: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) > 1 do
1551: LD_INT 22
1553: PUSH
1554: LD_INT 6
1556: PUSH
1557: EMPTY
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 21
1563: PUSH
1564: LD_INT 3
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: PPUSH
1575: CALL_OW 69
1579: PUSH
1580: LD_INT 1
1582: GREATER
1583: IFFALSE 1605
1585: GO 1587
1587: DISABLE
// begin wait ( 3 3$00 ) ;
1588: LD_INT 6300
1590: PPUSH
1591: CALL_OW 67
// PrepareAttack ( 4 , 2 ) ;
1595: LD_INT 4
1597: PPUSH
1598: LD_INT 2
1600: PPUSH
1601: CALL 1453 0 2
// end ;
1605: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
1606: LD_INT 22
1608: PUSH
1609: LD_INT 8
1611: PUSH
1612: EMPTY
1613: LIST
1614: LIST
1615: PUSH
1616: LD_INT 33
1618: PUSH
1619: LD_INT 2
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PPUSH
1630: CALL_OW 69
1634: IFFALSE 1846
1636: GO 1638
1638: DISABLE
1639: LD_INT 0
1641: PPUSH
1642: PPUSH
1643: PPUSH
1644: PPUSH
1645: PPUSH
1646: PPUSH
1647: PPUSH
// begin enable ;
1648: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
1649: LD_ADDR_VAR 0 4
1653: PUSH
1654: LD_INT 22
1656: PUSH
1657: LD_INT 8
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: LD_INT 33
1666: PUSH
1667: LD_INT 2
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: PUSH
1674: LD_INT 3
1676: PUSH
1677: LD_INT 61
1679: PUSH
1680: EMPTY
1681: LIST
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: LIST
1691: PPUSH
1692: CALL_OW 69
1696: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ;
1697: LD_ADDR_VAR 0 3
1701: PUSH
1702: LD_INT 22
1704: PUSH
1705: LD_INT 8
1707: PUSH
1708: EMPTY
1709: LIST
1710: LIST
1711: PUSH
1712: LD_INT 34
1714: PUSH
1715: LD_INT 31
1717: PUSH
1718: EMPTY
1719: LIST
1720: LIST
1721: PUSH
1722: EMPTY
1723: LIST
1724: LIST
1725: PPUSH
1726: CALL_OW 69
1730: ST_TO_ADDR
// best := 10 ;
1731: LD_ADDR_VAR 0 5
1735: PUSH
1736: LD_INT 10
1738: ST_TO_ADDR
// best_mechanic := - 1 ;
1739: LD_ADDR_VAR 0 6
1743: PUSH
1744: LD_INT 1
1746: NEG
1747: ST_TO_ADDR
// if vehs then
1748: LD_VAR 0 4
1752: IFFALSE 1846
// begin for j in cts do
1754: LD_ADDR_VAR 0 2
1758: PUSH
1759: LD_VAR 0 3
1763: PUSH
1764: FOR_IN
1765: IFFALSE 1826
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
1767: LD_ADDR_VAR 0 7
1771: PUSH
1772: LD_VAR 0 2
1776: PPUSH
1777: CALL 3042 0 1
1781: PPUSH
1782: CALL_OW 432
1786: ST_TO_ADDR
// if p < best then
1787: LD_VAR 0 7
1791: PUSH
1792: LD_VAR 0 5
1796: LESS
1797: IFFALSE 1824
// begin best := p ;
1799: LD_ADDR_VAR 0 5
1803: PUSH
1804: LD_VAR 0 7
1808: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
1809: LD_ADDR_VAR 0 6
1813: PUSH
1814: LD_VAR 0 2
1818: PPUSH
1819: CALL 3042 0 1
1823: ST_TO_ADDR
// end ; end ;
1824: GO 1764
1826: POP
1827: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
1828: LD_VAR 0 4
1832: PUSH
1833: LD_INT 1
1835: ARRAY
1836: PPUSH
1837: LD_VAR 0 6
1841: PPUSH
1842: CALL_OW 135
// end ; end ; end_of_file
1846: PPOPN 7
1848: END
// export Davidov ; export function PrepareRussian ; var i , skill , un , tmp , amount , k ; begin
1849: LD_INT 0
1851: PPUSH
1852: PPUSH
1853: PPUSH
1854: PPUSH
1855: PPUSH
1856: PPUSH
1857: PPUSH
// uc_side := 6 ;
1858: LD_ADDR_OWVAR 20
1862: PUSH
1863: LD_INT 6
1865: ST_TO_ADDR
// uc_nation := nation_russian ;
1866: LD_ADDR_OWVAR 21
1870: PUSH
1871: LD_INT 3
1873: ST_TO_ADDR
// amount := [ [ 8 , 4 ] , [ 7 , 3 ] , [ 6 , 2 ] ] [ Difficulty ] ;
1874: LD_ADDR_VAR 0 6
1878: PUSH
1879: LD_INT 8
1881: PUSH
1882: LD_INT 4
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: PUSH
1889: LD_INT 7
1891: PUSH
1892: LD_INT 3
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: PUSH
1899: LD_INT 6
1901: PUSH
1902: LD_INT 2
1904: PUSH
1905: EMPTY
1906: LIST
1907: LIST
1908: PUSH
1909: EMPTY
1910: LIST
1911: LIST
1912: LIST
1913: PUSH
1914: LD_OWVAR 67
1918: ARRAY
1919: ST_TO_ADDR
// skill := [ 9 , 7 , 6 ] [ Difficulty ] ;
1920: LD_ADDR_VAR 0 3
1924: PUSH
1925: LD_INT 9
1927: PUSH
1928: LD_INT 7
1930: PUSH
1931: LD_INT 6
1933: PUSH
1934: EMPTY
1935: LIST
1936: LIST
1937: LIST
1938: PUSH
1939: LD_OWVAR 67
1943: ARRAY
1944: ST_TO_ADDR
// tmp := [ ] ;
1945: LD_ADDR_VAR 0 5
1949: PUSH
1950: EMPTY
1951: ST_TO_ADDR
// Davidov := NewCharacter ( Davidov ) ;
1952: LD_ADDR_EXP 3
1956: PUSH
1957: LD_STRING Davidov
1959: PPUSH
1960: CALL_OW 25
1964: ST_TO_ADDR
// SetSkill ( Davidov , 1 , 7 ) ;
1965: LD_EXP 3
1969: PPUSH
1970: LD_INT 1
1972: PPUSH
1973: LD_INT 7
1975: PPUSH
1976: CALL_OW 237
// SetSkill ( Davidov , 2 , 8 ) ;
1980: LD_EXP 3
1984: PPUSH
1985: LD_INT 2
1987: PPUSH
1988: LD_INT 8
1990: PPUSH
1991: CALL_OW 237
// SetSkill ( Davidov , 3 , 6 ) ;
1995: LD_EXP 3
1999: PPUSH
2000: LD_INT 3
2002: PPUSH
2003: LD_INT 6
2005: PPUSH
2006: CALL_OW 237
// SetSkill ( Davidov , 4 , 10 ) ;
2010: LD_EXP 3
2014: PPUSH
2015: LD_INT 4
2017: PPUSH
2018: LD_INT 10
2020: PPUSH
2021: CALL_OW 237
// SetClass ( Davidov , 4 ) ;
2025: LD_EXP 3
2029: PPUSH
2030: LD_INT 4
2032: PPUSH
2033: CALL_OW 336
// hc_importance := 0 ;
2037: LD_ADDR_OWVAR 32
2041: PUSH
2042: LD_INT 0
2044: ST_TO_ADDR
// while amount [ 1 ] do
2045: LD_VAR 0 6
2049: PUSH
2050: LD_INT 1
2052: ARRAY
2053: IFFALSE 2386
// begin Wait ( 1 ) ;
2055: LD_INT 1
2057: PPUSH
2058: CALL_OW 67
// k := rand ( 2 , 4 ) ;
2062: LD_ADDR_VAR 0 7
2066: PUSH
2067: LD_INT 2
2069: PPUSH
2070: LD_INT 4
2072: PPUSH
2073: CALL_OW 12
2077: ST_TO_ADDR
// if amount [ 2 ] and tmp then
2078: LD_VAR 0 6
2082: PUSH
2083: LD_INT 2
2085: ARRAY
2086: PUSH
2087: LD_VAR 0 5
2091: AND
2092: IFFALSE 2247
// begin if k in [ 1 , 2 ] then
2094: LD_VAR 0 7
2098: PUSH
2099: LD_INT 1
2101: PUSH
2102: LD_INT 2
2104: PUSH
2105: EMPTY
2106: LIST
2107: LIST
2108: IN
2109: IFFALSE 2119
// k := 3 ;
2111: LD_ADDR_VAR 0 7
2115: PUSH
2116: LD_INT 3
2118: ST_TO_ADDR
// vc_chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
2119: LD_ADDR_OWVAR 37
2123: PUSH
2124: LD_INT 22
2126: PUSH
2127: LD_INT 24
2129: PUSH
2130: EMPTY
2131: LIST
2132: LIST
2133: PUSH
2134: LD_INT 1
2136: PPUSH
2137: LD_INT 2
2139: PPUSH
2140: CALL_OW 12
2144: ARRAY
2145: ST_TO_ADDR
// vc_engine := engine_siberite ;
2146: LD_ADDR_OWVAR 39
2150: PUSH
2151: LD_INT 3
2153: ST_TO_ADDR
// vc_control := control_manual ;
2154: LD_ADDR_OWVAR 38
2158: PUSH
2159: LD_INT 1
2161: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_rocket_launcher , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ;
2162: LD_ADDR_OWVAR 40
2166: PUSH
2167: LD_INT 44
2169: PUSH
2170: LD_INT 45
2172: PUSH
2173: LD_INT 43
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: PUSH
2181: LD_INT 1
2183: PPUSH
2184: LD_INT 3
2186: PPUSH
2187: CALL_OW 12
2191: ARRAY
2192: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , CreateVehicle ) ;
2193: LD_ADDR_VAR 0 5
2197: PUSH
2198: LD_VAR 0 5
2202: PPUSH
2203: LD_INT 1
2205: PPUSH
2206: CALL_OW 45
2210: PPUSH
2211: CALL_OW 2
2215: ST_TO_ADDR
// amount := Replace ( amount , 2 , amount [ 2 ] - 1 ) ;
2216: LD_ADDR_VAR 0 6
2220: PUSH
2221: LD_VAR 0 6
2225: PPUSH
2226: LD_INT 2
2228: PPUSH
2229: LD_VAR 0 6
2233: PUSH
2234: LD_INT 2
2236: ARRAY
2237: PUSH
2238: LD_INT 1
2240: MINUS
2241: PPUSH
2242: CALL_OW 1
2246: ST_TO_ADDR
// end ; if not tmp then
2247: LD_VAR 0 5
2251: NOT
2252: IFFALSE 2262
// k := 2 ;
2254: LD_ADDR_VAR 0 7
2258: PUSH
2259: LD_INT 2
2261: ST_TO_ADDR
// if amount [ 2 ] = 0 and k = 3 then
2262: LD_VAR 0 6
2266: PUSH
2267: LD_INT 2
2269: ARRAY
2270: PUSH
2271: LD_INT 0
2273: EQUAL
2274: PUSH
2275: LD_VAR 0 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: AND
2284: IFFALSE 2313
// k := [ class_bazooker , class_scientistic ] [ rand ( 1 , 2 ) ] ;
2286: LD_ADDR_VAR 0 7
2290: PUSH
2291: LD_INT 9
2293: PUSH
2294: LD_INT 4
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: PUSH
2301: LD_INT 1
2303: PPUSH
2304: LD_INT 2
2306: PPUSH
2307: CALL_OW 12
2311: ARRAY
2312: ST_TO_ADDR
// PrepareHuman ( false , k , skill ) ;
2313: LD_INT 0
2315: PPUSH
2316: LD_VAR 0 7
2320: PPUSH
2321: LD_VAR 0 3
2325: PPUSH
2326: CALL_OW 380
// tmp := Insert ( tmp , 1 , CreateHuman ) ;
2330: LD_ADDR_VAR 0 5
2334: PUSH
2335: LD_VAR 0 5
2339: PPUSH
2340: LD_INT 1
2342: PPUSH
2343: CALL_OW 44
2347: PPUSH
2348: CALL_OW 2
2352: ST_TO_ADDR
// amount := Replace ( amount , 1 , amount [ 1 ] - 1 ) ;
2353: LD_ADDR_VAR 0 6
2357: PUSH
2358: LD_VAR 0 6
2362: PPUSH
2363: LD_INT 1
2365: PPUSH
2366: LD_VAR 0 6
2370: PUSH
2371: LD_INT 1
2373: ARRAY
2374: PUSH
2375: LD_INT 1
2377: MINUS
2378: PPUSH
2379: CALL_OW 1
2383: ST_TO_ADDR
// end ;
2384: GO 2045
// tmp := Insert ( tmp , tmp + 1 , Davidov ) ;
2386: LD_ADDR_VAR 0 5
2390: PUSH
2391: LD_VAR 0 5
2395: PPUSH
2396: LD_VAR 0 5
2400: PUSH
2401: LD_INT 1
2403: PLUS
2404: PPUSH
2405: LD_EXP 3
2409: PPUSH
2410: CALL_OW 2
2414: ST_TO_ADDR
// for i = tmp downto 1 do
2415: LD_ADDR_VAR 0 2
2419: PUSH
2420: DOUBLE
2421: LD_VAR 0 5
2425: INC
2426: ST_TO_ADDR
2427: LD_INT 1
2429: PUSH
2430: FOR_DOWNTO
2431: IFFALSE 2593
// begin if GetType ( tmp [ i ] ) = unit_vehicle then
2433: LD_VAR 0 5
2437: PUSH
2438: LD_VAR 0 2
2442: ARRAY
2443: PPUSH
2444: CALL_OW 247
2448: PUSH
2449: LD_INT 2
2451: EQUAL
2452: IFFALSE 2542
// begin SetDir ( tmp [ i ] , 3 ) ;
2454: LD_VAR 0 5
2458: PUSH
2459: LD_VAR 0 2
2463: ARRAY
2464: PPUSH
2465: LD_INT 3
2467: PPUSH
2468: CALL_OW 233
// PlaceUnitXY ( tmp [ i ] , 193 , 3 , false ) ;
2472: LD_VAR 0 5
2476: PUSH
2477: LD_VAR 0 2
2481: ARRAY
2482: PPUSH
2483: LD_INT 193
2485: PPUSH
2486: LD_INT 3
2488: PPUSH
2489: LD_INT 0
2491: PPUSH
2492: CALL_OW 48
// PlaceHumanInUnit ( tmp [ i - 1 ] , tmp [ i ] ) ;
2496: LD_VAR 0 5
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_INT 1
2508: MINUS
2509: ARRAY
2510: PPUSH
2511: LD_VAR 0 5
2515: PUSH
2516: LD_VAR 0 2
2520: ARRAY
2521: PPUSH
2522: CALL_OW 52
// i := i - 1 ;
2526: LD_ADDR_VAR 0 2
2530: PUSH
2531: LD_VAR 0 2
2535: PUSH
2536: LD_INT 1
2538: MINUS
2539: ST_TO_ADDR
// end else
2540: GO 2563
// PlaceUnitArea ( tmp [ i ] , start_area , false ) ;
2542: LD_VAR 0 5
2546: PUSH
2547: LD_VAR 0 2
2551: ARRAY
2552: PPUSH
2553: LD_INT 2
2555: PPUSH
2556: LD_INT 0
2558: PPUSH
2559: CALL_OW 49
// ComMoveXY ( tmp [ i ] , 197 , 22 ) ;
2563: LD_VAR 0 5
2567: PUSH
2568: LD_VAR 0 2
2572: ARRAY
2573: PPUSH
2574: LD_INT 197
2576: PPUSH
2577: LD_INT 22
2579: PPUSH
2580: CALL_OW 111
// Wait ( 0 0$02 ) ;
2584: LD_INT 70
2586: PPUSH
2587: CALL_OW 67
// end ;
2591: GO 2430
2593: POP
2594: POP
// end ; end_of_file
2595: LD_VAR 0 1
2599: RET
// on VehicleConstructed ( veh , fac ) do var side ;
2600: LD_INT 0
2602: PPUSH
// begin side := GetSide ( fac ) ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: LD_VAR 0 2
2612: PPUSH
2613: CALL_OW 255
2617: ST_TO_ADDR
// case side of 8 :
2618: LD_VAR 0 3
2622: PUSH
2623: LD_INT 8
2625: DOUBLE
2626: EQUAL
2627: IFTRUE 2631
2629: GO 2708
2631: POP
// begin if GetWeapon ( veh ) = ar_control_tower then
2632: LD_VAR 0 1
2636: PPUSH
2637: CALL_OW 264
2641: PUSH
2642: LD_INT 31
2644: EQUAL
2645: IFFALSE 2662
// ComMoveXY ( veh , 145 , 66 ) ;
2647: LD_VAR 0 1
2651: PPUSH
2652: LD_INT 145
2654: PPUSH
2655: LD_INT 66
2657: PPUSH
2658: CALL_OW 111
// if GetChassis ( veh ) = ar_hovercraft then
2662: LD_VAR 0 1
2666: PPUSH
2667: CALL_OW 265
2671: PUSH
2672: LD_INT 11
2674: EQUAL
2675: IFFALSE 2706
// legion_force := Insert ( legion_force , legion_force + 1 , veh ) ;
2677: LD_ADDR_EXP 1
2681: PUSH
2682: LD_EXP 1
2686: PPUSH
2687: LD_EXP 1
2691: PUSH
2692: LD_INT 1
2694: PLUS
2695: PPUSH
2696: LD_VAR 0 1
2700: PPUSH
2701: CALL_OW 2
2705: ST_TO_ADDR
// end ; end ;
2706: GO 2709
2708: POP
// end ;
2709: PPOPN 3
2711: END
// on UnitTeleported ( b , un ) do begin if b = legion_telep and GetClass ( un ) = 17 then
2712: LD_VAR 0 1
2716: PUSH
2717: LD_INT 68
2719: EQUAL
2720: PUSH
2721: LD_VAR 0 2
2725: PPUSH
2726: CALL_OW 257
2730: PUSH
2731: LD_INT 17
2733: EQUAL
2734: AND
2735: IFFALSE 2778
// begin Wait ( 0 0$03 ) ;
2737: LD_INT 105
2739: PPUSH
2740: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , un ) ) ;
2744: LD_VAR 0 2
2748: PPUSH
2749: LD_INT 22
2751: PUSH
2752: LD_INT 6
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 69
2763: PPUSH
2764: LD_VAR 0 2
2768: PPUSH
2769: CALL_OW 74
2773: PPUSH
2774: CALL_OW 115
// end ; end ;
2778: PPOPN 2
2780: END
// on CrateSpawn ( id , x , y , amount , mode ) do var i , apes , n ;
2781: LD_INT 0
2783: PPUSH
2784: PPUSH
2785: PPUSH
// begin if InArea ( x , y , cratesArea ) then
2786: LD_VAR 0 2
2790: PPUSH
2791: LD_VAR 0 3
2795: PPUSH
2796: LD_INT 3
2798: PPUSH
2799: CALL_OW 309
2803: IFFALSE 3012
// begin apes := FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 16 ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_hastask ] ] ] ) ;
2805: LD_ADDR_VAR 0 7
2809: PUSH
2810: LD_INT 22
2812: PUSH
2813: LD_INT 6
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PUSH
2820: LD_INT 25
2822: PUSH
2823: LD_INT 16
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: PUSH
2830: LD_INT 3
2832: PUSH
2833: LD_INT 54
2835: PUSH
2836: EMPTY
2837: LIST
2838: PUSH
2839: EMPTY
2840: LIST
2841: LIST
2842: PUSH
2843: LD_INT 3
2845: PUSH
2846: LD_INT 60
2848: PUSH
2849: EMPTY
2850: LIST
2851: PUSH
2852: EMPTY
2853: LIST
2854: LIST
2855: PUSH
2856: EMPTY
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: PPUSH
2862: CALL_OW 69
2866: ST_TO_ADDR
// if apes = 0 or FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 then
2867: LD_VAR 0 7
2871: PUSH
2872: LD_INT 0
2874: EQUAL
2875: PUSH
2876: LD_INT 22
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: PUSH
2886: LD_INT 2
2888: PUSH
2889: LD_INT 30
2891: PUSH
2892: LD_INT 0
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: PUSH
2899: LD_INT 30
2901: PUSH
2902: LD_INT 1
2904: PUSH
2905: EMPTY
2906: LIST
2907: LIST
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: LIST
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PPUSH
2918: CALL_OW 69
2922: PUSH
2923: LD_INT 0
2925: EQUAL
2926: OR
2927: IFFALSE 2931
// exit ;
2929: GO 3012
// if apes < amount then
2931: LD_VAR 0 7
2935: PUSH
2936: LD_VAR 0 4
2940: LESS
2941: IFFALSE 2955
// n := apes else
2943: LD_ADDR_VAR 0 8
2947: PUSH
2948: LD_VAR 0 7
2952: ST_TO_ADDR
2953: GO 2965
// n := amount ;
2955: LD_ADDR_VAR 0 8
2959: PUSH
2960: LD_VAR 0 4
2964: ST_TO_ADDR
// for i = 1 to n do
2965: LD_ADDR_VAR 0 6
2969: PUSH
2970: DOUBLE
2971: LD_INT 1
2973: DEC
2974: ST_TO_ADDR
2975: LD_VAR 0 8
2979: PUSH
2980: FOR_TO
2981: IFFALSE 3010
// AddComCollect ( apes [ i ] , x , y ) ;
2983: LD_VAR 0 7
2987: PUSH
2988: LD_VAR 0 6
2992: ARRAY
2993: PPUSH
2994: LD_VAR 0 2
2998: PPUSH
2999: LD_VAR 0 3
3003: PPUSH
3004: CALL_OW 177
3008: GO 2980
3010: POP
3011: POP
// end ; end ;
3012: PPOPN 8
3014: END
// on UnitGoesToRed ( un ) do begin if GetControl ( un ) = control_remote then
3015: LD_VAR 0 1
3019: PPUSH
3020: CALL_OW 263
3024: PUSH
3025: LD_INT 2
3027: EQUAL
3028: IFFALSE 3039
// ComUnlink ( un ) ;
3030: LD_VAR 0 1
3034: PPUSH
3035: CALL_OW 136
// end ; end_of_file
3039: PPOPN 1
3041: END
// export function GetDriver ( veh ) ; var i , filter ; begin
3042: LD_INT 0
3044: PPUSH
3045: PPUSH
3046: PPUSH
// if not GetControl ( veh ) = control_manual then
3047: LD_VAR 0 1
3051: PPUSH
3052: CALL_OW 263
3056: PUSH
3057: LD_INT 1
3059: EQUAL
3060: NOT
3061: IFFALSE 3073
// result := false else
3063: LD_ADDR_VAR 0 2
3067: PUSH
3068: LD_INT 0
3070: ST_TO_ADDR
3071: GO 3218
// if veh in FilterAllUnits ( [ f_empty ] ) then
3073: LD_VAR 0 1
3077: PUSH
3078: LD_INT 58
3080: PUSH
3081: EMPTY
3082: LIST
3083: PPUSH
3084: CALL_OW 69
3088: IN
3089: IFFALSE 3101
// result := false else
3091: LD_ADDR_VAR 0 2
3095: PUSH
3096: LD_INT 0
3098: ST_TO_ADDR
3099: GO 3218
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3101: LD_ADDR_VAR 0 4
3105: PUSH
3106: LD_INT 22
3108: PUSH
3109: LD_VAR 0 1
3113: PPUSH
3114: CALL_OW 255
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 55
3125: PUSH
3126: EMPTY
3127: LIST
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PPUSH
3133: CALL_OW 69
3137: ST_TO_ADDR
// if not filter then
3138: LD_VAR 0 4
3142: NOT
3143: IFFALSE 3155
// result := false else
3145: LD_ADDR_VAR 0 2
3149: PUSH
3150: LD_INT 0
3152: ST_TO_ADDR
3153: GO 3218
// for i = 1 to filter do
3155: LD_ADDR_VAR 0 3
3159: PUSH
3160: DOUBLE
3161: LD_INT 1
3163: DEC
3164: ST_TO_ADDR
3165: LD_VAR 0 4
3169: PUSH
3170: FOR_TO
3171: IFFALSE 3216
// if IsDriver ( filter [ i ] ) = veh then
3173: LD_VAR 0 4
3177: PUSH
3178: LD_VAR 0 3
3182: ARRAY
3183: PPUSH
3184: CALL 3223 0 1
3188: PUSH
3189: LD_VAR 0 1
3193: EQUAL
3194: IFFALSE 3214
// begin result := filter [ i ] ;
3196: LD_ADDR_VAR 0 2
3200: PUSH
3201: LD_VAR 0 4
3205: PUSH
3206: LD_VAR 0 3
3210: ARRAY
3211: ST_TO_ADDR
// break ;
3212: GO 3216
// end ;
3214: GO 3170
3216: POP
3217: POP
// end ; end ;
3218: LD_VAR 0 2
3222: RET
// export function IsDriver ( unit ) ; begin
3223: LD_INT 0
3225: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3226: LD_VAR 0 1
3230: PUSH
3231: LD_INT 55
3233: PUSH
3234: EMPTY
3235: LIST
3236: PPUSH
3237: CALL_OW 69
3241: IN
3242: IFFALSE 3261
// result := IsInUnit ( unit ) else
3244: LD_ADDR_VAR 0 2
3248: PUSH
3249: LD_VAR 0 1
3253: PPUSH
3254: CALL_OW 310
3258: ST_TO_ADDR
3259: GO 3269
// result := false ;
3261: LD_ADDR_VAR 0 2
3265: PUSH
3266: LD_INT 0
3268: ST_TO_ADDR
// end ;
3269: LD_VAR 0 2
3273: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
3274: LD_INT 0
3276: PPUSH
3277: PPUSH
3278: PPUSH
3279: PPUSH
// if pos < 1 then
3280: LD_VAR 0 2
3284: PUSH
3285: LD_INT 1
3287: LESS
3288: IFFALSE 3292
// exit ;
3290: GO 3595
// if pos = 1 then
3292: LD_VAR 0 2
3296: PUSH
3297: LD_INT 1
3299: EQUAL
3300: IFFALSE 3333
// result := Replace ( arr , pos [ 1 ] , value ) else
3302: LD_ADDR_VAR 0 4
3306: PUSH
3307: LD_VAR 0 1
3311: PPUSH
3312: LD_VAR 0 2
3316: PUSH
3317: LD_INT 1
3319: ARRAY
3320: PPUSH
3321: LD_VAR 0 3
3325: PPUSH
3326: CALL_OW 1
3330: ST_TO_ADDR
3331: GO 3595
// begin tmp := arr ;
3333: LD_ADDR_VAR 0 6
3337: PUSH
3338: LD_VAR 0 1
3342: ST_TO_ADDR
// s_arr := [ tmp ] ;
3343: LD_ADDR_VAR 0 7
3347: PUSH
3348: LD_VAR 0 6
3352: PUSH
3353: EMPTY
3354: LIST
3355: ST_TO_ADDR
// for i = 1 to pos - 1 do
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: DOUBLE
3362: LD_INT 1
3364: DEC
3365: ST_TO_ADDR
3366: LD_VAR 0 2
3370: PUSH
3371: LD_INT 1
3373: MINUS
3374: PUSH
3375: FOR_TO
3376: IFFALSE 3421
// begin tmp := tmp [ pos [ i ] ] ;
3378: LD_ADDR_VAR 0 6
3382: PUSH
3383: LD_VAR 0 6
3387: PUSH
3388: LD_VAR 0 2
3392: PUSH
3393: LD_VAR 0 5
3397: ARRAY
3398: ARRAY
3399: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
3400: LD_ADDR_VAR 0 7
3404: PUSH
3405: LD_VAR 0 7
3409: PUSH
3410: LD_VAR 0 6
3414: PUSH
3415: EMPTY
3416: LIST
3417: ADD
3418: ST_TO_ADDR
// end ;
3419: GO 3375
3421: POP
3422: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
3423: LD_ADDR_VAR 0 6
3427: PUSH
3428: LD_VAR 0 6
3432: PPUSH
3433: LD_VAR 0 2
3437: PUSH
3438: LD_VAR 0 2
3442: ARRAY
3443: PPUSH
3444: LD_VAR 0 3
3448: PPUSH
3449: CALL_OW 1
3453: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
3454: LD_ADDR_VAR 0 7
3458: PUSH
3459: LD_VAR 0 7
3463: PPUSH
3464: LD_VAR 0 7
3468: PPUSH
3469: LD_VAR 0 6
3473: PPUSH
3474: CALL_OW 1
3478: ST_TO_ADDR
// for i = s_arr downto 2 do
3479: LD_ADDR_VAR 0 5
3483: PUSH
3484: DOUBLE
3485: LD_VAR 0 7
3489: INC
3490: ST_TO_ADDR
3491: LD_INT 2
3493: PUSH
3494: FOR_DOWNTO
3495: IFFALSE 3579
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
3497: LD_ADDR_VAR 0 6
3501: PUSH
3502: LD_VAR 0 7
3506: PUSH
3507: LD_VAR 0 5
3511: PUSH
3512: LD_INT 1
3514: MINUS
3515: ARRAY
3516: PPUSH
3517: LD_VAR 0 2
3521: PUSH
3522: LD_VAR 0 5
3526: PUSH
3527: LD_INT 1
3529: MINUS
3530: ARRAY
3531: PPUSH
3532: LD_VAR 0 7
3536: PUSH
3537: LD_VAR 0 5
3541: ARRAY
3542: PPUSH
3543: CALL_OW 1
3547: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
3548: LD_ADDR_VAR 0 7
3552: PUSH
3553: LD_VAR 0 7
3557: PPUSH
3558: LD_VAR 0 5
3562: PUSH
3563: LD_INT 1
3565: MINUS
3566: PPUSH
3567: LD_VAR 0 6
3571: PPUSH
3572: CALL_OW 1
3576: ST_TO_ADDR
// end ;
3577: GO 3494
3579: POP
3580: POP
// result := s_arr [ 1 ] ;
3581: LD_ADDR_VAR 0 4
3585: PUSH
3586: LD_VAR 0 7
3590: PUSH
3591: LD_INT 1
3593: ARRAY
3594: ST_TO_ADDR
// end ; end ;
3595: LD_VAR 0 4
3599: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
3600: LD_VAR 0 1
3604: PUSH
3605: LD_EXP 4
3609: IN
3610: NOT
3611: IFFALSE 3642
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
3613: LD_ADDR_EXP 4
3617: PUSH
3618: LD_EXP 4
3622: PPUSH
3623: LD_EXP 4
3627: PUSH
3628: LD_INT 1
3630: PLUS
3631: PPUSH
3632: LD_VAR 0 1
3636: PPUSH
3637: CALL_OW 2
3641: ST_TO_ADDR
// end ;
3642: PPOPN 1
3644: END
// export function DestinationReachable ( unit , x , y ) ; begin
3645: LD_INT 0
3647: PPUSH
// if unit in unreachableList then
3648: LD_VAR 0 1
3652: PUSH
3653: LD_EXP 4
3657: IN
3658: IFFALSE 3676
// unreachableList := unreachableList diff unit ;
3660: LD_ADDR_EXP 4
3664: PUSH
3665: LD_EXP 4
3669: PUSH
3670: LD_VAR 0 1
3674: DIFF
3675: ST_TO_ADDR
// if ValidHex ( x , y ) then
3676: LD_VAR 0 2
3680: PPUSH
3681: LD_VAR 0 3
3685: PPUSH
3686: CALL_OW 488
3690: IFFALSE 3716
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
3692: LD_VAR 0 1
3696: PPUSH
3697: LD_VAR 0 2
3701: PPUSH
3702: LD_VAR 0 3
3706: PPUSH
3707: CALL_OW 428
3711: PPUSH
3712: CALL_OW 115
// Wait ( 3 ) ;
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 67
// if unit in unreachableList then
3723: LD_VAR 0 1
3727: PUSH
3728: LD_EXP 4
3732: IN
3733: IFFALSE 3745
// result := false else
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: LD_INT 0
3742: ST_TO_ADDR
3743: GO 3753
// result := true ;
3745: LD_ADDR_VAR 0 4
3749: PUSH
3750: LD_INT 1
3752: ST_TO_ADDR
// end ;
3753: LD_VAR 0 4
3757: RET
// export function ComBombAttack ( unit , side ) ; var i , enemy , t , x , y , change_target_counter , last_target ; begin
3758: LD_INT 0
3760: PPUSH
3761: PPUSH
3762: PPUSH
3763: PPUSH
3764: PPUSH
3765: PPUSH
3766: PPUSH
3767: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
3768: LD_ADDR_VAR 0 5
3772: PUSH
3773: LD_INT 22
3775: PUSH
3776: LD_VAR 0 2
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PPUSH
3785: CALL_OW 69
3789: ST_TO_ADDR
// change_target_counter := 0 ;
3790: LD_ADDR_VAR 0 9
3794: PUSH
3795: LD_INT 0
3797: ST_TO_ADDR
// last_target := 0 ;
3798: LD_ADDR_VAR 0 10
3802: PUSH
3803: LD_INT 0
3805: ST_TO_ADDR
// if not enemy then
3806: LD_VAR 0 5
3810: NOT
3811: IFFALSE 3815
// exit ;
3813: GO 4020
// while ( IsLive ( unit ) and change_target_counter < 4 ) do
3815: LD_VAR 0 1
3819: PPUSH
3820: CALL_OW 300
3824: PUSH
3825: LD_VAR 0 9
3829: PUSH
3830: LD_INT 4
3832: LESS
3833: AND
3834: IFFALSE 4020
// begin if UnitFilter ( enemy , [ f_occupied ] ) then
3836: LD_VAR 0 5
3840: PPUSH
3841: LD_INT 59
3843: PUSH
3844: EMPTY
3845: LIST
3846: PPUSH
3847: CALL_OW 72
3851: IFFALSE 3987
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
3853: LD_ADDR_VAR 0 6
3857: PUSH
3858: LD_VAR 0 5
3862: PPUSH
3863: LD_INT 59
3865: PUSH
3866: EMPTY
3867: LIST
3868: PPUSH
3869: CALL_OW 72
3873: PPUSH
3874: LD_VAR 0 1
3878: PPUSH
3879: CALL_OW 74
3883: ST_TO_ADDR
// if ( last_target <> t ) then
3884: LD_VAR 0 10
3888: PUSH
3889: LD_VAR 0 6
3893: NONEQUAL
3894: IFFALSE 3910
// change_target_counter := change_target_counter + 1 ;
3896: LD_ADDR_VAR 0 9
3900: PUSH
3901: LD_VAR 0 9
3905: PUSH
3906: LD_INT 1
3908: PLUS
3909: ST_TO_ADDR
// last_target := t ;
3910: LD_ADDR_VAR 0 10
3914: PUSH
3915: LD_VAR 0 6
3919: ST_TO_ADDR
// x := GetX ( t ) ;
3920: LD_ADDR_VAR 0 7
3924: PUSH
3925: LD_VAR 0 6
3929: PPUSH
3930: CALL_OW 250
3934: ST_TO_ADDR
// y := GetY ( t ) ;
3935: LD_ADDR_VAR 0 8
3939: PUSH
3940: LD_VAR 0 6
3944: PPUSH
3945: CALL_OW 251
3949: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
3950: LD_VAR 0 1
3954: PPUSH
3955: LD_VAR 0 7
3959: PPUSH
3960: LD_VAR 0 8
3964: PPUSH
3965: CALL 3645 0 3
3969: IFFALSE 3985
// ComAttackUnit ( unit , t ) ;
3971: LD_VAR 0 1
3975: PPUSH
3976: LD_VAR 0 6
3980: PPUSH
3981: CALL_OW 115
// end else
3985: GO 4011
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
3987: LD_VAR 0 1
3991: PPUSH
3992: LD_VAR 0 5
3996: PPUSH
3997: LD_VAR 0 1
4001: PPUSH
4002: CALL_OW 74
4006: PPUSH
4007: CALL_OW 115
// Wait ( 0 0$0.3 ) ;
4011: LD_INT 10
4013: PPUSH
4014: CALL_OW 67
// end ;
4018: GO 3815
// end ;
4020: LD_VAR 0 3
4024: RET
// export function ComBrutalAttack ( units , side ) ; var i , enemy , t , x , y , target , unit ; begin
4025: LD_INT 0
4027: PPUSH
4028: PPUSH
4029: PPUSH
4030: PPUSH
4031: PPUSH
4032: PPUSH
4033: PPUSH
4034: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
4035: LD_ADDR_VAR 0 5
4039: PUSH
4040: LD_INT 22
4042: PUSH
4043: LD_VAR 0 2
4047: PUSH
4048: EMPTY
4049: LIST
4050: LIST
4051: PPUSH
4052: CALL_OW 69
4056: ST_TO_ADDR
// target := 0 ;
4057: LD_ADDR_VAR 0 9
4061: PUSH
4062: LD_INT 0
4064: ST_TO_ADDR
// if not enemy then
4065: LD_VAR 0 5
4069: NOT
4070: IFFALSE 4074
// exit ;
4072: GO 4655
// while units do
4074: LD_VAR 0 1
4078: IFFALSE 4655
// begin wait ( 0 0$0.3 ) ;
4080: LD_INT 10
4082: PPUSH
4083: CALL_OW 67
// for unit in units do
4087: LD_ADDR_VAR 0 10
4091: PUSH
4092: LD_VAR 0 1
4096: PUSH
4097: FOR_IN
4098: IFFALSE 4651
// begin if not IsPlaced ( unit ) then
4100: LD_VAR 0 10
4104: PPUSH
4105: CALL_OW 305
4109: NOT
4110: IFFALSE 4130
// begin units := units diff unit ;
4112: LD_ADDR_VAR 0 1
4116: PUSH
4117: LD_VAR 0 1
4121: PUSH
4122: LD_VAR 0 10
4126: DIFF
4127: ST_TO_ADDR
// continue ;
4128: GO 4097
// end ; if not IsPlaced ( target ) then
4130: LD_VAR 0 9
4134: PPUSH
4135: CALL_OW 305
4139: NOT
4140: IFFALSE 4150
// target := 0 ;
4142: LD_ADDR_VAR 0 9
4146: PUSH
4147: LD_INT 0
4149: ST_TO_ADDR
// if not target and UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) then
4150: LD_VAR 0 9
4154: NOT
4155: PUSH
4156: LD_VAR 0 5
4160: PPUSH
4161: LD_INT 21
4163: PUSH
4164: LD_INT 1
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 3
4173: PUSH
4174: LD_INT 54
4176: PUSH
4177: EMPTY
4178: LIST
4179: PUSH
4180: EMPTY
4181: LIST
4182: LIST
4183: PUSH
4184: EMPTY
4185: LIST
4186: LIST
4187: PPUSH
4188: CALL_OW 72
4192: AND
4193: IFFALSE 4419
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , unit ) ;
4195: LD_ADDR_VAR 0 6
4199: PUSH
4200: LD_VAR 0 5
4204: PPUSH
4205: LD_INT 21
4207: PUSH
4208: LD_INT 1
4210: PUSH
4211: EMPTY
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 3
4217: PUSH
4218: LD_INT 54
4220: PUSH
4221: EMPTY
4222: LIST
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PPUSH
4232: CALL_OW 72
4236: PPUSH
4237: LD_VAR 0 10
4241: PPUSH
4242: CALL_OW 74
4246: ST_TO_ADDR
// x := GetX ( t ) ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: LD_VAR 0 6
4256: PPUSH
4257: CALL_OW 250
4261: ST_TO_ADDR
// y := GetY ( t ) ;
4262: LD_ADDR_VAR 0 8
4266: PUSH
4267: LD_VAR 0 6
4271: PPUSH
4272: CALL_OW 251
4276: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
4277: LD_VAR 0 10
4281: PPUSH
4282: LD_VAR 0 7
4286: PPUSH
4287: LD_VAR 0 8
4291: PPUSH
4292: CALL 3645 0 3
4296: IFFALSE 4310
// target := t else
4298: LD_ADDR_VAR 0 9
4302: PUSH
4303: LD_VAR 0 6
4307: ST_TO_ADDR
4308: GO 4419
// if UnitFilter ( enemy , [ f_occupied ] ) then
4310: LD_VAR 0 5
4314: PPUSH
4315: LD_INT 59
4317: PUSH
4318: EMPTY
4319: LIST
4320: PPUSH
4321: CALL_OW 72
4325: IFFALSE 4419
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
4327: LD_ADDR_VAR 0 6
4331: PUSH
4332: LD_VAR 0 5
4336: PPUSH
4337: LD_INT 59
4339: PUSH
4340: EMPTY
4341: LIST
4342: PPUSH
4343: CALL_OW 72
4347: PPUSH
4348: LD_VAR 0 10
4352: PPUSH
4353: CALL_OW 74
4357: ST_TO_ADDR
// x := GetX ( t ) ;
4358: LD_ADDR_VAR 0 7
4362: PUSH
4363: LD_VAR 0 6
4367: PPUSH
4368: CALL_OW 250
4372: ST_TO_ADDR
// y := GetY ( t ) ;
4373: LD_ADDR_VAR 0 8
4377: PUSH
4378: LD_VAR 0 6
4382: PPUSH
4383: CALL_OW 251
4387: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
4388: LD_VAR 0 10
4392: PPUSH
4393: LD_VAR 0 7
4397: PPUSH
4398: LD_VAR 0 8
4402: PPUSH
4403: CALL 3645 0 3
4407: IFFALSE 4419
// target := t ;
4409: LD_ADDR_VAR 0 9
4413: PUSH
4414: LD_VAR 0 6
4418: ST_TO_ADDR
// end ; end ; if not target or not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
4419: LD_VAR 0 9
4423: NOT
4424: PUSH
4425: LD_VAR 0 10
4429: PPUSH
4430: LD_VAR 0 9
4434: PPUSH
4435: CALL_OW 250
4439: PPUSH
4440: LD_VAR 0 9
4444: PPUSH
4445: CALL_OW 251
4449: PPUSH
4450: CALL 3645 0 3
4454: NOT
4455: OR
4456: IFFALSE 4490
// target := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
4458: LD_ADDR_VAR 0 9
4462: PUSH
4463: LD_INT 22
4465: PUSH
4466: LD_VAR 0 2
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PPUSH
4475: CALL_OW 69
4479: PPUSH
4480: LD_VAR 0 10
4484: PPUSH
4485: CALL_OW 74
4489: ST_TO_ADDR
// if ( GetDistUnits ( target , unit ) < 4 and GetLives ( unit ) < 600 ) or GetLives ( unit ) < 200 then
4490: LD_VAR 0 9
4494: PPUSH
4495: LD_VAR 0 10
4499: PPUSH
4500: CALL_OW 296
4504: PUSH
4505: LD_INT 4
4507: LESS
4508: PUSH
4509: LD_VAR 0 10
4513: PPUSH
4514: CALL_OW 256
4518: PUSH
4519: LD_INT 600
4521: LESS
4522: AND
4523: PUSH
4524: LD_VAR 0 10
4528: PPUSH
4529: CALL_OW 256
4533: PUSH
4534: LD_INT 200
4536: LESS
4537: OR
4538: IFFALSE 4589
// begin for i = 1 to 4 do
4540: LD_ADDR_VAR 0 4
4544: PUSH
4545: DOUBLE
4546: LD_INT 1
4548: DEC
4549: ST_TO_ADDR
4550: LD_INT 4
4552: PUSH
4553: FOR_TO
4554: IFFALSE 4585
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
4556: LD_VAR 0 10
4560: PPUSH
4561: CALL_OW 250
4565: PPUSH
4566: LD_VAR 0 10
4570: PPUSH
4571: CALL_OW 251
4575: PPUSH
4576: LD_INT 1
4578: PPUSH
4579: CALL_OW 453
4583: GO 4553
4585: POP
4586: POP
// end else
4587: GO 4649
// if GetType ( target ) <> unit_human then
4589: LD_VAR 0 9
4593: PPUSH
4594: CALL_OW 247
4598: PUSH
4599: LD_INT 1
4601: NONEQUAL
4602: IFFALSE 4620
// ComAttackUnit ( unit , target ) else
4604: LD_VAR 0 10
4608: PPUSH
4609: LD_VAR 0 9
4613: PPUSH
4614: CALL_OW 115
4618: GO 4649
// ComMoveXY ( unit , GetX ( target ) , GetY ( target ) ) ;
4620: LD_VAR 0 10
4624: PPUSH
4625: LD_VAR 0 9
4629: PPUSH
4630: CALL_OW 250
4634: PPUSH
4635: LD_VAR 0 9
4639: PPUSH
4640: CALL_OW 251
4644: PPUSH
4645: CALL_OW 111
// end ;
4649: GO 4097
4651: POP
4652: POP
// end ;
4653: GO 4074
// end ; end_of_file
4655: LD_VAR 0 3
4659: RET
// export function Action ; var dial ; begin
4660: LD_INT 0
4662: PPUSH
4663: PPUSH
// CenterNowOnXY ( 192 , 1 ) ;
4664: LD_INT 192
4666: PPUSH
4667: LD_INT 1
4669: PPUSH
4670: CALL_OW 86
// InGameOn ;
4674: CALL_OW 8
// case query ( textdiff ) of 1 :
4678: LD_STRING textdiff
4680: PPUSH
4681: CALL_OW 97
4685: PUSH
4686: LD_INT 1
4688: DOUBLE
4689: EQUAL
4690: IFTRUE 4694
4692: GO 4705
4694: POP
// Difficulty := 1 ; 2 :
4695: LD_ADDR_OWVAR 67
4699: PUSH
4700: LD_INT 1
4702: ST_TO_ADDR
4703: GO 4744
4705: LD_INT 2
4707: DOUBLE
4708: EQUAL
4709: IFTRUE 4713
4711: GO 4724
4713: POP
// Difficulty := 2 ; 3 :
4714: LD_ADDR_OWVAR 67
4718: PUSH
4719: LD_INT 2
4721: ST_TO_ADDR
4722: GO 4744
4724: LD_INT 3
4726: DOUBLE
4727: EQUAL
4728: IFTRUE 4732
4730: GO 4743
4732: POP
// Difficulty := 3 ; end ;
4733: LD_ADDR_OWVAR 67
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
4741: GO 4744
4743: POP
// case query ( info ) of 1 :
4744: LD_STRING info
4746: PPUSH
4747: CALL_OW 97
4751: PUSH
4752: LD_INT 1
4754: DOUBLE
4755: EQUAL
4756: IFTRUE 4760
4758: GO 4763
4760: POP
// ; end ;
4761: GO 4764
4763: POP
// PrepareRussian ;
4764: CALL 1849 0 0
// dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Davidov ;
4768: LD_ADDR_VAR 0 2
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 6
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_EXP 3
4806: DIFF
4807: ST_TO_ADDR
// ComMoveXY ( dial [ 1 ] , 202 , 40 ) ;
4808: LD_VAR 0 2
4812: PUSH
4813: LD_INT 1
4815: ARRAY
4816: PPUSH
4817: LD_INT 202
4819: PPUSH
4820: LD_INT 40
4822: PPUSH
4823: CALL_OW 111
// Wait ( 0 0$03 ) ;
4827: LD_INT 105
4829: PPUSH
4830: CALL_OW 67
// Say ( Davidov , DD1 ) ;
4834: LD_EXP 3
4838: PPUSH
4839: LD_STRING DD1
4841: PPUSH
4842: CALL_OW 88
// ComTurnUnit ( dial [ 1 ] , Davidov ) ;
4846: LD_VAR 0 2
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PPUSH
4855: LD_EXP 3
4859: PPUSH
4860: CALL_OW 119
// ComTurnUnit ( Davidov , dial [ 1 ] ) ;
4864: LD_EXP 3
4868: PPUSH
4869: LD_VAR 0 2
4873: PUSH
4874: LD_INT 1
4876: ARRAY
4877: PPUSH
4878: CALL_OW 119
// CenterOnXY ( 202 , 40 ) ;
4882: LD_INT 202
4884: PPUSH
4885: LD_INT 40
4887: PPUSH
4888: CALL_OW 84
// Say ( dial [ 1 ] , DV1 ) ;
4892: LD_VAR 0 2
4896: PUSH
4897: LD_INT 1
4899: ARRAY
4900: PPUSH
4901: LD_STRING DV1
4903: PPUSH
4904: CALL_OW 88
// Say ( Davidov , DD2 ) ;
4908: LD_EXP 3
4912: PPUSH
4913: LD_STRING DD2
4915: PPUSH
4916: CALL_OW 88
// Say ( dial [ 1 ] , DV2 ) ;
4920: LD_VAR 0 2
4924: PUSH
4925: LD_INT 1
4927: ARRAY
4928: PPUSH
4929: LD_STRING DV2
4931: PPUSH
4932: CALL_OW 88
// Say ( Davidov , DD3 ) ;
4936: LD_EXP 3
4940: PPUSH
4941: LD_STRING DD3
4943: PPUSH
4944: CALL_OW 88
// InGameOff ;
4948: CALL_OW 9
// Wait ( 0 0$0.3 ) ;
4952: LD_INT 10
4954: PPUSH
4955: CALL_OW 67
// ChangeMissionObjectives ( C1 ) ;
4959: LD_STRING C1
4961: PPUSH
4962: CALL_OW 337
// end ;
4966: LD_VAR 0 1
4970: RET
// every 0 0$30 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_lab ] ] ) do
4971: LD_INT 22
4973: PUSH
4974: LD_INT 6
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: PUSH
4981: LD_INT 30
4983: PUSH
4984: LD_INT 6
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: EMPTY
4992: LIST
4993: LIST
4994: PPUSH
4995: CALL_OW 69
4999: IFFALSE 5016
5001: GO 5003
5003: DISABLE
// begin Say ( Davidov , DD4 ) ;
5004: LD_EXP 3
5008: PPUSH
5009: LD_STRING DD4
5011: PPUSH
5012: CALL_OW 88
// end ;
5016: END
// every 0 0$02 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_lab_siberium ] ] ) do var dial ;
5017: LD_INT 22
5019: PUSH
5020: LD_INT 6
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 30
5029: PUSH
5030: LD_INT 11
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PPUSH
5041: CALL_OW 69
5045: IFFALSE 5128
5047: GO 5049
5049: DISABLE
5050: LD_INT 0
5052: PPUSH
// begin dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Davidov ;
5053: LD_ADDR_VAR 0 1
5057: PUSH
5058: LD_INT 22
5060: PUSH
5061: LD_INT 6
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 21
5070: PUSH
5071: LD_INT 1
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: PPUSH
5082: CALL_OW 69
5086: PUSH
5087: LD_EXP 3
5091: DIFF
5092: ST_TO_ADDR
// Say ( dial [ 1 ] , DV3 ) ;
5093: LD_VAR 0 1
5097: PUSH
5098: LD_INT 1
5100: ARRAY
5101: PPUSH
5102: LD_STRING DV3
5104: PPUSH
5105: CALL_OW 88
// Say ( Davidov , DD5 ) ;
5109: LD_EXP 3
5113: PPUSH
5114: LD_STRING DD5
5116: PPUSH
5117: CALL_OW 88
// ChangeMissionObjectives ( C2 ) ;
5121: LD_STRING C2
5123: PPUSH
5124: CALL_OW 337
// end ; end_of_file
5128: PPOPN 1
5130: END
// every 0 0$22 + 0 0$2 do
5131: GO 5133
5133: DISABLE
// begin enable ;
5134: ENABLE
// CreateCratesArea ( Rand ( 4 , 5 ) , cratesArea , true ) ;
5135: LD_INT 4
5137: PPUSH
5138: LD_INT 5
5140: PPUSH
5141: CALL_OW 12
5145: PPUSH
5146: LD_INT 3
5148: PPUSH
5149: LD_INT 1
5151: PPUSH
5152: CALL_OW 55
// if tick >= 4 4$00 then
5156: LD_OWVAR 1
5160: PUSH
5161: LD_INT 8400
5163: GREATEREQUAL
5164: IFFALSE 5171
// begin disable ;
5166: DISABLE
// CratesSpawn ( ) ;
5167: CALL 5172 0 0
// end ; end ;
5171: END
// function CratesSpawn ( ) ; var i , amount , cr ; begin
5172: LD_INT 0
5174: PPUSH
5175: PPUSH
5176: PPUSH
5177: PPUSH
// amount := [ 30000 , 20000 , 10000 ] [ Difficulty ] ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_INT 30000
5185: PUSH
5186: LD_INT 20000
5188: PUSH
5189: LD_INT 10000
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: LIST
5196: PUSH
5197: LD_OWVAR 67
5201: ARRAY
5202: ST_TO_ADDR
// while amount > 0 do
5203: LD_VAR 0 3
5207: PUSH
5208: LD_INT 0
5210: GREATER
5211: IFFALSE 5281
// begin Wait ( rand ( 0 0$30 , 1 1$30 ) ) ;
5213: LD_INT 1050
5215: PPUSH
5216: LD_INT 3150
5218: PPUSH
5219: CALL_OW 12
5223: PPUSH
5224: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
5228: LD_ADDR_VAR 0 4
5232: PUSH
5233: LD_INT 1
5235: PPUSH
5236: LD_INT 5
5238: PPUSH
5239: CALL_OW 12
5243: ST_TO_ADDR
// amount := amount - ( cr * 10 ) ;
5244: LD_ADDR_VAR 0 3
5248: PUSH
5249: LD_VAR 0 3
5253: PUSH
5254: LD_VAR 0 4
5258: PUSH
5259: LD_INT 10
5261: MUL
5262: MINUS
5263: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
5264: LD_VAR 0 4
5268: PPUSH
5269: LD_INT 3
5271: PPUSH
5272: LD_INT 1
5274: PPUSH
5275: CALL_OW 55
// end ;
5279: GO 5203
// end ; end_of_file
5281: LD_VAR 0 1
5285: RET
// every 2 2$10 do
5286: GO 5288
5288: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
5289: LD_INT 1
5291: PPUSH
5292: LD_INT 210
5294: PPUSH
5295: LD_INT 110
5297: PPUSH
5298: CALL_OW 550
// Wait ( Rand ( 7 7$00 , 10 10$00 ) ) ;
5302: LD_INT 14700
5304: PPUSH
5305: LD_INT 21000
5307: PPUSH
5308: CALL_OW 12
5312: PPUSH
5313: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
5317: LD_INT 0
5319: PPUSH
5320: LD_INT 210
5322: PPUSH
5323: LD_INT 110
5325: PPUSH
5326: CALL_OW 550
// end ;
5330: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
5331: LD_INT 0
5333: PPUSH
5334: PPUSH
5335: PPUSH
5336: PPUSH
5337: PPUSH
// uc_nation = nation_nature ;
5338: LD_ADDR_OWVAR 21
5342: PUSH
5343: LD_INT 0
5345: ST_TO_ADDR
// uc_side = 0 ;
5346: LD_ADDR_OWVAR 20
5350: PUSH
5351: LD_INT 0
5353: ST_TO_ADDR
// l = 0 ;
5354: LD_ADDR_VAR 0 6
5358: PUSH
5359: LD_INT 0
5361: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
5362: LD_ADDR_OWVAR 24
5366: PUSH
5367: LD_INT 0
5369: PPUSH
5370: LD_INT 5
5372: PPUSH
5373: CALL_OW 12
5377: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
5378: LD_ADDR_OWVAR 35
5382: PUSH
5383: LD_INT 5
5385: NEG
5386: PPUSH
5387: LD_INT 5
5389: PPUSH
5390: CALL_OW 12
5394: ST_TO_ADDR
// hc_gallery =  ;
5395: LD_ADDR_OWVAR 33
5399: PUSH
5400: LD_STRING 
5402: ST_TO_ADDR
// hc_class = class_apeman ;
5403: LD_ADDR_OWVAR 28
5407: PUSH
5408: LD_INT 12
5410: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
5411: LD_ADDR_OWVAR 29
5415: PUSH
5416: LD_INT 11
5418: PPUSH
5419: LD_INT 13
5421: PPUSH
5422: CALL_OW 12
5426: PUSH
5427: LD_INT 10
5429: PPUSH
5430: LD_INT 11
5432: PPUSH
5433: CALL_OW 12
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: ST_TO_ADDR
// hc_sex = sex_male ;
5442: LD_ADDR_OWVAR 27
5446: PUSH
5447: LD_INT 1
5449: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
5450: LD_ADDR_OWVAR 31
5454: PUSH
5455: LD_INT 0
5457: PPUSH
5458: LD_INT 2
5460: PPUSH
5461: CALL_OW 12
5465: PUSH
5466: LD_INT 0
5468: PUSH
5469: LD_INT 0
5471: PUSH
5472: LD_INT 0
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: ST_TO_ADDR
// apeman = CreateHuman ;
5481: LD_ADDR_VAR 0 7
5485: PUSH
5486: CALL_OW 44
5490: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
5491: LD_VAR 0 7
5495: PPUSH
5496: LD_VAR 0 4
5500: PPUSH
5501: LD_INT 0
5503: PPUSH
5504: CALL_OW 49
// l = l + 1 ;
5508: LD_ADDR_VAR 0 6
5512: PUSH
5513: LD_VAR 0 6
5517: PUSH
5518: LD_INT 1
5520: PLUS
5521: ST_TO_ADDR
// end until l = num1 ;
5522: LD_VAR 0 6
5526: PUSH
5527: LD_VAR 0 1
5531: EQUAL
5532: IFFALSE 5362
// l = 0 ;
5534: LD_ADDR_VAR 0 6
5538: PUSH
5539: LD_INT 0
5541: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
5542: LD_ADDR_OWVAR 35
5546: PUSH
5547: LD_INT 0
5549: PPUSH
5550: LD_INT 25
5552: PPUSH
5553: CALL_OW 12
5557: ST_TO_ADDR
// hc_class = class_tiger ;
5558: LD_ADDR_OWVAR 28
5562: PUSH
5563: LD_INT 14
5565: ST_TO_ADDR
// hc_sex = sex_male ;
5566: LD_ADDR_OWVAR 27
5570: PUSH
5571: LD_INT 1
5573: ST_TO_ADDR
// hc_gallery = sandnature ;
5574: LD_ADDR_OWVAR 33
5578: PUSH
5579: LD_STRING sandnature
5581: ST_TO_ADDR
// hc_face_number = 3 ;
5582: LD_ADDR_OWVAR 34
5586: PUSH
5587: LD_INT 3
5589: ST_TO_ADDR
// tiger = CreateHuman ;
5590: LD_ADDR_VAR 0 8
5594: PUSH
5595: CALL_OW 44
5599: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
5600: LD_VAR 0 8
5604: PPUSH
5605: LD_VAR 0 4
5609: PPUSH
5610: LD_INT 0
5612: PPUSH
5613: CALL_OW 49
// l = l + 1 ;
5617: LD_ADDR_VAR 0 6
5621: PUSH
5622: LD_VAR 0 6
5626: PUSH
5627: LD_INT 1
5629: PLUS
5630: ST_TO_ADDR
// end until l = num2 ;
5631: LD_VAR 0 6
5635: PUSH
5636: LD_VAR 0 2
5640: EQUAL
5641: IFFALSE 5542
// l = 0 ;
5643: LD_ADDR_VAR 0 6
5647: PUSH
5648: LD_INT 0
5650: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
5651: LD_ADDR_OWVAR 28
5655: PUSH
5656: LD_INT 18
5658: ST_TO_ADDR
// hc_gallery = sandnature ;
5659: LD_ADDR_OWVAR 33
5663: PUSH
5664: LD_STRING sandnature
5666: ST_TO_ADDR
// hc_face_number = 1 ;
5667: LD_ADDR_OWVAR 34
5671: PUSH
5672: LD_INT 1
5674: ST_TO_ADDR
// bird = CreateHuman ;
5675: LD_ADDR_VAR 0 9
5679: PUSH
5680: CALL_OW 44
5684: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
5685: LD_VAR 0 9
5689: PPUSH
5690: LD_INT 0
5692: PPUSH
5693: CALL_OW 51
// l = l + 1 ;
5697: LD_ADDR_VAR 0 6
5701: PUSH
5702: LD_VAR 0 6
5706: PUSH
5707: LD_INT 1
5709: PLUS
5710: ST_TO_ADDR
// end until l = num3 ;
5711: LD_VAR 0 6
5715: PUSH
5716: LD_VAR 0 3
5720: EQUAL
5721: IFFALSE 5651
// hc_gallery :=  ;
5723: LD_ADDR_OWVAR 33
5727: PUSH
5728: LD_STRING 
5730: ST_TO_ADDR
// hc_name :=  ;
5731: LD_ADDR_OWVAR 26
5735: PUSH
5736: LD_STRING 
5738: ST_TO_ADDR
// end ; end_of_file
5739: LD_VAR 0 5
5743: RET
// every 0 0$01 do var timer ;
5744: GO 5746
5746: DISABLE
5747: LD_INT 0
5749: PPUSH
// begin timer := 0 0$00 ;
5750: LD_ADDR_VAR 0 1
5754: PUSH
5755: LD_INT 0
5757: ST_TO_ADDR
// while ( true ) do
5758: LD_INT 1
5760: IFFALSE 5802
// begin timer := timer + 0 0$01 ;
5762: LD_ADDR_VAR 0 1
5766: PUSH
5767: LD_VAR 0 1
5771: PUSH
5772: LD_INT 35
5774: PLUS
5775: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
5776: LD_ADDR_OWVAR 47
5780: PUSH
5781: LD_STRING #tick
5783: PUSH
5784: LD_VAR 0 1
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5793: LD_INT 35
5795: PPUSH
5796: CALL_OW 67
// end ;
5800: GO 5758
// end ;
5802: PPOPN 1
5804: END
