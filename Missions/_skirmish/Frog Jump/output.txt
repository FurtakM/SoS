// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// debug := false ;
   8: LD_ADDR_EXP 6
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// InitVariables ;
  16: CALL 94 0 0
// InitArtifactsPos ;
  20: CALL 9054 0 0
// PrepareAnimals ( 6 , 1 , 1 , cratesArea ) ;
  24: LD_INT 6
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 1
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: CALL 8433 0 4
// PrepareAlliance ;
  40: CALL 339 0 0
// PrepareLegion ;
  44: CALL 1956 0 0
// if debug then
  48: LD_EXP 6
  52: IFFALSE 76
// begin alliance_attack_active := true ;
  54: LD_ADDR_EXP 9
  58: PUSH
  59: LD_INT 1
  61: ST_TO_ADDR
// Difficulty := 2 ;
  62: LD_ADDR_OWVAR 67
  66: PUSH
  67: LD_INT 2
  69: ST_TO_ADDR
// DebugMode ;
  70: CALL 11029 0 0
// end else
  74: GO 89
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  76: LD_ADDR_OWVAR 67
  80: PUSH
  81: LD_INT 0
  83: PPUSH
  84: CALL_OW 426
  88: ST_TO_ADDR
// Action ;
  89: CALL 7253 0 0
// end ;
  93: END
// export Bagins , Davidov , Vervecken ; export player_start_res_sib_bomb , player_start_res_artifact , debug , legion_attacks_active , legion_attack_strenght , alliance_attack_active , alliance_used_artifact_1 , alliance_used_artifact_2 , player_used_sib_bomb , artifacts_mode , artifacts_type , artifacts_pos , artifact_destroyed , sib_rocket_range , player_artifact_loaded , player_artifact_number , player_artifact_icon , player_artifact_icon_2 , player_artifact_researched , player_artifact_active_distance , player_artifact_icon_type , player_artifact_icon_res , player_artifact_time_refresh , player_artifact_time_res , player_side , player_artifact_ready , player_artifact_selected_unit , alliance_attack_strength ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// player_start_res_sib_bomb := false ;
  97: LD_ADDR_EXP 4
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// player_start_res_artifact := false ;
 105: LD_ADDR_EXP 5
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// legion_attacks_active := false ;
 113: LD_ADDR_EXP 7
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// legion_attack_strenght := 3 ;
 121: LD_ADDR_EXP 8
 125: PUSH
 126: LD_INT 3
 128: ST_TO_ADDR
// alliance_attack_strength := 0 ;
 129: LD_ADDR_EXP 31
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// alliance_attack_active := false ;
 137: LD_ADDR_EXP 9
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// alliance_used_artifact_1 := false ;
 145: LD_ADDR_EXP 10
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// alliance_used_artifact_2 := false ;
 153: LD_ADDR_EXP 11
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// artifacts_mode := [ 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: EMPTY
 176: LIST
 177: LIST
 178: LIST
 179: ST_TO_ADDR
// artifacts_type := [ 2 , 3 , 5 ] ;
 180: LD_ADDR_EXP 14
 184: PUSH
 185: LD_INT 2
 187: PUSH
 188: LD_INT 3
 190: PUSH
 191: LD_INT 5
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// artifacts_pos := [ ] ;
 199: LD_ADDR_EXP 15
 203: PUSH
 204: EMPTY
 205: ST_TO_ADDR
// artifact_destroyed := false ;
 206: LD_ADDR_EXP 16
 210: PUSH
 211: LD_INT 0
 213: ST_TO_ADDR
// sib_rocket_range := 25 ;
 214: LD_ADDR_EXP 17
 218: PUSH
 219: LD_INT 25
 221: ST_TO_ADDR
// player_used_sib_bomb := false ;
 222: LD_ADDR_EXP 12
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// player_artifact_loaded := true ;
 230: LD_ADDR_EXP 18
 234: PUSH
 235: LD_INT 1
 237: ST_TO_ADDR
// player_artifact_number := 6 ;
 238: LD_ADDR_EXP 19
 242: PUSH
 243: LD_INT 6
 245: ST_TO_ADDR
// player_artifact_icon := art_use_human ;
 246: LD_ADDR_EXP 20
 250: PUSH
 251: LD_INT 10
 253: ST_TO_ADDR
// player_artifact_icon_2 := art_use_teleport ;
 254: LD_ADDR_EXP 21
 258: PUSH
 259: LD_INT 6
 261: ST_TO_ADDR
// player_artifact_researched := false ;
 262: LD_ADDR_EXP 22
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// player_artifact_active_distance := 5 ;
 270: LD_ADDR_EXP 23
 274: PUSH
 275: LD_INT 5
 277: ST_TO_ADDR
// player_artifact_time_refresh := 8500 ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 8500
 285: ST_TO_ADDR
// player_artifact_icon_type := art_place ;
 286: LD_ADDR_EXP 24
 290: PUSH
 291: LD_INT 3
 293: ST_TO_ADDR
// player_artifact_icon_res := art_exp_left ;
 294: LD_ADDR_EXP 25
 298: PUSH
 299: LD_INT 1
 301: ST_TO_ADDR
// player_artifact_time_res := 300 ;
 302: LD_ADDR_EXP 27
 306: PUSH
 307: LD_INT 300
 309: ST_TO_ADDR
// player_artifact_ready := false ;
 310: LD_ADDR_EXP 29
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// player_artifact_selected_unit := 0 ;
 318: LD_ADDR_EXP 30
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// player_side := 6 ;
 326: LD_ADDR_EXP 28
 330: PUSH
 331: LD_INT 6
 333: ST_TO_ADDR
// end ; end_of_file
 334: LD_VAR 0 1
 338: RET
// export al_force ; export function PrepareAlliance ; var i , un , skill ; begin
 339: LD_INT 0
 341: PPUSH
 342: PPUSH
 343: PPUSH
 344: PPUSH
// uc_side := 7 ;
 345: LD_ADDR_OWVAR 20
 349: PUSH
 350: LD_INT 7
 352: ST_TO_ADDR
// uc_nation := nation_american ;
 353: LD_ADDR_OWVAR 21
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
 361: LD_ADDR_VAR 0 4
 365: PUSH
 366: LD_INT 7
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 9
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: PUSH
 380: LD_OWVAR 67
 384: ARRAY
 385: ST_TO_ADDR
// al_force := [ ] ;
 386: LD_ADDR_EXP 32
 390: PUSH
 391: EMPTY
 392: ST_TO_ADDR
// SetResourceType ( GetBase ( al_dep ) , mat_cans , 999999 ) ;
 393: LD_INT 1
 395: PPUSH
 396: CALL_OW 274
 400: PPUSH
 401: LD_INT 1
 403: PPUSH
 404: LD_INT 999999
 406: PPUSH
 407: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_oil , 10000 ) ;
 411: LD_INT 1
 413: PPUSH
 414: CALL_OW 274
 418: PPUSH
 419: LD_INT 2
 421: PPUSH
 422: LD_INT 10000
 424: PPUSH
 425: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_siberit , 10000 ) ;
 429: LD_INT 1
 431: PPUSH
 432: CALL_OW 274
 436: PPUSH
 437: LD_INT 3
 439: PPUSH
 440: LD_INT 10000
 442: PPUSH
 443: CALL_OW 277
// hc_gallery := sandal ;
 447: LD_ADDR_OWVAR 33
 451: PUSH
 452: LD_STRING sandal
 454: ST_TO_ADDR
// hc_face_number := 13 ;
 455: LD_ADDR_OWVAR 34
 459: PUSH
 460: LD_INT 13
 462: ST_TO_ADDR
// hc_class := 1 ;
 463: LD_ADDR_OWVAR 28
 467: PUSH
 468: LD_INT 1
 470: ST_TO_ADDR
// hc_name := Matthew Bagins ;
 471: LD_ADDR_OWVAR 26
 475: PUSH
 476: LD_STRING Matthew Bagins
 478: ST_TO_ADDR
// hc_skills := [ 10 , 5 , 8 , 5 ] ;
 479: LD_ADDR_OWVAR 31
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: LD_INT 5
 489: PUSH
 490: LD_INT 8
 492: PUSH
 493: LD_INT 5
 495: PUSH
 496: EMPTY
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: ST_TO_ADDR
// hc_attr := [ 11 , 12 ] ;
 502: LD_ADDR_OWVAR 29
 506: PUSH
 507: LD_INT 11
 509: PUSH
 510: LD_INT 12
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: ST_TO_ADDR
// Bagins := CreateHuman ;
 517: LD_ADDR_EXP 1
 521: PUSH
 522: CALL_OW 44
 526: ST_TO_ADDR
// PlaceHumanInUnit ( Bagins , al_dep ) ;
 527: LD_EXP 1
 531: PPUSH
 532: LD_INT 1
 534: PPUSH
 535: CALL_OW 52
// hc_gallery :=  ;
 539: LD_ADDR_OWVAR 33
 543: PUSH
 544: LD_STRING 
 546: ST_TO_ADDR
// hc_name :=  ;
 547: LD_ADDR_OWVAR 26
 551: PUSH
 552: LD_STRING 
 554: ST_TO_ADDR
// for i = 1 to 6 do
 555: LD_ADDR_VAR 0 2
 559: PUSH
 560: DOUBLE
 561: LD_INT 1
 563: DEC
 564: ST_TO_ADDR
 565: LD_INT 6
 567: PUSH
 568: FOR_TO
 569: IFFALSE 630
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 571: LD_ADDR_OWVAR 21
 575: PUSH
 576: LD_INT 1
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: PUSH
 586: LD_INT 1
 588: PPUSH
 589: LD_INT 2
 591: PPUSH
 592: CALL_OW 12
 596: ARRAY
 597: ST_TO_ADDR
// PrepareHuman ( false , class_engineer , skill ) ;
 598: LD_INT 0
 600: PPUSH
 601: LD_INT 2
 603: PPUSH
 604: LD_VAR 0 4
 608: PPUSH
 609: CALL_OW 380
// PlaceUnitArea ( CreateHuman , al_base , false ) ;
 613: CALL_OW 44
 617: PPUSH
 618: LD_INT 1
 620: PPUSH
 621: LD_INT 0
 623: PPUSH
 624: CALL_OW 49
// end ;
 628: GO 568
 630: POP
 631: POP
// for i = 1 to 6 do
 632: LD_ADDR_VAR 0 2
 636: PUSH
 637: DOUBLE
 638: LD_INT 1
 640: DEC
 641: ST_TO_ADDR
 642: LD_INT 6
 644: PUSH
 645: FOR_TO
 646: IFFALSE 704
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 648: LD_ADDR_OWVAR 21
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 3
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: PUSH
 663: LD_INT 1
 665: PPUSH
 666: LD_INT 2
 668: PPUSH
 669: CALL_OW 12
 673: ARRAY
 674: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 675: LD_INT 0
 677: PPUSH
 678: LD_INT 3
 680: PPUSH
 681: LD_VAR 0 4
 685: PPUSH
 686: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_ru ) ;
 690: CALL_OW 44
 694: PPUSH
 695: LD_INT 6
 697: PPUSH
 698: CALL_OW 52
// end ;
 702: GO 645
 704: POP
 705: POP
// for i = 1 to 6 do
 706: LD_ADDR_VAR 0 2
 710: PUSH
 711: DOUBLE
 712: LD_INT 1
 714: DEC
 715: ST_TO_ADDR
 716: LD_INT 6
 718: PUSH
 719: FOR_TO
 720: IFFALSE 778
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 722: LD_ADDR_OWVAR 21
 726: PUSH
 727: LD_INT 1
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: PUSH
 737: LD_INT 1
 739: PPUSH
 740: LD_INT 2
 742: PPUSH
 743: CALL_OW 12
 747: ARRAY
 748: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 749: LD_INT 0
 751: PPUSH
 752: LD_INT 3
 754: PPUSH
 755: LD_VAR 0 4
 759: PPUSH
 760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_us ) ;
 764: CALL_OW 44
 768: PPUSH
 769: LD_INT 11
 771: PPUSH
 772: CALL_OW 52
// end ;
 776: GO 719
 778: POP
 779: POP
// for i = 1 to 6 do
 780: LD_ADDR_VAR 0 2
 784: PUSH
 785: DOUBLE
 786: LD_INT 1
 788: DEC
 789: ST_TO_ADDR
 790: LD_INT 6
 792: PUSH
 793: FOR_TO
 794: IFFALSE 871
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 796: LD_ADDR_OWVAR 21
 800: PUSH
 801: LD_INT 1
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: PUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 2
 816: PPUSH
 817: CALL_OW 12
 821: ARRAY
 822: ST_TO_ADDR
// PrepareHuman ( false , class_scientistic , skill ) ;
 823: LD_INT 0
 825: PPUSH
 826: LD_INT 4
 828: PPUSH
 829: LD_VAR 0 4
 833: PPUSH
 834: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , [ al_lab_us , al_lab_ru ] [ Rand ( 1 , 2 ) ] ) ;
 838: CALL_OW 44
 842: PPUSH
 843: LD_INT 2
 845: PUSH
 846: LD_INT 5
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_INT 2
 858: PPUSH
 859: CALL_OW 12
 863: ARRAY
 864: PPUSH
 865: CALL_OW 52
// end ;
 869: GO 793
 871: POP
 872: POP
// for i = 1 to 6 do
 873: LD_ADDR_VAR 0 2
 877: PUSH
 878: DOUBLE
 879: LD_INT 1
 881: DEC
 882: ST_TO_ADDR
 883: LD_INT 6
 885: PUSH
 886: FOR_TO
 887: IFFALSE 994
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 889: LD_ADDR_OWVAR 21
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 3
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PUSH
 904: LD_INT 1
 906: PPUSH
 907: LD_INT 2
 909: PPUSH
 910: CALL_OW 12
 914: ARRAY
 915: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker ] [ Rand ( 1 , 2 ) ] , skill ) ;
 916: LD_INT 0
 918: PPUSH
 919: LD_INT 5
 921: PUSH
 922: LD_INT 9
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PUSH
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 2
 934: PPUSH
 935: CALL_OW 12
 939: ARRAY
 940: PPUSH
 941: LD_VAR 0 4
 945: PPUSH
 946: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 950: CALL_OW 44
 954: PPUSH
 955: LD_INT 22
 957: PUSH
 958: LD_INT 7
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PUSH
 965: LD_INT 30
 967: PUSH
 968: LD_INT 5
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PPUSH
 979: CALL_OW 69
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: CALL_OW 52
// end ;
 992: GO 886
 994: POP
 995: POP
// uc_nation := 3 ;
 996: LD_ADDR_OWVAR 21
1000: PUSH
1001: LD_INT 3
1003: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , skill ) ;
1004: LD_INT 0
1006: PPUSH
1007: LD_INT 5
1009: PPUSH
1010: LD_VAR 0 4
1014: PPUSH
1015: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_bun ) ;
1019: CALL_OW 44
1023: PPUSH
1024: LD_INT 50
1026: PPUSH
1027: CALL_OW 52
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) do
1031: LD_ADDR_VAR 0 2
1035: PUSH
1036: LD_INT 22
1038: PUSH
1039: LD_INT 7
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: PUSH
1046: LD_INT 30
1048: PUSH
1049: LD_INT 33
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: PUSH
1056: EMPTY
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL_OW 69
1064: PUSH
1065: FOR_IN
1066: IFFALSE 1130
// if GetNation ( i ) = 1 then
1068: LD_VAR 0 2
1072: PPUSH
1073: CALL_OW 248
1077: PUSH
1078: LD_INT 1
1080: EQUAL
1081: IFFALSE 1097
// AddComPlaceWeapon ( i , us_double_laser ) else
1083: LD_VAR 0 2
1087: PPUSH
1088: LD_INT 10
1090: PPUSH
1091: CALL_OW 208
1095: GO 1128
// AddComPlaceWeapon ( i , [ ru_rocket , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
1097: LD_VAR 0 2
1101: PPUSH
1102: LD_INT 47
1104: PUSH
1105: LD_INT 45
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PUSH
1112: LD_INT 1
1114: PPUSH
1115: LD_INT 2
1117: PPUSH
1118: CALL_OW 12
1122: ARRAY
1123: PPUSH
1124: CALL_OW 208
1128: GO 1065
1130: POP
1131: POP
// end ;
1132: LD_VAR 0 1
1136: RET
// export function ConstructAlVeh ( nation ) ; var i , un , fac , chassis , engine , control , weapon ; begin
1137: LD_INT 0
1139: PPUSH
1140: PPUSH
1141: PPUSH
1142: PPUSH
1143: PPUSH
1144: PPUSH
1145: PPUSH
1146: PPUSH
// if nation = 2 then
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 2
1154: EQUAL
1155: IFFALSE 1159
// exit ;
1157: GO 1378
// if nation = 1 then
1159: LD_VAR 0 1
1163: PUSH
1164: LD_INT 1
1166: EQUAL
1167: IFFALSE 1185
// if al_fac_us then
1169: LD_INT 11
1171: IFFALSE 1183
// fac := al_fac_us else
1173: LD_ADDR_VAR 0 5
1177: PUSH
1178: LD_INT 11
1180: ST_TO_ADDR
1181: GO 1185
// exit ;
1183: GO 1378
// if nation = 3 then
1185: LD_VAR 0 1
1189: PUSH
1190: LD_INT 3
1192: EQUAL
1193: IFFALSE 1211
// if al_fac_ru then
1195: LD_INT 6
1197: IFFALSE 1209
// fac := al_fac_ru else
1199: LD_ADDR_VAR 0 5
1203: PUSH
1204: LD_INT 6
1206: ST_TO_ADDR
1207: GO 1211
// exit ;
1209: GO 1378
// if nation = 1 then
1211: LD_VAR 0 1
1215: PUSH
1216: LD_INT 1
1218: EQUAL
1219: IFFALSE 1231
// chassis := us_morphling else
1221: LD_ADDR_VAR 0 6
1225: PUSH
1226: LD_INT 5
1228: ST_TO_ADDR
1229: GO 1239
// chassis := ru_heavy_tracked ;
1231: LD_ADDR_VAR 0 6
1235: PUSH
1236: LD_INT 24
1238: ST_TO_ADDR
// if nation = 1 then
1239: LD_VAR 0 1
1243: PUSH
1244: LD_INT 1
1246: EQUAL
1247: IFFALSE 1259
// engine := engine_combustion else
1249: LD_ADDR_VAR 0 7
1253: PUSH
1254: LD_INT 1
1256: ST_TO_ADDR
1257: GO 1267
// engine := engine_siberite ;
1259: LD_ADDR_VAR 0 7
1263: PUSH
1264: LD_INT 3
1266: ST_TO_ADDR
// control := control_computer ;
1267: LD_ADDR_VAR 0 8
1271: PUSH
1272: LD_INT 3
1274: ST_TO_ADDR
// if nation = 3 then
1275: LD_VAR 0 1
1279: PUSH
1280: LD_INT 3
1282: EQUAL
1283: IFFALSE 1306
// weapon := [ ru_rocket , ru_rocket_launcher , ru_gatling_gun ] else
1285: LD_ADDR_VAR 0 9
1289: PUSH
1290: LD_INT 47
1292: PUSH
1293: LD_INT 45
1295: PUSH
1296: LD_INT 43
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: LIST
1303: ST_TO_ADDR
1304: GO 1325
// weapon := [ us_heavy_gun , us_laser , us_double_laser ] ;
1306: LD_ADDR_VAR 0 9
1310: PUSH
1311: LD_INT 6
1313: PUSH
1314: LD_INT 9
1316: PUSH
1317: LD_INT 10
1319: PUSH
1320: EMPTY
1321: LIST
1322: LIST
1323: LIST
1324: ST_TO_ADDR
// weapon := weapon [ rand ( 1 , weapon ) ] ;
1325: LD_ADDR_VAR 0 9
1329: PUSH
1330: LD_VAR 0 9
1334: PUSH
1335: LD_INT 1
1337: PPUSH
1338: LD_VAR 0 9
1342: PPUSH
1343: CALL_OW 12
1347: ARRAY
1348: ST_TO_ADDR
// AddComConstruct ( fac , chassis , engine , control , weapon ) ;
1349: LD_VAR 0 5
1353: PPUSH
1354: LD_VAR 0 6
1358: PPUSH
1359: LD_VAR 0 7
1363: PPUSH
1364: LD_VAR 0 8
1368: PPUSH
1369: LD_VAR 0 9
1373: PPUSH
1374: CALL_OW 185
// end ;
1378: LD_VAR 0 2
1382: RET
// every 0 0$01 trigger FilterUnitsInArea ( al_teleport_enter , [ [ f_side , 7 ] , [ f_not , [ f_type , unit_building ] ] ] ) do var tmp , i , xy ;
1383: LD_INT 4
1385: PPUSH
1386: LD_INT 22
1388: PUSH
1389: LD_INT 7
1391: PUSH
1392: EMPTY
1393: LIST
1394: LIST
1395: PUSH
1396: LD_INT 3
1398: PUSH
1399: LD_INT 21
1401: PUSH
1402: LD_INT 3
1404: PUSH
1405: EMPTY
1406: LIST
1407: LIST
1408: PUSH
1409: EMPTY
1410: LIST
1411: LIST
1412: PUSH
1413: EMPTY
1414: LIST
1415: LIST
1416: PPUSH
1417: CALL_OW 70
1421: IFFALSE 1579
1423: GO 1425
1425: DISABLE
1426: LD_INT 0
1428: PPUSH
1429: PPUSH
1430: PPUSH
// begin enable ;
1431: ENABLE
// tmp := FilterUnitsInArea ( al_teleport_enter , [ [ f_side , 7 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
1432: LD_ADDR_VAR 0 1
1436: PUSH
1437: LD_INT 4
1439: PPUSH
1440: LD_INT 22
1442: PUSH
1443: LD_INT 7
1445: PUSH
1446: EMPTY
1447: LIST
1448: LIST
1449: PUSH
1450: LD_INT 3
1452: PUSH
1453: LD_INT 21
1455: PUSH
1456: LD_INT 3
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: PPUSH
1471: CALL_OW 70
1475: ST_TO_ADDR
// xy := [ 225 , 16 ] ;
1476: LD_ADDR_VAR 0 3
1480: PUSH
1481: LD_INT 225
1483: PUSH
1484: LD_INT 16
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// if FilterUnitsInArea ( al_teleport_exit , [ f_side , 6 ] ) > 2 then
1491: LD_INT 5
1493: PPUSH
1494: LD_INT 22
1496: PUSH
1497: LD_INT 6
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: PPUSH
1504: CALL_OW 70
1508: PUSH
1509: LD_INT 2
1511: GREATER
1512: IFFALSE 1529
// xy := [ 170 , 13 ] ;
1514: LD_ADDR_VAR 0 3
1518: PUSH
1519: LD_INT 170
1521: PUSH
1522: LD_INT 13
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: ST_TO_ADDR
// for i in tmp do
1529: LD_ADDR_VAR 0 2
1533: PUSH
1534: LD_VAR 0 1
1538: PUSH
1539: FOR_IN
1540: IFFALSE 1577
// TeleportUnit ( i , xy [ 1 ] , xy [ 2 ] , 12 , true ) ;
1542: LD_VAR 0 2
1546: PPUSH
1547: LD_VAR 0 3
1551: PUSH
1552: LD_INT 1
1554: ARRAY
1555: PPUSH
1556: LD_VAR 0 3
1560: PUSH
1561: LD_INT 2
1563: ARRAY
1564: PPUSH
1565: LD_INT 12
1567: PPUSH
1568: LD_INT 1
1570: PPUSH
1571: CALL_OW 483
1575: GO 1539
1577: POP
1578: POP
// end ;
1579: PPOPN 3
1581: END
// every 12 12$00 trigger FilterAllUnits ( [ f_side , 7 ] ) and alliance_attack_active do var i ;
1582: LD_INT 22
1584: PUSH
1585: LD_INT 7
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: PPUSH
1592: CALL_OW 69
1596: PUSH
1597: LD_EXP 9
1601: AND
1602: IFFALSE 1749
1604: GO 1606
1606: DISABLE
1607: LD_INT 0
1609: PPUSH
// begin enable ;
1610: ENABLE
// alliance_attack_strength := alliance_attack_strength + 1 ;
1611: LD_ADDR_EXP 31
1615: PUSH
1616: LD_EXP 31
1620: PUSH
1621: LD_INT 1
1623: PLUS
1624: ST_TO_ADDR
// for i = 1 to ( [ 4 , 5 , 5 ] [ Difficulty ] ) + alliance_attack_strength do
1625: LD_ADDR_VAR 0 1
1629: PUSH
1630: DOUBLE
1631: LD_INT 1
1633: DEC
1634: ST_TO_ADDR
1635: LD_INT 4
1637: PUSH
1638: LD_INT 5
1640: PUSH
1641: LD_INT 5
1643: PUSH
1644: EMPTY
1645: LIST
1646: LIST
1647: LIST
1648: PUSH
1649: LD_OWVAR 67
1653: ARRAY
1654: PUSH
1655: LD_EXP 31
1659: PLUS
1660: PUSH
1661: FOR_TO
1662: IFFALSE 1692
// begin ConstructAlVeh ( [ 1 , 3 ] [ rand ( 1 , 2 ) ] ) ;
1664: LD_INT 1
1666: PUSH
1667: LD_INT 3
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: PUSH
1674: LD_INT 1
1676: PPUSH
1677: LD_INT 2
1679: PPUSH
1680: CALL_OW 12
1684: ARRAY
1685: PPUSH
1686: CALL 1137 0 1
// end ;
1690: GO 1661
1692: POP
1693: POP
// repeat wait ( 0 0$01 ) ;
1694: LD_INT 35
1696: PPUSH
1697: CALL_OW 67
// until al_force >= ( [ 4 , 5 , 5 ] [ Difficulty ] ) + alliance_attack_strength ;
1701: LD_EXP 32
1705: PUSH
1706: LD_INT 4
1708: PUSH
1709: LD_INT 5
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: EMPTY
1716: LIST
1717: LIST
1718: LIST
1719: PUSH
1720: LD_OWVAR 67
1724: ARRAY
1725: PUSH
1726: LD_EXP 31
1730: PLUS
1731: GREATEREQUAL
1732: IFFALSE 1694
// AddComMoveXY ( al_force , 143 , 178 ) ;
1734: LD_EXP 32
1738: PPUSH
1739: LD_INT 143
1741: PPUSH
1742: LD_INT 178
1744: PPUSH
1745: CALL_OW 171
// end ;
1749: PPOPN 1
1751: END
// every 0 0$01 trigger FilterUnitsInArea ( islandArea , [ f_side , 7 ] ) do var i ;
1752: LD_INT 6
1754: PPUSH
1755: LD_INT 22
1757: PUSH
1758: LD_INT 7
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PPUSH
1765: CALL_OW 70
1769: IFFALSE 1849
1771: GO 1773
1773: DISABLE
1774: LD_INT 0
1776: PPUSH
// begin enable ;
1777: ENABLE
// for i in FilterUnitsInArea ( islandArea , [ f_side , 7 ] ) do
1778: LD_ADDR_VAR 0 1
1782: PUSH
1783: LD_INT 6
1785: PPUSH
1786: LD_INT 22
1788: PUSH
1789: LD_INT 7
1791: PUSH
1792: EMPTY
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL_OW 70
1800: PUSH
1801: FOR_IN
1802: IFFALSE 1847
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( i ) ] ) , i ) ) ;
1804: LD_VAR 0 1
1808: PPUSH
1809: LD_INT 81
1811: PUSH
1812: LD_VAR 0 1
1816: PPUSH
1817: CALL_OW 255
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: LD_VAR 0 1
1835: PPUSH
1836: CALL_OW 74
1840: PPUSH
1841: CALL_OW 115
1845: GO 1801
1847: POP
1848: POP
// end ;
1849: PPOPN 1
1851: END
// every 7 7$30 trigger alliance_attack_active do var reload_time ;
1852: LD_EXP 9
1856: IFFALSE 1953
1858: GO 1860
1860: DISABLE
1861: LD_INT 0
1863: PPUSH
// begin reload_time := [ 9 9$00 , 8 8$40 , 7 7$50 ] [ Difficulty ] ;
1864: LD_ADDR_VAR 0 1
1868: PUSH
1869: LD_INT 18900
1871: PUSH
1872: LD_INT 18200
1874: PUSH
1875: LD_INT 16450
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: LD_OWVAR 67
1887: ARRAY
1888: ST_TO_ADDR
// repeat ActiveArtifact1 ( ) ;
1889: CALL 10464 0 0
// wait ( reload_time / 2 ) ;
1893: LD_VAR 0 1
1897: PUSH
1898: LD_INT 2
1900: DIVREAL
1901: PPUSH
1902: CALL_OW 67
// ActiveArtifact2 ( ) ;
1906: CALL 10849 0 0
// wait ( reload_time / 2 ) ;
1910: LD_VAR 0 1
1914: PUSH
1915: LD_INT 2
1917: DIVREAL
1918: PPUSH
1919: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) ;
1923: LD_INT 22
1925: PUSH
1926: LD_INT 7
1928: PUSH
1929: EMPTY
1930: LIST
1931: LIST
1932: PUSH
1933: LD_INT 30
1935: PUSH
1936: LD_INT 8
1938: PUSH
1939: EMPTY
1940: LIST
1941: LIST
1942: PUSH
1943: EMPTY
1944: LIST
1945: LIST
1946: PPUSH
1947: CALL_OW 69
1951: IFFALSE 1889
// end ; end_of_file
1953: PPOPN 1
1955: END
// export function PrepareLegion ; var i , un , skill , dep , fac ; begin
1956: LD_INT 0
1958: PPUSH
1959: PPUSH
1960: PPUSH
1961: PPUSH
1962: PPUSH
1963: PPUSH
// uc_side := 8 ;
1964: LD_ADDR_OWVAR 20
1968: PUSH
1969: LD_INT 8
1971: ST_TO_ADDR
// uc_nation := 2 ;
1972: LD_ADDR_OWVAR 21
1976: PUSH
1977: LD_INT 2
1979: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
1980: LD_ADDR_VAR 0 4
1984: PUSH
1985: LD_INT 7
1987: PUSH
1988: LD_INT 8
1990: PUSH
1991: LD_INT 9
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: PUSH
1999: LD_OWVAR 67
2003: ARRAY
2004: ST_TO_ADDR
// dep := ar_base ;
2005: LD_ADDR_VAR 0 5
2009: PUSH
2010: LD_INT 57
2012: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
2013: LD_ADDR_VAR 0 6
2017: PUSH
2018: LD_INT 22
2020: PUSH
2021: LD_INT 8
2023: PUSH
2024: EMPTY
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: PPUSH
2042: CALL_OW 69
2046: PUSH
2047: LD_INT 1
2049: ARRAY
2050: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 999999 ) ;
2051: LD_VAR 0 5
2055: PPUSH
2056: CALL_OW 274
2060: PPUSH
2061: LD_INT 1
2063: PPUSH
2064: LD_INT 999999
2066: PPUSH
2067: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
2071: LD_VAR 0 5
2075: PPUSH
2076: CALL_OW 274
2080: PPUSH
2081: LD_INT 2
2083: PPUSH
2084: LD_INT 10000
2086: PPUSH
2087: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 10000 ) ;
2091: LD_VAR 0 5
2095: PPUSH
2096: CALL_OW 274
2100: PPUSH
2101: LD_INT 3
2103: PPUSH
2104: LD_INT 10000
2106: PPUSH
2107: CALL_OW 277
// TeleportExit ( legion_telep , 224 , 5 ) ;
2111: LD_INT 68
2113: PPUSH
2114: LD_INT 224
2116: PPUSH
2117: LD_INT 5
2119: PPUSH
2120: CALL_OW 243
// PrepareHuman ( sex_male , 1 , 6 ) ;
2124: LD_INT 1
2126: PPUSH
2127: LD_INT 1
2129: PPUSH
2130: LD_INT 6
2132: PPUSH
2133: CALL_OW 380
// hc_name := Nicolas Vervecken ;
2137: LD_ADDR_OWVAR 26
2141: PUSH
2142: LD_STRING Nicolas Vervecken
2144: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2145: LD_ADDR_OWVAR 33
2149: PUSH
2150: LD_STRING SecondCharsGal
2152: ST_TO_ADDR
// hc_face_number := 3 ;
2153: LD_ADDR_OWVAR 34
2157: PUSH
2158: LD_INT 3
2160: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2161: LD_ADDR_OWVAR 29
2165: PUSH
2166: LD_INT 11
2168: PUSH
2169: LD_INT 10
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: ST_TO_ADDR
// Vervecken := CreateHuman ;
2176: LD_ADDR_EXP 3
2180: PUSH
2181: CALL_OW 44
2185: ST_TO_ADDR
// PlaceHumanInUnit ( Vervecken , dep ) ;
2186: LD_EXP 3
2190: PPUSH
2191: LD_VAR 0 5
2195: PPUSH
2196: CALL_OW 52
// InitHc ;
2200: CALL_OW 19
// for i = 1 to 4 do
2204: LD_ADDR_VAR 0 2
2208: PUSH
2209: DOUBLE
2210: LD_INT 1
2212: DEC
2213: ST_TO_ADDR
2214: LD_INT 4
2216: PUSH
2217: FOR_TO
2218: IFFALSE 2279
// begin PrepareHuman ( false , class_bazooker , skill ) ;
2220: LD_INT 0
2222: PPUSH
2223: LD_INT 9
2225: PPUSH
2226: LD_VAR 0 4
2230: PPUSH
2231: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
2235: CALL_OW 44
2239: PPUSH
2240: LD_INT 22
2242: PUSH
2243: LD_INT 8
2245: PUSH
2246: EMPTY
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 30
2252: PUSH
2253: LD_INT 5
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: PUSH
2260: EMPTY
2261: LIST
2262: LIST
2263: PPUSH
2264: CALL_OW 69
2268: PUSH
2269: LD_INT 1
2271: ARRAY
2272: PPUSH
2273: CALL_OW 52
// end ;
2277: GO 2217
2279: POP
2280: POP
// for i = 1 to 2 do
2281: LD_ADDR_VAR 0 2
2285: PUSH
2286: DOUBLE
2287: LD_INT 1
2289: DEC
2290: ST_TO_ADDR
2291: LD_INT 2
2293: PUSH
2294: FOR_TO
2295: IFFALSE 2356
// begin PrepareHuman ( false , 4 , skill ) ;
2297: LD_INT 0
2299: PPUSH
2300: LD_INT 4
2302: PPUSH
2303: LD_VAR 0 4
2307: PPUSH
2308: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
2312: CALL_OW 44
2316: PPUSH
2317: LD_INT 22
2319: PUSH
2320: LD_INT 8
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PUSH
2327: LD_INT 30
2329: PUSH
2330: LD_INT 8
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: PUSH
2337: EMPTY
2338: LIST
2339: LIST
2340: PPUSH
2341: CALL_OW 69
2345: PUSH
2346: LD_INT 1
2348: ARRAY
2349: PPUSH
2350: CALL_OW 52
// end ;
2354: GO 2294
2356: POP
2357: POP
// for i = 1 to 6 do
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: DOUBLE
2364: LD_INT 1
2366: DEC
2367: ST_TO_ADDR
2368: LD_INT 6
2370: PUSH
2371: FOR_TO
2372: IFFALSE 2409
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
2374: LD_INT 0
2376: PPUSH
2377: LD_INT 3
2379: PPUSH
2380: LD_VAR 0 4
2384: PUSH
2385: LD_INT 1
2387: PLUS
2388: PPUSH
2389: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac ) ;
2393: CALL_OW 44
2397: PPUSH
2398: LD_VAR 0 6
2402: PPUSH
2403: CALL_OW 52
// end ;
2407: GO 2371
2409: POP
2410: POP
// uc_nation := 0 ;
2411: LD_ADDR_OWVAR 21
2415: PUSH
2416: LD_INT 0
2418: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) do
2419: LD_ADDR_VAR 0 2
2423: PUSH
2424: LD_INT 22
2426: PUSH
2427: LD_INT 8
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: PUSH
2434: LD_INT 30
2436: PUSH
2437: LD_INT 32
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: PPUSH
2448: CALL_OW 69
2452: PUSH
2453: FOR_IN
2454: IFFALSE 2491
// begin PrepareHuman ( false , class_apeman_soldier , skill + 1 ) ;
2456: LD_INT 0
2458: PPUSH
2459: LD_INT 15
2461: PPUSH
2462: LD_VAR 0 4
2466: PUSH
2467: LD_INT 1
2469: PLUS
2470: PPUSH
2471: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
2475: CALL_OW 44
2479: PPUSH
2480: LD_VAR 0 2
2484: PPUSH
2485: CALL_OW 52
// end ;
2489: GO 2453
2491: POP
2492: POP
// PrepareHuman ( false , class_sniper , 10 ) ;
2493: LD_INT 0
2495: PPUSH
2496: LD_INT 5
2498: PPUSH
2499: LD_INT 10
2501: PPUSH
2502: CALL_OW 380
// un := CreateHuman ;
2506: LD_ADDR_VAR 0 3
2510: PUSH
2511: CALL_OW 44
2515: ST_TO_ADDR
// PlaceUnitXY ( un , 175 , 128 , false ) ;
2516: LD_VAR 0 3
2520: PPUSH
2521: LD_INT 175
2523: PPUSH
2524: LD_INT 128
2526: PPUSH
2527: LD_INT 0
2529: PPUSH
2530: CALL_OW 48
// ComEnterUnit ( un , ar_ibun ) ;
2534: LD_VAR 0 3
2538: PPUSH
2539: LD_INT 115
2541: PPUSH
2542: CALL_OW 120
// for i = 1 to 2 do
2546: LD_ADDR_VAR 0 2
2550: PUSH
2551: DOUBLE
2552: LD_INT 1
2554: DEC
2555: ST_TO_ADDR
2556: LD_INT 2
2558: PUSH
2559: FOR_TO
2560: IFFALSE 2585
// AddComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
2562: LD_VAR 0 6
2566: PPUSH
2567: LD_INT 14
2569: PPUSH
2570: LD_INT 2
2572: PPUSH
2573: LD_INT 1
2575: PPUSH
2576: LD_INT 31
2578: PPUSH
2579: CALL_OW 185
2583: GO 2559
2585: POP
2586: POP
// end ;
2587: LD_VAR 0 1
2591: RET
// export function PrepareHovercraft ( num ) ; var i ; begin
2592: LD_INT 0
2594: PPUSH
2595: PPUSH
// for i = 1 to num do
2596: LD_ADDR_VAR 0 3
2600: PUSH
2601: DOUBLE
2602: LD_INT 1
2604: DEC
2605: ST_TO_ADDR
2606: LD_VAR 0 1
2610: PUSH
2611: FOR_TO
2612: IFFALSE 2684
// AddComConstruct ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] , ar_hovercraft , engine_combustion , control_remote , [ ar_light_gun , ar_double_machine_gun ] [ rand ( 1 , 2 ) ] ) ;
2614: LD_INT 22
2616: PUSH
2617: LD_INT 8
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 30
2626: PUSH
2627: LD_INT 3
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PPUSH
2638: CALL_OW 69
2642: PUSH
2643: LD_INT 1
2645: ARRAY
2646: PPUSH
2647: LD_INT 11
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 2
2655: PPUSH
2656: LD_INT 23
2658: PUSH
2659: LD_INT 24
2661: PUSH
2662: EMPTY
2663: LIST
2664: LIST
2665: PUSH
2666: LD_INT 1
2668: PPUSH
2669: LD_INT 2
2671: PPUSH
2672: CALL_OW 12
2676: ARRAY
2677: PPUSH
2678: CALL_OW 185
2682: GO 2611
2684: POP
2685: POP
// end ;
2686: LD_VAR 0 2
2690: RET
// export function AddKamikaze ( ) ; var i , un ; begin
2691: LD_INT 0
2693: PPUSH
2694: PPUSH
2695: PPUSH
// uc_side := 8 ;
2696: LD_ADDR_OWVAR 20
2700: PUSH
2701: LD_INT 8
2703: ST_TO_ADDR
// uc_nation := 0 ;
2704: LD_ADDR_OWVAR 21
2708: PUSH
2709: LD_INT 0
2711: ST_TO_ADDR
// hc_class := 17 ;
2712: LD_ADDR_OWVAR 28
2716: PUSH
2717: LD_INT 17
2719: ST_TO_ADDR
// hc_gallery :=  ;
2720: LD_ADDR_OWVAR 33
2724: PUSH
2725: LD_STRING 
2727: ST_TO_ADDR
// hc_name :=  ;
2728: LD_ADDR_OWVAR 26
2732: PUSH
2733: LD_STRING 
2735: ST_TO_ADDR
// hc_importance := 0 ;
2736: LD_ADDR_OWVAR 32
2740: PUSH
2741: LD_INT 0
2743: ST_TO_ADDR
// hc_skills := [ 10 , 10 , 10 , 10 ] ;
2744: LD_ADDR_OWVAR 31
2748: PUSH
2749: LD_INT 10
2751: PUSH
2752: LD_INT 10
2754: PUSH
2755: LD_INT 10
2757: PUSH
2758: LD_INT 10
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: LIST
2765: LIST
2766: ST_TO_ADDR
// if ar_base then
2767: LD_INT 57
2769: IFFALSE 2814
// begin un := CreateHuman ;
2771: LD_ADDR_VAR 0 3
2775: PUSH
2776: CALL_OW 44
2780: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_base ) ;
2781: LD_VAR 0 3
2785: PPUSH
2786: LD_INT 57
2788: PPUSH
2789: CALL_OW 52
// ComExitBuilding ( un ) ;
2793: LD_VAR 0 3
2797: PPUSH
2798: CALL_OW 122
// AddComEnterUnit ( un , legion_telep ) ;
2802: LD_VAR 0 3
2806: PPUSH
2807: LD_INT 68
2809: PPUSH
2810: CALL_OW 180
// end ; end ;
2814: LD_VAR 0 1
2818: RET
// export legion_force , l_allow_attack ; export function PrepareAttack ( n1 , n2 ) ; var i ; begin
2819: LD_INT 0
2821: PPUSH
2822: PPUSH
// legion_force := [ ] ;
2823: LD_ADDR_EXP 33
2827: PUSH
2828: EMPTY
2829: ST_TO_ADDR
// l_allow_attack := false ;
2830: LD_ADDR_EXP 34
2834: PUSH
2835: LD_INT 0
2837: ST_TO_ADDR
// PrepareHovercraft ( n1 ) ;
2838: LD_VAR 0 1
2842: PPUSH
2843: CALL 2592 0 1
// repeat wait ( 0 0$01 ) ;
2847: LD_INT 35
2849: PPUSH
2850: CALL_OW 67
// until legion_force = n1 ;
2854: LD_EXP 33
2858: PUSH
2859: LD_VAR 0 1
2863: EQUAL
2864: IFFALSE 2847
// l_allow_attack := true ;
2866: LD_ADDR_EXP 34
2870: PUSH
2871: LD_INT 1
2873: ST_TO_ADDR
// for i = 1 to n2 do
2874: LD_ADDR_VAR 0 4
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_VAR 0 2
2888: PUSH
2889: FOR_TO
2890: IFFALSE 2898
// begin AddKamikaze ( ) ;
2892: CALL 2691 0 0
// end ;
2896: GO 2889
2898: POP
2899: POP
// ComBrutalAttack ( legion_force , 6 ) ;
2900: LD_EXP 33
2904: PPUSH
2905: LD_INT 6
2907: PPUSH
2908: CALL 6544 0 2
// end ;
2912: LD_VAR 0 3
2916: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
2917: LD_INT 22
2919: PUSH
2920: LD_INT 8
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: PUSH
2927: LD_INT 33
2929: PUSH
2930: LD_INT 2
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PPUSH
2941: CALL_OW 69
2945: IFFALSE 3157
2947: GO 2949
2949: DISABLE
2950: LD_INT 0
2952: PPUSH
2953: PPUSH
2954: PPUSH
2955: PPUSH
2956: PPUSH
2957: PPUSH
2958: PPUSH
// begin enable ;
2959: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
2960: LD_ADDR_VAR 0 4
2964: PUSH
2965: LD_INT 22
2967: PUSH
2968: LD_INT 8
2970: PUSH
2971: EMPTY
2972: LIST
2973: LIST
2974: PUSH
2975: LD_INT 33
2977: PUSH
2978: LD_INT 2
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: PUSH
2985: LD_INT 3
2987: PUSH
2988: LD_INT 61
2990: PUSH
2991: EMPTY
2992: LIST
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: PPUSH
3003: CALL_OW 69
3007: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ;
3008: LD_ADDR_VAR 0 3
3012: PUSH
3013: LD_INT 22
3015: PUSH
3016: LD_INT 8
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: LD_INT 34
3025: PUSH
3026: LD_INT 31
3028: PUSH
3029: EMPTY
3030: LIST
3031: LIST
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PPUSH
3037: CALL_OW 69
3041: ST_TO_ADDR
// best := 10 ;
3042: LD_ADDR_VAR 0 5
3046: PUSH
3047: LD_INT 10
3049: ST_TO_ADDR
// best_mechanic := - 1 ;
3050: LD_ADDR_VAR 0 6
3054: PUSH
3055: LD_INT 1
3057: NEG
3058: ST_TO_ADDR
// if vehs then
3059: LD_VAR 0 4
3063: IFFALSE 3157
// begin for j in cts do
3065: LD_ADDR_VAR 0 2
3069: PUSH
3070: LD_VAR 0 3
3074: PUSH
3075: FOR_IN
3076: IFFALSE 3137
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
3078: LD_ADDR_VAR 0 7
3082: PUSH
3083: LD_VAR 0 2
3087: PPUSH
3088: CALL 5222 0 1
3092: PPUSH
3093: CALL_OW 432
3097: ST_TO_ADDR
// if p < best then
3098: LD_VAR 0 7
3102: PUSH
3103: LD_VAR 0 5
3107: LESS
3108: IFFALSE 3135
// begin best := p ;
3110: LD_ADDR_VAR 0 5
3114: PUSH
3115: LD_VAR 0 7
3119: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
3120: LD_ADDR_VAR 0 6
3124: PUSH
3125: LD_VAR 0 2
3129: PPUSH
3130: CALL 5222 0 1
3134: ST_TO_ADDR
// end ; end ;
3135: GO 3075
3137: POP
3138: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
3139: LD_VAR 0 4
3143: PUSH
3144: LD_INT 1
3146: ARRAY
3147: PPUSH
3148: LD_VAR 0 6
3152: PPUSH
3153: CALL_OW 135
// end ; end ;
3157: PPOPN 7
3159: END
// every 5 5$00 trigger legion_attacks_active do
3160: LD_EXP 7
3164: IFFALSE 3216
3166: GO 3168
3168: DISABLE
// begin enable ;
3169: ENABLE
// Wait ( [ 2 2$30 , 1 1$00 , 0 0$30 ] [ Difficulty ] ) ;
3170: LD_INT 5250
3172: PUSH
3173: LD_INT 2100
3175: PUSH
3176: LD_INT 1050
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: LIST
3183: PUSH
3184: LD_OWVAR 67
3188: ARRAY
3189: PPUSH
3190: CALL_OW 67
// PrepareAttack ( ( legion_attack_strenght - 2 + Difficulty ) , 2 ) ;
3194: LD_EXP 8
3198: PUSH
3199: LD_INT 2
3201: MINUS
3202: PUSH
3203: LD_OWVAR 67
3207: PLUS
3208: PPUSH
3209: LD_INT 2
3211: PPUSH
3212: CALL 2819 0 2
// end ;
3216: END
// every 0 0$01 trigger FilterUnitsInArea ( islandArea , [ [ f_side , 8 ] , [ f_class , 17 ] ] ) do var i ;
3217: LD_INT 6
3219: PPUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 8
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: PUSH
3230: LD_INT 25
3232: PUSH
3233: LD_INT 17
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PPUSH
3244: CALL_OW 70
3248: IFFALSE 3335
3250: GO 3252
3252: DISABLE
3253: LD_INT 0
3255: PPUSH
// begin enable ;
3256: ENABLE
// for i in FilterUnitsInArea ( islandArea , [ [ f_side , 8 ] , [ f_class , 17 ] ] ) do
3257: LD_ADDR_VAR 0 1
3261: PUSH
3262: LD_INT 6
3264: PPUSH
3265: LD_INT 22
3267: PUSH
3268: LD_INT 8
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: PUSH
3275: LD_INT 25
3277: PUSH
3278: LD_INT 17
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: PUSH
3285: EMPTY
3286: LIST
3287: LIST
3288: PPUSH
3289: CALL_OW 70
3293: PUSH
3294: FOR_IN
3295: IFFALSE 3333
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , i ) ) ;
3297: LD_VAR 0 1
3301: PPUSH
3302: LD_INT 22
3304: PUSH
3305: LD_INT 6
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PPUSH
3312: CALL_OW 69
3316: PPUSH
3317: LD_VAR 0 1
3321: PPUSH
3322: CALL_OW 74
3326: PPUSH
3327: CALL_OW 115
3331: GO 3294
3333: POP
3334: POP
// end ;
3335: PPOPN 1
3337: END
// every 6 6$00 trigger legion_telep do var k , xy , i ;
3338: LD_INT 68
3340: IFFALSE 3571
3342: GO 3344
3344: DISABLE
3345: LD_INT 0
3347: PPUSH
3348: PPUSH
3349: PPUSH
// begin enable ;
3350: ENABLE
// xy := [ [ 224 , 5 ] , [ 160 , 4 ] , [ 228 , 56 ] , [ 271 , 87 ] ] ;
3351: LD_ADDR_VAR 0 2
3355: PUSH
3356: LD_INT 224
3358: PUSH
3359: LD_INT 5
3361: PUSH
3362: EMPTY
3363: LIST
3364: LIST
3365: PUSH
3366: LD_INT 160
3368: PUSH
3369: LD_INT 4
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: PUSH
3376: LD_INT 228
3378: PUSH
3379: LD_INT 56
3381: PUSH
3382: EMPTY
3383: LIST
3384: LIST
3385: PUSH
3386: LD_INT 271
3388: PUSH
3389: LD_INT 87
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: PUSH
3396: EMPTY
3397: LIST
3398: LIST
3399: LIST
3400: LIST
3401: ST_TO_ADDR
// for i = 1 to 3 do
3402: LD_ADDR_VAR 0 3
3406: PUSH
3407: DOUBLE
3408: LD_INT 1
3410: DEC
3411: ST_TO_ADDR
3412: LD_INT 3
3414: PUSH
3415: FOR_TO
3416: IFFALSE 3432
// EraseResourceArea ( telArea , i ) ;
3418: LD_INT 7
3420: PPUSH
3421: LD_VAR 0 3
3425: PPUSH
3426: CALL_OW 286
3430: GO 3415
3432: POP
3433: POP
// for i = xy downto 1 do
3434: LD_ADDR_VAR 0 3
3438: PUSH
3439: DOUBLE
3440: LD_VAR 0 2
3444: INC
3445: ST_TO_ADDR
3446: LD_INT 1
3448: PUSH
3449: FOR_DOWNTO
3450: IFFALSE 3532
// begin k := rand ( 1 , xy ) ;
3452: LD_ADDR_VAR 0 1
3456: PUSH
3457: LD_INT 1
3459: PPUSH
3460: LD_VAR 0 2
3464: PPUSH
3465: CALL_OW 12
3469: ST_TO_ADDR
// if HexInfo ( xy [ k ] [ 1 ] , xy [ k ] [ 2 ] ) then
3470: LD_VAR 0 2
3474: PUSH
3475: LD_VAR 0 1
3479: ARRAY
3480: PUSH
3481: LD_INT 1
3483: ARRAY
3484: PPUSH
3485: LD_VAR 0 2
3489: PUSH
3490: LD_VAR 0 1
3494: ARRAY
3495: PUSH
3496: LD_INT 2
3498: ARRAY
3499: PPUSH
3500: CALL_OW 428
3504: IFFALSE 3528
// xy := Delete ( xy , k ) else
3506: LD_ADDR_VAR 0 2
3510: PUSH
3511: LD_VAR 0 2
3515: PPUSH
3516: LD_VAR 0 1
3520: PPUSH
3521: CALL_OW 3
3525: ST_TO_ADDR
3526: GO 3530
// break ;
3528: GO 3532
// end ;
3530: GO 3449
3532: POP
3533: POP
// TeleportExit ( legion_telep , xy [ k ] [ 1 ] , xy [ k ] [ 2 ] ) ;
3534: LD_INT 68
3536: PPUSH
3537: LD_VAR 0 2
3541: PUSH
3542: LD_VAR 0 1
3546: ARRAY
3547: PUSH
3548: LD_INT 1
3550: ARRAY
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_VAR 0 1
3561: ARRAY
3562: PUSH
3563: LD_INT 2
3565: ARRAY
3566: PPUSH
3567: CALL_OW 243
// end ; end_of_file
3571: PPOPN 3
3573: END
// export function PrepareRussian ; var i , skill , un , tmp , amount , k ; begin
3574: LD_INT 0
3576: PPUSH
3577: PPUSH
3578: PPUSH
3579: PPUSH
3580: PPUSH
3581: PPUSH
3582: PPUSH
// uc_side := 6 ;
3583: LD_ADDR_OWVAR 20
3587: PUSH
3588: LD_INT 6
3590: ST_TO_ADDR
// uc_nation := nation_russian ;
3591: LD_ADDR_OWVAR 21
3595: PUSH
3596: LD_INT 3
3598: ST_TO_ADDR
// SetArtifactRes ( 6 , true ) ;
3599: LD_INT 6
3601: PPUSH
3602: LD_INT 1
3604: PPUSH
3605: CALL_OW 467
// amount := [ [ 9 , 4 ] , [ 8 , 3 ] , [ 8 , 2 ] ] [ Difficulty ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_INT 9
3616: PUSH
3617: LD_INT 4
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 8
3626: PUSH
3627: LD_INT 3
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: PUSH
3634: LD_INT 8
3636: PUSH
3637: LD_INT 2
3639: PUSH
3640: EMPTY
3641: LIST
3642: LIST
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: LIST
3648: PUSH
3649: LD_OWVAR 67
3653: ARRAY
3654: ST_TO_ADDR
// skill := [ 9 , 8 , 7 ] [ Difficulty ] ;
3655: LD_ADDR_VAR 0 3
3659: PUSH
3660: LD_INT 9
3662: PUSH
3663: LD_INT 8
3665: PUSH
3666: LD_INT 7
3668: PUSH
3669: EMPTY
3670: LIST
3671: LIST
3672: LIST
3673: PUSH
3674: LD_OWVAR 67
3678: ARRAY
3679: ST_TO_ADDR
// tmp := [ ] ;
3680: LD_ADDR_VAR 0 5
3684: PUSH
3685: EMPTY
3686: ST_TO_ADDR
// Davidov := NewCharacter ( Davidov ) ;
3687: LD_ADDR_EXP 2
3691: PUSH
3692: LD_STRING Davidov
3694: PPUSH
3695: CALL_OW 25
3699: ST_TO_ADDR
// SetSkill ( Davidov , 1 , 7 ) ;
3700: LD_EXP 2
3704: PPUSH
3705: LD_INT 1
3707: PPUSH
3708: LD_INT 7
3710: PPUSH
3711: CALL_OW 237
// SetSkill ( Davidov , 2 , 8 ) ;
3715: LD_EXP 2
3719: PPUSH
3720: LD_INT 2
3722: PPUSH
3723: LD_INT 8
3725: PPUSH
3726: CALL_OW 237
// SetSkill ( Davidov , 3 , 6 ) ;
3730: LD_EXP 2
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 6
3740: PPUSH
3741: CALL_OW 237
// SetSkill ( Davidov , 4 , 10 ) ;
3745: LD_EXP 2
3749: PPUSH
3750: LD_INT 4
3752: PPUSH
3753: LD_INT 10
3755: PPUSH
3756: CALL_OW 237
// SetClass ( Davidov , 4 ) ;
3760: LD_EXP 2
3764: PPUSH
3765: LD_INT 4
3767: PPUSH
3768: CALL_OW 336
// hc_importance := 0 ;
3772: LD_ADDR_OWVAR 32
3776: PUSH
3777: LD_INT 0
3779: ST_TO_ADDR
// while amount [ 1 ] do
3780: LD_VAR 0 6
3784: PUSH
3785: LD_INT 1
3787: ARRAY
3788: IFFALSE 4121
// begin Wait ( 1 ) ;
3790: LD_INT 1
3792: PPUSH
3793: CALL_OW 67
// k := rand ( 1 , 4 ) ;
3797: LD_ADDR_VAR 0 7
3801: PUSH
3802: LD_INT 1
3804: PPUSH
3805: LD_INT 4
3807: PPUSH
3808: CALL_OW 12
3812: ST_TO_ADDR
// if amount [ 2 ] and tmp then
3813: LD_VAR 0 6
3817: PUSH
3818: LD_INT 2
3820: ARRAY
3821: PUSH
3822: LD_VAR 0 5
3826: AND
3827: IFFALSE 3982
// begin if k in [ 1 , 2 ] then
3829: LD_VAR 0 7
3833: PUSH
3834: LD_INT 1
3836: PUSH
3837: LD_INT 2
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: IN
3844: IFFALSE 3854
// k := 3 ;
3846: LD_ADDR_VAR 0 7
3850: PUSH
3851: LD_INT 3
3853: ST_TO_ADDR
// vc_chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
3854: LD_ADDR_OWVAR 37
3858: PUSH
3859: LD_INT 22
3861: PUSH
3862: LD_INT 24
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: PUSH
3869: LD_INT 1
3871: PPUSH
3872: LD_INT 2
3874: PPUSH
3875: CALL_OW 12
3879: ARRAY
3880: ST_TO_ADDR
// vc_engine := engine_siberite ;
3881: LD_ADDR_OWVAR 39
3885: PUSH
3886: LD_INT 3
3888: ST_TO_ADDR
// vc_control := control_manual ;
3889: LD_ADDR_OWVAR 38
3893: PUSH
3894: LD_INT 1
3896: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_rocket_launcher , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ;
3897: LD_ADDR_OWVAR 40
3901: PUSH
3902: LD_INT 44
3904: PUSH
3905: LD_INT 45
3907: PUSH
3908: LD_INT 43
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: LIST
3915: PUSH
3916: LD_INT 1
3918: PPUSH
3919: LD_INT 3
3921: PPUSH
3922: CALL_OW 12
3926: ARRAY
3927: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , CreateVehicle ) ;
3928: LD_ADDR_VAR 0 5
3932: PUSH
3933: LD_VAR 0 5
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 45
3945: PPUSH
3946: CALL_OW 2
3950: ST_TO_ADDR
// amount := Replace ( amount , 2 , amount [ 2 ] - 1 ) ;
3951: LD_ADDR_VAR 0 6
3955: PUSH
3956: LD_VAR 0 6
3960: PPUSH
3961: LD_INT 2
3963: PPUSH
3964: LD_VAR 0 6
3968: PUSH
3969: LD_INT 2
3971: ARRAY
3972: PUSH
3973: LD_INT 1
3975: MINUS
3976: PPUSH
3977: CALL_OW 1
3981: ST_TO_ADDR
// end ; if not tmp then
3982: LD_VAR 0 5
3986: NOT
3987: IFFALSE 3997
// k := 2 ;
3989: LD_ADDR_VAR 0 7
3993: PUSH
3994: LD_INT 2
3996: ST_TO_ADDR
// if amount [ 2 ] = 0 and k = 3 then
3997: LD_VAR 0 6
4001: PUSH
4002: LD_INT 2
4004: ARRAY
4005: PUSH
4006: LD_INT 0
4008: EQUAL
4009: PUSH
4010: LD_VAR 0 7
4014: PUSH
4015: LD_INT 3
4017: EQUAL
4018: AND
4019: IFFALSE 4048
// k := [ class_bazooker , class_scientistic ] [ rand ( 1 , 2 ) ] ;
4021: LD_ADDR_VAR 0 7
4025: PUSH
4026: LD_INT 9
4028: PUSH
4029: LD_INT 4
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: PUSH
4036: LD_INT 1
4038: PPUSH
4039: LD_INT 2
4041: PPUSH
4042: CALL_OW 12
4046: ARRAY
4047: ST_TO_ADDR
// PrepareHuman ( false , k , skill ) ;
4048: LD_INT 0
4050: PPUSH
4051: LD_VAR 0 7
4055: PPUSH
4056: LD_VAR 0 3
4060: PPUSH
4061: CALL_OW 380
// tmp := Insert ( tmp , 1 , CreateHuman ) ;
4065: LD_ADDR_VAR 0 5
4069: PUSH
4070: LD_VAR 0 5
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: CALL_OW 44
4082: PPUSH
4083: CALL_OW 2
4087: ST_TO_ADDR
// amount := Replace ( amount , 1 , amount [ 1 ] - 1 ) ;
4088: LD_ADDR_VAR 0 6
4092: PUSH
4093: LD_VAR 0 6
4097: PPUSH
4098: LD_INT 1
4100: PPUSH
4101: LD_VAR 0 6
4105: PUSH
4106: LD_INT 1
4108: ARRAY
4109: PUSH
4110: LD_INT 1
4112: MINUS
4113: PPUSH
4114: CALL_OW 1
4118: ST_TO_ADDR
// end ;
4119: GO 3780
// tmp := Insert ( tmp , tmp + 1 , Davidov ) ;
4121: LD_ADDR_VAR 0 5
4125: PUSH
4126: LD_VAR 0 5
4130: PPUSH
4131: LD_VAR 0 5
4135: PUSH
4136: LD_INT 1
4138: PLUS
4139: PPUSH
4140: LD_EXP 2
4144: PPUSH
4145: CALL_OW 2
4149: ST_TO_ADDR
// for i = tmp downto 1 do
4150: LD_ADDR_VAR 0 2
4154: PUSH
4155: DOUBLE
4156: LD_VAR 0 5
4160: INC
4161: ST_TO_ADDR
4162: LD_INT 1
4164: PUSH
4165: FOR_DOWNTO
4166: IFFALSE 4328
// begin if GetType ( tmp [ i ] ) = unit_vehicle then
4168: LD_VAR 0 5
4172: PUSH
4173: LD_VAR 0 2
4177: ARRAY
4178: PPUSH
4179: CALL_OW 247
4183: PUSH
4184: LD_INT 2
4186: EQUAL
4187: IFFALSE 4277
// begin SetDir ( tmp [ i ] , 3 ) ;
4189: LD_VAR 0 5
4193: PUSH
4194: LD_VAR 0 2
4198: ARRAY
4199: PPUSH
4200: LD_INT 3
4202: PPUSH
4203: CALL_OW 233
// PlaceUnitXY ( tmp [ i ] , 193 , 3 , false ) ;
4207: LD_VAR 0 5
4211: PUSH
4212: LD_VAR 0 2
4216: ARRAY
4217: PPUSH
4218: LD_INT 193
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 0
4226: PPUSH
4227: CALL_OW 48
// PlaceHumanInUnit ( tmp [ i - 1 ] , tmp [ i ] ) ;
4231: LD_VAR 0 5
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 1
4243: MINUS
4244: ARRAY
4245: PPUSH
4246: LD_VAR 0 5
4250: PUSH
4251: LD_VAR 0 2
4255: ARRAY
4256: PPUSH
4257: CALL_OW 52
// i := i - 1 ;
4261: LD_ADDR_VAR 0 2
4265: PUSH
4266: LD_VAR 0 2
4270: PUSH
4271: LD_INT 1
4273: MINUS
4274: ST_TO_ADDR
// end else
4275: GO 4298
// PlaceUnitArea ( tmp [ i ] , start_area , false ) ;
4277: LD_VAR 0 5
4281: PUSH
4282: LD_VAR 0 2
4286: ARRAY
4287: PPUSH
4288: LD_INT 2
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// ComMoveXY ( tmp [ i ] , 197 , 22 ) ;
4298: LD_VAR 0 5
4302: PUSH
4303: LD_VAR 0 2
4307: ARRAY
4308: PPUSH
4309: LD_INT 197
4311: PPUSH
4312: LD_INT 22
4314: PPUSH
4315: CALL_OW 111
// Wait ( 0 0$02 ) ;
4319: LD_INT 70
4321: PPUSH
4322: CALL_OW 67
// end ;
4326: GO 4165
4328: POP
4329: POP
// Wait ( 0 0$02 ) ;
4330: LD_INT 70
4332: PPUSH
4333: CALL_OW 67
// vc_chassis := ru_medium_tracked ;
4337: LD_ADDR_OWVAR 37
4341: PUSH
4342: LD_INT 22
4344: ST_TO_ADDR
// vc_engine := engine_siberite ;
4345: LD_ADDR_OWVAR 39
4349: PUSH
4350: LD_INT 3
4352: ST_TO_ADDR
// vc_control := control_computer ;
4353: LD_ADDR_OWVAR 38
4357: PUSH
4358: LD_INT 3
4360: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4361: LD_ADDR_OWVAR 40
4365: PUSH
4366: LD_INT 51
4368: ST_TO_ADDR
// tmp := CreateVehicle ;
4369: LD_ADDR_VAR 0 5
4373: PUSH
4374: CALL_OW 45
4378: ST_TO_ADDR
// SetDir ( tmp , 3 ) ;
4379: LD_VAR 0 5
4383: PPUSH
4384: LD_INT 3
4386: PPUSH
4387: CALL_OW 233
// PlaceUnitXY ( tmp , 193 , 3 , false ) ;
4391: LD_VAR 0 5
4395: PPUSH
4396: LD_INT 193
4398: PPUSH
4399: LD_INT 3
4401: PPUSH
4402: LD_INT 0
4404: PPUSH
4405: CALL_OW 48
// SetCargo ( tmp , mat_artifact , 60 ) ;
4409: LD_VAR 0 5
4413: PPUSH
4414: LD_INT 4
4416: PPUSH
4417: LD_INT 60
4419: PPUSH
4420: CALL_OW 290
// ComMoveXY ( tmp , 197 , 22 ) ;
4424: LD_VAR 0 5
4428: PPUSH
4429: LD_INT 197
4431: PPUSH
4432: LD_INT 22
4434: PPUSH
4435: CALL_OW 111
// end ; end_of_file
4439: LD_VAR 0 1
4443: RET
// on VehicleConstructed ( veh , fac ) do var side ;
4444: LD_INT 0
4446: PPUSH
// begin side := GetSide ( fac ) ;
4447: LD_ADDR_VAR 0 3
4451: PUSH
4452: LD_VAR 0 2
4456: PPUSH
4457: CALL_OW 255
4461: ST_TO_ADDR
// case side of 7 :
4462: LD_VAR 0 3
4466: PUSH
4467: LD_INT 7
4469: DOUBLE
4470: EQUAL
4471: IFTRUE 4475
4473: GO 4522
4475: POP
// begin al_force := Replace ( al_force , al_force + 1 , veh ) ;
4476: LD_ADDR_EXP 32
4480: PUSH
4481: LD_EXP 32
4485: PPUSH
4486: LD_EXP 32
4490: PUSH
4491: LD_INT 1
4493: PLUS
4494: PPUSH
4495: LD_VAR 0 1
4499: PPUSH
4500: CALL_OW 1
4504: ST_TO_ADDR
// AddComMoveXY ( veh , 112 , 175 ) ;
4505: LD_VAR 0 1
4509: PPUSH
4510: LD_INT 112
4512: PPUSH
4513: LD_INT 175
4515: PPUSH
4516: CALL_OW 171
// end ; 8 :
4520: GO 4608
4522: LD_INT 8
4524: DOUBLE
4525: EQUAL
4526: IFTRUE 4530
4528: GO 4607
4530: POP
// begin if GetWeapon ( veh ) = ar_control_tower then
4531: LD_VAR 0 1
4535: PPUSH
4536: CALL_OW 264
4540: PUSH
4541: LD_INT 31
4543: EQUAL
4544: IFFALSE 4561
// ComMoveXY ( veh , 145 , 66 ) ;
4546: LD_VAR 0 1
4550: PPUSH
4551: LD_INT 145
4553: PPUSH
4554: LD_INT 66
4556: PPUSH
4557: CALL_OW 111
// if GetChassis ( veh ) = ar_hovercraft then
4561: LD_VAR 0 1
4565: PPUSH
4566: CALL_OW 265
4570: PUSH
4571: LD_INT 11
4573: EQUAL
4574: IFFALSE 4605
// legion_force := Replace ( legion_force , legion_force + 1 , veh ) ;
4576: LD_ADDR_EXP 33
4580: PUSH
4581: LD_EXP 33
4585: PPUSH
4586: LD_EXP 33
4590: PUSH
4591: LD_INT 1
4593: PLUS
4594: PPUSH
4595: LD_VAR 0 1
4599: PPUSH
4600: CALL_OW 1
4604: ST_TO_ADDR
// end ; end ;
4605: GO 4608
4607: POP
// end ;
4608: PPOPN 3
4610: END
// on UnitDestroyed ( un ) do begin if un in legion_force then
4611: LD_VAR 0 1
4615: PUSH
4616: LD_EXP 33
4620: IN
4621: IFFALSE 4639
// legion_force := legion_force diff un ;
4623: LD_ADDR_EXP 33
4627: PUSH
4628: LD_EXP 33
4632: PUSH
4633: LD_VAR 0 1
4637: DIFF
4638: ST_TO_ADDR
// if un in al_force then
4639: LD_VAR 0 1
4643: PUSH
4644: LD_EXP 32
4648: IN
4649: IFFALSE 4667
// al_force := al_force diff un ;
4651: LD_ADDR_EXP 32
4655: PUSH
4656: LD_EXP 32
4660: PUSH
4661: LD_VAR 0 1
4665: DIFF
4666: ST_TO_ADDR
// end ;
4667: PPOPN 1
4669: END
// on UnitTeleported ( b , un ) do begin if b = legion_telep and GetClass ( un ) = 17 then
4670: LD_VAR 0 1
4674: PUSH
4675: LD_INT 68
4677: EQUAL
4678: PUSH
4679: LD_VAR 0 2
4683: PPUSH
4684: CALL_OW 257
4688: PUSH
4689: LD_INT 17
4691: EQUAL
4692: AND
4693: IFFALSE 4736
// begin Wait ( 0 0$01 ) ;
4695: LD_INT 35
4697: PPUSH
4698: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , un ) ) ;
4702: LD_VAR 0 2
4706: PPUSH
4707: LD_INT 22
4709: PUSH
4710: LD_INT 6
4712: PUSH
4713: EMPTY
4714: LIST
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: PPUSH
4722: LD_VAR 0 2
4726: PPUSH
4727: CALL_OW 74
4731: PPUSH
4732: CALL_OW 115
// end ; end ;
4736: PPOPN 2
4738: END
// on CrateSpawn ( id , x , y , amount , mode ) do var i , apes , n ;
4739: LD_INT 0
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin if InArea ( x , y , cratesArea ) and FilterUnitsInArea ( islandArea , [ f_enemy , 6 ] ) = 0 then
4744: LD_VAR 0 2
4748: PPUSH
4749: LD_VAR 0 3
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: CALL_OW 309
4761: PUSH
4762: LD_INT 6
4764: PPUSH
4765: LD_INT 81
4767: PUSH
4768: LD_INT 6
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: PPUSH
4775: CALL_OW 70
4779: PUSH
4780: LD_INT 0
4782: EQUAL
4783: AND
4784: IFFALSE 4947
// begin apes := FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 16 ] ] ) ;
4786: LD_ADDR_VAR 0 7
4790: PUSH
4791: LD_INT 22
4793: PUSH
4794: LD_INT 6
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: LD_INT 25
4803: PUSH
4804: LD_INT 16
4806: PUSH
4807: EMPTY
4808: LIST
4809: LIST
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PPUSH
4815: CALL_OW 69
4819: ST_TO_ADDR
// if apes = 0 or FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 then
4820: LD_VAR 0 7
4824: PUSH
4825: LD_INT 0
4827: EQUAL
4828: PUSH
4829: LD_INT 22
4831: PUSH
4832: LD_INT 6
4834: PUSH
4835: EMPTY
4836: LIST
4837: LIST
4838: PUSH
4839: LD_INT 2
4841: PUSH
4842: LD_INT 30
4844: PUSH
4845: LD_INT 0
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: LD_INT 30
4854: PUSH
4855: LD_INT 1
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: LIST
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PPUSH
4871: CALL_OW 69
4875: PUSH
4876: LD_INT 0
4878: EQUAL
4879: OR
4880: IFFALSE 4884
// exit ;
4882: GO 4947
// if UnitFilter ( apes , [ f_inside ] ) then
4884: LD_VAR 0 7
4888: PPUSH
4889: LD_INT 54
4891: PUSH
4892: EMPTY
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: IFFALSE 4928
// begin ComExitBuilding ( UnitFilter ( apes , [ f_inside ] ) ) ;
4901: LD_VAR 0 7
4905: PPUSH
4906: LD_INT 54
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 72
4916: PPUSH
4917: CALL_OW 122
// wait ( 3 ) ;
4921: LD_INT 3
4923: PPUSH
4924: CALL_OW 67
// end ; AddComCollect ( apes , x , y ) ;
4928: LD_VAR 0 7
4932: PPUSH
4933: LD_VAR 0 2
4937: PPUSH
4938: LD_VAR 0 3
4942: PPUSH
4943: CALL_OW 177
// end ; end ;
4947: PPOPN 8
4949: END
// on UnitGoesToRed ( un ) do begin if un in al_force then
4950: LD_VAR 0 1
4954: PUSH
4955: LD_EXP 32
4959: IN
4960: IFFALSE 4978
// al_force := al_force diff un ;
4962: LD_ADDR_EXP 32
4966: PUSH
4967: LD_EXP 32
4971: PUSH
4972: LD_VAR 0 1
4976: DIFF
4977: ST_TO_ADDR
// if GetControl ( un ) = control_remote then
4978: LD_VAR 0 1
4982: PPUSH
4983: CALL_OW 263
4987: PUSH
4988: LD_INT 2
4990: EQUAL
4991: IFFALSE 5002
// ComUnlink ( un ) ;
4993: LD_VAR 0 1
4997: PPUSH
4998: CALL_OW 136
// end ;
5002: PPOPN 1
5004: END
// on ResearchStarted ( tech , lab ) do begin if tech = tech_sibfiss then
5005: LD_VAR 0 1
5009: PUSH
5010: LD_INT 25
5012: EQUAL
5013: IFFALSE 5023
// player_start_res_sib_bomb := true ;
5015: LD_ADDR_EXP 4
5019: PUSH
5020: LD_INT 1
5022: ST_TO_ADDR
// if tech = tech_artifact then
5023: LD_VAR 0 1
5027: PUSH
5028: LD_INT 24
5030: EQUAL
5031: IFFALSE 5041
// player_start_res_artifact := true ;
5033: LD_ADDR_EXP 5
5037: PUSH
5038: LD_INT 1
5040: ST_TO_ADDR
// end ;
5041: PPOPN 2
5043: END
// on ArtifactUnloaded ( cargo , artifact_num ) do begin if artifact_num = 6 then
5044: LD_VAR 0 2
5048: PUSH
5049: LD_INT 6
5051: EQUAL
5052: IFFALSE 5062
// player_artifact_loaded := false ;
5054: LD_ADDR_EXP 18
5058: PUSH
5059: LD_INT 0
5061: ST_TO_ADDR
// end ;
5062: PPOPN 2
5064: END
// on ArtifactLoaded ( cargo , artifact_num ) do begin if artifact_num = 6 then
5065: LD_VAR 0 2
5069: PUSH
5070: LD_INT 6
5072: EQUAL
5073: IFFALSE 5083
// player_artifact_loaded := true ;
5075: LD_ADDR_EXP 18
5079: PUSH
5080: LD_INT 1
5082: ST_TO_ADDR
// end ;
5083: PPOPN 2
5085: END
// on SiberiteRocketExploded ( rocket , x , y ) do var i ;
5086: LD_INT 0
5088: PPUSH
// begin player_used_sib_bomb := true ;
5089: LD_ADDR_EXP 12
5093: PUSH
5094: LD_INT 1
5096: ST_TO_ADDR
// for i = 1 to 3 do
5097: LD_ADDR_VAR 0 4
5101: PUSH
5102: DOUBLE
5103: LD_INT 1
5105: DEC
5106: ST_TO_ADDR
5107: LD_INT 3
5109: PUSH
5110: FOR_TO
5111: IFFALSE 5184
// begin if GetDistXY ( x , y , artifacts_pos [ i ] [ 1 ] , artifacts_pos [ i ] [ 2 ] ) <= sib_rocket_range then
5113: LD_VAR 0 2
5117: PPUSH
5118: LD_VAR 0 3
5122: PPUSH
5123: LD_EXP 15
5127: PUSH
5128: LD_VAR 0 4
5132: ARRAY
5133: PUSH
5134: LD_INT 1
5136: ARRAY
5137: PPUSH
5138: LD_EXP 15
5142: PUSH
5143: LD_VAR 0 4
5147: ARRAY
5148: PUSH
5149: LD_INT 2
5151: ARRAY
5152: PPUSH
5153: CALL_OW 298
5157: PUSH
5158: LD_EXP 17
5162: LESSEQUAL
5163: IFFALSE 5182
// begin wait ( 0 0$5 ) ;
5165: LD_INT 175
5167: PPUSH
5168: CALL_OW 67
// artifact_destroyed := true ;
5172: LD_ADDR_EXP 16
5176: PUSH
5177: LD_INT 1
5179: ST_TO_ADDR
// break ;
5180: GO 5184
// end ; end ;
5182: GO 5110
5184: POP
5185: POP
// end ; end_of_file
5186: PPOPN 4
5188: END
// export function CreateArtifact ( type , x , y ) ; begin
5189: LD_INT 0
5191: PPUSH
// CreateResourcesXY ( mat_artifact , type , x , y , false ) ;
5192: LD_INT 4
5194: PPUSH
5195: LD_VAR 0 1
5199: PPUSH
5200: LD_VAR 0 2
5204: PPUSH
5205: LD_VAR 0 3
5209: PPUSH
5210: LD_INT 0
5212: PPUSH
5213: CALL_OW 58
// end ;
5217: LD_VAR 0 4
5221: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
5222: LD_INT 0
5224: PPUSH
5225: PPUSH
5226: PPUSH
// if not GetControl ( veh ) = control_manual then
5227: LD_VAR 0 1
5231: PPUSH
5232: CALL_OW 263
5236: PUSH
5237: LD_INT 1
5239: EQUAL
5240: NOT
5241: IFFALSE 5253
// result := false else
5243: LD_ADDR_VAR 0 2
5247: PUSH
5248: LD_INT 0
5250: ST_TO_ADDR
5251: GO 5398
// if veh in FilterAllUnits ( [ f_empty ] ) then
5253: LD_VAR 0 1
5257: PUSH
5258: LD_INT 58
5260: PUSH
5261: EMPTY
5262: LIST
5263: PPUSH
5264: CALL_OW 69
5268: IN
5269: IFFALSE 5281
// result := false else
5271: LD_ADDR_VAR 0 2
5275: PUSH
5276: LD_INT 0
5278: ST_TO_ADDR
5279: GO 5398
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
5281: LD_ADDR_VAR 0 4
5285: PUSH
5286: LD_INT 22
5288: PUSH
5289: LD_VAR 0 1
5293: PPUSH
5294: CALL_OW 255
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 55
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: PPUSH
5313: CALL_OW 69
5317: ST_TO_ADDR
// if not filter then
5318: LD_VAR 0 4
5322: NOT
5323: IFFALSE 5335
// result := false else
5325: LD_ADDR_VAR 0 2
5329: PUSH
5330: LD_INT 0
5332: ST_TO_ADDR
5333: GO 5398
// for i = 1 to filter do
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: DOUBLE
5341: LD_INT 1
5343: DEC
5344: ST_TO_ADDR
5345: LD_VAR 0 4
5349: PUSH
5350: FOR_TO
5351: IFFALSE 5396
// if IsDriver ( filter [ i ] ) = veh then
5353: LD_VAR 0 4
5357: PUSH
5358: LD_VAR 0 3
5362: ARRAY
5363: PPUSH
5364: CALL 5742 0 1
5368: PUSH
5369: LD_VAR 0 1
5373: EQUAL
5374: IFFALSE 5394
// begin result := filter [ i ] ;
5376: LD_ADDR_VAR 0 2
5380: PUSH
5381: LD_VAR 0 4
5385: PUSH
5386: LD_VAR 0 3
5390: ARRAY
5391: ST_TO_ADDR
// break ;
5392: GO 5396
// end ;
5394: GO 5350
5396: POP
5397: POP
// end ; end ;
5398: LD_VAR 0 2
5402: RET
// export function GetSibResources ( side ) ; var i , deps ; begin
5403: LD_INT 0
5405: PPUSH
5406: PPUSH
5407: PPUSH
// result := 0 ;
5408: LD_ADDR_VAR 0 2
5412: PUSH
5413: LD_INT 0
5415: ST_TO_ADDR
// deps := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5416: LD_ADDR_VAR 0 4
5420: PUSH
5421: LD_INT 22
5423: PUSH
5424: LD_VAR 0 1
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: PUSH
5433: LD_INT 2
5435: PUSH
5436: LD_INT 30
5438: PUSH
5439: LD_INT 0
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PUSH
5446: LD_INT 30
5448: PUSH
5449: LD_INT 1
5451: PUSH
5452: EMPTY
5453: LIST
5454: LIST
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: LIST
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PPUSH
5465: CALL_OW 69
5469: ST_TO_ADDR
// if deps then
5470: LD_VAR 0 4
5474: IFFALSE 5522
// for i in deps do
5476: LD_ADDR_VAR 0 3
5480: PUSH
5481: LD_VAR 0 4
5485: PUSH
5486: FOR_IN
5487: IFFALSE 5520
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
5489: LD_ADDR_VAR 0 2
5493: PUSH
5494: LD_VAR 0 2
5498: PUSH
5499: LD_VAR 0 3
5503: PPUSH
5504: CALL_OW 274
5508: PPUSH
5509: LD_INT 3
5511: PPUSH
5512: CALL_OW 275
5516: PLUS
5517: ST_TO_ADDR
5518: GO 5486
5520: POP
5521: POP
// end ;
5522: LD_VAR 0 2
5526: RET
// export function SetSibResources ( side , val ) ; var i , deps , s ; begin
5527: LD_INT 0
5529: PPUSH
5530: PPUSH
5531: PPUSH
5532: PPUSH
// if val <= 0 then
5533: LD_VAR 0 2
5537: PUSH
5538: LD_INT 0
5540: LESSEQUAL
5541: IFFALSE 5545
// exit ;
5543: GO 5737
// deps := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5545: LD_ADDR_VAR 0 5
5549: PUSH
5550: LD_INT 22
5552: PUSH
5553: LD_VAR 0 1
5557: PUSH
5558: EMPTY
5559: LIST
5560: LIST
5561: PUSH
5562: LD_INT 2
5564: PUSH
5565: LD_INT 30
5567: PUSH
5568: LD_INT 0
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: LD_INT 30
5577: PUSH
5578: LD_INT 1
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PPUSH
5594: CALL_OW 69
5598: ST_TO_ADDR
// if deps then
5599: LD_VAR 0 5
5603: IFFALSE 5737
// for i in deps do
5605: LD_ADDR_VAR 0 4
5609: PUSH
5610: LD_VAR 0 5
5614: PUSH
5615: FOR_IN
5616: IFFALSE 5735
// begin s := GetResourceType ( GetBase ( i ) , mat_siberit ) ;
5618: LD_ADDR_VAR 0 6
5622: PUSH
5623: LD_VAR 0 4
5627: PPUSH
5628: CALL_OW 274
5632: PPUSH
5633: LD_INT 3
5635: PPUSH
5636: CALL_OW 275
5640: ST_TO_ADDR
// if val < s then
5641: LD_VAR 0 2
5645: PUSH
5646: LD_VAR 0 6
5650: LESS
5651: IFFALSE 5697
// begin s := s - val ;
5653: LD_ADDR_VAR 0 6
5657: PUSH
5658: LD_VAR 0 6
5662: PUSH
5663: LD_VAR 0 2
5667: MINUS
5668: ST_TO_ADDR
// SetResourceType ( GetBase ( i ) , mat_siberit , s ) ;
5669: LD_VAR 0 4
5673: PPUSH
5674: CALL_OW 274
5678: PPUSH
5679: LD_INT 3
5681: PPUSH
5682: LD_VAR 0 6
5686: PPUSH
5687: CALL_OW 277
// exit ;
5691: POP
5692: POP
5693: GO 5737
// end else
5695: GO 5733
// begin val := val - s ;
5697: LD_ADDR_VAR 0 2
5701: PUSH
5702: LD_VAR 0 2
5706: PUSH
5707: LD_VAR 0 6
5711: MINUS
5712: ST_TO_ADDR
// SetResourceType ( GetBase ( i ) , mat_siberit , 0 ) ;
5713: LD_VAR 0 4
5717: PPUSH
5718: CALL_OW 274
5722: PPUSH
5723: LD_INT 3
5725: PPUSH
5726: LD_INT 0
5728: PPUSH
5729: CALL_OW 277
// end ; end ;
5733: GO 5615
5735: POP
5736: POP
// end ;
5737: LD_VAR 0 3
5741: RET
// export function IsDriver ( unit ) ; begin
5742: LD_INT 0
5744: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
5745: LD_VAR 0 1
5749: PUSH
5750: LD_INT 55
5752: PUSH
5753: EMPTY
5754: LIST
5755: PPUSH
5756: CALL_OW 69
5760: IN
5761: IFFALSE 5780
// result := IsInUnit ( unit ) else
5763: LD_ADDR_VAR 0 2
5767: PUSH
5768: LD_VAR 0 1
5772: PPUSH
5773: CALL_OW 310
5777: ST_TO_ADDR
5778: GO 5788
// result := false ;
5780: LD_ADDR_VAR 0 2
5784: PUSH
5785: LD_INT 0
5787: ST_TO_ADDR
// end ;
5788: LD_VAR 0 2
5792: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
5793: LD_INT 0
5795: PPUSH
5796: PPUSH
5797: PPUSH
5798: PPUSH
// if pos < 1 then
5799: LD_VAR 0 2
5803: PUSH
5804: LD_INT 1
5806: LESS
5807: IFFALSE 5811
// exit ;
5809: GO 6114
// if pos = 1 then
5811: LD_VAR 0 2
5815: PUSH
5816: LD_INT 1
5818: EQUAL
5819: IFFALSE 5852
// result := Replace ( arr , pos [ 1 ] , value ) else
5821: LD_ADDR_VAR 0 4
5825: PUSH
5826: LD_VAR 0 1
5830: PPUSH
5831: LD_VAR 0 2
5835: PUSH
5836: LD_INT 1
5838: ARRAY
5839: PPUSH
5840: LD_VAR 0 3
5844: PPUSH
5845: CALL_OW 1
5849: ST_TO_ADDR
5850: GO 6114
// begin tmp := arr ;
5852: LD_ADDR_VAR 0 6
5856: PUSH
5857: LD_VAR 0 1
5861: ST_TO_ADDR
// s_arr := [ tmp ] ;
5862: LD_ADDR_VAR 0 7
5866: PUSH
5867: LD_VAR 0 6
5871: PUSH
5872: EMPTY
5873: LIST
5874: ST_TO_ADDR
// for i = 1 to pos - 1 do
5875: LD_ADDR_VAR 0 5
5879: PUSH
5880: DOUBLE
5881: LD_INT 1
5883: DEC
5884: ST_TO_ADDR
5885: LD_VAR 0 2
5889: PUSH
5890: LD_INT 1
5892: MINUS
5893: PUSH
5894: FOR_TO
5895: IFFALSE 5940
// begin tmp := tmp [ pos [ i ] ] ;
5897: LD_ADDR_VAR 0 6
5901: PUSH
5902: LD_VAR 0 6
5906: PUSH
5907: LD_VAR 0 2
5911: PUSH
5912: LD_VAR 0 5
5916: ARRAY
5917: ARRAY
5918: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
5919: LD_ADDR_VAR 0 7
5923: PUSH
5924: LD_VAR 0 7
5928: PUSH
5929: LD_VAR 0 6
5933: PUSH
5934: EMPTY
5935: LIST
5936: ADD
5937: ST_TO_ADDR
// end ;
5938: GO 5894
5940: POP
5941: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
5942: LD_ADDR_VAR 0 6
5946: PUSH
5947: LD_VAR 0 6
5951: PPUSH
5952: LD_VAR 0 2
5956: PUSH
5957: LD_VAR 0 2
5961: ARRAY
5962: PPUSH
5963: LD_VAR 0 3
5967: PPUSH
5968: CALL_OW 1
5972: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
5973: LD_ADDR_VAR 0 7
5977: PUSH
5978: LD_VAR 0 7
5982: PPUSH
5983: LD_VAR 0 7
5987: PPUSH
5988: LD_VAR 0 6
5992: PPUSH
5993: CALL_OW 1
5997: ST_TO_ADDR
// for i = s_arr downto 2 do
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: DOUBLE
6004: LD_VAR 0 7
6008: INC
6009: ST_TO_ADDR
6010: LD_INT 2
6012: PUSH
6013: FOR_DOWNTO
6014: IFFALSE 6098
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
6016: LD_ADDR_VAR 0 6
6020: PUSH
6021: LD_VAR 0 7
6025: PUSH
6026: LD_VAR 0 5
6030: PUSH
6031: LD_INT 1
6033: MINUS
6034: ARRAY
6035: PPUSH
6036: LD_VAR 0 2
6040: PUSH
6041: LD_VAR 0 5
6045: PUSH
6046: LD_INT 1
6048: MINUS
6049: ARRAY
6050: PPUSH
6051: LD_VAR 0 7
6055: PUSH
6056: LD_VAR 0 5
6060: ARRAY
6061: PPUSH
6062: CALL_OW 1
6066: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
6067: LD_ADDR_VAR 0 7
6071: PUSH
6072: LD_VAR 0 7
6076: PPUSH
6077: LD_VAR 0 5
6081: PUSH
6082: LD_INT 1
6084: MINUS
6085: PPUSH
6086: LD_VAR 0 6
6090: PPUSH
6091: CALL_OW 1
6095: ST_TO_ADDR
// end ;
6096: GO 6013
6098: POP
6099: POP
// result := s_arr [ 1 ] ;
6100: LD_ADDR_VAR 0 4
6104: PUSH
6105: LD_VAR 0 7
6109: PUSH
6110: LD_INT 1
6112: ARRAY
6113: ST_TO_ADDR
// end ; end ;
6114: LD_VAR 0 4
6118: RET
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
6119: LD_VAR 0 1
6123: PUSH
6124: LD_EXP 35
6128: IN
6129: NOT
6130: IFFALSE 6161
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
6132: LD_ADDR_EXP 35
6136: PUSH
6137: LD_EXP 35
6141: PPUSH
6142: LD_EXP 35
6146: PUSH
6147: LD_INT 1
6149: PLUS
6150: PPUSH
6151: LD_VAR 0 1
6155: PPUSH
6156: CALL_OW 2
6160: ST_TO_ADDR
// end ;
6161: PPOPN 1
6163: END
// export function DestinationReachable ( unit , x , y ) ; begin
6164: LD_INT 0
6166: PPUSH
// if unit in unreachableList then
6167: LD_VAR 0 1
6171: PUSH
6172: LD_EXP 35
6176: IN
6177: IFFALSE 6195
// unreachableList := unreachableList diff unit ;
6179: LD_ADDR_EXP 35
6183: PUSH
6184: LD_EXP 35
6188: PUSH
6189: LD_VAR 0 1
6193: DIFF
6194: ST_TO_ADDR
// if ValidHex ( x , y ) then
6195: LD_VAR 0 2
6199: PPUSH
6200: LD_VAR 0 3
6204: PPUSH
6205: CALL_OW 488
6209: IFFALSE 6235
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
6211: LD_VAR 0 1
6215: PPUSH
6216: LD_VAR 0 2
6220: PPUSH
6221: LD_VAR 0 3
6225: PPUSH
6226: CALL_OW 428
6230: PPUSH
6231: CALL_OW 115
// Wait ( 3 ) ;
6235: LD_INT 3
6237: PPUSH
6238: CALL_OW 67
// if unit in unreachableList then
6242: LD_VAR 0 1
6246: PUSH
6247: LD_EXP 35
6251: IN
6252: IFFALSE 6264
// result := false else
6254: LD_ADDR_VAR 0 4
6258: PUSH
6259: LD_INT 0
6261: ST_TO_ADDR
6262: GO 6272
// result := true ;
6264: LD_ADDR_VAR 0 4
6268: PUSH
6269: LD_INT 1
6271: ST_TO_ADDR
// end ;
6272: LD_VAR 0 4
6276: RET
// export function ComBombAttack ( unit , side ) ; var i , enemy , t , x , y , change_target_counter , last_target ; begin
6277: LD_INT 0
6279: PPUSH
6280: PPUSH
6281: PPUSH
6282: PPUSH
6283: PPUSH
6284: PPUSH
6285: PPUSH
6286: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
6287: LD_ADDR_VAR 0 5
6291: PUSH
6292: LD_INT 22
6294: PUSH
6295: LD_VAR 0 2
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PPUSH
6304: CALL_OW 69
6308: ST_TO_ADDR
// change_target_counter := 0 ;
6309: LD_ADDR_VAR 0 9
6313: PUSH
6314: LD_INT 0
6316: ST_TO_ADDR
// last_target := 0 ;
6317: LD_ADDR_VAR 0 10
6321: PUSH
6322: LD_INT 0
6324: ST_TO_ADDR
// if not enemy then
6325: LD_VAR 0 5
6329: NOT
6330: IFFALSE 6334
// exit ;
6332: GO 6539
// while ( IsLive ( unit ) and change_target_counter < 4 ) do
6334: LD_VAR 0 1
6338: PPUSH
6339: CALL_OW 300
6343: PUSH
6344: LD_VAR 0 9
6348: PUSH
6349: LD_INT 4
6351: LESS
6352: AND
6353: IFFALSE 6539
// begin if UnitFilter ( enemy , [ f_occupied ] ) then
6355: LD_VAR 0 5
6359: PPUSH
6360: LD_INT 59
6362: PUSH
6363: EMPTY
6364: LIST
6365: PPUSH
6366: CALL_OW 72
6370: IFFALSE 6506
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
6372: LD_ADDR_VAR 0 6
6376: PUSH
6377: LD_VAR 0 5
6381: PPUSH
6382: LD_INT 59
6384: PUSH
6385: EMPTY
6386: LIST
6387: PPUSH
6388: CALL_OW 72
6392: PPUSH
6393: LD_VAR 0 1
6397: PPUSH
6398: CALL_OW 74
6402: ST_TO_ADDR
// if ( last_target <> t ) then
6403: LD_VAR 0 10
6407: PUSH
6408: LD_VAR 0 6
6412: NONEQUAL
6413: IFFALSE 6429
// change_target_counter := change_target_counter + 1 ;
6415: LD_ADDR_VAR 0 9
6419: PUSH
6420: LD_VAR 0 9
6424: PUSH
6425: LD_INT 1
6427: PLUS
6428: ST_TO_ADDR
// last_target := t ;
6429: LD_ADDR_VAR 0 10
6433: PUSH
6434: LD_VAR 0 6
6438: ST_TO_ADDR
// x := GetX ( t ) ;
6439: LD_ADDR_VAR 0 7
6443: PUSH
6444: LD_VAR 0 6
6448: PPUSH
6449: CALL_OW 250
6453: ST_TO_ADDR
// y := GetY ( t ) ;
6454: LD_ADDR_VAR 0 8
6458: PUSH
6459: LD_VAR 0 6
6463: PPUSH
6464: CALL_OW 251
6468: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6469: LD_VAR 0 1
6473: PPUSH
6474: LD_VAR 0 7
6478: PPUSH
6479: LD_VAR 0 8
6483: PPUSH
6484: CALL 6164 0 3
6488: IFFALSE 6504
// ComAttackUnit ( unit , t ) ;
6490: LD_VAR 0 1
6494: PPUSH
6495: LD_VAR 0 6
6499: PPUSH
6500: CALL_OW 115
// end else
6504: GO 6530
// ComAttackUnit ( unit , NearestUnitToUnit ( enemy , unit ) ) ;
6506: LD_VAR 0 1
6510: PPUSH
6511: LD_VAR 0 5
6515: PPUSH
6516: LD_VAR 0 1
6520: PPUSH
6521: CALL_OW 74
6525: PPUSH
6526: CALL_OW 115
// Wait ( 0 0$0.3 ) ;
6530: LD_INT 10
6532: PPUSH
6533: CALL_OW 67
// end ;
6537: GO 6334
// end ;
6539: LD_VAR 0 3
6543: RET
// export function ComBrutalAttack ( units , side ) ; var i , enemy , t , x , y , target , unit ; begin
6544: LD_INT 0
6546: PPUSH
6547: PPUSH
6548: PPUSH
6549: PPUSH
6550: PPUSH
6551: PPUSH
6552: PPUSH
6553: PPUSH
// enemy := FilterAllUnits ( [ f_side , side ] ) ;
6554: LD_ADDR_VAR 0 5
6558: PUSH
6559: LD_INT 22
6561: PUSH
6562: LD_VAR 0 2
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PPUSH
6571: CALL_OW 69
6575: ST_TO_ADDR
// target := 0 ;
6576: LD_ADDR_VAR 0 9
6580: PUSH
6581: LD_INT 0
6583: ST_TO_ADDR
// if not enemy then
6584: LD_VAR 0 5
6588: NOT
6589: IFFALSE 6593
// exit ;
6591: GO 7248
// while units do
6593: LD_VAR 0 1
6597: IFFALSE 7248
// begin wait ( 0 0$0.3 ) ;
6599: LD_INT 10
6601: PPUSH
6602: CALL_OW 67
// for unit in units do
6606: LD_ADDR_VAR 0 10
6610: PUSH
6611: LD_VAR 0 1
6615: PUSH
6616: FOR_IN
6617: IFFALSE 7244
// begin if not IsPlaced ( unit ) then
6619: LD_VAR 0 10
6623: PPUSH
6624: CALL_OW 305
6628: NOT
6629: IFFALSE 6649
// begin units := units diff unit ;
6631: LD_ADDR_VAR 0 1
6635: PUSH
6636: LD_VAR 0 1
6640: PUSH
6641: LD_VAR 0 10
6645: DIFF
6646: ST_TO_ADDR
// continue ;
6647: GO 6616
// end ; if not IsPlaced ( target ) then
6649: LD_VAR 0 9
6653: PPUSH
6654: CALL_OW 305
6658: NOT
6659: IFFALSE 6669
// target := 0 ;
6661: LD_ADDR_VAR 0 9
6665: PUSH
6666: LD_INT 0
6668: ST_TO_ADDR
// if not target and UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) then
6669: LD_VAR 0 9
6673: NOT
6674: PUSH
6675: LD_VAR 0 5
6679: PPUSH
6680: LD_INT 21
6682: PUSH
6683: LD_INT 1
6685: PUSH
6686: EMPTY
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 3
6692: PUSH
6693: LD_INT 54
6695: PUSH
6696: EMPTY
6697: LIST
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PPUSH
6707: CALL_OW 72
6711: AND
6712: IFFALSE 6974
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , unit ) ;
6714: LD_ADDR_VAR 0 6
6718: PUSH
6719: LD_VAR 0 5
6723: PPUSH
6724: LD_INT 21
6726: PUSH
6727: LD_INT 1
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: PUSH
6734: LD_INT 3
6736: PUSH
6737: LD_INT 54
6739: PUSH
6740: EMPTY
6741: LIST
6742: PUSH
6743: EMPTY
6744: LIST
6745: LIST
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PPUSH
6751: CALL_OW 72
6755: PPUSH
6756: LD_VAR 0 10
6760: PPUSH
6761: CALL_OW 74
6765: ST_TO_ADDR
// x := GetX ( t ) ;
6766: LD_ADDR_VAR 0 7
6770: PUSH
6771: LD_VAR 0 6
6775: PPUSH
6776: CALL_OW 250
6780: ST_TO_ADDR
// y := GetY ( t ) ;
6781: LD_ADDR_VAR 0 8
6785: PUSH
6786: LD_VAR 0 6
6790: PPUSH
6791: CALL_OW 251
6795: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6796: LD_VAR 0 10
6800: PPUSH
6801: LD_VAR 0 7
6805: PPUSH
6806: LD_VAR 0 8
6810: PPUSH
6811: CALL 6164 0 3
6815: IFFALSE 6829
// target := t else
6817: LD_ADDR_VAR 0 9
6821: PUSH
6822: LD_VAR 0 6
6826: ST_TO_ADDR
6827: GO 6974
// if UnitFilter ( enemy , [ f_occupied ] ) then
6829: LD_VAR 0 5
6833: PPUSH
6834: LD_INT 59
6836: PUSH
6837: EMPTY
6838: LIST
6839: PPUSH
6840: CALL_OW 72
6844: IFFALSE 6974
// begin t := NearestUnitToUnit ( UnitFilter ( enemy , [ f_occupied ] ) , unit ) ;
6846: LD_ADDR_VAR 0 6
6850: PUSH
6851: LD_VAR 0 5
6855: PPUSH
6856: LD_INT 59
6858: PUSH
6859: EMPTY
6860: LIST
6861: PPUSH
6862: CALL_OW 72
6866: PPUSH
6867: LD_VAR 0 10
6871: PPUSH
6872: CALL_OW 74
6876: ST_TO_ADDR
// x := GetX ( t ) ;
6877: LD_ADDR_VAR 0 7
6881: PUSH
6882: LD_VAR 0 6
6886: PPUSH
6887: CALL_OW 250
6891: ST_TO_ADDR
// y := GetY ( t ) ;
6892: LD_ADDR_VAR 0 8
6896: PUSH
6897: LD_VAR 0 6
6901: PPUSH
6902: CALL_OW 251
6906: ST_TO_ADDR
// if DestinationReachable ( unit , x , y ) then
6907: LD_VAR 0 10
6911: PPUSH
6912: LD_VAR 0 7
6916: PPUSH
6917: LD_VAR 0 8
6921: PPUSH
6922: CALL 6164 0 3
6926: IFFALSE 6940
// target := t else
6928: LD_ADDR_VAR 0 9
6932: PUSH
6933: LD_VAR 0 6
6937: ST_TO_ADDR
6938: GO 6974
// ComAttackUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , unit ) ) ;
6940: LD_VAR 0 10
6944: PPUSH
6945: LD_INT 22
6947: PUSH
6948: LD_INT 6
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 69
6959: PPUSH
6960: LD_VAR 0 10
6964: PPUSH
6965: CALL_OW 74
6969: PPUSH
6970: CALL_OW 115
// end ; end ; if not target or not DestinationReachable ( unit , GetX ( target ) , GetY ( target ) ) then
6974: LD_VAR 0 9
6978: NOT
6979: PUSH
6980: LD_VAR 0 10
6984: PPUSH
6985: LD_VAR 0 9
6989: PPUSH
6990: CALL_OW 250
6994: PPUSH
6995: LD_VAR 0 9
6999: PPUSH
7000: CALL_OW 251
7004: PPUSH
7005: CALL 6164 0 3
7009: NOT
7010: OR
7011: IFFALSE 7045
// target := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
7013: LD_ADDR_VAR 0 9
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_VAR 0 2
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PPUSH
7030: CALL_OW 69
7034: PPUSH
7035: LD_VAR 0 10
7039: PPUSH
7040: CALL_OW 74
7044: ST_TO_ADDR
// if ( GetDistUnits ( target , unit ) < 4 and GetLives ( unit ) < 600 ) or ( GetLives ( unit ) < 200 and GetSide ( NearestUnitToUnit ( all_units diff unit , unit ) ) <> GetSide ( unit ) ) then
7045: LD_VAR 0 9
7049: PPUSH
7050: LD_VAR 0 10
7054: PPUSH
7055: CALL_OW 296
7059: PUSH
7060: LD_INT 4
7062: LESS
7063: PUSH
7064: LD_VAR 0 10
7068: PPUSH
7069: CALL_OW 256
7073: PUSH
7074: LD_INT 600
7076: LESS
7077: AND
7078: PUSH
7079: LD_VAR 0 10
7083: PPUSH
7084: CALL_OW 256
7088: PUSH
7089: LD_INT 200
7091: LESS
7092: PUSH
7093: LD_OWVAR 3
7097: PUSH
7098: LD_VAR 0 10
7102: DIFF
7103: PPUSH
7104: LD_VAR 0 10
7108: PPUSH
7109: CALL_OW 74
7113: PPUSH
7114: CALL_OW 255
7118: PUSH
7119: LD_VAR 0 10
7123: PPUSH
7124: CALL_OW 255
7128: NONEQUAL
7129: AND
7130: OR
7131: IFFALSE 7182
// begin for i = 1 to 4 do
7133: LD_ADDR_VAR 0 4
7137: PUSH
7138: DOUBLE
7139: LD_INT 1
7141: DEC
7142: ST_TO_ADDR
7143: LD_INT 4
7145: PUSH
7146: FOR_TO
7147: IFFALSE 7178
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
7149: LD_VAR 0 10
7153: PPUSH
7154: CALL_OW 250
7158: PPUSH
7159: LD_VAR 0 10
7163: PPUSH
7164: CALL_OW 251
7168: PPUSH
7169: LD_INT 1
7171: PPUSH
7172: CALL_OW 453
7176: GO 7146
7178: POP
7179: POP
// end else
7180: GO 7242
// if GetType ( target ) <> unit_human then
7182: LD_VAR 0 9
7186: PPUSH
7187: CALL_OW 247
7191: PUSH
7192: LD_INT 1
7194: NONEQUAL
7195: IFFALSE 7213
// ComAttackUnit ( unit , target ) else
7197: LD_VAR 0 10
7201: PPUSH
7202: LD_VAR 0 9
7206: PPUSH
7207: CALL_OW 115
7211: GO 7242
// ComMoveXY ( unit , GetX ( target ) , GetY ( target ) ) ;
7213: LD_VAR 0 10
7217: PPUSH
7218: LD_VAR 0 9
7222: PPUSH
7223: CALL_OW 250
7227: PPUSH
7228: LD_VAR 0 9
7232: PPUSH
7233: CALL_OW 251
7237: PPUSH
7238: CALL_OW 111
// end ;
7242: GO 6616
7244: POP
7245: POP
// end ;
7246: GO 6593
// end ; end_of_file
7248: LD_VAR 0 3
7252: RET
// export function Action ; var dial ; begin
7253: LD_INT 0
7255: PPUSH
7256: PPUSH
// CenterNowOnXY ( 192 , 1 ) ;
7257: LD_INT 192
7259: PPUSH
7260: LD_INT 1
7262: PPUSH
7263: CALL_OW 86
// InGameOn ;
7267: CALL_OW 8
// PrepareRussian ;
7271: CALL 3574 0 0
// dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff Davidov ;
7275: LD_ADDR_VAR 0 2
7279: PUSH
7280: LD_INT 22
7282: PUSH
7283: LD_INT 6
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: PUSH
7290: LD_INT 2
7292: PUSH
7293: LD_INT 25
7295: PUSH
7296: LD_INT 1
7298: PUSH
7299: EMPTY
7300: LIST
7301: LIST
7302: PUSH
7303: LD_INT 25
7305: PUSH
7306: LD_INT 2
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: PUSH
7313: LD_INT 25
7315: PUSH
7316: LD_INT 3
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PUSH
7323: LD_INT 25
7325: PUSH
7326: LD_INT 4
7328: PUSH
7329: EMPTY
7330: LIST
7331: LIST
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: PPUSH
7344: CALL_OW 69
7348: PUSH
7349: LD_EXP 2
7353: DIFF
7354: ST_TO_ADDR
// ComMoveXY ( dial [ 1 ] , 202 , 40 ) ;
7355: LD_VAR 0 2
7359: PUSH
7360: LD_INT 1
7362: ARRAY
7363: PPUSH
7364: LD_INT 202
7366: PPUSH
7367: LD_INT 40
7369: PPUSH
7370: CALL_OW 111
// Wait ( 0 0$03 ) ;
7374: LD_INT 105
7376: PPUSH
7377: CALL_OW 67
// Say ( Davidov , DDav-1 ) ;
7381: LD_EXP 2
7385: PPUSH
7386: LD_STRING DDav-1
7388: PPUSH
7389: CALL_OW 88
// ComTurnUnit ( dial [ 1 ] , Davidov ) ;
7393: LD_VAR 0 2
7397: PUSH
7398: LD_INT 1
7400: ARRAY
7401: PPUSH
7402: LD_EXP 2
7406: PPUSH
7407: CALL_OW 119
// ComTurnUnit ( Davidov , dial [ 1 ] ) ;
7411: LD_EXP 2
7415: PPUSH
7416: LD_VAR 0 2
7420: PUSH
7421: LD_INT 1
7423: ARRAY
7424: PPUSH
7425: CALL_OW 119
// CenterOnXY ( 202 , 40 ) ;
7429: LD_INT 202
7431: PPUSH
7432: LD_INT 40
7434: PPUSH
7435: CALL_OW 84
// Say ( dial [ 1 ] , DRus-1 ) ;
7439: LD_VAR 0 2
7443: PUSH
7444: LD_INT 1
7446: ARRAY
7447: PPUSH
7448: LD_STRING DRus-1
7450: PPUSH
7451: CALL_OW 88
// Say ( Davidov , DDav-2 ) ;
7455: LD_EXP 2
7459: PPUSH
7460: LD_STRING DDav-2
7462: PPUSH
7463: CALL_OW 88
// Say ( dial [ 1 ] , DRus-2 ) ;
7467: LD_VAR 0 2
7471: PUSH
7472: LD_INT 1
7474: ARRAY
7475: PPUSH
7476: LD_STRING DRus-2
7478: PPUSH
7479: CALL_OW 88
// Say ( Davidov , DDav-3 ) ;
7483: LD_EXP 2
7487: PPUSH
7488: LD_STRING DDav-3
7490: PPUSH
7491: CALL_OW 88
// InGameOff ;
7495: CALL_OW 9
// Wait ( 0 0$0.3 ) ;
7499: LD_INT 10
7501: PPUSH
7502: CALL_OW 67
// ChangeMissionObjectives ( C1 ) ;
7506: LD_STRING C1
7508: PPUSH
7509: CALL_OW 337
// end ;
7513: LD_VAR 0 1
7517: RET
// every 0 0$30 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
7518: LD_INT 22
7520: PUSH
7521: LD_INT 6
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 2
7530: PUSH
7531: LD_INT 30
7533: PUSH
7534: LD_INT 6
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: PUSH
7541: LD_INT 30
7543: PUSH
7544: LD_INT 7
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_INT 30
7553: PUSH
7554: LD_INT 8
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PPUSH
7571: CALL_OW 69
7575: IFFALSE 7675
7577: GO 7579
7579: DISABLE
// begin Say ( Davidov , DDav-4 ) ;
7580: LD_EXP 2
7584: PPUSH
7585: LD_STRING DDav-4
7587: PPUSH
7588: CALL_OW 88
// Wait ( 0 0$40 ) ;
7592: LD_INT 1400
7594: PPUSH
7595: CALL_OW 67
// DialogueOn ;
7599: CALL_OW 6
// SayRadio ( Vervecken , Dver-Meet-1 ) ;
7603: LD_EXP 3
7607: PPUSH
7608: LD_STRING Dver-Meet-1
7610: PPUSH
7611: CALL_OW 94
// Say ( Davidov , DDav-Meet-1 ) ;
7615: LD_EXP 2
7619: PPUSH
7620: LD_STRING DDav-Meet-1
7622: PPUSH
7623: CALL_OW 88
// SayRadio ( Vervecken , Dver-Meet-2 ) ;
7627: LD_EXP 3
7631: PPUSH
7632: LD_STRING Dver-Meet-2
7634: PPUSH
7635: CALL_OW 94
// DialogueOff ;
7639: CALL_OW 7
// Wait ( [ 9 9$20 , 7 7$20 , 6 6$20 ] [ Difficulty ] ) ;
7643: LD_INT 19600
7645: PUSH
7646: LD_INT 15400
7648: PUSH
7649: LD_INT 13300
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: LIST
7656: PUSH
7657: LD_OWVAR 67
7661: ARRAY
7662: PPUSH
7663: CALL_OW 67
// legion_attacks_active := true ;
7667: LD_ADDR_EXP 7
7671: PUSH
7672: LD_INT 1
7674: ST_TO_ADDR
// end ;
7675: END
// every 0 0$02 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_factory ] ] ) or tick > 10 10$00 do var dial ;
7676: LD_INT 22
7678: PUSH
7679: LD_INT 6
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 30
7688: PUSH
7689: LD_INT 3
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PPUSH
7700: CALL_OW 69
7704: PUSH
7705: LD_OWVAR 1
7709: PUSH
7710: LD_INT 21000
7712: GREATER
7713: OR
7714: IFFALSE 7948
7716: GO 7718
7718: DISABLE
7719: LD_INT 0
7721: PPUSH
// begin dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff Davidov ;
7722: LD_ADDR_VAR 0 1
7726: PUSH
7727: LD_INT 22
7729: PUSH
7730: LD_INT 6
7732: PUSH
7733: EMPTY
7734: LIST
7735: LIST
7736: PUSH
7737: LD_INT 2
7739: PUSH
7740: LD_INT 25
7742: PUSH
7743: LD_INT 1
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: LD_INT 25
7752: PUSH
7753: LD_INT 2
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PUSH
7760: LD_INT 25
7762: PUSH
7763: LD_INT 3
7765: PUSH
7766: EMPTY
7767: LIST
7768: LIST
7769: PUSH
7770: LD_INT 25
7772: PUSH
7773: LD_INT 4
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: PPUSH
7791: CALL_OW 69
7795: PUSH
7796: LD_EXP 2
7800: DIFF
7801: ST_TO_ADDR
// Say ( dial [ 1 ] , DRus-3 ) ;
7802: LD_VAR 0 1
7806: PUSH
7807: LD_INT 1
7809: ARRAY
7810: PPUSH
7811: LD_STRING DRus-3
7813: PPUSH
7814: CALL_OW 88
// Say ( Davidov , DDav-5 ) ;
7818: LD_EXP 2
7822: PPUSH
7823: LD_STRING DDav-5
7825: PPUSH
7826: CALL_OW 88
// Say ( dial [ 1 ] , DRus-4 ) ;
7830: LD_VAR 0 1
7834: PUSH
7835: LD_INT 1
7837: ARRAY
7838: PPUSH
7839: LD_STRING DRus-4
7841: PPUSH
7842: CALL_OW 88
// Say ( Davidov , DDav-6 ) ;
7846: LD_EXP 2
7850: PPUSH
7851: LD_STRING DDav-6
7853: PPUSH
7854: CALL_OW 88
// ChangeMissionObjectives ( C2 ) ;
7858: LD_STRING C2
7860: PPUSH
7861: CALL_OW 337
// Wait ( 5 5$00 ) ;
7865: LD_INT 10500
7867: PPUSH
7868: CALL_OW 67
// DialogueOn ;
7872: CALL_OW 6
// SayRadio ( Bagins , DBag-1 ) ;
7876: LD_EXP 1
7880: PPUSH
7881: LD_STRING DBag-1
7883: PPUSH
7884: CALL_OW 94
// Say ( Davidov , DDavB-1 ) ;
7888: LD_EXP 2
7892: PPUSH
7893: LD_STRING DDavB-1
7895: PPUSH
7896: CALL_OW 88
// SayRadio ( Bagins , DBag-2 ) ;
7900: LD_EXP 1
7904: PPUSH
7905: LD_STRING DBag-2
7907: PPUSH
7908: CALL_OW 94
// Say ( Davidov , DDavB-2 ) ;
7912: LD_EXP 2
7916: PPUSH
7917: LD_STRING DDavB-2
7919: PPUSH
7920: CALL_OW 88
// SayRadio ( Bagins , DBag-3 ) ;
7924: LD_EXP 1
7928: PPUSH
7929: LD_STRING DBag-3
7931: PPUSH
7932: CALL_OW 94
// DialogueOff ;
7936: CALL_OW 7
// alliance_attack_active := true ;
7940: LD_ADDR_EXP 9
7944: PUSH
7945: LD_INT 1
7947: ST_TO_ADDR
// end ;
7948: PPOPN 1
7950: END
// every 0 0$1 trigger alliance_used_artifact_1 do
7951: LD_EXP 10
7955: IFFALSE 8002
7957: GO 7959
7959: DISABLE
// begin DialogueOn ;
7960: CALL_OW 6
// CenterNowOnXY ( alliance_used_artifact_1 [ 1 ] , alliance_used_artifact_1 [ 2 ] ) ;
7964: LD_EXP 10
7968: PUSH
7969: LD_INT 1
7971: ARRAY
7972: PPUSH
7973: LD_EXP 10
7977: PUSH
7978: LD_INT 2
7980: ARRAY
7981: PPUSH
7982: CALL_OW 86
// Say ( Davidov , DDav-Artifact1-1 ) ;
7986: LD_EXP 2
7990: PPUSH
7991: LD_STRING DDav-Artifact1-1
7993: PPUSH
7994: CALL_OW 88
// DialogueOff ;
7998: CALL_OW 7
// end ;
8002: END
// every 0 0$1 trigger alliance_used_artifact_2 do
8003: LD_EXP 11
8007: IFFALSE 8054
8009: GO 8011
8011: DISABLE
// begin DialogueOn ;
8012: CALL_OW 6
// CenterNowOnXY ( alliance_used_artifact_2 [ 1 ] , alliance_used_artifact_2 [ 2 ] ) ;
8016: LD_EXP 11
8020: PUSH
8021: LD_INT 1
8023: ARRAY
8024: PPUSH
8025: LD_EXP 11
8029: PUSH
8030: LD_INT 2
8032: ARRAY
8033: PPUSH
8034: CALL_OW 86
// Say ( Davidov , DDav-Artifact2-1 ) ;
8038: LD_EXP 2
8042: PPUSH
8043: LD_STRING DDav-Artifact2-1
8045: PPUSH
8046: CALL_OW 88
// DialogueOff ;
8050: CALL_OW 7
// end ;
8054: END
// every 0 0$01 trigger artifact_destroyed or ( not FindArtifact ( 6 ) and not player_artifact_loaded ) do
8055: LD_EXP 16
8059: PUSH
8060: LD_INT 6
8062: PPUSH
8063: CALL_OW 469
8067: NOT
8068: PUSH
8069: LD_EXP 18
8073: NOT
8074: AND
8075: OR
8076: IFFALSE 8088
8078: GO 8080
8080: DISABLE
// YouLost ( artifact_destroyed ) ;
8081: LD_STRING artifact_destroyed
8083: PPUSH
8084: CALL_OW 104
8088: END
// every 0 0$01 trigger IsDead ( Davidov ) do
8089: LD_EXP 2
8093: PPUSH
8094: CALL_OW 301
8098: IFFALSE 8110
8100: GO 8102
8102: DISABLE
// YouLost ( dead ) ;
8103: LD_STRING dead
8105: PPUSH
8106: CALL_OW 104
8110: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) = 0 do
8111: LD_INT 22
8113: PUSH
8114: LD_INT 7
8116: PUSH
8117: EMPTY
8118: LIST
8119: LIST
8120: PUSH
8121: LD_INT 21
8123: PUSH
8124: LD_INT 1
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: PUSH
8131: EMPTY
8132: LIST
8133: LIST
8134: PPUSH
8135: CALL_OW 69
8139: PUSH
8140: LD_INT 0
8142: EQUAL
8143: IFFALSE 8277
8145: GO 8147
8147: DISABLE
// begin if tick < [ 120 120$00 , 100 100$00 , 90 90$00 ] [ Difficulty ] then
8148: LD_OWVAR 1
8152: PUSH
8153: LD_INT 252000
8155: PUSH
8156: LD_INT 210000
8158: PUSH
8159: LD_INT 189000
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: LIST
8166: PUSH
8167: LD_OWVAR 67
8171: ARRAY
8172: LESS
8173: IFFALSE 8187
// AddMedal ( med1 , 1 ) else
8175: LD_STRING med1
8177: PPUSH
8178: LD_INT 1
8180: PPUSH
8181: CALL_OW 101
8185: GO 8198
// AddMedal ( med1 , - 1 ) ;
8187: LD_STRING med1
8189: PPUSH
8190: LD_INT 1
8192: NEG
8193: PPUSH
8194: CALL_OW 101
// if FilterAllUnits ( [ f_side , 8 ] ) then
8198: LD_INT 22
8200: PUSH
8201: LD_INT 8
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PPUSH
8208: CALL_OW 69
8212: IFFALSE 8227
// AddMedal ( med2 , - 1 ) else
8214: LD_STRING med2
8216: PPUSH
8217: LD_INT 1
8219: NEG
8220: PPUSH
8221: CALL_OW 101
8225: GO 8237
// AddMedal ( med2 , 1 ) ;
8227: LD_STRING med2
8229: PPUSH
8230: LD_INT 1
8232: PPUSH
8233: CALL_OW 101
// if player_used_sib_bomb then
8237: LD_EXP 12
8241: IFFALSE 8256
// AddMedal ( med3 , - 1 ) else
8243: LD_STRING med3
8245: PPUSH
8246: LD_INT 1
8248: NEG
8249: PPUSH
8250: CALL_OW 101
8254: GO 8266
// AddMedal ( med3 , 1 ) ;
8256: LD_STRING med3
8258: PPUSH
8259: LD_INT 1
8261: PPUSH
8262: CALL_OW 101
// GiveMedals ( MAIN ) ;
8266: LD_STRING MAIN
8268: PPUSH
8269: CALL_OW 102
// YouWin ;
8273: CALL_OW 103
// end ; end_of_file
8277: END
// every 0 0$22 + 0 0$2 do
8278: GO 8280
8280: DISABLE
// begin enable ;
8281: ENABLE
// CreateCratesArea ( Rand ( 4 , 5 ) , cratesArea , true ) ;
8282: LD_INT 4
8284: PPUSH
8285: LD_INT 5
8287: PPUSH
8288: CALL_OW 12
8292: PPUSH
8293: LD_INT 3
8295: PPUSH
8296: LD_INT 1
8298: PPUSH
8299: CALL_OW 55
// if tick >= 4 4$00 then
8303: LD_OWVAR 1
8307: PUSH
8308: LD_INT 8400
8310: GREATEREQUAL
8311: IFFALSE 8318
// begin disable ;
8313: DISABLE
// CratesSpawn ( ) ;
8314: CALL 8319 0 0
// end ; end ;
8318: END
// function CratesSpawn ( ) ; var i , amount , cr ; begin
8319: LD_INT 0
8321: PPUSH
8322: PPUSH
8323: PPUSH
8324: PPUSH
// amount := [ 30000 , 20000 , 10000 ] [ Difficulty ] ;
8325: LD_ADDR_VAR 0 3
8329: PUSH
8330: LD_INT 30000
8332: PUSH
8333: LD_INT 20000
8335: PUSH
8336: LD_INT 10000
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: LIST
8343: PUSH
8344: LD_OWVAR 67
8348: ARRAY
8349: ST_TO_ADDR
// while amount > 0 do
8350: LD_VAR 0 3
8354: PUSH
8355: LD_INT 0
8357: GREATER
8358: IFFALSE 8428
// begin Wait ( rand ( 0 0$30 , 1 1$30 ) ) ;
8360: LD_INT 1050
8362: PPUSH
8363: LD_INT 3150
8365: PPUSH
8366: CALL_OW 12
8370: PPUSH
8371: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
8375: LD_ADDR_VAR 0 4
8379: PUSH
8380: LD_INT 1
8382: PPUSH
8383: LD_INT 5
8385: PPUSH
8386: CALL_OW 12
8390: ST_TO_ADDR
// amount := amount - ( cr * 10 ) ;
8391: LD_ADDR_VAR 0 3
8395: PUSH
8396: LD_VAR 0 3
8400: PUSH
8401: LD_VAR 0 4
8405: PUSH
8406: LD_INT 10
8408: MUL
8409: MINUS
8410: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
8411: LD_VAR 0 4
8415: PPUSH
8416: LD_INT 3
8418: PPUSH
8419: LD_INT 1
8421: PPUSH
8422: CALL_OW 55
// end ;
8426: GO 8350
// end ; end_of_file
8428: LD_VAR 0 1
8432: RET
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird , horse ; begin
8433: LD_INT 0
8435: PPUSH
8436: PPUSH
8437: PPUSH
8438: PPUSH
8439: PPUSH
8440: PPUSH
// uc_nation = nation_nature ;
8441: LD_ADDR_OWVAR 21
8445: PUSH
8446: LD_INT 0
8448: ST_TO_ADDR
// uc_side = 0 ;
8449: LD_ADDR_OWVAR 20
8453: PUSH
8454: LD_INT 0
8456: ST_TO_ADDR
// l = 0 ;
8457: LD_ADDR_VAR 0 6
8461: PUSH
8462: LD_INT 0
8464: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
8465: LD_ADDR_OWVAR 24
8469: PUSH
8470: LD_INT 0
8472: PPUSH
8473: LD_INT 5
8475: PPUSH
8476: CALL_OW 12
8480: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
8481: LD_ADDR_OWVAR 35
8485: PUSH
8486: LD_INT 5
8488: NEG
8489: PPUSH
8490: LD_INT 5
8492: PPUSH
8493: CALL_OW 12
8497: ST_TO_ADDR
// hc_gallery =  ;
8498: LD_ADDR_OWVAR 33
8502: PUSH
8503: LD_STRING 
8505: ST_TO_ADDR
// hc_class = class_apeman ;
8506: LD_ADDR_OWVAR 28
8510: PUSH
8511: LD_INT 12
8513: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
8514: LD_ADDR_OWVAR 29
8518: PUSH
8519: LD_INT 11
8521: PPUSH
8522: LD_INT 13
8524: PPUSH
8525: CALL_OW 12
8529: PUSH
8530: LD_INT 10
8532: PPUSH
8533: LD_INT 11
8535: PPUSH
8536: CALL_OW 12
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: ST_TO_ADDR
// hc_sex = sex_male ;
8545: LD_ADDR_OWVAR 27
8549: PUSH
8550: LD_INT 1
8552: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
8553: LD_ADDR_OWVAR 31
8557: PUSH
8558: LD_INT 0
8560: PPUSH
8561: LD_INT 2
8563: PPUSH
8564: CALL_OW 12
8568: PUSH
8569: LD_INT 0
8571: PUSH
8572: LD_INT 0
8574: PUSH
8575: LD_INT 0
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: ST_TO_ADDR
// apeman = CreateHuman ;
8584: LD_ADDR_VAR 0 7
8588: PUSH
8589: CALL_OW 44
8593: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
8594: LD_VAR 0 7
8598: PPUSH
8599: LD_VAR 0 4
8603: PPUSH
8604: LD_INT 0
8606: PPUSH
8607: CALL_OW 49
// l = l + 1 ;
8611: LD_ADDR_VAR 0 6
8615: PUSH
8616: LD_VAR 0 6
8620: PUSH
8621: LD_INT 1
8623: PLUS
8624: ST_TO_ADDR
// end until l = num1 ;
8625: LD_VAR 0 6
8629: PUSH
8630: LD_VAR 0 1
8634: EQUAL
8635: IFFALSE 8465
// l = 0 ;
8637: LD_ADDR_VAR 0 6
8641: PUSH
8642: LD_INT 0
8644: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
8645: LD_ADDR_OWVAR 35
8649: PUSH
8650: LD_INT 0
8652: PPUSH
8653: LD_INT 25
8655: PPUSH
8656: CALL_OW 12
8660: ST_TO_ADDR
// hc_class = class_tiger ;
8661: LD_ADDR_OWVAR 28
8665: PUSH
8666: LD_INT 14
8668: ST_TO_ADDR
// hc_sex = sex_male ;
8669: LD_ADDR_OWVAR 27
8673: PUSH
8674: LD_INT 1
8676: ST_TO_ADDR
// hc_gallery = sandnature ;
8677: LD_ADDR_OWVAR 33
8681: PUSH
8682: LD_STRING sandnature
8684: ST_TO_ADDR
// hc_face_number = 3 ;
8685: LD_ADDR_OWVAR 34
8689: PUSH
8690: LD_INT 3
8692: ST_TO_ADDR
// tiger = CreateHuman ;
8693: LD_ADDR_VAR 0 8
8697: PUSH
8698: CALL_OW 44
8702: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8703: LD_VAR 0 8
8707: PPUSH
8708: LD_VAR 0 4
8712: PPUSH
8713: LD_INT 0
8715: PPUSH
8716: CALL_OW 49
// l = l + 1 ;
8720: LD_ADDR_VAR 0 6
8724: PUSH
8725: LD_VAR 0 6
8729: PUSH
8730: LD_INT 1
8732: PLUS
8733: ST_TO_ADDR
// end until l = num2 ;
8734: LD_VAR 0 6
8738: PUSH
8739: LD_VAR 0 2
8743: EQUAL
8744: IFFALSE 8645
// l = 0 ;
8746: LD_ADDR_VAR 0 6
8750: PUSH
8751: LD_INT 0
8753: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8754: LD_ADDR_OWVAR 28
8758: PUSH
8759: LD_INT 18
8761: ST_TO_ADDR
// hc_gallery = sandnature ;
8762: LD_ADDR_OWVAR 33
8766: PUSH
8767: LD_STRING sandnature
8769: ST_TO_ADDR
// hc_face_number = 1 ;
8770: LD_ADDR_OWVAR 34
8774: PUSH
8775: LD_INT 1
8777: ST_TO_ADDR
// bird = CreateHuman ;
8778: LD_ADDR_VAR 0 9
8782: PUSH
8783: CALL_OW 44
8787: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8788: LD_VAR 0 9
8792: PPUSH
8793: LD_INT 0
8795: PPUSH
8796: CALL_OW 51
// l = l + 1 ;
8800: LD_ADDR_VAR 0 6
8804: PUSH
8805: LD_VAR 0 6
8809: PUSH
8810: LD_INT 1
8812: PLUS
8813: ST_TO_ADDR
// end until l = num3 ;
8814: LD_VAR 0 6
8818: PUSH
8819: LD_VAR 0 3
8823: EQUAL
8824: IFFALSE 8754
// for l = 1 to 2 do
8826: LD_ADDR_VAR 0 6
8830: PUSH
8831: DOUBLE
8832: LD_INT 1
8834: DEC
8835: ST_TO_ADDR
8836: LD_INT 2
8838: PUSH
8839: FOR_TO
8840: IFFALSE 8898
// begin hc_class = 21 ;
8842: LD_ADDR_OWVAR 28
8846: PUSH
8847: LD_INT 21
8849: ST_TO_ADDR
// hc_gallery =  ;
8850: LD_ADDR_OWVAR 33
8854: PUSH
8855: LD_STRING 
8857: ST_TO_ADDR
// hc_agressivity = 0 ;
8858: LD_ADDR_OWVAR 35
8862: PUSH
8863: LD_INT 0
8865: ST_TO_ADDR
// hc_face_number = 5 ;
8866: LD_ADDR_OWVAR 34
8870: PUSH
8871: LD_INT 5
8873: ST_TO_ADDR
// horse := CreateHuman ;
8874: LD_ADDR_VAR 0 10
8878: PUSH
8879: CALL_OW 44
8883: ST_TO_ADDR
// PlaceUnitAnywhere ( horse , false ) ;
8884: LD_VAR 0 10
8888: PPUSH
8889: LD_INT 0
8891: PPUSH
8892: CALL_OW 51
// end ;
8896: GO 8839
8898: POP
8899: POP
// hc_gallery :=  ;
8900: LD_ADDR_OWVAR 33
8904: PUSH
8905: LD_STRING 
8907: ST_TO_ADDR
// hc_name :=  ;
8908: LD_ADDR_OWVAR 26
8912: PUSH
8913: LD_STRING 
8915: ST_TO_ADDR
// end ; end_of_file
8916: LD_VAR 0 5
8920: RET
// every 0 0$01 trigger not debug do var timer ;
8921: LD_EXP 6
8925: NOT
8926: IFFALSE 8986
8928: GO 8930
8930: DISABLE
8931: LD_INT 0
8933: PPUSH
// begin timer := 0 0$00 ;
8934: LD_ADDR_VAR 0 1
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// while ( true ) do
8942: LD_INT 1
8944: IFFALSE 8986
// begin timer := timer + 0 0$01 ;
8946: LD_ADDR_VAR 0 1
8950: PUSH
8951: LD_VAR 0 1
8955: PUSH
8956: LD_INT 35
8958: PLUS
8959: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
8960: LD_ADDR_OWVAR 47
8964: PUSH
8965: LD_STRING #tick
8967: PUSH
8968: LD_VAR 0 1
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
8977: LD_INT 35
8979: PPUSH
8980: CALL_OW 67
// end ;
8984: GO 8942
// end ; end_of_file
8986: PPOPN 1
8988: END
// export function DebugArtifact ; begin
8989: LD_INT 0
8991: PPUSH
// AddToLog ( Artifact is loaded:  & player_artifact_loaded ) ;
8992: LD_STRING Artifact is loaded: 
8994: PUSH
8995: LD_EXP 18
8999: STR
9000: PPUSH
9001: CALL_OW 561
// AddToLog ( Artifact is active:  & player_artifact_ready ) ;
9005: LD_STRING Artifact is active: 
9007: PUSH
9008: LD_EXP 29
9012: STR
9013: PPUSH
9014: CALL_OW 561
// AddToLog ( Artifact is researched:  & player_artifact_researched ) ;
9018: LD_STRING Artifact is researched: 
9020: PUSH
9021: LD_EXP 22
9025: STR
9026: PPUSH
9027: CALL_OW 561
// AddToLog ( Artifact coords  & FindArtifact ( player_artifact_number ) ) ;
9031: LD_STRING Artifact coords 
9033: PUSH
9034: LD_EXP 19
9038: PPUSH
9039: CALL_OW 469
9043: STR
9044: PPUSH
9045: CALL_OW 561
// end ;
9049: LD_VAR 0 1
9053: RET
// export function InitArtifactsPos ( ) ; var i , tmp , possible_pos ; begin
9054: LD_INT 0
9056: PPUSH
9057: PPUSH
9058: PPUSH
9059: PPUSH
// possible_pos := [ [ 100 , 185 ] , [ 99 , 175 ] , [ 117 , 191 ] ] ;
9060: LD_ADDR_VAR 0 4
9064: PUSH
9065: LD_INT 100
9067: PUSH
9068: LD_INT 185
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: PUSH
9075: LD_INT 99
9077: PUSH
9078: LD_INT 175
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: PUSH
9085: LD_INT 117
9087: PUSH
9088: LD_INT 191
9090: PUSH
9091: EMPTY
9092: LIST
9093: LIST
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: LIST
9099: ST_TO_ADDR
// for i = 1 to artifacts_type do
9100: LD_ADDR_VAR 0 2
9104: PUSH
9105: DOUBLE
9106: LD_INT 1
9108: DEC
9109: ST_TO_ADDR
9110: LD_EXP 14
9114: PUSH
9115: FOR_TO
9116: IFFALSE 9218
// begin tmp := possible_pos [ rand ( 1 , possible_pos ) ] ;
9118: LD_ADDR_VAR 0 3
9122: PUSH
9123: LD_VAR 0 4
9127: PUSH
9128: LD_INT 1
9130: PPUSH
9131: LD_VAR 0 4
9135: PPUSH
9136: CALL_OW 12
9140: ARRAY
9141: ST_TO_ADDR
// possible_pos := possible_pos diff tmp ;
9142: LD_ADDR_VAR 0 4
9146: PUSH
9147: LD_VAR 0 4
9151: PUSH
9152: LD_VAR 0 3
9156: DIFF
9157: ST_TO_ADDR
// artifacts_pos := Insert ( artifacts_pos , i , tmp ) ;
9158: LD_ADDR_EXP 15
9162: PUSH
9163: LD_EXP 15
9167: PPUSH
9168: LD_VAR 0 2
9172: PPUSH
9173: LD_VAR 0 3
9177: PPUSH
9178: CALL_OW 2
9182: ST_TO_ADDR
// CreateArtifact ( artifacts_type [ i ] , tmp [ 1 ] , tmp [ 2 ] ) ;
9183: LD_EXP 14
9187: PUSH
9188: LD_VAR 0 2
9192: ARRAY
9193: PPUSH
9194: LD_VAR 0 3
9198: PUSH
9199: LD_INT 1
9201: ARRAY
9202: PPUSH
9203: LD_VAR 0 3
9207: PUSH
9208: LD_INT 2
9210: ARRAY
9211: PPUSH
9212: CALL 5189 0 3
// end ;
9216: GO 9115
9218: POP
9219: POP
// end ;
9220: LD_VAR 0 1
9224: RET
// export function GetUseCost ( dist ) ; begin
9225: LD_INT 0
9227: PPUSH
// if dist < 30 then
9228: LD_VAR 0 1
9232: PUSH
9233: LD_INT 30
9235: LESS
9236: IFFALSE 9246
// result := 10 ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_INT 10
9245: ST_TO_ADDR
// if dist >= 30 and dist < 50 then
9246: LD_VAR 0 1
9250: PUSH
9251: LD_INT 30
9253: GREATEREQUAL
9254: PUSH
9255: LD_VAR 0 1
9259: PUSH
9260: LD_INT 50
9262: LESS
9263: AND
9264: IFFALSE 9274
// result := 35 ;
9266: LD_ADDR_VAR 0 2
9270: PUSH
9271: LD_INT 35
9273: ST_TO_ADDR
// if dist >= 50 and dist < 80 then
9274: LD_VAR 0 1
9278: PUSH
9279: LD_INT 50
9281: GREATEREQUAL
9282: PUSH
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 80
9290: LESS
9291: AND
9292: IFFALSE 9302
// result := 70 ;
9294: LD_ADDR_VAR 0 2
9298: PUSH
9299: LD_INT 70
9301: ST_TO_ADDR
// if dist >= 80 and dist < 120 then
9302: LD_VAR 0 1
9306: PUSH
9307: LD_INT 80
9309: GREATEREQUAL
9310: PUSH
9311: LD_VAR 0 1
9315: PUSH
9316: LD_INT 120
9318: LESS
9319: AND
9320: IFFALSE 9330
// result := 100 ;
9322: LD_ADDR_VAR 0 2
9326: PUSH
9327: LD_INT 100
9329: ST_TO_ADDR
// if dist >= 120 then
9330: LD_VAR 0 1
9334: PUSH
9335: LD_INT 120
9337: GREATEREQUAL
9338: IFFALSE 9348
// result := 150 ;
9340: LD_ADDR_VAR 0 2
9344: PUSH
9345: LD_INT 150
9347: ST_TO_ADDR
// end ;
9348: LD_VAR 0 2
9352: RET
// on ArtifactResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
9353: LD_VAR 0 1
9357: PPUSH
9358: CALL_OW 255
9362: PUSH
9363: LD_OWVAR 2
9367: EQUAL
9368: IFFALSE 9378
// player_artifact_researched := true ;
9370: LD_ADDR_EXP 22
9374: PUSH
9375: LD_INT 1
9377: ST_TO_ADDR
// end ;
9378: PPOPN 1
9380: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) and player_artifact_researched and not player_artifact_loaded do var lab , coords ;
9381: LD_INT 22
9383: PUSH
9384: LD_OWVAR 2
9388: PUSH
9389: EMPTY
9390: LIST
9391: LIST
9392: PUSH
9393: LD_INT 2
9395: PUSH
9396: LD_INT 30
9398: PUSH
9399: LD_INT 8
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: PUSH
9406: LD_INT 30
9408: PUSH
9409: LD_INT 11
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PPUSH
9425: CALL_OW 69
9429: PUSH
9430: LD_EXP 22
9434: AND
9435: PUSH
9436: LD_EXP 18
9440: NOT
9441: AND
9442: IFFALSE 9896
9444: GO 9446
9446: DISABLE
9447: LD_INT 0
9449: PPUSH
9450: PPUSH
// begin enable ;
9451: ENABLE
// coords := FindArtifact ( player_artifact_number ) ;
9452: LD_ADDR_VAR 0 2
9456: PUSH
9457: LD_EXP 19
9461: PPUSH
9462: CALL_OW 469
9466: ST_TO_ADDR
// if not coords then
9467: LD_VAR 0 2
9471: NOT
9472: IFFALSE 9476
// exit ;
9474: GO 9896
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , coords [ 1 ] , coords [ 2 ] ) ;
9476: LD_ADDR_VAR 0 1
9480: PUSH
9481: LD_INT 22
9483: PUSH
9484: LD_OWVAR 2
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: LD_INT 2
9495: PUSH
9496: LD_INT 30
9498: PUSH
9499: LD_INT 8
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: PUSH
9506: LD_INT 30
9508: PUSH
9509: LD_INT 11
9511: PUSH
9512: EMPTY
9513: LIST
9514: LIST
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PPUSH
9525: CALL_OW 69
9529: PPUSH
9530: LD_VAR 0 2
9534: PUSH
9535: LD_INT 1
9537: ARRAY
9538: PPUSH
9539: LD_VAR 0 2
9543: PUSH
9544: LD_INT 2
9546: ARRAY
9547: PPUSH
9548: CALL_OW 73
9552: ST_TO_ADDR
// if not lab then
9553: LD_VAR 0 1
9557: NOT
9558: IFFALSE 9575
// begin if debug then
9560: LD_EXP 6
9564: IFFALSE 9573
// AddToLog ( Cannot find lab for artifact! ) ;
9566: LD_STRING Cannot find lab for artifact!
9568: PPUSH
9569: CALL_OW 561
// exit ;
9573: GO 9896
// end ; if not player_artifact_ready then
9575: LD_EXP 29
9579: NOT
9580: IFFALSE 9704
// begin if GetDistUnitXY ( lab , coords [ 1 ] , coords [ 2 ] ) < player_artifact_active_distance then
9582: LD_VAR 0 1
9586: PPUSH
9587: LD_VAR 0 2
9591: PUSH
9592: LD_INT 1
9594: ARRAY
9595: PPUSH
9596: LD_VAR 0 2
9600: PUSH
9601: LD_INT 2
9603: ARRAY
9604: PPUSH
9605: CALL_OW 297
9609: PUSH
9610: LD_EXP 23
9614: LESS
9615: IFFALSE 9680
// begin if BuildingStatus ( lab ) = bs_idle then
9617: LD_VAR 0 1
9621: PPUSH
9622: CALL_OW 461
9626: PUSH
9627: LD_INT 2
9629: EQUAL
9630: IFFALSE 9656
// SetArtifactUse ( your_side , player_artifact_icon_res , art_instant , lab ) else
9632: LD_OWVAR 2
9636: PPUSH
9637: LD_EXP 25
9641: PPUSH
9642: LD_INT 2
9644: PPUSH
9645: LD_VAR 0 1
9649: PPUSH
9650: CALL_OW 468
9654: GO 9678
// SetArtifactUse ( your_side , player_artifact_icon_res , art_gray , lab ) ;
9656: LD_OWVAR 2
9660: PPUSH
9661: LD_EXP 25
9665: PPUSH
9666: LD_INT 1
9668: PPUSH
9669: LD_VAR 0 1
9673: PPUSH
9674: CALL_OW 468
// end else
9678: GO 9702
// SetArtifactUse ( your_side , player_artifact_icon_res , art_gray , lab ) ;
9680: LD_OWVAR 2
9684: PPUSH
9685: LD_EXP 25
9689: PPUSH
9690: LD_INT 1
9692: PPUSH
9693: LD_VAR 0 1
9697: PPUSH
9698: CALL_OW 468
// end else
9702: GO 9896
// if GetDistUnitXY ( lab , coords [ 1 ] , coords [ 2 ] ) < player_artifact_active_distance then
9704: LD_VAR 0 1
9708: PPUSH
9709: LD_VAR 0 2
9713: PUSH
9714: LD_INT 1
9716: ARRAY
9717: PPUSH
9718: LD_VAR 0 2
9722: PUSH
9723: LD_INT 2
9725: ARRAY
9726: PPUSH
9727: CALL_OW 297
9731: PUSH
9732: LD_EXP 23
9736: LESS
9737: IFFALSE 9852
// begin if BuildingStatus ( lab ) = bs_idle then
9739: LD_VAR 0 1
9743: PPUSH
9744: CALL_OW 461
9748: PUSH
9749: LD_INT 2
9751: EQUAL
9752: IFFALSE 9806
// begin SetArtifactUse ( your_side , player_artifact_icon , art_unit , lab ) ;
9754: LD_OWVAR 2
9758: PPUSH
9759: LD_EXP 20
9763: PPUSH
9764: LD_INT 4
9766: PPUSH
9767: LD_VAR 0 1
9771: PPUSH
9772: CALL_OW 468
// if player_artifact_selected_unit then
9776: LD_EXP 30
9780: IFFALSE 9804
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_place , lab ) ;
9782: LD_OWVAR 2
9786: PPUSH
9787: LD_EXP 21
9791: PPUSH
9792: LD_INT 3
9794: PPUSH
9795: LD_VAR 0 1
9799: PPUSH
9800: CALL_OW 468
// end else
9804: GO 9850
// begin SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
9806: LD_OWVAR 2
9810: PPUSH
9811: LD_EXP 20
9815: PPUSH
9816: LD_INT 1
9818: PPUSH
9819: LD_VAR 0 1
9823: PPUSH
9824: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_gray , lab ) ;
9828: LD_OWVAR 2
9832: PPUSH
9833: LD_EXP 21
9837: PPUSH
9838: LD_INT 1
9840: PPUSH
9841: LD_VAR 0 1
9845: PPUSH
9846: CALL_OW 468
// end ; end else
9850: GO 9896
// begin SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
9852: LD_OWVAR 2
9856: PPUSH
9857: LD_EXP 20
9861: PPUSH
9862: LD_INT 1
9864: PPUSH
9865: LD_VAR 0 1
9869: PPUSH
9870: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_gray , lab ) ;
9874: LD_OWVAR 2
9878: PPUSH
9879: LD_EXP 21
9883: PPUSH
9884: LD_INT 1
9886: PPUSH
9887: LD_VAR 0 1
9891: PPUSH
9892: CALL_OW 468
// end ; end ;
9896: PPOPN 2
9898: END
// on ArtifactUsed ( s , icon , cr1 , cr2 ) do var coords , i , lab , side , dist , cost ;
9899: LD_INT 0
9901: PPUSH
9902: PPUSH
9903: PPUSH
9904: PPUSH
9905: PPUSH
9906: PPUSH
// begin coords := FindArtifact ( player_artifact_number ) ;
9907: LD_ADDR_VAR 0 5
9911: PUSH
9912: LD_EXP 19
9916: PPUSH
9917: CALL_OW 469
9921: ST_TO_ADDR
// lab := NearestUnitToXY ( FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_siberium ] ] ] ) , coords [ 1 ] , coords [ 2 ] ) ;
9922: LD_ADDR_VAR 0 7
9926: PUSH
9927: LD_INT 22
9929: PUSH
9930: LD_OWVAR 2
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: PUSH
9939: LD_INT 2
9941: PUSH
9942: LD_INT 30
9944: PUSH
9945: LD_INT 8
9947: PUSH
9948: EMPTY
9949: LIST
9950: LIST
9951: PUSH
9952: LD_INT 30
9954: PUSH
9955: LD_INT 11
9957: PUSH
9958: EMPTY
9959: LIST
9960: LIST
9961: PUSH
9962: EMPTY
9963: LIST
9964: LIST
9965: LIST
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PPUSH
9971: CALL_OW 69
9975: PPUSH
9976: LD_VAR 0 5
9980: PUSH
9981: LD_INT 1
9983: ARRAY
9984: PPUSH
9985: LD_VAR 0 5
9989: PUSH
9990: LD_INT 2
9992: ARRAY
9993: PPUSH
9994: CALL_OW 73
9998: ST_TO_ADDR
// if not lab then
9999: LD_VAR 0 7
10003: NOT
10004: IFFALSE 10021
// begin if debug then
10006: LD_EXP 6
10010: IFFALSE 10019
// AddToLog ( Cannot find lab! ) ;
10012: LD_STRING Cannot find lab!
10014: PPUSH
10015: CALL_OW 561
// exit ;
10019: GO 10379
// end ; if icon = player_artifact_icon_res then
10021: LD_VAR 0 2
10025: PUSH
10026: LD_EXP 25
10030: EQUAL
10031: IFFALSE 10072
// begin SetSpecResearch ( lab , player_artifact_time_res , true ) ;
10033: LD_VAR 0 7
10037: PPUSH
10038: LD_EXP 27
10042: PPUSH
10043: LD_INT 1
10045: PPUSH
10046: CALL_OW 486
// SetArtifactUse ( your_side , player_artifact_icon_res , art_no , lab ) ;
10050: LD_OWVAR 2
10054: PPUSH
10055: LD_EXP 25
10059: PPUSH
10060: LD_INT 0
10062: PPUSH
10063: LD_VAR 0 7
10067: PPUSH
10068: CALL_OW 468
// end ; if icon = player_artifact_icon then
10072: LD_VAR 0 2
10076: PUSH
10077: LD_EXP 20
10081: EQUAL
10082: IFFALSE 10121
// begin if GetType ( cr1 ) = unit_human and not IsInUnit ( cr1 ) then
10084: LD_VAR 0 3
10088: PPUSH
10089: CALL_OW 247
10093: PUSH
10094: LD_INT 1
10096: EQUAL
10097: PUSH
10098: LD_VAR 0 3
10102: PPUSH
10103: CALL_OW 310
10107: NOT
10108: AND
10109: IFFALSE 10121
// player_artifact_selected_unit := cr1 ;
10111: LD_ADDR_EXP 30
10115: PUSH
10116: LD_VAR 0 3
10120: ST_TO_ADDR
// end ; if icon = player_artifact_icon_2 then
10121: LD_VAR 0 2
10125: PUSH
10126: LD_EXP 21
10130: EQUAL
10131: IFFALSE 10369
// begin if HexInfo ( cr1 , cr2 ) <> 0 then
10133: LD_VAR 0 3
10137: PPUSH
10138: LD_VAR 0 4
10142: PPUSH
10143: CALL_OW 428
10147: PUSH
10148: LD_INT 0
10150: NONEQUAL
10151: IFFALSE 10155
// exit ;
10153: GO 10379
// dist := GetDistXY ( GetX ( player_artifact_selected_unit ) , GetY ( player_artifact_selected_unit ) , cr1 , cr2 ) ;
10155: LD_ADDR_VAR 0 9
10159: PUSH
10160: LD_EXP 30
10164: PPUSH
10165: CALL_OW 250
10169: PPUSH
10170: LD_EXP 30
10174: PPUSH
10175: CALL_OW 251
10179: PPUSH
10180: LD_VAR 0 3
10184: PPUSH
10185: LD_VAR 0 4
10189: PPUSH
10190: CALL_OW 298
10194: ST_TO_ADDR
// cost := GetUseCost ( dist ) ;
10195: LD_ADDR_VAR 0 10
10199: PUSH
10200: LD_VAR 0 9
10204: PPUSH
10205: CALL 9225 0 1
10209: ST_TO_ADDR
// if cost > GetSibResources ( your_side ) then
10210: LD_VAR 0 10
10214: PUSH
10215: LD_OWVAR 2
10219: PPUSH
10220: CALL 5403 0 1
10224: GREATER
10225: IFFALSE 10239
// begin HintSpec ( ArtFrogJumpCost , 2 ) ;
10227: LD_STRING ArtFrogJumpCost
10229: PPUSH
10230: LD_INT 2
10232: PPUSH
10233: CALL_OW 338
// exit ;
10237: GO 10379
// end ; SetSibResources ( your_side , cost ) ;
10239: LD_OWVAR 2
10243: PPUSH
10244: LD_VAR 0 10
10248: PPUSH
10249: CALL 5527 0 2
// TeleportUnit ( player_artifact_selected_unit , cr1 , cr2 , 0 , true ) ;
10253: LD_EXP 30
10257: PPUSH
10258: LD_VAR 0 3
10262: PPUSH
10263: LD_VAR 0 4
10267: PPUSH
10268: LD_INT 0
10270: PPUSH
10271: LD_INT 1
10273: PPUSH
10274: CALL_OW 483
// CenterOnXY ( cr1 , cr2 ) ;
10278: LD_VAR 0 3
10282: PPUSH
10283: LD_VAR 0 4
10287: PPUSH
10288: CALL_OW 84
// player_artifact_selected_unit := 0 ;
10292: LD_ADDR_EXP 30
10296: PUSH
10297: LD_INT 0
10299: ST_TO_ADDR
// player_artifact_researched := false ;
10300: LD_ADDR_EXP 22
10304: PUSH
10305: LD_INT 0
10307: ST_TO_ADDR
// SetArtifactUse ( your_side , player_artifact_icon , art_gray , lab ) ;
10308: LD_OWVAR 2
10312: PPUSH
10313: LD_EXP 20
10317: PPUSH
10318: LD_INT 1
10320: PPUSH
10321: LD_VAR 0 7
10325: PPUSH
10326: CALL_OW 468
// SetArtifactUse ( your_side , player_artifact_icon_2 , art_no , lab ) ;
10330: LD_OWVAR 2
10334: PPUSH
10335: LD_EXP 21
10339: PPUSH
10340: LD_INT 0
10342: PPUSH
10343: LD_VAR 0 7
10347: PPUSH
10348: CALL_OW 468
// Wait ( player_artifact_time_refresh ) ;
10352: LD_EXP 26
10356: PPUSH
10357: CALL_OW 67
// player_artifact_researched := true ;
10361: LD_ADDR_EXP 22
10365: PUSH
10366: LD_INT 1
10368: ST_TO_ADDR
// end ; if debug then
10369: LD_EXP 6
10373: IFFALSE 10379
// DebugArtifact ;
10375: CALL 8989 0 0
// end ;
10379: PPOPN 10
10381: END
// on SpecResearchComplete ( lab ) do begin if GetSide ( lab ) = your_side then
10382: LD_VAR 0 1
10386: PPUSH
10387: CALL_OW 255
10391: PUSH
10392: LD_OWVAR 2
10396: EQUAL
10397: IFFALSE 10436
// begin SetArtifactUse ( your_side , player_artifact_icon_res , art_no , lab ) ;
10399: LD_OWVAR 2
10403: PPUSH
10404: LD_EXP 25
10408: PPUSH
10409: LD_INT 0
10411: PPUSH
10412: LD_VAR 0 1
10416: PPUSH
10417: CALL_OW 468
// player_artifact_ready := true ;
10421: LD_ADDR_EXP 29
10425: PUSH
10426: LD_INT 1
10428: ST_TO_ADDR
// Hint ( ArtFrogJump ) ;
10429: LD_STRING ArtFrogJump
10431: PPUSH
10432: CALL_OW 339
// end ; end ;
10436: PPOPN 1
10438: END
// on SpecResearchCancel ( lab , progress ) do begin SetArtifactUse ( your_side , player_artifact_icon_res , art_instant , lab ) ;
10439: LD_OWVAR 2
10443: PPUSH
10444: LD_EXP 25
10448: PPUSH
10449: LD_INT 2
10451: PPUSH
10452: LD_VAR 0 1
10456: PPUSH
10457: CALL_OW 468
// end ;
10461: PPOPN 2
10463: END
// export function ActiveArtifact1 ( ) ; var i , tmp , un ; begin
10464: LD_INT 0
10466: PPUSH
10467: PPUSH
10468: PPUSH
10469: PPUSH
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_weapon , ru_siberium_rocket ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_siberite_power ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_siberite_mine ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_ext_siberium ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_btype , b_teleport ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_bweapon , ru_time_lapser ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_bweapon , ru_rocket ] ] ) ^ FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_engine , engine_siberite ] ] ) ;
10470: LD_ADDR_VAR 0 3
10474: PUSH
10475: LD_INT 81
10477: PUSH
10478: LD_INT 7
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PUSH
10485: LD_INT 34
10487: PUSH
10488: LD_INT 48
10490: PUSH
10491: EMPTY
10492: LIST
10493: LIST
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PPUSH
10499: CALL_OW 69
10503: PUSH
10504: LD_INT 81
10506: PUSH
10507: LD_INT 7
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: PUSH
10514: LD_INT 30
10516: PUSH
10517: LD_INT 28
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: PPUSH
10528: CALL_OW 69
10532: ADD
10533: PUSH
10534: LD_INT 81
10536: PUSH
10537: LD_INT 7
10539: PUSH
10540: EMPTY
10541: LIST
10542: LIST
10543: PUSH
10544: LD_INT 30
10546: PUSH
10547: LD_INT 30
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: PPUSH
10558: CALL_OW 69
10562: ADD
10563: PUSH
10564: LD_INT 81
10566: PUSH
10567: LD_INT 7
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: PUSH
10574: LD_INT 30
10576: PUSH
10577: LD_INT 21
10579: PUSH
10580: EMPTY
10581: LIST
10582: LIST
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PPUSH
10588: CALL_OW 69
10592: ADD
10593: PUSH
10594: LD_INT 81
10596: PUSH
10597: LD_INT 7
10599: PUSH
10600: EMPTY
10601: LIST
10602: LIST
10603: PUSH
10604: LD_INT 30
10606: PUSH
10607: LD_INT 34
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: PPUSH
10618: CALL_OW 69
10622: ADD
10623: PUSH
10624: LD_INT 81
10626: PUSH
10627: LD_INT 7
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PUSH
10634: LD_INT 35
10636: PUSH
10637: LD_INT 49
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PUSH
10644: EMPTY
10645: LIST
10646: LIST
10647: PPUSH
10648: CALL_OW 69
10652: ADD
10653: PUSH
10654: LD_INT 81
10656: PUSH
10657: LD_INT 7
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 35
10666: PUSH
10667: LD_INT 47
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: PPUSH
10678: CALL_OW 69
10682: ADD
10683: PUSH
10684: LD_INT 81
10686: PUSH
10687: LD_INT 7
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 32
10696: PUSH
10697: LD_INT 3
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: PPUSH
10708: CALL_OW 69
10712: ADD
10713: ST_TO_ADDR
// if not tmp then
10714: LD_VAR 0 3
10718: NOT
10719: IFFALSE 10723
// exit ;
10721: GO 10844
// if UnitFilter ( tmp , [ f_weapon , ru_siberium_rocket ] ) then
10723: LD_VAR 0 3
10727: PPUSH
10728: LD_INT 34
10730: PUSH
10731: LD_INT 48
10733: PUSH
10734: EMPTY
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: IFFALSE 10775
// un := UnitFilter ( tmp , [ f_weapon , ru_siberium_rocket ] ) [ 1 ] else
10744: LD_ADDR_VAR 0 4
10748: PUSH
10749: LD_VAR 0 3
10753: PPUSH
10754: LD_INT 34
10756: PUSH
10757: LD_INT 48
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: PPUSH
10764: CALL_OW 72
10768: PUSH
10769: LD_INT 1
10771: ARRAY
10772: ST_TO_ADDR
10773: GO 10799
// un := tmp [ rand ( 1 , tmp ) ] ;
10775: LD_ADDR_VAR 0 4
10779: PUSH
10780: LD_VAR 0 3
10784: PUSH
10785: LD_INT 1
10787: PPUSH
10788: LD_VAR 0 3
10792: PPUSH
10793: CALL_OW 12
10797: ARRAY
10798: ST_TO_ADDR
// if not alliance_used_artifact_1 then
10799: LD_EXP 10
10803: NOT
10804: IFFALSE 10835
// alliance_used_artifact_1 := [ GetX ( un ) , GetY ( un ) ] ;
10806: LD_ADDR_EXP 10
10810: PUSH
10811: LD_VAR 0 4
10815: PPUSH
10816: CALL_OW 250
10820: PUSH
10821: LD_VAR 0 4
10825: PPUSH
10826: CALL_OW 251
10830: PUSH
10831: EMPTY
10832: LIST
10833: LIST
10834: ST_TO_ADDR
// KillUnit ( un ) ;
10835: LD_VAR 0 4
10839: PPUSH
10840: CALL_OW 66
// end ;
10844: LD_VAR 0 1
10848: RET
// export function ActiveArtifact2 ( ) ; var i , un , tmp ; begin
10849: LD_INT 0
10851: PPUSH
10852: PPUSH
10853: PPUSH
10854: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , 6 ] , [ f_control , control_computer ] ] ) ;
10855: LD_ADDR_VAR 0 4
10859: PUSH
10860: LD_INT 22
10862: PUSH
10863: LD_INT 6
10865: PUSH
10866: EMPTY
10867: LIST
10868: LIST
10869: PUSH
10870: LD_INT 33
10872: PUSH
10873: LD_INT 3
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: PPUSH
10884: CALL_OW 69
10888: ST_TO_ADDR
// if not tmp then
10889: LD_VAR 0 4
10893: NOT
10894: IFFALSE 10898
// exit ;
10896: GO 11024
// un := tmp [ rand ( 1 , tmp ) ] ;
10898: LD_ADDR_VAR 0 3
10902: PUSH
10903: LD_VAR 0 4
10907: PUSH
10908: LD_INT 1
10910: PPUSH
10911: LD_VAR 0 4
10915: PPUSH
10916: CALL_OW 12
10920: ARRAY
10921: ST_TO_ADDR
// if GetWeapon ( un ) = ru_siberium_rocket then
10922: LD_VAR 0 3
10926: PPUSH
10927: CALL_OW 264
10931: PUSH
10932: LD_INT 48
10934: EQUAL
10935: IFFALSE 10954
// ComAttackPlace ( un , 194 , 19 ) else
10937: LD_VAR 0 3
10941: PPUSH
10942: LD_INT 194
10944: PPUSH
10945: LD_INT 19
10947: PPUSH
10948: CALL_OW 116
10952: GO 10988
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , un ) ) ;
10954: LD_VAR 0 3
10958: PPUSH
10959: LD_INT 81
10961: PUSH
10962: LD_INT 7
10964: PUSH
10965: EMPTY
10966: LIST
10967: LIST
10968: PPUSH
10969: CALL_OW 69
10973: PPUSH
10974: LD_VAR 0 3
10978: PPUSH
10979: CALL_OW 74
10983: PPUSH
10984: CALL_OW 115
// if not alliance_used_artifact_2 then
10988: LD_EXP 11
10992: NOT
10993: IFFALSE 11024
// alliance_used_artifact_2 := [ GetX ( un ) , GetY ( un ) ] ;
10995: LD_ADDR_EXP 11
10999: PUSH
11000: LD_VAR 0 3
11004: PPUSH
11005: CALL_OW 250
11009: PUSH
11010: LD_VAR 0 3
11014: PPUSH
11015: CALL_OW 251
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: ST_TO_ADDR
// end ; end_of_file
11024: LD_VAR 0 1
11028: RET
// export function DebugMode ; var i , j , b ; begin
11029: LD_INT 0
11031: PPUSH
11032: PPUSH
11033: PPUSH
11034: PPUSH
// enable_addtolog = true ;
11035: LD_ADDR_OWVAR 81
11039: PUSH
11040: LD_INT 1
11042: ST_TO_ADDR
// FogOff ( 6 ) ;
11043: LD_INT 6
11045: PPUSH
11046: CALL_OW 344
// uc_side = 6 ;
11050: LD_ADDR_OWVAR 20
11054: PUSH
11055: LD_INT 6
11057: ST_TO_ADDR
// uc_nation = 3 ;
11058: LD_ADDR_OWVAR 21
11062: PUSH
11063: LD_INT 3
11065: ST_TO_ADDR
// bc_level = 10 ;
11066: LD_ADDR_OWVAR 43
11070: PUSH
11071: LD_INT 10
11073: ST_TO_ADDR
// bc_type := b_lab_full ;
11074: LD_ADDR_OWVAR 42
11078: PUSH
11079: LD_INT 8
11081: ST_TO_ADDR
// bc_kind1 := 11 ;
11082: LD_ADDR_OWVAR 44
11086: PUSH
11087: LD_INT 11
11089: ST_TO_ADDR
// bc_kind2 := 12 ;
11090: LD_ADDR_OWVAR 45
11094: PUSH
11095: LD_INT 12
11097: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 189 , 20 , 1 ) ;
11098: LD_INT 189
11100: PPUSH
11101: LD_INT 20
11103: PPUSH
11104: LD_INT 1
11106: PPUSH
11107: CALL_OW 47
// bc_type := b_warehouse ;
11111: LD_ADDR_OWVAR 42
11115: PUSH
11116: LD_INT 1
11118: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 201 , 22 , 4 ) ;
11119: LD_ADDR_VAR 0 4
11123: PUSH
11124: LD_INT 201
11126: PPUSH
11127: LD_INT 22
11129: PPUSH
11130: LD_INT 4
11132: PPUSH
11133: CALL_OW 47
11137: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , 10000 ) ;
11138: LD_VAR 0 4
11142: PPUSH
11143: CALL_OW 274
11147: PPUSH
11148: LD_INT 1
11150: PPUSH
11151: LD_INT 10000
11153: PPUSH
11154: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , 10000 ) ;
11158: LD_VAR 0 4
11162: PPUSH
11163: CALL_OW 274
11167: PPUSH
11168: LD_INT 2
11170: PPUSH
11171: LD_INT 10000
11173: PPUSH
11174: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , 10000 ) ;
11178: LD_VAR 0 4
11182: PPUSH
11183: CALL_OW 274
11187: PPUSH
11188: LD_INT 3
11190: PPUSH
11191: LD_INT 10000
11193: PPUSH
11194: CALL_OW 277
// bc_type := b_siberite_power ;
11198: LD_ADDR_OWVAR 42
11202: PUSH
11203: LD_INT 28
11205: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 216 , 16 , 4 ) ;
11206: LD_ADDR_VAR 0 4
11210: PUSH
11211: LD_INT 216
11213: PPUSH
11214: LD_INT 16
11216: PPUSH
11217: LD_INT 4
11219: PPUSH
11220: CALL_OW 47
11224: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 219 , 16 , 4 ) ;
11225: LD_ADDR_VAR 0 4
11229: PUSH
11230: LD_INT 219
11232: PPUSH
11233: LD_INT 16
11235: PPUSH
11236: LD_INT 4
11238: PPUSH
11239: CALL_OW 47
11243: ST_TO_ADDR
// SetTech ( tech_sib2 , 6 , state_researched ) ;
11244: LD_INT 55
11246: PPUSH
11247: LD_INT 6
11249: PPUSH
11250: LD_INT 2
11252: PPUSH
11253: CALL_OW 322
// SetTech ( tech_sib3 , 6 , state_researched ) ;
11257: LD_INT 56
11259: PPUSH
11260: LD_INT 6
11262: PPUSH
11263: LD_INT 2
11265: PPUSH
11266: CALL_OW 322
// end ;
11270: LD_VAR 0 1
11274: RET
