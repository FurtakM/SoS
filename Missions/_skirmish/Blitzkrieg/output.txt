// starting begin InitMap ;
   0: CALL 1277 0 0
// InitTriggers ;
   4: CALL 1543 0 0
// InitUs ;
   8: CALL 1792 0 0
// InitRussian ;
  12: CALL 2121 0 0
// StartGame ;
  16: CALL 10755 0 0
// end ; end_of_file
  20: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
  21: LD_INT 0
  23: PPUSH
  24: PPUSH
  25: PPUSH
  26: PPUSH
  27: PPUSH
// uc_nation = nation_nature ;
  28: LD_ADDR_OWVAR 21
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// uc_side = 0 ;
  36: LD_ADDR_OWVAR 20
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// l = 0 ;
  44: LD_ADDR_VAR 0 6
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
  52: LD_ADDR_OWVAR 24
  56: PUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: CALL_OW 12
  67: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
  68: LD_ADDR_OWVAR 35
  72: PUSH
  73: LD_INT 5
  75: NEG
  76: PPUSH
  77: LD_INT 5
  79: PPUSH
  80: CALL_OW 12
  84: ST_TO_ADDR
// hc_gallery =  ;
  85: LD_ADDR_OWVAR 33
  89: PUSH
  90: LD_STRING 
  92: ST_TO_ADDR
// hc_class = class_apeman ;
  93: LD_ADDR_OWVAR 28
  97: PUSH
  98: LD_INT 12
 100: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
 101: LD_ADDR_OWVAR 29
 105: PUSH
 106: LD_INT 11
 108: PPUSH
 109: LD_INT 13
 111: PPUSH
 112: CALL_OW 12
 116: PUSH
 117: LD_INT 10
 119: PPUSH
 120: LD_INT 11
 122: PPUSH
 123: CALL_OW 12
 127: PUSH
 128: EMPTY
 129: LIST
 130: LIST
 131: ST_TO_ADDR
// hc_sex = sex_male ;
 132: LD_ADDR_OWVAR 27
 136: PUSH
 137: LD_INT 1
 139: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
 140: LD_ADDR_OWVAR 31
 144: PUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 2
 150: PPUSH
 151: CALL_OW 12
 155: PUSH
 156: LD_INT 0
 158: PUSH
 159: LD_INT 0
 161: PUSH
 162: LD_INT 0
 164: PUSH
 165: EMPTY
 166: LIST
 167: LIST
 168: LIST
 169: LIST
 170: ST_TO_ADDR
// apeman = CreateHuman ;
 171: LD_ADDR_VAR 0 7
 175: PUSH
 176: CALL_OW 44
 180: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
 181: LD_VAR 0 7
 185: PPUSH
 186: LD_VAR 0 4
 190: PPUSH
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 49
// l = l + 1 ;
 198: LD_ADDR_VAR 0 6
 202: PUSH
 203: LD_VAR 0 6
 207: PUSH
 208: LD_INT 1
 210: PLUS
 211: ST_TO_ADDR
// end until l = num1 ;
 212: LD_VAR 0 6
 216: PUSH
 217: LD_VAR 0 1
 221: EQUAL
 222: IFFALSE 52
// l = 0 ;
 224: LD_ADDR_VAR 0 6
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
 232: LD_ADDR_OWVAR 35
 236: PUSH
 237: LD_INT 0
 239: PPUSH
 240: LD_INT 25
 242: PPUSH
 243: CALL_OW 12
 247: ST_TO_ADDR
// hc_class = class_tiger ;
 248: LD_ADDR_OWVAR 28
 252: PUSH
 253: LD_INT 14
 255: ST_TO_ADDR
// hc_sex = sex_male ;
 256: LD_ADDR_OWVAR 27
 260: PUSH
 261: LD_INT 1
 263: ST_TO_ADDR
// hc_gallery = sandnature ;
 264: LD_ADDR_OWVAR 33
 268: PUSH
 269: LD_STRING sandnature
 271: ST_TO_ADDR
// hc_face_number = 3 ;
 272: LD_ADDR_OWVAR 34
 276: PUSH
 277: LD_INT 3
 279: ST_TO_ADDR
// tiger = CreateHuman ;
 280: LD_ADDR_VAR 0 8
 284: PUSH
 285: CALL_OW 44
 289: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
 290: LD_VAR 0 8
 294: PPUSH
 295: LD_VAR 0 4
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL_OW 49
// l = l + 1 ;
 307: LD_ADDR_VAR 0 6
 311: PUSH
 312: LD_VAR 0 6
 316: PUSH
 317: LD_INT 1
 319: PLUS
 320: ST_TO_ADDR
// end until l = num2 ;
 321: LD_VAR 0 6
 325: PUSH
 326: LD_VAR 0 2
 330: EQUAL
 331: IFFALSE 232
// l = 0 ;
 333: LD_ADDR_VAR 0 6
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
 341: LD_ADDR_OWVAR 28
 345: PUSH
 346: LD_INT 18
 348: ST_TO_ADDR
// hc_gallery = sandnature ;
 349: LD_ADDR_OWVAR 33
 353: PUSH
 354: LD_STRING sandnature
 356: ST_TO_ADDR
// hc_face_number = 1 ;
 357: LD_ADDR_OWVAR 34
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// bird = CreateHuman ;
 365: LD_ADDR_VAR 0 9
 369: PUSH
 370: CALL_OW 44
 374: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
 375: LD_VAR 0 9
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: CALL_OW 51
// l = l + 1 ;
 387: LD_ADDR_VAR 0 6
 391: PUSH
 392: LD_VAR 0 6
 396: PUSH
 397: LD_INT 1
 399: PLUS
 400: ST_TO_ADDR
// end until l = num3 ;
 401: LD_VAR 0 6
 405: PUSH
 406: LD_VAR 0 3
 410: EQUAL
 411: IFFALSE 341
// end ;
 413: LD_VAR 0 5
 417: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
 418: LD_INT 0
 420: PPUSH
 421: PPUSH
 422: PPUSH
 423: PPUSH
 424: PPUSH
 425: PPUSH
// hc_class := clas ;
 426: LD_ADDR_OWVAR 28
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
 436: LD_ADDR_VAR 0 4
 440: PUSH
 441: LD_VAR 0 2
 445: PUSH
 446: LD_INT 1
 448: NEG
 449: PPUSH
 450: LD_INT 1
 452: PPUSH
 453: CALL_OW 12
 457: PLUS
 458: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
 459: LD_ADDR_VAR 0 5
 463: PUSH
 464: LD_VAR 0 2
 468: PUSH
 469: LD_INT 1
 471: NEG
 472: PPUSH
 473: LD_INT 1
 475: PPUSH
 476: CALL_OW 12
 480: PLUS
 481: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 482: LD_ADDR_VAR 0 6
 486: PUSH
 487: LD_VAR 0 2
 491: PUSH
 492: LD_INT 1
 494: NEG
 495: PPUSH
 496: LD_INT 1
 498: PPUSH
 499: CALL_OW 12
 503: PLUS
 504: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 505: LD_ADDR_VAR 0 7
 509: PUSH
 510: LD_VAR 0 2
 514: PUSH
 515: LD_INT 1
 517: NEG
 518: PPUSH
 519: LD_INT 1
 521: PPUSH
 522: CALL_OW 12
 526: PLUS
 527: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_mortar then
 528: LD_VAR 0 1
 532: PUSH
 533: LD_INT 1
 535: EQUAL
 536: PUSH
 537: LD_VAR 0 1
 541: PUSH
 542: LD_INT 9
 544: EQUAL
 545: OR
 546: PUSH
 547: LD_VAR 0 1
 551: PUSH
 552: LD_INT 8
 554: EQUAL
 555: OR
 556: IFFALSE 581
// bonus := [ 2 , 0 , 0 , 0 ] ;
 558: LD_ADDR_VAR 0 8
 562: PUSH
 563: LD_INT 2
 565: PUSH
 566: LD_INT 0
 568: PUSH
 569: LD_INT 0
 571: PUSH
 572: LD_INT 0
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: ST_TO_ADDR
// if clas = 2 then
 581: LD_VAR 0 1
 585: PUSH
 586: LD_INT 2
 588: EQUAL
 589: IFFALSE 614
// bonus := [ 0 , 2 , 0 , 0 ] ;
 591: LD_ADDR_VAR 0 8
 595: PUSH
 596: LD_INT 0
 598: PUSH
 599: LD_INT 2
 601: PUSH
 602: LD_INT 0
 604: PUSH
 605: LD_INT 0
 607: PUSH
 608: EMPTY
 609: LIST
 610: LIST
 611: LIST
 612: LIST
 613: ST_TO_ADDR
// if clas = 3 then
 614: LD_VAR 0 1
 618: PUSH
 619: LD_INT 3
 621: EQUAL
 622: IFFALSE 647
// bonus := [ 0 , 0 , 2 , 0 ] ;
 624: LD_ADDR_VAR 0 8
 628: PUSH
 629: LD_INT 0
 631: PUSH
 632: LD_INT 0
 634: PUSH
 635: LD_INT 2
 637: PUSH
 638: LD_INT 0
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: ST_TO_ADDR
// if clas = 4 then
 647: LD_VAR 0 1
 651: PUSH
 652: LD_INT 4
 654: EQUAL
 655: IFFALSE 680
// bonus := [ 0 , 0 , 0 , 2 ] ;
 657: LD_ADDR_VAR 0 8
 661: PUSH
 662: LD_INT 0
 664: PUSH
 665: LD_INT 0
 667: PUSH
 668: LD_INT 0
 670: PUSH
 671: LD_INT 2
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: ST_TO_ADDR
// if clas > 4 and not clas = 9 and not clas = class_mortar then
 680: LD_VAR 0 1
 684: PUSH
 685: LD_INT 4
 687: GREATER
 688: PUSH
 689: LD_VAR 0 1
 693: PUSH
 694: LD_INT 9
 696: EQUAL
 697: NOT
 698: AND
 699: PUSH
 700: LD_VAR 0 1
 704: PUSH
 705: LD_INT 8
 707: EQUAL
 708: NOT
 709: AND
 710: IFFALSE 735
// bonus := [ 0 , 0 , 0 , 0 ] ;
 712: LD_ADDR_VAR 0 8
 716: PUSH
 717: LD_INT 0
 719: PUSH
 720: LD_INT 0
 722: PUSH
 723: LD_INT 0
 725: PUSH
 726: LD_INT 0
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
 735: LD_ADDR_OWVAR 31
 739: PUSH
 740: LD_VAR 0 4
 744: PUSH
 745: LD_VAR 0 8
 749: PUSH
 750: LD_INT 1
 752: ARRAY
 753: PLUS
 754: PUSH
 755: LD_VAR 0 5
 759: PUSH
 760: LD_VAR 0 8
 764: PUSH
 765: LD_INT 2
 767: ARRAY
 768: PLUS
 769: PUSH
 770: LD_VAR 0 6
 774: PUSH
 775: LD_VAR 0 8
 779: PUSH
 780: LD_INT 3
 782: ARRAY
 783: PLUS
 784: PUSH
 785: LD_VAR 0 7
 789: PUSH
 790: LD_VAR 0 8
 794: PUSH
 795: LD_INT 4
 797: ARRAY
 798: PLUS
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
 806: LD_ADDR_OWVAR 27
 810: PUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 2
 816: PPUSH
 817: CALL_OW 12
 821: ST_TO_ADDR
// hc_gallery :=  ;
 822: LD_ADDR_OWVAR 33
 826: PUSH
 827: LD_STRING 
 829: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
 830: LD_ADDR_OWVAR 29
 834: PUSH
 835: LD_INT 8
 837: PPUSH
 838: LD_INT 12
 840: PPUSH
 841: CALL_OW 12
 845: PUSH
 846: LD_INT 9
 848: PPUSH
 849: LD_INT 11
 851: PPUSH
 852: CALL_OW 12
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: ST_TO_ADDR
// hc_name :=  ;
 861: LD_ADDR_OWVAR 26
 865: PUSH
 866: LD_STRING 
 868: ST_TO_ADDR
// result := CreateHuman ;
 869: LD_ADDR_VAR 0 3
 873: PUSH
 874: CALL_OW 44
 878: ST_TO_ADDR
// end ;
 879: LD_VAR 0 3
 883: RET
// export function Save ; var i , tmp , sveh ; begin
 884: LD_INT 0
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff [ heike , olaf , kurt ] ;
 890: LD_ADDR_VAR 0 3
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 21
 907: PUSH
 908: LD_INT 1
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PPUSH
 919: CALL_OW 69
 923: PUSH
 924: LD_EXP 14
 928: PUSH
 929: LD_EXP 17
 933: PUSH
 934: LD_EXP 16
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: LIST
 943: DIFF
 944: ST_TO_ADDR
// for i = 1 to tmp do
 945: LD_ADDR_VAR 0 2
 949: PUSH
 950: DOUBLE
 951: LD_INT 1
 953: DEC
 954: ST_TO_ADDR
 955: LD_VAR 0 3
 959: PUSH
 960: FOR_TO
 961: IFFALSE 983
// SaveCharacters ( tmp , Blitz_ & i ) ;
 963: LD_VAR 0 3
 967: PPUSH
 968: LD_STRING Blitz_
 970: PUSH
 971: LD_VAR 0 2
 975: STR
 976: PPUSH
 977: CALL_OW 38
 981: GO 960
 983: POP
 984: POP
// SaveVariable ( tmp , Blitz_Count ) ;
 985: LD_VAR 0 3
 989: PPUSH
 990: LD_STRING Blitz_Count
 992: PPUSH
 993: CALL_OW 39
// SaveCharacters ( heike , Blitz_Heike ) ;
 997: LD_EXP 14
1001: PPUSH
1002: LD_STRING Blitz_Heike
1004: PPUSH
1005: CALL_OW 38
// if IsLive ( olaf ) then
1009: LD_EXP 17
1013: PPUSH
1014: CALL_OW 300
1018: IFFALSE 1032
// SaveCharacters ( olaf , Blitz_Olaf ) ;
1020: LD_EXP 17
1024: PPUSH
1025: LD_STRING Blitz_Olaf
1027: PPUSH
1028: CALL_OW 38
// if IsLive ( kurt ) then
1032: LD_EXP 16
1036: PPUSH
1037: CALL_OW 300
1041: IFFALSE 1055
// SaveCharacters ( kurt , Blitz_Kurt ) ;
1043: LD_EXP 16
1047: PPUSH
1048: LD_STRING Blitz_Kurt
1050: PPUSH
1051: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
1055: LD_ADDR_VAR 0 3
1059: PUSH
1060: LD_INT 22
1062: PUSH
1063: LD_INT 2
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: PUSH
1070: LD_INT 21
1072: PUSH
1073: LD_INT 2
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: PPUSH
1084: CALL_OW 69
1088: ST_TO_ADDR
// sveh := [ ] ;
1089: LD_ADDR_VAR 0 4
1093: PUSH
1094: EMPTY
1095: ST_TO_ADDR
// for i = 1 to tmp do
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: DOUBLE
1102: LD_INT 1
1104: DEC
1105: ST_TO_ADDR
1106: LD_VAR 0 3
1110: PUSH
1111: FOR_TO
1112: IFFALSE 1234
// begin sveh := sveh ^ [ [ GetNation ( tmp [ i ] ) , GetChassis ( tmp [ i ] ) , GetEngine ( tmp [ i ] ) , GetControl ( tmp [ i ] ) , GetWeapon ( tmp [ i ] ) , GetFuel ( tmp [ i ] ) ] ] ;
1114: LD_ADDR_VAR 0 4
1118: PUSH
1119: LD_VAR 0 4
1123: PUSH
1124: LD_VAR 0 3
1128: PUSH
1129: LD_VAR 0 2
1133: ARRAY
1134: PPUSH
1135: CALL_OW 248
1139: PUSH
1140: LD_VAR 0 3
1144: PUSH
1145: LD_VAR 0 2
1149: ARRAY
1150: PPUSH
1151: CALL_OW 265
1155: PUSH
1156: LD_VAR 0 3
1160: PUSH
1161: LD_VAR 0 2
1165: ARRAY
1166: PPUSH
1167: CALL_OW 262
1171: PUSH
1172: LD_VAR 0 3
1176: PUSH
1177: LD_VAR 0 2
1181: ARRAY
1182: PPUSH
1183: CALL_OW 263
1187: PUSH
1188: LD_VAR 0 3
1192: PUSH
1193: LD_VAR 0 2
1197: ARRAY
1198: PPUSH
1199: CALL_OW 264
1203: PUSH
1204: LD_VAR 0 3
1208: PUSH
1209: LD_VAR 0 2
1213: ARRAY
1214: PPUSH
1215: CALL_OW 261
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: PUSH
1228: EMPTY
1229: LIST
1230: ADD
1231: ST_TO_ADDR
// end ;
1232: GO 1111
1234: POP
1235: POP
// SaveVariable ( sveh , Blitz_Vehicle ) ;
1236: LD_VAR 0 4
1240: PPUSH
1241: LD_STRING Blitz_Vehicle
1243: PPUSH
1244: CALL_OW 39
// SaveVariable ( global_diff , Blitz_Difficulty ) ;
1248: LD_EXP 2
1252: PPUSH
1253: LD_STRING Blitz_Difficulty
1255: PPUSH
1256: CALL_OW 39
// SaveVariable ( points , Blitz_Points ) ;
1260: LD_EXP 25
1264: PPUSH
1265: LD_STRING Blitz_Points
1267: PPUSH
1268: CALL_OW 39
// end ; end_of_file
1272: LD_VAR 0 1
1276: RET
// export function InitMap ; begin
1277: LD_INT 0
1279: PPUSH
// ResetFog ;
1280: CALL_OW 335
// RandomizeAll ;
1284: CALL_OW 11
// end ;
1288: LD_VAR 0 1
1292: RET
// export function SpawnCrates ; var i ; begin
1293: LD_INT 0
1295: PPUSH
1296: PPUSH
// while ( crates_allow ) do
1297: LD_EXP 12
1301: IFFALSE 1454
// begin Wait ( crates_time + Rand ( - 0 0$10 , 0 0$20 ) ) ;
1303: LD_EXP 10
1307: PUSH
1308: LD_INT 350
1310: NEG
1311: PPUSH
1312: LD_INT 700
1314: PPUSH
1315: CALL_OW 12
1319: PLUS
1320: PPUSH
1321: CALL_OW 67
// for i = 1 to crates_num do
1325: LD_ADDR_VAR 0 2
1329: PUSH
1330: DOUBLE
1331: LD_INT 1
1333: DEC
1334: ST_TO_ADDR
1335: LD_EXP 11
1339: PUSH
1340: FOR_TO
1341: IFFALSE 1450
// begin CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1343: LD_INT 1
1345: PPUSH
1346: LD_INT 5
1348: PPUSH
1349: CALL_OW 12
1353: PPUSH
1354: LD_INT 7
1356: PPUSH
1357: LD_INT 1
1359: PPUSH
1360: CALL_OW 55
// Wait ( Rand ( 0 0$03 , 0 0$12 ) ) ;
1364: LD_INT 105
1366: PPUSH
1367: LD_INT 420
1369: PPUSH
1370: CALL_OW 12
1374: PPUSH
1375: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_main_area , true ) ;
1379: LD_INT 1
1381: PPUSH
1382: LD_INT 5
1384: PPUSH
1385: CALL_OW 12
1389: PPUSH
1390: LD_INT 7
1392: PPUSH
1393: LD_INT 1
1395: PPUSH
1396: CALL_OW 55
// Wait ( Rand ( 0 0$04 , 0 0$15 ) ) ;
1400: LD_INT 140
1402: PPUSH
1403: LD_INT 525
1405: PPUSH
1406: CALL_OW 12
1410: PPUSH
1411: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
1415: LD_INT 1
1417: PPUSH
1418: LD_INT 5
1420: PPUSH
1421: CALL_OW 12
1425: PPUSH
1426: LD_INT 1
1428: PPUSH
1429: CALL_OW 57
// Wait ( Rand ( 0 0$05 , 0 0$10 ) ) ;
1433: LD_INT 175
1435: PPUSH
1436: LD_INT 350
1438: PPUSH
1439: CALL_OW 12
1443: PPUSH
1444: CALL_OW 67
// end ;
1448: GO 1340
1450: POP
1451: POP
// end ;
1452: GO 1297
// end ;
1454: LD_VAR 0 1
1458: RET
// every 1 do
1459: GO 1461
1461: DISABLE
// SpawnCrates ( ) ;
1462: CALL 1293 0 0
1466: END
// export timer ; every 1 do
1467: GO 1469
1469: DISABLE
// timer := 0 0$00 ;
1470: LD_ADDR_EXP 1
1474: PUSH
1475: LD_INT 0
1477: ST_TO_ADDR
1478: END
// every 0 0$01 trigger game_started do
1479: LD_EXP 9
1483: IFFALSE 1530
1485: GO 1487
1487: DISABLE
// begin enable ;
1488: ENABLE
// timer := timer + 0 0$01 ;
1489: LD_ADDR_EXP 1
1493: PUSH
1494: LD_EXP 1
1498: PUSH
1499: LD_INT 35
1501: PLUS
1502: ST_TO_ADDR
// Display_Strings := [ #tick , timer , #points , points ] ;
1503: LD_ADDR_OWVAR 47
1507: PUSH
1508: LD_STRING #tick
1510: PUSH
1511: LD_EXP 1
1515: PUSH
1516: LD_STRING #points
1518: PUSH
1519: LD_EXP 25
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: ST_TO_ADDR
// end ;
1530: END
// every 0 0$01 do
1531: GO 1533
1533: DISABLE
// music_nat := 2 ; end_of_file
1534: LD_ADDR_OWVAR 71
1538: PUSH
1539: LD_INT 2
1541: ST_TO_ADDR
1542: END
// export global_diff , ru_force , ru_def , am_def , am_force , ar_def , ar_force ; export game_started ; export crates_time , crates_num , crates_allow ; export kurin , heike , omar , kurt , olaf ; export russian_produce , beria_action ; export omar_attack , heike_go , rus_escape , attack_omicron , st_omar ; export points ; export function InitTriggers ; begin
1543: LD_INT 0
1545: PPUSH
// game_started := false ;
1546: LD_ADDR_EXP 9
1550: PUSH
1551: LD_INT 0
1553: ST_TO_ADDR
// points := 0 ;
1554: LD_ADDR_EXP 25
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// global_diff := [ 1 , 2 , 3 ] ;
1562: LD_ADDR_EXP 2
1566: PUSH
1567: LD_INT 1
1569: PUSH
1570: LD_INT 2
1572: PUSH
1573: LD_INT 3
1575: PUSH
1576: EMPTY
1577: LIST
1578: LIST
1579: LIST
1580: ST_TO_ADDR
// crates_time := [ 0 0$55 , 1 1$15 , 1 1$35 ] [ global_diff ] ;
1581: LD_ADDR_EXP 10
1585: PUSH
1586: LD_INT 1925
1588: PUSH
1589: LD_INT 2625
1591: PUSH
1592: LD_INT 3325
1594: PUSH
1595: EMPTY
1596: LIST
1597: LIST
1598: LIST
1599: PUSH
1600: LD_EXP 2
1604: ARRAY
1605: ST_TO_ADDR
// crates_num := [ 3 , 2 , 1 ] [ global_diff ] ;
1606: LD_ADDR_EXP 11
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: LD_INT 2
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: LIST
1624: PUSH
1625: LD_EXP 2
1629: ARRAY
1630: ST_TO_ADDR
// crates_allow := false ;
1631: LD_ADDR_EXP 12
1635: PUSH
1636: LD_INT 0
1638: ST_TO_ADDR
// am_def := [ 4 , 3 , 2 ] [ global_diff ] ;
1639: LD_ADDR_EXP 5
1643: PUSH
1644: LD_INT 4
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 2
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: LIST
1657: PUSH
1658: LD_EXP 2
1662: ARRAY
1663: ST_TO_ADDR
// ru_def := [ 2 , 3 , 4 ] [ global_diff ] ;
1664: LD_ADDR_EXP 4
1668: PUSH
1669: LD_INT 2
1671: PUSH
1672: LD_INT 3
1674: PUSH
1675: LD_INT 4
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: LIST
1682: PUSH
1683: LD_EXP 2
1687: ARRAY
1688: ST_TO_ADDR
// ru_force := [ 11 , 13 , 15 ] [ global_diff ] ;
1689: LD_ADDR_EXP 3
1693: PUSH
1694: LD_INT 11
1696: PUSH
1697: LD_INT 13
1699: PUSH
1700: LD_INT 15
1702: PUSH
1703: EMPTY
1704: LIST
1705: LIST
1706: LIST
1707: PUSH
1708: LD_EXP 2
1712: ARRAY
1713: ST_TO_ADDR
// ar_def := [ 5 , 4 , 3 ] [ global_diff ] ;
1714: LD_ADDR_EXP 7
1718: PUSH
1719: LD_INT 5
1721: PUSH
1722: LD_INT 4
1724: PUSH
1725: LD_INT 3
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: LIST
1732: PUSH
1733: LD_EXP 2
1737: ARRAY
1738: ST_TO_ADDR
// russian_produce := false ;
1739: LD_ADDR_EXP 18
1743: PUSH
1744: LD_INT 0
1746: ST_TO_ADDR
// omar_attack := false ;
1747: LD_ADDR_EXP 20
1751: PUSH
1752: LD_INT 0
1754: ST_TO_ADDR
// heike_go := false ;
1755: LD_ADDR_EXP 21
1759: PUSH
1760: LD_INT 0
1762: ST_TO_ADDR
// rus_escape := false ;
1763: LD_ADDR_EXP 22
1767: PUSH
1768: LD_INT 0
1770: ST_TO_ADDR
// attack_omicron := false ;
1771: LD_ADDR_EXP 23
1775: PUSH
1776: LD_INT 0
1778: ST_TO_ADDR
// st_omar := false ;
1779: LD_ADDR_EXP 24
1783: PUSH
1784: LD_INT 0
1786: ST_TO_ADDR
// end ; end_of_file
1787: LD_VAR 0 1
1791: RET
// export function InitUs ; var i , p , un , am , filter ; begin
1792: LD_INT 0
1794: PPUSH
1795: PPUSH
1796: PPUSH
1797: PPUSH
1798: PPUSH
1799: PPUSH
// uc_nation := nation_american ;
1800: LD_ADDR_OWVAR 21
1804: PUSH
1805: LD_INT 1
1807: ST_TO_ADDR
// am := 1 ;
1808: LD_ADDR_VAR 0 5
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// filter := [ ] ;
1816: LD_ADDR_VAR 0 6
1820: PUSH
1821: EMPTY
1822: ST_TO_ADDR
// SetBName ( omikron , omikron ) ;
1823: LD_INT 64
1825: PPUSH
1826: LD_STRING omikron
1828: PPUSH
1829: CALL_OW 500
// uc_side := am ;
1833: LD_ADDR_OWVAR 20
1837: PUSH
1838: LD_VAR 0 5
1842: ST_TO_ADDR
// for i = 1 to 4 do
1843: LD_ADDR_VAR 0 2
1847: PUSH
1848: DOUBLE
1849: LD_INT 1
1851: DEC
1852: ST_TO_ADDR
1853: LD_INT 4
1855: PUSH
1856: FOR_TO
1857: IFFALSE 1889
// begin un := CreateHumanWithClass ( 1 , 4 ) ;
1859: LD_ADDR_VAR 0 4
1863: PUSH
1864: LD_INT 1
1866: PPUSH
1867: LD_INT 4
1869: PPUSH
1870: CALL 418 0 2
1874: ST_TO_ADDR
// PlaceHumanInUnit ( un , am_arm1 ) ;
1875: LD_VAR 0 4
1879: PPUSH
1880: LD_INT 176
1882: PPUSH
1883: CALL_OW 52
// end ;
1887: GO 1856
1889: POP
1890: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_empty ] ] ) do
1891: LD_ADDR_VAR 0 2
1895: PUSH
1896: LD_INT 22
1898: PUSH
1899: LD_INT 1
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: PUSH
1906: LD_INT 2
1908: PUSH
1909: LD_INT 30
1911: PUSH
1912: LD_INT 31
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: PUSH
1919: LD_INT 30
1921: PUSH
1922: LD_INT 32
1924: PUSH
1925: EMPTY
1926: LIST
1927: LIST
1928: PUSH
1929: EMPTY
1930: LIST
1931: LIST
1932: LIST
1933: PUSH
1934: LD_INT 58
1936: PUSH
1937: EMPTY
1938: LIST
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: PPUSH
1945: CALL_OW 69
1949: PUSH
1950: FOR_IN
1951: IFFALSE 1985
// begin un := CreateHumanWithClass ( 1 , 4 ) ;
1953: LD_ADDR_VAR 0 4
1957: PUSH
1958: LD_INT 1
1960: PPUSH
1961: LD_INT 4
1963: PPUSH
1964: CALL 418 0 2
1968: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
1969: LD_VAR 0 4
1973: PPUSH
1974: LD_VAR 0 2
1978: PPUSH
1979: CALL_OW 52
// end ;
1983: GO 1950
1985: POP
1986: POP
// for i = 1 to 2 do
1987: LD_ADDR_VAR 0 2
1991: PUSH
1992: DOUBLE
1993: LD_INT 1
1995: DEC
1996: ST_TO_ADDR
1997: LD_INT 2
1999: PUSH
2000: FOR_TO
2001: IFFALSE 2036
// begin un := CreateHumanWithClass ( 2 , 4 ) ;
2003: LD_ADDR_VAR 0 4
2007: PUSH
2008: LD_INT 2
2010: PPUSH
2011: LD_INT 4
2013: PPUSH
2014: CALL 418 0 2
2018: ST_TO_ADDR
// PlaceUnitArea ( un , am_area , false ) ;
2019: LD_VAR 0 4
2023: PPUSH
2024: LD_INT 4
2026: PPUSH
2027: LD_INT 0
2029: PPUSH
2030: CALL_OW 49
// end ;
2034: GO 2000
2036: POP
2037: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) do
2038: LD_ADDR_VAR 0 2
2042: PUSH
2043: LD_INT 22
2045: PUSH
2046: LD_INT 1
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: PUSH
2053: LD_INT 21
2055: PUSH
2056: LD_INT 2
2058: PUSH
2059: EMPTY
2060: LIST
2061: LIST
2062: PUSH
2063: LD_INT 58
2065: PUSH
2066: EMPTY
2067: LIST
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: LIST
2073: PPUSH
2074: CALL_OW 69
2078: PUSH
2079: FOR_IN
2080: IFFALSE 2114
// begin un := CreateHumanWithClass ( 3 , 4 ) ;
2082: LD_ADDR_VAR 0 4
2086: PUSH
2087: LD_INT 3
2089: PPUSH
2090: LD_INT 4
2092: PPUSH
2093: CALL 418 0 2
2097: ST_TO_ADDR
// PlaceHumanInUnit ( un , i ) ;
2098: LD_VAR 0 4
2102: PPUSH
2103: LD_VAR 0 2
2107: PPUSH
2108: CALL_OW 52
// end ;
2112: GO 2079
2114: POP
2115: POP
// end ; end_of_file
2116: LD_VAR 0 1
2120: RET
// export ru_sold , ru_stw , ru_tw , ru_tech , ru_veh , ru_eng , ru_mech , ru_sci , ru_bul , ru_b ; export ru2_sold , ru2_stw , ru2_tw , ru2_tech , ru2_veh , ru2_eng , ru2_mech , ru2_sci , ru2_bul , ru2_b ; export ru_radar ; export function InitRussian ; var ru , ru2 , i , un , filter ; begin
2121: LD_INT 0
2123: PPUSH
2124: PPUSH
2125: PPUSH
2126: PPUSH
2127: PPUSH
2128: PPUSH
// ru := 6 ;
2129: LD_ADDR_VAR 0 2
2133: PUSH
2134: LD_INT 6
2136: ST_TO_ADDR
// ru2 := 3 ;
2137: LD_ADDR_VAR 0 3
2141: PUSH
2142: LD_INT 3
2144: ST_TO_ADDR
// uc_nation := nation_russian ;
2145: LD_ADDR_OWVAR 21
2149: PUSH
2150: LD_INT 3
2152: ST_TO_ADDR
// ru_radar := 98 ;
2153: LD_ADDR_EXP 46
2157: PUSH
2158: LD_INT 98
2160: ST_TO_ADDR
// uc_side := ru ;
2161: LD_ADDR_OWVAR 20
2165: PUSH
2166: LD_VAR 0 2
2170: ST_TO_ADDR
// ru_sold := [ ] ;
2171: LD_ADDR_EXP 26
2175: PUSH
2176: EMPTY
2177: ST_TO_ADDR
// ru_stw := [ ] ;
2178: LD_ADDR_EXP 27
2182: PUSH
2183: EMPTY
2184: ST_TO_ADDR
// ru_tw := [ ] ;
2185: LD_ADDR_EXP 28
2189: PUSH
2190: EMPTY
2191: ST_TO_ADDR
// ru_b := [ ] ;
2192: LD_ADDR_EXP 35
2196: PUSH
2197: EMPTY
2198: ST_TO_ADDR
// ru_eng := [ ] ;
2199: LD_ADDR_EXP 31
2203: PUSH
2204: EMPTY
2205: ST_TO_ADDR
// ru_mech := [ ] ;
2206: LD_ADDR_EXP 32
2210: PUSH
2211: EMPTY
2212: ST_TO_ADDR
// ru_sci := [ ] ;
2213: LD_ADDR_EXP 33
2217: PUSH
2218: EMPTY
2219: ST_TO_ADDR
// ru_bul := [ b_bunker , 162 , 101 , 0 ] ;
2220: LD_ADDR_EXP 34
2224: PUSH
2225: LD_INT 32
2227: PUSH
2228: LD_INT 162
2230: PUSH
2231: LD_INT 101
2233: PUSH
2234: LD_INT 0
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: LIST
2241: LIST
2242: ST_TO_ADDR
// ru_tech := [ tech_tech1 , tech_tech2 , tech_tech3 , tech_oilpow , tech_oileng , tech_weap1 , tech_weap2 , tech_gatling , tech_advmet , tech_weap3 ] ;
2243: LD_ADDR_EXP 29
2247: PUSH
2248: LD_INT 48
2250: PUSH
2251: LD_INT 49
2253: PUSH
2254: LD_INT 50
2256: PUSH
2257: LD_INT 46
2259: PUSH
2260: LD_INT 47
2262: PUSH
2263: LD_INT 51
2265: PUSH
2266: LD_INT 52
2268: PUSH
2269: LD_INT 69
2271: PUSH
2272: LD_INT 34
2274: PUSH
2275: LD_INT 53
2277: PUSH
2278: EMPTY
2279: LIST
2280: LIST
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: LIST
2288: LIST
2289: ST_TO_ADDR
// ru_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
2290: LD_ADDR_EXP 30
2294: PUSH
2295: LD_INT 21
2297: PUSH
2298: LD_INT 1
2300: PUSH
2301: LD_INT 1
2303: PUSH
2304: LD_INT 51
2306: PUSH
2307: LD_INT 22
2309: PUSH
2310: LD_INT 1
2312: PUSH
2313: LD_INT 1
2315: PUSH
2316: LD_INT 52
2318: PUSH
2319: LD_INT 22
2321: PUSH
2322: LD_INT 1
2324: PUSH
2325: LD_INT 1
2327: PUSH
2328: LD_INT 52
2330: PUSH
2331: EMPTY
2332: LIST
2333: LIST
2334: LIST
2335: LIST
2336: LIST
2337: LIST
2338: LIST
2339: LIST
2340: LIST
2341: LIST
2342: LIST
2343: LIST
2344: ST_TO_ADDR
// SetBName ( kirov , kirov ) ;
2345: LD_INT 71
2347: PPUSH
2348: LD_STRING kirov
2350: PPUSH
2351: CALL_OW 500
// hc_gallery := ru ;
2355: LD_ADDR_OWVAR 33
2359: PUSH
2360: LD_STRING ru
2362: ST_TO_ADDR
// hc_face_number := 8 ;
2363: LD_ADDR_OWVAR 34
2367: PUSH
2368: LD_INT 8
2370: ST_TO_ADDR
// hc_skills := [ 7 , 4 , 3 , 2 ] ;
2371: LD_ADDR_OWVAR 31
2375: PUSH
2376: LD_INT 7
2378: PUSH
2379: LD_INT 4
2381: PUSH
2382: LD_INT 3
2384: PUSH
2385: LD_INT 2
2387: PUSH
2388: EMPTY
2389: LIST
2390: LIST
2391: LIST
2392: LIST
2393: ST_TO_ADDR
// hc_sex := sex_male ;
2394: LD_ADDR_OWVAR 27
2398: PUSH
2399: LD_INT 1
2401: ST_TO_ADDR
// hc_name := P³k. Iwan Kurin ;
2402: LD_ADDR_OWVAR 26
2406: PUSH
2407: LD_STRING P³k. Iwan Kurin
2409: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2410: LD_ADDR_OWVAR 29
2414: PUSH
2415: LD_INT 10
2417: PUSH
2418: LD_INT 10
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: ST_TO_ADDR
// kurin := CreateHuman ;
2425: LD_ADDR_EXP 13
2429: PUSH
2430: CALL_OW 44
2434: ST_TO_ADDR
// PlaceHumanInUnit ( kurin , kirov ) ;
2435: LD_EXP 13
2439: PPUSH
2440: LD_INT 71
2442: PPUSH
2443: CALL_OW 52
// filter := FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_bunker ] ] ) ;
2447: LD_ADDR_VAR 0 6
2451: PUSH
2452: LD_INT 22
2454: PUSH
2455: LD_INT 6
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 30
2464: PUSH
2465: LD_INT 32
2467: PUSH
2468: EMPTY
2469: LIST
2470: LIST
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: PPUSH
2476: CALL_OW 69
2480: ST_TO_ADDR
// for i = 1 to ru_force do
2481: LD_ADDR_VAR 0 4
2485: PUSH
2486: DOUBLE
2487: LD_INT 1
2489: DEC
2490: ST_TO_ADDR
2491: LD_EXP 3
2495: PUSH
2496: FOR_TO
2497: IFFALSE 2568
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
2499: LD_ADDR_VAR 0 5
2503: PUSH
2504: LD_INT 1
2506: PPUSH
2507: LD_EXP 4
2511: PPUSH
2512: CALL 418 0 2
2516: ST_TO_ADDR
// if i <= filter then
2517: LD_VAR 0 4
2521: PUSH
2522: LD_VAR 0 6
2526: LESSEQUAL
2527: IFFALSE 2551
// PlaceHumanInUnit ( un , filter [ i ] ) else
2529: LD_VAR 0 5
2533: PPUSH
2534: LD_VAR 0 6
2538: PUSH
2539: LD_VAR 0 4
2543: ARRAY
2544: PPUSH
2545: CALL_OW 52
2549: GO 2566
// PlaceUnitArea ( un , ru_area , false ) ;
2551: LD_VAR 0 5
2555: PPUSH
2556: LD_INT 3
2558: PPUSH
2559: LD_INT 0
2561: PPUSH
2562: CALL_OW 49
// end ;
2566: GO 2496
2568: POP
2569: POP
// for i = 1 to 6 do
2570: LD_ADDR_VAR 0 4
2574: PUSH
2575: DOUBLE
2576: LD_INT 1
2578: DEC
2579: ST_TO_ADDR
2580: LD_INT 6
2582: PUSH
2583: FOR_TO
2584: IFFALSE 2621
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
2586: LD_ADDR_VAR 0 5
2590: PUSH
2591: LD_INT 3
2593: PPUSH
2594: LD_EXP 4
2598: PPUSH
2599: CALL 418 0 2
2603: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
2604: LD_VAR 0 5
2608: PPUSH
2609: LD_INT 3
2611: PPUSH
2612: LD_INT 0
2614: PPUSH
2615: CALL_OW 49
// end ;
2619: GO 2583
2621: POP
2622: POP
// for i = 1 to 3 do
2623: LD_ADDR_VAR 0 4
2627: PUSH
2628: DOUBLE
2629: LD_INT 1
2631: DEC
2632: ST_TO_ADDR
2633: LD_INT 3
2635: PUSH
2636: FOR_TO
2637: IFFALSE 2674
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
2639: LD_ADDR_VAR 0 5
2643: PUSH
2644: LD_INT 4
2646: PPUSH
2647: LD_EXP 4
2651: PPUSH
2652: CALL 418 0 2
2656: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
2657: LD_VAR 0 5
2661: PPUSH
2662: LD_INT 3
2664: PPUSH
2665: LD_INT 0
2667: PPUSH
2668: CALL_OW 49
// end ;
2672: GO 2636
2674: POP
2675: POP
// for i = 1 to 4 do
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: DOUBLE
2682: LD_INT 1
2684: DEC
2685: ST_TO_ADDR
2686: LD_INT 4
2688: PUSH
2689: FOR_TO
2690: IFFALSE 2727
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
2692: LD_ADDR_VAR 0 5
2696: PUSH
2697: LD_INT 2
2699: PPUSH
2700: LD_EXP 4
2704: PPUSH
2705: CALL 418 0 2
2709: ST_TO_ADDR
// PlaceUnitArea ( un , ru_area , false ) ;
2710: LD_VAR 0 5
2714: PPUSH
2715: LD_INT 3
2717: PPUSH
2718: LD_INT 0
2720: PPUSH
2721: CALL_OW 49
// end ;
2725: GO 2689
2727: POP
2728: POP
// uc_side := ru2 ;
2729: LD_ADDR_OWVAR 20
2733: PUSH
2734: LD_VAR 0 3
2738: ST_TO_ADDR
// ru2_sold := [ ] ;
2739: LD_ADDR_EXP 36
2743: PUSH
2744: EMPTY
2745: ST_TO_ADDR
// ru2_stw := [ ] ;
2746: LD_ADDR_EXP 37
2750: PUSH
2751: EMPTY
2752: ST_TO_ADDR
// ru2_tw := [ ] ;
2753: LD_ADDR_EXP 38
2757: PUSH
2758: EMPTY
2759: ST_TO_ADDR
// ru2_b := [ ] ;
2760: LD_ADDR_EXP 45
2764: PUSH
2765: EMPTY
2766: ST_TO_ADDR
// ru2_eng := [ ] ;
2767: LD_ADDR_EXP 41
2771: PUSH
2772: EMPTY
2773: ST_TO_ADDR
// ru2_mech := [ ] ;
2774: LD_ADDR_EXP 42
2778: PUSH
2779: EMPTY
2780: ST_TO_ADDR
// ru2_sci := [ ] ;
2781: LD_ADDR_EXP 43
2785: PUSH
2786: EMPTY
2787: ST_TO_ADDR
// ru2_bul := [ ] ;
2788: LD_ADDR_EXP 44
2792: PUSH
2793: EMPTY
2794: ST_TO_ADDR
// ru2_tech := [ tech_tech1 , tech_tech2 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_advmet , tech_weap3 , tech_tech3 ] ;
2795: LD_ADDR_EXP 39
2799: PUSH
2800: LD_INT 48
2802: PUSH
2803: LD_INT 49
2805: PUSH
2806: LD_INT 51
2808: PUSH
2809: LD_INT 52
2811: PUSH
2812: LD_INT 69
2814: PUSH
2815: LD_INT 39
2817: PUSH
2818: LD_INT 34
2820: PUSH
2821: LD_INT 53
2823: PUSH
2824: LD_INT 50
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: LIST
2837: ST_TO_ADDR
// ru2_veh := [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , ru_medium_tracked , engine_combustion , control_manual , ru_crane , ru_medium_tracked , engine_combustion , control_manual , ru_crane ] ;
2838: LD_ADDR_EXP 40
2842: PUSH
2843: LD_INT 21
2845: PUSH
2846: LD_INT 1
2848: PUSH
2849: LD_INT 1
2851: PUSH
2852: LD_INT 51
2854: PUSH
2855: LD_INT 22
2857: PUSH
2858: LD_INT 1
2860: PUSH
2861: LD_INT 1
2863: PUSH
2864: LD_INT 52
2866: PUSH
2867: LD_INT 22
2869: PUSH
2870: LD_INT 1
2872: PUSH
2873: LD_INT 1
2875: PUSH
2876: LD_INT 52
2878: PUSH
2879: EMPTY
2880: LIST
2881: LIST
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: ST_TO_ADDR
// SetBName ( beria , beria ) ;
2893: LD_INT 106
2895: PPUSH
2896: LD_STRING beria
2898: PPUSH
2899: CALL_OW 500
// SetBName ( kagan , kagan ) ;
2903: LD_INT 112
2905: PPUSH
2906: LD_STRING kagan
2908: PPUSH
2909: CALL_OW 500
// for i = 1 to 12 do
2913: LD_ADDR_VAR 0 4
2917: PUSH
2918: DOUBLE
2919: LD_INT 1
2921: DEC
2922: ST_TO_ADDR
2923: LD_INT 12
2925: PUSH
2926: FOR_TO
2927: IFFALSE 2964
// begin un := CreateHumanWithClass ( 1 , ru_def ) ;
2929: LD_ADDR_VAR 0 5
2933: PUSH
2934: LD_INT 1
2936: PPUSH
2937: LD_EXP 4
2941: PPUSH
2942: CALL 418 0 2
2946: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
2947: LD_VAR 0 5
2951: PPUSH
2952: LD_INT 5
2954: PPUSH
2955: LD_INT 0
2957: PPUSH
2958: CALL_OW 49
// end ;
2962: GO 2926
2964: POP
2965: POP
// for i = 1 to 6 do
2966: LD_ADDR_VAR 0 4
2970: PUSH
2971: DOUBLE
2972: LD_INT 1
2974: DEC
2975: ST_TO_ADDR
2976: LD_INT 6
2978: PUSH
2979: FOR_TO
2980: IFFALSE 3017
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
2982: LD_ADDR_VAR 0 5
2986: PUSH
2987: LD_INT 3
2989: PPUSH
2990: LD_EXP 4
2994: PPUSH
2995: CALL 418 0 2
2999: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
3000: LD_VAR 0 5
3004: PPUSH
3005: LD_INT 5
3007: PPUSH
3008: LD_INT 0
3010: PPUSH
3011: CALL_OW 49
// end ;
3015: GO 2979
3017: POP
3018: POP
// for i = 1 to 4 do
3019: LD_ADDR_VAR 0 4
3023: PUSH
3024: DOUBLE
3025: LD_INT 1
3027: DEC
3028: ST_TO_ADDR
3029: LD_INT 4
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3070
// begin un := CreateHumanWithClass ( 4 , ru_def ) ;
3035: LD_ADDR_VAR 0 5
3039: PUSH
3040: LD_INT 4
3042: PPUSH
3043: LD_EXP 4
3047: PPUSH
3048: CALL 418 0 2
3052: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
3053: LD_VAR 0 5
3057: PPUSH
3058: LD_INT 5
3060: PPUSH
3061: LD_INT 0
3063: PPUSH
3064: CALL_OW 49
// end ;
3068: GO 3032
3070: POP
3071: POP
// for i = 1 to 4 do
3072: LD_ADDR_VAR 0 4
3076: PUSH
3077: DOUBLE
3078: LD_INT 1
3080: DEC
3081: ST_TO_ADDR
3082: LD_INT 4
3084: PUSH
3085: FOR_TO
3086: IFFALSE 3123
// begin un := CreateHumanWithClass ( 2 , ru_def ) ;
3088: LD_ADDR_VAR 0 5
3092: PUSH
3093: LD_INT 2
3095: PPUSH
3096: LD_EXP 4
3100: PPUSH
3101: CALL 418 0 2
3105: ST_TO_ADDR
// PlaceUnitArea ( un , ru2_area , false ) ;
3106: LD_VAR 0 5
3110: PPUSH
3111: LD_INT 5
3113: PPUSH
3114: LD_INT 0
3116: PPUSH
3117: CALL_OW 49
// end ;
3121: GO 3085
3123: POP
3124: POP
// end ;
3125: LD_VAR 0 1
3129: RET
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , enemy_detected ;
3130: GO 3132
3132: DISABLE
3133: LD_INT 0
3135: PPUSH
3136: PPUSH
3137: PPUSH
3138: PPUSH
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// begin enable ;
3145: ENABLE
// ru_sold := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) diff Kurin ;
3146: LD_ADDR_EXP 26
3150: PUSH
3151: LD_INT 22
3153: PUSH
3154: LD_INT 6
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PUSH
3161: LD_INT 25
3163: PUSH
3164: LD_INT 1
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: PUSH
3171: LD_INT 24
3173: PUSH
3174: LD_INT 600
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: PUSH
3186: EMPTY
3187: LIST
3188: PPUSH
3189: CALL_OW 69
3193: PUSH
3194: LD_EXP 13
3198: DIFF
3199: ST_TO_ADDR
// ru_eng := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
3200: LD_ADDR_EXP 31
3204: PUSH
3205: LD_INT 22
3207: PUSH
3208: LD_INT 6
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: PUSH
3215: LD_INT 25
3217: PUSH
3218: LD_INT 2
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: LD_INT 24
3227: PUSH
3228: LD_INT 600
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: PUSH
3240: EMPTY
3241: LIST
3242: PPUSH
3243: CALL_OW 69
3247: ST_TO_ADDR
// ru_mech := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
3248: LD_ADDR_EXP 32
3252: PUSH
3253: LD_INT 22
3255: PUSH
3256: LD_INT 6
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: PUSH
3263: LD_INT 25
3265: PUSH
3266: LD_INT 3
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: PUSH
3273: LD_INT 24
3275: PUSH
3276: LD_INT 600
3278: PUSH
3279: EMPTY
3280: LIST
3281: LIST
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: EMPTY
3289: LIST
3290: PPUSH
3291: CALL_OW 69
3295: ST_TO_ADDR
// ru_sci := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
3296: LD_ADDR_EXP 33
3300: PUSH
3301: LD_INT 22
3303: PUSH
3304: LD_INT 6
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 25
3313: PUSH
3314: LD_INT 4
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: PUSH
3321: LD_INT 24
3323: PUSH
3324: LD_INT 600
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: PUSH
3331: EMPTY
3332: LIST
3333: LIST
3334: LIST
3335: PUSH
3336: EMPTY
3337: LIST
3338: PPUSH
3339: CALL_OW 69
3343: ST_TO_ADDR
// ru_tw := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
3344: LD_ADDR_EXP 28
3348: PUSH
3349: LD_INT 22
3351: PUSH
3352: LD_INT 6
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: PUSH
3359: LD_INT 2
3361: PUSH
3362: LD_INT 30
3364: PUSH
3365: LD_INT 31
3367: PUSH
3368: EMPTY
3369: LIST
3370: LIST
3371: PUSH
3372: LD_INT 30
3374: PUSH
3375: LD_INT 32
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: PUSH
3382: EMPTY
3383: LIST
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 24
3389: PUSH
3390: LD_INT 250
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: PUSH
3397: EMPTY
3398: LIST
3399: LIST
3400: LIST
3401: PUSH
3402: EMPTY
3403: LIST
3404: PPUSH
3405: CALL_OW 69
3409: ST_TO_ADDR
// ru_b := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) ;
3410: LD_ADDR_EXP 35
3414: PUSH
3415: LD_INT 22
3417: PUSH
3418: LD_INT 6
3420: PUSH
3421: EMPTY
3422: LIST
3423: LIST
3424: PUSH
3425: LD_INT 21
3427: PUSH
3428: LD_INT 3
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: PPUSH
3439: CALL_OW 69
3443: ST_TO_ADDR
// b_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
3444: LD_ADDR_VAR 0 6
3448: PUSH
3449: LD_INT 22
3451: PUSH
3452: LD_INT 6
3454: PUSH
3455: EMPTY
3456: LIST
3457: LIST
3458: PUSH
3459: LD_INT 21
3461: PUSH
3462: LD_INT 3
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: PUSH
3469: LD_INT 3
3471: PUSH
3472: LD_INT 24
3474: PUSH
3475: LD_INT 1000
3477: PUSH
3478: EMPTY
3479: LIST
3480: LIST
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: PUSH
3486: EMPTY
3487: LIST
3488: LIST
3489: LIST
3490: PUSH
3491: EMPTY
3492: LIST
3493: PPUSH
3494: CALL_OW 69
3498: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
3499: LD_ADDR_VAR 0 5
3503: PUSH
3504: LD_INT 22
3506: PUSH
3507: LD_INT 6
3509: PUSH
3510: EMPTY
3511: LIST
3512: LIST
3513: PUSH
3514: LD_INT 21
3516: PUSH
3517: LD_INT 1
3519: PUSH
3520: EMPTY
3521: LIST
3522: LIST
3523: PUSH
3524: LD_INT 3
3526: PUSH
3527: LD_INT 24
3529: PUSH
3530: LD_INT 600
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: PUSH
3537: EMPTY
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: LIST
3545: PUSH
3546: EMPTY
3547: LIST
3548: PPUSH
3549: CALL_OW 69
3553: ST_TO_ADDR
// b_weap := AvailableWeaponList ( ru_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
3554: LD_ADDR_VAR 0 8
3558: PUSH
3559: LD_INT 92
3561: PPUSH
3562: CALL_OW 478
3566: PUSH
3567: LD_INT 52
3569: PUSH
3570: LD_INT 51
3572: PUSH
3573: LD_INT 53
3575: PUSH
3576: LD_EXP 46
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: DIFF
3587: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_breastwork , b_workshop ] ;
3588: LD_ADDR_VAR 0 9
3592: PUSH
3593: LD_INT 0
3595: PUSH
3596: LD_INT 4
3598: PUSH
3599: LD_INT 31
3601: PUSH
3602: LD_INT 2
3604: PUSH
3605: EMPTY
3606: LIST
3607: LIST
3608: LIST
3609: LIST
3610: ST_TO_ADDR
// if FilterUnitsInArea ( kirov_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) > 0 then
3611: LD_INT 6
3613: PPUSH
3614: LD_INT 2
3616: PUSH
3617: LD_INT 22
3619: PUSH
3620: LD_INT 1
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 22
3629: PUSH
3630: LD_INT 2
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: PUSH
3637: EMPTY
3638: LIST
3639: LIST
3640: LIST
3641: PPUSH
3642: CALL_OW 70
3646: PUSH
3647: LD_INT 0
3649: GREATER
3650: IFFALSE 3662
// enemy_detected := true else
3652: LD_ADDR_VAR 0 10
3656: PUSH
3657: LD_INT 1
3659: ST_TO_ADDR
3660: GO 3670
// enemy_detected := false ;
3662: LD_ADDR_VAR 0 10
3666: PUSH
3667: LD_INT 0
3669: ST_TO_ADDR
// if enemy_detected = false then
3670: LD_VAR 0 10
3674: PUSH
3675: LD_INT 0
3677: EQUAL
3678: IFFALSE 3740
// for i = 1 to ru_b do
3680: LD_ADDR_VAR 0 1
3684: PUSH
3685: DOUBLE
3686: LD_INT 1
3688: DEC
3689: ST_TO_ADDR
3690: LD_EXP 35
3694: PUSH
3695: FOR_TO
3696: IFFALSE 3738
// if GetBType ( ru_b [ i ] ) in b_upgrade then
3698: LD_EXP 35
3702: PUSH
3703: LD_VAR 0 1
3707: ARRAY
3708: PPUSH
3709: CALL_OW 266
3713: PUSH
3714: LD_VAR 0 9
3718: IN
3719: IFFALSE 3736
// ComUpgrade ( ru_b [ i ] ) ;
3721: LD_EXP 35
3725: PUSH
3726: LD_VAR 0 1
3730: ARRAY
3731: PPUSH
3732: CALL_OW 146
3736: GO 3695
3738: POP
3739: POP
// if ru_sold > 0 then
3740: LD_EXP 26
3744: PUSH
3745: LD_INT 0
3747: GREATER
3748: IFFALSE 4162
// begin filter := UnitFilter ( ru_sold , [ f_not , [ f_inside ] ] ) ;
3750: LD_ADDR_VAR 0 4
3754: PUSH
3755: LD_EXP 26
3759: PPUSH
3760: LD_INT 3
3762: PUSH
3763: LD_INT 54
3765: PUSH
3766: EMPTY
3767: LIST
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PPUSH
3773: CALL_OW 72
3777: ST_TO_ADDR
// if UnitFilter ( ru_tw , [ f_empty ] ) > 0 then
3778: LD_EXP 28
3782: PPUSH
3783: LD_INT 58
3785: PUSH
3786: EMPTY
3787: LIST
3788: PPUSH
3789: CALL_OW 72
3793: PUSH
3794: LD_INT 0
3796: GREATER
3797: IFFALSE 3865
// begin if filter = 0 then
3799: LD_VAR 0 4
3803: PUSH
3804: LD_INT 0
3806: EQUAL
3807: IFFALSE 3832
// ComExitBuilding ( ru_sold [ Rand ( 1 , ru_sold ) ] ) ;
3809: LD_EXP 26
3813: PUSH
3814: LD_INT 1
3816: PPUSH
3817: LD_EXP 26
3821: PPUSH
3822: CALL_OW 12
3826: ARRAY
3827: PPUSH
3828: CALL_OW 122
// ComEnterUnit ( filter [ 1 ] , UnitFilter ( ru_tw , [ f_empty ] ) [ 1 ] ) ;
3832: LD_VAR 0 4
3836: PUSH
3837: LD_INT 1
3839: ARRAY
3840: PPUSH
3841: LD_EXP 28
3845: PPUSH
3846: LD_INT 58
3848: PUSH
3849: EMPTY
3850: LIST
3851: PPUSH
3852: CALL_OW 72
3856: PUSH
3857: LD_INT 1
3859: ARRAY
3860: PPUSH
3861: CALL_OW 120
// end ; if UnitFilter ( ru_tw , [ f_empty ] ) = 0 then
3865: LD_EXP 28
3869: PPUSH
3870: LD_INT 58
3872: PUSH
3873: EMPTY
3874: LIST
3875: PPUSH
3876: CALL_OW 72
3880: PUSH
3881: LD_INT 0
3883: EQUAL
3884: IFFALSE 4039
// begin b_unit := FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
3886: LD_ADDR_VAR 0 7
3890: PUSH
3891: LD_INT 22
3893: PUSH
3894: LD_INT 6
3896: PUSH
3897: EMPTY
3898: LIST
3899: LIST
3900: PUSH
3901: LD_INT 2
3903: PUSH
3904: LD_INT 30
3906: PUSH
3907: LD_INT 4
3909: PUSH
3910: EMPTY
3911: LIST
3912: LIST
3913: PUSH
3914: LD_INT 30
3916: PUSH
3917: LD_INT 5
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: LIST
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: PPUSH
3933: CALL_OW 69
3937: ST_TO_ADDR
// if b_unit > 0 then
3938: LD_VAR 0 7
3942: PUSH
3943: LD_INT 0
3945: GREATER
3946: IFFALSE 4039
// for p = 1 to b_unit do
3948: LD_ADDR_VAR 0 2
3952: PUSH
3953: DOUBLE
3954: LD_INT 1
3956: DEC
3957: ST_TO_ADDR
3958: LD_VAR 0 7
3962: PUSH
3963: FOR_TO
3964: IFFALSE 4037
// if UnitsInSide ( b_unit [ p ] ) < 6 then
3966: LD_VAR 0 7
3970: PUSH
3971: LD_VAR 0 2
3975: ARRAY
3976: PPUSH
3977: CALL_OW 313
3981: PUSH
3982: LD_INT 6
3984: LESS
3985: IFFALSE 4035
// for i = 1 to filter do
3987: LD_ADDR_VAR 0 1
3991: PUSH
3992: DOUBLE
3993: LD_INT 1
3995: DEC
3996: ST_TO_ADDR
3997: LD_VAR 0 4
4001: PUSH
4002: FOR_TO
4003: IFFALSE 4033
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
4005: LD_VAR 0 4
4009: PUSH
4010: LD_VAR 0 1
4014: ARRAY
4015: PPUSH
4016: LD_VAR 0 7
4020: PUSH
4021: LD_VAR 0 2
4025: ARRAY
4026: PPUSH
4027: CALL_OW 120
4031: GO 4002
4033: POP
4034: POP
4035: GO 3963
4037: POP
4038: POP
// end ; if UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
4039: LD_EXP 28
4043: PPUSH
4044: LD_INT 30
4046: PUSH
4047: LD_INT 32
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: PUSH
4054: LD_INT 35
4056: PUSH
4057: LD_INT 0
4059: PUSH
4060: EMPTY
4061: LIST
4062: LIST
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: PPUSH
4068: CALL_OW 72
4072: PUSH
4073: LD_INT 0
4075: GREATER
4076: IFFALSE 4162
// begin filter := UnitFilter ( ru_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
4078: LD_ADDR_VAR 0 4
4082: PUSH
4083: LD_EXP 28
4087: PPUSH
4088: LD_INT 30
4090: PUSH
4091: LD_INT 32
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: PUSH
4098: LD_INT 35
4100: PUSH
4101: LD_INT 0
4103: PUSH
4104: EMPTY
4105: LIST
4106: LIST
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: PPUSH
4112: CALL_OW 72
4116: ST_TO_ADDR
// if BuildingStatus ( ru_fac ) = bs_idle then
4117: LD_INT 92
4119: PPUSH
4120: CALL_OW 461
4124: PUSH
4125: LD_INT 2
4127: EQUAL
4128: IFFALSE 4162
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
4130: LD_VAR 0 4
4134: PUSH
4135: LD_INT 1
4137: ARRAY
4138: PPUSH
4139: LD_VAR 0 8
4143: PUSH
4144: LD_INT 1
4146: PPUSH
4147: LD_VAR 0 8
4151: PPUSH
4152: CALL_OW 12
4156: ARRAY
4157: PPUSH
4158: CALL_OW 148
// end ; end ; if ru_mech > 0 then
4162: LD_EXP 32
4166: PUSH
4167: LD_INT 0
4169: GREATER
4170: IFFALSE 4230
// for i = 1 to ru_mech do
4172: LD_ADDR_VAR 0 1
4176: PUSH
4177: DOUBLE
4178: LD_INT 1
4180: DEC
4181: ST_TO_ADDR
4182: LD_EXP 32
4186: PUSH
4187: FOR_TO
4188: IFFALSE 4228
// if not IsInUnit ( ru_mech [ i ] ) then
4190: LD_EXP 32
4194: PUSH
4195: LD_VAR 0 1
4199: ARRAY
4200: PPUSH
4201: CALL_OW 310
4205: NOT
4206: IFFALSE 4226
// ComEnterUnit ( ru_mech [ i ] , ru_fac ) ;
4208: LD_EXP 32
4212: PUSH
4213: LD_VAR 0 1
4217: ARRAY
4218: PPUSH
4219: LD_INT 92
4221: PPUSH
4222: CALL_OW 120
4226: GO 4187
4228: POP
4229: POP
// if ru_fac then
4230: LD_INT 92
4232: IFFALSE 4338
// if ru_veh > 0 then
4234: LD_EXP 30
4238: PUSH
4239: LD_INT 0
4241: GREATER
4242: IFFALSE 4338
// if BuildingStatus ( ru_fac ) = bs_idle then
4244: LD_INT 92
4246: PPUSH
4247: CALL_OW 461
4251: PUSH
4252: LD_INT 2
4254: EQUAL
4255: IFFALSE 4338
// begin ComConstruct ( ru_fac , ru_veh [ 1 ] , ru_veh [ 2 ] , ru_veh [ 3 ] , ru_veh [ 4 ] ) ;
4257: LD_INT 92
4259: PPUSH
4260: LD_EXP 30
4264: PUSH
4265: LD_INT 1
4267: ARRAY
4268: PPUSH
4269: LD_EXP 30
4273: PUSH
4274: LD_INT 2
4276: ARRAY
4277: PPUSH
4278: LD_EXP 30
4282: PUSH
4283: LD_INT 3
4285: ARRAY
4286: PPUSH
4287: LD_EXP 30
4291: PUSH
4292: LD_INT 4
4294: ARRAY
4295: PPUSH
4296: CALL_OW 125
// for i = 1 to 4 do
4300: LD_ADDR_VAR 0 1
4304: PUSH
4305: DOUBLE
4306: LD_INT 1
4308: DEC
4309: ST_TO_ADDR
4310: LD_INT 4
4312: PUSH
4313: FOR_TO
4314: IFFALSE 4336
// ru_veh := Delete ( ru_veh , 1 ) ;
4316: LD_ADDR_EXP 30
4320: PUSH
4321: LD_EXP 30
4325: PPUSH
4326: LD_INT 1
4328: PPUSH
4329: CALL_OW 3
4333: ST_TO_ADDR
4334: GO 4313
4336: POP
4337: POP
// end ; if b_dmgunit > 0 then
4338: LD_VAR 0 6
4342: PUSH
4343: LD_INT 0
4345: GREATER
4346: IFFALSE 4531
// begin if ru_eng > 0 then
4348: LD_EXP 31
4352: PUSH
4353: LD_INT 0
4355: GREATER
4356: IFFALSE 4436
// for i = 1 to ru_eng do
4358: LD_ADDR_VAR 0 1
4362: PUSH
4363: DOUBLE
4364: LD_INT 1
4366: DEC
4367: ST_TO_ADDR
4368: LD_EXP 31
4372: PUSH
4373: FOR_TO
4374: IFFALSE 4434
// begin if IsInUnit ( ru_eng [ i ] ) then
4376: LD_EXP 31
4380: PUSH
4381: LD_VAR 0 1
4385: ARRAY
4386: PPUSH
4387: CALL_OW 310
4391: IFFALSE 4408
// ComExitBuilding ( ru_eng [ i ] ) ;
4393: LD_EXP 31
4397: PUSH
4398: LD_VAR 0 1
4402: ARRAY
4403: PPUSH
4404: CALL_OW 122
// ComRepairBuilding ( ru_eng [ i ] , b_dmgunit [ 1 ] ) ;
4408: LD_EXP 31
4412: PUSH
4413: LD_VAR 0 1
4417: ARRAY
4418: PPUSH
4419: LD_VAR 0 6
4423: PUSH
4424: LD_INT 1
4426: ARRAY
4427: PPUSH
4428: CALL_OW 130
// end ;
4432: GO 4373
4434: POP
4435: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) > 0 then
4436: LD_INT 22
4438: PUSH
4439: LD_INT 6
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: PUSH
4446: LD_INT 34
4448: PUSH
4449: LD_INT 52
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PPUSH
4460: CALL_OW 69
4464: PUSH
4465: LD_INT 0
4467: GREATER
4468: IFFALSE 4529
// for p in FilterAllUnits ( [ [ f_side , 6 ] , [ f_weapon , ru_crane ] ] ) do
4470: LD_ADDR_VAR 0 2
4474: PUSH
4475: LD_INT 22
4477: PUSH
4478: LD_INT 6
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PUSH
4485: LD_INT 34
4487: PUSH
4488: LD_INT 52
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: PPUSH
4499: CALL_OW 69
4503: PUSH
4504: FOR_IN
4505: IFFALSE 4527
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
4507: LD_VAR 0 2
4511: PPUSH
4512: LD_VAR 0 6
4516: PUSH
4517: LD_INT 1
4519: ARRAY
4520: PPUSH
4521: CALL_OW 130
4525: GO 4504
4527: POP
4528: POP
// end else
4529: GO 4659
// if ru_bul = 0 then
4531: LD_EXP 34
4535: PUSH
4536: LD_INT 0
4538: EQUAL
4539: IFFALSE 4659
// for i = 1 to ru_eng do
4541: LD_ADDR_VAR 0 1
4545: PUSH
4546: DOUBLE
4547: LD_INT 1
4549: DEC
4550: ST_TO_ADDR
4551: LD_EXP 31
4555: PUSH
4556: FOR_TO
4557: IFFALSE 4657
// if not HasTask ( ru_eng [ i ] ) then
4559: LD_EXP 31
4563: PUSH
4564: LD_VAR 0 1
4568: ARRAY
4569: PPUSH
4570: CALL_OW 314
4574: NOT
4575: IFFALSE 4655
// ComEnterUnit ( ru_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru_eng [ i ] ) ) ;
4577: LD_EXP 31
4581: PUSH
4582: LD_VAR 0 1
4586: ARRAY
4587: PPUSH
4588: LD_INT 22
4590: PUSH
4591: LD_INT 6
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: PUSH
4598: LD_INT 2
4600: PUSH
4601: LD_INT 30
4603: PUSH
4604: LD_INT 0
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: LD_INT 30
4613: PUSH
4614: LD_INT 1
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: LIST
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: PPUSH
4630: CALL_OW 69
4634: PPUSH
4635: LD_EXP 31
4639: PUSH
4640: LD_VAR 0 1
4644: ARRAY
4645: PPUSH
4646: CALL_OW 74
4650: PPUSH
4651: CALL_OW 120
4655: GO 4556
4657: POP
4658: POP
// if h_dmgunit > 0 then
4659: LD_VAR 0 5
4663: PUSH
4664: LD_INT 0
4666: GREATER
4667: IFFALSE 4874
// begin for p = 1 to h_dmgunit do
4669: LD_ADDR_VAR 0 2
4673: PUSH
4674: DOUBLE
4675: LD_INT 1
4677: DEC
4678: ST_TO_ADDR
4679: LD_VAR 0 5
4683: PUSH
4684: FOR_TO
4685: IFFALSE 4734
// if GetDistUnits ( h_dmgunit [ p ] , ru_lab ) > 6 then
4687: LD_VAR 0 5
4691: PUSH
4692: LD_VAR 0 2
4696: ARRAY
4697: PPUSH
4698: LD_INT 83
4700: PPUSH
4701: CALL_OW 296
4705: PUSH
4706: LD_INT 6
4708: GREATER
4709: IFFALSE 4732
// ComMoveXY ( h_dmgunit [ p ] , 140 , 76 ) ;
4711: LD_VAR 0 5
4715: PUSH
4716: LD_VAR 0 2
4720: ARRAY
4721: PPUSH
4722: LD_INT 140
4724: PPUSH
4725: LD_INT 76
4727: PPUSH
4728: CALL_OW 111
4732: GO 4684
4734: POP
4735: POP
// if ru_sci > 0 then
4736: LD_EXP 33
4740: PUSH
4741: LD_INT 0
4743: GREATER
4744: IFFALSE 4874
// for i = 1 to ru_sci do
4746: LD_ADDR_VAR 0 1
4750: PUSH
4751: DOUBLE
4752: LD_INT 1
4754: DEC
4755: ST_TO_ADDR
4756: LD_EXP 33
4760: PUSH
4761: FOR_TO
4762: IFFALSE 4872
// if IsInUnit ( ru_sci [ i ] ) then
4764: LD_EXP 33
4768: PUSH
4769: LD_VAR 0 1
4773: ARRAY
4774: PPUSH
4775: CALL_OW 310
4779: IFFALSE 4798
// ComExitBuilding ( ru_sci [ i ] ) else
4781: LD_EXP 33
4785: PUSH
4786: LD_VAR 0 1
4790: ARRAY
4791: PPUSH
4792: CALL_OW 122
4796: GO 4870
// if not HasTask ( ru_sci [ i ] ) then
4798: LD_EXP 33
4802: PUSH
4803: LD_VAR 0 1
4807: ARRAY
4808: PPUSH
4809: CALL_OW 314
4813: NOT
4814: IFFALSE 4870
// if GetDistUnits ( ru_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
4816: LD_EXP 33
4820: PUSH
4821: LD_VAR 0 1
4825: ARRAY
4826: PPUSH
4827: LD_VAR 0 5
4831: PUSH
4832: LD_INT 1
4834: ARRAY
4835: PPUSH
4836: CALL_OW 296
4840: PUSH
4841: LD_INT 15
4843: LESSEQUAL
4844: IFFALSE 4870
// ComHeal ( ru_sci [ i ] , h_dmgunit [ 1 ] ) ;
4846: LD_EXP 33
4850: PUSH
4851: LD_VAR 0 1
4855: ARRAY
4856: PPUSH
4857: LD_VAR 0 5
4861: PUSH
4862: LD_INT 1
4864: ARRAY
4865: PPUSH
4866: CALL_OW 128
4870: GO 4761
4872: POP
4873: POP
// end ; if h_dmgunit = 0 then
4874: LD_VAR 0 5
4878: PUSH
4879: LD_INT 0
4881: EQUAL
4882: IFFALSE 4999
// begin for i = 1 to ru_sci do
4884: LD_ADDR_VAR 0 1
4888: PUSH
4889: DOUBLE
4890: LD_INT 1
4892: DEC
4893: ST_TO_ADDR
4894: LD_EXP 33
4898: PUSH
4899: FOR_TO
4900: IFFALSE 4940
// if not IsInUnit ( ru_sci [ i ] ) then
4902: LD_EXP 33
4906: PUSH
4907: LD_VAR 0 1
4911: ARRAY
4912: PPUSH
4913: CALL_OW 310
4917: NOT
4918: IFFALSE 4938
// ComEnterUnit ( ru_sci [ i ] , ru_lab ) ;
4920: LD_EXP 33
4924: PUSH
4925: LD_VAR 0 1
4929: ARRAY
4930: PPUSH
4931: LD_INT 83
4933: PPUSH
4934: CALL_OW 120
4938: GO 4899
4940: POP
4941: POP
// if ru_tech > 0 then
4942: LD_EXP 29
4946: PUSH
4947: LD_INT 0
4949: GREATER
4950: IFFALSE 4999
// if BuildingStatus ( ru_lab ) = bs_idle then
4952: LD_INT 83
4954: PPUSH
4955: CALL_OW 461
4959: PUSH
4960: LD_INT 2
4962: EQUAL
4963: IFFALSE 4999
// begin ComResearch ( ru_lab , ru_tech [ 1 ] ) ;
4965: LD_INT 83
4967: PPUSH
4968: LD_EXP 29
4972: PUSH
4973: LD_INT 1
4975: ARRAY
4976: PPUSH
4977: CALL_OW 124
// ru_tech := Delete ( ru_tech , 1 ) ;
4981: LD_ADDR_EXP 29
4985: PUSH
4986: LD_EXP 29
4990: PPUSH
4991: LD_INT 1
4993: PPUSH
4994: CALL_OW 3
4998: ST_TO_ADDR
// end ; end ; end ;
4999: PPOPN 10
5001: END
// every 4 4$00 trigger ru_fac do var weap ;
5002: LD_INT 92
5004: IFFALSE 5131
5006: GO 5008
5008: DISABLE
5009: LD_INT 0
5011: PPUSH
// begin enable ;
5012: ENABLE
// weap := AvailableWeaponList ( ru_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer ] ;
5013: LD_ADDR_VAR 0 1
5017: PUSH
5018: LD_INT 92
5020: PPUSH
5021: CALL_OW 478
5025: PUSH
5026: LD_INT 52
5028: PUSH
5029: LD_INT 51
5031: PUSH
5032: LD_INT 53
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: LIST
5039: DIFF
5040: ST_TO_ADDR
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
5041: LD_ADDR_EXP 30
5045: PUSH
5046: LD_EXP 30
5050: PUSH
5051: LD_INT 23
5053: PUSH
5054: LD_INT 1
5056: PUSH
5057: LD_INT 1
5059: PUSH
5060: LD_VAR 0 1
5064: PUSH
5065: LD_INT 1
5067: PPUSH
5068: LD_VAR 0 1
5072: PPUSH
5073: CALL_OW 12
5077: ARRAY
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: ADD
5085: ST_TO_ADDR
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , weap [ Rand ( 1 , weap ) ] ] ;
5086: LD_ADDR_EXP 40
5090: PUSH
5091: LD_EXP 40
5095: PUSH
5096: LD_INT 23
5098: PUSH
5099: LD_INT 1
5101: PUSH
5102: LD_INT 1
5104: PUSH
5105: LD_VAR 0 1
5109: PUSH
5110: LD_INT 1
5112: PPUSH
5113: LD_VAR 0 1
5117: PPUSH
5118: CALL_OW 12
5122: ARRAY
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: LIST
5128: LIST
5129: ADD
5130: ST_TO_ADDR
// end ;
5131: PPOPN 1
5133: END
// every 0 0$01 do var i , p , un , filter , h_dmgunit , b_dmgunit , b_unit , b_weap , b_upgrade , b_fac , b_labb , b_ext , enemy_detected ;
5134: GO 5136
5136: DISABLE
5137: LD_INT 0
5139: PPUSH
5140: PPUSH
5141: PPUSH
5142: PPUSH
5143: PPUSH
5144: PPUSH
5145: PPUSH
5146: PPUSH
5147: PPUSH
5148: PPUSH
5149: PPUSH
5150: PPUSH
5151: PPUSH
// begin enable ;
5152: ENABLE
// ru2_sold := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_lives , 600 ] ] ] ) ;
5153: LD_ADDR_EXP 36
5157: PUSH
5158: LD_INT 22
5160: PUSH
5161: LD_INT 3
5163: PUSH
5164: EMPTY
5165: LIST
5166: LIST
5167: PUSH
5168: LD_INT 25
5170: PUSH
5171: LD_INT 1
5173: PUSH
5174: EMPTY
5175: LIST
5176: LIST
5177: PUSH
5178: LD_INT 24
5180: PUSH
5181: LD_INT 600
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: PPUSH
5196: CALL_OW 69
5200: ST_TO_ADDR
// ru2_eng := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 600 ] ] ] ) ;
5201: LD_ADDR_EXP 41
5205: PUSH
5206: LD_INT 22
5208: PUSH
5209: LD_INT 3
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: PUSH
5216: LD_INT 25
5218: PUSH
5219: LD_INT 2
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: LD_INT 24
5228: PUSH
5229: LD_INT 600
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: LIST
5240: PUSH
5241: EMPTY
5242: LIST
5243: PPUSH
5244: CALL_OW 69
5248: ST_TO_ADDR
// ru2_mech := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 3 ] , [ f_lives , 600 ] ] ] ) ;
5249: LD_ADDR_EXP 42
5253: PUSH
5254: LD_INT 22
5256: PUSH
5257: LD_INT 3
5259: PUSH
5260: EMPTY
5261: LIST
5262: LIST
5263: PUSH
5264: LD_INT 25
5266: PUSH
5267: LD_INT 3
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: PUSH
5274: LD_INT 24
5276: PUSH
5277: LD_INT 600
5279: PUSH
5280: EMPTY
5281: LIST
5282: LIST
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: LIST
5288: PUSH
5289: EMPTY
5290: LIST
5291: PPUSH
5292: CALL_OW 69
5296: ST_TO_ADDR
// ru2_sci := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 4 ] , [ f_lives , 600 ] ] ] ) ;
5297: LD_ADDR_EXP 43
5301: PUSH
5302: LD_INT 22
5304: PUSH
5305: LD_INT 3
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PUSH
5312: LD_INT 25
5314: PUSH
5315: LD_INT 4
5317: PUSH
5318: EMPTY
5319: LIST
5320: LIST
5321: PUSH
5322: LD_INT 24
5324: PUSH
5325: LD_INT 600
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: PUSH
5332: EMPTY
5333: LIST
5334: LIST
5335: LIST
5336: PUSH
5337: EMPTY
5338: LIST
5339: PPUSH
5340: CALL_OW 69
5344: ST_TO_ADDR
// ru2_tw := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_lives , 250 ] ] ] ) ;
5345: LD_ADDR_EXP 38
5349: PUSH
5350: LD_INT 22
5352: PUSH
5353: LD_INT 3
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: PUSH
5360: LD_INT 2
5362: PUSH
5363: LD_INT 30
5365: PUSH
5366: LD_INT 31
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: PUSH
5373: LD_INT 30
5375: PUSH
5376: LD_INT 32
5378: PUSH
5379: EMPTY
5380: LIST
5381: LIST
5382: PUSH
5383: EMPTY
5384: LIST
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 24
5390: PUSH
5391: LD_INT 250
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: LIST
5402: PUSH
5403: EMPTY
5404: LIST
5405: PPUSH
5406: CALL_OW 69
5410: ST_TO_ADDR
// ru2_b := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
5411: LD_ADDR_EXP 45
5415: PUSH
5416: LD_INT 22
5418: PUSH
5419: LD_INT 3
5421: PUSH
5422: EMPTY
5423: LIST
5424: LIST
5425: PUSH
5426: LD_INT 21
5428: PUSH
5429: LD_INT 3
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: PPUSH
5440: CALL_OW 69
5444: ST_TO_ADDR
// b_dmgunit := FilterUnitsInArea ( beria_defa , [ [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
5445: LD_ADDR_VAR 0 6
5449: PUSH
5450: LD_INT 8
5452: PPUSH
5453: LD_INT 22
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PUSH
5463: LD_INT 21
5465: PUSH
5466: LD_INT 3
5468: PUSH
5469: EMPTY
5470: LIST
5471: LIST
5472: PUSH
5473: LD_INT 3
5475: PUSH
5476: LD_INT 24
5478: PUSH
5479: LD_INT 1000
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: PUSH
5495: EMPTY
5496: LIST
5497: PPUSH
5498: CALL_OW 70
5502: ST_TO_ADDR
// h_dmgunit := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ] ) ;
5503: LD_ADDR_VAR 0 5
5507: PUSH
5508: LD_INT 22
5510: PUSH
5511: LD_INT 3
5513: PUSH
5514: EMPTY
5515: LIST
5516: LIST
5517: PUSH
5518: LD_INT 21
5520: PUSH
5521: LD_INT 1
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: PUSH
5528: LD_INT 3
5530: PUSH
5531: LD_INT 24
5533: PUSH
5534: LD_INT 600
5536: PUSH
5537: EMPTY
5538: LIST
5539: LIST
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: LIST
5549: PUSH
5550: EMPTY
5551: LIST
5552: PPUSH
5553: CALL_OW 69
5557: ST_TO_ADDR
// b_fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
5558: LD_ADDR_VAR 0 10
5562: PUSH
5563: LD_INT 22
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: PUSH
5573: LD_INT 30
5575: PUSH
5576: LD_INT 3
5578: PUSH
5579: EMPTY
5580: LIST
5581: LIST
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: PPUSH
5587: CALL_OW 69
5591: PUSH
5592: LD_INT 1
5594: ARRAY
5595: ST_TO_ADDR
// b_labb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
5596: LD_ADDR_VAR 0 11
5600: PUSH
5601: LD_INT 22
5603: PUSH
5604: LD_INT 3
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PUSH
5611: LD_INT 2
5613: PUSH
5614: LD_INT 30
5616: PUSH
5617: LD_INT 6
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 7
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: LD_INT 30
5636: PUSH
5637: LD_INT 8
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PPUSH
5654: CALL_OW 69
5658: PUSH
5659: LD_INT 1
5661: ARRAY
5662: ST_TO_ADDR
// b_weap := AvailableWeaponList ( b_fac ) diff [ ru_crane , ru_cargo_bay , ru_bulldozer , ru_radar ] ;
5663: LD_ADDR_VAR 0 8
5667: PUSH
5668: LD_VAR 0 10
5672: PPUSH
5673: CALL_OW 478
5677: PUSH
5678: LD_INT 52
5680: PUSH
5681: LD_INT 51
5683: PUSH
5684: LD_INT 53
5686: PUSH
5687: LD_EXP 46
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: LIST
5696: LIST
5697: DIFF
5698: ST_TO_ADDR
// b_upgrade := [ b_depot , b_armoury , b_workshop ] ;
5699: LD_ADDR_VAR 0 9
5703: PUSH
5704: LD_INT 0
5706: PUSH
5707: LD_INT 4
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: LIST
5717: ST_TO_ADDR
// b_ext := [ ] ;
5718: LD_ADDR_VAR 0 12
5722: PUSH
5723: EMPTY
5724: ST_TO_ADDR
// if FilterUnitsInArea ( beria_strict , [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) diff FilterAllUnits ( [ f_weapon , us_radar ] ) > 0 then
5725: LD_INT 9
5727: PPUSH
5728: LD_INT 2
5730: PUSH
5731: LD_INT 22
5733: PUSH
5734: LD_INT 1
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: PUSH
5741: LD_INT 22
5743: PUSH
5744: LD_INT 2
5746: PUSH
5747: EMPTY
5748: LIST
5749: LIST
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: LIST
5755: PPUSH
5756: CALL_OW 70
5760: PUSH
5761: LD_INT 34
5763: PUSH
5764: LD_INT 11
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 69
5775: PUSH
5776: LD_INT 0
5778: GREATER
5779: DIFF
5780: IFFALSE 5792
// enemy_detected := true else
5782: LD_ADDR_VAR 0 13
5786: PUSH
5787: LD_INT 1
5789: ST_TO_ADDR
5790: GO 5800
// enemy_detected := false ;
5792: LD_ADDR_VAR 0 13
5796: PUSH
5797: LD_INT 0
5799: ST_TO_ADDR
// if enemy_detected = false then
5800: LD_VAR 0 13
5804: PUSH
5805: LD_INT 0
5807: EQUAL
5808: IFFALSE 5909
// for i = 1 to ru2_b do
5810: LD_ADDR_VAR 0 1
5814: PUSH
5815: DOUBLE
5816: LD_INT 1
5818: DEC
5819: ST_TO_ADDR
5820: LD_EXP 45
5824: PUSH
5825: FOR_TO
5826: IFFALSE 5907
// begin if GetBType ( ru2_b [ i ] ) in b_upgrade then
5828: LD_EXP 45
5832: PUSH
5833: LD_VAR 0 1
5837: ARRAY
5838: PPUSH
5839: CALL_OW 266
5843: PUSH
5844: LD_VAR 0 9
5848: IN
5849: IFFALSE 5866
// ComUpgrade ( ru2_b [ i ] ) ;
5851: LD_EXP 45
5855: PUSH
5856: LD_VAR 0 1
5860: ARRAY
5861: PPUSH
5862: CALL_OW 146
// if GetBType ( ru2_b [ i ] ) in b_lab then
5866: LD_EXP 45
5870: PUSH
5871: LD_VAR 0 1
5875: ARRAY
5876: PPUSH
5877: CALL_OW 266
5881: PUSH
5882: LD_INT 6
5884: IN
5885: IFFALSE 5905
// ComUpgradeLab ( ru2_b [ i ] , b_lab_weapon ) ;
5887: LD_EXP 45
5891: PUSH
5892: LD_VAR 0 1
5896: ARRAY
5897: PPUSH
5898: LD_INT 10
5900: PPUSH
5901: CALL_OW 147
// end ;
5905: GO 5825
5907: POP
5908: POP
// if ru2_sold > 0 then
5909: LD_EXP 36
5913: PUSH
5914: LD_INT 0
5916: GREATER
5917: IFFALSE 6380
// begin filter := UnitFilter ( ru2_sold , [ f_not , [ f_inside ] ] ) ;
5919: LD_ADDR_VAR 0 4
5923: PUSH
5924: LD_EXP 36
5928: PPUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 54
5934: PUSH
5935: EMPTY
5936: LIST
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL_OW 72
5946: ST_TO_ADDR
// if UnitFilter ( ru2_tw , [ f_empty ] ) > 0 then
5947: LD_EXP 38
5951: PPUSH
5952: LD_INT 58
5954: PUSH
5955: EMPTY
5956: LIST
5957: PPUSH
5958: CALL_OW 72
5962: PUSH
5963: LD_INT 0
5965: GREATER
5966: IFFALSE 6081
// begin if filter = 0 then
5968: LD_VAR 0 4
5972: PUSH
5973: LD_INT 0
5975: EQUAL
5976: IFFALSE 6001
// ComExitBuilding ( ru2_sold [ Rand ( 1 , ru2_sold ) ] ) ;
5978: LD_EXP 36
5982: PUSH
5983: LD_INT 1
5985: PPUSH
5986: LD_EXP 36
5990: PPUSH
5991: CALL_OW 12
5995: ARRAY
5996: PPUSH
5997: CALL_OW 122
// if filter > 0 then
6001: LD_VAR 0 4
6005: PUSH
6006: LD_INT 0
6008: GREATER
6009: IFFALSE 6081
// for i = 1 to UnitFilter ( ru2_tw , [ f_empty ] ) do
6011: LD_ADDR_VAR 0 1
6015: PUSH
6016: DOUBLE
6017: LD_INT 1
6019: DEC
6020: ST_TO_ADDR
6021: LD_EXP 38
6025: PPUSH
6026: LD_INT 58
6028: PUSH
6029: EMPTY
6030: LIST
6031: PPUSH
6032: CALL_OW 72
6036: PUSH
6037: FOR_TO
6038: IFFALSE 6079
// ComEnterUnit ( filter [ i ] , UnitFilter ( ru2_tw , [ f_empty ] ) [ i ] ) ;
6040: LD_VAR 0 4
6044: PUSH
6045: LD_VAR 0 1
6049: ARRAY
6050: PPUSH
6051: LD_EXP 38
6055: PPUSH
6056: LD_INT 58
6058: PUSH
6059: EMPTY
6060: LIST
6061: PPUSH
6062: CALL_OW 72
6066: PUSH
6067: LD_VAR 0 1
6071: ARRAY
6072: PPUSH
6073: CALL_OW 120
6077: GO 6037
6079: POP
6080: POP
// end ; if UnitFilter ( ru2_tw , [ f_empty ] ) = 0 then
6081: LD_EXP 38
6085: PPUSH
6086: LD_INT 58
6088: PUSH
6089: EMPTY
6090: LIST
6091: PPUSH
6092: CALL_OW 72
6096: PUSH
6097: LD_INT 0
6099: EQUAL
6100: IFFALSE 6255
// begin b_unit := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
6102: LD_ADDR_VAR 0 7
6106: PUSH
6107: LD_INT 22
6109: PUSH
6110: LD_INT 3
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: PUSH
6117: LD_INT 2
6119: PUSH
6120: LD_INT 30
6122: PUSH
6123: LD_INT 4
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: PUSH
6130: LD_INT 30
6132: PUSH
6133: LD_INT 5
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: PPUSH
6149: CALL_OW 69
6153: ST_TO_ADDR
// if b_unit > 0 then
6154: LD_VAR 0 7
6158: PUSH
6159: LD_INT 0
6161: GREATER
6162: IFFALSE 6255
// for p = 1 to b_unit do
6164: LD_ADDR_VAR 0 2
6168: PUSH
6169: DOUBLE
6170: LD_INT 1
6172: DEC
6173: ST_TO_ADDR
6174: LD_VAR 0 7
6178: PUSH
6179: FOR_TO
6180: IFFALSE 6253
// if UnitsInSide ( b_unit [ p ] ) < 6 then
6182: LD_VAR 0 7
6186: PUSH
6187: LD_VAR 0 2
6191: ARRAY
6192: PPUSH
6193: CALL_OW 313
6197: PUSH
6198: LD_INT 6
6200: LESS
6201: IFFALSE 6251
// for i = 1 to filter do
6203: LD_ADDR_VAR 0 1
6207: PUSH
6208: DOUBLE
6209: LD_INT 1
6211: DEC
6212: ST_TO_ADDR
6213: LD_VAR 0 4
6217: PUSH
6218: FOR_TO
6219: IFFALSE 6249
// ComEnterUnit ( filter [ i ] , b_unit [ p ] ) ;
6221: LD_VAR 0 4
6225: PUSH
6226: LD_VAR 0 1
6230: ARRAY
6231: PPUSH
6232: LD_VAR 0 7
6236: PUSH
6237: LD_VAR 0 2
6241: ARRAY
6242: PPUSH
6243: CALL_OW 120
6247: GO 6218
6249: POP
6250: POP
6251: GO 6179
6253: POP
6254: POP
// end ; if UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) > 0 then
6255: LD_EXP 38
6259: PPUSH
6260: LD_INT 30
6262: PUSH
6263: LD_INT 32
6265: PUSH
6266: EMPTY
6267: LIST
6268: LIST
6269: PUSH
6270: LD_INT 35
6272: PUSH
6273: LD_INT 0
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: PPUSH
6284: CALL_OW 72
6288: PUSH
6289: LD_INT 0
6291: GREATER
6292: IFFALSE 6380
// begin filter := UnitFilter ( ru2_tw , [ [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ) ;
6294: LD_ADDR_VAR 0 4
6298: PUSH
6299: LD_EXP 38
6303: PPUSH
6304: LD_INT 30
6306: PUSH
6307: LD_INT 32
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 35
6316: PUSH
6317: LD_INT 0
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: PUSH
6324: EMPTY
6325: LIST
6326: LIST
6327: PPUSH
6328: CALL_OW 72
6332: ST_TO_ADDR
// if BuildingStatus ( b_fac ) = bs_idle then
6333: LD_VAR 0 10
6337: PPUSH
6338: CALL_OW 461
6342: PUSH
6343: LD_INT 2
6345: EQUAL
6346: IFFALSE 6380
// ComPlaceWeapon ( filter [ 1 ] , b_weap [ Rand ( 1 , b_weap ) ] ) ;
6348: LD_VAR 0 4
6352: PUSH
6353: LD_INT 1
6355: ARRAY
6356: PPUSH
6357: LD_VAR 0 8
6361: PUSH
6362: LD_INT 1
6364: PPUSH
6365: LD_VAR 0 8
6369: PPUSH
6370: CALL_OW 12
6374: ARRAY
6375: PPUSH
6376: CALL_OW 148
// end ; end ; if b_fac > 0 and ru2_mech > 0 then
6380: LD_VAR 0 10
6384: PUSH
6385: LD_INT 0
6387: GREATER
6388: PUSH
6389: LD_EXP 42
6393: PUSH
6394: LD_INT 0
6396: GREATER
6397: AND
6398: IFFALSE 6460
// for i = 1 to ru2_mech do
6400: LD_ADDR_VAR 0 1
6404: PUSH
6405: DOUBLE
6406: LD_INT 1
6408: DEC
6409: ST_TO_ADDR
6410: LD_EXP 42
6414: PUSH
6415: FOR_TO
6416: IFFALSE 6458
// if not IsInUnit ( ru2_mech [ i ] ) then
6418: LD_EXP 42
6422: PUSH
6423: LD_VAR 0 1
6427: ARRAY
6428: PPUSH
6429: CALL_OW 310
6433: NOT
6434: IFFALSE 6456
// ComEnterUnit ( ru2_mech [ i ] , b_fac ) ;
6436: LD_EXP 42
6440: PUSH
6441: LD_VAR 0 1
6445: ARRAY
6446: PPUSH
6447: LD_VAR 0 10
6451: PPUSH
6452: CALL_OW 120
6456: GO 6415
6458: POP
6459: POP
// if b_fac > 0 and ru2_veh > 0 then
6460: LD_VAR 0 10
6464: PUSH
6465: LD_INT 0
6467: GREATER
6468: PUSH
6469: LD_EXP 40
6473: PUSH
6474: LD_INT 0
6476: GREATER
6477: AND
6478: IFFALSE 6578
// if BuildingStatus ( b_fac ) = bs_idle then
6480: LD_VAR 0 10
6484: PPUSH
6485: CALL_OW 461
6489: PUSH
6490: LD_INT 2
6492: EQUAL
6493: IFFALSE 6578
// begin ComConstruct ( b_fac , ru2_veh [ 1 ] , ru2_veh [ 2 ] , ru2_veh [ 3 ] , ru2_veh [ 4 ] ) ;
6495: LD_VAR 0 10
6499: PPUSH
6500: LD_EXP 40
6504: PUSH
6505: LD_INT 1
6507: ARRAY
6508: PPUSH
6509: LD_EXP 40
6513: PUSH
6514: LD_INT 2
6516: ARRAY
6517: PPUSH
6518: LD_EXP 40
6522: PUSH
6523: LD_INT 3
6525: ARRAY
6526: PPUSH
6527: LD_EXP 40
6531: PUSH
6532: LD_INT 4
6534: ARRAY
6535: PPUSH
6536: CALL_OW 125
// for i = 1 to 4 do
6540: LD_ADDR_VAR 0 1
6544: PUSH
6545: DOUBLE
6546: LD_INT 1
6548: DEC
6549: ST_TO_ADDR
6550: LD_INT 4
6552: PUSH
6553: FOR_TO
6554: IFFALSE 6576
// ru2_veh := Delete ( ru2_veh , 1 ) ;
6556: LD_ADDR_EXP 40
6560: PUSH
6561: LD_EXP 40
6565: PPUSH
6566: LD_INT 1
6568: PPUSH
6569: CALL_OW 3
6573: ST_TO_ADDR
6574: GO 6553
6576: POP
6577: POP
// end ; for i = 1 to ru2_b do
6578: LD_ADDR_VAR 0 1
6582: PUSH
6583: DOUBLE
6584: LD_INT 1
6586: DEC
6587: ST_TO_ADDR
6588: LD_EXP 45
6592: PUSH
6593: FOR_TO
6594: IFFALSE 6782
// if BuildingStatus ( ru2_b [ i ] ) = bs_need_extension then
6596: LD_EXP 45
6600: PUSH
6601: LD_VAR 0 1
6605: ARRAY
6606: PPUSH
6607: CALL_OW 461
6611: PUSH
6612: LD_INT 8
6614: EQUAL
6615: IFFALSE 6780
// begin b_ext := GetExtPositions ( ru2_b [ i ] ) ;
6617: LD_ADDR_VAR 0 12
6621: PUSH
6622: LD_EXP 45
6626: PUSH
6627: LD_VAR 0 1
6631: ARRAY
6632: PPUSH
6633: CALL_OW 270
6637: ST_TO_ADDR
// if b_ext > 0 and not b_ext_gun in ru2_bul then
6638: LD_VAR 0 12
6642: PUSH
6643: LD_INT 0
6645: GREATER
6646: PUSH
6647: LD_INT 17
6649: PUSH
6650: LD_EXP 44
6654: IN
6655: NOT
6656: AND
6657: IFFALSE 6780
// ru2_bul := ru2_bul ^ [ b_ext_noncombat , b_ext [ 1 ] [ 1 ] , b_ext [ 1 ] [ 2 ] , 3 , b_ext_track , b_ext [ 2 ] [ 1 ] , b_ext [ 2 ] [ 2 ] , 5 , b_ext_gun , b_ext [ 3 ] [ 1 ] , b_ext [ 3 ] [ 2 ] , 2 ] ;
6659: LD_ADDR_EXP 44
6663: PUSH
6664: LD_EXP 44
6668: PUSH
6669: LD_INT 19
6671: PUSH
6672: LD_VAR 0 12
6676: PUSH
6677: LD_INT 1
6679: ARRAY
6680: PUSH
6681: LD_INT 1
6683: ARRAY
6684: PUSH
6685: LD_VAR 0 12
6689: PUSH
6690: LD_INT 1
6692: ARRAY
6693: PUSH
6694: LD_INT 2
6696: ARRAY
6697: PUSH
6698: LD_INT 3
6700: PUSH
6701: LD_INT 16
6703: PUSH
6704: LD_VAR 0 12
6708: PUSH
6709: LD_INT 2
6711: ARRAY
6712: PUSH
6713: LD_INT 1
6715: ARRAY
6716: PUSH
6717: LD_VAR 0 12
6721: PUSH
6722: LD_INT 2
6724: ARRAY
6725: PUSH
6726: LD_INT 2
6728: ARRAY
6729: PUSH
6730: LD_INT 5
6732: PUSH
6733: LD_INT 17
6735: PUSH
6736: LD_VAR 0 12
6740: PUSH
6741: LD_INT 3
6743: ARRAY
6744: PUSH
6745: LD_INT 1
6747: ARRAY
6748: PUSH
6749: LD_VAR 0 12
6753: PUSH
6754: LD_INT 3
6756: ARRAY
6757: PUSH
6758: LD_INT 2
6760: ARRAY
6761: PUSH
6762: LD_INT 2
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: LIST
6778: ADD
6779: ST_TO_ADDR
// end ;
6780: GO 6593
6782: POP
6783: POP
// if b_dmgunit > 0 then
6784: LD_VAR 0 6
6788: PUSH
6789: LD_INT 0
6791: GREATER
6792: IFFALSE 6977
// begin if ru2_eng > 0 then
6794: LD_EXP 41
6798: PUSH
6799: LD_INT 0
6801: GREATER
6802: IFFALSE 6882
// for i = 1 to ru2_eng do
6804: LD_ADDR_VAR 0 1
6808: PUSH
6809: DOUBLE
6810: LD_INT 1
6812: DEC
6813: ST_TO_ADDR
6814: LD_EXP 41
6818: PUSH
6819: FOR_TO
6820: IFFALSE 6880
// begin if IsInUnit ( ru2_eng [ i ] ) then
6822: LD_EXP 41
6826: PUSH
6827: LD_VAR 0 1
6831: ARRAY
6832: PPUSH
6833: CALL_OW 310
6837: IFFALSE 6854
// ComExitBuilding ( ru2_eng [ i ] ) ;
6839: LD_EXP 41
6843: PUSH
6844: LD_VAR 0 1
6848: ARRAY
6849: PPUSH
6850: CALL_OW 122
// ComRepairBuilding ( ru2_eng [ i ] , b_dmgunit [ 1 ] ) ;
6854: LD_EXP 41
6858: PUSH
6859: LD_VAR 0 1
6863: ARRAY
6864: PPUSH
6865: LD_VAR 0 6
6869: PUSH
6870: LD_INT 1
6872: ARRAY
6873: PPUSH
6874: CALL_OW 130
// end ;
6878: GO 6819
6880: POP
6881: POP
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) > 0 then
6882: LD_INT 22
6884: PUSH
6885: LD_INT 3
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: PUSH
6892: LD_INT 34
6894: PUSH
6895: LD_INT 52
6897: PUSH
6898: EMPTY
6899: LIST
6900: LIST
6901: PUSH
6902: EMPTY
6903: LIST
6904: LIST
6905: PPUSH
6906: CALL_OW 69
6910: PUSH
6911: LD_INT 0
6913: GREATER
6914: IFFALSE 6975
// for p in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_crane ] ] ) do
6916: LD_ADDR_VAR 0 2
6920: PUSH
6921: LD_INT 22
6923: PUSH
6924: LD_INT 3
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 34
6933: PUSH
6934: LD_INT 52
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PPUSH
6945: CALL_OW 69
6949: PUSH
6950: FOR_IN
6951: IFFALSE 6973
// ComRepairBuilding ( p , b_dmgunit [ 1 ] ) ;
6953: LD_VAR 0 2
6957: PPUSH
6958: LD_VAR 0 6
6962: PUSH
6963: LD_INT 1
6965: ARRAY
6966: PPUSH
6967: CALL_OW 130
6971: GO 6950
6973: POP
6974: POP
// end else
6975: GO 7105
// if ru2_bul = 0 then
6977: LD_EXP 44
6981: PUSH
6982: LD_INT 0
6984: EQUAL
6985: IFFALSE 7105
// for i = 1 to ru2_eng do
6987: LD_ADDR_VAR 0 1
6991: PUSH
6992: DOUBLE
6993: LD_INT 1
6995: DEC
6996: ST_TO_ADDR
6997: LD_EXP 41
7001: PUSH
7002: FOR_TO
7003: IFFALSE 7103
// if not HasTask ( ru2_eng [ i ] ) then
7005: LD_EXP 41
7009: PUSH
7010: LD_VAR 0 1
7014: ARRAY
7015: PPUSH
7016: CALL_OW 314
7020: NOT
7021: IFFALSE 7101
// ComEnterUnit ( ru2_eng [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , ru2_eng [ i ] ) ) ;
7023: LD_EXP 41
7027: PUSH
7028: LD_VAR 0 1
7032: ARRAY
7033: PPUSH
7034: LD_INT 22
7036: PUSH
7037: LD_INT 3
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PUSH
7044: LD_INT 2
7046: PUSH
7047: LD_INT 30
7049: PUSH
7050: LD_INT 0
7052: PUSH
7053: EMPTY
7054: LIST
7055: LIST
7056: PUSH
7057: LD_INT 30
7059: PUSH
7060: LD_INT 1
7062: PUSH
7063: EMPTY
7064: LIST
7065: LIST
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: LIST
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PPUSH
7076: CALL_OW 69
7080: PPUSH
7081: LD_EXP 41
7085: PUSH
7086: LD_VAR 0 1
7090: ARRAY
7091: PPUSH
7092: CALL_OW 74
7096: PPUSH
7097: CALL_OW 120
7101: GO 7002
7103: POP
7104: POP
// if b_labb > 0 then
7105: LD_VAR 0 11
7109: PUSH
7110: LD_INT 0
7112: GREATER
7113: IFFALSE 7463
// begin if h_dmgunit > 0 then
7115: LD_VAR 0 5
7119: PUSH
7120: LD_INT 0
7122: GREATER
7123: IFFALSE 7332
// begin for p = 1 to h_dmgunit do
7125: LD_ADDR_VAR 0 2
7129: PUSH
7130: DOUBLE
7131: LD_INT 1
7133: DEC
7134: ST_TO_ADDR
7135: LD_VAR 0 5
7139: PUSH
7140: FOR_TO
7141: IFFALSE 7192
// if GetDistUnits ( h_dmgunit [ p ] , b_labb ) > 6 then
7143: LD_VAR 0 5
7147: PUSH
7148: LD_VAR 0 2
7152: ARRAY
7153: PPUSH
7154: LD_VAR 0 11
7158: PPUSH
7159: CALL_OW 296
7163: PUSH
7164: LD_INT 6
7166: GREATER
7167: IFFALSE 7190
// ComMoveXY ( h_dmgunit [ p ] , 95 , 72 ) ;
7169: LD_VAR 0 5
7173: PUSH
7174: LD_VAR 0 2
7178: ARRAY
7179: PPUSH
7180: LD_INT 95
7182: PPUSH
7183: LD_INT 72
7185: PPUSH
7186: CALL_OW 111
7190: GO 7140
7192: POP
7193: POP
// if ru2_sci > 0 then
7194: LD_EXP 43
7198: PUSH
7199: LD_INT 0
7201: GREATER
7202: IFFALSE 7332
// for i = 1 to ru2_sci do
7204: LD_ADDR_VAR 0 1
7208: PUSH
7209: DOUBLE
7210: LD_INT 1
7212: DEC
7213: ST_TO_ADDR
7214: LD_EXP 43
7218: PUSH
7219: FOR_TO
7220: IFFALSE 7330
// if IsInUnit ( ru2_sci [ i ] ) then
7222: LD_EXP 43
7226: PUSH
7227: LD_VAR 0 1
7231: ARRAY
7232: PPUSH
7233: CALL_OW 310
7237: IFFALSE 7256
// ComExitBuilding ( ru2_sci [ i ] ) else
7239: LD_EXP 43
7243: PUSH
7244: LD_VAR 0 1
7248: ARRAY
7249: PPUSH
7250: CALL_OW 122
7254: GO 7328
// if not HasTask ( ru2_sci [ i ] ) then
7256: LD_EXP 43
7260: PUSH
7261: LD_VAR 0 1
7265: ARRAY
7266: PPUSH
7267: CALL_OW 314
7271: NOT
7272: IFFALSE 7328
// if GetDistUnits ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) <= 15 then
7274: LD_EXP 43
7278: PUSH
7279: LD_VAR 0 1
7283: ARRAY
7284: PPUSH
7285: LD_VAR 0 5
7289: PUSH
7290: LD_INT 1
7292: ARRAY
7293: PPUSH
7294: CALL_OW 296
7298: PUSH
7299: LD_INT 15
7301: LESSEQUAL
7302: IFFALSE 7328
// ComHeal ( ru2_sci [ i ] , h_dmgunit [ 1 ] ) ;
7304: LD_EXP 43
7308: PUSH
7309: LD_VAR 0 1
7313: ARRAY
7314: PPUSH
7315: LD_VAR 0 5
7319: PUSH
7320: LD_INT 1
7322: ARRAY
7323: PPUSH
7324: CALL_OW 128
7328: GO 7219
7330: POP
7331: POP
// end ; if h_dmgunit = 0 then
7332: LD_VAR 0 5
7336: PUSH
7337: LD_INT 0
7339: EQUAL
7340: IFFALSE 7463
// begin for i = 1 to ru2_sci do
7342: LD_ADDR_VAR 0 1
7346: PUSH
7347: DOUBLE
7348: LD_INT 1
7350: DEC
7351: ST_TO_ADDR
7352: LD_EXP 43
7356: PUSH
7357: FOR_TO
7358: IFFALSE 7400
// if not IsInUnit ( ru2_sci [ i ] ) then
7360: LD_EXP 43
7364: PUSH
7365: LD_VAR 0 1
7369: ARRAY
7370: PPUSH
7371: CALL_OW 310
7375: NOT
7376: IFFALSE 7398
// ComEnterUnit ( ru2_sci [ i ] , b_labb ) ;
7378: LD_EXP 43
7382: PUSH
7383: LD_VAR 0 1
7387: ARRAY
7388: PPUSH
7389: LD_VAR 0 11
7393: PPUSH
7394: CALL_OW 120
7398: GO 7357
7400: POP
7401: POP
// if ru2_tech > 0 then
7402: LD_EXP 39
7406: PUSH
7407: LD_INT 0
7409: GREATER
7410: IFFALSE 7463
// if BuildingStatus ( b_labb ) = bs_idle then
7412: LD_VAR 0 11
7416: PPUSH
7417: CALL_OW 461
7421: PUSH
7422: LD_INT 2
7424: EQUAL
7425: IFFALSE 7463
// begin ComResearch ( b_labb , ru2_tech [ 1 ] ) ;
7427: LD_VAR 0 11
7431: PPUSH
7432: LD_EXP 39
7436: PUSH
7437: LD_INT 1
7439: ARRAY
7440: PPUSH
7441: CALL_OW 124
// ru2_tech := Delete ( ru2_tech , 1 ) ;
7445: LD_ADDR_EXP 39
7449: PUSH
7450: LD_EXP 39
7454: PPUSH
7455: LD_INT 1
7457: PPUSH
7458: CALL_OW 3
7462: ST_TO_ADDR
// end ; end ; end ; end ;
7463: PPOPN 13
7465: END
// every 0 0$03 trigger beria and kirov do
7466: LD_INT 106
7468: PUSH
7469: LD_INT 71
7471: AND
7472: IFFALSE 7530
7474: GO 7476
7476: DISABLE
// begin enable ;
7477: ENABLE
// SetResourceType ( beria , mat_cans , 10000 ) ;
7478: LD_INT 106
7480: PPUSH
7481: LD_INT 1
7483: PPUSH
7484: LD_INT 10000
7486: PPUSH
7487: CALL_OW 277
// SetResourceType ( beria , mat_oil , 10000 ) ;
7491: LD_INT 106
7493: PPUSH
7494: LD_INT 2
7496: PPUSH
7497: LD_INT 10000
7499: PPUSH
7500: CALL_OW 277
// SetResourceType ( kirov , mat_cans , 10000 ) ;
7504: LD_INT 71
7506: PPUSH
7507: LD_INT 1
7509: PPUSH
7510: LD_INT 10000
7512: PPUSH
7513: CALL_OW 277
// SetResourceType ( kirov , mat_oil , 10000 ) ;
7517: LD_INT 71
7519: PPUSH
7520: LD_INT 2
7522: PPUSH
7523: LD_INT 10000
7525: PPUSH
7526: CALL_OW 277
// end ;
7530: END
// every 0 0$01 trigger russian_produce do
7531: LD_EXP 18
7535: IFFALSE 7984
7537: GO 7539
7539: DISABLE
// begin case global_diff of 1 :
7540: LD_EXP 2
7544: PUSH
7545: LD_INT 1
7547: DOUBLE
7548: EQUAL
7549: IFTRUE 7553
7551: GO 7617
7553: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
7554: LD_ADDR_EXP 30
7558: PUSH
7559: LD_EXP 30
7563: PUSH
7564: LD_INT 21
7566: PUSH
7567: LD_INT 1
7569: PUSH
7570: LD_INT 1
7572: PUSH
7573: LD_INT 42
7575: PUSH
7576: LD_INT 21
7578: PUSH
7579: LD_INT 1
7581: PUSH
7582: LD_INT 1
7584: PUSH
7585: LD_INT 42
7587: PUSH
7588: LD_INT 21
7590: PUSH
7591: LD_INT 1
7593: PUSH
7594: LD_INT 1
7596: PUSH
7597: LD_INT 43
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: LIST
7607: LIST
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: ADD
7614: ST_TO_ADDR
7615: GO 7762
7617: LD_INT 2
7619: DOUBLE
7620: EQUAL
7621: IFTRUE 7625
7623: GO 7689
7625: POP
// ru_veh := ru_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
7626: LD_ADDR_EXP 30
7630: PUSH
7631: LD_EXP 30
7635: PUSH
7636: LD_INT 21
7638: PUSH
7639: LD_INT 1
7641: PUSH
7642: LD_INT 1
7644: PUSH
7645: LD_INT 44
7647: PUSH
7648: LD_INT 22
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 1
7656: PUSH
7657: LD_INT 42
7659: PUSH
7660: LD_INT 22
7662: PUSH
7663: LD_INT 1
7665: PUSH
7666: LD_INT 1
7668: PUSH
7669: LD_INT 43
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: ADD
7686: ST_TO_ADDR
7687: GO 7762
7689: LD_INT 3
7691: DOUBLE
7692: EQUAL
7693: IFTRUE 7697
7695: GO 7761
7697: POP
// ru_veh := ru_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun ] ; end ;
7698: LD_ADDR_EXP 30
7702: PUSH
7703: LD_EXP 30
7707: PUSH
7708: LD_INT 23
7710: PUSH
7711: LD_INT 1
7713: PUSH
7714: LD_INT 1
7716: PUSH
7717: LD_INT 43
7719: PUSH
7720: LD_INT 22
7722: PUSH
7723: LD_INT 1
7725: PUSH
7726: LD_INT 1
7728: PUSH
7729: LD_INT 44
7731: PUSH
7732: LD_INT 22
7734: PUSH
7735: LD_INT 1
7737: PUSH
7738: LD_INT 1
7740: PUSH
7741: LD_INT 44
7743: PUSH
7744: EMPTY
7745: LIST
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: ADD
7758: ST_TO_ADDR
7759: GO 7762
7761: POP
// case global_diff of 1 :
7762: LD_EXP 2
7766: PUSH
7767: LD_INT 1
7769: DOUBLE
7770: EQUAL
7771: IFTRUE 7775
7773: GO 7839
7775: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ; 2 :
7776: LD_ADDR_EXP 40
7780: PUSH
7781: LD_EXP 40
7785: PUSH
7786: LD_INT 21
7788: PUSH
7789: LD_INT 1
7791: PUSH
7792: LD_INT 1
7794: PUSH
7795: LD_INT 42
7797: PUSH
7798: LD_INT 21
7800: PUSH
7801: LD_INT 1
7803: PUSH
7804: LD_INT 1
7806: PUSH
7807: LD_INT 42
7809: PUSH
7810: LD_INT 21
7812: PUSH
7813: LD_INT 1
7815: PUSH
7816: LD_INT 1
7818: PUSH
7819: LD_INT 43
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: LIST
7826: LIST
7827: LIST
7828: LIST
7829: LIST
7830: LIST
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: ADD
7836: ST_TO_ADDR
7837: GO 7984
7839: LD_INT 2
7841: DOUBLE
7842: EQUAL
7843: IFTRUE 7847
7845: GO 7911
7847: POP
// ru2_veh := ru2_veh ^ [ ru_medium_wheeled , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ; 3 :
7848: LD_ADDR_EXP 40
7852: PUSH
7853: LD_EXP 40
7857: PUSH
7858: LD_INT 21
7860: PUSH
7861: LD_INT 1
7863: PUSH
7864: LD_INT 1
7866: PUSH
7867: LD_INT 44
7869: PUSH
7870: LD_INT 22
7872: PUSH
7873: LD_INT 1
7875: PUSH
7876: LD_INT 1
7878: PUSH
7879: LD_INT 44
7881: PUSH
7882: LD_INT 22
7884: PUSH
7885: LD_INT 1
7887: PUSH
7888: LD_INT 1
7890: PUSH
7891: LD_INT 43
7893: PUSH
7894: EMPTY
7895: LIST
7896: LIST
7897: LIST
7898: LIST
7899: LIST
7900: LIST
7901: LIST
7902: LIST
7903: LIST
7904: LIST
7905: LIST
7906: LIST
7907: ADD
7908: ST_TO_ADDR
7909: GO 7984
7911: LD_INT 3
7913: DOUBLE
7914: EQUAL
7915: IFTRUE 7919
7917: GO 7983
7919: POP
// ru2_veh := ru2_veh ^ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun , ru_medium_tracked , engine_combustion , control_manual , ru_gun ] ; end ;
7920: LD_ADDR_EXP 40
7924: PUSH
7925: LD_EXP 40
7929: PUSH
7930: LD_INT 23
7932: PUSH
7933: LD_INT 1
7935: PUSH
7936: LD_INT 1
7938: PUSH
7939: LD_INT 42
7941: PUSH
7942: LD_INT 22
7944: PUSH
7945: LD_INT 1
7947: PUSH
7948: LD_INT 1
7950: PUSH
7951: LD_INT 44
7953: PUSH
7954: LD_INT 22
7956: PUSH
7957: LD_INT 1
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: LD_INT 44
7965: PUSH
7966: EMPTY
7967: LIST
7968: LIST
7969: LIST
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: LIST
7975: LIST
7976: LIST
7977: LIST
7978: LIST
7979: ADD
7980: ST_TO_ADDR
7981: GO 7984
7983: POP
// end ;
7984: END
// every 0 0$04 trigger attack_omicron and FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) do var filter , enemy , i ;
7985: LD_EXP 23
7989: PUSH
7990: LD_INT 2
7992: PUSH
7993: LD_INT 22
7995: PUSH
7996: LD_INT 3
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: LD_INT 22
8005: PUSH
8006: LD_INT 6
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: LIST
8017: PUSH
8018: LD_INT 21
8020: PUSH
8021: LD_INT 2
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 3
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 34
8036: PUSH
8037: LD_INT 52
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: PUSH
8044: LD_INT 34
8046: PUSH
8047: LD_INT 51
8049: PUSH
8050: EMPTY
8051: LIST
8052: LIST
8053: PUSH
8054: LD_INT 34
8056: PUSH
8057: LD_INT 53
8059: PUSH
8060: EMPTY
8061: LIST
8062: LIST
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: LIST
8068: LIST
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: LIST
8078: PPUSH
8079: CALL_OW 69
8083: AND
8084: IFFALSE 8320
8086: GO 8088
8088: DISABLE
8089: LD_INT 0
8091: PPUSH
8092: PPUSH
8093: PPUSH
// begin enable ;
8094: ENABLE
// filter := FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] ] ] ] ) ;
8095: LD_ADDR_VAR 0 1
8099: PUSH
8100: LD_INT 2
8102: PUSH
8103: LD_INT 22
8105: PUSH
8106: LD_INT 3
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: PUSH
8113: LD_INT 22
8115: PUSH
8116: LD_INT 6
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: LIST
8127: PUSH
8128: LD_INT 21
8130: PUSH
8131: LD_INT 2
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 3
8140: PUSH
8141: LD_INT 2
8143: PUSH
8144: LD_INT 34
8146: PUSH
8147: LD_INT 52
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PUSH
8154: LD_INT 34
8156: PUSH
8157: LD_INT 51
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: PUSH
8164: LD_INT 34
8166: PUSH
8167: LD_INT 53
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PUSH
8174: EMPTY
8175: LIST
8176: LIST
8177: LIST
8178: LIST
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: LIST
8188: PPUSH
8189: CALL_OW 69
8193: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_side , 1 ] ) ;
8194: LD_ADDR_VAR 0 2
8198: PUSH
8199: LD_INT 22
8201: PUSH
8202: LD_INT 1
8204: PUSH
8205: EMPTY
8206: LIST
8207: LIST
8208: PPUSH
8209: CALL_OW 69
8213: ST_TO_ADDR
// if enemy = 0 or IsDead ( kurin ) then
8214: LD_VAR 0 2
8218: PUSH
8219: LD_INT 0
8221: EQUAL
8222: PUSH
8223: LD_EXP 13
8227: PPUSH
8228: CALL_OW 301
8232: OR
8233: IFFALSE 8255
// enemy := FilterAllUnits ( [ f_side , 2 ] ) ;
8235: LD_ADDR_VAR 0 2
8239: PUSH
8240: LD_INT 22
8242: PUSH
8243: LD_INT 2
8245: PUSH
8246: EMPTY
8247: LIST
8248: LIST
8249: PPUSH
8250: CALL_OW 69
8254: ST_TO_ADDR
// for i = 1 to filter do
8255: LD_ADDR_VAR 0 3
8259: PUSH
8260: DOUBLE
8261: LD_INT 1
8263: DEC
8264: ST_TO_ADDR
8265: LD_VAR 0 1
8269: PUSH
8270: FOR_TO
8271: IFFALSE 8318
// begin ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
8273: LD_VAR 0 1
8277: PUSH
8278: LD_VAR 0 3
8282: ARRAY
8283: PPUSH
8284: LD_VAR 0 2
8288: PPUSH
8289: LD_VAR 0 1
8293: PUSH
8294: LD_VAR 0 3
8298: ARRAY
8299: PPUSH
8300: CALL_OW 74
8304: PPUSH
8305: CALL_OW 115
// Wait ( 0 0$01 ) ;
8309: LD_INT 35
8311: PPUSH
8312: CALL_OW 67
// end ;
8316: GO 8270
8318: POP
8319: POP
// end ;
8320: PPOPN 3
8322: END
// export function RusSpecForce ; var i , un ; begin
8323: LD_INT 0
8325: PPUSH
8326: PPUSH
8327: PPUSH
// uc_side := 3 ;
8328: LD_ADDR_OWVAR 20
8332: PUSH
8333: LD_INT 3
8335: ST_TO_ADDR
// uc_nation := 3 ;
8336: LD_ADDR_OWVAR 21
8340: PUSH
8341: LD_INT 3
8343: ST_TO_ADDR
// for i = 1 to 5 do
8344: LD_ADDR_VAR 0 2
8348: PUSH
8349: DOUBLE
8350: LD_INT 1
8352: DEC
8353: ST_TO_ADDR
8354: LD_INT 5
8356: PUSH
8357: FOR_TO
8358: IFFALSE 8429
// begin un := CreateHumanWithClass ( 3 , ru_def ) ;
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_INT 3
8367: PPUSH
8368: LD_EXP 4
8372: PPUSH
8373: CALL 418 0 2
8377: ST_TO_ADDR
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) [ 1 ] ) ;
8378: LD_VAR 0 3
8382: PPUSH
8383: LD_INT 22
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: PUSH
8393: LD_INT 21
8395: PUSH
8396: LD_INT 2
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PUSH
8403: LD_INT 58
8405: PUSH
8406: EMPTY
8407: LIST
8408: PUSH
8409: EMPTY
8410: LIST
8411: LIST
8412: LIST
8413: PPUSH
8414: CALL_OW 69
8418: PUSH
8419: LD_INT 1
8421: ARRAY
8422: PPUSH
8423: CALL_OW 52
// end ;
8427: GO 8357
8429: POP
8430: POP
// end ; end_of_file
8431: LD_VAR 0 1
8435: RET
// export function PrepareHeike ; begin
8436: LD_INT 0
8438: PPUSH
// uc_side := 2 ;
8439: LD_ADDR_OWVAR 20
8443: PUSH
8444: LD_INT 2
8446: ST_TO_ADDR
// uc_nation := 2 ;
8447: LD_ADDR_OWVAR 21
8451: PUSH
8452: LD_INT 2
8454: ST_TO_ADDR
// hc_gallery := sandar ;
8455: LD_ADDR_OWVAR 33
8459: PUSH
8460: LD_STRING sandar
8462: ST_TO_ADDR
// hc_face_number := 2 ;
8463: LD_ADDR_OWVAR 34
8467: PUSH
8468: LD_INT 2
8470: ST_TO_ADDR
// hc_name := Heike Steyer ;
8471: LD_ADDR_OWVAR 26
8475: PUSH
8476: LD_STRING Heike Steyer
8478: ST_TO_ADDR
// hc_sex := sex_female ;
8479: LD_ADDR_OWVAR 27
8483: PUSH
8484: LD_INT 2
8486: ST_TO_ADDR
// hc_skills := [ 7 , 3 , 4 , 2 ] ;
8487: LD_ADDR_OWVAR 31
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 3
8497: PUSH
8498: LD_INT 4
8500: PUSH
8501: LD_INT 2
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: LIST
8508: LIST
8509: ST_TO_ADDR
// hc_class := 1 ;
8510: LD_ADDR_OWVAR 28
8514: PUSH
8515: LD_INT 1
8517: ST_TO_ADDR
// hc_importance := 100 ;
8518: LD_ADDR_OWVAR 32
8522: PUSH
8523: LD_INT 100
8525: ST_TO_ADDR
// heike := CreateHuman ;
8526: LD_ADDR_EXP 14
8530: PUSH
8531: CALL_OW 44
8535: ST_TO_ADDR
// hc_gallery := sandar ;
8536: LD_ADDR_OWVAR 33
8540: PUSH
8541: LD_STRING sandar
8543: ST_TO_ADDR
// hc_face_number := 25 ;
8544: LD_ADDR_OWVAR 34
8548: PUSH
8549: LD_INT 25
8551: ST_TO_ADDR
// hc_name := Olaf Larsson ;
8552: LD_ADDR_OWVAR 26
8556: PUSH
8557: LD_STRING Olaf Larsson
8559: ST_TO_ADDR
// hc_sex := sex_male ;
8560: LD_ADDR_OWVAR 27
8564: PUSH
8565: LD_INT 1
8567: ST_TO_ADDR
// hc_skills := [ 2 , 4 , 6 , 3 ] ;
8568: LD_ADDR_OWVAR 31
8572: PUSH
8573: LD_INT 2
8575: PUSH
8576: LD_INT 4
8578: PUSH
8579: LD_INT 6
8581: PUSH
8582: LD_INT 3
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: ST_TO_ADDR
// hc_class := 3 ;
8591: LD_ADDR_OWVAR 28
8595: PUSH
8596: LD_INT 3
8598: ST_TO_ADDR
// hc_importance := 0 ;
8599: LD_ADDR_OWVAR 32
8603: PUSH
8604: LD_INT 0
8606: ST_TO_ADDR
// olaf := CreateHuman ;
8607: LD_ADDR_EXP 17
8611: PUSH
8612: CALL_OW 44
8616: ST_TO_ADDR
// hc_gallery := us ;
8617: LD_ADDR_OWVAR 33
8621: PUSH
8622: LD_STRING us
8624: ST_TO_ADDR
// hc_face_number := 18 ;
8625: LD_ADDR_OWVAR 34
8629: PUSH
8630: LD_INT 18
8632: ST_TO_ADDR
// hc_name := Kurt Schmidt ;
8633: LD_ADDR_OWVAR 26
8637: PUSH
8638: LD_STRING Kurt Schmidt
8640: ST_TO_ADDR
// hc_sex := sex_male ;
8641: LD_ADDR_OWVAR 27
8645: PUSH
8646: LD_INT 1
8648: ST_TO_ADDR
// hc_skills := [ 5 , 1 , 2 , 0 ] ;
8649: LD_ADDR_OWVAR 31
8653: PUSH
8654: LD_INT 5
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 2
8662: PUSH
8663: LD_INT 0
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: ST_TO_ADDR
// hc_class := 1 ;
8672: LD_ADDR_OWVAR 28
8676: PUSH
8677: LD_INT 1
8679: ST_TO_ADDR
// kurt := CreateHuman ;
8680: LD_ADDR_EXP 16
8684: PUSH
8685: CALL_OW 44
8689: ST_TO_ADDR
// end ;
8690: LD_VAR 0 1
8694: RET
// export ar_vehs ; export function PrepareArabian ; var i , un ; begin
8695: LD_INT 0
8697: PPUSH
8698: PPUSH
8699: PPUSH
// ar_force := [ ] ;
8700: LD_ADDR_EXP 8
8704: PUSH
8705: EMPTY
8706: ST_TO_ADDR
// ar_vehs := [ ] ;
8707: LD_ADDR_EXP 47
8711: PUSH
8712: EMPTY
8713: ST_TO_ADDR
// uc_side := 2 ;
8714: LD_ADDR_OWVAR 20
8718: PUSH
8719: LD_INT 2
8721: ST_TO_ADDR
// uc_nation := nation_arabian ;
8722: LD_ADDR_OWVAR 21
8726: PUSH
8727: LD_INT 2
8729: ST_TO_ADDR
// for i = 1 to 2 do
8730: LD_ADDR_VAR 0 2
8734: PUSH
8735: DOUBLE
8736: LD_INT 1
8738: DEC
8739: ST_TO_ADDR
8740: LD_INT 2
8742: PUSH
8743: FOR_TO
8744: IFFALSE 8793
// SetCargo ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ru_cargo_bay ] ] ) [ i ] , mat_oil , 100 ) ;
8746: LD_INT 22
8748: PUSH
8749: LD_INT 2
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: PUSH
8756: LD_INT 34
8758: PUSH
8759: LD_INT 51
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: PPUSH
8770: CALL_OW 69
8774: PUSH
8775: LD_VAR 0 2
8779: ARRAY
8780: PPUSH
8781: LD_INT 2
8783: PPUSH
8784: LD_INT 100
8786: PPUSH
8787: CALL_OW 290
8791: GO 8743
8793: POP
8794: POP
// for i = 1 to [ 4 , 4 , 3 ] [ global_diff ] do
8795: LD_ADDR_VAR 0 2
8799: PUSH
8800: DOUBLE
8801: LD_INT 1
8803: DEC
8804: ST_TO_ADDR
8805: LD_INT 4
8807: PUSH
8808: LD_INT 4
8810: PUSH
8811: LD_INT 3
8813: PUSH
8814: EMPTY
8815: LIST
8816: LIST
8817: LIST
8818: PUSH
8819: LD_EXP 2
8823: ARRAY
8824: PUSH
8825: FOR_TO
8826: IFFALSE 8887
// begin un := CreateHumanWithClass ( [ class_soldier , class_mortar , class_mortar ] [ Rand ( 1 , 3 ) ] , ar_def ) ;
8828: LD_ADDR_VAR 0 3
8832: PUSH
8833: LD_INT 1
8835: PUSH
8836: LD_INT 8
8838: PUSH
8839: LD_INT 8
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: LIST
8846: PUSH
8847: LD_INT 1
8849: PPUSH
8850: LD_INT 3
8852: PPUSH
8853: CALL_OW 12
8857: ARRAY
8858: PPUSH
8859: LD_EXP 7
8863: PPUSH
8864: CALL 418 0 2
8868: ST_TO_ADDR
// ar_force := ar_force ^ un ;
8869: LD_ADDR_EXP 8
8873: PUSH
8874: LD_EXP 8
8878: PUSH
8879: LD_VAR 0 3
8883: ADD
8884: ST_TO_ADDR
// end ;
8885: GO 8825
8887: POP
8888: POP
// for i = 1 to 2 do
8889: LD_ADDR_VAR 0 2
8893: PUSH
8894: DOUBLE
8895: LD_INT 1
8897: DEC
8898: ST_TO_ADDR
8899: LD_INT 2
8901: PUSH
8902: FOR_TO
8903: IFFALSE 8941
// begin un := CreateHumanWithClass ( 4 , ar_def ) ;
8905: LD_ADDR_VAR 0 3
8909: PUSH
8910: LD_INT 4
8912: PPUSH
8913: LD_EXP 7
8917: PPUSH
8918: CALL 418 0 2
8922: ST_TO_ADDR
// ar_force := ar_force ^ un ;
8923: LD_ADDR_EXP 8
8927: PUSH
8928: LD_EXP 8
8932: PUSH
8933: LD_VAR 0 3
8937: ADD
8938: ST_TO_ADDR
// end ;
8939: GO 8902
8941: POP
8942: POP
// for i = 1 to 4 do
8943: LD_ADDR_VAR 0 2
8947: PUSH
8948: DOUBLE
8949: LD_INT 1
8951: DEC
8952: ST_TO_ADDR
8953: LD_INT 4
8955: PUSH
8956: FOR_TO
8957: IFFALSE 9091
// begin un := CreateHumanWithClass ( 3 , ar_def ) ;
8959: LD_ADDR_VAR 0 3
8963: PUSH
8964: LD_INT 3
8966: PPUSH
8967: LD_EXP 7
8971: PPUSH
8972: CALL 418 0 2
8976: ST_TO_ADDR
// ar_vehs := ar_vehs ^ un ;
8977: LD_ADDR_EXP 47
8981: PUSH
8982: LD_EXP 47
8986: PUSH
8987: LD_VAR 0 3
8991: ADD
8992: ST_TO_ADDR
// vc_chassis := [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
8993: LD_ADDR_OWVAR 37
8997: PUSH
8998: LD_INT 13
9000: PUSH
9001: LD_INT 14
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: LD_INT 1
9010: PPUSH
9011: LD_INT 2
9013: PPUSH
9014: CALL_OW 12
9018: ARRAY
9019: ST_TO_ADDR
// vc_engine := engine_combustion ;
9020: LD_ADDR_OWVAR 39
9024: PUSH
9025: LD_INT 1
9027: ST_TO_ADDR
// vc_control := control_manual ;
9028: LD_ADDR_OWVAR 38
9032: PUSH
9033: LD_INT 1
9035: ST_TO_ADDR
// vc_weapon := [ ar_gun , ar_flame_thrower ] [ Rand ( 1 , 2 ) ] ;
9036: LD_ADDR_OWVAR 40
9040: PUSH
9041: LD_INT 27
9043: PUSH
9044: LD_INT 26
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: PUSH
9051: LD_INT 1
9053: PPUSH
9054: LD_INT 2
9056: PPUSH
9057: CALL_OW 12
9061: ARRAY
9062: ST_TO_ADDR
// un := CreateVehicle ;
9063: LD_ADDR_VAR 0 3
9067: PUSH
9068: CALL_OW 45
9072: ST_TO_ADDR
// ar_force := ar_force ^ un ;
9073: LD_ADDR_EXP 8
9077: PUSH
9078: LD_EXP 8
9082: PUSH
9083: LD_VAR 0 3
9087: ADD
9088: ST_TO_ADDR
// end ;
9089: GO 8956
9091: POP
9092: POP
// end ;
9093: LD_VAR 0 1
9097: RET
// export omar_force ; export function PrepareOmarForce ; var i , un , v ; begin
9098: LD_INT 0
9100: PPUSH
9101: PPUSH
9102: PPUSH
9103: PPUSH
// omar_force := [ ] ;
9104: LD_ADDR_EXP 48
9108: PUSH
9109: EMPTY
9110: ST_TO_ADDR
// uc_side := 5 ;
9111: LD_ADDR_OWVAR 20
9115: PUSH
9116: LD_INT 5
9118: ST_TO_ADDR
// uc_nation := nation_arabian ;
9119: LD_ADDR_OWVAR 21
9123: PUSH
9124: LD_INT 2
9126: ST_TO_ADDR
// for i = 1 to 2 do
9127: LD_ADDR_VAR 0 2
9131: PUSH
9132: DOUBLE
9133: LD_INT 1
9135: DEC
9136: ST_TO_ADDR
9137: LD_INT 2
9139: PUSH
9140: FOR_TO
9141: IFFALSE 9239
// begin Wait ( 0 0$02 ) ;
9143: LD_INT 70
9145: PPUSH
9146: CALL_OW 67
// un := CreateHumanWithClass ( [ class_soldier , class_mortar , class_mortar ] [ Rand ( 1 , 3 ) ] , ar_def ) ;
9150: LD_ADDR_VAR 0 3
9154: PUSH
9155: LD_INT 1
9157: PUSH
9158: LD_INT 8
9160: PUSH
9161: LD_INT 8
9163: PUSH
9164: EMPTY
9165: LIST
9166: LIST
9167: LIST
9168: PUSH
9169: LD_INT 1
9171: PPUSH
9172: LD_INT 3
9174: PPUSH
9175: CALL_OW 12
9179: ARRAY
9180: PPUSH
9181: LD_EXP 7
9185: PPUSH
9186: CALL 418 0 2
9190: ST_TO_ADDR
// omar_force := omar_force ^ un ;
9191: LD_ADDR_EXP 48
9195: PUSH
9196: LD_EXP 48
9200: PUSH
9201: LD_VAR 0 3
9205: ADD
9206: ST_TO_ADDR
// PlaceUnitArea ( un , south_spawn , false ) ;
9207: LD_VAR 0 3
9211: PPUSH
9212: LD_INT 10
9214: PPUSH
9215: LD_INT 0
9217: PPUSH
9218: CALL_OW 49
// ComMoveXY ( un , 186 , 126 ) ;
9222: LD_VAR 0 3
9226: PPUSH
9227: LD_INT 186
9229: PPUSH
9230: LD_INT 126
9232: PPUSH
9233: CALL_OW 111
// end ;
9237: GO 9140
9239: POP
9240: POP
// for i = 1 to 3 do
9241: LD_ADDR_VAR 0 2
9245: PUSH
9246: DOUBLE
9247: LD_INT 1
9249: DEC
9250: ST_TO_ADDR
9251: LD_INT 3
9253: PUSH
9254: FOR_TO
9255: IFFALSE 9408
// begin Wait ( 0 0$03 ) ;
9257: LD_INT 105
9259: PPUSH
9260: CALL_OW 67
// un := CreateHumanWithClass ( 3 , ar_def ) ;
9264: LD_ADDR_VAR 0 3
9268: PUSH
9269: LD_INT 3
9271: PPUSH
9272: LD_EXP 7
9276: PPUSH
9277: CALL 418 0 2
9281: ST_TO_ADDR
// vc_chassis := [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
9282: LD_ADDR_OWVAR 37
9286: PUSH
9287: LD_INT 13
9289: PUSH
9290: LD_INT 14
9292: PUSH
9293: EMPTY
9294: LIST
9295: LIST
9296: PUSH
9297: LD_INT 1
9299: PPUSH
9300: LD_INT 2
9302: PPUSH
9303: CALL_OW 12
9307: ARRAY
9308: ST_TO_ADDR
// vc_engine := engine_combustion ;
9309: LD_ADDR_OWVAR 39
9313: PUSH
9314: LD_INT 1
9316: ST_TO_ADDR
// vc_control := control_manual ;
9317: LD_ADDR_OWVAR 38
9321: PUSH
9322: LD_INT 1
9324: ST_TO_ADDR
// vc_weapon := [ ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 2 ) ] ;
9325: LD_ADDR_OWVAR 40
9329: PUSH
9330: LD_INT 28
9332: PUSH
9333: LD_INT 26
9335: PUSH
9336: EMPTY
9337: LIST
9338: LIST
9339: PUSH
9340: LD_INT 1
9342: PPUSH
9343: LD_INT 2
9345: PPUSH
9346: CALL_OW 12
9350: ARRAY
9351: ST_TO_ADDR
// v := CreateVehicle ;
9352: LD_ADDR_VAR 0 4
9356: PUSH
9357: CALL_OW 45
9361: ST_TO_ADDR
// PlaceUnitArea ( v , south_spawn , false ) ;
9362: LD_VAR 0 4
9366: PPUSH
9367: LD_INT 10
9369: PPUSH
9370: LD_INT 0
9372: PPUSH
9373: CALL_OW 49
// PlaceHumanInUnit ( un , v ) ;
9377: LD_VAR 0 3
9381: PPUSH
9382: LD_VAR 0 4
9386: PPUSH
9387: CALL_OW 52
// ComMoveXY ( v , 186 , 126 ) ;
9391: LD_VAR 0 4
9395: PPUSH
9396: LD_INT 186
9398: PPUSH
9399: LD_INT 126
9401: PPUSH
9402: CALL_OW 111
// end ;
9406: GO 9254
9408: POP
9409: POP
// Wait ( 0 0$30 ) ;
9410: LD_INT 1050
9412: PPUSH
9413: CALL_OW 67
// omar_attack := true ;
9417: LD_ADDR_EXP 20
9421: PUSH
9422: LD_INT 1
9424: ST_TO_ADDR
// end ;
9425: LD_VAR 0 1
9429: RET
// every 0 0$01 trigger omar_attack do var i ;
9430: LD_EXP 20
9434: IFFALSE 9516
9436: GO 9438
9438: DISABLE
9439: LD_INT 0
9441: PPUSH
// begin enable ;
9442: ENABLE
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
9443: LD_ADDR_VAR 0 1
9447: PUSH
9448: LD_INT 22
9450: PUSH
9451: LD_INT 5
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: PPUSH
9458: CALL_OW 69
9462: PUSH
9463: FOR_IN
9464: IFFALSE 9514
// if not HasTask ( i ) then
9466: LD_VAR 0 1
9470: PPUSH
9471: CALL_OW 314
9475: NOT
9476: IFFALSE 9512
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 5 ] ) , i ) ) ;
9478: LD_VAR 0 1
9482: PPUSH
9483: LD_INT 81
9485: PUSH
9486: LD_INT 5
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 69
9497: PPUSH
9498: LD_VAR 0 1
9502: PPUSH
9503: CALL_OW 74
9507: PPUSH
9508: CALL_OW 115
9512: GO 9463
9514: POP
9515: POP
// end ; end_of_file
9516: PPOPN 1
9518: END
// on UnitDestroyed ( un ) do begin if un = heike then
9519: LD_VAR 0 1
9523: PUSH
9524: LD_EXP 14
9528: EQUAL
9529: IFFALSE 9538
// YouLost (  ) ;
9531: LD_STRING 
9533: PPUSH
9534: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) and not IsInArea ( un , omicronz ) then
9538: LD_VAR 0 1
9542: PUSH
9543: LD_INT 22
9545: PUSH
9546: LD_INT 6
9548: PUSH
9549: EMPTY
9550: LIST
9551: LIST
9552: PUSH
9553: LD_INT 21
9555: PUSH
9556: LD_INT 1
9558: PUSH
9559: EMPTY
9560: LIST
9561: LIST
9562: PUSH
9563: EMPTY
9564: LIST
9565: LIST
9566: PPUSH
9567: CALL_OW 69
9571: IN
9572: PUSH
9573: LD_VAR 0 1
9577: PPUSH
9578: LD_INT 12
9580: PPUSH
9581: CALL_OW 308
9585: NOT
9586: AND
9587: IFFALSE 9603
// points := points + 30 ;
9589: LD_ADDR_EXP 25
9593: PUSH
9594: LD_EXP 25
9598: PUSH
9599: LD_INT 30
9601: PLUS
9602: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and not IsInArea ( un , omicronz ) then
9603: LD_VAR 0 1
9607: PUSH
9608: LD_INT 22
9610: PUSH
9611: LD_INT 3
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: PUSH
9618: LD_INT 21
9620: PUSH
9621: LD_INT 1
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: PPUSH
9632: CALL_OW 69
9636: IN
9637: PUSH
9638: LD_VAR 0 1
9642: PPUSH
9643: LD_INT 12
9645: PPUSH
9646: CALL_OW 308
9650: NOT
9651: AND
9652: IFFALSE 9668
// points := points + 30 ;
9654: LD_ADDR_EXP 25
9658: PUSH
9659: LD_EXP 25
9663: PUSH
9664: LD_INT 30
9666: PLUS
9667: ST_TO_ADDR
// if un = kurin then
9668: LD_VAR 0 1
9672: PUSH
9673: LD_EXP 13
9677: EQUAL
9678: IFFALSE 9694
// points := points + 500 ;
9680: LD_ADDR_EXP 25
9684: PUSH
9685: LD_EXP 25
9689: PUSH
9690: LD_INT 500
9692: PLUS
9693: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) and not IsInArea ( un , omicronz ) then
9694: LD_VAR 0 1
9698: PUSH
9699: LD_INT 22
9701: PUSH
9702: LD_INT 3
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: PUSH
9709: LD_INT 21
9711: PUSH
9712: LD_INT 3
9714: PUSH
9715: EMPTY
9716: LIST
9717: LIST
9718: PUSH
9719: EMPTY
9720: LIST
9721: LIST
9722: PPUSH
9723: CALL_OW 69
9727: IN
9728: PUSH
9729: LD_VAR 0 1
9733: PPUSH
9734: LD_INT 12
9736: PPUSH
9737: CALL_OW 308
9741: NOT
9742: AND
9743: IFFALSE 9759
// points := points + 100 ;
9745: LD_ADDR_EXP 25
9749: PUSH
9750: LD_EXP 25
9754: PUSH
9755: LD_INT 100
9757: PLUS
9758: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) and not IsInArea ( un , omicronz ) then
9759: LD_VAR 0 1
9763: PUSH
9764: LD_INT 22
9766: PUSH
9767: LD_INT 6
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: PUSH
9774: LD_INT 21
9776: PUSH
9777: LD_INT 3
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PPUSH
9788: CALL_OW 69
9792: IN
9793: PUSH
9794: LD_VAR 0 1
9798: PPUSH
9799: LD_INT 12
9801: PPUSH
9802: CALL_OW 308
9806: NOT
9807: AND
9808: IFFALSE 9824
// points := points + 100 ;
9810: LD_ADDR_EXP 25
9814: PUSH
9815: LD_EXP 25
9819: PUSH
9820: LD_INT 100
9822: PLUS
9823: ST_TO_ADDR
// if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
9824: LD_VAR 0 1
9828: PPUSH
9829: CALL_OW 255
9833: PUSH
9834: LD_INT 6
9836: EQUAL
9837: PUSH
9838: LD_VAR 0 1
9842: PUSH
9843: LD_INT 21
9845: PUSH
9846: LD_INT 3
9848: PUSH
9849: EMPTY
9850: LIST
9851: LIST
9852: PPUSH
9853: CALL_OW 69
9857: IN
9858: AND
9859: IFFALSE 10086
// begin st_omar := true ;
9861: LD_ADDR_EXP 24
9865: PUSH
9866: LD_INT 1
9868: ST_TO_ADDR
// if GetBType ( un ) = b_factory then
9869: LD_VAR 0 1
9873: PPUSH
9874: CALL_OW 266
9878: PUSH
9879: LD_INT 3
9881: EQUAL
9882: IFFALSE 9898
// ru_bul := ru_bul ^ b_workshop ;
9884: LD_ADDR_EXP 34
9888: PUSH
9889: LD_EXP 34
9893: PUSH
9894: LD_INT 2
9896: ADD
9897: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
9898: LD_VAR 0 1
9902: PPUSH
9903: CALL_OW 266
9907: PUSH
9908: LD_INT 8
9910: EQUAL
9911: PUSH
9912: LD_VAR 0 1
9916: PPUSH
9917: CALL_OW 266
9921: PUSH
9922: LD_INT 7
9924: EQUAL
9925: OR
9926: IFFALSE 9942
// ru_bul := ru_bul ^ b_lab ;
9928: LD_ADDR_EXP 34
9932: PUSH
9933: LD_EXP 34
9937: PUSH
9938: LD_INT 6
9940: ADD
9941: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
9942: LD_VAR 0 1
9946: PPUSH
9947: CALL_OW 266
9951: PUSH
9952: LD_INT 5
9954: EQUAL
9955: IFFALSE 9971
// ru_bul := ru_bul ^ b_armoury ;
9957: LD_ADDR_EXP 34
9961: PUSH
9962: LD_EXP 34
9966: PUSH
9967: LD_INT 4
9969: ADD
9970: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks ] then
9971: LD_VAR 0 1
9975: PPUSH
9976: CALL_OW 266
9980: PUSH
9981: LD_INT 3
9983: PUSH
9984: LD_INT 8
9986: PUSH
9987: LD_INT 7
9989: PUSH
9990: LD_INT 5
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: LIST
9997: LIST
9998: IN
9999: NOT
10000: IFFALSE 10023
// ru_bul := ru_bul ^ GetBType ( un ) ;
10002: LD_ADDR_EXP 34
10006: PUSH
10007: LD_EXP 34
10011: PUSH
10012: LD_VAR 0 1
10016: PPUSH
10017: CALL_OW 266
10021: ADD
10022: ST_TO_ADDR
// ru_bul := ru_bul ^ GetX ( un ) ;
10023: LD_ADDR_EXP 34
10027: PUSH
10028: LD_EXP 34
10032: PUSH
10033: LD_VAR 0 1
10037: PPUSH
10038: CALL_OW 250
10042: ADD
10043: ST_TO_ADDR
// ru_bul := ru_bul ^ GetY ( un ) ;
10044: LD_ADDR_EXP 34
10048: PUSH
10049: LD_EXP 34
10053: PUSH
10054: LD_VAR 0 1
10058: PPUSH
10059: CALL_OW 251
10063: ADD
10064: ST_TO_ADDR
// ru_bul := ru_bul ^ GetDir ( un ) ;
10065: LD_ADDR_EXP 34
10069: PUSH
10070: LD_EXP 34
10074: PUSH
10075: LD_VAR 0 1
10079: PPUSH
10080: CALL_OW 254
10084: ADD
10085: ST_TO_ADDR
// end ; if GetSide ( un ) = 6 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
10086: LD_VAR 0 1
10090: PPUSH
10091: CALL_OW 255
10095: PUSH
10096: LD_INT 6
10098: EQUAL
10099: PUSH
10100: LD_VAR 0 1
10104: PUSH
10105: LD_INT 21
10107: PUSH
10108: LD_INT 2
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: PPUSH
10115: CALL_OW 69
10119: PUSH
10120: LD_INT 34
10122: PUSH
10123: LD_INT 45
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PPUSH
10130: CALL_OW 69
10134: DIFF
10135: IN
10136: AND
10137: IFFALSE 10223
// begin ru_veh := ru_veh ^ GetChassis ( un ) ;
10139: LD_ADDR_EXP 30
10143: PUSH
10144: LD_EXP 30
10148: PUSH
10149: LD_VAR 0 1
10153: PPUSH
10154: CALL_OW 265
10158: ADD
10159: ST_TO_ADDR
// ru_veh := ru_veh ^ GetEngine ( un ) ;
10160: LD_ADDR_EXP 30
10164: PUSH
10165: LD_EXP 30
10169: PUSH
10170: LD_VAR 0 1
10174: PPUSH
10175: CALL_OW 262
10179: ADD
10180: ST_TO_ADDR
// ru_veh := ru_veh ^ GetControl ( un ) ;
10181: LD_ADDR_EXP 30
10185: PUSH
10186: LD_EXP 30
10190: PUSH
10191: LD_VAR 0 1
10195: PPUSH
10196: CALL_OW 263
10200: ADD
10201: ST_TO_ADDR
// ru_veh := ru_veh ^ GetWeapon ( un ) ;
10202: LD_ADDR_EXP 30
10206: PUSH
10207: LD_EXP 30
10211: PUSH
10212: LD_VAR 0 1
10216: PPUSH
10217: CALL_OW 264
10221: ADD
10222: ST_TO_ADDR
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
10223: LD_VAR 0 1
10227: PPUSH
10228: CALL_OW 255
10232: PUSH
10233: LD_INT 3
10235: EQUAL
10236: PUSH
10237: LD_VAR 0 1
10241: PUSH
10242: LD_INT 21
10244: PUSH
10245: LD_INT 3
10247: PUSH
10248: EMPTY
10249: LIST
10250: LIST
10251: PPUSH
10252: CALL_OW 69
10256: IN
10257: AND
10258: IFFALSE 10489
// begin if GetBType ( un ) = b_factory then
10260: LD_VAR 0 1
10264: PPUSH
10265: CALL_OW 266
10269: PUSH
10270: LD_INT 3
10272: EQUAL
10273: IFFALSE 10289
// ru2_bul := ru2_bul ^ b_workshop ;
10275: LD_ADDR_EXP 44
10279: PUSH
10280: LD_EXP 44
10284: PUSH
10285: LD_INT 2
10287: ADD
10288: ST_TO_ADDR
// if GetBType ( un ) = b_lab_full or GetBType ( un ) = b_lab_half then
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 266
10298: PUSH
10299: LD_INT 8
10301: EQUAL
10302: PUSH
10303: LD_VAR 0 1
10307: PPUSH
10308: CALL_OW 266
10312: PUSH
10313: LD_INT 7
10315: EQUAL
10316: OR
10317: IFFALSE 10333
// ru2_bul := ru2_bul ^ b_lab ;
10319: LD_ADDR_EXP 44
10323: PUSH
10324: LD_EXP 44
10328: PUSH
10329: LD_INT 6
10331: ADD
10332: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
10333: LD_VAR 0 1
10337: PPUSH
10338: CALL_OW 266
10342: PUSH
10343: LD_INT 5
10345: EQUAL
10346: IFFALSE 10362
// ru2_bul := ru2_bul ^ b_armoury ;
10348: LD_ADDR_EXP 44
10352: PUSH
10353: LD_EXP 44
10357: PUSH
10358: LD_INT 4
10360: ADD
10361: ST_TO_ADDR
// if not GetBType ( un ) in [ b_factory , b_lab_full , b_lab_half , b_barracks , b_ext_gun , b_ext_noncombat , b_ext_track ] then
10362: LD_VAR 0 1
10366: PPUSH
10367: CALL_OW 266
10371: PUSH
10372: LD_INT 3
10374: PUSH
10375: LD_INT 8
10377: PUSH
10378: LD_INT 7
10380: PUSH
10381: LD_INT 5
10383: PUSH
10384: LD_INT 17
10386: PUSH
10387: LD_INT 19
10389: PUSH
10390: LD_INT 16
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: LIST
10401: IN
10402: NOT
10403: IFFALSE 10426
// ru2_bul := ru2_bul ^ GetBType ( un ) ;
10405: LD_ADDR_EXP 44
10409: PUSH
10410: LD_EXP 44
10414: PUSH
10415: LD_VAR 0 1
10419: PPUSH
10420: CALL_OW 266
10424: ADD
10425: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetX ( un ) ;
10426: LD_ADDR_EXP 44
10430: PUSH
10431: LD_EXP 44
10435: PUSH
10436: LD_VAR 0 1
10440: PPUSH
10441: CALL_OW 250
10445: ADD
10446: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetY ( un ) ;
10447: LD_ADDR_EXP 44
10451: PUSH
10452: LD_EXP 44
10456: PUSH
10457: LD_VAR 0 1
10461: PPUSH
10462: CALL_OW 251
10466: ADD
10467: ST_TO_ADDR
// ru2_bul := ru2_bul ^ GetDir ( un ) ;
10468: LD_ADDR_EXP 44
10472: PUSH
10473: LD_EXP 44
10477: PUSH
10478: LD_VAR 0 1
10482: PPUSH
10483: CALL_OW 254
10487: ADD
10488: ST_TO_ADDR
// end ; if GetSide ( un ) = 3 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) diff FilterAllUnits ( [ f_weapon , ru_rocket_launcher ] ) then
10489: LD_VAR 0 1
10493: PPUSH
10494: CALL_OW 255
10498: PUSH
10499: LD_INT 3
10501: EQUAL
10502: PUSH
10503: LD_VAR 0 1
10507: PUSH
10508: LD_INT 21
10510: PUSH
10511: LD_INT 2
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: PPUSH
10518: CALL_OW 69
10522: PUSH
10523: LD_INT 34
10525: PUSH
10526: LD_INT 45
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: PPUSH
10533: CALL_OW 69
10537: DIFF
10538: IN
10539: AND
10540: IFFALSE 10626
// begin ru2_veh := ru2_veh ^ GetChassis ( un ) ;
10542: LD_ADDR_EXP 40
10546: PUSH
10547: LD_EXP 40
10551: PUSH
10552: LD_VAR 0 1
10556: PPUSH
10557: CALL_OW 265
10561: ADD
10562: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetEngine ( un ) ;
10563: LD_ADDR_EXP 40
10567: PUSH
10568: LD_EXP 40
10572: PUSH
10573: LD_VAR 0 1
10577: PPUSH
10578: CALL_OW 262
10582: ADD
10583: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetControl ( un ) ;
10584: LD_ADDR_EXP 40
10588: PUSH
10589: LD_EXP 40
10593: PUSH
10594: LD_VAR 0 1
10598: PPUSH
10599: CALL_OW 263
10603: ADD
10604: ST_TO_ADDR
// ru2_veh := ru2_veh ^ GetWeapon ( un ) ;
10605: LD_ADDR_EXP 40
10609: PUSH
10610: LD_EXP 40
10614: PUSH
10615: LD_VAR 0 1
10619: PPUSH
10620: CALL_OW 264
10624: ADD
10625: ST_TO_ADDR
// end ; end ;
10626: PPOPN 1
10628: END
// on BuildingComplete ( b ) do var i ;
10629: LD_INT 0
10631: PPUSH
// begin if b in FilterAllUnits ( [ f_side , 6 ] ) then
10632: LD_VAR 0 1
10636: PUSH
10637: LD_INT 22
10639: PUSH
10640: LD_INT 6
10642: PUSH
10643: EMPTY
10644: LIST
10645: LIST
10646: PPUSH
10647: CALL_OW 69
10651: IN
10652: IFFALSE 10692
// for i = 1 to 4 do
10654: LD_ADDR_VAR 0 2
10658: PUSH
10659: DOUBLE
10660: LD_INT 1
10662: DEC
10663: ST_TO_ADDR
10664: LD_INT 4
10666: PUSH
10667: FOR_TO
10668: IFFALSE 10690
// ru_bul := Delete ( ru_bul , 1 ) ;
10670: LD_ADDR_EXP 34
10674: PUSH
10675: LD_EXP 34
10679: PPUSH
10680: LD_INT 1
10682: PPUSH
10683: CALL_OW 3
10687: ST_TO_ADDR
10688: GO 10667
10690: POP
10691: POP
// if b in FilterAllUnits ( [ f_side , 3 ] ) then
10692: LD_VAR 0 1
10696: PUSH
10697: LD_INT 22
10699: PUSH
10700: LD_INT 3
10702: PUSH
10703: EMPTY
10704: LIST
10705: LIST
10706: PPUSH
10707: CALL_OW 69
10711: IN
10712: IFFALSE 10752
// for i = 1 to 4 do
10714: LD_ADDR_VAR 0 2
10718: PUSH
10719: DOUBLE
10720: LD_INT 1
10722: DEC
10723: ST_TO_ADDR
10724: LD_INT 4
10726: PUSH
10727: FOR_TO
10728: IFFALSE 10750
// ru2_bul := Delete ( ru2_bul , 1 ) ;
10730: LD_ADDR_EXP 44
10734: PUSH
10735: LD_EXP 44
10739: PPUSH
10740: LD_INT 1
10742: PPUSH
10743: CALL_OW 3
10747: ST_TO_ADDR
10748: GO 10727
10750: POP
10751: POP
// end ; end_of_file
10752: PPOPN 2
10754: END
// export function StartGame ; var i ; begin
10755: LD_INT 0
10757: PPUSH
10758: PPUSH
// InGameOn ;
10759: CALL_OW 8
// ChangeSideFog ( 2 , 5 ) ;
10763: LD_INT 2
10765: PPUSH
10766: LD_INT 5
10768: PPUSH
10769: CALL_OW 343
// CenterNowOnXY ( 152 , 13 ) ;
10773: LD_INT 152
10775: PPUSH
10776: LD_INT 13
10778: PPUSH
10779: CALL_OW 86
// case Query ( textdiff ) of 1 :
10783: LD_STRING textdiff
10785: PPUSH
10786: CALL_OW 97
10790: PUSH
10791: LD_INT 1
10793: DOUBLE
10794: EQUAL
10795: IFTRUE 10799
10797: GO 10810
10799: POP
// global_diff := 1 ; 2 :
10800: LD_ADDR_EXP 2
10804: PUSH
10805: LD_INT 1
10807: ST_TO_ADDR
10808: GO 10849
10810: LD_INT 2
10812: DOUBLE
10813: EQUAL
10814: IFTRUE 10818
10816: GO 10829
10818: POP
// global_diff := 2 ; 3 :
10819: LD_ADDR_EXP 2
10823: PUSH
10824: LD_INT 2
10826: ST_TO_ADDR
10827: GO 10849
10829: LD_INT 3
10831: DOUBLE
10832: EQUAL
10833: IFTRUE 10837
10835: GO 10848
10837: POP
// global_diff := 3 ; end ;
10838: LD_ADDR_EXP 2
10842: PUSH
10843: LD_INT 3
10845: ST_TO_ADDR
10846: GO 10849
10848: POP
// case Query ( redplan ) of 1 :
10849: LD_STRING redplan
10851: PPUSH
10852: CALL_OW 97
10856: PUSH
10857: LD_INT 1
10859: DOUBLE
10860: EQUAL
10861: IFTRUE 10865
10863: GO 10868
10865: POP
// ; end ;
10866: GO 10869
10868: POP
// RusSpecForce ;
10869: CALL 8323 0 0
// game_started := true ;
10873: LD_ADDR_EXP 9
10877: PUSH
10878: LD_INT 1
10880: ST_TO_ADDR
// crates_allow := true ;
10881: LD_ADDR_EXP 12
10885: PUSH
10886: LD_INT 1
10888: ST_TO_ADDR
// PrepareHeike ;
10889: CALL 8436 0 0
// PlaceUnitXY ( heike , 152 , 13 , false ) ;
10893: LD_EXP 14
10897: PPUSH
10898: LD_INT 152
10900: PPUSH
10901: LD_INT 13
10903: PPUSH
10904: LD_INT 0
10906: PPUSH
10907: CALL_OW 48
// PlaceUnitXY ( kurt , 143 , 13 , false ) ;
10911: LD_EXP 16
10915: PPUSH
10916: LD_INT 143
10918: PPUSH
10919: LD_INT 13
10921: PPUSH
10922: LD_INT 0
10924: PPUSH
10925: CALL_OW 48
// PlaceUnitXY ( olaf , 149 , 10 , false ) ;
10929: LD_EXP 17
10933: PPUSH
10934: LD_INT 149
10936: PPUSH
10937: LD_INT 10
10939: PPUSH
10940: LD_INT 0
10942: PPUSH
10943: CALL_OW 48
// ComTurnUnit ( olaf , heike ) ;
10947: LD_EXP 17
10951: PPUSH
10952: LD_EXP 14
10956: PPUSH
10957: CALL_OW 119
// ComTurnUnit ( kurt , heike ) ;
10961: LD_EXP 16
10965: PPUSH
10966: LD_EXP 14
10970: PPUSH
10971: CALL_OW 119
// ComTurnUnit ( heike , kurt ) ;
10975: LD_EXP 14
10979: PPUSH
10980: LD_EXP 16
10984: PPUSH
10985: CALL_OW 119
// Say ( heike , DBlitz-H1 ) ;
10989: LD_EXP 14
10993: PPUSH
10994: LD_STRING DBlitz-H1
10996: PPUSH
10997: CALL_OW 88
// Say ( kurt , DBlitz-K1 ) ;
11001: LD_EXP 16
11005: PPUSH
11006: LD_STRING DBlitz-K1
11008: PPUSH
11009: CALL_OW 88
// Say ( olaf , DBlitz-O1 ) ;
11013: LD_EXP 17
11017: PPUSH
11018: LD_STRING DBlitz-O1
11020: PPUSH
11021: CALL_OW 88
// Say ( heike , DBlitz-H2 ) ;
11025: LD_EXP 14
11029: PPUSH
11030: LD_STRING DBlitz-H2
11032: PPUSH
11033: CALL_OW 88
// InGameOff ;
11037: CALL_OW 9
// PlaceSeeing ( 38 , 16 , 2 , 10 ) ;
11041: LD_INT 38
11043: PPUSH
11044: LD_INT 16
11046: PPUSH
11047: LD_INT 2
11049: PPUSH
11050: LD_INT 10
11052: PPUSH
11053: CALL_OW 330
// PlaceSeeing ( 54 , 60 , 2 , 10 ) ;
11057: LD_INT 54
11059: PPUSH
11060: LD_INT 60
11062: PPUSH
11063: LD_INT 2
11065: PPUSH
11066: LD_INT 10
11068: PPUSH
11069: CALL_OW 330
// PlaceSeeing ( 117 , 113 , 2 , 10 ) ;
11073: LD_INT 117
11075: PPUSH
11076: LD_INT 113
11078: PPUSH
11079: LD_INT 2
11081: PPUSH
11082: LD_INT 10
11084: PPUSH
11085: CALL_OW 330
// PlaceSeeing ( 104 , 55 , 2 , 10 ) ;
11089: LD_INT 104
11091: PPUSH
11092: LD_INT 55
11094: PPUSH
11095: LD_INT 2
11097: PPUSH
11098: LD_INT 10
11100: PPUSH
11101: CALL_OW 330
// ChangeMissionObjectives ( redplan1 ) ;
11105: LD_STRING redplan1
11107: PPUSH
11108: CALL_OW 337
// PrepareArabian ;
11112: CALL 8695 0 0
// for i = 1 to ar_force do
11116: LD_ADDR_VAR 0 2
11120: PUSH
11121: DOUBLE
11122: LD_INT 1
11124: DEC
11125: ST_TO_ADDR
11126: LD_EXP 8
11130: PUSH
11131: FOR_TO
11132: IFFALSE 11266
// begin Wait ( Rand ( 0 0$03 , 0 0$05 ) ) ;
11134: LD_INT 105
11136: PPUSH
11137: LD_INT 175
11139: PPUSH
11140: CALL_OW 12
11144: PPUSH
11145: CALL_OW 67
// PlaceUnitXY ( ar_force [ i ] , 132 , 2 , false ) ;
11149: LD_EXP 8
11153: PUSH
11154: LD_VAR 0 2
11158: ARRAY
11159: PPUSH
11160: LD_INT 132
11162: PPUSH
11163: LD_INT 2
11165: PPUSH
11166: LD_INT 0
11168: PPUSH
11169: CALL_OW 48
// if ar_force [ i ] in FilterAllUnits ( [ f_type , unit_vehicle ] ) then
11173: LD_EXP 8
11177: PUSH
11178: LD_VAR 0 2
11182: ARRAY
11183: PUSH
11184: LD_INT 21
11186: PUSH
11187: LD_INT 2
11189: PUSH
11190: EMPTY
11191: LIST
11192: LIST
11193: PPUSH
11194: CALL_OW 69
11198: IN
11199: IFFALSE 11243
// begin PlaceHumanInUnit ( ar_vehs [ 1 ] , ar_force [ i ] ) ;
11201: LD_EXP 47
11205: PUSH
11206: LD_INT 1
11208: ARRAY
11209: PPUSH
11210: LD_EXP 8
11214: PUSH
11215: LD_VAR 0 2
11219: ARRAY
11220: PPUSH
11221: CALL_OW 52
// ar_vehs := Delete ( ar_vehs , 1 ) ;
11225: LD_ADDR_EXP 47
11229: PUSH
11230: LD_EXP 47
11234: PPUSH
11235: LD_INT 1
11237: PPUSH
11238: CALL_OW 3
11242: ST_TO_ADDR
// end ; ComMoveXY ( ar_force [ i ] , 141 , 16 ) ;
11243: LD_EXP 8
11247: PUSH
11248: LD_VAR 0 2
11252: ARRAY
11253: PPUSH
11254: LD_INT 141
11256: PPUSH
11257: LD_INT 16
11259: PPUSH
11260: CALL_OW 111
// end ;
11264: GO 11131
11266: POP
11267: POP
// Say ( Heike , DBlitz-Heike-1 ) ;
11268: LD_EXP 14
11272: PPUSH
11273: LD_STRING DBlitz-Heike-1
11275: PPUSH
11276: CALL_OW 88
// attack_omicron := true ;
11280: LD_ADDR_EXP 23
11284: PUSH
11285: LD_INT 1
11287: ST_TO_ADDR
// end ;
11288: LD_VAR 0 1
11292: RET
// every 0 0$01 trigger st_omar do
11293: LD_EXP 24
11297: IFFALSE 11306
11299: GO 11301
11301: DISABLE
// PrepareOmarForce ;
11302: CALL 9098 0 0
11306: END
// every 0 0$01 trigger IsDead ( kurin ) do
11307: LD_EXP 13
11311: PPUSH
11312: CALL_OW 301
11316: IFFALSE 11329
11318: GO 11320
11320: DISABLE
// begin rus_escape := true ;
11321: LD_ADDR_EXP 22
11325: PUSH
11326: LD_INT 1
11328: ST_TO_ADDR
// end ;
11329: END
// every 0 0$01 trigger rus_escape and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do var i ;
11330: LD_EXP 22
11334: PUSH
11335: LD_INT 22
11337: PUSH
11338: LD_INT 3
11340: PUSH
11341: EMPTY
11342: LIST
11343: LIST
11344: PUSH
11345: LD_INT 21
11347: PUSH
11348: LD_INT 1
11350: PUSH
11351: EMPTY
11352: LIST
11353: LIST
11354: PUSH
11355: EMPTY
11356: LIST
11357: LIST
11358: PPUSH
11359: CALL_OW 69
11363: AND
11364: IFFALSE 11464
11366: GO 11368
11368: DISABLE
11369: LD_INT 0
11371: PPUSH
// begin enable ;
11372: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 2 ] , [ f_class , 4 ] ] ] ) do
11373: LD_ADDR_VAR 0 1
11377: PUSH
11378: LD_INT 22
11380: PUSH
11381: LD_INT 3
11383: PUSH
11384: EMPTY
11385: LIST
11386: LIST
11387: PUSH
11388: LD_INT 2
11390: PUSH
11391: LD_INT 25
11393: PUSH
11394: LD_INT 2
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: PUSH
11401: LD_INT 25
11403: PUSH
11404: LD_INT 4
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: PUSH
11411: EMPTY
11412: LIST
11413: LIST
11414: LIST
11415: PUSH
11416: EMPTY
11417: LIST
11418: LIST
11419: PPUSH
11420: CALL_OW 69
11424: PUSH
11425: FOR_IN
11426: IFFALSE 11462
// begin if IsInUnit ( i ) then
11428: LD_VAR 0 1
11432: PPUSH
11433: CALL_OW 310
11437: IFFALSE 11448
// ComExitBuilding ( i ) ;
11439: LD_VAR 0 1
11443: PPUSH
11444: CALL_OW 122
// ComMoveToArea ( i , west ) ;
11448: LD_VAR 0 1
11452: PPUSH
11453: LD_INT 11
11455: PPUSH
11456: CALL_OW 113
// end ;
11460: GO 11425
11462: POP
11463: POP
// end ;
11464: PPOPN 1
11466: END
// every 0 0$01 trigger IsDead ( kirov ) and IsDead ( beria ) and IsDead ( kagan ) do
11467: LD_INT 71
11469: PPUSH
11470: CALL_OW 301
11474: PUSH
11475: LD_INT 106
11477: PPUSH
11478: CALL_OW 301
11482: AND
11483: PUSH
11484: LD_INT 112
11486: PPUSH
11487: CALL_OW 301
11491: AND
11492: IFFALSE 11522
11494: GO 11496
11496: DISABLE
// begin ChangeMissionObjectives ( redplan2 ) ;
11497: LD_STRING redplan2
11499: PPUSH
11500: CALL_OW 337
// SetAreaMapShow ( west , 1 ) ;
11504: LD_INT 11
11506: PPUSH
11507: LD_INT 1
11509: PPUSH
11510: CALL_OW 424
// heike_go := true ;
11514: LD_ADDR_EXP 21
11518: PUSH
11519: LD_INT 1
11521: ST_TO_ADDR
// end ;
11522: END
// every 0 0$01 trigger IsInArea ( heike , west ) and heike_go do
11523: LD_EXP 14
11527: PPUSH
11528: LD_INT 11
11530: PPUSH
11531: CALL_OW 308
11535: PUSH
11536: LD_EXP 21
11540: AND
11541: IFFALSE 11560
11543: GO 11545
11545: DISABLE
// begin Save ;
11546: CALL 884 0 0
// ChangeMap ( 1 , __am/Blitzkrieg2 ) ;
11550: LD_INT 1
11552: PPUSH
11553: LD_STRING __am/Blitzkrieg2
11555: PPUSH
11556: CALL_OW 340
// end ;
11560: END
// every 0 0$01 trigger FilterUnitsInArea ( west , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
11561: LD_INT 11
11563: PPUSH
11564: LD_INT 2
11566: PUSH
11567: LD_INT 22
11569: PUSH
11570: LD_INT 3
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: LD_INT 22
11579: PUSH
11580: LD_INT 6
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: LIST
11591: PPUSH
11592: CALL_OW 70
11596: IFFALSE 11676
11598: GO 11600
11600: DISABLE
11601: LD_INT 0
11603: PPUSH
// begin enable ;
11604: ENABLE
// for i in FilterUnitsInArea ( west , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
11605: LD_ADDR_VAR 0 1
11609: PUSH
11610: LD_INT 11
11612: PPUSH
11613: LD_INT 2
11615: PUSH
11616: LD_INT 22
11618: PUSH
11619: LD_INT 3
11621: PUSH
11622: EMPTY
11623: LIST
11624: LIST
11625: PUSH
11626: LD_INT 22
11628: PUSH
11629: LD_INT 6
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PUSH
11636: EMPTY
11637: LIST
11638: LIST
11639: LIST
11640: PPUSH
11641: CALL_OW 70
11645: PUSH
11646: FOR_IN
11647: IFFALSE 11674
// begin RemoveUnit ( i ) ;
11649: LD_VAR 0 1
11653: PPUSH
11654: CALL_OW 64
// points := points - 50 ;
11658: LD_ADDR_EXP 25
11662: PUSH
11663: LD_EXP 25
11667: PUSH
11668: LD_INT 50
11670: MINUS
11671: ST_TO_ADDR
// end ;
11672: GO 11646
11674: POP
11675: POP
// end ;
11676: PPOPN 1
11678: END
