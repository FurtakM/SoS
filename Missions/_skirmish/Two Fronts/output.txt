// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7474 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4575 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 32
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4874 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3000 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2627 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3000 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2627 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3000 0 4
// MC_Registry ( ) ;
 213: CALL 41953 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42404 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 33
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21205 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21141 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18134 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21041 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22055 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21282 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21075 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21108 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 17913 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 21963 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20220 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20795 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20795 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20592 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20256 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20432 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19716 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20330 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20831 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21571 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21141 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18134 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21041 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21282 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21075 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21108 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 17913 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 21963 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20220 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20795 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20795 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20592 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20256 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20432 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19716 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20330 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20831 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21571 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 5
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 6
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 7
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 8
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 11
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 12
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 13
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 14
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 15
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 9
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// end ;
1629: LD_VAR 0 1
1633: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1634: LD_INT 8
1636: PPUSH
1637: CALL_OW 353
1641: PUSH
1642: LD_INT 0
1644: EQUAL
1645: IFFALSE 1680
1647: GO 1649
1649: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1650: LD_INT 1
1652: PPUSH
1653: LD_INT 32
1655: PPUSH
1656: LD_INT 50
1658: PUSH
1659: LD_INT 10
1661: PUSH
1662: LD_INT 4
1664: PUSH
1665: EMPTY
1666: LIST
1667: LIST
1668: LIST
1669: PPUSH
1670: LD_INT 7
1672: PUSH
1673: EMPTY
1674: LIST
1675: PPUSH
1676: CALL 19716 0 4
// end ;
1680: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1681: LD_INT 1
1683: PPUSH
1684: LD_INT 30
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: EMPTY
1691: LIST
1692: LIST
1693: PPUSH
1694: CALL 11421 0 2
1698: IFFALSE 1792
1700: GO 1702
1702: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1703: LD_INT 1
1705: PPUSH
1706: LD_INT 3
1708: PUSH
1709: LD_INT 1
1711: PUSH
1712: LD_INT 2
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 3
1720: PUSH
1721: LD_INT 1
1723: PUSH
1724: LD_INT 2
1726: PUSH
1727: LD_INT 5
1729: PUSH
1730: LD_INT 3
1732: PUSH
1733: LD_INT 1
1735: PUSH
1736: LD_INT 2
1738: PUSH
1739: LD_INT 5
1741: PUSH
1742: LD_INT 3
1744: PUSH
1745: LD_INT 1
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 7
1753: PUSH
1754: LD_INT 3
1756: PUSH
1757: LD_INT 1
1759: PUSH
1760: LD_INT 2
1762: PUSH
1763: LD_INT 7
1765: PUSH
1766: EMPTY
1767: LIST
1768: LIST
1769: LIST
1770: LIST
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: PPUSH
1788: CALL 21789 0 2
// end ;
1792: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1793: LD_INT 4
1795: PPUSH
1796: LD_INT 30
1798: PUSH
1799: LD_INT 3
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: PPUSH
1806: CALL 11421 0 2
1810: IFFALSE 1904
1812: GO 1814
1814: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1815: LD_INT 4
1817: PPUSH
1818: LD_INT 3
1820: PUSH
1821: LD_INT 1
1823: PUSH
1824: LD_INT 2
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 3
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 2
1838: PUSH
1839: LD_INT 5
1841: PUSH
1842: LD_INT 3
1844: PUSH
1845: LD_INT 1
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 5
1853: PUSH
1854: LD_INT 4
1856: PUSH
1857: LD_INT 1
1859: PUSH
1860: LD_INT 2
1862: PUSH
1863: LD_INT 6
1865: PUSH
1866: LD_INT 4
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 2
1874: PUSH
1875: LD_INT 6
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PPUSH
1900: CALL 21789 0 2
// end ;
1904: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 30
1910: PUSH
1911: LD_INT 3
1913: PUSH
1914: EMPTY
1915: LIST
1916: LIST
1917: PPUSH
1918: CALL 11421 0 2
1922: PUSH
1923: LD_EXP 70
1927: PUSH
1928: LD_INT 1
1930: ARRAY
1931: PUSH
1932: LD_INT 1
1934: ARRAY
1935: PUSH
1936: LD_INT 0
1938: EQUAL
1939: AND
1940: IFFALSE 2051
1942: GO 1944
1944: DISABLE
// begin enable ;
1945: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1946: LD_INT 1
1948: PPUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 2
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: LD_INT 3
1963: PUSH
1964: LD_INT 1
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 5
1972: PUSH
1973: LD_INT 3
1975: PUSH
1976: LD_INT 1
1978: PUSH
1979: LD_INT 2
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: LD_INT 3
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 2
1993: PUSH
1994: LD_INT 7
1996: PUSH
1997: LD_INT 3
1999: PUSH
2000: LD_INT 1
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 7
2008: PUSH
2009: LD_INT 4
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 2
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: LIST
2028: LIST
2029: LIST
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 21789 0 2
// end ;
2051: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2052: LD_INT 4
2054: PPUSH
2055: LD_INT 30
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PPUSH
2065: CALL 11421 0 2
2069: PUSH
2070: LD_EXP 70
2074: PUSH
2075: LD_INT 4
2077: ARRAY
2078: PUSH
2079: LD_INT 1
2081: ARRAY
2082: PUSH
2083: LD_INT 0
2085: EQUAL
2086: AND
2087: IFFALSE 2198
2089: GO 2091
2091: DISABLE
// begin enable ;
2092: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2093: LD_INT 4
2095: PPUSH
2096: LD_INT 3
2098: PUSH
2099: LD_INT 1
2101: PUSH
2102: LD_INT 2
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 3
2110: PUSH
2111: LD_INT 1
2113: PUSH
2114: LD_INT 2
2116: PUSH
2117: LD_INT 5
2119: PUSH
2120: LD_INT 3
2122: PUSH
2123: LD_INT 1
2125: PUSH
2126: LD_INT 2
2128: PUSH
2129: LD_INT 5
2131: PUSH
2132: LD_INT 4
2134: PUSH
2135: LD_INT 1
2137: PUSH
2138: LD_INT 2
2140: PUSH
2141: LD_INT 6
2143: PUSH
2144: LD_INT 4
2146: PUSH
2147: LD_INT 1
2149: PUSH
2150: LD_INT 2
2152: PUSH
2153: LD_INT 6
2155: PUSH
2156: LD_INT 3
2158: PUSH
2159: LD_INT 1
2161: PUSH
2162: LD_INT 2
2164: PUSH
2165: LD_INT 5
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: PPUSH
2194: CALL 21789 0 2
// end ;
2198: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2199: LD_EXP 12
2203: PUSH
2204: LD_INT 22
2206: PUSH
2207: LD_INT 6
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 21
2216: PUSH
2217: LD_INT 2
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 3
2226: PUSH
2227: LD_INT 34
2229: PUSH
2230: LD_INT 51
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: LIST
2245: PPUSH
2246: CALL_OW 69
2250: AND
2251: IFFALSE 2380
2253: GO 2255
2255: DISABLE
2256: LD_INT 0
2258: PPUSH
// begin enable ;
2259: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2260: LD_ADDR_VAR 0 1
2264: PUSH
2265: LD_INT 22
2267: PUSH
2268: LD_INT 6
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: LD_INT 21
2277: PUSH
2278: LD_INT 2
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: PUSH
2285: LD_INT 3
2287: PUSH
2288: LD_INT 34
2290: PUSH
2291: LD_INT 51
2293: PUSH
2294: EMPTY
2295: LIST
2296: LIST
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: LIST
2306: PPUSH
2307: CALL_OW 69
2311: PUSH
2312: FOR_IN
2313: IFFALSE 2378
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2315: LD_VAR 0 1
2319: PPUSH
2320: CALL_OW 314
2324: NOT
2325: PUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: CALL_OW 256
2335: PUSH
2336: LD_INT 250
2338: GREATER
2339: AND
2340: IFFALSE 2376
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2342: LD_VAR 0 1
2346: PPUSH
2347: LD_INT 81
2349: PUSH
2350: LD_INT 6
2352: PUSH
2353: EMPTY
2354: LIST
2355: LIST
2356: PPUSH
2357: CALL_OW 69
2361: PPUSH
2362: LD_VAR 0 1
2366: PPUSH
2367: CALL_OW 74
2371: PPUSH
2372: CALL_OW 115
2376: GO 2312
2378: POP
2379: POP
// end ;
2380: PPOPN 1
2382: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2383: LD_EXP 12
2387: PUSH
2388: LD_INT 22
2390: PUSH
2391: LD_INT 6
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: LD_INT 21
2400: PUSH
2401: LD_INT 2
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 34
2413: PUSH
2414: LD_INT 51
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: LIST
2429: PPUSH
2430: CALL_OW 69
2434: PUSH
2435: LD_INT 0
2437: EQUAL
2438: AND
2439: IFFALSE 2453
2441: GO 2443
2443: DISABLE
// begin enable ;
2444: ENABLE
// pink_attack := false ;
2445: LD_ADDR_EXP 12
2449: PUSH
2450: LD_INT 0
2452: ST_TO_ADDR
// end ;
2453: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2454: LD_EXP 13
2458: PUSH
2459: LD_INT 22
2461: PUSH
2462: LD_INT 8
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: PPUSH
2469: CALL_OW 69
2473: AND
2474: IFFALSE 2585
2476: GO 2478
2478: DISABLE
2479: LD_INT 0
2481: PPUSH
// begin enable ;
2482: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2483: LD_ADDR_VAR 0 1
2487: PUSH
2488: LD_INT 22
2490: PUSH
2491: LD_INT 8
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: PUSH
2498: LD_INT 21
2500: PUSH
2501: LD_INT 2
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: PPUSH
2512: CALL_OW 69
2516: PUSH
2517: FOR_IN
2518: IFFALSE 2583
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2520: LD_VAR 0 1
2524: PPUSH
2525: CALL_OW 314
2529: NOT
2530: PUSH
2531: LD_VAR 0 1
2535: PPUSH
2536: CALL_OW 256
2540: PUSH
2541: LD_INT 250
2543: GREATER
2544: AND
2545: IFFALSE 2581
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2547: LD_VAR 0 1
2551: PPUSH
2552: LD_INT 81
2554: PUSH
2555: LD_INT 8
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: PPUSH
2562: CALL_OW 69
2566: PPUSH
2567: LD_VAR 0 1
2571: PPUSH
2572: CALL_OW 74
2576: PPUSH
2577: CALL_OW 115
2581: GO 2517
2583: POP
2584: POP
// end ;
2585: PPOPN 1
2587: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2588: LD_EXP 13
2592: PUSH
2593: LD_INT 22
2595: PUSH
2596: LD_INT 8
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: PPUSH
2603: CALL_OW 69
2607: PUSH
2608: LD_INT 0
2610: EQUAL
2611: AND
2612: IFFALSE 2626
2614: GO 2616
2616: DISABLE
// begin enable ;
2617: ENABLE
// alfa_support := false ;
2618: LD_ADDR_EXP 13
2622: PUSH
2623: LD_INT 0
2625: ST_TO_ADDR
// end ; end_of_file
2626: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2627: LD_INT 0
2629: PPUSH
2630: PPUSH
2631: PPUSH
2632: PPUSH
// uc_side := side ;
2633: LD_ADDR_OWVAR 20
2637: PUSH
2638: LD_VAR 0 1
2642: ST_TO_ADDR
// uc_nation := nat ;
2643: LD_ADDR_OWVAR 21
2647: PUSH
2648: LD_VAR 0 2
2652: ST_TO_ADDR
// team := [ ] ;
2653: LD_ADDR_VAR 0 10
2657: PUSH
2658: EMPTY
2659: ST_TO_ADDR
// hc_importance := 100 ;
2660: LD_ADDR_OWVAR 32
2664: PUSH
2665: LD_INT 100
2667: ST_TO_ADDR
// case commander of jakes :
2668: LD_VAR 0 4
2672: PUSH
2673: LD_STRING jakes
2675: DOUBLE
2676: EQUAL
2677: IFTRUE 2681
2679: GO 2758
2681: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2682: LD_INT 1
2684: PPUSH
2685: LD_INT 1
2687: PPUSH
2688: LD_VAR 0 5
2692: PPUSH
2693: CALL_OW 380
// hc_gallery := pkremaster ;
2697: LD_ADDR_OWVAR 33
2701: PUSH
2702: LD_STRING pkremaster
2704: ST_TO_ADDR
// hc_face_number := 12 ;
2705: LD_ADDR_OWVAR 34
2709: PUSH
2710: LD_INT 12
2712: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2713: LD_ADDR_OWVAR 26
2717: PUSH
2718: LD_STRING Jan van Jakes
2720: ST_TO_ADDR
// houten := CreateHuman ;
2721: LD_ADDR_EXP 3
2725: PUSH
2726: CALL_OW 44
2730: ST_TO_ADDR
// LogHuman ( houten ) ;
2731: LD_EXP 3
2735: PPUSH
2736: CALL 7693 0 1
// team := team ^ houten ;
2740: LD_ADDR_VAR 0 10
2744: PUSH
2745: LD_VAR 0 10
2749: PUSH
2750: LD_EXP 3
2754: ADD
2755: ST_TO_ADDR
// end ; sylvia :
2756: GO 2844
2758: LD_STRING sylvia
2760: DOUBLE
2761: EQUAL
2762: IFTRUE 2766
2764: GO 2843
2766: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2767: LD_INT 2
2769: PPUSH
2770: LD_INT 1
2772: PPUSH
2773: LD_VAR 0 5
2777: PPUSH
2778: CALL_OW 380
// hc_gallery := pkremaster ;
2782: LD_ADDR_OWVAR 33
2786: PUSH
2787: LD_STRING pkremaster
2789: ST_TO_ADDR
// hc_face_number := 13 ;
2790: LD_ADDR_OWVAR 34
2794: PUSH
2795: LD_INT 13
2797: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2798: LD_ADDR_OWVAR 26
2802: PUSH
2803: LD_STRING Sylvia Johnson
2805: ST_TO_ADDR
// brown := CreateHuman ;
2806: LD_ADDR_EXP 4
2810: PUSH
2811: CALL_OW 44
2815: ST_TO_ADDR
// LogHuman ( brown ) ;
2816: LD_EXP 4
2820: PPUSH
2821: CALL 7693 0 1
// team := team ^ brown ;
2825: LD_ADDR_VAR 0 10
2829: PUSH
2830: LD_VAR 0 10
2834: PUSH
2835: LD_EXP 4
2839: ADD
2840: ST_TO_ADDR
// end ; end ;
2841: GO 2844
2843: POP
// hc_gallery :=  ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING 
2851: ST_TO_ADDR
// hc_name :=  ;
2852: LD_ADDR_OWVAR 26
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_importance := 0 ;
2860: LD_ADDR_OWVAR 32
2864: PUSH
2865: LD_INT 0
2867: ST_TO_ADDR
// for i = 1 to num do
2868: LD_ADDR_VAR 0 8
2872: PUSH
2873: DOUBLE
2874: LD_INT 1
2876: DEC
2877: ST_TO_ADDR
2878: LD_VAR 0 6
2882: PUSH
2883: FOR_TO
2884: IFFALSE 2948
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2886: LD_INT 0
2888: PPUSH
2889: LD_VAR 0 8
2893: PUSH
2894: LD_INT 4
2896: MOD
2897: PUSH
2898: LD_INT 1
2900: PLUS
2901: PPUSH
2902: LD_VAR 0 5
2906: PPUSH
2907: CALL_OW 380
// un := CreateHuman ;
2911: LD_ADDR_VAR 0 9
2915: PUSH
2916: CALL_OW 44
2920: ST_TO_ADDR
// LogHuman ( un ) ;
2921: LD_VAR 0 9
2925: PPUSH
2926: CALL 7693 0 1
// team := team ^ un ;
2930: LD_ADDR_VAR 0 10
2934: PUSH
2935: LD_VAR 0 10
2939: PUSH
2940: LD_VAR 0 9
2944: ADD
2945: ST_TO_ADDR
// end ;
2946: GO 2883
2948: POP
2949: POP
// for i = 1 to team do
2950: LD_ADDR_VAR 0 8
2954: PUSH
2955: DOUBLE
2956: LD_INT 1
2958: DEC
2959: ST_TO_ADDR
2960: LD_VAR 0 10
2964: PUSH
2965: FOR_TO
2966: IFFALSE 2993
// PlaceUnitArea ( team [ i ] , area , false ) ;
2968: LD_VAR 0 10
2972: PUSH
2973: LD_VAR 0 8
2977: ARRAY
2978: PPUSH
2979: LD_VAR 0 3
2983: PPUSH
2984: LD_INT 0
2986: PPUSH
2987: CALL_OW 49
2991: GO 2965
2993: POP
2994: POP
// end ;
2995: LD_VAR 0 7
2999: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3000: LD_INT 0
3002: PPUSH
3003: PPUSH
// for i = 1 to n1 do
3004: LD_ADDR_VAR 0 6
3008: PUSH
3009: DOUBLE
3010: LD_INT 1
3012: DEC
3013: ST_TO_ADDR
3014: LD_VAR 0 1
3018: PUSH
3019: FOR_TO
3020: IFFALSE 3042
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3022: LD_INT 1
3024: PPUSH
3025: LD_INT 1
3027: PPUSH
3028: LD_VAR 0 4
3032: PPUSH
3033: LD_INT 0
3035: PPUSH
3036: CALL_OW 59
3040: GO 3019
3042: POP
3043: POP
// for i = 1 to n2 do
3044: LD_ADDR_VAR 0 6
3048: PUSH
3049: DOUBLE
3050: LD_INT 1
3052: DEC
3053: ST_TO_ADDR
3054: LD_VAR 0 2
3058: PUSH
3059: FOR_TO
3060: IFFALSE 3082
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3062: LD_INT 2
3064: PPUSH
3065: LD_INT 1
3067: PPUSH
3068: LD_VAR 0 4
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL_OW 59
3080: GO 3059
3082: POP
3083: POP
// for i = 1 to n3 do
3084: LD_ADDR_VAR 0 6
3088: PUSH
3089: DOUBLE
3090: LD_INT 1
3092: DEC
3093: ST_TO_ADDR
3094: LD_VAR 0 3
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3102: LD_INT 3
3104: PPUSH
3105: LD_INT 1
3107: PPUSH
3108: LD_VAR 0 4
3112: PPUSH
3113: LD_INT 0
3115: PPUSH
3116: CALL_OW 59
3120: GO 3099
3122: POP
3123: POP
// end ; end_of_file
3124: LD_VAR 0 5
3128: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3129: LD_INT 0
3131: PPUSH
3132: PPUSH
3133: PPUSH
3134: PPUSH
3135: PPUSH
3136: PPUSH
// uc_side := your_side ;
3137: LD_ADDR_OWVAR 20
3141: PUSH
3142: LD_OWVAR 2
3146: ST_TO_ADDR
// uc_nation := nation_russian ;
3147: LD_ADDR_OWVAR 21
3151: PUSH
3152: LD_INT 3
3154: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3155: LD_ADDR_EXP 18
3159: PUSH
3160: LD_STRING Gladkov
3162: PPUSH
3163: CALL_OW 25
3167: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3168: LD_ADDR_EXP 19
3172: PUSH
3173: LD_STRING Davidov
3175: PPUSH
3176: CALL_OW 25
3180: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3181: LD_ADDR_EXP 20
3185: PUSH
3186: LD_STRING Burlak
3188: PPUSH
3189: CALL_OW 25
3193: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3194: LD_ADDR_EXP 21
3198: PUSH
3199: LD_STRING Stolypin
3201: PPUSH
3202: CALL_OW 25
3206: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3207: LD_ADDR_EXP 16
3211: PUSH
3212: LD_EXP 18
3216: PUSH
3217: LD_EXP 19
3221: PUSH
3222: LD_EXP 20
3226: PUSH
3227: LD_EXP 21
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3238: LD_ADDR_EXP 24
3242: PUSH
3243: LD_EXP 16
3247: PUSH
3248: LD_VAR 0 1
3252: ARRAY
3253: ST_TO_ADDR
// team := [ ] ;
3254: LD_ADDR_VAR 0 6
3258: PUSH
3259: EMPTY
3260: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3261: LD_ADDR_VAR 0 4
3265: PUSH
3266: LD_INT 4
3268: PUSH
3269: LD_INT 3
3271: PUSH
3272: LD_INT 3
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PUSH
3280: LD_OWVAR 67
3284: ARRAY
3285: ST_TO_ADDR
// hc_gallery :=  ;
3286: LD_ADDR_OWVAR 33
3290: PUSH
3291: LD_STRING 
3293: ST_TO_ADDR
// hc_name :=  ;
3294: LD_ADDR_OWVAR 26
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_importance := 0 ;
3302: LD_ADDR_OWVAR 32
3306: PUSH
3307: LD_INT 0
3309: ST_TO_ADDR
// case player_com of gladkov :
3310: LD_EXP 24
3314: PUSH
3315: LD_EXP 18
3319: DOUBLE
3320: EQUAL
3321: IFTRUE 3325
3323: GO 3470
3325: POP
// begin for i = 1 to 10 do
3326: LD_ADDR_VAR 0 3
3330: PUSH
3331: DOUBLE
3332: LD_INT 1
3334: DEC
3335: ST_TO_ADDR
3336: LD_INT 10
3338: PUSH
3339: FOR_TO
3340: IFFALSE 3379
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3342: LD_INT 0
3344: PPUSH
3345: LD_INT 1
3347: PPUSH
3348: LD_VAR 0 4
3352: PUSH
3353: LD_INT 1
3355: PLUS
3356: PPUSH
3357: CALL_OW 380
// team := team ^ CreateHuman ;
3361: LD_ADDR_VAR 0 6
3365: PUSH
3366: LD_VAR 0 6
3370: PUSH
3371: CALL_OW 44
3375: ADD
3376: ST_TO_ADDR
// end ;
3377: GO 3339
3379: POP
3380: POP
// for i = 1 to 15 do
3381: LD_ADDR_VAR 0 3
3385: PUSH
3386: DOUBLE
3387: LD_INT 1
3389: DEC
3390: ST_TO_ADDR
3391: LD_INT 15
3393: PUSH
3394: FOR_TO
3395: IFFALSE 3440
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3397: LD_INT 0
3399: PPUSH
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: MOD
3408: PUSH
3409: LD_INT 2
3411: PLUS
3412: PPUSH
3413: LD_VAR 0 4
3417: PPUSH
3418: CALL_OW 380
// team := team ^ CreateHuman ;
3422: LD_ADDR_VAR 0 6
3426: PUSH
3427: LD_VAR 0 6
3431: PUSH
3432: CALL_OW 44
3436: ADD
3437: ST_TO_ADDR
// end ;
3438: GO 3394
3440: POP
3441: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3442: LD_INT 44
3444: PPUSH
3445: LD_INT 3
3447: PPUSH
3448: LD_INT 1
3450: PPUSH
3451: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3455: LD_INT 34
3457: PPUSH
3458: LD_INT 3
3460: PPUSH
3461: LD_INT 1
3463: PPUSH
3464: CALL_OW 322
// end ; davidov :
3468: GO 4353
3470: LD_EXP 19
3474: DOUBLE
3475: EQUAL
3476: IFTRUE 3480
3478: GO 3755
3480: POP
// begin for i = 1 to 10 do
3481: LD_ADDR_VAR 0 3
3485: PUSH
3486: DOUBLE
3487: LD_INT 1
3489: DEC
3490: ST_TO_ADDR
3491: LD_INT 10
3493: PUSH
3494: FOR_TO
3495: IFFALSE 3534
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3497: LD_INT 0
3499: PPUSH
3500: LD_INT 4
3502: PPUSH
3503: LD_VAR 0 4
3507: PUSH
3508: LD_INT 1
3510: PLUS
3511: PPUSH
3512: CALL_OW 380
// team := team ^ CreateHuman ;
3516: LD_ADDR_VAR 0 6
3520: PUSH
3521: LD_VAR 0 6
3525: PUSH
3526: CALL_OW 44
3530: ADD
3531: ST_TO_ADDR
// end ;
3532: GO 3494
3534: POP
3535: POP
// for i = 1 to 15 do
3536: LD_ADDR_VAR 0 3
3540: PUSH
3541: DOUBLE
3542: LD_INT 1
3544: DEC
3545: ST_TO_ADDR
3546: LD_INT 15
3548: PUSH
3549: FOR_TO
3550: IFFALSE 3595
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3552: LD_INT 0
3554: PPUSH
3555: LD_VAR 0 3
3559: PUSH
3560: LD_INT 3
3562: MOD
3563: PUSH
3564: LD_INT 1
3566: PLUS
3567: PPUSH
3568: LD_VAR 0 4
3572: PPUSH
3573: CALL_OW 380
// team := team ^ CreateHuman ;
3577: LD_ADDR_VAR 0 6
3581: PUSH
3582: LD_VAR 0 6
3586: PUSH
3587: CALL_OW 44
3591: ADD
3592: ST_TO_ADDR
// end ;
3593: GO 3549
3595: POP
3596: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3597: LD_INT 34
3599: PPUSH
3600: LD_INT 3
3602: PPUSH
3603: LD_INT 1
3605: PPUSH
3606: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3610: LD_INT 32
3612: PPUSH
3613: LD_INT 3
3615: PPUSH
3616: LD_INT 1
3618: PPUSH
3619: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3623: LD_INT 27
3625: PPUSH
3626: LD_INT 3
3628: PPUSH
3629: LD_INT 1
3631: PPUSH
3632: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3636: LD_INT 30
3638: PPUSH
3639: LD_INT 3
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3649: LD_INT 63
3651: PPUSH
3652: LD_INT 3
3654: PPUSH
3655: LD_INT 1
3657: PPUSH
3658: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3662: LD_INT 57
3664: PPUSH
3665: LD_INT 3
3667: PPUSH
3668: LD_INT 1
3670: PPUSH
3671: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3675: LD_INT 58
3677: PPUSH
3678: LD_INT 3
3680: PPUSH
3681: LD_INT 1
3683: PPUSH
3684: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3688: LD_INT 8
3690: PPUSH
3691: LD_INT 3
3693: PPUSH
3694: LD_INT 1
3696: PPUSH
3697: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3701: LD_INT 12
3703: PPUSH
3704: LD_INT 3
3706: PPUSH
3707: LD_INT 1
3709: PPUSH
3710: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3714: LD_INT 14
3716: PPUSH
3717: LD_INT 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3727: LD_INT 24
3729: PPUSH
3730: LD_INT 3
3732: PPUSH
3733: LD_INT 1
3735: PPUSH
3736: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3740: LD_INT 33
3742: PPUSH
3743: LD_INT 3
3745: PPUSH
3746: LD_INT 1
3748: PPUSH
3749: CALL_OW 324
// end ; gorki :
3753: GO 4353
3755: LD_EXP 20
3759: DOUBLE
3760: EQUAL
3761: IFTRUE 3765
3763: GO 4046
3765: POP
// begin for i = 1 to 10 do
3766: LD_ADDR_VAR 0 3
3770: PUSH
3771: DOUBLE
3772: LD_INT 1
3774: DEC
3775: ST_TO_ADDR
3776: LD_INT 10
3778: PUSH
3779: FOR_TO
3780: IFFALSE 3834
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3782: LD_INT 0
3784: PPUSH
3785: LD_INT 3
3787: PPUSH
3788: LD_VAR 0 4
3792: PUSH
3793: LD_INT 1
3795: PLUS
3796: PPUSH
3797: CALL_OW 380
// team := team ^ CreateHuman ;
3801: LD_ADDR_VAR 0 6
3805: PUSH
3806: LD_VAR 0 6
3810: PUSH
3811: CALL_OW 44
3815: ADD
3816: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3817: LD_VAR 0 6
3821: PUSH
3822: LD_VAR 0 6
3826: ARRAY
3827: PPUSH
3828: CALL 7693 0 1
// end ;
3832: GO 3779
3834: POP
3835: POP
// for i = 1 to 15 do
3836: LD_ADDR_VAR 0 3
3840: PUSH
3841: DOUBLE
3842: LD_INT 1
3844: DEC
3845: ST_TO_ADDR
3846: LD_INT 15
3848: PUSH
3849: FOR_TO
3850: IFFALSE 3923
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3852: LD_INT 0
3854: PPUSH
3855: LD_INT 1
3857: PUSH
3858: LD_INT 2
3860: PUSH
3861: LD_INT 4
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: LIST
3868: PUSH
3869: LD_INT 1
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: CALL_OW 12
3879: ARRAY
3880: PPUSH
3881: LD_VAR 0 4
3885: PPUSH
3886: CALL_OW 380
// team := team ^ CreateHuman ;
3890: LD_ADDR_VAR 0 6
3894: PUSH
3895: LD_VAR 0 6
3899: PUSH
3900: CALL_OW 44
3904: ADD
3905: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3906: LD_VAR 0 6
3910: PUSH
3911: LD_VAR 0 6
3915: ARRAY
3916: PPUSH
3917: CALL 7693 0 1
// end ;
3921: GO 3849
3923: POP
3924: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3925: LD_INT 40
3927: PPUSH
3928: LD_INT 3
3930: PPUSH
3931: LD_INT 1
3933: PPUSH
3934: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3938: LD_INT 34
3940: PPUSH
3941: LD_INT 3
3943: PPUSH
3944: LD_INT 1
3946: PPUSH
3947: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3951: LD_INT 18
3953: PPUSH
3954: LD_INT 3
3956: PPUSH
3957: LD_INT 1
3959: PPUSH
3960: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3964: LD_ADDR_OWVAR 37
3968: PUSH
3969: LD_INT 22
3971: ST_TO_ADDR
// vc_engine := engine_combustion ;
3972: LD_ADDR_OWVAR 39
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// vc_control := control_manual ;
3980: LD_ADDR_OWVAR 38
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3988: LD_ADDR_OWVAR 40
3992: PUSH
3993: LD_INT 45
3995: ST_TO_ADDR
// vc_fuel_battery := 3 ;
3996: LD_ADDR_OWVAR 41
4000: PUSH
4001: LD_INT 3
4003: ST_TO_ADDR
// veh := CreateVehicle ;
4004: LD_ADDR_VAR 0 7
4008: PUSH
4009: CALL_OW 45
4013: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4014: LD_VAR 0 7
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4026: LD_VAR 0 7
4030: PPUSH
4031: LD_INT 107
4033: PPUSH
4034: LD_INT 83
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: CALL_OW 48
// end ; stolypin :
4044: GO 4353
4046: LD_EXP 21
4050: DOUBLE
4051: EQUAL
4052: IFTRUE 4056
4054: GO 4352
4056: POP
// begin for i = 1 to 10 do
4057: LD_ADDR_VAR 0 3
4061: PUSH
4062: DOUBLE
4063: LD_INT 1
4065: DEC
4066: ST_TO_ADDR
4067: LD_INT 10
4069: PUSH
4070: FOR_TO
4071: IFFALSE 4110
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4073: LD_INT 0
4075: PPUSH
4076: LD_INT 2
4078: PPUSH
4079: LD_VAR 0 4
4083: PUSH
4084: LD_INT 1
4086: PLUS
4087: PPUSH
4088: CALL_OW 380
// team := team ^ CreateHuman ;
4092: LD_ADDR_VAR 0 6
4096: PUSH
4097: LD_VAR 0 6
4101: PUSH
4102: CALL_OW 44
4106: ADD
4107: ST_TO_ADDR
// end ;
4108: GO 4070
4110: POP
4111: POP
// for i = 1 to 15 do
4112: LD_ADDR_VAR 0 3
4116: PUSH
4117: DOUBLE
4118: LD_INT 1
4120: DEC
4121: ST_TO_ADDR
4122: LD_INT 15
4124: PUSH
4125: FOR_TO
4126: IFFALSE 4184
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4128: LD_INT 0
4130: PPUSH
4131: LD_INT 1
4133: PUSH
4134: LD_INT 3
4136: PUSH
4137: LD_INT 4
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: PUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_INT 3
4150: PPUSH
4151: CALL_OW 12
4155: ARRAY
4156: PPUSH
4157: LD_VAR 0 4
4161: PPUSH
4162: CALL_OW 380
// team := team ^ CreateHuman ;
4166: LD_ADDR_VAR 0 6
4170: PUSH
4171: LD_VAR 0 6
4175: PUSH
4176: CALL_OW 44
4180: ADD
4181: ST_TO_ADDR
// end ;
4182: GO 4125
4184: POP
4185: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4186: LD_INT 34
4188: PPUSH
4189: LD_INT 3
4191: PPUSH
4192: LD_INT 1
4194: PPUSH
4195: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4199: LD_ADDR_OWVAR 37
4203: PUSH
4204: LD_INT 22
4206: ST_TO_ADDR
// vc_engine := engine_combustion ;
4207: LD_ADDR_OWVAR 39
4211: PUSH
4212: LD_INT 1
4214: ST_TO_ADDR
// vc_control := control_manual ;
4215: LD_ADDR_OWVAR 38
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4223: LD_ADDR_OWVAR 40
4227: PUSH
4228: LD_INT 51
4230: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4231: LD_ADDR_OWVAR 41
4235: PUSH
4236: LD_INT 30
4238: ST_TO_ADDR
// veh := CreateVehicle ;
4239: LD_ADDR_VAR 0 7
4243: PUSH
4244: CALL_OW 45
4248: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4249: LD_VAR 0 7
4253: PPUSH
4254: LD_INT 1
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4264: LD_VAR 0 7
4268: PPUSH
4269: LD_INT 107
4271: PPUSH
4272: LD_INT 83
4274: PPUSH
4275: LD_INT 0
4277: PPUSH
4278: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4282: LD_ADDR_OWVAR 37
4286: PUSH
4287: LD_INT 22
4289: ST_TO_ADDR
// vc_engine := engine_combustion ;
4290: LD_ADDR_OWVAR 39
4294: PUSH
4295: LD_INT 1
4297: ST_TO_ADDR
// vc_control := control_manual ;
4298: LD_ADDR_OWVAR 38
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_weapon := ru_crane ;
4306: LD_ADDR_OWVAR 40
4310: PUSH
4311: LD_INT 52
4313: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4314: LD_ADDR_OWVAR 41
4318: PUSH
4319: LD_INT 30
4321: ST_TO_ADDR
// veh := CreateVehicle ;
4322: LD_ADDR_VAR 0 7
4326: PUSH
4327: CALL_OW 45
4331: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4332: LD_VAR 0 7
4336: PPUSH
4337: LD_INT 115
4339: PPUSH
4340: LD_INT 96
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: CALL_OW 48
// end ; end ;
4350: GO 4353
4352: POP
// if isTest then
4353: LD_EXP 1
4357: IFFALSE 4371
// tmp := team else
4359: LD_ADDR_VAR 0 5
4363: PUSH
4364: LD_VAR 0 6
4368: ST_TO_ADDR
4369: GO 4435
// tmp := CharacterSelection ( text , 12 , 12 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_STRING text
4378: PPUSH
4379: LD_INT 12
4381: PPUSH
4382: LD_INT 12
4384: PPUSH
4385: LD_INT -2
4387: PUSH
4388: LD_INT -5
4390: PUSH
4391: LD_INT -3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: LIST
4398: PUSH
4399: LD_VAR 0 6
4403: ADD
4404: PPUSH
4405: LD_INT 1
4407: PUSH
4408: LD_INT 2
4410: PUSH
4411: LD_INT 1
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 3
4420: PUSH
4421: LD_INT 4
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: PPUSH
4430: CALL_OW 42
4434: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4435: LD_EXP 24
4439: PPUSH
4440: LD_INT 9
4442: PPUSH
4443: LD_INT 0
4445: PPUSH
4446: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4450: LD_VAR 0 5
4454: PUSH
4455: LD_INT 1
4457: ARRAY
4458: PPUSH
4459: LD_INT 2
4461: PPUSH
4462: CALL_OW 336
// for i = 1 to tmp do
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: DOUBLE
4472: LD_INT 1
4474: DEC
4475: ST_TO_ADDR
4476: LD_VAR 0 5
4480: PUSH
4481: FOR_TO
4482: IFFALSE 4537
// if i < 4 then
4484: LD_VAR 0 3
4488: PUSH
4489: LD_INT 4
4491: LESS
4492: IFFALSE 4517
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4494: LD_VAR 0 5
4498: PUSH
4499: LD_VAR 0 3
4503: ARRAY
4504: PPUSH
4505: LD_INT 9
4507: PPUSH
4508: LD_INT 0
4510: PPUSH
4511: CALL_OW 49
4515: GO 4535
// SetSide ( tmp [ i ] , 6 ) ;
4517: LD_VAR 0 5
4521: PUSH
4522: LD_VAR 0 3
4526: ARRAY
4527: PPUSH
4528: LD_INT 6
4530: PPUSH
4531: CALL_OW 235
4535: GO 4481
4537: POP
4538: POP
// player_squad := tmp ;
4539: LD_ADDR_EXP 22
4543: PUSH
4544: LD_VAR 0 5
4548: ST_TO_ADDR
// pl_counter := 4 ;
4549: LD_ADDR_EXP 23
4553: PUSH
4554: LD_INT 4
4556: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4557: LD_INT 17
4559: PPUSH
4560: LD_INT 5
4562: PPUSH
4563: LD_INT 1
4565: PPUSH
4566: CALL 18134 0 3
// end ;
4570: LD_VAR 0 2
4574: RET
// export Popov ; export function InitAction ; var commander ; begin
4575: LD_INT 0
4577: PPUSH
4578: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4579: LD_INT 6
4581: PPUSH
4582: LD_INT 3
4584: PPUSH
4585: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4589: LD_INT 1
4591: PPUSH
4592: LD_INT 1
4594: PPUSH
4595: CALL_OW 86
// uc_side := 6 ;
4599: LD_ADDR_OWVAR 20
4603: PUSH
4604: LD_INT 6
4606: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4607: LD_ADDR_EXP 25
4611: PUSH
4612: LD_STRING Popov
4614: PPUSH
4615: CALL_OW 25
4619: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4620: LD_ADDR_OWVAR 67
4624: PUSH
4625: LD_INT 0
4627: PPUSH
4628: CALL_OW 426
4632: ST_TO_ADDR
// if not Difficulty then
4633: LD_OWVAR 67
4637: NOT
4638: IFFALSE 4648
// Difficulty := 2 ;
4640: LD_ADDR_OWVAR 67
4644: PUSH
4645: LD_INT 2
4647: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4648: LD_ADDR_VAR 0 2
4652: PUSH
4653: LD_INT 1
4655: PPUSH
4656: CALL_OW 426
4660: ST_TO_ADDR
// if not commander then
4661: LD_VAR 0 2
4665: NOT
4666: IFFALSE 4676
// commander := 1 ;
4668: LD_ADDR_VAR 0 2
4672: PUSH
4673: LD_INT 1
4675: ST_TO_ADDR
// InitCommanders ( commander ) ;
4676: LD_VAR 0 2
4680: PPUSH
4681: CALL 3129 0 1
// end ;
4685: LD_VAR 0 1
4689: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4690: LD_EXP 23
4694: PUSH
4695: LD_INT 12
4697: LESS
4698: IFFALSE 4871
4700: GO 4702
4702: DISABLE
4703: LD_INT 0
4705: PPUSH
// begin enable ;
4706: ENABLE
// for i = pl_counter to pl_counter + 2 do
4707: LD_ADDR_VAR 0 1
4711: PUSH
4712: DOUBLE
4713: LD_EXP 23
4717: DEC
4718: ST_TO_ADDR
4719: LD_EXP 23
4723: PUSH
4724: LD_INT 2
4726: PLUS
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4775
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4731: LD_EXP 22
4735: PUSH
4736: LD_VAR 0 1
4740: ARRAY
4741: PPUSH
4742: LD_INT 18
4744: PPUSH
4745: LD_INT 0
4747: PPUSH
4748: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4752: LD_EXP 22
4756: PUSH
4757: LD_VAR 0 1
4761: ARRAY
4762: PPUSH
4763: LD_INT 107
4765: PPUSH
4766: LD_INT 88
4768: PPUSH
4769: CALL_OW 111
// end ;
4773: GO 4728
4775: POP
4776: POP
// for i = pl_counter to pl_counter + 2 do
4777: LD_ADDR_VAR 0 1
4781: PUSH
4782: DOUBLE
4783: LD_EXP 23
4787: DEC
4788: ST_TO_ADDR
4789: LD_EXP 23
4793: PUSH
4794: LD_INT 2
4796: PLUS
4797: PUSH
4798: FOR_TO
4799: IFFALSE 4855
// begin repeat wait ( 0 0$01 ) ;
4801: LD_INT 35
4803: PPUSH
4804: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4808: LD_EXP 22
4812: PUSH
4813: LD_VAR 0 1
4817: ARRAY
4818: PPUSH
4819: LD_INT 107
4821: PPUSH
4822: LD_INT 88
4824: PPUSH
4825: CALL_OW 297
4829: PUSH
4830: LD_INT 6
4832: LESS
4833: IFFALSE 4801
// SetSide ( player_squad [ i ] , 3 ) ;
4835: LD_EXP 22
4839: PUSH
4840: LD_VAR 0 1
4844: ARRAY
4845: PPUSH
4846: LD_INT 3
4848: PPUSH
4849: CALL_OW 235
// end ;
4853: GO 4798
4855: POP
4856: POP
// pl_counter := pl_counter + 3 ;
4857: LD_ADDR_EXP 23
4861: PUSH
4862: LD_EXP 23
4866: PUSH
4867: LD_INT 3
4869: PLUS
4870: ST_TO_ADDR
// end ;
4871: PPOPN 1
4873: END
// export function Dialog ; begin
4874: LD_INT 0
4876: PPUSH
// if not isTest then
4877: LD_EXP 1
4881: NOT
4882: IFFALSE 4904
// case query ( task ) of 1 :
4884: LD_STRING task
4886: PPUSH
4887: CALL_OW 97
4891: PUSH
4892: LD_INT 1
4894: DOUBLE
4895: EQUAL
4896: IFTRUE 4900
4898: GO 4903
4900: POP
// ; end ;
4901: GO 4904
4903: POP
// InGameOn ;
4904: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4908: LD_INT 107
4910: PPUSH
4911: LD_INT 84
4913: PPUSH
4914: CALL_OW 86
// if isTest then
4918: LD_EXP 1
4922: IFFALSE 4932
// dialogue_skipped := true ;
4924: LD_ADDR_OWVAR 59
4928: PUSH
4929: LD_INT 1
4931: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4932: LD_ADDR_EXP 10
4936: PUSH
4937: LD_EXP 22
4941: PUSH
4942: LD_INT 1
4944: ARRAY
4945: PPUSH
4946: LD_INT 0
4948: PPUSH
4949: LD_INT 96
4951: PPUSH
4952: LD_INT 79
4954: PPUSH
4955: LD_INT 2
4957: PPUSH
4958: CALL_OW 145
4962: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4963: LD_INT 35
4965: PPUSH
4966: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
4970: LD_EXP 25
4974: PPUSH
4975: LD_STRING DR1
4977: PPUSH
4978: CALL_OW 94
// Wait ( 0 0$01 ) ;
4982: LD_INT 35
4984: PPUSH
4985: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
4989: LD_EXP 25
4993: PPUSH
4994: LD_STRING DR2
4996: PPUSH
4997: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5001: LD_EXP 25
5005: PPUSH
5006: LD_STRING DR3
5008: PPUSH
5009: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5013: LD_INT 35
5015: PPUSH
5016: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5020: LD_INT 3
5022: PPUSH
5023: LD_INT 30
5025: PUSH
5026: LD_INT 0
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL 11421 0 2
5037: PUSH
5038: LD_EXP 1
5042: OR
5043: IFFALSE 5013
// InGameOff ;
5045: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5049: LD_STRING C1
5051: PPUSH
5052: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5056: LD_INT 35
5058: PPUSH
5059: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5063: LD_EXP 10
5067: PPUSH
5068: CALL_OW 461
5072: PUSH
5073: LD_INT 2
5075: EQUAL
5076: IFFALSE 5056
// if not isTest then
5078: LD_EXP 1
5082: NOT
5083: IFFALSE 5105
// case query ( support ) of 1 :
5085: LD_STRING support
5087: PPUSH
5088: CALL_OW 97
5092: PUSH
5093: LD_INT 1
5095: DOUBLE
5096: EQUAL
5097: IFTRUE 5101
5099: GO 5104
5101: POP
// ; end ;
5102: GO 5105
5104: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5105: LD_INT 3
5107: PPUSH
5108: LD_INT 12
5110: PPUSH
5111: LD_INT 2
5113: PPUSH
5114: LD_INT 22
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: LD_INT 30
5126: PUSH
5127: LD_INT 0
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PPUSH
5138: CALL_OW 69
5142: PUSH
5143: LD_INT 1
5145: ARRAY
5146: PPUSH
5147: CALL_OW 468
// if player_com = stolypin then
5151: LD_EXP 24
5155: PUSH
5156: LD_EXP 21
5160: EQUAL
5161: IFFALSE 5190
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5163: LD_INT 18
5165: PPUSH
5166: LD_INT 3
5168: PUSH
5169: LD_INT 3
5171: PUSH
5172: LD_INT 2
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_OWVAR 67
5184: ARRAY
5185: PPUSH
5186: CALL 6490 0 2
// end ;
5190: LD_VAR 0 1
5194: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5195: LD_EXP 11
5199: PUSH
5200: LD_OWVAR 1
5204: PUSH
5205: LD_INT 31500
5207: LESS
5208: AND
5209: IFFALSE 5373
// case query ( call1 ) of 1 :
5211: LD_STRING call1
5213: PPUSH
5214: CALL_OW 97
5218: PUSH
5219: LD_INT 1
5221: DOUBLE
5222: EQUAL
5223: IFTRUE 5227
5225: GO 5361
5227: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5228: LD_INT 3
5230: PPUSH
5231: LD_INT 12
5233: PPUSH
5234: LD_INT 1
5236: PPUSH
5237: LD_EXP 10
5241: PPUSH
5242: CALL_OW 468
// call := false ;
5246: LD_ADDR_EXP 11
5250: PUSH
5251: LD_INT 0
5253: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5254: LD_EXP 25
5258: PPUSH
5259: LD_STRING DR6
5261: PPUSH
5262: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5266: LD_INT 6300
5268: PPUSH
5269: LD_INT 8400
5271: PPUSH
5272: CALL_OW 12
5276: PPUSH
5277: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5281: LD_INT 18
5283: PUSH
5284: LD_INT 19
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: LD_INT 1
5293: PPUSH
5294: LD_INT 2
5296: PPUSH
5297: CALL_OW 12
5301: ARRAY
5302: PPUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: PPUSH
5314: CALL 6490 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5318: LD_INT 25200
5320: PPUSH
5321: LD_INT 35700
5323: PPUSH
5324: CALL_OW 12
5328: PPUSH
5329: CALL_OW 67
// call := true ;
5333: LD_ADDR_EXP 11
5337: PUSH
5338: LD_INT 1
5340: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5341: LD_INT 3
5343: PPUSH
5344: LD_INT 12
5346: PPUSH
5347: LD_INT 2
5349: PPUSH
5350: LD_EXP 10
5354: PPUSH
5355: CALL_OW 468
// end ; 2 :
5359: GO 5373
5361: LD_INT 2
5363: DOUBLE
5364: EQUAL
5365: IFTRUE 5369
5367: GO 5372
5369: POP
// ; end ;
5370: GO 5373
5372: POP
// if call and tick >= 15 15$00 then
5373: LD_EXP 11
5377: PUSH
5378: LD_OWVAR 1
5382: PUSH
5383: LD_INT 31500
5385: GREATEREQUAL
5386: AND
5387: IFFALSE 5816
// case query ( call2 ) of 1 :
5389: LD_STRING call2
5391: PPUSH
5392: CALL_OW 97
5396: PUSH
5397: LD_INT 1
5399: DOUBLE
5400: EQUAL
5401: IFTRUE 5405
5403: GO 5641
5405: POP
// begin call := false ;
5406: LD_ADDR_EXP 11
5410: PUSH
5411: LD_INT 0
5413: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5414: LD_INT 1
5416: PPUSH
5417: LD_INT 21
5419: PUSH
5420: LD_INT 3
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PPUSH
5427: CALL 11421 0 2
5431: PUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11421 0 2
5449: AND
5450: IFFALSE 5498
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5452: LD_INT 18
5454: PUSH
5455: LD_INT 19
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 1
5464: PPUSH
5465: LD_INT 2
5467: PPUSH
5468: CALL_OW 12
5472: ARRAY
5473: PPUSH
5474: LD_INT 5
5476: PUSH
5477: LD_INT 4
5479: PUSH
5480: LD_INT 4
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: LD_OWVAR 67
5492: ARRAY
5493: PPUSH
5494: CALL 6251 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5498: LD_INT 1
5500: PPUSH
5501: LD_INT 21
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PPUSH
5511: CALL 11421 0 2
5515: PUSH
5516: LD_INT 0
5518: EQUAL
5519: IFFALSE 5548
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5521: LD_INT 19
5523: PPUSH
5524: LD_INT 5
5526: PUSH
5527: LD_INT 4
5529: PUSH
5530: LD_INT 3
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: LD_OWVAR 67
5542: ARRAY
5543: PPUSH
5544: CALL 6251 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5548: LD_INT 4
5550: PPUSH
5551: LD_INT 21
5553: PUSH
5554: LD_INT 3
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PPUSH
5561: CALL 11421 0 2
5565: PUSH
5566: LD_INT 0
5568: EQUAL
5569: IFFALSE 5598
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5571: LD_INT 18
5573: PPUSH
5574: LD_INT 5
5576: PUSH
5577: LD_INT 4
5579: PUSH
5580: LD_INT 4
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: PUSH
5588: LD_OWVAR 67
5592: ARRAY
5593: PPUSH
5594: CALL 6251 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5598: LD_INT 10500
5600: PPUSH
5601: LD_INT 23100
5603: PPUSH
5604: CALL_OW 12
5608: PPUSH
5609: CALL_OW 67
// call := true ;
5613: LD_ADDR_EXP 11
5617: PUSH
5618: LD_INT 1
5620: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 12
5626: PPUSH
5627: LD_INT 2
5629: PPUSH
5630: LD_EXP 10
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5816
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5804
5649: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5650: LD_INT 3
5652: PPUSH
5653: LD_INT 12
5655: PPUSH
5656: LD_INT 1
5658: PPUSH
5659: LD_EXP 10
5663: PPUSH
5664: CALL_OW 468
// call := false ;
5668: LD_ADDR_EXP 11
5672: PUSH
5673: LD_INT 0
5675: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5676: LD_EXP 25
5680: PPUSH
5681: LD_STRING DR6
5683: PPUSH
5684: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5688: LD_INT 6300
5690: PPUSH
5691: LD_INT 8400
5693: PPUSH
5694: CALL_OW 12
5698: PPUSH
5699: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5703: LD_INT 18
5705: PUSH
5706: LD_INT 19
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 1
5715: PPUSH
5716: LD_INT 2
5718: PPUSH
5719: CALL_OW 12
5723: ARRAY
5724: PPUSH
5725: LD_INT 3
5727: PUSH
5728: LD_INT 2
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: LIST
5738: PUSH
5739: LD_OWVAR 67
5743: ARRAY
5744: PUSH
5745: LD_INT 0
5747: PPUSH
5748: LD_INT 1
5750: PPUSH
5751: CALL_OW 12
5755: MINUS
5756: PPUSH
5757: CALL 6490 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5761: LD_INT 35700
5763: PPUSH
5764: LD_INT 44100
5766: PPUSH
5767: CALL_OW 12
5771: PPUSH
5772: CALL_OW 67
// call := true ;
5776: LD_ADDR_EXP 11
5780: PUSH
5781: LD_INT 1
5783: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5784: LD_INT 3
5786: PPUSH
5787: LD_INT 12
5789: PPUSH
5790: LD_INT 2
5792: PPUSH
5793: LD_EXP 10
5797: PPUSH
5798: CALL_OW 468
// end ; 3 :
5802: GO 5816
5804: LD_INT 3
5806: DOUBLE
5807: EQUAL
5808: IFTRUE 5812
5810: GO 5815
5812: POP
// ; end ;
5813: GO 5816
5815: POP
// end ;
5816: PPOPN 4
5818: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5819: LD_INT 22
5821: PUSH
5822: LD_INT 1
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 21
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PPUSH
5843: CALL_OW 69
5847: PUSH
5848: LD_INT 0
5850: EQUAL
5851: PUSH
5852: LD_INT 22
5854: PUSH
5855: LD_INT 4
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 21
5864: PUSH
5865: LD_INT 1
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PPUSH
5876: CALL_OW 69
5880: PUSH
5881: LD_INT 0
5883: EQUAL
5884: AND
5885: IFFALSE 6089
5887: GO 5889
5889: DISABLE
// begin DialogueOn ;
5890: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5894: LD_EXP 25
5898: PPUSH
5899: LD_STRING DR7
5901: PPUSH
5902: CALL_OW 94
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
5906: LD_OWVAR 1
5910: PUSH
5911: LD_INT 116550
5913: PUSH
5914: LD_INT 95550
5916: PUSH
5917: LD_INT 89250
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_OWVAR 67
5929: ARRAY
5930: LESS
5931: IFFALSE 5945
// AddMedal ( med1 , 1 ) else
5933: LD_STRING med1
5935: PPUSH
5936: LD_INT 1
5938: PPUSH
5939: CALL_OW 101
5943: GO 5956
// AddMedal ( med1 , - 1 ) ;
5945: LD_STRING med1
5947: PPUSH
5948: LD_INT 1
5950: NEG
5951: PPUSH
5952: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
5956: LD_INT 81
5958: PUSH
5959: LD_INT 3
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: PUSH
5966: LD_INT 21
5968: PUSH
5969: LD_INT 3
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 69
5984: PUSH
5985: LD_INT 0
5987: EQUAL
5988: IFFALSE 6002
// AddMedal ( med3 , 1 ) else
5990: LD_STRING med3
5992: PPUSH
5993: LD_INT 1
5995: PPUSH
5996: CALL_OW 101
6000: GO 6013
// AddMedal ( med3 , - 1 ) ;
6002: LD_STRING med3
6004: PPUSH
6005: LD_INT 1
6007: NEG
6008: PPUSH
6009: CALL_OW 101
// if player_loss = 0 then
6013: LD_EXP 9
6017: PUSH
6018: LD_INT 0
6020: EQUAL
6021: IFFALSE 6035
// AddMedal ( med2 , 1 ) else
6023: LD_STRING med2
6025: PPUSH
6026: LD_INT 1
6028: PPUSH
6029: CALL_OW 101
6033: GO 6078
// if player_loss > 0 and player_loss < 3 then
6035: LD_EXP 9
6039: PUSH
6040: LD_INT 0
6042: GREATER
6043: PUSH
6044: LD_EXP 9
6048: PUSH
6049: LD_INT 3
6051: LESS
6052: AND
6053: IFFALSE 6067
// AddMedal ( med2 , 2 ) else
6055: LD_STRING med2
6057: PPUSH
6058: LD_INT 2
6060: PPUSH
6061: CALL_OW 101
6065: GO 6078
// AddMedal ( med2 , - 1 ) ;
6067: LD_STRING med2
6069: PPUSH
6070: LD_INT 1
6072: NEG
6073: PPUSH
6074: CALL_OW 101
// GiveMedals ( MAIN ) ;
6078: LD_STRING MAIN
6080: PPUSH
6081: CALL_OW 102
// YouWin ;
6085: CALL_OW 103
// end ;
6089: END
// every 0 0$01 trigger IsDead ( player_com ) do
6090: LD_EXP 24
6094: PPUSH
6095: CALL_OW 301
6099: IFFALSE 6166
6101: GO 6103
6103: DISABLE
// begin if IsLive ( Houten ) then
6104: LD_EXP 3
6108: PPUSH
6109: CALL_OW 300
6113: IFFALSE 6129
// SayRadio ( Houten , DJ5 ) else
6115: LD_EXP 3
6119: PPUSH
6120: LD_STRING DJ5
6122: PPUSH
6123: CALL_OW 94
6127: GO 6152
// if IsLive ( Brown ) then
6129: LD_EXP 4
6133: PPUSH
6134: CALL_OW 300
6138: IFFALSE 6152
// SayRadio ( Brown , DS5 ) ;
6140: LD_EXP 4
6144: PPUSH
6145: LD_STRING DS5
6147: PPUSH
6148: CALL_OW 94
// Wait ( 0 0$01 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// YouLost ( dead ) ;
6159: LD_STRING dead
6161: PPUSH
6162: CALL_OW 104
// end ;
6166: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6167: LD_EXP 10
6171: PPUSH
6172: CALL_OW 301
6176: PUSH
6177: LD_EXP 1
6181: NOT
6182: AND
6183: IFFALSE 6250
6185: GO 6187
6187: DISABLE
// begin if IsLive ( Brown ) then
6188: LD_EXP 4
6192: PPUSH
6193: CALL_OW 300
6197: IFFALSE 6213
// SayRadio ( Brown , DS5 ) else
6199: LD_EXP 4
6203: PPUSH
6204: LD_STRING DS5
6206: PPUSH
6207: CALL_OW 94
6211: GO 6236
// if IsLive ( Houten ) then
6213: LD_EXP 3
6217: PPUSH
6218: CALL_OW 300
6222: IFFALSE 6236
// SayRadio ( Houten , DJ5 ) ;
6224: LD_EXP 3
6228: PPUSH
6229: LD_STRING DJ5
6231: PPUSH
6232: CALL_OW 94
// Wait ( 0 0$01 ) ;
6236: LD_INT 35
6238: PPUSH
6239: CALL_OW 67
// YouLost ( depot ) ;
6243: LD_STRING depot
6245: PPUSH
6246: CALL_OW 104
// end ;
6250: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6251: LD_INT 0
6253: PPUSH
6254: PPUSH
6255: PPUSH
// for i = 1 to n do
6256: LD_ADDR_VAR 0 4
6260: PUSH
6261: DOUBLE
6262: LD_INT 1
6264: DEC
6265: ST_TO_ADDR
6266: LD_VAR 0 2
6270: PUSH
6271: FOR_TO
6272: IFFALSE 6475
// begin uc_side := 6 ;
6274: LD_ADDR_OWVAR 20
6278: PUSH
6279: LD_INT 6
6281: ST_TO_ADDR
// uc_nation := 3 ;
6282: LD_ADDR_OWVAR 21
6286: PUSH
6287: LD_INT 3
6289: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6290: LD_ADDR_OWVAR 37
6294: PUSH
6295: LD_INT 23
6297: PUSH
6298: LD_INT 22
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: LD_INT 1
6307: PPUSH
6308: LD_INT 2
6310: PPUSH
6311: CALL_OW 12
6315: ARRAY
6316: ST_TO_ADDR
// vc_control := control_computer ;
6317: LD_ADDR_OWVAR 38
6321: PUSH
6322: LD_INT 3
6324: ST_TO_ADDR
// vc_engine := engine_siberite ;
6325: LD_ADDR_OWVAR 39
6329: PUSH
6330: LD_INT 3
6332: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6333: LD_ADDR_OWVAR 40
6337: PUSH
6338: LD_INT 43
6340: PUSH
6341: LD_INT 44
6343: PUSH
6344: LD_INT 44
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_INT 1
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: CALL_OW 12
6362: ARRAY
6363: ST_TO_ADDR
// un := CreateVehicle ;
6364: LD_ADDR_VAR 0 5
6368: PUSH
6369: CALL_OW 45
6373: ST_TO_ADDR
// case area of east_arr :
6374: LD_VAR 0 1
6378: PUSH
6379: LD_INT 18
6381: DOUBLE
6382: EQUAL
6383: IFTRUE 6387
6385: GO 6422
6387: POP
// begin PlaceUnitArea ( un , area , false ) ;
6388: LD_VAR 0 5
6392: PPUSH
6393: LD_VAR 0 1
6397: PPUSH
6398: LD_INT 0
6400: PPUSH
6401: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6405: LD_VAR 0 5
6409: PPUSH
6410: LD_INT 79
6412: PPUSH
6413: LD_INT 33
6415: PPUSH
6416: CALL_OW 111
// end ; south_arr :
6420: GO 6466
6422: LD_INT 19
6424: DOUBLE
6425: EQUAL
6426: IFTRUE 6430
6428: GO 6465
6430: POP
// begin PlaceUnitArea ( un , area , false ) ;
6431: LD_VAR 0 5
6435: PPUSH
6436: LD_VAR 0 1
6440: PPUSH
6441: LD_INT 0
6443: PPUSH
6444: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6448: LD_VAR 0 5
6452: PPUSH
6453: LD_INT 131
6455: PPUSH
6456: LD_INT 148
6458: PPUSH
6459: CALL_OW 111
// end ; end ;
6463: GO 6466
6465: POP
// Wait ( 0 0$02 ) ;
6466: LD_INT 70
6468: PPUSH
6469: CALL_OW 67
// end ;
6473: GO 6271
6475: POP
6476: POP
// pink_attack := true ;
6477: LD_ADDR_EXP 12
6481: PUSH
6482: LD_INT 1
6484: ST_TO_ADDR
// end ;
6485: LD_VAR 0 3
6489: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6490: LD_INT 0
6492: PPUSH
6493: PPUSH
6494: PPUSH
// for i = 1 to n do
6495: LD_ADDR_VAR 0 4
6499: PUSH
6500: DOUBLE
6501: LD_INT 1
6503: DEC
6504: ST_TO_ADDR
6505: LD_VAR 0 2
6509: PUSH
6510: FOR_TO
6511: IFFALSE 6737
// begin uc_side := 6 ;
6513: LD_ADDR_OWVAR 20
6517: PUSH
6518: LD_INT 6
6520: ST_TO_ADDR
// uc_nation := 3 ;
6521: LD_ADDR_OWVAR 21
6525: PUSH
6526: LD_INT 3
6528: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6529: LD_INT 0
6531: PPUSH
6532: LD_INT 3
6534: PPUSH
6535: LD_INT 4
6537: PPUSH
6538: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6542: LD_ADDR_OWVAR 37
6546: PUSH
6547: LD_INT 22
6549: ST_TO_ADDR
// vc_control := control_manual ;
6550: LD_ADDR_OWVAR 38
6554: PUSH
6555: LD_INT 1
6557: ST_TO_ADDR
// vc_engine := engine_combustion ;
6558: LD_ADDR_OWVAR 39
6562: PUSH
6563: LD_INT 1
6565: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6566: LD_ADDR_OWVAR 40
6570: PUSH
6571: LD_INT 51
6573: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6574: LD_ADDR_OWVAR 41
6578: PUSH
6579: LD_INT 50
6581: ST_TO_ADDR
// un := CreateVehicle ;
6582: LD_ADDR_VAR 0 5
6586: PUSH
6587: CALL_OW 45
6591: ST_TO_ADDR
// case area of east_arr :
6592: LD_VAR 0 1
6596: PUSH
6597: LD_INT 18
6599: DOUBLE
6600: EQUAL
6601: IFTRUE 6605
6603: GO 6620
6605: POP
// SetDir ( un , 4 ) ; south_arr :
6606: LD_VAR 0 5
6610: PPUSH
6611: LD_INT 4
6613: PPUSH
6614: CALL_OW 233
6618: GO 6644
6620: LD_INT 19
6622: DOUBLE
6623: EQUAL
6624: IFTRUE 6628
6626: GO 6643
6628: POP
// SetDir ( un , 5 ) ; end ;
6629: LD_VAR 0 5
6633: PPUSH
6634: LD_INT 5
6636: PPUSH
6637: CALL_OW 233
6641: GO 6644
6643: POP
// PlaceUnitArea ( un , area , false ) ;
6644: LD_VAR 0 5
6648: PPUSH
6649: LD_VAR 0 1
6653: PPUSH
6654: LD_INT 0
6656: PPUSH
6657: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6661: CALL_OW 44
6665: PPUSH
6666: LD_VAR 0 5
6670: PPUSH
6671: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6675: LD_VAR 0 5
6679: PPUSH
6680: LD_INT 1
6682: PPUSH
6683: LD_INT 100
6685: PPUSH
6686: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6690: LD_VAR 0 5
6694: PPUSH
6695: LD_INT 106
6697: PPUSH
6698: LD_INT 88
6700: PPUSH
6701: CALL_OW 111
// AddComUnload ( un ) ;
6705: LD_VAR 0 5
6709: PPUSH
6710: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6714: LD_VAR 0 5
6718: PPUSH
6719: LD_VAR 0 1
6723: PPUSH
6724: CALL_OW 173
// Wait ( 0 0$02 ) ;
6728: LD_INT 70
6730: PPUSH
6731: CALL_OW 67
// end ;
6735: GO 6510
6737: POP
6738: POP
// Wait ( 0 0$05 ) ;
6739: LD_INT 175
6741: PPUSH
6742: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6746: LD_INT 6
6748: PPUSH
6749: LD_INT 34
6751: PUSH
6752: LD_INT 51
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PPUSH
6759: CALL 11421 0 2
6763: IFFALSE 6951
// begin wait ( 0 0$01 ) ;
6765: LD_INT 35
6767: PPUSH
6768: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6772: LD_ADDR_VAR 0 4
6776: PUSH
6777: LD_INT 6
6779: PPUSH
6780: LD_INT 34
6782: PUSH
6783: LD_INT 51
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL 11421 0 2
6794: PUSH
6795: FOR_IN
6796: IFFALSE 6947
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6798: LD_VAR 0 4
6802: PPUSH
6803: LD_INT 9
6805: PPUSH
6806: CALL_OW 308
6810: PUSH
6811: LD_VAR 0 4
6815: PPUSH
6816: CALL 31644 0 1
6820: PPUSH
6821: CALL_OW 258
6825: PUSH
6826: LD_INT 1
6828: EQUAL
6829: AND
6830: PUSH
6831: LD_EXP 8
6835: AND
6836: IFFALSE 6863
// begin Say ( GetDriver ( i ) , Dtran ) ;
6838: LD_VAR 0 4
6842: PPUSH
6843: CALL 31644 0 1
6847: PPUSH
6848: LD_STRING Dtran
6850: PPUSH
6851: CALL_OW 88
// dialog_trans := false ;
6855: LD_ADDR_EXP 8
6859: PUSH
6860: LD_INT 0
6862: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6863: LD_VAR 0 4
6867: PPUSH
6868: CALL_OW 316
6872: IFFALSE 6888
// ComMoveToArea ( i , area ) ;
6874: LD_VAR 0 4
6878: PPUSH
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6888: LD_VAR 0 4
6892: PPUSH
6893: LD_VAR 0 1
6897: PPUSH
6898: CALL_OW 308
6902: PUSH
6903: LD_VAR 0 4
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: CALL_OW 289
6915: PUSH
6916: LD_INT 0
6918: EQUAL
6919: AND
6920: IFFALSE 6945
// begin RemoveUnit ( GetDriver ( i ) ) ;
6922: LD_VAR 0 4
6926: PPUSH
6927: CALL 31644 0 1
6931: PPUSH
6932: CALL_OW 64
// RemoveUnit ( i ) ;
6936: LD_VAR 0 4
6940: PPUSH
6941: CALL_OW 64
// end ; end ;
6945: GO 6795
6947: POP
6948: POP
// end ;
6949: GO 6746
// end ;
6951: LD_VAR 0 3
6955: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
6961: PPUSH
// if isTest then
6962: LD_EXP 1
6966: IFFALSE 6970
// exit ;
6968: GO 7359
// for i = 1 to n do
6970: LD_ADDR_VAR 0 4
6974: PUSH
6975: DOUBLE
6976: LD_INT 1
6978: DEC
6979: ST_TO_ADDR
6980: LD_VAR 0 2
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7218
// begin uc_side := 8 ;
6988: LD_ADDR_OWVAR 20
6992: PUSH
6993: LD_INT 8
6995: ST_TO_ADDR
// uc_nation := 1 ;
6996: LD_ADDR_OWVAR 21
7000: PUSH
7001: LD_INT 1
7003: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7004: LD_ADDR_VAR 0 6
7008: PUSH
7009: LD_INT 3
7011: PUSH
7012: LD_INT 4
7014: PUSH
7015: LD_INT 4
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 1
7025: PPUSH
7026: LD_OWVAR 67
7030: PPUSH
7031: CALL_OW 12
7035: ARRAY
7036: ST_TO_ADDR
// vc_chassis := ch ;
7037: LD_ADDR_OWVAR 37
7041: PUSH
7042: LD_VAR 0 6
7046: ST_TO_ADDR
// vc_control := control_computer ;
7047: LD_ADDR_OWVAR 38
7051: PUSH
7052: LD_INT 3
7054: ST_TO_ADDR
// vc_engine := engine_combustion ;
7055: LD_ADDR_OWVAR 39
7059: PUSH
7060: LD_INT 1
7062: ST_TO_ADDR
// if ch = us_medium_tracked then
7063: LD_VAR 0 6
7067: PUSH
7068: LD_INT 3
7070: EQUAL
7071: IFFALSE 7118
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7073: LD_ADDR_OWVAR 40
7077: PUSH
7078: LD_INT 3
7080: PUSH
7081: LD_INT 4
7083: PUSH
7084: LD_INT 5
7086: PUSH
7087: LD_INT 7
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: LIST
7094: LIST
7095: PUSH
7096: LD_OWVAR 67
7100: PPUSH
7101: LD_OWVAR 67
7105: PUSH
7106: LD_INT 1
7108: PLUS
7109: PPUSH
7110: CALL_OW 12
7114: ARRAY
7115: ST_TO_ADDR
7116: GO 7159
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7118: LD_ADDR_OWVAR 40
7122: PUSH
7123: LD_INT 5
7125: PUSH
7126: LD_INT 6
7128: PUSH
7129: LD_INT 7
7131: PUSH
7132: LD_INT 7
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PUSH
7149: LD_INT 1
7151: PLUS
7152: PPUSH
7153: CALL_OW 12
7157: ARRAY
7158: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7159: LD_ADDR_OWVAR 41
7163: PUSH
7164: LD_INT 70
7166: ST_TO_ADDR
// un := CreateVehicle ;
7167: LD_ADDR_VAR 0 5
7171: PUSH
7172: CALL_OW 45
7176: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7177: LD_VAR 0 5
7181: PPUSH
7182: LD_VAR 0 1
7186: PPUSH
7187: LD_INT 0
7189: PPUSH
7190: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7194: LD_VAR 0 5
7198: PPUSH
7199: LD_INT 65
7201: PPUSH
7202: LD_INT 9
7204: PPUSH
7205: CALL_OW 111
// Wait ( 0 0$02 ) ;
7209: LD_INT 70
7211: PPUSH
7212: CALL_OW 67
// end ;
7216: GO 6985
7218: POP
7219: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7220: LD_INT 90
7222: PUSH
7223: LD_INT 80
7225: PUSH
7226: LD_INT 70
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: LD_OWVAR 67
7238: ARRAY
7239: PPUSH
7240: CALL_OW 13
7244: IFFALSE 7351
// begin uc_side := 8 ;
7246: LD_ADDR_OWVAR 20
7250: PUSH
7251: LD_INT 8
7253: ST_TO_ADDR
// uc_nation := 1 ;
7254: LD_ADDR_OWVAR 21
7258: PUSH
7259: LD_INT 1
7261: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7262: LD_ADDR_OWVAR 37
7266: PUSH
7267: LD_INT 4
7269: ST_TO_ADDR
// vc_control := control_computer ;
7270: LD_ADDR_OWVAR 38
7274: PUSH
7275: LD_INT 3
7277: ST_TO_ADDR
// vc_engine := engine_combustion ;
7278: LD_ADDR_OWVAR 39
7282: PUSH
7283: LD_INT 1
7285: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7286: LD_ADDR_OWVAR 40
7290: PUSH
7291: LD_INT 14
7293: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7294: LD_ADDR_OWVAR 41
7298: PUSH
7299: LD_INT 70
7301: ST_TO_ADDR
// un := CreateVehicle ;
7302: LD_ADDR_VAR 0 5
7306: PUSH
7307: CALL_OW 45
7311: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7312: LD_VAR 0 5
7316: PPUSH
7317: LD_VAR 0 1
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7329: LD_VAR 0 5
7333: PPUSH
7334: LD_INT 65
7336: PPUSH
7337: LD_INT 9
7339: PPUSH
7340: CALL_OW 111
// Wait ( 0 0$02 ) ;
7344: LD_INT 70
7346: PPUSH
7347: CALL_OW 67
// end ; alfa_support := true ;
7351: LD_ADDR_EXP 13
7355: PUSH
7356: LD_INT 1
7358: ST_TO_ADDR
// end ;
7359: LD_VAR 0 3
7363: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7364: LD_OWVAR 1
7368: PUSH
7369: LD_INT 21000
7371: PUSH
7372: LD_INT 18900
7374: PUSH
7375: LD_INT 16800
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: LIST
7382: PUSH
7383: LD_OWVAR 67
7387: ARRAY
7388: GREATER
7389: IFFALSE 7473
7391: GO 7393
7393: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7394: LD_EXP 25
7398: PPUSH
7399: LD_STRING DR5
7401: PPUSH
7402: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7406: LD_INT 1050
7408: PPUSH
7409: LD_INT 4200
7411: PPUSH
7412: CALL_OW 12
7416: PPUSH
7417: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7421: LD_INT 20
7423: PPUSH
7424: LD_INT 5
7426: PUSH
7427: LD_INT 6
7429: PUSH
7430: LD_INT 7
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: LIST
7437: PUSH
7438: LD_OWVAR 67
7442: ARRAY
7443: PPUSH
7444: CALL 6956 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7448: LD_INT 8400
7450: PPUSH
7451: LD_INT 12600
7453: PPUSH
7454: CALL_OW 12
7458: PPUSH
7459: CALL_OW 67
// until tick >= 120 120$00 ;
7463: LD_OWVAR 1
7467: PUSH
7468: LD_INT 252000
7470: GREATEREQUAL
7471: IFFALSE 7394
// end ; end_of_file
7473: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7474: LD_INT 0
7476: PPUSH
// enable_addtolog := isTest ;
7477: LD_ADDR_OWVAR 81
7481: PUSH
7482: LD_EXP 1
7486: ST_TO_ADDR
// lines_break_limit := 5 ;
7487: LD_ADDR_EXP 27
7491: PUSH
7492: LD_INT 5
7494: ST_TO_ADDR
// lines_break_type := --- ;
7495: LD_ADDR_EXP 28
7499: PUSH
7500: LD_STRING ---
7502: ST_TO_ADDR
// lines_counter := 0 ;
7503: LD_ADDR_EXP 26
7507: PUSH
7508: LD_INT 0
7510: ST_TO_ADDR
// show_line_index := true ;
7511: LD_ADDR_EXP 29
7515: PUSH
7516: LD_INT 1
7518: ST_TO_ADDR
// tick_log := true ;
7519: LD_ADDR_EXP 30
7523: PUSH
7524: LD_INT 1
7526: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7527: LD_STRING ----------SAND OF SIBERIA LOG----------
7529: PPUSH
7530: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7534: LD_STRING Map Name: 
7536: PUSH
7537: LD_OWVAR 68
7541: STR
7542: PPUSH
7543: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7547: LD_STRING Map Number: 
7549: PUSH
7550: LD_OWVAR 70
7554: STR
7555: PPUSH
7556: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7560: LD_STRING Difficulty: 
7562: PUSH
7563: LD_OWVAR 67
7567: STR
7568: PPUSH
7569: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7573: LD_STRING ---------------------------------------
7575: PPUSH
7576: CALL_OW 561
// end ;
7580: LD_VAR 0 1
7584: RET
// function Log ( text ) ; begin
7585: LD_INT 0
7587: PPUSH
// if show_line_index then
7588: LD_EXP 29
7592: IFFALSE 7604
// result := lines_counter ;
7594: LD_ADDR_VAR 0 2
7598: PUSH
7599: LD_EXP 26
7603: ST_TO_ADDR
// if tick_log then
7604: LD_EXP 30
7608: IFFALSE 7634
// result := result &  T:  & tick &   ;
7610: LD_ADDR_VAR 0 2
7614: PUSH
7615: LD_VAR 0 2
7619: PUSH
7620: LD_STRING  T: 
7622: STR
7623: PUSH
7624: LD_OWVAR 1
7628: STR
7629: PUSH
7630: LD_STRING  
7632: STR
7633: ST_TO_ADDR
// AddToLog ( result & text ) ;
7634: LD_VAR 0 2
7638: PUSH
7639: LD_VAR 0 1
7643: STR
7644: PPUSH
7645: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7649: LD_ADDR_EXP 26
7653: PUSH
7654: LD_EXP 26
7658: PUSH
7659: LD_INT 1
7661: PLUS
7662: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7663: LD_EXP 26
7667: PUSH
7668: LD_EXP 27
7672: MOD
7673: PUSH
7674: LD_INT 0
7676: EQUAL
7677: IFFALSE 7688
// AddToLog ( lines_break_type ) ;
7679: LD_EXP 28
7683: PPUSH
7684: CALL_OW 561
// end ;
7688: LD_VAR 0 2
7692: RET
// export function LogHuman ( id ) ; begin
7693: LD_INT 0
7695: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7696: LD_STRING Human Created. id: 
7698: PUSH
7699: LD_VAR 0 1
7703: STR
7704: PUSH
7705: LD_STRING ; side: 
7707: STR
7708: PUSH
7709: LD_VAR 0 1
7713: PPUSH
7714: CALL_OW 255
7718: STR
7719: PUSH
7720: LD_STRING ; class: 
7722: STR
7723: PUSH
7724: LD_VAR 0 1
7728: PPUSH
7729: CALL_OW 257
7733: STR
7734: PUSH
7735: LD_STRING ; 
7737: STR
7738: PPUSH
7739: CALL 7585 0 1
// end ;
7743: LD_VAR 0 2
7747: RET
// export function LogVeh ( id ) ; begin
7748: LD_INT 0
7750: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7751: LD_STRING Vehicle Created. id: 
7753: PUSH
7754: LD_VAR 0 1
7758: STR
7759: PUSH
7760: LD_STRING ; side: 
7762: STR
7763: PUSH
7764: LD_VAR 0 1
7768: PPUSH
7769: CALL_OW 255
7773: STR
7774: PUSH
7775: LD_STRING ; nation: 
7777: STR
7778: PUSH
7779: LD_VAR 0 1
7783: PPUSH
7784: CALL_OW 248
7788: STR
7789: PUSH
7790: LD_STRING ; weapon: 
7792: STR
7793: PUSH
7794: LD_VAR 0 1
7798: PPUSH
7799: CALL_OW 264
7803: STR
7804: PUSH
7805: LD_STRING ; 
7807: STR
7808: PPUSH
7809: CALL 7585 0 1
// end ;
7813: LD_VAR 0 2
7817: RET
// export function LogEvent ( event ) ; begin
7818: LD_INT 0
7820: PPUSH
// Log ( Event Executed. id:  & event ) ;
7821: LD_STRING Event Executed. id: 
7823: PUSH
7824: LD_VAR 0 1
7828: STR
7829: PPUSH
7830: CALL 7585 0 1
// end ; end_of_file
7834: LD_VAR 0 2
7838: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7839: LD_INT 0
7841: PPUSH
7842: PPUSH
7843: PPUSH
7844: PPUSH
7845: PPUSH
7846: PPUSH
7847: PPUSH
7848: PPUSH
// if unit then
7849: LD_VAR 0 1
7853: IFFALSE 8253
// begin if mode = 0 then
7855: LD_VAR 0 3
7859: PUSH
7860: LD_INT 0
7862: EQUAL
7863: IFFALSE 8011
// begin if coords then
7865: LD_VAR 0 2
7869: IFFALSE 8009
// while ( coords > 1 ) do
7871: LD_VAR 0 2
7875: PUSH
7876: LD_INT 1
7878: GREATER
7879: IFFALSE 8009
// if not HasTask ( unit ) then
7881: LD_VAR 0 1
7885: PPUSH
7886: CALL_OW 314
7890: NOT
7891: IFFALSE 8007
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7893: LD_VAR 0 1
7897: PPUSH
7898: LD_VAR 0 2
7902: PUSH
7903: LD_INT 1
7905: ARRAY
7906: PPUSH
7907: LD_VAR 0 2
7911: PUSH
7912: LD_INT 2
7914: ARRAY
7915: PPUSH
7916: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
7920: LD_INT 35
7922: PPUSH
7923: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
7927: LD_VAR 0 1
7931: PPUSH
7932: CALL_OW 250
7936: PUSH
7937: LD_VAR 0 2
7941: PUSH
7942: LD_INT 1
7944: ARRAY
7945: EQUAL
7946: PUSH
7947: LD_VAR 0 1
7951: PPUSH
7952: CALL_OW 251
7956: PUSH
7957: LD_VAR 0 2
7961: PUSH
7962: LD_INT 2
7964: ARRAY
7965: EQUAL
7966: AND
7967: IFFALSE 7920
// for i = 1 to 2 do
7969: LD_ADDR_VAR 0 5
7973: PUSH
7974: DOUBLE
7975: LD_INT 1
7977: DEC
7978: ST_TO_ADDR
7979: LD_INT 2
7981: PUSH
7982: FOR_TO
7983: IFFALSE 8005
// coords := Delete ( coords , 1 ) ;
7985: LD_ADDR_VAR 0 2
7989: PUSH
7990: LD_VAR 0 2
7994: PPUSH
7995: LD_INT 1
7997: PPUSH
7998: CALL_OW 3
8002: ST_TO_ADDR
8003: GO 7982
8005: POP
8006: POP
// end ;
8007: GO 7871
// end else
8009: GO 8253
// begin if coords then
8011: LD_VAR 0 2
8015: IFFALSE 8253
// begin x := GetX ( unit ) ;
8017: LD_ADDR_VAR 0 6
8021: PUSH
8022: LD_VAR 0 1
8026: PPUSH
8027: CALL_OW 250
8031: ST_TO_ADDR
// y := GetY ( unit ) ;
8032: LD_ADDR_VAR 0 7
8036: PUSH
8037: LD_VAR 0 1
8041: PPUSH
8042: CALL_OW 251
8046: ST_TO_ADDR
// while ( coords > 1 ) do
8047: LD_VAR 0 2
8051: PUSH
8052: LD_INT 1
8054: GREATER
8055: IFFALSE 8253
// begin Wait ( 0 0$0.3 ) ;
8057: LD_INT 10
8059: PPUSH
8060: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8064: LD_VAR 0 1
8068: PPUSH
8069: CALL_OW 255
8073: PPUSH
8074: LD_VAR 0 1
8078: PPUSH
8079: CALL_OW 250
8083: PPUSH
8084: LD_VAR 0 1
8088: PPUSH
8089: CALL_OW 251
8093: PPUSH
8094: LD_INT 14
8096: PPUSH
8097: CALL 22591 0 4
8101: IFFALSE 8132
// begin ComMoveXY ( unit , x , y ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_VAR 0 6
8112: PPUSH
8113: LD_VAR 0 7
8117: PPUSH
8118: CALL_OW 111
// result := false ;
8122: LD_ADDR_VAR 0 4
8126: PUSH
8127: LD_INT 0
8129: ST_TO_ADDR
// end else
8130: GO 8171
// if not HasTask ( unit ) then
8132: LD_VAR 0 1
8136: PPUSH
8137: CALL_OW 314
8141: NOT
8142: IFFALSE 8171
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8144: LD_VAR 0 1
8148: PPUSH
8149: LD_VAR 0 2
8153: PUSH
8154: LD_INT 1
8156: ARRAY
8157: PPUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 2
8165: ARRAY
8166: PPUSH
8167: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8171: LD_VAR 0 1
8175: PPUSH
8176: CALL_OW 250
8180: PUSH
8181: LD_VAR 0 2
8185: PUSH
8186: LD_INT 1
8188: ARRAY
8189: EQUAL
8190: PUSH
8191: LD_VAR 0 1
8195: PPUSH
8196: CALL_OW 251
8200: PUSH
8201: LD_VAR 0 2
8205: PUSH
8206: LD_INT 2
8208: ARRAY
8209: EQUAL
8210: AND
8211: IFFALSE 8251
// for i = 1 to 2 do
8213: LD_ADDR_VAR 0 5
8217: PUSH
8218: DOUBLE
8219: LD_INT 1
8221: DEC
8222: ST_TO_ADDR
8223: LD_INT 2
8225: PUSH
8226: FOR_TO
8227: IFFALSE 8249
// coords := Delete ( coords , 1 ) ;
8229: LD_ADDR_VAR 0 2
8233: PUSH
8234: LD_VAR 0 2
8238: PPUSH
8239: LD_INT 1
8241: PPUSH
8242: CALL_OW 3
8246: ST_TO_ADDR
8247: GO 8226
8249: POP
8250: POP
// end ;
8251: GO 8047
// end ; end ; end ; result := true ;
8253: LD_ADDR_VAR 0 4
8257: PUSH
8258: LD_INT 1
8260: ST_TO_ADDR
// end ;
8261: LD_VAR 0 4
8265: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8266: LD_INT 0
8268: PPUSH
8269: PPUSH
8270: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8271: LD_ADDR_VAR 0 5
8275: PUSH
8276: LD_INT 81
8278: PUSH
8279: LD_VAR 0 1
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PPUSH
8288: CALL_OW 69
8292: ST_TO_ADDR
// for i in units do
8293: LD_ADDR_VAR 0 4
8297: PUSH
8298: LD_VAR 0 2
8302: PUSH
8303: FOR_IN
8304: IFFALSE 8332
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8306: LD_VAR 0 4
8310: PPUSH
8311: LD_VAR 0 5
8315: PPUSH
8316: LD_VAR 0 4
8320: PPUSH
8321: CALL_OW 74
8325: PPUSH
8326: CALL_OW 115
// end ;
8330: GO 8303
8332: POP
8333: POP
// end ;
8334: LD_VAR 0 3
8338: RET
// export function MC_Show ( string ) ; begin
8339: LD_INT 0
8341: PPUSH
// display_strings := string ;
8342: LD_ADDR_OWVAR 47
8346: PUSH
8347: LD_VAR 0 1
8351: ST_TO_ADDR
// end ; end_of_file
8352: LD_VAR 0 2
8356: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8357: LD_INT 0
8359: PPUSH
8360: PPUSH
8361: PPUSH
8362: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8363: LD_ADDR_VAR 0 8
8367: PUSH
8368: LD_VAR 0 1
8372: PPUSH
8373: LD_INT 2
8375: PPUSH
8376: EMPTY
8377: PPUSH
8378: CALL 11504 0 3
8382: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8383: LD_VAR 0 8
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_VAR 0 3
8397: PPUSH
8398: CALL_OW 428
8402: PUSH
8403: LD_INT 0
8405: EQUAL
8406: AND
8407: IFFALSE 8481
// for i = 1 to plist do
8409: LD_ADDR_VAR 0 6
8413: PUSH
8414: DOUBLE
8415: LD_INT 1
8417: DEC
8418: ST_TO_ADDR
8419: LD_VAR 0 8
8423: PUSH
8424: FOR_TO
8425: IFFALSE 8479
// if NotTask ( plist [ i ] ) then
8427: LD_VAR 0 8
8431: PUSH
8432: LD_VAR 0 6
8436: ARRAY
8437: PPUSH
8438: CALL 32289 0 1
8442: IFFALSE 8477
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8444: LD_VAR 0 8
8448: PUSH
8449: LD_VAR 0 6
8453: ARRAY
8454: PPUSH
8455: LD_INT 0
8457: PPUSH
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_VAR 0 3
8467: PPUSH
8468: LD_VAR 0 4
8472: PPUSH
8473: CALL_OW 145
// end ;
8477: GO 8424
8479: POP
8480: POP
// end ;
8481: LD_VAR 0 5
8485: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8486: LD_INT 0
8488: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8489: LD_VAR 0 1
8493: PPUSH
8494: LD_INT 6
8496: PPUSH
8497: LD_VAR 0 2
8501: PPUSH
8502: LD_VAR 0 3
8506: PPUSH
8507: LD_VAR 0 4
8511: PPUSH
8512: CALL 9990 0 5
// end ;
8516: LD_VAR 0 5
8520: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8521: LD_INT 0
8523: PPUSH
8524: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8525: LD_ADDR_VAR 0 4
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 1
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 2
8544: PUSH
8545: LD_INT 30
8547: PUSH
8548: LD_INT 0
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: PUSH
8555: LD_INT 30
8557: PUSH
8558: LD_INT 1
8560: PUSH
8561: EMPTY
8562: LIST
8563: LIST
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: LIST
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: PUSH
8574: EMPTY
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: PPUSH
8582: LD_VAR 0 2
8586: PPUSH
8587: CALL_OW 250
8591: PPUSH
8592: LD_VAR 0 2
8596: PPUSH
8597: CALL_OW 251
8601: PPUSH
8602: CALL_OW 73
8606: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8607: LD_VAR 0 4
8611: PPUSH
8612: LD_VAR 0 2
8616: PPUSH
8617: CALL 10279 0 2
8621: IFFALSE 8680
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8623: LD_VAR 0 1
8627: PPUSH
8628: LD_INT 30
8630: PUSH
8631: LD_VAR 0 2
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PPUSH
8640: CALL 11421 0 2
8644: PUSH
8645: LD_INT 1
8647: ARRAY
8648: PPUSH
8649: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8653: LD_ADDR_EXP 49
8657: PUSH
8658: LD_EXP 49
8662: PPUSH
8663: LD_VAR 0 1
8667: PPUSH
8668: LD_VAR 0 2
8672: PPUSH
8673: EMPTY
8674: PPUSH
8675: CALL 42323 0 4
8679: ST_TO_ADDR
// end ; end ;
8680: LD_VAR 0 3
8684: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8685: LD_INT 0
8687: PPUSH
8688: PPUSH
8689: PPUSH
8690: PPUSH
8691: PPUSH
8692: PPUSH
// result := false ;
8693: LD_ADDR_VAR 0 4
8697: PUSH
8698: LD_INT 0
8700: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8701: LD_VAR 0 1
8705: PPUSH
8706: LD_EXP 41
8710: PPUSH
8711: CALL 43271 0 2
8715: IFFALSE 8928
// for i = 1 to MREG_LabList do
8717: LD_ADDR_VAR 0 5
8721: PUSH
8722: DOUBLE
8723: LD_INT 1
8725: DEC
8726: ST_TO_ADDR
8727: LD_EXP 41
8731: PUSH
8732: FOR_TO
8733: IFFALSE 8926
// begin if MREG_LabList [ i ] [ 1 ] = side then
8735: LD_EXP 41
8739: PUSH
8740: LD_VAR 0 5
8744: ARRAY
8745: PUSH
8746: LD_INT 1
8748: ARRAY
8749: PUSH
8750: LD_VAR 0 1
8754: EQUAL
8755: IFFALSE 8924
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8757: LD_ADDR_VAR 0 7
8761: PUSH
8762: LD_EXP 41
8766: PUSH
8767: LD_VAR 0 5
8771: ARRAY
8772: PUSH
8773: LD_INT 2
8775: ARRAY
8776: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8777: LD_ADDR_VAR 0 9
8781: PUSH
8782: LD_INT 22
8784: PUSH
8785: LD_VAR 0 1
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: PUSH
8794: LD_INT 2
8796: PUSH
8797: LD_INT 30
8799: PUSH
8800: LD_INT 0
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 30
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: LIST
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: PUSH
8826: EMPTY
8827: LIST
8828: PPUSH
8829: CALL_OW 69
8833: PPUSH
8834: LD_VAR 0 7
8838: PPUSH
8839: CALL_OW 250
8843: PPUSH
8844: LD_VAR 0 7
8848: PPUSH
8849: CALL_OW 251
8853: PPUSH
8854: CALL_OW 73
8858: ST_TO_ADDR
// if dep then
8859: LD_VAR 0 9
8863: IFFALSE 8922
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8865: LD_VAR 0 9
8869: PPUSH
8870: LD_VAR 0 2
8874: PPUSH
8875: LD_VAR 0 3
8879: PPUSH
8880: CALL 10395 0 3
8884: IFFALSE 8922
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
8886: LD_VAR 0 7
8890: PPUSH
8891: LD_VAR 0 2
8895: PPUSH
8896: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
8900: LD_VAR 0 7
8904: PPUSH
8905: LD_VAR 0 3
8909: PPUSH
8910: CALL_OW 207
// result := true ;
8914: LD_ADDR_VAR 0 4
8918: PUSH
8919: LD_INT 1
8921: ST_TO_ADDR
// end ; end ; break ;
8922: GO 8926
// end ; end ;
8924: GO 8732
8926: POP
8927: POP
// end ;
8928: LD_VAR 0 4
8932: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
8933: LD_INT 0
8935: PPUSH
8936: PPUSH
8937: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
8938: LD_ADDR_VAR 0 7
8942: PUSH
8943: LD_VAR 0 2
8947: PPUSH
8948: LD_VAR 0 3
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: CALL 9120 0 3
8962: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
8963: LD_ADDR_EXP 47
8967: PUSH
8968: LD_EXP 47
8972: PPUSH
8973: LD_VAR 0 1
8977: PPUSH
8978: LD_INT 2
8980: PPUSH
8981: LD_VAR 0 2
8985: PUSH
8986: LD_VAR 0 3
8990: PUSH
8991: LD_VAR 0 4
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: LIST
9000: PPUSH
9001: CALL 42232 0 4
9005: ST_TO_ADDR
// if ext_list then
9006: LD_VAR 0 5
9010: IFFALSE 9115
// for i = 1 to ext_list do
9012: LD_ADDR_VAR 0 8
9016: PUSH
9017: DOUBLE
9018: LD_INT 1
9020: DEC
9021: ST_TO_ADDR
9022: LD_VAR 0 5
9026: PUSH
9027: FOR_TO
9028: IFFALSE 9113
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9030: LD_ADDR_EXP 47
9034: PUSH
9035: LD_EXP 47
9039: PPUSH
9040: LD_VAR 0 1
9044: PPUSH
9045: LD_VAR 0 5
9049: PUSH
9050: LD_VAR 0 8
9054: ARRAY
9055: PPUSH
9056: LD_VAR 0 7
9060: PUSH
9061: LD_VAR 0 8
9065: ARRAY
9066: PUSH
9067: LD_INT 1
9069: ARRAY
9070: PUSH
9071: LD_VAR 0 7
9075: PUSH
9076: LD_VAR 0 8
9080: ARRAY
9081: PUSH
9082: LD_INT 2
9084: ARRAY
9085: PUSH
9086: LD_VAR 0 7
9090: PUSH
9091: LD_VAR 0 8
9095: ARRAY
9096: PUSH
9097: LD_INT 3
9099: ARRAY
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: LIST
9105: PPUSH
9106: CALL 42232 0 4
9110: ST_TO_ADDR
9111: GO 9027
9113: POP
9114: POP
// end ;
9115: LD_VAR 0 6
9119: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9120: LD_INT 0
9122: PPUSH
9123: PPUSH
// list := [ ] ;
9124: LD_ADDR_VAR 0 5
9128: PUSH
9129: EMPTY
9130: ST_TO_ADDR
// case d of 0 :
9131: LD_VAR 0 3
9135: PUSH
9136: LD_INT 0
9138: DOUBLE
9139: EQUAL
9140: IFTRUE 9144
9142: GO 9277
9144: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9145: LD_ADDR_VAR 0 5
9149: PUSH
9150: LD_VAR 0 1
9154: PUSH
9155: LD_INT 4
9157: MINUS
9158: PUSH
9159: LD_VAR 0 2
9163: PUSH
9164: LD_INT 4
9166: MINUS
9167: PUSH
9168: LD_INT 2
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: LIST
9175: PUSH
9176: LD_VAR 0 1
9180: PUSH
9181: LD_INT 3
9183: MINUS
9184: PUSH
9185: LD_VAR 0 2
9189: PUSH
9190: LD_INT 1
9192: PUSH
9193: EMPTY
9194: LIST
9195: LIST
9196: LIST
9197: PUSH
9198: LD_VAR 0 1
9202: PUSH
9203: LD_INT 4
9205: PLUS
9206: PUSH
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 4
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: LIST
9219: PUSH
9220: LD_VAR 0 1
9224: PUSH
9225: LD_INT 3
9227: PLUS
9228: PUSH
9229: LD_VAR 0 2
9233: PUSH
9234: LD_INT 3
9236: PLUS
9237: PUSH
9238: LD_INT 5
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: LIST
9245: PUSH
9246: LD_VAR 0 1
9250: PUSH
9251: LD_VAR 0 2
9255: PUSH
9256: LD_INT 4
9258: PLUS
9259: PUSH
9260: LD_INT 0
9262: PUSH
9263: EMPTY
9264: LIST
9265: LIST
9266: LIST
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: LIST
9273: LIST
9274: ST_TO_ADDR
// end ; 1 :
9275: GO 9975
9277: LD_INT 1
9279: DOUBLE
9280: EQUAL
9281: IFTRUE 9285
9283: GO 9418
9285: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9286: LD_ADDR_VAR 0 5
9290: PUSH
9291: LD_VAR 0 1
9295: PUSH
9296: LD_VAR 0 2
9300: PUSH
9301: LD_INT 4
9303: MINUS
9304: PUSH
9305: LD_INT 3
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_VAR 0 1
9317: PUSH
9318: LD_INT 3
9320: MINUS
9321: PUSH
9322: LD_VAR 0 2
9326: PUSH
9327: LD_INT 3
9329: MINUS
9330: PUSH
9331: LD_INT 2
9333: PUSH
9334: EMPTY
9335: LIST
9336: LIST
9337: LIST
9338: PUSH
9339: LD_VAR 0 1
9343: PUSH
9344: LD_INT 4
9346: MINUS
9347: PUSH
9348: LD_VAR 0 2
9352: PUSH
9353: LD_INT 1
9355: PUSH
9356: EMPTY
9357: LIST
9358: LIST
9359: LIST
9360: PUSH
9361: LD_VAR 0 1
9365: PUSH
9366: LD_VAR 0 2
9370: PUSH
9371: LD_INT 3
9373: PLUS
9374: PUSH
9375: LD_INT 0
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: LIST
9382: PUSH
9383: LD_VAR 0 1
9387: PUSH
9388: LD_INT 4
9390: PLUS
9391: PUSH
9392: LD_VAR 0 2
9396: PUSH
9397: LD_INT 4
9399: PLUS
9400: PUSH
9401: LD_INT 5
9403: PUSH
9404: EMPTY
9405: LIST
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: LIST
9413: LIST
9414: LIST
9415: ST_TO_ADDR
// end ; 2 :
9416: GO 9975
9418: LD_INT 2
9420: DOUBLE
9421: EQUAL
9422: IFTRUE 9426
9424: GO 9555
9426: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9427: LD_ADDR_VAR 0 5
9431: PUSH
9432: LD_VAR 0 1
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 3
9444: MINUS
9445: PUSH
9446: LD_INT 3
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: LIST
9453: PUSH
9454: LD_VAR 0 1
9458: PUSH
9459: LD_INT 4
9461: PLUS
9462: PUSH
9463: LD_VAR 0 2
9467: PUSH
9468: LD_INT 4
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: LD_VAR 0 1
9502: PUSH
9503: LD_INT 3
9505: MINUS
9506: PUSH
9507: LD_VAR 0 2
9511: PUSH
9512: LD_INT 1
9514: PUSH
9515: EMPTY
9516: LIST
9517: LIST
9518: LIST
9519: PUSH
9520: LD_VAR 0 1
9524: PUSH
9525: LD_INT 4
9527: MINUS
9528: PUSH
9529: LD_VAR 0 2
9533: PUSH
9534: LD_INT 4
9536: MINUS
9537: PUSH
9538: LD_INT 2
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: LIST
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: ST_TO_ADDR
// end ; 3 :
9553: GO 9975
9555: LD_INT 3
9557: DOUBLE
9558: EQUAL
9559: IFTRUE 9563
9561: GO 9696
9563: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 3
9576: PLUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 4
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_INT 4
9598: PLUS
9599: PUSH
9600: LD_VAR 0 2
9604: PUSH
9605: LD_INT 4
9607: PLUS
9608: PUSH
9609: LD_INT 5
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: PUSH
9617: LD_VAR 0 1
9621: PUSH
9622: LD_INT 4
9624: MINUS
9625: PUSH
9626: LD_VAR 0 2
9630: PUSH
9631: LD_INT 1
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: LD_VAR 0 1
9643: PUSH
9644: LD_VAR 0 2
9648: PUSH
9649: LD_INT 4
9651: MINUS
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: LIST
9660: PUSH
9661: LD_VAR 0 1
9665: PUSH
9666: LD_INT 3
9668: MINUS
9669: PUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_INT 3
9677: MINUS
9678: PUSH
9679: LD_INT 2
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: ST_TO_ADDR
// end ; 4 :
9694: GO 9975
9696: LD_INT 4
9698: DOUBLE
9699: EQUAL
9700: IFTRUE 9704
9702: GO 9837
9704: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9705: LD_ADDR_VAR 0 5
9709: PUSH
9710: LD_VAR 0 1
9714: PUSH
9715: LD_VAR 0 2
9719: PUSH
9720: LD_INT 4
9722: PLUS
9723: PUSH
9724: LD_INT 0
9726: PUSH
9727: EMPTY
9728: LIST
9729: LIST
9730: LIST
9731: PUSH
9732: LD_VAR 0 1
9736: PUSH
9737: LD_INT 3
9739: PLUS
9740: PUSH
9741: LD_VAR 0 2
9745: PUSH
9746: LD_INT 3
9748: PLUS
9749: PUSH
9750: LD_INT 5
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: LIST
9757: PUSH
9758: LD_VAR 0 1
9762: PUSH
9763: LD_INT 3
9765: PLUS
9766: PUSH
9767: LD_VAR 0 2
9771: PUSH
9772: LD_INT 4
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: LIST
9779: PUSH
9780: LD_VAR 0 1
9784: PUSH
9785: LD_VAR 0 2
9789: PUSH
9790: LD_INT 3
9792: MINUS
9793: PUSH
9794: LD_INT 3
9796: PUSH
9797: EMPTY
9798: LIST
9799: LIST
9800: LIST
9801: PUSH
9802: LD_VAR 0 1
9806: PUSH
9807: LD_INT 4
9809: MINUS
9810: PUSH
9811: LD_VAR 0 2
9815: PUSH
9816: LD_INT 4
9818: MINUS
9819: PUSH
9820: LD_INT 2
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: LIST
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: ST_TO_ADDR
// end ; 5 :
9835: GO 9975
9837: LD_INT 5
9839: DOUBLE
9840: EQUAL
9841: IFTRUE 9845
9843: GO 9974
9845: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9846: LD_ADDR_VAR 0 5
9850: PUSH
9851: LD_VAR 0 1
9855: PUSH
9856: LD_INT 4
9858: MINUS
9859: PUSH
9860: LD_VAR 0 2
9864: PUSH
9865: LD_INT 1
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: LIST
9872: PUSH
9873: LD_VAR 0 1
9877: PUSH
9878: LD_VAR 0 2
9882: PUSH
9883: LD_INT 4
9885: MINUS
9886: PUSH
9887: LD_INT 3
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: LIST
9894: PUSH
9895: LD_VAR 0 1
9899: PUSH
9900: LD_INT 4
9902: PLUS
9903: PUSH
9904: LD_VAR 0 2
9908: PUSH
9909: LD_INT 4
9911: PLUS
9912: PUSH
9913: LD_INT 5
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: LIST
9920: PUSH
9921: LD_VAR 0 1
9925: PUSH
9926: LD_INT 3
9928: PLUS
9929: PUSH
9930: LD_VAR 0 2
9934: PUSH
9935: LD_INT 4
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: LIST
9942: PUSH
9943: LD_VAR 0 1
9947: PUSH
9948: LD_VAR 0 2
9952: PUSH
9953: LD_INT 3
9955: PLUS
9956: PUSH
9957: LD_INT 0
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: LIST
9969: LIST
9970: LIST
9971: ST_TO_ADDR
// end ; end ;
9972: GO 9975
9974: POP
// result := list ;
9975: LD_ADDR_VAR 0 4
9979: PUSH
9980: LD_VAR 0 5
9984: ST_TO_ADDR
// end ;
9985: LD_VAR 0 4
9989: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
9990: LD_INT 0
9992: PPUSH
9993: PPUSH
9994: PPUSH
9995: PPUSH
9996: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
9997: LD_ADDR_VAR 0 10
10001: PUSH
10002: LD_VAR 0 1
10006: PPUSH
10007: LD_INT 2
10009: PPUSH
10010: EMPTY
10011: PPUSH
10012: CALL 11504 0 3
10016: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10017: LD_ADDR_VAR 0 9
10021: PUSH
10022: LD_INT 22
10024: PUSH
10025: LD_VAR 0 1
10029: PUSH
10030: EMPTY
10031: LIST
10032: LIST
10033: PUSH
10034: LD_INT 2
10036: PUSH
10037: LD_INT 30
10039: PUSH
10040: LD_INT 0
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 30
10049: PUSH
10050: LD_INT 1
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: LIST
10061: PUSH
10062: EMPTY
10063: LIST
10064: LIST
10065: PUSH
10066: EMPTY
10067: LIST
10068: PPUSH
10069: CALL_OW 69
10073: PPUSH
10074: LD_VAR 0 3
10078: PPUSH
10079: LD_VAR 0 4
10083: PPUSH
10084: CALL_OW 73
10088: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10089: LD_ADDR_VAR 0 8
10093: PUSH
10094: LD_VAR 0 9
10098: PPUSH
10099: LD_VAR 0 2
10103: PPUSH
10104: CALL 10279 0 2
10108: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10109: LD_VAR 0 10
10113: PUSH
10114: LD_VAR 0 8
10118: AND
10119: PUSH
10120: LD_VAR 0 9
10124: PPUSH
10125: LD_VAR 0 3
10129: PPUSH
10130: LD_VAR 0 4
10134: PPUSH
10135: CALL_OW 297
10139: PUSH
10140: LD_INT 26
10142: LESSEQUAL
10143: AND
10144: PUSH
10145: LD_VAR 0 3
10149: PPUSH
10150: LD_VAR 0 4
10154: PPUSH
10155: CALL_OW 428
10159: PUSH
10160: LD_INT 0
10162: EQUAL
10163: AND
10164: IFFALSE 10274
// for i = 1 to plist do
10166: LD_ADDR_VAR 0 7
10170: PUSH
10171: DOUBLE
10172: LD_INT 1
10174: DEC
10175: ST_TO_ADDR
10176: LD_VAR 0 10
10180: PUSH
10181: FOR_TO
10182: IFFALSE 10272
// if IsInUnit ( plist [ i ] ) then
10184: LD_VAR 0 10
10188: PUSH
10189: LD_VAR 0 7
10193: ARRAY
10194: PPUSH
10195: CALL_OW 310
10199: IFFALSE 10218
// ComExitBuilding ( plist [ i ] ) else
10201: LD_VAR 0 10
10205: PUSH
10206: LD_VAR 0 7
10210: ARRAY
10211: PPUSH
10212: CALL_OW 122
10216: GO 10270
// if NotTask ( plist [ i ] ) then
10218: LD_VAR 0 10
10222: PUSH
10223: LD_VAR 0 7
10227: ARRAY
10228: PPUSH
10229: CALL 32289 0 1
10233: IFFALSE 10270
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10235: LD_VAR 0 10
10239: PUSH
10240: LD_VAR 0 7
10244: ARRAY
10245: PPUSH
10246: LD_VAR 0 2
10250: PPUSH
10251: LD_VAR 0 3
10255: PPUSH
10256: LD_VAR 0 4
10260: PPUSH
10261: LD_VAR 0 5
10265: PPUSH
10266: CALL_OW 145
// end ;
10270: GO 10181
10272: POP
10273: POP
// end ;
10274: LD_VAR 0 6
10278: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10279: LD_INT 0
10281: PPUSH
10282: PPUSH
10283: PPUSH
// pom := GetBase ( bdepot ) ;
10284: LD_ADDR_VAR 0 4
10288: PUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 274
10298: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10299: LD_ADDR_VAR 0 5
10303: PUSH
10304: LD_VAR 0 2
10308: PPUSH
10309: LD_VAR 0 1
10313: PPUSH
10314: CALL_OW 248
10318: PPUSH
10319: CALL_OW 450
10323: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10324: LD_VAR 0 4
10328: PPUSH
10329: LD_INT 1
10331: PPUSH
10332: CALL_OW 275
10336: PUSH
10337: LD_VAR 0 5
10341: PUSH
10342: LD_INT 1
10344: ARRAY
10345: GREATEREQUAL
10346: PUSH
10347: LD_VAR 0 4
10351: PPUSH
10352: LD_INT 3
10354: PPUSH
10355: CALL_OW 275
10359: PUSH
10360: LD_VAR 0 5
10364: PUSH
10365: LD_INT 3
10367: ARRAY
10368: GREATEREQUAL
10369: AND
10370: IFFALSE 10382
// result := true else
10372: LD_ADDR_VAR 0 3
10376: PUSH
10377: LD_INT 1
10379: ST_TO_ADDR
10380: GO 10390
// result := false ;
10382: LD_ADDR_VAR 0 3
10386: PUSH
10387: LD_INT 0
10389: ST_TO_ADDR
// end ;
10390: LD_VAR 0 3
10394: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10395: LD_INT 0
10397: PPUSH
10398: PPUSH
10399: PPUSH
10400: PPUSH
10401: PPUSH
// pom := GetBase ( bdepot ) ;
10402: LD_ADDR_VAR 0 5
10406: PUSH
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 274
10416: ST_TO_ADDR
// cost := [ ] ;
10417: LD_ADDR_VAR 0 8
10421: PUSH
10422: EMPTY
10423: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10424: LD_ADDR_VAR 0 6
10428: PUSH
10429: LD_VAR 0 2
10433: PPUSH
10434: LD_VAR 0 1
10438: PPUSH
10439: CALL_OW 248
10443: PPUSH
10444: CALL_OW 450
10448: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10449: LD_ADDR_VAR 0 7
10453: PUSH
10454: LD_VAR 0 3
10458: PPUSH
10459: LD_VAR 0 1
10463: PPUSH
10464: CALL_OW 248
10468: PPUSH
10469: CALL_OW 450
10473: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10474: LD_ADDR_VAR 0 8
10478: PUSH
10479: LD_VAR 0 8
10483: PPUSH
10484: LD_INT 1
10486: PPUSH
10487: LD_VAR 0 6
10491: PUSH
10492: LD_INT 1
10494: ARRAY
10495: PUSH
10496: LD_VAR 0 7
10500: PUSH
10501: LD_INT 1
10503: ARRAY
10504: PLUS
10505: PPUSH
10506: CALL_OW 1
10510: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10511: LD_ADDR_VAR 0 8
10515: PUSH
10516: LD_VAR 0 8
10520: PPUSH
10521: LD_INT 2
10523: PPUSH
10524: LD_VAR 0 6
10528: PUSH
10529: LD_INT 2
10531: ARRAY
10532: PUSH
10533: LD_VAR 0 7
10537: PUSH
10538: LD_INT 2
10540: ARRAY
10541: PLUS
10542: PPUSH
10543: CALL_OW 1
10547: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10548: LD_ADDR_VAR 0 8
10552: PUSH
10553: LD_VAR 0 8
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_VAR 0 6
10565: PUSH
10566: LD_INT 3
10568: ARRAY
10569: PUSH
10570: LD_VAR 0 7
10574: PUSH
10575: LD_INT 3
10577: ARRAY
10578: PLUS
10579: PPUSH
10580: CALL_OW 1
10584: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10585: LD_VAR 0 5
10589: PPUSH
10590: LD_INT 1
10592: PPUSH
10593: CALL_OW 275
10597: PUSH
10598: LD_VAR 0 8
10602: PUSH
10603: LD_INT 1
10605: ARRAY
10606: GREATEREQUAL
10607: PUSH
10608: LD_VAR 0 5
10612: PPUSH
10613: LD_INT 3
10615: PPUSH
10616: CALL_OW 275
10620: PUSH
10621: LD_VAR 0 8
10625: PUSH
10626: LD_INT 3
10628: ARRAY
10629: GREATEREQUAL
10630: AND
10631: IFFALSE 10643
// result := true else
10633: LD_ADDR_VAR 0 4
10637: PUSH
10638: LD_INT 1
10640: ST_TO_ADDR
10641: GO 10651
// result := false ;
10643: LD_ADDR_VAR 0 4
10647: PUSH
10648: LD_INT 0
10650: ST_TO_ADDR
// end ;
10651: LD_VAR 0 4
10655: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10656: LD_INT 0
10658: PPUSH
10659: PPUSH
10660: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10661: LD_ADDR_VAR 0 5
10665: PUSH
10666: LD_VAR 0 1
10670: PPUSH
10671: LD_INT 2
10673: PPUSH
10674: EMPTY
10675: PPUSH
10676: CALL 11504 0 3
10680: ST_TO_ADDR
// if unit and plist then
10681: LD_VAR 0 2
10685: PUSH
10686: LD_VAR 0 5
10690: AND
10691: IFFALSE 10752
// for i = 1 to plist do
10693: LD_ADDR_VAR 0 4
10697: PUSH
10698: DOUBLE
10699: LD_INT 1
10701: DEC
10702: ST_TO_ADDR
10703: LD_VAR 0 5
10707: PUSH
10708: FOR_TO
10709: IFFALSE 10750
// if NotTask ( plist [ i ] ) then
10711: LD_VAR 0 5
10715: PUSH
10716: LD_VAR 0 4
10720: ARRAY
10721: PPUSH
10722: CALL 32289 0 1
10726: IFFALSE 10748
// ComDismantle ( plist [ i ] , unit ) ;
10728: LD_VAR 0 5
10732: PUSH
10733: LD_VAR 0 4
10737: ARRAY
10738: PPUSH
10739: LD_VAR 0 2
10743: PPUSH
10744: CALL_OW 167
10748: GO 10708
10750: POP
10751: POP
// result := true ;
10752: LD_ADDR_VAR 0 3
10756: PUSH
10757: LD_INT 1
10759: ST_TO_ADDR
// end ;
10760: LD_VAR 0 3
10764: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10765: LD_INT 0
10767: PPUSH
10768: PPUSH
10769: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10770: LD_ADDR_VAR 0 5
10774: PUSH
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_INT 2
10782: PPUSH
10783: EMPTY
10784: PPUSH
10785: CALL 11504 0 3
10789: ST_TO_ADDR
// if unit and plist then
10790: LD_VAR 0 2
10794: PUSH
10795: LD_VAR 0 5
10799: AND
10800: IFFALSE 10861
// for i = 1 to plist do
10802: LD_ADDR_VAR 0 4
10806: PUSH
10807: DOUBLE
10808: LD_INT 1
10810: DEC
10811: ST_TO_ADDR
10812: LD_VAR 0 5
10816: PUSH
10817: FOR_TO
10818: IFFALSE 10859
// if NotTask ( plist [ i ] ) then
10820: LD_VAR 0 5
10824: PUSH
10825: LD_VAR 0 4
10829: ARRAY
10830: PPUSH
10831: CALL 32289 0 1
10835: IFFALSE 10857
// ComComplete ( plist [ i ] , unit ) ;
10837: LD_VAR 0 5
10841: PUSH
10842: LD_VAR 0 4
10846: ARRAY
10847: PPUSH
10848: LD_VAR 0 2
10852: PPUSH
10853: CALL 31825 0 2
10857: GO 10817
10859: POP
10860: POP
// result := true ;
10861: LD_ADDR_VAR 0 3
10865: PUSH
10866: LD_INT 1
10868: ST_TO_ADDR
// end ;
10869: LD_VAR 0 3
10873: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10874: LD_INT 0
10876: PPUSH
10877: PPUSH
10878: PPUSH
10879: PPUSH
10880: PPUSH
10881: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10882: LD_ADDR_VAR 0 5
10886: PUSH
10887: LD_INT 22
10889: PUSH
10890: LD_VAR 0 1
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PUSH
10899: LD_INT 21
10901: PUSH
10902: LD_INT 3
10904: PUSH
10905: EMPTY
10906: LIST
10907: LIST
10908: PUSH
10909: LD_INT 3
10911: PUSH
10912: LD_INT 57
10914: PUSH
10915: EMPTY
10916: LIST
10917: PUSH
10918: EMPTY
10919: LIST
10920: LIST
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 24
10927: PUSH
10928: LD_INT 1000
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: PUSH
10935: EMPTY
10936: LIST
10937: LIST
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: PPUSH
10945: CALL_OW 69
10949: ST_TO_ADDR
// r := [ ] ;
10950: LD_ADDR_VAR 0 6
10954: PUSH
10955: EMPTY
10956: ST_TO_ADDR
// if not tmp then
10957: LD_VAR 0 5
10961: NOT
10962: IFFALSE 10968
// exit else
10964: GO 11156
10966: GO 11136
// begin r := [ tmp [ 1 ] ] ;
10968: LD_ADDR_VAR 0 6
10972: PUSH
10973: LD_VAR 0 5
10977: PUSH
10978: LD_INT 1
10980: ARRAY
10981: PUSH
10982: EMPTY
10983: LIST
10984: ST_TO_ADDR
// for i = 2 to tmp do
10985: LD_ADDR_VAR 0 3
10989: PUSH
10990: DOUBLE
10991: LD_INT 2
10993: DEC
10994: ST_TO_ADDR
10995: LD_VAR 0 5
10999: PUSH
11000: FOR_TO
11001: IFFALSE 11134
// begin m := false ;
11003: LD_ADDR_VAR 0 7
11007: PUSH
11008: LD_INT 0
11010: ST_TO_ADDR
// for j = 1 to r do
11011: LD_ADDR_VAR 0 4
11015: PUSH
11016: DOUBLE
11017: LD_INT 1
11019: DEC
11020: ST_TO_ADDR
11021: LD_VAR 0 6
11025: PUSH
11026: FOR_TO
11027: IFFALSE 11101
// if GetLives ( tmp [ i ] ) < r [ j ] then
11029: LD_VAR 0 5
11033: PUSH
11034: LD_VAR 0 3
11038: ARRAY
11039: PPUSH
11040: CALL_OW 256
11044: PUSH
11045: LD_VAR 0 6
11049: PUSH
11050: LD_VAR 0 4
11054: ARRAY
11055: LESS
11056: IFFALSE 11099
// begin r := Insert ( r , j , tmp [ i ] ) ;
11058: LD_ADDR_VAR 0 6
11062: PUSH
11063: LD_VAR 0 6
11067: PPUSH
11068: LD_VAR 0 4
11072: PPUSH
11073: LD_VAR 0 5
11077: PUSH
11078: LD_VAR 0 3
11082: ARRAY
11083: PPUSH
11084: CALL_OW 2
11088: ST_TO_ADDR
// m := true ;
11089: LD_ADDR_VAR 0 7
11093: PUSH
11094: LD_INT 1
11096: ST_TO_ADDR
// break ;
11097: GO 11101
// end ;
11099: GO 11026
11101: POP
11102: POP
// if not m then
11103: LD_VAR 0 7
11107: NOT
11108: IFFALSE 11132
// r := r ^ tmp [ i ] ;
11110: LD_ADDR_VAR 0 6
11114: PUSH
11115: LD_VAR 0 6
11119: PUSH
11120: LD_VAR 0 5
11124: PUSH
11125: LD_VAR 0 3
11129: ARRAY
11130: ADD
11131: ST_TO_ADDR
// end ;
11132: GO 11000
11134: POP
11135: POP
// end ; if r then
11136: LD_VAR 0 6
11140: IFFALSE 11154
// result := r else
11142: LD_ADDR_VAR 0 2
11146: PUSH
11147: LD_VAR 0 6
11151: ST_TO_ADDR
11152: GO 11156
// exit ;
11154: GO 11156
// end ;
11156: LD_VAR 0 2
11160: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11161: LD_INT 0
11163: PPUSH
11164: PPUSH
11165: PPUSH
11166: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11167: LD_ADDR_VAR 0 5
11171: PUSH
11172: LD_INT 22
11174: PUSH
11175: LD_VAR 0 1
11179: PUSH
11180: EMPTY
11181: LIST
11182: LIST
11183: PUSH
11184: LD_INT 2
11186: PUSH
11187: LD_INT 25
11189: PUSH
11190: LD_INT 2
11192: PUSH
11193: EMPTY
11194: LIST
11195: LIST
11196: PUSH
11197: LD_INT 25
11199: PUSH
11200: LD_INT 16
11202: PUSH
11203: EMPTY
11204: LIST
11205: LIST
11206: PUSH
11207: LD_INT 34
11209: PUSH
11210: LD_INT 13
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: PUSH
11217: LD_INT 34
11219: PUSH
11220: LD_INT 52
11222: PUSH
11223: EMPTY
11224: LIST
11225: LIST
11226: PUSH
11227: EMPTY
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: PUSH
11234: LD_INT 24
11236: PUSH
11237: LD_INT 650
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: EMPTY
11245: LIST
11246: LIST
11247: LIST
11248: PPUSH
11249: CALL_OW 69
11253: ST_TO_ADDR
// p := 1 ;
11254: LD_ADDR_VAR 0 4
11258: PUSH
11259: LD_INT 1
11261: ST_TO_ADDR
// for i = 1 to repairs do
11262: LD_ADDR_VAR 0 3
11266: PUSH
11267: DOUBLE
11268: LD_INT 1
11270: DEC
11271: ST_TO_ADDR
11272: LD_VAR 0 5
11276: PUSH
11277: FOR_TO
11278: IFFALSE 11414
// begin if IsInUnit ( repairs [ i ] ) then
11280: LD_VAR 0 5
11284: PUSH
11285: LD_VAR 0 3
11289: ARRAY
11290: PPUSH
11291: CALL_OW 310
11295: IFFALSE 11314
// ComExitBuilding ( repairs [ i ] ) else
11297: LD_VAR 0 5
11301: PUSH
11302: LD_VAR 0 3
11306: ARRAY
11307: PPUSH
11308: CALL_OW 122
11312: GO 11412
// if not HasTask ( repairs [ i ] ) then
11314: LD_VAR 0 5
11318: PUSH
11319: LD_VAR 0 3
11323: ARRAY
11324: PPUSH
11325: CALL_OW 314
11329: NOT
11330: IFFALSE 11412
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11332: LD_VAR 0 5
11336: PUSH
11337: LD_VAR 0 3
11341: ARRAY
11342: PPUSH
11343: LD_EXP 48
11347: PUSH
11348: LD_VAR 0 1
11352: ARRAY
11353: PUSH
11354: LD_VAR 0 4
11358: ARRAY
11359: PPUSH
11360: CALL_OW 130
// if i mod 3 = 0 then
11364: LD_VAR 0 3
11368: PUSH
11369: LD_INT 3
11371: MOD
11372: PUSH
11373: LD_INT 0
11375: EQUAL
11376: IFFALSE 11392
// p := p + 1 ;
11378: LD_ADDR_VAR 0 4
11382: PUSH
11383: LD_VAR 0 4
11387: PUSH
11388: LD_INT 1
11390: PLUS
11391: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11392: LD_EXP 48
11396: PUSH
11397: LD_VAR 0 1
11401: ARRAY
11402: PUSH
11403: LD_VAR 0 4
11407: LESS
11408: IFFALSE 11412
// break ;
11410: GO 11414
// end ; end ;
11412: GO 11277
11414: POP
11415: POP
// end ; end_of_file
11416: LD_VAR 0 2
11420: RET
// export function MCF_Get ( side , filter ) ; begin
11421: LD_INT 0
11423: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11424: LD_ADDR_VAR 0 3
11428: PUSH
11429: LD_INT 22
11431: PUSH
11432: LD_VAR 0 1
11436: PUSH
11437: EMPTY
11438: LIST
11439: LIST
11440: PUSH
11441: LD_VAR 0 2
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PPUSH
11450: CALL_OW 69
11454: ST_TO_ADDR
// end ;
11455: LD_VAR 0 3
11459: RET
// export function MCF_Lab ( side ) ; begin
11460: LD_INT 0
11462: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11463: LD_ADDR_VAR 0 2
11467: PUSH
11468: LD_INT 22
11470: PUSH
11471: LD_VAR 0 1
11475: PUSH
11476: EMPTY
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 30
11482: PUSH
11483: LD_INT 8
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PPUSH
11494: CALL_OW 69
11498: ST_TO_ADDR
// end ;
11499: LD_VAR 0 2
11503: RET
// export function MCF_Class ( side , class , filter ) ; begin
11504: LD_INT 0
11506: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11507: LD_ADDR_VAR 0 4
11511: PUSH
11512: LD_INT 22
11514: PUSH
11515: LD_VAR 0 1
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: PUSH
11524: LD_INT 25
11526: PUSH
11527: LD_VAR 0 2
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PUSH
11536: LD_VAR 0 3
11540: PUSH
11541: EMPTY
11542: LIST
11543: LIST
11544: LIST
11545: PPUSH
11546: CALL_OW 69
11550: ST_TO_ADDR
// end ;
11551: LD_VAR 0 4
11555: RET
// export function MCF_All ( side , filter ) ; begin
11556: LD_INT 0
11558: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11559: LD_ADDR_VAR 0 3
11563: PUSH
11564: LD_INT 22
11566: PUSH
11567: LD_VAR 0 1
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PUSH
11576: LD_INT 2
11578: PUSH
11579: LD_INT 25
11581: PUSH
11582: LD_INT 1
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: PUSH
11589: LD_INT 25
11591: PUSH
11592: LD_INT 2
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: PUSH
11599: LD_INT 25
11601: PUSH
11602: LD_INT 3
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 25
11611: PUSH
11612: LD_INT 4
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: PUSH
11626: LD_VAR 0 2
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: LIST
11635: PPUSH
11636: CALL_OW 69
11640: ST_TO_ADDR
// end ;
11641: LD_VAR 0 3
11645: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11646: LD_INT 0
11648: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11649: LD_ADDR_VAR 0 4
11653: PUSH
11654: LD_INT 22
11656: PUSH
11657: LD_VAR 0 1
11661: PUSH
11662: EMPTY
11663: LIST
11664: LIST
11665: PUSH
11666: LD_INT 92
11668: PUSH
11669: LD_VAR 0 2
11673: PUSH
11674: LD_INT 1
11676: ARRAY
11677: PUSH
11678: LD_VAR 0 2
11682: PUSH
11683: LD_INT 2
11685: ARRAY
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: LD_INT 3
11694: ARRAY
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 21
11744: PUSH
11745: LD_INT 2
11747: PUSH
11748: EMPTY
11749: LIST
11750: LIST
11751: PUSH
11752: LD_VAR 0 2
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: LIST
11761: PPUSH
11762: CALL_OW 69
11766: ST_TO_ADDR
// end ;
11767: LD_VAR 0 3
11771: RET
// export function MCF_Cargo ( side ) ; begin
11772: LD_INT 0
11774: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11775: LD_ADDR_VAR 0 2
11779: PUSH
11780: LD_VAR 0 1
11784: PPUSH
11785: LD_INT 2
11787: PUSH
11788: LD_INT 34
11790: PUSH
11791: LD_INT 12
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: PUSH
11798: LD_INT 34
11800: PUSH
11801: LD_INT 32
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: LD_INT 34
11810: PUSH
11811: LD_INT 51
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: PPUSH
11824: CALL 11722 0 2
11828: ST_TO_ADDR
// end ;
11829: LD_VAR 0 2
11833: RET
// export function MCF_Ape ( side ) ; begin
11834: LD_INT 0
11836: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11837: LD_ADDR_VAR 0 2
11841: PUSH
11842: LD_INT 22
11844: PUSH
11845: LD_VAR 0 1
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: LD_INT 25
11859: PUSH
11860: LD_INT 12
11862: PUSH
11863: EMPTY
11864: LIST
11865: LIST
11866: PUSH
11867: LD_INT 25
11869: PUSH
11870: LD_INT 15
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: LD_INT 25
11879: PUSH
11880: LD_INT 16
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: PUSH
11887: LD_INT 25
11889: PUSH
11890: LD_INT 17
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: EMPTY
11898: LIST
11899: LIST
11900: LIST
11901: LIST
11902: LIST
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PPUSH
11908: CALL_OW 69
11912: ST_TO_ADDR
// end ;
11913: LD_VAR 0 2
11917: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
11918: LD_INT 0
11920: PPUSH
11921: PPUSH
11922: PPUSH
11923: PPUSH
// result := [ ] ;
11924: LD_ADDR_VAR 0 3
11928: PUSH
11929: EMPTY
11930: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
11931: LD_ADDR_VAR 0 4
11935: PUSH
11936: LD_VAR 0 1
11940: PPUSH
11941: CALL 11834 0 1
11945: ST_TO_ADDR
// case type of 0 , normal :
11946: LD_VAR 0 2
11950: PUSH
11951: LD_INT 0
11953: DOUBLE
11954: EQUAL
11955: IFTRUE 11965
11957: LD_STRING normal
11959: DOUBLE
11960: EQUAL
11961: IFTRUE 11965
11963: GO 11976
11965: POP
// cl := class_apeman ; 1 , soldier :
11966: LD_ADDR_VAR 0 5
11970: PUSH
11971: LD_INT 12
11973: ST_TO_ADDR
11974: GO 12052
11976: LD_INT 1
11978: DOUBLE
11979: EQUAL
11980: IFTRUE 11990
11982: LD_STRING soldier
11984: DOUBLE
11985: EQUAL
11986: IFTRUE 11990
11988: GO 12001
11990: POP
// cl := class_apeman_soldier ; 2 , engineer :
11991: LD_ADDR_VAR 0 5
11995: PUSH
11996: LD_INT 15
11998: ST_TO_ADDR
11999: GO 12052
12001: LD_INT 2
12003: DOUBLE
12004: EQUAL
12005: IFTRUE 12015
12007: LD_STRING engineer
12009: DOUBLE
12010: EQUAL
12011: IFTRUE 12015
12013: GO 12026
12015: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12016: LD_ADDR_VAR 0 5
12020: PUSH
12021: LD_INT 16
12023: ST_TO_ADDR
12024: GO 12052
12026: LD_INT 3
12028: DOUBLE
12029: EQUAL
12030: IFTRUE 12040
12032: LD_STRING kamikaze
12034: DOUBLE
12035: EQUAL
12036: IFTRUE 12040
12038: GO 12051
12040: POP
// cl := class_apeman_kamikaze ; end ;
12041: LD_ADDR_VAR 0 5
12045: PUSH
12046: LD_INT 17
12048: ST_TO_ADDR
12049: GO 12052
12051: POP
// for i = 1 to tmp do
12052: LD_ADDR_VAR 0 6
12056: PUSH
12057: DOUBLE
12058: LD_INT 1
12060: DEC
12061: ST_TO_ADDR
12062: LD_VAR 0 4
12066: PUSH
12067: FOR_TO
12068: IFFALSE 12117
// if GetClass ( tmp [ i ] ) = cl then
12070: LD_VAR 0 4
12074: PUSH
12075: LD_VAR 0 6
12079: ARRAY
12080: PPUSH
12081: CALL_OW 257
12085: PUSH
12086: LD_VAR 0 5
12090: EQUAL
12091: IFFALSE 12115
// result := result ^ tmp [ i ] ;
12093: LD_ADDR_VAR 0 3
12097: PUSH
12098: LD_VAR 0 3
12102: PUSH
12103: LD_VAR 0 4
12107: PUSH
12108: LD_VAR 0 6
12112: ARRAY
12113: ADD
12114: ST_TO_ADDR
12115: GO 12067
12117: POP
12118: POP
// end ;
12119: LD_VAR 0 3
12123: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12124: LD_INT 0
12126: PPUSH
12127: PPUSH
12128: PPUSH
12129: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12130: LD_ADDR_VAR 0 5
12134: PUSH
12135: LD_INT 22
12137: PUSH
12138: LD_VAR 0 1
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_VAR 0 3
12151: PUSH
12152: EMPTY
12153: LIST
12154: LIST
12155: PPUSH
12156: CALL_OW 69
12160: ST_TO_ADDR
// r := [ ] ;
12161: LD_ADDR_VAR 0 6
12165: PUSH
12166: EMPTY
12167: ST_TO_ADDR
// if tmp then
12168: LD_VAR 0 5
12172: IFFALSE 12241
// for i = 1 to tmp do
12174: LD_ADDR_VAR 0 7
12178: PUSH
12179: DOUBLE
12180: LD_INT 1
12182: DEC
12183: ST_TO_ADDR
12184: LD_VAR 0 5
12188: PUSH
12189: FOR_TO
12190: IFFALSE 12239
// if GetTag ( tmp [ i ] ) = tag then
12192: LD_VAR 0 5
12196: PUSH
12197: LD_VAR 0 7
12201: ARRAY
12202: PPUSH
12203: CALL_OW 110
12207: PUSH
12208: LD_VAR 0 2
12212: EQUAL
12213: IFFALSE 12237
// r := r ^ tmp [ i ] ;
12215: LD_ADDR_VAR 0 6
12219: PUSH
12220: LD_VAR 0 6
12224: PUSH
12225: LD_VAR 0 5
12229: PUSH
12230: LD_VAR 0 7
12234: ARRAY
12235: ADD
12236: ST_TO_ADDR
12237: GO 12189
12239: POP
12240: POP
// result := r ;
12241: LD_ADDR_VAR 0 4
12245: PUSH
12246: LD_VAR 0 6
12250: ST_TO_ADDR
// end ;
12251: LD_VAR 0 4
12255: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12256: LD_INT 0
12258: PPUSH
12259: PPUSH
12260: PPUSH
// tmp := plist ;
12261: LD_ADDR_VAR 0 5
12265: PUSH
12266: LD_VAR 0 2
12270: ST_TO_ADDR
// if tmp then
12271: LD_VAR 0 5
12275: IFFALSE 12352
// begin for i = 1 to tmp do
12277: LD_ADDR_VAR 0 6
12281: PUSH
12282: DOUBLE
12283: LD_INT 1
12285: DEC
12286: ST_TO_ADDR
12287: LD_VAR 0 5
12291: PUSH
12292: FOR_TO
12293: IFFALSE 12340
// if GetTag ( tmp [ i ] ) <> tag then
12295: LD_VAR 0 5
12299: PUSH
12300: LD_VAR 0 6
12304: ARRAY
12305: PPUSH
12306: CALL_OW 110
12310: PUSH
12311: LD_VAR 0 3
12315: NONEQUAL
12316: IFFALSE 12338
// SetTag ( tmp [ i ] , tag ) ;
12318: LD_VAR 0 5
12322: PUSH
12323: LD_VAR 0 6
12327: ARRAY
12328: PPUSH
12329: LD_VAR 0 3
12333: PPUSH
12334: CALL_OW 109
12338: GO 12292
12340: POP
12341: POP
// result := true ;
12342: LD_ADDR_VAR 0 4
12346: PUSH
12347: LD_INT 1
12349: ST_TO_ADDR
// end else
12350: GO 12360
// result := false ;
12352: LD_ADDR_VAR 0 4
12356: PUSH
12357: LD_INT 0
12359: ST_TO_ADDR
// end ;
12360: LD_VAR 0 4
12364: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12365: LD_INT 0
12367: PPUSH
12368: PPUSH
12369: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12370: LD_ADDR_VAR 0 4
12374: PUSH
12375: LD_VAR 0 1
12379: PPUSH
12380: LD_VAR 0 2
12384: PPUSH
12385: EMPTY
12386: PPUSH
12387: CALL 12124 0 3
12391: ST_TO_ADDR
// if tmp then
12392: LD_VAR 0 4
12396: IFFALSE 12448
// begin for i = 1 to tmp do
12398: LD_ADDR_VAR 0 5
12402: PUSH
12403: DOUBLE
12404: LD_INT 1
12406: DEC
12407: ST_TO_ADDR
12408: LD_VAR 0 4
12412: PUSH
12413: FOR_TO
12414: IFFALSE 12436
// SetTag ( tmp [ i ] , 0 ) ;
12416: LD_VAR 0 4
12420: PUSH
12421: LD_VAR 0 5
12425: ARRAY
12426: PPUSH
12427: LD_INT 0
12429: PPUSH
12430: CALL_OW 109
12434: GO 12413
12436: POP
12437: POP
// result := true ;
12438: LD_ADDR_VAR 0 3
12442: PUSH
12443: LD_INT 1
12445: ST_TO_ADDR
// end else
12446: GO 12456
// result := false ;
12448: LD_ADDR_VAR 0 3
12452: PUSH
12453: LD_INT 0
12455: ST_TO_ADDR
// end ;
12456: LD_VAR 0 3
12460: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12461: LD_INT 0
12463: PPUSH
12464: PPUSH
12465: PPUSH
12466: PPUSH
12467: PPUSH
// sort_list := [ ] ;
12468: LD_ADDR_VAR 0 5
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to list do
12475: LD_ADDR_VAR 0 3
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_VAR 0 1
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12653
// begin if i = 1 then
12493: LD_VAR 0 3
12497: PUSH
12498: LD_INT 1
12500: EQUAL
12501: IFFALSE 12527
// sort_list := sort_list ^ list [ i ] else
12503: LD_ADDR_VAR 0 5
12507: PUSH
12508: LD_VAR 0 5
12512: PUSH
12513: LD_VAR 0 1
12517: PUSH
12518: LD_VAR 0 3
12522: ARRAY
12523: ADD
12524: ST_TO_ADDR
12525: GO 12651
// begin for j = 1 to sort_list do
12527: LD_ADDR_VAR 0 4
12531: PUSH
12532: DOUBLE
12533: LD_INT 1
12535: DEC
12536: ST_TO_ADDR
12537: LD_VAR 0 5
12541: PUSH
12542: FOR_TO
12543: IFFALSE 12620
// begin add := false ;
12545: LD_ADDR_VAR 0 6
12549: PUSH
12550: LD_INT 0
12552: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12553: LD_VAR 0 1
12557: PUSH
12558: LD_VAR 0 3
12562: ARRAY
12563: PUSH
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 4
12573: ARRAY
12574: LESS
12575: IFFALSE 12618
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12577: LD_ADDR_VAR 0 5
12581: PUSH
12582: LD_VAR 0 5
12586: PPUSH
12587: LD_VAR 0 4
12591: PPUSH
12592: LD_VAR 0 1
12596: PUSH
12597: LD_VAR 0 3
12601: ARRAY
12602: PPUSH
12603: CALL_OW 2
12607: ST_TO_ADDR
// add := true ;
12608: LD_ADDR_VAR 0 6
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// break ;
12616: GO 12620
// end ; end ;
12618: GO 12542
12620: POP
12621: POP
// if not add then
12622: LD_VAR 0 6
12626: NOT
12627: IFFALSE 12651
// sort_list := sort_list ^ list [ i ] ;
12629: LD_ADDR_VAR 0 5
12633: PUSH
12634: LD_VAR 0 5
12638: PUSH
12639: LD_VAR 0 1
12643: PUSH
12644: LD_VAR 0 3
12648: ARRAY
12649: ADD
12650: ST_TO_ADDR
// end ; end ;
12651: GO 12490
12653: POP
12654: POP
// result := sort_list ;
12655: LD_ADDR_VAR 0 2
12659: PUSH
12660: LD_VAR 0 5
12664: ST_TO_ADDR
// end ;
12665: LD_VAR 0 2
12669: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12670: LD_INT 0
12672: PPUSH
12673: PPUSH
12674: PPUSH
12675: PPUSH
12676: PPUSH
// sort_list := [ ] ;
12677: LD_ADDR_VAR 0 5
12681: PUSH
12682: EMPTY
12683: ST_TO_ADDR
// for i = 1 to list do
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: DOUBLE
12690: LD_INT 1
12692: DEC
12693: ST_TO_ADDR
12694: LD_VAR 0 1
12698: PUSH
12699: FOR_TO
12700: IFFALSE 12862
// begin if i = 1 then
12702: LD_VAR 0 3
12706: PUSH
12707: LD_INT 1
12709: EQUAL
12710: IFFALSE 12736
// sort_list := sort_list ^ list [ i ] else
12712: LD_ADDR_VAR 0 5
12716: PUSH
12717: LD_VAR 0 5
12721: PUSH
12722: LD_VAR 0 1
12726: PUSH
12727: LD_VAR 0 3
12731: ARRAY
12732: ADD
12733: ST_TO_ADDR
12734: GO 12860
// begin for j = 1 to sort_list do
12736: LD_ADDR_VAR 0 4
12740: PUSH
12741: DOUBLE
12742: LD_INT 1
12744: DEC
12745: ST_TO_ADDR
12746: LD_VAR 0 5
12750: PUSH
12751: FOR_TO
12752: IFFALSE 12829
// begin add := false ;
12754: LD_ADDR_VAR 0 6
12758: PUSH
12759: LD_INT 0
12761: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12762: LD_VAR 0 1
12766: PUSH
12767: LD_VAR 0 3
12771: ARRAY
12772: PUSH
12773: LD_VAR 0 5
12777: PUSH
12778: LD_VAR 0 4
12782: ARRAY
12783: GREATER
12784: IFFALSE 12827
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12786: LD_ADDR_VAR 0 5
12790: PUSH
12791: LD_VAR 0 5
12795: PPUSH
12796: LD_VAR 0 4
12800: PPUSH
12801: LD_VAR 0 1
12805: PUSH
12806: LD_VAR 0 3
12810: ARRAY
12811: PPUSH
12812: CALL_OW 2
12816: ST_TO_ADDR
// add := true ;
12817: LD_ADDR_VAR 0 6
12821: PUSH
12822: LD_INT 1
12824: ST_TO_ADDR
// break ;
12825: GO 12829
// end ; end ;
12827: GO 12751
12829: POP
12830: POP
// if not add then
12831: LD_VAR 0 6
12835: NOT
12836: IFFALSE 12860
// sort_list := sort_list ^ list [ i ] ;
12838: LD_ADDR_VAR 0 5
12842: PUSH
12843: LD_VAR 0 5
12847: PUSH
12848: LD_VAR 0 1
12852: PUSH
12853: LD_VAR 0 3
12857: ARRAY
12858: ADD
12859: ST_TO_ADDR
// end ; end ;
12860: GO 12699
12862: POP
12863: POP
// result := sort_list ;
12864: LD_ADDR_VAR 0 2
12868: PUSH
12869: LD_VAR 0 5
12873: ST_TO_ADDR
// end ;
12874: LD_VAR 0 2
12878: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12879: LD_INT 0
12881: PPUSH
12882: PPUSH
12883: PPUSH
12884: PPUSH
12885: PPUSH
12886: PPUSH
// tmp := [ ] ;
12887: LD_ADDR_VAR 0 8
12891: PUSH
12892: EMPTY
12893: ST_TO_ADDR
// r := [ ] ;
12894: LD_ADDR_VAR 0 7
12898: PUSH
12899: EMPTY
12900: ST_TO_ADDR
// add := false ;
12901: LD_ADDR_VAR 0 9
12905: PUSH
12906: LD_INT 0
12908: ST_TO_ADDR
// if plist then
12909: LD_VAR 0 2
12913: IFFALSE 12989
// begin for i = 1 to plist do
12915: LD_ADDR_VAR 0 5
12919: PUSH
12920: DOUBLE
12921: LD_INT 1
12923: DEC
12924: ST_TO_ADDR
12925: LD_VAR 0 2
12929: PUSH
12930: FOR_TO
12931: IFFALSE 12985
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12933: LD_ADDR_VAR 0 8
12937: PUSH
12938: LD_VAR 0 8
12942: PUSH
12943: LD_VAR 0 2
12947: PUSH
12948: LD_VAR 0 5
12952: ARRAY
12953: PUSH
12954: LD_VAR 0 2
12958: PUSH
12959: LD_VAR 0 5
12963: ARRAY
12964: PPUSH
12965: LD_VAR 0 3
12969: PPUSH
12970: CALL_OW 259
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: PUSH
12979: EMPTY
12980: LIST
12981: ADD
12982: ST_TO_ADDR
// end ;
12983: GO 12930
12985: POP
12986: POP
// end else
12987: GO 12997
// result := false ;
12989: LD_ADDR_VAR 0 4
12993: PUSH
12994: LD_INT 0
12996: ST_TO_ADDR
// if tmp then
12997: LD_VAR 0 8
13001: IFFALSE 13175
// begin r := r ^ [ tmp [ 1 ] ] ;
13003: LD_ADDR_VAR 0 7
13007: PUSH
13008: LD_VAR 0 7
13012: PUSH
13013: LD_VAR 0 8
13017: PUSH
13018: LD_INT 1
13020: ARRAY
13021: PUSH
13022: EMPTY
13023: LIST
13024: ADD
13025: ST_TO_ADDR
// for i = 2 to tmp do
13026: LD_ADDR_VAR 0 5
13030: PUSH
13031: DOUBLE
13032: LD_INT 2
13034: DEC
13035: ST_TO_ADDR
13036: LD_VAR 0 8
13040: PUSH
13041: FOR_TO
13042: IFFALSE 13173
// begin for j = 1 to r do
13044: LD_ADDR_VAR 0 6
13048: PUSH
13049: DOUBLE
13050: LD_INT 1
13052: DEC
13053: ST_TO_ADDR
13054: LD_VAR 0 7
13058: PUSH
13059: FOR_TO
13060: IFFALSE 13137
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13062: LD_VAR 0 8
13066: PUSH
13067: LD_VAR 0 5
13071: ARRAY
13072: PUSH
13073: LD_INT 2
13075: ARRAY
13076: PUSH
13077: LD_VAR 0 7
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PUSH
13088: LD_INT 2
13090: ARRAY
13091: LESS
13092: IFFALSE 13135
// begin r := Insert ( r , j , tmp [ i ] ) ;
13094: LD_ADDR_VAR 0 7
13098: PUSH
13099: LD_VAR 0 7
13103: PPUSH
13104: LD_VAR 0 6
13108: PPUSH
13109: LD_VAR 0 8
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PPUSH
13120: CALL_OW 2
13124: ST_TO_ADDR
// add := true ;
13125: LD_ADDR_VAR 0 9
13129: PUSH
13130: LD_INT 1
13132: ST_TO_ADDR
// break ;
13133: GO 13137
// end ; end ;
13135: GO 13059
13137: POP
13138: POP
// if not add then
13139: LD_VAR 0 9
13143: NOT
13144: IFFALSE 13171
// r := r ^ [ tmp [ i ] ] ;
13146: LD_ADDR_VAR 0 7
13150: PUSH
13151: LD_VAR 0 7
13155: PUSH
13156: LD_VAR 0 8
13160: PUSH
13161: LD_VAR 0 5
13165: ARRAY
13166: PUSH
13167: EMPTY
13168: LIST
13169: ADD
13170: ST_TO_ADDR
// end ;
13171: GO 13041
13173: POP
13174: POP
// end ; result := r ;
13175: LD_ADDR_VAR 0 4
13179: PUSH
13180: LD_VAR 0 7
13184: ST_TO_ADDR
// end ;
13185: LD_VAR 0 4
13189: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13190: LD_INT 0
13192: PPUSH
13193: PPUSH
13194: PPUSH
13195: PPUSH
13196: PPUSH
13197: PPUSH
// tmp := [ ] ;
13198: LD_ADDR_VAR 0 8
13202: PUSH
13203: EMPTY
13204: ST_TO_ADDR
// r := [ ] ;
13205: LD_ADDR_VAR 0 7
13209: PUSH
13210: EMPTY
13211: ST_TO_ADDR
// add := false ;
13212: LD_ADDR_VAR 0 9
13216: PUSH
13217: LD_INT 0
13219: ST_TO_ADDR
// if plist then
13220: LD_VAR 0 2
13224: IFFALSE 13300
// begin for i = 1 to plist do
13226: LD_ADDR_VAR 0 5
13230: PUSH
13231: DOUBLE
13232: LD_INT 1
13234: DEC
13235: ST_TO_ADDR
13236: LD_VAR 0 2
13240: PUSH
13241: FOR_TO
13242: IFFALSE 13296
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13244: LD_ADDR_VAR 0 8
13248: PUSH
13249: LD_VAR 0 8
13253: PUSH
13254: LD_VAR 0 2
13258: PUSH
13259: LD_VAR 0 5
13263: ARRAY
13264: PUSH
13265: LD_VAR 0 2
13269: PUSH
13270: LD_VAR 0 5
13274: ARRAY
13275: PPUSH
13276: LD_VAR 0 3
13280: PPUSH
13281: CALL_OW 259
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PUSH
13290: EMPTY
13291: LIST
13292: ADD
13293: ST_TO_ADDR
// end ;
13294: GO 13241
13296: POP
13297: POP
// end else
13298: GO 13308
// result := false ;
13300: LD_ADDR_VAR 0 4
13304: PUSH
13305: LD_INT 0
13307: ST_TO_ADDR
// if tmp then
13308: LD_VAR 0 8
13312: IFFALSE 13486
// begin r := r ^ [ tmp [ 1 ] ] ;
13314: LD_ADDR_VAR 0 7
13318: PUSH
13319: LD_VAR 0 7
13323: PUSH
13324: LD_VAR 0 8
13328: PUSH
13329: LD_INT 1
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// for i = 2 to tmp do
13337: LD_ADDR_VAR 0 5
13341: PUSH
13342: DOUBLE
13343: LD_INT 2
13345: DEC
13346: ST_TO_ADDR
13347: LD_VAR 0 8
13351: PUSH
13352: FOR_TO
13353: IFFALSE 13484
// begin for j = 1 to r do
13355: LD_ADDR_VAR 0 6
13359: PUSH
13360: DOUBLE
13361: LD_INT 1
13363: DEC
13364: ST_TO_ADDR
13365: LD_VAR 0 7
13369: PUSH
13370: FOR_TO
13371: IFFALSE 13448
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13373: LD_VAR 0 8
13377: PUSH
13378: LD_VAR 0 5
13382: ARRAY
13383: PUSH
13384: LD_INT 2
13386: ARRAY
13387: PUSH
13388: LD_VAR 0 7
13392: PUSH
13393: LD_VAR 0 6
13397: ARRAY
13398: PUSH
13399: LD_INT 2
13401: ARRAY
13402: GREATER
13403: IFFALSE 13446
// begin r := Insert ( r , j , tmp [ i ] ) ;
13405: LD_ADDR_VAR 0 7
13409: PUSH
13410: LD_VAR 0 7
13414: PPUSH
13415: LD_VAR 0 6
13419: PPUSH
13420: LD_VAR 0 8
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PPUSH
13431: CALL_OW 2
13435: ST_TO_ADDR
// add := true ;
13436: LD_ADDR_VAR 0 9
13440: PUSH
13441: LD_INT 1
13443: ST_TO_ADDR
// break ;
13444: GO 13448
// end ; end ;
13446: GO 13370
13448: POP
13449: POP
// if not add then
13450: LD_VAR 0 9
13454: NOT
13455: IFFALSE 13482
// r := r ^ [ tmp [ i ] ] ;
13457: LD_ADDR_VAR 0 7
13461: PUSH
13462: LD_VAR 0 7
13466: PUSH
13467: LD_VAR 0 8
13471: PUSH
13472: LD_VAR 0 5
13476: ARRAY
13477: PUSH
13478: EMPTY
13479: LIST
13480: ADD
13481: ST_TO_ADDR
// end ;
13482: GO 13352
13484: POP
13485: POP
// end ; result := r ;
13486: LD_ADDR_VAR 0 4
13490: PUSH
13491: LD_VAR 0 7
13495: ST_TO_ADDR
// end ;
13496: LD_VAR 0 4
13500: RET
// export function MCF_Clear ( side ) ; var i ; begin
13501: LD_INT 0
13503: PPUSH
13504: PPUSH
// for i = 1 to 100 do
13505: LD_ADDR_VAR 0 3
13509: PUSH
13510: DOUBLE
13511: LD_INT 1
13513: DEC
13514: ST_TO_ADDR
13515: LD_INT 100
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13555
// if MCF_Tag ( side , i , [ ] ) then
13521: LD_VAR 0 1
13525: PPUSH
13526: LD_VAR 0 3
13530: PPUSH
13531: EMPTY
13532: PPUSH
13533: CALL 12124 0 3
13537: IFFALSE 13553
// MCF_ClearTag ( side , i ) ;
13539: LD_VAR 0 1
13543: PPUSH
13544: LD_VAR 0 3
13548: PPUSH
13549: CALL 12365 0 2
13553: GO 13518
13555: POP
13556: POP
// result := true ;
13557: LD_ADDR_VAR 0 2
13561: PUSH
13562: LD_INT 1
13564: ST_TO_ADDR
// end ;
13565: LD_VAR 0 2
13569: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13570: LD_INT 0
13572: PPUSH
13573: PPUSH
13574: PPUSH
// for i = 1 to plist do
13575: LD_ADDR_VAR 0 4
13579: PUSH
13580: DOUBLE
13581: LD_INT 1
13583: DEC
13584: ST_TO_ADDR
13585: LD_VAR 0 1
13589: PUSH
13590: FOR_TO
13591: IFFALSE 13640
// if MCF_HasClass ( plist [ i ] ) = n then
13593: LD_VAR 0 1
13597: PUSH
13598: LD_VAR 0 4
13602: ARRAY
13603: PPUSH
13604: CALL 14127 0 1
13608: PUSH
13609: LD_VAR 0 2
13613: EQUAL
13614: IFFALSE 13638
// tmp := tmp ^ plist [ i ] ;
13616: LD_ADDR_VAR 0 5
13620: PUSH
13621: LD_VAR 0 5
13625: PUSH
13626: LD_VAR 0 1
13630: PUSH
13631: LD_VAR 0 4
13635: ARRAY
13636: ADD
13637: ST_TO_ADDR
13638: GO 13590
13640: POP
13641: POP
// result := tmp ;
13642: LD_ADDR_VAR 0 3
13646: PUSH
13647: LD_VAR 0 5
13651: ST_TO_ADDR
// end ;
13652: LD_VAR 0 3
13656: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13657: LD_INT 0
13659: PPUSH
13660: PPUSH
13661: PPUSH
// if mreg = ToArm then
13662: LD_VAR 0 2
13666: PUSH
13667: LD_STRING ToArm
13669: EQUAL
13670: IFFALSE 13775
// begin tmp := MREG_ToArm [ side ] ;
13672: LD_ADDR_VAR 0 6
13676: PUSH
13677: LD_EXP 57
13681: PUSH
13682: LD_VAR 0 1
13686: ARRAY
13687: ST_TO_ADDR
// if tmp = 0 then
13688: LD_VAR 0 6
13692: PUSH
13693: LD_INT 0
13695: EQUAL
13696: IFFALSE 13702
// exit else
13698: GO 14122
13700: GO 13775
// begin for i = MREG_ToArm [ side ] downto n do
13702: LD_ADDR_VAR 0 5
13706: PUSH
13707: DOUBLE
13708: LD_EXP 57
13712: PUSH
13713: LD_VAR 0 1
13717: ARRAY
13718: INC
13719: ST_TO_ADDR
13720: LD_VAR 0 3
13724: PUSH
13725: FOR_DOWNTO
13726: IFFALSE 13748
// tmp := Delete ( tmp , 1 ) ;
13728: LD_ADDR_VAR 0 6
13732: PUSH
13733: LD_VAR 0 6
13737: PPUSH
13738: LD_INT 1
13740: PPUSH
13741: CALL_OW 3
13745: ST_TO_ADDR
13746: GO 13725
13748: POP
13749: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13750: LD_ADDR_EXP 57
13754: PUSH
13755: LD_EXP 57
13759: PPUSH
13760: LD_VAR 0 1
13764: PPUSH
13765: LD_VAR 0 6
13769: PPUSH
13770: CALL_OW 1
13774: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13775: LD_VAR 0 2
13779: PUSH
13780: LD_STRING ToDep
13782: EQUAL
13783: IFFALSE 13888
// begin tmp := MREG_ToDep [ side ] ;
13785: LD_ADDR_VAR 0 6
13789: PUSH
13790: LD_EXP 58
13794: PUSH
13795: LD_VAR 0 1
13799: ARRAY
13800: ST_TO_ADDR
// if tmp = 0 then
13801: LD_VAR 0 6
13805: PUSH
13806: LD_INT 0
13808: EQUAL
13809: IFFALSE 13815
// exit else
13811: GO 14122
13813: GO 13888
// begin for i = MREG_ToDep [ side ] downto n do
13815: LD_ADDR_VAR 0 5
13819: PUSH
13820: DOUBLE
13821: LD_EXP 58
13825: PUSH
13826: LD_VAR 0 1
13830: ARRAY
13831: INC
13832: ST_TO_ADDR
13833: LD_VAR 0 3
13837: PUSH
13838: FOR_DOWNTO
13839: IFFALSE 13861
// tmp := Delete ( tmp , 1 ) ;
13841: LD_ADDR_VAR 0 6
13845: PUSH
13846: LD_VAR 0 6
13850: PPUSH
13851: LD_INT 1
13853: PPUSH
13854: CALL_OW 3
13858: ST_TO_ADDR
13859: GO 13838
13861: POP
13862: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13863: LD_ADDR_EXP 58
13867: PUSH
13868: LD_EXP 58
13872: PPUSH
13873: LD_VAR 0 1
13877: PPUSH
13878: LD_VAR 0 6
13882: PPUSH
13883: CALL_OW 1
13887: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
13888: LD_VAR 0 2
13892: PUSH
13893: LD_STRING ToFac
13895: EQUAL
13896: IFFALSE 14001
// begin tmp := MREG_ToFac [ side ] ;
13898: LD_ADDR_VAR 0 6
13902: PUSH
13903: LD_EXP 56
13907: PUSH
13908: LD_VAR 0 1
13912: ARRAY
13913: ST_TO_ADDR
// if tmp = 0 then
13914: LD_VAR 0 6
13918: PUSH
13919: LD_INT 0
13921: EQUAL
13922: IFFALSE 13928
// exit else
13924: GO 14122
13926: GO 14001
// begin for i = MREG_ToFac [ side ] downto n do
13928: LD_ADDR_VAR 0 5
13932: PUSH
13933: DOUBLE
13934: LD_EXP 56
13938: PUSH
13939: LD_VAR 0 1
13943: ARRAY
13944: INC
13945: ST_TO_ADDR
13946: LD_VAR 0 3
13950: PUSH
13951: FOR_DOWNTO
13952: IFFALSE 13974
// tmp := Delete ( tmp , 1 ) ;
13954: LD_ADDR_VAR 0 6
13958: PUSH
13959: LD_VAR 0 6
13963: PPUSH
13964: LD_INT 1
13966: PPUSH
13967: CALL_OW 3
13971: ST_TO_ADDR
13972: GO 13951
13974: POP
13975: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
13976: LD_ADDR_EXP 56
13980: PUSH
13981: LD_EXP 56
13985: PPUSH
13986: LD_VAR 0 1
13990: PPUSH
13991: LD_VAR 0 6
13995: PPUSH
13996: CALL_OW 1
14000: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14001: LD_VAR 0 2
14005: PUSH
14006: LD_STRING ToLab
14008: EQUAL
14009: IFFALSE 14114
// begin tmp := MREG_ToLab [ side ] ;
14011: LD_ADDR_VAR 0 6
14015: PUSH
14016: LD_EXP 55
14020: PUSH
14021: LD_VAR 0 1
14025: ARRAY
14026: ST_TO_ADDR
// if tmp = 0 then
14027: LD_VAR 0 6
14031: PUSH
14032: LD_INT 0
14034: EQUAL
14035: IFFALSE 14041
// exit else
14037: GO 14122
14039: GO 14114
// begin for i = MREG_ToLab [ side ] downto n do
14041: LD_ADDR_VAR 0 5
14045: PUSH
14046: DOUBLE
14047: LD_EXP 55
14051: PUSH
14052: LD_VAR 0 1
14056: ARRAY
14057: INC
14058: ST_TO_ADDR
14059: LD_VAR 0 3
14063: PUSH
14064: FOR_DOWNTO
14065: IFFALSE 14087
// tmp := Delete ( tmp , 1 ) ;
14067: LD_ADDR_VAR 0 6
14071: PUSH
14072: LD_VAR 0 6
14076: PPUSH
14077: LD_INT 1
14079: PPUSH
14080: CALL_OW 3
14084: ST_TO_ADDR
14085: GO 14064
14087: POP
14088: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14089: LD_ADDR_EXP 55
14093: PUSH
14094: LD_EXP 55
14098: PPUSH
14099: LD_VAR 0 1
14103: PPUSH
14104: LD_VAR 0 6
14108: PPUSH
14109: CALL_OW 1
14113: ST_TO_ADDR
// end ; end ; result := true ;
14114: LD_ADDR_VAR 0 4
14118: PUSH
14119: LD_INT 1
14121: ST_TO_ADDR
// end ;
14122: LD_VAR 0 4
14126: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14127: LD_INT 0
14129: PPUSH
14130: PPUSH
14131: PPUSH
// side := GetSide ( unit ) ;
14132: LD_ADDR_VAR 0 4
14136: PUSH
14137: LD_VAR 0 1
14141: PPUSH
14142: CALL_OW 255
14146: ST_TO_ADDR
// tmp := 0 ;
14147: LD_ADDR_VAR 0 3
14151: PUSH
14152: LD_INT 0
14154: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14155: LD_VAR 0 1
14159: PUSH
14160: LD_EXP 57
14164: PUSH
14165: LD_VAR 0 4
14169: ARRAY
14170: IN
14171: IFFALSE 14181
// tmp := 1 ;
14173: LD_ADDR_VAR 0 3
14177: PUSH
14178: LD_INT 1
14180: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14181: LD_VAR 0 1
14185: PUSH
14186: LD_EXP 58
14190: PUSH
14191: LD_VAR 0 4
14195: ARRAY
14196: IN
14197: IFFALSE 14207
// tmp := 2 ;
14199: LD_ADDR_VAR 0 3
14203: PUSH
14204: LD_INT 2
14206: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14207: LD_VAR 0 1
14211: PUSH
14212: LD_EXP 56
14216: PUSH
14217: LD_VAR 0 4
14221: ARRAY
14222: IN
14223: IFFALSE 14233
// tmp := 3 ;
14225: LD_ADDR_VAR 0 3
14229: PUSH
14230: LD_INT 3
14232: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14233: LD_VAR 0 1
14237: PUSH
14238: LD_EXP 55
14242: PUSH
14243: LD_VAR 0 4
14247: ARRAY
14248: IN
14249: IFFALSE 14259
// tmp := 4 ;
14251: LD_ADDR_VAR 0 3
14255: PUSH
14256: LD_INT 4
14258: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14259: LD_VAR 0 1
14263: PUSH
14264: LD_EXP 69
14268: PUSH
14269: LD_VAR 0 4
14273: ARRAY
14274: IN
14275: IFFALSE 14285
// tmp := 5 ;
14277: LD_ADDR_VAR 0 3
14281: PUSH
14282: LD_INT 5
14284: ST_TO_ADDR
// result := tmp ;
14285: LD_ADDR_VAR 0 2
14289: PUSH
14290: LD_VAR 0 3
14294: ST_TO_ADDR
// end ;
14295: LD_VAR 0 2
14299: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14300: LD_INT 0
14302: PPUSH
14303: PPUSH
// if mreg = ToArm then
14304: LD_VAR 0 2
14308: PUSH
14309: LD_STRING ToArm
14311: EQUAL
14312: IFFALSE 14401
// for i = MREG_ToArm [ side ] downto 1 do
14314: LD_ADDR_VAR 0 5
14318: PUSH
14319: DOUBLE
14320: LD_EXP 57
14324: PUSH
14325: LD_VAR 0 1
14329: ARRAY
14330: INC
14331: ST_TO_ADDR
14332: LD_INT 1
14334: PUSH
14335: FOR_DOWNTO
14336: IFFALSE 14399
// if MREG_ToArm [ side ] [ i ] = unit then
14338: LD_EXP 57
14342: PUSH
14343: LD_VAR 0 1
14347: ARRAY
14348: PUSH
14349: LD_VAR 0 5
14353: ARRAY
14354: PUSH
14355: LD_VAR 0 3
14359: EQUAL
14360: IFFALSE 14397
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14362: LD_ADDR_EXP 57
14366: PUSH
14367: LD_EXP 57
14371: PPUSH
14372: LD_EXP 57
14376: PUSH
14377: LD_VAR 0 1
14381: ARRAY
14382: PUSH
14383: LD_VAR 0 5
14387: ARRAY
14388: PPUSH
14389: LD_INT 1
14391: PPUSH
14392: CALL 31109 0 3
14396: ST_TO_ADDR
// end ;
14397: GO 14335
14399: POP
14400: POP
// if mreg = ToDep then
14401: LD_VAR 0 2
14405: PUSH
14406: LD_STRING ToDep
14408: EQUAL
14409: IFFALSE 14498
// for i = MREG_ToDep [ side ] downto 1 do
14411: LD_ADDR_VAR 0 5
14415: PUSH
14416: DOUBLE
14417: LD_EXP 58
14421: PUSH
14422: LD_VAR 0 1
14426: ARRAY
14427: INC
14428: ST_TO_ADDR
14429: LD_INT 1
14431: PUSH
14432: FOR_DOWNTO
14433: IFFALSE 14496
// if MREG_ToDep [ side ] [ i ] = unit then
14435: LD_EXP 58
14439: PUSH
14440: LD_VAR 0 1
14444: ARRAY
14445: PUSH
14446: LD_VAR 0 5
14450: ARRAY
14451: PUSH
14452: LD_VAR 0 3
14456: EQUAL
14457: IFFALSE 14494
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14459: LD_ADDR_EXP 58
14463: PUSH
14464: LD_EXP 58
14468: PPUSH
14469: LD_EXP 58
14473: PUSH
14474: LD_VAR 0 1
14478: ARRAY
14479: PUSH
14480: LD_VAR 0 5
14484: ARRAY
14485: PPUSH
14486: LD_INT 1
14488: PPUSH
14489: CALL 31109 0 3
14493: ST_TO_ADDR
// end ;
14494: GO 14432
14496: POP
14497: POP
// if mreg = ToFac then
14498: LD_VAR 0 2
14502: PUSH
14503: LD_STRING ToFac
14505: EQUAL
14506: IFFALSE 14595
// for i = MREG_ToFac [ side ] downto 1 do
14508: LD_ADDR_VAR 0 5
14512: PUSH
14513: DOUBLE
14514: LD_EXP 56
14518: PUSH
14519: LD_VAR 0 1
14523: ARRAY
14524: INC
14525: ST_TO_ADDR
14526: LD_INT 1
14528: PUSH
14529: FOR_DOWNTO
14530: IFFALSE 14593
// if MREG_ToFac [ side ] [ i ] = unit then
14532: LD_EXP 56
14536: PUSH
14537: LD_VAR 0 1
14541: ARRAY
14542: PUSH
14543: LD_VAR 0 5
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 3
14553: EQUAL
14554: IFFALSE 14591
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14556: LD_ADDR_EXP 56
14560: PUSH
14561: LD_EXP 56
14565: PPUSH
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: PUSH
14577: LD_VAR 0 5
14581: ARRAY
14582: PPUSH
14583: LD_INT 1
14585: PPUSH
14586: CALL 31109 0 3
14590: ST_TO_ADDR
// end ;
14591: GO 14529
14593: POP
14594: POP
// if mreg = ToLab then
14595: LD_VAR 0 2
14599: PUSH
14600: LD_STRING ToLab
14602: EQUAL
14603: IFFALSE 14692
// for i = MREG_ToLab [ side ] downto 1 do
14605: LD_ADDR_VAR 0 5
14609: PUSH
14610: DOUBLE
14611: LD_EXP 55
14615: PUSH
14616: LD_VAR 0 1
14620: ARRAY
14621: INC
14622: ST_TO_ADDR
14623: LD_INT 1
14625: PUSH
14626: FOR_DOWNTO
14627: IFFALSE 14690
// if MREG_ToLab [ side ] [ i ] = unit then
14629: LD_EXP 55
14633: PUSH
14634: LD_VAR 0 1
14638: ARRAY
14639: PUSH
14640: LD_VAR 0 5
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 3
14650: EQUAL
14651: IFFALSE 14688
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14653: LD_ADDR_EXP 55
14657: PUSH
14658: LD_EXP 55
14662: PPUSH
14663: LD_EXP 55
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: PUSH
14674: LD_VAR 0 5
14678: ARRAY
14679: PPUSH
14680: LD_INT 1
14682: PPUSH
14683: CALL 31109 0 3
14687: ST_TO_ADDR
// end ;
14688: GO 14626
14690: POP
14691: POP
// end ;
14692: LD_VAR 0 4
14696: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14697: LD_INT 0
14699: PPUSH
14700: PPUSH
// result := false ;
14701: LD_ADDR_VAR 0 2
14705: PUSH
14706: LD_INT 0
14708: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14709: LD_ADDR_VAR 0 3
14713: PUSH
14714: DOUBLE
14715: LD_INT 1
14717: DEC
14718: ST_TO_ADDR
14719: LD_EXP 47
14723: PUSH
14724: FOR_TO
14725: IFFALSE 14789
// if MREG_ToBuild [ i ] [ 1 ] = side then
14727: LD_EXP 47
14731: PUSH
14732: LD_VAR 0 3
14736: ARRAY
14737: PUSH
14738: LD_INT 1
14740: ARRAY
14741: PUSH
14742: LD_VAR 0 1
14746: EQUAL
14747: IFFALSE 14787
// begin if MREG_ToBuild [ i ] [ 1 ] then
14749: LD_EXP 47
14753: PUSH
14754: LD_VAR 0 3
14758: ARRAY
14759: PUSH
14760: LD_INT 1
14762: ARRAY
14763: IFFALSE 14787
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14765: LD_ADDR_VAR 0 2
14769: PUSH
14770: LD_EXP 47
14774: PUSH
14775: LD_VAR 0 3
14779: ARRAY
14780: PUSH
14781: LD_INT 1
14783: ARRAY
14784: ST_TO_ADDR
// break ;
14785: GO 14789
// end ; end ;
14787: GO 14724
14789: POP
14790: POP
// for i = 1 to MREG_ToRepair do
14791: LD_ADDR_VAR 0 3
14795: PUSH
14796: DOUBLE
14797: LD_INT 1
14799: DEC
14800: ST_TO_ADDR
14801: LD_EXP 48
14805: PUSH
14806: FOR_TO
14807: IFFALSE 14871
// if MREG_ToRepair [ i ] [ 1 ] = side then
14809: LD_EXP 48
14813: PUSH
14814: LD_VAR 0 3
14818: ARRAY
14819: PUSH
14820: LD_INT 1
14822: ARRAY
14823: PUSH
14824: LD_VAR 0 1
14828: EQUAL
14829: IFFALSE 14869
// begin if MREG_ToRepair [ i ] [ 1 ] then
14831: LD_EXP 48
14835: PUSH
14836: LD_VAR 0 3
14840: ARRAY
14841: PUSH
14842: LD_INT 1
14844: ARRAY
14845: IFFALSE 14869
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14847: LD_ADDR_VAR 0 2
14851: PUSH
14852: LD_EXP 48
14856: PUSH
14857: LD_VAR 0 3
14861: ARRAY
14862: PUSH
14863: LD_INT 1
14865: ARRAY
14866: ST_TO_ADDR
// break ;
14867: GO 14871
// end ; end ;
14869: GO 14806
14871: POP
14872: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14873: LD_VAR 0 1
14877: PPUSH
14878: LD_INT 57
14880: PUSH
14881: EMPTY
14882: LIST
14883: PPUSH
14884: CALL 11421 0 2
14888: IFFALSE 14915
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
14890: LD_ADDR_VAR 0 2
14894: PUSH
14895: LD_VAR 0 1
14899: PPUSH
14900: LD_INT 57
14902: PUSH
14903: EMPTY
14904: LIST
14905: PPUSH
14906: CALL 11421 0 2
14910: PUSH
14911: LD_INT 1
14913: ARRAY
14914: ST_TO_ADDR
// end ;
14915: LD_VAR 0 2
14919: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
14920: LD_INT 0
14922: PPUSH
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
14927: LD_ADDR_VAR 0 6
14931: PUSH
14932: LD_VAR 0 1
14936: PPUSH
14937: LD_INT 21
14939: PUSH
14940: LD_INT 3
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL 11421 0 2
14951: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
14952: LD_ADDR_VAR 0 7
14956: PUSH
14957: LD_VAR 0 1
14961: PPUSH
14962: LD_INT 81
14964: PUSH
14965: LD_VAR 0 1
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL 11421 0 2
14978: ST_TO_ADDR
// if not enemy then
14979: LD_VAR 0 7
14983: NOT
14984: IFFALSE 14996
// result := false else
14986: LD_ADDR_VAR 0 3
14990: PUSH
14991: LD_INT 0
14993: ST_TO_ADDR
14994: GO 15050
// begin scan := NearestUnit ( b , enemy ) ;
14996: LD_ADDR_VAR 0 5
15000: PUSH
15001: LD_VAR 0 6
15005: PPUSH
15006: LD_VAR 0 7
15010: PPUSH
15011: CALL 32434 0 2
15015: ST_TO_ADDR
// if scan [ 2 ] < dist then
15016: LD_VAR 0 5
15020: PUSH
15021: LD_INT 2
15023: ARRAY
15024: PUSH
15025: LD_VAR 0 2
15029: LESS
15030: IFFALSE 15042
// result := true else
15032: LD_ADDR_VAR 0 3
15036: PUSH
15037: LD_INT 1
15039: ST_TO_ADDR
15040: GO 15050
// result := false ;
15042: LD_ADDR_VAR 0 3
15046: PUSH
15047: LD_INT 0
15049: ST_TO_ADDR
// end ; end ;
15050: LD_VAR 0 3
15054: RET
// export function MCF_Info ( ) ; begin
15055: LD_INT 0
15057: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15058: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15060: PUSH
15061: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15063: ADD
15064: PUSH
15065: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15067: ADD
15068: PUSH
15069: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15071: ADD
15072: PUSH
15073: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15075: ADD
15076: PUSH
15077: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15079: ADD
15080: PUSH
15081: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15083: ADD
15084: PUSH
15085: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15087: ADD
15088: PUSH
15089: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15091: ADD
15092: PUSH
15093: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15095: ADD
15096: PPUSH
15097: CALL 8339 0 1
// end ; end_of_file
15101: LD_VAR 0 1
15105: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15106: LD_INT 0
15108: PPUSH
15109: PPUSH
15110: PPUSH
15111: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15112: LD_ADDR_VAR 0 5
15116: PUSH
15117: LD_VAR 0 1
15121: PPUSH
15122: LD_INT 2
15124: PUSH
15125: LD_INT 25
15127: PUSH
15128: LD_INT 2
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 25
15137: PUSH
15138: LD_INT 3
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 25
15147: PUSH
15148: LD_INT 4
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: PPUSH
15161: CALL 11421 0 2
15165: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15166: LD_ADDR_VAR 0 5
15170: PUSH
15171: LD_VAR 0 5
15175: PPUSH
15176: LD_INT 0
15178: PPUSH
15179: CALL 13570 0 2
15183: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15184: LD_ADDR_VAR 0 6
15188: PUSH
15189: LD_VAR 0 1
15193: PPUSH
15194: LD_VAR 0 5
15198: PPUSH
15199: LD_INT 1
15201: PPUSH
15202: CALL 13190 0 3
15206: ST_TO_ADDR
// if n > sk then
15207: LD_VAR 0 2
15211: PUSH
15212: LD_VAR 0 6
15216: GREATER
15217: IFFALSE 15229
// n := sk ;
15219: LD_ADDR_VAR 0 2
15223: PUSH
15224: LD_VAR 0 6
15228: ST_TO_ADDR
// for i = 1 to n do
15229: LD_ADDR_VAR 0 4
15233: PUSH
15234: DOUBLE
15235: LD_INT 1
15237: DEC
15238: ST_TO_ADDR
15239: LD_VAR 0 2
15243: PUSH
15244: FOR_TO
15245: IFFALSE 15357
// if ( sk [ i ] [ 1 ] ) <> 0 then
15247: LD_VAR 0 6
15251: PUSH
15252: LD_VAR 0 4
15256: ARRAY
15257: PUSH
15258: LD_INT 1
15260: ARRAY
15261: PUSH
15262: LD_INT 0
15264: NONEQUAL
15265: IFFALSE 15355
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15267: LD_ADDR_EXP 54
15271: PUSH
15272: LD_EXP 54
15276: PPUSH
15277: LD_VAR 0 1
15281: PPUSH
15282: LD_VAR 0 6
15286: PUSH
15287: LD_VAR 0 4
15291: ARRAY
15292: PUSH
15293: LD_INT 1
15295: ARRAY
15296: PPUSH
15297: LD_INT 1
15299: PPUSH
15300: CALL 42232 0 4
15304: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15305: LD_ADDR_EXP 57
15309: PUSH
15310: LD_EXP 57
15314: PPUSH
15315: LD_VAR 0 1
15319: PPUSH
15320: LD_EXP 57
15324: PUSH
15325: LD_VAR 0 1
15329: ARRAY
15330: PUSH
15331: LD_INT 1
15333: PLUS
15334: PPUSH
15335: LD_VAR 0 6
15339: PUSH
15340: LD_VAR 0 4
15344: ARRAY
15345: PUSH
15346: LD_INT 1
15348: ARRAY
15349: PPUSH
15350: CALL 30950 0 4
15354: ST_TO_ADDR
// end ;
15355: GO 15244
15357: POP
15358: POP
// end ;
15359: LD_VAR 0 3
15363: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15364: LD_INT 0
15366: PPUSH
15367: PPUSH
15368: PPUSH
15369: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15370: LD_ADDR_VAR 0 5
15374: PUSH
15375: LD_VAR 0 1
15379: PPUSH
15380: LD_INT 2
15382: PUSH
15383: LD_INT 25
15385: PUSH
15386: LD_INT 1
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: PUSH
15393: LD_INT 25
15395: PUSH
15396: LD_INT 3
15398: PUSH
15399: EMPTY
15400: LIST
15401: LIST
15402: PUSH
15403: LD_INT 25
15405: PUSH
15406: LD_INT 4
15408: PUSH
15409: EMPTY
15410: LIST
15411: LIST
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: PPUSH
15419: CALL 11421 0 2
15423: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15424: LD_ADDR_VAR 0 5
15428: PUSH
15429: LD_VAR 0 5
15433: PPUSH
15434: LD_INT 0
15436: PPUSH
15437: CALL 13570 0 2
15441: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15442: LD_ADDR_VAR 0 6
15446: PUSH
15447: LD_VAR 0 1
15451: PPUSH
15452: LD_VAR 0 5
15456: PPUSH
15457: LD_INT 2
15459: PPUSH
15460: CALL 13190 0 3
15464: ST_TO_ADDR
// if n > sk then
15465: LD_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: GREATER
15475: IFFALSE 15487
// n := sk ;
15477: LD_ADDR_VAR 0 2
15481: PUSH
15482: LD_VAR 0 6
15486: ST_TO_ADDR
// for i = 1 to n do
15487: LD_ADDR_VAR 0 4
15491: PUSH
15492: DOUBLE
15493: LD_INT 1
15495: DEC
15496: ST_TO_ADDR
15497: LD_VAR 0 2
15501: PUSH
15502: FOR_TO
15503: IFFALSE 15615
// if ( sk [ i ] [ 1 ] ) <> 0 then
15505: LD_VAR 0 6
15509: PUSH
15510: LD_VAR 0 4
15514: ARRAY
15515: PUSH
15516: LD_INT 1
15518: ARRAY
15519: PUSH
15520: LD_INT 0
15522: NONEQUAL
15523: IFFALSE 15613
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15525: LD_ADDR_EXP 54
15529: PUSH
15530: LD_EXP 54
15534: PPUSH
15535: LD_VAR 0 1
15539: PPUSH
15540: LD_VAR 0 6
15544: PUSH
15545: LD_VAR 0 4
15549: ARRAY
15550: PUSH
15551: LD_INT 1
15553: ARRAY
15554: PPUSH
15555: LD_INT 2
15557: PPUSH
15558: CALL 42232 0 4
15562: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15563: LD_ADDR_EXP 58
15567: PUSH
15568: LD_EXP 58
15572: PPUSH
15573: LD_VAR 0 1
15577: PPUSH
15578: LD_EXP 58
15582: PUSH
15583: LD_VAR 0 1
15587: ARRAY
15588: PUSH
15589: LD_INT 1
15591: PLUS
15592: PPUSH
15593: LD_VAR 0 6
15597: PUSH
15598: LD_VAR 0 4
15602: ARRAY
15603: PUSH
15604: LD_INT 1
15606: ARRAY
15607: PPUSH
15608: CALL 30950 0 4
15612: ST_TO_ADDR
// end ;
15613: GO 15502
15615: POP
15616: POP
// end ;
15617: LD_VAR 0 3
15621: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15622: LD_INT 0
15624: PPUSH
15625: PPUSH
15626: PPUSH
15627: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15628: LD_ADDR_VAR 0 5
15632: PUSH
15633: LD_VAR 0 1
15637: PPUSH
15638: LD_INT 2
15640: PUSH
15641: LD_INT 25
15643: PUSH
15644: LD_INT 1
15646: PUSH
15647: EMPTY
15648: LIST
15649: LIST
15650: PUSH
15651: LD_INT 25
15653: PUSH
15654: LD_INT 2
15656: PUSH
15657: EMPTY
15658: LIST
15659: LIST
15660: PUSH
15661: LD_INT 25
15663: PUSH
15664: LD_INT 4
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: PUSH
15671: EMPTY
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: PPUSH
15677: CALL 11421 0 2
15681: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15682: LD_ADDR_VAR 0 5
15686: PUSH
15687: LD_VAR 0 5
15691: PPUSH
15692: LD_INT 0
15694: PPUSH
15695: CALL 13570 0 2
15699: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15700: LD_ADDR_VAR 0 6
15704: PUSH
15705: LD_VAR 0 1
15709: PPUSH
15710: LD_VAR 0 5
15714: PPUSH
15715: LD_INT 3
15717: PPUSH
15718: CALL 13190 0 3
15722: ST_TO_ADDR
// if n > sk then
15723: LD_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: GREATER
15733: IFFALSE 15745
// n := sk ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_VAR 0 6
15744: ST_TO_ADDR
// for i = 1 to n do
15745: LD_ADDR_VAR 0 4
15749: PUSH
15750: DOUBLE
15751: LD_INT 1
15753: DEC
15754: ST_TO_ADDR
15755: LD_VAR 0 2
15759: PUSH
15760: FOR_TO
15761: IFFALSE 15873
// if ( sk [ i ] [ 1 ] ) <> 0 then
15763: LD_VAR 0 6
15767: PUSH
15768: LD_VAR 0 4
15772: ARRAY
15773: PUSH
15774: LD_INT 1
15776: ARRAY
15777: PUSH
15778: LD_INT 0
15780: NONEQUAL
15781: IFFALSE 15871
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15783: LD_ADDR_EXP 54
15787: PUSH
15788: LD_EXP 54
15792: PPUSH
15793: LD_VAR 0 1
15797: PPUSH
15798: LD_VAR 0 6
15802: PUSH
15803: LD_VAR 0 4
15807: ARRAY
15808: PUSH
15809: LD_INT 1
15811: ARRAY
15812: PPUSH
15813: LD_INT 3
15815: PPUSH
15816: CALL 42232 0 4
15820: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15821: LD_ADDR_EXP 56
15825: PUSH
15826: LD_EXP 56
15830: PPUSH
15831: LD_VAR 0 1
15835: PPUSH
15836: LD_EXP 56
15840: PUSH
15841: LD_VAR 0 1
15845: ARRAY
15846: PUSH
15847: LD_INT 1
15849: PLUS
15850: PPUSH
15851: LD_VAR 0 6
15855: PUSH
15856: LD_VAR 0 4
15860: ARRAY
15861: PUSH
15862: LD_INT 1
15864: ARRAY
15865: PPUSH
15866: CALL 30950 0 4
15870: ST_TO_ADDR
// end ;
15871: GO 15760
15873: POP
15874: POP
// end ;
15875: LD_VAR 0 3
15879: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
15880: LD_INT 0
15882: PPUSH
15883: PPUSH
15884: PPUSH
15885: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
15886: LD_ADDR_VAR 0 5
15890: PUSH
15891: LD_VAR 0 1
15895: PPUSH
15896: LD_INT 2
15898: PUSH
15899: LD_INT 25
15901: PUSH
15902: LD_INT 1
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: LD_INT 25
15911: PUSH
15912: LD_INT 2
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: LIST
15923: PPUSH
15924: CALL 11421 0 2
15928: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15929: LD_ADDR_VAR 0 5
15933: PUSH
15934: LD_VAR 0 5
15938: PPUSH
15939: LD_INT 0
15941: PPUSH
15942: CALL 13570 0 2
15946: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
15947: LD_ADDR_VAR 0 6
15951: PUSH
15952: LD_VAR 0 1
15956: PPUSH
15957: LD_VAR 0 5
15961: PPUSH
15962: LD_INT 4
15964: PPUSH
15965: CALL 13190 0 3
15969: ST_TO_ADDR
// if n > sk then
15970: LD_VAR 0 2
15974: PUSH
15975: LD_VAR 0 6
15979: GREATER
15980: IFFALSE 15992
// n := sk ;
15982: LD_ADDR_VAR 0 2
15986: PUSH
15987: LD_VAR 0 6
15991: ST_TO_ADDR
// for i = 1 to n do
15992: LD_ADDR_VAR 0 4
15996: PUSH
15997: DOUBLE
15998: LD_INT 1
16000: DEC
16001: ST_TO_ADDR
16002: LD_VAR 0 2
16006: PUSH
16007: FOR_TO
16008: IFFALSE 16120
// if ( sk [ i ] [ 1 ] ) <> 0 then
16010: LD_VAR 0 6
16014: PUSH
16015: LD_VAR 0 4
16019: ARRAY
16020: PUSH
16021: LD_INT 1
16023: ARRAY
16024: PUSH
16025: LD_INT 0
16027: NONEQUAL
16028: IFFALSE 16118
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16030: LD_ADDR_EXP 54
16034: PUSH
16035: LD_EXP 54
16039: PPUSH
16040: LD_VAR 0 1
16044: PPUSH
16045: LD_VAR 0 6
16049: PUSH
16050: LD_VAR 0 4
16054: ARRAY
16055: PUSH
16056: LD_INT 1
16058: ARRAY
16059: PPUSH
16060: LD_INT 4
16062: PPUSH
16063: CALL 42232 0 4
16067: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16068: LD_ADDR_EXP 55
16072: PUSH
16073: LD_EXP 55
16077: PPUSH
16078: LD_VAR 0 1
16082: PPUSH
16083: LD_EXP 55
16087: PUSH
16088: LD_VAR 0 1
16092: ARRAY
16093: PUSH
16094: LD_INT 1
16096: PLUS
16097: PPUSH
16098: LD_VAR 0 6
16102: PUSH
16103: LD_VAR 0 4
16107: ARRAY
16108: PUSH
16109: LD_INT 1
16111: ARRAY
16112: PPUSH
16113: CALL 30950 0 4
16117: ST_TO_ADDR
// end ;
16118: GO 16007
16120: POP
16121: POP
// end ;
16122: LD_VAR 0 3
16126: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16127: LD_INT 0
16129: PPUSH
16130: PPUSH
16131: PPUSH
16132: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16133: LD_ADDR_VAR 0 6
16137: PUSH
16138: LD_VAR 0 1
16142: PPUSH
16143: LD_INT 2
16145: PUSH
16146: LD_INT 25
16148: PUSH
16149: LD_INT 1
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: PUSH
16156: LD_INT 25
16158: PUSH
16159: LD_INT 2
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PUSH
16166: LD_INT 25
16168: PUSH
16169: LD_INT 3
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: PUSH
16176: LD_INT 25
16178: PUSH
16179: LD_INT 4
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: LIST
16190: LIST
16191: LIST
16192: PPUSH
16193: CALL 11421 0 2
16197: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16198: LD_ADDR_VAR 0 6
16202: PUSH
16203: LD_VAR 0 6
16207: PPUSH
16208: LD_INT 0
16210: PPUSH
16211: CALL 13570 0 2
16215: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16216: LD_ADDR_VAR 0 7
16220: PUSH
16221: LD_VAR 0 1
16225: PPUSH
16226: LD_VAR 0 6
16230: PPUSH
16231: LD_INT 1
16233: PPUSH
16234: CALL 13190 0 3
16238: ST_TO_ADDR
// if n > sk then
16239: LD_VAR 0 2
16243: PUSH
16244: LD_VAR 0 7
16248: GREATER
16249: IFFALSE 16261
// n := sk ;
16251: LD_ADDR_VAR 0 2
16255: PUSH
16256: LD_VAR 0 7
16260: ST_TO_ADDR
// for i = 1 to n do
16261: LD_ADDR_VAR 0 5
16265: PUSH
16266: DOUBLE
16267: LD_INT 1
16269: DEC
16270: ST_TO_ADDR
16271: LD_VAR 0 2
16275: PUSH
16276: FOR_TO
16277: IFFALSE 16321
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16279: LD_ADDR_EXP 54
16283: PUSH
16284: LD_EXP 54
16288: PPUSH
16289: LD_VAR 0 1
16293: PPUSH
16294: LD_VAR 0 7
16298: PUSH
16299: LD_VAR 0 5
16303: ARRAY
16304: PUSH
16305: LD_INT 1
16307: ARRAY
16308: PPUSH
16309: LD_VAR 0 3
16313: PPUSH
16314: CALL 42232 0 4
16318: ST_TO_ADDR
// end ;
16319: GO 16276
16321: POP
16322: POP
// end ;
16323: LD_VAR 0 4
16327: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16328: LD_INT 0
16330: PPUSH
16331: PPUSH
16332: PPUSH
// b := false ;
16333: LD_ADDR_VAR 0 6
16337: PUSH
16338: LD_INT 0
16340: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16341: LD_VAR 0 3
16345: PUSH
16346: LD_INT 1
16348: PUSH
16349: LD_INT 9
16351: PUSH
16352: LD_INT 5
16354: PUSH
16355: LD_INT 8
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: LIST
16362: LIST
16363: IN
16364: IFFALSE 16452
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16366: LD_VAR 0 1
16370: PPUSH
16371: LD_INT 2
16373: PUSH
16374: LD_INT 30
16376: PUSH
16377: LD_INT 4
16379: PUSH
16380: EMPTY
16381: LIST
16382: LIST
16383: PUSH
16384: LD_INT 30
16386: PUSH
16387: LD_INT 5
16389: PUSH
16390: EMPTY
16391: LIST
16392: LIST
16393: PUSH
16394: EMPTY
16395: LIST
16396: LIST
16397: LIST
16398: PPUSH
16399: CALL 11421 0 2
16403: IFFALSE 16452
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16405: LD_ADDR_VAR 0 6
16409: PUSH
16410: LD_VAR 0 1
16414: PPUSH
16415: LD_INT 2
16417: PUSH
16418: LD_INT 30
16420: PUSH
16421: LD_INT 4
16423: PUSH
16424: EMPTY
16425: LIST
16426: LIST
16427: PUSH
16428: LD_INT 30
16430: PUSH
16431: LD_INT 5
16433: PUSH
16434: EMPTY
16435: LIST
16436: LIST
16437: PUSH
16438: EMPTY
16439: LIST
16440: LIST
16441: LIST
16442: PPUSH
16443: CALL 11421 0 2
16447: PUSH
16448: LD_INT 1
16450: ARRAY
16451: ST_TO_ADDR
// if class = class_engineer then
16452: LD_VAR 0 3
16456: PUSH
16457: LD_INT 2
16459: EQUAL
16460: IFFALSE 16548
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16462: LD_VAR 0 1
16466: PPUSH
16467: LD_INT 2
16469: PUSH
16470: LD_INT 30
16472: PUSH
16473: LD_INT 0
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: PUSH
16480: LD_INT 30
16482: PUSH
16483: LD_INT 1
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: LIST
16494: PPUSH
16495: CALL 11421 0 2
16499: IFFALSE 16548
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16501: LD_ADDR_VAR 0 6
16505: PUSH
16506: LD_VAR 0 1
16510: PPUSH
16511: LD_INT 2
16513: PUSH
16514: LD_INT 30
16516: PUSH
16517: LD_INT 0
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: PUSH
16524: LD_INT 30
16526: PUSH
16527: LD_INT 1
16529: PUSH
16530: EMPTY
16531: LIST
16532: LIST
16533: PUSH
16534: EMPTY
16535: LIST
16536: LIST
16537: LIST
16538: PPUSH
16539: CALL 11421 0 2
16543: PUSH
16544: LD_INT 1
16546: ARRAY
16547: ST_TO_ADDR
// if class = class_mechanic then
16548: LD_VAR 0 3
16552: PUSH
16553: LD_INT 3
16555: EQUAL
16556: IFFALSE 16626
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16558: LD_VAR 0 1
16562: PPUSH
16563: LD_INT 30
16565: PUSH
16566: LD_INT 3
16568: PUSH
16569: EMPTY
16570: LIST
16571: LIST
16572: PPUSH
16573: CALL 11421 0 2
16577: IFFALSE 16626
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_VAR 0 1
16588: PPUSH
16589: LD_INT 2
16591: PUSH
16592: LD_INT 30
16594: PUSH
16595: LD_INT 2
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: LD_INT 30
16604: PUSH
16605: LD_INT 3
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: LIST
16616: PPUSH
16617: CALL 11421 0 2
16621: PUSH
16622: LD_INT 1
16624: ARRAY
16625: ST_TO_ADDR
// if class = class_scientistic then
16626: LD_VAR 0 3
16630: PUSH
16631: LD_INT 4
16633: EQUAL
16634: IFFALSE 16744
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16636: LD_VAR 0 1
16640: PPUSH
16641: LD_INT 2
16643: PUSH
16644: LD_INT 30
16646: PUSH
16647: LD_INT 6
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: PUSH
16654: LD_INT 30
16656: PUSH
16657: LD_INT 7
16659: PUSH
16660: EMPTY
16661: LIST
16662: LIST
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 8
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL 11421 0 2
16684: IFFALSE 16744
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16686: LD_ADDR_VAR 0 6
16690: PUSH
16691: LD_VAR 0 1
16695: PPUSH
16696: LD_INT 2
16698: PUSH
16699: LD_INT 30
16701: PUSH
16702: LD_INT 6
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: LD_INT 30
16711: PUSH
16712: LD_INT 7
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PUSH
16719: LD_INT 30
16721: PUSH
16722: LD_INT 8
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: PUSH
16729: EMPTY
16730: LIST
16731: LIST
16732: LIST
16733: LIST
16734: PPUSH
16735: CALL 11421 0 2
16739: PUSH
16740: LD_INT 1
16742: ARRAY
16743: ST_TO_ADDR
// if GetClass ( unit ) = class then
16744: LD_VAR 0 2
16748: PPUSH
16749: CALL_OW 257
16753: PUSH
16754: LD_VAR 0 3
16758: EQUAL
16759: IFFALSE 16793
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16761: LD_ADDR_EXP 54
16765: PUSH
16766: LD_EXP 54
16770: PPUSH
16771: LD_VAR 0 1
16775: PPUSH
16776: LD_VAR 0 2
16780: PPUSH
16781: LD_VAR 0 3
16785: PPUSH
16786: CALL 42323 0 4
16790: ST_TO_ADDR
// end else
16791: GO 16886
// if b then
16793: LD_VAR 0 6
16797: IFFALSE 16878
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16799: LD_VAR 0 2
16803: PPUSH
16804: CALL_OW 310
16808: PUSH
16809: LD_VAR 0 2
16813: PPUSH
16814: CALL_OW 310
16818: PUSH
16819: LD_VAR 0 6
16823: NONEQUAL
16824: AND
16825: IFFALSE 16836
// ComExitBuilding ( unit ) ;
16827: LD_VAR 0 2
16831: PPUSH
16832: CALL_OW 122
// if not IsInUnit ( unit ) then
16836: LD_VAR 0 2
16840: PPUSH
16841: CALL_OW 310
16845: NOT
16846: IFFALSE 16862
// ComEnterUnit ( unit , b ) ;
16848: LD_VAR 0 2
16852: PPUSH
16853: LD_VAR 0 6
16857: PPUSH
16858: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16862: LD_VAR 0 2
16866: PPUSH
16867: LD_VAR 0 3
16871: PPUSH
16872: CALL_OW 183
// end else
16876: GO 16886
// result := false ;
16878: LD_ADDR_VAR 0 4
16882: PUSH
16883: LD_INT 0
16885: ST_TO_ADDR
// end ; end_of_file
16886: LD_VAR 0 4
16890: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
16891: LD_INT 0
16893: PPUSH
16894: PPUSH
16895: PPUSH
16896: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16897: LD_ADDR_VAR 0 5
16901: PUSH
16902: LD_INT 35
16904: PUSH
16905: LD_INT 45
16907: PUSH
16908: LD_INT 46
16910: PUSH
16911: LD_INT 47
16913: PUSH
16914: LD_INT 1
16916: PUSH
16917: LD_INT 2
16919: PUSH
16920: LD_INT 48
16922: PUSH
16923: LD_INT 49
16925: PUSH
16926: LD_INT 50
16928: PUSH
16929: LD_INT 20
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: ST_TO_ADDR
// if MCF_Lab ( side ) then
16944: LD_VAR 0 1
16948: PPUSH
16949: CALL 11460 0 1
16953: IFFALSE 17192
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
16955: LD_VAR 0 1
16959: PPUSH
16960: CALL 11460 0 1
16964: PUSH
16965: LD_INT 1
16967: ARRAY
16968: PPUSH
16969: CALL_OW 461
16973: PUSH
16974: LD_INT 2
16976: EQUAL
16977: IFFALSE 17116
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
16979: LD_VAR 0 1
16983: PPUSH
16984: CALL 11460 0 1
16988: PUSH
16989: LD_INT 1
16991: ARRAY
16992: PPUSH
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL 17288 0 2
17002: IFFALSE 17029
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL 11460 0 1
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: PPUSH
17018: LD_VAR 0 2
17022: PPUSH
17023: CALL_OW 124
17027: GO 17116
// if MCF_Lab ( side ) > 1 then
17029: LD_VAR 0 1
17033: PPUSH
17034: CALL 11460 0 1
17038: PUSH
17039: LD_INT 1
17041: GREATER
17042: IFFALSE 17116
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17044: LD_VAR 0 1
17048: PPUSH
17049: CALL 11460 0 1
17053: PUSH
17054: LD_INT 2
17056: ARRAY
17057: PPUSH
17058: CALL_OW 461
17062: PUSH
17063: LD_INT 2
17065: EQUAL
17066: IFFALSE 17116
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17068: LD_VAR 0 1
17072: PPUSH
17073: CALL 11460 0 1
17077: PUSH
17078: LD_INT 2
17080: ARRAY
17081: PPUSH
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL 17288 0 2
17091: IFFALSE 17116
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17093: LD_VAR 0 1
17097: PPUSH
17098: CALL 11460 0 1
17102: PUSH
17103: LD_INT 2
17105: ARRAY
17106: PPUSH
17107: LD_VAR 0 2
17111: PPUSH
17112: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17116: LD_VAR 0 2
17120: PUSH
17121: LD_INT 2
17123: PUSH
17124: LD_INT 11
17126: PUSH
17127: LD_INT 4
17129: PUSH
17130: LD_INT 3
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: LIST
17137: LIST
17138: IN
17139: IFFALSE 17192
// begin for lab in MCF_Lab ( side ) do
17141: LD_ADDR_VAR 0 6
17145: PUSH
17146: LD_VAR 0 1
17150: PPUSH
17151: CALL 11460 0 1
17155: PUSH
17156: FOR_IN
17157: IFFALSE 17190
// if BuildingStatus ( lab ) = bs_need_ape then
17159: LD_VAR 0 6
17163: PPUSH
17164: CALL_OW 461
17168: PUSH
17169: LD_INT 10
17171: EQUAL
17172: IFFALSE 17188
// MCL_ResTame ( side , lab ) ;
17174: LD_VAR 0 1
17178: PPUSH
17179: LD_VAR 0 6
17183: PPUSH
17184: CALL 17413 0 2
17188: GO 17156
17190: POP
17191: POP
// end ; end ; end ;
17192: LD_VAR 0 3
17196: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17197: LD_INT 0
17199: PPUSH
17200: PPUSH
// tmp := [ ] ;
17201: LD_ADDR_VAR 0 3
17205: PUSH
17206: EMPTY
17207: ST_TO_ADDR
// if not lab then
17208: LD_VAR 0 1
17212: NOT
17213: IFFALSE 17225
// result := false else
17215: LD_ADDR_VAR 0 2
17219: PUSH
17220: LD_INT 0
17222: ST_TO_ADDR
17223: GO 17283
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17225: LD_ADDR_VAR 0 3
17229: PUSH
17230: LD_VAR 0 3
17234: PUSH
17235: LD_VAR 0 1
17239: PPUSH
17240: LD_INT 1
17242: PPUSH
17243: CALL_OW 268
17247: ADD
17248: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17249: LD_ADDR_VAR 0 3
17253: PUSH
17254: LD_VAR 0 3
17258: PUSH
17259: LD_VAR 0 1
17263: PPUSH
17264: LD_INT 2
17266: PPUSH
17267: CALL_OW 268
17271: ADD
17272: ST_TO_ADDR
// result := tmp ;
17273: LD_ADDR_VAR 0 2
17277: PUSH
17278: LD_VAR 0 3
17282: ST_TO_ADDR
// end ; end ;
17283: LD_VAR 0 2
17287: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17288: LD_INT 0
17290: PPUSH
17291: PPUSH
17292: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17293: LD_ADDR_VAR 0 5
17297: PUSH
17298: LD_INT 35
17300: PUSH
17301: LD_INT 45
17303: PUSH
17304: LD_INT 46
17306: PUSH
17307: LD_INT 47
17309: PUSH
17310: LD_INT 1
17312: PUSH
17313: LD_INT 2
17315: PUSH
17316: LD_INT 48
17318: PUSH
17319: LD_INT 49
17321: PUSH
17322: LD_INT 50
17324: PUSH
17325: LD_INT 20
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: LIST
17332: LIST
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: ST_TO_ADDR
// if lab then
17340: LD_VAR 0 1
17344: IFFALSE 17400
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_VAR 0 5
17355: IN
17356: PUSH
17357: LD_VAR 0 2
17361: PPUSH
17362: CALL_OW 481
17366: PUSH
17367: LD_VAR 0 1
17371: PPUSH
17372: CALL 17197 0 1
17376: IN
17377: OR
17378: IFFALSE 17390
// result := true else
17380: LD_ADDR_VAR 0 3
17384: PUSH
17385: LD_INT 1
17387: ST_TO_ADDR
17388: GO 17398
// result := false ;
17390: LD_ADDR_VAR 0 3
17394: PUSH
17395: LD_INT 0
17397: ST_TO_ADDR
// end else
17398: GO 17408
// result := false ;
17400: LD_ADDR_VAR 0 3
17404: PUSH
17405: LD_INT 0
17407: ST_TO_ADDR
// end ;
17408: LD_VAR 0 3
17412: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17413: LD_INT 0
17415: PPUSH
17416: PPUSH
17417: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17418: LD_ADDR_VAR 0 4
17422: PUSH
17423: LD_VAR 0 1
17427: PPUSH
17428: LD_INT 171
17430: PPUSH
17431: EMPTY
17432: PPUSH
17433: CALL 12124 0 3
17437: ST_TO_ADDR
// if not ape then
17438: LD_VAR 0 4
17442: NOT
17443: IFFALSE 17475
// if MCF_Ape ( side ) then
17445: LD_VAR 0 1
17449: PPUSH
17450: CALL 11834 0 1
17454: IFFALSE 17475
// ape := MCF_Ape ( side ) [ 1 ] ;
17456: LD_ADDR_VAR 0 4
17460: PUSH
17461: LD_VAR 0 1
17465: PPUSH
17466: CALL 11834 0 1
17470: PUSH
17471: LD_INT 1
17473: ARRAY
17474: ST_TO_ADDR
// if ape then
17475: LD_VAR 0 4
17479: IFFALSE 17530
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17481: LD_VAR 0 4
17485: PUSH
17486: LD_INT 1
17488: ARRAY
17489: PPUSH
17490: CALL_OW 310
17494: PUSH
17495: LD_VAR 0 4
17499: PUSH
17500: LD_INT 1
17502: ARRAY
17503: PPUSH
17504: CALL_OW 310
17508: PUSH
17509: LD_VAR 0 2
17513: NONEQUAL
17514: AND
17515: IFFALSE 17530
// ComExitBuilding ( ape [ 1 ] ) ;
17517: LD_VAR 0 4
17521: PUSH
17522: LD_INT 1
17524: ARRAY
17525: PPUSH
17526: CALL_OW 122
// if not lab then
17530: LD_VAR 0 2
17534: NOT
17535: IFFALSE 17541
// exit else
17537: GO 17689
17539: GO 17649
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17541: LD_VAR 0 1
17545: PPUSH
17546: LD_INT 16
17548: PPUSH
17549: LD_INT 25
17551: PUSH
17552: LD_INT 4
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: PPUSH
17559: CALL 12124 0 3
17563: PUSH
17564: LD_INT 0
17566: EQUAL
17567: PUSH
17568: LD_VAR 0 2
17572: PPUSH
17573: CALL_OW 313
17577: PUSH
17578: LD_INT 6
17580: EQUAL
17581: AND
17582: IFFALSE 17649
// begin tmp := UnitsInside ( lab ) ;
17584: LD_ADDR_VAR 0 5
17588: PUSH
17589: LD_VAR 0 2
17593: PPUSH
17594: CALL_OW 313
17598: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17599: LD_VAR 0 5
17603: PUSH
17604: LD_VAR 0 5
17608: ARRAY
17609: PPUSH
17610: LD_INT 16
17612: PPUSH
17613: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17617: LD_VAR 0 5
17621: PUSH
17622: LD_VAR 0 5
17626: ARRAY
17627: PPUSH
17628: CALL_OW 310
17632: IFFALSE 17649
// ComExitBuilding ( tmp [ tmp ] ) ;
17634: LD_VAR 0 5
17638: PUSH
17639: LD_VAR 0 5
17643: ARRAY
17644: PPUSH
17645: CALL_OW 122
// end ; if ape then
17649: LD_VAR 0 4
17653: IFFALSE 17689
// if not IsInUnit ( ape [ 1 ] ) then
17655: LD_VAR 0 4
17659: PUSH
17660: LD_INT 1
17662: ARRAY
17663: PPUSH
17664: CALL_OW 310
17668: NOT
17669: IFFALSE 17689
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17671: LD_VAR 0 4
17675: PUSH
17676: LD_INT 1
17678: ARRAY
17679: PPUSH
17680: LD_VAR 0 2
17684: PPUSH
17685: CALL_OW 120
// end ;
17689: LD_VAR 0 3
17693: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17694: LD_INT 0
17696: PPUSH
17697: PPUSH
17698: PPUSH
// result := false ;
17699: LD_ADDR_VAR 0 2
17703: PUSH
17704: LD_INT 0
17706: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_VAR 0 1
17716: PPUSH
17717: CALL 17804 0 1
17721: ST_TO_ADDR
// if techs then
17722: LD_VAR 0 3
17726: IFFALSE 17756
// if techs [ 2 ] then
17728: LD_VAR 0 3
17732: PUSH
17733: LD_INT 2
17735: ARRAY
17736: IFFALSE 17748
// result := true else
17738: LD_ADDR_VAR 0 2
17742: PUSH
17743: LD_INT 1
17745: ST_TO_ADDR
17746: GO 17756
// result := false ;
17748: LD_ADDR_VAR 0 2
17752: PUSH
17753: LD_INT 0
17755: ST_TO_ADDR
// end ;
17756: LD_VAR 0 2
17760: RET
// export function MCL_Start ( side ) ; var i ; begin
17761: LD_INT 0
17763: PPUSH
17764: PPUSH
// if MCL_GetTechList ( side ) then
17765: LD_VAR 0 1
17769: PPUSH
17770: CALL 17804 0 1
17774: IFFALSE 17799
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17776: LD_VAR 0 1
17780: PPUSH
17781: LD_VAR 0 1
17785: PPUSH
17786: CALL 17804 0 1
17790: PUSH
17791: LD_INT 1
17793: ARRAY
17794: PPUSH
17795: CALL 16891 0 2
// end ;
17799: LD_VAR 0 2
17803: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17804: LD_INT 0
17806: PPUSH
17807: PPUSH
17808: PPUSH
// if MREG_ToRes then
17809: LD_EXP 51
17813: IFFALSE 17898
// for i = 1 to MREG_ToRes do
17815: LD_ADDR_VAR 0 3
17819: PUSH
17820: DOUBLE
17821: LD_INT 1
17823: DEC
17824: ST_TO_ADDR
17825: LD_EXP 51
17829: PUSH
17830: FOR_TO
17831: IFFALSE 17896
// if MREG_ToRes [ i ] [ 1 ] = side then
17833: LD_EXP 51
17837: PUSH
17838: LD_VAR 0 3
17842: ARRAY
17843: PUSH
17844: LD_INT 1
17846: ARRAY
17847: PUSH
17848: LD_VAR 0 1
17852: EQUAL
17853: IFFALSE 17894
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17855: LD_ADDR_VAR 0 4
17859: PUSH
17860: LD_VAR 0 4
17864: PPUSH
17865: LD_VAR 0 4
17869: PUSH
17870: LD_INT 1
17872: PLUS
17873: PPUSH
17874: LD_EXP 51
17878: PUSH
17879: LD_VAR 0 3
17883: ARRAY
17884: PUSH
17885: LD_INT 2
17887: ARRAY
17888: PPUSH
17889: CALL_OW 1
17893: ST_TO_ADDR
// end ;
17894: GO 17830
17896: POP
17897: POP
// result := techs ;
17898: LD_ADDR_VAR 0 2
17902: PUSH
17903: LD_VAR 0 4
17907: ST_TO_ADDR
// end ;
17908: LD_VAR 0 2
17912: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
17913: LD_INT 0
17915: PPUSH
17916: PPUSH
// for i = 1 to tech_list do
17917: LD_ADDR_VAR 0 4
17921: PUSH
17922: DOUBLE
17923: LD_INT 1
17925: DEC
17926: ST_TO_ADDR
17927: LD_VAR 0 2
17931: PUSH
17932: FOR_TO
17933: IFFALSE 17987
// if not tech_list [ i ] = 20 then
17935: LD_VAR 0 2
17939: PUSH
17940: LD_VAR 0 4
17944: ARRAY
17945: PUSH
17946: LD_INT 20
17948: EQUAL
17949: NOT
17950: IFFALSE 17985
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
17952: LD_ADDR_EXP 51
17956: PUSH
17957: LD_EXP 51
17961: PPUSH
17962: LD_VAR 0 1
17966: PPUSH
17967: LD_VAR 0 2
17971: PUSH
17972: LD_VAR 0 4
17976: ARRAY
17977: PPUSH
17978: EMPTY
17979: PPUSH
17980: CALL 42232 0 4
17984: ST_TO_ADDR
17985: GO 17932
17987: POP
17988: POP
// result := true ;
17989: LD_ADDR_VAR 0 3
17993: PUSH
17994: LD_INT 1
17996: ST_TO_ADDR
// end ;
17997: LD_VAR 0 3
18001: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18002: LD_INT 0
18004: PPUSH
18005: PPUSH
// for i = MREG_ToRes downto 1 do
18006: LD_ADDR_VAR 0 3
18010: PUSH
18011: DOUBLE
18012: LD_EXP 51
18016: INC
18017: ST_TO_ADDR
18018: LD_INT 1
18020: PUSH
18021: FOR_DOWNTO
18022: IFFALSE 18068
// if MREG_ToRes [ i ] [ 1 ] = side then
18024: LD_EXP 51
18028: PUSH
18029: LD_VAR 0 3
18033: ARRAY
18034: PUSH
18035: LD_INT 1
18037: ARRAY
18038: PUSH
18039: LD_VAR 0 1
18043: EQUAL
18044: IFFALSE 18066
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18046: LD_ADDR_EXP 51
18050: PUSH
18051: LD_EXP 51
18055: PPUSH
18056: LD_VAR 0 3
18060: PPUSH
18061: CALL_OW 3
18065: ST_TO_ADDR
18066: GO 18021
18068: POP
18069: POP
// result := true ;
18070: LD_ADDR_VAR 0 2
18074: PUSH
18075: LD_INT 1
18077: ST_TO_ADDR
// end ;
18078: LD_VAR 0 2
18082: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18083: LD_INT 0
18085: PPUSH
// result := GetTechProgress ( side , tech ) ;
18086: LD_ADDR_VAR 0 3
18090: PUSH
18091: LD_VAR 0 1
18095: PPUSH
18096: LD_VAR 0 2
18100: PPUSH
18101: CALL_OW 326
18105: ST_TO_ADDR
// end ;
18106: LD_VAR 0 3
18110: RET
// export function MCL_Require ( tech ) ; begin
18111: LD_INT 0
18113: PPUSH
// result := GetTechTechsReq ( tech ) ;
18114: LD_ADDR_VAR 0 2
18118: PUSH
18119: LD_VAR 0 1
18123: PPUSH
18124: CALL_OW 480
18128: ST_TO_ADDR
// end ; end_of_file
18129: LD_VAR 0 2
18133: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18134: LD_INT 0
18136: PPUSH
18137: PPUSH
18138: PPUSH
// uc_side := 0 ;
18139: LD_ADDR_OWVAR 20
18143: PUSH
18144: LD_INT 0
18146: ST_TO_ADDR
// uc_nation := 0 ;
18147: LD_ADDR_OWVAR 21
18151: PUSH
18152: LD_INT 0
18154: ST_TO_ADDR
// for i = 1 to n do
18155: LD_ADDR_VAR 0 5
18159: PUSH
18160: DOUBLE
18161: LD_INT 1
18163: DEC
18164: ST_TO_ADDR
18165: LD_VAR 0 2
18169: PUSH
18170: FOR_TO
18171: IFFALSE 18316
// begin hc_importance := 0 ;
18173: LD_ADDR_OWVAR 32
18177: PUSH
18178: LD_INT 0
18180: ST_TO_ADDR
// hc_gallery :=  ;
18181: LD_ADDR_OWVAR 33
18185: PUSH
18186: LD_STRING 
18188: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18189: LD_ADDR_OWVAR 35
18193: PUSH
18194: LD_VAR 0 3
18198: PUSH
18199: LD_INT 20
18201: MINUS
18202: PPUSH
18203: LD_VAR 0 3
18207: PUSH
18208: LD_INT 20
18210: PLUS
18211: PPUSH
18212: CALL_OW 12
18216: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18217: LD_ADDR_OWVAR 31
18221: PUSH
18222: LD_INT 0
18224: PPUSH
18225: LD_INT 2
18227: PPUSH
18228: CALL_OW 12
18232: PUSH
18233: LD_INT 0
18235: PUSH
18236: LD_INT 0
18238: PUSH
18239: LD_INT 0
18241: PUSH
18242: EMPTY
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18248: LD_ADDR_OWVAR 30
18252: PUSH
18253: LD_INT 0
18255: PUSH
18256: LD_INT 0
18258: PUSH
18259: LD_INT 0
18261: PUSH
18262: LD_INT 0
18264: PUSH
18265: EMPTY
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: ST_TO_ADDR
// hc_name :=  ;
18271: LD_ADDR_OWVAR 26
18275: PUSH
18276: LD_STRING 
18278: ST_TO_ADDR
// hc_class := class_apeman ;
18279: LD_ADDR_OWVAR 28
18283: PUSH
18284: LD_INT 12
18286: ST_TO_ADDR
// ape := CreateHuman ;
18287: LD_ADDR_VAR 0 6
18291: PUSH
18292: CALL_OW 44
18296: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18297: LD_VAR 0 6
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: LD_INT 0
18309: PPUSH
18310: CALL_OW 49
// end ;
18314: GO 18170
18316: POP
18317: POP
// end ;
18318: LD_VAR 0 4
18322: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18323: LD_INT 0
18325: PPUSH
18326: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18327: LD_VAR 0 1
18331: PPUSH
18332: CALL 11834 0 1
18336: PUSH
18337: LD_EXP 38
18341: PUSH
18342: LD_VAR 0 1
18346: ARRAY
18347: GREATEREQUAL
18348: IFFALSE 18525
// begin if GetTag ( unit ) = 17 then
18350: LD_VAR 0 2
18354: PPUSH
18355: CALL_OW 110
18359: PUSH
18360: LD_INT 17
18362: EQUAL
18363: IFFALSE 18523
// begin SetTag ( unit , 0 ) ;
18365: LD_VAR 0 2
18369: PPUSH
18370: LD_INT 0
18372: PPUSH
18373: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18377: LD_VAR 0 1
18381: PPUSH
18382: CALL 11460 0 1
18386: PUSH
18387: LD_VAR 0 1
18391: PPUSH
18392: CALL 17804 0 1
18396: NOT
18397: AND
18398: IFFALSE 18423
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18400: LD_VAR 0 2
18404: PPUSH
18405: LD_VAR 0 1
18409: PPUSH
18410: CALL 11460 0 1
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18423: LD_VAR 0 1
18427: PPUSH
18428: CALL 11460 0 1
18432: NOT
18433: PUSH
18434: LD_VAR 0 1
18438: PPUSH
18439: LD_INT 30
18441: PUSH
18442: LD_INT 1
18444: PUSH
18445: EMPTY
18446: LIST
18447: LIST
18448: PPUSH
18449: CALL 11421 0 2
18453: AND
18454: IFFALSE 18523
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18456: LD_VAR 0 2
18460: PPUSH
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 30
18468: PUSH
18469: LD_INT 1
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: PPUSH
18476: CALL 11421 0 2
18480: PUSH
18481: LD_INT 1
18483: ARRAY
18484: PPUSH
18485: CALL_OW 250
18489: PPUSH
18490: LD_VAR 0 1
18494: PPUSH
18495: LD_INT 30
18497: PUSH
18498: LD_INT 1
18500: PUSH
18501: EMPTY
18502: LIST
18503: LIST
18504: PPUSH
18505: CALL 11421 0 2
18509: PUSH
18510: LD_INT 1
18512: ARRAY
18513: PPUSH
18514: CALL_OW 251
18518: PPUSH
18519: CALL_OW 111
// end ; end else
18523: GO 18709
// if GetClass ( unit ) <> 4 then
18525: LD_VAR 0 2
18529: PPUSH
18530: CALL_OW 257
18534: PUSH
18535: LD_INT 4
18537: NONEQUAL
18538: IFFALSE 18544
// exit else
18540: GO 18709
18542: GO 18709
// if GetTag ( unit ) = 0 then
18544: LD_VAR 0 2
18548: PPUSH
18549: CALL_OW 110
18553: PUSH
18554: LD_INT 0
18556: EQUAL
18557: IFFALSE 18573
// SetTag ( unit , 17 ) else
18559: LD_VAR 0 2
18563: PPUSH
18564: LD_INT 17
18566: PPUSH
18567: CALL_OW 109
18571: GO 18709
// begin if IsInUnit ( unit ) then
18573: LD_VAR 0 2
18577: PPUSH
18578: CALL_OW 310
18582: IFFALSE 18593
// ComExitBuilding ( unit ) ;
18584: LD_VAR 0 2
18588: PPUSH
18589: CALL_OW 122
// Wait ( 1 ) ;
18593: LD_INT 1
18595: PPUSH
18596: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18600: LD_ADDR_VAR 0 4
18604: PUSH
18605: LD_INT 22
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PUSH
18615: LD_INT 25
18617: PUSH
18618: LD_INT 12
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: PUSH
18625: EMPTY
18626: LIST
18627: LIST
18628: PPUSH
18629: CALL_OW 69
18633: PPUSH
18634: LD_VAR 0 2
18638: PPUSH
18639: CALL_OW 74
18643: ST_TO_ADDR
// if not ape then
18644: LD_VAR 0 4
18648: NOT
18649: IFFALSE 18655
// exit else
18651: GO 18709
18653: GO 18664
// ComHold ( ape ) ;
18655: LD_VAR 0 4
18659: PPUSH
18660: CALL_OW 140
// if not HasTask ( unit ) then
18664: LD_VAR 0 2
18668: PPUSH
18669: CALL_OW 314
18673: NOT
18674: IFFALSE 18707
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18676: LD_VAR 0 2
18680: PPUSH
18681: LD_VAR 0 4
18685: PPUSH
18686: CALL_OW 250
18690: PPUSH
18691: LD_VAR 0 4
18695: PPUSH
18696: CALL_OW 251
18700: PPUSH
18701: CALL_OW 131
18705: GO 18709
// exit ;
18707: GO 18709
// end ; end ;
18709: LD_VAR 0 3
18713: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18714: LD_INT 0
18716: PPUSH
18717: PPUSH
18718: PPUSH
18719: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18720: LD_ADDR_VAR 0 4
18724: PUSH
18725: LD_EXP 39
18729: PUSH
18730: LD_VAR 0 1
18734: ARRAY
18735: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18736: LD_ADDR_VAR 0 5
18740: PUSH
18741: LD_VAR 0 1
18745: PPUSH
18746: LD_STRING normal
18748: PPUSH
18749: CALL 11918 0 2
18753: ST_TO_ADDR
// if apes then
18754: LD_VAR 0 5
18758: IFFALSE 18986
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18760: LD_INT 2
18762: PPUSH
18763: LD_VAR 0 1
18767: PPUSH
18768: CALL_OW 321
18772: PUSH
18773: LD_INT 2
18775: EQUAL
18776: PUSH
18777: LD_VAR 0 4
18781: PUSH
18782: LD_INT 2
18784: ARRAY
18785: PUSH
18786: LD_INT 1
18788: EQUAL
18789: AND
18790: PUSH
18791: LD_VAR 0 1
18795: PPUSH
18796: LD_STRING engineer
18798: PPUSH
18799: CALL 11918 0 2
18803: PUSH
18804: LD_INT 3
18806: LESS
18807: AND
18808: PUSH
18809: LD_VAR 0 1
18813: PPUSH
18814: LD_INT 30
18816: PUSH
18817: LD_INT 1
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PPUSH
18824: CALL 11421 0 2
18828: AND
18829: IFFALSE 18883
// begin for i in apes do
18831: LD_ADDR_VAR 0 3
18835: PUSH
18836: LD_VAR 0 5
18840: PUSH
18841: FOR_IN
18842: IFFALSE 18879
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18844: LD_VAR 0 3
18848: PPUSH
18849: LD_VAR 0 1
18853: PPUSH
18854: LD_INT 30
18856: PUSH
18857: LD_INT 1
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PPUSH
18864: CALL 11421 0 2
18868: PUSH
18869: LD_INT 1
18871: ARRAY
18872: PPUSH
18873: CALL_OW 120
// end ;
18877: GO 18841
18879: POP
18880: POP
// end else
18881: GO 18986
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
18883: LD_INT 11
18885: PPUSH
18886: LD_VAR 0 1
18890: PPUSH
18891: CALL_OW 321
18895: PUSH
18896: LD_INT 2
18898: EQUAL
18899: PUSH
18900: LD_VAR 0 4
18904: PUSH
18905: LD_INT 1
18907: ARRAY
18908: PUSH
18909: LD_INT 1
18911: EQUAL
18912: AND
18913: PUSH
18914: LD_VAR 0 1
18918: PPUSH
18919: LD_INT 30
18921: PUSH
18922: LD_INT 5
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: PPUSH
18929: CALL 11421 0 2
18933: AND
18934: IFFALSE 18986
// begin for i in apes do
18936: LD_ADDR_VAR 0 3
18940: PUSH
18941: LD_VAR 0 5
18945: PUSH
18946: FOR_IN
18947: IFFALSE 18984
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
18949: LD_VAR 0 3
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: LD_INT 30
18961: PUSH
18962: LD_INT 5
18964: PUSH
18965: EMPTY
18966: LIST
18967: LIST
18968: PPUSH
18969: CALL 11421 0 2
18973: PUSH
18974: LD_INT 1
18976: ARRAY
18977: PPUSH
18978: CALL_OW 120
// end ;
18982: GO 18946
18984: POP
18985: POP
// end ; end ; end ; end_of_file
18986: LD_VAR 0 2
18990: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
18991: LD_INT 0
18993: PPUSH
18994: PPUSH
// if not GetClass ( unit ) = 4 or not target then
18995: LD_VAR 0 1
18999: PPUSH
19000: CALL_OW 257
19004: PUSH
19005: LD_INT 4
19007: EQUAL
19008: NOT
19009: PUSH
19010: LD_VAR 0 2
19014: NOT
19015: OR
19016: IFFALSE 19022
// exit else
19018: GO 19056
19020: GO 19056
// if not GetTag ( unit ) = 4 then
19022: LD_VAR 0 1
19026: PPUSH
19027: CALL_OW 110
19031: PUSH
19032: LD_INT 4
19034: EQUAL
19035: NOT
19036: IFFALSE 19042
// exit else
19038: GO 19056
19040: GO 19056
// ComHeal ( unit , target ) ;
19042: LD_VAR 0 1
19046: PPUSH
19047: LD_VAR 0 2
19051: PPUSH
19052: CALL_OW 128
// end ;
19056: LD_VAR 0 3
19060: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19061: LD_INT 0
19063: PPUSH
19064: PPUSH
19065: PPUSH
19066: PPUSH
19067: PPUSH
19068: PPUSH
19069: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19070: LD_ADDR_VAR 0 5
19074: PUSH
19075: LD_INT 22
19077: PUSH
19078: LD_VAR 0 1
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: PUSH
19087: LD_INT 21
19089: PUSH
19090: LD_INT 1
19092: PUSH
19093: EMPTY
19094: LIST
19095: LIST
19096: PUSH
19097: LD_INT 3
19099: PUSH
19100: LD_INT 55
19102: PUSH
19103: EMPTY
19104: LIST
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PUSH
19110: LD_INT 3
19112: PUSH
19113: LD_INT 54
19115: PUSH
19116: EMPTY
19117: LIST
19118: PUSH
19119: EMPTY
19120: LIST
19121: LIST
19122: PUSH
19123: LD_INT 3
19125: PUSH
19126: LD_INT 24
19128: PUSH
19129: LD_INT 1000
19131: PUSH
19132: EMPTY
19133: LIST
19134: LIST
19135: PUSH
19136: EMPTY
19137: LIST
19138: LIST
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: LIST
19144: LIST
19145: LIST
19146: PPUSH
19147: CALL_OW 69
19151: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19152: LD_ADDR_VAR 0 8
19156: PUSH
19157: LD_VAR 0 1
19161: PPUSH
19162: LD_INT 30
19164: PUSH
19165: LD_INT 1
19167: PUSH
19168: EMPTY
19169: LIST
19170: LIST
19171: PPUSH
19172: CALL 11421 0 2
19176: ST_TO_ADDR
// r := [ ] ;
19177: LD_ADDR_VAR 0 6
19181: PUSH
19182: EMPTY
19183: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 5
19191: PPUSH
19192: EMPTY
19193: PPUSH
19194: CALL 12124 0 3
19198: IFFALSE 19254
// for j in MCF_Tag ( side , 5 , [ ] ) do
19200: LD_ADDR_VAR 0 4
19204: PUSH
19205: LD_VAR 0 1
19209: PPUSH
19210: LD_INT 5
19212: PPUSH
19213: EMPTY
19214: PPUSH
19215: CALL 12124 0 3
19219: PUSH
19220: FOR_IN
19221: IFFALSE 19252
// if GetLives ( j ) = 1000 then
19223: LD_VAR 0 4
19227: PPUSH
19228: CALL_OW 256
19232: PUSH
19233: LD_INT 1000
19235: EQUAL
19236: IFFALSE 19250
// SetTag ( j , 0 ) ;
19238: LD_VAR 0 4
19242: PPUSH
19243: LD_INT 0
19245: PPUSH
19246: CALL_OW 109
19250: GO 19220
19252: POP
19253: POP
// if tmp then
19254: LD_VAR 0 5
19258: IFFALSE 19587
// begin r := [ tmp [ 1 ] ] ;
19260: LD_ADDR_VAR 0 6
19264: PUSH
19265: LD_VAR 0 5
19269: PUSH
19270: LD_INT 1
19272: ARRAY
19273: PUSH
19274: EMPTY
19275: LIST
19276: ST_TO_ADDR
// for i = 2 to tmp do
19277: LD_ADDR_VAR 0 3
19281: PUSH
19282: DOUBLE
19283: LD_INT 2
19285: DEC
19286: ST_TO_ADDR
19287: LD_VAR 0 5
19291: PUSH
19292: FOR_TO
19293: IFFALSE 19585
// begin m := false ;
19295: LD_ADDR_VAR 0 7
19299: PUSH
19300: LD_INT 0
19302: ST_TO_ADDR
// if d then
19303: LD_VAR 0 8
19307: IFFALSE 19462
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19309: LD_VAR 0 5
19313: PUSH
19314: LD_VAR 0 3
19318: ARRAY
19319: PPUSH
19320: CALL_OW 256
19324: PUSH
19325: LD_INT 650
19327: LESS
19328: PUSH
19329: LD_VAR 0 5
19333: PUSH
19334: LD_VAR 0 3
19338: ARRAY
19339: PPUSH
19340: LD_VAR 0 8
19344: PUSH
19345: LD_INT 1
19347: ARRAY
19348: PPUSH
19349: CALL_OW 250
19353: PPUSH
19354: LD_VAR 0 8
19358: PUSH
19359: LD_INT 1
19361: ARRAY
19362: PPUSH
19363: CALL_OW 251
19367: PPUSH
19368: CALL_OW 297
19372: PUSH
19373: LD_INT 10
19375: GREATER
19376: AND
19377: IFFALSE 19462
// begin if not GetTag ( tmp [ i ] ) = 5 then
19379: LD_VAR 0 5
19383: PUSH
19384: LD_VAR 0 3
19388: ARRAY
19389: PPUSH
19390: CALL_OW 110
19394: PUSH
19395: LD_INT 5
19397: EQUAL
19398: NOT
19399: IFFALSE 19419
// SetTag ( tmp [ i ] , 5 ) ;
19401: LD_VAR 0 5
19405: PUSH
19406: LD_VAR 0 3
19410: ARRAY
19411: PPUSH
19412: LD_INT 5
19414: PPUSH
19415: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19419: LD_VAR 0 5
19423: PUSH
19424: LD_VAR 0 3
19428: ARRAY
19429: PPUSH
19430: LD_VAR 0 8
19434: PUSH
19435: LD_INT 1
19437: ARRAY
19438: PPUSH
19439: CALL_OW 250
19443: PPUSH
19444: LD_VAR 0 8
19448: PUSH
19449: LD_INT 1
19451: ARRAY
19452: PPUSH
19453: CALL_OW 251
19457: PPUSH
19458: CALL_OW 111
// end ; for j = 1 to r do
19462: LD_ADDR_VAR 0 4
19466: PUSH
19467: DOUBLE
19468: LD_INT 1
19470: DEC
19471: ST_TO_ADDR
19472: LD_VAR 0 6
19476: PUSH
19477: FOR_TO
19478: IFFALSE 19552
// if GetLives ( tmp [ i ] ) < r [ j ] then
19480: LD_VAR 0 5
19484: PUSH
19485: LD_VAR 0 3
19489: ARRAY
19490: PPUSH
19491: CALL_OW 256
19495: PUSH
19496: LD_VAR 0 6
19500: PUSH
19501: LD_VAR 0 4
19505: ARRAY
19506: LESS
19507: IFFALSE 19550
// begin r := Insert ( r , j , tmp [ i ] ) ;
19509: LD_ADDR_VAR 0 6
19513: PUSH
19514: LD_VAR 0 6
19518: PPUSH
19519: LD_VAR 0 4
19523: PPUSH
19524: LD_VAR 0 5
19528: PUSH
19529: LD_VAR 0 3
19533: ARRAY
19534: PPUSH
19535: CALL_OW 2
19539: ST_TO_ADDR
// m := true ;
19540: LD_ADDR_VAR 0 7
19544: PUSH
19545: LD_INT 1
19547: ST_TO_ADDR
// break ;
19548: GO 19552
// end ;
19550: GO 19477
19552: POP
19553: POP
// if not m then
19554: LD_VAR 0 7
19558: NOT
19559: IFFALSE 19583
// r := r ^ tmp [ i ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_VAR 0 6
19570: PUSH
19571: LD_VAR 0 5
19575: PUSH
19576: LD_VAR 0 3
19580: ARRAY
19581: ADD
19582: ST_TO_ADDR
// end ;
19583: GO 19292
19585: POP
19586: POP
// end ; result := r end ; end_of_file
19587: LD_ADDR_VAR 0 2
19591: PUSH
19592: LD_VAR 0 6
19596: ST_TO_ADDR
19597: LD_VAR 0 2
19601: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19602: LD_INT 0
19604: PPUSH
19605: PPUSH
19606: PPUSH
// pom := GetBase ( bdepot ) ;
19607: LD_ADDR_VAR 0 3
19611: PUSH
19612: LD_VAR 0 1
19616: PPUSH
19617: CALL_OW 274
19621: ST_TO_ADDR
// sor := [ ] ;
19622: LD_ADDR_VAR 0 4
19626: PUSH
19627: EMPTY
19628: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19629: LD_ADDR_VAR 0 4
19633: PUSH
19634: LD_VAR 0 4
19638: PUSH
19639: LD_VAR 0 3
19643: PPUSH
19644: LD_INT 1
19646: PPUSH
19647: CALL_OW 275
19651: ADD
19652: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19653: LD_ADDR_VAR 0 4
19657: PUSH
19658: LD_VAR 0 4
19662: PUSH
19663: LD_VAR 0 3
19667: PPUSH
19668: LD_INT 2
19670: PPUSH
19671: CALL_OW 275
19675: ADD
19676: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19677: LD_ADDR_VAR 0 4
19681: PUSH
19682: LD_VAR 0 4
19686: PUSH
19687: LD_VAR 0 3
19691: PPUSH
19692: LD_INT 3
19694: PPUSH
19695: CALL_OW 275
19699: ADD
19700: ST_TO_ADDR
// result := sor ;
19701: LD_ADDR_VAR 0 2
19705: PUSH
19706: LD_VAR 0 4
19710: ST_TO_ADDR
// end ;
19711: LD_VAR 0 2
19715: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19716: LD_INT 0
19718: PPUSH
19719: PPUSH
// while ( coord_list ) do
19720: LD_VAR 0 3
19724: IFFALSE 19898
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19726: LD_ADDR_EXP 47
19730: PUSH
19731: LD_EXP 47
19735: PPUSH
19736: LD_VAR 0 1
19740: PPUSH
19741: LD_VAR 0 2
19745: PPUSH
19746: LD_VAR 0 3
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: LD_VAR 0 3
19759: PUSH
19760: LD_INT 2
19762: ARRAY
19763: PUSH
19764: LD_VAR 0 3
19768: PUSH
19769: LD_INT 3
19771: ARRAY
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: PPUSH
19778: CALL 42232 0 4
19782: ST_TO_ADDR
// if weapon_list then
19783: LD_VAR 0 4
19787: IFFALSE 19858
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19789: LD_ADDR_EXP 44
19793: PUSH
19794: LD_EXP 44
19798: PPUSH
19799: LD_VAR 0 1
19803: PPUSH
19804: LD_VAR 0 4
19808: PUSH
19809: LD_INT 1
19811: ARRAY
19812: PPUSH
19813: LD_VAR 0 3
19817: PUSH
19818: LD_INT 1
19820: ARRAY
19821: PUSH
19822: LD_VAR 0 3
19826: PUSH
19827: LD_INT 2
19829: ARRAY
19830: PUSH
19831: EMPTY
19832: LIST
19833: LIST
19834: PPUSH
19835: CALL 42232 0 4
19839: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19840: LD_ADDR_VAR 0 4
19844: PUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: LD_INT 1
19852: PPUSH
19853: CALL_OW 3
19857: ST_TO_ADDR
// end ; for i = 1 to 3 do
19858: LD_ADDR_VAR 0 6
19862: PUSH
19863: DOUBLE
19864: LD_INT 1
19866: DEC
19867: ST_TO_ADDR
19868: LD_INT 3
19870: PUSH
19871: FOR_TO
19872: IFFALSE 19894
// coord_list := Delete ( coord_list , 1 ) ;
19874: LD_ADDR_VAR 0 3
19878: PUSH
19879: LD_VAR 0 3
19883: PPUSH
19884: LD_INT 1
19886: PPUSH
19887: CALL_OW 3
19891: ST_TO_ADDR
19892: GO 19871
19894: POP
19895: POP
// end ;
19896: GO 19720
// result := true ;
19898: LD_ADDR_VAR 0 5
19902: PUSH
19903: LD_INT 1
19905: ST_TO_ADDR
// end ;
19906: LD_VAR 0 5
19910: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
19911: LD_INT 0
19913: PPUSH
19914: PPUSH
// if not weapon_list then
19915: LD_VAR 0 3
19919: NOT
19920: IFFALSE 19924
// exit ;
19922: GO 20039
// while ( coord_list ) do
19924: LD_VAR 0 2
19928: IFFALSE 20039
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19930: LD_ADDR_EXP 44
19934: PUSH
19935: LD_EXP 44
19939: PPUSH
19940: LD_VAR 0 1
19944: PPUSH
19945: LD_VAR 0 3
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PPUSH
19954: LD_VAR 0 2
19958: PUSH
19959: LD_INT 1
19961: ARRAY
19962: PUSH
19963: LD_VAR 0 2
19967: PUSH
19968: LD_INT 2
19970: ARRAY
19971: PUSH
19972: EMPTY
19973: LIST
19974: LIST
19975: PPUSH
19976: CALL 42232 0 4
19980: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19981: LD_ADDR_VAR 0 3
19985: PUSH
19986: LD_VAR 0 3
19990: PPUSH
19991: LD_INT 1
19993: PPUSH
19994: CALL_OW 3
19998: ST_TO_ADDR
// for i = 1 to 2 do
19999: LD_ADDR_VAR 0 5
20003: PUSH
20004: DOUBLE
20005: LD_INT 1
20007: DEC
20008: ST_TO_ADDR
20009: LD_INT 2
20011: PUSH
20012: FOR_TO
20013: IFFALSE 20035
// coord_list := Delete ( coord_list , 1 ) ;
20015: LD_ADDR_VAR 0 2
20019: PUSH
20020: LD_VAR 0 2
20024: PPUSH
20025: LD_INT 1
20027: PPUSH
20028: CALL_OW 3
20032: ST_TO_ADDR
20033: GO 20012
20035: POP
20036: POP
// end ;
20037: GO 19924
// end ;
20039: LD_VAR 0 4
20043: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20044: LD_INT 0
20046: PPUSH
20047: PPUSH
// while ( coord_list ) do
20048: LD_VAR 0 2
20052: IFFALSE 20207
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20054: LD_VAR 0 2
20058: PUSH
20059: LD_INT 1
20061: ARRAY
20062: PPUSH
20063: LD_VAR 0 2
20067: PUSH
20068: LD_INT 2
20070: ARRAY
20071: PPUSH
20072: CALL_OW 428
20076: IFFALSE 20167
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20078: LD_VAR 0 2
20082: PUSH
20083: LD_INT 1
20085: ARRAY
20086: PPUSH
20087: LD_VAR 0 2
20091: PUSH
20092: LD_INT 2
20094: ARRAY
20095: PPUSH
20096: CALL_OW 428
20100: PPUSH
20101: CALL_OW 266
20105: PUSH
20106: LD_INT 31
20108: PUSH
20109: LD_INT 32
20111: PUSH
20112: LD_INT 33
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: LIST
20119: IN
20120: IFFALSE 20167
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20122: LD_ADDR_EXP 53
20126: PUSH
20127: LD_EXP 53
20131: PPUSH
20132: LD_VAR 0 1
20136: PPUSH
20137: LD_VAR 0 2
20141: PUSH
20142: LD_INT 1
20144: ARRAY
20145: PPUSH
20146: LD_VAR 0 2
20150: PUSH
20151: LD_INT 2
20153: ARRAY
20154: PPUSH
20155: CALL_OW 428
20159: PPUSH
20160: EMPTY
20161: PPUSH
20162: CALL 42232 0 4
20166: ST_TO_ADDR
// for i = 1 to 3 do
20167: LD_ADDR_VAR 0 4
20171: PUSH
20172: DOUBLE
20173: LD_INT 1
20175: DEC
20176: ST_TO_ADDR
20177: LD_INT 3
20179: PUSH
20180: FOR_TO
20181: IFFALSE 20203
// coord_list := Delete ( coord_list , 1 ) ;
20183: LD_ADDR_VAR 0 2
20187: PUSH
20188: LD_VAR 0 2
20192: PPUSH
20193: LD_INT 1
20195: PPUSH
20196: CALL_OW 3
20200: ST_TO_ADDR
20201: GO 20180
20203: POP
20204: POP
// end ;
20205: GO 20048
// result := true ;
20207: LD_ADDR_VAR 0 3
20211: PUSH
20212: LD_INT 1
20214: ST_TO_ADDR
// end ;
20215: LD_VAR 0 3
20219: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20220: LD_INT 0
20222: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20223: LD_ADDR_EXP 47
20227: PUSH
20228: LD_EXP 47
20232: PPUSH
20233: LD_VAR 0 1
20237: PPUSH
20238: LD_INT 0
20240: PPUSH
20241: LD_VAR 0 2
20245: PPUSH
20246: CALL 42232 0 4
20250: ST_TO_ADDR
// end ;
20251: LD_VAR 0 3
20255: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20256: LD_INT 0
20258: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20259: LD_ADDR_EXP 47
20263: PUSH
20264: LD_EXP 47
20268: PPUSH
20269: LD_VAR 0 1
20273: PPUSH
20274: LD_INT 6
20276: PPUSH
20277: LD_VAR 0 2
20281: PPUSH
20282: CALL 42232 0 4
20286: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20287: LD_ADDR_EXP 50
20291: PUSH
20292: LD_EXP 50
20296: PPUSH
20297: LD_VAR 0 1
20301: PPUSH
20302: LD_VAR 0 3
20306: PUSH
20307: LD_INT 1
20309: ARRAY
20310: PPUSH
20311: LD_VAR 0 3
20315: PUSH
20316: LD_INT 2
20318: ARRAY
20319: PPUSH
20320: CALL 42232 0 4
20324: ST_TO_ADDR
// end ;
20325: LD_VAR 0 4
20329: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20330: LD_INT 0
20332: PPUSH
20333: PPUSH
// if ext_list > 5 then
20334: LD_VAR 0 3
20338: PUSH
20339: LD_INT 5
20341: GREATER
20342: IFFALSE 20386
// for i = 6 to ext_list do
20344: LD_ADDR_VAR 0 5
20348: PUSH
20349: DOUBLE
20350: LD_INT 6
20352: DEC
20353: ST_TO_ADDR
20354: LD_VAR 0 3
20358: PUSH
20359: FOR_TO
20360: IFFALSE 20384
// ext_list := Delete ( ext_list , ext_list ) ;
20362: LD_ADDR_VAR 0 3
20366: PUSH
20367: LD_VAR 0 3
20371: PPUSH
20372: LD_VAR 0 3
20376: PPUSH
20377: CALL_OW 3
20381: ST_TO_ADDR
20382: GO 20359
20384: POP
20385: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20386: LD_VAR 0 1
20390: PPUSH
20391: LD_VAR 0 2
20395: PUSH
20396: LD_INT 1
20398: ARRAY
20399: PPUSH
20400: LD_VAR 0 2
20404: PUSH
20405: LD_INT 2
20407: ARRAY
20408: PPUSH
20409: LD_VAR 0 2
20413: PUSH
20414: LD_INT 3
20416: ARRAY
20417: PPUSH
20418: LD_VAR 0 3
20422: PPUSH
20423: CALL 8933 0 5
// end ;
20427: LD_VAR 0 4
20431: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20432: LD_INT 0
20434: PPUSH
20435: PPUSH
20436: PPUSH
// p := 1 ;
20437: LD_ADDR_VAR 0 6
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// if type_list = [ ] then
20445: LD_VAR 0 3
20449: PUSH
20450: EMPTY
20451: EQUAL
20452: IFFALSE 20462
// type_list := b_oil_power ;
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 26
20461: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20462: LD_ADDR_VAR 0 5
20466: PUSH
20467: DOUBLE
20468: LD_INT 1
20470: DEC
20471: ST_TO_ADDR
20472: LD_VAR 0 2
20476: PUSH
20477: LD_INT 3
20479: DIVREAL
20480: PUSH
20481: FOR_TO
20482: IFFALSE 20585
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20484: LD_ADDR_EXP 47
20488: PUSH
20489: LD_EXP 47
20493: PPUSH
20494: LD_VAR 0 1
20498: PPUSH
20499: LD_VAR 0 3
20503: PUSH
20504: LD_INT 1
20506: PPUSH
20507: LD_VAR 0 3
20511: PPUSH
20512: CALL_OW 12
20516: ARRAY
20517: PPUSH
20518: LD_VAR 0 2
20522: PUSH
20523: LD_VAR 0 6
20527: ARRAY
20528: PUSH
20529: LD_VAR 0 2
20533: PUSH
20534: LD_VAR 0 6
20538: PUSH
20539: LD_INT 1
20541: PLUS
20542: ARRAY
20543: PUSH
20544: LD_VAR 0 2
20548: PUSH
20549: LD_VAR 0 6
20553: PUSH
20554: LD_INT 2
20556: PLUS
20557: ARRAY
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: LIST
20563: PPUSH
20564: CALL 42232 0 4
20568: ST_TO_ADDR
// p := p + 3 ;
20569: LD_ADDR_VAR 0 6
20573: PUSH
20574: LD_VAR 0 6
20578: PUSH
20579: LD_INT 3
20581: PLUS
20582: ST_TO_ADDR
// end ;
20583: GO 20481
20585: POP
20586: POP
// end ;
20587: LD_VAR 0 4
20591: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20592: LD_INT 0
20594: PPUSH
20595: PPUSH
20596: PPUSH
20597: PPUSH
// if not MREG_Deposit [ side ] then
20598: LD_EXP 62
20602: PUSH
20603: LD_VAR 0 1
20607: ARRAY
20608: NOT
20609: IFFALSE 20613
// exit ;
20611: GO 20790
// p := 1 ;
20613: LD_ADDR_VAR 0 4
20617: PUSH
20618: LD_INT 1
20620: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20621: LD_ADDR_VAR 0 3
20625: PUSH
20626: DOUBLE
20627: LD_INT 1
20629: DEC
20630: ST_TO_ADDR
20631: LD_EXP 62
20635: PUSH
20636: LD_VAR 0 1
20640: ARRAY
20641: PUSH
20642: LD_INT 3
20644: DIVREAL
20645: PUSH
20646: FOR_TO
20647: IFFALSE 20788
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20649: LD_EXP 62
20653: PUSH
20654: LD_VAR 0 1
20658: ARRAY
20659: PUSH
20660: LD_VAR 0 4
20664: PUSH
20665: LD_INT 2
20667: PLUS
20668: ARRAY
20669: PUSH
20670: LD_INT 2
20672: EQUAL
20673: IFFALSE 20685
// b := b_oil_mine else
20675: LD_ADDR_VAR 0 5
20679: PUSH
20680: LD_INT 29
20682: ST_TO_ADDR
20683: GO 20693
// b := b_siberite_mine ;
20685: LD_ADDR_VAR 0 5
20689: PUSH
20690: LD_INT 30
20692: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20693: LD_ADDR_EXP 47
20697: PUSH
20698: LD_EXP 47
20702: PPUSH
20703: LD_VAR 0 1
20707: PPUSH
20708: LD_VAR 0 5
20712: PPUSH
20713: LD_EXP 62
20717: PUSH
20718: LD_VAR 0 1
20722: ARRAY
20723: PUSH
20724: LD_VAR 0 4
20728: ARRAY
20729: PUSH
20730: LD_EXP 62
20734: PUSH
20735: LD_VAR 0 1
20739: ARRAY
20740: PUSH
20741: LD_VAR 0 4
20745: PUSH
20746: LD_INT 1
20748: PLUS
20749: ARRAY
20750: PUSH
20751: LD_INT 0
20753: PPUSH
20754: LD_INT 5
20756: PPUSH
20757: CALL_OW 12
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: LIST
20766: PPUSH
20767: CALL 42232 0 4
20771: ST_TO_ADDR
// p := p + 3 ;
20772: LD_ADDR_VAR 0 4
20776: PUSH
20777: LD_VAR 0 4
20781: PUSH
20782: LD_INT 3
20784: PLUS
20785: ST_TO_ADDR
// end ;
20786: GO 20646
20788: POP
20789: POP
// end ;
20790: LD_VAR 0 2
20794: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20795: LD_INT 0
20797: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20798: LD_ADDR_EXP 47
20802: PUSH
20803: LD_EXP 47
20807: PPUSH
20808: LD_VAR 0 1
20812: PPUSH
20813: LD_INT 4
20815: PPUSH
20816: LD_VAR 0 2
20820: PPUSH
20821: CALL 42232 0 4
20825: ST_TO_ADDR
// end ;
20826: LD_VAR 0 3
20830: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20831: LD_INT 0
20833: PPUSH
// case nation of 1 , us :
20834: LD_VAR 0 2
20838: PUSH
20839: LD_INT 1
20841: DOUBLE
20842: EQUAL
20843: IFTRUE 20853
20845: LD_STRING us
20847: DOUBLE
20848: EQUAL
20849: IFTRUE 20853
20851: GO 20884
20853: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20854: LD_ADDR_EXP 47
20858: PUSH
20859: LD_EXP 47
20863: PPUSH
20864: LD_VAR 0 1
20868: PPUSH
20869: LD_INT 36
20871: PPUSH
20872: LD_VAR 0 3
20876: PPUSH
20877: CALL 42232 0 4
20881: ST_TO_ADDR
20882: GO 20935
20884: LD_INT 2
20886: DOUBLE
20887: EQUAL
20888: IFTRUE 20898
20890: LD_STRING ar
20892: DOUBLE
20893: EQUAL
20894: IFTRUE 20898
20896: GO 20934
20898: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
20899: LD_ADDR_EXP 47
20903: PUSH
20904: LD_VAR 0 1
20908: PPUSH
20909: LD_INT 14
20911: PUSH
20912: LD_INT 2
20914: PUSH
20915: LD_INT 1
20917: PUSH
20918: LD_INT 31
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: LIST
20925: LIST
20926: PPUSH
20927: CALL 20940 0 2
20931: ST_TO_ADDR
20932: GO 20935
20934: POP
// end ;
20935: LD_VAR 0 4
20939: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
20940: LD_INT 0
20942: PPUSH
20943: PPUSH
// for i = 1 to list do
20944: LD_ADDR_VAR 0 4
20948: PUSH
20949: DOUBLE
20950: LD_INT 1
20952: DEC
20953: ST_TO_ADDR
20954: LD_VAR 0 2
20958: PUSH
20959: FOR_TO
20960: IFFALSE 21010
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
20962: LD_ADDR_EXP 52
20966: PUSH
20967: LD_EXP 52
20971: PPUSH
20972: LD_VAR 0 1
20976: PPUSH
20977: LD_EXP 52
20981: PUSH
20982: LD_VAR 0 1
20986: ARRAY
20987: PUSH
20988: LD_INT 1
20990: PLUS
20991: PPUSH
20992: LD_VAR 0 2
20996: PUSH
20997: LD_VAR 0 4
21001: ARRAY
21002: PPUSH
21003: CALL 30950 0 4
21007: ST_TO_ADDR
21008: GO 20959
21010: POP
21011: POP
// end ;
21012: LD_VAR 0 3
21016: RET
// export function MCS_GetVehicleList ( side ) ; begin
21017: LD_INT 0
21019: PPUSH
// result := MREG_ToConstruct [ side ] ;
21020: LD_ADDR_VAR 0 2
21024: PUSH
21025: LD_EXP 52
21029: PUSH
21030: LD_VAR 0 1
21034: ARRAY
21035: ST_TO_ADDR
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21041: LD_INT 0
21043: PPUSH
21044: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21045: LD_ADDR_EXP 59
21049: PUSH
21050: LD_EXP 59
21054: PPUSH
21055: LD_VAR 0 1
21059: PPUSH
21060: LD_VAR 0 2
21064: PPUSH
21065: CALL_OW 1
21069: ST_TO_ADDR
// end ;
21070: LD_VAR 0 3
21074: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21075: LD_INT 0
21077: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21078: LD_ADDR_EXP 38
21082: PUSH
21083: LD_EXP 38
21087: PPUSH
21088: LD_VAR 0 1
21092: PPUSH
21093: LD_VAR 0 2
21097: PPUSH
21098: CALL_OW 1
21102: ST_TO_ADDR
// end ;
21103: LD_VAR 0 3
21107: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21108: LD_INT 0
21110: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21111: LD_ADDR_EXP 39
21115: PUSH
21116: LD_EXP 39
21120: PPUSH
21121: LD_VAR 0 1
21125: PPUSH
21126: LD_VAR 0 2
21130: PPUSH
21131: CALL_OW 1
21135: ST_TO_ADDR
// end ;
21136: LD_VAR 0 3
21140: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21141: LD_INT 0
21143: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21144: LD_ADDR_EXP 61
21148: PUSH
21149: LD_EXP 61
21153: PPUSH
21154: LD_VAR 0 1
21158: PPUSH
21159: LD_INT 1
21161: PPUSH
21162: LD_VAR 0 2
21166: PPUSH
21167: CALL 30950 0 4
21171: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21172: LD_ADDR_EXP 61
21176: PUSH
21177: LD_EXP 61
21181: PPUSH
21182: LD_VAR 0 1
21186: PPUSH
21187: LD_INT 2
21189: PPUSH
21190: LD_VAR 0 3
21194: PPUSH
21195: CALL 30950 0 4
21199: ST_TO_ADDR
// end ;
21200: LD_VAR 0 4
21204: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21205: LD_INT 0
21207: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21208: LD_ADDR_EXP 73
21212: PUSH
21213: LD_EXP 73
21217: PPUSH
21218: LD_INT 1
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: CALL_OW 1
21230: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21231: LD_ADDR_EXP 73
21235: PUSH
21236: LD_EXP 73
21240: PPUSH
21241: LD_INT 2
21243: PPUSH
21244: LD_VAR 0 2
21248: PPUSH
21249: CALL_OW 1
21253: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21254: LD_ADDR_EXP 73
21258: PUSH
21259: LD_EXP 73
21263: PPUSH
21264: LD_INT 3
21266: PPUSH
21267: LD_VAR 0 3
21271: PPUSH
21272: CALL_OW 1
21276: ST_TO_ADDR
// end ;
21277: LD_VAR 0 4
21281: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21282: LD_INT 0
21284: PPUSH
21285: PPUSH
21286: PPUSH
// if not side or not list then
21287: LD_VAR 0 1
21291: NOT
21292: PUSH
21293: LD_VAR 0 2
21297: NOT
21298: OR
21299: IFFALSE 21303
// exit ;
21301: GO 21471
// SetTech ( 20 , side , state_researched ) ;
21303: LD_INT 20
21305: PPUSH
21306: LD_VAR 0 1
21310: PPUSH
21311: LD_INT 2
21313: PPUSH
21314: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21318: LD_ADDR_EXP 62
21322: PUSH
21323: LD_EXP 62
21327: PPUSH
21328: LD_VAR 0 1
21332: PPUSH
21333: LD_VAR 0 2
21337: PPUSH
21338: CALL_OW 2
21342: ST_TO_ADDR
// p := 1 ;
21343: LD_ADDR_VAR 0 5
21347: PUSH
21348: LD_INT 1
21350: ST_TO_ADDR
// for i = 1 to list / 3 do
21351: LD_ADDR_VAR 0 4
21355: PUSH
21356: DOUBLE
21357: LD_INT 1
21359: DEC
21360: ST_TO_ADDR
21361: LD_VAR 0 2
21365: PUSH
21366: LD_INT 3
21368: DIVREAL
21369: PUSH
21370: FOR_TO
21371: IFFALSE 21469
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21373: LD_VAR 0 2
21377: PUSH
21378: LD_VAR 0 5
21382: ARRAY
21383: PPUSH
21384: LD_VAR 0 2
21388: PUSH
21389: LD_VAR 0 5
21393: PUSH
21394: LD_INT 1
21396: PLUS
21397: ARRAY
21398: PPUSH
21399: LD_VAR 0 2
21403: PUSH
21404: LD_VAR 0 5
21408: PUSH
21409: LD_INT 2
21411: PLUS
21412: ARRAY
21413: PPUSH
21414: CALL 22173 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21418: LD_VAR 0 2
21422: PUSH
21423: LD_VAR 0 5
21427: ARRAY
21428: PPUSH
21429: LD_VAR 0 2
21433: PUSH
21434: LD_VAR 0 5
21438: PUSH
21439: LD_INT 1
21441: PLUS
21442: ARRAY
21443: PPUSH
21444: LD_VAR 0 1
21448: PPUSH
21449: CALL_OW 441
// p := p + 3 ;
21453: LD_ADDR_VAR 0 5
21457: PUSH
21458: LD_VAR 0 5
21462: PUSH
21463: LD_INT 3
21465: PLUS
21466: ST_TO_ADDR
// end ;
21467: GO 21370
21469: POP
21470: POP
// end ;
21471: LD_VAR 0 3
21475: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21476: LD_INT 0
21478: PPUSH
21479: PPUSH
// if nat = nation_arabian then
21480: LD_VAR 0 2
21484: PUSH
21485: LD_INT 2
21487: EQUAL
21488: IFFALSE 21494
// exit else
21490: GO 21566
21492: GO 21552
// if nat = nation_american then
21494: LD_VAR 0 2
21498: PUSH
21499: LD_INT 1
21501: EQUAL
21502: IFFALSE 21529
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21504: LD_ADDR_VAR 0 4
21508: PUSH
21509: LD_INT 4
21511: PUSH
21512: LD_INT 3
21514: PUSH
21515: LD_INT 1
21517: PUSH
21518: LD_INT 8
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: LIST
21525: LIST
21526: ST_TO_ADDR
21527: GO 21552
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21529: LD_ADDR_VAR 0 4
21533: PUSH
21534: LD_INT 24
21536: PUSH
21537: LD_INT 3
21539: PUSH
21540: LD_INT 1
21542: PUSH
21543: LD_INT 48
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: LIST
21550: LIST
21551: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_VAR 0 4
21561: PPUSH
21562: CALL 20940 0 2
// end ;
21566: LD_VAR 0 3
21570: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21571: LD_INT 0
21573: PPUSH
21574: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21575: LD_ADDR_EXP 64
21579: PUSH
21580: LD_EXP 64
21584: PPUSH
21585: LD_VAR 0 1
21589: PPUSH
21590: LD_INT 1
21592: PPUSH
21593: LD_VAR 0 4
21597: PPUSH
21598: CALL 30950 0 4
21602: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21603: LD_ADDR_EXP 65
21607: PUSH
21608: LD_EXP 65
21612: PPUSH
21613: LD_VAR 0 1
21617: PPUSH
21618: LD_INT 1
21620: PPUSH
21621: LD_VAR 0 2
21625: PPUSH
21626: CALL 30950 0 4
21630: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21631: LD_ADDR_EXP 66
21635: PUSH
21636: LD_EXP 66
21640: PPUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_INT 1
21648: PPUSH
21649: LD_VAR 0 3
21653: PPUSH
21654: CALL 30950 0 4
21658: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21659: LD_ADDR_EXP 67
21663: PUSH
21664: LD_EXP 67
21668: PPUSH
21669: LD_VAR 0 1
21673: PPUSH
21674: LD_INT 1
21676: PPUSH
21677: LD_VAR 0 5
21681: PPUSH
21682: CALL 30950 0 4
21686: ST_TO_ADDR
// while squad do
21687: LD_VAR 0 5
21691: IFFALSE 21784
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21693: LD_VAR 0 1
21697: PPUSH
21698: LD_VAR 0 5
21702: PUSH
21703: LD_INT 1
21705: ARRAY
21706: PUSH
21707: LD_VAR 0 5
21711: PUSH
21712: LD_INT 2
21714: ARRAY
21715: PUSH
21716: LD_VAR 0 5
21720: PUSH
21721: LD_INT 3
21723: ARRAY
21724: PUSH
21725: LD_VAR 0 5
21729: PUSH
21730: LD_INT 4
21732: ARRAY
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: LIST
21738: LIST
21739: PPUSH
21740: CALL 20940 0 2
// for i = 1 to 4 do
21744: LD_ADDR_VAR 0 7
21748: PUSH
21749: DOUBLE
21750: LD_INT 1
21752: DEC
21753: ST_TO_ADDR
21754: LD_INT 4
21756: PUSH
21757: FOR_TO
21758: IFFALSE 21780
// squad := Delete ( squad , 1 ) ;
21760: LD_ADDR_VAR 0 5
21764: PUSH
21765: LD_VAR 0 5
21769: PPUSH
21770: LD_INT 1
21772: PPUSH
21773: CALL_OW 3
21777: ST_TO_ADDR
21778: GO 21757
21780: POP
21781: POP
// end ;
21782: GO 21687
// end ;
21784: LD_VAR 0 6
21788: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21789: LD_INT 0
21791: PPUSH
21792: PPUSH
// for i = 1 to squad do
21793: LD_ADDR_VAR 0 4
21797: PUSH
21798: DOUBLE
21799: LD_INT 1
21801: DEC
21802: ST_TO_ADDR
21803: LD_VAR 0 2
21807: PUSH
21808: FOR_TO
21809: IFFALSE 21859
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21811: LD_ADDR_EXP 70
21815: PUSH
21816: LD_EXP 70
21820: PPUSH
21821: LD_VAR 0 1
21825: PPUSH
21826: LD_EXP 70
21830: PUSH
21831: LD_VAR 0 1
21835: ARRAY
21836: PUSH
21837: LD_INT 1
21839: PLUS
21840: PPUSH
21841: LD_VAR 0 2
21845: PUSH
21846: LD_VAR 0 4
21850: ARRAY
21851: PPUSH
21852: CALL 30950 0 4
21856: ST_TO_ADDR
21857: GO 21808
21859: POP
21860: POP
// while squad do
21861: LD_VAR 0 2
21865: IFFALSE 21958
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21867: LD_VAR 0 1
21871: PPUSH
21872: LD_VAR 0 2
21876: PUSH
21877: LD_INT 1
21879: ARRAY
21880: PUSH
21881: LD_VAR 0 2
21885: PUSH
21886: LD_INT 2
21888: ARRAY
21889: PUSH
21890: LD_VAR 0 2
21894: PUSH
21895: LD_INT 3
21897: ARRAY
21898: PUSH
21899: LD_VAR 0 2
21903: PUSH
21904: LD_INT 4
21906: ARRAY
21907: PUSH
21908: EMPTY
21909: LIST
21910: LIST
21911: LIST
21912: LIST
21913: PPUSH
21914: CALL 20940 0 2
// for i = 1 to 4 do
21918: LD_ADDR_VAR 0 4
21922: PUSH
21923: DOUBLE
21924: LD_INT 1
21926: DEC
21927: ST_TO_ADDR
21928: LD_INT 4
21930: PUSH
21931: FOR_TO
21932: IFFALSE 21954
// squad := Delete ( squad , 1 ) ;
21934: LD_ADDR_VAR 0 2
21938: PUSH
21939: LD_VAR 0 2
21943: PPUSH
21944: LD_INT 1
21946: PPUSH
21947: CALL_OW 3
21951: ST_TO_ADDR
21952: GO 21931
21954: POP
21955: POP
// end ;
21956: GO 21861
// end ;
21958: LD_VAR 0 3
21962: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
21963: LD_INT 0
21965: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
21966: LD_ADDR_EXP 63
21970: PUSH
21971: LD_EXP 63
21975: PPUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: LD_INT 1
21983: PPUSH
21984: LD_VAR 0 2
21988: PPUSH
21989: CALL 30950 0 4
21993: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
21994: LD_ADDR_EXP 63
21998: PUSH
21999: LD_EXP 63
22003: PPUSH
22004: LD_VAR 0 1
22008: PPUSH
22009: LD_INT 2
22011: PPUSH
22012: LD_VAR 0 3
22016: PPUSH
22017: CALL 30950 0 4
22021: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22022: LD_ADDR_EXP 63
22026: PUSH
22027: LD_EXP 63
22031: PPUSH
22032: LD_VAR 0 1
22036: PPUSH
22037: LD_INT 3
22039: PPUSH
22040: LD_VAR 0 4
22044: PPUSH
22045: CALL 30950 0 4
22049: ST_TO_ADDR
// end ; end_of_file
22050: LD_VAR 0 5
22054: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22055: LD_INT 0
22057: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22058: LD_ADDR_EXP 43
22062: PUSH
22063: LD_EXP 43
22067: PPUSH
22068: LD_VAR 0 1
22072: PPUSH
22073: LD_INT 1
22075: PPUSH
22076: LD_VAR 0 2
22080: PPUSH
22081: CALL 30950 0 4
22085: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22086: LD_VAR 0 1
22090: PPUSH
22091: EMPTY
22092: PPUSH
22093: CALL 11556 0 2
22097: PUSH
22098: LD_INT 1
22100: ARRAY
22101: PPUSH
22102: CALL_OW 248
22106: PUSH
22107: LD_INT 1
22109: EQUAL
22110: IFFALSE 22141
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22112: LD_VAR 0 1
22116: PPUSH
22117: LD_INT 4
22119: PUSH
22120: LD_INT 1
22122: PUSH
22123: LD_INT 1
22125: PUSH
22126: LD_INT 14
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: LIST
22133: LIST
22134: PPUSH
22135: CALL 20940 0 2
22139: GO 22168
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22141: LD_VAR 0 1
22145: PPUSH
22146: LD_INT 24
22148: PUSH
22149: LD_INT 1
22151: PUSH
22152: LD_INT 1
22154: PUSH
22155: LD_INT 53
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: LIST
22162: LIST
22163: PPUSH
22164: CALL 20940 0 2
// end ;
22168: LD_VAR 0 3
22172: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22173: LD_INT 0
22175: PPUSH
// CreateDepositXY ( x , y , t ) ;
22176: LD_VAR 0 1
22180: PPUSH
22181: LD_VAR 0 2
22185: PPUSH
22186: LD_VAR 0 3
22190: PPUSH
22191: CALL_OW 62
// end ;
22195: LD_VAR 0 4
22199: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22200: LD_INT 0
22202: PPUSH
22203: PPUSH
// c := 1 ;
22204: LD_ADDR_VAR 0 5
22208: PUSH
22209: LD_INT 1
22211: ST_TO_ADDR
// case color of red :
22212: LD_VAR 0 3
22216: PUSH
22217: LD_STRING red
22219: DOUBLE
22220: EQUAL
22221: IFTRUE 22225
22223: GO 22236
22225: POP
// c = 1 ; dark-green :
22226: LD_ADDR_VAR 0 5
22230: PUSH
22231: LD_INT 1
22233: ST_TO_ADDR
22234: GO 22522
22236: LD_STRING dark-green
22238: DOUBLE
22239: EQUAL
22240: IFTRUE 22244
22242: GO 22255
22244: POP
// c = 2 ; purple :
22245: LD_ADDR_VAR 0 5
22249: PUSH
22250: LD_INT 2
22252: ST_TO_ADDR
22253: GO 22522
22255: LD_STRING purple
22257: DOUBLE
22258: EQUAL
22259: IFTRUE 22263
22261: GO 22274
22263: POP
// c = 3 ; aqua :
22264: LD_ADDR_VAR 0 5
22268: PUSH
22269: LD_INT 3
22271: ST_TO_ADDR
22272: GO 22522
22274: LD_STRING aqua
22276: DOUBLE
22277: EQUAL
22278: IFTRUE 22282
22280: GO 22293
22282: POP
// c = 4 ; grey :
22283: LD_ADDR_VAR 0 5
22287: PUSH
22288: LD_INT 4
22290: ST_TO_ADDR
22291: GO 22522
22293: LD_STRING grey
22295: DOUBLE
22296: EQUAL
22297: IFTRUE 22301
22299: GO 22312
22301: POP
// c = 5 ; lime :
22302: LD_ADDR_VAR 0 5
22306: PUSH
22307: LD_INT 5
22309: ST_TO_ADDR
22310: GO 22522
22312: LD_STRING lime
22314: DOUBLE
22315: EQUAL
22316: IFTRUE 22320
22318: GO 22331
22320: POP
// c = 6 ; tan :
22321: LD_ADDR_VAR 0 5
22325: PUSH
22326: LD_INT 6
22328: ST_TO_ADDR
22329: GO 22522
22331: LD_STRING tan
22333: DOUBLE
22334: EQUAL
22335: IFTRUE 22339
22337: GO 22350
22339: POP
// c = 7 ; pink :
22340: LD_ADDR_VAR 0 5
22344: PUSH
22345: LD_INT 7
22347: ST_TO_ADDR
22348: GO 22522
22350: LD_STRING pink
22352: DOUBLE
22353: EQUAL
22354: IFTRUE 22358
22356: GO 22369
22358: POP
// c = 8 ; green :
22359: LD_ADDR_VAR 0 5
22363: PUSH
22364: LD_INT 8
22366: ST_TO_ADDR
22367: GO 22522
22369: LD_STRING green
22371: DOUBLE
22372: EQUAL
22373: IFTRUE 22377
22375: GO 22388
22377: POP
// c = 9 ; blue :
22378: LD_ADDR_VAR 0 5
22382: PUSH
22383: LD_INT 9
22385: ST_TO_ADDR
22386: GO 22522
22388: LD_STRING blue
22390: DOUBLE
22391: EQUAL
22392: IFTRUE 22396
22394: GO 22407
22396: POP
// c = 10 ; yellow :
22397: LD_ADDR_VAR 0 5
22401: PUSH
22402: LD_INT 10
22404: ST_TO_ADDR
22405: GO 22522
22407: LD_STRING yellow
22409: DOUBLE
22410: EQUAL
22411: IFTRUE 22415
22413: GO 22426
22415: POP
// c = 11 ; brown :
22416: LD_ADDR_VAR 0 5
22420: PUSH
22421: LD_INT 11
22423: ST_TO_ADDR
22424: GO 22522
22426: LD_STRING brown
22428: DOUBLE
22429: EQUAL
22430: IFTRUE 22434
22432: GO 22445
22434: POP
// c = 12 ; black :
22435: LD_ADDR_VAR 0 5
22439: PUSH
22440: LD_INT 12
22442: ST_TO_ADDR
22443: GO 22522
22445: LD_STRING black
22447: DOUBLE
22448: EQUAL
22449: IFTRUE 22453
22451: GO 22464
22453: POP
// c = 13 ; aqua2 :
22454: LD_ADDR_VAR 0 5
22458: PUSH
22459: LD_INT 13
22461: ST_TO_ADDR
22462: GO 22522
22464: LD_STRING aqua2
22466: DOUBLE
22467: EQUAL
22468: IFTRUE 22472
22470: GO 22483
22472: POP
// c = 14 ; orange :
22473: LD_ADDR_VAR 0 5
22477: PUSH
22478: LD_INT 14
22480: ST_TO_ADDR
22481: GO 22522
22483: LD_STRING orange
22485: DOUBLE
22486: EQUAL
22487: IFTRUE 22491
22489: GO 22502
22491: POP
// c = 15 ; white :
22492: LD_ADDR_VAR 0 5
22496: PUSH
22497: LD_INT 15
22499: ST_TO_ADDR
22500: GO 22522
22502: LD_STRING white
22504: DOUBLE
22505: EQUAL
22506: IFTRUE 22510
22508: GO 22521
22510: POP
// c = 16 ; end ;
22511: LD_ADDR_VAR 0 5
22515: PUSH
22516: LD_INT 16
22518: ST_TO_ADDR
22519: GO 22522
22521: POP
// if HexInfo ( x , y ) = 0 then
22522: LD_VAR 0 1
22526: PPUSH
22527: LD_VAR 0 2
22531: PPUSH
22532: CALL_OW 428
22536: PUSH
22537: LD_INT 0
22539: EQUAL
22540: IFFALSE 22564
// PlaceEnvironment ( x , y , 58 , c ) ;
22542: LD_VAR 0 1
22546: PPUSH
22547: LD_VAR 0 2
22551: PPUSH
22552: LD_INT 58
22554: PPUSH
22555: LD_VAR 0 5
22559: PPUSH
22560: CALL_OW 349
// end ;
22564: LD_VAR 0 4
22568: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22569: LD_INT 0
22571: PPUSH
// RemoveEnvironment ( x , y ) ;
22572: LD_VAR 0 1
22576: PPUSH
22577: LD_VAR 0 2
22581: PPUSH
22582: CALL_OW 347
// end ;
22586: LD_VAR 0 3
22590: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22591: LD_INT 0
22593: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22594: LD_INT 81
22596: PUSH
22597: LD_VAR 0 1
22601: PUSH
22602: EMPTY
22603: LIST
22604: LIST
22605: PPUSH
22606: CALL_OW 69
22610: PUSH
22611: LD_INT 0
22613: EQUAL
22614: IFFALSE 22626
// result := false else
22616: LD_ADDR_VAR 0 5
22620: PUSH
22621: LD_INT 0
22623: ST_TO_ADDR
22624: GO 22690
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22626: LD_INT 81
22628: PUSH
22629: LD_VAR 0 1
22633: PUSH
22634: EMPTY
22635: LIST
22636: LIST
22637: PUSH
22638: LD_INT 92
22640: PUSH
22641: LD_VAR 0 2
22645: PUSH
22646: LD_VAR 0 3
22650: PUSH
22651: LD_VAR 0 4
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: LIST
22660: LIST
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: PPUSH
22666: CALL_OW 69
22670: IFFALSE 22682
// result := true else
22672: LD_ADDR_VAR 0 5
22676: PUSH
22677: LD_INT 1
22679: ST_TO_ADDR
22680: GO 22690
// result := false ;
22682: LD_ADDR_VAR 0 5
22686: PUSH
22687: LD_INT 0
22689: ST_TO_ADDR
// end ;
22690: LD_VAR 0 5
22694: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22695: LD_INT 0
22697: PPUSH
22698: PPUSH
22699: PPUSH
22700: PPUSH
22701: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22702: LD_VAR 0 1
22706: PPUSH
22707: LD_INT 81
22709: PUSH
22710: LD_VAR 0 1
22714: PPUSH
22715: CALL_OW 255
22719: PUSH
22720: EMPTY
22721: LIST
22722: LIST
22723: PPUSH
22724: CALL_OW 69
22728: PPUSH
22729: LD_VAR 0 1
22733: PPUSH
22734: CALL_OW 74
22738: PPUSH
22739: CALL_OW 119
// dir := GetDir ( un ) ;
22743: LD_ADDR_VAR 0 4
22747: PUSH
22748: LD_VAR 0 1
22752: PPUSH
22753: CALL_OW 254
22757: ST_TO_ADDR
// dir := dir - 3 ;
22758: LD_ADDR_VAR 0 4
22762: PUSH
22763: LD_VAR 0 4
22767: PUSH
22768: LD_INT 3
22770: MINUS
22771: ST_TO_ADDR
// if dir < 0 then
22772: LD_VAR 0 4
22776: PUSH
22777: LD_INT 0
22779: LESS
22780: IFFALSE 22796
// dir := dir + 6 ;
22782: LD_ADDR_VAR 0 4
22786: PUSH
22787: LD_VAR 0 4
22791: PUSH
22792: LD_INT 6
22794: PLUS
22795: ST_TO_ADDR
// while true do
22796: LD_INT 1
22798: IFFALSE 23295
// begin coord_dist := 3 ;
22800: LD_ADDR_VAR 0 3
22804: PUSH
22805: LD_INT 3
22807: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22808: LD_ADDR_VAR 0 5
22812: PUSH
22813: LD_VAR 0 1
22817: PPUSH
22818: CALL_OW 250
22822: PPUSH
22823: LD_VAR 0 4
22827: PPUSH
22828: LD_VAR 0 3
22832: PPUSH
22833: CALL_OW 272
22837: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22838: LD_ADDR_VAR 0 6
22842: PUSH
22843: LD_VAR 0 1
22847: PPUSH
22848: CALL_OW 251
22852: PPUSH
22853: LD_VAR 0 4
22857: PPUSH
22858: LD_VAR 0 3
22862: PPUSH
22863: CALL_OW 273
22867: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 255
22877: PPUSH
22878: LD_VAR 0 1
22882: PPUSH
22883: CALL_OW 250
22887: PPUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: CALL_OW 251
22897: PPUSH
22898: LD_INT 14
22900: PPUSH
22901: CALL 22591 0 4
22905: PUSH
22906: LD_VAR 0 5
22910: PPUSH
22911: LD_VAR 0 6
22915: PPUSH
22916: CALL_OW 351
22920: OR
22921: PUSH
22922: LD_VAR 0 5
22926: PPUSH
22927: LD_VAR 0 6
22931: PPUSH
22932: CALL_OW 488
22936: PUSH
22937: LD_INT 0
22939: EQUAL
22940: OR
22941: PUSH
22942: LD_VAR 0 5
22946: PPUSH
22947: LD_VAR 0 6
22951: PPUSH
22952: CALL_OW 546
22956: PUSH
22957: LD_INT 1
22959: EQUAL
22960: OR
22961: PUSH
22962: LD_VAR 0 5
22966: PPUSH
22967: LD_VAR 0 6
22971: PPUSH
22972: CALL_OW 428
22976: PUSH
22977: LD_INT 0
22979: NONEQUAL
22980: OR
22981: IFFALSE 23209
// begin repeat begin Wait ( 0 0$0.3 ) ;
22983: LD_INT 10
22985: PPUSH
22986: CALL_OW 67
// coord_dist := coord_dist + 1 ;
22990: LD_ADDR_VAR 0 3
22994: PUSH
22995: LD_VAR 0 3
22999: PUSH
23000: LD_INT 1
23002: PLUS
23003: ST_TO_ADDR
// dir := dir + 1 ;
23004: LD_ADDR_VAR 0 4
23008: PUSH
23009: LD_VAR 0 4
23013: PUSH
23014: LD_INT 1
23016: PLUS
23017: ST_TO_ADDR
// if dir > 5 then
23018: LD_VAR 0 4
23022: PUSH
23023: LD_INT 5
23025: GREATER
23026: IFFALSE 23036
// dir = 0 ;
23028: LD_ADDR_VAR 0 4
23032: PUSH
23033: LD_INT 0
23035: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23036: LD_ADDR_VAR 0 5
23040: PUSH
23041: LD_VAR 0 1
23045: PPUSH
23046: CALL_OW 250
23050: PPUSH
23051: LD_VAR 0 4
23055: PPUSH
23056: LD_VAR 0 3
23060: PPUSH
23061: CALL_OW 272
23065: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23066: LD_ADDR_VAR 0 6
23070: PUSH
23071: LD_VAR 0 1
23075: PPUSH
23076: CALL_OW 251
23080: PPUSH
23081: LD_VAR 0 4
23085: PPUSH
23086: LD_VAR 0 3
23090: PPUSH
23091: CALL_OW 273
23095: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23096: LD_VAR 0 1
23100: PPUSH
23101: CALL_OW 255
23105: PPUSH
23106: LD_VAR 0 1
23110: PPUSH
23111: CALL_OW 250
23115: PPUSH
23116: LD_VAR 0 1
23120: PPUSH
23121: CALL_OW 251
23125: PPUSH
23126: LD_INT 14
23128: PPUSH
23129: CALL 22591 0 4
23133: NOT
23134: PUSH
23135: LD_VAR 0 5
23139: PPUSH
23140: LD_VAR 0 6
23144: PPUSH
23145: CALL_OW 351
23149: NOT
23150: AND
23151: PUSH
23152: LD_VAR 0 5
23156: PPUSH
23157: LD_VAR 0 6
23161: PPUSH
23162: CALL_OW 488
23166: AND
23167: PUSH
23168: LD_VAR 0 5
23172: PPUSH
23173: LD_VAR 0 6
23177: PPUSH
23178: CALL_OW 546
23182: PUSH
23183: LD_INT 0
23185: EQUAL
23186: AND
23187: PUSH
23188: LD_VAR 0 5
23192: PPUSH
23193: LD_VAR 0 6
23197: PPUSH
23198: CALL_OW 428
23202: PUSH
23203: LD_INT 0
23205: EQUAL
23206: AND
23207: IFFALSE 22983
// end ; ComMoveXY ( un , x , y ) ;
23209: LD_VAR 0 1
23213: PPUSH
23214: LD_VAR 0 5
23218: PPUSH
23219: LD_VAR 0 6
23223: PPUSH
23224: CALL_OW 111
// Wait ( 0 0$1 ) ;
23228: LD_INT 35
23230: PPUSH
23231: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23235: LD_VAR 0 1
23239: PPUSH
23240: LD_INT 81
23242: PUSH
23243: LD_VAR 0 1
23247: PPUSH
23248: CALL_OW 255
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PPUSH
23257: CALL_OW 69
23261: PPUSH
23262: LD_VAR 0 1
23266: PPUSH
23267: CALL_OW 74
23271: PPUSH
23272: CALL_OW 296
23276: PUSH
23277: LD_INT 14
23279: GREATEREQUAL
23280: IFFALSE 23293
// begin ComStop ( un ) ;
23282: LD_VAR 0 1
23286: PPUSH
23287: CALL_OW 141
// break ;
23291: GO 23295
// end ; end ;
23293: GO 22796
// end ;
23295: LD_VAR 0 2
23299: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23300: LD_INT 0
23302: PPUSH
23303: PPUSH
23304: PPUSH
23305: PPUSH
23306: PPUSH
23307: PPUSH
23308: PPUSH
23309: PPUSH
// x := GetX ( unit ) ;
23310: LD_ADDR_VAR 0 3
23314: PUSH
23315: LD_VAR 0 1
23319: PPUSH
23320: CALL_OW 250
23324: ST_TO_ADDR
// y := GetY ( unit ) ;
23325: LD_ADDR_VAR 0 4
23329: PUSH
23330: LD_VAR 0 1
23334: PPUSH
23335: CALL_OW 251
23339: ST_TO_ADDR
// i := 0 ;
23340: LD_ADDR_VAR 0 8
23344: PUSH
23345: LD_INT 0
23347: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23348: LD_VAR 0 1
23352: PPUSH
23353: LD_INT 81
23355: PUSH
23356: LD_VAR 0 1
23360: PPUSH
23361: CALL_OW 255
23365: PUSH
23366: EMPTY
23367: LIST
23368: LIST
23369: PPUSH
23370: CALL_OW 69
23374: PPUSH
23375: LD_VAR 0 1
23379: PPUSH
23380: CALL_OW 74
23384: PPUSH
23385: CALL_OW 119
// dir := GetDir ( unit ) ;
23389: LD_ADDR_VAR 0 7
23393: PUSH
23394: LD_VAR 0 1
23398: PPUSH
23399: CALL_OW 254
23403: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23404: LD_ADDR_VAR 0 9
23408: PUSH
23409: LD_INT 0
23411: PPUSH
23412: LD_INT 1
23414: PPUSH
23415: CALL_OW 12
23419: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23420: LD_INT 10
23422: PPUSH
23423: CALL_OW 67
// if mode then
23427: LD_VAR 0 9
23431: IFFALSE 23449
// dir := dir + 1 else
23433: LD_ADDR_VAR 0 7
23437: PUSH
23438: LD_VAR 0 7
23442: PUSH
23443: LD_INT 1
23445: PLUS
23446: ST_TO_ADDR
23447: GO 23463
// dir := dir - 1 ;
23449: LD_ADDR_VAR 0 7
23453: PUSH
23454: LD_VAR 0 7
23458: PUSH
23459: LD_INT 1
23461: MINUS
23462: ST_TO_ADDR
// if ( dir < 0 ) then
23463: LD_VAR 0 7
23467: PUSH
23468: LD_INT 0
23470: LESS
23471: IFFALSE 23481
// dir := 5 ;
23473: LD_ADDR_VAR 0 7
23477: PUSH
23478: LD_INT 5
23480: ST_TO_ADDR
// if ( dir > 5 ) then
23481: LD_VAR 0 7
23485: PUSH
23486: LD_INT 5
23488: GREATER
23489: IFFALSE 23499
// dir := 0 ;
23491: LD_ADDR_VAR 0 7
23495: PUSH
23496: LD_INT 0
23498: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23499: LD_ADDR_VAR 0 5
23503: PUSH
23504: LD_VAR 0 3
23508: PPUSH
23509: LD_VAR 0 7
23513: PPUSH
23514: LD_INT 4
23516: PPUSH
23517: CALL_OW 272
23521: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23522: LD_ADDR_VAR 0 6
23526: PUSH
23527: LD_VAR 0 4
23531: PPUSH
23532: LD_VAR 0 7
23536: PPUSH
23537: LD_INT 4
23539: PPUSH
23540: CALL_OW 273
23544: ST_TO_ADDR
// i := i + 1 ;
23545: LD_ADDR_VAR 0 8
23549: PUSH
23550: LD_VAR 0 8
23554: PUSH
23555: LD_INT 1
23557: PLUS
23558: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 255
23568: PPUSH
23569: LD_VAR 0 5
23573: PPUSH
23574: LD_VAR 0 6
23578: PPUSH
23579: LD_INT 14
23581: PPUSH
23582: CALL 22591 0 4
23586: PUSH
23587: LD_INT 0
23589: EQUAL
23590: PUSH
23591: LD_VAR 0 5
23595: PPUSH
23596: LD_VAR 0 6
23600: PPUSH
23601: CALL_OW 546
23605: PUSH
23606: LD_INT 0
23608: EQUAL
23609: AND
23610: PUSH
23611: LD_VAR 0 5
23615: PPUSH
23616: LD_VAR 0 6
23620: PPUSH
23621: CALL_OW 428
23625: PUSH
23626: LD_INT 0
23628: EQUAL
23629: AND
23630: IFFALSE 23634
// break ;
23632: GO 23644
// end until i > 4 ;
23634: LD_VAR 0 8
23638: PUSH
23639: LD_INT 4
23641: GREATER
23642: IFFALSE 23420
// if x2 and y2 then
23644: LD_VAR 0 5
23648: PUSH
23649: LD_VAR 0 6
23653: AND
23654: IFFALSE 23677
// result := [ x2 , y2 ] else
23656: LD_ADDR_VAR 0 2
23660: PUSH
23661: LD_VAR 0 5
23665: PUSH
23666: LD_VAR 0 6
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: ST_TO_ADDR
23675: GO 23706
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23677: LD_ADDR_VAR 0 2
23681: PUSH
23682: LD_VAR 0 1
23686: PPUSH
23687: CALL_OW 250
23691: PUSH
23692: LD_VAR 0 1
23696: PPUSH
23697: CALL_OW 251
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: ST_TO_ADDR
// end ;
23706: LD_VAR 0 2
23710: RET
// export function MCT_Hex ( x , y ) ; begin
23711: LD_INT 0
23713: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23714: LD_ADDR_VAR 0 3
23718: PUSH
23719: LD_VAR 0 1
23723: PPUSH
23724: LD_VAR 0 2
23728: PPUSH
23729: CALL_OW 546
23733: PUSH
23734: LD_VAR 0 1
23738: PPUSH
23739: LD_VAR 0 2
23743: PPUSH
23744: CALL_OW 428
23748: PUSH
23749: EMPTY
23750: LIST
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: ST_TO_ADDR
// end ;
23756: LD_VAR 0 3
23760: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23761: LD_INT 0
23763: PPUSH
23764: PPUSH
23765: PPUSH
23766: PPUSH
23767: PPUSH
23768: PPUSH
23769: PPUSH
23770: PPUSH
23771: PPUSH
23772: PPUSH
23773: PPUSH
23774: PPUSH
23775: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23776: LD_ADDR_VAR 0 10
23780: PUSH
23781: LD_EXP 61
23785: PUSH
23786: LD_VAR 0 1
23790: ARRAY
23791: PUSH
23792: LD_INT 1
23794: ARRAY
23795: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23796: LD_ADDR_VAR 0 11
23800: PUSH
23801: LD_EXP 61
23805: PUSH
23806: LD_VAR 0 1
23810: ARRAY
23811: PUSH
23812: LD_INT 2
23814: ARRAY
23815: ST_TO_ADDR
// collectors := [ ] ;
23816: LD_ADDR_VAR 0 12
23820: PUSH
23821: EMPTY
23822: ST_TO_ADDR
// is_cargo := false ;
23823: LD_ADDR_VAR 0 13
23827: PUSH
23828: LD_INT 0
23830: ST_TO_ADDR
// if isTest then
23831: LD_EXP 1
23835: IFFALSE 23841
// TimerStart ( ) ;
23837: CALL_OW 548
// if MCF_Cargo ( side ) then
23841: LD_VAR 0 1
23845: PPUSH
23846: CALL 11772 0 1
23850: IFFALSE 23877
// begin collectors := MCF_Cargo ( side ) ;
23852: LD_ADDR_VAR 0 12
23856: PUSH
23857: LD_VAR 0 1
23861: PPUSH
23862: CALL 11772 0 1
23866: ST_TO_ADDR
// is_cargo := true ;
23867: LD_ADDR_VAR 0 13
23871: PUSH
23872: LD_INT 1
23874: ST_TO_ADDR
// end else
23875: GO 24026
// begin if MCF_ApeSpec ( side , engineer ) then
23877: LD_VAR 0 1
23881: PPUSH
23882: LD_STRING engineer
23884: PPUSH
23885: CALL 11918 0 2
23889: IFFALSE 23909
// collectors := MCF_ApeSpec ( side , engineer ) ;
23891: LD_ADDR_VAR 0 12
23895: PUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: LD_STRING engineer
23903: PPUSH
23904: CALL 11918 0 2
23908: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23909: LD_VAR 0 1
23913: PPUSH
23914: LD_INT 2
23916: PPUSH
23917: EMPTY
23918: PPUSH
23919: CALL 11504 0 3
23923: IFFALSE 24026
// begin z := MCF_Class ( side , 2 , [ ] ) ;
23925: LD_ADDR_VAR 0 7
23929: PUSH
23930: LD_VAR 0 1
23934: PPUSH
23935: LD_INT 2
23937: PPUSH
23938: EMPTY
23939: PPUSH
23940: CALL 11504 0 3
23944: ST_TO_ADDR
// if z > 5 then
23945: LD_VAR 0 7
23949: PUSH
23950: LD_INT 5
23952: GREATER
23953: IFFALSE 23965
// t1 := 5 else
23955: LD_ADDR_VAR 0 8
23959: PUSH
23960: LD_INT 5
23962: ST_TO_ADDR
23963: GO 23975
// t1 := z ;
23965: LD_ADDR_VAR 0 8
23969: PUSH
23970: LD_VAR 0 7
23974: ST_TO_ADDR
// for t2 = 1 to t1 do
23975: LD_ADDR_VAR 0 9
23979: PUSH
23980: DOUBLE
23981: LD_INT 1
23983: DEC
23984: ST_TO_ADDR
23985: LD_VAR 0 8
23989: PUSH
23990: FOR_TO
23991: IFFALSE 24024
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
23993: LD_ADDR_VAR 0 12
23997: PUSH
23998: LD_VAR 0 12
24002: PPUSH
24003: LD_INT 1
24005: PPUSH
24006: LD_VAR 0 7
24010: PUSH
24011: LD_VAR 0 9
24015: ARRAY
24016: PPUSH
24017: CALL_OW 2
24021: ST_TO_ADDR
24022: GO 23990
24024: POP
24025: POP
// end ; end ; if not mode then
24026: LD_VAR 0 10
24030: NOT
24031: IFFALSE 24037
// exit else
24033: GO 24296
24035: GO 24296
// begin if collectors then
24037: LD_VAR 0 12
24041: IFFALSE 24296
// for i in areas do
24043: LD_ADDR_VAR 0 3
24047: PUSH
24048: LD_VAR 0 11
24052: PUSH
24053: FOR_IN
24054: IFFALSE 24294
// if GetListOfCratesInArea ( i ) then
24056: LD_VAR 0 3
24060: PPUSH
24061: CALL_OW 435
24065: IFFALSE 24292
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24067: LD_ADDR_VAR 0 5
24071: PUSH
24072: LD_VAR 0 3
24076: PPUSH
24077: CALL_OW 435
24081: PUSH
24082: LD_INT 1
24084: ARRAY
24085: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24086: LD_ADDR_VAR 0 6
24090: PUSH
24091: LD_VAR 0 3
24095: PPUSH
24096: CALL_OW 435
24100: PUSH
24101: LD_INT 2
24103: ARRAY
24104: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24105: LD_VAR 0 13
24109: PUSH
24110: LD_VAR 0 12
24114: PUSH
24115: LD_INT 1
24117: ARRAY
24118: PPUSH
24119: CALL_OW 110
24123: PUSH
24124: LD_INT 0
24126: EQUAL
24127: AND
24128: IFFALSE 24190
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24130: LD_VAR 0 12
24134: PUSH
24135: LD_INT 1
24137: ARRAY
24138: PPUSH
24139: CALL_OW 314
24143: NOT
24144: PUSH
24145: LD_VAR 0 12
24149: PUSH
24150: LD_INT 1
24152: ARRAY
24153: PPUSH
24154: CALL_OW 110
24158: PUSH
24159: LD_INT 0
24161: EQUAL
24162: AND
24163: IFFALSE 24188
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24165: LD_VAR 0 12
24169: PUSH
24170: LD_INT 1
24172: ARRAY
24173: PPUSH
24174: LD_VAR 0 5
24178: PPUSH
24179: LD_VAR 0 6
24183: PPUSH
24184: CALL_OW 117
// end ; end else
24188: GO 24276
// begin for j = 1 to collectors do
24190: LD_ADDR_VAR 0 4
24194: PUSH
24195: DOUBLE
24196: LD_INT 1
24198: DEC
24199: ST_TO_ADDR
24200: LD_VAR 0 12
24204: PUSH
24205: FOR_TO
24206: IFFALSE 24274
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24208: LD_VAR 0 12
24212: PUSH
24213: LD_VAR 0 4
24217: ARRAY
24218: PPUSH
24219: CALL_OW 314
24223: NOT
24224: PUSH
24225: LD_VAR 0 12
24229: PUSH
24230: LD_VAR 0 4
24234: ARRAY
24235: PPUSH
24236: CALL_OW 110
24240: PUSH
24241: LD_INT 0
24243: EQUAL
24244: AND
24245: IFFALSE 24272
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24247: LD_VAR 0 12
24251: PUSH
24252: LD_VAR 0 4
24256: ARRAY
24257: PPUSH
24258: LD_VAR 0 5
24262: PPUSH
24263: LD_VAR 0 6
24267: PPUSH
24268: CALL 24667 0 3
// end ;
24272: GO 24205
24274: POP
24275: POP
// end ; if isTest then
24276: LD_EXP 1
24280: IFFALSE 24292
// begin debug_time := TimerEnd ( ) ;
24282: LD_ADDR_VAR 0 14
24286: PUSH
24287: CALL_OW 549
24291: ST_TO_ADDR
// end ; end ;
24292: GO 24053
24294: POP
24295: POP
// end ; end ;
24296: LD_VAR 0 2
24300: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24301: LD_INT 0
24303: PPUSH
24304: PPUSH
24305: PPUSH
24306: PPUSH
24307: PPUSH
24308: PPUSH
// if not area then
24309: LD_VAR 0 1
24313: NOT
24314: IFFALSE 24320
// exit else
24316: GO 24582
24318: GO 24582
// if tick mod interval = 0 and Prob ( percent ) then
24320: LD_OWVAR 1
24324: PUSH
24325: LD_VAR 0 4
24329: MOD
24330: PUSH
24331: LD_INT 0
24333: EQUAL
24334: PUSH
24335: LD_VAR 0 3
24339: PPUSH
24340: CALL_OW 13
24344: AND
24345: IFFALSE 24582
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24347: LD_VAR 0 1
24351: PPUSH
24352: CALL_OW 435
24356: PUSH
24357: LD_VAR 0 5
24361: LESS
24362: PUSH
24363: LD_VAR 0 5
24367: PUSH
24368: LD_INT 0
24370: EQUAL
24371: OR
24372: IFFALSE 24582
// begin Randomize ;
24374: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24378: LD_ADDR_VAR 0 7
24382: PUSH
24383: LD_INT 1
24385: PPUSH
24386: LD_VAR 0 2
24390: PPUSH
24391: CALL_OW 12
24395: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24396: LD_ADDR_VAR 0 9
24400: PUSH
24401: LD_VAR 0 1
24405: PPUSH
24406: LD_INT 0
24408: PPUSH
24409: CALL_OW 517
24413: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24414: LD_ADDR_VAR 0 8
24418: PUSH
24419: LD_INT 1
24421: PPUSH
24422: LD_VAR 0 9
24426: PUSH
24427: LD_INT 1
24429: ARRAY
24430: PPUSH
24431: CALL_OW 12
24435: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24436: LD_VAR 0 9
24440: PUSH
24441: LD_INT 1
24443: ARRAY
24444: PUSH
24445: LD_VAR 0 8
24449: ARRAY
24450: PPUSH
24451: LD_VAR 0 9
24455: PUSH
24456: LD_INT 2
24458: ARRAY
24459: PUSH
24460: LD_VAR 0 8
24464: ARRAY
24465: PPUSH
24466: CALL_OW 428
24470: PUSH
24471: LD_INT 0
24473: GREATER
24474: PUSH
24475: LD_VAR 0 9
24479: PUSH
24480: LD_INT 1
24482: ARRAY
24483: PUSH
24484: LD_VAR 0 8
24488: ARRAY
24489: PPUSH
24490: LD_VAR 0 9
24494: PUSH
24495: LD_INT 2
24497: ARRAY
24498: PUSH
24499: LD_VAR 0 8
24503: ARRAY
24504: PPUSH
24505: CALL_OW 284
24509: PUSH
24510: LD_INT 0
24512: GREATER
24513: AND
24514: IFFALSE 24540
// c := Rand ( 1 , tmp [ 1 ] ) ;
24516: LD_ADDR_VAR 0 8
24520: PUSH
24521: LD_INT 1
24523: PPUSH
24524: LD_VAR 0 9
24528: PUSH
24529: LD_INT 1
24531: ARRAY
24532: PPUSH
24533: CALL_OW 12
24537: ST_TO_ADDR
24538: GO 24436
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24540: LD_VAR 0 7
24544: PPUSH
24545: LD_VAR 0 9
24549: PUSH
24550: LD_INT 1
24552: ARRAY
24553: PUSH
24554: LD_VAR 0 8
24558: ARRAY
24559: PPUSH
24560: LD_VAR 0 9
24564: PUSH
24565: LD_INT 2
24567: ARRAY
24568: PUSH
24569: LD_VAR 0 8
24573: ARRAY
24574: PPUSH
24575: LD_INT 1
24577: PPUSH
24578: CALL_OW 54
// end ; end ; end ;
24582: LD_VAR 0 6
24586: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24587: LD_INT 0
24589: PPUSH
24590: PPUSH
// if not MREG_Crates then
24591: LD_EXP 35
24595: NOT
24596: IFFALSE 24600
// exit ;
24598: GO 24662
// for i = MREG_Crates downto 1 do
24600: LD_ADDR_VAR 0 2
24604: PUSH
24605: DOUBLE
24606: LD_EXP 35
24610: INC
24611: ST_TO_ADDR
24612: LD_INT 1
24614: PUSH
24615: FOR_DOWNTO
24616: IFFALSE 24660
// if MREG_Crates [ i ] [ 3 ] = 0 then
24618: LD_EXP 35
24622: PUSH
24623: LD_VAR 0 2
24627: ARRAY
24628: PUSH
24629: LD_INT 3
24631: ARRAY
24632: PUSH
24633: LD_INT 0
24635: EQUAL
24636: IFFALSE 24658
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24638: LD_ADDR_EXP 35
24642: PUSH
24643: LD_EXP 35
24647: PPUSH
24648: LD_VAR 0 2
24652: PPUSH
24653: CALL_OW 3
24657: ST_TO_ADDR
24658: GO 24615
24660: POP
24661: POP
// end ;
24662: LD_VAR 0 1
24666: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24667: LD_INT 0
24669: PPUSH
24670: PPUSH
24671: PPUSH
24672: PPUSH
// if not unit then
24673: LD_VAR 0 1
24677: NOT
24678: IFFALSE 24682
// exit ;
24680: GO 24817
// if HasTask ( unit ) or not CanCarry ( unit ) then
24682: LD_VAR 0 1
24686: PPUSH
24687: CALL_OW 314
24691: PUSH
24692: LD_VAR 0 1
24696: PPUSH
24697: CALL_OW 280
24701: NOT
24702: OR
24703: IFFALSE 24707
// exit ;
24705: GO 24817
// side := GetSide ( unit ) ;
24707: LD_ADDR_VAR 0 6
24711: PUSH
24712: LD_VAR 0 1
24716: PPUSH
24717: CALL_OW 255
24721: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24722: LD_ADDR_VAR 0 7
24726: PUSH
24727: LD_VAR 0 6
24731: PPUSH
24732: LD_INT 30
24734: PUSH
24735: LD_INT 1
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PPUSH
24742: CALL 11421 0 2
24746: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24747: LD_VAR 0 1
24751: PPUSH
24752: CALL_OW 281
24756: PUSH
24757: LD_VAR 0 7
24761: NOT
24762: OR
24763: IFFALSE 24769
// exit else
24765: GO 24817
24767: GO 24817
// if GetResourceAmountXY ( x , y ) then
24769: LD_VAR 0 2
24773: PPUSH
24774: LD_VAR 0 3
24778: PPUSH
24779: CALL_OW 284
24783: IFFALSE 24815
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24785: LD_VAR 0 1
24789: PPUSH
24790: LD_VAR 0 2
24794: PPUSH
24795: LD_VAR 0 3
24799: PPUSH
24800: LD_VAR 0 7
24804: PUSH
24805: LD_INT 1
24807: ARRAY
24808: PPUSH
24809: CALL 32114 0 4
// end else
24813: GO 24817
// exit ;
24815: GO 24817
// end ;
24817: LD_VAR 0 4
24821: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24822: LD_INT 0
24824: PPUSH
24825: PPUSH
24826: PPUSH
24827: PPUSH
24828: PPUSH
// result := 0 ;
24829: LD_ADDR_VAR 0 2
24833: PUSH
24834: LD_INT 0
24836: ST_TO_ADDR
// p := 1 ;
24837: LD_ADDR_VAR 0 4
24841: PUSH
24842: LD_INT 1
24844: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24845: LD_ADDR_VAR 0 3
24849: PUSH
24850: DOUBLE
24851: LD_INT 1
24853: DEC
24854: ST_TO_ADDR
24855: LD_EXP 64
24859: PUSH
24860: LD_VAR 0 1
24864: ARRAY
24865: PUSH
24866: LD_INT 1
24868: ARRAY
24869: PUSH
24870: LD_INT 2
24872: DIVREAL
24873: PUSH
24874: FOR_TO
24875: IFFALSE 24999
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24877: LD_ADDR_VAR 0 5
24881: PUSH
24882: LD_INT 81
24884: PUSH
24885: LD_VAR 0 1
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: PUSH
24894: LD_INT 92
24896: PUSH
24897: LD_EXP 64
24901: PUSH
24902: LD_VAR 0 1
24906: ARRAY
24907: PUSH
24908: LD_INT 1
24910: ARRAY
24911: PUSH
24912: LD_VAR 0 4
24916: ARRAY
24917: PUSH
24918: LD_EXP 64
24922: PUSH
24923: LD_VAR 0 1
24927: ARRAY
24928: PUSH
24929: LD_INT 1
24931: ARRAY
24932: PUSH
24933: LD_VAR 0 4
24937: PUSH
24938: LD_INT 1
24940: PLUS
24941: ARRAY
24942: PUSH
24943: LD_INT 12
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: LIST
24950: LIST
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PPUSH
24956: CALL_OW 69
24960: ST_TO_ADDR
// if tmp then
24961: LD_VAR 0 5
24965: IFFALSE 24983
// result := result ^ tmp ;
24967: LD_ADDR_VAR 0 2
24971: PUSH
24972: LD_VAR 0 2
24976: PUSH
24977: LD_VAR 0 5
24981: ADD
24982: ST_TO_ADDR
// p := p + 2 ;
24983: LD_ADDR_VAR 0 4
24987: PUSH
24988: LD_VAR 0 4
24992: PUSH
24993: LD_INT 2
24995: PLUS
24996: ST_TO_ADDR
// end ;
24997: GO 24874
24999: POP
25000: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25001: LD_EXP 65
25005: PUSH
25006: LD_VAR 0 1
25010: ARRAY
25011: PPUSH
25012: LD_INT 81
25014: PUSH
25015: LD_VAR 0 1
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PPUSH
25024: CALL_OW 70
25028: IFFALSE 25069
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25030: LD_ADDR_VAR 0 2
25034: PUSH
25035: LD_VAR 0 2
25039: PUSH
25040: LD_EXP 65
25044: PUSH
25045: LD_VAR 0 1
25049: ARRAY
25050: PPUSH
25051: LD_INT 81
25053: PUSH
25054: LD_VAR 0 1
25058: PUSH
25059: EMPTY
25060: LIST
25061: LIST
25062: PPUSH
25063: CALL_OW 70
25067: ADD
25068: ST_TO_ADDR
// end ; end_of_file
25069: LD_VAR 0 2
25073: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25074: LD_INT 0
25076: PPUSH
25077: PPUSH
25078: PPUSH
// pom := GetBase ( fac ) ;
25079: LD_ADDR_VAR 0 5
25083: PUSH
25084: LD_VAR 0 1
25088: PPUSH
25089: CALL_OW 274
25093: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25094: LD_ADDR_VAR 0 4
25098: PUSH
25099: LD_VAR 0 2
25103: PUSH
25104: LD_INT 1
25106: ARRAY
25107: PPUSH
25108: LD_VAR 0 2
25112: PUSH
25113: LD_INT 2
25115: ARRAY
25116: PPUSH
25117: LD_VAR 0 2
25121: PUSH
25122: LD_INT 3
25124: ARRAY
25125: PPUSH
25126: LD_VAR 0 2
25130: PUSH
25131: LD_INT 4
25133: ARRAY
25134: PPUSH
25135: CALL_OW 449
25139: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25140: LD_VAR 0 5
25144: PPUSH
25145: LD_INT 1
25147: PPUSH
25148: CALL_OW 275
25152: PUSH
25153: LD_VAR 0 4
25157: PUSH
25158: LD_INT 1
25160: ARRAY
25161: GREATEREQUAL
25162: PUSH
25163: LD_VAR 0 5
25167: PPUSH
25168: LD_INT 2
25170: PPUSH
25171: CALL_OW 275
25175: PUSH
25176: LD_VAR 0 4
25180: PUSH
25181: LD_INT 2
25183: ARRAY
25184: GREATEREQUAL
25185: AND
25186: PUSH
25187: LD_VAR 0 5
25191: PPUSH
25192: LD_INT 3
25194: PPUSH
25195: CALL_OW 275
25199: PUSH
25200: LD_VAR 0 4
25204: PUSH
25205: LD_INT 3
25207: ARRAY
25208: GREATEREQUAL
25209: AND
25210: IFFALSE 25222
// result := true else
25212: LD_ADDR_VAR 0 3
25216: PUSH
25217: LD_INT 1
25219: ST_TO_ADDR
25220: GO 25230
// result := false ;
25222: LD_ADDR_VAR 0 3
25226: PUSH
25227: LD_INT 0
25229: ST_TO_ADDR
// end ;
25230: LD_VAR 0 3
25234: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25235: LD_INT 0
25237: PPUSH
25238: PPUSH
25239: PPUSH
// result := false ;
25240: LD_ADDR_VAR 0 3
25244: PUSH
25245: LD_INT 0
25247: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25248: LD_ADDR_VAR 0 4
25252: PUSH
25253: LD_EXP 52
25257: PUSH
25258: LD_VAR 0 1
25262: ARRAY
25263: ST_TO_ADDR
// if tmp then
25264: LD_VAR 0 4
25268: IFFALSE 25320
// for i = 1 to tmp do
25270: LD_ADDR_VAR 0 5
25274: PUSH
25275: DOUBLE
25276: LD_INT 1
25278: DEC
25279: ST_TO_ADDR
25280: LD_VAR 0 4
25284: PUSH
25285: FOR_TO
25286: IFFALSE 25318
// if component = tmp [ i ] then
25288: LD_VAR 0 2
25292: PUSH
25293: LD_VAR 0 4
25297: PUSH
25298: LD_VAR 0 5
25302: ARRAY
25303: EQUAL
25304: IFFALSE 25316
// begin result := true ;
25306: LD_ADDR_VAR 0 3
25310: PUSH
25311: LD_INT 1
25313: ST_TO_ADDR
// break ;
25314: GO 25318
// end ;
25316: GO 25285
25318: POP
25319: POP
// end ;
25320: LD_VAR 0 3
25324: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25325: LD_INT 0
25327: PPUSH
25328: PPUSH
25329: PPUSH
// if fac then
25330: LD_VAR 0 2
25334: IFFALSE 25569
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25336: LD_VAR 0 2
25340: PPUSH
25341: LD_VAR 0 3
25345: PPUSH
25346: CALL 25074 0 2
25350: PUSH
25351: LD_VAR 0 2
25355: PPUSH
25356: CALL_OW 461
25360: PUSH
25361: LD_INT 2
25363: EQUAL
25364: AND
25365: PUSH
25366: LD_VAR 0 2
25370: PPUSH
25371: LD_VAR 0 3
25375: PUSH
25376: LD_INT 1
25378: ARRAY
25379: PPUSH
25380: LD_VAR 0 3
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: PPUSH
25389: LD_VAR 0 3
25393: PUSH
25394: LD_INT 3
25396: ARRAY
25397: PPUSH
25398: LD_VAR 0 3
25402: PUSH
25403: LD_INT 4
25405: ARRAY
25406: PPUSH
25407: CALL_OW 448
25411: AND
25412: IFFALSE 25559
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25414: LD_VAR 0 2
25418: PPUSH
25419: LD_VAR 0 3
25423: PUSH
25424: LD_INT 1
25426: ARRAY
25427: PPUSH
25428: LD_VAR 0 3
25432: PUSH
25433: LD_INT 2
25435: ARRAY
25436: PPUSH
25437: LD_VAR 0 3
25441: PUSH
25442: LD_INT 3
25444: ARRAY
25445: PPUSH
25446: LD_VAR 0 3
25450: PUSH
25451: LD_INT 4
25453: ARRAY
25454: PPUSH
25455: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25459: LD_ADDR_VAR 0 6
25463: PUSH
25464: LD_EXP 52
25468: PUSH
25469: LD_VAR 0 1
25473: ARRAY
25474: ST_TO_ADDR
// for i = 4 downto 1 do
25475: LD_ADDR_VAR 0 5
25479: PUSH
25480: DOUBLE
25481: LD_INT 4
25483: INC
25484: ST_TO_ADDR
25485: LD_INT 1
25487: PUSH
25488: FOR_DOWNTO
25489: IFFALSE 25522
// tab := Remove ( tab , list [ i ] , true ) ;
25491: LD_ADDR_VAR 0 6
25495: PUSH
25496: LD_VAR 0 6
25500: PPUSH
25501: LD_VAR 0 3
25505: PUSH
25506: LD_VAR 0 5
25510: ARRAY
25511: PPUSH
25512: LD_INT 1
25514: PPUSH
25515: CALL 31109 0 3
25519: ST_TO_ADDR
25520: GO 25488
25522: POP
25523: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25524: LD_ADDR_EXP 52
25528: PUSH
25529: LD_EXP 52
25533: PPUSH
25534: LD_VAR 0 1
25538: PPUSH
25539: LD_VAR 0 6
25543: PPUSH
25544: CALL_OW 1
25548: ST_TO_ADDR
// result := true ;
25549: LD_ADDR_VAR 0 4
25553: PUSH
25554: LD_INT 1
25556: ST_TO_ADDR
// end else
25557: GO 25567
// result := false ;
25559: LD_ADDR_VAR 0 4
25563: PUSH
25564: LD_INT 0
25566: ST_TO_ADDR
// end else
25567: GO 25577
// result := false ;
25569: LD_ADDR_VAR 0 4
25573: PUSH
25574: LD_INT 0
25576: ST_TO_ADDR
// end ;
25577: LD_VAR 0 4
25581: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25582: LD_INT 0
25584: PPUSH
25585: PPUSH
// if not veh then
25586: LD_VAR 0 2
25590: NOT
25591: IFFALSE 25595
// exit ;
25593: GO 25769
// if MREG_Parking [ side ] then
25595: LD_EXP 59
25599: PUSH
25600: LD_VAR 0 1
25604: ARRAY
25605: IFFALSE 25769
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25607: LD_VAR 0 2
25611: PPUSH
25612: LD_EXP 59
25616: PUSH
25617: LD_VAR 0 1
25621: ARRAY
25622: PPUSH
25623: CALL_OW 308
25627: NOT
25628: IFFALSE 25769
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25630: LD_VAR 0 2
25634: PPUSH
25635: LD_EXP 59
25639: PUSH
25640: LD_VAR 0 1
25644: ARRAY
25645: PPUSH
25646: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25650: LD_VAR 0 2
25654: PPUSH
25655: CALL_OW 263
25659: PUSH
25660: LD_INT 1
25662: EQUAL
25663: IFFALSE 25769
// begin i := GetDriver ( veh ) ;
25665: LD_ADDR_VAR 0 4
25669: PUSH
25670: LD_VAR 0 2
25674: PPUSH
25675: CALL 31644 0 1
25679: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25680: LD_INT 35
25682: PPUSH
25683: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25687: LD_VAR 0 2
25691: PPUSH
25692: LD_EXP 59
25696: PUSH
25697: LD_VAR 0 1
25701: ARRAY
25702: PPUSH
25703: CALL_OW 308
25707: PUSH
25708: LD_VAR 0 2
25712: PPUSH
25713: CALL_OW 301
25717: OR
25718: IFFALSE 25680
// ComExitVehicle ( i ) ;
25720: LD_VAR 0 4
25724: PPUSH
25725: CALL_OW 121
// Wait ( 1 ) ;
25729: LD_INT 1
25731: PPUSH
25732: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25736: LD_VAR 0 4
25740: PPUSH
25741: LD_VAR 0 1
25745: PPUSH
25746: LD_INT 30
25748: PUSH
25749: LD_INT 3
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PPUSH
25756: CALL 11421 0 2
25760: PUSH
25761: LD_INT 1
25763: ARRAY
25764: PPUSH
25765: CALL_OW 180
// end ; end ; end ;
25769: LD_VAR 0 3
25773: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25774: LD_INT 0
25776: PPUSH
25777: PPUSH
25778: PPUSH
25779: PPUSH
25780: PPUSH
25781: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25782: LD_VAR 0 1
25786: PPUSH
25787: LD_INT 30
25789: PUSH
25790: LD_INT 3
25792: PUSH
25793: EMPTY
25794: LIST
25795: LIST
25796: PPUSH
25797: CALL 11421 0 2
25801: IFFALSE 25985
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25803: LD_VAR 0 1
25807: PPUSH
25808: LD_INT 30
25810: PUSH
25811: LD_INT 3
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PPUSH
25818: CALL 11421 0 2
25822: PUSH
25823: LD_INT 1
25825: ARRAY
25826: PPUSH
25827: CALL_OW 461
25831: PUSH
25832: LD_INT 2
25834: EQUAL
25835: IFFALSE 25985
// begin for i = 1 to MREG_TurretWeapon do
25837: LD_ADDR_VAR 0 3
25841: PUSH
25842: DOUBLE
25843: LD_INT 1
25845: DEC
25846: ST_TO_ADDR
25847: LD_EXP 44
25851: PUSH
25852: FOR_TO
25853: IFFALSE 25983
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25855: LD_EXP 44
25859: PUSH
25860: LD_VAR 0 3
25864: ARRAY
25865: PUSH
25866: LD_INT 1
25868: ARRAY
25869: PUSH
25870: LD_VAR 0 1
25874: EQUAL
25875: IFFALSE 25981
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25877: LD_ADDR_VAR 0 5
25881: PUSH
25882: LD_EXP 44
25886: PUSH
25887: LD_VAR 0 3
25891: ARRAY
25892: PUSH
25893: LD_INT 2
25895: ARRAY
25896: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25897: LD_ADDR_VAR 0 6
25901: PUSH
25902: LD_EXP 44
25906: PUSH
25907: LD_VAR 0 3
25911: ARRAY
25912: PUSH
25913: LD_INT 3
25915: ARRAY
25916: PUSH
25917: LD_INT 1
25919: ARRAY
25920: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25921: LD_ADDR_VAR 0 7
25925: PUSH
25926: LD_EXP 44
25930: PUSH
25931: LD_VAR 0 3
25935: ARRAY
25936: PUSH
25937: LD_INT 3
25939: ARRAY
25940: PUSH
25941: LD_INT 2
25943: ARRAY
25944: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25945: LD_ADDR_VAR 0 4
25949: PUSH
25950: LD_VAR 0 6
25954: PPUSH
25955: LD_VAR 0 7
25959: PPUSH
25960: CALL_OW 428
25964: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
25965: LD_VAR 0 4
25969: PPUSH
25970: LD_VAR 0 5
25974: PPUSH
25975: CALL_OW 148
// break ;
25979: GO 25983
// end ;
25981: GO 25852
25983: POP
25984: POP
// end ; end ;
25985: LD_VAR 0 2
25989: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
25990: LD_INT 0
25992: PPUSH
25993: PPUSH
25994: PPUSH
25995: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
25996: LD_ADDR_VAR 0 4
26000: PUSH
26001: LD_VAR 0 1
26005: PPUSH
26006: LD_INT 32
26008: PUSH
26009: LD_INT 1
26011: PUSH
26012: EMPTY
26013: LIST
26014: LIST
26015: PPUSH
26016: CALL 11421 0 2
26020: ST_TO_ADDR
// if not tmp then
26021: LD_VAR 0 4
26025: NOT
26026: IFFALSE 26032
// exit else
26028: GO 26114
26030: GO 26114
// begin for i = 1 to tmp do
26032: LD_ADDR_VAR 0 3
26036: PUSH
26037: DOUBLE
26038: LD_INT 1
26040: DEC
26041: ST_TO_ADDR
26042: LD_VAR 0 4
26046: PUSH
26047: FOR_TO
26048: IFFALSE 26112
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26050: LD_VAR 0 4
26054: PUSH
26055: LD_VAR 0 3
26059: ARRAY
26060: PPUSH
26061: CALL_OW 261
26065: PUSH
26066: LD_INT 20
26068: LESS
26069: PUSH
26070: LD_VAR 0 4
26074: PUSH
26075: LD_VAR 0 3
26079: ARRAY
26080: PPUSH
26081: CALL_OW 110
26085: PUSH
26086: LD_INT 0
26088: EQUAL
26089: AND
26090: IFFALSE 26110
// begin SetTag ( tmp [ i ] , 21 ) ;
26092: LD_VAR 0 4
26096: PUSH
26097: LD_VAR 0 3
26101: ARRAY
26102: PPUSH
26103: LD_INT 21
26105: PPUSH
26106: CALL_OW 109
// end ;
26110: GO 26047
26112: POP
26113: POP
// end ; end ;
26114: LD_VAR 0 2
26118: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26119: LD_INT 0
26121: PPUSH
26122: PPUSH
26123: PPUSH
26124: PPUSH
26125: PPUSH
// if not unit then
26126: LD_VAR 0 1
26130: NOT
26131: IFFALSE 26135
// exit ;
26133: GO 26323
// side := GetSide ( unit ) ;
26135: LD_ADDR_VAR 0 3
26139: PUSH
26140: LD_VAR 0 1
26144: PPUSH
26145: CALL_OW 255
26149: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26150: LD_ADDR_VAR 0 5
26154: PUSH
26155: LD_VAR 0 3
26159: PPUSH
26160: LD_INT 2
26162: PUSH
26163: LD_INT 30
26165: PUSH
26166: LD_INT 1
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: PUSH
26173: LD_INT 30
26175: PUSH
26176: LD_INT 3
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 30
26185: PUSH
26186: LD_INT 29
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: LIST
26197: LIST
26198: PPUSH
26199: CALL 11421 0 2
26203: ST_TO_ADDR
// if not b then
26204: LD_VAR 0 5
26208: NOT
26209: IFFALSE 26213
// exit ;
26211: GO 26323
// if GetTag ( unit ) = 21 then
26213: LD_VAR 0 1
26217: PPUSH
26218: CALL_OW 110
26222: PUSH
26223: LD_INT 21
26225: EQUAL
26226: IFFALSE 26323
// begin c := NearestUnitToUnit ( b , unit ) ;
26228: LD_ADDR_VAR 0 6
26232: PUSH
26233: LD_VAR 0 5
26237: PPUSH
26238: LD_VAR 0 1
26242: PPUSH
26243: CALL_OW 74
26247: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26248: LD_VAR 0 1
26252: PPUSH
26253: LD_VAR 0 6
26257: PPUSH
26258: CALL_OW 250
26262: PPUSH
26263: LD_VAR 0 6
26267: PPUSH
26268: CALL_OW 251
26272: PPUSH
26273: CALL_OW 297
26277: PUSH
26278: LD_INT 6
26280: GREATER
26281: IFFALSE 26299
// ComMoveUnit ( unit , c ) else
26283: LD_VAR 0 1
26287: PPUSH
26288: LD_VAR 0 6
26292: PPUSH
26293: CALL_OW 112
26297: GO 26323
// begin SetFuel ( unit , 100 ) ;
26299: LD_VAR 0 1
26303: PPUSH
26304: LD_INT 100
26306: PPUSH
26307: CALL_OW 240
// SetTag ( unit , 0 ) ;
26311: LD_VAR 0 1
26315: PPUSH
26316: LD_INT 0
26318: PPUSH
26319: CALL_OW 109
// end ; end ; end ;
26323: LD_VAR 0 2
26327: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26328: LD_INT 0
26330: PPUSH
26331: PPUSH
26332: PPUSH
26333: PPUSH
26334: PPUSH
26335: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26336: LD_ADDR_VAR 0 7
26340: PUSH
26341: LD_VAR 0 1
26345: PPUSH
26346: LD_INT 33
26348: PUSH
26349: LD_INT 2
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: LD_INT 3
26358: PUSH
26359: LD_INT 61
26361: PUSH
26362: EMPTY
26363: LIST
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: PPUSH
26373: CALL 11421 0 2
26377: ST_TO_ADDR
// if not vehs then
26378: LD_VAR 0 7
26382: NOT
26383: IFFALSE 26387
// exit ;
26385: GO 26672
// if nation = 1 then
26387: LD_VAR 0 2
26391: PUSH
26392: LD_INT 1
26394: EQUAL
26395: IFFALSE 26565
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26397: LD_VAR 0 1
26401: PPUSH
26402: LD_INT 30
26404: PUSH
26405: LD_INT 36
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: PPUSH
26412: CALL 11421 0 2
26416: NOT
26417: IFFALSE 26423
// exit else
26419: GO 26672
26421: GO 26563
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26423: LD_ADDR_VAR 0 5
26427: PUSH
26428: LD_VAR 0 1
26432: PPUSH
26433: LD_INT 30
26435: PUSH
26436: LD_INT 36
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PPUSH
26443: CALL 11421 0 2
26447: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26448: LD_ADDR_VAR 0 6
26452: PUSH
26453: LD_VAR 0 5
26457: PUSH
26458: LD_INT 1
26460: ARRAY
26461: PPUSH
26462: CALL_OW 313
26466: ST_TO_ADDR
// for i = vehs downto 1 do
26467: LD_ADDR_VAR 0 4
26471: PUSH
26472: DOUBLE
26473: LD_VAR 0 7
26477: INC
26478: ST_TO_ADDR
26479: LD_INT 1
26481: PUSH
26482: FOR_DOWNTO
26483: IFFALSE 26561
// begin if not IsControledBy ( vehs [ i ] ) then
26485: LD_VAR 0 7
26489: PUSH
26490: LD_VAR 0 4
26494: ARRAY
26495: PPUSH
26496: CALL_OW 312
26500: NOT
26501: IFFALSE 26559
// begin tmp := MCV_RemoteDriver ( oper ) ;
26503: LD_ADDR_VAR 0 8
26507: PUSH
26508: LD_VAR 0 6
26512: PPUSH
26513: CALL 26677 0 1
26517: ST_TO_ADDR
// if not tmp then
26518: LD_VAR 0 8
26522: NOT
26523: IFFALSE 26531
// exit else
26525: POP
26526: POP
26527: GO 26672
26529: GO 26559
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26531: LD_VAR 0 7
26535: PUSH
26536: LD_VAR 0 4
26540: ARRAY
26541: PPUSH
26542: LD_VAR 0 8
26546: PUSH
26547: LD_INT 1
26549: ARRAY
26550: PUSH
26551: LD_INT 1
26553: ARRAY
26554: PPUSH
26555: CALL_OW 135
// end ; end ;
26559: GO 26482
26561: POP
26562: POP
// end ; end else
26563: GO 26672
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26565: LD_VAR 0 1
26569: PPUSH
26570: LD_INT 34
26572: PUSH
26573: LD_INT 31
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PPUSH
26580: CALL 11421 0 2
26584: NOT
26585: IFFALSE 26591
// exit else
26587: GO 26672
26589: GO 26672
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26591: LD_ADDR_VAR 0 5
26595: PUSH
26596: LD_VAR 0 1
26600: PPUSH
26601: LD_INT 34
26603: PUSH
26604: LD_INT 31
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PPUSH
26611: CALL 11421 0 2
26615: ST_TO_ADDR
// oper := [ ] ;
26616: LD_ADDR_VAR 0 6
26620: PUSH
26621: EMPTY
26622: ST_TO_ADDR
// for i = 1 to ct do
26623: LD_ADDR_VAR 0 4
26627: PUSH
26628: DOUBLE
26629: LD_INT 1
26631: DEC
26632: ST_TO_ADDR
26633: LD_VAR 0 5
26637: PUSH
26638: FOR_TO
26639: IFFALSE 26670
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26641: LD_ADDR_VAR 0 6
26645: PUSH
26646: LD_VAR 0 6
26650: PUSH
26651: LD_VAR 0 5
26655: PUSH
26656: LD_VAR 0 4
26660: ARRAY
26661: PPUSH
26662: CALL 31644 0 1
26666: ADD
26667: ST_TO_ADDR
26668: GO 26638
26670: POP
26671: POP
// end ; end ; end ;
26672: LD_VAR 0 3
26676: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26677: LD_INT 0
26679: PPUSH
26680: PPUSH
26681: PPUSH
26682: PPUSH
26683: PPUSH
26684: PPUSH
// if not drivers then
26685: LD_VAR 0 1
26689: NOT
26690: IFFALSE 26696
// exit else
26692: GO 26976
26694: GO 26976
// begin linked := [ ] ;
26696: LD_ADDR_VAR 0 5
26700: PUSH
26701: EMPTY
26702: ST_TO_ADDR
// for i = 1 to drivers do
26703: LD_ADDR_VAR 0 3
26707: PUSH
26708: DOUBLE
26709: LD_INT 1
26711: DEC
26712: ST_TO_ADDR
26713: LD_VAR 0 1
26717: PUSH
26718: FOR_TO
26719: IFFALSE 26964
// begin if CanControl ( drivers [ i ] ) then
26721: LD_VAR 0 1
26725: PUSH
26726: LD_VAR 0 3
26730: ARRAY
26731: PPUSH
26732: CALL 32216 0 1
26736: IFFALSE 26962
// if i > 1 then
26738: LD_VAR 0 3
26742: PUSH
26743: LD_INT 1
26745: GREATER
26746: IFFALSE 26923
// begin m := false ;
26748: LD_ADDR_VAR 0 6
26752: PUSH
26753: LD_INT 0
26755: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26756: LD_ADDR_VAR 0 7
26760: PUSH
26761: LD_VAR 0 1
26765: PUSH
26766: LD_VAR 0 3
26770: ARRAY
26771: PPUSH
26772: CALL_OW 432
26776: ST_TO_ADDR
// for j = 1 to linked do
26777: LD_ADDR_VAR 0 4
26781: PUSH
26782: DOUBLE
26783: LD_INT 1
26785: DEC
26786: ST_TO_ADDR
26787: LD_VAR 0 5
26791: PUSH
26792: FOR_TO
26793: IFFALSE 26867
// begin if l < linked [ j ] [ 2 ] then
26795: LD_VAR 0 7
26799: PUSH
26800: LD_VAR 0 5
26804: PUSH
26805: LD_VAR 0 4
26809: ARRAY
26810: PUSH
26811: LD_INT 2
26813: ARRAY
26814: LESS
26815: IFFALSE 26865
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26817: LD_ADDR_VAR 0 5
26821: PUSH
26822: LD_VAR 0 5
26826: PPUSH
26827: LD_INT 1
26829: PPUSH
26830: LD_VAR 0 1
26834: PUSH
26835: LD_VAR 0 3
26839: ARRAY
26840: PUSH
26841: LD_VAR 0 7
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PPUSH
26850: CALL_OW 2
26854: ST_TO_ADDR
// m := true ;
26855: LD_ADDR_VAR 0 6
26859: PUSH
26860: LD_INT 1
26862: ST_TO_ADDR
// break ;
26863: GO 26867
// end ; end ;
26865: GO 26792
26867: POP
26868: POP
// if not m then
26869: LD_VAR 0 6
26873: NOT
26874: IFFALSE 26921
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26876: LD_ADDR_VAR 0 5
26880: PUSH
26881: LD_VAR 0 5
26885: PUSH
26886: LD_VAR 0 1
26890: PUSH
26891: LD_VAR 0 3
26895: ARRAY
26896: PUSH
26897: LD_VAR 0 1
26901: PUSH
26902: LD_VAR 0 3
26906: ARRAY
26907: PPUSH
26908: CALL_OW 432
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: EMPTY
26918: LIST
26919: ADD
26920: ST_TO_ADDR
// end else
26921: GO 26962
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26923: LD_ADDR_VAR 0 5
26927: PUSH
26928: LD_VAR 0 1
26932: PUSH
26933: LD_VAR 0 3
26937: ARRAY
26938: PUSH
26939: LD_VAR 0 1
26943: PUSH
26944: LD_VAR 0 3
26948: ARRAY
26949: PPUSH
26950: CALL_OW 432
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: EMPTY
26960: LIST
26961: ST_TO_ADDR
// end ;
26962: GO 26718
26964: POP
26965: POP
// result := linked ;
26966: LD_ADDR_VAR 0 2
26970: PUSH
26971: LD_VAR 0 5
26975: ST_TO_ADDR
// end ; end ;
26976: LD_VAR 0 2
26980: RET
// export function MCV_ToRepair ( unit ) ; begin
26981: LD_INT 0
26983: PPUSH
// if not unit then
26984: LD_VAR 0 1
26988: NOT
26989: IFFALSE 26995
// exit else
26991: GO 27026
26993: GO 27026
// begin SetTag ( unit , 6 ) ;
26995: LD_VAR 0 1
26999: PPUSH
27000: LD_INT 6
27002: PPUSH
27003: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27007: LD_VAR 0 1
27011: PPUSH
27012: CALL_OW 255
27016: PPUSH
27017: LD_VAR 0 1
27021: PPUSH
27022: CALL 25582 0 2
// end ; end ;
27026: LD_VAR 0 2
27030: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27031: LD_INT 0
27033: PPUSH
27034: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27035: LD_VAR 0 1
27039: PPUSH
27040: LD_INT 6
27042: PPUSH
27043: EMPTY
27044: PPUSH
27045: CALL 12124 0 3
27049: IFFALSE 27142
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27051: LD_ADDR_VAR 0 3
27055: PUSH
27056: DOUBLE
27057: LD_VAR 0 1
27061: PPUSH
27062: LD_INT 6
27064: PPUSH
27065: EMPTY
27066: PPUSH
27067: CALL 12124 0 3
27071: INC
27072: ST_TO_ADDR
27073: LD_INT 1
27075: PUSH
27076: FOR_DOWNTO
27077: IFFALSE 27140
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27079: LD_VAR 0 1
27083: PPUSH
27084: LD_INT 6
27086: PPUSH
27087: EMPTY
27088: PPUSH
27089: CALL 12124 0 3
27093: PUSH
27094: LD_VAR 0 3
27098: ARRAY
27099: PPUSH
27100: CALL_OW 256
27104: PUSH
27105: LD_INT 1000
27107: EQUAL
27108: IFFALSE 27138
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27110: LD_VAR 0 1
27114: PPUSH
27115: LD_INT 6
27117: PPUSH
27118: EMPTY
27119: PPUSH
27120: CALL 12124 0 3
27124: PUSH
27125: LD_VAR 0 3
27129: ARRAY
27130: PPUSH
27131: LD_INT 0
27133: PPUSH
27134: CALL_OW 109
27138: GO 27076
27140: POP
27141: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27142: LD_VAR 0 1
27146: PPUSH
27147: LD_INT 10
27149: PPUSH
27150: EMPTY
27151: PPUSH
27152: CALL 12124 0 3
27156: IFFALSE 27273
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27158: LD_ADDR_VAR 0 3
27162: PUSH
27163: DOUBLE
27164: LD_VAR 0 1
27168: PPUSH
27169: LD_INT 10
27171: PPUSH
27172: EMPTY
27173: PPUSH
27174: CALL 12124 0 3
27178: INC
27179: ST_TO_ADDR
27180: LD_INT 1
27182: PUSH
27183: FOR_DOWNTO
27184: IFFALSE 27271
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27186: LD_VAR 0 1
27190: PPUSH
27191: LD_INT 10
27193: PPUSH
27194: EMPTY
27195: PPUSH
27196: CALL 12124 0 3
27200: PUSH
27201: LD_VAR 0 3
27205: ARRAY
27206: PPUSH
27207: CALL_OW 302
27211: NOT
27212: PUSH
27213: LD_VAR 0 1
27217: PPUSH
27218: LD_INT 10
27220: PPUSH
27221: EMPTY
27222: PPUSH
27223: CALL 12124 0 3
27227: PUSH
27228: LD_VAR 0 3
27232: ARRAY
27233: PPUSH
27234: CALL_OW 301
27238: OR
27239: IFFALSE 27269
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27241: LD_VAR 0 1
27245: PPUSH
27246: LD_INT 10
27248: PPUSH
27249: EMPTY
27250: PPUSH
27251: CALL 12124 0 3
27255: PUSH
27256: LD_VAR 0 3
27260: ARRAY
27261: PPUSH
27262: LD_INT 0
27264: PPUSH
27265: CALL_OW 109
27269: GO 27183
27271: POP
27272: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27273: LD_ADDR_VAR 0 3
27277: PUSH
27278: LD_VAR 0 1
27282: PPUSH
27283: EMPTY
27284: PPUSH
27285: CALL 11722 0 2
27289: PUSH
27290: LD_VAR 0 1
27294: PPUSH
27295: LD_INT 7
27297: PPUSH
27298: EMPTY
27299: PPUSH
27300: CALL 12124 0 3
27304: DIFF
27305: PUSH
27306: FOR_IN
27307: IFFALSE 27351
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27309: LD_VAR 0 3
27313: PPUSH
27314: CALL_OW 256
27318: PUSH
27319: LD_INT 650
27321: LESS
27322: PUSH
27323: LD_VAR 0 3
27327: PPUSH
27328: CALL_OW 110
27332: PUSH
27333: LD_INT 6
27335: EQUAL
27336: NOT
27337: AND
27338: IFFALSE 27349
// MCV_ToRepair ( i ) ;
27340: LD_VAR 0 3
27344: PPUSH
27345: CALL 26981 0 1
27349: GO 27306
27351: POP
27352: POP
// end ; end_of_file end_of_file
27353: LD_VAR 0 2
27357: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27358: LD_STRING SAILEvent [
27360: PUSH
27361: LD_VAR 0 1
27365: STR
27366: PUSH
27367: LD_STRING ]
27369: STR
27370: PPUSH
27371: CALL 7818 0 1
// if event = 101 and dialog_north then
27375: LD_VAR 0 1
27379: PUSH
27380: LD_INT 101
27382: EQUAL
27383: PUSH
27384: LD_EXP 5
27388: AND
27389: IFFALSE 27453
// begin dialog_north := false ;
27391: LD_ADDR_EXP 5
27395: PUSH
27396: LD_INT 0
27398: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27399: LD_EXP 4
27403: PPUSH
27404: LD_STRING DS1
27406: PUSH
27407: LD_STRING DS2
27409: PUSH
27410: LD_STRING DS3
27412: PUSH
27413: LD_STRING DS6
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 1
27424: PPUSH
27425: LD_INT 4
27427: PPUSH
27428: CALL_OW 12
27432: ARRAY
27433: PPUSH
27434: CALL_OW 94
// Wait ( 4 4$00 ) ;
27438: LD_INT 8400
27440: PPUSH
27441: CALL_OW 67
// dialog_north := true ;
27445: LD_ADDR_EXP 5
27449: PUSH
27450: LD_INT 1
27452: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27453: LD_VAR 0 1
27457: PUSH
27458: LD_INT 102
27460: EQUAL
27461: PUSH
27462: LD_EXP 6
27466: AND
27467: IFFALSE 27527
// begin dialog_south := false ;
27469: LD_ADDR_EXP 6
27473: PUSH
27474: LD_INT 0
27476: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27477: LD_EXP 3
27481: PPUSH
27482: LD_STRING DJ1
27484: PUSH
27485: LD_STRING DJ4
27487: PUSH
27488: LD_STRING DJ6
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 1
27498: PPUSH
27499: LD_INT 3
27501: PPUSH
27502: CALL_OW 12
27506: ARRAY
27507: PPUSH
27508: CALL_OW 94
// Wait ( 4 4$00 ) ;
27512: LD_INT 8400
27514: PPUSH
27515: CALL_OW 67
// dialog_south := true ;
27519: LD_ADDR_EXP 6
27523: PUSH
27524: LD_INT 1
27526: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27527: LD_VAR 0 1
27531: PUSH
27532: LD_INT 104
27534: EQUAL
27535: PUSH
27536: LD_EXP 7
27540: AND
27541: IFFALSE 27563
// begin dialog_popov := false ;
27543: LD_ADDR_EXP 7
27547: PUSH
27548: LD_INT 0
27550: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27551: LD_EXP 25
27555: PPUSH
27556: LD_STRING DR4
27558: PPUSH
27559: CALL_OW 94
// end ; end ;
27563: PPOPN 1
27565: END
// on BuildingStarted ( b , unit ) do var side , i ;
27566: LD_INT 0
27568: PPUSH
27569: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27570: LD_EXP 40
27574: PUSH
27575: LD_VAR 0 1
27579: PPUSH
27580: CALL_OW 255
27584: ARRAY
27585: IFFALSE 27763
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27587: LD_STRING BuildingStarted [side: 
27589: PUSH
27590: LD_VAR 0 1
27594: PPUSH
27595: CALL_OW 255
27599: STR
27600: PUSH
27601: LD_STRING ; btype: 
27603: STR
27604: PUSH
27605: LD_VAR 0 1
27609: PPUSH
27610: CALL_OW 266
27614: STR
27615: PUSH
27616: LD_STRING ; unit: 
27618: STR
27619: PUSH
27620: LD_VAR 0 2
27624: STR
27625: PUSH
27626: LD_STRING ]
27628: STR
27629: PPUSH
27630: CALL 7818 0 1
// side := GetSide ( b ) ;
27634: LD_ADDR_VAR 0 3
27638: PUSH
27639: LD_VAR 0 1
27643: PPUSH
27644: CALL_OW 255
27648: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27649: LD_VAR 0 3
27653: PPUSH
27654: LD_INT 21
27656: PUSH
27657: LD_INT 3
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PPUSH
27664: CALL 11421 0 2
27668: PUSH
27669: LD_INT 1
27671: EQUAL
27672: IFFALSE 27763
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27674: LD_ADDR_VAR 0 4
27678: PUSH
27679: LD_VAR 0 3
27683: PPUSH
27684: LD_INT 21
27686: PUSH
27687: LD_INT 1
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PPUSH
27694: CALL 11421 0 2
27698: PUSH
27699: LD_VAR 0 3
27703: PPUSH
27704: LD_INT 2
27706: PPUSH
27707: EMPTY
27708: PPUSH
27709: CALL 11504 0 3
27713: DIFF
27714: PUSH
27715: FOR_IN
27716: IFFALSE 27761
// if not HasTask ( i ) then
27718: LD_VAR 0 4
27722: PPUSH
27723: CALL_OW 314
27727: NOT
27728: IFFALSE 27759
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27730: LD_VAR 0 4
27734: PPUSH
27735: LD_VAR 0 1
27739: PPUSH
27740: CALL_OW 250
27744: PPUSH
27745: LD_VAR 0 1
27749: PPUSH
27750: CALL_OW 251
27754: PPUSH
27755: CALL_OW 111
27759: GO 27715
27761: POP
27762: POP
// end ;
27763: PPOPN 4
27765: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27766: LD_EXP 40
27770: PUSH
27771: LD_VAR 0 1
27775: PPUSH
27776: CALL_OW 255
27780: ARRAY
27781: IFFALSE 28150
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27783: LD_STRING BuildingComplete [side: 
27785: PUSH
27786: LD_VAR 0 1
27790: PPUSH
27791: CALL_OW 255
27795: STR
27796: PUSH
27797: LD_STRING ; btype: 
27799: STR
27800: PUSH
27801: LD_VAR 0 1
27805: PPUSH
27806: CALL_OW 266
27810: STR
27811: PUSH
27812: LD_STRING ]
27814: STR
27815: PPUSH
27816: CALL 7818 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27820: LD_ADDR_EXP 47
27824: PUSH
27825: LD_EXP 47
27829: PPUSH
27830: LD_VAR 0 1
27834: PPUSH
27835: CALL_OW 255
27839: PPUSH
27840: LD_VAR 0 1
27844: PPUSH
27845: CALL_OW 266
27849: PPUSH
27850: LD_VAR 0 1
27854: PPUSH
27855: CALL_OW 250
27859: PUSH
27860: LD_VAR 0 1
27864: PPUSH
27865: CALL_OW 251
27869: PUSH
27870: LD_VAR 0 1
27874: PPUSH
27875: CALL_OW 254
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: LIST
27884: PPUSH
27885: CALL 42323 0 4
27889: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27890: LD_VAR 0 1
27894: PPUSH
27895: CALL_OW 266
27899: PUSH
27900: LD_INT 6
27902: EQUAL
27903: IFFALSE 27937
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27905: LD_ADDR_EXP 41
27909: PUSH
27910: LD_EXP 41
27914: PPUSH
27915: LD_VAR 0 1
27919: PPUSH
27920: CALL_OW 255
27924: PPUSH
27925: LD_VAR 0 1
27929: PPUSH
27930: EMPTY
27931: PPUSH
27932: CALL 42232 0 4
27936: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27937: LD_VAR 0 1
27941: PPUSH
27942: CALL_OW 266
27946: PUSH
27947: LD_INT 0
27949: EQUAL
27950: IFFALSE 28060
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
27952: LD_ADDR_EXP 49
27956: PUSH
27957: LD_EXP 49
27961: PPUSH
27962: LD_VAR 0 1
27966: PPUSH
27967: CALL_OW 255
27971: PPUSH
27972: LD_INT 0
27974: PPUSH
27975: EMPTY
27976: PPUSH
27977: CALL 42232 0 4
27981: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
27982: LD_VAR 0 1
27986: PPUSH
27987: CALL_OW 274
27991: PPUSH
27992: LD_INT 1
27994: PPUSH
27995: LD_EXP 73
27999: PUSH
28000: LD_INT 1
28002: ARRAY
28003: PPUSH
28004: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28008: LD_VAR 0 1
28012: PPUSH
28013: CALL_OW 274
28017: PPUSH
28018: LD_INT 2
28020: PPUSH
28021: LD_EXP 73
28025: PUSH
28026: LD_INT 2
28028: ARRAY
28029: PPUSH
28030: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28034: LD_VAR 0 1
28038: PPUSH
28039: CALL_OW 274
28043: PPUSH
28044: LD_INT 3
28046: PPUSH
28047: LD_EXP 73
28051: PUSH
28052: LD_INT 3
28054: ARRAY
28055: PPUSH
28056: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28060: LD_VAR 0 1
28064: PPUSH
28065: CALL_OW 266
28069: PUSH
28070: LD_INT 2
28072: EQUAL
28073: IFFALSE 28105
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28075: LD_ADDR_EXP 49
28079: PUSH
28080: LD_EXP 49
28084: PPUSH
28085: LD_VAR 0 1
28089: PPUSH
28090: CALL_OW 255
28094: PPUSH
28095: LD_INT 2
28097: PPUSH
28098: EMPTY
28099: PPUSH
28100: CALL 42232 0 4
28104: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28105: LD_VAR 0 1
28109: PPUSH
28110: CALL_OW 266
28114: PUSH
28115: LD_INT 4
28117: EQUAL
28118: IFFALSE 28150
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28120: LD_ADDR_EXP 49
28124: PUSH
28125: LD_EXP 49
28129: PPUSH
28130: LD_VAR 0 1
28134: PPUSH
28135: CALL_OW 255
28139: PPUSH
28140: LD_INT 4
28142: PPUSH
28143: EMPTY
28144: PPUSH
28145: CALL 42232 0 4
28149: ST_TO_ADDR
// end ;
28150: PPOPN 1
28152: END
// on ResearchComplete ( tech , lab ) do var i ;
28153: LD_INT 0
28155: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28156: LD_EXP 40
28160: PUSH
28161: LD_VAR 0 2
28165: PPUSH
28166: CALL_OW 255
28170: ARRAY
28171: IFFALSE 28455
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28173: LD_STRING ResearchComplete [side: 
28175: PUSH
28176: LD_VAR 0 2
28180: PPUSH
28181: CALL_OW 255
28185: PPUSH
28186: CALL_OW 255
28190: STR
28191: PUSH
28192: LD_STRING ; tech:
28194: STR
28195: PUSH
28196: LD_VAR 0 1
28200: STR
28201: PUSH
28202: LD_STRING ]
28204: STR
28205: PPUSH
28206: CALL 7818 0 1
// for i = 1 to MREG_ToRes do
28210: LD_ADDR_VAR 0 3
28214: PUSH
28215: DOUBLE
28216: LD_INT 1
28218: DEC
28219: ST_TO_ADDR
28220: LD_EXP 51
28224: PUSH
28225: FOR_TO
28226: IFFALSE 28313
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28228: LD_EXP 51
28232: PUSH
28233: LD_VAR 0 3
28237: ARRAY
28238: PUSH
28239: LD_INT 1
28241: ARRAY
28242: PUSH
28243: LD_VAR 0 2
28247: PPUSH
28248: CALL_OW 255
28252: EQUAL
28253: PUSH
28254: LD_EXP 51
28258: PUSH
28259: LD_VAR 0 3
28263: ARRAY
28264: PUSH
28265: LD_INT 2
28267: ARRAY
28268: PUSH
28269: LD_VAR 0 1
28273: EQUAL
28274: AND
28275: IFFALSE 28311
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28277: LD_ADDR_EXP 51
28281: PUSH
28282: LD_EXP 51
28286: PPUSH
28287: LD_VAR 0 2
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_VAR 0 1
28301: PPUSH
28302: EMPTY
28303: PPUSH
28304: CALL 42323 0 4
28308: ST_TO_ADDR
// break ;
28309: GO 28313
// end ;
28311: GO 28225
28313: POP
28314: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28315: LD_VAR 0 1
28319: PUSH
28320: LD_INT 2
28322: PUSH
28323: LD_INT 11
28325: PUSH
28326: LD_INT 4
28328: PUSH
28329: LD_INT 3
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: IN
28338: IFFALSE 28455
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28340: LD_ADDR_VAR 0 3
28344: PUSH
28345: LD_VAR 0 2
28349: PPUSH
28350: CALL_OW 255
28354: PPUSH
28355: LD_INT 16
28357: PPUSH
28358: LD_INT 25
28360: PUSH
28361: LD_INT 4
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: PPUSH
28368: CALL 12124 0 3
28372: ST_TO_ADDR
// if i then
28373: LD_VAR 0 3
28377: IFFALSE 28395
// SetTag ( i [ 1 ] , 0 ) ;
28379: LD_VAR 0 3
28383: PUSH
28384: LD_INT 1
28386: ARRAY
28387: PPUSH
28388: LD_INT 0
28390: PPUSH
28391: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28395: LD_ADDR_VAR 0 3
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: PPUSH
28410: LD_INT 171
28412: PPUSH
28413: EMPTY
28414: PPUSH
28415: CALL 12124 0 3
28419: ST_TO_ADDR
// if i then
28420: LD_VAR 0 3
28424: IFFALSE 28455
// begin SetTag ( i [ 1 ] , 0 ) ;
28426: LD_VAR 0 3
28430: PUSH
28431: LD_INT 1
28433: ARRAY
28434: PPUSH
28435: LD_INT 0
28437: PPUSH
28438: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28442: LD_VAR 0 3
28446: PUSH
28447: LD_INT 1
28449: ARRAY
28450: PPUSH
28451: CALL_OW 122
// end ; end ; end ;
28455: PPOPN 3
28457: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28458: LD_INT 0
28460: PPUSH
28461: PPUSH
28462: PPUSH
28463: PPUSH
28464: PPUSH
28465: PPUSH
28466: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28467: LD_EXP 40
28471: PUSH
28472: LD_VAR 0 2
28476: PPUSH
28477: CALL_OW 255
28481: ARRAY
28482: IFFALSE 29209
// begin side := GetSide ( veh ) ;
28484: LD_ADDR_VAR 0 4
28488: PUSH
28489: LD_VAR 0 1
28493: PPUSH
28494: CALL_OW 255
28498: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28499: LD_ADDR_VAR 0 6
28503: PUSH
28504: LD_VAR 0 1
28508: PPUSH
28509: CALL_OW 265
28513: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28514: LD_ADDR_VAR 0 7
28518: PUSH
28519: LD_VAR 0 1
28523: PPUSH
28524: CALL_OW 262
28528: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28529: LD_ADDR_VAR 0 8
28533: PUSH
28534: LD_VAR 0 1
28538: PPUSH
28539: CALL_OW 263
28543: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28544: LD_ADDR_VAR 0 9
28548: PUSH
28549: LD_VAR 0 1
28553: PPUSH
28554: CALL_OW 264
28558: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28559: LD_STRING VehicleConstructed [side: 
28561: PUSH
28562: LD_VAR 0 4
28566: STR
28567: PUSH
28568: LD_STRING ; id:
28570: STR
28571: PUSH
28572: LD_VAR 0 1
28576: STR
28577: PUSH
28578: LD_STRING ; components: [
28580: STR
28581: PUSH
28582: LD_VAR 0 6
28586: STR
28587: PUSH
28588: LD_STRING , 
28590: STR
28591: PUSH
28592: LD_VAR 0 7
28596: STR
28597: PUSH
28598: LD_STRING , 
28600: STR
28601: PUSH
28602: LD_VAR 0 8
28606: STR
28607: PUSH
28608: LD_STRING , 
28610: STR
28611: PUSH
28612: LD_VAR 0 9
28616: STR
28617: PUSH
28618: LD_STRING ]]
28620: STR
28621: PPUSH
28622: CALL 7818 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28626: LD_VAR 0 1
28630: PPUSH
28631: CALL_OW 264
28635: PUSH
28636: LD_INT 13
28638: PUSH
28639: LD_INT 12
28641: PUSH
28642: LD_INT 14
28644: PUSH
28645: LD_INT 51
28647: PUSH
28648: LD_INT 53
28650: PUSH
28651: LD_INT 52
28653: PUSH
28654: LD_INT 32
28656: PUSH
28657: EMPTY
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: LIST
28665: IN
28666: NOT
28667: IFFALSE 28709
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28669: LD_ADDR_EXP 60
28673: PUSH
28674: LD_EXP 60
28678: PPUSH
28679: LD_VAR 0 4
28683: PPUSH
28684: LD_EXP 60
28688: PUSH
28689: LD_VAR 0 4
28693: ARRAY
28694: PUSH
28695: LD_INT 1
28697: PLUS
28698: PPUSH
28699: LD_VAR 0 1
28703: PPUSH
28704: CALL 30950 0 4
28708: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28709: LD_VAR 0 1
28713: PPUSH
28714: CALL_OW 264
28718: PUSH
28719: LD_INT 31
28721: EQUAL
28722: IFFALSE 28741
// SetTag ( GetDriver ( veh ) , 9 ) ;
28724: LD_VAR 0 1
28728: PPUSH
28729: CALL 31644 0 1
28733: PPUSH
28734: LD_INT 9
28736: PPUSH
28737: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28741: LD_VAR 0 1
28745: PPUSH
28746: CALL_OW 264
28750: PUSH
28751: LD_INT 14
28753: PUSH
28754: LD_INT 53
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: IN
28761: IFFALSE 28798
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28763: LD_ADDR_EXP 43
28767: PUSH
28768: LD_EXP 43
28772: PPUSH
28773: LD_VAR 0 1
28777: PPUSH
28778: CALL_OW 255
28782: PPUSH
28783: LD_INT 2
28785: PPUSH
28786: LD_VAR 0 1
28790: PPUSH
28791: CALL 30950 0 4
28795: ST_TO_ADDR
// exit ;
28796: GO 29209
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28798: LD_VAR 0 1
28802: PPUSH
28803: CALL_OW 265
28807: PUSH
28808: LD_EXP 67
28812: PUSH
28813: LD_VAR 0 4
28817: ARRAY
28818: PUSH
28819: LD_INT 1
28821: ARRAY
28822: IN
28823: PUSH
28824: LD_VAR 0 1
28828: PPUSH
28829: CALL_OW 262
28833: PUSH
28834: LD_EXP 67
28838: PUSH
28839: LD_VAR 0 4
28843: ARRAY
28844: PUSH
28845: LD_INT 1
28847: ARRAY
28848: IN
28849: AND
28850: PUSH
28851: LD_VAR 0 1
28855: PPUSH
28856: CALL_OW 263
28860: PUSH
28861: LD_EXP 67
28865: PUSH
28866: LD_VAR 0 4
28870: ARRAY
28871: PUSH
28872: LD_INT 1
28874: ARRAY
28875: IN
28876: AND
28877: PUSH
28878: LD_VAR 0 1
28882: PPUSH
28883: CALL_OW 264
28887: PUSH
28888: LD_EXP 67
28892: PUSH
28893: LD_VAR 0 4
28897: ARRAY
28898: PUSH
28899: LD_INT 1
28901: ARRAY
28902: IN
28903: AND
28904: IFFALSE 28948
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28906: LD_ADDR_EXP 68
28910: PUSH
28911: LD_EXP 68
28915: PPUSH
28916: LD_VAR 0 4
28920: PPUSH
28921: LD_EXP 68
28925: PUSH
28926: LD_VAR 0 4
28930: ARRAY
28931: PUSH
28932: LD_INT 1
28934: PLUS
28935: PPUSH
28936: LD_VAR 0 1
28940: PPUSH
28941: CALL 30950 0 4
28945: ST_TO_ADDR
// exit ;
28946: GO 29209
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
28948: LD_VAR 0 6
28952: PUSH
28953: LD_EXP 70
28957: PUSH
28958: LD_VAR 0 4
28962: ARRAY
28963: PUSH
28964: LD_INT 1
28966: ARRAY
28967: EQUAL
28968: PUSH
28969: LD_VAR 0 7
28973: PUSH
28974: LD_EXP 70
28978: PUSH
28979: LD_VAR 0 4
28983: ARRAY
28984: PUSH
28985: LD_INT 2
28987: ARRAY
28988: EQUAL
28989: AND
28990: PUSH
28991: LD_VAR 0 8
28995: PUSH
28996: LD_EXP 70
29000: PUSH
29001: LD_VAR 0 4
29005: ARRAY
29006: PUSH
29007: LD_INT 3
29009: ARRAY
29010: EQUAL
29011: AND
29012: PUSH
29013: LD_VAR 0 9
29017: PUSH
29018: LD_EXP 70
29022: PUSH
29023: LD_VAR 0 4
29027: ARRAY
29028: PUSH
29029: LD_INT 4
29031: ARRAY
29032: EQUAL
29033: AND
29034: IFFALSE 29190
// begin tmp := MREG_ToAttack [ side ] ;
29036: LD_ADDR_VAR 0 5
29040: PUSH
29041: LD_EXP 70
29045: PUSH
29046: LD_VAR 0 4
29050: ARRAY
29051: ST_TO_ADDR
// for i = 1 to 4 do
29052: LD_ADDR_VAR 0 3
29056: PUSH
29057: DOUBLE
29058: LD_INT 1
29060: DEC
29061: ST_TO_ADDR
29062: LD_INT 4
29064: PUSH
29065: FOR_TO
29066: IFFALSE 29088
// tmp := Delete ( tmp , 1 ) ;
29068: LD_ADDR_VAR 0 5
29072: PUSH
29073: LD_VAR 0 5
29077: PPUSH
29078: LD_INT 1
29080: PPUSH
29081: CALL_OW 3
29085: ST_TO_ADDR
29086: GO 29065
29088: POP
29089: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29090: LD_ADDR_EXP 70
29094: PUSH
29095: LD_EXP 70
29099: PPUSH
29100: LD_VAR 0 4
29104: PPUSH
29105: LD_VAR 0 5
29109: PPUSH
29110: CALL_OW 1
29114: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29115: LD_ADDR_EXP 72
29119: PUSH
29120: LD_EXP 72
29124: PPUSH
29125: LD_VAR 0 4
29129: PPUSH
29130: LD_EXP 72
29134: PUSH
29135: LD_VAR 0 4
29139: ARRAY
29140: PUSH
29141: LD_INT 1
29143: PLUS
29144: PPUSH
29145: LD_VAR 0 1
29149: PPUSH
29150: CALL 30950 0 4
29154: ST_TO_ADDR
// if tmp = 0 then
29155: LD_VAR 0 5
29159: PUSH
29160: LD_INT 0
29162: EQUAL
29163: IFFALSE 29188
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29165: LD_ADDR_EXP 70
29169: PUSH
29170: LD_EXP 70
29174: PPUSH
29175: LD_VAR 0 4
29179: PPUSH
29180: LD_INT 0
29182: PPUSH
29183: CALL_OW 1
29187: ST_TO_ADDR
// exit ;
29188: GO 29209
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29190: LD_VAR 0 1
29194: PPUSH
29195: CALL_OW 255
29199: PPUSH
29200: LD_VAR 0 1
29204: PPUSH
29205: CALL 25582 0 2
// end ;
29209: PPOPN 9
29211: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29212: LD_EXP 40
29216: PUSH
29217: LD_VAR 0 2
29221: PPUSH
29222: CALL_OW 255
29226: ARRAY
29227: IFFALSE 29459
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29229: LD_STRING ApemanTamed [side: 
29231: PUSH
29232: LD_VAR 0 2
29236: PPUSH
29237: CALL_OW 255
29241: STR
29242: PUSH
29243: LD_STRING ; sci: 
29245: STR
29246: PUSH
29247: LD_VAR 0 2
29251: STR
29252: PUSH
29253: LD_STRING ; ape: 
29255: STR
29256: PUSH
29257: LD_VAR 0 1
29261: STR
29262: PUSH
29263: LD_STRING ]
29265: STR
29266: PPUSH
29267: CALL 7818 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29271: LD_INT 11
29273: PPUSH
29274: LD_VAR 0 2
29278: PPUSH
29279: CALL_OW 255
29283: PPUSH
29284: CALL_OW 321
29288: PUSH
29289: LD_INT 2
29291: EQUAL
29292: NOT
29293: PUSH
29294: LD_INT 2
29296: PPUSH
29297: LD_VAR 0 2
29301: PPUSH
29302: CALL_OW 255
29306: PPUSH
29307: CALL_OW 321
29311: PUSH
29312: LD_INT 2
29314: EQUAL
29315: NOT
29316: OR
29317: PUSH
29318: LD_VAR 0 2
29322: PPUSH
29323: CALL_OW 255
29327: PPUSH
29328: LD_INT 171
29330: PPUSH
29331: EMPTY
29332: PPUSH
29333: CALL 12124 0 3
29337: PUSH
29338: LD_INT 0
29340: EQUAL
29341: AND
29342: IFFALSE 29356
// begin SetTag ( ape , 171 ) ;
29344: LD_VAR 0 1
29348: PPUSH
29349: LD_INT 171
29351: PPUSH
29352: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29356: LD_VAR 0 2
29360: PPUSH
29361: CALL_OW 255
29365: PPUSH
29366: LD_INT 30
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PPUSH
29376: CALL 11421 0 2
29380: IFFALSE 29459
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29382: LD_VAR 0 1
29386: PPUSH
29387: LD_VAR 0 2
29391: PPUSH
29392: CALL_OW 255
29396: PPUSH
29397: LD_INT 30
29399: PUSH
29400: LD_INT 1
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PPUSH
29407: CALL 11421 0 2
29411: PUSH
29412: LD_INT 1
29414: ARRAY
29415: PPUSH
29416: CALL_OW 250
29420: PPUSH
29421: LD_VAR 0 2
29425: PPUSH
29426: CALL_OW 255
29430: PPUSH
29431: LD_INT 30
29433: PUSH
29434: LD_INT 1
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PPUSH
29441: CALL 11421 0 2
29445: PUSH
29446: LD_INT 1
29448: ARRAY
29449: PPUSH
29450: CALL_OW 251
29454: PPUSH
29455: CALL_OW 111
// end ;
29459: PPOPN 2
29461: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29462: LD_EXP 40
29466: PUSH
29467: LD_VAR 0 1
29471: PPUSH
29472: CALL_OW 255
29476: ARRAY
29477: IFFALSE 29755
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29479: LD_VAR 0 2
29483: PUSH
29484: LD_VAR 0 2
29488: PPUSH
29489: CALL_OW 255
29493: PPUSH
29494: CALL 11834 0 1
29498: IN
29499: IFFALSE 29640
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29501: LD_VAR 0 1
29505: PPUSH
29506: CALL_OW 266
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: IN
29521: IFFALSE 29551
// begin Wait ( 0 0$0.3 ) ;
29523: LD_INT 10
29525: PPUSH
29526: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29530: LD_VAR 0 2
29534: PPUSH
29535: LD_INT 16
29537: PPUSH
29538: CALL_OW 336
// ComExitBuilding ( un ) ;
29542: LD_VAR 0 2
29546: PPUSH
29547: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29551: LD_VAR 0 1
29555: PPUSH
29556: CALL_OW 266
29560: PUSH
29561: LD_INT 4
29563: PUSH
29564: LD_INT 5
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: IN
29571: IFFALSE 29640
// begin Wait ( 0 0$0.3 ) ;
29573: LD_INT 10
29575: PPUSH
29576: CALL_OW 67
// if GetTag ( un ) = 0 then
29580: LD_VAR 0 2
29584: PPUSH
29585: CALL_OW 110
29589: PUSH
29590: LD_INT 0
29592: EQUAL
29593: IFFALSE 29609
// SetClass ( un , class_apeman_soldier ) else
29595: LD_VAR 0 2
29599: PPUSH
29600: LD_INT 15
29602: PPUSH
29603: CALL_OW 336
29607: GO 29640
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29609: LD_INT 3
29611: PPUSH
29612: LD_VAR 0 2
29616: PPUSH
29617: CALL_OW 255
29621: PPUSH
29622: CALL_OW 321
29626: IFFALSE 29640
// SetClass ( un , class_apeman_kamikaze ) ;
29628: LD_VAR 0 2
29632: PPUSH
29633: LD_INT 17
29635: PPUSH
29636: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29640: LD_VAR 0 1
29644: PPUSH
29645: CALL_OW 266
29649: PUSH
29650: LD_INT 32
29652: EQUAL
29653: IFFALSE 29755
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29655: LD_ADDR_EXP 69
29659: PUSH
29660: LD_EXP 69
29664: PPUSH
29665: LD_VAR 0 1
29669: PPUSH
29670: CALL_OW 255
29674: PPUSH
29675: LD_EXP 69
29679: PUSH
29680: LD_VAR 0 1
29684: PPUSH
29685: CALL_OW 255
29689: ARRAY
29690: PUSH
29691: LD_INT 1
29693: PLUS
29694: PPUSH
29695: LD_VAR 0 1
29699: PPUSH
29700: CALL 30950 0 4
29704: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29705: LD_ADDR_EXP 69
29709: PUSH
29710: LD_EXP 69
29714: PPUSH
29715: LD_VAR 0 1
29719: PPUSH
29720: CALL_OW 255
29724: PPUSH
29725: LD_EXP 69
29729: PUSH
29730: LD_VAR 0 1
29734: PPUSH
29735: CALL_OW 255
29739: ARRAY
29740: PUSH
29741: LD_INT 1
29743: PLUS
29744: PPUSH
29745: LD_VAR 0 2
29749: PPUSH
29750: CALL 30950 0 4
29754: ST_TO_ADDR
// end ; end ;
29755: PPOPN 2
29757: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29758: LD_VAR 0 1
29762: PUSH
29763: LD_INT 22
29765: PUSH
29766: LD_INT 3
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 23
29775: PUSH
29776: LD_INT 3
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 21
29785: PUSH
29786: LD_INT 1
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: LIST
29797: PPUSH
29798: CALL_OW 69
29802: IN
29803: IFFALSE 29819
// player_loss := player_loss + 1 ;
29805: LD_ADDR_EXP 9
29809: PUSH
29810: LD_EXP 9
29814: PUSH
29815: LD_INT 1
29817: PLUS
29818: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29819: LD_VAR 0 1
29823: PUSH
29824: LD_INT 22
29826: PUSH
29827: LD_INT 1
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: PUSH
29834: LD_INT 21
29836: PUSH
29837: LD_INT 3
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: PUSH
29844: EMPTY
29845: LIST
29846: LIST
29847: PPUSH
29848: CALL_OW 69
29852: IN
29853: PUSH
29854: LD_EXP 14
29858: NOT
29859: AND
29860: IFFALSE 29923
// begin alfa_north_triggered := true ;
29862: LD_ADDR_EXP 14
29866: PUSH
29867: LD_INT 1
29869: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29870: LD_EXP 4
29874: PPUSH
29875: LD_STRING DS4
29877: PPUSH
29878: CALL_OW 94
// Wait ( 1 1$25 ) ;
29882: LD_INT 2975
29884: PPUSH
29885: CALL_OW 67
// if not isTest then
29889: LD_EXP 1
29893: NOT
29894: IFFALSE 29923
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29896: LD_INT 20
29898: PPUSH
29899: LD_INT 5
29901: PUSH
29902: LD_INT 6
29904: PUSH
29905: LD_INT 7
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: LIST
29912: PUSH
29913: LD_OWVAR 67
29917: ARRAY
29918: PPUSH
29919: CALL 6956 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
29923: LD_VAR 0 1
29927: PUSH
29928: LD_INT 22
29930: PUSH
29931: LD_INT 4
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 21
29940: PUSH
29941: LD_INT 3
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PPUSH
29952: CALL_OW 69
29956: IN
29957: PUSH
29958: LD_EXP 15
29962: NOT
29963: AND
29964: IFFALSE 30027
// begin alfa_south_triggered := true ;
29966: LD_ADDR_EXP 15
29970: PUSH
29971: LD_INT 1
29973: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
29974: LD_EXP 3
29978: PPUSH
29979: LD_STRING DJ3
29981: PPUSH
29982: CALL_OW 94
// Wait ( 0 0$45 ) ;
29986: LD_INT 1575
29988: PPUSH
29989: CALL_OW 67
// if not isTest then
29993: LD_EXP 1
29997: NOT
29998: IFFALSE 30027
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30000: LD_INT 20
30002: PPUSH
30003: LD_INT 5
30005: PUSH
30006: LD_INT 6
30008: PUSH
30009: LD_INT 7
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: LIST
30016: PUSH
30017: LD_OWVAR 67
30021: ARRAY
30022: PPUSH
30023: CALL 6956 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30027: LD_VAR 0 1
30031: PPUSH
30032: CALL_OW 266
30036: PUSH
30037: LD_INT 1
30039: EQUAL
30040: PUSH
30041: LD_VAR 0 1
30045: PPUSH
30046: CALL_OW 255
30050: PUSH
30051: LD_INT 1
30053: PUSH
30054: LD_INT 4
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: IN
30061: AND
30062: IFFALSE 30071
// RaiseSailEvent ( 104 ) ;
30064: LD_INT 104
30066: PPUSH
30067: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30071: LD_EXP 40
30075: PUSH
30076: LD_VAR 0 1
30080: PPUSH
30081: CALL_OW 255
30085: ARRAY
30086: IFFALSE 30473
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30088: LD_STRING UnitDestroyed [side 
30090: PUSH
30091: LD_VAR 0 1
30095: PPUSH
30096: CALL_OW 255
30100: STR
30101: PUSH
30102: LD_STRING ; id: 
30104: STR
30105: PUSH
30106: LD_VAR 0 1
30110: STR
30111: PUSH
30112: LD_STRING ; type: 
30114: STR
30115: PUSH
30116: LD_VAR 0 1
30120: PPUSH
30121: CALL_OW 247
30125: STR
30126: PUSH
30127: LD_STRING ]
30129: STR
30130: PPUSH
30131: CALL 7818 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30135: LD_VAR 0 1
30139: PUSH
30140: LD_VAR 0 1
30144: PPUSH
30145: CALL_OW 255
30149: PPUSH
30150: LD_INT 21
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PPUSH
30160: CALL 11421 0 2
30164: IN
30165: IFFALSE 30321
// begin if MCF_HasClass ( un ) then
30167: LD_VAR 0 1
30171: PPUSH
30172: CALL 14127 0 1
30176: IFFALSE 30321
// case MCF_HasClass ( un ) of 1 :
30178: LD_VAR 0 1
30182: PPUSH
30183: CALL 14127 0 1
30187: PUSH
30188: LD_INT 1
30190: DOUBLE
30191: EQUAL
30192: IFTRUE 30196
30194: GO 30221
30196: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30197: LD_VAR 0 1
30201: PPUSH
30202: CALL_OW 255
30206: PPUSH
30207: LD_STRING ToArm
30209: PPUSH
30210: LD_VAR 0 1
30214: PPUSH
30215: CALL 14300 0 3
30219: GO 30321
30221: LD_INT 2
30223: DOUBLE
30224: EQUAL
30225: IFTRUE 30229
30227: GO 30254
30229: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30230: LD_VAR 0 1
30234: PPUSH
30235: CALL_OW 255
30239: PPUSH
30240: LD_STRING ToDep
30242: PPUSH
30243: LD_VAR 0 1
30247: PPUSH
30248: CALL 14300 0 3
30252: GO 30321
30254: LD_INT 3
30256: DOUBLE
30257: EQUAL
30258: IFTRUE 30262
30260: GO 30287
30262: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30263: LD_VAR 0 1
30267: PPUSH
30268: CALL_OW 255
30272: PPUSH
30273: LD_STRING ToFac
30275: PPUSH
30276: LD_VAR 0 1
30280: PPUSH
30281: CALL 14300 0 3
30285: GO 30321
30287: LD_INT 4
30289: DOUBLE
30290: EQUAL
30291: IFTRUE 30295
30293: GO 30320
30295: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30296: LD_VAR 0 1
30300: PPUSH
30301: CALL_OW 255
30305: PPUSH
30306: LD_STRING ToLab
30308: PPUSH
30309: LD_VAR 0 1
30313: PPUSH
30314: CALL 14300 0 3
30318: GO 30321
30320: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30321: LD_VAR 0 1
30325: PUSH
30326: LD_EXP 68
30330: PUSH
30331: LD_VAR 0 1
30335: PPUSH
30336: CALL_OW 255
30340: ARRAY
30341: IN
30342: IFFALSE 30427
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30344: LD_ADDR_EXP 68
30348: PUSH
30349: LD_EXP 68
30353: PPUSH
30354: LD_VAR 0 1
30358: PPUSH
30359: LD_INT 0
30361: PPUSH
30362: CALL 31109 0 3
30366: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30367: LD_VAR 0 1
30371: PPUSH
30372: CALL_OW 255
30376: PPUSH
30377: LD_VAR 0 1
30381: PPUSH
30382: CALL_OW 265
30386: PUSH
30387: LD_VAR 0 1
30391: PPUSH
30392: CALL_OW 262
30396: PUSH
30397: LD_VAR 0 1
30401: PPUSH
30402: CALL_OW 263
30406: PUSH
30407: LD_VAR 0 1
30411: PPUSH
30412: CALL_OW 264
30416: PUSH
30417: EMPTY
30418: LIST
30419: LIST
30420: LIST
30421: LIST
30422: PPUSH
30423: CALL 20940 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30427: LD_VAR 0 1
30431: PUSH
30432: LD_EXP 72
30436: PUSH
30437: LD_VAR 0 1
30441: PPUSH
30442: CALL_OW 255
30446: ARRAY
30447: IN
30448: IFFALSE 30473
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30450: LD_ADDR_EXP 72
30454: PUSH
30455: LD_EXP 72
30459: PPUSH
30460: LD_VAR 0 1
30464: PPUSH
30465: LD_INT 0
30467: PPUSH
30468: CALL 31109 0 3
30472: ST_TO_ADDR
// end ; end ;
30473: PPOPN 1
30475: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30476: LD_EXP 40
30480: PUSH
30481: LD_VAR 0 2
30485: PPUSH
30486: CALL_OW 255
30490: ARRAY
30491: IFFALSE 30663
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30493: LD_VAR 0 2
30497: PUSH
30498: LD_EXP 69
30502: PUSH
30503: LD_VAR 0 2
30507: PPUSH
30508: CALL_OW 255
30512: ARRAY
30513: IN
30514: PUSH
30515: LD_VAR 0 1
30519: PPUSH
30520: CALL_OW 266
30524: PUSH
30525: LD_INT 32
30527: PUSH
30528: LD_INT 31
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: IN
30535: AND
30536: IFFALSE 30636
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30538: LD_ADDR_EXP 69
30542: PUSH
30543: LD_EXP 69
30547: PPUSH
30548: LD_VAR 0 1
30552: PPUSH
30553: LD_INT 0
30555: PPUSH
30556: CALL 31109 0 3
30560: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30561: LD_ADDR_EXP 69
30565: PUSH
30566: LD_EXP 69
30570: PPUSH
30571: LD_VAR 0 2
30575: PPUSH
30576: LD_INT 0
30578: PPUSH
30579: CALL 31109 0 3
30583: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30584: LD_EXP 69
30588: PUSH
30589: LD_VAR 0 2
30593: PPUSH
30594: CALL_OW 255
30598: ARRAY
30599: PUSH
30600: LD_STRING 
30602: EQUAL
30603: IFFALSE 30636
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30605: LD_ADDR_EXP 69
30609: PUSH
30610: LD_EXP 69
30614: PPUSH
30615: LD_VAR 0 2
30619: PPUSH
30620: CALL_OW 255
30624: PPUSH
30625: LD_INT 1
30627: PPUSH
30628: LD_INT 0
30630: PPUSH
30631: CALL 30950 0 4
30635: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30636: LD_VAR 0 1
30640: PPUSH
30641: CALL_OW 266
30645: PUSH
30646: LD_INT 36
30648: IN
30649: IFFALSE 30663
// SetTag ( un , 0 ) ;
30651: LD_VAR 0 2
30655: PPUSH
30656: LD_INT 0
30658: PPUSH
30659: CALL_OW 109
// end ;
30663: PPOPN 2
30665: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30666: LD_EXP 40
30670: PUSH
30671: LD_VAR 0 1
30675: PPUSH
30676: CALL_OW 255
30680: ARRAY
30681: IFFALSE 30707
// begin if GetControl ( un ) = control_remote then
30683: LD_VAR 0 1
30687: PPUSH
30688: CALL_OW 263
30692: PUSH
30693: LD_INT 2
30695: EQUAL
30696: IFFALSE 30707
// ComUnlink ( un ) ;
30698: LD_VAR 0 1
30702: PPUSH
30703: CALL_OW 136
// end ;
30707: PPOPN 1
30709: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30710: LD_EXP 40
30714: PUSH
30715: LD_VAR 0 1
30719: PPUSH
30720: CALL_OW 255
30724: ARRAY
30725: IFFALSE 30754
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30727: LD_VAR 0 2
30731: PPUSH
30732: CALL_OW 264
30736: PUSH
30737: LD_INT 31
30739: IN
30740: IFFALSE 30754
// SetTag ( driver , 0 ) ;
30742: LD_VAR 0 1
30746: PPUSH
30747: LD_INT 0
30749: PPUSH
30750: CALL_OW 109
// end ;
30754: PPOPN 4
30756: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30757: LD_INT 0
30759: PPUSH
30760: PPUSH
30761: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30762: LD_ADDR_VAR 0 3
30766: PUSH
30767: LD_VAR 0 1
30771: PPUSH
30772: CALL_OW 269
30776: ST_TO_ADDR
// x := GetX ( building ) ;
30777: LD_ADDR_VAR 0 4
30781: PUSH
30782: LD_VAR 0 1
30786: PPUSH
30787: CALL_OW 250
30791: ST_TO_ADDR
// y := GetY ( building ) ;
30792: LD_ADDR_VAR 0 5
30796: PUSH
30797: LD_VAR 0 1
30801: PPUSH
30802: CALL_OW 251
30806: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30807: LD_ADDR_EXP 44
30811: PUSH
30812: LD_EXP 44
30816: PPUSH
30817: LD_VAR 0 1
30821: PPUSH
30822: CALL_OW 255
30826: PPUSH
30827: LD_VAR 0 3
30831: PPUSH
30832: LD_VAR 0 4
30836: PUSH
30837: LD_VAR 0 5
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PPUSH
30846: CALL 42323 0 4
30850: ST_TO_ADDR
// end ;
30851: PPOPN 5
30853: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30854: LD_VAR 0 1
30858: PUSH
30859: LD_EXP 31
30863: IN
30864: NOT
30865: IFFALSE 30913
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30867: LD_ADDR_EXP 31
30871: PUSH
30872: LD_EXP 31
30876: PPUSH
30877: LD_EXP 31
30881: PUSH
30882: LD_INT 1
30884: PLUS
30885: PPUSH
30886: LD_VAR 0 1
30890: PPUSH
30891: CALL_OW 2
30895: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30896: LD_STRING DestinationUnrechable. [unit: 
30898: PUSH
30899: LD_VAR 0 1
30903: STR
30904: PUSH
30905: LD_STRING ]
30907: STR
30908: PPUSH
30909: CALL 7818 0 1
// end ; end ;
30913: PPOPN 1
30915: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
30916: LD_VAR 0 1
30920: PPUSH
30921: LD_VAR 0 2
30925: PPUSH
30926: LD_VAR 0 3
30930: PPUSH
30931: CALL 47095 0 3
// end ;
30935: PPOPN 3
30937: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
30938: LD_VAR 0 1
30942: PPUSH
30943: CALL 47193 0 1
// end ; end_of_file
30947: PPOPN 1
30949: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
30950: LD_INT 0
30952: PPUSH
30953: PPUSH
30954: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
30955: LD_ADDR_VAR 0 7
30959: PUSH
30960: LD_VAR 0 1
30964: PUSH
30965: LD_VAR 0 2
30969: ARRAY
30970: PPUSH
30971: LD_VAR 0 3
30975: PPUSH
30976: LD_VAR 0 4
30980: PPUSH
30981: CALL_OW 1
30985: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
30986: LD_ADDR_VAR 0 1
30990: PUSH
30991: LD_VAR 0 1
30995: PPUSH
30996: LD_VAR 0 2
31000: PPUSH
31001: LD_VAR 0 7
31005: PPUSH
31006: CALL_OW 1
31010: ST_TO_ADDR
// result := tab ;
31011: LD_ADDR_VAR 0 5
31015: PUSH
31016: LD_VAR 0 1
31020: ST_TO_ADDR
// end ;
31021: LD_VAR 0 5
31025: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31026: LD_INT 0
31028: PPUSH
31029: PPUSH
31030: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31031: LD_ADDR_VAR 0 5
31035: PUSH
31036: LD_VAR 0 1
31040: PUSH
31041: LD_VAR 0 2
31045: PUSH
31046: LD_INT 1
31048: ARRAY
31049: ARRAY
31050: PPUSH
31051: LD_VAR 0 2
31055: PUSH
31056: LD_INT 2
31058: ARRAY
31059: PPUSH
31060: CALL_OW 3
31064: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31065: LD_ADDR_VAR 0 1
31069: PUSH
31070: LD_VAR 0 1
31074: PPUSH
31075: LD_VAR 0 2
31079: PUSH
31080: LD_INT 1
31082: ARRAY
31083: PPUSH
31084: LD_VAR 0 5
31088: PPUSH
31089: CALL_OW 1
31093: ST_TO_ADDR
// result := tab ;
31094: LD_ADDR_VAR 0 3
31098: PUSH
31099: LD_VAR 0 1
31103: ST_TO_ADDR
// end ;
31104: LD_VAR 0 3
31108: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31109: LD_INT 0
31111: PPUSH
31112: PPUSH
31113: PPUSH
31114: PPUSH
// i := 1 ;
31115: LD_ADDR_VAR 0 5
31119: PUSH
31120: LD_INT 1
31122: ST_TO_ADDR
// while ( i <= tab ) do
31123: LD_VAR 0 5
31127: PUSH
31128: LD_VAR 0 1
31132: LESSEQUAL
31133: IFFALSE 31508
// begin if not tab [ i ] then
31135: LD_VAR 0 1
31139: PUSH
31140: LD_VAR 0 5
31144: ARRAY
31145: NOT
31146: IFFALSE 31150
// break ;
31148: GO 31508
// if value in tab then
31150: LD_VAR 0 2
31154: PUSH
31155: LD_VAR 0 1
31159: IN
31160: IFFALSE 31273
// begin if not mode then
31162: LD_VAR 0 3
31166: NOT
31167: IFFALSE 31187
// tab := tab diff value else
31169: LD_ADDR_VAR 0 1
31173: PUSH
31174: LD_VAR 0 1
31178: PUSH
31179: LD_VAR 0 2
31183: DIFF
31184: ST_TO_ADDR
31185: GO 31249
// for j = 1 to tab do
31187: LD_ADDR_VAR 0 6
31191: PUSH
31192: DOUBLE
31193: LD_INT 1
31195: DEC
31196: ST_TO_ADDR
31197: LD_VAR 0 1
31201: PUSH
31202: FOR_TO
31203: IFFALSE 31247
// if tab [ j ] = value then
31205: LD_VAR 0 1
31209: PUSH
31210: LD_VAR 0 6
31214: ARRAY
31215: PUSH
31216: LD_VAR 0 2
31220: EQUAL
31221: IFFALSE 31245
// begin tab := Delete ( tab , j ) ;
31223: LD_ADDR_VAR 0 1
31227: PUSH
31228: LD_VAR 0 1
31232: PPUSH
31233: LD_VAR 0 6
31237: PPUSH
31238: CALL_OW 3
31242: ST_TO_ADDR
// break ;
31243: GO 31247
// end ;
31245: GO 31202
31247: POP
31248: POP
// i := i - 1 ;
31249: LD_ADDR_VAR 0 5
31253: PUSH
31254: LD_VAR 0 5
31258: PUSH
31259: LD_INT 1
31261: MINUS
31262: ST_TO_ADDR
// if mode then
31263: LD_VAR 0 3
31267: IFFALSE 31271
// break ;
31269: GO 31508
// end else
31271: GO 31492
// if tab [ i ] and value in tab [ i ] then
31273: LD_VAR 0 1
31277: PUSH
31278: LD_VAR 0 5
31282: ARRAY
31283: PUSH
31284: LD_VAR 0 2
31288: PUSH
31289: LD_VAR 0 1
31293: PUSH
31294: LD_VAR 0 5
31298: ARRAY
31299: IN
31300: AND
31301: IFFALSE 31492
// begin if not mode then
31303: LD_VAR 0 3
31307: NOT
31308: IFFALSE 31334
// tmp := tab [ i ] diff value else
31310: LD_ADDR_VAR 0 7
31314: PUSH
31315: LD_VAR 0 1
31319: PUSH
31320: LD_VAR 0 5
31324: ARRAY
31325: PUSH
31326: LD_VAR 0 2
31330: DIFF
31331: ST_TO_ADDR
31332: GO 31414
// for j = 1 to tab [ i ] do
31334: LD_ADDR_VAR 0 6
31338: PUSH
31339: DOUBLE
31340: LD_INT 1
31342: DEC
31343: ST_TO_ADDR
31344: LD_VAR 0 1
31348: PUSH
31349: LD_VAR 0 5
31353: ARRAY
31354: PUSH
31355: FOR_TO
31356: IFFALSE 31412
// if value = tab [ i ] [ j ] then
31358: LD_VAR 0 2
31362: PUSH
31363: LD_VAR 0 1
31367: PUSH
31368: LD_VAR 0 5
31372: ARRAY
31373: PUSH
31374: LD_VAR 0 6
31378: ARRAY
31379: EQUAL
31380: IFFALSE 31410
// begin tmp := Delete ( tab [ i ] , j ) ;
31382: LD_ADDR_VAR 0 7
31386: PUSH
31387: LD_VAR 0 1
31391: PUSH
31392: LD_VAR 0 5
31396: ARRAY
31397: PPUSH
31398: LD_VAR 0 6
31402: PPUSH
31403: CALL_OW 3
31407: ST_TO_ADDR
// break ;
31408: GO 31412
// end ;
31410: GO 31355
31412: POP
31413: POP
// if tmp = [ ] then
31414: LD_VAR 0 7
31418: PUSH
31419: EMPTY
31420: EQUAL
31421: IFFALSE 31445
// begin tab := Delete ( tab , i ) ;
31423: LD_ADDR_VAR 0 1
31427: PUSH
31428: LD_VAR 0 1
31432: PPUSH
31433: LD_VAR 0 5
31437: PPUSH
31438: CALL_OW 3
31442: ST_TO_ADDR
// end else
31443: GO 31470
// tab := Replace ( tab , i , tmp ) ;
31445: LD_ADDR_VAR 0 1
31449: PUSH
31450: LD_VAR 0 1
31454: PPUSH
31455: LD_VAR 0 5
31459: PPUSH
31460: LD_VAR 0 7
31464: PPUSH
31465: CALL_OW 1
31469: ST_TO_ADDR
// i := i - 1 ;
31470: LD_ADDR_VAR 0 5
31474: PUSH
31475: LD_VAR 0 5
31479: PUSH
31480: LD_INT 1
31482: MINUS
31483: ST_TO_ADDR
// if mode then
31484: LD_VAR 0 3
31488: IFFALSE 31492
// break ;
31490: GO 31508
// end ; i := i + 1 ;
31492: LD_ADDR_VAR 0 5
31496: PUSH
31497: LD_VAR 0 5
31501: PUSH
31502: LD_INT 1
31504: PLUS
31505: ST_TO_ADDR
// end ;
31506: GO 31123
// result := tab ;
31508: LD_ADDR_VAR 0 4
31512: PUSH
31513: LD_VAR 0 1
31517: ST_TO_ADDR
// end ;
31518: LD_VAR 0 4
31522: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31523: LD_INT 0
31525: PPUSH
31526: PPUSH
// for i = 1 to values do
31527: LD_ADDR_VAR 0 4
31531: PUSH
31532: DOUBLE
31533: LD_INT 1
31535: DEC
31536: ST_TO_ADDR
31537: LD_VAR 0 2
31541: PUSH
31542: FOR_TO
31543: IFFALSE 31576
// tab := Remove ( tab , values [ i ] , false ) ;
31545: LD_ADDR_VAR 0 1
31549: PUSH
31550: LD_VAR 0 1
31554: PPUSH
31555: LD_VAR 0 2
31559: PUSH
31560: LD_VAR 0 4
31564: ARRAY
31565: PPUSH
31566: LD_INT 0
31568: PPUSH
31569: CALL 31109 0 3
31573: ST_TO_ADDR
31574: GO 31542
31576: POP
31577: POP
// result := tab ;
31578: LD_ADDR_VAR 0 3
31582: PUSH
31583: LD_VAR 0 1
31587: ST_TO_ADDR
// end ;
31588: LD_VAR 0 3
31592: RET
// export function IsDriver ( unit ) ; begin
31593: LD_INT 0
31595: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31596: LD_VAR 0 1
31600: PUSH
31601: LD_INT 55
31603: PUSH
31604: EMPTY
31605: LIST
31606: PPUSH
31607: CALL_OW 69
31611: IN
31612: IFFALSE 31631
// result := IsInUnit ( unit ) else
31614: LD_ADDR_VAR 0 2
31618: PUSH
31619: LD_VAR 0 1
31623: PPUSH
31624: CALL_OW 310
31628: ST_TO_ADDR
31629: GO 31639
// result := false ;
31631: LD_ADDR_VAR 0 2
31635: PUSH
31636: LD_INT 0
31638: ST_TO_ADDR
// end ;
31639: LD_VAR 0 2
31643: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31644: LD_INT 0
31646: PPUSH
31647: PPUSH
31648: PPUSH
// if not GetControl ( veh ) = control_manual then
31649: LD_VAR 0 1
31653: PPUSH
31654: CALL_OW 263
31658: PUSH
31659: LD_INT 1
31661: EQUAL
31662: NOT
31663: IFFALSE 31675
// result := false else
31665: LD_ADDR_VAR 0 2
31669: PUSH
31670: LD_INT 0
31672: ST_TO_ADDR
31673: GO 31820
// if veh in FilterAllUnits ( [ f_empty ] ) then
31675: LD_VAR 0 1
31679: PUSH
31680: LD_INT 58
31682: PUSH
31683: EMPTY
31684: LIST
31685: PPUSH
31686: CALL_OW 69
31690: IN
31691: IFFALSE 31703
// result := false else
31693: LD_ADDR_VAR 0 2
31697: PUSH
31698: LD_INT 0
31700: ST_TO_ADDR
31701: GO 31820
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31703: LD_ADDR_VAR 0 4
31707: PUSH
31708: LD_INT 22
31710: PUSH
31711: LD_VAR 0 1
31715: PPUSH
31716: CALL_OW 255
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 55
31727: PUSH
31728: EMPTY
31729: LIST
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PPUSH
31735: CALL_OW 69
31739: ST_TO_ADDR
// if not filter then
31740: LD_VAR 0 4
31744: NOT
31745: IFFALSE 31757
// result := false else
31747: LD_ADDR_VAR 0 2
31751: PUSH
31752: LD_INT 0
31754: ST_TO_ADDR
31755: GO 31820
// for i = 1 to filter do
31757: LD_ADDR_VAR 0 3
31761: PUSH
31762: DOUBLE
31763: LD_INT 1
31765: DEC
31766: ST_TO_ADDR
31767: LD_VAR 0 4
31771: PUSH
31772: FOR_TO
31773: IFFALSE 31818
// if IsDriver ( filter [ i ] ) = veh then
31775: LD_VAR 0 4
31779: PUSH
31780: LD_VAR 0 3
31784: ARRAY
31785: PPUSH
31786: CALL 31593 0 1
31790: PUSH
31791: LD_VAR 0 1
31795: EQUAL
31796: IFFALSE 31816
// begin result := filter [ i ] ;
31798: LD_ADDR_VAR 0 2
31802: PUSH
31803: LD_VAR 0 4
31807: PUSH
31808: LD_VAR 0 3
31812: ARRAY
31813: ST_TO_ADDR
// break ;
31814: GO 31818
// end ;
31816: GO 31772
31818: POP
31819: POP
// end ; end ;
31820: LD_VAR 0 2
31824: RET
// export function ComComplete ( unit , b ) ; var i ; begin
31825: LD_INT 0
31827: PPUSH
31828: PPUSH
// if BuildingStatus ( b ) = bs_build then
31829: LD_VAR 0 2
31833: PPUSH
31834: CALL_OW 461
31838: PUSH
31839: LD_INT 1
31841: EQUAL
31842: IFFALSE 31902
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
31844: LD_VAR 0 1
31848: PPUSH
31849: LD_STRING h
31851: PUSH
31852: LD_VAR 0 2
31856: PPUSH
31857: CALL_OW 250
31861: PUSH
31862: LD_VAR 0 2
31866: PPUSH
31867: CALL_OW 251
31871: PUSH
31872: LD_VAR 0 2
31876: PUSH
31877: LD_INT 0
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 0
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: LIST
31893: LIST
31894: PUSH
31895: EMPTY
31896: LIST
31897: PPUSH
31898: CALL_OW 446
// end ;
31902: LD_VAR 0 3
31906: RET
// export function Compare ( val1 , val2 ) ; begin
31907: LD_INT 0
31909: PPUSH
// if val1 = val2 then
31910: LD_VAR 0 1
31914: PUSH
31915: LD_VAR 0 2
31919: EQUAL
31920: IFFALSE 31932
// result := true else
31922: LD_ADDR_VAR 0 3
31926: PUSH
31927: LD_INT 1
31929: ST_TO_ADDR
31930: GO 31940
// result := false ;
31932: LD_ADDR_VAR 0 3
31936: PUSH
31937: LD_INT 0
31939: ST_TO_ADDR
// end ;
31940: LD_VAR 0 3
31944: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31945: LD_INT 0
31947: PPUSH
31948: PPUSH
// result := true ;
31949: LD_ADDR_VAR 0 3
31953: PUSH
31954: LD_INT 1
31956: ST_TO_ADDR
// if array1 = array2 then
31957: LD_VAR 0 1
31961: PUSH
31962: LD_VAR 0 2
31966: EQUAL
31967: IFFALSE 32032
// begin for i = 1 to array1 do
31969: LD_ADDR_VAR 0 4
31973: PUSH
31974: DOUBLE
31975: LD_INT 1
31977: DEC
31978: ST_TO_ADDR
31979: LD_VAR 0 1
31983: PUSH
31984: FOR_TO
31985: IFFALSE 32028
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
31987: LD_VAR 0 1
31991: PUSH
31992: LD_VAR 0 4
31996: ARRAY
31997: PPUSH
31998: LD_VAR 0 2
32002: PUSH
32003: LD_VAR 0 4
32007: ARRAY
32008: PPUSH
32009: CALL 31907 0 2
32013: NOT
32014: IFFALSE 32026
// begin result := false ;
32016: LD_ADDR_VAR 0 3
32020: PUSH
32021: LD_INT 0
32023: ST_TO_ADDR
// break ;
32024: GO 32028
// end ;
32026: GO 31984
32028: POP
32029: POP
// end else
32030: GO 32040
// result := false ;
32032: LD_ADDR_VAR 0 3
32036: PUSH
32037: LD_INT 0
32039: ST_TO_ADDR
// end ;
32040: LD_VAR 0 3
32044: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
32045: LD_INT 0
32047: PPUSH
32048: PPUSH
// result := false ;
32049: LD_ADDR_VAR 0 3
32053: PUSH
32054: LD_INT 0
32056: ST_TO_ADDR
// for j = 1 to e2 do
32057: LD_ADDR_VAR 0 4
32061: PUSH
32062: DOUBLE
32063: LD_INT 1
32065: DEC
32066: ST_TO_ADDR
32067: LD_VAR 0 2
32071: PUSH
32072: FOR_TO
32073: IFFALSE 32107
// if Compare ( e1 , e2 [ j ] ) then
32075: LD_VAR 0 1
32079: PPUSH
32080: LD_VAR 0 2
32084: PUSH
32085: LD_VAR 0 4
32089: ARRAY
32090: PPUSH
32091: CALL 31907 0 2
32095: IFFALSE 32105
// result := true ;
32097: LD_ADDR_VAR 0 3
32101: PUSH
32102: LD_INT 1
32104: ST_TO_ADDR
32105: GO 32072
32107: POP
32108: POP
// end ;
32109: LD_VAR 0 3
32113: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32114: LD_INT 0
32116: PPUSH
32117: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32118: LD_VAR 0 1
32122: PPUSH
32123: LD_STRING C
32125: PUSH
32126: LD_VAR 0 2
32130: PUSH
32131: LD_VAR 0 3
32135: PUSH
32136: LD_INT 0
32138: PUSH
32139: LD_INT 0
32141: PUSH
32142: LD_INT 0
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: PUSH
32157: LD_STRING v
32159: PUSH
32160: LD_VAR 0 4
32164: PPUSH
32165: CALL_OW 250
32169: PUSH
32170: LD_VAR 0 4
32174: PPUSH
32175: CALL_OW 251
32179: PUSH
32180: LD_VAR 0 4
32184: PUSH
32185: LD_INT 0
32187: PUSH
32188: LD_INT 0
32190: PUSH
32191: LD_INT 0
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: PPUSH
32207: CALL_OW 446
// end ;
32211: LD_VAR 0 5
32215: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32216: LD_INT 0
32218: PPUSH
32219: PPUSH
32220: PPUSH
// linked := UnitsLinked ( unit ) ;
32221: LD_ADDR_VAR 0 4
32225: PUSH
32226: LD_VAR 0 1
32230: PPUSH
32231: CALL_OW 432
32235: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32236: LD_ADDR_VAR 0 3
32240: PUSH
32241: LD_VAR 0 1
32245: PPUSH
32246: LD_INT 3
32248: PPUSH
32249: CALL_OW 259
32253: ST_TO_ADDR
// if sk > linked then
32254: LD_VAR 0 3
32258: PUSH
32259: LD_VAR 0 4
32263: GREATER
32264: IFFALSE 32276
// result := true else
32266: LD_ADDR_VAR 0 2
32270: PUSH
32271: LD_INT 1
32273: ST_TO_ADDR
32274: GO 32284
// result := false ;
32276: LD_ADDR_VAR 0 2
32280: PUSH
32281: LD_INT 0
32283: ST_TO_ADDR
// end ;
32284: LD_VAR 0 2
32288: RET
// export function NotTask ( unit ) ; begin
32289: LD_INT 0
32291: PPUSH
// result := true ;
32292: LD_ADDR_VAR 0 2
32296: PUSH
32297: LD_INT 1
32299: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32300: LD_VAR 0 1
32304: PPUSH
32305: CALL_OW 437
32309: PUSH
32310: LD_VAR 0 1
32314: PPUSH
32315: CALL_OW 314
32319: OR
32320: IFFALSE 32330
// result := false ;
32322: LD_ADDR_VAR 0 2
32326: PUSH
32327: LD_INT 0
32329: ST_TO_ADDR
// end ;
32330: LD_VAR 0 2
32334: RET
// export function WantHeal ( sci , unit ) ; begin
32335: LD_INT 0
32337: PPUSH
// if GetTaskList ( sci ) > 0 then
32338: LD_VAR 0 1
32342: PPUSH
32343: CALL_OW 437
32347: PUSH
32348: LD_INT 0
32350: GREATER
32351: IFFALSE 32421
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32353: LD_VAR 0 1
32357: PPUSH
32358: CALL_OW 437
32362: PUSH
32363: LD_INT 1
32365: ARRAY
32366: PUSH
32367: LD_INT 1
32369: ARRAY
32370: PUSH
32371: LD_STRING l
32373: EQUAL
32374: PUSH
32375: LD_VAR 0 1
32379: PPUSH
32380: CALL_OW 437
32384: PUSH
32385: LD_INT 1
32387: ARRAY
32388: PUSH
32389: LD_INT 4
32391: ARRAY
32392: PUSH
32393: LD_VAR 0 2
32397: EQUAL
32398: AND
32399: IFFALSE 32411
// result := true else
32401: LD_ADDR_VAR 0 3
32405: PUSH
32406: LD_INT 1
32408: ST_TO_ADDR
32409: GO 32419
// result := false ;
32411: LD_ADDR_VAR 0 3
32415: PUSH
32416: LD_INT 0
32418: ST_TO_ADDR
// end else
32419: GO 32429
// result := false ;
32421: LD_ADDR_VAR 0 3
32425: PUSH
32426: LD_INT 0
32428: ST_TO_ADDR
// end ;
32429: LD_VAR 0 3
32433: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32434: LD_INT 0
32436: PPUSH
32437: PPUSH
32438: PPUSH
32439: PPUSH
32440: PPUSH
// dist := 99999 ;
32441: LD_ADDR_VAR 0 7
32445: PUSH
32446: LD_INT 99999
32448: ST_TO_ADDR
// un := - 1 ;
32449: LD_ADDR_VAR 0 6
32453: PUSH
32454: LD_INT 1
32456: NEG
32457: ST_TO_ADDR
// if units1 and units2 then
32458: LD_VAR 0 1
32462: PUSH
32463: LD_VAR 0 2
32467: AND
32468: IFFALSE 32556
// for i in units1 do
32470: LD_ADDR_VAR 0 4
32474: PUSH
32475: LD_VAR 0 1
32479: PUSH
32480: FOR_IN
32481: IFFALSE 32554
// for j in units2 do
32483: LD_ADDR_VAR 0 5
32487: PUSH
32488: LD_VAR 0 2
32492: PUSH
32493: FOR_IN
32494: IFFALSE 32550
// if GetDistUnits ( i , j ) < dist then
32496: LD_VAR 0 4
32500: PPUSH
32501: LD_VAR 0 5
32505: PPUSH
32506: CALL_OW 296
32510: PUSH
32511: LD_VAR 0 7
32515: LESS
32516: IFFALSE 32548
// begin un := i ;
32518: LD_ADDR_VAR 0 6
32522: PUSH
32523: LD_VAR 0 4
32527: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32528: LD_ADDR_VAR 0 7
32532: PUSH
32533: LD_VAR 0 4
32537: PPUSH
32538: LD_VAR 0 5
32542: PPUSH
32543: CALL_OW 296
32547: ST_TO_ADDR
// end ;
32548: GO 32493
32550: POP
32551: POP
32552: GO 32480
32554: POP
32555: POP
// result := [ un , dist ] ;
32556: LD_ADDR_VAR 0 3
32560: PUSH
32561: LD_VAR 0 6
32565: PUSH
32566: LD_VAR 0 7
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: ST_TO_ADDR
// end ;
32575: LD_VAR 0 3
32579: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32580: LD_INT 0
32582: PPUSH
32583: PPUSH
32584: PPUSH
32585: PPUSH
32586: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32587: LD_VAR 0 1
32591: NOT
32592: PUSH
32593: LD_VAR 0 1
32597: PPUSH
32598: CALL_OW 256
32602: PUSH
32603: LD_INT 250
32605: LESS
32606: OR
32607: PUSH
32608: LD_VAR 0 1
32612: PPUSH
32613: CALL_OW 314
32617: PUSH
32618: LD_VAR 0 1
32622: PPUSH
32623: CALL_OW 261
32627: PUSH
32628: LD_INT 20
32630: GREATER
32631: AND
32632: OR
32633: IFFALSE 32637
// exit ;
32635: GO 33011
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32637: LD_VAR 0 1
32641: PPUSH
32642: CALL_OW 261
32646: PUSH
32647: LD_INT 20
32649: LESS
32650: PUSH
32651: LD_VAR 0 1
32655: PPUSH
32656: CALL_OW 110
32660: PUSH
32661: LD_INT 21
32663: EQUAL
32664: NOT
32665: AND
32666: IFFALSE 32702
// begin ComStop ( bulldozer ) ;
32668: LD_VAR 0 1
32672: PPUSH
32673: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32677: LD_VAR 0 1
32681: PPUSH
32682: LD_INT 21
32684: PPUSH
32685: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32689: LD_VAR 0 1
32693: PPUSH
32694: CALL 26119 0 1
// exit ;
32698: GO 33011
// end else
32700: GO 32729
// if GetFuel ( bulldozer ) > 20 then
32702: LD_VAR 0 1
32706: PPUSH
32707: CALL_OW 261
32711: PUSH
32712: LD_INT 20
32714: GREATER
32715: IFFALSE 32729
// SetTag ( bulldozer , 0 ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: LD_INT 0
32724: PPUSH
32725: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32729: LD_ADDR_VAR 0 5
32733: PUSH
32734: LD_VAR 0 2
32738: PPUSH
32739: CALL_OW 353
32743: ST_TO_ADDR
// tmp := [ ] ;
32744: LD_ADDR_VAR 0 6
32748: PUSH
32749: EMPTY
32750: ST_TO_ADDR
// for i = 1 to list do
32751: LD_ADDR_VAR 0 4
32755: PUSH
32756: DOUBLE
32757: LD_INT 1
32759: DEC
32760: ST_TO_ADDR
32761: LD_VAR 0 5
32765: PUSH
32766: FOR_TO
32767: IFFALSE 32865
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32769: LD_VAR 0 5
32773: PUSH
32774: LD_VAR 0 4
32778: ARRAY
32779: PUSH
32780: LD_INT 1
32782: ARRAY
32783: PPUSH
32784: LD_VAR 0 5
32788: PUSH
32789: LD_VAR 0 4
32793: ARRAY
32794: PUSH
32795: LD_INT 2
32797: ARRAY
32798: PPUSH
32799: CALL_OW 554
32803: IFFALSE 32863
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32805: LD_ADDR_VAR 0 6
32809: PUSH
32810: LD_VAR 0 6
32814: PPUSH
32815: LD_VAR 0 6
32819: PUSH
32820: LD_INT 1
32822: PLUS
32823: PPUSH
32824: LD_VAR 0 5
32828: PUSH
32829: LD_VAR 0 4
32833: ARRAY
32834: PUSH
32835: LD_INT 1
32837: ARRAY
32838: PUSH
32839: LD_VAR 0 5
32843: PUSH
32844: LD_VAR 0 4
32848: ARRAY
32849: PUSH
32850: LD_INT 2
32852: ARRAY
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PPUSH
32858: CALL_OW 1
32862: ST_TO_ADDR
// end ;
32863: GO 32766
32865: POP
32866: POP
// ComStop ( bulldozer ) ;
32867: LD_VAR 0 1
32871: PPUSH
32872: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32876: LD_ADDR_VAR 0 7
32880: PUSH
32881: LD_VAR 0 1
32885: PPUSH
32886: CALL_OW 250
32890: PUSH
32891: LD_VAR 0 1
32895: PPUSH
32896: CALL_OW 251
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: ST_TO_ADDR
// for i = tmp downto 1 do
32905: LD_ADDR_VAR 0 4
32909: PUSH
32910: DOUBLE
32911: LD_VAR 0 6
32915: INC
32916: ST_TO_ADDR
32917: LD_INT 1
32919: PUSH
32920: FOR_DOWNTO
32921: IFFALSE 33009
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32923: LD_ADDR_VAR 0 7
32927: PUSH
32928: LD_VAR 0 7
32932: PUSH
32933: LD_INT 1
32935: ARRAY
32936: PPUSH
32937: LD_VAR 0 7
32941: PUSH
32942: LD_INT 2
32944: ARRAY
32945: PPUSH
32946: LD_VAR 0 6
32950: PPUSH
32951: CALL 33112 0 3
32955: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32956: LD_VAR 0 1
32960: PPUSH
32961: LD_VAR 0 7
32965: PUSH
32966: LD_INT 1
32968: ARRAY
32969: PPUSH
32970: LD_VAR 0 7
32974: PUSH
32975: LD_INT 2
32977: ARRAY
32978: PPUSH
32979: CALL 33016 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32983: LD_ADDR_VAR 0 6
32987: PUSH
32988: LD_VAR 0 6
32992: PPUSH
32993: LD_VAR 0 7
32997: PUSH
32998: LD_INT 3
33000: ARRAY
33001: PPUSH
33002: CALL_OW 3
33006: ST_TO_ADDR
// end ;
33007: GO 32920
33009: POP
33010: POP
// end ;
33011: LD_VAR 0 3
33015: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
33016: LD_INT 0
33018: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
33019: LD_VAR 0 2
33023: PPUSH
33024: LD_VAR 0 3
33028: PPUSH
33029: CALL_OW 351
33033: PUSH
33034: LD_VAR 0 2
33038: PPUSH
33039: LD_VAR 0 3
33043: PPUSH
33044: CALL_OW 554
33048: AND
33049: PUSH
33050: LD_VAR 0 2
33054: PPUSH
33055: LD_VAR 0 3
33059: PPUSH
33060: CALL_OW 488
33064: AND
33065: PUSH
33066: LD_VAR 0 2
33070: PPUSH
33071: LD_VAR 0 3
33075: PPUSH
33076: CALL_OW 428
33080: PUSH
33081: LD_INT 1
33083: NEG
33084: EQUAL
33085: AND
33086: IFFALSE 33107
// AddComMoveXY ( bulldozer , x , y ) ;
33088: LD_VAR 0 1
33092: PPUSH
33093: LD_VAR 0 2
33097: PPUSH
33098: LD_VAR 0 3
33102: PPUSH
33103: CALL_OW 171
// end ;
33107: LD_VAR 0 4
33111: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
33112: LD_INT 0
33114: PPUSH
33115: PPUSH
33116: PPUSH
33117: PPUSH
33118: PPUSH
33119: PPUSH
33120: PPUSH
// dist := 99999 ;
33121: LD_ADDR_VAR 0 6
33125: PUSH
33126: LD_INT 99999
33128: ST_TO_ADDR
// for i = 1 to list do
33129: LD_ADDR_VAR 0 5
33133: PUSH
33134: DOUBLE
33135: LD_INT 1
33137: DEC
33138: ST_TO_ADDR
33139: LD_VAR 0 3
33143: PUSH
33144: FOR_TO
33145: IFFALSE 33283
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33147: LD_ADDR_VAR 0 7
33151: PUSH
33152: LD_VAR 0 1
33156: PPUSH
33157: LD_VAR 0 2
33161: PPUSH
33162: LD_VAR 0 3
33166: PUSH
33167: LD_VAR 0 5
33171: ARRAY
33172: PUSH
33173: LD_INT 1
33175: ARRAY
33176: PPUSH
33177: LD_VAR 0 3
33181: PUSH
33182: LD_VAR 0 5
33186: ARRAY
33187: PUSH
33188: LD_INT 2
33190: ARRAY
33191: PPUSH
33192: CALL_OW 298
33196: ST_TO_ADDR
// if d = 0 then
33197: LD_VAR 0 7
33201: PUSH
33202: LD_INT 0
33204: EQUAL
33205: IFFALSE 33209
// continue ;
33207: GO 33144
// if d < dist then
33209: LD_VAR 0 7
33213: PUSH
33214: LD_VAR 0 6
33218: LESS
33219: IFFALSE 33281
// begin _x := list [ i ] [ 1 ] ;
33221: LD_ADDR_VAR 0 8
33225: PUSH
33226: LD_VAR 0 3
33230: PUSH
33231: LD_VAR 0 5
33235: ARRAY
33236: PUSH
33237: LD_INT 1
33239: ARRAY
33240: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33241: LD_ADDR_VAR 0 9
33245: PUSH
33246: LD_VAR 0 3
33250: PUSH
33251: LD_VAR 0 5
33255: ARRAY
33256: PUSH
33257: LD_INT 2
33259: ARRAY
33260: ST_TO_ADDR
// _i := i ;
33261: LD_ADDR_VAR 0 10
33265: PUSH
33266: LD_VAR 0 5
33270: ST_TO_ADDR
// dist := d ;
33271: LD_ADDR_VAR 0 6
33275: PUSH
33276: LD_VAR 0 7
33280: ST_TO_ADDR
// end ; end ;
33281: GO 33144
33283: POP
33284: POP
// result := [ _x , _y , _i , dist ] ;
33285: LD_ADDR_VAR 0 4
33289: PUSH
33290: LD_VAR 0 8
33294: PUSH
33295: LD_VAR 0 9
33299: PUSH
33300: LD_VAR 0 10
33304: PUSH
33305: LD_VAR 0 6
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: ST_TO_ADDR
// end ;
33316: LD_VAR 0 4
33320: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33321: LD_INT 0
33323: PPUSH
33324: PPUSH
33325: PPUSH
33326: PPUSH
33327: PPUSH
// for i = 1 to list do
33328: LD_ADDR_VAR 0 5
33332: PUSH
33333: DOUBLE
33334: LD_INT 1
33336: DEC
33337: ST_TO_ADDR
33338: LD_VAR 0 1
33342: PUSH
33343: FOR_TO
33344: IFFALSE 33658
// begin for j = list downto 2 do
33346: LD_ADDR_VAR 0 6
33350: PUSH
33351: DOUBLE
33352: LD_VAR 0 1
33356: INC
33357: ST_TO_ADDR
33358: LD_INT 2
33360: PUSH
33361: FOR_DOWNTO
33362: IFFALSE 33654
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33364: LD_VAR 0 2
33368: PPUSH
33369: LD_VAR 0 3
33373: PPUSH
33374: LD_VAR 0 1
33378: PUSH
33379: LD_VAR 0 6
33383: ARRAY
33384: PUSH
33385: LD_INT 1
33387: ARRAY
33388: PPUSH
33389: LD_VAR 0 1
33393: PUSH
33394: LD_VAR 0 6
33398: ARRAY
33399: PUSH
33400: LD_INT 2
33402: ARRAY
33403: PPUSH
33404: CALL_OW 298
33408: PUSH
33409: LD_VAR 0 2
33413: PPUSH
33414: LD_VAR 0 3
33418: PPUSH
33419: LD_VAR 0 1
33423: PUSH
33424: LD_VAR 0 6
33428: PUSH
33429: LD_INT 1
33431: MINUS
33432: ARRAY
33433: PUSH
33434: LD_INT 1
33436: ARRAY
33437: PPUSH
33438: LD_VAR 0 1
33442: PUSH
33443: LD_VAR 0 6
33447: PUSH
33448: LD_INT 1
33450: MINUS
33451: ARRAY
33452: PUSH
33453: LD_INT 2
33455: ARRAY
33456: PPUSH
33457: CALL_OW 298
33461: LESS
33462: IFFALSE 33652
// begin _x := list [ j ] [ 1 ] ;
33464: LD_ADDR_VAR 0 7
33468: PUSH
33469: LD_VAR 0 1
33473: PUSH
33474: LD_VAR 0 6
33478: ARRAY
33479: PUSH
33480: LD_INT 1
33482: ARRAY
33483: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33484: LD_ADDR_VAR 0 8
33488: PUSH
33489: LD_VAR 0 1
33493: PUSH
33494: LD_VAR 0 6
33498: ARRAY
33499: PUSH
33500: LD_INT 2
33502: ARRAY
33503: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33504: LD_ADDR_VAR 0 1
33508: PUSH
33509: LD_VAR 0 1
33513: PPUSH
33514: LD_VAR 0 6
33518: PPUSH
33519: LD_INT 1
33521: PPUSH
33522: LD_VAR 0 1
33526: PUSH
33527: LD_VAR 0 6
33531: PUSH
33532: LD_INT 1
33534: MINUS
33535: ARRAY
33536: PUSH
33537: LD_INT 1
33539: ARRAY
33540: PPUSH
33541: CALL 30950 0 4
33545: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33546: LD_ADDR_VAR 0 1
33550: PUSH
33551: LD_VAR 0 1
33555: PPUSH
33556: LD_VAR 0 6
33560: PPUSH
33561: LD_INT 2
33563: PPUSH
33564: LD_VAR 0 1
33568: PUSH
33569: LD_VAR 0 6
33573: PUSH
33574: LD_INT 1
33576: MINUS
33577: ARRAY
33578: PUSH
33579: LD_INT 2
33581: ARRAY
33582: PPUSH
33583: CALL 30950 0 4
33587: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33588: LD_ADDR_VAR 0 1
33592: PUSH
33593: LD_VAR 0 1
33597: PPUSH
33598: LD_VAR 0 6
33602: PUSH
33603: LD_INT 1
33605: MINUS
33606: PPUSH
33607: LD_INT 1
33609: PPUSH
33610: LD_VAR 0 7
33614: PPUSH
33615: CALL 30950 0 4
33619: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33620: LD_ADDR_VAR 0 1
33624: PUSH
33625: LD_VAR 0 1
33629: PPUSH
33630: LD_VAR 0 6
33634: PUSH
33635: LD_INT 1
33637: MINUS
33638: PPUSH
33639: LD_INT 2
33641: PPUSH
33642: LD_VAR 0 8
33646: PPUSH
33647: CALL 30950 0 4
33651: ST_TO_ADDR
// end ; end ;
33652: GO 33361
33654: POP
33655: POP
// end ;
33656: GO 33343
33658: POP
33659: POP
// result := list ;
33660: LD_ADDR_VAR 0 4
33664: PUSH
33665: LD_VAR 0 1
33669: ST_TO_ADDR
// end ;
33670: LD_VAR 0 4
33674: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33675: LD_INT 0
33677: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33678: LD_ADDR_VAR 0 5
33682: PUSH
33683: LD_VAR 0 1
33687: PPUSH
33688: LD_VAR 0 2
33692: PPUSH
33693: CALL_OW 546
33697: PUSH
33698: LD_INT 2
33700: ARRAY
33701: PUSH
33702: LD_VAR 0 3
33706: PPUSH
33707: LD_VAR 0 4
33711: PPUSH
33712: CALL_OW 546
33716: PUSH
33717: LD_INT 2
33719: ARRAY
33720: MINUS
33721: ST_TO_ADDR
// if result < 0 then
33722: LD_VAR 0 5
33726: PUSH
33727: LD_INT 0
33729: LESS
33730: IFFALSE 33747
// result := result * - 1 ;
33732: LD_ADDR_VAR 0 5
33736: PUSH
33737: LD_VAR 0 5
33741: PUSH
33742: LD_INT 1
33744: NEG
33745: MUL
33746: ST_TO_ADDR
// end ;
33747: LD_VAR 0 5
33751: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33752: LD_INT 0
33754: PPUSH
33755: PPUSH
// area = ListEnvironmentArea ( area ) ;
33756: LD_ADDR_VAR 0 2
33760: PUSH
33761: LD_VAR 0 2
33765: PPUSH
33766: CALL_OW 353
33770: ST_TO_ADDR
// if bulldozer > 0 then
33771: LD_VAR 0 1
33775: PUSH
33776: LD_INT 0
33778: GREATER
33779: IFFALSE 33890
// for i = area downto 1 do
33781: LD_ADDR_VAR 0 4
33785: PUSH
33786: DOUBLE
33787: LD_VAR 0 2
33791: INC
33792: ST_TO_ADDR
33793: LD_INT 1
33795: PUSH
33796: FOR_DOWNTO
33797: IFFALSE 33888
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33799: LD_VAR 0 2
33803: PUSH
33804: LD_VAR 0 4
33808: ARRAY
33809: PUSH
33810: LD_INT 1
33812: ARRAY
33813: PPUSH
33814: LD_VAR 0 2
33818: PUSH
33819: LD_VAR 0 4
33823: ARRAY
33824: PUSH
33825: LD_INT 2
33827: ARRAY
33828: PPUSH
33829: CALL_OW 351
33833: IFFALSE 33886
// if not HasTask ( bulldozer ) then
33835: LD_VAR 0 1
33839: PPUSH
33840: CALL_OW 314
33844: NOT
33845: IFFALSE 33886
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33847: LD_VAR 0 1
33851: PPUSH
33852: LD_VAR 0 2
33856: PUSH
33857: LD_VAR 0 4
33861: ARRAY
33862: PUSH
33863: LD_INT 1
33865: ARRAY
33866: PPUSH
33867: LD_VAR 0 2
33871: PUSH
33872: LD_VAR 0 4
33876: ARRAY
33877: PUSH
33878: LD_INT 2
33880: ARRAY
33881: PPUSH
33882: CALL_OW 171
33886: GO 33796
33888: POP
33889: POP
// end ;
33890: LD_VAR 0 3
33894: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33895: LD_INT 0
33897: PPUSH
33898: PPUSH
33899: PPUSH
33900: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33901: LD_ADDR_VAR 0 6
33905: PUSH
33906: LD_INT 22
33908: PUSH
33909: LD_VAR 0 1
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 21
33920: PUSH
33921: LD_VAR 0 2
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PPUSH
33934: CALL_OW 69
33938: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33939: LD_ADDR_VAR 0 7
33943: PUSH
33944: LD_VAR 0 3
33948: PPUSH
33949: LD_INT 22
33951: PUSH
33952: LD_VAR 0 1
33956: PUSH
33957: EMPTY
33958: LIST
33959: LIST
33960: PUSH
33961: LD_INT 21
33963: PUSH
33964: LD_VAR 0 2
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PPUSH
33977: CALL_OW 70
33981: ST_TO_ADDR
// if tmp and pom then
33982: LD_VAR 0 6
33986: PUSH
33987: LD_VAR 0 7
33991: AND
33992: IFFALSE 34012
// result := tmp diff pom else
33994: LD_ADDR_VAR 0 4
33998: PUSH
33999: LD_VAR 0 6
34003: PUSH
34004: LD_VAR 0 7
34008: DIFF
34009: ST_TO_ADDR
34010: GO 34020
// result := false ;
34012: LD_ADDR_VAR 0 4
34016: PUSH
34017: LD_INT 0
34019: ST_TO_ADDR
// end ;
34020: LD_VAR 0 4
34024: RET
// export function SavePosition ( unit ) ; begin
34025: LD_INT 0
34027: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
34028: LD_VAR 0 1
34032: PPUSH
34033: LD_VAR 0 1
34037: PPUSH
34038: CALL_OW 250
34042: PPUSH
34043: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
34047: LD_VAR 0 1
34051: PPUSH
34052: LD_VAR 0 1
34056: PPUSH
34057: CALL_OW 251
34061: PPUSH
34062: CALL_OW 232
// end ;
34066: LD_VAR 0 2
34070: RET
// export function GetPosition ( unit ) ; begin
34071: LD_INT 0
34073: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
34074: LD_ADDR_VAR 0 2
34078: PUSH
34079: LD_VAR 0 1
34083: PPUSH
34084: CALL_OW 252
34088: PUSH
34089: LD_VAR 0 1
34093: PPUSH
34094: CALL_OW 253
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: ST_TO_ADDR
// end ;
34103: LD_VAR 0 2
34107: RET
// export function DestinationReachable ( unit , x , y ) ; begin
34108: LD_INT 0
34110: PPUSH
// if unit in unreachableList then
34111: LD_VAR 0 1
34115: PUSH
34116: LD_EXP 31
34120: IN
34121: IFFALSE 34139
// unreachableList := unreachableList diff unit ;
34123: LD_ADDR_EXP 31
34127: PUSH
34128: LD_EXP 31
34132: PUSH
34133: LD_VAR 0 1
34137: DIFF
34138: ST_TO_ADDR
// if ValidHex ( x , y ) then
34139: LD_VAR 0 2
34143: PPUSH
34144: LD_VAR 0 3
34148: PPUSH
34149: CALL_OW 488
34153: IFFALSE 34179
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34155: LD_VAR 0 1
34159: PPUSH
34160: LD_VAR 0 2
34164: PPUSH
34165: LD_VAR 0 3
34169: PPUSH
34170: CALL_OW 428
34174: PPUSH
34175: CALL_OW 115
// Wait ( 3 ) ;
34179: LD_INT 3
34181: PPUSH
34182: CALL_OW 67
// if unit in unreachableList then
34186: LD_VAR 0 1
34190: PUSH
34191: LD_EXP 31
34195: IN
34196: IFFALSE 34208
// result := false else
34198: LD_ADDR_VAR 0 4
34202: PUSH
34203: LD_INT 0
34205: ST_TO_ADDR
34206: GO 34216
// result := true ;
34208: LD_ADDR_VAR 0 4
34212: PUSH
34213: LD_INT 1
34215: ST_TO_ADDR
// end ; end_of_file
34216: LD_VAR 0 4
34220: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34221: LD_EXP 32
34225: IFFALSE 34287
34227: GO 34229
34229: DISABLE
34230: LD_INT 0
34232: PPUSH
// begin enable ;
34233: ENABLE
// for i = 1 to mc_crates_list do
34234: LD_ADDR_VAR 0 1
34238: PUSH
34239: DOUBLE
34240: LD_INT 1
34242: DEC
34243: ST_TO_ADDR
34244: LD_EXP 33
34248: PUSH
34249: FOR_TO
34250: IFFALSE 34281
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34252: LD_EXP 33
34256: PUSH
34257: LD_VAR 0 1
34261: ARRAY
34262: PPUSH
34263: LD_INT 5
34265: PPUSH
34266: LD_INT 50
34268: PPUSH
34269: LD_INT 700
34271: PPUSH
34272: LD_INT 20
34274: PPUSH
34275: CALL 24301 0 5
34279: GO 34249
34281: POP
34282: POP
// MC_Game ( ) ;
34283: CALL 34290 0 0
// end ;
34287: PPOPN 1
34289: END
// export function MC_Game ( ) ; var i , side , un ; begin
34290: LD_INT 0
34292: PPUSH
34293: PPUSH
34294: PPUSH
34295: PPUSH
// if not isTest then
34296: LD_EXP 1
34300: NOT
34301: IFFALSE 34321
// MC_Show ( [ #tick , tick ] ) else
34303: LD_STRING #tick
34305: PUSH
34306: LD_OWVAR 1
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PPUSH
34315: CALL 8339 0 1
34319: GO 34330
// MC_Show ( debug_string ) ;
34321: LD_EXP 2
34325: PPUSH
34326: CALL 8339 0 1
// for side = 1 to 8 do
34330: LD_ADDR_VAR 0 3
34334: PUSH
34335: DOUBLE
34336: LD_INT 1
34338: DEC
34339: ST_TO_ADDR
34340: LD_INT 8
34342: PUSH
34343: FOR_TO
34344: IFFALSE 36344
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34346: LD_EXP 40
34350: PUSH
34351: LD_VAR 0 3
34355: ARRAY
34356: PUSH
34357: LD_INT 0
34359: EQUAL
34360: PUSH
34361: LD_VAR 0 3
34365: PPUSH
34366: EMPTY
34367: PPUSH
34368: CALL 11556 0 2
34372: PUSH
34373: LD_INT 0
34375: EQUAL
34376: OR
34377: IFFALSE 34381
// continue ;
34379: GO 34343
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34381: LD_VAR 0 3
34385: PPUSH
34386: LD_VAR 0 3
34390: PPUSH
34391: CALL 24822 0 1
34395: PPUSH
34396: CALL 36351 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34400: LD_EXP 72
34404: PUSH
34405: LD_VAR 0 3
34409: ARRAY
34410: PUSH
34411: LD_INT 1
34413: ARRAY
34414: PUSH
34415: LD_INT 0
34417: GREATER
34418: PUSH
34419: LD_EXP 70
34423: PUSH
34424: LD_VAR 0 3
34428: ARRAY
34429: PUSH
34430: LD_INT 1
34432: ARRAY
34433: PUSH
34434: LD_INT 0
34436: EQUAL
34437: AND
34438: PUSH
34439: LD_VAR 0 3
34443: PPUSH
34444: LD_INT 7
34446: PPUSH
34447: EMPTY
34448: PPUSH
34449: CALL 12124 0 3
34453: NOT
34454: AND
34455: IFFALSE 34526
// begin if side = 1 then
34457: LD_VAR 0 3
34461: PUSH
34462: LD_INT 1
34464: EQUAL
34465: IFFALSE 34474
// RaiseSailEvent ( 101 ) ;
34467: LD_INT 101
34469: PPUSH
34470: CALL_OW 427
// if side = 4 then
34474: LD_VAR 0 3
34478: PUSH
34479: LD_INT 4
34481: EQUAL
34482: IFFALSE 34491
// RaiseSailEvent ( 102 ) ;
34484: LD_INT 102
34486: PPUSH
34487: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34491: LD_ADDR_VAR 0 2
34495: PUSH
34496: LD_EXP 72
34500: PUSH
34501: LD_VAR 0 3
34505: ARRAY
34506: PUSH
34507: FOR_IN
34508: IFFALSE 34524
// SetTag ( i , 7 ) ;
34510: LD_VAR 0 2
34514: PPUSH
34515: LD_INT 7
34517: PPUSH
34518: CALL_OW 109
34522: GO 34507
34524: POP
34525: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34526: LD_VAR 0 3
34530: PPUSH
34531: LD_INT 7
34533: PPUSH
34534: EMPTY
34535: PPUSH
34536: CALL 12124 0 3
34540: IFFALSE 34566
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34542: LD_VAR 0 3
34546: PPUSH
34547: LD_VAR 0 3
34551: PPUSH
34552: LD_INT 7
34554: PPUSH
34555: EMPTY
34556: PPUSH
34557: CALL 12124 0 3
34561: PPUSH
34562: CALL 8266 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34566: LD_VAR 0 3
34570: PPUSH
34571: CALL 17804 0 1
34575: PUSH
34576: LD_VAR 0 3
34580: PPUSH
34581: CALL 11460 0 1
34585: AND
34586: IFFALSE 34597
// MCL_Start ( side ) ;
34588: LD_VAR 0 3
34592: PPUSH
34593: CALL 17761 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34597: LD_ADDR_EXP 36
34601: PUSH
34602: LD_EXP 36
34606: PPUSH
34607: LD_VAR 0 3
34611: PPUSH
34612: LD_VAR 0 3
34616: PPUSH
34617: CALL 19061 0 1
34621: PPUSH
34622: CALL_OW 1
34626: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34627: LD_ADDR_EXP 48
34631: PUSH
34632: LD_EXP 48
34636: PPUSH
34637: LD_VAR 0 3
34641: PPUSH
34642: LD_VAR 0 3
34646: PPUSH
34647: CALL 10874 0 1
34651: PPUSH
34652: CALL_OW 1
34656: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34657: LD_VAR 0 3
34661: PPUSH
34662: LD_INT 21
34664: PUSH
34665: LD_INT 2
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PPUSH
34672: CALL 11421 0 2
34676: IFFALSE 34687
// MCV_CheckStatus ( side ) ;
34678: LD_VAR 0 3
34682: PPUSH
34683: CALL 27031 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34687: LD_VAR 0 3
34691: PPUSH
34692: LD_EXP 54
34696: PPUSH
34697: CALL 43271 0 2
34701: IFFALSE 34786
// begin for i = MREG_ToChangeClass downto 1 do
34703: LD_ADDR_VAR 0 2
34707: PUSH
34708: DOUBLE
34709: LD_EXP 54
34713: INC
34714: ST_TO_ADDR
34715: LD_INT 1
34717: PUSH
34718: FOR_DOWNTO
34719: IFFALSE 34784
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34721: LD_EXP 54
34725: PUSH
34726: LD_VAR 0 2
34730: ARRAY
34731: PUSH
34732: LD_INT 1
34734: ARRAY
34735: PUSH
34736: LD_VAR 0 3
34740: EQUAL
34741: IFFALSE 34782
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34743: LD_VAR 0 3
34747: PPUSH
34748: LD_EXP 54
34752: PUSH
34753: LD_VAR 0 2
34757: ARRAY
34758: PUSH
34759: LD_INT 2
34761: ARRAY
34762: PPUSH
34763: LD_EXP 54
34767: PUSH
34768: LD_VAR 0 2
34772: ARRAY
34773: PUSH
34774: LD_INT 3
34776: ARRAY
34777: PPUSH
34778: CALL 16328 0 3
// end ; end ;
34782: GO 34718
34784: POP
34785: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34786: LD_INT 1
34788: PUSH
34789: LD_EXP 39
34793: PUSH
34794: LD_VAR 0 3
34798: ARRAY
34799: IN
34800: IFFALSE 34811
// begin MCN_TrainApe ( side ) ;
34802: LD_VAR 0 3
34806: PPUSH
34807: CALL 18714 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34811: LD_VAR 0 3
34815: PPUSH
34816: LD_INT 30
34818: PUSH
34819: LD_INT 3
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PPUSH
34826: CALL 11421 0 2
34830: IFFALSE 35004
// begin if MCF_Tag ( side , 10 , [ ] ) then
34832: LD_VAR 0 3
34836: PPUSH
34837: LD_INT 10
34839: PPUSH
34840: EMPTY
34841: PPUSH
34842: CALL 12124 0 3
34846: IFFALSE 34893
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34848: LD_VAR 0 3
34852: PPUSH
34853: LD_INT 10
34855: PPUSH
34856: EMPTY
34857: PPUSH
34858: CALL 12124 0 3
34862: PPUSH
34863: LD_VAR 0 3
34867: PPUSH
34868: LD_INT 30
34870: PUSH
34871: LD_INT 3
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PPUSH
34878: CALL 11421 0 2
34882: PUSH
34883: LD_INT 1
34885: ARRAY
34886: PPUSH
34887: CALL_OW 168
// end else
34891: GO 35004
// if MREG_ToConstruct [ side ] then
34893: LD_EXP 52
34897: PUSH
34898: LD_VAR 0 3
34902: ARRAY
34903: IFFALSE 35004
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34905: LD_VAR 0 3
34909: PPUSH
34910: LD_VAR 0 3
34914: PPUSH
34915: LD_INT 30
34917: PUSH
34918: LD_INT 3
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PPUSH
34925: CALL 11421 0 2
34929: PUSH
34930: LD_INT 1
34932: ARRAY
34933: PPUSH
34934: LD_EXP 52
34938: PUSH
34939: LD_VAR 0 3
34943: ARRAY
34944: PUSH
34945: LD_INT 1
34947: ARRAY
34948: PUSH
34949: LD_EXP 52
34953: PUSH
34954: LD_VAR 0 3
34958: ARRAY
34959: PUSH
34960: LD_INT 2
34962: ARRAY
34963: PUSH
34964: LD_EXP 52
34968: PUSH
34969: LD_VAR 0 3
34973: ARRAY
34974: PUSH
34975: LD_INT 3
34977: ARRAY
34978: PUSH
34979: LD_EXP 52
34983: PUSH
34984: LD_VAR 0 3
34988: ARRAY
34989: PUSH
34990: LD_INT 4
34992: ARRAY
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: PPUSH
35000: CALL 25325 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
35004: LD_VAR 0 3
35008: PPUSH
35009: LD_INT 30
35011: PUSH
35012: LD_INT 3
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PPUSH
35019: CALL 11421 0 2
35023: PUSH
35024: LD_VAR 0 3
35028: PPUSH
35029: LD_EXP 44
35033: PPUSH
35034: CALL 43271 0 2
35038: AND
35039: PUSH
35040: LD_INT 22
35042: PUSH
35043: LD_VAR 0 3
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 2
35054: PUSH
35055: LD_INT 30
35057: PUSH
35058: LD_INT 33
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: PUSH
35065: LD_INT 30
35067: PUSH
35068: LD_INT 32
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 35
35082: PUSH
35083: LD_INT 0
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: LIST
35094: PPUSH
35095: CALL_OW 69
35099: AND
35100: IFFALSE 35111
// MCV_Turret ( side ) ;
35102: LD_VAR 0 3
35106: PPUSH
35107: CALL 25774 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
35111: LD_EXP 43
35115: PUSH
35116: LD_VAR 0 3
35120: ARRAY
35121: PUSH
35122: LD_INT 1
35124: GREATER
35125: PUSH
35126: LD_VAR 0 3
35130: PPUSH
35131: CALL 24822 0 1
35135: PUSH
35136: LD_INT 0
35138: EQUAL
35139: AND
35140: IFFALSE 35302
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35142: LD_EXP 43
35146: PUSH
35147: LD_VAR 0 3
35151: ARRAY
35152: PUSH
35153: LD_INT 1
35155: ARRAY
35156: PPUSH
35157: CALL_OW 353
35161: IFFALSE 35199
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35163: LD_EXP 43
35167: PUSH
35168: LD_VAR 0 3
35172: ARRAY
35173: PUSH
35174: LD_INT 2
35176: ARRAY
35177: PPUSH
35178: LD_EXP 43
35182: PUSH
35183: LD_VAR 0 3
35187: ARRAY
35188: PUSH
35189: LD_INT 1
35191: ARRAY
35192: PPUSH
35193: CALL 32580 0 2
35197: GO 35302
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35199: LD_VAR 0 3
35203: PPUSH
35204: LD_INT 30
35206: PUSH
35207: LD_INT 3
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PPUSH
35214: CALL 11421 0 2
35218: IFFALSE 35302
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35220: LD_VAR 0 3
35224: PPUSH
35225: LD_INT 30
35227: PUSH
35228: LD_INT 3
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PPUSH
35235: CALL 11421 0 2
35239: PUSH
35240: LD_INT 1
35242: ARRAY
35243: PPUSH
35244: CALL_OW 461
35248: PUSH
35249: LD_INT 2
35251: EQUAL
35252: IFFALSE 35302
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35254: LD_EXP 43
35258: PUSH
35259: LD_VAR 0 3
35263: ARRAY
35264: PUSH
35265: LD_INT 2
35267: ARRAY
35268: PPUSH
35269: LD_INT 10
35271: PPUSH
35272: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35276: LD_ADDR_EXP 43
35280: PUSH
35281: LD_EXP 43
35285: PPUSH
35286: LD_VAR 0 3
35290: PPUSH
35291: LD_INT 0
35293: PUSH
35294: EMPTY
35295: LIST
35296: PPUSH
35297: CALL_OW 1
35301: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35302: LD_VAR 0 3
35306: PPUSH
35307: LD_INT 33
35309: PUSH
35310: LD_INT 2
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PPUSH
35317: CALL 11421 0 2
35321: IFFALSE 35361
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35323: LD_VAR 0 3
35327: PPUSH
35328: LD_VAR 0 3
35332: PPUSH
35333: LD_INT 33
35335: PUSH
35336: LD_INT 2
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PPUSH
35343: CALL 11421 0 2
35347: PUSH
35348: LD_INT 1
35350: ARRAY
35351: PPUSH
35352: CALL_OW 248
35356: PPUSH
35357: CALL 26328 0 2
// if MREG_ToRepair [ side ] then
35361: LD_EXP 48
35365: PUSH
35366: LD_VAR 0 3
35370: ARRAY
35371: IFFALSE 35384
// begin MCB_Repair ( side ) ;
35373: LD_VAR 0 3
35377: PPUSH
35378: CALL 11161 0 1
// end else
35382: GO 36297
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35384: LD_VAR 0 3
35388: PPUSH
35389: LD_EXP 50
35393: PPUSH
35394: CALL 43271 0 2
35398: PUSH
35399: LD_VAR 0 3
35403: PPUSH
35404: LD_EXP 41
35408: PPUSH
35409: CALL 43271 0 2
35413: AND
35414: IFFALSE 35622
// begin for i = 1 to MREG_ToUpLab do
35416: LD_ADDR_VAR 0 2
35420: PUSH
35421: DOUBLE
35422: LD_INT 1
35424: DEC
35425: ST_TO_ADDR
35426: LD_EXP 50
35430: PUSH
35431: FOR_TO
35432: IFFALSE 35618
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35434: LD_EXP 50
35438: PUSH
35439: LD_VAR 0 2
35443: ARRAY
35444: PUSH
35445: LD_INT 1
35447: ARRAY
35448: PUSH
35449: LD_VAR 0 3
35453: EQUAL
35454: IFFALSE 35616
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35456: LD_EXP 50
35460: PUSH
35461: LD_VAR 0 2
35465: ARRAY
35466: PUSH
35467: LD_INT 2
35469: ARRAY
35470: PUSH
35471: LD_EXP 50
35475: PUSH
35476: LD_VAR 0 2
35480: ARRAY
35481: PUSH
35482: LD_INT 3
35484: ARRAY
35485: AND
35486: IFFALSE 35614
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35488: LD_VAR 0 3
35492: PPUSH
35493: LD_EXP 50
35497: PUSH
35498: LD_VAR 0 2
35502: ARRAY
35503: PUSH
35504: LD_INT 2
35506: ARRAY
35507: PPUSH
35508: LD_EXP 50
35512: PUSH
35513: LD_VAR 0 2
35517: ARRAY
35518: PUSH
35519: LD_INT 3
35521: ARRAY
35522: PPUSH
35523: CALL 8685 0 3
35527: IFFALSE 35614
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35529: LD_ADDR_EXP 50
35533: PUSH
35534: LD_EXP 50
35538: PPUSH
35539: LD_VAR 0 3
35543: PPUSH
35544: LD_EXP 50
35548: PUSH
35549: LD_VAR 0 2
35553: ARRAY
35554: PUSH
35555: LD_INT 2
35557: ARRAY
35558: PPUSH
35559: LD_EXP 50
35563: PUSH
35564: LD_VAR 0 2
35568: ARRAY
35569: PUSH
35570: LD_INT 3
35572: ARRAY
35573: PPUSH
35574: CALL 42323 0 4
35578: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35579: LD_ADDR_EXP 41
35583: PUSH
35584: LD_EXP 41
35588: PPUSH
35589: LD_VAR 0 3
35593: PPUSH
35594: LD_EXP 41
35598: PUSH
35599: LD_INT 1
35601: ARRAY
35602: PUSH
35603: LD_INT 2
35605: ARRAY
35606: PPUSH
35607: EMPTY
35608: PPUSH
35609: CALL 42323 0 4
35613: ST_TO_ADDR
// end ; break ;
35614: GO 35618
// end ;
35616: GO 35431
35618: POP
35619: POP
// end else
35620: GO 36297
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35622: LD_VAR 0 3
35626: PPUSH
35627: LD_EXP 49
35631: PPUSH
35632: CALL 43271 0 2
35636: IFFALSE 35710
// begin for i = 1 to MREG_ToUpdate do
35638: LD_ADDR_VAR 0 2
35642: PUSH
35643: DOUBLE
35644: LD_INT 1
35646: DEC
35647: ST_TO_ADDR
35648: LD_EXP 49
35652: PUSH
35653: FOR_TO
35654: IFFALSE 35706
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35656: LD_EXP 49
35660: PUSH
35661: LD_VAR 0 2
35665: ARRAY
35666: PUSH
35667: LD_INT 1
35669: ARRAY
35670: PUSH
35671: LD_VAR 0 3
35675: EQUAL
35676: IFFALSE 35704
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35678: LD_VAR 0 3
35682: PPUSH
35683: LD_EXP 49
35687: PUSH
35688: LD_VAR 0 2
35692: ARRAY
35693: PUSH
35694: LD_INT 2
35696: ARRAY
35697: PPUSH
35698: CALL 8521 0 2
// break ;
35702: GO 35706
// end ;
35704: GO 35653
35706: POP
35707: POP
// end else
35708: GO 36297
// if MCF_Get ( side , [ f_constructed ] ) then
35710: LD_VAR 0 3
35714: PPUSH
35715: LD_INT 57
35717: PUSH
35718: EMPTY
35719: LIST
35720: PPUSH
35721: CALL 11421 0 2
35725: IFFALSE 35758
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35727: LD_VAR 0 3
35731: PPUSH
35732: LD_VAR 0 3
35736: PPUSH
35737: LD_INT 57
35739: PUSH
35740: EMPTY
35741: LIST
35742: PPUSH
35743: CALL 11421 0 2
35747: PUSH
35748: LD_INT 1
35750: ARRAY
35751: PPUSH
35752: CALL 10765 0 2
35756: GO 36297
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35758: LD_VAR 0 3
35762: PPUSH
35763: LD_EXP 47
35767: PPUSH
35768: CALL 43271 0 2
35772: PUSH
35773: LD_VAR 0 3
35777: PPUSH
35778: CALL_OW 345
35782: NOT
35783: AND
35784: PUSH
35785: LD_VAR 0 3
35789: PPUSH
35790: CALL 24822 0 1
35794: PUSH
35795: LD_INT 0
35797: EQUAL
35798: AND
35799: IFFALSE 36198
// begin for i = 1 to MREG_ToBuild do
35801: LD_ADDR_VAR 0 2
35805: PUSH
35806: DOUBLE
35807: LD_INT 1
35809: DEC
35810: ST_TO_ADDR
35811: LD_EXP 47
35815: PUSH
35816: FOR_TO
35817: IFFALSE 36194
// if MREG_ToBuild [ i ] [ 1 ] = side then
35819: LD_EXP 47
35823: PUSH
35824: LD_VAR 0 2
35828: ARRAY
35829: PUSH
35830: LD_INT 1
35832: ARRAY
35833: PUSH
35834: LD_VAR 0 3
35838: EQUAL
35839: IFFALSE 36192
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35841: LD_OWVAR 84
35845: PUSH
35846: LD_EXP 47
35850: PUSH
35851: LD_VAR 0 2
35855: ARRAY
35856: PUSH
35857: LD_INT 3
35859: ARRAY
35860: PUSH
35861: LD_INT 1
35863: ARRAY
35864: PPUSH
35865: LD_EXP 47
35869: PUSH
35870: LD_VAR 0 2
35874: ARRAY
35875: PUSH
35876: LD_INT 3
35878: ARRAY
35879: PUSH
35880: LD_INT 2
35882: ARRAY
35883: PPUSH
35884: CALL_OW 351
35888: AND
35889: IFFALSE 35933
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35891: LD_EXP 47
35895: PUSH
35896: LD_VAR 0 2
35900: ARRAY
35901: PUSH
35902: LD_INT 3
35904: ARRAY
35905: PUSH
35906: LD_INT 1
35908: ARRAY
35909: PPUSH
35910: LD_EXP 47
35914: PUSH
35915: LD_VAR 0 2
35919: ARRAY
35920: PUSH
35921: LD_INT 3
35923: ARRAY
35924: PUSH
35925: LD_INT 2
35927: ARRAY
35928: PPUSH
35929: CALL 22569 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35933: LD_EXP 47
35937: PUSH
35938: LD_VAR 0 2
35942: ARRAY
35943: PUSH
35944: LD_INT 2
35946: ARRAY
35947: PUSH
35948: LD_INT 0
35950: EQUAL
35951: IFFALSE 36021
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35953: LD_VAR 0 3
35957: PPUSH
35958: LD_EXP 47
35962: PUSH
35963: LD_VAR 0 2
35967: ARRAY
35968: PUSH
35969: LD_INT 3
35971: ARRAY
35972: PUSH
35973: LD_INT 1
35975: ARRAY
35976: PPUSH
35977: LD_EXP 47
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: PUSH
35988: LD_INT 3
35990: ARRAY
35991: PUSH
35992: LD_INT 2
35994: ARRAY
35995: PPUSH
35996: LD_EXP 47
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 3
36009: ARRAY
36010: PUSH
36011: LD_INT 3
36013: ARRAY
36014: PPUSH
36015: CALL 8357 0 4
36019: GO 36190
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
36021: LD_EXP 47
36025: PUSH
36026: LD_VAR 0 2
36030: ARRAY
36031: PUSH
36032: LD_INT 2
36034: ARRAY
36035: PUSH
36036: LD_INT 6
36038: EQUAL
36039: IFFALSE 36109
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
36041: LD_VAR 0 3
36045: PPUSH
36046: LD_EXP 47
36050: PUSH
36051: LD_VAR 0 2
36055: ARRAY
36056: PUSH
36057: LD_INT 3
36059: ARRAY
36060: PUSH
36061: LD_INT 1
36063: ARRAY
36064: PPUSH
36065: LD_EXP 47
36069: PUSH
36070: LD_VAR 0 2
36074: ARRAY
36075: PUSH
36076: LD_INT 3
36078: ARRAY
36079: PUSH
36080: LD_INT 2
36082: ARRAY
36083: PPUSH
36084: LD_EXP 47
36088: PUSH
36089: LD_VAR 0 2
36093: ARRAY
36094: PUSH
36095: LD_INT 3
36097: ARRAY
36098: PUSH
36099: LD_INT 3
36101: ARRAY
36102: PPUSH
36103: CALL 8486 0 4
36107: GO 36190
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
36109: LD_VAR 0 3
36113: PPUSH
36114: LD_EXP 47
36118: PUSH
36119: LD_VAR 0 2
36123: ARRAY
36124: PUSH
36125: LD_INT 2
36127: ARRAY
36128: PPUSH
36129: LD_EXP 47
36133: PUSH
36134: LD_VAR 0 2
36138: ARRAY
36139: PUSH
36140: LD_INT 3
36142: ARRAY
36143: PUSH
36144: LD_INT 1
36146: ARRAY
36147: PPUSH
36148: LD_EXP 47
36152: PUSH
36153: LD_VAR 0 2
36157: ARRAY
36158: PUSH
36159: LD_INT 3
36161: ARRAY
36162: PUSH
36163: LD_INT 2
36165: ARRAY
36166: PPUSH
36167: LD_EXP 47
36171: PUSH
36172: LD_VAR 0 2
36176: ARRAY
36177: PUSH
36178: LD_INT 3
36180: ARRAY
36181: PUSH
36182: LD_INT 3
36184: ARRAY
36185: PPUSH
36186: CALL 9990 0 5
// break ;
36190: GO 36194
// end ;
36192: GO 35816
36194: POP
36195: POP
// end else
36196: GO 36297
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36198: LD_VAR 0 3
36202: PPUSH
36203: LD_EXP 53
36207: PPUSH
36208: CALL 43271 0 2
36212: PUSH
36213: LD_VAR 0 3
36217: PPUSH
36218: CALL 24822 0 1
36222: PUSH
36223: LD_INT 0
36225: EQUAL
36226: AND
36227: IFFALSE 36297
// begin for i = 1 to MREG_ToDismantle do
36229: LD_ADDR_VAR 0 2
36233: PUSH
36234: DOUBLE
36235: LD_INT 1
36237: DEC
36238: ST_TO_ADDR
36239: LD_EXP 53
36243: PUSH
36244: FOR_TO
36245: IFFALSE 36295
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36247: LD_EXP 53
36251: PUSH
36252: LD_VAR 0 2
36256: ARRAY
36257: PUSH
36258: LD_INT 1
36260: ARRAY
36261: PUSH
36262: LD_VAR 0 3
36266: EQUAL
36267: IFFALSE 36293
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36269: LD_VAR 0 3
36273: PPUSH
36274: LD_EXP 53
36278: PUSH
36279: LD_VAR 0 2
36283: ARRAY
36284: PUSH
36285: LD_INT 2
36287: ARRAY
36288: PPUSH
36289: CALL 10656 0 2
// end ;
36293: GO 36244
36295: POP
36296: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36297: LD_VAR 0 3
36301: PPUSH
36302: LD_INT 30
36304: PUSH
36305: LD_INT 1
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PPUSH
36312: CALL 11421 0 2
36316: PUSH
36317: LD_VAR 0 3
36321: PPUSH
36322: CALL 24822 0 1
36326: PUSH
36327: LD_INT 0
36329: EQUAL
36330: AND
36331: IFFALSE 36342
// MCT_CollectCrates ( side ) ;
36333: LD_VAR 0 3
36337: PPUSH
36338: CALL 23761 0 1
// end ;
36342: GO 34343
36344: POP
36345: POP
// end ;
36346: LD_VAR 0 1
36350: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36351: LD_INT 0
36353: PPUSH
36354: PPUSH
36355: PPUSH
36356: PPUSH
36357: PPUSH
36358: PPUSH
36359: PPUSH
36360: PPUSH
36361: PPUSH
36362: PPUSH
36363: PPUSH
36364: PPUSH
36365: PPUSH
36366: PPUSH
36367: PPUSH
// all := MCF_All ( side , [ ] ) ;
36368: LD_ADDR_VAR 0 17
36372: PUSH
36373: LD_VAR 0 1
36377: PPUSH
36378: EMPTY
36379: PPUSH
36380: CALL 11556 0 2
36384: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36385: LD_ADDR_VAR 0 13
36389: PUSH
36390: LD_VAR 0 1
36394: PPUSH
36395: LD_INT 1
36397: PPUSH
36398: EMPTY
36399: PPUSH
36400: CALL 11504 0 3
36404: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36405: LD_ADDR_VAR 0 14
36409: PUSH
36410: LD_VAR 0 1
36414: PPUSH
36415: LD_INT 2
36417: PPUSH
36418: EMPTY
36419: PPUSH
36420: CALL 11504 0 3
36424: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36425: LD_ADDR_VAR 0 15
36429: PUSH
36430: LD_VAR 0 1
36434: PPUSH
36435: LD_INT 3
36437: PPUSH
36438: EMPTY
36439: PPUSH
36440: CALL 11504 0 3
36444: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36445: LD_ADDR_VAR 0 16
36449: PUSH
36450: LD_VAR 0 1
36454: PPUSH
36455: LD_INT 4
36457: PPUSH
36458: EMPTY
36459: PPUSH
36460: CALL 11504 0 3
36464: ST_TO_ADDR
// if mech then
36465: LD_VAR 0 15
36469: IFFALSE 36486
// mech := MCF_SortListDesc ( mech ) ;
36471: LD_ADDR_VAR 0 15
36475: PUSH
36476: LD_VAR 0 15
36480: PPUSH
36481: CALL 12670 0 1
36485: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36486: LD_EXP 57
36490: PUSH
36491: LD_VAR 0 1
36495: ARRAY
36496: PUSH
36497: LD_STRING 
36499: EQUAL
36500: NOT
36501: IFFALSE 36557
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36503: LD_EXP 57
36507: PUSH
36508: LD_VAR 0 1
36512: ARRAY
36513: PUSH
36514: LD_INT 1
36516: ARRAY
36517: PPUSH
36518: CALL_OW 257
36522: PUSH
36523: LD_INT 1
36525: EQUAL
36526: IFFALSE 36555
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36528: LD_VAR 0 1
36532: PPUSH
36533: LD_STRING ToArm
36535: PPUSH
36536: LD_EXP 57
36540: PUSH
36541: LD_VAR 0 1
36545: ARRAY
36546: PUSH
36547: LD_INT 1
36549: ARRAY
36550: PPUSH
36551: CALL 14300 0 3
// end else
36555: GO 36583
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36557: LD_ADDR_EXP 57
36561: PUSH
36562: LD_EXP 57
36566: PPUSH
36567: LD_VAR 0 1
36571: PPUSH
36572: LD_INT 1
36574: PPUSH
36575: LD_INT 0
36577: PPUSH
36578: CALL 30950 0 4
36582: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36583: LD_EXP 58
36587: PUSH
36588: LD_VAR 0 1
36592: ARRAY
36593: PUSH
36594: LD_STRING 
36596: EQUAL
36597: NOT
36598: IFFALSE 36654
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36600: LD_EXP 58
36604: PUSH
36605: LD_VAR 0 1
36609: ARRAY
36610: PUSH
36611: LD_INT 1
36613: ARRAY
36614: PPUSH
36615: CALL_OW 257
36619: PUSH
36620: LD_INT 2
36622: EQUAL
36623: IFFALSE 36652
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36625: LD_VAR 0 1
36629: PPUSH
36630: LD_STRING ToDep
36632: PPUSH
36633: LD_EXP 58
36637: PUSH
36638: LD_VAR 0 1
36642: ARRAY
36643: PUSH
36644: LD_INT 1
36646: ARRAY
36647: PPUSH
36648: CALL 14300 0 3
// end else
36652: GO 36680
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36654: LD_ADDR_EXP 58
36658: PUSH
36659: LD_EXP 58
36663: PPUSH
36664: LD_VAR 0 1
36668: PPUSH
36669: LD_INT 1
36671: PPUSH
36672: LD_INT 0
36674: PPUSH
36675: CALL 30950 0 4
36679: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36680: LD_EXP 56
36684: PUSH
36685: LD_VAR 0 1
36689: ARRAY
36690: PUSH
36691: LD_STRING 
36693: EQUAL
36694: NOT
36695: IFFALSE 36751
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36697: LD_EXP 56
36701: PUSH
36702: LD_VAR 0 1
36706: ARRAY
36707: PUSH
36708: LD_INT 1
36710: ARRAY
36711: PPUSH
36712: CALL_OW 257
36716: PUSH
36717: LD_INT 3
36719: EQUAL
36720: IFFALSE 36749
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36722: LD_VAR 0 1
36726: PPUSH
36727: LD_STRING ToFac
36729: PPUSH
36730: LD_EXP 56
36734: PUSH
36735: LD_VAR 0 1
36739: ARRAY
36740: PUSH
36741: LD_INT 1
36743: ARRAY
36744: PPUSH
36745: CALL 14300 0 3
// end else
36749: GO 36777
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36751: LD_ADDR_EXP 56
36755: PUSH
36756: LD_EXP 56
36760: PPUSH
36761: LD_VAR 0 1
36765: PPUSH
36766: LD_INT 1
36768: PPUSH
36769: LD_INT 0
36771: PPUSH
36772: CALL 30950 0 4
36776: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36777: LD_EXP 55
36781: PUSH
36782: LD_VAR 0 1
36786: ARRAY
36787: PUSH
36788: LD_STRING 
36790: EQUAL
36791: NOT
36792: IFFALSE 36848
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36794: LD_EXP 55
36798: PUSH
36799: LD_VAR 0 1
36803: ARRAY
36804: PUSH
36805: LD_INT 1
36807: ARRAY
36808: PPUSH
36809: CALL_OW 257
36813: PUSH
36814: LD_INT 4
36816: EQUAL
36817: IFFALSE 36846
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36819: LD_VAR 0 1
36823: PPUSH
36824: LD_STRING ToLab
36826: PPUSH
36827: LD_EXP 55
36831: PUSH
36832: LD_VAR 0 1
36836: ARRAY
36837: PUSH
36838: LD_INT 1
36840: ARRAY
36841: PPUSH
36842: CALL 14300 0 3
// end else
36846: GO 36874
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36848: LD_ADDR_EXP 55
36852: PUSH
36853: LD_EXP 55
36857: PPUSH
36858: LD_VAR 0 1
36862: PPUSH
36863: LD_INT 1
36865: PPUSH
36866: LD_INT 0
36868: PPUSH
36869: CALL 30950 0 4
36873: ST_TO_ADDR
// if mode = 0 then
36874: LD_VAR 0 2
36878: PUSH
36879: LD_INT 0
36881: EQUAL
36882: IFFALSE 38720
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36884: LD_VAR 0 1
36888: PPUSH
36889: LD_INT 30
36891: PUSH
36892: LD_INT 1
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PPUSH
36899: CALL 11421 0 2
36903: PUSH
36904: LD_VAR 0 1
36908: PPUSH
36909: LD_INT 21
36911: PUSH
36912: LD_INT 3
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PPUSH
36919: CALL 11421 0 2
36923: PUSH
36924: LD_INT 1
36926: EQUAL
36927: AND
36928: IFFALSE 36993
// begin if all then
36930: LD_VAR 0 17
36934: IFFALSE 36991
// for i in ( all diff eng ) do
36936: LD_ADDR_VAR 0 4
36940: PUSH
36941: LD_VAR 0 17
36945: PUSH
36946: LD_VAR 0 14
36950: DIFF
36951: PUSH
36952: FOR_IN
36953: IFFALSE 36989
// if GetTag ( i ) = 0 then
36955: LD_VAR 0 4
36959: PPUSH
36960: CALL_OW 110
36964: PUSH
36965: LD_INT 0
36967: EQUAL
36968: IFFALSE 36987
// MCH_ChangeClass ( side , i , 2 ) ;
36970: LD_VAR 0 1
36974: PPUSH
36975: LD_VAR 0 4
36979: PPUSH
36980: LD_INT 2
36982: PPUSH
36983: CALL 16328 0 3
36987: GO 36952
36989: POP
36990: POP
// end else
36991: GO 37312
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36993: LD_VAR 0 13
36997: PUSH
36998: LD_EXP 57
37002: PUSH
37003: LD_VAR 0 1
37007: ARRAY
37008: PLUS
37009: PUSH
37010: LD_INT 22
37012: PUSH
37013: LD_VAR 0 1
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 30
37024: PUSH
37025: LD_INT 32
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PPUSH
37036: CALL_OW 69
37040: LESS
37041: IFFALSE 37066
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
37043: LD_VAR 0 1
37047: PPUSH
37048: LD_VAR 0 14
37052: PUSH
37053: LD_INT 1
37055: ARRAY
37056: PPUSH
37057: LD_INT 1
37059: PPUSH
37060: CALL 16328 0 3
// end else
37064: GO 37312
// if sci < 6 and MCF_Lab ( side ) then
37066: LD_VAR 0 16
37070: PUSH
37071: LD_INT 6
37073: LESS
37074: PUSH
37075: LD_VAR 0 1
37079: PPUSH
37080: CALL 11460 0 1
37084: AND
37085: IFFALSE 37190
// begin if MREG_ToBunker [ side ] then
37087: LD_EXP 69
37091: PUSH
37092: LD_VAR 0 1
37096: ARRAY
37097: IFFALSE 37123
// tmp := sol diff MREG_ToBunker [ side ] else
37099: LD_ADDR_VAR 0 12
37103: PUSH
37104: LD_VAR 0 13
37108: PUSH
37109: LD_EXP 69
37113: PUSH
37114: LD_VAR 0 1
37118: ARRAY
37119: DIFF
37120: ST_TO_ADDR
37121: GO 37133
// tmp := sol ;
37123: LD_ADDR_VAR 0 12
37127: PUSH
37128: LD_VAR 0 13
37132: ST_TO_ADDR
// if tmp then
37133: LD_VAR 0 12
37137: IFFALSE 37188
// for i in tmp do
37139: LD_ADDR_VAR 0 4
37143: PUSH
37144: LD_VAR 0 12
37148: PUSH
37149: FOR_IN
37150: IFFALSE 37186
// if GetTag ( i ) = 0 then
37152: LD_VAR 0 4
37156: PPUSH
37157: CALL_OW 110
37161: PUSH
37162: LD_INT 0
37164: EQUAL
37165: IFFALSE 37184
// MCH_ChangeClass ( side , i , 4 ) ;
37167: LD_VAR 0 1
37171: PPUSH
37172: LD_VAR 0 4
37176: PPUSH
37177: LD_INT 4
37179: PPUSH
37180: CALL 16328 0 3
37184: GO 37149
37186: POP
37187: POP
// end else
37188: GO 37312
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37190: LD_VAR 0 1
37194: PPUSH
37195: LD_INT 30
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PPUSH
37205: CALL 11421 0 2
37209: IFFALSE 37312
// begin if MREG_ToBunker [ side ] then
37211: LD_EXP 69
37215: PUSH
37216: LD_VAR 0 1
37220: ARRAY
37221: IFFALSE 37247
// tmp := sol diff MREG_ToBunker [ side ] else
37223: LD_ADDR_VAR 0 12
37227: PUSH
37228: LD_VAR 0 13
37232: PUSH
37233: LD_EXP 69
37237: PUSH
37238: LD_VAR 0 1
37242: ARRAY
37243: DIFF
37244: ST_TO_ADDR
37245: GO 37257
// tmp := sol ;
37247: LD_ADDR_VAR 0 12
37251: PUSH
37252: LD_VAR 0 13
37256: ST_TO_ADDR
// if tmp then
37257: LD_VAR 0 12
37261: IFFALSE 37312
// for i in tmp do
37263: LD_ADDR_VAR 0 4
37267: PUSH
37268: LD_VAR 0 12
37272: PUSH
37273: FOR_IN
37274: IFFALSE 37310
// if GetTag ( i ) = 0 then
37276: LD_VAR 0 4
37280: PPUSH
37281: CALL_OW 110
37285: PUSH
37286: LD_INT 0
37288: EQUAL
37289: IFFALSE 37308
// MCH_ChangeClass ( side , i , 2 ) ;
37291: LD_VAR 0 1
37295: PPUSH
37296: LD_VAR 0 4
37300: PPUSH
37301: LD_INT 2
37303: PPUSH
37304: CALL 16328 0 3
37308: GO 37273
37310: POP
37311: POP
// end ; if MCF_Lab ( side ) then
37312: LD_VAR 0 1
37316: PPUSH
37317: CALL 11460 0 1
37321: IFFALSE 37861
// begin if MCL_GetTechList ( side ) then
37323: LD_VAR 0 1
37327: PPUSH
37328: CALL 17804 0 1
37332: IFFALSE 37458
// begin if MREG_ToLab [ side ] then
37334: LD_EXP 55
37338: PUSH
37339: LD_VAR 0 1
37343: ARRAY
37344: IFFALSE 37364
// k := MREG_ToLab [ side ] else
37346: LD_ADDR_VAR 0 8
37350: PUSH
37351: LD_EXP 55
37355: PUSH
37356: LD_VAR 0 1
37360: ARRAY
37361: ST_TO_ADDR
37362: GO 37372
// k := 0 ;
37364: LD_ADDR_VAR 0 8
37368: PUSH
37369: LD_INT 0
37371: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37372: LD_VAR 0 16
37376: PUSH
37377: LD_VAR 0 8
37381: PLUS
37382: PUSH
37383: LD_INT 6
37385: LESSEQUAL
37386: PUSH
37387: LD_VAR 0 17
37391: PUSH
37392: LD_INT 6
37394: GREATER
37395: AND
37396: IFFALSE 37412
// MCH_TrainScientist ( side , 1 ) else
37398: LD_VAR 0 1
37402: PPUSH
37403: LD_INT 1
37405: PPUSH
37406: CALL 15880 0 2
37410: GO 37456
// if all < 6 then
37412: LD_VAR 0 17
37416: PUSH
37417: LD_INT 6
37419: LESS
37420: IFFALSE 37456
// if sci + k < all / 2 then
37422: LD_VAR 0 16
37426: PUSH
37427: LD_VAR 0 8
37431: PLUS
37432: PUSH
37433: LD_VAR 0 17
37437: PUSH
37438: LD_INT 2
37440: DIVREAL
37441: LESS
37442: IFFALSE 37456
// MCH_TrainScientist ( side , 1 ) ;
37444: LD_VAR 0 1
37448: PPUSH
37449: LD_INT 1
37451: PPUSH
37452: CALL 15880 0 2
// end else
37456: GO 37534
// begin if sci > 2 then
37458: LD_VAR 0 16
37462: PUSH
37463: LD_INT 2
37465: GREATER
37466: IFFALSE 37534
// for i = sci downto 2 do
37468: LD_ADDR_VAR 0 4
37472: PUSH
37473: DOUBLE
37474: LD_VAR 0 16
37478: INC
37479: ST_TO_ADDR
37480: LD_INT 2
37482: PUSH
37483: FOR_DOWNTO
37484: IFFALSE 37532
// if GetTag ( sci [ i ] ) = 0 then
37486: LD_VAR 0 16
37490: PUSH
37491: LD_VAR 0 4
37495: ARRAY
37496: PPUSH
37497: CALL_OW 110
37501: PUSH
37502: LD_INT 0
37504: EQUAL
37505: IFFALSE 37530
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37507: LD_VAR 0 1
37511: PPUSH
37512: LD_VAR 0 16
37516: PUSH
37517: LD_VAR 0 4
37521: ARRAY
37522: PPUSH
37523: LD_INT 2
37525: PPUSH
37526: CALL 16328 0 3
37530: GO 37483
37532: POP
37533: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37534: LD_VAR 0 1
37538: PPUSH
37539: CALL 17804 0 1
37543: PUSH
37544: LD_VAR 0 1
37548: PPUSH
37549: CALL 11460 0 1
37553: AND
37554: PUSH
37555: LD_EXP 36
37559: PUSH
37560: LD_VAR 0 1
37564: ARRAY
37565: NOT
37566: AND
37567: IFFALSE 37861
// begin for j = 1 to MCF_Lab ( side ) do
37569: LD_ADDR_VAR 0 5
37573: PUSH
37574: DOUBLE
37575: LD_INT 1
37577: DEC
37578: ST_TO_ADDR
37579: LD_VAR 0 1
37583: PPUSH
37584: CALL 11460 0 1
37588: PUSH
37589: FOR_TO
37590: IFFALSE 37650
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37592: LD_VAR 0 1
37596: PPUSH
37597: CALL 11460 0 1
37601: PUSH
37602: LD_VAR 0 5
37606: ARRAY
37607: PPUSH
37608: CALL_OW 461
37612: PUSH
37613: LD_INT 3
37615: PUSH
37616: LD_INT 6
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: IN
37623: IFFALSE 37648
// begin b := MCF_Lab ( side ) [ j ] ;
37625: LD_ADDR_VAR 0 11
37629: PUSH
37630: LD_VAR 0 1
37634: PPUSH
37635: CALL 11460 0 1
37639: PUSH
37640: LD_VAR 0 5
37644: ARRAY
37645: ST_TO_ADDR
// break ;
37646: GO 37650
// end ;
37648: GO 37589
37650: POP
37651: POP
// if MCF_Class ( side , 4 , [ ] ) then
37652: LD_VAR 0 1
37656: PPUSH
37657: LD_INT 4
37659: PPUSH
37660: EMPTY
37661: PPUSH
37662: CALL 11504 0 3
37666: IFFALSE 37861
// for j in MCF_Class ( side , 4 , [ ] ) do
37668: LD_ADDR_VAR 0 5
37672: PUSH
37673: LD_VAR 0 1
37677: PPUSH
37678: LD_INT 4
37680: PPUSH
37681: EMPTY
37682: PPUSH
37683: CALL 11504 0 3
37687: PUSH
37688: FOR_IN
37689: IFFALSE 37859
// begin if GetTag ( j ) = 0 then
37691: LD_VAR 0 5
37695: PPUSH
37696: CALL_OW 110
37700: PUSH
37701: LD_INT 0
37703: EQUAL
37704: IFFALSE 37795
// begin if IsInUnit ( j ) and b then
37706: LD_VAR 0 5
37710: PPUSH
37711: CALL_OW 310
37715: PUSH
37716: LD_VAR 0 11
37720: AND
37721: IFFALSE 37769
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37723: LD_VAR 0 5
37727: PPUSH
37728: CALL_OW 310
37732: PPUSH
37733: CALL_OW 461
37737: PUSH
37738: LD_INT 2
37740: EQUAL
37741: PUSH
37742: LD_VAR 0 5
37746: PPUSH
37747: CALL_OW 310
37751: PUSH
37752: LD_VAR 0 11
37756: NONEQUAL
37757: AND
37758: IFFALSE 37769
// ComExitBuilding ( j ) ;
37760: LD_VAR 0 5
37764: PPUSH
37765: CALL_OW 122
// if not IsInUnit ( j ) then
37769: LD_VAR 0 5
37773: PPUSH
37774: CALL_OW 310
37778: NOT
37779: IFFALSE 37795
// ComEnterUnit ( j , b ) ;
37781: LD_VAR 0 5
37785: PPUSH
37786: LD_VAR 0 11
37790: PPUSH
37791: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37795: LD_INT 1
37797: PPUSH
37798: LD_VAR 0 5
37802: PPUSH
37803: CALL_OW 255
37807: PPUSH
37808: CALL_OW 321
37812: PUSH
37813: LD_INT 2
37815: EQUAL
37816: PUSH
37817: LD_VAR 0 5
37821: PPUSH
37822: CALL_OW 255
37826: PPUSH
37827: CALL 24822 0 1
37831: PUSH
37832: LD_INT 0
37834: EQUAL
37835: AND
37836: IFFALSE 37857
// MCN_Tame ( GetSide ( j ) , j ) ;
37838: LD_VAR 0 5
37842: PPUSH
37843: CALL_OW 255
37847: PPUSH
37848: LD_VAR 0 5
37852: PPUSH
37853: CALL 18323 0 2
// end ;
37857: GO 37688
37859: POP
37860: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37861: LD_VAR 0 1
37865: PPUSH
37866: LD_INT 30
37868: PUSH
37869: LD_INT 3
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PPUSH
37876: CALL 11421 0 2
37880: IFFALSE 38139
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37882: LD_ADDR_VAR 0 11
37886: PUSH
37887: LD_VAR 0 1
37891: PPUSH
37892: LD_INT 30
37894: PUSH
37895: LD_INT 3
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: PPUSH
37902: CALL 11421 0 2
37906: PUSH
37907: LD_INT 1
37909: ARRAY
37910: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37911: LD_ADDR_VAR 0 12
37915: PUSH
37916: LD_VAR 0 1
37920: PPUSH
37921: LD_INT 0
37923: PPUSH
37924: LD_INT 25
37926: PUSH
37927: LD_INT 3
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PPUSH
37934: CALL 12124 0 3
37938: ST_TO_ADDR
// for i = 1 to tmp do
37939: LD_ADDR_VAR 0 4
37943: PUSH
37944: DOUBLE
37945: LD_INT 1
37947: DEC
37948: ST_TO_ADDR
37949: LD_VAR 0 12
37953: PUSH
37954: FOR_TO
37955: IFFALSE 38015
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37957: LD_VAR 0 12
37961: PUSH
37962: LD_VAR 0 4
37966: ARRAY
37967: PPUSH
37968: CALL_OW 310
37972: NOT
37973: PUSH
37974: LD_VAR 0 12
37978: PUSH
37979: LD_VAR 0 4
37983: ARRAY
37984: PPUSH
37985: CALL_OW 314
37989: NOT
37990: AND
37991: IFFALSE 38013
// ComEnterUnit ( tmp [ i ] , b ) ;
37993: LD_VAR 0 12
37997: PUSH
37998: LD_VAR 0 4
38002: ARRAY
38003: PPUSH
38004: LD_VAR 0 11
38008: PPUSH
38009: CALL_OW 120
38013: GO 37954
38015: POP
38016: POP
// if MREG_ToFac [ side ] then
38017: LD_EXP 56
38021: PUSH
38022: LD_VAR 0 1
38026: ARRAY
38027: IFFALSE 38047
// k := MREG_ToFac [ side ] else
38029: LD_ADDR_VAR 0 8
38033: PUSH
38034: LD_EXP 56
38038: PUSH
38039: LD_VAR 0 1
38043: ARRAY
38044: ST_TO_ADDR
38045: GO 38055
// k := 0 ;
38047: LD_ADDR_VAR 0 8
38051: PUSH
38052: LD_INT 0
38054: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
38055: LD_VAR 0 15
38059: PUSH
38060: LD_VAR 0 8
38064: PLUS
38065: PUSH
38066: LD_INT 6
38068: LESSEQUAL
38069: PUSH
38070: LD_VAR 0 17
38074: PUSH
38075: LD_INT 6
38077: GREATER
38078: AND
38079: IFFALSE 38095
// MCH_TrainMechanic ( side , 1 ) else
38081: LD_VAR 0 1
38085: PPUSH
38086: LD_INT 1
38088: PPUSH
38089: CALL 15622 0 2
38093: GO 38139
// if all < 6 then
38095: LD_VAR 0 17
38099: PUSH
38100: LD_INT 6
38102: LESS
38103: IFFALSE 38139
// if mech + k < all / 2 then
38105: LD_VAR 0 15
38109: PUSH
38110: LD_VAR 0 8
38114: PLUS
38115: PUSH
38116: LD_VAR 0 17
38120: PUSH
38121: LD_INT 2
38123: DIVREAL
38124: LESS
38125: IFFALSE 38139
// MCH_TrainMechanic ( side , 1 ) ;
38127: LD_VAR 0 1
38131: PPUSH
38132: LD_INT 1
38134: PPUSH
38135: CALL 15622 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38139: LD_ADDR_VAR 0 10
38143: PUSH
38144: LD_VAR 0 1
38148: PPUSH
38149: LD_INT 30
38151: PUSH
38152: LD_INT 36
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PPUSH
38159: CALL 11421 0 2
38163: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38164: LD_VAR 0 10
38168: PUSH
38169: LD_VAR 0 15
38173: AND
38174: PUSH
38175: LD_VAR 0 1
38179: PPUSH
38180: LD_INT 3
38182: PPUSH
38183: EMPTY
38184: PPUSH
38185: CALL 11504 0 3
38189: AND
38190: IFFALSE 38348
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38192: LD_VAR 0 1
38196: PPUSH
38197: LD_INT 9
38199: PPUSH
38200: EMPTY
38201: PPUSH
38202: CALL 12124 0 3
38206: PUSH
38207: LD_INT 3
38209: LESS
38210: IFFALSE 38348
// begin if mech < 3 then
38212: LD_VAR 0 15
38216: PUSH
38217: LD_INT 3
38219: LESS
38220: IFFALSE 38234
// k := mech else
38222: LD_ADDR_VAR 0 8
38226: PUSH
38227: LD_VAR 0 15
38231: ST_TO_ADDR
38232: GO 38242
// k := 3 ;
38234: LD_ADDR_VAR 0 8
38238: PUSH
38239: LD_INT 3
38241: ST_TO_ADDR
// for j = 1 to k do
38242: LD_ADDR_VAR 0 5
38246: PUSH
38247: DOUBLE
38248: LD_INT 1
38250: DEC
38251: ST_TO_ADDR
38252: LD_VAR 0 8
38256: PUSH
38257: FOR_TO
38258: IFFALSE 38316
// if GetClass ( mech [ j ] ) = 3 then
38260: LD_VAR 0 15
38264: PUSH
38265: LD_VAR 0 5
38269: ARRAY
38270: PPUSH
38271: CALL_OW 257
38275: PUSH
38276: LD_INT 3
38278: EQUAL
38279: IFFALSE 38314
// begin SetTag ( mech [ j ] , 9 ) ;
38281: LD_VAR 0 15
38285: PUSH
38286: LD_VAR 0 5
38290: ARRAY
38291: PPUSH
38292: LD_INT 9
38294: PPUSH
38295: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38299: LD_VAR 0 15
38303: PUSH
38304: LD_VAR 0 5
38308: ARRAY
38309: PPUSH
38310: CALL_OW 122
// end ;
38314: GO 38257
38316: POP
38317: POP
// if mech < 6 + k then
38318: LD_VAR 0 15
38322: PUSH
38323: LD_INT 6
38325: PUSH
38326: LD_VAR 0 8
38330: PLUS
38331: LESS
38332: IFFALSE 38348
// MCH_TrainMechanic ( side , k ) ;
38334: LD_VAR 0 1
38338: PPUSH
38339: LD_VAR 0 8
38343: PPUSH
38344: CALL 15622 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38348: LD_VAR 0 1
38352: PPUSH
38353: LD_INT 9
38355: PPUSH
38356: EMPTY
38357: PPUSH
38358: CALL 12124 0 3
38362: IFFALSE 38453
// for j in MCF_Tag ( side , 9 , [ ] ) do
38364: LD_ADDR_VAR 0 5
38368: PUSH
38369: LD_VAR 0 1
38373: PPUSH
38374: LD_INT 9
38376: PPUSH
38377: EMPTY
38378: PPUSH
38379: CALL 12124 0 3
38383: PUSH
38384: FOR_IN
38385: IFFALSE 38451
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38387: LD_VAR 0 5
38391: PPUSH
38392: CALL_OW 310
38396: NOT
38397: PUSH
38398: LD_VAR 0 5
38402: PPUSH
38403: CALL 31593 0 1
38407: NOT
38408: AND
38409: IFFALSE 38449
// if ct then
38411: LD_VAR 0 10
38415: IFFALSE 38437
// ComEnterUnit ( j , ct [ 1 ] ) else
38417: LD_VAR 0 5
38421: PPUSH
38422: LD_VAR 0 10
38426: PUSH
38427: LD_INT 1
38429: ARRAY
38430: PPUSH
38431: CALL_OW 120
38435: GO 38449
// SetTag ( j , 0 ) ;
38437: LD_VAR 0 5
38441: PPUSH
38442: LD_INT 0
38444: PPUSH
38445: CALL_OW 109
38449: GO 38384
38451: POP
38452: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38453: LD_INT 1
38455: PPUSH
38456: LD_VAR 0 1
38460: PPUSH
38461: CALL_OW 321
38465: PUSH
38466: LD_INT 2
38468: EQUAL
38469: PUSH
38470: LD_EXP 36
38474: PUSH
38475: LD_VAR 0 1
38479: ARRAY
38480: NOT
38481: AND
38482: PUSH
38483: LD_VAR 0 1
38487: PPUSH
38488: LD_INT 4
38490: PPUSH
38491: EMPTY
38492: PPUSH
38493: CALL 11504 0 3
38497: AND
38498: IFFALSE 38546
// for j in MCF_Class ( side , 4 , [ ] ) do
38500: LD_ADDR_VAR 0 5
38504: PUSH
38505: LD_VAR 0 1
38509: PPUSH
38510: LD_INT 4
38512: PPUSH
38513: EMPTY
38514: PPUSH
38515: CALL 11504 0 3
38519: PUSH
38520: FOR_IN
38521: IFFALSE 38544
// MCN_Tame ( GetSide ( j ) , j ) ;
38523: LD_VAR 0 5
38527: PPUSH
38528: CALL_OW 255
38532: PPUSH
38533: LD_VAR 0 5
38537: PPUSH
38538: CALL 18323 0 2
38542: GO 38520
38544: POP
38545: POP
// if MREG_DefVeh [ side ] then
38546: LD_EXP 68
38550: PUSH
38551: LD_VAR 0 1
38555: ARRAY
38556: IFFALSE 38720
// begin for i in MREG_DefVeh [ side ] do
38558: LD_ADDR_VAR 0 4
38562: PUSH
38563: LD_EXP 68
38567: PUSH
38568: LD_VAR 0 1
38572: ARRAY
38573: PUSH
38574: FOR_IN
38575: IFFALSE 38628
// begin SetTag ( i , 0 ) ;
38577: LD_VAR 0 4
38581: PPUSH
38582: LD_INT 0
38584: PPUSH
38585: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38589: LD_VAR 0 4
38593: PPUSH
38594: LD_EXP 65
38598: PUSH
38599: LD_VAR 0 1
38603: ARRAY
38604: PPUSH
38605: CALL_OW 308
38609: NOT
38610: IFFALSE 38626
// MCV_Parking ( side , i ) ;
38612: LD_VAR 0 1
38616: PPUSH
38617: LD_VAR 0 4
38621: PPUSH
38622: CALL 25582 0 2
// end ;
38626: GO 38574
38628: POP
38629: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38630: LD_VAR 0 1
38634: PPUSH
38635: LD_INT 36
38637: PPUSH
38638: EMPTY
38639: PPUSH
38640: CALL 12124 0 3
38644: IFFALSE 38685
// for i in MCF_Tag ( side , 36 , [ ] ) do
38646: LD_ADDR_VAR 0 4
38650: PUSH
38651: LD_VAR 0 1
38655: PPUSH
38656: LD_INT 36
38658: PPUSH
38659: EMPTY
38660: PPUSH
38661: CALL 12124 0 3
38665: PUSH
38666: FOR_IN
38667: IFFALSE 38683
// SetTag ( i , 0 ) ;
38669: LD_VAR 0 4
38673: PPUSH
38674: LD_INT 0
38676: PPUSH
38677: CALL_OW 109
38681: GO 38666
38683: POP
38684: POP
// if MREG_DefMobActive [ side ] then
38685: LD_EXP 71
38689: PUSH
38690: LD_VAR 0 1
38694: ARRAY
38695: IFFALSE 38720
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38697: LD_ADDR_EXP 71
38701: PUSH
38702: LD_EXP 71
38706: PPUSH
38707: LD_VAR 0 1
38711: PPUSH
38712: LD_INT 0
38714: PPUSH
38715: CALL_OW 1
38719: ST_TO_ADDR
// end ; end ; if mode > 0 then
38720: LD_VAR 0 2
38724: PUSH
38725: LD_INT 0
38727: GREATER
38728: IFFALSE 40743
// begin if tick <= 15 15$00 then
38730: LD_OWVAR 1
38734: PUSH
38735: LD_INT 31500
38737: LESSEQUAL
38738: IFFALSE 39162
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38740: LD_VAR 0 13
38744: PUSH
38745: LD_INT 4
38747: GREATER
38748: PUSH
38749: LD_VAR 0 1
38753: PPUSH
38754: CALL 24822 0 1
38758: PUSH
38759: LD_INT 4
38761: LESS
38762: AND
38763: IFFALSE 38874
// for i in sol do
38765: LD_ADDR_VAR 0 4
38769: PUSH
38770: LD_VAR 0 13
38774: PUSH
38775: FOR_IN
38776: IFFALSE 38872
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38778: LD_ADDR_VAR 0 8
38782: PUSH
38783: LD_VAR 0 1
38787: PPUSH
38788: CALL 24822 0 1
38792: PPUSH
38793: LD_VAR 0 4
38797: PPUSH
38798: CALL_OW 74
38802: ST_TO_ADDR
// if IsInUnit ( i ) then
38803: LD_VAR 0 4
38807: PPUSH
38808: CALL_OW 310
38812: IFFALSE 38823
// ComExitBuilding ( i ) ;
38814: LD_VAR 0 4
38818: PPUSH
38819: CALL_OW 122
// if not HasTask ( i ) and k then
38823: LD_VAR 0 4
38827: PPUSH
38828: CALL_OW 314
38832: NOT
38833: PUSH
38834: LD_VAR 0 8
38838: AND
38839: IFFALSE 38870
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38841: LD_VAR 0 4
38845: PPUSH
38846: LD_VAR 0 8
38850: PPUSH
38851: CALL_OW 250
38855: PPUSH
38856: LD_VAR 0 8
38860: PPUSH
38861: CALL_OW 251
38865: PPUSH
38866: CALL_OW 114
// end ;
38870: GO 38775
38872: POP
38873: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38874: LD_VAR 0 1
38878: PPUSH
38879: LD_INT 30
38881: PUSH
38882: LD_INT 5
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PPUSH
38889: CALL 11421 0 2
38893: IFFALSE 39160
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38895: LD_ADDR_VAR 0 11
38899: PUSH
38900: LD_VAR 0 1
38904: PPUSH
38905: LD_INT 30
38907: PUSH
38908: LD_INT 5
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PPUSH
38915: CALL 11421 0 2
38919: PUSH
38920: LD_INT 1
38922: ARRAY
38923: ST_TO_ADDR
// if mech then
38924: LD_VAR 0 15
38928: IFFALSE 38964
// for i in mech do
38930: LD_ADDR_VAR 0 4
38934: PUSH
38935: LD_VAR 0 15
38939: PUSH
38940: FOR_IN
38941: IFFALSE 38962
// MCH_ChangeClass ( side , i , 1 ) ;
38943: LD_VAR 0 1
38947: PPUSH
38948: LD_VAR 0 4
38952: PPUSH
38953: LD_INT 1
38955: PPUSH
38956: CALL 16328 0 3
38960: GO 38940
38962: POP
38963: POP
// if eng > 1 then
38964: LD_VAR 0 14
38968: PUSH
38969: LD_INT 1
38971: GREATER
38972: IFFALSE 39019
// for i = eng downto 2 do
38974: LD_ADDR_VAR 0 4
38978: PUSH
38979: DOUBLE
38980: LD_VAR 0 14
38984: INC
38985: ST_TO_ADDR
38986: LD_INT 2
38988: PUSH
38989: FOR_DOWNTO
38990: IFFALSE 39017
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38992: LD_VAR 0 1
38996: PPUSH
38997: LD_VAR 0 14
39001: PUSH
39002: LD_VAR 0 4
39006: ARRAY
39007: PPUSH
39008: LD_INT 1
39010: PPUSH
39011: CALL 16328 0 3
39015: GO 38989
39017: POP
39018: POP
// if UnitsInside ( b ) = 6 then
39019: LD_VAR 0 11
39023: PPUSH
39024: CALL_OW 313
39028: PUSH
39029: LD_INT 6
39031: EQUAL
39032: IFFALSE 39160
// begin un := UnitsInside ( b ) [ 1 ] ;
39034: LD_ADDR_VAR 0 9
39038: PUSH
39039: LD_VAR 0 11
39043: PPUSH
39044: CALL_OW 313
39048: PUSH
39049: LD_INT 1
39051: ARRAY
39052: ST_TO_ADDR
// ComExitBuilding ( un ) ;
39053: LD_VAR 0 9
39057: PPUSH
39058: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
39062: LD_VAR 0 1
39066: PPUSH
39067: LD_INT 30
39069: PUSH
39070: LD_INT 5
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PPUSH
39077: CALL 11421 0 2
39081: PUSH
39082: LD_INT 1
39084: GREATER
39085: PUSH
39086: LD_VAR 0 1
39090: PPUSH
39091: CALL 24822 0 1
39095: PUSH
39096: LD_INT 4
39098: GREATEREQUAL
39099: AND
39100: IFFALSE 39160
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39102: LD_ADDR_VAR 0 8
39106: PUSH
39107: LD_VAR 0 1
39111: PPUSH
39112: LD_INT 30
39114: PUSH
39115: LD_INT 5
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PPUSH
39122: CALL 11421 0 2
39126: PUSH
39127: LD_INT 2
39129: ARRAY
39130: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
39131: LD_VAR 0 8
39135: PPUSH
39136: CALL_OW 313
39140: PUSH
39141: LD_INT 6
39143: LESS
39144: IFFALSE 39160
// AddComEnterUnit ( un , k ) ;
39146: LD_VAR 0 9
39150: PPUSH
39151: LD_VAR 0 8
39155: PPUSH
39156: CALL_OW 180
// end ; end ; end ; end else
39160: GO 40743
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39162: LD_VAR 0 1
39166: PPUSH
39167: LD_INT 1
39169: PPUSH
39170: LD_EXP 66
39174: PUSH
39175: LD_VAR 0 1
39179: ARRAY
39180: PUSH
39181: LD_INT 1
39183: ARRAY
39184: PPUSH
39185: CALL 33895 0 3
39189: IFFALSE 39328
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39191: LD_ADDR_VAR 0 12
39195: PUSH
39196: LD_VAR 0 1
39200: PPUSH
39201: LD_INT 21
39203: PUSH
39204: LD_INT 1
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PPUSH
39211: CALL 11421 0 2
39215: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39216: LD_ADDR_VAR 0 11
39220: PUSH
39221: LD_VAR 0 1
39225: PPUSH
39226: LD_INT 30
39228: PUSH
39229: LD_INT 1
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PPUSH
39236: CALL 11421 0 2
39240: ST_TO_ADDR
// if b then
39241: LD_VAR 0 11
39245: IFFALSE 39328
// for i in tmp do
39247: LD_ADDR_VAR 0 4
39251: PUSH
39252: LD_VAR 0 12
39256: PUSH
39257: FOR_IN
39258: IFFALSE 39326
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39260: LD_VAR 0 4
39264: PPUSH
39265: LD_EXP 66
39269: PUSH
39270: LD_VAR 0 1
39274: ARRAY
39275: PUSH
39276: LD_INT 1
39278: ARRAY
39279: PPUSH
39280: CALL_OW 308
39284: NOT
39285: IFFALSE 39324
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39287: LD_VAR 0 4
39291: PPUSH
39292: LD_VAR 0 11
39296: PUSH
39297: LD_INT 1
39299: ARRAY
39300: PPUSH
39301: CALL_OW 250
39305: PPUSH
39306: LD_VAR 0 11
39310: PUSH
39311: LD_INT 1
39313: ARRAY
39314: PPUSH
39315: CALL_OW 251
39319: PPUSH
39320: CALL_OW 111
39324: GO 39257
39326: POP
39327: POP
// end ; if MREG_DefVeh [ side ] then
39328: LD_EXP 68
39332: PUSH
39333: LD_VAR 0 1
39337: ARRAY
39338: IFFALSE 39906
// begin tmp := [ ] ;
39340: LD_ADDR_VAR 0 12
39344: PUSH
39345: EMPTY
39346: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39347: LD_EXP 71
39351: PUSH
39352: LD_VAR 0 1
39356: ARRAY
39357: PUSH
39358: LD_INT 0
39360: EQUAL
39361: IFFALSE 39501
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39363: LD_ADDR_VAR 0 8
39367: PUSH
39368: LD_VAR 0 1
39372: PPUSH
39373: LD_INT 0
39375: PPUSH
39376: LD_INT 25
39378: PUSH
39379: LD_INT 3
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PPUSH
39386: CALL 12124 0 3
39390: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39391: LD_VAR 0 8
39395: PUSH
39396: LD_EXP 68
39400: PUSH
39401: LD_VAR 0 1
39405: ARRAY
39406: GREATER
39407: IFFALSE 39468
// begin for i = 1 to MREG_DefVeh [ side ] do
39409: LD_ADDR_VAR 0 4
39413: PUSH
39414: DOUBLE
39415: LD_INT 1
39417: DEC
39418: ST_TO_ADDR
39419: LD_EXP 68
39423: PUSH
39424: LD_VAR 0 1
39428: ARRAY
39429: PUSH
39430: FOR_TO
39431: IFFALSE 39464
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39433: LD_ADDR_VAR 0 12
39437: PUSH
39438: LD_VAR 0 12
39442: PPUSH
39443: LD_INT 1
39445: PPUSH
39446: LD_VAR 0 8
39450: PUSH
39451: LD_VAR 0 4
39455: ARRAY
39456: PPUSH
39457: CALL_OW 2
39461: ST_TO_ADDR
39462: GO 39430
39464: POP
39465: POP
// end else
39466: GO 39478
// tmp := k ;
39468: LD_ADDR_VAR 0 12
39472: PUSH
39473: LD_VAR 0 8
39477: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39478: LD_ADDR_EXP 71
39482: PUSH
39483: LD_EXP 71
39487: PPUSH
39488: LD_VAR 0 1
39492: PPUSH
39493: LD_INT 1
39495: PPUSH
39496: CALL_OW 1
39500: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39501: LD_ADDR_VAR 0 4
39505: PUSH
39506: LD_EXP 68
39510: PUSH
39511: LD_VAR 0 1
39515: ARRAY
39516: PUSH
39517: FOR_IN
39518: IFFALSE 39904
// begin if not GetDriver ( i ) then
39520: LD_VAR 0 4
39524: PPUSH
39525: CALL 31644 0 1
39529: NOT
39530: IFFALSE 39605
// begin if tmp then
39532: LD_VAR 0 12
39536: IFFALSE 39603
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39538: LD_VAR 0 12
39542: PUSH
39543: LD_INT 1
39545: ARRAY
39546: PPUSH
39547: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39551: LD_VAR 0 12
39555: PUSH
39556: LD_INT 1
39558: ARRAY
39559: PPUSH
39560: LD_VAR 0 4
39564: PPUSH
39565: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39569: LD_VAR 0 12
39573: PUSH
39574: LD_INT 1
39576: ARRAY
39577: PPUSH
39578: LD_INT 36
39580: PPUSH
39581: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39585: LD_ADDR_VAR 0 12
39589: PUSH
39590: LD_VAR 0 12
39594: PPUSH
39595: LD_INT 1
39597: PPUSH
39598: CALL_OW 3
39602: ST_TO_ADDR
// end ; end else
39603: GO 39902
// begin if GetTag ( i ) = 0 then
39605: LD_VAR 0 4
39609: PPUSH
39610: CALL_OW 110
39614: PUSH
39615: LD_INT 0
39617: EQUAL
39618: IFFALSE 39634
// SetTag ( i , 31 ) else
39620: LD_VAR 0 4
39624: PPUSH
39625: LD_INT 31
39627: PPUSH
39628: CALL_OW 109
39632: GO 39902
// if GetTag ( i ) = 31 then
39634: LD_VAR 0 4
39638: PPUSH
39639: CALL_OW 110
39643: PUSH
39644: LD_INT 31
39646: EQUAL
39647: IFFALSE 39902
// begin if GetFuel ( i ) < 20 then
39649: LD_VAR 0 4
39653: PPUSH
39654: CALL_OW 261
39658: PUSH
39659: LD_INT 20
39661: LESS
39662: IFFALSE 39687
// begin SetTag ( i , 21 ) ;
39664: LD_VAR 0 4
39668: PPUSH
39669: LD_INT 21
39671: PPUSH
39672: CALL_OW 109
// MCV_Refuel ( i ) ;
39676: LD_VAR 0 4
39680: PPUSH
39681: CALL 26119 0 1
// continue ;
39685: GO 39517
// end ; if GetLives ( i ) < 700 then
39687: LD_VAR 0 4
39691: PPUSH
39692: CALL_OW 256
39696: PUSH
39697: LD_INT 700
39699: LESS
39700: IFFALSE 39812
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39702: LD_VAR 0 4
39706: PPUSH
39707: LD_EXP 59
39711: PUSH
39712: LD_VAR 0 1
39716: ARRAY
39717: PPUSH
39718: CALL_OW 308
39722: NOT
39723: IFFALSE 39747
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39725: LD_VAR 0 4
39729: PPUSH
39730: LD_EXP 59
39734: PUSH
39735: LD_VAR 0 1
39739: ARRAY
39740: PPUSH
39741: CALL_OW 113
39745: GO 39810
// if GetDriver ( i ) then
39747: LD_VAR 0 4
39751: PPUSH
39752: CALL 31644 0 1
39756: IFFALSE 39810
// begin k := GetDriver ( i ) ;
39758: LD_ADDR_VAR 0 8
39762: PUSH
39763: LD_VAR 0 4
39767: PPUSH
39768: CALL 31644 0 1
39772: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39773: LD_VAR 0 8
39777: PPUSH
39778: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39782: LD_VAR 0 8
39786: PPUSH
39787: LD_VAR 0 4
39791: PPUSH
39792: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39796: LD_VAR 0 8
39800: PPUSH
39801: LD_VAR 0 4
39805: PPUSH
39806: CALL_OW 180
// end ; end else
39810: GO 39902
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39812: LD_ADDR_VAR 0 8
39816: PUSH
39817: LD_VAR 0 1
39821: PPUSH
39822: CALL 24822 0 1
39826: PPUSH
39827: LD_VAR 0 4
39831: PPUSH
39832: CALL_OW 74
39836: ST_TO_ADDR
// if k then
39837: LD_VAR 0 8
39841: IFFALSE 39859
// ComAttackUnit ( i , k ) else
39843: LD_VAR 0 4
39847: PPUSH
39848: LD_VAR 0 8
39852: PPUSH
39853: CALL_OW 115
39857: GO 39902
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39859: LD_VAR 0 4
39863: PPUSH
39864: LD_EXP 59
39868: PUSH
39869: LD_VAR 0 1
39873: ARRAY
39874: PPUSH
39875: CALL_OW 308
39879: NOT
39880: IFFALSE 39902
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39882: LD_VAR 0 4
39886: PPUSH
39887: LD_EXP 59
39891: PUSH
39892: LD_VAR 0 1
39896: ARRAY
39897: PPUSH
39898: CALL_OW 113
// end ; end ; end ; end ;
39902: GO 39517
39904: POP
39905: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39906: LD_VAR 0 1
39910: PPUSH
39911: LD_INT 30
39913: PUSH
39914: LD_INT 5
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PPUSH
39921: CALL 11421 0 2
39925: IFFALSE 40743
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39927: LD_ADDR_VAR 0 11
39931: PUSH
39932: LD_VAR 0 1
39936: PPUSH
39937: LD_INT 30
39939: PUSH
39940: LD_INT 5
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PPUSH
39947: CALL 11421 0 2
39951: PUSH
39952: LD_INT 1
39954: ARRAY
39955: ST_TO_ADDR
// if eng > 1 then
39956: LD_VAR 0 14
39960: PUSH
39961: LD_INT 1
39963: GREATER
39964: IFFALSE 40011
// for i = eng downto 2 do
39966: LD_ADDR_VAR 0 4
39970: PUSH
39971: DOUBLE
39972: LD_VAR 0 14
39976: INC
39977: ST_TO_ADDR
39978: LD_INT 2
39980: PUSH
39981: FOR_DOWNTO
39982: IFFALSE 40009
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39984: LD_VAR 0 1
39988: PPUSH
39989: LD_VAR 0 14
39993: PUSH
39994: LD_VAR 0 4
39998: ARRAY
39999: PPUSH
40000: LD_INT 1
40002: PPUSH
40003: CALL 16328 0 3
40007: GO 39981
40009: POP
40010: POP
// if sci > 1 then
40011: LD_VAR 0 16
40015: PUSH
40016: LD_INT 1
40018: GREATER
40019: IFFALSE 40066
// for i = sci downto 2 do
40021: LD_ADDR_VAR 0 4
40025: PUSH
40026: DOUBLE
40027: LD_VAR 0 16
40031: INC
40032: ST_TO_ADDR
40033: LD_INT 2
40035: PUSH
40036: FOR_DOWNTO
40037: IFFALSE 40064
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
40039: LD_VAR 0 1
40043: PPUSH
40044: LD_VAR 0 16
40048: PUSH
40049: LD_VAR 0 4
40053: ARRAY
40054: PPUSH
40055: LD_INT 1
40057: PPUSH
40058: CALL 16328 0 3
40062: GO 40036
40064: POP
40065: POP
// if sol then
40066: LD_VAR 0 13
40070: IFFALSE 40743
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
40072: LD_VAR 0 13
40076: PUSH
40077: LD_EXP 69
40081: PUSH
40082: LD_VAR 0 1
40086: ARRAY
40087: DIFF
40088: PUSH
40089: LD_INT 22
40091: PUSH
40092: LD_VAR 0 1
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 58
40103: PUSH
40104: EMPTY
40105: LIST
40106: PUSH
40107: LD_INT 2
40109: PUSH
40110: LD_INT 30
40112: PUSH
40113: LD_INT 32
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PUSH
40120: LD_INT 30
40122: PUSH
40123: LD_INT 31
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: LIST
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: LIST
40139: PPUSH
40140: CALL_OW 69
40144: PUSH
40145: LD_INT 0
40147: EQUAL
40148: AND
40149: IFFALSE 40743
// begin tmp := sol diff MREG_ToBunker [ side ] ;
40151: LD_ADDR_VAR 0 12
40155: PUSH
40156: LD_VAR 0 13
40160: PUSH
40161: LD_EXP 69
40165: PUSH
40166: LD_VAR 0 1
40170: ARRAY
40171: DIFF
40172: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40173: LD_VAR 0 1
40177: PPUSH
40178: LD_INT 30
40180: PUSH
40181: LD_INT 5
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PPUSH
40188: CALL 11421 0 2
40192: PUSH
40193: LD_INT 1
40195: GREATER
40196: IFFALSE 40227
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40198: LD_ADDR_VAR 0 8
40202: PUSH
40203: LD_VAR 0 1
40207: PPUSH
40208: LD_INT 30
40210: PUSH
40211: LD_INT 5
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PPUSH
40218: CALL 11421 0 2
40222: PUSH
40223: LD_INT 2
40225: ARRAY
40226: ST_TO_ADDR
// for j in tmp do
40227: LD_ADDR_VAR 0 5
40231: PUSH
40232: LD_VAR 0 12
40236: PUSH
40237: FOR_IN
40238: IFFALSE 40741
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40240: LD_VAR 0 5
40244: PUSH
40245: LD_VAR 0 11
40249: PPUSH
40250: CALL_OW 313
40254: IN
40255: PUSH
40256: LD_VAR 0 11
40260: PPUSH
40261: CALL_OW 313
40265: PUSH
40266: LD_INT 6
40268: EQUAL
40269: AND
40270: PUSH
40271: LD_VAR 0 8
40275: AND
40276: PUSH
40277: LD_VAR 0 8
40281: PPUSH
40282: CALL_OW 313
40286: PUSH
40287: LD_INT 6
40289: LESS
40290: AND
40291: IFFALSE 40318
// begin ComExitBuilding ( j ) ;
40293: LD_VAR 0 5
40297: PPUSH
40298: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40302: LD_VAR 0 5
40306: PPUSH
40307: LD_VAR 0 8
40311: PPUSH
40312: CALL_OW 180
// continue ;
40316: GO 40237
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40318: LD_VAR 0 5
40322: PPUSH
40323: CALL_OW 314
40327: NOT
40328: PUSH
40329: LD_VAR 0 5
40333: PPUSH
40334: CALL_OW 110
40338: PUSH
40339: LD_INT 0
40341: EQUAL
40342: AND
40343: PUSH
40344: LD_VAR 0 5
40348: PPUSH
40349: CALL_OW 310
40353: NOT
40354: AND
40355: IFFALSE 40461
// begin if k then
40357: LD_VAR 0 8
40361: IFFALSE 40432
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40363: LD_VAR 0 8
40367: PPUSH
40368: CALL_OW 313
40372: PUSH
40373: LD_VAR 0 11
40377: PPUSH
40378: CALL_OW 313
40382: LESS
40383: IFFALSE 40401
// ComEnterUnit ( j , k ) else
40385: LD_VAR 0 5
40389: PPUSH
40390: LD_VAR 0 8
40394: PPUSH
40395: CALL_OW 120
40399: GO 40430
// if UnitsInside ( b ) < 6 then
40401: LD_VAR 0 11
40405: PPUSH
40406: CALL_OW 313
40410: PUSH
40411: LD_INT 6
40413: LESS
40414: IFFALSE 40430
// ComEnterUnit ( j , b ) ;
40416: LD_VAR 0 5
40420: PPUSH
40421: LD_VAR 0 11
40425: PPUSH
40426: CALL_OW 120
// end else
40430: GO 40461
// if UnitsInside ( b ) < 6 then
40432: LD_VAR 0 11
40436: PPUSH
40437: CALL_OW 313
40441: PUSH
40442: LD_INT 6
40444: LESS
40445: IFFALSE 40461
// ComEnterUnit ( j , b ) ;
40447: LD_VAR 0 5
40451: PPUSH
40452: LD_VAR 0 11
40456: PPUSH
40457: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40461: LD_VAR 0 5
40465: PUSH
40466: LD_VAR 0 1
40470: PPUSH
40471: LD_INT 54
40473: PUSH
40474: EMPTY
40475: LIST
40476: PPUSH
40477: CALL 11421 0 2
40481: IN
40482: PUSH
40483: LD_VAR 0 5
40487: PPUSH
40488: CALL_OW 257
40492: PUSH
40493: LD_INT 1
40495: EQUAL
40496: AND
40497: IFFALSE 40739
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40499: LD_EXP 63
40503: PUSH
40504: LD_VAR 0 1
40508: ARRAY
40509: PUSH
40510: LD_INT 1
40512: ARRAY
40513: PUSH
40514: LD_INT 12
40516: PPUSH
40517: LD_VAR 0 1
40521: PPUSH
40522: CALL_OW 321
40526: PUSH
40527: LD_INT 2
40529: EQUAL
40530: AND
40531: IFFALSE 40579
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40533: LD_VAR 0 1
40537: PPUSH
40538: LD_INT 5
40540: PPUSH
40541: EMPTY
40542: PPUSH
40543: CALL 11504 0 3
40547: PUSH
40548: LD_EXP 63
40552: PUSH
40553: LD_VAR 0 1
40557: ARRAY
40558: PUSH
40559: LD_INT 1
40561: ARRAY
40562: LESS
40563: IFFALSE 40579
// begin SetClass ( j , class_sniper ) ;
40565: LD_VAR 0 5
40569: PPUSH
40570: LD_INT 5
40572: PPUSH
40573: CALL_OW 336
// continue ;
40577: GO 40237
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40579: LD_EXP 63
40583: PUSH
40584: LD_VAR 0 1
40588: ARRAY
40589: PUSH
40590: LD_INT 2
40592: ARRAY
40593: PUSH
40594: LD_INT 41
40596: PPUSH
40597: LD_VAR 0 1
40601: PPUSH
40602: CALL_OW 321
40606: PUSH
40607: LD_INT 2
40609: EQUAL
40610: AND
40611: IFFALSE 40659
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40613: LD_VAR 0 1
40617: PPUSH
40618: LD_INT 8
40620: PPUSH
40621: EMPTY
40622: PPUSH
40623: CALL 11504 0 3
40627: PUSH
40628: LD_EXP 63
40632: PUSH
40633: LD_VAR 0 1
40637: ARRAY
40638: PUSH
40639: LD_INT 2
40641: ARRAY
40642: LESS
40643: IFFALSE 40659
// begin SetClass ( j , class_mortar ) ;
40645: LD_VAR 0 5
40649: PPUSH
40650: LD_INT 8
40652: PPUSH
40653: CALL_OW 336
// continue ;
40657: GO 40237
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40659: LD_EXP 63
40663: PUSH
40664: LD_VAR 0 1
40668: ARRAY
40669: PUSH
40670: LD_INT 3
40672: ARRAY
40673: PUSH
40674: LD_INT 44
40676: PPUSH
40677: LD_VAR 0 1
40681: PPUSH
40682: CALL_OW 321
40686: PUSH
40687: LD_INT 2
40689: EQUAL
40690: AND
40691: IFFALSE 40739
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40693: LD_VAR 0 1
40697: PPUSH
40698: LD_INT 9
40700: PPUSH
40701: EMPTY
40702: PPUSH
40703: CALL 11504 0 3
40707: PUSH
40708: LD_EXP 63
40712: PUSH
40713: LD_VAR 0 1
40717: ARRAY
40718: PUSH
40719: LD_INT 3
40721: ARRAY
40722: LESS
40723: IFFALSE 40739
// begin SetClass ( j , class_bazooker ) ;
40725: LD_VAR 0 5
40729: PPUSH
40730: LD_INT 9
40732: PPUSH
40733: CALL_OW 336
// continue ;
40737: GO 40237
// end ; end ; end ;
40739: GO 40237
40741: POP
40742: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40743: LD_INT 22
40745: PUSH
40746: LD_VAR 0 1
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 58
40757: PUSH
40758: EMPTY
40759: LIST
40760: PUSH
40761: LD_INT 30
40763: PUSH
40764: LD_INT 32
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: LIST
40775: PPUSH
40776: CALL_OW 69
40780: IFFALSE 40930
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40782: LD_ADDR_VAR 0 12
40786: PUSH
40787: LD_INT 22
40789: PUSH
40790: LD_VAR 0 1
40794: PUSH
40795: EMPTY
40796: LIST
40797: LIST
40798: PUSH
40799: LD_INT 58
40801: PUSH
40802: EMPTY
40803: LIST
40804: PUSH
40805: LD_INT 30
40807: PUSH
40808: LD_INT 32
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: LIST
40819: PPUSH
40820: CALL_OW 69
40824: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40825: LD_ADDR_VAR 0 8
40829: PUSH
40830: LD_VAR 0 13
40834: PUSH
40835: LD_EXP 69
40839: PUSH
40840: LD_VAR 0 1
40844: ARRAY
40845: DIFF
40846: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40847: LD_VAR 0 12
40851: PUSH
40852: LD_INT 1
40854: ARRAY
40855: PPUSH
40856: CALL_OW 461
40860: PUSH
40861: LD_INT 2
40863: EQUAL
40864: PUSH
40865: LD_VAR 0 12
40869: PUSH
40870: LD_INT 1
40872: ARRAY
40873: PUSH
40874: LD_EXP 69
40878: PUSH
40879: LD_VAR 0 1
40883: ARRAY
40884: IN
40885: NOT
40886: AND
40887: PUSH
40888: LD_VAR 0 8
40892: AND
40893: IFFALSE 40930
// begin ComExitBuilding ( k [ 1 ] ) ;
40895: LD_VAR 0 8
40899: PUSH
40900: LD_INT 1
40902: ARRAY
40903: PPUSH
40904: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40908: LD_VAR 0 8
40912: PUSH
40913: LD_INT 1
40915: ARRAY
40916: PPUSH
40917: LD_VAR 0 12
40921: PUSH
40922: LD_INT 1
40924: ARRAY
40925: PPUSH
40926: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40930: LD_EXP 36
40934: PUSH
40935: LD_VAR 0 1
40939: ARRAY
40940: IFFALSE 41088
// begin if MCF_Class ( side , 4 , [ ] ) then
40942: LD_VAR 0 1
40946: PPUSH
40947: LD_INT 4
40949: PPUSH
40950: EMPTY
40951: PPUSH
40952: CALL 11504 0 3
40956: IFFALSE 41086
// for j in MCF_Class ( side , 4 , [ ] ) do
40958: LD_ADDR_VAR 0 5
40962: PUSH
40963: LD_VAR 0 1
40967: PPUSH
40968: LD_INT 4
40970: PPUSH
40971: EMPTY
40972: PPUSH
40973: CALL 11504 0 3
40977: PUSH
40978: FOR_IN
40979: IFFALSE 41084
// begin if not GetTag ( j ) = 4 then
40981: LD_VAR 0 5
40985: PPUSH
40986: CALL_OW 110
40990: PUSH
40991: LD_INT 4
40993: EQUAL
40994: NOT
40995: IFFALSE 41031
// begin SetTag ( j , 4 ) ;
40997: LD_VAR 0 5
41001: PPUSH
41002: LD_INT 4
41004: PPUSH
41005: CALL_OW 109
// if IsInUnit ( j ) then
41009: LD_VAR 0 5
41013: PPUSH
41014: CALL_OW 310
41018: IFFALSE 41029
// ComExitBuilding ( j ) ;
41020: LD_VAR 0 5
41024: PPUSH
41025: CALL_OW 122
// end else
41029: GO 41082
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
41031: LD_VAR 0 5
41035: PPUSH
41036: LD_EXP 36
41040: PUSH
41041: LD_VAR 0 1
41045: ARRAY
41046: PUSH
41047: LD_INT 1
41049: ARRAY
41050: PPUSH
41051: CALL 32335 0 2
41055: NOT
41056: IFFALSE 41082
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
41058: LD_VAR 0 5
41062: PPUSH
41063: LD_EXP 36
41067: PUSH
41068: LD_VAR 0 1
41072: ARRAY
41073: PUSH
41074: LD_INT 1
41076: ARRAY
41077: PPUSH
41078: CALL 18991 0 2
// end ;
41082: GO 40978
41084: POP
41085: POP
// end else
41086: GO 41320
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
41088: LD_VAR 0 1
41092: PPUSH
41093: LD_INT 4
41095: PPUSH
41096: EMPTY
41097: PPUSH
41098: CALL 11504 0 3
41102: PUSH
41103: LD_VAR 0 1
41107: PPUSH
41108: LD_INT 4
41110: PPUSH
41111: EMPTY
41112: PPUSH
41113: CALL 12124 0 3
41117: AND
41118: IFFALSE 41320
// for j in MCF_Class ( side , 4 , [ ] ) do
41120: LD_ADDR_VAR 0 5
41124: PUSH
41125: LD_VAR 0 1
41129: PPUSH
41130: LD_INT 4
41132: PPUSH
41133: EMPTY
41134: PPUSH
41135: CALL 11504 0 3
41139: PUSH
41140: FOR_IN
41141: IFFALSE 41318
// begin if GetTag ( j ) = 4 then
41143: LD_VAR 0 5
41147: PPUSH
41148: CALL_OW 110
41152: PUSH
41153: LD_INT 4
41155: EQUAL
41156: IFFALSE 41316
// begin SetTag ( j , 0 ) ;
41158: LD_VAR 0 5
41162: PPUSH
41163: LD_INT 0
41165: PPUSH
41166: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41170: LD_VAR 0 1
41174: PPUSH
41175: CALL 11460 0 1
41179: PUSH
41180: LD_VAR 0 1
41184: PPUSH
41185: CALL 17804 0 1
41189: NOT
41190: AND
41191: IFFALSE 41216
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41193: LD_VAR 0 5
41197: PPUSH
41198: LD_VAR 0 1
41202: PPUSH
41203: CALL 11460 0 1
41207: PUSH
41208: LD_INT 1
41210: ARRAY
41211: PPUSH
41212: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41216: LD_VAR 0 1
41220: PPUSH
41221: CALL 11460 0 1
41225: NOT
41226: PUSH
41227: LD_VAR 0 1
41231: PPUSH
41232: LD_INT 30
41234: PUSH
41235: LD_INT 1
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PPUSH
41242: CALL 11421 0 2
41246: AND
41247: IFFALSE 41316
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41249: LD_VAR 0 5
41253: PPUSH
41254: LD_VAR 0 1
41258: PPUSH
41259: LD_INT 30
41261: PUSH
41262: LD_INT 1
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PPUSH
41269: CALL 11421 0 2
41273: PUSH
41274: LD_INT 1
41276: ARRAY
41277: PPUSH
41278: CALL_OW 250
41282: PPUSH
41283: LD_VAR 0 1
41287: PPUSH
41288: LD_INT 30
41290: PUSH
41291: LD_INT 1
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PPUSH
41298: CALL 11421 0 2
41302: PUSH
41303: LD_INT 1
41305: ARRAY
41306: PPUSH
41307: CALL_OW 251
41311: PPUSH
41312: CALL_OW 111
// end ; end ;
41316: GO 41140
41318: POP
41319: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41320: LD_VAR 0 1
41324: PPUSH
41325: LD_INT 3
41327: PPUSH
41328: EMPTY
41329: PPUSH
41330: CALL 11504 0 3
41334: PUSH
41335: LD_EXP 59
41339: PUSH
41340: LD_VAR 0 1
41344: ARRAY
41345: AND
41346: PUSH
41347: LD_VAR 0 1
41351: PPUSH
41352: LD_INT 6
41354: PPUSH
41355: EMPTY
41356: PPUSH
41357: CALL 12124 0 3
41361: AND
41362: IFFALSE 41893
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41364: LD_ADDR_VAR 0 6
41368: PUSH
41369: LD_EXP 59
41373: PUSH
41374: LD_VAR 0 1
41378: ARRAY
41379: PPUSH
41380: LD_INT 0
41382: PPUSH
41383: CALL_OW 517
41387: PUSH
41388: LD_INT 1
41390: ARRAY
41391: PUSH
41392: LD_INT 1
41394: ARRAY
41395: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41396: LD_ADDR_VAR 0 7
41400: PUSH
41401: LD_EXP 59
41405: PUSH
41406: LD_VAR 0 1
41410: ARRAY
41411: PPUSH
41412: LD_INT 0
41414: PPUSH
41415: CALL_OW 517
41419: PUSH
41420: LD_INT 2
41422: ARRAY
41423: PUSH
41424: LD_INT 1
41426: ARRAY
41427: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41428: LD_VAR 0 1
41432: PPUSH
41433: LD_INT 6
41435: PPUSH
41436: EMPTY
41437: PPUSH
41438: CALL 12124 0 3
41442: IFFALSE 41891
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41444: LD_ADDR_VAR 0 8
41448: PUSH
41449: LD_VAR 0 1
41453: PPUSH
41454: LD_INT 6
41456: PPUSH
41457: EMPTY
41458: PPUSH
41459: CALL 12124 0 3
41463: PUSH
41464: FOR_IN
41465: IFFALSE 41496
// if GetLives ( k ) = 1000 then
41467: LD_VAR 0 8
41471: PPUSH
41472: CALL_OW 256
41476: PUSH
41477: LD_INT 1000
41479: EQUAL
41480: IFFALSE 41494
// SetTag ( k , 0 ) ;
41482: LD_VAR 0 8
41486: PPUSH
41487: LD_INT 0
41489: PPUSH
41490: CALL_OW 109
41494: GO 41464
41496: POP
41497: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41498: LD_VAR 0 1
41502: PPUSH
41503: LD_INT 0
41505: PPUSH
41506: LD_INT 25
41508: PUSH
41509: LD_INT 3
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: PPUSH
41516: CALL 12124 0 3
41520: IFFALSE 41584
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41522: LD_ADDR_VAR 0 8
41526: PUSH
41527: LD_VAR 0 4
41531: PPUSH
41532: LD_INT 0
41534: PPUSH
41535: LD_INT 25
41537: PUSH
41538: LD_INT 3
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PPUSH
41545: CALL 12124 0 3
41549: PUSH
41550: FOR_IN
41551: IFFALSE 41582
// if GetTag ( k ) = 0 then
41553: LD_VAR 0 8
41557: PPUSH
41558: CALL_OW 110
41562: PUSH
41563: LD_INT 0
41565: EQUAL
41566: IFFALSE 41580
// begin SetTag ( k , 8 ) ;
41568: LD_VAR 0 8
41572: PPUSH
41573: LD_INT 8
41575: PPUSH
41576: CALL_OW 109
// end ;
41580: GO 41550
41582: POP
41583: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41584: LD_VAR 0 1
41588: PPUSH
41589: LD_INT 6
41591: PPUSH
41592: LD_INT 92
41594: PUSH
41595: LD_VAR 0 6
41599: PUSH
41600: LD_VAR 0 7
41604: PUSH
41605: LD_INT 10
41607: PUSH
41608: EMPTY
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: PPUSH
41614: CALL 12124 0 3
41618: IFFALSE 41742
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41620: LD_ADDR_VAR 0 5
41624: PUSH
41625: LD_VAR 0 4
41629: PPUSH
41630: LD_INT 6
41632: PPUSH
41633: LD_INT 92
41635: PUSH
41636: LD_VAR 0 6
41640: PUSH
41641: LD_VAR 0 7
41645: PUSH
41646: LD_INT 10
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: LIST
41653: LIST
41654: PPUSH
41655: CALL 12124 0 3
41659: PUSH
41660: FOR_IN
41661: IFFALSE 41740
// begin if not HasTask ( j ) and GetDriver ( j ) then
41663: LD_VAR 0 5
41667: PPUSH
41668: CALL_OW 314
41672: NOT
41673: PUSH
41674: LD_VAR 0 5
41678: PPUSH
41679: CALL 31644 0 1
41683: AND
41684: IFFALSE 41738
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41686: LD_VAR 0 5
41690: PPUSH
41691: CALL 31644 0 1
41695: PPUSH
41696: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41700: LD_VAR 0 5
41704: PPUSH
41705: CALL 31644 0 1
41709: PPUSH
41710: LD_VAR 0 5
41714: PPUSH
41715: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41719: LD_VAR 0 5
41723: PPUSH
41724: CALL 31644 0 1
41728: PPUSH
41729: LD_VAR 0 5
41733: PPUSH
41734: CALL_OW 180
// end ; end ;
41738: GO 41660
41740: POP
41741: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41742: LD_VAR 0 1
41746: PPUSH
41747: LD_INT 6
41749: PPUSH
41750: LD_INT 92
41752: PUSH
41753: LD_VAR 0 6
41757: PUSH
41758: LD_VAR 0 7
41762: PUSH
41763: LD_INT 10
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: PPUSH
41772: CALL 12124 0 3
41776: PUSH
41777: LD_VAR 0 1
41781: PPUSH
41782: LD_INT 8
41784: PPUSH
41785: EMPTY
41786: PPUSH
41787: CALL 12124 0 3
41791: AND
41792: IFFALSE 41891
// for j in MCF_Tag ( side , 8 , [ ] ) do
41794: LD_ADDR_VAR 0 5
41798: PUSH
41799: LD_VAR 0 1
41803: PPUSH
41804: LD_INT 8
41806: PPUSH
41807: EMPTY
41808: PPUSH
41809: CALL 12124 0 3
41813: PUSH
41814: FOR_IN
41815: IFFALSE 41889
// begin if IsInUnit ( j ) then
41817: LD_VAR 0 5
41821: PPUSH
41822: CALL_OW 310
41826: IFFALSE 41839
// ComExitBuilding ( j ) else
41828: LD_VAR 0 5
41832: PPUSH
41833: CALL_OW 122
41837: GO 41887
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41839: LD_VAR 0 5
41843: PPUSH
41844: LD_VAR 0 1
41848: PPUSH
41849: LD_INT 6
41851: PPUSH
41852: LD_INT 92
41854: PUSH
41855: LD_VAR 0 6
41859: PUSH
41860: LD_VAR 0 7
41864: PUSH
41865: LD_INT 10
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: LIST
41872: LIST
41873: PPUSH
41874: CALL 12124 0 3
41878: PUSH
41879: LD_INT 1
41881: ARRAY
41882: PPUSH
41883: CALL_OW 129
// end ;
41887: GO 41814
41889: POP
41890: POP
// end ; end else
41891: GO 41948
// if MCF_Tag ( side , 8 , [ ] ) then
41893: LD_VAR 0 1
41897: PPUSH
41898: LD_INT 8
41900: PPUSH
41901: EMPTY
41902: PPUSH
41903: CALL 12124 0 3
41907: IFFALSE 41948
// for k in MCF_Tag ( side , 8 , [ ] ) do
41909: LD_ADDR_VAR 0 8
41913: PUSH
41914: LD_VAR 0 1
41918: PPUSH
41919: LD_INT 8
41921: PPUSH
41922: EMPTY
41923: PPUSH
41924: CALL 12124 0 3
41928: PUSH
41929: FOR_IN
41930: IFFALSE 41946
// SetTag ( k , 0 ) ;
41932: LD_VAR 0 8
41936: PPUSH
41937: LD_INT 0
41939: PPUSH
41940: CALL_OW 109
41944: GO 41929
41946: POP
41947: POP
// end ; end_of_file
41948: LD_VAR 0 3
41952: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41953: LD_INT 0
41955: PPUSH
// MREG_Game := [ ] ;
41956: LD_ADDR_EXP 34
41960: PUSH
41961: EMPTY
41962: ST_TO_ADDR
// MREG_Crates := [ ] ;
41963: LD_ADDR_EXP 35
41967: PUSH
41968: EMPTY
41969: ST_TO_ADDR
// MREG_Heal := [ ] ;
41970: LD_ADDR_EXP 36
41974: PUSH
41975: EMPTY
41976: ST_TO_ADDR
// MREG_Tame := [ ] ;
41977: LD_ADDR_EXP 38
41981: PUSH
41982: EMPTY
41983: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41984: LD_ADDR_EXP 39
41988: PUSH
41989: EMPTY
41990: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41991: LD_ADDR_EXP 40
41995: PUSH
41996: EMPTY
41997: ST_TO_ADDR
// MREG_LabList := [ ] ;
41998: LD_ADDR_EXP 41
42002: PUSH
42003: EMPTY
42004: ST_TO_ADDR
// MREG_Cargo := [ ] ;
42005: LD_ADDR_EXP 42
42009: PUSH
42010: EMPTY
42011: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
42012: LD_ADDR_EXP 43
42016: PUSH
42017: EMPTY
42018: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
42019: LD_ADDR_EXP 44
42023: PUSH
42024: EMPTY
42025: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
42026: LD_ADDR_EXP 45
42030: PUSH
42031: EMPTY
42032: ST_TO_ADDR
// MREG_Status := [ ] ;
42033: LD_ADDR_EXP 46
42037: PUSH
42038: EMPTY
42039: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
42040: LD_ADDR_EXP 47
42044: PUSH
42045: EMPTY
42046: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
42047: LD_ADDR_EXP 48
42051: PUSH
42052: EMPTY
42053: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
42054: LD_ADDR_EXP 49
42058: PUSH
42059: EMPTY
42060: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
42061: LD_ADDR_EXP 50
42065: PUSH
42066: EMPTY
42067: ST_TO_ADDR
// MREG_ToRes := [ ] ;
42068: LD_ADDR_EXP 51
42072: PUSH
42073: EMPTY
42074: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
42075: LD_ADDR_EXP 52
42079: PUSH
42080: EMPTY
42081: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
42082: LD_ADDR_EXP 53
42086: PUSH
42087: EMPTY
42088: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
42089: LD_ADDR_EXP 54
42093: PUSH
42094: EMPTY
42095: ST_TO_ADDR
// MREG_ToLab := [ ] ;
42096: LD_ADDR_EXP 55
42100: PUSH
42101: EMPTY
42102: ST_TO_ADDR
// MREG_ToFac := [ ] ;
42103: LD_ADDR_EXP 56
42107: PUSH
42108: EMPTY
42109: ST_TO_ADDR
// MREG_ToArm := [ ] ;
42110: LD_ADDR_EXP 57
42114: PUSH
42115: EMPTY
42116: ST_TO_ADDR
// MREG_ToDep := [ ] ;
42117: LD_ADDR_EXP 58
42121: PUSH
42122: EMPTY
42123: ST_TO_ADDR
// MREG_Deposit := [ ] ;
42124: LD_ADDR_EXP 62
42128: PUSH
42129: EMPTY
42130: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
42131: LD_ADDR_EXP 63
42135: PUSH
42136: EMPTY
42137: ST_TO_ADDR
// MREG_Parking := [ ] ;
42138: LD_ADDR_EXP 59
42142: PUSH
42143: EMPTY
42144: ST_TO_ADDR
// MREG_VCombat := [ ] ;
42145: LD_ADDR_EXP 60
42149: PUSH
42150: EMPTY
42151: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
42152: LD_ADDR_EXP 64
42156: PUSH
42157: EMPTY
42158: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42159: LD_ADDR_EXP 65
42163: PUSH
42164: EMPTY
42165: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42166: LD_ADDR_EXP 66
42170: PUSH
42171: EMPTY
42172: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42173: LD_ADDR_EXP 68
42177: PUSH
42178: EMPTY
42179: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42180: LD_ADDR_EXP 69
42184: PUSH
42185: EMPTY
42186: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42187: LD_ADDR_EXP 70
42191: PUSH
42192: EMPTY
42193: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42194: LD_ADDR_EXP 72
42198: PUSH
42199: EMPTY
42200: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42201: LD_ADDR_EXP 71
42205: PUSH
42206: EMPTY
42207: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42208: LD_ADDR_EXP 73
42212: PUSH
42213: LD_INT 300
42215: PUSH
42216: LD_INT 100
42218: PUSH
42219: LD_INT 25
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: LIST
42226: ST_TO_ADDR
// end ;
42227: LD_VAR 0 1
42231: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42232: LD_INT 0
42234: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42235: LD_VAR 0 2
42239: PUSH
42240: LD_VAR 0 3
42244: PUSH
42245: LD_VAR 0 4
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: LIST
42254: PUSH
42255: LD_VAR 0 1
42259: IN
42260: IFFALSE 42274
// result := mreg_list else
42262: LD_ADDR_VAR 0 5
42266: PUSH
42267: LD_VAR 0 1
42271: ST_TO_ADDR
42272: GO 42308
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42274: LD_ADDR_VAR 0 1
42278: PUSH
42279: LD_VAR 0 1
42283: PUSH
42284: LD_VAR 0 2
42288: PUSH
42289: LD_VAR 0 3
42293: PUSH
42294: LD_VAR 0 4
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: LIST
42303: PUSH
42304: EMPTY
42305: LIST
42306: ADD
42307: ST_TO_ADDR
// result := mreg_list ;
42308: LD_ADDR_VAR 0 5
42312: PUSH
42313: LD_VAR 0 1
42317: ST_TO_ADDR
// end ;
42318: LD_VAR 0 5
42322: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42323: LD_INT 0
42325: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42326: LD_VAR 0 2
42330: PUSH
42331: LD_VAR 0 3
42335: PUSH
42336: LD_VAR 0 4
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: LIST
42345: PUSH
42346: LD_VAR 0 1
42350: IN
42351: IFFALSE 42389
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42353: LD_ADDR_VAR 0 5
42357: PUSH
42358: LD_VAR 0 1
42362: PUSH
42363: LD_VAR 0 2
42367: PUSH
42368: LD_VAR 0 3
42372: PUSH
42373: LD_VAR 0 4
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: LIST
42382: PUSH
42383: EMPTY
42384: LIST
42385: DIFF
42386: ST_TO_ADDR
42387: GO 42399
// result := mreg_list ;
42389: LD_ADDR_VAR 0 5
42393: PUSH
42394: LD_VAR 0 1
42398: ST_TO_ADDR
// end ;
42399: LD_VAR 0 5
42403: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42404: LD_INT 0
42406: PPUSH
42407: PPUSH
42408: PPUSH
// for j = 1 to 8 do
42409: LD_ADDR_VAR 0 3
42413: PUSH
42414: DOUBLE
42415: LD_INT 1
42417: DEC
42418: ST_TO_ADDR
42419: LD_INT 8
42421: PUSH
42422: FOR_TO
42423: IFFALSE 43264
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42425: LD_VAR 0 3
42429: PPUSH
42430: LD_INT 51
42432: PUSH
42433: EMPTY
42434: LIST
42435: PPUSH
42436: CALL 11421 0 2
42440: PUSH
42441: LD_OWVAR 2
42445: PUSH
42446: LD_VAR 0 3
42450: EQUAL
42451: NOT
42452: AND
42453: IFFALSE 42471
// MREG_SidesList := MREG_SidesList ^ 1 else
42455: LD_ADDR_EXP 40
42459: PUSH
42460: LD_EXP 40
42464: PUSH
42465: LD_INT 1
42467: ADD
42468: ST_TO_ADDR
42469: GO 42485
// MREG_SidesList := MREG_SidesList ^ 0 ;
42471: LD_ADDR_EXP 40
42475: PUSH
42476: LD_EXP 40
42480: PUSH
42481: LD_INT 0
42483: ADD
42484: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42485: LD_VAR 0 3
42489: PPUSH
42490: LD_INT 2
42492: PUSH
42493: LD_INT 34
42495: PUSH
42496: LD_INT 12
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 34
42505: PUSH
42506: LD_INT 32
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: LD_INT 34
42515: PUSH
42516: LD_INT 51
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: LIST
42527: LIST
42528: PUSH
42529: EMPTY
42530: LIST
42531: PPUSH
42532: CALL 11722 0 2
42536: IFFALSE 42637
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42538: LD_ADDR_VAR 0 2
42542: PUSH
42543: LD_VAR 0 3
42547: PPUSH
42548: LD_INT 2
42550: PUSH
42551: LD_INT 34
42553: PUSH
42554: LD_INT 12
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 34
42563: PUSH
42564: LD_INT 32
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 34
42573: PUSH
42574: LD_INT 51
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: LIST
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PPUSH
42590: CALL 11722 0 2
42594: PUSH
42595: FOR_IN
42596: IFFALSE 42635
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42598: LD_ADDR_EXP 42
42602: PUSH
42603: LD_EXP 42
42607: PPUSH
42608: LD_VAR 0 3
42612: PPUSH
42613: LD_VAR 0 2
42617: PPUSH
42618: LD_VAR 0 2
42622: PPUSH
42623: CALL_OW 264
42627: PPUSH
42628: CALL 42232 0 4
42632: ST_TO_ADDR
42633: GO 42595
42635: POP
42636: POP
// if MCF_Class ( j , 4 , [ ] ) then
42637: LD_VAR 0 3
42641: PPUSH
42642: LD_INT 4
42644: PPUSH
42645: EMPTY
42646: PPUSH
42647: CALL 11504 0 3
42651: IFFALSE 42684
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42653: LD_ADDR_EXP 55
42657: PUSH
42658: LD_EXP 55
42662: PUSH
42663: LD_VAR 0 3
42667: PPUSH
42668: LD_INT 4
42670: PPUSH
42671: EMPTY
42672: PPUSH
42673: CALL 11504 0 3
42677: PUSH
42678: EMPTY
42679: LIST
42680: ADD
42681: ST_TO_ADDR
42682: GO 42701
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42684: LD_ADDR_EXP 55
42688: PUSH
42689: LD_EXP 55
42693: PUSH
42694: LD_INT 0
42696: PUSH
42697: EMPTY
42698: LIST
42699: ADD
42700: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42701: LD_VAR 0 3
42705: PPUSH
42706: LD_INT 3
42708: PPUSH
42709: EMPTY
42710: PPUSH
42711: CALL 11504 0 3
42715: IFFALSE 42748
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42717: LD_ADDR_EXP 56
42721: PUSH
42722: LD_EXP 56
42726: PUSH
42727: LD_VAR 0 3
42731: PPUSH
42732: LD_INT 3
42734: PPUSH
42735: EMPTY
42736: PPUSH
42737: CALL 11504 0 3
42741: PUSH
42742: EMPTY
42743: LIST
42744: ADD
42745: ST_TO_ADDR
42746: GO 42765
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42748: LD_ADDR_EXP 56
42752: PUSH
42753: LD_EXP 56
42757: PUSH
42758: LD_INT 0
42760: PUSH
42761: EMPTY
42762: LIST
42763: ADD
42764: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42765: LD_VAR 0 3
42769: PPUSH
42770: LD_INT 1
42772: PPUSH
42773: EMPTY
42774: PPUSH
42775: CALL 11504 0 3
42779: IFFALSE 42812
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42781: LD_ADDR_EXP 57
42785: PUSH
42786: LD_EXP 57
42790: PUSH
42791: LD_VAR 0 3
42795: PPUSH
42796: LD_INT 1
42798: PPUSH
42799: EMPTY
42800: PPUSH
42801: CALL 11504 0 3
42805: PUSH
42806: EMPTY
42807: LIST
42808: ADD
42809: ST_TO_ADDR
42810: GO 42829
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42812: LD_ADDR_EXP 57
42816: PUSH
42817: LD_EXP 57
42821: PUSH
42822: LD_INT 0
42824: PUSH
42825: EMPTY
42826: LIST
42827: ADD
42828: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42829: LD_VAR 0 3
42833: PPUSH
42834: LD_INT 2
42836: PPUSH
42837: EMPTY
42838: PPUSH
42839: CALL 11504 0 3
42843: IFFALSE 42876
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42845: LD_ADDR_EXP 58
42849: PUSH
42850: LD_EXP 58
42854: PUSH
42855: LD_VAR 0 3
42859: PPUSH
42860: LD_INT 2
42862: PPUSH
42863: EMPTY
42864: PPUSH
42865: CALL 11504 0 3
42869: PUSH
42870: EMPTY
42871: LIST
42872: ADD
42873: ST_TO_ADDR
42874: GO 42893
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42876: LD_ADDR_EXP 58
42880: PUSH
42881: LD_EXP 58
42885: PUSH
42886: LD_INT 0
42888: PUSH
42889: EMPTY
42890: LIST
42891: ADD
42892: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42893: LD_ADDR_EXP 48
42897: PUSH
42898: LD_EXP 48
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: EMPTY
42907: LIST
42908: ADD
42909: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42910: LD_ADDR_EXP 36
42914: PUSH
42915: LD_EXP 36
42919: PUSH
42920: LD_INT 0
42922: PUSH
42923: EMPTY
42924: LIST
42925: ADD
42926: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42927: LD_ADDR_EXP 38
42931: PUSH
42932: LD_EXP 38
42936: PUSH
42937: LD_INT 0
42939: PUSH
42940: EMPTY
42941: LIST
42942: ADD
42943: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42944: LD_ADDR_EXP 59
42948: PUSH
42949: LD_EXP 59
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: EMPTY
42958: LIST
42959: ADD
42960: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42961: LD_ADDR_EXP 60
42965: PUSH
42966: LD_EXP 60
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: EMPTY
42975: LIST
42976: ADD
42977: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42978: LD_ADDR_EXP 52
42982: PUSH
42983: LD_EXP 52
42987: PUSH
42988: LD_INT 0
42990: PUSH
42991: EMPTY
42992: LIST
42993: ADD
42994: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42995: LD_ADDR_EXP 39
42999: PUSH
43000: LD_EXP 39
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: LD_INT 0
43010: PUSH
43011: LD_INT 0
43013: PUSH
43014: LD_INT 0
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: LIST
43021: LIST
43022: PUSH
43023: EMPTY
43024: LIST
43025: ADD
43026: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
43027: LD_ADDR_EXP 61
43031: PUSH
43032: LD_EXP 61
43036: PUSH
43037: LD_INT 0
43039: PUSH
43040: EMPTY
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PUSH
43046: EMPTY
43047: LIST
43048: ADD
43049: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
43050: LD_ADDR_EXP 62
43054: PUSH
43055: LD_EXP 62
43059: PUSH
43060: LD_INT 0
43062: PUSH
43063: EMPTY
43064: LIST
43065: PUSH
43066: EMPTY
43067: LIST
43068: ADD
43069: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
43070: LD_ADDR_EXP 43
43074: PUSH
43075: LD_EXP 43
43079: PUSH
43080: LD_INT 0
43082: PUSH
43083: EMPTY
43084: LIST
43085: ADD
43086: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
43087: LD_ADDR_EXP 64
43091: PUSH
43092: LD_EXP 64
43096: PUSH
43097: LD_INT 0
43099: PUSH
43100: EMPTY
43101: LIST
43102: ADD
43103: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
43104: LD_ADDR_EXP 65
43108: PUSH
43109: LD_EXP 65
43113: PUSH
43114: LD_INT 0
43116: PUSH
43117: EMPTY
43118: LIST
43119: ADD
43120: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
43121: LD_ADDR_EXP 66
43125: PUSH
43126: LD_EXP 66
43130: PUSH
43131: LD_INT 0
43133: PUSH
43134: EMPTY
43135: LIST
43136: ADD
43137: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
43138: LD_ADDR_EXP 67
43142: PUSH
43143: LD_EXP 67
43147: PUSH
43148: LD_INT 0
43150: PUSH
43151: EMPTY
43152: LIST
43153: ADD
43154: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
43155: LD_ADDR_EXP 68
43159: PUSH
43160: LD_EXP 68
43164: PUSH
43165: LD_INT 0
43167: PUSH
43168: EMPTY
43169: LIST
43170: ADD
43171: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43172: LD_ADDR_EXP 69
43176: PUSH
43177: LD_EXP 69
43181: PUSH
43182: LD_INT 0
43184: PUSH
43185: EMPTY
43186: LIST
43187: ADD
43188: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43189: LD_ADDR_EXP 70
43193: PUSH
43194: LD_EXP 70
43198: PUSH
43199: LD_INT 0
43201: PUSH
43202: EMPTY
43203: LIST
43204: ADD
43205: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43206: LD_ADDR_EXP 72
43210: PUSH
43211: LD_EXP 72
43215: PUSH
43216: LD_INT 0
43218: PUSH
43219: EMPTY
43220: LIST
43221: ADD
43222: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43223: LD_ADDR_EXP 71
43227: PUSH
43228: LD_EXP 71
43232: PUSH
43233: LD_INT 0
43235: ADD
43236: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43237: LD_ADDR_EXP 63
43241: PUSH
43242: LD_EXP 63
43246: PUSH
43247: LD_INT 0
43249: PUSH
43250: LD_INT 0
43252: PUSH
43253: LD_INT 0
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: LIST
43260: ADD
43261: ST_TO_ADDR
// end ;
43262: GO 42422
43264: POP
43265: POP
// end ;
43266: LD_VAR 0 1
43270: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43271: LD_INT 0
43273: PPUSH
43274: PPUSH
43275: PPUSH
// m := false ;
43276: LD_ADDR_VAR 0 5
43280: PUSH
43281: LD_INT 0
43283: ST_TO_ADDR
// for i = 1 to mreg do
43284: LD_ADDR_VAR 0 4
43288: PUSH
43289: DOUBLE
43290: LD_INT 1
43292: DEC
43293: ST_TO_ADDR
43294: LD_VAR 0 2
43298: PUSH
43299: FOR_TO
43300: IFFALSE 43336
// if mreg [ i ] [ 1 ] = side then
43302: LD_VAR 0 2
43306: PUSH
43307: LD_VAR 0 4
43311: ARRAY
43312: PUSH
43313: LD_INT 1
43315: ARRAY
43316: PUSH
43317: LD_VAR 0 1
43321: EQUAL
43322: IFFALSE 43334
// begin m := true ;
43324: LD_ADDR_VAR 0 5
43328: PUSH
43329: LD_INT 1
43331: ST_TO_ADDR
// break ;
43332: GO 43336
// end ;
43334: GO 43299
43336: POP
43337: POP
// result := m ;
43338: LD_ADDR_VAR 0 3
43342: PUSH
43343: LD_VAR 0 5
43347: ST_TO_ADDR
// end ;
43348: LD_VAR 0 3
43352: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43353: LD_INT 0
43355: PPUSH
43356: PPUSH
43357: PPUSH
// m := 0 ;
43358: LD_ADDR_VAR 0 5
43362: PUSH
43363: LD_INT 0
43365: ST_TO_ADDR
// for i = 1 to mreg do
43366: LD_ADDR_VAR 0 4
43370: PUSH
43371: DOUBLE
43372: LD_INT 1
43374: DEC
43375: ST_TO_ADDR
43376: LD_VAR 0 2
43380: PUSH
43381: FOR_TO
43382: IFFALSE 43422
// if mreg [ i ] [ 1 ] = side then
43384: LD_VAR 0 2
43388: PUSH
43389: LD_VAR 0 4
43393: ARRAY
43394: PUSH
43395: LD_INT 1
43397: ARRAY
43398: PUSH
43399: LD_VAR 0 1
43403: EQUAL
43404: IFFALSE 43420
// begin m := m + 1 ;
43406: LD_ADDR_VAR 0 5
43410: PUSH
43411: LD_VAR 0 5
43415: PUSH
43416: LD_INT 1
43418: PLUS
43419: ST_TO_ADDR
// end ;
43420: GO 43381
43422: POP
43423: POP
// result := m ;
43424: LD_ADDR_VAR 0 3
43428: PUSH
43429: LD_VAR 0 5
43433: ST_TO_ADDR
// end ;
43434: LD_VAR 0 3
43438: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43439: LD_INT 0
43441: PPUSH
43442: PPUSH
// result := 0 ;
43443: LD_ADDR_VAR 0 3
43447: PUSH
43448: LD_INT 0
43450: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43451: LD_ADDR_VAR 0 4
43455: PUSH
43456: DOUBLE
43457: LD_INT 1
43459: DEC
43460: ST_TO_ADDR
43461: LD_EXP 54
43465: PUSH
43466: FOR_TO
43467: IFFALSE 43529
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43469: LD_EXP 54
43473: PUSH
43474: LD_VAR 0 4
43478: ARRAY
43479: PUSH
43480: LD_INT 1
43482: ARRAY
43483: PUSH
43484: LD_VAR 0 1
43488: EQUAL
43489: PUSH
43490: LD_EXP 54
43494: PUSH
43495: LD_VAR 0 4
43499: ARRAY
43500: PUSH
43501: LD_INT 2
43503: ARRAY
43504: PUSH
43505: LD_VAR 0 2
43509: EQUAL
43510: AND
43511: IFFALSE 43527
// begin result := result + 1 ;
43513: LD_ADDR_VAR 0 3
43517: PUSH
43518: LD_VAR 0 3
43522: PUSH
43523: LD_INT 1
43525: PLUS
43526: ST_TO_ADDR
// end ;
43527: GO 43466
43529: POP
43530: POP
// end ; end_of_file
43531: LD_VAR 0 3
43535: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
43536: GO 43538
43538: DISABLE
// begin ru_radar := 98 ;
43539: LD_ADDR_EXP 74
43543: PUSH
43544: LD_INT 98
43546: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43547: LD_ADDR_EXP 75
43551: PUSH
43552: LD_INT 89
43554: ST_TO_ADDR
// us_hack := 99 ;
43555: LD_ADDR_EXP 76
43559: PUSH
43560: LD_INT 99
43562: ST_TO_ADDR
// us_artillery := 97 ;
43563: LD_ADDR_EXP 77
43567: PUSH
43568: LD_INT 97
43570: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43571: LD_ADDR_EXP 78
43575: PUSH
43576: LD_INT 91
43578: ST_TO_ADDR
// end ; end_of_file end_of_file
43579: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
43580: GO 43582
43582: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
43583: LD_STRING initStreamRollete();
43585: PPUSH
43586: CALL_OW 559
// InitStreamMode ;
43590: CALL 43595 0 0
// end ;
43594: END
// function InitStreamMode ; begin
43595: LD_INT 0
43597: PPUSH
// streamModeActive := false ;
43598: LD_ADDR_EXP 79
43602: PUSH
43603: LD_INT 0
43605: ST_TO_ADDR
// sRocket := false ;
43606: LD_ADDR_EXP 82
43610: PUSH
43611: LD_INT 0
43613: ST_TO_ADDR
// sSpeed := false ;
43614: LD_ADDR_EXP 81
43618: PUSH
43619: LD_INT 0
43621: ST_TO_ADDR
// sEngine := false ;
43622: LD_ADDR_EXP 83
43626: PUSH
43627: LD_INT 0
43629: ST_TO_ADDR
// sSpec := false ;
43630: LD_ADDR_EXP 80
43634: PUSH
43635: LD_INT 0
43637: ST_TO_ADDR
// sLevel := false ;
43638: LD_ADDR_EXP 84
43642: PUSH
43643: LD_INT 0
43645: ST_TO_ADDR
// sArmoury := false ;
43646: LD_ADDR_EXP 85
43650: PUSH
43651: LD_INT 0
43653: ST_TO_ADDR
// sRadar := false ;
43654: LD_ADDR_EXP 86
43658: PUSH
43659: LD_INT 0
43661: ST_TO_ADDR
// sBunker := false ;
43662: LD_ADDR_EXP 87
43666: PUSH
43667: LD_INT 0
43669: ST_TO_ADDR
// sHack := false ;
43670: LD_ADDR_EXP 88
43674: PUSH
43675: LD_INT 0
43677: ST_TO_ADDR
// sFire := false ;
43678: LD_ADDR_EXP 89
43682: PUSH
43683: LD_INT 0
43685: ST_TO_ADDR
// sRefresh := false ;
43686: LD_ADDR_EXP 90
43690: PUSH
43691: LD_INT 0
43693: ST_TO_ADDR
// sExp := false ;
43694: LD_ADDR_EXP 91
43698: PUSH
43699: LD_INT 0
43701: ST_TO_ADDR
// sDepot := false ;
43702: LD_ADDR_EXP 92
43706: PUSH
43707: LD_INT 0
43709: ST_TO_ADDR
// sFlag := false ;
43710: LD_ADDR_EXP 93
43714: PUSH
43715: LD_INT 0
43717: ST_TO_ADDR
// sKamikadze := false ;
43718: LD_ADDR_EXP 101
43722: PUSH
43723: LD_INT 0
43725: ST_TO_ADDR
// sTroll := false ;
43726: LD_ADDR_EXP 102
43730: PUSH
43731: LD_INT 0
43733: ST_TO_ADDR
// sSlow := false ;
43734: LD_ADDR_EXP 103
43738: PUSH
43739: LD_INT 0
43741: ST_TO_ADDR
// sLack := false ;
43742: LD_ADDR_EXP 104
43746: PUSH
43747: LD_INT 0
43749: ST_TO_ADDR
// sTank := false ;
43750: LD_ADDR_EXP 106
43754: PUSH
43755: LD_INT 0
43757: ST_TO_ADDR
// sRemote := false ;
43758: LD_ADDR_EXP 107
43762: PUSH
43763: LD_INT 0
43765: ST_TO_ADDR
// sSold := false ;
43766: LD_ADDR_EXP 94
43770: PUSH
43771: LD_INT 0
43773: ST_TO_ADDR
// sDiff := false ;
43774: LD_ADDR_EXP 95
43778: PUSH
43779: LD_INT 0
43781: ST_TO_ADDR
// sFog := false ;
43782: LD_ADDR_EXP 98
43786: PUSH
43787: LD_INT 0
43789: ST_TO_ADDR
// sReset := false ;
43790: LD_ADDR_EXP 99
43794: PUSH
43795: LD_INT 0
43797: ST_TO_ADDR
// sSun := false ;
43798: LD_ADDR_EXP 100
43802: PUSH
43803: LD_INT 0
43805: ST_TO_ADDR
// sTiger := false ;
43806: LD_ADDR_EXP 96
43810: PUSH
43811: LD_INT 0
43813: ST_TO_ADDR
// sBomb := false ;
43814: LD_ADDR_EXP 97
43818: PUSH
43819: LD_INT 0
43821: ST_TO_ADDR
// sWound := false ;
43822: LD_ADDR_EXP 105
43826: PUSH
43827: LD_INT 0
43829: ST_TO_ADDR
// end ;
43830: LD_VAR 0 1
43834: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
43835: LD_VAR 0 2
43839: PUSH
43840: LD_INT 100
43842: EQUAL
43843: IFFALSE 44378
// begin if not StreamModeActive then
43845: LD_EXP 79
43849: NOT
43850: IFFALSE 43860
// StreamModeActive := true ;
43852: LD_ADDR_EXP 79
43856: PUSH
43857: LD_INT 1
43859: ST_TO_ADDR
// if p3 = 0 then
43860: LD_VAR 0 3
43864: PUSH
43865: LD_INT 0
43867: EQUAL
43868: IFFALSE 43874
// InitStreamMode ;
43870: CALL 43595 0 0
// if p3 = 1 then
43874: LD_VAR 0 3
43878: PUSH
43879: LD_INT 1
43881: EQUAL
43882: IFFALSE 43892
// sRocket := true ;
43884: LD_ADDR_EXP 82
43888: PUSH
43889: LD_INT 1
43891: ST_TO_ADDR
// if p3 = 2 then
43892: LD_VAR 0 3
43896: PUSH
43897: LD_INT 2
43899: EQUAL
43900: IFFALSE 43910
// sSpeed := true ;
43902: LD_ADDR_EXP 81
43906: PUSH
43907: LD_INT 1
43909: ST_TO_ADDR
// if p3 = 3 then
43910: LD_VAR 0 3
43914: PUSH
43915: LD_INT 3
43917: EQUAL
43918: IFFALSE 43928
// sEngine := true ;
43920: LD_ADDR_EXP 83
43924: PUSH
43925: LD_INT 1
43927: ST_TO_ADDR
// if p3 = 4 then
43928: LD_VAR 0 3
43932: PUSH
43933: LD_INT 4
43935: EQUAL
43936: IFFALSE 43946
// sSpec := true ;
43938: LD_ADDR_EXP 80
43942: PUSH
43943: LD_INT 1
43945: ST_TO_ADDR
// if p3 = 5 then
43946: LD_VAR 0 3
43950: PUSH
43951: LD_INT 5
43953: EQUAL
43954: IFFALSE 43964
// sLevel := true ;
43956: LD_ADDR_EXP 84
43960: PUSH
43961: LD_INT 1
43963: ST_TO_ADDR
// if p3 = 6 then
43964: LD_VAR 0 3
43968: PUSH
43969: LD_INT 6
43971: EQUAL
43972: IFFALSE 43982
// sArmoury := true ;
43974: LD_ADDR_EXP 85
43978: PUSH
43979: LD_INT 1
43981: ST_TO_ADDR
// if p3 = 7 then
43982: LD_VAR 0 3
43986: PUSH
43987: LD_INT 7
43989: EQUAL
43990: IFFALSE 44000
// sRadar := true ;
43992: LD_ADDR_EXP 86
43996: PUSH
43997: LD_INT 1
43999: ST_TO_ADDR
// if p3 = 8 then
44000: LD_VAR 0 3
44004: PUSH
44005: LD_INT 8
44007: EQUAL
44008: IFFALSE 44018
// sBunker := true ;
44010: LD_ADDR_EXP 87
44014: PUSH
44015: LD_INT 1
44017: ST_TO_ADDR
// if p3 = 9 then
44018: LD_VAR 0 3
44022: PUSH
44023: LD_INT 9
44025: EQUAL
44026: IFFALSE 44036
// sHack := true ;
44028: LD_ADDR_EXP 88
44032: PUSH
44033: LD_INT 1
44035: ST_TO_ADDR
// if p3 = 10 then
44036: LD_VAR 0 3
44040: PUSH
44041: LD_INT 10
44043: EQUAL
44044: IFFALSE 44054
// sFire := true ;
44046: LD_ADDR_EXP 89
44050: PUSH
44051: LD_INT 1
44053: ST_TO_ADDR
// if p3 = 11 then
44054: LD_VAR 0 3
44058: PUSH
44059: LD_INT 11
44061: EQUAL
44062: IFFALSE 44072
// sRefresh := true ;
44064: LD_ADDR_EXP 90
44068: PUSH
44069: LD_INT 1
44071: ST_TO_ADDR
// if p3 = 12 then
44072: LD_VAR 0 3
44076: PUSH
44077: LD_INT 12
44079: EQUAL
44080: IFFALSE 44090
// sExp := true ;
44082: LD_ADDR_EXP 91
44086: PUSH
44087: LD_INT 1
44089: ST_TO_ADDR
// if p3 = 13 then
44090: LD_VAR 0 3
44094: PUSH
44095: LD_INT 13
44097: EQUAL
44098: IFFALSE 44108
// sDepot := true ;
44100: LD_ADDR_EXP 92
44104: PUSH
44105: LD_INT 1
44107: ST_TO_ADDR
// if p3 = 14 then
44108: LD_VAR 0 3
44112: PUSH
44113: LD_INT 14
44115: EQUAL
44116: IFFALSE 44126
// sFlag := true ;
44118: LD_ADDR_EXP 93
44122: PUSH
44123: LD_INT 1
44125: ST_TO_ADDR
// if p3 = 15 then
44126: LD_VAR 0 3
44130: PUSH
44131: LD_INT 15
44133: EQUAL
44134: IFFALSE 44144
// sKamikadze := true ;
44136: LD_ADDR_EXP 101
44140: PUSH
44141: LD_INT 1
44143: ST_TO_ADDR
// if p3 = 16 then
44144: LD_VAR 0 3
44148: PUSH
44149: LD_INT 16
44151: EQUAL
44152: IFFALSE 44162
// sTroll := true ;
44154: LD_ADDR_EXP 102
44158: PUSH
44159: LD_INT 1
44161: ST_TO_ADDR
// if p3 = 17 then
44162: LD_VAR 0 3
44166: PUSH
44167: LD_INT 17
44169: EQUAL
44170: IFFALSE 44180
// sSlow := true ;
44172: LD_ADDR_EXP 103
44176: PUSH
44177: LD_INT 1
44179: ST_TO_ADDR
// if p3 = 18 then
44180: LD_VAR 0 3
44184: PUSH
44185: LD_INT 18
44187: EQUAL
44188: IFFALSE 44198
// sLack := true ;
44190: LD_ADDR_EXP 104
44194: PUSH
44195: LD_INT 1
44197: ST_TO_ADDR
// if p3 = 19 then
44198: LD_VAR 0 3
44202: PUSH
44203: LD_INT 19
44205: EQUAL
44206: IFFALSE 44216
// sTank := true ;
44208: LD_ADDR_EXP 106
44212: PUSH
44213: LD_INT 1
44215: ST_TO_ADDR
// if p3 = 20 then
44216: LD_VAR 0 3
44220: PUSH
44221: LD_INT 20
44223: EQUAL
44224: IFFALSE 44234
// sRemote := true ;
44226: LD_ADDR_EXP 107
44230: PUSH
44231: LD_INT 1
44233: ST_TO_ADDR
// if p3 = 101 then
44234: LD_VAR 0 3
44238: PUSH
44239: LD_INT 101
44241: EQUAL
44242: IFFALSE 44252
// sSold := true ;
44244: LD_ADDR_EXP 94
44248: PUSH
44249: LD_INT 1
44251: ST_TO_ADDR
// if p3 = 102 then
44252: LD_VAR 0 3
44256: PUSH
44257: LD_INT 102
44259: EQUAL
44260: IFFALSE 44270
// sDiff := true ;
44262: LD_ADDR_EXP 95
44266: PUSH
44267: LD_INT 1
44269: ST_TO_ADDR
// if p3 = 103 then
44270: LD_VAR 0 3
44274: PUSH
44275: LD_INT 103
44277: EQUAL
44278: IFFALSE 44288
// sFog := true ;
44280: LD_ADDR_EXP 98
44284: PUSH
44285: LD_INT 1
44287: ST_TO_ADDR
// if p3 = 104 then
44288: LD_VAR 0 3
44292: PUSH
44293: LD_INT 104
44295: EQUAL
44296: IFFALSE 44306
// sReset := true ;
44298: LD_ADDR_EXP 99
44302: PUSH
44303: LD_INT 1
44305: ST_TO_ADDR
// if p3 = 105 then
44306: LD_VAR 0 3
44310: PUSH
44311: LD_INT 105
44313: EQUAL
44314: IFFALSE 44324
// sSun := true ;
44316: LD_ADDR_EXP 100
44320: PUSH
44321: LD_INT 1
44323: ST_TO_ADDR
// if p3 = 106 then
44324: LD_VAR 0 3
44328: PUSH
44329: LD_INT 106
44331: EQUAL
44332: IFFALSE 44342
// sTiger := true ;
44334: LD_ADDR_EXP 96
44338: PUSH
44339: LD_INT 1
44341: ST_TO_ADDR
// if p3 = 107 then
44342: LD_VAR 0 3
44346: PUSH
44347: LD_INT 107
44349: EQUAL
44350: IFFALSE 44360
// sBomb := true ;
44352: LD_ADDR_EXP 97
44356: PUSH
44357: LD_INT 1
44359: ST_TO_ADDR
// if p3 = 108 then
44360: LD_VAR 0 3
44364: PUSH
44365: LD_INT 108
44367: EQUAL
44368: IFFALSE 44378
// sWound := true ;
44370: LD_ADDR_EXP 105
44374: PUSH
44375: LD_INT 1
44377: ST_TO_ADDR
// end ; end ;
44378: PPOPN 6
44380: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
44381: LD_EXP 79
44385: PUSH
44386: LD_EXP 82
44390: AND
44391: IFFALSE 44512
44393: GO 44395
44395: DISABLE
44396: LD_INT 0
44398: PPUSH
44399: PPUSH
// begin enable ;
44400: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
44401: LD_ADDR_VAR 0 2
44405: PUSH
44406: LD_INT 22
44408: PUSH
44409: LD_OWVAR 2
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 2
44420: PUSH
44421: LD_INT 34
44423: PUSH
44424: LD_INT 7
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 34
44433: PUSH
44434: LD_INT 45
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 34
44443: PUSH
44444: LD_INT 28
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 34
44453: PUSH
44454: LD_INT 47
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: PUSH
44468: EMPTY
44469: LIST
44470: LIST
44471: PPUSH
44472: CALL_OW 69
44476: ST_TO_ADDR
// if not tmp then
44477: LD_VAR 0 2
44481: NOT
44482: IFFALSE 44486
// exit ;
44484: GO 44512
// for i in tmp do
44486: LD_ADDR_VAR 0 1
44490: PUSH
44491: LD_VAR 0 2
44495: PUSH
44496: FOR_IN
44497: IFFALSE 44510
// begin DestroyUnit ( i ) ;
44499: LD_VAR 0 1
44503: PPUSH
44504: CALL_OW 65
// end ;
44508: GO 44496
44510: POP
44511: POP
// end ;
44512: PPOPN 2
44514: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
44515: LD_EXP 79
44519: PUSH
44520: LD_EXP 83
44524: AND
44525: IFFALSE 44606
44527: GO 44529
44529: DISABLE
44530: LD_INT 0
44532: PPUSH
44533: PPUSH
// begin enable ;
44534: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
44535: LD_ADDR_VAR 0 2
44539: PUSH
44540: LD_INT 22
44542: PUSH
44543: LD_OWVAR 2
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: PUSH
44552: LD_INT 32
44554: PUSH
44555: LD_INT 3
44557: PUSH
44558: EMPTY
44559: LIST
44560: LIST
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PPUSH
44566: CALL_OW 69
44570: ST_TO_ADDR
// if not tmp then
44571: LD_VAR 0 2
44575: NOT
44576: IFFALSE 44580
// exit ;
44578: GO 44606
// for i in tmp do
44580: LD_ADDR_VAR 0 1
44584: PUSH
44585: LD_VAR 0 2
44589: PUSH
44590: FOR_IN
44591: IFFALSE 44604
// begin DestroyUnit ( i ) ;
44593: LD_VAR 0 1
44597: PPUSH
44598: CALL_OW 65
// end ;
44602: GO 44590
44604: POP
44605: POP
// end ;
44606: PPOPN 2
44608: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
44609: LD_EXP 79
44613: PUSH
44614: LD_EXP 80
44618: AND
44619: IFFALSE 44712
44621: GO 44623
44623: DISABLE
44624: LD_INT 0
44626: PPUSH
// begin enable ;
44627: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
44628: LD_ADDR_VAR 0 1
44632: PUSH
44633: LD_INT 22
44635: PUSH
44636: LD_OWVAR 2
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 2
44647: PUSH
44648: LD_INT 25
44650: PUSH
44651: LD_INT 5
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 25
44660: PUSH
44661: LD_INT 9
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 25
44670: PUSH
44671: LD_INT 8
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PPUSH
44688: CALL_OW 69
44692: PUSH
44693: FOR_IN
44694: IFFALSE 44710
// begin SetClass ( i , 1 ) ;
44696: LD_VAR 0 1
44700: PPUSH
44701: LD_INT 1
44703: PPUSH
44704: CALL_OW 336
// end ;
44708: GO 44693
44710: POP
44711: POP
// end ;
44712: PPOPN 1
44714: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
44715: LD_EXP 79
44719: PUSH
44720: LD_EXP 81
44724: AND
44725: PUSH
44726: LD_OWVAR 65
44730: PUSH
44731: LD_INT 7
44733: LESS
44734: AND
44735: IFFALSE 44749
44737: GO 44739
44739: DISABLE
// begin enable ;
44740: ENABLE
// game_speed := 7 ;
44741: LD_ADDR_OWVAR 65
44745: PUSH
44746: LD_INT 7
44748: ST_TO_ADDR
// end ;
44749: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
44750: LD_EXP 79
44754: PUSH
44755: LD_EXP 84
44759: AND
44760: IFFALSE 44962
44762: GO 44764
44764: DISABLE
44765: LD_INT 0
44767: PPUSH
44768: PPUSH
44769: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
44770: LD_ADDR_VAR 0 3
44774: PUSH
44775: LD_INT 81
44777: PUSH
44778: LD_OWVAR 2
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 21
44789: PUSH
44790: LD_INT 1
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PPUSH
44801: CALL_OW 69
44805: ST_TO_ADDR
// if not tmp then
44806: LD_VAR 0 3
44810: NOT
44811: IFFALSE 44815
// exit ;
44813: GO 44962
// if tmp > 5 then
44815: LD_VAR 0 3
44819: PUSH
44820: LD_INT 5
44822: GREATER
44823: IFFALSE 44835
// k := 5 else
44825: LD_ADDR_VAR 0 2
44829: PUSH
44830: LD_INT 5
44832: ST_TO_ADDR
44833: GO 44845
// k := tmp ;
44835: LD_ADDR_VAR 0 2
44839: PUSH
44840: LD_VAR 0 3
44844: ST_TO_ADDR
// for i := 1 to k do
44845: LD_ADDR_VAR 0 1
44849: PUSH
44850: DOUBLE
44851: LD_INT 1
44853: DEC
44854: ST_TO_ADDR
44855: LD_VAR 0 2
44859: PUSH
44860: FOR_TO
44861: IFFALSE 44960
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
44863: LD_VAR 0 3
44867: PUSH
44868: LD_VAR 0 1
44872: ARRAY
44873: PPUSH
44874: LD_VAR 0 1
44878: PUSH
44879: LD_INT 4
44881: MOD
44882: PUSH
44883: LD_INT 1
44885: PLUS
44886: PPUSH
44887: CALL_OW 259
44891: PUSH
44892: LD_INT 10
44894: LESS
44895: IFFALSE 44958
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
44897: LD_VAR 0 3
44901: PUSH
44902: LD_VAR 0 1
44906: ARRAY
44907: PPUSH
44908: LD_VAR 0 1
44912: PUSH
44913: LD_INT 4
44915: MOD
44916: PUSH
44917: LD_INT 1
44919: PLUS
44920: PPUSH
44921: LD_VAR 0 3
44925: PUSH
44926: LD_VAR 0 1
44930: ARRAY
44931: PPUSH
44932: LD_VAR 0 1
44936: PUSH
44937: LD_INT 4
44939: MOD
44940: PUSH
44941: LD_INT 1
44943: PLUS
44944: PPUSH
44945: CALL_OW 259
44949: PUSH
44950: LD_INT 1
44952: PLUS
44953: PPUSH
44954: CALL_OW 237
44958: GO 44860
44960: POP
44961: POP
// end ;
44962: PPOPN 3
44964: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
44965: LD_EXP 79
44969: PUSH
44970: LD_EXP 85
44974: AND
44975: IFFALSE 44995
44977: GO 44979
44979: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
44980: LD_INT 4
44982: PPUSH
44983: LD_OWVAR 2
44987: PPUSH
44988: LD_INT 0
44990: PPUSH
44991: CALL_OW 324
44995: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
44996: LD_EXP 79
45000: PUSH
45001: LD_EXP 86
45005: AND
45006: IFFALSE 45105
45008: GO 45010
45010: DISABLE
45011: LD_INT 0
45013: PPUSH
45014: PPUSH
// begin enable ;
45015: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
45016: LD_ADDR_VAR 0 2
45020: PUSH
45021: LD_INT 22
45023: PUSH
45024: LD_OWVAR 2
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 2
45035: PUSH
45036: LD_INT 34
45038: PUSH
45039: LD_INT 11
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 34
45048: PUSH
45049: LD_INT 30
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: LIST
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PPUSH
45065: CALL_OW 69
45069: ST_TO_ADDR
// if not tmp then
45070: LD_VAR 0 2
45074: NOT
45075: IFFALSE 45079
// exit ;
45077: GO 45105
// for i in tmp do
45079: LD_ADDR_VAR 0 1
45083: PUSH
45084: LD_VAR 0 2
45088: PUSH
45089: FOR_IN
45090: IFFALSE 45103
// begin DestroyUnit ( i ) ;
45092: LD_VAR 0 1
45096: PPUSH
45097: CALL_OW 65
// end ;
45101: GO 45089
45103: POP
45104: POP
// end ;
45105: PPOPN 2
45107: END
// every 0 0$1 trigger StreamModeActive and sBunker do
45108: LD_EXP 79
45112: PUSH
45113: LD_EXP 87
45117: AND
45118: IFFALSE 45138
45120: GO 45122
45122: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
45123: LD_INT 32
45125: PPUSH
45126: LD_OWVAR 2
45130: PPUSH
45131: LD_INT 0
45133: PPUSH
45134: CALL_OW 324
45138: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
45139: LD_EXP 79
45143: PUSH
45144: LD_EXP 88
45148: AND
45149: IFFALSE 45330
45151: GO 45153
45153: DISABLE
45154: LD_INT 0
45156: PPUSH
45157: PPUSH
45158: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
45159: LD_ADDR_VAR 0 2
45163: PUSH
45164: LD_INT 22
45166: PUSH
45167: LD_OWVAR 2
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 33
45178: PUSH
45179: LD_INT 3
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PPUSH
45190: CALL_OW 69
45194: ST_TO_ADDR
// if not tmp then
45195: LD_VAR 0 2
45199: NOT
45200: IFFALSE 45204
// exit ;
45202: GO 45330
// side := 0 ;
45204: LD_ADDR_VAR 0 3
45208: PUSH
45209: LD_INT 0
45211: ST_TO_ADDR
// for i := 1 to 8 do
45212: LD_ADDR_VAR 0 1
45216: PUSH
45217: DOUBLE
45218: LD_INT 1
45220: DEC
45221: ST_TO_ADDR
45222: LD_INT 8
45224: PUSH
45225: FOR_TO
45226: IFFALSE 45274
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
45228: LD_OWVAR 2
45232: PUSH
45233: LD_VAR 0 1
45237: NONEQUAL
45238: PUSH
45239: LD_OWVAR 2
45243: PPUSH
45244: LD_VAR 0 1
45248: PPUSH
45249: CALL_OW 81
45253: PUSH
45254: LD_INT 2
45256: EQUAL
45257: AND
45258: IFFALSE 45272
// begin side := i ;
45260: LD_ADDR_VAR 0 3
45264: PUSH
45265: LD_VAR 0 1
45269: ST_TO_ADDR
// break ;
45270: GO 45274
// end ;
45272: GO 45225
45274: POP
45275: POP
// if not side then
45276: LD_VAR 0 3
45280: NOT
45281: IFFALSE 45285
// exit ;
45283: GO 45330
// for i := 1 to tmp do
45285: LD_ADDR_VAR 0 1
45289: PUSH
45290: DOUBLE
45291: LD_INT 1
45293: DEC
45294: ST_TO_ADDR
45295: LD_VAR 0 2
45299: PUSH
45300: FOR_TO
45301: IFFALSE 45328
// if Prob ( 30 ) then
45303: LD_INT 30
45305: PPUSH
45306: CALL_OW 13
45310: IFFALSE 45326
// SetSide ( i , side ) ;
45312: LD_VAR 0 1
45316: PPUSH
45317: LD_VAR 0 3
45321: PPUSH
45322: CALL_OW 235
45326: GO 45300
45328: POP
45329: POP
// end ;
45330: PPOPN 3
45332: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
45333: LD_EXP 79
45337: PUSH
45338: LD_EXP 90
45342: AND
45343: IFFALSE 45462
45345: GO 45347
45347: DISABLE
45348: LD_INT 0
45350: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
45351: LD_ADDR_VAR 0 1
45355: PUSH
45356: LD_INT 22
45358: PUSH
45359: LD_OWVAR 2
45363: PUSH
45364: EMPTY
45365: LIST
45366: LIST
45367: PUSH
45368: LD_INT 21
45370: PUSH
45371: LD_INT 1
45373: PUSH
45374: EMPTY
45375: LIST
45376: LIST
45377: PUSH
45378: LD_INT 3
45380: PUSH
45381: LD_INT 23
45383: PUSH
45384: LD_INT 0
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: EMPTY
45392: LIST
45393: LIST
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: LIST
45399: PPUSH
45400: CALL_OW 69
45404: PUSH
45405: FOR_IN
45406: IFFALSE 45460
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
45408: LD_VAR 0 1
45412: PPUSH
45413: CALL_OW 257
45417: PUSH
45418: LD_INT 1
45420: PUSH
45421: LD_INT 2
45423: PUSH
45424: LD_INT 3
45426: PUSH
45427: LD_INT 4
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: IN
45436: IFFALSE 45458
// SetClass ( un , rand ( 1 , 4 ) ) ;
45438: LD_VAR 0 1
45442: PPUSH
45443: LD_INT 1
45445: PPUSH
45446: LD_INT 4
45448: PPUSH
45449: CALL_OW 12
45453: PPUSH
45454: CALL_OW 336
45458: GO 45405
45460: POP
45461: POP
// end ;
45462: PPOPN 1
45464: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
45465: LD_EXP 79
45469: PUSH
45470: LD_EXP 89
45474: AND
45475: IFFALSE 45554
45477: GO 45479
45479: DISABLE
45480: LD_INT 0
45482: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
45483: LD_ADDR_VAR 0 1
45487: PUSH
45488: LD_INT 22
45490: PUSH
45491: LD_OWVAR 2
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: PUSH
45500: LD_INT 21
45502: PUSH
45503: LD_INT 3
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PPUSH
45514: CALL_OW 69
45518: ST_TO_ADDR
// if not tmp then
45519: LD_VAR 0 1
45523: NOT
45524: IFFALSE 45528
// exit ;
45526: GO 45554
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
45528: LD_VAR 0 1
45532: PUSH
45533: LD_INT 1
45535: PPUSH
45536: LD_VAR 0 1
45540: PPUSH
45541: CALL_OW 12
45545: ARRAY
45546: PPUSH
45547: LD_INT 100
45549: PPUSH
45550: CALL_OW 234
// end ;
45554: PPOPN 1
45556: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
45557: LD_EXP 79
45561: PUSH
45562: LD_EXP 91
45566: AND
45567: IFFALSE 45665
45569: GO 45571
45571: DISABLE
45572: LD_INT 0
45574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
45575: LD_ADDR_VAR 0 1
45579: PUSH
45580: LD_INT 22
45582: PUSH
45583: LD_OWVAR 2
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 21
45594: PUSH
45595: LD_INT 1
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PPUSH
45606: CALL_OW 69
45610: ST_TO_ADDR
// if not tmp then
45611: LD_VAR 0 1
45615: NOT
45616: IFFALSE 45620
// exit ;
45618: GO 45665
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
45620: LD_VAR 0 1
45624: PUSH
45625: LD_INT 1
45627: PPUSH
45628: LD_VAR 0 1
45632: PPUSH
45633: CALL_OW 12
45637: ARRAY
45638: PPUSH
45639: LD_INT 1
45641: PPUSH
45642: LD_INT 4
45644: PPUSH
45645: CALL_OW 12
45649: PPUSH
45650: LD_INT 3000
45652: PPUSH
45653: LD_INT 9000
45655: PPUSH
45656: CALL_OW 12
45660: PPUSH
45661: CALL_OW 492
// end ;
45665: PPOPN 1
45667: END
// every 0 0$1 trigger StreamModeActive and sDepot do
45668: LD_EXP 79
45672: PUSH
45673: LD_EXP 92
45677: AND
45678: IFFALSE 45698
45680: GO 45682
45682: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
45683: LD_INT 1
45685: PPUSH
45686: LD_OWVAR 2
45690: PPUSH
45691: LD_INT 0
45693: PPUSH
45694: CALL_OW 324
45698: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
45699: LD_EXP 79
45703: PUSH
45704: LD_EXP 93
45708: AND
45709: IFFALSE 45792
45711: GO 45713
45713: DISABLE
45714: LD_INT 0
45716: PPUSH
45717: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
45718: LD_ADDR_VAR 0 2
45722: PUSH
45723: LD_INT 22
45725: PUSH
45726: LD_OWVAR 2
45730: PUSH
45731: EMPTY
45732: LIST
45733: LIST
45734: PUSH
45735: LD_INT 21
45737: PUSH
45738: LD_INT 3
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PPUSH
45749: CALL_OW 69
45753: ST_TO_ADDR
// if not tmp then
45754: LD_VAR 0 2
45758: NOT
45759: IFFALSE 45763
// exit ;
45761: GO 45792
// for i in tmp do
45763: LD_ADDR_VAR 0 1
45767: PUSH
45768: LD_VAR 0 2
45772: PUSH
45773: FOR_IN
45774: IFFALSE 45790
// SetBLevel ( i , 10 ) ;
45776: LD_VAR 0 1
45780: PPUSH
45781: LD_INT 10
45783: PPUSH
45784: CALL_OW 241
45788: GO 45773
45790: POP
45791: POP
// end ;
45792: PPOPN 2
45794: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
45795: LD_EXP 79
45799: PUSH
45800: LD_EXP 94
45804: AND
45805: IFFALSE 45908
45807: GO 45809
45809: DISABLE
45810: LD_INT 0
45812: PPUSH
45813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
45814: LD_ADDR_VAR 0 2
45818: PUSH
45819: LD_INT 22
45821: PUSH
45822: LD_OWVAR 2
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 25
45833: PUSH
45834: LD_INT 1
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: PPUSH
45845: CALL_OW 69
45849: ST_TO_ADDR
// if not tmp then
45850: LD_VAR 0 2
45854: NOT
45855: IFFALSE 45859
// exit ;
45857: GO 45908
// for i in tmp do
45859: LD_ADDR_VAR 0 1
45863: PUSH
45864: LD_VAR 0 2
45868: PUSH
45869: FOR_IN
45870: IFFALSE 45906
// begin if Crawls ( i ) then
45872: LD_VAR 0 1
45876: PPUSH
45877: CALL_OW 318
45881: IFFALSE 45892
// ComWalk ( i ) ;
45883: LD_VAR 0 1
45887: PPUSH
45888: CALL_OW 138
// SetClass ( i , 4 ) ;
45892: LD_VAR 0 1
45896: PPUSH
45897: LD_INT 4
45899: PPUSH
45900: CALL_OW 336
// end ;
45904: GO 45869
45906: POP
45907: POP
// end ;
45908: PPOPN 2
45910: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
45911: LD_EXP 79
45915: PUSH
45916: LD_EXP 95
45920: AND
45921: PUSH
45922: LD_OWVAR 67
45926: PUSH
45927: LD_INT 3
45929: LESS
45930: AND
45931: IFFALSE 45950
45933: GO 45935
45935: DISABLE
// Difficulty := Difficulty + 1 ;
45936: LD_ADDR_OWVAR 67
45940: PUSH
45941: LD_OWVAR 67
45945: PUSH
45946: LD_INT 1
45948: PLUS
45949: ST_TO_ADDR
45950: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
45951: LD_EXP 79
45955: PUSH
45956: LD_EXP 96
45960: AND
45961: IFFALSE 46064
45963: GO 45965
45965: DISABLE
45966: LD_INT 0
45968: PPUSH
// begin for i := 1 to 5 do
45969: LD_ADDR_VAR 0 1
45973: PUSH
45974: DOUBLE
45975: LD_INT 1
45977: DEC
45978: ST_TO_ADDR
45979: LD_INT 5
45981: PUSH
45982: FOR_TO
45983: IFFALSE 46062
// begin uc_nation := nation_nature ;
45985: LD_ADDR_OWVAR 21
45989: PUSH
45990: LD_INT 0
45992: ST_TO_ADDR
// uc_side := 0 ;
45993: LD_ADDR_OWVAR 20
45997: PUSH
45998: LD_INT 0
46000: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
46001: LD_ADDR_OWVAR 29
46005: PUSH
46006: LD_INT 12
46008: PUSH
46009: LD_INT 12
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: ST_TO_ADDR
// hc_agressivity := 20 ;
46016: LD_ADDR_OWVAR 35
46020: PUSH
46021: LD_INT 20
46023: ST_TO_ADDR
// hc_class := class_tiger ;
46024: LD_ADDR_OWVAR 28
46028: PUSH
46029: LD_INT 14
46031: ST_TO_ADDR
// hc_gallery :=  ;
46032: LD_ADDR_OWVAR 33
46036: PUSH
46037: LD_STRING 
46039: ST_TO_ADDR
// hc_name :=  ;
46040: LD_ADDR_OWVAR 26
46044: PUSH
46045: LD_STRING 
46047: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
46048: CALL_OW 44
46052: PPUSH
46053: LD_INT 0
46055: PPUSH
46056: CALL_OW 51
// end ;
46060: GO 45982
46062: POP
46063: POP
// end ;
46064: PPOPN 1
46066: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
46067: LD_EXP 79
46071: PUSH
46072: LD_EXP 97
46076: AND
46077: IFFALSE 46251
46079: GO 46081
46081: DISABLE
46082: LD_INT 0
46084: PPUSH
46085: PPUSH
46086: PPUSH
46087: PPUSH
// begin result := false ;
46088: LD_ADDR_VAR 0 4
46092: PUSH
46093: LD_INT 0
46095: ST_TO_ADDR
// for i := 1 to 8 do
46096: LD_ADDR_VAR 0 1
46100: PUSH
46101: DOUBLE
46102: LD_INT 1
46104: DEC
46105: ST_TO_ADDR
46106: LD_INT 8
46108: PUSH
46109: FOR_TO
46110: IFFALSE 46221
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
46112: LD_ADDR_VAR 0 2
46116: PUSH
46117: LD_INT 10
46119: PUSH
46120: LD_INT 50
46122: PUSH
46123: LD_INT 90
46125: PUSH
46126: LD_INT 140
46128: PUSH
46129: EMPTY
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 1
46137: PPUSH
46138: LD_INT 4
46140: PPUSH
46141: CALL_OW 12
46145: ARRAY
46146: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
46147: LD_ADDR_VAR 0 3
46151: PUSH
46152: LD_INT 10
46154: PUSH
46155: LD_INT 50
46157: PUSH
46158: LD_INT 90
46160: PUSH
46161: LD_INT 140
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: PUSH
46170: LD_INT 1
46172: PPUSH
46173: LD_INT 4
46175: PPUSH
46176: CALL_OW 12
46180: ARRAY
46181: ST_TO_ADDR
// if ValidHex ( x , y ) then
46182: LD_VAR 0 2
46186: PPUSH
46187: LD_VAR 0 3
46191: PPUSH
46192: CALL_OW 488
46196: IFFALSE 46219
// begin result := [ x , y ] ;
46198: LD_ADDR_VAR 0 4
46202: PUSH
46203: LD_VAR 0 2
46207: PUSH
46208: LD_VAR 0 3
46212: PUSH
46213: EMPTY
46214: LIST
46215: LIST
46216: ST_TO_ADDR
// break ;
46217: GO 46221
// end ; end ;
46219: GO 46109
46221: POP
46222: POP
// if result then
46223: LD_VAR 0 4
46227: IFFALSE 46251
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
46229: LD_VAR 0 4
46233: PUSH
46234: LD_INT 1
46236: ARRAY
46237: PPUSH
46238: LD_VAR 0 4
46242: PUSH
46243: LD_INT 2
46245: ARRAY
46246: PPUSH
46247: CALL_OW 429
// end ;
46251: PPOPN 4
46253: END
// every 0 0$1 trigger StreamModeActive and sReset do
46254: LD_EXP 79
46258: PUSH
46259: LD_EXP 99
46263: AND
46264: IFFALSE 46276
46266: GO 46268
46268: DISABLE
// YouLost (  ) ;
46269: LD_STRING 
46271: PPUSH
46272: CALL_OW 104
46276: END
// every 0 0$1 trigger StreamModeActive and sFog do
46277: LD_EXP 79
46281: PUSH
46282: LD_EXP 98
46286: AND
46287: IFFALSE 46301
46289: GO 46291
46291: DISABLE
// FogOff ( your_side ) ;
46292: LD_OWVAR 2
46296: PPUSH
46297: CALL_OW 344
46301: END
// every 0 0$1 trigger StreamModeActive and sSun do
46302: LD_EXP 79
46306: PUSH
46307: LD_EXP 100
46311: AND
46312: IFFALSE 46340
46314: GO 46316
46316: DISABLE
// begin solar_recharge_percent := 0 ;
46317: LD_ADDR_OWVAR 79
46321: PUSH
46322: LD_INT 0
46324: ST_TO_ADDR
// wait ( 5 5$00 ) ;
46325: LD_INT 10500
46327: PPUSH
46328: CALL_OW 67
// solar_recharge_percent := 100 ;
46332: LD_ADDR_OWVAR 79
46336: PUSH
46337: LD_INT 100
46339: ST_TO_ADDR
// end ;
46340: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
46341: LD_EXP 79
46345: PUSH
46346: LD_EXP 101
46350: AND
46351: IFFALSE 46506
46353: GO 46355
46355: DISABLE
46356: LD_INT 0
46358: PPUSH
46359: PPUSH
// begin for i := 1 to 6 do
46360: LD_ADDR_VAR 0 1
46364: PUSH
46365: DOUBLE
46366: LD_INT 1
46368: DEC
46369: ST_TO_ADDR
46370: LD_INT 6
46372: PUSH
46373: FOR_TO
46374: IFFALSE 46504
// begin uc_nation := nation_nature ;
46376: LD_ADDR_OWVAR 21
46380: PUSH
46381: LD_INT 0
46383: ST_TO_ADDR
// uc_side := 0 ;
46384: LD_ADDR_OWVAR 20
46388: PUSH
46389: LD_INT 0
46391: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
46392: LD_ADDR_OWVAR 29
46396: PUSH
46397: LD_INT 12
46399: PUSH
46400: LD_INT 12
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: ST_TO_ADDR
// hc_agressivity := 20 ;
46407: LD_ADDR_OWVAR 35
46411: PUSH
46412: LD_INT 20
46414: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
46415: LD_ADDR_OWVAR 28
46419: PUSH
46420: LD_INT 17
46422: ST_TO_ADDR
// hc_gallery :=  ;
46423: LD_ADDR_OWVAR 33
46427: PUSH
46428: LD_STRING 
46430: ST_TO_ADDR
// hc_name :=  ;
46431: LD_ADDR_OWVAR 26
46435: PUSH
46436: LD_STRING 
46438: ST_TO_ADDR
// un := CreateHuman ;
46439: LD_ADDR_VAR 0 2
46443: PUSH
46444: CALL_OW 44
46448: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
46449: LD_VAR 0 2
46453: PPUSH
46454: LD_INT 1
46456: PPUSH
46457: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
46461: LD_VAR 0 2
46465: PPUSH
46466: LD_INT 3
46468: PUSH
46469: LD_INT 22
46471: PUSH
46472: LD_INT 0
46474: PUSH
46475: EMPTY
46476: LIST
46477: LIST
46478: PUSH
46479: EMPTY
46480: LIST
46481: LIST
46482: PPUSH
46483: CALL_OW 69
46487: PPUSH
46488: LD_VAR 0 2
46492: PPUSH
46493: CALL_OW 74
46497: PPUSH
46498: CALL_OW 115
// end ;
46502: GO 46373
46504: POP
46505: POP
// end ;
46506: PPOPN 2
46508: END
// every 0 0$1 trigger StreamModeActive and sTroll do
46509: LD_EXP 79
46513: PUSH
46514: LD_EXP 102
46518: AND
46519: IFFALSE 46545
46521: GO 46523
46523: DISABLE
// begin ToLua ( displayTroll(); ) ;
46524: LD_STRING displayTroll();
46526: PPUSH
46527: CALL_OW 559
// wait ( 3 3$00 ) ;
46531: LD_INT 6300
46533: PPUSH
46534: CALL_OW 67
// ToLua ( hideTroll(); ) ;
46538: LD_STRING hideTroll();
46540: PPUSH
46541: CALL_OW 559
// end ;
46545: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
46546: LD_EXP 79
46550: PUSH
46551: LD_EXP 103
46555: AND
46556: IFFALSE 46619
46558: GO 46560
46560: DISABLE
46561: LD_INT 0
46563: PPUSH
// begin p := 0 ;
46564: LD_ADDR_VAR 0 1
46568: PUSH
46569: LD_INT 0
46571: ST_TO_ADDR
// repeat game_speed := 1 ;
46572: LD_ADDR_OWVAR 65
46576: PUSH
46577: LD_INT 1
46579: ST_TO_ADDR
// wait ( 0 0$1 ) ;
46580: LD_INT 35
46582: PPUSH
46583: CALL_OW 67
// p := p + 1 ;
46587: LD_ADDR_VAR 0 1
46591: PUSH
46592: LD_VAR 0 1
46596: PUSH
46597: LD_INT 1
46599: PLUS
46600: ST_TO_ADDR
// until p >= 60 ;
46601: LD_VAR 0 1
46605: PUSH
46606: LD_INT 60
46608: GREATEREQUAL
46609: IFFALSE 46572
// game_speed := 4 ;
46611: LD_ADDR_OWVAR 65
46615: PUSH
46616: LD_INT 4
46618: ST_TO_ADDR
// end ;
46619: PPOPN 1
46621: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
46622: LD_EXP 79
46626: PUSH
46627: LD_EXP 104
46631: AND
46632: IFFALSE 46778
46634: GO 46636
46636: DISABLE
46637: LD_INT 0
46639: PPUSH
46640: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
46641: LD_ADDR_VAR 0 1
46645: PUSH
46646: LD_INT 22
46648: PUSH
46649: LD_OWVAR 2
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: LD_INT 2
46660: PUSH
46661: LD_INT 30
46663: PUSH
46664: LD_INT 0
46666: PUSH
46667: EMPTY
46668: LIST
46669: LIST
46670: PUSH
46671: LD_INT 30
46673: PUSH
46674: LD_INT 1
46676: PUSH
46677: EMPTY
46678: LIST
46679: LIST
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: LIST
46685: PUSH
46686: EMPTY
46687: LIST
46688: LIST
46689: PPUSH
46690: CALL_OW 69
46694: ST_TO_ADDR
// if not depot then
46695: LD_VAR 0 1
46699: NOT
46700: IFFALSE 46704
// exit ;
46702: GO 46778
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
46704: LD_ADDR_VAR 0 2
46708: PUSH
46709: LD_VAR 0 1
46713: PUSH
46714: LD_INT 1
46716: PPUSH
46717: LD_VAR 0 1
46721: PPUSH
46722: CALL_OW 12
46726: ARRAY
46727: PPUSH
46728: CALL_OW 274
46732: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
46733: LD_VAR 0 2
46737: PPUSH
46738: LD_INT 1
46740: PPUSH
46741: LD_INT 0
46743: PPUSH
46744: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
46748: LD_VAR 0 2
46752: PPUSH
46753: LD_INT 2
46755: PPUSH
46756: LD_INT 0
46758: PPUSH
46759: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
46763: LD_VAR 0 2
46767: PPUSH
46768: LD_INT 3
46770: PPUSH
46771: LD_INT 0
46773: PPUSH
46774: CALL_OW 277
// end ;
46778: PPOPN 2
46780: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
46781: LD_EXP 79
46785: PUSH
46786: LD_EXP 105
46790: AND
46791: IFFALSE 46888
46793: GO 46795
46795: DISABLE
46796: LD_INT 0
46798: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
46799: LD_ADDR_VAR 0 1
46803: PUSH
46804: LD_INT 22
46806: PUSH
46807: LD_OWVAR 2
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PUSH
46816: LD_INT 21
46818: PUSH
46819: LD_INT 1
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: PUSH
46826: LD_INT 3
46828: PUSH
46829: LD_INT 23
46831: PUSH
46832: LD_INT 0
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: PUSH
46839: EMPTY
46840: LIST
46841: LIST
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: LIST
46847: PPUSH
46848: CALL_OW 69
46852: ST_TO_ADDR
// if not tmp then
46853: LD_VAR 0 1
46857: NOT
46858: IFFALSE 46862
// exit ;
46860: GO 46888
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
46862: LD_VAR 0 1
46866: PUSH
46867: LD_INT 1
46869: PPUSH
46870: LD_VAR 0 1
46874: PPUSH
46875: CALL_OW 12
46879: ARRAY
46880: PPUSH
46881: LD_INT 200
46883: PPUSH
46884: CALL_OW 234
// end ;
46888: PPOPN 1
46890: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
46891: LD_EXP 79
46895: PUSH
46896: LD_EXP 106
46900: AND
46901: IFFALSE 46980
46903: GO 46905
46905: DISABLE
46906: LD_INT 0
46908: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
46909: LD_ADDR_VAR 0 1
46913: PUSH
46914: LD_INT 22
46916: PUSH
46917: LD_OWVAR 2
46921: PUSH
46922: EMPTY
46923: LIST
46924: LIST
46925: PUSH
46926: LD_INT 21
46928: PUSH
46929: LD_INT 2
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PPUSH
46940: CALL_OW 69
46944: ST_TO_ADDR
// if not tmp then
46945: LD_VAR 0 1
46949: NOT
46950: IFFALSE 46954
// exit ;
46952: GO 46980
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
46954: LD_VAR 0 1
46958: PUSH
46959: LD_INT 1
46961: PPUSH
46962: LD_VAR 0 1
46966: PPUSH
46967: CALL_OW 12
46971: ARRAY
46972: PPUSH
46973: LD_INT 10
46975: PPUSH
46976: CALL_OW 234
// end ;
46980: PPOPN 1
46982: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
46983: LD_EXP 79
46987: PUSH
46988: LD_EXP 107
46992: AND
46993: IFFALSE 47092
46995: GO 46997
46997: DISABLE
46998: LD_INT 0
47000: PPUSH
47001: PPUSH
// begin enable ;
47002: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
47003: LD_ADDR_VAR 0 1
47007: PUSH
47008: LD_INT 22
47010: PUSH
47011: LD_OWVAR 2
47015: PUSH
47016: EMPTY
47017: LIST
47018: LIST
47019: PUSH
47020: LD_INT 61
47022: PUSH
47023: EMPTY
47024: LIST
47025: PUSH
47026: LD_INT 33
47028: PUSH
47029: LD_INT 2
47031: PUSH
47032: EMPTY
47033: LIST
47034: LIST
47035: PUSH
47036: EMPTY
47037: LIST
47038: LIST
47039: LIST
47040: PPUSH
47041: CALL_OW 69
47045: ST_TO_ADDR
// if not tmp then
47046: LD_VAR 0 1
47050: NOT
47051: IFFALSE 47055
// exit ;
47053: GO 47092
// for i in tmp do
47055: LD_ADDR_VAR 0 2
47059: PUSH
47060: LD_VAR 0 1
47064: PUSH
47065: FOR_IN
47066: IFFALSE 47090
// if IsControledBy ( i ) then
47068: LD_VAR 0 2
47072: PPUSH
47073: CALL_OW 312
47077: IFFALSE 47088
// ComUnlink ( i ) ;
47079: LD_VAR 0 2
47083: PPUSH
47084: CALL_OW 136
47088: GO 47065
47090: POP
47091: POP
// end ; end_of_file
47092: PPOPN 2
47094: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
47095: LD_INT 0
47097: PPUSH
47098: PPUSH
47099: PPUSH
47100: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
47101: LD_VAR 0 1
47105: PPUSH
47106: CALL_OW 264
47110: PUSH
47111: LD_EXP 78
47115: EQUAL
47116: IFFALSE 47188
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
47118: LD_INT 68
47120: PPUSH
47121: LD_VAR 0 1
47125: PPUSH
47126: CALL_OW 255
47130: PPUSH
47131: CALL_OW 321
47135: PUSH
47136: LD_INT 2
47138: EQUAL
47139: IFFALSE 47151
// eff := 70 else
47141: LD_ADDR_VAR 0 6
47145: PUSH
47146: LD_INT 70
47148: ST_TO_ADDR
47149: GO 47159
// eff := 30 ;
47151: LD_ADDR_VAR 0 6
47155: PUSH
47156: LD_INT 30
47158: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
47159: LD_VAR 0 1
47163: PPUSH
47164: CALL_OW 250
47168: PPUSH
47169: LD_VAR 0 1
47173: PPUSH
47174: CALL_OW 251
47178: PPUSH
47179: LD_VAR 0 6
47183: PPUSH
47184: CALL_OW 495
// end ; end ;
47188: LD_VAR 0 4
47192: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
47193: LD_INT 0
47195: PPUSH
47196: PPUSH
47197: PPUSH
47198: PPUSH
47199: PPUSH
47200: PPUSH
// if cmd = 124 then
47201: LD_VAR 0 1
47205: PUSH
47206: LD_INT 124
47208: EQUAL
47209: IFFALSE 47415
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
47211: LD_ADDR_VAR 0 5
47215: PUSH
47216: LD_INT 2
47218: PUSH
47219: LD_INT 34
47221: PUSH
47222: LD_INT 53
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PUSH
47229: LD_INT 34
47231: PUSH
47232: LD_INT 14
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PUSH
47239: EMPTY
47240: LIST
47241: LIST
47242: LIST
47243: PPUSH
47244: CALL_OW 69
47248: ST_TO_ADDR
// if not tmp then
47249: LD_VAR 0 5
47253: NOT
47254: IFFALSE 47258
// exit ;
47256: GO 47415
// for i in tmp do
47258: LD_ADDR_VAR 0 3
47262: PUSH
47263: LD_VAR 0 5
47267: PUSH
47268: FOR_IN
47269: IFFALSE 47413
// begin taskList := GetTaskList ( i ) ;
47271: LD_ADDR_VAR 0 6
47275: PUSH
47276: LD_VAR 0 3
47280: PPUSH
47281: CALL_OW 437
47285: ST_TO_ADDR
// if not taskList then
47286: LD_VAR 0 6
47290: NOT
47291: IFFALSE 47295
// continue ;
47293: GO 47268
// for j = 1 to taskList do
47295: LD_ADDR_VAR 0 4
47299: PUSH
47300: DOUBLE
47301: LD_INT 1
47303: DEC
47304: ST_TO_ADDR
47305: LD_VAR 0 6
47309: PUSH
47310: FOR_TO
47311: IFFALSE 47409
// if taskList [ j ] [ 1 ] = | then
47313: LD_VAR 0 6
47317: PUSH
47318: LD_VAR 0 4
47322: ARRAY
47323: PUSH
47324: LD_INT 1
47326: ARRAY
47327: PUSH
47328: LD_STRING |
47330: EQUAL
47331: IFFALSE 47407
// begin _taskList := Delete ( taskList , 1 ) ;
47333: LD_ADDR_VAR 0 7
47337: PUSH
47338: LD_VAR 0 6
47342: PPUSH
47343: LD_INT 1
47345: PPUSH
47346: CALL_OW 3
47350: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
47351: LD_VAR 0 3
47355: PPUSH
47356: LD_VAR 0 7
47360: PPUSH
47361: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
47365: LD_VAR 0 3
47369: PPUSH
47370: LD_VAR 0 6
47374: PUSH
47375: LD_VAR 0 4
47379: ARRAY
47380: PUSH
47381: LD_INT 2
47383: ARRAY
47384: PPUSH
47385: LD_VAR 0 6
47389: PUSH
47390: LD_VAR 0 4
47394: ARRAY
47395: PUSH
47396: LD_INT 3
47398: ARRAY
47399: PPUSH
47400: LD_INT 8
47402: PPUSH
47403: CALL 47420 0 4
// end ;
47407: GO 47310
47409: POP
47410: POP
// end ;
47411: GO 47268
47413: POP
47414: POP
// end ; end ;
47415: LD_VAR 0 2
47419: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
47420: LD_INT 0
47422: PPUSH
47423: PPUSH
47424: PPUSH
47425: PPUSH
47426: PPUSH
47427: PPUSH
47428: PPUSH
47429: PPUSH
47430: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
47431: LD_VAR 0 1
47435: NOT
47436: PUSH
47437: LD_VAR 0 2
47441: PPUSH
47442: LD_VAR 0 3
47446: PPUSH
47447: CALL_OW 488
47451: NOT
47452: OR
47453: PUSH
47454: LD_VAR 0 4
47458: NOT
47459: OR
47460: IFFALSE 47464
// exit ;
47462: GO 47804
// list := [ ] ;
47464: LD_ADDR_VAR 0 13
47468: PUSH
47469: EMPTY
47470: ST_TO_ADDR
// if x - r < 0 then
47471: LD_VAR 0 2
47475: PUSH
47476: LD_VAR 0 4
47480: MINUS
47481: PUSH
47482: LD_INT 0
47484: LESS
47485: IFFALSE 47497
// min_x := 0 else
47487: LD_ADDR_VAR 0 7
47491: PUSH
47492: LD_INT 0
47494: ST_TO_ADDR
47495: GO 47513
// min_x := x - r ;
47497: LD_ADDR_VAR 0 7
47501: PUSH
47502: LD_VAR 0 2
47506: PUSH
47507: LD_VAR 0 4
47511: MINUS
47512: ST_TO_ADDR
// if y - r < 0 then
47513: LD_VAR 0 3
47517: PUSH
47518: LD_VAR 0 4
47522: MINUS
47523: PUSH
47524: LD_INT 0
47526: LESS
47527: IFFALSE 47539
// min_y := 0 else
47529: LD_ADDR_VAR 0 8
47533: PUSH
47534: LD_INT 0
47536: ST_TO_ADDR
47537: GO 47555
// min_y := y - r ;
47539: LD_ADDR_VAR 0 8
47543: PUSH
47544: LD_VAR 0 3
47548: PUSH
47549: LD_VAR 0 4
47553: MINUS
47554: ST_TO_ADDR
// max_x := x + r ;
47555: LD_ADDR_VAR 0 9
47559: PUSH
47560: LD_VAR 0 2
47564: PUSH
47565: LD_VAR 0 4
47569: PLUS
47570: ST_TO_ADDR
// max_y := y + r ;
47571: LD_ADDR_VAR 0 10
47575: PUSH
47576: LD_VAR 0 3
47580: PUSH
47581: LD_VAR 0 4
47585: PLUS
47586: ST_TO_ADDR
// for _x = min_x to max_x do
47587: LD_ADDR_VAR 0 11
47591: PUSH
47592: DOUBLE
47593: LD_VAR 0 7
47597: DEC
47598: ST_TO_ADDR
47599: LD_VAR 0 9
47603: PUSH
47604: FOR_TO
47605: IFFALSE 47722
// for _y = min_y to max_y do
47607: LD_ADDR_VAR 0 12
47611: PUSH
47612: DOUBLE
47613: LD_VAR 0 8
47617: DEC
47618: ST_TO_ADDR
47619: LD_VAR 0 10
47623: PUSH
47624: FOR_TO
47625: IFFALSE 47718
// begin if not ValidHex ( _x , _y ) then
47627: LD_VAR 0 11
47631: PPUSH
47632: LD_VAR 0 12
47636: PPUSH
47637: CALL_OW 488
47641: NOT
47642: IFFALSE 47646
// continue ;
47644: GO 47624
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
47646: LD_VAR 0 11
47650: PPUSH
47651: LD_VAR 0 12
47655: PPUSH
47656: CALL_OW 351
47660: PUSH
47661: LD_VAR 0 11
47665: PPUSH
47666: LD_VAR 0 12
47670: PPUSH
47671: CALL_OW 554
47675: AND
47676: IFFALSE 47716
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
47678: LD_ADDR_VAR 0 13
47682: PUSH
47683: LD_VAR 0 13
47687: PPUSH
47688: LD_VAR 0 13
47692: PUSH
47693: LD_INT 1
47695: PLUS
47696: PPUSH
47697: LD_VAR 0 11
47701: PUSH
47702: LD_VAR 0 12
47706: PUSH
47707: EMPTY
47708: LIST
47709: LIST
47710: PPUSH
47711: CALL_OW 2
47715: ST_TO_ADDR
// end ;
47716: GO 47624
47718: POP
47719: POP
47720: GO 47604
47722: POP
47723: POP
// if not list then
47724: LD_VAR 0 13
47728: NOT
47729: IFFALSE 47733
// exit ;
47731: GO 47804
// for i in list do
47733: LD_ADDR_VAR 0 6
47737: PUSH
47738: LD_VAR 0 13
47742: PUSH
47743: FOR_IN
47744: IFFALSE 47802
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
47746: LD_VAR 0 1
47750: PPUSH
47751: LD_STRING M
47753: PUSH
47754: LD_VAR 0 6
47758: PUSH
47759: LD_INT 1
47761: ARRAY
47762: PUSH
47763: LD_VAR 0 6
47767: PUSH
47768: LD_INT 2
47770: ARRAY
47771: PUSH
47772: LD_INT 0
47774: PUSH
47775: LD_INT 0
47777: PUSH
47778: LD_INT 0
47780: PUSH
47781: LD_INT 0
47783: PUSH
47784: EMPTY
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: PUSH
47793: EMPTY
47794: LIST
47795: PPUSH
47796: CALL_OW 447
47800: GO 47743
47802: POP
47803: POP
// end ;
47804: LD_VAR 0 5
47808: RET
