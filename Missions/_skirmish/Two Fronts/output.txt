// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7711 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4880 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41683 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42134 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21451 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21387 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18380 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21287 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22301 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21528 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21321 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21354 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18159 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22209 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20466 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21041 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21041 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20838 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20502 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20678 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19962 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20576 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21077 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21817 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21387 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18380 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21287 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21528 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18159 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22209 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20466 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21041 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21041 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20838 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20502 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20678 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19962 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20576 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21077 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21817 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19962 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11667 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22035 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11667 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22035 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11667 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22035 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11667 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22035 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7930 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7930 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7930 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7930 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7930 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18380 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4877
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4875
// begin if player_squad < i then
4785: LD_EXP 22
4789: PUSH
4790: LD_VAR 0 1
4794: LESS
4795: IFFALSE 4801
// exit ;
4797: POP
4798: POP
4799: GO 4877
// PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4801: LD_EXP 22
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PPUSH
4810: LD_INT 18
4812: PPUSH
4813: LD_INT 0
4815: PPUSH
4816: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4820: LD_EXP 22
4824: PUSH
4825: LD_INT 1
4827: ARRAY
4828: PPUSH
4829: LD_INT 107
4831: PPUSH
4832: LD_INT 88
4834: PPUSH
4835: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4839: LD_EXP 22
4843: PUSH
4844: LD_INT 1
4846: ARRAY
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4855: LD_ADDR_EXP 22
4859: PUSH
4860: LD_EXP 22
4864: PPUSH
4865: LD_INT 1
4867: PPUSH
4868: CALL_OW 3
4872: ST_TO_ADDR
// end ;
4873: GO 4782
4875: POP
4876: POP
// end ;
4877: PPOPN 1
4879: END
// export function Dialog ; var i ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
// if not isTest then
4884: LD_EXP 1
4888: NOT
4889: IFFALSE 4911
// case query ( task ) of 1 :
4891: LD_STRING task
4893: PPUSH
4894: CALL_OW 97
4898: PUSH
4899: LD_INT 1
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4910
4907: POP
// ; end ;
4908: GO 4911
4910: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4911: LD_INT 105
4913: PPUSH
4914: LD_INT 84
4916: PPUSH
4917: LD_INT 3
4919: PPUSH
4920: LD_INT 30
4922: NEG
4923: PPUSH
4924: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4928: LD_INT 105
4930: PPUSH
4931: LD_INT 84
4933: PPUSH
4934: LD_INT 3
4936: PPUSH
4937: CALL_OW 331
// InGameOn ;
4941: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4945: LD_INT 128
4947: PPUSH
4948: LD_INT 64
4950: PPUSH
4951: CALL_OW 86
// if isTest then
4955: LD_EXP 1
4959: IFFALSE 4969
// dialogue_skipped := true ;
4961: LD_ADDR_OWVAR 59
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4969: LD_EXP 24
4973: PPUSH
4974: LD_STRING DR1
4976: PPUSH
4977: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_STRING DR2
4988: PPUSH
4989: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4993: LD_EXP 24
4997: PPUSH
4998: LD_STRING DR3
5000: PPUSH
5001: CALL_OW 94
// InGameOff ;
5005: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5009: LD_STRING C1
5011: PPUSH
5012: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5016: LD_INT 35
5018: PPUSH
5019: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5023: LD_INT 9
5025: PPUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 70
5040: IFFALSE 5016
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5042: LD_ADDR_VAR 0 2
5046: PUSH
5047: LD_INT 9
5049: PPUSH
5050: LD_INT 22
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 70
5064: PUSH
5065: FOR_IN
5066: IFFALSE 5082
// SetSide ( i , 3 ) ;
5068: LD_VAR 0 2
5072: PPUSH
5073: LD_INT 3
5075: PPUSH
5076: CALL_OW 235
5080: GO 5065
5082: POP
5083: POP
// if not isTest then
5084: LD_EXP 1
5088: NOT
5089: IFFALSE 5111
// case query ( support ) of 1 :
5091: LD_STRING support
5093: PPUSH
5094: CALL_OW 97
5098: PUSH
5099: LD_INT 1
5101: DOUBLE
5102: EQUAL
5103: IFTRUE 5107
5105: GO 5110
5107: POP
// ; end ;
5108: GO 5111
5110: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5111: LD_INT 3
5113: PPUSH
5114: LD_INT 12
5116: PPUSH
5117: LD_INT 2
5119: PPUSH
5120: LD_INT 22
5122: PUSH
5123: LD_INT 3
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 30
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: PPUSH
5144: CALL_OW 69
5148: PUSH
5149: LD_INT 1
5151: ARRAY
5152: PPUSH
5153: CALL_OW 468
// if player_com = stolypin then
5157: LD_EXP 23
5161: PUSH
5162: LD_EXP 21
5166: EQUAL
5167: IFFALSE 5196
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5169: LD_INT 18
5171: PPUSH
5172: LD_INT 3
5174: PUSH
5175: LD_INT 3
5177: PUSH
5178: LD_INT 2
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_OWVAR 67
5190: ARRAY
5191: PPUSH
5192: CALL 6608 0 2
// end ;
5196: LD_VAR 0 1
5200: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5201: LD_EXP 11
5205: PUSH
5206: LD_OWVAR 1
5210: PUSH
5211: LD_INT 31500
5213: LESS
5214: AND
5215: IFFALSE 5383
// case query ( call1 ) of 1 :
5217: LD_STRING call1
5219: PPUSH
5220: CALL_OW 97
5224: PUSH
5225: LD_INT 1
5227: DOUBLE
5228: EQUAL
5229: IFTRUE 5233
5231: GO 5371
5233: POP
// begin callUsed := true ;
5234: LD_ADDR_EXP 3
5238: PUSH
5239: LD_INT 1
5241: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 12
5247: PPUSH
5248: LD_INT 1
5250: PPUSH
5251: LD_INT 1
5253: PPUSH
5254: CALL_OW 468
// call := false ;
5258: LD_ADDR_EXP 11
5262: PUSH
5263: LD_INT 0
5265: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5266: LD_EXP 24
5270: PPUSH
5271: LD_STRING DR6
5273: PPUSH
5274: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5278: LD_INT 6300
5280: PPUSH
5281: LD_INT 8400
5283: PPUSH
5284: CALL_OW 12
5288: PPUSH
5289: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5293: LD_INT 18
5295: PUSH
5296: LD_INT 19
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: ARRAY
5314: PPUSH
5315: LD_INT 1
5317: PPUSH
5318: LD_INT 2
5320: PPUSH
5321: CALL_OW 12
5325: PPUSH
5326: CALL 6608 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5330: LD_INT 25200
5332: PPUSH
5333: LD_INT 35700
5335: PPUSH
5336: CALL_OW 12
5340: PPUSH
5341: CALL_OW 67
// call := true ;
5345: LD_ADDR_EXP 11
5349: PUSH
5350: LD_INT 1
5352: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 12
5358: PPUSH
5359: LD_INT 2
5361: PPUSH
5362: LD_INT 1
5364: PPUSH
5365: CALL_OW 468
// end ; 2 :
5369: GO 5383
5371: LD_INT 2
5373: DOUBLE
5374: EQUAL
5375: IFTRUE 5379
5377: GO 5382
5379: POP
// ; end ;
5380: GO 5383
5382: POP
// if call and tick >= 15 15$00 then
5383: LD_EXP 11
5387: PUSH
5388: LD_OWVAR 1
5392: PUSH
5393: LD_INT 31500
5395: GREATEREQUAL
5396: AND
5397: IFFALSE 5836
// case query ( call2 ) of 1 :
5399: LD_STRING call2
5401: PPUSH
5402: CALL_OW 97
5406: PUSH
5407: LD_INT 1
5409: DOUBLE
5410: EQUAL
5411: IFTRUE 5415
5413: GO 5657
5415: POP
// begin callUsed := true ;
5416: LD_ADDR_EXP 3
5420: PUSH
5421: LD_INT 1
5423: ST_TO_ADDR
// call := false ;
5424: LD_ADDR_EXP 11
5428: PUSH
5429: LD_INT 0
5431: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5432: LD_INT 1
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11667 0 2
5449: PUSH
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 21
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL 11667 0 2
5467: AND
5468: IFFALSE 5516
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5470: LD_INT 18
5472: PUSH
5473: LD_INT 19
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 1
5482: PPUSH
5483: LD_INT 2
5485: PPUSH
5486: CALL_OW 12
5490: ARRAY
5491: PPUSH
5492: LD_INT 5
5494: PUSH
5495: LD_INT 4
5497: PUSH
5498: LD_INT 4
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_OWVAR 67
5510: ARRAY
5511: PPUSH
5512: CALL 6369 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 21
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL 11667 0 2
5533: PUSH
5534: LD_INT 0
5536: EQUAL
5537: IFFALSE 5566
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5539: LD_INT 19
5541: PPUSH
5542: LD_INT 5
5544: PUSH
5545: LD_INT 4
5547: PUSH
5548: LD_INT 3
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: PUSH
5556: LD_OWVAR 67
5560: ARRAY
5561: PPUSH
5562: CALL 6369 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5566: LD_INT 4
5568: PPUSH
5569: LD_INT 21
5571: PUSH
5572: LD_INT 3
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 11667 0 2
5583: PUSH
5584: LD_INT 0
5586: EQUAL
5587: IFFALSE 5616
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5589: LD_INT 18
5591: PPUSH
5592: LD_INT 5
5594: PUSH
5595: LD_INT 4
5597: PUSH
5598: LD_INT 4
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_OWVAR 67
5610: ARRAY
5611: PPUSH
5612: CALL 6369 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5616: LD_INT 10500
5618: PPUSH
5619: LD_INT 23100
5621: PPUSH
5622: CALL_OW 12
5626: PPUSH
5627: CALL_OW 67
// call := true ;
5631: LD_ADDR_EXP 11
5635: PUSH
5636: LD_INT 1
5638: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5639: LD_INT 3
5641: PPUSH
5642: LD_INT 12
5644: PPUSH
5645: LD_INT 2
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: CALL_OW 468
// end ; 2 :
5655: GO 5836
5657: LD_INT 2
5659: DOUBLE
5660: EQUAL
5661: IFTRUE 5665
5663: GO 5824
5665: POP
// begin callUsed := true ;
5666: LD_ADDR_EXP 3
5670: PUSH
5671: LD_INT 1
5673: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_INT 12
5679: PPUSH
5680: LD_INT 1
5682: PPUSH
5683: LD_INT 1
5685: PPUSH
5686: CALL_OW 468
// call := false ;
5690: LD_ADDR_EXP 11
5694: PUSH
5695: LD_INT 0
5697: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5698: LD_EXP 24
5702: PPUSH
5703: LD_STRING DR6
5705: PPUSH
5706: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5710: LD_INT 6300
5712: PPUSH
5713: LD_INT 8400
5715: PPUSH
5716: CALL_OW 12
5720: PPUSH
5721: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5725: LD_INT 18
5727: PUSH
5728: LD_INT 19
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PUSH
5735: LD_INT 1
5737: PPUSH
5738: LD_INT 2
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: PUSH
5761: LD_OWVAR 67
5765: ARRAY
5766: PUSH
5767: LD_INT 0
5769: PPUSH
5770: LD_INT 1
5772: PPUSH
5773: CALL_OW 12
5777: MINUS
5778: PPUSH
5779: CALL 6608 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5783: LD_INT 35700
5785: PPUSH
5786: LD_INT 44100
5788: PPUSH
5789: CALL_OW 12
5793: PPUSH
5794: CALL_OW 67
// call := true ;
5798: LD_ADDR_EXP 11
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5806: LD_INT 3
5808: PPUSH
5809: LD_INT 12
5811: PPUSH
5812: LD_INT 2
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL_OW 468
// end ; 3 :
5822: GO 5836
5824: LD_INT 3
5826: DOUBLE
5827: EQUAL
5828: IFTRUE 5832
5830: GO 5835
5832: POP
// ; end ;
5833: GO 5836
5835: POP
// end ;
5836: PPOPN 4
5838: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 21
5851: PUSH
5852: LD_INT 1
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: CALL_OW 69
5867: PUSH
5868: LD_INT 0
5870: EQUAL
5871: PUSH
5872: LD_INT 22
5874: PUSH
5875: LD_INT 4
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 21
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PPUSH
5896: CALL_OW 69
5900: PUSH
5901: LD_INT 0
5903: EQUAL
5904: AND
5905: IFFALSE 6209
5907: GO 5909
5909: DISABLE
// begin DialogueOn ;
5910: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5914: LD_EXP 24
5918: PPUSH
5919: LD_STRING DR7
5921: PPUSH
5922: CALL_OW 94
// case player_com of Gorki :
5926: LD_EXP 23
5930: PUSH
5931: LD_EXP 20
5935: DOUBLE
5936: EQUAL
5937: IFTRUE 5941
5939: GO 5951
5941: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5942: LD_STRING ACH_GORKI
5944: PPUSH
5945: CALL_OW 543
5949: GO 6012
5951: LD_EXP 21
5955: DOUBLE
5956: EQUAL
5957: IFTRUE 5961
5959: GO 5971
5961: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5962: LD_STRING ACH_STOLYP
5964: PPUSH
5965: CALL_OW 543
5969: GO 6012
5971: LD_EXP 19
5975: DOUBLE
5976: EQUAL
5977: IFTRUE 5981
5979: GO 5991
5981: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5982: LD_STRING ACH_DAVIDOV
5984: PPUSH
5985: CALL_OW 543
5989: GO 6012
5991: LD_EXP 18
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6011
6001: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6002: LD_STRING ACH_GLADKOV
6004: PPUSH
6005: CALL_OW 543
6009: GO 6012
6011: POP
// if not callUsed then
6012: LD_EXP 3
6016: NOT
6017: IFFALSE 6026
// SetAchievement ( ACH_NOSUPP ) ;
6019: LD_STRING ACH_NOSUPP
6021: PPUSH
6022: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6026: LD_OWVAR 1
6030: PUSH
6031: LD_INT 116550
6033: PUSH
6034: LD_INT 95550
6036: PUSH
6037: LD_INT 89250
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_OWVAR 67
6049: ARRAY
6050: LESS
6051: IFFALSE 6065
// AddMedal ( med1 , 1 ) else
6053: LD_STRING med1
6055: PPUSH
6056: LD_INT 1
6058: PPUSH
6059: CALL_OW 101
6063: GO 6076
// AddMedal ( med1 , - 1 ) ;
6065: LD_STRING med1
6067: PPUSH
6068: LD_INT 1
6070: NEG
6071: PPUSH
6072: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6076: LD_INT 81
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: LD_INT 21
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PPUSH
6100: CALL_OW 69
6104: PUSH
6105: LD_INT 0
6107: EQUAL
6108: IFFALSE 6122
// AddMedal ( med3 , 1 ) else
6110: LD_STRING med3
6112: PPUSH
6113: LD_INT 1
6115: PPUSH
6116: CALL_OW 101
6120: GO 6133
// AddMedal ( med3 , - 1 ) ;
6122: LD_STRING med3
6124: PPUSH
6125: LD_INT 1
6127: NEG
6128: PPUSH
6129: CALL_OW 101
// if player_loss = 0 then
6133: LD_EXP 10
6137: PUSH
6138: LD_INT 0
6140: EQUAL
6141: IFFALSE 6155
// AddMedal ( med2 , 1 ) else
6143: LD_STRING med2
6145: PPUSH
6146: LD_INT 1
6148: PPUSH
6149: CALL_OW 101
6153: GO 6198
// if player_loss > 0 and player_loss < 3 then
6155: LD_EXP 10
6159: PUSH
6160: LD_INT 0
6162: GREATER
6163: PUSH
6164: LD_EXP 10
6168: PUSH
6169: LD_INT 3
6171: LESS
6172: AND
6173: IFFALSE 6187
// AddMedal ( med2 , 2 ) else
6175: LD_STRING med2
6177: PPUSH
6178: LD_INT 2
6180: PPUSH
6181: CALL_OW 101
6185: GO 6198
// AddMedal ( med2 , - 1 ) ;
6187: LD_STRING med2
6189: PPUSH
6190: LD_INT 1
6192: NEG
6193: PPUSH
6194: CALL_OW 101
// GiveMedals ( MAIN ) ;
6198: LD_STRING MAIN
6200: PPUSH
6201: CALL_OW 102
// YouWin ;
6205: CALL_OW 103
// end ;
6209: END
// every 0 0$01 trigger IsDead ( player_com ) do
6210: LD_EXP 23
6214: PPUSH
6215: CALL_OW 301
6219: IFFALSE 6286
6221: GO 6223
6223: DISABLE
// begin if IsLive ( Houten ) then
6224: LD_EXP 4
6228: PPUSH
6229: CALL_OW 300
6233: IFFALSE 6249
// SayRadio ( Houten , DJ5 ) else
6235: LD_EXP 4
6239: PPUSH
6240: LD_STRING DJ5
6242: PPUSH
6243: CALL_OW 94
6247: GO 6272
// if IsLive ( Brown ) then
6249: LD_EXP 5
6253: PPUSH
6254: CALL_OW 300
6258: IFFALSE 6272
// SayRadio ( Brown , DS5 ) ;
6260: LD_EXP 5
6264: PPUSH
6265: LD_STRING DS5
6267: PPUSH
6268: CALL_OW 94
// Wait ( 0 0$01 ) ;
6272: LD_INT 35
6274: PPUSH
6275: CALL_OW 67
// YouLost ( dead ) ;
6279: LD_STRING dead
6281: PPUSH
6282: CALL_OW 104
// end ;
6286: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6287: LD_INT 1
6289: PPUSH
6290: CALL_OW 301
6294: PUSH
6295: LD_EXP 1
6299: NOT
6300: AND
6301: IFFALSE 6368
6303: GO 6305
6305: DISABLE
// begin if IsLive ( Brown ) then
6306: LD_EXP 5
6310: PPUSH
6311: CALL_OW 300
6315: IFFALSE 6331
// SayRadio ( Brown , DS5 ) else
6317: LD_EXP 5
6321: PPUSH
6322: LD_STRING DS5
6324: PPUSH
6325: CALL_OW 94
6329: GO 6354
// if IsLive ( Houten ) then
6331: LD_EXP 4
6335: PPUSH
6336: CALL_OW 300
6340: IFFALSE 6354
// SayRadio ( Houten , DJ5 ) ;
6342: LD_EXP 4
6346: PPUSH
6347: LD_STRING DJ5
6349: PPUSH
6350: CALL_OW 94
// Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// YouLost ( depot ) ;
6361: LD_STRING depot
6363: PPUSH
6364: CALL_OW 104
// end ;
6368: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6369: LD_INT 0
6371: PPUSH
6372: PPUSH
6373: PPUSH
// for i = 1 to n do
6374: LD_ADDR_VAR 0 4
6378: PUSH
6379: DOUBLE
6380: LD_INT 1
6382: DEC
6383: ST_TO_ADDR
6384: LD_VAR 0 2
6388: PUSH
6389: FOR_TO
6390: IFFALSE 6593
// begin uc_side := 6 ;
6392: LD_ADDR_OWVAR 20
6396: PUSH
6397: LD_INT 6
6399: ST_TO_ADDR
// uc_nation := 3 ;
6400: LD_ADDR_OWVAR 21
6404: PUSH
6405: LD_INT 3
6407: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6408: LD_ADDR_OWVAR 37
6412: PUSH
6413: LD_INT 23
6415: PUSH
6416: LD_INT 22
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ARRAY
6434: ST_TO_ADDR
// vc_control := control_computer ;
6435: LD_ADDR_OWVAR 38
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// vc_engine := engine_siberite ;
6443: LD_ADDR_OWVAR 39
6447: PUSH
6448: LD_INT 3
6450: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6451: LD_ADDR_OWVAR 40
6455: PUSH
6456: LD_INT 43
6458: PUSH
6459: LD_INT 44
6461: PUSH
6462: LD_INT 44
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 1
6472: PPUSH
6473: LD_INT 3
6475: PPUSH
6476: CALL_OW 12
6480: ARRAY
6481: ST_TO_ADDR
// un := CreateVehicle ;
6482: LD_ADDR_VAR 0 5
6486: PUSH
6487: CALL_OW 45
6491: ST_TO_ADDR
// case area of east_arr :
6492: LD_VAR 0 1
6496: PUSH
6497: LD_INT 18
6499: DOUBLE
6500: EQUAL
6501: IFTRUE 6505
6503: GO 6540
6505: POP
// begin PlaceUnitArea ( un , area , false ) ;
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6523: LD_VAR 0 5
6527: PPUSH
6528: LD_INT 79
6530: PPUSH
6531: LD_INT 33
6533: PPUSH
6534: CALL_OW 111
// end ; south_arr :
6538: GO 6584
6540: LD_INT 19
6542: DOUBLE
6543: EQUAL
6544: IFTRUE 6548
6546: GO 6583
6548: POP
// begin PlaceUnitArea ( un , area , false ) ;
6549: LD_VAR 0 5
6553: PPUSH
6554: LD_VAR 0 1
6558: PPUSH
6559: LD_INT 0
6561: PPUSH
6562: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6566: LD_VAR 0 5
6570: PPUSH
6571: LD_INT 131
6573: PPUSH
6574: LD_INT 148
6576: PPUSH
6577: CALL_OW 111
// end ; end ;
6581: GO 6584
6583: POP
// Wait ( 0 0$02 ) ;
6584: LD_INT 70
6586: PPUSH
6587: CALL_OW 67
// end ;
6591: GO 6389
6593: POP
6594: POP
// pink_attack := true ;
6595: LD_ADDR_EXP 12
6599: PUSH
6600: LD_INT 1
6602: ST_TO_ADDR
// end ;
6603: LD_VAR 0 3
6607: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
6612: PPUSH
// for i = 1 to n do
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 2
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6855
// begin uc_side := 6 ;
6631: LD_ADDR_OWVAR 20
6635: PUSH
6636: LD_INT 6
6638: ST_TO_ADDR
// uc_nation := 3 ;
6639: LD_ADDR_OWVAR 21
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6647: LD_INT 0
6649: PPUSH
6650: LD_INT 3
6652: PPUSH
6653: LD_INT 4
6655: PPUSH
6656: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6660: LD_ADDR_OWVAR 37
6664: PUSH
6665: LD_INT 22
6667: ST_TO_ADDR
// vc_control := control_manual ;
6668: LD_ADDR_OWVAR 38
6672: PUSH
6673: LD_INT 1
6675: ST_TO_ADDR
// vc_engine := engine_combustion ;
6676: LD_ADDR_OWVAR 39
6680: PUSH
6681: LD_INT 1
6683: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6684: LD_ADDR_OWVAR 40
6688: PUSH
6689: LD_INT 51
6691: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6692: LD_ADDR_OWVAR 41
6696: PUSH
6697: LD_INT 50
6699: ST_TO_ADDR
// un := CreateVehicle ;
6700: LD_ADDR_VAR 0 5
6704: PUSH
6705: CALL_OW 45
6709: ST_TO_ADDR
// case area of east_arr :
6710: LD_VAR 0 1
6714: PUSH
6715: LD_INT 18
6717: DOUBLE
6718: EQUAL
6719: IFTRUE 6723
6721: GO 6738
6723: POP
// SetDir ( un , 4 ) ; south_arr :
6724: LD_VAR 0 5
6728: PPUSH
6729: LD_INT 4
6731: PPUSH
6732: CALL_OW 233
6736: GO 6762
6738: LD_INT 19
6740: DOUBLE
6741: EQUAL
6742: IFTRUE 6746
6744: GO 6761
6746: POP
// SetDir ( un , 5 ) ; end ;
6747: LD_VAR 0 5
6751: PPUSH
6752: LD_INT 5
6754: PPUSH
6755: CALL_OW 233
6759: GO 6762
6761: POP
// PlaceUnitArea ( un , area , false ) ;
6762: LD_VAR 0 5
6766: PPUSH
6767: LD_VAR 0 1
6771: PPUSH
6772: LD_INT 0
6774: PPUSH
6775: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6779: CALL_OW 44
6783: PPUSH
6784: LD_VAR 0 5
6788: PPUSH
6789: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6793: LD_VAR 0 5
6797: PPUSH
6798: LD_INT 1
6800: PPUSH
6801: LD_INT 100
6803: PPUSH
6804: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6808: LD_VAR 0 5
6812: PPUSH
6813: LD_INT 106
6815: PPUSH
6816: LD_INT 88
6818: PPUSH
6819: CALL_OW 111
// AddComUnload ( un ) ;
6823: LD_VAR 0 5
6827: PPUSH
6828: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6832: LD_VAR 0 5
6836: PPUSH
6837: LD_VAR 0 1
6841: PPUSH
6842: CALL_OW 173
// Wait ( 0 0$02 ) ;
6846: LD_INT 70
6848: PPUSH
6849: CALL_OW 67
// end ;
6853: GO 6628
6855: POP
6856: POP
// Wait ( 0 0$05 ) ;
6857: LD_INT 175
6859: PPUSH
6860: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6864: LD_INT 6
6866: PPUSH
6867: LD_INT 34
6869: PUSH
6870: LD_INT 51
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PPUSH
6877: CALL 11667 0 2
6881: IFFALSE 7069
// begin wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_INT 6
6897: PPUSH
6898: LD_INT 34
6900: PUSH
6901: LD_INT 51
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL 11667 0 2
6912: PUSH
6913: FOR_IN
6914: IFFALSE 7065
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_INT 9
6923: PPUSH
6924: CALL_OW 308
6928: PUSH
6929: LD_VAR 0 4
6933: PPUSH
6934: CALL 31775 0 1
6938: PPUSH
6939: CALL_OW 258
6943: PUSH
6944: LD_INT 1
6946: EQUAL
6947: AND
6948: PUSH
6949: LD_EXP 9
6953: AND
6954: IFFALSE 6981
// begin Say ( GetDriver ( i ) , Dtran ) ;
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 31775 0 1
6965: PPUSH
6966: LD_STRING Dtran
6968: PPUSH
6969: CALL_OW 88
// dialog_trans := false ;
6973: LD_ADDR_EXP 9
6977: PUSH
6978: LD_INT 0
6980: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6981: LD_VAR 0 4
6985: PPUSH
6986: CALL_OW 316
6990: IFFALSE 7006
// ComMoveToArea ( i , area ) ;
6992: LD_VAR 0 4
6996: PPUSH
6997: LD_VAR 0 1
7001: PPUSH
7002: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_VAR 0 1
7015: PPUSH
7016: CALL_OW 308
7020: PUSH
7021: LD_VAR 0 4
7025: PPUSH
7026: LD_INT 1
7028: PPUSH
7029: CALL_OW 289
7033: PUSH
7034: LD_INT 0
7036: EQUAL
7037: AND
7038: IFFALSE 7063
// begin RemoveUnit ( GetDriver ( i ) ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: CALL 31775 0 1
7049: PPUSH
7050: CALL_OW 64
// RemoveUnit ( i ) ;
7054: LD_VAR 0 4
7058: PPUSH
7059: CALL_OW 64
// end ; end ;
7063: GO 6913
7065: POP
7066: POP
// end ;
7067: GO 6864
// end ;
7069: LD_VAR 0 3
7073: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7074: LD_INT 0
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
// if isTest then
7080: LD_EXP 1
7084: IFFALSE 7088
// exit ;
7086: GO 7533
// for i = 1 to n do
7088: LD_ADDR_VAR 0 4
7092: PUSH
7093: DOUBLE
7094: LD_INT 1
7096: DEC
7097: ST_TO_ADDR
7098: LD_VAR 0 2
7102: PUSH
7103: FOR_TO
7104: IFFALSE 7392
// begin uc_side := 8 ;
7106: LD_ADDR_OWVAR 20
7110: PUSH
7111: LD_INT 8
7113: ST_TO_ADDR
// uc_nation := 1 ;
7114: LD_ADDR_OWVAR 21
7118: PUSH
7119: LD_INT 1
7121: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7122: LD_ADDR_VAR 0 6
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PPUSH
7149: CALL_OW 12
7153: ARRAY
7154: ST_TO_ADDR
// vc_chassis := ch ;
7155: LD_ADDR_OWVAR 37
7159: PUSH
7160: LD_VAR 0 6
7164: ST_TO_ADDR
// vc_control := control_computer ;
7165: LD_ADDR_OWVAR 38
7169: PUSH
7170: LD_INT 3
7172: ST_TO_ADDR
// vc_engine := engine_combustion ;
7173: LD_ADDR_OWVAR 39
7177: PUSH
7178: LD_INT 1
7180: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7181: LD_OWVAR 1
7185: PUSH
7186: LD_INT 42000
7188: PUSH
7189: LD_INT 33600
7191: PUSH
7192: LD_INT 29400
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: LESS
7206: IFFALSE 7237
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7208: LD_ADDR_OWVAR 40
7212: PUSH
7213: LD_INT 3
7215: PUSH
7216: LD_INT 5
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: LD_INT 1
7225: PPUSH
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 12
7233: ARRAY
7234: ST_TO_ADDR
7235: GO 7333
// if ch = us_medium_tracked then
7237: LD_VAR 0 6
7241: PUSH
7242: LD_INT 3
7244: EQUAL
7245: IFFALSE 7292
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7247: LD_ADDR_OWVAR 40
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: LD_INT 4
7257: PUSH
7258: LD_INT 5
7260: PUSH
7261: LD_INT 7
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: PUSH
7270: LD_OWVAR 67
7274: PPUSH
7275: LD_OWVAR 67
7279: PUSH
7280: LD_INT 1
7282: PLUS
7283: PPUSH
7284: CALL_OW 12
7288: ARRAY
7289: ST_TO_ADDR
7290: GO 7333
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7292: LD_ADDR_OWVAR 40
7296: PUSH
7297: LD_INT 5
7299: PUSH
7300: LD_INT 6
7302: PUSH
7303: LD_INT 7
7305: PUSH
7306: LD_INT 7
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_INT 1
7317: PPUSH
7318: LD_OWVAR 67
7322: PUSH
7323: LD_INT 1
7325: PLUS
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7333: LD_ADDR_OWVAR 41
7337: PUSH
7338: LD_INT 70
7340: ST_TO_ADDR
// un := CreateVehicle ;
7341: LD_ADDR_VAR 0 5
7345: PUSH
7346: CALL_OW 45
7350: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7351: LD_VAR 0 5
7355: PPUSH
7356: LD_VAR 0 1
7360: PPUSH
7361: LD_INT 0
7363: PPUSH
7364: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7368: LD_VAR 0 5
7372: PPUSH
7373: LD_INT 65
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: CALL_OW 111
// Wait ( 0 0$02 ) ;
7383: LD_INT 70
7385: PPUSH
7386: CALL_OW 67
// end ;
7390: GO 7103
7392: POP
7393: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7394: LD_INT 90
7396: PUSH
7397: LD_INT 80
7399: PUSH
7400: LD_INT 70
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: LIST
7407: PUSH
7408: LD_OWVAR 67
7412: ARRAY
7413: PPUSH
7414: CALL_OW 13
7418: IFFALSE 7525
// begin uc_side := 8 ;
7420: LD_ADDR_OWVAR 20
7424: PUSH
7425: LD_INT 8
7427: ST_TO_ADDR
// uc_nation := 1 ;
7428: LD_ADDR_OWVAR 21
7432: PUSH
7433: LD_INT 1
7435: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7436: LD_ADDR_OWVAR 37
7440: PUSH
7441: LD_INT 4
7443: ST_TO_ADDR
// vc_control := control_computer ;
7444: LD_ADDR_OWVAR 38
7448: PUSH
7449: LD_INT 3
7451: ST_TO_ADDR
// vc_engine := engine_combustion ;
7452: LD_ADDR_OWVAR 39
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7460: LD_ADDR_OWVAR 40
7464: PUSH
7465: LD_INT 14
7467: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7468: LD_ADDR_OWVAR 41
7472: PUSH
7473: LD_INT 70
7475: ST_TO_ADDR
// un := CreateVehicle ;
7476: LD_ADDR_VAR 0 5
7480: PUSH
7481: CALL_OW 45
7485: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7486: LD_VAR 0 5
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 0
7498: PPUSH
7499: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7503: LD_VAR 0 5
7507: PPUSH
7508: LD_INT 65
7510: PPUSH
7511: LD_INT 9
7513: PPUSH
7514: CALL_OW 111
// Wait ( 0 0$02 ) ;
7518: LD_INT 70
7520: PPUSH
7521: CALL_OW 67
// end ; alfa_support := true ;
7525: LD_ADDR_EXP 13
7529: PUSH
7530: LD_INT 1
7532: ST_TO_ADDR
// end ;
7533: LD_VAR 0 3
7537: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7538: LD_OWVAR 1
7542: PUSH
7543: LD_INT 25200
7545: PUSH
7546: LD_INT 23100
7548: PUSH
7549: LD_INT 21000
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_OWVAR 67
7561: ARRAY
7562: GREATER
7563: IFFALSE 7708
7565: GO 7567
7567: DISABLE
7568: LD_INT 0
7570: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_INT 3
7578: PUSH
7579: LD_INT 4
7581: PUSH
7582: LD_INT 5
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PUSH
7590: LD_OWVAR 67
7594: ARRAY
7595: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7596: LD_INT 1050
7598: PPUSH
7599: LD_INT 4200
7601: PPUSH
7602: CALL_OW 12
7606: PPUSH
7607: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7611: LD_INT 20
7613: PPUSH
7614: LD_VAR 0 1
7618: PPUSH
7619: CALL 7074 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7623: LD_INT 22
7625: PUSH
7626: LD_INT 8
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PPUSH
7633: CALL_OW 69
7637: IFFALSE 7651
// SayRadio ( Popov , DR5 ) ;
7639: LD_EXP 24
7643: PPUSH
7644: LD_STRING DR5
7646: PPUSH
7647: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7651: LD_INT 8400
7653: PPUSH
7654: LD_INT 12600
7656: PPUSH
7657: CALL_OW 12
7661: PPUSH
7662: CALL_OW 67
// n := n + 1 ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_VAR 0 1
7675: PUSH
7676: LD_INT 1
7678: PLUS
7679: ST_TO_ADDR
// if n > 9 then
7680: LD_VAR 0 1
7684: PUSH
7685: LD_INT 9
7687: GREATER
7688: IFFALSE 7698
// n := 9 ;
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: LD_INT 9
7697: ST_TO_ADDR
// until tick >= 120 120$00 ;
7698: LD_OWVAR 1
7702: PUSH
7703: LD_INT 252000
7705: GREATEREQUAL
7706: IFFALSE 7596
// end ; end_of_file
7708: PPOPN 1
7710: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7711: LD_INT 0
7713: PPUSH
// enable_addtolog := isTest ;
7714: LD_ADDR_OWVAR 81
7718: PUSH
7719: LD_EXP 1
7723: ST_TO_ADDR
// lines_break_limit := 5 ;
7724: LD_ADDR_EXP 26
7728: PUSH
7729: LD_INT 5
7731: ST_TO_ADDR
// lines_break_type := --- ;
7732: LD_ADDR_EXP 27
7736: PUSH
7737: LD_STRING ---
7739: ST_TO_ADDR
// lines_counter := 0 ;
7740: LD_ADDR_EXP 25
7744: PUSH
7745: LD_INT 0
7747: ST_TO_ADDR
// show_line_index := true ;
7748: LD_ADDR_EXP 28
7752: PUSH
7753: LD_INT 1
7755: ST_TO_ADDR
// tick_log := true ;
7756: LD_ADDR_EXP 29
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7764: LD_STRING ----------SAND OF SIBERIA LOG----------
7766: PPUSH
7767: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7771: LD_STRING Map Name: 
7773: PUSH
7774: LD_OWVAR 68
7778: STR
7779: PPUSH
7780: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7784: LD_STRING Map Number: 
7786: PUSH
7787: LD_OWVAR 70
7791: STR
7792: PPUSH
7793: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7797: LD_STRING Difficulty: 
7799: PUSH
7800: LD_OWVAR 67
7804: STR
7805: PPUSH
7806: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7810: LD_STRING ---------------------------------------
7812: PPUSH
7813: CALL_OW 561
// end ;
7817: LD_VAR 0 1
7821: RET
// function Log ( text ) ; begin
7822: LD_INT 0
7824: PPUSH
// if show_line_index then
7825: LD_EXP 28
7829: IFFALSE 7841
// result := lines_counter ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_EXP 25
7840: ST_TO_ADDR
// if tick_log then
7841: LD_EXP 29
7845: IFFALSE 7871
// result := result &  T:  & tick &   ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 2
7856: PUSH
7857: LD_STRING  T: 
7859: STR
7860: PUSH
7861: LD_OWVAR 1
7865: STR
7866: PUSH
7867: LD_STRING  
7869: STR
7870: ST_TO_ADDR
// AddToLog ( result & text ) ;
7871: LD_VAR 0 2
7875: PUSH
7876: LD_VAR 0 1
7880: STR
7881: PPUSH
7882: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7886: LD_ADDR_EXP 25
7890: PUSH
7891: LD_EXP 25
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7900: LD_EXP 25
7904: PUSH
7905: LD_EXP 26
7909: MOD
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7925
// AddToLog ( lines_break_type ) ;
7916: LD_EXP 27
7920: PPUSH
7921: CALL_OW 561
// end ;
7925: LD_VAR 0 2
7929: RET
// export function LogHuman ( id ) ; begin
7930: LD_INT 0
7932: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7933: LD_STRING Human Created. id: 
7935: PUSH
7936: LD_VAR 0 1
7940: STR
7941: PUSH
7942: LD_STRING ; side: 
7944: STR
7945: PUSH
7946: LD_VAR 0 1
7950: PPUSH
7951: CALL_OW 255
7955: STR
7956: PUSH
7957: LD_STRING ; class: 
7959: STR
7960: PUSH
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 257
7970: STR
7971: PUSH
7972: LD_STRING ; 
7974: STR
7975: PPUSH
7976: CALL 7822 0 1
// end ;
7980: LD_VAR 0 2
7984: RET
// export function LogVeh ( id ) ; begin
7985: LD_INT 0
7987: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7988: LD_STRING Vehicle Created. id: 
7990: PUSH
7991: LD_VAR 0 1
7995: STR
7996: PUSH
7997: LD_STRING ; side: 
7999: STR
8000: PUSH
8001: LD_VAR 0 1
8005: PPUSH
8006: CALL_OW 255
8010: STR
8011: PUSH
8012: LD_STRING ; nation: 
8014: STR
8015: PUSH
8016: LD_VAR 0 1
8020: PPUSH
8021: CALL_OW 248
8025: STR
8026: PUSH
8027: LD_STRING ; weapon: 
8029: STR
8030: PUSH
8031: LD_VAR 0 1
8035: PPUSH
8036: CALL_OW 264
8040: STR
8041: PUSH
8042: LD_STRING ; 
8044: STR
8045: PPUSH
8046: CALL 7822 0 1
// end ;
8050: LD_VAR 0 2
8054: RET
// export function LogEvent ( event ) ; begin
8055: LD_INT 0
8057: PPUSH
// Log ( Event Executed. id:  & event ) ;
8058: LD_STRING Event Executed. id: 
8060: PUSH
8061: LD_VAR 0 1
8065: STR
8066: PPUSH
8067: CALL 7822 0 1
// end ; end_of_file
8071: LD_VAR 0 2
8075: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8076: LD_INT 0
8078: PPUSH
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
8084: PPUSH
8085: PPUSH
// if unit then
8086: LD_VAR 0 1
8090: IFFALSE 8490
// begin if mode = 0 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 0
8099: EQUAL
8100: IFFALSE 8248
// begin if coords then
8102: LD_VAR 0 2
8106: IFFALSE 8246
// while ( coords > 1 ) do
8108: LD_VAR 0 2
8112: PUSH
8113: LD_INT 1
8115: GREATER
8116: IFFALSE 8246
// if not HasTask ( unit ) then
8118: LD_VAR 0 1
8122: PPUSH
8123: CALL_OW 314
8127: NOT
8128: IFFALSE 8244
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8130: LD_VAR 0 1
8134: PPUSH
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 2
8148: PUSH
8149: LD_INT 2
8151: ARRAY
8152: PPUSH
8153: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8157: LD_INT 35
8159: PPUSH
8160: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8164: LD_VAR 0 1
8168: PPUSH
8169: CALL_OW 250
8173: PUSH
8174: LD_VAR 0 2
8178: PUSH
8179: LD_INT 1
8181: ARRAY
8182: EQUAL
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 251
8193: PUSH
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 2
8201: ARRAY
8202: EQUAL
8203: AND
8204: IFFALSE 8157
// for i = 1 to 2 do
8206: LD_ADDR_VAR 0 5
8210: PUSH
8211: DOUBLE
8212: LD_INT 1
8214: DEC
8215: ST_TO_ADDR
8216: LD_INT 2
8218: PUSH
8219: FOR_TO
8220: IFFALSE 8242
// coords := Delete ( coords , 1 ) ;
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 2
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: CALL_OW 3
8239: ST_TO_ADDR
8240: GO 8219
8242: POP
8243: POP
// end ;
8244: GO 8108
// end else
8246: GO 8490
// begin if coords then
8248: LD_VAR 0 2
8252: IFFALSE 8490
// begin x := GetX ( unit ) ;
8254: LD_ADDR_VAR 0 6
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 250
8268: ST_TO_ADDR
// y := GetY ( unit ) ;
8269: LD_ADDR_VAR 0 7
8273: PUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 251
8283: ST_TO_ADDR
// while ( coords > 1 ) do
8284: LD_VAR 0 2
8288: PUSH
8289: LD_INT 1
8291: GREATER
8292: IFFALSE 8490
// begin Wait ( 0 0$0.3 ) ;
8294: LD_INT 10
8296: PPUSH
8297: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8301: LD_VAR 0 1
8305: PPUSH
8306: CALL_OW 255
8310: PPUSH
8311: LD_VAR 0 1
8315: PPUSH
8316: CALL_OW 250
8320: PPUSH
8321: LD_VAR 0 1
8325: PPUSH
8326: CALL_OW 251
8330: PPUSH
8331: LD_INT 14
8333: PPUSH
8334: CALL 22837 0 4
8338: IFFALSE 8369
// begin ComMoveXY ( unit , x , y ) ;
8340: LD_VAR 0 1
8344: PPUSH
8345: LD_VAR 0 6
8349: PPUSH
8350: LD_VAR 0 7
8354: PPUSH
8355: CALL_OW 111
// result := false ;
8359: LD_ADDR_VAR 0 4
8363: PUSH
8364: LD_INT 0
8366: ST_TO_ADDR
// end else
8367: GO 8408
// if not HasTask ( unit ) then
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 314
8378: NOT
8379: IFFALSE 8408
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8381: LD_VAR 0 1
8385: PPUSH
8386: LD_VAR 0 2
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PPUSH
8395: LD_VAR 0 2
8399: PUSH
8400: LD_INT 2
8402: ARRAY
8403: PPUSH
8404: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8408: LD_VAR 0 1
8412: PPUSH
8413: CALL_OW 250
8417: PUSH
8418: LD_VAR 0 2
8422: PUSH
8423: LD_INT 1
8425: ARRAY
8426: EQUAL
8427: PUSH
8428: LD_VAR 0 1
8432: PPUSH
8433: CALL_OW 251
8437: PUSH
8438: LD_VAR 0 2
8442: PUSH
8443: LD_INT 2
8445: ARRAY
8446: EQUAL
8447: AND
8448: IFFALSE 8488
// for i = 1 to 2 do
8450: LD_ADDR_VAR 0 5
8454: PUSH
8455: DOUBLE
8456: LD_INT 1
8458: DEC
8459: ST_TO_ADDR
8460: LD_INT 2
8462: PUSH
8463: FOR_TO
8464: IFFALSE 8486
// coords := Delete ( coords , 1 ) ;
8466: LD_ADDR_VAR 0 2
8470: PUSH
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 1
8478: PPUSH
8479: CALL_OW 3
8483: ST_TO_ADDR
8484: GO 8463
8486: POP
8487: POP
// end ;
8488: GO 8284
// end ; end ; end ; result := true ;
8490: LD_ADDR_VAR 0 4
8494: PUSH
8495: LD_INT 1
8497: ST_TO_ADDR
// end ;
8498: LD_VAR 0 4
8502: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8503: LD_INT 0
8505: PPUSH
8506: PPUSH
8507: PPUSH
// if not units then
8508: LD_VAR 0 2
8512: NOT
8513: IFFALSE 8517
// exit ;
8515: GO 8580
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8517: LD_ADDR_VAR 0 5
8521: PUSH
8522: LD_INT 81
8524: PUSH
8525: LD_VAR 0 1
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// for i in units do
8539: LD_ADDR_VAR 0 4
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8578
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8552: LD_VAR 0 4
8556: PPUSH
8557: LD_VAR 0 5
8561: PPUSH
8562: LD_VAR 0 4
8566: PPUSH
8567: CALL_OW 74
8571: PPUSH
8572: CALL_OW 115
// end ;
8576: GO 8549
8578: POP
8579: POP
// end ;
8580: LD_VAR 0 3
8584: RET
// export function MC_Show ( string ) ; begin
8585: LD_INT 0
8587: PPUSH
// display_strings := string ;
8588: LD_ADDR_OWVAR 47
8592: PUSH
8593: LD_VAR 0 1
8597: ST_TO_ADDR
// end ; end_of_file
8598: LD_VAR 0 2
8602: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8603: LD_INT 0
8605: PPUSH
8606: PPUSH
8607: PPUSH
8608: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8609: LD_ADDR_VAR 0 8
8613: PUSH
8614: LD_VAR 0 1
8618: PPUSH
8619: LD_INT 2
8621: PPUSH
8622: EMPTY
8623: PPUSH
8624: CALL 11750 0 3
8628: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8629: LD_VAR 0 8
8633: PUSH
8634: LD_VAR 0 2
8638: PPUSH
8639: LD_VAR 0 3
8643: PPUSH
8644: CALL_OW 428
8648: PUSH
8649: LD_INT 0
8651: EQUAL
8652: AND
8653: IFFALSE 8727
// for i = 1 to plist do
8655: LD_ADDR_VAR 0 6
8659: PUSH
8660: DOUBLE
8661: LD_INT 1
8663: DEC
8664: ST_TO_ADDR
8665: LD_VAR 0 8
8669: PUSH
8670: FOR_TO
8671: IFFALSE 8725
// if NotTask ( plist [ i ] ) then
8673: LD_VAR 0 8
8677: PUSH
8678: LD_VAR 0 6
8682: ARRAY
8683: PPUSH
8684: CALL 32238 0 1
8688: IFFALSE 8723
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8690: LD_VAR 0 8
8694: PUSH
8695: LD_VAR 0 6
8699: ARRAY
8700: PPUSH
8701: LD_INT 0
8703: PPUSH
8704: LD_VAR 0 2
8708: PPUSH
8709: LD_VAR 0 3
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: CALL_OW 145
// end ;
8723: GO 8670
8725: POP
8726: POP
// end ;
8727: LD_VAR 0 5
8731: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8732: LD_INT 0
8734: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8735: LD_VAR 0 1
8739: PPUSH
8740: LD_INT 6
8742: PPUSH
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_VAR 0 3
8752: PPUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL 10236 0 5
// end ;
8762: LD_VAR 0 5
8766: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8767: LD_INT 0
8769: PPUSH
8770: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8771: LD_ADDR_VAR 0 4
8775: PUSH
8776: LD_INT 22
8778: PUSH
8779: LD_VAR 0 1
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 2
8790: PUSH
8791: LD_INT 30
8793: PUSH
8794: LD_INT 0
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 30
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: PPUSH
8823: CALL_OW 69
8827: PPUSH
8828: LD_VAR 0 2
8832: PPUSH
8833: CALL_OW 250
8837: PPUSH
8838: LD_VAR 0 2
8842: PPUSH
8843: CALL_OW 251
8847: PPUSH
8848: CALL_OW 73
8852: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: CALL 10525 0 2
8867: IFFALSE 8926
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8869: LD_VAR 0 1
8873: PPUSH
8874: LD_INT 30
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PPUSH
8886: CALL 11667 0 2
8890: PUSH
8891: LD_INT 1
8893: ARRAY
8894: PPUSH
8895: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8899: LD_ADDR_EXP 48
8903: PUSH
8904: LD_EXP 48
8908: PPUSH
8909: LD_VAR 0 1
8913: PPUSH
8914: LD_VAR 0 2
8918: PPUSH
8919: EMPTY
8920: PPUSH
8921: CALL 42053 0 4
8925: ST_TO_ADDR
// end ; end ;
8926: LD_VAR 0 3
8930: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8931: LD_INT 0
8933: PPUSH
8934: PPUSH
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
// result := false ;
8939: LD_ADDR_VAR 0 4
8943: PUSH
8944: LD_INT 0
8946: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8947: LD_VAR 0 1
8951: PPUSH
8952: LD_EXP 40
8956: PPUSH
8957: CALL 43001 0 2
8961: IFFALSE 9174
// for i = 1 to MREG_LabList do
8963: LD_ADDR_VAR 0 5
8967: PUSH
8968: DOUBLE
8969: LD_INT 1
8971: DEC
8972: ST_TO_ADDR
8973: LD_EXP 40
8977: PUSH
8978: FOR_TO
8979: IFFALSE 9172
// begin if MREG_LabList [ i ] [ 1 ] = side then
8981: LD_EXP 40
8985: PUSH
8986: LD_VAR 0 5
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PUSH
8996: LD_VAR 0 1
9000: EQUAL
9001: IFFALSE 9170
// begin lab := MREG_LabList [ i ] [ 2 ] ;
9003: LD_ADDR_VAR 0 7
9007: PUSH
9008: LD_EXP 40
9012: PUSH
9013: LD_VAR 0 5
9017: ARRAY
9018: PUSH
9019: LD_INT 2
9021: ARRAY
9022: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9023: LD_ADDR_VAR 0 9
9027: PUSH
9028: LD_INT 22
9030: PUSH
9031: LD_VAR 0 1
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: LD_INT 2
9042: PUSH
9043: LD_INT 30
9045: PUSH
9046: LD_INT 0
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: LD_INT 30
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: EMPTY
9073: LIST
9074: PPUSH
9075: CALL_OW 69
9079: PPUSH
9080: LD_VAR 0 7
9084: PPUSH
9085: CALL_OW 250
9089: PPUSH
9090: LD_VAR 0 7
9094: PPUSH
9095: CALL_OW 251
9099: PPUSH
9100: CALL_OW 73
9104: ST_TO_ADDR
// if dep then
9105: LD_VAR 0 9
9109: IFFALSE 9168
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9111: LD_VAR 0 9
9115: PPUSH
9116: LD_VAR 0 2
9120: PPUSH
9121: LD_VAR 0 3
9125: PPUSH
9126: CALL 10641 0 3
9130: IFFALSE 9168
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9132: LD_VAR 0 7
9136: PPUSH
9137: LD_VAR 0 2
9141: PPUSH
9142: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9146: LD_VAR 0 7
9150: PPUSH
9151: LD_VAR 0 3
9155: PPUSH
9156: CALL_OW 207
// result := true ;
9160: LD_ADDR_VAR 0 4
9164: PUSH
9165: LD_INT 1
9167: ST_TO_ADDR
// end ; end ; break ;
9168: GO 9172
// end ; end ;
9170: GO 8978
9172: POP
9173: POP
// end ;
9174: LD_VAR 0 4
9178: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9179: LD_INT 0
9181: PPUSH
9182: PPUSH
9183: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9184: LD_ADDR_VAR 0 7
9188: PUSH
9189: LD_VAR 0 2
9193: PPUSH
9194: LD_VAR 0 3
9198: PPUSH
9199: LD_VAR 0 4
9203: PPUSH
9204: CALL 9366 0 3
9208: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9209: LD_ADDR_EXP 46
9213: PUSH
9214: LD_EXP 46
9218: PPUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: LD_INT 2
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 3
9236: PUSH
9237: LD_VAR 0 4
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL 41962 0 4
9251: ST_TO_ADDR
// if ext_list then
9252: LD_VAR 0 5
9256: IFFALSE 9361
// for i = 1 to ext_list do
9258: LD_ADDR_VAR 0 8
9262: PUSH
9263: DOUBLE
9264: LD_INT 1
9266: DEC
9267: ST_TO_ADDR
9268: LD_VAR 0 5
9272: PUSH
9273: FOR_TO
9274: IFFALSE 9359
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9276: LD_ADDR_EXP 46
9280: PUSH
9281: LD_EXP 46
9285: PPUSH
9286: LD_VAR 0 1
9290: PPUSH
9291: LD_VAR 0 5
9295: PUSH
9296: LD_VAR 0 8
9300: ARRAY
9301: PPUSH
9302: LD_VAR 0 7
9306: PUSH
9307: LD_VAR 0 8
9311: ARRAY
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PUSH
9317: LD_VAR 0 7
9321: PUSH
9322: LD_VAR 0 8
9326: ARRAY
9327: PUSH
9328: LD_INT 2
9330: ARRAY
9331: PUSH
9332: LD_VAR 0 7
9336: PUSH
9337: LD_VAR 0 8
9341: ARRAY
9342: PUSH
9343: LD_INT 3
9345: ARRAY
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL 41962 0 4
9356: ST_TO_ADDR
9357: GO 9273
9359: POP
9360: POP
// end ;
9361: LD_VAR 0 6
9365: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9366: LD_INT 0
9368: PPUSH
9369: PPUSH
// list := [ ] ;
9370: LD_ADDR_VAR 0 5
9374: PUSH
9375: EMPTY
9376: ST_TO_ADDR
// case d of 0 :
9377: LD_VAR 0 3
9381: PUSH
9382: LD_INT 0
9384: DOUBLE
9385: EQUAL
9386: IFTRUE 9390
9388: GO 9523
9390: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9391: LD_ADDR_VAR 0 5
9395: PUSH
9396: LD_VAR 0 1
9400: PUSH
9401: LD_INT 4
9403: MINUS
9404: PUSH
9405: LD_VAR 0 2
9409: PUSH
9410: LD_INT 4
9412: MINUS
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 3
9429: MINUS
9430: PUSH
9431: LD_VAR 0 2
9435: PUSH
9436: LD_INT 1
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: PUSH
9444: LD_VAR 0 1
9448: PUSH
9449: LD_INT 4
9451: PLUS
9452: PUSH
9453: LD_VAR 0 2
9457: PUSH
9458: LD_INT 4
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: LIST
9465: PUSH
9466: LD_VAR 0 1
9470: PUSH
9471: LD_INT 3
9473: PLUS
9474: PUSH
9475: LD_VAR 0 2
9479: PUSH
9480: LD_INT 3
9482: PLUS
9483: PUSH
9484: LD_INT 5
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_VAR 0 1
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_INT 4
9504: PLUS
9505: PUSH
9506: LD_INT 0
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// end ; 1 :
9521: GO 10221
9523: LD_INT 1
9525: DOUBLE
9526: EQUAL
9527: IFTRUE 9531
9529: GO 9664
9531: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9532: LD_ADDR_VAR 0 5
9536: PUSH
9537: LD_VAR 0 1
9541: PUSH
9542: LD_VAR 0 2
9546: PUSH
9547: LD_INT 4
9549: MINUS
9550: PUSH
9551: LD_INT 3
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: PUSH
9559: LD_VAR 0 1
9563: PUSH
9564: LD_INT 3
9566: MINUS
9567: PUSH
9568: LD_VAR 0 2
9572: PUSH
9573: LD_INT 3
9575: MINUS
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: PUSH
9585: LD_VAR 0 1
9589: PUSH
9590: LD_INT 4
9592: MINUS
9593: PUSH
9594: LD_VAR 0 2
9598: PUSH
9599: LD_INT 1
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_VAR 0 1
9611: PUSH
9612: LD_VAR 0 2
9616: PUSH
9617: LD_INT 3
9619: PLUS
9620: PUSH
9621: LD_INT 0
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_VAR 0 1
9633: PUSH
9634: LD_INT 4
9636: PLUS
9637: PUSH
9638: LD_VAR 0 2
9642: PUSH
9643: LD_INT 4
9645: PLUS
9646: PUSH
9647: LD_INT 5
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: LIST
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: ST_TO_ADDR
// end ; 2 :
9662: GO 10221
9664: LD_INT 2
9666: DOUBLE
9667: EQUAL
9668: IFTRUE 9672
9670: GO 9801
9672: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9673: LD_ADDR_VAR 0 5
9677: PUSH
9678: LD_VAR 0 1
9682: PUSH
9683: LD_VAR 0 2
9687: PUSH
9688: LD_INT 3
9690: MINUS
9691: PUSH
9692: LD_INT 3
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: PUSH
9700: LD_VAR 0 1
9704: PUSH
9705: LD_INT 4
9707: PLUS
9708: PUSH
9709: LD_VAR 0 2
9713: PUSH
9714: LD_INT 4
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: PUSH
9722: LD_VAR 0 1
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 4
9734: PLUS
9735: PUSH
9736: LD_INT 0
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: LD_VAR 0 1
9748: PUSH
9749: LD_INT 3
9751: MINUS
9752: PUSH
9753: LD_VAR 0 2
9757: PUSH
9758: LD_INT 1
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: LD_VAR 0 1
9770: PUSH
9771: LD_INT 4
9773: MINUS
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: LD_INT 4
9782: MINUS
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: ST_TO_ADDR
// end ; 3 :
9799: GO 10221
9801: LD_INT 3
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9942
9809: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9810: LD_ADDR_VAR 0 5
9814: PUSH
9815: LD_VAR 0 1
9819: PUSH
9820: LD_INT 3
9822: PLUS
9823: PUSH
9824: LD_VAR 0 2
9828: PUSH
9829: LD_INT 4
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 4
9844: PLUS
9845: PUSH
9846: LD_VAR 0 2
9850: PUSH
9851: LD_INT 4
9853: PLUS
9854: PUSH
9855: LD_INT 5
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_VAR 0 1
9867: PUSH
9868: LD_INT 4
9870: MINUS
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: LD_INT 1
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: LIST
9884: PUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_VAR 0 2
9894: PUSH
9895: LD_INT 4
9897: MINUS
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: LD_VAR 0 1
9911: PUSH
9912: LD_INT 3
9914: MINUS
9915: PUSH
9916: LD_VAR 0 2
9920: PUSH
9921: LD_INT 3
9923: MINUS
9924: PUSH
9925: LD_INT 2
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: ST_TO_ADDR
// end ; 4 :
9940: GO 10221
9942: LD_INT 4
9944: DOUBLE
9945: EQUAL
9946: IFTRUE 9950
9948: GO 10083
9950: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9951: LD_ADDR_VAR 0 5
9955: PUSH
9956: LD_VAR 0 1
9960: PUSH
9961: LD_VAR 0 2
9965: PUSH
9966: LD_INT 4
9968: PLUS
9969: PUSH
9970: LD_INT 0
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_VAR 0 1
9982: PUSH
9983: LD_INT 3
9985: PLUS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 3
9994: PLUS
9995: PUSH
9996: LD_INT 5
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: PUSH
10004: LD_VAR 0 1
10008: PUSH
10009: LD_INT 3
10011: PLUS
10012: PUSH
10013: LD_VAR 0 2
10017: PUSH
10018: LD_INT 4
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: PUSH
10026: LD_VAR 0 1
10030: PUSH
10031: LD_VAR 0 2
10035: PUSH
10036: LD_INT 3
10038: MINUS
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: PUSH
10048: LD_VAR 0 1
10052: PUSH
10053: LD_INT 4
10055: MINUS
10056: PUSH
10057: LD_VAR 0 2
10061: PUSH
10062: LD_INT 4
10064: MINUS
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: ST_TO_ADDR
// end ; 5 :
10081: GO 10221
10083: LD_INT 5
10085: DOUBLE
10086: EQUAL
10087: IFTRUE 10091
10089: GO 10220
10091: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10092: LD_ADDR_VAR 0 5
10096: PUSH
10097: LD_VAR 0 1
10101: PUSH
10102: LD_INT 4
10104: MINUS
10105: PUSH
10106: LD_VAR 0 2
10110: PUSH
10111: LD_INT 1
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_VAR 0 1
10123: PUSH
10124: LD_VAR 0 2
10128: PUSH
10129: LD_INT 4
10131: MINUS
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: LIST
10140: PUSH
10141: LD_VAR 0 1
10145: PUSH
10146: LD_INT 4
10148: PLUS
10149: PUSH
10150: LD_VAR 0 2
10154: PUSH
10155: LD_INT 4
10157: PLUS
10158: PUSH
10159: LD_INT 5
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_VAR 0 1
10171: PUSH
10172: LD_INT 3
10174: PLUS
10175: PUSH
10176: LD_VAR 0 2
10180: PUSH
10181: LD_INT 4
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_VAR 0 1
10193: PUSH
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 3
10201: PLUS
10202: PUSH
10203: LD_INT 0
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: ST_TO_ADDR
// end ; end ;
10218: GO 10221
10220: POP
// result := list ;
10221: LD_ADDR_VAR 0 4
10225: PUSH
10226: LD_VAR 0 5
10230: ST_TO_ADDR
// end ;
10231: LD_VAR 0 4
10235: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10236: LD_INT 0
10238: PPUSH
10239: PPUSH
10240: PPUSH
10241: PPUSH
10242: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10243: LD_ADDR_VAR 0 10
10247: PUSH
10248: LD_VAR 0 1
10252: PPUSH
10253: LD_INT 2
10255: PPUSH
10256: EMPTY
10257: PPUSH
10258: CALL 11750 0 3
10262: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10263: LD_ADDR_VAR 0 9
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_VAR 0 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: LD_INT 30
10285: PUSH
10286: LD_INT 0
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 30
10295: PUSH
10296: LD_INT 1
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: PPUSH
10315: CALL_OW 69
10319: PPUSH
10320: LD_VAR 0 3
10324: PPUSH
10325: LD_VAR 0 4
10329: PPUSH
10330: CALL_OW 73
10334: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10335: LD_ADDR_VAR 0 8
10339: PUSH
10340: LD_VAR 0 9
10344: PPUSH
10345: LD_VAR 0 2
10349: PPUSH
10350: CALL 10525 0 2
10354: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10355: LD_VAR 0 10
10359: PUSH
10360: LD_VAR 0 8
10364: AND
10365: PUSH
10366: LD_VAR 0 9
10370: PPUSH
10371: LD_VAR 0 3
10375: PPUSH
10376: LD_VAR 0 4
10380: PPUSH
10381: CALL_OW 297
10385: PUSH
10386: LD_INT 26
10388: LESSEQUAL
10389: AND
10390: PUSH
10391: LD_VAR 0 3
10395: PPUSH
10396: LD_VAR 0 4
10400: PPUSH
10401: CALL_OW 428
10405: PUSH
10406: LD_INT 0
10408: EQUAL
10409: AND
10410: IFFALSE 10520
// for i = 1 to plist do
10412: LD_ADDR_VAR 0 7
10416: PUSH
10417: DOUBLE
10418: LD_INT 1
10420: DEC
10421: ST_TO_ADDR
10422: LD_VAR 0 10
10426: PUSH
10427: FOR_TO
10428: IFFALSE 10518
// if IsInUnit ( plist [ i ] ) then
10430: LD_VAR 0 10
10434: PUSH
10435: LD_VAR 0 7
10439: ARRAY
10440: PPUSH
10441: CALL_OW 310
10445: IFFALSE 10464
// ComExitBuilding ( plist [ i ] ) else
10447: LD_VAR 0 10
10451: PUSH
10452: LD_VAR 0 7
10456: ARRAY
10457: PPUSH
10458: CALL_OW 122
10462: GO 10516
// if NotTask ( plist [ i ] ) then
10464: LD_VAR 0 10
10468: PUSH
10469: LD_VAR 0 7
10473: ARRAY
10474: PPUSH
10475: CALL 32238 0 1
10479: IFFALSE 10516
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10481: LD_VAR 0 10
10485: PUSH
10486: LD_VAR 0 7
10490: ARRAY
10491: PPUSH
10492: LD_VAR 0 2
10496: PPUSH
10497: LD_VAR 0 3
10501: PPUSH
10502: LD_VAR 0 4
10506: PPUSH
10507: LD_VAR 0 5
10511: PPUSH
10512: CALL_OW 145
// end ;
10516: GO 10427
10518: POP
10519: POP
// end ;
10520: LD_VAR 0 6
10524: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10525: LD_INT 0
10527: PPUSH
10528: PPUSH
10529: PPUSH
// pom := GetBase ( bdepot ) ;
10530: LD_ADDR_VAR 0 4
10534: PUSH
10535: LD_VAR 0 1
10539: PPUSH
10540: CALL_OW 274
10544: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10545: LD_ADDR_VAR 0 5
10549: PUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL_OW 248
10564: PPUSH
10565: CALL_OW 450
10569: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10570: LD_VAR 0 4
10574: PPUSH
10575: LD_INT 1
10577: PPUSH
10578: CALL_OW 275
10582: PUSH
10583: LD_VAR 0 5
10587: PUSH
10588: LD_INT 1
10590: ARRAY
10591: GREATEREQUAL
10592: PUSH
10593: LD_VAR 0 4
10597: PPUSH
10598: LD_INT 3
10600: PPUSH
10601: CALL_OW 275
10605: PUSH
10606: LD_VAR 0 5
10610: PUSH
10611: LD_INT 3
10613: ARRAY
10614: GREATEREQUAL
10615: AND
10616: IFFALSE 10628
// result := true else
10618: LD_ADDR_VAR 0 3
10622: PUSH
10623: LD_INT 1
10625: ST_TO_ADDR
10626: GO 10636
// result := false ;
10628: LD_ADDR_VAR 0 3
10632: PUSH
10633: LD_INT 0
10635: ST_TO_ADDR
// end ;
10636: LD_VAR 0 3
10640: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10641: LD_INT 0
10643: PPUSH
10644: PPUSH
10645: PPUSH
10646: PPUSH
10647: PPUSH
// pom := GetBase ( bdepot ) ;
10648: LD_ADDR_VAR 0 5
10652: PUSH
10653: LD_VAR 0 1
10657: PPUSH
10658: CALL_OW 274
10662: ST_TO_ADDR
// cost := [ ] ;
10663: LD_ADDR_VAR 0 8
10667: PUSH
10668: EMPTY
10669: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10670: LD_ADDR_VAR 0 6
10674: PUSH
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_VAR 0 1
10684: PPUSH
10685: CALL_OW 248
10689: PPUSH
10690: CALL_OW 450
10694: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10695: LD_ADDR_VAR 0 7
10699: PUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 248
10714: PPUSH
10715: CALL_OW 450
10719: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10720: LD_ADDR_VAR 0 8
10724: PUSH
10725: LD_VAR 0 8
10729: PPUSH
10730: LD_INT 1
10732: PPUSH
10733: LD_VAR 0 6
10737: PUSH
10738: LD_INT 1
10740: ARRAY
10741: PUSH
10742: LD_VAR 0 7
10746: PUSH
10747: LD_INT 1
10749: ARRAY
10750: PLUS
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10757: LD_ADDR_VAR 0 8
10761: PUSH
10762: LD_VAR 0 8
10766: PPUSH
10767: LD_INT 2
10769: PPUSH
10770: LD_VAR 0 6
10774: PUSH
10775: LD_INT 2
10777: ARRAY
10778: PUSH
10779: LD_VAR 0 7
10783: PUSH
10784: LD_INT 2
10786: ARRAY
10787: PLUS
10788: PPUSH
10789: CALL_OW 1
10793: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10794: LD_ADDR_VAR 0 8
10798: PUSH
10799: LD_VAR 0 8
10803: PPUSH
10804: LD_INT 3
10806: PPUSH
10807: LD_VAR 0 6
10811: PUSH
10812: LD_INT 3
10814: ARRAY
10815: PUSH
10816: LD_VAR 0 7
10820: PUSH
10821: LD_INT 3
10823: ARRAY
10824: PLUS
10825: PPUSH
10826: CALL_OW 1
10830: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10831: LD_VAR 0 5
10835: PPUSH
10836: LD_INT 1
10838: PPUSH
10839: CALL_OW 275
10843: PUSH
10844: LD_VAR 0 8
10848: PUSH
10849: LD_INT 1
10851: ARRAY
10852: GREATEREQUAL
10853: PUSH
10854: LD_VAR 0 5
10858: PPUSH
10859: LD_INT 3
10861: PPUSH
10862: CALL_OW 275
10866: PUSH
10867: LD_VAR 0 8
10871: PUSH
10872: LD_INT 3
10874: ARRAY
10875: GREATEREQUAL
10876: AND
10877: IFFALSE 10889
// result := true else
10879: LD_ADDR_VAR 0 4
10883: PUSH
10884: LD_INT 1
10886: ST_TO_ADDR
10887: GO 10897
// result := false ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_INT 0
10896: ST_TO_ADDR
// end ;
10897: LD_VAR 0 4
10901: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10902: LD_INT 0
10904: PPUSH
10905: PPUSH
10906: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10907: LD_ADDR_VAR 0 5
10911: PUSH
10912: LD_VAR 0 1
10916: PPUSH
10917: LD_INT 2
10919: PPUSH
10920: EMPTY
10921: PPUSH
10922: CALL 11750 0 3
10926: ST_TO_ADDR
// if unit and plist then
10927: LD_VAR 0 2
10931: PUSH
10932: LD_VAR 0 5
10936: AND
10937: IFFALSE 10998
// for i = 1 to plist do
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: DOUBLE
10945: LD_INT 1
10947: DEC
10948: ST_TO_ADDR
10949: LD_VAR 0 5
10953: PUSH
10954: FOR_TO
10955: IFFALSE 10996
// if NotTask ( plist [ i ] ) then
10957: LD_VAR 0 5
10961: PUSH
10962: LD_VAR 0 4
10966: ARRAY
10967: PPUSH
10968: CALL 32238 0 1
10972: IFFALSE 10994
// ComDismantle ( plist [ i ] , unit ) ;
10974: LD_VAR 0 5
10978: PUSH
10979: LD_VAR 0 4
10983: ARRAY
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL_OW 167
10994: GO 10954
10996: POP
10997: POP
// result := true ;
10998: LD_ADDR_VAR 0 3
11002: PUSH
11003: LD_INT 1
11005: ST_TO_ADDR
// end ;
11006: LD_VAR 0 3
11010: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
11011: LD_INT 0
11013: PPUSH
11014: PPUSH
11015: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11016: LD_ADDR_VAR 0 5
11020: PUSH
11021: LD_VAR 0 1
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: EMPTY
11030: PPUSH
11031: CALL 11750 0 3
11035: ST_TO_ADDR
// if unit and plist then
11036: LD_VAR 0 2
11040: PUSH
11041: LD_VAR 0 5
11045: AND
11046: IFFALSE 11107
// for i = 1 to plist do
11048: LD_ADDR_VAR 0 4
11052: PUSH
11053: DOUBLE
11054: LD_INT 1
11056: DEC
11057: ST_TO_ADDR
11058: LD_VAR 0 5
11062: PUSH
11063: FOR_TO
11064: IFFALSE 11105
// if NotTask ( plist [ i ] ) then
11066: LD_VAR 0 5
11070: PUSH
11071: LD_VAR 0 4
11075: ARRAY
11076: PPUSH
11077: CALL 32238 0 1
11081: IFFALSE 11103
// ComComplete ( plist [ i ] , unit ) ;
11083: LD_VAR 0 5
11087: PUSH
11088: LD_VAR 0 4
11092: ARRAY
11093: PPUSH
11094: LD_VAR 0 2
11098: PPUSH
11099: CALL 69095 0 2
11103: GO 11063
11105: POP
11106: POP
// result := true ;
11107: LD_ADDR_VAR 0 3
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// end ;
11115: LD_VAR 0 3
11119: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11120: LD_INT 0
11122: PPUSH
11123: PPUSH
11124: PPUSH
11125: PPUSH
11126: PPUSH
11127: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11128: LD_ADDR_VAR 0 5
11132: PUSH
11133: LD_INT 22
11135: PUSH
11136: LD_VAR 0 1
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 21
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 57
11160: PUSH
11161: EMPTY
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 24
11173: PUSH
11174: LD_INT 1000
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: PPUSH
11191: CALL_OW 69
11195: ST_TO_ADDR
// r := [ ] ;
11196: LD_ADDR_VAR 0 6
11200: PUSH
11201: EMPTY
11202: ST_TO_ADDR
// if not tmp then
11203: LD_VAR 0 5
11207: NOT
11208: IFFALSE 11214
// exit else
11210: GO 11402
11212: GO 11382
// begin r := [ tmp [ 1 ] ] ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 5
11223: PUSH
11224: LD_INT 1
11226: ARRAY
11227: PUSH
11228: EMPTY
11229: LIST
11230: ST_TO_ADDR
// for i = 2 to tmp do
11231: LD_ADDR_VAR 0 3
11235: PUSH
11236: DOUBLE
11237: LD_INT 2
11239: DEC
11240: ST_TO_ADDR
11241: LD_VAR 0 5
11245: PUSH
11246: FOR_TO
11247: IFFALSE 11380
// begin m := false ;
11249: LD_ADDR_VAR 0 7
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// for j = 1 to r do
11257: LD_ADDR_VAR 0 4
11261: PUSH
11262: DOUBLE
11263: LD_INT 1
11265: DEC
11266: ST_TO_ADDR
11267: LD_VAR 0 6
11271: PUSH
11272: FOR_TO
11273: IFFALSE 11347
// if GetLives ( tmp [ i ] ) < r [ j ] then
11275: LD_VAR 0 5
11279: PUSH
11280: LD_VAR 0 3
11284: ARRAY
11285: PPUSH
11286: CALL_OW 256
11290: PUSH
11291: LD_VAR 0 6
11295: PUSH
11296: LD_VAR 0 4
11300: ARRAY
11301: LESS
11302: IFFALSE 11345
// begin r := Insert ( r , j , tmp [ i ] ) ;
11304: LD_ADDR_VAR 0 6
11308: PUSH
11309: LD_VAR 0 6
11313: PPUSH
11314: LD_VAR 0 4
11318: PPUSH
11319: LD_VAR 0 5
11323: PUSH
11324: LD_VAR 0 3
11328: ARRAY
11329: PPUSH
11330: CALL_OW 2
11334: ST_TO_ADDR
// m := true ;
11335: LD_ADDR_VAR 0 7
11339: PUSH
11340: LD_INT 1
11342: ST_TO_ADDR
// break ;
11343: GO 11347
// end ;
11345: GO 11272
11347: POP
11348: POP
// if not m then
11349: LD_VAR 0 7
11353: NOT
11354: IFFALSE 11378
// r := r ^ tmp [ i ] ;
11356: LD_ADDR_VAR 0 6
11360: PUSH
11361: LD_VAR 0 6
11365: PUSH
11366: LD_VAR 0 5
11370: PUSH
11371: LD_VAR 0 3
11375: ARRAY
11376: ADD
11377: ST_TO_ADDR
// end ;
11378: GO 11246
11380: POP
11381: POP
// end ; if r then
11382: LD_VAR 0 6
11386: IFFALSE 11400
// result := r else
11388: LD_ADDR_VAR 0 2
11392: PUSH
11393: LD_VAR 0 6
11397: ST_TO_ADDR
11398: GO 11402
// exit ;
11400: GO 11402
// end ;
11402: LD_VAR 0 2
11406: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
11412: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11413: LD_ADDR_VAR 0 5
11417: PUSH
11418: LD_INT 22
11420: PUSH
11421: LD_VAR 0 1
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 2
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 16
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 34
11455: PUSH
11456: LD_INT 13
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 34
11465: PUSH
11466: LD_INT 52
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 24
11482: PUSH
11483: LD_INT 650
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: PPUSH
11495: CALL_OW 69
11499: ST_TO_ADDR
// p := 1 ;
11500: LD_ADDR_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ST_TO_ADDR
// for i = 1 to repairs do
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: DOUBLE
11514: LD_INT 1
11516: DEC
11517: ST_TO_ADDR
11518: LD_VAR 0 5
11522: PUSH
11523: FOR_TO
11524: IFFALSE 11660
// begin if IsInUnit ( repairs [ i ] ) then
11526: LD_VAR 0 5
11530: PUSH
11531: LD_VAR 0 3
11535: ARRAY
11536: PPUSH
11537: CALL_OW 310
11541: IFFALSE 11560
// ComExitBuilding ( repairs [ i ] ) else
11543: LD_VAR 0 5
11547: PUSH
11548: LD_VAR 0 3
11552: ARRAY
11553: PPUSH
11554: CALL_OW 122
11558: GO 11658
// if not HasTask ( repairs [ i ] ) then
11560: LD_VAR 0 5
11564: PUSH
11565: LD_VAR 0 3
11569: ARRAY
11570: PPUSH
11571: CALL_OW 314
11575: NOT
11576: IFFALSE 11658
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11578: LD_VAR 0 5
11582: PUSH
11583: LD_VAR 0 3
11587: ARRAY
11588: PPUSH
11589: LD_EXP 47
11593: PUSH
11594: LD_VAR 0 1
11598: ARRAY
11599: PUSH
11600: LD_VAR 0 4
11604: ARRAY
11605: PPUSH
11606: CALL_OW 130
// if i mod 3 = 0 then
11610: LD_VAR 0 3
11614: PUSH
11615: LD_INT 3
11617: MOD
11618: PUSH
11619: LD_INT 0
11621: EQUAL
11622: IFFALSE 11638
// p := p + 1 ;
11624: LD_ADDR_VAR 0 4
11628: PUSH
11629: LD_VAR 0 4
11633: PUSH
11634: LD_INT 1
11636: PLUS
11637: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11638: LD_EXP 47
11642: PUSH
11643: LD_VAR 0 1
11647: ARRAY
11648: PUSH
11649: LD_VAR 0 4
11653: LESS
11654: IFFALSE 11658
// break ;
11656: GO 11660
// end ; end ;
11658: GO 11523
11660: POP
11661: POP
// end ; end_of_file
11662: LD_VAR 0 2
11666: RET
// export function MCF_Get ( side , filter ) ; begin
11667: LD_INT 0
11669: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11670: LD_ADDR_VAR 0 3
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_VAR 0 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: ST_TO_ADDR
// end ;
11701: LD_VAR 0 3
11705: RET
// export function MCF_Lab ( side ) ; begin
11706: LD_INT 0
11708: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_VAR 0 1
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: PUSH
11726: LD_INT 30
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PPUSH
11740: CALL_OW 69
11744: ST_TO_ADDR
// end ;
11745: LD_VAR 0 2
11749: RET
// export function MCF_Class ( side , class , filter ) ; begin
11750: LD_INT 0
11752: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11753: LD_ADDR_VAR 0 4
11757: PUSH
11758: LD_INT 22
11760: PUSH
11761: LD_VAR 0 1
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 25
11772: PUSH
11773: LD_VAR 0 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: LIST
11791: PPUSH
11792: CALL_OW 69
11796: ST_TO_ADDR
// end ;
11797: LD_VAR 0 4
11801: RET
// export function MCF_All ( side , filter ) ; begin
11802: LD_INT 0
11804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11805: LD_ADDR_VAR 0 3
11809: PUSH
11810: LD_INT 22
11812: PUSH
11813: LD_VAR 0 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 25
11827: PUSH
11828: LD_INT 1
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 25
11837: PUSH
11838: LD_INT 2
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: PUSH
11872: LD_VAR 0 2
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: LIST
11881: PPUSH
11882: CALL_OW 69
11886: ST_TO_ADDR
// end ;
11887: LD_VAR 0 3
11891: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11892: LD_INT 0
11894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11895: LD_ADDR_VAR 0 4
11899: PUSH
11900: LD_INT 22
11902: PUSH
11903: LD_VAR 0 1
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 92
11914: PUSH
11915: LD_VAR 0 2
11919: PUSH
11920: LD_INT 1
11922: ARRAY
11923: PUSH
11924: LD_VAR 0 2
11928: PUSH
11929: LD_INT 2
11931: ARRAY
11932: PUSH
11933: LD_VAR 0 2
11937: PUSH
11938: LD_INT 3
11940: ARRAY
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: PUSH
11948: LD_VAR 0 3
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: PPUSH
11958: CALL_OW 69
11962: ST_TO_ADDR
// end ;
11963: LD_VAR 0 4
11967: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11968: LD_INT 0
11970: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11971: LD_ADDR_VAR 0 3
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_VAR 0 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 21
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: LD_VAR 0 2
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PPUSH
12008: CALL_OW 69
12012: ST_TO_ADDR
// end ;
12013: LD_VAR 0 3
12017: RET
// export function MCF_Cargo ( side ) ; begin
12018: LD_INT 0
12020: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12021: LD_ADDR_VAR 0 2
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 34
12036: PUSH
12037: LD_INT 12
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 34
12046: PUSH
12047: LD_INT 32
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 34
12056: PUSH
12057: LD_INT 51
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL 11968 0 2
12074: ST_TO_ADDR
// end ;
12075: LD_VAR 0 2
12079: RET
// export function MCF_Ape ( side ) ; begin
12080: LD_INT 0
12082: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12083: LD_ADDR_VAR 0 2
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 2
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 15
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 25
12125: PUSH
12126: LD_INT 16
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 25
12135: PUSH
12136: LD_INT 17
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PPUSH
12154: CALL_OW 69
12158: ST_TO_ADDR
// end ;
12159: LD_VAR 0 2
12163: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12164: LD_INT 0
12166: PPUSH
12167: PPUSH
12168: PPUSH
12169: PPUSH
// result := [ ] ;
12170: LD_ADDR_VAR 0 3
12174: PUSH
12175: EMPTY
12176: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12177: LD_ADDR_VAR 0 4
12181: PUSH
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL 12080 0 1
12191: ST_TO_ADDR
// case type of 0 , normal :
12192: LD_VAR 0 2
12196: PUSH
12197: LD_INT 0
12199: DOUBLE
12200: EQUAL
12201: IFTRUE 12211
12203: LD_STRING normal
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12222
12211: POP
// cl := class_apeman ; 1 , soldier :
12212: LD_ADDR_VAR 0 5
12216: PUSH
12217: LD_INT 12
12219: ST_TO_ADDR
12220: GO 12298
12222: LD_INT 1
12224: DOUBLE
12225: EQUAL
12226: IFTRUE 12236
12228: LD_STRING soldier
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12247
12236: POP
// cl := class_apeman_soldier ; 2 , engineer :
12237: LD_ADDR_VAR 0 5
12241: PUSH
12242: LD_INT 15
12244: ST_TO_ADDR
12245: GO 12298
12247: LD_INT 2
12249: DOUBLE
12250: EQUAL
12251: IFTRUE 12261
12253: LD_STRING engineer
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12272
12261: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_INT 16
12269: ST_TO_ADDR
12270: GO 12298
12272: LD_INT 3
12274: DOUBLE
12275: EQUAL
12276: IFTRUE 12286
12278: LD_STRING kamikaze
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12297
12286: POP
// cl := class_apeman_kamikaze ; end ;
12287: LD_ADDR_VAR 0 5
12291: PUSH
12292: LD_INT 17
12294: ST_TO_ADDR
12295: GO 12298
12297: POP
// for i = 1 to tmp do
12298: LD_ADDR_VAR 0 6
12302: PUSH
12303: DOUBLE
12304: LD_INT 1
12306: DEC
12307: ST_TO_ADDR
12308: LD_VAR 0 4
12312: PUSH
12313: FOR_TO
12314: IFFALSE 12363
// if GetClass ( tmp [ i ] ) = cl then
12316: LD_VAR 0 4
12320: PUSH
12321: LD_VAR 0 6
12325: ARRAY
12326: PPUSH
12327: CALL_OW 257
12331: PUSH
12332: LD_VAR 0 5
12336: EQUAL
12337: IFFALSE 12361
// result := result ^ tmp [ i ] ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_VAR 0 3
12348: PUSH
12349: LD_VAR 0 4
12353: PUSH
12354: LD_VAR 0 6
12358: ARRAY
12359: ADD
12360: ST_TO_ADDR
12361: GO 12313
12363: POP
12364: POP
// end ;
12365: LD_VAR 0 3
12369: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12370: LD_INT 0
12372: PPUSH
12373: PPUSH
12374: PPUSH
12375: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_INT 22
12383: PUSH
12384: LD_VAR 0 1
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PPUSH
12402: CALL_OW 69
12406: ST_TO_ADDR
// r := [ ] ;
12407: LD_ADDR_VAR 0 6
12411: PUSH
12412: EMPTY
12413: ST_TO_ADDR
// if tmp then
12414: LD_VAR 0 5
12418: IFFALSE 12487
// for i = 1 to tmp do
12420: LD_ADDR_VAR 0 7
12424: PUSH
12425: DOUBLE
12426: LD_INT 1
12428: DEC
12429: ST_TO_ADDR
12430: LD_VAR 0 5
12434: PUSH
12435: FOR_TO
12436: IFFALSE 12485
// if GetTag ( tmp [ i ] ) = tag then
12438: LD_VAR 0 5
12442: PUSH
12443: LD_VAR 0 7
12447: ARRAY
12448: PPUSH
12449: CALL_OW 110
12453: PUSH
12454: LD_VAR 0 2
12458: EQUAL
12459: IFFALSE 12483
// r := r ^ tmp [ i ] ;
12461: LD_ADDR_VAR 0 6
12465: PUSH
12466: LD_VAR 0 6
12470: PUSH
12471: LD_VAR 0 5
12475: PUSH
12476: LD_VAR 0 7
12480: ARRAY
12481: ADD
12482: ST_TO_ADDR
12483: GO 12435
12485: POP
12486: POP
// result := r ;
12487: LD_ADDR_VAR 0 4
12491: PUSH
12492: LD_VAR 0 6
12496: ST_TO_ADDR
// end ;
12497: LD_VAR 0 4
12501: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12502: LD_INT 0
12504: PPUSH
12505: PPUSH
12506: PPUSH
// tmp := plist ;
12507: LD_ADDR_VAR 0 5
12511: PUSH
12512: LD_VAR 0 2
12516: ST_TO_ADDR
// if tmp then
12517: LD_VAR 0 5
12521: IFFALSE 12598
// begin for i = 1 to tmp do
12523: LD_ADDR_VAR 0 6
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_VAR 0 5
12537: PUSH
12538: FOR_TO
12539: IFFALSE 12586
// if GetTag ( tmp [ i ] ) <> tag then
12541: LD_VAR 0 5
12545: PUSH
12546: LD_VAR 0 6
12550: ARRAY
12551: PPUSH
12552: CALL_OW 110
12556: PUSH
12557: LD_VAR 0 3
12561: NONEQUAL
12562: IFFALSE 12584
// SetTag ( tmp [ i ] , tag ) ;
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 6
12573: ARRAY
12574: PPUSH
12575: LD_VAR 0 3
12579: PPUSH
12580: CALL_OW 109
12584: GO 12538
12586: POP
12587: POP
// result := true ;
12588: LD_ADDR_VAR 0 4
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// end else
12596: GO 12606
// result := false ;
12598: LD_ADDR_VAR 0 4
12602: PUSH
12603: LD_INT 0
12605: ST_TO_ADDR
// end ;
12606: LD_VAR 0 4
12610: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12611: LD_INT 0
12613: PPUSH
12614: PPUSH
12615: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12616: LD_ADDR_VAR 0 4
12620: PUSH
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: EMPTY
12632: PPUSH
12633: CALL 12370 0 3
12637: ST_TO_ADDR
// if tmp then
12638: LD_VAR 0 4
12642: IFFALSE 12694
// begin for i = 1 to tmp do
12644: LD_ADDR_VAR 0 5
12648: PUSH
12649: DOUBLE
12650: LD_INT 1
12652: DEC
12653: ST_TO_ADDR
12654: LD_VAR 0 4
12658: PUSH
12659: FOR_TO
12660: IFFALSE 12682
// SetTag ( tmp [ i ] , 0 ) ;
12662: LD_VAR 0 4
12666: PUSH
12667: LD_VAR 0 5
12671: ARRAY
12672: PPUSH
12673: LD_INT 0
12675: PPUSH
12676: CALL_OW 109
12680: GO 12659
12682: POP
12683: POP
// result := true ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// end else
12692: GO 12702
// result := false ;
12694: LD_ADDR_VAR 0 3
12698: PUSH
12699: LD_INT 0
12701: ST_TO_ADDR
// end ;
12702: LD_VAR 0 3
12706: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12707: LD_INT 0
12709: PPUSH
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// sort_list := [ ] ;
12714: LD_ADDR_VAR 0 5
12718: PUSH
12719: EMPTY
12720: ST_TO_ADDR
// for i = 1 to list do
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: DOUBLE
12727: LD_INT 1
12729: DEC
12730: ST_TO_ADDR
12731: LD_VAR 0 1
12735: PUSH
12736: FOR_TO
12737: IFFALSE 12899
// begin if i = 1 then
12739: LD_VAR 0 3
12743: PUSH
12744: LD_INT 1
12746: EQUAL
12747: IFFALSE 12773
// sort_list := sort_list ^ list [ i ] else
12749: LD_ADDR_VAR 0 5
12753: PUSH
12754: LD_VAR 0 5
12758: PUSH
12759: LD_VAR 0 1
12763: PUSH
12764: LD_VAR 0 3
12768: ARRAY
12769: ADD
12770: ST_TO_ADDR
12771: GO 12897
// begin for j = 1 to sort_list do
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: DOUBLE
12779: LD_INT 1
12781: DEC
12782: ST_TO_ADDR
12783: LD_VAR 0 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12866
// begin add := false ;
12791: LD_ADDR_VAR 0 6
12795: PUSH
12796: LD_INT 0
12798: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12799: LD_VAR 0 1
12803: PUSH
12804: LD_VAR 0 3
12808: ARRAY
12809: PUSH
12810: LD_VAR 0 5
12814: PUSH
12815: LD_VAR 0 4
12819: ARRAY
12820: LESS
12821: IFFALSE 12864
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12823: LD_ADDR_VAR 0 5
12827: PUSH
12828: LD_VAR 0 5
12832: PPUSH
12833: LD_VAR 0 4
12837: PPUSH
12838: LD_VAR 0 1
12842: PUSH
12843: LD_VAR 0 3
12847: ARRAY
12848: PPUSH
12849: CALL_OW 2
12853: ST_TO_ADDR
// add := true ;
12854: LD_ADDR_VAR 0 6
12858: PUSH
12859: LD_INT 1
12861: ST_TO_ADDR
// break ;
12862: GO 12866
// end ; end ;
12864: GO 12788
12866: POP
12867: POP
// if not add then
12868: LD_VAR 0 6
12872: NOT
12873: IFFALSE 12897
// sort_list := sort_list ^ list [ i ] ;
12875: LD_ADDR_VAR 0 5
12879: PUSH
12880: LD_VAR 0 5
12884: PUSH
12885: LD_VAR 0 1
12889: PUSH
12890: LD_VAR 0 3
12894: ARRAY
12895: ADD
12896: ST_TO_ADDR
// end ; end ;
12897: GO 12736
12899: POP
12900: POP
// result := sort_list ;
12901: LD_ADDR_VAR 0 2
12905: PUSH
12906: LD_VAR 0 5
12910: ST_TO_ADDR
// end ;
12911: LD_VAR 0 2
12915: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12916: LD_INT 0
12918: PPUSH
12919: PPUSH
12920: PPUSH
12921: PPUSH
12922: PPUSH
// sort_list := [ ] ;
12923: LD_ADDR_VAR 0 5
12927: PUSH
12928: EMPTY
12929: ST_TO_ADDR
// for i = 1 to list do
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: DOUBLE
12936: LD_INT 1
12938: DEC
12939: ST_TO_ADDR
12940: LD_VAR 0 1
12944: PUSH
12945: FOR_TO
12946: IFFALSE 13108
// begin if i = 1 then
12948: LD_VAR 0 3
12952: PUSH
12953: LD_INT 1
12955: EQUAL
12956: IFFALSE 12982
// sort_list := sort_list ^ list [ i ] else
12958: LD_ADDR_VAR 0 5
12962: PUSH
12963: LD_VAR 0 5
12967: PUSH
12968: LD_VAR 0 1
12972: PUSH
12973: LD_VAR 0 3
12977: ARRAY
12978: ADD
12979: ST_TO_ADDR
12980: GO 13106
// begin for j = 1 to sort_list do
12982: LD_ADDR_VAR 0 4
12986: PUSH
12987: DOUBLE
12988: LD_INT 1
12990: DEC
12991: ST_TO_ADDR
12992: LD_VAR 0 5
12996: PUSH
12997: FOR_TO
12998: IFFALSE 13075
// begin add := false ;
13000: LD_ADDR_VAR 0 6
13004: PUSH
13005: LD_INT 0
13007: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
13008: LD_VAR 0 1
13012: PUSH
13013: LD_VAR 0 3
13017: ARRAY
13018: PUSH
13019: LD_VAR 0 5
13023: PUSH
13024: LD_VAR 0 4
13028: ARRAY
13029: GREATER
13030: IFFALSE 13073
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13032: LD_ADDR_VAR 0 5
13036: PUSH
13037: LD_VAR 0 5
13041: PPUSH
13042: LD_VAR 0 4
13046: PPUSH
13047: LD_VAR 0 1
13051: PUSH
13052: LD_VAR 0 3
13056: ARRAY
13057: PPUSH
13058: CALL_OW 2
13062: ST_TO_ADDR
// add := true ;
13063: LD_ADDR_VAR 0 6
13067: PUSH
13068: LD_INT 1
13070: ST_TO_ADDR
// break ;
13071: GO 13075
// end ; end ;
13073: GO 12997
13075: POP
13076: POP
// if not add then
13077: LD_VAR 0 6
13081: NOT
13082: IFFALSE 13106
// sort_list := sort_list ^ list [ i ] ;
13084: LD_ADDR_VAR 0 5
13088: PUSH
13089: LD_VAR 0 5
13093: PUSH
13094: LD_VAR 0 1
13098: PUSH
13099: LD_VAR 0 3
13103: ARRAY
13104: ADD
13105: ST_TO_ADDR
// end ; end ;
13106: GO 12945
13108: POP
13109: POP
// result := sort_list ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_VAR 0 5
13119: ST_TO_ADDR
// end ;
13120: LD_VAR 0 2
13124: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
13130: PPUSH
13131: PPUSH
13132: PPUSH
// tmp := [ ] ;
13133: LD_ADDR_VAR 0 8
13137: PUSH
13138: EMPTY
13139: ST_TO_ADDR
// r := [ ] ;
13140: LD_ADDR_VAR 0 7
13144: PUSH
13145: EMPTY
13146: ST_TO_ADDR
// add := false ;
13147: LD_ADDR_VAR 0 9
13151: PUSH
13152: LD_INT 0
13154: ST_TO_ADDR
// if plist then
13155: LD_VAR 0 2
13159: IFFALSE 13235
// begin for i = 1 to plist do
13161: LD_ADDR_VAR 0 5
13165: PUSH
13166: DOUBLE
13167: LD_INT 1
13169: DEC
13170: ST_TO_ADDR
13171: LD_VAR 0 2
13175: PUSH
13176: FOR_TO
13177: IFFALSE 13231
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13179: LD_ADDR_VAR 0 8
13183: PUSH
13184: LD_VAR 0 8
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: LD_VAR 0 5
13198: ARRAY
13199: PUSH
13200: LD_VAR 0 2
13204: PUSH
13205: LD_VAR 0 5
13209: ARRAY
13210: PPUSH
13211: LD_VAR 0 3
13215: PPUSH
13216: CALL_OW 259
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: EMPTY
13226: LIST
13227: ADD
13228: ST_TO_ADDR
// end ;
13229: GO 13176
13231: POP
13232: POP
// end else
13233: GO 13243
// result := false ;
13235: LD_ADDR_VAR 0 4
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// if tmp then
13243: LD_VAR 0 8
13247: IFFALSE 13421
// begin r := r ^ [ tmp [ 1 ] ] ;
13249: LD_ADDR_VAR 0 7
13253: PUSH
13254: LD_VAR 0 7
13258: PUSH
13259: LD_VAR 0 8
13263: PUSH
13264: LD_INT 1
13266: ARRAY
13267: PUSH
13268: EMPTY
13269: LIST
13270: ADD
13271: ST_TO_ADDR
// for i = 2 to tmp do
13272: LD_ADDR_VAR 0 5
13276: PUSH
13277: DOUBLE
13278: LD_INT 2
13280: DEC
13281: ST_TO_ADDR
13282: LD_VAR 0 8
13286: PUSH
13287: FOR_TO
13288: IFFALSE 13419
// begin for j = 1 to r do
13290: LD_ADDR_VAR 0 6
13294: PUSH
13295: DOUBLE
13296: LD_INT 1
13298: DEC
13299: ST_TO_ADDR
13300: LD_VAR 0 7
13304: PUSH
13305: FOR_TO
13306: IFFALSE 13383
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13308: LD_VAR 0 8
13312: PUSH
13313: LD_VAR 0 5
13317: ARRAY
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PUSH
13323: LD_VAR 0 7
13327: PUSH
13328: LD_VAR 0 6
13332: ARRAY
13333: PUSH
13334: LD_INT 2
13336: ARRAY
13337: LESS
13338: IFFALSE 13381
// begin r := Insert ( r , j , tmp [ i ] ) ;
13340: LD_ADDR_VAR 0 7
13344: PUSH
13345: LD_VAR 0 7
13349: PPUSH
13350: LD_VAR 0 6
13354: PPUSH
13355: LD_VAR 0 8
13359: PUSH
13360: LD_VAR 0 5
13364: ARRAY
13365: PPUSH
13366: CALL_OW 2
13370: ST_TO_ADDR
// add := true ;
13371: LD_ADDR_VAR 0 9
13375: PUSH
13376: LD_INT 1
13378: ST_TO_ADDR
// break ;
13379: GO 13383
// end ; end ;
13381: GO 13305
13383: POP
13384: POP
// if not add then
13385: LD_VAR 0 9
13389: NOT
13390: IFFALSE 13417
// r := r ^ [ tmp [ i ] ] ;
13392: LD_ADDR_VAR 0 7
13396: PUSH
13397: LD_VAR 0 7
13401: PUSH
13402: LD_VAR 0 8
13406: PUSH
13407: LD_VAR 0 5
13411: ARRAY
13412: PUSH
13413: EMPTY
13414: LIST
13415: ADD
13416: ST_TO_ADDR
// end ;
13417: GO 13287
13419: POP
13420: POP
// end ; result := r ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_VAR 0 7
13430: ST_TO_ADDR
// end ;
13431: LD_VAR 0 4
13435: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
// tmp := [ ] ;
13444: LD_ADDR_VAR 0 8
13448: PUSH
13449: EMPTY
13450: ST_TO_ADDR
// r := [ ] ;
13451: LD_ADDR_VAR 0 7
13455: PUSH
13456: EMPTY
13457: ST_TO_ADDR
// add := false ;
13458: LD_ADDR_VAR 0 9
13462: PUSH
13463: LD_INT 0
13465: ST_TO_ADDR
// if plist then
13466: LD_VAR 0 2
13470: IFFALSE 13546
// begin for i = 1 to plist do
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: DOUBLE
13478: LD_INT 1
13480: DEC
13481: ST_TO_ADDR
13482: LD_VAR 0 2
13486: PUSH
13487: FOR_TO
13488: IFFALSE 13542
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13490: LD_ADDR_VAR 0 8
13494: PUSH
13495: LD_VAR 0 8
13499: PUSH
13500: LD_VAR 0 2
13504: PUSH
13505: LD_VAR 0 5
13509: ARRAY
13510: PUSH
13511: LD_VAR 0 2
13515: PUSH
13516: LD_VAR 0 5
13520: ARRAY
13521: PPUSH
13522: LD_VAR 0 3
13526: PPUSH
13527: CALL_OW 259
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: ADD
13539: ST_TO_ADDR
// end ;
13540: GO 13487
13542: POP
13543: POP
// end else
13544: GO 13554
// result := false ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 0
13553: ST_TO_ADDR
// if tmp then
13554: LD_VAR 0 8
13558: IFFALSE 13732
// begin r := r ^ [ tmp [ 1 ] ] ;
13560: LD_ADDR_VAR 0 7
13564: PUSH
13565: LD_VAR 0 7
13569: PUSH
13570: LD_VAR 0 8
13574: PUSH
13575: LD_INT 1
13577: ARRAY
13578: PUSH
13579: EMPTY
13580: LIST
13581: ADD
13582: ST_TO_ADDR
// for i = 2 to tmp do
13583: LD_ADDR_VAR 0 5
13587: PUSH
13588: DOUBLE
13589: LD_INT 2
13591: DEC
13592: ST_TO_ADDR
13593: LD_VAR 0 8
13597: PUSH
13598: FOR_TO
13599: IFFALSE 13730
// begin for j = 1 to r do
13601: LD_ADDR_VAR 0 6
13605: PUSH
13606: DOUBLE
13607: LD_INT 1
13609: DEC
13610: ST_TO_ADDR
13611: LD_VAR 0 7
13615: PUSH
13616: FOR_TO
13617: IFFALSE 13694
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13619: LD_VAR 0 8
13623: PUSH
13624: LD_VAR 0 5
13628: ARRAY
13629: PUSH
13630: LD_INT 2
13632: ARRAY
13633: PUSH
13634: LD_VAR 0 7
13638: PUSH
13639: LD_VAR 0 6
13643: ARRAY
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: GREATER
13649: IFFALSE 13692
// begin r := Insert ( r , j , tmp [ i ] ) ;
13651: LD_ADDR_VAR 0 7
13655: PUSH
13656: LD_VAR 0 7
13660: PPUSH
13661: LD_VAR 0 6
13665: PPUSH
13666: LD_VAR 0 8
13670: PUSH
13671: LD_VAR 0 5
13675: ARRAY
13676: PPUSH
13677: CALL_OW 2
13681: ST_TO_ADDR
// add := true ;
13682: LD_ADDR_VAR 0 9
13686: PUSH
13687: LD_INT 1
13689: ST_TO_ADDR
// break ;
13690: GO 13694
// end ; end ;
13692: GO 13616
13694: POP
13695: POP
// if not add then
13696: LD_VAR 0 9
13700: NOT
13701: IFFALSE 13728
// r := r ^ [ tmp [ i ] ] ;
13703: LD_ADDR_VAR 0 7
13707: PUSH
13708: LD_VAR 0 7
13712: PUSH
13713: LD_VAR 0 8
13717: PUSH
13718: LD_VAR 0 5
13722: ARRAY
13723: PUSH
13724: EMPTY
13725: LIST
13726: ADD
13727: ST_TO_ADDR
// end ;
13728: GO 13598
13730: POP
13731: POP
// end ; result := r ;
13732: LD_ADDR_VAR 0 4
13736: PUSH
13737: LD_VAR 0 7
13741: ST_TO_ADDR
// end ;
13742: LD_VAR 0 4
13746: RET
// export function MCF_Clear ( side ) ; var i ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
// for i = 1 to 100 do
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: DOUBLE
13757: LD_INT 1
13759: DEC
13760: ST_TO_ADDR
13761: LD_INT 100
13763: PUSH
13764: FOR_TO
13765: IFFALSE 13801
// if MCF_Tag ( side , i , [ ] ) then
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 3
13776: PPUSH
13777: EMPTY
13778: PPUSH
13779: CALL 12370 0 3
13783: IFFALSE 13799
// MCF_ClearTag ( side , i ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 3
13794: PPUSH
13795: CALL 12611 0 2
13799: GO 13764
13801: POP
13802: POP
// result := true ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_INT 1
13810: ST_TO_ADDR
// end ;
13811: LD_VAR 0 2
13815: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13816: LD_INT 0
13818: PPUSH
13819: PPUSH
13820: PPUSH
// for i = 1 to plist do
13821: LD_ADDR_VAR 0 4
13825: PUSH
13826: DOUBLE
13827: LD_INT 1
13829: DEC
13830: ST_TO_ADDR
13831: LD_VAR 0 1
13835: PUSH
13836: FOR_TO
13837: IFFALSE 13886
// if MCF_HasClass ( plist [ i ] ) = n then
13839: LD_VAR 0 1
13843: PUSH
13844: LD_VAR 0 4
13848: ARRAY
13849: PPUSH
13850: CALL 14373 0 1
13854: PUSH
13855: LD_VAR 0 2
13859: EQUAL
13860: IFFALSE 13884
// tmp := tmp ^ plist [ i ] ;
13862: LD_ADDR_VAR 0 5
13866: PUSH
13867: LD_VAR 0 5
13871: PUSH
13872: LD_VAR 0 1
13876: PUSH
13877: LD_VAR 0 4
13881: ARRAY
13882: ADD
13883: ST_TO_ADDR
13884: GO 13836
13886: POP
13887: POP
// result := tmp ;
13888: LD_ADDR_VAR 0 3
13892: PUSH
13893: LD_VAR 0 5
13897: ST_TO_ADDR
// end ;
13898: LD_VAR 0 3
13902: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// if mreg = ToArm then
13908: LD_VAR 0 2
13912: PUSH
13913: LD_STRING ToArm
13915: EQUAL
13916: IFFALSE 14021
// begin tmp := MREG_ToArm [ side ] ;
13918: LD_ADDR_VAR 0 6
13922: PUSH
13923: LD_EXP 56
13927: PUSH
13928: LD_VAR 0 1
13932: ARRAY
13933: ST_TO_ADDR
// if tmp = 0 then
13934: LD_VAR 0 6
13938: PUSH
13939: LD_INT 0
13941: EQUAL
13942: IFFALSE 13948
// exit else
13944: GO 14368
13946: GO 14021
// begin for i = MREG_ToArm [ side ] downto n do
13948: LD_ADDR_VAR 0 5
13952: PUSH
13953: DOUBLE
13954: LD_EXP 56
13958: PUSH
13959: LD_VAR 0 1
13963: ARRAY
13964: INC
13965: ST_TO_ADDR
13966: LD_VAR 0 3
13970: PUSH
13971: FOR_DOWNTO
13972: IFFALSE 13994
// tmp := Delete ( tmp , 1 ) ;
13974: LD_ADDR_VAR 0 6
13978: PUSH
13979: LD_VAR 0 6
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 3
13991: ST_TO_ADDR
13992: GO 13971
13994: POP
13995: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13996: LD_ADDR_EXP 56
14000: PUSH
14001: LD_EXP 56
14005: PPUSH
14006: LD_VAR 0 1
14010: PPUSH
14011: LD_VAR 0 6
14015: PPUSH
14016: CALL_OW 1
14020: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14021: LD_VAR 0 2
14025: PUSH
14026: LD_STRING ToDep
14028: EQUAL
14029: IFFALSE 14134
// begin tmp := MREG_ToDep [ side ] ;
14031: LD_ADDR_VAR 0 6
14035: PUSH
14036: LD_EXP 57
14040: PUSH
14041: LD_VAR 0 1
14045: ARRAY
14046: ST_TO_ADDR
// if tmp = 0 then
14047: LD_VAR 0 6
14051: PUSH
14052: LD_INT 0
14054: EQUAL
14055: IFFALSE 14061
// exit else
14057: GO 14368
14059: GO 14134
// begin for i = MREG_ToDep [ side ] downto n do
14061: LD_ADDR_VAR 0 5
14065: PUSH
14066: DOUBLE
14067: LD_EXP 57
14071: PUSH
14072: LD_VAR 0 1
14076: ARRAY
14077: INC
14078: ST_TO_ADDR
14079: LD_VAR 0 3
14083: PUSH
14084: FOR_DOWNTO
14085: IFFALSE 14107
// tmp := Delete ( tmp , 1 ) ;
14087: LD_ADDR_VAR 0 6
14091: PUSH
14092: LD_VAR 0 6
14096: PPUSH
14097: LD_INT 1
14099: PPUSH
14100: CALL_OW 3
14104: ST_TO_ADDR
14105: GO 14084
14107: POP
14108: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14109: LD_ADDR_EXP 57
14113: PUSH
14114: LD_EXP 57
14118: PPUSH
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_VAR 0 6
14128: PPUSH
14129: CALL_OW 1
14133: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14134: LD_VAR 0 2
14138: PUSH
14139: LD_STRING ToFac
14141: EQUAL
14142: IFFALSE 14247
// begin tmp := MREG_ToFac [ side ] ;
14144: LD_ADDR_VAR 0 6
14148: PUSH
14149: LD_EXP 55
14153: PUSH
14154: LD_VAR 0 1
14158: ARRAY
14159: ST_TO_ADDR
// if tmp = 0 then
14160: LD_VAR 0 6
14164: PUSH
14165: LD_INT 0
14167: EQUAL
14168: IFFALSE 14174
// exit else
14170: GO 14368
14172: GO 14247
// begin for i = MREG_ToFac [ side ] downto n do
14174: LD_ADDR_VAR 0 5
14178: PUSH
14179: DOUBLE
14180: LD_EXP 55
14184: PUSH
14185: LD_VAR 0 1
14189: ARRAY
14190: INC
14191: ST_TO_ADDR
14192: LD_VAR 0 3
14196: PUSH
14197: FOR_DOWNTO
14198: IFFALSE 14220
// tmp := Delete ( tmp , 1 ) ;
14200: LD_ADDR_VAR 0 6
14204: PUSH
14205: LD_VAR 0 6
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: CALL_OW 3
14217: ST_TO_ADDR
14218: GO 14197
14220: POP
14221: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14222: LD_ADDR_EXP 55
14226: PUSH
14227: LD_EXP 55
14231: PPUSH
14232: LD_VAR 0 1
14236: PPUSH
14237: LD_VAR 0 6
14241: PPUSH
14242: CALL_OW 1
14246: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14247: LD_VAR 0 2
14251: PUSH
14252: LD_STRING ToLab
14254: EQUAL
14255: IFFALSE 14360
// begin tmp := MREG_ToLab [ side ] ;
14257: LD_ADDR_VAR 0 6
14261: PUSH
14262: LD_EXP 54
14266: PUSH
14267: LD_VAR 0 1
14271: ARRAY
14272: ST_TO_ADDR
// if tmp = 0 then
14273: LD_VAR 0 6
14277: PUSH
14278: LD_INT 0
14280: EQUAL
14281: IFFALSE 14287
// exit else
14283: GO 14368
14285: GO 14360
// begin for i = MREG_ToLab [ side ] downto n do
14287: LD_ADDR_VAR 0 5
14291: PUSH
14292: DOUBLE
14293: LD_EXP 54
14297: PUSH
14298: LD_VAR 0 1
14302: ARRAY
14303: INC
14304: ST_TO_ADDR
14305: LD_VAR 0 3
14309: PUSH
14310: FOR_DOWNTO
14311: IFFALSE 14333
// tmp := Delete ( tmp , 1 ) ;
14313: LD_ADDR_VAR 0 6
14317: PUSH
14318: LD_VAR 0 6
14322: PPUSH
14323: LD_INT 1
14325: PPUSH
14326: CALL_OW 3
14330: ST_TO_ADDR
14331: GO 14310
14333: POP
14334: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14335: LD_ADDR_EXP 54
14339: PUSH
14340: LD_EXP 54
14344: PPUSH
14345: LD_VAR 0 1
14349: PPUSH
14350: LD_VAR 0 6
14354: PPUSH
14355: CALL_OW 1
14359: ST_TO_ADDR
// end ; end ; result := true ;
14360: LD_ADDR_VAR 0 4
14364: PUSH
14365: LD_INT 1
14367: ST_TO_ADDR
// end ;
14368: LD_VAR 0 4
14372: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14373: LD_INT 0
14375: PPUSH
14376: PPUSH
14377: PPUSH
// side := GetSide ( unit ) ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_VAR 0 1
14387: PPUSH
14388: CALL_OW 255
14392: ST_TO_ADDR
// tmp := 0 ;
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 0
14400: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14401: LD_VAR 0 1
14405: PUSH
14406: LD_EXP 56
14410: PUSH
14411: LD_VAR 0 4
14415: ARRAY
14416: IN
14417: IFFALSE 14427
// tmp := 1 ;
14419: LD_ADDR_VAR 0 3
14423: PUSH
14424: LD_INT 1
14426: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14427: LD_VAR 0 1
14431: PUSH
14432: LD_EXP 57
14436: PUSH
14437: LD_VAR 0 4
14441: ARRAY
14442: IN
14443: IFFALSE 14453
// tmp := 2 ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: LD_INT 2
14452: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14453: LD_VAR 0 1
14457: PUSH
14458: LD_EXP 55
14462: PUSH
14463: LD_VAR 0 4
14467: ARRAY
14468: IN
14469: IFFALSE 14479
// tmp := 3 ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_INT 3
14478: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14479: LD_VAR 0 1
14483: PUSH
14484: LD_EXP 54
14488: PUSH
14489: LD_VAR 0 4
14493: ARRAY
14494: IN
14495: IFFALSE 14505
// tmp := 4 ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: LD_INT 4
14504: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14505: LD_VAR 0 1
14509: PUSH
14510: LD_EXP 68
14514: PUSH
14515: LD_VAR 0 4
14519: ARRAY
14520: IN
14521: IFFALSE 14531
// tmp := 5 ;
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 5
14530: ST_TO_ADDR
// result := tmp ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: LD_VAR 0 3
14540: ST_TO_ADDR
// end ;
14541: LD_VAR 0 2
14545: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14546: LD_INT 0
14548: PPUSH
14549: PPUSH
// if mreg = ToArm then
14550: LD_VAR 0 2
14554: PUSH
14555: LD_STRING ToArm
14557: EQUAL
14558: IFFALSE 14647
// for i = MREG_ToArm [ side ] downto 1 do
14560: LD_ADDR_VAR 0 5
14564: PUSH
14565: DOUBLE
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: INC
14577: ST_TO_ADDR
14578: LD_INT 1
14580: PUSH
14581: FOR_DOWNTO
14582: IFFALSE 14645
// if MREG_ToArm [ side ] [ i ] = unit then
14584: LD_EXP 56
14588: PUSH
14589: LD_VAR 0 1
14593: ARRAY
14594: PUSH
14595: LD_VAR 0 5
14599: ARRAY
14600: PUSH
14601: LD_VAR 0 3
14605: EQUAL
14606: IFFALSE 14643
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14608: LD_ADDR_EXP 56
14612: PUSH
14613: LD_EXP 56
14617: PPUSH
14618: LD_EXP 56
14622: PUSH
14623: LD_VAR 0 1
14627: ARRAY
14628: PUSH
14629: LD_VAR 0 5
14633: ARRAY
14634: PPUSH
14635: LD_INT 1
14637: PPUSH
14638: CALL 31291 0 3
14642: ST_TO_ADDR
// end ;
14643: GO 14581
14645: POP
14646: POP
// if mreg = ToDep then
14647: LD_VAR 0 2
14651: PUSH
14652: LD_STRING ToDep
14654: EQUAL
14655: IFFALSE 14744
// for i = MREG_ToDep [ side ] downto 1 do
14657: LD_ADDR_VAR 0 5
14661: PUSH
14662: DOUBLE
14663: LD_EXP 57
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: INC
14674: ST_TO_ADDR
14675: LD_INT 1
14677: PUSH
14678: FOR_DOWNTO
14679: IFFALSE 14742
// if MREG_ToDep [ side ] [ i ] = unit then
14681: LD_EXP 57
14685: PUSH
14686: LD_VAR 0 1
14690: ARRAY
14691: PUSH
14692: LD_VAR 0 5
14696: ARRAY
14697: PUSH
14698: LD_VAR 0 3
14702: EQUAL
14703: IFFALSE 14740
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14705: LD_ADDR_EXP 57
14709: PUSH
14710: LD_EXP 57
14714: PPUSH
14715: LD_EXP 57
14719: PUSH
14720: LD_VAR 0 1
14724: ARRAY
14725: PUSH
14726: LD_VAR 0 5
14730: ARRAY
14731: PPUSH
14732: LD_INT 1
14734: PPUSH
14735: CALL 31291 0 3
14739: ST_TO_ADDR
// end ;
14740: GO 14678
14742: POP
14743: POP
// if mreg = ToFac then
14744: LD_VAR 0 2
14748: PUSH
14749: LD_STRING ToFac
14751: EQUAL
14752: IFFALSE 14841
// for i = MREG_ToFac [ side ] downto 1 do
14754: LD_ADDR_VAR 0 5
14758: PUSH
14759: DOUBLE
14760: LD_EXP 55
14764: PUSH
14765: LD_VAR 0 1
14769: ARRAY
14770: INC
14771: ST_TO_ADDR
14772: LD_INT 1
14774: PUSH
14775: FOR_DOWNTO
14776: IFFALSE 14839
// if MREG_ToFac [ side ] [ i ] = unit then
14778: LD_EXP 55
14782: PUSH
14783: LD_VAR 0 1
14787: ARRAY
14788: PUSH
14789: LD_VAR 0 5
14793: ARRAY
14794: PUSH
14795: LD_VAR 0 3
14799: EQUAL
14800: IFFALSE 14837
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14802: LD_ADDR_EXP 55
14806: PUSH
14807: LD_EXP 55
14811: PPUSH
14812: LD_EXP 55
14816: PUSH
14817: LD_VAR 0 1
14821: ARRAY
14822: PUSH
14823: LD_VAR 0 5
14827: ARRAY
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: CALL 31291 0 3
14836: ST_TO_ADDR
// end ;
14837: GO 14775
14839: POP
14840: POP
// if mreg = ToLab then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_STRING ToLab
14848: EQUAL
14849: IFFALSE 14938
// for i = MREG_ToLab [ side ] downto 1 do
14851: LD_ADDR_VAR 0 5
14855: PUSH
14856: DOUBLE
14857: LD_EXP 54
14861: PUSH
14862: LD_VAR 0 1
14866: ARRAY
14867: INC
14868: ST_TO_ADDR
14869: LD_INT 1
14871: PUSH
14872: FOR_DOWNTO
14873: IFFALSE 14936
// if MREG_ToLab [ side ] [ i ] = unit then
14875: LD_EXP 54
14879: PUSH
14880: LD_VAR 0 1
14884: ARRAY
14885: PUSH
14886: LD_VAR 0 5
14890: ARRAY
14891: PUSH
14892: LD_VAR 0 3
14896: EQUAL
14897: IFFALSE 14934
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14899: LD_ADDR_EXP 54
14903: PUSH
14904: LD_EXP 54
14908: PPUSH
14909: LD_EXP 54
14913: PUSH
14914: LD_VAR 0 1
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 5
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: CALL 31291 0 3
14933: ST_TO_ADDR
// end ;
14934: GO 14872
14936: POP
14937: POP
// end ;
14938: LD_VAR 0 4
14942: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14943: LD_INT 0
14945: PPUSH
14946: PPUSH
// result := false ;
14947: LD_ADDR_VAR 0 2
14951: PUSH
14952: LD_INT 0
14954: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14955: LD_ADDR_VAR 0 3
14959: PUSH
14960: DOUBLE
14961: LD_INT 1
14963: DEC
14964: ST_TO_ADDR
14965: LD_EXP 46
14969: PUSH
14970: FOR_TO
14971: IFFALSE 15035
// if MREG_ToBuild [ i ] [ 1 ] = side then
14973: LD_EXP 46
14977: PUSH
14978: LD_VAR 0 3
14982: ARRAY
14983: PUSH
14984: LD_INT 1
14986: ARRAY
14987: PUSH
14988: LD_VAR 0 1
14992: EQUAL
14993: IFFALSE 15033
// begin if MREG_ToBuild [ i ] [ 1 ] then
14995: LD_EXP 46
14999: PUSH
15000: LD_VAR 0 3
15004: ARRAY
15005: PUSH
15006: LD_INT 1
15008: ARRAY
15009: IFFALSE 15033
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: LD_EXP 46
15020: PUSH
15021: LD_VAR 0 3
15025: ARRAY
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: ST_TO_ADDR
// break ;
15031: GO 15035
// end ; end ;
15033: GO 14970
15035: POP
15036: POP
// for i = 1 to MREG_ToRepair do
15037: LD_ADDR_VAR 0 3
15041: PUSH
15042: DOUBLE
15043: LD_INT 1
15045: DEC
15046: ST_TO_ADDR
15047: LD_EXP 47
15051: PUSH
15052: FOR_TO
15053: IFFALSE 15117
// if MREG_ToRepair [ i ] [ 1 ] = side then
15055: LD_EXP 47
15059: PUSH
15060: LD_VAR 0 3
15064: ARRAY
15065: PUSH
15066: LD_INT 1
15068: ARRAY
15069: PUSH
15070: LD_VAR 0 1
15074: EQUAL
15075: IFFALSE 15115
// begin if MREG_ToRepair [ i ] [ 1 ] then
15077: LD_EXP 47
15081: PUSH
15082: LD_VAR 0 3
15086: ARRAY
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: IFFALSE 15115
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15093: LD_ADDR_VAR 0 2
15097: PUSH
15098: LD_EXP 47
15102: PUSH
15103: LD_VAR 0 3
15107: ARRAY
15108: PUSH
15109: LD_INT 1
15111: ARRAY
15112: ST_TO_ADDR
// break ;
15113: GO 15117
// end ; end ;
15115: GO 15052
15117: POP
15118: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_INT 57
15126: PUSH
15127: EMPTY
15128: LIST
15129: PPUSH
15130: CALL 11667 0 2
15134: IFFALSE 15161
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 57
15148: PUSH
15149: EMPTY
15150: LIST
15151: PPUSH
15152: CALL 11667 0 2
15156: PUSH
15157: LD_INT 1
15159: ARRAY
15160: ST_TO_ADDR
// end ;
15161: LD_VAR 0 2
15165: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15173: LD_ADDR_VAR 0 6
15177: PUSH
15178: LD_VAR 0 1
15182: PPUSH
15183: LD_INT 21
15185: PUSH
15186: LD_INT 3
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PPUSH
15193: CALL 11667 0 2
15197: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15198: LD_ADDR_VAR 0 7
15202: PUSH
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_INT 81
15210: PUSH
15211: LD_VAR 0 1
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL 11667 0 2
15224: ST_TO_ADDR
// if not enemy then
15225: LD_VAR 0 7
15229: NOT
15230: IFFALSE 15242
// result := false else
15232: LD_ADDR_VAR 0 3
15236: PUSH
15237: LD_INT 0
15239: ST_TO_ADDR
15240: GO 15296
// begin scan := NearestUnit ( b , enemy ) ;
15242: LD_ADDR_VAR 0 5
15246: PUSH
15247: LD_VAR 0 6
15251: PPUSH
15252: LD_VAR 0 7
15256: PPUSH
15257: CALL 32284 0 2
15261: ST_TO_ADDR
// if scan [ 2 ] < dist then
15262: LD_VAR 0 5
15266: PUSH
15267: LD_INT 2
15269: ARRAY
15270: PUSH
15271: LD_VAR 0 2
15275: LESS
15276: IFFALSE 15288
// result := true else
15278: LD_ADDR_VAR 0 3
15282: PUSH
15283: LD_INT 1
15285: ST_TO_ADDR
15286: GO 15296
// result := false ;
15288: LD_ADDR_VAR 0 3
15292: PUSH
15293: LD_INT 0
15295: ST_TO_ADDR
// end ; end ;
15296: LD_VAR 0 3
15300: RET
// export function MCF_Info ( ) ; begin
15301: LD_INT 0
15303: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15304: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15306: PUSH
15307: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15325: ADD
15326: PUSH
15327: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15329: ADD
15330: PUSH
15331: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15333: ADD
15334: PUSH
15335: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15337: ADD
15338: PUSH
15339: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15341: ADD
15342: PPUSH
15343: CALL 8585 0 1
// end ; end_of_file
15347: LD_VAR 0 1
15351: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15358: LD_ADDR_VAR 0 5
15362: PUSH
15363: LD_VAR 0 1
15367: PPUSH
15368: LD_INT 2
15370: PUSH
15371: LD_INT 25
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 25
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: LD_INT 25
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PPUSH
15407: CALL 11667 0 2
15411: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_INT 0
15424: PPUSH
15425: CALL 13816 0 2
15429: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15430: LD_ADDR_VAR 0 6
15434: PUSH
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_VAR 0 5
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL 13436 0 3
15452: ST_TO_ADDR
// if n > sk then
15453: LD_VAR 0 2
15457: PUSH
15458: LD_VAR 0 6
15462: GREATER
15463: IFFALSE 15475
// n := sk ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: ST_TO_ADDR
// for i = 1 to n do
15475: LD_ADDR_VAR 0 4
15479: PUSH
15480: DOUBLE
15481: LD_INT 1
15483: DEC
15484: ST_TO_ADDR
15485: LD_VAR 0 2
15489: PUSH
15490: FOR_TO
15491: IFFALSE 15603
// if ( sk [ i ] [ 1 ] ) <> 0 then
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 4
15502: ARRAY
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PUSH
15508: LD_INT 0
15510: NONEQUAL
15511: IFFALSE 15601
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15513: LD_ADDR_EXP 53
15517: PUSH
15518: LD_EXP 53
15522: PPUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 4
15537: ARRAY
15538: PUSH
15539: LD_INT 1
15541: ARRAY
15542: PPUSH
15543: LD_INT 1
15545: PPUSH
15546: CALL 41962 0 4
15550: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15551: LD_ADDR_EXP 56
15555: PUSH
15556: LD_EXP 56
15560: PPUSH
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_EXP 56
15570: PUSH
15571: LD_VAR 0 1
15575: ARRAY
15576: PUSH
15577: LD_INT 1
15579: PLUS
15580: PPUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 4
15590: ARRAY
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: CALL 31132 0 4
15600: ST_TO_ADDR
// end ;
15601: GO 15490
15603: POP
15604: POP
// end ;
15605: LD_VAR 0 3
15609: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15616: LD_ADDR_VAR 0 5
15620: PUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 2
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 1
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 25
15641: PUSH
15642: LD_INT 3
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: LD_INT 25
15651: PUSH
15652: LD_INT 4
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL 11667 0 2
15669: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15670: LD_ADDR_VAR 0 5
15674: PUSH
15675: LD_VAR 0 5
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL 13816 0 2
15687: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15688: LD_ADDR_VAR 0 6
15692: PUSH
15693: LD_VAR 0 1
15697: PPUSH
15698: LD_VAR 0 5
15702: PPUSH
15703: LD_INT 2
15705: PPUSH
15706: CALL 13436 0 3
15710: ST_TO_ADDR
// if n > sk then
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 6
15720: GREATER
15721: IFFALSE 15733
// n := sk ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: ST_TO_ADDR
// for i = 1 to n do
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: DOUBLE
15739: LD_INT 1
15741: DEC
15742: ST_TO_ADDR
15743: LD_VAR 0 2
15747: PUSH
15748: FOR_TO
15749: IFFALSE 15861
// if ( sk [ i ] [ 1 ] ) <> 0 then
15751: LD_VAR 0 6
15755: PUSH
15756: LD_VAR 0 4
15760: ARRAY
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PUSH
15766: LD_INT 0
15768: NONEQUAL
15769: IFFALSE 15859
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15771: LD_ADDR_EXP 53
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_VAR 0 6
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: LD_INT 2
15803: PPUSH
15804: CALL 41962 0 4
15808: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15809: LD_ADDR_EXP 57
15813: PUSH
15814: LD_EXP 57
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_EXP 57
15828: PUSH
15829: LD_VAR 0 1
15833: ARRAY
15834: PUSH
15835: LD_INT 1
15837: PLUS
15838: PPUSH
15839: LD_VAR 0 6
15843: PUSH
15844: LD_VAR 0 4
15848: ARRAY
15849: PUSH
15850: LD_INT 1
15852: ARRAY
15853: PPUSH
15854: CALL 31132 0 4
15858: ST_TO_ADDR
// end ;
15859: GO 15748
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15868: LD_INT 0
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_INT 2
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 1
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: LD_INT 25
15909: PUSH
15910: LD_INT 4
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: LIST
15921: LIST
15922: PPUSH
15923: CALL 11667 0 2
15927: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15928: LD_ADDR_VAR 0 5
15932: PUSH
15933: LD_VAR 0 5
15937: PPUSH
15938: LD_INT 0
15940: PPUSH
15941: CALL 13816 0 2
15945: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15946: LD_ADDR_VAR 0 6
15950: PUSH
15951: LD_VAR 0 1
15955: PPUSH
15956: LD_VAR 0 5
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: CALL 13436 0 3
15968: ST_TO_ADDR
// if n > sk then
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 6
15978: GREATER
15979: IFFALSE 15991
// n := sk ;
15981: LD_ADDR_VAR 0 2
15985: PUSH
15986: LD_VAR 0 6
15990: ST_TO_ADDR
// for i = 1 to n do
15991: LD_ADDR_VAR 0 4
15995: PUSH
15996: DOUBLE
15997: LD_INT 1
15999: DEC
16000: ST_TO_ADDR
16001: LD_VAR 0 2
16005: PUSH
16006: FOR_TO
16007: IFFALSE 16119
// if ( sk [ i ] [ 1 ] ) <> 0 then
16009: LD_VAR 0 6
16013: PUSH
16014: LD_VAR 0 4
16018: ARRAY
16019: PUSH
16020: LD_INT 1
16022: ARRAY
16023: PUSH
16024: LD_INT 0
16026: NONEQUAL
16027: IFFALSE 16117
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16029: LD_ADDR_EXP 53
16033: PUSH
16034: LD_EXP 53
16038: PPUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: LD_VAR 0 6
16048: PUSH
16049: LD_VAR 0 4
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PPUSH
16059: LD_INT 3
16061: PPUSH
16062: CALL 41962 0 4
16066: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16067: LD_ADDR_EXP 55
16071: PUSH
16072: LD_EXP 55
16076: PPUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_EXP 55
16086: PUSH
16087: LD_VAR 0 1
16091: ARRAY
16092: PUSH
16093: LD_INT 1
16095: PLUS
16096: PPUSH
16097: LD_VAR 0 6
16101: PUSH
16102: LD_VAR 0 4
16106: ARRAY
16107: PUSH
16108: LD_INT 1
16110: ARRAY
16111: PPUSH
16112: CALL 31132 0 4
16116: ST_TO_ADDR
// end ;
16117: GO 16006
16119: POP
16120: POP
// end ;
16121: LD_VAR 0 3
16125: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_VAR 0 1
16141: PPUSH
16142: LD_INT 2
16144: PUSH
16145: LD_INT 25
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: PUSH
16155: LD_INT 25
16157: PUSH
16158: LD_INT 2
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL 11667 0 2
16174: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16175: LD_ADDR_VAR 0 5
16179: PUSH
16180: LD_VAR 0 5
16184: PPUSH
16185: LD_INT 0
16187: PPUSH
16188: CALL 13816 0 2
16192: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16193: LD_ADDR_VAR 0 6
16197: PUSH
16198: LD_VAR 0 1
16202: PPUSH
16203: LD_VAR 0 5
16207: PPUSH
16208: LD_INT 4
16210: PPUSH
16211: CALL 13436 0 3
16215: ST_TO_ADDR
// if n > sk then
16216: LD_VAR 0 2
16220: PUSH
16221: LD_VAR 0 6
16225: GREATER
16226: IFFALSE 16238
// n := sk ;
16228: LD_ADDR_VAR 0 2
16232: PUSH
16233: LD_VAR 0 6
16237: ST_TO_ADDR
// for i = 1 to n do
16238: LD_ADDR_VAR 0 4
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_VAR 0 2
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16366
// if ( sk [ i ] [ 1 ] ) <> 0 then
16256: LD_VAR 0 6
16260: PUSH
16261: LD_VAR 0 4
16265: ARRAY
16266: PUSH
16267: LD_INT 1
16269: ARRAY
16270: PUSH
16271: LD_INT 0
16273: NONEQUAL
16274: IFFALSE 16364
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16276: LD_ADDR_EXP 53
16280: PUSH
16281: LD_EXP 53
16285: PPUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 6
16295: PUSH
16296: LD_VAR 0 4
16300: ARRAY
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_INT 4
16308: PPUSH
16309: CALL 41962 0 4
16313: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16314: LD_ADDR_EXP 54
16318: PUSH
16319: LD_EXP 54
16323: PPUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_EXP 54
16333: PUSH
16334: LD_VAR 0 1
16338: ARRAY
16339: PUSH
16340: LD_INT 1
16342: PLUS
16343: PPUSH
16344: LD_VAR 0 6
16348: PUSH
16349: LD_VAR 0 4
16353: ARRAY
16354: PUSH
16355: LD_INT 1
16357: ARRAY
16358: PPUSH
16359: CALL 31132 0 4
16363: ST_TO_ADDR
// end ;
16364: GO 16253
16366: POP
16367: POP
// end ;
16368: LD_VAR 0 3
16372: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16373: LD_INT 0
16375: PPUSH
16376: PPUSH
16377: PPUSH
16378: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16379: LD_ADDR_VAR 0 6
16383: PUSH
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_INT 2
16391: PUSH
16392: LD_INT 25
16394: PUSH
16395: LD_INT 1
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 2
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 4
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: PPUSH
16439: CALL 11667 0 2
16443: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16444: LD_ADDR_VAR 0 6
16448: PUSH
16449: LD_VAR 0 6
16453: PPUSH
16454: LD_INT 0
16456: PPUSH
16457: CALL 13816 0 2
16461: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16462: LD_ADDR_VAR 0 7
16466: PUSH
16467: LD_VAR 0 1
16471: PPUSH
16472: LD_VAR 0 6
16476: PPUSH
16477: LD_INT 1
16479: PPUSH
16480: CALL 13436 0 3
16484: ST_TO_ADDR
// if n > sk then
16485: LD_VAR 0 2
16489: PUSH
16490: LD_VAR 0 7
16494: GREATER
16495: IFFALSE 16507
// n := sk ;
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: LD_VAR 0 7
16506: ST_TO_ADDR
// for i = 1 to n do
16507: LD_ADDR_VAR 0 5
16511: PUSH
16512: DOUBLE
16513: LD_INT 1
16515: DEC
16516: ST_TO_ADDR
16517: LD_VAR 0 2
16521: PUSH
16522: FOR_TO
16523: IFFALSE 16567
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16525: LD_ADDR_EXP 53
16529: PUSH
16530: LD_EXP 53
16534: PPUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_VAR 0 7
16544: PUSH
16545: LD_VAR 0 5
16549: ARRAY
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_VAR 0 3
16559: PPUSH
16560: CALL 41962 0 4
16564: ST_TO_ADDR
// end ;
16565: GO 16522
16567: POP
16568: POP
// end ;
16569: LD_VAR 0 4
16573: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16574: LD_INT 0
16576: PPUSH
16577: PPUSH
16578: PPUSH
// b := false ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_INT 0
16586: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16587: LD_VAR 0 3
16591: PUSH
16592: LD_INT 1
16594: PUSH
16595: LD_INT 9
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: LD_INT 8
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: LIST
16609: IN
16610: IFFALSE 16698
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_INT 2
16619: PUSH
16620: LD_INT 30
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: LD_INT 30
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL 11667 0 2
16649: IFFALSE 16698
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16651: LD_ADDR_VAR 0 6
16655: PUSH
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_INT 2
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 4
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 30
16676: PUSH
16677: LD_INT 5
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: LIST
16688: PPUSH
16689: CALL 11667 0 2
16693: PUSH
16694: LD_INT 1
16696: ARRAY
16697: ST_TO_ADDR
// if class = class_engineer then
16698: LD_VAR 0 3
16702: PUSH
16703: LD_INT 2
16705: EQUAL
16706: IFFALSE 16794
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16708: LD_VAR 0 1
16712: PPUSH
16713: LD_INT 2
16715: PUSH
16716: LD_INT 30
16718: PUSH
16719: LD_INT 0
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PPUSH
16741: CALL 11667 0 2
16745: IFFALSE 16794
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16747: LD_ADDR_VAR 0 6
16751: PUSH
16752: LD_VAR 0 1
16756: PPUSH
16757: LD_INT 2
16759: PUSH
16760: LD_INT 30
16762: PUSH
16763: LD_INT 0
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: PUSH
16770: LD_INT 30
16772: PUSH
16773: LD_INT 1
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: LIST
16784: PPUSH
16785: CALL 11667 0 2
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: ST_TO_ADDR
// if class = class_mechanic then
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 3
16801: EQUAL
16802: IFFALSE 16872
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16804: LD_VAR 0 1
16808: PPUSH
16809: LD_INT 30
16811: PUSH
16812: LD_INT 3
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PPUSH
16819: CALL 11667 0 2
16823: IFFALSE 16872
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16825: LD_ADDR_VAR 0 6
16829: PUSH
16830: LD_VAR 0 1
16834: PPUSH
16835: LD_INT 2
16837: PUSH
16838: LD_INT 30
16840: PUSH
16841: LD_INT 2
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: LD_INT 30
16850: PUSH
16851: LD_INT 3
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL 11667 0 2
16867: PUSH
16868: LD_INT 1
16870: ARRAY
16871: ST_TO_ADDR
// if class = class_scientistic then
16872: LD_VAR 0 3
16876: PUSH
16877: LD_INT 4
16879: EQUAL
16880: IFFALSE 16990
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16882: LD_VAR 0 1
16886: PPUSH
16887: LD_INT 2
16889: PUSH
16890: LD_INT 30
16892: PUSH
16893: LD_INT 6
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 30
16902: PUSH
16903: LD_INT 7
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 30
16912: PUSH
16913: LD_INT 8
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL 11667 0 2
16930: IFFALSE 16990
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16932: LD_ADDR_VAR 0 6
16936: PUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_INT 2
16944: PUSH
16945: LD_INT 30
16947: PUSH
16948: LD_INT 6
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: LD_INT 30
16957: PUSH
16958: LD_INT 7
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 30
16967: PUSH
16968: LD_INT 8
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: PPUSH
16981: CALL 11667 0 2
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: ST_TO_ADDR
// if GetClass ( unit ) = class then
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 257
16999: PUSH
17000: LD_VAR 0 3
17004: EQUAL
17005: IFFALSE 17039
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
17007: LD_ADDR_EXP 53
17011: PUSH
17012: LD_EXP 53
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: LD_VAR 0 2
17026: PPUSH
17027: LD_VAR 0 3
17031: PPUSH
17032: CALL 42053 0 4
17036: ST_TO_ADDR
// end else
17037: GO 17132
// if b then
17039: LD_VAR 0 6
17043: IFFALSE 17124
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17045: LD_VAR 0 2
17049: PPUSH
17050: CALL_OW 310
17054: PUSH
17055: LD_VAR 0 2
17059: PPUSH
17060: CALL_OW 310
17064: PUSH
17065: LD_VAR 0 6
17069: NONEQUAL
17070: AND
17071: IFFALSE 17082
// ComExitBuilding ( unit ) ;
17073: LD_VAR 0 2
17077: PPUSH
17078: CALL_OW 122
// if not IsInUnit ( unit ) then
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL_OW 310
17091: NOT
17092: IFFALSE 17108
// ComEnterUnit ( unit , b ) ;
17094: LD_VAR 0 2
17098: PPUSH
17099: LD_VAR 0 6
17103: PPUSH
17104: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17108: LD_VAR 0 2
17112: PPUSH
17113: LD_VAR 0 3
17117: PPUSH
17118: CALL_OW 183
// end else
17122: GO 17132
// result := false ;
17124: LD_ADDR_VAR 0 4
17128: PUSH
17129: LD_INT 0
17131: ST_TO_ADDR
// end ; end_of_file
17132: LD_VAR 0 4
17136: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17137: LD_INT 0
17139: PPUSH
17140: PPUSH
17141: PPUSH
17142: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17143: LD_ADDR_VAR 0 5
17147: PUSH
17148: LD_INT 35
17150: PUSH
17151: LD_INT 45
17153: PUSH
17154: LD_INT 46
17156: PUSH
17157: LD_INT 47
17159: PUSH
17160: LD_INT 1
17162: PUSH
17163: LD_INT 2
17165: PUSH
17166: LD_INT 48
17168: PUSH
17169: LD_INT 49
17171: PUSH
17172: LD_INT 50
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: ST_TO_ADDR
// if MCF_Lab ( side ) then
17190: LD_VAR 0 1
17194: PPUSH
17195: CALL 11706 0 1
17199: IFFALSE 17438
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL 11706 0 1
17210: PUSH
17211: LD_INT 1
17213: ARRAY
17214: PPUSH
17215: CALL_OW 461
17219: PUSH
17220: LD_INT 2
17222: EQUAL
17223: IFFALSE 17362
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17225: LD_VAR 0 1
17229: PPUSH
17230: CALL 11706 0 1
17234: PUSH
17235: LD_INT 1
17237: ARRAY
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL 17534 0 2
17248: IFFALSE 17275
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL 11706 0 1
17259: PUSH
17260: LD_INT 1
17262: ARRAY
17263: PPUSH
17264: LD_VAR 0 2
17268: PPUSH
17269: CALL_OW 124
17273: GO 17362
// if MCF_Lab ( side ) > 1 then
17275: LD_VAR 0 1
17279: PPUSH
17280: CALL 11706 0 1
17284: PUSH
17285: LD_INT 1
17287: GREATER
17288: IFFALSE 17362
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 11706 0 1
17299: PUSH
17300: LD_INT 2
17302: ARRAY
17303: PPUSH
17304: CALL_OW 461
17308: PUSH
17309: LD_INT 2
17311: EQUAL
17312: IFFALSE 17362
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL 11706 0 1
17323: PUSH
17324: LD_INT 2
17326: ARRAY
17327: PPUSH
17328: LD_VAR 0 2
17332: PPUSH
17333: CALL 17534 0 2
17337: IFFALSE 17362
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17339: LD_VAR 0 1
17343: PPUSH
17344: CALL 11706 0 1
17348: PUSH
17349: LD_INT 2
17351: ARRAY
17352: PPUSH
17353: LD_VAR 0 2
17357: PPUSH
17358: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17362: LD_VAR 0 2
17366: PUSH
17367: LD_INT 2
17369: PUSH
17370: LD_INT 11
17372: PUSH
17373: LD_INT 4
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: IN
17385: IFFALSE 17438
// begin for lab in MCF_Lab ( side ) do
17387: LD_ADDR_VAR 0 6
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: CALL 11706 0 1
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17436
// if BuildingStatus ( lab ) = bs_need_ape then
17405: LD_VAR 0 6
17409: PPUSH
17410: CALL_OW 461
17414: PUSH
17415: LD_INT 10
17417: EQUAL
17418: IFFALSE 17434
// MCL_ResTame ( side , lab ) ;
17420: LD_VAR 0 1
17424: PPUSH
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL 17659 0 2
17434: GO 17402
17436: POP
17437: POP
// end ; end ; end ;
17438: LD_VAR 0 3
17442: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17443: LD_INT 0
17445: PPUSH
17446: PPUSH
// tmp := [ ] ;
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: EMPTY
17453: ST_TO_ADDR
// if not lab then
17454: LD_VAR 0 1
17458: NOT
17459: IFFALSE 17471
// result := false else
17461: LD_ADDR_VAR 0 2
17465: PUSH
17466: LD_INT 0
17468: ST_TO_ADDR
17469: GO 17529
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17471: LD_ADDR_VAR 0 3
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 1
17488: PPUSH
17489: CALL_OW 268
17493: ADD
17494: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17495: LD_ADDR_VAR 0 3
17499: PUSH
17500: LD_VAR 0 3
17504: PUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: LD_INT 2
17512: PPUSH
17513: CALL_OW 268
17517: ADD
17518: ST_TO_ADDR
// result := tmp ;
17519: LD_ADDR_VAR 0 2
17523: PUSH
17524: LD_VAR 0 3
17528: ST_TO_ADDR
// end ; end ;
17529: LD_VAR 0 2
17533: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17534: LD_INT 0
17536: PPUSH
17537: PPUSH
17538: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17539: LD_ADDR_VAR 0 5
17543: PUSH
17544: LD_INT 35
17546: PUSH
17547: LD_INT 45
17549: PUSH
17550: LD_INT 46
17552: PUSH
17553: LD_INT 47
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: LD_INT 48
17564: PUSH
17565: LD_INT 49
17567: PUSH
17568: LD_INT 50
17570: PUSH
17571: LD_INT 20
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: ST_TO_ADDR
// if lab then
17586: LD_VAR 0 1
17590: IFFALSE 17646
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17592: LD_VAR 0 2
17596: PUSH
17597: LD_VAR 0 5
17601: IN
17602: PUSH
17603: LD_VAR 0 2
17607: PPUSH
17608: CALL_OW 481
17612: PUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL 17443 0 1
17622: IN
17623: OR
17624: IFFALSE 17636
// result := true else
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: LD_INT 1
17633: ST_TO_ADDR
17634: GO 17644
// result := false ;
17636: LD_ADDR_VAR 0 3
17640: PUSH
17641: LD_INT 0
17643: ST_TO_ADDR
// end else
17644: GO 17654
// result := false ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: LD_INT 0
17653: ST_TO_ADDR
// end ;
17654: LD_VAR 0 3
17658: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17659: LD_INT 0
17661: PPUSH
17662: PPUSH
17663: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17664: LD_ADDR_VAR 0 4
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: LD_INT 171
17676: PPUSH
17677: EMPTY
17678: PPUSH
17679: CALL 12370 0 3
17683: ST_TO_ADDR
// if not ape then
17684: LD_VAR 0 4
17688: NOT
17689: IFFALSE 17721
// if MCF_Ape ( side ) then
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12080 0 1
17700: IFFALSE 17721
// ape := MCF_Ape ( side ) [ 1 ] ;
17702: LD_ADDR_VAR 0 4
17706: PUSH
17707: LD_VAR 0 1
17711: PPUSH
17712: CALL 12080 0 1
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// if ape then
17721: LD_VAR 0 4
17725: IFFALSE 17776
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17727: LD_VAR 0 4
17731: PUSH
17732: LD_INT 1
17734: ARRAY
17735: PPUSH
17736: CALL_OW 310
17740: PUSH
17741: LD_VAR 0 4
17745: PUSH
17746: LD_INT 1
17748: ARRAY
17749: PPUSH
17750: CALL_OW 310
17754: PUSH
17755: LD_VAR 0 2
17759: NONEQUAL
17760: AND
17761: IFFALSE 17776
// ComExitBuilding ( ape [ 1 ] ) ;
17763: LD_VAR 0 4
17767: PUSH
17768: LD_INT 1
17770: ARRAY
17771: PPUSH
17772: CALL_OW 122
// if not lab then
17776: LD_VAR 0 2
17780: NOT
17781: IFFALSE 17787
// exit else
17783: GO 17935
17785: GO 17895
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17787: LD_VAR 0 1
17791: PPUSH
17792: LD_INT 16
17794: PPUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL 12370 0 3
17809: PUSH
17810: LD_INT 0
17812: EQUAL
17813: PUSH
17814: LD_VAR 0 2
17818: PPUSH
17819: CALL_OW 313
17823: PUSH
17824: LD_INT 6
17826: EQUAL
17827: AND
17828: IFFALSE 17895
// begin tmp := UnitsInside ( lab ) ;
17830: LD_ADDR_VAR 0 5
17834: PUSH
17835: LD_VAR 0 2
17839: PPUSH
17840: CALL_OW 313
17844: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17845: LD_VAR 0 5
17849: PUSH
17850: LD_VAR 0 5
17854: ARRAY
17855: PPUSH
17856: LD_INT 16
17858: PPUSH
17859: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 5
17872: ARRAY
17873: PPUSH
17874: CALL_OW 310
17878: IFFALSE 17895
// ComExitBuilding ( tmp [ tmp ] ) ;
17880: LD_VAR 0 5
17884: PUSH
17885: LD_VAR 0 5
17889: ARRAY
17890: PPUSH
17891: CALL_OW 122
// end ; if ape then
17895: LD_VAR 0 4
17899: IFFALSE 17935
// if not IsInUnit ( ape [ 1 ] ) then
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: CALL_OW 310
17914: NOT
17915: IFFALSE 17935
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17917: LD_VAR 0 4
17921: PUSH
17922: LD_INT 1
17924: ARRAY
17925: PPUSH
17926: LD_VAR 0 2
17930: PPUSH
17931: CALL_OW 120
// end ;
17935: LD_VAR 0 3
17939: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17940: LD_INT 0
17942: PPUSH
17943: PPUSH
17944: PPUSH
// result := false ;
17945: LD_ADDR_VAR 0 2
17949: PUSH
17950: LD_INT 0
17952: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17953: LD_ADDR_VAR 0 3
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: CALL 18050 0 1
17967: ST_TO_ADDR
// if techs then
17968: LD_VAR 0 3
17972: IFFALSE 18002
// if techs [ 2 ] then
17974: LD_VAR 0 3
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: IFFALSE 17994
// result := true else
17984: LD_ADDR_VAR 0 2
17988: PUSH
17989: LD_INT 1
17991: ST_TO_ADDR
17992: GO 18002
// result := false ;
17994: LD_ADDR_VAR 0 2
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 2
18006: RET
// export function MCL_Start ( side ) ; var i ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
// if MCL_GetTechList ( side ) then
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18050 0 1
18020: IFFALSE 18045
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: CALL 18050 0 1
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: CALL 17137 0 2
// end ;
18045: LD_VAR 0 2
18049: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18050: LD_INT 0
18052: PPUSH
18053: PPUSH
18054: PPUSH
// if MREG_ToRes then
18055: LD_EXP 50
18059: IFFALSE 18144
// for i = 1 to MREG_ToRes do
18061: LD_ADDR_VAR 0 3
18065: PUSH
18066: DOUBLE
18067: LD_INT 1
18069: DEC
18070: ST_TO_ADDR
18071: LD_EXP 50
18075: PUSH
18076: FOR_TO
18077: IFFALSE 18142
// if MREG_ToRes [ i ] [ 1 ] = side then
18079: LD_EXP 50
18083: PUSH
18084: LD_VAR 0 3
18088: ARRAY
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PUSH
18094: LD_VAR 0 1
18098: EQUAL
18099: IFFALSE 18140
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18101: LD_ADDR_VAR 0 4
18105: PUSH
18106: LD_VAR 0 4
18110: PPUSH
18111: LD_VAR 0 4
18115: PUSH
18116: LD_INT 1
18118: PLUS
18119: PPUSH
18120: LD_EXP 50
18124: PUSH
18125: LD_VAR 0 3
18129: ARRAY
18130: PUSH
18131: LD_INT 2
18133: ARRAY
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
// end ;
18140: GO 18076
18142: POP
18143: POP
// result := techs ;
18144: LD_ADDR_VAR 0 2
18148: PUSH
18149: LD_VAR 0 4
18153: ST_TO_ADDR
// end ;
18154: LD_VAR 0 2
18158: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18159: LD_INT 0
18161: PPUSH
18162: PPUSH
// for i = 1 to tech_list do
18163: LD_ADDR_VAR 0 4
18167: PUSH
18168: DOUBLE
18169: LD_INT 1
18171: DEC
18172: ST_TO_ADDR
18173: LD_VAR 0 2
18177: PUSH
18178: FOR_TO
18179: IFFALSE 18233
// if not tech_list [ i ] = 20 then
18181: LD_VAR 0 2
18185: PUSH
18186: LD_VAR 0 4
18190: ARRAY
18191: PUSH
18192: LD_INT 20
18194: EQUAL
18195: NOT
18196: IFFALSE 18231
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: LD_VAR 0 2
18217: PUSH
18218: LD_VAR 0 4
18222: ARRAY
18223: PPUSH
18224: EMPTY
18225: PPUSH
18226: CALL 41962 0 4
18230: ST_TO_ADDR
18231: GO 18178
18233: POP
18234: POP
// result := true ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_INT 1
18242: ST_TO_ADDR
// end ;
18243: LD_VAR 0 3
18247: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18248: LD_INT 0
18250: PPUSH
18251: PPUSH
// for i = MREG_ToRes downto 1 do
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: DOUBLE
18258: LD_EXP 50
18262: INC
18263: ST_TO_ADDR
18264: LD_INT 1
18266: PUSH
18267: FOR_DOWNTO
18268: IFFALSE 18314
// if MREG_ToRes [ i ] [ 1 ] = side then
18270: LD_EXP 50
18274: PUSH
18275: LD_VAR 0 3
18279: ARRAY
18280: PUSH
18281: LD_INT 1
18283: ARRAY
18284: PUSH
18285: LD_VAR 0 1
18289: EQUAL
18290: IFFALSE 18312
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18292: LD_ADDR_EXP 50
18296: PUSH
18297: LD_EXP 50
18301: PPUSH
18302: LD_VAR 0 3
18306: PPUSH
18307: CALL_OW 3
18311: ST_TO_ADDR
18312: GO 18267
18314: POP
18315: POP
// result := true ;
18316: LD_ADDR_VAR 0 2
18320: PUSH
18321: LD_INT 1
18323: ST_TO_ADDR
// end ;
18324: LD_VAR 0 2
18328: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18329: LD_INT 0
18331: PPUSH
// result := GetTechProgress ( side , tech ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_VAR 0 2
18346: PPUSH
18347: CALL_OW 326
18351: ST_TO_ADDR
// end ;
18352: LD_VAR 0 3
18356: RET
// export function MCL_Require ( tech ) ; begin
18357: LD_INT 0
18359: PPUSH
// result := GetTechTechsReq ( tech ) ;
18360: LD_ADDR_VAR 0 2
18364: PUSH
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL_OW 480
18374: ST_TO_ADDR
// end ; end_of_file
18375: LD_VAR 0 2
18379: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18380: LD_INT 0
18382: PPUSH
18383: PPUSH
18384: PPUSH
// uc_side := 0 ;
18385: LD_ADDR_OWVAR 20
18389: PUSH
18390: LD_INT 0
18392: ST_TO_ADDR
// uc_nation := 0 ;
18393: LD_ADDR_OWVAR 21
18397: PUSH
18398: LD_INT 0
18400: ST_TO_ADDR
// for i = 1 to n do
18401: LD_ADDR_VAR 0 5
18405: PUSH
18406: DOUBLE
18407: LD_INT 1
18409: DEC
18410: ST_TO_ADDR
18411: LD_VAR 0 2
18415: PUSH
18416: FOR_TO
18417: IFFALSE 18562
// begin hc_importance := 0 ;
18419: LD_ADDR_OWVAR 32
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// hc_gallery :=  ;
18427: LD_ADDR_OWVAR 33
18431: PUSH
18432: LD_STRING 
18434: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18435: LD_ADDR_OWVAR 35
18439: PUSH
18440: LD_VAR 0 3
18444: PUSH
18445: LD_INT 20
18447: MINUS
18448: PPUSH
18449: LD_VAR 0 3
18453: PUSH
18454: LD_INT 20
18456: PLUS
18457: PPUSH
18458: CALL_OW 12
18462: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18463: LD_ADDR_OWVAR 31
18467: PUSH
18468: LD_INT 0
18470: PPUSH
18471: LD_INT 2
18473: PPUSH
18474: CALL_OW 12
18478: PUSH
18479: LD_INT 0
18481: PUSH
18482: LD_INT 0
18484: PUSH
18485: LD_INT 0
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18494: LD_ADDR_OWVAR 30
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 0
18504: PUSH
18505: LD_INT 0
18507: PUSH
18508: LD_INT 0
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: ST_TO_ADDR
// hc_name :=  ;
18517: LD_ADDR_OWVAR 26
18521: PUSH
18522: LD_STRING 
18524: ST_TO_ADDR
// hc_class := class_apeman ;
18525: LD_ADDR_OWVAR 28
18529: PUSH
18530: LD_INT 12
18532: ST_TO_ADDR
// ape := CreateHuman ;
18533: LD_ADDR_VAR 0 6
18537: PUSH
18538: CALL_OW 44
18542: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18543: LD_VAR 0 6
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: LD_INT 0
18555: PPUSH
18556: CALL_OW 49
// end ;
18560: GO 18416
18562: POP
18563: POP
// end ;
18564: LD_VAR 0 4
18568: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18569: LD_INT 0
18571: PPUSH
18572: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18573: LD_VAR 0 1
18577: PPUSH
18578: CALL 12080 0 1
18582: PUSH
18583: LD_EXP 37
18587: PUSH
18588: LD_VAR 0 1
18592: ARRAY
18593: GREATEREQUAL
18594: IFFALSE 18771
// begin if GetTag ( unit ) = 17 then
18596: LD_VAR 0 2
18600: PPUSH
18601: CALL_OW 110
18605: PUSH
18606: LD_INT 17
18608: EQUAL
18609: IFFALSE 18769
// begin SetTag ( unit , 0 ) ;
18611: LD_VAR 0 2
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18623: LD_VAR 0 1
18627: PPUSH
18628: CALL 11706 0 1
18632: PUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: CALL 18050 0 1
18642: NOT
18643: AND
18644: IFFALSE 18669
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: CALL 11706 0 1
18660: PUSH
18661: LD_INT 1
18663: ARRAY
18664: PPUSH
18665: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18669: LD_VAR 0 1
18673: PPUSH
18674: CALL 11706 0 1
18678: NOT
18679: PUSH
18680: LD_VAR 0 1
18684: PPUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 1
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PPUSH
18695: CALL 11667 0 2
18699: AND
18700: IFFALSE 18769
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18702: LD_VAR 0 2
18706: PPUSH
18707: LD_VAR 0 1
18711: PPUSH
18712: LD_INT 30
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PPUSH
18722: CALL 11667 0 2
18726: PUSH
18727: LD_INT 1
18729: ARRAY
18730: PPUSH
18731: CALL_OW 250
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: LD_INT 30
18743: PUSH
18744: LD_INT 1
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: PPUSH
18751: CALL 11667 0 2
18755: PUSH
18756: LD_INT 1
18758: ARRAY
18759: PPUSH
18760: CALL_OW 251
18764: PPUSH
18765: CALL_OW 111
// end ; end else
18769: GO 18955
// if GetClass ( unit ) <> 4 then
18771: LD_VAR 0 2
18775: PPUSH
18776: CALL_OW 257
18780: PUSH
18781: LD_INT 4
18783: NONEQUAL
18784: IFFALSE 18790
// exit else
18786: GO 18955
18788: GO 18955
// if GetTag ( unit ) = 0 then
18790: LD_VAR 0 2
18794: PPUSH
18795: CALL_OW 110
18799: PUSH
18800: LD_INT 0
18802: EQUAL
18803: IFFALSE 18819
// SetTag ( unit , 17 ) else
18805: LD_VAR 0 2
18809: PPUSH
18810: LD_INT 17
18812: PPUSH
18813: CALL_OW 109
18817: GO 18955
// begin if IsInUnit ( unit ) then
18819: LD_VAR 0 2
18823: PPUSH
18824: CALL_OW 310
18828: IFFALSE 18839
// ComExitBuilding ( unit ) ;
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 122
// Wait ( 1 ) ;
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18846: LD_ADDR_VAR 0 4
18850: PUSH
18851: LD_INT 22
18853: PUSH
18854: LD_INT 0
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PUSH
18861: LD_INT 25
18863: PUSH
18864: LD_INT 12
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PPUSH
18875: CALL_OW 69
18879: PPUSH
18880: LD_VAR 0 2
18884: PPUSH
18885: CALL_OW 74
18889: ST_TO_ADDR
// if not ape then
18890: LD_VAR 0 4
18894: NOT
18895: IFFALSE 18901
// exit else
18897: GO 18955
18899: GO 18910
// ComHold ( ape ) ;
18901: LD_VAR 0 4
18905: PPUSH
18906: CALL_OW 140
// if not HasTask ( unit ) then
18910: LD_VAR 0 2
18914: PPUSH
18915: CALL_OW 314
18919: NOT
18920: IFFALSE 18953
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 4
18931: PPUSH
18932: CALL_OW 250
18936: PPUSH
18937: LD_VAR 0 4
18941: PPUSH
18942: CALL_OW 251
18946: PPUSH
18947: CALL_OW 131
18951: GO 18955
// exit ;
18953: GO 18955
// end ; end ;
18955: LD_VAR 0 3
18959: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18960: LD_INT 0
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18966: LD_ADDR_VAR 0 4
18970: PUSH
18971: LD_EXP 38
18975: PUSH
18976: LD_VAR 0 1
18980: ARRAY
18981: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18982: LD_ADDR_VAR 0 5
18986: PUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_STRING normal
18994: PPUSH
18995: CALL 12164 0 2
18999: ST_TO_ADDR
// if apes then
19000: LD_VAR 0 5
19004: IFFALSE 19232
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
19006: LD_INT 2
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: CALL_OW 321
19018: PUSH
19019: LD_INT 2
19021: EQUAL
19022: PUSH
19023: LD_VAR 0 4
19027: PUSH
19028: LD_INT 2
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: EQUAL
19035: AND
19036: PUSH
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_STRING engineer
19044: PPUSH
19045: CALL 12164 0 2
19049: PUSH
19050: LD_INT 3
19052: LESS
19053: AND
19054: PUSH
19055: LD_VAR 0 1
19059: PPUSH
19060: LD_INT 30
19062: PUSH
19063: LD_INT 1
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: CALL 11667 0 2
19074: AND
19075: IFFALSE 19129
// begin for i in apes do
19077: LD_ADDR_VAR 0 3
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: FOR_IN
19088: IFFALSE 19125
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19090: LD_VAR 0 3
19094: PPUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: LD_INT 30
19102: PUSH
19103: LD_INT 1
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PPUSH
19110: CALL 11667 0 2
19114: PUSH
19115: LD_INT 1
19117: ARRAY
19118: PPUSH
19119: CALL_OW 120
// end ;
19123: GO 19087
19125: POP
19126: POP
// end else
19127: GO 19232
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19129: LD_INT 11
19131: PPUSH
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 321
19141: PUSH
19142: LD_INT 2
19144: EQUAL
19145: PUSH
19146: LD_VAR 0 4
19150: PUSH
19151: LD_INT 1
19153: ARRAY
19154: PUSH
19155: LD_INT 1
19157: EQUAL
19158: AND
19159: PUSH
19160: LD_VAR 0 1
19164: PPUSH
19165: LD_INT 30
19167: PUSH
19168: LD_INT 5
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PPUSH
19175: CALL 11667 0 2
19179: AND
19180: IFFALSE 19232
// begin for i in apes do
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_VAR 0 5
19191: PUSH
19192: FOR_IN
19193: IFFALSE 19230
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19195: LD_VAR 0 3
19199: PPUSH
19200: LD_VAR 0 1
19204: PPUSH
19205: LD_INT 30
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PPUSH
19215: CALL 11667 0 2
19219: PUSH
19220: LD_INT 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 120
// end ;
19228: GO 19192
19230: POP
19231: POP
// end ; end ; end ; end_of_file
19232: LD_VAR 0 2
19236: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19241: LD_VAR 0 1
19245: PPUSH
19246: CALL_OW 257
19250: PUSH
19251: LD_INT 4
19253: EQUAL
19254: NOT
19255: PUSH
19256: LD_VAR 0 2
19260: NOT
19261: OR
19262: IFFALSE 19268
// exit else
19264: GO 19302
19266: GO 19302
// if not GetTag ( unit ) = 4 then
19268: LD_VAR 0 1
19272: PPUSH
19273: CALL_OW 110
19277: PUSH
19278: LD_INT 4
19280: EQUAL
19281: NOT
19282: IFFALSE 19288
// exit else
19284: GO 19302
19286: GO 19302
// ComHeal ( unit , target ) ;
19288: LD_VAR 0 1
19292: PPUSH
19293: LD_VAR 0 2
19297: PPUSH
19298: CALL_OW 128
// end ;
19302: LD_VAR 0 3
19306: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19316: LD_ADDR_VAR 0 5
19320: PUSH
19321: LD_INT 22
19323: PUSH
19324: LD_VAR 0 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 21
19335: PUSH
19336: LD_INT 1
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 3
19345: PUSH
19346: LD_INT 55
19348: PUSH
19349: EMPTY
19350: LIST
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 3
19358: PUSH
19359: LD_INT 54
19361: PUSH
19362: EMPTY
19363: LIST
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: PUSH
19369: LD_INT 3
19371: PUSH
19372: LD_INT 24
19374: PUSH
19375: LD_INT 1000
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: EMPTY
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PPUSH
19393: CALL_OW 69
19397: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19398: LD_ADDR_VAR 0 8
19402: PUSH
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 30
19410: PUSH
19411: LD_INT 1
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: PPUSH
19418: CALL 11667 0 2
19422: ST_TO_ADDR
// r := [ ] ;
19423: LD_ADDR_VAR 0 6
19427: PUSH
19428: EMPTY
19429: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_INT 5
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL 12370 0 3
19444: IFFALSE 19500
// for j in MCF_Tag ( side , 5 , [ ] ) do
19446: LD_ADDR_VAR 0 4
19450: PUSH
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 5
19458: PPUSH
19459: EMPTY
19460: PPUSH
19461: CALL 12370 0 3
19465: PUSH
19466: FOR_IN
19467: IFFALSE 19498
// if GetLives ( j ) = 1000 then
19469: LD_VAR 0 4
19473: PPUSH
19474: CALL_OW 256
19478: PUSH
19479: LD_INT 1000
19481: EQUAL
19482: IFFALSE 19496
// SetTag ( j , 0 ) ;
19484: LD_VAR 0 4
19488: PPUSH
19489: LD_INT 0
19491: PPUSH
19492: CALL_OW 109
19496: GO 19466
19498: POP
19499: POP
// if tmp then
19500: LD_VAR 0 5
19504: IFFALSE 19833
// begin r := [ tmp [ 1 ] ] ;
19506: LD_ADDR_VAR 0 6
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: ARRAY
19519: PUSH
19520: EMPTY
19521: LIST
19522: ST_TO_ADDR
// for i = 2 to tmp do
19523: LD_ADDR_VAR 0 3
19527: PUSH
19528: DOUBLE
19529: LD_INT 2
19531: DEC
19532: ST_TO_ADDR
19533: LD_VAR 0 5
19537: PUSH
19538: FOR_TO
19539: IFFALSE 19831
// begin m := false ;
19541: LD_ADDR_VAR 0 7
19545: PUSH
19546: LD_INT 0
19548: ST_TO_ADDR
// if d then
19549: LD_VAR 0 8
19553: IFFALSE 19708
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19555: LD_VAR 0 5
19559: PUSH
19560: LD_VAR 0 3
19564: ARRAY
19565: PPUSH
19566: CALL_OW 256
19570: PUSH
19571: LD_INT 650
19573: LESS
19574: PUSH
19575: LD_VAR 0 5
19579: PUSH
19580: LD_VAR 0 3
19584: ARRAY
19585: PPUSH
19586: LD_VAR 0 8
19590: PUSH
19591: LD_INT 1
19593: ARRAY
19594: PPUSH
19595: CALL_OW 250
19599: PPUSH
19600: LD_VAR 0 8
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: CALL_OW 251
19613: PPUSH
19614: CALL_OW 297
19618: PUSH
19619: LD_INT 10
19621: GREATER
19622: AND
19623: IFFALSE 19708
// begin if not GetTag ( tmp [ i ] ) = 5 then
19625: LD_VAR 0 5
19629: PUSH
19630: LD_VAR 0 3
19634: ARRAY
19635: PPUSH
19636: CALL_OW 110
19640: PUSH
19641: LD_INT 5
19643: EQUAL
19644: NOT
19645: IFFALSE 19665
// SetTag ( tmp [ i ] , 5 ) ;
19647: LD_VAR 0 5
19651: PUSH
19652: LD_VAR 0 3
19656: ARRAY
19657: PPUSH
19658: LD_INT 5
19660: PPUSH
19661: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19665: LD_VAR 0 5
19669: PUSH
19670: LD_VAR 0 3
19674: ARRAY
19675: PPUSH
19676: LD_VAR 0 8
19680: PUSH
19681: LD_INT 1
19683: ARRAY
19684: PPUSH
19685: CALL_OW 250
19689: PPUSH
19690: LD_VAR 0 8
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: CALL_OW 251
19703: PPUSH
19704: CALL_OW 111
// end ; for j = 1 to r do
19708: LD_ADDR_VAR 0 4
19712: PUSH
19713: DOUBLE
19714: LD_INT 1
19716: DEC
19717: ST_TO_ADDR
19718: LD_VAR 0 6
19722: PUSH
19723: FOR_TO
19724: IFFALSE 19798
// if GetLives ( tmp [ i ] ) < r [ j ] then
19726: LD_VAR 0 5
19730: PUSH
19731: LD_VAR 0 3
19735: ARRAY
19736: PPUSH
19737: CALL_OW 256
19741: PUSH
19742: LD_VAR 0 6
19746: PUSH
19747: LD_VAR 0 4
19751: ARRAY
19752: LESS
19753: IFFALSE 19796
// begin r := Insert ( r , j , tmp [ i ] ) ;
19755: LD_ADDR_VAR 0 6
19759: PUSH
19760: LD_VAR 0 6
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: LD_VAR 0 5
19774: PUSH
19775: LD_VAR 0 3
19779: ARRAY
19780: PPUSH
19781: CALL_OW 2
19785: ST_TO_ADDR
// m := true ;
19786: LD_ADDR_VAR 0 7
19790: PUSH
19791: LD_INT 1
19793: ST_TO_ADDR
// break ;
19794: GO 19798
// end ;
19796: GO 19723
19798: POP
19799: POP
// if not m then
19800: LD_VAR 0 7
19804: NOT
19805: IFFALSE 19829
// r := r ^ tmp [ i ] ;
19807: LD_ADDR_VAR 0 6
19811: PUSH
19812: LD_VAR 0 6
19816: PUSH
19817: LD_VAR 0 5
19821: PUSH
19822: LD_VAR 0 3
19826: ARRAY
19827: ADD
19828: ST_TO_ADDR
// end ;
19829: GO 19538
19831: POP
19832: POP
// end ; result := r end ; end_of_file
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 6
19842: ST_TO_ADDR
19843: LD_VAR 0 2
19847: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
19852: PPUSH
// pom := GetBase ( bdepot ) ;
19853: LD_ADDR_VAR 0 3
19857: PUSH
19858: LD_VAR 0 1
19862: PPUSH
19863: CALL_OW 274
19867: ST_TO_ADDR
// sor := [ ] ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: EMPTY
19874: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19875: LD_ADDR_VAR 0 4
19879: PUSH
19880: LD_VAR 0 4
19884: PUSH
19885: LD_VAR 0 3
19889: PPUSH
19890: LD_INT 1
19892: PPUSH
19893: CALL_OW 275
19897: ADD
19898: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19899: LD_ADDR_VAR 0 4
19903: PUSH
19904: LD_VAR 0 4
19908: PUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_INT 2
19916: PPUSH
19917: CALL_OW 275
19921: ADD
19922: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19923: LD_ADDR_VAR 0 4
19927: PUSH
19928: LD_VAR 0 4
19932: PUSH
19933: LD_VAR 0 3
19937: PPUSH
19938: LD_INT 3
19940: PPUSH
19941: CALL_OW 275
19945: ADD
19946: ST_TO_ADDR
// result := sor ;
19947: LD_ADDR_VAR 0 2
19951: PUSH
19952: LD_VAR 0 4
19956: ST_TO_ADDR
// end ;
19957: LD_VAR 0 2
19961: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19962: LD_INT 0
19964: PPUSH
19965: PPUSH
// while ( coord_list ) do
19966: LD_VAR 0 3
19970: IFFALSE 20144
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19972: LD_ADDR_EXP 46
19976: PUSH
19977: LD_EXP 46
19981: PPUSH
19982: LD_VAR 0 1
19986: PPUSH
19987: LD_VAR 0 2
19991: PPUSH
19992: LD_VAR 0 3
19996: PUSH
19997: LD_INT 1
19999: ARRAY
20000: PUSH
20001: LD_VAR 0 3
20005: PUSH
20006: LD_INT 2
20008: ARRAY
20009: PUSH
20010: LD_VAR 0 3
20014: PUSH
20015: LD_INT 3
20017: ARRAY
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL 41962 0 4
20028: ST_TO_ADDR
// if weapon_list then
20029: LD_VAR 0 4
20033: IFFALSE 20104
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20035: LD_ADDR_EXP 43
20039: PUSH
20040: LD_EXP 43
20044: PPUSH
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_VAR 0 4
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 3
20063: PUSH
20064: LD_INT 1
20066: ARRAY
20067: PUSH
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 2
20075: ARRAY
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PPUSH
20081: CALL 41962 0 4
20085: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: LD_VAR 0 4
20095: PPUSH
20096: LD_INT 1
20098: PPUSH
20099: CALL_OW 3
20103: ST_TO_ADDR
// end ; for i = 1 to 3 do
20104: LD_ADDR_VAR 0 6
20108: PUSH
20109: DOUBLE
20110: LD_INT 1
20112: DEC
20113: ST_TO_ADDR
20114: LD_INT 3
20116: PUSH
20117: FOR_TO
20118: IFFALSE 20140
// coord_list := Delete ( coord_list , 1 ) ;
20120: LD_ADDR_VAR 0 3
20124: PUSH
20125: LD_VAR 0 3
20129: PPUSH
20130: LD_INT 1
20132: PPUSH
20133: CALL_OW 3
20137: ST_TO_ADDR
20138: GO 20117
20140: POP
20141: POP
// end ;
20142: GO 19966
// result := true ;
20144: LD_ADDR_VAR 0 5
20148: PUSH
20149: LD_INT 1
20151: ST_TO_ADDR
// end ;
20152: LD_VAR 0 5
20156: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
// if not weapon_list then
20161: LD_VAR 0 3
20165: NOT
20166: IFFALSE 20170
// exit ;
20168: GO 20285
// while ( coord_list ) do
20170: LD_VAR 0 2
20174: IFFALSE 20285
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20176: LD_ADDR_EXP 43
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 1
20198: ARRAY
20199: PPUSH
20200: LD_VAR 0 2
20204: PUSH
20205: LD_INT 1
20207: ARRAY
20208: PUSH
20209: LD_VAR 0 2
20213: PUSH
20214: LD_INT 2
20216: ARRAY
20217: PUSH
20218: EMPTY
20219: LIST
20220: LIST
20221: PPUSH
20222: CALL 41962 0 4
20226: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20227: LD_ADDR_VAR 0 3
20231: PUSH
20232: LD_VAR 0 3
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: CALL_OW 3
20244: ST_TO_ADDR
// for i = 1 to 2 do
20245: LD_ADDR_VAR 0 5
20249: PUSH
20250: DOUBLE
20251: LD_INT 1
20253: DEC
20254: ST_TO_ADDR
20255: LD_INT 2
20257: PUSH
20258: FOR_TO
20259: IFFALSE 20281
// coord_list := Delete ( coord_list , 1 ) ;
20261: LD_ADDR_VAR 0 2
20265: PUSH
20266: LD_VAR 0 2
20270: PPUSH
20271: LD_INT 1
20273: PPUSH
20274: CALL_OW 3
20278: ST_TO_ADDR
20279: GO 20258
20281: POP
20282: POP
// end ;
20283: GO 20170
// end ;
20285: LD_VAR 0 4
20289: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20290: LD_INT 0
20292: PPUSH
20293: PPUSH
// while ( coord_list ) do
20294: LD_VAR 0 2
20298: IFFALSE 20453
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_INT 1
20307: ARRAY
20308: PPUSH
20309: LD_VAR 0 2
20313: PUSH
20314: LD_INT 2
20316: ARRAY
20317: PPUSH
20318: CALL_OW 428
20322: IFFALSE 20413
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20324: LD_VAR 0 2
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: PPUSH
20333: LD_VAR 0 2
20337: PUSH
20338: LD_INT 2
20340: ARRAY
20341: PPUSH
20342: CALL_OW 428
20346: PPUSH
20347: CALL_OW 266
20351: PUSH
20352: LD_INT 31
20354: PUSH
20355: LD_INT 32
20357: PUSH
20358: LD_INT 33
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: IN
20366: IFFALSE 20413
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20368: LD_ADDR_EXP 52
20372: PUSH
20373: LD_EXP 52
20377: PPUSH
20378: LD_VAR 0 1
20382: PPUSH
20383: LD_VAR 0 2
20387: PUSH
20388: LD_INT 1
20390: ARRAY
20391: PPUSH
20392: LD_VAR 0 2
20396: PUSH
20397: LD_INT 2
20399: ARRAY
20400: PPUSH
20401: CALL_OW 428
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL 41962 0 4
20412: ST_TO_ADDR
// for i = 1 to 3 do
20413: LD_ADDR_VAR 0 4
20417: PUSH
20418: DOUBLE
20419: LD_INT 1
20421: DEC
20422: ST_TO_ADDR
20423: LD_INT 3
20425: PUSH
20426: FOR_TO
20427: IFFALSE 20449
// coord_list := Delete ( coord_list , 1 ) ;
20429: LD_ADDR_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: PPUSH
20439: LD_INT 1
20441: PPUSH
20442: CALL_OW 3
20446: ST_TO_ADDR
20447: GO 20426
20449: POP
20450: POP
// end ;
20451: GO 20294
// result := true ;
20453: LD_ADDR_VAR 0 3
20457: PUSH
20458: LD_INT 1
20460: ST_TO_ADDR
// end ;
20461: LD_VAR 0 3
20465: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20466: LD_INT 0
20468: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20469: LD_ADDR_EXP 46
20473: PUSH
20474: LD_EXP 46
20478: PPUSH
20479: LD_VAR 0 1
20483: PPUSH
20484: LD_INT 0
20486: PPUSH
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL 41962 0 4
20496: ST_TO_ADDR
// end ;
20497: LD_VAR 0 3
20501: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20502: LD_INT 0
20504: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20505: LD_ADDR_EXP 46
20509: PUSH
20510: LD_EXP 46
20514: PPUSH
20515: LD_VAR 0 1
20519: PPUSH
20520: LD_INT 6
20522: PPUSH
20523: LD_VAR 0 2
20527: PPUSH
20528: CALL 41962 0 4
20532: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20533: LD_ADDR_EXP 49
20537: PUSH
20538: LD_EXP 49
20542: PPUSH
20543: LD_VAR 0 1
20547: PPUSH
20548: LD_VAR 0 3
20552: PUSH
20553: LD_INT 1
20555: ARRAY
20556: PPUSH
20557: LD_VAR 0 3
20561: PUSH
20562: LD_INT 2
20564: ARRAY
20565: PPUSH
20566: CALL 41962 0 4
20570: ST_TO_ADDR
// end ;
20571: LD_VAR 0 4
20575: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20576: LD_INT 0
20578: PPUSH
20579: PPUSH
// if ext_list > 5 then
20580: LD_VAR 0 3
20584: PUSH
20585: LD_INT 5
20587: GREATER
20588: IFFALSE 20632
// for i = 6 to ext_list do
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: DOUBLE
20596: LD_INT 6
20598: DEC
20599: ST_TO_ADDR
20600: LD_VAR 0 3
20604: PUSH
20605: FOR_TO
20606: IFFALSE 20630
// ext_list := Delete ( ext_list , ext_list ) ;
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_VAR 0 3
20617: PPUSH
20618: LD_VAR 0 3
20622: PPUSH
20623: CALL_OW 3
20627: ST_TO_ADDR
20628: GO 20605
20630: POP
20631: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20632: LD_VAR 0 1
20636: PPUSH
20637: LD_VAR 0 2
20641: PUSH
20642: LD_INT 1
20644: ARRAY
20645: PPUSH
20646: LD_VAR 0 2
20650: PUSH
20651: LD_INT 2
20653: ARRAY
20654: PPUSH
20655: LD_VAR 0 2
20659: PUSH
20660: LD_INT 3
20662: ARRAY
20663: PPUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: CALL 9179 0 5
// end ;
20673: LD_VAR 0 4
20677: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20678: LD_INT 0
20680: PPUSH
20681: PPUSH
20682: PPUSH
// p := 1 ;
20683: LD_ADDR_VAR 0 6
20687: PUSH
20688: LD_INT 1
20690: ST_TO_ADDR
// if type_list = [ ] then
20691: LD_VAR 0 3
20695: PUSH
20696: EMPTY
20697: EQUAL
20698: IFFALSE 20708
// type_list := b_oil_power ;
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 26
20707: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: DOUBLE
20714: LD_INT 1
20716: DEC
20717: ST_TO_ADDR
20718: LD_VAR 0 2
20722: PUSH
20723: LD_INT 3
20725: DIVREAL
20726: PUSH
20727: FOR_TO
20728: IFFALSE 20831
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20730: LD_ADDR_EXP 46
20734: PUSH
20735: LD_EXP 46
20739: PPUSH
20740: LD_VAR 0 1
20744: PPUSH
20745: LD_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: PPUSH
20753: LD_VAR 0 3
20757: PPUSH
20758: CALL_OW 12
20762: ARRAY
20763: PPUSH
20764: LD_VAR 0 2
20768: PUSH
20769: LD_VAR 0 6
20773: ARRAY
20774: PUSH
20775: LD_VAR 0 2
20779: PUSH
20780: LD_VAR 0 6
20784: PUSH
20785: LD_INT 1
20787: PLUS
20788: ARRAY
20789: PUSH
20790: LD_VAR 0 2
20794: PUSH
20795: LD_VAR 0 6
20799: PUSH
20800: LD_INT 2
20802: PLUS
20803: ARRAY
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: PPUSH
20810: CALL 41962 0 4
20814: ST_TO_ADDR
// p := p + 3 ;
20815: LD_ADDR_VAR 0 6
20819: PUSH
20820: LD_VAR 0 6
20824: PUSH
20825: LD_INT 3
20827: PLUS
20828: ST_TO_ADDR
// end ;
20829: GO 20727
20831: POP
20832: POP
// end ;
20833: LD_VAR 0 4
20837: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20838: LD_INT 0
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
// if not MREG_Deposit [ side ] then
20844: LD_EXP 61
20848: PUSH
20849: LD_VAR 0 1
20853: ARRAY
20854: NOT
20855: IFFALSE 20859
// exit ;
20857: GO 21036
// p := 1 ;
20859: LD_ADDR_VAR 0 4
20863: PUSH
20864: LD_INT 1
20866: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20867: LD_ADDR_VAR 0 3
20871: PUSH
20872: DOUBLE
20873: LD_INT 1
20875: DEC
20876: ST_TO_ADDR
20877: LD_EXP 61
20881: PUSH
20882: LD_VAR 0 1
20886: ARRAY
20887: PUSH
20888: LD_INT 3
20890: DIVREAL
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20895: LD_EXP 61
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PUSH
20906: LD_VAR 0 4
20910: PUSH
20911: LD_INT 2
20913: PLUS
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: EQUAL
20919: IFFALSE 20931
// b := b_oil_mine else
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: LD_INT 29
20928: ST_TO_ADDR
20929: GO 20939
// b := b_siberite_mine ;
20931: LD_ADDR_VAR 0 5
20935: PUSH
20936: LD_INT 30
20938: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20939: LD_ADDR_EXP 46
20943: PUSH
20944: LD_EXP 46
20948: PPUSH
20949: LD_VAR 0 1
20953: PPUSH
20954: LD_VAR 0 5
20958: PPUSH
20959: LD_EXP 61
20963: PUSH
20964: LD_VAR 0 1
20968: ARRAY
20969: PUSH
20970: LD_VAR 0 4
20974: ARRAY
20975: PUSH
20976: LD_EXP 61
20980: PUSH
20981: LD_VAR 0 1
20985: ARRAY
20986: PUSH
20987: LD_VAR 0 4
20991: PUSH
20992: LD_INT 1
20994: PLUS
20995: ARRAY
20996: PUSH
20997: LD_INT 0
20999: PPUSH
21000: LD_INT 5
21002: PPUSH
21003: CALL_OW 12
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: LIST
21012: PPUSH
21013: CALL 41962 0 4
21017: ST_TO_ADDR
// p := p + 3 ;
21018: LD_ADDR_VAR 0 4
21022: PUSH
21023: LD_VAR 0 4
21027: PUSH
21028: LD_INT 3
21030: PLUS
21031: ST_TO_ADDR
// end ;
21032: GO 20892
21034: POP
21035: POP
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21041: LD_INT 0
21043: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21044: LD_ADDR_EXP 46
21048: PUSH
21049: LD_EXP 46
21053: PPUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: LD_INT 4
21061: PPUSH
21062: LD_VAR 0 2
21066: PPUSH
21067: CALL 41962 0 4
21071: ST_TO_ADDR
// end ;
21072: LD_VAR 0 3
21076: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21077: LD_INT 0
21079: PPUSH
// case nation of 1 , us :
21080: LD_VAR 0 2
21084: PUSH
21085: LD_INT 1
21087: DOUBLE
21088: EQUAL
21089: IFTRUE 21099
21091: LD_STRING us
21093: DOUBLE
21094: EQUAL
21095: IFTRUE 21099
21097: GO 21130
21099: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21100: LD_ADDR_EXP 46
21104: PUSH
21105: LD_EXP 46
21109: PPUSH
21110: LD_VAR 0 1
21114: PPUSH
21115: LD_INT 36
21117: PPUSH
21118: LD_VAR 0 3
21122: PPUSH
21123: CALL 41962 0 4
21127: ST_TO_ADDR
21128: GO 21181
21130: LD_INT 2
21132: DOUBLE
21133: EQUAL
21134: IFTRUE 21144
21136: LD_STRING ar
21138: DOUBLE
21139: EQUAL
21140: IFTRUE 21144
21142: GO 21180
21144: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21145: LD_ADDR_EXP 46
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: LD_INT 14
21157: PUSH
21158: LD_INT 2
21160: PUSH
21161: LD_INT 1
21163: PUSH
21164: LD_INT 31
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL 21186 0 2
21177: ST_TO_ADDR
21178: GO 21181
21180: POP
// end ;
21181: LD_VAR 0 4
21185: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21186: LD_INT 0
21188: PPUSH
21189: PPUSH
// for i = 1 to list do
21190: LD_ADDR_VAR 0 4
21194: PUSH
21195: DOUBLE
21196: LD_INT 1
21198: DEC
21199: ST_TO_ADDR
21200: LD_VAR 0 2
21204: PUSH
21205: FOR_TO
21206: IFFALSE 21256
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21208: LD_ADDR_EXP 51
21212: PUSH
21213: LD_EXP 51
21217: PPUSH
21218: LD_VAR 0 1
21222: PPUSH
21223: LD_EXP 51
21227: PUSH
21228: LD_VAR 0 1
21232: ARRAY
21233: PUSH
21234: LD_INT 1
21236: PLUS
21237: PPUSH
21238: LD_VAR 0 2
21242: PUSH
21243: LD_VAR 0 4
21247: ARRAY
21248: PPUSH
21249: CALL 31132 0 4
21253: ST_TO_ADDR
21254: GO 21205
21256: POP
21257: POP
// end ;
21258: LD_VAR 0 3
21262: RET
// export function MCS_GetVehicleList ( side ) ; begin
21263: LD_INT 0
21265: PPUSH
// result := MREG_ToConstruct [ side ] ;
21266: LD_ADDR_VAR 0 2
21270: PUSH
21271: LD_EXP 51
21275: PUSH
21276: LD_VAR 0 1
21280: ARRAY
21281: ST_TO_ADDR
// end ;
21282: LD_VAR 0 2
21286: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21287: LD_INT 0
21289: PPUSH
21290: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21291: LD_ADDR_EXP 58
21295: PUSH
21296: LD_EXP 58
21300: PPUSH
21301: LD_VAR 0 1
21305: PPUSH
21306: LD_VAR 0 2
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// end ;
21316: LD_VAR 0 3
21320: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21321: LD_INT 0
21323: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21324: LD_ADDR_EXP 37
21328: PUSH
21329: LD_EXP 37
21333: PPUSH
21334: LD_VAR 0 1
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// end ;
21349: LD_VAR 0 3
21353: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21354: LD_INT 0
21356: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21357: LD_ADDR_EXP 38
21361: PUSH
21362: LD_EXP 38
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: LD_VAR 0 2
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// end ;
21382: LD_VAR 0 3
21386: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21387: LD_INT 0
21389: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21390: LD_ADDR_EXP 60
21394: PUSH
21395: LD_EXP 60
21399: PPUSH
21400: LD_VAR 0 1
21404: PPUSH
21405: LD_INT 1
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: CALL 31132 0 4
21417: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21418: LD_ADDR_EXP 60
21422: PUSH
21423: LD_EXP 60
21427: PPUSH
21428: LD_VAR 0 1
21432: PPUSH
21433: LD_INT 2
21435: PPUSH
21436: LD_VAR 0 3
21440: PPUSH
21441: CALL 31132 0 4
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21451: LD_INT 0
21453: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21454: LD_ADDR_EXP 72
21458: PUSH
21459: LD_EXP 72
21463: PPUSH
21464: LD_INT 1
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21477: LD_ADDR_EXP 72
21481: PUSH
21482: LD_EXP 72
21486: PPUSH
21487: LD_INT 2
21489: PPUSH
21490: LD_VAR 0 2
21494: PPUSH
21495: CALL_OW 1
21499: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21500: LD_ADDR_EXP 72
21504: PUSH
21505: LD_EXP 72
21509: PPUSH
21510: LD_INT 3
21512: PPUSH
21513: LD_VAR 0 3
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// end ;
21523: LD_VAR 0 4
21527: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21528: LD_INT 0
21530: PPUSH
21531: PPUSH
21532: PPUSH
// if not side or not list then
21533: LD_VAR 0 1
21537: NOT
21538: PUSH
21539: LD_VAR 0 2
21543: NOT
21544: OR
21545: IFFALSE 21549
// exit ;
21547: GO 21717
// SetTech ( 20 , side , state_researched ) ;
21549: LD_INT 20
21551: PPUSH
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_INT 2
21559: PPUSH
21560: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21564: LD_ADDR_EXP 61
21568: PUSH
21569: LD_EXP 61
21573: PPUSH
21574: LD_VAR 0 1
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: CALL_OW 2
21588: ST_TO_ADDR
// p := 1 ;
21589: LD_ADDR_VAR 0 5
21593: PUSH
21594: LD_INT 1
21596: ST_TO_ADDR
// for i = 1 to list / 3 do
21597: LD_ADDR_VAR 0 4
21601: PUSH
21602: DOUBLE
21603: LD_INT 1
21605: DEC
21606: ST_TO_ADDR
21607: LD_VAR 0 2
21611: PUSH
21612: LD_INT 3
21614: DIVREAL
21615: PUSH
21616: FOR_TO
21617: IFFALSE 21715
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 5
21628: ARRAY
21629: PPUSH
21630: LD_VAR 0 2
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 1
21642: PLUS
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 2
21649: PUSH
21650: LD_VAR 0 5
21654: PUSH
21655: LD_INT 2
21657: PLUS
21658: ARRAY
21659: PPUSH
21660: CALL 22419 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21664: LD_VAR 0 2
21668: PUSH
21669: LD_VAR 0 5
21673: ARRAY
21674: PPUSH
21675: LD_VAR 0 2
21679: PUSH
21680: LD_VAR 0 5
21684: PUSH
21685: LD_INT 1
21687: PLUS
21688: ARRAY
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: CALL_OW 441
// p := p + 3 ;
21699: LD_ADDR_VAR 0 5
21703: PUSH
21704: LD_VAR 0 5
21708: PUSH
21709: LD_INT 3
21711: PLUS
21712: ST_TO_ADDR
// end ;
21713: GO 21616
21715: POP
21716: POP
// end ;
21717: LD_VAR 0 3
21721: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21722: LD_INT 0
21724: PPUSH
21725: PPUSH
// if nat = nation_arabian then
21726: LD_VAR 0 2
21730: PUSH
21731: LD_INT 2
21733: EQUAL
21734: IFFALSE 21740
// exit else
21736: GO 21812
21738: GO 21798
// if nat = nation_american then
21740: LD_VAR 0 2
21744: PUSH
21745: LD_INT 1
21747: EQUAL
21748: IFFALSE 21775
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21750: LD_ADDR_VAR 0 4
21754: PUSH
21755: LD_INT 4
21757: PUSH
21758: LD_INT 3
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 8
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: ST_TO_ADDR
21773: GO 21798
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21775: LD_ADDR_VAR 0 4
21779: PUSH
21780: LD_INT 24
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: LD_INT 1
21788: PUSH
21789: LD_INT 48
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21798: LD_VAR 0 1
21802: PPUSH
21803: LD_VAR 0 4
21807: PPUSH
21808: CALL 21186 0 2
// end ;
21812: LD_VAR 0 3
21816: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21817: LD_INT 0
21819: PPUSH
21820: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21821: LD_ADDR_EXP 63
21825: PUSH
21826: LD_EXP 63
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: LD_INT 1
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: CALL 31132 0 4
21848: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21849: LD_ADDR_EXP 64
21853: PUSH
21854: LD_EXP 64
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_INT 1
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: CALL 31132 0 4
21876: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21877: LD_ADDR_EXP 65
21881: PUSH
21882: LD_EXP 65
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: LD_INT 1
21894: PPUSH
21895: LD_VAR 0 3
21899: PPUSH
21900: CALL 31132 0 4
21904: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21905: LD_ADDR_EXP 66
21909: PUSH
21910: LD_EXP 66
21914: PPUSH
21915: LD_VAR 0 1
21919: PPUSH
21920: LD_INT 1
21922: PPUSH
21923: LD_VAR 0 5
21927: PPUSH
21928: CALL 31132 0 4
21932: ST_TO_ADDR
// while squad do
21933: LD_VAR 0 5
21937: IFFALSE 22030
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21939: LD_VAR 0 1
21943: PPUSH
21944: LD_VAR 0 5
21948: PUSH
21949: LD_INT 1
21951: ARRAY
21952: PUSH
21953: LD_VAR 0 5
21957: PUSH
21958: LD_INT 2
21960: ARRAY
21961: PUSH
21962: LD_VAR 0 5
21966: PUSH
21967: LD_INT 3
21969: ARRAY
21970: PUSH
21971: LD_VAR 0 5
21975: PUSH
21976: LD_INT 4
21978: ARRAY
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: PPUSH
21986: CALL 21186 0 2
// for i = 1 to 4 do
21990: LD_ADDR_VAR 0 7
21994: PUSH
21995: DOUBLE
21996: LD_INT 1
21998: DEC
21999: ST_TO_ADDR
22000: LD_INT 4
22002: PUSH
22003: FOR_TO
22004: IFFALSE 22026
// squad := Delete ( squad , 1 ) ;
22006: LD_ADDR_VAR 0 5
22010: PUSH
22011: LD_VAR 0 5
22015: PPUSH
22016: LD_INT 1
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
22024: GO 22003
22026: POP
22027: POP
// end ;
22028: GO 21933
// end ;
22030: LD_VAR 0 6
22034: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22035: LD_INT 0
22037: PPUSH
22038: PPUSH
// for i = 1 to squad do
22039: LD_ADDR_VAR 0 4
22043: PUSH
22044: DOUBLE
22045: LD_INT 1
22047: DEC
22048: ST_TO_ADDR
22049: LD_VAR 0 2
22053: PUSH
22054: FOR_TO
22055: IFFALSE 22105
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22057: LD_ADDR_EXP 69
22061: PUSH
22062: LD_EXP 69
22066: PPUSH
22067: LD_VAR 0 1
22071: PPUSH
22072: LD_EXP 69
22076: PUSH
22077: LD_VAR 0 1
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: PLUS
22086: PPUSH
22087: LD_VAR 0 2
22091: PUSH
22092: LD_VAR 0 4
22096: ARRAY
22097: PPUSH
22098: CALL 31132 0 4
22102: ST_TO_ADDR
22103: GO 22054
22105: POP
22106: POP
// while squad do
22107: LD_VAR 0 2
22111: IFFALSE 22204
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_VAR 0 2
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: PUSH
22127: LD_VAR 0 2
22131: PUSH
22132: LD_INT 2
22134: ARRAY
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 3
22143: ARRAY
22144: PUSH
22145: LD_VAR 0 2
22149: PUSH
22150: LD_INT 4
22152: ARRAY
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: LIST
22158: LIST
22159: PPUSH
22160: CALL 21186 0 2
// for i = 1 to 4 do
22164: LD_ADDR_VAR 0 4
22168: PUSH
22169: DOUBLE
22170: LD_INT 1
22172: DEC
22173: ST_TO_ADDR
22174: LD_INT 4
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22200
// squad := Delete ( squad , 1 ) ;
22180: LD_ADDR_VAR 0 2
22184: PUSH
22185: LD_VAR 0 2
22189: PPUSH
22190: LD_INT 1
22192: PPUSH
22193: CALL_OW 3
22197: ST_TO_ADDR
22198: GO 22177
22200: POP
22201: POP
// end ;
22202: GO 22107
// end ;
22204: LD_VAR 0 3
22208: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22209: LD_INT 0
22211: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22212: LD_ADDR_EXP 62
22216: PUSH
22217: LD_EXP 62
22221: PPUSH
22222: LD_VAR 0 1
22226: PPUSH
22227: LD_INT 1
22229: PPUSH
22230: LD_VAR 0 2
22234: PPUSH
22235: CALL 31132 0 4
22239: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22240: LD_ADDR_EXP 62
22244: PUSH
22245: LD_EXP 62
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: LD_INT 2
22257: PPUSH
22258: LD_VAR 0 3
22262: PPUSH
22263: CALL 31132 0 4
22267: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22268: LD_ADDR_EXP 62
22272: PUSH
22273: LD_EXP 62
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 3
22285: PPUSH
22286: LD_VAR 0 4
22290: PPUSH
22291: CALL 31132 0 4
22295: ST_TO_ADDR
// end ; end_of_file
22296: LD_VAR 0 5
22300: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22301: LD_INT 0
22303: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22304: LD_ADDR_EXP 42
22308: PUSH
22309: LD_EXP 42
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: LD_VAR 0 2
22326: PPUSH
22327: CALL 31132 0 4
22331: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22332: LD_VAR 0 1
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL 11802 0 2
22343: PUSH
22344: LD_INT 1
22346: ARRAY
22347: PPUSH
22348: CALL_OW 248
22352: PUSH
22353: LD_INT 1
22355: EQUAL
22356: IFFALSE 22387
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22358: LD_VAR 0 1
22362: PPUSH
22363: LD_INT 4
22365: PUSH
22366: LD_INT 1
22368: PUSH
22369: LD_INT 1
22371: PUSH
22372: LD_INT 14
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: PPUSH
22381: CALL 21186 0 2
22385: GO 22414
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22387: LD_VAR 0 1
22391: PPUSH
22392: LD_INT 24
22394: PUSH
22395: LD_INT 1
22397: PUSH
22398: LD_INT 1
22400: PUSH
22401: LD_INT 53
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: PPUSH
22410: CALL 21186 0 2
// end ;
22414: LD_VAR 0 3
22418: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22419: LD_INT 0
22421: PPUSH
// CreateDepositXY ( x , y , t ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: LD_VAR 0 3
22436: PPUSH
22437: CALL_OW 62
// end ;
22441: LD_VAR 0 4
22445: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22446: LD_INT 0
22448: PPUSH
22449: PPUSH
// c := 1 ;
22450: LD_ADDR_VAR 0 5
22454: PUSH
22455: LD_INT 1
22457: ST_TO_ADDR
// case color of red :
22458: LD_VAR 0 3
22462: PUSH
22463: LD_STRING red
22465: DOUBLE
22466: EQUAL
22467: IFTRUE 22471
22469: GO 22482
22471: POP
// c = 1 ; dark-green :
22472: LD_ADDR_VAR 0 5
22476: PUSH
22477: LD_INT 1
22479: ST_TO_ADDR
22480: GO 22768
22482: LD_STRING dark-green
22484: DOUBLE
22485: EQUAL
22486: IFTRUE 22490
22488: GO 22501
22490: POP
// c = 2 ; purple :
22491: LD_ADDR_VAR 0 5
22495: PUSH
22496: LD_INT 2
22498: ST_TO_ADDR
22499: GO 22768
22501: LD_STRING purple
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 22520
22509: POP
// c = 3 ; aqua :
22510: LD_ADDR_VAR 0 5
22514: PUSH
22515: LD_INT 3
22517: ST_TO_ADDR
22518: GO 22768
22520: LD_STRING aqua
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22539
22528: POP
// c = 4 ; grey :
22529: LD_ADDR_VAR 0 5
22533: PUSH
22534: LD_INT 4
22536: ST_TO_ADDR
22537: GO 22768
22539: LD_STRING grey
22541: DOUBLE
22542: EQUAL
22543: IFTRUE 22547
22545: GO 22558
22547: POP
// c = 5 ; lime :
22548: LD_ADDR_VAR 0 5
22552: PUSH
22553: LD_INT 5
22555: ST_TO_ADDR
22556: GO 22768
22558: LD_STRING lime
22560: DOUBLE
22561: EQUAL
22562: IFTRUE 22566
22564: GO 22577
22566: POP
// c = 6 ; tan :
22567: LD_ADDR_VAR 0 5
22571: PUSH
22572: LD_INT 6
22574: ST_TO_ADDR
22575: GO 22768
22577: LD_STRING tan
22579: DOUBLE
22580: EQUAL
22581: IFTRUE 22585
22583: GO 22596
22585: POP
// c = 7 ; pink :
22586: LD_ADDR_VAR 0 5
22590: PUSH
22591: LD_INT 7
22593: ST_TO_ADDR
22594: GO 22768
22596: LD_STRING pink
22598: DOUBLE
22599: EQUAL
22600: IFTRUE 22604
22602: GO 22615
22604: POP
// c = 8 ; green :
22605: LD_ADDR_VAR 0 5
22609: PUSH
22610: LD_INT 8
22612: ST_TO_ADDR
22613: GO 22768
22615: LD_STRING green
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22634
22623: POP
// c = 9 ; blue :
22624: LD_ADDR_VAR 0 5
22628: PUSH
22629: LD_INT 9
22631: ST_TO_ADDR
22632: GO 22768
22634: LD_STRING blue
22636: DOUBLE
22637: EQUAL
22638: IFTRUE 22642
22640: GO 22653
22642: POP
// c = 10 ; yellow :
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 10
22650: ST_TO_ADDR
22651: GO 22768
22653: LD_STRING yellow
22655: DOUBLE
22656: EQUAL
22657: IFTRUE 22661
22659: GO 22672
22661: POP
// c = 11 ; brown :
22662: LD_ADDR_VAR 0 5
22666: PUSH
22667: LD_INT 11
22669: ST_TO_ADDR
22670: GO 22768
22672: LD_STRING brown
22674: DOUBLE
22675: EQUAL
22676: IFTRUE 22680
22678: GO 22691
22680: POP
// c = 12 ; black :
22681: LD_ADDR_VAR 0 5
22685: PUSH
22686: LD_INT 12
22688: ST_TO_ADDR
22689: GO 22768
22691: LD_STRING black
22693: DOUBLE
22694: EQUAL
22695: IFTRUE 22699
22697: GO 22710
22699: POP
// c = 13 ; aqua2 :
22700: LD_ADDR_VAR 0 5
22704: PUSH
22705: LD_INT 13
22707: ST_TO_ADDR
22708: GO 22768
22710: LD_STRING aqua2
22712: DOUBLE
22713: EQUAL
22714: IFTRUE 22718
22716: GO 22729
22718: POP
// c = 14 ; orange :
22719: LD_ADDR_VAR 0 5
22723: PUSH
22724: LD_INT 14
22726: ST_TO_ADDR
22727: GO 22768
22729: LD_STRING orange
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22737
22735: GO 22748
22737: POP
// c = 15 ; white :
22738: LD_ADDR_VAR 0 5
22742: PUSH
22743: LD_INT 15
22745: ST_TO_ADDR
22746: GO 22768
22748: LD_STRING white
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22767
22756: POP
// c = 16 ; end ;
22757: LD_ADDR_VAR 0 5
22761: PUSH
22762: LD_INT 16
22764: ST_TO_ADDR
22765: GO 22768
22767: POP
// if HexInfo ( x , y ) = 0 then
22768: LD_VAR 0 1
22772: PPUSH
22773: LD_VAR 0 2
22777: PPUSH
22778: CALL_OW 428
22782: PUSH
22783: LD_INT 0
22785: EQUAL
22786: IFFALSE 22810
// PlaceEnvironment ( x , y , 58 , c ) ;
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: LD_INT 58
22800: PPUSH
22801: LD_VAR 0 5
22805: PPUSH
22806: CALL_OW 349
// end ;
22810: LD_VAR 0 4
22814: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22815: LD_INT 0
22817: PPUSH
// RemoveEnvironment ( x , y ) ;
22818: LD_VAR 0 1
22822: PPUSH
22823: LD_VAR 0 2
22827: PPUSH
22828: CALL_OW 347
// end ;
22832: LD_VAR 0 3
22836: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22837: LD_INT 0
22839: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22840: LD_ADDR_VAR 0 5
22844: PUSH
22845: LD_INT 81
22847: PUSH
22848: LD_VAR 0 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 92
22859: PUSH
22860: LD_VAR 0 2
22864: PUSH
22865: LD_VAR 0 3
22869: PUSH
22870: LD_VAR 0 4
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: PPUSH
22885: CALL_OW 69
22889: ST_TO_ADDR
// end ;
22890: LD_VAR 0 5
22894: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22895: LD_INT 0
22897: PPUSH
22898: PPUSH
22899: PPUSH
22900: PPUSH
22901: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_INT 81
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 255
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PPUSH
22924: CALL_OW 69
22928: PPUSH
22929: LD_VAR 0 1
22933: PPUSH
22934: CALL_OW 74
22938: PPUSH
22939: CALL_OW 119
// dir := GetDir ( un ) ;
22943: LD_ADDR_VAR 0 4
22947: PUSH
22948: LD_VAR 0 1
22952: PPUSH
22953: CALL_OW 254
22957: ST_TO_ADDR
// dir := dir - 3 ;
22958: LD_ADDR_VAR 0 4
22962: PUSH
22963: LD_VAR 0 4
22967: PUSH
22968: LD_INT 3
22970: MINUS
22971: ST_TO_ADDR
// if dir < 0 then
22972: LD_VAR 0 4
22976: PUSH
22977: LD_INT 0
22979: LESS
22980: IFFALSE 22996
// dir := dir + 6 ;
22982: LD_ADDR_VAR 0 4
22986: PUSH
22987: LD_VAR 0 4
22991: PUSH
22992: LD_INT 6
22994: PLUS
22995: ST_TO_ADDR
// while true do
22996: LD_INT 1
22998: IFFALSE 23495
// begin coord_dist := 3 ;
23000: LD_ADDR_VAR 0 3
23004: PUSH
23005: LD_INT 3
23007: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23008: LD_ADDR_VAR 0 5
23012: PUSH
23013: LD_VAR 0 1
23017: PPUSH
23018: CALL_OW 250
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: CALL_OW 272
23037: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: CALL_OW 251
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_VAR 0 3
23062: PPUSH
23063: CALL_OW 273
23067: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 255
23077: PPUSH
23078: LD_VAR 0 1
23082: PPUSH
23083: CALL_OW 250
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 251
23097: PPUSH
23098: LD_INT 14
23100: PPUSH
23101: CALL 22837 0 4
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 351
23120: OR
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 6
23131: PPUSH
23132: CALL_OW 488
23136: PUSH
23137: LD_INT 0
23139: EQUAL
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PPUSH
23147: LD_VAR 0 6
23151: PPUSH
23152: CALL_OW 546
23156: PUSH
23157: LD_INT 1
23159: EQUAL
23160: OR
23161: PUSH
23162: LD_VAR 0 5
23166: PPUSH
23167: LD_VAR 0 6
23171: PPUSH
23172: CALL_OW 428
23176: PUSH
23177: LD_INT 0
23179: NONEQUAL
23180: OR
23181: IFFALSE 23409
// begin repeat begin Wait ( 0 0$0.3 ) ;
23183: LD_INT 10
23185: PPUSH
23186: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23190: LD_ADDR_VAR 0 3
23194: PUSH
23195: LD_VAR 0 3
23199: PUSH
23200: LD_INT 1
23202: PLUS
23203: ST_TO_ADDR
// dir := dir + 1 ;
23204: LD_ADDR_VAR 0 4
23208: PUSH
23209: LD_VAR 0 4
23213: PUSH
23214: LD_INT 1
23216: PLUS
23217: ST_TO_ADDR
// if dir > 5 then
23218: LD_VAR 0 4
23222: PUSH
23223: LD_INT 5
23225: GREATER
23226: IFFALSE 23236
// dir = 0 ;
23228: LD_ADDR_VAR 0 4
23232: PUSH
23233: LD_INT 0
23235: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23236: LD_ADDR_VAR 0 5
23240: PUSH
23241: LD_VAR 0 1
23245: PPUSH
23246: CALL_OW 250
23250: PPUSH
23251: LD_VAR 0 4
23255: PPUSH
23256: LD_VAR 0 3
23260: PPUSH
23261: CALL_OW 272
23265: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23266: LD_ADDR_VAR 0 6
23270: PUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: CALL_OW 251
23280: PPUSH
23281: LD_VAR 0 4
23285: PPUSH
23286: LD_VAR 0 3
23290: PPUSH
23291: CALL_OW 273
23295: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 255
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 250
23315: PPUSH
23316: LD_VAR 0 1
23320: PPUSH
23321: CALL_OW 251
23325: PPUSH
23326: LD_INT 14
23328: PPUSH
23329: CALL 22837 0 4
23333: NOT
23334: PUSH
23335: LD_VAR 0 5
23339: PPUSH
23340: LD_VAR 0 6
23344: PPUSH
23345: CALL_OW 351
23349: NOT
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 488
23366: AND
23367: PUSH
23368: LD_VAR 0 5
23372: PPUSH
23373: LD_VAR 0 6
23377: PPUSH
23378: CALL_OW 546
23382: PUSH
23383: LD_INT 0
23385: EQUAL
23386: AND
23387: PUSH
23388: LD_VAR 0 5
23392: PPUSH
23393: LD_VAR 0 6
23397: PPUSH
23398: CALL_OW 428
23402: PUSH
23403: LD_INT 0
23405: EQUAL
23406: AND
23407: IFFALSE 23183
// end ; ComMoveXY ( un , x , y ) ;
23409: LD_VAR 0 1
23413: PPUSH
23414: LD_VAR 0 5
23418: PPUSH
23419: LD_VAR 0 6
23423: PPUSH
23424: CALL_OW 111
// Wait ( 0 0$1 ) ;
23428: LD_INT 35
23430: PPUSH
23431: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23435: LD_VAR 0 1
23439: PPUSH
23440: LD_INT 81
23442: PUSH
23443: LD_VAR 0 1
23447: PPUSH
23448: CALL_OW 255
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL_OW 69
23461: PPUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: CALL_OW 74
23471: PPUSH
23472: CALL_OW 296
23476: PUSH
23477: LD_INT 14
23479: GREATEREQUAL
23480: IFFALSE 23493
// begin ComStop ( un ) ;
23482: LD_VAR 0 1
23486: PPUSH
23487: CALL_OW 141
// break ;
23491: GO 23495
// end ; end ;
23493: GO 22996
// end ;
23495: LD_VAR 0 2
23499: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23500: LD_INT 0
23502: PPUSH
23503: PPUSH
23504: PPUSH
23505: PPUSH
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// x := GetX ( unit ) ;
23510: LD_ADDR_VAR 0 3
23514: PUSH
23515: LD_VAR 0 1
23519: PPUSH
23520: CALL_OW 250
23524: ST_TO_ADDR
// y := GetY ( unit ) ;
23525: LD_ADDR_VAR 0 4
23529: PUSH
23530: LD_VAR 0 1
23534: PPUSH
23535: CALL_OW 251
23539: ST_TO_ADDR
// i := 0 ;
23540: LD_ADDR_VAR 0 8
23544: PUSH
23545: LD_INT 0
23547: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23548: LD_VAR 0 1
23552: PPUSH
23553: LD_INT 81
23555: PUSH
23556: LD_VAR 0 1
23560: PPUSH
23561: CALL_OW 255
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PPUSH
23570: CALL_OW 69
23574: PPUSH
23575: LD_VAR 0 1
23579: PPUSH
23580: CALL_OW 74
23584: PPUSH
23585: CALL_OW 119
// dir := GetDir ( unit ) ;
23589: LD_ADDR_VAR 0 7
23593: PUSH
23594: LD_VAR 0 1
23598: PPUSH
23599: CALL_OW 254
23603: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23604: LD_ADDR_VAR 0 9
23608: PUSH
23609: LD_INT 0
23611: PPUSH
23612: LD_INT 1
23614: PPUSH
23615: CALL_OW 12
23619: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23620: LD_INT 10
23622: PPUSH
23623: CALL_OW 67
// if mode then
23627: LD_VAR 0 9
23631: IFFALSE 23649
// dir := dir + 1 else
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: PLUS
23646: ST_TO_ADDR
23647: GO 23663
// dir := dir - 1 ;
23649: LD_ADDR_VAR 0 7
23653: PUSH
23654: LD_VAR 0 7
23658: PUSH
23659: LD_INT 1
23661: MINUS
23662: ST_TO_ADDR
// if ( dir < 0 ) then
23663: LD_VAR 0 7
23667: PUSH
23668: LD_INT 0
23670: LESS
23671: IFFALSE 23681
// dir := 5 ;
23673: LD_ADDR_VAR 0 7
23677: PUSH
23678: LD_INT 5
23680: ST_TO_ADDR
// if ( dir > 5 ) then
23681: LD_VAR 0 7
23685: PUSH
23686: LD_INT 5
23688: GREATER
23689: IFFALSE 23699
// dir := 0 ;
23691: LD_ADDR_VAR 0 7
23695: PUSH
23696: LD_INT 0
23698: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23699: LD_ADDR_VAR 0 5
23703: PUSH
23704: LD_VAR 0 3
23708: PPUSH
23709: LD_VAR 0 7
23713: PPUSH
23714: LD_INT 4
23716: PPUSH
23717: CALL_OW 272
23721: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23722: LD_ADDR_VAR 0 6
23726: PUSH
23727: LD_VAR 0 4
23731: PPUSH
23732: LD_VAR 0 7
23736: PPUSH
23737: LD_INT 4
23739: PPUSH
23740: CALL_OW 273
23744: ST_TO_ADDR
// i := i + 1 ;
23745: LD_ADDR_VAR 0 8
23749: PUSH
23750: LD_VAR 0 8
23754: PUSH
23755: LD_INT 1
23757: PLUS
23758: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23759: LD_VAR 0 1
23763: PPUSH
23764: CALL_OW 255
23768: PPUSH
23769: LD_VAR 0 5
23773: PPUSH
23774: LD_VAR 0 6
23778: PPUSH
23779: LD_INT 14
23781: PPUSH
23782: CALL 22837 0 4
23786: PUSH
23787: LD_INT 0
23789: EQUAL
23790: PUSH
23791: LD_VAR 0 5
23795: PPUSH
23796: LD_VAR 0 6
23800: PPUSH
23801: CALL_OW 546
23805: PUSH
23806: LD_INT 0
23808: EQUAL
23809: AND
23810: PUSH
23811: LD_VAR 0 5
23815: PPUSH
23816: LD_VAR 0 6
23820: PPUSH
23821: CALL_OW 428
23825: PUSH
23826: LD_INT 0
23828: EQUAL
23829: AND
23830: IFFALSE 23834
// break ;
23832: GO 23844
// end until i > 4 ;
23834: LD_VAR 0 8
23838: PUSH
23839: LD_INT 4
23841: GREATER
23842: IFFALSE 23620
// if x2 and y2 then
23844: LD_VAR 0 5
23848: PUSH
23849: LD_VAR 0 6
23853: AND
23854: IFFALSE 23877
// result := [ x2 , y2 ] else
23856: LD_ADDR_VAR 0 2
23860: PUSH
23861: LD_VAR 0 5
23865: PUSH
23866: LD_VAR 0 6
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 23906
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23877: LD_ADDR_VAR 0 2
23881: PUSH
23882: LD_VAR 0 1
23886: PPUSH
23887: CALL_OW 250
23891: PUSH
23892: LD_VAR 0 1
23896: PPUSH
23897: CALL_OW 251
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: ST_TO_ADDR
// end ;
23906: LD_VAR 0 2
23910: RET
// export function MCT_Hex ( x , y ) ; begin
23911: LD_INT 0
23913: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23914: LD_ADDR_VAR 0 3
23918: PUSH
23919: LD_VAR 0 1
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: CALL_OW 546
23933: PUSH
23934: LD_VAR 0 1
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: CALL_OW 428
23948: PUSH
23949: EMPTY
23950: LIST
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: ST_TO_ADDR
// end ;
23956: LD_VAR 0 3
23960: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23961: LD_INT 0
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23976: LD_ADDR_VAR 0 10
23980: PUSH
23981: LD_EXP 60
23985: PUSH
23986: LD_VAR 0 1
23990: ARRAY
23991: PUSH
23992: LD_INT 1
23994: ARRAY
23995: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23996: LD_ADDR_VAR 0 11
24000: PUSH
24001: LD_EXP 60
24005: PUSH
24006: LD_VAR 0 1
24010: ARRAY
24011: PUSH
24012: LD_INT 2
24014: ARRAY
24015: ST_TO_ADDR
// collectors := [ ] ;
24016: LD_ADDR_VAR 0 12
24020: PUSH
24021: EMPTY
24022: ST_TO_ADDR
// is_cargo := false ;
24023: LD_ADDR_VAR 0 13
24027: PUSH
24028: LD_INT 0
24030: ST_TO_ADDR
// if isTest then
24031: LD_EXP 1
24035: IFFALSE 24041
// TimerStart ( ) ;
24037: CALL_OW 548
// if MCF_Cargo ( side ) then
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12018 0 1
24050: IFFALSE 24077
// begin collectors := MCF_Cargo ( side ) ;
24052: LD_ADDR_VAR 0 12
24056: PUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: CALL 12018 0 1
24066: ST_TO_ADDR
// is_cargo := true ;
24067: LD_ADDR_VAR 0 13
24071: PUSH
24072: LD_INT 1
24074: ST_TO_ADDR
// end else
24075: GO 24226
// begin if MCF_ApeSpec ( side , engineer ) then
24077: LD_VAR 0 1
24081: PPUSH
24082: LD_STRING engineer
24084: PPUSH
24085: CALL 12164 0 2
24089: IFFALSE 24109
// collectors := MCF_ApeSpec ( side , engineer ) ;
24091: LD_ADDR_VAR 0 12
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_STRING engineer
24103: PPUSH
24104: CALL 12164 0 2
24108: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24109: LD_VAR 0 1
24113: PPUSH
24114: LD_INT 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL 11750 0 3
24123: IFFALSE 24226
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24125: LD_ADDR_VAR 0 7
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: EMPTY
24139: PPUSH
24140: CALL 11750 0 3
24144: ST_TO_ADDR
// if z > 5 then
24145: LD_VAR 0 7
24149: PUSH
24150: LD_INT 5
24152: GREATER
24153: IFFALSE 24165
// t1 := 5 else
24155: LD_ADDR_VAR 0 8
24159: PUSH
24160: LD_INT 5
24162: ST_TO_ADDR
24163: GO 24175
// t1 := z ;
24165: LD_ADDR_VAR 0 8
24169: PUSH
24170: LD_VAR 0 7
24174: ST_TO_ADDR
// for t2 = 1 to t1 do
24175: LD_ADDR_VAR 0 9
24179: PUSH
24180: DOUBLE
24181: LD_INT 1
24183: DEC
24184: ST_TO_ADDR
24185: LD_VAR 0 8
24189: PUSH
24190: FOR_TO
24191: IFFALSE 24224
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24193: LD_ADDR_VAR 0 12
24197: PUSH
24198: LD_VAR 0 12
24202: PPUSH
24203: LD_INT 1
24205: PPUSH
24206: LD_VAR 0 7
24210: PUSH
24211: LD_VAR 0 9
24215: ARRAY
24216: PPUSH
24217: CALL_OW 2
24221: ST_TO_ADDR
24222: GO 24190
24224: POP
24225: POP
// end ; end ; if not mode then
24226: LD_VAR 0 10
24230: NOT
24231: IFFALSE 24237
// exit else
24233: GO 24496
24235: GO 24496
// begin if collectors then
24237: LD_VAR 0 12
24241: IFFALSE 24496
// for i in areas do
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 11
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24494
// if GetListOfCratesInArea ( i ) then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: IFFALSE 24492
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24267: LD_ADDR_VAR 0 5
24271: PUSH
24272: LD_VAR 0 3
24276: PPUSH
24277: CALL_OW 435
24281: PUSH
24282: LD_INT 1
24284: ARRAY
24285: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24286: LD_ADDR_VAR 0 6
24290: PUSH
24291: LD_VAR 0 3
24295: PPUSH
24296: CALL_OW 435
24300: PUSH
24301: LD_INT 2
24303: ARRAY
24304: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24305: LD_VAR 0 13
24309: PUSH
24310: LD_VAR 0 12
24314: PUSH
24315: LD_INT 1
24317: ARRAY
24318: PPUSH
24319: CALL_OW 110
24323: PUSH
24324: LD_INT 0
24326: EQUAL
24327: AND
24328: IFFALSE 24390
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24330: LD_VAR 0 12
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: PPUSH
24354: CALL_OW 110
24358: PUSH
24359: LD_INT 0
24361: EQUAL
24362: AND
24363: IFFALSE 24388
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24365: LD_VAR 0 12
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: PPUSH
24374: LD_VAR 0 5
24378: PPUSH
24379: LD_VAR 0 6
24383: PPUSH
24384: CALL_OW 117
// end ; end else
24388: GO 24476
// begin for j = 1 to collectors do
24390: LD_ADDR_VAR 0 4
24394: PUSH
24395: DOUBLE
24396: LD_INT 1
24398: DEC
24399: ST_TO_ADDR
24400: LD_VAR 0 12
24404: PUSH
24405: FOR_TO
24406: IFFALSE 24474
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24408: LD_VAR 0 12
24412: PUSH
24413: LD_VAR 0 4
24417: ARRAY
24418: PPUSH
24419: CALL_OW 314
24423: NOT
24424: PUSH
24425: LD_VAR 0 12
24429: PUSH
24430: LD_VAR 0 4
24434: ARRAY
24435: PPUSH
24436: CALL_OW 110
24440: PUSH
24441: LD_INT 0
24443: EQUAL
24444: AND
24445: IFFALSE 24472
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24447: LD_VAR 0 12
24451: PUSH
24452: LD_VAR 0 4
24456: ARRAY
24457: PPUSH
24458: LD_VAR 0 5
24462: PPUSH
24463: LD_VAR 0 6
24467: PPUSH
24468: CALL 24867 0 3
// end ;
24472: GO 24405
24474: POP
24475: POP
// end ; if isTest then
24476: LD_EXP 1
24480: IFFALSE 24492
// begin debug_time := TimerEnd ( ) ;
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: CALL_OW 549
24491: ST_TO_ADDR
// end ; end ;
24492: GO 24253
24494: POP
24495: POP
// end ; end ;
24496: LD_VAR 0 2
24500: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24501: LD_INT 0
24503: PPUSH
24504: PPUSH
24505: PPUSH
24506: PPUSH
24507: PPUSH
24508: PPUSH
// if not area then
24509: LD_VAR 0 1
24513: NOT
24514: IFFALSE 24520
// exit else
24516: GO 24782
24518: GO 24782
// if tick mod interval = 0 and Prob ( percent ) then
24520: LD_OWVAR 1
24524: PUSH
24525: LD_VAR 0 4
24529: MOD
24530: PUSH
24531: LD_INT 0
24533: EQUAL
24534: PUSH
24535: LD_VAR 0 3
24539: PPUSH
24540: CALL_OW 13
24544: AND
24545: IFFALSE 24782
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24547: LD_VAR 0 1
24551: PPUSH
24552: CALL_OW 435
24556: PUSH
24557: LD_VAR 0 5
24561: LESS
24562: PUSH
24563: LD_VAR 0 5
24567: PUSH
24568: LD_INT 0
24570: EQUAL
24571: OR
24572: IFFALSE 24782
// begin Randomize ;
24574: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24578: LD_ADDR_VAR 0 7
24582: PUSH
24583: LD_INT 1
24585: PPUSH
24586: LD_VAR 0 2
24590: PPUSH
24591: CALL_OW 12
24595: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL_OW 517
24613: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24614: LD_ADDR_VAR 0 8
24618: PUSH
24619: LD_INT 1
24621: PPUSH
24622: LD_VAR 0 9
24626: PUSH
24627: LD_INT 1
24629: ARRAY
24630: PPUSH
24631: CALL_OW 12
24635: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24636: LD_VAR 0 9
24640: PUSH
24641: LD_INT 1
24643: ARRAY
24644: PUSH
24645: LD_VAR 0 8
24649: ARRAY
24650: PPUSH
24651: LD_VAR 0 9
24655: PUSH
24656: LD_INT 2
24658: ARRAY
24659: PUSH
24660: LD_VAR 0 8
24664: ARRAY
24665: PPUSH
24666: CALL_OW 428
24670: PUSH
24671: LD_INT 0
24673: GREATER
24674: PUSH
24675: LD_VAR 0 9
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: PUSH
24684: LD_VAR 0 8
24688: ARRAY
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 2
24697: ARRAY
24698: PUSH
24699: LD_VAR 0 8
24703: ARRAY
24704: PPUSH
24705: CALL_OW 284
24709: PUSH
24710: LD_INT 0
24712: GREATER
24713: AND
24714: IFFALSE 24740
// c := Rand ( 1 , tmp [ 1 ] ) ;
24716: LD_ADDR_VAR 0 8
24720: PUSH
24721: LD_INT 1
24723: PPUSH
24724: LD_VAR 0 9
24728: PUSH
24729: LD_INT 1
24731: ARRAY
24732: PPUSH
24733: CALL_OW 12
24737: ST_TO_ADDR
24738: GO 24636
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24740: LD_VAR 0 7
24744: PPUSH
24745: LD_VAR 0 9
24749: PUSH
24750: LD_INT 1
24752: ARRAY
24753: PUSH
24754: LD_VAR 0 8
24758: ARRAY
24759: PPUSH
24760: LD_VAR 0 9
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PUSH
24769: LD_VAR 0 8
24773: ARRAY
24774: PPUSH
24775: LD_INT 1
24777: PPUSH
24778: CALL_OW 54
// end ; end ; end ;
24782: LD_VAR 0 6
24786: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
// if not MREG_Crates then
24791: LD_EXP 34
24795: NOT
24796: IFFALSE 24800
// exit ;
24798: GO 24862
// for i = MREG_Crates downto 1 do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: DOUBLE
24806: LD_EXP 34
24810: INC
24811: ST_TO_ADDR
24812: LD_INT 1
24814: PUSH
24815: FOR_DOWNTO
24816: IFFALSE 24860
// if MREG_Crates [ i ] [ 3 ] = 0 then
24818: LD_EXP 34
24822: PUSH
24823: LD_VAR 0 2
24827: ARRAY
24828: PUSH
24829: LD_INT 3
24831: ARRAY
24832: PUSH
24833: LD_INT 0
24835: EQUAL
24836: IFFALSE 24858
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24838: LD_ADDR_EXP 34
24842: PUSH
24843: LD_EXP 34
24847: PPUSH
24848: LD_VAR 0 2
24852: PPUSH
24853: CALL_OW 3
24857: ST_TO_ADDR
24858: GO 24815
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 1
24866: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
24871: PPUSH
24872: PPUSH
// if not unit then
24873: LD_VAR 0 1
24877: NOT
24878: IFFALSE 24882
// exit ;
24880: GO 25017
// if HasTask ( unit ) or not CanCarry ( unit ) then
24882: LD_VAR 0 1
24886: PPUSH
24887: CALL_OW 314
24891: PUSH
24892: LD_VAR 0 1
24896: PPUSH
24897: CALL_OW 280
24901: NOT
24902: OR
24903: IFFALSE 24907
// exit ;
24905: GO 25017
// side := GetSide ( unit ) ;
24907: LD_ADDR_VAR 0 6
24911: PUSH
24912: LD_VAR 0 1
24916: PPUSH
24917: CALL_OW 255
24921: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24922: LD_ADDR_VAR 0 7
24926: PUSH
24927: LD_VAR 0 6
24931: PPUSH
24932: LD_INT 30
24934: PUSH
24935: LD_INT 1
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PPUSH
24942: CALL 11667 0 2
24946: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24947: LD_VAR 0 1
24951: PPUSH
24952: CALL_OW 281
24956: PUSH
24957: LD_VAR 0 7
24961: NOT
24962: OR
24963: IFFALSE 24969
// exit else
24965: GO 25017
24967: GO 25017
// if GetResourceAmountXY ( x , y ) then
24969: LD_VAR 0 2
24973: PPUSH
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 284
24983: IFFALSE 25015
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24985: LD_VAR 0 1
24989: PPUSH
24990: LD_VAR 0 2
24994: PPUSH
24995: LD_VAR 0 3
24999: PPUSH
25000: LD_VAR 0 7
25004: PUSH
25005: LD_INT 1
25007: ARRAY
25008: PPUSH
25009: CALL 32063 0 4
// end else
25013: GO 25017
// exit ;
25015: GO 25017
// end ;
25017: LD_VAR 0 4
25021: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25022: LD_INT 0
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
// result := [ ] ;
25029: LD_ADDR_VAR 0 2
25033: PUSH
25034: EMPTY
25035: ST_TO_ADDR
// p := 1 ;
25036: LD_ADDR_VAR 0 4
25040: PUSH
25041: LD_INT 1
25043: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25044: LD_ADDR_VAR 0 3
25048: PUSH
25049: DOUBLE
25050: LD_INT 1
25052: DEC
25053: ST_TO_ADDR
25054: LD_EXP 63
25058: PUSH
25059: LD_VAR 0 1
25063: ARRAY
25064: PUSH
25065: LD_INT 1
25067: ARRAY
25068: PUSH
25069: LD_INT 2
25071: DIVREAL
25072: PUSH
25073: FOR_TO
25074: IFFALSE 25198
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25076: LD_ADDR_VAR 0 5
25080: PUSH
25081: LD_INT 81
25083: PUSH
25084: LD_VAR 0 1
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 92
25095: PUSH
25096: LD_EXP 63
25100: PUSH
25101: LD_VAR 0 1
25105: ARRAY
25106: PUSH
25107: LD_INT 1
25109: ARRAY
25110: PUSH
25111: LD_VAR 0 4
25115: ARRAY
25116: PUSH
25117: LD_EXP 63
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_INT 1
25139: PLUS
25140: ARRAY
25141: PUSH
25142: LD_INT 12
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PPUSH
25155: CALL_OW 69
25159: ST_TO_ADDR
// if tmp then
25160: LD_VAR 0 5
25164: IFFALSE 25182
// result := result union tmp ;
25166: LD_ADDR_VAR 0 2
25170: PUSH
25171: LD_VAR 0 2
25175: PUSH
25176: LD_VAR 0 5
25180: UNION
25181: ST_TO_ADDR
// p := p + 2 ;
25182: LD_ADDR_VAR 0 4
25186: PUSH
25187: LD_VAR 0 4
25191: PUSH
25192: LD_INT 2
25194: PLUS
25195: ST_TO_ADDR
// end ;
25196: GO 25073
25198: POP
25199: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25200: LD_EXP 64
25204: PUSH
25205: LD_VAR 0 1
25209: ARRAY
25210: PPUSH
25211: LD_INT 81
25213: PUSH
25214: LD_VAR 0 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PPUSH
25223: CALL_OW 70
25227: IFFALSE 25268
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25229: LD_ADDR_VAR 0 2
25233: PUSH
25234: LD_VAR 0 2
25238: PUSH
25239: LD_EXP 64
25243: PUSH
25244: LD_VAR 0 1
25248: ARRAY
25249: PPUSH
25250: LD_INT 81
25252: PUSH
25253: LD_VAR 0 1
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 70
25266: UNION
25267: ST_TO_ADDR
// end ; end_of_file
25268: LD_VAR 0 2
25272: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25273: LD_INT 0
25275: PPUSH
25276: PPUSH
25277: PPUSH
// pom := GetBase ( fac ) ;
25278: LD_ADDR_VAR 0 5
25282: PUSH
25283: LD_VAR 0 1
25287: PPUSH
25288: CALL_OW 274
25292: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25293: LD_ADDR_VAR 0 4
25297: PUSH
25298: LD_VAR 0 2
25302: PUSH
25303: LD_INT 1
25305: ARRAY
25306: PPUSH
25307: LD_VAR 0 2
25311: PUSH
25312: LD_INT 2
25314: ARRAY
25315: PPUSH
25316: LD_VAR 0 2
25320: PUSH
25321: LD_INT 3
25323: ARRAY
25324: PPUSH
25325: LD_VAR 0 2
25329: PUSH
25330: LD_INT 4
25332: ARRAY
25333: PPUSH
25334: CALL_OW 449
25338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_VAR 0 5
25348: PPUSH
25349: LD_INT 1
25351: PPUSH
25352: CALL_OW 275
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_INT 1
25364: ARRAY
25365: GREATEREQUAL
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_INT 2
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 4
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: PUSH
25391: LD_VAR 0 5
25395: PPUSH
25396: LD_INT 3
25398: PPUSH
25399: CALL_OW 275
25403: PUSH
25404: LD_VAR 0 4
25408: PUSH
25409: LD_INT 3
25411: ARRAY
25412: GREATEREQUAL
25413: AND
25414: ST_TO_ADDR
// end ;
25415: LD_VAR 0 3
25419: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25420: LD_INT 0
25422: PPUSH
25423: PPUSH
25424: PPUSH
// result := false ;
25425: LD_ADDR_VAR 0 3
25429: PUSH
25430: LD_INT 0
25432: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25433: LD_ADDR_VAR 0 4
25437: PUSH
25438: LD_EXP 51
25442: PUSH
25443: LD_VAR 0 1
25447: ARRAY
25448: ST_TO_ADDR
// if tmp then
25449: LD_VAR 0 4
25453: IFFALSE 25507
// for i = 1 to tmp do
25455: LD_ADDR_VAR 0 5
25459: PUSH
25460: DOUBLE
25461: LD_INT 1
25463: DEC
25464: ST_TO_ADDR
25465: LD_VAR 0 4
25469: PUSH
25470: FOR_TO
25471: IFFALSE 25505
// if component = tmp [ i ] then
25473: LD_VAR 0 2
25477: PUSH
25478: LD_VAR 0 4
25482: PUSH
25483: LD_VAR 0 5
25487: ARRAY
25488: EQUAL
25489: IFFALSE 25503
// begin result := true ;
25491: LD_ADDR_VAR 0 3
25495: PUSH
25496: LD_INT 1
25498: ST_TO_ADDR
// exit ;
25499: POP
25500: POP
25501: GO 25507
// end ;
25503: GO 25470
25505: POP
25506: POP
// end ;
25507: LD_VAR 0 3
25511: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
// result := false ;
25517: LD_ADDR_VAR 0 4
25521: PUSH
25522: LD_INT 0
25524: ST_TO_ADDR
// if fac then
25525: LD_VAR 0 2
25529: IFFALSE 25752
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25531: LD_VAR 0 2
25535: PPUSH
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL 25273 0 2
25545: PUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: CALL_OW 461
25555: PUSH
25556: LD_INT 2
25558: EQUAL
25559: AND
25560: PUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_VAR 0 3
25570: PUSH
25571: LD_INT 1
25573: ARRAY
25574: PPUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_INT 2
25582: ARRAY
25583: PPUSH
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 3
25591: ARRAY
25592: PPUSH
25593: LD_VAR 0 3
25597: PUSH
25598: LD_INT 4
25600: ARRAY
25601: PPUSH
25602: CALL_OW 448
25606: AND
25607: IFFALSE 25752
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25609: LD_VAR 0 2
25613: PPUSH
25614: LD_VAR 0 3
25618: PUSH
25619: LD_INT 1
25621: ARRAY
25622: PPUSH
25623: LD_VAR 0 3
25627: PUSH
25628: LD_INT 2
25630: ARRAY
25631: PPUSH
25632: LD_VAR 0 3
25636: PUSH
25637: LD_INT 3
25639: ARRAY
25640: PPUSH
25641: LD_VAR 0 3
25645: PUSH
25646: LD_INT 4
25648: ARRAY
25649: PPUSH
25650: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25654: LD_ADDR_VAR 0 6
25658: PUSH
25659: LD_EXP 51
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: ST_TO_ADDR
// for i = 4 downto 1 do
25670: LD_ADDR_VAR 0 5
25674: PUSH
25675: DOUBLE
25676: LD_INT 4
25678: INC
25679: ST_TO_ADDR
25680: LD_INT 1
25682: PUSH
25683: FOR_DOWNTO
25684: IFFALSE 25717
// tab := Remove ( tab , list [ i ] , true ) ;
25686: LD_ADDR_VAR 0 6
25690: PUSH
25691: LD_VAR 0 6
25695: PPUSH
25696: LD_VAR 0 3
25700: PUSH
25701: LD_VAR 0 5
25705: ARRAY
25706: PPUSH
25707: LD_INT 1
25709: PPUSH
25710: CALL 31291 0 3
25714: ST_TO_ADDR
25715: GO 25683
25717: POP
25718: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25719: LD_ADDR_EXP 51
25723: PUSH
25724: LD_EXP 51
25728: PPUSH
25729: LD_VAR 0 1
25733: PPUSH
25734: LD_VAR 0 6
25738: PPUSH
25739: CALL_OW 1
25743: ST_TO_ADDR
// result := true ;
25744: LD_ADDR_VAR 0 4
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// end ; end ; end ;
25752: LD_VAR 0 4
25756: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25757: LD_INT 0
25759: PPUSH
25760: PPUSH
// if not veh then
25761: LD_VAR 0 2
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 25944
// if MREG_Parking [ side ] then
25770: LD_EXP 58
25774: PUSH
25775: LD_VAR 0 1
25779: ARRAY
25780: IFFALSE 25944
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 58
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: NOT
25803: IFFALSE 25944
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25805: LD_VAR 0 2
25809: PPUSH
25810: LD_EXP 58
25814: PUSH
25815: LD_VAR 0 1
25819: ARRAY
25820: PPUSH
25821: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25825: LD_VAR 0 2
25829: PPUSH
25830: CALL_OW 263
25834: PUSH
25835: LD_INT 1
25837: EQUAL
25838: IFFALSE 25944
// begin i := GetDriver ( veh ) ;
25840: LD_ADDR_VAR 0 4
25844: PUSH
25845: LD_VAR 0 2
25849: PPUSH
25850: CALL 31775 0 1
25854: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25855: LD_INT 35
25857: PPUSH
25858: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25862: LD_VAR 0 2
25866: PPUSH
25867: LD_EXP 58
25871: PUSH
25872: LD_VAR 0 1
25876: ARRAY
25877: PPUSH
25878: CALL_OW 308
25882: PUSH
25883: LD_VAR 0 2
25887: PPUSH
25888: CALL_OW 301
25892: OR
25893: IFFALSE 25855
// ComExitVehicle ( i ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: CALL_OW 121
// Wait ( 1 ) ;
25904: LD_INT 1
25906: PPUSH
25907: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25911: LD_VAR 0 4
25915: PPUSH
25916: LD_VAR 0 1
25920: PPUSH
25921: LD_INT 30
25923: PUSH
25924: LD_INT 3
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PPUSH
25931: CALL 11667 0 2
25935: PUSH
25936: LD_INT 1
25938: ARRAY
25939: PPUSH
25940: CALL_OW 180
// end ; end ; end ;
25944: LD_VAR 0 3
25948: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25949: LD_INT 0
25951: PPUSH
25952: PPUSH
25953: PPUSH
25954: PPUSH
25955: PPUSH
25956: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25957: LD_VAR 0 1
25961: PPUSH
25962: LD_INT 30
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PPUSH
25972: CALL 11667 0 2
25976: IFFALSE 26160
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25978: LD_VAR 0 1
25982: PPUSH
25983: LD_INT 30
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PPUSH
25993: CALL 11667 0 2
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 461
26006: PUSH
26007: LD_INT 2
26009: EQUAL
26010: IFFALSE 26160
// begin for i = 1 to MREG_TurretWeapon do
26012: LD_ADDR_VAR 0 3
26016: PUSH
26017: DOUBLE
26018: LD_INT 1
26020: DEC
26021: ST_TO_ADDR
26022: LD_EXP 43
26026: PUSH
26027: FOR_TO
26028: IFFALSE 26158
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26030: LD_EXP 43
26034: PUSH
26035: LD_VAR 0 3
26039: ARRAY
26040: PUSH
26041: LD_INT 1
26043: ARRAY
26044: PUSH
26045: LD_VAR 0 1
26049: EQUAL
26050: IFFALSE 26156
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26052: LD_ADDR_VAR 0 5
26056: PUSH
26057: LD_EXP 43
26061: PUSH
26062: LD_VAR 0 3
26066: ARRAY
26067: PUSH
26068: LD_INT 2
26070: ARRAY
26071: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26072: LD_ADDR_VAR 0 6
26076: PUSH
26077: LD_EXP 43
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PUSH
26088: LD_INT 3
26090: ARRAY
26091: PUSH
26092: LD_INT 1
26094: ARRAY
26095: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26096: LD_ADDR_VAR 0 7
26100: PUSH
26101: LD_EXP 43
26105: PUSH
26106: LD_VAR 0 3
26110: ARRAY
26111: PUSH
26112: LD_INT 3
26114: ARRAY
26115: PUSH
26116: LD_INT 2
26118: ARRAY
26119: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26120: LD_ADDR_VAR 0 4
26124: PUSH
26125: LD_VAR 0 6
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL_OW 428
26139: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 148
// break ;
26154: GO 26158
// end ;
26156: GO 26027
26158: POP
26159: POP
// end ; end ;
26160: LD_VAR 0 2
26164: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26165: LD_INT 0
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26171: LD_ADDR_VAR 0 4
26175: PUSH
26176: LD_VAR 0 1
26180: PPUSH
26181: LD_INT 32
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL 11667 0 2
26195: ST_TO_ADDR
// if not tmp then
26196: LD_VAR 0 4
26200: NOT
26201: IFFALSE 26207
// exit else
26203: GO 26289
26205: GO 26289
// begin for i = 1 to tmp do
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: DOUBLE
26213: LD_INT 1
26215: DEC
26216: ST_TO_ADDR
26217: LD_VAR 0 4
26221: PUSH
26222: FOR_TO
26223: IFFALSE 26287
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26225: LD_VAR 0 4
26229: PUSH
26230: LD_VAR 0 3
26234: ARRAY
26235: PPUSH
26236: CALL_OW 261
26240: PUSH
26241: LD_INT 20
26243: LESS
26244: PUSH
26245: LD_VAR 0 4
26249: PUSH
26250: LD_VAR 0 3
26254: ARRAY
26255: PPUSH
26256: CALL_OW 110
26260: PUSH
26261: LD_INT 0
26263: EQUAL
26264: AND
26265: IFFALSE 26285
// begin SetTag ( tmp [ i ] , 21 ) ;
26267: LD_VAR 0 4
26271: PUSH
26272: LD_VAR 0 3
26276: ARRAY
26277: PPUSH
26278: LD_INT 21
26280: PPUSH
26281: CALL_OW 109
// end ;
26285: GO 26222
26287: POP
26288: POP
// end ; end ;
26289: LD_VAR 0 2
26293: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26294: LD_INT 0
26296: PPUSH
26297: PPUSH
26298: PPUSH
26299: PPUSH
26300: PPUSH
// if not unit then
26301: LD_VAR 0 1
26305: NOT
26306: IFFALSE 26310
// exit ;
26308: GO 26498
// side := GetSide ( unit ) ;
26310: LD_ADDR_VAR 0 3
26314: PUSH
26315: LD_VAR 0 1
26319: PPUSH
26320: CALL_OW 255
26324: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26325: LD_ADDR_VAR 0 5
26329: PUSH
26330: LD_VAR 0 3
26334: PPUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 30
26360: PUSH
26361: LD_INT 29
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PPUSH
26374: CALL 11667 0 2
26378: ST_TO_ADDR
// if not b then
26379: LD_VAR 0 5
26383: NOT
26384: IFFALSE 26388
// exit ;
26386: GO 26498
// if GetTag ( unit ) = 21 then
26388: LD_VAR 0 1
26392: PPUSH
26393: CALL_OW 110
26397: PUSH
26398: LD_INT 21
26400: EQUAL
26401: IFFALSE 26498
// begin c := NearestUnitToUnit ( b , unit ) ;
26403: LD_ADDR_VAR 0 6
26407: PUSH
26408: LD_VAR 0 5
26412: PPUSH
26413: LD_VAR 0 1
26417: PPUSH
26418: CALL_OW 74
26422: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_VAR 0 6
26432: PPUSH
26433: CALL_OW 250
26437: PPUSH
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 251
26447: PPUSH
26448: CALL_OW 297
26452: PUSH
26453: LD_INT 6
26455: GREATER
26456: IFFALSE 26474
// ComMoveUnit ( unit , c ) else
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_VAR 0 6
26467: PPUSH
26468: CALL_OW 112
26472: GO 26498
// begin SetFuel ( unit , 100 ) ;
26474: LD_VAR 0 1
26478: PPUSH
26479: LD_INT 100
26481: PPUSH
26482: CALL_OW 240
// SetTag ( unit , 0 ) ;
26486: LD_VAR 0 1
26490: PPUSH
26491: LD_INT 0
26493: PPUSH
26494: CALL_OW 109
// end ; end ; end ;
26498: LD_VAR 0 2
26502: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26511: LD_ADDR_VAR 0 7
26515: PUSH
26516: LD_VAR 0 1
26520: PPUSH
26521: LD_INT 33
26523: PUSH
26524: LD_INT 2
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 3
26533: PUSH
26534: LD_INT 61
26536: PUSH
26537: EMPTY
26538: LIST
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PPUSH
26548: CALL 11667 0 2
26552: ST_TO_ADDR
// if not vehs then
26553: LD_VAR 0 7
26557: NOT
26558: IFFALSE 26562
// exit ;
26560: GO 26847
// if nation = 1 then
26562: LD_VAR 0 2
26566: PUSH
26567: LD_INT 1
26569: EQUAL
26570: IFFALSE 26740
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26572: LD_VAR 0 1
26576: PPUSH
26577: LD_INT 30
26579: PUSH
26580: LD_INT 36
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PPUSH
26587: CALL 11667 0 2
26591: NOT
26592: IFFALSE 26598
// exit else
26594: GO 26847
26596: GO 26738
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26598: LD_ADDR_VAR 0 5
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_INT 30
26610: PUSH
26611: LD_INT 36
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PPUSH
26618: CALL 11667 0 2
26622: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26623: LD_ADDR_VAR 0 6
26627: PUSH
26628: LD_VAR 0 5
26632: PUSH
26633: LD_INT 1
26635: ARRAY
26636: PPUSH
26637: CALL_OW 313
26641: ST_TO_ADDR
// for i = vehs downto 1 do
26642: LD_ADDR_VAR 0 4
26646: PUSH
26647: DOUBLE
26648: LD_VAR 0 7
26652: INC
26653: ST_TO_ADDR
26654: LD_INT 1
26656: PUSH
26657: FOR_DOWNTO
26658: IFFALSE 26736
// begin if not IsControledBy ( vehs [ i ] ) then
26660: LD_VAR 0 7
26664: PUSH
26665: LD_VAR 0 4
26669: ARRAY
26670: PPUSH
26671: CALL_OW 312
26675: NOT
26676: IFFALSE 26734
// begin tmp := MCV_RemoteDriver ( oper ) ;
26678: LD_ADDR_VAR 0 8
26682: PUSH
26683: LD_VAR 0 6
26687: PPUSH
26688: CALL 26852 0 1
26692: ST_TO_ADDR
// if not tmp then
26693: LD_VAR 0 8
26697: NOT
26698: IFFALSE 26706
// exit else
26700: POP
26701: POP
26702: GO 26847
26704: GO 26734
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26706: LD_VAR 0 7
26710: PUSH
26711: LD_VAR 0 4
26715: ARRAY
26716: PPUSH
26717: LD_VAR 0 8
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: PUSH
26726: LD_INT 1
26728: ARRAY
26729: PPUSH
26730: CALL_OW 135
// end ; end ;
26734: GO 26657
26736: POP
26737: POP
// end ; end else
26738: GO 26847
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26740: LD_VAR 0 1
26744: PPUSH
26745: LD_INT 34
26747: PUSH
26748: LD_INT 31
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL 11667 0 2
26759: NOT
26760: IFFALSE 26766
// exit else
26762: GO 26847
26764: GO 26847
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26766: LD_ADDR_VAR 0 5
26770: PUSH
26771: LD_VAR 0 1
26775: PPUSH
26776: LD_INT 34
26778: PUSH
26779: LD_INT 31
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL 11667 0 2
26790: ST_TO_ADDR
// oper := [ ] ;
26791: LD_ADDR_VAR 0 6
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to ct do
26798: LD_ADDR_VAR 0 4
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 5
26812: PUSH
26813: FOR_TO
26814: IFFALSE 26845
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26816: LD_ADDR_VAR 0 6
26820: PUSH
26821: LD_VAR 0 6
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_VAR 0 4
26835: ARRAY
26836: PPUSH
26837: CALL 31775 0 1
26841: ADD
26842: ST_TO_ADDR
26843: GO 26813
26845: POP
26846: POP
// end ; end ; end ;
26847: LD_VAR 0 3
26851: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26852: LD_INT 0
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
// if not drivers then
26860: LD_VAR 0 1
26864: NOT
26865: IFFALSE 26871
// exit else
26867: GO 27151
26869: GO 27151
// begin linked := [ ] ;
26871: LD_ADDR_VAR 0 5
26875: PUSH
26876: EMPTY
26877: ST_TO_ADDR
// for i = 1 to drivers do
26878: LD_ADDR_VAR 0 3
26882: PUSH
26883: DOUBLE
26884: LD_INT 1
26886: DEC
26887: ST_TO_ADDR
26888: LD_VAR 0 1
26892: PUSH
26893: FOR_TO
26894: IFFALSE 27139
// begin if CanControl ( drivers [ i ] ) then
26896: LD_VAR 0 1
26900: PUSH
26901: LD_VAR 0 3
26905: ARRAY
26906: PPUSH
26907: CALL 32165 0 1
26911: IFFALSE 27137
// if i > 1 then
26913: LD_VAR 0 3
26917: PUSH
26918: LD_INT 1
26920: GREATER
26921: IFFALSE 27098
// begin m := false ;
26923: LD_ADDR_VAR 0 6
26927: PUSH
26928: LD_INT 0
26930: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26931: LD_ADDR_VAR 0 7
26935: PUSH
26936: LD_VAR 0 1
26940: PUSH
26941: LD_VAR 0 3
26945: ARRAY
26946: PPUSH
26947: CALL_OW 432
26951: ST_TO_ADDR
// for j = 1 to linked do
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: DOUBLE
26958: LD_INT 1
26960: DEC
26961: ST_TO_ADDR
26962: LD_VAR 0 5
26966: PUSH
26967: FOR_TO
26968: IFFALSE 27042
// begin if l < linked [ j ] [ 2 ] then
26970: LD_VAR 0 7
26974: PUSH
26975: LD_VAR 0 5
26979: PUSH
26980: LD_VAR 0 4
26984: ARRAY
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: LESS
26990: IFFALSE 27040
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26992: LD_ADDR_VAR 0 5
26996: PUSH
26997: LD_VAR 0 5
27001: PPUSH
27002: LD_INT 1
27004: PPUSH
27005: LD_VAR 0 1
27009: PUSH
27010: LD_VAR 0 3
27014: ARRAY
27015: PUSH
27016: LD_VAR 0 7
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PPUSH
27025: CALL_OW 2
27029: ST_TO_ADDR
// m := true ;
27030: LD_ADDR_VAR 0 6
27034: PUSH
27035: LD_INT 1
27037: ST_TO_ADDR
// break ;
27038: GO 27042
// end ; end ;
27040: GO 26967
27042: POP
27043: POP
// if not m then
27044: LD_VAR 0 6
27048: NOT
27049: IFFALSE 27096
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27051: LD_ADDR_VAR 0 5
27055: PUSH
27056: LD_VAR 0 5
27060: PUSH
27061: LD_VAR 0 1
27065: PUSH
27066: LD_VAR 0 3
27070: ARRAY
27071: PUSH
27072: LD_VAR 0 1
27076: PUSH
27077: LD_VAR 0 3
27081: ARRAY
27082: PPUSH
27083: CALL_OW 432
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: EMPTY
27093: LIST
27094: ADD
27095: ST_TO_ADDR
// end else
27096: GO 27137
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27098: LD_ADDR_VAR 0 5
27102: PUSH
27103: LD_VAR 0 1
27107: PUSH
27108: LD_VAR 0 3
27112: ARRAY
27113: PUSH
27114: LD_VAR 0 1
27118: PUSH
27119: LD_VAR 0 3
27123: ARRAY
27124: PPUSH
27125: CALL_OW 432
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: ST_TO_ADDR
// end ;
27137: GO 26893
27139: POP
27140: POP
// result := linked ;
27141: LD_ADDR_VAR 0 2
27145: PUSH
27146: LD_VAR 0 5
27150: ST_TO_ADDR
// end ; end ;
27151: LD_VAR 0 2
27155: RET
// export function MCV_ToRepair ( unit ) ; begin
27156: LD_INT 0
27158: PPUSH
// if not unit then
27159: LD_VAR 0 1
27163: NOT
27164: IFFALSE 27168
// exit ;
27166: GO 27199
// SetTag ( unit , 6 ) ;
27168: LD_VAR 0 1
27172: PPUSH
27173: LD_INT 6
27175: PPUSH
27176: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 255
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL 25757 0 2
// end ;
27199: LD_VAR 0 2
27203: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27204: LD_INT 0
27206: PPUSH
27207: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27208: LD_VAR 0 1
27212: PPUSH
27213: LD_INT 6
27215: PPUSH
27216: EMPTY
27217: PPUSH
27218: CALL 12370 0 3
27222: IFFALSE 27315
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27224: LD_ADDR_VAR 0 3
27228: PUSH
27229: DOUBLE
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_INT 6
27237: PPUSH
27238: EMPTY
27239: PPUSH
27240: CALL 12370 0 3
27244: INC
27245: ST_TO_ADDR
27246: LD_INT 1
27248: PUSH
27249: FOR_DOWNTO
27250: IFFALSE 27313
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27252: LD_VAR 0 1
27256: PPUSH
27257: LD_INT 6
27259: PPUSH
27260: EMPTY
27261: PPUSH
27262: CALL 12370 0 3
27266: PUSH
27267: LD_VAR 0 3
27271: ARRAY
27272: PPUSH
27273: CALL_OW 256
27277: PUSH
27278: LD_INT 1000
27280: EQUAL
27281: IFFALSE 27311
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27283: LD_VAR 0 1
27287: PPUSH
27288: LD_INT 6
27290: PPUSH
27291: EMPTY
27292: PPUSH
27293: CALL 12370 0 3
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: LD_INT 0
27306: PPUSH
27307: CALL_OW 109
27311: GO 27249
27313: POP
27314: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27315: LD_VAR 0 1
27319: PPUSH
27320: LD_INT 10
27322: PPUSH
27323: EMPTY
27324: PPUSH
27325: CALL 12370 0 3
27329: IFFALSE 27446
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27331: LD_ADDR_VAR 0 3
27335: PUSH
27336: DOUBLE
27337: LD_VAR 0 1
27341: PPUSH
27342: LD_INT 10
27344: PPUSH
27345: EMPTY
27346: PPUSH
27347: CALL 12370 0 3
27351: INC
27352: ST_TO_ADDR
27353: LD_INT 1
27355: PUSH
27356: FOR_DOWNTO
27357: IFFALSE 27444
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_INT 10
27366: PPUSH
27367: EMPTY
27368: PPUSH
27369: CALL 12370 0 3
27373: PUSH
27374: LD_VAR 0 3
27378: ARRAY
27379: PPUSH
27380: CALL_OW 302
27384: NOT
27385: PUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: LD_INT 10
27393: PPUSH
27394: EMPTY
27395: PPUSH
27396: CALL 12370 0 3
27400: PUSH
27401: LD_VAR 0 3
27405: ARRAY
27406: PPUSH
27407: CALL_OW 301
27411: OR
27412: IFFALSE 27442
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27414: LD_VAR 0 1
27418: PPUSH
27419: LD_INT 10
27421: PPUSH
27422: EMPTY
27423: PPUSH
27424: CALL 12370 0 3
27428: PUSH
27429: LD_VAR 0 3
27433: ARRAY
27434: PPUSH
27435: LD_INT 0
27437: PPUSH
27438: CALL_OW 109
27442: GO 27356
27444: POP
27445: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_VAR 0 1
27455: PPUSH
27456: EMPTY
27457: PPUSH
27458: CALL 11968 0 2
27462: PUSH
27463: LD_VAR 0 1
27467: PPUSH
27468: LD_INT 7
27470: PPUSH
27471: EMPTY
27472: PPUSH
27473: CALL 12370 0 3
27477: DIFF
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27524
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27482: LD_VAR 0 3
27486: PPUSH
27487: CALL_OW 256
27491: PUSH
27492: LD_INT 650
27494: LESS
27495: PUSH
27496: LD_VAR 0 3
27500: PPUSH
27501: CALL_OW 110
27505: PUSH
27506: LD_INT 6
27508: EQUAL
27509: NOT
27510: AND
27511: IFFALSE 27522
// MCV_ToRepair ( i ) ;
27513: LD_VAR 0 3
27517: PPUSH
27518: CALL 27156 0 1
27522: GO 27479
27524: POP
27525: POP
// end ; end_of_file end_of_file
27526: LD_VAR 0 2
27530: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27531: LD_STRING SAILEvent [
27533: PUSH
27534: LD_VAR 0 1
27538: STR
27539: PUSH
27540: LD_STRING ]
27542: STR
27543: PPUSH
27544: CALL 8055 0 1
// if event = 101 and dialog_north then
27548: LD_VAR 0 1
27552: PUSH
27553: LD_INT 101
27555: EQUAL
27556: PUSH
27557: LD_EXP 6
27561: AND
27562: IFFALSE 27626
// begin dialog_north := false ;
27564: LD_ADDR_EXP 6
27568: PUSH
27569: LD_INT 0
27571: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27572: LD_EXP 5
27576: PPUSH
27577: LD_STRING DS1
27579: PUSH
27580: LD_STRING DS2
27582: PUSH
27583: LD_STRING DS3
27585: PUSH
27586: LD_STRING DS6
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 1
27597: PPUSH
27598: LD_INT 4
27600: PPUSH
27601: CALL_OW 12
27605: ARRAY
27606: PPUSH
27607: CALL_OW 94
// Wait ( 4 4$00 ) ;
27611: LD_INT 8400
27613: PPUSH
27614: CALL_OW 67
// dialog_north := true ;
27618: LD_ADDR_EXP 6
27622: PUSH
27623: LD_INT 1
27625: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27626: LD_VAR 0 1
27630: PUSH
27631: LD_INT 102
27633: EQUAL
27634: PUSH
27635: LD_EXP 7
27639: AND
27640: IFFALSE 27700
// begin dialog_south := false ;
27642: LD_ADDR_EXP 7
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27650: LD_EXP 4
27654: PPUSH
27655: LD_STRING DJ1
27657: PUSH
27658: LD_STRING DJ4
27660: PUSH
27661: LD_STRING DJ6
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 1
27671: PPUSH
27672: LD_INT 3
27674: PPUSH
27675: CALL_OW 12
27679: ARRAY
27680: PPUSH
27681: CALL_OW 94
// Wait ( 4 4$00 ) ;
27685: LD_INT 8400
27687: PPUSH
27688: CALL_OW 67
// dialog_south := true ;
27692: LD_ADDR_EXP 7
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27700: LD_VAR 0 1
27704: PUSH
27705: LD_INT 104
27707: EQUAL
27708: PUSH
27709: LD_EXP 8
27713: AND
27714: IFFALSE 27736
// begin dialog_popov := false ;
27716: LD_ADDR_EXP 8
27720: PUSH
27721: LD_INT 0
27723: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27724: LD_EXP 24
27728: PPUSH
27729: LD_STRING DR4
27731: PPUSH
27732: CALL_OW 94
// end ; end ;
27736: PPOPN 1
27738: END
// on BuildingStarted ( b , unit ) do var side , i ;
27739: LD_INT 0
27741: PPUSH
27742: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27743: LD_EXP 39
27747: PUSH
27748: LD_VAR 0 1
27752: PPUSH
27753: CALL_OW 255
27757: ARRAY
27758: IFFALSE 27936
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27760: LD_STRING BuildingStarted [side: 
27762: PUSH
27763: LD_VAR 0 1
27767: PPUSH
27768: CALL_OW 255
27772: STR
27773: PUSH
27774: LD_STRING ; btype: 
27776: STR
27777: PUSH
27778: LD_VAR 0 1
27782: PPUSH
27783: CALL_OW 266
27787: STR
27788: PUSH
27789: LD_STRING ; unit: 
27791: STR
27792: PUSH
27793: LD_VAR 0 2
27797: STR
27798: PUSH
27799: LD_STRING ]
27801: STR
27802: PPUSH
27803: CALL 8055 0 1
// side := GetSide ( b ) ;
27807: LD_ADDR_VAR 0 3
27811: PUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 255
27821: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27822: LD_VAR 0 3
27826: PPUSH
27827: LD_INT 21
27829: PUSH
27830: LD_INT 3
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PPUSH
27837: CALL 11667 0 2
27841: PUSH
27842: LD_INT 1
27844: EQUAL
27845: IFFALSE 27936
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27847: LD_ADDR_VAR 0 4
27851: PUSH
27852: LD_VAR 0 3
27856: PPUSH
27857: LD_INT 21
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PPUSH
27867: CALL 11667 0 2
27871: PUSH
27872: LD_VAR 0 3
27876: PPUSH
27877: LD_INT 2
27879: PPUSH
27880: EMPTY
27881: PPUSH
27882: CALL 11750 0 3
27886: DIFF
27887: PUSH
27888: FOR_IN
27889: IFFALSE 27934
// if not HasTask ( i ) then
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 314
27900: NOT
27901: IFFALSE 27932
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27903: LD_VAR 0 4
27907: PPUSH
27908: LD_VAR 0 1
27912: PPUSH
27913: CALL_OW 250
27917: PPUSH
27918: LD_VAR 0 1
27922: PPUSH
27923: CALL_OW 251
27927: PPUSH
27928: CALL_OW 111
27932: GO 27888
27934: POP
27935: POP
// end ;
27936: PPOPN 4
27938: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27939: LD_EXP 39
27943: PUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 255
27953: ARRAY
27954: IFFALSE 28323
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27956: LD_STRING BuildingComplete [side: 
27958: PUSH
27959: LD_VAR 0 1
27963: PPUSH
27964: CALL_OW 255
27968: STR
27969: PUSH
27970: LD_STRING ; btype: 
27972: STR
27973: PUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 266
27983: STR
27984: PUSH
27985: LD_STRING ]
27987: STR
27988: PPUSH
27989: CALL 8055 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27993: LD_ADDR_EXP 46
27997: PUSH
27998: LD_EXP 46
28002: PPUSH
28003: LD_VAR 0 1
28007: PPUSH
28008: CALL_OW 255
28012: PPUSH
28013: LD_VAR 0 1
28017: PPUSH
28018: CALL_OW 266
28022: PPUSH
28023: LD_VAR 0 1
28027: PPUSH
28028: CALL_OW 250
28032: PUSH
28033: LD_VAR 0 1
28037: PPUSH
28038: CALL_OW 251
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 254
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: LIST
28057: PPUSH
28058: CALL 42053 0 4
28062: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 266
28072: PUSH
28073: LD_INT 6
28075: EQUAL
28076: IFFALSE 28110
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28078: LD_ADDR_EXP 40
28082: PUSH
28083: LD_EXP 40
28087: PPUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 255
28097: PPUSH
28098: LD_VAR 0 1
28102: PPUSH
28103: EMPTY
28104: PPUSH
28105: CALL 41962 0 4
28109: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28110: LD_VAR 0 1
28114: PPUSH
28115: CALL_OW 266
28119: PUSH
28120: LD_INT 0
28122: EQUAL
28123: IFFALSE 28233
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28125: LD_ADDR_EXP 48
28129: PUSH
28130: LD_EXP 48
28134: PPUSH
28135: LD_VAR 0 1
28139: PPUSH
28140: CALL_OW 255
28144: PPUSH
28145: LD_INT 0
28147: PPUSH
28148: EMPTY
28149: PPUSH
28150: CALL 41962 0 4
28154: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: PPUSH
28165: LD_INT 1
28167: PPUSH
28168: LD_EXP 72
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PPUSH
28177: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28181: LD_VAR 0 1
28185: PPUSH
28186: CALL_OW 274
28190: PPUSH
28191: LD_INT 2
28193: PPUSH
28194: LD_EXP 72
28198: PUSH
28199: LD_INT 2
28201: ARRAY
28202: PPUSH
28203: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28207: LD_VAR 0 1
28211: PPUSH
28212: CALL_OW 274
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_EXP 72
28224: PUSH
28225: LD_INT 3
28227: ARRAY
28228: PPUSH
28229: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28233: LD_VAR 0 1
28237: PPUSH
28238: CALL_OW 266
28242: PUSH
28243: LD_INT 2
28245: EQUAL
28246: IFFALSE 28278
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28248: LD_ADDR_EXP 48
28252: PUSH
28253: LD_EXP 48
28257: PPUSH
28258: LD_VAR 0 1
28262: PPUSH
28263: CALL_OW 255
28267: PPUSH
28268: LD_INT 2
28270: PPUSH
28271: EMPTY
28272: PPUSH
28273: CALL 41962 0 4
28277: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28278: LD_VAR 0 1
28282: PPUSH
28283: CALL_OW 266
28287: PUSH
28288: LD_INT 4
28290: EQUAL
28291: IFFALSE 28323
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28293: LD_ADDR_EXP 48
28297: PUSH
28298: LD_EXP 48
28302: PPUSH
28303: LD_VAR 0 1
28307: PPUSH
28308: CALL_OW 255
28312: PPUSH
28313: LD_INT 4
28315: PPUSH
28316: EMPTY
28317: PPUSH
28318: CALL 41962 0 4
28322: ST_TO_ADDR
// end ;
28323: PPOPN 1
28325: END
// on ResearchComplete ( tech , lab ) do var i ;
28326: LD_INT 0
28328: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28329: LD_EXP 39
28333: PUSH
28334: LD_VAR 0 2
28338: PPUSH
28339: CALL_OW 255
28343: ARRAY
28344: IFFALSE 28628
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28346: LD_STRING ResearchComplete [side: 
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: CALL_OW 255
28358: PPUSH
28359: CALL_OW 255
28363: STR
28364: PUSH
28365: LD_STRING ; tech:
28367: STR
28368: PUSH
28369: LD_VAR 0 1
28373: STR
28374: PUSH
28375: LD_STRING ]
28377: STR
28378: PPUSH
28379: CALL 8055 0 1
// for i = 1 to MREG_ToRes do
28383: LD_ADDR_VAR 0 3
28387: PUSH
28388: DOUBLE
28389: LD_INT 1
28391: DEC
28392: ST_TO_ADDR
28393: LD_EXP 50
28397: PUSH
28398: FOR_TO
28399: IFFALSE 28486
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28401: LD_EXP 50
28405: PUSH
28406: LD_VAR 0 3
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PUSH
28416: LD_VAR 0 2
28420: PPUSH
28421: CALL_OW 255
28425: EQUAL
28426: PUSH
28427: LD_EXP 50
28431: PUSH
28432: LD_VAR 0 3
28436: ARRAY
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 1
28446: EQUAL
28447: AND
28448: IFFALSE 28484
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28450: LD_ADDR_EXP 50
28454: PUSH
28455: LD_EXP 50
28459: PPUSH
28460: LD_VAR 0 2
28464: PPUSH
28465: CALL_OW 255
28469: PPUSH
28470: LD_VAR 0 1
28474: PPUSH
28475: EMPTY
28476: PPUSH
28477: CALL 42053 0 4
28481: ST_TO_ADDR
// break ;
28482: GO 28486
// end ;
28484: GO 28398
28486: POP
28487: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28488: LD_VAR 0 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 11
28498: PUSH
28499: LD_INT 4
28501: PUSH
28502: LD_INT 3
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: IN
28511: IFFALSE 28628
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28513: LD_ADDR_VAR 0 3
28517: PUSH
28518: LD_VAR 0 2
28522: PPUSH
28523: CALL_OW 255
28527: PPUSH
28528: LD_INT 16
28530: PPUSH
28531: LD_INT 25
28533: PUSH
28534: LD_INT 4
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PPUSH
28541: CALL 12370 0 3
28545: ST_TO_ADDR
// if i then
28546: LD_VAR 0 3
28550: IFFALSE 28568
// SetTag ( i [ 1 ] , 0 ) ;
28552: LD_VAR 0 3
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: PPUSH
28561: LD_INT 0
28563: PPUSH
28564: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28568: LD_ADDR_VAR 0 3
28572: PUSH
28573: LD_VAR 0 2
28577: PPUSH
28578: CALL_OW 255
28582: PPUSH
28583: LD_INT 171
28585: PPUSH
28586: EMPTY
28587: PPUSH
28588: CALL 12370 0 3
28592: ST_TO_ADDR
// if i then
28593: LD_VAR 0 3
28597: IFFALSE 28628
// begin SetTag ( i [ 1 ] , 0 ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: LD_INT 0
28610: PPUSH
28611: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28615: LD_VAR 0 3
28619: PUSH
28620: LD_INT 1
28622: ARRAY
28623: PPUSH
28624: CALL_OW 122
// end ; end ; end ;
28628: PPOPN 3
28630: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28631: LD_INT 0
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
28638: PPUSH
28639: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28640: LD_EXP 39
28644: PUSH
28645: LD_VAR 0 2
28649: PPUSH
28650: CALL_OW 255
28654: ARRAY
28655: IFFALSE 29382
// begin side := GetSide ( veh ) ;
28657: LD_ADDR_VAR 0 4
28661: PUSH
28662: LD_VAR 0 1
28666: PPUSH
28667: CALL_OW 255
28671: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28672: LD_ADDR_VAR 0 6
28676: PUSH
28677: LD_VAR 0 1
28681: PPUSH
28682: CALL_OW 265
28686: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28687: LD_ADDR_VAR 0 7
28691: PUSH
28692: LD_VAR 0 1
28696: PPUSH
28697: CALL_OW 262
28701: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28702: LD_ADDR_VAR 0 8
28706: PUSH
28707: LD_VAR 0 1
28711: PPUSH
28712: CALL_OW 263
28716: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28717: LD_ADDR_VAR 0 9
28721: PUSH
28722: LD_VAR 0 1
28726: PPUSH
28727: CALL_OW 264
28731: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28732: LD_STRING VehicleConstructed [side: 
28734: PUSH
28735: LD_VAR 0 4
28739: STR
28740: PUSH
28741: LD_STRING ; id:
28743: STR
28744: PUSH
28745: LD_VAR 0 1
28749: STR
28750: PUSH
28751: LD_STRING ; components: [
28753: STR
28754: PUSH
28755: LD_VAR 0 6
28759: STR
28760: PUSH
28761: LD_STRING , 
28763: STR
28764: PUSH
28765: LD_VAR 0 7
28769: STR
28770: PUSH
28771: LD_STRING , 
28773: STR
28774: PUSH
28775: LD_VAR 0 8
28779: STR
28780: PUSH
28781: LD_STRING , 
28783: STR
28784: PUSH
28785: LD_VAR 0 9
28789: STR
28790: PUSH
28791: LD_STRING ]]
28793: STR
28794: PPUSH
28795: CALL 8055 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28799: LD_VAR 0 1
28803: PPUSH
28804: CALL_OW 264
28808: PUSH
28809: LD_INT 13
28811: PUSH
28812: LD_INT 12
28814: PUSH
28815: LD_INT 14
28817: PUSH
28818: LD_INT 51
28820: PUSH
28821: LD_INT 53
28823: PUSH
28824: LD_INT 52
28826: PUSH
28827: LD_INT 32
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: LIST
28837: LIST
28838: IN
28839: NOT
28840: IFFALSE 28882
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28842: LD_ADDR_EXP 59
28846: PUSH
28847: LD_EXP 59
28851: PPUSH
28852: LD_VAR 0 4
28856: PPUSH
28857: LD_EXP 59
28861: PUSH
28862: LD_VAR 0 4
28866: ARRAY
28867: PUSH
28868: LD_INT 1
28870: PLUS
28871: PPUSH
28872: LD_VAR 0 1
28876: PPUSH
28877: CALL 31132 0 4
28881: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28882: LD_VAR 0 1
28886: PPUSH
28887: CALL_OW 264
28891: PUSH
28892: LD_INT 31
28894: EQUAL
28895: IFFALSE 28914
// SetTag ( GetDriver ( veh ) , 9 ) ;
28897: LD_VAR 0 1
28901: PPUSH
28902: CALL 31775 0 1
28906: PPUSH
28907: LD_INT 9
28909: PPUSH
28910: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28914: LD_VAR 0 1
28918: PPUSH
28919: CALL_OW 264
28923: PUSH
28924: LD_INT 14
28926: PUSH
28927: LD_INT 53
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: IN
28934: IFFALSE 28971
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28936: LD_ADDR_EXP 42
28940: PUSH
28941: LD_EXP 42
28945: PPUSH
28946: LD_VAR 0 1
28950: PPUSH
28951: CALL_OW 255
28955: PPUSH
28956: LD_INT 2
28958: PPUSH
28959: LD_VAR 0 1
28963: PPUSH
28964: CALL 31132 0 4
28968: ST_TO_ADDR
// exit ;
28969: GO 29382
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28971: LD_VAR 0 1
28975: PPUSH
28976: CALL_OW 265
28980: PUSH
28981: LD_EXP 66
28985: PUSH
28986: LD_VAR 0 4
28990: ARRAY
28991: PUSH
28992: LD_INT 1
28994: ARRAY
28995: IN
28996: PUSH
28997: LD_VAR 0 1
29001: PPUSH
29002: CALL_OW 262
29006: PUSH
29007: LD_EXP 66
29011: PUSH
29012: LD_VAR 0 4
29016: ARRAY
29017: PUSH
29018: LD_INT 1
29020: ARRAY
29021: IN
29022: AND
29023: PUSH
29024: LD_VAR 0 1
29028: PPUSH
29029: CALL_OW 263
29033: PUSH
29034: LD_EXP 66
29038: PUSH
29039: LD_VAR 0 4
29043: ARRAY
29044: PUSH
29045: LD_INT 1
29047: ARRAY
29048: IN
29049: AND
29050: PUSH
29051: LD_VAR 0 1
29055: PPUSH
29056: CALL_OW 264
29060: PUSH
29061: LD_EXP 66
29065: PUSH
29066: LD_VAR 0 4
29070: ARRAY
29071: PUSH
29072: LD_INT 1
29074: ARRAY
29075: IN
29076: AND
29077: IFFALSE 29121
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29079: LD_ADDR_EXP 67
29083: PUSH
29084: LD_EXP 67
29088: PPUSH
29089: LD_VAR 0 4
29093: PPUSH
29094: LD_EXP 67
29098: PUSH
29099: LD_VAR 0 4
29103: ARRAY
29104: PUSH
29105: LD_INT 1
29107: PLUS
29108: PPUSH
29109: LD_VAR 0 1
29113: PPUSH
29114: CALL 31132 0 4
29118: ST_TO_ADDR
// exit ;
29119: GO 29382
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29121: LD_VAR 0 6
29125: PUSH
29126: LD_EXP 69
29130: PUSH
29131: LD_VAR 0 4
29135: ARRAY
29136: PUSH
29137: LD_INT 1
29139: ARRAY
29140: EQUAL
29141: PUSH
29142: LD_VAR 0 7
29146: PUSH
29147: LD_EXP 69
29151: PUSH
29152: LD_VAR 0 4
29156: ARRAY
29157: PUSH
29158: LD_INT 2
29160: ARRAY
29161: EQUAL
29162: AND
29163: PUSH
29164: LD_VAR 0 8
29168: PUSH
29169: LD_EXP 69
29173: PUSH
29174: LD_VAR 0 4
29178: ARRAY
29179: PUSH
29180: LD_INT 3
29182: ARRAY
29183: EQUAL
29184: AND
29185: PUSH
29186: LD_VAR 0 9
29190: PUSH
29191: LD_EXP 69
29195: PUSH
29196: LD_VAR 0 4
29200: ARRAY
29201: PUSH
29202: LD_INT 4
29204: ARRAY
29205: EQUAL
29206: AND
29207: IFFALSE 29363
// begin tmp := MREG_ToAttack [ side ] ;
29209: LD_ADDR_VAR 0 5
29213: PUSH
29214: LD_EXP 69
29218: PUSH
29219: LD_VAR 0 4
29223: ARRAY
29224: ST_TO_ADDR
// for i = 1 to 4 do
29225: LD_ADDR_VAR 0 3
29229: PUSH
29230: DOUBLE
29231: LD_INT 1
29233: DEC
29234: ST_TO_ADDR
29235: LD_INT 4
29237: PUSH
29238: FOR_TO
29239: IFFALSE 29261
// tmp := Delete ( tmp , 1 ) ;
29241: LD_ADDR_VAR 0 5
29245: PUSH
29246: LD_VAR 0 5
29250: PPUSH
29251: LD_INT 1
29253: PPUSH
29254: CALL_OW 3
29258: ST_TO_ADDR
29259: GO 29238
29261: POP
29262: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29263: LD_ADDR_EXP 69
29267: PUSH
29268: LD_EXP 69
29272: PPUSH
29273: LD_VAR 0 4
29277: PPUSH
29278: LD_VAR 0 5
29282: PPUSH
29283: CALL_OW 1
29287: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29288: LD_ADDR_EXP 71
29292: PUSH
29293: LD_EXP 71
29297: PPUSH
29298: LD_VAR 0 4
29302: PPUSH
29303: LD_EXP 71
29307: PUSH
29308: LD_VAR 0 4
29312: ARRAY
29313: PUSH
29314: LD_INT 1
29316: PLUS
29317: PPUSH
29318: LD_VAR 0 1
29322: PPUSH
29323: CALL 31132 0 4
29327: ST_TO_ADDR
// if tmp = 0 then
29328: LD_VAR 0 5
29332: PUSH
29333: LD_INT 0
29335: EQUAL
29336: IFFALSE 29361
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29338: LD_ADDR_EXP 69
29342: PUSH
29343: LD_EXP 69
29347: PPUSH
29348: LD_VAR 0 4
29352: PPUSH
29353: LD_INT 0
29355: PPUSH
29356: CALL_OW 1
29360: ST_TO_ADDR
// exit ;
29361: GO 29382
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29363: LD_VAR 0 1
29367: PPUSH
29368: CALL_OW 255
29372: PPUSH
29373: LD_VAR 0 1
29377: PPUSH
29378: CALL 25757 0 2
// end ;
29382: PPOPN 9
29384: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29385: LD_EXP 39
29389: PUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: CALL_OW 255
29399: ARRAY
29400: IFFALSE 29632
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29402: LD_STRING ApemanTamed [side: 
29404: PUSH
29405: LD_VAR 0 2
29409: PPUSH
29410: CALL_OW 255
29414: STR
29415: PUSH
29416: LD_STRING ; sci: 
29418: STR
29419: PUSH
29420: LD_VAR 0 2
29424: STR
29425: PUSH
29426: LD_STRING ; ape: 
29428: STR
29429: PUSH
29430: LD_VAR 0 1
29434: STR
29435: PUSH
29436: LD_STRING ]
29438: STR
29439: PPUSH
29440: CALL 8055 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29444: LD_INT 11
29446: PPUSH
29447: LD_VAR 0 2
29451: PPUSH
29452: CALL_OW 255
29456: PPUSH
29457: CALL_OW 321
29461: PUSH
29462: LD_INT 2
29464: EQUAL
29465: NOT
29466: PUSH
29467: LD_INT 2
29469: PPUSH
29470: LD_VAR 0 2
29474: PPUSH
29475: CALL_OW 255
29479: PPUSH
29480: CALL_OW 321
29484: PUSH
29485: LD_INT 2
29487: EQUAL
29488: NOT
29489: OR
29490: PUSH
29491: LD_VAR 0 2
29495: PPUSH
29496: CALL_OW 255
29500: PPUSH
29501: LD_INT 171
29503: PPUSH
29504: EMPTY
29505: PPUSH
29506: CALL 12370 0 3
29510: PUSH
29511: LD_INT 0
29513: EQUAL
29514: AND
29515: IFFALSE 29529
// begin SetTag ( ape , 171 ) ;
29517: LD_VAR 0 1
29521: PPUSH
29522: LD_INT 171
29524: PPUSH
29525: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29529: LD_VAR 0 2
29533: PPUSH
29534: CALL_OW 255
29538: PPUSH
29539: LD_INT 30
29541: PUSH
29542: LD_INT 1
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PPUSH
29549: CALL 11667 0 2
29553: IFFALSE 29632
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29555: LD_VAR 0 1
29559: PPUSH
29560: LD_VAR 0 2
29564: PPUSH
29565: CALL_OW 255
29569: PPUSH
29570: LD_INT 30
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PPUSH
29580: CALL 11667 0 2
29584: PUSH
29585: LD_INT 1
29587: ARRAY
29588: PPUSH
29589: CALL_OW 250
29593: PPUSH
29594: LD_VAR 0 2
29598: PPUSH
29599: CALL_OW 255
29603: PPUSH
29604: LD_INT 30
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL 11667 0 2
29618: PUSH
29619: LD_INT 1
29621: ARRAY
29622: PPUSH
29623: CALL_OW 251
29627: PPUSH
29628: CALL_OW 111
// end ;
29632: PPOPN 2
29634: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29635: LD_EXP 39
29639: PUSH
29640: LD_VAR 0 1
29644: PPUSH
29645: CALL_OW 255
29649: ARRAY
29650: IFFALSE 29928
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29652: LD_VAR 0 2
29656: PUSH
29657: LD_VAR 0 2
29661: PPUSH
29662: CALL_OW 255
29666: PPUSH
29667: CALL 12080 0 1
29671: IN
29672: IFFALSE 29813
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29674: LD_VAR 0 1
29678: PPUSH
29679: CALL_OW 266
29683: PUSH
29684: LD_INT 0
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: IN
29694: IFFALSE 29724
// begin Wait ( 0 0$0.3 ) ;
29696: LD_INT 10
29698: PPUSH
29699: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29703: LD_VAR 0 2
29707: PPUSH
29708: LD_INT 16
29710: PPUSH
29711: CALL_OW 336
// ComExitBuilding ( un ) ;
29715: LD_VAR 0 2
29719: PPUSH
29720: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29724: LD_VAR 0 1
29728: PPUSH
29729: CALL_OW 266
29733: PUSH
29734: LD_INT 4
29736: PUSH
29737: LD_INT 5
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: IN
29744: IFFALSE 29813
// begin Wait ( 0 0$0.3 ) ;
29746: LD_INT 10
29748: PPUSH
29749: CALL_OW 67
// if GetTag ( un ) = 0 then
29753: LD_VAR 0 2
29757: PPUSH
29758: CALL_OW 110
29762: PUSH
29763: LD_INT 0
29765: EQUAL
29766: IFFALSE 29782
// SetClass ( un , class_apeman_soldier ) else
29768: LD_VAR 0 2
29772: PPUSH
29773: LD_INT 15
29775: PPUSH
29776: CALL_OW 336
29780: GO 29813
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29782: LD_INT 3
29784: PPUSH
29785: LD_VAR 0 2
29789: PPUSH
29790: CALL_OW 255
29794: PPUSH
29795: CALL_OW 321
29799: IFFALSE 29813
// SetClass ( un , class_apeman_kamikaze ) ;
29801: LD_VAR 0 2
29805: PPUSH
29806: LD_INT 17
29808: PPUSH
29809: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29813: LD_VAR 0 1
29817: PPUSH
29818: CALL_OW 266
29822: PUSH
29823: LD_INT 32
29825: EQUAL
29826: IFFALSE 29928
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29828: LD_ADDR_EXP 68
29832: PUSH
29833: LD_EXP 68
29837: PPUSH
29838: LD_VAR 0 1
29842: PPUSH
29843: CALL_OW 255
29847: PPUSH
29848: LD_EXP 68
29852: PUSH
29853: LD_VAR 0 1
29857: PPUSH
29858: CALL_OW 255
29862: ARRAY
29863: PUSH
29864: LD_INT 1
29866: PLUS
29867: PPUSH
29868: LD_VAR 0 1
29872: PPUSH
29873: CALL 31132 0 4
29877: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29878: LD_ADDR_EXP 68
29882: PUSH
29883: LD_EXP 68
29887: PPUSH
29888: LD_VAR 0 1
29892: PPUSH
29893: CALL_OW 255
29897: PPUSH
29898: LD_EXP 68
29902: PUSH
29903: LD_VAR 0 1
29907: PPUSH
29908: CALL_OW 255
29912: ARRAY
29913: PUSH
29914: LD_INT 1
29916: PLUS
29917: PPUSH
29918: LD_VAR 0 2
29922: PPUSH
29923: CALL 31132 0 4
29927: ST_TO_ADDR
// end ; end ;
29928: PPOPN 2
29930: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29931: LD_VAR 0 1
29935: PPUSH
29936: CALL 57241 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29940: LD_VAR 0 1
29944: PUSH
29945: LD_INT 22
29947: PUSH
29948: LD_INT 3
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 23
29957: PUSH
29958: LD_INT 3
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 21
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: LIST
29979: PPUSH
29980: CALL_OW 69
29984: IN
29985: IFFALSE 30001
// player_loss := player_loss + 1 ;
29987: LD_ADDR_EXP 10
29991: PUSH
29992: LD_EXP 10
29996: PUSH
29997: LD_INT 1
29999: PLUS
30000: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
30001: LD_VAR 0 1
30005: PUSH
30006: LD_INT 22
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 21
30018: PUSH
30019: LD_INT 3
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PPUSH
30030: CALL_OW 69
30034: IN
30035: PUSH
30036: LD_EXP 14
30040: NOT
30041: AND
30042: IFFALSE 30105
// begin alfa_north_triggered := true ;
30044: LD_ADDR_EXP 14
30048: PUSH
30049: LD_INT 1
30051: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30052: LD_EXP 5
30056: PPUSH
30057: LD_STRING DS4
30059: PPUSH
30060: CALL_OW 94
// Wait ( 1 1$25 ) ;
30064: LD_INT 2975
30066: PPUSH
30067: CALL_OW 67
// if not isTest then
30071: LD_EXP 1
30075: NOT
30076: IFFALSE 30105
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30078: LD_INT 20
30080: PPUSH
30081: LD_INT 5
30083: PUSH
30084: LD_INT 6
30086: PUSH
30087: LD_INT 7
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: LIST
30094: PUSH
30095: LD_OWVAR 67
30099: ARRAY
30100: PPUSH
30101: CALL 7074 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30105: LD_VAR 0 1
30109: PUSH
30110: LD_INT 22
30112: PUSH
30113: LD_INT 4
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 21
30122: PUSH
30123: LD_INT 3
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PPUSH
30134: CALL_OW 69
30138: IN
30139: PUSH
30140: LD_EXP 15
30144: NOT
30145: AND
30146: IFFALSE 30209
// begin alfa_south_triggered := true ;
30148: LD_ADDR_EXP 15
30152: PUSH
30153: LD_INT 1
30155: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30156: LD_EXP 4
30160: PPUSH
30161: LD_STRING DJ3
30163: PPUSH
30164: CALL_OW 94
// Wait ( 0 0$45 ) ;
30168: LD_INT 1575
30170: PPUSH
30171: CALL_OW 67
// if not isTest then
30175: LD_EXP 1
30179: NOT
30180: IFFALSE 30209
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30182: LD_INT 20
30184: PPUSH
30185: LD_INT 5
30187: PUSH
30188: LD_INT 6
30190: PUSH
30191: LD_INT 7
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: LIST
30198: PUSH
30199: LD_OWVAR 67
30203: ARRAY
30204: PPUSH
30205: CALL 7074 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30209: LD_VAR 0 1
30213: PPUSH
30214: CALL_OW 266
30218: PUSH
30219: LD_INT 1
30221: EQUAL
30222: PUSH
30223: LD_VAR 0 1
30227: PPUSH
30228: CALL_OW 255
30232: PUSH
30233: LD_INT 1
30235: PUSH
30236: LD_INT 4
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: IN
30243: AND
30244: IFFALSE 30253
// RaiseSailEvent ( 104 ) ;
30246: LD_INT 104
30248: PPUSH
30249: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30253: LD_EXP 39
30257: PUSH
30258: LD_VAR 0 1
30262: PPUSH
30263: CALL_OW 255
30267: ARRAY
30268: IFFALSE 30655
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30270: LD_STRING UnitDestroyed [side 
30272: PUSH
30273: LD_VAR 0 1
30277: PPUSH
30278: CALL_OW 255
30282: STR
30283: PUSH
30284: LD_STRING ; id: 
30286: STR
30287: PUSH
30288: LD_VAR 0 1
30292: STR
30293: PUSH
30294: LD_STRING ; type: 
30296: STR
30297: PUSH
30298: LD_VAR 0 1
30302: PPUSH
30303: CALL_OW 247
30307: STR
30308: PUSH
30309: LD_STRING ]
30311: STR
30312: PPUSH
30313: CALL 8055 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30317: LD_VAR 0 1
30321: PUSH
30322: LD_VAR 0 1
30326: PPUSH
30327: CALL_OW 255
30331: PPUSH
30332: LD_INT 21
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PPUSH
30342: CALL 11667 0 2
30346: IN
30347: IFFALSE 30503
// begin if MCF_HasClass ( un ) then
30349: LD_VAR 0 1
30353: PPUSH
30354: CALL 14373 0 1
30358: IFFALSE 30503
// case MCF_HasClass ( un ) of 1 :
30360: LD_VAR 0 1
30364: PPUSH
30365: CALL 14373 0 1
30369: PUSH
30370: LD_INT 1
30372: DOUBLE
30373: EQUAL
30374: IFTRUE 30378
30376: GO 30403
30378: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30379: LD_VAR 0 1
30383: PPUSH
30384: CALL_OW 255
30388: PPUSH
30389: LD_STRING ToArm
30391: PPUSH
30392: LD_VAR 0 1
30396: PPUSH
30397: CALL 14546 0 3
30401: GO 30503
30403: LD_INT 2
30405: DOUBLE
30406: EQUAL
30407: IFTRUE 30411
30409: GO 30436
30411: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30412: LD_VAR 0 1
30416: PPUSH
30417: CALL_OW 255
30421: PPUSH
30422: LD_STRING ToDep
30424: PPUSH
30425: LD_VAR 0 1
30429: PPUSH
30430: CALL 14546 0 3
30434: GO 30503
30436: LD_INT 3
30438: DOUBLE
30439: EQUAL
30440: IFTRUE 30444
30442: GO 30469
30444: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30445: LD_VAR 0 1
30449: PPUSH
30450: CALL_OW 255
30454: PPUSH
30455: LD_STRING ToFac
30457: PPUSH
30458: LD_VAR 0 1
30462: PPUSH
30463: CALL 14546 0 3
30467: GO 30503
30469: LD_INT 4
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30502
30477: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30478: LD_VAR 0 1
30482: PPUSH
30483: CALL_OW 255
30487: PPUSH
30488: LD_STRING ToLab
30490: PPUSH
30491: LD_VAR 0 1
30495: PPUSH
30496: CALL 14546 0 3
30500: GO 30503
30502: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30503: LD_VAR 0 1
30507: PUSH
30508: LD_EXP 67
30512: PUSH
30513: LD_VAR 0 1
30517: PPUSH
30518: CALL_OW 255
30522: ARRAY
30523: IN
30524: IFFALSE 30609
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30526: LD_ADDR_EXP 67
30530: PUSH
30531: LD_EXP 67
30535: PPUSH
30536: LD_VAR 0 1
30540: PPUSH
30541: LD_INT 0
30543: PPUSH
30544: CALL 31291 0 3
30548: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30549: LD_VAR 0 1
30553: PPUSH
30554: CALL_OW 255
30558: PPUSH
30559: LD_VAR 0 1
30563: PPUSH
30564: CALL_OW 265
30568: PUSH
30569: LD_VAR 0 1
30573: PPUSH
30574: CALL_OW 262
30578: PUSH
30579: LD_VAR 0 1
30583: PPUSH
30584: CALL_OW 263
30588: PUSH
30589: LD_VAR 0 1
30593: PPUSH
30594: CALL_OW 264
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: PPUSH
30605: CALL 21186 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30609: LD_VAR 0 1
30613: PUSH
30614: LD_EXP 71
30618: PUSH
30619: LD_VAR 0 1
30623: PPUSH
30624: CALL_OW 255
30628: ARRAY
30629: IN
30630: IFFALSE 30655
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30632: LD_ADDR_EXP 71
30636: PUSH
30637: LD_EXP 71
30641: PPUSH
30642: LD_VAR 0 1
30646: PPUSH
30647: LD_INT 0
30649: PPUSH
30650: CALL 31291 0 3
30654: ST_TO_ADDR
// end ; end ;
30655: PPOPN 1
30657: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30658: LD_EXP 39
30662: PUSH
30663: LD_VAR 0 2
30667: PPUSH
30668: CALL_OW 255
30672: ARRAY
30673: IFFALSE 30845
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30675: LD_VAR 0 2
30679: PUSH
30680: LD_EXP 68
30684: PUSH
30685: LD_VAR 0 2
30689: PPUSH
30690: CALL_OW 255
30694: ARRAY
30695: IN
30696: PUSH
30697: LD_VAR 0 1
30701: PPUSH
30702: CALL_OW 266
30706: PUSH
30707: LD_INT 32
30709: PUSH
30710: LD_INT 31
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: IN
30717: AND
30718: IFFALSE 30818
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30720: LD_ADDR_EXP 68
30724: PUSH
30725: LD_EXP 68
30729: PPUSH
30730: LD_VAR 0 1
30734: PPUSH
30735: LD_INT 0
30737: PPUSH
30738: CALL 31291 0 3
30742: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30743: LD_ADDR_EXP 68
30747: PUSH
30748: LD_EXP 68
30752: PPUSH
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_INT 0
30760: PPUSH
30761: CALL 31291 0 3
30765: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30766: LD_EXP 68
30770: PUSH
30771: LD_VAR 0 2
30775: PPUSH
30776: CALL_OW 255
30780: ARRAY
30781: PUSH
30782: LD_STRING 
30784: EQUAL
30785: IFFALSE 30818
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30787: LD_ADDR_EXP 68
30791: PUSH
30792: LD_EXP 68
30796: PPUSH
30797: LD_VAR 0 2
30801: PPUSH
30802: CALL_OW 255
30806: PPUSH
30807: LD_INT 1
30809: PPUSH
30810: LD_INT 0
30812: PPUSH
30813: CALL 31132 0 4
30817: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30818: LD_VAR 0 1
30822: PPUSH
30823: CALL_OW 266
30827: PUSH
30828: LD_INT 36
30830: IN
30831: IFFALSE 30845
// SetTag ( un , 0 ) ;
30833: LD_VAR 0 2
30837: PPUSH
30838: LD_INT 0
30840: PPUSH
30841: CALL_OW 109
// end ;
30845: PPOPN 2
30847: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30848: LD_EXP 39
30852: PUSH
30853: LD_VAR 0 1
30857: PPUSH
30858: CALL_OW 255
30862: ARRAY
30863: IFFALSE 30889
// begin if GetControl ( un ) = control_remote then
30865: LD_VAR 0 1
30869: PPUSH
30870: CALL_OW 263
30874: PUSH
30875: LD_INT 2
30877: EQUAL
30878: IFFALSE 30889
// ComUnlink ( un ) ;
30880: LD_VAR 0 1
30884: PPUSH
30885: CALL_OW 136
// end ;
30889: PPOPN 1
30891: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30892: LD_EXP 39
30896: PUSH
30897: LD_VAR 0 1
30901: PPUSH
30902: CALL_OW 255
30906: ARRAY
30907: IFFALSE 30936
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30909: LD_VAR 0 2
30913: PPUSH
30914: CALL_OW 264
30918: PUSH
30919: LD_INT 31
30921: IN
30922: IFFALSE 30936
// SetTag ( driver , 0 ) ;
30924: LD_VAR 0 1
30928: PPUSH
30929: LD_INT 0
30931: PPUSH
30932: CALL_OW 109
// end ;
30936: PPOPN 4
30938: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30939: LD_INT 0
30941: PPUSH
30942: PPUSH
30943: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30944: LD_ADDR_VAR 0 3
30948: PUSH
30949: LD_VAR 0 1
30953: PPUSH
30954: CALL_OW 269
30958: ST_TO_ADDR
// x := GetX ( building ) ;
30959: LD_ADDR_VAR 0 4
30963: PUSH
30964: LD_VAR 0 1
30968: PPUSH
30969: CALL_OW 250
30973: ST_TO_ADDR
// y := GetY ( building ) ;
30974: LD_ADDR_VAR 0 5
30978: PUSH
30979: LD_VAR 0 1
30983: PPUSH
30984: CALL_OW 251
30988: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30989: LD_ADDR_EXP 43
30993: PUSH
30994: LD_EXP 43
30998: PPUSH
30999: LD_VAR 0 1
31003: PPUSH
31004: CALL_OW 255
31008: PPUSH
31009: LD_VAR 0 3
31013: PPUSH
31014: LD_VAR 0 4
31018: PUSH
31019: LD_VAR 0 5
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PPUSH
31028: CALL 42053 0 4
31032: ST_TO_ADDR
// end ;
31033: PPOPN 5
31035: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31036: LD_VAR 0 1
31040: PUSH
31041: LD_EXP 30
31045: IN
31046: NOT
31047: IFFALSE 31095
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31049: LD_ADDR_EXP 30
31053: PUSH
31054: LD_EXP 30
31058: PPUSH
31059: LD_EXP 30
31063: PUSH
31064: LD_INT 1
31066: PLUS
31067: PPUSH
31068: LD_VAR 0 1
31072: PPUSH
31073: CALL_OW 2
31077: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31078: LD_STRING DestinationUnrechable. [unit: 
31080: PUSH
31081: LD_VAR 0 1
31085: STR
31086: PUSH
31087: LD_STRING ]
31089: STR
31090: PPUSH
31091: CALL 8055 0 1
// end ; end ;
31095: PPOPN 1
31097: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31098: LD_VAR 0 1
31102: PPUSH
31103: LD_VAR 0 2
31107: PPUSH
31108: LD_VAR 0 3
31112: PPUSH
31113: CALL 57339 0 3
// end ;
31117: PPOPN 3
31119: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31120: LD_VAR 0 1
31124: PPUSH
31125: CALL 57347 0 1
// end ; end_of_file
31129: PPOPN 1
31131: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31132: LD_INT 0
31134: PPUSH
31135: PPUSH
31136: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31137: LD_ADDR_VAR 0 7
31141: PUSH
31142: LD_VAR 0 1
31146: PUSH
31147: LD_VAR 0 2
31151: ARRAY
31152: PPUSH
31153: LD_VAR 0 3
31157: PPUSH
31158: LD_VAR 0 4
31162: PPUSH
31163: CALL_OW 1
31167: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31168: LD_ADDR_VAR 0 1
31172: PUSH
31173: LD_VAR 0 1
31177: PPUSH
31178: LD_VAR 0 2
31182: PPUSH
31183: LD_VAR 0 7
31187: PPUSH
31188: CALL_OW 1
31192: ST_TO_ADDR
// result := tab ;
31193: LD_ADDR_VAR 0 5
31197: PUSH
31198: LD_VAR 0 1
31202: ST_TO_ADDR
// end ;
31203: LD_VAR 0 5
31207: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31208: LD_INT 0
31210: PPUSH
31211: PPUSH
31212: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31213: LD_ADDR_VAR 0 5
31217: PUSH
31218: LD_VAR 0 1
31222: PUSH
31223: LD_VAR 0 2
31227: PUSH
31228: LD_INT 1
31230: ARRAY
31231: ARRAY
31232: PPUSH
31233: LD_VAR 0 2
31237: PUSH
31238: LD_INT 2
31240: ARRAY
31241: PPUSH
31242: CALL_OW 3
31246: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31247: LD_ADDR_VAR 0 1
31251: PUSH
31252: LD_VAR 0 1
31256: PPUSH
31257: LD_VAR 0 2
31261: PUSH
31262: LD_INT 1
31264: ARRAY
31265: PPUSH
31266: LD_VAR 0 5
31270: PPUSH
31271: CALL_OW 1
31275: ST_TO_ADDR
// result := tab ;
31276: LD_ADDR_VAR 0 3
31280: PUSH
31281: LD_VAR 0 1
31285: ST_TO_ADDR
// end ;
31286: LD_VAR 0 3
31290: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31291: LD_INT 0
31293: PPUSH
31294: PPUSH
31295: PPUSH
31296: PPUSH
// i := 1 ;
31297: LD_ADDR_VAR 0 5
31301: PUSH
31302: LD_INT 1
31304: ST_TO_ADDR
// while ( i <= tab ) do
31305: LD_VAR 0 5
31309: PUSH
31310: LD_VAR 0 1
31314: LESSEQUAL
31315: IFFALSE 31690
// begin if not tab [ i ] then
31317: LD_VAR 0 1
31321: PUSH
31322: LD_VAR 0 5
31326: ARRAY
31327: NOT
31328: IFFALSE 31332
// break ;
31330: GO 31690
// if value in tab then
31332: LD_VAR 0 2
31336: PUSH
31337: LD_VAR 0 1
31341: IN
31342: IFFALSE 31455
// begin if not mode then
31344: LD_VAR 0 3
31348: NOT
31349: IFFALSE 31369
// tab := tab diff value else
31351: LD_ADDR_VAR 0 1
31355: PUSH
31356: LD_VAR 0 1
31360: PUSH
31361: LD_VAR 0 2
31365: DIFF
31366: ST_TO_ADDR
31367: GO 31431
// for j = 1 to tab do
31369: LD_ADDR_VAR 0 6
31373: PUSH
31374: DOUBLE
31375: LD_INT 1
31377: DEC
31378: ST_TO_ADDR
31379: LD_VAR 0 1
31383: PUSH
31384: FOR_TO
31385: IFFALSE 31429
// if tab [ j ] = value then
31387: LD_VAR 0 1
31391: PUSH
31392: LD_VAR 0 6
31396: ARRAY
31397: PUSH
31398: LD_VAR 0 2
31402: EQUAL
31403: IFFALSE 31427
// begin tab := Delete ( tab , j ) ;
31405: LD_ADDR_VAR 0 1
31409: PUSH
31410: LD_VAR 0 1
31414: PPUSH
31415: LD_VAR 0 6
31419: PPUSH
31420: CALL_OW 3
31424: ST_TO_ADDR
// break ;
31425: GO 31429
// end ;
31427: GO 31384
31429: POP
31430: POP
// i := i - 1 ;
31431: LD_ADDR_VAR 0 5
31435: PUSH
31436: LD_VAR 0 5
31440: PUSH
31441: LD_INT 1
31443: MINUS
31444: ST_TO_ADDR
// if mode then
31445: LD_VAR 0 3
31449: IFFALSE 31453
// break ;
31451: GO 31690
// end else
31453: GO 31674
// if tab [ i ] and value in tab [ i ] then
31455: LD_VAR 0 1
31459: PUSH
31460: LD_VAR 0 5
31464: ARRAY
31465: PUSH
31466: LD_VAR 0 2
31470: PUSH
31471: LD_VAR 0 1
31475: PUSH
31476: LD_VAR 0 5
31480: ARRAY
31481: IN
31482: AND
31483: IFFALSE 31674
// begin if not mode then
31485: LD_VAR 0 3
31489: NOT
31490: IFFALSE 31516
// tmp := tab [ i ] diff value else
31492: LD_ADDR_VAR 0 7
31496: PUSH
31497: LD_VAR 0 1
31501: PUSH
31502: LD_VAR 0 5
31506: ARRAY
31507: PUSH
31508: LD_VAR 0 2
31512: DIFF
31513: ST_TO_ADDR
31514: GO 31596
// for j = 1 to tab [ i ] do
31516: LD_ADDR_VAR 0 6
31520: PUSH
31521: DOUBLE
31522: LD_INT 1
31524: DEC
31525: ST_TO_ADDR
31526: LD_VAR 0 1
31530: PUSH
31531: LD_VAR 0 5
31535: ARRAY
31536: PUSH
31537: FOR_TO
31538: IFFALSE 31594
// if value = tab [ i ] [ j ] then
31540: LD_VAR 0 2
31544: PUSH
31545: LD_VAR 0 1
31549: PUSH
31550: LD_VAR 0 5
31554: ARRAY
31555: PUSH
31556: LD_VAR 0 6
31560: ARRAY
31561: EQUAL
31562: IFFALSE 31592
// begin tmp := Delete ( tab [ i ] , j ) ;
31564: LD_ADDR_VAR 0 7
31568: PUSH
31569: LD_VAR 0 1
31573: PUSH
31574: LD_VAR 0 5
31578: ARRAY
31579: PPUSH
31580: LD_VAR 0 6
31584: PPUSH
31585: CALL_OW 3
31589: ST_TO_ADDR
// break ;
31590: GO 31594
// end ;
31592: GO 31537
31594: POP
31595: POP
// if tmp = [ ] then
31596: LD_VAR 0 7
31600: PUSH
31601: EMPTY
31602: EQUAL
31603: IFFALSE 31627
// begin tab := Delete ( tab , i ) ;
31605: LD_ADDR_VAR 0 1
31609: PUSH
31610: LD_VAR 0 1
31614: PPUSH
31615: LD_VAR 0 5
31619: PPUSH
31620: CALL_OW 3
31624: ST_TO_ADDR
// end else
31625: GO 31652
// tab := Replace ( tab , i , tmp ) ;
31627: LD_ADDR_VAR 0 1
31631: PUSH
31632: LD_VAR 0 1
31636: PPUSH
31637: LD_VAR 0 5
31641: PPUSH
31642: LD_VAR 0 7
31646: PPUSH
31647: CALL_OW 1
31651: ST_TO_ADDR
// i := i - 1 ;
31652: LD_ADDR_VAR 0 5
31656: PUSH
31657: LD_VAR 0 5
31661: PUSH
31662: LD_INT 1
31664: MINUS
31665: ST_TO_ADDR
// if mode then
31666: LD_VAR 0 3
31670: IFFALSE 31674
// break ;
31672: GO 31690
// end ; i := i + 1 ;
31674: LD_ADDR_VAR 0 5
31678: PUSH
31679: LD_VAR 0 5
31683: PUSH
31684: LD_INT 1
31686: PLUS
31687: ST_TO_ADDR
// end ;
31688: GO 31305
// result := tab ;
31690: LD_ADDR_VAR 0 4
31694: PUSH
31695: LD_VAR 0 1
31699: ST_TO_ADDR
// end ;
31700: LD_VAR 0 4
31704: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31705: LD_INT 0
31707: PPUSH
31708: PPUSH
// for i = 1 to values do
31709: LD_ADDR_VAR 0 4
31713: PUSH
31714: DOUBLE
31715: LD_INT 1
31717: DEC
31718: ST_TO_ADDR
31719: LD_VAR 0 2
31723: PUSH
31724: FOR_TO
31725: IFFALSE 31758
// tab := Remove ( tab , values [ i ] , false ) ;
31727: LD_ADDR_VAR 0 1
31731: PUSH
31732: LD_VAR 0 1
31736: PPUSH
31737: LD_VAR 0 2
31741: PUSH
31742: LD_VAR 0 4
31746: ARRAY
31747: PPUSH
31748: LD_INT 0
31750: PPUSH
31751: CALL 31291 0 3
31755: ST_TO_ADDR
31756: GO 31724
31758: POP
31759: POP
// result := tab ;
31760: LD_ADDR_VAR 0 3
31764: PUSH
31765: LD_VAR 0 1
31769: ST_TO_ADDR
// end ;
31770: LD_VAR 0 3
31774: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31775: LD_INT 0
31777: PPUSH
31778: PPUSH
31779: PPUSH
// if not GetControl ( veh ) = control_manual then
31780: LD_VAR 0 1
31784: PPUSH
31785: CALL_OW 263
31789: PUSH
31790: LD_INT 1
31792: EQUAL
31793: NOT
31794: IFFALSE 31806
// result := false else
31796: LD_ADDR_VAR 0 2
31800: PUSH
31801: LD_INT 0
31803: ST_TO_ADDR
31804: GO 31951
// if veh in FilterAllUnits ( [ f_empty ] ) then
31806: LD_VAR 0 1
31810: PUSH
31811: LD_INT 58
31813: PUSH
31814: EMPTY
31815: LIST
31816: PPUSH
31817: CALL_OW 69
31821: IN
31822: IFFALSE 31834
// result := false else
31824: LD_ADDR_VAR 0 2
31828: PUSH
31829: LD_INT 0
31831: ST_TO_ADDR
31832: GO 31951
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31834: LD_ADDR_VAR 0 4
31838: PUSH
31839: LD_INT 22
31841: PUSH
31842: LD_VAR 0 1
31846: PPUSH
31847: CALL_OW 255
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 55
31858: PUSH
31859: EMPTY
31860: LIST
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PPUSH
31866: CALL_OW 69
31870: ST_TO_ADDR
// if not filter then
31871: LD_VAR 0 4
31875: NOT
31876: IFFALSE 31888
// result := false else
31878: LD_ADDR_VAR 0 2
31882: PUSH
31883: LD_INT 0
31885: ST_TO_ADDR
31886: GO 31951
// for i = 1 to filter do
31888: LD_ADDR_VAR 0 3
31892: PUSH
31893: DOUBLE
31894: LD_INT 1
31896: DEC
31897: ST_TO_ADDR
31898: LD_VAR 0 4
31902: PUSH
31903: FOR_TO
31904: IFFALSE 31949
// if IsDriver ( filter [ i ] ) = veh then
31906: LD_VAR 0 4
31910: PUSH
31911: LD_VAR 0 3
31915: ARRAY
31916: PPUSH
31917: CALL 95589 0 1
31921: PUSH
31922: LD_VAR 0 1
31926: EQUAL
31927: IFFALSE 31947
// begin result := filter [ i ] ;
31929: LD_ADDR_VAR 0 2
31933: PUSH
31934: LD_VAR 0 4
31938: PUSH
31939: LD_VAR 0 3
31943: ARRAY
31944: ST_TO_ADDR
// break ;
31945: GO 31949
// end ;
31947: GO 31903
31949: POP
31950: POP
// end ; end ;
31951: LD_VAR 0 2
31955: RET
// export function Compare ( val1 , val2 ) ; begin
31956: LD_INT 0
31958: PPUSH
// if val1 = val2 then
31959: LD_VAR 0 1
31963: PUSH
31964: LD_VAR 0 2
31968: EQUAL
31969: IFFALSE 31981
// result := true else
31971: LD_ADDR_VAR 0 3
31975: PUSH
31976: LD_INT 1
31978: ST_TO_ADDR
31979: GO 31989
// result := false ;
31981: LD_ADDR_VAR 0 3
31985: PUSH
31986: LD_INT 0
31988: ST_TO_ADDR
// end ;
31989: LD_VAR 0 3
31993: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31994: LD_INT 0
31996: PPUSH
31997: PPUSH
// result := false ;
31998: LD_ADDR_VAR 0 3
32002: PUSH
32003: LD_INT 0
32005: ST_TO_ADDR
// for j = 1 to e2 do
32006: LD_ADDR_VAR 0 4
32010: PUSH
32011: DOUBLE
32012: LD_INT 1
32014: DEC
32015: ST_TO_ADDR
32016: LD_VAR 0 2
32020: PUSH
32021: FOR_TO
32022: IFFALSE 32056
// if Compare ( e1 , e2 [ j ] ) then
32024: LD_VAR 0 1
32028: PPUSH
32029: LD_VAR 0 2
32033: PUSH
32034: LD_VAR 0 4
32038: ARRAY
32039: PPUSH
32040: CALL 31956 0 2
32044: IFFALSE 32054
// result := true ;
32046: LD_ADDR_VAR 0 3
32050: PUSH
32051: LD_INT 1
32053: ST_TO_ADDR
32054: GO 32021
32056: POP
32057: POP
// end ;
32058: LD_VAR 0 3
32062: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32063: LD_INT 0
32065: PPUSH
32066: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32067: LD_VAR 0 1
32071: PPUSH
32072: LD_STRING C
32074: PUSH
32075: LD_VAR 0 2
32079: PUSH
32080: LD_VAR 0 3
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: LD_INT 0
32090: PUSH
32091: LD_INT 0
32093: PUSH
32094: LD_INT 0
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: PUSH
32106: LD_STRING v
32108: PUSH
32109: LD_VAR 0 4
32113: PPUSH
32114: CALL_OW 250
32118: PUSH
32119: LD_VAR 0 4
32123: PPUSH
32124: CALL_OW 251
32128: PUSH
32129: LD_VAR 0 4
32133: PUSH
32134: LD_INT 0
32136: PUSH
32137: LD_INT 0
32139: PUSH
32140: LD_INT 0
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PPUSH
32156: CALL_OW 446
// end ;
32160: LD_VAR 0 5
32164: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32165: LD_INT 0
32167: PPUSH
32168: PPUSH
32169: PPUSH
// linked := UnitsLinked ( unit ) ;
32170: LD_ADDR_VAR 0 4
32174: PUSH
32175: LD_VAR 0 1
32179: PPUSH
32180: CALL_OW 432
32184: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32185: LD_ADDR_VAR 0 3
32189: PUSH
32190: LD_VAR 0 1
32194: PPUSH
32195: LD_INT 3
32197: PPUSH
32198: CALL_OW 259
32202: ST_TO_ADDR
// if sk > linked then
32203: LD_VAR 0 3
32207: PUSH
32208: LD_VAR 0 4
32212: GREATER
32213: IFFALSE 32225
// result := true else
32215: LD_ADDR_VAR 0 2
32219: PUSH
32220: LD_INT 1
32222: ST_TO_ADDR
32223: GO 32233
// result := false ;
32225: LD_ADDR_VAR 0 2
32229: PUSH
32230: LD_INT 0
32232: ST_TO_ADDR
// end ;
32233: LD_VAR 0 2
32237: RET
// export function NotTask ( unit ) ; begin
32238: LD_INT 0
32240: PPUSH
// result := true ;
32241: LD_ADDR_VAR 0 2
32245: PUSH
32246: LD_INT 1
32248: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 437
32258: PUSH
32259: LD_VAR 0 1
32263: PPUSH
32264: CALL_OW 314
32268: OR
32269: IFFALSE 32279
// result := false ;
32271: LD_ADDR_VAR 0 2
32275: PUSH
32276: LD_INT 0
32278: ST_TO_ADDR
// end ;
32279: LD_VAR 0 2
32283: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32284: LD_INT 0
32286: PPUSH
32287: PPUSH
32288: PPUSH
32289: PPUSH
32290: PPUSH
// dist := 99999 ;
32291: LD_ADDR_VAR 0 7
32295: PUSH
32296: LD_INT 99999
32298: ST_TO_ADDR
// un := - 1 ;
32299: LD_ADDR_VAR 0 6
32303: PUSH
32304: LD_INT 1
32306: NEG
32307: ST_TO_ADDR
// if units1 and units2 then
32308: LD_VAR 0 1
32312: PUSH
32313: LD_VAR 0 2
32317: AND
32318: IFFALSE 32406
// for i in units1 do
32320: LD_ADDR_VAR 0 4
32324: PUSH
32325: LD_VAR 0 1
32329: PUSH
32330: FOR_IN
32331: IFFALSE 32404
// for j in units2 do
32333: LD_ADDR_VAR 0 5
32337: PUSH
32338: LD_VAR 0 2
32342: PUSH
32343: FOR_IN
32344: IFFALSE 32400
// if GetDistUnits ( i , j ) < dist then
32346: LD_VAR 0 4
32350: PPUSH
32351: LD_VAR 0 5
32355: PPUSH
32356: CALL_OW 296
32360: PUSH
32361: LD_VAR 0 7
32365: LESS
32366: IFFALSE 32398
// begin un := i ;
32368: LD_ADDR_VAR 0 6
32372: PUSH
32373: LD_VAR 0 4
32377: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32378: LD_ADDR_VAR 0 7
32382: PUSH
32383: LD_VAR 0 4
32387: PPUSH
32388: LD_VAR 0 5
32392: PPUSH
32393: CALL_OW 296
32397: ST_TO_ADDR
// end ;
32398: GO 32343
32400: POP
32401: POP
32402: GO 32330
32404: POP
32405: POP
// result := [ un , dist ] ;
32406: LD_ADDR_VAR 0 3
32410: PUSH
32411: LD_VAR 0 6
32415: PUSH
32416: LD_VAR 0 7
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: ST_TO_ADDR
// end ;
32425: LD_VAR 0 3
32429: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32430: LD_INT 0
32432: PPUSH
32433: PPUSH
32434: PPUSH
32435: PPUSH
32436: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32437: LD_VAR 0 1
32441: NOT
32442: PUSH
32443: LD_VAR 0 1
32447: PPUSH
32448: CALL_OW 256
32452: PUSH
32453: LD_INT 250
32455: LESS
32456: OR
32457: PUSH
32458: LD_VAR 0 1
32462: PPUSH
32463: CALL_OW 314
32467: PUSH
32468: LD_VAR 0 1
32472: PPUSH
32473: CALL_OW 261
32477: PUSH
32478: LD_INT 20
32480: GREATER
32481: AND
32482: OR
32483: IFFALSE 32487
// exit ;
32485: GO 32861
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32487: LD_VAR 0 1
32491: PPUSH
32492: CALL_OW 261
32496: PUSH
32497: LD_INT 20
32499: LESS
32500: PUSH
32501: LD_VAR 0 1
32505: PPUSH
32506: CALL_OW 110
32510: PUSH
32511: LD_INT 21
32513: EQUAL
32514: NOT
32515: AND
32516: IFFALSE 32552
// begin ComStop ( bulldozer ) ;
32518: LD_VAR 0 1
32522: PPUSH
32523: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32527: LD_VAR 0 1
32531: PPUSH
32532: LD_INT 21
32534: PPUSH
32535: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32539: LD_VAR 0 1
32543: PPUSH
32544: CALL 26294 0 1
// exit ;
32548: GO 32861
// end else
32550: GO 32579
// if GetFuel ( bulldozer ) > 20 then
32552: LD_VAR 0 1
32556: PPUSH
32557: CALL_OW 261
32561: PUSH
32562: LD_INT 20
32564: GREATER
32565: IFFALSE 32579
// SetTag ( bulldozer , 0 ) ;
32567: LD_VAR 0 1
32571: PPUSH
32572: LD_INT 0
32574: PPUSH
32575: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32579: LD_ADDR_VAR 0 5
32583: PUSH
32584: LD_VAR 0 2
32588: PPUSH
32589: CALL_OW 353
32593: ST_TO_ADDR
// tmp := [ ] ;
32594: LD_ADDR_VAR 0 6
32598: PUSH
32599: EMPTY
32600: ST_TO_ADDR
// for i = 1 to list do
32601: LD_ADDR_VAR 0 4
32605: PUSH
32606: DOUBLE
32607: LD_INT 1
32609: DEC
32610: ST_TO_ADDR
32611: LD_VAR 0 5
32615: PUSH
32616: FOR_TO
32617: IFFALSE 32715
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32619: LD_VAR 0 5
32623: PUSH
32624: LD_VAR 0 4
32628: ARRAY
32629: PUSH
32630: LD_INT 1
32632: ARRAY
32633: PPUSH
32634: LD_VAR 0 5
32638: PUSH
32639: LD_VAR 0 4
32643: ARRAY
32644: PUSH
32645: LD_INT 2
32647: ARRAY
32648: PPUSH
32649: CALL_OW 554
32653: IFFALSE 32713
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32655: LD_ADDR_VAR 0 6
32659: PUSH
32660: LD_VAR 0 6
32664: PPUSH
32665: LD_VAR 0 6
32669: PUSH
32670: LD_INT 1
32672: PLUS
32673: PPUSH
32674: LD_VAR 0 5
32678: PUSH
32679: LD_VAR 0 4
32683: ARRAY
32684: PUSH
32685: LD_INT 1
32687: ARRAY
32688: PUSH
32689: LD_VAR 0 5
32693: PUSH
32694: LD_VAR 0 4
32698: ARRAY
32699: PUSH
32700: LD_INT 2
32702: ARRAY
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PPUSH
32708: CALL_OW 1
32712: ST_TO_ADDR
// end ;
32713: GO 32616
32715: POP
32716: POP
// ComStop ( bulldozer ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32726: LD_ADDR_VAR 0 7
32730: PUSH
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 250
32740: PUSH
32741: LD_VAR 0 1
32745: PPUSH
32746: CALL_OW 251
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: ST_TO_ADDR
// for i = tmp downto 1 do
32755: LD_ADDR_VAR 0 4
32759: PUSH
32760: DOUBLE
32761: LD_VAR 0 6
32765: INC
32766: ST_TO_ADDR
32767: LD_INT 1
32769: PUSH
32770: FOR_DOWNTO
32771: IFFALSE 32859
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32773: LD_ADDR_VAR 0 7
32777: PUSH
32778: LD_VAR 0 7
32782: PUSH
32783: LD_INT 1
32785: ARRAY
32786: PPUSH
32787: LD_VAR 0 7
32791: PUSH
32792: LD_INT 2
32794: ARRAY
32795: PPUSH
32796: LD_VAR 0 6
32800: PPUSH
32801: CALL 32962 0 3
32805: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32806: LD_VAR 0 1
32810: PPUSH
32811: LD_VAR 0 7
32815: PUSH
32816: LD_INT 1
32818: ARRAY
32819: PPUSH
32820: LD_VAR 0 7
32824: PUSH
32825: LD_INT 2
32827: ARRAY
32828: PPUSH
32829: CALL 32866 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32833: LD_ADDR_VAR 0 6
32837: PUSH
32838: LD_VAR 0 6
32842: PPUSH
32843: LD_VAR 0 7
32847: PUSH
32848: LD_INT 3
32850: ARRAY
32851: PPUSH
32852: CALL_OW 3
32856: ST_TO_ADDR
// end ;
32857: GO 32770
32859: POP
32860: POP
// end ;
32861: LD_VAR 0 3
32865: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32866: LD_INT 0
32868: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32869: LD_VAR 0 2
32873: PPUSH
32874: LD_VAR 0 3
32878: PPUSH
32879: CALL_OW 351
32883: PUSH
32884: LD_VAR 0 2
32888: PPUSH
32889: LD_VAR 0 3
32893: PPUSH
32894: CALL_OW 554
32898: AND
32899: PUSH
32900: LD_VAR 0 2
32904: PPUSH
32905: LD_VAR 0 3
32909: PPUSH
32910: CALL_OW 488
32914: AND
32915: PUSH
32916: LD_VAR 0 2
32920: PPUSH
32921: LD_VAR 0 3
32925: PPUSH
32926: CALL_OW 428
32930: PUSH
32931: LD_INT 1
32933: NEG
32934: EQUAL
32935: AND
32936: IFFALSE 32957
// AddComMoveXY ( bulldozer , x , y ) ;
32938: LD_VAR 0 1
32942: PPUSH
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_VAR 0 3
32952: PPUSH
32953: CALL_OW 171
// end ;
32957: LD_VAR 0 4
32961: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32962: LD_INT 0
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
32969: PPUSH
32970: PPUSH
// dist := 99999 ;
32971: LD_ADDR_VAR 0 6
32975: PUSH
32976: LD_INT 99999
32978: ST_TO_ADDR
// for i = 1 to list do
32979: LD_ADDR_VAR 0 5
32983: PUSH
32984: DOUBLE
32985: LD_INT 1
32987: DEC
32988: ST_TO_ADDR
32989: LD_VAR 0 3
32993: PUSH
32994: FOR_TO
32995: IFFALSE 33133
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32997: LD_ADDR_VAR 0 7
33001: PUSH
33002: LD_VAR 0 1
33006: PPUSH
33007: LD_VAR 0 2
33011: PPUSH
33012: LD_VAR 0 3
33016: PUSH
33017: LD_VAR 0 5
33021: ARRAY
33022: PUSH
33023: LD_INT 1
33025: ARRAY
33026: PPUSH
33027: LD_VAR 0 3
33031: PUSH
33032: LD_VAR 0 5
33036: ARRAY
33037: PUSH
33038: LD_INT 2
33040: ARRAY
33041: PPUSH
33042: CALL_OW 298
33046: ST_TO_ADDR
// if d = 0 then
33047: LD_VAR 0 7
33051: PUSH
33052: LD_INT 0
33054: EQUAL
33055: IFFALSE 33059
// continue ;
33057: GO 32994
// if d < dist then
33059: LD_VAR 0 7
33063: PUSH
33064: LD_VAR 0 6
33068: LESS
33069: IFFALSE 33131
// begin _x := list [ i ] [ 1 ] ;
33071: LD_ADDR_VAR 0 8
33075: PUSH
33076: LD_VAR 0 3
33080: PUSH
33081: LD_VAR 0 5
33085: ARRAY
33086: PUSH
33087: LD_INT 1
33089: ARRAY
33090: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33091: LD_ADDR_VAR 0 9
33095: PUSH
33096: LD_VAR 0 3
33100: PUSH
33101: LD_VAR 0 5
33105: ARRAY
33106: PUSH
33107: LD_INT 2
33109: ARRAY
33110: ST_TO_ADDR
// _i := i ;
33111: LD_ADDR_VAR 0 10
33115: PUSH
33116: LD_VAR 0 5
33120: ST_TO_ADDR
// dist := d ;
33121: LD_ADDR_VAR 0 6
33125: PUSH
33126: LD_VAR 0 7
33130: ST_TO_ADDR
// end ; end ;
33131: GO 32994
33133: POP
33134: POP
// result := [ _x , _y , _i , dist ] ;
33135: LD_ADDR_VAR 0 4
33139: PUSH
33140: LD_VAR 0 8
33144: PUSH
33145: LD_VAR 0 9
33149: PUSH
33150: LD_VAR 0 10
33154: PUSH
33155: LD_VAR 0 6
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: ST_TO_ADDR
// end ;
33166: LD_VAR 0 4
33170: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33171: LD_INT 0
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
// for i = 1 to list do
33178: LD_ADDR_VAR 0 5
33182: PUSH
33183: DOUBLE
33184: LD_INT 1
33186: DEC
33187: ST_TO_ADDR
33188: LD_VAR 0 1
33192: PUSH
33193: FOR_TO
33194: IFFALSE 33508
// begin for j = list downto 2 do
33196: LD_ADDR_VAR 0 6
33200: PUSH
33201: DOUBLE
33202: LD_VAR 0 1
33206: INC
33207: ST_TO_ADDR
33208: LD_INT 2
33210: PUSH
33211: FOR_DOWNTO
33212: IFFALSE 33504
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33214: LD_VAR 0 2
33218: PPUSH
33219: LD_VAR 0 3
33223: PPUSH
33224: LD_VAR 0 1
33228: PUSH
33229: LD_VAR 0 6
33233: ARRAY
33234: PUSH
33235: LD_INT 1
33237: ARRAY
33238: PPUSH
33239: LD_VAR 0 1
33243: PUSH
33244: LD_VAR 0 6
33248: ARRAY
33249: PUSH
33250: LD_INT 2
33252: ARRAY
33253: PPUSH
33254: CALL_OW 298
33258: PUSH
33259: LD_VAR 0 2
33263: PPUSH
33264: LD_VAR 0 3
33268: PPUSH
33269: LD_VAR 0 1
33273: PUSH
33274: LD_VAR 0 6
33278: PUSH
33279: LD_INT 1
33281: MINUS
33282: ARRAY
33283: PUSH
33284: LD_INT 1
33286: ARRAY
33287: PPUSH
33288: LD_VAR 0 1
33292: PUSH
33293: LD_VAR 0 6
33297: PUSH
33298: LD_INT 1
33300: MINUS
33301: ARRAY
33302: PUSH
33303: LD_INT 2
33305: ARRAY
33306: PPUSH
33307: CALL_OW 298
33311: LESS
33312: IFFALSE 33502
// begin _x := list [ j ] [ 1 ] ;
33314: LD_ADDR_VAR 0 7
33318: PUSH
33319: LD_VAR 0 1
33323: PUSH
33324: LD_VAR 0 6
33328: ARRAY
33329: PUSH
33330: LD_INT 1
33332: ARRAY
33333: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33334: LD_ADDR_VAR 0 8
33338: PUSH
33339: LD_VAR 0 1
33343: PUSH
33344: LD_VAR 0 6
33348: ARRAY
33349: PUSH
33350: LD_INT 2
33352: ARRAY
33353: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33354: LD_ADDR_VAR 0 1
33358: PUSH
33359: LD_VAR 0 1
33363: PPUSH
33364: LD_VAR 0 6
33368: PPUSH
33369: LD_INT 1
33371: PPUSH
33372: LD_VAR 0 1
33376: PUSH
33377: LD_VAR 0 6
33381: PUSH
33382: LD_INT 1
33384: MINUS
33385: ARRAY
33386: PUSH
33387: LD_INT 1
33389: ARRAY
33390: PPUSH
33391: CALL 31132 0 4
33395: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33396: LD_ADDR_VAR 0 1
33400: PUSH
33401: LD_VAR 0 1
33405: PPUSH
33406: LD_VAR 0 6
33410: PPUSH
33411: LD_INT 2
33413: PPUSH
33414: LD_VAR 0 1
33418: PUSH
33419: LD_VAR 0 6
33423: PUSH
33424: LD_INT 1
33426: MINUS
33427: ARRAY
33428: PUSH
33429: LD_INT 2
33431: ARRAY
33432: PPUSH
33433: CALL 31132 0 4
33437: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33438: LD_ADDR_VAR 0 1
33442: PUSH
33443: LD_VAR 0 1
33447: PPUSH
33448: LD_VAR 0 6
33452: PUSH
33453: LD_INT 1
33455: MINUS
33456: PPUSH
33457: LD_INT 1
33459: PPUSH
33460: LD_VAR 0 7
33464: PPUSH
33465: CALL 31132 0 4
33469: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33470: LD_ADDR_VAR 0 1
33474: PUSH
33475: LD_VAR 0 1
33479: PPUSH
33480: LD_VAR 0 6
33484: PUSH
33485: LD_INT 1
33487: MINUS
33488: PPUSH
33489: LD_INT 2
33491: PPUSH
33492: LD_VAR 0 8
33496: PPUSH
33497: CALL 31132 0 4
33501: ST_TO_ADDR
// end ; end ;
33502: GO 33211
33504: POP
33505: POP
// end ;
33506: GO 33193
33508: POP
33509: POP
// result := list ;
33510: LD_ADDR_VAR 0 4
33514: PUSH
33515: LD_VAR 0 1
33519: ST_TO_ADDR
// end ;
33520: LD_VAR 0 4
33524: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33525: LD_INT 0
33527: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33528: LD_ADDR_VAR 0 5
33532: PUSH
33533: LD_VAR 0 1
33537: PPUSH
33538: LD_VAR 0 2
33542: PPUSH
33543: CALL_OW 546
33547: PUSH
33548: LD_INT 2
33550: ARRAY
33551: PUSH
33552: LD_VAR 0 3
33556: PPUSH
33557: LD_VAR 0 4
33561: PPUSH
33562: CALL_OW 546
33566: PUSH
33567: LD_INT 2
33569: ARRAY
33570: MINUS
33571: ST_TO_ADDR
// if result < 0 then
33572: LD_VAR 0 5
33576: PUSH
33577: LD_INT 0
33579: LESS
33580: IFFALSE 33597
// result := result * - 1 ;
33582: LD_ADDR_VAR 0 5
33586: PUSH
33587: LD_VAR 0 5
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: MUL
33596: ST_TO_ADDR
// end ;
33597: LD_VAR 0 5
33601: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33602: LD_INT 0
33604: PPUSH
33605: PPUSH
// area = ListEnvironmentArea ( area ) ;
33606: LD_ADDR_VAR 0 2
33610: PUSH
33611: LD_VAR 0 2
33615: PPUSH
33616: CALL_OW 353
33620: ST_TO_ADDR
// if bulldozer > 0 then
33621: LD_VAR 0 1
33625: PUSH
33626: LD_INT 0
33628: GREATER
33629: IFFALSE 33740
// for i = area downto 1 do
33631: LD_ADDR_VAR 0 4
33635: PUSH
33636: DOUBLE
33637: LD_VAR 0 2
33641: INC
33642: ST_TO_ADDR
33643: LD_INT 1
33645: PUSH
33646: FOR_DOWNTO
33647: IFFALSE 33738
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33649: LD_VAR 0 2
33653: PUSH
33654: LD_VAR 0 4
33658: ARRAY
33659: PUSH
33660: LD_INT 1
33662: ARRAY
33663: PPUSH
33664: LD_VAR 0 2
33668: PUSH
33669: LD_VAR 0 4
33673: ARRAY
33674: PUSH
33675: LD_INT 2
33677: ARRAY
33678: PPUSH
33679: CALL_OW 351
33683: IFFALSE 33736
// if not HasTask ( bulldozer ) then
33685: LD_VAR 0 1
33689: PPUSH
33690: CALL_OW 314
33694: NOT
33695: IFFALSE 33736
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33697: LD_VAR 0 1
33701: PPUSH
33702: LD_VAR 0 2
33706: PUSH
33707: LD_VAR 0 4
33711: ARRAY
33712: PUSH
33713: LD_INT 1
33715: ARRAY
33716: PPUSH
33717: LD_VAR 0 2
33721: PUSH
33722: LD_VAR 0 4
33726: ARRAY
33727: PUSH
33728: LD_INT 2
33730: ARRAY
33731: PPUSH
33732: CALL_OW 171
33736: GO 33646
33738: POP
33739: POP
// end ;
33740: LD_VAR 0 3
33744: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33745: LD_INT 0
33747: PPUSH
33748: PPUSH
33749: PPUSH
33750: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33751: LD_ADDR_VAR 0 6
33755: PUSH
33756: LD_INT 22
33758: PUSH
33759: LD_VAR 0 1
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 21
33770: PUSH
33771: LD_VAR 0 2
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PPUSH
33784: CALL_OW 69
33788: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33789: LD_ADDR_VAR 0 7
33793: PUSH
33794: LD_VAR 0 3
33798: PPUSH
33799: LD_INT 22
33801: PUSH
33802: LD_VAR 0 1
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 21
33813: PUSH
33814: LD_VAR 0 2
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PPUSH
33827: CALL_OW 70
33831: ST_TO_ADDR
// if tmp and pom then
33832: LD_VAR 0 6
33836: PUSH
33837: LD_VAR 0 7
33841: AND
33842: IFFALSE 33862
// result := tmp diff pom else
33844: LD_ADDR_VAR 0 4
33848: PUSH
33849: LD_VAR 0 6
33853: PUSH
33854: LD_VAR 0 7
33858: DIFF
33859: ST_TO_ADDR
33860: GO 33870
// result := false ;
33862: LD_ADDR_VAR 0 4
33866: PUSH
33867: LD_INT 0
33869: ST_TO_ADDR
// end ;
33870: LD_VAR 0 4
33874: RET
// export function SavePosition ( unit ) ; begin
33875: LD_INT 0
33877: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33878: LD_VAR 0 1
33882: PPUSH
33883: LD_VAR 0 1
33887: PPUSH
33888: CALL_OW 250
33892: PPUSH
33893: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33897: LD_VAR 0 1
33901: PPUSH
33902: LD_VAR 0 1
33906: PPUSH
33907: CALL_OW 251
33911: PPUSH
33912: CALL_OW 232
// end ;
33916: LD_VAR 0 2
33920: RET
// export function GetPosition ( unit ) ; begin
33921: LD_INT 0
33923: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33924: LD_ADDR_VAR 0 2
33928: PUSH
33929: LD_VAR 0 1
33933: PPUSH
33934: CALL_OW 252
33938: PUSH
33939: LD_VAR 0 1
33943: PPUSH
33944: CALL_OW 253
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: ST_TO_ADDR
// end ;
33953: LD_VAR 0 2
33957: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33958: LD_INT 0
33960: PPUSH
// if unit in unreachableList then
33961: LD_VAR 0 1
33965: PUSH
33966: LD_EXP 30
33970: IN
33971: IFFALSE 33989
// unreachableList := unreachableList diff unit ;
33973: LD_ADDR_EXP 30
33977: PUSH
33978: LD_EXP 30
33982: PUSH
33983: LD_VAR 0 1
33987: DIFF
33988: ST_TO_ADDR
// if ValidHex ( x , y ) then
33989: LD_VAR 0 2
33993: PPUSH
33994: LD_VAR 0 3
33998: PPUSH
33999: CALL_OW 488
34003: IFFALSE 34029
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34005: LD_VAR 0 1
34009: PPUSH
34010: LD_VAR 0 2
34014: PPUSH
34015: LD_VAR 0 3
34019: PPUSH
34020: CALL_OW 428
34024: PPUSH
34025: CALL_OW 115
// Wait ( 3 ) ;
34029: LD_INT 3
34031: PPUSH
34032: CALL_OW 67
// if unit in unreachableList then
34036: LD_VAR 0 1
34040: PUSH
34041: LD_EXP 30
34045: IN
34046: IFFALSE 34058
// result := false else
34048: LD_ADDR_VAR 0 4
34052: PUSH
34053: LD_INT 0
34055: ST_TO_ADDR
34056: GO 34066
// result := true ;
34058: LD_ADDR_VAR 0 4
34062: PUSH
34063: LD_INT 1
34065: ST_TO_ADDR
// end ; end_of_file
34066: LD_VAR 0 4
34070: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34071: LD_EXP 31
34075: IFFALSE 34137
34077: GO 34079
34079: DISABLE
34080: LD_INT 0
34082: PPUSH
// begin enable ;
34083: ENABLE
// for i = 1 to mc_crates_list do
34084: LD_ADDR_VAR 0 1
34088: PUSH
34089: DOUBLE
34090: LD_INT 1
34092: DEC
34093: ST_TO_ADDR
34094: LD_EXP 32
34098: PUSH
34099: FOR_TO
34100: IFFALSE 34131
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34102: LD_EXP 32
34106: PUSH
34107: LD_VAR 0 1
34111: ARRAY
34112: PPUSH
34113: LD_INT 5
34115: PPUSH
34116: LD_INT 50
34118: PPUSH
34119: LD_INT 700
34121: PPUSH
34122: LD_INT 20
34124: PPUSH
34125: CALL 24501 0 5
34129: GO 34099
34131: POP
34132: POP
// MC_Game ( ) ;
34133: CALL 34140 0 0
// end ;
34137: PPOPN 1
34139: END
// export function MC_Game ( ) ; var i , side , un ; begin
34140: LD_INT 0
34142: PPUSH
34143: PPUSH
34144: PPUSH
34145: PPUSH
// if not isTest then
34146: LD_EXP 1
34150: NOT
34151: IFFALSE 34171
// MC_Show ( [ #tick , tick ] ) else
34153: LD_STRING #tick
34155: PUSH
34156: LD_OWVAR 1
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PPUSH
34165: CALL 8585 0 1
34169: GO 34180
// MC_Show ( debug_string ) ;
34171: LD_EXP 2
34175: PPUSH
34176: CALL 8585 0 1
// for side = 1 to 8 do
34180: LD_ADDR_VAR 0 3
34184: PUSH
34185: DOUBLE
34186: LD_INT 1
34188: DEC
34189: ST_TO_ADDR
34190: LD_INT 8
34192: PUSH
34193: FOR_TO
34194: IFFALSE 36194
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34196: LD_EXP 39
34200: PUSH
34201: LD_VAR 0 3
34205: ARRAY
34206: PUSH
34207: LD_INT 0
34209: EQUAL
34210: PUSH
34211: LD_VAR 0 3
34215: PPUSH
34216: EMPTY
34217: PPUSH
34218: CALL 11802 0 2
34222: PUSH
34223: LD_INT 0
34225: EQUAL
34226: OR
34227: IFFALSE 34231
// continue ;
34229: GO 34193
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34231: LD_VAR 0 3
34235: PPUSH
34236: LD_VAR 0 3
34240: PPUSH
34241: CALL 25022 0 1
34245: PPUSH
34246: CALL 36201 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34250: LD_EXP 71
34254: PUSH
34255: LD_VAR 0 3
34259: ARRAY
34260: PUSH
34261: LD_INT 1
34263: ARRAY
34264: PUSH
34265: LD_INT 0
34267: GREATER
34268: PUSH
34269: LD_EXP 69
34273: PUSH
34274: LD_VAR 0 3
34278: ARRAY
34279: PUSH
34280: LD_INT 1
34282: ARRAY
34283: PUSH
34284: LD_INT 0
34286: EQUAL
34287: AND
34288: PUSH
34289: LD_VAR 0 3
34293: PPUSH
34294: LD_INT 7
34296: PPUSH
34297: EMPTY
34298: PPUSH
34299: CALL 12370 0 3
34303: NOT
34304: AND
34305: IFFALSE 34342
// begin for i in MREG_Attackers [ side ] do
34307: LD_ADDR_VAR 0 2
34311: PUSH
34312: LD_EXP 71
34316: PUSH
34317: LD_VAR 0 3
34321: ARRAY
34322: PUSH
34323: FOR_IN
34324: IFFALSE 34340
// SetTag ( i , 7 ) ;
34326: LD_VAR 0 2
34330: PPUSH
34331: LD_INT 7
34333: PPUSH
34334: CALL_OW 109
34338: GO 34323
34340: POP
34341: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34342: LD_VAR 0 3
34346: PPUSH
34347: LD_INT 7
34349: PPUSH
34350: EMPTY
34351: PPUSH
34352: CALL 12370 0 3
34356: IFFALSE 34416
// begin if side = 1 then
34358: LD_VAR 0 3
34362: PUSH
34363: LD_INT 1
34365: EQUAL
34366: IFFALSE 34375
// RaiseSailEvent ( 101 ) ;
34368: LD_INT 101
34370: PPUSH
34371: CALL_OW 427
// if side = 4 then
34375: LD_VAR 0 3
34379: PUSH
34380: LD_INT 4
34382: EQUAL
34383: IFFALSE 34392
// RaiseSailEvent ( 102 ) ;
34385: LD_INT 102
34387: PPUSH
34388: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34392: LD_VAR 0 3
34396: PPUSH
34397: LD_VAR 0 3
34401: PPUSH
34402: LD_INT 7
34404: PPUSH
34405: EMPTY
34406: PPUSH
34407: CALL 12370 0 3
34411: PPUSH
34412: CALL 8503 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34416: LD_VAR 0 3
34420: PPUSH
34421: CALL 18050 0 1
34425: PUSH
34426: LD_VAR 0 3
34430: PPUSH
34431: CALL 11706 0 1
34435: AND
34436: IFFALSE 34447
// MCL_Start ( side ) ;
34438: LD_VAR 0 3
34442: PPUSH
34443: CALL 18007 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34447: LD_ADDR_EXP 35
34451: PUSH
34452: LD_EXP 35
34456: PPUSH
34457: LD_VAR 0 3
34461: PPUSH
34462: LD_VAR 0 3
34466: PPUSH
34467: CALL 19307 0 1
34471: PPUSH
34472: CALL_OW 1
34476: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34477: LD_ADDR_EXP 47
34481: PUSH
34482: LD_EXP 47
34486: PPUSH
34487: LD_VAR 0 3
34491: PPUSH
34492: LD_VAR 0 3
34496: PPUSH
34497: CALL 11120 0 1
34501: PPUSH
34502: CALL_OW 1
34506: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34507: LD_VAR 0 3
34511: PPUSH
34512: LD_INT 21
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PPUSH
34522: CALL 11667 0 2
34526: IFFALSE 34537
// MCV_CheckStatus ( side ) ;
34528: LD_VAR 0 3
34532: PPUSH
34533: CALL 27204 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34537: LD_VAR 0 3
34541: PPUSH
34542: LD_EXP 53
34546: PPUSH
34547: CALL 43001 0 2
34551: IFFALSE 34636
// begin for i = MREG_ToChangeClass downto 1 do
34553: LD_ADDR_VAR 0 2
34557: PUSH
34558: DOUBLE
34559: LD_EXP 53
34563: INC
34564: ST_TO_ADDR
34565: LD_INT 1
34567: PUSH
34568: FOR_DOWNTO
34569: IFFALSE 34634
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34571: LD_EXP 53
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: PUSH
34582: LD_INT 1
34584: ARRAY
34585: PUSH
34586: LD_VAR 0 3
34590: EQUAL
34591: IFFALSE 34632
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34593: LD_VAR 0 3
34597: PPUSH
34598: LD_EXP 53
34602: PUSH
34603: LD_VAR 0 2
34607: ARRAY
34608: PUSH
34609: LD_INT 2
34611: ARRAY
34612: PPUSH
34613: LD_EXP 53
34617: PUSH
34618: LD_VAR 0 2
34622: ARRAY
34623: PUSH
34624: LD_INT 3
34626: ARRAY
34627: PPUSH
34628: CALL 16574 0 3
// end ; end ;
34632: GO 34568
34634: POP
34635: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34636: LD_INT 1
34638: PUSH
34639: LD_EXP 38
34643: PUSH
34644: LD_VAR 0 3
34648: ARRAY
34649: IN
34650: IFFALSE 34661
// begin MCN_TrainApe ( side ) ;
34652: LD_VAR 0 3
34656: PPUSH
34657: CALL 18960 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34661: LD_VAR 0 3
34665: PPUSH
34666: LD_INT 30
34668: PUSH
34669: LD_INT 3
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PPUSH
34676: CALL 11667 0 2
34680: IFFALSE 34854
// begin if MCF_Tag ( side , 10 , [ ] ) then
34682: LD_VAR 0 3
34686: PPUSH
34687: LD_INT 10
34689: PPUSH
34690: EMPTY
34691: PPUSH
34692: CALL 12370 0 3
34696: IFFALSE 34743
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34698: LD_VAR 0 3
34702: PPUSH
34703: LD_INT 10
34705: PPUSH
34706: EMPTY
34707: PPUSH
34708: CALL 12370 0 3
34712: PPUSH
34713: LD_VAR 0 3
34717: PPUSH
34718: LD_INT 30
34720: PUSH
34721: LD_INT 3
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PPUSH
34728: CALL 11667 0 2
34732: PUSH
34733: LD_INT 1
34735: ARRAY
34736: PPUSH
34737: CALL_OW 168
// end else
34741: GO 34854
// if MREG_ToConstruct [ side ] then
34743: LD_EXP 51
34747: PUSH
34748: LD_VAR 0 3
34752: ARRAY
34753: IFFALSE 34854
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34755: LD_VAR 0 3
34759: PPUSH
34760: LD_VAR 0 3
34764: PPUSH
34765: LD_INT 30
34767: PUSH
34768: LD_INT 3
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PPUSH
34775: CALL 11667 0 2
34779: PUSH
34780: LD_INT 1
34782: ARRAY
34783: PPUSH
34784: LD_EXP 51
34788: PUSH
34789: LD_VAR 0 3
34793: ARRAY
34794: PUSH
34795: LD_INT 1
34797: ARRAY
34798: PUSH
34799: LD_EXP 51
34803: PUSH
34804: LD_VAR 0 3
34808: ARRAY
34809: PUSH
34810: LD_INT 2
34812: ARRAY
34813: PUSH
34814: LD_EXP 51
34818: PUSH
34819: LD_VAR 0 3
34823: ARRAY
34824: PUSH
34825: LD_INT 3
34827: ARRAY
34828: PUSH
34829: LD_EXP 51
34833: PUSH
34834: LD_VAR 0 3
34838: ARRAY
34839: PUSH
34840: LD_INT 4
34842: ARRAY
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: LIST
34848: LIST
34849: PPUSH
34850: CALL 25512 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34854: LD_VAR 0 3
34858: PPUSH
34859: LD_INT 30
34861: PUSH
34862: LD_INT 3
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PPUSH
34869: CALL 11667 0 2
34873: PUSH
34874: LD_VAR 0 3
34878: PPUSH
34879: LD_EXP 43
34883: PPUSH
34884: CALL 43001 0 2
34888: AND
34889: PUSH
34890: LD_INT 22
34892: PUSH
34893: LD_VAR 0 3
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 2
34904: PUSH
34905: LD_INT 30
34907: PUSH
34908: LD_INT 33
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 30
34917: PUSH
34918: LD_INT 32
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 35
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: LIST
34944: PPUSH
34945: CALL_OW 69
34949: AND
34950: IFFALSE 34961
// MCV_Turret ( side ) ;
34952: LD_VAR 0 3
34956: PPUSH
34957: CALL 25949 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34961: LD_EXP 42
34965: PUSH
34966: LD_VAR 0 3
34970: ARRAY
34971: PUSH
34972: LD_INT 1
34974: GREATER
34975: PUSH
34976: LD_VAR 0 3
34980: PPUSH
34981: CALL 25022 0 1
34985: PUSH
34986: LD_INT 0
34988: EQUAL
34989: AND
34990: IFFALSE 35152
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34992: LD_EXP 42
34996: PUSH
34997: LD_VAR 0 3
35001: ARRAY
35002: PUSH
35003: LD_INT 1
35005: ARRAY
35006: PPUSH
35007: CALL_OW 353
35011: IFFALSE 35049
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35013: LD_EXP 42
35017: PUSH
35018: LD_VAR 0 3
35022: ARRAY
35023: PUSH
35024: LD_INT 2
35026: ARRAY
35027: PPUSH
35028: LD_EXP 42
35032: PUSH
35033: LD_VAR 0 3
35037: ARRAY
35038: PUSH
35039: LD_INT 1
35041: ARRAY
35042: PPUSH
35043: CALL 32430 0 2
35047: GO 35152
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35049: LD_VAR 0 3
35053: PPUSH
35054: LD_INT 30
35056: PUSH
35057: LD_INT 3
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PPUSH
35064: CALL 11667 0 2
35068: IFFALSE 35152
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35070: LD_VAR 0 3
35074: PPUSH
35075: LD_INT 30
35077: PUSH
35078: LD_INT 3
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PPUSH
35085: CALL 11667 0 2
35089: PUSH
35090: LD_INT 1
35092: ARRAY
35093: PPUSH
35094: CALL_OW 461
35098: PUSH
35099: LD_INT 2
35101: EQUAL
35102: IFFALSE 35152
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35104: LD_EXP 42
35108: PUSH
35109: LD_VAR 0 3
35113: ARRAY
35114: PUSH
35115: LD_INT 2
35117: ARRAY
35118: PPUSH
35119: LD_INT 10
35121: PPUSH
35122: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35126: LD_ADDR_EXP 42
35130: PUSH
35131: LD_EXP 42
35135: PPUSH
35136: LD_VAR 0 3
35140: PPUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: PPUSH
35147: CALL_OW 1
35151: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35152: LD_VAR 0 3
35156: PPUSH
35157: LD_INT 33
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PPUSH
35167: CALL 11667 0 2
35171: IFFALSE 35211
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35173: LD_VAR 0 3
35177: PPUSH
35178: LD_VAR 0 3
35182: PPUSH
35183: LD_INT 33
35185: PUSH
35186: LD_INT 2
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PPUSH
35193: CALL 11667 0 2
35197: PUSH
35198: LD_INT 1
35200: ARRAY
35201: PPUSH
35202: CALL_OW 248
35206: PPUSH
35207: CALL 26503 0 2
// if MREG_ToRepair [ side ] then
35211: LD_EXP 47
35215: PUSH
35216: LD_VAR 0 3
35220: ARRAY
35221: IFFALSE 35234
// begin MCB_Repair ( side ) ;
35223: LD_VAR 0 3
35227: PPUSH
35228: CALL 11407 0 1
// end else
35232: GO 36147
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35234: LD_VAR 0 3
35238: PPUSH
35239: LD_EXP 49
35243: PPUSH
35244: CALL 43001 0 2
35248: PUSH
35249: LD_VAR 0 3
35253: PPUSH
35254: LD_EXP 40
35258: PPUSH
35259: CALL 43001 0 2
35263: AND
35264: IFFALSE 35472
// begin for i = 1 to MREG_ToUpLab do
35266: LD_ADDR_VAR 0 2
35270: PUSH
35271: DOUBLE
35272: LD_INT 1
35274: DEC
35275: ST_TO_ADDR
35276: LD_EXP 49
35280: PUSH
35281: FOR_TO
35282: IFFALSE 35468
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35284: LD_EXP 49
35288: PUSH
35289: LD_VAR 0 2
35293: ARRAY
35294: PUSH
35295: LD_INT 1
35297: ARRAY
35298: PUSH
35299: LD_VAR 0 3
35303: EQUAL
35304: IFFALSE 35466
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35306: LD_EXP 49
35310: PUSH
35311: LD_VAR 0 2
35315: ARRAY
35316: PUSH
35317: LD_INT 2
35319: ARRAY
35320: PUSH
35321: LD_EXP 49
35325: PUSH
35326: LD_VAR 0 2
35330: ARRAY
35331: PUSH
35332: LD_INT 3
35334: ARRAY
35335: AND
35336: IFFALSE 35464
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35338: LD_VAR 0 3
35342: PPUSH
35343: LD_EXP 49
35347: PUSH
35348: LD_VAR 0 2
35352: ARRAY
35353: PUSH
35354: LD_INT 2
35356: ARRAY
35357: PPUSH
35358: LD_EXP 49
35362: PUSH
35363: LD_VAR 0 2
35367: ARRAY
35368: PUSH
35369: LD_INT 3
35371: ARRAY
35372: PPUSH
35373: CALL 8931 0 3
35377: IFFALSE 35464
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35379: LD_ADDR_EXP 49
35383: PUSH
35384: LD_EXP 49
35388: PPUSH
35389: LD_VAR 0 3
35393: PPUSH
35394: LD_EXP 49
35398: PUSH
35399: LD_VAR 0 2
35403: ARRAY
35404: PUSH
35405: LD_INT 2
35407: ARRAY
35408: PPUSH
35409: LD_EXP 49
35413: PUSH
35414: LD_VAR 0 2
35418: ARRAY
35419: PUSH
35420: LD_INT 3
35422: ARRAY
35423: PPUSH
35424: CALL 42053 0 4
35428: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35429: LD_ADDR_EXP 40
35433: PUSH
35434: LD_EXP 40
35438: PPUSH
35439: LD_VAR 0 3
35443: PPUSH
35444: LD_EXP 40
35448: PUSH
35449: LD_INT 1
35451: ARRAY
35452: PUSH
35453: LD_INT 2
35455: ARRAY
35456: PPUSH
35457: EMPTY
35458: PPUSH
35459: CALL 42053 0 4
35463: ST_TO_ADDR
// end ; break ;
35464: GO 35468
// end ;
35466: GO 35281
35468: POP
35469: POP
// end else
35470: GO 36147
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35472: LD_VAR 0 3
35476: PPUSH
35477: LD_EXP 48
35481: PPUSH
35482: CALL 43001 0 2
35486: IFFALSE 35560
// begin for i = 1 to MREG_ToUpdate do
35488: LD_ADDR_VAR 0 2
35492: PUSH
35493: DOUBLE
35494: LD_INT 1
35496: DEC
35497: ST_TO_ADDR
35498: LD_EXP 48
35502: PUSH
35503: FOR_TO
35504: IFFALSE 35556
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35506: LD_EXP 48
35510: PUSH
35511: LD_VAR 0 2
35515: ARRAY
35516: PUSH
35517: LD_INT 1
35519: ARRAY
35520: PUSH
35521: LD_VAR 0 3
35525: EQUAL
35526: IFFALSE 35554
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_EXP 48
35537: PUSH
35538: LD_VAR 0 2
35542: ARRAY
35543: PUSH
35544: LD_INT 2
35546: ARRAY
35547: PPUSH
35548: CALL 8767 0 2
// break ;
35552: GO 35556
// end ;
35554: GO 35503
35556: POP
35557: POP
// end else
35558: GO 36147
// if MCF_Get ( side , [ f_constructed ] ) then
35560: LD_VAR 0 3
35564: PPUSH
35565: LD_INT 57
35567: PUSH
35568: EMPTY
35569: LIST
35570: PPUSH
35571: CALL 11667 0 2
35575: IFFALSE 35608
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35577: LD_VAR 0 3
35581: PPUSH
35582: LD_VAR 0 3
35586: PPUSH
35587: LD_INT 57
35589: PUSH
35590: EMPTY
35591: LIST
35592: PPUSH
35593: CALL 11667 0 2
35597: PUSH
35598: LD_INT 1
35600: ARRAY
35601: PPUSH
35602: CALL 11011 0 2
35606: GO 36147
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35608: LD_VAR 0 3
35612: PPUSH
35613: LD_EXP 46
35617: PPUSH
35618: CALL 43001 0 2
35622: PUSH
35623: LD_VAR 0 3
35627: PPUSH
35628: CALL_OW 345
35632: NOT
35633: AND
35634: PUSH
35635: LD_VAR 0 3
35639: PPUSH
35640: CALL 25022 0 1
35644: PUSH
35645: LD_INT 0
35647: EQUAL
35648: AND
35649: IFFALSE 36048
// begin for i = 1 to MREG_ToBuild do
35651: LD_ADDR_VAR 0 2
35655: PUSH
35656: DOUBLE
35657: LD_INT 1
35659: DEC
35660: ST_TO_ADDR
35661: LD_EXP 46
35665: PUSH
35666: FOR_TO
35667: IFFALSE 36044
// if MREG_ToBuild [ i ] [ 1 ] = side then
35669: LD_EXP 46
35673: PUSH
35674: LD_VAR 0 2
35678: ARRAY
35679: PUSH
35680: LD_INT 1
35682: ARRAY
35683: PUSH
35684: LD_VAR 0 3
35688: EQUAL
35689: IFFALSE 36042
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35691: LD_OWVAR 84
35695: PUSH
35696: LD_EXP 46
35700: PUSH
35701: LD_VAR 0 2
35705: ARRAY
35706: PUSH
35707: LD_INT 3
35709: ARRAY
35710: PUSH
35711: LD_INT 1
35713: ARRAY
35714: PPUSH
35715: LD_EXP 46
35719: PUSH
35720: LD_VAR 0 2
35724: ARRAY
35725: PUSH
35726: LD_INT 3
35728: ARRAY
35729: PUSH
35730: LD_INT 2
35732: ARRAY
35733: PPUSH
35734: CALL_OW 351
35738: AND
35739: IFFALSE 35783
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35741: LD_EXP 46
35745: PUSH
35746: LD_VAR 0 2
35750: ARRAY
35751: PUSH
35752: LD_INT 3
35754: ARRAY
35755: PUSH
35756: LD_INT 1
35758: ARRAY
35759: PPUSH
35760: LD_EXP 46
35764: PUSH
35765: LD_VAR 0 2
35769: ARRAY
35770: PUSH
35771: LD_INT 3
35773: ARRAY
35774: PUSH
35775: LD_INT 2
35777: ARRAY
35778: PPUSH
35779: CALL 22815 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35783: LD_EXP 46
35787: PUSH
35788: LD_VAR 0 2
35792: ARRAY
35793: PUSH
35794: LD_INT 2
35796: ARRAY
35797: PUSH
35798: LD_INT 0
35800: EQUAL
35801: IFFALSE 35871
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35803: LD_VAR 0 3
35807: PPUSH
35808: LD_EXP 46
35812: PUSH
35813: LD_VAR 0 2
35817: ARRAY
35818: PUSH
35819: LD_INT 3
35821: ARRAY
35822: PUSH
35823: LD_INT 1
35825: ARRAY
35826: PPUSH
35827: LD_EXP 46
35831: PUSH
35832: LD_VAR 0 2
35836: ARRAY
35837: PUSH
35838: LD_INT 3
35840: ARRAY
35841: PUSH
35842: LD_INT 2
35844: ARRAY
35845: PPUSH
35846: LD_EXP 46
35850: PUSH
35851: LD_VAR 0 2
35855: ARRAY
35856: PUSH
35857: LD_INT 3
35859: ARRAY
35860: PUSH
35861: LD_INT 3
35863: ARRAY
35864: PPUSH
35865: CALL 8603 0 4
35869: GO 36040
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35871: LD_EXP 46
35875: PUSH
35876: LD_VAR 0 2
35880: ARRAY
35881: PUSH
35882: LD_INT 2
35884: ARRAY
35885: PUSH
35886: LD_INT 6
35888: EQUAL
35889: IFFALSE 35959
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35891: LD_VAR 0 3
35895: PPUSH
35896: LD_EXP 46
35900: PUSH
35901: LD_VAR 0 2
35905: ARRAY
35906: PUSH
35907: LD_INT 3
35909: ARRAY
35910: PUSH
35911: LD_INT 1
35913: ARRAY
35914: PPUSH
35915: LD_EXP 46
35919: PUSH
35920: LD_VAR 0 2
35924: ARRAY
35925: PUSH
35926: LD_INT 3
35928: ARRAY
35929: PUSH
35930: LD_INT 2
35932: ARRAY
35933: PPUSH
35934: LD_EXP 46
35938: PUSH
35939: LD_VAR 0 2
35943: ARRAY
35944: PUSH
35945: LD_INT 3
35947: ARRAY
35948: PUSH
35949: LD_INT 3
35951: ARRAY
35952: PPUSH
35953: CALL 8732 0 4
35957: GO 36040
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35959: LD_VAR 0 3
35963: PPUSH
35964: LD_EXP 46
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: PUSH
35975: LD_INT 2
35977: ARRAY
35978: PPUSH
35979: LD_EXP 46
35983: PUSH
35984: LD_VAR 0 2
35988: ARRAY
35989: PUSH
35990: LD_INT 3
35992: ARRAY
35993: PUSH
35994: LD_INT 1
35996: ARRAY
35997: PPUSH
35998: LD_EXP 46
36002: PUSH
36003: LD_VAR 0 2
36007: ARRAY
36008: PUSH
36009: LD_INT 3
36011: ARRAY
36012: PUSH
36013: LD_INT 2
36015: ARRAY
36016: PPUSH
36017: LD_EXP 46
36021: PUSH
36022: LD_VAR 0 2
36026: ARRAY
36027: PUSH
36028: LD_INT 3
36030: ARRAY
36031: PUSH
36032: LD_INT 3
36034: ARRAY
36035: PPUSH
36036: CALL 10236 0 5
// break ;
36040: GO 36044
// end ;
36042: GO 35666
36044: POP
36045: POP
// end else
36046: GO 36147
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36048: LD_VAR 0 3
36052: PPUSH
36053: LD_EXP 52
36057: PPUSH
36058: CALL 43001 0 2
36062: PUSH
36063: LD_VAR 0 3
36067: PPUSH
36068: CALL 25022 0 1
36072: PUSH
36073: LD_INT 0
36075: EQUAL
36076: AND
36077: IFFALSE 36147
// begin for i = 1 to MREG_ToDismantle do
36079: LD_ADDR_VAR 0 2
36083: PUSH
36084: DOUBLE
36085: LD_INT 1
36087: DEC
36088: ST_TO_ADDR
36089: LD_EXP 52
36093: PUSH
36094: FOR_TO
36095: IFFALSE 36145
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36097: LD_EXP 52
36101: PUSH
36102: LD_VAR 0 2
36106: ARRAY
36107: PUSH
36108: LD_INT 1
36110: ARRAY
36111: PUSH
36112: LD_VAR 0 3
36116: EQUAL
36117: IFFALSE 36143
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36119: LD_VAR 0 3
36123: PPUSH
36124: LD_EXP 52
36128: PUSH
36129: LD_VAR 0 2
36133: ARRAY
36134: PUSH
36135: LD_INT 2
36137: ARRAY
36138: PPUSH
36139: CALL 10902 0 2
// end ;
36143: GO 36094
36145: POP
36146: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36147: LD_VAR 0 3
36151: PPUSH
36152: LD_INT 30
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PPUSH
36162: CALL 11667 0 2
36166: PUSH
36167: LD_VAR 0 3
36171: PPUSH
36172: CALL 25022 0 1
36176: PUSH
36177: LD_INT 0
36179: EQUAL
36180: AND
36181: IFFALSE 36192
// MCT_CollectCrates ( side ) ;
36183: LD_VAR 0 3
36187: PPUSH
36188: CALL 23961 0 1
// end ;
36192: GO 34193
36194: POP
36195: POP
// end ;
36196: LD_VAR 0 1
36200: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36201: LD_INT 0
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
36216: PPUSH
36217: PPUSH
// all := MCF_All ( side , [ ] ) ;
36218: LD_ADDR_VAR 0 17
36222: PUSH
36223: LD_VAR 0 1
36227: PPUSH
36228: EMPTY
36229: PPUSH
36230: CALL 11802 0 2
36234: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36235: LD_ADDR_VAR 0 13
36239: PUSH
36240: LD_VAR 0 1
36244: PPUSH
36245: LD_INT 1
36247: PPUSH
36248: EMPTY
36249: PPUSH
36250: CALL 11750 0 3
36254: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36255: LD_ADDR_VAR 0 14
36259: PUSH
36260: LD_VAR 0 1
36264: PPUSH
36265: LD_INT 2
36267: PPUSH
36268: EMPTY
36269: PPUSH
36270: CALL 11750 0 3
36274: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36275: LD_ADDR_VAR 0 15
36279: PUSH
36280: LD_VAR 0 1
36284: PPUSH
36285: LD_INT 3
36287: PPUSH
36288: EMPTY
36289: PPUSH
36290: CALL 11750 0 3
36294: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36295: LD_ADDR_VAR 0 16
36299: PUSH
36300: LD_VAR 0 1
36304: PPUSH
36305: LD_INT 4
36307: PPUSH
36308: EMPTY
36309: PPUSH
36310: CALL 11750 0 3
36314: ST_TO_ADDR
// if mech then
36315: LD_VAR 0 15
36319: IFFALSE 36336
// mech := MCF_SortListDesc ( mech ) ;
36321: LD_ADDR_VAR 0 15
36325: PUSH
36326: LD_VAR 0 15
36330: PPUSH
36331: CALL 12916 0 1
36335: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36336: LD_EXP 56
36340: PUSH
36341: LD_VAR 0 1
36345: ARRAY
36346: PUSH
36347: LD_STRING 
36349: EQUAL
36350: NOT
36351: IFFALSE 36407
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36353: LD_EXP 56
36357: PUSH
36358: LD_VAR 0 1
36362: ARRAY
36363: PUSH
36364: LD_INT 1
36366: ARRAY
36367: PPUSH
36368: CALL_OW 257
36372: PUSH
36373: LD_INT 1
36375: EQUAL
36376: IFFALSE 36405
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36378: LD_VAR 0 1
36382: PPUSH
36383: LD_STRING ToArm
36385: PPUSH
36386: LD_EXP 56
36390: PUSH
36391: LD_VAR 0 1
36395: ARRAY
36396: PUSH
36397: LD_INT 1
36399: ARRAY
36400: PPUSH
36401: CALL 14546 0 3
// end else
36405: GO 36433
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36407: LD_ADDR_EXP 56
36411: PUSH
36412: LD_EXP 56
36416: PPUSH
36417: LD_VAR 0 1
36421: PPUSH
36422: LD_INT 1
36424: PPUSH
36425: LD_INT 0
36427: PPUSH
36428: CALL 31132 0 4
36432: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36433: LD_EXP 57
36437: PUSH
36438: LD_VAR 0 1
36442: ARRAY
36443: PUSH
36444: LD_STRING 
36446: EQUAL
36447: NOT
36448: IFFALSE 36504
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36450: LD_EXP 57
36454: PUSH
36455: LD_VAR 0 1
36459: ARRAY
36460: PUSH
36461: LD_INT 1
36463: ARRAY
36464: PPUSH
36465: CALL_OW 257
36469: PUSH
36470: LD_INT 2
36472: EQUAL
36473: IFFALSE 36502
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36475: LD_VAR 0 1
36479: PPUSH
36480: LD_STRING ToDep
36482: PPUSH
36483: LD_EXP 57
36487: PUSH
36488: LD_VAR 0 1
36492: ARRAY
36493: PUSH
36494: LD_INT 1
36496: ARRAY
36497: PPUSH
36498: CALL 14546 0 3
// end else
36502: GO 36530
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36504: LD_ADDR_EXP 57
36508: PUSH
36509: LD_EXP 57
36513: PPUSH
36514: LD_VAR 0 1
36518: PPUSH
36519: LD_INT 1
36521: PPUSH
36522: LD_INT 0
36524: PPUSH
36525: CALL 31132 0 4
36529: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36530: LD_EXP 55
36534: PUSH
36535: LD_VAR 0 1
36539: ARRAY
36540: PUSH
36541: LD_STRING 
36543: EQUAL
36544: NOT
36545: IFFALSE 36601
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36547: LD_EXP 55
36551: PUSH
36552: LD_VAR 0 1
36556: ARRAY
36557: PUSH
36558: LD_INT 1
36560: ARRAY
36561: PPUSH
36562: CALL_OW 257
36566: PUSH
36567: LD_INT 3
36569: EQUAL
36570: IFFALSE 36599
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36572: LD_VAR 0 1
36576: PPUSH
36577: LD_STRING ToFac
36579: PPUSH
36580: LD_EXP 55
36584: PUSH
36585: LD_VAR 0 1
36589: ARRAY
36590: PUSH
36591: LD_INT 1
36593: ARRAY
36594: PPUSH
36595: CALL 14546 0 3
// end else
36599: GO 36627
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36601: LD_ADDR_EXP 55
36605: PUSH
36606: LD_EXP 55
36610: PPUSH
36611: LD_VAR 0 1
36615: PPUSH
36616: LD_INT 1
36618: PPUSH
36619: LD_INT 0
36621: PPUSH
36622: CALL 31132 0 4
36626: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36627: LD_EXP 54
36631: PUSH
36632: LD_VAR 0 1
36636: ARRAY
36637: PUSH
36638: LD_STRING 
36640: EQUAL
36641: NOT
36642: IFFALSE 36698
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36644: LD_EXP 54
36648: PUSH
36649: LD_VAR 0 1
36653: ARRAY
36654: PUSH
36655: LD_INT 1
36657: ARRAY
36658: PPUSH
36659: CALL_OW 257
36663: PUSH
36664: LD_INT 4
36666: EQUAL
36667: IFFALSE 36696
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36669: LD_VAR 0 1
36673: PPUSH
36674: LD_STRING ToLab
36676: PPUSH
36677: LD_EXP 54
36681: PUSH
36682: LD_VAR 0 1
36686: ARRAY
36687: PUSH
36688: LD_INT 1
36690: ARRAY
36691: PPUSH
36692: CALL 14546 0 3
// end else
36696: GO 36724
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36698: LD_ADDR_EXP 54
36702: PUSH
36703: LD_EXP 54
36707: PPUSH
36708: LD_VAR 0 1
36712: PPUSH
36713: LD_INT 1
36715: PPUSH
36716: LD_INT 0
36718: PPUSH
36719: CALL 31132 0 4
36723: ST_TO_ADDR
// if mode = 0 then
36724: LD_VAR 0 2
36728: PUSH
36729: LD_INT 0
36731: EQUAL
36732: IFFALSE 38570
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36734: LD_VAR 0 1
36738: PPUSH
36739: LD_INT 30
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PPUSH
36749: CALL 11667 0 2
36753: PUSH
36754: LD_VAR 0 1
36758: PPUSH
36759: LD_INT 21
36761: PUSH
36762: LD_INT 3
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PPUSH
36769: CALL 11667 0 2
36773: PUSH
36774: LD_INT 1
36776: EQUAL
36777: AND
36778: IFFALSE 36843
// begin if all then
36780: LD_VAR 0 17
36784: IFFALSE 36841
// for i in ( all diff eng ) do
36786: LD_ADDR_VAR 0 4
36790: PUSH
36791: LD_VAR 0 17
36795: PUSH
36796: LD_VAR 0 14
36800: DIFF
36801: PUSH
36802: FOR_IN
36803: IFFALSE 36839
// if GetTag ( i ) = 0 then
36805: LD_VAR 0 4
36809: PPUSH
36810: CALL_OW 110
36814: PUSH
36815: LD_INT 0
36817: EQUAL
36818: IFFALSE 36837
// MCH_ChangeClass ( side , i , 2 ) ;
36820: LD_VAR 0 1
36824: PPUSH
36825: LD_VAR 0 4
36829: PPUSH
36830: LD_INT 2
36832: PPUSH
36833: CALL 16574 0 3
36837: GO 36802
36839: POP
36840: POP
// end else
36841: GO 37162
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36843: LD_VAR 0 13
36847: PUSH
36848: LD_EXP 56
36852: PUSH
36853: LD_VAR 0 1
36857: ARRAY
36858: PLUS
36859: PUSH
36860: LD_INT 22
36862: PUSH
36863: LD_VAR 0 1
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 30
36874: PUSH
36875: LD_INT 32
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PPUSH
36886: CALL_OW 69
36890: LESS
36891: IFFALSE 36916
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36893: LD_VAR 0 1
36897: PPUSH
36898: LD_VAR 0 14
36902: PUSH
36903: LD_INT 1
36905: ARRAY
36906: PPUSH
36907: LD_INT 1
36909: PPUSH
36910: CALL 16574 0 3
// end else
36914: GO 37162
// if sci < 6 and MCF_Lab ( side ) then
36916: LD_VAR 0 16
36920: PUSH
36921: LD_INT 6
36923: LESS
36924: PUSH
36925: LD_VAR 0 1
36929: PPUSH
36930: CALL 11706 0 1
36934: AND
36935: IFFALSE 37040
// begin if MREG_ToBunker [ side ] then
36937: LD_EXP 68
36941: PUSH
36942: LD_VAR 0 1
36946: ARRAY
36947: IFFALSE 36973
// tmp := sol diff MREG_ToBunker [ side ] else
36949: LD_ADDR_VAR 0 12
36953: PUSH
36954: LD_VAR 0 13
36958: PUSH
36959: LD_EXP 68
36963: PUSH
36964: LD_VAR 0 1
36968: ARRAY
36969: DIFF
36970: ST_TO_ADDR
36971: GO 36983
// tmp := sol ;
36973: LD_ADDR_VAR 0 12
36977: PUSH
36978: LD_VAR 0 13
36982: ST_TO_ADDR
// if tmp then
36983: LD_VAR 0 12
36987: IFFALSE 37038
// for i in tmp do
36989: LD_ADDR_VAR 0 4
36993: PUSH
36994: LD_VAR 0 12
36998: PUSH
36999: FOR_IN
37000: IFFALSE 37036
// if GetTag ( i ) = 0 then
37002: LD_VAR 0 4
37006: PPUSH
37007: CALL_OW 110
37011: PUSH
37012: LD_INT 0
37014: EQUAL
37015: IFFALSE 37034
// MCH_ChangeClass ( side , i , 4 ) ;
37017: LD_VAR 0 1
37021: PPUSH
37022: LD_VAR 0 4
37026: PPUSH
37027: LD_INT 4
37029: PPUSH
37030: CALL 16574 0 3
37034: GO 36999
37036: POP
37037: POP
// end else
37038: GO 37162
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37040: LD_VAR 0 1
37044: PPUSH
37045: LD_INT 30
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PPUSH
37055: CALL 11667 0 2
37059: IFFALSE 37162
// begin if MREG_ToBunker [ side ] then
37061: LD_EXP 68
37065: PUSH
37066: LD_VAR 0 1
37070: ARRAY
37071: IFFALSE 37097
// tmp := sol diff MREG_ToBunker [ side ] else
37073: LD_ADDR_VAR 0 12
37077: PUSH
37078: LD_VAR 0 13
37082: PUSH
37083: LD_EXP 68
37087: PUSH
37088: LD_VAR 0 1
37092: ARRAY
37093: DIFF
37094: ST_TO_ADDR
37095: GO 37107
// tmp := sol ;
37097: LD_ADDR_VAR 0 12
37101: PUSH
37102: LD_VAR 0 13
37106: ST_TO_ADDR
// if tmp then
37107: LD_VAR 0 12
37111: IFFALSE 37162
// for i in tmp do
37113: LD_ADDR_VAR 0 4
37117: PUSH
37118: LD_VAR 0 12
37122: PUSH
37123: FOR_IN
37124: IFFALSE 37160
// if GetTag ( i ) = 0 then
37126: LD_VAR 0 4
37130: PPUSH
37131: CALL_OW 110
37135: PUSH
37136: LD_INT 0
37138: EQUAL
37139: IFFALSE 37158
// MCH_ChangeClass ( side , i , 2 ) ;
37141: LD_VAR 0 1
37145: PPUSH
37146: LD_VAR 0 4
37150: PPUSH
37151: LD_INT 2
37153: PPUSH
37154: CALL 16574 0 3
37158: GO 37123
37160: POP
37161: POP
// end ; if MCF_Lab ( side ) then
37162: LD_VAR 0 1
37166: PPUSH
37167: CALL 11706 0 1
37171: IFFALSE 37711
// begin if MCL_GetTechList ( side ) then
37173: LD_VAR 0 1
37177: PPUSH
37178: CALL 18050 0 1
37182: IFFALSE 37308
// begin if MREG_ToLab [ side ] then
37184: LD_EXP 54
37188: PUSH
37189: LD_VAR 0 1
37193: ARRAY
37194: IFFALSE 37214
// k := MREG_ToLab [ side ] else
37196: LD_ADDR_VAR 0 8
37200: PUSH
37201: LD_EXP 54
37205: PUSH
37206: LD_VAR 0 1
37210: ARRAY
37211: ST_TO_ADDR
37212: GO 37222
// k := 0 ;
37214: LD_ADDR_VAR 0 8
37218: PUSH
37219: LD_INT 0
37221: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37222: LD_VAR 0 16
37226: PUSH
37227: LD_VAR 0 8
37231: PLUS
37232: PUSH
37233: LD_INT 6
37235: LESSEQUAL
37236: PUSH
37237: LD_VAR 0 17
37241: PUSH
37242: LD_INT 6
37244: GREATER
37245: AND
37246: IFFALSE 37262
// MCH_TrainScientist ( side , 1 ) else
37248: LD_VAR 0 1
37252: PPUSH
37253: LD_INT 1
37255: PPUSH
37256: CALL 16126 0 2
37260: GO 37306
// if all < 6 then
37262: LD_VAR 0 17
37266: PUSH
37267: LD_INT 6
37269: LESS
37270: IFFALSE 37306
// if sci + k < all / 2 then
37272: LD_VAR 0 16
37276: PUSH
37277: LD_VAR 0 8
37281: PLUS
37282: PUSH
37283: LD_VAR 0 17
37287: PUSH
37288: LD_INT 2
37290: DIVREAL
37291: LESS
37292: IFFALSE 37306
// MCH_TrainScientist ( side , 1 ) ;
37294: LD_VAR 0 1
37298: PPUSH
37299: LD_INT 1
37301: PPUSH
37302: CALL 16126 0 2
// end else
37306: GO 37384
// begin if sci > 2 then
37308: LD_VAR 0 16
37312: PUSH
37313: LD_INT 2
37315: GREATER
37316: IFFALSE 37384
// for i = sci downto 2 do
37318: LD_ADDR_VAR 0 4
37322: PUSH
37323: DOUBLE
37324: LD_VAR 0 16
37328: INC
37329: ST_TO_ADDR
37330: LD_INT 2
37332: PUSH
37333: FOR_DOWNTO
37334: IFFALSE 37382
// if GetTag ( sci [ i ] ) = 0 then
37336: LD_VAR 0 16
37340: PUSH
37341: LD_VAR 0 4
37345: ARRAY
37346: PPUSH
37347: CALL_OW 110
37351: PUSH
37352: LD_INT 0
37354: EQUAL
37355: IFFALSE 37380
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37357: LD_VAR 0 1
37361: PPUSH
37362: LD_VAR 0 16
37366: PUSH
37367: LD_VAR 0 4
37371: ARRAY
37372: PPUSH
37373: LD_INT 2
37375: PPUSH
37376: CALL 16574 0 3
37380: GO 37333
37382: POP
37383: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37384: LD_VAR 0 1
37388: PPUSH
37389: CALL 18050 0 1
37393: PUSH
37394: LD_VAR 0 1
37398: PPUSH
37399: CALL 11706 0 1
37403: AND
37404: PUSH
37405: LD_EXP 35
37409: PUSH
37410: LD_VAR 0 1
37414: ARRAY
37415: NOT
37416: AND
37417: IFFALSE 37711
// begin for j = 1 to MCF_Lab ( side ) do
37419: LD_ADDR_VAR 0 5
37423: PUSH
37424: DOUBLE
37425: LD_INT 1
37427: DEC
37428: ST_TO_ADDR
37429: LD_VAR 0 1
37433: PPUSH
37434: CALL 11706 0 1
37438: PUSH
37439: FOR_TO
37440: IFFALSE 37500
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37442: LD_VAR 0 1
37446: PPUSH
37447: CALL 11706 0 1
37451: PUSH
37452: LD_VAR 0 5
37456: ARRAY
37457: PPUSH
37458: CALL_OW 461
37462: PUSH
37463: LD_INT 3
37465: PUSH
37466: LD_INT 6
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: IN
37473: IFFALSE 37498
// begin b := MCF_Lab ( side ) [ j ] ;
37475: LD_ADDR_VAR 0 11
37479: PUSH
37480: LD_VAR 0 1
37484: PPUSH
37485: CALL 11706 0 1
37489: PUSH
37490: LD_VAR 0 5
37494: ARRAY
37495: ST_TO_ADDR
// break ;
37496: GO 37500
// end ;
37498: GO 37439
37500: POP
37501: POP
// if MCF_Class ( side , 4 , [ ] ) then
37502: LD_VAR 0 1
37506: PPUSH
37507: LD_INT 4
37509: PPUSH
37510: EMPTY
37511: PPUSH
37512: CALL 11750 0 3
37516: IFFALSE 37711
// for j in MCF_Class ( side , 4 , [ ] ) do
37518: LD_ADDR_VAR 0 5
37522: PUSH
37523: LD_VAR 0 1
37527: PPUSH
37528: LD_INT 4
37530: PPUSH
37531: EMPTY
37532: PPUSH
37533: CALL 11750 0 3
37537: PUSH
37538: FOR_IN
37539: IFFALSE 37709
// begin if GetTag ( j ) = 0 then
37541: LD_VAR 0 5
37545: PPUSH
37546: CALL_OW 110
37550: PUSH
37551: LD_INT 0
37553: EQUAL
37554: IFFALSE 37645
// begin if IsInUnit ( j ) and b then
37556: LD_VAR 0 5
37560: PPUSH
37561: CALL_OW 310
37565: PUSH
37566: LD_VAR 0 11
37570: AND
37571: IFFALSE 37619
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37573: LD_VAR 0 5
37577: PPUSH
37578: CALL_OW 310
37582: PPUSH
37583: CALL_OW 461
37587: PUSH
37588: LD_INT 2
37590: EQUAL
37591: PUSH
37592: LD_VAR 0 5
37596: PPUSH
37597: CALL_OW 310
37601: PUSH
37602: LD_VAR 0 11
37606: NONEQUAL
37607: AND
37608: IFFALSE 37619
// ComExitBuilding ( j ) ;
37610: LD_VAR 0 5
37614: PPUSH
37615: CALL_OW 122
// if not IsInUnit ( j ) then
37619: LD_VAR 0 5
37623: PPUSH
37624: CALL_OW 310
37628: NOT
37629: IFFALSE 37645
// ComEnterUnit ( j , b ) ;
37631: LD_VAR 0 5
37635: PPUSH
37636: LD_VAR 0 11
37640: PPUSH
37641: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37645: LD_INT 1
37647: PPUSH
37648: LD_VAR 0 5
37652: PPUSH
37653: CALL_OW 255
37657: PPUSH
37658: CALL_OW 321
37662: PUSH
37663: LD_INT 2
37665: EQUAL
37666: PUSH
37667: LD_VAR 0 5
37671: PPUSH
37672: CALL_OW 255
37676: PPUSH
37677: CALL 25022 0 1
37681: PUSH
37682: LD_INT 0
37684: EQUAL
37685: AND
37686: IFFALSE 37707
// MCN_Tame ( GetSide ( j ) , j ) ;
37688: LD_VAR 0 5
37692: PPUSH
37693: CALL_OW 255
37697: PPUSH
37698: LD_VAR 0 5
37702: PPUSH
37703: CALL 18569 0 2
// end ;
37707: GO 37538
37709: POP
37710: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37711: LD_VAR 0 1
37715: PPUSH
37716: LD_INT 30
37718: PUSH
37719: LD_INT 3
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PPUSH
37726: CALL 11667 0 2
37730: IFFALSE 37989
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37732: LD_ADDR_VAR 0 11
37736: PUSH
37737: LD_VAR 0 1
37741: PPUSH
37742: LD_INT 30
37744: PUSH
37745: LD_INT 3
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PPUSH
37752: CALL 11667 0 2
37756: PUSH
37757: LD_INT 1
37759: ARRAY
37760: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37761: LD_ADDR_VAR 0 12
37765: PUSH
37766: LD_VAR 0 1
37770: PPUSH
37771: LD_INT 0
37773: PPUSH
37774: LD_INT 25
37776: PUSH
37777: LD_INT 3
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PPUSH
37784: CALL 12370 0 3
37788: ST_TO_ADDR
// for i = 1 to tmp do
37789: LD_ADDR_VAR 0 4
37793: PUSH
37794: DOUBLE
37795: LD_INT 1
37797: DEC
37798: ST_TO_ADDR
37799: LD_VAR 0 12
37803: PUSH
37804: FOR_TO
37805: IFFALSE 37865
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37807: LD_VAR 0 12
37811: PUSH
37812: LD_VAR 0 4
37816: ARRAY
37817: PPUSH
37818: CALL_OW 310
37822: NOT
37823: PUSH
37824: LD_VAR 0 12
37828: PUSH
37829: LD_VAR 0 4
37833: ARRAY
37834: PPUSH
37835: CALL_OW 314
37839: NOT
37840: AND
37841: IFFALSE 37863
// ComEnterUnit ( tmp [ i ] , b ) ;
37843: LD_VAR 0 12
37847: PUSH
37848: LD_VAR 0 4
37852: ARRAY
37853: PPUSH
37854: LD_VAR 0 11
37858: PPUSH
37859: CALL_OW 120
37863: GO 37804
37865: POP
37866: POP
// if MREG_ToFac [ side ] then
37867: LD_EXP 55
37871: PUSH
37872: LD_VAR 0 1
37876: ARRAY
37877: IFFALSE 37897
// k := MREG_ToFac [ side ] else
37879: LD_ADDR_VAR 0 8
37883: PUSH
37884: LD_EXP 55
37888: PUSH
37889: LD_VAR 0 1
37893: ARRAY
37894: ST_TO_ADDR
37895: GO 37905
// k := 0 ;
37897: LD_ADDR_VAR 0 8
37901: PUSH
37902: LD_INT 0
37904: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37905: LD_VAR 0 15
37909: PUSH
37910: LD_VAR 0 8
37914: PLUS
37915: PUSH
37916: LD_INT 6
37918: LESSEQUAL
37919: PUSH
37920: LD_VAR 0 17
37924: PUSH
37925: LD_INT 6
37927: GREATER
37928: AND
37929: IFFALSE 37945
// MCH_TrainMechanic ( side , 1 ) else
37931: LD_VAR 0 1
37935: PPUSH
37936: LD_INT 1
37938: PPUSH
37939: CALL 15868 0 2
37943: GO 37989
// if all < 6 then
37945: LD_VAR 0 17
37949: PUSH
37950: LD_INT 6
37952: LESS
37953: IFFALSE 37989
// if mech + k < all / 2 then
37955: LD_VAR 0 15
37959: PUSH
37960: LD_VAR 0 8
37964: PLUS
37965: PUSH
37966: LD_VAR 0 17
37970: PUSH
37971: LD_INT 2
37973: DIVREAL
37974: LESS
37975: IFFALSE 37989
// MCH_TrainMechanic ( side , 1 ) ;
37977: LD_VAR 0 1
37981: PPUSH
37982: LD_INT 1
37984: PPUSH
37985: CALL 15868 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37989: LD_ADDR_VAR 0 10
37993: PUSH
37994: LD_VAR 0 1
37998: PPUSH
37999: LD_INT 30
38001: PUSH
38002: LD_INT 36
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PPUSH
38009: CALL 11667 0 2
38013: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38014: LD_VAR 0 10
38018: PUSH
38019: LD_VAR 0 15
38023: AND
38024: PUSH
38025: LD_VAR 0 1
38029: PPUSH
38030: LD_INT 3
38032: PPUSH
38033: EMPTY
38034: PPUSH
38035: CALL 11750 0 3
38039: AND
38040: IFFALSE 38198
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38042: LD_VAR 0 1
38046: PPUSH
38047: LD_INT 9
38049: PPUSH
38050: EMPTY
38051: PPUSH
38052: CALL 12370 0 3
38056: PUSH
38057: LD_INT 3
38059: LESS
38060: IFFALSE 38198
// begin if mech < 3 then
38062: LD_VAR 0 15
38066: PUSH
38067: LD_INT 3
38069: LESS
38070: IFFALSE 38084
// k := mech else
38072: LD_ADDR_VAR 0 8
38076: PUSH
38077: LD_VAR 0 15
38081: ST_TO_ADDR
38082: GO 38092
// k := 3 ;
38084: LD_ADDR_VAR 0 8
38088: PUSH
38089: LD_INT 3
38091: ST_TO_ADDR
// for j = 1 to k do
38092: LD_ADDR_VAR 0 5
38096: PUSH
38097: DOUBLE
38098: LD_INT 1
38100: DEC
38101: ST_TO_ADDR
38102: LD_VAR 0 8
38106: PUSH
38107: FOR_TO
38108: IFFALSE 38166
// if GetClass ( mech [ j ] ) = 3 then
38110: LD_VAR 0 15
38114: PUSH
38115: LD_VAR 0 5
38119: ARRAY
38120: PPUSH
38121: CALL_OW 257
38125: PUSH
38126: LD_INT 3
38128: EQUAL
38129: IFFALSE 38164
// begin SetTag ( mech [ j ] , 9 ) ;
38131: LD_VAR 0 15
38135: PUSH
38136: LD_VAR 0 5
38140: ARRAY
38141: PPUSH
38142: LD_INT 9
38144: PPUSH
38145: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38149: LD_VAR 0 15
38153: PUSH
38154: LD_VAR 0 5
38158: ARRAY
38159: PPUSH
38160: CALL_OW 122
// end ;
38164: GO 38107
38166: POP
38167: POP
// if mech < 6 + k then
38168: LD_VAR 0 15
38172: PUSH
38173: LD_INT 6
38175: PUSH
38176: LD_VAR 0 8
38180: PLUS
38181: LESS
38182: IFFALSE 38198
// MCH_TrainMechanic ( side , k ) ;
38184: LD_VAR 0 1
38188: PPUSH
38189: LD_VAR 0 8
38193: PPUSH
38194: CALL 15868 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38198: LD_VAR 0 1
38202: PPUSH
38203: LD_INT 9
38205: PPUSH
38206: EMPTY
38207: PPUSH
38208: CALL 12370 0 3
38212: IFFALSE 38303
// for j in MCF_Tag ( side , 9 , [ ] ) do
38214: LD_ADDR_VAR 0 5
38218: PUSH
38219: LD_VAR 0 1
38223: PPUSH
38224: LD_INT 9
38226: PPUSH
38227: EMPTY
38228: PPUSH
38229: CALL 12370 0 3
38233: PUSH
38234: FOR_IN
38235: IFFALSE 38301
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38237: LD_VAR 0 5
38241: PPUSH
38242: CALL_OW 310
38246: NOT
38247: PUSH
38248: LD_VAR 0 5
38252: PPUSH
38253: CALL 95589 0 1
38257: NOT
38258: AND
38259: IFFALSE 38299
// if ct then
38261: LD_VAR 0 10
38265: IFFALSE 38287
// ComEnterUnit ( j , ct [ 1 ] ) else
38267: LD_VAR 0 5
38271: PPUSH
38272: LD_VAR 0 10
38276: PUSH
38277: LD_INT 1
38279: ARRAY
38280: PPUSH
38281: CALL_OW 120
38285: GO 38299
// SetTag ( j , 0 ) ;
38287: LD_VAR 0 5
38291: PPUSH
38292: LD_INT 0
38294: PPUSH
38295: CALL_OW 109
38299: GO 38234
38301: POP
38302: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38303: LD_INT 1
38305: PPUSH
38306: LD_VAR 0 1
38310: PPUSH
38311: CALL_OW 321
38315: PUSH
38316: LD_INT 2
38318: EQUAL
38319: PUSH
38320: LD_EXP 35
38324: PUSH
38325: LD_VAR 0 1
38329: ARRAY
38330: NOT
38331: AND
38332: PUSH
38333: LD_VAR 0 1
38337: PPUSH
38338: LD_INT 4
38340: PPUSH
38341: EMPTY
38342: PPUSH
38343: CALL 11750 0 3
38347: AND
38348: IFFALSE 38396
// for j in MCF_Class ( side , 4 , [ ] ) do
38350: LD_ADDR_VAR 0 5
38354: PUSH
38355: LD_VAR 0 1
38359: PPUSH
38360: LD_INT 4
38362: PPUSH
38363: EMPTY
38364: PPUSH
38365: CALL 11750 0 3
38369: PUSH
38370: FOR_IN
38371: IFFALSE 38394
// MCN_Tame ( GetSide ( j ) , j ) ;
38373: LD_VAR 0 5
38377: PPUSH
38378: CALL_OW 255
38382: PPUSH
38383: LD_VAR 0 5
38387: PPUSH
38388: CALL 18569 0 2
38392: GO 38370
38394: POP
38395: POP
// if MREG_DefVeh [ side ] then
38396: LD_EXP 67
38400: PUSH
38401: LD_VAR 0 1
38405: ARRAY
38406: IFFALSE 38570
// begin for i in MREG_DefVeh [ side ] do
38408: LD_ADDR_VAR 0 4
38412: PUSH
38413: LD_EXP 67
38417: PUSH
38418: LD_VAR 0 1
38422: ARRAY
38423: PUSH
38424: FOR_IN
38425: IFFALSE 38478
// begin SetTag ( i , 0 ) ;
38427: LD_VAR 0 4
38431: PPUSH
38432: LD_INT 0
38434: PPUSH
38435: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38439: LD_VAR 0 4
38443: PPUSH
38444: LD_EXP 64
38448: PUSH
38449: LD_VAR 0 1
38453: ARRAY
38454: PPUSH
38455: CALL_OW 308
38459: NOT
38460: IFFALSE 38476
// MCV_Parking ( side , i ) ;
38462: LD_VAR 0 1
38466: PPUSH
38467: LD_VAR 0 4
38471: PPUSH
38472: CALL 25757 0 2
// end ;
38476: GO 38424
38478: POP
38479: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38480: LD_VAR 0 1
38484: PPUSH
38485: LD_INT 36
38487: PPUSH
38488: EMPTY
38489: PPUSH
38490: CALL 12370 0 3
38494: IFFALSE 38535
// for i in MCF_Tag ( side , 36 , [ ] ) do
38496: LD_ADDR_VAR 0 4
38500: PUSH
38501: LD_VAR 0 1
38505: PPUSH
38506: LD_INT 36
38508: PPUSH
38509: EMPTY
38510: PPUSH
38511: CALL 12370 0 3
38515: PUSH
38516: FOR_IN
38517: IFFALSE 38533
// SetTag ( i , 0 ) ;
38519: LD_VAR 0 4
38523: PPUSH
38524: LD_INT 0
38526: PPUSH
38527: CALL_OW 109
38531: GO 38516
38533: POP
38534: POP
// if MREG_DefMobActive [ side ] then
38535: LD_EXP 70
38539: PUSH
38540: LD_VAR 0 1
38544: ARRAY
38545: IFFALSE 38570
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38547: LD_ADDR_EXP 70
38551: PUSH
38552: LD_EXP 70
38556: PPUSH
38557: LD_VAR 0 1
38561: PPUSH
38562: LD_INT 0
38564: PPUSH
38565: CALL_OW 1
38569: ST_TO_ADDR
// end ; end ; if mode > 0 then
38570: LD_VAR 0 2
38574: PUSH
38575: LD_INT 0
38577: GREATER
38578: IFFALSE 40473
// begin if tick <= 15 15$00 then
38580: LD_OWVAR 1
38584: PUSH
38585: LD_INT 31500
38587: LESSEQUAL
38588: IFFALSE 38892
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38590: LD_VAR 0 13
38594: PUSH
38595: LD_VAR 0 1
38599: PPUSH
38600: CALL 25022 0 1
38604: PUSH
38605: LD_INT 4
38607: LESS
38608: AND
38609: IFFALSE 38720
// begin for i in sol do
38611: LD_ADDR_VAR 0 4
38615: PUSH
38616: LD_VAR 0 13
38620: PUSH
38621: FOR_IN
38622: IFFALSE 38718
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38624: LD_ADDR_VAR 0 8
38628: PUSH
38629: LD_VAR 0 1
38633: PPUSH
38634: CALL 25022 0 1
38638: PPUSH
38639: LD_VAR 0 4
38643: PPUSH
38644: CALL_OW 74
38648: ST_TO_ADDR
// if IsInUnit ( i ) then
38649: LD_VAR 0 4
38653: PPUSH
38654: CALL_OW 310
38658: IFFALSE 38669
// ComExitBuilding ( i ) ;
38660: LD_VAR 0 4
38664: PPUSH
38665: CALL_OW 122
// if not HasTask ( i ) and k then
38669: LD_VAR 0 4
38673: PPUSH
38674: CALL_OW 314
38678: NOT
38679: PUSH
38680: LD_VAR 0 8
38684: AND
38685: IFFALSE 38716
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38687: LD_VAR 0 4
38691: PPUSH
38692: LD_VAR 0 8
38696: PPUSH
38697: CALL_OW 250
38701: PPUSH
38702: LD_VAR 0 8
38706: PPUSH
38707: CALL_OW 251
38711: PPUSH
38712: CALL_OW 174
// end ;
38716: GO 38621
38718: POP
38719: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38720: LD_VAR 0 1
38724: PPUSH
38725: LD_INT 30
38727: PUSH
38728: LD_INT 5
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PPUSH
38735: CALL 11667 0 2
38739: IFFALSE 38890
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38741: LD_ADDR_VAR 0 11
38745: PUSH
38746: LD_VAR 0 1
38750: PPUSH
38751: LD_INT 30
38753: PUSH
38754: LD_INT 5
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PPUSH
38761: CALL 11667 0 2
38765: PUSH
38766: LD_INT 1
38768: ARRAY
38769: ST_TO_ADDR
// if mech then
38770: LD_VAR 0 15
38774: IFFALSE 38810
// for i in mech do
38776: LD_ADDR_VAR 0 4
38780: PUSH
38781: LD_VAR 0 15
38785: PUSH
38786: FOR_IN
38787: IFFALSE 38808
// MCH_ChangeClass ( side , i , 1 ) ;
38789: LD_VAR 0 1
38793: PPUSH
38794: LD_VAR 0 4
38798: PPUSH
38799: LD_INT 1
38801: PPUSH
38802: CALL 16574 0 3
38806: GO 38786
38808: POP
38809: POP
// if eng > 1 then
38810: LD_VAR 0 14
38814: PUSH
38815: LD_INT 1
38817: GREATER
38818: IFFALSE 38865
// for i = eng downto 2 do
38820: LD_ADDR_VAR 0 4
38824: PUSH
38825: DOUBLE
38826: LD_VAR 0 14
38830: INC
38831: ST_TO_ADDR
38832: LD_INT 2
38834: PUSH
38835: FOR_DOWNTO
38836: IFFALSE 38863
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38838: LD_VAR 0 1
38842: PPUSH
38843: LD_VAR 0 14
38847: PUSH
38848: LD_VAR 0 4
38852: ARRAY
38853: PPUSH
38854: LD_INT 1
38856: PPUSH
38857: CALL 16574 0 3
38861: GO 38835
38863: POP
38864: POP
// if UnitsInside ( b ) then
38865: LD_VAR 0 11
38869: PPUSH
38870: CALL_OW 313
38874: IFFALSE 38890
// ComExitBuilding ( UnitsInside ( b ) ) ;
38876: LD_VAR 0 11
38880: PPUSH
38881: CALL_OW 313
38885: PPUSH
38886: CALL_OW 122
// end ; end else
38890: GO 40473
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38892: LD_VAR 0 1
38896: PPUSH
38897: LD_INT 1
38899: PPUSH
38900: LD_EXP 65
38904: PUSH
38905: LD_VAR 0 1
38909: ARRAY
38910: PUSH
38911: LD_INT 1
38913: ARRAY
38914: PPUSH
38915: CALL 33745 0 3
38919: IFFALSE 39058
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38921: LD_ADDR_VAR 0 12
38925: PUSH
38926: LD_VAR 0 1
38930: PPUSH
38931: LD_INT 21
38933: PUSH
38934: LD_INT 1
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PPUSH
38941: CALL 11667 0 2
38945: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38946: LD_ADDR_VAR 0 11
38950: PUSH
38951: LD_VAR 0 1
38955: PPUSH
38956: LD_INT 30
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PPUSH
38966: CALL 11667 0 2
38970: ST_TO_ADDR
// if b then
38971: LD_VAR 0 11
38975: IFFALSE 39058
// for i in tmp do
38977: LD_ADDR_VAR 0 4
38981: PUSH
38982: LD_VAR 0 12
38986: PUSH
38987: FOR_IN
38988: IFFALSE 39056
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38990: LD_VAR 0 4
38994: PPUSH
38995: LD_EXP 65
38999: PUSH
39000: LD_VAR 0 1
39004: ARRAY
39005: PUSH
39006: LD_INT 1
39008: ARRAY
39009: PPUSH
39010: CALL_OW 308
39014: NOT
39015: IFFALSE 39054
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39017: LD_VAR 0 4
39021: PPUSH
39022: LD_VAR 0 11
39026: PUSH
39027: LD_INT 1
39029: ARRAY
39030: PPUSH
39031: CALL_OW 250
39035: PPUSH
39036: LD_VAR 0 11
39040: PUSH
39041: LD_INT 1
39043: ARRAY
39044: PPUSH
39045: CALL_OW 251
39049: PPUSH
39050: CALL_OW 111
39054: GO 38987
39056: POP
39057: POP
// end ; if MREG_DefVeh [ side ] then
39058: LD_EXP 67
39062: PUSH
39063: LD_VAR 0 1
39067: ARRAY
39068: IFFALSE 39636
// begin tmp := [ ] ;
39070: LD_ADDR_VAR 0 12
39074: PUSH
39075: EMPTY
39076: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39077: LD_EXP 70
39081: PUSH
39082: LD_VAR 0 1
39086: ARRAY
39087: PUSH
39088: LD_INT 0
39090: EQUAL
39091: IFFALSE 39231
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39093: LD_ADDR_VAR 0 8
39097: PUSH
39098: LD_VAR 0 1
39102: PPUSH
39103: LD_INT 0
39105: PPUSH
39106: LD_INT 25
39108: PUSH
39109: LD_INT 3
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PPUSH
39116: CALL 12370 0 3
39120: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39121: LD_VAR 0 8
39125: PUSH
39126: LD_EXP 67
39130: PUSH
39131: LD_VAR 0 1
39135: ARRAY
39136: GREATER
39137: IFFALSE 39198
// begin for i = 1 to MREG_DefVeh [ side ] do
39139: LD_ADDR_VAR 0 4
39143: PUSH
39144: DOUBLE
39145: LD_INT 1
39147: DEC
39148: ST_TO_ADDR
39149: LD_EXP 67
39153: PUSH
39154: LD_VAR 0 1
39158: ARRAY
39159: PUSH
39160: FOR_TO
39161: IFFALSE 39194
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39163: LD_ADDR_VAR 0 12
39167: PUSH
39168: LD_VAR 0 12
39172: PPUSH
39173: LD_INT 1
39175: PPUSH
39176: LD_VAR 0 8
39180: PUSH
39181: LD_VAR 0 4
39185: ARRAY
39186: PPUSH
39187: CALL_OW 2
39191: ST_TO_ADDR
39192: GO 39160
39194: POP
39195: POP
// end else
39196: GO 39208
// tmp := k ;
39198: LD_ADDR_VAR 0 12
39202: PUSH
39203: LD_VAR 0 8
39207: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39208: LD_ADDR_EXP 70
39212: PUSH
39213: LD_EXP 70
39217: PPUSH
39218: LD_VAR 0 1
39222: PPUSH
39223: LD_INT 1
39225: PPUSH
39226: CALL_OW 1
39230: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39231: LD_ADDR_VAR 0 4
39235: PUSH
39236: LD_EXP 67
39240: PUSH
39241: LD_VAR 0 1
39245: ARRAY
39246: PUSH
39247: FOR_IN
39248: IFFALSE 39634
// begin if not GetDriver ( i ) then
39250: LD_VAR 0 4
39254: PPUSH
39255: CALL 31775 0 1
39259: NOT
39260: IFFALSE 39335
// begin if tmp then
39262: LD_VAR 0 12
39266: IFFALSE 39333
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39268: LD_VAR 0 12
39272: PUSH
39273: LD_INT 1
39275: ARRAY
39276: PPUSH
39277: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39281: LD_VAR 0 12
39285: PUSH
39286: LD_INT 1
39288: ARRAY
39289: PPUSH
39290: LD_VAR 0 4
39294: PPUSH
39295: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39299: LD_VAR 0 12
39303: PUSH
39304: LD_INT 1
39306: ARRAY
39307: PPUSH
39308: LD_INT 36
39310: PPUSH
39311: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39315: LD_ADDR_VAR 0 12
39319: PUSH
39320: LD_VAR 0 12
39324: PPUSH
39325: LD_INT 1
39327: PPUSH
39328: CALL_OW 3
39332: ST_TO_ADDR
// end ; end else
39333: GO 39632
// begin if GetTag ( i ) = 0 then
39335: LD_VAR 0 4
39339: PPUSH
39340: CALL_OW 110
39344: PUSH
39345: LD_INT 0
39347: EQUAL
39348: IFFALSE 39364
// SetTag ( i , 31 ) else
39350: LD_VAR 0 4
39354: PPUSH
39355: LD_INT 31
39357: PPUSH
39358: CALL_OW 109
39362: GO 39632
// if GetTag ( i ) = 31 then
39364: LD_VAR 0 4
39368: PPUSH
39369: CALL_OW 110
39373: PUSH
39374: LD_INT 31
39376: EQUAL
39377: IFFALSE 39632
// begin if GetFuel ( i ) < 20 then
39379: LD_VAR 0 4
39383: PPUSH
39384: CALL_OW 261
39388: PUSH
39389: LD_INT 20
39391: LESS
39392: IFFALSE 39417
// begin SetTag ( i , 21 ) ;
39394: LD_VAR 0 4
39398: PPUSH
39399: LD_INT 21
39401: PPUSH
39402: CALL_OW 109
// MCV_Refuel ( i ) ;
39406: LD_VAR 0 4
39410: PPUSH
39411: CALL 26294 0 1
// continue ;
39415: GO 39247
// end ; if GetLives ( i ) < 700 then
39417: LD_VAR 0 4
39421: PPUSH
39422: CALL_OW 256
39426: PUSH
39427: LD_INT 700
39429: LESS
39430: IFFALSE 39542
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39432: LD_VAR 0 4
39436: PPUSH
39437: LD_EXP 58
39441: PUSH
39442: LD_VAR 0 1
39446: ARRAY
39447: PPUSH
39448: CALL_OW 308
39452: NOT
39453: IFFALSE 39477
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39455: LD_VAR 0 4
39459: PPUSH
39460: LD_EXP 58
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: CALL_OW 113
39475: GO 39540
// if GetDriver ( i ) then
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL 31775 0 1
39486: IFFALSE 39540
// begin k := GetDriver ( i ) ;
39488: LD_ADDR_VAR 0 8
39492: PUSH
39493: LD_VAR 0 4
39497: PPUSH
39498: CALL 31775 0 1
39502: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39503: LD_VAR 0 8
39507: PPUSH
39508: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39512: LD_VAR 0 8
39516: PPUSH
39517: LD_VAR 0 4
39521: PPUSH
39522: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39526: LD_VAR 0 8
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL_OW 180
// end ; end else
39540: GO 39632
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39542: LD_ADDR_VAR 0 8
39546: PUSH
39547: LD_VAR 0 1
39551: PPUSH
39552: CALL 25022 0 1
39556: PPUSH
39557: LD_VAR 0 4
39561: PPUSH
39562: CALL_OW 74
39566: ST_TO_ADDR
// if k then
39567: LD_VAR 0 8
39571: IFFALSE 39589
// ComAttackUnit ( i , k ) else
39573: LD_VAR 0 4
39577: PPUSH
39578: LD_VAR 0 8
39582: PPUSH
39583: CALL_OW 115
39587: GO 39632
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39589: LD_VAR 0 4
39593: PPUSH
39594: LD_EXP 58
39598: PUSH
39599: LD_VAR 0 1
39603: ARRAY
39604: PPUSH
39605: CALL_OW 308
39609: NOT
39610: IFFALSE 39632
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39612: LD_VAR 0 4
39616: PPUSH
39617: LD_EXP 58
39621: PUSH
39622: LD_VAR 0 1
39626: ARRAY
39627: PPUSH
39628: CALL_OW 113
// end ; end ; end ; end ;
39632: GO 39247
39634: POP
39635: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39636: LD_VAR 0 1
39640: PPUSH
39641: LD_INT 30
39643: PUSH
39644: LD_INT 5
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PPUSH
39651: CALL 11667 0 2
39655: IFFALSE 40473
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39657: LD_ADDR_VAR 0 11
39661: PUSH
39662: LD_VAR 0 1
39666: PPUSH
39667: LD_INT 30
39669: PUSH
39670: LD_INT 5
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PPUSH
39677: CALL 11667 0 2
39681: PUSH
39682: LD_INT 1
39684: ARRAY
39685: ST_TO_ADDR
// if eng > 1 then
39686: LD_VAR 0 14
39690: PUSH
39691: LD_INT 1
39693: GREATER
39694: IFFALSE 39741
// for i = eng downto 2 do
39696: LD_ADDR_VAR 0 4
39700: PUSH
39701: DOUBLE
39702: LD_VAR 0 14
39706: INC
39707: ST_TO_ADDR
39708: LD_INT 2
39710: PUSH
39711: FOR_DOWNTO
39712: IFFALSE 39739
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39714: LD_VAR 0 1
39718: PPUSH
39719: LD_VAR 0 14
39723: PUSH
39724: LD_VAR 0 4
39728: ARRAY
39729: PPUSH
39730: LD_INT 1
39732: PPUSH
39733: CALL 16574 0 3
39737: GO 39711
39739: POP
39740: POP
// if sci > 1 then
39741: LD_VAR 0 16
39745: PUSH
39746: LD_INT 1
39748: GREATER
39749: IFFALSE 39796
// for i = sci downto 2 do
39751: LD_ADDR_VAR 0 4
39755: PUSH
39756: DOUBLE
39757: LD_VAR 0 16
39761: INC
39762: ST_TO_ADDR
39763: LD_INT 2
39765: PUSH
39766: FOR_DOWNTO
39767: IFFALSE 39794
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39769: LD_VAR 0 1
39773: PPUSH
39774: LD_VAR 0 16
39778: PUSH
39779: LD_VAR 0 4
39783: ARRAY
39784: PPUSH
39785: LD_INT 1
39787: PPUSH
39788: CALL 16574 0 3
39792: GO 39766
39794: POP
39795: POP
// if sol then
39796: LD_VAR 0 13
39800: IFFALSE 40473
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39802: LD_VAR 0 13
39806: PUSH
39807: LD_EXP 68
39811: PUSH
39812: LD_VAR 0 1
39816: ARRAY
39817: DIFF
39818: PUSH
39819: LD_INT 22
39821: PUSH
39822: LD_VAR 0 1
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 58
39833: PUSH
39834: EMPTY
39835: LIST
39836: PUSH
39837: LD_INT 2
39839: PUSH
39840: LD_INT 30
39842: PUSH
39843: LD_INT 32
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 30
39852: PUSH
39853: LD_INT 31
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: LIST
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: LIST
39869: PPUSH
39870: CALL_OW 69
39874: PUSH
39875: LD_INT 0
39877: EQUAL
39878: AND
39879: IFFALSE 40473
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39881: LD_ADDR_VAR 0 12
39885: PUSH
39886: LD_VAR 0 13
39890: PUSH
39891: LD_EXP 68
39895: PUSH
39896: LD_VAR 0 1
39900: ARRAY
39901: DIFF
39902: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39903: LD_VAR 0 1
39907: PPUSH
39908: LD_INT 30
39910: PUSH
39911: LD_INT 5
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PPUSH
39918: CALL 11667 0 2
39922: PUSH
39923: LD_INT 1
39925: GREATER
39926: IFFALSE 39957
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39928: LD_ADDR_VAR 0 8
39932: PUSH
39933: LD_VAR 0 1
39937: PPUSH
39938: LD_INT 30
39940: PUSH
39941: LD_INT 5
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PPUSH
39948: CALL 11667 0 2
39952: PUSH
39953: LD_INT 2
39955: ARRAY
39956: ST_TO_ADDR
// for j in tmp do
39957: LD_ADDR_VAR 0 5
39961: PUSH
39962: LD_VAR 0 12
39966: PUSH
39967: FOR_IN
39968: IFFALSE 40471
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39970: LD_VAR 0 5
39974: PUSH
39975: LD_VAR 0 11
39979: PPUSH
39980: CALL_OW 313
39984: IN
39985: PUSH
39986: LD_VAR 0 11
39990: PPUSH
39991: CALL_OW 313
39995: PUSH
39996: LD_INT 6
39998: EQUAL
39999: AND
40000: PUSH
40001: LD_VAR 0 8
40005: AND
40006: PUSH
40007: LD_VAR 0 8
40011: PPUSH
40012: CALL_OW 313
40016: PUSH
40017: LD_INT 6
40019: LESS
40020: AND
40021: IFFALSE 40048
// begin ComExitBuilding ( j ) ;
40023: LD_VAR 0 5
40027: PPUSH
40028: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40032: LD_VAR 0 5
40036: PPUSH
40037: LD_VAR 0 8
40041: PPUSH
40042: CALL_OW 180
// continue ;
40046: GO 39967
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40048: LD_VAR 0 5
40052: PPUSH
40053: CALL_OW 314
40057: NOT
40058: PUSH
40059: LD_VAR 0 5
40063: PPUSH
40064: CALL_OW 110
40068: PUSH
40069: LD_INT 0
40071: EQUAL
40072: AND
40073: PUSH
40074: LD_VAR 0 5
40078: PPUSH
40079: CALL_OW 310
40083: NOT
40084: AND
40085: IFFALSE 40191
// begin if k then
40087: LD_VAR 0 8
40091: IFFALSE 40162
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40093: LD_VAR 0 8
40097: PPUSH
40098: CALL_OW 313
40102: PUSH
40103: LD_VAR 0 11
40107: PPUSH
40108: CALL_OW 313
40112: LESS
40113: IFFALSE 40131
// ComEnterUnit ( j , k ) else
40115: LD_VAR 0 5
40119: PPUSH
40120: LD_VAR 0 8
40124: PPUSH
40125: CALL_OW 120
40129: GO 40160
// if UnitsInside ( b ) < 6 then
40131: LD_VAR 0 11
40135: PPUSH
40136: CALL_OW 313
40140: PUSH
40141: LD_INT 6
40143: LESS
40144: IFFALSE 40160
// ComEnterUnit ( j , b ) ;
40146: LD_VAR 0 5
40150: PPUSH
40151: LD_VAR 0 11
40155: PPUSH
40156: CALL_OW 120
// end else
40160: GO 40191
// if UnitsInside ( b ) < 6 then
40162: LD_VAR 0 11
40166: PPUSH
40167: CALL_OW 313
40171: PUSH
40172: LD_INT 6
40174: LESS
40175: IFFALSE 40191
// ComEnterUnit ( j , b ) ;
40177: LD_VAR 0 5
40181: PPUSH
40182: LD_VAR 0 11
40186: PPUSH
40187: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40191: LD_VAR 0 5
40195: PUSH
40196: LD_VAR 0 1
40200: PPUSH
40201: LD_INT 54
40203: PUSH
40204: EMPTY
40205: LIST
40206: PPUSH
40207: CALL 11667 0 2
40211: IN
40212: PUSH
40213: LD_VAR 0 5
40217: PPUSH
40218: CALL_OW 257
40222: PUSH
40223: LD_INT 1
40225: EQUAL
40226: AND
40227: IFFALSE 40469
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40229: LD_EXP 62
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PUSH
40240: LD_INT 1
40242: ARRAY
40243: PUSH
40244: LD_INT 12
40246: PPUSH
40247: LD_VAR 0 1
40251: PPUSH
40252: CALL_OW 321
40256: PUSH
40257: LD_INT 2
40259: EQUAL
40260: AND
40261: IFFALSE 40309
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40263: LD_VAR 0 1
40267: PPUSH
40268: LD_INT 5
40270: PPUSH
40271: EMPTY
40272: PPUSH
40273: CALL 11750 0 3
40277: PUSH
40278: LD_EXP 62
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PUSH
40289: LD_INT 1
40291: ARRAY
40292: LESS
40293: IFFALSE 40309
// begin SetClass ( j , class_sniper ) ;
40295: LD_VAR 0 5
40299: PPUSH
40300: LD_INT 5
40302: PPUSH
40303: CALL_OW 336
// continue ;
40307: GO 39967
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40309: LD_EXP 62
40313: PUSH
40314: LD_VAR 0 1
40318: ARRAY
40319: PUSH
40320: LD_INT 2
40322: ARRAY
40323: PUSH
40324: LD_INT 41
40326: PPUSH
40327: LD_VAR 0 1
40331: PPUSH
40332: CALL_OW 321
40336: PUSH
40337: LD_INT 2
40339: EQUAL
40340: AND
40341: IFFALSE 40389
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40343: LD_VAR 0 1
40347: PPUSH
40348: LD_INT 8
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL 11750 0 3
40357: PUSH
40358: LD_EXP 62
40362: PUSH
40363: LD_VAR 0 1
40367: ARRAY
40368: PUSH
40369: LD_INT 2
40371: ARRAY
40372: LESS
40373: IFFALSE 40389
// begin SetClass ( j , class_mortar ) ;
40375: LD_VAR 0 5
40379: PPUSH
40380: LD_INT 8
40382: PPUSH
40383: CALL_OW 336
// continue ;
40387: GO 39967
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40389: LD_EXP 62
40393: PUSH
40394: LD_VAR 0 1
40398: ARRAY
40399: PUSH
40400: LD_INT 3
40402: ARRAY
40403: PUSH
40404: LD_INT 44
40406: PPUSH
40407: LD_VAR 0 1
40411: PPUSH
40412: CALL_OW 321
40416: PUSH
40417: LD_INT 2
40419: EQUAL
40420: AND
40421: IFFALSE 40469
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40423: LD_VAR 0 1
40427: PPUSH
40428: LD_INT 9
40430: PPUSH
40431: EMPTY
40432: PPUSH
40433: CALL 11750 0 3
40437: PUSH
40438: LD_EXP 62
40442: PUSH
40443: LD_VAR 0 1
40447: ARRAY
40448: PUSH
40449: LD_INT 3
40451: ARRAY
40452: LESS
40453: IFFALSE 40469
// begin SetClass ( j , class_bazooker ) ;
40455: LD_VAR 0 5
40459: PPUSH
40460: LD_INT 9
40462: PPUSH
40463: CALL_OW 336
// continue ;
40467: GO 39967
// end ; end ; end ;
40469: GO 39967
40471: POP
40472: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40473: LD_INT 22
40475: PUSH
40476: LD_VAR 0 1
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 58
40487: PUSH
40488: EMPTY
40489: LIST
40490: PUSH
40491: LD_INT 30
40493: PUSH
40494: LD_INT 32
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: LIST
40505: PPUSH
40506: CALL_OW 69
40510: IFFALSE 40660
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40512: LD_ADDR_VAR 0 12
40516: PUSH
40517: LD_INT 22
40519: PUSH
40520: LD_VAR 0 1
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 58
40531: PUSH
40532: EMPTY
40533: LIST
40534: PUSH
40535: LD_INT 30
40537: PUSH
40538: LD_INT 32
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: LIST
40549: PPUSH
40550: CALL_OW 69
40554: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40555: LD_ADDR_VAR 0 8
40559: PUSH
40560: LD_VAR 0 13
40564: PUSH
40565: LD_EXP 68
40569: PUSH
40570: LD_VAR 0 1
40574: ARRAY
40575: DIFF
40576: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40577: LD_VAR 0 12
40581: PUSH
40582: LD_INT 1
40584: ARRAY
40585: PPUSH
40586: CALL_OW 461
40590: PUSH
40591: LD_INT 2
40593: EQUAL
40594: PUSH
40595: LD_VAR 0 12
40599: PUSH
40600: LD_INT 1
40602: ARRAY
40603: PUSH
40604: LD_EXP 68
40608: PUSH
40609: LD_VAR 0 1
40613: ARRAY
40614: IN
40615: NOT
40616: AND
40617: PUSH
40618: LD_VAR 0 8
40622: AND
40623: IFFALSE 40660
// begin ComExitBuilding ( k [ 1 ] ) ;
40625: LD_VAR 0 8
40629: PUSH
40630: LD_INT 1
40632: ARRAY
40633: PPUSH
40634: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40638: LD_VAR 0 8
40642: PUSH
40643: LD_INT 1
40645: ARRAY
40646: PPUSH
40647: LD_VAR 0 12
40651: PUSH
40652: LD_INT 1
40654: ARRAY
40655: PPUSH
40656: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40660: LD_EXP 35
40664: PUSH
40665: LD_VAR 0 1
40669: ARRAY
40670: IFFALSE 40818
// begin if MCF_Class ( side , 4 , [ ] ) then
40672: LD_VAR 0 1
40676: PPUSH
40677: LD_INT 4
40679: PPUSH
40680: EMPTY
40681: PPUSH
40682: CALL 11750 0 3
40686: IFFALSE 40816
// for j in MCF_Class ( side , 4 , [ ] ) do
40688: LD_ADDR_VAR 0 5
40692: PUSH
40693: LD_VAR 0 1
40697: PPUSH
40698: LD_INT 4
40700: PPUSH
40701: EMPTY
40702: PPUSH
40703: CALL 11750 0 3
40707: PUSH
40708: FOR_IN
40709: IFFALSE 40814
// begin if not GetTag ( j ) = 4 then
40711: LD_VAR 0 5
40715: PPUSH
40716: CALL_OW 110
40720: PUSH
40721: LD_INT 4
40723: EQUAL
40724: NOT
40725: IFFALSE 40761
// begin SetTag ( j , 4 ) ;
40727: LD_VAR 0 5
40731: PPUSH
40732: LD_INT 4
40734: PPUSH
40735: CALL_OW 109
// if IsInUnit ( j ) then
40739: LD_VAR 0 5
40743: PPUSH
40744: CALL_OW 310
40748: IFFALSE 40759
// ComExitBuilding ( j ) ;
40750: LD_VAR 0 5
40754: PPUSH
40755: CALL_OW 122
// end else
40759: GO 40812
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40761: LD_VAR 0 5
40765: PPUSH
40766: LD_EXP 35
40770: PUSH
40771: LD_VAR 0 1
40775: ARRAY
40776: PUSH
40777: LD_INT 1
40779: ARRAY
40780: PPUSH
40781: CALL 95213 0 2
40785: NOT
40786: IFFALSE 40812
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40788: LD_VAR 0 5
40792: PPUSH
40793: LD_EXP 35
40797: PUSH
40798: LD_VAR 0 1
40802: ARRAY
40803: PUSH
40804: LD_INT 1
40806: ARRAY
40807: PPUSH
40808: CALL 19237 0 2
// end ;
40812: GO 40708
40814: POP
40815: POP
// end else
40816: GO 41050
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40818: LD_VAR 0 1
40822: PPUSH
40823: LD_INT 4
40825: PPUSH
40826: EMPTY
40827: PPUSH
40828: CALL 11750 0 3
40832: PUSH
40833: LD_VAR 0 1
40837: PPUSH
40838: LD_INT 4
40840: PPUSH
40841: EMPTY
40842: PPUSH
40843: CALL 12370 0 3
40847: AND
40848: IFFALSE 41050
// for j in MCF_Class ( side , 4 , [ ] ) do
40850: LD_ADDR_VAR 0 5
40854: PUSH
40855: LD_VAR 0 1
40859: PPUSH
40860: LD_INT 4
40862: PPUSH
40863: EMPTY
40864: PPUSH
40865: CALL 11750 0 3
40869: PUSH
40870: FOR_IN
40871: IFFALSE 41048
// begin if GetTag ( j ) = 4 then
40873: LD_VAR 0 5
40877: PPUSH
40878: CALL_OW 110
40882: PUSH
40883: LD_INT 4
40885: EQUAL
40886: IFFALSE 41046
// begin SetTag ( j , 0 ) ;
40888: LD_VAR 0 5
40892: PPUSH
40893: LD_INT 0
40895: PPUSH
40896: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40900: LD_VAR 0 1
40904: PPUSH
40905: CALL 11706 0 1
40909: PUSH
40910: LD_VAR 0 1
40914: PPUSH
40915: CALL 18050 0 1
40919: NOT
40920: AND
40921: IFFALSE 40946
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40923: LD_VAR 0 5
40927: PPUSH
40928: LD_VAR 0 1
40932: PPUSH
40933: CALL 11706 0 1
40937: PUSH
40938: LD_INT 1
40940: ARRAY
40941: PPUSH
40942: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40946: LD_VAR 0 1
40950: PPUSH
40951: CALL 11706 0 1
40955: NOT
40956: PUSH
40957: LD_VAR 0 1
40961: PPUSH
40962: LD_INT 30
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PPUSH
40972: CALL 11667 0 2
40976: AND
40977: IFFALSE 41046
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40979: LD_VAR 0 5
40983: PPUSH
40984: LD_VAR 0 1
40988: PPUSH
40989: LD_INT 30
40991: PUSH
40992: LD_INT 1
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PPUSH
40999: CALL 11667 0 2
41003: PUSH
41004: LD_INT 1
41006: ARRAY
41007: PPUSH
41008: CALL_OW 250
41012: PPUSH
41013: LD_VAR 0 1
41017: PPUSH
41018: LD_INT 30
41020: PUSH
41021: LD_INT 1
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PPUSH
41028: CALL 11667 0 2
41032: PUSH
41033: LD_INT 1
41035: ARRAY
41036: PPUSH
41037: CALL_OW 251
41041: PPUSH
41042: CALL_OW 111
// end ; end ;
41046: GO 40870
41048: POP
41049: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41050: LD_VAR 0 1
41054: PPUSH
41055: LD_INT 3
41057: PPUSH
41058: EMPTY
41059: PPUSH
41060: CALL 11750 0 3
41064: PUSH
41065: LD_EXP 58
41069: PUSH
41070: LD_VAR 0 1
41074: ARRAY
41075: AND
41076: PUSH
41077: LD_VAR 0 1
41081: PPUSH
41082: LD_INT 6
41084: PPUSH
41085: EMPTY
41086: PPUSH
41087: CALL 12370 0 3
41091: AND
41092: IFFALSE 41623
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41094: LD_ADDR_VAR 0 6
41098: PUSH
41099: LD_EXP 58
41103: PUSH
41104: LD_VAR 0 1
41108: ARRAY
41109: PPUSH
41110: LD_INT 0
41112: PPUSH
41113: CALL_OW 517
41117: PUSH
41118: LD_INT 1
41120: ARRAY
41121: PUSH
41122: LD_INT 1
41124: ARRAY
41125: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41126: LD_ADDR_VAR 0 7
41130: PUSH
41131: LD_EXP 58
41135: PUSH
41136: LD_VAR 0 1
41140: ARRAY
41141: PPUSH
41142: LD_INT 0
41144: PPUSH
41145: CALL_OW 517
41149: PUSH
41150: LD_INT 2
41152: ARRAY
41153: PUSH
41154: LD_INT 1
41156: ARRAY
41157: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41158: LD_VAR 0 1
41162: PPUSH
41163: LD_INT 6
41165: PPUSH
41166: EMPTY
41167: PPUSH
41168: CALL 12370 0 3
41172: IFFALSE 41621
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41174: LD_ADDR_VAR 0 8
41178: PUSH
41179: LD_VAR 0 1
41183: PPUSH
41184: LD_INT 6
41186: PPUSH
41187: EMPTY
41188: PPUSH
41189: CALL 12370 0 3
41193: PUSH
41194: FOR_IN
41195: IFFALSE 41226
// if GetLives ( k ) = 1000 then
41197: LD_VAR 0 8
41201: PPUSH
41202: CALL_OW 256
41206: PUSH
41207: LD_INT 1000
41209: EQUAL
41210: IFFALSE 41224
// SetTag ( k , 0 ) ;
41212: LD_VAR 0 8
41216: PPUSH
41217: LD_INT 0
41219: PPUSH
41220: CALL_OW 109
41224: GO 41194
41226: POP
41227: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41228: LD_VAR 0 1
41232: PPUSH
41233: LD_INT 0
41235: PPUSH
41236: LD_INT 25
41238: PUSH
41239: LD_INT 3
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PPUSH
41246: CALL 12370 0 3
41250: IFFALSE 41314
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41252: LD_ADDR_VAR 0 8
41256: PUSH
41257: LD_VAR 0 4
41261: PPUSH
41262: LD_INT 0
41264: PPUSH
41265: LD_INT 25
41267: PUSH
41268: LD_INT 3
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PPUSH
41275: CALL 12370 0 3
41279: PUSH
41280: FOR_IN
41281: IFFALSE 41312
// if GetTag ( k ) = 0 then
41283: LD_VAR 0 8
41287: PPUSH
41288: CALL_OW 110
41292: PUSH
41293: LD_INT 0
41295: EQUAL
41296: IFFALSE 41310
// begin SetTag ( k , 8 ) ;
41298: LD_VAR 0 8
41302: PPUSH
41303: LD_INT 8
41305: PPUSH
41306: CALL_OW 109
// end ;
41310: GO 41280
41312: POP
41313: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41314: LD_VAR 0 1
41318: PPUSH
41319: LD_INT 6
41321: PPUSH
41322: LD_INT 92
41324: PUSH
41325: LD_VAR 0 6
41329: PUSH
41330: LD_VAR 0 7
41334: PUSH
41335: LD_INT 10
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: LIST
41342: LIST
41343: PPUSH
41344: CALL 12370 0 3
41348: IFFALSE 41472
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41350: LD_ADDR_VAR 0 5
41354: PUSH
41355: LD_VAR 0 4
41359: PPUSH
41360: LD_INT 6
41362: PPUSH
41363: LD_INT 92
41365: PUSH
41366: LD_VAR 0 6
41370: PUSH
41371: LD_VAR 0 7
41375: PUSH
41376: LD_INT 10
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: PPUSH
41385: CALL 12370 0 3
41389: PUSH
41390: FOR_IN
41391: IFFALSE 41470
// begin if not HasTask ( j ) and GetDriver ( j ) then
41393: LD_VAR 0 5
41397: PPUSH
41398: CALL_OW 314
41402: NOT
41403: PUSH
41404: LD_VAR 0 5
41408: PPUSH
41409: CALL 31775 0 1
41413: AND
41414: IFFALSE 41468
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41416: LD_VAR 0 5
41420: PPUSH
41421: CALL 31775 0 1
41425: PPUSH
41426: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41430: LD_VAR 0 5
41434: PPUSH
41435: CALL 31775 0 1
41439: PPUSH
41440: LD_VAR 0 5
41444: PPUSH
41445: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41449: LD_VAR 0 5
41453: PPUSH
41454: CALL 31775 0 1
41458: PPUSH
41459: LD_VAR 0 5
41463: PPUSH
41464: CALL_OW 180
// end ; end ;
41468: GO 41390
41470: POP
41471: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41472: LD_VAR 0 1
41476: PPUSH
41477: LD_INT 6
41479: PPUSH
41480: LD_INT 92
41482: PUSH
41483: LD_VAR 0 6
41487: PUSH
41488: LD_VAR 0 7
41492: PUSH
41493: LD_INT 10
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL 12370 0 3
41506: PUSH
41507: LD_VAR 0 1
41511: PPUSH
41512: LD_INT 8
41514: PPUSH
41515: EMPTY
41516: PPUSH
41517: CALL 12370 0 3
41521: AND
41522: IFFALSE 41621
// for j in MCF_Tag ( side , 8 , [ ] ) do
41524: LD_ADDR_VAR 0 5
41528: PUSH
41529: LD_VAR 0 1
41533: PPUSH
41534: LD_INT 8
41536: PPUSH
41537: EMPTY
41538: PPUSH
41539: CALL 12370 0 3
41543: PUSH
41544: FOR_IN
41545: IFFALSE 41619
// begin if IsInUnit ( j ) then
41547: LD_VAR 0 5
41551: PPUSH
41552: CALL_OW 310
41556: IFFALSE 41569
// ComExitBuilding ( j ) else
41558: LD_VAR 0 5
41562: PPUSH
41563: CALL_OW 122
41567: GO 41617
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41569: LD_VAR 0 5
41573: PPUSH
41574: LD_VAR 0 1
41578: PPUSH
41579: LD_INT 6
41581: PPUSH
41582: LD_INT 92
41584: PUSH
41585: LD_VAR 0 6
41589: PUSH
41590: LD_VAR 0 7
41594: PUSH
41595: LD_INT 10
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: PPUSH
41604: CALL 12370 0 3
41608: PUSH
41609: LD_INT 1
41611: ARRAY
41612: PPUSH
41613: CALL_OW 129
// end ;
41617: GO 41544
41619: POP
41620: POP
// end ; end else
41621: GO 41678
// if MCF_Tag ( side , 8 , [ ] ) then
41623: LD_VAR 0 1
41627: PPUSH
41628: LD_INT 8
41630: PPUSH
41631: EMPTY
41632: PPUSH
41633: CALL 12370 0 3
41637: IFFALSE 41678
// for k in MCF_Tag ( side , 8 , [ ] ) do
41639: LD_ADDR_VAR 0 8
41643: PUSH
41644: LD_VAR 0 1
41648: PPUSH
41649: LD_INT 8
41651: PPUSH
41652: EMPTY
41653: PPUSH
41654: CALL 12370 0 3
41658: PUSH
41659: FOR_IN
41660: IFFALSE 41676
// SetTag ( k , 0 ) ;
41662: LD_VAR 0 8
41666: PPUSH
41667: LD_INT 0
41669: PPUSH
41670: CALL_OW 109
41674: GO 41659
41676: POP
41677: POP
// end ; end_of_file
41678: LD_VAR 0 3
41682: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41683: LD_INT 0
41685: PPUSH
// MREG_Game := [ ] ;
41686: LD_ADDR_EXP 33
41690: PUSH
41691: EMPTY
41692: ST_TO_ADDR
// MREG_Crates := [ ] ;
41693: LD_ADDR_EXP 34
41697: PUSH
41698: EMPTY
41699: ST_TO_ADDR
// MREG_Heal := [ ] ;
41700: LD_ADDR_EXP 35
41704: PUSH
41705: EMPTY
41706: ST_TO_ADDR
// MREG_Tame := [ ] ;
41707: LD_ADDR_EXP 37
41711: PUSH
41712: EMPTY
41713: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41714: LD_ADDR_EXP 38
41718: PUSH
41719: EMPTY
41720: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41721: LD_ADDR_EXP 39
41725: PUSH
41726: EMPTY
41727: ST_TO_ADDR
// MREG_LabList := [ ] ;
41728: LD_ADDR_EXP 40
41732: PUSH
41733: EMPTY
41734: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41735: LD_ADDR_EXP 41
41739: PUSH
41740: EMPTY
41741: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41742: LD_ADDR_EXP 42
41746: PUSH
41747: EMPTY
41748: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41749: LD_ADDR_EXP 43
41753: PUSH
41754: EMPTY
41755: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41756: LD_ADDR_EXP 44
41760: PUSH
41761: EMPTY
41762: ST_TO_ADDR
// MREG_Status := [ ] ;
41763: LD_ADDR_EXP 45
41767: PUSH
41768: EMPTY
41769: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41770: LD_ADDR_EXP 46
41774: PUSH
41775: EMPTY
41776: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41777: LD_ADDR_EXP 47
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41784: LD_ADDR_EXP 48
41788: PUSH
41789: EMPTY
41790: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41791: LD_ADDR_EXP 49
41795: PUSH
41796: EMPTY
41797: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41798: LD_ADDR_EXP 50
41802: PUSH
41803: EMPTY
41804: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41805: LD_ADDR_EXP 51
41809: PUSH
41810: EMPTY
41811: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41812: LD_ADDR_EXP 52
41816: PUSH
41817: EMPTY
41818: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41819: LD_ADDR_EXP 53
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41826: LD_ADDR_EXP 54
41830: PUSH
41831: EMPTY
41832: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41833: LD_ADDR_EXP 55
41837: PUSH
41838: EMPTY
41839: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41840: LD_ADDR_EXP 56
41844: PUSH
41845: EMPTY
41846: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41847: LD_ADDR_EXP 57
41851: PUSH
41852: EMPTY
41853: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41854: LD_ADDR_EXP 61
41858: PUSH
41859: EMPTY
41860: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41861: LD_ADDR_EXP 62
41865: PUSH
41866: EMPTY
41867: ST_TO_ADDR
// MREG_Parking := [ ] ;
41868: LD_ADDR_EXP 58
41872: PUSH
41873: EMPTY
41874: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41875: LD_ADDR_EXP 59
41879: PUSH
41880: EMPTY
41881: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41882: LD_ADDR_EXP 63
41886: PUSH
41887: EMPTY
41888: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41889: LD_ADDR_EXP 64
41893: PUSH
41894: EMPTY
41895: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41896: LD_ADDR_EXP 65
41900: PUSH
41901: EMPTY
41902: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41903: LD_ADDR_EXP 67
41907: PUSH
41908: EMPTY
41909: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41910: LD_ADDR_EXP 68
41914: PUSH
41915: EMPTY
41916: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41917: LD_ADDR_EXP 69
41921: PUSH
41922: EMPTY
41923: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41924: LD_ADDR_EXP 71
41928: PUSH
41929: EMPTY
41930: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41931: LD_ADDR_EXP 70
41935: PUSH
41936: EMPTY
41937: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41938: LD_ADDR_EXP 72
41942: PUSH
41943: LD_INT 300
41945: PUSH
41946: LD_INT 100
41948: PUSH
41949: LD_INT 25
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: LIST
41956: ST_TO_ADDR
// end ;
41957: LD_VAR 0 1
41961: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41962: LD_INT 0
41964: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41965: LD_VAR 0 2
41969: PUSH
41970: LD_VAR 0 3
41974: PUSH
41975: LD_VAR 0 4
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: LIST
41984: PUSH
41985: LD_VAR 0 1
41989: IN
41990: IFFALSE 42004
// result := mreg_list else
41992: LD_ADDR_VAR 0 5
41996: PUSH
41997: LD_VAR 0 1
42001: ST_TO_ADDR
42002: GO 42038
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42004: LD_ADDR_VAR 0 1
42008: PUSH
42009: LD_VAR 0 1
42013: PUSH
42014: LD_VAR 0 2
42018: PUSH
42019: LD_VAR 0 3
42023: PUSH
42024: LD_VAR 0 4
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: LIST
42033: PUSH
42034: EMPTY
42035: LIST
42036: ADD
42037: ST_TO_ADDR
// result := mreg_list ;
42038: LD_ADDR_VAR 0 5
42042: PUSH
42043: LD_VAR 0 1
42047: ST_TO_ADDR
// end ;
42048: LD_VAR 0 5
42052: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42053: LD_INT 0
42055: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42056: LD_VAR 0 2
42060: PUSH
42061: LD_VAR 0 3
42065: PUSH
42066: LD_VAR 0 4
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: LIST
42075: PUSH
42076: LD_VAR 0 1
42080: IN
42081: IFFALSE 42119
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42083: LD_ADDR_VAR 0 5
42087: PUSH
42088: LD_VAR 0 1
42092: PUSH
42093: LD_VAR 0 2
42097: PUSH
42098: LD_VAR 0 3
42102: PUSH
42103: LD_VAR 0 4
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: LIST
42112: PUSH
42113: EMPTY
42114: LIST
42115: DIFF
42116: ST_TO_ADDR
42117: GO 42129
// result := mreg_list ;
42119: LD_ADDR_VAR 0 5
42123: PUSH
42124: LD_VAR 0 1
42128: ST_TO_ADDR
// end ;
42129: LD_VAR 0 5
42133: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42134: LD_INT 0
42136: PPUSH
42137: PPUSH
42138: PPUSH
// for j = 1 to 8 do
42139: LD_ADDR_VAR 0 3
42143: PUSH
42144: DOUBLE
42145: LD_INT 1
42147: DEC
42148: ST_TO_ADDR
42149: LD_INT 8
42151: PUSH
42152: FOR_TO
42153: IFFALSE 42994
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42155: LD_VAR 0 3
42159: PPUSH
42160: LD_INT 51
42162: PUSH
42163: EMPTY
42164: LIST
42165: PPUSH
42166: CALL 11667 0 2
42170: PUSH
42171: LD_OWVAR 2
42175: PUSH
42176: LD_VAR 0 3
42180: EQUAL
42181: NOT
42182: AND
42183: IFFALSE 42201
// MREG_SidesList := MREG_SidesList ^ 1 else
42185: LD_ADDR_EXP 39
42189: PUSH
42190: LD_EXP 39
42194: PUSH
42195: LD_INT 1
42197: ADD
42198: ST_TO_ADDR
42199: GO 42215
// MREG_SidesList := MREG_SidesList ^ 0 ;
42201: LD_ADDR_EXP 39
42205: PUSH
42206: LD_EXP 39
42210: PUSH
42211: LD_INT 0
42213: ADD
42214: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42215: LD_VAR 0 3
42219: PPUSH
42220: LD_INT 2
42222: PUSH
42223: LD_INT 34
42225: PUSH
42226: LD_INT 12
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 34
42235: PUSH
42236: LD_INT 32
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 34
42245: PUSH
42246: LD_INT 51
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: PUSH
42259: EMPTY
42260: LIST
42261: PPUSH
42262: CALL 11968 0 2
42266: IFFALSE 42367
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42268: LD_ADDR_VAR 0 2
42272: PUSH
42273: LD_VAR 0 3
42277: PPUSH
42278: LD_INT 2
42280: PUSH
42281: LD_INT 34
42283: PUSH
42284: LD_INT 12
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 34
42293: PUSH
42294: LD_INT 32
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 34
42303: PUSH
42304: LD_INT 51
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: LIST
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PPUSH
42320: CALL 11968 0 2
42324: PUSH
42325: FOR_IN
42326: IFFALSE 42365
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42328: LD_ADDR_EXP 41
42332: PUSH
42333: LD_EXP 41
42337: PPUSH
42338: LD_VAR 0 3
42342: PPUSH
42343: LD_VAR 0 2
42347: PPUSH
42348: LD_VAR 0 2
42352: PPUSH
42353: CALL_OW 264
42357: PPUSH
42358: CALL 41962 0 4
42362: ST_TO_ADDR
42363: GO 42325
42365: POP
42366: POP
// if MCF_Class ( j , 4 , [ ] ) then
42367: LD_VAR 0 3
42371: PPUSH
42372: LD_INT 4
42374: PPUSH
42375: EMPTY
42376: PPUSH
42377: CALL 11750 0 3
42381: IFFALSE 42414
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42383: LD_ADDR_EXP 54
42387: PUSH
42388: LD_EXP 54
42392: PUSH
42393: LD_VAR 0 3
42397: PPUSH
42398: LD_INT 4
42400: PPUSH
42401: EMPTY
42402: PPUSH
42403: CALL 11750 0 3
42407: PUSH
42408: EMPTY
42409: LIST
42410: ADD
42411: ST_TO_ADDR
42412: GO 42431
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42414: LD_ADDR_EXP 54
42418: PUSH
42419: LD_EXP 54
42423: PUSH
42424: LD_INT 0
42426: PUSH
42427: EMPTY
42428: LIST
42429: ADD
42430: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42431: LD_VAR 0 3
42435: PPUSH
42436: LD_INT 3
42438: PPUSH
42439: EMPTY
42440: PPUSH
42441: CALL 11750 0 3
42445: IFFALSE 42478
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42447: LD_ADDR_EXP 55
42451: PUSH
42452: LD_EXP 55
42456: PUSH
42457: LD_VAR 0 3
42461: PPUSH
42462: LD_INT 3
42464: PPUSH
42465: EMPTY
42466: PPUSH
42467: CALL 11750 0 3
42471: PUSH
42472: EMPTY
42473: LIST
42474: ADD
42475: ST_TO_ADDR
42476: GO 42495
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42478: LD_ADDR_EXP 55
42482: PUSH
42483: LD_EXP 55
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: EMPTY
42492: LIST
42493: ADD
42494: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42495: LD_VAR 0 3
42499: PPUSH
42500: LD_INT 1
42502: PPUSH
42503: EMPTY
42504: PPUSH
42505: CALL 11750 0 3
42509: IFFALSE 42542
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42511: LD_ADDR_EXP 56
42515: PUSH
42516: LD_EXP 56
42520: PUSH
42521: LD_VAR 0 3
42525: PPUSH
42526: LD_INT 1
42528: PPUSH
42529: EMPTY
42530: PPUSH
42531: CALL 11750 0 3
42535: PUSH
42536: EMPTY
42537: LIST
42538: ADD
42539: ST_TO_ADDR
42540: GO 42559
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42542: LD_ADDR_EXP 56
42546: PUSH
42547: LD_EXP 56
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: ADD
42558: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42559: LD_VAR 0 3
42563: PPUSH
42564: LD_INT 2
42566: PPUSH
42567: EMPTY
42568: PPUSH
42569: CALL 11750 0 3
42573: IFFALSE 42606
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42575: LD_ADDR_EXP 57
42579: PUSH
42580: LD_EXP 57
42584: PUSH
42585: LD_VAR 0 3
42589: PPUSH
42590: LD_INT 2
42592: PPUSH
42593: EMPTY
42594: PPUSH
42595: CALL 11750 0 3
42599: PUSH
42600: EMPTY
42601: LIST
42602: ADD
42603: ST_TO_ADDR
42604: GO 42623
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42606: LD_ADDR_EXP 57
42610: PUSH
42611: LD_EXP 57
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: EMPTY
42620: LIST
42621: ADD
42622: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42623: LD_ADDR_EXP 47
42627: PUSH
42628: LD_EXP 47
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: EMPTY
42637: LIST
42638: ADD
42639: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42640: LD_ADDR_EXP 35
42644: PUSH
42645: LD_EXP 35
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: EMPTY
42654: LIST
42655: ADD
42656: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42657: LD_ADDR_EXP 37
42661: PUSH
42662: LD_EXP 37
42666: PUSH
42667: LD_INT 0
42669: PUSH
42670: EMPTY
42671: LIST
42672: ADD
42673: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42674: LD_ADDR_EXP 58
42678: PUSH
42679: LD_EXP 58
42683: PUSH
42684: LD_INT 0
42686: PUSH
42687: EMPTY
42688: LIST
42689: ADD
42690: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42691: LD_ADDR_EXP 59
42695: PUSH
42696: LD_EXP 59
42700: PUSH
42701: LD_INT 0
42703: PUSH
42704: EMPTY
42705: LIST
42706: ADD
42707: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42708: LD_ADDR_EXP 51
42712: PUSH
42713: LD_EXP 51
42717: PUSH
42718: LD_INT 0
42720: PUSH
42721: EMPTY
42722: LIST
42723: ADD
42724: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42725: LD_ADDR_EXP 38
42729: PUSH
42730: LD_EXP 38
42734: PUSH
42735: LD_INT 0
42737: PUSH
42738: LD_INT 0
42740: PUSH
42741: LD_INT 0
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: PUSH
42753: EMPTY
42754: LIST
42755: ADD
42756: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42757: LD_ADDR_EXP 60
42761: PUSH
42762: LD_EXP 60
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: EMPTY
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: EMPTY
42777: LIST
42778: ADD
42779: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42780: LD_ADDR_EXP 61
42784: PUSH
42785: LD_EXP 61
42789: PUSH
42790: LD_INT 0
42792: PUSH
42793: EMPTY
42794: LIST
42795: PUSH
42796: EMPTY
42797: LIST
42798: ADD
42799: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42800: LD_ADDR_EXP 42
42804: PUSH
42805: LD_EXP 42
42809: PUSH
42810: LD_INT 0
42812: PUSH
42813: EMPTY
42814: LIST
42815: ADD
42816: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42817: LD_ADDR_EXP 63
42821: PUSH
42822: LD_EXP 63
42826: PUSH
42827: LD_INT 0
42829: PUSH
42830: EMPTY
42831: LIST
42832: ADD
42833: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42834: LD_ADDR_EXP 64
42838: PUSH
42839: LD_EXP 64
42843: PUSH
42844: LD_INT 0
42846: PUSH
42847: EMPTY
42848: LIST
42849: ADD
42850: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42851: LD_ADDR_EXP 65
42855: PUSH
42856: LD_EXP 65
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: ADD
42867: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42868: LD_ADDR_EXP 66
42872: PUSH
42873: LD_EXP 66
42877: PUSH
42878: LD_INT 0
42880: PUSH
42881: EMPTY
42882: LIST
42883: ADD
42884: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42885: LD_ADDR_EXP 67
42889: PUSH
42890: LD_EXP 67
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: EMPTY
42899: LIST
42900: ADD
42901: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42902: LD_ADDR_EXP 68
42906: PUSH
42907: LD_EXP 68
42911: PUSH
42912: LD_INT 0
42914: PUSH
42915: EMPTY
42916: LIST
42917: ADD
42918: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42919: LD_ADDR_EXP 69
42923: PUSH
42924: LD_EXP 69
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: EMPTY
42933: LIST
42934: ADD
42935: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42936: LD_ADDR_EXP 71
42940: PUSH
42941: LD_EXP 71
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: EMPTY
42950: LIST
42951: ADD
42952: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42953: LD_ADDR_EXP 70
42957: PUSH
42958: LD_EXP 70
42962: PUSH
42963: LD_INT 0
42965: ADD
42966: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42967: LD_ADDR_EXP 62
42971: PUSH
42972: LD_EXP 62
42976: PUSH
42977: LD_INT 0
42979: PUSH
42980: LD_INT 0
42982: PUSH
42983: LD_INT 0
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: LIST
42990: ADD
42991: ST_TO_ADDR
// end ;
42992: GO 42152
42994: POP
42995: POP
// end ;
42996: LD_VAR 0 1
43000: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43001: LD_INT 0
43003: PPUSH
43004: PPUSH
43005: PPUSH
// m := false ;
43006: LD_ADDR_VAR 0 5
43010: PUSH
43011: LD_INT 0
43013: ST_TO_ADDR
// for i = 1 to mreg do
43014: LD_ADDR_VAR 0 4
43018: PUSH
43019: DOUBLE
43020: LD_INT 1
43022: DEC
43023: ST_TO_ADDR
43024: LD_VAR 0 2
43028: PUSH
43029: FOR_TO
43030: IFFALSE 43066
// if mreg [ i ] [ 1 ] = side then
43032: LD_VAR 0 2
43036: PUSH
43037: LD_VAR 0 4
43041: ARRAY
43042: PUSH
43043: LD_INT 1
43045: ARRAY
43046: PUSH
43047: LD_VAR 0 1
43051: EQUAL
43052: IFFALSE 43064
// begin m := true ;
43054: LD_ADDR_VAR 0 5
43058: PUSH
43059: LD_INT 1
43061: ST_TO_ADDR
// break ;
43062: GO 43066
// end ;
43064: GO 43029
43066: POP
43067: POP
// result := m ;
43068: LD_ADDR_VAR 0 3
43072: PUSH
43073: LD_VAR 0 5
43077: ST_TO_ADDR
// end ;
43078: LD_VAR 0 3
43082: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43083: LD_INT 0
43085: PPUSH
43086: PPUSH
43087: PPUSH
// m := 0 ;
43088: LD_ADDR_VAR 0 5
43092: PUSH
43093: LD_INT 0
43095: ST_TO_ADDR
// for i = 1 to mreg do
43096: LD_ADDR_VAR 0 4
43100: PUSH
43101: DOUBLE
43102: LD_INT 1
43104: DEC
43105: ST_TO_ADDR
43106: LD_VAR 0 2
43110: PUSH
43111: FOR_TO
43112: IFFALSE 43152
// if mreg [ i ] [ 1 ] = side then
43114: LD_VAR 0 2
43118: PUSH
43119: LD_VAR 0 4
43123: ARRAY
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: PUSH
43129: LD_VAR 0 1
43133: EQUAL
43134: IFFALSE 43150
// begin m := m + 1 ;
43136: LD_ADDR_VAR 0 5
43140: PUSH
43141: LD_VAR 0 5
43145: PUSH
43146: LD_INT 1
43148: PLUS
43149: ST_TO_ADDR
// end ;
43150: GO 43111
43152: POP
43153: POP
// result := m ;
43154: LD_ADDR_VAR 0 3
43158: PUSH
43159: LD_VAR 0 5
43163: ST_TO_ADDR
// end ;
43164: LD_VAR 0 3
43168: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43169: LD_INT 0
43171: PPUSH
43172: PPUSH
// result := 0 ;
43173: LD_ADDR_VAR 0 3
43177: PUSH
43178: LD_INT 0
43180: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43181: LD_ADDR_VAR 0 4
43185: PUSH
43186: DOUBLE
43187: LD_INT 1
43189: DEC
43190: ST_TO_ADDR
43191: LD_EXP 53
43195: PUSH
43196: FOR_TO
43197: IFFALSE 43259
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43199: LD_EXP 53
43203: PUSH
43204: LD_VAR 0 4
43208: ARRAY
43209: PUSH
43210: LD_INT 1
43212: ARRAY
43213: PUSH
43214: LD_VAR 0 1
43218: EQUAL
43219: PUSH
43220: LD_EXP 53
43224: PUSH
43225: LD_VAR 0 4
43229: ARRAY
43230: PUSH
43231: LD_INT 2
43233: ARRAY
43234: PUSH
43235: LD_VAR 0 2
43239: EQUAL
43240: AND
43241: IFFALSE 43257
// begin result := result + 1 ;
43243: LD_ADDR_VAR 0 3
43247: PUSH
43248: LD_VAR 0 3
43252: PUSH
43253: LD_INT 1
43255: PLUS
43256: ST_TO_ADDR
// end ;
43257: GO 43196
43259: POP
43260: POP
// end ; end_of_file
43261: LD_VAR 0 3
43265: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
43266: LD_INT 0
43268: PPUSH
// ar_miner := 81 ;
43269: LD_ADDR_EXP 80
43273: PUSH
43274: LD_INT 81
43276: ST_TO_ADDR
// ar_crane := 88 ;
43277: LD_ADDR_EXP 79
43281: PUSH
43282: LD_INT 88
43284: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43285: LD_ADDR_EXP 74
43289: PUSH
43290: LD_INT 89
43292: ST_TO_ADDR
// us_hack := 99 ;
43293: LD_ADDR_EXP 75
43297: PUSH
43298: LD_INT 99
43300: ST_TO_ADDR
// us_artillery := 97 ;
43301: LD_ADDR_EXP 76
43305: PUSH
43306: LD_INT 97
43308: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43309: LD_ADDR_EXP 77
43313: PUSH
43314: LD_INT 91
43316: ST_TO_ADDR
// ar_mortar := 92 ;
43317: LD_ADDR_EXP 78
43321: PUSH
43322: LD_INT 92
43324: ST_TO_ADDR
// ru_radar := 98 ;
43325: LD_ADDR_EXP 73
43329: PUSH
43330: LD_INT 98
43332: ST_TO_ADDR
// tech_Artillery := 80 ;
43333: LD_ADDR_EXP 81
43337: PUSH
43338: LD_INT 80
43340: ST_TO_ADDR
// tech_RadMat := 81 ;
43341: LD_ADDR_EXP 82
43345: PUSH
43346: LD_INT 81
43348: ST_TO_ADDR
// tech_BasicTools := 82 ;
43349: LD_ADDR_EXP 83
43353: PUSH
43354: LD_INT 82
43356: ST_TO_ADDR
// tech_Cargo := 83 ;
43357: LD_ADDR_EXP 84
43361: PUSH
43362: LD_INT 83
43364: ST_TO_ADDR
// tech_Track := 84 ;
43365: LD_ADDR_EXP 85
43369: PUSH
43370: LD_INT 84
43372: ST_TO_ADDR
// tech_Crane := 85 ;
43373: LD_ADDR_EXP 86
43377: PUSH
43378: LD_INT 85
43380: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43381: LD_ADDR_EXP 87
43385: PUSH
43386: LD_INT 86
43388: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43389: LD_ADDR_EXP 88
43393: PUSH
43394: LD_INT 87
43396: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
43397: LD_ADDR_EXP 89
43401: PUSH
43402: LD_INT 88
43404: ST_TO_ADDR
// class_mastodont := 31 ;
43405: LD_ADDR_EXP 90
43409: PUSH
43410: LD_INT 31
43412: ST_TO_ADDR
// class_horse := 21 ;
43413: LD_ADDR_EXP 91
43417: PUSH
43418: LD_INT 21
43420: ST_TO_ADDR
// end ;
43421: LD_VAR 0 1
43425: RET
// every 1 do
43426: GO 43428
43428: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43429: CALL 43266 0 0
43433: END
// every 0 0$1 do
43434: GO 43436
43436: DISABLE
// begin enable ;
43437: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43438: LD_STRING updateTimer(
43440: PUSH
43441: LD_OWVAR 1
43445: STR
43446: PUSH
43447: LD_STRING );
43449: STR
43450: PPUSH
43451: CALL_OW 559
// end ;
43455: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43456: LD_INT 0
43458: PPUSH
// if p2 = 100 then
43459: LD_VAR 0 2
43463: PUSH
43464: LD_INT 100
43466: EQUAL
43467: IFFALSE 44470
// begin if not StreamModeActive then
43469: LD_EXP 92
43473: NOT
43474: IFFALSE 43484
// StreamModeActive := true ;
43476: LD_ADDR_EXP 92
43480: PUSH
43481: LD_INT 1
43483: ST_TO_ADDR
// if p3 = 0 then
43484: LD_VAR 0 3
43488: PUSH
43489: LD_INT 0
43491: EQUAL
43492: IFFALSE 43498
// InitStreamMode ;
43494: CALL 44630 0 0
// if p3 = 1 then
43498: LD_VAR 0 3
43502: PUSH
43503: LD_INT 1
43505: EQUAL
43506: IFFALSE 43516
// sRocket := true ;
43508: LD_ADDR_EXP 97
43512: PUSH
43513: LD_INT 1
43515: ST_TO_ADDR
// if p3 = 2 then
43516: LD_VAR 0 3
43520: PUSH
43521: LD_INT 2
43523: EQUAL
43524: IFFALSE 43534
// sSpeed := true ;
43526: LD_ADDR_EXP 96
43530: PUSH
43531: LD_INT 1
43533: ST_TO_ADDR
// if p3 = 3 then
43534: LD_VAR 0 3
43538: PUSH
43539: LD_INT 3
43541: EQUAL
43542: IFFALSE 43552
// sEngine := true ;
43544: LD_ADDR_EXP 98
43548: PUSH
43549: LD_INT 1
43551: ST_TO_ADDR
// if p3 = 4 then
43552: LD_VAR 0 3
43556: PUSH
43557: LD_INT 4
43559: EQUAL
43560: IFFALSE 43570
// sSpec := true ;
43562: LD_ADDR_EXP 95
43566: PUSH
43567: LD_INT 1
43569: ST_TO_ADDR
// if p3 = 5 then
43570: LD_VAR 0 3
43574: PUSH
43575: LD_INT 5
43577: EQUAL
43578: IFFALSE 43588
// sLevel := true ;
43580: LD_ADDR_EXP 99
43584: PUSH
43585: LD_INT 1
43587: ST_TO_ADDR
// if p3 = 6 then
43588: LD_VAR 0 3
43592: PUSH
43593: LD_INT 6
43595: EQUAL
43596: IFFALSE 43606
// sArmoury := true ;
43598: LD_ADDR_EXP 100
43602: PUSH
43603: LD_INT 1
43605: ST_TO_ADDR
// if p3 = 7 then
43606: LD_VAR 0 3
43610: PUSH
43611: LD_INT 7
43613: EQUAL
43614: IFFALSE 43624
// sRadar := true ;
43616: LD_ADDR_EXP 101
43620: PUSH
43621: LD_INT 1
43623: ST_TO_ADDR
// if p3 = 8 then
43624: LD_VAR 0 3
43628: PUSH
43629: LD_INT 8
43631: EQUAL
43632: IFFALSE 43642
// sBunker := true ;
43634: LD_ADDR_EXP 102
43638: PUSH
43639: LD_INT 1
43641: ST_TO_ADDR
// if p3 = 9 then
43642: LD_VAR 0 3
43646: PUSH
43647: LD_INT 9
43649: EQUAL
43650: IFFALSE 43660
// sHack := true ;
43652: LD_ADDR_EXP 103
43656: PUSH
43657: LD_INT 1
43659: ST_TO_ADDR
// if p3 = 10 then
43660: LD_VAR 0 3
43664: PUSH
43665: LD_INT 10
43667: EQUAL
43668: IFFALSE 43678
// sFire := true ;
43670: LD_ADDR_EXP 104
43674: PUSH
43675: LD_INT 1
43677: ST_TO_ADDR
// if p3 = 11 then
43678: LD_VAR 0 3
43682: PUSH
43683: LD_INT 11
43685: EQUAL
43686: IFFALSE 43696
// sRefresh := true ;
43688: LD_ADDR_EXP 105
43692: PUSH
43693: LD_INT 1
43695: ST_TO_ADDR
// if p3 = 12 then
43696: LD_VAR 0 3
43700: PUSH
43701: LD_INT 12
43703: EQUAL
43704: IFFALSE 43714
// sExp := true ;
43706: LD_ADDR_EXP 106
43710: PUSH
43711: LD_INT 1
43713: ST_TO_ADDR
// if p3 = 13 then
43714: LD_VAR 0 3
43718: PUSH
43719: LD_INT 13
43721: EQUAL
43722: IFFALSE 43732
// sDepot := true ;
43724: LD_ADDR_EXP 107
43728: PUSH
43729: LD_INT 1
43731: ST_TO_ADDR
// if p3 = 14 then
43732: LD_VAR 0 3
43736: PUSH
43737: LD_INT 14
43739: EQUAL
43740: IFFALSE 43750
// sFlag := true ;
43742: LD_ADDR_EXP 108
43746: PUSH
43747: LD_INT 1
43749: ST_TO_ADDR
// if p3 = 15 then
43750: LD_VAR 0 3
43754: PUSH
43755: LD_INT 15
43757: EQUAL
43758: IFFALSE 43768
// sKamikadze := true ;
43760: LD_ADDR_EXP 116
43764: PUSH
43765: LD_INT 1
43767: ST_TO_ADDR
// if p3 = 16 then
43768: LD_VAR 0 3
43772: PUSH
43773: LD_INT 16
43775: EQUAL
43776: IFFALSE 43786
// sTroll := true ;
43778: LD_ADDR_EXP 117
43782: PUSH
43783: LD_INT 1
43785: ST_TO_ADDR
// if p3 = 17 then
43786: LD_VAR 0 3
43790: PUSH
43791: LD_INT 17
43793: EQUAL
43794: IFFALSE 43804
// sSlow := true ;
43796: LD_ADDR_EXP 118
43800: PUSH
43801: LD_INT 1
43803: ST_TO_ADDR
// if p3 = 18 then
43804: LD_VAR 0 3
43808: PUSH
43809: LD_INT 18
43811: EQUAL
43812: IFFALSE 43822
// sLack := true ;
43814: LD_ADDR_EXP 119
43818: PUSH
43819: LD_INT 1
43821: ST_TO_ADDR
// if p3 = 19 then
43822: LD_VAR 0 3
43826: PUSH
43827: LD_INT 19
43829: EQUAL
43830: IFFALSE 43840
// sTank := true ;
43832: LD_ADDR_EXP 121
43836: PUSH
43837: LD_INT 1
43839: ST_TO_ADDR
// if p3 = 20 then
43840: LD_VAR 0 3
43844: PUSH
43845: LD_INT 20
43847: EQUAL
43848: IFFALSE 43858
// sRemote := true ;
43850: LD_ADDR_EXP 122
43854: PUSH
43855: LD_INT 1
43857: ST_TO_ADDR
// if p3 = 21 then
43858: LD_VAR 0 3
43862: PUSH
43863: LD_INT 21
43865: EQUAL
43866: IFFALSE 43876
// sPowell := true ;
43868: LD_ADDR_EXP 123
43872: PUSH
43873: LD_INT 1
43875: ST_TO_ADDR
// if p3 = 22 then
43876: LD_VAR 0 3
43880: PUSH
43881: LD_INT 22
43883: EQUAL
43884: IFFALSE 43894
// sTeleport := true ;
43886: LD_ADDR_EXP 126
43890: PUSH
43891: LD_INT 1
43893: ST_TO_ADDR
// if p3 = 23 then
43894: LD_VAR 0 3
43898: PUSH
43899: LD_INT 23
43901: EQUAL
43902: IFFALSE 43912
// sOilTower := true ;
43904: LD_ADDR_EXP 128
43908: PUSH
43909: LD_INT 1
43911: ST_TO_ADDR
// if p3 = 24 then
43912: LD_VAR 0 3
43916: PUSH
43917: LD_INT 24
43919: EQUAL
43920: IFFALSE 43930
// sShovel := true ;
43922: LD_ADDR_EXP 129
43926: PUSH
43927: LD_INT 1
43929: ST_TO_ADDR
// if p3 = 25 then
43930: LD_VAR 0 3
43934: PUSH
43935: LD_INT 25
43937: EQUAL
43938: IFFALSE 43948
// sSheik := true ;
43940: LD_ADDR_EXP 130
43944: PUSH
43945: LD_INT 1
43947: ST_TO_ADDR
// if p3 = 26 then
43948: LD_VAR 0 3
43952: PUSH
43953: LD_INT 26
43955: EQUAL
43956: IFFALSE 43966
// sEarthquake := true ;
43958: LD_ADDR_EXP 132
43962: PUSH
43963: LD_INT 1
43965: ST_TO_ADDR
// if p3 = 27 then
43966: LD_VAR 0 3
43970: PUSH
43971: LD_INT 27
43973: EQUAL
43974: IFFALSE 43984
// sAI := true ;
43976: LD_ADDR_EXP 133
43980: PUSH
43981: LD_INT 1
43983: ST_TO_ADDR
// if p3 = 28 then
43984: LD_VAR 0 3
43988: PUSH
43989: LD_INT 28
43991: EQUAL
43992: IFFALSE 44002
// sCargo := true ;
43994: LD_ADDR_EXP 136
43998: PUSH
43999: LD_INT 1
44001: ST_TO_ADDR
// if p3 = 29 then
44002: LD_VAR 0 3
44006: PUSH
44007: LD_INT 29
44009: EQUAL
44010: IFFALSE 44020
// sDLaser := true ;
44012: LD_ADDR_EXP 137
44016: PUSH
44017: LD_INT 1
44019: ST_TO_ADDR
// if p3 = 30 then
44020: LD_VAR 0 3
44024: PUSH
44025: LD_INT 30
44027: EQUAL
44028: IFFALSE 44038
// sExchange := true ;
44030: LD_ADDR_EXP 138
44034: PUSH
44035: LD_INT 1
44037: ST_TO_ADDR
// if p3 = 31 then
44038: LD_VAR 0 3
44042: PUSH
44043: LD_INT 31
44045: EQUAL
44046: IFFALSE 44056
// sFac := true ;
44048: LD_ADDR_EXP 139
44052: PUSH
44053: LD_INT 1
44055: ST_TO_ADDR
// if p3 = 32 then
44056: LD_VAR 0 3
44060: PUSH
44061: LD_INT 32
44063: EQUAL
44064: IFFALSE 44074
// sPower := true ;
44066: LD_ADDR_EXP 140
44070: PUSH
44071: LD_INT 1
44073: ST_TO_ADDR
// if p3 = 33 then
44074: LD_VAR 0 3
44078: PUSH
44079: LD_INT 33
44081: EQUAL
44082: IFFALSE 44092
// sRandom := true ;
44084: LD_ADDR_EXP 141
44088: PUSH
44089: LD_INT 1
44091: ST_TO_ADDR
// if p3 = 34 then
44092: LD_VAR 0 3
44096: PUSH
44097: LD_INT 34
44099: EQUAL
44100: IFFALSE 44110
// sShield := true ;
44102: LD_ADDR_EXP 142
44106: PUSH
44107: LD_INT 1
44109: ST_TO_ADDR
// if p3 = 35 then
44110: LD_VAR 0 3
44114: PUSH
44115: LD_INT 35
44117: EQUAL
44118: IFFALSE 44128
// sTime := true ;
44120: LD_ADDR_EXP 143
44124: PUSH
44125: LD_INT 1
44127: ST_TO_ADDR
// if p3 = 36 then
44128: LD_VAR 0 3
44132: PUSH
44133: LD_INT 36
44135: EQUAL
44136: IFFALSE 44146
// sTools := true ;
44138: LD_ADDR_EXP 144
44142: PUSH
44143: LD_INT 1
44145: ST_TO_ADDR
// if p3 = 101 then
44146: LD_VAR 0 3
44150: PUSH
44151: LD_INT 101
44153: EQUAL
44154: IFFALSE 44164
// sSold := true ;
44156: LD_ADDR_EXP 109
44160: PUSH
44161: LD_INT 1
44163: ST_TO_ADDR
// if p3 = 102 then
44164: LD_VAR 0 3
44168: PUSH
44169: LD_INT 102
44171: EQUAL
44172: IFFALSE 44182
// sDiff := true ;
44174: LD_ADDR_EXP 110
44178: PUSH
44179: LD_INT 1
44181: ST_TO_ADDR
// if p3 = 103 then
44182: LD_VAR 0 3
44186: PUSH
44187: LD_INT 103
44189: EQUAL
44190: IFFALSE 44200
// sFog := true ;
44192: LD_ADDR_EXP 113
44196: PUSH
44197: LD_INT 1
44199: ST_TO_ADDR
// if p3 = 104 then
44200: LD_VAR 0 3
44204: PUSH
44205: LD_INT 104
44207: EQUAL
44208: IFFALSE 44218
// sReset := true ;
44210: LD_ADDR_EXP 114
44214: PUSH
44215: LD_INT 1
44217: ST_TO_ADDR
// if p3 = 105 then
44218: LD_VAR 0 3
44222: PUSH
44223: LD_INT 105
44225: EQUAL
44226: IFFALSE 44236
// sSun := true ;
44228: LD_ADDR_EXP 115
44232: PUSH
44233: LD_INT 1
44235: ST_TO_ADDR
// if p3 = 106 then
44236: LD_VAR 0 3
44240: PUSH
44241: LD_INT 106
44243: EQUAL
44244: IFFALSE 44254
// sTiger := true ;
44246: LD_ADDR_EXP 111
44250: PUSH
44251: LD_INT 1
44253: ST_TO_ADDR
// if p3 = 107 then
44254: LD_VAR 0 3
44258: PUSH
44259: LD_INT 107
44261: EQUAL
44262: IFFALSE 44272
// sBomb := true ;
44264: LD_ADDR_EXP 112
44268: PUSH
44269: LD_INT 1
44271: ST_TO_ADDR
// if p3 = 108 then
44272: LD_VAR 0 3
44276: PUSH
44277: LD_INT 108
44279: EQUAL
44280: IFFALSE 44290
// sWound := true ;
44282: LD_ADDR_EXP 120
44286: PUSH
44287: LD_INT 1
44289: ST_TO_ADDR
// if p3 = 109 then
44290: LD_VAR 0 3
44294: PUSH
44295: LD_INT 109
44297: EQUAL
44298: IFFALSE 44308
// sBetray := true ;
44300: LD_ADDR_EXP 124
44304: PUSH
44305: LD_INT 1
44307: ST_TO_ADDR
// if p3 = 110 then
44308: LD_VAR 0 3
44312: PUSH
44313: LD_INT 110
44315: EQUAL
44316: IFFALSE 44326
// sContamin := true ;
44318: LD_ADDR_EXP 125
44322: PUSH
44323: LD_INT 1
44325: ST_TO_ADDR
// if p3 = 111 then
44326: LD_VAR 0 3
44330: PUSH
44331: LD_INT 111
44333: EQUAL
44334: IFFALSE 44344
// sOil := true ;
44336: LD_ADDR_EXP 127
44340: PUSH
44341: LD_INT 1
44343: ST_TO_ADDR
// if p3 = 112 then
44344: LD_VAR 0 3
44348: PUSH
44349: LD_INT 112
44351: EQUAL
44352: IFFALSE 44362
// sStu := true ;
44354: LD_ADDR_EXP 131
44358: PUSH
44359: LD_INT 1
44361: ST_TO_ADDR
// if p3 = 113 then
44362: LD_VAR 0 3
44366: PUSH
44367: LD_INT 113
44369: EQUAL
44370: IFFALSE 44380
// sBazooka := true ;
44372: LD_ADDR_EXP 134
44376: PUSH
44377: LD_INT 1
44379: ST_TO_ADDR
// if p3 = 114 then
44380: LD_VAR 0 3
44384: PUSH
44385: LD_INT 114
44387: EQUAL
44388: IFFALSE 44398
// sMortar := true ;
44390: LD_ADDR_EXP 135
44394: PUSH
44395: LD_INT 1
44397: ST_TO_ADDR
// if p3 = 115 then
44398: LD_VAR 0 3
44402: PUSH
44403: LD_INT 115
44405: EQUAL
44406: IFFALSE 44416
// sRanger := true ;
44408: LD_ADDR_EXP 145
44412: PUSH
44413: LD_INT 1
44415: ST_TO_ADDR
// if p3 = 116 then
44416: LD_VAR 0 3
44420: PUSH
44421: LD_INT 116
44423: EQUAL
44424: IFFALSE 44434
// sComputer := true ;
44426: LD_ADDR_EXP 146
44430: PUSH
44431: LD_INT 1
44433: ST_TO_ADDR
// if p3 = 117 then
44434: LD_VAR 0 3
44438: PUSH
44439: LD_INT 117
44441: EQUAL
44442: IFFALSE 44452
// s30 := true ;
44444: LD_ADDR_EXP 147
44448: PUSH
44449: LD_INT 1
44451: ST_TO_ADDR
// if p3 = 118 then
44452: LD_VAR 0 3
44456: PUSH
44457: LD_INT 118
44459: EQUAL
44460: IFFALSE 44470
// s60 := true ;
44462: LD_ADDR_EXP 148
44466: PUSH
44467: LD_INT 1
44469: ST_TO_ADDR
// end ; if p2 = 101 then
44470: LD_VAR 0 2
44474: PUSH
44475: LD_INT 101
44477: EQUAL
44478: IFFALSE 44606
// begin case p3 of 1 :
44480: LD_VAR 0 3
44484: PUSH
44485: LD_INT 1
44487: DOUBLE
44488: EQUAL
44489: IFTRUE 44493
44491: GO 44500
44493: POP
// hHackUnlimitedResources ; 2 :
44494: CALL 56202 0 0
44498: GO 44606
44500: LD_INT 2
44502: DOUBLE
44503: EQUAL
44504: IFTRUE 44508
44506: GO 44515
44508: POP
// hHackSetLevel10 ; 3 :
44509: CALL 56335 0 0
44513: GO 44606
44515: LD_INT 3
44517: DOUBLE
44518: EQUAL
44519: IFTRUE 44523
44521: GO 44530
44523: POP
// hHackSetLevel10YourUnits ; 4 :
44524: CALL 56420 0 0
44528: GO 44606
44530: LD_INT 4
44532: DOUBLE
44533: EQUAL
44534: IFTRUE 44538
44536: GO 44545
44538: POP
// hHackInvincible ; 5 :
44539: CALL 56868 0 0
44543: GO 44606
44545: LD_INT 5
44547: DOUBLE
44548: EQUAL
44549: IFTRUE 44553
44551: GO 44560
44553: POP
// hHackInvisible ; 6 :
44554: CALL 56979 0 0
44558: GO 44606
44560: LD_INT 6
44562: DOUBLE
44563: EQUAL
44564: IFTRUE 44568
44566: GO 44575
44568: POP
// hHackChangeYourSide ; 7 :
44569: CALL 57036 0 0
44573: GO 44606
44575: LD_INT 7
44577: DOUBLE
44578: EQUAL
44579: IFTRUE 44583
44581: GO 44590
44583: POP
// hHackChangeUnitSide ; 8 :
44584: CALL 57078 0 0
44588: GO 44606
44590: LD_INT 8
44592: DOUBLE
44593: EQUAL
44594: IFTRUE 44598
44596: GO 44605
44598: POP
// hHackFog ; end ;
44599: CALL 57179 0 0
44603: GO 44606
44605: POP
// end ; end ;
44606: LD_VAR 0 7
44610: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
44611: GO 44613
44613: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44614: LD_STRING initStreamRollete();
44616: PPUSH
44617: CALL_OW 559
// InitStreamMode ;
44621: CALL 44630 0 0
// DefineStreamItems ( ) ;
44625: CALL 45094 0 0
// end ;
44629: END
// function InitStreamMode ; begin
44630: LD_INT 0
44632: PPUSH
// streamModeActive := false ;
44633: LD_ADDR_EXP 92
44637: PUSH
44638: LD_INT 0
44640: ST_TO_ADDR
// normalCounter := 36 ;
44641: LD_ADDR_EXP 93
44645: PUSH
44646: LD_INT 36
44648: ST_TO_ADDR
// hardcoreCounter := 16 ;
44649: LD_ADDR_EXP 94
44653: PUSH
44654: LD_INT 16
44656: ST_TO_ADDR
// sRocket := false ;
44657: LD_ADDR_EXP 97
44661: PUSH
44662: LD_INT 0
44664: ST_TO_ADDR
// sSpeed := false ;
44665: LD_ADDR_EXP 96
44669: PUSH
44670: LD_INT 0
44672: ST_TO_ADDR
// sEngine := false ;
44673: LD_ADDR_EXP 98
44677: PUSH
44678: LD_INT 0
44680: ST_TO_ADDR
// sSpec := false ;
44681: LD_ADDR_EXP 95
44685: PUSH
44686: LD_INT 0
44688: ST_TO_ADDR
// sLevel := false ;
44689: LD_ADDR_EXP 99
44693: PUSH
44694: LD_INT 0
44696: ST_TO_ADDR
// sArmoury := false ;
44697: LD_ADDR_EXP 100
44701: PUSH
44702: LD_INT 0
44704: ST_TO_ADDR
// sRadar := false ;
44705: LD_ADDR_EXP 101
44709: PUSH
44710: LD_INT 0
44712: ST_TO_ADDR
// sBunker := false ;
44713: LD_ADDR_EXP 102
44717: PUSH
44718: LD_INT 0
44720: ST_TO_ADDR
// sHack := false ;
44721: LD_ADDR_EXP 103
44725: PUSH
44726: LD_INT 0
44728: ST_TO_ADDR
// sFire := false ;
44729: LD_ADDR_EXP 104
44733: PUSH
44734: LD_INT 0
44736: ST_TO_ADDR
// sRefresh := false ;
44737: LD_ADDR_EXP 105
44741: PUSH
44742: LD_INT 0
44744: ST_TO_ADDR
// sExp := false ;
44745: LD_ADDR_EXP 106
44749: PUSH
44750: LD_INT 0
44752: ST_TO_ADDR
// sDepot := false ;
44753: LD_ADDR_EXP 107
44757: PUSH
44758: LD_INT 0
44760: ST_TO_ADDR
// sFlag := false ;
44761: LD_ADDR_EXP 108
44765: PUSH
44766: LD_INT 0
44768: ST_TO_ADDR
// sKamikadze := false ;
44769: LD_ADDR_EXP 116
44773: PUSH
44774: LD_INT 0
44776: ST_TO_ADDR
// sTroll := false ;
44777: LD_ADDR_EXP 117
44781: PUSH
44782: LD_INT 0
44784: ST_TO_ADDR
// sSlow := false ;
44785: LD_ADDR_EXP 118
44789: PUSH
44790: LD_INT 0
44792: ST_TO_ADDR
// sLack := false ;
44793: LD_ADDR_EXP 119
44797: PUSH
44798: LD_INT 0
44800: ST_TO_ADDR
// sTank := false ;
44801: LD_ADDR_EXP 121
44805: PUSH
44806: LD_INT 0
44808: ST_TO_ADDR
// sRemote := false ;
44809: LD_ADDR_EXP 122
44813: PUSH
44814: LD_INT 0
44816: ST_TO_ADDR
// sPowell := false ;
44817: LD_ADDR_EXP 123
44821: PUSH
44822: LD_INT 0
44824: ST_TO_ADDR
// sTeleport := false ;
44825: LD_ADDR_EXP 126
44829: PUSH
44830: LD_INT 0
44832: ST_TO_ADDR
// sOilTower := false ;
44833: LD_ADDR_EXP 128
44837: PUSH
44838: LD_INT 0
44840: ST_TO_ADDR
// sShovel := false ;
44841: LD_ADDR_EXP 129
44845: PUSH
44846: LD_INT 0
44848: ST_TO_ADDR
// sSheik := false ;
44849: LD_ADDR_EXP 130
44853: PUSH
44854: LD_INT 0
44856: ST_TO_ADDR
// sEarthquake := false ;
44857: LD_ADDR_EXP 132
44861: PUSH
44862: LD_INT 0
44864: ST_TO_ADDR
// sAI := false ;
44865: LD_ADDR_EXP 133
44869: PUSH
44870: LD_INT 0
44872: ST_TO_ADDR
// sCargo := false ;
44873: LD_ADDR_EXP 136
44877: PUSH
44878: LD_INT 0
44880: ST_TO_ADDR
// sDLaser := false ;
44881: LD_ADDR_EXP 137
44885: PUSH
44886: LD_INT 0
44888: ST_TO_ADDR
// sExchange := false ;
44889: LD_ADDR_EXP 138
44893: PUSH
44894: LD_INT 0
44896: ST_TO_ADDR
// sFac := false ;
44897: LD_ADDR_EXP 139
44901: PUSH
44902: LD_INT 0
44904: ST_TO_ADDR
// sPower := false ;
44905: LD_ADDR_EXP 140
44909: PUSH
44910: LD_INT 0
44912: ST_TO_ADDR
// sRandom := false ;
44913: LD_ADDR_EXP 141
44917: PUSH
44918: LD_INT 0
44920: ST_TO_ADDR
// sShield := false ;
44921: LD_ADDR_EXP 142
44925: PUSH
44926: LD_INT 0
44928: ST_TO_ADDR
// sTime := false ;
44929: LD_ADDR_EXP 143
44933: PUSH
44934: LD_INT 0
44936: ST_TO_ADDR
// sTools := false ;
44937: LD_ADDR_EXP 144
44941: PUSH
44942: LD_INT 0
44944: ST_TO_ADDR
// sSold := false ;
44945: LD_ADDR_EXP 109
44949: PUSH
44950: LD_INT 0
44952: ST_TO_ADDR
// sDiff := false ;
44953: LD_ADDR_EXP 110
44957: PUSH
44958: LD_INT 0
44960: ST_TO_ADDR
// sFog := false ;
44961: LD_ADDR_EXP 113
44965: PUSH
44966: LD_INT 0
44968: ST_TO_ADDR
// sReset := false ;
44969: LD_ADDR_EXP 114
44973: PUSH
44974: LD_INT 0
44976: ST_TO_ADDR
// sSun := false ;
44977: LD_ADDR_EXP 115
44981: PUSH
44982: LD_INT 0
44984: ST_TO_ADDR
// sTiger := false ;
44985: LD_ADDR_EXP 111
44989: PUSH
44990: LD_INT 0
44992: ST_TO_ADDR
// sBomb := false ;
44993: LD_ADDR_EXP 112
44997: PUSH
44998: LD_INT 0
45000: ST_TO_ADDR
// sWound := false ;
45001: LD_ADDR_EXP 120
45005: PUSH
45006: LD_INT 0
45008: ST_TO_ADDR
// sBetray := false ;
45009: LD_ADDR_EXP 124
45013: PUSH
45014: LD_INT 0
45016: ST_TO_ADDR
// sContamin := false ;
45017: LD_ADDR_EXP 125
45021: PUSH
45022: LD_INT 0
45024: ST_TO_ADDR
// sOil := false ;
45025: LD_ADDR_EXP 127
45029: PUSH
45030: LD_INT 0
45032: ST_TO_ADDR
// sStu := false ;
45033: LD_ADDR_EXP 131
45037: PUSH
45038: LD_INT 0
45040: ST_TO_ADDR
// sBazooka := false ;
45041: LD_ADDR_EXP 134
45045: PUSH
45046: LD_INT 0
45048: ST_TO_ADDR
// sMortar := false ;
45049: LD_ADDR_EXP 135
45053: PUSH
45054: LD_INT 0
45056: ST_TO_ADDR
// sRanger := false ;
45057: LD_ADDR_EXP 145
45061: PUSH
45062: LD_INT 0
45064: ST_TO_ADDR
// sComputer := false ;
45065: LD_ADDR_EXP 146
45069: PUSH
45070: LD_INT 0
45072: ST_TO_ADDR
// s30 := false ;
45073: LD_ADDR_EXP 147
45077: PUSH
45078: LD_INT 0
45080: ST_TO_ADDR
// s60 := false ;
45081: LD_ADDR_EXP 148
45085: PUSH
45086: LD_INT 0
45088: ST_TO_ADDR
// end ;
45089: LD_VAR 0 1
45093: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
45094: LD_INT 0
45096: PPUSH
45097: PPUSH
45098: PPUSH
45099: PPUSH
45100: PPUSH
// result := [ ] ;
45101: LD_ADDR_VAR 0 1
45105: PUSH
45106: EMPTY
45107: ST_TO_ADDR
// if campaign_id = 1 then
45108: LD_OWVAR 69
45112: PUSH
45113: LD_INT 1
45115: EQUAL
45116: IFFALSE 48282
// begin case mission_number of 1 :
45118: LD_OWVAR 70
45122: PUSH
45123: LD_INT 1
45125: DOUBLE
45126: EQUAL
45127: IFTRUE 45131
45129: GO 45207
45131: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45132: LD_ADDR_VAR 0 1
45136: PUSH
45137: LD_INT 2
45139: PUSH
45140: LD_INT 4
45142: PUSH
45143: LD_INT 11
45145: PUSH
45146: LD_INT 12
45148: PUSH
45149: LD_INT 15
45151: PUSH
45152: LD_INT 16
45154: PUSH
45155: LD_INT 22
45157: PUSH
45158: LD_INT 23
45160: PUSH
45161: LD_INT 26
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: LIST
45170: LIST
45171: LIST
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 101
45177: PUSH
45178: LD_INT 102
45180: PUSH
45181: LD_INT 106
45183: PUSH
45184: LD_INT 116
45186: PUSH
45187: LD_INT 117
45189: PUSH
45190: LD_INT 118
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: ST_TO_ADDR
45205: GO 48280
45207: LD_INT 2
45209: DOUBLE
45210: EQUAL
45211: IFTRUE 45215
45213: GO 45299
45215: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45216: LD_ADDR_VAR 0 1
45220: PUSH
45221: LD_INT 2
45223: PUSH
45224: LD_INT 4
45226: PUSH
45227: LD_INT 11
45229: PUSH
45230: LD_INT 12
45232: PUSH
45233: LD_INT 15
45235: PUSH
45236: LD_INT 16
45238: PUSH
45239: LD_INT 22
45241: PUSH
45242: LD_INT 23
45244: PUSH
45245: LD_INT 26
45247: PUSH
45248: EMPTY
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: PUSH
45259: LD_INT 101
45261: PUSH
45262: LD_INT 102
45264: PUSH
45265: LD_INT 105
45267: PUSH
45268: LD_INT 106
45270: PUSH
45271: LD_INT 108
45273: PUSH
45274: LD_INT 116
45276: PUSH
45277: LD_INT 117
45279: PUSH
45280: LD_INT 118
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: LIST
45287: LIST
45288: LIST
45289: LIST
45290: LIST
45291: LIST
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: ST_TO_ADDR
45297: GO 48280
45299: LD_INT 3
45301: DOUBLE
45302: EQUAL
45303: IFTRUE 45307
45305: GO 45395
45307: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45308: LD_ADDR_VAR 0 1
45312: PUSH
45313: LD_INT 2
45315: PUSH
45316: LD_INT 4
45318: PUSH
45319: LD_INT 5
45321: PUSH
45322: LD_INT 11
45324: PUSH
45325: LD_INT 12
45327: PUSH
45328: LD_INT 15
45330: PUSH
45331: LD_INT 16
45333: PUSH
45334: LD_INT 22
45336: PUSH
45337: LD_INT 26
45339: PUSH
45340: LD_INT 36
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: PUSH
45355: LD_INT 101
45357: PUSH
45358: LD_INT 102
45360: PUSH
45361: LD_INT 105
45363: PUSH
45364: LD_INT 106
45366: PUSH
45367: LD_INT 108
45369: PUSH
45370: LD_INT 116
45372: PUSH
45373: LD_INT 117
45375: PUSH
45376: LD_INT 118
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: LIST
45386: LIST
45387: LIST
45388: PUSH
45389: EMPTY
45390: LIST
45391: LIST
45392: ST_TO_ADDR
45393: GO 48280
45395: LD_INT 4
45397: DOUBLE
45398: EQUAL
45399: IFTRUE 45403
45401: GO 45499
45403: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45404: LD_ADDR_VAR 0 1
45408: PUSH
45409: LD_INT 2
45411: PUSH
45412: LD_INT 4
45414: PUSH
45415: LD_INT 5
45417: PUSH
45418: LD_INT 8
45420: PUSH
45421: LD_INT 11
45423: PUSH
45424: LD_INT 12
45426: PUSH
45427: LD_INT 15
45429: PUSH
45430: LD_INT 16
45432: PUSH
45433: LD_INT 22
45435: PUSH
45436: LD_INT 23
45438: PUSH
45439: LD_INT 26
45441: PUSH
45442: LD_INT 36
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: LIST
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 101
45461: PUSH
45462: LD_INT 102
45464: PUSH
45465: LD_INT 105
45467: PUSH
45468: LD_INT 106
45470: PUSH
45471: LD_INT 108
45473: PUSH
45474: LD_INT 116
45476: PUSH
45477: LD_INT 117
45479: PUSH
45480: LD_INT 118
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: ST_TO_ADDR
45497: GO 48280
45499: LD_INT 5
45501: DOUBLE
45502: EQUAL
45503: IFTRUE 45507
45505: GO 45619
45507: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45508: LD_ADDR_VAR 0 1
45512: PUSH
45513: LD_INT 2
45515: PUSH
45516: LD_INT 4
45518: PUSH
45519: LD_INT 5
45521: PUSH
45522: LD_INT 6
45524: PUSH
45525: LD_INT 8
45527: PUSH
45528: LD_INT 11
45530: PUSH
45531: LD_INT 12
45533: PUSH
45534: LD_INT 15
45536: PUSH
45537: LD_INT 16
45539: PUSH
45540: LD_INT 22
45542: PUSH
45543: LD_INT 23
45545: PUSH
45546: LD_INT 25
45548: PUSH
45549: LD_INT 26
45551: PUSH
45552: LD_INT 36
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 101
45573: PUSH
45574: LD_INT 102
45576: PUSH
45577: LD_INT 105
45579: PUSH
45580: LD_INT 106
45582: PUSH
45583: LD_INT 108
45585: PUSH
45586: LD_INT 109
45588: PUSH
45589: LD_INT 112
45591: PUSH
45592: LD_INT 116
45594: PUSH
45595: LD_INT 117
45597: PUSH
45598: LD_INT 118
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: ST_TO_ADDR
45617: GO 48280
45619: LD_INT 6
45621: DOUBLE
45622: EQUAL
45623: IFTRUE 45627
45625: GO 45759
45627: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45628: LD_ADDR_VAR 0 1
45632: PUSH
45633: LD_INT 2
45635: PUSH
45636: LD_INT 4
45638: PUSH
45639: LD_INT 5
45641: PUSH
45642: LD_INT 6
45644: PUSH
45645: LD_INT 8
45647: PUSH
45648: LD_INT 11
45650: PUSH
45651: LD_INT 12
45653: PUSH
45654: LD_INT 15
45656: PUSH
45657: LD_INT 16
45659: PUSH
45660: LD_INT 20
45662: PUSH
45663: LD_INT 21
45665: PUSH
45666: LD_INT 22
45668: PUSH
45669: LD_INT 23
45671: PUSH
45672: LD_INT 25
45674: PUSH
45675: LD_INT 26
45677: PUSH
45678: LD_INT 30
45680: PUSH
45681: LD_INT 31
45683: PUSH
45684: LD_INT 32
45686: PUSH
45687: LD_INT 36
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: PUSH
45711: LD_INT 101
45713: PUSH
45714: LD_INT 102
45716: PUSH
45717: LD_INT 105
45719: PUSH
45720: LD_INT 106
45722: PUSH
45723: LD_INT 108
45725: PUSH
45726: LD_INT 109
45728: PUSH
45729: LD_INT 112
45731: PUSH
45732: LD_INT 116
45734: PUSH
45735: LD_INT 117
45737: PUSH
45738: LD_INT 118
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: LIST
45745: LIST
45746: LIST
45747: LIST
45748: LIST
45749: LIST
45750: LIST
45751: LIST
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: ST_TO_ADDR
45757: GO 48280
45759: LD_INT 7
45761: DOUBLE
45762: EQUAL
45763: IFTRUE 45767
45765: GO 45879
45767: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45768: LD_ADDR_VAR 0 1
45772: PUSH
45773: LD_INT 2
45775: PUSH
45776: LD_INT 4
45778: PUSH
45779: LD_INT 5
45781: PUSH
45782: LD_INT 7
45784: PUSH
45785: LD_INT 11
45787: PUSH
45788: LD_INT 12
45790: PUSH
45791: LD_INT 15
45793: PUSH
45794: LD_INT 16
45796: PUSH
45797: LD_INT 20
45799: PUSH
45800: LD_INT 21
45802: PUSH
45803: LD_INT 22
45805: PUSH
45806: LD_INT 23
45808: PUSH
45809: LD_INT 25
45811: PUSH
45812: LD_INT 26
45814: PUSH
45815: EMPTY
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 101
45833: PUSH
45834: LD_INT 102
45836: PUSH
45837: LD_INT 103
45839: PUSH
45840: LD_INT 105
45842: PUSH
45843: LD_INT 106
45845: PUSH
45846: LD_INT 108
45848: PUSH
45849: LD_INT 112
45851: PUSH
45852: LD_INT 116
45854: PUSH
45855: LD_INT 117
45857: PUSH
45858: LD_INT 118
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: ST_TO_ADDR
45877: GO 48280
45879: LD_INT 8
45881: DOUBLE
45882: EQUAL
45883: IFTRUE 45887
45885: GO 46027
45887: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45888: LD_ADDR_VAR 0 1
45892: PUSH
45893: LD_INT 2
45895: PUSH
45896: LD_INT 4
45898: PUSH
45899: LD_INT 5
45901: PUSH
45902: LD_INT 6
45904: PUSH
45905: LD_INT 7
45907: PUSH
45908: LD_INT 8
45910: PUSH
45911: LD_INT 11
45913: PUSH
45914: LD_INT 12
45916: PUSH
45917: LD_INT 15
45919: PUSH
45920: LD_INT 16
45922: PUSH
45923: LD_INT 20
45925: PUSH
45926: LD_INT 21
45928: PUSH
45929: LD_INT 22
45931: PUSH
45932: LD_INT 23
45934: PUSH
45935: LD_INT 25
45937: PUSH
45938: LD_INT 26
45940: PUSH
45941: LD_INT 30
45943: PUSH
45944: LD_INT 31
45946: PUSH
45947: LD_INT 32
45949: PUSH
45950: LD_INT 36
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: PUSH
45975: LD_INT 101
45977: PUSH
45978: LD_INT 102
45980: PUSH
45981: LD_INT 103
45983: PUSH
45984: LD_INT 105
45986: PUSH
45987: LD_INT 106
45989: PUSH
45990: LD_INT 108
45992: PUSH
45993: LD_INT 109
45995: PUSH
45996: LD_INT 112
45998: PUSH
45999: LD_INT 116
46001: PUSH
46002: LD_INT 117
46004: PUSH
46005: LD_INT 118
46007: PUSH
46008: EMPTY
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: ST_TO_ADDR
46025: GO 48280
46027: LD_INT 9
46029: DOUBLE
46030: EQUAL
46031: IFTRUE 46035
46033: GO 46183
46035: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46036: LD_ADDR_VAR 0 1
46040: PUSH
46041: LD_INT 2
46043: PUSH
46044: LD_INT 4
46046: PUSH
46047: LD_INT 5
46049: PUSH
46050: LD_INT 6
46052: PUSH
46053: LD_INT 7
46055: PUSH
46056: LD_INT 8
46058: PUSH
46059: LD_INT 11
46061: PUSH
46062: LD_INT 12
46064: PUSH
46065: LD_INT 15
46067: PUSH
46068: LD_INT 16
46070: PUSH
46071: LD_INT 20
46073: PUSH
46074: LD_INT 21
46076: PUSH
46077: LD_INT 22
46079: PUSH
46080: LD_INT 23
46082: PUSH
46083: LD_INT 25
46085: PUSH
46086: LD_INT 26
46088: PUSH
46089: LD_INT 28
46091: PUSH
46092: LD_INT 30
46094: PUSH
46095: LD_INT 31
46097: PUSH
46098: LD_INT 32
46100: PUSH
46101: LD_INT 36
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: LIST
46108: LIST
46109: LIST
46110: LIST
46111: LIST
46112: LIST
46113: LIST
46114: LIST
46115: LIST
46116: LIST
46117: LIST
46118: LIST
46119: LIST
46120: LIST
46121: LIST
46122: LIST
46123: LIST
46124: LIST
46125: LIST
46126: PUSH
46127: LD_INT 101
46129: PUSH
46130: LD_INT 102
46132: PUSH
46133: LD_INT 103
46135: PUSH
46136: LD_INT 105
46138: PUSH
46139: LD_INT 106
46141: PUSH
46142: LD_INT 108
46144: PUSH
46145: LD_INT 109
46147: PUSH
46148: LD_INT 112
46150: PUSH
46151: LD_INT 114
46153: PUSH
46154: LD_INT 116
46156: PUSH
46157: LD_INT 117
46159: PUSH
46160: LD_INT 118
46162: PUSH
46163: EMPTY
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: PUSH
46177: EMPTY
46178: LIST
46179: LIST
46180: ST_TO_ADDR
46181: GO 48280
46183: LD_INT 10
46185: DOUBLE
46186: EQUAL
46187: IFTRUE 46191
46189: GO 46387
46191: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46192: LD_ADDR_VAR 0 1
46196: PUSH
46197: LD_INT 2
46199: PUSH
46200: LD_INT 4
46202: PUSH
46203: LD_INT 5
46205: PUSH
46206: LD_INT 6
46208: PUSH
46209: LD_INT 7
46211: PUSH
46212: LD_INT 8
46214: PUSH
46215: LD_INT 9
46217: PUSH
46218: LD_INT 10
46220: PUSH
46221: LD_INT 11
46223: PUSH
46224: LD_INT 12
46226: PUSH
46227: LD_INT 13
46229: PUSH
46230: LD_INT 14
46232: PUSH
46233: LD_INT 15
46235: PUSH
46236: LD_INT 16
46238: PUSH
46239: LD_INT 17
46241: PUSH
46242: LD_INT 18
46244: PUSH
46245: LD_INT 19
46247: PUSH
46248: LD_INT 20
46250: PUSH
46251: LD_INT 21
46253: PUSH
46254: LD_INT 22
46256: PUSH
46257: LD_INT 23
46259: PUSH
46260: LD_INT 24
46262: PUSH
46263: LD_INT 25
46265: PUSH
46266: LD_INT 26
46268: PUSH
46269: LD_INT 28
46271: PUSH
46272: LD_INT 30
46274: PUSH
46275: LD_INT 31
46277: PUSH
46278: LD_INT 32
46280: PUSH
46281: LD_INT 36
46283: PUSH
46284: EMPTY
46285: LIST
46286: LIST
46287: LIST
46288: LIST
46289: LIST
46290: LIST
46291: LIST
46292: LIST
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: PUSH
46315: LD_INT 101
46317: PUSH
46318: LD_INT 102
46320: PUSH
46321: LD_INT 103
46323: PUSH
46324: LD_INT 104
46326: PUSH
46327: LD_INT 105
46329: PUSH
46330: LD_INT 106
46332: PUSH
46333: LD_INT 107
46335: PUSH
46336: LD_INT 108
46338: PUSH
46339: LD_INT 109
46341: PUSH
46342: LD_INT 110
46344: PUSH
46345: LD_INT 111
46347: PUSH
46348: LD_INT 112
46350: PUSH
46351: LD_INT 114
46353: PUSH
46354: LD_INT 116
46356: PUSH
46357: LD_INT 117
46359: PUSH
46360: LD_INT 118
46362: PUSH
46363: EMPTY
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: ST_TO_ADDR
46385: GO 48280
46387: LD_INT 11
46389: DOUBLE
46390: EQUAL
46391: IFTRUE 46395
46393: GO 46599
46395: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46396: LD_ADDR_VAR 0 1
46400: PUSH
46401: LD_INT 2
46403: PUSH
46404: LD_INT 3
46406: PUSH
46407: LD_INT 4
46409: PUSH
46410: LD_INT 5
46412: PUSH
46413: LD_INT 6
46415: PUSH
46416: LD_INT 7
46418: PUSH
46419: LD_INT 8
46421: PUSH
46422: LD_INT 9
46424: PUSH
46425: LD_INT 10
46427: PUSH
46428: LD_INT 11
46430: PUSH
46431: LD_INT 12
46433: PUSH
46434: LD_INT 13
46436: PUSH
46437: LD_INT 14
46439: PUSH
46440: LD_INT 15
46442: PUSH
46443: LD_INT 16
46445: PUSH
46446: LD_INT 17
46448: PUSH
46449: LD_INT 18
46451: PUSH
46452: LD_INT 19
46454: PUSH
46455: LD_INT 20
46457: PUSH
46458: LD_INT 21
46460: PUSH
46461: LD_INT 22
46463: PUSH
46464: LD_INT 23
46466: PUSH
46467: LD_INT 24
46469: PUSH
46470: LD_INT 25
46472: PUSH
46473: LD_INT 26
46475: PUSH
46476: LD_INT 28
46478: PUSH
46479: LD_INT 30
46481: PUSH
46482: LD_INT 31
46484: PUSH
46485: LD_INT 32
46487: PUSH
46488: LD_INT 34
46490: PUSH
46491: LD_INT 36
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: LIST
46498: LIST
46499: LIST
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: PUSH
46527: LD_INT 101
46529: PUSH
46530: LD_INT 102
46532: PUSH
46533: LD_INT 103
46535: PUSH
46536: LD_INT 104
46538: PUSH
46539: LD_INT 105
46541: PUSH
46542: LD_INT 106
46544: PUSH
46545: LD_INT 107
46547: PUSH
46548: LD_INT 108
46550: PUSH
46551: LD_INT 109
46553: PUSH
46554: LD_INT 110
46556: PUSH
46557: LD_INT 111
46559: PUSH
46560: LD_INT 112
46562: PUSH
46563: LD_INT 114
46565: PUSH
46566: LD_INT 116
46568: PUSH
46569: LD_INT 117
46571: PUSH
46572: LD_INT 118
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: ST_TO_ADDR
46597: GO 48280
46599: LD_INT 12
46601: DOUBLE
46602: EQUAL
46603: IFTRUE 46607
46605: GO 46827
46607: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46608: LD_ADDR_VAR 0 1
46612: PUSH
46613: LD_INT 1
46615: PUSH
46616: LD_INT 2
46618: PUSH
46619: LD_INT 3
46621: PUSH
46622: LD_INT 4
46624: PUSH
46625: LD_INT 5
46627: PUSH
46628: LD_INT 6
46630: PUSH
46631: LD_INT 7
46633: PUSH
46634: LD_INT 8
46636: PUSH
46637: LD_INT 9
46639: PUSH
46640: LD_INT 10
46642: PUSH
46643: LD_INT 11
46645: PUSH
46646: LD_INT 12
46648: PUSH
46649: LD_INT 13
46651: PUSH
46652: LD_INT 14
46654: PUSH
46655: LD_INT 15
46657: PUSH
46658: LD_INT 16
46660: PUSH
46661: LD_INT 17
46663: PUSH
46664: LD_INT 18
46666: PUSH
46667: LD_INT 19
46669: PUSH
46670: LD_INT 20
46672: PUSH
46673: LD_INT 21
46675: PUSH
46676: LD_INT 22
46678: PUSH
46679: LD_INT 23
46681: PUSH
46682: LD_INT 24
46684: PUSH
46685: LD_INT 25
46687: PUSH
46688: LD_INT 26
46690: PUSH
46691: LD_INT 27
46693: PUSH
46694: LD_INT 28
46696: PUSH
46697: LD_INT 30
46699: PUSH
46700: LD_INT 31
46702: PUSH
46703: LD_INT 32
46705: PUSH
46706: LD_INT 33
46708: PUSH
46709: LD_INT 34
46711: PUSH
46712: LD_INT 36
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: LIST
46719: LIST
46720: LIST
46721: LIST
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 101
46753: PUSH
46754: LD_INT 102
46756: PUSH
46757: LD_INT 103
46759: PUSH
46760: LD_INT 104
46762: PUSH
46763: LD_INT 105
46765: PUSH
46766: LD_INT 106
46768: PUSH
46769: LD_INT 107
46771: PUSH
46772: LD_INT 108
46774: PUSH
46775: LD_INT 109
46777: PUSH
46778: LD_INT 110
46780: PUSH
46781: LD_INT 111
46783: PUSH
46784: LD_INT 112
46786: PUSH
46787: LD_INT 113
46789: PUSH
46790: LD_INT 114
46792: PUSH
46793: LD_INT 116
46795: PUSH
46796: LD_INT 117
46798: PUSH
46799: LD_INT 118
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: PUSH
46821: EMPTY
46822: LIST
46823: LIST
46824: ST_TO_ADDR
46825: GO 48280
46827: LD_INT 13
46829: DOUBLE
46830: EQUAL
46831: IFTRUE 46835
46833: GO 47043
46835: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46836: LD_ADDR_VAR 0 1
46840: PUSH
46841: LD_INT 1
46843: PUSH
46844: LD_INT 2
46846: PUSH
46847: LD_INT 3
46849: PUSH
46850: LD_INT 4
46852: PUSH
46853: LD_INT 5
46855: PUSH
46856: LD_INT 8
46858: PUSH
46859: LD_INT 9
46861: PUSH
46862: LD_INT 10
46864: PUSH
46865: LD_INT 11
46867: PUSH
46868: LD_INT 12
46870: PUSH
46871: LD_INT 14
46873: PUSH
46874: LD_INT 15
46876: PUSH
46877: LD_INT 16
46879: PUSH
46880: LD_INT 17
46882: PUSH
46883: LD_INT 18
46885: PUSH
46886: LD_INT 19
46888: PUSH
46889: LD_INT 20
46891: PUSH
46892: LD_INT 21
46894: PUSH
46895: LD_INT 22
46897: PUSH
46898: LD_INT 23
46900: PUSH
46901: LD_INT 24
46903: PUSH
46904: LD_INT 25
46906: PUSH
46907: LD_INT 26
46909: PUSH
46910: LD_INT 27
46912: PUSH
46913: LD_INT 28
46915: PUSH
46916: LD_INT 30
46918: PUSH
46919: LD_INT 31
46921: PUSH
46922: LD_INT 32
46924: PUSH
46925: LD_INT 33
46927: PUSH
46928: LD_INT 34
46930: PUSH
46931: LD_INT 36
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: LIST
46938: LIST
46939: LIST
46940: LIST
46941: LIST
46942: LIST
46943: LIST
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: PUSH
46967: LD_INT 101
46969: PUSH
46970: LD_INT 102
46972: PUSH
46973: LD_INT 103
46975: PUSH
46976: LD_INT 104
46978: PUSH
46979: LD_INT 105
46981: PUSH
46982: LD_INT 106
46984: PUSH
46985: LD_INT 107
46987: PUSH
46988: LD_INT 108
46990: PUSH
46991: LD_INT 109
46993: PUSH
46994: LD_INT 110
46996: PUSH
46997: LD_INT 111
46999: PUSH
47000: LD_INT 112
47002: PUSH
47003: LD_INT 113
47005: PUSH
47006: LD_INT 114
47008: PUSH
47009: LD_INT 116
47011: PUSH
47012: LD_INT 117
47014: PUSH
47015: LD_INT 118
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: ST_TO_ADDR
47041: GO 48280
47043: LD_INT 14
47045: DOUBLE
47046: EQUAL
47047: IFTRUE 47051
47049: GO 47275
47051: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47052: LD_ADDR_VAR 0 1
47056: PUSH
47057: LD_INT 1
47059: PUSH
47060: LD_INT 2
47062: PUSH
47063: LD_INT 3
47065: PUSH
47066: LD_INT 4
47068: PUSH
47069: LD_INT 5
47071: PUSH
47072: LD_INT 6
47074: PUSH
47075: LD_INT 7
47077: PUSH
47078: LD_INT 8
47080: PUSH
47081: LD_INT 9
47083: PUSH
47084: LD_INT 10
47086: PUSH
47087: LD_INT 11
47089: PUSH
47090: LD_INT 12
47092: PUSH
47093: LD_INT 13
47095: PUSH
47096: LD_INT 14
47098: PUSH
47099: LD_INT 15
47101: PUSH
47102: LD_INT 16
47104: PUSH
47105: LD_INT 17
47107: PUSH
47108: LD_INT 18
47110: PUSH
47111: LD_INT 19
47113: PUSH
47114: LD_INT 20
47116: PUSH
47117: LD_INT 21
47119: PUSH
47120: LD_INT 22
47122: PUSH
47123: LD_INT 23
47125: PUSH
47126: LD_INT 24
47128: PUSH
47129: LD_INT 25
47131: PUSH
47132: LD_INT 26
47134: PUSH
47135: LD_INT 27
47137: PUSH
47138: LD_INT 28
47140: PUSH
47141: LD_INT 29
47143: PUSH
47144: LD_INT 30
47146: PUSH
47147: LD_INT 31
47149: PUSH
47150: LD_INT 32
47152: PUSH
47153: LD_INT 33
47155: PUSH
47156: LD_INT 34
47158: PUSH
47159: LD_INT 36
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: LIST
47166: LIST
47167: LIST
47168: LIST
47169: LIST
47170: LIST
47171: LIST
47172: LIST
47173: LIST
47174: LIST
47175: LIST
47176: LIST
47177: LIST
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: PUSH
47199: LD_INT 101
47201: PUSH
47202: LD_INT 102
47204: PUSH
47205: LD_INT 103
47207: PUSH
47208: LD_INT 104
47210: PUSH
47211: LD_INT 105
47213: PUSH
47214: LD_INT 106
47216: PUSH
47217: LD_INT 107
47219: PUSH
47220: LD_INT 108
47222: PUSH
47223: LD_INT 109
47225: PUSH
47226: LD_INT 110
47228: PUSH
47229: LD_INT 111
47231: PUSH
47232: LD_INT 112
47234: PUSH
47235: LD_INT 113
47237: PUSH
47238: LD_INT 114
47240: PUSH
47241: LD_INT 116
47243: PUSH
47244: LD_INT 117
47246: PUSH
47247: LD_INT 118
47249: PUSH
47250: EMPTY
47251: LIST
47252: LIST
47253: LIST
47254: LIST
47255: LIST
47256: LIST
47257: LIST
47258: LIST
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: ST_TO_ADDR
47273: GO 48280
47275: LD_INT 15
47277: DOUBLE
47278: EQUAL
47279: IFTRUE 47283
47281: GO 47507
47283: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47284: LD_ADDR_VAR 0 1
47288: PUSH
47289: LD_INT 1
47291: PUSH
47292: LD_INT 2
47294: PUSH
47295: LD_INT 3
47297: PUSH
47298: LD_INT 4
47300: PUSH
47301: LD_INT 5
47303: PUSH
47304: LD_INT 6
47306: PUSH
47307: LD_INT 7
47309: PUSH
47310: LD_INT 8
47312: PUSH
47313: LD_INT 9
47315: PUSH
47316: LD_INT 10
47318: PUSH
47319: LD_INT 11
47321: PUSH
47322: LD_INT 12
47324: PUSH
47325: LD_INT 13
47327: PUSH
47328: LD_INT 14
47330: PUSH
47331: LD_INT 15
47333: PUSH
47334: LD_INT 16
47336: PUSH
47337: LD_INT 17
47339: PUSH
47340: LD_INT 18
47342: PUSH
47343: LD_INT 19
47345: PUSH
47346: LD_INT 20
47348: PUSH
47349: LD_INT 21
47351: PUSH
47352: LD_INT 22
47354: PUSH
47355: LD_INT 23
47357: PUSH
47358: LD_INT 24
47360: PUSH
47361: LD_INT 25
47363: PUSH
47364: LD_INT 26
47366: PUSH
47367: LD_INT 27
47369: PUSH
47370: LD_INT 28
47372: PUSH
47373: LD_INT 29
47375: PUSH
47376: LD_INT 30
47378: PUSH
47379: LD_INT 31
47381: PUSH
47382: LD_INT 32
47384: PUSH
47385: LD_INT 33
47387: PUSH
47388: LD_INT 34
47390: PUSH
47391: LD_INT 36
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: PUSH
47431: LD_INT 101
47433: PUSH
47434: LD_INT 102
47436: PUSH
47437: LD_INT 103
47439: PUSH
47440: LD_INT 104
47442: PUSH
47443: LD_INT 105
47445: PUSH
47446: LD_INT 106
47448: PUSH
47449: LD_INT 107
47451: PUSH
47452: LD_INT 108
47454: PUSH
47455: LD_INT 109
47457: PUSH
47458: LD_INT 110
47460: PUSH
47461: LD_INT 111
47463: PUSH
47464: LD_INT 112
47466: PUSH
47467: LD_INT 113
47469: PUSH
47470: LD_INT 114
47472: PUSH
47473: LD_INT 116
47475: PUSH
47476: LD_INT 117
47478: PUSH
47479: LD_INT 118
47481: PUSH
47482: EMPTY
47483: LIST
47484: LIST
47485: LIST
47486: LIST
47487: LIST
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: ST_TO_ADDR
47505: GO 48280
47507: LD_INT 16
47509: DOUBLE
47510: EQUAL
47511: IFTRUE 47515
47513: GO 47651
47515: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47516: LD_ADDR_VAR 0 1
47520: PUSH
47521: LD_INT 2
47523: PUSH
47524: LD_INT 4
47526: PUSH
47527: LD_INT 5
47529: PUSH
47530: LD_INT 7
47532: PUSH
47533: LD_INT 11
47535: PUSH
47536: LD_INT 12
47538: PUSH
47539: LD_INT 15
47541: PUSH
47542: LD_INT 16
47544: PUSH
47545: LD_INT 20
47547: PUSH
47548: LD_INT 21
47550: PUSH
47551: LD_INT 22
47553: PUSH
47554: LD_INT 23
47556: PUSH
47557: LD_INT 25
47559: PUSH
47560: LD_INT 26
47562: PUSH
47563: LD_INT 30
47565: PUSH
47566: LD_INT 31
47568: PUSH
47569: LD_INT 32
47571: PUSH
47572: LD_INT 33
47574: PUSH
47575: LD_INT 34
47577: PUSH
47578: EMPTY
47579: LIST
47580: LIST
47581: LIST
47582: LIST
47583: LIST
47584: LIST
47585: LIST
47586: LIST
47587: LIST
47588: LIST
47589: LIST
47590: LIST
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: LIST
47598: PUSH
47599: LD_INT 101
47601: PUSH
47602: LD_INT 102
47604: PUSH
47605: LD_INT 103
47607: PUSH
47608: LD_INT 106
47610: PUSH
47611: LD_INT 108
47613: PUSH
47614: LD_INT 112
47616: PUSH
47617: LD_INT 113
47619: PUSH
47620: LD_INT 114
47622: PUSH
47623: LD_INT 116
47625: PUSH
47626: LD_INT 117
47628: PUSH
47629: LD_INT 118
47631: PUSH
47632: EMPTY
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: LIST
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: PUSH
47645: EMPTY
47646: LIST
47647: LIST
47648: ST_TO_ADDR
47649: GO 48280
47651: LD_INT 17
47653: DOUBLE
47654: EQUAL
47655: IFTRUE 47659
47657: GO 47883
47659: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47660: LD_ADDR_VAR 0 1
47664: PUSH
47665: LD_INT 1
47667: PUSH
47668: LD_INT 2
47670: PUSH
47671: LD_INT 3
47673: PUSH
47674: LD_INT 4
47676: PUSH
47677: LD_INT 5
47679: PUSH
47680: LD_INT 6
47682: PUSH
47683: LD_INT 7
47685: PUSH
47686: LD_INT 8
47688: PUSH
47689: LD_INT 9
47691: PUSH
47692: LD_INT 10
47694: PUSH
47695: LD_INT 11
47697: PUSH
47698: LD_INT 12
47700: PUSH
47701: LD_INT 13
47703: PUSH
47704: LD_INT 14
47706: PUSH
47707: LD_INT 15
47709: PUSH
47710: LD_INT 16
47712: PUSH
47713: LD_INT 17
47715: PUSH
47716: LD_INT 18
47718: PUSH
47719: LD_INT 19
47721: PUSH
47722: LD_INT 20
47724: PUSH
47725: LD_INT 21
47727: PUSH
47728: LD_INT 22
47730: PUSH
47731: LD_INT 23
47733: PUSH
47734: LD_INT 24
47736: PUSH
47737: LD_INT 25
47739: PUSH
47740: LD_INT 26
47742: PUSH
47743: LD_INT 27
47745: PUSH
47746: LD_INT 28
47748: PUSH
47749: LD_INT 29
47751: PUSH
47752: LD_INT 30
47754: PUSH
47755: LD_INT 31
47757: PUSH
47758: LD_INT 32
47760: PUSH
47761: LD_INT 33
47763: PUSH
47764: LD_INT 34
47766: PUSH
47767: LD_INT 36
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: LIST
47774: LIST
47775: LIST
47776: LIST
47777: LIST
47778: LIST
47779: LIST
47780: LIST
47781: LIST
47782: LIST
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: PUSH
47807: LD_INT 101
47809: PUSH
47810: LD_INT 102
47812: PUSH
47813: LD_INT 103
47815: PUSH
47816: LD_INT 104
47818: PUSH
47819: LD_INT 105
47821: PUSH
47822: LD_INT 106
47824: PUSH
47825: LD_INT 107
47827: PUSH
47828: LD_INT 108
47830: PUSH
47831: LD_INT 109
47833: PUSH
47834: LD_INT 110
47836: PUSH
47837: LD_INT 111
47839: PUSH
47840: LD_INT 112
47842: PUSH
47843: LD_INT 113
47845: PUSH
47846: LD_INT 114
47848: PUSH
47849: LD_INT 116
47851: PUSH
47852: LD_INT 117
47854: PUSH
47855: LD_INT 118
47857: PUSH
47858: EMPTY
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: PUSH
47877: EMPTY
47878: LIST
47879: LIST
47880: ST_TO_ADDR
47881: GO 48280
47883: LD_INT 18
47885: DOUBLE
47886: EQUAL
47887: IFTRUE 47891
47889: GO 48039
47891: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47892: LD_ADDR_VAR 0 1
47896: PUSH
47897: LD_INT 2
47899: PUSH
47900: LD_INT 4
47902: PUSH
47903: LD_INT 5
47905: PUSH
47906: LD_INT 7
47908: PUSH
47909: LD_INT 11
47911: PUSH
47912: LD_INT 12
47914: PUSH
47915: LD_INT 15
47917: PUSH
47918: LD_INT 16
47920: PUSH
47921: LD_INT 20
47923: PUSH
47924: LD_INT 21
47926: PUSH
47927: LD_INT 22
47929: PUSH
47930: LD_INT 23
47932: PUSH
47933: LD_INT 25
47935: PUSH
47936: LD_INT 26
47938: PUSH
47939: LD_INT 30
47941: PUSH
47942: LD_INT 31
47944: PUSH
47945: LD_INT 32
47947: PUSH
47948: LD_INT 33
47950: PUSH
47951: LD_INT 34
47953: PUSH
47954: LD_INT 35
47956: PUSH
47957: LD_INT 36
47959: PUSH
47960: EMPTY
47961: LIST
47962: LIST
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: LIST
47969: LIST
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: PUSH
47983: LD_INT 101
47985: PUSH
47986: LD_INT 102
47988: PUSH
47989: LD_INT 103
47991: PUSH
47992: LD_INT 106
47994: PUSH
47995: LD_INT 108
47997: PUSH
47998: LD_INT 112
48000: PUSH
48001: LD_INT 113
48003: PUSH
48004: LD_INT 114
48006: PUSH
48007: LD_INT 115
48009: PUSH
48010: LD_INT 116
48012: PUSH
48013: LD_INT 117
48015: PUSH
48016: LD_INT 118
48018: PUSH
48019: EMPTY
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: ST_TO_ADDR
48037: GO 48280
48039: LD_INT 19
48041: DOUBLE
48042: EQUAL
48043: IFTRUE 48047
48045: GO 48279
48047: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48048: LD_ADDR_VAR 0 1
48052: PUSH
48053: LD_INT 1
48055: PUSH
48056: LD_INT 2
48058: PUSH
48059: LD_INT 3
48061: PUSH
48062: LD_INT 4
48064: PUSH
48065: LD_INT 5
48067: PUSH
48068: LD_INT 6
48070: PUSH
48071: LD_INT 7
48073: PUSH
48074: LD_INT 8
48076: PUSH
48077: LD_INT 9
48079: PUSH
48080: LD_INT 10
48082: PUSH
48083: LD_INT 11
48085: PUSH
48086: LD_INT 12
48088: PUSH
48089: LD_INT 13
48091: PUSH
48092: LD_INT 14
48094: PUSH
48095: LD_INT 15
48097: PUSH
48098: LD_INT 16
48100: PUSH
48101: LD_INT 17
48103: PUSH
48104: LD_INT 18
48106: PUSH
48107: LD_INT 19
48109: PUSH
48110: LD_INT 20
48112: PUSH
48113: LD_INT 21
48115: PUSH
48116: LD_INT 22
48118: PUSH
48119: LD_INT 23
48121: PUSH
48122: LD_INT 24
48124: PUSH
48125: LD_INT 25
48127: PUSH
48128: LD_INT 26
48130: PUSH
48131: LD_INT 27
48133: PUSH
48134: LD_INT 28
48136: PUSH
48137: LD_INT 29
48139: PUSH
48140: LD_INT 30
48142: PUSH
48143: LD_INT 31
48145: PUSH
48146: LD_INT 32
48148: PUSH
48149: LD_INT 33
48151: PUSH
48152: LD_INT 34
48154: PUSH
48155: LD_INT 35
48157: PUSH
48158: LD_INT 36
48160: PUSH
48161: EMPTY
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: LIST
48197: LIST
48198: PUSH
48199: LD_INT 101
48201: PUSH
48202: LD_INT 102
48204: PUSH
48205: LD_INT 103
48207: PUSH
48208: LD_INT 104
48210: PUSH
48211: LD_INT 105
48213: PUSH
48214: LD_INT 106
48216: PUSH
48217: LD_INT 107
48219: PUSH
48220: LD_INT 108
48222: PUSH
48223: LD_INT 109
48225: PUSH
48226: LD_INT 110
48228: PUSH
48229: LD_INT 111
48231: PUSH
48232: LD_INT 112
48234: PUSH
48235: LD_INT 113
48237: PUSH
48238: LD_INT 114
48240: PUSH
48241: LD_INT 115
48243: PUSH
48244: LD_INT 116
48246: PUSH
48247: LD_INT 117
48249: PUSH
48250: LD_INT 118
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: PUSH
48273: EMPTY
48274: LIST
48275: LIST
48276: ST_TO_ADDR
48277: GO 48280
48279: POP
// end else
48280: GO 48511
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48282: LD_ADDR_VAR 0 1
48286: PUSH
48287: LD_INT 1
48289: PUSH
48290: LD_INT 2
48292: PUSH
48293: LD_INT 3
48295: PUSH
48296: LD_INT 4
48298: PUSH
48299: LD_INT 5
48301: PUSH
48302: LD_INT 6
48304: PUSH
48305: LD_INT 7
48307: PUSH
48308: LD_INT 8
48310: PUSH
48311: LD_INT 9
48313: PUSH
48314: LD_INT 10
48316: PUSH
48317: LD_INT 11
48319: PUSH
48320: LD_INT 12
48322: PUSH
48323: LD_INT 13
48325: PUSH
48326: LD_INT 14
48328: PUSH
48329: LD_INT 15
48331: PUSH
48332: LD_INT 16
48334: PUSH
48335: LD_INT 17
48337: PUSH
48338: LD_INT 18
48340: PUSH
48341: LD_INT 19
48343: PUSH
48344: LD_INT 20
48346: PUSH
48347: LD_INT 21
48349: PUSH
48350: LD_INT 22
48352: PUSH
48353: LD_INT 23
48355: PUSH
48356: LD_INT 24
48358: PUSH
48359: LD_INT 25
48361: PUSH
48362: LD_INT 26
48364: PUSH
48365: LD_INT 27
48367: PUSH
48368: LD_INT 28
48370: PUSH
48371: LD_INT 29
48373: PUSH
48374: LD_INT 30
48376: PUSH
48377: LD_INT 31
48379: PUSH
48380: LD_INT 32
48382: PUSH
48383: LD_INT 33
48385: PUSH
48386: LD_INT 34
48388: PUSH
48389: LD_INT 35
48391: PUSH
48392: LD_INT 36
48394: PUSH
48395: EMPTY
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: PUSH
48433: LD_INT 101
48435: PUSH
48436: LD_INT 102
48438: PUSH
48439: LD_INT 103
48441: PUSH
48442: LD_INT 104
48444: PUSH
48445: LD_INT 105
48447: PUSH
48448: LD_INT 106
48450: PUSH
48451: LD_INT 107
48453: PUSH
48454: LD_INT 108
48456: PUSH
48457: LD_INT 109
48459: PUSH
48460: LD_INT 110
48462: PUSH
48463: LD_INT 111
48465: PUSH
48466: LD_INT 112
48468: PUSH
48469: LD_INT 113
48471: PUSH
48472: LD_INT 114
48474: PUSH
48475: LD_INT 115
48477: PUSH
48478: LD_INT 116
48480: PUSH
48481: LD_INT 117
48483: PUSH
48484: LD_INT 118
48486: PUSH
48487: EMPTY
48488: LIST
48489: LIST
48490: LIST
48491: LIST
48492: LIST
48493: LIST
48494: LIST
48495: LIST
48496: LIST
48497: LIST
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: LIST
48505: LIST
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: ST_TO_ADDR
// if result then
48511: LD_VAR 0 1
48515: IFFALSE 48804
// begin normal :=  ;
48517: LD_ADDR_VAR 0 3
48521: PUSH
48522: LD_STRING 
48524: ST_TO_ADDR
// hardcore :=  ;
48525: LD_ADDR_VAR 0 4
48529: PUSH
48530: LD_STRING 
48532: ST_TO_ADDR
// for i = 1 to normalCounter do
48533: LD_ADDR_VAR 0 5
48537: PUSH
48538: DOUBLE
48539: LD_INT 1
48541: DEC
48542: ST_TO_ADDR
48543: LD_EXP 93
48547: PUSH
48548: FOR_TO
48549: IFFALSE 48650
// begin tmp := 0 ;
48551: LD_ADDR_VAR 0 2
48555: PUSH
48556: LD_STRING 0
48558: ST_TO_ADDR
// if result [ 1 ] then
48559: LD_VAR 0 1
48563: PUSH
48564: LD_INT 1
48566: ARRAY
48567: IFFALSE 48632
// if result [ 1 ] [ 1 ] = i then
48569: LD_VAR 0 1
48573: PUSH
48574: LD_INT 1
48576: ARRAY
48577: PUSH
48578: LD_INT 1
48580: ARRAY
48581: PUSH
48582: LD_VAR 0 5
48586: EQUAL
48587: IFFALSE 48632
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48589: LD_ADDR_VAR 0 1
48593: PUSH
48594: LD_VAR 0 1
48598: PPUSH
48599: LD_INT 1
48601: PPUSH
48602: LD_VAR 0 1
48606: PUSH
48607: LD_INT 1
48609: ARRAY
48610: PPUSH
48611: LD_INT 1
48613: PPUSH
48614: CALL_OW 3
48618: PPUSH
48619: CALL_OW 1
48623: ST_TO_ADDR
// tmp := 1 ;
48624: LD_ADDR_VAR 0 2
48628: PUSH
48629: LD_STRING 1
48631: ST_TO_ADDR
// end ; normal := normal & tmp ;
48632: LD_ADDR_VAR 0 3
48636: PUSH
48637: LD_VAR 0 3
48641: PUSH
48642: LD_VAR 0 2
48646: STR
48647: ST_TO_ADDR
// end ;
48648: GO 48548
48650: POP
48651: POP
// for i = 1 to hardcoreCounter do
48652: LD_ADDR_VAR 0 5
48656: PUSH
48657: DOUBLE
48658: LD_INT 1
48660: DEC
48661: ST_TO_ADDR
48662: LD_EXP 94
48666: PUSH
48667: FOR_TO
48668: IFFALSE 48773
// begin tmp := 0 ;
48670: LD_ADDR_VAR 0 2
48674: PUSH
48675: LD_STRING 0
48677: ST_TO_ADDR
// if result [ 2 ] then
48678: LD_VAR 0 1
48682: PUSH
48683: LD_INT 2
48685: ARRAY
48686: IFFALSE 48755
// if result [ 2 ] [ 1 ] = 100 + i then
48688: LD_VAR 0 1
48692: PUSH
48693: LD_INT 2
48695: ARRAY
48696: PUSH
48697: LD_INT 1
48699: ARRAY
48700: PUSH
48701: LD_INT 100
48703: PUSH
48704: LD_VAR 0 5
48708: PLUS
48709: EQUAL
48710: IFFALSE 48755
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48712: LD_ADDR_VAR 0 1
48716: PUSH
48717: LD_VAR 0 1
48721: PPUSH
48722: LD_INT 2
48724: PPUSH
48725: LD_VAR 0 1
48729: PUSH
48730: LD_INT 2
48732: ARRAY
48733: PPUSH
48734: LD_INT 1
48736: PPUSH
48737: CALL_OW 3
48741: PPUSH
48742: CALL_OW 1
48746: ST_TO_ADDR
// tmp := 1 ;
48747: LD_ADDR_VAR 0 2
48751: PUSH
48752: LD_STRING 1
48754: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48755: LD_ADDR_VAR 0 4
48759: PUSH
48760: LD_VAR 0 4
48764: PUSH
48765: LD_VAR 0 2
48769: STR
48770: ST_TO_ADDR
// end ;
48771: GO 48667
48773: POP
48774: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48775: LD_STRING getStreamItemsFromMission("
48777: PUSH
48778: LD_VAR 0 3
48782: STR
48783: PUSH
48784: LD_STRING ","
48786: STR
48787: PUSH
48788: LD_VAR 0 4
48792: STR
48793: PUSH
48794: LD_STRING ")
48796: STR
48797: PPUSH
48798: CALL_OW 559
// end else
48802: GO 48811
// ToLua ( getStreamItemsFromMission("","") ) ;
48804: LD_STRING getStreamItemsFromMission("","")
48806: PPUSH
48807: CALL_OW 559
// end ;
48811: LD_VAR 0 1
48815: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48816: LD_EXP 92
48820: PUSH
48821: LD_EXP 97
48825: AND
48826: IFFALSE 48950
48828: GO 48830
48830: DISABLE
48831: LD_INT 0
48833: PPUSH
48834: PPUSH
// begin enable ;
48835: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48836: LD_ADDR_VAR 0 2
48840: PUSH
48841: LD_INT 22
48843: PUSH
48844: LD_OWVAR 2
48848: PUSH
48849: EMPTY
48850: LIST
48851: LIST
48852: PUSH
48853: LD_INT 2
48855: PUSH
48856: LD_INT 34
48858: PUSH
48859: LD_INT 7
48861: PUSH
48862: EMPTY
48863: LIST
48864: LIST
48865: PUSH
48866: LD_INT 34
48868: PUSH
48869: LD_INT 45
48871: PUSH
48872: EMPTY
48873: LIST
48874: LIST
48875: PUSH
48876: LD_INT 34
48878: PUSH
48879: LD_INT 28
48881: PUSH
48882: EMPTY
48883: LIST
48884: LIST
48885: PUSH
48886: LD_INT 34
48888: PUSH
48889: LD_INT 47
48891: PUSH
48892: EMPTY
48893: LIST
48894: LIST
48895: PUSH
48896: EMPTY
48897: LIST
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: PUSH
48903: EMPTY
48904: LIST
48905: LIST
48906: PPUSH
48907: CALL_OW 69
48911: ST_TO_ADDR
// if not tmp then
48912: LD_VAR 0 2
48916: NOT
48917: IFFALSE 48921
// exit ;
48919: GO 48950
// for i in tmp do
48921: LD_ADDR_VAR 0 1
48925: PUSH
48926: LD_VAR 0 2
48930: PUSH
48931: FOR_IN
48932: IFFALSE 48948
// begin SetLives ( i , 0 ) ;
48934: LD_VAR 0 1
48938: PPUSH
48939: LD_INT 0
48941: PPUSH
48942: CALL_OW 234
// end ;
48946: GO 48931
48948: POP
48949: POP
// end ;
48950: PPOPN 2
48952: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48953: LD_EXP 92
48957: PUSH
48958: LD_EXP 98
48962: AND
48963: IFFALSE 49047
48965: GO 48967
48967: DISABLE
48968: LD_INT 0
48970: PPUSH
48971: PPUSH
// begin enable ;
48972: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48973: LD_ADDR_VAR 0 2
48977: PUSH
48978: LD_INT 22
48980: PUSH
48981: LD_OWVAR 2
48985: PUSH
48986: EMPTY
48987: LIST
48988: LIST
48989: PUSH
48990: LD_INT 32
48992: PUSH
48993: LD_INT 3
48995: PUSH
48996: EMPTY
48997: LIST
48998: LIST
48999: PUSH
49000: EMPTY
49001: LIST
49002: LIST
49003: PPUSH
49004: CALL_OW 69
49008: ST_TO_ADDR
// if not tmp then
49009: LD_VAR 0 2
49013: NOT
49014: IFFALSE 49018
// exit ;
49016: GO 49047
// for i in tmp do
49018: LD_ADDR_VAR 0 1
49022: PUSH
49023: LD_VAR 0 2
49027: PUSH
49028: FOR_IN
49029: IFFALSE 49045
// begin SetLives ( i , 0 ) ;
49031: LD_VAR 0 1
49035: PPUSH
49036: LD_INT 0
49038: PPUSH
49039: CALL_OW 234
// end ;
49043: GO 49028
49045: POP
49046: POP
// end ;
49047: PPOPN 2
49049: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49050: LD_EXP 92
49054: PUSH
49055: LD_EXP 95
49059: AND
49060: IFFALSE 49153
49062: GO 49064
49064: DISABLE
49065: LD_INT 0
49067: PPUSH
// begin enable ;
49068: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49069: LD_ADDR_VAR 0 1
49073: PUSH
49074: LD_INT 22
49076: PUSH
49077: LD_OWVAR 2
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: PUSH
49086: LD_INT 2
49088: PUSH
49089: LD_INT 25
49091: PUSH
49092: LD_INT 5
49094: PUSH
49095: EMPTY
49096: LIST
49097: LIST
49098: PUSH
49099: LD_INT 25
49101: PUSH
49102: LD_INT 9
49104: PUSH
49105: EMPTY
49106: LIST
49107: LIST
49108: PUSH
49109: LD_INT 25
49111: PUSH
49112: LD_INT 8
49114: PUSH
49115: EMPTY
49116: LIST
49117: LIST
49118: PUSH
49119: EMPTY
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: PUSH
49125: EMPTY
49126: LIST
49127: LIST
49128: PPUSH
49129: CALL_OW 69
49133: PUSH
49134: FOR_IN
49135: IFFALSE 49151
// begin SetClass ( i , 1 ) ;
49137: LD_VAR 0 1
49141: PPUSH
49142: LD_INT 1
49144: PPUSH
49145: CALL_OW 336
// end ;
49149: GO 49134
49151: POP
49152: POP
// end ;
49153: PPOPN 1
49155: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49156: LD_EXP 92
49160: PUSH
49161: LD_EXP 96
49165: AND
49166: PUSH
49167: LD_OWVAR 65
49171: PUSH
49172: LD_INT 7
49174: LESS
49175: AND
49176: IFFALSE 49190
49178: GO 49180
49180: DISABLE
// begin enable ;
49181: ENABLE
// game_speed := 7 ;
49182: LD_ADDR_OWVAR 65
49186: PUSH
49187: LD_INT 7
49189: ST_TO_ADDR
// end ;
49190: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49191: LD_EXP 92
49195: PUSH
49196: LD_EXP 99
49200: AND
49201: IFFALSE 49403
49203: GO 49205
49205: DISABLE
49206: LD_INT 0
49208: PPUSH
49209: PPUSH
49210: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49211: LD_ADDR_VAR 0 3
49215: PUSH
49216: LD_INT 81
49218: PUSH
49219: LD_OWVAR 2
49223: PUSH
49224: EMPTY
49225: LIST
49226: LIST
49227: PUSH
49228: LD_INT 21
49230: PUSH
49231: LD_INT 1
49233: PUSH
49234: EMPTY
49235: LIST
49236: LIST
49237: PUSH
49238: EMPTY
49239: LIST
49240: LIST
49241: PPUSH
49242: CALL_OW 69
49246: ST_TO_ADDR
// if not tmp then
49247: LD_VAR 0 3
49251: NOT
49252: IFFALSE 49256
// exit ;
49254: GO 49403
// if tmp > 5 then
49256: LD_VAR 0 3
49260: PUSH
49261: LD_INT 5
49263: GREATER
49264: IFFALSE 49276
// k := 5 else
49266: LD_ADDR_VAR 0 2
49270: PUSH
49271: LD_INT 5
49273: ST_TO_ADDR
49274: GO 49286
// k := tmp ;
49276: LD_ADDR_VAR 0 2
49280: PUSH
49281: LD_VAR 0 3
49285: ST_TO_ADDR
// for i := 1 to k do
49286: LD_ADDR_VAR 0 1
49290: PUSH
49291: DOUBLE
49292: LD_INT 1
49294: DEC
49295: ST_TO_ADDR
49296: LD_VAR 0 2
49300: PUSH
49301: FOR_TO
49302: IFFALSE 49401
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49304: LD_VAR 0 3
49308: PUSH
49309: LD_VAR 0 1
49313: ARRAY
49314: PPUSH
49315: LD_VAR 0 1
49319: PUSH
49320: LD_INT 4
49322: MOD
49323: PUSH
49324: LD_INT 1
49326: PLUS
49327: PPUSH
49328: CALL_OW 259
49332: PUSH
49333: LD_INT 10
49335: LESS
49336: IFFALSE 49399
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49338: LD_VAR 0 3
49342: PUSH
49343: LD_VAR 0 1
49347: ARRAY
49348: PPUSH
49349: LD_VAR 0 1
49353: PUSH
49354: LD_INT 4
49356: MOD
49357: PUSH
49358: LD_INT 1
49360: PLUS
49361: PPUSH
49362: LD_VAR 0 3
49366: PUSH
49367: LD_VAR 0 1
49371: ARRAY
49372: PPUSH
49373: LD_VAR 0 1
49377: PUSH
49378: LD_INT 4
49380: MOD
49381: PUSH
49382: LD_INT 1
49384: PLUS
49385: PPUSH
49386: CALL_OW 259
49390: PUSH
49391: LD_INT 1
49393: PLUS
49394: PPUSH
49395: CALL_OW 237
49399: GO 49301
49401: POP
49402: POP
// end ;
49403: PPOPN 3
49405: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49406: LD_EXP 92
49410: PUSH
49411: LD_EXP 100
49415: AND
49416: IFFALSE 49436
49418: GO 49420
49420: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49421: LD_INT 4
49423: PPUSH
49424: LD_OWVAR 2
49428: PPUSH
49429: LD_INT 0
49431: PPUSH
49432: CALL_OW 324
49436: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49437: LD_EXP 92
49441: PUSH
49442: LD_EXP 129
49446: AND
49447: IFFALSE 49467
49449: GO 49451
49451: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49452: LD_INT 19
49454: PPUSH
49455: LD_OWVAR 2
49459: PPUSH
49460: LD_INT 0
49462: PPUSH
49463: CALL_OW 324
49467: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49468: LD_EXP 92
49472: PUSH
49473: LD_EXP 101
49477: AND
49478: IFFALSE 49580
49480: GO 49482
49482: DISABLE
49483: LD_INT 0
49485: PPUSH
49486: PPUSH
// begin enable ;
49487: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49488: LD_ADDR_VAR 0 2
49492: PUSH
49493: LD_INT 22
49495: PUSH
49496: LD_OWVAR 2
49500: PUSH
49501: EMPTY
49502: LIST
49503: LIST
49504: PUSH
49505: LD_INT 2
49507: PUSH
49508: LD_INT 34
49510: PUSH
49511: LD_INT 11
49513: PUSH
49514: EMPTY
49515: LIST
49516: LIST
49517: PUSH
49518: LD_INT 34
49520: PUSH
49521: LD_INT 30
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: PUSH
49528: EMPTY
49529: LIST
49530: LIST
49531: LIST
49532: PUSH
49533: EMPTY
49534: LIST
49535: LIST
49536: PPUSH
49537: CALL_OW 69
49541: ST_TO_ADDR
// if not tmp then
49542: LD_VAR 0 2
49546: NOT
49547: IFFALSE 49551
// exit ;
49549: GO 49580
// for i in tmp do
49551: LD_ADDR_VAR 0 1
49555: PUSH
49556: LD_VAR 0 2
49560: PUSH
49561: FOR_IN
49562: IFFALSE 49578
// begin SetLives ( i , 0 ) ;
49564: LD_VAR 0 1
49568: PPUSH
49569: LD_INT 0
49571: PPUSH
49572: CALL_OW 234
// end ;
49576: GO 49561
49578: POP
49579: POP
// end ;
49580: PPOPN 2
49582: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49583: LD_EXP 92
49587: PUSH
49588: LD_EXP 102
49592: AND
49593: IFFALSE 49613
49595: GO 49597
49597: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49598: LD_INT 32
49600: PPUSH
49601: LD_OWVAR 2
49605: PPUSH
49606: LD_INT 0
49608: PPUSH
49609: CALL_OW 324
49613: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49614: LD_EXP 92
49618: PUSH
49619: LD_EXP 103
49623: AND
49624: IFFALSE 49805
49626: GO 49628
49628: DISABLE
49629: LD_INT 0
49631: PPUSH
49632: PPUSH
49633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49634: LD_ADDR_VAR 0 2
49638: PUSH
49639: LD_INT 22
49641: PUSH
49642: LD_OWVAR 2
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: PUSH
49651: LD_INT 33
49653: PUSH
49654: LD_INT 3
49656: PUSH
49657: EMPTY
49658: LIST
49659: LIST
49660: PUSH
49661: EMPTY
49662: LIST
49663: LIST
49664: PPUSH
49665: CALL_OW 69
49669: ST_TO_ADDR
// if not tmp then
49670: LD_VAR 0 2
49674: NOT
49675: IFFALSE 49679
// exit ;
49677: GO 49805
// side := 0 ;
49679: LD_ADDR_VAR 0 3
49683: PUSH
49684: LD_INT 0
49686: ST_TO_ADDR
// for i := 1 to 8 do
49687: LD_ADDR_VAR 0 1
49691: PUSH
49692: DOUBLE
49693: LD_INT 1
49695: DEC
49696: ST_TO_ADDR
49697: LD_INT 8
49699: PUSH
49700: FOR_TO
49701: IFFALSE 49749
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49703: LD_OWVAR 2
49707: PUSH
49708: LD_VAR 0 1
49712: NONEQUAL
49713: PUSH
49714: LD_OWVAR 2
49718: PPUSH
49719: LD_VAR 0 1
49723: PPUSH
49724: CALL_OW 81
49728: PUSH
49729: LD_INT 2
49731: EQUAL
49732: AND
49733: IFFALSE 49747
// begin side := i ;
49735: LD_ADDR_VAR 0 3
49739: PUSH
49740: LD_VAR 0 1
49744: ST_TO_ADDR
// break ;
49745: GO 49749
// end ;
49747: GO 49700
49749: POP
49750: POP
// if not side then
49751: LD_VAR 0 3
49755: NOT
49756: IFFALSE 49760
// exit ;
49758: GO 49805
// for i := 1 to tmp do
49760: LD_ADDR_VAR 0 1
49764: PUSH
49765: DOUBLE
49766: LD_INT 1
49768: DEC
49769: ST_TO_ADDR
49770: LD_VAR 0 2
49774: PUSH
49775: FOR_TO
49776: IFFALSE 49803
// if Prob ( 60 ) then
49778: LD_INT 60
49780: PPUSH
49781: CALL_OW 13
49785: IFFALSE 49801
// SetSide ( i , side ) ;
49787: LD_VAR 0 1
49791: PPUSH
49792: LD_VAR 0 3
49796: PPUSH
49797: CALL_OW 235
49801: GO 49775
49803: POP
49804: POP
// end ;
49805: PPOPN 3
49807: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49808: LD_EXP 92
49812: PUSH
49813: LD_EXP 105
49817: AND
49818: IFFALSE 49937
49820: GO 49822
49822: DISABLE
49823: LD_INT 0
49825: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49826: LD_ADDR_VAR 0 1
49830: PUSH
49831: LD_INT 22
49833: PUSH
49834: LD_OWVAR 2
49838: PUSH
49839: EMPTY
49840: LIST
49841: LIST
49842: PUSH
49843: LD_INT 21
49845: PUSH
49846: LD_INT 1
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: PUSH
49853: LD_INT 3
49855: PUSH
49856: LD_INT 23
49858: PUSH
49859: LD_INT 0
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PUSH
49870: EMPTY
49871: LIST
49872: LIST
49873: LIST
49874: PPUSH
49875: CALL_OW 69
49879: PUSH
49880: FOR_IN
49881: IFFALSE 49935
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49883: LD_VAR 0 1
49887: PPUSH
49888: CALL_OW 257
49892: PUSH
49893: LD_INT 1
49895: PUSH
49896: LD_INT 2
49898: PUSH
49899: LD_INT 3
49901: PUSH
49902: LD_INT 4
49904: PUSH
49905: EMPTY
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: IN
49911: IFFALSE 49933
// SetClass ( un , rand ( 1 , 4 ) ) ;
49913: LD_VAR 0 1
49917: PPUSH
49918: LD_INT 1
49920: PPUSH
49921: LD_INT 4
49923: PPUSH
49924: CALL_OW 12
49928: PPUSH
49929: CALL_OW 336
49933: GO 49880
49935: POP
49936: POP
// end ;
49937: PPOPN 1
49939: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49940: LD_EXP 92
49944: PUSH
49945: LD_EXP 104
49949: AND
49950: IFFALSE 50029
49952: GO 49954
49954: DISABLE
49955: LD_INT 0
49957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49958: LD_ADDR_VAR 0 1
49962: PUSH
49963: LD_INT 22
49965: PUSH
49966: LD_OWVAR 2
49970: PUSH
49971: EMPTY
49972: LIST
49973: LIST
49974: PUSH
49975: LD_INT 21
49977: PUSH
49978: LD_INT 3
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: PUSH
49985: EMPTY
49986: LIST
49987: LIST
49988: PPUSH
49989: CALL_OW 69
49993: ST_TO_ADDR
// if not tmp then
49994: LD_VAR 0 1
49998: NOT
49999: IFFALSE 50003
// exit ;
50001: GO 50029
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50003: LD_VAR 0 1
50007: PUSH
50008: LD_INT 1
50010: PPUSH
50011: LD_VAR 0 1
50015: PPUSH
50016: CALL_OW 12
50020: ARRAY
50021: PPUSH
50022: LD_INT 100
50024: PPUSH
50025: CALL_OW 234
// end ;
50029: PPOPN 1
50031: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50032: LD_EXP 92
50036: PUSH
50037: LD_EXP 106
50041: AND
50042: IFFALSE 50140
50044: GO 50046
50046: DISABLE
50047: LD_INT 0
50049: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50050: LD_ADDR_VAR 0 1
50054: PUSH
50055: LD_INT 22
50057: PUSH
50058: LD_OWVAR 2
50062: PUSH
50063: EMPTY
50064: LIST
50065: LIST
50066: PUSH
50067: LD_INT 21
50069: PUSH
50070: LD_INT 1
50072: PUSH
50073: EMPTY
50074: LIST
50075: LIST
50076: PUSH
50077: EMPTY
50078: LIST
50079: LIST
50080: PPUSH
50081: CALL_OW 69
50085: ST_TO_ADDR
// if not tmp then
50086: LD_VAR 0 1
50090: NOT
50091: IFFALSE 50095
// exit ;
50093: GO 50140
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50095: LD_VAR 0 1
50099: PUSH
50100: LD_INT 1
50102: PPUSH
50103: LD_VAR 0 1
50107: PPUSH
50108: CALL_OW 12
50112: ARRAY
50113: PPUSH
50114: LD_INT 1
50116: PPUSH
50117: LD_INT 4
50119: PPUSH
50120: CALL_OW 12
50124: PPUSH
50125: LD_INT 3000
50127: PPUSH
50128: LD_INT 9000
50130: PPUSH
50131: CALL_OW 12
50135: PPUSH
50136: CALL_OW 492
// end ;
50140: PPOPN 1
50142: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50143: LD_EXP 92
50147: PUSH
50148: LD_EXP 107
50152: AND
50153: IFFALSE 50173
50155: GO 50157
50157: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50158: LD_INT 1
50160: PPUSH
50161: LD_OWVAR 2
50165: PPUSH
50166: LD_INT 0
50168: PPUSH
50169: CALL_OW 324
50173: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50174: LD_EXP 92
50178: PUSH
50179: LD_EXP 108
50183: AND
50184: IFFALSE 50267
50186: GO 50188
50188: DISABLE
50189: LD_INT 0
50191: PPUSH
50192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50193: LD_ADDR_VAR 0 2
50197: PUSH
50198: LD_INT 22
50200: PUSH
50201: LD_OWVAR 2
50205: PUSH
50206: EMPTY
50207: LIST
50208: LIST
50209: PUSH
50210: LD_INT 21
50212: PUSH
50213: LD_INT 3
50215: PUSH
50216: EMPTY
50217: LIST
50218: LIST
50219: PUSH
50220: EMPTY
50221: LIST
50222: LIST
50223: PPUSH
50224: CALL_OW 69
50228: ST_TO_ADDR
// if not tmp then
50229: LD_VAR 0 2
50233: NOT
50234: IFFALSE 50238
// exit ;
50236: GO 50267
// for i in tmp do
50238: LD_ADDR_VAR 0 1
50242: PUSH
50243: LD_VAR 0 2
50247: PUSH
50248: FOR_IN
50249: IFFALSE 50265
// SetBLevel ( i , 10 ) ;
50251: LD_VAR 0 1
50255: PPUSH
50256: LD_INT 10
50258: PPUSH
50259: CALL_OW 241
50263: GO 50248
50265: POP
50266: POP
// end ;
50267: PPOPN 2
50269: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50270: LD_EXP 92
50274: PUSH
50275: LD_EXP 109
50279: AND
50280: IFFALSE 50391
50282: GO 50284
50284: DISABLE
50285: LD_INT 0
50287: PPUSH
50288: PPUSH
50289: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50290: LD_ADDR_VAR 0 3
50294: PUSH
50295: LD_INT 22
50297: PUSH
50298: LD_OWVAR 2
50302: PUSH
50303: EMPTY
50304: LIST
50305: LIST
50306: PUSH
50307: LD_INT 25
50309: PUSH
50310: LD_INT 1
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PUSH
50317: EMPTY
50318: LIST
50319: LIST
50320: PPUSH
50321: CALL_OW 69
50325: ST_TO_ADDR
// if not tmp then
50326: LD_VAR 0 3
50330: NOT
50331: IFFALSE 50335
// exit ;
50333: GO 50391
// un := tmp [ rand ( 1 , tmp ) ] ;
50335: LD_ADDR_VAR 0 2
50339: PUSH
50340: LD_VAR 0 3
50344: PUSH
50345: LD_INT 1
50347: PPUSH
50348: LD_VAR 0 3
50352: PPUSH
50353: CALL_OW 12
50357: ARRAY
50358: ST_TO_ADDR
// if Crawls ( un ) then
50359: LD_VAR 0 2
50363: PPUSH
50364: CALL_OW 318
50368: IFFALSE 50379
// ComWalk ( un ) ;
50370: LD_VAR 0 2
50374: PPUSH
50375: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50379: LD_VAR 0 2
50383: PPUSH
50384: LD_INT 5
50386: PPUSH
50387: CALL_OW 336
// end ;
50391: PPOPN 3
50393: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50394: LD_EXP 92
50398: PUSH
50399: LD_EXP 110
50403: AND
50404: PUSH
50405: LD_OWVAR 67
50409: PUSH
50410: LD_INT 4
50412: LESS
50413: AND
50414: IFFALSE 50433
50416: GO 50418
50418: DISABLE
// begin Difficulty := Difficulty + 1 ;
50419: LD_ADDR_OWVAR 67
50423: PUSH
50424: LD_OWVAR 67
50428: PUSH
50429: LD_INT 1
50431: PLUS
50432: ST_TO_ADDR
// end ;
50433: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50434: LD_EXP 92
50438: PUSH
50439: LD_EXP 111
50443: AND
50444: IFFALSE 50547
50446: GO 50448
50448: DISABLE
50449: LD_INT 0
50451: PPUSH
// begin for i := 1 to 5 do
50452: LD_ADDR_VAR 0 1
50456: PUSH
50457: DOUBLE
50458: LD_INT 1
50460: DEC
50461: ST_TO_ADDR
50462: LD_INT 5
50464: PUSH
50465: FOR_TO
50466: IFFALSE 50545
// begin uc_nation := nation_nature ;
50468: LD_ADDR_OWVAR 21
50472: PUSH
50473: LD_INT 0
50475: ST_TO_ADDR
// uc_side := 0 ;
50476: LD_ADDR_OWVAR 20
50480: PUSH
50481: LD_INT 0
50483: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50484: LD_ADDR_OWVAR 29
50488: PUSH
50489: LD_INT 12
50491: PUSH
50492: LD_INT 12
50494: PUSH
50495: EMPTY
50496: LIST
50497: LIST
50498: ST_TO_ADDR
// hc_agressivity := 20 ;
50499: LD_ADDR_OWVAR 35
50503: PUSH
50504: LD_INT 20
50506: ST_TO_ADDR
// hc_class := class_tiger ;
50507: LD_ADDR_OWVAR 28
50511: PUSH
50512: LD_INT 14
50514: ST_TO_ADDR
// hc_gallery :=  ;
50515: LD_ADDR_OWVAR 33
50519: PUSH
50520: LD_STRING 
50522: ST_TO_ADDR
// hc_name :=  ;
50523: LD_ADDR_OWVAR 26
50527: PUSH
50528: LD_STRING 
50530: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50531: CALL_OW 44
50535: PPUSH
50536: LD_INT 0
50538: PPUSH
50539: CALL_OW 51
// end ;
50543: GO 50465
50545: POP
50546: POP
// end ;
50547: PPOPN 1
50549: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50550: LD_EXP 92
50554: PUSH
50555: LD_EXP 112
50559: AND
50560: IFFALSE 50569
50562: GO 50564
50564: DISABLE
// StreamSibBomb ;
50565: CALL 50570 0 0
50569: END
// export function StreamSibBomb ; var i , x , y ; begin
50570: LD_INT 0
50572: PPUSH
50573: PPUSH
50574: PPUSH
50575: PPUSH
// result := false ;
50576: LD_ADDR_VAR 0 1
50580: PUSH
50581: LD_INT 0
50583: ST_TO_ADDR
// for i := 1 to 16 do
50584: LD_ADDR_VAR 0 2
50588: PUSH
50589: DOUBLE
50590: LD_INT 1
50592: DEC
50593: ST_TO_ADDR
50594: LD_INT 16
50596: PUSH
50597: FOR_TO
50598: IFFALSE 50797
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50600: LD_ADDR_VAR 0 3
50604: PUSH
50605: LD_INT 10
50607: PUSH
50608: LD_INT 20
50610: PUSH
50611: LD_INT 30
50613: PUSH
50614: LD_INT 40
50616: PUSH
50617: LD_INT 50
50619: PUSH
50620: LD_INT 60
50622: PUSH
50623: LD_INT 70
50625: PUSH
50626: LD_INT 80
50628: PUSH
50629: LD_INT 90
50631: PUSH
50632: LD_INT 100
50634: PUSH
50635: LD_INT 110
50637: PUSH
50638: LD_INT 120
50640: PUSH
50641: LD_INT 130
50643: PUSH
50644: LD_INT 140
50646: PUSH
50647: LD_INT 150
50649: PUSH
50650: EMPTY
50651: LIST
50652: LIST
50653: LIST
50654: LIST
50655: LIST
50656: LIST
50657: LIST
50658: LIST
50659: LIST
50660: LIST
50661: LIST
50662: LIST
50663: LIST
50664: LIST
50665: LIST
50666: PUSH
50667: LD_INT 1
50669: PPUSH
50670: LD_INT 15
50672: PPUSH
50673: CALL_OW 12
50677: ARRAY
50678: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50679: LD_ADDR_VAR 0 4
50683: PUSH
50684: LD_INT 10
50686: PUSH
50687: LD_INT 20
50689: PUSH
50690: LD_INT 30
50692: PUSH
50693: LD_INT 40
50695: PUSH
50696: LD_INT 50
50698: PUSH
50699: LD_INT 60
50701: PUSH
50702: LD_INT 70
50704: PUSH
50705: LD_INT 80
50707: PUSH
50708: LD_INT 90
50710: PUSH
50711: LD_INT 100
50713: PUSH
50714: LD_INT 110
50716: PUSH
50717: LD_INT 120
50719: PUSH
50720: LD_INT 130
50722: PUSH
50723: LD_INT 140
50725: PUSH
50726: LD_INT 150
50728: PUSH
50729: EMPTY
50730: LIST
50731: LIST
50732: LIST
50733: LIST
50734: LIST
50735: LIST
50736: LIST
50737: LIST
50738: LIST
50739: LIST
50740: LIST
50741: LIST
50742: LIST
50743: LIST
50744: LIST
50745: PUSH
50746: LD_INT 1
50748: PPUSH
50749: LD_INT 15
50751: PPUSH
50752: CALL_OW 12
50756: ARRAY
50757: ST_TO_ADDR
// if ValidHex ( x , y ) then
50758: LD_VAR 0 3
50762: PPUSH
50763: LD_VAR 0 4
50767: PPUSH
50768: CALL_OW 488
50772: IFFALSE 50795
// begin result := [ x , y ] ;
50774: LD_ADDR_VAR 0 1
50778: PUSH
50779: LD_VAR 0 3
50783: PUSH
50784: LD_VAR 0 4
50788: PUSH
50789: EMPTY
50790: LIST
50791: LIST
50792: ST_TO_ADDR
// break ;
50793: GO 50797
// end ; end ;
50795: GO 50597
50797: POP
50798: POP
// if result then
50799: LD_VAR 0 1
50803: IFFALSE 50863
// begin ToLua ( playSibBomb() ) ;
50805: LD_STRING playSibBomb()
50807: PPUSH
50808: CALL_OW 559
// wait ( 0 0$14 ) ;
50812: LD_INT 490
50814: PPUSH
50815: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50819: LD_VAR 0 1
50823: PUSH
50824: LD_INT 1
50826: ARRAY
50827: PPUSH
50828: LD_VAR 0 1
50832: PUSH
50833: LD_INT 2
50835: ARRAY
50836: PPUSH
50837: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50841: LD_VAR 0 1
50845: PUSH
50846: LD_INT 1
50848: ARRAY
50849: PPUSH
50850: LD_VAR 0 1
50854: PUSH
50855: LD_INT 2
50857: ARRAY
50858: PPUSH
50859: CALL_OW 429
// end ; end ;
50863: LD_VAR 0 1
50867: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50868: LD_EXP 92
50872: PUSH
50873: LD_EXP 114
50877: AND
50878: IFFALSE 50890
50880: GO 50882
50882: DISABLE
// YouLost (  ) ;
50883: LD_STRING 
50885: PPUSH
50886: CALL_OW 104
50890: END
// every 0 0$1 trigger StreamModeActive and sFog do
50891: LD_EXP 92
50895: PUSH
50896: LD_EXP 113
50900: AND
50901: IFFALSE 50915
50903: GO 50905
50905: DISABLE
// FogOff ( your_side ) ;
50906: LD_OWVAR 2
50910: PPUSH
50911: CALL_OW 344
50915: END
// every 0 0$1 trigger StreamModeActive and sSun do
50916: LD_EXP 92
50920: PUSH
50921: LD_EXP 115
50925: AND
50926: IFFALSE 50954
50928: GO 50930
50930: DISABLE
// begin solar_recharge_percent := 0 ;
50931: LD_ADDR_OWVAR 79
50935: PUSH
50936: LD_INT 0
50938: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50939: LD_INT 10500
50941: PPUSH
50942: CALL_OW 67
// solar_recharge_percent := 100 ;
50946: LD_ADDR_OWVAR 79
50950: PUSH
50951: LD_INT 100
50953: ST_TO_ADDR
// end ;
50954: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50955: LD_EXP 92
50959: PUSH
50960: LD_EXP 116
50964: AND
50965: IFFALSE 51204
50967: GO 50969
50969: DISABLE
50970: LD_INT 0
50972: PPUSH
50973: PPUSH
50974: PPUSH
// begin tmp := [ ] ;
50975: LD_ADDR_VAR 0 3
50979: PUSH
50980: EMPTY
50981: ST_TO_ADDR
// for i := 1 to 6 do
50982: LD_ADDR_VAR 0 1
50986: PUSH
50987: DOUBLE
50988: LD_INT 1
50990: DEC
50991: ST_TO_ADDR
50992: LD_INT 6
50994: PUSH
50995: FOR_TO
50996: IFFALSE 51101
// begin uc_nation := nation_nature ;
50998: LD_ADDR_OWVAR 21
51002: PUSH
51003: LD_INT 0
51005: ST_TO_ADDR
// uc_side := 0 ;
51006: LD_ADDR_OWVAR 20
51010: PUSH
51011: LD_INT 0
51013: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51014: LD_ADDR_OWVAR 29
51018: PUSH
51019: LD_INT 12
51021: PUSH
51022: LD_INT 12
51024: PUSH
51025: EMPTY
51026: LIST
51027: LIST
51028: ST_TO_ADDR
// hc_agressivity := 20 ;
51029: LD_ADDR_OWVAR 35
51033: PUSH
51034: LD_INT 20
51036: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51037: LD_ADDR_OWVAR 28
51041: PUSH
51042: LD_INT 17
51044: ST_TO_ADDR
// hc_gallery :=  ;
51045: LD_ADDR_OWVAR 33
51049: PUSH
51050: LD_STRING 
51052: ST_TO_ADDR
// hc_name :=  ;
51053: LD_ADDR_OWVAR 26
51057: PUSH
51058: LD_STRING 
51060: ST_TO_ADDR
// un := CreateHuman ;
51061: LD_ADDR_VAR 0 2
51065: PUSH
51066: CALL_OW 44
51070: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51071: LD_VAR 0 2
51075: PPUSH
51076: LD_INT 1
51078: PPUSH
51079: CALL_OW 51
// tmp := tmp ^ un ;
51083: LD_ADDR_VAR 0 3
51087: PUSH
51088: LD_VAR 0 3
51092: PUSH
51093: LD_VAR 0 2
51097: ADD
51098: ST_TO_ADDR
// end ;
51099: GO 50995
51101: POP
51102: POP
// repeat wait ( 0 0$1 ) ;
51103: LD_INT 35
51105: PPUSH
51106: CALL_OW 67
// for un in tmp do
51110: LD_ADDR_VAR 0 2
51114: PUSH
51115: LD_VAR 0 3
51119: PUSH
51120: FOR_IN
51121: IFFALSE 51195
// begin if IsDead ( un ) then
51123: LD_VAR 0 2
51127: PPUSH
51128: CALL_OW 301
51132: IFFALSE 51152
// begin tmp := tmp diff un ;
51134: LD_ADDR_VAR 0 3
51138: PUSH
51139: LD_VAR 0 3
51143: PUSH
51144: LD_VAR 0 2
51148: DIFF
51149: ST_TO_ADDR
// continue ;
51150: GO 51120
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51152: LD_VAR 0 2
51156: PPUSH
51157: LD_INT 3
51159: PUSH
51160: LD_INT 22
51162: PUSH
51163: LD_INT 0
51165: PUSH
51166: EMPTY
51167: LIST
51168: LIST
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PPUSH
51174: CALL_OW 69
51178: PPUSH
51179: LD_VAR 0 2
51183: PPUSH
51184: CALL_OW 74
51188: PPUSH
51189: CALL_OW 115
// end ;
51193: GO 51120
51195: POP
51196: POP
// until not tmp ;
51197: LD_VAR 0 3
51201: NOT
51202: IFFALSE 51103
// end ;
51204: PPOPN 3
51206: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51207: LD_EXP 92
51211: PUSH
51212: LD_EXP 117
51216: AND
51217: IFFALSE 51271
51219: GO 51221
51221: DISABLE
// begin ToLua ( displayTroll(); ) ;
51222: LD_STRING displayTroll();
51224: PPUSH
51225: CALL_OW 559
// wait ( 3 3$00 ) ;
51229: LD_INT 6300
51231: PPUSH
51232: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51236: LD_STRING hideTroll();
51238: PPUSH
51239: CALL_OW 559
// wait ( 1 1$00 ) ;
51243: LD_INT 2100
51245: PPUSH
51246: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51250: LD_STRING displayTroll();
51252: PPUSH
51253: CALL_OW 559
// wait ( 1 1$00 ) ;
51257: LD_INT 2100
51259: PPUSH
51260: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51264: LD_STRING hideTroll();
51266: PPUSH
51267: CALL_OW 559
// end ;
51271: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51272: LD_EXP 92
51276: PUSH
51277: LD_EXP 118
51281: AND
51282: IFFALSE 51345
51284: GO 51286
51286: DISABLE
51287: LD_INT 0
51289: PPUSH
// begin p := 0 ;
51290: LD_ADDR_VAR 0 1
51294: PUSH
51295: LD_INT 0
51297: ST_TO_ADDR
// repeat game_speed := 1 ;
51298: LD_ADDR_OWVAR 65
51302: PUSH
51303: LD_INT 1
51305: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51306: LD_INT 35
51308: PPUSH
51309: CALL_OW 67
// p := p + 1 ;
51313: LD_ADDR_VAR 0 1
51317: PUSH
51318: LD_VAR 0 1
51322: PUSH
51323: LD_INT 1
51325: PLUS
51326: ST_TO_ADDR
// until p >= 60 ;
51327: LD_VAR 0 1
51331: PUSH
51332: LD_INT 60
51334: GREATEREQUAL
51335: IFFALSE 51298
// game_speed := 4 ;
51337: LD_ADDR_OWVAR 65
51341: PUSH
51342: LD_INT 4
51344: ST_TO_ADDR
// end ;
51345: PPOPN 1
51347: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51348: LD_EXP 92
51352: PUSH
51353: LD_EXP 119
51357: AND
51358: IFFALSE 51504
51360: GO 51362
51362: DISABLE
51363: LD_INT 0
51365: PPUSH
51366: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51367: LD_ADDR_VAR 0 1
51371: PUSH
51372: LD_INT 22
51374: PUSH
51375: LD_OWVAR 2
51379: PUSH
51380: EMPTY
51381: LIST
51382: LIST
51383: PUSH
51384: LD_INT 2
51386: PUSH
51387: LD_INT 30
51389: PUSH
51390: LD_INT 0
51392: PUSH
51393: EMPTY
51394: LIST
51395: LIST
51396: PUSH
51397: LD_INT 30
51399: PUSH
51400: LD_INT 1
51402: PUSH
51403: EMPTY
51404: LIST
51405: LIST
51406: PUSH
51407: EMPTY
51408: LIST
51409: LIST
51410: LIST
51411: PUSH
51412: EMPTY
51413: LIST
51414: LIST
51415: PPUSH
51416: CALL_OW 69
51420: ST_TO_ADDR
// if not depot then
51421: LD_VAR 0 1
51425: NOT
51426: IFFALSE 51430
// exit ;
51428: GO 51504
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51430: LD_ADDR_VAR 0 2
51434: PUSH
51435: LD_VAR 0 1
51439: PUSH
51440: LD_INT 1
51442: PPUSH
51443: LD_VAR 0 1
51447: PPUSH
51448: CALL_OW 12
51452: ARRAY
51453: PPUSH
51454: CALL_OW 274
51458: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51459: LD_VAR 0 2
51463: PPUSH
51464: LD_INT 1
51466: PPUSH
51467: LD_INT 0
51469: PPUSH
51470: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51474: LD_VAR 0 2
51478: PPUSH
51479: LD_INT 2
51481: PPUSH
51482: LD_INT 0
51484: PPUSH
51485: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51489: LD_VAR 0 2
51493: PPUSH
51494: LD_INT 3
51496: PPUSH
51497: LD_INT 0
51499: PPUSH
51500: CALL_OW 277
// end ;
51504: PPOPN 2
51506: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51507: LD_EXP 92
51511: PUSH
51512: LD_EXP 120
51516: AND
51517: IFFALSE 51614
51519: GO 51521
51521: DISABLE
51522: LD_INT 0
51524: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51525: LD_ADDR_VAR 0 1
51529: PUSH
51530: LD_INT 22
51532: PUSH
51533: LD_OWVAR 2
51537: PUSH
51538: EMPTY
51539: LIST
51540: LIST
51541: PUSH
51542: LD_INT 21
51544: PUSH
51545: LD_INT 1
51547: PUSH
51548: EMPTY
51549: LIST
51550: LIST
51551: PUSH
51552: LD_INT 3
51554: PUSH
51555: LD_INT 23
51557: PUSH
51558: LD_INT 0
51560: PUSH
51561: EMPTY
51562: LIST
51563: LIST
51564: PUSH
51565: EMPTY
51566: LIST
51567: LIST
51568: PUSH
51569: EMPTY
51570: LIST
51571: LIST
51572: LIST
51573: PPUSH
51574: CALL_OW 69
51578: ST_TO_ADDR
// if not tmp then
51579: LD_VAR 0 1
51583: NOT
51584: IFFALSE 51588
// exit ;
51586: GO 51614
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51588: LD_VAR 0 1
51592: PUSH
51593: LD_INT 1
51595: PPUSH
51596: LD_VAR 0 1
51600: PPUSH
51601: CALL_OW 12
51605: ARRAY
51606: PPUSH
51607: LD_INT 200
51609: PPUSH
51610: CALL_OW 234
// end ;
51614: PPOPN 1
51616: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51617: LD_EXP 92
51621: PUSH
51622: LD_EXP 121
51626: AND
51627: IFFALSE 51706
51629: GO 51631
51631: DISABLE
51632: LD_INT 0
51634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51635: LD_ADDR_VAR 0 1
51639: PUSH
51640: LD_INT 22
51642: PUSH
51643: LD_OWVAR 2
51647: PUSH
51648: EMPTY
51649: LIST
51650: LIST
51651: PUSH
51652: LD_INT 21
51654: PUSH
51655: LD_INT 2
51657: PUSH
51658: EMPTY
51659: LIST
51660: LIST
51661: PUSH
51662: EMPTY
51663: LIST
51664: LIST
51665: PPUSH
51666: CALL_OW 69
51670: ST_TO_ADDR
// if not tmp then
51671: LD_VAR 0 1
51675: NOT
51676: IFFALSE 51680
// exit ;
51678: GO 51706
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51680: LD_VAR 0 1
51684: PUSH
51685: LD_INT 1
51687: PPUSH
51688: LD_VAR 0 1
51692: PPUSH
51693: CALL_OW 12
51697: ARRAY
51698: PPUSH
51699: LD_INT 60
51701: PPUSH
51702: CALL_OW 234
// end ;
51706: PPOPN 1
51708: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51709: LD_EXP 92
51713: PUSH
51714: LD_EXP 122
51718: AND
51719: IFFALSE 51818
51721: GO 51723
51723: DISABLE
51724: LD_INT 0
51726: PPUSH
51727: PPUSH
// begin enable ;
51728: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51729: LD_ADDR_VAR 0 1
51733: PUSH
51734: LD_INT 22
51736: PUSH
51737: LD_OWVAR 2
51741: PUSH
51742: EMPTY
51743: LIST
51744: LIST
51745: PUSH
51746: LD_INT 61
51748: PUSH
51749: EMPTY
51750: LIST
51751: PUSH
51752: LD_INT 33
51754: PUSH
51755: LD_INT 2
51757: PUSH
51758: EMPTY
51759: LIST
51760: LIST
51761: PUSH
51762: EMPTY
51763: LIST
51764: LIST
51765: LIST
51766: PPUSH
51767: CALL_OW 69
51771: ST_TO_ADDR
// if not tmp then
51772: LD_VAR 0 1
51776: NOT
51777: IFFALSE 51781
// exit ;
51779: GO 51818
// for i in tmp do
51781: LD_ADDR_VAR 0 2
51785: PUSH
51786: LD_VAR 0 1
51790: PUSH
51791: FOR_IN
51792: IFFALSE 51816
// if IsControledBy ( i ) then
51794: LD_VAR 0 2
51798: PPUSH
51799: CALL_OW 312
51803: IFFALSE 51814
// ComUnlink ( i ) ;
51805: LD_VAR 0 2
51809: PPUSH
51810: CALL_OW 136
51814: GO 51791
51816: POP
51817: POP
// end ;
51818: PPOPN 2
51820: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51821: LD_EXP 92
51825: PUSH
51826: LD_EXP 123
51830: AND
51831: IFFALSE 51971
51833: GO 51835
51835: DISABLE
51836: LD_INT 0
51838: PPUSH
51839: PPUSH
// begin ToLua ( displayPowell(); ) ;
51840: LD_STRING displayPowell();
51842: PPUSH
51843: CALL_OW 559
// uc_side := 0 ;
51847: LD_ADDR_OWVAR 20
51851: PUSH
51852: LD_INT 0
51854: ST_TO_ADDR
// uc_nation := 2 ;
51855: LD_ADDR_OWVAR 21
51859: PUSH
51860: LD_INT 2
51862: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51863: LD_ADDR_OWVAR 37
51867: PUSH
51868: LD_INT 14
51870: ST_TO_ADDR
// vc_engine := engine_siberite ;
51871: LD_ADDR_OWVAR 39
51875: PUSH
51876: LD_INT 3
51878: ST_TO_ADDR
// vc_control := control_apeman ;
51879: LD_ADDR_OWVAR 38
51883: PUSH
51884: LD_INT 5
51886: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51887: LD_ADDR_OWVAR 40
51891: PUSH
51892: LD_INT 29
51894: ST_TO_ADDR
// un := CreateVehicle ;
51895: LD_ADDR_VAR 0 2
51899: PUSH
51900: CALL_OW 45
51904: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51905: LD_VAR 0 2
51909: PPUSH
51910: LD_INT 1
51912: PPUSH
51913: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51917: LD_INT 35
51919: PPUSH
51920: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51924: LD_VAR 0 2
51928: PPUSH
51929: LD_INT 22
51931: PUSH
51932: LD_OWVAR 2
51936: PUSH
51937: EMPTY
51938: LIST
51939: LIST
51940: PPUSH
51941: CALL_OW 69
51945: PPUSH
51946: LD_VAR 0 2
51950: PPUSH
51951: CALL_OW 74
51955: PPUSH
51956: CALL_OW 115
// until IsDead ( un ) ;
51960: LD_VAR 0 2
51964: PPUSH
51965: CALL_OW 301
51969: IFFALSE 51917
// end ;
51971: PPOPN 2
51973: END
// every 0 0$1 trigger StreamModeActive and sStu do
51974: LD_EXP 92
51978: PUSH
51979: LD_EXP 131
51983: AND
51984: IFFALSE 52000
51986: GO 51988
51988: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51989: LD_STRING displayStucuk();
51991: PPUSH
51992: CALL_OW 559
// ResetFog ;
51996: CALL_OW 335
// end ;
52000: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52001: LD_EXP 92
52005: PUSH
52006: LD_EXP 124
52010: AND
52011: IFFALSE 52152
52013: GO 52015
52015: DISABLE
52016: LD_INT 0
52018: PPUSH
52019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52020: LD_ADDR_VAR 0 2
52024: PUSH
52025: LD_INT 22
52027: PUSH
52028: LD_OWVAR 2
52032: PUSH
52033: EMPTY
52034: LIST
52035: LIST
52036: PUSH
52037: LD_INT 21
52039: PUSH
52040: LD_INT 1
52042: PUSH
52043: EMPTY
52044: LIST
52045: LIST
52046: PUSH
52047: EMPTY
52048: LIST
52049: LIST
52050: PPUSH
52051: CALL_OW 69
52055: ST_TO_ADDR
// if not tmp then
52056: LD_VAR 0 2
52060: NOT
52061: IFFALSE 52065
// exit ;
52063: GO 52152
// un := tmp [ rand ( 1 , tmp ) ] ;
52065: LD_ADDR_VAR 0 1
52069: PUSH
52070: LD_VAR 0 2
52074: PUSH
52075: LD_INT 1
52077: PPUSH
52078: LD_VAR 0 2
52082: PPUSH
52083: CALL_OW 12
52087: ARRAY
52088: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52089: LD_VAR 0 1
52093: PPUSH
52094: LD_INT 0
52096: PPUSH
52097: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52101: LD_VAR 0 1
52105: PPUSH
52106: LD_OWVAR 3
52110: PUSH
52111: LD_VAR 0 1
52115: DIFF
52116: PPUSH
52117: LD_VAR 0 1
52121: PPUSH
52122: CALL_OW 74
52126: PPUSH
52127: CALL_OW 115
// wait ( 0 0$20 ) ;
52131: LD_INT 700
52133: PPUSH
52134: CALL_OW 67
// SetSide ( un , your_side ) ;
52138: LD_VAR 0 1
52142: PPUSH
52143: LD_OWVAR 2
52147: PPUSH
52148: CALL_OW 235
// end ;
52152: PPOPN 2
52154: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52155: LD_EXP 92
52159: PUSH
52160: LD_EXP 125
52164: AND
52165: IFFALSE 52271
52167: GO 52169
52169: DISABLE
52170: LD_INT 0
52172: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52173: LD_ADDR_VAR 0 1
52177: PUSH
52178: LD_INT 22
52180: PUSH
52181: LD_OWVAR 2
52185: PUSH
52186: EMPTY
52187: LIST
52188: LIST
52189: PUSH
52190: LD_INT 2
52192: PUSH
52193: LD_INT 30
52195: PUSH
52196: LD_INT 0
52198: PUSH
52199: EMPTY
52200: LIST
52201: LIST
52202: PUSH
52203: LD_INT 30
52205: PUSH
52206: LD_INT 1
52208: PUSH
52209: EMPTY
52210: LIST
52211: LIST
52212: PUSH
52213: EMPTY
52214: LIST
52215: LIST
52216: LIST
52217: PUSH
52218: EMPTY
52219: LIST
52220: LIST
52221: PPUSH
52222: CALL_OW 69
52226: ST_TO_ADDR
// if not depot then
52227: LD_VAR 0 1
52231: NOT
52232: IFFALSE 52236
// exit ;
52234: GO 52271
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52236: LD_VAR 0 1
52240: PUSH
52241: LD_INT 1
52243: ARRAY
52244: PPUSH
52245: CALL_OW 250
52249: PPUSH
52250: LD_VAR 0 1
52254: PUSH
52255: LD_INT 1
52257: ARRAY
52258: PPUSH
52259: CALL_OW 251
52263: PPUSH
52264: LD_INT 70
52266: PPUSH
52267: CALL_OW 495
// end ;
52271: PPOPN 1
52273: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52274: LD_EXP 92
52278: PUSH
52279: LD_EXP 126
52283: AND
52284: IFFALSE 52495
52286: GO 52288
52288: DISABLE
52289: LD_INT 0
52291: PPUSH
52292: PPUSH
52293: PPUSH
52294: PPUSH
52295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52296: LD_ADDR_VAR 0 5
52300: PUSH
52301: LD_INT 22
52303: PUSH
52304: LD_OWVAR 2
52308: PUSH
52309: EMPTY
52310: LIST
52311: LIST
52312: PUSH
52313: LD_INT 21
52315: PUSH
52316: LD_INT 1
52318: PUSH
52319: EMPTY
52320: LIST
52321: LIST
52322: PUSH
52323: EMPTY
52324: LIST
52325: LIST
52326: PPUSH
52327: CALL_OW 69
52331: ST_TO_ADDR
// if not tmp then
52332: LD_VAR 0 5
52336: NOT
52337: IFFALSE 52341
// exit ;
52339: GO 52495
// for i in tmp do
52341: LD_ADDR_VAR 0 1
52345: PUSH
52346: LD_VAR 0 5
52350: PUSH
52351: FOR_IN
52352: IFFALSE 52493
// begin d := rand ( 0 , 5 ) ;
52354: LD_ADDR_VAR 0 4
52358: PUSH
52359: LD_INT 0
52361: PPUSH
52362: LD_INT 5
52364: PPUSH
52365: CALL_OW 12
52369: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52370: LD_ADDR_VAR 0 2
52374: PUSH
52375: LD_VAR 0 1
52379: PPUSH
52380: CALL_OW 250
52384: PPUSH
52385: LD_VAR 0 4
52389: PPUSH
52390: LD_INT 3
52392: PPUSH
52393: LD_INT 12
52395: PPUSH
52396: CALL_OW 12
52400: PPUSH
52401: CALL_OW 272
52405: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52406: LD_ADDR_VAR 0 3
52410: PUSH
52411: LD_VAR 0 1
52415: PPUSH
52416: CALL_OW 251
52420: PPUSH
52421: LD_VAR 0 4
52425: PPUSH
52426: LD_INT 3
52428: PPUSH
52429: LD_INT 12
52431: PPUSH
52432: CALL_OW 12
52436: PPUSH
52437: CALL_OW 273
52441: ST_TO_ADDR
// if ValidHex ( x , y ) then
52442: LD_VAR 0 2
52446: PPUSH
52447: LD_VAR 0 3
52451: PPUSH
52452: CALL_OW 488
52456: IFFALSE 52491
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52458: LD_VAR 0 1
52462: PPUSH
52463: LD_VAR 0 2
52467: PPUSH
52468: LD_VAR 0 3
52472: PPUSH
52473: LD_INT 3
52475: PPUSH
52476: LD_INT 6
52478: PPUSH
52479: CALL_OW 12
52483: PPUSH
52484: LD_INT 1
52486: PPUSH
52487: CALL_OW 483
// end ;
52491: GO 52351
52493: POP
52494: POP
// end ;
52495: PPOPN 5
52497: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52498: LD_EXP 92
52502: PUSH
52503: LD_EXP 127
52507: AND
52508: IFFALSE 52602
52510: GO 52512
52512: DISABLE
52513: LD_INT 0
52515: PPUSH
52516: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52517: LD_ADDR_VAR 0 2
52521: PUSH
52522: LD_INT 22
52524: PUSH
52525: LD_OWVAR 2
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: PUSH
52534: LD_INT 32
52536: PUSH
52537: LD_INT 1
52539: PUSH
52540: EMPTY
52541: LIST
52542: LIST
52543: PUSH
52544: LD_INT 21
52546: PUSH
52547: LD_INT 2
52549: PUSH
52550: EMPTY
52551: LIST
52552: LIST
52553: PUSH
52554: EMPTY
52555: LIST
52556: LIST
52557: LIST
52558: PPUSH
52559: CALL_OW 69
52563: ST_TO_ADDR
// if not tmp then
52564: LD_VAR 0 2
52568: NOT
52569: IFFALSE 52573
// exit ;
52571: GO 52602
// for i in tmp do
52573: LD_ADDR_VAR 0 1
52577: PUSH
52578: LD_VAR 0 2
52582: PUSH
52583: FOR_IN
52584: IFFALSE 52600
// SetFuel ( i , 0 ) ;
52586: LD_VAR 0 1
52590: PPUSH
52591: LD_INT 0
52593: PPUSH
52594: CALL_OW 240
52598: GO 52583
52600: POP
52601: POP
// end ;
52602: PPOPN 2
52604: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52605: LD_EXP 92
52609: PUSH
52610: LD_EXP 128
52614: AND
52615: IFFALSE 52681
52617: GO 52619
52619: DISABLE
52620: LD_INT 0
52622: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52623: LD_ADDR_VAR 0 1
52627: PUSH
52628: LD_INT 22
52630: PUSH
52631: LD_OWVAR 2
52635: PUSH
52636: EMPTY
52637: LIST
52638: LIST
52639: PUSH
52640: LD_INT 30
52642: PUSH
52643: LD_INT 29
52645: PUSH
52646: EMPTY
52647: LIST
52648: LIST
52649: PUSH
52650: EMPTY
52651: LIST
52652: LIST
52653: PPUSH
52654: CALL_OW 69
52658: ST_TO_ADDR
// if not tmp then
52659: LD_VAR 0 1
52663: NOT
52664: IFFALSE 52668
// exit ;
52666: GO 52681
// DestroyUnit ( tmp [ 1 ] ) ;
52668: LD_VAR 0 1
52672: PUSH
52673: LD_INT 1
52675: ARRAY
52676: PPUSH
52677: CALL_OW 65
// end ;
52681: PPOPN 1
52683: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52684: LD_EXP 92
52688: PUSH
52689: LD_EXP 130
52693: AND
52694: IFFALSE 52823
52696: GO 52698
52698: DISABLE
52699: LD_INT 0
52701: PPUSH
// begin uc_side := 0 ;
52702: LD_ADDR_OWVAR 20
52706: PUSH
52707: LD_INT 0
52709: ST_TO_ADDR
// uc_nation := nation_arabian ;
52710: LD_ADDR_OWVAR 21
52714: PUSH
52715: LD_INT 2
52717: ST_TO_ADDR
// hc_gallery :=  ;
52718: LD_ADDR_OWVAR 33
52722: PUSH
52723: LD_STRING 
52725: ST_TO_ADDR
// hc_name :=  ;
52726: LD_ADDR_OWVAR 26
52730: PUSH
52731: LD_STRING 
52733: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52734: LD_INT 1
52736: PPUSH
52737: LD_INT 11
52739: PPUSH
52740: LD_INT 10
52742: PPUSH
52743: CALL_OW 380
// un := CreateHuman ;
52747: LD_ADDR_VAR 0 1
52751: PUSH
52752: CALL_OW 44
52756: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52757: LD_VAR 0 1
52761: PPUSH
52762: LD_INT 1
52764: PPUSH
52765: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52769: LD_INT 35
52771: PPUSH
52772: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52776: LD_VAR 0 1
52780: PPUSH
52781: LD_INT 22
52783: PUSH
52784: LD_OWVAR 2
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: PPUSH
52793: CALL_OW 69
52797: PPUSH
52798: LD_VAR 0 1
52802: PPUSH
52803: CALL_OW 74
52807: PPUSH
52808: CALL_OW 115
// until IsDead ( un ) ;
52812: LD_VAR 0 1
52816: PPUSH
52817: CALL_OW 301
52821: IFFALSE 52769
// end ;
52823: PPOPN 1
52825: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52826: LD_EXP 92
52830: PUSH
52831: LD_EXP 132
52835: AND
52836: IFFALSE 52848
52838: GO 52840
52840: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52841: LD_STRING earthquake(getX(game), 0, 32)
52843: PPUSH
52844: CALL_OW 559
52848: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52849: LD_EXP 92
52853: PUSH
52854: LD_EXP 133
52858: AND
52859: IFFALSE 52950
52861: GO 52863
52863: DISABLE
52864: LD_INT 0
52866: PPUSH
// begin enable ;
52867: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52868: LD_ADDR_VAR 0 1
52872: PUSH
52873: LD_INT 22
52875: PUSH
52876: LD_OWVAR 2
52880: PUSH
52881: EMPTY
52882: LIST
52883: LIST
52884: PUSH
52885: LD_INT 21
52887: PUSH
52888: LD_INT 2
52890: PUSH
52891: EMPTY
52892: LIST
52893: LIST
52894: PUSH
52895: LD_INT 33
52897: PUSH
52898: LD_INT 3
52900: PUSH
52901: EMPTY
52902: LIST
52903: LIST
52904: PUSH
52905: EMPTY
52906: LIST
52907: LIST
52908: LIST
52909: PPUSH
52910: CALL_OW 69
52914: ST_TO_ADDR
// if not tmp then
52915: LD_VAR 0 1
52919: NOT
52920: IFFALSE 52924
// exit ;
52922: GO 52950
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52924: LD_VAR 0 1
52928: PUSH
52929: LD_INT 1
52931: PPUSH
52932: LD_VAR 0 1
52936: PPUSH
52937: CALL_OW 12
52941: ARRAY
52942: PPUSH
52943: LD_INT 1
52945: PPUSH
52946: CALL_OW 234
// end ;
52950: PPOPN 1
52952: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52953: LD_EXP 92
52957: PUSH
52958: LD_EXP 134
52962: AND
52963: IFFALSE 53104
52965: GO 52967
52967: DISABLE
52968: LD_INT 0
52970: PPUSH
52971: PPUSH
52972: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52973: LD_ADDR_VAR 0 3
52977: PUSH
52978: LD_INT 22
52980: PUSH
52981: LD_OWVAR 2
52985: PUSH
52986: EMPTY
52987: LIST
52988: LIST
52989: PUSH
52990: LD_INT 25
52992: PUSH
52993: LD_INT 1
52995: PUSH
52996: EMPTY
52997: LIST
52998: LIST
52999: PUSH
53000: EMPTY
53001: LIST
53002: LIST
53003: PPUSH
53004: CALL_OW 69
53008: ST_TO_ADDR
// if not tmp then
53009: LD_VAR 0 3
53013: NOT
53014: IFFALSE 53018
// exit ;
53016: GO 53104
// un := tmp [ rand ( 1 , tmp ) ] ;
53018: LD_ADDR_VAR 0 2
53022: PUSH
53023: LD_VAR 0 3
53027: PUSH
53028: LD_INT 1
53030: PPUSH
53031: LD_VAR 0 3
53035: PPUSH
53036: CALL_OW 12
53040: ARRAY
53041: ST_TO_ADDR
// if Crawls ( un ) then
53042: LD_VAR 0 2
53046: PPUSH
53047: CALL_OW 318
53051: IFFALSE 53062
// ComWalk ( un ) ;
53053: LD_VAR 0 2
53057: PPUSH
53058: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53062: LD_VAR 0 2
53066: PPUSH
53067: LD_INT 9
53069: PPUSH
53070: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53074: LD_INT 28
53076: PPUSH
53077: LD_OWVAR 2
53081: PPUSH
53082: LD_INT 2
53084: PPUSH
53085: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53089: LD_INT 29
53091: PPUSH
53092: LD_OWVAR 2
53096: PPUSH
53097: LD_INT 2
53099: PPUSH
53100: CALL_OW 322
// end ;
53104: PPOPN 3
53106: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53107: LD_EXP 92
53111: PUSH
53112: LD_EXP 135
53116: AND
53117: IFFALSE 53228
53119: GO 53121
53121: DISABLE
53122: LD_INT 0
53124: PPUSH
53125: PPUSH
53126: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53127: LD_ADDR_VAR 0 3
53131: PUSH
53132: LD_INT 22
53134: PUSH
53135: LD_OWVAR 2
53139: PUSH
53140: EMPTY
53141: LIST
53142: LIST
53143: PUSH
53144: LD_INT 25
53146: PUSH
53147: LD_INT 1
53149: PUSH
53150: EMPTY
53151: LIST
53152: LIST
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: PPUSH
53158: CALL_OW 69
53162: ST_TO_ADDR
// if not tmp then
53163: LD_VAR 0 3
53167: NOT
53168: IFFALSE 53172
// exit ;
53170: GO 53228
// un := tmp [ rand ( 1 , tmp ) ] ;
53172: LD_ADDR_VAR 0 2
53176: PUSH
53177: LD_VAR 0 3
53181: PUSH
53182: LD_INT 1
53184: PPUSH
53185: LD_VAR 0 3
53189: PPUSH
53190: CALL_OW 12
53194: ARRAY
53195: ST_TO_ADDR
// if Crawls ( un ) then
53196: LD_VAR 0 2
53200: PPUSH
53201: CALL_OW 318
53205: IFFALSE 53216
// ComWalk ( un ) ;
53207: LD_VAR 0 2
53211: PPUSH
53212: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53216: LD_VAR 0 2
53220: PPUSH
53221: LD_INT 8
53223: PPUSH
53224: CALL_OW 336
// end ;
53228: PPOPN 3
53230: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53231: LD_EXP 92
53235: PUSH
53236: LD_EXP 136
53240: AND
53241: IFFALSE 53385
53243: GO 53245
53245: DISABLE
53246: LD_INT 0
53248: PPUSH
53249: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53250: LD_ADDR_VAR 0 2
53254: PUSH
53255: LD_INT 22
53257: PUSH
53258: LD_OWVAR 2
53262: PUSH
53263: EMPTY
53264: LIST
53265: LIST
53266: PUSH
53267: LD_INT 21
53269: PUSH
53270: LD_INT 2
53272: PUSH
53273: EMPTY
53274: LIST
53275: LIST
53276: PUSH
53277: LD_INT 2
53279: PUSH
53280: LD_INT 34
53282: PUSH
53283: LD_INT 12
53285: PUSH
53286: EMPTY
53287: LIST
53288: LIST
53289: PUSH
53290: LD_INT 34
53292: PUSH
53293: LD_INT 51
53295: PUSH
53296: EMPTY
53297: LIST
53298: LIST
53299: PUSH
53300: LD_INT 34
53302: PUSH
53303: LD_INT 32
53305: PUSH
53306: EMPTY
53307: LIST
53308: LIST
53309: PUSH
53310: EMPTY
53311: LIST
53312: LIST
53313: LIST
53314: LIST
53315: PUSH
53316: EMPTY
53317: LIST
53318: LIST
53319: LIST
53320: PPUSH
53321: CALL_OW 69
53325: ST_TO_ADDR
// if not tmp then
53326: LD_VAR 0 2
53330: NOT
53331: IFFALSE 53335
// exit ;
53333: GO 53385
// for i in tmp do
53335: LD_ADDR_VAR 0 1
53339: PUSH
53340: LD_VAR 0 2
53344: PUSH
53345: FOR_IN
53346: IFFALSE 53383
// if GetCargo ( i , mat_artifact ) = 0 then
53348: LD_VAR 0 1
53352: PPUSH
53353: LD_INT 4
53355: PPUSH
53356: CALL_OW 289
53360: PUSH
53361: LD_INT 0
53363: EQUAL
53364: IFFALSE 53381
// SetCargo ( i , mat_siberit , 100 ) ;
53366: LD_VAR 0 1
53370: PPUSH
53371: LD_INT 3
53373: PPUSH
53374: LD_INT 100
53376: PPUSH
53377: CALL_OW 290
53381: GO 53345
53383: POP
53384: POP
// end ;
53385: PPOPN 2
53387: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53388: LD_EXP 92
53392: PUSH
53393: LD_EXP 137
53397: AND
53398: IFFALSE 53581
53400: GO 53402
53402: DISABLE
53403: LD_INT 0
53405: PPUSH
53406: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53407: LD_ADDR_VAR 0 2
53411: PUSH
53412: LD_INT 22
53414: PUSH
53415: LD_OWVAR 2
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PPUSH
53424: CALL_OW 69
53428: ST_TO_ADDR
// if not tmp then
53429: LD_VAR 0 2
53433: NOT
53434: IFFALSE 53438
// exit ;
53436: GO 53581
// for i := 1 to 2 do
53438: LD_ADDR_VAR 0 1
53442: PUSH
53443: DOUBLE
53444: LD_INT 1
53446: DEC
53447: ST_TO_ADDR
53448: LD_INT 2
53450: PUSH
53451: FOR_TO
53452: IFFALSE 53579
// begin uc_side := your_side ;
53454: LD_ADDR_OWVAR 20
53458: PUSH
53459: LD_OWVAR 2
53463: ST_TO_ADDR
// uc_nation := nation_american ;
53464: LD_ADDR_OWVAR 21
53468: PUSH
53469: LD_INT 1
53471: ST_TO_ADDR
// vc_chassis := us_morphling ;
53472: LD_ADDR_OWVAR 37
53476: PUSH
53477: LD_INT 5
53479: ST_TO_ADDR
// vc_engine := engine_siberite ;
53480: LD_ADDR_OWVAR 39
53484: PUSH
53485: LD_INT 3
53487: ST_TO_ADDR
// vc_control := control_computer ;
53488: LD_ADDR_OWVAR 38
53492: PUSH
53493: LD_INT 3
53495: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53496: LD_ADDR_OWVAR 40
53500: PUSH
53501: LD_INT 10
53503: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53504: LD_VAR 0 2
53508: PUSH
53509: LD_INT 1
53511: ARRAY
53512: PPUSH
53513: CALL_OW 310
53517: NOT
53518: IFFALSE 53565
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53520: CALL_OW 45
53524: PPUSH
53525: LD_VAR 0 2
53529: PUSH
53530: LD_INT 1
53532: ARRAY
53533: PPUSH
53534: CALL_OW 250
53538: PPUSH
53539: LD_VAR 0 2
53543: PUSH
53544: LD_INT 1
53546: ARRAY
53547: PPUSH
53548: CALL_OW 251
53552: PPUSH
53553: LD_INT 12
53555: PPUSH
53556: LD_INT 1
53558: PPUSH
53559: CALL_OW 50
53563: GO 53577
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53565: CALL_OW 45
53569: PPUSH
53570: LD_INT 1
53572: PPUSH
53573: CALL_OW 51
// end ;
53577: GO 53451
53579: POP
53580: POP
// end ;
53581: PPOPN 2
53583: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53584: LD_EXP 92
53588: PUSH
53589: LD_EXP 138
53593: AND
53594: IFFALSE 53816
53596: GO 53598
53598: DISABLE
53599: LD_INT 0
53601: PPUSH
53602: PPUSH
53603: PPUSH
53604: PPUSH
53605: PPUSH
53606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53607: LD_ADDR_VAR 0 6
53611: PUSH
53612: LD_INT 22
53614: PUSH
53615: LD_OWVAR 2
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: PUSH
53624: LD_INT 21
53626: PUSH
53627: LD_INT 1
53629: PUSH
53630: EMPTY
53631: LIST
53632: LIST
53633: PUSH
53634: LD_INT 3
53636: PUSH
53637: LD_INT 23
53639: PUSH
53640: LD_INT 0
53642: PUSH
53643: EMPTY
53644: LIST
53645: LIST
53646: PUSH
53647: EMPTY
53648: LIST
53649: LIST
53650: PUSH
53651: EMPTY
53652: LIST
53653: LIST
53654: LIST
53655: PPUSH
53656: CALL_OW 69
53660: ST_TO_ADDR
// if not tmp then
53661: LD_VAR 0 6
53665: NOT
53666: IFFALSE 53670
// exit ;
53668: GO 53816
// s1 := rand ( 1 , 4 ) ;
53670: LD_ADDR_VAR 0 2
53674: PUSH
53675: LD_INT 1
53677: PPUSH
53678: LD_INT 4
53680: PPUSH
53681: CALL_OW 12
53685: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53686: LD_ADDR_VAR 0 4
53690: PUSH
53691: LD_VAR 0 6
53695: PUSH
53696: LD_INT 1
53698: ARRAY
53699: PPUSH
53700: LD_VAR 0 2
53704: PPUSH
53705: CALL_OW 259
53709: ST_TO_ADDR
// if s1 = 1 then
53710: LD_VAR 0 2
53714: PUSH
53715: LD_INT 1
53717: EQUAL
53718: IFFALSE 53738
// s2 := rand ( 2 , 4 ) else
53720: LD_ADDR_VAR 0 3
53724: PUSH
53725: LD_INT 2
53727: PPUSH
53728: LD_INT 4
53730: PPUSH
53731: CALL_OW 12
53735: ST_TO_ADDR
53736: GO 53746
// s2 := 1 ;
53738: LD_ADDR_VAR 0 3
53742: PUSH
53743: LD_INT 1
53745: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53746: LD_ADDR_VAR 0 5
53750: PUSH
53751: LD_VAR 0 6
53755: PUSH
53756: LD_INT 1
53758: ARRAY
53759: PPUSH
53760: LD_VAR 0 3
53764: PPUSH
53765: CALL_OW 259
53769: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53770: LD_VAR 0 6
53774: PUSH
53775: LD_INT 1
53777: ARRAY
53778: PPUSH
53779: LD_VAR 0 2
53783: PPUSH
53784: LD_VAR 0 5
53788: PPUSH
53789: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53793: LD_VAR 0 6
53797: PUSH
53798: LD_INT 1
53800: ARRAY
53801: PPUSH
53802: LD_VAR 0 3
53806: PPUSH
53807: LD_VAR 0 4
53811: PPUSH
53812: CALL_OW 237
// end ;
53816: PPOPN 6
53818: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53819: LD_EXP 92
53823: PUSH
53824: LD_EXP 139
53828: AND
53829: IFFALSE 53908
53831: GO 53833
53833: DISABLE
53834: LD_INT 0
53836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53837: LD_ADDR_VAR 0 1
53841: PUSH
53842: LD_INT 22
53844: PUSH
53845: LD_OWVAR 2
53849: PUSH
53850: EMPTY
53851: LIST
53852: LIST
53853: PUSH
53854: LD_INT 30
53856: PUSH
53857: LD_INT 3
53859: PUSH
53860: EMPTY
53861: LIST
53862: LIST
53863: PUSH
53864: EMPTY
53865: LIST
53866: LIST
53867: PPUSH
53868: CALL_OW 69
53872: ST_TO_ADDR
// if not tmp then
53873: LD_VAR 0 1
53877: NOT
53878: IFFALSE 53882
// exit ;
53880: GO 53908
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53882: LD_VAR 0 1
53886: PUSH
53887: LD_INT 1
53889: PPUSH
53890: LD_VAR 0 1
53894: PPUSH
53895: CALL_OW 12
53899: ARRAY
53900: PPUSH
53901: LD_INT 1
53903: PPUSH
53904: CALL_OW 234
// end ;
53908: PPOPN 1
53910: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53911: LD_EXP 92
53915: PUSH
53916: LD_EXP 140
53920: AND
53921: IFFALSE 54033
53923: GO 53925
53925: DISABLE
53926: LD_INT 0
53928: PPUSH
53929: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53930: LD_ADDR_VAR 0 2
53934: PUSH
53935: LD_INT 22
53937: PUSH
53938: LD_OWVAR 2
53942: PUSH
53943: EMPTY
53944: LIST
53945: LIST
53946: PUSH
53947: LD_INT 2
53949: PUSH
53950: LD_INT 30
53952: PUSH
53953: LD_INT 27
53955: PUSH
53956: EMPTY
53957: LIST
53958: LIST
53959: PUSH
53960: LD_INT 30
53962: PUSH
53963: LD_INT 26
53965: PUSH
53966: EMPTY
53967: LIST
53968: LIST
53969: PUSH
53970: LD_INT 30
53972: PUSH
53973: LD_INT 28
53975: PUSH
53976: EMPTY
53977: LIST
53978: LIST
53979: PUSH
53980: EMPTY
53981: LIST
53982: LIST
53983: LIST
53984: LIST
53985: PUSH
53986: EMPTY
53987: LIST
53988: LIST
53989: PPUSH
53990: CALL_OW 69
53994: ST_TO_ADDR
// if not tmp then
53995: LD_VAR 0 2
53999: NOT
54000: IFFALSE 54004
// exit ;
54002: GO 54033
// for i in tmp do
54004: LD_ADDR_VAR 0 1
54008: PUSH
54009: LD_VAR 0 2
54013: PUSH
54014: FOR_IN
54015: IFFALSE 54031
// SetLives ( i , 1 ) ;
54017: LD_VAR 0 1
54021: PPUSH
54022: LD_INT 1
54024: PPUSH
54025: CALL_OW 234
54029: GO 54014
54031: POP
54032: POP
// end ;
54033: PPOPN 2
54035: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54036: LD_EXP 92
54040: PUSH
54041: LD_EXP 141
54045: AND
54046: IFFALSE 54333
54048: GO 54050
54050: DISABLE
54051: LD_INT 0
54053: PPUSH
54054: PPUSH
54055: PPUSH
// begin i := rand ( 1 , 7 ) ;
54056: LD_ADDR_VAR 0 1
54060: PUSH
54061: LD_INT 1
54063: PPUSH
54064: LD_INT 7
54066: PPUSH
54067: CALL_OW 12
54071: ST_TO_ADDR
// case i of 1 :
54072: LD_VAR 0 1
54076: PUSH
54077: LD_INT 1
54079: DOUBLE
54080: EQUAL
54081: IFTRUE 54085
54083: GO 54095
54085: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54086: LD_STRING earthquake(getX(game), 0, 32)
54088: PPUSH
54089: CALL_OW 559
54093: GO 54333
54095: LD_INT 2
54097: DOUBLE
54098: EQUAL
54099: IFTRUE 54103
54101: GO 54117
54103: POP
// begin ToLua ( displayStucuk(); ) ;
54104: LD_STRING displayStucuk();
54106: PPUSH
54107: CALL_OW 559
// ResetFog ;
54111: CALL_OW 335
// end ; 3 :
54115: GO 54333
54117: LD_INT 3
54119: DOUBLE
54120: EQUAL
54121: IFTRUE 54125
54123: GO 54229
54125: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54126: LD_ADDR_VAR 0 2
54130: PUSH
54131: LD_INT 22
54133: PUSH
54134: LD_OWVAR 2
54138: PUSH
54139: EMPTY
54140: LIST
54141: LIST
54142: PUSH
54143: LD_INT 25
54145: PUSH
54146: LD_INT 1
54148: PUSH
54149: EMPTY
54150: LIST
54151: LIST
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: PPUSH
54157: CALL_OW 69
54161: ST_TO_ADDR
// if not tmp then
54162: LD_VAR 0 2
54166: NOT
54167: IFFALSE 54171
// exit ;
54169: GO 54333
// un := tmp [ rand ( 1 , tmp ) ] ;
54171: LD_ADDR_VAR 0 3
54175: PUSH
54176: LD_VAR 0 2
54180: PUSH
54181: LD_INT 1
54183: PPUSH
54184: LD_VAR 0 2
54188: PPUSH
54189: CALL_OW 12
54193: ARRAY
54194: ST_TO_ADDR
// if Crawls ( un ) then
54195: LD_VAR 0 3
54199: PPUSH
54200: CALL_OW 318
54204: IFFALSE 54215
// ComWalk ( un ) ;
54206: LD_VAR 0 3
54210: PPUSH
54211: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54215: LD_VAR 0 3
54219: PPUSH
54220: LD_INT 8
54222: PPUSH
54223: CALL_OW 336
// end ; 4 :
54227: GO 54333
54229: LD_INT 4
54231: DOUBLE
54232: EQUAL
54233: IFTRUE 54237
54235: GO 54311
54237: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54238: LD_ADDR_VAR 0 2
54242: PUSH
54243: LD_INT 22
54245: PUSH
54246: LD_OWVAR 2
54250: PUSH
54251: EMPTY
54252: LIST
54253: LIST
54254: PUSH
54255: LD_INT 30
54257: PUSH
54258: LD_INT 29
54260: PUSH
54261: EMPTY
54262: LIST
54263: LIST
54264: PUSH
54265: EMPTY
54266: LIST
54267: LIST
54268: PPUSH
54269: CALL_OW 69
54273: ST_TO_ADDR
// if not tmp then
54274: LD_VAR 0 2
54278: NOT
54279: IFFALSE 54283
// exit ;
54281: GO 54333
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54283: LD_VAR 0 2
54287: PUSH
54288: LD_INT 1
54290: ARRAY
54291: PPUSH
54292: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54296: LD_VAR 0 2
54300: PUSH
54301: LD_INT 1
54303: ARRAY
54304: PPUSH
54305: CALL_OW 65
// end ; 5 .. 7 :
54309: GO 54333
54311: LD_INT 5
54313: DOUBLE
54314: GREATEREQUAL
54315: IFFALSE 54323
54317: LD_INT 7
54319: DOUBLE
54320: LESSEQUAL
54321: IFTRUE 54325
54323: GO 54332
54325: POP
// StreamSibBomb ; end ;
54326: CALL 50570 0 0
54330: GO 54333
54332: POP
// end ;
54333: PPOPN 3
54335: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54336: LD_EXP 92
54340: PUSH
54341: LD_EXP 142
54345: AND
54346: IFFALSE 54502
54348: GO 54350
54350: DISABLE
54351: LD_INT 0
54353: PPUSH
54354: PPUSH
54355: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54356: LD_ADDR_VAR 0 2
54360: PUSH
54361: LD_INT 81
54363: PUSH
54364: LD_OWVAR 2
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: PUSH
54373: LD_INT 2
54375: PUSH
54376: LD_INT 21
54378: PUSH
54379: LD_INT 1
54381: PUSH
54382: EMPTY
54383: LIST
54384: LIST
54385: PUSH
54386: LD_INT 21
54388: PUSH
54389: LD_INT 2
54391: PUSH
54392: EMPTY
54393: LIST
54394: LIST
54395: PUSH
54396: EMPTY
54397: LIST
54398: LIST
54399: LIST
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: PPUSH
54405: CALL_OW 69
54409: ST_TO_ADDR
// if not tmp then
54410: LD_VAR 0 2
54414: NOT
54415: IFFALSE 54419
// exit ;
54417: GO 54502
// p := 0 ;
54419: LD_ADDR_VAR 0 3
54423: PUSH
54424: LD_INT 0
54426: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54427: LD_INT 35
54429: PPUSH
54430: CALL_OW 67
// p := p + 1 ;
54434: LD_ADDR_VAR 0 3
54438: PUSH
54439: LD_VAR 0 3
54443: PUSH
54444: LD_INT 1
54446: PLUS
54447: ST_TO_ADDR
// for i in tmp do
54448: LD_ADDR_VAR 0 1
54452: PUSH
54453: LD_VAR 0 2
54457: PUSH
54458: FOR_IN
54459: IFFALSE 54490
// if GetLives ( i ) < 1000 then
54461: LD_VAR 0 1
54465: PPUSH
54466: CALL_OW 256
54470: PUSH
54471: LD_INT 1000
54473: LESS
54474: IFFALSE 54488
// SetLives ( i , 1000 ) ;
54476: LD_VAR 0 1
54480: PPUSH
54481: LD_INT 1000
54483: PPUSH
54484: CALL_OW 234
54488: GO 54458
54490: POP
54491: POP
// until p > 20 ;
54492: LD_VAR 0 3
54496: PUSH
54497: LD_INT 20
54499: GREATER
54500: IFFALSE 54427
// end ;
54502: PPOPN 3
54504: END
// every 0 0$1 trigger StreamModeActive and sTime do
54505: LD_EXP 92
54509: PUSH
54510: LD_EXP 143
54514: AND
54515: IFFALSE 54550
54517: GO 54519
54519: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54520: LD_INT 28
54522: PPUSH
54523: LD_OWVAR 2
54527: PPUSH
54528: LD_INT 2
54530: PPUSH
54531: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54535: LD_INT 30
54537: PPUSH
54538: LD_OWVAR 2
54542: PPUSH
54543: LD_INT 2
54545: PPUSH
54546: CALL_OW 322
// end ;
54550: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54551: LD_EXP 92
54555: PUSH
54556: LD_EXP 144
54560: AND
54561: IFFALSE 54682
54563: GO 54565
54565: DISABLE
54566: LD_INT 0
54568: PPUSH
54569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54570: LD_ADDR_VAR 0 2
54574: PUSH
54575: LD_INT 22
54577: PUSH
54578: LD_OWVAR 2
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: PUSH
54587: LD_INT 21
54589: PUSH
54590: LD_INT 1
54592: PUSH
54593: EMPTY
54594: LIST
54595: LIST
54596: PUSH
54597: LD_INT 3
54599: PUSH
54600: LD_INT 23
54602: PUSH
54603: LD_INT 0
54605: PUSH
54606: EMPTY
54607: LIST
54608: LIST
54609: PUSH
54610: EMPTY
54611: LIST
54612: LIST
54613: PUSH
54614: EMPTY
54615: LIST
54616: LIST
54617: LIST
54618: PPUSH
54619: CALL_OW 69
54623: ST_TO_ADDR
// if not tmp then
54624: LD_VAR 0 2
54628: NOT
54629: IFFALSE 54633
// exit ;
54631: GO 54682
// for i in tmp do
54633: LD_ADDR_VAR 0 1
54637: PUSH
54638: LD_VAR 0 2
54642: PUSH
54643: FOR_IN
54644: IFFALSE 54680
// begin if Crawls ( i ) then
54646: LD_VAR 0 1
54650: PPUSH
54651: CALL_OW 318
54655: IFFALSE 54666
// ComWalk ( i ) ;
54657: LD_VAR 0 1
54661: PPUSH
54662: CALL_OW 138
// SetClass ( i , 2 ) ;
54666: LD_VAR 0 1
54670: PPUSH
54671: LD_INT 2
54673: PPUSH
54674: CALL_OW 336
// end ;
54678: GO 54643
54680: POP
54681: POP
// end ;
54682: PPOPN 2
54684: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54685: LD_EXP 92
54689: PUSH
54690: LD_EXP 145
54694: AND
54695: IFFALSE 54983
54697: GO 54699
54699: DISABLE
54700: LD_INT 0
54702: PPUSH
54703: PPUSH
54704: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54705: LD_OWVAR 2
54709: PPUSH
54710: LD_INT 9
54712: PPUSH
54713: LD_INT 1
54715: PPUSH
54716: LD_INT 1
54718: PPUSH
54719: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54723: LD_INT 9
54725: PPUSH
54726: LD_OWVAR 2
54730: PPUSH
54731: CALL_OW 343
// uc_side := 9 ;
54735: LD_ADDR_OWVAR 20
54739: PUSH
54740: LD_INT 9
54742: ST_TO_ADDR
// uc_nation := 2 ;
54743: LD_ADDR_OWVAR 21
54747: PUSH
54748: LD_INT 2
54750: ST_TO_ADDR
// hc_name := Dark Warrior ;
54751: LD_ADDR_OWVAR 26
54755: PUSH
54756: LD_STRING Dark Warrior
54758: ST_TO_ADDR
// hc_gallery :=  ;
54759: LD_ADDR_OWVAR 33
54763: PUSH
54764: LD_STRING 
54766: ST_TO_ADDR
// hc_noskilllimit := true ;
54767: LD_ADDR_OWVAR 76
54771: PUSH
54772: LD_INT 1
54774: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54775: LD_ADDR_OWVAR 31
54779: PUSH
54780: LD_INT 30
54782: PUSH
54783: LD_INT 30
54785: PUSH
54786: LD_INT 30
54788: PUSH
54789: LD_INT 30
54791: PUSH
54792: EMPTY
54793: LIST
54794: LIST
54795: LIST
54796: LIST
54797: ST_TO_ADDR
// un := CreateHuman ;
54798: LD_ADDR_VAR 0 3
54802: PUSH
54803: CALL_OW 44
54807: ST_TO_ADDR
// hc_noskilllimit := false ;
54808: LD_ADDR_OWVAR 76
54812: PUSH
54813: LD_INT 0
54815: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54816: LD_VAR 0 3
54820: PPUSH
54821: LD_INT 1
54823: PPUSH
54824: CALL_OW 51
// ToLua ( playRanger() ) ;
54828: LD_STRING playRanger()
54830: PPUSH
54831: CALL_OW 559
// p := 0 ;
54835: LD_ADDR_VAR 0 2
54839: PUSH
54840: LD_INT 0
54842: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54843: LD_INT 35
54845: PPUSH
54846: CALL_OW 67
// p := p + 1 ;
54850: LD_ADDR_VAR 0 2
54854: PUSH
54855: LD_VAR 0 2
54859: PUSH
54860: LD_INT 1
54862: PLUS
54863: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54864: LD_VAR 0 3
54868: PPUSH
54869: CALL_OW 256
54873: PUSH
54874: LD_INT 1000
54876: LESS
54877: IFFALSE 54891
// SetLives ( un , 1000 ) ;
54879: LD_VAR 0 3
54883: PPUSH
54884: LD_INT 1000
54886: PPUSH
54887: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54891: LD_VAR 0 3
54895: PPUSH
54896: LD_INT 81
54898: PUSH
54899: LD_OWVAR 2
54903: PUSH
54904: EMPTY
54905: LIST
54906: LIST
54907: PUSH
54908: LD_INT 91
54910: PUSH
54911: LD_VAR 0 3
54915: PUSH
54916: LD_INT 30
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: LIST
54923: PUSH
54924: EMPTY
54925: LIST
54926: LIST
54927: PPUSH
54928: CALL_OW 69
54932: PPUSH
54933: LD_VAR 0 3
54937: PPUSH
54938: CALL_OW 74
54942: PPUSH
54943: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
54947: LD_VAR 0 2
54951: PUSH
54952: LD_INT 80
54954: GREATER
54955: PUSH
54956: LD_VAR 0 3
54960: PPUSH
54961: CALL_OW 301
54965: OR
54966: IFFALSE 54843
// if un then
54968: LD_VAR 0 3
54972: IFFALSE 54983
// RemoveUnit ( un ) ;
54974: LD_VAR 0 3
54978: PPUSH
54979: CALL_OW 64
// end ;
54983: PPOPN 3
54985: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
54986: LD_EXP 146
54990: IFFALSE 55106
54992: GO 54994
54994: DISABLE
54995: LD_INT 0
54997: PPUSH
54998: PPUSH
54999: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55000: LD_ADDR_VAR 0 2
55004: PUSH
55005: LD_INT 81
55007: PUSH
55008: LD_OWVAR 2
55012: PUSH
55013: EMPTY
55014: LIST
55015: LIST
55016: PUSH
55017: LD_INT 21
55019: PUSH
55020: LD_INT 1
55022: PUSH
55023: EMPTY
55024: LIST
55025: LIST
55026: PUSH
55027: EMPTY
55028: LIST
55029: LIST
55030: PPUSH
55031: CALL_OW 69
55035: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55036: LD_STRING playComputer()
55038: PPUSH
55039: CALL_OW 559
// if not tmp then
55043: LD_VAR 0 2
55047: NOT
55048: IFFALSE 55052
// exit ;
55050: GO 55106
// for i in tmp do
55052: LD_ADDR_VAR 0 1
55056: PUSH
55057: LD_VAR 0 2
55061: PUSH
55062: FOR_IN
55063: IFFALSE 55104
// for j := 1 to 4 do
55065: LD_ADDR_VAR 0 3
55069: PUSH
55070: DOUBLE
55071: LD_INT 1
55073: DEC
55074: ST_TO_ADDR
55075: LD_INT 4
55077: PUSH
55078: FOR_TO
55079: IFFALSE 55100
// SetSkill ( i , j , 10 ) ;
55081: LD_VAR 0 1
55085: PPUSH
55086: LD_VAR 0 3
55090: PPUSH
55091: LD_INT 10
55093: PPUSH
55094: CALL_OW 237
55098: GO 55078
55100: POP
55101: POP
55102: GO 55062
55104: POP
55105: POP
// end ;
55106: PPOPN 3
55108: END
// every 0 0$1 trigger s30 do var i , tmp ;
55109: LD_EXP 147
55113: IFFALSE 55182
55115: GO 55117
55117: DISABLE
55118: LD_INT 0
55120: PPUSH
55121: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55122: LD_ADDR_VAR 0 2
55126: PUSH
55127: LD_INT 22
55129: PUSH
55130: LD_OWVAR 2
55134: PUSH
55135: EMPTY
55136: LIST
55137: LIST
55138: PPUSH
55139: CALL_OW 69
55143: ST_TO_ADDR
// if not tmp then
55144: LD_VAR 0 2
55148: NOT
55149: IFFALSE 55153
// exit ;
55151: GO 55182
// for i in tmp do
55153: LD_ADDR_VAR 0 1
55157: PUSH
55158: LD_VAR 0 2
55162: PUSH
55163: FOR_IN
55164: IFFALSE 55180
// SetLives ( i , 300 ) ;
55166: LD_VAR 0 1
55170: PPUSH
55171: LD_INT 300
55173: PPUSH
55174: CALL_OW 234
55178: GO 55163
55180: POP
55181: POP
// end ;
55182: PPOPN 2
55184: END
// every 0 0$1 trigger s60 do var i , tmp ;
55185: LD_EXP 148
55189: IFFALSE 55258
55191: GO 55193
55193: DISABLE
55194: LD_INT 0
55196: PPUSH
55197: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55198: LD_ADDR_VAR 0 2
55202: PUSH
55203: LD_INT 22
55205: PUSH
55206: LD_OWVAR 2
55210: PUSH
55211: EMPTY
55212: LIST
55213: LIST
55214: PPUSH
55215: CALL_OW 69
55219: ST_TO_ADDR
// if not tmp then
55220: LD_VAR 0 2
55224: NOT
55225: IFFALSE 55229
// exit ;
55227: GO 55258
// for i in tmp do
55229: LD_ADDR_VAR 0 1
55233: PUSH
55234: LD_VAR 0 2
55238: PUSH
55239: FOR_IN
55240: IFFALSE 55256
// SetLives ( i , 600 ) ;
55242: LD_VAR 0 1
55246: PPUSH
55247: LD_INT 600
55249: PPUSH
55250: CALL_OW 234
55254: GO 55239
55256: POP
55257: POP
// end ;
55258: PPOPN 2
55260: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55261: LD_INT 0
55263: PPUSH
// case cmd of 301 :
55264: LD_VAR 0 1
55268: PUSH
55269: LD_INT 301
55271: DOUBLE
55272: EQUAL
55273: IFTRUE 55277
55275: GO 55309
55277: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55278: LD_VAR 0 6
55282: PPUSH
55283: LD_VAR 0 7
55287: PPUSH
55288: LD_VAR 0 8
55292: PPUSH
55293: LD_VAR 0 4
55297: PPUSH
55298: LD_VAR 0 5
55302: PPUSH
55303: CALL 56510 0 5
55307: GO 55430
55309: LD_INT 302
55311: DOUBLE
55312: EQUAL
55313: IFTRUE 55317
55315: GO 55354
55317: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55318: LD_VAR 0 6
55322: PPUSH
55323: LD_VAR 0 7
55327: PPUSH
55328: LD_VAR 0 8
55332: PPUSH
55333: LD_VAR 0 9
55337: PPUSH
55338: LD_VAR 0 4
55342: PPUSH
55343: LD_VAR 0 5
55347: PPUSH
55348: CALL 56601 0 6
55352: GO 55430
55354: LD_INT 303
55356: DOUBLE
55357: EQUAL
55358: IFTRUE 55362
55360: GO 55399
55362: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55363: LD_VAR 0 6
55367: PPUSH
55368: LD_VAR 0 7
55372: PPUSH
55373: LD_VAR 0 8
55377: PPUSH
55378: LD_VAR 0 9
55382: PPUSH
55383: LD_VAR 0 4
55387: PPUSH
55388: LD_VAR 0 5
55392: PPUSH
55393: CALL 55435 0 6
55397: GO 55430
55399: LD_INT 304
55401: DOUBLE
55402: EQUAL
55403: IFTRUE 55407
55405: GO 55429
55407: POP
// hHackTeleport ( unit , x , y ) ; end ;
55408: LD_VAR 0 2
55412: PPUSH
55413: LD_VAR 0 4
55417: PPUSH
55418: LD_VAR 0 5
55422: PPUSH
55423: CALL 57194 0 3
55427: GO 55430
55429: POP
// end ;
55430: LD_VAR 0 12
55434: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55435: LD_INT 0
55437: PPUSH
55438: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55439: LD_VAR 0 1
55443: PUSH
55444: LD_INT 1
55446: LESS
55447: PUSH
55448: LD_VAR 0 1
55452: PUSH
55453: LD_INT 3
55455: GREATER
55456: OR
55457: PUSH
55458: LD_VAR 0 5
55462: PPUSH
55463: LD_VAR 0 6
55467: PPUSH
55468: CALL_OW 428
55472: OR
55473: IFFALSE 55477
// exit ;
55475: GO 56197
// uc_side := your_side ;
55477: LD_ADDR_OWVAR 20
55481: PUSH
55482: LD_OWVAR 2
55486: ST_TO_ADDR
// uc_nation := nation ;
55487: LD_ADDR_OWVAR 21
55491: PUSH
55492: LD_VAR 0 1
55496: ST_TO_ADDR
// bc_level = 1 ;
55497: LD_ADDR_OWVAR 43
55501: PUSH
55502: LD_INT 1
55504: ST_TO_ADDR
// case btype of 1 :
55505: LD_VAR 0 2
55509: PUSH
55510: LD_INT 1
55512: DOUBLE
55513: EQUAL
55514: IFTRUE 55518
55516: GO 55529
55518: POP
// bc_type := b_depot ; 2 :
55519: LD_ADDR_OWVAR 42
55523: PUSH
55524: LD_INT 0
55526: ST_TO_ADDR
55527: GO 56141
55529: LD_INT 2
55531: DOUBLE
55532: EQUAL
55533: IFTRUE 55537
55535: GO 55548
55537: POP
// bc_type := b_warehouse ; 3 :
55538: LD_ADDR_OWVAR 42
55542: PUSH
55543: LD_INT 1
55545: ST_TO_ADDR
55546: GO 56141
55548: LD_INT 3
55550: DOUBLE
55551: EQUAL
55552: IFTRUE 55556
55554: GO 55567
55556: POP
// bc_type := b_lab ; 4 .. 9 :
55557: LD_ADDR_OWVAR 42
55561: PUSH
55562: LD_INT 6
55564: ST_TO_ADDR
55565: GO 56141
55567: LD_INT 4
55569: DOUBLE
55570: GREATEREQUAL
55571: IFFALSE 55579
55573: LD_INT 9
55575: DOUBLE
55576: LESSEQUAL
55577: IFTRUE 55581
55579: GO 55633
55581: POP
// begin bc_type := b_lab_half ;
55582: LD_ADDR_OWVAR 42
55586: PUSH
55587: LD_INT 7
55589: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
55590: LD_ADDR_OWVAR 44
55594: PUSH
55595: LD_INT 10
55597: PUSH
55598: LD_INT 11
55600: PUSH
55601: LD_INT 12
55603: PUSH
55604: LD_INT 15
55606: PUSH
55607: LD_INT 14
55609: PUSH
55610: LD_INT 13
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: LIST
55617: LIST
55618: LIST
55619: LIST
55620: PUSH
55621: LD_VAR 0 2
55625: PUSH
55626: LD_INT 3
55628: MINUS
55629: ARRAY
55630: ST_TO_ADDR
// end ; 10 .. 13 :
55631: GO 56141
55633: LD_INT 10
55635: DOUBLE
55636: GREATEREQUAL
55637: IFFALSE 55645
55639: LD_INT 13
55641: DOUBLE
55642: LESSEQUAL
55643: IFTRUE 55647
55645: GO 55724
55647: POP
// begin bc_type := b_lab_full ;
55648: LD_ADDR_OWVAR 42
55652: PUSH
55653: LD_INT 8
55655: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
55656: LD_ADDR_OWVAR 44
55660: PUSH
55661: LD_INT 10
55663: PUSH
55664: LD_INT 12
55666: PUSH
55667: LD_INT 14
55669: PUSH
55670: LD_INT 13
55672: PUSH
55673: EMPTY
55674: LIST
55675: LIST
55676: LIST
55677: LIST
55678: PUSH
55679: LD_VAR 0 2
55683: PUSH
55684: LD_INT 9
55686: MINUS
55687: ARRAY
55688: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
55689: LD_ADDR_OWVAR 45
55693: PUSH
55694: LD_INT 11
55696: PUSH
55697: LD_INT 15
55699: PUSH
55700: LD_INT 12
55702: PUSH
55703: LD_INT 15
55705: PUSH
55706: EMPTY
55707: LIST
55708: LIST
55709: LIST
55710: LIST
55711: PUSH
55712: LD_VAR 0 2
55716: PUSH
55717: LD_INT 9
55719: MINUS
55720: ARRAY
55721: ST_TO_ADDR
// end ; 14 :
55722: GO 56141
55724: LD_INT 14
55726: DOUBLE
55727: EQUAL
55728: IFTRUE 55732
55730: GO 55743
55732: POP
// bc_type := b_workshop ; 15 :
55733: LD_ADDR_OWVAR 42
55737: PUSH
55738: LD_INT 2
55740: ST_TO_ADDR
55741: GO 56141
55743: LD_INT 15
55745: DOUBLE
55746: EQUAL
55747: IFTRUE 55751
55749: GO 55762
55751: POP
// bc_type := b_factory ; 16 :
55752: LD_ADDR_OWVAR 42
55756: PUSH
55757: LD_INT 3
55759: ST_TO_ADDR
55760: GO 56141
55762: LD_INT 16
55764: DOUBLE
55765: EQUAL
55766: IFTRUE 55770
55768: GO 55781
55770: POP
// bc_type := b_ext_gun ; 17 :
55771: LD_ADDR_OWVAR 42
55775: PUSH
55776: LD_INT 17
55778: ST_TO_ADDR
55779: GO 56141
55781: LD_INT 17
55783: DOUBLE
55784: EQUAL
55785: IFTRUE 55789
55787: GO 55817
55789: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
55790: LD_ADDR_OWVAR 42
55794: PUSH
55795: LD_INT 19
55797: PUSH
55798: LD_INT 23
55800: PUSH
55801: LD_INT 19
55803: PUSH
55804: EMPTY
55805: LIST
55806: LIST
55807: LIST
55808: PUSH
55809: LD_VAR 0 1
55813: ARRAY
55814: ST_TO_ADDR
55815: GO 56141
55817: LD_INT 18
55819: DOUBLE
55820: EQUAL
55821: IFTRUE 55825
55823: GO 55836
55825: POP
// bc_type := b_ext_radar ; 19 :
55826: LD_ADDR_OWVAR 42
55830: PUSH
55831: LD_INT 20
55833: ST_TO_ADDR
55834: GO 56141
55836: LD_INT 19
55838: DOUBLE
55839: EQUAL
55840: IFTRUE 55844
55842: GO 55855
55844: POP
// bc_type := b_ext_radio ; 20 :
55845: LD_ADDR_OWVAR 42
55849: PUSH
55850: LD_INT 22
55852: ST_TO_ADDR
55853: GO 56141
55855: LD_INT 20
55857: DOUBLE
55858: EQUAL
55859: IFTRUE 55863
55861: GO 55874
55863: POP
// bc_type := b_ext_siberium ; 21 :
55864: LD_ADDR_OWVAR 42
55868: PUSH
55869: LD_INT 21
55871: ST_TO_ADDR
55872: GO 56141
55874: LD_INT 21
55876: DOUBLE
55877: EQUAL
55878: IFTRUE 55882
55880: GO 55893
55882: POP
// bc_type := b_ext_computer ; 22 :
55883: LD_ADDR_OWVAR 42
55887: PUSH
55888: LD_INT 24
55890: ST_TO_ADDR
55891: GO 56141
55893: LD_INT 22
55895: DOUBLE
55896: EQUAL
55897: IFTRUE 55901
55899: GO 55912
55901: POP
// bc_type := b_ext_track ; 23 :
55902: LD_ADDR_OWVAR 42
55906: PUSH
55907: LD_INT 16
55909: ST_TO_ADDR
55910: GO 56141
55912: LD_INT 23
55914: DOUBLE
55915: EQUAL
55916: IFTRUE 55920
55918: GO 55931
55920: POP
// bc_type := b_ext_laser ; 24 :
55921: LD_ADDR_OWVAR 42
55925: PUSH
55926: LD_INT 25
55928: ST_TO_ADDR
55929: GO 56141
55931: LD_INT 24
55933: DOUBLE
55934: EQUAL
55935: IFTRUE 55939
55937: GO 55950
55939: POP
// bc_type := b_control_tower ; 25 :
55940: LD_ADDR_OWVAR 42
55944: PUSH
55945: LD_INT 36
55947: ST_TO_ADDR
55948: GO 56141
55950: LD_INT 25
55952: DOUBLE
55953: EQUAL
55954: IFTRUE 55958
55956: GO 55969
55958: POP
// bc_type := b_breastwork ; 26 :
55959: LD_ADDR_OWVAR 42
55963: PUSH
55964: LD_INT 31
55966: ST_TO_ADDR
55967: GO 56141
55969: LD_INT 26
55971: DOUBLE
55972: EQUAL
55973: IFTRUE 55977
55975: GO 55988
55977: POP
// bc_type := b_bunker ; 27 :
55978: LD_ADDR_OWVAR 42
55982: PUSH
55983: LD_INT 32
55985: ST_TO_ADDR
55986: GO 56141
55988: LD_INT 27
55990: DOUBLE
55991: EQUAL
55992: IFTRUE 55996
55994: GO 56007
55996: POP
// bc_type := b_turret ; 28 :
55997: LD_ADDR_OWVAR 42
56001: PUSH
56002: LD_INT 33
56004: ST_TO_ADDR
56005: GO 56141
56007: LD_INT 28
56009: DOUBLE
56010: EQUAL
56011: IFTRUE 56015
56013: GO 56026
56015: POP
// bc_type := b_armoury ; 29 :
56016: LD_ADDR_OWVAR 42
56020: PUSH
56021: LD_INT 4
56023: ST_TO_ADDR
56024: GO 56141
56026: LD_INT 29
56028: DOUBLE
56029: EQUAL
56030: IFTRUE 56034
56032: GO 56045
56034: POP
// bc_type := b_barracks ; 30 :
56035: LD_ADDR_OWVAR 42
56039: PUSH
56040: LD_INT 5
56042: ST_TO_ADDR
56043: GO 56141
56045: LD_INT 30
56047: DOUBLE
56048: EQUAL
56049: IFTRUE 56053
56051: GO 56064
56053: POP
// bc_type := b_solar_power ; 31 :
56054: LD_ADDR_OWVAR 42
56058: PUSH
56059: LD_INT 27
56061: ST_TO_ADDR
56062: GO 56141
56064: LD_INT 31
56066: DOUBLE
56067: EQUAL
56068: IFTRUE 56072
56070: GO 56083
56072: POP
// bc_type := b_oil_power ; 32 :
56073: LD_ADDR_OWVAR 42
56077: PUSH
56078: LD_INT 26
56080: ST_TO_ADDR
56081: GO 56141
56083: LD_INT 32
56085: DOUBLE
56086: EQUAL
56087: IFTRUE 56091
56089: GO 56102
56091: POP
// bc_type := b_siberite_power ; 33 :
56092: LD_ADDR_OWVAR 42
56096: PUSH
56097: LD_INT 28
56099: ST_TO_ADDR
56100: GO 56141
56102: LD_INT 33
56104: DOUBLE
56105: EQUAL
56106: IFTRUE 56110
56108: GO 56121
56110: POP
// bc_type := b_oil_mine ; 34 :
56111: LD_ADDR_OWVAR 42
56115: PUSH
56116: LD_INT 29
56118: ST_TO_ADDR
56119: GO 56141
56121: LD_INT 34
56123: DOUBLE
56124: EQUAL
56125: IFTRUE 56129
56127: GO 56140
56129: POP
// bc_type := b_siberite_mine ; end ;
56130: LD_ADDR_OWVAR 42
56134: PUSH
56135: LD_INT 30
56137: ST_TO_ADDR
56138: GO 56141
56140: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56141: LD_ADDR_VAR 0 8
56145: PUSH
56146: LD_VAR 0 5
56150: PPUSH
56151: LD_VAR 0 6
56155: PPUSH
56156: LD_VAR 0 3
56160: PPUSH
56161: CALL_OW 47
56165: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56166: LD_OWVAR 42
56170: PUSH
56171: LD_INT 32
56173: PUSH
56174: LD_INT 33
56176: PUSH
56177: EMPTY
56178: LIST
56179: LIST
56180: IN
56181: IFFALSE 56197
// PlaceWeaponTurret ( b , weapon ) ;
56183: LD_VAR 0 8
56187: PPUSH
56188: LD_VAR 0 4
56192: PPUSH
56193: CALL_OW 431
// end ;
56197: LD_VAR 0 7
56201: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56202: LD_INT 0
56204: PPUSH
56205: PPUSH
56206: PPUSH
56207: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56208: LD_ADDR_VAR 0 4
56212: PUSH
56213: LD_INT 22
56215: PUSH
56216: LD_OWVAR 2
56220: PUSH
56221: EMPTY
56222: LIST
56223: LIST
56224: PUSH
56225: LD_INT 2
56227: PUSH
56228: LD_INT 30
56230: PUSH
56231: LD_INT 0
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: PUSH
56238: LD_INT 30
56240: PUSH
56241: LD_INT 1
56243: PUSH
56244: EMPTY
56245: LIST
56246: LIST
56247: PUSH
56248: EMPTY
56249: LIST
56250: LIST
56251: LIST
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: PPUSH
56257: CALL_OW 69
56261: ST_TO_ADDR
// if not tmp then
56262: LD_VAR 0 4
56266: NOT
56267: IFFALSE 56271
// exit ;
56269: GO 56330
// for i in tmp do
56271: LD_ADDR_VAR 0 2
56275: PUSH
56276: LD_VAR 0 4
56280: PUSH
56281: FOR_IN
56282: IFFALSE 56328
// for j = 1 to 3 do
56284: LD_ADDR_VAR 0 3
56288: PUSH
56289: DOUBLE
56290: LD_INT 1
56292: DEC
56293: ST_TO_ADDR
56294: LD_INT 3
56296: PUSH
56297: FOR_TO
56298: IFFALSE 56324
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56300: LD_VAR 0 2
56304: PPUSH
56305: CALL_OW 274
56309: PPUSH
56310: LD_VAR 0 3
56314: PPUSH
56315: LD_INT 99999
56317: PPUSH
56318: CALL_OW 277
56322: GO 56297
56324: POP
56325: POP
56326: GO 56281
56328: POP
56329: POP
// end ;
56330: LD_VAR 0 1
56334: RET
// export function hHackSetLevel10 ; var i , j ; begin
56335: LD_INT 0
56337: PPUSH
56338: PPUSH
56339: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56340: LD_ADDR_VAR 0 2
56344: PUSH
56345: LD_INT 21
56347: PUSH
56348: LD_INT 1
56350: PUSH
56351: EMPTY
56352: LIST
56353: LIST
56354: PPUSH
56355: CALL_OW 69
56359: PUSH
56360: FOR_IN
56361: IFFALSE 56413
// if IsSelected ( i ) then
56363: LD_VAR 0 2
56367: PPUSH
56368: CALL_OW 306
56372: IFFALSE 56411
// begin for j := 1 to 4 do
56374: LD_ADDR_VAR 0 3
56378: PUSH
56379: DOUBLE
56380: LD_INT 1
56382: DEC
56383: ST_TO_ADDR
56384: LD_INT 4
56386: PUSH
56387: FOR_TO
56388: IFFALSE 56409
// SetSkill ( i , j , 10 ) ;
56390: LD_VAR 0 2
56394: PPUSH
56395: LD_VAR 0 3
56399: PPUSH
56400: LD_INT 10
56402: PPUSH
56403: CALL_OW 237
56407: GO 56387
56409: POP
56410: POP
// end ;
56411: GO 56360
56413: POP
56414: POP
// end ;
56415: LD_VAR 0 1
56419: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56420: LD_INT 0
56422: PPUSH
56423: PPUSH
56424: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56425: LD_ADDR_VAR 0 2
56429: PUSH
56430: LD_INT 22
56432: PUSH
56433: LD_OWVAR 2
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: PUSH
56442: LD_INT 21
56444: PUSH
56445: LD_INT 1
56447: PUSH
56448: EMPTY
56449: LIST
56450: LIST
56451: PUSH
56452: EMPTY
56453: LIST
56454: LIST
56455: PPUSH
56456: CALL_OW 69
56460: PUSH
56461: FOR_IN
56462: IFFALSE 56503
// begin for j := 1 to 4 do
56464: LD_ADDR_VAR 0 3
56468: PUSH
56469: DOUBLE
56470: LD_INT 1
56472: DEC
56473: ST_TO_ADDR
56474: LD_INT 4
56476: PUSH
56477: FOR_TO
56478: IFFALSE 56499
// SetSkill ( i , j , 10 ) ;
56480: LD_VAR 0 2
56484: PPUSH
56485: LD_VAR 0 3
56489: PPUSH
56490: LD_INT 10
56492: PPUSH
56493: CALL_OW 237
56497: GO 56477
56499: POP
56500: POP
// end ;
56501: GO 56461
56503: POP
56504: POP
// end ;
56505: LD_VAR 0 1
56509: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
56510: LD_INT 0
56512: PPUSH
// uc_side := your_side ;
56513: LD_ADDR_OWVAR 20
56517: PUSH
56518: LD_OWVAR 2
56522: ST_TO_ADDR
// uc_nation := nation ;
56523: LD_ADDR_OWVAR 21
56527: PUSH
56528: LD_VAR 0 1
56532: ST_TO_ADDR
// InitHc ;
56533: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
56537: LD_INT 0
56539: PPUSH
56540: LD_VAR 0 2
56544: PPUSH
56545: LD_VAR 0 3
56549: PPUSH
56550: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
56554: LD_VAR 0 4
56558: PPUSH
56559: LD_VAR 0 5
56563: PPUSH
56564: CALL_OW 428
56568: PUSH
56569: LD_INT 0
56571: EQUAL
56572: IFFALSE 56596
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
56574: CALL_OW 44
56578: PPUSH
56579: LD_VAR 0 4
56583: PPUSH
56584: LD_VAR 0 5
56588: PPUSH
56589: LD_INT 1
56591: PPUSH
56592: CALL_OW 48
// end ;
56596: LD_VAR 0 6
56600: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
56601: LD_INT 0
56603: PPUSH
56604: PPUSH
// uc_side := your_side ;
56605: LD_ADDR_OWVAR 20
56609: PUSH
56610: LD_OWVAR 2
56614: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
56615: LD_VAR 0 1
56619: PUSH
56620: LD_INT 1
56622: PUSH
56623: LD_INT 2
56625: PUSH
56626: LD_INT 3
56628: PUSH
56629: LD_INT 4
56631: PUSH
56632: LD_INT 5
56634: PUSH
56635: EMPTY
56636: LIST
56637: LIST
56638: LIST
56639: LIST
56640: LIST
56641: IN
56642: IFFALSE 56654
// uc_nation := nation_american else
56644: LD_ADDR_OWVAR 21
56648: PUSH
56649: LD_INT 1
56651: ST_TO_ADDR
56652: GO 56697
// if chassis in [ 11 , 12 , 13 , 14 ] then
56654: LD_VAR 0 1
56658: PUSH
56659: LD_INT 11
56661: PUSH
56662: LD_INT 12
56664: PUSH
56665: LD_INT 13
56667: PUSH
56668: LD_INT 14
56670: PUSH
56671: EMPTY
56672: LIST
56673: LIST
56674: LIST
56675: LIST
56676: IN
56677: IFFALSE 56689
// uc_nation := nation_arabian else
56679: LD_ADDR_OWVAR 21
56683: PUSH
56684: LD_INT 2
56686: ST_TO_ADDR
56687: GO 56697
// uc_nation := nation_russian ;
56689: LD_ADDR_OWVAR 21
56693: PUSH
56694: LD_INT 3
56696: ST_TO_ADDR
// vc_chassis := chassis ;
56697: LD_ADDR_OWVAR 37
56701: PUSH
56702: LD_VAR 0 1
56706: ST_TO_ADDR
// vc_engine := engine ;
56707: LD_ADDR_OWVAR 39
56711: PUSH
56712: LD_VAR 0 2
56716: ST_TO_ADDR
// vc_control := control ;
56717: LD_ADDR_OWVAR 38
56721: PUSH
56722: LD_VAR 0 3
56726: ST_TO_ADDR
// vc_weapon := weapon ;
56727: LD_ADDR_OWVAR 40
56731: PUSH
56732: LD_VAR 0 4
56736: ST_TO_ADDR
// un := CreateVehicle ;
56737: LD_ADDR_VAR 0 8
56741: PUSH
56742: CALL_OW 45
56746: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
56747: LD_VAR 0 8
56751: PPUSH
56752: LD_INT 0
56754: PPUSH
56755: LD_INT 5
56757: PPUSH
56758: CALL_OW 12
56762: PPUSH
56763: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
56767: LD_VAR 0 8
56771: PPUSH
56772: LD_VAR 0 5
56776: PPUSH
56777: LD_VAR 0 6
56781: PPUSH
56782: LD_INT 1
56784: PPUSH
56785: CALL_OW 48
// end ;
56789: LD_VAR 0 7
56793: RET
// export hInvincible ; every 1 do
56794: GO 56796
56796: DISABLE
// hInvincible := [ ] ;
56797: LD_ADDR_EXP 149
56801: PUSH
56802: EMPTY
56803: ST_TO_ADDR
56804: END
// every 10 do var i ;
56805: GO 56807
56807: DISABLE
56808: LD_INT 0
56810: PPUSH
// begin enable ;
56811: ENABLE
// if not hInvincible then
56812: LD_EXP 149
56816: NOT
56817: IFFALSE 56821
// exit ;
56819: GO 56865
// for i in hInvincible do
56821: LD_ADDR_VAR 0 1
56825: PUSH
56826: LD_EXP 149
56830: PUSH
56831: FOR_IN
56832: IFFALSE 56863
// if GetLives ( i ) < 1000 then
56834: LD_VAR 0 1
56838: PPUSH
56839: CALL_OW 256
56843: PUSH
56844: LD_INT 1000
56846: LESS
56847: IFFALSE 56861
// SetLives ( i , 1000 ) ;
56849: LD_VAR 0 1
56853: PPUSH
56854: LD_INT 1000
56856: PPUSH
56857: CALL_OW 234
56861: GO 56831
56863: POP
56864: POP
// end ;
56865: PPOPN 1
56867: END
// export function hHackInvincible ; var i ; begin
56868: LD_INT 0
56870: PPUSH
56871: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
56872: LD_ADDR_VAR 0 2
56876: PUSH
56877: LD_INT 2
56879: PUSH
56880: LD_INT 21
56882: PUSH
56883: LD_INT 1
56885: PUSH
56886: EMPTY
56887: LIST
56888: LIST
56889: PUSH
56890: LD_INT 21
56892: PUSH
56893: LD_INT 2
56895: PUSH
56896: EMPTY
56897: LIST
56898: LIST
56899: PUSH
56900: EMPTY
56901: LIST
56902: LIST
56903: LIST
56904: PPUSH
56905: CALL_OW 69
56909: PUSH
56910: FOR_IN
56911: IFFALSE 56972
// if IsSelected ( i ) then
56913: LD_VAR 0 2
56917: PPUSH
56918: CALL_OW 306
56922: IFFALSE 56970
// begin if i in hInvincible then
56924: LD_VAR 0 2
56928: PUSH
56929: LD_EXP 149
56933: IN
56934: IFFALSE 56954
// hInvincible := hInvincible diff i else
56936: LD_ADDR_EXP 149
56940: PUSH
56941: LD_EXP 149
56945: PUSH
56946: LD_VAR 0 2
56950: DIFF
56951: ST_TO_ADDR
56952: GO 56970
// hInvincible := hInvincible union i ;
56954: LD_ADDR_EXP 149
56958: PUSH
56959: LD_EXP 149
56963: PUSH
56964: LD_VAR 0 2
56968: UNION
56969: ST_TO_ADDR
// end ;
56970: GO 56910
56972: POP
56973: POP
// end ;
56974: LD_VAR 0 1
56978: RET
// export function hHackInvisible ; var i , j ; begin
56979: LD_INT 0
56981: PPUSH
56982: PPUSH
56983: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56984: LD_ADDR_VAR 0 2
56988: PUSH
56989: LD_INT 21
56991: PUSH
56992: LD_INT 1
56994: PUSH
56995: EMPTY
56996: LIST
56997: LIST
56998: PPUSH
56999: CALL_OW 69
57003: PUSH
57004: FOR_IN
57005: IFFALSE 57029
// if IsSelected ( i ) then
57007: LD_VAR 0 2
57011: PPUSH
57012: CALL_OW 306
57016: IFFALSE 57027
// ComForceInvisible ( i ) ;
57018: LD_VAR 0 2
57022: PPUSH
57023: CALL_OW 496
57027: GO 57004
57029: POP
57030: POP
// end ;
57031: LD_VAR 0 1
57035: RET
// export function hHackChangeYourSide ; begin
57036: LD_INT 0
57038: PPUSH
// if your_side = 8 then
57039: LD_OWVAR 2
57043: PUSH
57044: LD_INT 8
57046: EQUAL
57047: IFFALSE 57059
// your_side := 0 else
57049: LD_ADDR_OWVAR 2
57053: PUSH
57054: LD_INT 0
57056: ST_TO_ADDR
57057: GO 57073
// your_side := your_side + 1 ;
57059: LD_ADDR_OWVAR 2
57063: PUSH
57064: LD_OWVAR 2
57068: PUSH
57069: LD_INT 1
57071: PLUS
57072: ST_TO_ADDR
// end ;
57073: LD_VAR 0 1
57077: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57078: LD_INT 0
57080: PPUSH
57081: PPUSH
57082: PPUSH
// for i in all_units do
57083: LD_ADDR_VAR 0 2
57087: PUSH
57088: LD_OWVAR 3
57092: PUSH
57093: FOR_IN
57094: IFFALSE 57172
// if IsSelected ( i ) then
57096: LD_VAR 0 2
57100: PPUSH
57101: CALL_OW 306
57105: IFFALSE 57170
// begin j := GetSide ( i ) ;
57107: LD_ADDR_VAR 0 3
57111: PUSH
57112: LD_VAR 0 2
57116: PPUSH
57117: CALL_OW 255
57121: ST_TO_ADDR
// if j = 8 then
57122: LD_VAR 0 3
57126: PUSH
57127: LD_INT 8
57129: EQUAL
57130: IFFALSE 57142
// j := 0 else
57132: LD_ADDR_VAR 0 3
57136: PUSH
57137: LD_INT 0
57139: ST_TO_ADDR
57140: GO 57156
// j := j + 1 ;
57142: LD_ADDR_VAR 0 3
57146: PUSH
57147: LD_VAR 0 3
57151: PUSH
57152: LD_INT 1
57154: PLUS
57155: ST_TO_ADDR
// SetSide ( i , j ) ;
57156: LD_VAR 0 2
57160: PPUSH
57161: LD_VAR 0 3
57165: PPUSH
57166: CALL_OW 235
// end ;
57170: GO 57093
57172: POP
57173: POP
// end ;
57174: LD_VAR 0 1
57178: RET
// export function hHackFog ; begin
57179: LD_INT 0
57181: PPUSH
// FogOff ( true ) ;
57182: LD_INT 1
57184: PPUSH
57185: CALL_OW 344
// end ;
57189: LD_VAR 0 1
57193: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57194: LD_INT 0
57196: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57197: LD_VAR 0 1
57201: PPUSH
57202: LD_VAR 0 2
57206: PPUSH
57207: LD_VAR 0 3
57211: PPUSH
57212: LD_INT 1
57214: PPUSH
57215: LD_INT 1
57217: PPUSH
57218: CALL_OW 483
// CenterOnXY ( x , y ) ;
57222: LD_VAR 0 2
57226: PPUSH
57227: LD_VAR 0 3
57231: PPUSH
57232: CALL_OW 84
// end ; end_of_file
57236: LD_VAR 0 4
57240: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
57241: LD_INT 0
57243: PPUSH
57244: PPUSH
57245: PPUSH
57246: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
57247: LD_VAR 0 1
57251: PPUSH
57252: CALL_OW 264
57256: PUSH
57257: LD_EXP 77
57261: EQUAL
57262: IFFALSE 57334
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
57264: LD_INT 68
57266: PPUSH
57267: LD_VAR 0 1
57271: PPUSH
57272: CALL_OW 255
57276: PPUSH
57277: CALL_OW 321
57281: PUSH
57282: LD_INT 2
57284: EQUAL
57285: IFFALSE 57297
// eff := 70 else
57287: LD_ADDR_VAR 0 4
57291: PUSH
57292: LD_INT 70
57294: ST_TO_ADDR
57295: GO 57305
// eff := 30 ;
57297: LD_ADDR_VAR 0 4
57301: PUSH
57302: LD_INT 30
57304: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
57305: LD_VAR 0 1
57309: PPUSH
57310: CALL_OW 250
57314: PPUSH
57315: LD_VAR 0 1
57319: PPUSH
57320: CALL_OW 251
57324: PPUSH
57325: LD_VAR 0 4
57329: PPUSH
57330: CALL_OW 495
// end ; end ;
57334: LD_VAR 0 2
57338: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
57339: LD_INT 0
57341: PPUSH
// end ;
57342: LD_VAR 0 4
57346: RET
// export function SOS_Command ( cmd ) ; begin
57347: LD_INT 0
57349: PPUSH
// end ;
57350: LD_VAR 0 2
57354: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
57355: LD_INT 0
57357: PPUSH
// end ;
57358: LD_VAR 0 6
57362: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
57363: LD_INT 0
57365: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
57366: LD_VAR 0 1
57370: PUSH
57371: LD_INT 250
57373: EQUAL
57374: PUSH
57375: LD_VAR 0 2
57379: PPUSH
57380: CALL_OW 264
57384: PUSH
57385: LD_EXP 80
57389: EQUAL
57390: AND
57391: IFFALSE 57412
// MinerPlaceMine ( unit , x , y ) ;
57393: LD_VAR 0 2
57397: PPUSH
57398: LD_VAR 0 4
57402: PPUSH
57403: LD_VAR 0 5
57407: PPUSH
57408: CALL 59761 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
57412: LD_VAR 0 1
57416: PUSH
57417: LD_INT 251
57419: EQUAL
57420: PUSH
57421: LD_VAR 0 2
57425: PPUSH
57426: CALL_OW 264
57430: PUSH
57431: LD_EXP 80
57435: EQUAL
57436: AND
57437: IFFALSE 57458
// MinerDetonateMine ( unit , x , y ) ;
57439: LD_VAR 0 2
57443: PPUSH
57444: LD_VAR 0 4
57448: PPUSH
57449: LD_VAR 0 5
57453: PPUSH
57454: CALL 60038 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
57458: LD_VAR 0 1
57462: PUSH
57463: LD_INT 252
57465: EQUAL
57466: PUSH
57467: LD_VAR 0 2
57471: PPUSH
57472: CALL_OW 264
57476: PUSH
57477: LD_EXP 80
57481: EQUAL
57482: AND
57483: IFFALSE 57504
// MinerCreateMinefield ( unit , x , y ) ;
57485: LD_VAR 0 2
57489: PPUSH
57490: LD_VAR 0 4
57494: PPUSH
57495: LD_VAR 0 5
57499: PPUSH
57500: CALL 60455 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
57504: LD_VAR 0 1
57508: PUSH
57509: LD_INT 253
57511: EQUAL
57512: PUSH
57513: LD_VAR 0 2
57517: PPUSH
57518: CALL_OW 257
57522: PUSH
57523: LD_INT 5
57525: EQUAL
57526: AND
57527: IFFALSE 57548
// ComBinocular ( unit , x , y ) ;
57529: LD_VAR 0 2
57533: PPUSH
57534: LD_VAR 0 4
57538: PPUSH
57539: LD_VAR 0 5
57543: PPUSH
57544: CALL 60826 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
57548: LD_VAR 0 1
57552: PUSH
57553: LD_INT 254
57555: EQUAL
57556: PUSH
57557: LD_VAR 0 2
57561: PPUSH
57562: CALL_OW 264
57566: PUSH
57567: LD_EXP 75
57571: EQUAL
57572: AND
57573: PUSH
57574: LD_VAR 0 3
57578: PPUSH
57579: CALL_OW 263
57583: PUSH
57584: LD_INT 3
57586: EQUAL
57587: AND
57588: IFFALSE 57604
// HackDestroyVehicle ( unit , selectedUnit ) ;
57590: LD_VAR 0 2
57594: PPUSH
57595: LD_VAR 0 3
57599: PPUSH
57600: CALL 59121 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
57604: LD_VAR 0 1
57608: PUSH
57609: LD_INT 255
57611: EQUAL
57612: PUSH
57613: LD_VAR 0 2
57617: PPUSH
57618: CALL_OW 264
57622: PUSH
57623: LD_INT 14
57625: PUSH
57626: LD_INT 53
57628: PUSH
57629: EMPTY
57630: LIST
57631: LIST
57632: IN
57633: AND
57634: PUSH
57635: LD_VAR 0 4
57639: PPUSH
57640: LD_VAR 0 5
57644: PPUSH
57645: CALL_OW 488
57649: AND
57650: IFFALSE 57674
// CutTreeXYR ( unit , x , y , 12 ) ;
57652: LD_VAR 0 2
57656: PPUSH
57657: LD_VAR 0 4
57661: PPUSH
57662: LD_VAR 0 5
57666: PPUSH
57667: LD_INT 12
57669: PPUSH
57670: CALL 57687 0 4
// end ;
57674: LD_VAR 0 6
57678: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
57679: LD_INT 0
57681: PPUSH
// end ;
57682: LD_VAR 0 4
57686: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
57687: LD_INT 0
57689: PPUSH
57690: PPUSH
57691: PPUSH
57692: PPUSH
57693: PPUSH
57694: PPUSH
57695: PPUSH
57696: PPUSH
57697: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
57698: LD_VAR 0 1
57702: NOT
57703: PUSH
57704: LD_VAR 0 2
57708: PPUSH
57709: LD_VAR 0 3
57713: PPUSH
57714: CALL_OW 488
57718: NOT
57719: OR
57720: PUSH
57721: LD_VAR 0 4
57725: NOT
57726: OR
57727: IFFALSE 57731
// exit ;
57729: GO 58071
// list := [ ] ;
57731: LD_ADDR_VAR 0 13
57735: PUSH
57736: EMPTY
57737: ST_TO_ADDR
// if x - r < 0 then
57738: LD_VAR 0 2
57742: PUSH
57743: LD_VAR 0 4
57747: MINUS
57748: PUSH
57749: LD_INT 0
57751: LESS
57752: IFFALSE 57764
// min_x := 0 else
57754: LD_ADDR_VAR 0 7
57758: PUSH
57759: LD_INT 0
57761: ST_TO_ADDR
57762: GO 57780
// min_x := x - r ;
57764: LD_ADDR_VAR 0 7
57768: PUSH
57769: LD_VAR 0 2
57773: PUSH
57774: LD_VAR 0 4
57778: MINUS
57779: ST_TO_ADDR
// if y - r < 0 then
57780: LD_VAR 0 3
57784: PUSH
57785: LD_VAR 0 4
57789: MINUS
57790: PUSH
57791: LD_INT 0
57793: LESS
57794: IFFALSE 57806
// min_y := 0 else
57796: LD_ADDR_VAR 0 8
57800: PUSH
57801: LD_INT 0
57803: ST_TO_ADDR
57804: GO 57822
// min_y := y - r ;
57806: LD_ADDR_VAR 0 8
57810: PUSH
57811: LD_VAR 0 3
57815: PUSH
57816: LD_VAR 0 4
57820: MINUS
57821: ST_TO_ADDR
// max_x := x + r ;
57822: LD_ADDR_VAR 0 9
57826: PUSH
57827: LD_VAR 0 2
57831: PUSH
57832: LD_VAR 0 4
57836: PLUS
57837: ST_TO_ADDR
// max_y := y + r ;
57838: LD_ADDR_VAR 0 10
57842: PUSH
57843: LD_VAR 0 3
57847: PUSH
57848: LD_VAR 0 4
57852: PLUS
57853: ST_TO_ADDR
// for _x = min_x to max_x do
57854: LD_ADDR_VAR 0 11
57858: PUSH
57859: DOUBLE
57860: LD_VAR 0 7
57864: DEC
57865: ST_TO_ADDR
57866: LD_VAR 0 9
57870: PUSH
57871: FOR_TO
57872: IFFALSE 57989
// for _y = min_y to max_y do
57874: LD_ADDR_VAR 0 12
57878: PUSH
57879: DOUBLE
57880: LD_VAR 0 8
57884: DEC
57885: ST_TO_ADDR
57886: LD_VAR 0 10
57890: PUSH
57891: FOR_TO
57892: IFFALSE 57985
// begin if not ValidHex ( _x , _y ) then
57894: LD_VAR 0 11
57898: PPUSH
57899: LD_VAR 0 12
57903: PPUSH
57904: CALL_OW 488
57908: NOT
57909: IFFALSE 57913
// continue ;
57911: GO 57891
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57913: LD_VAR 0 11
57917: PPUSH
57918: LD_VAR 0 12
57922: PPUSH
57923: CALL_OW 351
57927: PUSH
57928: LD_VAR 0 11
57932: PPUSH
57933: LD_VAR 0 12
57937: PPUSH
57938: CALL_OW 554
57942: AND
57943: IFFALSE 57983
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57945: LD_ADDR_VAR 0 13
57949: PUSH
57950: LD_VAR 0 13
57954: PPUSH
57955: LD_VAR 0 13
57959: PUSH
57960: LD_INT 1
57962: PLUS
57963: PPUSH
57964: LD_VAR 0 11
57968: PUSH
57969: LD_VAR 0 12
57973: PUSH
57974: EMPTY
57975: LIST
57976: LIST
57977: PPUSH
57978: CALL_OW 2
57982: ST_TO_ADDR
// end ;
57983: GO 57891
57985: POP
57986: POP
57987: GO 57871
57989: POP
57990: POP
// if not list then
57991: LD_VAR 0 13
57995: NOT
57996: IFFALSE 58000
// exit ;
57998: GO 58071
// for i in list do
58000: LD_ADDR_VAR 0 6
58004: PUSH
58005: LD_VAR 0 13
58009: PUSH
58010: FOR_IN
58011: IFFALSE 58069
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
58013: LD_VAR 0 1
58017: PPUSH
58018: LD_STRING M
58020: PUSH
58021: LD_VAR 0 6
58025: PUSH
58026: LD_INT 1
58028: ARRAY
58029: PUSH
58030: LD_VAR 0 6
58034: PUSH
58035: LD_INT 2
58037: ARRAY
58038: PUSH
58039: LD_INT 0
58041: PUSH
58042: LD_INT 0
58044: PUSH
58045: LD_INT 0
58047: PUSH
58048: LD_INT 0
58050: PUSH
58051: EMPTY
58052: LIST
58053: LIST
58054: LIST
58055: LIST
58056: LIST
58057: LIST
58058: LIST
58059: PUSH
58060: EMPTY
58061: LIST
58062: PPUSH
58063: CALL_OW 447
58067: GO 58010
58069: POP
58070: POP
// end ;
58071: LD_VAR 0 5
58075: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
58076: LD_EXP 152
58080: NOT
58081: IFFALSE 58131
58083: GO 58085
58085: DISABLE
// begin initHack := true ;
58086: LD_ADDR_EXP 152
58090: PUSH
58091: LD_INT 1
58093: ST_TO_ADDR
// hackTanks := [ ] ;
58094: LD_ADDR_EXP 153
58098: PUSH
58099: EMPTY
58100: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
58101: LD_ADDR_EXP 154
58105: PUSH
58106: EMPTY
58107: ST_TO_ADDR
// hackLimit := 3 ;
58108: LD_ADDR_EXP 155
58112: PUSH
58113: LD_INT 3
58115: ST_TO_ADDR
// hackDist := 12 ;
58116: LD_ADDR_EXP 156
58120: PUSH
58121: LD_INT 12
58123: ST_TO_ADDR
// hackCounter := [ ] ;
58124: LD_ADDR_EXP 157
58128: PUSH
58129: EMPTY
58130: ST_TO_ADDR
// end ;
58131: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
58132: LD_EXP 152
58136: PUSH
58137: LD_INT 34
58139: PUSH
58140: LD_EXP 75
58144: PUSH
58145: EMPTY
58146: LIST
58147: LIST
58148: PPUSH
58149: CALL_OW 69
58153: AND
58154: IFFALSE 58409
58156: GO 58158
58158: DISABLE
58159: LD_INT 0
58161: PPUSH
58162: PPUSH
// begin enable ;
58163: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
58164: LD_ADDR_VAR 0 1
58168: PUSH
58169: LD_INT 34
58171: PUSH
58172: LD_EXP 75
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: PPUSH
58181: CALL_OW 69
58185: PUSH
58186: FOR_IN
58187: IFFALSE 58407
// begin if not i in hackTanks then
58189: LD_VAR 0 1
58193: PUSH
58194: LD_EXP 153
58198: IN
58199: NOT
58200: IFFALSE 58283
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
58202: LD_ADDR_EXP 153
58206: PUSH
58207: LD_EXP 153
58211: PPUSH
58212: LD_EXP 153
58216: PUSH
58217: LD_INT 1
58219: PLUS
58220: PPUSH
58221: LD_VAR 0 1
58225: PPUSH
58226: CALL_OW 1
58230: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
58231: LD_ADDR_EXP 154
58235: PUSH
58236: LD_EXP 154
58240: PPUSH
58241: LD_EXP 154
58245: PUSH
58246: LD_INT 1
58248: PLUS
58249: PPUSH
58250: EMPTY
58251: PPUSH
58252: CALL_OW 1
58256: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
58257: LD_ADDR_EXP 157
58261: PUSH
58262: LD_EXP 157
58266: PPUSH
58267: LD_EXP 157
58271: PUSH
58272: LD_INT 1
58274: PLUS
58275: PPUSH
58276: EMPTY
58277: PPUSH
58278: CALL_OW 1
58282: ST_TO_ADDR
// end ; if not IsOk ( i ) then
58283: LD_VAR 0 1
58287: PPUSH
58288: CALL_OW 302
58292: NOT
58293: IFFALSE 58306
// begin HackUnlinkAll ( i ) ;
58295: LD_VAR 0 1
58299: PPUSH
58300: CALL 58412 0 1
// continue ;
58304: GO 58186
// end ; HackCheckCapturedStatus ( i ) ;
58306: LD_VAR 0 1
58310: PPUSH
58311: CALL 58855 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
58315: LD_ADDR_VAR 0 2
58319: PUSH
58320: LD_INT 81
58322: PUSH
58323: LD_VAR 0 1
58327: PPUSH
58328: CALL_OW 255
58332: PUSH
58333: EMPTY
58334: LIST
58335: LIST
58336: PUSH
58337: LD_INT 33
58339: PUSH
58340: LD_INT 3
58342: PUSH
58343: EMPTY
58344: LIST
58345: LIST
58346: PUSH
58347: LD_INT 91
58349: PUSH
58350: LD_VAR 0 1
58354: PUSH
58355: LD_EXP 156
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: LIST
58364: PUSH
58365: LD_INT 50
58367: PUSH
58368: EMPTY
58369: LIST
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: LIST
58375: LIST
58376: PPUSH
58377: CALL_OW 69
58381: ST_TO_ADDR
// if not tmp then
58382: LD_VAR 0 2
58386: NOT
58387: IFFALSE 58391
// continue ;
58389: GO 58186
// HackLink ( i , tmp ) ;
58391: LD_VAR 0 1
58395: PPUSH
58396: LD_VAR 0 2
58400: PPUSH
58401: CALL 58548 0 2
// end ;
58405: GO 58186
58407: POP
58408: POP
// end ;
58409: PPOPN 2
58411: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
58412: LD_INT 0
58414: PPUSH
58415: PPUSH
58416: PPUSH
// if not hack in hackTanks then
58417: LD_VAR 0 1
58421: PUSH
58422: LD_EXP 153
58426: IN
58427: NOT
58428: IFFALSE 58432
// exit ;
58430: GO 58543
// index := GetElementIndex ( hackTanks , hack ) ;
58432: LD_ADDR_VAR 0 4
58436: PUSH
58437: LD_EXP 153
58441: PPUSH
58442: LD_VAR 0 1
58446: PPUSH
58447: CALL 66017 0 2
58451: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
58452: LD_EXP 154
58456: PUSH
58457: LD_VAR 0 4
58461: ARRAY
58462: IFFALSE 58543
// begin for i in hackTanksCaptured [ index ] do
58464: LD_ADDR_VAR 0 3
58468: PUSH
58469: LD_EXP 154
58473: PUSH
58474: LD_VAR 0 4
58478: ARRAY
58479: PUSH
58480: FOR_IN
58481: IFFALSE 58507
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
58483: LD_VAR 0 3
58487: PUSH
58488: LD_INT 1
58490: ARRAY
58491: PPUSH
58492: LD_VAR 0 3
58496: PUSH
58497: LD_INT 2
58499: ARRAY
58500: PPUSH
58501: CALL_OW 235
58505: GO 58480
58507: POP
58508: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
58509: LD_ADDR_EXP 154
58513: PUSH
58514: LD_EXP 154
58518: PPUSH
58519: LD_VAR 0 4
58523: PPUSH
58524: EMPTY
58525: PPUSH
58526: CALL_OW 1
58530: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
58531: LD_VAR 0 1
58535: PPUSH
58536: LD_INT 0
58538: PPUSH
58539: CALL_OW 505
// end ; end ;
58543: LD_VAR 0 2
58547: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
58548: LD_INT 0
58550: PPUSH
58551: PPUSH
58552: PPUSH
// if not hack in hackTanks or not vehicles then
58553: LD_VAR 0 1
58557: PUSH
58558: LD_EXP 153
58562: IN
58563: NOT
58564: PUSH
58565: LD_VAR 0 2
58569: NOT
58570: OR
58571: IFFALSE 58575
// exit ;
58573: GO 58850
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
58575: LD_ADDR_VAR 0 2
58579: PUSH
58580: LD_VAR 0 1
58584: PPUSH
58585: LD_VAR 0 2
58589: PPUSH
58590: LD_INT 1
58592: PPUSH
58593: LD_INT 1
58595: PPUSH
58596: CALL 66667 0 4
58600: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
58601: LD_ADDR_VAR 0 5
58605: PUSH
58606: LD_EXP 153
58610: PPUSH
58611: LD_VAR 0 1
58615: PPUSH
58616: CALL 66017 0 2
58620: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
58621: LD_EXP 154
58625: PUSH
58626: LD_VAR 0 5
58630: ARRAY
58631: PUSH
58632: LD_EXP 155
58636: LESS
58637: IFFALSE 58826
// begin for i := 1 to vehicles do
58639: LD_ADDR_VAR 0 4
58643: PUSH
58644: DOUBLE
58645: LD_INT 1
58647: DEC
58648: ST_TO_ADDR
58649: LD_VAR 0 2
58653: PUSH
58654: FOR_TO
58655: IFFALSE 58824
// begin if hackTanksCaptured [ index ] = hackLimit then
58657: LD_EXP 154
58661: PUSH
58662: LD_VAR 0 5
58666: ARRAY
58667: PUSH
58668: LD_EXP 155
58672: EQUAL
58673: IFFALSE 58677
// break ;
58675: GO 58824
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
58677: LD_ADDR_EXP 157
58681: PUSH
58682: LD_EXP 157
58686: PPUSH
58687: LD_VAR 0 5
58691: PPUSH
58692: LD_EXP 157
58696: PUSH
58697: LD_VAR 0 5
58701: ARRAY
58702: PUSH
58703: LD_INT 1
58705: PLUS
58706: PPUSH
58707: CALL_OW 1
58711: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
58712: LD_ADDR_EXP 154
58716: PUSH
58717: LD_EXP 154
58721: PPUSH
58722: LD_VAR 0 5
58726: PUSH
58727: LD_EXP 154
58731: PUSH
58732: LD_VAR 0 5
58736: ARRAY
58737: PUSH
58738: LD_INT 1
58740: PLUS
58741: PUSH
58742: EMPTY
58743: LIST
58744: LIST
58745: PPUSH
58746: LD_VAR 0 2
58750: PUSH
58751: LD_VAR 0 4
58755: ARRAY
58756: PUSH
58757: LD_VAR 0 2
58761: PUSH
58762: LD_VAR 0 4
58766: ARRAY
58767: PPUSH
58768: CALL_OW 255
58772: PUSH
58773: EMPTY
58774: LIST
58775: LIST
58776: PPUSH
58777: CALL 66232 0 3
58781: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
58782: LD_VAR 0 2
58786: PUSH
58787: LD_VAR 0 4
58791: ARRAY
58792: PPUSH
58793: LD_VAR 0 1
58797: PPUSH
58798: CALL_OW 255
58802: PPUSH
58803: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
58807: LD_VAR 0 2
58811: PUSH
58812: LD_VAR 0 4
58816: ARRAY
58817: PPUSH
58818: CALL_OW 141
// end ;
58822: GO 58654
58824: POP
58825: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58826: LD_VAR 0 1
58830: PPUSH
58831: LD_EXP 154
58835: PUSH
58836: LD_VAR 0 5
58840: ARRAY
58841: PUSH
58842: LD_INT 0
58844: PLUS
58845: PPUSH
58846: CALL_OW 505
// end ;
58850: LD_VAR 0 3
58854: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
58855: LD_INT 0
58857: PPUSH
58858: PPUSH
58859: PPUSH
58860: PPUSH
// if not hack in hackTanks then
58861: LD_VAR 0 1
58865: PUSH
58866: LD_EXP 153
58870: IN
58871: NOT
58872: IFFALSE 58876
// exit ;
58874: GO 59116
// index := GetElementIndex ( hackTanks , hack ) ;
58876: LD_ADDR_VAR 0 4
58880: PUSH
58881: LD_EXP 153
58885: PPUSH
58886: LD_VAR 0 1
58890: PPUSH
58891: CALL 66017 0 2
58895: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58896: LD_ADDR_VAR 0 3
58900: PUSH
58901: DOUBLE
58902: LD_EXP 154
58906: PUSH
58907: LD_VAR 0 4
58911: ARRAY
58912: INC
58913: ST_TO_ADDR
58914: LD_INT 1
58916: PUSH
58917: FOR_DOWNTO
58918: IFFALSE 59090
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58920: LD_ADDR_VAR 0 5
58924: PUSH
58925: LD_EXP 154
58929: PUSH
58930: LD_VAR 0 4
58934: ARRAY
58935: PUSH
58936: LD_VAR 0 3
58940: ARRAY
58941: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58942: LD_VAR 0 5
58946: PUSH
58947: LD_INT 1
58949: ARRAY
58950: PPUSH
58951: CALL_OW 302
58955: NOT
58956: PUSH
58957: LD_VAR 0 5
58961: PUSH
58962: LD_INT 1
58964: ARRAY
58965: PPUSH
58966: CALL_OW 255
58970: PUSH
58971: LD_VAR 0 1
58975: PPUSH
58976: CALL_OW 255
58980: NONEQUAL
58981: OR
58982: IFFALSE 59088
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58984: LD_VAR 0 5
58988: PUSH
58989: LD_INT 1
58991: ARRAY
58992: PPUSH
58993: CALL_OW 305
58997: PUSH
58998: LD_VAR 0 5
59002: PUSH
59003: LD_INT 1
59005: ARRAY
59006: PPUSH
59007: CALL_OW 255
59011: PUSH
59012: LD_VAR 0 1
59016: PPUSH
59017: CALL_OW 255
59021: EQUAL
59022: AND
59023: IFFALSE 59047
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
59025: LD_VAR 0 5
59029: PUSH
59030: LD_INT 1
59032: ARRAY
59033: PPUSH
59034: LD_VAR 0 5
59038: PUSH
59039: LD_INT 2
59041: ARRAY
59042: PPUSH
59043: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
59047: LD_ADDR_EXP 154
59051: PUSH
59052: LD_EXP 154
59056: PPUSH
59057: LD_VAR 0 4
59061: PPUSH
59062: LD_EXP 154
59066: PUSH
59067: LD_VAR 0 4
59071: ARRAY
59072: PPUSH
59073: LD_VAR 0 3
59077: PPUSH
59078: CALL_OW 3
59082: PPUSH
59083: CALL_OW 1
59087: ST_TO_ADDR
// end ; end ;
59088: GO 58917
59090: POP
59091: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
59092: LD_VAR 0 1
59096: PPUSH
59097: LD_EXP 154
59101: PUSH
59102: LD_VAR 0 4
59106: ARRAY
59107: PUSH
59108: LD_INT 0
59110: PLUS
59111: PPUSH
59112: CALL_OW 505
// end ;
59116: LD_VAR 0 2
59120: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
59121: LD_INT 0
59123: PPUSH
59124: PPUSH
59125: PPUSH
59126: PPUSH
// if not hack in hackTanks then
59127: LD_VAR 0 1
59131: PUSH
59132: LD_EXP 153
59136: IN
59137: NOT
59138: IFFALSE 59142
// exit ;
59140: GO 59227
// index := GetElementIndex ( hackTanks , hack ) ;
59142: LD_ADDR_VAR 0 5
59146: PUSH
59147: LD_EXP 153
59151: PPUSH
59152: LD_VAR 0 1
59156: PPUSH
59157: CALL 66017 0 2
59161: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
59162: LD_ADDR_VAR 0 4
59166: PUSH
59167: DOUBLE
59168: LD_INT 1
59170: DEC
59171: ST_TO_ADDR
59172: LD_EXP 154
59176: PUSH
59177: LD_VAR 0 5
59181: ARRAY
59182: PUSH
59183: FOR_TO
59184: IFFALSE 59225
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
59186: LD_EXP 154
59190: PUSH
59191: LD_VAR 0 5
59195: ARRAY
59196: PUSH
59197: LD_VAR 0 4
59201: ARRAY
59202: PUSH
59203: LD_INT 1
59205: ARRAY
59206: PUSH
59207: LD_VAR 0 2
59211: EQUAL
59212: IFFALSE 59223
// KillUnit ( vehicle ) ;
59214: LD_VAR 0 2
59218: PPUSH
59219: CALL_OW 66
59223: GO 59183
59225: POP
59226: POP
// end ;
59227: LD_VAR 0 3
59231: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
59232: LD_EXP 158
59236: NOT
59237: IFFALSE 59272
59239: GO 59241
59241: DISABLE
// begin initMiner := true ;
59242: LD_ADDR_EXP 158
59246: PUSH
59247: LD_INT 1
59249: ST_TO_ADDR
// minersList := [ ] ;
59250: LD_ADDR_EXP 159
59254: PUSH
59255: EMPTY
59256: ST_TO_ADDR
// minerMinesList := [ ] ;
59257: LD_ADDR_EXP 160
59261: PUSH
59262: EMPTY
59263: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
59264: LD_ADDR_EXP 161
59268: PUSH
59269: LD_INT 5
59271: ST_TO_ADDR
// end ;
59272: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
59273: LD_EXP 158
59277: PUSH
59278: LD_INT 34
59280: PUSH
59281: LD_EXP 80
59285: PUSH
59286: EMPTY
59287: LIST
59288: LIST
59289: PPUSH
59290: CALL_OW 69
59294: AND
59295: IFFALSE 59758
59297: GO 59299
59299: DISABLE
59300: LD_INT 0
59302: PPUSH
59303: PPUSH
59304: PPUSH
59305: PPUSH
// begin enable ;
59306: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
59307: LD_ADDR_VAR 0 1
59311: PUSH
59312: LD_INT 34
59314: PUSH
59315: LD_EXP 80
59319: PUSH
59320: EMPTY
59321: LIST
59322: LIST
59323: PPUSH
59324: CALL_OW 69
59328: PUSH
59329: FOR_IN
59330: IFFALSE 59402
// begin if not i in minersList then
59332: LD_VAR 0 1
59336: PUSH
59337: LD_EXP 159
59341: IN
59342: NOT
59343: IFFALSE 59400
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
59345: LD_ADDR_EXP 159
59349: PUSH
59350: LD_EXP 159
59354: PPUSH
59355: LD_EXP 159
59359: PUSH
59360: LD_INT 1
59362: PLUS
59363: PPUSH
59364: LD_VAR 0 1
59368: PPUSH
59369: CALL_OW 1
59373: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
59374: LD_ADDR_EXP 160
59378: PUSH
59379: LD_EXP 160
59383: PPUSH
59384: LD_EXP 160
59388: PUSH
59389: LD_INT 1
59391: PLUS
59392: PPUSH
59393: EMPTY
59394: PPUSH
59395: CALL_OW 1
59399: ST_TO_ADDR
// end end ;
59400: GO 59329
59402: POP
59403: POP
// for i := minerMinesList downto 1 do
59404: LD_ADDR_VAR 0 1
59408: PUSH
59409: DOUBLE
59410: LD_EXP 160
59414: INC
59415: ST_TO_ADDR
59416: LD_INT 1
59418: PUSH
59419: FOR_DOWNTO
59420: IFFALSE 59756
// begin if IsLive ( minersList [ i ] ) then
59422: LD_EXP 159
59426: PUSH
59427: LD_VAR 0 1
59431: ARRAY
59432: PPUSH
59433: CALL_OW 300
59437: IFFALSE 59465
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
59439: LD_EXP 159
59443: PUSH
59444: LD_VAR 0 1
59448: ARRAY
59449: PPUSH
59450: LD_EXP 160
59454: PUSH
59455: LD_VAR 0 1
59459: ARRAY
59460: PPUSH
59461: CALL_OW 505
// if not minerMinesList [ i ] then
59465: LD_EXP 160
59469: PUSH
59470: LD_VAR 0 1
59474: ARRAY
59475: NOT
59476: IFFALSE 59480
// continue ;
59478: GO 59419
// for j := minerMinesList [ i ] downto 1 do
59480: LD_ADDR_VAR 0 2
59484: PUSH
59485: DOUBLE
59486: LD_EXP 160
59490: PUSH
59491: LD_VAR 0 1
59495: ARRAY
59496: INC
59497: ST_TO_ADDR
59498: LD_INT 1
59500: PUSH
59501: FOR_DOWNTO
59502: IFFALSE 59752
// begin side := GetSide ( minersList [ i ] ) ;
59504: LD_ADDR_VAR 0 3
59508: PUSH
59509: LD_EXP 159
59513: PUSH
59514: LD_VAR 0 1
59518: ARRAY
59519: PPUSH
59520: CALL_OW 255
59524: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
59525: LD_ADDR_VAR 0 4
59529: PUSH
59530: LD_EXP 160
59534: PUSH
59535: LD_VAR 0 1
59539: ARRAY
59540: PUSH
59541: LD_VAR 0 2
59545: ARRAY
59546: PUSH
59547: LD_INT 1
59549: ARRAY
59550: PPUSH
59551: LD_EXP 160
59555: PUSH
59556: LD_VAR 0 1
59560: ARRAY
59561: PUSH
59562: LD_VAR 0 2
59566: ARRAY
59567: PUSH
59568: LD_INT 2
59570: ARRAY
59571: PPUSH
59572: CALL_OW 428
59576: ST_TO_ADDR
// if not tmp then
59577: LD_VAR 0 4
59581: NOT
59582: IFFALSE 59586
// continue ;
59584: GO 59501
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
59586: LD_VAR 0 4
59590: PUSH
59591: LD_INT 81
59593: PUSH
59594: LD_VAR 0 3
59598: PUSH
59599: EMPTY
59600: LIST
59601: LIST
59602: PPUSH
59603: CALL_OW 69
59607: IN
59608: PUSH
59609: LD_EXP 160
59613: PUSH
59614: LD_VAR 0 1
59618: ARRAY
59619: PUSH
59620: LD_VAR 0 2
59624: ARRAY
59625: PUSH
59626: LD_INT 1
59628: ARRAY
59629: PPUSH
59630: LD_EXP 160
59634: PUSH
59635: LD_VAR 0 1
59639: ARRAY
59640: PUSH
59641: LD_VAR 0 2
59645: ARRAY
59646: PUSH
59647: LD_INT 2
59649: ARRAY
59650: PPUSH
59651: CALL_OW 458
59655: AND
59656: IFFALSE 59750
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
59658: LD_EXP 160
59662: PUSH
59663: LD_VAR 0 1
59667: ARRAY
59668: PUSH
59669: LD_VAR 0 2
59673: ARRAY
59674: PUSH
59675: LD_INT 1
59677: ARRAY
59678: PPUSH
59679: LD_EXP 160
59683: PUSH
59684: LD_VAR 0 1
59688: ARRAY
59689: PUSH
59690: LD_VAR 0 2
59694: ARRAY
59695: PUSH
59696: LD_INT 2
59698: ARRAY
59699: PPUSH
59700: LD_VAR 0 3
59704: PPUSH
59705: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
59709: LD_ADDR_EXP 160
59713: PUSH
59714: LD_EXP 160
59718: PPUSH
59719: LD_VAR 0 1
59723: PPUSH
59724: LD_EXP 160
59728: PUSH
59729: LD_VAR 0 1
59733: ARRAY
59734: PPUSH
59735: LD_VAR 0 2
59739: PPUSH
59740: CALL_OW 3
59744: PPUSH
59745: CALL_OW 1
59749: ST_TO_ADDR
// end ; end ;
59750: GO 59501
59752: POP
59753: POP
// end ;
59754: GO 59419
59756: POP
59757: POP
// end ;
59758: PPOPN 4
59760: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
59761: LD_INT 0
59763: PPUSH
59764: PPUSH
// result := false ;
59765: LD_ADDR_VAR 0 4
59769: PUSH
59770: LD_INT 0
59772: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
59773: LD_VAR 0 1
59777: PPUSH
59778: CALL_OW 264
59782: PUSH
59783: LD_EXP 80
59787: EQUAL
59788: NOT
59789: IFFALSE 59793
// exit ;
59791: GO 60033
// index := GetElementIndex ( minersList , unit ) ;
59793: LD_ADDR_VAR 0 5
59797: PUSH
59798: LD_EXP 159
59802: PPUSH
59803: LD_VAR 0 1
59807: PPUSH
59808: CALL 66017 0 2
59812: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
59813: LD_EXP 160
59817: PUSH
59818: LD_VAR 0 5
59822: ARRAY
59823: PUSH
59824: LD_EXP 161
59828: GREATEREQUAL
59829: IFFALSE 59833
// exit ;
59831: GO 60033
// ComMoveXY ( unit , x , y ) ;
59833: LD_VAR 0 1
59837: PPUSH
59838: LD_VAR 0 2
59842: PPUSH
59843: LD_VAR 0 3
59847: PPUSH
59848: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
59852: LD_INT 35
59854: PPUSH
59855: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
59859: LD_VAR 0 1
59863: PPUSH
59864: LD_VAR 0 2
59868: PPUSH
59869: LD_VAR 0 3
59873: PPUSH
59874: CALL 96789 0 3
59878: NOT
59879: PUSH
59880: LD_VAR 0 1
59884: PPUSH
59885: CALL_OW 314
59889: AND
59890: IFFALSE 59894
// exit ;
59892: GO 60033
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59894: LD_VAR 0 2
59898: PPUSH
59899: LD_VAR 0 3
59903: PPUSH
59904: CALL_OW 428
59908: PUSH
59909: LD_VAR 0 1
59913: EQUAL
59914: PUSH
59915: LD_VAR 0 1
59919: PPUSH
59920: CALL_OW 314
59924: NOT
59925: AND
59926: IFFALSE 59852
// PlaySoundXY ( x , y , PlantMine ) ;
59928: LD_VAR 0 2
59932: PPUSH
59933: LD_VAR 0 3
59937: PPUSH
59938: LD_STRING PlantMine
59940: PPUSH
59941: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59945: LD_VAR 0 2
59949: PPUSH
59950: LD_VAR 0 3
59954: PPUSH
59955: LD_VAR 0 1
59959: PPUSH
59960: CALL_OW 255
59964: PPUSH
59965: LD_INT 0
59967: PPUSH
59968: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59972: LD_ADDR_EXP 160
59976: PUSH
59977: LD_EXP 160
59981: PPUSH
59982: LD_VAR 0 5
59986: PUSH
59987: LD_EXP 160
59991: PUSH
59992: LD_VAR 0 5
59996: ARRAY
59997: PUSH
59998: LD_INT 1
60000: PLUS
60001: PUSH
60002: EMPTY
60003: LIST
60004: LIST
60005: PPUSH
60006: LD_VAR 0 2
60010: PUSH
60011: LD_VAR 0 3
60015: PUSH
60016: EMPTY
60017: LIST
60018: LIST
60019: PPUSH
60020: CALL 66232 0 3
60024: ST_TO_ADDR
// result := true ;
60025: LD_ADDR_VAR 0 4
60029: PUSH
60030: LD_INT 1
60032: ST_TO_ADDR
// end ;
60033: LD_VAR 0 4
60037: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
60038: LD_INT 0
60040: PPUSH
60041: PPUSH
60042: PPUSH
// if not unit in minersList then
60043: LD_VAR 0 1
60047: PUSH
60048: LD_EXP 159
60052: IN
60053: NOT
60054: IFFALSE 60058
// exit ;
60056: GO 60450
// index := GetElementIndex ( minersList , unit ) ;
60058: LD_ADDR_VAR 0 6
60062: PUSH
60063: LD_EXP 159
60067: PPUSH
60068: LD_VAR 0 1
60072: PPUSH
60073: CALL 66017 0 2
60077: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
60078: LD_ADDR_VAR 0 5
60082: PUSH
60083: DOUBLE
60084: LD_EXP 160
60088: PUSH
60089: LD_VAR 0 6
60093: ARRAY
60094: INC
60095: ST_TO_ADDR
60096: LD_INT 1
60098: PUSH
60099: FOR_DOWNTO
60100: IFFALSE 60261
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
60102: LD_EXP 160
60106: PUSH
60107: LD_VAR 0 6
60111: ARRAY
60112: PUSH
60113: LD_VAR 0 5
60117: ARRAY
60118: PUSH
60119: LD_INT 1
60121: ARRAY
60122: PUSH
60123: LD_VAR 0 2
60127: EQUAL
60128: PUSH
60129: LD_EXP 160
60133: PUSH
60134: LD_VAR 0 6
60138: ARRAY
60139: PUSH
60140: LD_VAR 0 5
60144: ARRAY
60145: PUSH
60146: LD_INT 2
60148: ARRAY
60149: PUSH
60150: LD_VAR 0 3
60154: EQUAL
60155: AND
60156: IFFALSE 60259
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
60158: LD_EXP 160
60162: PUSH
60163: LD_VAR 0 6
60167: ARRAY
60168: PUSH
60169: LD_VAR 0 5
60173: ARRAY
60174: PUSH
60175: LD_INT 1
60177: ARRAY
60178: PPUSH
60179: LD_EXP 160
60183: PUSH
60184: LD_VAR 0 6
60188: ARRAY
60189: PUSH
60190: LD_VAR 0 5
60194: ARRAY
60195: PUSH
60196: LD_INT 2
60198: ARRAY
60199: PPUSH
60200: LD_VAR 0 1
60204: PPUSH
60205: CALL_OW 255
60209: PPUSH
60210: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
60214: LD_ADDR_EXP 160
60218: PUSH
60219: LD_EXP 160
60223: PPUSH
60224: LD_VAR 0 6
60228: PPUSH
60229: LD_EXP 160
60233: PUSH
60234: LD_VAR 0 6
60238: ARRAY
60239: PPUSH
60240: LD_VAR 0 5
60244: PPUSH
60245: CALL_OW 3
60249: PPUSH
60250: CALL_OW 1
60254: ST_TO_ADDR
// exit ;
60255: POP
60256: POP
60257: GO 60450
// end ; end ;
60259: GO 60099
60261: POP
60262: POP
// for i := minerMinesList [ index ] downto 1 do
60263: LD_ADDR_VAR 0 5
60267: PUSH
60268: DOUBLE
60269: LD_EXP 160
60273: PUSH
60274: LD_VAR 0 6
60278: ARRAY
60279: INC
60280: ST_TO_ADDR
60281: LD_INT 1
60283: PUSH
60284: FOR_DOWNTO
60285: IFFALSE 60448
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
60287: LD_EXP 160
60291: PUSH
60292: LD_VAR 0 6
60296: ARRAY
60297: PUSH
60298: LD_VAR 0 5
60302: ARRAY
60303: PUSH
60304: LD_INT 1
60306: ARRAY
60307: PPUSH
60308: LD_EXP 160
60312: PUSH
60313: LD_VAR 0 6
60317: ARRAY
60318: PUSH
60319: LD_VAR 0 5
60323: ARRAY
60324: PUSH
60325: LD_INT 2
60327: ARRAY
60328: PPUSH
60329: LD_VAR 0 2
60333: PPUSH
60334: LD_VAR 0 3
60338: PPUSH
60339: CALL_OW 298
60343: PUSH
60344: LD_INT 6
60346: LESS
60347: IFFALSE 60446
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
60349: LD_EXP 160
60353: PUSH
60354: LD_VAR 0 6
60358: ARRAY
60359: PUSH
60360: LD_VAR 0 5
60364: ARRAY
60365: PUSH
60366: LD_INT 1
60368: ARRAY
60369: PPUSH
60370: LD_EXP 160
60374: PUSH
60375: LD_VAR 0 6
60379: ARRAY
60380: PUSH
60381: LD_VAR 0 5
60385: ARRAY
60386: PUSH
60387: LD_INT 2
60389: ARRAY
60390: PPUSH
60391: LD_VAR 0 1
60395: PPUSH
60396: CALL_OW 255
60400: PPUSH
60401: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
60405: LD_ADDR_EXP 160
60409: PUSH
60410: LD_EXP 160
60414: PPUSH
60415: LD_VAR 0 6
60419: PPUSH
60420: LD_EXP 160
60424: PUSH
60425: LD_VAR 0 6
60429: ARRAY
60430: PPUSH
60431: LD_VAR 0 5
60435: PPUSH
60436: CALL_OW 3
60440: PPUSH
60441: CALL_OW 1
60445: ST_TO_ADDR
// end ; end ;
60446: GO 60284
60448: POP
60449: POP
// end ;
60450: LD_VAR 0 4
60454: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
60455: LD_INT 0
60457: PPUSH
60458: PPUSH
60459: PPUSH
60460: PPUSH
60461: PPUSH
60462: PPUSH
60463: PPUSH
60464: PPUSH
60465: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
60466: LD_VAR 0 1
60470: PPUSH
60471: CALL_OW 264
60475: PUSH
60476: LD_EXP 80
60480: EQUAL
60481: NOT
60482: PUSH
60483: LD_VAR 0 1
60487: PUSH
60488: LD_EXP 159
60492: IN
60493: NOT
60494: OR
60495: IFFALSE 60499
// exit ;
60497: GO 60821
// index := GetElementIndex ( minersList , unit ) ;
60499: LD_ADDR_VAR 0 6
60503: PUSH
60504: LD_EXP 159
60508: PPUSH
60509: LD_VAR 0 1
60513: PPUSH
60514: CALL 66017 0 2
60518: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
60519: LD_ADDR_VAR 0 8
60523: PUSH
60524: LD_EXP 161
60528: PUSH
60529: LD_EXP 160
60533: PUSH
60534: LD_VAR 0 6
60538: ARRAY
60539: MINUS
60540: ST_TO_ADDR
// if not minesFreeAmount then
60541: LD_VAR 0 8
60545: NOT
60546: IFFALSE 60550
// exit ;
60548: GO 60821
// tmp := [ ] ;
60550: LD_ADDR_VAR 0 7
60554: PUSH
60555: EMPTY
60556: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
60557: LD_ADDR_VAR 0 5
60561: PUSH
60562: DOUBLE
60563: LD_INT 1
60565: DEC
60566: ST_TO_ADDR
60567: LD_VAR 0 8
60571: PUSH
60572: FOR_TO
60573: IFFALSE 60768
// begin _d := rand ( 0 , 5 ) ;
60575: LD_ADDR_VAR 0 11
60579: PUSH
60580: LD_INT 0
60582: PPUSH
60583: LD_INT 5
60585: PPUSH
60586: CALL_OW 12
60590: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
60591: LD_ADDR_VAR 0 12
60595: PUSH
60596: LD_INT 2
60598: PPUSH
60599: LD_INT 6
60601: PPUSH
60602: CALL_OW 12
60606: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
60607: LD_ADDR_VAR 0 9
60611: PUSH
60612: LD_VAR 0 2
60616: PPUSH
60617: LD_VAR 0 11
60621: PPUSH
60622: LD_VAR 0 12
60626: PPUSH
60627: CALL_OW 272
60631: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
60632: LD_ADDR_VAR 0 10
60636: PUSH
60637: LD_VAR 0 3
60641: PPUSH
60642: LD_VAR 0 11
60646: PPUSH
60647: LD_VAR 0 12
60651: PPUSH
60652: CALL_OW 273
60656: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
60657: LD_VAR 0 9
60661: PPUSH
60662: LD_VAR 0 10
60666: PPUSH
60667: CALL_OW 488
60671: PUSH
60672: LD_VAR 0 9
60676: PUSH
60677: LD_VAR 0 10
60681: PUSH
60682: EMPTY
60683: LIST
60684: LIST
60685: PUSH
60686: LD_VAR 0 7
60690: IN
60691: NOT
60692: AND
60693: PUSH
60694: LD_VAR 0 9
60698: PPUSH
60699: LD_VAR 0 10
60703: PPUSH
60704: CALL_OW 458
60708: NOT
60709: AND
60710: IFFALSE 60752
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
60712: LD_ADDR_VAR 0 7
60716: PUSH
60717: LD_VAR 0 7
60721: PPUSH
60722: LD_VAR 0 7
60726: PUSH
60727: LD_INT 1
60729: PLUS
60730: PPUSH
60731: LD_VAR 0 9
60735: PUSH
60736: LD_VAR 0 10
60740: PUSH
60741: EMPTY
60742: LIST
60743: LIST
60744: PPUSH
60745: CALL_OW 1
60749: ST_TO_ADDR
60750: GO 60766
// i := i - 1 ;
60752: LD_ADDR_VAR 0 5
60756: PUSH
60757: LD_VAR 0 5
60761: PUSH
60762: LD_INT 1
60764: MINUS
60765: ST_TO_ADDR
// end ;
60766: GO 60572
60768: POP
60769: POP
// for i in tmp do
60770: LD_ADDR_VAR 0 5
60774: PUSH
60775: LD_VAR 0 7
60779: PUSH
60780: FOR_IN
60781: IFFALSE 60819
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
60783: LD_VAR 0 1
60787: PPUSH
60788: LD_VAR 0 5
60792: PUSH
60793: LD_INT 1
60795: ARRAY
60796: PPUSH
60797: LD_VAR 0 5
60801: PUSH
60802: LD_INT 2
60804: ARRAY
60805: PPUSH
60806: CALL 59761 0 3
60810: NOT
60811: IFFALSE 60817
// exit ;
60813: POP
60814: POP
60815: GO 60821
60817: GO 60780
60819: POP
60820: POP
// end ;
60821: LD_VAR 0 4
60825: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
60826: LD_INT 0
60828: PPUSH
60829: PPUSH
60830: PPUSH
60831: PPUSH
60832: PPUSH
60833: PPUSH
60834: PPUSH
// if not GetClass ( unit ) = class_sniper then
60835: LD_VAR 0 1
60839: PPUSH
60840: CALL_OW 257
60844: PUSH
60845: LD_INT 5
60847: EQUAL
60848: NOT
60849: IFFALSE 60853
// exit ;
60851: GO 61241
// dist := 8 ;
60853: LD_ADDR_VAR 0 5
60857: PUSH
60858: LD_INT 8
60860: ST_TO_ADDR
// viewRange := 12 ;
60861: LD_ADDR_VAR 0 7
60865: PUSH
60866: LD_INT 12
60868: ST_TO_ADDR
// side := GetSide ( unit ) ;
60869: LD_ADDR_VAR 0 6
60873: PUSH
60874: LD_VAR 0 1
60878: PPUSH
60879: CALL_OW 255
60883: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60884: LD_INT 61
60886: PPUSH
60887: LD_VAR 0 6
60891: PPUSH
60892: CALL_OW 321
60896: PUSH
60897: LD_INT 2
60899: EQUAL
60900: IFFALSE 60910
// viewRange := 16 ;
60902: LD_ADDR_VAR 0 7
60906: PUSH
60907: LD_INT 16
60909: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60910: LD_VAR 0 1
60914: PPUSH
60915: LD_VAR 0 2
60919: PPUSH
60920: LD_VAR 0 3
60924: PPUSH
60925: CALL_OW 297
60929: PUSH
60930: LD_VAR 0 5
60934: GREATER
60935: IFFALSE 61014
// begin ComMoveXY ( unit , x , y ) ;
60937: LD_VAR 0 1
60941: PPUSH
60942: LD_VAR 0 2
60946: PPUSH
60947: LD_VAR 0 3
60951: PPUSH
60952: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60956: LD_INT 35
60958: PPUSH
60959: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60963: LD_VAR 0 1
60967: PPUSH
60968: LD_VAR 0 2
60972: PPUSH
60973: LD_VAR 0 3
60977: PPUSH
60978: CALL 96789 0 3
60982: NOT
60983: IFFALSE 60987
// exit ;
60985: GO 61241
// until GetDistUnitXY ( unit , x , y ) < dist ;
60987: LD_VAR 0 1
60991: PPUSH
60992: LD_VAR 0 2
60996: PPUSH
60997: LD_VAR 0 3
61001: PPUSH
61002: CALL_OW 297
61006: PUSH
61007: LD_VAR 0 5
61011: LESS
61012: IFFALSE 60956
// end ; ComTurnXY ( unit , x , y ) ;
61014: LD_VAR 0 1
61018: PPUSH
61019: LD_VAR 0 2
61023: PPUSH
61024: LD_VAR 0 3
61028: PPUSH
61029: CALL_OW 118
// wait ( 5 ) ;
61033: LD_INT 5
61035: PPUSH
61036: CALL_OW 67
// _d := GetDir ( unit ) ;
61040: LD_ADDR_VAR 0 10
61044: PUSH
61045: LD_VAR 0 1
61049: PPUSH
61050: CALL_OW 254
61054: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
61055: LD_ADDR_VAR 0 8
61059: PUSH
61060: LD_VAR 0 1
61064: PPUSH
61065: CALL_OW 250
61069: PPUSH
61070: LD_VAR 0 10
61074: PPUSH
61075: LD_VAR 0 5
61079: PPUSH
61080: CALL_OW 272
61084: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
61085: LD_ADDR_VAR 0 9
61089: PUSH
61090: LD_VAR 0 1
61094: PPUSH
61095: CALL_OW 251
61099: PPUSH
61100: LD_VAR 0 10
61104: PPUSH
61105: LD_VAR 0 5
61109: PPUSH
61110: CALL_OW 273
61114: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
61115: LD_VAR 0 8
61119: PPUSH
61120: LD_VAR 0 9
61124: PPUSH
61125: CALL_OW 488
61129: NOT
61130: IFFALSE 61134
// exit ;
61132: GO 61241
// ComAnimCustom ( unit , 1 ) ;
61134: LD_VAR 0 1
61138: PPUSH
61139: LD_INT 1
61141: PPUSH
61142: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
61146: LD_VAR 0 8
61150: PPUSH
61151: LD_VAR 0 9
61155: PPUSH
61156: LD_VAR 0 6
61160: PPUSH
61161: LD_VAR 0 7
61165: PPUSH
61166: CALL_OW 330
// repeat wait ( 1 ) ;
61170: LD_INT 1
61172: PPUSH
61173: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
61177: LD_VAR 0 1
61181: PPUSH
61182: CALL_OW 316
61186: PUSH
61187: LD_VAR 0 1
61191: PPUSH
61192: CALL_OW 314
61196: OR
61197: PUSH
61198: LD_VAR 0 1
61202: PPUSH
61203: CALL_OW 302
61207: NOT
61208: OR
61209: PUSH
61210: LD_VAR 0 1
61214: PPUSH
61215: CALL_OW 301
61219: OR
61220: IFFALSE 61170
// RemoveSeeing ( _x , _y , side ) ;
61222: LD_VAR 0 8
61226: PPUSH
61227: LD_VAR 0 9
61231: PPUSH
61232: LD_VAR 0 6
61236: PPUSH
61237: CALL_OW 331
// end ; end_of_file
61241: LD_VAR 0 4
61245: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
61246: LD_INT 0
61248: PPUSH
61249: PPUSH
// if exist_mode then
61250: LD_VAR 0 2
61254: IFFALSE 61279
// unit := CreateCharacter ( prefix & ident ) else
61256: LD_ADDR_VAR 0 5
61260: PUSH
61261: LD_VAR 0 3
61265: PUSH
61266: LD_VAR 0 1
61270: STR
61271: PPUSH
61272: CALL_OW 34
61276: ST_TO_ADDR
61277: GO 61294
// unit := NewCharacter ( ident ) ;
61279: LD_ADDR_VAR 0 5
61283: PUSH
61284: LD_VAR 0 1
61288: PPUSH
61289: CALL_OW 25
61293: ST_TO_ADDR
// result := unit ;
61294: LD_ADDR_VAR 0 4
61298: PUSH
61299: LD_VAR 0 5
61303: ST_TO_ADDR
// end ;
61304: LD_VAR 0 4
61308: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
61309: LD_INT 0
61311: PPUSH
61312: PPUSH
// if not side or not nation then
61313: LD_VAR 0 1
61317: NOT
61318: PUSH
61319: LD_VAR 0 2
61323: NOT
61324: OR
61325: IFFALSE 61329
// exit ;
61327: GO 62097
// case nation of nation_american :
61329: LD_VAR 0 2
61333: PUSH
61334: LD_INT 1
61336: DOUBLE
61337: EQUAL
61338: IFTRUE 61342
61340: GO 61556
61342: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
61343: LD_ADDR_VAR 0 4
61347: PUSH
61348: LD_INT 35
61350: PUSH
61351: LD_INT 45
61353: PUSH
61354: LD_INT 46
61356: PUSH
61357: LD_INT 47
61359: PUSH
61360: LD_INT 82
61362: PUSH
61363: LD_INT 83
61365: PUSH
61366: LD_INT 84
61368: PUSH
61369: LD_INT 85
61371: PUSH
61372: LD_INT 86
61374: PUSH
61375: LD_INT 1
61377: PUSH
61378: LD_INT 2
61380: PUSH
61381: LD_INT 6
61383: PUSH
61384: LD_INT 15
61386: PUSH
61387: LD_INT 16
61389: PUSH
61390: LD_INT 7
61392: PUSH
61393: LD_INT 12
61395: PUSH
61396: LD_INT 13
61398: PUSH
61399: LD_INT 10
61401: PUSH
61402: LD_INT 14
61404: PUSH
61405: LD_INT 20
61407: PUSH
61408: LD_INT 21
61410: PUSH
61411: LD_INT 22
61413: PUSH
61414: LD_INT 25
61416: PUSH
61417: LD_INT 32
61419: PUSH
61420: LD_INT 27
61422: PUSH
61423: LD_INT 36
61425: PUSH
61426: LD_INT 69
61428: PUSH
61429: LD_INT 39
61431: PUSH
61432: LD_INT 34
61434: PUSH
61435: LD_INT 40
61437: PUSH
61438: LD_INT 48
61440: PUSH
61441: LD_INT 49
61443: PUSH
61444: LD_INT 50
61446: PUSH
61447: LD_INT 51
61449: PUSH
61450: LD_INT 52
61452: PUSH
61453: LD_INT 53
61455: PUSH
61456: LD_INT 54
61458: PUSH
61459: LD_INT 55
61461: PUSH
61462: LD_INT 56
61464: PUSH
61465: LD_INT 57
61467: PUSH
61468: LD_INT 58
61470: PUSH
61471: LD_INT 59
61473: PUSH
61474: LD_INT 60
61476: PUSH
61477: LD_INT 61
61479: PUSH
61480: LD_INT 62
61482: PUSH
61483: LD_INT 80
61485: PUSH
61486: LD_INT 82
61488: PUSH
61489: LD_INT 83
61491: PUSH
61492: LD_INT 84
61494: PUSH
61495: LD_INT 85
61497: PUSH
61498: LD_INT 86
61500: PUSH
61501: EMPTY
61502: LIST
61503: LIST
61504: LIST
61505: LIST
61506: LIST
61507: LIST
61508: LIST
61509: LIST
61510: LIST
61511: LIST
61512: LIST
61513: LIST
61514: LIST
61515: LIST
61516: LIST
61517: LIST
61518: LIST
61519: LIST
61520: LIST
61521: LIST
61522: LIST
61523: LIST
61524: LIST
61525: LIST
61526: LIST
61527: LIST
61528: LIST
61529: LIST
61530: LIST
61531: LIST
61532: LIST
61533: LIST
61534: LIST
61535: LIST
61536: LIST
61537: LIST
61538: LIST
61539: LIST
61540: LIST
61541: LIST
61542: LIST
61543: LIST
61544: LIST
61545: LIST
61546: LIST
61547: LIST
61548: LIST
61549: LIST
61550: LIST
61551: LIST
61552: LIST
61553: ST_TO_ADDR
61554: GO 62021
61556: LD_INT 2
61558: DOUBLE
61559: EQUAL
61560: IFTRUE 61564
61562: GO 61790
61564: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
61565: LD_ADDR_VAR 0 4
61569: PUSH
61570: LD_INT 35
61572: PUSH
61573: LD_INT 45
61575: PUSH
61576: LD_INT 46
61578: PUSH
61579: LD_INT 47
61581: PUSH
61582: LD_INT 82
61584: PUSH
61585: LD_INT 83
61587: PUSH
61588: LD_INT 84
61590: PUSH
61591: LD_INT 85
61593: PUSH
61594: LD_INT 87
61596: PUSH
61597: LD_INT 70
61599: PUSH
61600: LD_INT 1
61602: PUSH
61603: LD_INT 11
61605: PUSH
61606: LD_INT 3
61608: PUSH
61609: LD_INT 4
61611: PUSH
61612: LD_INT 5
61614: PUSH
61615: LD_INT 6
61617: PUSH
61618: LD_INT 15
61620: PUSH
61621: LD_INT 18
61623: PUSH
61624: LD_INT 7
61626: PUSH
61627: LD_INT 17
61629: PUSH
61630: LD_INT 8
61632: PUSH
61633: LD_INT 20
61635: PUSH
61636: LD_INT 21
61638: PUSH
61639: LD_INT 22
61641: PUSH
61642: LD_INT 72
61644: PUSH
61645: LD_INT 26
61647: PUSH
61648: LD_INT 69
61650: PUSH
61651: LD_INT 39
61653: PUSH
61654: LD_INT 40
61656: PUSH
61657: LD_INT 41
61659: PUSH
61660: LD_INT 42
61662: PUSH
61663: LD_INT 43
61665: PUSH
61666: LD_INT 48
61668: PUSH
61669: LD_INT 49
61671: PUSH
61672: LD_INT 50
61674: PUSH
61675: LD_INT 51
61677: PUSH
61678: LD_INT 52
61680: PUSH
61681: LD_INT 53
61683: PUSH
61684: LD_INT 54
61686: PUSH
61687: LD_INT 55
61689: PUSH
61690: LD_INT 56
61692: PUSH
61693: LD_INT 60
61695: PUSH
61696: LD_INT 61
61698: PUSH
61699: LD_INT 62
61701: PUSH
61702: LD_INT 66
61704: PUSH
61705: LD_INT 67
61707: PUSH
61708: LD_INT 68
61710: PUSH
61711: LD_INT 81
61713: PUSH
61714: LD_INT 82
61716: PUSH
61717: LD_INT 83
61719: PUSH
61720: LD_INT 84
61722: PUSH
61723: LD_INT 85
61725: PUSH
61726: LD_INT 87
61728: PUSH
61729: LD_INT 88
61731: PUSH
61732: EMPTY
61733: LIST
61734: LIST
61735: LIST
61736: LIST
61737: LIST
61738: LIST
61739: LIST
61740: LIST
61741: LIST
61742: LIST
61743: LIST
61744: LIST
61745: LIST
61746: LIST
61747: LIST
61748: LIST
61749: LIST
61750: LIST
61751: LIST
61752: LIST
61753: LIST
61754: LIST
61755: LIST
61756: LIST
61757: LIST
61758: LIST
61759: LIST
61760: LIST
61761: LIST
61762: LIST
61763: LIST
61764: LIST
61765: LIST
61766: LIST
61767: LIST
61768: LIST
61769: LIST
61770: LIST
61771: LIST
61772: LIST
61773: LIST
61774: LIST
61775: LIST
61776: LIST
61777: LIST
61778: LIST
61779: LIST
61780: LIST
61781: LIST
61782: LIST
61783: LIST
61784: LIST
61785: LIST
61786: LIST
61787: ST_TO_ADDR
61788: GO 62021
61790: LD_INT 3
61792: DOUBLE
61793: EQUAL
61794: IFTRUE 61798
61796: GO 62020
61798: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
61799: LD_ADDR_VAR 0 4
61803: PUSH
61804: LD_INT 46
61806: PUSH
61807: LD_INT 47
61809: PUSH
61810: LD_INT 1
61812: PUSH
61813: LD_INT 2
61815: PUSH
61816: LD_INT 82
61818: PUSH
61819: LD_INT 83
61821: PUSH
61822: LD_INT 84
61824: PUSH
61825: LD_INT 85
61827: PUSH
61828: LD_INT 86
61830: PUSH
61831: LD_INT 11
61833: PUSH
61834: LD_INT 9
61836: PUSH
61837: LD_INT 20
61839: PUSH
61840: LD_INT 19
61842: PUSH
61843: LD_INT 21
61845: PUSH
61846: LD_INT 24
61848: PUSH
61849: LD_INT 22
61851: PUSH
61852: LD_INT 25
61854: PUSH
61855: LD_INT 28
61857: PUSH
61858: LD_INT 29
61860: PUSH
61861: LD_INT 30
61863: PUSH
61864: LD_INT 31
61866: PUSH
61867: LD_INT 37
61869: PUSH
61870: LD_INT 38
61872: PUSH
61873: LD_INT 32
61875: PUSH
61876: LD_INT 27
61878: PUSH
61879: LD_INT 33
61881: PUSH
61882: LD_INT 69
61884: PUSH
61885: LD_INT 39
61887: PUSH
61888: LD_INT 34
61890: PUSH
61891: LD_INT 40
61893: PUSH
61894: LD_INT 71
61896: PUSH
61897: LD_INT 23
61899: PUSH
61900: LD_INT 44
61902: PUSH
61903: LD_INT 48
61905: PUSH
61906: LD_INT 49
61908: PUSH
61909: LD_INT 50
61911: PUSH
61912: LD_INT 51
61914: PUSH
61915: LD_INT 52
61917: PUSH
61918: LD_INT 53
61920: PUSH
61921: LD_INT 54
61923: PUSH
61924: LD_INT 55
61926: PUSH
61927: LD_INT 56
61929: PUSH
61930: LD_INT 57
61932: PUSH
61933: LD_INT 58
61935: PUSH
61936: LD_INT 59
61938: PUSH
61939: LD_INT 63
61941: PUSH
61942: LD_INT 64
61944: PUSH
61945: LD_INT 65
61947: PUSH
61948: LD_INT 82
61950: PUSH
61951: LD_INT 83
61953: PUSH
61954: LD_INT 84
61956: PUSH
61957: LD_INT 85
61959: PUSH
61960: LD_INT 86
61962: PUSH
61963: EMPTY
61964: LIST
61965: LIST
61966: LIST
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: LIST
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: LIST
61982: LIST
61983: LIST
61984: LIST
61985: LIST
61986: LIST
61987: LIST
61988: LIST
61989: LIST
61990: LIST
61991: LIST
61992: LIST
61993: LIST
61994: LIST
61995: LIST
61996: LIST
61997: LIST
61998: LIST
61999: LIST
62000: LIST
62001: LIST
62002: LIST
62003: LIST
62004: LIST
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: LIST
62010: LIST
62011: LIST
62012: LIST
62013: LIST
62014: LIST
62015: LIST
62016: LIST
62017: ST_TO_ADDR
62018: GO 62021
62020: POP
// if state > - 1 and state < 3 then
62021: LD_VAR 0 3
62025: PUSH
62026: LD_INT 1
62028: NEG
62029: GREATER
62030: PUSH
62031: LD_VAR 0 3
62035: PUSH
62036: LD_INT 3
62038: LESS
62039: AND
62040: IFFALSE 62097
// for i in result do
62042: LD_ADDR_VAR 0 5
62046: PUSH
62047: LD_VAR 0 4
62051: PUSH
62052: FOR_IN
62053: IFFALSE 62095
// if GetTech ( i , side ) <> state then
62055: LD_VAR 0 5
62059: PPUSH
62060: LD_VAR 0 1
62064: PPUSH
62065: CALL_OW 321
62069: PUSH
62070: LD_VAR 0 3
62074: NONEQUAL
62075: IFFALSE 62093
// result := result diff i ;
62077: LD_ADDR_VAR 0 4
62081: PUSH
62082: LD_VAR 0 4
62086: PUSH
62087: LD_VAR 0 5
62091: DIFF
62092: ST_TO_ADDR
62093: GO 62052
62095: POP
62096: POP
// end ;
62097: LD_VAR 0 4
62101: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
62102: LD_INT 0
62104: PPUSH
62105: PPUSH
62106: PPUSH
// result := true ;
62107: LD_ADDR_VAR 0 3
62111: PUSH
62112: LD_INT 1
62114: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
62115: LD_ADDR_VAR 0 5
62119: PUSH
62120: LD_VAR 0 2
62124: PPUSH
62125: CALL_OW 480
62129: ST_TO_ADDR
// if not tmp then
62130: LD_VAR 0 5
62134: NOT
62135: IFFALSE 62139
// exit ;
62137: GO 62188
// for i in tmp do
62139: LD_ADDR_VAR 0 4
62143: PUSH
62144: LD_VAR 0 5
62148: PUSH
62149: FOR_IN
62150: IFFALSE 62186
// if GetTech ( i , side ) <> state_researched then
62152: LD_VAR 0 4
62156: PPUSH
62157: LD_VAR 0 1
62161: PPUSH
62162: CALL_OW 321
62166: PUSH
62167: LD_INT 2
62169: NONEQUAL
62170: IFFALSE 62184
// begin result := false ;
62172: LD_ADDR_VAR 0 3
62176: PUSH
62177: LD_INT 0
62179: ST_TO_ADDR
// exit ;
62180: POP
62181: POP
62182: GO 62188
// end ;
62184: GO 62149
62186: POP
62187: POP
// end ;
62188: LD_VAR 0 3
62192: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
62193: LD_INT 0
62195: PPUSH
62196: PPUSH
62197: PPUSH
62198: PPUSH
62199: PPUSH
62200: PPUSH
62201: PPUSH
62202: PPUSH
62203: PPUSH
62204: PPUSH
62205: PPUSH
62206: PPUSH
62207: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
62208: LD_VAR 0 1
62212: NOT
62213: PUSH
62214: LD_VAR 0 1
62218: PPUSH
62219: CALL_OW 257
62223: PUSH
62224: LD_INT 9
62226: NONEQUAL
62227: OR
62228: IFFALSE 62232
// exit ;
62230: GO 62805
// side := GetSide ( unit ) ;
62232: LD_ADDR_VAR 0 9
62236: PUSH
62237: LD_VAR 0 1
62241: PPUSH
62242: CALL_OW 255
62246: ST_TO_ADDR
// tech_space := tech_spacanom ;
62247: LD_ADDR_VAR 0 12
62251: PUSH
62252: LD_INT 29
62254: ST_TO_ADDR
// tech_time := tech_taurad ;
62255: LD_ADDR_VAR 0 13
62259: PUSH
62260: LD_INT 28
62262: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
62263: LD_ADDR_VAR 0 11
62267: PUSH
62268: LD_VAR 0 1
62272: PPUSH
62273: CALL_OW 310
62277: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
62278: LD_VAR 0 11
62282: PPUSH
62283: CALL_OW 247
62287: PUSH
62288: LD_INT 2
62290: EQUAL
62291: IFFALSE 62295
// exit ;
62293: GO 62805
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62295: LD_ADDR_VAR 0 8
62299: PUSH
62300: LD_INT 81
62302: PUSH
62303: LD_VAR 0 9
62307: PUSH
62308: EMPTY
62309: LIST
62310: LIST
62311: PUSH
62312: LD_INT 3
62314: PUSH
62315: LD_INT 21
62317: PUSH
62318: LD_INT 3
62320: PUSH
62321: EMPTY
62322: LIST
62323: LIST
62324: PUSH
62325: EMPTY
62326: LIST
62327: LIST
62328: PUSH
62329: EMPTY
62330: LIST
62331: LIST
62332: PPUSH
62333: CALL_OW 69
62337: ST_TO_ADDR
// if not tmp then
62338: LD_VAR 0 8
62342: NOT
62343: IFFALSE 62347
// exit ;
62345: GO 62805
// if in_unit then
62347: LD_VAR 0 11
62351: IFFALSE 62375
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
62353: LD_ADDR_VAR 0 10
62357: PUSH
62358: LD_VAR 0 8
62362: PPUSH
62363: LD_VAR 0 11
62367: PPUSH
62368: CALL_OW 74
62372: ST_TO_ADDR
62373: GO 62395
// enemy := NearestUnitToUnit ( tmp , unit ) ;
62375: LD_ADDR_VAR 0 10
62379: PUSH
62380: LD_VAR 0 8
62384: PPUSH
62385: LD_VAR 0 1
62389: PPUSH
62390: CALL_OW 74
62394: ST_TO_ADDR
// if not enemy then
62395: LD_VAR 0 10
62399: NOT
62400: IFFALSE 62404
// exit ;
62402: GO 62805
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
62404: LD_VAR 0 11
62408: PUSH
62409: LD_VAR 0 11
62413: PPUSH
62414: LD_VAR 0 10
62418: PPUSH
62419: CALL_OW 296
62423: PUSH
62424: LD_INT 13
62426: GREATER
62427: AND
62428: PUSH
62429: LD_VAR 0 1
62433: PPUSH
62434: LD_VAR 0 10
62438: PPUSH
62439: CALL_OW 296
62443: PUSH
62444: LD_INT 12
62446: GREATER
62447: OR
62448: IFFALSE 62452
// exit ;
62450: GO 62805
// missile := [ 1 ] ;
62452: LD_ADDR_VAR 0 14
62456: PUSH
62457: LD_INT 1
62459: PUSH
62460: EMPTY
62461: LIST
62462: ST_TO_ADDR
// if Researched ( side , tech_space ) then
62463: LD_VAR 0 9
62467: PPUSH
62468: LD_VAR 0 12
62472: PPUSH
62473: CALL_OW 325
62477: IFFALSE 62506
// missile := Insert ( missile , missile + 1 , 2 ) ;
62479: LD_ADDR_VAR 0 14
62483: PUSH
62484: LD_VAR 0 14
62488: PPUSH
62489: LD_VAR 0 14
62493: PUSH
62494: LD_INT 1
62496: PLUS
62497: PPUSH
62498: LD_INT 2
62500: PPUSH
62501: CALL_OW 2
62505: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
62506: LD_VAR 0 9
62510: PPUSH
62511: LD_VAR 0 13
62515: PPUSH
62516: CALL_OW 325
62520: PUSH
62521: LD_VAR 0 10
62525: PPUSH
62526: CALL_OW 255
62530: PPUSH
62531: LD_VAR 0 13
62535: PPUSH
62536: CALL_OW 325
62540: NOT
62541: AND
62542: IFFALSE 62571
// missile := Insert ( missile , missile + 1 , 3 ) ;
62544: LD_ADDR_VAR 0 14
62548: PUSH
62549: LD_VAR 0 14
62553: PPUSH
62554: LD_VAR 0 14
62558: PUSH
62559: LD_INT 1
62561: PLUS
62562: PPUSH
62563: LD_INT 3
62565: PPUSH
62566: CALL_OW 2
62570: ST_TO_ADDR
// if missile < 2 then
62571: LD_VAR 0 14
62575: PUSH
62576: LD_INT 2
62578: LESS
62579: IFFALSE 62583
// exit ;
62581: GO 62805
// x := GetX ( enemy ) ;
62583: LD_ADDR_VAR 0 4
62587: PUSH
62588: LD_VAR 0 10
62592: PPUSH
62593: CALL_OW 250
62597: ST_TO_ADDR
// y := GetY ( enemy ) ;
62598: LD_ADDR_VAR 0 5
62602: PUSH
62603: LD_VAR 0 10
62607: PPUSH
62608: CALL_OW 251
62612: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
62613: LD_ADDR_VAR 0 6
62617: PUSH
62618: LD_VAR 0 4
62622: PUSH
62623: LD_INT 1
62625: NEG
62626: PPUSH
62627: LD_INT 1
62629: PPUSH
62630: CALL_OW 12
62634: PLUS
62635: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
62636: LD_ADDR_VAR 0 7
62640: PUSH
62641: LD_VAR 0 5
62645: PUSH
62646: LD_INT 1
62648: NEG
62649: PPUSH
62650: LD_INT 1
62652: PPUSH
62653: CALL_OW 12
62657: PLUS
62658: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62659: LD_VAR 0 6
62663: PPUSH
62664: LD_VAR 0 7
62668: PPUSH
62669: CALL_OW 488
62673: NOT
62674: IFFALSE 62696
// begin _x := x ;
62676: LD_ADDR_VAR 0 6
62680: PUSH
62681: LD_VAR 0 4
62685: ST_TO_ADDR
// _y := y ;
62686: LD_ADDR_VAR 0 7
62690: PUSH
62691: LD_VAR 0 5
62695: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
62696: LD_ADDR_VAR 0 3
62700: PUSH
62701: LD_INT 1
62703: PPUSH
62704: LD_VAR 0 14
62708: PPUSH
62709: CALL_OW 12
62713: ST_TO_ADDR
// case i of 1 :
62714: LD_VAR 0 3
62718: PUSH
62719: LD_INT 1
62721: DOUBLE
62722: EQUAL
62723: IFTRUE 62727
62725: GO 62744
62727: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
62728: LD_VAR 0 1
62732: PPUSH
62733: LD_VAR 0 10
62737: PPUSH
62738: CALL_OW 115
62742: GO 62805
62744: LD_INT 2
62746: DOUBLE
62747: EQUAL
62748: IFTRUE 62752
62750: GO 62774
62752: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
62753: LD_VAR 0 1
62757: PPUSH
62758: LD_VAR 0 6
62762: PPUSH
62763: LD_VAR 0 7
62767: PPUSH
62768: CALL_OW 153
62772: GO 62805
62774: LD_INT 3
62776: DOUBLE
62777: EQUAL
62778: IFTRUE 62782
62780: GO 62804
62782: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62783: LD_VAR 0 1
62787: PPUSH
62788: LD_VAR 0 6
62792: PPUSH
62793: LD_VAR 0 7
62797: PPUSH
62798: CALL_OW 154
62802: GO 62805
62804: POP
// end ;
62805: LD_VAR 0 2
62809: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62810: LD_INT 0
62812: PPUSH
62813: PPUSH
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
// if not unit or not building then
62818: LD_VAR 0 1
62822: NOT
62823: PUSH
62824: LD_VAR 0 2
62828: NOT
62829: OR
62830: IFFALSE 62834
// exit ;
62832: GO 62992
// x := GetX ( building ) ;
62834: LD_ADDR_VAR 0 5
62838: PUSH
62839: LD_VAR 0 2
62843: PPUSH
62844: CALL_OW 250
62848: ST_TO_ADDR
// y := GetY ( building ) ;
62849: LD_ADDR_VAR 0 6
62853: PUSH
62854: LD_VAR 0 2
62858: PPUSH
62859: CALL_OW 251
62863: ST_TO_ADDR
// for i = 0 to 5 do
62864: LD_ADDR_VAR 0 4
62868: PUSH
62869: DOUBLE
62870: LD_INT 0
62872: DEC
62873: ST_TO_ADDR
62874: LD_INT 5
62876: PUSH
62877: FOR_TO
62878: IFFALSE 62990
// begin _x := ShiftX ( x , i , 3 ) ;
62880: LD_ADDR_VAR 0 7
62884: PUSH
62885: LD_VAR 0 5
62889: PPUSH
62890: LD_VAR 0 4
62894: PPUSH
62895: LD_INT 3
62897: PPUSH
62898: CALL_OW 272
62902: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
62903: LD_ADDR_VAR 0 8
62907: PUSH
62908: LD_VAR 0 6
62912: PPUSH
62913: LD_VAR 0 4
62917: PPUSH
62918: LD_INT 3
62920: PPUSH
62921: CALL_OW 273
62925: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62926: LD_VAR 0 7
62930: PPUSH
62931: LD_VAR 0 8
62935: PPUSH
62936: CALL_OW 488
62940: NOT
62941: IFFALSE 62945
// continue ;
62943: GO 62877
// if HexInfo ( _x , _y ) = 0 then
62945: LD_VAR 0 7
62949: PPUSH
62950: LD_VAR 0 8
62954: PPUSH
62955: CALL_OW 428
62959: PUSH
62960: LD_INT 0
62962: EQUAL
62963: IFFALSE 62988
// begin ComMoveXY ( unit , _x , _y ) ;
62965: LD_VAR 0 1
62969: PPUSH
62970: LD_VAR 0 7
62974: PPUSH
62975: LD_VAR 0 8
62979: PPUSH
62980: CALL_OW 111
// exit ;
62984: POP
62985: POP
62986: GO 62992
// end ; end ;
62988: GO 62877
62990: POP
62991: POP
// end ;
62992: LD_VAR 0 3
62996: RET
// export function ScanBase ( side , base_area ) ; begin
62997: LD_INT 0
62999: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
63000: LD_ADDR_VAR 0 3
63004: PUSH
63005: LD_VAR 0 2
63009: PPUSH
63010: LD_INT 81
63012: PUSH
63013: LD_VAR 0 1
63017: PUSH
63018: EMPTY
63019: LIST
63020: LIST
63021: PPUSH
63022: CALL_OW 70
63026: ST_TO_ADDR
// end ;
63027: LD_VAR 0 3
63031: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
63032: LD_INT 0
63034: PPUSH
63035: PPUSH
63036: PPUSH
63037: PPUSH
// result := false ;
63038: LD_ADDR_VAR 0 2
63042: PUSH
63043: LD_INT 0
63045: ST_TO_ADDR
// side := GetSide ( unit ) ;
63046: LD_ADDR_VAR 0 3
63050: PUSH
63051: LD_VAR 0 1
63055: PPUSH
63056: CALL_OW 255
63060: ST_TO_ADDR
// nat := GetNation ( unit ) ;
63061: LD_ADDR_VAR 0 4
63065: PUSH
63066: LD_VAR 0 1
63070: PPUSH
63071: CALL_OW 248
63075: ST_TO_ADDR
// case nat of 1 :
63076: LD_VAR 0 4
63080: PUSH
63081: LD_INT 1
63083: DOUBLE
63084: EQUAL
63085: IFTRUE 63089
63087: GO 63100
63089: POP
// tech := tech_lassight ; 2 :
63090: LD_ADDR_VAR 0 5
63094: PUSH
63095: LD_INT 12
63097: ST_TO_ADDR
63098: GO 63139
63100: LD_INT 2
63102: DOUBLE
63103: EQUAL
63104: IFTRUE 63108
63106: GO 63119
63108: POP
// tech := tech_mortar ; 3 :
63109: LD_ADDR_VAR 0 5
63113: PUSH
63114: LD_INT 41
63116: ST_TO_ADDR
63117: GO 63139
63119: LD_INT 3
63121: DOUBLE
63122: EQUAL
63123: IFTRUE 63127
63125: GO 63138
63127: POP
// tech := tech_bazooka ; end ;
63128: LD_ADDR_VAR 0 5
63132: PUSH
63133: LD_INT 44
63135: ST_TO_ADDR
63136: GO 63139
63138: POP
// if Researched ( side , tech ) then
63139: LD_VAR 0 3
63143: PPUSH
63144: LD_VAR 0 5
63148: PPUSH
63149: CALL_OW 325
63153: IFFALSE 63180
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
63155: LD_ADDR_VAR 0 2
63159: PUSH
63160: LD_INT 5
63162: PUSH
63163: LD_INT 8
63165: PUSH
63166: LD_INT 9
63168: PUSH
63169: EMPTY
63170: LIST
63171: LIST
63172: LIST
63173: PUSH
63174: LD_VAR 0 4
63178: ARRAY
63179: ST_TO_ADDR
// end ;
63180: LD_VAR 0 2
63184: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
63185: LD_INT 0
63187: PPUSH
63188: PPUSH
63189: PPUSH
// if not mines then
63190: LD_VAR 0 2
63194: NOT
63195: IFFALSE 63199
// exit ;
63197: GO 63343
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63199: LD_ADDR_VAR 0 5
63203: PUSH
63204: LD_INT 81
63206: PUSH
63207: LD_VAR 0 1
63211: PUSH
63212: EMPTY
63213: LIST
63214: LIST
63215: PUSH
63216: LD_INT 3
63218: PUSH
63219: LD_INT 21
63221: PUSH
63222: LD_INT 3
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: PUSH
63233: EMPTY
63234: LIST
63235: LIST
63236: PPUSH
63237: CALL_OW 69
63241: ST_TO_ADDR
// for i in mines do
63242: LD_ADDR_VAR 0 4
63246: PUSH
63247: LD_VAR 0 2
63251: PUSH
63252: FOR_IN
63253: IFFALSE 63341
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
63255: LD_VAR 0 4
63259: PUSH
63260: LD_INT 1
63262: ARRAY
63263: PPUSH
63264: LD_VAR 0 4
63268: PUSH
63269: LD_INT 2
63271: ARRAY
63272: PPUSH
63273: CALL_OW 458
63277: NOT
63278: IFFALSE 63282
// continue ;
63280: GO 63252
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
63282: LD_VAR 0 4
63286: PUSH
63287: LD_INT 1
63289: ARRAY
63290: PPUSH
63291: LD_VAR 0 4
63295: PUSH
63296: LD_INT 2
63298: ARRAY
63299: PPUSH
63300: CALL_OW 428
63304: PUSH
63305: LD_VAR 0 5
63309: IN
63310: IFFALSE 63339
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
63312: LD_VAR 0 4
63316: PUSH
63317: LD_INT 1
63319: ARRAY
63320: PPUSH
63321: LD_VAR 0 4
63325: PUSH
63326: LD_INT 2
63328: ARRAY
63329: PPUSH
63330: LD_VAR 0 1
63334: PPUSH
63335: CALL_OW 456
// end ;
63339: GO 63252
63341: POP
63342: POP
// end ;
63343: LD_VAR 0 3
63347: RET
// export function Count ( array ) ; var i ; begin
63348: LD_INT 0
63350: PPUSH
63351: PPUSH
// result := 0 ;
63352: LD_ADDR_VAR 0 2
63356: PUSH
63357: LD_INT 0
63359: ST_TO_ADDR
// for i in array do
63360: LD_ADDR_VAR 0 3
63364: PUSH
63365: LD_VAR 0 1
63369: PUSH
63370: FOR_IN
63371: IFFALSE 63395
// if i then
63373: LD_VAR 0 3
63377: IFFALSE 63393
// result := result + 1 ;
63379: LD_ADDR_VAR 0 2
63383: PUSH
63384: LD_VAR 0 2
63388: PUSH
63389: LD_INT 1
63391: PLUS
63392: ST_TO_ADDR
63393: GO 63370
63395: POP
63396: POP
// end ;
63397: LD_VAR 0 2
63401: RET
// export function IsEmpty ( building ) ; begin
63402: LD_INT 0
63404: PPUSH
// if not building then
63405: LD_VAR 0 1
63409: NOT
63410: IFFALSE 63414
// exit ;
63412: GO 63457
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
63414: LD_ADDR_VAR 0 2
63418: PUSH
63419: LD_VAR 0 1
63423: PUSH
63424: LD_INT 22
63426: PUSH
63427: LD_VAR 0 1
63431: PPUSH
63432: CALL_OW 255
63436: PUSH
63437: EMPTY
63438: LIST
63439: LIST
63440: PUSH
63441: LD_INT 58
63443: PUSH
63444: EMPTY
63445: LIST
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: PPUSH
63451: CALL_OW 69
63455: IN
63456: ST_TO_ADDR
// end ;
63457: LD_VAR 0 2
63461: RET
// export function IsNotFull ( building ) ; begin
63462: LD_INT 0
63464: PPUSH
// if not building then
63465: LD_VAR 0 1
63469: NOT
63470: IFFALSE 63474
// exit ;
63472: GO 63493
// result := UnitsInside ( building ) < 6 ;
63474: LD_ADDR_VAR 0 2
63478: PUSH
63479: LD_VAR 0 1
63483: PPUSH
63484: CALL_OW 313
63488: PUSH
63489: LD_INT 6
63491: LESS
63492: ST_TO_ADDR
// end ;
63493: LD_VAR 0 2
63497: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
63498: LD_INT 0
63500: PPUSH
63501: PPUSH
63502: PPUSH
63503: PPUSH
// tmp := [ ] ;
63504: LD_ADDR_VAR 0 3
63508: PUSH
63509: EMPTY
63510: ST_TO_ADDR
// list := [ ] ;
63511: LD_ADDR_VAR 0 5
63515: PUSH
63516: EMPTY
63517: ST_TO_ADDR
// for i = 16 to 25 do
63518: LD_ADDR_VAR 0 4
63522: PUSH
63523: DOUBLE
63524: LD_INT 16
63526: DEC
63527: ST_TO_ADDR
63528: LD_INT 25
63530: PUSH
63531: FOR_TO
63532: IFFALSE 63605
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
63534: LD_ADDR_VAR 0 3
63538: PUSH
63539: LD_VAR 0 3
63543: PUSH
63544: LD_INT 22
63546: PUSH
63547: LD_VAR 0 1
63551: PPUSH
63552: CALL_OW 255
63556: PUSH
63557: EMPTY
63558: LIST
63559: LIST
63560: PUSH
63561: LD_INT 91
63563: PUSH
63564: LD_VAR 0 1
63568: PUSH
63569: LD_INT 6
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 30
63579: PUSH
63580: LD_VAR 0 4
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: PUSH
63589: EMPTY
63590: LIST
63591: LIST
63592: LIST
63593: PUSH
63594: EMPTY
63595: LIST
63596: PPUSH
63597: CALL_OW 69
63601: ADD
63602: ST_TO_ADDR
63603: GO 63531
63605: POP
63606: POP
// for i = 1 to tmp do
63607: LD_ADDR_VAR 0 4
63611: PUSH
63612: DOUBLE
63613: LD_INT 1
63615: DEC
63616: ST_TO_ADDR
63617: LD_VAR 0 3
63621: PUSH
63622: FOR_TO
63623: IFFALSE 63711
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
63625: LD_ADDR_VAR 0 5
63629: PUSH
63630: LD_VAR 0 5
63634: PUSH
63635: LD_VAR 0 3
63639: PUSH
63640: LD_VAR 0 4
63644: ARRAY
63645: PPUSH
63646: CALL_OW 266
63650: PUSH
63651: LD_VAR 0 3
63655: PUSH
63656: LD_VAR 0 4
63660: ARRAY
63661: PPUSH
63662: CALL_OW 250
63666: PUSH
63667: LD_VAR 0 3
63671: PUSH
63672: LD_VAR 0 4
63676: ARRAY
63677: PPUSH
63678: CALL_OW 251
63682: PUSH
63683: LD_VAR 0 3
63687: PUSH
63688: LD_VAR 0 4
63692: ARRAY
63693: PPUSH
63694: CALL_OW 254
63698: PUSH
63699: EMPTY
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: PUSH
63705: EMPTY
63706: LIST
63707: ADD
63708: ST_TO_ADDR
63709: GO 63622
63711: POP
63712: POP
// result := list ;
63713: LD_ADDR_VAR 0 2
63717: PUSH
63718: LD_VAR 0 5
63722: ST_TO_ADDR
// end ;
63723: LD_VAR 0 2
63727: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
63728: LD_INT 0
63730: PPUSH
63731: PPUSH
63732: PPUSH
63733: PPUSH
63734: PPUSH
63735: PPUSH
63736: PPUSH
// if not factory then
63737: LD_VAR 0 1
63741: NOT
63742: IFFALSE 63746
// exit ;
63744: GO 64339
// if control = control_apeman then
63746: LD_VAR 0 4
63750: PUSH
63751: LD_INT 5
63753: EQUAL
63754: IFFALSE 63863
// begin tmp := UnitsInside ( factory ) ;
63756: LD_ADDR_VAR 0 8
63760: PUSH
63761: LD_VAR 0 1
63765: PPUSH
63766: CALL_OW 313
63770: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
63771: LD_VAR 0 8
63775: PPUSH
63776: LD_INT 25
63778: PUSH
63779: LD_INT 12
63781: PUSH
63782: EMPTY
63783: LIST
63784: LIST
63785: PPUSH
63786: CALL_OW 72
63790: NOT
63791: IFFALSE 63801
// control := control_manual ;
63793: LD_ADDR_VAR 0 4
63797: PUSH
63798: LD_INT 1
63800: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
63801: LD_ADDR_VAR 0 8
63805: PUSH
63806: LD_VAR 0 1
63810: PPUSH
63811: CALL 63498 0 1
63815: ST_TO_ADDR
// if tmp then
63816: LD_VAR 0 8
63820: IFFALSE 63863
// begin for i in tmp do
63822: LD_ADDR_VAR 0 7
63826: PUSH
63827: LD_VAR 0 8
63831: PUSH
63832: FOR_IN
63833: IFFALSE 63861
// if i [ 1 ] = b_ext_radio then
63835: LD_VAR 0 7
63839: PUSH
63840: LD_INT 1
63842: ARRAY
63843: PUSH
63844: LD_INT 22
63846: EQUAL
63847: IFFALSE 63859
// begin control := control_remote ;
63849: LD_ADDR_VAR 0 4
63853: PUSH
63854: LD_INT 2
63856: ST_TO_ADDR
// break ;
63857: GO 63861
// end ;
63859: GO 63832
63861: POP
63862: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63863: LD_VAR 0 1
63867: PPUSH
63868: LD_VAR 0 2
63872: PPUSH
63873: LD_VAR 0 3
63877: PPUSH
63878: LD_VAR 0 4
63882: PPUSH
63883: LD_VAR 0 5
63887: PPUSH
63888: CALL_OW 448
63892: IFFALSE 63927
// begin result := [ chassis , engine , control , weapon ] ;
63894: LD_ADDR_VAR 0 6
63898: PUSH
63899: LD_VAR 0 2
63903: PUSH
63904: LD_VAR 0 3
63908: PUSH
63909: LD_VAR 0 4
63913: PUSH
63914: LD_VAR 0 5
63918: PUSH
63919: EMPTY
63920: LIST
63921: LIST
63922: LIST
63923: LIST
63924: ST_TO_ADDR
// exit ;
63925: GO 64339
// end ; _chassis := AvailableChassisList ( factory ) ;
63927: LD_ADDR_VAR 0 9
63931: PUSH
63932: LD_VAR 0 1
63936: PPUSH
63937: CALL_OW 475
63941: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
63942: LD_ADDR_VAR 0 11
63946: PUSH
63947: LD_VAR 0 1
63951: PPUSH
63952: CALL_OW 476
63956: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
63957: LD_ADDR_VAR 0 12
63961: PUSH
63962: LD_VAR 0 1
63966: PPUSH
63967: CALL_OW 477
63971: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
63972: LD_ADDR_VAR 0 10
63976: PUSH
63977: LD_VAR 0 1
63981: PPUSH
63982: CALL_OW 478
63986: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
63987: LD_VAR 0 9
63991: NOT
63992: PUSH
63993: LD_VAR 0 11
63997: NOT
63998: OR
63999: PUSH
64000: LD_VAR 0 12
64004: NOT
64005: OR
64006: PUSH
64007: LD_VAR 0 10
64011: NOT
64012: OR
64013: IFFALSE 64048
// begin result := [ chassis , engine , control , weapon ] ;
64015: LD_ADDR_VAR 0 6
64019: PUSH
64020: LD_VAR 0 2
64024: PUSH
64025: LD_VAR 0 3
64029: PUSH
64030: LD_VAR 0 4
64034: PUSH
64035: LD_VAR 0 5
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: ST_TO_ADDR
// exit ;
64046: GO 64339
// end ; if not chassis in _chassis then
64048: LD_VAR 0 2
64052: PUSH
64053: LD_VAR 0 9
64057: IN
64058: NOT
64059: IFFALSE 64085
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
64061: LD_ADDR_VAR 0 2
64065: PUSH
64066: LD_VAR 0 9
64070: PUSH
64071: LD_INT 1
64073: PPUSH
64074: LD_VAR 0 9
64078: PPUSH
64079: CALL_OW 12
64083: ARRAY
64084: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
64085: LD_VAR 0 2
64089: PPUSH
64090: LD_VAR 0 3
64094: PPUSH
64095: CALL 64344 0 2
64099: NOT
64100: IFFALSE 64159
// repeat engine := _engine [ 1 ] ;
64102: LD_ADDR_VAR 0 3
64106: PUSH
64107: LD_VAR 0 11
64111: PUSH
64112: LD_INT 1
64114: ARRAY
64115: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
64116: LD_ADDR_VAR 0 11
64120: PUSH
64121: LD_VAR 0 11
64125: PPUSH
64126: LD_INT 1
64128: PPUSH
64129: CALL_OW 3
64133: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
64134: LD_VAR 0 2
64138: PPUSH
64139: LD_VAR 0 3
64143: PPUSH
64144: CALL 64344 0 2
64148: PUSH
64149: LD_VAR 0 11
64153: PUSH
64154: EMPTY
64155: EQUAL
64156: OR
64157: IFFALSE 64102
// if not control in _control then
64159: LD_VAR 0 4
64163: PUSH
64164: LD_VAR 0 12
64168: IN
64169: NOT
64170: IFFALSE 64196
// control := _control [ rand ( 1 , _control ) ] ;
64172: LD_ADDR_VAR 0 4
64176: PUSH
64177: LD_VAR 0 12
64181: PUSH
64182: LD_INT 1
64184: PPUSH
64185: LD_VAR 0 12
64189: PPUSH
64190: CALL_OW 12
64194: ARRAY
64195: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
64196: LD_VAR 0 2
64200: PPUSH
64201: LD_VAR 0 5
64205: PPUSH
64206: CALL 64564 0 2
64210: NOT
64211: IFFALSE 64270
// repeat weapon := _weapon [ 1 ] ;
64213: LD_ADDR_VAR 0 5
64217: PUSH
64218: LD_VAR 0 10
64222: PUSH
64223: LD_INT 1
64225: ARRAY
64226: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
64227: LD_ADDR_VAR 0 10
64231: PUSH
64232: LD_VAR 0 10
64236: PPUSH
64237: LD_INT 1
64239: PPUSH
64240: CALL_OW 3
64244: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
64245: LD_VAR 0 2
64249: PPUSH
64250: LD_VAR 0 5
64254: PPUSH
64255: CALL 64564 0 2
64259: PUSH
64260: LD_VAR 0 10
64264: PUSH
64265: EMPTY
64266: EQUAL
64267: OR
64268: IFFALSE 64213
// result := [ ] ;
64270: LD_ADDR_VAR 0 6
64274: PUSH
64275: EMPTY
64276: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
64277: LD_VAR 0 1
64281: PPUSH
64282: LD_VAR 0 2
64286: PPUSH
64287: LD_VAR 0 3
64291: PPUSH
64292: LD_VAR 0 4
64296: PPUSH
64297: LD_VAR 0 5
64301: PPUSH
64302: CALL_OW 448
64306: IFFALSE 64339
// result := [ chassis , engine , control , weapon ] ;
64308: LD_ADDR_VAR 0 6
64312: PUSH
64313: LD_VAR 0 2
64317: PUSH
64318: LD_VAR 0 3
64322: PUSH
64323: LD_VAR 0 4
64327: PUSH
64328: LD_VAR 0 5
64332: PUSH
64333: EMPTY
64334: LIST
64335: LIST
64336: LIST
64337: LIST
64338: ST_TO_ADDR
// end ;
64339: LD_VAR 0 6
64343: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
64344: LD_INT 0
64346: PPUSH
// if not chassis or not engine then
64347: LD_VAR 0 1
64351: NOT
64352: PUSH
64353: LD_VAR 0 2
64357: NOT
64358: OR
64359: IFFALSE 64363
// exit ;
64361: GO 64559
// case engine of engine_solar :
64363: LD_VAR 0 2
64367: PUSH
64368: LD_INT 2
64370: DOUBLE
64371: EQUAL
64372: IFTRUE 64376
64374: GO 64414
64376: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
64377: LD_ADDR_VAR 0 3
64381: PUSH
64382: LD_INT 11
64384: PUSH
64385: LD_INT 12
64387: PUSH
64388: LD_INT 13
64390: PUSH
64391: LD_INT 14
64393: PUSH
64394: LD_INT 1
64396: PUSH
64397: LD_INT 2
64399: PUSH
64400: LD_INT 3
64402: PUSH
64403: EMPTY
64404: LIST
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: LIST
64410: LIST
64411: ST_TO_ADDR
64412: GO 64543
64414: LD_INT 1
64416: DOUBLE
64417: EQUAL
64418: IFTRUE 64422
64420: GO 64484
64422: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
64423: LD_ADDR_VAR 0 3
64427: PUSH
64428: LD_INT 11
64430: PUSH
64431: LD_INT 12
64433: PUSH
64434: LD_INT 13
64436: PUSH
64437: LD_INT 14
64439: PUSH
64440: LD_INT 1
64442: PUSH
64443: LD_INT 2
64445: PUSH
64446: LD_INT 3
64448: PUSH
64449: LD_INT 4
64451: PUSH
64452: LD_INT 5
64454: PUSH
64455: LD_INT 21
64457: PUSH
64458: LD_INT 23
64460: PUSH
64461: LD_INT 22
64463: PUSH
64464: LD_INT 24
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: ST_TO_ADDR
64482: GO 64543
64484: LD_INT 3
64486: DOUBLE
64487: EQUAL
64488: IFTRUE 64492
64490: GO 64542
64492: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
64493: LD_ADDR_VAR 0 3
64497: PUSH
64498: LD_INT 13
64500: PUSH
64501: LD_INT 14
64503: PUSH
64504: LD_INT 2
64506: PUSH
64507: LD_INT 3
64509: PUSH
64510: LD_INT 4
64512: PUSH
64513: LD_INT 5
64515: PUSH
64516: LD_INT 21
64518: PUSH
64519: LD_INT 22
64521: PUSH
64522: LD_INT 23
64524: PUSH
64525: LD_INT 24
64527: PUSH
64528: EMPTY
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: ST_TO_ADDR
64540: GO 64543
64542: POP
// result := ( chassis in result ) ;
64543: LD_ADDR_VAR 0 3
64547: PUSH
64548: LD_VAR 0 1
64552: PUSH
64553: LD_VAR 0 3
64557: IN
64558: ST_TO_ADDR
// end ;
64559: LD_VAR 0 3
64563: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
64564: LD_INT 0
64566: PPUSH
// if not chassis or not weapon then
64567: LD_VAR 0 1
64571: NOT
64572: PUSH
64573: LD_VAR 0 2
64577: NOT
64578: OR
64579: IFFALSE 64583
// exit ;
64581: GO 65645
// case weapon of us_machine_gun :
64583: LD_VAR 0 2
64587: PUSH
64588: LD_INT 2
64590: DOUBLE
64591: EQUAL
64592: IFTRUE 64596
64594: GO 64626
64596: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
64597: LD_ADDR_VAR 0 3
64601: PUSH
64602: LD_INT 1
64604: PUSH
64605: LD_INT 2
64607: PUSH
64608: LD_INT 3
64610: PUSH
64611: LD_INT 4
64613: PUSH
64614: LD_INT 5
64616: PUSH
64617: EMPTY
64618: LIST
64619: LIST
64620: LIST
64621: LIST
64622: LIST
64623: ST_TO_ADDR
64624: GO 65629
64626: LD_INT 3
64628: DOUBLE
64629: EQUAL
64630: IFTRUE 64634
64632: GO 64664
64634: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
64635: LD_ADDR_VAR 0 3
64639: PUSH
64640: LD_INT 1
64642: PUSH
64643: LD_INT 2
64645: PUSH
64646: LD_INT 3
64648: PUSH
64649: LD_INT 4
64651: PUSH
64652: LD_INT 5
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: LIST
64659: LIST
64660: LIST
64661: ST_TO_ADDR
64662: GO 65629
64664: LD_INT 11
64666: DOUBLE
64667: EQUAL
64668: IFTRUE 64672
64670: GO 64702
64672: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
64673: LD_ADDR_VAR 0 3
64677: PUSH
64678: LD_INT 1
64680: PUSH
64681: LD_INT 2
64683: PUSH
64684: LD_INT 3
64686: PUSH
64687: LD_INT 4
64689: PUSH
64690: LD_INT 5
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: ST_TO_ADDR
64700: GO 65629
64702: LD_INT 4
64704: DOUBLE
64705: EQUAL
64706: IFTRUE 64710
64708: GO 64736
64710: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
64711: LD_ADDR_VAR 0 3
64715: PUSH
64716: LD_INT 2
64718: PUSH
64719: LD_INT 3
64721: PUSH
64722: LD_INT 4
64724: PUSH
64725: LD_INT 5
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: LIST
64732: LIST
64733: ST_TO_ADDR
64734: GO 65629
64736: LD_INT 5
64738: DOUBLE
64739: EQUAL
64740: IFTRUE 64744
64742: GO 64770
64744: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
64745: LD_ADDR_VAR 0 3
64749: PUSH
64750: LD_INT 2
64752: PUSH
64753: LD_INT 3
64755: PUSH
64756: LD_INT 4
64758: PUSH
64759: LD_INT 5
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: ST_TO_ADDR
64768: GO 65629
64770: LD_INT 9
64772: DOUBLE
64773: EQUAL
64774: IFTRUE 64778
64776: GO 64804
64778: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
64779: LD_ADDR_VAR 0 3
64783: PUSH
64784: LD_INT 2
64786: PUSH
64787: LD_INT 3
64789: PUSH
64790: LD_INT 4
64792: PUSH
64793: LD_INT 5
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: ST_TO_ADDR
64802: GO 65629
64804: LD_INT 7
64806: DOUBLE
64807: EQUAL
64808: IFTRUE 64812
64810: GO 64838
64812: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
64813: LD_ADDR_VAR 0 3
64817: PUSH
64818: LD_INT 2
64820: PUSH
64821: LD_INT 3
64823: PUSH
64824: LD_INT 4
64826: PUSH
64827: LD_INT 5
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: LIST
64834: LIST
64835: ST_TO_ADDR
64836: GO 65629
64838: LD_INT 12
64840: DOUBLE
64841: EQUAL
64842: IFTRUE 64846
64844: GO 64872
64846: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
64847: LD_ADDR_VAR 0 3
64851: PUSH
64852: LD_INT 2
64854: PUSH
64855: LD_INT 3
64857: PUSH
64858: LD_INT 4
64860: PUSH
64861: LD_INT 5
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: ST_TO_ADDR
64870: GO 65629
64872: LD_INT 13
64874: DOUBLE
64875: EQUAL
64876: IFTRUE 64880
64878: GO 64906
64880: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
64881: LD_ADDR_VAR 0 3
64885: PUSH
64886: LD_INT 2
64888: PUSH
64889: LD_INT 3
64891: PUSH
64892: LD_INT 4
64894: PUSH
64895: LD_INT 5
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: LIST
64902: LIST
64903: ST_TO_ADDR
64904: GO 65629
64906: LD_INT 14
64908: DOUBLE
64909: EQUAL
64910: IFTRUE 64914
64912: GO 64932
64914: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
64915: LD_ADDR_VAR 0 3
64919: PUSH
64920: LD_INT 4
64922: PUSH
64923: LD_INT 5
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: ST_TO_ADDR
64930: GO 65629
64932: LD_INT 6
64934: DOUBLE
64935: EQUAL
64936: IFTRUE 64940
64938: GO 64958
64940: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
64941: LD_ADDR_VAR 0 3
64945: PUSH
64946: LD_INT 4
64948: PUSH
64949: LD_INT 5
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: ST_TO_ADDR
64956: GO 65629
64958: LD_INT 10
64960: DOUBLE
64961: EQUAL
64962: IFTRUE 64966
64964: GO 64984
64966: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
64967: LD_ADDR_VAR 0 3
64971: PUSH
64972: LD_INT 4
64974: PUSH
64975: LD_INT 5
64977: PUSH
64978: EMPTY
64979: LIST
64980: LIST
64981: ST_TO_ADDR
64982: GO 65629
64984: LD_INT 22
64986: DOUBLE
64987: EQUAL
64988: IFTRUE 64992
64990: GO 65018
64992: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
64993: LD_ADDR_VAR 0 3
64997: PUSH
64998: LD_INT 11
65000: PUSH
65001: LD_INT 12
65003: PUSH
65004: LD_INT 13
65006: PUSH
65007: LD_INT 14
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: ST_TO_ADDR
65016: GO 65629
65018: LD_INT 23
65020: DOUBLE
65021: EQUAL
65022: IFTRUE 65026
65024: GO 65052
65026: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
65027: LD_ADDR_VAR 0 3
65031: PUSH
65032: LD_INT 11
65034: PUSH
65035: LD_INT 12
65037: PUSH
65038: LD_INT 13
65040: PUSH
65041: LD_INT 14
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: LIST
65048: LIST
65049: ST_TO_ADDR
65050: GO 65629
65052: LD_INT 24
65054: DOUBLE
65055: EQUAL
65056: IFTRUE 65060
65058: GO 65086
65060: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
65061: LD_ADDR_VAR 0 3
65065: PUSH
65066: LD_INT 11
65068: PUSH
65069: LD_INT 12
65071: PUSH
65072: LD_INT 13
65074: PUSH
65075: LD_INT 14
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: LIST
65082: LIST
65083: ST_TO_ADDR
65084: GO 65629
65086: LD_INT 30
65088: DOUBLE
65089: EQUAL
65090: IFTRUE 65094
65092: GO 65120
65094: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
65095: LD_ADDR_VAR 0 3
65099: PUSH
65100: LD_INT 11
65102: PUSH
65103: LD_INT 12
65105: PUSH
65106: LD_INT 13
65108: PUSH
65109: LD_INT 14
65111: PUSH
65112: EMPTY
65113: LIST
65114: LIST
65115: LIST
65116: LIST
65117: ST_TO_ADDR
65118: GO 65629
65120: LD_INT 25
65122: DOUBLE
65123: EQUAL
65124: IFTRUE 65128
65126: GO 65146
65128: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
65129: LD_ADDR_VAR 0 3
65133: PUSH
65134: LD_INT 13
65136: PUSH
65137: LD_INT 14
65139: PUSH
65140: EMPTY
65141: LIST
65142: LIST
65143: ST_TO_ADDR
65144: GO 65629
65146: LD_INT 27
65148: DOUBLE
65149: EQUAL
65150: IFTRUE 65154
65152: GO 65172
65154: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
65155: LD_ADDR_VAR 0 3
65159: PUSH
65160: LD_INT 13
65162: PUSH
65163: LD_INT 14
65165: PUSH
65166: EMPTY
65167: LIST
65168: LIST
65169: ST_TO_ADDR
65170: GO 65629
65172: LD_EXP 78
65176: DOUBLE
65177: EQUAL
65178: IFTRUE 65182
65180: GO 65208
65182: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
65183: LD_ADDR_VAR 0 3
65187: PUSH
65188: LD_INT 11
65190: PUSH
65191: LD_INT 12
65193: PUSH
65194: LD_INT 13
65196: PUSH
65197: LD_INT 14
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: LIST
65204: LIST
65205: ST_TO_ADDR
65206: GO 65629
65208: LD_INT 28
65210: DOUBLE
65211: EQUAL
65212: IFTRUE 65216
65214: GO 65234
65216: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
65217: LD_ADDR_VAR 0 3
65221: PUSH
65222: LD_INT 13
65224: PUSH
65225: LD_INT 14
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: ST_TO_ADDR
65232: GO 65629
65234: LD_INT 29
65236: DOUBLE
65237: EQUAL
65238: IFTRUE 65242
65240: GO 65260
65242: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
65243: LD_ADDR_VAR 0 3
65247: PUSH
65248: LD_INT 13
65250: PUSH
65251: LD_INT 14
65253: PUSH
65254: EMPTY
65255: LIST
65256: LIST
65257: ST_TO_ADDR
65258: GO 65629
65260: LD_INT 31
65262: DOUBLE
65263: EQUAL
65264: IFTRUE 65268
65266: GO 65286
65268: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
65269: LD_ADDR_VAR 0 3
65273: PUSH
65274: LD_INT 13
65276: PUSH
65277: LD_INT 14
65279: PUSH
65280: EMPTY
65281: LIST
65282: LIST
65283: ST_TO_ADDR
65284: GO 65629
65286: LD_INT 26
65288: DOUBLE
65289: EQUAL
65290: IFTRUE 65294
65292: GO 65312
65294: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
65295: LD_ADDR_VAR 0 3
65299: PUSH
65300: LD_INT 13
65302: PUSH
65303: LD_INT 14
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: ST_TO_ADDR
65310: GO 65629
65312: LD_INT 42
65314: DOUBLE
65315: EQUAL
65316: IFTRUE 65320
65318: GO 65346
65320: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
65321: LD_ADDR_VAR 0 3
65325: PUSH
65326: LD_INT 21
65328: PUSH
65329: LD_INT 22
65331: PUSH
65332: LD_INT 23
65334: PUSH
65335: LD_INT 24
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: ST_TO_ADDR
65344: GO 65629
65346: LD_INT 43
65348: DOUBLE
65349: EQUAL
65350: IFTRUE 65354
65352: GO 65380
65354: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
65355: LD_ADDR_VAR 0 3
65359: PUSH
65360: LD_INT 21
65362: PUSH
65363: LD_INT 22
65365: PUSH
65366: LD_INT 23
65368: PUSH
65369: LD_INT 24
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: ST_TO_ADDR
65378: GO 65629
65380: LD_INT 44
65382: DOUBLE
65383: EQUAL
65384: IFTRUE 65388
65386: GO 65414
65388: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
65389: LD_ADDR_VAR 0 3
65393: PUSH
65394: LD_INT 21
65396: PUSH
65397: LD_INT 22
65399: PUSH
65400: LD_INT 23
65402: PUSH
65403: LD_INT 24
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: ST_TO_ADDR
65412: GO 65629
65414: LD_INT 45
65416: DOUBLE
65417: EQUAL
65418: IFTRUE 65422
65420: GO 65448
65422: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
65423: LD_ADDR_VAR 0 3
65427: PUSH
65428: LD_INT 21
65430: PUSH
65431: LD_INT 22
65433: PUSH
65434: LD_INT 23
65436: PUSH
65437: LD_INT 24
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: ST_TO_ADDR
65446: GO 65629
65448: LD_INT 49
65450: DOUBLE
65451: EQUAL
65452: IFTRUE 65456
65454: GO 65482
65456: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
65457: LD_ADDR_VAR 0 3
65461: PUSH
65462: LD_INT 21
65464: PUSH
65465: LD_INT 22
65467: PUSH
65468: LD_INT 23
65470: PUSH
65471: LD_INT 24
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: ST_TO_ADDR
65480: GO 65629
65482: LD_INT 51
65484: DOUBLE
65485: EQUAL
65486: IFTRUE 65490
65488: GO 65516
65490: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
65491: LD_ADDR_VAR 0 3
65495: PUSH
65496: LD_INT 21
65498: PUSH
65499: LD_INT 22
65501: PUSH
65502: LD_INT 23
65504: PUSH
65505: LD_INT 24
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: ST_TO_ADDR
65514: GO 65629
65516: LD_INT 52
65518: DOUBLE
65519: EQUAL
65520: IFTRUE 65524
65522: GO 65550
65524: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
65525: LD_ADDR_VAR 0 3
65529: PUSH
65530: LD_INT 21
65532: PUSH
65533: LD_INT 22
65535: PUSH
65536: LD_INT 23
65538: PUSH
65539: LD_INT 24
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: LIST
65546: LIST
65547: ST_TO_ADDR
65548: GO 65629
65550: LD_INT 53
65552: DOUBLE
65553: EQUAL
65554: IFTRUE 65558
65556: GO 65576
65558: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
65559: LD_ADDR_VAR 0 3
65563: PUSH
65564: LD_INT 23
65566: PUSH
65567: LD_INT 24
65569: PUSH
65570: EMPTY
65571: LIST
65572: LIST
65573: ST_TO_ADDR
65574: GO 65629
65576: LD_INT 46
65578: DOUBLE
65579: EQUAL
65580: IFTRUE 65584
65582: GO 65602
65584: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
65585: LD_ADDR_VAR 0 3
65589: PUSH
65590: LD_INT 23
65592: PUSH
65593: LD_INT 24
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: ST_TO_ADDR
65600: GO 65629
65602: LD_INT 47
65604: DOUBLE
65605: EQUAL
65606: IFTRUE 65610
65608: GO 65628
65610: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
65611: LD_ADDR_VAR 0 3
65615: PUSH
65616: LD_INT 23
65618: PUSH
65619: LD_INT 24
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: ST_TO_ADDR
65626: GO 65629
65628: POP
// result := ( chassis in result ) ;
65629: LD_ADDR_VAR 0 3
65633: PUSH
65634: LD_VAR 0 1
65638: PUSH
65639: LD_VAR 0 3
65643: IN
65644: ST_TO_ADDR
// end ;
65645: LD_VAR 0 3
65649: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
65650: LD_INT 0
65652: PPUSH
65653: PPUSH
65654: PPUSH
65655: PPUSH
65656: PPUSH
65657: PPUSH
65658: PPUSH
// result := array ;
65659: LD_ADDR_VAR 0 5
65663: PUSH
65664: LD_VAR 0 1
65668: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
65669: LD_VAR 0 1
65673: NOT
65674: PUSH
65675: LD_VAR 0 2
65679: NOT
65680: OR
65681: PUSH
65682: LD_VAR 0 3
65686: NOT
65687: OR
65688: PUSH
65689: LD_VAR 0 2
65693: PUSH
65694: LD_VAR 0 1
65698: GREATER
65699: OR
65700: PUSH
65701: LD_VAR 0 3
65705: PUSH
65706: LD_VAR 0 1
65710: GREATER
65711: OR
65712: IFFALSE 65716
// exit ;
65714: GO 66012
// if direction then
65716: LD_VAR 0 4
65720: IFFALSE 65784
// begin d := 1 ;
65722: LD_ADDR_VAR 0 9
65726: PUSH
65727: LD_INT 1
65729: ST_TO_ADDR
// if i_from > i_to then
65730: LD_VAR 0 2
65734: PUSH
65735: LD_VAR 0 3
65739: GREATER
65740: IFFALSE 65766
// length := ( array - i_from ) + i_to else
65742: LD_ADDR_VAR 0 11
65746: PUSH
65747: LD_VAR 0 1
65751: PUSH
65752: LD_VAR 0 2
65756: MINUS
65757: PUSH
65758: LD_VAR 0 3
65762: PLUS
65763: ST_TO_ADDR
65764: GO 65782
// length := i_to - i_from ;
65766: LD_ADDR_VAR 0 11
65770: PUSH
65771: LD_VAR 0 3
65775: PUSH
65776: LD_VAR 0 2
65780: MINUS
65781: ST_TO_ADDR
// end else
65782: GO 65845
// begin d := - 1 ;
65784: LD_ADDR_VAR 0 9
65788: PUSH
65789: LD_INT 1
65791: NEG
65792: ST_TO_ADDR
// if i_from > i_to then
65793: LD_VAR 0 2
65797: PUSH
65798: LD_VAR 0 3
65802: GREATER
65803: IFFALSE 65823
// length := i_from - i_to else
65805: LD_ADDR_VAR 0 11
65809: PUSH
65810: LD_VAR 0 2
65814: PUSH
65815: LD_VAR 0 3
65819: MINUS
65820: ST_TO_ADDR
65821: GO 65845
// length := ( array - i_to ) + i_from ;
65823: LD_ADDR_VAR 0 11
65827: PUSH
65828: LD_VAR 0 1
65832: PUSH
65833: LD_VAR 0 3
65837: MINUS
65838: PUSH
65839: LD_VAR 0 2
65843: PLUS
65844: ST_TO_ADDR
// end ; if not length then
65845: LD_VAR 0 11
65849: NOT
65850: IFFALSE 65854
// exit ;
65852: GO 66012
// tmp := array ;
65854: LD_ADDR_VAR 0 10
65858: PUSH
65859: LD_VAR 0 1
65863: ST_TO_ADDR
// for i = 1 to length do
65864: LD_ADDR_VAR 0 6
65868: PUSH
65869: DOUBLE
65870: LD_INT 1
65872: DEC
65873: ST_TO_ADDR
65874: LD_VAR 0 11
65878: PUSH
65879: FOR_TO
65880: IFFALSE 66000
// begin for j = 1 to array do
65882: LD_ADDR_VAR 0 7
65886: PUSH
65887: DOUBLE
65888: LD_INT 1
65890: DEC
65891: ST_TO_ADDR
65892: LD_VAR 0 1
65896: PUSH
65897: FOR_TO
65898: IFFALSE 65986
// begin k := j + d ;
65900: LD_ADDR_VAR 0 8
65904: PUSH
65905: LD_VAR 0 7
65909: PUSH
65910: LD_VAR 0 9
65914: PLUS
65915: ST_TO_ADDR
// if k > array then
65916: LD_VAR 0 8
65920: PUSH
65921: LD_VAR 0 1
65925: GREATER
65926: IFFALSE 65936
// k := 1 ;
65928: LD_ADDR_VAR 0 8
65932: PUSH
65933: LD_INT 1
65935: ST_TO_ADDR
// if not k then
65936: LD_VAR 0 8
65940: NOT
65941: IFFALSE 65953
// k := array ;
65943: LD_ADDR_VAR 0 8
65947: PUSH
65948: LD_VAR 0 1
65952: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
65953: LD_ADDR_VAR 0 10
65957: PUSH
65958: LD_VAR 0 10
65962: PPUSH
65963: LD_VAR 0 8
65967: PPUSH
65968: LD_VAR 0 1
65972: PUSH
65973: LD_VAR 0 7
65977: ARRAY
65978: PPUSH
65979: CALL_OW 1
65983: ST_TO_ADDR
// end ;
65984: GO 65897
65986: POP
65987: POP
// array := tmp ;
65988: LD_ADDR_VAR 0 1
65992: PUSH
65993: LD_VAR 0 10
65997: ST_TO_ADDR
// end ;
65998: GO 65879
66000: POP
66001: POP
// result := array ;
66002: LD_ADDR_VAR 0 5
66006: PUSH
66007: LD_VAR 0 1
66011: ST_TO_ADDR
// end ;
66012: LD_VAR 0 5
66016: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
66017: LD_INT 0
66019: PPUSH
66020: PPUSH
// result := 0 ;
66021: LD_ADDR_VAR 0 3
66025: PUSH
66026: LD_INT 0
66028: ST_TO_ADDR
// if not array or not value in array then
66029: LD_VAR 0 1
66033: NOT
66034: PUSH
66035: LD_VAR 0 2
66039: PUSH
66040: LD_VAR 0 1
66044: IN
66045: NOT
66046: OR
66047: IFFALSE 66051
// exit ;
66049: GO 66105
// for i = 1 to array do
66051: LD_ADDR_VAR 0 4
66055: PUSH
66056: DOUBLE
66057: LD_INT 1
66059: DEC
66060: ST_TO_ADDR
66061: LD_VAR 0 1
66065: PUSH
66066: FOR_TO
66067: IFFALSE 66103
// if value = array [ i ] then
66069: LD_VAR 0 2
66073: PUSH
66074: LD_VAR 0 1
66078: PUSH
66079: LD_VAR 0 4
66083: ARRAY
66084: EQUAL
66085: IFFALSE 66101
// begin result := i ;
66087: LD_ADDR_VAR 0 3
66091: PUSH
66092: LD_VAR 0 4
66096: ST_TO_ADDR
// exit ;
66097: POP
66098: POP
66099: GO 66105
// end ;
66101: GO 66066
66103: POP
66104: POP
// end ;
66105: LD_VAR 0 3
66109: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
66110: LD_INT 0
66112: PPUSH
// vc_chassis := chassis ;
66113: LD_ADDR_OWVAR 37
66117: PUSH
66118: LD_VAR 0 1
66122: ST_TO_ADDR
// vc_engine := engine ;
66123: LD_ADDR_OWVAR 39
66127: PUSH
66128: LD_VAR 0 2
66132: ST_TO_ADDR
// vc_control := control ;
66133: LD_ADDR_OWVAR 38
66137: PUSH
66138: LD_VAR 0 3
66142: ST_TO_ADDR
// vc_weapon := weapon ;
66143: LD_ADDR_OWVAR 40
66147: PUSH
66148: LD_VAR 0 4
66152: ST_TO_ADDR
// vc_fuel_battery := fuel ;
66153: LD_ADDR_OWVAR 41
66157: PUSH
66158: LD_VAR 0 5
66162: ST_TO_ADDR
// end ;
66163: LD_VAR 0 6
66167: RET
// export function WantPlant ( unit ) ; var task ; begin
66168: LD_INT 0
66170: PPUSH
66171: PPUSH
// result := false ;
66172: LD_ADDR_VAR 0 2
66176: PUSH
66177: LD_INT 0
66179: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
66180: LD_ADDR_VAR 0 3
66184: PUSH
66185: LD_VAR 0 1
66189: PPUSH
66190: CALL_OW 437
66194: ST_TO_ADDR
// if task then
66195: LD_VAR 0 3
66199: IFFALSE 66227
// if task [ 1 ] [ 1 ] = p then
66201: LD_VAR 0 3
66205: PUSH
66206: LD_INT 1
66208: ARRAY
66209: PUSH
66210: LD_INT 1
66212: ARRAY
66213: PUSH
66214: LD_STRING p
66216: EQUAL
66217: IFFALSE 66227
// result := true ;
66219: LD_ADDR_VAR 0 2
66223: PUSH
66224: LD_INT 1
66226: ST_TO_ADDR
// end ;
66227: LD_VAR 0 2
66231: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
66232: LD_INT 0
66234: PPUSH
66235: PPUSH
66236: PPUSH
66237: PPUSH
// if pos < 1 then
66238: LD_VAR 0 2
66242: PUSH
66243: LD_INT 1
66245: LESS
66246: IFFALSE 66250
// exit ;
66248: GO 66553
// if pos = 1 then
66250: LD_VAR 0 2
66254: PUSH
66255: LD_INT 1
66257: EQUAL
66258: IFFALSE 66291
// result := Replace ( arr , pos [ 1 ] , value ) else
66260: LD_ADDR_VAR 0 4
66264: PUSH
66265: LD_VAR 0 1
66269: PPUSH
66270: LD_VAR 0 2
66274: PUSH
66275: LD_INT 1
66277: ARRAY
66278: PPUSH
66279: LD_VAR 0 3
66283: PPUSH
66284: CALL_OW 1
66288: ST_TO_ADDR
66289: GO 66553
// begin tmp := arr ;
66291: LD_ADDR_VAR 0 6
66295: PUSH
66296: LD_VAR 0 1
66300: ST_TO_ADDR
// s_arr := [ tmp ] ;
66301: LD_ADDR_VAR 0 7
66305: PUSH
66306: LD_VAR 0 6
66310: PUSH
66311: EMPTY
66312: LIST
66313: ST_TO_ADDR
// for i = 1 to pos - 1 do
66314: LD_ADDR_VAR 0 5
66318: PUSH
66319: DOUBLE
66320: LD_INT 1
66322: DEC
66323: ST_TO_ADDR
66324: LD_VAR 0 2
66328: PUSH
66329: LD_INT 1
66331: MINUS
66332: PUSH
66333: FOR_TO
66334: IFFALSE 66379
// begin tmp := tmp [ pos [ i ] ] ;
66336: LD_ADDR_VAR 0 6
66340: PUSH
66341: LD_VAR 0 6
66345: PUSH
66346: LD_VAR 0 2
66350: PUSH
66351: LD_VAR 0 5
66355: ARRAY
66356: ARRAY
66357: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
66358: LD_ADDR_VAR 0 7
66362: PUSH
66363: LD_VAR 0 7
66367: PUSH
66368: LD_VAR 0 6
66372: PUSH
66373: EMPTY
66374: LIST
66375: ADD
66376: ST_TO_ADDR
// end ;
66377: GO 66333
66379: POP
66380: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
66381: LD_ADDR_VAR 0 6
66385: PUSH
66386: LD_VAR 0 6
66390: PPUSH
66391: LD_VAR 0 2
66395: PUSH
66396: LD_VAR 0 2
66400: ARRAY
66401: PPUSH
66402: LD_VAR 0 3
66406: PPUSH
66407: CALL_OW 1
66411: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
66412: LD_ADDR_VAR 0 7
66416: PUSH
66417: LD_VAR 0 7
66421: PPUSH
66422: LD_VAR 0 7
66426: PPUSH
66427: LD_VAR 0 6
66431: PPUSH
66432: CALL_OW 1
66436: ST_TO_ADDR
// for i = s_arr downto 2 do
66437: LD_ADDR_VAR 0 5
66441: PUSH
66442: DOUBLE
66443: LD_VAR 0 7
66447: INC
66448: ST_TO_ADDR
66449: LD_INT 2
66451: PUSH
66452: FOR_DOWNTO
66453: IFFALSE 66537
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
66455: LD_ADDR_VAR 0 6
66459: PUSH
66460: LD_VAR 0 7
66464: PUSH
66465: LD_VAR 0 5
66469: PUSH
66470: LD_INT 1
66472: MINUS
66473: ARRAY
66474: PPUSH
66475: LD_VAR 0 2
66479: PUSH
66480: LD_VAR 0 5
66484: PUSH
66485: LD_INT 1
66487: MINUS
66488: ARRAY
66489: PPUSH
66490: LD_VAR 0 7
66494: PUSH
66495: LD_VAR 0 5
66499: ARRAY
66500: PPUSH
66501: CALL_OW 1
66505: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
66506: LD_ADDR_VAR 0 7
66510: PUSH
66511: LD_VAR 0 7
66515: PPUSH
66516: LD_VAR 0 5
66520: PUSH
66521: LD_INT 1
66523: MINUS
66524: PPUSH
66525: LD_VAR 0 6
66529: PPUSH
66530: CALL_OW 1
66534: ST_TO_ADDR
// end ;
66535: GO 66452
66537: POP
66538: POP
// result := s_arr [ 1 ] ;
66539: LD_ADDR_VAR 0 4
66543: PUSH
66544: LD_VAR 0 7
66548: PUSH
66549: LD_INT 1
66551: ARRAY
66552: ST_TO_ADDR
// end ; end ;
66553: LD_VAR 0 4
66557: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
66558: LD_INT 0
66560: PPUSH
66561: PPUSH
// if not list then
66562: LD_VAR 0 1
66566: NOT
66567: IFFALSE 66571
// exit ;
66569: GO 66662
// i := list [ pos1 ] ;
66571: LD_ADDR_VAR 0 5
66575: PUSH
66576: LD_VAR 0 1
66580: PUSH
66581: LD_VAR 0 2
66585: ARRAY
66586: ST_TO_ADDR
// if not i then
66587: LD_VAR 0 5
66591: NOT
66592: IFFALSE 66596
// exit ;
66594: GO 66662
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
66596: LD_ADDR_VAR 0 1
66600: PUSH
66601: LD_VAR 0 1
66605: PPUSH
66606: LD_VAR 0 2
66610: PPUSH
66611: LD_VAR 0 1
66615: PUSH
66616: LD_VAR 0 3
66620: ARRAY
66621: PPUSH
66622: CALL_OW 1
66626: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
66627: LD_ADDR_VAR 0 1
66631: PUSH
66632: LD_VAR 0 1
66636: PPUSH
66637: LD_VAR 0 3
66641: PPUSH
66642: LD_VAR 0 5
66646: PPUSH
66647: CALL_OW 1
66651: ST_TO_ADDR
// result := list ;
66652: LD_ADDR_VAR 0 4
66656: PUSH
66657: LD_VAR 0 1
66661: ST_TO_ADDR
// end ;
66662: LD_VAR 0 4
66666: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
66667: LD_INT 0
66669: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
66670: LD_ADDR_VAR 0 5
66674: PUSH
66675: LD_VAR 0 1
66679: PPUSH
66680: CALL_OW 250
66684: PPUSH
66685: LD_VAR 0 1
66689: PPUSH
66690: CALL_OW 251
66694: PPUSH
66695: LD_VAR 0 2
66699: PPUSH
66700: LD_VAR 0 3
66704: PPUSH
66705: LD_VAR 0 4
66709: PPUSH
66710: CALL 66720 0 5
66714: ST_TO_ADDR
// end ;
66715: LD_VAR 0 5
66719: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
66720: LD_INT 0
66722: PPUSH
66723: PPUSH
66724: PPUSH
66725: PPUSH
// if not list then
66726: LD_VAR 0 3
66730: NOT
66731: IFFALSE 66735
// exit ;
66733: GO 67123
// result := [ ] ;
66735: LD_ADDR_VAR 0 6
66739: PUSH
66740: EMPTY
66741: ST_TO_ADDR
// for i in list do
66742: LD_ADDR_VAR 0 7
66746: PUSH
66747: LD_VAR 0 3
66751: PUSH
66752: FOR_IN
66753: IFFALSE 66955
// begin tmp := GetDistUnitXY ( i , x , y ) ;
66755: LD_ADDR_VAR 0 9
66759: PUSH
66760: LD_VAR 0 7
66764: PPUSH
66765: LD_VAR 0 1
66769: PPUSH
66770: LD_VAR 0 2
66774: PPUSH
66775: CALL_OW 297
66779: ST_TO_ADDR
// if not result then
66780: LD_VAR 0 6
66784: NOT
66785: IFFALSE 66811
// result := [ [ i , tmp ] ] else
66787: LD_ADDR_VAR 0 6
66791: PUSH
66792: LD_VAR 0 7
66796: PUSH
66797: LD_VAR 0 9
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: EMPTY
66807: LIST
66808: ST_TO_ADDR
66809: GO 66953
// begin if result [ result ] [ 2 ] < tmp then
66811: LD_VAR 0 6
66815: PUSH
66816: LD_VAR 0 6
66820: ARRAY
66821: PUSH
66822: LD_INT 2
66824: ARRAY
66825: PUSH
66826: LD_VAR 0 9
66830: LESS
66831: IFFALSE 66873
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
66833: LD_ADDR_VAR 0 6
66837: PUSH
66838: LD_VAR 0 6
66842: PPUSH
66843: LD_VAR 0 6
66847: PUSH
66848: LD_INT 1
66850: PLUS
66851: PPUSH
66852: LD_VAR 0 7
66856: PUSH
66857: LD_VAR 0 9
66861: PUSH
66862: EMPTY
66863: LIST
66864: LIST
66865: PPUSH
66866: CALL_OW 2
66870: ST_TO_ADDR
66871: GO 66953
// for j = 1 to result do
66873: LD_ADDR_VAR 0 8
66877: PUSH
66878: DOUBLE
66879: LD_INT 1
66881: DEC
66882: ST_TO_ADDR
66883: LD_VAR 0 6
66887: PUSH
66888: FOR_TO
66889: IFFALSE 66951
// begin if tmp < result [ j ] [ 2 ] then
66891: LD_VAR 0 9
66895: PUSH
66896: LD_VAR 0 6
66900: PUSH
66901: LD_VAR 0 8
66905: ARRAY
66906: PUSH
66907: LD_INT 2
66909: ARRAY
66910: LESS
66911: IFFALSE 66949
// begin result := Insert ( result , j , [ i , tmp ] ) ;
66913: LD_ADDR_VAR 0 6
66917: PUSH
66918: LD_VAR 0 6
66922: PPUSH
66923: LD_VAR 0 8
66927: PPUSH
66928: LD_VAR 0 7
66932: PUSH
66933: LD_VAR 0 9
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PPUSH
66942: CALL_OW 2
66946: ST_TO_ADDR
// break ;
66947: GO 66951
// end ; end ;
66949: GO 66888
66951: POP
66952: POP
// end ; end ;
66953: GO 66752
66955: POP
66956: POP
// if result and not asc then
66957: LD_VAR 0 6
66961: PUSH
66962: LD_VAR 0 4
66966: NOT
66967: AND
66968: IFFALSE 67043
// begin tmp := result ;
66970: LD_ADDR_VAR 0 9
66974: PUSH
66975: LD_VAR 0 6
66979: ST_TO_ADDR
// for i = tmp downto 1 do
66980: LD_ADDR_VAR 0 7
66984: PUSH
66985: DOUBLE
66986: LD_VAR 0 9
66990: INC
66991: ST_TO_ADDR
66992: LD_INT 1
66994: PUSH
66995: FOR_DOWNTO
66996: IFFALSE 67041
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
66998: LD_ADDR_VAR 0 6
67002: PUSH
67003: LD_VAR 0 6
67007: PPUSH
67008: LD_VAR 0 9
67012: PUSH
67013: LD_VAR 0 7
67017: MINUS
67018: PUSH
67019: LD_INT 1
67021: PLUS
67022: PPUSH
67023: LD_VAR 0 9
67027: PUSH
67028: LD_VAR 0 7
67032: ARRAY
67033: PPUSH
67034: CALL_OW 1
67038: ST_TO_ADDR
67039: GO 66995
67041: POP
67042: POP
// end ; tmp := [ ] ;
67043: LD_ADDR_VAR 0 9
67047: PUSH
67048: EMPTY
67049: ST_TO_ADDR
// if mode then
67050: LD_VAR 0 5
67054: IFFALSE 67123
// begin for i = 1 to result do
67056: LD_ADDR_VAR 0 7
67060: PUSH
67061: DOUBLE
67062: LD_INT 1
67064: DEC
67065: ST_TO_ADDR
67066: LD_VAR 0 6
67070: PUSH
67071: FOR_TO
67072: IFFALSE 67111
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
67074: LD_ADDR_VAR 0 9
67078: PUSH
67079: LD_VAR 0 9
67083: PPUSH
67084: LD_VAR 0 7
67088: PPUSH
67089: LD_VAR 0 6
67093: PUSH
67094: LD_VAR 0 7
67098: ARRAY
67099: PUSH
67100: LD_INT 1
67102: ARRAY
67103: PPUSH
67104: CALL_OW 1
67108: ST_TO_ADDR
67109: GO 67071
67111: POP
67112: POP
// result := tmp ;
67113: LD_ADDR_VAR 0 6
67117: PUSH
67118: LD_VAR 0 9
67122: ST_TO_ADDR
// end ; end ;
67123: LD_VAR 0 6
67127: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
67128: LD_INT 0
67130: PPUSH
67131: PPUSH
67132: PPUSH
67133: PPUSH
67134: PPUSH
67135: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
67136: LD_ADDR_VAR 0 5
67140: PUSH
67141: LD_INT 0
67143: PUSH
67144: LD_INT 0
67146: PUSH
67147: LD_INT 0
67149: PUSH
67150: EMPTY
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: ST_TO_ADDR
// if not x or not y then
67158: LD_VAR 0 2
67162: NOT
67163: PUSH
67164: LD_VAR 0 3
67168: NOT
67169: OR
67170: IFFALSE 67174
// exit ;
67172: GO 68826
// if not range then
67174: LD_VAR 0 4
67178: NOT
67179: IFFALSE 67189
// range := 10 ;
67181: LD_ADDR_VAR 0 4
67185: PUSH
67186: LD_INT 10
67188: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67189: LD_ADDR_VAR 0 8
67193: PUSH
67194: LD_INT 81
67196: PUSH
67197: LD_VAR 0 1
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 92
67208: PUSH
67209: LD_VAR 0 2
67213: PUSH
67214: LD_VAR 0 3
67218: PUSH
67219: LD_VAR 0 4
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: PUSH
67230: LD_INT 3
67232: PUSH
67233: LD_INT 21
67235: PUSH
67236: LD_INT 3
67238: PUSH
67239: EMPTY
67240: LIST
67241: LIST
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: LIST
67251: PPUSH
67252: CALL_OW 69
67256: ST_TO_ADDR
// if not tmp then
67257: LD_VAR 0 8
67261: NOT
67262: IFFALSE 67266
// exit ;
67264: GO 68826
// for i in tmp do
67266: LD_ADDR_VAR 0 6
67270: PUSH
67271: LD_VAR 0 8
67275: PUSH
67276: FOR_IN
67277: IFFALSE 68801
// begin points := [ 0 , 0 , 0 ] ;
67279: LD_ADDR_VAR 0 9
67283: PUSH
67284: LD_INT 0
67286: PUSH
67287: LD_INT 0
67289: PUSH
67290: LD_INT 0
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: LIST
67297: ST_TO_ADDR
// bpoints := 1 ;
67298: LD_ADDR_VAR 0 10
67302: PUSH
67303: LD_INT 1
67305: ST_TO_ADDR
// case GetType ( i ) of unit_human :
67306: LD_VAR 0 6
67310: PPUSH
67311: CALL_OW 247
67315: PUSH
67316: LD_INT 1
67318: DOUBLE
67319: EQUAL
67320: IFTRUE 67324
67322: GO 67902
67324: POP
// begin if GetClass ( i ) = 1 then
67325: LD_VAR 0 6
67329: PPUSH
67330: CALL_OW 257
67334: PUSH
67335: LD_INT 1
67337: EQUAL
67338: IFFALSE 67359
// points := [ 10 , 5 , 3 ] ;
67340: LD_ADDR_VAR 0 9
67344: PUSH
67345: LD_INT 10
67347: PUSH
67348: LD_INT 5
67350: PUSH
67351: LD_INT 3
67353: PUSH
67354: EMPTY
67355: LIST
67356: LIST
67357: LIST
67358: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
67359: LD_VAR 0 6
67363: PPUSH
67364: CALL_OW 257
67368: PUSH
67369: LD_INT 2
67371: PUSH
67372: LD_INT 3
67374: PUSH
67375: LD_INT 4
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: LIST
67382: IN
67383: IFFALSE 67404
// points := [ 3 , 2 , 1 ] ;
67385: LD_ADDR_VAR 0 9
67389: PUSH
67390: LD_INT 3
67392: PUSH
67393: LD_INT 2
67395: PUSH
67396: LD_INT 1
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: LIST
67403: ST_TO_ADDR
// if GetClass ( i ) = 5 then
67404: LD_VAR 0 6
67408: PPUSH
67409: CALL_OW 257
67413: PUSH
67414: LD_INT 5
67416: EQUAL
67417: IFFALSE 67438
// points := [ 130 , 5 , 2 ] ;
67419: LD_ADDR_VAR 0 9
67423: PUSH
67424: LD_INT 130
67426: PUSH
67427: LD_INT 5
67429: PUSH
67430: LD_INT 2
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: LIST
67437: ST_TO_ADDR
// if GetClass ( i ) = 8 then
67438: LD_VAR 0 6
67442: PPUSH
67443: CALL_OW 257
67447: PUSH
67448: LD_INT 8
67450: EQUAL
67451: IFFALSE 67472
// points := [ 35 , 35 , 30 ] ;
67453: LD_ADDR_VAR 0 9
67457: PUSH
67458: LD_INT 35
67460: PUSH
67461: LD_INT 35
67463: PUSH
67464: LD_INT 30
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: LIST
67471: ST_TO_ADDR
// if GetClass ( i ) = 9 then
67472: LD_VAR 0 6
67476: PPUSH
67477: CALL_OW 257
67481: PUSH
67482: LD_INT 9
67484: EQUAL
67485: IFFALSE 67506
// points := [ 20 , 55 , 40 ] ;
67487: LD_ADDR_VAR 0 9
67491: PUSH
67492: LD_INT 20
67494: PUSH
67495: LD_INT 55
67497: PUSH
67498: LD_INT 40
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: LIST
67505: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
67506: LD_VAR 0 6
67510: PPUSH
67511: CALL_OW 257
67515: PUSH
67516: LD_INT 12
67518: PUSH
67519: LD_INT 16
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: IN
67526: IFFALSE 67547
// points := [ 5 , 3 , 2 ] ;
67528: LD_ADDR_VAR 0 9
67532: PUSH
67533: LD_INT 5
67535: PUSH
67536: LD_INT 3
67538: PUSH
67539: LD_INT 2
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: LIST
67546: ST_TO_ADDR
// if GetClass ( i ) = 17 then
67547: LD_VAR 0 6
67551: PPUSH
67552: CALL_OW 257
67556: PUSH
67557: LD_INT 17
67559: EQUAL
67560: IFFALSE 67581
// points := [ 100 , 50 , 75 ] ;
67562: LD_ADDR_VAR 0 9
67566: PUSH
67567: LD_INT 100
67569: PUSH
67570: LD_INT 50
67572: PUSH
67573: LD_INT 75
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: LIST
67580: ST_TO_ADDR
// if GetClass ( i ) = 15 then
67581: LD_VAR 0 6
67585: PPUSH
67586: CALL_OW 257
67590: PUSH
67591: LD_INT 15
67593: EQUAL
67594: IFFALSE 67615
// points := [ 10 , 5 , 3 ] ;
67596: LD_ADDR_VAR 0 9
67600: PUSH
67601: LD_INT 10
67603: PUSH
67604: LD_INT 5
67606: PUSH
67607: LD_INT 3
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: LIST
67614: ST_TO_ADDR
// if GetClass ( i ) = 14 then
67615: LD_VAR 0 6
67619: PPUSH
67620: CALL_OW 257
67624: PUSH
67625: LD_INT 14
67627: EQUAL
67628: IFFALSE 67649
// points := [ 10 , 0 , 0 ] ;
67630: LD_ADDR_VAR 0 9
67634: PUSH
67635: LD_INT 10
67637: PUSH
67638: LD_INT 0
67640: PUSH
67641: LD_INT 0
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: LIST
67648: ST_TO_ADDR
// if GetClass ( i ) = 11 then
67649: LD_VAR 0 6
67653: PPUSH
67654: CALL_OW 257
67658: PUSH
67659: LD_INT 11
67661: EQUAL
67662: IFFALSE 67683
// points := [ 30 , 10 , 5 ] ;
67664: LD_ADDR_VAR 0 9
67668: PUSH
67669: LD_INT 30
67671: PUSH
67672: LD_INT 10
67674: PUSH
67675: LD_INT 5
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: LIST
67682: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
67683: LD_VAR 0 1
67687: PPUSH
67688: LD_INT 5
67690: PPUSH
67691: CALL_OW 321
67695: PUSH
67696: LD_INT 2
67698: EQUAL
67699: IFFALSE 67716
// bpoints := bpoints * 1.8 ;
67701: LD_ADDR_VAR 0 10
67705: PUSH
67706: LD_VAR 0 10
67710: PUSH
67711: LD_REAL  1.80000000000000E+0000
67714: MUL
67715: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
67716: LD_VAR 0 6
67720: PPUSH
67721: CALL_OW 257
67725: PUSH
67726: LD_INT 1
67728: PUSH
67729: LD_INT 2
67731: PUSH
67732: LD_INT 3
67734: PUSH
67735: LD_INT 4
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: IN
67744: PUSH
67745: LD_VAR 0 1
67749: PPUSH
67750: LD_INT 51
67752: PPUSH
67753: CALL_OW 321
67757: PUSH
67758: LD_INT 2
67760: EQUAL
67761: AND
67762: IFFALSE 67779
// bpoints := bpoints * 1.2 ;
67764: LD_ADDR_VAR 0 10
67768: PUSH
67769: LD_VAR 0 10
67773: PUSH
67774: LD_REAL  1.20000000000000E+0000
67777: MUL
67778: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
67779: LD_VAR 0 6
67783: PPUSH
67784: CALL_OW 257
67788: PUSH
67789: LD_INT 5
67791: PUSH
67792: LD_INT 7
67794: PUSH
67795: LD_INT 9
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: LIST
67802: IN
67803: PUSH
67804: LD_VAR 0 1
67808: PPUSH
67809: LD_INT 52
67811: PPUSH
67812: CALL_OW 321
67816: PUSH
67817: LD_INT 2
67819: EQUAL
67820: AND
67821: IFFALSE 67838
// bpoints := bpoints * 1.5 ;
67823: LD_ADDR_VAR 0 10
67827: PUSH
67828: LD_VAR 0 10
67832: PUSH
67833: LD_REAL  1.50000000000000E+0000
67836: MUL
67837: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
67838: LD_VAR 0 1
67842: PPUSH
67843: LD_INT 66
67845: PPUSH
67846: CALL_OW 321
67850: PUSH
67851: LD_INT 2
67853: EQUAL
67854: IFFALSE 67871
// bpoints := bpoints * 1.1 ;
67856: LD_ADDR_VAR 0 10
67860: PUSH
67861: LD_VAR 0 10
67865: PUSH
67866: LD_REAL  1.10000000000000E+0000
67869: MUL
67870: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
67871: LD_ADDR_VAR 0 10
67875: PUSH
67876: LD_VAR 0 10
67880: PUSH
67881: LD_VAR 0 6
67885: PPUSH
67886: LD_INT 1
67888: PPUSH
67889: CALL_OW 259
67893: PUSH
67894: LD_REAL  1.15000000000000E+0000
67897: MUL
67898: MUL
67899: ST_TO_ADDR
// end ; unit_vehicle :
67900: GO 68730
67902: LD_INT 2
67904: DOUBLE
67905: EQUAL
67906: IFTRUE 67910
67908: GO 68718
67910: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
67911: LD_VAR 0 6
67915: PPUSH
67916: CALL_OW 264
67920: PUSH
67921: LD_INT 2
67923: PUSH
67924: LD_INT 42
67926: PUSH
67927: LD_INT 24
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: LIST
67934: IN
67935: IFFALSE 67956
// points := [ 25 , 5 , 3 ] ;
67937: LD_ADDR_VAR 0 9
67941: PUSH
67942: LD_INT 25
67944: PUSH
67945: LD_INT 5
67947: PUSH
67948: LD_INT 3
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: LIST
67955: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
67956: LD_VAR 0 6
67960: PPUSH
67961: CALL_OW 264
67965: PUSH
67966: LD_INT 4
67968: PUSH
67969: LD_INT 43
67971: PUSH
67972: LD_INT 25
67974: PUSH
67975: EMPTY
67976: LIST
67977: LIST
67978: LIST
67979: IN
67980: IFFALSE 68001
// points := [ 40 , 15 , 5 ] ;
67982: LD_ADDR_VAR 0 9
67986: PUSH
67987: LD_INT 40
67989: PUSH
67990: LD_INT 15
67992: PUSH
67993: LD_INT 5
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: LIST
68000: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
68001: LD_VAR 0 6
68005: PPUSH
68006: CALL_OW 264
68010: PUSH
68011: LD_INT 3
68013: PUSH
68014: LD_INT 23
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: IN
68021: IFFALSE 68042
// points := [ 7 , 25 , 8 ] ;
68023: LD_ADDR_VAR 0 9
68027: PUSH
68028: LD_INT 7
68030: PUSH
68031: LD_INT 25
68033: PUSH
68034: LD_INT 8
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: LIST
68041: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
68042: LD_VAR 0 6
68046: PPUSH
68047: CALL_OW 264
68051: PUSH
68052: LD_INT 5
68054: PUSH
68055: LD_INT 27
68057: PUSH
68058: LD_INT 44
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: LIST
68065: IN
68066: IFFALSE 68087
// points := [ 14 , 50 , 16 ] ;
68068: LD_ADDR_VAR 0 9
68072: PUSH
68073: LD_INT 14
68075: PUSH
68076: LD_INT 50
68078: PUSH
68079: LD_INT 16
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: LIST
68086: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
68087: LD_VAR 0 6
68091: PPUSH
68092: CALL_OW 264
68096: PUSH
68097: LD_INT 6
68099: PUSH
68100: LD_INT 46
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: IN
68107: IFFALSE 68128
// points := [ 32 , 120 , 70 ] ;
68109: LD_ADDR_VAR 0 9
68113: PUSH
68114: LD_INT 32
68116: PUSH
68117: LD_INT 120
68119: PUSH
68120: LD_INT 70
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: LIST
68127: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
68128: LD_VAR 0 6
68132: PPUSH
68133: CALL_OW 264
68137: PUSH
68138: LD_INT 7
68140: PUSH
68141: LD_INT 28
68143: PUSH
68144: LD_INT 45
68146: PUSH
68147: LD_EXP 78
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: IN
68158: IFFALSE 68179
// points := [ 35 , 20 , 45 ] ;
68160: LD_ADDR_VAR 0 9
68164: PUSH
68165: LD_INT 35
68167: PUSH
68168: LD_INT 20
68170: PUSH
68171: LD_INT 45
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: LIST
68178: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
68179: LD_VAR 0 6
68183: PPUSH
68184: CALL_OW 264
68188: PUSH
68189: LD_INT 47
68191: PUSH
68192: EMPTY
68193: LIST
68194: IN
68195: IFFALSE 68216
// points := [ 67 , 45 , 75 ] ;
68197: LD_ADDR_VAR 0 9
68201: PUSH
68202: LD_INT 67
68204: PUSH
68205: LD_INT 45
68207: PUSH
68208: LD_INT 75
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: LIST
68215: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
68216: LD_VAR 0 6
68220: PPUSH
68221: CALL_OW 264
68225: PUSH
68226: LD_INT 26
68228: PUSH
68229: EMPTY
68230: LIST
68231: IN
68232: IFFALSE 68253
// points := [ 120 , 30 , 80 ] ;
68234: LD_ADDR_VAR 0 9
68238: PUSH
68239: LD_INT 120
68241: PUSH
68242: LD_INT 30
68244: PUSH
68245: LD_INT 80
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: LIST
68252: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
68253: LD_VAR 0 6
68257: PPUSH
68258: CALL_OW 264
68262: PUSH
68263: LD_INT 22
68265: PUSH
68266: EMPTY
68267: LIST
68268: IN
68269: IFFALSE 68290
// points := [ 40 , 1 , 1 ] ;
68271: LD_ADDR_VAR 0 9
68275: PUSH
68276: LD_INT 40
68278: PUSH
68279: LD_INT 1
68281: PUSH
68282: LD_INT 1
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: LIST
68289: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
68290: LD_VAR 0 6
68294: PPUSH
68295: CALL_OW 264
68299: PUSH
68300: LD_INT 29
68302: PUSH
68303: EMPTY
68304: LIST
68305: IN
68306: IFFALSE 68327
// points := [ 70 , 200 , 400 ] ;
68308: LD_ADDR_VAR 0 9
68312: PUSH
68313: LD_INT 70
68315: PUSH
68316: LD_INT 200
68318: PUSH
68319: LD_INT 400
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: LIST
68326: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
68327: LD_VAR 0 6
68331: PPUSH
68332: CALL_OW 264
68336: PUSH
68337: LD_INT 14
68339: PUSH
68340: LD_INT 53
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: IN
68347: IFFALSE 68368
// points := [ 40 , 10 , 20 ] ;
68349: LD_ADDR_VAR 0 9
68353: PUSH
68354: LD_INT 40
68356: PUSH
68357: LD_INT 10
68359: PUSH
68360: LD_INT 20
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: LIST
68367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
68368: LD_VAR 0 6
68372: PPUSH
68373: CALL_OW 264
68377: PUSH
68378: LD_INT 9
68380: PUSH
68381: EMPTY
68382: LIST
68383: IN
68384: IFFALSE 68405
// points := [ 5 , 70 , 20 ] ;
68386: LD_ADDR_VAR 0 9
68390: PUSH
68391: LD_INT 5
68393: PUSH
68394: LD_INT 70
68396: PUSH
68397: LD_INT 20
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: LIST
68404: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
68405: LD_VAR 0 6
68409: PPUSH
68410: CALL_OW 264
68414: PUSH
68415: LD_INT 10
68417: PUSH
68418: EMPTY
68419: LIST
68420: IN
68421: IFFALSE 68442
// points := [ 35 , 110 , 70 ] ;
68423: LD_ADDR_VAR 0 9
68427: PUSH
68428: LD_INT 35
68430: PUSH
68431: LD_INT 110
68433: PUSH
68434: LD_INT 70
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: LIST
68441: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
68442: LD_VAR 0 6
68446: PPUSH
68447: CALL_OW 265
68451: PUSH
68452: LD_INT 25
68454: EQUAL
68455: IFFALSE 68476
// points := [ 80 , 65 , 100 ] ;
68457: LD_ADDR_VAR 0 9
68461: PUSH
68462: LD_INT 80
68464: PUSH
68465: LD_INT 65
68467: PUSH
68468: LD_INT 100
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: LIST
68475: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
68476: LD_VAR 0 6
68480: PPUSH
68481: CALL_OW 263
68485: PUSH
68486: LD_INT 1
68488: EQUAL
68489: IFFALSE 68524
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
68491: LD_ADDR_VAR 0 10
68495: PUSH
68496: LD_VAR 0 10
68500: PUSH
68501: LD_VAR 0 6
68505: PPUSH
68506: CALL_OW 311
68510: PPUSH
68511: LD_INT 3
68513: PPUSH
68514: CALL_OW 259
68518: PUSH
68519: LD_INT 4
68521: MUL
68522: MUL
68523: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
68524: LD_VAR 0 6
68528: PPUSH
68529: CALL_OW 263
68533: PUSH
68534: LD_INT 2
68536: EQUAL
68537: IFFALSE 68588
// begin j := IsControledBy ( i ) ;
68539: LD_ADDR_VAR 0 7
68543: PUSH
68544: LD_VAR 0 6
68548: PPUSH
68549: CALL_OW 312
68553: ST_TO_ADDR
// if j then
68554: LD_VAR 0 7
68558: IFFALSE 68588
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
68560: LD_ADDR_VAR 0 10
68564: PUSH
68565: LD_VAR 0 10
68569: PUSH
68570: LD_VAR 0 7
68574: PPUSH
68575: LD_INT 3
68577: PPUSH
68578: CALL_OW 259
68582: PUSH
68583: LD_INT 3
68585: MUL
68586: MUL
68587: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
68588: LD_VAR 0 6
68592: PPUSH
68593: CALL_OW 264
68597: PUSH
68598: LD_INT 5
68600: PUSH
68601: LD_INT 6
68603: PUSH
68604: LD_INT 46
68606: PUSH
68607: LD_INT 44
68609: PUSH
68610: LD_INT 47
68612: PUSH
68613: LD_INT 45
68615: PUSH
68616: LD_INT 28
68618: PUSH
68619: LD_INT 7
68621: PUSH
68622: LD_INT 27
68624: PUSH
68625: LD_INT 29
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: IN
68640: PUSH
68641: LD_VAR 0 1
68645: PPUSH
68646: LD_INT 52
68648: PPUSH
68649: CALL_OW 321
68653: PUSH
68654: LD_INT 2
68656: EQUAL
68657: AND
68658: IFFALSE 68675
// bpoints := bpoints * 1.2 ;
68660: LD_ADDR_VAR 0 10
68664: PUSH
68665: LD_VAR 0 10
68669: PUSH
68670: LD_REAL  1.20000000000000E+0000
68673: MUL
68674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
68675: LD_VAR 0 6
68679: PPUSH
68680: CALL_OW 264
68684: PUSH
68685: LD_INT 6
68687: PUSH
68688: LD_INT 46
68690: PUSH
68691: LD_INT 47
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: LIST
68698: IN
68699: IFFALSE 68716
// bpoints := bpoints * 1.2 ;
68701: LD_ADDR_VAR 0 10
68705: PUSH
68706: LD_VAR 0 10
68710: PUSH
68711: LD_REAL  1.20000000000000E+0000
68714: MUL
68715: ST_TO_ADDR
// end ; unit_building :
68716: GO 68730
68718: LD_INT 3
68720: DOUBLE
68721: EQUAL
68722: IFTRUE 68726
68724: GO 68729
68726: POP
// ; end ;
68727: GO 68730
68729: POP
// for j = 1 to 3 do
68730: LD_ADDR_VAR 0 7
68734: PUSH
68735: DOUBLE
68736: LD_INT 1
68738: DEC
68739: ST_TO_ADDR
68740: LD_INT 3
68742: PUSH
68743: FOR_TO
68744: IFFALSE 68797
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
68746: LD_ADDR_VAR 0 5
68750: PUSH
68751: LD_VAR 0 5
68755: PPUSH
68756: LD_VAR 0 7
68760: PPUSH
68761: LD_VAR 0 5
68765: PUSH
68766: LD_VAR 0 7
68770: ARRAY
68771: PUSH
68772: LD_VAR 0 9
68776: PUSH
68777: LD_VAR 0 7
68781: ARRAY
68782: PUSH
68783: LD_VAR 0 10
68787: MUL
68788: PLUS
68789: PPUSH
68790: CALL_OW 1
68794: ST_TO_ADDR
68795: GO 68743
68797: POP
68798: POP
// end ;
68799: GO 67276
68801: POP
68802: POP
// result := Replace ( result , 4 , tmp ) ;
68803: LD_ADDR_VAR 0 5
68807: PUSH
68808: LD_VAR 0 5
68812: PPUSH
68813: LD_INT 4
68815: PPUSH
68816: LD_VAR 0 8
68820: PPUSH
68821: CALL_OW 1
68825: ST_TO_ADDR
// end ;
68826: LD_VAR 0 5
68830: RET
// export function DangerAtRange ( unit , range ) ; begin
68831: LD_INT 0
68833: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
68834: LD_ADDR_VAR 0 3
68838: PUSH
68839: LD_VAR 0 1
68843: PPUSH
68844: CALL_OW 255
68848: PPUSH
68849: LD_VAR 0 1
68853: PPUSH
68854: CALL_OW 250
68858: PPUSH
68859: LD_VAR 0 1
68863: PPUSH
68864: CALL_OW 251
68868: PPUSH
68869: LD_VAR 0 2
68873: PPUSH
68874: CALL 67128 0 4
68878: ST_TO_ADDR
// end ;
68879: LD_VAR 0 3
68883: RET
// export function DangerInArea ( side , area ) ; begin
68884: LD_INT 0
68886: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
68887: LD_ADDR_VAR 0 3
68891: PUSH
68892: LD_VAR 0 2
68896: PPUSH
68897: LD_INT 81
68899: PUSH
68900: LD_VAR 0 1
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PPUSH
68909: CALL_OW 70
68913: ST_TO_ADDR
// end ;
68914: LD_VAR 0 3
68918: RET
// export function IsExtension ( b ) ; begin
68919: LD_INT 0
68921: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
68922: LD_ADDR_VAR 0 2
68926: PUSH
68927: LD_VAR 0 1
68931: PUSH
68932: LD_INT 23
68934: PUSH
68935: LD_INT 20
68937: PUSH
68938: LD_INT 22
68940: PUSH
68941: LD_INT 17
68943: PUSH
68944: LD_INT 24
68946: PUSH
68947: LD_INT 21
68949: PUSH
68950: LD_INT 19
68952: PUSH
68953: LD_INT 16
68955: PUSH
68956: LD_INT 25
68958: PUSH
68959: LD_INT 18
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: IN
68974: ST_TO_ADDR
// end ;
68975: LD_VAR 0 2
68979: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
68980: LD_INT 0
68982: PPUSH
68983: PPUSH
68984: PPUSH
// result := [ ] ;
68985: LD_ADDR_VAR 0 4
68989: PUSH
68990: EMPTY
68991: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
68992: LD_ADDR_VAR 0 5
68996: PUSH
68997: LD_VAR 0 2
69001: PPUSH
69002: LD_INT 21
69004: PUSH
69005: LD_INT 3
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PPUSH
69012: CALL_OW 70
69016: ST_TO_ADDR
// if not tmp then
69017: LD_VAR 0 5
69021: NOT
69022: IFFALSE 69026
// exit ;
69024: GO 69090
// if checkLink then
69026: LD_VAR 0 3
69030: IFFALSE 69080
// begin for i in tmp do
69032: LD_ADDR_VAR 0 6
69036: PUSH
69037: LD_VAR 0 5
69041: PUSH
69042: FOR_IN
69043: IFFALSE 69078
// if GetBase ( i ) <> base then
69045: LD_VAR 0 6
69049: PPUSH
69050: CALL_OW 274
69054: PUSH
69055: LD_VAR 0 1
69059: NONEQUAL
69060: IFFALSE 69076
// ComLinkToBase ( base , i ) ;
69062: LD_VAR 0 1
69066: PPUSH
69067: LD_VAR 0 6
69071: PPUSH
69072: CALL_OW 169
69076: GO 69042
69078: POP
69079: POP
// end ; result := tmp ;
69080: LD_ADDR_VAR 0 4
69084: PUSH
69085: LD_VAR 0 5
69089: ST_TO_ADDR
// end ;
69090: LD_VAR 0 4
69094: RET
// export function ComComplete ( units , b ) ; var i ; begin
69095: LD_INT 0
69097: PPUSH
69098: PPUSH
// if not units then
69099: LD_VAR 0 1
69103: NOT
69104: IFFALSE 69108
// exit ;
69106: GO 69198
// for i in units do
69108: LD_ADDR_VAR 0 4
69112: PUSH
69113: LD_VAR 0 1
69117: PUSH
69118: FOR_IN
69119: IFFALSE 69196
// if BuildingStatus ( b ) = bs_build then
69121: LD_VAR 0 2
69125: PPUSH
69126: CALL_OW 461
69130: PUSH
69131: LD_INT 1
69133: EQUAL
69134: IFFALSE 69194
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
69136: LD_VAR 0 4
69140: PPUSH
69141: LD_STRING h
69143: PUSH
69144: LD_VAR 0 2
69148: PPUSH
69149: CALL_OW 250
69153: PUSH
69154: LD_VAR 0 2
69158: PPUSH
69159: CALL_OW 251
69163: PUSH
69164: LD_VAR 0 2
69168: PUSH
69169: LD_INT 0
69171: PUSH
69172: LD_INT 0
69174: PUSH
69175: LD_INT 0
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: PUSH
69187: EMPTY
69188: LIST
69189: PPUSH
69190: CALL_OW 446
69194: GO 69118
69196: POP
69197: POP
// end ;
69198: LD_VAR 0 3
69202: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
69203: LD_INT 0
69205: PPUSH
69206: PPUSH
69207: PPUSH
69208: PPUSH
69209: PPUSH
69210: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
69211: LD_VAR 0 1
69215: NOT
69216: PUSH
69217: LD_VAR 0 1
69221: PPUSH
69222: CALL_OW 263
69226: PUSH
69227: LD_INT 2
69229: NONEQUAL
69230: OR
69231: IFFALSE 69235
// exit ;
69233: GO 69551
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
69235: LD_ADDR_VAR 0 6
69239: PUSH
69240: LD_INT 22
69242: PUSH
69243: LD_VAR 0 1
69247: PPUSH
69248: CALL_OW 255
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 2
69259: PUSH
69260: LD_INT 30
69262: PUSH
69263: LD_INT 36
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 34
69272: PUSH
69273: LD_INT 31
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: LIST
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: PPUSH
69289: CALL_OW 69
69293: ST_TO_ADDR
// if not tmp then
69294: LD_VAR 0 6
69298: NOT
69299: IFFALSE 69303
// exit ;
69301: GO 69551
// result := [ ] ;
69303: LD_ADDR_VAR 0 2
69307: PUSH
69308: EMPTY
69309: ST_TO_ADDR
// for i in tmp do
69310: LD_ADDR_VAR 0 3
69314: PUSH
69315: LD_VAR 0 6
69319: PUSH
69320: FOR_IN
69321: IFFALSE 69392
// begin t := UnitsInside ( i ) ;
69323: LD_ADDR_VAR 0 4
69327: PUSH
69328: LD_VAR 0 3
69332: PPUSH
69333: CALL_OW 313
69337: ST_TO_ADDR
// if t then
69338: LD_VAR 0 4
69342: IFFALSE 69390
// for j in t do
69344: LD_ADDR_VAR 0 7
69348: PUSH
69349: LD_VAR 0 4
69353: PUSH
69354: FOR_IN
69355: IFFALSE 69388
// result := Replace ( result , result + 1 , j ) ;
69357: LD_ADDR_VAR 0 2
69361: PUSH
69362: LD_VAR 0 2
69366: PPUSH
69367: LD_VAR 0 2
69371: PUSH
69372: LD_INT 1
69374: PLUS
69375: PPUSH
69376: LD_VAR 0 7
69380: PPUSH
69381: CALL_OW 1
69385: ST_TO_ADDR
69386: GO 69354
69388: POP
69389: POP
// end ;
69390: GO 69320
69392: POP
69393: POP
// if not result then
69394: LD_VAR 0 2
69398: NOT
69399: IFFALSE 69403
// exit ;
69401: GO 69551
// mech := result [ 1 ] ;
69403: LD_ADDR_VAR 0 5
69407: PUSH
69408: LD_VAR 0 2
69412: PUSH
69413: LD_INT 1
69415: ARRAY
69416: ST_TO_ADDR
// if result > 1 then
69417: LD_VAR 0 2
69421: PUSH
69422: LD_INT 1
69424: GREATER
69425: IFFALSE 69537
// begin for i = 2 to result do
69427: LD_ADDR_VAR 0 3
69431: PUSH
69432: DOUBLE
69433: LD_INT 2
69435: DEC
69436: ST_TO_ADDR
69437: LD_VAR 0 2
69441: PUSH
69442: FOR_TO
69443: IFFALSE 69535
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
69445: LD_ADDR_VAR 0 4
69449: PUSH
69450: LD_VAR 0 2
69454: PUSH
69455: LD_VAR 0 3
69459: ARRAY
69460: PPUSH
69461: LD_INT 3
69463: PPUSH
69464: CALL_OW 259
69468: PUSH
69469: LD_VAR 0 2
69473: PUSH
69474: LD_VAR 0 3
69478: ARRAY
69479: PPUSH
69480: CALL_OW 432
69484: MINUS
69485: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
69486: LD_VAR 0 4
69490: PUSH
69491: LD_VAR 0 5
69495: PPUSH
69496: LD_INT 3
69498: PPUSH
69499: CALL_OW 259
69503: PUSH
69504: LD_VAR 0 5
69508: PPUSH
69509: CALL_OW 432
69513: MINUS
69514: GREATEREQUAL
69515: IFFALSE 69533
// mech := result [ i ] ;
69517: LD_ADDR_VAR 0 5
69521: PUSH
69522: LD_VAR 0 2
69526: PUSH
69527: LD_VAR 0 3
69531: ARRAY
69532: ST_TO_ADDR
// end ;
69533: GO 69442
69535: POP
69536: POP
// end ; ComLinkTo ( vehicle , mech ) ;
69537: LD_VAR 0 1
69541: PPUSH
69542: LD_VAR 0 5
69546: PPUSH
69547: CALL_OW 135
// end ;
69551: LD_VAR 0 2
69555: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
69556: LD_INT 0
69558: PPUSH
69559: PPUSH
69560: PPUSH
69561: PPUSH
69562: PPUSH
69563: PPUSH
69564: PPUSH
69565: PPUSH
69566: PPUSH
69567: PPUSH
69568: PPUSH
69569: PPUSH
69570: PPUSH
// result := [ ] ;
69571: LD_ADDR_VAR 0 7
69575: PUSH
69576: EMPTY
69577: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
69578: LD_VAR 0 1
69582: PPUSH
69583: CALL_OW 266
69587: PUSH
69588: LD_INT 0
69590: PUSH
69591: LD_INT 1
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: IN
69598: NOT
69599: IFFALSE 69603
// exit ;
69601: GO 71237
// if name then
69603: LD_VAR 0 3
69607: IFFALSE 69623
// SetBName ( base_dep , name ) ;
69609: LD_VAR 0 1
69613: PPUSH
69614: LD_VAR 0 3
69618: PPUSH
69619: CALL_OW 500
// base := GetBase ( base_dep ) ;
69623: LD_ADDR_VAR 0 15
69627: PUSH
69628: LD_VAR 0 1
69632: PPUSH
69633: CALL_OW 274
69637: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
69638: LD_ADDR_VAR 0 16
69642: PUSH
69643: LD_VAR 0 1
69647: PPUSH
69648: CALL_OW 255
69652: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
69653: LD_ADDR_VAR 0 17
69657: PUSH
69658: LD_VAR 0 1
69662: PPUSH
69663: CALL_OW 248
69667: ST_TO_ADDR
// if sources then
69668: LD_VAR 0 5
69672: IFFALSE 69719
// for i = 1 to 3 do
69674: LD_ADDR_VAR 0 8
69678: PUSH
69679: DOUBLE
69680: LD_INT 1
69682: DEC
69683: ST_TO_ADDR
69684: LD_INT 3
69686: PUSH
69687: FOR_TO
69688: IFFALSE 69717
// AddResourceType ( base , i , sources [ i ] ) ;
69690: LD_VAR 0 15
69694: PPUSH
69695: LD_VAR 0 8
69699: PPUSH
69700: LD_VAR 0 5
69704: PUSH
69705: LD_VAR 0 8
69709: ARRAY
69710: PPUSH
69711: CALL_OW 276
69715: GO 69687
69717: POP
69718: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
69719: LD_ADDR_VAR 0 18
69723: PUSH
69724: LD_VAR 0 15
69728: PPUSH
69729: LD_VAR 0 2
69733: PPUSH
69734: LD_INT 1
69736: PPUSH
69737: CALL 68980 0 3
69741: ST_TO_ADDR
// InitHc ;
69742: CALL_OW 19
// InitUc ;
69746: CALL_OW 18
// uc_side := side ;
69750: LD_ADDR_OWVAR 20
69754: PUSH
69755: LD_VAR 0 16
69759: ST_TO_ADDR
// uc_nation := nation ;
69760: LD_ADDR_OWVAR 21
69764: PUSH
69765: LD_VAR 0 17
69769: ST_TO_ADDR
// if buildings then
69770: LD_VAR 0 18
69774: IFFALSE 71096
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
69776: LD_ADDR_VAR 0 19
69780: PUSH
69781: LD_VAR 0 18
69785: PPUSH
69786: LD_INT 2
69788: PUSH
69789: LD_INT 30
69791: PUSH
69792: LD_INT 29
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 30
69801: PUSH
69802: LD_INT 30
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: LIST
69813: PPUSH
69814: CALL_OW 72
69818: ST_TO_ADDR
// if tmp then
69819: LD_VAR 0 19
69823: IFFALSE 69871
// for i in tmp do
69825: LD_ADDR_VAR 0 8
69829: PUSH
69830: LD_VAR 0 19
69834: PUSH
69835: FOR_IN
69836: IFFALSE 69869
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
69838: LD_VAR 0 8
69842: PPUSH
69843: CALL_OW 250
69847: PPUSH
69848: LD_VAR 0 8
69852: PPUSH
69853: CALL_OW 251
69857: PPUSH
69858: LD_VAR 0 16
69862: PPUSH
69863: CALL_OW 441
69867: GO 69835
69869: POP
69870: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
69871: LD_VAR 0 18
69875: PPUSH
69876: LD_INT 2
69878: PUSH
69879: LD_INT 30
69881: PUSH
69882: LD_INT 32
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 30
69891: PUSH
69892: LD_INT 33
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: LIST
69903: PPUSH
69904: CALL_OW 72
69908: IFFALSE 69996
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
69910: LD_ADDR_VAR 0 8
69914: PUSH
69915: LD_VAR 0 18
69919: PPUSH
69920: LD_INT 2
69922: PUSH
69923: LD_INT 30
69925: PUSH
69926: LD_INT 32
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 30
69935: PUSH
69936: LD_INT 33
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: LIST
69947: PPUSH
69948: CALL_OW 72
69952: PUSH
69953: FOR_IN
69954: IFFALSE 69994
// begin if not GetBWeapon ( i ) then
69956: LD_VAR 0 8
69960: PPUSH
69961: CALL_OW 269
69965: NOT
69966: IFFALSE 69992
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
69968: LD_VAR 0 8
69972: PPUSH
69973: LD_VAR 0 8
69977: PPUSH
69978: LD_VAR 0 2
69982: PPUSH
69983: CALL 71242 0 2
69987: PPUSH
69988: CALL_OW 431
// end ;
69992: GO 69953
69994: POP
69995: POP
// end ; for i = 1 to personel do
69996: LD_ADDR_VAR 0 8
70000: PUSH
70001: DOUBLE
70002: LD_INT 1
70004: DEC
70005: ST_TO_ADDR
70006: LD_VAR 0 6
70010: PUSH
70011: FOR_TO
70012: IFFALSE 71076
// begin if i > 4 then
70014: LD_VAR 0 8
70018: PUSH
70019: LD_INT 4
70021: GREATER
70022: IFFALSE 70026
// break ;
70024: GO 71076
// case i of 1 :
70026: LD_VAR 0 8
70030: PUSH
70031: LD_INT 1
70033: DOUBLE
70034: EQUAL
70035: IFTRUE 70039
70037: GO 70119
70039: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
70040: LD_ADDR_VAR 0 12
70044: PUSH
70045: LD_VAR 0 18
70049: PPUSH
70050: LD_INT 22
70052: PUSH
70053: LD_VAR 0 16
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: LD_INT 58
70064: PUSH
70065: EMPTY
70066: LIST
70067: PUSH
70068: LD_INT 2
70070: PUSH
70071: LD_INT 30
70073: PUSH
70074: LD_INT 32
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: PUSH
70081: LD_INT 30
70083: PUSH
70084: LD_INT 4
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 30
70093: PUSH
70094: LD_INT 5
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: EMPTY
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: LIST
70111: PPUSH
70112: CALL_OW 72
70116: ST_TO_ADDR
70117: GO 70341
70119: LD_INT 2
70121: DOUBLE
70122: EQUAL
70123: IFTRUE 70127
70125: GO 70189
70127: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
70128: LD_ADDR_VAR 0 12
70132: PUSH
70133: LD_VAR 0 18
70137: PPUSH
70138: LD_INT 22
70140: PUSH
70141: LD_VAR 0 16
70145: PUSH
70146: EMPTY
70147: LIST
70148: LIST
70149: PUSH
70150: LD_INT 2
70152: PUSH
70153: LD_INT 30
70155: PUSH
70156: LD_INT 0
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 30
70165: PUSH
70166: LD_INT 1
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: LIST
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: PPUSH
70182: CALL_OW 72
70186: ST_TO_ADDR
70187: GO 70341
70189: LD_INT 3
70191: DOUBLE
70192: EQUAL
70193: IFTRUE 70197
70195: GO 70259
70197: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
70198: LD_ADDR_VAR 0 12
70202: PUSH
70203: LD_VAR 0 18
70207: PPUSH
70208: LD_INT 22
70210: PUSH
70211: LD_VAR 0 16
70215: PUSH
70216: EMPTY
70217: LIST
70218: LIST
70219: PUSH
70220: LD_INT 2
70222: PUSH
70223: LD_INT 30
70225: PUSH
70226: LD_INT 2
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 30
70235: PUSH
70236: LD_INT 3
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: LIST
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PPUSH
70252: CALL_OW 72
70256: ST_TO_ADDR
70257: GO 70341
70259: LD_INT 4
70261: DOUBLE
70262: EQUAL
70263: IFTRUE 70267
70265: GO 70340
70267: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
70268: LD_ADDR_VAR 0 12
70272: PUSH
70273: LD_VAR 0 18
70277: PPUSH
70278: LD_INT 22
70280: PUSH
70281: LD_VAR 0 16
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 2
70292: PUSH
70293: LD_INT 30
70295: PUSH
70296: LD_INT 6
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: LD_INT 30
70305: PUSH
70306: LD_INT 7
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 30
70315: PUSH
70316: LD_INT 8
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PPUSH
70333: CALL_OW 72
70337: ST_TO_ADDR
70338: GO 70341
70340: POP
// if i = 1 then
70341: LD_VAR 0 8
70345: PUSH
70346: LD_INT 1
70348: EQUAL
70349: IFFALSE 70460
// begin tmp := [ ] ;
70351: LD_ADDR_VAR 0 19
70355: PUSH
70356: EMPTY
70357: ST_TO_ADDR
// for j in f do
70358: LD_ADDR_VAR 0 9
70362: PUSH
70363: LD_VAR 0 12
70367: PUSH
70368: FOR_IN
70369: IFFALSE 70442
// if GetBType ( j ) = b_bunker then
70371: LD_VAR 0 9
70375: PPUSH
70376: CALL_OW 266
70380: PUSH
70381: LD_INT 32
70383: EQUAL
70384: IFFALSE 70411
// tmp := Insert ( tmp , 1 , j ) else
70386: LD_ADDR_VAR 0 19
70390: PUSH
70391: LD_VAR 0 19
70395: PPUSH
70396: LD_INT 1
70398: PPUSH
70399: LD_VAR 0 9
70403: PPUSH
70404: CALL_OW 2
70408: ST_TO_ADDR
70409: GO 70440
// tmp := Insert ( tmp , tmp + 1 , j ) ;
70411: LD_ADDR_VAR 0 19
70415: PUSH
70416: LD_VAR 0 19
70420: PPUSH
70421: LD_VAR 0 19
70425: PUSH
70426: LD_INT 1
70428: PLUS
70429: PPUSH
70430: LD_VAR 0 9
70434: PPUSH
70435: CALL_OW 2
70439: ST_TO_ADDR
70440: GO 70368
70442: POP
70443: POP
// if tmp then
70444: LD_VAR 0 19
70448: IFFALSE 70460
// f := tmp ;
70450: LD_ADDR_VAR 0 12
70454: PUSH
70455: LD_VAR 0 19
70459: ST_TO_ADDR
// end ; x := personel [ i ] ;
70460: LD_ADDR_VAR 0 13
70464: PUSH
70465: LD_VAR 0 6
70469: PUSH
70470: LD_VAR 0 8
70474: ARRAY
70475: ST_TO_ADDR
// if x = - 1 then
70476: LD_VAR 0 13
70480: PUSH
70481: LD_INT 1
70483: NEG
70484: EQUAL
70485: IFFALSE 70694
// begin for j in f do
70487: LD_ADDR_VAR 0 9
70491: PUSH
70492: LD_VAR 0 12
70496: PUSH
70497: FOR_IN
70498: IFFALSE 70690
// repeat InitHc ;
70500: CALL_OW 19
// if GetBType ( j ) = b_barracks then
70504: LD_VAR 0 9
70508: PPUSH
70509: CALL_OW 266
70513: PUSH
70514: LD_INT 5
70516: EQUAL
70517: IFFALSE 70587
// begin if UnitsInside ( j ) < 3 then
70519: LD_VAR 0 9
70523: PPUSH
70524: CALL_OW 313
70528: PUSH
70529: LD_INT 3
70531: LESS
70532: IFFALSE 70568
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70534: LD_INT 0
70536: PPUSH
70537: LD_INT 5
70539: PUSH
70540: LD_INT 8
70542: PUSH
70543: LD_INT 9
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: LIST
70550: PUSH
70551: LD_VAR 0 17
70555: ARRAY
70556: PPUSH
70557: LD_VAR 0 4
70561: PPUSH
70562: CALL_OW 380
70566: GO 70585
// PrepareHuman ( false , i , skill ) ;
70568: LD_INT 0
70570: PPUSH
70571: LD_VAR 0 8
70575: PPUSH
70576: LD_VAR 0 4
70580: PPUSH
70581: CALL_OW 380
// end else
70585: GO 70604
// PrepareHuman ( false , i , skill ) ;
70587: LD_INT 0
70589: PPUSH
70590: LD_VAR 0 8
70594: PPUSH
70595: LD_VAR 0 4
70599: PPUSH
70600: CALL_OW 380
// un := CreateHuman ;
70604: LD_ADDR_VAR 0 14
70608: PUSH
70609: CALL_OW 44
70613: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70614: LD_ADDR_VAR 0 7
70618: PUSH
70619: LD_VAR 0 7
70623: PPUSH
70624: LD_INT 1
70626: PPUSH
70627: LD_VAR 0 14
70631: PPUSH
70632: CALL_OW 2
70636: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
70637: LD_VAR 0 14
70641: PPUSH
70642: LD_VAR 0 9
70646: PPUSH
70647: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
70651: LD_VAR 0 9
70655: PPUSH
70656: CALL_OW 313
70660: PUSH
70661: LD_INT 6
70663: EQUAL
70664: PUSH
70665: LD_VAR 0 9
70669: PPUSH
70670: CALL_OW 266
70674: PUSH
70675: LD_INT 32
70677: PUSH
70678: LD_INT 31
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: IN
70685: OR
70686: IFFALSE 70500
70688: GO 70497
70690: POP
70691: POP
// end else
70692: GO 71074
// for j = 1 to x do
70694: LD_ADDR_VAR 0 9
70698: PUSH
70699: DOUBLE
70700: LD_INT 1
70702: DEC
70703: ST_TO_ADDR
70704: LD_VAR 0 13
70708: PUSH
70709: FOR_TO
70710: IFFALSE 71072
// begin InitHc ;
70712: CALL_OW 19
// if not f then
70716: LD_VAR 0 12
70720: NOT
70721: IFFALSE 70810
// begin PrepareHuman ( false , i , skill ) ;
70723: LD_INT 0
70725: PPUSH
70726: LD_VAR 0 8
70730: PPUSH
70731: LD_VAR 0 4
70735: PPUSH
70736: CALL_OW 380
// un := CreateHuman ;
70740: LD_ADDR_VAR 0 14
70744: PUSH
70745: CALL_OW 44
70749: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70750: LD_ADDR_VAR 0 7
70754: PUSH
70755: LD_VAR 0 7
70759: PPUSH
70760: LD_INT 1
70762: PPUSH
70763: LD_VAR 0 14
70767: PPUSH
70768: CALL_OW 2
70772: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70773: LD_VAR 0 14
70777: PPUSH
70778: LD_VAR 0 1
70782: PPUSH
70783: CALL_OW 250
70787: PPUSH
70788: LD_VAR 0 1
70792: PPUSH
70793: CALL_OW 251
70797: PPUSH
70798: LD_INT 10
70800: PPUSH
70801: LD_INT 0
70803: PPUSH
70804: CALL_OW 50
// continue ;
70808: GO 70709
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
70810: LD_VAR 0 12
70814: PUSH
70815: LD_INT 1
70817: ARRAY
70818: PPUSH
70819: CALL_OW 313
70823: PUSH
70824: LD_VAR 0 12
70828: PUSH
70829: LD_INT 1
70831: ARRAY
70832: PPUSH
70833: CALL_OW 266
70837: PUSH
70838: LD_INT 32
70840: PUSH
70841: LD_INT 31
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: IN
70848: AND
70849: PUSH
70850: LD_VAR 0 12
70854: PUSH
70855: LD_INT 1
70857: ARRAY
70858: PPUSH
70859: CALL_OW 313
70863: PUSH
70864: LD_INT 6
70866: EQUAL
70867: OR
70868: IFFALSE 70888
// f := Delete ( f , 1 ) ;
70870: LD_ADDR_VAR 0 12
70874: PUSH
70875: LD_VAR 0 12
70879: PPUSH
70880: LD_INT 1
70882: PPUSH
70883: CALL_OW 3
70887: ST_TO_ADDR
// if not f then
70888: LD_VAR 0 12
70892: NOT
70893: IFFALSE 70911
// begin x := x + 2 ;
70895: LD_ADDR_VAR 0 13
70899: PUSH
70900: LD_VAR 0 13
70904: PUSH
70905: LD_INT 2
70907: PLUS
70908: ST_TO_ADDR
// continue ;
70909: GO 70709
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
70911: LD_VAR 0 12
70915: PUSH
70916: LD_INT 1
70918: ARRAY
70919: PPUSH
70920: CALL_OW 266
70924: PUSH
70925: LD_INT 5
70927: EQUAL
70928: IFFALSE 71002
// begin if UnitsInside ( f [ 1 ] ) < 3 then
70930: LD_VAR 0 12
70934: PUSH
70935: LD_INT 1
70937: ARRAY
70938: PPUSH
70939: CALL_OW 313
70943: PUSH
70944: LD_INT 3
70946: LESS
70947: IFFALSE 70983
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70949: LD_INT 0
70951: PPUSH
70952: LD_INT 5
70954: PUSH
70955: LD_INT 8
70957: PUSH
70958: LD_INT 9
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: LIST
70965: PUSH
70966: LD_VAR 0 17
70970: ARRAY
70971: PPUSH
70972: LD_VAR 0 4
70976: PPUSH
70977: CALL_OW 380
70981: GO 71000
// PrepareHuman ( false , i , skill ) ;
70983: LD_INT 0
70985: PPUSH
70986: LD_VAR 0 8
70990: PPUSH
70991: LD_VAR 0 4
70995: PPUSH
70996: CALL_OW 380
// end else
71000: GO 71019
// PrepareHuman ( false , i , skill ) ;
71002: LD_INT 0
71004: PPUSH
71005: LD_VAR 0 8
71009: PPUSH
71010: LD_VAR 0 4
71014: PPUSH
71015: CALL_OW 380
// un := CreateHuman ;
71019: LD_ADDR_VAR 0 14
71023: PUSH
71024: CALL_OW 44
71028: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
71029: LD_ADDR_VAR 0 7
71033: PUSH
71034: LD_VAR 0 7
71038: PPUSH
71039: LD_INT 1
71041: PPUSH
71042: LD_VAR 0 14
71046: PPUSH
71047: CALL_OW 2
71051: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
71052: LD_VAR 0 14
71056: PPUSH
71057: LD_VAR 0 12
71061: PUSH
71062: LD_INT 1
71064: ARRAY
71065: PPUSH
71066: CALL_OW 52
// end ;
71070: GO 70709
71072: POP
71073: POP
// end ;
71074: GO 70011
71076: POP
71077: POP
// result := result ^ buildings ;
71078: LD_ADDR_VAR 0 7
71082: PUSH
71083: LD_VAR 0 7
71087: PUSH
71088: LD_VAR 0 18
71092: ADD
71093: ST_TO_ADDR
// end else
71094: GO 71237
// begin for i = 1 to personel do
71096: LD_ADDR_VAR 0 8
71100: PUSH
71101: DOUBLE
71102: LD_INT 1
71104: DEC
71105: ST_TO_ADDR
71106: LD_VAR 0 6
71110: PUSH
71111: FOR_TO
71112: IFFALSE 71235
// begin if i > 4 then
71114: LD_VAR 0 8
71118: PUSH
71119: LD_INT 4
71121: GREATER
71122: IFFALSE 71126
// break ;
71124: GO 71235
// x := personel [ i ] ;
71126: LD_ADDR_VAR 0 13
71130: PUSH
71131: LD_VAR 0 6
71135: PUSH
71136: LD_VAR 0 8
71140: ARRAY
71141: ST_TO_ADDR
// if x = - 1 then
71142: LD_VAR 0 13
71146: PUSH
71147: LD_INT 1
71149: NEG
71150: EQUAL
71151: IFFALSE 71155
// continue ;
71153: GO 71111
// PrepareHuman ( false , i , skill ) ;
71155: LD_INT 0
71157: PPUSH
71158: LD_VAR 0 8
71162: PPUSH
71163: LD_VAR 0 4
71167: PPUSH
71168: CALL_OW 380
// un := CreateHuman ;
71172: LD_ADDR_VAR 0 14
71176: PUSH
71177: CALL_OW 44
71181: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
71182: LD_VAR 0 14
71186: PPUSH
71187: LD_VAR 0 1
71191: PPUSH
71192: CALL_OW 250
71196: PPUSH
71197: LD_VAR 0 1
71201: PPUSH
71202: CALL_OW 251
71206: PPUSH
71207: LD_INT 10
71209: PPUSH
71210: LD_INT 0
71212: PPUSH
71213: CALL_OW 50
// result := result ^ un ;
71217: LD_ADDR_VAR 0 7
71221: PUSH
71222: LD_VAR 0 7
71226: PUSH
71227: LD_VAR 0 14
71231: ADD
71232: ST_TO_ADDR
// end ;
71233: GO 71111
71235: POP
71236: POP
// end ; end ;
71237: LD_VAR 0 7
71241: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
71242: LD_INT 0
71244: PPUSH
71245: PPUSH
71246: PPUSH
71247: PPUSH
71248: PPUSH
71249: PPUSH
71250: PPUSH
71251: PPUSH
71252: PPUSH
71253: PPUSH
71254: PPUSH
71255: PPUSH
71256: PPUSH
71257: PPUSH
71258: PPUSH
71259: PPUSH
// result := false ;
71260: LD_ADDR_VAR 0 3
71264: PUSH
71265: LD_INT 0
71267: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
71268: LD_VAR 0 1
71272: NOT
71273: PUSH
71274: LD_VAR 0 1
71278: PPUSH
71279: CALL_OW 266
71283: PUSH
71284: LD_INT 32
71286: PUSH
71287: LD_INT 33
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: IN
71294: NOT
71295: OR
71296: IFFALSE 71300
// exit ;
71298: GO 72409
// nat := GetNation ( tower ) ;
71300: LD_ADDR_VAR 0 12
71304: PUSH
71305: LD_VAR 0 1
71309: PPUSH
71310: CALL_OW 248
71314: ST_TO_ADDR
// side := GetSide ( tower ) ;
71315: LD_ADDR_VAR 0 16
71319: PUSH
71320: LD_VAR 0 1
71324: PPUSH
71325: CALL_OW 255
71329: ST_TO_ADDR
// x := GetX ( tower ) ;
71330: LD_ADDR_VAR 0 10
71334: PUSH
71335: LD_VAR 0 1
71339: PPUSH
71340: CALL_OW 250
71344: ST_TO_ADDR
// y := GetY ( tower ) ;
71345: LD_ADDR_VAR 0 11
71349: PUSH
71350: LD_VAR 0 1
71354: PPUSH
71355: CALL_OW 251
71359: ST_TO_ADDR
// if not x or not y then
71360: LD_VAR 0 10
71364: NOT
71365: PUSH
71366: LD_VAR 0 11
71370: NOT
71371: OR
71372: IFFALSE 71376
// exit ;
71374: GO 72409
// weapon := 0 ;
71376: LD_ADDR_VAR 0 18
71380: PUSH
71381: LD_INT 0
71383: ST_TO_ADDR
// fac_list := [ ] ;
71384: LD_ADDR_VAR 0 17
71388: PUSH
71389: EMPTY
71390: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
71391: LD_ADDR_VAR 0 6
71395: PUSH
71396: LD_VAR 0 1
71400: PPUSH
71401: CALL_OW 274
71405: PPUSH
71406: LD_VAR 0 2
71410: PPUSH
71411: LD_INT 0
71413: PPUSH
71414: CALL 68980 0 3
71418: PPUSH
71419: LD_INT 30
71421: PUSH
71422: LD_INT 3
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PPUSH
71429: CALL_OW 72
71433: ST_TO_ADDR
// if not factories then
71434: LD_VAR 0 6
71438: NOT
71439: IFFALSE 71443
// exit ;
71441: GO 72409
// for i in factories do
71443: LD_ADDR_VAR 0 8
71447: PUSH
71448: LD_VAR 0 6
71452: PUSH
71453: FOR_IN
71454: IFFALSE 71479
// fac_list := fac_list union AvailableWeaponList ( i ) ;
71456: LD_ADDR_VAR 0 17
71460: PUSH
71461: LD_VAR 0 17
71465: PUSH
71466: LD_VAR 0 8
71470: PPUSH
71471: CALL_OW 478
71475: UNION
71476: ST_TO_ADDR
71477: GO 71453
71479: POP
71480: POP
// if not fac_list then
71481: LD_VAR 0 17
71485: NOT
71486: IFFALSE 71490
// exit ;
71488: GO 72409
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
71490: LD_ADDR_VAR 0 5
71494: PUSH
71495: LD_INT 4
71497: PUSH
71498: LD_INT 5
71500: PUSH
71501: LD_INT 9
71503: PUSH
71504: LD_INT 10
71506: PUSH
71507: LD_INT 6
71509: PUSH
71510: LD_INT 7
71512: PUSH
71513: LD_INT 11
71515: PUSH
71516: EMPTY
71517: LIST
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 27
71527: PUSH
71528: LD_INT 28
71530: PUSH
71531: LD_INT 26
71533: PUSH
71534: LD_INT 30
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 43
71545: PUSH
71546: LD_INT 44
71548: PUSH
71549: LD_INT 46
71551: PUSH
71552: LD_INT 45
71554: PUSH
71555: LD_INT 47
71557: PUSH
71558: LD_INT 49
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: LIST
71565: LIST
71566: LIST
71567: LIST
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: LIST
71573: PUSH
71574: LD_VAR 0 12
71578: ARRAY
71579: ST_TO_ADDR
// list := list isect fac_list ;
71580: LD_ADDR_VAR 0 5
71584: PUSH
71585: LD_VAR 0 5
71589: PUSH
71590: LD_VAR 0 17
71594: ISECT
71595: ST_TO_ADDR
// if not list then
71596: LD_VAR 0 5
71600: NOT
71601: IFFALSE 71605
// exit ;
71603: GO 72409
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
71605: LD_VAR 0 12
71609: PUSH
71610: LD_INT 3
71612: EQUAL
71613: PUSH
71614: LD_INT 49
71616: PUSH
71617: LD_VAR 0 5
71621: IN
71622: AND
71623: PUSH
71624: LD_INT 31
71626: PPUSH
71627: LD_VAR 0 16
71631: PPUSH
71632: CALL_OW 321
71636: PUSH
71637: LD_INT 2
71639: EQUAL
71640: AND
71641: IFFALSE 71701
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
71643: LD_INT 22
71645: PUSH
71646: LD_VAR 0 16
71650: PUSH
71651: EMPTY
71652: LIST
71653: LIST
71654: PUSH
71655: LD_INT 35
71657: PUSH
71658: LD_INT 49
71660: PUSH
71661: EMPTY
71662: LIST
71663: LIST
71664: PUSH
71665: LD_INT 91
71667: PUSH
71668: LD_VAR 0 1
71672: PUSH
71673: LD_INT 10
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: LIST
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: LIST
71685: PPUSH
71686: CALL_OW 69
71690: NOT
71691: IFFALSE 71701
// weapon := ru_time_lapser ;
71693: LD_ADDR_VAR 0 18
71697: PUSH
71698: LD_INT 49
71700: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
71701: LD_VAR 0 12
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: LD_INT 2
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: IN
71716: PUSH
71717: LD_INT 11
71719: PUSH
71720: LD_VAR 0 5
71724: IN
71725: PUSH
71726: LD_INT 30
71728: PUSH
71729: LD_VAR 0 5
71733: IN
71734: OR
71735: AND
71736: PUSH
71737: LD_INT 6
71739: PPUSH
71740: LD_VAR 0 16
71744: PPUSH
71745: CALL_OW 321
71749: PUSH
71750: LD_INT 2
71752: EQUAL
71753: AND
71754: IFFALSE 71919
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
71756: LD_INT 22
71758: PUSH
71759: LD_VAR 0 16
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 2
71770: PUSH
71771: LD_INT 35
71773: PUSH
71774: LD_INT 11
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 35
71783: PUSH
71784: LD_INT 30
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: LIST
71795: PUSH
71796: LD_INT 91
71798: PUSH
71799: LD_VAR 0 1
71803: PUSH
71804: LD_INT 18
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: LIST
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: LIST
71816: PPUSH
71817: CALL_OW 69
71821: NOT
71822: PUSH
71823: LD_INT 22
71825: PUSH
71826: LD_VAR 0 16
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 2
71837: PUSH
71838: LD_INT 30
71840: PUSH
71841: LD_INT 32
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 30
71850: PUSH
71851: LD_INT 33
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: LIST
71862: PUSH
71863: LD_INT 91
71865: PUSH
71866: LD_VAR 0 1
71870: PUSH
71871: LD_INT 12
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: LIST
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: LIST
71883: PUSH
71884: EMPTY
71885: LIST
71886: PPUSH
71887: CALL_OW 69
71891: PUSH
71892: LD_INT 2
71894: GREATER
71895: AND
71896: IFFALSE 71919
// weapon := [ us_radar , ar_radar ] [ nat ] ;
71898: LD_ADDR_VAR 0 18
71902: PUSH
71903: LD_INT 11
71905: PUSH
71906: LD_INT 30
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_VAR 0 12
71917: ARRAY
71918: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
71919: LD_VAR 0 18
71923: NOT
71924: PUSH
71925: LD_INT 40
71927: PPUSH
71928: LD_VAR 0 16
71932: PPUSH
71933: CALL_OW 321
71937: PUSH
71938: LD_INT 2
71940: EQUAL
71941: AND
71942: PUSH
71943: LD_INT 7
71945: PUSH
71946: LD_VAR 0 5
71950: IN
71951: PUSH
71952: LD_INT 28
71954: PUSH
71955: LD_VAR 0 5
71959: IN
71960: OR
71961: PUSH
71962: LD_INT 45
71964: PUSH
71965: LD_VAR 0 5
71969: IN
71970: OR
71971: AND
71972: IFFALSE 72226
// begin hex := GetHexInfo ( x , y ) ;
71974: LD_ADDR_VAR 0 4
71978: PUSH
71979: LD_VAR 0 10
71983: PPUSH
71984: LD_VAR 0 11
71988: PPUSH
71989: CALL_OW 546
71993: ST_TO_ADDR
// if hex [ 1 ] then
71994: LD_VAR 0 4
71998: PUSH
71999: LD_INT 1
72001: ARRAY
72002: IFFALSE 72006
// exit ;
72004: GO 72409
// height := hex [ 2 ] ;
72006: LD_ADDR_VAR 0 15
72010: PUSH
72011: LD_VAR 0 4
72015: PUSH
72016: LD_INT 2
72018: ARRAY
72019: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
72020: LD_ADDR_VAR 0 14
72024: PUSH
72025: LD_INT 0
72027: PUSH
72028: LD_INT 2
72030: PUSH
72031: LD_INT 3
72033: PUSH
72034: LD_INT 5
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: LIST
72041: LIST
72042: ST_TO_ADDR
// for i in tmp do
72043: LD_ADDR_VAR 0 8
72047: PUSH
72048: LD_VAR 0 14
72052: PUSH
72053: FOR_IN
72054: IFFALSE 72224
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
72056: LD_ADDR_VAR 0 9
72060: PUSH
72061: LD_VAR 0 10
72065: PPUSH
72066: LD_VAR 0 8
72070: PPUSH
72071: LD_INT 5
72073: PPUSH
72074: CALL_OW 272
72078: PUSH
72079: LD_VAR 0 11
72083: PPUSH
72084: LD_VAR 0 8
72088: PPUSH
72089: LD_INT 5
72091: PPUSH
72092: CALL_OW 273
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
72101: LD_VAR 0 9
72105: PUSH
72106: LD_INT 1
72108: ARRAY
72109: PPUSH
72110: LD_VAR 0 9
72114: PUSH
72115: LD_INT 2
72117: ARRAY
72118: PPUSH
72119: CALL_OW 488
72123: IFFALSE 72222
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
72125: LD_ADDR_VAR 0 4
72129: PUSH
72130: LD_VAR 0 9
72134: PUSH
72135: LD_INT 1
72137: ARRAY
72138: PPUSH
72139: LD_VAR 0 9
72143: PUSH
72144: LD_INT 2
72146: ARRAY
72147: PPUSH
72148: CALL_OW 546
72152: ST_TO_ADDR
// if hex [ 1 ] then
72153: LD_VAR 0 4
72157: PUSH
72158: LD_INT 1
72160: ARRAY
72161: IFFALSE 72165
// continue ;
72163: GO 72053
// h := hex [ 2 ] ;
72165: LD_ADDR_VAR 0 13
72169: PUSH
72170: LD_VAR 0 4
72174: PUSH
72175: LD_INT 2
72177: ARRAY
72178: ST_TO_ADDR
// if h + 7 < height then
72179: LD_VAR 0 13
72183: PUSH
72184: LD_INT 7
72186: PLUS
72187: PUSH
72188: LD_VAR 0 15
72192: LESS
72193: IFFALSE 72222
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
72195: LD_ADDR_VAR 0 18
72199: PUSH
72200: LD_INT 7
72202: PUSH
72203: LD_INT 28
72205: PUSH
72206: LD_INT 45
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: LIST
72213: PUSH
72214: LD_VAR 0 12
72218: ARRAY
72219: ST_TO_ADDR
// break ;
72220: GO 72224
// end ; end ; end ;
72222: GO 72053
72224: POP
72225: POP
// end ; if not weapon then
72226: LD_VAR 0 18
72230: NOT
72231: IFFALSE 72291
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
72233: LD_ADDR_VAR 0 5
72237: PUSH
72238: LD_VAR 0 5
72242: PUSH
72243: LD_INT 11
72245: PUSH
72246: LD_INT 30
72248: PUSH
72249: LD_INT 49
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: LIST
72256: DIFF
72257: ST_TO_ADDR
// if not list then
72258: LD_VAR 0 5
72262: NOT
72263: IFFALSE 72267
// exit ;
72265: GO 72409
// weapon := list [ rand ( 1 , list ) ] ;
72267: LD_ADDR_VAR 0 18
72271: PUSH
72272: LD_VAR 0 5
72276: PUSH
72277: LD_INT 1
72279: PPUSH
72280: LD_VAR 0 5
72284: PPUSH
72285: CALL_OW 12
72289: ARRAY
72290: ST_TO_ADDR
// end ; if weapon then
72291: LD_VAR 0 18
72295: IFFALSE 72409
// begin tmp := CostOfWeapon ( weapon ) ;
72297: LD_ADDR_VAR 0 14
72301: PUSH
72302: LD_VAR 0 18
72306: PPUSH
72307: CALL_OW 451
72311: ST_TO_ADDR
// j := GetBase ( tower ) ;
72312: LD_ADDR_VAR 0 9
72316: PUSH
72317: LD_VAR 0 1
72321: PPUSH
72322: CALL_OW 274
72326: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
72327: LD_VAR 0 9
72331: PPUSH
72332: LD_INT 1
72334: PPUSH
72335: CALL_OW 275
72339: PUSH
72340: LD_VAR 0 14
72344: PUSH
72345: LD_INT 1
72347: ARRAY
72348: GREATEREQUAL
72349: PUSH
72350: LD_VAR 0 9
72354: PPUSH
72355: LD_INT 2
72357: PPUSH
72358: CALL_OW 275
72362: PUSH
72363: LD_VAR 0 14
72367: PUSH
72368: LD_INT 2
72370: ARRAY
72371: GREATEREQUAL
72372: AND
72373: PUSH
72374: LD_VAR 0 9
72378: PPUSH
72379: LD_INT 3
72381: PPUSH
72382: CALL_OW 275
72386: PUSH
72387: LD_VAR 0 14
72391: PUSH
72392: LD_INT 3
72394: ARRAY
72395: GREATEREQUAL
72396: AND
72397: IFFALSE 72409
// result := weapon ;
72399: LD_ADDR_VAR 0 3
72403: PUSH
72404: LD_VAR 0 18
72408: ST_TO_ADDR
// end ; end ;
72409: LD_VAR 0 3
72413: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
72414: LD_INT 0
72416: PPUSH
72417: PPUSH
// result := true ;
72418: LD_ADDR_VAR 0 3
72422: PUSH
72423: LD_INT 1
72425: ST_TO_ADDR
// if array1 = array2 then
72426: LD_VAR 0 1
72430: PUSH
72431: LD_VAR 0 2
72435: EQUAL
72436: IFFALSE 72496
// begin for i = 1 to array1 do
72438: LD_ADDR_VAR 0 4
72442: PUSH
72443: DOUBLE
72444: LD_INT 1
72446: DEC
72447: ST_TO_ADDR
72448: LD_VAR 0 1
72452: PUSH
72453: FOR_TO
72454: IFFALSE 72492
// if array1 [ i ] <> array2 [ i ] then
72456: LD_VAR 0 1
72460: PUSH
72461: LD_VAR 0 4
72465: ARRAY
72466: PUSH
72467: LD_VAR 0 2
72471: PUSH
72472: LD_VAR 0 4
72476: ARRAY
72477: NONEQUAL
72478: IFFALSE 72490
// begin result := false ;
72480: LD_ADDR_VAR 0 3
72484: PUSH
72485: LD_INT 0
72487: ST_TO_ADDR
// break ;
72488: GO 72492
// end ;
72490: GO 72453
72492: POP
72493: POP
// end else
72494: GO 72504
// result := false ;
72496: LD_ADDR_VAR 0 3
72500: PUSH
72501: LD_INT 0
72503: ST_TO_ADDR
// end ;
72504: LD_VAR 0 3
72508: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
72509: LD_INT 0
72511: PPUSH
72512: PPUSH
// if not array1 or not array2 then
72513: LD_VAR 0 1
72517: NOT
72518: PUSH
72519: LD_VAR 0 2
72523: NOT
72524: OR
72525: IFFALSE 72529
// exit ;
72527: GO 72593
// result := true ;
72529: LD_ADDR_VAR 0 3
72533: PUSH
72534: LD_INT 1
72536: ST_TO_ADDR
// for i = 1 to array1 do
72537: LD_ADDR_VAR 0 4
72541: PUSH
72542: DOUBLE
72543: LD_INT 1
72545: DEC
72546: ST_TO_ADDR
72547: LD_VAR 0 1
72551: PUSH
72552: FOR_TO
72553: IFFALSE 72591
// if array1 [ i ] <> array2 [ i ] then
72555: LD_VAR 0 1
72559: PUSH
72560: LD_VAR 0 4
72564: ARRAY
72565: PUSH
72566: LD_VAR 0 2
72570: PUSH
72571: LD_VAR 0 4
72575: ARRAY
72576: NONEQUAL
72577: IFFALSE 72589
// begin result := false ;
72579: LD_ADDR_VAR 0 3
72583: PUSH
72584: LD_INT 0
72586: ST_TO_ADDR
// break ;
72587: GO 72591
// end ;
72589: GO 72552
72591: POP
72592: POP
// end ;
72593: LD_VAR 0 3
72597: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
72598: LD_INT 0
72600: PPUSH
72601: PPUSH
72602: PPUSH
// pom := GetBase ( fac ) ;
72603: LD_ADDR_VAR 0 5
72607: PUSH
72608: LD_VAR 0 1
72612: PPUSH
72613: CALL_OW 274
72617: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
72618: LD_ADDR_VAR 0 4
72622: PUSH
72623: LD_VAR 0 2
72627: PUSH
72628: LD_INT 1
72630: ARRAY
72631: PPUSH
72632: LD_VAR 0 2
72636: PUSH
72637: LD_INT 2
72639: ARRAY
72640: PPUSH
72641: LD_VAR 0 2
72645: PUSH
72646: LD_INT 3
72648: ARRAY
72649: PPUSH
72650: LD_VAR 0 2
72654: PUSH
72655: LD_INT 4
72657: ARRAY
72658: PPUSH
72659: CALL_OW 449
72663: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72664: LD_ADDR_VAR 0 3
72668: PUSH
72669: LD_VAR 0 5
72673: PPUSH
72674: LD_INT 1
72676: PPUSH
72677: CALL_OW 275
72681: PUSH
72682: LD_VAR 0 4
72686: PUSH
72687: LD_INT 1
72689: ARRAY
72690: GREATEREQUAL
72691: PUSH
72692: LD_VAR 0 5
72696: PPUSH
72697: LD_INT 2
72699: PPUSH
72700: CALL_OW 275
72704: PUSH
72705: LD_VAR 0 4
72709: PUSH
72710: LD_INT 2
72712: ARRAY
72713: GREATEREQUAL
72714: AND
72715: PUSH
72716: LD_VAR 0 5
72720: PPUSH
72721: LD_INT 3
72723: PPUSH
72724: CALL_OW 275
72728: PUSH
72729: LD_VAR 0 4
72733: PUSH
72734: LD_INT 3
72736: ARRAY
72737: GREATEREQUAL
72738: AND
72739: ST_TO_ADDR
// end ;
72740: LD_VAR 0 3
72744: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
72745: LD_INT 0
72747: PPUSH
72748: PPUSH
72749: PPUSH
72750: PPUSH
// pom := GetBase ( building ) ;
72751: LD_ADDR_VAR 0 3
72755: PUSH
72756: LD_VAR 0 1
72760: PPUSH
72761: CALL_OW 274
72765: ST_TO_ADDR
// if not pom then
72766: LD_VAR 0 3
72770: NOT
72771: IFFALSE 72775
// exit ;
72773: GO 72945
// btype := GetBType ( building ) ;
72775: LD_ADDR_VAR 0 5
72779: PUSH
72780: LD_VAR 0 1
72784: PPUSH
72785: CALL_OW 266
72789: ST_TO_ADDR
// if btype = b_armoury then
72790: LD_VAR 0 5
72794: PUSH
72795: LD_INT 4
72797: EQUAL
72798: IFFALSE 72808
// btype := b_barracks ;
72800: LD_ADDR_VAR 0 5
72804: PUSH
72805: LD_INT 5
72807: ST_TO_ADDR
// if btype = b_depot then
72808: LD_VAR 0 5
72812: PUSH
72813: LD_INT 0
72815: EQUAL
72816: IFFALSE 72826
// btype := b_warehouse ;
72818: LD_ADDR_VAR 0 5
72822: PUSH
72823: LD_INT 1
72825: ST_TO_ADDR
// if btype = b_workshop then
72826: LD_VAR 0 5
72830: PUSH
72831: LD_INT 2
72833: EQUAL
72834: IFFALSE 72844
// btype := b_factory ;
72836: LD_ADDR_VAR 0 5
72840: PUSH
72841: LD_INT 3
72843: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72844: LD_ADDR_VAR 0 4
72848: PUSH
72849: LD_VAR 0 5
72853: PPUSH
72854: LD_VAR 0 1
72858: PPUSH
72859: CALL_OW 248
72863: PPUSH
72864: CALL_OW 450
72868: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72869: LD_ADDR_VAR 0 2
72873: PUSH
72874: LD_VAR 0 3
72878: PPUSH
72879: LD_INT 1
72881: PPUSH
72882: CALL_OW 275
72886: PUSH
72887: LD_VAR 0 4
72891: PUSH
72892: LD_INT 1
72894: ARRAY
72895: GREATEREQUAL
72896: PUSH
72897: LD_VAR 0 3
72901: PPUSH
72902: LD_INT 2
72904: PPUSH
72905: CALL_OW 275
72909: PUSH
72910: LD_VAR 0 4
72914: PUSH
72915: LD_INT 2
72917: ARRAY
72918: GREATEREQUAL
72919: AND
72920: PUSH
72921: LD_VAR 0 3
72925: PPUSH
72926: LD_INT 3
72928: PPUSH
72929: CALL_OW 275
72933: PUSH
72934: LD_VAR 0 4
72938: PUSH
72939: LD_INT 3
72941: ARRAY
72942: GREATEREQUAL
72943: AND
72944: ST_TO_ADDR
// end ;
72945: LD_VAR 0 2
72949: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
72950: LD_INT 0
72952: PPUSH
72953: PPUSH
72954: PPUSH
// pom := GetBase ( building ) ;
72955: LD_ADDR_VAR 0 4
72959: PUSH
72960: LD_VAR 0 1
72964: PPUSH
72965: CALL_OW 274
72969: ST_TO_ADDR
// if not pom then
72970: LD_VAR 0 4
72974: NOT
72975: IFFALSE 72979
// exit ;
72977: GO 73080
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72979: LD_ADDR_VAR 0 5
72983: PUSH
72984: LD_VAR 0 2
72988: PPUSH
72989: LD_VAR 0 1
72993: PPUSH
72994: CALL_OW 248
72998: PPUSH
72999: CALL_OW 450
73003: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
73004: LD_ADDR_VAR 0 3
73008: PUSH
73009: LD_VAR 0 4
73013: PPUSH
73014: LD_INT 1
73016: PPUSH
73017: CALL_OW 275
73021: PUSH
73022: LD_VAR 0 5
73026: PUSH
73027: LD_INT 1
73029: ARRAY
73030: GREATEREQUAL
73031: PUSH
73032: LD_VAR 0 4
73036: PPUSH
73037: LD_INT 2
73039: PPUSH
73040: CALL_OW 275
73044: PUSH
73045: LD_VAR 0 5
73049: PUSH
73050: LD_INT 2
73052: ARRAY
73053: GREATEREQUAL
73054: AND
73055: PUSH
73056: LD_VAR 0 4
73060: PPUSH
73061: LD_INT 3
73063: PPUSH
73064: CALL_OW 275
73068: PUSH
73069: LD_VAR 0 5
73073: PUSH
73074: LD_INT 3
73076: ARRAY
73077: GREATEREQUAL
73078: AND
73079: ST_TO_ADDR
// end ;
73080: LD_VAR 0 3
73084: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
73085: LD_INT 0
73087: PPUSH
73088: PPUSH
73089: PPUSH
73090: PPUSH
73091: PPUSH
73092: PPUSH
73093: PPUSH
73094: PPUSH
73095: PPUSH
73096: PPUSH
73097: PPUSH
// result := false ;
73098: LD_ADDR_VAR 0 8
73102: PUSH
73103: LD_INT 0
73105: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
73106: LD_VAR 0 5
73110: NOT
73111: PUSH
73112: LD_VAR 0 1
73116: NOT
73117: OR
73118: PUSH
73119: LD_VAR 0 2
73123: NOT
73124: OR
73125: PUSH
73126: LD_VAR 0 3
73130: NOT
73131: OR
73132: IFFALSE 73136
// exit ;
73134: GO 73950
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
73136: LD_ADDR_VAR 0 14
73140: PUSH
73141: LD_VAR 0 1
73145: PPUSH
73146: LD_VAR 0 2
73150: PPUSH
73151: LD_VAR 0 3
73155: PPUSH
73156: LD_VAR 0 4
73160: PPUSH
73161: LD_VAR 0 5
73165: PUSH
73166: LD_INT 1
73168: ARRAY
73169: PPUSH
73170: CALL_OW 248
73174: PPUSH
73175: LD_INT 0
73177: PPUSH
73178: CALL 75187 0 6
73182: ST_TO_ADDR
// if not hexes then
73183: LD_VAR 0 14
73187: NOT
73188: IFFALSE 73192
// exit ;
73190: GO 73950
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73192: LD_ADDR_VAR 0 17
73196: PUSH
73197: LD_VAR 0 5
73201: PPUSH
73202: LD_INT 22
73204: PUSH
73205: LD_VAR 0 13
73209: PPUSH
73210: CALL_OW 255
73214: PUSH
73215: EMPTY
73216: LIST
73217: LIST
73218: PUSH
73219: LD_INT 2
73221: PUSH
73222: LD_INT 30
73224: PUSH
73225: LD_INT 0
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 30
73234: PUSH
73235: LD_INT 1
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: LIST
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PPUSH
73251: CALL_OW 72
73255: ST_TO_ADDR
// for i = 1 to hexes do
73256: LD_ADDR_VAR 0 9
73260: PUSH
73261: DOUBLE
73262: LD_INT 1
73264: DEC
73265: ST_TO_ADDR
73266: LD_VAR 0 14
73270: PUSH
73271: FOR_TO
73272: IFFALSE 73948
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
73274: LD_ADDR_VAR 0 13
73278: PUSH
73279: LD_VAR 0 14
73283: PUSH
73284: LD_VAR 0 9
73288: ARRAY
73289: PUSH
73290: LD_INT 1
73292: ARRAY
73293: PPUSH
73294: LD_VAR 0 14
73298: PUSH
73299: LD_VAR 0 9
73303: ARRAY
73304: PUSH
73305: LD_INT 2
73307: ARRAY
73308: PPUSH
73309: CALL_OW 428
73313: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
73314: LD_VAR 0 14
73318: PUSH
73319: LD_VAR 0 9
73323: ARRAY
73324: PUSH
73325: LD_INT 1
73327: ARRAY
73328: PPUSH
73329: LD_VAR 0 14
73333: PUSH
73334: LD_VAR 0 9
73338: ARRAY
73339: PUSH
73340: LD_INT 2
73342: ARRAY
73343: PPUSH
73344: CALL_OW 351
73348: PUSH
73349: LD_VAR 0 14
73353: PUSH
73354: LD_VAR 0 9
73358: ARRAY
73359: PUSH
73360: LD_INT 1
73362: ARRAY
73363: PPUSH
73364: LD_VAR 0 14
73368: PUSH
73369: LD_VAR 0 9
73373: ARRAY
73374: PUSH
73375: LD_INT 2
73377: ARRAY
73378: PPUSH
73379: CALL_OW 488
73383: NOT
73384: OR
73385: PUSH
73386: LD_VAR 0 13
73390: PPUSH
73391: CALL_OW 247
73395: PUSH
73396: LD_INT 3
73398: EQUAL
73399: OR
73400: IFFALSE 73406
// exit ;
73402: POP
73403: POP
73404: GO 73950
// if not tmp then
73406: LD_VAR 0 13
73410: NOT
73411: IFFALSE 73415
// continue ;
73413: GO 73271
// result := true ;
73415: LD_ADDR_VAR 0 8
73419: PUSH
73420: LD_INT 1
73422: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
73423: LD_VAR 0 6
73427: PUSH
73428: LD_VAR 0 13
73432: PPUSH
73433: CALL_OW 247
73437: PUSH
73438: LD_INT 2
73440: EQUAL
73441: AND
73442: PUSH
73443: LD_VAR 0 13
73447: PPUSH
73448: CALL_OW 263
73452: PUSH
73453: LD_INT 1
73455: EQUAL
73456: AND
73457: IFFALSE 73621
// begin if IsDrivenBy ( tmp ) then
73459: LD_VAR 0 13
73463: PPUSH
73464: CALL_OW 311
73468: IFFALSE 73472
// continue ;
73470: GO 73271
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
73472: LD_VAR 0 6
73476: PPUSH
73477: LD_INT 3
73479: PUSH
73480: LD_INT 60
73482: PUSH
73483: EMPTY
73484: LIST
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 3
73492: PUSH
73493: LD_INT 55
73495: PUSH
73496: EMPTY
73497: LIST
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PPUSH
73507: CALL_OW 72
73511: IFFALSE 73619
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
73513: LD_ADDR_VAR 0 18
73517: PUSH
73518: LD_VAR 0 6
73522: PPUSH
73523: LD_INT 3
73525: PUSH
73526: LD_INT 60
73528: PUSH
73529: EMPTY
73530: LIST
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 3
73538: PUSH
73539: LD_INT 55
73541: PUSH
73542: EMPTY
73543: LIST
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PPUSH
73553: CALL_OW 72
73557: PUSH
73558: LD_INT 1
73560: ARRAY
73561: ST_TO_ADDR
// if IsInUnit ( driver ) then
73562: LD_VAR 0 18
73566: PPUSH
73567: CALL_OW 310
73571: IFFALSE 73582
// ComExit ( driver ) ;
73573: LD_VAR 0 18
73577: PPUSH
73578: CALL 98371 0 1
// AddComEnterUnit ( driver , tmp ) ;
73582: LD_VAR 0 18
73586: PPUSH
73587: LD_VAR 0 13
73591: PPUSH
73592: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
73596: LD_VAR 0 18
73600: PPUSH
73601: LD_VAR 0 7
73605: PPUSH
73606: CALL_OW 173
// AddComExitVehicle ( driver ) ;
73610: LD_VAR 0 18
73614: PPUSH
73615: CALL_OW 181
// end ; continue ;
73619: GO 73271
// end ; if not cleaners or not tmp in cleaners then
73621: LD_VAR 0 6
73625: NOT
73626: PUSH
73627: LD_VAR 0 13
73631: PUSH
73632: LD_VAR 0 6
73636: IN
73637: NOT
73638: OR
73639: IFFALSE 73946
// begin if dep then
73641: LD_VAR 0 17
73645: IFFALSE 73781
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
73647: LD_ADDR_VAR 0 16
73651: PUSH
73652: LD_VAR 0 17
73656: PUSH
73657: LD_INT 1
73659: ARRAY
73660: PPUSH
73661: CALL_OW 250
73665: PPUSH
73666: LD_VAR 0 17
73670: PUSH
73671: LD_INT 1
73673: ARRAY
73674: PPUSH
73675: CALL_OW 254
73679: PPUSH
73680: LD_INT 5
73682: PPUSH
73683: CALL_OW 272
73687: PUSH
73688: LD_VAR 0 17
73692: PUSH
73693: LD_INT 1
73695: ARRAY
73696: PPUSH
73697: CALL_OW 251
73701: PPUSH
73702: LD_VAR 0 17
73706: PUSH
73707: LD_INT 1
73709: ARRAY
73710: PPUSH
73711: CALL_OW 254
73715: PPUSH
73716: LD_INT 5
73718: PPUSH
73719: CALL_OW 273
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
73728: LD_VAR 0 16
73732: PUSH
73733: LD_INT 1
73735: ARRAY
73736: PPUSH
73737: LD_VAR 0 16
73741: PUSH
73742: LD_INT 2
73744: ARRAY
73745: PPUSH
73746: CALL_OW 488
73750: IFFALSE 73781
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
73752: LD_VAR 0 13
73756: PPUSH
73757: LD_VAR 0 16
73761: PUSH
73762: LD_INT 1
73764: ARRAY
73765: PPUSH
73766: LD_VAR 0 16
73770: PUSH
73771: LD_INT 2
73773: ARRAY
73774: PPUSH
73775: CALL_OW 111
// continue ;
73779: GO 73271
// end ; end ; r := GetDir ( tmp ) ;
73781: LD_ADDR_VAR 0 15
73785: PUSH
73786: LD_VAR 0 13
73790: PPUSH
73791: CALL_OW 254
73795: ST_TO_ADDR
// if r = 5 then
73796: LD_VAR 0 15
73800: PUSH
73801: LD_INT 5
73803: EQUAL
73804: IFFALSE 73814
// r := 0 ;
73806: LD_ADDR_VAR 0 15
73810: PUSH
73811: LD_INT 0
73813: ST_TO_ADDR
// for j = r to 5 do
73814: LD_ADDR_VAR 0 10
73818: PUSH
73819: DOUBLE
73820: LD_VAR 0 15
73824: DEC
73825: ST_TO_ADDR
73826: LD_INT 5
73828: PUSH
73829: FOR_TO
73830: IFFALSE 73944
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
73832: LD_ADDR_VAR 0 11
73836: PUSH
73837: LD_VAR 0 13
73841: PPUSH
73842: CALL_OW 250
73846: PPUSH
73847: LD_VAR 0 10
73851: PPUSH
73852: LD_INT 2
73854: PPUSH
73855: CALL_OW 272
73859: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
73860: LD_ADDR_VAR 0 12
73864: PUSH
73865: LD_VAR 0 13
73869: PPUSH
73870: CALL_OW 251
73874: PPUSH
73875: LD_VAR 0 10
73879: PPUSH
73880: LD_INT 2
73882: PPUSH
73883: CALL_OW 273
73887: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
73888: LD_VAR 0 11
73892: PPUSH
73893: LD_VAR 0 12
73897: PPUSH
73898: CALL_OW 488
73902: PUSH
73903: LD_VAR 0 11
73907: PPUSH
73908: LD_VAR 0 12
73912: PPUSH
73913: CALL_OW 428
73917: NOT
73918: AND
73919: IFFALSE 73942
// begin ComMoveXY ( tmp , _x , _y ) ;
73921: LD_VAR 0 13
73925: PPUSH
73926: LD_VAR 0 11
73930: PPUSH
73931: LD_VAR 0 12
73935: PPUSH
73936: CALL_OW 111
// break ;
73940: GO 73944
// end ; end ;
73942: GO 73829
73944: POP
73945: POP
// end ; end ;
73946: GO 73271
73948: POP
73949: POP
// end ;
73950: LD_VAR 0 8
73954: RET
// export function BuildingTechInvented ( side , btype ) ; begin
73955: LD_INT 0
73957: PPUSH
// result := true ;
73958: LD_ADDR_VAR 0 3
73962: PUSH
73963: LD_INT 1
73965: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
73966: LD_VAR 0 2
73970: PUSH
73971: LD_INT 24
73973: DOUBLE
73974: EQUAL
73975: IFTRUE 73985
73977: LD_INT 33
73979: DOUBLE
73980: EQUAL
73981: IFTRUE 73985
73983: GO 74010
73985: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
73986: LD_ADDR_VAR 0 3
73990: PUSH
73991: LD_INT 32
73993: PPUSH
73994: LD_VAR 0 1
73998: PPUSH
73999: CALL_OW 321
74003: PUSH
74004: LD_INT 2
74006: EQUAL
74007: ST_TO_ADDR
74008: GO 74330
74010: LD_INT 20
74012: DOUBLE
74013: EQUAL
74014: IFTRUE 74018
74016: GO 74043
74018: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
74019: LD_ADDR_VAR 0 3
74023: PUSH
74024: LD_INT 6
74026: PPUSH
74027: LD_VAR 0 1
74031: PPUSH
74032: CALL_OW 321
74036: PUSH
74037: LD_INT 2
74039: EQUAL
74040: ST_TO_ADDR
74041: GO 74330
74043: LD_INT 22
74045: DOUBLE
74046: EQUAL
74047: IFTRUE 74057
74049: LD_INT 36
74051: DOUBLE
74052: EQUAL
74053: IFTRUE 74057
74055: GO 74082
74057: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
74058: LD_ADDR_VAR 0 3
74062: PUSH
74063: LD_INT 15
74065: PPUSH
74066: LD_VAR 0 1
74070: PPUSH
74071: CALL_OW 321
74075: PUSH
74076: LD_INT 2
74078: EQUAL
74079: ST_TO_ADDR
74080: GO 74330
74082: LD_INT 30
74084: DOUBLE
74085: EQUAL
74086: IFTRUE 74090
74088: GO 74115
74090: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
74091: LD_ADDR_VAR 0 3
74095: PUSH
74096: LD_INT 20
74098: PPUSH
74099: LD_VAR 0 1
74103: PPUSH
74104: CALL_OW 321
74108: PUSH
74109: LD_INT 2
74111: EQUAL
74112: ST_TO_ADDR
74113: GO 74330
74115: LD_INT 28
74117: DOUBLE
74118: EQUAL
74119: IFTRUE 74129
74121: LD_INT 21
74123: DOUBLE
74124: EQUAL
74125: IFTRUE 74129
74127: GO 74154
74129: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
74130: LD_ADDR_VAR 0 3
74134: PUSH
74135: LD_INT 21
74137: PPUSH
74138: LD_VAR 0 1
74142: PPUSH
74143: CALL_OW 321
74147: PUSH
74148: LD_INT 2
74150: EQUAL
74151: ST_TO_ADDR
74152: GO 74330
74154: LD_INT 16
74156: DOUBLE
74157: EQUAL
74158: IFTRUE 74162
74160: GO 74189
74162: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
74163: LD_ADDR_VAR 0 3
74167: PUSH
74168: LD_EXP 85
74172: PPUSH
74173: LD_VAR 0 1
74177: PPUSH
74178: CALL_OW 321
74182: PUSH
74183: LD_INT 2
74185: EQUAL
74186: ST_TO_ADDR
74187: GO 74330
74189: LD_INT 19
74191: DOUBLE
74192: EQUAL
74193: IFTRUE 74203
74195: LD_INT 23
74197: DOUBLE
74198: EQUAL
74199: IFTRUE 74203
74201: GO 74230
74203: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
74204: LD_ADDR_VAR 0 3
74208: PUSH
74209: LD_EXP 84
74213: PPUSH
74214: LD_VAR 0 1
74218: PPUSH
74219: CALL_OW 321
74223: PUSH
74224: LD_INT 2
74226: EQUAL
74227: ST_TO_ADDR
74228: GO 74330
74230: LD_INT 17
74232: DOUBLE
74233: EQUAL
74234: IFTRUE 74238
74236: GO 74263
74238: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
74239: LD_ADDR_VAR 0 3
74243: PUSH
74244: LD_INT 39
74246: PPUSH
74247: LD_VAR 0 1
74251: PPUSH
74252: CALL_OW 321
74256: PUSH
74257: LD_INT 2
74259: EQUAL
74260: ST_TO_ADDR
74261: GO 74330
74263: LD_INT 18
74265: DOUBLE
74266: EQUAL
74267: IFTRUE 74271
74269: GO 74296
74271: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
74272: LD_ADDR_VAR 0 3
74276: PUSH
74277: LD_INT 40
74279: PPUSH
74280: LD_VAR 0 1
74284: PPUSH
74285: CALL_OW 321
74289: PUSH
74290: LD_INT 2
74292: EQUAL
74293: ST_TO_ADDR
74294: GO 74330
74296: LD_INT 27
74298: DOUBLE
74299: EQUAL
74300: IFTRUE 74304
74302: GO 74329
74304: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
74305: LD_ADDR_VAR 0 3
74309: PUSH
74310: LD_INT 35
74312: PPUSH
74313: LD_VAR 0 1
74317: PPUSH
74318: CALL_OW 321
74322: PUSH
74323: LD_INT 2
74325: EQUAL
74326: ST_TO_ADDR
74327: GO 74330
74329: POP
// end ;
74330: LD_VAR 0 3
74334: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
74335: LD_INT 0
74337: PPUSH
74338: PPUSH
74339: PPUSH
74340: PPUSH
74341: PPUSH
74342: PPUSH
74343: PPUSH
74344: PPUSH
74345: PPUSH
74346: PPUSH
74347: PPUSH
// result := false ;
74348: LD_ADDR_VAR 0 6
74352: PUSH
74353: LD_INT 0
74355: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
74356: LD_VAR 0 1
74360: NOT
74361: PUSH
74362: LD_VAR 0 1
74366: PPUSH
74367: CALL_OW 266
74371: PUSH
74372: LD_INT 0
74374: PUSH
74375: LD_INT 1
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: IN
74382: NOT
74383: OR
74384: PUSH
74385: LD_VAR 0 2
74389: NOT
74390: OR
74391: PUSH
74392: LD_VAR 0 5
74396: PUSH
74397: LD_INT 0
74399: PUSH
74400: LD_INT 1
74402: PUSH
74403: LD_INT 2
74405: PUSH
74406: LD_INT 3
74408: PUSH
74409: LD_INT 4
74411: PUSH
74412: LD_INT 5
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: IN
74423: NOT
74424: OR
74425: PUSH
74426: LD_VAR 0 3
74430: PPUSH
74431: LD_VAR 0 4
74435: PPUSH
74436: CALL_OW 488
74440: NOT
74441: OR
74442: IFFALSE 74446
// exit ;
74444: GO 75182
// side := GetSide ( depot ) ;
74446: LD_ADDR_VAR 0 9
74450: PUSH
74451: LD_VAR 0 1
74455: PPUSH
74456: CALL_OW 255
74460: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
74461: LD_VAR 0 9
74465: PPUSH
74466: LD_VAR 0 2
74470: PPUSH
74471: CALL 73955 0 2
74475: NOT
74476: IFFALSE 74480
// exit ;
74478: GO 75182
// pom := GetBase ( depot ) ;
74480: LD_ADDR_VAR 0 10
74484: PUSH
74485: LD_VAR 0 1
74489: PPUSH
74490: CALL_OW 274
74494: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
74495: LD_ADDR_VAR 0 11
74499: PUSH
74500: LD_VAR 0 2
74504: PPUSH
74505: LD_VAR 0 1
74509: PPUSH
74510: CALL_OW 248
74514: PPUSH
74515: CALL_OW 450
74519: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
74520: LD_VAR 0 10
74524: PPUSH
74525: LD_INT 1
74527: PPUSH
74528: CALL_OW 275
74532: PUSH
74533: LD_VAR 0 11
74537: PUSH
74538: LD_INT 1
74540: ARRAY
74541: GREATEREQUAL
74542: PUSH
74543: LD_VAR 0 10
74547: PPUSH
74548: LD_INT 2
74550: PPUSH
74551: CALL_OW 275
74555: PUSH
74556: LD_VAR 0 11
74560: PUSH
74561: LD_INT 2
74563: ARRAY
74564: GREATEREQUAL
74565: AND
74566: PUSH
74567: LD_VAR 0 10
74571: PPUSH
74572: LD_INT 3
74574: PPUSH
74575: CALL_OW 275
74579: PUSH
74580: LD_VAR 0 11
74584: PUSH
74585: LD_INT 3
74587: ARRAY
74588: GREATEREQUAL
74589: AND
74590: NOT
74591: IFFALSE 74595
// exit ;
74593: GO 75182
// if GetBType ( depot ) = b_depot then
74595: LD_VAR 0 1
74599: PPUSH
74600: CALL_OW 266
74604: PUSH
74605: LD_INT 0
74607: EQUAL
74608: IFFALSE 74620
// dist := 28 else
74610: LD_ADDR_VAR 0 14
74614: PUSH
74615: LD_INT 28
74617: ST_TO_ADDR
74618: GO 74628
// dist := 36 ;
74620: LD_ADDR_VAR 0 14
74624: PUSH
74625: LD_INT 36
74627: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
74628: LD_VAR 0 1
74632: PPUSH
74633: LD_VAR 0 3
74637: PPUSH
74638: LD_VAR 0 4
74642: PPUSH
74643: CALL_OW 297
74647: PUSH
74648: LD_VAR 0 14
74652: GREATER
74653: IFFALSE 74657
// exit ;
74655: GO 75182
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
74657: LD_ADDR_VAR 0 12
74661: PUSH
74662: LD_VAR 0 2
74666: PPUSH
74667: LD_VAR 0 3
74671: PPUSH
74672: LD_VAR 0 4
74676: PPUSH
74677: LD_VAR 0 5
74681: PPUSH
74682: LD_VAR 0 1
74686: PPUSH
74687: CALL_OW 248
74691: PPUSH
74692: LD_INT 0
74694: PPUSH
74695: CALL 75187 0 6
74699: ST_TO_ADDR
// if not hexes then
74700: LD_VAR 0 12
74704: NOT
74705: IFFALSE 74709
// exit ;
74707: GO 75182
// hex := GetHexInfo ( x , y ) ;
74709: LD_ADDR_VAR 0 15
74713: PUSH
74714: LD_VAR 0 3
74718: PPUSH
74719: LD_VAR 0 4
74723: PPUSH
74724: CALL_OW 546
74728: ST_TO_ADDR
// if hex [ 1 ] then
74729: LD_VAR 0 15
74733: PUSH
74734: LD_INT 1
74736: ARRAY
74737: IFFALSE 74741
// exit ;
74739: GO 75182
// height := hex [ 2 ] ;
74741: LD_ADDR_VAR 0 13
74745: PUSH
74746: LD_VAR 0 15
74750: PUSH
74751: LD_INT 2
74753: ARRAY
74754: ST_TO_ADDR
// for i = 1 to hexes do
74755: LD_ADDR_VAR 0 7
74759: PUSH
74760: DOUBLE
74761: LD_INT 1
74763: DEC
74764: ST_TO_ADDR
74765: LD_VAR 0 12
74769: PUSH
74770: FOR_TO
74771: IFFALSE 75101
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
74773: LD_VAR 0 12
74777: PUSH
74778: LD_VAR 0 7
74782: ARRAY
74783: PUSH
74784: LD_INT 1
74786: ARRAY
74787: PPUSH
74788: LD_VAR 0 12
74792: PUSH
74793: LD_VAR 0 7
74797: ARRAY
74798: PUSH
74799: LD_INT 2
74801: ARRAY
74802: PPUSH
74803: CALL_OW 488
74807: NOT
74808: PUSH
74809: LD_VAR 0 12
74813: PUSH
74814: LD_VAR 0 7
74818: ARRAY
74819: PUSH
74820: LD_INT 1
74822: ARRAY
74823: PPUSH
74824: LD_VAR 0 12
74828: PUSH
74829: LD_VAR 0 7
74833: ARRAY
74834: PUSH
74835: LD_INT 2
74837: ARRAY
74838: PPUSH
74839: CALL_OW 428
74843: PUSH
74844: LD_INT 0
74846: GREATER
74847: OR
74848: PUSH
74849: LD_VAR 0 12
74853: PUSH
74854: LD_VAR 0 7
74858: ARRAY
74859: PUSH
74860: LD_INT 1
74862: ARRAY
74863: PPUSH
74864: LD_VAR 0 12
74868: PUSH
74869: LD_VAR 0 7
74873: ARRAY
74874: PUSH
74875: LD_INT 2
74877: ARRAY
74878: PPUSH
74879: CALL_OW 351
74883: OR
74884: IFFALSE 74890
// exit ;
74886: POP
74887: POP
74888: GO 75182
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74890: LD_ADDR_VAR 0 8
74894: PUSH
74895: LD_VAR 0 12
74899: PUSH
74900: LD_VAR 0 7
74904: ARRAY
74905: PUSH
74906: LD_INT 1
74908: ARRAY
74909: PPUSH
74910: LD_VAR 0 12
74914: PUSH
74915: LD_VAR 0 7
74919: ARRAY
74920: PUSH
74921: LD_INT 2
74923: ARRAY
74924: PPUSH
74925: CALL_OW 546
74929: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
74930: LD_VAR 0 8
74934: PUSH
74935: LD_INT 1
74937: ARRAY
74938: PUSH
74939: LD_VAR 0 8
74943: PUSH
74944: LD_INT 2
74946: ARRAY
74947: PUSH
74948: LD_VAR 0 13
74952: PUSH
74953: LD_INT 2
74955: PLUS
74956: GREATER
74957: OR
74958: PUSH
74959: LD_VAR 0 8
74963: PUSH
74964: LD_INT 2
74966: ARRAY
74967: PUSH
74968: LD_VAR 0 13
74972: PUSH
74973: LD_INT 2
74975: MINUS
74976: LESS
74977: OR
74978: PUSH
74979: LD_VAR 0 8
74983: PUSH
74984: LD_INT 3
74986: ARRAY
74987: PUSH
74988: LD_INT 0
74990: PUSH
74991: LD_INT 8
74993: PUSH
74994: LD_INT 9
74996: PUSH
74997: LD_INT 10
74999: PUSH
75000: LD_INT 11
75002: PUSH
75003: LD_INT 12
75005: PUSH
75006: LD_INT 13
75008: PUSH
75009: LD_INT 16
75011: PUSH
75012: LD_INT 17
75014: PUSH
75015: LD_INT 18
75017: PUSH
75018: LD_INT 19
75020: PUSH
75021: LD_INT 20
75023: PUSH
75024: LD_INT 21
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: LIST
75040: LIST
75041: IN
75042: NOT
75043: OR
75044: PUSH
75045: LD_VAR 0 8
75049: PUSH
75050: LD_INT 5
75052: ARRAY
75053: NOT
75054: OR
75055: PUSH
75056: LD_VAR 0 8
75060: PUSH
75061: LD_INT 6
75063: ARRAY
75064: PUSH
75065: LD_INT 1
75067: PUSH
75068: LD_INT 2
75070: PUSH
75071: LD_INT 7
75073: PUSH
75074: LD_INT 9
75076: PUSH
75077: LD_INT 10
75079: PUSH
75080: LD_INT 11
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: LIST
75087: LIST
75088: LIST
75089: LIST
75090: IN
75091: NOT
75092: OR
75093: IFFALSE 75099
// exit ;
75095: POP
75096: POP
75097: GO 75182
// end ;
75099: GO 74770
75101: POP
75102: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75103: LD_VAR 0 9
75107: PPUSH
75108: LD_VAR 0 3
75112: PPUSH
75113: LD_VAR 0 4
75117: PPUSH
75118: LD_INT 20
75120: PPUSH
75121: CALL 67128 0 4
75125: PUSH
75126: LD_INT 4
75128: ARRAY
75129: IFFALSE 75133
// exit ;
75131: GO 75182
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
75133: LD_VAR 0 2
75137: PUSH
75138: LD_INT 29
75140: PUSH
75141: LD_INT 30
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: IN
75148: PUSH
75149: LD_VAR 0 3
75153: PPUSH
75154: LD_VAR 0 4
75158: PPUSH
75159: LD_VAR 0 9
75163: PPUSH
75164: CALL_OW 440
75168: NOT
75169: AND
75170: IFFALSE 75174
// exit ;
75172: GO 75182
// result := true ;
75174: LD_ADDR_VAR 0 6
75178: PUSH
75179: LD_INT 1
75181: ST_TO_ADDR
// end ;
75182: LD_VAR 0 6
75186: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
75187: LD_INT 0
75189: PPUSH
75190: PPUSH
75191: PPUSH
75192: PPUSH
75193: PPUSH
75194: PPUSH
75195: PPUSH
75196: PPUSH
75197: PPUSH
75198: PPUSH
75199: PPUSH
75200: PPUSH
75201: PPUSH
75202: PPUSH
75203: PPUSH
75204: PPUSH
75205: PPUSH
75206: PPUSH
75207: PPUSH
75208: PPUSH
75209: PPUSH
75210: PPUSH
75211: PPUSH
75212: PPUSH
75213: PPUSH
75214: PPUSH
75215: PPUSH
75216: PPUSH
75217: PPUSH
75218: PPUSH
75219: PPUSH
75220: PPUSH
75221: PPUSH
75222: PPUSH
75223: PPUSH
75224: PPUSH
75225: PPUSH
75226: PPUSH
75227: PPUSH
75228: PPUSH
75229: PPUSH
75230: PPUSH
75231: PPUSH
75232: PPUSH
75233: PPUSH
75234: PPUSH
75235: PPUSH
75236: PPUSH
75237: PPUSH
75238: PPUSH
75239: PPUSH
75240: PPUSH
75241: PPUSH
75242: PPUSH
75243: PPUSH
75244: PPUSH
75245: PPUSH
75246: PPUSH
// result = [ ] ;
75247: LD_ADDR_VAR 0 7
75251: PUSH
75252: EMPTY
75253: ST_TO_ADDR
// temp_list = [ ] ;
75254: LD_ADDR_VAR 0 9
75258: PUSH
75259: EMPTY
75260: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
75261: LD_VAR 0 4
75265: PUSH
75266: LD_INT 0
75268: PUSH
75269: LD_INT 1
75271: PUSH
75272: LD_INT 2
75274: PUSH
75275: LD_INT 3
75277: PUSH
75278: LD_INT 4
75280: PUSH
75281: LD_INT 5
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: LIST
75288: LIST
75289: LIST
75290: LIST
75291: IN
75292: NOT
75293: PUSH
75294: LD_VAR 0 1
75298: PUSH
75299: LD_INT 0
75301: PUSH
75302: LD_INT 1
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: IN
75309: PUSH
75310: LD_VAR 0 5
75314: PUSH
75315: LD_INT 1
75317: PUSH
75318: LD_INT 2
75320: PUSH
75321: LD_INT 3
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: LIST
75328: IN
75329: NOT
75330: AND
75331: OR
75332: IFFALSE 75336
// exit ;
75334: GO 93727
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
75336: LD_VAR 0 1
75340: PUSH
75341: LD_INT 6
75343: PUSH
75344: LD_INT 7
75346: PUSH
75347: LD_INT 8
75349: PUSH
75350: LD_INT 13
75352: PUSH
75353: LD_INT 12
75355: PUSH
75356: LD_INT 15
75358: PUSH
75359: LD_INT 11
75361: PUSH
75362: LD_INT 14
75364: PUSH
75365: LD_INT 10
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: LIST
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: IN
75379: IFFALSE 75389
// btype = b_lab ;
75381: LD_ADDR_VAR 0 1
75385: PUSH
75386: LD_INT 6
75388: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
75389: LD_VAR 0 6
75393: PUSH
75394: LD_INT 0
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 2
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: LIST
75407: IN
75408: NOT
75409: PUSH
75410: LD_VAR 0 1
75414: PUSH
75415: LD_INT 0
75417: PUSH
75418: LD_INT 1
75420: PUSH
75421: LD_INT 2
75423: PUSH
75424: LD_INT 3
75426: PUSH
75427: LD_INT 6
75429: PUSH
75430: LD_INT 36
75432: PUSH
75433: LD_INT 4
75435: PUSH
75436: LD_INT 5
75438: PUSH
75439: LD_INT 31
75441: PUSH
75442: LD_INT 32
75444: PUSH
75445: LD_INT 33
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: IN
75461: NOT
75462: PUSH
75463: LD_VAR 0 6
75467: PUSH
75468: LD_INT 1
75470: EQUAL
75471: AND
75472: OR
75473: PUSH
75474: LD_VAR 0 1
75478: PUSH
75479: LD_INT 2
75481: PUSH
75482: LD_INT 3
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: IN
75489: NOT
75490: PUSH
75491: LD_VAR 0 6
75495: PUSH
75496: LD_INT 2
75498: EQUAL
75499: AND
75500: OR
75501: IFFALSE 75511
// mode = 0 ;
75503: LD_ADDR_VAR 0 6
75507: PUSH
75508: LD_INT 0
75510: ST_TO_ADDR
// case mode of 0 :
75511: LD_VAR 0 6
75515: PUSH
75516: LD_INT 0
75518: DOUBLE
75519: EQUAL
75520: IFTRUE 75524
75522: GO 86977
75524: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75525: LD_ADDR_VAR 0 11
75529: PUSH
75530: LD_INT 0
75532: PUSH
75533: LD_INT 0
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 0
75542: PUSH
75543: LD_INT 1
75545: NEG
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: LD_INT 1
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 1
75563: PUSH
75564: LD_INT 1
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 0
75573: PUSH
75574: LD_INT 1
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 1
75583: NEG
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 1
75594: NEG
75595: PUSH
75596: LD_INT 1
75598: NEG
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: LD_INT 1
75606: NEG
75607: PUSH
75608: LD_INT 2
75610: NEG
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 0
75618: PUSH
75619: LD_INT 2
75621: NEG
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: LD_INT 1
75629: PUSH
75630: LD_INT 1
75632: NEG
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 1
75640: PUSH
75641: LD_INT 2
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 0
75650: PUSH
75651: LD_INT 2
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 1
75660: NEG
75661: PUSH
75662: LD_INT 1
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 1
75671: PUSH
75672: LD_INT 3
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 0
75681: PUSH
75682: LD_INT 3
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 1
75691: NEG
75692: PUSH
75693: LD_INT 2
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: LIST
75704: LIST
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: LIST
75713: LIST
75714: LIST
75715: LIST
75716: LIST
75717: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75718: LD_ADDR_VAR 0 12
75722: PUSH
75723: LD_INT 0
75725: PUSH
75726: LD_INT 0
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 0
75735: PUSH
75736: LD_INT 1
75738: NEG
75739: PUSH
75740: EMPTY
75741: LIST
75742: LIST
75743: PUSH
75744: LD_INT 1
75746: PUSH
75747: LD_INT 0
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: LD_INT 1
75756: PUSH
75757: LD_INT 1
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: PUSH
75764: LD_INT 0
75766: PUSH
75767: LD_INT 1
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PUSH
75774: LD_INT 1
75776: NEG
75777: PUSH
75778: LD_INT 0
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 1
75787: NEG
75788: PUSH
75789: LD_INT 1
75791: NEG
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 1
75799: PUSH
75800: LD_INT 1
75802: NEG
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: LD_INT 2
75810: PUSH
75811: LD_INT 0
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_INT 2
75820: PUSH
75821: LD_INT 1
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 1
75830: NEG
75831: PUSH
75832: LD_INT 1
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 2
75841: NEG
75842: PUSH
75843: LD_INT 0
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 2
75852: NEG
75853: PUSH
75854: LD_INT 1
75856: NEG
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 2
75864: NEG
75865: PUSH
75866: LD_INT 1
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 3
75875: NEG
75876: PUSH
75877: LD_INT 0
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 3
75886: NEG
75887: PUSH
75888: LD_INT 1
75890: NEG
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: LIST
75903: LIST
75904: LIST
75905: LIST
75906: LIST
75907: LIST
75908: LIST
75909: LIST
75910: LIST
75911: LIST
75912: LIST
75913: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75914: LD_ADDR_VAR 0 13
75918: PUSH
75919: LD_INT 0
75921: PUSH
75922: LD_INT 0
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: LD_INT 0
75931: PUSH
75932: LD_INT 1
75934: NEG
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: LD_INT 1
75942: PUSH
75943: LD_INT 0
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: LD_INT 1
75952: PUSH
75953: LD_INT 1
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 0
75962: PUSH
75963: LD_INT 1
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 1
75972: NEG
75973: PUSH
75974: LD_INT 0
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: LD_INT 1
75983: NEG
75984: PUSH
75985: LD_INT 1
75987: NEG
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 1
75995: NEG
75996: PUSH
75997: LD_INT 2
75999: NEG
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: LD_INT 2
76007: PUSH
76008: LD_INT 1
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 2
76017: PUSH
76018: LD_INT 2
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 1
76027: PUSH
76028: LD_INT 2
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 2
76037: NEG
76038: PUSH
76039: LD_INT 1
76041: NEG
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: LD_INT 2
76049: NEG
76050: PUSH
76051: LD_INT 2
76053: NEG
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: LD_INT 2
76061: NEG
76062: PUSH
76063: LD_INT 3
76065: NEG
76066: PUSH
76067: EMPTY
76068: LIST
76069: LIST
76070: PUSH
76071: LD_INT 3
76073: NEG
76074: PUSH
76075: LD_INT 2
76077: NEG
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: LD_INT 3
76085: NEG
76086: PUSH
76087: LD_INT 3
76089: NEG
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: LIST
76099: LIST
76100: LIST
76101: LIST
76102: LIST
76103: LIST
76104: LIST
76105: LIST
76106: LIST
76107: LIST
76108: LIST
76109: LIST
76110: LIST
76111: LIST
76112: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76113: LD_ADDR_VAR 0 14
76117: PUSH
76118: LD_INT 0
76120: PUSH
76121: LD_INT 0
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 0
76130: PUSH
76131: LD_INT 1
76133: NEG
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: PUSH
76139: LD_INT 1
76141: PUSH
76142: LD_INT 0
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 1
76151: PUSH
76152: LD_INT 1
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 0
76161: PUSH
76162: LD_INT 1
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: PUSH
76169: LD_INT 1
76171: NEG
76172: PUSH
76173: LD_INT 0
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 1
76182: NEG
76183: PUSH
76184: LD_INT 1
76186: NEG
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 1
76194: NEG
76195: PUSH
76196: LD_INT 2
76198: NEG
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 0
76206: PUSH
76207: LD_INT 2
76209: NEG
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 1
76217: PUSH
76218: LD_INT 1
76220: NEG
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: PUSH
76226: LD_INT 1
76228: PUSH
76229: LD_INT 2
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: LD_INT 0
76238: PUSH
76239: LD_INT 2
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: LD_INT 1
76248: NEG
76249: PUSH
76250: LD_INT 1
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 1
76259: NEG
76260: PUSH
76261: LD_INT 3
76263: NEG
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: PUSH
76269: LD_INT 0
76271: PUSH
76272: LD_INT 3
76274: NEG
76275: PUSH
76276: EMPTY
76277: LIST
76278: LIST
76279: PUSH
76280: LD_INT 1
76282: PUSH
76283: LD_INT 2
76285: NEG
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: LIST
76305: LIST
76306: LIST
76307: LIST
76308: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76309: LD_ADDR_VAR 0 15
76313: PUSH
76314: LD_INT 0
76316: PUSH
76317: LD_INT 0
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 0
76326: PUSH
76327: LD_INT 1
76329: NEG
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 1
76337: PUSH
76338: LD_INT 0
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: PUSH
76345: LD_INT 1
76347: PUSH
76348: LD_INT 1
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 0
76357: PUSH
76358: LD_INT 1
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 1
76367: NEG
76368: PUSH
76369: LD_INT 0
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 1
76378: NEG
76379: PUSH
76380: LD_INT 1
76382: NEG
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: LD_INT 1
76390: PUSH
76391: LD_INT 1
76393: NEG
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 2
76401: PUSH
76402: LD_INT 0
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 2
76411: PUSH
76412: LD_INT 1
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: PUSH
76419: LD_INT 1
76421: NEG
76422: PUSH
76423: LD_INT 1
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: LD_INT 0
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: LD_INT 2
76443: NEG
76444: PUSH
76445: LD_INT 1
76447: NEG
76448: PUSH
76449: EMPTY
76450: LIST
76451: LIST
76452: PUSH
76453: LD_INT 2
76455: PUSH
76456: LD_INT 1
76458: NEG
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: PUSH
76464: LD_INT 3
76466: PUSH
76467: LD_INT 0
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 3
76476: PUSH
76477: LD_INT 1
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76502: LD_ADDR_VAR 0 16
76506: PUSH
76507: LD_INT 0
76509: PUSH
76510: LD_INT 0
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: PUSH
76517: LD_INT 0
76519: PUSH
76520: LD_INT 1
76522: NEG
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 1
76530: PUSH
76531: LD_INT 0
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 1
76540: PUSH
76541: LD_INT 1
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: LD_INT 0
76550: PUSH
76551: LD_INT 1
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PUSH
76558: LD_INT 1
76560: NEG
76561: PUSH
76562: LD_INT 0
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 1
76571: NEG
76572: PUSH
76573: LD_INT 1
76575: NEG
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: LD_INT 1
76583: NEG
76584: PUSH
76585: LD_INT 2
76587: NEG
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 2
76595: PUSH
76596: LD_INT 1
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 2
76605: PUSH
76606: LD_INT 2
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 1
76615: PUSH
76616: LD_INT 2
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: PUSH
76623: LD_INT 2
76625: NEG
76626: PUSH
76627: LD_INT 1
76629: NEG
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 2
76637: NEG
76638: PUSH
76639: LD_INT 2
76641: NEG
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 3
76649: PUSH
76650: LD_INT 2
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_INT 3
76659: PUSH
76660: LD_INT 3
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: LD_INT 3
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: LIST
76681: LIST
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: LIST
76690: LIST
76691: LIST
76692: LIST
76693: LIST
76694: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76695: LD_ADDR_VAR 0 17
76699: PUSH
76700: LD_INT 0
76702: PUSH
76703: LD_INT 0
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: PUSH
76710: LD_INT 0
76712: PUSH
76713: LD_INT 1
76715: NEG
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: LD_INT 1
76723: PUSH
76724: LD_INT 0
76726: PUSH
76727: EMPTY
76728: LIST
76729: LIST
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: LD_INT 1
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 0
76743: PUSH
76744: LD_INT 1
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: LD_INT 1
76753: NEG
76754: PUSH
76755: LD_INT 0
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: LD_INT 1
76764: NEG
76765: PUSH
76766: LD_INT 1
76768: NEG
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 1
76776: NEG
76777: PUSH
76778: LD_INT 2
76780: NEG
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 0
76788: PUSH
76789: LD_INT 2
76791: NEG
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 1
76799: PUSH
76800: LD_INT 1
76802: NEG
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 2
76810: PUSH
76811: LD_INT 0
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 2
76820: PUSH
76821: LD_INT 1
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 2
76830: PUSH
76831: LD_INT 2
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 1
76840: PUSH
76841: LD_INT 2
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: LD_INT 0
76850: PUSH
76851: LD_INT 2
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 1
76860: NEG
76861: PUSH
76862: LD_INT 1
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 2
76871: NEG
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 2
76882: NEG
76883: PUSH
76884: LD_INT 1
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 2
76894: NEG
76895: PUSH
76896: LD_INT 2
76898: NEG
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: LIST
76908: LIST
76909: LIST
76910: LIST
76911: LIST
76912: LIST
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76925: LD_ADDR_VAR 0 18
76929: PUSH
76930: LD_INT 0
76932: PUSH
76933: LD_INT 0
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: LD_INT 0
76942: PUSH
76943: LD_INT 1
76945: NEG
76946: PUSH
76947: EMPTY
76948: LIST
76949: LIST
76950: PUSH
76951: LD_INT 1
76953: PUSH
76954: LD_INT 0
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 1
76963: PUSH
76964: LD_INT 1
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PUSH
76971: LD_INT 0
76973: PUSH
76974: LD_INT 1
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: LD_INT 1
76983: NEG
76984: PUSH
76985: LD_INT 0
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 1
76994: NEG
76995: PUSH
76996: LD_INT 1
76998: NEG
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 1
77006: NEG
77007: PUSH
77008: LD_INT 2
77010: NEG
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 0
77018: PUSH
77019: LD_INT 2
77021: NEG
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 1
77029: PUSH
77030: LD_INT 1
77032: NEG
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 2
77040: PUSH
77041: LD_INT 0
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 2
77050: PUSH
77051: LD_INT 1
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 2
77060: PUSH
77061: LD_INT 2
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 1
77070: PUSH
77071: LD_INT 2
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 0
77080: PUSH
77081: LD_INT 2
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 1
77090: NEG
77091: PUSH
77092: LD_INT 1
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 2
77101: NEG
77102: PUSH
77103: LD_INT 0
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 2
77112: NEG
77113: PUSH
77114: LD_INT 1
77116: NEG
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 2
77124: NEG
77125: PUSH
77126: LD_INT 2
77128: NEG
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: LIST
77143: LIST
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: LIST
77151: LIST
77152: LIST
77153: LIST
77154: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77155: LD_ADDR_VAR 0 19
77159: PUSH
77160: LD_INT 0
77162: PUSH
77163: LD_INT 0
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: LD_INT 0
77172: PUSH
77173: LD_INT 1
77175: NEG
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: LD_INT 1
77183: PUSH
77184: LD_INT 0
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 1
77193: PUSH
77194: LD_INT 1
77196: PUSH
77197: EMPTY
77198: LIST
77199: LIST
77200: PUSH
77201: LD_INT 0
77203: PUSH
77204: LD_INT 1
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 1
77213: NEG
77214: PUSH
77215: LD_INT 0
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 1
77224: NEG
77225: PUSH
77226: LD_INT 1
77228: NEG
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 1
77236: NEG
77237: PUSH
77238: LD_INT 2
77240: NEG
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 0
77248: PUSH
77249: LD_INT 2
77251: NEG
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: LD_INT 1
77259: PUSH
77260: LD_INT 1
77262: NEG
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 2
77270: PUSH
77271: LD_INT 0
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 2
77280: PUSH
77281: LD_INT 1
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 2
77290: PUSH
77291: LD_INT 2
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 1
77300: PUSH
77301: LD_INT 2
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 0
77310: PUSH
77311: LD_INT 2
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 1
77320: NEG
77321: PUSH
77322: LD_INT 1
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 2
77331: NEG
77332: PUSH
77333: LD_INT 0
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: PUSH
77340: LD_INT 2
77342: NEG
77343: PUSH
77344: LD_INT 1
77346: NEG
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 2
77354: NEG
77355: PUSH
77356: LD_INT 2
77358: NEG
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: LIST
77368: LIST
77369: LIST
77370: LIST
77371: LIST
77372: LIST
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: LIST
77381: LIST
77382: LIST
77383: LIST
77384: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77385: LD_ADDR_VAR 0 20
77389: PUSH
77390: LD_INT 0
77392: PUSH
77393: LD_INT 0
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: LD_INT 0
77402: PUSH
77403: LD_INT 1
77405: NEG
77406: PUSH
77407: EMPTY
77408: LIST
77409: LIST
77410: PUSH
77411: LD_INT 1
77413: PUSH
77414: LD_INT 0
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 1
77423: PUSH
77424: LD_INT 1
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: PUSH
77431: LD_INT 0
77433: PUSH
77434: LD_INT 1
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 1
77443: NEG
77444: PUSH
77445: LD_INT 0
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 1
77454: NEG
77455: PUSH
77456: LD_INT 1
77458: NEG
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 1
77466: NEG
77467: PUSH
77468: LD_INT 2
77470: NEG
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 0
77478: PUSH
77479: LD_INT 2
77481: NEG
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: LD_INT 1
77489: PUSH
77490: LD_INT 1
77492: NEG
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: PUSH
77498: LD_INT 2
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: PUSH
77508: LD_INT 2
77510: PUSH
77511: LD_INT 1
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 2
77520: PUSH
77521: LD_INT 2
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 1
77530: PUSH
77531: LD_INT 2
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 0
77540: PUSH
77541: LD_INT 2
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 1
77550: NEG
77551: PUSH
77552: LD_INT 1
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 2
77561: NEG
77562: PUSH
77563: LD_INT 0
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: LD_INT 2
77572: NEG
77573: PUSH
77574: LD_INT 1
77576: NEG
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 2
77584: NEG
77585: PUSH
77586: LD_INT 2
77588: NEG
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: LIST
77606: LIST
77607: LIST
77608: LIST
77609: LIST
77610: LIST
77611: LIST
77612: LIST
77613: LIST
77614: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77615: LD_ADDR_VAR 0 21
77619: PUSH
77620: LD_INT 0
77622: PUSH
77623: LD_INT 0
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 0
77632: PUSH
77633: LD_INT 1
77635: NEG
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 1
77643: PUSH
77644: LD_INT 0
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 1
77653: PUSH
77654: LD_INT 1
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: PUSH
77661: LD_INT 0
77663: PUSH
77664: LD_INT 1
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: PUSH
77671: LD_INT 1
77673: NEG
77674: PUSH
77675: LD_INT 0
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 1
77684: NEG
77685: PUSH
77686: LD_INT 1
77688: NEG
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PUSH
77694: LD_INT 1
77696: NEG
77697: PUSH
77698: LD_INT 2
77700: NEG
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: LD_INT 0
77708: PUSH
77709: LD_INT 2
77711: NEG
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 1
77719: PUSH
77720: LD_INT 1
77722: NEG
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 2
77730: PUSH
77731: LD_INT 0
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: LD_INT 2
77740: PUSH
77741: LD_INT 1
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: LD_INT 2
77750: PUSH
77751: LD_INT 2
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 1
77760: PUSH
77761: LD_INT 2
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 0
77770: PUSH
77771: LD_INT 2
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 1
77780: NEG
77781: PUSH
77782: LD_INT 1
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 2
77791: NEG
77792: PUSH
77793: LD_INT 0
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: PUSH
77800: LD_INT 2
77802: NEG
77803: PUSH
77804: LD_INT 1
77806: NEG
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 2
77814: NEG
77815: PUSH
77816: LD_INT 2
77818: NEG
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: PUSH
77824: EMPTY
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: LIST
77830: LIST
77831: LIST
77832: LIST
77833: LIST
77834: LIST
77835: LIST
77836: LIST
77837: LIST
77838: LIST
77839: LIST
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77845: LD_ADDR_VAR 0 22
77849: PUSH
77850: LD_INT 0
77852: PUSH
77853: LD_INT 0
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: LD_INT 0
77862: PUSH
77863: LD_INT 1
77865: NEG
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 1
77873: PUSH
77874: LD_INT 0
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 1
77883: PUSH
77884: LD_INT 1
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: LD_INT 0
77893: PUSH
77894: LD_INT 1
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 1
77903: NEG
77904: PUSH
77905: LD_INT 0
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 1
77914: NEG
77915: PUSH
77916: LD_INT 1
77918: NEG
77919: PUSH
77920: EMPTY
77921: LIST
77922: LIST
77923: PUSH
77924: LD_INT 1
77926: NEG
77927: PUSH
77928: LD_INT 2
77930: NEG
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 0
77938: PUSH
77939: LD_INT 2
77941: NEG
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 1
77949: PUSH
77950: LD_INT 1
77952: NEG
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 2
77960: PUSH
77961: LD_INT 0
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PUSH
77968: LD_INT 2
77970: PUSH
77971: LD_INT 1
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: PUSH
77978: LD_INT 2
77980: PUSH
77981: LD_INT 2
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 1
77990: PUSH
77991: LD_INT 2
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 0
78000: PUSH
78001: LD_INT 2
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 1
78010: NEG
78011: PUSH
78012: LD_INT 1
78014: PUSH
78015: EMPTY
78016: LIST
78017: LIST
78018: PUSH
78019: LD_INT 2
78021: NEG
78022: PUSH
78023: LD_INT 0
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 2
78032: NEG
78033: PUSH
78034: LD_INT 1
78036: NEG
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PUSH
78042: LD_INT 2
78044: NEG
78045: PUSH
78046: LD_INT 2
78048: NEG
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: LIST
78062: LIST
78063: LIST
78064: LIST
78065: LIST
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: LIST
78071: LIST
78072: LIST
78073: LIST
78074: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78075: LD_ADDR_VAR 0 23
78079: PUSH
78080: LD_INT 0
78082: PUSH
78083: LD_INT 0
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 0
78092: PUSH
78093: LD_INT 1
78095: NEG
78096: PUSH
78097: EMPTY
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 1
78103: PUSH
78104: LD_INT 0
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PUSH
78111: LD_INT 1
78113: PUSH
78114: LD_INT 1
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: PUSH
78121: LD_INT 0
78123: PUSH
78124: LD_INT 1
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: LD_INT 1
78133: NEG
78134: PUSH
78135: LD_INT 0
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: LD_INT 1
78144: NEG
78145: PUSH
78146: LD_INT 1
78148: NEG
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 1
78156: NEG
78157: PUSH
78158: LD_INT 2
78160: NEG
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 0
78168: PUSH
78169: LD_INT 2
78171: NEG
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 1
78179: PUSH
78180: LD_INT 1
78182: NEG
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: LD_INT 2
78190: PUSH
78191: LD_INT 0
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: PUSH
78198: LD_INT 2
78200: PUSH
78201: LD_INT 1
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PUSH
78208: LD_INT 2
78210: PUSH
78211: LD_INT 2
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 1
78220: PUSH
78221: LD_INT 2
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: PUSH
78228: LD_INT 0
78230: PUSH
78231: LD_INT 2
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 1
78240: NEG
78241: PUSH
78242: LD_INT 1
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 2
78251: NEG
78252: PUSH
78253: LD_INT 0
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 2
78262: NEG
78263: PUSH
78264: LD_INT 1
78266: NEG
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 2
78274: NEG
78275: PUSH
78276: LD_INT 2
78278: NEG
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 2
78286: NEG
78287: PUSH
78288: LD_INT 3
78290: NEG
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 1
78298: NEG
78299: PUSH
78300: LD_INT 3
78302: NEG
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 1
78310: PUSH
78311: LD_INT 2
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 2
78321: PUSH
78322: LD_INT 1
78324: NEG
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: LIST
78334: LIST
78335: LIST
78336: LIST
78337: LIST
78338: LIST
78339: LIST
78340: LIST
78341: LIST
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
78355: LD_ADDR_VAR 0 24
78359: PUSH
78360: LD_INT 0
78362: PUSH
78363: LD_INT 0
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: PUSH
78370: LD_INT 0
78372: PUSH
78373: LD_INT 1
78375: NEG
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 1
78383: PUSH
78384: LD_INT 0
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: PUSH
78391: LD_INT 1
78393: PUSH
78394: LD_INT 1
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: PUSH
78401: LD_INT 0
78403: PUSH
78404: LD_INT 1
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 1
78413: NEG
78414: PUSH
78415: LD_INT 0
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 1
78424: NEG
78425: PUSH
78426: LD_INT 1
78428: NEG
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: PUSH
78434: LD_INT 1
78436: NEG
78437: PUSH
78438: LD_INT 2
78440: NEG
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 0
78448: PUSH
78449: LD_INT 2
78451: NEG
78452: PUSH
78453: EMPTY
78454: LIST
78455: LIST
78456: PUSH
78457: LD_INT 1
78459: PUSH
78460: LD_INT 1
78462: NEG
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: LD_INT 2
78470: PUSH
78471: LD_INT 0
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 2
78480: PUSH
78481: LD_INT 1
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: PUSH
78488: LD_INT 2
78490: PUSH
78491: LD_INT 2
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 1
78500: PUSH
78501: LD_INT 2
78503: PUSH
78504: EMPTY
78505: LIST
78506: LIST
78507: PUSH
78508: LD_INT 0
78510: PUSH
78511: LD_INT 2
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_INT 1
78520: NEG
78521: PUSH
78522: LD_INT 1
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 2
78531: NEG
78532: PUSH
78533: LD_INT 0
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 2
78542: NEG
78543: PUSH
78544: LD_INT 1
78546: NEG
78547: PUSH
78548: EMPTY
78549: LIST
78550: LIST
78551: PUSH
78552: LD_INT 2
78554: NEG
78555: PUSH
78556: LD_INT 2
78558: NEG
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 1
78566: PUSH
78567: LD_INT 2
78569: NEG
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 2
78577: PUSH
78578: LD_INT 1
78580: NEG
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 3
78588: PUSH
78589: LD_INT 1
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 3
78598: PUSH
78599: LD_INT 2
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: LIST
78615: LIST
78616: LIST
78617: LIST
78618: LIST
78619: LIST
78620: LIST
78621: LIST
78622: LIST
78623: LIST
78624: LIST
78625: LIST
78626: LIST
78627: LIST
78628: LIST
78629: LIST
78630: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
78631: LD_ADDR_VAR 0 25
78635: PUSH
78636: LD_INT 0
78638: PUSH
78639: LD_INT 0
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 0
78648: PUSH
78649: LD_INT 1
78651: NEG
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 1
78659: PUSH
78660: LD_INT 0
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 1
78669: PUSH
78670: LD_INT 1
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PUSH
78677: LD_INT 0
78679: PUSH
78680: LD_INT 1
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 1
78689: NEG
78690: PUSH
78691: LD_INT 0
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 1
78700: NEG
78701: PUSH
78702: LD_INT 1
78704: NEG
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 1
78712: NEG
78713: PUSH
78714: LD_INT 2
78716: NEG
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 0
78724: PUSH
78725: LD_INT 2
78727: NEG
78728: PUSH
78729: EMPTY
78730: LIST
78731: LIST
78732: PUSH
78733: LD_INT 1
78735: PUSH
78736: LD_INT 1
78738: NEG
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: LD_INT 2
78746: PUSH
78747: LD_INT 0
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 2
78756: PUSH
78757: LD_INT 1
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 2
78766: PUSH
78767: LD_INT 2
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: PUSH
78774: LD_INT 1
78776: PUSH
78777: LD_INT 2
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 0
78786: PUSH
78787: LD_INT 2
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 1
78796: NEG
78797: PUSH
78798: LD_INT 1
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: LD_INT 2
78807: NEG
78808: PUSH
78809: LD_INT 0
78811: PUSH
78812: EMPTY
78813: LIST
78814: LIST
78815: PUSH
78816: LD_INT 2
78818: NEG
78819: PUSH
78820: LD_INT 1
78822: NEG
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 2
78830: NEG
78831: PUSH
78832: LD_INT 2
78834: NEG
78835: PUSH
78836: EMPTY
78837: LIST
78838: LIST
78839: PUSH
78840: LD_INT 3
78842: PUSH
78843: LD_INT 1
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 3
78852: PUSH
78853: LD_INT 2
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 2
78862: PUSH
78863: LD_INT 3
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 1
78872: PUSH
78873: LD_INT 3
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78905: LD_ADDR_VAR 0 26
78909: PUSH
78910: LD_INT 0
78912: PUSH
78913: LD_INT 0
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 0
78922: PUSH
78923: LD_INT 1
78925: NEG
78926: PUSH
78927: EMPTY
78928: LIST
78929: LIST
78930: PUSH
78931: LD_INT 1
78933: PUSH
78934: LD_INT 0
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 1
78943: PUSH
78944: LD_INT 1
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 0
78953: PUSH
78954: LD_INT 1
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 1
78963: NEG
78964: PUSH
78965: LD_INT 0
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 1
78974: NEG
78975: PUSH
78976: LD_INT 1
78978: NEG
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 1
78986: NEG
78987: PUSH
78988: LD_INT 2
78990: NEG
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 0
78998: PUSH
78999: LD_INT 2
79001: NEG
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 1
79009: PUSH
79010: LD_INT 1
79012: NEG
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: LD_INT 2
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 2
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 2
79040: PUSH
79041: LD_INT 2
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 1
79050: PUSH
79051: LD_INT 2
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 0
79060: PUSH
79061: LD_INT 2
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 1
79070: NEG
79071: PUSH
79072: LD_INT 1
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 2
79081: NEG
79082: PUSH
79083: LD_INT 0
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 2
79092: NEG
79093: PUSH
79094: LD_INT 1
79096: NEG
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_INT 2
79104: NEG
79105: PUSH
79106: LD_INT 2
79108: NEG
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 2
79116: PUSH
79117: LD_INT 3
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 1
79126: PUSH
79127: LD_INT 3
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 1
79136: NEG
79137: PUSH
79138: LD_INT 2
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: LD_INT 2
79147: NEG
79148: PUSH
79149: LD_INT 1
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: LIST
79165: LIST
79166: LIST
79167: LIST
79168: LIST
79169: LIST
79170: LIST
79171: LIST
79172: LIST
79173: LIST
79174: LIST
79175: LIST
79176: LIST
79177: LIST
79178: LIST
79179: LIST
79180: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79181: LD_ADDR_VAR 0 27
79185: PUSH
79186: LD_INT 0
79188: PUSH
79189: LD_INT 0
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: LD_INT 0
79198: PUSH
79199: LD_INT 1
79201: NEG
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 1
79209: PUSH
79210: LD_INT 0
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 1
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 0
79229: PUSH
79230: LD_INT 1
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 1
79239: NEG
79240: PUSH
79241: LD_INT 0
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 1
79250: NEG
79251: PUSH
79252: LD_INT 1
79254: NEG
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 1
79262: NEG
79263: PUSH
79264: LD_INT 2
79266: NEG
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 0
79274: PUSH
79275: LD_INT 2
79277: NEG
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 1
79285: PUSH
79286: LD_INT 1
79288: NEG
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 2
79296: PUSH
79297: LD_INT 0
79299: PUSH
79300: EMPTY
79301: LIST
79302: LIST
79303: PUSH
79304: LD_INT 2
79306: PUSH
79307: LD_INT 1
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 2
79316: PUSH
79317: LD_INT 2
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 1
79326: PUSH
79327: LD_INT 2
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 0
79336: PUSH
79337: LD_INT 2
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 1
79346: NEG
79347: PUSH
79348: LD_INT 1
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 2
79357: NEG
79358: PUSH
79359: LD_INT 0
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: PUSH
79366: LD_INT 2
79368: NEG
79369: PUSH
79370: LD_INT 1
79372: NEG
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: PUSH
79378: LD_INT 2
79380: NEG
79381: PUSH
79382: LD_INT 2
79384: NEG
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 1
79392: NEG
79393: PUSH
79394: LD_INT 2
79396: PUSH
79397: EMPTY
79398: LIST
79399: LIST
79400: PUSH
79401: LD_INT 2
79403: NEG
79404: PUSH
79405: LD_INT 1
79407: PUSH
79408: EMPTY
79409: LIST
79410: LIST
79411: PUSH
79412: LD_INT 3
79414: NEG
79415: PUSH
79416: LD_INT 1
79418: NEG
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 3
79426: NEG
79427: PUSH
79428: LD_INT 2
79430: NEG
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79461: LD_ADDR_VAR 0 28
79465: PUSH
79466: LD_INT 0
79468: PUSH
79469: LD_INT 0
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 0
79478: PUSH
79479: LD_INT 1
79481: NEG
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: PUSH
79487: LD_INT 1
79489: PUSH
79490: LD_INT 0
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 1
79499: PUSH
79500: LD_INT 1
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 0
79509: PUSH
79510: LD_INT 1
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 1
79519: NEG
79520: PUSH
79521: LD_INT 0
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 1
79530: NEG
79531: PUSH
79532: LD_INT 1
79534: NEG
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 1
79542: NEG
79543: PUSH
79544: LD_INT 2
79546: NEG
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 0
79554: PUSH
79555: LD_INT 2
79557: NEG
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 1
79565: PUSH
79566: LD_INT 1
79568: NEG
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 2
79576: PUSH
79577: LD_INT 0
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 2
79586: PUSH
79587: LD_INT 1
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 2
79596: PUSH
79597: LD_INT 2
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 1
79606: PUSH
79607: LD_INT 2
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 0
79616: PUSH
79617: LD_INT 2
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 1
79626: NEG
79627: PUSH
79628: LD_INT 1
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 2
79637: NEG
79638: PUSH
79639: LD_INT 0
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 2
79648: NEG
79649: PUSH
79650: LD_INT 1
79652: NEG
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 2
79660: NEG
79661: PUSH
79662: LD_INT 2
79664: NEG
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 2
79672: NEG
79673: PUSH
79674: LD_INT 3
79676: NEG
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: LD_INT 1
79684: NEG
79685: PUSH
79686: LD_INT 3
79688: NEG
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 3
79696: NEG
79697: PUSH
79698: LD_INT 1
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 3
79708: NEG
79709: PUSH
79710: LD_INT 2
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: LIST
79722: LIST
79723: LIST
79724: LIST
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: LIST
79730: LIST
79731: LIST
79732: LIST
79733: LIST
79734: LIST
79735: LIST
79736: LIST
79737: LIST
79738: LIST
79739: LIST
79740: LIST
79741: LIST
79742: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79743: LD_ADDR_VAR 0 29
79747: PUSH
79748: LD_INT 0
79750: PUSH
79751: LD_INT 0
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 0
79760: PUSH
79761: LD_INT 1
79763: NEG
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 1
79771: PUSH
79772: LD_INT 0
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 1
79781: PUSH
79782: LD_INT 1
79784: PUSH
79785: EMPTY
79786: LIST
79787: LIST
79788: PUSH
79789: LD_INT 0
79791: PUSH
79792: LD_INT 1
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 1
79801: NEG
79802: PUSH
79803: LD_INT 0
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 1
79812: NEG
79813: PUSH
79814: LD_INT 1
79816: NEG
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 1
79824: NEG
79825: PUSH
79826: LD_INT 2
79828: NEG
79829: PUSH
79830: EMPTY
79831: LIST
79832: LIST
79833: PUSH
79834: LD_INT 0
79836: PUSH
79837: LD_INT 2
79839: NEG
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 1
79847: PUSH
79848: LD_INT 1
79850: NEG
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 2
79858: PUSH
79859: LD_INT 0
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 2
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 1
79878: PUSH
79879: LD_INT 2
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 0
79888: PUSH
79889: LD_INT 2
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 1
79898: NEG
79899: PUSH
79900: LD_INT 1
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 2
79909: NEG
79910: PUSH
79911: LD_INT 1
79913: NEG
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 2
79921: NEG
79922: PUSH
79923: LD_INT 2
79925: NEG
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 2
79933: NEG
79934: PUSH
79935: LD_INT 3
79937: NEG
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 2
79945: PUSH
79946: LD_INT 1
79948: NEG
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: LD_INT 3
79956: PUSH
79957: LD_INT 1
79959: PUSH
79960: EMPTY
79961: LIST
79962: LIST
79963: PUSH
79964: LD_INT 1
79966: PUSH
79967: LD_INT 3
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 1
79976: NEG
79977: PUSH
79978: LD_INT 2
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 3
79987: NEG
79988: PUSH
79989: LD_INT 2
79991: NEG
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80022: LD_ADDR_VAR 0 30
80026: PUSH
80027: LD_INT 0
80029: PUSH
80030: LD_INT 0
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 0
80039: PUSH
80040: LD_INT 1
80042: NEG
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 1
80050: PUSH
80051: LD_INT 0
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 1
80060: PUSH
80061: LD_INT 1
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 0
80070: PUSH
80071: LD_INT 1
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 1
80080: NEG
80081: PUSH
80082: LD_INT 0
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PUSH
80089: LD_INT 1
80091: NEG
80092: PUSH
80093: LD_INT 1
80095: NEG
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 1
80103: NEG
80104: PUSH
80105: LD_INT 2
80107: NEG
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 0
80115: PUSH
80116: LD_INT 2
80118: NEG
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 1
80126: PUSH
80127: LD_INT 1
80129: NEG
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: PUSH
80135: LD_INT 2
80137: PUSH
80138: LD_INT 0
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: PUSH
80145: LD_INT 2
80147: PUSH
80148: LD_INT 1
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: LD_INT 2
80157: PUSH
80158: LD_INT 2
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 1
80167: PUSH
80168: LD_INT 2
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 1
80177: NEG
80178: PUSH
80179: LD_INT 1
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 2
80188: NEG
80189: PUSH
80190: LD_INT 0
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 2
80199: NEG
80200: PUSH
80201: LD_INT 1
80203: NEG
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 1
80211: NEG
80212: PUSH
80213: LD_INT 3
80215: NEG
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: PUSH
80224: LD_INT 2
80226: NEG
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 3
80234: PUSH
80235: LD_INT 2
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 2
80244: PUSH
80245: LD_INT 3
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 2
80254: NEG
80255: PUSH
80256: LD_INT 1
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 3
80265: NEG
80266: PUSH
80267: LD_INT 1
80269: NEG
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80300: LD_ADDR_VAR 0 31
80304: PUSH
80305: LD_INT 0
80307: PUSH
80308: LD_INT 0
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 0
80317: PUSH
80318: LD_INT 1
80320: NEG
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 1
80328: PUSH
80329: LD_INT 0
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 1
80338: PUSH
80339: LD_INT 1
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 0
80348: PUSH
80349: LD_INT 1
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 1
80358: NEG
80359: PUSH
80360: LD_INT 0
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 1
80369: NEG
80370: PUSH
80371: LD_INT 1
80373: NEG
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 1
80381: NEG
80382: PUSH
80383: LD_INT 2
80385: NEG
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 1
80393: PUSH
80394: LD_INT 1
80396: NEG
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 2
80404: PUSH
80405: LD_INT 0
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 2
80414: PUSH
80415: LD_INT 1
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 2
80424: PUSH
80425: LD_INT 2
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 1
80434: PUSH
80435: LD_INT 2
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: LD_INT 2
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 1
80454: NEG
80455: PUSH
80456: LD_INT 1
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 2
80465: NEG
80466: PUSH
80467: LD_INT 1
80469: NEG
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 2
80477: NEG
80478: PUSH
80479: LD_INT 2
80481: NEG
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 2
80489: NEG
80490: PUSH
80491: LD_INT 3
80493: NEG
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 2
80501: PUSH
80502: LD_INT 1
80504: NEG
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PUSH
80510: LD_INT 3
80512: PUSH
80513: LD_INT 1
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 1
80522: PUSH
80523: LD_INT 3
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 1
80532: NEG
80533: PUSH
80534: LD_INT 2
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 3
80543: NEG
80544: PUSH
80545: LD_INT 2
80547: NEG
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80578: LD_ADDR_VAR 0 32
80582: PUSH
80583: LD_INT 0
80585: PUSH
80586: LD_INT 0
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: LD_INT 0
80595: PUSH
80596: LD_INT 1
80598: NEG
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 1
80606: PUSH
80607: LD_INT 0
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 1
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 0
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 1
80636: NEG
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 1
80647: NEG
80648: PUSH
80649: LD_INT 1
80651: NEG
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 1
80659: NEG
80660: PUSH
80661: LD_INT 2
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 0
80671: PUSH
80672: LD_INT 2
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 1
80682: PUSH
80683: LD_INT 1
80685: NEG
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 2
80693: PUSH
80694: LD_INT 1
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 2
80703: PUSH
80704: LD_INT 2
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 1
80713: PUSH
80714: LD_INT 2
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 0
80723: PUSH
80724: LD_INT 2
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 1
80733: NEG
80734: PUSH
80735: LD_INT 1
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 2
80744: NEG
80745: PUSH
80746: LD_INT 0
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 2
80755: NEG
80756: PUSH
80757: LD_INT 1
80759: NEG
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: LD_INT 1
80767: NEG
80768: PUSH
80769: LD_INT 3
80771: NEG
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 1
80779: PUSH
80780: LD_INT 2
80782: NEG
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 3
80790: PUSH
80791: LD_INT 2
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 2
80800: PUSH
80801: LD_INT 3
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 2
80810: NEG
80811: PUSH
80812: LD_INT 1
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 3
80821: NEG
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: LIST
80835: LIST
80836: LIST
80837: LIST
80838: LIST
80839: LIST
80840: LIST
80841: LIST
80842: LIST
80843: LIST
80844: LIST
80845: LIST
80846: LIST
80847: LIST
80848: LIST
80849: LIST
80850: LIST
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80856: LD_ADDR_VAR 0 33
80860: PUSH
80861: LD_INT 0
80863: PUSH
80864: LD_INT 0
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 0
80873: PUSH
80874: LD_INT 1
80876: NEG
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 1
80884: PUSH
80885: LD_INT 0
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: PUSH
80895: LD_INT 1
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: PUSH
80902: LD_INT 0
80904: PUSH
80905: LD_INT 1
80907: PUSH
80908: EMPTY
80909: LIST
80910: LIST
80911: PUSH
80912: LD_INT 1
80914: NEG
80915: PUSH
80916: LD_INT 0
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: PUSH
80923: LD_INT 1
80925: NEG
80926: PUSH
80927: LD_INT 1
80929: NEG
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 1
80937: NEG
80938: PUSH
80939: LD_INT 2
80941: NEG
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: PUSH
80947: LD_INT 1
80949: PUSH
80950: LD_INT 1
80952: NEG
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 2
80960: PUSH
80961: LD_INT 0
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 2
80970: PUSH
80971: LD_INT 1
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 1
80980: PUSH
80981: LD_INT 2
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 0
80990: PUSH
80991: LD_INT 2
80993: PUSH
80994: EMPTY
80995: LIST
80996: LIST
80997: PUSH
80998: LD_INT 1
81000: NEG
81001: PUSH
81002: LD_INT 1
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: LD_INT 2
81011: NEG
81012: PUSH
81013: LD_INT 0
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 2
81022: NEG
81023: PUSH
81024: LD_INT 1
81026: NEG
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 2
81034: NEG
81035: PUSH
81036: LD_INT 2
81038: NEG
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: LD_INT 2
81046: NEG
81047: PUSH
81048: LD_INT 3
81050: NEG
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 2
81058: PUSH
81059: LD_INT 1
81061: NEG
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 3
81069: PUSH
81070: LD_INT 1
81072: PUSH
81073: EMPTY
81074: LIST
81075: LIST
81076: PUSH
81077: LD_INT 1
81079: PUSH
81080: LD_INT 3
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 1
81089: NEG
81090: PUSH
81091: LD_INT 2
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 3
81100: NEG
81101: PUSH
81102: LD_INT 2
81104: NEG
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81135: LD_ADDR_VAR 0 34
81139: PUSH
81140: LD_INT 0
81142: PUSH
81143: LD_INT 0
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: LD_INT 1
81155: NEG
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 1
81163: PUSH
81164: LD_INT 0
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 1
81173: PUSH
81174: LD_INT 1
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: PUSH
81181: LD_INT 0
81183: PUSH
81184: LD_INT 1
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 1
81193: NEG
81194: PUSH
81195: LD_INT 0
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 1
81204: NEG
81205: PUSH
81206: LD_INT 1
81208: NEG
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 1
81216: NEG
81217: PUSH
81218: LD_INT 2
81220: NEG
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 0
81228: PUSH
81229: LD_INT 2
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 1
81239: PUSH
81240: LD_INT 1
81242: NEG
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 2
81250: PUSH
81251: LD_INT 1
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 2
81260: PUSH
81261: LD_INT 2
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 1
81270: PUSH
81271: LD_INT 2
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 1
81280: NEG
81281: PUSH
81282: LD_INT 1
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 2
81291: NEG
81292: PUSH
81293: LD_INT 0
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 2
81302: NEG
81303: PUSH
81304: LD_INT 1
81306: NEG
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 2
81314: NEG
81315: PUSH
81316: LD_INT 2
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 1
81326: NEG
81327: PUSH
81328: LD_INT 3
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 1
81338: PUSH
81339: LD_INT 2
81341: NEG
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 3
81349: PUSH
81350: LD_INT 2
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 2
81359: PUSH
81360: LD_INT 3
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 2
81369: NEG
81370: PUSH
81371: LD_INT 1
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 3
81380: NEG
81381: PUSH
81382: LD_INT 1
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: LIST
81394: LIST
81395: LIST
81396: LIST
81397: LIST
81398: LIST
81399: LIST
81400: LIST
81401: LIST
81402: LIST
81403: LIST
81404: LIST
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
81415: LD_ADDR_VAR 0 35
81419: PUSH
81420: LD_INT 0
81422: PUSH
81423: LD_INT 0
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 0
81432: PUSH
81433: LD_INT 1
81435: NEG
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 1
81443: PUSH
81444: LD_INT 0
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 1
81453: PUSH
81454: LD_INT 1
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 0
81463: PUSH
81464: LD_INT 1
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 1
81473: NEG
81474: PUSH
81475: LD_INT 0
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: LD_INT 1
81484: NEG
81485: PUSH
81486: LD_INT 1
81488: NEG
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 2
81496: PUSH
81497: LD_INT 1
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 2
81506: NEG
81507: PUSH
81508: LD_INT 1
81510: NEG
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
81527: LD_ADDR_VAR 0 36
81531: PUSH
81532: LD_INT 0
81534: PUSH
81535: LD_INT 0
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 0
81544: PUSH
81545: LD_INT 1
81547: NEG
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 1
81555: PUSH
81556: LD_INT 0
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: PUSH
81563: LD_INT 1
81565: PUSH
81566: LD_INT 1
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 0
81575: PUSH
81576: LD_INT 1
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_INT 1
81585: NEG
81586: PUSH
81587: LD_INT 0
81589: PUSH
81590: EMPTY
81591: LIST
81592: LIST
81593: PUSH
81594: LD_INT 1
81596: NEG
81597: PUSH
81598: LD_INT 1
81600: NEG
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 1
81608: NEG
81609: PUSH
81610: LD_INT 2
81612: NEG
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 1
81620: PUSH
81621: LD_INT 2
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
81639: LD_ADDR_VAR 0 37
81643: PUSH
81644: LD_INT 0
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 0
81656: PUSH
81657: LD_INT 1
81659: NEG
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: PUSH
81665: LD_INT 1
81667: PUSH
81668: LD_INT 0
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 1
81677: PUSH
81678: LD_INT 1
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 0
81687: PUSH
81688: LD_INT 1
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 1
81697: NEG
81698: PUSH
81699: LD_INT 0
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 1
81708: NEG
81709: PUSH
81710: LD_INT 1
81712: NEG
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 1
81720: PUSH
81721: LD_INT 1
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 1
81731: NEG
81732: PUSH
81733: LD_INT 1
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
81751: LD_ADDR_VAR 0 38
81755: PUSH
81756: LD_INT 0
81758: PUSH
81759: LD_INT 0
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 0
81768: PUSH
81769: LD_INT 1
81771: NEG
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 1
81779: PUSH
81780: LD_INT 0
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 1
81789: PUSH
81790: LD_INT 1
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 0
81799: PUSH
81800: LD_INT 1
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 1
81809: NEG
81810: PUSH
81811: LD_INT 0
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 1
81820: NEG
81821: PUSH
81822: LD_INT 1
81824: NEG
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 2
81832: PUSH
81833: LD_INT 1
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 2
81842: NEG
81843: PUSH
81844: LD_INT 1
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
81863: LD_ADDR_VAR 0 39
81867: PUSH
81868: LD_INT 0
81870: PUSH
81871: LD_INT 0
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: LD_INT 0
81880: PUSH
81881: LD_INT 1
81883: NEG
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PUSH
81889: LD_INT 1
81891: PUSH
81892: LD_INT 0
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 1
81901: PUSH
81902: LD_INT 1
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 0
81911: PUSH
81912: LD_INT 1
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 1
81921: NEG
81922: PUSH
81923: LD_INT 0
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 1
81932: NEG
81933: PUSH
81934: LD_INT 1
81936: NEG
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 1
81944: NEG
81945: PUSH
81946: LD_INT 2
81948: NEG
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 1
81956: PUSH
81957: LD_INT 2
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
81975: LD_ADDR_VAR 0 40
81979: PUSH
81980: LD_INT 0
81982: PUSH
81983: LD_INT 0
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 0
81992: PUSH
81993: LD_INT 1
81995: NEG
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 1
82003: PUSH
82004: LD_INT 0
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 1
82013: PUSH
82014: LD_INT 1
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 0
82023: PUSH
82024: LD_INT 1
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 1
82033: NEG
82034: PUSH
82035: LD_INT 0
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 1
82044: NEG
82045: PUSH
82046: LD_INT 1
82048: NEG
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 1
82056: PUSH
82057: LD_INT 1
82059: NEG
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 1
82067: NEG
82068: PUSH
82069: LD_INT 1
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82087: LD_ADDR_VAR 0 41
82091: PUSH
82092: LD_INT 0
82094: PUSH
82095: LD_INT 0
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 0
82104: PUSH
82105: LD_INT 1
82107: NEG
82108: PUSH
82109: EMPTY
82110: LIST
82111: LIST
82112: PUSH
82113: LD_INT 1
82115: PUSH
82116: LD_INT 0
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 1
82125: PUSH
82126: LD_INT 1
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 0
82135: PUSH
82136: LD_INT 1
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 1
82145: NEG
82146: PUSH
82147: LD_INT 0
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 1
82156: NEG
82157: PUSH
82158: LD_INT 1
82160: NEG
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 1
82168: NEG
82169: PUSH
82170: LD_INT 2
82172: NEG
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 1
82180: PUSH
82181: LD_INT 1
82183: NEG
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 2
82191: PUSH
82192: LD_INT 0
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 2
82201: PUSH
82202: LD_INT 1
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 2
82211: PUSH
82212: LD_INT 2
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 1
82221: PUSH
82222: LD_INT 2
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 1
82231: NEG
82232: PUSH
82233: LD_INT 1
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 2
82242: NEG
82243: PUSH
82244: LD_INT 0
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PUSH
82251: LD_INT 2
82253: NEG
82254: PUSH
82255: LD_INT 1
82257: NEG
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 2
82265: NEG
82266: PUSH
82267: LD_INT 2
82269: NEG
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 2
82277: NEG
82278: PUSH
82279: LD_INT 3
82281: NEG
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PUSH
82287: LD_INT 2
82289: PUSH
82290: LD_INT 1
82292: NEG
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 3
82300: PUSH
82301: LD_INT 0
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 3
82310: PUSH
82311: LD_INT 1
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: LD_INT 3
82320: PUSH
82321: LD_INT 2
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 3
82330: PUSH
82331: LD_INT 3
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 2
82340: PUSH
82341: LD_INT 3
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 2
82350: NEG
82351: PUSH
82352: LD_INT 1
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 3
82361: NEG
82362: PUSH
82363: LD_INT 0
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 3
82372: NEG
82373: PUSH
82374: LD_INT 1
82376: NEG
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 3
82384: NEG
82385: PUSH
82386: LD_INT 2
82388: NEG
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 3
82396: NEG
82397: PUSH
82398: LD_INT 3
82400: NEG
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82437: LD_ADDR_VAR 0 42
82441: PUSH
82442: LD_INT 0
82444: PUSH
82445: LD_INT 0
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: PUSH
82452: LD_INT 0
82454: PUSH
82455: LD_INT 1
82457: NEG
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: LD_INT 1
82465: PUSH
82466: LD_INT 0
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 1
82475: PUSH
82476: LD_INT 1
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 0
82485: PUSH
82486: LD_INT 1
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 1
82495: NEG
82496: PUSH
82497: LD_INT 0
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 1
82506: NEG
82507: PUSH
82508: LD_INT 1
82510: NEG
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 1
82518: NEG
82519: PUSH
82520: LD_INT 2
82522: NEG
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 0
82530: PUSH
82531: LD_INT 2
82533: NEG
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 1
82541: PUSH
82542: LD_INT 1
82544: NEG
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PUSH
82550: LD_INT 2
82552: PUSH
82553: LD_INT 1
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 2
82562: PUSH
82563: LD_INT 2
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 1
82572: PUSH
82573: LD_INT 2
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 0
82582: PUSH
82583: LD_INT 2
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 1
82592: NEG
82593: PUSH
82594: LD_INT 1
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: PUSH
82601: LD_INT 2
82603: NEG
82604: PUSH
82605: LD_INT 1
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 2
82615: NEG
82616: PUSH
82617: LD_INT 2
82619: NEG
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 2
82627: NEG
82628: PUSH
82629: LD_INT 3
82631: NEG
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 1
82639: NEG
82640: PUSH
82641: LD_INT 3
82643: NEG
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 0
82651: PUSH
82652: LD_INT 3
82654: NEG
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 1
82662: PUSH
82663: LD_INT 2
82665: NEG
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 3
82673: PUSH
82674: LD_INT 2
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 3
82683: PUSH
82684: LD_INT 3
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: PUSH
82691: LD_INT 2
82693: PUSH
82694: LD_INT 3
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 1
82703: PUSH
82704: LD_INT 3
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: PUSH
82711: LD_INT 0
82713: PUSH
82714: LD_INT 3
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 1
82723: NEG
82724: PUSH
82725: LD_INT 2
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 3
82734: NEG
82735: PUSH
82736: LD_INT 2
82738: NEG
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 3
82746: NEG
82747: PUSH
82748: LD_INT 3
82750: NEG
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82787: LD_ADDR_VAR 0 43
82791: PUSH
82792: LD_INT 0
82794: PUSH
82795: LD_INT 0
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 0
82804: PUSH
82805: LD_INT 1
82807: NEG
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 1
82815: PUSH
82816: LD_INT 0
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 1
82825: PUSH
82826: LD_INT 1
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 0
82835: PUSH
82836: LD_INT 1
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 1
82845: NEG
82846: PUSH
82847: LD_INT 0
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 1
82856: NEG
82857: PUSH
82858: LD_INT 1
82860: NEG
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: PUSH
82866: LD_INT 1
82868: NEG
82869: PUSH
82870: LD_INT 2
82872: NEG
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 0
82880: PUSH
82881: LD_INT 2
82883: NEG
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 1
82891: PUSH
82892: LD_INT 1
82894: NEG
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 2
82902: PUSH
82903: LD_INT 0
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: PUSH
82910: LD_INT 2
82912: PUSH
82913: LD_INT 1
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 1
82922: PUSH
82923: LD_INT 2
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PUSH
82930: LD_INT 0
82932: PUSH
82933: LD_INT 2
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 1
82942: NEG
82943: PUSH
82944: LD_INT 1
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 2
82953: NEG
82954: PUSH
82955: LD_INT 0
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 2
82964: NEG
82965: PUSH
82966: LD_INT 1
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 1
82976: NEG
82977: PUSH
82978: LD_INT 3
82980: NEG
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 0
82988: PUSH
82989: LD_INT 3
82991: NEG
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 1
82999: PUSH
83000: LD_INT 2
83002: NEG
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PUSH
83008: LD_INT 2
83010: PUSH
83011: LD_INT 1
83013: NEG
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 3
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 3
83031: PUSH
83032: LD_INT 1
83034: PUSH
83035: EMPTY
83036: LIST
83037: LIST
83038: PUSH
83039: LD_INT 1
83041: PUSH
83042: LD_INT 3
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 0
83051: PUSH
83052: LD_INT 3
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: PUSH
83059: LD_INT 1
83061: NEG
83062: PUSH
83063: LD_INT 2
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 2
83072: NEG
83073: PUSH
83074: LD_INT 1
83076: PUSH
83077: EMPTY
83078: LIST
83079: LIST
83080: PUSH
83081: LD_INT 3
83083: NEG
83084: PUSH
83085: LD_INT 0
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 3
83094: NEG
83095: PUSH
83096: LD_INT 1
83098: NEG
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83135: LD_ADDR_VAR 0 44
83139: PUSH
83140: LD_INT 0
83142: PUSH
83143: LD_INT 0
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: PUSH
83150: LD_INT 0
83152: PUSH
83153: LD_INT 1
83155: NEG
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 1
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: LD_INT 1
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: LD_INT 0
83183: PUSH
83184: LD_INT 1
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 1
83193: NEG
83194: PUSH
83195: LD_INT 0
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: LD_INT 1
83204: NEG
83205: PUSH
83206: LD_INT 1
83208: NEG
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 1
83216: NEG
83217: PUSH
83218: LD_INT 2
83220: NEG
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 1
83228: PUSH
83229: LD_INT 1
83231: NEG
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 2
83239: PUSH
83240: LD_INT 0
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 2
83249: PUSH
83250: LD_INT 1
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 2
83259: PUSH
83260: LD_INT 2
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 1
83269: PUSH
83270: LD_INT 2
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 1
83279: NEG
83280: PUSH
83281: LD_INT 1
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 2
83290: NEG
83291: PUSH
83292: LD_INT 0
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 2
83301: NEG
83302: PUSH
83303: LD_INT 1
83305: NEG
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 2
83313: NEG
83314: PUSH
83315: LD_INT 2
83317: NEG
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 2
83325: NEG
83326: PUSH
83327: LD_INT 3
83329: NEG
83330: PUSH
83331: EMPTY
83332: LIST
83333: LIST
83334: PUSH
83335: LD_INT 2
83337: PUSH
83338: LD_INT 1
83340: NEG
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 3
83348: PUSH
83349: LD_INT 0
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 3
83358: PUSH
83359: LD_INT 1
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 3
83368: PUSH
83369: LD_INT 2
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: PUSH
83376: LD_INT 3
83378: PUSH
83379: LD_INT 3
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 2
83388: PUSH
83389: LD_INT 3
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 2
83398: NEG
83399: PUSH
83400: LD_INT 1
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 3
83409: NEG
83410: PUSH
83411: LD_INT 0
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: PUSH
83418: LD_INT 3
83420: NEG
83421: PUSH
83422: LD_INT 1
83424: NEG
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 3
83432: NEG
83433: PUSH
83434: LD_INT 2
83436: NEG
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PUSH
83442: LD_INT 3
83444: NEG
83445: PUSH
83446: LD_INT 3
83448: NEG
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: EMPTY
83455: LIST
83456: LIST
83457: LIST
83458: LIST
83459: LIST
83460: LIST
83461: LIST
83462: LIST
83463: LIST
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83485: LD_ADDR_VAR 0 45
83489: PUSH
83490: LD_INT 0
83492: PUSH
83493: LD_INT 0
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 0
83502: PUSH
83503: LD_INT 1
83505: NEG
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: LD_INT 1
83513: PUSH
83514: LD_INT 0
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 1
83523: PUSH
83524: LD_INT 1
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 0
83533: PUSH
83534: LD_INT 1
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 1
83543: NEG
83544: PUSH
83545: LD_INT 0
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 1
83554: NEG
83555: PUSH
83556: LD_INT 1
83558: NEG
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: LD_INT 1
83566: NEG
83567: PUSH
83568: LD_INT 2
83570: NEG
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: LD_INT 0
83578: PUSH
83579: LD_INT 2
83581: NEG
83582: PUSH
83583: EMPTY
83584: LIST
83585: LIST
83586: PUSH
83587: LD_INT 1
83589: PUSH
83590: LD_INT 1
83592: NEG
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_INT 2
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 2
83610: PUSH
83611: LD_INT 2
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 1
83620: PUSH
83621: LD_INT 2
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: LD_INT 2
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: NEG
83641: PUSH
83642: LD_INT 1
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 2
83651: NEG
83652: PUSH
83653: LD_INT 1
83655: NEG
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 2
83663: NEG
83664: PUSH
83665: LD_INT 2
83667: NEG
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: LD_INT 3
83679: NEG
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 1
83687: NEG
83688: PUSH
83689: LD_INT 3
83691: NEG
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 0
83699: PUSH
83700: LD_INT 3
83702: NEG
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 1
83710: PUSH
83711: LD_INT 2
83713: NEG
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 3
83721: PUSH
83722: LD_INT 2
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 3
83731: PUSH
83732: LD_INT 3
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: LD_INT 2
83741: PUSH
83742: LD_INT 3
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: LD_INT 3
83754: PUSH
83755: EMPTY
83756: LIST
83757: LIST
83758: PUSH
83759: LD_INT 0
83761: PUSH
83762: LD_INT 3
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: PUSH
83769: LD_INT 1
83771: NEG
83772: PUSH
83773: LD_INT 2
83775: PUSH
83776: EMPTY
83777: LIST
83778: LIST
83779: PUSH
83780: LD_INT 3
83782: NEG
83783: PUSH
83784: LD_INT 2
83786: NEG
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 3
83794: NEG
83795: PUSH
83796: LD_INT 3
83798: NEG
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: EMPTY
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83835: LD_ADDR_VAR 0 46
83839: PUSH
83840: LD_INT 0
83842: PUSH
83843: LD_INT 0
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: PUSH
83850: LD_INT 0
83852: PUSH
83853: LD_INT 1
83855: NEG
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: PUSH
83861: LD_INT 1
83863: PUSH
83864: LD_INT 0
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 1
83873: PUSH
83874: LD_INT 1
83876: PUSH
83877: EMPTY
83878: LIST
83879: LIST
83880: PUSH
83881: LD_INT 0
83883: PUSH
83884: LD_INT 1
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 1
83893: NEG
83894: PUSH
83895: LD_INT 0
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PUSH
83902: LD_INT 1
83904: NEG
83905: PUSH
83906: LD_INT 1
83908: NEG
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: PUSH
83914: LD_INT 1
83916: NEG
83917: PUSH
83918: LD_INT 2
83920: NEG
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: PUSH
83926: LD_INT 0
83928: PUSH
83929: LD_INT 2
83931: NEG
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: PUSH
83937: LD_INT 1
83939: PUSH
83940: LD_INT 1
83942: NEG
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: PUSH
83948: LD_INT 2
83950: PUSH
83951: LD_INT 0
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 2
83960: PUSH
83961: LD_INT 1
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: PUSH
83968: LD_INT 1
83970: PUSH
83971: LD_INT 2
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: PUSH
83978: LD_INT 0
83980: PUSH
83981: LD_INT 2
83983: PUSH
83984: EMPTY
83985: LIST
83986: LIST
83987: PUSH
83988: LD_INT 1
83990: NEG
83991: PUSH
83992: LD_INT 1
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 2
84001: NEG
84002: PUSH
84003: LD_INT 0
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 2
84012: NEG
84013: PUSH
84014: LD_INT 1
84016: NEG
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 1
84024: NEG
84025: PUSH
84026: LD_INT 3
84028: NEG
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 0
84036: PUSH
84037: LD_INT 3
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: LD_INT 2
84050: NEG
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PUSH
84056: LD_INT 2
84058: PUSH
84059: LD_INT 1
84061: NEG
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 3
84069: PUSH
84070: LD_INT 0
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 3
84079: PUSH
84080: LD_INT 1
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 1
84089: PUSH
84090: LD_INT 3
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 0
84099: PUSH
84100: LD_INT 3
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 1
84109: NEG
84110: PUSH
84111: LD_INT 2
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 2
84120: NEG
84121: PUSH
84122: LD_INT 1
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 3
84131: NEG
84132: PUSH
84133: LD_INT 0
84135: PUSH
84136: EMPTY
84137: LIST
84138: LIST
84139: PUSH
84140: LD_INT 3
84142: NEG
84143: PUSH
84144: LD_INT 1
84146: NEG
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: LIST
84178: LIST
84179: LIST
84180: LIST
84181: LIST
84182: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84183: LD_ADDR_VAR 0 47
84187: PUSH
84188: LD_INT 0
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 0
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 1
84211: PUSH
84212: LD_INT 0
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 1
84221: PUSH
84222: LD_INT 1
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: LD_INT 1
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 1
84241: NEG
84242: PUSH
84243: LD_INT 0
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: NEG
84253: PUSH
84254: LD_INT 1
84256: NEG
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 1
84264: NEG
84265: PUSH
84266: LD_INT 2
84268: NEG
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: PUSH
84274: LD_INT 0
84276: PUSH
84277: LD_INT 2
84279: NEG
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 1
84287: PUSH
84288: LD_INT 1
84290: NEG
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: PUSH
84296: LD_INT 2
84298: NEG
84299: PUSH
84300: LD_INT 1
84302: NEG
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 2
84310: NEG
84311: PUSH
84312: LD_INT 2
84314: NEG
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
84334: LD_ADDR_VAR 0 48
84338: PUSH
84339: LD_INT 0
84341: PUSH
84342: LD_INT 0
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 0
84351: PUSH
84352: LD_INT 1
84354: NEG
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 1
84362: PUSH
84363: LD_INT 0
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 1
84372: PUSH
84373: LD_INT 1
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 0
84382: PUSH
84383: LD_INT 1
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 1
84392: NEG
84393: PUSH
84394: LD_INT 0
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: LD_INT 1
84407: NEG
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 1
84415: NEG
84416: PUSH
84417: LD_INT 2
84419: NEG
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 0
84427: PUSH
84428: LD_INT 2
84430: NEG
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 1
84438: PUSH
84439: LD_INT 1
84441: NEG
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 2
84449: PUSH
84450: LD_INT 0
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 2
84459: PUSH
84460: LD_INT 1
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: PUSH
84467: EMPTY
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
84481: LD_ADDR_VAR 0 49
84485: PUSH
84486: LD_INT 0
84488: PUSH
84489: LD_INT 0
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PUSH
84496: LD_INT 0
84498: PUSH
84499: LD_INT 1
84501: NEG
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: PUSH
84507: LD_INT 1
84509: PUSH
84510: LD_INT 0
84512: PUSH
84513: EMPTY
84514: LIST
84515: LIST
84516: PUSH
84517: LD_INT 1
84519: PUSH
84520: LD_INT 1
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 0
84529: PUSH
84530: LD_INT 1
84532: PUSH
84533: EMPTY
84534: LIST
84535: LIST
84536: PUSH
84537: LD_INT 1
84539: NEG
84540: PUSH
84541: LD_INT 0
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PUSH
84548: LD_INT 1
84550: NEG
84551: PUSH
84552: LD_INT 1
84554: NEG
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 1
84562: PUSH
84563: LD_INT 1
84565: NEG
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 2
84573: PUSH
84574: LD_INT 0
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 2
84583: PUSH
84584: LD_INT 1
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PUSH
84591: LD_INT 2
84593: PUSH
84594: LD_INT 2
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 1
84603: PUSH
84604: LD_INT 2
84606: PUSH
84607: EMPTY
84608: LIST
84609: LIST
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
84625: LD_ADDR_VAR 0 50
84629: PUSH
84630: LD_INT 0
84632: PUSH
84633: LD_INT 0
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 0
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: LD_INT 0
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 1
84663: PUSH
84664: LD_INT 1
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 1
84683: NEG
84684: PUSH
84685: LD_INT 0
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 1
84694: NEG
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: LD_INT 2
84706: PUSH
84707: LD_INT 1
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 2
84716: PUSH
84717: LD_INT 2
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 1
84726: PUSH
84727: LD_INT 2
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: PUSH
84734: LD_INT 0
84736: PUSH
84737: LD_INT 2
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 1
84746: NEG
84747: PUSH
84748: LD_INT 1
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: EMPTY
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
84769: LD_ADDR_VAR 0 51
84773: PUSH
84774: LD_INT 0
84776: PUSH
84777: LD_INT 0
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 0
84786: PUSH
84787: LD_INT 1
84789: NEG
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 1
84797: PUSH
84798: LD_INT 0
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 1
84807: PUSH
84808: LD_INT 1
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 0
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 1
84827: NEG
84828: PUSH
84829: LD_INT 0
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 1
84838: NEG
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 1
84850: PUSH
84851: LD_INT 2
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 0
84860: PUSH
84861: LD_INT 2
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PUSH
84868: LD_INT 1
84870: NEG
84871: PUSH
84872: LD_INT 1
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 2
84881: NEG
84882: PUSH
84883: LD_INT 0
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: PUSH
84890: LD_INT 2
84892: NEG
84893: PUSH
84894: LD_INT 1
84896: NEG
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: LIST
84906: LIST
84907: LIST
84908: LIST
84909: LIST
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84916: LD_ADDR_VAR 0 52
84920: PUSH
84921: LD_INT 0
84923: PUSH
84924: LD_INT 0
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: PUSH
84931: LD_INT 0
84933: PUSH
84934: LD_INT 1
84936: NEG
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: PUSH
84942: LD_INT 1
84944: PUSH
84945: LD_INT 0
84947: PUSH
84948: EMPTY
84949: LIST
84950: LIST
84951: PUSH
84952: LD_INT 1
84954: PUSH
84955: LD_INT 1
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 0
84964: PUSH
84965: LD_INT 1
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 1
84974: NEG
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 1
84985: NEG
84986: PUSH
84987: LD_INT 1
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 1
84997: NEG
84998: PUSH
84999: LD_INT 2
85001: NEG
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 1
85009: NEG
85010: PUSH
85011: LD_INT 1
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 2
85020: NEG
85021: PUSH
85022: LD_INT 0
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 2
85031: NEG
85032: PUSH
85033: LD_INT 1
85035: NEG
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 2
85043: NEG
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85067: LD_ADDR_VAR 0 53
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 0
85084: PUSH
85085: LD_INT 1
85087: NEG
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 1
85095: PUSH
85096: LD_INT 0
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 1
85105: PUSH
85106: LD_INT 1
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_INT 0
85115: PUSH
85116: LD_INT 1
85118: PUSH
85119: EMPTY
85120: LIST
85121: LIST
85122: PUSH
85123: LD_INT 1
85125: NEG
85126: PUSH
85127: LD_INT 0
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: PUSH
85134: LD_INT 1
85136: NEG
85137: PUSH
85138: LD_INT 1
85140: NEG
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: PUSH
85146: LD_INT 1
85148: NEG
85149: PUSH
85150: LD_INT 2
85152: NEG
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: LD_INT 0
85160: PUSH
85161: LD_INT 2
85163: NEG
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 1
85171: PUSH
85172: LD_INT 1
85174: NEG
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 2
85182: PUSH
85183: LD_INT 0
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 2
85192: PUSH
85193: LD_INT 1
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 2
85202: PUSH
85203: LD_INT 2
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 1
85212: PUSH
85213: LD_INT 2
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: PUSH
85220: LD_INT 0
85222: PUSH
85223: LD_INT 2
85225: PUSH
85226: EMPTY
85227: LIST
85228: LIST
85229: PUSH
85230: LD_INT 1
85232: NEG
85233: PUSH
85234: LD_INT 1
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PUSH
85241: LD_INT 2
85243: NEG
85244: PUSH
85245: LD_INT 0
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 2
85254: NEG
85255: PUSH
85256: LD_INT 1
85258: NEG
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 2
85266: NEG
85267: PUSH
85268: LD_INT 2
85270: NEG
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: EMPTY
85277: LIST
85278: LIST
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85297: LD_ADDR_VAR 0 54
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: LD_INT 0
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 1
85325: PUSH
85326: LD_INT 0
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: LD_INT 1
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 0
85345: PUSH
85346: LD_INT 1
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 1
85355: NEG
85356: PUSH
85357: LD_INT 0
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 1
85366: NEG
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 1
85378: NEG
85379: PUSH
85380: LD_INT 2
85382: NEG
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 0
85390: PUSH
85391: LD_INT 2
85393: NEG
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: PUSH
85399: LD_INT 1
85401: PUSH
85402: LD_INT 1
85404: NEG
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 2
85412: PUSH
85413: LD_INT 0
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 2
85422: PUSH
85423: LD_INT 1
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 2
85432: PUSH
85433: LD_INT 2
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 1
85442: PUSH
85443: LD_INT 2
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 0
85452: PUSH
85453: LD_INT 2
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 1
85462: NEG
85463: PUSH
85464: LD_INT 1
85466: PUSH
85467: EMPTY
85468: LIST
85469: LIST
85470: PUSH
85471: LD_INT 2
85473: NEG
85474: PUSH
85475: LD_INT 0
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 2
85484: NEG
85485: PUSH
85486: LD_INT 1
85488: NEG
85489: PUSH
85490: EMPTY
85491: LIST
85492: LIST
85493: PUSH
85494: LD_INT 2
85496: NEG
85497: PUSH
85498: LD_INT 2
85500: NEG
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85527: LD_ADDR_VAR 0 55
85531: PUSH
85532: LD_INT 0
85534: PUSH
85535: LD_INT 0
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 0
85544: PUSH
85545: LD_INT 1
85547: NEG
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: PUSH
85553: LD_INT 1
85555: PUSH
85556: LD_INT 0
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: PUSH
85566: LD_INT 1
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 0
85575: PUSH
85576: LD_INT 1
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 1
85585: NEG
85586: PUSH
85587: LD_INT 0
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PUSH
85594: LD_INT 1
85596: NEG
85597: PUSH
85598: LD_INT 1
85600: NEG
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 1
85608: NEG
85609: PUSH
85610: LD_INT 2
85612: NEG
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 0
85620: PUSH
85621: LD_INT 2
85623: NEG
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 1
85634: NEG
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 2
85642: PUSH
85643: LD_INT 0
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 2
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 2
85662: PUSH
85663: LD_INT 2
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 1
85672: PUSH
85673: LD_INT 2
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: PUSH
85680: LD_INT 0
85682: PUSH
85683: LD_INT 2
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 1
85692: NEG
85693: PUSH
85694: LD_INT 1
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PUSH
85701: LD_INT 2
85703: NEG
85704: PUSH
85705: LD_INT 0
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 2
85714: NEG
85715: PUSH
85716: LD_INT 1
85718: NEG
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PUSH
85724: LD_INT 2
85726: NEG
85727: PUSH
85728: LD_INT 2
85730: NEG
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: EMPTY
85737: LIST
85738: LIST
85739: LIST
85740: LIST
85741: LIST
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85757: LD_ADDR_VAR 0 56
85761: PUSH
85762: LD_INT 0
85764: PUSH
85765: LD_INT 0
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 0
85774: PUSH
85775: LD_INT 1
85777: NEG
85778: PUSH
85779: EMPTY
85780: LIST
85781: LIST
85782: PUSH
85783: LD_INT 1
85785: PUSH
85786: LD_INT 0
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: PUSH
85793: LD_INT 1
85795: PUSH
85796: LD_INT 1
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 0
85805: PUSH
85806: LD_INT 1
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: LD_INT 1
85815: NEG
85816: PUSH
85817: LD_INT 0
85819: PUSH
85820: EMPTY
85821: LIST
85822: LIST
85823: PUSH
85824: LD_INT 1
85826: NEG
85827: PUSH
85828: LD_INT 1
85830: NEG
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 1
85838: NEG
85839: PUSH
85840: LD_INT 2
85842: NEG
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PUSH
85848: LD_INT 0
85850: PUSH
85851: LD_INT 2
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 1
85861: PUSH
85862: LD_INT 1
85864: NEG
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 2
85872: PUSH
85873: LD_INT 0
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: LD_INT 2
85882: PUSH
85883: LD_INT 1
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: LD_INT 2
85892: PUSH
85893: LD_INT 2
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 1
85902: PUSH
85903: LD_INT 2
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 0
85912: PUSH
85913: LD_INT 2
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 1
85922: NEG
85923: PUSH
85924: LD_INT 1
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 2
85933: NEG
85934: PUSH
85935: LD_INT 0
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 2
85944: NEG
85945: PUSH
85946: LD_INT 1
85948: NEG
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 2
85956: NEG
85957: PUSH
85958: LD_INT 2
85960: NEG
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85987: LD_ADDR_VAR 0 57
85991: PUSH
85992: LD_INT 0
85994: PUSH
85995: LD_INT 0
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PUSH
86002: LD_INT 0
86004: PUSH
86005: LD_INT 1
86007: NEG
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 1
86015: PUSH
86016: LD_INT 0
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 1
86025: PUSH
86026: LD_INT 1
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 0
86035: PUSH
86036: LD_INT 1
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 1
86045: NEG
86046: PUSH
86047: LD_INT 0
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: PUSH
86054: LD_INT 1
86056: NEG
86057: PUSH
86058: LD_INT 1
86060: NEG
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 1
86068: NEG
86069: PUSH
86070: LD_INT 2
86072: NEG
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: LD_INT 0
86080: PUSH
86081: LD_INT 2
86083: NEG
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 1
86091: PUSH
86092: LD_INT 1
86094: NEG
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 2
86102: PUSH
86103: LD_INT 0
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 2
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 2
86122: PUSH
86123: LD_INT 2
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: PUSH
86133: LD_INT 2
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 0
86142: PUSH
86143: LD_INT 2
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 1
86152: NEG
86153: PUSH
86154: LD_INT 1
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: PUSH
86161: LD_INT 2
86163: NEG
86164: PUSH
86165: LD_INT 0
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 2
86174: NEG
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 2
86186: NEG
86187: PUSH
86188: LD_INT 2
86190: NEG
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86217: LD_ADDR_VAR 0 58
86221: PUSH
86222: LD_INT 0
86224: PUSH
86225: LD_INT 0
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: LD_INT 1
86237: NEG
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 1
86245: PUSH
86246: LD_INT 0
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: LD_INT 1
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: LD_INT 0
86265: PUSH
86266: LD_INT 1
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 1
86275: NEG
86276: PUSH
86277: LD_INT 0
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: PUSH
86284: LD_INT 1
86286: NEG
86287: PUSH
86288: LD_INT 1
86290: NEG
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 1
86298: NEG
86299: PUSH
86300: LD_INT 2
86302: NEG
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 0
86310: PUSH
86311: LD_INT 2
86313: NEG
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 1
86321: PUSH
86322: LD_INT 1
86324: NEG
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PUSH
86330: LD_INT 2
86332: PUSH
86333: LD_INT 0
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: PUSH
86340: LD_INT 2
86342: PUSH
86343: LD_INT 1
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 2
86352: PUSH
86353: LD_INT 2
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 1
86362: PUSH
86363: LD_INT 2
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 0
86372: PUSH
86373: LD_INT 2
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PUSH
86380: LD_INT 1
86382: NEG
86383: PUSH
86384: LD_INT 1
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 2
86393: NEG
86394: PUSH
86395: LD_INT 0
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: LD_INT 2
86404: NEG
86405: PUSH
86406: LD_INT 1
86408: NEG
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: PUSH
86414: LD_INT 2
86416: NEG
86417: PUSH
86418: LD_INT 2
86420: NEG
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86447: LD_ADDR_VAR 0 59
86451: PUSH
86452: LD_INT 0
86454: PUSH
86455: LD_INT 0
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: LD_INT 0
86464: PUSH
86465: LD_INT 1
86467: NEG
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: PUSH
86473: LD_INT 1
86475: PUSH
86476: LD_INT 0
86478: PUSH
86479: EMPTY
86480: LIST
86481: LIST
86482: PUSH
86483: LD_INT 1
86485: PUSH
86486: LD_INT 1
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: PUSH
86493: LD_INT 0
86495: PUSH
86496: LD_INT 1
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 1
86505: NEG
86506: PUSH
86507: LD_INT 0
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PUSH
86514: LD_INT 1
86516: NEG
86517: PUSH
86518: LD_INT 1
86520: NEG
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86535: LD_ADDR_VAR 0 60
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: LD_INT 0
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 0
86552: PUSH
86553: LD_INT 1
86555: NEG
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 1
86563: PUSH
86564: LD_INT 0
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 1
86573: PUSH
86574: LD_INT 1
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 0
86583: PUSH
86584: LD_INT 1
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 1
86593: NEG
86594: PUSH
86595: LD_INT 0
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: PUSH
86602: LD_INT 1
86604: NEG
86605: PUSH
86606: LD_INT 1
86608: NEG
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: LIST
86618: LIST
86619: LIST
86620: LIST
86621: LIST
86622: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86623: LD_ADDR_VAR 0 61
86627: PUSH
86628: LD_INT 0
86630: PUSH
86631: LD_INT 0
86633: PUSH
86634: EMPTY
86635: LIST
86636: LIST
86637: PUSH
86638: LD_INT 0
86640: PUSH
86641: LD_INT 1
86643: NEG
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 1
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 1
86661: PUSH
86662: LD_INT 1
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PUSH
86669: LD_INT 0
86671: PUSH
86672: LD_INT 1
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PUSH
86679: LD_INT 1
86681: NEG
86682: PUSH
86683: LD_INT 0
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 1
86692: NEG
86693: PUSH
86694: LD_INT 1
86696: NEG
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86711: LD_ADDR_VAR 0 62
86715: PUSH
86716: LD_INT 0
86718: PUSH
86719: LD_INT 0
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: LD_INT 1
86731: NEG
86732: PUSH
86733: EMPTY
86734: LIST
86735: LIST
86736: PUSH
86737: LD_INT 1
86739: PUSH
86740: LD_INT 0
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: LD_INT 1
86749: PUSH
86750: LD_INT 1
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: LD_INT 0
86759: PUSH
86760: LD_INT 1
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 1
86769: NEG
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 1
86780: NEG
86781: PUSH
86782: LD_INT 1
86784: NEG
86785: PUSH
86786: EMPTY
86787: LIST
86788: LIST
86789: PUSH
86790: EMPTY
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86799: LD_ADDR_VAR 0 63
86803: PUSH
86804: LD_INT 0
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 0
86816: PUSH
86817: LD_INT 1
86819: NEG
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 1
86827: PUSH
86828: LD_INT 0
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 1
86837: PUSH
86838: LD_INT 1
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 0
86847: PUSH
86848: LD_INT 1
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_INT 1
86857: NEG
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 1
86868: NEG
86869: PUSH
86870: LD_INT 1
86872: NEG
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86887: LD_ADDR_VAR 0 64
86891: PUSH
86892: LD_INT 0
86894: PUSH
86895: LD_INT 0
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 0
86904: PUSH
86905: LD_INT 1
86907: NEG
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: LD_INT 1
86915: PUSH
86916: LD_INT 0
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: PUSH
86923: LD_INT 1
86925: PUSH
86926: LD_INT 1
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 0
86935: PUSH
86936: LD_INT 1
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: LD_INT 1
86945: NEG
86946: PUSH
86947: LD_INT 0
86949: PUSH
86950: EMPTY
86951: LIST
86952: LIST
86953: PUSH
86954: LD_INT 1
86956: NEG
86957: PUSH
86958: LD_INT 1
86960: NEG
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: ST_TO_ADDR
// end ; 1 :
86975: GO 92872
86977: LD_INT 1
86979: DOUBLE
86980: EQUAL
86981: IFTRUE 86985
86983: GO 89608
86985: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86986: LD_ADDR_VAR 0 11
86990: PUSH
86991: LD_INT 1
86993: NEG
86994: PUSH
86995: LD_INT 3
86997: NEG
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: PUSH
87003: LD_INT 0
87005: PUSH
87006: LD_INT 3
87008: NEG
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: LD_INT 1
87016: PUSH
87017: LD_INT 2
87019: NEG
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: LIST
87029: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
87030: LD_ADDR_VAR 0 12
87034: PUSH
87035: LD_INT 2
87037: PUSH
87038: LD_INT 1
87040: NEG
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 3
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 3
87058: PUSH
87059: LD_INT 1
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: LIST
87070: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
87071: LD_ADDR_VAR 0 13
87075: PUSH
87076: LD_INT 3
87078: PUSH
87079: LD_INT 2
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: PUSH
87086: LD_INT 3
87088: PUSH
87089: LD_INT 3
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 2
87098: PUSH
87099: LD_INT 3
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: LIST
87110: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
87111: LD_ADDR_VAR 0 14
87115: PUSH
87116: LD_INT 1
87118: PUSH
87119: LD_INT 3
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 0
87128: PUSH
87129: LD_INT 3
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 1
87138: NEG
87139: PUSH
87140: LD_INT 2
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: LIST
87151: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87152: LD_ADDR_VAR 0 15
87156: PUSH
87157: LD_INT 2
87159: NEG
87160: PUSH
87161: LD_INT 1
87163: PUSH
87164: EMPTY
87165: LIST
87166: LIST
87167: PUSH
87168: LD_INT 3
87170: NEG
87171: PUSH
87172: LD_INT 0
87174: PUSH
87175: EMPTY
87176: LIST
87177: LIST
87178: PUSH
87179: LD_INT 3
87181: NEG
87182: PUSH
87183: LD_INT 1
87185: NEG
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: LIST
87195: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87196: LD_ADDR_VAR 0 16
87200: PUSH
87201: LD_INT 2
87203: NEG
87204: PUSH
87205: LD_INT 3
87207: NEG
87208: PUSH
87209: EMPTY
87210: LIST
87211: LIST
87212: PUSH
87213: LD_INT 3
87215: NEG
87216: PUSH
87217: LD_INT 2
87219: NEG
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PUSH
87225: LD_INT 3
87227: NEG
87228: PUSH
87229: LD_INT 3
87231: NEG
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: LIST
87241: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
87242: LD_ADDR_VAR 0 17
87246: PUSH
87247: LD_INT 1
87249: NEG
87250: PUSH
87251: LD_INT 3
87253: NEG
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: LD_INT 0
87261: PUSH
87262: LD_INT 3
87264: NEG
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PUSH
87270: LD_INT 1
87272: PUSH
87273: LD_INT 2
87275: NEG
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: LIST
87285: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
87286: LD_ADDR_VAR 0 18
87290: PUSH
87291: LD_INT 2
87293: PUSH
87294: LD_INT 1
87296: NEG
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 3
87304: PUSH
87305: LD_INT 0
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: PUSH
87312: LD_INT 3
87314: PUSH
87315: LD_INT 1
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: LIST
87326: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
87327: LD_ADDR_VAR 0 19
87331: PUSH
87332: LD_INT 3
87334: PUSH
87335: LD_INT 2
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 3
87344: PUSH
87345: LD_INT 3
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 2
87354: PUSH
87355: LD_INT 3
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: LIST
87366: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
87367: LD_ADDR_VAR 0 20
87371: PUSH
87372: LD_INT 1
87374: PUSH
87375: LD_INT 3
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 0
87384: PUSH
87385: LD_INT 3
87387: PUSH
87388: EMPTY
87389: LIST
87390: LIST
87391: PUSH
87392: LD_INT 1
87394: NEG
87395: PUSH
87396: LD_INT 2
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: EMPTY
87404: LIST
87405: LIST
87406: LIST
87407: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87408: LD_ADDR_VAR 0 21
87412: PUSH
87413: LD_INT 2
87415: NEG
87416: PUSH
87417: LD_INT 1
87419: PUSH
87420: EMPTY
87421: LIST
87422: LIST
87423: PUSH
87424: LD_INT 3
87426: NEG
87427: PUSH
87428: LD_INT 0
87430: PUSH
87431: EMPTY
87432: LIST
87433: LIST
87434: PUSH
87435: LD_INT 3
87437: NEG
87438: PUSH
87439: LD_INT 1
87441: NEG
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: LIST
87451: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87452: LD_ADDR_VAR 0 22
87456: PUSH
87457: LD_INT 2
87459: NEG
87460: PUSH
87461: LD_INT 3
87463: NEG
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: LD_INT 3
87471: NEG
87472: PUSH
87473: LD_INT 2
87475: NEG
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 3
87483: NEG
87484: PUSH
87485: LD_INT 3
87487: NEG
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: LIST
87497: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
87498: LD_ADDR_VAR 0 23
87502: PUSH
87503: LD_INT 0
87505: PUSH
87506: LD_INT 3
87508: NEG
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: LD_INT 1
87516: NEG
87517: PUSH
87518: LD_INT 4
87520: NEG
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 1
87528: PUSH
87529: LD_INT 3
87531: NEG
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: EMPTY
87538: LIST
87539: LIST
87540: LIST
87541: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
87542: LD_ADDR_VAR 0 24
87546: PUSH
87547: LD_INT 3
87549: PUSH
87550: LD_INT 0
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 3
87559: PUSH
87560: LD_INT 1
87562: NEG
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 4
87570: PUSH
87571: LD_INT 1
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: LIST
87582: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
87583: LD_ADDR_VAR 0 25
87587: PUSH
87588: LD_INT 3
87590: PUSH
87591: LD_INT 3
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: PUSH
87598: LD_INT 4
87600: PUSH
87601: LD_INT 3
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: PUSH
87608: LD_INT 3
87610: PUSH
87611: LD_INT 4
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: LIST
87622: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
87623: LD_ADDR_VAR 0 26
87627: PUSH
87628: LD_INT 0
87630: PUSH
87631: LD_INT 3
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: PUSH
87638: LD_INT 1
87640: PUSH
87641: LD_INT 4
87643: PUSH
87644: EMPTY
87645: LIST
87646: LIST
87647: PUSH
87648: LD_INT 1
87650: NEG
87651: PUSH
87652: LD_INT 3
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: LIST
87663: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
87664: LD_ADDR_VAR 0 27
87668: PUSH
87669: LD_INT 3
87671: NEG
87672: PUSH
87673: LD_INT 0
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 3
87682: NEG
87683: PUSH
87684: LD_INT 1
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 4
87693: NEG
87694: PUSH
87695: LD_INT 1
87697: NEG
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: LIST
87707: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
87708: LD_ADDR_VAR 0 28
87712: PUSH
87713: LD_INT 3
87715: NEG
87716: PUSH
87717: LD_INT 3
87719: NEG
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PUSH
87725: LD_INT 3
87727: NEG
87728: PUSH
87729: LD_INT 4
87731: NEG
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: PUSH
87737: LD_INT 4
87739: NEG
87740: PUSH
87741: LD_INT 3
87743: NEG
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: EMPTY
87750: LIST
87751: LIST
87752: LIST
87753: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
87754: LD_ADDR_VAR 0 29
87758: PUSH
87759: LD_INT 1
87761: NEG
87762: PUSH
87763: LD_INT 3
87765: NEG
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 0
87773: PUSH
87774: LD_INT 3
87776: NEG
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 1
87784: PUSH
87785: LD_INT 2
87787: NEG
87788: PUSH
87789: EMPTY
87790: LIST
87791: LIST
87792: PUSH
87793: LD_INT 1
87795: NEG
87796: PUSH
87797: LD_INT 4
87799: NEG
87800: PUSH
87801: EMPTY
87802: LIST
87803: LIST
87804: PUSH
87805: LD_INT 0
87807: PUSH
87808: LD_INT 4
87810: NEG
87811: PUSH
87812: EMPTY
87813: LIST
87814: LIST
87815: PUSH
87816: LD_INT 1
87818: PUSH
87819: LD_INT 3
87821: NEG
87822: PUSH
87823: EMPTY
87824: LIST
87825: LIST
87826: PUSH
87827: LD_INT 1
87829: NEG
87830: PUSH
87831: LD_INT 5
87833: NEG
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 0
87841: PUSH
87842: LD_INT 5
87844: NEG
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: PUSH
87850: LD_INT 1
87852: PUSH
87853: LD_INT 4
87855: NEG
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 1
87863: NEG
87864: PUSH
87865: LD_INT 6
87867: NEG
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: LD_INT 0
87875: PUSH
87876: LD_INT 6
87878: NEG
87879: PUSH
87880: EMPTY
87881: LIST
87882: LIST
87883: PUSH
87884: LD_INT 1
87886: PUSH
87887: LD_INT 5
87889: NEG
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: PUSH
87895: EMPTY
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
87909: LD_ADDR_VAR 0 30
87913: PUSH
87914: LD_INT 2
87916: PUSH
87917: LD_INT 1
87919: NEG
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: PUSH
87925: LD_INT 3
87927: PUSH
87928: LD_INT 0
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 3
87937: PUSH
87938: LD_INT 1
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: PUSH
87945: LD_INT 3
87947: PUSH
87948: LD_INT 1
87950: NEG
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 4
87958: PUSH
87959: LD_INT 0
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 4
87968: PUSH
87969: LD_INT 1
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PUSH
87976: LD_INT 4
87978: PUSH
87979: LD_INT 1
87981: NEG
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 5
87989: PUSH
87990: LD_INT 0
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: LD_INT 5
87999: PUSH
88000: LD_INT 1
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: LD_INT 5
88009: PUSH
88010: LD_INT 1
88012: NEG
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 6
88020: PUSH
88021: LD_INT 0
88023: PUSH
88024: EMPTY
88025: LIST
88026: LIST
88027: PUSH
88028: LD_INT 6
88030: PUSH
88031: LD_INT 1
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
88052: LD_ADDR_VAR 0 31
88056: PUSH
88057: LD_INT 3
88059: PUSH
88060: LD_INT 2
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PUSH
88067: LD_INT 3
88069: PUSH
88070: LD_INT 3
88072: PUSH
88073: EMPTY
88074: LIST
88075: LIST
88076: PUSH
88077: LD_INT 2
88079: PUSH
88080: LD_INT 3
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 4
88089: PUSH
88090: LD_INT 3
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PUSH
88097: LD_INT 4
88099: PUSH
88100: LD_INT 4
88102: PUSH
88103: EMPTY
88104: LIST
88105: LIST
88106: PUSH
88107: LD_INT 3
88109: PUSH
88110: LD_INT 4
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 5
88119: PUSH
88120: LD_INT 4
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 5
88129: PUSH
88130: LD_INT 5
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PUSH
88137: LD_INT 4
88139: PUSH
88140: LD_INT 5
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 6
88149: PUSH
88150: LD_INT 5
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 6
88159: PUSH
88160: LD_INT 6
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 5
88169: PUSH
88170: LD_INT 6
88172: PUSH
88173: EMPTY
88174: LIST
88175: LIST
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
88191: LD_ADDR_VAR 0 32
88195: PUSH
88196: LD_INT 1
88198: PUSH
88199: LD_INT 3
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 0
88208: PUSH
88209: LD_INT 3
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 1
88218: NEG
88219: PUSH
88220: LD_INT 2
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 1
88229: PUSH
88230: LD_INT 4
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 0
88239: PUSH
88240: LD_INT 4
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 1
88249: NEG
88250: PUSH
88251: LD_INT 3
88253: PUSH
88254: EMPTY
88255: LIST
88256: LIST
88257: PUSH
88258: LD_INT 1
88260: PUSH
88261: LD_INT 5
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 0
88270: PUSH
88271: LD_INT 5
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 1
88280: NEG
88281: PUSH
88282: LD_INT 4
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: PUSH
88289: LD_INT 1
88291: PUSH
88292: LD_INT 6
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: PUSH
88299: LD_INT 0
88301: PUSH
88302: LD_INT 6
88304: PUSH
88305: EMPTY
88306: LIST
88307: LIST
88308: PUSH
88309: LD_INT 1
88311: NEG
88312: PUSH
88313: LD_INT 5
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
88334: LD_ADDR_VAR 0 33
88338: PUSH
88339: LD_INT 2
88341: NEG
88342: PUSH
88343: LD_INT 1
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 3
88352: NEG
88353: PUSH
88354: LD_INT 0
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: PUSH
88361: LD_INT 3
88363: NEG
88364: PUSH
88365: LD_INT 1
88367: NEG
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 3
88375: NEG
88376: PUSH
88377: LD_INT 1
88379: PUSH
88380: EMPTY
88381: LIST
88382: LIST
88383: PUSH
88384: LD_INT 4
88386: NEG
88387: PUSH
88388: LD_INT 0
88390: PUSH
88391: EMPTY
88392: LIST
88393: LIST
88394: PUSH
88395: LD_INT 4
88397: NEG
88398: PUSH
88399: LD_INT 1
88401: NEG
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PUSH
88407: LD_INT 4
88409: NEG
88410: PUSH
88411: LD_INT 1
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 5
88420: NEG
88421: PUSH
88422: LD_INT 0
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: LD_INT 5
88431: NEG
88432: PUSH
88433: LD_INT 1
88435: NEG
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 5
88443: NEG
88444: PUSH
88445: LD_INT 1
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: PUSH
88452: LD_INT 6
88454: NEG
88455: PUSH
88456: LD_INT 0
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 6
88465: NEG
88466: PUSH
88467: LD_INT 1
88469: NEG
88470: PUSH
88471: EMPTY
88472: LIST
88473: LIST
88474: PUSH
88475: EMPTY
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
88489: LD_ADDR_VAR 0 34
88493: PUSH
88494: LD_INT 2
88496: NEG
88497: PUSH
88498: LD_INT 3
88500: NEG
88501: PUSH
88502: EMPTY
88503: LIST
88504: LIST
88505: PUSH
88506: LD_INT 3
88508: NEG
88509: PUSH
88510: LD_INT 2
88512: NEG
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PUSH
88518: LD_INT 3
88520: NEG
88521: PUSH
88522: LD_INT 3
88524: NEG
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 3
88532: NEG
88533: PUSH
88534: LD_INT 4
88536: NEG
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 4
88544: NEG
88545: PUSH
88546: LD_INT 3
88548: NEG
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PUSH
88554: LD_INT 4
88556: NEG
88557: PUSH
88558: LD_INT 4
88560: NEG
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: PUSH
88566: LD_INT 4
88568: NEG
88569: PUSH
88570: LD_INT 5
88572: NEG
88573: PUSH
88574: EMPTY
88575: LIST
88576: LIST
88577: PUSH
88578: LD_INT 5
88580: NEG
88581: PUSH
88582: LD_INT 4
88584: NEG
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 5
88592: NEG
88593: PUSH
88594: LD_INT 5
88596: NEG
88597: PUSH
88598: EMPTY
88599: LIST
88600: LIST
88601: PUSH
88602: LD_INT 5
88604: NEG
88605: PUSH
88606: LD_INT 6
88608: NEG
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: PUSH
88614: LD_INT 6
88616: NEG
88617: PUSH
88618: LD_INT 5
88620: NEG
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 6
88628: NEG
88629: PUSH
88630: LD_INT 6
88632: NEG
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: EMPTY
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
88652: LD_ADDR_VAR 0 41
88656: PUSH
88657: LD_INT 0
88659: PUSH
88660: LD_INT 2
88662: NEG
88663: PUSH
88664: EMPTY
88665: LIST
88666: LIST
88667: PUSH
88668: LD_INT 1
88670: NEG
88671: PUSH
88672: LD_INT 3
88674: NEG
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 1
88682: PUSH
88683: LD_INT 2
88685: NEG
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: LIST
88695: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
88696: LD_ADDR_VAR 0 42
88700: PUSH
88701: LD_INT 2
88703: PUSH
88704: LD_INT 0
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 2
88713: PUSH
88714: LD_INT 1
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 3
88724: PUSH
88725: LD_INT 1
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: LIST
88736: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
88737: LD_ADDR_VAR 0 43
88741: PUSH
88742: LD_INT 2
88744: PUSH
88745: LD_INT 2
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 3
88754: PUSH
88755: LD_INT 2
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 2
88764: PUSH
88765: LD_INT 3
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: LIST
88776: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
88777: LD_ADDR_VAR 0 44
88781: PUSH
88782: LD_INT 0
88784: PUSH
88785: LD_INT 2
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: LD_INT 3
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: PUSH
88802: LD_INT 1
88804: NEG
88805: PUSH
88806: LD_INT 2
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: LIST
88817: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88818: LD_ADDR_VAR 0 45
88822: PUSH
88823: LD_INT 2
88825: NEG
88826: PUSH
88827: LD_INT 0
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 2
88836: NEG
88837: PUSH
88838: LD_INT 1
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: PUSH
88845: LD_INT 3
88847: NEG
88848: PUSH
88849: LD_INT 1
88851: NEG
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: EMPTY
88858: LIST
88859: LIST
88860: LIST
88861: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
88862: LD_ADDR_VAR 0 46
88866: PUSH
88867: LD_INT 2
88869: NEG
88870: PUSH
88871: LD_INT 2
88873: NEG
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 2
88881: NEG
88882: PUSH
88883: LD_INT 3
88885: NEG
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 3
88893: NEG
88894: PUSH
88895: LD_INT 2
88897: NEG
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: LIST
88907: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
88908: LD_ADDR_VAR 0 47
88912: PUSH
88913: LD_INT 2
88915: NEG
88916: PUSH
88917: LD_INT 3
88919: NEG
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 1
88927: NEG
88928: PUSH
88929: LD_INT 3
88931: NEG
88932: PUSH
88933: EMPTY
88934: LIST
88935: LIST
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
88941: LD_ADDR_VAR 0 48
88945: PUSH
88946: LD_INT 1
88948: PUSH
88949: LD_INT 2
88951: NEG
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: PUSH
88957: LD_INT 2
88959: PUSH
88960: LD_INT 1
88962: NEG
88963: PUSH
88964: EMPTY
88965: LIST
88966: LIST
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
88972: LD_ADDR_VAR 0 49
88976: PUSH
88977: LD_INT 3
88979: PUSH
88980: LD_INT 1
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 3
88989: PUSH
88990: LD_INT 2
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
89001: LD_ADDR_VAR 0 50
89005: PUSH
89006: LD_INT 2
89008: PUSH
89009: LD_INT 3
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: LD_INT 1
89018: PUSH
89019: LD_INT 3
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
89030: LD_ADDR_VAR 0 51
89034: PUSH
89035: LD_INT 1
89037: NEG
89038: PUSH
89039: LD_INT 2
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 2
89048: NEG
89049: PUSH
89050: LD_INT 1
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89061: LD_ADDR_VAR 0 52
89065: PUSH
89066: LD_INT 3
89068: NEG
89069: PUSH
89070: LD_INT 1
89072: NEG
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 3
89080: NEG
89081: PUSH
89082: LD_INT 2
89084: NEG
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89094: LD_ADDR_VAR 0 53
89098: PUSH
89099: LD_INT 1
89101: NEG
89102: PUSH
89103: LD_INT 3
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 0
89113: PUSH
89114: LD_INT 3
89116: NEG
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: PUSH
89122: LD_INT 1
89124: PUSH
89125: LD_INT 2
89127: NEG
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: LIST
89137: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89138: LD_ADDR_VAR 0 54
89142: PUSH
89143: LD_INT 2
89145: PUSH
89146: LD_INT 1
89148: NEG
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 3
89156: PUSH
89157: LD_INT 0
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 3
89166: PUSH
89167: LD_INT 1
89169: PUSH
89170: EMPTY
89171: LIST
89172: LIST
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: LIST
89178: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89179: LD_ADDR_VAR 0 55
89183: PUSH
89184: LD_INT 3
89186: PUSH
89187: LD_INT 2
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 3
89196: PUSH
89197: LD_INT 3
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: LD_INT 2
89206: PUSH
89207: LD_INT 3
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: LIST
89218: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89219: LD_ADDR_VAR 0 56
89223: PUSH
89224: LD_INT 1
89226: PUSH
89227: LD_INT 3
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: LD_INT 3
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 1
89246: NEG
89247: PUSH
89248: LD_INT 2
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: LIST
89259: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89260: LD_ADDR_VAR 0 57
89264: PUSH
89265: LD_INT 2
89267: NEG
89268: PUSH
89269: LD_INT 1
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 3
89278: NEG
89279: PUSH
89280: LD_INT 0
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 3
89289: NEG
89290: PUSH
89291: LD_INT 1
89293: NEG
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: LIST
89303: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89304: LD_ADDR_VAR 0 58
89308: PUSH
89309: LD_INT 2
89311: NEG
89312: PUSH
89313: LD_INT 3
89315: NEG
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: PUSH
89321: LD_INT 3
89323: NEG
89324: PUSH
89325: LD_INT 2
89327: NEG
89328: PUSH
89329: EMPTY
89330: LIST
89331: LIST
89332: PUSH
89333: LD_INT 3
89335: NEG
89336: PUSH
89337: LD_INT 3
89339: NEG
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: LIST
89349: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
89350: LD_ADDR_VAR 0 59
89354: PUSH
89355: LD_INT 1
89357: NEG
89358: PUSH
89359: LD_INT 2
89361: NEG
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 0
89369: PUSH
89370: LD_INT 2
89372: NEG
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 1
89380: PUSH
89381: LD_INT 1
89383: NEG
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: LIST
89393: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89394: LD_ADDR_VAR 0 60
89398: PUSH
89399: LD_INT 1
89401: PUSH
89402: LD_INT 1
89404: NEG
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: LD_INT 2
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 2
89422: PUSH
89423: LD_INT 1
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: LIST
89434: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89435: LD_ADDR_VAR 0 61
89439: PUSH
89440: LD_INT 2
89442: PUSH
89443: LD_INT 1
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: PUSH
89450: LD_INT 2
89452: PUSH
89453: LD_INT 2
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 1
89462: PUSH
89463: LD_INT 2
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: LIST
89474: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89475: LD_ADDR_VAR 0 62
89479: PUSH
89480: LD_INT 1
89482: PUSH
89483: LD_INT 2
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 0
89492: PUSH
89493: LD_INT 2
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 1
89502: NEG
89503: PUSH
89504: LD_INT 1
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: LIST
89515: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89516: LD_ADDR_VAR 0 63
89520: PUSH
89521: LD_INT 1
89523: NEG
89524: PUSH
89525: LD_INT 1
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 2
89534: NEG
89535: PUSH
89536: LD_INT 0
89538: PUSH
89539: EMPTY
89540: LIST
89541: LIST
89542: PUSH
89543: LD_INT 2
89545: NEG
89546: PUSH
89547: LD_INT 1
89549: NEG
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: LIST
89559: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89560: LD_ADDR_VAR 0 64
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: LD_INT 2
89571: NEG
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: PUSH
89577: LD_INT 2
89579: NEG
89580: PUSH
89581: LD_INT 1
89583: NEG
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 2
89591: NEG
89592: PUSH
89593: LD_INT 2
89595: NEG
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: LIST
89605: ST_TO_ADDR
// end ; 2 :
89606: GO 92872
89608: LD_INT 2
89610: DOUBLE
89611: EQUAL
89612: IFTRUE 89616
89614: GO 92871
89616: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
89617: LD_ADDR_VAR 0 29
89621: PUSH
89622: LD_INT 4
89624: PUSH
89625: LD_INT 0
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 4
89634: PUSH
89635: LD_INT 1
89637: NEG
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: LD_INT 5
89645: PUSH
89646: LD_INT 0
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 5
89655: PUSH
89656: LD_INT 1
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 4
89665: PUSH
89666: LD_INT 1
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: LD_INT 3
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 3
89685: PUSH
89686: LD_INT 1
89688: NEG
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: PUSH
89694: LD_INT 3
89696: PUSH
89697: LD_INT 2
89699: NEG
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: LD_INT 5
89707: PUSH
89708: LD_INT 2
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: PUSH
89715: LD_INT 3
89717: PUSH
89718: LD_INT 3
89720: PUSH
89721: EMPTY
89722: LIST
89723: LIST
89724: PUSH
89725: LD_INT 3
89727: PUSH
89728: LD_INT 2
89730: PUSH
89731: EMPTY
89732: LIST
89733: LIST
89734: PUSH
89735: LD_INT 4
89737: PUSH
89738: LD_INT 3
89740: PUSH
89741: EMPTY
89742: LIST
89743: LIST
89744: PUSH
89745: LD_INT 4
89747: PUSH
89748: LD_INT 4
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 3
89757: PUSH
89758: LD_INT 4
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 2
89767: PUSH
89768: LD_INT 3
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 2
89777: PUSH
89778: LD_INT 2
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PUSH
89785: LD_INT 4
89787: PUSH
89788: LD_INT 2
89790: PUSH
89791: EMPTY
89792: LIST
89793: LIST
89794: PUSH
89795: LD_INT 2
89797: PUSH
89798: LD_INT 4
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: LD_INT 0
89807: PUSH
89808: LD_INT 4
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: LD_INT 0
89817: PUSH
89818: LD_INT 3
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: PUSH
89825: LD_INT 1
89827: PUSH
89828: LD_INT 4
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: LD_INT 5
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 0
89847: PUSH
89848: LD_INT 5
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PUSH
89855: LD_INT 1
89857: NEG
89858: PUSH
89859: LD_INT 4
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: LD_INT 1
89868: NEG
89869: PUSH
89870: LD_INT 3
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 2
89879: PUSH
89880: LD_INT 5
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 2
89889: NEG
89890: PUSH
89891: LD_INT 3
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PUSH
89898: LD_INT 3
89900: NEG
89901: PUSH
89902: LD_INT 0
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: LD_INT 3
89911: NEG
89912: PUSH
89913: LD_INT 1
89915: NEG
89916: PUSH
89917: EMPTY
89918: LIST
89919: LIST
89920: PUSH
89921: LD_INT 2
89923: NEG
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: EMPTY
89929: LIST
89930: LIST
89931: PUSH
89932: LD_INT 2
89934: NEG
89935: PUSH
89936: LD_INT 1
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 3
89945: NEG
89946: PUSH
89947: LD_INT 1
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: LD_INT 4
89956: NEG
89957: PUSH
89958: LD_INT 0
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: PUSH
89965: LD_INT 4
89967: NEG
89968: PUSH
89969: LD_INT 1
89971: NEG
89972: PUSH
89973: EMPTY
89974: LIST
89975: LIST
89976: PUSH
89977: LD_INT 4
89979: NEG
89980: PUSH
89981: LD_INT 2
89983: NEG
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: LD_INT 2
89991: NEG
89992: PUSH
89993: LD_INT 2
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 4
90002: NEG
90003: PUSH
90004: LD_INT 4
90006: NEG
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 4
90014: NEG
90015: PUSH
90016: LD_INT 5
90018: NEG
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 3
90026: NEG
90027: PUSH
90028: LD_INT 4
90030: NEG
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: PUSH
90036: LD_INT 3
90038: NEG
90039: PUSH
90040: LD_INT 3
90042: NEG
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: LD_INT 4
90050: NEG
90051: PUSH
90052: LD_INT 3
90054: NEG
90055: PUSH
90056: EMPTY
90057: LIST
90058: LIST
90059: PUSH
90060: LD_INT 5
90062: NEG
90063: PUSH
90064: LD_INT 4
90066: NEG
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 5
90074: NEG
90075: PUSH
90076: LD_INT 5
90078: NEG
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 3
90086: NEG
90087: PUSH
90088: LD_INT 5
90090: NEG
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 5
90098: NEG
90099: PUSH
90100: LD_INT 3
90102: NEG
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: LIST
90137: LIST
90138: LIST
90139: LIST
90140: LIST
90141: LIST
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
90155: LD_ADDR_VAR 0 30
90159: PUSH
90160: LD_INT 4
90162: PUSH
90163: LD_INT 4
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 4
90172: PUSH
90173: LD_INT 3
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: PUSH
90180: LD_INT 5
90182: PUSH
90183: LD_INT 4
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: LD_INT 5
90192: PUSH
90193: LD_INT 5
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 4
90202: PUSH
90203: LD_INT 5
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 3
90212: PUSH
90213: LD_INT 4
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 3
90222: PUSH
90223: LD_INT 3
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PUSH
90230: LD_INT 5
90232: PUSH
90233: LD_INT 3
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 3
90242: PUSH
90243: LD_INT 5
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 0
90252: PUSH
90253: LD_INT 3
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: LD_INT 0
90262: PUSH
90263: LD_INT 2
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: PUSH
90270: LD_INT 1
90272: PUSH
90273: LD_INT 3
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PUSH
90280: LD_INT 1
90282: PUSH
90283: LD_INT 4
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: LD_INT 0
90292: PUSH
90293: LD_INT 4
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: LD_INT 1
90302: NEG
90303: PUSH
90304: LD_INT 3
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 1
90313: NEG
90314: PUSH
90315: LD_INT 2
90317: PUSH
90318: EMPTY
90319: LIST
90320: LIST
90321: PUSH
90322: LD_INT 2
90324: PUSH
90325: LD_INT 4
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 2
90334: NEG
90335: PUSH
90336: LD_INT 2
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 4
90345: NEG
90346: PUSH
90347: LD_INT 0
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: PUSH
90354: LD_INT 4
90356: NEG
90357: PUSH
90358: LD_INT 1
90360: NEG
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 3
90368: NEG
90369: PUSH
90370: LD_INT 0
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 3
90379: NEG
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 4
90390: NEG
90391: PUSH
90392: LD_INT 1
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 5
90401: NEG
90402: PUSH
90403: LD_INT 0
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 5
90412: NEG
90413: PUSH
90414: LD_INT 1
90416: NEG
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 5
90424: NEG
90425: PUSH
90426: LD_INT 2
90428: NEG
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 3
90436: NEG
90437: PUSH
90438: LD_INT 2
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 3
90447: NEG
90448: PUSH
90449: LD_INT 3
90451: NEG
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: LD_INT 3
90459: NEG
90460: PUSH
90461: LD_INT 4
90463: NEG
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 2
90471: NEG
90472: PUSH
90473: LD_INT 3
90475: NEG
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: LD_INT 2
90483: NEG
90484: PUSH
90485: LD_INT 2
90487: NEG
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 3
90495: NEG
90496: PUSH
90497: LD_INT 2
90499: NEG
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: PUSH
90505: LD_INT 4
90507: NEG
90508: PUSH
90509: LD_INT 3
90511: NEG
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 4
90519: NEG
90520: PUSH
90521: LD_INT 4
90523: NEG
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 2
90531: NEG
90532: PUSH
90533: LD_INT 4
90535: NEG
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: PUSH
90541: LD_INT 4
90543: NEG
90544: PUSH
90545: LD_INT 2
90547: NEG
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 0
90555: PUSH
90556: LD_INT 4
90558: NEG
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 0
90566: PUSH
90567: LD_INT 5
90569: NEG
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: LD_INT 1
90577: PUSH
90578: LD_INT 4
90580: NEG
90581: PUSH
90582: EMPTY
90583: LIST
90584: LIST
90585: PUSH
90586: LD_INT 1
90588: PUSH
90589: LD_INT 3
90591: NEG
90592: PUSH
90593: EMPTY
90594: LIST
90595: LIST
90596: PUSH
90597: LD_INT 0
90599: PUSH
90600: LD_INT 3
90602: NEG
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 1
90610: NEG
90611: PUSH
90612: LD_INT 4
90614: NEG
90615: PUSH
90616: EMPTY
90617: LIST
90618: LIST
90619: PUSH
90620: LD_INT 1
90622: NEG
90623: PUSH
90624: LD_INT 5
90626: NEG
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: PUSH
90632: LD_INT 2
90634: PUSH
90635: LD_INT 3
90637: NEG
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: PUSH
90643: LD_INT 2
90645: NEG
90646: PUSH
90647: LD_INT 5
90649: NEG
90650: PUSH
90651: EMPTY
90652: LIST
90653: LIST
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: LIST
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
90702: LD_ADDR_VAR 0 31
90706: PUSH
90707: LD_INT 0
90709: PUSH
90710: LD_INT 4
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 0
90719: PUSH
90720: LD_INT 3
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 1
90729: PUSH
90730: LD_INT 4
90732: PUSH
90733: EMPTY
90734: LIST
90735: LIST
90736: PUSH
90737: LD_INT 1
90739: PUSH
90740: LD_INT 5
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: PUSH
90747: LD_INT 0
90749: PUSH
90750: LD_INT 5
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: PUSH
90757: LD_INT 1
90759: NEG
90760: PUSH
90761: LD_INT 4
90763: PUSH
90764: EMPTY
90765: LIST
90766: LIST
90767: PUSH
90768: LD_INT 1
90770: NEG
90771: PUSH
90772: LD_INT 3
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 2
90781: PUSH
90782: LD_INT 5
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 2
90791: NEG
90792: PUSH
90793: LD_INT 3
90795: PUSH
90796: EMPTY
90797: LIST
90798: LIST
90799: PUSH
90800: LD_INT 3
90802: NEG
90803: PUSH
90804: LD_INT 0
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PUSH
90811: LD_INT 3
90813: NEG
90814: PUSH
90815: LD_INT 1
90817: NEG
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 2
90825: NEG
90826: PUSH
90827: LD_INT 0
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 2
90836: NEG
90837: PUSH
90838: LD_INT 1
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 3
90847: NEG
90848: PUSH
90849: LD_INT 1
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 4
90858: NEG
90859: PUSH
90860: LD_INT 0
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 4
90869: NEG
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 4
90881: NEG
90882: PUSH
90883: LD_INT 2
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 2
90893: NEG
90894: PUSH
90895: LD_INT 2
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 4
90904: NEG
90905: PUSH
90906: LD_INT 4
90908: NEG
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: LD_INT 4
90916: NEG
90917: PUSH
90918: LD_INT 5
90920: NEG
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 3
90928: NEG
90929: PUSH
90930: LD_INT 4
90932: NEG
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 3
90940: NEG
90941: PUSH
90942: LD_INT 3
90944: NEG
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PUSH
90950: LD_INT 4
90952: NEG
90953: PUSH
90954: LD_INT 3
90956: NEG
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 5
90964: NEG
90965: PUSH
90966: LD_INT 4
90968: NEG
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 5
90976: NEG
90977: PUSH
90978: LD_INT 5
90980: NEG
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: PUSH
90986: LD_INT 3
90988: NEG
90989: PUSH
90990: LD_INT 5
90992: NEG
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 5
91000: NEG
91001: PUSH
91002: LD_INT 3
91004: NEG
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 0
91012: PUSH
91013: LD_INT 3
91015: NEG
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: PUSH
91021: LD_INT 0
91023: PUSH
91024: LD_INT 4
91026: NEG
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PUSH
91032: LD_INT 1
91034: PUSH
91035: LD_INT 3
91037: NEG
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 1
91045: PUSH
91046: LD_INT 2
91048: NEG
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: LD_INT 0
91056: PUSH
91057: LD_INT 2
91059: NEG
91060: PUSH
91061: EMPTY
91062: LIST
91063: LIST
91064: PUSH
91065: LD_INT 1
91067: NEG
91068: PUSH
91069: LD_INT 3
91071: NEG
91072: PUSH
91073: EMPTY
91074: LIST
91075: LIST
91076: PUSH
91077: LD_INT 1
91079: NEG
91080: PUSH
91081: LD_INT 4
91083: NEG
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 2
91091: PUSH
91092: LD_INT 2
91094: NEG
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: LD_INT 2
91102: NEG
91103: PUSH
91104: LD_INT 4
91106: NEG
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: LD_INT 4
91114: PUSH
91115: LD_INT 0
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 4
91124: PUSH
91125: LD_INT 1
91127: NEG
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 5
91135: PUSH
91136: LD_INT 0
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 5
91145: PUSH
91146: LD_INT 1
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 4
91155: PUSH
91156: LD_INT 1
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 3
91165: PUSH
91166: LD_INT 0
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 3
91175: PUSH
91176: LD_INT 1
91178: NEG
91179: PUSH
91180: EMPTY
91181: LIST
91182: LIST
91183: PUSH
91184: LD_INT 3
91186: PUSH
91187: LD_INT 2
91189: NEG
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 5
91197: PUSH
91198: LD_INT 2
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
91252: LD_ADDR_VAR 0 32
91256: PUSH
91257: LD_INT 4
91259: NEG
91260: PUSH
91261: LD_INT 0
91263: PUSH
91264: EMPTY
91265: LIST
91266: LIST
91267: PUSH
91268: LD_INT 4
91270: NEG
91271: PUSH
91272: LD_INT 1
91274: NEG
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PUSH
91280: LD_INT 3
91282: NEG
91283: PUSH
91284: LD_INT 0
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 3
91293: NEG
91294: PUSH
91295: LD_INT 1
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 4
91304: NEG
91305: PUSH
91306: LD_INT 1
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PUSH
91313: LD_INT 5
91315: NEG
91316: PUSH
91317: LD_INT 0
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: LD_INT 5
91326: NEG
91327: PUSH
91328: LD_INT 1
91330: NEG
91331: PUSH
91332: EMPTY
91333: LIST
91334: LIST
91335: PUSH
91336: LD_INT 5
91338: NEG
91339: PUSH
91340: LD_INT 2
91342: NEG
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 3
91350: NEG
91351: PUSH
91352: LD_INT 2
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: LD_INT 3
91361: NEG
91362: PUSH
91363: LD_INT 3
91365: NEG
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 3
91373: NEG
91374: PUSH
91375: LD_INT 4
91377: NEG
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 2
91385: NEG
91386: PUSH
91387: LD_INT 3
91389: NEG
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 2
91397: NEG
91398: PUSH
91399: LD_INT 2
91401: NEG
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: LD_INT 3
91409: NEG
91410: PUSH
91411: LD_INT 2
91413: NEG
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 4
91421: NEG
91422: PUSH
91423: LD_INT 3
91425: NEG
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: PUSH
91431: LD_INT 4
91433: NEG
91434: PUSH
91435: LD_INT 4
91437: NEG
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: PUSH
91443: LD_INT 2
91445: NEG
91446: PUSH
91447: LD_INT 4
91449: NEG
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 4
91457: NEG
91458: PUSH
91459: LD_INT 2
91461: NEG
91462: PUSH
91463: EMPTY
91464: LIST
91465: LIST
91466: PUSH
91467: LD_INT 0
91469: PUSH
91470: LD_INT 4
91472: NEG
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 0
91480: PUSH
91481: LD_INT 5
91483: NEG
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 1
91491: PUSH
91492: LD_INT 4
91494: NEG
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 1
91502: PUSH
91503: LD_INT 3
91505: NEG
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: LD_INT 0
91513: PUSH
91514: LD_INT 3
91516: NEG
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: PUSH
91522: LD_INT 1
91524: NEG
91525: PUSH
91526: LD_INT 4
91528: NEG
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: LD_INT 1
91536: NEG
91537: PUSH
91538: LD_INT 5
91540: NEG
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 2
91548: PUSH
91549: LD_INT 3
91551: NEG
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 2
91559: NEG
91560: PUSH
91561: LD_INT 5
91563: NEG
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 3
91571: PUSH
91572: LD_INT 0
91574: PUSH
91575: EMPTY
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 3
91581: PUSH
91582: LD_INT 1
91584: NEG
91585: PUSH
91586: EMPTY
91587: LIST
91588: LIST
91589: PUSH
91590: LD_INT 4
91592: PUSH
91593: LD_INT 0
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: LD_INT 4
91602: PUSH
91603: LD_INT 1
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: PUSH
91610: LD_INT 3
91612: PUSH
91613: LD_INT 1
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: PUSH
91620: LD_INT 2
91622: PUSH
91623: LD_INT 0
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: LD_INT 2
91632: PUSH
91633: LD_INT 1
91635: NEG
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: LD_INT 2
91643: PUSH
91644: LD_INT 2
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 4
91654: PUSH
91655: LD_INT 2
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 4
91664: PUSH
91665: LD_INT 4
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 4
91674: PUSH
91675: LD_INT 3
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: LD_INT 5
91684: PUSH
91685: LD_INT 4
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: PUSH
91692: LD_INT 5
91694: PUSH
91695: LD_INT 5
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: PUSH
91702: LD_INT 4
91704: PUSH
91705: LD_INT 5
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 3
91714: PUSH
91715: LD_INT 4
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 3
91724: PUSH
91725: LD_INT 3
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 5
91734: PUSH
91735: LD_INT 3
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 3
91744: PUSH
91745: LD_INT 5
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
91799: LD_ADDR_VAR 0 33
91803: PUSH
91804: LD_INT 4
91806: NEG
91807: PUSH
91808: LD_INT 4
91810: NEG
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 4
91818: NEG
91819: PUSH
91820: LD_INT 5
91822: NEG
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: LD_INT 3
91830: NEG
91831: PUSH
91832: LD_INT 4
91834: NEG
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 3
91842: NEG
91843: PUSH
91844: LD_INT 3
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 4
91854: NEG
91855: PUSH
91856: LD_INT 3
91858: NEG
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PUSH
91864: LD_INT 5
91866: NEG
91867: PUSH
91868: LD_INT 4
91870: NEG
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 5
91878: NEG
91879: PUSH
91880: LD_INT 5
91882: NEG
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: PUSH
91888: LD_INT 3
91890: NEG
91891: PUSH
91892: LD_INT 5
91894: NEG
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: PUSH
91900: LD_INT 5
91902: NEG
91903: PUSH
91904: LD_INT 3
91906: NEG
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: LD_INT 0
91914: PUSH
91915: LD_INT 3
91917: NEG
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: LD_INT 0
91925: PUSH
91926: LD_INT 4
91928: NEG
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: PUSH
91934: LD_INT 1
91936: PUSH
91937: LD_INT 3
91939: NEG
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 1
91947: PUSH
91948: LD_INT 2
91950: NEG
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: LD_INT 0
91958: PUSH
91959: LD_INT 2
91961: NEG
91962: PUSH
91963: EMPTY
91964: LIST
91965: LIST
91966: PUSH
91967: LD_INT 1
91969: NEG
91970: PUSH
91971: LD_INT 3
91973: NEG
91974: PUSH
91975: EMPTY
91976: LIST
91977: LIST
91978: PUSH
91979: LD_INT 1
91981: NEG
91982: PUSH
91983: LD_INT 4
91985: NEG
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: PUSH
91991: LD_INT 2
91993: PUSH
91994: LD_INT 2
91996: NEG
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 2
92004: NEG
92005: PUSH
92006: LD_INT 4
92008: NEG
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 4
92016: PUSH
92017: LD_INT 0
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: PUSH
92024: LD_INT 4
92026: PUSH
92027: LD_INT 1
92029: NEG
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: LD_INT 5
92037: PUSH
92038: LD_INT 0
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: PUSH
92045: LD_INT 5
92047: PUSH
92048: LD_INT 1
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 4
92057: PUSH
92058: LD_INT 1
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: LD_INT 3
92067: PUSH
92068: LD_INT 0
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 3
92077: PUSH
92078: LD_INT 1
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 3
92088: PUSH
92089: LD_INT 2
92091: NEG
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 5
92099: PUSH
92100: LD_INT 2
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 3
92109: PUSH
92110: LD_INT 3
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 3
92119: PUSH
92120: LD_INT 2
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 4
92129: PUSH
92130: LD_INT 3
92132: PUSH
92133: EMPTY
92134: LIST
92135: LIST
92136: PUSH
92137: LD_INT 4
92139: PUSH
92140: LD_INT 4
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 3
92149: PUSH
92150: LD_INT 4
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 2
92159: PUSH
92160: LD_INT 3
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: LD_INT 2
92169: PUSH
92170: LD_INT 2
92172: PUSH
92173: EMPTY
92174: LIST
92175: LIST
92176: PUSH
92177: LD_INT 4
92179: PUSH
92180: LD_INT 2
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 2
92189: PUSH
92190: LD_INT 4
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 0
92199: PUSH
92200: LD_INT 4
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: LD_INT 0
92209: PUSH
92210: LD_INT 3
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: LD_INT 1
92219: PUSH
92220: LD_INT 4
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PUSH
92227: LD_INT 1
92229: PUSH
92230: LD_INT 5
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 0
92239: PUSH
92240: LD_INT 5
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 1
92249: NEG
92250: PUSH
92251: LD_INT 4
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: PUSH
92258: LD_INT 1
92260: NEG
92261: PUSH
92262: LD_INT 3
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: PUSH
92269: LD_INT 2
92271: PUSH
92272: LD_INT 5
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: LD_INT 2
92281: NEG
92282: PUSH
92283: LD_INT 3
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
92337: LD_ADDR_VAR 0 34
92341: PUSH
92342: LD_INT 0
92344: PUSH
92345: LD_INT 4
92347: NEG
92348: PUSH
92349: EMPTY
92350: LIST
92351: LIST
92352: PUSH
92353: LD_INT 0
92355: PUSH
92356: LD_INT 5
92358: NEG
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 1
92366: PUSH
92367: LD_INT 4
92369: NEG
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PUSH
92375: LD_INT 1
92377: PUSH
92378: LD_INT 3
92380: NEG
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: PUSH
92386: LD_INT 0
92388: PUSH
92389: LD_INT 3
92391: NEG
92392: PUSH
92393: EMPTY
92394: LIST
92395: LIST
92396: PUSH
92397: LD_INT 1
92399: NEG
92400: PUSH
92401: LD_INT 4
92403: NEG
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: PUSH
92409: LD_INT 1
92411: NEG
92412: PUSH
92413: LD_INT 5
92415: NEG
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 2
92423: PUSH
92424: LD_INT 3
92426: NEG
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 2
92434: NEG
92435: PUSH
92436: LD_INT 5
92438: NEG
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 3
92446: PUSH
92447: LD_INT 0
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 3
92456: PUSH
92457: LD_INT 1
92459: NEG
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 4
92467: PUSH
92468: LD_INT 0
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 4
92477: PUSH
92478: LD_INT 1
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 3
92487: PUSH
92488: LD_INT 1
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: PUSH
92495: LD_INT 2
92497: PUSH
92498: LD_INT 0
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: PUSH
92505: LD_INT 2
92507: PUSH
92508: LD_INT 1
92510: NEG
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 2
92518: PUSH
92519: LD_INT 2
92521: NEG
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: PUSH
92527: LD_INT 4
92529: PUSH
92530: LD_INT 2
92532: PUSH
92533: EMPTY
92534: LIST
92535: LIST
92536: PUSH
92537: LD_INT 4
92539: PUSH
92540: LD_INT 4
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 4
92549: PUSH
92550: LD_INT 3
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: LD_INT 5
92559: PUSH
92560: LD_INT 4
92562: PUSH
92563: EMPTY
92564: LIST
92565: LIST
92566: PUSH
92567: LD_INT 5
92569: PUSH
92570: LD_INT 5
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: LD_INT 4
92579: PUSH
92580: LD_INT 5
92582: PUSH
92583: EMPTY
92584: LIST
92585: LIST
92586: PUSH
92587: LD_INT 3
92589: PUSH
92590: LD_INT 4
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: PUSH
92597: LD_INT 3
92599: PUSH
92600: LD_INT 3
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 5
92609: PUSH
92610: LD_INT 3
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: PUSH
92617: LD_INT 3
92619: PUSH
92620: LD_INT 5
92622: PUSH
92623: EMPTY
92624: LIST
92625: LIST
92626: PUSH
92627: LD_INT 0
92629: PUSH
92630: LD_INT 3
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: LD_INT 0
92639: PUSH
92640: LD_INT 2
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: PUSH
92647: LD_INT 1
92649: PUSH
92650: LD_INT 3
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 1
92659: PUSH
92660: LD_INT 4
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 0
92669: PUSH
92670: LD_INT 4
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 1
92679: NEG
92680: PUSH
92681: LD_INT 3
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 1
92690: NEG
92691: PUSH
92692: LD_INT 2
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: LD_INT 2
92701: PUSH
92702: LD_INT 4
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 2
92711: NEG
92712: PUSH
92713: LD_INT 2
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 4
92722: NEG
92723: PUSH
92724: LD_INT 0
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 4
92733: NEG
92734: PUSH
92735: LD_INT 1
92737: NEG
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 3
92745: NEG
92746: PUSH
92747: LD_INT 0
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 3
92756: NEG
92757: PUSH
92758: LD_INT 1
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 4
92767: NEG
92768: PUSH
92769: LD_INT 1
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 5
92778: NEG
92779: PUSH
92780: LD_INT 0
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 5
92789: NEG
92790: PUSH
92791: LD_INT 1
92793: NEG
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 5
92801: NEG
92802: PUSH
92803: LD_INT 2
92805: NEG
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 3
92813: NEG
92814: PUSH
92815: LD_INT 2
92817: PUSH
92818: EMPTY
92819: LIST
92820: LIST
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: ST_TO_ADDR
// end ; end ;
92869: GO 92872
92871: POP
// case btype of b_depot , b_warehouse :
92872: LD_VAR 0 1
92876: PUSH
92877: LD_INT 0
92879: DOUBLE
92880: EQUAL
92881: IFTRUE 92891
92883: LD_INT 1
92885: DOUBLE
92886: EQUAL
92887: IFTRUE 92891
92889: GO 93092
92891: POP
// case nation of nation_american :
92892: LD_VAR 0 5
92896: PUSH
92897: LD_INT 1
92899: DOUBLE
92900: EQUAL
92901: IFTRUE 92905
92903: GO 92961
92905: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
92906: LD_ADDR_VAR 0 9
92910: PUSH
92911: LD_VAR 0 11
92915: PUSH
92916: LD_VAR 0 12
92920: PUSH
92921: LD_VAR 0 13
92925: PUSH
92926: LD_VAR 0 14
92930: PUSH
92931: LD_VAR 0 15
92935: PUSH
92936: LD_VAR 0 16
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: PUSH
92949: LD_VAR 0 4
92953: PUSH
92954: LD_INT 1
92956: PLUS
92957: ARRAY
92958: ST_TO_ADDR
92959: GO 93090
92961: LD_INT 2
92963: DOUBLE
92964: EQUAL
92965: IFTRUE 92969
92967: GO 93025
92969: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
92970: LD_ADDR_VAR 0 9
92974: PUSH
92975: LD_VAR 0 17
92979: PUSH
92980: LD_VAR 0 18
92984: PUSH
92985: LD_VAR 0 19
92989: PUSH
92990: LD_VAR 0 20
92994: PUSH
92995: LD_VAR 0 21
92999: PUSH
93000: LD_VAR 0 22
93004: PUSH
93005: EMPTY
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: PUSH
93013: LD_VAR 0 4
93017: PUSH
93018: LD_INT 1
93020: PLUS
93021: ARRAY
93022: ST_TO_ADDR
93023: GO 93090
93025: LD_INT 3
93027: DOUBLE
93028: EQUAL
93029: IFTRUE 93033
93031: GO 93089
93033: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
93034: LD_ADDR_VAR 0 9
93038: PUSH
93039: LD_VAR 0 23
93043: PUSH
93044: LD_VAR 0 24
93048: PUSH
93049: LD_VAR 0 25
93053: PUSH
93054: LD_VAR 0 26
93058: PUSH
93059: LD_VAR 0 27
93063: PUSH
93064: LD_VAR 0 28
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: PUSH
93077: LD_VAR 0 4
93081: PUSH
93082: LD_INT 1
93084: PLUS
93085: ARRAY
93086: ST_TO_ADDR
93087: GO 93090
93089: POP
93090: GO 93645
93092: LD_INT 2
93094: DOUBLE
93095: EQUAL
93096: IFTRUE 93106
93098: LD_INT 3
93100: DOUBLE
93101: EQUAL
93102: IFTRUE 93106
93104: GO 93162
93106: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
93107: LD_ADDR_VAR 0 9
93111: PUSH
93112: LD_VAR 0 29
93116: PUSH
93117: LD_VAR 0 30
93121: PUSH
93122: LD_VAR 0 31
93126: PUSH
93127: LD_VAR 0 32
93131: PUSH
93132: LD_VAR 0 33
93136: PUSH
93137: LD_VAR 0 34
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: PUSH
93150: LD_VAR 0 4
93154: PUSH
93155: LD_INT 1
93157: PLUS
93158: ARRAY
93159: ST_TO_ADDR
93160: GO 93645
93162: LD_INT 16
93164: DOUBLE
93165: EQUAL
93166: IFTRUE 93224
93168: LD_INT 17
93170: DOUBLE
93171: EQUAL
93172: IFTRUE 93224
93174: LD_INT 18
93176: DOUBLE
93177: EQUAL
93178: IFTRUE 93224
93180: LD_INT 19
93182: DOUBLE
93183: EQUAL
93184: IFTRUE 93224
93186: LD_INT 22
93188: DOUBLE
93189: EQUAL
93190: IFTRUE 93224
93192: LD_INT 20
93194: DOUBLE
93195: EQUAL
93196: IFTRUE 93224
93198: LD_INT 21
93200: DOUBLE
93201: EQUAL
93202: IFTRUE 93224
93204: LD_INT 23
93206: DOUBLE
93207: EQUAL
93208: IFTRUE 93224
93210: LD_INT 24
93212: DOUBLE
93213: EQUAL
93214: IFTRUE 93224
93216: LD_INT 25
93218: DOUBLE
93219: EQUAL
93220: IFTRUE 93224
93222: GO 93280
93224: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
93225: LD_ADDR_VAR 0 9
93229: PUSH
93230: LD_VAR 0 35
93234: PUSH
93235: LD_VAR 0 36
93239: PUSH
93240: LD_VAR 0 37
93244: PUSH
93245: LD_VAR 0 38
93249: PUSH
93250: LD_VAR 0 39
93254: PUSH
93255: LD_VAR 0 40
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: PUSH
93268: LD_VAR 0 4
93272: PUSH
93273: LD_INT 1
93275: PLUS
93276: ARRAY
93277: ST_TO_ADDR
93278: GO 93645
93280: LD_INT 6
93282: DOUBLE
93283: EQUAL
93284: IFTRUE 93336
93286: LD_INT 7
93288: DOUBLE
93289: EQUAL
93290: IFTRUE 93336
93292: LD_INT 8
93294: DOUBLE
93295: EQUAL
93296: IFTRUE 93336
93298: LD_INT 13
93300: DOUBLE
93301: EQUAL
93302: IFTRUE 93336
93304: LD_INT 12
93306: DOUBLE
93307: EQUAL
93308: IFTRUE 93336
93310: LD_INT 15
93312: DOUBLE
93313: EQUAL
93314: IFTRUE 93336
93316: LD_INT 11
93318: DOUBLE
93319: EQUAL
93320: IFTRUE 93336
93322: LD_INT 14
93324: DOUBLE
93325: EQUAL
93326: IFTRUE 93336
93328: LD_INT 10
93330: DOUBLE
93331: EQUAL
93332: IFTRUE 93336
93334: GO 93392
93336: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
93337: LD_ADDR_VAR 0 9
93341: PUSH
93342: LD_VAR 0 41
93346: PUSH
93347: LD_VAR 0 42
93351: PUSH
93352: LD_VAR 0 43
93356: PUSH
93357: LD_VAR 0 44
93361: PUSH
93362: LD_VAR 0 45
93366: PUSH
93367: LD_VAR 0 46
93371: PUSH
93372: EMPTY
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: PUSH
93380: LD_VAR 0 4
93384: PUSH
93385: LD_INT 1
93387: PLUS
93388: ARRAY
93389: ST_TO_ADDR
93390: GO 93645
93392: LD_INT 36
93394: DOUBLE
93395: EQUAL
93396: IFTRUE 93400
93398: GO 93456
93400: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
93401: LD_ADDR_VAR 0 9
93405: PUSH
93406: LD_VAR 0 47
93410: PUSH
93411: LD_VAR 0 48
93415: PUSH
93416: LD_VAR 0 49
93420: PUSH
93421: LD_VAR 0 50
93425: PUSH
93426: LD_VAR 0 51
93430: PUSH
93431: LD_VAR 0 52
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: PUSH
93444: LD_VAR 0 4
93448: PUSH
93449: LD_INT 1
93451: PLUS
93452: ARRAY
93453: ST_TO_ADDR
93454: GO 93645
93456: LD_INT 4
93458: DOUBLE
93459: EQUAL
93460: IFTRUE 93482
93462: LD_INT 5
93464: DOUBLE
93465: EQUAL
93466: IFTRUE 93482
93468: LD_INT 34
93470: DOUBLE
93471: EQUAL
93472: IFTRUE 93482
93474: LD_INT 37
93476: DOUBLE
93477: EQUAL
93478: IFTRUE 93482
93480: GO 93538
93482: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
93483: LD_ADDR_VAR 0 9
93487: PUSH
93488: LD_VAR 0 53
93492: PUSH
93493: LD_VAR 0 54
93497: PUSH
93498: LD_VAR 0 55
93502: PUSH
93503: LD_VAR 0 56
93507: PUSH
93508: LD_VAR 0 57
93512: PUSH
93513: LD_VAR 0 58
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: PUSH
93526: LD_VAR 0 4
93530: PUSH
93531: LD_INT 1
93533: PLUS
93534: ARRAY
93535: ST_TO_ADDR
93536: GO 93645
93538: LD_INT 31
93540: DOUBLE
93541: EQUAL
93542: IFTRUE 93588
93544: LD_INT 32
93546: DOUBLE
93547: EQUAL
93548: IFTRUE 93588
93550: LD_INT 33
93552: DOUBLE
93553: EQUAL
93554: IFTRUE 93588
93556: LD_INT 27
93558: DOUBLE
93559: EQUAL
93560: IFTRUE 93588
93562: LD_INT 26
93564: DOUBLE
93565: EQUAL
93566: IFTRUE 93588
93568: LD_INT 28
93570: DOUBLE
93571: EQUAL
93572: IFTRUE 93588
93574: LD_INT 29
93576: DOUBLE
93577: EQUAL
93578: IFTRUE 93588
93580: LD_INT 30
93582: DOUBLE
93583: EQUAL
93584: IFTRUE 93588
93586: GO 93644
93588: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
93589: LD_ADDR_VAR 0 9
93593: PUSH
93594: LD_VAR 0 59
93598: PUSH
93599: LD_VAR 0 60
93603: PUSH
93604: LD_VAR 0 61
93608: PUSH
93609: LD_VAR 0 62
93613: PUSH
93614: LD_VAR 0 63
93618: PUSH
93619: LD_VAR 0 64
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: LIST
93628: LIST
93629: LIST
93630: LIST
93631: PUSH
93632: LD_VAR 0 4
93636: PUSH
93637: LD_INT 1
93639: PLUS
93640: ARRAY
93641: ST_TO_ADDR
93642: GO 93645
93644: POP
// temp_list2 = [ ] ;
93645: LD_ADDR_VAR 0 10
93649: PUSH
93650: EMPTY
93651: ST_TO_ADDR
// for i in temp_list do
93652: LD_ADDR_VAR 0 8
93656: PUSH
93657: LD_VAR 0 9
93661: PUSH
93662: FOR_IN
93663: IFFALSE 93715
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
93665: LD_ADDR_VAR 0 10
93669: PUSH
93670: LD_VAR 0 10
93674: PUSH
93675: LD_VAR 0 8
93679: PUSH
93680: LD_INT 1
93682: ARRAY
93683: PUSH
93684: LD_VAR 0 2
93688: PLUS
93689: PUSH
93690: LD_VAR 0 8
93694: PUSH
93695: LD_INT 2
93697: ARRAY
93698: PUSH
93699: LD_VAR 0 3
93703: PLUS
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: EMPTY
93710: LIST
93711: ADD
93712: ST_TO_ADDR
93713: GO 93662
93715: POP
93716: POP
// result = temp_list2 ;
93717: LD_ADDR_VAR 0 7
93721: PUSH
93722: LD_VAR 0 10
93726: ST_TO_ADDR
// end ;
93727: LD_VAR 0 7
93731: RET
// export function EnemyInRange ( unit , dist ) ; begin
93732: LD_INT 0
93734: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
93735: LD_ADDR_VAR 0 3
93739: PUSH
93740: LD_VAR 0 1
93744: PPUSH
93745: CALL_OW 255
93749: PPUSH
93750: LD_VAR 0 1
93754: PPUSH
93755: CALL_OW 250
93759: PPUSH
93760: LD_VAR 0 1
93764: PPUSH
93765: CALL_OW 251
93769: PPUSH
93770: LD_VAR 0 2
93774: PPUSH
93775: CALL 67128 0 4
93779: PUSH
93780: LD_INT 4
93782: ARRAY
93783: ST_TO_ADDR
// end ;
93784: LD_VAR 0 3
93788: RET
// export function PlayerSeeMe ( unit ) ; begin
93789: LD_INT 0
93791: PPUSH
// result := See ( your_side , unit ) ;
93792: LD_ADDR_VAR 0 2
93796: PUSH
93797: LD_OWVAR 2
93801: PPUSH
93802: LD_VAR 0 1
93806: PPUSH
93807: CALL_OW 292
93811: ST_TO_ADDR
// end ;
93812: LD_VAR 0 2
93816: RET
// export function ReverseDir ( unit ) ; begin
93817: LD_INT 0
93819: PPUSH
// if not unit then
93820: LD_VAR 0 1
93824: NOT
93825: IFFALSE 93829
// exit ;
93827: GO 93852
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
93829: LD_ADDR_VAR 0 2
93833: PUSH
93834: LD_VAR 0 1
93838: PPUSH
93839: CALL_OW 254
93843: PUSH
93844: LD_INT 3
93846: PLUS
93847: PUSH
93848: LD_INT 6
93850: MOD
93851: ST_TO_ADDR
// end ;
93852: LD_VAR 0 2
93856: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
93857: LD_INT 0
93859: PPUSH
93860: PPUSH
93861: PPUSH
93862: PPUSH
93863: PPUSH
// if not hexes then
93864: LD_VAR 0 2
93868: NOT
93869: IFFALSE 93873
// exit ;
93871: GO 94021
// dist := 9999 ;
93873: LD_ADDR_VAR 0 5
93877: PUSH
93878: LD_INT 9999
93880: ST_TO_ADDR
// for i = 1 to hexes do
93881: LD_ADDR_VAR 0 4
93885: PUSH
93886: DOUBLE
93887: LD_INT 1
93889: DEC
93890: ST_TO_ADDR
93891: LD_VAR 0 2
93895: PUSH
93896: FOR_TO
93897: IFFALSE 94009
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
93899: LD_VAR 0 1
93903: PPUSH
93904: LD_VAR 0 2
93908: PUSH
93909: LD_VAR 0 4
93913: ARRAY
93914: PUSH
93915: LD_INT 1
93917: ARRAY
93918: PPUSH
93919: LD_VAR 0 2
93923: PUSH
93924: LD_VAR 0 4
93928: ARRAY
93929: PUSH
93930: LD_INT 2
93932: ARRAY
93933: PPUSH
93934: CALL_OW 297
93938: PUSH
93939: LD_VAR 0 5
93943: LESS
93944: IFFALSE 94007
// begin hex := hexes [ i ] ;
93946: LD_ADDR_VAR 0 7
93950: PUSH
93951: LD_VAR 0 2
93955: PUSH
93956: LD_VAR 0 4
93960: ARRAY
93961: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
93962: LD_ADDR_VAR 0 5
93966: PUSH
93967: LD_VAR 0 1
93971: PPUSH
93972: LD_VAR 0 2
93976: PUSH
93977: LD_VAR 0 4
93981: ARRAY
93982: PUSH
93983: LD_INT 1
93985: ARRAY
93986: PPUSH
93987: LD_VAR 0 2
93991: PUSH
93992: LD_VAR 0 4
93996: ARRAY
93997: PUSH
93998: LD_INT 2
94000: ARRAY
94001: PPUSH
94002: CALL_OW 297
94006: ST_TO_ADDR
// end ; end ;
94007: GO 93896
94009: POP
94010: POP
// result := hex ;
94011: LD_ADDR_VAR 0 3
94015: PUSH
94016: LD_VAR 0 7
94020: ST_TO_ADDR
// end ;
94021: LD_VAR 0 3
94025: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
94026: LD_INT 0
94028: PPUSH
94029: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
94030: LD_VAR 0 1
94034: NOT
94035: PUSH
94036: LD_VAR 0 1
94040: PUSH
94041: LD_INT 21
94043: PUSH
94044: LD_INT 2
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 23
94053: PUSH
94054: LD_INT 2
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: PPUSH
94065: CALL_OW 69
94069: IN
94070: NOT
94071: OR
94072: IFFALSE 94076
// exit ;
94074: GO 94123
// for i = 1 to 3 do
94076: LD_ADDR_VAR 0 3
94080: PUSH
94081: DOUBLE
94082: LD_INT 1
94084: DEC
94085: ST_TO_ADDR
94086: LD_INT 3
94088: PUSH
94089: FOR_TO
94090: IFFALSE 94121
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
94092: LD_VAR 0 1
94096: PPUSH
94097: CALL_OW 250
94101: PPUSH
94102: LD_VAR 0 1
94106: PPUSH
94107: CALL_OW 251
94111: PPUSH
94112: LD_INT 1
94114: PPUSH
94115: CALL_OW 453
94119: GO 94089
94121: POP
94122: POP
// end ;
94123: LD_VAR 0 2
94127: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
94128: LD_INT 0
94130: PPUSH
94131: PPUSH
94132: PPUSH
94133: PPUSH
94134: PPUSH
94135: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
94136: LD_VAR 0 1
94140: NOT
94141: PUSH
94142: LD_VAR 0 2
94146: NOT
94147: OR
94148: PUSH
94149: LD_VAR 0 1
94153: PPUSH
94154: CALL_OW 314
94158: OR
94159: IFFALSE 94163
// exit ;
94161: GO 94604
// x := GetX ( enemy_unit ) ;
94163: LD_ADDR_VAR 0 7
94167: PUSH
94168: LD_VAR 0 2
94172: PPUSH
94173: CALL_OW 250
94177: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
94178: LD_ADDR_VAR 0 8
94182: PUSH
94183: LD_VAR 0 2
94187: PPUSH
94188: CALL_OW 251
94192: ST_TO_ADDR
// if not x or not y then
94193: LD_VAR 0 7
94197: NOT
94198: PUSH
94199: LD_VAR 0 8
94203: NOT
94204: OR
94205: IFFALSE 94209
// exit ;
94207: GO 94604
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
94209: LD_ADDR_VAR 0 6
94213: PUSH
94214: LD_VAR 0 7
94218: PPUSH
94219: LD_INT 0
94221: PPUSH
94222: LD_INT 4
94224: PPUSH
94225: CALL_OW 272
94229: PUSH
94230: LD_VAR 0 8
94234: PPUSH
94235: LD_INT 0
94237: PPUSH
94238: LD_INT 4
94240: PPUSH
94241: CALL_OW 273
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: PUSH
94250: LD_VAR 0 7
94254: PPUSH
94255: LD_INT 1
94257: PPUSH
94258: LD_INT 4
94260: PPUSH
94261: CALL_OW 272
94265: PUSH
94266: LD_VAR 0 8
94270: PPUSH
94271: LD_INT 1
94273: PPUSH
94274: LD_INT 4
94276: PPUSH
94277: CALL_OW 273
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: PUSH
94286: LD_VAR 0 7
94290: PPUSH
94291: LD_INT 2
94293: PPUSH
94294: LD_INT 4
94296: PPUSH
94297: CALL_OW 272
94301: PUSH
94302: LD_VAR 0 8
94306: PPUSH
94307: LD_INT 2
94309: PPUSH
94310: LD_INT 4
94312: PPUSH
94313: CALL_OW 273
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_VAR 0 7
94326: PPUSH
94327: LD_INT 3
94329: PPUSH
94330: LD_INT 4
94332: PPUSH
94333: CALL_OW 272
94337: PUSH
94338: LD_VAR 0 8
94342: PPUSH
94343: LD_INT 3
94345: PPUSH
94346: LD_INT 4
94348: PPUSH
94349: CALL_OW 273
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: PUSH
94358: LD_VAR 0 7
94362: PPUSH
94363: LD_INT 4
94365: PPUSH
94366: LD_INT 4
94368: PPUSH
94369: CALL_OW 272
94373: PUSH
94374: LD_VAR 0 8
94378: PPUSH
94379: LD_INT 4
94381: PPUSH
94382: LD_INT 4
94384: PPUSH
94385: CALL_OW 273
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: PUSH
94394: LD_VAR 0 7
94398: PPUSH
94399: LD_INT 5
94401: PPUSH
94402: LD_INT 4
94404: PPUSH
94405: CALL_OW 272
94409: PUSH
94410: LD_VAR 0 8
94414: PPUSH
94415: LD_INT 5
94417: PPUSH
94418: LD_INT 4
94420: PPUSH
94421: CALL_OW 273
94425: PUSH
94426: EMPTY
94427: LIST
94428: LIST
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: ST_TO_ADDR
// for i = tmp downto 1 do
94438: LD_ADDR_VAR 0 4
94442: PUSH
94443: DOUBLE
94444: LD_VAR 0 6
94448: INC
94449: ST_TO_ADDR
94450: LD_INT 1
94452: PUSH
94453: FOR_DOWNTO
94454: IFFALSE 94555
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
94456: LD_VAR 0 6
94460: PUSH
94461: LD_VAR 0 4
94465: ARRAY
94466: PUSH
94467: LD_INT 1
94469: ARRAY
94470: PPUSH
94471: LD_VAR 0 6
94475: PUSH
94476: LD_VAR 0 4
94480: ARRAY
94481: PUSH
94482: LD_INT 2
94484: ARRAY
94485: PPUSH
94486: CALL_OW 488
94490: NOT
94491: PUSH
94492: LD_VAR 0 6
94496: PUSH
94497: LD_VAR 0 4
94501: ARRAY
94502: PUSH
94503: LD_INT 1
94505: ARRAY
94506: PPUSH
94507: LD_VAR 0 6
94511: PUSH
94512: LD_VAR 0 4
94516: ARRAY
94517: PUSH
94518: LD_INT 2
94520: ARRAY
94521: PPUSH
94522: CALL_OW 428
94526: PUSH
94527: LD_INT 0
94529: NONEQUAL
94530: OR
94531: IFFALSE 94553
// tmp := Delete ( tmp , i ) ;
94533: LD_ADDR_VAR 0 6
94537: PUSH
94538: LD_VAR 0 6
94542: PPUSH
94543: LD_VAR 0 4
94547: PPUSH
94548: CALL_OW 3
94552: ST_TO_ADDR
94553: GO 94453
94555: POP
94556: POP
// j := GetClosestHex ( unit , tmp ) ;
94557: LD_ADDR_VAR 0 5
94561: PUSH
94562: LD_VAR 0 1
94566: PPUSH
94567: LD_VAR 0 6
94571: PPUSH
94572: CALL 93857 0 2
94576: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
94577: LD_VAR 0 1
94581: PPUSH
94582: LD_VAR 0 5
94586: PUSH
94587: LD_INT 1
94589: ARRAY
94590: PPUSH
94591: LD_VAR 0 5
94595: PUSH
94596: LD_INT 2
94598: ARRAY
94599: PPUSH
94600: CALL_OW 111
// end ;
94604: LD_VAR 0 3
94608: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
94609: LD_INT 0
94611: PPUSH
94612: PPUSH
94613: PPUSH
// uc_side = 0 ;
94614: LD_ADDR_OWVAR 20
94618: PUSH
94619: LD_INT 0
94621: ST_TO_ADDR
// uc_nation = 0 ;
94622: LD_ADDR_OWVAR 21
94626: PUSH
94627: LD_INT 0
94629: ST_TO_ADDR
// InitHc_All ( ) ;
94630: CALL_OW 584
// InitVc ;
94634: CALL_OW 20
// if mastodonts then
94638: LD_VAR 0 6
94642: IFFALSE 94709
// for i = 1 to mastodonts do
94644: LD_ADDR_VAR 0 11
94648: PUSH
94649: DOUBLE
94650: LD_INT 1
94652: DEC
94653: ST_TO_ADDR
94654: LD_VAR 0 6
94658: PUSH
94659: FOR_TO
94660: IFFALSE 94707
// begin vc_chassis := 31 ;
94662: LD_ADDR_OWVAR 37
94666: PUSH
94667: LD_INT 31
94669: ST_TO_ADDR
// vc_control := control_rider ;
94670: LD_ADDR_OWVAR 38
94674: PUSH
94675: LD_INT 4
94677: ST_TO_ADDR
// animal := CreateVehicle ;
94678: LD_ADDR_VAR 0 12
94682: PUSH
94683: CALL_OW 45
94687: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94688: LD_VAR 0 12
94692: PPUSH
94693: LD_VAR 0 8
94697: PPUSH
94698: LD_INT 0
94700: PPUSH
94701: CALL 96897 0 3
// end ;
94705: GO 94659
94707: POP
94708: POP
// if horses then
94709: LD_VAR 0 5
94713: IFFALSE 94780
// for i = 1 to horses do
94715: LD_ADDR_VAR 0 11
94719: PUSH
94720: DOUBLE
94721: LD_INT 1
94723: DEC
94724: ST_TO_ADDR
94725: LD_VAR 0 5
94729: PUSH
94730: FOR_TO
94731: IFFALSE 94778
// begin hc_class := 21 ;
94733: LD_ADDR_OWVAR 28
94737: PUSH
94738: LD_INT 21
94740: ST_TO_ADDR
// hc_gallery :=  ;
94741: LD_ADDR_OWVAR 33
94745: PUSH
94746: LD_STRING 
94748: ST_TO_ADDR
// animal := CreateHuman ;
94749: LD_ADDR_VAR 0 12
94753: PUSH
94754: CALL_OW 44
94758: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94759: LD_VAR 0 12
94763: PPUSH
94764: LD_VAR 0 8
94768: PPUSH
94769: LD_INT 0
94771: PPUSH
94772: CALL 96897 0 3
// end ;
94776: GO 94730
94778: POP
94779: POP
// if birds then
94780: LD_VAR 0 1
94784: IFFALSE 94851
// for i = 1 to birds do
94786: LD_ADDR_VAR 0 11
94790: PUSH
94791: DOUBLE
94792: LD_INT 1
94794: DEC
94795: ST_TO_ADDR
94796: LD_VAR 0 1
94800: PUSH
94801: FOR_TO
94802: IFFALSE 94849
// begin hc_class = 18 ;
94804: LD_ADDR_OWVAR 28
94808: PUSH
94809: LD_INT 18
94811: ST_TO_ADDR
// hc_gallery =  ;
94812: LD_ADDR_OWVAR 33
94816: PUSH
94817: LD_STRING 
94819: ST_TO_ADDR
// animal := CreateHuman ;
94820: LD_ADDR_VAR 0 12
94824: PUSH
94825: CALL_OW 44
94829: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94830: LD_VAR 0 12
94834: PPUSH
94835: LD_VAR 0 8
94839: PPUSH
94840: LD_INT 0
94842: PPUSH
94843: CALL 96897 0 3
// end ;
94847: GO 94801
94849: POP
94850: POP
// if tigers then
94851: LD_VAR 0 2
94855: IFFALSE 94939
// for i = 1 to tigers do
94857: LD_ADDR_VAR 0 11
94861: PUSH
94862: DOUBLE
94863: LD_INT 1
94865: DEC
94866: ST_TO_ADDR
94867: LD_VAR 0 2
94871: PUSH
94872: FOR_TO
94873: IFFALSE 94937
// begin hc_class = class_tiger ;
94875: LD_ADDR_OWVAR 28
94879: PUSH
94880: LD_INT 14
94882: ST_TO_ADDR
// hc_gallery =  ;
94883: LD_ADDR_OWVAR 33
94887: PUSH
94888: LD_STRING 
94890: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
94891: LD_ADDR_OWVAR 35
94895: PUSH
94896: LD_INT 7
94898: NEG
94899: PPUSH
94900: LD_INT 7
94902: PPUSH
94903: CALL_OW 12
94907: ST_TO_ADDR
// animal := CreateHuman ;
94908: LD_ADDR_VAR 0 12
94912: PUSH
94913: CALL_OW 44
94917: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94918: LD_VAR 0 12
94922: PPUSH
94923: LD_VAR 0 8
94927: PPUSH
94928: LD_INT 0
94930: PPUSH
94931: CALL 96897 0 3
// end ;
94935: GO 94872
94937: POP
94938: POP
// if apemans then
94939: LD_VAR 0 3
94943: IFFALSE 95066
// for i = 1 to apemans do
94945: LD_ADDR_VAR 0 11
94949: PUSH
94950: DOUBLE
94951: LD_INT 1
94953: DEC
94954: ST_TO_ADDR
94955: LD_VAR 0 3
94959: PUSH
94960: FOR_TO
94961: IFFALSE 95064
// begin hc_class = class_apeman ;
94963: LD_ADDR_OWVAR 28
94967: PUSH
94968: LD_INT 12
94970: ST_TO_ADDR
// hc_gallery =  ;
94971: LD_ADDR_OWVAR 33
94975: PUSH
94976: LD_STRING 
94978: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
94979: LD_ADDR_OWVAR 35
94983: PUSH
94984: LD_INT 2
94986: NEG
94987: PPUSH
94988: LD_INT 2
94990: PPUSH
94991: CALL_OW 12
94995: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
94996: LD_ADDR_OWVAR 31
95000: PUSH
95001: LD_INT 1
95003: PPUSH
95004: LD_INT 3
95006: PPUSH
95007: CALL_OW 12
95011: PUSH
95012: LD_INT 1
95014: PPUSH
95015: LD_INT 3
95017: PPUSH
95018: CALL_OW 12
95022: PUSH
95023: LD_INT 0
95025: PUSH
95026: LD_INT 0
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: ST_TO_ADDR
// animal := CreateHuman ;
95035: LD_ADDR_VAR 0 12
95039: PUSH
95040: CALL_OW 44
95044: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95045: LD_VAR 0 12
95049: PPUSH
95050: LD_VAR 0 8
95054: PPUSH
95055: LD_INT 0
95057: PPUSH
95058: CALL 96897 0 3
// end ;
95062: GO 94960
95064: POP
95065: POP
// if enchidnas then
95066: LD_VAR 0 4
95070: IFFALSE 95137
// for i = 1 to enchidnas do
95072: LD_ADDR_VAR 0 11
95076: PUSH
95077: DOUBLE
95078: LD_INT 1
95080: DEC
95081: ST_TO_ADDR
95082: LD_VAR 0 4
95086: PUSH
95087: FOR_TO
95088: IFFALSE 95135
// begin hc_class = 13 ;
95090: LD_ADDR_OWVAR 28
95094: PUSH
95095: LD_INT 13
95097: ST_TO_ADDR
// hc_gallery =  ;
95098: LD_ADDR_OWVAR 33
95102: PUSH
95103: LD_STRING 
95105: ST_TO_ADDR
// animal := CreateHuman ;
95106: LD_ADDR_VAR 0 12
95110: PUSH
95111: CALL_OW 44
95115: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95116: LD_VAR 0 12
95120: PPUSH
95121: LD_VAR 0 8
95125: PPUSH
95126: LD_INT 0
95128: PPUSH
95129: CALL 96897 0 3
// end ;
95133: GO 95087
95135: POP
95136: POP
// if fishes then
95137: LD_VAR 0 7
95141: IFFALSE 95208
// for i = 1 to fishes do
95143: LD_ADDR_VAR 0 11
95147: PUSH
95148: DOUBLE
95149: LD_INT 1
95151: DEC
95152: ST_TO_ADDR
95153: LD_VAR 0 7
95157: PUSH
95158: FOR_TO
95159: IFFALSE 95206
// begin hc_class = 20 ;
95161: LD_ADDR_OWVAR 28
95165: PUSH
95166: LD_INT 20
95168: ST_TO_ADDR
// hc_gallery =  ;
95169: LD_ADDR_OWVAR 33
95173: PUSH
95174: LD_STRING 
95176: ST_TO_ADDR
// animal := CreateHuman ;
95177: LD_ADDR_VAR 0 12
95181: PUSH
95182: CALL_OW 44
95186: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
95187: LD_VAR 0 12
95191: PPUSH
95192: LD_VAR 0 9
95196: PPUSH
95197: LD_INT 0
95199: PPUSH
95200: CALL 96897 0 3
// end ;
95204: GO 95158
95206: POP
95207: POP
// end ;
95208: LD_VAR 0 10
95212: RET
// export function WantHeal ( sci , unit ) ; begin
95213: LD_INT 0
95215: PPUSH
// if GetTaskList ( sci ) > 0 then
95216: LD_VAR 0 1
95220: PPUSH
95221: CALL_OW 437
95225: PUSH
95226: LD_INT 0
95228: GREATER
95229: IFFALSE 95299
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
95231: LD_VAR 0 1
95235: PPUSH
95236: CALL_OW 437
95240: PUSH
95241: LD_INT 1
95243: ARRAY
95244: PUSH
95245: LD_INT 1
95247: ARRAY
95248: PUSH
95249: LD_STRING l
95251: EQUAL
95252: PUSH
95253: LD_VAR 0 1
95257: PPUSH
95258: CALL_OW 437
95262: PUSH
95263: LD_INT 1
95265: ARRAY
95266: PUSH
95267: LD_INT 4
95269: ARRAY
95270: PUSH
95271: LD_VAR 0 2
95275: EQUAL
95276: AND
95277: IFFALSE 95289
// result := true else
95279: LD_ADDR_VAR 0 3
95283: PUSH
95284: LD_INT 1
95286: ST_TO_ADDR
95287: GO 95297
// result := false ;
95289: LD_ADDR_VAR 0 3
95293: PUSH
95294: LD_INT 0
95296: ST_TO_ADDR
// end else
95297: GO 95307
// result := false ;
95299: LD_ADDR_VAR 0 3
95303: PUSH
95304: LD_INT 0
95306: ST_TO_ADDR
// end ;
95307: LD_VAR 0 3
95311: RET
// export function HealTarget ( sci ) ; begin
95312: LD_INT 0
95314: PPUSH
// if not sci then
95315: LD_VAR 0 1
95319: NOT
95320: IFFALSE 95324
// exit ;
95322: GO 95389
// result := 0 ;
95324: LD_ADDR_VAR 0 2
95328: PUSH
95329: LD_INT 0
95331: ST_TO_ADDR
// if GetTaskList ( sci ) then
95332: LD_VAR 0 1
95336: PPUSH
95337: CALL_OW 437
95341: IFFALSE 95389
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
95343: LD_VAR 0 1
95347: PPUSH
95348: CALL_OW 437
95352: PUSH
95353: LD_INT 1
95355: ARRAY
95356: PUSH
95357: LD_INT 1
95359: ARRAY
95360: PUSH
95361: LD_STRING l
95363: EQUAL
95364: IFFALSE 95389
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
95366: LD_ADDR_VAR 0 2
95370: PUSH
95371: LD_VAR 0 1
95375: PPUSH
95376: CALL_OW 437
95380: PUSH
95381: LD_INT 1
95383: ARRAY
95384: PUSH
95385: LD_INT 4
95387: ARRAY
95388: ST_TO_ADDR
// end ;
95389: LD_VAR 0 2
95393: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
95394: LD_INT 0
95396: PPUSH
95397: PPUSH
95398: PPUSH
95399: PPUSH
// if not base_units then
95400: LD_VAR 0 1
95404: NOT
95405: IFFALSE 95409
// exit ;
95407: GO 95496
// result := false ;
95409: LD_ADDR_VAR 0 2
95413: PUSH
95414: LD_INT 0
95416: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
95417: LD_ADDR_VAR 0 5
95421: PUSH
95422: LD_VAR 0 1
95426: PPUSH
95427: LD_INT 21
95429: PUSH
95430: LD_INT 3
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: PPUSH
95437: CALL_OW 72
95441: ST_TO_ADDR
// if not tmp then
95442: LD_VAR 0 5
95446: NOT
95447: IFFALSE 95451
// exit ;
95449: GO 95496
// for i in tmp do
95451: LD_ADDR_VAR 0 3
95455: PUSH
95456: LD_VAR 0 5
95460: PUSH
95461: FOR_IN
95462: IFFALSE 95494
// begin result := EnemyInRange ( i , 22 ) ;
95464: LD_ADDR_VAR 0 2
95468: PUSH
95469: LD_VAR 0 3
95473: PPUSH
95474: LD_INT 22
95476: PPUSH
95477: CALL 93732 0 2
95481: ST_TO_ADDR
// if result then
95482: LD_VAR 0 2
95486: IFFALSE 95492
// exit ;
95488: POP
95489: POP
95490: GO 95496
// end ;
95492: GO 95461
95494: POP
95495: POP
// end ;
95496: LD_VAR 0 2
95500: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
95501: LD_INT 0
95503: PPUSH
95504: PPUSH
// if not units then
95505: LD_VAR 0 1
95509: NOT
95510: IFFALSE 95514
// exit ;
95512: GO 95584
// result := [ ] ;
95514: LD_ADDR_VAR 0 3
95518: PUSH
95519: EMPTY
95520: ST_TO_ADDR
// for i in units do
95521: LD_ADDR_VAR 0 4
95525: PUSH
95526: LD_VAR 0 1
95530: PUSH
95531: FOR_IN
95532: IFFALSE 95582
// if GetTag ( i ) = tag then
95534: LD_VAR 0 4
95538: PPUSH
95539: CALL_OW 110
95543: PUSH
95544: LD_VAR 0 2
95548: EQUAL
95549: IFFALSE 95580
// result := Replace ( result , result + 1 , i ) ;
95551: LD_ADDR_VAR 0 3
95555: PUSH
95556: LD_VAR 0 3
95560: PPUSH
95561: LD_VAR 0 3
95565: PUSH
95566: LD_INT 1
95568: PLUS
95569: PPUSH
95570: LD_VAR 0 4
95574: PPUSH
95575: CALL_OW 1
95579: ST_TO_ADDR
95580: GO 95531
95582: POP
95583: POP
// end ;
95584: LD_VAR 0 3
95588: RET
// export function IsDriver ( un ) ; begin
95589: LD_INT 0
95591: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
95592: LD_ADDR_VAR 0 2
95596: PUSH
95597: LD_VAR 0 1
95601: PUSH
95602: LD_INT 55
95604: PUSH
95605: EMPTY
95606: LIST
95607: PPUSH
95608: CALL_OW 69
95612: IN
95613: ST_TO_ADDR
// end ;
95614: LD_VAR 0 2
95618: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
95619: LD_INT 0
95621: PPUSH
95622: PPUSH
// list := [ ] ;
95623: LD_ADDR_VAR 0 5
95627: PUSH
95628: EMPTY
95629: ST_TO_ADDR
// case d of 0 :
95630: LD_VAR 0 3
95634: PUSH
95635: LD_INT 0
95637: DOUBLE
95638: EQUAL
95639: IFTRUE 95643
95641: GO 95776
95643: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
95644: LD_ADDR_VAR 0 5
95648: PUSH
95649: LD_VAR 0 1
95653: PUSH
95654: LD_INT 4
95656: MINUS
95657: PUSH
95658: LD_VAR 0 2
95662: PUSH
95663: LD_INT 4
95665: MINUS
95666: PUSH
95667: LD_INT 2
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: LIST
95674: PUSH
95675: LD_VAR 0 1
95679: PUSH
95680: LD_INT 3
95682: MINUS
95683: PUSH
95684: LD_VAR 0 2
95688: PUSH
95689: LD_INT 1
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: LIST
95696: PUSH
95697: LD_VAR 0 1
95701: PUSH
95702: LD_INT 4
95704: PLUS
95705: PUSH
95706: LD_VAR 0 2
95710: PUSH
95711: LD_INT 4
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: LIST
95718: PUSH
95719: LD_VAR 0 1
95723: PUSH
95724: LD_INT 3
95726: PLUS
95727: PUSH
95728: LD_VAR 0 2
95732: PUSH
95733: LD_INT 3
95735: PLUS
95736: PUSH
95737: LD_INT 5
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: LIST
95744: PUSH
95745: LD_VAR 0 1
95749: PUSH
95750: LD_VAR 0 2
95754: PUSH
95755: LD_INT 4
95757: PLUS
95758: PUSH
95759: LD_INT 0
95761: PUSH
95762: EMPTY
95763: LIST
95764: LIST
95765: LIST
95766: PUSH
95767: EMPTY
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: ST_TO_ADDR
// end ; 1 :
95774: GO 96474
95776: LD_INT 1
95778: DOUBLE
95779: EQUAL
95780: IFTRUE 95784
95782: GO 95917
95784: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
95785: LD_ADDR_VAR 0 5
95789: PUSH
95790: LD_VAR 0 1
95794: PUSH
95795: LD_VAR 0 2
95799: PUSH
95800: LD_INT 4
95802: MINUS
95803: PUSH
95804: LD_INT 3
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: LIST
95811: PUSH
95812: LD_VAR 0 1
95816: PUSH
95817: LD_INT 3
95819: MINUS
95820: PUSH
95821: LD_VAR 0 2
95825: PUSH
95826: LD_INT 3
95828: MINUS
95829: PUSH
95830: LD_INT 2
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: LIST
95837: PUSH
95838: LD_VAR 0 1
95842: PUSH
95843: LD_INT 4
95845: MINUS
95846: PUSH
95847: LD_VAR 0 2
95851: PUSH
95852: LD_INT 1
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: LIST
95859: PUSH
95860: LD_VAR 0 1
95864: PUSH
95865: LD_VAR 0 2
95869: PUSH
95870: LD_INT 3
95872: PLUS
95873: PUSH
95874: LD_INT 0
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: LIST
95881: PUSH
95882: LD_VAR 0 1
95886: PUSH
95887: LD_INT 4
95889: PLUS
95890: PUSH
95891: LD_VAR 0 2
95895: PUSH
95896: LD_INT 4
95898: PLUS
95899: PUSH
95900: LD_INT 5
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: LIST
95907: PUSH
95908: EMPTY
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: ST_TO_ADDR
// end ; 2 :
95915: GO 96474
95917: LD_INT 2
95919: DOUBLE
95920: EQUAL
95921: IFTRUE 95925
95923: GO 96054
95925: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
95926: LD_ADDR_VAR 0 5
95930: PUSH
95931: LD_VAR 0 1
95935: PUSH
95936: LD_VAR 0 2
95940: PUSH
95941: LD_INT 3
95943: MINUS
95944: PUSH
95945: LD_INT 3
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: LIST
95952: PUSH
95953: LD_VAR 0 1
95957: PUSH
95958: LD_INT 4
95960: PLUS
95961: PUSH
95962: LD_VAR 0 2
95966: PUSH
95967: LD_INT 4
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: LIST
95974: PUSH
95975: LD_VAR 0 1
95979: PUSH
95980: LD_VAR 0 2
95984: PUSH
95985: LD_INT 4
95987: PLUS
95988: PUSH
95989: LD_INT 0
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: LIST
95996: PUSH
95997: LD_VAR 0 1
96001: PUSH
96002: LD_INT 3
96004: MINUS
96005: PUSH
96006: LD_VAR 0 2
96010: PUSH
96011: LD_INT 1
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: LIST
96018: PUSH
96019: LD_VAR 0 1
96023: PUSH
96024: LD_INT 4
96026: MINUS
96027: PUSH
96028: LD_VAR 0 2
96032: PUSH
96033: LD_INT 4
96035: MINUS
96036: PUSH
96037: LD_INT 2
96039: PUSH
96040: EMPTY
96041: LIST
96042: LIST
96043: LIST
96044: PUSH
96045: EMPTY
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: ST_TO_ADDR
// end ; 3 :
96052: GO 96474
96054: LD_INT 3
96056: DOUBLE
96057: EQUAL
96058: IFTRUE 96062
96060: GO 96195
96062: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
96063: LD_ADDR_VAR 0 5
96067: PUSH
96068: LD_VAR 0 1
96072: PUSH
96073: LD_INT 3
96075: PLUS
96076: PUSH
96077: LD_VAR 0 2
96081: PUSH
96082: LD_INT 4
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: LIST
96089: PUSH
96090: LD_VAR 0 1
96094: PUSH
96095: LD_INT 4
96097: PLUS
96098: PUSH
96099: LD_VAR 0 2
96103: PUSH
96104: LD_INT 4
96106: PLUS
96107: PUSH
96108: LD_INT 5
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: LIST
96115: PUSH
96116: LD_VAR 0 1
96120: PUSH
96121: LD_INT 4
96123: MINUS
96124: PUSH
96125: LD_VAR 0 2
96129: PUSH
96130: LD_INT 1
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: LIST
96137: PUSH
96138: LD_VAR 0 1
96142: PUSH
96143: LD_VAR 0 2
96147: PUSH
96148: LD_INT 4
96150: MINUS
96151: PUSH
96152: LD_INT 3
96154: PUSH
96155: EMPTY
96156: LIST
96157: LIST
96158: LIST
96159: PUSH
96160: LD_VAR 0 1
96164: PUSH
96165: LD_INT 3
96167: MINUS
96168: PUSH
96169: LD_VAR 0 2
96173: PUSH
96174: LD_INT 3
96176: MINUS
96177: PUSH
96178: LD_INT 2
96180: PUSH
96181: EMPTY
96182: LIST
96183: LIST
96184: LIST
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: ST_TO_ADDR
// end ; 4 :
96193: GO 96474
96195: LD_INT 4
96197: DOUBLE
96198: EQUAL
96199: IFTRUE 96203
96201: GO 96336
96203: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
96204: LD_ADDR_VAR 0 5
96208: PUSH
96209: LD_VAR 0 1
96213: PUSH
96214: LD_VAR 0 2
96218: PUSH
96219: LD_INT 4
96221: PLUS
96222: PUSH
96223: LD_INT 0
96225: PUSH
96226: EMPTY
96227: LIST
96228: LIST
96229: LIST
96230: PUSH
96231: LD_VAR 0 1
96235: PUSH
96236: LD_INT 3
96238: PLUS
96239: PUSH
96240: LD_VAR 0 2
96244: PUSH
96245: LD_INT 3
96247: PLUS
96248: PUSH
96249: LD_INT 5
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: LIST
96256: PUSH
96257: LD_VAR 0 1
96261: PUSH
96262: LD_INT 4
96264: PLUS
96265: PUSH
96266: LD_VAR 0 2
96270: PUSH
96271: LD_INT 4
96273: PUSH
96274: EMPTY
96275: LIST
96276: LIST
96277: LIST
96278: PUSH
96279: LD_VAR 0 1
96283: PUSH
96284: LD_VAR 0 2
96288: PUSH
96289: LD_INT 3
96291: MINUS
96292: PUSH
96293: LD_INT 3
96295: PUSH
96296: EMPTY
96297: LIST
96298: LIST
96299: LIST
96300: PUSH
96301: LD_VAR 0 1
96305: PUSH
96306: LD_INT 4
96308: MINUS
96309: PUSH
96310: LD_VAR 0 2
96314: PUSH
96315: LD_INT 4
96317: MINUS
96318: PUSH
96319: LD_INT 2
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: LIST
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: ST_TO_ADDR
// end ; 5 :
96334: GO 96474
96336: LD_INT 5
96338: DOUBLE
96339: EQUAL
96340: IFTRUE 96344
96342: GO 96473
96344: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
96345: LD_ADDR_VAR 0 5
96349: PUSH
96350: LD_VAR 0 1
96354: PUSH
96355: LD_INT 4
96357: MINUS
96358: PUSH
96359: LD_VAR 0 2
96363: PUSH
96364: LD_INT 1
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: LIST
96371: PUSH
96372: LD_VAR 0 1
96376: PUSH
96377: LD_VAR 0 2
96381: PUSH
96382: LD_INT 4
96384: MINUS
96385: PUSH
96386: LD_INT 3
96388: PUSH
96389: EMPTY
96390: LIST
96391: LIST
96392: LIST
96393: PUSH
96394: LD_VAR 0 1
96398: PUSH
96399: LD_INT 4
96401: PLUS
96402: PUSH
96403: LD_VAR 0 2
96407: PUSH
96408: LD_INT 4
96410: PLUS
96411: PUSH
96412: LD_INT 5
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: LIST
96419: PUSH
96420: LD_VAR 0 1
96424: PUSH
96425: LD_INT 3
96427: PLUS
96428: PUSH
96429: LD_VAR 0 2
96433: PUSH
96434: LD_INT 4
96436: PUSH
96437: EMPTY
96438: LIST
96439: LIST
96440: LIST
96441: PUSH
96442: LD_VAR 0 1
96446: PUSH
96447: LD_VAR 0 2
96451: PUSH
96452: LD_INT 3
96454: PLUS
96455: PUSH
96456: LD_INT 0
96458: PUSH
96459: EMPTY
96460: LIST
96461: LIST
96462: LIST
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: ST_TO_ADDR
// end ; end ;
96471: GO 96474
96473: POP
// result := list ;
96474: LD_ADDR_VAR 0 4
96478: PUSH
96479: LD_VAR 0 5
96483: ST_TO_ADDR
// end ;
96484: LD_VAR 0 4
96488: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
96489: LD_INT 0
96491: PPUSH
96492: PPUSH
96493: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
96494: LD_VAR 0 1
96498: NOT
96499: PUSH
96500: LD_VAR 0 2
96504: PUSH
96505: LD_INT 1
96507: PUSH
96508: LD_INT 2
96510: PUSH
96511: LD_INT 3
96513: PUSH
96514: LD_INT 4
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: IN
96523: NOT
96524: OR
96525: IFFALSE 96529
// exit ;
96527: GO 96621
// tmp := [ ] ;
96529: LD_ADDR_VAR 0 5
96533: PUSH
96534: EMPTY
96535: ST_TO_ADDR
// for i in units do
96536: LD_ADDR_VAR 0 4
96540: PUSH
96541: LD_VAR 0 1
96545: PUSH
96546: FOR_IN
96547: IFFALSE 96590
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
96549: LD_ADDR_VAR 0 5
96553: PUSH
96554: LD_VAR 0 5
96558: PPUSH
96559: LD_VAR 0 5
96563: PUSH
96564: LD_INT 1
96566: PLUS
96567: PPUSH
96568: LD_VAR 0 4
96572: PPUSH
96573: LD_VAR 0 2
96577: PPUSH
96578: CALL_OW 259
96582: PPUSH
96583: CALL_OW 2
96587: ST_TO_ADDR
96588: GO 96546
96590: POP
96591: POP
// if not tmp then
96592: LD_VAR 0 5
96596: NOT
96597: IFFALSE 96601
// exit ;
96599: GO 96621
// result := SortListByListDesc ( units , tmp ) ;
96601: LD_ADDR_VAR 0 3
96605: PUSH
96606: LD_VAR 0 1
96610: PPUSH
96611: LD_VAR 0 5
96615: PPUSH
96616: CALL_OW 77
96620: ST_TO_ADDR
// end ;
96621: LD_VAR 0 3
96625: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
96626: LD_INT 0
96628: PPUSH
96629: PPUSH
96630: PPUSH
// result := false ;
96631: LD_ADDR_VAR 0 3
96635: PUSH
96636: LD_INT 0
96638: ST_TO_ADDR
// x := GetX ( building ) ;
96639: LD_ADDR_VAR 0 4
96643: PUSH
96644: LD_VAR 0 2
96648: PPUSH
96649: CALL_OW 250
96653: ST_TO_ADDR
// y := GetY ( building ) ;
96654: LD_ADDR_VAR 0 5
96658: PUSH
96659: LD_VAR 0 2
96663: PPUSH
96664: CALL_OW 251
96668: ST_TO_ADDR
// if not building or not x or not y then
96669: LD_VAR 0 2
96673: NOT
96674: PUSH
96675: LD_VAR 0 4
96679: NOT
96680: OR
96681: PUSH
96682: LD_VAR 0 5
96686: NOT
96687: OR
96688: IFFALSE 96692
// exit ;
96690: GO 96784
// if GetTaskList ( unit ) then
96692: LD_VAR 0 1
96696: PPUSH
96697: CALL_OW 437
96701: IFFALSE 96784
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
96703: LD_STRING e
96705: PUSH
96706: LD_VAR 0 1
96710: PPUSH
96711: CALL_OW 437
96715: PUSH
96716: LD_INT 1
96718: ARRAY
96719: PUSH
96720: LD_INT 1
96722: ARRAY
96723: EQUAL
96724: PUSH
96725: LD_VAR 0 4
96729: PUSH
96730: LD_VAR 0 1
96734: PPUSH
96735: CALL_OW 437
96739: PUSH
96740: LD_INT 1
96742: ARRAY
96743: PUSH
96744: LD_INT 2
96746: ARRAY
96747: EQUAL
96748: AND
96749: PUSH
96750: LD_VAR 0 5
96754: PUSH
96755: LD_VAR 0 1
96759: PPUSH
96760: CALL_OW 437
96764: PUSH
96765: LD_INT 1
96767: ARRAY
96768: PUSH
96769: LD_INT 3
96771: ARRAY
96772: EQUAL
96773: AND
96774: IFFALSE 96784
// result := true end ;
96776: LD_ADDR_VAR 0 3
96780: PUSH
96781: LD_INT 1
96783: ST_TO_ADDR
// end ;
96784: LD_VAR 0 3
96788: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
96789: LD_INT 0
96791: PPUSH
// result := false ;
96792: LD_ADDR_VAR 0 4
96796: PUSH
96797: LD_INT 0
96799: ST_TO_ADDR
// if GetTaskList ( unit ) then
96800: LD_VAR 0 1
96804: PPUSH
96805: CALL_OW 437
96809: IFFALSE 96892
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
96811: LD_STRING M
96813: PUSH
96814: LD_VAR 0 1
96818: PPUSH
96819: CALL_OW 437
96823: PUSH
96824: LD_INT 1
96826: ARRAY
96827: PUSH
96828: LD_INT 1
96830: ARRAY
96831: EQUAL
96832: PUSH
96833: LD_VAR 0 2
96837: PUSH
96838: LD_VAR 0 1
96842: PPUSH
96843: CALL_OW 437
96847: PUSH
96848: LD_INT 1
96850: ARRAY
96851: PUSH
96852: LD_INT 2
96854: ARRAY
96855: EQUAL
96856: AND
96857: PUSH
96858: LD_VAR 0 3
96862: PUSH
96863: LD_VAR 0 1
96867: PPUSH
96868: CALL_OW 437
96872: PUSH
96873: LD_INT 1
96875: ARRAY
96876: PUSH
96877: LD_INT 3
96879: ARRAY
96880: EQUAL
96881: AND
96882: IFFALSE 96892
// result := true ;
96884: LD_ADDR_VAR 0 4
96888: PUSH
96889: LD_INT 1
96891: ST_TO_ADDR
// end ; end ;
96892: LD_VAR 0 4
96896: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
96897: LD_INT 0
96899: PPUSH
96900: PPUSH
96901: PPUSH
96902: PPUSH
// if not unit or not area then
96903: LD_VAR 0 1
96907: NOT
96908: PUSH
96909: LD_VAR 0 2
96913: NOT
96914: OR
96915: IFFALSE 96919
// exit ;
96917: GO 97083
// tmp := AreaToList ( area , i ) ;
96919: LD_ADDR_VAR 0 6
96923: PUSH
96924: LD_VAR 0 2
96928: PPUSH
96929: LD_VAR 0 5
96933: PPUSH
96934: CALL_OW 517
96938: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
96939: LD_ADDR_VAR 0 5
96943: PUSH
96944: DOUBLE
96945: LD_INT 1
96947: DEC
96948: ST_TO_ADDR
96949: LD_VAR 0 6
96953: PUSH
96954: LD_INT 1
96956: ARRAY
96957: PUSH
96958: FOR_TO
96959: IFFALSE 97081
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
96961: LD_ADDR_VAR 0 7
96965: PUSH
96966: LD_VAR 0 6
96970: PUSH
96971: LD_INT 1
96973: ARRAY
96974: PUSH
96975: LD_VAR 0 5
96979: ARRAY
96980: PUSH
96981: LD_VAR 0 6
96985: PUSH
96986: LD_INT 2
96988: ARRAY
96989: PUSH
96990: LD_VAR 0 5
96994: ARRAY
96995: PUSH
96996: EMPTY
96997: LIST
96998: LIST
96999: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
97000: LD_VAR 0 7
97004: PUSH
97005: LD_INT 1
97007: ARRAY
97008: PPUSH
97009: LD_VAR 0 7
97013: PUSH
97014: LD_INT 2
97016: ARRAY
97017: PPUSH
97018: CALL_OW 428
97022: PUSH
97023: LD_INT 0
97025: EQUAL
97026: IFFALSE 97079
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
97028: LD_VAR 0 1
97032: PPUSH
97033: LD_VAR 0 7
97037: PUSH
97038: LD_INT 1
97040: ARRAY
97041: PPUSH
97042: LD_VAR 0 7
97046: PUSH
97047: LD_INT 2
97049: ARRAY
97050: PPUSH
97051: LD_VAR 0 3
97055: PPUSH
97056: CALL_OW 48
// result := IsPlaced ( unit ) ;
97060: LD_ADDR_VAR 0 4
97064: PUSH
97065: LD_VAR 0 1
97069: PPUSH
97070: CALL_OW 305
97074: ST_TO_ADDR
// exit ;
97075: POP
97076: POP
97077: GO 97083
// end ; end ;
97079: GO 96958
97081: POP
97082: POP
// end ;
97083: LD_VAR 0 4
97087: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
97088: LD_INT 0
97090: PPUSH
97091: PPUSH
97092: PPUSH
// if not side or side > 8 then
97093: LD_VAR 0 1
97097: NOT
97098: PUSH
97099: LD_VAR 0 1
97103: PUSH
97104: LD_INT 8
97106: GREATER
97107: OR
97108: IFFALSE 97112
// exit ;
97110: GO 97299
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
97112: LD_ADDR_VAR 0 4
97116: PUSH
97117: LD_INT 22
97119: PUSH
97120: LD_VAR 0 1
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 21
97131: PUSH
97132: LD_INT 3
97134: PUSH
97135: EMPTY
97136: LIST
97137: LIST
97138: PUSH
97139: EMPTY
97140: LIST
97141: LIST
97142: PPUSH
97143: CALL_OW 69
97147: ST_TO_ADDR
// if not tmp then
97148: LD_VAR 0 4
97152: NOT
97153: IFFALSE 97157
// exit ;
97155: GO 97299
// enable_addtolog := true ;
97157: LD_ADDR_OWVAR 81
97161: PUSH
97162: LD_INT 1
97164: ST_TO_ADDR
// AddToLog ( [ ) ;
97165: LD_STRING [
97167: PPUSH
97168: CALL_OW 561
// for i in tmp do
97172: LD_ADDR_VAR 0 3
97176: PUSH
97177: LD_VAR 0 4
97181: PUSH
97182: FOR_IN
97183: IFFALSE 97290
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
97185: LD_STRING [
97187: PUSH
97188: LD_VAR 0 3
97192: PPUSH
97193: CALL_OW 266
97197: STR
97198: PUSH
97199: LD_STRING , 
97201: STR
97202: PUSH
97203: LD_VAR 0 3
97207: PPUSH
97208: CALL_OW 250
97212: STR
97213: PUSH
97214: LD_STRING , 
97216: STR
97217: PUSH
97218: LD_VAR 0 3
97222: PPUSH
97223: CALL_OW 251
97227: STR
97228: PUSH
97229: LD_STRING , 
97231: STR
97232: PUSH
97233: LD_VAR 0 3
97237: PPUSH
97238: CALL_OW 254
97242: STR
97243: PUSH
97244: LD_STRING , 
97246: STR
97247: PUSH
97248: LD_VAR 0 3
97252: PPUSH
97253: LD_INT 1
97255: PPUSH
97256: CALL_OW 268
97260: STR
97261: PUSH
97262: LD_STRING , 
97264: STR
97265: PUSH
97266: LD_VAR 0 3
97270: PPUSH
97271: LD_INT 2
97273: PPUSH
97274: CALL_OW 268
97278: STR
97279: PUSH
97280: LD_STRING ],
97282: STR
97283: PPUSH
97284: CALL_OW 561
// end ;
97288: GO 97182
97290: POP
97291: POP
// AddToLog ( ]; ) ;
97292: LD_STRING ];
97294: PPUSH
97295: CALL_OW 561
// end ;
97299: LD_VAR 0 2
97303: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
97304: LD_INT 0
97306: PPUSH
97307: PPUSH
97308: PPUSH
97309: PPUSH
97310: PPUSH
// if not area or not rate or not max then
97311: LD_VAR 0 1
97315: NOT
97316: PUSH
97317: LD_VAR 0 2
97321: NOT
97322: OR
97323: PUSH
97324: LD_VAR 0 4
97328: NOT
97329: OR
97330: IFFALSE 97334
// exit ;
97332: GO 97526
// while 1 do
97334: LD_INT 1
97336: IFFALSE 97526
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
97338: LD_ADDR_VAR 0 9
97342: PUSH
97343: LD_VAR 0 1
97347: PPUSH
97348: LD_INT 1
97350: PPUSH
97351: CALL_OW 287
97355: PUSH
97356: LD_INT 10
97358: MUL
97359: ST_TO_ADDR
// r := rate / 10 ;
97360: LD_ADDR_VAR 0 7
97364: PUSH
97365: LD_VAR 0 2
97369: PUSH
97370: LD_INT 10
97372: DIVREAL
97373: ST_TO_ADDR
// time := 1 1$00 ;
97374: LD_ADDR_VAR 0 8
97378: PUSH
97379: LD_INT 2100
97381: ST_TO_ADDR
// if amount < min then
97382: LD_VAR 0 9
97386: PUSH
97387: LD_VAR 0 3
97391: LESS
97392: IFFALSE 97410
// r := r * 2 else
97394: LD_ADDR_VAR 0 7
97398: PUSH
97399: LD_VAR 0 7
97403: PUSH
97404: LD_INT 2
97406: MUL
97407: ST_TO_ADDR
97408: GO 97436
// if amount > max then
97410: LD_VAR 0 9
97414: PUSH
97415: LD_VAR 0 4
97419: GREATER
97420: IFFALSE 97436
// r := r / 2 ;
97422: LD_ADDR_VAR 0 7
97426: PUSH
97427: LD_VAR 0 7
97431: PUSH
97432: LD_INT 2
97434: DIVREAL
97435: ST_TO_ADDR
// time := time / r ;
97436: LD_ADDR_VAR 0 8
97440: PUSH
97441: LD_VAR 0 8
97445: PUSH
97446: LD_VAR 0 7
97450: DIVREAL
97451: ST_TO_ADDR
// if time < 0 then
97452: LD_VAR 0 8
97456: PUSH
97457: LD_INT 0
97459: LESS
97460: IFFALSE 97477
// time := time * - 1 ;
97462: LD_ADDR_VAR 0 8
97466: PUSH
97467: LD_VAR 0 8
97471: PUSH
97472: LD_INT 1
97474: NEG
97475: MUL
97476: ST_TO_ADDR
// wait ( time ) ;
97477: LD_VAR 0 8
97481: PPUSH
97482: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
97486: LD_INT 35
97488: PPUSH
97489: LD_INT 875
97491: PPUSH
97492: CALL_OW 12
97496: PPUSH
97497: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
97501: LD_INT 1
97503: PPUSH
97504: LD_INT 5
97506: PPUSH
97507: CALL_OW 12
97511: PPUSH
97512: LD_VAR 0 1
97516: PPUSH
97517: LD_INT 1
97519: PPUSH
97520: CALL_OW 55
// end ;
97524: GO 97334
// end ;
97526: LD_VAR 0 5
97530: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
97531: LD_INT 0
97533: PPUSH
97534: PPUSH
97535: PPUSH
97536: PPUSH
97537: PPUSH
97538: PPUSH
97539: PPUSH
97540: PPUSH
// if not turrets or not factories then
97541: LD_VAR 0 1
97545: NOT
97546: PUSH
97547: LD_VAR 0 2
97551: NOT
97552: OR
97553: IFFALSE 97557
// exit ;
97555: GO 97864
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
97557: LD_ADDR_VAR 0 10
97561: PUSH
97562: LD_INT 5
97564: PUSH
97565: LD_INT 6
97567: PUSH
97568: EMPTY
97569: LIST
97570: LIST
97571: PUSH
97572: LD_INT 2
97574: PUSH
97575: LD_INT 4
97577: PUSH
97578: EMPTY
97579: LIST
97580: LIST
97581: PUSH
97582: LD_INT 3
97584: PUSH
97585: LD_INT 5
97587: PUSH
97588: EMPTY
97589: LIST
97590: LIST
97591: PUSH
97592: EMPTY
97593: LIST
97594: LIST
97595: LIST
97596: PUSH
97597: LD_INT 24
97599: PUSH
97600: LD_INT 25
97602: PUSH
97603: EMPTY
97604: LIST
97605: LIST
97606: PUSH
97607: LD_INT 23
97609: PUSH
97610: LD_INT 27
97612: PUSH
97613: EMPTY
97614: LIST
97615: LIST
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: PUSH
97621: LD_INT 42
97623: PUSH
97624: LD_INT 43
97626: PUSH
97627: EMPTY
97628: LIST
97629: LIST
97630: PUSH
97631: LD_INT 44
97633: PUSH
97634: LD_INT 46
97636: PUSH
97637: EMPTY
97638: LIST
97639: LIST
97640: PUSH
97641: LD_INT 45
97643: PUSH
97644: LD_INT 47
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: PUSH
97651: EMPTY
97652: LIST
97653: LIST
97654: LIST
97655: PUSH
97656: EMPTY
97657: LIST
97658: LIST
97659: LIST
97660: ST_TO_ADDR
// result := [ ] ;
97661: LD_ADDR_VAR 0 3
97665: PUSH
97666: EMPTY
97667: ST_TO_ADDR
// for i in turrets do
97668: LD_ADDR_VAR 0 4
97672: PUSH
97673: LD_VAR 0 1
97677: PUSH
97678: FOR_IN
97679: IFFALSE 97862
// begin nat := GetNation ( i ) ;
97681: LD_ADDR_VAR 0 7
97685: PUSH
97686: LD_VAR 0 4
97690: PPUSH
97691: CALL_OW 248
97695: ST_TO_ADDR
// weapon := 0 ;
97696: LD_ADDR_VAR 0 8
97700: PUSH
97701: LD_INT 0
97703: ST_TO_ADDR
// if not nat then
97704: LD_VAR 0 7
97708: NOT
97709: IFFALSE 97713
// continue ;
97711: GO 97678
// for j in list [ nat ] do
97713: LD_ADDR_VAR 0 5
97717: PUSH
97718: LD_VAR 0 10
97722: PUSH
97723: LD_VAR 0 7
97727: ARRAY
97728: PUSH
97729: FOR_IN
97730: IFFALSE 97771
// if GetBWeapon ( i ) = j [ 1 ] then
97732: LD_VAR 0 4
97736: PPUSH
97737: CALL_OW 269
97741: PUSH
97742: LD_VAR 0 5
97746: PUSH
97747: LD_INT 1
97749: ARRAY
97750: EQUAL
97751: IFFALSE 97769
// begin weapon := j [ 2 ] ;
97753: LD_ADDR_VAR 0 8
97757: PUSH
97758: LD_VAR 0 5
97762: PUSH
97763: LD_INT 2
97765: ARRAY
97766: ST_TO_ADDR
// break ;
97767: GO 97771
// end ;
97769: GO 97729
97771: POP
97772: POP
// if not weapon then
97773: LD_VAR 0 8
97777: NOT
97778: IFFALSE 97782
// continue ;
97780: GO 97678
// for k in factories do
97782: LD_ADDR_VAR 0 6
97786: PUSH
97787: LD_VAR 0 2
97791: PUSH
97792: FOR_IN
97793: IFFALSE 97858
// begin weapons := AvailableWeaponList ( k ) ;
97795: LD_ADDR_VAR 0 9
97799: PUSH
97800: LD_VAR 0 6
97804: PPUSH
97805: CALL_OW 478
97809: ST_TO_ADDR
// if not weapons then
97810: LD_VAR 0 9
97814: NOT
97815: IFFALSE 97819
// continue ;
97817: GO 97792
// if weapon in weapons then
97819: LD_VAR 0 8
97823: PUSH
97824: LD_VAR 0 9
97828: IN
97829: IFFALSE 97856
// begin result := [ i , weapon ] ;
97831: LD_ADDR_VAR 0 3
97835: PUSH
97836: LD_VAR 0 4
97840: PUSH
97841: LD_VAR 0 8
97845: PUSH
97846: EMPTY
97847: LIST
97848: LIST
97849: ST_TO_ADDR
// exit ;
97850: POP
97851: POP
97852: POP
97853: POP
97854: GO 97864
// end ; end ;
97856: GO 97792
97858: POP
97859: POP
// end ;
97860: GO 97678
97862: POP
97863: POP
// end ;
97864: LD_VAR 0 3
97868: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
97869: LD_INT 0
97871: PPUSH
// if not side or side > 8 then
97872: LD_VAR 0 3
97876: NOT
97877: PUSH
97878: LD_VAR 0 3
97882: PUSH
97883: LD_INT 8
97885: GREATER
97886: OR
97887: IFFALSE 97891
// exit ;
97889: GO 97950
// if not range then
97891: LD_VAR 0 4
97895: NOT
97896: IFFALSE 97907
// range := - 12 ;
97898: LD_ADDR_VAR 0 4
97902: PUSH
97903: LD_INT 12
97905: NEG
97906: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
97907: LD_VAR 0 1
97911: PPUSH
97912: LD_VAR 0 2
97916: PPUSH
97917: LD_VAR 0 3
97921: PPUSH
97922: LD_VAR 0 4
97926: PPUSH
97927: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
97931: LD_VAR 0 1
97935: PPUSH
97936: LD_VAR 0 2
97940: PPUSH
97941: LD_VAR 0 3
97945: PPUSH
97946: CALL_OW 331
// end ;
97950: LD_VAR 0 5
97954: RET
// export function Video ( mode ) ; begin
97955: LD_INT 0
97957: PPUSH
// ingame_video = mode ;
97958: LD_ADDR_OWVAR 52
97962: PUSH
97963: LD_VAR 0 1
97967: ST_TO_ADDR
// interface_hidden = mode ;
97968: LD_ADDR_OWVAR 54
97972: PUSH
97973: LD_VAR 0 1
97977: ST_TO_ADDR
// end ;
97978: LD_VAR 0 2
97982: RET
// export function Join ( array , element ) ; begin
97983: LD_INT 0
97985: PPUSH
// result := Replace ( array , array + 1 , element ) ;
97986: LD_ADDR_VAR 0 3
97990: PUSH
97991: LD_VAR 0 1
97995: PPUSH
97996: LD_VAR 0 1
98000: PUSH
98001: LD_INT 1
98003: PLUS
98004: PPUSH
98005: LD_VAR 0 2
98009: PPUSH
98010: CALL_OW 1
98014: ST_TO_ADDR
// end ;
98015: LD_VAR 0 3
98019: RET
// export function JoinUnion ( array , element ) ; begin
98020: LD_INT 0
98022: PPUSH
// result := array union element ;
98023: LD_ADDR_VAR 0 3
98027: PUSH
98028: LD_VAR 0 1
98032: PUSH
98033: LD_VAR 0 2
98037: UNION
98038: ST_TO_ADDR
// end ;
98039: LD_VAR 0 3
98043: RET
// export function GetBehemoths ( side ) ; begin
98044: LD_INT 0
98046: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
98047: LD_ADDR_VAR 0 2
98051: PUSH
98052: LD_INT 22
98054: PUSH
98055: LD_VAR 0 1
98059: PUSH
98060: EMPTY
98061: LIST
98062: LIST
98063: PUSH
98064: LD_INT 31
98066: PUSH
98067: LD_INT 25
98069: PUSH
98070: EMPTY
98071: LIST
98072: LIST
98073: PUSH
98074: EMPTY
98075: LIST
98076: LIST
98077: PPUSH
98078: CALL_OW 69
98082: ST_TO_ADDR
// end ;
98083: LD_VAR 0 2
98087: RET
// export function Shuffle ( array ) ; var i , index ; begin
98088: LD_INT 0
98090: PPUSH
98091: PPUSH
98092: PPUSH
// result := [ ] ;
98093: LD_ADDR_VAR 0 2
98097: PUSH
98098: EMPTY
98099: ST_TO_ADDR
// if not array then
98100: LD_VAR 0 1
98104: NOT
98105: IFFALSE 98109
// exit ;
98107: GO 98208
// Randomize ;
98109: CALL_OW 10
// for i = array downto 1 do
98113: LD_ADDR_VAR 0 3
98117: PUSH
98118: DOUBLE
98119: LD_VAR 0 1
98123: INC
98124: ST_TO_ADDR
98125: LD_INT 1
98127: PUSH
98128: FOR_DOWNTO
98129: IFFALSE 98206
// begin index := rand ( 1 , array ) ;
98131: LD_ADDR_VAR 0 4
98135: PUSH
98136: LD_INT 1
98138: PPUSH
98139: LD_VAR 0 1
98143: PPUSH
98144: CALL_OW 12
98148: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
98149: LD_ADDR_VAR 0 2
98153: PUSH
98154: LD_VAR 0 2
98158: PPUSH
98159: LD_VAR 0 2
98163: PUSH
98164: LD_INT 1
98166: PLUS
98167: PPUSH
98168: LD_VAR 0 1
98172: PUSH
98173: LD_VAR 0 4
98177: ARRAY
98178: PPUSH
98179: CALL_OW 2
98183: ST_TO_ADDR
// array := Delete ( array , index ) ;
98184: LD_ADDR_VAR 0 1
98188: PUSH
98189: LD_VAR 0 1
98193: PPUSH
98194: LD_VAR 0 4
98198: PPUSH
98199: CALL_OW 3
98203: ST_TO_ADDR
// end ;
98204: GO 98128
98206: POP
98207: POP
// end ;
98208: LD_VAR 0 2
98212: RET
// export function GetBaseMaterials ( base ) ; begin
98213: LD_INT 0
98215: PPUSH
// result := [ 0 , 0 , 0 ] ;
98216: LD_ADDR_VAR 0 2
98220: PUSH
98221: LD_INT 0
98223: PUSH
98224: LD_INT 0
98226: PUSH
98227: LD_INT 0
98229: PUSH
98230: EMPTY
98231: LIST
98232: LIST
98233: LIST
98234: ST_TO_ADDR
// if not base then
98235: LD_VAR 0 1
98239: NOT
98240: IFFALSE 98244
// exit ;
98242: GO 98293
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
98244: LD_ADDR_VAR 0 2
98248: PUSH
98249: LD_VAR 0 1
98253: PPUSH
98254: LD_INT 1
98256: PPUSH
98257: CALL_OW 275
98261: PUSH
98262: LD_VAR 0 1
98266: PPUSH
98267: LD_INT 2
98269: PPUSH
98270: CALL_OW 275
98274: PUSH
98275: LD_VAR 0 1
98279: PPUSH
98280: LD_INT 3
98282: PPUSH
98283: CALL_OW 275
98287: PUSH
98288: EMPTY
98289: LIST
98290: LIST
98291: LIST
98292: ST_TO_ADDR
// end ;
98293: LD_VAR 0 2
98297: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
98298: LD_INT 0
98300: PPUSH
98301: PPUSH
// result := array ;
98302: LD_ADDR_VAR 0 3
98306: PUSH
98307: LD_VAR 0 1
98311: ST_TO_ADDR
// if size > 0 then
98312: LD_VAR 0 2
98316: PUSH
98317: LD_INT 0
98319: GREATER
98320: IFFALSE 98366
// for i := array downto size do
98322: LD_ADDR_VAR 0 4
98326: PUSH
98327: DOUBLE
98328: LD_VAR 0 1
98332: INC
98333: ST_TO_ADDR
98334: LD_VAR 0 2
98338: PUSH
98339: FOR_DOWNTO
98340: IFFALSE 98364
// result := Delete ( result , result ) ;
98342: LD_ADDR_VAR 0 3
98346: PUSH
98347: LD_VAR 0 3
98351: PPUSH
98352: LD_VAR 0 3
98356: PPUSH
98357: CALL_OW 3
98361: ST_TO_ADDR
98362: GO 98339
98364: POP
98365: POP
// end ;
98366: LD_VAR 0 3
98370: RET
// export function ComExit ( unit ) ; var tmp ; begin
98371: LD_INT 0
98373: PPUSH
98374: PPUSH
// if not IsInUnit ( unit ) then
98375: LD_VAR 0 1
98379: PPUSH
98380: CALL_OW 310
98384: NOT
98385: IFFALSE 98389
// exit ;
98387: GO 98449
// tmp := IsInUnit ( unit ) ;
98389: LD_ADDR_VAR 0 3
98393: PUSH
98394: LD_VAR 0 1
98398: PPUSH
98399: CALL_OW 310
98403: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
98404: LD_VAR 0 3
98408: PPUSH
98409: CALL_OW 247
98413: PUSH
98414: LD_INT 2
98416: EQUAL
98417: IFFALSE 98430
// ComExitVehicle ( unit ) else
98419: LD_VAR 0 1
98423: PPUSH
98424: CALL_OW 121
98428: GO 98439
// ComExitBuilding ( unit ) ;
98430: LD_VAR 0 1
98434: PPUSH
98435: CALL_OW 122
// result := tmp ;
98439: LD_ADDR_VAR 0 2
98443: PUSH
98444: LD_VAR 0 3
98448: ST_TO_ADDR
// end ;
98449: LD_VAR 0 2
98453: RET
// export function ComExitAll ( units ) ; var i ; begin
98454: LD_INT 0
98456: PPUSH
98457: PPUSH
// if not units then
98458: LD_VAR 0 1
98462: NOT
98463: IFFALSE 98467
// exit ;
98465: GO 98493
// for i in units do
98467: LD_ADDR_VAR 0 3
98471: PUSH
98472: LD_VAR 0 1
98476: PUSH
98477: FOR_IN
98478: IFFALSE 98491
// ComExit ( i ) ;
98480: LD_VAR 0 3
98484: PPUSH
98485: CALL 98371 0 1
98489: GO 98477
98491: POP
98492: POP
// end ;
98493: LD_VAR 0 2
98497: RET
// export function ResetHc ; begin
98498: LD_INT 0
98500: PPUSH
// InitHc ;
98501: CALL_OW 19
// hc_importance := 0 ;
98505: LD_ADDR_OWVAR 32
98509: PUSH
98510: LD_INT 0
98512: ST_TO_ADDR
// end ;
98513: LD_VAR 0 1
98517: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
98518: LD_INT 0
98520: PPUSH
98521: PPUSH
98522: PPUSH
// _x := ( x1 + x2 ) div 2 ;
98523: LD_ADDR_VAR 0 6
98527: PUSH
98528: LD_VAR 0 1
98532: PUSH
98533: LD_VAR 0 3
98537: PLUS
98538: PUSH
98539: LD_INT 2
98541: DIV
98542: ST_TO_ADDR
// if _x < 0 then
98543: LD_VAR 0 6
98547: PUSH
98548: LD_INT 0
98550: LESS
98551: IFFALSE 98568
// _x := _x * - 1 ;
98553: LD_ADDR_VAR 0 6
98557: PUSH
98558: LD_VAR 0 6
98562: PUSH
98563: LD_INT 1
98565: NEG
98566: MUL
98567: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
98568: LD_ADDR_VAR 0 7
98572: PUSH
98573: LD_VAR 0 2
98577: PUSH
98578: LD_VAR 0 4
98582: PLUS
98583: PUSH
98584: LD_INT 2
98586: DIV
98587: ST_TO_ADDR
// if _y < 0 then
98588: LD_VAR 0 7
98592: PUSH
98593: LD_INT 0
98595: LESS
98596: IFFALSE 98613
// _y := _y * - 1 ;
98598: LD_ADDR_VAR 0 7
98602: PUSH
98603: LD_VAR 0 7
98607: PUSH
98608: LD_INT 1
98610: NEG
98611: MUL
98612: ST_TO_ADDR
// result := [ _x , _y ] ;
98613: LD_ADDR_VAR 0 5
98617: PUSH
98618: LD_VAR 0 6
98622: PUSH
98623: LD_VAR 0 7
98627: PUSH
98628: EMPTY
98629: LIST
98630: LIST
98631: ST_TO_ADDR
// end ;
98632: LD_VAR 0 5
98636: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
98637: LD_INT 0
98639: PPUSH
98640: PPUSH
98641: PPUSH
98642: PPUSH
// task := GetTaskList ( unit ) ;
98643: LD_ADDR_VAR 0 7
98647: PUSH
98648: LD_VAR 0 1
98652: PPUSH
98653: CALL_OW 437
98657: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
98658: LD_VAR 0 7
98662: NOT
98663: PUSH
98664: LD_VAR 0 1
98668: PPUSH
98669: LD_VAR 0 2
98673: PPUSH
98674: CALL_OW 308
98678: NOT
98679: AND
98680: IFFALSE 98684
// exit ;
98682: GO 98802
// if IsInArea ( unit , area ) then
98684: LD_VAR 0 1
98688: PPUSH
98689: LD_VAR 0 2
98693: PPUSH
98694: CALL_OW 308
98698: IFFALSE 98716
// begin ComMoveToArea ( unit , goAway ) ;
98700: LD_VAR 0 1
98704: PPUSH
98705: LD_VAR 0 3
98709: PPUSH
98710: CALL_OW 113
// exit ;
98714: GO 98802
// end ; if task [ 1 ] [ 1 ] <> M then
98716: LD_VAR 0 7
98720: PUSH
98721: LD_INT 1
98723: ARRAY
98724: PUSH
98725: LD_INT 1
98727: ARRAY
98728: PUSH
98729: LD_STRING M
98731: NONEQUAL
98732: IFFALSE 98736
// exit ;
98734: GO 98802
// x := task [ 1 ] [ 2 ] ;
98736: LD_ADDR_VAR 0 5
98740: PUSH
98741: LD_VAR 0 7
98745: PUSH
98746: LD_INT 1
98748: ARRAY
98749: PUSH
98750: LD_INT 2
98752: ARRAY
98753: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
98754: LD_ADDR_VAR 0 6
98758: PUSH
98759: LD_VAR 0 7
98763: PUSH
98764: LD_INT 1
98766: ARRAY
98767: PUSH
98768: LD_INT 3
98770: ARRAY
98771: ST_TO_ADDR
// if InArea ( x , y , area ) then
98772: LD_VAR 0 5
98776: PPUSH
98777: LD_VAR 0 6
98781: PPUSH
98782: LD_VAR 0 2
98786: PPUSH
98787: CALL_OW 309
98791: IFFALSE 98802
// ComStop ( unit ) ;
98793: LD_VAR 0 1
98797: PPUSH
98798: CALL_OW 141
// end ;
98802: LD_VAR 0 4
98806: RET
// export function Abs ( value ) ; begin
98807: LD_INT 0
98809: PPUSH
// result := value ;
98810: LD_ADDR_VAR 0 2
98814: PUSH
98815: LD_VAR 0 1
98819: ST_TO_ADDR
// if value < 0 then
98820: LD_VAR 0 1
98824: PUSH
98825: LD_INT 0
98827: LESS
98828: IFFALSE 98845
// result := value * - 1 ;
98830: LD_ADDR_VAR 0 2
98834: PUSH
98835: LD_VAR 0 1
98839: PUSH
98840: LD_INT 1
98842: NEG
98843: MUL
98844: ST_TO_ADDR
// end ;
98845: LD_VAR 0 2
98849: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
98850: LD_INT 0
98852: PPUSH
98853: PPUSH
98854: PPUSH
98855: PPUSH
98856: PPUSH
98857: PPUSH
98858: PPUSH
98859: PPUSH
// if not unit or not building then
98860: LD_VAR 0 1
98864: NOT
98865: PUSH
98866: LD_VAR 0 2
98870: NOT
98871: OR
98872: IFFALSE 98876
// exit ;
98874: GO 99102
// x := GetX ( building ) ;
98876: LD_ADDR_VAR 0 4
98880: PUSH
98881: LD_VAR 0 2
98885: PPUSH
98886: CALL_OW 250
98890: ST_TO_ADDR
// y := GetY ( building ) ;
98891: LD_ADDR_VAR 0 6
98895: PUSH
98896: LD_VAR 0 2
98900: PPUSH
98901: CALL_OW 251
98905: ST_TO_ADDR
// d := GetDir ( building ) ;
98906: LD_ADDR_VAR 0 8
98910: PUSH
98911: LD_VAR 0 2
98915: PPUSH
98916: CALL_OW 254
98920: ST_TO_ADDR
// r := 4 ;
98921: LD_ADDR_VAR 0 9
98925: PUSH
98926: LD_INT 4
98928: ST_TO_ADDR
// for i := 1 to 5 do
98929: LD_ADDR_VAR 0 10
98933: PUSH
98934: DOUBLE
98935: LD_INT 1
98937: DEC
98938: ST_TO_ADDR
98939: LD_INT 5
98941: PUSH
98942: FOR_TO
98943: IFFALSE 99100
// begin _x := ShiftX ( x , d , r + i ) ;
98945: LD_ADDR_VAR 0 5
98949: PUSH
98950: LD_VAR 0 4
98954: PPUSH
98955: LD_VAR 0 8
98959: PPUSH
98960: LD_VAR 0 9
98964: PUSH
98965: LD_VAR 0 10
98969: PLUS
98970: PPUSH
98971: CALL_OW 272
98975: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
98976: LD_ADDR_VAR 0 7
98980: PUSH
98981: LD_VAR 0 6
98985: PPUSH
98986: LD_VAR 0 8
98990: PPUSH
98991: LD_VAR 0 9
98995: PUSH
98996: LD_VAR 0 10
99000: PLUS
99001: PPUSH
99002: CALL_OW 273
99006: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
99007: LD_VAR 0 5
99011: PPUSH
99012: LD_VAR 0 7
99016: PPUSH
99017: CALL_OW 488
99021: PUSH
99022: LD_VAR 0 5
99026: PPUSH
99027: LD_VAR 0 7
99031: PPUSH
99032: CALL_OW 428
99036: PPUSH
99037: CALL_OW 247
99041: PUSH
99042: LD_INT 3
99044: PUSH
99045: LD_INT 2
99047: PUSH
99048: EMPTY
99049: LIST
99050: LIST
99051: IN
99052: NOT
99053: AND
99054: IFFALSE 99098
// begin ComMoveXY ( unit , _x , _y ) ;
99056: LD_VAR 0 1
99060: PPUSH
99061: LD_VAR 0 5
99065: PPUSH
99066: LD_VAR 0 7
99070: PPUSH
99071: CALL_OW 111
// result := [ _x , _y ] ;
99075: LD_ADDR_VAR 0 3
99079: PUSH
99080: LD_VAR 0 5
99084: PUSH
99085: LD_VAR 0 7
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: ST_TO_ADDR
// exit ;
99094: POP
99095: POP
99096: GO 99102
// end ; end ;
99098: GO 98942
99100: POP
99101: POP
// end ;
99102: LD_VAR 0 3
99106: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
99107: LD_INT 0
99109: PPUSH
99110: PPUSH
99111: PPUSH
// result := 0 ;
99112: LD_ADDR_VAR 0 3
99116: PUSH
99117: LD_INT 0
99119: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
99120: LD_VAR 0 1
99124: PUSH
99125: LD_INT 0
99127: LESS
99128: PUSH
99129: LD_VAR 0 1
99133: PUSH
99134: LD_INT 8
99136: GREATER
99137: OR
99138: PUSH
99139: LD_VAR 0 2
99143: PUSH
99144: LD_INT 0
99146: LESS
99147: OR
99148: PUSH
99149: LD_VAR 0 2
99153: PUSH
99154: LD_INT 8
99156: GREATER
99157: OR
99158: IFFALSE 99162
// exit ;
99160: GO 99237
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
99162: LD_ADDR_VAR 0 4
99166: PUSH
99167: LD_INT 22
99169: PUSH
99170: LD_VAR 0 2
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: PPUSH
99179: CALL_OW 69
99183: PUSH
99184: FOR_IN
99185: IFFALSE 99235
// begin un := UnitShoot ( i ) ;
99187: LD_ADDR_VAR 0 5
99191: PUSH
99192: LD_VAR 0 4
99196: PPUSH
99197: CALL_OW 504
99201: ST_TO_ADDR
// if GetSide ( un ) = side1 then
99202: LD_VAR 0 5
99206: PPUSH
99207: CALL_OW 255
99211: PUSH
99212: LD_VAR 0 1
99216: EQUAL
99217: IFFALSE 99233
// begin result := un ;
99219: LD_ADDR_VAR 0 3
99223: PUSH
99224: LD_VAR 0 5
99228: ST_TO_ADDR
// exit ;
99229: POP
99230: POP
99231: GO 99237
// end ; end ;
99233: GO 99184
99235: POP
99236: POP
// end ;
99237: LD_VAR 0 3
99241: RET
// export function GetCargoBay ( units ) ; begin
99242: LD_INT 0
99244: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
99245: LD_ADDR_VAR 0 2
99249: PUSH
99250: LD_VAR 0 1
99254: PPUSH
99255: LD_INT 2
99257: PUSH
99258: LD_INT 34
99260: PUSH
99261: LD_INT 12
99263: PUSH
99264: EMPTY
99265: LIST
99266: LIST
99267: PUSH
99268: LD_INT 34
99270: PUSH
99271: LD_INT 51
99273: PUSH
99274: EMPTY
99275: LIST
99276: LIST
99277: PUSH
99278: LD_INT 34
99280: PUSH
99281: LD_INT 32
99283: PUSH
99284: EMPTY
99285: LIST
99286: LIST
99287: PUSH
99288: LD_INT 34
99290: PUSH
99291: LD_EXP 74
99295: PUSH
99296: EMPTY
99297: LIST
99298: LIST
99299: PUSH
99300: EMPTY
99301: LIST
99302: LIST
99303: LIST
99304: LIST
99305: LIST
99306: PPUSH
99307: CALL_OW 72
99311: ST_TO_ADDR
// end ;
99312: LD_VAR 0 2
99316: RET
// export function Negate ( value ) ; begin
99317: LD_INT 0
99319: PPUSH
// result := not value ;
99320: LD_ADDR_VAR 0 2
99324: PUSH
99325: LD_VAR 0 1
99329: NOT
99330: ST_TO_ADDR
// end ;
99331: LD_VAR 0 2
99335: RET
// export function Inc ( value ) ; begin
99336: LD_INT 0
99338: PPUSH
// result := value + 1 ;
99339: LD_ADDR_VAR 0 2
99343: PUSH
99344: LD_VAR 0 1
99348: PUSH
99349: LD_INT 1
99351: PLUS
99352: ST_TO_ADDR
// end ;
99353: LD_VAR 0 2
99357: RET
// export function Dec ( value ) ; begin
99358: LD_INT 0
99360: PPUSH
// result := value - 1 ;
99361: LD_ADDR_VAR 0 2
99365: PUSH
99366: LD_VAR 0 1
99370: PUSH
99371: LD_INT 1
99373: MINUS
99374: ST_TO_ADDR
// end ;
99375: LD_VAR 0 2
99379: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
99380: LD_INT 0
99382: PPUSH
99383: PPUSH
99384: PPUSH
99385: PPUSH
99386: PPUSH
99387: PPUSH
99388: PPUSH
99389: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
99390: LD_VAR 0 1
99394: PPUSH
99395: LD_VAR 0 2
99399: PPUSH
99400: CALL_OW 488
99404: NOT
99405: PUSH
99406: LD_VAR 0 3
99410: PPUSH
99411: LD_VAR 0 4
99415: PPUSH
99416: CALL_OW 488
99420: NOT
99421: OR
99422: IFFALSE 99435
// begin result := - 1 ;
99424: LD_ADDR_VAR 0 5
99428: PUSH
99429: LD_INT 1
99431: NEG
99432: ST_TO_ADDR
// exit ;
99433: GO 99670
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
99435: LD_ADDR_VAR 0 12
99439: PUSH
99440: LD_VAR 0 1
99444: PPUSH
99445: LD_VAR 0 2
99449: PPUSH
99450: LD_VAR 0 3
99454: PPUSH
99455: LD_VAR 0 4
99459: PPUSH
99460: CALL 98518 0 4
99464: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
99465: LD_ADDR_VAR 0 11
99469: PUSH
99470: LD_VAR 0 1
99474: PPUSH
99475: LD_VAR 0 2
99479: PPUSH
99480: LD_VAR 0 12
99484: PUSH
99485: LD_INT 1
99487: ARRAY
99488: PPUSH
99489: LD_VAR 0 12
99493: PUSH
99494: LD_INT 2
99496: ARRAY
99497: PPUSH
99498: CALL_OW 298
99502: ST_TO_ADDR
// distance := 9999 ;
99503: LD_ADDR_VAR 0 10
99507: PUSH
99508: LD_INT 9999
99510: ST_TO_ADDR
// for i := 0 to 5 do
99511: LD_ADDR_VAR 0 6
99515: PUSH
99516: DOUBLE
99517: LD_INT 0
99519: DEC
99520: ST_TO_ADDR
99521: LD_INT 5
99523: PUSH
99524: FOR_TO
99525: IFFALSE 99668
// begin _x := ShiftX ( x1 , i , centerDist ) ;
99527: LD_ADDR_VAR 0 7
99531: PUSH
99532: LD_VAR 0 1
99536: PPUSH
99537: LD_VAR 0 6
99541: PPUSH
99542: LD_VAR 0 11
99546: PPUSH
99547: CALL_OW 272
99551: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
99552: LD_ADDR_VAR 0 8
99556: PUSH
99557: LD_VAR 0 2
99561: PPUSH
99562: LD_VAR 0 6
99566: PPUSH
99567: LD_VAR 0 11
99571: PPUSH
99572: CALL_OW 273
99576: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
99577: LD_VAR 0 7
99581: PPUSH
99582: LD_VAR 0 8
99586: PPUSH
99587: CALL_OW 488
99591: NOT
99592: IFFALSE 99596
// continue ;
99594: GO 99524
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
99596: LD_ADDR_VAR 0 9
99600: PUSH
99601: LD_VAR 0 12
99605: PUSH
99606: LD_INT 1
99608: ARRAY
99609: PPUSH
99610: LD_VAR 0 12
99614: PUSH
99615: LD_INT 2
99617: ARRAY
99618: PPUSH
99619: LD_VAR 0 7
99623: PPUSH
99624: LD_VAR 0 8
99628: PPUSH
99629: CALL_OW 298
99633: ST_TO_ADDR
// if tmp < distance then
99634: LD_VAR 0 9
99638: PUSH
99639: LD_VAR 0 10
99643: LESS
99644: IFFALSE 99666
// begin result := i ;
99646: LD_ADDR_VAR 0 5
99650: PUSH
99651: LD_VAR 0 6
99655: ST_TO_ADDR
// distance := tmp ;
99656: LD_ADDR_VAR 0 10
99660: PUSH
99661: LD_VAR 0 9
99665: ST_TO_ADDR
// end ; end ;
99666: GO 99524
99668: POP
99669: POP
// end ;
99670: LD_VAR 0 5
99674: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
99675: LD_INT 0
99677: PPUSH
99678: PPUSH
// if not driver or not IsInUnit ( driver ) then
99679: LD_VAR 0 1
99683: NOT
99684: PUSH
99685: LD_VAR 0 1
99689: PPUSH
99690: CALL_OW 310
99694: NOT
99695: OR
99696: IFFALSE 99700
// exit ;
99698: GO 99790
// vehicle := IsInUnit ( driver ) ;
99700: LD_ADDR_VAR 0 3
99704: PUSH
99705: LD_VAR 0 1
99709: PPUSH
99710: CALL_OW 310
99714: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
99715: LD_VAR 0 1
99719: PPUSH
99720: LD_STRING \
99722: PUSH
99723: LD_INT 0
99725: PUSH
99726: LD_INT 0
99728: PUSH
99729: LD_INT 0
99731: PUSH
99732: LD_INT 0
99734: PUSH
99735: LD_INT 0
99737: PUSH
99738: LD_INT 0
99740: PUSH
99741: EMPTY
99742: LIST
99743: LIST
99744: LIST
99745: LIST
99746: LIST
99747: LIST
99748: LIST
99749: PUSH
99750: LD_STRING E
99752: PUSH
99753: LD_INT 0
99755: PUSH
99756: LD_INT 0
99758: PUSH
99759: LD_VAR 0 3
99763: PUSH
99764: LD_INT 0
99766: PUSH
99767: LD_INT 0
99769: PUSH
99770: LD_INT 0
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: LIST
99777: LIST
99778: LIST
99779: LIST
99780: LIST
99781: PUSH
99782: EMPTY
99783: LIST
99784: LIST
99785: PPUSH
99786: CALL_OW 446
// end ;
99790: LD_VAR 0 2
99794: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
99795: LD_INT 0
99797: PPUSH
99798: PPUSH
// if not driver or not IsInUnit ( driver ) then
99799: LD_VAR 0 1
99803: NOT
99804: PUSH
99805: LD_VAR 0 1
99809: PPUSH
99810: CALL_OW 310
99814: NOT
99815: OR
99816: IFFALSE 99820
// exit ;
99818: GO 99910
// vehicle := IsInUnit ( driver ) ;
99820: LD_ADDR_VAR 0 3
99824: PUSH
99825: LD_VAR 0 1
99829: PPUSH
99830: CALL_OW 310
99834: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
99835: LD_VAR 0 1
99839: PPUSH
99840: LD_STRING \
99842: PUSH
99843: LD_INT 0
99845: PUSH
99846: LD_INT 0
99848: PUSH
99849: LD_INT 0
99851: PUSH
99852: LD_INT 0
99854: PUSH
99855: LD_INT 0
99857: PUSH
99858: LD_INT 0
99860: PUSH
99861: EMPTY
99862: LIST
99863: LIST
99864: LIST
99865: LIST
99866: LIST
99867: LIST
99868: LIST
99869: PUSH
99870: LD_STRING E
99872: PUSH
99873: LD_INT 0
99875: PUSH
99876: LD_INT 0
99878: PUSH
99879: LD_VAR 0 3
99883: PUSH
99884: LD_INT 0
99886: PUSH
99887: LD_INT 0
99889: PUSH
99890: LD_INT 0
99892: PUSH
99893: EMPTY
99894: LIST
99895: LIST
99896: LIST
99897: LIST
99898: LIST
99899: LIST
99900: LIST
99901: PUSH
99902: EMPTY
99903: LIST
99904: LIST
99905: PPUSH
99906: CALL_OW 447
// end ;
99910: LD_VAR 0 2
99914: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
99915: LD_INT 0
99917: PPUSH
99918: PPUSH
99919: PPUSH
// tmp := [ ] ;
99920: LD_ADDR_VAR 0 5
99924: PUSH
99925: EMPTY
99926: ST_TO_ADDR
// for i in units do
99927: LD_ADDR_VAR 0 4
99931: PUSH
99932: LD_VAR 0 1
99936: PUSH
99937: FOR_IN
99938: IFFALSE 99976
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
99940: LD_ADDR_VAR 0 5
99944: PUSH
99945: LD_VAR 0 5
99949: PPUSH
99950: LD_VAR 0 5
99954: PUSH
99955: LD_INT 1
99957: PLUS
99958: PPUSH
99959: LD_VAR 0 4
99963: PPUSH
99964: CALL_OW 256
99968: PPUSH
99969: CALL_OW 2
99973: ST_TO_ADDR
99974: GO 99937
99976: POP
99977: POP
// if not tmp then
99978: LD_VAR 0 5
99982: NOT
99983: IFFALSE 99987
// exit ;
99985: GO 100035
// if asc then
99987: LD_VAR 0 2
99991: IFFALSE 100015
// result := SortListByListAsc ( units , tmp ) else
99993: LD_ADDR_VAR 0 3
99997: PUSH
99998: LD_VAR 0 1
100002: PPUSH
100003: LD_VAR 0 5
100007: PPUSH
100008: CALL_OW 76
100012: ST_TO_ADDR
100013: GO 100035
// result := SortListByListDesc ( units , tmp ) ;
100015: LD_ADDR_VAR 0 3
100019: PUSH
100020: LD_VAR 0 1
100024: PPUSH
100025: LD_VAR 0 5
100029: PPUSH
100030: CALL_OW 77
100034: ST_TO_ADDR
// end ;
100035: LD_VAR 0 3
100039: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
100040: LD_INT 0
100042: PPUSH
100043: PPUSH
// task := GetTaskList ( mech ) ;
100044: LD_ADDR_VAR 0 4
100048: PUSH
100049: LD_VAR 0 1
100053: PPUSH
100054: CALL_OW 437
100058: ST_TO_ADDR
// if not task then
100059: LD_VAR 0 4
100063: NOT
100064: IFFALSE 100068
// exit ;
100066: GO 100110
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
100068: LD_ADDR_VAR 0 3
100072: PUSH
100073: LD_VAR 0 4
100077: PUSH
100078: LD_INT 1
100080: ARRAY
100081: PUSH
100082: LD_INT 1
100084: ARRAY
100085: PUSH
100086: LD_STRING r
100088: EQUAL
100089: PUSH
100090: LD_VAR 0 4
100094: PUSH
100095: LD_INT 1
100097: ARRAY
100098: PUSH
100099: LD_INT 4
100101: ARRAY
100102: PUSH
100103: LD_VAR 0 2
100107: EQUAL
100108: AND
100109: ST_TO_ADDR
// end ;
100110: LD_VAR 0 3
100114: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
100115: LD_INT 0
100117: PPUSH
// SetDir ( unit , d ) ;
100118: LD_VAR 0 1
100122: PPUSH
100123: LD_VAR 0 4
100127: PPUSH
100128: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
100132: LD_VAR 0 1
100136: PPUSH
100137: LD_VAR 0 2
100141: PPUSH
100142: LD_VAR 0 3
100146: PPUSH
100147: LD_VAR 0 5
100151: PPUSH
100152: CALL_OW 48
// end ;
100156: LD_VAR 0 6
100160: RET
// export function ToNaturalNumber ( number ) ; begin
100161: LD_INT 0
100163: PPUSH
// result := number div 1 ;
100164: LD_ADDR_VAR 0 2
100168: PUSH
100169: LD_VAR 0 1
100173: PUSH
100174: LD_INT 1
100176: DIV
100177: ST_TO_ADDR
// if number < 0 then
100178: LD_VAR 0 1
100182: PUSH
100183: LD_INT 0
100185: LESS
100186: IFFALSE 100196
// result := 0 ;
100188: LD_ADDR_VAR 0 2
100192: PUSH
100193: LD_INT 0
100195: ST_TO_ADDR
// end ;
100196: LD_VAR 0 2
100200: RET
// export function SortByClass ( units , class ) ; var un ; begin
100201: LD_INT 0
100203: PPUSH
100204: PPUSH
// if not units or not class then
100205: LD_VAR 0 1
100209: NOT
100210: PUSH
100211: LD_VAR 0 2
100215: NOT
100216: OR
100217: IFFALSE 100221
// exit ;
100219: GO 100316
// result := [ ] ;
100221: LD_ADDR_VAR 0 3
100225: PUSH
100226: EMPTY
100227: ST_TO_ADDR
// for un in units do
100228: LD_ADDR_VAR 0 4
100232: PUSH
100233: LD_VAR 0 1
100237: PUSH
100238: FOR_IN
100239: IFFALSE 100314
// if GetClass ( un ) = class then
100241: LD_VAR 0 4
100245: PPUSH
100246: CALL_OW 257
100250: PUSH
100251: LD_VAR 0 2
100255: EQUAL
100256: IFFALSE 100283
// result := Insert ( result , 1 , un ) else
100258: LD_ADDR_VAR 0 3
100262: PUSH
100263: LD_VAR 0 3
100267: PPUSH
100268: LD_INT 1
100270: PPUSH
100271: LD_VAR 0 4
100275: PPUSH
100276: CALL_OW 2
100280: ST_TO_ADDR
100281: GO 100312
// result := Replace ( result , result + 1 , un ) ;
100283: LD_ADDR_VAR 0 3
100287: PUSH
100288: LD_VAR 0 3
100292: PPUSH
100293: LD_VAR 0 3
100297: PUSH
100298: LD_INT 1
100300: PLUS
100301: PPUSH
100302: LD_VAR 0 4
100306: PPUSH
100307: CALL_OW 1
100311: ST_TO_ADDR
100312: GO 100238
100314: POP
100315: POP
// end ;
100316: LD_VAR 0 3
100320: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
100321: LD_INT 0
100323: PPUSH
100324: PPUSH
100325: PPUSH
100326: PPUSH
100327: PPUSH
100328: PPUSH
100329: PPUSH
// result := [ ] ;
100330: LD_ADDR_VAR 0 4
100334: PUSH
100335: EMPTY
100336: ST_TO_ADDR
// if x - r < 0 then
100337: LD_VAR 0 1
100341: PUSH
100342: LD_VAR 0 3
100346: MINUS
100347: PUSH
100348: LD_INT 0
100350: LESS
100351: IFFALSE 100363
// min_x := 0 else
100353: LD_ADDR_VAR 0 8
100357: PUSH
100358: LD_INT 0
100360: ST_TO_ADDR
100361: GO 100379
// min_x := x - r ;
100363: LD_ADDR_VAR 0 8
100367: PUSH
100368: LD_VAR 0 1
100372: PUSH
100373: LD_VAR 0 3
100377: MINUS
100378: ST_TO_ADDR
// if y - r < 0 then
100379: LD_VAR 0 2
100383: PUSH
100384: LD_VAR 0 3
100388: MINUS
100389: PUSH
100390: LD_INT 0
100392: LESS
100393: IFFALSE 100405
// min_y := 0 else
100395: LD_ADDR_VAR 0 7
100399: PUSH
100400: LD_INT 0
100402: ST_TO_ADDR
100403: GO 100421
// min_y := y - r ;
100405: LD_ADDR_VAR 0 7
100409: PUSH
100410: LD_VAR 0 2
100414: PUSH
100415: LD_VAR 0 3
100419: MINUS
100420: ST_TO_ADDR
// max_x := x + r ;
100421: LD_ADDR_VAR 0 9
100425: PUSH
100426: LD_VAR 0 1
100430: PUSH
100431: LD_VAR 0 3
100435: PLUS
100436: ST_TO_ADDR
// max_y := y + r ;
100437: LD_ADDR_VAR 0 10
100441: PUSH
100442: LD_VAR 0 2
100446: PUSH
100447: LD_VAR 0 3
100451: PLUS
100452: ST_TO_ADDR
// for _x = min_x to max_x do
100453: LD_ADDR_VAR 0 5
100457: PUSH
100458: DOUBLE
100459: LD_VAR 0 8
100463: DEC
100464: ST_TO_ADDR
100465: LD_VAR 0 9
100469: PUSH
100470: FOR_TO
100471: IFFALSE 100572
// for _y = min_y to max_y do
100473: LD_ADDR_VAR 0 6
100477: PUSH
100478: DOUBLE
100479: LD_VAR 0 7
100483: DEC
100484: ST_TO_ADDR
100485: LD_VAR 0 10
100489: PUSH
100490: FOR_TO
100491: IFFALSE 100568
// begin if not ValidHex ( _x , _y ) then
100493: LD_VAR 0 5
100497: PPUSH
100498: LD_VAR 0 6
100502: PPUSH
100503: CALL_OW 488
100507: NOT
100508: IFFALSE 100512
// continue ;
100510: GO 100490
// if GetResourceTypeXY ( _x , _y ) then
100512: LD_VAR 0 5
100516: PPUSH
100517: LD_VAR 0 6
100521: PPUSH
100522: CALL_OW 283
100526: IFFALSE 100566
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
100528: LD_ADDR_VAR 0 4
100532: PUSH
100533: LD_VAR 0 4
100537: PPUSH
100538: LD_VAR 0 4
100542: PUSH
100543: LD_INT 1
100545: PLUS
100546: PPUSH
100547: LD_VAR 0 5
100551: PUSH
100552: LD_VAR 0 6
100556: PUSH
100557: EMPTY
100558: LIST
100559: LIST
100560: PPUSH
100561: CALL_OW 1
100565: ST_TO_ADDR
// end ;
100566: GO 100490
100568: POP
100569: POP
100570: GO 100470
100572: POP
100573: POP
// end ;
100574: LD_VAR 0 4
100578: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
100579: LD_INT 0
100581: PPUSH
100582: PPUSH
100583: PPUSH
100584: PPUSH
100585: PPUSH
100586: PPUSH
100587: PPUSH
100588: PPUSH
// if not units then
100589: LD_VAR 0 1
100593: NOT
100594: IFFALSE 100598
// exit ;
100596: GO 101023
// result := UnitFilter ( units , [ f_ok ] ) ;
100598: LD_ADDR_VAR 0 3
100602: PUSH
100603: LD_VAR 0 1
100607: PPUSH
100608: LD_INT 50
100610: PUSH
100611: EMPTY
100612: LIST
100613: PPUSH
100614: CALL_OW 72
100618: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
100619: LD_ADDR_VAR 0 8
100623: PUSH
100624: LD_VAR 0 1
100628: PUSH
100629: LD_INT 1
100631: ARRAY
100632: PPUSH
100633: CALL_OW 255
100637: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
100638: LD_ADDR_VAR 0 10
100642: PUSH
100643: LD_INT 29
100645: PUSH
100646: LD_EXP 77
100650: PUSH
100651: EMPTY
100652: LIST
100653: LIST
100654: ST_TO_ADDR
// if not result then
100655: LD_VAR 0 3
100659: NOT
100660: IFFALSE 100664
// exit ;
100662: GO 101023
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
100664: LD_ADDR_VAR 0 5
100668: PUSH
100669: LD_INT 81
100671: PUSH
100672: LD_VAR 0 8
100676: PUSH
100677: EMPTY
100678: LIST
100679: LIST
100680: PPUSH
100681: CALL_OW 69
100685: ST_TO_ADDR
// for i in result do
100686: LD_ADDR_VAR 0 4
100690: PUSH
100691: LD_VAR 0 3
100695: PUSH
100696: FOR_IN
100697: IFFALSE 101021
// begin tag := GetTag ( i ) + 1 ;
100699: LD_ADDR_VAR 0 9
100703: PUSH
100704: LD_VAR 0 4
100708: PPUSH
100709: CALL_OW 110
100713: PUSH
100714: LD_INT 1
100716: PLUS
100717: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
100718: LD_ADDR_VAR 0 7
100722: PUSH
100723: LD_VAR 0 4
100727: PPUSH
100728: CALL_OW 250
100732: PPUSH
100733: LD_VAR 0 4
100737: PPUSH
100738: CALL_OW 251
100742: PPUSH
100743: LD_INT 6
100745: PPUSH
100746: CALL 100321 0 3
100750: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
100751: LD_VAR 0 7
100755: PUSH
100756: LD_VAR 0 4
100760: PPUSH
100761: CALL_OW 264
100765: PUSH
100766: LD_VAR 0 10
100770: IN
100771: NOT
100772: AND
100773: IFFALSE 100812
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
100775: LD_VAR 0 4
100779: PPUSH
100780: LD_VAR 0 7
100784: PUSH
100785: LD_INT 1
100787: ARRAY
100788: PUSH
100789: LD_INT 1
100791: ARRAY
100792: PPUSH
100793: LD_VAR 0 7
100797: PUSH
100798: LD_INT 1
100800: ARRAY
100801: PUSH
100802: LD_INT 2
100804: ARRAY
100805: PPUSH
100806: CALL_OW 116
100810: GO 101019
// if path > tag then
100812: LD_VAR 0 2
100816: PUSH
100817: LD_VAR 0 9
100821: GREATER
100822: IFFALSE 100989
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
100824: LD_ADDR_VAR 0 6
100828: PUSH
100829: LD_VAR 0 5
100833: PPUSH
100834: LD_INT 91
100836: PUSH
100837: LD_VAR 0 4
100841: PUSH
100842: LD_INT 12
100844: PUSH
100845: EMPTY
100846: LIST
100847: LIST
100848: LIST
100849: PPUSH
100850: CALL_OW 72
100854: ST_TO_ADDR
// if nearEnemy then
100855: LD_VAR 0 6
100859: IFFALSE 100887
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
100861: LD_VAR 0 4
100865: PPUSH
100866: LD_VAR 0 6
100870: PPUSH
100871: LD_VAR 0 4
100875: PPUSH
100876: CALL_OW 74
100880: PPUSH
100881: CALL_OW 115
100885: GO 100987
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
100887: LD_VAR 0 4
100891: PPUSH
100892: LD_VAR 0 2
100896: PUSH
100897: LD_VAR 0 9
100901: ARRAY
100902: PUSH
100903: LD_INT 1
100905: ARRAY
100906: PPUSH
100907: LD_VAR 0 2
100911: PUSH
100912: LD_VAR 0 9
100916: ARRAY
100917: PUSH
100918: LD_INT 2
100920: ARRAY
100921: PPUSH
100922: CALL_OW 297
100926: PUSH
100927: LD_INT 6
100929: GREATER
100930: IFFALSE 100973
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
100932: LD_VAR 0 4
100936: PPUSH
100937: LD_VAR 0 2
100941: PUSH
100942: LD_VAR 0 9
100946: ARRAY
100947: PUSH
100948: LD_INT 1
100950: ARRAY
100951: PPUSH
100952: LD_VAR 0 2
100956: PUSH
100957: LD_VAR 0 9
100961: ARRAY
100962: PUSH
100963: LD_INT 2
100965: ARRAY
100966: PPUSH
100967: CALL_OW 114
100971: GO 100987
// SetTag ( i , tag ) ;
100973: LD_VAR 0 4
100977: PPUSH
100978: LD_VAR 0 9
100982: PPUSH
100983: CALL_OW 109
// end else
100987: GO 101019
// if enemy then
100989: LD_VAR 0 5
100993: IFFALSE 101019
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
100995: LD_VAR 0 4
100999: PPUSH
101000: LD_VAR 0 5
101004: PPUSH
101005: LD_VAR 0 4
101009: PPUSH
101010: CALL_OW 74
101014: PPUSH
101015: CALL_OW 115
// end ;
101019: GO 100696
101021: POP
101022: POP
// end ;
101023: LD_VAR 0 3
101027: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
101028: LD_INT 0
101030: PPUSH
101031: PPUSH
101032: PPUSH
// if not unit or IsInUnit ( unit ) then
101033: LD_VAR 0 1
101037: NOT
101038: PUSH
101039: LD_VAR 0 1
101043: PPUSH
101044: CALL_OW 310
101048: OR
101049: IFFALSE 101053
// exit ;
101051: GO 101144
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
101053: LD_ADDR_VAR 0 4
101057: PUSH
101058: LD_VAR 0 1
101062: PPUSH
101063: CALL_OW 250
101067: PPUSH
101068: LD_VAR 0 2
101072: PPUSH
101073: LD_INT 1
101075: PPUSH
101076: CALL_OW 272
101080: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
101081: LD_ADDR_VAR 0 5
101085: PUSH
101086: LD_VAR 0 1
101090: PPUSH
101091: CALL_OW 251
101095: PPUSH
101096: LD_VAR 0 2
101100: PPUSH
101101: LD_INT 1
101103: PPUSH
101104: CALL_OW 273
101108: ST_TO_ADDR
// if ValidHex ( x , y ) then
101109: LD_VAR 0 4
101113: PPUSH
101114: LD_VAR 0 5
101118: PPUSH
101119: CALL_OW 488
101123: IFFALSE 101144
// ComTurnXY ( unit , x , y ) ;
101125: LD_VAR 0 1
101129: PPUSH
101130: LD_VAR 0 4
101134: PPUSH
101135: LD_VAR 0 5
101139: PPUSH
101140: CALL_OW 118
// end ;
101144: LD_VAR 0 3
101148: RET
// export function SeeUnits ( side , units ) ; var i ; begin
101149: LD_INT 0
101151: PPUSH
101152: PPUSH
// result := false ;
101153: LD_ADDR_VAR 0 3
101157: PUSH
101158: LD_INT 0
101160: ST_TO_ADDR
// if not units then
101161: LD_VAR 0 2
101165: NOT
101166: IFFALSE 101170
// exit ;
101168: GO 101215
// for i in units do
101170: LD_ADDR_VAR 0 4
101174: PUSH
101175: LD_VAR 0 2
101179: PUSH
101180: FOR_IN
101181: IFFALSE 101213
// if See ( side , i ) then
101183: LD_VAR 0 1
101187: PPUSH
101188: LD_VAR 0 4
101192: PPUSH
101193: CALL_OW 292
101197: IFFALSE 101211
// begin result := true ;
101199: LD_ADDR_VAR 0 3
101203: PUSH
101204: LD_INT 1
101206: ST_TO_ADDR
// exit ;
101207: POP
101208: POP
101209: GO 101215
// end ;
101211: GO 101180
101213: POP
101214: POP
// end ;
101215: LD_VAR 0 3
101219: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
101220: LD_INT 0
101222: PPUSH
101223: PPUSH
101224: PPUSH
101225: PPUSH
// if not unit or not points then
101226: LD_VAR 0 1
101230: NOT
101231: PUSH
101232: LD_VAR 0 2
101236: NOT
101237: OR
101238: IFFALSE 101242
// exit ;
101240: GO 101332
// dist := 99999 ;
101242: LD_ADDR_VAR 0 5
101246: PUSH
101247: LD_INT 99999
101249: ST_TO_ADDR
// for i in points do
101250: LD_ADDR_VAR 0 4
101254: PUSH
101255: LD_VAR 0 2
101259: PUSH
101260: FOR_IN
101261: IFFALSE 101330
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
101263: LD_ADDR_VAR 0 6
101267: PUSH
101268: LD_VAR 0 1
101272: PPUSH
101273: LD_VAR 0 4
101277: PUSH
101278: LD_INT 1
101280: ARRAY
101281: PPUSH
101282: LD_VAR 0 4
101286: PUSH
101287: LD_INT 2
101289: ARRAY
101290: PPUSH
101291: CALL_OW 297
101295: ST_TO_ADDR
// if tmpDist < dist then
101296: LD_VAR 0 6
101300: PUSH
101301: LD_VAR 0 5
101305: LESS
101306: IFFALSE 101328
// begin result := i ;
101308: LD_ADDR_VAR 0 3
101312: PUSH
101313: LD_VAR 0 4
101317: ST_TO_ADDR
// dist := tmpDist ;
101318: LD_ADDR_VAR 0 5
101322: PUSH
101323: LD_VAR 0 6
101327: ST_TO_ADDR
// end ; end ;
101328: GO 101260
101330: POP
101331: POP
// end ; end_of_file
101332: LD_VAR 0 3
101336: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
101337: LD_VAR 0 1
101341: PUSH
101342: LD_INT 200
101344: DOUBLE
101345: GREATEREQUAL
101346: IFFALSE 101354
101348: LD_INT 299
101350: DOUBLE
101351: LESSEQUAL
101352: IFTRUE 101356
101354: GO 101388
101356: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
101357: LD_VAR 0 1
101361: PPUSH
101362: LD_VAR 0 2
101366: PPUSH
101367: LD_VAR 0 3
101371: PPUSH
101372: LD_VAR 0 4
101376: PPUSH
101377: LD_VAR 0 5
101381: PPUSH
101382: CALL 57363 0 5
101386: GO 101465
101388: LD_INT 300
101390: DOUBLE
101391: GREATEREQUAL
101392: IFFALSE 101400
101394: LD_INT 399
101396: DOUBLE
101397: LESSEQUAL
101398: IFTRUE 101402
101400: GO 101464
101402: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
101403: LD_VAR 0 1
101407: PPUSH
101408: LD_VAR 0 2
101412: PPUSH
101413: LD_VAR 0 3
101417: PPUSH
101418: LD_VAR 0 4
101422: PPUSH
101423: LD_VAR 0 5
101427: PPUSH
101428: LD_VAR 0 6
101432: PPUSH
101433: LD_VAR 0 7
101437: PPUSH
101438: LD_VAR 0 8
101442: PPUSH
101443: LD_VAR 0 9
101447: PPUSH
101448: LD_VAR 0 10
101452: PPUSH
101453: LD_VAR 0 11
101457: PPUSH
101458: CALL 55261 0 11
101462: GO 101465
101464: POP
// end ;
101465: PPOPN 11
101467: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
101468: LD_VAR 0 1
101472: PPUSH
101473: LD_VAR 0 2
101477: PPUSH
101478: LD_VAR 0 3
101482: PPUSH
101483: LD_VAR 0 4
101487: PPUSH
101488: LD_VAR 0 5
101492: PPUSH
101493: CALL 57355 0 5
// end ; end_of_file
101497: PPOPN 5
101499: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
101500: LD_VAR 0 1
101504: PPUSH
101505: LD_VAR 0 2
101509: PPUSH
101510: LD_VAR 0 3
101514: PPUSH
101515: LD_VAR 0 4
101519: PPUSH
101520: LD_VAR 0 5
101524: PPUSH
101525: LD_VAR 0 6
101529: PPUSH
101530: CALL 43456 0 6
// end ;
101534: PPOPN 6
101536: END
