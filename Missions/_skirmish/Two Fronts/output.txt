// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7501 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4626 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4949 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 41883 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42334 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21232 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21168 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18161 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21068 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22082 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21309 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21102 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21135 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 17940 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 21990 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20247 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20822 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20822 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20619 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20283 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20459 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19743 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radar , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 20
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20357 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20858 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21598 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21168 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18161 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21068 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21309 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21102 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21135 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 17940 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 21990 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20247 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20822 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20822 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20619 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20283 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20459 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19743 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radar , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 20
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20357 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20858 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21598 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string ; export houten , brown ; export ar_crane , ru_big_cargo_bay ; export dialog_north , dialog_south , dialog_popov , dialog_trans ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// ar_crane := 88 ;
1549: LD_ADDR_EXP 5
1553: PUSH
1554: LD_INT 88
1556: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
1557: LD_ADDR_EXP 6
1561: PUSH
1562: LD_INT 89
1564: ST_TO_ADDR
// dialog_north := true ;
1565: LD_ADDR_EXP 7
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_south := true ;
1573: LD_ADDR_EXP 8
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// dialog_popov := true ;
1581: LD_ADDR_EXP 9
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// dialog_trans := true ;
1589: LD_ADDR_EXP 10
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// call := true ;
1597: LD_ADDR_EXP 12
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// pink_attack := false ;
1605: LD_ADDR_EXP 13
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_support := false ;
1613: LD_ADDR_EXP 14
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// alfa_north_triggered := false ;
1621: LD_ADDR_EXP 15
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// alfa_south_triggered := false ;
1629: LD_ADDR_EXP 16
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19743 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11448 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21816 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11448 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21816 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11448 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21816 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11448 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21816 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 3
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 3
2743: PPUSH
2744: CALL 7720 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 3
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 4
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 4
2828: PPUSH
2829: CALL 7720 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 4
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7720 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player := CharacterSelection ( text , 1 , 1 , [ sel_not_hired , sel_changeable ] ^ commanders , [ ] ) ;
3246: LD_ADDR_EXP 18
3250: PUSH
3251: LD_STRING text
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: LD_INT 1
3259: PPUSH
3260: LD_INT -2
3262: PUSH
3263: LD_INT -3
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: LD_EXP 17
3274: ADD
3275: PPUSH
3276: EMPTY
3277: PPUSH
3278: CALL_OW 42
3282: ST_TO_ADDR
// player_com := player [ 1 ] ;
3283: LD_ADDR_EXP 25
3287: PUSH
3288: LD_EXP 18
3292: PUSH
3293: LD_INT 1
3295: ARRAY
3296: ST_TO_ADDR
// team := [ ] ;
3297: LD_ADDR_VAR 0 5
3301: PUSH
3302: EMPTY
3303: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3304: LD_ADDR_VAR 0 3
3308: PUSH
3309: LD_INT 4
3311: PUSH
3312: LD_INT 3
3314: PUSH
3315: LD_INT 3
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: LIST
3322: PUSH
3323: LD_OWVAR 67
3327: ARRAY
3328: ST_TO_ADDR
// hc_gallery :=  ;
3329: LD_ADDR_OWVAR 33
3333: PUSH
3334: LD_STRING 
3336: ST_TO_ADDR
// hc_name :=  ;
3337: LD_ADDR_OWVAR 26
3341: PUSH
3342: LD_STRING 
3344: ST_TO_ADDR
// hc_importance := 0 ;
3345: LD_ADDR_OWVAR 32
3349: PUSH
3350: LD_INT 0
3352: ST_TO_ADDR
// case player [ 1 ] of gladkov :
3353: LD_EXP 18
3357: PUSH
3358: LD_INT 1
3360: ARRAY
3361: PUSH
3362: LD_EXP 19
3366: DOUBLE
3367: EQUAL
3368: IFTRUE 3372
3370: GO 3517
3372: POP
// begin for i = 1 to 10 do
3373: LD_ADDR_VAR 0 2
3377: PUSH
3378: DOUBLE
3379: LD_INT 1
3381: DEC
3382: ST_TO_ADDR
3383: LD_INT 10
3385: PUSH
3386: FOR_TO
3387: IFFALSE 3426
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3389: LD_INT 0
3391: PPUSH
3392: LD_INT 1
3394: PPUSH
3395: LD_VAR 0 3
3399: PUSH
3400: LD_INT 1
3402: PLUS
3403: PPUSH
3404: CALL_OW 380
// team := team ^ CreateHuman ;
3408: LD_ADDR_VAR 0 5
3412: PUSH
3413: LD_VAR 0 5
3417: PUSH
3418: CALL_OW 44
3422: ADD
3423: ST_TO_ADDR
// end ;
3424: GO 3386
3426: POP
3427: POP
// for i = 1 to 15 do
3428: LD_ADDR_VAR 0 2
3432: PUSH
3433: DOUBLE
3434: LD_INT 1
3436: DEC
3437: ST_TO_ADDR
3438: LD_INT 15
3440: PUSH
3441: FOR_TO
3442: IFFALSE 3487
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3444: LD_INT 0
3446: PPUSH
3447: LD_VAR 0 2
3451: PUSH
3452: LD_INT 3
3454: MOD
3455: PUSH
3456: LD_INT 2
3458: PLUS
3459: PPUSH
3460: LD_VAR 0 3
3464: PPUSH
3465: CALL_OW 380
// team := team ^ CreateHuman ;
3469: LD_ADDR_VAR 0 5
3473: PUSH
3474: LD_VAR 0 5
3478: PUSH
3479: CALL_OW 44
3483: ADD
3484: ST_TO_ADDR
// end ;
3485: GO 3441
3487: POP
3488: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3489: LD_INT 44
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: LD_INT 1
3497: PPUSH
3498: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3502: LD_INT 34
3504: PPUSH
3505: LD_INT 3
3507: PPUSH
3508: LD_INT 1
3510: PPUSH
3511: CALL_OW 322
// end ; davidov :
3515: GO 4400
3517: LD_EXP 20
3521: DOUBLE
3522: EQUAL
3523: IFTRUE 3527
3525: GO 3802
3527: POP
// begin for i = 1 to 10 do
3528: LD_ADDR_VAR 0 2
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_INT 10
3540: PUSH
3541: FOR_TO
3542: IFFALSE 3581
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3544: LD_INT 0
3546: PPUSH
3547: LD_INT 4
3549: PPUSH
3550: LD_VAR 0 3
3554: PUSH
3555: LD_INT 1
3557: PLUS
3558: PPUSH
3559: CALL_OW 380
// team := team ^ CreateHuman ;
3563: LD_ADDR_VAR 0 5
3567: PUSH
3568: LD_VAR 0 5
3572: PUSH
3573: CALL_OW 44
3577: ADD
3578: ST_TO_ADDR
// end ;
3579: GO 3541
3581: POP
3582: POP
// for i = 1 to 15 do
3583: LD_ADDR_VAR 0 2
3587: PUSH
3588: DOUBLE
3589: LD_INT 1
3591: DEC
3592: ST_TO_ADDR
3593: LD_INT 15
3595: PUSH
3596: FOR_TO
3597: IFFALSE 3642
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3599: LD_INT 0
3601: PPUSH
3602: LD_VAR 0 2
3606: PUSH
3607: LD_INT 3
3609: MOD
3610: PUSH
3611: LD_INT 1
3613: PLUS
3614: PPUSH
3615: LD_VAR 0 3
3619: PPUSH
3620: CALL_OW 380
// team := team ^ CreateHuman ;
3624: LD_ADDR_VAR 0 5
3628: PUSH
3629: LD_VAR 0 5
3633: PUSH
3634: CALL_OW 44
3638: ADD
3639: ST_TO_ADDR
// end ;
3640: GO 3596
3642: POP
3643: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3644: LD_INT 34
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3657: LD_INT 32
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3670: LD_INT 27
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3683: LD_INT 30
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3696: LD_INT 63
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3709: LD_INT 57
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3722: LD_INT 58
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3735: LD_INT 8
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3748: LD_INT 12
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3761: LD_INT 14
3763: PPUSH
3764: LD_INT 3
3766: PPUSH
3767: LD_INT 1
3769: PPUSH
3770: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3774: LD_INT 24
3776: PPUSH
3777: LD_INT 3
3779: PPUSH
3780: LD_INT 1
3782: PPUSH
3783: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3787: LD_INT 33
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: LD_INT 1
3795: PPUSH
3796: CALL_OW 324
// end ; gorki :
3800: GO 4400
3802: LD_EXP 21
3806: DOUBLE
3807: EQUAL
3808: IFTRUE 3812
3810: GO 4093
3812: POP
// begin for i = 1 to 10 do
3813: LD_ADDR_VAR 0 2
3817: PUSH
3818: DOUBLE
3819: LD_INT 1
3821: DEC
3822: ST_TO_ADDR
3823: LD_INT 10
3825: PUSH
3826: FOR_TO
3827: IFFALSE 3881
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3829: LD_INT 0
3831: PPUSH
3832: LD_INT 3
3834: PPUSH
3835: LD_VAR 0 3
3839: PUSH
3840: LD_INT 1
3842: PLUS
3843: PPUSH
3844: CALL_OW 380
// team := team ^ CreateHuman ;
3848: LD_ADDR_VAR 0 5
3852: PUSH
3853: LD_VAR 0 5
3857: PUSH
3858: CALL_OW 44
3862: ADD
3863: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3864: LD_VAR 0 5
3868: PUSH
3869: LD_VAR 0 5
3873: ARRAY
3874: PPUSH
3875: CALL 7720 0 1
// end ;
3879: GO 3826
3881: POP
3882: POP
// for i = 1 to 15 do
3883: LD_ADDR_VAR 0 2
3887: PUSH
3888: DOUBLE
3889: LD_INT 1
3891: DEC
3892: ST_TO_ADDR
3893: LD_INT 15
3895: PUSH
3896: FOR_TO
3897: IFFALSE 3970
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3899: LD_INT 0
3901: PPUSH
3902: LD_INT 1
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: LD_INT 4
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: LIST
3915: PUSH
3916: LD_INT 1
3918: PPUSH
3919: LD_INT 3
3921: PPUSH
3922: CALL_OW 12
3926: ARRAY
3927: PPUSH
3928: LD_VAR 0 3
3932: PPUSH
3933: CALL_OW 380
// team := team ^ CreateHuman ;
3937: LD_ADDR_VAR 0 5
3941: PUSH
3942: LD_VAR 0 5
3946: PUSH
3947: CALL_OW 44
3951: ADD
3952: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3953: LD_VAR 0 5
3957: PUSH
3958: LD_VAR 0 5
3962: ARRAY
3963: PPUSH
3964: CALL 7720 0 1
// end ;
3968: GO 3896
3970: POP
3971: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3972: LD_INT 40
3974: PPUSH
3975: LD_INT 3
3977: PPUSH
3978: LD_INT 1
3980: PPUSH
3981: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3985: LD_INT 34
3987: PPUSH
3988: LD_INT 3
3990: PPUSH
3991: LD_INT 1
3993: PPUSH
3994: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3998: LD_INT 18
4000: PPUSH
4001: LD_INT 3
4003: PPUSH
4004: LD_INT 1
4006: PPUSH
4007: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
4011: LD_ADDR_OWVAR 37
4015: PUSH
4016: LD_INT 22
4018: ST_TO_ADDR
// vc_engine := engine_combustion ;
4019: LD_ADDR_OWVAR 39
4023: PUSH
4024: LD_INT 1
4026: ST_TO_ADDR
// vc_control := control_manual ;
4027: LD_ADDR_OWVAR 38
4031: PUSH
4032: LD_INT 1
4034: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
4035: LD_ADDR_OWVAR 40
4039: PUSH
4040: LD_INT 45
4042: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4043: LD_ADDR_OWVAR 41
4047: PUSH
4048: LD_INT 3
4050: ST_TO_ADDR
// veh := CreateVehicle ;
4051: LD_ADDR_VAR 0 6
4055: PUSH
4056: CALL_OW 45
4060: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4061: LD_VAR 0 6
4065: PPUSH
4066: LD_INT 1
4068: PPUSH
4069: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4073: LD_VAR 0 6
4077: PPUSH
4078: LD_INT 107
4080: PPUSH
4081: LD_INT 83
4083: PPUSH
4084: LD_INT 0
4086: PPUSH
4087: CALL_OW 48
// end ; stolypin :
4091: GO 4400
4093: LD_EXP 22
4097: DOUBLE
4098: EQUAL
4099: IFTRUE 4103
4101: GO 4399
4103: POP
// begin for i = 1 to 10 do
4104: LD_ADDR_VAR 0 2
4108: PUSH
4109: DOUBLE
4110: LD_INT 1
4112: DEC
4113: ST_TO_ADDR
4114: LD_INT 10
4116: PUSH
4117: FOR_TO
4118: IFFALSE 4157
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4120: LD_INT 0
4122: PPUSH
4123: LD_INT 2
4125: PPUSH
4126: LD_VAR 0 3
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PPUSH
4135: CALL_OW 380
// team := team ^ CreateHuman ;
4139: LD_ADDR_VAR 0 5
4143: PUSH
4144: LD_VAR 0 5
4148: PUSH
4149: CALL_OW 44
4153: ADD
4154: ST_TO_ADDR
// end ;
4155: GO 4117
4157: POP
4158: POP
// for i = 1 to 15 do
4159: LD_ADDR_VAR 0 2
4163: PUSH
4164: DOUBLE
4165: LD_INT 1
4167: DEC
4168: ST_TO_ADDR
4169: LD_INT 15
4171: PUSH
4172: FOR_TO
4173: IFFALSE 4231
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4175: LD_INT 0
4177: PPUSH
4178: LD_INT 1
4180: PUSH
4181: LD_INT 3
4183: PUSH
4184: LD_INT 4
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: LIST
4191: PUSH
4192: LD_INT 1
4194: PPUSH
4195: LD_INT 3
4197: PPUSH
4198: CALL_OW 12
4202: ARRAY
4203: PPUSH
4204: LD_VAR 0 3
4208: PPUSH
4209: CALL_OW 380
// team := team ^ CreateHuman ;
4213: LD_ADDR_VAR 0 5
4217: PUSH
4218: LD_VAR 0 5
4222: PUSH
4223: CALL_OW 44
4227: ADD
4228: ST_TO_ADDR
// end ;
4229: GO 4172
4231: POP
4232: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4233: LD_INT 34
4235: PPUSH
4236: LD_INT 3
4238: PPUSH
4239: LD_INT 1
4241: PPUSH
4242: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4246: LD_ADDR_OWVAR 37
4250: PUSH
4251: LD_INT 22
4253: ST_TO_ADDR
// vc_engine := engine_combustion ;
4254: LD_ADDR_OWVAR 39
4258: PUSH
4259: LD_INT 1
4261: ST_TO_ADDR
// vc_control := control_manual ;
4262: LD_ADDR_OWVAR 38
4266: PUSH
4267: LD_INT 1
4269: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4270: LD_ADDR_OWVAR 40
4274: PUSH
4275: LD_INT 51
4277: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4278: LD_ADDR_OWVAR 41
4282: PUSH
4283: LD_INT 30
4285: ST_TO_ADDR
// veh := CreateVehicle ;
4286: LD_ADDR_VAR 0 6
4290: PUSH
4291: CALL_OW 45
4295: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4296: LD_VAR 0 6
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: LD_INT 100
4306: PPUSH
4307: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4311: LD_VAR 0 6
4315: PPUSH
4316: LD_INT 107
4318: PPUSH
4319: LD_INT 83
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4329: LD_ADDR_OWVAR 37
4333: PUSH
4334: LD_INT 22
4336: ST_TO_ADDR
// vc_engine := engine_combustion ;
4337: LD_ADDR_OWVAR 39
4341: PUSH
4342: LD_INT 1
4344: ST_TO_ADDR
// vc_control := control_manual ;
4345: LD_ADDR_OWVAR 38
4349: PUSH
4350: LD_INT 1
4352: ST_TO_ADDR
// vc_weapon := ru_crane ;
4353: LD_ADDR_OWVAR 40
4357: PUSH
4358: LD_INT 52
4360: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4361: LD_ADDR_OWVAR 41
4365: PUSH
4366: LD_INT 30
4368: ST_TO_ADDR
// veh := CreateVehicle ;
4369: LD_ADDR_VAR 0 6
4373: PUSH
4374: CALL_OW 45
4378: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4379: LD_VAR 0 6
4383: PPUSH
4384: LD_INT 115
4386: PPUSH
4387: LD_INT 96
4389: PPUSH
4390: LD_INT 0
4392: PPUSH
4393: CALL_OW 48
// end ; end ;
4397: GO 4400
4399: POP
// if isTest then
4400: LD_EXP 1
4404: IFFALSE 4418
// tmp := team else
4406: LD_ADDR_VAR 0 4
4410: PUSH
4411: LD_VAR 0 5
4415: ST_TO_ADDR
4416: GO 4482
// tmp := CharacterSelection ( text , 12 , 12 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4418: LD_ADDR_VAR 0 4
4422: PUSH
4423: LD_STRING text
4425: PPUSH
4426: LD_INT 12
4428: PPUSH
4429: LD_INT 12
4431: PPUSH
4432: LD_INT -2
4434: PUSH
4435: LD_INT -5
4437: PUSH
4438: LD_INT -3
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: PUSH
4446: LD_VAR 0 5
4450: ADD
4451: PPUSH
4452: LD_INT 1
4454: PUSH
4455: LD_INT 2
4457: PUSH
4458: LD_INT 1
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 3
4467: PUSH
4468: LD_INT 4
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: LIST
4475: LIST
4476: PPUSH
4477: CALL_OW 42
4481: ST_TO_ADDR
// PlaceUnitArea ( player [ 1 ] , gaidar_base , false ) ;
4482: LD_EXP 18
4486: PUSH
4487: LD_INT 1
4489: ARRAY
4490: PPUSH
4491: LD_INT 9
4493: PPUSH
4494: LD_INT 0
4496: PPUSH
4497: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4501: LD_VAR 0 4
4505: PUSH
4506: LD_INT 1
4508: ARRAY
4509: PPUSH
4510: LD_INT 2
4512: PPUSH
4513: CALL_OW 336
// for i = 1 to tmp do
4517: LD_ADDR_VAR 0 2
4521: PUSH
4522: DOUBLE
4523: LD_INT 1
4525: DEC
4526: ST_TO_ADDR
4527: LD_VAR 0 4
4531: PUSH
4532: FOR_TO
4533: IFFALSE 4588
// if i < 4 then
4535: LD_VAR 0 2
4539: PUSH
4540: LD_INT 4
4542: LESS
4543: IFFALSE 4568
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4545: LD_VAR 0 4
4549: PUSH
4550: LD_VAR 0 2
4554: ARRAY
4555: PPUSH
4556: LD_INT 9
4558: PPUSH
4559: LD_INT 0
4561: PPUSH
4562: CALL_OW 49
4566: GO 4586
// SetSide ( tmp [ i ] , 6 ) ;
4568: LD_VAR 0 4
4572: PUSH
4573: LD_VAR 0 2
4577: ARRAY
4578: PPUSH
4579: LD_INT 6
4581: PPUSH
4582: CALL_OW 235
4586: GO 4532
4588: POP
4589: POP
// player_squad := tmp ;
4590: LD_ADDR_EXP 23
4594: PUSH
4595: LD_VAR 0 4
4599: ST_TO_ADDR
// pl_counter := 4 ;
4600: LD_ADDR_EXP 24
4604: PUSH
4605: LD_INT 4
4607: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4608: LD_INT 17
4610: PPUSH
4611: LD_INT 5
4613: PPUSH
4614: LD_INT 1
4616: PPUSH
4617: CALL 18161 0 3
// end ;
4621: LD_VAR 0 1
4625: RET
// export Popov ; export function InitAction ; begin
4626: LD_INT 0
4628: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4629: LD_INT 6
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4639: LD_INT 1
4641: PPUSH
4642: LD_INT 1
4644: PPUSH
4645: CALL_OW 86
// uc_side := 6 ;
4649: LD_ADDR_OWVAR 20
4653: PUSH
4654: LD_INT 6
4656: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4657: LD_ADDR_EXP 26
4661: PUSH
4662: LD_STRING Popov
4664: PPUSH
4665: CALL_OW 25
4669: ST_TO_ADDR
// case query ( textdiff ) of 1 :
4670: LD_STRING textdiff
4672: PPUSH
4673: CALL_OW 97
4677: PUSH
4678: LD_INT 1
4680: DOUBLE
4681: EQUAL
4682: IFTRUE 4686
4684: GO 4697
4686: POP
// Difficulty := 1 ; 2 :
4687: LD_ADDR_OWVAR 67
4691: PUSH
4692: LD_INT 1
4694: ST_TO_ADDR
4695: GO 4736
4697: LD_INT 2
4699: DOUBLE
4700: EQUAL
4701: IFTRUE 4705
4703: GO 4716
4705: POP
// Difficulty := 2 ; 3 :
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
4714: GO 4736
4716: LD_INT 3
4718: DOUBLE
4719: EQUAL
4720: IFTRUE 4724
4722: GO 4735
4724: POP
// Difficulty := 3 ; end ;
4725: LD_ADDR_OWVAR 67
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
4733: GO 4736
4735: POP
// case query ( choosecom ) of 1 :
4736: LD_STRING choosecom
4738: PPUSH
4739: CALL_OW 97
4743: PUSH
4744: LD_INT 1
4746: DOUBLE
4747: EQUAL
4748: IFTRUE 4752
4750: GO 4759
4752: POP
// InitCommanders ; end ;
4753: CALL 3137 0 0
4757: GO 4760
4759: POP
// end ;
4760: LD_VAR 0 1
4764: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4765: LD_EXP 24
4769: PUSH
4770: LD_INT 12
4772: LESS
4773: IFFALSE 4946
4775: GO 4777
4777: DISABLE
4778: LD_INT 0
4780: PPUSH
// begin enable ;
4781: ENABLE
// for i = pl_counter to pl_counter + 2 do
4782: LD_ADDR_VAR 0 1
4786: PUSH
4787: DOUBLE
4788: LD_EXP 24
4792: DEC
4793: ST_TO_ADDR
4794: LD_EXP 24
4798: PUSH
4799: LD_INT 2
4801: PLUS
4802: PUSH
4803: FOR_TO
4804: IFFALSE 4850
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4806: LD_EXP 23
4810: PUSH
4811: LD_VAR 0 1
4815: ARRAY
4816: PPUSH
4817: LD_INT 18
4819: PPUSH
4820: LD_INT 0
4822: PPUSH
4823: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4827: LD_EXP 23
4831: PUSH
4832: LD_VAR 0 1
4836: ARRAY
4837: PPUSH
4838: LD_INT 107
4840: PPUSH
4841: LD_INT 88
4843: PPUSH
4844: CALL_OW 111
// end ;
4848: GO 4803
4850: POP
4851: POP
// for i = pl_counter to pl_counter + 2 do
4852: LD_ADDR_VAR 0 1
4856: PUSH
4857: DOUBLE
4858: LD_EXP 24
4862: DEC
4863: ST_TO_ADDR
4864: LD_EXP 24
4868: PUSH
4869: LD_INT 2
4871: PLUS
4872: PUSH
4873: FOR_TO
4874: IFFALSE 4930
// begin repeat wait ( 0 0$01 ) ;
4876: LD_INT 35
4878: PPUSH
4879: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4883: LD_EXP 23
4887: PUSH
4888: LD_VAR 0 1
4892: ARRAY
4893: PPUSH
4894: LD_INT 107
4896: PPUSH
4897: LD_INT 88
4899: PPUSH
4900: CALL_OW 297
4904: PUSH
4905: LD_INT 6
4907: LESS
4908: IFFALSE 4876
// SetSide ( player_squad [ i ] , 3 ) ;
4910: LD_EXP 23
4914: PUSH
4915: LD_VAR 0 1
4919: ARRAY
4920: PPUSH
4921: LD_INT 3
4923: PPUSH
4924: CALL_OW 235
// end ;
4928: GO 4873
4930: POP
4931: POP
// pl_counter := pl_counter + 3 ;
4932: LD_ADDR_EXP 24
4936: PUSH
4937: LD_EXP 24
4941: PUSH
4942: LD_INT 3
4944: PLUS
4945: ST_TO_ADDR
// end ;
4946: PPOPN 1
4948: END
// export function Dialog ; begin
4949: LD_INT 0
4951: PPUSH
// if not isTest then
4952: LD_EXP 1
4956: NOT
4957: IFFALSE 4979
// case query ( task ) of 1 :
4959: LD_STRING task
4961: PPUSH
4962: CALL_OW 97
4966: PUSH
4967: LD_INT 1
4969: DOUBLE
4970: EQUAL
4971: IFTRUE 4975
4973: GO 4978
4975: POP
// ; end ;
4976: GO 4979
4978: POP
// InGameOn ;
4979: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4983: LD_INT 107
4985: PPUSH
4986: LD_INT 84
4988: PPUSH
4989: CALL_OW 86
// if isTest then
4993: LD_EXP 1
4997: IFFALSE 5007
// dialogue_skipped := true ;
4999: LD_ADDR_OWVAR 59
5003: PUSH
5004: LD_INT 1
5006: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
5007: LD_ADDR_EXP 11
5011: PUSH
5012: LD_EXP 23
5016: PUSH
5017: LD_INT 1
5019: ARRAY
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: LD_INT 96
5026: PPUSH
5027: LD_INT 79
5029: PPUSH
5030: LD_INT 2
5032: PPUSH
5033: CALL_OW 145
5037: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5038: LD_INT 35
5040: PPUSH
5041: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
5045: LD_EXP 26
5049: PPUSH
5050: LD_STRING DR1
5052: PPUSH
5053: CALL_OW 94
// Wait ( 0 0$01 ) ;
5057: LD_INT 35
5059: PPUSH
5060: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
5064: LD_EXP 26
5068: PPUSH
5069: LD_STRING DR2
5071: PPUSH
5072: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5076: LD_EXP 26
5080: PPUSH
5081: LD_STRING DR3
5083: PPUSH
5084: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5088: LD_INT 35
5090: PPUSH
5091: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5095: LD_INT 3
5097: PPUSH
5098: LD_INT 30
5100: PUSH
5101: LD_INT 0
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: PPUSH
5108: CALL 11448 0 2
5112: PUSH
5113: LD_EXP 1
5117: OR
5118: IFFALSE 5088
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5120: LD_INT 3
5122: PPUSH
5123: LD_INT 2
5125: PPUSH
5126: LD_INT 2
5128: PPUSH
5129: LD_EXP 11
5133: PPUSH
5134: CALL_OW 468
// InGameOff ;
5138: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5142: LD_STRING C1
5144: PPUSH
5145: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5149: LD_INT 35
5151: PPUSH
5152: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5156: LD_EXP 11
5160: PPUSH
5161: CALL_OW 461
5165: PUSH
5166: LD_INT 2
5168: EQUAL
5169: IFFALSE 5149
// if not isTest then
5171: LD_EXP 1
5175: NOT
5176: IFFALSE 5198
// case query ( support ) of 1 :
5178: LD_STRING support
5180: PPUSH
5181: CALL_OW 97
5185: PUSH
5186: LD_INT 1
5188: DOUBLE
5189: EQUAL
5190: IFTRUE 5194
5192: GO 5197
5194: POP
// ; end ;
5195: GO 5198
5197: POP
// if player_com = stolypin then
5198: LD_EXP 25
5202: PUSH
5203: LD_EXP 22
5207: EQUAL
5208: IFFALSE 5237
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5210: LD_INT 18
5212: PPUSH
5213: LD_INT 3
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: LD_INT 2
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: LIST
5226: PUSH
5227: LD_OWVAR 67
5231: ARRAY
5232: PPUSH
5233: CALL 6537 0 2
// end ;
5237: LD_VAR 0 1
5241: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5242: LD_EXP 12
5246: PUSH
5247: LD_OWVAR 1
5251: PUSH
5252: LD_INT 31500
5254: LESS
5255: AND
5256: IFFALSE 5420
// case query ( call1 ) of 1 :
5258: LD_STRING call1
5260: PPUSH
5261: CALL_OW 97
5265: PUSH
5266: LD_INT 1
5268: DOUBLE
5269: EQUAL
5270: IFTRUE 5274
5272: GO 5408
5274: POP
// begin SetArtifactUse ( 3 , art_exp_mid , art_gray , player_depot ) ;
5275: LD_INT 3
5277: PPUSH
5278: LD_INT 2
5280: PPUSH
5281: LD_INT 1
5283: PPUSH
5284: LD_EXP 11
5288: PPUSH
5289: CALL_OW 468
// call := false ;
5293: LD_ADDR_EXP 12
5297: PUSH
5298: LD_INT 0
5300: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5301: LD_EXP 26
5305: PPUSH
5306: LD_STRING DR6
5308: PPUSH
5309: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5313: LD_INT 6300
5315: PPUSH
5316: LD_INT 8400
5318: PPUSH
5319: CALL_OW 12
5323: PPUSH
5324: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5328: LD_INT 18
5330: PUSH
5331: LD_INT 19
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PUSH
5338: LD_INT 1
5340: PPUSH
5341: LD_INT 2
5343: PPUSH
5344: CALL_OW 12
5348: ARRAY
5349: PPUSH
5350: LD_INT 1
5352: PPUSH
5353: LD_INT 2
5355: PPUSH
5356: CALL_OW 12
5360: PPUSH
5361: CALL 6537 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5365: LD_INT 25200
5367: PPUSH
5368: LD_INT 35700
5370: PPUSH
5371: CALL_OW 12
5375: PPUSH
5376: CALL_OW 67
// call := true ;
5380: LD_ADDR_EXP 12
5384: PUSH
5385: LD_INT 1
5387: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5388: LD_INT 3
5390: PPUSH
5391: LD_INT 2
5393: PPUSH
5394: LD_INT 2
5396: PPUSH
5397: LD_EXP 11
5401: PPUSH
5402: CALL_OW 468
// end ; 2 :
5406: GO 5420
5408: LD_INT 2
5410: DOUBLE
5411: EQUAL
5412: IFTRUE 5416
5414: GO 5419
5416: POP
// ; end ;
5417: GO 5420
5419: POP
// if call and tick >= 15 15$00 then
5420: LD_EXP 12
5424: PUSH
5425: LD_OWVAR 1
5429: PUSH
5430: LD_INT 31500
5432: GREATEREQUAL
5433: AND
5434: IFFALSE 5863
// case query ( call2 ) of 1 :
5436: LD_STRING call2
5438: PPUSH
5439: CALL_OW 97
5443: PUSH
5444: LD_INT 1
5446: DOUBLE
5447: EQUAL
5448: IFTRUE 5452
5450: GO 5688
5452: POP
// begin call := false ;
5453: LD_ADDR_EXP 12
5457: PUSH
5458: LD_INT 0
5460: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5461: LD_INT 1
5463: PPUSH
5464: LD_INT 21
5466: PUSH
5467: LD_INT 3
5469: PUSH
5470: EMPTY
5471: LIST
5472: LIST
5473: PPUSH
5474: CALL 11448 0 2
5478: PUSH
5479: LD_INT 4
5481: PPUSH
5482: LD_INT 21
5484: PUSH
5485: LD_INT 3
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: PPUSH
5492: CALL 11448 0 2
5496: AND
5497: IFFALSE 5545
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5499: LD_INT 18
5501: PUSH
5502: LD_INT 19
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: PUSH
5509: LD_INT 1
5511: PPUSH
5512: LD_INT 2
5514: PPUSH
5515: CALL_OW 12
5519: ARRAY
5520: PPUSH
5521: LD_INT 5
5523: PUSH
5524: LD_INT 4
5526: PUSH
5527: LD_INT 4
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: PUSH
5535: LD_OWVAR 67
5539: ARRAY
5540: PPUSH
5541: CALL 6298 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5545: LD_INT 1
5547: PPUSH
5548: LD_INT 21
5550: PUSH
5551: LD_INT 3
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: PPUSH
5558: CALL 11448 0 2
5562: PUSH
5563: LD_INT 0
5565: EQUAL
5566: IFFALSE 5595
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5568: LD_INT 19
5570: PPUSH
5571: LD_INT 5
5573: PUSH
5574: LD_INT 4
5576: PUSH
5577: LD_INT 3
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: PUSH
5585: LD_OWVAR 67
5589: ARRAY
5590: PPUSH
5591: CALL 6298 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5595: LD_INT 4
5597: PPUSH
5598: LD_INT 21
5600: PUSH
5601: LD_INT 3
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PPUSH
5608: CALL 11448 0 2
5612: PUSH
5613: LD_INT 0
5615: EQUAL
5616: IFFALSE 5645
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5618: LD_INT 18
5620: PPUSH
5621: LD_INT 5
5623: PUSH
5624: LD_INT 4
5626: PUSH
5627: LD_INT 4
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: LIST
5634: PUSH
5635: LD_OWVAR 67
5639: ARRAY
5640: PPUSH
5641: CALL 6298 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5645: LD_INT 10500
5647: PPUSH
5648: LD_INT 23100
5650: PPUSH
5651: CALL_OW 12
5655: PPUSH
5656: CALL_OW 67
// call := true ;
5660: LD_ADDR_EXP 12
5664: PUSH
5665: LD_INT 1
5667: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5668: LD_INT 3
5670: PPUSH
5671: LD_INT 2
5673: PPUSH
5674: LD_INT 2
5676: PPUSH
5677: LD_EXP 11
5681: PPUSH
5682: CALL_OW 468
// end ; 2 :
5686: GO 5863
5688: LD_INT 2
5690: DOUBLE
5691: EQUAL
5692: IFTRUE 5696
5694: GO 5851
5696: POP
// begin SetArtifactUse ( 3 , art_exp_mid , art_gray , player_depot ) ;
5697: LD_INT 3
5699: PPUSH
5700: LD_INT 2
5702: PPUSH
5703: LD_INT 1
5705: PPUSH
5706: LD_EXP 11
5710: PPUSH
5711: CALL_OW 468
// call := false ;
5715: LD_ADDR_EXP 12
5719: PUSH
5720: LD_INT 0
5722: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5723: LD_EXP 26
5727: PPUSH
5728: LD_STRING DR6
5730: PPUSH
5731: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5735: LD_INT 6300
5737: PPUSH
5738: LD_INT 8400
5740: PPUSH
5741: CALL_OW 12
5745: PPUSH
5746: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5750: LD_INT 18
5752: PUSH
5753: LD_INT 19
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: PUSH
5760: LD_INT 1
5762: PPUSH
5763: LD_INT 2
5765: PPUSH
5766: CALL_OW 12
5770: ARRAY
5771: PPUSH
5772: LD_INT 3
5774: PUSH
5775: LD_INT 2
5777: PUSH
5778: LD_INT 2
5780: PUSH
5781: EMPTY
5782: LIST
5783: LIST
5784: LIST
5785: PUSH
5786: LD_OWVAR 67
5790: ARRAY
5791: PUSH
5792: LD_INT 0
5794: PPUSH
5795: LD_INT 1
5797: PPUSH
5798: CALL_OW 12
5802: MINUS
5803: PPUSH
5804: CALL 6537 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5808: LD_INT 35700
5810: PPUSH
5811: LD_INT 44100
5813: PPUSH
5814: CALL_OW 12
5818: PPUSH
5819: CALL_OW 67
// call := true ;
5823: LD_ADDR_EXP 12
5827: PUSH
5828: LD_INT 1
5830: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5831: LD_INT 3
5833: PPUSH
5834: LD_INT 2
5836: PPUSH
5837: LD_INT 2
5839: PPUSH
5840: LD_EXP 11
5844: PPUSH
5845: CALL_OW 468
// end ; 3 :
5849: GO 5863
5851: LD_INT 3
5853: DOUBLE
5854: EQUAL
5855: IFTRUE 5859
5857: GO 5862
5859: POP
// ; end ;
5860: GO 5863
5862: POP
// end ;
5863: PPOPN 4
5865: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5866: LD_INT 22
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: LD_INT 21
5878: PUSH
5879: LD_INT 1
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: PUSH
5886: EMPTY
5887: LIST
5888: LIST
5889: PPUSH
5890: CALL_OW 69
5894: PUSH
5895: LD_INT 0
5897: EQUAL
5898: PUSH
5899: LD_INT 22
5901: PUSH
5902: LD_INT 4
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PUSH
5909: LD_INT 21
5911: PUSH
5912: LD_INT 1
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: PPUSH
5923: CALL_OW 69
5927: PUSH
5928: LD_INT 0
5930: EQUAL
5931: AND
5932: IFFALSE 6136
5934: GO 5936
5936: DISABLE
// begin DialogueOn ;
5937: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5941: LD_EXP 26
5945: PPUSH
5946: LD_STRING DR7
5948: PPUSH
5949: CALL_OW 94
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
5953: LD_OWVAR 1
5957: PUSH
5958: LD_INT 116550
5960: PUSH
5961: LD_INT 95550
5963: PUSH
5964: LD_INT 89250
5966: PUSH
5967: EMPTY
5968: LIST
5969: LIST
5970: LIST
5971: PUSH
5972: LD_OWVAR 67
5976: ARRAY
5977: LESS
5978: IFFALSE 5992
// AddMedal ( med1 , 1 ) else
5980: LD_STRING med1
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL_OW 101
5990: GO 6003
// AddMedal ( med1 , - 1 ) ;
5992: LD_STRING med1
5994: PPUSH
5995: LD_INT 1
5997: NEG
5998: PPUSH
5999: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6003: LD_INT 81
6005: PUSH
6006: LD_INT 3
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: PUSH
6013: LD_INT 21
6015: PUSH
6016: LD_INT 3
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: EMPTY
6024: LIST
6025: LIST
6026: PPUSH
6027: CALL_OW 69
6031: PUSH
6032: LD_INT 0
6034: EQUAL
6035: IFFALSE 6049
// AddMedal ( med3 , 1 ) else
6037: LD_STRING med3
6039: PPUSH
6040: LD_INT 1
6042: PPUSH
6043: CALL_OW 101
6047: GO 6060
// AddMedal ( med3 , - 1 ) ;
6049: LD_STRING med3
6051: PPUSH
6052: LD_INT 1
6054: NEG
6055: PPUSH
6056: CALL_OW 101
// if player_squad = 15 then
6060: LD_EXP 23
6064: PUSH
6065: LD_INT 15
6067: EQUAL
6068: IFFALSE 6082
// AddMedal ( med2 , 1 ) else
6070: LD_STRING med2
6072: PPUSH
6073: LD_INT 1
6075: PPUSH
6076: CALL_OW 101
6080: GO 6125
// if player_squad > 12 and player_squad < 15 then
6082: LD_EXP 23
6086: PUSH
6087: LD_INT 12
6089: GREATER
6090: PUSH
6091: LD_EXP 23
6095: PUSH
6096: LD_INT 15
6098: LESS
6099: AND
6100: IFFALSE 6114
// AddMedal ( med2 , 2 ) else
6102: LD_STRING med2
6104: PPUSH
6105: LD_INT 2
6107: PPUSH
6108: CALL_OW 101
6112: GO 6125
// AddMedal ( med2 , - 1 ) ;
6114: LD_STRING med2
6116: PPUSH
6117: LD_INT 1
6119: NEG
6120: PPUSH
6121: CALL_OW 101
// GiveMedals ( MAIN ) ;
6125: LD_STRING MAIN
6127: PPUSH
6128: CALL_OW 102
// YouWin ;
6132: CALL_OW 103
// end ;
6136: END
// every 0 0$01 trigger IsDead ( player_com ) do
6137: LD_EXP 25
6141: PPUSH
6142: CALL_OW 301
6146: IFFALSE 6213
6148: GO 6150
6150: DISABLE
// begin if IsLive ( Houten ) then
6151: LD_EXP 3
6155: PPUSH
6156: CALL_OW 300
6160: IFFALSE 6176
// SayRadio ( Houten , DJ5 ) else
6162: LD_EXP 3
6166: PPUSH
6167: LD_STRING DJ5
6169: PPUSH
6170: CALL_OW 94
6174: GO 6199
// if IsLive ( Brown ) then
6176: LD_EXP 4
6180: PPUSH
6181: CALL_OW 300
6185: IFFALSE 6199
// SayRadio ( Brown , DS5 ) ;
6187: LD_EXP 4
6191: PPUSH
6192: LD_STRING DS5
6194: PPUSH
6195: CALL_OW 94
// Wait ( 0 0$01 ) ;
6199: LD_INT 35
6201: PPUSH
6202: CALL_OW 67
// YouLost ( dead ) ;
6206: LD_STRING dead
6208: PPUSH
6209: CALL_OW 104
// end ;
6213: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6214: LD_EXP 11
6218: PPUSH
6219: CALL_OW 301
6223: PUSH
6224: LD_EXP 1
6228: NOT
6229: AND
6230: IFFALSE 6297
6232: GO 6234
6234: DISABLE
// begin if IsLive ( Brown ) then
6235: LD_EXP 4
6239: PPUSH
6240: CALL_OW 300
6244: IFFALSE 6260
// SayRadio ( Brown , DS5 ) else
6246: LD_EXP 4
6250: PPUSH
6251: LD_STRING DS5
6253: PPUSH
6254: CALL_OW 94
6258: GO 6283
// if IsLive ( Houten ) then
6260: LD_EXP 3
6264: PPUSH
6265: CALL_OW 300
6269: IFFALSE 6283
// SayRadio ( Houten , DJ5 ) ;
6271: LD_EXP 3
6275: PPUSH
6276: LD_STRING DJ5
6278: PPUSH
6279: CALL_OW 94
// Wait ( 0 0$01 ) ;
6283: LD_INT 35
6285: PPUSH
6286: CALL_OW 67
// YouLost ( depot ) ;
6290: LD_STRING depot
6292: PPUSH
6293: CALL_OW 104
// end ;
6297: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6298: LD_INT 0
6300: PPUSH
6301: PPUSH
6302: PPUSH
// for i = 1 to n do
6303: LD_ADDR_VAR 0 4
6307: PUSH
6308: DOUBLE
6309: LD_INT 1
6311: DEC
6312: ST_TO_ADDR
6313: LD_VAR 0 2
6317: PUSH
6318: FOR_TO
6319: IFFALSE 6522
// begin uc_side := 6 ;
6321: LD_ADDR_OWVAR 20
6325: PUSH
6326: LD_INT 6
6328: ST_TO_ADDR
// uc_nation := 3 ;
6329: LD_ADDR_OWVAR 21
6333: PUSH
6334: LD_INT 3
6336: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6337: LD_ADDR_OWVAR 37
6341: PUSH
6342: LD_INT 23
6344: PUSH
6345: LD_INT 22
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: PUSH
6352: LD_INT 1
6354: PPUSH
6355: LD_INT 2
6357: PPUSH
6358: CALL_OW 12
6362: ARRAY
6363: ST_TO_ADDR
// vc_control := control_computer ;
6364: LD_ADDR_OWVAR 38
6368: PUSH
6369: LD_INT 3
6371: ST_TO_ADDR
// vc_engine := engine_siberite ;
6372: LD_ADDR_OWVAR 39
6376: PUSH
6377: LD_INT 3
6379: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6380: LD_ADDR_OWVAR 40
6384: PUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 44
6390: PUSH
6391: LD_INT 44
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_INT 3
6404: PPUSH
6405: CALL_OW 12
6409: ARRAY
6410: ST_TO_ADDR
// un := CreateVehicle ;
6411: LD_ADDR_VAR 0 5
6415: PUSH
6416: CALL_OW 45
6420: ST_TO_ADDR
// case area of east_arr :
6421: LD_VAR 0 1
6425: PUSH
6426: LD_INT 18
6428: DOUBLE
6429: EQUAL
6430: IFTRUE 6434
6432: GO 6469
6434: POP
// begin PlaceUnitArea ( un , area , false ) ;
6435: LD_VAR 0 5
6439: PPUSH
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 0
6447: PPUSH
6448: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6452: LD_VAR 0 5
6456: PPUSH
6457: LD_INT 79
6459: PPUSH
6460: LD_INT 33
6462: PPUSH
6463: CALL_OW 111
// end ; south_arr :
6467: GO 6513
6469: LD_INT 19
6471: DOUBLE
6472: EQUAL
6473: IFTRUE 6477
6475: GO 6512
6477: POP
// begin PlaceUnitArea ( un , area , false ) ;
6478: LD_VAR 0 5
6482: PPUSH
6483: LD_VAR 0 1
6487: PPUSH
6488: LD_INT 0
6490: PPUSH
6491: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6495: LD_VAR 0 5
6499: PPUSH
6500: LD_INT 131
6502: PPUSH
6503: LD_INT 148
6505: PPUSH
6506: CALL_OW 111
// end ; end ;
6510: GO 6513
6512: POP
// Wait ( 0 0$02 ) ;
6513: LD_INT 70
6515: PPUSH
6516: CALL_OW 67
// end ;
6520: GO 6318
6522: POP
6523: POP
// pink_attack := true ;
6524: LD_ADDR_EXP 13
6528: PUSH
6529: LD_INT 1
6531: ST_TO_ADDR
// end ;
6532: LD_VAR 0 3
6536: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6537: LD_INT 0
6539: PPUSH
6540: PPUSH
6541: PPUSH
// for i = 1 to n do
6542: LD_ADDR_VAR 0 4
6546: PUSH
6547: DOUBLE
6548: LD_INT 1
6550: DEC
6551: ST_TO_ADDR
6552: LD_VAR 0 2
6556: PUSH
6557: FOR_TO
6558: IFFALSE 6784
// begin uc_side := 6 ;
6560: LD_ADDR_OWVAR 20
6564: PUSH
6565: LD_INT 6
6567: ST_TO_ADDR
// uc_nation := 3 ;
6568: LD_ADDR_OWVAR 21
6572: PUSH
6573: LD_INT 3
6575: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6576: LD_INT 0
6578: PPUSH
6579: LD_INT 3
6581: PPUSH
6582: LD_INT 4
6584: PPUSH
6585: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6589: LD_ADDR_OWVAR 37
6593: PUSH
6594: LD_INT 22
6596: ST_TO_ADDR
// vc_control := control_manual ;
6597: LD_ADDR_OWVAR 38
6601: PUSH
6602: LD_INT 1
6604: ST_TO_ADDR
// vc_engine := engine_combustion ;
6605: LD_ADDR_OWVAR 39
6609: PUSH
6610: LD_INT 1
6612: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6613: LD_ADDR_OWVAR 40
6617: PUSH
6618: LD_INT 51
6620: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6621: LD_ADDR_OWVAR 41
6625: PUSH
6626: LD_INT 50
6628: ST_TO_ADDR
// un := CreateVehicle ;
6629: LD_ADDR_VAR 0 5
6633: PUSH
6634: CALL_OW 45
6638: ST_TO_ADDR
// case area of east_arr :
6639: LD_VAR 0 1
6643: PUSH
6644: LD_INT 18
6646: DOUBLE
6647: EQUAL
6648: IFTRUE 6652
6650: GO 6667
6652: POP
// SetDir ( un , 4 ) ; south_arr :
6653: LD_VAR 0 5
6657: PPUSH
6658: LD_INT 4
6660: PPUSH
6661: CALL_OW 233
6665: GO 6691
6667: LD_INT 19
6669: DOUBLE
6670: EQUAL
6671: IFTRUE 6675
6673: GO 6690
6675: POP
// SetDir ( un , 5 ) ; end ;
6676: LD_VAR 0 5
6680: PPUSH
6681: LD_INT 5
6683: PPUSH
6684: CALL_OW 233
6688: GO 6691
6690: POP
// PlaceUnitArea ( un , area , false ) ;
6691: LD_VAR 0 5
6695: PPUSH
6696: LD_VAR 0 1
6700: PPUSH
6701: LD_INT 0
6703: PPUSH
6704: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6708: CALL_OW 44
6712: PPUSH
6713: LD_VAR 0 5
6717: PPUSH
6718: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6722: LD_VAR 0 5
6726: PPUSH
6727: LD_INT 1
6729: PPUSH
6730: LD_INT 100
6732: PPUSH
6733: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6737: LD_VAR 0 5
6741: PPUSH
6742: LD_INT 106
6744: PPUSH
6745: LD_INT 88
6747: PPUSH
6748: CALL_OW 111
// AddComUnload ( un ) ;
6752: LD_VAR 0 5
6756: PPUSH
6757: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6761: LD_VAR 0 5
6765: PPUSH
6766: LD_VAR 0 1
6770: PPUSH
6771: CALL_OW 173
// Wait ( 0 0$02 ) ;
6775: LD_INT 70
6777: PPUSH
6778: CALL_OW 67
// end ;
6782: GO 6557
6784: POP
6785: POP
// Wait ( 0 0$05 ) ;
6786: LD_INT 175
6788: PPUSH
6789: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6793: LD_INT 6
6795: PPUSH
6796: LD_INT 34
6798: PUSH
6799: LD_INT 51
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: PPUSH
6806: CALL 11448 0 2
6810: IFFALSE 6998
// begin wait ( 0 0$01 ) ;
6812: LD_INT 35
6814: PPUSH
6815: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6819: LD_ADDR_VAR 0 4
6823: PUSH
6824: LD_INT 6
6826: PPUSH
6827: LD_INT 34
6829: PUSH
6830: LD_INT 51
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: PPUSH
6837: CALL 11448 0 2
6841: PUSH
6842: FOR_IN
6843: IFFALSE 6994
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6845: LD_VAR 0 4
6849: PPUSH
6850: LD_INT 9
6852: PPUSH
6853: CALL_OW 308
6857: PUSH
6858: LD_VAR 0 4
6862: PPUSH
6863: CALL 31576 0 1
6867: PPUSH
6868: CALL_OW 258
6872: PUSH
6873: LD_INT 1
6875: EQUAL
6876: AND
6877: PUSH
6878: LD_EXP 10
6882: AND
6883: IFFALSE 6910
// begin Say ( GetDriver ( i ) , Dtran ) ;
6885: LD_VAR 0 4
6889: PPUSH
6890: CALL 31576 0 1
6894: PPUSH
6895: LD_STRING Dtran
6897: PPUSH
6898: CALL_OW 88
// dialog_trans := false ;
6902: LD_ADDR_EXP 10
6906: PUSH
6907: LD_INT 0
6909: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6910: LD_VAR 0 4
6914: PPUSH
6915: CALL_OW 316
6919: IFFALSE 6935
// ComMoveToArea ( i , area ) ;
6921: LD_VAR 0 4
6925: PPUSH
6926: LD_VAR 0 1
6930: PPUSH
6931: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6935: LD_VAR 0 4
6939: PPUSH
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 308
6949: PUSH
6950: LD_VAR 0 4
6954: PPUSH
6955: LD_INT 1
6957: PPUSH
6958: CALL_OW 289
6962: PUSH
6963: LD_INT 0
6965: EQUAL
6966: AND
6967: IFFALSE 6992
// begin RemoveUnit ( GetDriver ( i ) ) ;
6969: LD_VAR 0 4
6973: PPUSH
6974: CALL 31576 0 1
6978: PPUSH
6979: CALL_OW 64
// RemoveUnit ( i ) ;
6983: LD_VAR 0 4
6987: PPUSH
6988: CALL_OW 64
// end ; end ;
6992: GO 6842
6994: POP
6995: POP
// end ;
6996: GO 6793
// end ;
6998: LD_VAR 0 3
7002: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7003: LD_INT 0
7005: PPUSH
7006: PPUSH
7007: PPUSH
7008: PPUSH
// if isTest then
7009: LD_EXP 1
7013: IFFALSE 7017
// exit ;
7015: GO 7406
// for i = 1 to n do
7017: LD_ADDR_VAR 0 4
7021: PUSH
7022: DOUBLE
7023: LD_INT 1
7025: DEC
7026: ST_TO_ADDR
7027: LD_VAR 0 2
7031: PUSH
7032: FOR_TO
7033: IFFALSE 7265
// begin uc_side := 8 ;
7035: LD_ADDR_OWVAR 20
7039: PUSH
7040: LD_INT 8
7042: ST_TO_ADDR
// uc_nation := 1 ;
7043: LD_ADDR_OWVAR 21
7047: PUSH
7048: LD_INT 1
7050: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7051: LD_ADDR_VAR 0 6
7055: PUSH
7056: LD_INT 3
7058: PUSH
7059: LD_INT 4
7061: PUSH
7062: LD_INT 4
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 1
7072: PPUSH
7073: LD_OWVAR 67
7077: PPUSH
7078: CALL_OW 12
7082: ARRAY
7083: ST_TO_ADDR
// vc_chassis := ch ;
7084: LD_ADDR_OWVAR 37
7088: PUSH
7089: LD_VAR 0 6
7093: ST_TO_ADDR
// vc_control := control_computer ;
7094: LD_ADDR_OWVAR 38
7098: PUSH
7099: LD_INT 3
7101: ST_TO_ADDR
// vc_engine := engine_combustion ;
7102: LD_ADDR_OWVAR 39
7106: PUSH
7107: LD_INT 1
7109: ST_TO_ADDR
// if ch = us_medium_tracked then
7110: LD_VAR 0 6
7114: PUSH
7115: LD_INT 3
7117: EQUAL
7118: IFFALSE 7165
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7120: LD_ADDR_OWVAR 40
7124: PUSH
7125: LD_INT 3
7127: PUSH
7128: LD_INT 4
7130: PUSH
7131: LD_INT 5
7133: PUSH
7134: LD_INT 7
7136: PUSH
7137: EMPTY
7138: LIST
7139: LIST
7140: LIST
7141: LIST
7142: PUSH
7143: LD_OWVAR 67
7147: PPUSH
7148: LD_OWVAR 67
7152: PUSH
7153: LD_INT 1
7155: PLUS
7156: PPUSH
7157: CALL_OW 12
7161: ARRAY
7162: ST_TO_ADDR
7163: GO 7206
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7165: LD_ADDR_OWVAR 40
7169: PUSH
7170: LD_INT 5
7172: PUSH
7173: LD_INT 6
7175: PUSH
7176: LD_INT 7
7178: PUSH
7179: LD_INT 7
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 1
7190: PPUSH
7191: LD_OWVAR 67
7195: PUSH
7196: LD_INT 1
7198: PLUS
7199: PPUSH
7200: CALL_OW 12
7204: ARRAY
7205: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7206: LD_ADDR_OWVAR 41
7210: PUSH
7211: LD_INT 70
7213: ST_TO_ADDR
// un := CreateVehicle ;
7214: LD_ADDR_VAR 0 5
7218: PUSH
7219: CALL_OW 45
7223: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7224: LD_VAR 0 5
7228: PPUSH
7229: LD_VAR 0 1
7233: PPUSH
7234: LD_INT 0
7236: PPUSH
7237: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7241: LD_VAR 0 5
7245: PPUSH
7246: LD_INT 65
7248: PPUSH
7249: LD_INT 9
7251: PPUSH
7252: CALL_OW 111
// Wait ( 0 0$02 ) ;
7256: LD_INT 70
7258: PPUSH
7259: CALL_OW 67
// end ;
7263: GO 7032
7265: POP
7266: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7267: LD_INT 90
7269: PUSH
7270: LD_INT 80
7272: PUSH
7273: LD_INT 70
7275: PUSH
7276: EMPTY
7277: LIST
7278: LIST
7279: LIST
7280: PUSH
7281: LD_OWVAR 67
7285: ARRAY
7286: PPUSH
7287: CALL_OW 13
7291: IFFALSE 7398
// begin uc_side := 8 ;
7293: LD_ADDR_OWVAR 20
7297: PUSH
7298: LD_INT 8
7300: ST_TO_ADDR
// uc_nation := 1 ;
7301: LD_ADDR_OWVAR 21
7305: PUSH
7306: LD_INT 1
7308: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7309: LD_ADDR_OWVAR 37
7313: PUSH
7314: LD_INT 4
7316: ST_TO_ADDR
// vc_control := control_computer ;
7317: LD_ADDR_OWVAR 38
7321: PUSH
7322: LD_INT 3
7324: ST_TO_ADDR
// vc_engine := engine_combustion ;
7325: LD_ADDR_OWVAR 39
7329: PUSH
7330: LD_INT 1
7332: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7333: LD_ADDR_OWVAR 40
7337: PUSH
7338: LD_INT 14
7340: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7341: LD_ADDR_OWVAR 41
7345: PUSH
7346: LD_INT 70
7348: ST_TO_ADDR
// un := CreateVehicle ;
7349: LD_ADDR_VAR 0 5
7353: PUSH
7354: CALL_OW 45
7358: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7359: LD_VAR 0 5
7363: PPUSH
7364: LD_VAR 0 1
7368: PPUSH
7369: LD_INT 0
7371: PPUSH
7372: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7376: LD_VAR 0 5
7380: PPUSH
7381: LD_INT 65
7383: PPUSH
7384: LD_INT 9
7386: PPUSH
7387: CALL_OW 111
// Wait ( 0 0$02 ) ;
7391: LD_INT 70
7393: PPUSH
7394: CALL_OW 67
// end ; alfa_support := true ;
7398: LD_ADDR_EXP 14
7402: PUSH
7403: LD_INT 1
7405: ST_TO_ADDR
// end ;
7406: LD_VAR 0 3
7410: RET
// every 0 0$01 trigger tick mod [ 21 21$00 , 16 16$00 , 12 12$00 ] [ Difficulty ] = 0 do
7411: LD_OWVAR 1
7415: PUSH
7416: LD_INT 44100
7418: PUSH
7419: LD_INT 33600
7421: PUSH
7422: LD_INT 25200
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_OWVAR 67
7434: ARRAY
7435: MOD
7436: PUSH
7437: LD_INT 0
7439: EQUAL
7440: IFFALSE 7500
7442: GO 7444
7444: DISABLE
// begin enable ;
7445: ENABLE
// SayRadio ( Popov , DR5 ) ;
7446: LD_EXP 26
7450: PPUSH
7451: LD_STRING DR5
7453: PPUSH
7454: CALL_OW 94
// Wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7458: LD_INT 1050
7460: PPUSH
7461: LD_INT 4200
7463: PPUSH
7464: CALL_OW 12
7468: PPUSH
7469: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7473: LD_INT 20
7475: PPUSH
7476: LD_INT 5
7478: PUSH
7479: LD_INT 6
7481: PUSH
7482: LD_INT 7
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: LIST
7489: PUSH
7490: LD_OWVAR 67
7494: ARRAY
7495: PPUSH
7496: CALL 7003 0 2
// end ; end_of_file
7500: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7501: LD_INT 0
7503: PPUSH
// enable_addtolog := isTest ;
7504: LD_ADDR_OWVAR 81
7508: PUSH
7509: LD_EXP 1
7513: ST_TO_ADDR
// lines_break_limit := 5 ;
7514: LD_ADDR_EXP 28
7518: PUSH
7519: LD_INT 5
7521: ST_TO_ADDR
// lines_break_type := --- ;
7522: LD_ADDR_EXP 29
7526: PUSH
7527: LD_STRING ---
7529: ST_TO_ADDR
// lines_counter := 0 ;
7530: LD_ADDR_EXP 27
7534: PUSH
7535: LD_INT 0
7537: ST_TO_ADDR
// show_line_index := true ;
7538: LD_ADDR_EXP 30
7542: PUSH
7543: LD_INT 1
7545: ST_TO_ADDR
// tick_log := true ;
7546: LD_ADDR_EXP 31
7550: PUSH
7551: LD_INT 1
7553: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7554: LD_STRING ----------SAND OF SIBERIA LOG----------
7556: PPUSH
7557: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7561: LD_STRING Map Name: 
7563: PUSH
7564: LD_OWVAR 68
7568: STR
7569: PPUSH
7570: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7574: LD_STRING Map Number: 
7576: PUSH
7577: LD_OWVAR 70
7581: STR
7582: PPUSH
7583: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7587: LD_STRING Difficulty: 
7589: PUSH
7590: LD_OWVAR 67
7594: STR
7595: PPUSH
7596: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7600: LD_STRING ---------------------------------------
7602: PPUSH
7603: CALL_OW 561
// end ;
7607: LD_VAR 0 1
7611: RET
// function Log ( text ) ; begin
7612: LD_INT 0
7614: PPUSH
// if show_line_index then
7615: LD_EXP 30
7619: IFFALSE 7631
// result := lines_counter ;
7621: LD_ADDR_VAR 0 2
7625: PUSH
7626: LD_EXP 27
7630: ST_TO_ADDR
// if tick_log then
7631: LD_EXP 31
7635: IFFALSE 7661
// result := result &  T:  & tick &   ;
7637: LD_ADDR_VAR 0 2
7641: PUSH
7642: LD_VAR 0 2
7646: PUSH
7647: LD_STRING  T: 
7649: STR
7650: PUSH
7651: LD_OWVAR 1
7655: STR
7656: PUSH
7657: LD_STRING  
7659: STR
7660: ST_TO_ADDR
// AddToLog ( result & text ) ;
7661: LD_VAR 0 2
7665: PUSH
7666: LD_VAR 0 1
7670: STR
7671: PPUSH
7672: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7676: LD_ADDR_EXP 27
7680: PUSH
7681: LD_EXP 27
7685: PUSH
7686: LD_INT 1
7688: PLUS
7689: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7690: LD_EXP 27
7694: PUSH
7695: LD_EXP 28
7699: MOD
7700: PUSH
7701: LD_INT 0
7703: EQUAL
7704: IFFALSE 7715
// AddToLog ( lines_break_type ) ;
7706: LD_EXP 29
7710: PPUSH
7711: CALL_OW 561
// end ;
7715: LD_VAR 0 2
7719: RET
// export function LogHuman ( id ) ; begin
7720: LD_INT 0
7722: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7723: LD_STRING Human Created. id: 
7725: PUSH
7726: LD_VAR 0 1
7730: STR
7731: PUSH
7732: LD_STRING ; side: 
7734: STR
7735: PUSH
7736: LD_VAR 0 1
7740: PPUSH
7741: CALL_OW 255
7745: STR
7746: PUSH
7747: LD_STRING ; class: 
7749: STR
7750: PUSH
7751: LD_VAR 0 1
7755: PPUSH
7756: CALL_OW 257
7760: STR
7761: PUSH
7762: LD_STRING ; 
7764: STR
7765: PPUSH
7766: CALL 7612 0 1
// end ;
7770: LD_VAR 0 2
7774: RET
// export function LogVeh ( id ) ; begin
7775: LD_INT 0
7777: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7778: LD_STRING Vehicle Created. id: 
7780: PUSH
7781: LD_VAR 0 1
7785: STR
7786: PUSH
7787: LD_STRING ; side: 
7789: STR
7790: PUSH
7791: LD_VAR 0 1
7795: PPUSH
7796: CALL_OW 255
7800: STR
7801: PUSH
7802: LD_STRING ; nation: 
7804: STR
7805: PUSH
7806: LD_VAR 0 1
7810: PPUSH
7811: CALL_OW 248
7815: STR
7816: PUSH
7817: LD_STRING ; weapon: 
7819: STR
7820: PUSH
7821: LD_VAR 0 1
7825: PPUSH
7826: CALL_OW 264
7830: STR
7831: PUSH
7832: LD_STRING ; 
7834: STR
7835: PPUSH
7836: CALL 7612 0 1
// end ;
7840: LD_VAR 0 2
7844: RET
// export function LogEvent ( event ) ; begin
7845: LD_INT 0
7847: PPUSH
// Log ( Event Executed. id:  & event ) ;
7848: LD_STRING Event Executed. id: 
7850: PUSH
7851: LD_VAR 0 1
7855: STR
7856: PPUSH
7857: CALL 7612 0 1
// end ; end_of_file
7861: LD_VAR 0 2
7865: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7866: LD_INT 0
7868: PPUSH
7869: PPUSH
7870: PPUSH
7871: PPUSH
7872: PPUSH
7873: PPUSH
7874: PPUSH
7875: PPUSH
// if unit then
7876: LD_VAR 0 1
7880: IFFALSE 8280
// begin if mode = 0 then
7882: LD_VAR 0 3
7886: PUSH
7887: LD_INT 0
7889: EQUAL
7890: IFFALSE 8038
// begin if coords then
7892: LD_VAR 0 2
7896: IFFALSE 8036
// while ( coords > 1 ) do
7898: LD_VAR 0 2
7902: PUSH
7903: LD_INT 1
7905: GREATER
7906: IFFALSE 8036
// if not HasTask ( unit ) then
7908: LD_VAR 0 1
7912: PPUSH
7913: CALL_OW 314
7917: NOT
7918: IFFALSE 8034
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7920: LD_VAR 0 1
7924: PPUSH
7925: LD_VAR 0 2
7929: PUSH
7930: LD_INT 1
7932: ARRAY
7933: PPUSH
7934: LD_VAR 0 2
7938: PUSH
7939: LD_INT 2
7941: ARRAY
7942: PPUSH
7943: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
7947: LD_INT 35
7949: PPUSH
7950: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
7954: LD_VAR 0 1
7958: PPUSH
7959: CALL_OW 250
7963: PUSH
7964: LD_VAR 0 2
7968: PUSH
7969: LD_INT 1
7971: ARRAY
7972: EQUAL
7973: PUSH
7974: LD_VAR 0 1
7978: PPUSH
7979: CALL_OW 251
7983: PUSH
7984: LD_VAR 0 2
7988: PUSH
7989: LD_INT 2
7991: ARRAY
7992: EQUAL
7993: AND
7994: IFFALSE 7947
// for i = 1 to 2 do
7996: LD_ADDR_VAR 0 5
8000: PUSH
8001: DOUBLE
8002: LD_INT 1
8004: DEC
8005: ST_TO_ADDR
8006: LD_INT 2
8008: PUSH
8009: FOR_TO
8010: IFFALSE 8032
// coords := Delete ( coords , 1 ) ;
8012: LD_ADDR_VAR 0 2
8016: PUSH
8017: LD_VAR 0 2
8021: PPUSH
8022: LD_INT 1
8024: PPUSH
8025: CALL_OW 3
8029: ST_TO_ADDR
8030: GO 8009
8032: POP
8033: POP
// end ;
8034: GO 7898
// end else
8036: GO 8280
// begin if coords then
8038: LD_VAR 0 2
8042: IFFALSE 8280
// begin x := GetX ( unit ) ;
8044: LD_ADDR_VAR 0 6
8048: PUSH
8049: LD_VAR 0 1
8053: PPUSH
8054: CALL_OW 250
8058: ST_TO_ADDR
// y := GetY ( unit ) ;
8059: LD_ADDR_VAR 0 7
8063: PUSH
8064: LD_VAR 0 1
8068: PPUSH
8069: CALL_OW 251
8073: ST_TO_ADDR
// while ( coords > 1 ) do
8074: LD_VAR 0 2
8078: PUSH
8079: LD_INT 1
8081: GREATER
8082: IFFALSE 8280
// begin Wait ( 0 0$0.3 ) ;
8084: LD_INT 10
8086: PPUSH
8087: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8091: LD_VAR 0 1
8095: PPUSH
8096: CALL_OW 255
8100: PPUSH
8101: LD_VAR 0 1
8105: PPUSH
8106: CALL_OW 250
8110: PPUSH
8111: LD_VAR 0 1
8115: PPUSH
8116: CALL_OW 251
8120: PPUSH
8121: LD_INT 14
8123: PPUSH
8124: CALL 22618 0 4
8128: IFFALSE 8159
// begin ComMoveXY ( unit , x , y ) ;
8130: LD_VAR 0 1
8134: PPUSH
8135: LD_VAR 0 6
8139: PPUSH
8140: LD_VAR 0 7
8144: PPUSH
8145: CALL_OW 111
// result := false ;
8149: LD_ADDR_VAR 0 4
8153: PUSH
8154: LD_INT 0
8156: ST_TO_ADDR
// end else
8157: GO 8198
// if not HasTask ( unit ) then
8159: LD_VAR 0 1
8163: PPUSH
8164: CALL_OW 314
8168: NOT
8169: IFFALSE 8198
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8171: LD_VAR 0 1
8175: PPUSH
8176: LD_VAR 0 2
8180: PUSH
8181: LD_INT 1
8183: ARRAY
8184: PPUSH
8185: LD_VAR 0 2
8189: PUSH
8190: LD_INT 2
8192: ARRAY
8193: PPUSH
8194: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8198: LD_VAR 0 1
8202: PPUSH
8203: CALL_OW 250
8207: PUSH
8208: LD_VAR 0 2
8212: PUSH
8213: LD_INT 1
8215: ARRAY
8216: EQUAL
8217: PUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 251
8227: PUSH
8228: LD_VAR 0 2
8232: PUSH
8233: LD_INT 2
8235: ARRAY
8236: EQUAL
8237: AND
8238: IFFALSE 8278
// for i = 1 to 2 do
8240: LD_ADDR_VAR 0 5
8244: PUSH
8245: DOUBLE
8246: LD_INT 1
8248: DEC
8249: ST_TO_ADDR
8250: LD_INT 2
8252: PUSH
8253: FOR_TO
8254: IFFALSE 8276
// coords := Delete ( coords , 1 ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_INT 1
8268: PPUSH
8269: CALL_OW 3
8273: ST_TO_ADDR
8274: GO 8253
8276: POP
8277: POP
// end ;
8278: GO 8074
// end ; end ; end ; result := true ;
8280: LD_ADDR_VAR 0 4
8284: PUSH
8285: LD_INT 1
8287: ST_TO_ADDR
// end ;
8288: LD_VAR 0 4
8292: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8293: LD_INT 0
8295: PPUSH
8296: PPUSH
8297: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8298: LD_ADDR_VAR 0 5
8302: PUSH
8303: LD_INT 81
8305: PUSH
8306: LD_VAR 0 1
8310: PUSH
8311: EMPTY
8312: LIST
8313: LIST
8314: PPUSH
8315: CALL_OW 69
8319: ST_TO_ADDR
// for i in units do
8320: LD_ADDR_VAR 0 4
8324: PUSH
8325: LD_VAR 0 2
8329: PUSH
8330: FOR_IN
8331: IFFALSE 8359
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8333: LD_VAR 0 4
8337: PPUSH
8338: LD_VAR 0 5
8342: PPUSH
8343: LD_VAR 0 4
8347: PPUSH
8348: CALL_OW 74
8352: PPUSH
8353: CALL_OW 115
// end ;
8357: GO 8330
8359: POP
8360: POP
// end ;
8361: LD_VAR 0 3
8365: RET
// export function MC_Show ( string ) ; begin
8366: LD_INT 0
8368: PPUSH
// display_strings := string ;
8369: LD_ADDR_OWVAR 47
8373: PUSH
8374: LD_VAR 0 1
8378: ST_TO_ADDR
// end ; end_of_file
8379: LD_VAR 0 2
8383: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8384: LD_INT 0
8386: PPUSH
8387: PPUSH
8388: PPUSH
8389: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8390: LD_ADDR_VAR 0 8
8394: PUSH
8395: LD_VAR 0 1
8399: PPUSH
8400: LD_INT 2
8402: PPUSH
8403: EMPTY
8404: PPUSH
8405: CALL 11531 0 3
8409: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8410: LD_VAR 0 8
8414: PUSH
8415: LD_VAR 0 2
8419: PPUSH
8420: LD_VAR 0 3
8424: PPUSH
8425: CALL_OW 428
8429: PUSH
8430: LD_INT 0
8432: EQUAL
8433: AND
8434: IFFALSE 8508
// for i = 1 to plist do
8436: LD_ADDR_VAR 0 6
8440: PUSH
8441: DOUBLE
8442: LD_INT 1
8444: DEC
8445: ST_TO_ADDR
8446: LD_VAR 0 8
8450: PUSH
8451: FOR_TO
8452: IFFALSE 8506
// if NotTask ( plist [ i ] ) then
8454: LD_VAR 0 8
8458: PUSH
8459: LD_VAR 0 6
8463: ARRAY
8464: PPUSH
8465: CALL 32221 0 1
8469: IFFALSE 8504
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8471: LD_VAR 0 8
8475: PUSH
8476: LD_VAR 0 6
8480: ARRAY
8481: PPUSH
8482: LD_INT 0
8484: PPUSH
8485: LD_VAR 0 2
8489: PPUSH
8490: LD_VAR 0 3
8494: PPUSH
8495: LD_VAR 0 4
8499: PPUSH
8500: CALL_OW 145
// end ;
8504: GO 8451
8506: POP
8507: POP
// end ;
8508: LD_VAR 0 5
8512: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8513: LD_INT 0
8515: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8516: LD_VAR 0 1
8520: PPUSH
8521: LD_INT 6
8523: PPUSH
8524: LD_VAR 0 2
8528: PPUSH
8529: LD_VAR 0 3
8533: PPUSH
8534: LD_VAR 0 4
8538: PPUSH
8539: CALL 10017 0 5
// end ;
8543: LD_VAR 0 5
8547: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8548: LD_INT 0
8550: PPUSH
8551: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8552: LD_ADDR_VAR 0 4
8556: PUSH
8557: LD_INT 22
8559: PUSH
8560: LD_VAR 0 1
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: PUSH
8569: LD_INT 2
8571: PUSH
8572: LD_INT 30
8574: PUSH
8575: LD_INT 0
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 30
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: LIST
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: PUSH
8601: EMPTY
8602: LIST
8603: PPUSH
8604: CALL_OW 69
8608: PPUSH
8609: LD_VAR 0 2
8613: PPUSH
8614: CALL_OW 250
8618: PPUSH
8619: LD_VAR 0 2
8623: PPUSH
8624: CALL_OW 251
8628: PPUSH
8629: CALL_OW 73
8633: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8634: LD_VAR 0 4
8638: PPUSH
8639: LD_VAR 0 2
8643: PPUSH
8644: CALL 10306 0 2
8648: IFFALSE 8707
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8650: LD_VAR 0 1
8654: PPUSH
8655: LD_INT 30
8657: PUSH
8658: LD_VAR 0 2
8662: PUSH
8663: EMPTY
8664: LIST
8665: LIST
8666: PPUSH
8667: CALL 11448 0 2
8671: PUSH
8672: LD_INT 1
8674: ARRAY
8675: PPUSH
8676: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8680: LD_ADDR_EXP 50
8684: PUSH
8685: LD_EXP 50
8689: PPUSH
8690: LD_VAR 0 1
8694: PPUSH
8695: LD_VAR 0 2
8699: PPUSH
8700: EMPTY
8701: PPUSH
8702: CALL 42253 0 4
8706: ST_TO_ADDR
// end ; end ;
8707: LD_VAR 0 3
8711: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8712: LD_INT 0
8714: PPUSH
8715: PPUSH
8716: PPUSH
8717: PPUSH
8718: PPUSH
8719: PPUSH
// result := false ;
8720: LD_ADDR_VAR 0 4
8724: PUSH
8725: LD_INT 0
8727: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8728: LD_VAR 0 1
8732: PPUSH
8733: LD_EXP 42
8737: PPUSH
8738: CALL 43201 0 2
8742: IFFALSE 8955
// for i = 1 to MREG_LabList do
8744: LD_ADDR_VAR 0 5
8748: PUSH
8749: DOUBLE
8750: LD_INT 1
8752: DEC
8753: ST_TO_ADDR
8754: LD_EXP 42
8758: PUSH
8759: FOR_TO
8760: IFFALSE 8953
// begin if MREG_LabList [ i ] [ 1 ] = side then
8762: LD_EXP 42
8766: PUSH
8767: LD_VAR 0 5
8771: ARRAY
8772: PUSH
8773: LD_INT 1
8775: ARRAY
8776: PUSH
8777: LD_VAR 0 1
8781: EQUAL
8782: IFFALSE 8951
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8784: LD_ADDR_VAR 0 7
8788: PUSH
8789: LD_EXP 42
8793: PUSH
8794: LD_VAR 0 5
8798: ARRAY
8799: PUSH
8800: LD_INT 2
8802: ARRAY
8803: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8804: LD_ADDR_VAR 0 9
8808: PUSH
8809: LD_INT 22
8811: PUSH
8812: LD_VAR 0 1
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: LD_INT 2
8823: PUSH
8824: LD_INT 30
8826: PUSH
8827: LD_INT 0
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PUSH
8834: LD_INT 30
8836: PUSH
8837: LD_INT 1
8839: PUSH
8840: EMPTY
8841: LIST
8842: LIST
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: LIST
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PUSH
8853: EMPTY
8854: LIST
8855: PPUSH
8856: CALL_OW 69
8860: PPUSH
8861: LD_VAR 0 7
8865: PPUSH
8866: CALL_OW 250
8870: PPUSH
8871: LD_VAR 0 7
8875: PPUSH
8876: CALL_OW 251
8880: PPUSH
8881: CALL_OW 73
8885: ST_TO_ADDR
// if dep then
8886: LD_VAR 0 9
8890: IFFALSE 8949
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8892: LD_VAR 0 9
8896: PPUSH
8897: LD_VAR 0 2
8901: PPUSH
8902: LD_VAR 0 3
8906: PPUSH
8907: CALL 10422 0 3
8911: IFFALSE 8949
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
8913: LD_VAR 0 7
8917: PPUSH
8918: LD_VAR 0 2
8922: PPUSH
8923: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
8927: LD_VAR 0 7
8931: PPUSH
8932: LD_VAR 0 3
8936: PPUSH
8937: CALL_OW 207
// result := true ;
8941: LD_ADDR_VAR 0 4
8945: PUSH
8946: LD_INT 1
8948: ST_TO_ADDR
// end ; end ; break ;
8949: GO 8953
// end ; end ;
8951: GO 8759
8953: POP
8954: POP
// end ;
8955: LD_VAR 0 4
8959: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
8960: LD_INT 0
8962: PPUSH
8963: PPUSH
8964: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
8965: LD_ADDR_VAR 0 7
8969: PUSH
8970: LD_VAR 0 2
8974: PPUSH
8975: LD_VAR 0 3
8979: PPUSH
8980: LD_VAR 0 4
8984: PPUSH
8985: CALL 9147 0 3
8989: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
8990: LD_ADDR_EXP 48
8994: PUSH
8995: LD_EXP 48
8999: PPUSH
9000: LD_VAR 0 1
9004: PPUSH
9005: LD_INT 2
9007: PPUSH
9008: LD_VAR 0 2
9012: PUSH
9013: LD_VAR 0 3
9017: PUSH
9018: LD_VAR 0 4
9022: PUSH
9023: EMPTY
9024: LIST
9025: LIST
9026: LIST
9027: PPUSH
9028: CALL 42162 0 4
9032: ST_TO_ADDR
// if ext_list then
9033: LD_VAR 0 5
9037: IFFALSE 9142
// for i = 1 to ext_list do
9039: LD_ADDR_VAR 0 8
9043: PUSH
9044: DOUBLE
9045: LD_INT 1
9047: DEC
9048: ST_TO_ADDR
9049: LD_VAR 0 5
9053: PUSH
9054: FOR_TO
9055: IFFALSE 9140
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9057: LD_ADDR_EXP 48
9061: PUSH
9062: LD_EXP 48
9066: PPUSH
9067: LD_VAR 0 1
9071: PPUSH
9072: LD_VAR 0 5
9076: PUSH
9077: LD_VAR 0 8
9081: ARRAY
9082: PPUSH
9083: LD_VAR 0 7
9087: PUSH
9088: LD_VAR 0 8
9092: ARRAY
9093: PUSH
9094: LD_INT 1
9096: ARRAY
9097: PUSH
9098: LD_VAR 0 7
9102: PUSH
9103: LD_VAR 0 8
9107: ARRAY
9108: PUSH
9109: LD_INT 2
9111: ARRAY
9112: PUSH
9113: LD_VAR 0 7
9117: PUSH
9118: LD_VAR 0 8
9122: ARRAY
9123: PUSH
9124: LD_INT 3
9126: ARRAY
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: PPUSH
9133: CALL 42162 0 4
9137: ST_TO_ADDR
9138: GO 9054
9140: POP
9141: POP
// end ;
9142: LD_VAR 0 6
9146: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9147: LD_INT 0
9149: PPUSH
9150: PPUSH
// list := [ ] ;
9151: LD_ADDR_VAR 0 5
9155: PUSH
9156: EMPTY
9157: ST_TO_ADDR
// case d of 0 :
9158: LD_VAR 0 3
9162: PUSH
9163: LD_INT 0
9165: DOUBLE
9166: EQUAL
9167: IFTRUE 9171
9169: GO 9304
9171: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9172: LD_ADDR_VAR 0 5
9176: PUSH
9177: LD_VAR 0 1
9181: PUSH
9182: LD_INT 4
9184: MINUS
9185: PUSH
9186: LD_VAR 0 2
9190: PUSH
9191: LD_INT 4
9193: MINUS
9194: PUSH
9195: LD_INT 2
9197: PUSH
9198: EMPTY
9199: LIST
9200: LIST
9201: LIST
9202: PUSH
9203: LD_VAR 0 1
9207: PUSH
9208: LD_INT 3
9210: MINUS
9211: PUSH
9212: LD_VAR 0 2
9216: PUSH
9217: LD_INT 1
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: PUSH
9225: LD_VAR 0 1
9229: PUSH
9230: LD_INT 4
9232: PLUS
9233: PUSH
9234: LD_VAR 0 2
9238: PUSH
9239: LD_INT 4
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PUSH
9247: LD_VAR 0 1
9251: PUSH
9252: LD_INT 3
9254: PLUS
9255: PUSH
9256: LD_VAR 0 2
9260: PUSH
9261: LD_INT 3
9263: PLUS
9264: PUSH
9265: LD_INT 5
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: PUSH
9273: LD_VAR 0 1
9277: PUSH
9278: LD_VAR 0 2
9282: PUSH
9283: LD_INT 4
9285: PLUS
9286: PUSH
9287: LD_INT 0
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: LIST
9294: PUSH
9295: EMPTY
9296: LIST
9297: LIST
9298: LIST
9299: LIST
9300: LIST
9301: ST_TO_ADDR
// end ; 1 :
9302: GO 10002
9304: LD_INT 1
9306: DOUBLE
9307: EQUAL
9308: IFTRUE 9312
9310: GO 9445
9312: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9313: LD_ADDR_VAR 0 5
9317: PUSH
9318: LD_VAR 0 1
9322: PUSH
9323: LD_VAR 0 2
9327: PUSH
9328: LD_INT 4
9330: MINUS
9331: PUSH
9332: LD_INT 3
9334: PUSH
9335: EMPTY
9336: LIST
9337: LIST
9338: LIST
9339: PUSH
9340: LD_VAR 0 1
9344: PUSH
9345: LD_INT 3
9347: MINUS
9348: PUSH
9349: LD_VAR 0 2
9353: PUSH
9354: LD_INT 3
9356: MINUS
9357: PUSH
9358: LD_INT 2
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: LIST
9365: PUSH
9366: LD_VAR 0 1
9370: PUSH
9371: LD_INT 4
9373: MINUS
9374: PUSH
9375: LD_VAR 0 2
9379: PUSH
9380: LD_INT 1
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: LIST
9387: PUSH
9388: LD_VAR 0 1
9392: PUSH
9393: LD_VAR 0 2
9397: PUSH
9398: LD_INT 3
9400: PLUS
9401: PUSH
9402: LD_INT 0
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: LIST
9409: PUSH
9410: LD_VAR 0 1
9414: PUSH
9415: LD_INT 4
9417: PLUS
9418: PUSH
9419: LD_VAR 0 2
9423: PUSH
9424: LD_INT 4
9426: PLUS
9427: PUSH
9428: LD_INT 5
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: PUSH
9436: EMPTY
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: ST_TO_ADDR
// end ; 2 :
9443: GO 10002
9445: LD_INT 2
9447: DOUBLE
9448: EQUAL
9449: IFTRUE 9453
9451: GO 9582
9453: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9454: LD_ADDR_VAR 0 5
9458: PUSH
9459: LD_VAR 0 1
9463: PUSH
9464: LD_VAR 0 2
9468: PUSH
9469: LD_INT 3
9471: MINUS
9472: PUSH
9473: LD_INT 3
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: LIST
9480: PUSH
9481: LD_VAR 0 1
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_VAR 0 2
9494: PUSH
9495: LD_INT 4
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: PUSH
9503: LD_VAR 0 1
9507: PUSH
9508: LD_VAR 0 2
9512: PUSH
9513: LD_INT 4
9515: PLUS
9516: PUSH
9517: LD_INT 0
9519: PUSH
9520: EMPTY
9521: LIST
9522: LIST
9523: LIST
9524: PUSH
9525: LD_VAR 0 1
9529: PUSH
9530: LD_INT 3
9532: MINUS
9533: PUSH
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: PUSH
9542: EMPTY
9543: LIST
9544: LIST
9545: LIST
9546: PUSH
9547: LD_VAR 0 1
9551: PUSH
9552: LD_INT 4
9554: MINUS
9555: PUSH
9556: LD_VAR 0 2
9560: PUSH
9561: LD_INT 4
9563: MINUS
9564: PUSH
9565: LD_INT 2
9567: PUSH
9568: EMPTY
9569: LIST
9570: LIST
9571: LIST
9572: PUSH
9573: EMPTY
9574: LIST
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: ST_TO_ADDR
// end ; 3 :
9580: GO 10002
9582: LD_INT 3
9584: DOUBLE
9585: EQUAL
9586: IFTRUE 9590
9588: GO 9723
9590: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9591: LD_ADDR_VAR 0 5
9595: PUSH
9596: LD_VAR 0 1
9600: PUSH
9601: LD_INT 3
9603: PLUS
9604: PUSH
9605: LD_VAR 0 2
9609: PUSH
9610: LD_INT 4
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: LIST
9617: PUSH
9618: LD_VAR 0 1
9622: PUSH
9623: LD_INT 4
9625: PLUS
9626: PUSH
9627: LD_VAR 0 2
9631: PUSH
9632: LD_INT 4
9634: PLUS
9635: PUSH
9636: LD_INT 5
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: PUSH
9644: LD_VAR 0 1
9648: PUSH
9649: LD_INT 4
9651: MINUS
9652: PUSH
9653: LD_VAR 0 2
9657: PUSH
9658: LD_INT 1
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: LIST
9665: PUSH
9666: LD_VAR 0 1
9670: PUSH
9671: LD_VAR 0 2
9675: PUSH
9676: LD_INT 4
9678: MINUS
9679: PUSH
9680: LD_INT 3
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: LIST
9687: PUSH
9688: LD_VAR 0 1
9692: PUSH
9693: LD_INT 3
9695: MINUS
9696: PUSH
9697: LD_VAR 0 2
9701: PUSH
9702: LD_INT 3
9704: MINUS
9705: PUSH
9706: LD_INT 2
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: LIST
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: LIST
9720: ST_TO_ADDR
// end ; 4 :
9721: GO 10002
9723: LD_INT 4
9725: DOUBLE
9726: EQUAL
9727: IFTRUE 9731
9729: GO 9864
9731: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9732: LD_ADDR_VAR 0 5
9736: PUSH
9737: LD_VAR 0 1
9741: PUSH
9742: LD_VAR 0 2
9746: PUSH
9747: LD_INT 4
9749: PLUS
9750: PUSH
9751: LD_INT 0
9753: PUSH
9754: EMPTY
9755: LIST
9756: LIST
9757: LIST
9758: PUSH
9759: LD_VAR 0 1
9763: PUSH
9764: LD_INT 3
9766: PLUS
9767: PUSH
9768: LD_VAR 0 2
9772: PUSH
9773: LD_INT 3
9775: PLUS
9776: PUSH
9777: LD_INT 5
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: LIST
9784: PUSH
9785: LD_VAR 0 1
9789: PUSH
9790: LD_INT 3
9792: PLUS
9793: PUSH
9794: LD_VAR 0 2
9798: PUSH
9799: LD_INT 4
9801: PUSH
9802: EMPTY
9803: LIST
9804: LIST
9805: LIST
9806: PUSH
9807: LD_VAR 0 1
9811: PUSH
9812: LD_VAR 0 2
9816: PUSH
9817: LD_INT 3
9819: MINUS
9820: PUSH
9821: LD_INT 3
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: LD_VAR 0 1
9833: PUSH
9834: LD_INT 4
9836: MINUS
9837: PUSH
9838: LD_VAR 0 2
9842: PUSH
9843: LD_INT 4
9845: MINUS
9846: PUSH
9847: LD_INT 2
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: LIST
9854: PUSH
9855: EMPTY
9856: LIST
9857: LIST
9858: LIST
9859: LIST
9860: LIST
9861: ST_TO_ADDR
// end ; 5 :
9862: GO 10002
9864: LD_INT 5
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 10001
9872: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9873: LD_ADDR_VAR 0 5
9877: PUSH
9878: LD_VAR 0 1
9882: PUSH
9883: LD_INT 4
9885: MINUS
9886: PUSH
9887: LD_VAR 0 2
9891: PUSH
9892: LD_INT 1
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: LIST
9899: PUSH
9900: LD_VAR 0 1
9904: PUSH
9905: LD_VAR 0 2
9909: PUSH
9910: LD_INT 4
9912: MINUS
9913: PUSH
9914: LD_INT 3
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: PUSH
9922: LD_VAR 0 1
9926: PUSH
9927: LD_INT 4
9929: PLUS
9930: PUSH
9931: LD_VAR 0 2
9935: PUSH
9936: LD_INT 4
9938: PLUS
9939: PUSH
9940: LD_INT 5
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: LIST
9947: PUSH
9948: LD_VAR 0 1
9952: PUSH
9953: LD_INT 3
9955: PLUS
9956: PUSH
9957: LD_VAR 0 2
9961: PUSH
9962: LD_INT 4
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: LIST
9969: PUSH
9970: LD_VAR 0 1
9974: PUSH
9975: LD_VAR 0 2
9979: PUSH
9980: LD_INT 3
9982: PLUS
9983: PUSH
9984: LD_INT 0
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: LIST
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: LIST
9996: LIST
9997: LIST
9998: ST_TO_ADDR
// end ; end ;
9999: GO 10002
10001: POP
// result := list ;
10002: LD_ADDR_VAR 0 4
10006: PUSH
10007: LD_VAR 0 5
10011: ST_TO_ADDR
// end ;
10012: LD_VAR 0 4
10016: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10017: LD_INT 0
10019: PPUSH
10020: PPUSH
10021: PPUSH
10022: PPUSH
10023: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10024: LD_ADDR_VAR 0 10
10028: PUSH
10029: LD_VAR 0 1
10033: PPUSH
10034: LD_INT 2
10036: PPUSH
10037: EMPTY
10038: PPUSH
10039: CALL 11531 0 3
10043: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10044: LD_ADDR_VAR 0 9
10048: PUSH
10049: LD_INT 22
10051: PUSH
10052: LD_VAR 0 1
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PUSH
10061: LD_INT 2
10063: PUSH
10064: LD_INT 30
10066: PUSH
10067: LD_INT 0
10069: PUSH
10070: EMPTY
10071: LIST
10072: LIST
10073: PUSH
10074: LD_INT 30
10076: PUSH
10077: LD_INT 1
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: LIST
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: EMPTY
10094: LIST
10095: PPUSH
10096: CALL_OW 69
10100: PPUSH
10101: LD_VAR 0 3
10105: PPUSH
10106: LD_VAR 0 4
10110: PPUSH
10111: CALL_OW 73
10115: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10116: LD_ADDR_VAR 0 8
10120: PUSH
10121: LD_VAR 0 9
10125: PPUSH
10126: LD_VAR 0 2
10130: PPUSH
10131: CALL 10306 0 2
10135: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10136: LD_VAR 0 10
10140: PUSH
10141: LD_VAR 0 8
10145: AND
10146: PUSH
10147: LD_VAR 0 9
10151: PPUSH
10152: LD_VAR 0 3
10156: PPUSH
10157: LD_VAR 0 4
10161: PPUSH
10162: CALL_OW 297
10166: PUSH
10167: LD_INT 26
10169: LESSEQUAL
10170: AND
10171: PUSH
10172: LD_VAR 0 3
10176: PPUSH
10177: LD_VAR 0 4
10181: PPUSH
10182: CALL_OW 428
10186: PUSH
10187: LD_INT 0
10189: EQUAL
10190: AND
10191: IFFALSE 10301
// for i = 1 to plist do
10193: LD_ADDR_VAR 0 7
10197: PUSH
10198: DOUBLE
10199: LD_INT 1
10201: DEC
10202: ST_TO_ADDR
10203: LD_VAR 0 10
10207: PUSH
10208: FOR_TO
10209: IFFALSE 10299
// if IsInUnit ( plist [ i ] ) then
10211: LD_VAR 0 10
10215: PUSH
10216: LD_VAR 0 7
10220: ARRAY
10221: PPUSH
10222: CALL_OW 310
10226: IFFALSE 10245
// ComExitBuilding ( plist [ i ] ) else
10228: LD_VAR 0 10
10232: PUSH
10233: LD_VAR 0 7
10237: ARRAY
10238: PPUSH
10239: CALL_OW 122
10243: GO 10297
// if NotTask ( plist [ i ] ) then
10245: LD_VAR 0 10
10249: PUSH
10250: LD_VAR 0 7
10254: ARRAY
10255: PPUSH
10256: CALL 32221 0 1
10260: IFFALSE 10297
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10262: LD_VAR 0 10
10266: PUSH
10267: LD_VAR 0 7
10271: ARRAY
10272: PPUSH
10273: LD_VAR 0 2
10277: PPUSH
10278: LD_VAR 0 3
10282: PPUSH
10283: LD_VAR 0 4
10287: PPUSH
10288: LD_VAR 0 5
10292: PPUSH
10293: CALL_OW 145
// end ;
10297: GO 10208
10299: POP
10300: POP
// end ;
10301: LD_VAR 0 6
10305: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10306: LD_INT 0
10308: PPUSH
10309: PPUSH
10310: PPUSH
// pom := GetBase ( bdepot ) ;
10311: LD_ADDR_VAR 0 4
10315: PUSH
10316: LD_VAR 0 1
10320: PPUSH
10321: CALL_OW 274
10325: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10326: LD_ADDR_VAR 0 5
10330: PUSH
10331: LD_VAR 0 2
10335: PPUSH
10336: LD_VAR 0 1
10340: PPUSH
10341: CALL_OW 248
10345: PPUSH
10346: CALL_OW 450
10350: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10351: LD_VAR 0 4
10355: PPUSH
10356: LD_INT 1
10358: PPUSH
10359: CALL_OW 275
10363: PUSH
10364: LD_VAR 0 5
10368: PUSH
10369: LD_INT 1
10371: ARRAY
10372: GREATEREQUAL
10373: PUSH
10374: LD_VAR 0 4
10378: PPUSH
10379: LD_INT 3
10381: PPUSH
10382: CALL_OW 275
10386: PUSH
10387: LD_VAR 0 5
10391: PUSH
10392: LD_INT 3
10394: ARRAY
10395: GREATEREQUAL
10396: AND
10397: IFFALSE 10409
// result := true else
10399: LD_ADDR_VAR 0 3
10403: PUSH
10404: LD_INT 1
10406: ST_TO_ADDR
10407: GO 10417
// result := false ;
10409: LD_ADDR_VAR 0 3
10413: PUSH
10414: LD_INT 0
10416: ST_TO_ADDR
// end ;
10417: LD_VAR 0 3
10421: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10422: LD_INT 0
10424: PPUSH
10425: PPUSH
10426: PPUSH
10427: PPUSH
10428: PPUSH
// pom := GetBase ( bdepot ) ;
10429: LD_ADDR_VAR 0 5
10433: PUSH
10434: LD_VAR 0 1
10438: PPUSH
10439: CALL_OW 274
10443: ST_TO_ADDR
// cost := [ ] ;
10444: LD_ADDR_VAR 0 8
10448: PUSH
10449: EMPTY
10450: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10451: LD_ADDR_VAR 0 6
10455: PUSH
10456: LD_VAR 0 2
10460: PPUSH
10461: LD_VAR 0 1
10465: PPUSH
10466: CALL_OW 248
10470: PPUSH
10471: CALL_OW 450
10475: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10476: LD_ADDR_VAR 0 7
10480: PUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 1
10490: PPUSH
10491: CALL_OW 248
10495: PPUSH
10496: CALL_OW 450
10500: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10501: LD_ADDR_VAR 0 8
10505: PUSH
10506: LD_VAR 0 8
10510: PPUSH
10511: LD_INT 1
10513: PPUSH
10514: LD_VAR 0 6
10518: PUSH
10519: LD_INT 1
10521: ARRAY
10522: PUSH
10523: LD_VAR 0 7
10527: PUSH
10528: LD_INT 1
10530: ARRAY
10531: PLUS
10532: PPUSH
10533: CALL_OW 1
10537: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10538: LD_ADDR_VAR 0 8
10542: PUSH
10543: LD_VAR 0 8
10547: PPUSH
10548: LD_INT 2
10550: PPUSH
10551: LD_VAR 0 6
10555: PUSH
10556: LD_INT 2
10558: ARRAY
10559: PUSH
10560: LD_VAR 0 7
10564: PUSH
10565: LD_INT 2
10567: ARRAY
10568: PLUS
10569: PPUSH
10570: CALL_OW 1
10574: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10575: LD_ADDR_VAR 0 8
10579: PUSH
10580: LD_VAR 0 8
10584: PPUSH
10585: LD_INT 3
10587: PPUSH
10588: LD_VAR 0 6
10592: PUSH
10593: LD_INT 3
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 7
10601: PUSH
10602: LD_INT 3
10604: ARRAY
10605: PLUS
10606: PPUSH
10607: CALL_OW 1
10611: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10612: LD_VAR 0 5
10616: PPUSH
10617: LD_INT 1
10619: PPUSH
10620: CALL_OW 275
10624: PUSH
10625: LD_VAR 0 8
10629: PUSH
10630: LD_INT 1
10632: ARRAY
10633: GREATEREQUAL
10634: PUSH
10635: LD_VAR 0 5
10639: PPUSH
10640: LD_INT 3
10642: PPUSH
10643: CALL_OW 275
10647: PUSH
10648: LD_VAR 0 8
10652: PUSH
10653: LD_INT 3
10655: ARRAY
10656: GREATEREQUAL
10657: AND
10658: IFFALSE 10670
// result := true else
10660: LD_ADDR_VAR 0 4
10664: PUSH
10665: LD_INT 1
10667: ST_TO_ADDR
10668: GO 10678
// result := false ;
10670: LD_ADDR_VAR 0 4
10674: PUSH
10675: LD_INT 0
10677: ST_TO_ADDR
// end ;
10678: LD_VAR 0 4
10682: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10683: LD_INT 0
10685: PPUSH
10686: PPUSH
10687: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10688: LD_ADDR_VAR 0 5
10692: PUSH
10693: LD_VAR 0 1
10697: PPUSH
10698: LD_INT 2
10700: PPUSH
10701: EMPTY
10702: PPUSH
10703: CALL 11531 0 3
10707: ST_TO_ADDR
// if unit and plist then
10708: LD_VAR 0 2
10712: PUSH
10713: LD_VAR 0 5
10717: AND
10718: IFFALSE 10779
// for i = 1 to plist do
10720: LD_ADDR_VAR 0 4
10724: PUSH
10725: DOUBLE
10726: LD_INT 1
10728: DEC
10729: ST_TO_ADDR
10730: LD_VAR 0 5
10734: PUSH
10735: FOR_TO
10736: IFFALSE 10777
// if NotTask ( plist [ i ] ) then
10738: LD_VAR 0 5
10742: PUSH
10743: LD_VAR 0 4
10747: ARRAY
10748: PPUSH
10749: CALL 32221 0 1
10753: IFFALSE 10775
// ComDismantle ( plist [ i ] , unit ) ;
10755: LD_VAR 0 5
10759: PUSH
10760: LD_VAR 0 4
10764: ARRAY
10765: PPUSH
10766: LD_VAR 0 2
10770: PPUSH
10771: CALL_OW 167
10775: GO 10735
10777: POP
10778: POP
// result := true ;
10779: LD_ADDR_VAR 0 3
10783: PUSH
10784: LD_INT 1
10786: ST_TO_ADDR
// end ;
10787: LD_VAR 0 3
10791: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10792: LD_INT 0
10794: PPUSH
10795: PPUSH
10796: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10797: LD_ADDR_VAR 0 5
10801: PUSH
10802: LD_VAR 0 1
10806: PPUSH
10807: LD_INT 2
10809: PPUSH
10810: EMPTY
10811: PPUSH
10812: CALL 11531 0 3
10816: ST_TO_ADDR
// if unit and plist then
10817: LD_VAR 0 2
10821: PUSH
10822: LD_VAR 0 5
10826: AND
10827: IFFALSE 10888
// for i = 1 to plist do
10829: LD_ADDR_VAR 0 4
10833: PUSH
10834: DOUBLE
10835: LD_INT 1
10837: DEC
10838: ST_TO_ADDR
10839: LD_VAR 0 5
10843: PUSH
10844: FOR_TO
10845: IFFALSE 10886
// if NotTask ( plist [ i ] ) then
10847: LD_VAR 0 5
10851: PUSH
10852: LD_VAR 0 4
10856: ARRAY
10857: PPUSH
10858: CALL 32221 0 1
10862: IFFALSE 10884
// ComComplete ( plist [ i ] , unit ) ;
10864: LD_VAR 0 5
10868: PUSH
10869: LD_VAR 0 4
10873: ARRAY
10874: PPUSH
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL 31757 0 2
10884: GO 10844
10886: POP
10887: POP
// result := true ;
10888: LD_ADDR_VAR 0 3
10892: PUSH
10893: LD_INT 1
10895: ST_TO_ADDR
// end ;
10896: LD_VAR 0 3
10900: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10901: LD_INT 0
10903: PPUSH
10904: PPUSH
10905: PPUSH
10906: PPUSH
10907: PPUSH
10908: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10909: LD_ADDR_VAR 0 5
10913: PUSH
10914: LD_INT 22
10916: PUSH
10917: LD_VAR 0 1
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: LD_INT 21
10928: PUSH
10929: LD_INT 3
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: PUSH
10936: LD_INT 3
10938: PUSH
10939: LD_INT 57
10941: PUSH
10942: EMPTY
10943: LIST
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: PUSH
10949: LD_INT 3
10951: PUSH
10952: LD_INT 24
10954: PUSH
10955: LD_INT 1000
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: EMPTY
10967: LIST
10968: LIST
10969: LIST
10970: LIST
10971: PPUSH
10972: CALL_OW 69
10976: ST_TO_ADDR
// r := [ ] ;
10977: LD_ADDR_VAR 0 6
10981: PUSH
10982: EMPTY
10983: ST_TO_ADDR
// if not tmp then
10984: LD_VAR 0 5
10988: NOT
10989: IFFALSE 10995
// exit else
10991: GO 11183
10993: GO 11163
// begin r := [ tmp [ 1 ] ] ;
10995: LD_ADDR_VAR 0 6
10999: PUSH
11000: LD_VAR 0 5
11004: PUSH
11005: LD_INT 1
11007: ARRAY
11008: PUSH
11009: EMPTY
11010: LIST
11011: ST_TO_ADDR
// for i = 2 to tmp do
11012: LD_ADDR_VAR 0 3
11016: PUSH
11017: DOUBLE
11018: LD_INT 2
11020: DEC
11021: ST_TO_ADDR
11022: LD_VAR 0 5
11026: PUSH
11027: FOR_TO
11028: IFFALSE 11161
// begin m := false ;
11030: LD_ADDR_VAR 0 7
11034: PUSH
11035: LD_INT 0
11037: ST_TO_ADDR
// for j = 1 to r do
11038: LD_ADDR_VAR 0 4
11042: PUSH
11043: DOUBLE
11044: LD_INT 1
11046: DEC
11047: ST_TO_ADDR
11048: LD_VAR 0 6
11052: PUSH
11053: FOR_TO
11054: IFFALSE 11128
// if GetLives ( tmp [ i ] ) < r [ j ] then
11056: LD_VAR 0 5
11060: PUSH
11061: LD_VAR 0 3
11065: ARRAY
11066: PPUSH
11067: CALL_OW 256
11071: PUSH
11072: LD_VAR 0 6
11076: PUSH
11077: LD_VAR 0 4
11081: ARRAY
11082: LESS
11083: IFFALSE 11126
// begin r := Insert ( r , j , tmp [ i ] ) ;
11085: LD_ADDR_VAR 0 6
11089: PUSH
11090: LD_VAR 0 6
11094: PPUSH
11095: LD_VAR 0 4
11099: PPUSH
11100: LD_VAR 0 5
11104: PUSH
11105: LD_VAR 0 3
11109: ARRAY
11110: PPUSH
11111: CALL_OW 2
11115: ST_TO_ADDR
// m := true ;
11116: LD_ADDR_VAR 0 7
11120: PUSH
11121: LD_INT 1
11123: ST_TO_ADDR
// break ;
11124: GO 11128
// end ;
11126: GO 11053
11128: POP
11129: POP
// if not m then
11130: LD_VAR 0 7
11134: NOT
11135: IFFALSE 11159
// r := r ^ tmp [ i ] ;
11137: LD_ADDR_VAR 0 6
11141: PUSH
11142: LD_VAR 0 6
11146: PUSH
11147: LD_VAR 0 5
11151: PUSH
11152: LD_VAR 0 3
11156: ARRAY
11157: ADD
11158: ST_TO_ADDR
// end ;
11159: GO 11027
11161: POP
11162: POP
// end ; if r then
11163: LD_VAR 0 6
11167: IFFALSE 11181
// result := r else
11169: LD_ADDR_VAR 0 2
11173: PUSH
11174: LD_VAR 0 6
11178: ST_TO_ADDR
11179: GO 11183
// exit ;
11181: GO 11183
// end ;
11183: LD_VAR 0 2
11187: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11188: LD_INT 0
11190: PPUSH
11191: PPUSH
11192: PPUSH
11193: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11194: LD_ADDR_VAR 0 5
11198: PUSH
11199: LD_INT 22
11201: PUSH
11202: LD_VAR 0 1
11206: PUSH
11207: EMPTY
11208: LIST
11209: LIST
11210: PUSH
11211: LD_INT 2
11213: PUSH
11214: LD_INT 25
11216: PUSH
11217: LD_INT 2
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: PUSH
11224: LD_INT 25
11226: PUSH
11227: LD_INT 16
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PUSH
11234: LD_INT 34
11236: PUSH
11237: LD_INT 13
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: LD_INT 34
11246: PUSH
11247: LD_INT 52
11249: PUSH
11250: EMPTY
11251: LIST
11252: LIST
11253: PUSH
11254: EMPTY
11255: LIST
11256: LIST
11257: LIST
11258: LIST
11259: LIST
11260: PUSH
11261: LD_INT 24
11263: PUSH
11264: LD_INT 650
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PUSH
11271: EMPTY
11272: LIST
11273: LIST
11274: LIST
11275: PPUSH
11276: CALL_OW 69
11280: ST_TO_ADDR
// p := 1 ;
11281: LD_ADDR_VAR 0 4
11285: PUSH
11286: LD_INT 1
11288: ST_TO_ADDR
// for i = 1 to repairs do
11289: LD_ADDR_VAR 0 3
11293: PUSH
11294: DOUBLE
11295: LD_INT 1
11297: DEC
11298: ST_TO_ADDR
11299: LD_VAR 0 5
11303: PUSH
11304: FOR_TO
11305: IFFALSE 11441
// begin if IsInUnit ( repairs [ i ] ) then
11307: LD_VAR 0 5
11311: PUSH
11312: LD_VAR 0 3
11316: ARRAY
11317: PPUSH
11318: CALL_OW 310
11322: IFFALSE 11341
// ComExitBuilding ( repairs [ i ] ) else
11324: LD_VAR 0 5
11328: PUSH
11329: LD_VAR 0 3
11333: ARRAY
11334: PPUSH
11335: CALL_OW 122
11339: GO 11439
// if not HasTask ( repairs [ i ] ) then
11341: LD_VAR 0 5
11345: PUSH
11346: LD_VAR 0 3
11350: ARRAY
11351: PPUSH
11352: CALL_OW 314
11356: NOT
11357: IFFALSE 11439
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11359: LD_VAR 0 5
11363: PUSH
11364: LD_VAR 0 3
11368: ARRAY
11369: PPUSH
11370: LD_EXP 49
11374: PUSH
11375: LD_VAR 0 1
11379: ARRAY
11380: PUSH
11381: LD_VAR 0 4
11385: ARRAY
11386: PPUSH
11387: CALL_OW 130
// if i mod 3 = 0 then
11391: LD_VAR 0 3
11395: PUSH
11396: LD_INT 3
11398: MOD
11399: PUSH
11400: LD_INT 0
11402: EQUAL
11403: IFFALSE 11419
// p := p + 1 ;
11405: LD_ADDR_VAR 0 4
11409: PUSH
11410: LD_VAR 0 4
11414: PUSH
11415: LD_INT 1
11417: PLUS
11418: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11419: LD_EXP 49
11423: PUSH
11424: LD_VAR 0 1
11428: ARRAY
11429: PUSH
11430: LD_VAR 0 4
11434: LESS
11435: IFFALSE 11439
// break ;
11437: GO 11441
// end ; end ;
11439: GO 11304
11441: POP
11442: POP
// end ; end_of_file
11443: LD_VAR 0 2
11447: RET
// export function MCF_Get ( side , filter ) ; begin
11448: LD_INT 0
11450: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11451: LD_ADDR_VAR 0 3
11455: PUSH
11456: LD_INT 22
11458: PUSH
11459: LD_VAR 0 1
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: LD_VAR 0 2
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: PPUSH
11477: CALL_OW 69
11481: ST_TO_ADDR
// end ;
11482: LD_VAR 0 3
11486: RET
// export function MCF_Lab ( side ) ; begin
11487: LD_INT 0
11489: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11490: LD_ADDR_VAR 0 2
11494: PUSH
11495: LD_INT 22
11497: PUSH
11498: LD_VAR 0 1
11502: PUSH
11503: EMPTY
11504: LIST
11505: LIST
11506: PUSH
11507: LD_INT 30
11509: PUSH
11510: LD_INT 8
11512: PUSH
11513: EMPTY
11514: LIST
11515: LIST
11516: PUSH
11517: EMPTY
11518: LIST
11519: LIST
11520: PPUSH
11521: CALL_OW 69
11525: ST_TO_ADDR
// end ;
11526: LD_VAR 0 2
11530: RET
// export function MCF_Class ( side , class , filter ) ; begin
11531: LD_INT 0
11533: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11534: LD_ADDR_VAR 0 4
11538: PUSH
11539: LD_INT 22
11541: PUSH
11542: LD_VAR 0 1
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: PUSH
11551: LD_INT 25
11553: PUSH
11554: LD_VAR 0 2
11558: PUSH
11559: EMPTY
11560: LIST
11561: LIST
11562: PUSH
11563: LD_VAR 0 3
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: LIST
11572: PPUSH
11573: CALL_OW 69
11577: ST_TO_ADDR
// end ;
11578: LD_VAR 0 4
11582: RET
// export function MCF_All ( side , filter ) ; begin
11583: LD_INT 0
11585: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11586: LD_ADDR_VAR 0 3
11590: PUSH
11591: LD_INT 22
11593: PUSH
11594: LD_VAR 0 1
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: PUSH
11603: LD_INT 2
11605: PUSH
11606: LD_INT 25
11608: PUSH
11609: LD_INT 1
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PUSH
11616: LD_INT 25
11618: PUSH
11619: LD_INT 2
11621: PUSH
11622: EMPTY
11623: LIST
11624: LIST
11625: PUSH
11626: LD_INT 25
11628: PUSH
11629: LD_INT 3
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PUSH
11636: LD_INT 25
11638: PUSH
11639: LD_INT 4
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: EMPTY
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: PUSH
11653: LD_VAR 0 2
11657: PUSH
11658: EMPTY
11659: LIST
11660: LIST
11661: LIST
11662: PPUSH
11663: CALL_OW 69
11667: ST_TO_ADDR
// end ;
11668: LD_VAR 0 3
11672: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11673: LD_INT 0
11675: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11676: LD_ADDR_VAR 0 4
11680: PUSH
11681: LD_INT 22
11683: PUSH
11684: LD_VAR 0 1
11688: PUSH
11689: EMPTY
11690: LIST
11691: LIST
11692: PUSH
11693: LD_INT 92
11695: PUSH
11696: LD_VAR 0 2
11700: PUSH
11701: LD_INT 1
11703: ARRAY
11704: PUSH
11705: LD_VAR 0 2
11709: PUSH
11710: LD_INT 2
11712: ARRAY
11713: PUSH
11714: LD_VAR 0 2
11718: PUSH
11719: LD_INT 3
11721: ARRAY
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: PUSH
11729: LD_VAR 0 3
11733: PUSH
11734: EMPTY
11735: LIST
11736: LIST
11737: LIST
11738: PPUSH
11739: CALL_OW 69
11743: ST_TO_ADDR
// end ;
11744: LD_VAR 0 4
11748: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11749: LD_INT 0
11751: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11752: LD_ADDR_VAR 0 3
11756: PUSH
11757: LD_INT 22
11759: PUSH
11760: LD_VAR 0 1
11764: PUSH
11765: EMPTY
11766: LIST
11767: LIST
11768: PUSH
11769: LD_INT 21
11771: PUSH
11772: LD_INT 2
11774: PUSH
11775: EMPTY
11776: LIST
11777: LIST
11778: PUSH
11779: LD_VAR 0 2
11783: PUSH
11784: EMPTY
11785: LIST
11786: LIST
11787: LIST
11788: PPUSH
11789: CALL_OW 69
11793: ST_TO_ADDR
// end ;
11794: LD_VAR 0 3
11798: RET
// export function MCF_Cargo ( side ) ; begin
11799: LD_INT 0
11801: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11802: LD_ADDR_VAR 0 2
11806: PUSH
11807: LD_VAR 0 1
11811: PPUSH
11812: LD_INT 2
11814: PUSH
11815: LD_INT 34
11817: PUSH
11818: LD_INT 12
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: PUSH
11825: LD_INT 34
11827: PUSH
11828: LD_INT 32
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 34
11837: PUSH
11838: LD_INT 51
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: PPUSH
11851: CALL 11749 0 2
11855: ST_TO_ADDR
// end ;
11856: LD_VAR 0 2
11860: RET
// export function MCF_Ape ( side ) ; begin
11861: LD_INT 0
11863: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11864: LD_ADDR_VAR 0 2
11868: PUSH
11869: LD_INT 22
11871: PUSH
11872: LD_VAR 0 1
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: PUSH
11881: LD_INT 2
11883: PUSH
11884: LD_INT 25
11886: PUSH
11887: LD_INT 12
11889: PUSH
11890: EMPTY
11891: LIST
11892: LIST
11893: PUSH
11894: LD_INT 25
11896: PUSH
11897: LD_INT 15
11899: PUSH
11900: EMPTY
11901: LIST
11902: LIST
11903: PUSH
11904: LD_INT 25
11906: PUSH
11907: LD_INT 16
11909: PUSH
11910: EMPTY
11911: LIST
11912: LIST
11913: PUSH
11914: LD_INT 25
11916: PUSH
11917: LD_INT 17
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: LIST
11928: LIST
11929: LIST
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: PPUSH
11935: CALL_OW 69
11939: ST_TO_ADDR
// end ;
11940: LD_VAR 0 2
11944: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
11945: LD_INT 0
11947: PPUSH
11948: PPUSH
11949: PPUSH
11950: PPUSH
// result := [ ] ;
11951: LD_ADDR_VAR 0 3
11955: PUSH
11956: EMPTY
11957: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
11958: LD_ADDR_VAR 0 4
11962: PUSH
11963: LD_VAR 0 1
11967: PPUSH
11968: CALL 11861 0 1
11972: ST_TO_ADDR
// case type of 0 , normal :
11973: LD_VAR 0 2
11977: PUSH
11978: LD_INT 0
11980: DOUBLE
11981: EQUAL
11982: IFTRUE 11992
11984: LD_STRING normal
11986: DOUBLE
11987: EQUAL
11988: IFTRUE 11992
11990: GO 12003
11992: POP
// cl := class_apeman ; 1 , soldier :
11993: LD_ADDR_VAR 0 5
11997: PUSH
11998: LD_INT 12
12000: ST_TO_ADDR
12001: GO 12079
12003: LD_INT 1
12005: DOUBLE
12006: EQUAL
12007: IFTRUE 12017
12009: LD_STRING soldier
12011: DOUBLE
12012: EQUAL
12013: IFTRUE 12017
12015: GO 12028
12017: POP
// cl := class_apeman_soldier ; 2 , engineer :
12018: LD_ADDR_VAR 0 5
12022: PUSH
12023: LD_INT 15
12025: ST_TO_ADDR
12026: GO 12079
12028: LD_INT 2
12030: DOUBLE
12031: EQUAL
12032: IFTRUE 12042
12034: LD_STRING engineer
12036: DOUBLE
12037: EQUAL
12038: IFTRUE 12042
12040: GO 12053
12042: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12043: LD_ADDR_VAR 0 5
12047: PUSH
12048: LD_INT 16
12050: ST_TO_ADDR
12051: GO 12079
12053: LD_INT 3
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12067
12059: LD_STRING kamikaze
12061: DOUBLE
12062: EQUAL
12063: IFTRUE 12067
12065: GO 12078
12067: POP
// cl := class_apeman_kamikaze ; end ;
12068: LD_ADDR_VAR 0 5
12072: PUSH
12073: LD_INT 17
12075: ST_TO_ADDR
12076: GO 12079
12078: POP
// for i = 1 to tmp do
12079: LD_ADDR_VAR 0 6
12083: PUSH
12084: DOUBLE
12085: LD_INT 1
12087: DEC
12088: ST_TO_ADDR
12089: LD_VAR 0 4
12093: PUSH
12094: FOR_TO
12095: IFFALSE 12144
// if GetClass ( tmp [ i ] ) = cl then
12097: LD_VAR 0 4
12101: PUSH
12102: LD_VAR 0 6
12106: ARRAY
12107: PPUSH
12108: CALL_OW 257
12112: PUSH
12113: LD_VAR 0 5
12117: EQUAL
12118: IFFALSE 12142
// result := result ^ tmp [ i ] ;
12120: LD_ADDR_VAR 0 3
12124: PUSH
12125: LD_VAR 0 3
12129: PUSH
12130: LD_VAR 0 4
12134: PUSH
12135: LD_VAR 0 6
12139: ARRAY
12140: ADD
12141: ST_TO_ADDR
12142: GO 12094
12144: POP
12145: POP
// end ;
12146: LD_VAR 0 3
12150: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12151: LD_INT 0
12153: PPUSH
12154: PPUSH
12155: PPUSH
12156: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12157: LD_ADDR_VAR 0 5
12161: PUSH
12162: LD_INT 22
12164: PUSH
12165: LD_VAR 0 1
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: PUSH
12174: LD_VAR 0 3
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 69
12187: ST_TO_ADDR
// r := [ ] ;
12188: LD_ADDR_VAR 0 6
12192: PUSH
12193: EMPTY
12194: ST_TO_ADDR
// if tmp then
12195: LD_VAR 0 5
12199: IFFALSE 12268
// for i = 1 to tmp do
12201: LD_ADDR_VAR 0 7
12205: PUSH
12206: DOUBLE
12207: LD_INT 1
12209: DEC
12210: ST_TO_ADDR
12211: LD_VAR 0 5
12215: PUSH
12216: FOR_TO
12217: IFFALSE 12266
// if GetTag ( tmp [ i ] ) = tag then
12219: LD_VAR 0 5
12223: PUSH
12224: LD_VAR 0 7
12228: ARRAY
12229: PPUSH
12230: CALL_OW 110
12234: PUSH
12235: LD_VAR 0 2
12239: EQUAL
12240: IFFALSE 12264
// r := r ^ tmp [ i ] ;
12242: LD_ADDR_VAR 0 6
12246: PUSH
12247: LD_VAR 0 6
12251: PUSH
12252: LD_VAR 0 5
12256: PUSH
12257: LD_VAR 0 7
12261: ARRAY
12262: ADD
12263: ST_TO_ADDR
12264: GO 12216
12266: POP
12267: POP
// result := r ;
12268: LD_ADDR_VAR 0 4
12272: PUSH
12273: LD_VAR 0 6
12277: ST_TO_ADDR
// end ;
12278: LD_VAR 0 4
12282: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12283: LD_INT 0
12285: PPUSH
12286: PPUSH
12287: PPUSH
// tmp := plist ;
12288: LD_ADDR_VAR 0 5
12292: PUSH
12293: LD_VAR 0 2
12297: ST_TO_ADDR
// if tmp then
12298: LD_VAR 0 5
12302: IFFALSE 12379
// begin for i = 1 to tmp do
12304: LD_ADDR_VAR 0 6
12308: PUSH
12309: DOUBLE
12310: LD_INT 1
12312: DEC
12313: ST_TO_ADDR
12314: LD_VAR 0 5
12318: PUSH
12319: FOR_TO
12320: IFFALSE 12367
// if GetTag ( tmp [ i ] ) <> tag then
12322: LD_VAR 0 5
12326: PUSH
12327: LD_VAR 0 6
12331: ARRAY
12332: PPUSH
12333: CALL_OW 110
12337: PUSH
12338: LD_VAR 0 3
12342: NONEQUAL
12343: IFFALSE 12365
// SetTag ( tmp [ i ] , tag ) ;
12345: LD_VAR 0 5
12349: PUSH
12350: LD_VAR 0 6
12354: ARRAY
12355: PPUSH
12356: LD_VAR 0 3
12360: PPUSH
12361: CALL_OW 109
12365: GO 12319
12367: POP
12368: POP
// result := true ;
12369: LD_ADDR_VAR 0 4
12373: PUSH
12374: LD_INT 1
12376: ST_TO_ADDR
// end else
12377: GO 12387
// result := false ;
12379: LD_ADDR_VAR 0 4
12383: PUSH
12384: LD_INT 0
12386: ST_TO_ADDR
// end ;
12387: LD_VAR 0 4
12391: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12392: LD_INT 0
12394: PPUSH
12395: PPUSH
12396: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12397: LD_ADDR_VAR 0 4
12401: PUSH
12402: LD_VAR 0 1
12406: PPUSH
12407: LD_VAR 0 2
12411: PPUSH
12412: EMPTY
12413: PPUSH
12414: CALL 12151 0 3
12418: ST_TO_ADDR
// if tmp then
12419: LD_VAR 0 4
12423: IFFALSE 12475
// begin for i = 1 to tmp do
12425: LD_ADDR_VAR 0 5
12429: PUSH
12430: DOUBLE
12431: LD_INT 1
12433: DEC
12434: ST_TO_ADDR
12435: LD_VAR 0 4
12439: PUSH
12440: FOR_TO
12441: IFFALSE 12463
// SetTag ( tmp [ i ] , 0 ) ;
12443: LD_VAR 0 4
12447: PUSH
12448: LD_VAR 0 5
12452: ARRAY
12453: PPUSH
12454: LD_INT 0
12456: PPUSH
12457: CALL_OW 109
12461: GO 12440
12463: POP
12464: POP
// result := true ;
12465: LD_ADDR_VAR 0 3
12469: PUSH
12470: LD_INT 1
12472: ST_TO_ADDR
// end else
12473: GO 12483
// result := false ;
12475: LD_ADDR_VAR 0 3
12479: PUSH
12480: LD_INT 0
12482: ST_TO_ADDR
// end ;
12483: LD_VAR 0 3
12487: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12488: LD_INT 0
12490: PPUSH
12491: PPUSH
12492: PPUSH
12493: PPUSH
12494: PPUSH
// sort_list := [ ] ;
12495: LD_ADDR_VAR 0 5
12499: PUSH
12500: EMPTY
12501: ST_TO_ADDR
// for i = 1 to list do
12502: LD_ADDR_VAR 0 3
12506: PUSH
12507: DOUBLE
12508: LD_INT 1
12510: DEC
12511: ST_TO_ADDR
12512: LD_VAR 0 1
12516: PUSH
12517: FOR_TO
12518: IFFALSE 12680
// begin if i = 1 then
12520: LD_VAR 0 3
12524: PUSH
12525: LD_INT 1
12527: EQUAL
12528: IFFALSE 12554
// sort_list := sort_list ^ list [ i ] else
12530: LD_ADDR_VAR 0 5
12534: PUSH
12535: LD_VAR 0 5
12539: PUSH
12540: LD_VAR 0 1
12544: PUSH
12545: LD_VAR 0 3
12549: ARRAY
12550: ADD
12551: ST_TO_ADDR
12552: GO 12678
// begin for j = 1 to sort_list do
12554: LD_ADDR_VAR 0 4
12558: PUSH
12559: DOUBLE
12560: LD_INT 1
12562: DEC
12563: ST_TO_ADDR
12564: LD_VAR 0 5
12568: PUSH
12569: FOR_TO
12570: IFFALSE 12647
// begin add := false ;
12572: LD_ADDR_VAR 0 6
12576: PUSH
12577: LD_INT 0
12579: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12580: LD_VAR 0 1
12584: PUSH
12585: LD_VAR 0 3
12589: ARRAY
12590: PUSH
12591: LD_VAR 0 5
12595: PUSH
12596: LD_VAR 0 4
12600: ARRAY
12601: LESS
12602: IFFALSE 12645
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12604: LD_ADDR_VAR 0 5
12608: PUSH
12609: LD_VAR 0 5
12613: PPUSH
12614: LD_VAR 0 4
12618: PPUSH
12619: LD_VAR 0 1
12623: PUSH
12624: LD_VAR 0 3
12628: ARRAY
12629: PPUSH
12630: CALL_OW 2
12634: ST_TO_ADDR
// add := true ;
12635: LD_ADDR_VAR 0 6
12639: PUSH
12640: LD_INT 1
12642: ST_TO_ADDR
// break ;
12643: GO 12647
// end ; end ;
12645: GO 12569
12647: POP
12648: POP
// if not add then
12649: LD_VAR 0 6
12653: NOT
12654: IFFALSE 12678
// sort_list := sort_list ^ list [ i ] ;
12656: LD_ADDR_VAR 0 5
12660: PUSH
12661: LD_VAR 0 5
12665: PUSH
12666: LD_VAR 0 1
12670: PUSH
12671: LD_VAR 0 3
12675: ARRAY
12676: ADD
12677: ST_TO_ADDR
// end ; end ;
12678: GO 12517
12680: POP
12681: POP
// result := sort_list ;
12682: LD_ADDR_VAR 0 2
12686: PUSH
12687: LD_VAR 0 5
12691: ST_TO_ADDR
// end ;
12692: LD_VAR 0 2
12696: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12697: LD_INT 0
12699: PPUSH
12700: PPUSH
12701: PPUSH
12702: PPUSH
12703: PPUSH
// sort_list := [ ] ;
12704: LD_ADDR_VAR 0 5
12708: PUSH
12709: EMPTY
12710: ST_TO_ADDR
// for i = 1 to list do
12711: LD_ADDR_VAR 0 3
12715: PUSH
12716: DOUBLE
12717: LD_INT 1
12719: DEC
12720: ST_TO_ADDR
12721: LD_VAR 0 1
12725: PUSH
12726: FOR_TO
12727: IFFALSE 12889
// begin if i = 1 then
12729: LD_VAR 0 3
12733: PUSH
12734: LD_INT 1
12736: EQUAL
12737: IFFALSE 12763
// sort_list := sort_list ^ list [ i ] else
12739: LD_ADDR_VAR 0 5
12743: PUSH
12744: LD_VAR 0 5
12748: PUSH
12749: LD_VAR 0 1
12753: PUSH
12754: LD_VAR 0 3
12758: ARRAY
12759: ADD
12760: ST_TO_ADDR
12761: GO 12887
// begin for j = 1 to sort_list do
12763: LD_ADDR_VAR 0 4
12767: PUSH
12768: DOUBLE
12769: LD_INT 1
12771: DEC
12772: ST_TO_ADDR
12773: LD_VAR 0 5
12777: PUSH
12778: FOR_TO
12779: IFFALSE 12856
// begin add := false ;
12781: LD_ADDR_VAR 0 6
12785: PUSH
12786: LD_INT 0
12788: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12789: LD_VAR 0 1
12793: PUSH
12794: LD_VAR 0 3
12798: ARRAY
12799: PUSH
12800: LD_VAR 0 5
12804: PUSH
12805: LD_VAR 0 4
12809: ARRAY
12810: GREATER
12811: IFFALSE 12854
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12813: LD_ADDR_VAR 0 5
12817: PUSH
12818: LD_VAR 0 5
12822: PPUSH
12823: LD_VAR 0 4
12827: PPUSH
12828: LD_VAR 0 1
12832: PUSH
12833: LD_VAR 0 3
12837: ARRAY
12838: PPUSH
12839: CALL_OW 2
12843: ST_TO_ADDR
// add := true ;
12844: LD_ADDR_VAR 0 6
12848: PUSH
12849: LD_INT 1
12851: ST_TO_ADDR
// break ;
12852: GO 12856
// end ; end ;
12854: GO 12778
12856: POP
12857: POP
// if not add then
12858: LD_VAR 0 6
12862: NOT
12863: IFFALSE 12887
// sort_list := sort_list ^ list [ i ] ;
12865: LD_ADDR_VAR 0 5
12869: PUSH
12870: LD_VAR 0 5
12874: PUSH
12875: LD_VAR 0 1
12879: PUSH
12880: LD_VAR 0 3
12884: ARRAY
12885: ADD
12886: ST_TO_ADDR
// end ; end ;
12887: GO 12726
12889: POP
12890: POP
// result := sort_list ;
12891: LD_ADDR_VAR 0 2
12895: PUSH
12896: LD_VAR 0 5
12900: ST_TO_ADDR
// end ;
12901: LD_VAR 0 2
12905: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12906: LD_INT 0
12908: PPUSH
12909: PPUSH
12910: PPUSH
12911: PPUSH
12912: PPUSH
12913: PPUSH
// tmp := [ ] ;
12914: LD_ADDR_VAR 0 8
12918: PUSH
12919: EMPTY
12920: ST_TO_ADDR
// r := [ ] ;
12921: LD_ADDR_VAR 0 7
12925: PUSH
12926: EMPTY
12927: ST_TO_ADDR
// add := false ;
12928: LD_ADDR_VAR 0 9
12932: PUSH
12933: LD_INT 0
12935: ST_TO_ADDR
// if plist then
12936: LD_VAR 0 2
12940: IFFALSE 13016
// begin for i = 1 to plist do
12942: LD_ADDR_VAR 0 5
12946: PUSH
12947: DOUBLE
12948: LD_INT 1
12950: DEC
12951: ST_TO_ADDR
12952: LD_VAR 0 2
12956: PUSH
12957: FOR_TO
12958: IFFALSE 13012
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12960: LD_ADDR_VAR 0 8
12964: PUSH
12965: LD_VAR 0 8
12969: PUSH
12970: LD_VAR 0 2
12974: PUSH
12975: LD_VAR 0 5
12979: ARRAY
12980: PUSH
12981: LD_VAR 0 2
12985: PUSH
12986: LD_VAR 0 5
12990: ARRAY
12991: PPUSH
12992: LD_VAR 0 3
12996: PPUSH
12997: CALL_OW 259
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: EMPTY
13007: LIST
13008: ADD
13009: ST_TO_ADDR
// end ;
13010: GO 12957
13012: POP
13013: POP
// end else
13014: GO 13024
// result := false ;
13016: LD_ADDR_VAR 0 4
13020: PUSH
13021: LD_INT 0
13023: ST_TO_ADDR
// if tmp then
13024: LD_VAR 0 8
13028: IFFALSE 13202
// begin r := r ^ [ tmp [ 1 ] ] ;
13030: LD_ADDR_VAR 0 7
13034: PUSH
13035: LD_VAR 0 7
13039: PUSH
13040: LD_VAR 0 8
13044: PUSH
13045: LD_INT 1
13047: ARRAY
13048: PUSH
13049: EMPTY
13050: LIST
13051: ADD
13052: ST_TO_ADDR
// for i = 2 to tmp do
13053: LD_ADDR_VAR 0 5
13057: PUSH
13058: DOUBLE
13059: LD_INT 2
13061: DEC
13062: ST_TO_ADDR
13063: LD_VAR 0 8
13067: PUSH
13068: FOR_TO
13069: IFFALSE 13200
// begin for j = 1 to r do
13071: LD_ADDR_VAR 0 6
13075: PUSH
13076: DOUBLE
13077: LD_INT 1
13079: DEC
13080: ST_TO_ADDR
13081: LD_VAR 0 7
13085: PUSH
13086: FOR_TO
13087: IFFALSE 13164
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13089: LD_VAR 0 8
13093: PUSH
13094: LD_VAR 0 5
13098: ARRAY
13099: PUSH
13100: LD_INT 2
13102: ARRAY
13103: PUSH
13104: LD_VAR 0 7
13108: PUSH
13109: LD_VAR 0 6
13113: ARRAY
13114: PUSH
13115: LD_INT 2
13117: ARRAY
13118: LESS
13119: IFFALSE 13162
// begin r := Insert ( r , j , tmp [ i ] ) ;
13121: LD_ADDR_VAR 0 7
13125: PUSH
13126: LD_VAR 0 7
13130: PPUSH
13131: LD_VAR 0 6
13135: PPUSH
13136: LD_VAR 0 8
13140: PUSH
13141: LD_VAR 0 5
13145: ARRAY
13146: PPUSH
13147: CALL_OW 2
13151: ST_TO_ADDR
// add := true ;
13152: LD_ADDR_VAR 0 9
13156: PUSH
13157: LD_INT 1
13159: ST_TO_ADDR
// break ;
13160: GO 13164
// end ; end ;
13162: GO 13086
13164: POP
13165: POP
// if not add then
13166: LD_VAR 0 9
13170: NOT
13171: IFFALSE 13198
// r := r ^ [ tmp [ i ] ] ;
13173: LD_ADDR_VAR 0 7
13177: PUSH
13178: LD_VAR 0 7
13182: PUSH
13183: LD_VAR 0 8
13187: PUSH
13188: LD_VAR 0 5
13192: ARRAY
13193: PUSH
13194: EMPTY
13195: LIST
13196: ADD
13197: ST_TO_ADDR
// end ;
13198: GO 13068
13200: POP
13201: POP
// end ; result := r ;
13202: LD_ADDR_VAR 0 4
13206: PUSH
13207: LD_VAR 0 7
13211: ST_TO_ADDR
// end ;
13212: LD_VAR 0 4
13216: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13217: LD_INT 0
13219: PPUSH
13220: PPUSH
13221: PPUSH
13222: PPUSH
13223: PPUSH
13224: PPUSH
// tmp := [ ] ;
13225: LD_ADDR_VAR 0 8
13229: PUSH
13230: EMPTY
13231: ST_TO_ADDR
// r := [ ] ;
13232: LD_ADDR_VAR 0 7
13236: PUSH
13237: EMPTY
13238: ST_TO_ADDR
// add := false ;
13239: LD_ADDR_VAR 0 9
13243: PUSH
13244: LD_INT 0
13246: ST_TO_ADDR
// if plist then
13247: LD_VAR 0 2
13251: IFFALSE 13327
// begin for i = 1 to plist do
13253: LD_ADDR_VAR 0 5
13257: PUSH
13258: DOUBLE
13259: LD_INT 1
13261: DEC
13262: ST_TO_ADDR
13263: LD_VAR 0 2
13267: PUSH
13268: FOR_TO
13269: IFFALSE 13323
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13271: LD_ADDR_VAR 0 8
13275: PUSH
13276: LD_VAR 0 8
13280: PUSH
13281: LD_VAR 0 2
13285: PUSH
13286: LD_VAR 0 5
13290: ARRAY
13291: PUSH
13292: LD_VAR 0 2
13296: PUSH
13297: LD_VAR 0 5
13301: ARRAY
13302: PPUSH
13303: LD_VAR 0 3
13307: PPUSH
13308: CALL_OW 259
13312: PUSH
13313: EMPTY
13314: LIST
13315: LIST
13316: PUSH
13317: EMPTY
13318: LIST
13319: ADD
13320: ST_TO_ADDR
// end ;
13321: GO 13268
13323: POP
13324: POP
// end else
13325: GO 13335
// result := false ;
13327: LD_ADDR_VAR 0 4
13331: PUSH
13332: LD_INT 0
13334: ST_TO_ADDR
// if tmp then
13335: LD_VAR 0 8
13339: IFFALSE 13513
// begin r := r ^ [ tmp [ 1 ] ] ;
13341: LD_ADDR_VAR 0 7
13345: PUSH
13346: LD_VAR 0 7
13350: PUSH
13351: LD_VAR 0 8
13355: PUSH
13356: LD_INT 1
13358: ARRAY
13359: PUSH
13360: EMPTY
13361: LIST
13362: ADD
13363: ST_TO_ADDR
// for i = 2 to tmp do
13364: LD_ADDR_VAR 0 5
13368: PUSH
13369: DOUBLE
13370: LD_INT 2
13372: DEC
13373: ST_TO_ADDR
13374: LD_VAR 0 8
13378: PUSH
13379: FOR_TO
13380: IFFALSE 13511
// begin for j = 1 to r do
13382: LD_ADDR_VAR 0 6
13386: PUSH
13387: DOUBLE
13388: LD_INT 1
13390: DEC
13391: ST_TO_ADDR
13392: LD_VAR 0 7
13396: PUSH
13397: FOR_TO
13398: IFFALSE 13475
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13400: LD_VAR 0 8
13404: PUSH
13405: LD_VAR 0 5
13409: ARRAY
13410: PUSH
13411: LD_INT 2
13413: ARRAY
13414: PUSH
13415: LD_VAR 0 7
13419: PUSH
13420: LD_VAR 0 6
13424: ARRAY
13425: PUSH
13426: LD_INT 2
13428: ARRAY
13429: GREATER
13430: IFFALSE 13473
// begin r := Insert ( r , j , tmp [ i ] ) ;
13432: LD_ADDR_VAR 0 7
13436: PUSH
13437: LD_VAR 0 7
13441: PPUSH
13442: LD_VAR 0 6
13446: PPUSH
13447: LD_VAR 0 8
13451: PUSH
13452: LD_VAR 0 5
13456: ARRAY
13457: PPUSH
13458: CALL_OW 2
13462: ST_TO_ADDR
// add := true ;
13463: LD_ADDR_VAR 0 9
13467: PUSH
13468: LD_INT 1
13470: ST_TO_ADDR
// break ;
13471: GO 13475
// end ; end ;
13473: GO 13397
13475: POP
13476: POP
// if not add then
13477: LD_VAR 0 9
13481: NOT
13482: IFFALSE 13509
// r := r ^ [ tmp [ i ] ] ;
13484: LD_ADDR_VAR 0 7
13488: PUSH
13489: LD_VAR 0 7
13493: PUSH
13494: LD_VAR 0 8
13498: PUSH
13499: LD_VAR 0 5
13503: ARRAY
13504: PUSH
13505: EMPTY
13506: LIST
13507: ADD
13508: ST_TO_ADDR
// end ;
13509: GO 13379
13511: POP
13512: POP
// end ; result := r ;
13513: LD_ADDR_VAR 0 4
13517: PUSH
13518: LD_VAR 0 7
13522: ST_TO_ADDR
// end ;
13523: LD_VAR 0 4
13527: RET
// export function MCF_Clear ( side ) ; var i ; begin
13528: LD_INT 0
13530: PPUSH
13531: PPUSH
// for i = 1 to 100 do
13532: LD_ADDR_VAR 0 3
13536: PUSH
13537: DOUBLE
13538: LD_INT 1
13540: DEC
13541: ST_TO_ADDR
13542: LD_INT 100
13544: PUSH
13545: FOR_TO
13546: IFFALSE 13582
// if MCF_Tag ( side , i , [ ] ) then
13548: LD_VAR 0 1
13552: PPUSH
13553: LD_VAR 0 3
13557: PPUSH
13558: EMPTY
13559: PPUSH
13560: CALL 12151 0 3
13564: IFFALSE 13580
// MCF_ClearTag ( side , i ) ;
13566: LD_VAR 0 1
13570: PPUSH
13571: LD_VAR 0 3
13575: PPUSH
13576: CALL 12392 0 2
13580: GO 13545
13582: POP
13583: POP
// result := true ;
13584: LD_ADDR_VAR 0 2
13588: PUSH
13589: LD_INT 1
13591: ST_TO_ADDR
// end ;
13592: LD_VAR 0 2
13596: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13597: LD_INT 0
13599: PPUSH
13600: PPUSH
13601: PPUSH
// for i = 1 to plist do
13602: LD_ADDR_VAR 0 4
13606: PUSH
13607: DOUBLE
13608: LD_INT 1
13610: DEC
13611: ST_TO_ADDR
13612: LD_VAR 0 1
13616: PUSH
13617: FOR_TO
13618: IFFALSE 13667
// if MCF_HasClass ( plist [ i ] ) = n then
13620: LD_VAR 0 1
13624: PUSH
13625: LD_VAR 0 4
13629: ARRAY
13630: PPUSH
13631: CALL 14154 0 1
13635: PUSH
13636: LD_VAR 0 2
13640: EQUAL
13641: IFFALSE 13665
// tmp := tmp ^ plist [ i ] ;
13643: LD_ADDR_VAR 0 5
13647: PUSH
13648: LD_VAR 0 5
13652: PUSH
13653: LD_VAR 0 1
13657: PUSH
13658: LD_VAR 0 4
13662: ARRAY
13663: ADD
13664: ST_TO_ADDR
13665: GO 13617
13667: POP
13668: POP
// result := tmp ;
13669: LD_ADDR_VAR 0 3
13673: PUSH
13674: LD_VAR 0 5
13678: ST_TO_ADDR
// end ;
13679: LD_VAR 0 3
13683: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13684: LD_INT 0
13686: PPUSH
13687: PPUSH
13688: PPUSH
// if mreg = ToArm then
13689: LD_VAR 0 2
13693: PUSH
13694: LD_STRING ToArm
13696: EQUAL
13697: IFFALSE 13802
// begin tmp := MREG_ToArm [ side ] ;
13699: LD_ADDR_VAR 0 6
13703: PUSH
13704: LD_EXP 58
13708: PUSH
13709: LD_VAR 0 1
13713: ARRAY
13714: ST_TO_ADDR
// if tmp = 0 then
13715: LD_VAR 0 6
13719: PUSH
13720: LD_INT 0
13722: EQUAL
13723: IFFALSE 13729
// exit else
13725: GO 14149
13727: GO 13802
// begin for i = MREG_ToArm [ side ] downto n do
13729: LD_ADDR_VAR 0 5
13733: PUSH
13734: DOUBLE
13735: LD_EXP 58
13739: PUSH
13740: LD_VAR 0 1
13744: ARRAY
13745: INC
13746: ST_TO_ADDR
13747: LD_VAR 0 3
13751: PUSH
13752: FOR_DOWNTO
13753: IFFALSE 13775
// tmp := Delete ( tmp , 1 ) ;
13755: LD_ADDR_VAR 0 6
13759: PUSH
13760: LD_VAR 0 6
13764: PPUSH
13765: LD_INT 1
13767: PPUSH
13768: CALL_OW 3
13772: ST_TO_ADDR
13773: GO 13752
13775: POP
13776: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13777: LD_ADDR_EXP 58
13781: PUSH
13782: LD_EXP 58
13786: PPUSH
13787: LD_VAR 0 1
13791: PPUSH
13792: LD_VAR 0 6
13796: PPUSH
13797: CALL_OW 1
13801: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13802: LD_VAR 0 2
13806: PUSH
13807: LD_STRING ToDep
13809: EQUAL
13810: IFFALSE 13915
// begin tmp := MREG_ToDep [ side ] ;
13812: LD_ADDR_VAR 0 6
13816: PUSH
13817: LD_EXP 59
13821: PUSH
13822: LD_VAR 0 1
13826: ARRAY
13827: ST_TO_ADDR
// if tmp = 0 then
13828: LD_VAR 0 6
13832: PUSH
13833: LD_INT 0
13835: EQUAL
13836: IFFALSE 13842
// exit else
13838: GO 14149
13840: GO 13915
// begin for i = MREG_ToDep [ side ] downto n do
13842: LD_ADDR_VAR 0 5
13846: PUSH
13847: DOUBLE
13848: LD_EXP 59
13852: PUSH
13853: LD_VAR 0 1
13857: ARRAY
13858: INC
13859: ST_TO_ADDR
13860: LD_VAR 0 3
13864: PUSH
13865: FOR_DOWNTO
13866: IFFALSE 13888
// tmp := Delete ( tmp , 1 ) ;
13868: LD_ADDR_VAR 0 6
13872: PUSH
13873: LD_VAR 0 6
13877: PPUSH
13878: LD_INT 1
13880: PPUSH
13881: CALL_OW 3
13885: ST_TO_ADDR
13886: GO 13865
13888: POP
13889: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13890: LD_ADDR_EXP 59
13894: PUSH
13895: LD_EXP 59
13899: PPUSH
13900: LD_VAR 0 1
13904: PPUSH
13905: LD_VAR 0 6
13909: PPUSH
13910: CALL_OW 1
13914: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
13915: LD_VAR 0 2
13919: PUSH
13920: LD_STRING ToFac
13922: EQUAL
13923: IFFALSE 14028
// begin tmp := MREG_ToFac [ side ] ;
13925: LD_ADDR_VAR 0 6
13929: PUSH
13930: LD_EXP 57
13934: PUSH
13935: LD_VAR 0 1
13939: ARRAY
13940: ST_TO_ADDR
// if tmp = 0 then
13941: LD_VAR 0 6
13945: PUSH
13946: LD_INT 0
13948: EQUAL
13949: IFFALSE 13955
// exit else
13951: GO 14149
13953: GO 14028
// begin for i = MREG_ToFac [ side ] downto n do
13955: LD_ADDR_VAR 0 5
13959: PUSH
13960: DOUBLE
13961: LD_EXP 57
13965: PUSH
13966: LD_VAR 0 1
13970: ARRAY
13971: INC
13972: ST_TO_ADDR
13973: LD_VAR 0 3
13977: PUSH
13978: FOR_DOWNTO
13979: IFFALSE 14001
// tmp := Delete ( tmp , 1 ) ;
13981: LD_ADDR_VAR 0 6
13985: PUSH
13986: LD_VAR 0 6
13990: PPUSH
13991: LD_INT 1
13993: PPUSH
13994: CALL_OW 3
13998: ST_TO_ADDR
13999: GO 13978
14001: POP
14002: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14003: LD_ADDR_EXP 57
14007: PUSH
14008: LD_EXP 57
14012: PPUSH
14013: LD_VAR 0 1
14017: PPUSH
14018: LD_VAR 0 6
14022: PPUSH
14023: CALL_OW 1
14027: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14028: LD_VAR 0 2
14032: PUSH
14033: LD_STRING ToLab
14035: EQUAL
14036: IFFALSE 14141
// begin tmp := MREG_ToLab [ side ] ;
14038: LD_ADDR_VAR 0 6
14042: PUSH
14043: LD_EXP 56
14047: PUSH
14048: LD_VAR 0 1
14052: ARRAY
14053: ST_TO_ADDR
// if tmp = 0 then
14054: LD_VAR 0 6
14058: PUSH
14059: LD_INT 0
14061: EQUAL
14062: IFFALSE 14068
// exit else
14064: GO 14149
14066: GO 14141
// begin for i = MREG_ToLab [ side ] downto n do
14068: LD_ADDR_VAR 0 5
14072: PUSH
14073: DOUBLE
14074: LD_EXP 56
14078: PUSH
14079: LD_VAR 0 1
14083: ARRAY
14084: INC
14085: ST_TO_ADDR
14086: LD_VAR 0 3
14090: PUSH
14091: FOR_DOWNTO
14092: IFFALSE 14114
// tmp := Delete ( tmp , 1 ) ;
14094: LD_ADDR_VAR 0 6
14098: PUSH
14099: LD_VAR 0 6
14103: PPUSH
14104: LD_INT 1
14106: PPUSH
14107: CALL_OW 3
14111: ST_TO_ADDR
14112: GO 14091
14114: POP
14115: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14116: LD_ADDR_EXP 56
14120: PUSH
14121: LD_EXP 56
14125: PPUSH
14126: LD_VAR 0 1
14130: PPUSH
14131: LD_VAR 0 6
14135: PPUSH
14136: CALL_OW 1
14140: ST_TO_ADDR
// end ; end ; result := true ;
14141: LD_ADDR_VAR 0 4
14145: PUSH
14146: LD_INT 1
14148: ST_TO_ADDR
// end ;
14149: LD_VAR 0 4
14153: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14154: LD_INT 0
14156: PPUSH
14157: PPUSH
14158: PPUSH
// side := GetSide ( unit ) ;
14159: LD_ADDR_VAR 0 4
14163: PUSH
14164: LD_VAR 0 1
14168: PPUSH
14169: CALL_OW 255
14173: ST_TO_ADDR
// tmp := 0 ;
14174: LD_ADDR_VAR 0 3
14178: PUSH
14179: LD_INT 0
14181: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14182: LD_VAR 0 1
14186: PUSH
14187: LD_EXP 58
14191: PUSH
14192: LD_VAR 0 4
14196: ARRAY
14197: IN
14198: IFFALSE 14208
// tmp := 1 ;
14200: LD_ADDR_VAR 0 3
14204: PUSH
14205: LD_INT 1
14207: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14208: LD_VAR 0 1
14212: PUSH
14213: LD_EXP 59
14217: PUSH
14218: LD_VAR 0 4
14222: ARRAY
14223: IN
14224: IFFALSE 14234
// tmp := 2 ;
14226: LD_ADDR_VAR 0 3
14230: PUSH
14231: LD_INT 2
14233: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14234: LD_VAR 0 1
14238: PUSH
14239: LD_EXP 57
14243: PUSH
14244: LD_VAR 0 4
14248: ARRAY
14249: IN
14250: IFFALSE 14260
// tmp := 3 ;
14252: LD_ADDR_VAR 0 3
14256: PUSH
14257: LD_INT 3
14259: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14260: LD_VAR 0 1
14264: PUSH
14265: LD_EXP 56
14269: PUSH
14270: LD_VAR 0 4
14274: ARRAY
14275: IN
14276: IFFALSE 14286
// tmp := 4 ;
14278: LD_ADDR_VAR 0 3
14282: PUSH
14283: LD_INT 4
14285: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14286: LD_VAR 0 1
14290: PUSH
14291: LD_EXP 70
14295: PUSH
14296: LD_VAR 0 4
14300: ARRAY
14301: IN
14302: IFFALSE 14312
// tmp := 5 ;
14304: LD_ADDR_VAR 0 3
14308: PUSH
14309: LD_INT 5
14311: ST_TO_ADDR
// result := tmp ;
14312: LD_ADDR_VAR 0 2
14316: PUSH
14317: LD_VAR 0 3
14321: ST_TO_ADDR
// end ;
14322: LD_VAR 0 2
14326: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14327: LD_INT 0
14329: PPUSH
14330: PPUSH
// if mreg = ToArm then
14331: LD_VAR 0 2
14335: PUSH
14336: LD_STRING ToArm
14338: EQUAL
14339: IFFALSE 14428
// for i = MREG_ToArm [ side ] downto 1 do
14341: LD_ADDR_VAR 0 5
14345: PUSH
14346: DOUBLE
14347: LD_EXP 58
14351: PUSH
14352: LD_VAR 0 1
14356: ARRAY
14357: INC
14358: ST_TO_ADDR
14359: LD_INT 1
14361: PUSH
14362: FOR_DOWNTO
14363: IFFALSE 14426
// if MREG_ToArm [ side ] [ i ] = unit then
14365: LD_EXP 58
14369: PUSH
14370: LD_VAR 0 1
14374: ARRAY
14375: PUSH
14376: LD_VAR 0 5
14380: ARRAY
14381: PUSH
14382: LD_VAR 0 3
14386: EQUAL
14387: IFFALSE 14424
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14389: LD_ADDR_EXP 58
14393: PUSH
14394: LD_EXP 58
14398: PPUSH
14399: LD_EXP 58
14403: PUSH
14404: LD_VAR 0 1
14408: ARRAY
14409: PUSH
14410: LD_VAR 0 5
14414: ARRAY
14415: PPUSH
14416: LD_INT 1
14418: PPUSH
14419: CALL 31041 0 3
14423: ST_TO_ADDR
// end ;
14424: GO 14362
14426: POP
14427: POP
// if mreg = ToDep then
14428: LD_VAR 0 2
14432: PUSH
14433: LD_STRING ToDep
14435: EQUAL
14436: IFFALSE 14525
// for i = MREG_ToDep [ side ] downto 1 do
14438: LD_ADDR_VAR 0 5
14442: PUSH
14443: DOUBLE
14444: LD_EXP 59
14448: PUSH
14449: LD_VAR 0 1
14453: ARRAY
14454: INC
14455: ST_TO_ADDR
14456: LD_INT 1
14458: PUSH
14459: FOR_DOWNTO
14460: IFFALSE 14523
// if MREG_ToDep [ side ] [ i ] = unit then
14462: LD_EXP 59
14466: PUSH
14467: LD_VAR 0 1
14471: ARRAY
14472: PUSH
14473: LD_VAR 0 5
14477: ARRAY
14478: PUSH
14479: LD_VAR 0 3
14483: EQUAL
14484: IFFALSE 14521
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14486: LD_ADDR_EXP 59
14490: PUSH
14491: LD_EXP 59
14495: PPUSH
14496: LD_EXP 59
14500: PUSH
14501: LD_VAR 0 1
14505: ARRAY
14506: PUSH
14507: LD_VAR 0 5
14511: ARRAY
14512: PPUSH
14513: LD_INT 1
14515: PPUSH
14516: CALL 31041 0 3
14520: ST_TO_ADDR
// end ;
14521: GO 14459
14523: POP
14524: POP
// if mreg = ToFac then
14525: LD_VAR 0 2
14529: PUSH
14530: LD_STRING ToFac
14532: EQUAL
14533: IFFALSE 14622
// for i = MREG_ToFac [ side ] downto 1 do
14535: LD_ADDR_VAR 0 5
14539: PUSH
14540: DOUBLE
14541: LD_EXP 57
14545: PUSH
14546: LD_VAR 0 1
14550: ARRAY
14551: INC
14552: ST_TO_ADDR
14553: LD_INT 1
14555: PUSH
14556: FOR_DOWNTO
14557: IFFALSE 14620
// if MREG_ToFac [ side ] [ i ] = unit then
14559: LD_EXP 57
14563: PUSH
14564: LD_VAR 0 1
14568: ARRAY
14569: PUSH
14570: LD_VAR 0 5
14574: ARRAY
14575: PUSH
14576: LD_VAR 0 3
14580: EQUAL
14581: IFFALSE 14618
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14583: LD_ADDR_EXP 57
14587: PUSH
14588: LD_EXP 57
14592: PPUSH
14593: LD_EXP 57
14597: PUSH
14598: LD_VAR 0 1
14602: ARRAY
14603: PUSH
14604: LD_VAR 0 5
14608: ARRAY
14609: PPUSH
14610: LD_INT 1
14612: PPUSH
14613: CALL 31041 0 3
14617: ST_TO_ADDR
// end ;
14618: GO 14556
14620: POP
14621: POP
// if mreg = ToLab then
14622: LD_VAR 0 2
14626: PUSH
14627: LD_STRING ToLab
14629: EQUAL
14630: IFFALSE 14719
// for i = MREG_ToLab [ side ] downto 1 do
14632: LD_ADDR_VAR 0 5
14636: PUSH
14637: DOUBLE
14638: LD_EXP 56
14642: PUSH
14643: LD_VAR 0 1
14647: ARRAY
14648: INC
14649: ST_TO_ADDR
14650: LD_INT 1
14652: PUSH
14653: FOR_DOWNTO
14654: IFFALSE 14717
// if MREG_ToLab [ side ] [ i ] = unit then
14656: LD_EXP 56
14660: PUSH
14661: LD_VAR 0 1
14665: ARRAY
14666: PUSH
14667: LD_VAR 0 5
14671: ARRAY
14672: PUSH
14673: LD_VAR 0 3
14677: EQUAL
14678: IFFALSE 14715
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14680: LD_ADDR_EXP 56
14684: PUSH
14685: LD_EXP 56
14689: PPUSH
14690: LD_EXP 56
14694: PUSH
14695: LD_VAR 0 1
14699: ARRAY
14700: PUSH
14701: LD_VAR 0 5
14705: ARRAY
14706: PPUSH
14707: LD_INT 1
14709: PPUSH
14710: CALL 31041 0 3
14714: ST_TO_ADDR
// end ;
14715: GO 14653
14717: POP
14718: POP
// end ;
14719: LD_VAR 0 4
14723: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14724: LD_INT 0
14726: PPUSH
14727: PPUSH
// result := false ;
14728: LD_ADDR_VAR 0 2
14732: PUSH
14733: LD_INT 0
14735: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14736: LD_ADDR_VAR 0 3
14740: PUSH
14741: DOUBLE
14742: LD_INT 1
14744: DEC
14745: ST_TO_ADDR
14746: LD_EXP 48
14750: PUSH
14751: FOR_TO
14752: IFFALSE 14816
// if MREG_ToBuild [ i ] [ 1 ] = side then
14754: LD_EXP 48
14758: PUSH
14759: LD_VAR 0 3
14763: ARRAY
14764: PUSH
14765: LD_INT 1
14767: ARRAY
14768: PUSH
14769: LD_VAR 0 1
14773: EQUAL
14774: IFFALSE 14814
// begin if MREG_ToBuild [ i ] [ 1 ] then
14776: LD_EXP 48
14780: PUSH
14781: LD_VAR 0 3
14785: ARRAY
14786: PUSH
14787: LD_INT 1
14789: ARRAY
14790: IFFALSE 14814
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14792: LD_ADDR_VAR 0 2
14796: PUSH
14797: LD_EXP 48
14801: PUSH
14802: LD_VAR 0 3
14806: ARRAY
14807: PUSH
14808: LD_INT 1
14810: ARRAY
14811: ST_TO_ADDR
// break ;
14812: GO 14816
// end ; end ;
14814: GO 14751
14816: POP
14817: POP
// for i = 1 to MREG_ToRepair do
14818: LD_ADDR_VAR 0 3
14822: PUSH
14823: DOUBLE
14824: LD_INT 1
14826: DEC
14827: ST_TO_ADDR
14828: LD_EXP 49
14832: PUSH
14833: FOR_TO
14834: IFFALSE 14898
// if MREG_ToRepair [ i ] [ 1 ] = side then
14836: LD_EXP 49
14840: PUSH
14841: LD_VAR 0 3
14845: ARRAY
14846: PUSH
14847: LD_INT 1
14849: ARRAY
14850: PUSH
14851: LD_VAR 0 1
14855: EQUAL
14856: IFFALSE 14896
// begin if MREG_ToRepair [ i ] [ 1 ] then
14858: LD_EXP 49
14862: PUSH
14863: LD_VAR 0 3
14867: ARRAY
14868: PUSH
14869: LD_INT 1
14871: ARRAY
14872: IFFALSE 14896
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14874: LD_ADDR_VAR 0 2
14878: PUSH
14879: LD_EXP 49
14883: PUSH
14884: LD_VAR 0 3
14888: ARRAY
14889: PUSH
14890: LD_INT 1
14892: ARRAY
14893: ST_TO_ADDR
// break ;
14894: GO 14898
// end ; end ;
14896: GO 14833
14898: POP
14899: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14900: LD_VAR 0 1
14904: PPUSH
14905: LD_INT 57
14907: PUSH
14908: EMPTY
14909: LIST
14910: PPUSH
14911: CALL 11448 0 2
14915: IFFALSE 14942
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
14917: LD_ADDR_VAR 0 2
14921: PUSH
14922: LD_VAR 0 1
14926: PPUSH
14927: LD_INT 57
14929: PUSH
14930: EMPTY
14931: LIST
14932: PPUSH
14933: CALL 11448 0 2
14937: PUSH
14938: LD_INT 1
14940: ARRAY
14941: ST_TO_ADDR
// end ;
14942: LD_VAR 0 2
14946: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
14947: LD_INT 0
14949: PPUSH
14950: PPUSH
14951: PPUSH
14952: PPUSH
14953: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
14954: LD_ADDR_VAR 0 6
14958: PUSH
14959: LD_VAR 0 1
14963: PPUSH
14964: LD_INT 21
14966: PUSH
14967: LD_INT 3
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL 11448 0 2
14978: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
14979: LD_ADDR_VAR 0 7
14983: PUSH
14984: LD_VAR 0 1
14988: PPUSH
14989: LD_INT 81
14991: PUSH
14992: LD_VAR 0 1
14996: PUSH
14997: EMPTY
14998: LIST
14999: LIST
15000: PPUSH
15001: CALL 11448 0 2
15005: ST_TO_ADDR
// if not enemy then
15006: LD_VAR 0 7
15010: NOT
15011: IFFALSE 15023
// result := false else
15013: LD_ADDR_VAR 0 3
15017: PUSH
15018: LD_INT 0
15020: ST_TO_ADDR
15021: GO 15077
// begin scan := NearestUnit ( b , enemy ) ;
15023: LD_ADDR_VAR 0 5
15027: PUSH
15028: LD_VAR 0 6
15032: PPUSH
15033: LD_VAR 0 7
15037: PPUSH
15038: CALL 32366 0 2
15042: ST_TO_ADDR
// if scan [ 2 ] < dist then
15043: LD_VAR 0 5
15047: PUSH
15048: LD_INT 2
15050: ARRAY
15051: PUSH
15052: LD_VAR 0 2
15056: LESS
15057: IFFALSE 15069
// result := true else
15059: LD_ADDR_VAR 0 3
15063: PUSH
15064: LD_INT 1
15066: ST_TO_ADDR
15067: GO 15077
// result := false ;
15069: LD_ADDR_VAR 0 3
15073: PUSH
15074: LD_INT 0
15076: ST_TO_ADDR
// end ; end ;
15077: LD_VAR 0 3
15081: RET
// export function MCF_Info ( ) ; begin
15082: LD_INT 0
15084: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15085: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15087: PUSH
15088: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15090: ADD
15091: PUSH
15092: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15094: ADD
15095: PUSH
15096: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15098: ADD
15099: PUSH
15100: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15102: ADD
15103: PUSH
15104: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15106: ADD
15107: PUSH
15108: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15110: ADD
15111: PUSH
15112: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15114: ADD
15115: PUSH
15116: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15118: ADD
15119: PUSH
15120: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15122: ADD
15123: PPUSH
15124: CALL 8366 0 1
// end ; end_of_file
15128: LD_VAR 0 1
15132: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15133: LD_INT 0
15135: PPUSH
15136: PPUSH
15137: PPUSH
15138: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15139: LD_ADDR_VAR 0 5
15143: PUSH
15144: LD_VAR 0 1
15148: PPUSH
15149: LD_INT 2
15151: PUSH
15152: LD_INT 25
15154: PUSH
15155: LD_INT 2
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: PUSH
15162: LD_INT 25
15164: PUSH
15165: LD_INT 3
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: LD_INT 25
15174: PUSH
15175: LD_INT 4
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: LIST
15186: LIST
15187: PPUSH
15188: CALL 11448 0 2
15192: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15193: LD_ADDR_VAR 0 5
15197: PUSH
15198: LD_VAR 0 5
15202: PPUSH
15203: LD_INT 0
15205: PPUSH
15206: CALL 13597 0 2
15210: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15211: LD_ADDR_VAR 0 6
15215: PUSH
15216: LD_VAR 0 1
15220: PPUSH
15221: LD_VAR 0 5
15225: PPUSH
15226: LD_INT 1
15228: PPUSH
15229: CALL 13217 0 3
15233: ST_TO_ADDR
// if n > sk then
15234: LD_VAR 0 2
15238: PUSH
15239: LD_VAR 0 6
15243: GREATER
15244: IFFALSE 15256
// n := sk ;
15246: LD_ADDR_VAR 0 2
15250: PUSH
15251: LD_VAR 0 6
15255: ST_TO_ADDR
// for i = 1 to n do
15256: LD_ADDR_VAR 0 4
15260: PUSH
15261: DOUBLE
15262: LD_INT 1
15264: DEC
15265: ST_TO_ADDR
15266: LD_VAR 0 2
15270: PUSH
15271: FOR_TO
15272: IFFALSE 15384
// if ( sk [ i ] [ 1 ] ) <> 0 then
15274: LD_VAR 0 6
15278: PUSH
15279: LD_VAR 0 4
15283: ARRAY
15284: PUSH
15285: LD_INT 1
15287: ARRAY
15288: PUSH
15289: LD_INT 0
15291: NONEQUAL
15292: IFFALSE 15382
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15294: LD_ADDR_EXP 55
15298: PUSH
15299: LD_EXP 55
15303: PPUSH
15304: LD_VAR 0 1
15308: PPUSH
15309: LD_VAR 0 6
15313: PUSH
15314: LD_VAR 0 4
15318: ARRAY
15319: PUSH
15320: LD_INT 1
15322: ARRAY
15323: PPUSH
15324: LD_INT 1
15326: PPUSH
15327: CALL 42162 0 4
15331: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15332: LD_ADDR_EXP 58
15336: PUSH
15337: LD_EXP 58
15341: PPUSH
15342: LD_VAR 0 1
15346: PPUSH
15347: LD_EXP 58
15351: PUSH
15352: LD_VAR 0 1
15356: ARRAY
15357: PUSH
15358: LD_INT 1
15360: PLUS
15361: PPUSH
15362: LD_VAR 0 6
15366: PUSH
15367: LD_VAR 0 4
15371: ARRAY
15372: PUSH
15373: LD_INT 1
15375: ARRAY
15376: PPUSH
15377: CALL 30882 0 4
15381: ST_TO_ADDR
// end ;
15382: GO 15271
15384: POP
15385: POP
// end ;
15386: LD_VAR 0 3
15390: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15391: LD_INT 0
15393: PPUSH
15394: PPUSH
15395: PPUSH
15396: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15397: LD_ADDR_VAR 0 5
15401: PUSH
15402: LD_VAR 0 1
15406: PPUSH
15407: LD_INT 2
15409: PUSH
15410: LD_INT 25
15412: PUSH
15413: LD_INT 1
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: PUSH
15420: LD_INT 25
15422: PUSH
15423: LD_INT 3
15425: PUSH
15426: EMPTY
15427: LIST
15428: LIST
15429: PUSH
15430: LD_INT 25
15432: PUSH
15433: LD_INT 4
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: LIST
15444: LIST
15445: PPUSH
15446: CALL 11448 0 2
15450: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15451: LD_ADDR_VAR 0 5
15455: PUSH
15456: LD_VAR 0 5
15460: PPUSH
15461: LD_INT 0
15463: PPUSH
15464: CALL 13597 0 2
15468: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15469: LD_ADDR_VAR 0 6
15473: PUSH
15474: LD_VAR 0 1
15478: PPUSH
15479: LD_VAR 0 5
15483: PPUSH
15484: LD_INT 2
15486: PPUSH
15487: CALL 13217 0 3
15491: ST_TO_ADDR
// if n > sk then
15492: LD_VAR 0 2
15496: PUSH
15497: LD_VAR 0 6
15501: GREATER
15502: IFFALSE 15514
// n := sk ;
15504: LD_ADDR_VAR 0 2
15508: PUSH
15509: LD_VAR 0 6
15513: ST_TO_ADDR
// for i = 1 to n do
15514: LD_ADDR_VAR 0 4
15518: PUSH
15519: DOUBLE
15520: LD_INT 1
15522: DEC
15523: ST_TO_ADDR
15524: LD_VAR 0 2
15528: PUSH
15529: FOR_TO
15530: IFFALSE 15642
// if ( sk [ i ] [ 1 ] ) <> 0 then
15532: LD_VAR 0 6
15536: PUSH
15537: LD_VAR 0 4
15541: ARRAY
15542: PUSH
15543: LD_INT 1
15545: ARRAY
15546: PUSH
15547: LD_INT 0
15549: NONEQUAL
15550: IFFALSE 15640
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15552: LD_ADDR_EXP 55
15556: PUSH
15557: LD_EXP 55
15561: PPUSH
15562: LD_VAR 0 1
15566: PPUSH
15567: LD_VAR 0 6
15571: PUSH
15572: LD_VAR 0 4
15576: ARRAY
15577: PUSH
15578: LD_INT 1
15580: ARRAY
15581: PPUSH
15582: LD_INT 2
15584: PPUSH
15585: CALL 42162 0 4
15589: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15590: LD_ADDR_EXP 59
15594: PUSH
15595: LD_EXP 59
15599: PPUSH
15600: LD_VAR 0 1
15604: PPUSH
15605: LD_EXP 59
15609: PUSH
15610: LD_VAR 0 1
15614: ARRAY
15615: PUSH
15616: LD_INT 1
15618: PLUS
15619: PPUSH
15620: LD_VAR 0 6
15624: PUSH
15625: LD_VAR 0 4
15629: ARRAY
15630: PUSH
15631: LD_INT 1
15633: ARRAY
15634: PPUSH
15635: CALL 30882 0 4
15639: ST_TO_ADDR
// end ;
15640: GO 15529
15642: POP
15643: POP
// end ;
15644: LD_VAR 0 3
15648: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15649: LD_INT 0
15651: PPUSH
15652: PPUSH
15653: PPUSH
15654: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15655: LD_ADDR_VAR 0 5
15659: PUSH
15660: LD_VAR 0 1
15664: PPUSH
15665: LD_INT 2
15667: PUSH
15668: LD_INT 25
15670: PUSH
15671: LD_INT 1
15673: PUSH
15674: EMPTY
15675: LIST
15676: LIST
15677: PUSH
15678: LD_INT 25
15680: PUSH
15681: LD_INT 2
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PUSH
15688: LD_INT 25
15690: PUSH
15691: LD_INT 4
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: EMPTY
15699: LIST
15700: LIST
15701: LIST
15702: LIST
15703: PPUSH
15704: CALL 11448 0 2
15708: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15709: LD_ADDR_VAR 0 5
15713: PUSH
15714: LD_VAR 0 5
15718: PPUSH
15719: LD_INT 0
15721: PPUSH
15722: CALL 13597 0 2
15726: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15727: LD_ADDR_VAR 0 6
15731: PUSH
15732: LD_VAR 0 1
15736: PPUSH
15737: LD_VAR 0 5
15741: PPUSH
15742: LD_INT 3
15744: PPUSH
15745: CALL 13217 0 3
15749: ST_TO_ADDR
// if n > sk then
15750: LD_VAR 0 2
15754: PUSH
15755: LD_VAR 0 6
15759: GREATER
15760: IFFALSE 15772
// n := sk ;
15762: LD_ADDR_VAR 0 2
15766: PUSH
15767: LD_VAR 0 6
15771: ST_TO_ADDR
// for i = 1 to n do
15772: LD_ADDR_VAR 0 4
15776: PUSH
15777: DOUBLE
15778: LD_INT 1
15780: DEC
15781: ST_TO_ADDR
15782: LD_VAR 0 2
15786: PUSH
15787: FOR_TO
15788: IFFALSE 15900
// if ( sk [ i ] [ 1 ] ) <> 0 then
15790: LD_VAR 0 6
15794: PUSH
15795: LD_VAR 0 4
15799: ARRAY
15800: PUSH
15801: LD_INT 1
15803: ARRAY
15804: PUSH
15805: LD_INT 0
15807: NONEQUAL
15808: IFFALSE 15898
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15810: LD_ADDR_EXP 55
15814: PUSH
15815: LD_EXP 55
15819: PPUSH
15820: LD_VAR 0 1
15824: PPUSH
15825: LD_VAR 0 6
15829: PUSH
15830: LD_VAR 0 4
15834: ARRAY
15835: PUSH
15836: LD_INT 1
15838: ARRAY
15839: PPUSH
15840: LD_INT 3
15842: PPUSH
15843: CALL 42162 0 4
15847: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15848: LD_ADDR_EXP 57
15852: PUSH
15853: LD_EXP 57
15857: PPUSH
15858: LD_VAR 0 1
15862: PPUSH
15863: LD_EXP 57
15867: PUSH
15868: LD_VAR 0 1
15872: ARRAY
15873: PUSH
15874: LD_INT 1
15876: PLUS
15877: PPUSH
15878: LD_VAR 0 6
15882: PUSH
15883: LD_VAR 0 4
15887: ARRAY
15888: PUSH
15889: LD_INT 1
15891: ARRAY
15892: PPUSH
15893: CALL 30882 0 4
15897: ST_TO_ADDR
// end ;
15898: GO 15787
15900: POP
15901: POP
// end ;
15902: LD_VAR 0 3
15906: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
15907: LD_INT 0
15909: PPUSH
15910: PPUSH
15911: PPUSH
15912: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
15913: LD_ADDR_VAR 0 5
15917: PUSH
15918: LD_VAR 0 1
15922: PPUSH
15923: LD_INT 2
15925: PUSH
15926: LD_INT 25
15928: PUSH
15929: LD_INT 1
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PUSH
15936: LD_INT 25
15938: PUSH
15939: LD_INT 2
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: PUSH
15946: EMPTY
15947: LIST
15948: LIST
15949: LIST
15950: PPUSH
15951: CALL 11448 0 2
15955: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15956: LD_ADDR_VAR 0 5
15960: PUSH
15961: LD_VAR 0 5
15965: PPUSH
15966: LD_INT 0
15968: PPUSH
15969: CALL 13597 0 2
15973: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
15974: LD_ADDR_VAR 0 6
15978: PUSH
15979: LD_VAR 0 1
15983: PPUSH
15984: LD_VAR 0 5
15988: PPUSH
15989: LD_INT 4
15991: PPUSH
15992: CALL 13217 0 3
15996: ST_TO_ADDR
// if n > sk then
15997: LD_VAR 0 2
16001: PUSH
16002: LD_VAR 0 6
16006: GREATER
16007: IFFALSE 16019
// n := sk ;
16009: LD_ADDR_VAR 0 2
16013: PUSH
16014: LD_VAR 0 6
16018: ST_TO_ADDR
// for i = 1 to n do
16019: LD_ADDR_VAR 0 4
16023: PUSH
16024: DOUBLE
16025: LD_INT 1
16027: DEC
16028: ST_TO_ADDR
16029: LD_VAR 0 2
16033: PUSH
16034: FOR_TO
16035: IFFALSE 16147
// if ( sk [ i ] [ 1 ] ) <> 0 then
16037: LD_VAR 0 6
16041: PUSH
16042: LD_VAR 0 4
16046: ARRAY
16047: PUSH
16048: LD_INT 1
16050: ARRAY
16051: PUSH
16052: LD_INT 0
16054: NONEQUAL
16055: IFFALSE 16145
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16057: LD_ADDR_EXP 55
16061: PUSH
16062: LD_EXP 55
16066: PPUSH
16067: LD_VAR 0 1
16071: PPUSH
16072: LD_VAR 0 6
16076: PUSH
16077: LD_VAR 0 4
16081: ARRAY
16082: PUSH
16083: LD_INT 1
16085: ARRAY
16086: PPUSH
16087: LD_INT 4
16089: PPUSH
16090: CALL 42162 0 4
16094: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16095: LD_ADDR_EXP 56
16099: PUSH
16100: LD_EXP 56
16104: PPUSH
16105: LD_VAR 0 1
16109: PPUSH
16110: LD_EXP 56
16114: PUSH
16115: LD_VAR 0 1
16119: ARRAY
16120: PUSH
16121: LD_INT 1
16123: PLUS
16124: PPUSH
16125: LD_VAR 0 6
16129: PUSH
16130: LD_VAR 0 4
16134: ARRAY
16135: PUSH
16136: LD_INT 1
16138: ARRAY
16139: PPUSH
16140: CALL 30882 0 4
16144: ST_TO_ADDR
// end ;
16145: GO 16034
16147: POP
16148: POP
// end ;
16149: LD_VAR 0 3
16153: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16154: LD_INT 0
16156: PPUSH
16157: PPUSH
16158: PPUSH
16159: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16160: LD_ADDR_VAR 0 6
16164: PUSH
16165: LD_VAR 0 1
16169: PPUSH
16170: LD_INT 2
16172: PUSH
16173: LD_INT 25
16175: PUSH
16176: LD_INT 1
16178: PUSH
16179: EMPTY
16180: LIST
16181: LIST
16182: PUSH
16183: LD_INT 25
16185: PUSH
16186: LD_INT 2
16188: PUSH
16189: EMPTY
16190: LIST
16191: LIST
16192: PUSH
16193: LD_INT 25
16195: PUSH
16196: LD_INT 3
16198: PUSH
16199: EMPTY
16200: LIST
16201: LIST
16202: PUSH
16203: LD_INT 25
16205: PUSH
16206: LD_INT 4
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PUSH
16213: EMPTY
16214: LIST
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: PPUSH
16220: CALL 11448 0 2
16224: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16225: LD_ADDR_VAR 0 6
16229: PUSH
16230: LD_VAR 0 6
16234: PPUSH
16235: LD_INT 0
16237: PPUSH
16238: CALL 13597 0 2
16242: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16243: LD_ADDR_VAR 0 7
16247: PUSH
16248: LD_VAR 0 1
16252: PPUSH
16253: LD_VAR 0 6
16257: PPUSH
16258: LD_INT 1
16260: PPUSH
16261: CALL 13217 0 3
16265: ST_TO_ADDR
// if n > sk then
16266: LD_VAR 0 2
16270: PUSH
16271: LD_VAR 0 7
16275: GREATER
16276: IFFALSE 16288
// n := sk ;
16278: LD_ADDR_VAR 0 2
16282: PUSH
16283: LD_VAR 0 7
16287: ST_TO_ADDR
// for i = 1 to n do
16288: LD_ADDR_VAR 0 5
16292: PUSH
16293: DOUBLE
16294: LD_INT 1
16296: DEC
16297: ST_TO_ADDR
16298: LD_VAR 0 2
16302: PUSH
16303: FOR_TO
16304: IFFALSE 16348
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16306: LD_ADDR_EXP 55
16310: PUSH
16311: LD_EXP 55
16315: PPUSH
16316: LD_VAR 0 1
16320: PPUSH
16321: LD_VAR 0 7
16325: PUSH
16326: LD_VAR 0 5
16330: ARRAY
16331: PUSH
16332: LD_INT 1
16334: ARRAY
16335: PPUSH
16336: LD_VAR 0 3
16340: PPUSH
16341: CALL 42162 0 4
16345: ST_TO_ADDR
// end ;
16346: GO 16303
16348: POP
16349: POP
// end ;
16350: LD_VAR 0 4
16354: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16355: LD_INT 0
16357: PPUSH
16358: PPUSH
16359: PPUSH
// b := false ;
16360: LD_ADDR_VAR 0 6
16364: PUSH
16365: LD_INT 0
16367: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16368: LD_VAR 0 3
16372: PUSH
16373: LD_INT 1
16375: PUSH
16376: LD_INT 9
16378: PUSH
16379: LD_INT 5
16381: PUSH
16382: LD_INT 8
16384: PUSH
16385: EMPTY
16386: LIST
16387: LIST
16388: LIST
16389: LIST
16390: IN
16391: IFFALSE 16479
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16393: LD_VAR 0 1
16397: PPUSH
16398: LD_INT 2
16400: PUSH
16401: LD_INT 30
16403: PUSH
16404: LD_INT 4
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PUSH
16411: LD_INT 30
16413: PUSH
16414: LD_INT 5
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: LIST
16425: PPUSH
16426: CALL 11448 0 2
16430: IFFALSE 16479
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16432: LD_ADDR_VAR 0 6
16436: PUSH
16437: LD_VAR 0 1
16441: PPUSH
16442: LD_INT 2
16444: PUSH
16445: LD_INT 30
16447: PUSH
16448: LD_INT 4
16450: PUSH
16451: EMPTY
16452: LIST
16453: LIST
16454: PUSH
16455: LD_INT 30
16457: PUSH
16458: LD_INT 5
16460: PUSH
16461: EMPTY
16462: LIST
16463: LIST
16464: PUSH
16465: EMPTY
16466: LIST
16467: LIST
16468: LIST
16469: PPUSH
16470: CALL 11448 0 2
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: ST_TO_ADDR
// if class = class_engineer then
16479: LD_VAR 0 3
16483: PUSH
16484: LD_INT 2
16486: EQUAL
16487: IFFALSE 16575
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16489: LD_VAR 0 1
16493: PPUSH
16494: LD_INT 2
16496: PUSH
16497: LD_INT 30
16499: PUSH
16500: LD_INT 0
16502: PUSH
16503: EMPTY
16504: LIST
16505: LIST
16506: PUSH
16507: LD_INT 30
16509: PUSH
16510: LD_INT 1
16512: PUSH
16513: EMPTY
16514: LIST
16515: LIST
16516: PUSH
16517: EMPTY
16518: LIST
16519: LIST
16520: LIST
16521: PPUSH
16522: CALL 11448 0 2
16526: IFFALSE 16575
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16528: LD_ADDR_VAR 0 6
16532: PUSH
16533: LD_VAR 0 1
16537: PPUSH
16538: LD_INT 2
16540: PUSH
16541: LD_INT 30
16543: PUSH
16544: LD_INT 0
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: PUSH
16551: LD_INT 30
16553: PUSH
16554: LD_INT 1
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: PUSH
16561: EMPTY
16562: LIST
16563: LIST
16564: LIST
16565: PPUSH
16566: CALL 11448 0 2
16570: PUSH
16571: LD_INT 1
16573: ARRAY
16574: ST_TO_ADDR
// if class = class_mechanic then
16575: LD_VAR 0 3
16579: PUSH
16580: LD_INT 3
16582: EQUAL
16583: IFFALSE 16653
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16585: LD_VAR 0 1
16589: PPUSH
16590: LD_INT 30
16592: PUSH
16593: LD_INT 3
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL 11448 0 2
16604: IFFALSE 16653
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16606: LD_ADDR_VAR 0 6
16610: PUSH
16611: LD_VAR 0 1
16615: PPUSH
16616: LD_INT 2
16618: PUSH
16619: LD_INT 30
16621: PUSH
16622: LD_INT 2
16624: PUSH
16625: EMPTY
16626: LIST
16627: LIST
16628: PUSH
16629: LD_INT 30
16631: PUSH
16632: LD_INT 3
16634: PUSH
16635: EMPTY
16636: LIST
16637: LIST
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: LIST
16643: PPUSH
16644: CALL 11448 0 2
16648: PUSH
16649: LD_INT 1
16651: ARRAY
16652: ST_TO_ADDR
// if class = class_scientistic then
16653: LD_VAR 0 3
16657: PUSH
16658: LD_INT 4
16660: EQUAL
16661: IFFALSE 16771
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16663: LD_VAR 0 1
16667: PPUSH
16668: LD_INT 2
16670: PUSH
16671: LD_INT 30
16673: PUSH
16674: LD_INT 6
16676: PUSH
16677: EMPTY
16678: LIST
16679: LIST
16680: PUSH
16681: LD_INT 30
16683: PUSH
16684: LD_INT 7
16686: PUSH
16687: EMPTY
16688: LIST
16689: LIST
16690: PUSH
16691: LD_INT 30
16693: PUSH
16694: LD_INT 8
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: PPUSH
16707: CALL 11448 0 2
16711: IFFALSE 16771
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16713: LD_ADDR_VAR 0 6
16717: PUSH
16718: LD_VAR 0 1
16722: PPUSH
16723: LD_INT 2
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 6
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: LD_INT 30
16738: PUSH
16739: LD_INT 7
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: PUSH
16746: LD_INT 30
16748: PUSH
16749: LD_INT 8
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: EMPTY
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: PPUSH
16762: CALL 11448 0 2
16766: PUSH
16767: LD_INT 1
16769: ARRAY
16770: ST_TO_ADDR
// if GetClass ( unit ) = class then
16771: LD_VAR 0 2
16775: PPUSH
16776: CALL_OW 257
16780: PUSH
16781: LD_VAR 0 3
16785: EQUAL
16786: IFFALSE 16820
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16788: LD_ADDR_EXP 55
16792: PUSH
16793: LD_EXP 55
16797: PPUSH
16798: LD_VAR 0 1
16802: PPUSH
16803: LD_VAR 0 2
16807: PPUSH
16808: LD_VAR 0 3
16812: PPUSH
16813: CALL 42253 0 4
16817: ST_TO_ADDR
// end else
16818: GO 16913
// if b then
16820: LD_VAR 0 6
16824: IFFALSE 16905
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16826: LD_VAR 0 2
16830: PPUSH
16831: CALL_OW 310
16835: PUSH
16836: LD_VAR 0 2
16840: PPUSH
16841: CALL_OW 310
16845: PUSH
16846: LD_VAR 0 6
16850: NONEQUAL
16851: AND
16852: IFFALSE 16863
// ComExitBuilding ( unit ) ;
16854: LD_VAR 0 2
16858: PPUSH
16859: CALL_OW 122
// if not IsInUnit ( unit ) then
16863: LD_VAR 0 2
16867: PPUSH
16868: CALL_OW 310
16872: NOT
16873: IFFALSE 16889
// ComEnterUnit ( unit , b ) ;
16875: LD_VAR 0 2
16879: PPUSH
16880: LD_VAR 0 6
16884: PPUSH
16885: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16889: LD_VAR 0 2
16893: PPUSH
16894: LD_VAR 0 3
16898: PPUSH
16899: CALL_OW 183
// end else
16903: GO 16913
// result := false ;
16905: LD_ADDR_VAR 0 4
16909: PUSH
16910: LD_INT 0
16912: ST_TO_ADDR
// end ; end_of_file
16913: LD_VAR 0 4
16917: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
16918: LD_INT 0
16920: PPUSH
16921: PPUSH
16922: PPUSH
16923: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16924: LD_ADDR_VAR 0 5
16928: PUSH
16929: LD_INT 35
16931: PUSH
16932: LD_INT 45
16934: PUSH
16935: LD_INT 46
16937: PUSH
16938: LD_INT 47
16940: PUSH
16941: LD_INT 1
16943: PUSH
16944: LD_INT 2
16946: PUSH
16947: LD_INT 48
16949: PUSH
16950: LD_INT 49
16952: PUSH
16953: LD_INT 50
16955: PUSH
16956: LD_INT 20
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: LIST
16967: LIST
16968: LIST
16969: LIST
16970: ST_TO_ADDR
// if MCF_Lab ( side ) then
16971: LD_VAR 0 1
16975: PPUSH
16976: CALL 11487 0 1
16980: IFFALSE 17219
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
16982: LD_VAR 0 1
16986: PPUSH
16987: CALL 11487 0 1
16991: PUSH
16992: LD_INT 1
16994: ARRAY
16995: PPUSH
16996: CALL_OW 461
17000: PUSH
17001: LD_INT 2
17003: EQUAL
17004: IFFALSE 17143
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17006: LD_VAR 0 1
17010: PPUSH
17011: CALL 11487 0 1
17015: PUSH
17016: LD_INT 1
17018: ARRAY
17019: PPUSH
17020: LD_VAR 0 2
17024: PPUSH
17025: CALL 17315 0 2
17029: IFFALSE 17056
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17031: LD_VAR 0 1
17035: PPUSH
17036: CALL 11487 0 1
17040: PUSH
17041: LD_INT 1
17043: ARRAY
17044: PPUSH
17045: LD_VAR 0 2
17049: PPUSH
17050: CALL_OW 124
17054: GO 17143
// if MCF_Lab ( side ) > 1 then
17056: LD_VAR 0 1
17060: PPUSH
17061: CALL 11487 0 1
17065: PUSH
17066: LD_INT 1
17068: GREATER
17069: IFFALSE 17143
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17071: LD_VAR 0 1
17075: PPUSH
17076: CALL 11487 0 1
17080: PUSH
17081: LD_INT 2
17083: ARRAY
17084: PPUSH
17085: CALL_OW 461
17089: PUSH
17090: LD_INT 2
17092: EQUAL
17093: IFFALSE 17143
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17095: LD_VAR 0 1
17099: PPUSH
17100: CALL 11487 0 1
17104: PUSH
17105: LD_INT 2
17107: ARRAY
17108: PPUSH
17109: LD_VAR 0 2
17113: PPUSH
17114: CALL 17315 0 2
17118: IFFALSE 17143
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17120: LD_VAR 0 1
17124: PPUSH
17125: CALL 11487 0 1
17129: PUSH
17130: LD_INT 2
17132: ARRAY
17133: PPUSH
17134: LD_VAR 0 2
17138: PPUSH
17139: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17143: LD_VAR 0 2
17147: PUSH
17148: LD_INT 2
17150: PUSH
17151: LD_INT 11
17153: PUSH
17154: LD_INT 4
17156: PUSH
17157: LD_INT 3
17159: PUSH
17160: EMPTY
17161: LIST
17162: LIST
17163: LIST
17164: LIST
17165: IN
17166: IFFALSE 17219
// begin for lab in MCF_Lab ( side ) do
17168: LD_ADDR_VAR 0 6
17172: PUSH
17173: LD_VAR 0 1
17177: PPUSH
17178: CALL 11487 0 1
17182: PUSH
17183: FOR_IN
17184: IFFALSE 17217
// if BuildingStatus ( lab ) = bs_need_ape then
17186: LD_VAR 0 6
17190: PPUSH
17191: CALL_OW 461
17195: PUSH
17196: LD_INT 10
17198: EQUAL
17199: IFFALSE 17215
// MCL_ResTame ( side , lab ) ;
17201: LD_VAR 0 1
17205: PPUSH
17206: LD_VAR 0 6
17210: PPUSH
17211: CALL 17440 0 2
17215: GO 17183
17217: POP
17218: POP
// end ; end ; end ;
17219: LD_VAR 0 3
17223: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17224: LD_INT 0
17226: PPUSH
17227: PPUSH
// tmp := [ ] ;
17228: LD_ADDR_VAR 0 3
17232: PUSH
17233: EMPTY
17234: ST_TO_ADDR
// if not lab then
17235: LD_VAR 0 1
17239: NOT
17240: IFFALSE 17252
// result := false else
17242: LD_ADDR_VAR 0 2
17246: PUSH
17247: LD_INT 0
17249: ST_TO_ADDR
17250: GO 17310
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17252: LD_ADDR_VAR 0 3
17256: PUSH
17257: LD_VAR 0 3
17261: PUSH
17262: LD_VAR 0 1
17266: PPUSH
17267: LD_INT 1
17269: PPUSH
17270: CALL_OW 268
17274: ADD
17275: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17276: LD_ADDR_VAR 0 3
17280: PUSH
17281: LD_VAR 0 3
17285: PUSH
17286: LD_VAR 0 1
17290: PPUSH
17291: LD_INT 2
17293: PPUSH
17294: CALL_OW 268
17298: ADD
17299: ST_TO_ADDR
// result := tmp ;
17300: LD_ADDR_VAR 0 2
17304: PUSH
17305: LD_VAR 0 3
17309: ST_TO_ADDR
// end ; end ;
17310: LD_VAR 0 2
17314: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
17319: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17320: LD_ADDR_VAR 0 5
17324: PUSH
17325: LD_INT 35
17327: PUSH
17328: LD_INT 45
17330: PUSH
17331: LD_INT 46
17333: PUSH
17334: LD_INT 47
17336: PUSH
17337: LD_INT 1
17339: PUSH
17340: LD_INT 2
17342: PUSH
17343: LD_INT 48
17345: PUSH
17346: LD_INT 49
17348: PUSH
17349: LD_INT 50
17351: PUSH
17352: LD_INT 20
17354: PUSH
17355: EMPTY
17356: LIST
17357: LIST
17358: LIST
17359: LIST
17360: LIST
17361: LIST
17362: LIST
17363: LIST
17364: LIST
17365: LIST
17366: ST_TO_ADDR
// if lab then
17367: LD_VAR 0 1
17371: IFFALSE 17427
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17373: LD_VAR 0 2
17377: PUSH
17378: LD_VAR 0 5
17382: IN
17383: PUSH
17384: LD_VAR 0 2
17388: PPUSH
17389: CALL_OW 481
17393: PUSH
17394: LD_VAR 0 1
17398: PPUSH
17399: CALL 17224 0 1
17403: IN
17404: OR
17405: IFFALSE 17417
// result := true else
17407: LD_ADDR_VAR 0 3
17411: PUSH
17412: LD_INT 1
17414: ST_TO_ADDR
17415: GO 17425
// result := false ;
17417: LD_ADDR_VAR 0 3
17421: PUSH
17422: LD_INT 0
17424: ST_TO_ADDR
// end else
17425: GO 17435
// result := false ;
17427: LD_ADDR_VAR 0 3
17431: PUSH
17432: LD_INT 0
17434: ST_TO_ADDR
// end ;
17435: LD_VAR 0 3
17439: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17440: LD_INT 0
17442: PPUSH
17443: PPUSH
17444: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17445: LD_ADDR_VAR 0 4
17449: PUSH
17450: LD_VAR 0 1
17454: PPUSH
17455: LD_INT 171
17457: PPUSH
17458: EMPTY
17459: PPUSH
17460: CALL 12151 0 3
17464: ST_TO_ADDR
// if not ape then
17465: LD_VAR 0 4
17469: NOT
17470: IFFALSE 17502
// if MCF_Ape ( side ) then
17472: LD_VAR 0 1
17476: PPUSH
17477: CALL 11861 0 1
17481: IFFALSE 17502
// ape := MCF_Ape ( side ) [ 1 ] ;
17483: LD_ADDR_VAR 0 4
17487: PUSH
17488: LD_VAR 0 1
17492: PPUSH
17493: CALL 11861 0 1
17497: PUSH
17498: LD_INT 1
17500: ARRAY
17501: ST_TO_ADDR
// if ape then
17502: LD_VAR 0 4
17506: IFFALSE 17557
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17508: LD_VAR 0 4
17512: PUSH
17513: LD_INT 1
17515: ARRAY
17516: PPUSH
17517: CALL_OW 310
17521: PUSH
17522: LD_VAR 0 4
17526: PUSH
17527: LD_INT 1
17529: ARRAY
17530: PPUSH
17531: CALL_OW 310
17535: PUSH
17536: LD_VAR 0 2
17540: NONEQUAL
17541: AND
17542: IFFALSE 17557
// ComExitBuilding ( ape [ 1 ] ) ;
17544: LD_VAR 0 4
17548: PUSH
17549: LD_INT 1
17551: ARRAY
17552: PPUSH
17553: CALL_OW 122
// if not lab then
17557: LD_VAR 0 2
17561: NOT
17562: IFFALSE 17568
// exit else
17564: GO 17716
17566: GO 17676
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17568: LD_VAR 0 1
17572: PPUSH
17573: LD_INT 16
17575: PPUSH
17576: LD_INT 25
17578: PUSH
17579: LD_INT 4
17581: PUSH
17582: EMPTY
17583: LIST
17584: LIST
17585: PPUSH
17586: CALL 12151 0 3
17590: PUSH
17591: LD_INT 0
17593: EQUAL
17594: PUSH
17595: LD_VAR 0 2
17599: PPUSH
17600: CALL_OW 313
17604: PUSH
17605: LD_INT 6
17607: EQUAL
17608: AND
17609: IFFALSE 17676
// begin tmp := UnitsInside ( lab ) ;
17611: LD_ADDR_VAR 0 5
17615: PUSH
17616: LD_VAR 0 2
17620: PPUSH
17621: CALL_OW 313
17625: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17626: LD_VAR 0 5
17630: PUSH
17631: LD_VAR 0 5
17635: ARRAY
17636: PPUSH
17637: LD_INT 16
17639: PPUSH
17640: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17644: LD_VAR 0 5
17648: PUSH
17649: LD_VAR 0 5
17653: ARRAY
17654: PPUSH
17655: CALL_OW 310
17659: IFFALSE 17676
// ComExitBuilding ( tmp [ tmp ] ) ;
17661: LD_VAR 0 5
17665: PUSH
17666: LD_VAR 0 5
17670: ARRAY
17671: PPUSH
17672: CALL_OW 122
// end ; if ape then
17676: LD_VAR 0 4
17680: IFFALSE 17716
// if not IsInUnit ( ape [ 1 ] ) then
17682: LD_VAR 0 4
17686: PUSH
17687: LD_INT 1
17689: ARRAY
17690: PPUSH
17691: CALL_OW 310
17695: NOT
17696: IFFALSE 17716
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17698: LD_VAR 0 4
17702: PUSH
17703: LD_INT 1
17705: ARRAY
17706: PPUSH
17707: LD_VAR 0 2
17711: PPUSH
17712: CALL_OW 120
// end ;
17716: LD_VAR 0 3
17720: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17721: LD_INT 0
17723: PPUSH
17724: PPUSH
17725: PPUSH
// result := false ;
17726: LD_ADDR_VAR 0 2
17730: PUSH
17731: LD_INT 0
17733: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17734: LD_ADDR_VAR 0 3
17738: PUSH
17739: LD_VAR 0 1
17743: PPUSH
17744: CALL 17831 0 1
17748: ST_TO_ADDR
// if techs then
17749: LD_VAR 0 3
17753: IFFALSE 17783
// if techs [ 2 ] then
17755: LD_VAR 0 3
17759: PUSH
17760: LD_INT 2
17762: ARRAY
17763: IFFALSE 17775
// result := true else
17765: LD_ADDR_VAR 0 2
17769: PUSH
17770: LD_INT 1
17772: ST_TO_ADDR
17773: GO 17783
// result := false ;
17775: LD_ADDR_VAR 0 2
17779: PUSH
17780: LD_INT 0
17782: ST_TO_ADDR
// end ;
17783: LD_VAR 0 2
17787: RET
// export function MCL_Start ( side ) ; var i ; begin
17788: LD_INT 0
17790: PPUSH
17791: PPUSH
// if MCL_GetTechList ( side ) then
17792: LD_VAR 0 1
17796: PPUSH
17797: CALL 17831 0 1
17801: IFFALSE 17826
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17803: LD_VAR 0 1
17807: PPUSH
17808: LD_VAR 0 1
17812: PPUSH
17813: CALL 17831 0 1
17817: PUSH
17818: LD_INT 1
17820: ARRAY
17821: PPUSH
17822: CALL 16918 0 2
// end ;
17826: LD_VAR 0 2
17830: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17831: LD_INT 0
17833: PPUSH
17834: PPUSH
17835: PPUSH
// if MREG_ToRes then
17836: LD_EXP 52
17840: IFFALSE 17925
// for i = 1 to MREG_ToRes do
17842: LD_ADDR_VAR 0 3
17846: PUSH
17847: DOUBLE
17848: LD_INT 1
17850: DEC
17851: ST_TO_ADDR
17852: LD_EXP 52
17856: PUSH
17857: FOR_TO
17858: IFFALSE 17923
// if MREG_ToRes [ i ] [ 1 ] = side then
17860: LD_EXP 52
17864: PUSH
17865: LD_VAR 0 3
17869: ARRAY
17870: PUSH
17871: LD_INT 1
17873: ARRAY
17874: PUSH
17875: LD_VAR 0 1
17879: EQUAL
17880: IFFALSE 17921
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17882: LD_ADDR_VAR 0 4
17886: PUSH
17887: LD_VAR 0 4
17891: PPUSH
17892: LD_VAR 0 4
17896: PUSH
17897: LD_INT 1
17899: PLUS
17900: PPUSH
17901: LD_EXP 52
17905: PUSH
17906: LD_VAR 0 3
17910: ARRAY
17911: PUSH
17912: LD_INT 2
17914: ARRAY
17915: PPUSH
17916: CALL_OW 1
17920: ST_TO_ADDR
// end ;
17921: GO 17857
17923: POP
17924: POP
// result := techs ;
17925: LD_ADDR_VAR 0 2
17929: PUSH
17930: LD_VAR 0 4
17934: ST_TO_ADDR
// end ;
17935: LD_VAR 0 2
17939: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
17940: LD_INT 0
17942: PPUSH
17943: PPUSH
// for i = 1 to tech_list do
17944: LD_ADDR_VAR 0 4
17948: PUSH
17949: DOUBLE
17950: LD_INT 1
17952: DEC
17953: ST_TO_ADDR
17954: LD_VAR 0 2
17958: PUSH
17959: FOR_TO
17960: IFFALSE 18014
// if not tech_list [ i ] = 20 then
17962: LD_VAR 0 2
17966: PUSH
17967: LD_VAR 0 4
17971: ARRAY
17972: PUSH
17973: LD_INT 20
17975: EQUAL
17976: NOT
17977: IFFALSE 18012
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
17979: LD_ADDR_EXP 52
17983: PUSH
17984: LD_EXP 52
17988: PPUSH
17989: LD_VAR 0 1
17993: PPUSH
17994: LD_VAR 0 2
17998: PUSH
17999: LD_VAR 0 4
18003: ARRAY
18004: PPUSH
18005: EMPTY
18006: PPUSH
18007: CALL 42162 0 4
18011: ST_TO_ADDR
18012: GO 17959
18014: POP
18015: POP
// result := true ;
18016: LD_ADDR_VAR 0 3
18020: PUSH
18021: LD_INT 1
18023: ST_TO_ADDR
// end ;
18024: LD_VAR 0 3
18028: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18029: LD_INT 0
18031: PPUSH
18032: PPUSH
// for i = MREG_ToRes downto 1 do
18033: LD_ADDR_VAR 0 3
18037: PUSH
18038: DOUBLE
18039: LD_EXP 52
18043: INC
18044: ST_TO_ADDR
18045: LD_INT 1
18047: PUSH
18048: FOR_DOWNTO
18049: IFFALSE 18095
// if MREG_ToRes [ i ] [ 1 ] = side then
18051: LD_EXP 52
18055: PUSH
18056: LD_VAR 0 3
18060: ARRAY
18061: PUSH
18062: LD_INT 1
18064: ARRAY
18065: PUSH
18066: LD_VAR 0 1
18070: EQUAL
18071: IFFALSE 18093
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18073: LD_ADDR_EXP 52
18077: PUSH
18078: LD_EXP 52
18082: PPUSH
18083: LD_VAR 0 3
18087: PPUSH
18088: CALL_OW 3
18092: ST_TO_ADDR
18093: GO 18048
18095: POP
18096: POP
// result := true ;
18097: LD_ADDR_VAR 0 2
18101: PUSH
18102: LD_INT 1
18104: ST_TO_ADDR
// end ;
18105: LD_VAR 0 2
18109: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18110: LD_INT 0
18112: PPUSH
// result := GetTechProgress ( side , tech ) ;
18113: LD_ADDR_VAR 0 3
18117: PUSH
18118: LD_VAR 0 1
18122: PPUSH
18123: LD_VAR 0 2
18127: PPUSH
18128: CALL_OW 326
18132: ST_TO_ADDR
// end ;
18133: LD_VAR 0 3
18137: RET
// export function MCL_Require ( tech ) ; begin
18138: LD_INT 0
18140: PPUSH
// result := GetTechTechsReq ( tech ) ;
18141: LD_ADDR_VAR 0 2
18145: PUSH
18146: LD_VAR 0 1
18150: PPUSH
18151: CALL_OW 480
18155: ST_TO_ADDR
// end ; end_of_file
18156: LD_VAR 0 2
18160: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18161: LD_INT 0
18163: PPUSH
18164: PPUSH
18165: PPUSH
// uc_side := 0 ;
18166: LD_ADDR_OWVAR 20
18170: PUSH
18171: LD_INT 0
18173: ST_TO_ADDR
// uc_nation := 0 ;
18174: LD_ADDR_OWVAR 21
18178: PUSH
18179: LD_INT 0
18181: ST_TO_ADDR
// for i = 1 to n do
18182: LD_ADDR_VAR 0 5
18186: PUSH
18187: DOUBLE
18188: LD_INT 1
18190: DEC
18191: ST_TO_ADDR
18192: LD_VAR 0 2
18196: PUSH
18197: FOR_TO
18198: IFFALSE 18343
// begin hc_importance := 0 ;
18200: LD_ADDR_OWVAR 32
18204: PUSH
18205: LD_INT 0
18207: ST_TO_ADDR
// hc_gallery :=  ;
18208: LD_ADDR_OWVAR 33
18212: PUSH
18213: LD_STRING 
18215: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18216: LD_ADDR_OWVAR 35
18220: PUSH
18221: LD_VAR 0 3
18225: PUSH
18226: LD_INT 20
18228: MINUS
18229: PPUSH
18230: LD_VAR 0 3
18234: PUSH
18235: LD_INT 20
18237: PLUS
18238: PPUSH
18239: CALL_OW 12
18243: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18244: LD_ADDR_OWVAR 31
18248: PUSH
18249: LD_INT 0
18251: PPUSH
18252: LD_INT 2
18254: PPUSH
18255: CALL_OW 12
18259: PUSH
18260: LD_INT 0
18262: PUSH
18263: LD_INT 0
18265: PUSH
18266: LD_INT 0
18268: PUSH
18269: EMPTY
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18275: LD_ADDR_OWVAR 30
18279: PUSH
18280: LD_INT 0
18282: PUSH
18283: LD_INT 0
18285: PUSH
18286: LD_INT 0
18288: PUSH
18289: LD_INT 0
18291: PUSH
18292: EMPTY
18293: LIST
18294: LIST
18295: LIST
18296: LIST
18297: ST_TO_ADDR
// hc_name :=  ;
18298: LD_ADDR_OWVAR 26
18302: PUSH
18303: LD_STRING 
18305: ST_TO_ADDR
// hc_class := class_apeman ;
18306: LD_ADDR_OWVAR 28
18310: PUSH
18311: LD_INT 12
18313: ST_TO_ADDR
// ape := CreateHuman ;
18314: LD_ADDR_VAR 0 6
18318: PUSH
18319: CALL_OW 44
18323: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18324: LD_VAR 0 6
18328: PPUSH
18329: LD_VAR 0 1
18333: PPUSH
18334: LD_INT 0
18336: PPUSH
18337: CALL_OW 49
// end ;
18341: GO 18197
18343: POP
18344: POP
// end ;
18345: LD_VAR 0 4
18349: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18350: LD_INT 0
18352: PPUSH
18353: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18354: LD_VAR 0 1
18358: PPUSH
18359: CALL 11861 0 1
18363: PUSH
18364: LD_EXP 39
18368: PUSH
18369: LD_VAR 0 1
18373: ARRAY
18374: GREATEREQUAL
18375: IFFALSE 18552
// begin if GetTag ( unit ) = 17 then
18377: LD_VAR 0 2
18381: PPUSH
18382: CALL_OW 110
18386: PUSH
18387: LD_INT 17
18389: EQUAL
18390: IFFALSE 18550
// begin SetTag ( unit , 0 ) ;
18392: LD_VAR 0 2
18396: PPUSH
18397: LD_INT 0
18399: PPUSH
18400: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18404: LD_VAR 0 1
18408: PPUSH
18409: CALL 11487 0 1
18413: PUSH
18414: LD_VAR 0 1
18418: PPUSH
18419: CALL 17831 0 1
18423: NOT
18424: AND
18425: IFFALSE 18450
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18427: LD_VAR 0 2
18431: PPUSH
18432: LD_VAR 0 1
18436: PPUSH
18437: CALL 11487 0 1
18441: PUSH
18442: LD_INT 1
18444: ARRAY
18445: PPUSH
18446: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18450: LD_VAR 0 1
18454: PPUSH
18455: CALL 11487 0 1
18459: NOT
18460: PUSH
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 30
18468: PUSH
18469: LD_INT 1
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: PPUSH
18476: CALL 11448 0 2
18480: AND
18481: IFFALSE 18550
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18483: LD_VAR 0 2
18487: PPUSH
18488: LD_VAR 0 1
18492: PPUSH
18493: LD_INT 30
18495: PUSH
18496: LD_INT 1
18498: PUSH
18499: EMPTY
18500: LIST
18501: LIST
18502: PPUSH
18503: CALL 11448 0 2
18507: PUSH
18508: LD_INT 1
18510: ARRAY
18511: PPUSH
18512: CALL_OW 250
18516: PPUSH
18517: LD_VAR 0 1
18521: PPUSH
18522: LD_INT 30
18524: PUSH
18525: LD_INT 1
18527: PUSH
18528: EMPTY
18529: LIST
18530: LIST
18531: PPUSH
18532: CALL 11448 0 2
18536: PUSH
18537: LD_INT 1
18539: ARRAY
18540: PPUSH
18541: CALL_OW 251
18545: PPUSH
18546: CALL_OW 111
// end ; end else
18550: GO 18736
// if GetClass ( unit ) <> 4 then
18552: LD_VAR 0 2
18556: PPUSH
18557: CALL_OW 257
18561: PUSH
18562: LD_INT 4
18564: NONEQUAL
18565: IFFALSE 18571
// exit else
18567: GO 18736
18569: GO 18736
// if GetTag ( unit ) = 0 then
18571: LD_VAR 0 2
18575: PPUSH
18576: CALL_OW 110
18580: PUSH
18581: LD_INT 0
18583: EQUAL
18584: IFFALSE 18600
// SetTag ( unit , 17 ) else
18586: LD_VAR 0 2
18590: PPUSH
18591: LD_INT 17
18593: PPUSH
18594: CALL_OW 109
18598: GO 18736
// begin if IsInUnit ( unit ) then
18600: LD_VAR 0 2
18604: PPUSH
18605: CALL_OW 310
18609: IFFALSE 18620
// ComExitBuilding ( unit ) ;
18611: LD_VAR 0 2
18615: PPUSH
18616: CALL_OW 122
// Wait ( 1 ) ;
18620: LD_INT 1
18622: PPUSH
18623: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18627: LD_ADDR_VAR 0 4
18631: PUSH
18632: LD_INT 22
18634: PUSH
18635: LD_INT 0
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: PUSH
18642: LD_INT 25
18644: PUSH
18645: LD_INT 12
18647: PUSH
18648: EMPTY
18649: LIST
18650: LIST
18651: PUSH
18652: EMPTY
18653: LIST
18654: LIST
18655: PPUSH
18656: CALL_OW 69
18660: PPUSH
18661: LD_VAR 0 2
18665: PPUSH
18666: CALL_OW 74
18670: ST_TO_ADDR
// if not ape then
18671: LD_VAR 0 4
18675: NOT
18676: IFFALSE 18682
// exit else
18678: GO 18736
18680: GO 18691
// ComHold ( ape ) ;
18682: LD_VAR 0 4
18686: PPUSH
18687: CALL_OW 140
// if not HasTask ( unit ) then
18691: LD_VAR 0 2
18695: PPUSH
18696: CALL_OW 314
18700: NOT
18701: IFFALSE 18734
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18703: LD_VAR 0 2
18707: PPUSH
18708: LD_VAR 0 4
18712: PPUSH
18713: CALL_OW 250
18717: PPUSH
18718: LD_VAR 0 4
18722: PPUSH
18723: CALL_OW 251
18727: PPUSH
18728: CALL_OW 131
18732: GO 18736
// exit ;
18734: GO 18736
// end ; end ;
18736: LD_VAR 0 3
18740: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18741: LD_INT 0
18743: PPUSH
18744: PPUSH
18745: PPUSH
18746: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18747: LD_ADDR_VAR 0 4
18751: PUSH
18752: LD_EXP 40
18756: PUSH
18757: LD_VAR 0 1
18761: ARRAY
18762: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18763: LD_ADDR_VAR 0 5
18767: PUSH
18768: LD_VAR 0 1
18772: PPUSH
18773: LD_STRING normal
18775: PPUSH
18776: CALL 11945 0 2
18780: ST_TO_ADDR
// if apes then
18781: LD_VAR 0 5
18785: IFFALSE 19013
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18787: LD_INT 2
18789: PPUSH
18790: LD_VAR 0 1
18794: PPUSH
18795: CALL_OW 321
18799: PUSH
18800: LD_INT 2
18802: EQUAL
18803: PUSH
18804: LD_VAR 0 4
18808: PUSH
18809: LD_INT 2
18811: ARRAY
18812: PUSH
18813: LD_INT 1
18815: EQUAL
18816: AND
18817: PUSH
18818: LD_VAR 0 1
18822: PPUSH
18823: LD_STRING engineer
18825: PPUSH
18826: CALL 11945 0 2
18830: PUSH
18831: LD_INT 3
18833: LESS
18834: AND
18835: PUSH
18836: LD_VAR 0 1
18840: PPUSH
18841: LD_INT 30
18843: PUSH
18844: LD_INT 1
18846: PUSH
18847: EMPTY
18848: LIST
18849: LIST
18850: PPUSH
18851: CALL 11448 0 2
18855: AND
18856: IFFALSE 18910
// begin for i in apes do
18858: LD_ADDR_VAR 0 3
18862: PUSH
18863: LD_VAR 0 5
18867: PUSH
18868: FOR_IN
18869: IFFALSE 18906
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18871: LD_VAR 0 3
18875: PPUSH
18876: LD_VAR 0 1
18880: PPUSH
18881: LD_INT 30
18883: PUSH
18884: LD_INT 1
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: PPUSH
18891: CALL 11448 0 2
18895: PUSH
18896: LD_INT 1
18898: ARRAY
18899: PPUSH
18900: CALL_OW 120
// end ;
18904: GO 18868
18906: POP
18907: POP
// end else
18908: GO 19013
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
18910: LD_INT 11
18912: PPUSH
18913: LD_VAR 0 1
18917: PPUSH
18918: CALL_OW 321
18922: PUSH
18923: LD_INT 2
18925: EQUAL
18926: PUSH
18927: LD_VAR 0 4
18931: PUSH
18932: LD_INT 1
18934: ARRAY
18935: PUSH
18936: LD_INT 1
18938: EQUAL
18939: AND
18940: PUSH
18941: LD_VAR 0 1
18945: PPUSH
18946: LD_INT 30
18948: PUSH
18949: LD_INT 5
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PPUSH
18956: CALL 11448 0 2
18960: AND
18961: IFFALSE 19013
// begin for i in apes do
18963: LD_ADDR_VAR 0 3
18967: PUSH
18968: LD_VAR 0 5
18972: PUSH
18973: FOR_IN
18974: IFFALSE 19011
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
18976: LD_VAR 0 3
18980: PPUSH
18981: LD_VAR 0 1
18985: PPUSH
18986: LD_INT 30
18988: PUSH
18989: LD_INT 5
18991: PUSH
18992: EMPTY
18993: LIST
18994: LIST
18995: PPUSH
18996: CALL 11448 0 2
19000: PUSH
19001: LD_INT 1
19003: ARRAY
19004: PPUSH
19005: CALL_OW 120
// end ;
19009: GO 18973
19011: POP
19012: POP
// end ; end ; end ; end_of_file
19013: LD_VAR 0 2
19017: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19018: LD_INT 0
19020: PPUSH
19021: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19022: LD_VAR 0 1
19026: PPUSH
19027: CALL_OW 257
19031: PUSH
19032: LD_INT 4
19034: EQUAL
19035: NOT
19036: PUSH
19037: LD_VAR 0 2
19041: NOT
19042: OR
19043: IFFALSE 19049
// exit else
19045: GO 19083
19047: GO 19083
// if not GetTag ( unit ) = 4 then
19049: LD_VAR 0 1
19053: PPUSH
19054: CALL_OW 110
19058: PUSH
19059: LD_INT 4
19061: EQUAL
19062: NOT
19063: IFFALSE 19069
// exit else
19065: GO 19083
19067: GO 19083
// ComHeal ( unit , target ) ;
19069: LD_VAR 0 1
19073: PPUSH
19074: LD_VAR 0 2
19078: PPUSH
19079: CALL_OW 128
// end ;
19083: LD_VAR 0 3
19087: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19088: LD_INT 0
19090: PPUSH
19091: PPUSH
19092: PPUSH
19093: PPUSH
19094: PPUSH
19095: PPUSH
19096: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19097: LD_ADDR_VAR 0 5
19101: PUSH
19102: LD_INT 22
19104: PUSH
19105: LD_VAR 0 1
19109: PUSH
19110: EMPTY
19111: LIST
19112: LIST
19113: PUSH
19114: LD_INT 21
19116: PUSH
19117: LD_INT 1
19119: PUSH
19120: EMPTY
19121: LIST
19122: LIST
19123: PUSH
19124: LD_INT 3
19126: PUSH
19127: LD_INT 55
19129: PUSH
19130: EMPTY
19131: LIST
19132: PUSH
19133: EMPTY
19134: LIST
19135: LIST
19136: PUSH
19137: LD_INT 3
19139: PUSH
19140: LD_INT 54
19142: PUSH
19143: EMPTY
19144: LIST
19145: PUSH
19146: EMPTY
19147: LIST
19148: LIST
19149: PUSH
19150: LD_INT 3
19152: PUSH
19153: LD_INT 24
19155: PUSH
19156: LD_INT 1000
19158: PUSH
19159: EMPTY
19160: LIST
19161: LIST
19162: PUSH
19163: EMPTY
19164: LIST
19165: LIST
19166: PUSH
19167: EMPTY
19168: LIST
19169: LIST
19170: LIST
19171: LIST
19172: LIST
19173: PPUSH
19174: CALL_OW 69
19178: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19179: LD_ADDR_VAR 0 8
19183: PUSH
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 30
19191: PUSH
19192: LD_INT 1
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: PPUSH
19199: CALL 11448 0 2
19203: ST_TO_ADDR
// r := [ ] ;
19204: LD_ADDR_VAR 0 6
19208: PUSH
19209: EMPTY
19210: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19211: LD_VAR 0 1
19215: PPUSH
19216: LD_INT 5
19218: PPUSH
19219: EMPTY
19220: PPUSH
19221: CALL 12151 0 3
19225: IFFALSE 19281
// for j in MCF_Tag ( side , 5 , [ ] ) do
19227: LD_ADDR_VAR 0 4
19231: PUSH
19232: LD_VAR 0 1
19236: PPUSH
19237: LD_INT 5
19239: PPUSH
19240: EMPTY
19241: PPUSH
19242: CALL 12151 0 3
19246: PUSH
19247: FOR_IN
19248: IFFALSE 19279
// if GetLives ( j ) = 1000 then
19250: LD_VAR 0 4
19254: PPUSH
19255: CALL_OW 256
19259: PUSH
19260: LD_INT 1000
19262: EQUAL
19263: IFFALSE 19277
// SetTag ( j , 0 ) ;
19265: LD_VAR 0 4
19269: PPUSH
19270: LD_INT 0
19272: PPUSH
19273: CALL_OW 109
19277: GO 19247
19279: POP
19280: POP
// if tmp then
19281: LD_VAR 0 5
19285: IFFALSE 19614
// begin r := [ tmp [ 1 ] ] ;
19287: LD_ADDR_VAR 0 6
19291: PUSH
19292: LD_VAR 0 5
19296: PUSH
19297: LD_INT 1
19299: ARRAY
19300: PUSH
19301: EMPTY
19302: LIST
19303: ST_TO_ADDR
// for i = 2 to tmp do
19304: LD_ADDR_VAR 0 3
19308: PUSH
19309: DOUBLE
19310: LD_INT 2
19312: DEC
19313: ST_TO_ADDR
19314: LD_VAR 0 5
19318: PUSH
19319: FOR_TO
19320: IFFALSE 19612
// begin m := false ;
19322: LD_ADDR_VAR 0 7
19326: PUSH
19327: LD_INT 0
19329: ST_TO_ADDR
// if d then
19330: LD_VAR 0 8
19334: IFFALSE 19489
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19336: LD_VAR 0 5
19340: PUSH
19341: LD_VAR 0 3
19345: ARRAY
19346: PPUSH
19347: CALL_OW 256
19351: PUSH
19352: LD_INT 650
19354: LESS
19355: PUSH
19356: LD_VAR 0 5
19360: PUSH
19361: LD_VAR 0 3
19365: ARRAY
19366: PPUSH
19367: LD_VAR 0 8
19371: PUSH
19372: LD_INT 1
19374: ARRAY
19375: PPUSH
19376: CALL_OW 250
19380: PPUSH
19381: LD_VAR 0 8
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 251
19394: PPUSH
19395: CALL_OW 297
19399: PUSH
19400: LD_INT 10
19402: GREATER
19403: AND
19404: IFFALSE 19489
// begin if not GetTag ( tmp [ i ] ) = 5 then
19406: LD_VAR 0 5
19410: PUSH
19411: LD_VAR 0 3
19415: ARRAY
19416: PPUSH
19417: CALL_OW 110
19421: PUSH
19422: LD_INT 5
19424: EQUAL
19425: NOT
19426: IFFALSE 19446
// SetTag ( tmp [ i ] , 5 ) ;
19428: LD_VAR 0 5
19432: PUSH
19433: LD_VAR 0 3
19437: ARRAY
19438: PPUSH
19439: LD_INT 5
19441: PPUSH
19442: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19446: LD_VAR 0 5
19450: PUSH
19451: LD_VAR 0 3
19455: ARRAY
19456: PPUSH
19457: LD_VAR 0 8
19461: PUSH
19462: LD_INT 1
19464: ARRAY
19465: PPUSH
19466: CALL_OW 250
19470: PPUSH
19471: LD_VAR 0 8
19475: PUSH
19476: LD_INT 1
19478: ARRAY
19479: PPUSH
19480: CALL_OW 251
19484: PPUSH
19485: CALL_OW 111
// end ; for j = 1 to r do
19489: LD_ADDR_VAR 0 4
19493: PUSH
19494: DOUBLE
19495: LD_INT 1
19497: DEC
19498: ST_TO_ADDR
19499: LD_VAR 0 6
19503: PUSH
19504: FOR_TO
19505: IFFALSE 19579
// if GetLives ( tmp [ i ] ) < r [ j ] then
19507: LD_VAR 0 5
19511: PUSH
19512: LD_VAR 0 3
19516: ARRAY
19517: PPUSH
19518: CALL_OW 256
19522: PUSH
19523: LD_VAR 0 6
19527: PUSH
19528: LD_VAR 0 4
19532: ARRAY
19533: LESS
19534: IFFALSE 19577
// begin r := Insert ( r , j , tmp [ i ] ) ;
19536: LD_ADDR_VAR 0 6
19540: PUSH
19541: LD_VAR 0 6
19545: PPUSH
19546: LD_VAR 0 4
19550: PPUSH
19551: LD_VAR 0 5
19555: PUSH
19556: LD_VAR 0 3
19560: ARRAY
19561: PPUSH
19562: CALL_OW 2
19566: ST_TO_ADDR
// m := true ;
19567: LD_ADDR_VAR 0 7
19571: PUSH
19572: LD_INT 1
19574: ST_TO_ADDR
// break ;
19575: GO 19579
// end ;
19577: GO 19504
19579: POP
19580: POP
// if not m then
19581: LD_VAR 0 7
19585: NOT
19586: IFFALSE 19610
// r := r ^ tmp [ i ] ;
19588: LD_ADDR_VAR 0 6
19592: PUSH
19593: LD_VAR 0 6
19597: PUSH
19598: LD_VAR 0 5
19602: PUSH
19603: LD_VAR 0 3
19607: ARRAY
19608: ADD
19609: ST_TO_ADDR
// end ;
19610: GO 19319
19612: POP
19613: POP
// end ; result := r end ; end_of_file
19614: LD_ADDR_VAR 0 2
19618: PUSH
19619: LD_VAR 0 6
19623: ST_TO_ADDR
19624: LD_VAR 0 2
19628: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19629: LD_INT 0
19631: PPUSH
19632: PPUSH
19633: PPUSH
// pom := GetBase ( bdepot ) ;
19634: LD_ADDR_VAR 0 3
19638: PUSH
19639: LD_VAR 0 1
19643: PPUSH
19644: CALL_OW 274
19648: ST_TO_ADDR
// sor := [ ] ;
19649: LD_ADDR_VAR 0 4
19653: PUSH
19654: EMPTY
19655: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19656: LD_ADDR_VAR 0 4
19660: PUSH
19661: LD_VAR 0 4
19665: PUSH
19666: LD_VAR 0 3
19670: PPUSH
19671: LD_INT 1
19673: PPUSH
19674: CALL_OW 275
19678: ADD
19679: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19680: LD_ADDR_VAR 0 4
19684: PUSH
19685: LD_VAR 0 4
19689: PUSH
19690: LD_VAR 0 3
19694: PPUSH
19695: LD_INT 2
19697: PPUSH
19698: CALL_OW 275
19702: ADD
19703: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19704: LD_ADDR_VAR 0 4
19708: PUSH
19709: LD_VAR 0 4
19713: PUSH
19714: LD_VAR 0 3
19718: PPUSH
19719: LD_INT 3
19721: PPUSH
19722: CALL_OW 275
19726: ADD
19727: ST_TO_ADDR
// result := sor ;
19728: LD_ADDR_VAR 0 2
19732: PUSH
19733: LD_VAR 0 4
19737: ST_TO_ADDR
// end ;
19738: LD_VAR 0 2
19742: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19743: LD_INT 0
19745: PPUSH
19746: PPUSH
// while ( coord_list ) do
19747: LD_VAR 0 3
19751: IFFALSE 19925
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19753: LD_ADDR_EXP 48
19757: PUSH
19758: LD_EXP 48
19762: PPUSH
19763: LD_VAR 0 1
19767: PPUSH
19768: LD_VAR 0 2
19772: PPUSH
19773: LD_VAR 0 3
19777: PUSH
19778: LD_INT 1
19780: ARRAY
19781: PUSH
19782: LD_VAR 0 3
19786: PUSH
19787: LD_INT 2
19789: ARRAY
19790: PUSH
19791: LD_VAR 0 3
19795: PUSH
19796: LD_INT 3
19798: ARRAY
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: LIST
19804: PPUSH
19805: CALL 42162 0 4
19809: ST_TO_ADDR
// if weapon_list then
19810: LD_VAR 0 4
19814: IFFALSE 19885
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19816: LD_ADDR_EXP 45
19820: PUSH
19821: LD_EXP 45
19825: PPUSH
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_VAR 0 4
19835: PUSH
19836: LD_INT 1
19838: ARRAY
19839: PPUSH
19840: LD_VAR 0 3
19844: PUSH
19845: LD_INT 1
19847: ARRAY
19848: PUSH
19849: LD_VAR 0 3
19853: PUSH
19854: LD_INT 2
19856: ARRAY
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: PPUSH
19862: CALL 42162 0 4
19866: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19867: LD_ADDR_VAR 0 4
19871: PUSH
19872: LD_VAR 0 4
19876: PPUSH
19877: LD_INT 1
19879: PPUSH
19880: CALL_OW 3
19884: ST_TO_ADDR
// end ; for i = 1 to 3 do
19885: LD_ADDR_VAR 0 6
19889: PUSH
19890: DOUBLE
19891: LD_INT 1
19893: DEC
19894: ST_TO_ADDR
19895: LD_INT 3
19897: PUSH
19898: FOR_TO
19899: IFFALSE 19921
// coord_list := Delete ( coord_list , 1 ) ;
19901: LD_ADDR_VAR 0 3
19905: PUSH
19906: LD_VAR 0 3
19910: PPUSH
19911: LD_INT 1
19913: PPUSH
19914: CALL_OW 3
19918: ST_TO_ADDR
19919: GO 19898
19921: POP
19922: POP
// end ;
19923: GO 19747
// result := true ;
19925: LD_ADDR_VAR 0 5
19929: PUSH
19930: LD_INT 1
19932: ST_TO_ADDR
// end ;
19933: LD_VAR 0 5
19937: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
19938: LD_INT 0
19940: PPUSH
19941: PPUSH
// if not weapon_list then
19942: LD_VAR 0 3
19946: NOT
19947: IFFALSE 19951
// exit ;
19949: GO 20066
// while ( coord_list ) do
19951: LD_VAR 0 2
19955: IFFALSE 20066
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19957: LD_ADDR_EXP 45
19961: PUSH
19962: LD_EXP 45
19966: PPUSH
19967: LD_VAR 0 1
19971: PPUSH
19972: LD_VAR 0 3
19976: PUSH
19977: LD_INT 1
19979: ARRAY
19980: PPUSH
19981: LD_VAR 0 2
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: PUSH
19990: LD_VAR 0 2
19994: PUSH
19995: LD_INT 2
19997: ARRAY
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: PPUSH
20003: CALL 42162 0 4
20007: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20008: LD_ADDR_VAR 0 3
20012: PUSH
20013: LD_VAR 0 3
20017: PPUSH
20018: LD_INT 1
20020: PPUSH
20021: CALL_OW 3
20025: ST_TO_ADDR
// for i = 1 to 2 do
20026: LD_ADDR_VAR 0 5
20030: PUSH
20031: DOUBLE
20032: LD_INT 1
20034: DEC
20035: ST_TO_ADDR
20036: LD_INT 2
20038: PUSH
20039: FOR_TO
20040: IFFALSE 20062
// coord_list := Delete ( coord_list , 1 ) ;
20042: LD_ADDR_VAR 0 2
20046: PUSH
20047: LD_VAR 0 2
20051: PPUSH
20052: LD_INT 1
20054: PPUSH
20055: CALL_OW 3
20059: ST_TO_ADDR
20060: GO 20039
20062: POP
20063: POP
// end ;
20064: GO 19951
// end ;
20066: LD_VAR 0 4
20070: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20071: LD_INT 0
20073: PPUSH
20074: PPUSH
// while ( coord_list ) do
20075: LD_VAR 0 2
20079: IFFALSE 20234
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20081: LD_VAR 0 2
20085: PUSH
20086: LD_INT 1
20088: ARRAY
20089: PPUSH
20090: LD_VAR 0 2
20094: PUSH
20095: LD_INT 2
20097: ARRAY
20098: PPUSH
20099: CALL_OW 428
20103: IFFALSE 20194
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20105: LD_VAR 0 2
20109: PUSH
20110: LD_INT 1
20112: ARRAY
20113: PPUSH
20114: LD_VAR 0 2
20118: PUSH
20119: LD_INT 2
20121: ARRAY
20122: PPUSH
20123: CALL_OW 428
20127: PPUSH
20128: CALL_OW 266
20132: PUSH
20133: LD_INT 31
20135: PUSH
20136: LD_INT 32
20138: PUSH
20139: LD_INT 33
20141: PUSH
20142: EMPTY
20143: LIST
20144: LIST
20145: LIST
20146: IN
20147: IFFALSE 20194
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20149: LD_ADDR_EXP 54
20153: PUSH
20154: LD_EXP 54
20158: PPUSH
20159: LD_VAR 0 1
20163: PPUSH
20164: LD_VAR 0 2
20168: PUSH
20169: LD_INT 1
20171: ARRAY
20172: PPUSH
20173: LD_VAR 0 2
20177: PUSH
20178: LD_INT 2
20180: ARRAY
20181: PPUSH
20182: CALL_OW 428
20186: PPUSH
20187: EMPTY
20188: PPUSH
20189: CALL 42162 0 4
20193: ST_TO_ADDR
// for i = 1 to 3 do
20194: LD_ADDR_VAR 0 4
20198: PUSH
20199: DOUBLE
20200: LD_INT 1
20202: DEC
20203: ST_TO_ADDR
20204: LD_INT 3
20206: PUSH
20207: FOR_TO
20208: IFFALSE 20230
// coord_list := Delete ( coord_list , 1 ) ;
20210: LD_ADDR_VAR 0 2
20214: PUSH
20215: LD_VAR 0 2
20219: PPUSH
20220: LD_INT 1
20222: PPUSH
20223: CALL_OW 3
20227: ST_TO_ADDR
20228: GO 20207
20230: POP
20231: POP
// end ;
20232: GO 20075
// result := true ;
20234: LD_ADDR_VAR 0 3
20238: PUSH
20239: LD_INT 1
20241: ST_TO_ADDR
// end ;
20242: LD_VAR 0 3
20246: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20247: LD_INT 0
20249: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20250: LD_ADDR_EXP 48
20254: PUSH
20255: LD_EXP 48
20259: PPUSH
20260: LD_VAR 0 1
20264: PPUSH
20265: LD_INT 0
20267: PPUSH
20268: LD_VAR 0 2
20272: PPUSH
20273: CALL 42162 0 4
20277: ST_TO_ADDR
// end ;
20278: LD_VAR 0 3
20282: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20283: LD_INT 0
20285: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20286: LD_ADDR_EXP 48
20290: PUSH
20291: LD_EXP 48
20295: PPUSH
20296: LD_VAR 0 1
20300: PPUSH
20301: LD_INT 6
20303: PPUSH
20304: LD_VAR 0 2
20308: PPUSH
20309: CALL 42162 0 4
20313: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20314: LD_ADDR_EXP 51
20318: PUSH
20319: LD_EXP 51
20323: PPUSH
20324: LD_VAR 0 1
20328: PPUSH
20329: LD_VAR 0 3
20333: PUSH
20334: LD_INT 1
20336: ARRAY
20337: PPUSH
20338: LD_VAR 0 3
20342: PUSH
20343: LD_INT 2
20345: ARRAY
20346: PPUSH
20347: CALL 42162 0 4
20351: ST_TO_ADDR
// end ;
20352: LD_VAR 0 4
20356: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20357: LD_INT 0
20359: PPUSH
20360: PPUSH
// if ext_list > 5 then
20361: LD_VAR 0 3
20365: PUSH
20366: LD_INT 5
20368: GREATER
20369: IFFALSE 20413
// for i = 6 to ext_list do
20371: LD_ADDR_VAR 0 5
20375: PUSH
20376: DOUBLE
20377: LD_INT 6
20379: DEC
20380: ST_TO_ADDR
20381: LD_VAR 0 3
20385: PUSH
20386: FOR_TO
20387: IFFALSE 20411
// ext_list := Delete ( ext_list , ext_list ) ;
20389: LD_ADDR_VAR 0 3
20393: PUSH
20394: LD_VAR 0 3
20398: PPUSH
20399: LD_VAR 0 3
20403: PPUSH
20404: CALL_OW 3
20408: ST_TO_ADDR
20409: GO 20386
20411: POP
20412: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20413: LD_VAR 0 1
20417: PPUSH
20418: LD_VAR 0 2
20422: PUSH
20423: LD_INT 1
20425: ARRAY
20426: PPUSH
20427: LD_VAR 0 2
20431: PUSH
20432: LD_INT 2
20434: ARRAY
20435: PPUSH
20436: LD_VAR 0 2
20440: PUSH
20441: LD_INT 3
20443: ARRAY
20444: PPUSH
20445: LD_VAR 0 3
20449: PPUSH
20450: CALL 8960 0 5
// end ;
20454: LD_VAR 0 4
20458: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20459: LD_INT 0
20461: PPUSH
20462: PPUSH
20463: PPUSH
// p := 1 ;
20464: LD_ADDR_VAR 0 6
20468: PUSH
20469: LD_INT 1
20471: ST_TO_ADDR
// if type_list = [ ] then
20472: LD_VAR 0 3
20476: PUSH
20477: EMPTY
20478: EQUAL
20479: IFFALSE 20489
// type_list := b_oil_power ;
20481: LD_ADDR_VAR 0 3
20485: PUSH
20486: LD_INT 26
20488: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20489: LD_ADDR_VAR 0 5
20493: PUSH
20494: DOUBLE
20495: LD_INT 1
20497: DEC
20498: ST_TO_ADDR
20499: LD_VAR 0 2
20503: PUSH
20504: LD_INT 3
20506: DIVREAL
20507: PUSH
20508: FOR_TO
20509: IFFALSE 20612
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20511: LD_ADDR_EXP 48
20515: PUSH
20516: LD_EXP 48
20520: PPUSH
20521: LD_VAR 0 1
20525: PPUSH
20526: LD_VAR 0 3
20530: PUSH
20531: LD_INT 1
20533: PPUSH
20534: LD_VAR 0 3
20538: PPUSH
20539: CALL_OW 12
20543: ARRAY
20544: PPUSH
20545: LD_VAR 0 2
20549: PUSH
20550: LD_VAR 0 6
20554: ARRAY
20555: PUSH
20556: LD_VAR 0 2
20560: PUSH
20561: LD_VAR 0 6
20565: PUSH
20566: LD_INT 1
20568: PLUS
20569: ARRAY
20570: PUSH
20571: LD_VAR 0 2
20575: PUSH
20576: LD_VAR 0 6
20580: PUSH
20581: LD_INT 2
20583: PLUS
20584: ARRAY
20585: PUSH
20586: EMPTY
20587: LIST
20588: LIST
20589: LIST
20590: PPUSH
20591: CALL 42162 0 4
20595: ST_TO_ADDR
// p := p + 3 ;
20596: LD_ADDR_VAR 0 6
20600: PUSH
20601: LD_VAR 0 6
20605: PUSH
20606: LD_INT 3
20608: PLUS
20609: ST_TO_ADDR
// end ;
20610: GO 20508
20612: POP
20613: POP
// end ;
20614: LD_VAR 0 4
20618: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20619: LD_INT 0
20621: PPUSH
20622: PPUSH
20623: PPUSH
20624: PPUSH
// if not MREG_Deposit [ side ] then
20625: LD_EXP 63
20629: PUSH
20630: LD_VAR 0 1
20634: ARRAY
20635: NOT
20636: IFFALSE 20640
// exit ;
20638: GO 20817
// p := 1 ;
20640: LD_ADDR_VAR 0 4
20644: PUSH
20645: LD_INT 1
20647: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20648: LD_ADDR_VAR 0 3
20652: PUSH
20653: DOUBLE
20654: LD_INT 1
20656: DEC
20657: ST_TO_ADDR
20658: LD_EXP 63
20662: PUSH
20663: LD_VAR 0 1
20667: ARRAY
20668: PUSH
20669: LD_INT 3
20671: DIVREAL
20672: PUSH
20673: FOR_TO
20674: IFFALSE 20815
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20676: LD_EXP 63
20680: PUSH
20681: LD_VAR 0 1
20685: ARRAY
20686: PUSH
20687: LD_VAR 0 4
20691: PUSH
20692: LD_INT 2
20694: PLUS
20695: ARRAY
20696: PUSH
20697: LD_INT 2
20699: EQUAL
20700: IFFALSE 20712
// b := b_oil_mine else
20702: LD_ADDR_VAR 0 5
20706: PUSH
20707: LD_INT 29
20709: ST_TO_ADDR
20710: GO 20720
// b := b_siberite_mine ;
20712: LD_ADDR_VAR 0 5
20716: PUSH
20717: LD_INT 30
20719: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20720: LD_ADDR_EXP 48
20724: PUSH
20725: LD_EXP 48
20729: PPUSH
20730: LD_VAR 0 1
20734: PPUSH
20735: LD_VAR 0 5
20739: PPUSH
20740: LD_EXP 63
20744: PUSH
20745: LD_VAR 0 1
20749: ARRAY
20750: PUSH
20751: LD_VAR 0 4
20755: ARRAY
20756: PUSH
20757: LD_EXP 63
20761: PUSH
20762: LD_VAR 0 1
20766: ARRAY
20767: PUSH
20768: LD_VAR 0 4
20772: PUSH
20773: LD_INT 1
20775: PLUS
20776: ARRAY
20777: PUSH
20778: LD_INT 0
20780: PPUSH
20781: LD_INT 5
20783: PPUSH
20784: CALL_OW 12
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: PPUSH
20794: CALL 42162 0 4
20798: ST_TO_ADDR
// p := p + 3 ;
20799: LD_ADDR_VAR 0 4
20803: PUSH
20804: LD_VAR 0 4
20808: PUSH
20809: LD_INT 3
20811: PLUS
20812: ST_TO_ADDR
// end ;
20813: GO 20673
20815: POP
20816: POP
// end ;
20817: LD_VAR 0 2
20821: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20822: LD_INT 0
20824: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20825: LD_ADDR_EXP 48
20829: PUSH
20830: LD_EXP 48
20834: PPUSH
20835: LD_VAR 0 1
20839: PPUSH
20840: LD_INT 4
20842: PPUSH
20843: LD_VAR 0 2
20847: PPUSH
20848: CALL 42162 0 4
20852: ST_TO_ADDR
// end ;
20853: LD_VAR 0 3
20857: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20858: LD_INT 0
20860: PPUSH
// case nation of 1 , us :
20861: LD_VAR 0 2
20865: PUSH
20866: LD_INT 1
20868: DOUBLE
20869: EQUAL
20870: IFTRUE 20880
20872: LD_STRING us
20874: DOUBLE
20875: EQUAL
20876: IFTRUE 20880
20878: GO 20911
20880: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20881: LD_ADDR_EXP 48
20885: PUSH
20886: LD_EXP 48
20890: PPUSH
20891: LD_VAR 0 1
20895: PPUSH
20896: LD_INT 36
20898: PPUSH
20899: LD_VAR 0 3
20903: PPUSH
20904: CALL 42162 0 4
20908: ST_TO_ADDR
20909: GO 20962
20911: LD_INT 2
20913: DOUBLE
20914: EQUAL
20915: IFTRUE 20925
20917: LD_STRING ar
20919: DOUBLE
20920: EQUAL
20921: IFTRUE 20925
20923: GO 20961
20925: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
20926: LD_ADDR_EXP 48
20930: PUSH
20931: LD_VAR 0 1
20935: PPUSH
20936: LD_INT 14
20938: PUSH
20939: LD_INT 2
20941: PUSH
20942: LD_INT 1
20944: PUSH
20945: LD_INT 31
20947: PUSH
20948: EMPTY
20949: LIST
20950: LIST
20951: LIST
20952: LIST
20953: PPUSH
20954: CALL 20967 0 2
20958: ST_TO_ADDR
20959: GO 20962
20961: POP
// end ;
20962: LD_VAR 0 4
20966: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
20967: LD_INT 0
20969: PPUSH
20970: PPUSH
// for i = 1 to list do
20971: LD_ADDR_VAR 0 4
20975: PUSH
20976: DOUBLE
20977: LD_INT 1
20979: DEC
20980: ST_TO_ADDR
20981: LD_VAR 0 2
20985: PUSH
20986: FOR_TO
20987: IFFALSE 21037
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
20989: LD_ADDR_EXP 53
20993: PUSH
20994: LD_EXP 53
20998: PPUSH
20999: LD_VAR 0 1
21003: PPUSH
21004: LD_EXP 53
21008: PUSH
21009: LD_VAR 0 1
21013: ARRAY
21014: PUSH
21015: LD_INT 1
21017: PLUS
21018: PPUSH
21019: LD_VAR 0 2
21023: PUSH
21024: LD_VAR 0 4
21028: ARRAY
21029: PPUSH
21030: CALL 30882 0 4
21034: ST_TO_ADDR
21035: GO 20986
21037: POP
21038: POP
// end ;
21039: LD_VAR 0 3
21043: RET
// export function MCS_GetVehicleList ( side ) ; begin
21044: LD_INT 0
21046: PPUSH
// result := MREG_ToConstruct [ side ] ;
21047: LD_ADDR_VAR 0 2
21051: PUSH
21052: LD_EXP 53
21056: PUSH
21057: LD_VAR 0 1
21061: ARRAY
21062: ST_TO_ADDR
// end ;
21063: LD_VAR 0 2
21067: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21068: LD_INT 0
21070: PPUSH
21071: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21072: LD_ADDR_EXP 60
21076: PUSH
21077: LD_EXP 60
21081: PPUSH
21082: LD_VAR 0 1
21086: PPUSH
21087: LD_VAR 0 2
21091: PPUSH
21092: CALL_OW 1
21096: ST_TO_ADDR
// end ;
21097: LD_VAR 0 3
21101: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21102: LD_INT 0
21104: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21105: LD_ADDR_EXP 39
21109: PUSH
21110: LD_EXP 39
21114: PPUSH
21115: LD_VAR 0 1
21119: PPUSH
21120: LD_VAR 0 2
21124: PPUSH
21125: CALL_OW 1
21129: ST_TO_ADDR
// end ;
21130: LD_VAR 0 3
21134: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21135: LD_INT 0
21137: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21138: LD_ADDR_EXP 40
21142: PUSH
21143: LD_EXP 40
21147: PPUSH
21148: LD_VAR 0 1
21152: PPUSH
21153: LD_VAR 0 2
21157: PPUSH
21158: CALL_OW 1
21162: ST_TO_ADDR
// end ;
21163: LD_VAR 0 3
21167: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21168: LD_INT 0
21170: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21171: LD_ADDR_EXP 62
21175: PUSH
21176: LD_EXP 62
21180: PPUSH
21181: LD_VAR 0 1
21185: PPUSH
21186: LD_INT 1
21188: PPUSH
21189: LD_VAR 0 2
21193: PPUSH
21194: CALL 30882 0 4
21198: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21199: LD_ADDR_EXP 62
21203: PUSH
21204: LD_EXP 62
21208: PPUSH
21209: LD_VAR 0 1
21213: PPUSH
21214: LD_INT 2
21216: PPUSH
21217: LD_VAR 0 3
21221: PPUSH
21222: CALL 30882 0 4
21226: ST_TO_ADDR
// end ;
21227: LD_VAR 0 4
21231: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21232: LD_INT 0
21234: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21235: LD_ADDR_EXP 74
21239: PUSH
21240: LD_EXP 74
21244: PPUSH
21245: LD_INT 1
21247: PPUSH
21248: LD_VAR 0 1
21252: PPUSH
21253: CALL_OW 1
21257: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21258: LD_ADDR_EXP 74
21262: PUSH
21263: LD_EXP 74
21267: PPUSH
21268: LD_INT 2
21270: PPUSH
21271: LD_VAR 0 2
21275: PPUSH
21276: CALL_OW 1
21280: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21281: LD_ADDR_EXP 74
21285: PUSH
21286: LD_EXP 74
21290: PPUSH
21291: LD_INT 3
21293: PPUSH
21294: LD_VAR 0 3
21298: PPUSH
21299: CALL_OW 1
21303: ST_TO_ADDR
// end ;
21304: LD_VAR 0 4
21308: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21309: LD_INT 0
21311: PPUSH
21312: PPUSH
21313: PPUSH
// if not side or not list then
21314: LD_VAR 0 1
21318: NOT
21319: PUSH
21320: LD_VAR 0 2
21324: NOT
21325: OR
21326: IFFALSE 21330
// exit ;
21328: GO 21498
// SetTech ( 20 , side , state_researched ) ;
21330: LD_INT 20
21332: PPUSH
21333: LD_VAR 0 1
21337: PPUSH
21338: LD_INT 2
21340: PPUSH
21341: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21345: LD_ADDR_EXP 63
21349: PUSH
21350: LD_EXP 63
21354: PPUSH
21355: LD_VAR 0 1
21359: PPUSH
21360: LD_VAR 0 2
21364: PPUSH
21365: CALL_OW 2
21369: ST_TO_ADDR
// p := 1 ;
21370: LD_ADDR_VAR 0 5
21374: PUSH
21375: LD_INT 1
21377: ST_TO_ADDR
// for i = 1 to list / 3 do
21378: LD_ADDR_VAR 0 4
21382: PUSH
21383: DOUBLE
21384: LD_INT 1
21386: DEC
21387: ST_TO_ADDR
21388: LD_VAR 0 2
21392: PUSH
21393: LD_INT 3
21395: DIVREAL
21396: PUSH
21397: FOR_TO
21398: IFFALSE 21496
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21400: LD_VAR 0 2
21404: PUSH
21405: LD_VAR 0 5
21409: ARRAY
21410: PPUSH
21411: LD_VAR 0 2
21415: PUSH
21416: LD_VAR 0 5
21420: PUSH
21421: LD_INT 1
21423: PLUS
21424: ARRAY
21425: PPUSH
21426: LD_VAR 0 2
21430: PUSH
21431: LD_VAR 0 5
21435: PUSH
21436: LD_INT 2
21438: PLUS
21439: ARRAY
21440: PPUSH
21441: CALL 22200 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21445: LD_VAR 0 2
21449: PUSH
21450: LD_VAR 0 5
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 2
21460: PUSH
21461: LD_VAR 0 5
21465: PUSH
21466: LD_INT 1
21468: PLUS
21469: ARRAY
21470: PPUSH
21471: LD_VAR 0 1
21475: PPUSH
21476: CALL_OW 441
// p := p + 3 ;
21480: LD_ADDR_VAR 0 5
21484: PUSH
21485: LD_VAR 0 5
21489: PUSH
21490: LD_INT 3
21492: PLUS
21493: ST_TO_ADDR
// end ;
21494: GO 21397
21496: POP
21497: POP
// end ;
21498: LD_VAR 0 3
21502: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21503: LD_INT 0
21505: PPUSH
21506: PPUSH
// if nat = nation_arabian then
21507: LD_VAR 0 2
21511: PUSH
21512: LD_INT 2
21514: EQUAL
21515: IFFALSE 21521
// exit else
21517: GO 21593
21519: GO 21579
// if nat = nation_american then
21521: LD_VAR 0 2
21525: PUSH
21526: LD_INT 1
21528: EQUAL
21529: IFFALSE 21556
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21531: LD_ADDR_VAR 0 4
21535: PUSH
21536: LD_INT 4
21538: PUSH
21539: LD_INT 3
21541: PUSH
21542: LD_INT 1
21544: PUSH
21545: LD_INT 8
21547: PUSH
21548: EMPTY
21549: LIST
21550: LIST
21551: LIST
21552: LIST
21553: ST_TO_ADDR
21554: GO 21579
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21556: LD_ADDR_VAR 0 4
21560: PUSH
21561: LD_INT 24
21563: PUSH
21564: LD_INT 3
21566: PUSH
21567: LD_INT 1
21569: PUSH
21570: LD_INT 48
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: LIST
21577: LIST
21578: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21579: LD_VAR 0 1
21583: PPUSH
21584: LD_VAR 0 4
21588: PPUSH
21589: CALL 20967 0 2
// end ;
21593: LD_VAR 0 3
21597: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21598: LD_INT 0
21600: PPUSH
21601: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21602: LD_ADDR_EXP 65
21606: PUSH
21607: LD_EXP 65
21611: PPUSH
21612: LD_VAR 0 1
21616: PPUSH
21617: LD_INT 1
21619: PPUSH
21620: LD_VAR 0 4
21624: PPUSH
21625: CALL 30882 0 4
21629: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21630: LD_ADDR_EXP 66
21634: PUSH
21635: LD_EXP 66
21639: PPUSH
21640: LD_VAR 0 1
21644: PPUSH
21645: LD_INT 1
21647: PPUSH
21648: LD_VAR 0 2
21652: PPUSH
21653: CALL 30882 0 4
21657: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21658: LD_ADDR_EXP 67
21662: PUSH
21663: LD_EXP 67
21667: PPUSH
21668: LD_VAR 0 1
21672: PPUSH
21673: LD_INT 1
21675: PPUSH
21676: LD_VAR 0 3
21680: PPUSH
21681: CALL 30882 0 4
21685: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21686: LD_ADDR_EXP 68
21690: PUSH
21691: LD_EXP 68
21695: PPUSH
21696: LD_VAR 0 1
21700: PPUSH
21701: LD_INT 1
21703: PPUSH
21704: LD_VAR 0 5
21708: PPUSH
21709: CALL 30882 0 4
21713: ST_TO_ADDR
// while squad do
21714: LD_VAR 0 5
21718: IFFALSE 21811
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21720: LD_VAR 0 1
21724: PPUSH
21725: LD_VAR 0 5
21729: PUSH
21730: LD_INT 1
21732: ARRAY
21733: PUSH
21734: LD_VAR 0 5
21738: PUSH
21739: LD_INT 2
21741: ARRAY
21742: PUSH
21743: LD_VAR 0 5
21747: PUSH
21748: LD_INT 3
21750: ARRAY
21751: PUSH
21752: LD_VAR 0 5
21756: PUSH
21757: LD_INT 4
21759: ARRAY
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: LIST
21765: LIST
21766: PPUSH
21767: CALL 20967 0 2
// for i = 1 to 4 do
21771: LD_ADDR_VAR 0 7
21775: PUSH
21776: DOUBLE
21777: LD_INT 1
21779: DEC
21780: ST_TO_ADDR
21781: LD_INT 4
21783: PUSH
21784: FOR_TO
21785: IFFALSE 21807
// squad := Delete ( squad , 1 ) ;
21787: LD_ADDR_VAR 0 5
21791: PUSH
21792: LD_VAR 0 5
21796: PPUSH
21797: LD_INT 1
21799: PPUSH
21800: CALL_OW 3
21804: ST_TO_ADDR
21805: GO 21784
21807: POP
21808: POP
// end ;
21809: GO 21714
// end ;
21811: LD_VAR 0 6
21815: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21816: LD_INT 0
21818: PPUSH
21819: PPUSH
// for i = 1 to squad do
21820: LD_ADDR_VAR 0 4
21824: PUSH
21825: DOUBLE
21826: LD_INT 1
21828: DEC
21829: ST_TO_ADDR
21830: LD_VAR 0 2
21834: PUSH
21835: FOR_TO
21836: IFFALSE 21886
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21838: LD_ADDR_EXP 71
21842: PUSH
21843: LD_EXP 71
21847: PPUSH
21848: LD_VAR 0 1
21852: PPUSH
21853: LD_EXP 71
21857: PUSH
21858: LD_VAR 0 1
21862: ARRAY
21863: PUSH
21864: LD_INT 1
21866: PLUS
21867: PPUSH
21868: LD_VAR 0 2
21872: PUSH
21873: LD_VAR 0 4
21877: ARRAY
21878: PPUSH
21879: CALL 30882 0 4
21883: ST_TO_ADDR
21884: GO 21835
21886: POP
21887: POP
// while squad do
21888: LD_VAR 0 2
21892: IFFALSE 21985
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21894: LD_VAR 0 1
21898: PPUSH
21899: LD_VAR 0 2
21903: PUSH
21904: LD_INT 1
21906: ARRAY
21907: PUSH
21908: LD_VAR 0 2
21912: PUSH
21913: LD_INT 2
21915: ARRAY
21916: PUSH
21917: LD_VAR 0 2
21921: PUSH
21922: LD_INT 3
21924: ARRAY
21925: PUSH
21926: LD_VAR 0 2
21930: PUSH
21931: LD_INT 4
21933: ARRAY
21934: PUSH
21935: EMPTY
21936: LIST
21937: LIST
21938: LIST
21939: LIST
21940: PPUSH
21941: CALL 20967 0 2
// for i = 1 to 4 do
21945: LD_ADDR_VAR 0 4
21949: PUSH
21950: DOUBLE
21951: LD_INT 1
21953: DEC
21954: ST_TO_ADDR
21955: LD_INT 4
21957: PUSH
21958: FOR_TO
21959: IFFALSE 21981
// squad := Delete ( squad , 1 ) ;
21961: LD_ADDR_VAR 0 2
21965: PUSH
21966: LD_VAR 0 2
21970: PPUSH
21971: LD_INT 1
21973: PPUSH
21974: CALL_OW 3
21978: ST_TO_ADDR
21979: GO 21958
21981: POP
21982: POP
// end ;
21983: GO 21888
// end ;
21985: LD_VAR 0 3
21989: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
21990: LD_INT 0
21992: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
21993: LD_ADDR_EXP 64
21997: PUSH
21998: LD_EXP 64
22002: PPUSH
22003: LD_VAR 0 1
22007: PPUSH
22008: LD_INT 1
22010: PPUSH
22011: LD_VAR 0 2
22015: PPUSH
22016: CALL 30882 0 4
22020: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22021: LD_ADDR_EXP 64
22025: PUSH
22026: LD_EXP 64
22030: PPUSH
22031: LD_VAR 0 1
22035: PPUSH
22036: LD_INT 2
22038: PPUSH
22039: LD_VAR 0 3
22043: PPUSH
22044: CALL 30882 0 4
22048: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22049: LD_ADDR_EXP 64
22053: PUSH
22054: LD_EXP 64
22058: PPUSH
22059: LD_VAR 0 1
22063: PPUSH
22064: LD_INT 3
22066: PPUSH
22067: LD_VAR 0 4
22071: PPUSH
22072: CALL 30882 0 4
22076: ST_TO_ADDR
// end ; end_of_file
22077: LD_VAR 0 5
22081: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22082: LD_INT 0
22084: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22085: LD_ADDR_EXP 44
22089: PUSH
22090: LD_EXP 44
22094: PPUSH
22095: LD_VAR 0 1
22099: PPUSH
22100: LD_INT 1
22102: PPUSH
22103: LD_VAR 0 2
22107: PPUSH
22108: CALL 30882 0 4
22112: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22113: LD_VAR 0 1
22117: PPUSH
22118: EMPTY
22119: PPUSH
22120: CALL 11583 0 2
22124: PUSH
22125: LD_INT 1
22127: ARRAY
22128: PPUSH
22129: CALL_OW 248
22133: PUSH
22134: LD_INT 1
22136: EQUAL
22137: IFFALSE 22168
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22139: LD_VAR 0 1
22143: PPUSH
22144: LD_INT 4
22146: PUSH
22147: LD_INT 1
22149: PUSH
22150: LD_INT 1
22152: PUSH
22153: LD_INT 14
22155: PUSH
22156: EMPTY
22157: LIST
22158: LIST
22159: LIST
22160: LIST
22161: PPUSH
22162: CALL 20967 0 2
22166: GO 22195
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22168: LD_VAR 0 1
22172: PPUSH
22173: LD_INT 24
22175: PUSH
22176: LD_INT 1
22178: PUSH
22179: LD_INT 1
22181: PUSH
22182: LD_INT 53
22184: PUSH
22185: EMPTY
22186: LIST
22187: LIST
22188: LIST
22189: LIST
22190: PPUSH
22191: CALL 20967 0 2
// end ;
22195: LD_VAR 0 3
22199: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22200: LD_INT 0
22202: PPUSH
// CreateDepositXY ( x , y , t ) ;
22203: LD_VAR 0 1
22207: PPUSH
22208: LD_VAR 0 2
22212: PPUSH
22213: LD_VAR 0 3
22217: PPUSH
22218: CALL_OW 62
// end ;
22222: LD_VAR 0 4
22226: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22227: LD_INT 0
22229: PPUSH
22230: PPUSH
// c := 1 ;
22231: LD_ADDR_VAR 0 5
22235: PUSH
22236: LD_INT 1
22238: ST_TO_ADDR
// case color of red :
22239: LD_VAR 0 3
22243: PUSH
22244: LD_STRING red
22246: DOUBLE
22247: EQUAL
22248: IFTRUE 22252
22250: GO 22263
22252: POP
// c = 1 ; dark-green :
22253: LD_ADDR_VAR 0 5
22257: PUSH
22258: LD_INT 1
22260: ST_TO_ADDR
22261: GO 22549
22263: LD_STRING dark-green
22265: DOUBLE
22266: EQUAL
22267: IFTRUE 22271
22269: GO 22282
22271: POP
// c = 2 ; purple :
22272: LD_ADDR_VAR 0 5
22276: PUSH
22277: LD_INT 2
22279: ST_TO_ADDR
22280: GO 22549
22282: LD_STRING purple
22284: DOUBLE
22285: EQUAL
22286: IFTRUE 22290
22288: GO 22301
22290: POP
// c = 3 ; aqua :
22291: LD_ADDR_VAR 0 5
22295: PUSH
22296: LD_INT 3
22298: ST_TO_ADDR
22299: GO 22549
22301: LD_STRING aqua
22303: DOUBLE
22304: EQUAL
22305: IFTRUE 22309
22307: GO 22320
22309: POP
// c = 4 ; grey :
22310: LD_ADDR_VAR 0 5
22314: PUSH
22315: LD_INT 4
22317: ST_TO_ADDR
22318: GO 22549
22320: LD_STRING grey
22322: DOUBLE
22323: EQUAL
22324: IFTRUE 22328
22326: GO 22339
22328: POP
// c = 5 ; lime :
22329: LD_ADDR_VAR 0 5
22333: PUSH
22334: LD_INT 5
22336: ST_TO_ADDR
22337: GO 22549
22339: LD_STRING lime
22341: DOUBLE
22342: EQUAL
22343: IFTRUE 22347
22345: GO 22358
22347: POP
// c = 6 ; tan :
22348: LD_ADDR_VAR 0 5
22352: PUSH
22353: LD_INT 6
22355: ST_TO_ADDR
22356: GO 22549
22358: LD_STRING tan
22360: DOUBLE
22361: EQUAL
22362: IFTRUE 22366
22364: GO 22377
22366: POP
// c = 7 ; pink :
22367: LD_ADDR_VAR 0 5
22371: PUSH
22372: LD_INT 7
22374: ST_TO_ADDR
22375: GO 22549
22377: LD_STRING pink
22379: DOUBLE
22380: EQUAL
22381: IFTRUE 22385
22383: GO 22396
22385: POP
// c = 8 ; green :
22386: LD_ADDR_VAR 0 5
22390: PUSH
22391: LD_INT 8
22393: ST_TO_ADDR
22394: GO 22549
22396: LD_STRING green
22398: DOUBLE
22399: EQUAL
22400: IFTRUE 22404
22402: GO 22415
22404: POP
// c = 9 ; blue :
22405: LD_ADDR_VAR 0 5
22409: PUSH
22410: LD_INT 9
22412: ST_TO_ADDR
22413: GO 22549
22415: LD_STRING blue
22417: DOUBLE
22418: EQUAL
22419: IFTRUE 22423
22421: GO 22434
22423: POP
// c = 10 ; yellow :
22424: LD_ADDR_VAR 0 5
22428: PUSH
22429: LD_INT 10
22431: ST_TO_ADDR
22432: GO 22549
22434: LD_STRING yellow
22436: DOUBLE
22437: EQUAL
22438: IFTRUE 22442
22440: GO 22453
22442: POP
// c = 11 ; brown :
22443: LD_ADDR_VAR 0 5
22447: PUSH
22448: LD_INT 11
22450: ST_TO_ADDR
22451: GO 22549
22453: LD_STRING brown
22455: DOUBLE
22456: EQUAL
22457: IFTRUE 22461
22459: GO 22472
22461: POP
// c = 12 ; black :
22462: LD_ADDR_VAR 0 5
22466: PUSH
22467: LD_INT 12
22469: ST_TO_ADDR
22470: GO 22549
22472: LD_STRING black
22474: DOUBLE
22475: EQUAL
22476: IFTRUE 22480
22478: GO 22491
22480: POP
// c = 13 ; aqua2 :
22481: LD_ADDR_VAR 0 5
22485: PUSH
22486: LD_INT 13
22488: ST_TO_ADDR
22489: GO 22549
22491: LD_STRING aqua2
22493: DOUBLE
22494: EQUAL
22495: IFTRUE 22499
22497: GO 22510
22499: POP
// c = 14 ; orange :
22500: LD_ADDR_VAR 0 5
22504: PUSH
22505: LD_INT 14
22507: ST_TO_ADDR
22508: GO 22549
22510: LD_STRING orange
22512: DOUBLE
22513: EQUAL
22514: IFTRUE 22518
22516: GO 22529
22518: POP
// c = 15 ; white :
22519: LD_ADDR_VAR 0 5
22523: PUSH
22524: LD_INT 15
22526: ST_TO_ADDR
22527: GO 22549
22529: LD_STRING white
22531: DOUBLE
22532: EQUAL
22533: IFTRUE 22537
22535: GO 22548
22537: POP
// c = 16 ; end ;
22538: LD_ADDR_VAR 0 5
22542: PUSH
22543: LD_INT 16
22545: ST_TO_ADDR
22546: GO 22549
22548: POP
// if HexInfo ( x , y ) = 0 then
22549: LD_VAR 0 1
22553: PPUSH
22554: LD_VAR 0 2
22558: PPUSH
22559: CALL_OW 428
22563: PUSH
22564: LD_INT 0
22566: EQUAL
22567: IFFALSE 22591
// PlaceEnvironment ( x , y , 58 , c ) ;
22569: LD_VAR 0 1
22573: PPUSH
22574: LD_VAR 0 2
22578: PPUSH
22579: LD_INT 58
22581: PPUSH
22582: LD_VAR 0 5
22586: PPUSH
22587: CALL_OW 349
// end ;
22591: LD_VAR 0 4
22595: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22596: LD_INT 0
22598: PPUSH
// RemoveEnvironment ( x , y ) ;
22599: LD_VAR 0 1
22603: PPUSH
22604: LD_VAR 0 2
22608: PPUSH
22609: CALL_OW 347
// end ;
22613: LD_VAR 0 3
22617: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22618: LD_INT 0
22620: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22621: LD_INT 81
22623: PUSH
22624: LD_VAR 0 1
22628: PUSH
22629: EMPTY
22630: LIST
22631: LIST
22632: PPUSH
22633: CALL_OW 69
22637: PUSH
22638: LD_INT 0
22640: EQUAL
22641: IFFALSE 22653
// result := false else
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 0
22650: ST_TO_ADDR
22651: GO 22717
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22653: LD_INT 81
22655: PUSH
22656: LD_VAR 0 1
22660: PUSH
22661: EMPTY
22662: LIST
22663: LIST
22664: PUSH
22665: LD_INT 92
22667: PUSH
22668: LD_VAR 0 2
22672: PUSH
22673: LD_VAR 0 3
22677: PUSH
22678: LD_VAR 0 4
22682: PUSH
22683: EMPTY
22684: LIST
22685: LIST
22686: LIST
22687: LIST
22688: PUSH
22689: EMPTY
22690: LIST
22691: LIST
22692: PPUSH
22693: CALL_OW 69
22697: IFFALSE 22709
// result := true else
22699: LD_ADDR_VAR 0 5
22703: PUSH
22704: LD_INT 1
22706: ST_TO_ADDR
22707: GO 22717
// result := false ;
22709: LD_ADDR_VAR 0 5
22713: PUSH
22714: LD_INT 0
22716: ST_TO_ADDR
// end ;
22717: LD_VAR 0 5
22721: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22722: LD_INT 0
22724: PPUSH
22725: PPUSH
22726: PPUSH
22727: PPUSH
22728: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22729: LD_VAR 0 1
22733: PPUSH
22734: LD_INT 81
22736: PUSH
22737: LD_VAR 0 1
22741: PPUSH
22742: CALL_OW 255
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PPUSH
22751: CALL_OW 69
22755: PPUSH
22756: LD_VAR 0 1
22760: PPUSH
22761: CALL_OW 74
22765: PPUSH
22766: CALL_OW 119
// dir := GetDir ( un ) ;
22770: LD_ADDR_VAR 0 4
22774: PUSH
22775: LD_VAR 0 1
22779: PPUSH
22780: CALL_OW 254
22784: ST_TO_ADDR
// dir := dir - 3 ;
22785: LD_ADDR_VAR 0 4
22789: PUSH
22790: LD_VAR 0 4
22794: PUSH
22795: LD_INT 3
22797: MINUS
22798: ST_TO_ADDR
// if dir < 0 then
22799: LD_VAR 0 4
22803: PUSH
22804: LD_INT 0
22806: LESS
22807: IFFALSE 22823
// dir := dir + 6 ;
22809: LD_ADDR_VAR 0 4
22813: PUSH
22814: LD_VAR 0 4
22818: PUSH
22819: LD_INT 6
22821: PLUS
22822: ST_TO_ADDR
// while true do
22823: LD_INT 1
22825: IFFALSE 23322
// begin coord_dist := 3 ;
22827: LD_ADDR_VAR 0 3
22831: PUSH
22832: LD_INT 3
22834: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22835: LD_ADDR_VAR 0 5
22839: PUSH
22840: LD_VAR 0 1
22844: PPUSH
22845: CALL_OW 250
22849: PPUSH
22850: LD_VAR 0 4
22854: PPUSH
22855: LD_VAR 0 3
22859: PPUSH
22860: CALL_OW 272
22864: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22865: LD_ADDR_VAR 0 6
22869: PUSH
22870: LD_VAR 0 1
22874: PPUSH
22875: CALL_OW 251
22879: PPUSH
22880: LD_VAR 0 4
22884: PPUSH
22885: LD_VAR 0 3
22889: PPUSH
22890: CALL_OW 273
22894: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22895: LD_VAR 0 1
22899: PPUSH
22900: CALL_OW 255
22904: PPUSH
22905: LD_VAR 0 1
22909: PPUSH
22910: CALL_OW 250
22914: PPUSH
22915: LD_VAR 0 1
22919: PPUSH
22920: CALL_OW 251
22924: PPUSH
22925: LD_INT 14
22927: PPUSH
22928: CALL 22618 0 4
22932: PUSH
22933: LD_VAR 0 5
22937: PPUSH
22938: LD_VAR 0 6
22942: PPUSH
22943: CALL_OW 351
22947: OR
22948: PUSH
22949: LD_VAR 0 5
22953: PPUSH
22954: LD_VAR 0 6
22958: PPUSH
22959: CALL_OW 488
22963: PUSH
22964: LD_INT 0
22966: EQUAL
22967: OR
22968: PUSH
22969: LD_VAR 0 5
22973: PPUSH
22974: LD_VAR 0 6
22978: PPUSH
22979: CALL_OW 546
22983: PUSH
22984: LD_INT 1
22986: EQUAL
22987: OR
22988: PUSH
22989: LD_VAR 0 5
22993: PPUSH
22994: LD_VAR 0 6
22998: PPUSH
22999: CALL_OW 428
23003: PUSH
23004: LD_INT 0
23006: NONEQUAL
23007: OR
23008: IFFALSE 23236
// begin repeat begin Wait ( 0 0$0.3 ) ;
23010: LD_INT 10
23012: PPUSH
23013: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23017: LD_ADDR_VAR 0 3
23021: PUSH
23022: LD_VAR 0 3
23026: PUSH
23027: LD_INT 1
23029: PLUS
23030: ST_TO_ADDR
// dir := dir + 1 ;
23031: LD_ADDR_VAR 0 4
23035: PUSH
23036: LD_VAR 0 4
23040: PUSH
23041: LD_INT 1
23043: PLUS
23044: ST_TO_ADDR
// if dir > 5 then
23045: LD_VAR 0 4
23049: PUSH
23050: LD_INT 5
23052: GREATER
23053: IFFALSE 23063
// dir = 0 ;
23055: LD_ADDR_VAR 0 4
23059: PUSH
23060: LD_INT 0
23062: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23063: LD_ADDR_VAR 0 5
23067: PUSH
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 250
23077: PPUSH
23078: LD_VAR 0 4
23082: PPUSH
23083: LD_VAR 0 3
23087: PPUSH
23088: CALL_OW 272
23092: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23093: LD_ADDR_VAR 0 6
23097: PUSH
23098: LD_VAR 0 1
23102: PPUSH
23103: CALL_OW 251
23107: PPUSH
23108: LD_VAR 0 4
23112: PPUSH
23113: LD_VAR 0 3
23117: PPUSH
23118: CALL_OW 273
23122: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23123: LD_VAR 0 1
23127: PPUSH
23128: CALL_OW 255
23132: PPUSH
23133: LD_VAR 0 1
23137: PPUSH
23138: CALL_OW 250
23142: PPUSH
23143: LD_VAR 0 1
23147: PPUSH
23148: CALL_OW 251
23152: PPUSH
23153: LD_INT 14
23155: PPUSH
23156: CALL 22618 0 4
23160: NOT
23161: PUSH
23162: LD_VAR 0 5
23166: PPUSH
23167: LD_VAR 0 6
23171: PPUSH
23172: CALL_OW 351
23176: NOT
23177: AND
23178: PUSH
23179: LD_VAR 0 5
23183: PPUSH
23184: LD_VAR 0 6
23188: PPUSH
23189: CALL_OW 488
23193: AND
23194: PUSH
23195: LD_VAR 0 5
23199: PPUSH
23200: LD_VAR 0 6
23204: PPUSH
23205: CALL_OW 546
23209: PUSH
23210: LD_INT 0
23212: EQUAL
23213: AND
23214: PUSH
23215: LD_VAR 0 5
23219: PPUSH
23220: LD_VAR 0 6
23224: PPUSH
23225: CALL_OW 428
23229: PUSH
23230: LD_INT 0
23232: EQUAL
23233: AND
23234: IFFALSE 23010
// end ; ComMoveXY ( un , x , y ) ;
23236: LD_VAR 0 1
23240: PPUSH
23241: LD_VAR 0 5
23245: PPUSH
23246: LD_VAR 0 6
23250: PPUSH
23251: CALL_OW 111
// Wait ( 0 0$1 ) ;
23255: LD_INT 35
23257: PPUSH
23258: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23262: LD_VAR 0 1
23266: PPUSH
23267: LD_INT 81
23269: PUSH
23270: LD_VAR 0 1
23274: PPUSH
23275: CALL_OW 255
23279: PUSH
23280: EMPTY
23281: LIST
23282: LIST
23283: PPUSH
23284: CALL_OW 69
23288: PPUSH
23289: LD_VAR 0 1
23293: PPUSH
23294: CALL_OW 74
23298: PPUSH
23299: CALL_OW 296
23303: PUSH
23304: LD_INT 14
23306: GREATEREQUAL
23307: IFFALSE 23320
// begin ComStop ( un ) ;
23309: LD_VAR 0 1
23313: PPUSH
23314: CALL_OW 141
// break ;
23318: GO 23322
// end ; end ;
23320: GO 22823
// end ;
23322: LD_VAR 0 2
23326: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23327: LD_INT 0
23329: PPUSH
23330: PPUSH
23331: PPUSH
23332: PPUSH
23333: PPUSH
23334: PPUSH
23335: PPUSH
23336: PPUSH
// x := GetX ( unit ) ;
23337: LD_ADDR_VAR 0 3
23341: PUSH
23342: LD_VAR 0 1
23346: PPUSH
23347: CALL_OW 250
23351: ST_TO_ADDR
// y := GetY ( unit ) ;
23352: LD_ADDR_VAR 0 4
23356: PUSH
23357: LD_VAR 0 1
23361: PPUSH
23362: CALL_OW 251
23366: ST_TO_ADDR
// i := 0 ;
23367: LD_ADDR_VAR 0 8
23371: PUSH
23372: LD_INT 0
23374: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23375: LD_VAR 0 1
23379: PPUSH
23380: LD_INT 81
23382: PUSH
23383: LD_VAR 0 1
23387: PPUSH
23388: CALL_OW 255
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: PPUSH
23397: CALL_OW 69
23401: PPUSH
23402: LD_VAR 0 1
23406: PPUSH
23407: CALL_OW 74
23411: PPUSH
23412: CALL_OW 119
// dir := GetDir ( unit ) ;
23416: LD_ADDR_VAR 0 7
23420: PUSH
23421: LD_VAR 0 1
23425: PPUSH
23426: CALL_OW 254
23430: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23431: LD_ADDR_VAR 0 9
23435: PUSH
23436: LD_INT 0
23438: PPUSH
23439: LD_INT 1
23441: PPUSH
23442: CALL_OW 12
23446: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23447: LD_INT 10
23449: PPUSH
23450: CALL_OW 67
// if mode then
23454: LD_VAR 0 9
23458: IFFALSE 23476
// dir := dir + 1 else
23460: LD_ADDR_VAR 0 7
23464: PUSH
23465: LD_VAR 0 7
23469: PUSH
23470: LD_INT 1
23472: PLUS
23473: ST_TO_ADDR
23474: GO 23490
// dir := dir - 1 ;
23476: LD_ADDR_VAR 0 7
23480: PUSH
23481: LD_VAR 0 7
23485: PUSH
23486: LD_INT 1
23488: MINUS
23489: ST_TO_ADDR
// if ( dir < 0 ) then
23490: LD_VAR 0 7
23494: PUSH
23495: LD_INT 0
23497: LESS
23498: IFFALSE 23508
// dir := 5 ;
23500: LD_ADDR_VAR 0 7
23504: PUSH
23505: LD_INT 5
23507: ST_TO_ADDR
// if ( dir > 5 ) then
23508: LD_VAR 0 7
23512: PUSH
23513: LD_INT 5
23515: GREATER
23516: IFFALSE 23526
// dir := 0 ;
23518: LD_ADDR_VAR 0 7
23522: PUSH
23523: LD_INT 0
23525: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23526: LD_ADDR_VAR 0 5
23530: PUSH
23531: LD_VAR 0 3
23535: PPUSH
23536: LD_VAR 0 7
23540: PPUSH
23541: LD_INT 4
23543: PPUSH
23544: CALL_OW 272
23548: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23549: LD_ADDR_VAR 0 6
23553: PUSH
23554: LD_VAR 0 4
23558: PPUSH
23559: LD_VAR 0 7
23563: PPUSH
23564: LD_INT 4
23566: PPUSH
23567: CALL_OW 273
23571: ST_TO_ADDR
// i := i + 1 ;
23572: LD_ADDR_VAR 0 8
23576: PUSH
23577: LD_VAR 0 8
23581: PUSH
23582: LD_INT 1
23584: PLUS
23585: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23586: LD_VAR 0 1
23590: PPUSH
23591: CALL_OW 255
23595: PPUSH
23596: LD_VAR 0 5
23600: PPUSH
23601: LD_VAR 0 6
23605: PPUSH
23606: LD_INT 14
23608: PPUSH
23609: CALL 22618 0 4
23613: PUSH
23614: LD_INT 0
23616: EQUAL
23617: PUSH
23618: LD_VAR 0 5
23622: PPUSH
23623: LD_VAR 0 6
23627: PPUSH
23628: CALL_OW 546
23632: PUSH
23633: LD_INT 0
23635: EQUAL
23636: AND
23637: PUSH
23638: LD_VAR 0 5
23642: PPUSH
23643: LD_VAR 0 6
23647: PPUSH
23648: CALL_OW 428
23652: PUSH
23653: LD_INT 0
23655: EQUAL
23656: AND
23657: IFFALSE 23661
// break ;
23659: GO 23671
// end until i > 4 ;
23661: LD_VAR 0 8
23665: PUSH
23666: LD_INT 4
23668: GREATER
23669: IFFALSE 23447
// if x2 and y2 then
23671: LD_VAR 0 5
23675: PUSH
23676: LD_VAR 0 6
23680: AND
23681: IFFALSE 23704
// result := [ x2 , y2 ] else
23683: LD_ADDR_VAR 0 2
23687: PUSH
23688: LD_VAR 0 5
23692: PUSH
23693: LD_VAR 0 6
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: ST_TO_ADDR
23702: GO 23733
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23704: LD_ADDR_VAR 0 2
23708: PUSH
23709: LD_VAR 0 1
23713: PPUSH
23714: CALL_OW 250
23718: PUSH
23719: LD_VAR 0 1
23723: PPUSH
23724: CALL_OW 251
23728: PUSH
23729: EMPTY
23730: LIST
23731: LIST
23732: ST_TO_ADDR
// end ;
23733: LD_VAR 0 2
23737: RET
// export function MCT_Hex ( x , y ) ; begin
23738: LD_INT 0
23740: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23741: LD_ADDR_VAR 0 3
23745: PUSH
23746: LD_VAR 0 1
23750: PPUSH
23751: LD_VAR 0 2
23755: PPUSH
23756: CALL_OW 546
23760: PUSH
23761: LD_VAR 0 1
23765: PPUSH
23766: LD_VAR 0 2
23770: PPUSH
23771: CALL_OW 428
23775: PUSH
23776: EMPTY
23777: LIST
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: ST_TO_ADDR
// end ;
23783: LD_VAR 0 3
23787: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23788: LD_INT 0
23790: PPUSH
23791: PPUSH
23792: PPUSH
23793: PPUSH
23794: PPUSH
23795: PPUSH
23796: PPUSH
23797: PPUSH
23798: PPUSH
23799: PPUSH
23800: PPUSH
23801: PPUSH
23802: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23803: LD_ADDR_VAR 0 10
23807: PUSH
23808: LD_EXP 62
23812: PUSH
23813: LD_VAR 0 1
23817: ARRAY
23818: PUSH
23819: LD_INT 1
23821: ARRAY
23822: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23823: LD_ADDR_VAR 0 11
23827: PUSH
23828: LD_EXP 62
23832: PUSH
23833: LD_VAR 0 1
23837: ARRAY
23838: PUSH
23839: LD_INT 2
23841: ARRAY
23842: ST_TO_ADDR
// collectors := [ ] ;
23843: LD_ADDR_VAR 0 12
23847: PUSH
23848: EMPTY
23849: ST_TO_ADDR
// is_cargo := false ;
23850: LD_ADDR_VAR 0 13
23854: PUSH
23855: LD_INT 0
23857: ST_TO_ADDR
// if isTest then
23858: LD_EXP 1
23862: IFFALSE 23868
// TimerStart ( ) ;
23864: CALL_OW 548
// if MCF_Cargo ( side ) then
23868: LD_VAR 0 1
23872: PPUSH
23873: CALL 11799 0 1
23877: IFFALSE 23904
// begin collectors := MCF_Cargo ( side ) ;
23879: LD_ADDR_VAR 0 12
23883: PUSH
23884: LD_VAR 0 1
23888: PPUSH
23889: CALL 11799 0 1
23893: ST_TO_ADDR
// is_cargo := true ;
23894: LD_ADDR_VAR 0 13
23898: PUSH
23899: LD_INT 1
23901: ST_TO_ADDR
// end else
23902: GO 24053
// begin if MCF_ApeSpec ( side , engineer ) then
23904: LD_VAR 0 1
23908: PPUSH
23909: LD_STRING engineer
23911: PPUSH
23912: CALL 11945 0 2
23916: IFFALSE 23936
// collectors := MCF_ApeSpec ( side , engineer ) ;
23918: LD_ADDR_VAR 0 12
23922: PUSH
23923: LD_VAR 0 1
23927: PPUSH
23928: LD_STRING engineer
23930: PPUSH
23931: CALL 11945 0 2
23935: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23936: LD_VAR 0 1
23940: PPUSH
23941: LD_INT 2
23943: PPUSH
23944: EMPTY
23945: PPUSH
23946: CALL 11531 0 3
23950: IFFALSE 24053
// begin z := MCF_Class ( side , 2 , [ ] ) ;
23952: LD_ADDR_VAR 0 7
23956: PUSH
23957: LD_VAR 0 1
23961: PPUSH
23962: LD_INT 2
23964: PPUSH
23965: EMPTY
23966: PPUSH
23967: CALL 11531 0 3
23971: ST_TO_ADDR
// if z > 5 then
23972: LD_VAR 0 7
23976: PUSH
23977: LD_INT 5
23979: GREATER
23980: IFFALSE 23992
// t1 := 5 else
23982: LD_ADDR_VAR 0 8
23986: PUSH
23987: LD_INT 5
23989: ST_TO_ADDR
23990: GO 24002
// t1 := z ;
23992: LD_ADDR_VAR 0 8
23996: PUSH
23997: LD_VAR 0 7
24001: ST_TO_ADDR
// for t2 = 1 to t1 do
24002: LD_ADDR_VAR 0 9
24006: PUSH
24007: DOUBLE
24008: LD_INT 1
24010: DEC
24011: ST_TO_ADDR
24012: LD_VAR 0 8
24016: PUSH
24017: FOR_TO
24018: IFFALSE 24051
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24020: LD_ADDR_VAR 0 12
24024: PUSH
24025: LD_VAR 0 12
24029: PPUSH
24030: LD_INT 1
24032: PPUSH
24033: LD_VAR 0 7
24037: PUSH
24038: LD_VAR 0 9
24042: ARRAY
24043: PPUSH
24044: CALL_OW 2
24048: ST_TO_ADDR
24049: GO 24017
24051: POP
24052: POP
// end ; end ; if not mode then
24053: LD_VAR 0 10
24057: NOT
24058: IFFALSE 24064
// exit else
24060: GO 24323
24062: GO 24323
// begin if collectors then
24064: LD_VAR 0 12
24068: IFFALSE 24323
// for i in areas do
24070: LD_ADDR_VAR 0 3
24074: PUSH
24075: LD_VAR 0 11
24079: PUSH
24080: FOR_IN
24081: IFFALSE 24321
// if GetListOfCratesInArea ( i ) then
24083: LD_VAR 0 3
24087: PPUSH
24088: CALL_OW 435
24092: IFFALSE 24319
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24094: LD_ADDR_VAR 0 5
24098: PUSH
24099: LD_VAR 0 3
24103: PPUSH
24104: CALL_OW 435
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24113: LD_ADDR_VAR 0 6
24117: PUSH
24118: LD_VAR 0 3
24122: PPUSH
24123: CALL_OW 435
24127: PUSH
24128: LD_INT 2
24130: ARRAY
24131: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24132: LD_VAR 0 13
24136: PUSH
24137: LD_VAR 0 12
24141: PUSH
24142: LD_INT 1
24144: ARRAY
24145: PPUSH
24146: CALL_OW 110
24150: PUSH
24151: LD_INT 0
24153: EQUAL
24154: AND
24155: IFFALSE 24217
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24157: LD_VAR 0 12
24161: PUSH
24162: LD_INT 1
24164: ARRAY
24165: PPUSH
24166: CALL_OW 314
24170: NOT
24171: PUSH
24172: LD_VAR 0 12
24176: PUSH
24177: LD_INT 1
24179: ARRAY
24180: PPUSH
24181: CALL_OW 110
24185: PUSH
24186: LD_INT 0
24188: EQUAL
24189: AND
24190: IFFALSE 24215
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24192: LD_VAR 0 12
24196: PUSH
24197: LD_INT 1
24199: ARRAY
24200: PPUSH
24201: LD_VAR 0 5
24205: PPUSH
24206: LD_VAR 0 6
24210: PPUSH
24211: CALL_OW 117
// end ; end else
24215: GO 24303
// begin for j = 1 to collectors do
24217: LD_ADDR_VAR 0 4
24221: PUSH
24222: DOUBLE
24223: LD_INT 1
24225: DEC
24226: ST_TO_ADDR
24227: LD_VAR 0 12
24231: PUSH
24232: FOR_TO
24233: IFFALSE 24301
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24235: LD_VAR 0 12
24239: PUSH
24240: LD_VAR 0 4
24244: ARRAY
24245: PPUSH
24246: CALL_OW 314
24250: NOT
24251: PUSH
24252: LD_VAR 0 12
24256: PUSH
24257: LD_VAR 0 4
24261: ARRAY
24262: PPUSH
24263: CALL_OW 110
24267: PUSH
24268: LD_INT 0
24270: EQUAL
24271: AND
24272: IFFALSE 24299
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24274: LD_VAR 0 12
24278: PUSH
24279: LD_VAR 0 4
24283: ARRAY
24284: PPUSH
24285: LD_VAR 0 5
24289: PPUSH
24290: LD_VAR 0 6
24294: PPUSH
24295: CALL 24694 0 3
// end ;
24299: GO 24232
24301: POP
24302: POP
// end ; if isTest then
24303: LD_EXP 1
24307: IFFALSE 24319
// begin debug_time := TimerEnd ( ) ;
24309: LD_ADDR_VAR 0 14
24313: PUSH
24314: CALL_OW 549
24318: ST_TO_ADDR
// end ; end ;
24319: GO 24080
24321: POP
24322: POP
// end ; end ;
24323: LD_VAR 0 2
24327: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24328: LD_INT 0
24330: PPUSH
24331: PPUSH
24332: PPUSH
24333: PPUSH
24334: PPUSH
24335: PPUSH
// if not area then
24336: LD_VAR 0 1
24340: NOT
24341: IFFALSE 24347
// exit else
24343: GO 24609
24345: GO 24609
// if tick mod interval = 0 and Prob ( percent ) then
24347: LD_OWVAR 1
24351: PUSH
24352: LD_VAR 0 4
24356: MOD
24357: PUSH
24358: LD_INT 0
24360: EQUAL
24361: PUSH
24362: LD_VAR 0 3
24366: PPUSH
24367: CALL_OW 13
24371: AND
24372: IFFALSE 24609
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24374: LD_VAR 0 1
24378: PPUSH
24379: CALL_OW 435
24383: PUSH
24384: LD_VAR 0 5
24388: LESS
24389: PUSH
24390: LD_VAR 0 5
24394: PUSH
24395: LD_INT 0
24397: EQUAL
24398: OR
24399: IFFALSE 24609
// begin Randomize ;
24401: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24405: LD_ADDR_VAR 0 7
24409: PUSH
24410: LD_INT 1
24412: PPUSH
24413: LD_VAR 0 2
24417: PPUSH
24418: CALL_OW 12
24422: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24423: LD_ADDR_VAR 0 9
24427: PUSH
24428: LD_VAR 0 1
24432: PPUSH
24433: LD_INT 0
24435: PPUSH
24436: CALL_OW 517
24440: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24441: LD_ADDR_VAR 0 8
24445: PUSH
24446: LD_INT 1
24448: PPUSH
24449: LD_VAR 0 9
24453: PUSH
24454: LD_INT 1
24456: ARRAY
24457: PPUSH
24458: CALL_OW 12
24462: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24463: LD_VAR 0 9
24467: PUSH
24468: LD_INT 1
24470: ARRAY
24471: PUSH
24472: LD_VAR 0 8
24476: ARRAY
24477: PPUSH
24478: LD_VAR 0 9
24482: PUSH
24483: LD_INT 2
24485: ARRAY
24486: PUSH
24487: LD_VAR 0 8
24491: ARRAY
24492: PPUSH
24493: CALL_OW 428
24497: PUSH
24498: LD_INT 0
24500: GREATER
24501: PUSH
24502: LD_VAR 0 9
24506: PUSH
24507: LD_INT 1
24509: ARRAY
24510: PUSH
24511: LD_VAR 0 8
24515: ARRAY
24516: PPUSH
24517: LD_VAR 0 9
24521: PUSH
24522: LD_INT 2
24524: ARRAY
24525: PUSH
24526: LD_VAR 0 8
24530: ARRAY
24531: PPUSH
24532: CALL_OW 284
24536: PUSH
24537: LD_INT 0
24539: GREATER
24540: AND
24541: IFFALSE 24567
// c := Rand ( 1 , tmp [ 1 ] ) ;
24543: LD_ADDR_VAR 0 8
24547: PUSH
24548: LD_INT 1
24550: PPUSH
24551: LD_VAR 0 9
24555: PUSH
24556: LD_INT 1
24558: ARRAY
24559: PPUSH
24560: CALL_OW 12
24564: ST_TO_ADDR
24565: GO 24463
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24567: LD_VAR 0 7
24571: PPUSH
24572: LD_VAR 0 9
24576: PUSH
24577: LD_INT 1
24579: ARRAY
24580: PUSH
24581: LD_VAR 0 8
24585: ARRAY
24586: PPUSH
24587: LD_VAR 0 9
24591: PUSH
24592: LD_INT 2
24594: ARRAY
24595: PUSH
24596: LD_VAR 0 8
24600: ARRAY
24601: PPUSH
24602: LD_INT 1
24604: PPUSH
24605: CALL_OW 54
// end ; end ; end ;
24609: LD_VAR 0 6
24613: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24614: LD_INT 0
24616: PPUSH
24617: PPUSH
// if not MREG_Crates then
24618: LD_EXP 36
24622: NOT
24623: IFFALSE 24627
// exit ;
24625: GO 24689
// for i = MREG_Crates downto 1 do
24627: LD_ADDR_VAR 0 2
24631: PUSH
24632: DOUBLE
24633: LD_EXP 36
24637: INC
24638: ST_TO_ADDR
24639: LD_INT 1
24641: PUSH
24642: FOR_DOWNTO
24643: IFFALSE 24687
// if MREG_Crates [ i ] [ 3 ] = 0 then
24645: LD_EXP 36
24649: PUSH
24650: LD_VAR 0 2
24654: ARRAY
24655: PUSH
24656: LD_INT 3
24658: ARRAY
24659: PUSH
24660: LD_INT 0
24662: EQUAL
24663: IFFALSE 24685
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24665: LD_ADDR_EXP 36
24669: PUSH
24670: LD_EXP 36
24674: PPUSH
24675: LD_VAR 0 2
24679: PPUSH
24680: CALL_OW 3
24684: ST_TO_ADDR
24685: GO 24642
24687: POP
24688: POP
// end ;
24689: LD_VAR 0 1
24693: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24694: LD_INT 0
24696: PPUSH
24697: PPUSH
24698: PPUSH
24699: PPUSH
// if not unit then
24700: LD_VAR 0 1
24704: NOT
24705: IFFALSE 24709
// exit ;
24707: GO 24844
// if HasTask ( unit ) or not CanCarry ( unit ) then
24709: LD_VAR 0 1
24713: PPUSH
24714: CALL_OW 314
24718: PUSH
24719: LD_VAR 0 1
24723: PPUSH
24724: CALL_OW 280
24728: NOT
24729: OR
24730: IFFALSE 24734
// exit ;
24732: GO 24844
// side := GetSide ( unit ) ;
24734: LD_ADDR_VAR 0 6
24738: PUSH
24739: LD_VAR 0 1
24743: PPUSH
24744: CALL_OW 255
24748: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24749: LD_ADDR_VAR 0 7
24753: PUSH
24754: LD_VAR 0 6
24758: PPUSH
24759: LD_INT 30
24761: PUSH
24762: LD_INT 1
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: PPUSH
24769: CALL 11448 0 2
24773: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24774: LD_VAR 0 1
24778: PPUSH
24779: CALL_OW 281
24783: PUSH
24784: LD_VAR 0 7
24788: NOT
24789: OR
24790: IFFALSE 24796
// exit else
24792: GO 24844
24794: GO 24844
// if GetResourceAmountXY ( x , y ) then
24796: LD_VAR 0 2
24800: PPUSH
24801: LD_VAR 0 3
24805: PPUSH
24806: CALL_OW 284
24810: IFFALSE 24842
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24812: LD_VAR 0 1
24816: PPUSH
24817: LD_VAR 0 2
24821: PPUSH
24822: LD_VAR 0 3
24826: PPUSH
24827: LD_VAR 0 7
24831: PUSH
24832: LD_INT 1
24834: ARRAY
24835: PPUSH
24836: CALL 32046 0 4
// end else
24840: GO 24844
// exit ;
24842: GO 24844
// end ;
24844: LD_VAR 0 4
24848: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24849: LD_INT 0
24851: PPUSH
24852: PPUSH
24853: PPUSH
24854: PPUSH
24855: PPUSH
// result := 0 ;
24856: LD_ADDR_VAR 0 2
24860: PUSH
24861: LD_INT 0
24863: ST_TO_ADDR
// p := 1 ;
24864: LD_ADDR_VAR 0 4
24868: PUSH
24869: LD_INT 1
24871: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24872: LD_ADDR_VAR 0 3
24876: PUSH
24877: DOUBLE
24878: LD_INT 1
24880: DEC
24881: ST_TO_ADDR
24882: LD_EXP 65
24886: PUSH
24887: LD_VAR 0 1
24891: ARRAY
24892: PUSH
24893: LD_INT 1
24895: ARRAY
24896: PUSH
24897: LD_INT 2
24899: DIVREAL
24900: PUSH
24901: FOR_TO
24902: IFFALSE 25026
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24904: LD_ADDR_VAR 0 5
24908: PUSH
24909: LD_INT 81
24911: PUSH
24912: LD_VAR 0 1
24916: PUSH
24917: EMPTY
24918: LIST
24919: LIST
24920: PUSH
24921: LD_INT 92
24923: PUSH
24924: LD_EXP 65
24928: PUSH
24929: LD_VAR 0 1
24933: ARRAY
24934: PUSH
24935: LD_INT 1
24937: ARRAY
24938: PUSH
24939: LD_VAR 0 4
24943: ARRAY
24944: PUSH
24945: LD_EXP 65
24949: PUSH
24950: LD_VAR 0 1
24954: ARRAY
24955: PUSH
24956: LD_INT 1
24958: ARRAY
24959: PUSH
24960: LD_VAR 0 4
24964: PUSH
24965: LD_INT 1
24967: PLUS
24968: ARRAY
24969: PUSH
24970: LD_INT 12
24972: PUSH
24973: EMPTY
24974: LIST
24975: LIST
24976: LIST
24977: LIST
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: PPUSH
24983: CALL_OW 69
24987: ST_TO_ADDR
// if tmp then
24988: LD_VAR 0 5
24992: IFFALSE 25010
// result := result ^ tmp ;
24994: LD_ADDR_VAR 0 2
24998: PUSH
24999: LD_VAR 0 2
25003: PUSH
25004: LD_VAR 0 5
25008: ADD
25009: ST_TO_ADDR
// p := p + 2 ;
25010: LD_ADDR_VAR 0 4
25014: PUSH
25015: LD_VAR 0 4
25019: PUSH
25020: LD_INT 2
25022: PLUS
25023: ST_TO_ADDR
// end ;
25024: GO 24901
25026: POP
25027: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25028: LD_EXP 66
25032: PUSH
25033: LD_VAR 0 1
25037: ARRAY
25038: PPUSH
25039: LD_INT 81
25041: PUSH
25042: LD_VAR 0 1
25046: PUSH
25047: EMPTY
25048: LIST
25049: LIST
25050: PPUSH
25051: CALL_OW 70
25055: IFFALSE 25096
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25057: LD_ADDR_VAR 0 2
25061: PUSH
25062: LD_VAR 0 2
25066: PUSH
25067: LD_EXP 66
25071: PUSH
25072: LD_VAR 0 1
25076: ARRAY
25077: PPUSH
25078: LD_INT 81
25080: PUSH
25081: LD_VAR 0 1
25085: PUSH
25086: EMPTY
25087: LIST
25088: LIST
25089: PPUSH
25090: CALL_OW 70
25094: ADD
25095: ST_TO_ADDR
// end ; end_of_file
25096: LD_VAR 0 2
25100: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25101: LD_INT 0
25103: PPUSH
25104: PPUSH
25105: PPUSH
// pom := GetBase ( fac ) ;
25106: LD_ADDR_VAR 0 5
25110: PUSH
25111: LD_VAR 0 1
25115: PPUSH
25116: CALL_OW 274
25120: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25121: LD_ADDR_VAR 0 4
25125: PUSH
25126: LD_VAR 0 2
25130: PUSH
25131: LD_INT 1
25133: ARRAY
25134: PPUSH
25135: LD_VAR 0 2
25139: PUSH
25140: LD_INT 2
25142: ARRAY
25143: PPUSH
25144: LD_VAR 0 2
25148: PUSH
25149: LD_INT 3
25151: ARRAY
25152: PPUSH
25153: LD_VAR 0 2
25157: PUSH
25158: LD_INT 4
25160: ARRAY
25161: PPUSH
25162: CALL_OW 449
25166: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25167: LD_VAR 0 5
25171: PPUSH
25172: LD_INT 1
25174: PPUSH
25175: CALL_OW 275
25179: PUSH
25180: LD_VAR 0 4
25184: PUSH
25185: LD_INT 1
25187: ARRAY
25188: GREATEREQUAL
25189: PUSH
25190: LD_VAR 0 5
25194: PPUSH
25195: LD_INT 2
25197: PPUSH
25198: CALL_OW 275
25202: PUSH
25203: LD_VAR 0 4
25207: PUSH
25208: LD_INT 2
25210: ARRAY
25211: GREATEREQUAL
25212: AND
25213: PUSH
25214: LD_VAR 0 5
25218: PPUSH
25219: LD_INT 3
25221: PPUSH
25222: CALL_OW 275
25226: PUSH
25227: LD_VAR 0 4
25231: PUSH
25232: LD_INT 3
25234: ARRAY
25235: GREATEREQUAL
25236: AND
25237: IFFALSE 25249
// result := true else
25239: LD_ADDR_VAR 0 3
25243: PUSH
25244: LD_INT 1
25246: ST_TO_ADDR
25247: GO 25257
// result := false ;
25249: LD_ADDR_VAR 0 3
25253: PUSH
25254: LD_INT 0
25256: ST_TO_ADDR
// end ;
25257: LD_VAR 0 3
25261: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25262: LD_INT 0
25264: PPUSH
25265: PPUSH
25266: PPUSH
// result := false ;
25267: LD_ADDR_VAR 0 3
25271: PUSH
25272: LD_INT 0
25274: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25275: LD_ADDR_VAR 0 4
25279: PUSH
25280: LD_EXP 53
25284: PUSH
25285: LD_VAR 0 1
25289: ARRAY
25290: ST_TO_ADDR
// if tmp then
25291: LD_VAR 0 4
25295: IFFALSE 25347
// for i = 1 to tmp do
25297: LD_ADDR_VAR 0 5
25301: PUSH
25302: DOUBLE
25303: LD_INT 1
25305: DEC
25306: ST_TO_ADDR
25307: LD_VAR 0 4
25311: PUSH
25312: FOR_TO
25313: IFFALSE 25345
// if component = tmp [ i ] then
25315: LD_VAR 0 2
25319: PUSH
25320: LD_VAR 0 4
25324: PUSH
25325: LD_VAR 0 5
25329: ARRAY
25330: EQUAL
25331: IFFALSE 25343
// begin result := true ;
25333: LD_ADDR_VAR 0 3
25337: PUSH
25338: LD_INT 1
25340: ST_TO_ADDR
// break ;
25341: GO 25345
// end ;
25343: GO 25312
25345: POP
25346: POP
// end ;
25347: LD_VAR 0 3
25351: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25352: LD_INT 0
25354: PPUSH
25355: PPUSH
25356: PPUSH
// if fac then
25357: LD_VAR 0 2
25361: IFFALSE 25596
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25363: LD_VAR 0 2
25367: PPUSH
25368: LD_VAR 0 3
25372: PPUSH
25373: CALL 25101 0 2
25377: PUSH
25378: LD_VAR 0 2
25382: PPUSH
25383: CALL_OW 461
25387: PUSH
25388: LD_INT 2
25390: EQUAL
25391: AND
25392: PUSH
25393: LD_VAR 0 2
25397: PPUSH
25398: LD_VAR 0 3
25402: PUSH
25403: LD_INT 1
25405: ARRAY
25406: PPUSH
25407: LD_VAR 0 3
25411: PUSH
25412: LD_INT 2
25414: ARRAY
25415: PPUSH
25416: LD_VAR 0 3
25420: PUSH
25421: LD_INT 3
25423: ARRAY
25424: PPUSH
25425: LD_VAR 0 3
25429: PUSH
25430: LD_INT 4
25432: ARRAY
25433: PPUSH
25434: CALL_OW 448
25438: AND
25439: IFFALSE 25586
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25441: LD_VAR 0 2
25445: PPUSH
25446: LD_VAR 0 3
25450: PUSH
25451: LD_INT 1
25453: ARRAY
25454: PPUSH
25455: LD_VAR 0 3
25459: PUSH
25460: LD_INT 2
25462: ARRAY
25463: PPUSH
25464: LD_VAR 0 3
25468: PUSH
25469: LD_INT 3
25471: ARRAY
25472: PPUSH
25473: LD_VAR 0 3
25477: PUSH
25478: LD_INT 4
25480: ARRAY
25481: PPUSH
25482: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25486: LD_ADDR_VAR 0 6
25490: PUSH
25491: LD_EXP 53
25495: PUSH
25496: LD_VAR 0 1
25500: ARRAY
25501: ST_TO_ADDR
// for i = 4 downto 1 do
25502: LD_ADDR_VAR 0 5
25506: PUSH
25507: DOUBLE
25508: LD_INT 4
25510: INC
25511: ST_TO_ADDR
25512: LD_INT 1
25514: PUSH
25515: FOR_DOWNTO
25516: IFFALSE 25549
// tab := Remove ( tab , list [ i ] , true ) ;
25518: LD_ADDR_VAR 0 6
25522: PUSH
25523: LD_VAR 0 6
25527: PPUSH
25528: LD_VAR 0 3
25532: PUSH
25533: LD_VAR 0 5
25537: ARRAY
25538: PPUSH
25539: LD_INT 1
25541: PPUSH
25542: CALL 31041 0 3
25546: ST_TO_ADDR
25547: GO 25515
25549: POP
25550: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25551: LD_ADDR_EXP 53
25555: PUSH
25556: LD_EXP 53
25560: PPUSH
25561: LD_VAR 0 1
25565: PPUSH
25566: LD_VAR 0 6
25570: PPUSH
25571: CALL_OW 1
25575: ST_TO_ADDR
// result := true ;
25576: LD_ADDR_VAR 0 4
25580: PUSH
25581: LD_INT 1
25583: ST_TO_ADDR
// end else
25584: GO 25594
// result := false ;
25586: LD_ADDR_VAR 0 4
25590: PUSH
25591: LD_INT 0
25593: ST_TO_ADDR
// end else
25594: GO 25604
// result := false ;
25596: LD_ADDR_VAR 0 4
25600: PUSH
25601: LD_INT 0
25603: ST_TO_ADDR
// end ;
25604: LD_VAR 0 4
25608: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25609: LD_INT 0
25611: PPUSH
25612: PPUSH
// if not veh then
25613: LD_VAR 0 2
25617: NOT
25618: IFFALSE 25622
// exit ;
25620: GO 25796
// if MREG_Parking [ side ] then
25622: LD_EXP 60
25626: PUSH
25627: LD_VAR 0 1
25631: ARRAY
25632: IFFALSE 25796
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25634: LD_VAR 0 2
25638: PPUSH
25639: LD_EXP 60
25643: PUSH
25644: LD_VAR 0 1
25648: ARRAY
25649: PPUSH
25650: CALL_OW 308
25654: NOT
25655: IFFALSE 25796
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25657: LD_VAR 0 2
25661: PPUSH
25662: LD_EXP 60
25666: PUSH
25667: LD_VAR 0 1
25671: ARRAY
25672: PPUSH
25673: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25677: LD_VAR 0 2
25681: PPUSH
25682: CALL_OW 263
25686: PUSH
25687: LD_INT 1
25689: EQUAL
25690: IFFALSE 25796
// begin i := GetDriver ( veh ) ;
25692: LD_ADDR_VAR 0 4
25696: PUSH
25697: LD_VAR 0 2
25701: PPUSH
25702: CALL 31576 0 1
25706: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25707: LD_INT 35
25709: PPUSH
25710: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25714: LD_VAR 0 2
25718: PPUSH
25719: LD_EXP 60
25723: PUSH
25724: LD_VAR 0 1
25728: ARRAY
25729: PPUSH
25730: CALL_OW 308
25734: PUSH
25735: LD_VAR 0 2
25739: PPUSH
25740: CALL_OW 301
25744: OR
25745: IFFALSE 25707
// ComExitVehicle ( i ) ;
25747: LD_VAR 0 4
25751: PPUSH
25752: CALL_OW 121
// Wait ( 1 ) ;
25756: LD_INT 1
25758: PPUSH
25759: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25763: LD_VAR 0 4
25767: PPUSH
25768: LD_VAR 0 1
25772: PPUSH
25773: LD_INT 30
25775: PUSH
25776: LD_INT 3
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PPUSH
25783: CALL 11448 0 2
25787: PUSH
25788: LD_INT 1
25790: ARRAY
25791: PPUSH
25792: CALL_OW 180
// end ; end ; end ;
25796: LD_VAR 0 3
25800: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25801: LD_INT 0
25803: PPUSH
25804: PPUSH
25805: PPUSH
25806: PPUSH
25807: PPUSH
25808: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25809: LD_VAR 0 1
25813: PPUSH
25814: LD_INT 30
25816: PUSH
25817: LD_INT 3
25819: PUSH
25820: EMPTY
25821: LIST
25822: LIST
25823: PPUSH
25824: CALL 11448 0 2
25828: IFFALSE 26012
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25830: LD_VAR 0 1
25834: PPUSH
25835: LD_INT 30
25837: PUSH
25838: LD_INT 3
25840: PUSH
25841: EMPTY
25842: LIST
25843: LIST
25844: PPUSH
25845: CALL 11448 0 2
25849: PUSH
25850: LD_INT 1
25852: ARRAY
25853: PPUSH
25854: CALL_OW 461
25858: PUSH
25859: LD_INT 2
25861: EQUAL
25862: IFFALSE 26012
// begin for i = 1 to MREG_TurretWeapon do
25864: LD_ADDR_VAR 0 3
25868: PUSH
25869: DOUBLE
25870: LD_INT 1
25872: DEC
25873: ST_TO_ADDR
25874: LD_EXP 45
25878: PUSH
25879: FOR_TO
25880: IFFALSE 26010
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25882: LD_EXP 45
25886: PUSH
25887: LD_VAR 0 3
25891: ARRAY
25892: PUSH
25893: LD_INT 1
25895: ARRAY
25896: PUSH
25897: LD_VAR 0 1
25901: EQUAL
25902: IFFALSE 26008
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25904: LD_ADDR_VAR 0 5
25908: PUSH
25909: LD_EXP 45
25913: PUSH
25914: LD_VAR 0 3
25918: ARRAY
25919: PUSH
25920: LD_INT 2
25922: ARRAY
25923: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25924: LD_ADDR_VAR 0 6
25928: PUSH
25929: LD_EXP 45
25933: PUSH
25934: LD_VAR 0 3
25938: ARRAY
25939: PUSH
25940: LD_INT 3
25942: ARRAY
25943: PUSH
25944: LD_INT 1
25946: ARRAY
25947: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25948: LD_ADDR_VAR 0 7
25952: PUSH
25953: LD_EXP 45
25957: PUSH
25958: LD_VAR 0 3
25962: ARRAY
25963: PUSH
25964: LD_INT 3
25966: ARRAY
25967: PUSH
25968: LD_INT 2
25970: ARRAY
25971: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25972: LD_ADDR_VAR 0 4
25976: PUSH
25977: LD_VAR 0 6
25981: PPUSH
25982: LD_VAR 0 7
25986: PPUSH
25987: CALL_OW 428
25991: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
25992: LD_VAR 0 4
25996: PPUSH
25997: LD_VAR 0 5
26001: PPUSH
26002: CALL_OW 148
// break ;
26006: GO 26010
// end ;
26008: GO 25879
26010: POP
26011: POP
// end ; end ;
26012: LD_VAR 0 2
26016: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26017: LD_INT 0
26019: PPUSH
26020: PPUSH
26021: PPUSH
26022: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26023: LD_ADDR_VAR 0 4
26027: PUSH
26028: LD_VAR 0 1
26032: PPUSH
26033: LD_INT 32
26035: PUSH
26036: LD_INT 1
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: PPUSH
26043: CALL 11448 0 2
26047: ST_TO_ADDR
// if not tmp then
26048: LD_VAR 0 4
26052: NOT
26053: IFFALSE 26059
// exit else
26055: GO 26141
26057: GO 26141
// begin for i = 1 to tmp do
26059: LD_ADDR_VAR 0 3
26063: PUSH
26064: DOUBLE
26065: LD_INT 1
26067: DEC
26068: ST_TO_ADDR
26069: LD_VAR 0 4
26073: PUSH
26074: FOR_TO
26075: IFFALSE 26139
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26077: LD_VAR 0 4
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PPUSH
26088: CALL_OW 261
26092: PUSH
26093: LD_INT 20
26095: LESS
26096: PUSH
26097: LD_VAR 0 4
26101: PUSH
26102: LD_VAR 0 3
26106: ARRAY
26107: PPUSH
26108: CALL_OW 110
26112: PUSH
26113: LD_INT 0
26115: EQUAL
26116: AND
26117: IFFALSE 26137
// begin SetTag ( tmp [ i ] , 21 ) ;
26119: LD_VAR 0 4
26123: PUSH
26124: LD_VAR 0 3
26128: ARRAY
26129: PPUSH
26130: LD_INT 21
26132: PPUSH
26133: CALL_OW 109
// end ;
26137: GO 26074
26139: POP
26140: POP
// end ; end ;
26141: LD_VAR 0 2
26145: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26146: LD_INT 0
26148: PPUSH
26149: PPUSH
26150: PPUSH
26151: PPUSH
26152: PPUSH
// if not unit then
26153: LD_VAR 0 1
26157: NOT
26158: IFFALSE 26162
// exit ;
26160: GO 26350
// side := GetSide ( unit ) ;
26162: LD_ADDR_VAR 0 3
26166: PUSH
26167: LD_VAR 0 1
26171: PPUSH
26172: CALL_OW 255
26176: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26177: LD_ADDR_VAR 0 5
26181: PUSH
26182: LD_VAR 0 3
26186: PPUSH
26187: LD_INT 2
26189: PUSH
26190: LD_INT 30
26192: PUSH
26193: LD_INT 1
26195: PUSH
26196: EMPTY
26197: LIST
26198: LIST
26199: PUSH
26200: LD_INT 30
26202: PUSH
26203: LD_INT 3
26205: PUSH
26206: EMPTY
26207: LIST
26208: LIST
26209: PUSH
26210: LD_INT 30
26212: PUSH
26213: LD_INT 29
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: PUSH
26220: EMPTY
26221: LIST
26222: LIST
26223: LIST
26224: LIST
26225: PPUSH
26226: CALL 11448 0 2
26230: ST_TO_ADDR
// if not b then
26231: LD_VAR 0 5
26235: NOT
26236: IFFALSE 26240
// exit ;
26238: GO 26350
// if GetTag ( unit ) = 21 then
26240: LD_VAR 0 1
26244: PPUSH
26245: CALL_OW 110
26249: PUSH
26250: LD_INT 21
26252: EQUAL
26253: IFFALSE 26350
// begin c := NearestUnitToUnit ( b , unit ) ;
26255: LD_ADDR_VAR 0 6
26259: PUSH
26260: LD_VAR 0 5
26264: PPUSH
26265: LD_VAR 0 1
26269: PPUSH
26270: CALL_OW 74
26274: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26275: LD_VAR 0 1
26279: PPUSH
26280: LD_VAR 0 6
26284: PPUSH
26285: CALL_OW 250
26289: PPUSH
26290: LD_VAR 0 6
26294: PPUSH
26295: CALL_OW 251
26299: PPUSH
26300: CALL_OW 297
26304: PUSH
26305: LD_INT 6
26307: GREATER
26308: IFFALSE 26326
// ComMoveUnit ( unit , c ) else
26310: LD_VAR 0 1
26314: PPUSH
26315: LD_VAR 0 6
26319: PPUSH
26320: CALL_OW 112
26324: GO 26350
// begin SetFuel ( unit , 100 ) ;
26326: LD_VAR 0 1
26330: PPUSH
26331: LD_INT 100
26333: PPUSH
26334: CALL_OW 240
// SetTag ( unit , 0 ) ;
26338: LD_VAR 0 1
26342: PPUSH
26343: LD_INT 0
26345: PPUSH
26346: CALL_OW 109
// end ; end ; end ;
26350: LD_VAR 0 2
26354: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26355: LD_INT 0
26357: PPUSH
26358: PPUSH
26359: PPUSH
26360: PPUSH
26361: PPUSH
26362: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26363: LD_ADDR_VAR 0 7
26367: PUSH
26368: LD_VAR 0 1
26372: PPUSH
26373: LD_INT 33
26375: PUSH
26376: LD_INT 2
26378: PUSH
26379: EMPTY
26380: LIST
26381: LIST
26382: PUSH
26383: LD_INT 3
26385: PUSH
26386: LD_INT 61
26388: PUSH
26389: EMPTY
26390: LIST
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PPUSH
26400: CALL 11448 0 2
26404: ST_TO_ADDR
// if not vehs then
26405: LD_VAR 0 7
26409: NOT
26410: IFFALSE 26414
// exit ;
26412: GO 26699
// if nation = 1 then
26414: LD_VAR 0 2
26418: PUSH
26419: LD_INT 1
26421: EQUAL
26422: IFFALSE 26592
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26424: LD_VAR 0 1
26428: PPUSH
26429: LD_INT 30
26431: PUSH
26432: LD_INT 36
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: PPUSH
26439: CALL 11448 0 2
26443: NOT
26444: IFFALSE 26450
// exit else
26446: GO 26699
26448: GO 26590
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26450: LD_ADDR_VAR 0 5
26454: PUSH
26455: LD_VAR 0 1
26459: PPUSH
26460: LD_INT 30
26462: PUSH
26463: LD_INT 36
26465: PUSH
26466: EMPTY
26467: LIST
26468: LIST
26469: PPUSH
26470: CALL 11448 0 2
26474: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26475: LD_ADDR_VAR 0 6
26479: PUSH
26480: LD_VAR 0 5
26484: PUSH
26485: LD_INT 1
26487: ARRAY
26488: PPUSH
26489: CALL_OW 313
26493: ST_TO_ADDR
// for i = vehs downto 1 do
26494: LD_ADDR_VAR 0 4
26498: PUSH
26499: DOUBLE
26500: LD_VAR 0 7
26504: INC
26505: ST_TO_ADDR
26506: LD_INT 1
26508: PUSH
26509: FOR_DOWNTO
26510: IFFALSE 26588
// begin if not IsControledBy ( vehs [ i ] ) then
26512: LD_VAR 0 7
26516: PUSH
26517: LD_VAR 0 4
26521: ARRAY
26522: PPUSH
26523: CALL_OW 312
26527: NOT
26528: IFFALSE 26586
// begin tmp := MCV_RemoteDriver ( oper ) ;
26530: LD_ADDR_VAR 0 8
26534: PUSH
26535: LD_VAR 0 6
26539: PPUSH
26540: CALL 26704 0 1
26544: ST_TO_ADDR
// if not tmp then
26545: LD_VAR 0 8
26549: NOT
26550: IFFALSE 26558
// exit else
26552: POP
26553: POP
26554: GO 26699
26556: GO 26586
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26558: LD_VAR 0 7
26562: PUSH
26563: LD_VAR 0 4
26567: ARRAY
26568: PPUSH
26569: LD_VAR 0 8
26573: PUSH
26574: LD_INT 1
26576: ARRAY
26577: PUSH
26578: LD_INT 1
26580: ARRAY
26581: PPUSH
26582: CALL_OW 135
// end ; end ;
26586: GO 26509
26588: POP
26589: POP
// end ; end else
26590: GO 26699
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26592: LD_VAR 0 1
26596: PPUSH
26597: LD_INT 34
26599: PUSH
26600: LD_INT 31
26602: PUSH
26603: EMPTY
26604: LIST
26605: LIST
26606: PPUSH
26607: CALL 11448 0 2
26611: NOT
26612: IFFALSE 26618
// exit else
26614: GO 26699
26616: GO 26699
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26618: LD_ADDR_VAR 0 5
26622: PUSH
26623: LD_VAR 0 1
26627: PPUSH
26628: LD_INT 34
26630: PUSH
26631: LD_INT 31
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PPUSH
26638: CALL 11448 0 2
26642: ST_TO_ADDR
// oper := [ ] ;
26643: LD_ADDR_VAR 0 6
26647: PUSH
26648: EMPTY
26649: ST_TO_ADDR
// for i = 1 to ct do
26650: LD_ADDR_VAR 0 4
26654: PUSH
26655: DOUBLE
26656: LD_INT 1
26658: DEC
26659: ST_TO_ADDR
26660: LD_VAR 0 5
26664: PUSH
26665: FOR_TO
26666: IFFALSE 26697
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26668: LD_ADDR_VAR 0 6
26672: PUSH
26673: LD_VAR 0 6
26677: PUSH
26678: LD_VAR 0 5
26682: PUSH
26683: LD_VAR 0 4
26687: ARRAY
26688: PPUSH
26689: CALL 31576 0 1
26693: ADD
26694: ST_TO_ADDR
26695: GO 26665
26697: POP
26698: POP
// end ; end ; end ;
26699: LD_VAR 0 3
26703: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26704: LD_INT 0
26706: PPUSH
26707: PPUSH
26708: PPUSH
26709: PPUSH
26710: PPUSH
26711: PPUSH
// if not drivers then
26712: LD_VAR 0 1
26716: NOT
26717: IFFALSE 26723
// exit else
26719: GO 27003
26721: GO 27003
// begin linked := [ ] ;
26723: LD_ADDR_VAR 0 5
26727: PUSH
26728: EMPTY
26729: ST_TO_ADDR
// for i = 1 to drivers do
26730: LD_ADDR_VAR 0 3
26734: PUSH
26735: DOUBLE
26736: LD_INT 1
26738: DEC
26739: ST_TO_ADDR
26740: LD_VAR 0 1
26744: PUSH
26745: FOR_TO
26746: IFFALSE 26991
// begin if CanControl ( drivers [ i ] ) then
26748: LD_VAR 0 1
26752: PUSH
26753: LD_VAR 0 3
26757: ARRAY
26758: PPUSH
26759: CALL 32148 0 1
26763: IFFALSE 26989
// if i > 1 then
26765: LD_VAR 0 3
26769: PUSH
26770: LD_INT 1
26772: GREATER
26773: IFFALSE 26950
// begin m := false ;
26775: LD_ADDR_VAR 0 6
26779: PUSH
26780: LD_INT 0
26782: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26783: LD_ADDR_VAR 0 7
26787: PUSH
26788: LD_VAR 0 1
26792: PUSH
26793: LD_VAR 0 3
26797: ARRAY
26798: PPUSH
26799: CALL_OW 432
26803: ST_TO_ADDR
// for j = 1 to linked do
26804: LD_ADDR_VAR 0 4
26808: PUSH
26809: DOUBLE
26810: LD_INT 1
26812: DEC
26813: ST_TO_ADDR
26814: LD_VAR 0 5
26818: PUSH
26819: FOR_TO
26820: IFFALSE 26894
// begin if l < linked [ j ] [ 2 ] then
26822: LD_VAR 0 7
26826: PUSH
26827: LD_VAR 0 5
26831: PUSH
26832: LD_VAR 0 4
26836: ARRAY
26837: PUSH
26838: LD_INT 2
26840: ARRAY
26841: LESS
26842: IFFALSE 26892
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26844: LD_ADDR_VAR 0 5
26848: PUSH
26849: LD_VAR 0 5
26853: PPUSH
26854: LD_INT 1
26856: PPUSH
26857: LD_VAR 0 1
26861: PUSH
26862: LD_VAR 0 3
26866: ARRAY
26867: PUSH
26868: LD_VAR 0 7
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PPUSH
26877: CALL_OW 2
26881: ST_TO_ADDR
// m := true ;
26882: LD_ADDR_VAR 0 6
26886: PUSH
26887: LD_INT 1
26889: ST_TO_ADDR
// break ;
26890: GO 26894
// end ; end ;
26892: GO 26819
26894: POP
26895: POP
// if not m then
26896: LD_VAR 0 6
26900: NOT
26901: IFFALSE 26948
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26903: LD_ADDR_VAR 0 5
26907: PUSH
26908: LD_VAR 0 5
26912: PUSH
26913: LD_VAR 0 1
26917: PUSH
26918: LD_VAR 0 3
26922: ARRAY
26923: PUSH
26924: LD_VAR 0 1
26928: PUSH
26929: LD_VAR 0 3
26933: ARRAY
26934: PPUSH
26935: CALL_OW 432
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: EMPTY
26945: LIST
26946: ADD
26947: ST_TO_ADDR
// end else
26948: GO 26989
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26950: LD_ADDR_VAR 0 5
26954: PUSH
26955: LD_VAR 0 1
26959: PUSH
26960: LD_VAR 0 3
26964: ARRAY
26965: PUSH
26966: LD_VAR 0 1
26970: PUSH
26971: LD_VAR 0 3
26975: ARRAY
26976: PPUSH
26977: CALL_OW 432
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: EMPTY
26987: LIST
26988: ST_TO_ADDR
// end ;
26989: GO 26745
26991: POP
26992: POP
// result := linked ;
26993: LD_ADDR_VAR 0 2
26997: PUSH
26998: LD_VAR 0 5
27002: ST_TO_ADDR
// end ; end ;
27003: LD_VAR 0 2
27007: RET
// export function MCV_ToRepair ( unit ) ; begin
27008: LD_INT 0
27010: PPUSH
// if not unit then
27011: LD_VAR 0 1
27015: NOT
27016: IFFALSE 27022
// exit else
27018: GO 27053
27020: GO 27053
// begin SetTag ( unit , 6 ) ;
27022: LD_VAR 0 1
27026: PPUSH
27027: LD_INT 6
27029: PPUSH
27030: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27034: LD_VAR 0 1
27038: PPUSH
27039: CALL_OW 255
27043: PPUSH
27044: LD_VAR 0 1
27048: PPUSH
27049: CALL 25609 0 2
// end ; end ;
27053: LD_VAR 0 2
27057: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27058: LD_INT 0
27060: PPUSH
27061: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27062: LD_VAR 0 1
27066: PPUSH
27067: LD_INT 6
27069: PPUSH
27070: EMPTY
27071: PPUSH
27072: CALL 12151 0 3
27076: IFFALSE 27169
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27078: LD_ADDR_VAR 0 3
27082: PUSH
27083: DOUBLE
27084: LD_VAR 0 1
27088: PPUSH
27089: LD_INT 6
27091: PPUSH
27092: EMPTY
27093: PPUSH
27094: CALL 12151 0 3
27098: INC
27099: ST_TO_ADDR
27100: LD_INT 1
27102: PUSH
27103: FOR_DOWNTO
27104: IFFALSE 27167
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27106: LD_VAR 0 1
27110: PPUSH
27111: LD_INT 6
27113: PPUSH
27114: EMPTY
27115: PPUSH
27116: CALL 12151 0 3
27120: PUSH
27121: LD_VAR 0 3
27125: ARRAY
27126: PPUSH
27127: CALL_OW 256
27131: PUSH
27132: LD_INT 1000
27134: EQUAL
27135: IFFALSE 27165
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27137: LD_VAR 0 1
27141: PPUSH
27142: LD_INT 6
27144: PPUSH
27145: EMPTY
27146: PPUSH
27147: CALL 12151 0 3
27151: PUSH
27152: LD_VAR 0 3
27156: ARRAY
27157: PPUSH
27158: LD_INT 0
27160: PPUSH
27161: CALL_OW 109
27165: GO 27103
27167: POP
27168: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27169: LD_VAR 0 1
27173: PPUSH
27174: LD_INT 10
27176: PPUSH
27177: EMPTY
27178: PPUSH
27179: CALL 12151 0 3
27183: IFFALSE 27300
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27185: LD_ADDR_VAR 0 3
27189: PUSH
27190: DOUBLE
27191: LD_VAR 0 1
27195: PPUSH
27196: LD_INT 10
27198: PPUSH
27199: EMPTY
27200: PPUSH
27201: CALL 12151 0 3
27205: INC
27206: ST_TO_ADDR
27207: LD_INT 1
27209: PUSH
27210: FOR_DOWNTO
27211: IFFALSE 27298
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27213: LD_VAR 0 1
27217: PPUSH
27218: LD_INT 10
27220: PPUSH
27221: EMPTY
27222: PPUSH
27223: CALL 12151 0 3
27227: PUSH
27228: LD_VAR 0 3
27232: ARRAY
27233: PPUSH
27234: CALL_OW 302
27238: NOT
27239: PUSH
27240: LD_VAR 0 1
27244: PPUSH
27245: LD_INT 10
27247: PPUSH
27248: EMPTY
27249: PPUSH
27250: CALL 12151 0 3
27254: PUSH
27255: LD_VAR 0 3
27259: ARRAY
27260: PPUSH
27261: CALL_OW 301
27265: OR
27266: IFFALSE 27296
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27268: LD_VAR 0 1
27272: PPUSH
27273: LD_INT 10
27275: PPUSH
27276: EMPTY
27277: PPUSH
27278: CALL 12151 0 3
27282: PUSH
27283: LD_VAR 0 3
27287: ARRAY
27288: PPUSH
27289: LD_INT 0
27291: PPUSH
27292: CALL_OW 109
27296: GO 27210
27298: POP
27299: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27300: LD_ADDR_VAR 0 3
27304: PUSH
27305: LD_VAR 0 1
27309: PPUSH
27310: EMPTY
27311: PPUSH
27312: CALL 11749 0 2
27316: PUSH
27317: LD_VAR 0 1
27321: PPUSH
27322: LD_INT 7
27324: PPUSH
27325: EMPTY
27326: PPUSH
27327: CALL 12151 0 3
27331: DIFF
27332: PUSH
27333: FOR_IN
27334: IFFALSE 27378
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27336: LD_VAR 0 3
27340: PPUSH
27341: CALL_OW 256
27345: PUSH
27346: LD_INT 650
27348: LESS
27349: PUSH
27350: LD_VAR 0 3
27354: PPUSH
27355: CALL_OW 110
27359: PUSH
27360: LD_INT 6
27362: EQUAL
27363: NOT
27364: AND
27365: IFFALSE 27376
// MCV_ToRepair ( i ) ;
27367: LD_VAR 0 3
27371: PPUSH
27372: CALL 27008 0 1
27376: GO 27333
27378: POP
27379: POP
// end ; end_of_file end_of_file
27380: LD_VAR 0 2
27384: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27385: LD_STRING SAILEvent [
27387: PUSH
27388: LD_VAR 0 1
27392: STR
27393: PUSH
27394: LD_STRING ]
27396: STR
27397: PPUSH
27398: CALL 7845 0 1
// if event = 101 and dialog_north then
27402: LD_VAR 0 1
27406: PUSH
27407: LD_INT 101
27409: EQUAL
27410: PUSH
27411: LD_EXP 7
27415: AND
27416: IFFALSE 27480
// begin dialog_north := false ;
27418: LD_ADDR_EXP 7
27422: PUSH
27423: LD_INT 0
27425: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27426: LD_EXP 4
27430: PPUSH
27431: LD_STRING DS1
27433: PUSH
27434: LD_STRING DS2
27436: PUSH
27437: LD_STRING DS3
27439: PUSH
27440: LD_STRING DS6
27442: PUSH
27443: EMPTY
27444: LIST
27445: LIST
27446: LIST
27447: LIST
27448: PUSH
27449: LD_INT 1
27451: PPUSH
27452: LD_INT 4
27454: PPUSH
27455: CALL_OW 12
27459: ARRAY
27460: PPUSH
27461: CALL_OW 94
// Wait ( 4 4$00 ) ;
27465: LD_INT 8400
27467: PPUSH
27468: CALL_OW 67
// dialog_north := true ;
27472: LD_ADDR_EXP 7
27476: PUSH
27477: LD_INT 1
27479: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27480: LD_VAR 0 1
27484: PUSH
27485: LD_INT 102
27487: EQUAL
27488: PUSH
27489: LD_EXP 8
27493: AND
27494: IFFALSE 27554
// begin dialog_south := false ;
27496: LD_ADDR_EXP 8
27500: PUSH
27501: LD_INT 0
27503: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27504: LD_EXP 3
27508: PPUSH
27509: LD_STRING DJ1
27511: PUSH
27512: LD_STRING DJ4
27514: PUSH
27515: LD_STRING DJ6
27517: PUSH
27518: EMPTY
27519: LIST
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 1
27525: PPUSH
27526: LD_INT 3
27528: PPUSH
27529: CALL_OW 12
27533: ARRAY
27534: PPUSH
27535: CALL_OW 94
// Wait ( 4 4$00 ) ;
27539: LD_INT 8400
27541: PPUSH
27542: CALL_OW 67
// dialog_south := true ;
27546: LD_ADDR_EXP 8
27550: PUSH
27551: LD_INT 1
27553: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27554: LD_VAR 0 1
27558: PUSH
27559: LD_INT 104
27561: EQUAL
27562: PUSH
27563: LD_EXP 9
27567: AND
27568: IFFALSE 27590
// begin dialog_popov := false ;
27570: LD_ADDR_EXP 9
27574: PUSH
27575: LD_INT 0
27577: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27578: LD_EXP 26
27582: PPUSH
27583: LD_STRING DR4
27585: PPUSH
27586: CALL_OW 94
// end ; end ;
27590: PPOPN 1
27592: END
// on BuildingStarted ( b , unit ) do var side , i ;
27593: LD_INT 0
27595: PPUSH
27596: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27597: LD_EXP 41
27601: PUSH
27602: LD_VAR 0 1
27606: PPUSH
27607: CALL_OW 255
27611: ARRAY
27612: IFFALSE 27790
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27614: LD_STRING BuildingStarted [side: 
27616: PUSH
27617: LD_VAR 0 1
27621: PPUSH
27622: CALL_OW 255
27626: STR
27627: PUSH
27628: LD_STRING ; btype: 
27630: STR
27631: PUSH
27632: LD_VAR 0 1
27636: PPUSH
27637: CALL_OW 266
27641: STR
27642: PUSH
27643: LD_STRING ; unit: 
27645: STR
27646: PUSH
27647: LD_VAR 0 2
27651: STR
27652: PUSH
27653: LD_STRING ]
27655: STR
27656: PPUSH
27657: CALL 7845 0 1
// side := GetSide ( b ) ;
27661: LD_ADDR_VAR 0 3
27665: PUSH
27666: LD_VAR 0 1
27670: PPUSH
27671: CALL_OW 255
27675: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27676: LD_VAR 0 3
27680: PPUSH
27681: LD_INT 21
27683: PUSH
27684: LD_INT 3
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PPUSH
27691: CALL 11448 0 2
27695: PUSH
27696: LD_INT 1
27698: EQUAL
27699: IFFALSE 27790
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27701: LD_ADDR_VAR 0 4
27705: PUSH
27706: LD_VAR 0 3
27710: PPUSH
27711: LD_INT 21
27713: PUSH
27714: LD_INT 1
27716: PUSH
27717: EMPTY
27718: LIST
27719: LIST
27720: PPUSH
27721: CALL 11448 0 2
27725: PUSH
27726: LD_VAR 0 3
27730: PPUSH
27731: LD_INT 2
27733: PPUSH
27734: EMPTY
27735: PPUSH
27736: CALL 11531 0 3
27740: DIFF
27741: PUSH
27742: FOR_IN
27743: IFFALSE 27788
// if not HasTask ( i ) then
27745: LD_VAR 0 4
27749: PPUSH
27750: CALL_OW 314
27754: NOT
27755: IFFALSE 27786
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27757: LD_VAR 0 4
27761: PPUSH
27762: LD_VAR 0 1
27766: PPUSH
27767: CALL_OW 250
27771: PPUSH
27772: LD_VAR 0 1
27776: PPUSH
27777: CALL_OW 251
27781: PPUSH
27782: CALL_OW 111
27786: GO 27742
27788: POP
27789: POP
// end ;
27790: PPOPN 4
27792: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27793: LD_EXP 41
27797: PUSH
27798: LD_VAR 0 1
27802: PPUSH
27803: CALL_OW 255
27807: ARRAY
27808: IFFALSE 28177
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27810: LD_STRING BuildingComplete [side: 
27812: PUSH
27813: LD_VAR 0 1
27817: PPUSH
27818: CALL_OW 255
27822: STR
27823: PUSH
27824: LD_STRING ; btype: 
27826: STR
27827: PUSH
27828: LD_VAR 0 1
27832: PPUSH
27833: CALL_OW 266
27837: STR
27838: PUSH
27839: LD_STRING ]
27841: STR
27842: PPUSH
27843: CALL 7845 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27847: LD_ADDR_EXP 48
27851: PUSH
27852: LD_EXP 48
27856: PPUSH
27857: LD_VAR 0 1
27861: PPUSH
27862: CALL_OW 255
27866: PPUSH
27867: LD_VAR 0 1
27871: PPUSH
27872: CALL_OW 266
27876: PPUSH
27877: LD_VAR 0 1
27881: PPUSH
27882: CALL_OW 250
27886: PUSH
27887: LD_VAR 0 1
27891: PPUSH
27892: CALL_OW 251
27896: PUSH
27897: LD_VAR 0 1
27901: PPUSH
27902: CALL_OW 254
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: LIST
27911: PPUSH
27912: CALL 42253 0 4
27916: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27917: LD_VAR 0 1
27921: PPUSH
27922: CALL_OW 266
27926: PUSH
27927: LD_INT 6
27929: EQUAL
27930: IFFALSE 27964
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27932: LD_ADDR_EXP 42
27936: PUSH
27937: LD_EXP 42
27941: PPUSH
27942: LD_VAR 0 1
27946: PPUSH
27947: CALL_OW 255
27951: PPUSH
27952: LD_VAR 0 1
27956: PPUSH
27957: EMPTY
27958: PPUSH
27959: CALL 42162 0 4
27963: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27964: LD_VAR 0 1
27968: PPUSH
27969: CALL_OW 266
27973: PUSH
27974: LD_INT 0
27976: EQUAL
27977: IFFALSE 28087
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
27979: LD_ADDR_EXP 50
27983: PUSH
27984: LD_EXP 50
27988: PPUSH
27989: LD_VAR 0 1
27993: PPUSH
27994: CALL_OW 255
27998: PPUSH
27999: LD_INT 0
28001: PPUSH
28002: EMPTY
28003: PPUSH
28004: CALL 42162 0 4
28008: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28009: LD_VAR 0 1
28013: PPUSH
28014: CALL_OW 274
28018: PPUSH
28019: LD_INT 1
28021: PPUSH
28022: LD_EXP 74
28026: PUSH
28027: LD_INT 1
28029: ARRAY
28030: PPUSH
28031: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28035: LD_VAR 0 1
28039: PPUSH
28040: CALL_OW 274
28044: PPUSH
28045: LD_INT 2
28047: PPUSH
28048: LD_EXP 74
28052: PUSH
28053: LD_INT 2
28055: ARRAY
28056: PPUSH
28057: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28061: LD_VAR 0 1
28065: PPUSH
28066: CALL_OW 274
28070: PPUSH
28071: LD_INT 3
28073: PPUSH
28074: LD_EXP 74
28078: PUSH
28079: LD_INT 3
28081: ARRAY
28082: PPUSH
28083: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28087: LD_VAR 0 1
28091: PPUSH
28092: CALL_OW 266
28096: PUSH
28097: LD_INT 2
28099: EQUAL
28100: IFFALSE 28132
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28102: LD_ADDR_EXP 50
28106: PUSH
28107: LD_EXP 50
28111: PPUSH
28112: LD_VAR 0 1
28116: PPUSH
28117: CALL_OW 255
28121: PPUSH
28122: LD_INT 2
28124: PPUSH
28125: EMPTY
28126: PPUSH
28127: CALL 42162 0 4
28131: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28132: LD_VAR 0 1
28136: PPUSH
28137: CALL_OW 266
28141: PUSH
28142: LD_INT 4
28144: EQUAL
28145: IFFALSE 28177
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28147: LD_ADDR_EXP 50
28151: PUSH
28152: LD_EXP 50
28156: PPUSH
28157: LD_VAR 0 1
28161: PPUSH
28162: CALL_OW 255
28166: PPUSH
28167: LD_INT 4
28169: PPUSH
28170: EMPTY
28171: PPUSH
28172: CALL 42162 0 4
28176: ST_TO_ADDR
// end ;
28177: PPOPN 1
28179: END
// on ResearchComplete ( tech , lab ) do var i ;
28180: LD_INT 0
28182: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28183: LD_EXP 41
28187: PUSH
28188: LD_VAR 0 2
28192: PPUSH
28193: CALL_OW 255
28197: ARRAY
28198: IFFALSE 28482
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28200: LD_STRING ResearchComplete [side: 
28202: PUSH
28203: LD_VAR 0 2
28207: PPUSH
28208: CALL_OW 255
28212: PPUSH
28213: CALL_OW 255
28217: STR
28218: PUSH
28219: LD_STRING ; tech:
28221: STR
28222: PUSH
28223: LD_VAR 0 1
28227: STR
28228: PUSH
28229: LD_STRING ]
28231: STR
28232: PPUSH
28233: CALL 7845 0 1
// for i = 1 to MREG_ToRes do
28237: LD_ADDR_VAR 0 3
28241: PUSH
28242: DOUBLE
28243: LD_INT 1
28245: DEC
28246: ST_TO_ADDR
28247: LD_EXP 52
28251: PUSH
28252: FOR_TO
28253: IFFALSE 28340
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28255: LD_EXP 52
28259: PUSH
28260: LD_VAR 0 3
28264: ARRAY
28265: PUSH
28266: LD_INT 1
28268: ARRAY
28269: PUSH
28270: LD_VAR 0 2
28274: PPUSH
28275: CALL_OW 255
28279: EQUAL
28280: PUSH
28281: LD_EXP 52
28285: PUSH
28286: LD_VAR 0 3
28290: ARRAY
28291: PUSH
28292: LD_INT 2
28294: ARRAY
28295: PUSH
28296: LD_VAR 0 1
28300: EQUAL
28301: AND
28302: IFFALSE 28338
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28304: LD_ADDR_EXP 52
28308: PUSH
28309: LD_EXP 52
28313: PPUSH
28314: LD_VAR 0 2
28318: PPUSH
28319: CALL_OW 255
28323: PPUSH
28324: LD_VAR 0 1
28328: PPUSH
28329: EMPTY
28330: PPUSH
28331: CALL 42253 0 4
28335: ST_TO_ADDR
// break ;
28336: GO 28340
// end ;
28338: GO 28252
28340: POP
28341: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28342: LD_VAR 0 1
28346: PUSH
28347: LD_INT 2
28349: PUSH
28350: LD_INT 11
28352: PUSH
28353: LD_INT 4
28355: PUSH
28356: LD_INT 3
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: LIST
28363: LIST
28364: IN
28365: IFFALSE 28482
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28367: LD_ADDR_VAR 0 3
28371: PUSH
28372: LD_VAR 0 2
28376: PPUSH
28377: CALL_OW 255
28381: PPUSH
28382: LD_INT 16
28384: PPUSH
28385: LD_INT 25
28387: PUSH
28388: LD_INT 4
28390: PUSH
28391: EMPTY
28392: LIST
28393: LIST
28394: PPUSH
28395: CALL 12151 0 3
28399: ST_TO_ADDR
// if i then
28400: LD_VAR 0 3
28404: IFFALSE 28422
// SetTag ( i [ 1 ] , 0 ) ;
28406: LD_VAR 0 3
28410: PUSH
28411: LD_INT 1
28413: ARRAY
28414: PPUSH
28415: LD_INT 0
28417: PPUSH
28418: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28422: LD_ADDR_VAR 0 3
28426: PUSH
28427: LD_VAR 0 2
28431: PPUSH
28432: CALL_OW 255
28436: PPUSH
28437: LD_INT 171
28439: PPUSH
28440: EMPTY
28441: PPUSH
28442: CALL 12151 0 3
28446: ST_TO_ADDR
// if i then
28447: LD_VAR 0 3
28451: IFFALSE 28482
// begin SetTag ( i [ 1 ] , 0 ) ;
28453: LD_VAR 0 3
28457: PUSH
28458: LD_INT 1
28460: ARRAY
28461: PPUSH
28462: LD_INT 0
28464: PPUSH
28465: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28469: LD_VAR 0 3
28473: PUSH
28474: LD_INT 1
28476: ARRAY
28477: PPUSH
28478: CALL_OW 122
// end ; end ; end ;
28482: PPOPN 3
28484: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28485: LD_INT 0
28487: PPUSH
28488: PPUSH
28489: PPUSH
28490: PPUSH
28491: PPUSH
28492: PPUSH
28493: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28494: LD_EXP 41
28498: PUSH
28499: LD_VAR 0 2
28503: PPUSH
28504: CALL_OW 255
28508: ARRAY
28509: IFFALSE 29236
// begin side := GetSide ( veh ) ;
28511: LD_ADDR_VAR 0 4
28515: PUSH
28516: LD_VAR 0 1
28520: PPUSH
28521: CALL_OW 255
28525: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28526: LD_ADDR_VAR 0 6
28530: PUSH
28531: LD_VAR 0 1
28535: PPUSH
28536: CALL_OW 265
28540: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28541: LD_ADDR_VAR 0 7
28545: PUSH
28546: LD_VAR 0 1
28550: PPUSH
28551: CALL_OW 262
28555: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28556: LD_ADDR_VAR 0 8
28560: PUSH
28561: LD_VAR 0 1
28565: PPUSH
28566: CALL_OW 263
28570: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28571: LD_ADDR_VAR 0 9
28575: PUSH
28576: LD_VAR 0 1
28580: PPUSH
28581: CALL_OW 264
28585: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28586: LD_STRING VehicleConstructed [side: 
28588: PUSH
28589: LD_VAR 0 4
28593: STR
28594: PUSH
28595: LD_STRING ; id:
28597: STR
28598: PUSH
28599: LD_VAR 0 1
28603: STR
28604: PUSH
28605: LD_STRING ; components: [
28607: STR
28608: PUSH
28609: LD_VAR 0 6
28613: STR
28614: PUSH
28615: LD_STRING , 
28617: STR
28618: PUSH
28619: LD_VAR 0 7
28623: STR
28624: PUSH
28625: LD_STRING , 
28627: STR
28628: PUSH
28629: LD_VAR 0 8
28633: STR
28634: PUSH
28635: LD_STRING , 
28637: STR
28638: PUSH
28639: LD_VAR 0 9
28643: STR
28644: PUSH
28645: LD_STRING ]]
28647: STR
28648: PPUSH
28649: CALL 7845 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28653: LD_VAR 0 1
28657: PPUSH
28658: CALL_OW 264
28662: PUSH
28663: LD_INT 13
28665: PUSH
28666: LD_INT 12
28668: PUSH
28669: LD_INT 14
28671: PUSH
28672: LD_INT 51
28674: PUSH
28675: LD_INT 53
28677: PUSH
28678: LD_INT 52
28680: PUSH
28681: LD_INT 32
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: LIST
28688: LIST
28689: LIST
28690: LIST
28691: LIST
28692: IN
28693: NOT
28694: IFFALSE 28736
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28696: LD_ADDR_EXP 61
28700: PUSH
28701: LD_EXP 61
28705: PPUSH
28706: LD_VAR 0 4
28710: PPUSH
28711: LD_EXP 61
28715: PUSH
28716: LD_VAR 0 4
28720: ARRAY
28721: PUSH
28722: LD_INT 1
28724: PLUS
28725: PPUSH
28726: LD_VAR 0 1
28730: PPUSH
28731: CALL 30882 0 4
28735: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28736: LD_VAR 0 1
28740: PPUSH
28741: CALL_OW 264
28745: PUSH
28746: LD_INT 31
28748: EQUAL
28749: IFFALSE 28768
// SetTag ( GetDriver ( veh ) , 9 ) ;
28751: LD_VAR 0 1
28755: PPUSH
28756: CALL 31576 0 1
28760: PPUSH
28761: LD_INT 9
28763: PPUSH
28764: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28768: LD_VAR 0 1
28772: PPUSH
28773: CALL_OW 264
28777: PUSH
28778: LD_INT 14
28780: PUSH
28781: LD_INT 53
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: IN
28788: IFFALSE 28825
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28790: LD_ADDR_EXP 44
28794: PUSH
28795: LD_EXP 44
28799: PPUSH
28800: LD_VAR 0 1
28804: PPUSH
28805: CALL_OW 255
28809: PPUSH
28810: LD_INT 2
28812: PPUSH
28813: LD_VAR 0 1
28817: PPUSH
28818: CALL 30882 0 4
28822: ST_TO_ADDR
// exit ;
28823: GO 29236
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28825: LD_VAR 0 1
28829: PPUSH
28830: CALL_OW 265
28834: PUSH
28835: LD_EXP 68
28839: PUSH
28840: LD_VAR 0 4
28844: ARRAY
28845: PUSH
28846: LD_INT 1
28848: ARRAY
28849: IN
28850: PUSH
28851: LD_VAR 0 1
28855: PPUSH
28856: CALL_OW 262
28860: PUSH
28861: LD_EXP 68
28865: PUSH
28866: LD_VAR 0 4
28870: ARRAY
28871: PUSH
28872: LD_INT 1
28874: ARRAY
28875: IN
28876: AND
28877: PUSH
28878: LD_VAR 0 1
28882: PPUSH
28883: CALL_OW 263
28887: PUSH
28888: LD_EXP 68
28892: PUSH
28893: LD_VAR 0 4
28897: ARRAY
28898: PUSH
28899: LD_INT 1
28901: ARRAY
28902: IN
28903: AND
28904: PUSH
28905: LD_VAR 0 1
28909: PPUSH
28910: CALL_OW 264
28914: PUSH
28915: LD_EXP 68
28919: PUSH
28920: LD_VAR 0 4
28924: ARRAY
28925: PUSH
28926: LD_INT 1
28928: ARRAY
28929: IN
28930: AND
28931: IFFALSE 28975
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28933: LD_ADDR_EXP 69
28937: PUSH
28938: LD_EXP 69
28942: PPUSH
28943: LD_VAR 0 4
28947: PPUSH
28948: LD_EXP 69
28952: PUSH
28953: LD_VAR 0 4
28957: ARRAY
28958: PUSH
28959: LD_INT 1
28961: PLUS
28962: PPUSH
28963: LD_VAR 0 1
28967: PPUSH
28968: CALL 30882 0 4
28972: ST_TO_ADDR
// exit ;
28973: GO 29236
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
28975: LD_VAR 0 6
28979: PUSH
28980: LD_EXP 71
28984: PUSH
28985: LD_VAR 0 4
28989: ARRAY
28990: PUSH
28991: LD_INT 1
28993: ARRAY
28994: EQUAL
28995: PUSH
28996: LD_VAR 0 7
29000: PUSH
29001: LD_EXP 71
29005: PUSH
29006: LD_VAR 0 4
29010: ARRAY
29011: PUSH
29012: LD_INT 2
29014: ARRAY
29015: EQUAL
29016: AND
29017: PUSH
29018: LD_VAR 0 8
29022: PUSH
29023: LD_EXP 71
29027: PUSH
29028: LD_VAR 0 4
29032: ARRAY
29033: PUSH
29034: LD_INT 3
29036: ARRAY
29037: EQUAL
29038: AND
29039: PUSH
29040: LD_VAR 0 9
29044: PUSH
29045: LD_EXP 71
29049: PUSH
29050: LD_VAR 0 4
29054: ARRAY
29055: PUSH
29056: LD_INT 4
29058: ARRAY
29059: EQUAL
29060: AND
29061: IFFALSE 29217
// begin tmp := MREG_ToAttack [ side ] ;
29063: LD_ADDR_VAR 0 5
29067: PUSH
29068: LD_EXP 71
29072: PUSH
29073: LD_VAR 0 4
29077: ARRAY
29078: ST_TO_ADDR
// for i = 1 to 4 do
29079: LD_ADDR_VAR 0 3
29083: PUSH
29084: DOUBLE
29085: LD_INT 1
29087: DEC
29088: ST_TO_ADDR
29089: LD_INT 4
29091: PUSH
29092: FOR_TO
29093: IFFALSE 29115
// tmp := Delete ( tmp , 1 ) ;
29095: LD_ADDR_VAR 0 5
29099: PUSH
29100: LD_VAR 0 5
29104: PPUSH
29105: LD_INT 1
29107: PPUSH
29108: CALL_OW 3
29112: ST_TO_ADDR
29113: GO 29092
29115: POP
29116: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29117: LD_ADDR_EXP 71
29121: PUSH
29122: LD_EXP 71
29126: PPUSH
29127: LD_VAR 0 4
29131: PPUSH
29132: LD_VAR 0 5
29136: PPUSH
29137: CALL_OW 1
29141: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29142: LD_ADDR_EXP 73
29146: PUSH
29147: LD_EXP 73
29151: PPUSH
29152: LD_VAR 0 4
29156: PPUSH
29157: LD_EXP 73
29161: PUSH
29162: LD_VAR 0 4
29166: ARRAY
29167: PUSH
29168: LD_INT 1
29170: PLUS
29171: PPUSH
29172: LD_VAR 0 1
29176: PPUSH
29177: CALL 30882 0 4
29181: ST_TO_ADDR
// if tmp = 0 then
29182: LD_VAR 0 5
29186: PUSH
29187: LD_INT 0
29189: EQUAL
29190: IFFALSE 29215
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29192: LD_ADDR_EXP 71
29196: PUSH
29197: LD_EXP 71
29201: PPUSH
29202: LD_VAR 0 4
29206: PPUSH
29207: LD_INT 0
29209: PPUSH
29210: CALL_OW 1
29214: ST_TO_ADDR
// exit ;
29215: GO 29236
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29217: LD_VAR 0 1
29221: PPUSH
29222: CALL_OW 255
29226: PPUSH
29227: LD_VAR 0 1
29231: PPUSH
29232: CALL 25609 0 2
// end ;
29236: PPOPN 9
29238: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29239: LD_EXP 41
29243: PUSH
29244: LD_VAR 0 2
29248: PPUSH
29249: CALL_OW 255
29253: ARRAY
29254: IFFALSE 29486
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29256: LD_STRING ApemanTamed [side: 
29258: PUSH
29259: LD_VAR 0 2
29263: PPUSH
29264: CALL_OW 255
29268: STR
29269: PUSH
29270: LD_STRING ; sci: 
29272: STR
29273: PUSH
29274: LD_VAR 0 2
29278: STR
29279: PUSH
29280: LD_STRING ; ape: 
29282: STR
29283: PUSH
29284: LD_VAR 0 1
29288: STR
29289: PUSH
29290: LD_STRING ]
29292: STR
29293: PPUSH
29294: CALL 7845 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29298: LD_INT 11
29300: PPUSH
29301: LD_VAR 0 2
29305: PPUSH
29306: CALL_OW 255
29310: PPUSH
29311: CALL_OW 321
29315: PUSH
29316: LD_INT 2
29318: EQUAL
29319: NOT
29320: PUSH
29321: LD_INT 2
29323: PPUSH
29324: LD_VAR 0 2
29328: PPUSH
29329: CALL_OW 255
29333: PPUSH
29334: CALL_OW 321
29338: PUSH
29339: LD_INT 2
29341: EQUAL
29342: NOT
29343: OR
29344: PUSH
29345: LD_VAR 0 2
29349: PPUSH
29350: CALL_OW 255
29354: PPUSH
29355: LD_INT 171
29357: PPUSH
29358: EMPTY
29359: PPUSH
29360: CALL 12151 0 3
29364: PUSH
29365: LD_INT 0
29367: EQUAL
29368: AND
29369: IFFALSE 29383
// begin SetTag ( ape , 171 ) ;
29371: LD_VAR 0 1
29375: PPUSH
29376: LD_INT 171
29378: PPUSH
29379: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29383: LD_VAR 0 2
29387: PPUSH
29388: CALL_OW 255
29392: PPUSH
29393: LD_INT 30
29395: PUSH
29396: LD_INT 1
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PPUSH
29403: CALL 11448 0 2
29407: IFFALSE 29486
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29409: LD_VAR 0 1
29413: PPUSH
29414: LD_VAR 0 2
29418: PPUSH
29419: CALL_OW 255
29423: PPUSH
29424: LD_INT 30
29426: PUSH
29427: LD_INT 1
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PPUSH
29434: CALL 11448 0 2
29438: PUSH
29439: LD_INT 1
29441: ARRAY
29442: PPUSH
29443: CALL_OW 250
29447: PPUSH
29448: LD_VAR 0 2
29452: PPUSH
29453: CALL_OW 255
29457: PPUSH
29458: LD_INT 30
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PPUSH
29468: CALL 11448 0 2
29472: PUSH
29473: LD_INT 1
29475: ARRAY
29476: PPUSH
29477: CALL_OW 251
29481: PPUSH
29482: CALL_OW 111
// end ;
29486: PPOPN 2
29488: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29489: LD_EXP 41
29493: PUSH
29494: LD_VAR 0 1
29498: PPUSH
29499: CALL_OW 255
29503: ARRAY
29504: IFFALSE 29782
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29506: LD_VAR 0 2
29510: PUSH
29511: LD_VAR 0 2
29515: PPUSH
29516: CALL_OW 255
29520: PPUSH
29521: CALL 11861 0 1
29525: IN
29526: IFFALSE 29667
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29528: LD_VAR 0 1
29532: PPUSH
29533: CALL_OW 266
29537: PUSH
29538: LD_INT 0
29540: PUSH
29541: LD_INT 1
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: IN
29548: IFFALSE 29578
// begin Wait ( 0 0$0.3 ) ;
29550: LD_INT 10
29552: PPUSH
29553: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29557: LD_VAR 0 2
29561: PPUSH
29562: LD_INT 16
29564: PPUSH
29565: CALL_OW 336
// ComExitBuilding ( un ) ;
29569: LD_VAR 0 2
29573: PPUSH
29574: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29578: LD_VAR 0 1
29582: PPUSH
29583: CALL_OW 266
29587: PUSH
29588: LD_INT 4
29590: PUSH
29591: LD_INT 5
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: IN
29598: IFFALSE 29667
// begin Wait ( 0 0$0.3 ) ;
29600: LD_INT 10
29602: PPUSH
29603: CALL_OW 67
// if GetTag ( un ) = 0 then
29607: LD_VAR 0 2
29611: PPUSH
29612: CALL_OW 110
29616: PUSH
29617: LD_INT 0
29619: EQUAL
29620: IFFALSE 29636
// SetClass ( un , class_apeman_soldier ) else
29622: LD_VAR 0 2
29626: PPUSH
29627: LD_INT 15
29629: PPUSH
29630: CALL_OW 336
29634: GO 29667
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29636: LD_INT 3
29638: PPUSH
29639: LD_VAR 0 2
29643: PPUSH
29644: CALL_OW 255
29648: PPUSH
29649: CALL_OW 321
29653: IFFALSE 29667
// SetClass ( un , class_apeman_kamikaze ) ;
29655: LD_VAR 0 2
29659: PPUSH
29660: LD_INT 17
29662: PPUSH
29663: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29667: LD_VAR 0 1
29671: PPUSH
29672: CALL_OW 266
29676: PUSH
29677: LD_INT 32
29679: EQUAL
29680: IFFALSE 29782
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29682: LD_ADDR_EXP 70
29686: PUSH
29687: LD_EXP 70
29691: PPUSH
29692: LD_VAR 0 1
29696: PPUSH
29697: CALL_OW 255
29701: PPUSH
29702: LD_EXP 70
29706: PUSH
29707: LD_VAR 0 1
29711: PPUSH
29712: CALL_OW 255
29716: ARRAY
29717: PUSH
29718: LD_INT 1
29720: PLUS
29721: PPUSH
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL 30882 0 4
29731: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29732: LD_ADDR_EXP 70
29736: PUSH
29737: LD_EXP 70
29741: PPUSH
29742: LD_VAR 0 1
29746: PPUSH
29747: CALL_OW 255
29751: PPUSH
29752: LD_EXP 70
29756: PUSH
29757: LD_VAR 0 1
29761: PPUSH
29762: CALL_OW 255
29766: ARRAY
29767: PUSH
29768: LD_INT 1
29770: PLUS
29771: PPUSH
29772: LD_VAR 0 2
29776: PPUSH
29777: CALL 30882 0 4
29781: ST_TO_ADDR
// end ; end ;
29782: PPOPN 2
29784: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29785: LD_VAR 0 1
29789: PUSH
29790: LD_INT 22
29792: PUSH
29793: LD_INT 1
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 21
29802: PUSH
29803: LD_INT 3
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: PPUSH
29814: CALL_OW 69
29818: IN
29819: PUSH
29820: LD_EXP 15
29824: NOT
29825: AND
29826: IFFALSE 29889
// begin alfa_north_triggered := true ;
29828: LD_ADDR_EXP 15
29832: PUSH
29833: LD_INT 1
29835: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29836: LD_EXP 4
29840: PPUSH
29841: LD_STRING DS4
29843: PPUSH
29844: CALL_OW 94
// Wait ( 1 1$25 ) ;
29848: LD_INT 2975
29850: PPUSH
29851: CALL_OW 67
// if not isTest then
29855: LD_EXP 1
29859: NOT
29860: IFFALSE 29889
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29862: LD_INT 20
29864: PPUSH
29865: LD_INT 5
29867: PUSH
29868: LD_INT 6
29870: PUSH
29871: LD_INT 7
29873: PUSH
29874: EMPTY
29875: LIST
29876: LIST
29877: LIST
29878: PUSH
29879: LD_OWVAR 67
29883: ARRAY
29884: PPUSH
29885: CALL 7003 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
29889: LD_VAR 0 1
29893: PUSH
29894: LD_INT 22
29896: PUSH
29897: LD_INT 4
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 21
29906: PUSH
29907: LD_INT 3
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PPUSH
29918: CALL_OW 69
29922: IN
29923: PUSH
29924: LD_EXP 16
29928: NOT
29929: AND
29930: IFFALSE 29993
// begin alfa_south_triggered := true ;
29932: LD_ADDR_EXP 16
29936: PUSH
29937: LD_INT 1
29939: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
29940: LD_EXP 3
29944: PPUSH
29945: LD_STRING DJ3
29947: PPUSH
29948: CALL_OW 94
// Wait ( 0 0$45 ) ;
29952: LD_INT 1575
29954: PPUSH
29955: CALL_OW 67
// if not isTest then
29959: LD_EXP 1
29963: NOT
29964: IFFALSE 29993
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29966: LD_INT 20
29968: PPUSH
29969: LD_INT 5
29971: PUSH
29972: LD_INT 6
29974: PUSH
29975: LD_INT 7
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: LIST
29982: PUSH
29983: LD_OWVAR 67
29987: ARRAY
29988: PPUSH
29989: CALL 7003 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
29993: LD_VAR 0 1
29997: PPUSH
29998: CALL_OW 266
30002: PUSH
30003: LD_INT 1
30005: EQUAL
30006: PUSH
30007: LD_VAR 0 1
30011: PPUSH
30012: CALL_OW 255
30016: PUSH
30017: LD_INT 1
30019: PUSH
30020: LD_INT 4
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: IN
30027: AND
30028: IFFALSE 30037
// RaiseSailEvent ( 104 ) ;
30030: LD_INT 104
30032: PPUSH
30033: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30037: LD_EXP 41
30041: PUSH
30042: LD_VAR 0 1
30046: PPUSH
30047: CALL_OW 255
30051: ARRAY
30052: IFFALSE 30439
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30054: LD_STRING UnitDestroyed [side 
30056: PUSH
30057: LD_VAR 0 1
30061: PPUSH
30062: CALL_OW 255
30066: STR
30067: PUSH
30068: LD_STRING ; id: 
30070: STR
30071: PUSH
30072: LD_VAR 0 1
30076: STR
30077: PUSH
30078: LD_STRING ; type: 
30080: STR
30081: PUSH
30082: LD_VAR 0 1
30086: PPUSH
30087: CALL_OW 247
30091: STR
30092: PUSH
30093: LD_STRING ]
30095: STR
30096: PPUSH
30097: CALL 7845 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30101: LD_VAR 0 1
30105: PUSH
30106: LD_VAR 0 1
30110: PPUSH
30111: CALL_OW 255
30115: PPUSH
30116: LD_INT 21
30118: PUSH
30119: LD_INT 1
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PPUSH
30126: CALL 11448 0 2
30130: IN
30131: IFFALSE 30287
// begin if MCF_HasClass ( un ) then
30133: LD_VAR 0 1
30137: PPUSH
30138: CALL 14154 0 1
30142: IFFALSE 30287
// case MCF_HasClass ( un ) of 1 :
30144: LD_VAR 0 1
30148: PPUSH
30149: CALL 14154 0 1
30153: PUSH
30154: LD_INT 1
30156: DOUBLE
30157: EQUAL
30158: IFTRUE 30162
30160: GO 30187
30162: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30163: LD_VAR 0 1
30167: PPUSH
30168: CALL_OW 255
30172: PPUSH
30173: LD_STRING ToArm
30175: PPUSH
30176: LD_VAR 0 1
30180: PPUSH
30181: CALL 14327 0 3
30185: GO 30287
30187: LD_INT 2
30189: DOUBLE
30190: EQUAL
30191: IFTRUE 30195
30193: GO 30220
30195: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30196: LD_VAR 0 1
30200: PPUSH
30201: CALL_OW 255
30205: PPUSH
30206: LD_STRING ToDep
30208: PPUSH
30209: LD_VAR 0 1
30213: PPUSH
30214: CALL 14327 0 3
30218: GO 30287
30220: LD_INT 3
30222: DOUBLE
30223: EQUAL
30224: IFTRUE 30228
30226: GO 30253
30228: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30229: LD_VAR 0 1
30233: PPUSH
30234: CALL_OW 255
30238: PPUSH
30239: LD_STRING ToFac
30241: PPUSH
30242: LD_VAR 0 1
30246: PPUSH
30247: CALL 14327 0 3
30251: GO 30287
30253: LD_INT 4
30255: DOUBLE
30256: EQUAL
30257: IFTRUE 30261
30259: GO 30286
30261: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30262: LD_VAR 0 1
30266: PPUSH
30267: CALL_OW 255
30271: PPUSH
30272: LD_STRING ToLab
30274: PPUSH
30275: LD_VAR 0 1
30279: PPUSH
30280: CALL 14327 0 3
30284: GO 30287
30286: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30287: LD_VAR 0 1
30291: PUSH
30292: LD_EXP 69
30296: PUSH
30297: LD_VAR 0 1
30301: PPUSH
30302: CALL_OW 255
30306: ARRAY
30307: IN
30308: IFFALSE 30393
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30310: LD_ADDR_EXP 69
30314: PUSH
30315: LD_EXP 69
30319: PPUSH
30320: LD_VAR 0 1
30324: PPUSH
30325: LD_INT 0
30327: PPUSH
30328: CALL 31041 0 3
30332: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30333: LD_VAR 0 1
30337: PPUSH
30338: CALL_OW 255
30342: PPUSH
30343: LD_VAR 0 1
30347: PPUSH
30348: CALL_OW 265
30352: PUSH
30353: LD_VAR 0 1
30357: PPUSH
30358: CALL_OW 262
30362: PUSH
30363: LD_VAR 0 1
30367: PPUSH
30368: CALL_OW 263
30372: PUSH
30373: LD_VAR 0 1
30377: PPUSH
30378: CALL_OW 264
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: PPUSH
30389: CALL 20967 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30393: LD_VAR 0 1
30397: PUSH
30398: LD_EXP 73
30402: PUSH
30403: LD_VAR 0 1
30407: PPUSH
30408: CALL_OW 255
30412: ARRAY
30413: IN
30414: IFFALSE 30439
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30416: LD_ADDR_EXP 73
30420: PUSH
30421: LD_EXP 73
30425: PPUSH
30426: LD_VAR 0 1
30430: PPUSH
30431: LD_INT 0
30433: PPUSH
30434: CALL 31041 0 3
30438: ST_TO_ADDR
// end ; end ;
30439: PPOPN 1
30441: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30442: LD_EXP 41
30446: PUSH
30447: LD_VAR 0 2
30451: PPUSH
30452: CALL_OW 255
30456: ARRAY
30457: IFFALSE 30629
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30459: LD_VAR 0 2
30463: PUSH
30464: LD_EXP 70
30468: PUSH
30469: LD_VAR 0 2
30473: PPUSH
30474: CALL_OW 255
30478: ARRAY
30479: IN
30480: PUSH
30481: LD_VAR 0 1
30485: PPUSH
30486: CALL_OW 266
30490: PUSH
30491: LD_INT 32
30493: PUSH
30494: LD_INT 31
30496: PUSH
30497: EMPTY
30498: LIST
30499: LIST
30500: IN
30501: AND
30502: IFFALSE 30602
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30504: LD_ADDR_EXP 70
30508: PUSH
30509: LD_EXP 70
30513: PPUSH
30514: LD_VAR 0 1
30518: PPUSH
30519: LD_INT 0
30521: PPUSH
30522: CALL 31041 0 3
30526: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30527: LD_ADDR_EXP 70
30531: PUSH
30532: LD_EXP 70
30536: PPUSH
30537: LD_VAR 0 2
30541: PPUSH
30542: LD_INT 0
30544: PPUSH
30545: CALL 31041 0 3
30549: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30550: LD_EXP 70
30554: PUSH
30555: LD_VAR 0 2
30559: PPUSH
30560: CALL_OW 255
30564: ARRAY
30565: PUSH
30566: LD_STRING 
30568: EQUAL
30569: IFFALSE 30602
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30571: LD_ADDR_EXP 70
30575: PUSH
30576: LD_EXP 70
30580: PPUSH
30581: LD_VAR 0 2
30585: PPUSH
30586: CALL_OW 255
30590: PPUSH
30591: LD_INT 1
30593: PPUSH
30594: LD_INT 0
30596: PPUSH
30597: CALL 30882 0 4
30601: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30602: LD_VAR 0 1
30606: PPUSH
30607: CALL_OW 266
30611: PUSH
30612: LD_INT 36
30614: IN
30615: IFFALSE 30629
// SetTag ( un , 0 ) ;
30617: LD_VAR 0 2
30621: PPUSH
30622: LD_INT 0
30624: PPUSH
30625: CALL_OW 109
// end ;
30629: PPOPN 2
30631: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30632: LD_EXP 41
30636: PUSH
30637: LD_VAR 0 1
30641: PPUSH
30642: CALL_OW 255
30646: ARRAY
30647: IFFALSE 30673
// begin if GetControl ( un ) = control_remote then
30649: LD_VAR 0 1
30653: PPUSH
30654: CALL_OW 263
30658: PUSH
30659: LD_INT 2
30661: EQUAL
30662: IFFALSE 30673
// ComUnlink ( un ) ;
30664: LD_VAR 0 1
30668: PPUSH
30669: CALL_OW 136
// end ;
30673: PPOPN 1
30675: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30676: LD_EXP 41
30680: PUSH
30681: LD_VAR 0 1
30685: PPUSH
30686: CALL_OW 255
30690: ARRAY
30691: IFFALSE 30720
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30693: LD_VAR 0 2
30697: PPUSH
30698: CALL_OW 264
30702: PUSH
30703: LD_INT 31
30705: IN
30706: IFFALSE 30720
// SetTag ( driver , 0 ) ;
30708: LD_VAR 0 1
30712: PPUSH
30713: LD_INT 0
30715: PPUSH
30716: CALL_OW 109
// end ;
30720: PPOPN 4
30722: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30723: LD_INT 0
30725: PPUSH
30726: PPUSH
30727: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30728: LD_ADDR_VAR 0 3
30732: PUSH
30733: LD_VAR 0 1
30737: PPUSH
30738: CALL_OW 269
30742: ST_TO_ADDR
// x := GetX ( building ) ;
30743: LD_ADDR_VAR 0 4
30747: PUSH
30748: LD_VAR 0 1
30752: PPUSH
30753: CALL_OW 250
30757: ST_TO_ADDR
// y := GetY ( building ) ;
30758: LD_ADDR_VAR 0 5
30762: PUSH
30763: LD_VAR 0 1
30767: PPUSH
30768: CALL_OW 251
30772: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30773: LD_ADDR_EXP 45
30777: PUSH
30778: LD_EXP 45
30782: PPUSH
30783: LD_VAR 0 1
30787: PPUSH
30788: CALL_OW 255
30792: PPUSH
30793: LD_VAR 0 3
30797: PPUSH
30798: LD_VAR 0 4
30802: PUSH
30803: LD_VAR 0 5
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PPUSH
30812: CALL 42253 0 4
30816: ST_TO_ADDR
// end ;
30817: PPOPN 5
30819: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30820: LD_VAR 0 1
30824: PUSH
30825: LD_EXP 32
30829: IN
30830: NOT
30831: IFFALSE 30879
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30833: LD_ADDR_EXP 32
30837: PUSH
30838: LD_EXP 32
30842: PPUSH
30843: LD_EXP 32
30847: PUSH
30848: LD_INT 1
30850: PLUS
30851: PPUSH
30852: LD_VAR 0 1
30856: PPUSH
30857: CALL_OW 2
30861: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30862: LD_STRING DestinationUnrechable. [unit: 
30864: PUSH
30865: LD_VAR 0 1
30869: STR
30870: PUSH
30871: LD_STRING ]
30873: STR
30874: PPUSH
30875: CALL 7845 0 1
// end ; end ; end_of_file
30879: PPOPN 1
30881: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
30882: LD_INT 0
30884: PPUSH
30885: PPUSH
30886: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
30887: LD_ADDR_VAR 0 7
30891: PUSH
30892: LD_VAR 0 1
30896: PUSH
30897: LD_VAR 0 2
30901: ARRAY
30902: PPUSH
30903: LD_VAR 0 3
30907: PPUSH
30908: LD_VAR 0 4
30912: PPUSH
30913: CALL_OW 1
30917: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
30918: LD_ADDR_VAR 0 1
30922: PUSH
30923: LD_VAR 0 1
30927: PPUSH
30928: LD_VAR 0 2
30932: PPUSH
30933: LD_VAR 0 7
30937: PPUSH
30938: CALL_OW 1
30942: ST_TO_ADDR
// result := tab ;
30943: LD_ADDR_VAR 0 5
30947: PUSH
30948: LD_VAR 0 1
30952: ST_TO_ADDR
// end ;
30953: LD_VAR 0 5
30957: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
30958: LD_INT 0
30960: PPUSH
30961: PPUSH
30962: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
30963: LD_ADDR_VAR 0 5
30967: PUSH
30968: LD_VAR 0 1
30972: PUSH
30973: LD_VAR 0 2
30977: PUSH
30978: LD_INT 1
30980: ARRAY
30981: ARRAY
30982: PPUSH
30983: LD_VAR 0 2
30987: PUSH
30988: LD_INT 2
30990: ARRAY
30991: PPUSH
30992: CALL_OW 3
30996: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
30997: LD_ADDR_VAR 0 1
31001: PUSH
31002: LD_VAR 0 1
31006: PPUSH
31007: LD_VAR 0 2
31011: PUSH
31012: LD_INT 1
31014: ARRAY
31015: PPUSH
31016: LD_VAR 0 5
31020: PPUSH
31021: CALL_OW 1
31025: ST_TO_ADDR
// result := tab ;
31026: LD_ADDR_VAR 0 3
31030: PUSH
31031: LD_VAR 0 1
31035: ST_TO_ADDR
// end ;
31036: LD_VAR 0 3
31040: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31041: LD_INT 0
31043: PPUSH
31044: PPUSH
31045: PPUSH
31046: PPUSH
// i := 1 ;
31047: LD_ADDR_VAR 0 5
31051: PUSH
31052: LD_INT 1
31054: ST_TO_ADDR
// while ( i <= tab ) do
31055: LD_VAR 0 5
31059: PUSH
31060: LD_VAR 0 1
31064: LESSEQUAL
31065: IFFALSE 31440
// begin if not tab [ i ] then
31067: LD_VAR 0 1
31071: PUSH
31072: LD_VAR 0 5
31076: ARRAY
31077: NOT
31078: IFFALSE 31082
// break ;
31080: GO 31440
// if value in tab then
31082: LD_VAR 0 2
31086: PUSH
31087: LD_VAR 0 1
31091: IN
31092: IFFALSE 31205
// begin if not mode then
31094: LD_VAR 0 3
31098: NOT
31099: IFFALSE 31119
// tab := tab diff value else
31101: LD_ADDR_VAR 0 1
31105: PUSH
31106: LD_VAR 0 1
31110: PUSH
31111: LD_VAR 0 2
31115: DIFF
31116: ST_TO_ADDR
31117: GO 31181
// for j = 1 to tab do
31119: LD_ADDR_VAR 0 6
31123: PUSH
31124: DOUBLE
31125: LD_INT 1
31127: DEC
31128: ST_TO_ADDR
31129: LD_VAR 0 1
31133: PUSH
31134: FOR_TO
31135: IFFALSE 31179
// if tab [ j ] = value then
31137: LD_VAR 0 1
31141: PUSH
31142: LD_VAR 0 6
31146: ARRAY
31147: PUSH
31148: LD_VAR 0 2
31152: EQUAL
31153: IFFALSE 31177
// begin tab := Delete ( tab , j ) ;
31155: LD_ADDR_VAR 0 1
31159: PUSH
31160: LD_VAR 0 1
31164: PPUSH
31165: LD_VAR 0 6
31169: PPUSH
31170: CALL_OW 3
31174: ST_TO_ADDR
// break ;
31175: GO 31179
// end ;
31177: GO 31134
31179: POP
31180: POP
// i := i - 1 ;
31181: LD_ADDR_VAR 0 5
31185: PUSH
31186: LD_VAR 0 5
31190: PUSH
31191: LD_INT 1
31193: MINUS
31194: ST_TO_ADDR
// if mode then
31195: LD_VAR 0 3
31199: IFFALSE 31203
// break ;
31201: GO 31440
// end else
31203: GO 31424
// if tab [ i ] and value in tab [ i ] then
31205: LD_VAR 0 1
31209: PUSH
31210: LD_VAR 0 5
31214: ARRAY
31215: PUSH
31216: LD_VAR 0 2
31220: PUSH
31221: LD_VAR 0 1
31225: PUSH
31226: LD_VAR 0 5
31230: ARRAY
31231: IN
31232: AND
31233: IFFALSE 31424
// begin if not mode then
31235: LD_VAR 0 3
31239: NOT
31240: IFFALSE 31266
// tmp := tab [ i ] diff value else
31242: LD_ADDR_VAR 0 7
31246: PUSH
31247: LD_VAR 0 1
31251: PUSH
31252: LD_VAR 0 5
31256: ARRAY
31257: PUSH
31258: LD_VAR 0 2
31262: DIFF
31263: ST_TO_ADDR
31264: GO 31346
// for j = 1 to tab [ i ] do
31266: LD_ADDR_VAR 0 6
31270: PUSH
31271: DOUBLE
31272: LD_INT 1
31274: DEC
31275: ST_TO_ADDR
31276: LD_VAR 0 1
31280: PUSH
31281: LD_VAR 0 5
31285: ARRAY
31286: PUSH
31287: FOR_TO
31288: IFFALSE 31344
// if value = tab [ i ] [ j ] then
31290: LD_VAR 0 2
31294: PUSH
31295: LD_VAR 0 1
31299: PUSH
31300: LD_VAR 0 5
31304: ARRAY
31305: PUSH
31306: LD_VAR 0 6
31310: ARRAY
31311: EQUAL
31312: IFFALSE 31342
// begin tmp := Delete ( tab [ i ] , j ) ;
31314: LD_ADDR_VAR 0 7
31318: PUSH
31319: LD_VAR 0 1
31323: PUSH
31324: LD_VAR 0 5
31328: ARRAY
31329: PPUSH
31330: LD_VAR 0 6
31334: PPUSH
31335: CALL_OW 3
31339: ST_TO_ADDR
// break ;
31340: GO 31344
// end ;
31342: GO 31287
31344: POP
31345: POP
// if tmp = [ ] then
31346: LD_VAR 0 7
31350: PUSH
31351: EMPTY
31352: EQUAL
31353: IFFALSE 31377
// begin tab := Delete ( tab , i ) ;
31355: LD_ADDR_VAR 0 1
31359: PUSH
31360: LD_VAR 0 1
31364: PPUSH
31365: LD_VAR 0 5
31369: PPUSH
31370: CALL_OW 3
31374: ST_TO_ADDR
// end else
31375: GO 31402
// tab := Replace ( tab , i , tmp ) ;
31377: LD_ADDR_VAR 0 1
31381: PUSH
31382: LD_VAR 0 1
31386: PPUSH
31387: LD_VAR 0 5
31391: PPUSH
31392: LD_VAR 0 7
31396: PPUSH
31397: CALL_OW 1
31401: ST_TO_ADDR
// i := i - 1 ;
31402: LD_ADDR_VAR 0 5
31406: PUSH
31407: LD_VAR 0 5
31411: PUSH
31412: LD_INT 1
31414: MINUS
31415: ST_TO_ADDR
// if mode then
31416: LD_VAR 0 3
31420: IFFALSE 31424
// break ;
31422: GO 31440
// end ; i := i + 1 ;
31424: LD_ADDR_VAR 0 5
31428: PUSH
31429: LD_VAR 0 5
31433: PUSH
31434: LD_INT 1
31436: PLUS
31437: ST_TO_ADDR
// end ;
31438: GO 31055
// result := tab ;
31440: LD_ADDR_VAR 0 4
31444: PUSH
31445: LD_VAR 0 1
31449: ST_TO_ADDR
// end ;
31450: LD_VAR 0 4
31454: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31455: LD_INT 0
31457: PPUSH
31458: PPUSH
// for i = 1 to values do
31459: LD_ADDR_VAR 0 4
31463: PUSH
31464: DOUBLE
31465: LD_INT 1
31467: DEC
31468: ST_TO_ADDR
31469: LD_VAR 0 2
31473: PUSH
31474: FOR_TO
31475: IFFALSE 31508
// tab := Remove ( tab , values [ i ] , false ) ;
31477: LD_ADDR_VAR 0 1
31481: PUSH
31482: LD_VAR 0 1
31486: PPUSH
31487: LD_VAR 0 2
31491: PUSH
31492: LD_VAR 0 4
31496: ARRAY
31497: PPUSH
31498: LD_INT 0
31500: PPUSH
31501: CALL 31041 0 3
31505: ST_TO_ADDR
31506: GO 31474
31508: POP
31509: POP
// result := tab ;
31510: LD_ADDR_VAR 0 3
31514: PUSH
31515: LD_VAR 0 1
31519: ST_TO_ADDR
// end ;
31520: LD_VAR 0 3
31524: RET
// export function IsDriver ( unit ) ; begin
31525: LD_INT 0
31527: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31528: LD_VAR 0 1
31532: PUSH
31533: LD_INT 55
31535: PUSH
31536: EMPTY
31537: LIST
31538: PPUSH
31539: CALL_OW 69
31543: IN
31544: IFFALSE 31563
// result := IsInUnit ( unit ) else
31546: LD_ADDR_VAR 0 2
31550: PUSH
31551: LD_VAR 0 1
31555: PPUSH
31556: CALL_OW 310
31560: ST_TO_ADDR
31561: GO 31571
// result := false ;
31563: LD_ADDR_VAR 0 2
31567: PUSH
31568: LD_INT 0
31570: ST_TO_ADDR
// end ;
31571: LD_VAR 0 2
31575: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31576: LD_INT 0
31578: PPUSH
31579: PPUSH
31580: PPUSH
// if not GetControl ( veh ) = control_manual then
31581: LD_VAR 0 1
31585: PPUSH
31586: CALL_OW 263
31590: PUSH
31591: LD_INT 1
31593: EQUAL
31594: NOT
31595: IFFALSE 31607
// result := false else
31597: LD_ADDR_VAR 0 2
31601: PUSH
31602: LD_INT 0
31604: ST_TO_ADDR
31605: GO 31752
// if veh in FilterAllUnits ( [ f_empty ] ) then
31607: LD_VAR 0 1
31611: PUSH
31612: LD_INT 58
31614: PUSH
31615: EMPTY
31616: LIST
31617: PPUSH
31618: CALL_OW 69
31622: IN
31623: IFFALSE 31635
// result := false else
31625: LD_ADDR_VAR 0 2
31629: PUSH
31630: LD_INT 0
31632: ST_TO_ADDR
31633: GO 31752
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31635: LD_ADDR_VAR 0 4
31639: PUSH
31640: LD_INT 22
31642: PUSH
31643: LD_VAR 0 1
31647: PPUSH
31648: CALL_OW 255
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 55
31659: PUSH
31660: EMPTY
31661: LIST
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PPUSH
31667: CALL_OW 69
31671: ST_TO_ADDR
// if not filter then
31672: LD_VAR 0 4
31676: NOT
31677: IFFALSE 31689
// result := false else
31679: LD_ADDR_VAR 0 2
31683: PUSH
31684: LD_INT 0
31686: ST_TO_ADDR
31687: GO 31752
// for i = 1 to filter do
31689: LD_ADDR_VAR 0 3
31693: PUSH
31694: DOUBLE
31695: LD_INT 1
31697: DEC
31698: ST_TO_ADDR
31699: LD_VAR 0 4
31703: PUSH
31704: FOR_TO
31705: IFFALSE 31750
// if IsDriver ( filter [ i ] ) = veh then
31707: LD_VAR 0 4
31711: PUSH
31712: LD_VAR 0 3
31716: ARRAY
31717: PPUSH
31718: CALL 31525 0 1
31722: PUSH
31723: LD_VAR 0 1
31727: EQUAL
31728: IFFALSE 31748
// begin result := filter [ i ] ;
31730: LD_ADDR_VAR 0 2
31734: PUSH
31735: LD_VAR 0 4
31739: PUSH
31740: LD_VAR 0 3
31744: ARRAY
31745: ST_TO_ADDR
// break ;
31746: GO 31750
// end ;
31748: GO 31704
31750: POP
31751: POP
// end ; end ;
31752: LD_VAR 0 2
31756: RET
// export function ComComplete ( unit , b ) ; var i ; begin
31757: LD_INT 0
31759: PPUSH
31760: PPUSH
// if BuildingStatus ( b ) = bs_build then
31761: LD_VAR 0 2
31765: PPUSH
31766: CALL_OW 461
31770: PUSH
31771: LD_INT 1
31773: EQUAL
31774: IFFALSE 31834
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
31776: LD_VAR 0 1
31780: PPUSH
31781: LD_STRING h
31783: PUSH
31784: LD_VAR 0 2
31788: PPUSH
31789: CALL_OW 250
31793: PUSH
31794: LD_VAR 0 2
31798: PPUSH
31799: CALL_OW 251
31803: PUSH
31804: LD_VAR 0 2
31808: PUSH
31809: LD_INT 0
31811: PUSH
31812: LD_INT 0
31814: PUSH
31815: LD_INT 0
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: LIST
31826: PUSH
31827: EMPTY
31828: LIST
31829: PPUSH
31830: CALL_OW 446
// end ;
31834: LD_VAR 0 3
31838: RET
// export function Compare ( val1 , val2 ) ; begin
31839: LD_INT 0
31841: PPUSH
// if val1 = val2 then
31842: LD_VAR 0 1
31846: PUSH
31847: LD_VAR 0 2
31851: EQUAL
31852: IFFALSE 31864
// result := true else
31854: LD_ADDR_VAR 0 3
31858: PUSH
31859: LD_INT 1
31861: ST_TO_ADDR
31862: GO 31872
// result := false ;
31864: LD_ADDR_VAR 0 3
31868: PUSH
31869: LD_INT 0
31871: ST_TO_ADDR
// end ;
31872: LD_VAR 0 3
31876: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31877: LD_INT 0
31879: PPUSH
31880: PPUSH
// result := true ;
31881: LD_ADDR_VAR 0 3
31885: PUSH
31886: LD_INT 1
31888: ST_TO_ADDR
// if array1 = array2 then
31889: LD_VAR 0 1
31893: PUSH
31894: LD_VAR 0 2
31898: EQUAL
31899: IFFALSE 31964
// begin for i = 1 to array1 do
31901: LD_ADDR_VAR 0 4
31905: PUSH
31906: DOUBLE
31907: LD_INT 1
31909: DEC
31910: ST_TO_ADDR
31911: LD_VAR 0 1
31915: PUSH
31916: FOR_TO
31917: IFFALSE 31960
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
31919: LD_VAR 0 1
31923: PUSH
31924: LD_VAR 0 4
31928: ARRAY
31929: PPUSH
31930: LD_VAR 0 2
31934: PUSH
31935: LD_VAR 0 4
31939: ARRAY
31940: PPUSH
31941: CALL 31839 0 2
31945: NOT
31946: IFFALSE 31958
// begin result := false ;
31948: LD_ADDR_VAR 0 3
31952: PUSH
31953: LD_INT 0
31955: ST_TO_ADDR
// break ;
31956: GO 31960
// end ;
31958: GO 31916
31960: POP
31961: POP
// end else
31962: GO 31972
// result := false ;
31964: LD_ADDR_VAR 0 3
31968: PUSH
31969: LD_INT 0
31971: ST_TO_ADDR
// end ;
31972: LD_VAR 0 3
31976: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31977: LD_INT 0
31979: PPUSH
31980: PPUSH
// result := false ;
31981: LD_ADDR_VAR 0 3
31985: PUSH
31986: LD_INT 0
31988: ST_TO_ADDR
// for j = 1 to e2 do
31989: LD_ADDR_VAR 0 4
31993: PUSH
31994: DOUBLE
31995: LD_INT 1
31997: DEC
31998: ST_TO_ADDR
31999: LD_VAR 0 2
32003: PUSH
32004: FOR_TO
32005: IFFALSE 32039
// if Compare ( e1 , e2 [ j ] ) then
32007: LD_VAR 0 1
32011: PPUSH
32012: LD_VAR 0 2
32016: PUSH
32017: LD_VAR 0 4
32021: ARRAY
32022: PPUSH
32023: CALL 31839 0 2
32027: IFFALSE 32037
// result := true ;
32029: LD_ADDR_VAR 0 3
32033: PUSH
32034: LD_INT 1
32036: ST_TO_ADDR
32037: GO 32004
32039: POP
32040: POP
// end ;
32041: LD_VAR 0 3
32045: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32046: LD_INT 0
32048: PPUSH
32049: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32050: LD_VAR 0 1
32054: PPUSH
32055: LD_STRING C
32057: PUSH
32058: LD_VAR 0 2
32062: PUSH
32063: LD_VAR 0 3
32067: PUSH
32068: LD_INT 0
32070: PUSH
32071: LD_INT 0
32073: PUSH
32074: LD_INT 0
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: PUSH
32089: LD_STRING v
32091: PUSH
32092: LD_VAR 0 4
32096: PPUSH
32097: CALL_OW 250
32101: PUSH
32102: LD_VAR 0 4
32106: PPUSH
32107: CALL_OW 251
32111: PUSH
32112: LD_VAR 0 4
32116: PUSH
32117: LD_INT 0
32119: PUSH
32120: LD_INT 0
32122: PUSH
32123: LD_INT 0
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: LIST
32130: LIST
32131: LIST
32132: LIST
32133: LIST
32134: PUSH
32135: EMPTY
32136: LIST
32137: LIST
32138: PPUSH
32139: CALL_OW 446
// end ;
32143: LD_VAR 0 5
32147: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32148: LD_INT 0
32150: PPUSH
32151: PPUSH
32152: PPUSH
// linked := UnitsLinked ( unit ) ;
32153: LD_ADDR_VAR 0 4
32157: PUSH
32158: LD_VAR 0 1
32162: PPUSH
32163: CALL_OW 432
32167: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32168: LD_ADDR_VAR 0 3
32172: PUSH
32173: LD_VAR 0 1
32177: PPUSH
32178: LD_INT 3
32180: PPUSH
32181: CALL_OW 259
32185: ST_TO_ADDR
// if sk > linked then
32186: LD_VAR 0 3
32190: PUSH
32191: LD_VAR 0 4
32195: GREATER
32196: IFFALSE 32208
// result := true else
32198: LD_ADDR_VAR 0 2
32202: PUSH
32203: LD_INT 1
32205: ST_TO_ADDR
32206: GO 32216
// result := false ;
32208: LD_ADDR_VAR 0 2
32212: PUSH
32213: LD_INT 0
32215: ST_TO_ADDR
// end ;
32216: LD_VAR 0 2
32220: RET
// export function NotTask ( unit ) ; begin
32221: LD_INT 0
32223: PPUSH
// result := true ;
32224: LD_ADDR_VAR 0 2
32228: PUSH
32229: LD_INT 1
32231: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32232: LD_VAR 0 1
32236: PPUSH
32237: CALL_OW 437
32241: PUSH
32242: LD_VAR 0 1
32246: PPUSH
32247: CALL_OW 314
32251: OR
32252: IFFALSE 32262
// result := false ;
32254: LD_ADDR_VAR 0 2
32258: PUSH
32259: LD_INT 0
32261: ST_TO_ADDR
// end ;
32262: LD_VAR 0 2
32266: RET
// export function WantHeal ( sci , unit ) ; begin
32267: LD_INT 0
32269: PPUSH
// if GetTaskList ( sci ) > 0 then
32270: LD_VAR 0 1
32274: PPUSH
32275: CALL_OW 437
32279: PUSH
32280: LD_INT 0
32282: GREATER
32283: IFFALSE 32353
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32285: LD_VAR 0 1
32289: PPUSH
32290: CALL_OW 437
32294: PUSH
32295: LD_INT 1
32297: ARRAY
32298: PUSH
32299: LD_INT 1
32301: ARRAY
32302: PUSH
32303: LD_STRING l
32305: EQUAL
32306: PUSH
32307: LD_VAR 0 1
32311: PPUSH
32312: CALL_OW 437
32316: PUSH
32317: LD_INT 1
32319: ARRAY
32320: PUSH
32321: LD_INT 4
32323: ARRAY
32324: PUSH
32325: LD_VAR 0 2
32329: EQUAL
32330: AND
32331: IFFALSE 32343
// result := true else
32333: LD_ADDR_VAR 0 3
32337: PUSH
32338: LD_INT 1
32340: ST_TO_ADDR
32341: GO 32351
// result := false ;
32343: LD_ADDR_VAR 0 3
32347: PUSH
32348: LD_INT 0
32350: ST_TO_ADDR
// end else
32351: GO 32361
// result := false ;
32353: LD_ADDR_VAR 0 3
32357: PUSH
32358: LD_INT 0
32360: ST_TO_ADDR
// end ;
32361: LD_VAR 0 3
32365: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32366: LD_INT 0
32368: PPUSH
32369: PPUSH
32370: PPUSH
32371: PPUSH
32372: PPUSH
// dist := 99999 ;
32373: LD_ADDR_VAR 0 7
32377: PUSH
32378: LD_INT 99999
32380: ST_TO_ADDR
// un := - 1 ;
32381: LD_ADDR_VAR 0 6
32385: PUSH
32386: LD_INT 1
32388: NEG
32389: ST_TO_ADDR
// if units1 and units2 then
32390: LD_VAR 0 1
32394: PUSH
32395: LD_VAR 0 2
32399: AND
32400: IFFALSE 32488
// for i in units1 do
32402: LD_ADDR_VAR 0 4
32406: PUSH
32407: LD_VAR 0 1
32411: PUSH
32412: FOR_IN
32413: IFFALSE 32486
// for j in units2 do
32415: LD_ADDR_VAR 0 5
32419: PUSH
32420: LD_VAR 0 2
32424: PUSH
32425: FOR_IN
32426: IFFALSE 32482
// if GetDistUnits ( i , j ) < dist then
32428: LD_VAR 0 4
32432: PPUSH
32433: LD_VAR 0 5
32437: PPUSH
32438: CALL_OW 296
32442: PUSH
32443: LD_VAR 0 7
32447: LESS
32448: IFFALSE 32480
// begin un := i ;
32450: LD_ADDR_VAR 0 6
32454: PUSH
32455: LD_VAR 0 4
32459: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32460: LD_ADDR_VAR 0 7
32464: PUSH
32465: LD_VAR 0 4
32469: PPUSH
32470: LD_VAR 0 5
32474: PPUSH
32475: CALL_OW 296
32479: ST_TO_ADDR
// end ;
32480: GO 32425
32482: POP
32483: POP
32484: GO 32412
32486: POP
32487: POP
// result := [ un , dist ] ;
32488: LD_ADDR_VAR 0 3
32492: PUSH
32493: LD_VAR 0 6
32497: PUSH
32498: LD_VAR 0 7
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: ST_TO_ADDR
// end ;
32507: LD_VAR 0 3
32511: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32512: LD_INT 0
32514: PPUSH
32515: PPUSH
32516: PPUSH
32517: PPUSH
32518: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32519: LD_VAR 0 1
32523: NOT
32524: PUSH
32525: LD_VAR 0 1
32529: PPUSH
32530: CALL_OW 256
32534: PUSH
32535: LD_INT 250
32537: LESS
32538: OR
32539: PUSH
32540: LD_VAR 0 1
32544: PPUSH
32545: CALL_OW 314
32549: PUSH
32550: LD_VAR 0 1
32554: PPUSH
32555: CALL_OW 261
32559: PUSH
32560: LD_INT 20
32562: GREATER
32563: AND
32564: OR
32565: IFFALSE 32569
// exit ;
32567: GO 32943
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32569: LD_VAR 0 1
32573: PPUSH
32574: CALL_OW 261
32578: PUSH
32579: LD_INT 20
32581: LESS
32582: PUSH
32583: LD_VAR 0 1
32587: PPUSH
32588: CALL_OW 110
32592: PUSH
32593: LD_INT 21
32595: EQUAL
32596: NOT
32597: AND
32598: IFFALSE 32634
// begin ComStop ( bulldozer ) ;
32600: LD_VAR 0 1
32604: PPUSH
32605: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32609: LD_VAR 0 1
32613: PPUSH
32614: LD_INT 21
32616: PPUSH
32617: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32621: LD_VAR 0 1
32625: PPUSH
32626: CALL 26146 0 1
// exit ;
32630: GO 32943
// end else
32632: GO 32661
// if GetFuel ( bulldozer ) > 20 then
32634: LD_VAR 0 1
32638: PPUSH
32639: CALL_OW 261
32643: PUSH
32644: LD_INT 20
32646: GREATER
32647: IFFALSE 32661
// SetTag ( bulldozer , 0 ) ;
32649: LD_VAR 0 1
32653: PPUSH
32654: LD_INT 0
32656: PPUSH
32657: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32661: LD_ADDR_VAR 0 5
32665: PUSH
32666: LD_VAR 0 2
32670: PPUSH
32671: CALL_OW 353
32675: ST_TO_ADDR
// tmp := [ ] ;
32676: LD_ADDR_VAR 0 6
32680: PUSH
32681: EMPTY
32682: ST_TO_ADDR
// for i = 1 to list do
32683: LD_ADDR_VAR 0 4
32687: PUSH
32688: DOUBLE
32689: LD_INT 1
32691: DEC
32692: ST_TO_ADDR
32693: LD_VAR 0 5
32697: PUSH
32698: FOR_TO
32699: IFFALSE 32797
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32701: LD_VAR 0 5
32705: PUSH
32706: LD_VAR 0 4
32710: ARRAY
32711: PUSH
32712: LD_INT 1
32714: ARRAY
32715: PPUSH
32716: LD_VAR 0 5
32720: PUSH
32721: LD_VAR 0 4
32725: ARRAY
32726: PUSH
32727: LD_INT 2
32729: ARRAY
32730: PPUSH
32731: CALL_OW 554
32735: IFFALSE 32795
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32737: LD_ADDR_VAR 0 6
32741: PUSH
32742: LD_VAR 0 6
32746: PPUSH
32747: LD_VAR 0 6
32751: PUSH
32752: LD_INT 1
32754: PLUS
32755: PPUSH
32756: LD_VAR 0 5
32760: PUSH
32761: LD_VAR 0 4
32765: ARRAY
32766: PUSH
32767: LD_INT 1
32769: ARRAY
32770: PUSH
32771: LD_VAR 0 5
32775: PUSH
32776: LD_VAR 0 4
32780: ARRAY
32781: PUSH
32782: LD_INT 2
32784: ARRAY
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: PPUSH
32790: CALL_OW 1
32794: ST_TO_ADDR
// end ;
32795: GO 32698
32797: POP
32798: POP
// ComStop ( bulldozer ) ;
32799: LD_VAR 0 1
32803: PPUSH
32804: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32808: LD_ADDR_VAR 0 7
32812: PUSH
32813: LD_VAR 0 1
32817: PPUSH
32818: CALL_OW 250
32822: PUSH
32823: LD_VAR 0 1
32827: PPUSH
32828: CALL_OW 251
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: ST_TO_ADDR
// for i = tmp downto 1 do
32837: LD_ADDR_VAR 0 4
32841: PUSH
32842: DOUBLE
32843: LD_VAR 0 6
32847: INC
32848: ST_TO_ADDR
32849: LD_INT 1
32851: PUSH
32852: FOR_DOWNTO
32853: IFFALSE 32941
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32855: LD_ADDR_VAR 0 7
32859: PUSH
32860: LD_VAR 0 7
32864: PUSH
32865: LD_INT 1
32867: ARRAY
32868: PPUSH
32869: LD_VAR 0 7
32873: PUSH
32874: LD_INT 2
32876: ARRAY
32877: PPUSH
32878: LD_VAR 0 6
32882: PPUSH
32883: CALL 33044 0 3
32887: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32888: LD_VAR 0 1
32892: PPUSH
32893: LD_VAR 0 7
32897: PUSH
32898: LD_INT 1
32900: ARRAY
32901: PPUSH
32902: LD_VAR 0 7
32906: PUSH
32907: LD_INT 2
32909: ARRAY
32910: PPUSH
32911: CALL 32948 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32915: LD_ADDR_VAR 0 6
32919: PUSH
32920: LD_VAR 0 6
32924: PPUSH
32925: LD_VAR 0 7
32929: PUSH
32930: LD_INT 3
32932: ARRAY
32933: PPUSH
32934: CALL_OW 3
32938: ST_TO_ADDR
// end ;
32939: GO 32852
32941: POP
32942: POP
// end ;
32943: LD_VAR 0 3
32947: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32948: LD_INT 0
32950: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32951: LD_VAR 0 2
32955: PPUSH
32956: LD_VAR 0 3
32960: PPUSH
32961: CALL_OW 351
32965: PUSH
32966: LD_VAR 0 2
32970: PPUSH
32971: LD_VAR 0 3
32975: PPUSH
32976: CALL_OW 554
32980: AND
32981: PUSH
32982: LD_VAR 0 2
32986: PPUSH
32987: LD_VAR 0 3
32991: PPUSH
32992: CALL_OW 488
32996: AND
32997: PUSH
32998: LD_VAR 0 2
33002: PPUSH
33003: LD_VAR 0 3
33007: PPUSH
33008: CALL_OW 428
33012: PUSH
33013: LD_INT 1
33015: NEG
33016: EQUAL
33017: AND
33018: IFFALSE 33039
// AddComMoveXY ( bulldozer , x , y ) ;
33020: LD_VAR 0 1
33024: PPUSH
33025: LD_VAR 0 2
33029: PPUSH
33030: LD_VAR 0 3
33034: PPUSH
33035: CALL_OW 171
// end ;
33039: LD_VAR 0 4
33043: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
33044: LD_INT 0
33046: PPUSH
33047: PPUSH
33048: PPUSH
33049: PPUSH
33050: PPUSH
33051: PPUSH
33052: PPUSH
// dist := 99999 ;
33053: LD_ADDR_VAR 0 6
33057: PUSH
33058: LD_INT 99999
33060: ST_TO_ADDR
// for i = 1 to list do
33061: LD_ADDR_VAR 0 5
33065: PUSH
33066: DOUBLE
33067: LD_INT 1
33069: DEC
33070: ST_TO_ADDR
33071: LD_VAR 0 3
33075: PUSH
33076: FOR_TO
33077: IFFALSE 33215
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33079: LD_ADDR_VAR 0 7
33083: PUSH
33084: LD_VAR 0 1
33088: PPUSH
33089: LD_VAR 0 2
33093: PPUSH
33094: LD_VAR 0 3
33098: PUSH
33099: LD_VAR 0 5
33103: ARRAY
33104: PUSH
33105: LD_INT 1
33107: ARRAY
33108: PPUSH
33109: LD_VAR 0 3
33113: PUSH
33114: LD_VAR 0 5
33118: ARRAY
33119: PUSH
33120: LD_INT 2
33122: ARRAY
33123: PPUSH
33124: CALL_OW 298
33128: ST_TO_ADDR
// if d = 0 then
33129: LD_VAR 0 7
33133: PUSH
33134: LD_INT 0
33136: EQUAL
33137: IFFALSE 33141
// continue ;
33139: GO 33076
// if d < dist then
33141: LD_VAR 0 7
33145: PUSH
33146: LD_VAR 0 6
33150: LESS
33151: IFFALSE 33213
// begin _x := list [ i ] [ 1 ] ;
33153: LD_ADDR_VAR 0 8
33157: PUSH
33158: LD_VAR 0 3
33162: PUSH
33163: LD_VAR 0 5
33167: ARRAY
33168: PUSH
33169: LD_INT 1
33171: ARRAY
33172: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33173: LD_ADDR_VAR 0 9
33177: PUSH
33178: LD_VAR 0 3
33182: PUSH
33183: LD_VAR 0 5
33187: ARRAY
33188: PUSH
33189: LD_INT 2
33191: ARRAY
33192: ST_TO_ADDR
// _i := i ;
33193: LD_ADDR_VAR 0 10
33197: PUSH
33198: LD_VAR 0 5
33202: ST_TO_ADDR
// dist := d ;
33203: LD_ADDR_VAR 0 6
33207: PUSH
33208: LD_VAR 0 7
33212: ST_TO_ADDR
// end ; end ;
33213: GO 33076
33215: POP
33216: POP
// result := [ _x , _y , _i , dist ] ;
33217: LD_ADDR_VAR 0 4
33221: PUSH
33222: LD_VAR 0 8
33226: PUSH
33227: LD_VAR 0 9
33231: PUSH
33232: LD_VAR 0 10
33236: PUSH
33237: LD_VAR 0 6
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: LIST
33246: LIST
33247: ST_TO_ADDR
// end ;
33248: LD_VAR 0 4
33252: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33253: LD_INT 0
33255: PPUSH
33256: PPUSH
33257: PPUSH
33258: PPUSH
33259: PPUSH
// for i = 1 to list do
33260: LD_ADDR_VAR 0 5
33264: PUSH
33265: DOUBLE
33266: LD_INT 1
33268: DEC
33269: ST_TO_ADDR
33270: LD_VAR 0 1
33274: PUSH
33275: FOR_TO
33276: IFFALSE 33590
// begin for j = list downto 2 do
33278: LD_ADDR_VAR 0 6
33282: PUSH
33283: DOUBLE
33284: LD_VAR 0 1
33288: INC
33289: ST_TO_ADDR
33290: LD_INT 2
33292: PUSH
33293: FOR_DOWNTO
33294: IFFALSE 33586
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33296: LD_VAR 0 2
33300: PPUSH
33301: LD_VAR 0 3
33305: PPUSH
33306: LD_VAR 0 1
33310: PUSH
33311: LD_VAR 0 6
33315: ARRAY
33316: PUSH
33317: LD_INT 1
33319: ARRAY
33320: PPUSH
33321: LD_VAR 0 1
33325: PUSH
33326: LD_VAR 0 6
33330: ARRAY
33331: PUSH
33332: LD_INT 2
33334: ARRAY
33335: PPUSH
33336: CALL_OW 298
33340: PUSH
33341: LD_VAR 0 2
33345: PPUSH
33346: LD_VAR 0 3
33350: PPUSH
33351: LD_VAR 0 1
33355: PUSH
33356: LD_VAR 0 6
33360: PUSH
33361: LD_INT 1
33363: MINUS
33364: ARRAY
33365: PUSH
33366: LD_INT 1
33368: ARRAY
33369: PPUSH
33370: LD_VAR 0 1
33374: PUSH
33375: LD_VAR 0 6
33379: PUSH
33380: LD_INT 1
33382: MINUS
33383: ARRAY
33384: PUSH
33385: LD_INT 2
33387: ARRAY
33388: PPUSH
33389: CALL_OW 298
33393: LESS
33394: IFFALSE 33584
// begin _x := list [ j ] [ 1 ] ;
33396: LD_ADDR_VAR 0 7
33400: PUSH
33401: LD_VAR 0 1
33405: PUSH
33406: LD_VAR 0 6
33410: ARRAY
33411: PUSH
33412: LD_INT 1
33414: ARRAY
33415: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33416: LD_ADDR_VAR 0 8
33420: PUSH
33421: LD_VAR 0 1
33425: PUSH
33426: LD_VAR 0 6
33430: ARRAY
33431: PUSH
33432: LD_INT 2
33434: ARRAY
33435: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33436: LD_ADDR_VAR 0 1
33440: PUSH
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_VAR 0 6
33450: PPUSH
33451: LD_INT 1
33453: PPUSH
33454: LD_VAR 0 1
33458: PUSH
33459: LD_VAR 0 6
33463: PUSH
33464: LD_INT 1
33466: MINUS
33467: ARRAY
33468: PUSH
33469: LD_INT 1
33471: ARRAY
33472: PPUSH
33473: CALL 30882 0 4
33477: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33478: LD_ADDR_VAR 0 1
33482: PUSH
33483: LD_VAR 0 1
33487: PPUSH
33488: LD_VAR 0 6
33492: PPUSH
33493: LD_INT 2
33495: PPUSH
33496: LD_VAR 0 1
33500: PUSH
33501: LD_VAR 0 6
33505: PUSH
33506: LD_INT 1
33508: MINUS
33509: ARRAY
33510: PUSH
33511: LD_INT 2
33513: ARRAY
33514: PPUSH
33515: CALL 30882 0 4
33519: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33520: LD_ADDR_VAR 0 1
33524: PUSH
33525: LD_VAR 0 1
33529: PPUSH
33530: LD_VAR 0 6
33534: PUSH
33535: LD_INT 1
33537: MINUS
33538: PPUSH
33539: LD_INT 1
33541: PPUSH
33542: LD_VAR 0 7
33546: PPUSH
33547: CALL 30882 0 4
33551: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33552: LD_ADDR_VAR 0 1
33556: PUSH
33557: LD_VAR 0 1
33561: PPUSH
33562: LD_VAR 0 6
33566: PUSH
33567: LD_INT 1
33569: MINUS
33570: PPUSH
33571: LD_INT 2
33573: PPUSH
33574: LD_VAR 0 8
33578: PPUSH
33579: CALL 30882 0 4
33583: ST_TO_ADDR
// end ; end ;
33584: GO 33293
33586: POP
33587: POP
// end ;
33588: GO 33275
33590: POP
33591: POP
// result := list ;
33592: LD_ADDR_VAR 0 4
33596: PUSH
33597: LD_VAR 0 1
33601: ST_TO_ADDR
// end ;
33602: LD_VAR 0 4
33606: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33607: LD_INT 0
33609: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33610: LD_ADDR_VAR 0 5
33614: PUSH
33615: LD_VAR 0 1
33619: PPUSH
33620: LD_VAR 0 2
33624: PPUSH
33625: CALL_OW 546
33629: PUSH
33630: LD_INT 2
33632: ARRAY
33633: PUSH
33634: LD_VAR 0 3
33638: PPUSH
33639: LD_VAR 0 4
33643: PPUSH
33644: CALL_OW 546
33648: PUSH
33649: LD_INT 2
33651: ARRAY
33652: MINUS
33653: ST_TO_ADDR
// if result < 0 then
33654: LD_VAR 0 5
33658: PUSH
33659: LD_INT 0
33661: LESS
33662: IFFALSE 33679
// result := result * - 1 ;
33664: LD_ADDR_VAR 0 5
33668: PUSH
33669: LD_VAR 0 5
33673: PUSH
33674: LD_INT 1
33676: NEG
33677: MUL
33678: ST_TO_ADDR
// end ;
33679: LD_VAR 0 5
33683: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33684: LD_INT 0
33686: PPUSH
33687: PPUSH
// area = ListEnvironmentArea ( area ) ;
33688: LD_ADDR_VAR 0 2
33692: PUSH
33693: LD_VAR 0 2
33697: PPUSH
33698: CALL_OW 353
33702: ST_TO_ADDR
// if bulldozer > 0 then
33703: LD_VAR 0 1
33707: PUSH
33708: LD_INT 0
33710: GREATER
33711: IFFALSE 33822
// for i = area downto 1 do
33713: LD_ADDR_VAR 0 4
33717: PUSH
33718: DOUBLE
33719: LD_VAR 0 2
33723: INC
33724: ST_TO_ADDR
33725: LD_INT 1
33727: PUSH
33728: FOR_DOWNTO
33729: IFFALSE 33820
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33731: LD_VAR 0 2
33735: PUSH
33736: LD_VAR 0 4
33740: ARRAY
33741: PUSH
33742: LD_INT 1
33744: ARRAY
33745: PPUSH
33746: LD_VAR 0 2
33750: PUSH
33751: LD_VAR 0 4
33755: ARRAY
33756: PUSH
33757: LD_INT 2
33759: ARRAY
33760: PPUSH
33761: CALL_OW 351
33765: IFFALSE 33818
// if not HasTask ( bulldozer ) then
33767: LD_VAR 0 1
33771: PPUSH
33772: CALL_OW 314
33776: NOT
33777: IFFALSE 33818
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33779: LD_VAR 0 1
33783: PPUSH
33784: LD_VAR 0 2
33788: PUSH
33789: LD_VAR 0 4
33793: ARRAY
33794: PUSH
33795: LD_INT 1
33797: ARRAY
33798: PPUSH
33799: LD_VAR 0 2
33803: PUSH
33804: LD_VAR 0 4
33808: ARRAY
33809: PUSH
33810: LD_INT 2
33812: ARRAY
33813: PPUSH
33814: CALL_OW 171
33818: GO 33728
33820: POP
33821: POP
// end ;
33822: LD_VAR 0 3
33826: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33827: LD_INT 0
33829: PPUSH
33830: PPUSH
33831: PPUSH
33832: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33833: LD_ADDR_VAR 0 6
33837: PUSH
33838: LD_INT 22
33840: PUSH
33841: LD_VAR 0 1
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 21
33852: PUSH
33853: LD_VAR 0 2
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: PPUSH
33866: CALL_OW 69
33870: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33871: LD_ADDR_VAR 0 7
33875: PUSH
33876: LD_VAR 0 3
33880: PPUSH
33881: LD_INT 22
33883: PUSH
33884: LD_VAR 0 1
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 21
33895: PUSH
33896: LD_VAR 0 2
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PPUSH
33909: CALL_OW 70
33913: ST_TO_ADDR
// if tmp and pom then
33914: LD_VAR 0 6
33918: PUSH
33919: LD_VAR 0 7
33923: AND
33924: IFFALSE 33944
// result := tmp diff pom else
33926: LD_ADDR_VAR 0 4
33930: PUSH
33931: LD_VAR 0 6
33935: PUSH
33936: LD_VAR 0 7
33940: DIFF
33941: ST_TO_ADDR
33942: GO 33952
// result := false ;
33944: LD_ADDR_VAR 0 4
33948: PUSH
33949: LD_INT 0
33951: ST_TO_ADDR
// end ;
33952: LD_VAR 0 4
33956: RET
// export function SavePosition ( unit ) ; begin
33957: LD_INT 0
33959: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33960: LD_VAR 0 1
33964: PPUSH
33965: LD_VAR 0 1
33969: PPUSH
33970: CALL_OW 250
33974: PPUSH
33975: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33979: LD_VAR 0 1
33983: PPUSH
33984: LD_VAR 0 1
33988: PPUSH
33989: CALL_OW 251
33993: PPUSH
33994: CALL_OW 232
// end ;
33998: LD_VAR 0 2
34002: RET
// export function GetPosition ( unit ) ; begin
34003: LD_INT 0
34005: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
34006: LD_ADDR_VAR 0 2
34010: PUSH
34011: LD_VAR 0 1
34015: PPUSH
34016: CALL_OW 252
34020: PUSH
34021: LD_VAR 0 1
34025: PPUSH
34026: CALL_OW 253
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: ST_TO_ADDR
// end ;
34035: LD_VAR 0 2
34039: RET
// export function DestinationReachable ( unit , x , y ) ; begin
34040: LD_INT 0
34042: PPUSH
// if unit in unreachableList then
34043: LD_VAR 0 1
34047: PUSH
34048: LD_EXP 32
34052: IN
34053: IFFALSE 34071
// unreachableList := unreachableList diff unit ;
34055: LD_ADDR_EXP 32
34059: PUSH
34060: LD_EXP 32
34064: PUSH
34065: LD_VAR 0 1
34069: DIFF
34070: ST_TO_ADDR
// if ValidHex ( x , y ) then
34071: LD_VAR 0 2
34075: PPUSH
34076: LD_VAR 0 3
34080: PPUSH
34081: CALL_OW 488
34085: IFFALSE 34111
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34087: LD_VAR 0 1
34091: PPUSH
34092: LD_VAR 0 2
34096: PPUSH
34097: LD_VAR 0 3
34101: PPUSH
34102: CALL_OW 428
34106: PPUSH
34107: CALL_OW 115
// Wait ( 3 ) ;
34111: LD_INT 3
34113: PPUSH
34114: CALL_OW 67
// if unit in unreachableList then
34118: LD_VAR 0 1
34122: PUSH
34123: LD_EXP 32
34127: IN
34128: IFFALSE 34140
// result := false else
34130: LD_ADDR_VAR 0 4
34134: PUSH
34135: LD_INT 0
34137: ST_TO_ADDR
34138: GO 34148
// result := true ;
34140: LD_ADDR_VAR 0 4
34144: PUSH
34145: LD_INT 1
34147: ST_TO_ADDR
// end ; end_of_file
34148: LD_VAR 0 4
34152: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34153: LD_EXP 33
34157: IFFALSE 34219
34159: GO 34161
34161: DISABLE
34162: LD_INT 0
34164: PPUSH
// begin enable ;
34165: ENABLE
// for i = 1 to mc_crates_list do
34166: LD_ADDR_VAR 0 1
34170: PUSH
34171: DOUBLE
34172: LD_INT 1
34174: DEC
34175: ST_TO_ADDR
34176: LD_EXP 34
34180: PUSH
34181: FOR_TO
34182: IFFALSE 34213
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34184: LD_EXP 34
34188: PUSH
34189: LD_VAR 0 1
34193: ARRAY
34194: PPUSH
34195: LD_INT 5
34197: PPUSH
34198: LD_INT 50
34200: PPUSH
34201: LD_INT 700
34203: PPUSH
34204: LD_INT 20
34206: PPUSH
34207: CALL 24328 0 5
34211: GO 34181
34213: POP
34214: POP
// MC_Game ( ) ;
34215: CALL 34222 0 0
// end ;
34219: PPOPN 1
34221: END
// export function MC_Game ( ) ; var i , side , un ; begin
34222: LD_INT 0
34224: PPUSH
34225: PPUSH
34226: PPUSH
34227: PPUSH
// if not isTest then
34228: LD_EXP 1
34232: NOT
34233: IFFALSE 34253
// MC_Show ( [ #tick , tick ] ) else
34235: LD_STRING #tick
34237: PUSH
34238: LD_OWVAR 1
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PPUSH
34247: CALL 8366 0 1
34251: GO 34262
// MC_Show ( debug_string ) ;
34253: LD_EXP 2
34257: PPUSH
34258: CALL 8366 0 1
// for side = 1 to 8 do
34262: LD_ADDR_VAR 0 3
34266: PUSH
34267: DOUBLE
34268: LD_INT 1
34270: DEC
34271: ST_TO_ADDR
34272: LD_INT 8
34274: PUSH
34275: FOR_TO
34276: IFFALSE 36274
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34278: LD_EXP 41
34282: PUSH
34283: LD_VAR 0 3
34287: ARRAY
34288: PUSH
34289: LD_INT 0
34291: EQUAL
34292: PUSH
34293: LD_VAR 0 3
34297: PPUSH
34298: EMPTY
34299: PPUSH
34300: CALL 11583 0 2
34304: PUSH
34305: LD_INT 0
34307: EQUAL
34308: OR
34309: IFFALSE 34313
// continue ;
34311: GO 34275
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34313: LD_VAR 0 3
34317: PPUSH
34318: LD_VAR 0 3
34322: PPUSH
34323: CALL 24849 0 1
34327: PPUSH
34328: CALL 36281 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34332: LD_EXP 73
34336: PUSH
34337: LD_VAR 0 3
34341: ARRAY
34342: PUSH
34343: LD_INT 1
34345: ARRAY
34346: PUSH
34347: LD_INT 0
34349: GREATER
34350: PUSH
34351: LD_EXP 71
34355: PUSH
34356: LD_VAR 0 3
34360: ARRAY
34361: PUSH
34362: LD_INT 1
34364: ARRAY
34365: PUSH
34366: LD_INT 0
34368: EQUAL
34369: AND
34370: PUSH
34371: LD_VAR 0 3
34375: PPUSH
34376: LD_INT 7
34378: PPUSH
34379: EMPTY
34380: PPUSH
34381: CALL 12151 0 3
34385: NOT
34386: AND
34387: IFFALSE 34458
// begin if side = 1 then
34389: LD_VAR 0 3
34393: PUSH
34394: LD_INT 1
34396: EQUAL
34397: IFFALSE 34406
// RaiseSailEvent ( 101 ) ;
34399: LD_INT 101
34401: PPUSH
34402: CALL_OW 427
// if side = 4 then
34406: LD_VAR 0 3
34410: PUSH
34411: LD_INT 4
34413: EQUAL
34414: IFFALSE 34423
// RaiseSailEvent ( 102 ) ;
34416: LD_INT 102
34418: PPUSH
34419: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34423: LD_ADDR_VAR 0 2
34427: PUSH
34428: LD_EXP 73
34432: PUSH
34433: LD_VAR 0 3
34437: ARRAY
34438: PUSH
34439: FOR_IN
34440: IFFALSE 34456
// SetTag ( i , 7 ) ;
34442: LD_VAR 0 2
34446: PPUSH
34447: LD_INT 7
34449: PPUSH
34450: CALL_OW 109
34454: GO 34439
34456: POP
34457: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34458: LD_VAR 0 3
34462: PPUSH
34463: LD_INT 7
34465: PPUSH
34466: EMPTY
34467: PPUSH
34468: CALL 12151 0 3
34472: IFFALSE 34498
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34474: LD_VAR 0 3
34478: PPUSH
34479: LD_VAR 0 3
34483: PPUSH
34484: LD_INT 7
34486: PPUSH
34487: EMPTY
34488: PPUSH
34489: CALL 12151 0 3
34493: PPUSH
34494: CALL 8293 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34498: LD_VAR 0 3
34502: PPUSH
34503: CALL 17831 0 1
34507: PUSH
34508: LD_VAR 0 3
34512: PPUSH
34513: CALL 11487 0 1
34517: AND
34518: IFFALSE 34529
// MCL_Start ( side ) ;
34520: LD_VAR 0 3
34524: PPUSH
34525: CALL 17788 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34529: LD_ADDR_EXP 37
34533: PUSH
34534: LD_EXP 37
34538: PPUSH
34539: LD_VAR 0 3
34543: PPUSH
34544: LD_VAR 0 3
34548: PPUSH
34549: CALL 19088 0 1
34553: PPUSH
34554: CALL_OW 1
34558: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34559: LD_ADDR_EXP 49
34563: PUSH
34564: LD_EXP 49
34568: PPUSH
34569: LD_VAR 0 3
34573: PPUSH
34574: LD_VAR 0 3
34578: PPUSH
34579: CALL 10901 0 1
34583: PPUSH
34584: CALL_OW 1
34588: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34589: LD_VAR 0 3
34593: PPUSH
34594: LD_INT 21
34596: PUSH
34597: LD_INT 2
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PPUSH
34604: CALL 11448 0 2
34608: IFFALSE 34619
// MCV_CheckStatus ( side ) ;
34610: LD_VAR 0 3
34614: PPUSH
34615: CALL 27058 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34619: LD_VAR 0 3
34623: PPUSH
34624: LD_EXP 55
34628: PPUSH
34629: CALL 43201 0 2
34633: IFFALSE 34718
// begin for i = MREG_ToChangeClass downto 1 do
34635: LD_ADDR_VAR 0 2
34639: PUSH
34640: DOUBLE
34641: LD_EXP 55
34645: INC
34646: ST_TO_ADDR
34647: LD_INT 1
34649: PUSH
34650: FOR_DOWNTO
34651: IFFALSE 34716
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34653: LD_EXP 55
34657: PUSH
34658: LD_VAR 0 2
34662: ARRAY
34663: PUSH
34664: LD_INT 1
34666: ARRAY
34667: PUSH
34668: LD_VAR 0 3
34672: EQUAL
34673: IFFALSE 34714
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_EXP 55
34684: PUSH
34685: LD_VAR 0 2
34689: ARRAY
34690: PUSH
34691: LD_INT 2
34693: ARRAY
34694: PPUSH
34695: LD_EXP 55
34699: PUSH
34700: LD_VAR 0 2
34704: ARRAY
34705: PUSH
34706: LD_INT 3
34708: ARRAY
34709: PPUSH
34710: CALL 16355 0 3
// end ; end ;
34714: GO 34650
34716: POP
34717: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34718: LD_INT 1
34720: PUSH
34721: LD_EXP 40
34725: PUSH
34726: LD_VAR 0 3
34730: ARRAY
34731: IN
34732: IFFALSE 34743
// begin MCN_TrainApe ( side ) ;
34734: LD_VAR 0 3
34738: PPUSH
34739: CALL 18741 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34743: LD_VAR 0 3
34747: PPUSH
34748: LD_INT 30
34750: PUSH
34751: LD_INT 3
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PPUSH
34758: CALL 11448 0 2
34762: IFFALSE 34936
// begin if MCF_Tag ( side , 10 , [ ] ) then
34764: LD_VAR 0 3
34768: PPUSH
34769: LD_INT 10
34771: PPUSH
34772: EMPTY
34773: PPUSH
34774: CALL 12151 0 3
34778: IFFALSE 34825
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34780: LD_VAR 0 3
34784: PPUSH
34785: LD_INT 10
34787: PPUSH
34788: EMPTY
34789: PPUSH
34790: CALL 12151 0 3
34794: PPUSH
34795: LD_VAR 0 3
34799: PPUSH
34800: LD_INT 30
34802: PUSH
34803: LD_INT 3
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PPUSH
34810: CALL 11448 0 2
34814: PUSH
34815: LD_INT 1
34817: ARRAY
34818: PPUSH
34819: CALL_OW 168
// end else
34823: GO 34936
// if MREG_ToConstruct [ side ] then
34825: LD_EXP 53
34829: PUSH
34830: LD_VAR 0 3
34834: ARRAY
34835: IFFALSE 34936
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34837: LD_VAR 0 3
34841: PPUSH
34842: LD_VAR 0 3
34846: PPUSH
34847: LD_INT 30
34849: PUSH
34850: LD_INT 3
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PPUSH
34857: CALL 11448 0 2
34861: PUSH
34862: LD_INT 1
34864: ARRAY
34865: PPUSH
34866: LD_EXP 53
34870: PUSH
34871: LD_VAR 0 3
34875: ARRAY
34876: PUSH
34877: LD_INT 1
34879: ARRAY
34880: PUSH
34881: LD_EXP 53
34885: PUSH
34886: LD_VAR 0 3
34890: ARRAY
34891: PUSH
34892: LD_INT 2
34894: ARRAY
34895: PUSH
34896: LD_EXP 53
34900: PUSH
34901: LD_VAR 0 3
34905: ARRAY
34906: PUSH
34907: LD_INT 3
34909: ARRAY
34910: PUSH
34911: LD_EXP 53
34915: PUSH
34916: LD_VAR 0 3
34920: ARRAY
34921: PUSH
34922: LD_INT 4
34924: ARRAY
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: PPUSH
34932: CALL 25352 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34936: LD_VAR 0 3
34940: PPUSH
34941: LD_INT 30
34943: PUSH
34944: LD_INT 3
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PPUSH
34951: CALL 11448 0 2
34955: PUSH
34956: LD_VAR 0 3
34960: PPUSH
34961: LD_EXP 45
34965: PPUSH
34966: CALL 43201 0 2
34970: AND
34971: PUSH
34972: LD_INT 22
34974: PUSH
34975: LD_VAR 0 3
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 2
34986: PUSH
34987: LD_INT 30
34989: PUSH
34990: LD_INT 33
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 30
34999: PUSH
35000: LD_INT 32
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: LIST
35011: PUSH
35012: LD_INT 35
35014: PUSH
35015: LD_INT 0
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: LIST
35026: PPUSH
35027: CALL_OW 69
35031: AND
35032: IFFALSE 35043
// MCV_Turret ( side ) ;
35034: LD_VAR 0 3
35038: PPUSH
35039: CALL 25801 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
35043: LD_EXP 44
35047: PUSH
35048: LD_VAR 0 3
35052: ARRAY
35053: PUSH
35054: LD_INT 1
35056: GREATER
35057: PUSH
35058: LD_VAR 0 3
35062: PPUSH
35063: CALL 24849 0 1
35067: PUSH
35068: LD_INT 0
35070: EQUAL
35071: AND
35072: IFFALSE 35234
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35074: LD_EXP 44
35078: PUSH
35079: LD_VAR 0 3
35083: ARRAY
35084: PUSH
35085: LD_INT 1
35087: ARRAY
35088: PPUSH
35089: CALL_OW 353
35093: IFFALSE 35131
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35095: LD_EXP 44
35099: PUSH
35100: LD_VAR 0 3
35104: ARRAY
35105: PUSH
35106: LD_INT 2
35108: ARRAY
35109: PPUSH
35110: LD_EXP 44
35114: PUSH
35115: LD_VAR 0 3
35119: ARRAY
35120: PUSH
35121: LD_INT 1
35123: ARRAY
35124: PPUSH
35125: CALL 32512 0 2
35129: GO 35234
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35131: LD_VAR 0 3
35135: PPUSH
35136: LD_INT 30
35138: PUSH
35139: LD_INT 3
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PPUSH
35146: CALL 11448 0 2
35150: IFFALSE 35234
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35152: LD_VAR 0 3
35156: PPUSH
35157: LD_INT 30
35159: PUSH
35160: LD_INT 3
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PPUSH
35167: CALL 11448 0 2
35171: PUSH
35172: LD_INT 1
35174: ARRAY
35175: PPUSH
35176: CALL_OW 461
35180: PUSH
35181: LD_INT 2
35183: EQUAL
35184: IFFALSE 35234
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35186: LD_EXP 44
35190: PUSH
35191: LD_VAR 0 3
35195: ARRAY
35196: PUSH
35197: LD_INT 2
35199: ARRAY
35200: PPUSH
35201: LD_INT 10
35203: PPUSH
35204: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35208: LD_ADDR_EXP 44
35212: PUSH
35213: LD_EXP 44
35217: PPUSH
35218: LD_VAR 0 3
35222: PPUSH
35223: LD_INT 0
35225: PUSH
35226: EMPTY
35227: LIST
35228: PPUSH
35229: CALL_OW 1
35233: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35234: LD_VAR 0 3
35238: PPUSH
35239: LD_INT 33
35241: PUSH
35242: LD_INT 2
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PPUSH
35249: CALL 11448 0 2
35253: IFFALSE 35293
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35255: LD_VAR 0 3
35259: PPUSH
35260: LD_VAR 0 3
35264: PPUSH
35265: LD_INT 33
35267: PUSH
35268: LD_INT 2
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PPUSH
35275: CALL 11448 0 2
35279: PUSH
35280: LD_INT 1
35282: ARRAY
35283: PPUSH
35284: CALL_OW 248
35288: PPUSH
35289: CALL 26355 0 2
// if MREG_ToRepair [ side ] then
35293: LD_EXP 49
35297: PUSH
35298: LD_VAR 0 3
35302: ARRAY
35303: IFFALSE 35316
// begin MCB_Repair ( side ) ;
35305: LD_VAR 0 3
35309: PPUSH
35310: CALL 11188 0 1
// end else
35314: GO 36227
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35316: LD_VAR 0 3
35320: PPUSH
35321: LD_EXP 51
35325: PPUSH
35326: CALL 43201 0 2
35330: PUSH
35331: LD_VAR 0 3
35335: PPUSH
35336: LD_EXP 42
35340: PPUSH
35341: CALL 43201 0 2
35345: AND
35346: IFFALSE 35554
// begin for i = 1 to MREG_ToUpLab do
35348: LD_ADDR_VAR 0 2
35352: PUSH
35353: DOUBLE
35354: LD_INT 1
35356: DEC
35357: ST_TO_ADDR
35358: LD_EXP 51
35362: PUSH
35363: FOR_TO
35364: IFFALSE 35550
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35366: LD_EXP 51
35370: PUSH
35371: LD_VAR 0 2
35375: ARRAY
35376: PUSH
35377: LD_INT 1
35379: ARRAY
35380: PUSH
35381: LD_VAR 0 3
35385: EQUAL
35386: IFFALSE 35548
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35388: LD_EXP 51
35392: PUSH
35393: LD_VAR 0 2
35397: ARRAY
35398: PUSH
35399: LD_INT 2
35401: ARRAY
35402: PUSH
35403: LD_EXP 51
35407: PUSH
35408: LD_VAR 0 2
35412: ARRAY
35413: PUSH
35414: LD_INT 3
35416: ARRAY
35417: AND
35418: IFFALSE 35546
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35420: LD_VAR 0 3
35424: PPUSH
35425: LD_EXP 51
35429: PUSH
35430: LD_VAR 0 2
35434: ARRAY
35435: PUSH
35436: LD_INT 2
35438: ARRAY
35439: PPUSH
35440: LD_EXP 51
35444: PUSH
35445: LD_VAR 0 2
35449: ARRAY
35450: PUSH
35451: LD_INT 3
35453: ARRAY
35454: PPUSH
35455: CALL 8712 0 3
35459: IFFALSE 35546
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35461: LD_ADDR_EXP 51
35465: PUSH
35466: LD_EXP 51
35470: PPUSH
35471: LD_VAR 0 3
35475: PPUSH
35476: LD_EXP 51
35480: PUSH
35481: LD_VAR 0 2
35485: ARRAY
35486: PUSH
35487: LD_INT 2
35489: ARRAY
35490: PPUSH
35491: LD_EXP 51
35495: PUSH
35496: LD_VAR 0 2
35500: ARRAY
35501: PUSH
35502: LD_INT 3
35504: ARRAY
35505: PPUSH
35506: CALL 42253 0 4
35510: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35511: LD_ADDR_EXP 42
35515: PUSH
35516: LD_EXP 42
35520: PPUSH
35521: LD_VAR 0 3
35525: PPUSH
35526: LD_EXP 42
35530: PUSH
35531: LD_INT 1
35533: ARRAY
35534: PUSH
35535: LD_INT 2
35537: ARRAY
35538: PPUSH
35539: EMPTY
35540: PPUSH
35541: CALL 42253 0 4
35545: ST_TO_ADDR
// end ; break ;
35546: GO 35550
// end ;
35548: GO 35363
35550: POP
35551: POP
// end else
35552: GO 36227
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35554: LD_VAR 0 3
35558: PPUSH
35559: LD_EXP 50
35563: PPUSH
35564: CALL 43201 0 2
35568: IFFALSE 35642
// begin for i = 1 to MREG_ToUpdate do
35570: LD_ADDR_VAR 0 2
35574: PUSH
35575: DOUBLE
35576: LD_INT 1
35578: DEC
35579: ST_TO_ADDR
35580: LD_EXP 50
35584: PUSH
35585: FOR_TO
35586: IFFALSE 35638
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35588: LD_EXP 50
35592: PUSH
35593: LD_VAR 0 2
35597: ARRAY
35598: PUSH
35599: LD_INT 1
35601: ARRAY
35602: PUSH
35603: LD_VAR 0 3
35607: EQUAL
35608: IFFALSE 35636
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35610: LD_VAR 0 3
35614: PPUSH
35615: LD_EXP 50
35619: PUSH
35620: LD_VAR 0 2
35624: ARRAY
35625: PUSH
35626: LD_INT 2
35628: ARRAY
35629: PPUSH
35630: CALL 8548 0 2
// break ;
35634: GO 35638
// end ;
35636: GO 35585
35638: POP
35639: POP
// end else
35640: GO 36227
// if MCF_Get ( side , [ f_constructed ] ) then
35642: LD_VAR 0 3
35646: PPUSH
35647: LD_INT 57
35649: PUSH
35650: EMPTY
35651: LIST
35652: PPUSH
35653: CALL 11448 0 2
35657: IFFALSE 35690
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35659: LD_VAR 0 3
35663: PPUSH
35664: LD_VAR 0 3
35668: PPUSH
35669: LD_INT 57
35671: PUSH
35672: EMPTY
35673: LIST
35674: PPUSH
35675: CALL 11448 0 2
35679: PUSH
35680: LD_INT 1
35682: ARRAY
35683: PPUSH
35684: CALL 10792 0 2
35688: GO 36227
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35690: LD_VAR 0 3
35694: PPUSH
35695: LD_EXP 48
35699: PPUSH
35700: CALL 43201 0 2
35704: PUSH
35705: LD_VAR 0 3
35709: PPUSH
35710: CALL_OW 345
35714: NOT
35715: AND
35716: PUSH
35717: LD_VAR 0 3
35721: PPUSH
35722: CALL 24849 0 1
35726: PUSH
35727: LD_INT 0
35729: EQUAL
35730: AND
35731: IFFALSE 36128
// begin for i = 1 to MREG_ToBuild do
35733: LD_ADDR_VAR 0 2
35737: PUSH
35738: DOUBLE
35739: LD_INT 1
35741: DEC
35742: ST_TO_ADDR
35743: LD_EXP 48
35747: PUSH
35748: FOR_TO
35749: IFFALSE 36124
// if MREG_ToBuild [ i ] [ 1 ] = side then
35751: LD_EXP 48
35755: PUSH
35756: LD_VAR 0 2
35760: ARRAY
35761: PUSH
35762: LD_INT 1
35764: ARRAY
35765: PUSH
35766: LD_VAR 0 3
35770: EQUAL
35771: IFFALSE 36122
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35773: LD_INT 1
35775: PUSH
35776: LD_EXP 48
35780: PUSH
35781: LD_VAR 0 2
35785: ARRAY
35786: PUSH
35787: LD_INT 3
35789: ARRAY
35790: PUSH
35791: LD_INT 1
35793: ARRAY
35794: PPUSH
35795: LD_EXP 48
35799: PUSH
35800: LD_VAR 0 2
35804: ARRAY
35805: PUSH
35806: LD_INT 3
35808: ARRAY
35809: PUSH
35810: LD_INT 2
35812: ARRAY
35813: PPUSH
35814: CALL_OW 351
35818: AND
35819: IFFALSE 35863
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35821: LD_EXP 48
35825: PUSH
35826: LD_VAR 0 2
35830: ARRAY
35831: PUSH
35832: LD_INT 3
35834: ARRAY
35835: PUSH
35836: LD_INT 1
35838: ARRAY
35839: PPUSH
35840: LD_EXP 48
35844: PUSH
35845: LD_VAR 0 2
35849: ARRAY
35850: PUSH
35851: LD_INT 3
35853: ARRAY
35854: PUSH
35855: LD_INT 2
35857: ARRAY
35858: PPUSH
35859: CALL 22596 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35863: LD_EXP 48
35867: PUSH
35868: LD_VAR 0 2
35872: ARRAY
35873: PUSH
35874: LD_INT 2
35876: ARRAY
35877: PUSH
35878: LD_INT 0
35880: EQUAL
35881: IFFALSE 35951
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35883: LD_VAR 0 3
35887: PPUSH
35888: LD_EXP 48
35892: PUSH
35893: LD_VAR 0 2
35897: ARRAY
35898: PUSH
35899: LD_INT 3
35901: ARRAY
35902: PUSH
35903: LD_INT 1
35905: ARRAY
35906: PPUSH
35907: LD_EXP 48
35911: PUSH
35912: LD_VAR 0 2
35916: ARRAY
35917: PUSH
35918: LD_INT 3
35920: ARRAY
35921: PUSH
35922: LD_INT 2
35924: ARRAY
35925: PPUSH
35926: LD_EXP 48
35930: PUSH
35931: LD_VAR 0 2
35935: ARRAY
35936: PUSH
35937: LD_INT 3
35939: ARRAY
35940: PUSH
35941: LD_INT 3
35943: ARRAY
35944: PPUSH
35945: CALL 8384 0 4
35949: GO 36120
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35951: LD_EXP 48
35955: PUSH
35956: LD_VAR 0 2
35960: ARRAY
35961: PUSH
35962: LD_INT 2
35964: ARRAY
35965: PUSH
35966: LD_INT 6
35968: EQUAL
35969: IFFALSE 36039
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35971: LD_VAR 0 3
35975: PPUSH
35976: LD_EXP 48
35980: PUSH
35981: LD_VAR 0 2
35985: ARRAY
35986: PUSH
35987: LD_INT 3
35989: ARRAY
35990: PUSH
35991: LD_INT 1
35993: ARRAY
35994: PPUSH
35995: LD_EXP 48
35999: PUSH
36000: LD_VAR 0 2
36004: ARRAY
36005: PUSH
36006: LD_INT 3
36008: ARRAY
36009: PUSH
36010: LD_INT 2
36012: ARRAY
36013: PPUSH
36014: LD_EXP 48
36018: PUSH
36019: LD_VAR 0 2
36023: ARRAY
36024: PUSH
36025: LD_INT 3
36027: ARRAY
36028: PUSH
36029: LD_INT 3
36031: ARRAY
36032: PPUSH
36033: CALL 8513 0 4
36037: GO 36120
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
36039: LD_VAR 0 3
36043: PPUSH
36044: LD_EXP 48
36048: PUSH
36049: LD_VAR 0 2
36053: ARRAY
36054: PUSH
36055: LD_INT 2
36057: ARRAY
36058: PPUSH
36059: LD_EXP 48
36063: PUSH
36064: LD_VAR 0 2
36068: ARRAY
36069: PUSH
36070: LD_INT 3
36072: ARRAY
36073: PUSH
36074: LD_INT 1
36076: ARRAY
36077: PPUSH
36078: LD_EXP 48
36082: PUSH
36083: LD_VAR 0 2
36087: ARRAY
36088: PUSH
36089: LD_INT 3
36091: ARRAY
36092: PUSH
36093: LD_INT 2
36095: ARRAY
36096: PPUSH
36097: LD_EXP 48
36101: PUSH
36102: LD_VAR 0 2
36106: ARRAY
36107: PUSH
36108: LD_INT 3
36110: ARRAY
36111: PUSH
36112: LD_INT 3
36114: ARRAY
36115: PPUSH
36116: CALL 10017 0 5
// break ;
36120: GO 36124
// end ;
36122: GO 35748
36124: POP
36125: POP
// end else
36126: GO 36227
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36128: LD_VAR 0 3
36132: PPUSH
36133: LD_EXP 54
36137: PPUSH
36138: CALL 43201 0 2
36142: PUSH
36143: LD_VAR 0 3
36147: PPUSH
36148: CALL 24849 0 1
36152: PUSH
36153: LD_INT 0
36155: EQUAL
36156: AND
36157: IFFALSE 36227
// begin for i = 1 to MREG_ToDismantle do
36159: LD_ADDR_VAR 0 2
36163: PUSH
36164: DOUBLE
36165: LD_INT 1
36167: DEC
36168: ST_TO_ADDR
36169: LD_EXP 54
36173: PUSH
36174: FOR_TO
36175: IFFALSE 36225
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36177: LD_EXP 54
36181: PUSH
36182: LD_VAR 0 2
36186: ARRAY
36187: PUSH
36188: LD_INT 1
36190: ARRAY
36191: PUSH
36192: LD_VAR 0 3
36196: EQUAL
36197: IFFALSE 36223
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36199: LD_VAR 0 3
36203: PPUSH
36204: LD_EXP 54
36208: PUSH
36209: LD_VAR 0 2
36213: ARRAY
36214: PUSH
36215: LD_INT 2
36217: ARRAY
36218: PPUSH
36219: CALL 10683 0 2
// end ;
36223: GO 36174
36225: POP
36226: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36227: LD_VAR 0 3
36231: PPUSH
36232: LD_INT 30
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PPUSH
36242: CALL 11448 0 2
36246: PUSH
36247: LD_VAR 0 3
36251: PPUSH
36252: CALL 24849 0 1
36256: PUSH
36257: LD_INT 0
36259: EQUAL
36260: AND
36261: IFFALSE 36272
// MCT_CollectCrates ( side ) ;
36263: LD_VAR 0 3
36267: PPUSH
36268: CALL 23788 0 1
// end ;
36272: GO 34275
36274: POP
36275: POP
// end ;
36276: LD_VAR 0 1
36280: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36281: LD_INT 0
36283: PPUSH
36284: PPUSH
36285: PPUSH
36286: PPUSH
36287: PPUSH
36288: PPUSH
36289: PPUSH
36290: PPUSH
36291: PPUSH
36292: PPUSH
36293: PPUSH
36294: PPUSH
36295: PPUSH
36296: PPUSH
36297: PPUSH
// all := MCF_All ( side , [ ] ) ;
36298: LD_ADDR_VAR 0 17
36302: PUSH
36303: LD_VAR 0 1
36307: PPUSH
36308: EMPTY
36309: PPUSH
36310: CALL 11583 0 2
36314: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36315: LD_ADDR_VAR 0 13
36319: PUSH
36320: LD_VAR 0 1
36324: PPUSH
36325: LD_INT 1
36327: PPUSH
36328: EMPTY
36329: PPUSH
36330: CALL 11531 0 3
36334: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36335: LD_ADDR_VAR 0 14
36339: PUSH
36340: LD_VAR 0 1
36344: PPUSH
36345: LD_INT 2
36347: PPUSH
36348: EMPTY
36349: PPUSH
36350: CALL 11531 0 3
36354: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36355: LD_ADDR_VAR 0 15
36359: PUSH
36360: LD_VAR 0 1
36364: PPUSH
36365: LD_INT 3
36367: PPUSH
36368: EMPTY
36369: PPUSH
36370: CALL 11531 0 3
36374: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36375: LD_ADDR_VAR 0 16
36379: PUSH
36380: LD_VAR 0 1
36384: PPUSH
36385: LD_INT 4
36387: PPUSH
36388: EMPTY
36389: PPUSH
36390: CALL 11531 0 3
36394: ST_TO_ADDR
// if mech then
36395: LD_VAR 0 15
36399: IFFALSE 36416
// mech := MCF_SortListDesc ( mech ) ;
36401: LD_ADDR_VAR 0 15
36405: PUSH
36406: LD_VAR 0 15
36410: PPUSH
36411: CALL 12697 0 1
36415: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36416: LD_EXP 58
36420: PUSH
36421: LD_VAR 0 1
36425: ARRAY
36426: PUSH
36427: LD_STRING 
36429: EQUAL
36430: NOT
36431: IFFALSE 36487
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36433: LD_EXP 58
36437: PUSH
36438: LD_VAR 0 1
36442: ARRAY
36443: PUSH
36444: LD_INT 1
36446: ARRAY
36447: PPUSH
36448: CALL_OW 257
36452: PUSH
36453: LD_INT 1
36455: EQUAL
36456: IFFALSE 36485
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36458: LD_VAR 0 1
36462: PPUSH
36463: LD_STRING ToArm
36465: PPUSH
36466: LD_EXP 58
36470: PUSH
36471: LD_VAR 0 1
36475: ARRAY
36476: PUSH
36477: LD_INT 1
36479: ARRAY
36480: PPUSH
36481: CALL 14327 0 3
// end else
36485: GO 36513
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36487: LD_ADDR_EXP 58
36491: PUSH
36492: LD_EXP 58
36496: PPUSH
36497: LD_VAR 0 1
36501: PPUSH
36502: LD_INT 1
36504: PPUSH
36505: LD_INT 0
36507: PPUSH
36508: CALL 30882 0 4
36512: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36513: LD_EXP 59
36517: PUSH
36518: LD_VAR 0 1
36522: ARRAY
36523: PUSH
36524: LD_STRING 
36526: EQUAL
36527: NOT
36528: IFFALSE 36584
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36530: LD_EXP 59
36534: PUSH
36535: LD_VAR 0 1
36539: ARRAY
36540: PUSH
36541: LD_INT 1
36543: ARRAY
36544: PPUSH
36545: CALL_OW 257
36549: PUSH
36550: LD_INT 2
36552: EQUAL
36553: IFFALSE 36582
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36555: LD_VAR 0 1
36559: PPUSH
36560: LD_STRING ToDep
36562: PPUSH
36563: LD_EXP 59
36567: PUSH
36568: LD_VAR 0 1
36572: ARRAY
36573: PUSH
36574: LD_INT 1
36576: ARRAY
36577: PPUSH
36578: CALL 14327 0 3
// end else
36582: GO 36610
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36584: LD_ADDR_EXP 59
36588: PUSH
36589: LD_EXP 59
36593: PPUSH
36594: LD_VAR 0 1
36598: PPUSH
36599: LD_INT 1
36601: PPUSH
36602: LD_INT 0
36604: PPUSH
36605: CALL 30882 0 4
36609: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36610: LD_EXP 57
36614: PUSH
36615: LD_VAR 0 1
36619: ARRAY
36620: PUSH
36621: LD_STRING 
36623: EQUAL
36624: NOT
36625: IFFALSE 36681
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36627: LD_EXP 57
36631: PUSH
36632: LD_VAR 0 1
36636: ARRAY
36637: PUSH
36638: LD_INT 1
36640: ARRAY
36641: PPUSH
36642: CALL_OW 257
36646: PUSH
36647: LD_INT 3
36649: EQUAL
36650: IFFALSE 36679
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36652: LD_VAR 0 1
36656: PPUSH
36657: LD_STRING ToFac
36659: PPUSH
36660: LD_EXP 57
36664: PUSH
36665: LD_VAR 0 1
36669: ARRAY
36670: PUSH
36671: LD_INT 1
36673: ARRAY
36674: PPUSH
36675: CALL 14327 0 3
// end else
36679: GO 36707
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36681: LD_ADDR_EXP 57
36685: PUSH
36686: LD_EXP 57
36690: PPUSH
36691: LD_VAR 0 1
36695: PPUSH
36696: LD_INT 1
36698: PPUSH
36699: LD_INT 0
36701: PPUSH
36702: CALL 30882 0 4
36706: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36707: LD_EXP 56
36711: PUSH
36712: LD_VAR 0 1
36716: ARRAY
36717: PUSH
36718: LD_STRING 
36720: EQUAL
36721: NOT
36722: IFFALSE 36778
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36724: LD_EXP 56
36728: PUSH
36729: LD_VAR 0 1
36733: ARRAY
36734: PUSH
36735: LD_INT 1
36737: ARRAY
36738: PPUSH
36739: CALL_OW 257
36743: PUSH
36744: LD_INT 4
36746: EQUAL
36747: IFFALSE 36776
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36749: LD_VAR 0 1
36753: PPUSH
36754: LD_STRING ToLab
36756: PPUSH
36757: LD_EXP 56
36761: PUSH
36762: LD_VAR 0 1
36766: ARRAY
36767: PUSH
36768: LD_INT 1
36770: ARRAY
36771: PPUSH
36772: CALL 14327 0 3
// end else
36776: GO 36804
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36778: LD_ADDR_EXP 56
36782: PUSH
36783: LD_EXP 56
36787: PPUSH
36788: LD_VAR 0 1
36792: PPUSH
36793: LD_INT 1
36795: PPUSH
36796: LD_INT 0
36798: PPUSH
36799: CALL 30882 0 4
36803: ST_TO_ADDR
// if mode = 0 then
36804: LD_VAR 0 2
36808: PUSH
36809: LD_INT 0
36811: EQUAL
36812: IFFALSE 38650
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36814: LD_VAR 0 1
36818: PPUSH
36819: LD_INT 30
36821: PUSH
36822: LD_INT 1
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PPUSH
36829: CALL 11448 0 2
36833: PUSH
36834: LD_VAR 0 1
36838: PPUSH
36839: LD_INT 21
36841: PUSH
36842: LD_INT 3
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PPUSH
36849: CALL 11448 0 2
36853: PUSH
36854: LD_INT 1
36856: EQUAL
36857: AND
36858: IFFALSE 36923
// begin if all then
36860: LD_VAR 0 17
36864: IFFALSE 36921
// for i in ( all diff eng ) do
36866: LD_ADDR_VAR 0 4
36870: PUSH
36871: LD_VAR 0 17
36875: PUSH
36876: LD_VAR 0 14
36880: DIFF
36881: PUSH
36882: FOR_IN
36883: IFFALSE 36919
// if GetTag ( i ) = 0 then
36885: LD_VAR 0 4
36889: PPUSH
36890: CALL_OW 110
36894: PUSH
36895: LD_INT 0
36897: EQUAL
36898: IFFALSE 36917
// MCH_ChangeClass ( side , i , 2 ) ;
36900: LD_VAR 0 1
36904: PPUSH
36905: LD_VAR 0 4
36909: PPUSH
36910: LD_INT 2
36912: PPUSH
36913: CALL 16355 0 3
36917: GO 36882
36919: POP
36920: POP
// end else
36921: GO 37242
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36923: LD_VAR 0 13
36927: PUSH
36928: LD_EXP 58
36932: PUSH
36933: LD_VAR 0 1
36937: ARRAY
36938: PLUS
36939: PUSH
36940: LD_INT 22
36942: PUSH
36943: LD_VAR 0 1
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 30
36954: PUSH
36955: LD_INT 32
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PPUSH
36966: CALL_OW 69
36970: LESS
36971: IFFALSE 36996
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36973: LD_VAR 0 1
36977: PPUSH
36978: LD_VAR 0 14
36982: PUSH
36983: LD_INT 1
36985: ARRAY
36986: PPUSH
36987: LD_INT 1
36989: PPUSH
36990: CALL 16355 0 3
// end else
36994: GO 37242
// if sci < 6 and MCF_Lab ( side ) then
36996: LD_VAR 0 16
37000: PUSH
37001: LD_INT 6
37003: LESS
37004: PUSH
37005: LD_VAR 0 1
37009: PPUSH
37010: CALL 11487 0 1
37014: AND
37015: IFFALSE 37120
// begin if MREG_ToBunker [ side ] then
37017: LD_EXP 70
37021: PUSH
37022: LD_VAR 0 1
37026: ARRAY
37027: IFFALSE 37053
// tmp := sol diff MREG_ToBunker [ side ] else
37029: LD_ADDR_VAR 0 12
37033: PUSH
37034: LD_VAR 0 13
37038: PUSH
37039: LD_EXP 70
37043: PUSH
37044: LD_VAR 0 1
37048: ARRAY
37049: DIFF
37050: ST_TO_ADDR
37051: GO 37063
// tmp := sol ;
37053: LD_ADDR_VAR 0 12
37057: PUSH
37058: LD_VAR 0 13
37062: ST_TO_ADDR
// if tmp then
37063: LD_VAR 0 12
37067: IFFALSE 37118
// for i in tmp do
37069: LD_ADDR_VAR 0 4
37073: PUSH
37074: LD_VAR 0 12
37078: PUSH
37079: FOR_IN
37080: IFFALSE 37116
// if GetTag ( i ) = 0 then
37082: LD_VAR 0 4
37086: PPUSH
37087: CALL_OW 110
37091: PUSH
37092: LD_INT 0
37094: EQUAL
37095: IFFALSE 37114
// MCH_ChangeClass ( side , i , 4 ) ;
37097: LD_VAR 0 1
37101: PPUSH
37102: LD_VAR 0 4
37106: PPUSH
37107: LD_INT 4
37109: PPUSH
37110: CALL 16355 0 3
37114: GO 37079
37116: POP
37117: POP
// end else
37118: GO 37242
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37120: LD_VAR 0 1
37124: PPUSH
37125: LD_INT 30
37127: PUSH
37128: LD_INT 1
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PPUSH
37135: CALL 11448 0 2
37139: IFFALSE 37242
// begin if MREG_ToBunker [ side ] then
37141: LD_EXP 70
37145: PUSH
37146: LD_VAR 0 1
37150: ARRAY
37151: IFFALSE 37177
// tmp := sol diff MREG_ToBunker [ side ] else
37153: LD_ADDR_VAR 0 12
37157: PUSH
37158: LD_VAR 0 13
37162: PUSH
37163: LD_EXP 70
37167: PUSH
37168: LD_VAR 0 1
37172: ARRAY
37173: DIFF
37174: ST_TO_ADDR
37175: GO 37187
// tmp := sol ;
37177: LD_ADDR_VAR 0 12
37181: PUSH
37182: LD_VAR 0 13
37186: ST_TO_ADDR
// if tmp then
37187: LD_VAR 0 12
37191: IFFALSE 37242
// for i in tmp do
37193: LD_ADDR_VAR 0 4
37197: PUSH
37198: LD_VAR 0 12
37202: PUSH
37203: FOR_IN
37204: IFFALSE 37240
// if GetTag ( i ) = 0 then
37206: LD_VAR 0 4
37210: PPUSH
37211: CALL_OW 110
37215: PUSH
37216: LD_INT 0
37218: EQUAL
37219: IFFALSE 37238
// MCH_ChangeClass ( side , i , 2 ) ;
37221: LD_VAR 0 1
37225: PPUSH
37226: LD_VAR 0 4
37230: PPUSH
37231: LD_INT 2
37233: PPUSH
37234: CALL 16355 0 3
37238: GO 37203
37240: POP
37241: POP
// end ; if MCF_Lab ( side ) then
37242: LD_VAR 0 1
37246: PPUSH
37247: CALL 11487 0 1
37251: IFFALSE 37791
// begin if MCL_GetTechList ( side ) then
37253: LD_VAR 0 1
37257: PPUSH
37258: CALL 17831 0 1
37262: IFFALSE 37388
// begin if MREG_ToLab [ side ] then
37264: LD_EXP 56
37268: PUSH
37269: LD_VAR 0 1
37273: ARRAY
37274: IFFALSE 37294
// k := MREG_ToLab [ side ] else
37276: LD_ADDR_VAR 0 8
37280: PUSH
37281: LD_EXP 56
37285: PUSH
37286: LD_VAR 0 1
37290: ARRAY
37291: ST_TO_ADDR
37292: GO 37302
// k := 0 ;
37294: LD_ADDR_VAR 0 8
37298: PUSH
37299: LD_INT 0
37301: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37302: LD_VAR 0 16
37306: PUSH
37307: LD_VAR 0 8
37311: PLUS
37312: PUSH
37313: LD_INT 6
37315: LESSEQUAL
37316: PUSH
37317: LD_VAR 0 17
37321: PUSH
37322: LD_INT 6
37324: GREATER
37325: AND
37326: IFFALSE 37342
// MCH_TrainScientist ( side , 1 ) else
37328: LD_VAR 0 1
37332: PPUSH
37333: LD_INT 1
37335: PPUSH
37336: CALL 15907 0 2
37340: GO 37386
// if all < 6 then
37342: LD_VAR 0 17
37346: PUSH
37347: LD_INT 6
37349: LESS
37350: IFFALSE 37386
// if sci + k < all / 2 then
37352: LD_VAR 0 16
37356: PUSH
37357: LD_VAR 0 8
37361: PLUS
37362: PUSH
37363: LD_VAR 0 17
37367: PUSH
37368: LD_INT 2
37370: DIVREAL
37371: LESS
37372: IFFALSE 37386
// MCH_TrainScientist ( side , 1 ) ;
37374: LD_VAR 0 1
37378: PPUSH
37379: LD_INT 1
37381: PPUSH
37382: CALL 15907 0 2
// end else
37386: GO 37464
// begin if sci > 2 then
37388: LD_VAR 0 16
37392: PUSH
37393: LD_INT 2
37395: GREATER
37396: IFFALSE 37464
// for i = sci downto 2 do
37398: LD_ADDR_VAR 0 4
37402: PUSH
37403: DOUBLE
37404: LD_VAR 0 16
37408: INC
37409: ST_TO_ADDR
37410: LD_INT 2
37412: PUSH
37413: FOR_DOWNTO
37414: IFFALSE 37462
// if GetTag ( sci [ i ] ) = 0 then
37416: LD_VAR 0 16
37420: PUSH
37421: LD_VAR 0 4
37425: ARRAY
37426: PPUSH
37427: CALL_OW 110
37431: PUSH
37432: LD_INT 0
37434: EQUAL
37435: IFFALSE 37460
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37437: LD_VAR 0 1
37441: PPUSH
37442: LD_VAR 0 16
37446: PUSH
37447: LD_VAR 0 4
37451: ARRAY
37452: PPUSH
37453: LD_INT 2
37455: PPUSH
37456: CALL 16355 0 3
37460: GO 37413
37462: POP
37463: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37464: LD_VAR 0 1
37468: PPUSH
37469: CALL 17831 0 1
37473: PUSH
37474: LD_VAR 0 1
37478: PPUSH
37479: CALL 11487 0 1
37483: AND
37484: PUSH
37485: LD_EXP 37
37489: PUSH
37490: LD_VAR 0 1
37494: ARRAY
37495: NOT
37496: AND
37497: IFFALSE 37791
// begin for j = 1 to MCF_Lab ( side ) do
37499: LD_ADDR_VAR 0 5
37503: PUSH
37504: DOUBLE
37505: LD_INT 1
37507: DEC
37508: ST_TO_ADDR
37509: LD_VAR 0 1
37513: PPUSH
37514: CALL 11487 0 1
37518: PUSH
37519: FOR_TO
37520: IFFALSE 37580
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37522: LD_VAR 0 1
37526: PPUSH
37527: CALL 11487 0 1
37531: PUSH
37532: LD_VAR 0 5
37536: ARRAY
37537: PPUSH
37538: CALL_OW 461
37542: PUSH
37543: LD_INT 3
37545: PUSH
37546: LD_INT 6
37548: PUSH
37549: EMPTY
37550: LIST
37551: LIST
37552: IN
37553: IFFALSE 37578
// begin b := MCF_Lab ( side ) [ j ] ;
37555: LD_ADDR_VAR 0 11
37559: PUSH
37560: LD_VAR 0 1
37564: PPUSH
37565: CALL 11487 0 1
37569: PUSH
37570: LD_VAR 0 5
37574: ARRAY
37575: ST_TO_ADDR
// break ;
37576: GO 37580
// end ;
37578: GO 37519
37580: POP
37581: POP
// if MCF_Class ( side , 4 , [ ] ) then
37582: LD_VAR 0 1
37586: PPUSH
37587: LD_INT 4
37589: PPUSH
37590: EMPTY
37591: PPUSH
37592: CALL 11531 0 3
37596: IFFALSE 37791
// for j in MCF_Class ( side , 4 , [ ] ) do
37598: LD_ADDR_VAR 0 5
37602: PUSH
37603: LD_VAR 0 1
37607: PPUSH
37608: LD_INT 4
37610: PPUSH
37611: EMPTY
37612: PPUSH
37613: CALL 11531 0 3
37617: PUSH
37618: FOR_IN
37619: IFFALSE 37789
// begin if GetTag ( j ) = 0 then
37621: LD_VAR 0 5
37625: PPUSH
37626: CALL_OW 110
37630: PUSH
37631: LD_INT 0
37633: EQUAL
37634: IFFALSE 37725
// begin if IsInUnit ( j ) and b then
37636: LD_VAR 0 5
37640: PPUSH
37641: CALL_OW 310
37645: PUSH
37646: LD_VAR 0 11
37650: AND
37651: IFFALSE 37699
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37653: LD_VAR 0 5
37657: PPUSH
37658: CALL_OW 310
37662: PPUSH
37663: CALL_OW 461
37667: PUSH
37668: LD_INT 2
37670: EQUAL
37671: PUSH
37672: LD_VAR 0 5
37676: PPUSH
37677: CALL_OW 310
37681: PUSH
37682: LD_VAR 0 11
37686: NONEQUAL
37687: AND
37688: IFFALSE 37699
// ComExitBuilding ( j ) ;
37690: LD_VAR 0 5
37694: PPUSH
37695: CALL_OW 122
// if not IsInUnit ( j ) then
37699: LD_VAR 0 5
37703: PPUSH
37704: CALL_OW 310
37708: NOT
37709: IFFALSE 37725
// ComEnterUnit ( j , b ) ;
37711: LD_VAR 0 5
37715: PPUSH
37716: LD_VAR 0 11
37720: PPUSH
37721: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37725: LD_INT 1
37727: PPUSH
37728: LD_VAR 0 5
37732: PPUSH
37733: CALL_OW 255
37737: PPUSH
37738: CALL_OW 321
37742: PUSH
37743: LD_INT 2
37745: EQUAL
37746: PUSH
37747: LD_VAR 0 5
37751: PPUSH
37752: CALL_OW 255
37756: PPUSH
37757: CALL 24849 0 1
37761: PUSH
37762: LD_INT 0
37764: EQUAL
37765: AND
37766: IFFALSE 37787
// MCN_Tame ( GetSide ( j ) , j ) ;
37768: LD_VAR 0 5
37772: PPUSH
37773: CALL_OW 255
37777: PPUSH
37778: LD_VAR 0 5
37782: PPUSH
37783: CALL 18350 0 2
// end ;
37787: GO 37618
37789: POP
37790: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37791: LD_VAR 0 1
37795: PPUSH
37796: LD_INT 30
37798: PUSH
37799: LD_INT 3
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PPUSH
37806: CALL 11448 0 2
37810: IFFALSE 38069
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37812: LD_ADDR_VAR 0 11
37816: PUSH
37817: LD_VAR 0 1
37821: PPUSH
37822: LD_INT 30
37824: PUSH
37825: LD_INT 3
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PPUSH
37832: CALL 11448 0 2
37836: PUSH
37837: LD_INT 1
37839: ARRAY
37840: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37841: LD_ADDR_VAR 0 12
37845: PUSH
37846: LD_VAR 0 1
37850: PPUSH
37851: LD_INT 0
37853: PPUSH
37854: LD_INT 25
37856: PUSH
37857: LD_INT 3
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PPUSH
37864: CALL 12151 0 3
37868: ST_TO_ADDR
// for i = 1 to tmp do
37869: LD_ADDR_VAR 0 4
37873: PUSH
37874: DOUBLE
37875: LD_INT 1
37877: DEC
37878: ST_TO_ADDR
37879: LD_VAR 0 12
37883: PUSH
37884: FOR_TO
37885: IFFALSE 37945
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37887: LD_VAR 0 12
37891: PUSH
37892: LD_VAR 0 4
37896: ARRAY
37897: PPUSH
37898: CALL_OW 310
37902: NOT
37903: PUSH
37904: LD_VAR 0 12
37908: PUSH
37909: LD_VAR 0 4
37913: ARRAY
37914: PPUSH
37915: CALL_OW 314
37919: NOT
37920: AND
37921: IFFALSE 37943
// ComEnterUnit ( tmp [ i ] , b ) ;
37923: LD_VAR 0 12
37927: PUSH
37928: LD_VAR 0 4
37932: ARRAY
37933: PPUSH
37934: LD_VAR 0 11
37938: PPUSH
37939: CALL_OW 120
37943: GO 37884
37945: POP
37946: POP
// if MREG_ToFac [ side ] then
37947: LD_EXP 57
37951: PUSH
37952: LD_VAR 0 1
37956: ARRAY
37957: IFFALSE 37977
// k := MREG_ToFac [ side ] else
37959: LD_ADDR_VAR 0 8
37963: PUSH
37964: LD_EXP 57
37968: PUSH
37969: LD_VAR 0 1
37973: ARRAY
37974: ST_TO_ADDR
37975: GO 37985
// k := 0 ;
37977: LD_ADDR_VAR 0 8
37981: PUSH
37982: LD_INT 0
37984: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37985: LD_VAR 0 15
37989: PUSH
37990: LD_VAR 0 8
37994: PLUS
37995: PUSH
37996: LD_INT 6
37998: LESSEQUAL
37999: PUSH
38000: LD_VAR 0 17
38004: PUSH
38005: LD_INT 6
38007: GREATER
38008: AND
38009: IFFALSE 38025
// MCH_TrainMechanic ( side , 1 ) else
38011: LD_VAR 0 1
38015: PPUSH
38016: LD_INT 1
38018: PPUSH
38019: CALL 15649 0 2
38023: GO 38069
// if all < 6 then
38025: LD_VAR 0 17
38029: PUSH
38030: LD_INT 6
38032: LESS
38033: IFFALSE 38069
// if mech + k < all / 2 then
38035: LD_VAR 0 15
38039: PUSH
38040: LD_VAR 0 8
38044: PLUS
38045: PUSH
38046: LD_VAR 0 17
38050: PUSH
38051: LD_INT 2
38053: DIVREAL
38054: LESS
38055: IFFALSE 38069
// MCH_TrainMechanic ( side , 1 ) ;
38057: LD_VAR 0 1
38061: PPUSH
38062: LD_INT 1
38064: PPUSH
38065: CALL 15649 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38069: LD_ADDR_VAR 0 10
38073: PUSH
38074: LD_VAR 0 1
38078: PPUSH
38079: LD_INT 30
38081: PUSH
38082: LD_INT 36
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PPUSH
38089: CALL 11448 0 2
38093: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38094: LD_VAR 0 10
38098: PUSH
38099: LD_VAR 0 15
38103: AND
38104: PUSH
38105: LD_VAR 0 1
38109: PPUSH
38110: LD_INT 3
38112: PPUSH
38113: EMPTY
38114: PPUSH
38115: CALL 11531 0 3
38119: AND
38120: IFFALSE 38278
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38122: LD_VAR 0 1
38126: PPUSH
38127: LD_INT 9
38129: PPUSH
38130: EMPTY
38131: PPUSH
38132: CALL 12151 0 3
38136: PUSH
38137: LD_INT 3
38139: LESS
38140: IFFALSE 38278
// begin if mech < 3 then
38142: LD_VAR 0 15
38146: PUSH
38147: LD_INT 3
38149: LESS
38150: IFFALSE 38164
// k := mech else
38152: LD_ADDR_VAR 0 8
38156: PUSH
38157: LD_VAR 0 15
38161: ST_TO_ADDR
38162: GO 38172
// k := 3 ;
38164: LD_ADDR_VAR 0 8
38168: PUSH
38169: LD_INT 3
38171: ST_TO_ADDR
// for j = 1 to k do
38172: LD_ADDR_VAR 0 5
38176: PUSH
38177: DOUBLE
38178: LD_INT 1
38180: DEC
38181: ST_TO_ADDR
38182: LD_VAR 0 8
38186: PUSH
38187: FOR_TO
38188: IFFALSE 38246
// if GetClass ( mech [ j ] ) = 3 then
38190: LD_VAR 0 15
38194: PUSH
38195: LD_VAR 0 5
38199: ARRAY
38200: PPUSH
38201: CALL_OW 257
38205: PUSH
38206: LD_INT 3
38208: EQUAL
38209: IFFALSE 38244
// begin SetTag ( mech [ j ] , 9 ) ;
38211: LD_VAR 0 15
38215: PUSH
38216: LD_VAR 0 5
38220: ARRAY
38221: PPUSH
38222: LD_INT 9
38224: PPUSH
38225: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38229: LD_VAR 0 15
38233: PUSH
38234: LD_VAR 0 5
38238: ARRAY
38239: PPUSH
38240: CALL_OW 122
// end ;
38244: GO 38187
38246: POP
38247: POP
// if mech < 6 + k then
38248: LD_VAR 0 15
38252: PUSH
38253: LD_INT 6
38255: PUSH
38256: LD_VAR 0 8
38260: PLUS
38261: LESS
38262: IFFALSE 38278
// MCH_TrainMechanic ( side , k ) ;
38264: LD_VAR 0 1
38268: PPUSH
38269: LD_VAR 0 8
38273: PPUSH
38274: CALL 15649 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38278: LD_VAR 0 1
38282: PPUSH
38283: LD_INT 9
38285: PPUSH
38286: EMPTY
38287: PPUSH
38288: CALL 12151 0 3
38292: IFFALSE 38383
// for j in MCF_Tag ( side , 9 , [ ] ) do
38294: LD_ADDR_VAR 0 5
38298: PUSH
38299: LD_VAR 0 1
38303: PPUSH
38304: LD_INT 9
38306: PPUSH
38307: EMPTY
38308: PPUSH
38309: CALL 12151 0 3
38313: PUSH
38314: FOR_IN
38315: IFFALSE 38381
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38317: LD_VAR 0 5
38321: PPUSH
38322: CALL_OW 310
38326: NOT
38327: PUSH
38328: LD_VAR 0 5
38332: PPUSH
38333: CALL 31525 0 1
38337: NOT
38338: AND
38339: IFFALSE 38379
// if ct then
38341: LD_VAR 0 10
38345: IFFALSE 38367
// ComEnterUnit ( j , ct [ 1 ] ) else
38347: LD_VAR 0 5
38351: PPUSH
38352: LD_VAR 0 10
38356: PUSH
38357: LD_INT 1
38359: ARRAY
38360: PPUSH
38361: CALL_OW 120
38365: GO 38379
// SetTag ( j , 0 ) ;
38367: LD_VAR 0 5
38371: PPUSH
38372: LD_INT 0
38374: PPUSH
38375: CALL_OW 109
38379: GO 38314
38381: POP
38382: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38383: LD_INT 1
38385: PPUSH
38386: LD_VAR 0 1
38390: PPUSH
38391: CALL_OW 321
38395: PUSH
38396: LD_INT 2
38398: EQUAL
38399: PUSH
38400: LD_EXP 37
38404: PUSH
38405: LD_VAR 0 1
38409: ARRAY
38410: NOT
38411: AND
38412: PUSH
38413: LD_VAR 0 1
38417: PPUSH
38418: LD_INT 4
38420: PPUSH
38421: EMPTY
38422: PPUSH
38423: CALL 11531 0 3
38427: AND
38428: IFFALSE 38476
// for j in MCF_Class ( side , 4 , [ ] ) do
38430: LD_ADDR_VAR 0 5
38434: PUSH
38435: LD_VAR 0 1
38439: PPUSH
38440: LD_INT 4
38442: PPUSH
38443: EMPTY
38444: PPUSH
38445: CALL 11531 0 3
38449: PUSH
38450: FOR_IN
38451: IFFALSE 38474
// MCN_Tame ( GetSide ( j ) , j ) ;
38453: LD_VAR 0 5
38457: PPUSH
38458: CALL_OW 255
38462: PPUSH
38463: LD_VAR 0 5
38467: PPUSH
38468: CALL 18350 0 2
38472: GO 38450
38474: POP
38475: POP
// if MREG_DefVeh [ side ] then
38476: LD_EXP 69
38480: PUSH
38481: LD_VAR 0 1
38485: ARRAY
38486: IFFALSE 38650
// begin for i in MREG_DefVeh [ side ] do
38488: LD_ADDR_VAR 0 4
38492: PUSH
38493: LD_EXP 69
38497: PUSH
38498: LD_VAR 0 1
38502: ARRAY
38503: PUSH
38504: FOR_IN
38505: IFFALSE 38558
// begin SetTag ( i , 0 ) ;
38507: LD_VAR 0 4
38511: PPUSH
38512: LD_INT 0
38514: PPUSH
38515: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38519: LD_VAR 0 4
38523: PPUSH
38524: LD_EXP 66
38528: PUSH
38529: LD_VAR 0 1
38533: ARRAY
38534: PPUSH
38535: CALL_OW 308
38539: NOT
38540: IFFALSE 38556
// MCV_Parking ( side , i ) ;
38542: LD_VAR 0 1
38546: PPUSH
38547: LD_VAR 0 4
38551: PPUSH
38552: CALL 25609 0 2
// end ;
38556: GO 38504
38558: POP
38559: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38560: LD_VAR 0 1
38564: PPUSH
38565: LD_INT 36
38567: PPUSH
38568: EMPTY
38569: PPUSH
38570: CALL 12151 0 3
38574: IFFALSE 38615
// for i in MCF_Tag ( side , 36 , [ ] ) do
38576: LD_ADDR_VAR 0 4
38580: PUSH
38581: LD_VAR 0 1
38585: PPUSH
38586: LD_INT 36
38588: PPUSH
38589: EMPTY
38590: PPUSH
38591: CALL 12151 0 3
38595: PUSH
38596: FOR_IN
38597: IFFALSE 38613
// SetTag ( i , 0 ) ;
38599: LD_VAR 0 4
38603: PPUSH
38604: LD_INT 0
38606: PPUSH
38607: CALL_OW 109
38611: GO 38596
38613: POP
38614: POP
// if MREG_DefMobActive [ side ] then
38615: LD_EXP 72
38619: PUSH
38620: LD_VAR 0 1
38624: ARRAY
38625: IFFALSE 38650
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38627: LD_ADDR_EXP 72
38631: PUSH
38632: LD_EXP 72
38636: PPUSH
38637: LD_VAR 0 1
38641: PPUSH
38642: LD_INT 0
38644: PPUSH
38645: CALL_OW 1
38649: ST_TO_ADDR
// end ; end ; if mode > 0 then
38650: LD_VAR 0 2
38654: PUSH
38655: LD_INT 0
38657: GREATER
38658: IFFALSE 40673
// begin if tick <= 15 15$00 then
38660: LD_OWVAR 1
38664: PUSH
38665: LD_INT 31500
38667: LESSEQUAL
38668: IFFALSE 39092
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38670: LD_VAR 0 13
38674: PUSH
38675: LD_INT 4
38677: GREATER
38678: PUSH
38679: LD_VAR 0 1
38683: PPUSH
38684: CALL 24849 0 1
38688: PUSH
38689: LD_INT 4
38691: LESS
38692: AND
38693: IFFALSE 38804
// for i in sol do
38695: LD_ADDR_VAR 0 4
38699: PUSH
38700: LD_VAR 0 13
38704: PUSH
38705: FOR_IN
38706: IFFALSE 38802
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38708: LD_ADDR_VAR 0 8
38712: PUSH
38713: LD_VAR 0 1
38717: PPUSH
38718: CALL 24849 0 1
38722: PPUSH
38723: LD_VAR 0 4
38727: PPUSH
38728: CALL_OW 74
38732: ST_TO_ADDR
// if IsInUnit ( i ) then
38733: LD_VAR 0 4
38737: PPUSH
38738: CALL_OW 310
38742: IFFALSE 38753
// ComExitBuilding ( i ) ;
38744: LD_VAR 0 4
38748: PPUSH
38749: CALL_OW 122
// if not HasTask ( i ) and k then
38753: LD_VAR 0 4
38757: PPUSH
38758: CALL_OW 314
38762: NOT
38763: PUSH
38764: LD_VAR 0 8
38768: AND
38769: IFFALSE 38800
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38771: LD_VAR 0 4
38775: PPUSH
38776: LD_VAR 0 8
38780: PPUSH
38781: CALL_OW 250
38785: PPUSH
38786: LD_VAR 0 8
38790: PPUSH
38791: CALL_OW 251
38795: PPUSH
38796: CALL_OW 114
// end ;
38800: GO 38705
38802: POP
38803: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38804: LD_VAR 0 1
38808: PPUSH
38809: LD_INT 30
38811: PUSH
38812: LD_INT 5
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PPUSH
38819: CALL 11448 0 2
38823: IFFALSE 39090
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38825: LD_ADDR_VAR 0 11
38829: PUSH
38830: LD_VAR 0 1
38834: PPUSH
38835: LD_INT 30
38837: PUSH
38838: LD_INT 5
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PPUSH
38845: CALL 11448 0 2
38849: PUSH
38850: LD_INT 1
38852: ARRAY
38853: ST_TO_ADDR
// if mech then
38854: LD_VAR 0 15
38858: IFFALSE 38894
// for i in mech do
38860: LD_ADDR_VAR 0 4
38864: PUSH
38865: LD_VAR 0 15
38869: PUSH
38870: FOR_IN
38871: IFFALSE 38892
// MCH_ChangeClass ( side , i , 1 ) ;
38873: LD_VAR 0 1
38877: PPUSH
38878: LD_VAR 0 4
38882: PPUSH
38883: LD_INT 1
38885: PPUSH
38886: CALL 16355 0 3
38890: GO 38870
38892: POP
38893: POP
// if eng > 1 then
38894: LD_VAR 0 14
38898: PUSH
38899: LD_INT 1
38901: GREATER
38902: IFFALSE 38949
// for i = eng downto 2 do
38904: LD_ADDR_VAR 0 4
38908: PUSH
38909: DOUBLE
38910: LD_VAR 0 14
38914: INC
38915: ST_TO_ADDR
38916: LD_INT 2
38918: PUSH
38919: FOR_DOWNTO
38920: IFFALSE 38947
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38922: LD_VAR 0 1
38926: PPUSH
38927: LD_VAR 0 14
38931: PUSH
38932: LD_VAR 0 4
38936: ARRAY
38937: PPUSH
38938: LD_INT 1
38940: PPUSH
38941: CALL 16355 0 3
38945: GO 38919
38947: POP
38948: POP
// if UnitsInside ( b ) = 6 then
38949: LD_VAR 0 11
38953: PPUSH
38954: CALL_OW 313
38958: PUSH
38959: LD_INT 6
38961: EQUAL
38962: IFFALSE 39090
// begin un := UnitsInside ( b ) [ 1 ] ;
38964: LD_ADDR_VAR 0 9
38968: PUSH
38969: LD_VAR 0 11
38973: PPUSH
38974: CALL_OW 313
38978: PUSH
38979: LD_INT 1
38981: ARRAY
38982: ST_TO_ADDR
// ComExitBuilding ( un ) ;
38983: LD_VAR 0 9
38987: PPUSH
38988: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
38992: LD_VAR 0 1
38996: PPUSH
38997: LD_INT 30
38999: PUSH
39000: LD_INT 5
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PPUSH
39007: CALL 11448 0 2
39011: PUSH
39012: LD_INT 1
39014: GREATER
39015: PUSH
39016: LD_VAR 0 1
39020: PPUSH
39021: CALL 24849 0 1
39025: PUSH
39026: LD_INT 4
39028: GREATEREQUAL
39029: AND
39030: IFFALSE 39090
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39032: LD_ADDR_VAR 0 8
39036: PUSH
39037: LD_VAR 0 1
39041: PPUSH
39042: LD_INT 30
39044: PUSH
39045: LD_INT 5
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PPUSH
39052: CALL 11448 0 2
39056: PUSH
39057: LD_INT 2
39059: ARRAY
39060: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
39061: LD_VAR 0 8
39065: PPUSH
39066: CALL_OW 313
39070: PUSH
39071: LD_INT 6
39073: LESS
39074: IFFALSE 39090
// AddComEnterUnit ( un , k ) ;
39076: LD_VAR 0 9
39080: PPUSH
39081: LD_VAR 0 8
39085: PPUSH
39086: CALL_OW 180
// end ; end ; end ; end else
39090: GO 40673
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39092: LD_VAR 0 1
39096: PPUSH
39097: LD_INT 1
39099: PPUSH
39100: LD_EXP 67
39104: PUSH
39105: LD_VAR 0 1
39109: ARRAY
39110: PUSH
39111: LD_INT 1
39113: ARRAY
39114: PPUSH
39115: CALL 33827 0 3
39119: IFFALSE 39258
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39121: LD_ADDR_VAR 0 12
39125: PUSH
39126: LD_VAR 0 1
39130: PPUSH
39131: LD_INT 21
39133: PUSH
39134: LD_INT 1
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PPUSH
39141: CALL 11448 0 2
39145: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39146: LD_ADDR_VAR 0 11
39150: PUSH
39151: LD_VAR 0 1
39155: PPUSH
39156: LD_INT 30
39158: PUSH
39159: LD_INT 1
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PPUSH
39166: CALL 11448 0 2
39170: ST_TO_ADDR
// if b then
39171: LD_VAR 0 11
39175: IFFALSE 39258
// for i in tmp do
39177: LD_ADDR_VAR 0 4
39181: PUSH
39182: LD_VAR 0 12
39186: PUSH
39187: FOR_IN
39188: IFFALSE 39256
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39190: LD_VAR 0 4
39194: PPUSH
39195: LD_EXP 67
39199: PUSH
39200: LD_VAR 0 1
39204: ARRAY
39205: PUSH
39206: LD_INT 1
39208: ARRAY
39209: PPUSH
39210: CALL_OW 308
39214: NOT
39215: IFFALSE 39254
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39217: LD_VAR 0 4
39221: PPUSH
39222: LD_VAR 0 11
39226: PUSH
39227: LD_INT 1
39229: ARRAY
39230: PPUSH
39231: CALL_OW 250
39235: PPUSH
39236: LD_VAR 0 11
39240: PUSH
39241: LD_INT 1
39243: ARRAY
39244: PPUSH
39245: CALL_OW 251
39249: PPUSH
39250: CALL_OW 111
39254: GO 39187
39256: POP
39257: POP
// end ; if MREG_DefVeh [ side ] then
39258: LD_EXP 69
39262: PUSH
39263: LD_VAR 0 1
39267: ARRAY
39268: IFFALSE 39836
// begin tmp := [ ] ;
39270: LD_ADDR_VAR 0 12
39274: PUSH
39275: EMPTY
39276: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39277: LD_EXP 72
39281: PUSH
39282: LD_VAR 0 1
39286: ARRAY
39287: PUSH
39288: LD_INT 0
39290: EQUAL
39291: IFFALSE 39431
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39293: LD_ADDR_VAR 0 8
39297: PUSH
39298: LD_VAR 0 1
39302: PPUSH
39303: LD_INT 0
39305: PPUSH
39306: LD_INT 25
39308: PUSH
39309: LD_INT 3
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PPUSH
39316: CALL 12151 0 3
39320: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39321: LD_VAR 0 8
39325: PUSH
39326: LD_EXP 69
39330: PUSH
39331: LD_VAR 0 1
39335: ARRAY
39336: GREATER
39337: IFFALSE 39398
// begin for i = 1 to MREG_DefVeh [ side ] do
39339: LD_ADDR_VAR 0 4
39343: PUSH
39344: DOUBLE
39345: LD_INT 1
39347: DEC
39348: ST_TO_ADDR
39349: LD_EXP 69
39353: PUSH
39354: LD_VAR 0 1
39358: ARRAY
39359: PUSH
39360: FOR_TO
39361: IFFALSE 39394
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39363: LD_ADDR_VAR 0 12
39367: PUSH
39368: LD_VAR 0 12
39372: PPUSH
39373: LD_INT 1
39375: PPUSH
39376: LD_VAR 0 8
39380: PUSH
39381: LD_VAR 0 4
39385: ARRAY
39386: PPUSH
39387: CALL_OW 2
39391: ST_TO_ADDR
39392: GO 39360
39394: POP
39395: POP
// end else
39396: GO 39408
// tmp := k ;
39398: LD_ADDR_VAR 0 12
39402: PUSH
39403: LD_VAR 0 8
39407: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39408: LD_ADDR_EXP 72
39412: PUSH
39413: LD_EXP 72
39417: PPUSH
39418: LD_VAR 0 1
39422: PPUSH
39423: LD_INT 1
39425: PPUSH
39426: CALL_OW 1
39430: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39431: LD_ADDR_VAR 0 4
39435: PUSH
39436: LD_EXP 69
39440: PUSH
39441: LD_VAR 0 1
39445: ARRAY
39446: PUSH
39447: FOR_IN
39448: IFFALSE 39834
// begin if not GetDriver ( i ) then
39450: LD_VAR 0 4
39454: PPUSH
39455: CALL 31576 0 1
39459: NOT
39460: IFFALSE 39535
// begin if tmp then
39462: LD_VAR 0 12
39466: IFFALSE 39533
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39468: LD_VAR 0 12
39472: PUSH
39473: LD_INT 1
39475: ARRAY
39476: PPUSH
39477: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39481: LD_VAR 0 12
39485: PUSH
39486: LD_INT 1
39488: ARRAY
39489: PPUSH
39490: LD_VAR 0 4
39494: PPUSH
39495: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39499: LD_VAR 0 12
39503: PUSH
39504: LD_INT 1
39506: ARRAY
39507: PPUSH
39508: LD_INT 36
39510: PPUSH
39511: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39515: LD_ADDR_VAR 0 12
39519: PUSH
39520: LD_VAR 0 12
39524: PPUSH
39525: LD_INT 1
39527: PPUSH
39528: CALL_OW 3
39532: ST_TO_ADDR
// end ; end else
39533: GO 39832
// begin if GetTag ( i ) = 0 then
39535: LD_VAR 0 4
39539: PPUSH
39540: CALL_OW 110
39544: PUSH
39545: LD_INT 0
39547: EQUAL
39548: IFFALSE 39564
// SetTag ( i , 31 ) else
39550: LD_VAR 0 4
39554: PPUSH
39555: LD_INT 31
39557: PPUSH
39558: CALL_OW 109
39562: GO 39832
// if GetTag ( i ) = 31 then
39564: LD_VAR 0 4
39568: PPUSH
39569: CALL_OW 110
39573: PUSH
39574: LD_INT 31
39576: EQUAL
39577: IFFALSE 39832
// begin if GetFuel ( i ) < 20 then
39579: LD_VAR 0 4
39583: PPUSH
39584: CALL_OW 261
39588: PUSH
39589: LD_INT 20
39591: LESS
39592: IFFALSE 39617
// begin SetTag ( i , 21 ) ;
39594: LD_VAR 0 4
39598: PPUSH
39599: LD_INT 21
39601: PPUSH
39602: CALL_OW 109
// MCV_Refuel ( i ) ;
39606: LD_VAR 0 4
39610: PPUSH
39611: CALL 26146 0 1
// continue ;
39615: GO 39447
// end ; if GetLives ( i ) < 700 then
39617: LD_VAR 0 4
39621: PPUSH
39622: CALL_OW 256
39626: PUSH
39627: LD_INT 700
39629: LESS
39630: IFFALSE 39742
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39632: LD_VAR 0 4
39636: PPUSH
39637: LD_EXP 60
39641: PUSH
39642: LD_VAR 0 1
39646: ARRAY
39647: PPUSH
39648: CALL_OW 308
39652: NOT
39653: IFFALSE 39677
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39655: LD_VAR 0 4
39659: PPUSH
39660: LD_EXP 60
39664: PUSH
39665: LD_VAR 0 1
39669: ARRAY
39670: PPUSH
39671: CALL_OW 113
39675: GO 39740
// if GetDriver ( i ) then
39677: LD_VAR 0 4
39681: PPUSH
39682: CALL 31576 0 1
39686: IFFALSE 39740
// begin k := GetDriver ( i ) ;
39688: LD_ADDR_VAR 0 8
39692: PUSH
39693: LD_VAR 0 4
39697: PPUSH
39698: CALL 31576 0 1
39702: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39703: LD_VAR 0 8
39707: PPUSH
39708: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39712: LD_VAR 0 8
39716: PPUSH
39717: LD_VAR 0 4
39721: PPUSH
39722: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39726: LD_VAR 0 8
39730: PPUSH
39731: LD_VAR 0 4
39735: PPUSH
39736: CALL_OW 180
// end ; end else
39740: GO 39832
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39742: LD_ADDR_VAR 0 8
39746: PUSH
39747: LD_VAR 0 1
39751: PPUSH
39752: CALL 24849 0 1
39756: PPUSH
39757: LD_VAR 0 4
39761: PPUSH
39762: CALL_OW 74
39766: ST_TO_ADDR
// if k then
39767: LD_VAR 0 8
39771: IFFALSE 39789
// ComAttackUnit ( i , k ) else
39773: LD_VAR 0 4
39777: PPUSH
39778: LD_VAR 0 8
39782: PPUSH
39783: CALL_OW 115
39787: GO 39832
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39789: LD_VAR 0 4
39793: PPUSH
39794: LD_EXP 60
39798: PUSH
39799: LD_VAR 0 1
39803: ARRAY
39804: PPUSH
39805: CALL_OW 308
39809: NOT
39810: IFFALSE 39832
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39812: LD_VAR 0 4
39816: PPUSH
39817: LD_EXP 60
39821: PUSH
39822: LD_VAR 0 1
39826: ARRAY
39827: PPUSH
39828: CALL_OW 113
// end ; end ; end ; end ;
39832: GO 39447
39834: POP
39835: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39836: LD_VAR 0 1
39840: PPUSH
39841: LD_INT 30
39843: PUSH
39844: LD_INT 5
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PPUSH
39851: CALL 11448 0 2
39855: IFFALSE 40673
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39857: LD_ADDR_VAR 0 11
39861: PUSH
39862: LD_VAR 0 1
39866: PPUSH
39867: LD_INT 30
39869: PUSH
39870: LD_INT 5
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PPUSH
39877: CALL 11448 0 2
39881: PUSH
39882: LD_INT 1
39884: ARRAY
39885: ST_TO_ADDR
// if eng > 1 then
39886: LD_VAR 0 14
39890: PUSH
39891: LD_INT 1
39893: GREATER
39894: IFFALSE 39941
// for i = eng downto 2 do
39896: LD_ADDR_VAR 0 4
39900: PUSH
39901: DOUBLE
39902: LD_VAR 0 14
39906: INC
39907: ST_TO_ADDR
39908: LD_INT 2
39910: PUSH
39911: FOR_DOWNTO
39912: IFFALSE 39939
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39914: LD_VAR 0 1
39918: PPUSH
39919: LD_VAR 0 14
39923: PUSH
39924: LD_VAR 0 4
39928: ARRAY
39929: PPUSH
39930: LD_INT 1
39932: PPUSH
39933: CALL 16355 0 3
39937: GO 39911
39939: POP
39940: POP
// if sci > 1 then
39941: LD_VAR 0 16
39945: PUSH
39946: LD_INT 1
39948: GREATER
39949: IFFALSE 39996
// for i = sci downto 2 do
39951: LD_ADDR_VAR 0 4
39955: PUSH
39956: DOUBLE
39957: LD_VAR 0 16
39961: INC
39962: ST_TO_ADDR
39963: LD_INT 2
39965: PUSH
39966: FOR_DOWNTO
39967: IFFALSE 39994
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39969: LD_VAR 0 1
39973: PPUSH
39974: LD_VAR 0 16
39978: PUSH
39979: LD_VAR 0 4
39983: ARRAY
39984: PPUSH
39985: LD_INT 1
39987: PPUSH
39988: CALL 16355 0 3
39992: GO 39966
39994: POP
39995: POP
// if sol then
39996: LD_VAR 0 13
40000: IFFALSE 40673
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
40002: LD_VAR 0 13
40006: PUSH
40007: LD_EXP 70
40011: PUSH
40012: LD_VAR 0 1
40016: ARRAY
40017: DIFF
40018: PUSH
40019: LD_INT 22
40021: PUSH
40022: LD_VAR 0 1
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 58
40033: PUSH
40034: EMPTY
40035: LIST
40036: PUSH
40037: LD_INT 2
40039: PUSH
40040: LD_INT 30
40042: PUSH
40043: LD_INT 32
40045: PUSH
40046: EMPTY
40047: LIST
40048: LIST
40049: PUSH
40050: LD_INT 30
40052: PUSH
40053: LD_INT 31
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: LIST
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: LIST
40069: PPUSH
40070: CALL_OW 69
40074: PUSH
40075: LD_INT 0
40077: EQUAL
40078: AND
40079: IFFALSE 40673
// begin tmp := sol diff MREG_ToBunker [ side ] ;
40081: LD_ADDR_VAR 0 12
40085: PUSH
40086: LD_VAR 0 13
40090: PUSH
40091: LD_EXP 70
40095: PUSH
40096: LD_VAR 0 1
40100: ARRAY
40101: DIFF
40102: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40103: LD_VAR 0 1
40107: PPUSH
40108: LD_INT 30
40110: PUSH
40111: LD_INT 5
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PPUSH
40118: CALL 11448 0 2
40122: PUSH
40123: LD_INT 1
40125: GREATER
40126: IFFALSE 40157
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40128: LD_ADDR_VAR 0 8
40132: PUSH
40133: LD_VAR 0 1
40137: PPUSH
40138: LD_INT 30
40140: PUSH
40141: LD_INT 5
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PPUSH
40148: CALL 11448 0 2
40152: PUSH
40153: LD_INT 2
40155: ARRAY
40156: ST_TO_ADDR
// for j in tmp do
40157: LD_ADDR_VAR 0 5
40161: PUSH
40162: LD_VAR 0 12
40166: PUSH
40167: FOR_IN
40168: IFFALSE 40671
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40170: LD_VAR 0 5
40174: PUSH
40175: LD_VAR 0 11
40179: PPUSH
40180: CALL_OW 313
40184: IN
40185: PUSH
40186: LD_VAR 0 11
40190: PPUSH
40191: CALL_OW 313
40195: PUSH
40196: LD_INT 6
40198: EQUAL
40199: AND
40200: PUSH
40201: LD_VAR 0 8
40205: AND
40206: PUSH
40207: LD_VAR 0 8
40211: PPUSH
40212: CALL_OW 313
40216: PUSH
40217: LD_INT 6
40219: LESS
40220: AND
40221: IFFALSE 40248
// begin ComExitBuilding ( j ) ;
40223: LD_VAR 0 5
40227: PPUSH
40228: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40232: LD_VAR 0 5
40236: PPUSH
40237: LD_VAR 0 8
40241: PPUSH
40242: CALL_OW 180
// continue ;
40246: GO 40167
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40248: LD_VAR 0 5
40252: PPUSH
40253: CALL_OW 314
40257: NOT
40258: PUSH
40259: LD_VAR 0 5
40263: PPUSH
40264: CALL_OW 110
40268: PUSH
40269: LD_INT 0
40271: EQUAL
40272: AND
40273: PUSH
40274: LD_VAR 0 5
40278: PPUSH
40279: CALL_OW 310
40283: NOT
40284: AND
40285: IFFALSE 40391
// begin if k then
40287: LD_VAR 0 8
40291: IFFALSE 40362
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40293: LD_VAR 0 8
40297: PPUSH
40298: CALL_OW 313
40302: PUSH
40303: LD_VAR 0 11
40307: PPUSH
40308: CALL_OW 313
40312: LESS
40313: IFFALSE 40331
// ComEnterUnit ( j , k ) else
40315: LD_VAR 0 5
40319: PPUSH
40320: LD_VAR 0 8
40324: PPUSH
40325: CALL_OW 120
40329: GO 40360
// if UnitsInside ( b ) < 6 then
40331: LD_VAR 0 11
40335: PPUSH
40336: CALL_OW 313
40340: PUSH
40341: LD_INT 6
40343: LESS
40344: IFFALSE 40360
// ComEnterUnit ( j , b ) ;
40346: LD_VAR 0 5
40350: PPUSH
40351: LD_VAR 0 11
40355: PPUSH
40356: CALL_OW 120
// end else
40360: GO 40391
// if UnitsInside ( b ) < 6 then
40362: LD_VAR 0 11
40366: PPUSH
40367: CALL_OW 313
40371: PUSH
40372: LD_INT 6
40374: LESS
40375: IFFALSE 40391
// ComEnterUnit ( j , b ) ;
40377: LD_VAR 0 5
40381: PPUSH
40382: LD_VAR 0 11
40386: PPUSH
40387: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40391: LD_VAR 0 5
40395: PUSH
40396: LD_VAR 0 1
40400: PPUSH
40401: LD_INT 54
40403: PUSH
40404: EMPTY
40405: LIST
40406: PPUSH
40407: CALL 11448 0 2
40411: IN
40412: PUSH
40413: LD_VAR 0 5
40417: PPUSH
40418: CALL_OW 257
40422: PUSH
40423: LD_INT 1
40425: EQUAL
40426: AND
40427: IFFALSE 40669
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40429: LD_EXP 64
40433: PUSH
40434: LD_VAR 0 1
40438: ARRAY
40439: PUSH
40440: LD_INT 1
40442: ARRAY
40443: PUSH
40444: LD_INT 12
40446: PPUSH
40447: LD_VAR 0 1
40451: PPUSH
40452: CALL_OW 321
40456: PUSH
40457: LD_INT 2
40459: EQUAL
40460: AND
40461: IFFALSE 40509
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40463: LD_VAR 0 1
40467: PPUSH
40468: LD_INT 5
40470: PPUSH
40471: EMPTY
40472: PPUSH
40473: CALL 11531 0 3
40477: PUSH
40478: LD_EXP 64
40482: PUSH
40483: LD_VAR 0 1
40487: ARRAY
40488: PUSH
40489: LD_INT 1
40491: ARRAY
40492: LESS
40493: IFFALSE 40509
// begin SetClass ( j , class_sniper ) ;
40495: LD_VAR 0 5
40499: PPUSH
40500: LD_INT 5
40502: PPUSH
40503: CALL_OW 336
// continue ;
40507: GO 40167
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40509: LD_EXP 64
40513: PUSH
40514: LD_VAR 0 1
40518: ARRAY
40519: PUSH
40520: LD_INT 2
40522: ARRAY
40523: PUSH
40524: LD_INT 41
40526: PPUSH
40527: LD_VAR 0 1
40531: PPUSH
40532: CALL_OW 321
40536: PUSH
40537: LD_INT 2
40539: EQUAL
40540: AND
40541: IFFALSE 40589
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40543: LD_VAR 0 1
40547: PPUSH
40548: LD_INT 8
40550: PPUSH
40551: EMPTY
40552: PPUSH
40553: CALL 11531 0 3
40557: PUSH
40558: LD_EXP 64
40562: PUSH
40563: LD_VAR 0 1
40567: ARRAY
40568: PUSH
40569: LD_INT 2
40571: ARRAY
40572: LESS
40573: IFFALSE 40589
// begin SetClass ( j , class_mortar ) ;
40575: LD_VAR 0 5
40579: PPUSH
40580: LD_INT 8
40582: PPUSH
40583: CALL_OW 336
// continue ;
40587: GO 40167
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40589: LD_EXP 64
40593: PUSH
40594: LD_VAR 0 1
40598: ARRAY
40599: PUSH
40600: LD_INT 3
40602: ARRAY
40603: PUSH
40604: LD_INT 44
40606: PPUSH
40607: LD_VAR 0 1
40611: PPUSH
40612: CALL_OW 321
40616: PUSH
40617: LD_INT 2
40619: EQUAL
40620: AND
40621: IFFALSE 40669
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40623: LD_VAR 0 1
40627: PPUSH
40628: LD_INT 9
40630: PPUSH
40631: EMPTY
40632: PPUSH
40633: CALL 11531 0 3
40637: PUSH
40638: LD_EXP 64
40642: PUSH
40643: LD_VAR 0 1
40647: ARRAY
40648: PUSH
40649: LD_INT 3
40651: ARRAY
40652: LESS
40653: IFFALSE 40669
// begin SetClass ( j , class_bazooker ) ;
40655: LD_VAR 0 5
40659: PPUSH
40660: LD_INT 9
40662: PPUSH
40663: CALL_OW 336
// continue ;
40667: GO 40167
// end ; end ; end ;
40669: GO 40167
40671: POP
40672: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40673: LD_INT 22
40675: PUSH
40676: LD_VAR 0 1
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 58
40687: PUSH
40688: EMPTY
40689: LIST
40690: PUSH
40691: LD_INT 30
40693: PUSH
40694: LD_INT 32
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: LIST
40705: PPUSH
40706: CALL_OW 69
40710: IFFALSE 40860
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40712: LD_ADDR_VAR 0 12
40716: PUSH
40717: LD_INT 22
40719: PUSH
40720: LD_VAR 0 1
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 58
40731: PUSH
40732: EMPTY
40733: LIST
40734: PUSH
40735: LD_INT 30
40737: PUSH
40738: LD_INT 32
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: LIST
40749: PPUSH
40750: CALL_OW 69
40754: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40755: LD_ADDR_VAR 0 8
40759: PUSH
40760: LD_VAR 0 13
40764: PUSH
40765: LD_EXP 70
40769: PUSH
40770: LD_VAR 0 1
40774: ARRAY
40775: DIFF
40776: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40777: LD_VAR 0 12
40781: PUSH
40782: LD_INT 1
40784: ARRAY
40785: PPUSH
40786: CALL_OW 461
40790: PUSH
40791: LD_INT 2
40793: EQUAL
40794: PUSH
40795: LD_VAR 0 12
40799: PUSH
40800: LD_INT 1
40802: ARRAY
40803: PUSH
40804: LD_EXP 70
40808: PUSH
40809: LD_VAR 0 1
40813: ARRAY
40814: IN
40815: NOT
40816: AND
40817: PUSH
40818: LD_VAR 0 8
40822: AND
40823: IFFALSE 40860
// begin ComExitBuilding ( k [ 1 ] ) ;
40825: LD_VAR 0 8
40829: PUSH
40830: LD_INT 1
40832: ARRAY
40833: PPUSH
40834: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40838: LD_VAR 0 8
40842: PUSH
40843: LD_INT 1
40845: ARRAY
40846: PPUSH
40847: LD_VAR 0 12
40851: PUSH
40852: LD_INT 1
40854: ARRAY
40855: PPUSH
40856: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40860: LD_EXP 37
40864: PUSH
40865: LD_VAR 0 1
40869: ARRAY
40870: IFFALSE 41018
// begin if MCF_Class ( side , 4 , [ ] ) then
40872: LD_VAR 0 1
40876: PPUSH
40877: LD_INT 4
40879: PPUSH
40880: EMPTY
40881: PPUSH
40882: CALL 11531 0 3
40886: IFFALSE 41016
// for j in MCF_Class ( side , 4 , [ ] ) do
40888: LD_ADDR_VAR 0 5
40892: PUSH
40893: LD_VAR 0 1
40897: PPUSH
40898: LD_INT 4
40900: PPUSH
40901: EMPTY
40902: PPUSH
40903: CALL 11531 0 3
40907: PUSH
40908: FOR_IN
40909: IFFALSE 41014
// begin if not GetTag ( j ) = 4 then
40911: LD_VAR 0 5
40915: PPUSH
40916: CALL_OW 110
40920: PUSH
40921: LD_INT 4
40923: EQUAL
40924: NOT
40925: IFFALSE 40961
// begin SetTag ( j , 4 ) ;
40927: LD_VAR 0 5
40931: PPUSH
40932: LD_INT 4
40934: PPUSH
40935: CALL_OW 109
// if IsInUnit ( j ) then
40939: LD_VAR 0 5
40943: PPUSH
40944: CALL_OW 310
40948: IFFALSE 40959
// ComExitBuilding ( j ) ;
40950: LD_VAR 0 5
40954: PPUSH
40955: CALL_OW 122
// end else
40959: GO 41012
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40961: LD_VAR 0 5
40965: PPUSH
40966: LD_EXP 37
40970: PUSH
40971: LD_VAR 0 1
40975: ARRAY
40976: PUSH
40977: LD_INT 1
40979: ARRAY
40980: PPUSH
40981: CALL 32267 0 2
40985: NOT
40986: IFFALSE 41012
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40988: LD_VAR 0 5
40992: PPUSH
40993: LD_EXP 37
40997: PUSH
40998: LD_VAR 0 1
41002: ARRAY
41003: PUSH
41004: LD_INT 1
41006: ARRAY
41007: PPUSH
41008: CALL 19018 0 2
// end ;
41012: GO 40908
41014: POP
41015: POP
// end else
41016: GO 41250
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
41018: LD_VAR 0 1
41022: PPUSH
41023: LD_INT 4
41025: PPUSH
41026: EMPTY
41027: PPUSH
41028: CALL 11531 0 3
41032: PUSH
41033: LD_VAR 0 1
41037: PPUSH
41038: LD_INT 4
41040: PPUSH
41041: EMPTY
41042: PPUSH
41043: CALL 12151 0 3
41047: AND
41048: IFFALSE 41250
// for j in MCF_Class ( side , 4 , [ ] ) do
41050: LD_ADDR_VAR 0 5
41054: PUSH
41055: LD_VAR 0 1
41059: PPUSH
41060: LD_INT 4
41062: PPUSH
41063: EMPTY
41064: PPUSH
41065: CALL 11531 0 3
41069: PUSH
41070: FOR_IN
41071: IFFALSE 41248
// begin if GetTag ( j ) = 4 then
41073: LD_VAR 0 5
41077: PPUSH
41078: CALL_OW 110
41082: PUSH
41083: LD_INT 4
41085: EQUAL
41086: IFFALSE 41246
// begin SetTag ( j , 0 ) ;
41088: LD_VAR 0 5
41092: PPUSH
41093: LD_INT 0
41095: PPUSH
41096: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41100: LD_VAR 0 1
41104: PPUSH
41105: CALL 11487 0 1
41109: PUSH
41110: LD_VAR 0 1
41114: PPUSH
41115: CALL 17831 0 1
41119: NOT
41120: AND
41121: IFFALSE 41146
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41123: LD_VAR 0 5
41127: PPUSH
41128: LD_VAR 0 1
41132: PPUSH
41133: CALL 11487 0 1
41137: PUSH
41138: LD_INT 1
41140: ARRAY
41141: PPUSH
41142: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41146: LD_VAR 0 1
41150: PPUSH
41151: CALL 11487 0 1
41155: NOT
41156: PUSH
41157: LD_VAR 0 1
41161: PPUSH
41162: LD_INT 30
41164: PUSH
41165: LD_INT 1
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PPUSH
41172: CALL 11448 0 2
41176: AND
41177: IFFALSE 41246
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41179: LD_VAR 0 5
41183: PPUSH
41184: LD_VAR 0 1
41188: PPUSH
41189: LD_INT 30
41191: PUSH
41192: LD_INT 1
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: PPUSH
41199: CALL 11448 0 2
41203: PUSH
41204: LD_INT 1
41206: ARRAY
41207: PPUSH
41208: CALL_OW 250
41212: PPUSH
41213: LD_VAR 0 1
41217: PPUSH
41218: LD_INT 30
41220: PUSH
41221: LD_INT 1
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PPUSH
41228: CALL 11448 0 2
41232: PUSH
41233: LD_INT 1
41235: ARRAY
41236: PPUSH
41237: CALL_OW 251
41241: PPUSH
41242: CALL_OW 111
// end ; end ;
41246: GO 41070
41248: POP
41249: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41250: LD_VAR 0 1
41254: PPUSH
41255: LD_INT 3
41257: PPUSH
41258: EMPTY
41259: PPUSH
41260: CALL 11531 0 3
41264: PUSH
41265: LD_EXP 60
41269: PUSH
41270: LD_VAR 0 1
41274: ARRAY
41275: AND
41276: PUSH
41277: LD_VAR 0 1
41281: PPUSH
41282: LD_INT 6
41284: PPUSH
41285: EMPTY
41286: PPUSH
41287: CALL 12151 0 3
41291: AND
41292: IFFALSE 41823
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41294: LD_ADDR_VAR 0 6
41298: PUSH
41299: LD_EXP 60
41303: PUSH
41304: LD_VAR 0 1
41308: ARRAY
41309: PPUSH
41310: LD_INT 0
41312: PPUSH
41313: CALL_OW 517
41317: PUSH
41318: LD_INT 1
41320: ARRAY
41321: PUSH
41322: LD_INT 1
41324: ARRAY
41325: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41326: LD_ADDR_VAR 0 7
41330: PUSH
41331: LD_EXP 60
41335: PUSH
41336: LD_VAR 0 1
41340: ARRAY
41341: PPUSH
41342: LD_INT 0
41344: PPUSH
41345: CALL_OW 517
41349: PUSH
41350: LD_INT 2
41352: ARRAY
41353: PUSH
41354: LD_INT 1
41356: ARRAY
41357: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41358: LD_VAR 0 1
41362: PPUSH
41363: LD_INT 6
41365: PPUSH
41366: EMPTY
41367: PPUSH
41368: CALL 12151 0 3
41372: IFFALSE 41821
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41374: LD_ADDR_VAR 0 8
41378: PUSH
41379: LD_VAR 0 1
41383: PPUSH
41384: LD_INT 6
41386: PPUSH
41387: EMPTY
41388: PPUSH
41389: CALL 12151 0 3
41393: PUSH
41394: FOR_IN
41395: IFFALSE 41426
// if GetLives ( k ) = 1000 then
41397: LD_VAR 0 8
41401: PPUSH
41402: CALL_OW 256
41406: PUSH
41407: LD_INT 1000
41409: EQUAL
41410: IFFALSE 41424
// SetTag ( k , 0 ) ;
41412: LD_VAR 0 8
41416: PPUSH
41417: LD_INT 0
41419: PPUSH
41420: CALL_OW 109
41424: GO 41394
41426: POP
41427: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41428: LD_VAR 0 1
41432: PPUSH
41433: LD_INT 0
41435: PPUSH
41436: LD_INT 25
41438: PUSH
41439: LD_INT 3
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PPUSH
41446: CALL 12151 0 3
41450: IFFALSE 41514
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41452: LD_ADDR_VAR 0 8
41456: PUSH
41457: LD_VAR 0 4
41461: PPUSH
41462: LD_INT 0
41464: PPUSH
41465: LD_INT 25
41467: PUSH
41468: LD_INT 3
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PPUSH
41475: CALL 12151 0 3
41479: PUSH
41480: FOR_IN
41481: IFFALSE 41512
// if GetTag ( k ) = 0 then
41483: LD_VAR 0 8
41487: PPUSH
41488: CALL_OW 110
41492: PUSH
41493: LD_INT 0
41495: EQUAL
41496: IFFALSE 41510
// begin SetTag ( k , 8 ) ;
41498: LD_VAR 0 8
41502: PPUSH
41503: LD_INT 8
41505: PPUSH
41506: CALL_OW 109
// end ;
41510: GO 41480
41512: POP
41513: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41514: LD_VAR 0 1
41518: PPUSH
41519: LD_INT 6
41521: PPUSH
41522: LD_INT 92
41524: PUSH
41525: LD_VAR 0 6
41529: PUSH
41530: LD_VAR 0 7
41534: PUSH
41535: LD_INT 10
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: PPUSH
41544: CALL 12151 0 3
41548: IFFALSE 41672
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41550: LD_ADDR_VAR 0 5
41554: PUSH
41555: LD_VAR 0 4
41559: PPUSH
41560: LD_INT 6
41562: PPUSH
41563: LD_INT 92
41565: PUSH
41566: LD_VAR 0 6
41570: PUSH
41571: LD_VAR 0 7
41575: PUSH
41576: LD_INT 10
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: PPUSH
41585: CALL 12151 0 3
41589: PUSH
41590: FOR_IN
41591: IFFALSE 41670
// begin if not HasTask ( j ) and GetDriver ( j ) then
41593: LD_VAR 0 5
41597: PPUSH
41598: CALL_OW 314
41602: NOT
41603: PUSH
41604: LD_VAR 0 5
41608: PPUSH
41609: CALL 31576 0 1
41613: AND
41614: IFFALSE 41668
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41616: LD_VAR 0 5
41620: PPUSH
41621: CALL 31576 0 1
41625: PPUSH
41626: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41630: LD_VAR 0 5
41634: PPUSH
41635: CALL 31576 0 1
41639: PPUSH
41640: LD_VAR 0 5
41644: PPUSH
41645: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41649: LD_VAR 0 5
41653: PPUSH
41654: CALL 31576 0 1
41658: PPUSH
41659: LD_VAR 0 5
41663: PPUSH
41664: CALL_OW 180
// end ; end ;
41668: GO 41590
41670: POP
41671: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41672: LD_VAR 0 1
41676: PPUSH
41677: LD_INT 6
41679: PPUSH
41680: LD_INT 92
41682: PUSH
41683: LD_VAR 0 6
41687: PUSH
41688: LD_VAR 0 7
41692: PUSH
41693: LD_INT 10
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: PPUSH
41702: CALL 12151 0 3
41706: PUSH
41707: LD_VAR 0 1
41711: PPUSH
41712: LD_INT 8
41714: PPUSH
41715: EMPTY
41716: PPUSH
41717: CALL 12151 0 3
41721: AND
41722: IFFALSE 41821
// for j in MCF_Tag ( side , 8 , [ ] ) do
41724: LD_ADDR_VAR 0 5
41728: PUSH
41729: LD_VAR 0 1
41733: PPUSH
41734: LD_INT 8
41736: PPUSH
41737: EMPTY
41738: PPUSH
41739: CALL 12151 0 3
41743: PUSH
41744: FOR_IN
41745: IFFALSE 41819
// begin if IsInUnit ( j ) then
41747: LD_VAR 0 5
41751: PPUSH
41752: CALL_OW 310
41756: IFFALSE 41769
// ComExitBuilding ( j ) else
41758: LD_VAR 0 5
41762: PPUSH
41763: CALL_OW 122
41767: GO 41817
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41769: LD_VAR 0 5
41773: PPUSH
41774: LD_VAR 0 1
41778: PPUSH
41779: LD_INT 6
41781: PPUSH
41782: LD_INT 92
41784: PUSH
41785: LD_VAR 0 6
41789: PUSH
41790: LD_VAR 0 7
41794: PUSH
41795: LD_INT 10
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: PPUSH
41804: CALL 12151 0 3
41808: PUSH
41809: LD_INT 1
41811: ARRAY
41812: PPUSH
41813: CALL_OW 129
// end ;
41817: GO 41744
41819: POP
41820: POP
// end ; end else
41821: GO 41878
// if MCF_Tag ( side , 8 , [ ] ) then
41823: LD_VAR 0 1
41827: PPUSH
41828: LD_INT 8
41830: PPUSH
41831: EMPTY
41832: PPUSH
41833: CALL 12151 0 3
41837: IFFALSE 41878
// for k in MCF_Tag ( side , 8 , [ ] ) do
41839: LD_ADDR_VAR 0 8
41843: PUSH
41844: LD_VAR 0 1
41848: PPUSH
41849: LD_INT 8
41851: PPUSH
41852: EMPTY
41853: PPUSH
41854: CALL 12151 0 3
41858: PUSH
41859: FOR_IN
41860: IFFALSE 41876
// SetTag ( k , 0 ) ;
41862: LD_VAR 0 8
41866: PPUSH
41867: LD_INT 0
41869: PPUSH
41870: CALL_OW 109
41874: GO 41859
41876: POP
41877: POP
// end ; end_of_file
41878: LD_VAR 0 3
41882: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41883: LD_INT 0
41885: PPUSH
// MREG_Game := [ ] ;
41886: LD_ADDR_EXP 35
41890: PUSH
41891: EMPTY
41892: ST_TO_ADDR
// MREG_Crates := [ ] ;
41893: LD_ADDR_EXP 36
41897: PUSH
41898: EMPTY
41899: ST_TO_ADDR
// MREG_Heal := [ ] ;
41900: LD_ADDR_EXP 37
41904: PUSH
41905: EMPTY
41906: ST_TO_ADDR
// MREG_Tame := [ ] ;
41907: LD_ADDR_EXP 39
41911: PUSH
41912: EMPTY
41913: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41914: LD_ADDR_EXP 40
41918: PUSH
41919: EMPTY
41920: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41921: LD_ADDR_EXP 41
41925: PUSH
41926: EMPTY
41927: ST_TO_ADDR
// MREG_LabList := [ ] ;
41928: LD_ADDR_EXP 42
41932: PUSH
41933: EMPTY
41934: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41935: LD_ADDR_EXP 43
41939: PUSH
41940: EMPTY
41941: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41942: LD_ADDR_EXP 44
41946: PUSH
41947: EMPTY
41948: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41949: LD_ADDR_EXP 45
41953: PUSH
41954: EMPTY
41955: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41956: LD_ADDR_EXP 46
41960: PUSH
41961: EMPTY
41962: ST_TO_ADDR
// MREG_Status := [ ] ;
41963: LD_ADDR_EXP 47
41967: PUSH
41968: EMPTY
41969: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41970: LD_ADDR_EXP 48
41974: PUSH
41975: EMPTY
41976: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41977: LD_ADDR_EXP 49
41981: PUSH
41982: EMPTY
41983: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41984: LD_ADDR_EXP 50
41988: PUSH
41989: EMPTY
41990: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41991: LD_ADDR_EXP 51
41995: PUSH
41996: EMPTY
41997: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41998: LD_ADDR_EXP 52
42002: PUSH
42003: EMPTY
42004: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
42005: LD_ADDR_EXP 53
42009: PUSH
42010: EMPTY
42011: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
42012: LD_ADDR_EXP 54
42016: PUSH
42017: EMPTY
42018: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
42019: LD_ADDR_EXP 55
42023: PUSH
42024: EMPTY
42025: ST_TO_ADDR
// MREG_ToLab := [ ] ;
42026: LD_ADDR_EXP 56
42030: PUSH
42031: EMPTY
42032: ST_TO_ADDR
// MREG_ToFac := [ ] ;
42033: LD_ADDR_EXP 57
42037: PUSH
42038: EMPTY
42039: ST_TO_ADDR
// MREG_ToArm := [ ] ;
42040: LD_ADDR_EXP 58
42044: PUSH
42045: EMPTY
42046: ST_TO_ADDR
// MREG_ToDep := [ ] ;
42047: LD_ADDR_EXP 59
42051: PUSH
42052: EMPTY
42053: ST_TO_ADDR
// MREG_Deposit := [ ] ;
42054: LD_ADDR_EXP 63
42058: PUSH
42059: EMPTY
42060: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
42061: LD_ADDR_EXP 64
42065: PUSH
42066: EMPTY
42067: ST_TO_ADDR
// MREG_Parking := [ ] ;
42068: LD_ADDR_EXP 60
42072: PUSH
42073: EMPTY
42074: ST_TO_ADDR
// MREG_VCombat := [ ] ;
42075: LD_ADDR_EXP 61
42079: PUSH
42080: EMPTY
42081: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
42082: LD_ADDR_EXP 65
42086: PUSH
42087: EMPTY
42088: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42089: LD_ADDR_EXP 66
42093: PUSH
42094: EMPTY
42095: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42096: LD_ADDR_EXP 67
42100: PUSH
42101: EMPTY
42102: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42103: LD_ADDR_EXP 69
42107: PUSH
42108: EMPTY
42109: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42110: LD_ADDR_EXP 70
42114: PUSH
42115: EMPTY
42116: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42117: LD_ADDR_EXP 71
42121: PUSH
42122: EMPTY
42123: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42124: LD_ADDR_EXP 73
42128: PUSH
42129: EMPTY
42130: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42131: LD_ADDR_EXP 72
42135: PUSH
42136: EMPTY
42137: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42138: LD_ADDR_EXP 74
42142: PUSH
42143: LD_INT 300
42145: PUSH
42146: LD_INT 100
42148: PUSH
42149: LD_INT 25
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: LIST
42156: ST_TO_ADDR
// end ;
42157: LD_VAR 0 1
42161: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42162: LD_INT 0
42164: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42165: LD_VAR 0 2
42169: PUSH
42170: LD_VAR 0 3
42174: PUSH
42175: LD_VAR 0 4
42179: PUSH
42180: EMPTY
42181: LIST
42182: LIST
42183: LIST
42184: PUSH
42185: LD_VAR 0 1
42189: IN
42190: IFFALSE 42204
// result := mreg_list else
42192: LD_ADDR_VAR 0 5
42196: PUSH
42197: LD_VAR 0 1
42201: ST_TO_ADDR
42202: GO 42238
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42204: LD_ADDR_VAR 0 1
42208: PUSH
42209: LD_VAR 0 1
42213: PUSH
42214: LD_VAR 0 2
42218: PUSH
42219: LD_VAR 0 3
42223: PUSH
42224: LD_VAR 0 4
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: LIST
42233: PUSH
42234: EMPTY
42235: LIST
42236: ADD
42237: ST_TO_ADDR
// result := mreg_list ;
42238: LD_ADDR_VAR 0 5
42242: PUSH
42243: LD_VAR 0 1
42247: ST_TO_ADDR
// end ;
42248: LD_VAR 0 5
42252: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42253: LD_INT 0
42255: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42256: LD_VAR 0 2
42260: PUSH
42261: LD_VAR 0 3
42265: PUSH
42266: LD_VAR 0 4
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: LIST
42275: PUSH
42276: LD_VAR 0 1
42280: IN
42281: IFFALSE 42319
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42283: LD_ADDR_VAR 0 5
42287: PUSH
42288: LD_VAR 0 1
42292: PUSH
42293: LD_VAR 0 2
42297: PUSH
42298: LD_VAR 0 3
42302: PUSH
42303: LD_VAR 0 4
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: LIST
42312: PUSH
42313: EMPTY
42314: LIST
42315: DIFF
42316: ST_TO_ADDR
42317: GO 42329
// result := mreg_list ;
42319: LD_ADDR_VAR 0 5
42323: PUSH
42324: LD_VAR 0 1
42328: ST_TO_ADDR
// end ;
42329: LD_VAR 0 5
42333: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42334: LD_INT 0
42336: PPUSH
42337: PPUSH
42338: PPUSH
// for j = 1 to 8 do
42339: LD_ADDR_VAR 0 3
42343: PUSH
42344: DOUBLE
42345: LD_INT 1
42347: DEC
42348: ST_TO_ADDR
42349: LD_INT 8
42351: PUSH
42352: FOR_TO
42353: IFFALSE 43194
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42355: LD_VAR 0 3
42359: PPUSH
42360: LD_INT 51
42362: PUSH
42363: EMPTY
42364: LIST
42365: PPUSH
42366: CALL 11448 0 2
42370: PUSH
42371: LD_OWVAR 2
42375: PUSH
42376: LD_VAR 0 3
42380: EQUAL
42381: NOT
42382: AND
42383: IFFALSE 42401
// MREG_SidesList := MREG_SidesList ^ 1 else
42385: LD_ADDR_EXP 41
42389: PUSH
42390: LD_EXP 41
42394: PUSH
42395: LD_INT 1
42397: ADD
42398: ST_TO_ADDR
42399: GO 42415
// MREG_SidesList := MREG_SidesList ^ 0 ;
42401: LD_ADDR_EXP 41
42405: PUSH
42406: LD_EXP 41
42410: PUSH
42411: LD_INT 0
42413: ADD
42414: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42415: LD_VAR 0 3
42419: PPUSH
42420: LD_INT 2
42422: PUSH
42423: LD_INT 34
42425: PUSH
42426: LD_INT 12
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PUSH
42433: LD_INT 34
42435: PUSH
42436: LD_INT 32
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: LD_INT 34
42445: PUSH
42446: LD_INT 51
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: PUSH
42459: EMPTY
42460: LIST
42461: PPUSH
42462: CALL 11749 0 2
42466: IFFALSE 42567
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42468: LD_ADDR_VAR 0 2
42472: PUSH
42473: LD_VAR 0 3
42477: PPUSH
42478: LD_INT 2
42480: PUSH
42481: LD_INT 34
42483: PUSH
42484: LD_INT 12
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 34
42493: PUSH
42494: LD_INT 32
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 34
42503: PUSH
42504: LD_INT 51
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: LIST
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PPUSH
42520: CALL 11749 0 2
42524: PUSH
42525: FOR_IN
42526: IFFALSE 42565
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42528: LD_ADDR_EXP 43
42532: PUSH
42533: LD_EXP 43
42537: PPUSH
42538: LD_VAR 0 3
42542: PPUSH
42543: LD_VAR 0 2
42547: PPUSH
42548: LD_VAR 0 2
42552: PPUSH
42553: CALL_OW 264
42557: PPUSH
42558: CALL 42162 0 4
42562: ST_TO_ADDR
42563: GO 42525
42565: POP
42566: POP
// if MCF_Class ( j , 4 , [ ] ) then
42567: LD_VAR 0 3
42571: PPUSH
42572: LD_INT 4
42574: PPUSH
42575: EMPTY
42576: PPUSH
42577: CALL 11531 0 3
42581: IFFALSE 42614
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42583: LD_ADDR_EXP 56
42587: PUSH
42588: LD_EXP 56
42592: PUSH
42593: LD_VAR 0 3
42597: PPUSH
42598: LD_INT 4
42600: PPUSH
42601: EMPTY
42602: PPUSH
42603: CALL 11531 0 3
42607: PUSH
42608: EMPTY
42609: LIST
42610: ADD
42611: ST_TO_ADDR
42612: GO 42631
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42614: LD_ADDR_EXP 56
42618: PUSH
42619: LD_EXP 56
42623: PUSH
42624: LD_INT 0
42626: PUSH
42627: EMPTY
42628: LIST
42629: ADD
42630: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42631: LD_VAR 0 3
42635: PPUSH
42636: LD_INT 3
42638: PPUSH
42639: EMPTY
42640: PPUSH
42641: CALL 11531 0 3
42645: IFFALSE 42678
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42647: LD_ADDR_EXP 57
42651: PUSH
42652: LD_EXP 57
42656: PUSH
42657: LD_VAR 0 3
42661: PPUSH
42662: LD_INT 3
42664: PPUSH
42665: EMPTY
42666: PPUSH
42667: CALL 11531 0 3
42671: PUSH
42672: EMPTY
42673: LIST
42674: ADD
42675: ST_TO_ADDR
42676: GO 42695
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42678: LD_ADDR_EXP 57
42682: PUSH
42683: LD_EXP 57
42687: PUSH
42688: LD_INT 0
42690: PUSH
42691: EMPTY
42692: LIST
42693: ADD
42694: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42695: LD_VAR 0 3
42699: PPUSH
42700: LD_INT 1
42702: PPUSH
42703: EMPTY
42704: PPUSH
42705: CALL 11531 0 3
42709: IFFALSE 42742
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42711: LD_ADDR_EXP 58
42715: PUSH
42716: LD_EXP 58
42720: PUSH
42721: LD_VAR 0 3
42725: PPUSH
42726: LD_INT 1
42728: PPUSH
42729: EMPTY
42730: PPUSH
42731: CALL 11531 0 3
42735: PUSH
42736: EMPTY
42737: LIST
42738: ADD
42739: ST_TO_ADDR
42740: GO 42759
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42742: LD_ADDR_EXP 58
42746: PUSH
42747: LD_EXP 58
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: EMPTY
42756: LIST
42757: ADD
42758: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42759: LD_VAR 0 3
42763: PPUSH
42764: LD_INT 2
42766: PPUSH
42767: EMPTY
42768: PPUSH
42769: CALL 11531 0 3
42773: IFFALSE 42806
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42775: LD_ADDR_EXP 59
42779: PUSH
42780: LD_EXP 59
42784: PUSH
42785: LD_VAR 0 3
42789: PPUSH
42790: LD_INT 2
42792: PPUSH
42793: EMPTY
42794: PPUSH
42795: CALL 11531 0 3
42799: PUSH
42800: EMPTY
42801: LIST
42802: ADD
42803: ST_TO_ADDR
42804: GO 42823
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42806: LD_ADDR_EXP 59
42810: PUSH
42811: LD_EXP 59
42815: PUSH
42816: LD_INT 0
42818: PUSH
42819: EMPTY
42820: LIST
42821: ADD
42822: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42823: LD_ADDR_EXP 49
42827: PUSH
42828: LD_EXP 49
42832: PUSH
42833: LD_INT 0
42835: PUSH
42836: EMPTY
42837: LIST
42838: ADD
42839: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42840: LD_ADDR_EXP 37
42844: PUSH
42845: LD_EXP 37
42849: PUSH
42850: LD_INT 0
42852: PUSH
42853: EMPTY
42854: LIST
42855: ADD
42856: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42857: LD_ADDR_EXP 39
42861: PUSH
42862: LD_EXP 39
42866: PUSH
42867: LD_INT 0
42869: PUSH
42870: EMPTY
42871: LIST
42872: ADD
42873: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42874: LD_ADDR_EXP 60
42878: PUSH
42879: LD_EXP 60
42883: PUSH
42884: LD_INT 0
42886: PUSH
42887: EMPTY
42888: LIST
42889: ADD
42890: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42891: LD_ADDR_EXP 61
42895: PUSH
42896: LD_EXP 61
42900: PUSH
42901: LD_INT 0
42903: PUSH
42904: EMPTY
42905: LIST
42906: ADD
42907: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42908: LD_ADDR_EXP 53
42912: PUSH
42913: LD_EXP 53
42917: PUSH
42918: LD_INT 0
42920: PUSH
42921: EMPTY
42922: LIST
42923: ADD
42924: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42925: LD_ADDR_EXP 40
42929: PUSH
42930: LD_EXP 40
42934: PUSH
42935: LD_INT 0
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: LD_INT 0
42943: PUSH
42944: LD_INT 0
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: PUSH
42953: EMPTY
42954: LIST
42955: ADD
42956: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42957: LD_ADDR_EXP 62
42961: PUSH
42962: LD_EXP 62
42966: PUSH
42967: LD_INT 0
42969: PUSH
42970: EMPTY
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: EMPTY
42977: LIST
42978: ADD
42979: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42980: LD_ADDR_EXP 63
42984: PUSH
42985: LD_EXP 63
42989: PUSH
42990: LD_INT 0
42992: PUSH
42993: EMPTY
42994: LIST
42995: PUSH
42996: EMPTY
42997: LIST
42998: ADD
42999: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
43000: LD_ADDR_EXP 44
43004: PUSH
43005: LD_EXP 44
43009: PUSH
43010: LD_INT 0
43012: PUSH
43013: EMPTY
43014: LIST
43015: ADD
43016: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
43017: LD_ADDR_EXP 65
43021: PUSH
43022: LD_EXP 65
43026: PUSH
43027: LD_INT 0
43029: PUSH
43030: EMPTY
43031: LIST
43032: ADD
43033: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
43034: LD_ADDR_EXP 66
43038: PUSH
43039: LD_EXP 66
43043: PUSH
43044: LD_INT 0
43046: PUSH
43047: EMPTY
43048: LIST
43049: ADD
43050: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
43051: LD_ADDR_EXP 67
43055: PUSH
43056: LD_EXP 67
43060: PUSH
43061: LD_INT 0
43063: PUSH
43064: EMPTY
43065: LIST
43066: ADD
43067: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
43068: LD_ADDR_EXP 68
43072: PUSH
43073: LD_EXP 68
43077: PUSH
43078: LD_INT 0
43080: PUSH
43081: EMPTY
43082: LIST
43083: ADD
43084: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
43085: LD_ADDR_EXP 69
43089: PUSH
43090: LD_EXP 69
43094: PUSH
43095: LD_INT 0
43097: PUSH
43098: EMPTY
43099: LIST
43100: ADD
43101: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43102: LD_ADDR_EXP 70
43106: PUSH
43107: LD_EXP 70
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: EMPTY
43116: LIST
43117: ADD
43118: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43119: LD_ADDR_EXP 71
43123: PUSH
43124: LD_EXP 71
43128: PUSH
43129: LD_INT 0
43131: PUSH
43132: EMPTY
43133: LIST
43134: ADD
43135: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43136: LD_ADDR_EXP 73
43140: PUSH
43141: LD_EXP 73
43145: PUSH
43146: LD_INT 0
43148: PUSH
43149: EMPTY
43150: LIST
43151: ADD
43152: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43153: LD_ADDR_EXP 72
43157: PUSH
43158: LD_EXP 72
43162: PUSH
43163: LD_INT 0
43165: ADD
43166: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43167: LD_ADDR_EXP 64
43171: PUSH
43172: LD_EXP 64
43176: PUSH
43177: LD_INT 0
43179: PUSH
43180: LD_INT 0
43182: PUSH
43183: LD_INT 0
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: LIST
43190: ADD
43191: ST_TO_ADDR
// end ;
43192: GO 42352
43194: POP
43195: POP
// end ;
43196: LD_VAR 0 1
43200: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43201: LD_INT 0
43203: PPUSH
43204: PPUSH
43205: PPUSH
// m := false ;
43206: LD_ADDR_VAR 0 5
43210: PUSH
43211: LD_INT 0
43213: ST_TO_ADDR
// for i = 1 to mreg do
43214: LD_ADDR_VAR 0 4
43218: PUSH
43219: DOUBLE
43220: LD_INT 1
43222: DEC
43223: ST_TO_ADDR
43224: LD_VAR 0 2
43228: PUSH
43229: FOR_TO
43230: IFFALSE 43266
// if mreg [ i ] [ 1 ] = side then
43232: LD_VAR 0 2
43236: PUSH
43237: LD_VAR 0 4
43241: ARRAY
43242: PUSH
43243: LD_INT 1
43245: ARRAY
43246: PUSH
43247: LD_VAR 0 1
43251: EQUAL
43252: IFFALSE 43264
// begin m := true ;
43254: LD_ADDR_VAR 0 5
43258: PUSH
43259: LD_INT 1
43261: ST_TO_ADDR
// break ;
43262: GO 43266
// end ;
43264: GO 43229
43266: POP
43267: POP
// result := m ;
43268: LD_ADDR_VAR 0 3
43272: PUSH
43273: LD_VAR 0 5
43277: ST_TO_ADDR
// end ;
43278: LD_VAR 0 3
43282: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43283: LD_INT 0
43285: PPUSH
43286: PPUSH
43287: PPUSH
// m := 0 ;
43288: LD_ADDR_VAR 0 5
43292: PUSH
43293: LD_INT 0
43295: ST_TO_ADDR
// for i = 1 to mreg do
43296: LD_ADDR_VAR 0 4
43300: PUSH
43301: DOUBLE
43302: LD_INT 1
43304: DEC
43305: ST_TO_ADDR
43306: LD_VAR 0 2
43310: PUSH
43311: FOR_TO
43312: IFFALSE 43352
// if mreg [ i ] [ 1 ] = side then
43314: LD_VAR 0 2
43318: PUSH
43319: LD_VAR 0 4
43323: ARRAY
43324: PUSH
43325: LD_INT 1
43327: ARRAY
43328: PUSH
43329: LD_VAR 0 1
43333: EQUAL
43334: IFFALSE 43350
// begin m := m + 1 ;
43336: LD_ADDR_VAR 0 5
43340: PUSH
43341: LD_VAR 0 5
43345: PUSH
43346: LD_INT 1
43348: PLUS
43349: ST_TO_ADDR
// end ;
43350: GO 43311
43352: POP
43353: POP
// result := m ;
43354: LD_ADDR_VAR 0 3
43358: PUSH
43359: LD_VAR 0 5
43363: ST_TO_ADDR
// end ;
43364: LD_VAR 0 3
43368: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43369: LD_INT 0
43371: PPUSH
43372: PPUSH
// result := 0 ;
43373: LD_ADDR_VAR 0 3
43377: PUSH
43378: LD_INT 0
43380: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43381: LD_ADDR_VAR 0 4
43385: PUSH
43386: DOUBLE
43387: LD_INT 1
43389: DEC
43390: ST_TO_ADDR
43391: LD_EXP 55
43395: PUSH
43396: FOR_TO
43397: IFFALSE 43459
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43399: LD_EXP 55
43403: PUSH
43404: LD_VAR 0 4
43408: ARRAY
43409: PUSH
43410: LD_INT 1
43412: ARRAY
43413: PUSH
43414: LD_VAR 0 1
43418: EQUAL
43419: PUSH
43420: LD_EXP 55
43424: PUSH
43425: LD_VAR 0 4
43429: ARRAY
43430: PUSH
43431: LD_INT 2
43433: ARRAY
43434: PUSH
43435: LD_VAR 0 2
43439: EQUAL
43440: AND
43441: IFFALSE 43457
// begin result := result + 1 ;
43443: LD_ADDR_VAR 0 3
43447: PUSH
43448: LD_VAR 0 3
43452: PUSH
43453: LD_INT 1
43455: PLUS
43456: ST_TO_ADDR
// end ;
43457: GO 43396
43459: POP
43460: POP
// end ;
43461: LD_VAR 0 3
43465: RET
