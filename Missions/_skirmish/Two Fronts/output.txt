// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7640 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4617 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4916 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 41603 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42054 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21371 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21307 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18300 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21207 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22221 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21448 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21241 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21274 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 18079 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 22129 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20386 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20961 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20961 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20758 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20422 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20598 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19882 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20496 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20997 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21737 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21307 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18300 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21207 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21448 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21241 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21274 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 18079 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 22129 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20386 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20961 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20961 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20758 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20422 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20598 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19882 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20496 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20997 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21737 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 6
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 7
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 8
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 9
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 12
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 13
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 14
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 15
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 16
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 10
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// callUsed := false ;
1629: LD_ADDR_EXP 3
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19882 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11587 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21955 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11587 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21955 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11587 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21955 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11587 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21955 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 4
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 4
2743: PPUSH
2744: CALL 7859 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 4
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 5
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 5
2828: PPUSH
2829: CALL 7859 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 5
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7859 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7859 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7859 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4477
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 10
4389: PUSH
4390: LD_INT 9
4392: PUSH
4393: LD_INT 8
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: LIST
4400: PUSH
4401: LD_OWVAR 67
4405: ARRAY
4406: PPUSH
4407: LD_INT 10
4409: PUSH
4410: LD_INT 9
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: PUSH
4421: LD_OWVAR 67
4425: ARRAY
4426: PPUSH
4427: LD_INT -2
4429: PUSH
4430: LD_INT -5
4432: PUSH
4433: LD_INT -3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: LD_VAR 0 6
4445: ADD
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 2
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 3
4462: PUSH
4463: LD_INT 4
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 42
4476: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4477: LD_EXP 25
4481: PPUSH
4482: LD_INT 9
4484: PPUSH
4485: LD_INT 0
4487: PPUSH
4488: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4492: LD_VAR 0 5
4496: PUSH
4497: LD_INT 1
4499: ARRAY
4500: PPUSH
4501: LD_INT 2
4503: PPUSH
4504: CALL_OW 336
// for i = 1 to tmp do
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: DOUBLE
4514: LD_INT 1
4516: DEC
4517: ST_TO_ADDR
4518: LD_VAR 0 5
4522: PUSH
4523: FOR_TO
4524: IFFALSE 4579
// if i < 4 then
4526: LD_VAR 0 3
4530: PUSH
4531: LD_INT 4
4533: LESS
4534: IFFALSE 4559
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4536: LD_VAR 0 5
4540: PUSH
4541: LD_VAR 0 3
4545: ARRAY
4546: PPUSH
4547: LD_INT 9
4549: PPUSH
4550: LD_INT 0
4552: PPUSH
4553: CALL_OW 49
4557: GO 4577
// SetSide ( tmp [ i ] , 6 ) ;
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 3
4568: ARRAY
4569: PPUSH
4570: LD_INT 6
4572: PPUSH
4573: CALL_OW 235
4577: GO 4523
4579: POP
4580: POP
// player_squad := tmp ;
4581: LD_ADDR_EXP 23
4585: PUSH
4586: LD_VAR 0 5
4590: ST_TO_ADDR
// pl_counter := 4 ;
4591: LD_ADDR_EXP 24
4595: PUSH
4596: LD_INT 4
4598: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4599: LD_INT 17
4601: PPUSH
4602: LD_INT 5
4604: PPUSH
4605: LD_INT 1
4607: PPUSH
4608: CALL 18300 0 3
// end ;
4612: LD_VAR 0 2
4616: RET
// export Popov ; export function InitAction ; var commander ; begin
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4621: LD_INT 6
4623: PPUSH
4624: LD_INT 3
4626: PPUSH
4627: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 1
4636: PPUSH
4637: CALL_OW 86
// uc_side := 6 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 6
4648: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4649: LD_ADDR_EXP 26
4653: PUSH
4654: LD_STRING Popov
4656: PPUSH
4657: CALL_OW 25
4661: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4662: LD_ADDR_OWVAR 67
4666: PUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 426
4674: ST_TO_ADDR
// if not Difficulty then
4675: LD_OWVAR 67
4679: NOT
4680: IFFALSE 4690
// Difficulty := 2 ;
4682: LD_ADDR_OWVAR 67
4686: PUSH
4687: LD_INT 2
4689: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4690: LD_ADDR_VAR 0 2
4694: PUSH
4695: LD_INT 1
4697: PPUSH
4698: CALL_OW 426
4702: ST_TO_ADDR
// if not commander then
4703: LD_VAR 0 2
4707: NOT
4708: IFFALSE 4718
// commander := 1 ;
4710: LD_ADDR_VAR 0 2
4714: PUSH
4715: LD_INT 1
4717: ST_TO_ADDR
// InitCommanders ( commander ) ;
4718: LD_VAR 0 2
4722: PPUSH
4723: CALL 3137 0 1
// end ;
4727: LD_VAR 0 1
4731: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4732: LD_EXP 24
4736: PUSH
4737: LD_INT 12
4739: LESS
4740: IFFALSE 4913
4742: GO 4744
4744: DISABLE
4745: LD_INT 0
4747: PPUSH
// begin enable ;
4748: ENABLE
// for i = pl_counter to pl_counter + 2 do
4749: LD_ADDR_VAR 0 1
4753: PUSH
4754: DOUBLE
4755: LD_EXP 24
4759: DEC
4760: ST_TO_ADDR
4761: LD_EXP 24
4765: PUSH
4766: LD_INT 2
4768: PLUS
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4817
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4773: LD_EXP 23
4777: PUSH
4778: LD_VAR 0 1
4782: ARRAY
4783: PPUSH
4784: LD_INT 18
4786: PPUSH
4787: LD_INT 0
4789: PPUSH
4790: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4794: LD_EXP 23
4798: PUSH
4799: LD_VAR 0 1
4803: ARRAY
4804: PPUSH
4805: LD_INT 107
4807: PPUSH
4808: LD_INT 88
4810: PPUSH
4811: CALL_OW 111
// end ;
4815: GO 4770
4817: POP
4818: POP
// for i = pl_counter to pl_counter + 2 do
4819: LD_ADDR_VAR 0 1
4823: PUSH
4824: DOUBLE
4825: LD_EXP 24
4829: DEC
4830: ST_TO_ADDR
4831: LD_EXP 24
4835: PUSH
4836: LD_INT 2
4838: PLUS
4839: PUSH
4840: FOR_TO
4841: IFFALSE 4897
// begin repeat wait ( 0 0$01 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4850: LD_EXP 23
4854: PUSH
4855: LD_VAR 0 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 107
4863: PPUSH
4864: LD_INT 88
4866: PPUSH
4867: CALL_OW 297
4871: PUSH
4872: LD_INT 6
4874: LESS
4875: IFFALSE 4843
// SetSide ( player_squad [ i ] , 3 ) ;
4877: LD_EXP 23
4881: PUSH
4882: LD_VAR 0 1
4886: ARRAY
4887: PPUSH
4888: LD_INT 3
4890: PPUSH
4891: CALL_OW 235
// end ;
4895: GO 4840
4897: POP
4898: POP
// pl_counter := pl_counter + 3 ;
4899: LD_ADDR_EXP 24
4903: PUSH
4904: LD_EXP 24
4908: PUSH
4909: LD_INT 3
4911: PLUS
4912: ST_TO_ADDR
// end ;
4913: PPOPN 1
4915: END
// export function Dialog ; begin
4916: LD_INT 0
4918: PPUSH
// if not isTest then
4919: LD_EXP 1
4923: NOT
4924: IFFALSE 4946
// case query ( task ) of 1 :
4926: LD_STRING task
4928: PPUSH
4929: CALL_OW 97
4933: PUSH
4934: LD_INT 1
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4945
4942: POP
// ; end ;
4943: GO 4946
4945: POP
// InGameOn ;
4946: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4950: LD_INT 107
4952: PPUSH
4953: LD_INT 84
4955: PPUSH
4956: CALL_OW 86
// if isTest then
4960: LD_EXP 1
4964: IFFALSE 4974
// dialogue_skipped := true ;
4966: LD_ADDR_OWVAR 59
4970: PUSH
4971: LD_INT 1
4973: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4974: LD_ADDR_EXP 11
4978: PUSH
4979: LD_EXP 23
4983: PUSH
4984: LD_INT 1
4986: ARRAY
4987: PPUSH
4988: LD_INT 0
4990: PPUSH
4991: LD_INT 96
4993: PPUSH
4994: LD_INT 79
4996: PPUSH
4997: LD_INT 2
4999: PPUSH
5000: CALL_OW 145
5004: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5005: LD_INT 35
5007: PPUSH
5008: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
5012: LD_EXP 26
5016: PPUSH
5017: LD_STRING DR1
5019: PPUSH
5020: CALL_OW 94
// Wait ( 0 0$01 ) ;
5024: LD_INT 35
5026: PPUSH
5027: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
5031: LD_EXP 26
5035: PPUSH
5036: LD_STRING DR2
5038: PPUSH
5039: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5043: LD_EXP 26
5047: PPUSH
5048: LD_STRING DR3
5050: PPUSH
5051: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5062: LD_INT 3
5064: PPUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 0
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PPUSH
5075: CALL 11587 0 2
5079: PUSH
5080: LD_EXP 1
5084: OR
5085: IFFALSE 5055
// InGameOff ;
5087: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5091: LD_STRING C1
5093: PPUSH
5094: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5105: LD_EXP 11
5109: PPUSH
5110: CALL_OW 461
5114: PUSH
5115: LD_INT 2
5117: EQUAL
5118: IFFALSE 5098
// if not isTest then
5120: LD_EXP 1
5124: NOT
5125: IFFALSE 5147
// case query ( support ) of 1 :
5127: LD_STRING support
5129: PPUSH
5130: CALL_OW 97
5134: PUSH
5135: LD_INT 1
5137: DOUBLE
5138: EQUAL
5139: IFTRUE 5143
5141: GO 5146
5143: POP
// ; end ;
5144: GO 5147
5146: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5147: LD_INT 3
5149: PPUSH
5150: LD_INT 12
5152: PPUSH
5153: LD_INT 2
5155: PPUSH
5156: LD_INT 22
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 30
5168: PUSH
5169: LD_INT 0
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 69
5184: PUSH
5185: LD_INT 1
5187: ARRAY
5188: PPUSH
5189: CALL_OW 468
// if player_com = stolypin then
5193: LD_EXP 25
5197: PUSH
5198: LD_EXP 22
5202: EQUAL
5203: IFFALSE 5232
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5205: LD_INT 18
5207: PPUSH
5208: LD_INT 3
5210: PUSH
5211: LD_INT 3
5213: PUSH
5214: LD_INT 2
5216: PUSH
5217: EMPTY
5218: LIST
5219: LIST
5220: LIST
5221: PUSH
5222: LD_OWVAR 67
5226: ARRAY
5227: PPUSH
5228: CALL 6656 0 2
// end ;
5232: LD_VAR 0 1
5236: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5237: LD_EXP 12
5241: PUSH
5242: LD_OWVAR 1
5246: PUSH
5247: LD_INT 31500
5249: LESS
5250: AND
5251: IFFALSE 5423
// case query ( call1 ) of 1 :
5253: LD_STRING call1
5255: PPUSH
5256: CALL_OW 97
5260: PUSH
5261: LD_INT 1
5263: DOUBLE
5264: EQUAL
5265: IFTRUE 5269
5267: GO 5411
5269: POP
// begin callUsed := true ;
5270: LD_ADDR_EXP 3
5274: PUSH
5275: LD_INT 1
5277: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5278: LD_INT 3
5280: PPUSH
5281: LD_INT 12
5283: PPUSH
5284: LD_INT 1
5286: PPUSH
5287: LD_EXP 11
5291: PPUSH
5292: CALL_OW 468
// call := false ;
5296: LD_ADDR_EXP 12
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5304: LD_EXP 26
5308: PPUSH
5309: LD_STRING DR6
5311: PPUSH
5312: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5316: LD_INT 6300
5318: PPUSH
5319: LD_INT 8400
5321: PPUSH
5322: CALL_OW 12
5326: PPUSH
5327: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5331: LD_INT 18
5333: PUSH
5334: LD_INT 19
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 1
5343: PPUSH
5344: LD_INT 2
5346: PPUSH
5347: CALL_OW 12
5351: ARRAY
5352: PPUSH
5353: LD_INT 1
5355: PPUSH
5356: LD_INT 2
5358: PPUSH
5359: CALL_OW 12
5363: PPUSH
5364: CALL 6656 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5368: LD_INT 25200
5370: PPUSH
5371: LD_INT 35700
5373: PPUSH
5374: CALL_OW 12
5378: PPUSH
5379: CALL_OW 67
// call := true ;
5383: LD_ADDR_EXP 12
5387: PUSH
5388: LD_INT 1
5390: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 12
5396: PPUSH
5397: LD_INT 2
5399: PPUSH
5400: LD_EXP 11
5404: PPUSH
5405: CALL_OW 468
// end ; 2 :
5409: GO 5423
5411: LD_INT 2
5413: DOUBLE
5414: EQUAL
5415: IFTRUE 5419
5417: GO 5422
5419: POP
// ; end ;
5420: GO 5423
5422: POP
// if call and tick >= 15 15$00 then
5423: LD_EXP 12
5427: PUSH
5428: LD_OWVAR 1
5432: PUSH
5433: LD_INT 31500
5435: GREATEREQUAL
5436: AND
5437: IFFALSE 5882
// case query ( call2 ) of 1 :
5439: LD_STRING call2
5441: PPUSH
5442: CALL_OW 97
5446: PUSH
5447: LD_INT 1
5449: DOUBLE
5450: EQUAL
5451: IFTRUE 5455
5453: GO 5699
5455: POP
// begin callUsed := true ;
5456: LD_ADDR_EXP 3
5460: PUSH
5461: LD_INT 1
5463: ST_TO_ADDR
// call := false ;
5464: LD_ADDR_EXP 12
5468: PUSH
5469: LD_INT 0
5471: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5472: LD_INT 1
5474: PPUSH
5475: LD_INT 21
5477: PUSH
5478: LD_INT 3
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PPUSH
5485: CALL 11587 0 2
5489: PUSH
5490: LD_INT 4
5492: PPUSH
5493: LD_INT 21
5495: PUSH
5496: LD_INT 3
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 11587 0 2
5507: AND
5508: IFFALSE 5556
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5510: LD_INT 18
5512: PUSH
5513: LD_INT 19
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: LD_INT 1
5522: PPUSH
5523: LD_INT 2
5525: PPUSH
5526: CALL_OW 12
5530: ARRAY
5531: PPUSH
5532: LD_INT 5
5534: PUSH
5535: LD_INT 4
5537: PUSH
5538: LD_INT 4
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_OWVAR 67
5550: ARRAY
5551: PPUSH
5552: CALL 6417 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5556: LD_INT 1
5558: PPUSH
5559: LD_INT 21
5561: PUSH
5562: LD_INT 3
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PPUSH
5569: CALL 11587 0 2
5573: PUSH
5574: LD_INT 0
5576: EQUAL
5577: IFFALSE 5606
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5579: LD_INT 19
5581: PPUSH
5582: LD_INT 5
5584: PUSH
5585: LD_INT 4
5587: PUSH
5588: LD_INT 3
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PUSH
5596: LD_OWVAR 67
5600: ARRAY
5601: PPUSH
5602: CALL 6417 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5606: LD_INT 4
5608: PPUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 3
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PPUSH
5619: CALL 11587 0 2
5623: PUSH
5624: LD_INT 0
5626: EQUAL
5627: IFFALSE 5656
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5629: LD_INT 18
5631: PPUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 4
5637: PUSH
5638: LD_INT 4
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: LIST
5645: PUSH
5646: LD_OWVAR 67
5650: ARRAY
5651: PPUSH
5652: CALL 6417 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5656: LD_INT 10500
5658: PPUSH
5659: LD_INT 23100
5661: PPUSH
5662: CALL_OW 12
5666: PPUSH
5667: CALL_OW 67
// call := true ;
5671: LD_ADDR_EXP 12
5675: PUSH
5676: LD_INT 1
5678: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5679: LD_INT 3
5681: PPUSH
5682: LD_INT 12
5684: PPUSH
5685: LD_INT 2
5687: PPUSH
5688: LD_EXP 11
5692: PPUSH
5693: CALL_OW 468
// end ; 2 :
5697: GO 5882
5699: LD_INT 2
5701: DOUBLE
5702: EQUAL
5703: IFTRUE 5707
5705: GO 5870
5707: POP
// begin callUsed := true ;
5708: LD_ADDR_EXP 3
5712: PUSH
5713: LD_INT 1
5715: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5716: LD_INT 3
5718: PPUSH
5719: LD_INT 12
5721: PPUSH
5722: LD_INT 1
5724: PPUSH
5725: LD_EXP 11
5729: PPUSH
5730: CALL_OW 468
// call := false ;
5734: LD_ADDR_EXP 12
5738: PUSH
5739: LD_INT 0
5741: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5742: LD_EXP 26
5746: PPUSH
5747: LD_STRING DR6
5749: PPUSH
5750: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5754: LD_INT 6300
5756: PPUSH
5757: LD_INT 8400
5759: PPUSH
5760: CALL_OW 12
5764: PPUSH
5765: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5769: LD_INT 18
5771: PUSH
5772: LD_INT 19
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PUSH
5779: LD_INT 1
5781: PPUSH
5782: LD_INT 2
5784: PPUSH
5785: CALL_OW 12
5789: ARRAY
5790: PPUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 2
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PUSH
5805: LD_OWVAR 67
5809: ARRAY
5810: PUSH
5811: LD_INT 0
5813: PPUSH
5814: LD_INT 1
5816: PPUSH
5817: CALL_OW 12
5821: MINUS
5822: PPUSH
5823: CALL 6656 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5827: LD_INT 35700
5829: PPUSH
5830: LD_INT 44100
5832: PPUSH
5833: CALL_OW 12
5837: PPUSH
5838: CALL_OW 67
// call := true ;
5842: LD_ADDR_EXP 12
5846: PUSH
5847: LD_INT 1
5849: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5850: LD_INT 3
5852: PPUSH
5853: LD_INT 12
5855: PPUSH
5856: LD_INT 2
5858: PPUSH
5859: LD_EXP 11
5863: PPUSH
5864: CALL_OW 468
// end ; 3 :
5868: GO 5882
5870: LD_INT 3
5872: DOUBLE
5873: EQUAL
5874: IFTRUE 5878
5876: GO 5881
5878: POP
// ; end ;
5879: GO 5882
5881: POP
// end ;
5882: PPOPN 4
5884: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5885: LD_INT 22
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 21
5897: PUSH
5898: LD_INT 1
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PPUSH
5909: CALL_OW 69
5913: PUSH
5914: LD_INT 0
5916: EQUAL
5917: PUSH
5918: LD_INT 22
5920: PUSH
5921: LD_INT 4
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: LD_INT 21
5930: PUSH
5931: LD_INT 1
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL_OW 69
5946: PUSH
5947: LD_INT 0
5949: EQUAL
5950: AND
5951: IFFALSE 6255
5953: GO 5955
5955: DISABLE
// begin DialogueOn ;
5956: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5960: LD_EXP 26
5964: PPUSH
5965: LD_STRING DR7
5967: PPUSH
5968: CALL_OW 94
// case player_com of Gorki :
5972: LD_EXP 25
5976: PUSH
5977: LD_EXP 21
5981: DOUBLE
5982: EQUAL
5983: IFTRUE 5987
5985: GO 5997
5987: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5988: LD_STRING ACH_GORKI
5990: PPUSH
5991: CALL_OW 543
5995: GO 6058
5997: LD_EXP 22
6001: DOUBLE
6002: EQUAL
6003: IFTRUE 6007
6005: GO 6017
6007: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
6008: LD_STRING ACH_STOLYP
6010: PPUSH
6011: CALL_OW 543
6015: GO 6058
6017: LD_EXP 20
6021: DOUBLE
6022: EQUAL
6023: IFTRUE 6027
6025: GO 6037
6027: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
6028: LD_STRING ACH_DAVIDOV
6030: PPUSH
6031: CALL_OW 543
6035: GO 6058
6037: LD_EXP 19
6041: DOUBLE
6042: EQUAL
6043: IFTRUE 6047
6045: GO 6057
6047: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6048: LD_STRING ACH_GLADKOV
6050: PPUSH
6051: CALL_OW 543
6055: GO 6058
6057: POP
// if not callUsed then
6058: LD_EXP 3
6062: NOT
6063: IFFALSE 6072
// SetAchievement ( ACH_NOSUPP ) ;
6065: LD_STRING ACH_NOSUPP
6067: PPUSH
6068: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6072: LD_OWVAR 1
6076: PUSH
6077: LD_INT 116550
6079: PUSH
6080: LD_INT 95550
6082: PUSH
6083: LD_INT 89250
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: PUSH
6091: LD_OWVAR 67
6095: ARRAY
6096: LESS
6097: IFFALSE 6111
// AddMedal ( med1 , 1 ) else
6099: LD_STRING med1
6101: PPUSH
6102: LD_INT 1
6104: PPUSH
6105: CALL_OW 101
6109: GO 6122
// AddMedal ( med1 , - 1 ) ;
6111: LD_STRING med1
6113: PPUSH
6114: LD_INT 1
6116: NEG
6117: PPUSH
6118: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6122: LD_INT 81
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 21
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PUSH
6151: LD_INT 0
6153: EQUAL
6154: IFFALSE 6168
// AddMedal ( med3 , 1 ) else
6156: LD_STRING med3
6158: PPUSH
6159: LD_INT 1
6161: PPUSH
6162: CALL_OW 101
6166: GO 6179
// AddMedal ( med3 , - 1 ) ;
6168: LD_STRING med3
6170: PPUSH
6171: LD_INT 1
6173: NEG
6174: PPUSH
6175: CALL_OW 101
// if player_loss = 0 then
6179: LD_EXP 10
6183: PUSH
6184: LD_INT 0
6186: EQUAL
6187: IFFALSE 6201
// AddMedal ( med2 , 1 ) else
6189: LD_STRING med2
6191: PPUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 101
6199: GO 6244
// if player_loss > 0 and player_loss < 3 then
6201: LD_EXP 10
6205: PUSH
6206: LD_INT 0
6208: GREATER
6209: PUSH
6210: LD_EXP 10
6214: PUSH
6215: LD_INT 3
6217: LESS
6218: AND
6219: IFFALSE 6233
// AddMedal ( med2 , 2 ) else
6221: LD_STRING med2
6223: PPUSH
6224: LD_INT 2
6226: PPUSH
6227: CALL_OW 101
6231: GO 6244
// AddMedal ( med2 , - 1 ) ;
6233: LD_STRING med2
6235: PPUSH
6236: LD_INT 1
6238: NEG
6239: PPUSH
6240: CALL_OW 101
// GiveMedals ( MAIN ) ;
6244: LD_STRING MAIN
6246: PPUSH
6247: CALL_OW 102
// YouWin ;
6251: CALL_OW 103
// end ;
6255: END
// every 0 0$01 trigger IsDead ( player_com ) do
6256: LD_EXP 25
6260: PPUSH
6261: CALL_OW 301
6265: IFFALSE 6332
6267: GO 6269
6269: DISABLE
// begin if IsLive ( Houten ) then
6270: LD_EXP 4
6274: PPUSH
6275: CALL_OW 300
6279: IFFALSE 6295
// SayRadio ( Houten , DJ5 ) else
6281: LD_EXP 4
6285: PPUSH
6286: LD_STRING DJ5
6288: PPUSH
6289: CALL_OW 94
6293: GO 6318
// if IsLive ( Brown ) then
6295: LD_EXP 5
6299: PPUSH
6300: CALL_OW 300
6304: IFFALSE 6318
// SayRadio ( Brown , DS5 ) ;
6306: LD_EXP 5
6310: PPUSH
6311: LD_STRING DS5
6313: PPUSH
6314: CALL_OW 94
// Wait ( 0 0$01 ) ;
6318: LD_INT 35
6320: PPUSH
6321: CALL_OW 67
// YouLost ( dead ) ;
6325: LD_STRING dead
6327: PPUSH
6328: CALL_OW 104
// end ;
6332: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6333: LD_EXP 11
6337: PPUSH
6338: CALL_OW 301
6342: PUSH
6343: LD_EXP 1
6347: NOT
6348: AND
6349: IFFALSE 6416
6351: GO 6353
6353: DISABLE
// begin if IsLive ( Brown ) then
6354: LD_EXP 5
6358: PPUSH
6359: CALL_OW 300
6363: IFFALSE 6379
// SayRadio ( Brown , DS5 ) else
6365: LD_EXP 5
6369: PPUSH
6370: LD_STRING DS5
6372: PPUSH
6373: CALL_OW 94
6377: GO 6402
// if IsLive ( Houten ) then
6379: LD_EXP 4
6383: PPUSH
6384: CALL_OW 300
6388: IFFALSE 6402
// SayRadio ( Houten , DJ5 ) ;
6390: LD_EXP 4
6394: PPUSH
6395: LD_STRING DJ5
6397: PPUSH
6398: CALL_OW 94
// Wait ( 0 0$01 ) ;
6402: LD_INT 35
6404: PPUSH
6405: CALL_OW 67
// YouLost ( depot ) ;
6409: LD_STRING depot
6411: PPUSH
6412: CALL_OW 104
// end ;
6416: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6417: LD_INT 0
6419: PPUSH
6420: PPUSH
6421: PPUSH
// for i = 1 to n do
6422: LD_ADDR_VAR 0 4
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_TO
6438: IFFALSE 6641
// begin uc_side := 6 ;
6440: LD_ADDR_OWVAR 20
6444: PUSH
6445: LD_INT 6
6447: ST_TO_ADDR
// uc_nation := 3 ;
6448: LD_ADDR_OWVAR 21
6452: PUSH
6453: LD_INT 3
6455: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6456: LD_ADDR_OWVAR 37
6460: PUSH
6461: LD_INT 23
6463: PUSH
6464: LD_INT 22
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 1
6473: PPUSH
6474: LD_INT 2
6476: PPUSH
6477: CALL_OW 12
6481: ARRAY
6482: ST_TO_ADDR
// vc_control := control_computer ;
6483: LD_ADDR_OWVAR 38
6487: PUSH
6488: LD_INT 3
6490: ST_TO_ADDR
// vc_engine := engine_siberite ;
6491: LD_ADDR_OWVAR 39
6495: PUSH
6496: LD_INT 3
6498: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6499: LD_ADDR_OWVAR 40
6503: PUSH
6504: LD_INT 43
6506: PUSH
6507: LD_INT 44
6509: PUSH
6510: LD_INT 44
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 1
6520: PPUSH
6521: LD_INT 3
6523: PPUSH
6524: CALL_OW 12
6528: ARRAY
6529: ST_TO_ADDR
// un := CreateVehicle ;
6530: LD_ADDR_VAR 0 5
6534: PUSH
6535: CALL_OW 45
6539: ST_TO_ADDR
// case area of east_arr :
6540: LD_VAR 0 1
6544: PUSH
6545: LD_INT 18
6547: DOUBLE
6548: EQUAL
6549: IFTRUE 6553
6551: GO 6588
6553: POP
// begin PlaceUnitArea ( un , area , false ) ;
6554: LD_VAR 0 5
6558: PPUSH
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 0
6566: PPUSH
6567: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_INT 79
6578: PPUSH
6579: LD_INT 33
6581: PPUSH
6582: CALL_OW 111
// end ; south_arr :
6586: GO 6632
6588: LD_INT 19
6590: DOUBLE
6591: EQUAL
6592: IFTRUE 6596
6594: GO 6631
6596: POP
// begin PlaceUnitArea ( un , area , false ) ;
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 1
6606: PPUSH
6607: LD_INT 0
6609: PPUSH
6610: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 131
6621: PPUSH
6622: LD_INT 148
6624: PPUSH
6625: CALL_OW 111
// end ; end ;
6629: GO 6632
6631: POP
// Wait ( 0 0$02 ) ;
6632: LD_INT 70
6634: PPUSH
6635: CALL_OW 67
// end ;
6639: GO 6437
6641: POP
6642: POP
// pink_attack := true ;
6643: LD_ADDR_EXP 13
6647: PUSH
6648: LD_INT 1
6650: ST_TO_ADDR
// end ;
6651: LD_VAR 0 3
6655: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// for i = 1 to n do
6661: LD_ADDR_VAR 0 4
6665: PUSH
6666: DOUBLE
6667: LD_INT 1
6669: DEC
6670: ST_TO_ADDR
6671: LD_VAR 0 2
6675: PUSH
6676: FOR_TO
6677: IFFALSE 6903
// begin uc_side := 6 ;
6679: LD_ADDR_OWVAR 20
6683: PUSH
6684: LD_INT 6
6686: ST_TO_ADDR
// uc_nation := 3 ;
6687: LD_ADDR_OWVAR 21
6691: PUSH
6692: LD_INT 3
6694: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6695: LD_INT 0
6697: PPUSH
6698: LD_INT 3
6700: PPUSH
6701: LD_INT 4
6703: PPUSH
6704: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6708: LD_ADDR_OWVAR 37
6712: PUSH
6713: LD_INT 22
6715: ST_TO_ADDR
// vc_control := control_manual ;
6716: LD_ADDR_OWVAR 38
6720: PUSH
6721: LD_INT 1
6723: ST_TO_ADDR
// vc_engine := engine_combustion ;
6724: LD_ADDR_OWVAR 39
6728: PUSH
6729: LD_INT 1
6731: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6732: LD_ADDR_OWVAR 40
6736: PUSH
6737: LD_INT 51
6739: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6740: LD_ADDR_OWVAR 41
6744: PUSH
6745: LD_INT 50
6747: ST_TO_ADDR
// un := CreateVehicle ;
6748: LD_ADDR_VAR 0 5
6752: PUSH
6753: CALL_OW 45
6757: ST_TO_ADDR
// case area of east_arr :
6758: LD_VAR 0 1
6762: PUSH
6763: LD_INT 18
6765: DOUBLE
6766: EQUAL
6767: IFTRUE 6771
6769: GO 6786
6771: POP
// SetDir ( un , 4 ) ; south_arr :
6772: LD_VAR 0 5
6776: PPUSH
6777: LD_INT 4
6779: PPUSH
6780: CALL_OW 233
6784: GO 6810
6786: LD_INT 19
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6809
6794: POP
// SetDir ( un , 5 ) ; end ;
6795: LD_VAR 0 5
6799: PPUSH
6800: LD_INT 5
6802: PPUSH
6803: CALL_OW 233
6807: GO 6810
6809: POP
// PlaceUnitArea ( un , area , false ) ;
6810: LD_VAR 0 5
6814: PPUSH
6815: LD_VAR 0 1
6819: PPUSH
6820: LD_INT 0
6822: PPUSH
6823: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6827: CALL_OW 44
6831: PPUSH
6832: LD_VAR 0 5
6836: PPUSH
6837: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6841: LD_VAR 0 5
6845: PPUSH
6846: LD_INT 1
6848: PPUSH
6849: LD_INT 100
6851: PPUSH
6852: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6856: LD_VAR 0 5
6860: PPUSH
6861: LD_INT 106
6863: PPUSH
6864: LD_INT 88
6866: PPUSH
6867: CALL_OW 111
// AddComUnload ( un ) ;
6871: LD_VAR 0 5
6875: PPUSH
6876: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6880: LD_VAR 0 5
6884: PPUSH
6885: LD_VAR 0 1
6889: PPUSH
6890: CALL_OW 173
// Wait ( 0 0$02 ) ;
6894: LD_INT 70
6896: PPUSH
6897: CALL_OW 67
// end ;
6901: GO 6676
6903: POP
6904: POP
// Wait ( 0 0$05 ) ;
6905: LD_INT 175
6907: PPUSH
6908: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6912: LD_INT 6
6914: PPUSH
6915: LD_INT 34
6917: PUSH
6918: LD_INT 51
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: CALL 11587 0 2
6929: IFFALSE 7117
// begin wait ( 0 0$01 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6938: LD_ADDR_VAR 0 4
6942: PUSH
6943: LD_INT 6
6945: PPUSH
6946: LD_INT 34
6948: PUSH
6949: LD_INT 51
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: CALL 11587 0 2
6960: PUSH
6961: FOR_IN
6962: IFFALSE 7113
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6964: LD_VAR 0 4
6968: PPUSH
6969: LD_INT 9
6971: PPUSH
6972: CALL_OW 308
6976: PUSH
6977: LD_VAR 0 4
6981: PPUSH
6982: CALL 31695 0 1
6986: PPUSH
6987: CALL_OW 258
6991: PUSH
6992: LD_INT 1
6994: EQUAL
6995: AND
6996: PUSH
6997: LD_EXP 9
7001: AND
7002: IFFALSE 7029
// begin Say ( GetDriver ( i ) , Dtran ) ;
7004: LD_VAR 0 4
7008: PPUSH
7009: CALL 31695 0 1
7013: PPUSH
7014: LD_STRING Dtran
7016: PPUSH
7017: CALL_OW 88
// dialog_trans := false ;
7021: LD_ADDR_EXP 9
7025: PUSH
7026: LD_INT 0
7028: ST_TO_ADDR
// end ; if IsIdle ( i ) then
7029: LD_VAR 0 4
7033: PPUSH
7034: CALL_OW 316
7038: IFFALSE 7054
// ComMoveToArea ( i , area ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: LD_VAR 0 1
7049: PPUSH
7050: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7054: LD_VAR 0 4
7058: PPUSH
7059: LD_VAR 0 1
7063: PPUSH
7064: CALL_OW 308
7068: PUSH
7069: LD_VAR 0 4
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL_OW 289
7081: PUSH
7082: LD_INT 0
7084: EQUAL
7085: AND
7086: IFFALSE 7111
// begin RemoveUnit ( GetDriver ( i ) ) ;
7088: LD_VAR 0 4
7092: PPUSH
7093: CALL 31695 0 1
7097: PPUSH
7098: CALL_OW 64
// RemoveUnit ( i ) ;
7102: LD_VAR 0 4
7106: PPUSH
7107: CALL_OW 64
// end ; end ;
7111: GO 6961
7113: POP
7114: POP
// end ;
7115: GO 6912
// end ;
7117: LD_VAR 0 3
7121: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7122: LD_INT 0
7124: PPUSH
7125: PPUSH
7126: PPUSH
7127: PPUSH
// if isTest then
7128: LD_EXP 1
7132: IFFALSE 7136
// exit ;
7134: GO 7525
// for i = 1 to n do
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: DOUBLE
7142: LD_INT 1
7144: DEC
7145: ST_TO_ADDR
7146: LD_VAR 0 2
7150: PUSH
7151: FOR_TO
7152: IFFALSE 7384
// begin uc_side := 8 ;
7154: LD_ADDR_OWVAR 20
7158: PUSH
7159: LD_INT 8
7161: ST_TO_ADDR
// uc_nation := 1 ;
7162: LD_ADDR_OWVAR 21
7166: PUSH
7167: LD_INT 1
7169: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7170: LD_ADDR_VAR 0 6
7174: PUSH
7175: LD_INT 3
7177: PUSH
7178: LD_INT 4
7180: PUSH
7181: LD_INT 4
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_INT 1
7191: PPUSH
7192: LD_OWVAR 67
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: ST_TO_ADDR
// vc_chassis := ch ;
7203: LD_ADDR_OWVAR 37
7207: PUSH
7208: LD_VAR 0 6
7212: ST_TO_ADDR
// vc_control := control_computer ;
7213: LD_ADDR_OWVAR 38
7217: PUSH
7218: LD_INT 3
7220: ST_TO_ADDR
// vc_engine := engine_combustion ;
7221: LD_ADDR_OWVAR 39
7225: PUSH
7226: LD_INT 1
7228: ST_TO_ADDR
// if ch = us_medium_tracked then
7229: LD_VAR 0 6
7233: PUSH
7234: LD_INT 3
7236: EQUAL
7237: IFFALSE 7284
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7239: LD_ADDR_OWVAR 40
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 4
7249: PUSH
7250: LD_INT 5
7252: PUSH
7253: LD_INT 7
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: PPUSH
7267: LD_OWVAR 67
7271: PUSH
7272: LD_INT 1
7274: PLUS
7275: PPUSH
7276: CALL_OW 12
7280: ARRAY
7281: ST_TO_ADDR
7282: GO 7325
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7284: LD_ADDR_OWVAR 40
7288: PUSH
7289: LD_INT 5
7291: PUSH
7292: LD_INT 6
7294: PUSH
7295: LD_INT 7
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 1
7309: PPUSH
7310: LD_OWVAR 67
7314: PUSH
7315: LD_INT 1
7317: PLUS
7318: PPUSH
7319: CALL_OW 12
7323: ARRAY
7324: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7325: LD_ADDR_OWVAR 41
7329: PUSH
7330: LD_INT 70
7332: ST_TO_ADDR
// un := CreateVehicle ;
7333: LD_ADDR_VAR 0 5
7337: PUSH
7338: CALL_OW 45
7342: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7343: LD_VAR 0 5
7347: PPUSH
7348: LD_VAR 0 1
7352: PPUSH
7353: LD_INT 0
7355: PPUSH
7356: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7360: LD_VAR 0 5
7364: PPUSH
7365: LD_INT 65
7367: PPUSH
7368: LD_INT 9
7370: PPUSH
7371: CALL_OW 111
// Wait ( 0 0$02 ) ;
7375: LD_INT 70
7377: PPUSH
7378: CALL_OW 67
// end ;
7382: GO 7151
7384: POP
7385: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7386: LD_INT 90
7388: PUSH
7389: LD_INT 80
7391: PUSH
7392: LD_INT 70
7394: PUSH
7395: EMPTY
7396: LIST
7397: LIST
7398: LIST
7399: PUSH
7400: LD_OWVAR 67
7404: ARRAY
7405: PPUSH
7406: CALL_OW 13
7410: IFFALSE 7517
// begin uc_side := 8 ;
7412: LD_ADDR_OWVAR 20
7416: PUSH
7417: LD_INT 8
7419: ST_TO_ADDR
// uc_nation := 1 ;
7420: LD_ADDR_OWVAR 21
7424: PUSH
7425: LD_INT 1
7427: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7428: LD_ADDR_OWVAR 37
7432: PUSH
7433: LD_INT 4
7435: ST_TO_ADDR
// vc_control := control_computer ;
7436: LD_ADDR_OWVAR 38
7440: PUSH
7441: LD_INT 3
7443: ST_TO_ADDR
// vc_engine := engine_combustion ;
7444: LD_ADDR_OWVAR 39
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7452: LD_ADDR_OWVAR 40
7456: PUSH
7457: LD_INT 14
7459: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7460: LD_ADDR_OWVAR 41
7464: PUSH
7465: LD_INT 70
7467: ST_TO_ADDR
// un := CreateVehicle ;
7468: LD_ADDR_VAR 0 5
7472: PUSH
7473: CALL_OW 45
7477: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7478: LD_VAR 0 5
7482: PPUSH
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 0
7490: PPUSH
7491: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7495: LD_VAR 0 5
7499: PPUSH
7500: LD_INT 65
7502: PPUSH
7503: LD_INT 9
7505: PPUSH
7506: CALL_OW 111
// Wait ( 0 0$02 ) ;
7510: LD_INT 70
7512: PPUSH
7513: CALL_OW 67
// end ; alfa_support := true ;
7517: LD_ADDR_EXP 14
7521: PUSH
7522: LD_INT 1
7524: ST_TO_ADDR
// end ;
7525: LD_VAR 0 3
7529: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7530: LD_OWVAR 1
7534: PUSH
7535: LD_INT 21000
7537: PUSH
7538: LD_INT 18900
7540: PUSH
7541: LD_INT 16800
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: LD_OWVAR 67
7553: ARRAY
7554: GREATER
7555: IFFALSE 7639
7557: GO 7559
7559: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7560: LD_EXP 26
7564: PPUSH
7565: LD_STRING DR5
7567: PPUSH
7568: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7572: LD_INT 1050
7574: PPUSH
7575: LD_INT 4200
7577: PPUSH
7578: CALL_OW 12
7582: PPUSH
7583: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 8 ] [ Difficulty ] ) ;
7587: LD_INT 20
7589: PPUSH
7590: LD_INT 5
7592: PUSH
7593: LD_INT 6
7595: PUSH
7596: LD_INT 8
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: PUSH
7604: LD_OWVAR 67
7608: ARRAY
7609: PPUSH
7610: CALL 7122 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7614: LD_INT 8400
7616: PPUSH
7617: LD_INT 12600
7619: PPUSH
7620: CALL_OW 12
7624: PPUSH
7625: CALL_OW 67
// until tick >= 120 120$00 ;
7629: LD_OWVAR 1
7633: PUSH
7634: LD_INT 252000
7636: GREATEREQUAL
7637: IFFALSE 7560
// end ; end_of_file
7639: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7640: LD_INT 0
7642: PPUSH
// enable_addtolog := isTest ;
7643: LD_ADDR_OWVAR 81
7647: PUSH
7648: LD_EXP 1
7652: ST_TO_ADDR
// lines_break_limit := 5 ;
7653: LD_ADDR_EXP 28
7657: PUSH
7658: LD_INT 5
7660: ST_TO_ADDR
// lines_break_type := --- ;
7661: LD_ADDR_EXP 29
7665: PUSH
7666: LD_STRING ---
7668: ST_TO_ADDR
// lines_counter := 0 ;
7669: LD_ADDR_EXP 27
7673: PUSH
7674: LD_INT 0
7676: ST_TO_ADDR
// show_line_index := true ;
7677: LD_ADDR_EXP 30
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// tick_log := true ;
7685: LD_ADDR_EXP 31
7689: PUSH
7690: LD_INT 1
7692: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7693: LD_STRING ----------SAND OF SIBERIA LOG----------
7695: PPUSH
7696: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7700: LD_STRING Map Name: 
7702: PUSH
7703: LD_OWVAR 68
7707: STR
7708: PPUSH
7709: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7713: LD_STRING Map Number: 
7715: PUSH
7716: LD_OWVAR 70
7720: STR
7721: PPUSH
7722: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7726: LD_STRING Difficulty: 
7728: PUSH
7729: LD_OWVAR 67
7733: STR
7734: PPUSH
7735: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7739: LD_STRING ---------------------------------------
7741: PPUSH
7742: CALL_OW 561
// end ;
7746: LD_VAR 0 1
7750: RET
// function Log ( text ) ; begin
7751: LD_INT 0
7753: PPUSH
// if show_line_index then
7754: LD_EXP 30
7758: IFFALSE 7770
// result := lines_counter ;
7760: LD_ADDR_VAR 0 2
7764: PUSH
7765: LD_EXP 27
7769: ST_TO_ADDR
// if tick_log then
7770: LD_EXP 31
7774: IFFALSE 7800
// result := result &  T:  & tick &   ;
7776: LD_ADDR_VAR 0 2
7780: PUSH
7781: LD_VAR 0 2
7785: PUSH
7786: LD_STRING  T: 
7788: STR
7789: PUSH
7790: LD_OWVAR 1
7794: STR
7795: PUSH
7796: LD_STRING  
7798: STR
7799: ST_TO_ADDR
// AddToLog ( result & text ) ;
7800: LD_VAR 0 2
7804: PUSH
7805: LD_VAR 0 1
7809: STR
7810: PPUSH
7811: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7815: LD_ADDR_EXP 27
7819: PUSH
7820: LD_EXP 27
7824: PUSH
7825: LD_INT 1
7827: PLUS
7828: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7829: LD_EXP 27
7833: PUSH
7834: LD_EXP 28
7838: MOD
7839: PUSH
7840: LD_INT 0
7842: EQUAL
7843: IFFALSE 7854
// AddToLog ( lines_break_type ) ;
7845: LD_EXP 29
7849: PPUSH
7850: CALL_OW 561
// end ;
7854: LD_VAR 0 2
7858: RET
// export function LogHuman ( id ) ; begin
7859: LD_INT 0
7861: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7862: LD_STRING Human Created. id: 
7864: PUSH
7865: LD_VAR 0 1
7869: STR
7870: PUSH
7871: LD_STRING ; side: 
7873: STR
7874: PUSH
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 255
7884: STR
7885: PUSH
7886: LD_STRING ; class: 
7888: STR
7889: PUSH
7890: LD_VAR 0 1
7894: PPUSH
7895: CALL_OW 257
7899: STR
7900: PUSH
7901: LD_STRING ; 
7903: STR
7904: PPUSH
7905: CALL 7751 0 1
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogVeh ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7917: LD_STRING Vehicle Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; nation: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 248
7954: STR
7955: PUSH
7956: LD_STRING ; weapon: 
7958: STR
7959: PUSH
7960: LD_VAR 0 1
7964: PPUSH
7965: CALL_OW 264
7969: STR
7970: PUSH
7971: LD_STRING ; 
7973: STR
7974: PPUSH
7975: CALL 7751 0 1
// end ;
7979: LD_VAR 0 2
7983: RET
// export function LogEvent ( event ) ; begin
7984: LD_INT 0
7986: PPUSH
// Log ( Event Executed. id:  & event ) ;
7987: LD_STRING Event Executed. id: 
7989: PUSH
7990: LD_VAR 0 1
7994: STR
7995: PPUSH
7996: CALL 7751 0 1
// end ; end_of_file
8000: LD_VAR 0 2
8004: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8005: LD_INT 0
8007: PPUSH
8008: PPUSH
8009: PPUSH
8010: PPUSH
8011: PPUSH
8012: PPUSH
8013: PPUSH
8014: PPUSH
// if unit then
8015: LD_VAR 0 1
8019: IFFALSE 8419
// begin if mode = 0 then
8021: LD_VAR 0 3
8025: PUSH
8026: LD_INT 0
8028: EQUAL
8029: IFFALSE 8177
// begin if coords then
8031: LD_VAR 0 2
8035: IFFALSE 8175
// while ( coords > 1 ) do
8037: LD_VAR 0 2
8041: PUSH
8042: LD_INT 1
8044: GREATER
8045: IFFALSE 8175
// if not HasTask ( unit ) then
8047: LD_VAR 0 1
8051: PPUSH
8052: CALL_OW 314
8056: NOT
8057: IFFALSE 8173
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8059: LD_VAR 0 1
8063: PPUSH
8064: LD_VAR 0 2
8068: PUSH
8069: LD_INT 1
8071: ARRAY
8072: PPUSH
8073: LD_VAR 0 2
8077: PUSH
8078: LD_INT 2
8080: ARRAY
8081: PPUSH
8082: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8086: LD_INT 35
8088: PPUSH
8089: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8093: LD_VAR 0 1
8097: PPUSH
8098: CALL_OW 250
8102: PUSH
8103: LD_VAR 0 2
8107: PUSH
8108: LD_INT 1
8110: ARRAY
8111: EQUAL
8112: PUSH
8113: LD_VAR 0 1
8117: PPUSH
8118: CALL_OW 251
8122: PUSH
8123: LD_VAR 0 2
8127: PUSH
8128: LD_INT 2
8130: ARRAY
8131: EQUAL
8132: AND
8133: IFFALSE 8086
// for i = 1 to 2 do
8135: LD_ADDR_VAR 0 5
8139: PUSH
8140: DOUBLE
8141: LD_INT 1
8143: DEC
8144: ST_TO_ADDR
8145: LD_INT 2
8147: PUSH
8148: FOR_TO
8149: IFFALSE 8171
// coords := Delete ( coords , 1 ) ;
8151: LD_ADDR_VAR 0 2
8155: PUSH
8156: LD_VAR 0 2
8160: PPUSH
8161: LD_INT 1
8163: PPUSH
8164: CALL_OW 3
8168: ST_TO_ADDR
8169: GO 8148
8171: POP
8172: POP
// end ;
8173: GO 8037
// end else
8175: GO 8419
// begin if coords then
8177: LD_VAR 0 2
8181: IFFALSE 8419
// begin x := GetX ( unit ) ;
8183: LD_ADDR_VAR 0 6
8187: PUSH
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 250
8197: ST_TO_ADDR
// y := GetY ( unit ) ;
8198: LD_ADDR_VAR 0 7
8202: PUSH
8203: LD_VAR 0 1
8207: PPUSH
8208: CALL_OW 251
8212: ST_TO_ADDR
// while ( coords > 1 ) do
8213: LD_VAR 0 2
8217: PUSH
8218: LD_INT 1
8220: GREATER
8221: IFFALSE 8419
// begin Wait ( 0 0$0.3 ) ;
8223: LD_INT 10
8225: PPUSH
8226: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 255
8239: PPUSH
8240: LD_VAR 0 1
8244: PPUSH
8245: CALL_OW 250
8249: PPUSH
8250: LD_VAR 0 1
8254: PPUSH
8255: CALL_OW 251
8259: PPUSH
8260: LD_INT 14
8262: PPUSH
8263: CALL 22757 0 4
8267: IFFALSE 8298
// begin ComMoveXY ( unit , x , y ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: LD_VAR 0 6
8278: PPUSH
8279: LD_VAR 0 7
8283: PPUSH
8284: CALL_OW 111
// result := false ;
8288: LD_ADDR_VAR 0 4
8292: PUSH
8293: LD_INT 0
8295: ST_TO_ADDR
// end else
8296: GO 8337
// if not HasTask ( unit ) then
8298: LD_VAR 0 1
8302: PPUSH
8303: CALL_OW 314
8307: NOT
8308: IFFALSE 8337
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8310: LD_VAR 0 1
8314: PPUSH
8315: LD_VAR 0 2
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_VAR 0 2
8328: PUSH
8329: LD_INT 2
8331: ARRAY
8332: PPUSH
8333: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8337: LD_VAR 0 1
8341: PPUSH
8342: CALL_OW 250
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: EQUAL
8356: PUSH
8357: LD_VAR 0 1
8361: PPUSH
8362: CALL_OW 251
8366: PUSH
8367: LD_VAR 0 2
8371: PUSH
8372: LD_INT 2
8374: ARRAY
8375: EQUAL
8376: AND
8377: IFFALSE 8417
// for i = 1 to 2 do
8379: LD_ADDR_VAR 0 5
8383: PUSH
8384: DOUBLE
8385: LD_INT 1
8387: DEC
8388: ST_TO_ADDR
8389: LD_INT 2
8391: PUSH
8392: FOR_TO
8393: IFFALSE 8415
// coords := Delete ( coords , 1 ) ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 2
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 3
8412: ST_TO_ADDR
8413: GO 8392
8415: POP
8416: POP
// end ;
8417: GO 8213
// end ; end ; end ; result := true ;
8419: LD_ADDR_VAR 0 4
8423: PUSH
8424: LD_INT 1
8426: ST_TO_ADDR
// end ;
8427: LD_VAR 0 4
8431: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8432: LD_INT 0
8434: PPUSH
8435: PPUSH
8436: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8437: LD_ADDR_VAR 0 5
8441: PUSH
8442: LD_INT 81
8444: PUSH
8445: LD_VAR 0 1
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PPUSH
8454: CALL_OW 69
8458: ST_TO_ADDR
// for i in units do
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_VAR 0 2
8468: PUSH
8469: FOR_IN
8470: IFFALSE 8498
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8472: LD_VAR 0 4
8476: PPUSH
8477: LD_VAR 0 5
8481: PPUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL_OW 74
8491: PPUSH
8492: CALL_OW 115
// end ;
8496: GO 8469
8498: POP
8499: POP
// end ;
8500: LD_VAR 0 3
8504: RET
// export function MC_Show ( string ) ; begin
8505: LD_INT 0
8507: PPUSH
// display_strings := string ;
8508: LD_ADDR_OWVAR 47
8512: PUSH
8513: LD_VAR 0 1
8517: ST_TO_ADDR
// end ; end_of_file
8518: LD_VAR 0 2
8522: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8523: LD_INT 0
8525: PPUSH
8526: PPUSH
8527: PPUSH
8528: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8529: LD_ADDR_VAR 0 8
8533: PUSH
8534: LD_VAR 0 1
8538: PPUSH
8539: LD_INT 2
8541: PPUSH
8542: EMPTY
8543: PPUSH
8544: CALL 11670 0 3
8548: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8549: LD_VAR 0 8
8553: PUSH
8554: LD_VAR 0 2
8558: PPUSH
8559: LD_VAR 0 3
8563: PPUSH
8564: CALL_OW 428
8568: PUSH
8569: LD_INT 0
8571: EQUAL
8572: AND
8573: IFFALSE 8647
// for i = 1 to plist do
8575: LD_ADDR_VAR 0 6
8579: PUSH
8580: DOUBLE
8581: LD_INT 1
8583: DEC
8584: ST_TO_ADDR
8585: LD_VAR 0 8
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8645
// if NotTask ( plist [ i ] ) then
8593: LD_VAR 0 8
8597: PUSH
8598: LD_VAR 0 6
8602: ARRAY
8603: PPUSH
8604: CALL 32158 0 1
8608: IFFALSE 8643
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8610: LD_VAR 0 8
8614: PUSH
8615: LD_VAR 0 6
8619: ARRAY
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: LD_VAR 0 2
8628: PPUSH
8629: LD_VAR 0 3
8633: PPUSH
8634: LD_VAR 0 4
8638: PPUSH
8639: CALL_OW 145
// end ;
8643: GO 8590
8645: POP
8646: POP
// end ;
8647: LD_VAR 0 5
8651: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8652: LD_INT 0
8654: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 6
8662: PPUSH
8663: LD_VAR 0 2
8667: PPUSH
8668: LD_VAR 0 3
8672: PPUSH
8673: LD_VAR 0 4
8677: PPUSH
8678: CALL 10156 0 5
// end ;
8682: LD_VAR 0 5
8686: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8691: LD_ADDR_VAR 0 4
8695: PUSH
8696: LD_INT 22
8698: PUSH
8699: LD_VAR 0 1
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 30
8713: PUSH
8714: LD_INT 0
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: LD_INT 30
8723: PUSH
8724: LD_INT 1
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: EMPTY
8741: LIST
8742: PPUSH
8743: CALL_OW 69
8747: PPUSH
8748: LD_VAR 0 2
8752: PPUSH
8753: CALL_OW 250
8757: PPUSH
8758: LD_VAR 0 2
8762: PPUSH
8763: CALL_OW 251
8767: PPUSH
8768: CALL_OW 73
8772: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8773: LD_VAR 0 4
8777: PPUSH
8778: LD_VAR 0 2
8782: PPUSH
8783: CALL 10445 0 2
8787: IFFALSE 8846
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8789: LD_VAR 0 1
8793: PPUSH
8794: LD_INT 30
8796: PUSH
8797: LD_VAR 0 2
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: PPUSH
8806: CALL 11587 0 2
8810: PUSH
8811: LD_INT 1
8813: ARRAY
8814: PPUSH
8815: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8819: LD_ADDR_EXP 50
8823: PUSH
8824: LD_EXP 50
8828: PPUSH
8829: LD_VAR 0 1
8833: PPUSH
8834: LD_VAR 0 2
8838: PPUSH
8839: EMPTY
8840: PPUSH
8841: CALL 41973 0 4
8845: ST_TO_ADDR
// end ; end ;
8846: LD_VAR 0 3
8850: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8851: LD_INT 0
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// result := false ;
8859: LD_ADDR_VAR 0 4
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8867: LD_VAR 0 1
8871: PPUSH
8872: LD_EXP 42
8876: PPUSH
8877: CALL 42921 0 2
8881: IFFALSE 9094
// for i = 1 to MREG_LabList do
8883: LD_ADDR_VAR 0 5
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_EXP 42
8897: PUSH
8898: FOR_TO
8899: IFFALSE 9092
// begin if MREG_LabList [ i ] [ 1 ] = side then
8901: LD_EXP 42
8905: PUSH
8906: LD_VAR 0 5
8910: ARRAY
8911: PUSH
8912: LD_INT 1
8914: ARRAY
8915: PUSH
8916: LD_VAR 0 1
8920: EQUAL
8921: IFFALSE 9090
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8923: LD_ADDR_VAR 0 7
8927: PUSH
8928: LD_EXP 42
8932: PUSH
8933: LD_VAR 0 5
8937: ARRAY
8938: PUSH
8939: LD_INT 2
8941: ARRAY
8942: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8943: LD_ADDR_VAR 0 9
8947: PUSH
8948: LD_INT 22
8950: PUSH
8951: LD_VAR 0 1
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 2
8962: PUSH
8963: LD_INT 30
8965: PUSH
8966: LD_INT 0
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 30
8975: PUSH
8976: LD_INT 1
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: LIST
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: PUSH
8992: EMPTY
8993: LIST
8994: PPUSH
8995: CALL_OW 69
8999: PPUSH
9000: LD_VAR 0 7
9004: PPUSH
9005: CALL_OW 250
9009: PPUSH
9010: LD_VAR 0 7
9014: PPUSH
9015: CALL_OW 251
9019: PPUSH
9020: CALL_OW 73
9024: ST_TO_ADDR
// if dep then
9025: LD_VAR 0 9
9029: IFFALSE 9088
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9031: LD_VAR 0 9
9035: PPUSH
9036: LD_VAR 0 2
9040: PPUSH
9041: LD_VAR 0 3
9045: PPUSH
9046: CALL 10561 0 3
9050: IFFALSE 9088
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9052: LD_VAR 0 7
9056: PPUSH
9057: LD_VAR 0 2
9061: PPUSH
9062: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9066: LD_VAR 0 7
9070: PPUSH
9071: LD_VAR 0 3
9075: PPUSH
9076: CALL_OW 207
// result := true ;
9080: LD_ADDR_VAR 0 4
9084: PUSH
9085: LD_INT 1
9087: ST_TO_ADDR
// end ; end ; break ;
9088: GO 9092
// end ; end ;
9090: GO 8898
9092: POP
9093: POP
// end ;
9094: LD_VAR 0 4
9098: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9099: LD_INT 0
9101: PPUSH
9102: PPUSH
9103: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9104: LD_ADDR_VAR 0 7
9108: PUSH
9109: LD_VAR 0 2
9113: PPUSH
9114: LD_VAR 0 3
9118: PPUSH
9119: LD_VAR 0 4
9123: PPUSH
9124: CALL 9286 0 3
9128: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9129: LD_ADDR_EXP 48
9133: PUSH
9134: LD_EXP 48
9138: PPUSH
9139: LD_VAR 0 1
9143: PPUSH
9144: LD_INT 2
9146: PPUSH
9147: LD_VAR 0 2
9151: PUSH
9152: LD_VAR 0 3
9156: PUSH
9157: LD_VAR 0 4
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL 41882 0 4
9171: ST_TO_ADDR
// if ext_list then
9172: LD_VAR 0 5
9176: IFFALSE 9281
// for i = 1 to ext_list do
9178: LD_ADDR_VAR 0 8
9182: PUSH
9183: DOUBLE
9184: LD_INT 1
9186: DEC
9187: ST_TO_ADDR
9188: LD_VAR 0 5
9192: PUSH
9193: FOR_TO
9194: IFFALSE 9279
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9196: LD_ADDR_EXP 48
9200: PUSH
9201: LD_EXP 48
9205: PPUSH
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_VAR 0 5
9215: PUSH
9216: LD_VAR 0 8
9220: ARRAY
9221: PPUSH
9222: LD_VAR 0 7
9226: PUSH
9227: LD_VAR 0 8
9231: ARRAY
9232: PUSH
9233: LD_INT 1
9235: ARRAY
9236: PUSH
9237: LD_VAR 0 7
9241: PUSH
9242: LD_VAR 0 8
9246: ARRAY
9247: PUSH
9248: LD_INT 2
9250: ARRAY
9251: PUSH
9252: LD_VAR 0 7
9256: PUSH
9257: LD_VAR 0 8
9261: ARRAY
9262: PUSH
9263: LD_INT 3
9265: ARRAY
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: PPUSH
9272: CALL 41882 0 4
9276: ST_TO_ADDR
9277: GO 9193
9279: POP
9280: POP
// end ;
9281: LD_VAR 0 6
9285: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
// list := [ ] ;
9290: LD_ADDR_VAR 0 5
9294: PUSH
9295: EMPTY
9296: ST_TO_ADDR
// case d of 0 :
9297: LD_VAR 0 3
9301: PUSH
9302: LD_INT 0
9304: DOUBLE
9305: EQUAL
9306: IFTRUE 9310
9308: GO 9443
9310: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9311: LD_ADDR_VAR 0 5
9315: PUSH
9316: LD_VAR 0 1
9320: PUSH
9321: LD_INT 4
9323: MINUS
9324: PUSH
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 4
9332: MINUS
9333: PUSH
9334: LD_INT 2
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: LIST
9341: PUSH
9342: LD_VAR 0 1
9346: PUSH
9347: LD_INT 3
9349: MINUS
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: LD_INT 1
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 1
9368: PUSH
9369: LD_INT 4
9371: PLUS
9372: PUSH
9373: LD_VAR 0 2
9377: PUSH
9378: LD_INT 4
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: LD_VAR 0 1
9390: PUSH
9391: LD_INT 3
9393: PLUS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 3
9402: PLUS
9403: PUSH
9404: LD_INT 5
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: PUSH
9412: LD_VAR 0 1
9416: PUSH
9417: LD_VAR 0 2
9421: PUSH
9422: LD_INT 4
9424: PLUS
9425: PUSH
9426: LD_INT 0
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: LIST
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: ST_TO_ADDR
// end ; 1 :
9441: GO 10141
9443: LD_INT 1
9445: DOUBLE
9446: EQUAL
9447: IFTRUE 9451
9449: GO 9584
9451: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9452: LD_ADDR_VAR 0 5
9456: PUSH
9457: LD_VAR 0 1
9461: PUSH
9462: LD_VAR 0 2
9466: PUSH
9467: LD_INT 4
9469: MINUS
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: LIST
9478: PUSH
9479: LD_VAR 0 1
9483: PUSH
9484: LD_INT 3
9486: MINUS
9487: PUSH
9488: LD_VAR 0 2
9492: PUSH
9493: LD_INT 3
9495: MINUS
9496: PUSH
9497: LD_INT 2
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: PUSH
9505: LD_VAR 0 1
9509: PUSH
9510: LD_INT 4
9512: MINUS
9513: PUSH
9514: LD_VAR 0 2
9518: PUSH
9519: LD_INT 1
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: PUSH
9527: LD_VAR 0 1
9531: PUSH
9532: LD_VAR 0 2
9536: PUSH
9537: LD_INT 3
9539: PLUS
9540: PUSH
9541: LD_INT 0
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: PUSH
9549: LD_VAR 0 1
9553: PUSH
9554: LD_INT 4
9556: PLUS
9557: PUSH
9558: LD_VAR 0 2
9562: PUSH
9563: LD_INT 4
9565: PLUS
9566: PUSH
9567: LD_INT 5
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: ST_TO_ADDR
// end ; 2 :
9582: GO 10141
9584: LD_INT 2
9586: DOUBLE
9587: EQUAL
9588: IFTRUE 9592
9590: GO 9721
9592: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9593: LD_ADDR_VAR 0 5
9597: PUSH
9598: LD_VAR 0 1
9602: PUSH
9603: LD_VAR 0 2
9607: PUSH
9608: LD_INT 3
9610: MINUS
9611: PUSH
9612: LD_INT 3
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: PUSH
9620: LD_VAR 0 1
9624: PUSH
9625: LD_INT 4
9627: PLUS
9628: PUSH
9629: LD_VAR 0 2
9633: PUSH
9634: LD_INT 4
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: LIST
9641: PUSH
9642: LD_VAR 0 1
9646: PUSH
9647: LD_VAR 0 2
9651: PUSH
9652: LD_INT 4
9654: PLUS
9655: PUSH
9656: LD_INT 0
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_VAR 0 1
9668: PUSH
9669: LD_INT 3
9671: MINUS
9672: PUSH
9673: LD_VAR 0 2
9677: PUSH
9678: LD_INT 1
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: LIST
9685: PUSH
9686: LD_VAR 0 1
9690: PUSH
9691: LD_INT 4
9693: MINUS
9694: PUSH
9695: LD_VAR 0 2
9699: PUSH
9700: LD_INT 4
9702: MINUS
9703: PUSH
9704: LD_INT 2
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: LIST
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: ST_TO_ADDR
// end ; 3 :
9719: GO 10141
9721: LD_INT 3
9723: DOUBLE
9724: EQUAL
9725: IFTRUE 9729
9727: GO 9862
9729: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9730: LD_ADDR_VAR 0 5
9734: PUSH
9735: LD_VAR 0 1
9739: PUSH
9740: LD_INT 3
9742: PLUS
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: LD_INT 4
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: LIST
9756: PUSH
9757: LD_VAR 0 1
9761: PUSH
9762: LD_INT 4
9764: PLUS
9765: PUSH
9766: LD_VAR 0 2
9770: PUSH
9771: LD_INT 4
9773: PLUS
9774: PUSH
9775: LD_INT 5
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_VAR 0 1
9787: PUSH
9788: LD_INT 4
9790: MINUS
9791: PUSH
9792: LD_VAR 0 2
9796: PUSH
9797: LD_INT 1
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: LIST
9804: PUSH
9805: LD_VAR 0 1
9809: PUSH
9810: LD_VAR 0 2
9814: PUSH
9815: LD_INT 4
9817: MINUS
9818: PUSH
9819: LD_INT 3
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: LIST
9826: PUSH
9827: LD_VAR 0 1
9831: PUSH
9832: LD_INT 3
9834: MINUS
9835: PUSH
9836: LD_VAR 0 2
9840: PUSH
9841: LD_INT 3
9843: MINUS
9844: PUSH
9845: LD_INT 2
9847: PUSH
9848: EMPTY
9849: LIST
9850: LIST
9851: LIST
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: ST_TO_ADDR
// end ; 4 :
9860: GO 10141
9862: LD_INT 4
9864: DOUBLE
9865: EQUAL
9866: IFTRUE 9870
9868: GO 10003
9870: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9871: LD_ADDR_VAR 0 5
9875: PUSH
9876: LD_VAR 0 1
9880: PUSH
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 4
9888: PLUS
9889: PUSH
9890: LD_INT 0
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: PUSH
9898: LD_VAR 0 1
9902: PUSH
9903: LD_INT 3
9905: PLUS
9906: PUSH
9907: LD_VAR 0 2
9911: PUSH
9912: LD_INT 3
9914: PLUS
9915: PUSH
9916: LD_INT 5
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: LIST
9923: PUSH
9924: LD_VAR 0 1
9928: PUSH
9929: LD_INT 3
9931: PLUS
9932: PUSH
9933: LD_VAR 0 2
9937: PUSH
9938: LD_INT 4
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: PUSH
9946: LD_VAR 0 1
9950: PUSH
9951: LD_VAR 0 2
9955: PUSH
9956: LD_INT 3
9958: MINUS
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: LIST
9967: PUSH
9968: LD_VAR 0 1
9972: PUSH
9973: LD_INT 4
9975: MINUS
9976: PUSH
9977: LD_VAR 0 2
9981: PUSH
9982: LD_INT 4
9984: MINUS
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: ST_TO_ADDR
// end ; 5 :
10001: GO 10141
10003: LD_INT 5
10005: DOUBLE
10006: EQUAL
10007: IFTRUE 10011
10009: GO 10140
10011: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10012: LD_ADDR_VAR 0 5
10016: PUSH
10017: LD_VAR 0 1
10021: PUSH
10022: LD_INT 4
10024: MINUS
10025: PUSH
10026: LD_VAR 0 2
10030: PUSH
10031: LD_INT 1
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: LIST
10038: PUSH
10039: LD_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: LD_INT 4
10051: MINUS
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: PUSH
10061: LD_VAR 0 1
10065: PUSH
10066: LD_INT 4
10068: PLUS
10069: PUSH
10070: LD_VAR 0 2
10074: PUSH
10075: LD_INT 4
10077: PLUS
10078: PUSH
10079: LD_INT 5
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: LIST
10086: PUSH
10087: LD_VAR 0 1
10091: PUSH
10092: LD_INT 3
10094: PLUS
10095: PUSH
10096: LD_VAR 0 2
10100: PUSH
10101: LD_INT 4
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PUSH
10109: LD_VAR 0 1
10113: PUSH
10114: LD_VAR 0 2
10118: PUSH
10119: LD_INT 3
10121: PLUS
10122: PUSH
10123: LD_INT 0
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: ST_TO_ADDR
// end ; end ;
10138: GO 10141
10140: POP
// result := list ;
10141: LD_ADDR_VAR 0 4
10145: PUSH
10146: LD_VAR 0 5
10150: ST_TO_ADDR
// end ;
10151: LD_VAR 0 4
10155: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10156: LD_INT 0
10158: PPUSH
10159: PPUSH
10160: PPUSH
10161: PPUSH
10162: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10163: LD_ADDR_VAR 0 10
10167: PUSH
10168: LD_VAR 0 1
10172: PPUSH
10173: LD_INT 2
10175: PPUSH
10176: EMPTY
10177: PPUSH
10178: CALL 11670 0 3
10182: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10183: LD_ADDR_VAR 0 9
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_VAR 0 1
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 2
10202: PUSH
10203: LD_INT 30
10205: PUSH
10206: LD_INT 0
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: PUSH
10213: LD_INT 30
10215: PUSH
10216: LD_INT 1
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: PPUSH
10235: CALL_OW 69
10239: PPUSH
10240: LD_VAR 0 3
10244: PPUSH
10245: LD_VAR 0 4
10249: PPUSH
10250: CALL_OW 73
10254: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10255: LD_ADDR_VAR 0 8
10259: PUSH
10260: LD_VAR 0 9
10264: PPUSH
10265: LD_VAR 0 2
10269: PPUSH
10270: CALL 10445 0 2
10274: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10275: LD_VAR 0 10
10279: PUSH
10280: LD_VAR 0 8
10284: AND
10285: PUSH
10286: LD_VAR 0 9
10290: PPUSH
10291: LD_VAR 0 3
10295: PPUSH
10296: LD_VAR 0 4
10300: PPUSH
10301: CALL_OW 297
10305: PUSH
10306: LD_INT 26
10308: LESSEQUAL
10309: AND
10310: PUSH
10311: LD_VAR 0 3
10315: PPUSH
10316: LD_VAR 0 4
10320: PPUSH
10321: CALL_OW 428
10325: PUSH
10326: LD_INT 0
10328: EQUAL
10329: AND
10330: IFFALSE 10440
// for i = 1 to plist do
10332: LD_ADDR_VAR 0 7
10336: PUSH
10337: DOUBLE
10338: LD_INT 1
10340: DEC
10341: ST_TO_ADDR
10342: LD_VAR 0 10
10346: PUSH
10347: FOR_TO
10348: IFFALSE 10438
// if IsInUnit ( plist [ i ] ) then
10350: LD_VAR 0 10
10354: PUSH
10355: LD_VAR 0 7
10359: ARRAY
10360: PPUSH
10361: CALL_OW 310
10365: IFFALSE 10384
// ComExitBuilding ( plist [ i ] ) else
10367: LD_VAR 0 10
10371: PUSH
10372: LD_VAR 0 7
10376: ARRAY
10377: PPUSH
10378: CALL_OW 122
10382: GO 10436
// if NotTask ( plist [ i ] ) then
10384: LD_VAR 0 10
10388: PUSH
10389: LD_VAR 0 7
10393: ARRAY
10394: PPUSH
10395: CALL 32158 0 1
10399: IFFALSE 10436
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10401: LD_VAR 0 10
10405: PUSH
10406: LD_VAR 0 7
10410: ARRAY
10411: PPUSH
10412: LD_VAR 0 2
10416: PPUSH
10417: LD_VAR 0 3
10421: PPUSH
10422: LD_VAR 0 4
10426: PPUSH
10427: LD_VAR 0 5
10431: PPUSH
10432: CALL_OW 145
// end ;
10436: GO 10347
10438: POP
10439: POP
// end ;
10440: LD_VAR 0 6
10444: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10445: LD_INT 0
10447: PPUSH
10448: PPUSH
10449: PPUSH
// pom := GetBase ( bdepot ) ;
10450: LD_ADDR_VAR 0 4
10454: PUSH
10455: LD_VAR 0 1
10459: PPUSH
10460: CALL_OW 274
10464: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10465: LD_ADDR_VAR 0 5
10469: PUSH
10470: LD_VAR 0 2
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 248
10484: PPUSH
10485: CALL_OW 450
10489: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10490: LD_VAR 0 4
10494: PPUSH
10495: LD_INT 1
10497: PPUSH
10498: CALL_OW 275
10502: PUSH
10503: LD_VAR 0 5
10507: PUSH
10508: LD_INT 1
10510: ARRAY
10511: GREATEREQUAL
10512: PUSH
10513: LD_VAR 0 4
10517: PPUSH
10518: LD_INT 3
10520: PPUSH
10521: CALL_OW 275
10525: PUSH
10526: LD_VAR 0 5
10530: PUSH
10531: LD_INT 3
10533: ARRAY
10534: GREATEREQUAL
10535: AND
10536: IFFALSE 10548
// result := true else
10538: LD_ADDR_VAR 0 3
10542: PUSH
10543: LD_INT 1
10545: ST_TO_ADDR
10546: GO 10556
// result := false ;
10548: LD_ADDR_VAR 0 3
10552: PUSH
10553: LD_INT 0
10555: ST_TO_ADDR
// end ;
10556: LD_VAR 0 3
10560: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10561: LD_INT 0
10563: PPUSH
10564: PPUSH
10565: PPUSH
10566: PPUSH
10567: PPUSH
// pom := GetBase ( bdepot ) ;
10568: LD_ADDR_VAR 0 5
10572: PUSH
10573: LD_VAR 0 1
10577: PPUSH
10578: CALL_OW 274
10582: ST_TO_ADDR
// cost := [ ] ;
10583: LD_ADDR_VAR 0 8
10587: PUSH
10588: EMPTY
10589: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10590: LD_ADDR_VAR 0 6
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_VAR 0 1
10604: PPUSH
10605: CALL_OW 248
10609: PPUSH
10610: CALL_OW 450
10614: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10615: LD_ADDR_VAR 0 7
10619: PUSH
10620: LD_VAR 0 3
10624: PPUSH
10625: LD_VAR 0 1
10629: PPUSH
10630: CALL_OW 248
10634: PPUSH
10635: CALL_OW 450
10639: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10640: LD_ADDR_VAR 0 8
10644: PUSH
10645: LD_VAR 0 8
10649: PPUSH
10650: LD_INT 1
10652: PPUSH
10653: LD_VAR 0 6
10657: PUSH
10658: LD_INT 1
10660: ARRAY
10661: PUSH
10662: LD_VAR 0 7
10666: PUSH
10667: LD_INT 1
10669: ARRAY
10670: PLUS
10671: PPUSH
10672: CALL_OW 1
10676: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10677: LD_ADDR_VAR 0 8
10681: PUSH
10682: LD_VAR 0 8
10686: PPUSH
10687: LD_INT 2
10689: PPUSH
10690: LD_VAR 0 6
10694: PUSH
10695: LD_INT 2
10697: ARRAY
10698: PUSH
10699: LD_VAR 0 7
10703: PUSH
10704: LD_INT 2
10706: ARRAY
10707: PLUS
10708: PPUSH
10709: CALL_OW 1
10713: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10714: LD_ADDR_VAR 0 8
10718: PUSH
10719: LD_VAR 0 8
10723: PPUSH
10724: LD_INT 3
10726: PPUSH
10727: LD_VAR 0 6
10731: PUSH
10732: LD_INT 3
10734: ARRAY
10735: PUSH
10736: LD_VAR 0 7
10740: PUSH
10741: LD_INT 3
10743: ARRAY
10744: PLUS
10745: PPUSH
10746: CALL_OW 1
10750: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10751: LD_VAR 0 5
10755: PPUSH
10756: LD_INT 1
10758: PPUSH
10759: CALL_OW 275
10763: PUSH
10764: LD_VAR 0 8
10768: PUSH
10769: LD_INT 1
10771: ARRAY
10772: GREATEREQUAL
10773: PUSH
10774: LD_VAR 0 5
10778: PPUSH
10779: LD_INT 3
10781: PPUSH
10782: CALL_OW 275
10786: PUSH
10787: LD_VAR 0 8
10791: PUSH
10792: LD_INT 3
10794: ARRAY
10795: GREATEREQUAL
10796: AND
10797: IFFALSE 10809
// result := true else
10799: LD_ADDR_VAR 0 4
10803: PUSH
10804: LD_INT 1
10806: ST_TO_ADDR
10807: GO 10817
// result := false ;
10809: LD_ADDR_VAR 0 4
10813: PUSH
10814: LD_INT 0
10816: ST_TO_ADDR
// end ;
10817: LD_VAR 0 4
10821: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10822: LD_INT 0
10824: PPUSH
10825: PPUSH
10826: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10827: LD_ADDR_VAR 0 5
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: LD_INT 2
10839: PPUSH
10840: EMPTY
10841: PPUSH
10842: CALL 11670 0 3
10846: ST_TO_ADDR
// if unit and plist then
10847: LD_VAR 0 2
10851: PUSH
10852: LD_VAR 0 5
10856: AND
10857: IFFALSE 10918
// for i = 1 to plist do
10859: LD_ADDR_VAR 0 4
10863: PUSH
10864: DOUBLE
10865: LD_INT 1
10867: DEC
10868: ST_TO_ADDR
10869: LD_VAR 0 5
10873: PUSH
10874: FOR_TO
10875: IFFALSE 10916
// if NotTask ( plist [ i ] ) then
10877: LD_VAR 0 5
10881: PUSH
10882: LD_VAR 0 4
10886: ARRAY
10887: PPUSH
10888: CALL 32158 0 1
10892: IFFALSE 10914
// ComDismantle ( plist [ i ] , unit ) ;
10894: LD_VAR 0 5
10898: PUSH
10899: LD_VAR 0 4
10903: ARRAY
10904: PPUSH
10905: LD_VAR 0 2
10909: PPUSH
10910: CALL_OW 167
10914: GO 10874
10916: POP
10917: POP
// result := true ;
10918: LD_ADDR_VAR 0 3
10922: PUSH
10923: LD_INT 1
10925: ST_TO_ADDR
// end ;
10926: LD_VAR 0 3
10930: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10931: LD_INT 0
10933: PPUSH
10934: PPUSH
10935: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10936: LD_ADDR_VAR 0 5
10940: PUSH
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: EMPTY
10950: PPUSH
10951: CALL 11670 0 3
10955: ST_TO_ADDR
// if unit and plist then
10956: LD_VAR 0 2
10960: PUSH
10961: LD_VAR 0 5
10965: AND
10966: IFFALSE 11027
// for i = 1 to plist do
10968: LD_ADDR_VAR 0 4
10972: PUSH
10973: DOUBLE
10974: LD_INT 1
10976: DEC
10977: ST_TO_ADDR
10978: LD_VAR 0 5
10982: PUSH
10983: FOR_TO
10984: IFFALSE 11025
// if NotTask ( plist [ i ] ) then
10986: LD_VAR 0 5
10990: PUSH
10991: LD_VAR 0 4
10995: ARRAY
10996: PPUSH
10997: CALL 32158 0 1
11001: IFFALSE 11023
// ComComplete ( plist [ i ] , unit ) ;
11003: LD_VAR 0 5
11007: PUSH
11008: LD_VAR 0 4
11012: ARRAY
11013: PPUSH
11014: LD_VAR 0 2
11018: PPUSH
11019: CALL 68336 0 2
11023: GO 10983
11025: POP
11026: POP
// result := true ;
11027: LD_ADDR_VAR 0 3
11031: PUSH
11032: LD_INT 1
11034: ST_TO_ADDR
// end ;
11035: LD_VAR 0 3
11039: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11040: LD_INT 0
11042: PPUSH
11043: PPUSH
11044: PPUSH
11045: PPUSH
11046: PPUSH
11047: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11048: LD_ADDR_VAR 0 5
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_VAR 0 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 21
11067: PUSH
11068: LD_INT 3
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 3
11077: PUSH
11078: LD_INT 57
11080: PUSH
11081: EMPTY
11082: LIST
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 3
11090: PUSH
11091: LD_INT 24
11093: PUSH
11094: LD_INT 1000
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 69
11115: ST_TO_ADDR
// r := [ ] ;
11116: LD_ADDR_VAR 0 6
11120: PUSH
11121: EMPTY
11122: ST_TO_ADDR
// if not tmp then
11123: LD_VAR 0 5
11127: NOT
11128: IFFALSE 11134
// exit else
11130: GO 11322
11132: GO 11302
// begin r := [ tmp [ 1 ] ] ;
11134: LD_ADDR_VAR 0 6
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_INT 1
11146: ARRAY
11147: PUSH
11148: EMPTY
11149: LIST
11150: ST_TO_ADDR
// for i = 2 to tmp do
11151: LD_ADDR_VAR 0 3
11155: PUSH
11156: DOUBLE
11157: LD_INT 2
11159: DEC
11160: ST_TO_ADDR
11161: LD_VAR 0 5
11165: PUSH
11166: FOR_TO
11167: IFFALSE 11300
// begin m := false ;
11169: LD_ADDR_VAR 0 7
11173: PUSH
11174: LD_INT 0
11176: ST_TO_ADDR
// for j = 1 to r do
11177: LD_ADDR_VAR 0 4
11181: PUSH
11182: DOUBLE
11183: LD_INT 1
11185: DEC
11186: ST_TO_ADDR
11187: LD_VAR 0 6
11191: PUSH
11192: FOR_TO
11193: IFFALSE 11267
// if GetLives ( tmp [ i ] ) < r [ j ] then
11195: LD_VAR 0 5
11199: PUSH
11200: LD_VAR 0 3
11204: ARRAY
11205: PPUSH
11206: CALL_OW 256
11210: PUSH
11211: LD_VAR 0 6
11215: PUSH
11216: LD_VAR 0 4
11220: ARRAY
11221: LESS
11222: IFFALSE 11265
// begin r := Insert ( r , j , tmp [ i ] ) ;
11224: LD_ADDR_VAR 0 6
11228: PUSH
11229: LD_VAR 0 6
11233: PPUSH
11234: LD_VAR 0 4
11238: PPUSH
11239: LD_VAR 0 5
11243: PUSH
11244: LD_VAR 0 3
11248: ARRAY
11249: PPUSH
11250: CALL_OW 2
11254: ST_TO_ADDR
// m := true ;
11255: LD_ADDR_VAR 0 7
11259: PUSH
11260: LD_INT 1
11262: ST_TO_ADDR
// break ;
11263: GO 11267
// end ;
11265: GO 11192
11267: POP
11268: POP
// if not m then
11269: LD_VAR 0 7
11273: NOT
11274: IFFALSE 11298
// r := r ^ tmp [ i ] ;
11276: LD_ADDR_VAR 0 6
11280: PUSH
11281: LD_VAR 0 6
11285: PUSH
11286: LD_VAR 0 5
11290: PUSH
11291: LD_VAR 0 3
11295: ARRAY
11296: ADD
11297: ST_TO_ADDR
// end ;
11298: GO 11166
11300: POP
11301: POP
// end ; if r then
11302: LD_VAR 0 6
11306: IFFALSE 11320
// result := r else
11308: LD_ADDR_VAR 0 2
11312: PUSH
11313: LD_VAR 0 6
11317: ST_TO_ADDR
11318: GO 11322
// exit ;
11320: GO 11322
// end ;
11322: LD_VAR 0 2
11326: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11327: LD_INT 0
11329: PPUSH
11330: PPUSH
11331: PPUSH
11332: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11333: LD_ADDR_VAR 0 5
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 1
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 2
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 25
11365: PUSH
11366: LD_INT 16
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 34
11375: PUSH
11376: LD_INT 13
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: LD_INT 34
11385: PUSH
11386: LD_INT 52
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: PUSH
11400: LD_INT 24
11402: PUSH
11403: LD_INT 650
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: LIST
11414: PPUSH
11415: CALL_OW 69
11419: ST_TO_ADDR
// p := 1 ;
11420: LD_ADDR_VAR 0 4
11424: PUSH
11425: LD_INT 1
11427: ST_TO_ADDR
// for i = 1 to repairs do
11428: LD_ADDR_VAR 0 3
11432: PUSH
11433: DOUBLE
11434: LD_INT 1
11436: DEC
11437: ST_TO_ADDR
11438: LD_VAR 0 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11580
// begin if IsInUnit ( repairs [ i ] ) then
11446: LD_VAR 0 5
11450: PUSH
11451: LD_VAR 0 3
11455: ARRAY
11456: PPUSH
11457: CALL_OW 310
11461: IFFALSE 11480
// ComExitBuilding ( repairs [ i ] ) else
11463: LD_VAR 0 5
11467: PUSH
11468: LD_VAR 0 3
11472: ARRAY
11473: PPUSH
11474: CALL_OW 122
11478: GO 11578
// if not HasTask ( repairs [ i ] ) then
11480: LD_VAR 0 5
11484: PUSH
11485: LD_VAR 0 3
11489: ARRAY
11490: PPUSH
11491: CALL_OW 314
11495: NOT
11496: IFFALSE 11578
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11498: LD_VAR 0 5
11502: PUSH
11503: LD_VAR 0 3
11507: ARRAY
11508: PPUSH
11509: LD_EXP 49
11513: PUSH
11514: LD_VAR 0 1
11518: ARRAY
11519: PUSH
11520: LD_VAR 0 4
11524: ARRAY
11525: PPUSH
11526: CALL_OW 130
// if i mod 3 = 0 then
11530: LD_VAR 0 3
11534: PUSH
11535: LD_INT 3
11537: MOD
11538: PUSH
11539: LD_INT 0
11541: EQUAL
11542: IFFALSE 11558
// p := p + 1 ;
11544: LD_ADDR_VAR 0 4
11548: PUSH
11549: LD_VAR 0 4
11553: PUSH
11554: LD_INT 1
11556: PLUS
11557: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11558: LD_EXP 49
11562: PUSH
11563: LD_VAR 0 1
11567: ARRAY
11568: PUSH
11569: LD_VAR 0 4
11573: LESS
11574: IFFALSE 11578
// break ;
11576: GO 11580
// end ; end ;
11578: GO 11443
11580: POP
11581: POP
// end ; end_of_file
11582: LD_VAR 0 2
11586: RET
// export function MCF_Get ( side , filter ) ; begin
11587: LD_INT 0
11589: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_INT 22
11597: PUSH
11598: LD_VAR 0 1
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_VAR 0 2
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// end ;
11621: LD_VAR 0 3
11625: RET
// export function MCF_Lab ( side ) ; begin
11626: LD_INT 0
11628: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11629: LD_ADDR_VAR 0 2
11633: PUSH
11634: LD_INT 22
11636: PUSH
11637: LD_VAR 0 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: LD_INT 30
11648: PUSH
11649: LD_INT 8
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: EMPTY
11657: LIST
11658: LIST
11659: PPUSH
11660: CALL_OW 69
11664: ST_TO_ADDR
// end ;
11665: LD_VAR 0 2
11669: RET
// export function MCF_Class ( side , class , filter ) ; begin
11670: LD_INT 0
11672: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11673: LD_ADDR_VAR 0 4
11677: PUSH
11678: LD_INT 22
11680: PUSH
11681: LD_VAR 0 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 25
11692: PUSH
11693: LD_VAR 0 2
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_All ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 2
11744: PUSH
11745: LD_INT 25
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: LD_INT 25
11757: PUSH
11758: LD_INT 2
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 25
11767: PUSH
11768: LD_INT 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 4
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: PUSH
11792: LD_VAR 0 2
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: LIST
11801: PPUSH
11802: CALL_OW 69
11806: ST_TO_ADDR
// end ;
11807: LD_VAR 0 3
11811: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11812: LD_INT 0
11814: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11815: LD_ADDR_VAR 0 4
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_VAR 0 1
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: PUSH
11832: LD_INT 92
11834: PUSH
11835: LD_VAR 0 2
11839: PUSH
11840: LD_INT 1
11842: ARRAY
11843: PUSH
11844: LD_VAR 0 2
11848: PUSH
11849: LD_INT 2
11851: ARRAY
11852: PUSH
11853: LD_VAR 0 2
11857: PUSH
11858: LD_INT 3
11860: ARRAY
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: PUSH
11868: LD_VAR 0 3
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PPUSH
11878: CALL_OW 69
11882: ST_TO_ADDR
// end ;
11883: LD_VAR 0 4
11887: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11888: LD_INT 0
11890: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11891: LD_ADDR_VAR 0 3
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_VAR 0 1
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PUSH
11908: LD_INT 21
11910: PUSH
11911: LD_INT 2
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_VAR 0 2
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PPUSH
11928: CALL_OW 69
11932: ST_TO_ADDR
// end ;
11933: LD_VAR 0 3
11937: RET
// export function MCF_Cargo ( side ) ; begin
11938: LD_INT 0
11940: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11941: LD_ADDR_VAR 0 2
11945: PUSH
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_INT 2
11953: PUSH
11954: LD_INT 34
11956: PUSH
11957: LD_INT 12
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 34
11966: PUSH
11967: LD_INT 32
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: LD_INT 34
11976: PUSH
11977: LD_INT 51
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: PPUSH
11990: CALL 11888 0 2
11994: ST_TO_ADDR
// end ;
11995: LD_VAR 0 2
11999: RET
// export function MCF_Ape ( side ) ; begin
12000: LD_INT 0
12002: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12003: LD_ADDR_VAR 0 2
12007: PUSH
12008: LD_INT 22
12010: PUSH
12011: LD_VAR 0 1
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 2
12022: PUSH
12023: LD_INT 25
12025: PUSH
12026: LD_INT 12
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: LD_INT 25
12035: PUSH
12036: LD_INT 15
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: LD_INT 25
12045: PUSH
12046: LD_INT 16
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PUSH
12053: LD_INT 25
12055: PUSH
12056: LD_INT 17
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PPUSH
12074: CALL_OW 69
12078: ST_TO_ADDR
// end ;
12079: LD_VAR 0 2
12083: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12084: LD_INT 0
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
// result := [ ] ;
12090: LD_ADDR_VAR 0 3
12094: PUSH
12095: EMPTY
12096: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12097: LD_ADDR_VAR 0 4
12101: PUSH
12102: LD_VAR 0 1
12106: PPUSH
12107: CALL 12000 0 1
12111: ST_TO_ADDR
// case type of 0 , normal :
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 0
12119: DOUBLE
12120: EQUAL
12121: IFTRUE 12131
12123: LD_STRING normal
12125: DOUBLE
12126: EQUAL
12127: IFTRUE 12131
12129: GO 12142
12131: POP
// cl := class_apeman ; 1 , soldier :
12132: LD_ADDR_VAR 0 5
12136: PUSH
12137: LD_INT 12
12139: ST_TO_ADDR
12140: GO 12218
12142: LD_INT 1
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12156
12148: LD_STRING soldier
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12156
12154: GO 12167
12156: POP
// cl := class_apeman_soldier ; 2 , engineer :
12157: LD_ADDR_VAR 0 5
12161: PUSH
12162: LD_INT 15
12164: ST_TO_ADDR
12165: GO 12218
12167: LD_INT 2
12169: DOUBLE
12170: EQUAL
12171: IFTRUE 12181
12173: LD_STRING engineer
12175: DOUBLE
12176: EQUAL
12177: IFTRUE 12181
12179: GO 12192
12181: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12182: LD_ADDR_VAR 0 5
12186: PUSH
12187: LD_INT 16
12189: ST_TO_ADDR
12190: GO 12218
12192: LD_INT 3
12194: DOUBLE
12195: EQUAL
12196: IFTRUE 12206
12198: LD_STRING kamikaze
12200: DOUBLE
12201: EQUAL
12202: IFTRUE 12206
12204: GO 12217
12206: POP
// cl := class_apeman_kamikaze ; end ;
12207: LD_ADDR_VAR 0 5
12211: PUSH
12212: LD_INT 17
12214: ST_TO_ADDR
12215: GO 12218
12217: POP
// for i = 1 to tmp do
12218: LD_ADDR_VAR 0 6
12222: PUSH
12223: DOUBLE
12224: LD_INT 1
12226: DEC
12227: ST_TO_ADDR
12228: LD_VAR 0 4
12232: PUSH
12233: FOR_TO
12234: IFFALSE 12283
// if GetClass ( tmp [ i ] ) = cl then
12236: LD_VAR 0 4
12240: PUSH
12241: LD_VAR 0 6
12245: ARRAY
12246: PPUSH
12247: CALL_OW 257
12251: PUSH
12252: LD_VAR 0 5
12256: EQUAL
12257: IFFALSE 12281
// result := result ^ tmp [ i ] ;
12259: LD_ADDR_VAR 0 3
12263: PUSH
12264: LD_VAR 0 3
12268: PUSH
12269: LD_VAR 0 4
12273: PUSH
12274: LD_VAR 0 6
12278: ARRAY
12279: ADD
12280: ST_TO_ADDR
12281: GO 12233
12283: POP
12284: POP
// end ;
12285: LD_VAR 0 3
12289: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12290: LD_INT 0
12292: PPUSH
12293: PPUSH
12294: PPUSH
12295: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12296: LD_ADDR_VAR 0 5
12300: PUSH
12301: LD_INT 22
12303: PUSH
12304: LD_VAR 0 1
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: LD_VAR 0 3
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PPUSH
12322: CALL_OW 69
12326: ST_TO_ADDR
// r := [ ] ;
12327: LD_ADDR_VAR 0 6
12331: PUSH
12332: EMPTY
12333: ST_TO_ADDR
// if tmp then
12334: LD_VAR 0 5
12338: IFFALSE 12407
// for i = 1 to tmp do
12340: LD_ADDR_VAR 0 7
12344: PUSH
12345: DOUBLE
12346: LD_INT 1
12348: DEC
12349: ST_TO_ADDR
12350: LD_VAR 0 5
12354: PUSH
12355: FOR_TO
12356: IFFALSE 12405
// if GetTag ( tmp [ i ] ) = tag then
12358: LD_VAR 0 5
12362: PUSH
12363: LD_VAR 0 7
12367: ARRAY
12368: PPUSH
12369: CALL_OW 110
12373: PUSH
12374: LD_VAR 0 2
12378: EQUAL
12379: IFFALSE 12403
// r := r ^ tmp [ i ] ;
12381: LD_ADDR_VAR 0 6
12385: PUSH
12386: LD_VAR 0 6
12390: PUSH
12391: LD_VAR 0 5
12395: PUSH
12396: LD_VAR 0 7
12400: ARRAY
12401: ADD
12402: ST_TO_ADDR
12403: GO 12355
12405: POP
12406: POP
// result := r ;
12407: LD_ADDR_VAR 0 4
12411: PUSH
12412: LD_VAR 0 6
12416: ST_TO_ADDR
// end ;
12417: LD_VAR 0 4
12421: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12422: LD_INT 0
12424: PPUSH
12425: PPUSH
12426: PPUSH
// tmp := plist ;
12427: LD_ADDR_VAR 0 5
12431: PUSH
12432: LD_VAR 0 2
12436: ST_TO_ADDR
// if tmp then
12437: LD_VAR 0 5
12441: IFFALSE 12518
// begin for i = 1 to tmp do
12443: LD_ADDR_VAR 0 6
12447: PUSH
12448: DOUBLE
12449: LD_INT 1
12451: DEC
12452: ST_TO_ADDR
12453: LD_VAR 0 5
12457: PUSH
12458: FOR_TO
12459: IFFALSE 12506
// if GetTag ( tmp [ i ] ) <> tag then
12461: LD_VAR 0 5
12465: PUSH
12466: LD_VAR 0 6
12470: ARRAY
12471: PPUSH
12472: CALL_OW 110
12476: PUSH
12477: LD_VAR 0 3
12481: NONEQUAL
12482: IFFALSE 12504
// SetTag ( tmp [ i ] , tag ) ;
12484: LD_VAR 0 5
12488: PUSH
12489: LD_VAR 0 6
12493: ARRAY
12494: PPUSH
12495: LD_VAR 0 3
12499: PPUSH
12500: CALL_OW 109
12504: GO 12458
12506: POP
12507: POP
// result := true ;
12508: LD_ADDR_VAR 0 4
12512: PUSH
12513: LD_INT 1
12515: ST_TO_ADDR
// end else
12516: GO 12526
// result := false ;
12518: LD_ADDR_VAR 0 4
12522: PUSH
12523: LD_INT 0
12525: ST_TO_ADDR
// end ;
12526: LD_VAR 0 4
12530: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12536: LD_ADDR_VAR 0 4
12540: PUSH
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 2
12550: PPUSH
12551: EMPTY
12552: PPUSH
12553: CALL 12290 0 3
12557: ST_TO_ADDR
// if tmp then
12558: LD_VAR 0 4
12562: IFFALSE 12614
// begin for i = 1 to tmp do
12564: LD_ADDR_VAR 0 5
12568: PUSH
12569: DOUBLE
12570: LD_INT 1
12572: DEC
12573: ST_TO_ADDR
12574: LD_VAR 0 4
12578: PUSH
12579: FOR_TO
12580: IFFALSE 12602
// SetTag ( tmp [ i ] , 0 ) ;
12582: LD_VAR 0 4
12586: PUSH
12587: LD_VAR 0 5
12591: ARRAY
12592: PPUSH
12593: LD_INT 0
12595: PPUSH
12596: CALL_OW 109
12600: GO 12579
12602: POP
12603: POP
// result := true ;
12604: LD_ADDR_VAR 0 3
12608: PUSH
12609: LD_INT 1
12611: ST_TO_ADDR
// end else
12612: GO 12622
// result := false ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_INT 0
12621: ST_TO_ADDR
// end ;
12622: LD_VAR 0 3
12626: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12627: LD_INT 0
12629: PPUSH
12630: PPUSH
12631: PPUSH
12632: PPUSH
12633: PPUSH
// sort_list := [ ] ;
12634: LD_ADDR_VAR 0 5
12638: PUSH
12639: EMPTY
12640: ST_TO_ADDR
// for i = 1 to list do
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: DOUBLE
12647: LD_INT 1
12649: DEC
12650: ST_TO_ADDR
12651: LD_VAR 0 1
12655: PUSH
12656: FOR_TO
12657: IFFALSE 12819
// begin if i = 1 then
12659: LD_VAR 0 3
12663: PUSH
12664: LD_INT 1
12666: EQUAL
12667: IFFALSE 12693
// sort_list := sort_list ^ list [ i ] else
12669: LD_ADDR_VAR 0 5
12673: PUSH
12674: LD_VAR 0 5
12678: PUSH
12679: LD_VAR 0 1
12683: PUSH
12684: LD_VAR 0 3
12688: ARRAY
12689: ADD
12690: ST_TO_ADDR
12691: GO 12817
// begin for j = 1 to sort_list do
12693: LD_ADDR_VAR 0 4
12697: PUSH
12698: DOUBLE
12699: LD_INT 1
12701: DEC
12702: ST_TO_ADDR
12703: LD_VAR 0 5
12707: PUSH
12708: FOR_TO
12709: IFFALSE 12786
// begin add := false ;
12711: LD_ADDR_VAR 0 6
12715: PUSH
12716: LD_INT 0
12718: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12719: LD_VAR 0 1
12723: PUSH
12724: LD_VAR 0 3
12728: ARRAY
12729: PUSH
12730: LD_VAR 0 5
12734: PUSH
12735: LD_VAR 0 4
12739: ARRAY
12740: LESS
12741: IFFALSE 12784
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12743: LD_ADDR_VAR 0 5
12747: PUSH
12748: LD_VAR 0 5
12752: PPUSH
12753: LD_VAR 0 4
12757: PPUSH
12758: LD_VAR 0 1
12762: PUSH
12763: LD_VAR 0 3
12767: ARRAY
12768: PPUSH
12769: CALL_OW 2
12773: ST_TO_ADDR
// add := true ;
12774: LD_ADDR_VAR 0 6
12778: PUSH
12779: LD_INT 1
12781: ST_TO_ADDR
// break ;
12782: GO 12786
// end ; end ;
12784: GO 12708
12786: POP
12787: POP
// if not add then
12788: LD_VAR 0 6
12792: NOT
12793: IFFALSE 12817
// sort_list := sort_list ^ list [ i ] ;
12795: LD_ADDR_VAR 0 5
12799: PUSH
12800: LD_VAR 0 5
12804: PUSH
12805: LD_VAR 0 1
12809: PUSH
12810: LD_VAR 0 3
12814: ARRAY
12815: ADD
12816: ST_TO_ADDR
// end ; end ;
12817: GO 12656
12819: POP
12820: POP
// result := sort_list ;
12821: LD_ADDR_VAR 0 2
12825: PUSH
12826: LD_VAR 0 5
12830: ST_TO_ADDR
// end ;
12831: LD_VAR 0 2
12835: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
12840: PPUSH
12841: PPUSH
12842: PPUSH
// sort_list := [ ] ;
12843: LD_ADDR_VAR 0 5
12847: PUSH
12848: EMPTY
12849: ST_TO_ADDR
// for i = 1 to list do
12850: LD_ADDR_VAR 0 3
12854: PUSH
12855: DOUBLE
12856: LD_INT 1
12858: DEC
12859: ST_TO_ADDR
12860: LD_VAR 0 1
12864: PUSH
12865: FOR_TO
12866: IFFALSE 13028
// begin if i = 1 then
12868: LD_VAR 0 3
12872: PUSH
12873: LD_INT 1
12875: EQUAL
12876: IFFALSE 12902
// sort_list := sort_list ^ list [ i ] else
12878: LD_ADDR_VAR 0 5
12882: PUSH
12883: LD_VAR 0 5
12887: PUSH
12888: LD_VAR 0 1
12892: PUSH
12893: LD_VAR 0 3
12897: ARRAY
12898: ADD
12899: ST_TO_ADDR
12900: GO 13026
// begin for j = 1 to sort_list do
12902: LD_ADDR_VAR 0 4
12906: PUSH
12907: DOUBLE
12908: LD_INT 1
12910: DEC
12911: ST_TO_ADDR
12912: LD_VAR 0 5
12916: PUSH
12917: FOR_TO
12918: IFFALSE 12995
// begin add := false ;
12920: LD_ADDR_VAR 0 6
12924: PUSH
12925: LD_INT 0
12927: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12928: LD_VAR 0 1
12932: PUSH
12933: LD_VAR 0 3
12937: ARRAY
12938: PUSH
12939: LD_VAR 0 5
12943: PUSH
12944: LD_VAR 0 4
12948: ARRAY
12949: GREATER
12950: IFFALSE 12993
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12952: LD_ADDR_VAR 0 5
12956: PUSH
12957: LD_VAR 0 5
12961: PPUSH
12962: LD_VAR 0 4
12966: PPUSH
12967: LD_VAR 0 1
12971: PUSH
12972: LD_VAR 0 3
12976: ARRAY
12977: PPUSH
12978: CALL_OW 2
12982: ST_TO_ADDR
// add := true ;
12983: LD_ADDR_VAR 0 6
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// break ;
12991: GO 12995
// end ; end ;
12993: GO 12917
12995: POP
12996: POP
// if not add then
12997: LD_VAR 0 6
13001: NOT
13002: IFFALSE 13026
// sort_list := sort_list ^ list [ i ] ;
13004: LD_ADDR_VAR 0 5
13008: PUSH
13009: LD_VAR 0 5
13013: PUSH
13014: LD_VAR 0 1
13018: PUSH
13019: LD_VAR 0 3
13023: ARRAY
13024: ADD
13025: ST_TO_ADDR
// end ; end ;
13026: GO 12865
13028: POP
13029: POP
// result := sort_list ;
13030: LD_ADDR_VAR 0 2
13034: PUSH
13035: LD_VAR 0 5
13039: ST_TO_ADDR
// end ;
13040: LD_VAR 0 2
13044: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13045: LD_INT 0
13047: PPUSH
13048: PPUSH
13049: PPUSH
13050: PPUSH
13051: PPUSH
13052: PPUSH
// tmp := [ ] ;
13053: LD_ADDR_VAR 0 8
13057: PUSH
13058: EMPTY
13059: ST_TO_ADDR
// r := [ ] ;
13060: LD_ADDR_VAR 0 7
13064: PUSH
13065: EMPTY
13066: ST_TO_ADDR
// add := false ;
13067: LD_ADDR_VAR 0 9
13071: PUSH
13072: LD_INT 0
13074: ST_TO_ADDR
// if plist then
13075: LD_VAR 0 2
13079: IFFALSE 13155
// begin for i = 1 to plist do
13081: LD_ADDR_VAR 0 5
13085: PUSH
13086: DOUBLE
13087: LD_INT 1
13089: DEC
13090: ST_TO_ADDR
13091: LD_VAR 0 2
13095: PUSH
13096: FOR_TO
13097: IFFALSE 13151
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13099: LD_ADDR_VAR 0 8
13103: PUSH
13104: LD_VAR 0 8
13108: PUSH
13109: LD_VAR 0 2
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PUSH
13120: LD_VAR 0 2
13124: PUSH
13125: LD_VAR 0 5
13129: ARRAY
13130: PPUSH
13131: LD_VAR 0 3
13135: PPUSH
13136: CALL_OW 259
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: ADD
13148: ST_TO_ADDR
// end ;
13149: GO 13096
13151: POP
13152: POP
// end else
13153: GO 13163
// result := false ;
13155: LD_ADDR_VAR 0 4
13159: PUSH
13160: LD_INT 0
13162: ST_TO_ADDR
// if tmp then
13163: LD_VAR 0 8
13167: IFFALSE 13341
// begin r := r ^ [ tmp [ 1 ] ] ;
13169: LD_ADDR_VAR 0 7
13173: PUSH
13174: LD_VAR 0 7
13178: PUSH
13179: LD_VAR 0 8
13183: PUSH
13184: LD_INT 1
13186: ARRAY
13187: PUSH
13188: EMPTY
13189: LIST
13190: ADD
13191: ST_TO_ADDR
// for i = 2 to tmp do
13192: LD_ADDR_VAR 0 5
13196: PUSH
13197: DOUBLE
13198: LD_INT 2
13200: DEC
13201: ST_TO_ADDR
13202: LD_VAR 0 8
13206: PUSH
13207: FOR_TO
13208: IFFALSE 13339
// begin for j = 1 to r do
13210: LD_ADDR_VAR 0 6
13214: PUSH
13215: DOUBLE
13216: LD_INT 1
13218: DEC
13219: ST_TO_ADDR
13220: LD_VAR 0 7
13224: PUSH
13225: FOR_TO
13226: IFFALSE 13303
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13228: LD_VAR 0 8
13232: PUSH
13233: LD_VAR 0 5
13237: ARRAY
13238: PUSH
13239: LD_INT 2
13241: ARRAY
13242: PUSH
13243: LD_VAR 0 7
13247: PUSH
13248: LD_VAR 0 6
13252: ARRAY
13253: PUSH
13254: LD_INT 2
13256: ARRAY
13257: LESS
13258: IFFALSE 13301
// begin r := Insert ( r , j , tmp [ i ] ) ;
13260: LD_ADDR_VAR 0 7
13264: PUSH
13265: LD_VAR 0 7
13269: PPUSH
13270: LD_VAR 0 6
13274: PPUSH
13275: LD_VAR 0 8
13279: PUSH
13280: LD_VAR 0 5
13284: ARRAY
13285: PPUSH
13286: CALL_OW 2
13290: ST_TO_ADDR
// add := true ;
13291: LD_ADDR_VAR 0 9
13295: PUSH
13296: LD_INT 1
13298: ST_TO_ADDR
// break ;
13299: GO 13303
// end ; end ;
13301: GO 13225
13303: POP
13304: POP
// if not add then
13305: LD_VAR 0 9
13309: NOT
13310: IFFALSE 13337
// r := r ^ [ tmp [ i ] ] ;
13312: LD_ADDR_VAR 0 7
13316: PUSH
13317: LD_VAR 0 7
13321: PUSH
13322: LD_VAR 0 8
13326: PUSH
13327: LD_VAR 0 5
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// end ;
13337: GO 13207
13339: POP
13340: POP
// end ; result := r ;
13341: LD_ADDR_VAR 0 4
13345: PUSH
13346: LD_VAR 0 7
13350: ST_TO_ADDR
// end ;
13351: LD_VAR 0 4
13355: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13356: LD_INT 0
13358: PPUSH
13359: PPUSH
13360: PPUSH
13361: PPUSH
13362: PPUSH
13363: PPUSH
// tmp := [ ] ;
13364: LD_ADDR_VAR 0 8
13368: PUSH
13369: EMPTY
13370: ST_TO_ADDR
// r := [ ] ;
13371: LD_ADDR_VAR 0 7
13375: PUSH
13376: EMPTY
13377: ST_TO_ADDR
// add := false ;
13378: LD_ADDR_VAR 0 9
13382: PUSH
13383: LD_INT 0
13385: ST_TO_ADDR
// if plist then
13386: LD_VAR 0 2
13390: IFFALSE 13466
// begin for i = 1 to plist do
13392: LD_ADDR_VAR 0 5
13396: PUSH
13397: DOUBLE
13398: LD_INT 1
13400: DEC
13401: ST_TO_ADDR
13402: LD_VAR 0 2
13406: PUSH
13407: FOR_TO
13408: IFFALSE 13462
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13410: LD_ADDR_VAR 0 8
13414: PUSH
13415: LD_VAR 0 8
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PUSH
13431: LD_VAR 0 2
13435: PUSH
13436: LD_VAR 0 5
13440: ARRAY
13441: PPUSH
13442: LD_VAR 0 3
13446: PPUSH
13447: CALL_OW 259
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: EMPTY
13457: LIST
13458: ADD
13459: ST_TO_ADDR
// end ;
13460: GO 13407
13462: POP
13463: POP
// end else
13464: GO 13474
// result := false ;
13466: LD_ADDR_VAR 0 4
13470: PUSH
13471: LD_INT 0
13473: ST_TO_ADDR
// if tmp then
13474: LD_VAR 0 8
13478: IFFALSE 13652
// begin r := r ^ [ tmp [ 1 ] ] ;
13480: LD_ADDR_VAR 0 7
13484: PUSH
13485: LD_VAR 0 7
13489: PUSH
13490: LD_VAR 0 8
13494: PUSH
13495: LD_INT 1
13497: ARRAY
13498: PUSH
13499: EMPTY
13500: LIST
13501: ADD
13502: ST_TO_ADDR
// for i = 2 to tmp do
13503: LD_ADDR_VAR 0 5
13507: PUSH
13508: DOUBLE
13509: LD_INT 2
13511: DEC
13512: ST_TO_ADDR
13513: LD_VAR 0 8
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13650
// begin for j = 1 to r do
13521: LD_ADDR_VAR 0 6
13525: PUSH
13526: DOUBLE
13527: LD_INT 1
13529: DEC
13530: ST_TO_ADDR
13531: LD_VAR 0 7
13535: PUSH
13536: FOR_TO
13537: IFFALSE 13614
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13539: LD_VAR 0 8
13543: PUSH
13544: LD_VAR 0 5
13548: ARRAY
13549: PUSH
13550: LD_INT 2
13552: ARRAY
13553: PUSH
13554: LD_VAR 0 7
13558: PUSH
13559: LD_VAR 0 6
13563: ARRAY
13564: PUSH
13565: LD_INT 2
13567: ARRAY
13568: GREATER
13569: IFFALSE 13612
// begin r := Insert ( r , j , tmp [ i ] ) ;
13571: LD_ADDR_VAR 0 7
13575: PUSH
13576: LD_VAR 0 7
13580: PPUSH
13581: LD_VAR 0 6
13585: PPUSH
13586: LD_VAR 0 8
13590: PUSH
13591: LD_VAR 0 5
13595: ARRAY
13596: PPUSH
13597: CALL_OW 2
13601: ST_TO_ADDR
// add := true ;
13602: LD_ADDR_VAR 0 9
13606: PUSH
13607: LD_INT 1
13609: ST_TO_ADDR
// break ;
13610: GO 13614
// end ; end ;
13612: GO 13536
13614: POP
13615: POP
// if not add then
13616: LD_VAR 0 9
13620: NOT
13621: IFFALSE 13648
// r := r ^ [ tmp [ i ] ] ;
13623: LD_ADDR_VAR 0 7
13627: PUSH
13628: LD_VAR 0 7
13632: PUSH
13633: LD_VAR 0 8
13637: PUSH
13638: LD_VAR 0 5
13642: ARRAY
13643: PUSH
13644: EMPTY
13645: LIST
13646: ADD
13647: ST_TO_ADDR
// end ;
13648: GO 13518
13650: POP
13651: POP
// end ; result := r ;
13652: LD_ADDR_VAR 0 4
13656: PUSH
13657: LD_VAR 0 7
13661: ST_TO_ADDR
// end ;
13662: LD_VAR 0 4
13666: RET
// export function MCF_Clear ( side ) ; var i ; begin
13667: LD_INT 0
13669: PPUSH
13670: PPUSH
// for i = 1 to 100 do
13671: LD_ADDR_VAR 0 3
13675: PUSH
13676: DOUBLE
13677: LD_INT 1
13679: DEC
13680: ST_TO_ADDR
13681: LD_INT 100
13683: PUSH
13684: FOR_TO
13685: IFFALSE 13721
// if MCF_Tag ( side , i , [ ] ) then
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_VAR 0 3
13696: PPUSH
13697: EMPTY
13698: PPUSH
13699: CALL 12290 0 3
13703: IFFALSE 13719
// MCF_ClearTag ( side , i ) ;
13705: LD_VAR 0 1
13709: PPUSH
13710: LD_VAR 0 3
13714: PPUSH
13715: CALL 12531 0 2
13719: GO 13684
13721: POP
13722: POP
// result := true ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_INT 1
13730: ST_TO_ADDR
// end ;
13731: LD_VAR 0 2
13735: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
13740: PPUSH
// for i = 1 to plist do
13741: LD_ADDR_VAR 0 4
13745: PUSH
13746: DOUBLE
13747: LD_INT 1
13749: DEC
13750: ST_TO_ADDR
13751: LD_VAR 0 1
13755: PUSH
13756: FOR_TO
13757: IFFALSE 13806
// if MCF_HasClass ( plist [ i ] ) = n then
13759: LD_VAR 0 1
13763: PUSH
13764: LD_VAR 0 4
13768: ARRAY
13769: PPUSH
13770: CALL 14293 0 1
13774: PUSH
13775: LD_VAR 0 2
13779: EQUAL
13780: IFFALSE 13804
// tmp := tmp ^ plist [ i ] ;
13782: LD_ADDR_VAR 0 5
13786: PUSH
13787: LD_VAR 0 5
13791: PUSH
13792: LD_VAR 0 1
13796: PUSH
13797: LD_VAR 0 4
13801: ARRAY
13802: ADD
13803: ST_TO_ADDR
13804: GO 13756
13806: POP
13807: POP
// result := tmp ;
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_VAR 0 5
13817: ST_TO_ADDR
// end ;
13818: LD_VAR 0 3
13822: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13823: LD_INT 0
13825: PPUSH
13826: PPUSH
13827: PPUSH
// if mreg = ToArm then
13828: LD_VAR 0 2
13832: PUSH
13833: LD_STRING ToArm
13835: EQUAL
13836: IFFALSE 13941
// begin tmp := MREG_ToArm [ side ] ;
13838: LD_ADDR_VAR 0 6
13842: PUSH
13843: LD_EXP 58
13847: PUSH
13848: LD_VAR 0 1
13852: ARRAY
13853: ST_TO_ADDR
// if tmp = 0 then
13854: LD_VAR 0 6
13858: PUSH
13859: LD_INT 0
13861: EQUAL
13862: IFFALSE 13868
// exit else
13864: GO 14288
13866: GO 13941
// begin for i = MREG_ToArm [ side ] downto n do
13868: LD_ADDR_VAR 0 5
13872: PUSH
13873: DOUBLE
13874: LD_EXP 58
13878: PUSH
13879: LD_VAR 0 1
13883: ARRAY
13884: INC
13885: ST_TO_ADDR
13886: LD_VAR 0 3
13890: PUSH
13891: FOR_DOWNTO
13892: IFFALSE 13914
// tmp := Delete ( tmp , 1 ) ;
13894: LD_ADDR_VAR 0 6
13898: PUSH
13899: LD_VAR 0 6
13903: PPUSH
13904: LD_INT 1
13906: PPUSH
13907: CALL_OW 3
13911: ST_TO_ADDR
13912: GO 13891
13914: POP
13915: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13916: LD_ADDR_EXP 58
13920: PUSH
13921: LD_EXP 58
13925: PPUSH
13926: LD_VAR 0 1
13930: PPUSH
13931: LD_VAR 0 6
13935: PPUSH
13936: CALL_OW 1
13940: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13941: LD_VAR 0 2
13945: PUSH
13946: LD_STRING ToDep
13948: EQUAL
13949: IFFALSE 14054
// begin tmp := MREG_ToDep [ side ] ;
13951: LD_ADDR_VAR 0 6
13955: PUSH
13956: LD_EXP 59
13960: PUSH
13961: LD_VAR 0 1
13965: ARRAY
13966: ST_TO_ADDR
// if tmp = 0 then
13967: LD_VAR 0 6
13971: PUSH
13972: LD_INT 0
13974: EQUAL
13975: IFFALSE 13981
// exit else
13977: GO 14288
13979: GO 14054
// begin for i = MREG_ToDep [ side ] downto n do
13981: LD_ADDR_VAR 0 5
13985: PUSH
13986: DOUBLE
13987: LD_EXP 59
13991: PUSH
13992: LD_VAR 0 1
13996: ARRAY
13997: INC
13998: ST_TO_ADDR
13999: LD_VAR 0 3
14003: PUSH
14004: FOR_DOWNTO
14005: IFFALSE 14027
// tmp := Delete ( tmp , 1 ) ;
14007: LD_ADDR_VAR 0 6
14011: PUSH
14012: LD_VAR 0 6
14016: PPUSH
14017: LD_INT 1
14019: PPUSH
14020: CALL_OW 3
14024: ST_TO_ADDR
14025: GO 14004
14027: POP
14028: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14029: LD_ADDR_EXP 59
14033: PUSH
14034: LD_EXP 59
14038: PPUSH
14039: LD_VAR 0 1
14043: PPUSH
14044: LD_VAR 0 6
14048: PPUSH
14049: CALL_OW 1
14053: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14054: LD_VAR 0 2
14058: PUSH
14059: LD_STRING ToFac
14061: EQUAL
14062: IFFALSE 14167
// begin tmp := MREG_ToFac [ side ] ;
14064: LD_ADDR_VAR 0 6
14068: PUSH
14069: LD_EXP 57
14073: PUSH
14074: LD_VAR 0 1
14078: ARRAY
14079: ST_TO_ADDR
// if tmp = 0 then
14080: LD_VAR 0 6
14084: PUSH
14085: LD_INT 0
14087: EQUAL
14088: IFFALSE 14094
// exit else
14090: GO 14288
14092: GO 14167
// begin for i = MREG_ToFac [ side ] downto n do
14094: LD_ADDR_VAR 0 5
14098: PUSH
14099: DOUBLE
14100: LD_EXP 57
14104: PUSH
14105: LD_VAR 0 1
14109: ARRAY
14110: INC
14111: ST_TO_ADDR
14112: LD_VAR 0 3
14116: PUSH
14117: FOR_DOWNTO
14118: IFFALSE 14140
// tmp := Delete ( tmp , 1 ) ;
14120: LD_ADDR_VAR 0 6
14124: PUSH
14125: LD_VAR 0 6
14129: PPUSH
14130: LD_INT 1
14132: PPUSH
14133: CALL_OW 3
14137: ST_TO_ADDR
14138: GO 14117
14140: POP
14141: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14142: LD_ADDR_EXP 57
14146: PUSH
14147: LD_EXP 57
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: LD_VAR 0 6
14161: PPUSH
14162: CALL_OW 1
14166: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14167: LD_VAR 0 2
14171: PUSH
14172: LD_STRING ToLab
14174: EQUAL
14175: IFFALSE 14280
// begin tmp := MREG_ToLab [ side ] ;
14177: LD_ADDR_VAR 0 6
14181: PUSH
14182: LD_EXP 56
14186: PUSH
14187: LD_VAR 0 1
14191: ARRAY
14192: ST_TO_ADDR
// if tmp = 0 then
14193: LD_VAR 0 6
14197: PUSH
14198: LD_INT 0
14200: EQUAL
14201: IFFALSE 14207
// exit else
14203: GO 14288
14205: GO 14280
// begin for i = MREG_ToLab [ side ] downto n do
14207: LD_ADDR_VAR 0 5
14211: PUSH
14212: DOUBLE
14213: LD_EXP 56
14217: PUSH
14218: LD_VAR 0 1
14222: ARRAY
14223: INC
14224: ST_TO_ADDR
14225: LD_VAR 0 3
14229: PUSH
14230: FOR_DOWNTO
14231: IFFALSE 14253
// tmp := Delete ( tmp , 1 ) ;
14233: LD_ADDR_VAR 0 6
14237: PUSH
14238: LD_VAR 0 6
14242: PPUSH
14243: LD_INT 1
14245: PPUSH
14246: CALL_OW 3
14250: ST_TO_ADDR
14251: GO 14230
14253: POP
14254: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14255: LD_ADDR_EXP 56
14259: PUSH
14260: LD_EXP 56
14264: PPUSH
14265: LD_VAR 0 1
14269: PPUSH
14270: LD_VAR 0 6
14274: PPUSH
14275: CALL_OW 1
14279: ST_TO_ADDR
// end ; end ; result := true ;
14280: LD_ADDR_VAR 0 4
14284: PUSH
14285: LD_INT 1
14287: ST_TO_ADDR
// end ;
14288: LD_VAR 0 4
14292: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14293: LD_INT 0
14295: PPUSH
14296: PPUSH
14297: PPUSH
// side := GetSide ( unit ) ;
14298: LD_ADDR_VAR 0 4
14302: PUSH
14303: LD_VAR 0 1
14307: PPUSH
14308: CALL_OW 255
14312: ST_TO_ADDR
// tmp := 0 ;
14313: LD_ADDR_VAR 0 3
14317: PUSH
14318: LD_INT 0
14320: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14321: LD_VAR 0 1
14325: PUSH
14326: LD_EXP 58
14330: PUSH
14331: LD_VAR 0 4
14335: ARRAY
14336: IN
14337: IFFALSE 14347
// tmp := 1 ;
14339: LD_ADDR_VAR 0 3
14343: PUSH
14344: LD_INT 1
14346: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14347: LD_VAR 0 1
14351: PUSH
14352: LD_EXP 59
14356: PUSH
14357: LD_VAR 0 4
14361: ARRAY
14362: IN
14363: IFFALSE 14373
// tmp := 2 ;
14365: LD_ADDR_VAR 0 3
14369: PUSH
14370: LD_INT 2
14372: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14373: LD_VAR 0 1
14377: PUSH
14378: LD_EXP 57
14382: PUSH
14383: LD_VAR 0 4
14387: ARRAY
14388: IN
14389: IFFALSE 14399
// tmp := 3 ;
14391: LD_ADDR_VAR 0 3
14395: PUSH
14396: LD_INT 3
14398: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 56
14408: PUSH
14409: LD_VAR 0 4
14413: ARRAY
14414: IN
14415: IFFALSE 14425
// tmp := 4 ;
14417: LD_ADDR_VAR 0 3
14421: PUSH
14422: LD_INT 4
14424: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14425: LD_VAR 0 1
14429: PUSH
14430: LD_EXP 70
14434: PUSH
14435: LD_VAR 0 4
14439: ARRAY
14440: IN
14441: IFFALSE 14451
// tmp := 5 ;
14443: LD_ADDR_VAR 0 3
14447: PUSH
14448: LD_INT 5
14450: ST_TO_ADDR
// result := tmp ;
14451: LD_ADDR_VAR 0 2
14455: PUSH
14456: LD_VAR 0 3
14460: ST_TO_ADDR
// end ;
14461: LD_VAR 0 2
14465: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14466: LD_INT 0
14468: PPUSH
14469: PPUSH
// if mreg = ToArm then
14470: LD_VAR 0 2
14474: PUSH
14475: LD_STRING ToArm
14477: EQUAL
14478: IFFALSE 14567
// for i = MREG_ToArm [ side ] downto 1 do
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: DOUBLE
14486: LD_EXP 58
14490: PUSH
14491: LD_VAR 0 1
14495: ARRAY
14496: INC
14497: ST_TO_ADDR
14498: LD_INT 1
14500: PUSH
14501: FOR_DOWNTO
14502: IFFALSE 14565
// if MREG_ToArm [ side ] [ i ] = unit then
14504: LD_EXP 58
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 5
14519: ARRAY
14520: PUSH
14521: LD_VAR 0 3
14525: EQUAL
14526: IFFALSE 14563
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14528: LD_ADDR_EXP 58
14532: PUSH
14533: LD_EXP 58
14537: PPUSH
14538: LD_EXP 58
14542: PUSH
14543: LD_VAR 0 1
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 5
14553: ARRAY
14554: PPUSH
14555: LD_INT 1
14557: PPUSH
14558: CALL 31211 0 3
14562: ST_TO_ADDR
// end ;
14563: GO 14501
14565: POP
14566: POP
// if mreg = ToDep then
14567: LD_VAR 0 2
14571: PUSH
14572: LD_STRING ToDep
14574: EQUAL
14575: IFFALSE 14664
// for i = MREG_ToDep [ side ] downto 1 do
14577: LD_ADDR_VAR 0 5
14581: PUSH
14582: DOUBLE
14583: LD_EXP 59
14587: PUSH
14588: LD_VAR 0 1
14592: ARRAY
14593: INC
14594: ST_TO_ADDR
14595: LD_INT 1
14597: PUSH
14598: FOR_DOWNTO
14599: IFFALSE 14662
// if MREG_ToDep [ side ] [ i ] = unit then
14601: LD_EXP 59
14605: PUSH
14606: LD_VAR 0 1
14610: ARRAY
14611: PUSH
14612: LD_VAR 0 5
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 3
14622: EQUAL
14623: IFFALSE 14660
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14625: LD_ADDR_EXP 59
14629: PUSH
14630: LD_EXP 59
14634: PPUSH
14635: LD_EXP 59
14639: PUSH
14640: LD_VAR 0 1
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 5
14650: ARRAY
14651: PPUSH
14652: LD_INT 1
14654: PPUSH
14655: CALL 31211 0 3
14659: ST_TO_ADDR
// end ;
14660: GO 14598
14662: POP
14663: POP
// if mreg = ToFac then
14664: LD_VAR 0 2
14668: PUSH
14669: LD_STRING ToFac
14671: EQUAL
14672: IFFALSE 14761
// for i = MREG_ToFac [ side ] downto 1 do
14674: LD_ADDR_VAR 0 5
14678: PUSH
14679: DOUBLE
14680: LD_EXP 57
14684: PUSH
14685: LD_VAR 0 1
14689: ARRAY
14690: INC
14691: ST_TO_ADDR
14692: LD_INT 1
14694: PUSH
14695: FOR_DOWNTO
14696: IFFALSE 14759
// if MREG_ToFac [ side ] [ i ] = unit then
14698: LD_EXP 57
14702: PUSH
14703: LD_VAR 0 1
14707: ARRAY
14708: PUSH
14709: LD_VAR 0 5
14713: ARRAY
14714: PUSH
14715: LD_VAR 0 3
14719: EQUAL
14720: IFFALSE 14757
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14722: LD_ADDR_EXP 57
14726: PUSH
14727: LD_EXP 57
14731: PPUSH
14732: LD_EXP 57
14736: PUSH
14737: LD_VAR 0 1
14741: ARRAY
14742: PUSH
14743: LD_VAR 0 5
14747: ARRAY
14748: PPUSH
14749: LD_INT 1
14751: PPUSH
14752: CALL 31211 0 3
14756: ST_TO_ADDR
// end ;
14757: GO 14695
14759: POP
14760: POP
// if mreg = ToLab then
14761: LD_VAR 0 2
14765: PUSH
14766: LD_STRING ToLab
14768: EQUAL
14769: IFFALSE 14858
// for i = MREG_ToLab [ side ] downto 1 do
14771: LD_ADDR_VAR 0 5
14775: PUSH
14776: DOUBLE
14777: LD_EXP 56
14781: PUSH
14782: LD_VAR 0 1
14786: ARRAY
14787: INC
14788: ST_TO_ADDR
14789: LD_INT 1
14791: PUSH
14792: FOR_DOWNTO
14793: IFFALSE 14856
// if MREG_ToLab [ side ] [ i ] = unit then
14795: LD_EXP 56
14799: PUSH
14800: LD_VAR 0 1
14804: ARRAY
14805: PUSH
14806: LD_VAR 0 5
14810: ARRAY
14811: PUSH
14812: LD_VAR 0 3
14816: EQUAL
14817: IFFALSE 14854
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14819: LD_ADDR_EXP 56
14823: PUSH
14824: LD_EXP 56
14828: PPUSH
14829: LD_EXP 56
14833: PUSH
14834: LD_VAR 0 1
14838: ARRAY
14839: PUSH
14840: LD_VAR 0 5
14844: ARRAY
14845: PPUSH
14846: LD_INT 1
14848: PPUSH
14849: CALL 31211 0 3
14853: ST_TO_ADDR
// end ;
14854: GO 14792
14856: POP
14857: POP
// end ;
14858: LD_VAR 0 4
14862: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14863: LD_INT 0
14865: PPUSH
14866: PPUSH
// result := false ;
14867: LD_ADDR_VAR 0 2
14871: PUSH
14872: LD_INT 0
14874: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14875: LD_ADDR_VAR 0 3
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_EXP 48
14889: PUSH
14890: FOR_TO
14891: IFFALSE 14955
// if MREG_ToBuild [ i ] [ 1 ] = side then
14893: LD_EXP 48
14897: PUSH
14898: LD_VAR 0 3
14902: ARRAY
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 1
14912: EQUAL
14913: IFFALSE 14953
// begin if MREG_ToBuild [ i ] [ 1 ] then
14915: LD_EXP 48
14919: PUSH
14920: LD_VAR 0 3
14924: ARRAY
14925: PUSH
14926: LD_INT 1
14928: ARRAY
14929: IFFALSE 14953
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_EXP 48
14940: PUSH
14941: LD_VAR 0 3
14945: ARRAY
14946: PUSH
14947: LD_INT 1
14949: ARRAY
14950: ST_TO_ADDR
// break ;
14951: GO 14955
// end ; end ;
14953: GO 14890
14955: POP
14956: POP
// for i = 1 to MREG_ToRepair do
14957: LD_ADDR_VAR 0 3
14961: PUSH
14962: DOUBLE
14963: LD_INT 1
14965: DEC
14966: ST_TO_ADDR
14967: LD_EXP 49
14971: PUSH
14972: FOR_TO
14973: IFFALSE 15037
// if MREG_ToRepair [ i ] [ 1 ] = side then
14975: LD_EXP 49
14979: PUSH
14980: LD_VAR 0 3
14984: ARRAY
14985: PUSH
14986: LD_INT 1
14988: ARRAY
14989: PUSH
14990: LD_VAR 0 1
14994: EQUAL
14995: IFFALSE 15035
// begin if MREG_ToRepair [ i ] [ 1 ] then
14997: LD_EXP 49
15001: PUSH
15002: LD_VAR 0 3
15006: ARRAY
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: IFFALSE 15035
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15013: LD_ADDR_VAR 0 2
15017: PUSH
15018: LD_EXP 49
15022: PUSH
15023: LD_VAR 0 3
15027: ARRAY
15028: PUSH
15029: LD_INT 1
15031: ARRAY
15032: ST_TO_ADDR
// break ;
15033: GO 15037
// end ; end ;
15035: GO 14972
15037: POP
15038: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_INT 57
15046: PUSH
15047: EMPTY
15048: LIST
15049: PPUSH
15050: CALL 11587 0 2
15054: IFFALSE 15081
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15056: LD_ADDR_VAR 0 2
15060: PUSH
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 57
15068: PUSH
15069: EMPTY
15070: LIST
15071: PPUSH
15072: CALL 11587 0 2
15076: PUSH
15077: LD_INT 1
15079: ARRAY
15080: ST_TO_ADDR
// end ;
15081: LD_VAR 0 2
15085: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15086: LD_INT 0
15088: PPUSH
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15093: LD_ADDR_VAR 0 6
15097: PUSH
15098: LD_VAR 0 1
15102: PPUSH
15103: LD_INT 21
15105: PUSH
15106: LD_INT 3
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PPUSH
15113: CALL 11587 0 2
15117: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15118: LD_ADDR_VAR 0 7
15122: PUSH
15123: LD_VAR 0 1
15127: PPUSH
15128: LD_INT 81
15130: PUSH
15131: LD_VAR 0 1
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: PPUSH
15140: CALL 11587 0 2
15144: ST_TO_ADDR
// if not enemy then
15145: LD_VAR 0 7
15149: NOT
15150: IFFALSE 15162
// result := false else
15152: LD_ADDR_VAR 0 3
15156: PUSH
15157: LD_INT 0
15159: ST_TO_ADDR
15160: GO 15216
// begin scan := NearestUnit ( b , enemy ) ;
15162: LD_ADDR_VAR 0 5
15166: PUSH
15167: LD_VAR 0 6
15171: PPUSH
15172: LD_VAR 0 7
15176: PPUSH
15177: CALL 32204 0 2
15181: ST_TO_ADDR
// if scan [ 2 ] < dist then
15182: LD_VAR 0 5
15186: PUSH
15187: LD_INT 2
15189: ARRAY
15190: PUSH
15191: LD_VAR 0 2
15195: LESS
15196: IFFALSE 15208
// result := true else
15198: LD_ADDR_VAR 0 3
15202: PUSH
15203: LD_INT 1
15205: ST_TO_ADDR
15206: GO 15216
// result := false ;
15208: LD_ADDR_VAR 0 3
15212: PUSH
15213: LD_INT 0
15215: ST_TO_ADDR
// end ; end ;
15216: LD_VAR 0 3
15220: RET
// export function MCF_Info ( ) ; begin
15221: LD_INT 0
15223: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15224: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15226: PUSH
15227: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15229: ADD
15230: PUSH
15231: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15233: ADD
15234: PUSH
15235: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15237: ADD
15238: PUSH
15239: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15241: ADD
15242: PUSH
15243: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15245: ADD
15246: PUSH
15247: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15249: ADD
15250: PUSH
15251: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15253: ADD
15254: PUSH
15255: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15257: ADD
15258: PUSH
15259: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15261: ADD
15262: PPUSH
15263: CALL 8505 0 1
// end ; end_of_file
15267: LD_VAR 0 1
15271: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15272: LD_INT 0
15274: PPUSH
15275: PPUSH
15276: PPUSH
15277: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15278: LD_ADDR_VAR 0 5
15282: PUSH
15283: LD_VAR 0 1
15287: PPUSH
15288: LD_INT 2
15290: PUSH
15291: LD_INT 25
15293: PUSH
15294: LD_INT 2
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: PUSH
15301: LD_INT 25
15303: PUSH
15304: LD_INT 3
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 25
15313: PUSH
15314: LD_INT 4
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL 11587 0 2
15331: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15332: LD_ADDR_VAR 0 5
15336: PUSH
15337: LD_VAR 0 5
15341: PPUSH
15342: LD_INT 0
15344: PPUSH
15345: CALL 13736 0 2
15349: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15350: LD_ADDR_VAR 0 6
15354: PUSH
15355: LD_VAR 0 1
15359: PPUSH
15360: LD_VAR 0 5
15364: PPUSH
15365: LD_INT 1
15367: PPUSH
15368: CALL 13356 0 3
15372: ST_TO_ADDR
// if n > sk then
15373: LD_VAR 0 2
15377: PUSH
15378: LD_VAR 0 6
15382: GREATER
15383: IFFALSE 15395
// n := sk ;
15385: LD_ADDR_VAR 0 2
15389: PUSH
15390: LD_VAR 0 6
15394: ST_TO_ADDR
// for i = 1 to n do
15395: LD_ADDR_VAR 0 4
15399: PUSH
15400: DOUBLE
15401: LD_INT 1
15403: DEC
15404: ST_TO_ADDR
15405: LD_VAR 0 2
15409: PUSH
15410: FOR_TO
15411: IFFALSE 15523
// if ( sk [ i ] [ 1 ] ) <> 0 then
15413: LD_VAR 0 6
15417: PUSH
15418: LD_VAR 0 4
15422: ARRAY
15423: PUSH
15424: LD_INT 1
15426: ARRAY
15427: PUSH
15428: LD_INT 0
15430: NONEQUAL
15431: IFFALSE 15521
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15433: LD_ADDR_EXP 55
15437: PUSH
15438: LD_EXP 55
15442: PPUSH
15443: LD_VAR 0 1
15447: PPUSH
15448: LD_VAR 0 6
15452: PUSH
15453: LD_VAR 0 4
15457: ARRAY
15458: PUSH
15459: LD_INT 1
15461: ARRAY
15462: PPUSH
15463: LD_INT 1
15465: PPUSH
15466: CALL 41882 0 4
15470: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15471: LD_ADDR_EXP 58
15475: PUSH
15476: LD_EXP 58
15480: PPUSH
15481: LD_VAR 0 1
15485: PPUSH
15486: LD_EXP 58
15490: PUSH
15491: LD_VAR 0 1
15495: ARRAY
15496: PUSH
15497: LD_INT 1
15499: PLUS
15500: PPUSH
15501: LD_VAR 0 6
15505: PUSH
15506: LD_VAR 0 4
15510: ARRAY
15511: PUSH
15512: LD_INT 1
15514: ARRAY
15515: PPUSH
15516: CALL 31052 0 4
15520: ST_TO_ADDR
// end ;
15521: GO 15410
15523: POP
15524: POP
// end ;
15525: LD_VAR 0 3
15529: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15530: LD_INT 0
15532: PPUSH
15533: PPUSH
15534: PPUSH
15535: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15536: LD_ADDR_VAR 0 5
15540: PUSH
15541: LD_VAR 0 1
15545: PPUSH
15546: LD_INT 2
15548: PUSH
15549: LD_INT 25
15551: PUSH
15552: LD_INT 1
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PUSH
15559: LD_INT 25
15561: PUSH
15562: LD_INT 3
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: PUSH
15569: LD_INT 25
15571: PUSH
15572: LD_INT 4
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: PPUSH
15585: CALL 11587 0 2
15589: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15590: LD_ADDR_VAR 0 5
15594: PUSH
15595: LD_VAR 0 5
15599: PPUSH
15600: LD_INT 0
15602: PPUSH
15603: CALL 13736 0 2
15607: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15608: LD_ADDR_VAR 0 6
15612: PUSH
15613: LD_VAR 0 1
15617: PPUSH
15618: LD_VAR 0 5
15622: PPUSH
15623: LD_INT 2
15625: PPUSH
15626: CALL 13356 0 3
15630: ST_TO_ADDR
// if n > sk then
15631: LD_VAR 0 2
15635: PUSH
15636: LD_VAR 0 6
15640: GREATER
15641: IFFALSE 15653
// n := sk ;
15643: LD_ADDR_VAR 0 2
15647: PUSH
15648: LD_VAR 0 6
15652: ST_TO_ADDR
// for i = 1 to n do
15653: LD_ADDR_VAR 0 4
15657: PUSH
15658: DOUBLE
15659: LD_INT 1
15661: DEC
15662: ST_TO_ADDR
15663: LD_VAR 0 2
15667: PUSH
15668: FOR_TO
15669: IFFALSE 15781
// if ( sk [ i ] [ 1 ] ) <> 0 then
15671: LD_VAR 0 6
15675: PUSH
15676: LD_VAR 0 4
15680: ARRAY
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PUSH
15686: LD_INT 0
15688: NONEQUAL
15689: IFFALSE 15779
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15691: LD_ADDR_EXP 55
15695: PUSH
15696: LD_EXP 55
15700: PPUSH
15701: LD_VAR 0 1
15705: PPUSH
15706: LD_VAR 0 6
15710: PUSH
15711: LD_VAR 0 4
15715: ARRAY
15716: PUSH
15717: LD_INT 1
15719: ARRAY
15720: PPUSH
15721: LD_INT 2
15723: PPUSH
15724: CALL 41882 0 4
15728: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15729: LD_ADDR_EXP 59
15733: PUSH
15734: LD_EXP 59
15738: PPUSH
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_EXP 59
15748: PUSH
15749: LD_VAR 0 1
15753: ARRAY
15754: PUSH
15755: LD_INT 1
15757: PLUS
15758: PPUSH
15759: LD_VAR 0 6
15763: PUSH
15764: LD_VAR 0 4
15768: ARRAY
15769: PUSH
15770: LD_INT 1
15772: ARRAY
15773: PPUSH
15774: CALL 31052 0 4
15778: ST_TO_ADDR
// end ;
15779: GO 15668
15781: POP
15782: POP
// end ;
15783: LD_VAR 0 3
15787: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15788: LD_INT 0
15790: PPUSH
15791: PPUSH
15792: PPUSH
15793: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15794: LD_ADDR_VAR 0 5
15798: PUSH
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 2
15806: PUSH
15807: LD_INT 25
15809: PUSH
15810: LD_INT 1
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: PUSH
15817: LD_INT 25
15819: PUSH
15820: LD_INT 2
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 25
15829: PUSH
15830: LD_INT 4
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: PPUSH
15843: CALL 11587 0 2
15847: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15848: LD_ADDR_VAR 0 5
15852: PUSH
15853: LD_VAR 0 5
15857: PPUSH
15858: LD_INT 0
15860: PPUSH
15861: CALL 13736 0 2
15865: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15866: LD_ADDR_VAR 0 6
15870: PUSH
15871: LD_VAR 0 1
15875: PPUSH
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_INT 3
15883: PPUSH
15884: CALL 13356 0 3
15888: ST_TO_ADDR
// if n > sk then
15889: LD_VAR 0 2
15893: PUSH
15894: LD_VAR 0 6
15898: GREATER
15899: IFFALSE 15911
// n := sk ;
15901: LD_ADDR_VAR 0 2
15905: PUSH
15906: LD_VAR 0 6
15910: ST_TO_ADDR
// for i = 1 to n do
15911: LD_ADDR_VAR 0 4
15915: PUSH
15916: DOUBLE
15917: LD_INT 1
15919: DEC
15920: ST_TO_ADDR
15921: LD_VAR 0 2
15925: PUSH
15926: FOR_TO
15927: IFFALSE 16039
// if ( sk [ i ] [ 1 ] ) <> 0 then
15929: LD_VAR 0 6
15933: PUSH
15934: LD_VAR 0 4
15938: ARRAY
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PUSH
15944: LD_INT 0
15946: NONEQUAL
15947: IFFALSE 16037
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15949: LD_ADDR_EXP 55
15953: PUSH
15954: LD_EXP 55
15958: PPUSH
15959: LD_VAR 0 1
15963: PPUSH
15964: LD_VAR 0 6
15968: PUSH
15969: LD_VAR 0 4
15973: ARRAY
15974: PUSH
15975: LD_INT 1
15977: ARRAY
15978: PPUSH
15979: LD_INT 3
15981: PPUSH
15982: CALL 41882 0 4
15986: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15987: LD_ADDR_EXP 57
15991: PUSH
15992: LD_EXP 57
15996: PPUSH
15997: LD_VAR 0 1
16001: PPUSH
16002: LD_EXP 57
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: PUSH
16013: LD_INT 1
16015: PLUS
16016: PPUSH
16017: LD_VAR 0 6
16021: PUSH
16022: LD_VAR 0 4
16026: ARRAY
16027: PUSH
16028: LD_INT 1
16030: ARRAY
16031: PPUSH
16032: CALL 31052 0 4
16036: ST_TO_ADDR
// end ;
16037: GO 15926
16039: POP
16040: POP
// end ;
16041: LD_VAR 0 3
16045: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
16050: PPUSH
16051: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16052: LD_ADDR_VAR 0 5
16056: PUSH
16057: LD_VAR 0 1
16061: PPUSH
16062: LD_INT 2
16064: PUSH
16065: LD_INT 25
16067: PUSH
16068: LD_INT 1
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: LD_INT 25
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL 11587 0 2
16094: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16095: LD_ADDR_VAR 0 5
16099: PUSH
16100: LD_VAR 0 5
16104: PPUSH
16105: LD_INT 0
16107: PPUSH
16108: CALL 13736 0 2
16112: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16113: LD_ADDR_VAR 0 6
16117: PUSH
16118: LD_VAR 0 1
16122: PPUSH
16123: LD_VAR 0 5
16127: PPUSH
16128: LD_INT 4
16130: PPUSH
16131: CALL 13356 0 3
16135: ST_TO_ADDR
// if n > sk then
16136: LD_VAR 0 2
16140: PUSH
16141: LD_VAR 0 6
16145: GREATER
16146: IFFALSE 16158
// n := sk ;
16148: LD_ADDR_VAR 0 2
16152: PUSH
16153: LD_VAR 0 6
16157: ST_TO_ADDR
// for i = 1 to n do
16158: LD_ADDR_VAR 0 4
16162: PUSH
16163: DOUBLE
16164: LD_INT 1
16166: DEC
16167: ST_TO_ADDR
16168: LD_VAR 0 2
16172: PUSH
16173: FOR_TO
16174: IFFALSE 16286
// if ( sk [ i ] [ 1 ] ) <> 0 then
16176: LD_VAR 0 6
16180: PUSH
16181: LD_VAR 0 4
16185: ARRAY
16186: PUSH
16187: LD_INT 1
16189: ARRAY
16190: PUSH
16191: LD_INT 0
16193: NONEQUAL
16194: IFFALSE 16284
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16196: LD_ADDR_EXP 55
16200: PUSH
16201: LD_EXP 55
16205: PPUSH
16206: LD_VAR 0 1
16210: PPUSH
16211: LD_VAR 0 6
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: PPUSH
16226: LD_INT 4
16228: PPUSH
16229: CALL 41882 0 4
16233: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16234: LD_ADDR_EXP 56
16238: PUSH
16239: LD_EXP 56
16243: PPUSH
16244: LD_VAR 0 1
16248: PPUSH
16249: LD_EXP 56
16253: PUSH
16254: LD_VAR 0 1
16258: ARRAY
16259: PUSH
16260: LD_INT 1
16262: PLUS
16263: PPUSH
16264: LD_VAR 0 6
16268: PUSH
16269: LD_VAR 0 4
16273: ARRAY
16274: PUSH
16275: LD_INT 1
16277: ARRAY
16278: PPUSH
16279: CALL 31052 0 4
16283: ST_TO_ADDR
// end ;
16284: GO 16173
16286: POP
16287: POP
// end ;
16288: LD_VAR 0 3
16292: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16293: LD_INT 0
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16299: LD_ADDR_VAR 0 6
16303: PUSH
16304: LD_VAR 0 1
16308: PPUSH
16309: LD_INT 2
16311: PUSH
16312: LD_INT 25
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PUSH
16322: LD_INT 25
16324: PUSH
16325: LD_INT 2
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: PUSH
16332: LD_INT 25
16334: PUSH
16335: LD_INT 3
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PUSH
16342: LD_INT 25
16344: PUSH
16345: LD_INT 4
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: PPUSH
16359: CALL 11587 0 2
16363: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16364: LD_ADDR_VAR 0 6
16368: PUSH
16369: LD_VAR 0 6
16373: PPUSH
16374: LD_INT 0
16376: PPUSH
16377: CALL 13736 0 2
16381: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16382: LD_ADDR_VAR 0 7
16386: PUSH
16387: LD_VAR 0 1
16391: PPUSH
16392: LD_VAR 0 6
16396: PPUSH
16397: LD_INT 1
16399: PPUSH
16400: CALL 13356 0 3
16404: ST_TO_ADDR
// if n > sk then
16405: LD_VAR 0 2
16409: PUSH
16410: LD_VAR 0 7
16414: GREATER
16415: IFFALSE 16427
// n := sk ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 7
16426: ST_TO_ADDR
// for i = 1 to n do
16427: LD_ADDR_VAR 0 5
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16487
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16445: LD_ADDR_EXP 55
16449: PUSH
16450: LD_EXP 55
16454: PPUSH
16455: LD_VAR 0 1
16459: PPUSH
16460: LD_VAR 0 7
16464: PUSH
16465: LD_VAR 0 5
16469: ARRAY
16470: PUSH
16471: LD_INT 1
16473: ARRAY
16474: PPUSH
16475: LD_VAR 0 3
16479: PPUSH
16480: CALL 41882 0 4
16484: ST_TO_ADDR
// end ;
16485: GO 16442
16487: POP
16488: POP
// end ;
16489: LD_VAR 0 4
16493: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
// b := false ;
16499: LD_ADDR_VAR 0 6
16503: PUSH
16504: LD_INT 0
16506: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16507: LD_VAR 0 3
16511: PUSH
16512: LD_INT 1
16514: PUSH
16515: LD_INT 9
16517: PUSH
16518: LD_INT 5
16520: PUSH
16521: LD_INT 8
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: IN
16530: IFFALSE 16618
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16532: LD_VAR 0 1
16536: PPUSH
16537: LD_INT 2
16539: PUSH
16540: LD_INT 30
16542: PUSH
16543: LD_INT 4
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: PUSH
16550: LD_INT 30
16552: PUSH
16553: LD_INT 5
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: PPUSH
16565: CALL 11587 0 2
16569: IFFALSE 16618
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16571: LD_ADDR_VAR 0 6
16575: PUSH
16576: LD_VAR 0 1
16580: PPUSH
16581: LD_INT 2
16583: PUSH
16584: LD_INT 30
16586: PUSH
16587: LD_INT 4
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 30
16596: PUSH
16597: LD_INT 5
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: PPUSH
16609: CALL 11587 0 2
16613: PUSH
16614: LD_INT 1
16616: ARRAY
16617: ST_TO_ADDR
// if class = class_engineer then
16618: LD_VAR 0 3
16622: PUSH
16623: LD_INT 2
16625: EQUAL
16626: IFFALSE 16714
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16628: LD_VAR 0 1
16632: PPUSH
16633: LD_INT 2
16635: PUSH
16636: LD_INT 30
16638: PUSH
16639: LD_INT 0
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: LD_INT 30
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PPUSH
16661: CALL 11587 0 2
16665: IFFALSE 16714
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16667: LD_ADDR_VAR 0 6
16671: PUSH
16672: LD_VAR 0 1
16676: PPUSH
16677: LD_INT 2
16679: PUSH
16680: LD_INT 30
16682: PUSH
16683: LD_INT 0
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: LD_INT 30
16692: PUSH
16693: LD_INT 1
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL 11587 0 2
16709: PUSH
16710: LD_INT 1
16712: ARRAY
16713: ST_TO_ADDR
// if class = class_mechanic then
16714: LD_VAR 0 3
16718: PUSH
16719: LD_INT 3
16721: EQUAL
16722: IFFALSE 16792
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16724: LD_VAR 0 1
16728: PPUSH
16729: LD_INT 30
16731: PUSH
16732: LD_INT 3
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: PPUSH
16739: CALL 11587 0 2
16743: IFFALSE 16792
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16745: LD_ADDR_VAR 0 6
16749: PUSH
16750: LD_VAR 0 1
16754: PPUSH
16755: LD_INT 2
16757: PUSH
16758: LD_INT 30
16760: PUSH
16761: LD_INT 2
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 30
16770: PUSH
16771: LD_INT 3
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: PPUSH
16783: CALL 11587 0 2
16787: PUSH
16788: LD_INT 1
16790: ARRAY
16791: ST_TO_ADDR
// if class = class_scientistic then
16792: LD_VAR 0 3
16796: PUSH
16797: LD_INT 4
16799: EQUAL
16800: IFFALSE 16910
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16802: LD_VAR 0 1
16806: PPUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 30
16812: PUSH
16813: LD_INT 6
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PUSH
16820: LD_INT 30
16822: PUSH
16823: LD_INT 7
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: PUSH
16830: LD_INT 30
16832: PUSH
16833: LD_INT 8
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL 11587 0 2
16850: IFFALSE 16910
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16852: LD_ADDR_VAR 0 6
16856: PUSH
16857: LD_VAR 0 1
16861: PPUSH
16862: LD_INT 2
16864: PUSH
16865: LD_INT 30
16867: PUSH
16868: LD_INT 6
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 30
16877: PUSH
16878: LD_INT 7
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: PUSH
16885: LD_INT 30
16887: PUSH
16888: LD_INT 8
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: PPUSH
16901: CALL 11587 0 2
16905: PUSH
16906: LD_INT 1
16908: ARRAY
16909: ST_TO_ADDR
// if GetClass ( unit ) = class then
16910: LD_VAR 0 2
16914: PPUSH
16915: CALL_OW 257
16919: PUSH
16920: LD_VAR 0 3
16924: EQUAL
16925: IFFALSE 16959
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16927: LD_ADDR_EXP 55
16931: PUSH
16932: LD_EXP 55
16936: PPUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_VAR 0 2
16946: PPUSH
16947: LD_VAR 0 3
16951: PPUSH
16952: CALL 41973 0 4
16956: ST_TO_ADDR
// end else
16957: GO 17052
// if b then
16959: LD_VAR 0 6
16963: IFFALSE 17044
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16965: LD_VAR 0 2
16969: PPUSH
16970: CALL_OW 310
16974: PUSH
16975: LD_VAR 0 2
16979: PPUSH
16980: CALL_OW 310
16984: PUSH
16985: LD_VAR 0 6
16989: NONEQUAL
16990: AND
16991: IFFALSE 17002
// ComExitBuilding ( unit ) ;
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL_OW 122
// if not IsInUnit ( unit ) then
17002: LD_VAR 0 2
17006: PPUSH
17007: CALL_OW 310
17011: NOT
17012: IFFALSE 17028
// ComEnterUnit ( unit , b ) ;
17014: LD_VAR 0 2
17018: PPUSH
17019: LD_VAR 0 6
17023: PPUSH
17024: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17028: LD_VAR 0 2
17032: PPUSH
17033: LD_VAR 0 3
17037: PPUSH
17038: CALL_OW 183
// end else
17042: GO 17052
// result := false ;
17044: LD_ADDR_VAR 0 4
17048: PUSH
17049: LD_INT 0
17051: ST_TO_ADDR
// end ; end_of_file
17052: LD_VAR 0 4
17056: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
17061: PPUSH
17062: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17063: LD_ADDR_VAR 0 5
17067: PUSH
17068: LD_INT 35
17070: PUSH
17071: LD_INT 45
17073: PUSH
17074: LD_INT 46
17076: PUSH
17077: LD_INT 47
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: LD_INT 2
17085: PUSH
17086: LD_INT 48
17088: PUSH
17089: LD_INT 49
17091: PUSH
17092: LD_INT 50
17094: PUSH
17095: LD_INT 20
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: LIST
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: ST_TO_ADDR
// if MCF_Lab ( side ) then
17110: LD_VAR 0 1
17114: PPUSH
17115: CALL 11626 0 1
17119: IFFALSE 17358
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17121: LD_VAR 0 1
17125: PPUSH
17126: CALL 11626 0 1
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: PPUSH
17135: CALL_OW 461
17139: PUSH
17140: LD_INT 2
17142: EQUAL
17143: IFFALSE 17282
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17145: LD_VAR 0 1
17149: PPUSH
17150: CALL 11626 0 1
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL 17454 0 2
17168: IFFALSE 17195
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17170: LD_VAR 0 1
17174: PPUSH
17175: CALL 11626 0 1
17179: PUSH
17180: LD_INT 1
17182: ARRAY
17183: PPUSH
17184: LD_VAR 0 2
17188: PPUSH
17189: CALL_OW 124
17193: GO 17282
// if MCF_Lab ( side ) > 1 then
17195: LD_VAR 0 1
17199: PPUSH
17200: CALL 11626 0 1
17204: PUSH
17205: LD_INT 1
17207: GREATER
17208: IFFALSE 17282
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17210: LD_VAR 0 1
17214: PPUSH
17215: CALL 11626 0 1
17219: PUSH
17220: LD_INT 2
17222: ARRAY
17223: PPUSH
17224: CALL_OW 461
17228: PUSH
17229: LD_INT 2
17231: EQUAL
17232: IFFALSE 17282
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11626 0 1
17243: PUSH
17244: LD_INT 2
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL 17454 0 2
17257: IFFALSE 17282
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11626 0 1
17268: PUSH
17269: LD_INT 2
17271: ARRAY
17272: PPUSH
17273: LD_VAR 0 2
17277: PPUSH
17278: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17282: LD_VAR 0 2
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: LD_INT 11
17292: PUSH
17293: LD_INT 4
17295: PUSH
17296: LD_INT 3
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: LIST
17304: IN
17305: IFFALSE 17358
// begin for lab in MCF_Lab ( side ) do
17307: LD_ADDR_VAR 0 6
17311: PUSH
17312: LD_VAR 0 1
17316: PPUSH
17317: CALL 11626 0 1
17321: PUSH
17322: FOR_IN
17323: IFFALSE 17356
// if BuildingStatus ( lab ) = bs_need_ape then
17325: LD_VAR 0 6
17329: PPUSH
17330: CALL_OW 461
17334: PUSH
17335: LD_INT 10
17337: EQUAL
17338: IFFALSE 17354
// MCL_ResTame ( side , lab ) ;
17340: LD_VAR 0 1
17344: PPUSH
17345: LD_VAR 0 6
17349: PPUSH
17350: CALL 17579 0 2
17354: GO 17322
17356: POP
17357: POP
// end ; end ; end ;
17358: LD_VAR 0 3
17362: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17363: LD_INT 0
17365: PPUSH
17366: PPUSH
// tmp := [ ] ;
17367: LD_ADDR_VAR 0 3
17371: PUSH
17372: EMPTY
17373: ST_TO_ADDR
// if not lab then
17374: LD_VAR 0 1
17378: NOT
17379: IFFALSE 17391
// result := false else
17381: LD_ADDR_VAR 0 2
17385: PUSH
17386: LD_INT 0
17388: ST_TO_ADDR
17389: GO 17449
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17391: LD_ADDR_VAR 0 3
17395: PUSH
17396: LD_VAR 0 3
17400: PUSH
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: CALL_OW 268
17413: ADD
17414: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17415: LD_ADDR_VAR 0 3
17419: PUSH
17420: LD_VAR 0 3
17424: PUSH
17425: LD_VAR 0 1
17429: PPUSH
17430: LD_INT 2
17432: PPUSH
17433: CALL_OW 268
17437: ADD
17438: ST_TO_ADDR
// result := tmp ;
17439: LD_ADDR_VAR 0 2
17443: PUSH
17444: LD_VAR 0 3
17448: ST_TO_ADDR
// end ; end ;
17449: LD_VAR 0 2
17453: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17454: LD_INT 0
17456: PPUSH
17457: PPUSH
17458: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17459: LD_ADDR_VAR 0 5
17463: PUSH
17464: LD_INT 35
17466: PUSH
17467: LD_INT 45
17469: PUSH
17470: LD_INT 46
17472: PUSH
17473: LD_INT 47
17475: PUSH
17476: LD_INT 1
17478: PUSH
17479: LD_INT 2
17481: PUSH
17482: LD_INT 48
17484: PUSH
17485: LD_INT 49
17487: PUSH
17488: LD_INT 50
17490: PUSH
17491: LD_INT 20
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: LIST
17505: ST_TO_ADDR
// if lab then
17506: LD_VAR 0 1
17510: IFFALSE 17566
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17512: LD_VAR 0 2
17516: PUSH
17517: LD_VAR 0 5
17521: IN
17522: PUSH
17523: LD_VAR 0 2
17527: PPUSH
17528: CALL_OW 481
17532: PUSH
17533: LD_VAR 0 1
17537: PPUSH
17538: CALL 17363 0 1
17542: IN
17543: OR
17544: IFFALSE 17556
// result := true else
17546: LD_ADDR_VAR 0 3
17550: PUSH
17551: LD_INT 1
17553: ST_TO_ADDR
17554: GO 17564
// result := false ;
17556: LD_ADDR_VAR 0 3
17560: PUSH
17561: LD_INT 0
17563: ST_TO_ADDR
// end else
17564: GO 17574
// result := false ;
17566: LD_ADDR_VAR 0 3
17570: PUSH
17571: LD_INT 0
17573: ST_TO_ADDR
// end ;
17574: LD_VAR 0 3
17578: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17579: LD_INT 0
17581: PPUSH
17582: PPUSH
17583: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17584: LD_ADDR_VAR 0 4
17588: PUSH
17589: LD_VAR 0 1
17593: PPUSH
17594: LD_INT 171
17596: PPUSH
17597: EMPTY
17598: PPUSH
17599: CALL 12290 0 3
17603: ST_TO_ADDR
// if not ape then
17604: LD_VAR 0 4
17608: NOT
17609: IFFALSE 17641
// if MCF_Ape ( side ) then
17611: LD_VAR 0 1
17615: PPUSH
17616: CALL 12000 0 1
17620: IFFALSE 17641
// ape := MCF_Ape ( side ) [ 1 ] ;
17622: LD_ADDR_VAR 0 4
17626: PUSH
17627: LD_VAR 0 1
17631: PPUSH
17632: CALL 12000 0 1
17636: PUSH
17637: LD_INT 1
17639: ARRAY
17640: ST_TO_ADDR
// if ape then
17641: LD_VAR 0 4
17645: IFFALSE 17696
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17647: LD_VAR 0 4
17651: PUSH
17652: LD_INT 1
17654: ARRAY
17655: PPUSH
17656: CALL_OW 310
17660: PUSH
17661: LD_VAR 0 4
17665: PUSH
17666: LD_INT 1
17668: ARRAY
17669: PPUSH
17670: CALL_OW 310
17674: PUSH
17675: LD_VAR 0 2
17679: NONEQUAL
17680: AND
17681: IFFALSE 17696
// ComExitBuilding ( ape [ 1 ] ) ;
17683: LD_VAR 0 4
17687: PUSH
17688: LD_INT 1
17690: ARRAY
17691: PPUSH
17692: CALL_OW 122
// if not lab then
17696: LD_VAR 0 2
17700: NOT
17701: IFFALSE 17707
// exit else
17703: GO 17855
17705: GO 17815
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17707: LD_VAR 0 1
17711: PPUSH
17712: LD_INT 16
17714: PPUSH
17715: LD_INT 25
17717: PUSH
17718: LD_INT 4
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: PPUSH
17725: CALL 12290 0 3
17729: PUSH
17730: LD_INT 0
17732: EQUAL
17733: PUSH
17734: LD_VAR 0 2
17738: PPUSH
17739: CALL_OW 313
17743: PUSH
17744: LD_INT 6
17746: EQUAL
17747: AND
17748: IFFALSE 17815
// begin tmp := UnitsInside ( lab ) ;
17750: LD_ADDR_VAR 0 5
17754: PUSH
17755: LD_VAR 0 2
17759: PPUSH
17760: CALL_OW 313
17764: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17765: LD_VAR 0 5
17769: PUSH
17770: LD_VAR 0 5
17774: ARRAY
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17783: LD_VAR 0 5
17787: PUSH
17788: LD_VAR 0 5
17792: ARRAY
17793: PPUSH
17794: CALL_OW 310
17798: IFFALSE 17815
// ComExitBuilding ( tmp [ tmp ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 5
17809: ARRAY
17810: PPUSH
17811: CALL_OW 122
// end ; if ape then
17815: LD_VAR 0 4
17819: IFFALSE 17855
// if not IsInUnit ( ape [ 1 ] ) then
17821: LD_VAR 0 4
17825: PUSH
17826: LD_INT 1
17828: ARRAY
17829: PPUSH
17830: CALL_OW 310
17834: NOT
17835: IFFALSE 17855
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17837: LD_VAR 0 4
17841: PUSH
17842: LD_INT 1
17844: ARRAY
17845: PPUSH
17846: LD_VAR 0 2
17850: PPUSH
17851: CALL_OW 120
// end ;
17855: LD_VAR 0 3
17859: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17860: LD_INT 0
17862: PPUSH
17863: PPUSH
17864: PPUSH
// result := false ;
17865: LD_ADDR_VAR 0 2
17869: PUSH
17870: LD_INT 0
17872: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_VAR 0 1
17882: PPUSH
17883: CALL 17970 0 1
17887: ST_TO_ADDR
// if techs then
17888: LD_VAR 0 3
17892: IFFALSE 17922
// if techs [ 2 ] then
17894: LD_VAR 0 3
17898: PUSH
17899: LD_INT 2
17901: ARRAY
17902: IFFALSE 17914
// result := true else
17904: LD_ADDR_VAR 0 2
17908: PUSH
17909: LD_INT 1
17911: ST_TO_ADDR
17912: GO 17922
// result := false ;
17914: LD_ADDR_VAR 0 2
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// end ;
17922: LD_VAR 0 2
17926: RET
// export function MCL_Start ( side ) ; var i ; begin
17927: LD_INT 0
17929: PPUSH
17930: PPUSH
// if MCL_GetTechList ( side ) then
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL 17970 0 1
17940: IFFALSE 17965
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 1
17951: PPUSH
17952: CALL 17970 0 1
17956: PUSH
17957: LD_INT 1
17959: ARRAY
17960: PPUSH
17961: CALL 17057 0 2
// end ;
17965: LD_VAR 0 2
17969: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17970: LD_INT 0
17972: PPUSH
17973: PPUSH
17974: PPUSH
// if MREG_ToRes then
17975: LD_EXP 52
17979: IFFALSE 18064
// for i = 1 to MREG_ToRes do
17981: LD_ADDR_VAR 0 3
17985: PUSH
17986: DOUBLE
17987: LD_INT 1
17989: DEC
17990: ST_TO_ADDR
17991: LD_EXP 52
17995: PUSH
17996: FOR_TO
17997: IFFALSE 18062
// if MREG_ToRes [ i ] [ 1 ] = side then
17999: LD_EXP 52
18003: PUSH
18004: LD_VAR 0 3
18008: ARRAY
18009: PUSH
18010: LD_INT 1
18012: ARRAY
18013: PUSH
18014: LD_VAR 0 1
18018: EQUAL
18019: IFFALSE 18060
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18021: LD_ADDR_VAR 0 4
18025: PUSH
18026: LD_VAR 0 4
18030: PPUSH
18031: LD_VAR 0 4
18035: PUSH
18036: LD_INT 1
18038: PLUS
18039: PPUSH
18040: LD_EXP 52
18044: PUSH
18045: LD_VAR 0 3
18049: ARRAY
18050: PUSH
18051: LD_INT 2
18053: ARRAY
18054: PPUSH
18055: CALL_OW 1
18059: ST_TO_ADDR
// end ;
18060: GO 17996
18062: POP
18063: POP
// result := techs ;
18064: LD_ADDR_VAR 0 2
18068: PUSH
18069: LD_VAR 0 4
18073: ST_TO_ADDR
// end ;
18074: LD_VAR 0 2
18078: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18079: LD_INT 0
18081: PPUSH
18082: PPUSH
// for i = 1 to tech_list do
18083: LD_ADDR_VAR 0 4
18087: PUSH
18088: DOUBLE
18089: LD_INT 1
18091: DEC
18092: ST_TO_ADDR
18093: LD_VAR 0 2
18097: PUSH
18098: FOR_TO
18099: IFFALSE 18153
// if not tech_list [ i ] = 20 then
18101: LD_VAR 0 2
18105: PUSH
18106: LD_VAR 0 4
18110: ARRAY
18111: PUSH
18112: LD_INT 20
18114: EQUAL
18115: NOT
18116: IFFALSE 18151
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18118: LD_ADDR_EXP 52
18122: PUSH
18123: LD_EXP 52
18127: PPUSH
18128: LD_VAR 0 1
18132: PPUSH
18133: LD_VAR 0 2
18137: PUSH
18138: LD_VAR 0 4
18142: ARRAY
18143: PPUSH
18144: EMPTY
18145: PPUSH
18146: CALL 41882 0 4
18150: ST_TO_ADDR
18151: GO 18098
18153: POP
18154: POP
// result := true ;
18155: LD_ADDR_VAR 0 3
18159: PUSH
18160: LD_INT 1
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 3
18167: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18168: LD_INT 0
18170: PPUSH
18171: PPUSH
// for i = MREG_ToRes downto 1 do
18172: LD_ADDR_VAR 0 3
18176: PUSH
18177: DOUBLE
18178: LD_EXP 52
18182: INC
18183: ST_TO_ADDR
18184: LD_INT 1
18186: PUSH
18187: FOR_DOWNTO
18188: IFFALSE 18234
// if MREG_ToRes [ i ] [ 1 ] = side then
18190: LD_EXP 52
18194: PUSH
18195: LD_VAR 0 3
18199: ARRAY
18200: PUSH
18201: LD_INT 1
18203: ARRAY
18204: PUSH
18205: LD_VAR 0 1
18209: EQUAL
18210: IFFALSE 18232
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18212: LD_ADDR_EXP 52
18216: PUSH
18217: LD_EXP 52
18221: PPUSH
18222: LD_VAR 0 3
18226: PPUSH
18227: CALL_OW 3
18231: ST_TO_ADDR
18232: GO 18187
18234: POP
18235: POP
// result := true ;
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: LD_INT 1
18243: ST_TO_ADDR
// end ;
18244: LD_VAR 0 2
18248: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18249: LD_INT 0
18251: PPUSH
// result := GetTechProgress ( side , tech ) ;
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: LD_VAR 0 1
18261: PPUSH
18262: LD_VAR 0 2
18266: PPUSH
18267: CALL_OW 326
18271: ST_TO_ADDR
// end ;
18272: LD_VAR 0 3
18276: RET
// export function MCL_Require ( tech ) ; begin
18277: LD_INT 0
18279: PPUSH
// result := GetTechTechsReq ( tech ) ;
18280: LD_ADDR_VAR 0 2
18284: PUSH
18285: LD_VAR 0 1
18289: PPUSH
18290: CALL_OW 480
18294: ST_TO_ADDR
// end ; end_of_file
18295: LD_VAR 0 2
18299: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18300: LD_INT 0
18302: PPUSH
18303: PPUSH
18304: PPUSH
// uc_side := 0 ;
18305: LD_ADDR_OWVAR 20
18309: PUSH
18310: LD_INT 0
18312: ST_TO_ADDR
// uc_nation := 0 ;
18313: LD_ADDR_OWVAR 21
18317: PUSH
18318: LD_INT 0
18320: ST_TO_ADDR
// for i = 1 to n do
18321: LD_ADDR_VAR 0 5
18325: PUSH
18326: DOUBLE
18327: LD_INT 1
18329: DEC
18330: ST_TO_ADDR
18331: LD_VAR 0 2
18335: PUSH
18336: FOR_TO
18337: IFFALSE 18482
// begin hc_importance := 0 ;
18339: LD_ADDR_OWVAR 32
18343: PUSH
18344: LD_INT 0
18346: ST_TO_ADDR
// hc_gallery :=  ;
18347: LD_ADDR_OWVAR 33
18351: PUSH
18352: LD_STRING 
18354: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18355: LD_ADDR_OWVAR 35
18359: PUSH
18360: LD_VAR 0 3
18364: PUSH
18365: LD_INT 20
18367: MINUS
18368: PPUSH
18369: LD_VAR 0 3
18373: PUSH
18374: LD_INT 20
18376: PLUS
18377: PPUSH
18378: CALL_OW 12
18382: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18383: LD_ADDR_OWVAR 31
18387: PUSH
18388: LD_INT 0
18390: PPUSH
18391: LD_INT 2
18393: PPUSH
18394: CALL_OW 12
18398: PUSH
18399: LD_INT 0
18401: PUSH
18402: LD_INT 0
18404: PUSH
18405: LD_INT 0
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18414: LD_ADDR_OWVAR 30
18418: PUSH
18419: LD_INT 0
18421: PUSH
18422: LD_INT 0
18424: PUSH
18425: LD_INT 0
18427: PUSH
18428: LD_INT 0
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: ST_TO_ADDR
// hc_name :=  ;
18437: LD_ADDR_OWVAR 26
18441: PUSH
18442: LD_STRING 
18444: ST_TO_ADDR
// hc_class := class_apeman ;
18445: LD_ADDR_OWVAR 28
18449: PUSH
18450: LD_INT 12
18452: ST_TO_ADDR
// ape := CreateHuman ;
18453: LD_ADDR_VAR 0 6
18457: PUSH
18458: CALL_OW 44
18462: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18463: LD_VAR 0 6
18467: PPUSH
18468: LD_VAR 0 1
18472: PPUSH
18473: LD_INT 0
18475: PPUSH
18476: CALL_OW 49
// end ;
18480: GO 18336
18482: POP
18483: POP
// end ;
18484: LD_VAR 0 4
18488: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18489: LD_INT 0
18491: PPUSH
18492: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18493: LD_VAR 0 1
18497: PPUSH
18498: CALL 12000 0 1
18502: PUSH
18503: LD_EXP 39
18507: PUSH
18508: LD_VAR 0 1
18512: ARRAY
18513: GREATEREQUAL
18514: IFFALSE 18691
// begin if GetTag ( unit ) = 17 then
18516: LD_VAR 0 2
18520: PPUSH
18521: CALL_OW 110
18525: PUSH
18526: LD_INT 17
18528: EQUAL
18529: IFFALSE 18689
// begin SetTag ( unit , 0 ) ;
18531: LD_VAR 0 2
18535: PPUSH
18536: LD_INT 0
18538: PPUSH
18539: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18543: LD_VAR 0 1
18547: PPUSH
18548: CALL 11626 0 1
18552: PUSH
18553: LD_VAR 0 1
18557: PPUSH
18558: CALL 17970 0 1
18562: NOT
18563: AND
18564: IFFALSE 18589
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18566: LD_VAR 0 2
18570: PPUSH
18571: LD_VAR 0 1
18575: PPUSH
18576: CALL 11626 0 1
18580: PUSH
18581: LD_INT 1
18583: ARRAY
18584: PPUSH
18585: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18589: LD_VAR 0 1
18593: PPUSH
18594: CALL 11626 0 1
18598: NOT
18599: PUSH
18600: LD_VAR 0 1
18604: PPUSH
18605: LD_INT 30
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PPUSH
18615: CALL 11587 0 2
18619: AND
18620: IFFALSE 18689
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18622: LD_VAR 0 2
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: LD_INT 30
18634: PUSH
18635: LD_INT 1
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: PPUSH
18642: CALL 11587 0 2
18646: PUSH
18647: LD_INT 1
18649: ARRAY
18650: PPUSH
18651: CALL_OW 250
18655: PPUSH
18656: LD_VAR 0 1
18660: PPUSH
18661: LD_INT 30
18663: PUSH
18664: LD_INT 1
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PPUSH
18671: CALL 11587 0 2
18675: PUSH
18676: LD_INT 1
18678: ARRAY
18679: PPUSH
18680: CALL_OW 251
18684: PPUSH
18685: CALL_OW 111
// end ; end else
18689: GO 18875
// if GetClass ( unit ) <> 4 then
18691: LD_VAR 0 2
18695: PPUSH
18696: CALL_OW 257
18700: PUSH
18701: LD_INT 4
18703: NONEQUAL
18704: IFFALSE 18710
// exit else
18706: GO 18875
18708: GO 18875
// if GetTag ( unit ) = 0 then
18710: LD_VAR 0 2
18714: PPUSH
18715: CALL_OW 110
18719: PUSH
18720: LD_INT 0
18722: EQUAL
18723: IFFALSE 18739
// SetTag ( unit , 17 ) else
18725: LD_VAR 0 2
18729: PPUSH
18730: LD_INT 17
18732: PPUSH
18733: CALL_OW 109
18737: GO 18875
// begin if IsInUnit ( unit ) then
18739: LD_VAR 0 2
18743: PPUSH
18744: CALL_OW 310
18748: IFFALSE 18759
// ComExitBuilding ( unit ) ;
18750: LD_VAR 0 2
18754: PPUSH
18755: CALL_OW 122
// Wait ( 1 ) ;
18759: LD_INT 1
18761: PPUSH
18762: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18766: LD_ADDR_VAR 0 4
18770: PUSH
18771: LD_INT 22
18773: PUSH
18774: LD_INT 0
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: PUSH
18781: LD_INT 25
18783: PUSH
18784: LD_INT 12
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: PPUSH
18795: CALL_OW 69
18799: PPUSH
18800: LD_VAR 0 2
18804: PPUSH
18805: CALL_OW 74
18809: ST_TO_ADDR
// if not ape then
18810: LD_VAR 0 4
18814: NOT
18815: IFFALSE 18821
// exit else
18817: GO 18875
18819: GO 18830
// ComHold ( ape ) ;
18821: LD_VAR 0 4
18825: PPUSH
18826: CALL_OW 140
// if not HasTask ( unit ) then
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 314
18839: NOT
18840: IFFALSE 18873
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18842: LD_VAR 0 2
18846: PPUSH
18847: LD_VAR 0 4
18851: PPUSH
18852: CALL_OW 250
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: CALL_OW 251
18866: PPUSH
18867: CALL_OW 131
18871: GO 18875
// exit ;
18873: GO 18875
// end ; end ;
18875: LD_VAR 0 3
18879: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18880: LD_INT 0
18882: PPUSH
18883: PPUSH
18884: PPUSH
18885: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18886: LD_ADDR_VAR 0 4
18890: PUSH
18891: LD_EXP 40
18895: PUSH
18896: LD_VAR 0 1
18900: ARRAY
18901: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18902: LD_ADDR_VAR 0 5
18906: PUSH
18907: LD_VAR 0 1
18911: PPUSH
18912: LD_STRING normal
18914: PPUSH
18915: CALL 12084 0 2
18919: ST_TO_ADDR
// if apes then
18920: LD_VAR 0 5
18924: IFFALSE 19152
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18926: LD_INT 2
18928: PPUSH
18929: LD_VAR 0 1
18933: PPUSH
18934: CALL_OW 321
18938: PUSH
18939: LD_INT 2
18941: EQUAL
18942: PUSH
18943: LD_VAR 0 4
18947: PUSH
18948: LD_INT 2
18950: ARRAY
18951: PUSH
18952: LD_INT 1
18954: EQUAL
18955: AND
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_STRING engineer
18964: PPUSH
18965: CALL 12084 0 2
18969: PUSH
18970: LD_INT 3
18972: LESS
18973: AND
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_INT 30
18982: PUSH
18983: LD_INT 1
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: PPUSH
18990: CALL 11587 0 2
18994: AND
18995: IFFALSE 19049
// begin for i in apes do
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 5
19006: PUSH
19007: FOR_IN
19008: IFFALSE 19045
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_VAR 0 1
19019: PPUSH
19020: LD_INT 30
19022: PUSH
19023: LD_INT 1
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: PPUSH
19030: CALL 11587 0 2
19034: PUSH
19035: LD_INT 1
19037: ARRAY
19038: PPUSH
19039: CALL_OW 120
// end ;
19043: GO 19007
19045: POP
19046: POP
// end else
19047: GO 19152
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19049: LD_INT 11
19051: PPUSH
19052: LD_VAR 0 1
19056: PPUSH
19057: CALL_OW 321
19061: PUSH
19062: LD_INT 2
19064: EQUAL
19065: PUSH
19066: LD_VAR 0 4
19070: PUSH
19071: LD_INT 1
19073: ARRAY
19074: PUSH
19075: LD_INT 1
19077: EQUAL
19078: AND
19079: PUSH
19080: LD_VAR 0 1
19084: PPUSH
19085: LD_INT 30
19087: PUSH
19088: LD_INT 5
19090: PUSH
19091: EMPTY
19092: LIST
19093: LIST
19094: PPUSH
19095: CALL 11587 0 2
19099: AND
19100: IFFALSE 19152
// begin for i in apes do
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19150
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19115: LD_VAR 0 3
19119: PPUSH
19120: LD_VAR 0 1
19124: PPUSH
19125: LD_INT 30
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: PPUSH
19135: CALL 11587 0 2
19139: PUSH
19140: LD_INT 1
19142: ARRAY
19143: PPUSH
19144: CALL_OW 120
// end ;
19148: GO 19112
19150: POP
19151: POP
// end ; end ; end ; end_of_file
19152: LD_VAR 0 2
19156: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19157: LD_INT 0
19159: PPUSH
19160: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19161: LD_VAR 0 1
19165: PPUSH
19166: CALL_OW 257
19170: PUSH
19171: LD_INT 4
19173: EQUAL
19174: NOT
19175: PUSH
19176: LD_VAR 0 2
19180: NOT
19181: OR
19182: IFFALSE 19188
// exit else
19184: GO 19222
19186: GO 19222
// if not GetTag ( unit ) = 4 then
19188: LD_VAR 0 1
19192: PPUSH
19193: CALL_OW 110
19197: PUSH
19198: LD_INT 4
19200: EQUAL
19201: NOT
19202: IFFALSE 19208
// exit else
19204: GO 19222
19206: GO 19222
// ComHeal ( unit , target ) ;
19208: LD_VAR 0 1
19212: PPUSH
19213: LD_VAR 0 2
19217: PPUSH
19218: CALL_OW 128
// end ;
19222: LD_VAR 0 3
19226: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19227: LD_INT 0
19229: PPUSH
19230: PPUSH
19231: PPUSH
19232: PPUSH
19233: PPUSH
19234: PPUSH
19235: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19236: LD_ADDR_VAR 0 5
19240: PUSH
19241: LD_INT 22
19243: PUSH
19244: LD_VAR 0 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 1
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: LD_INT 3
19265: PUSH
19266: LD_INT 55
19268: PUSH
19269: EMPTY
19270: LIST
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: PUSH
19276: LD_INT 3
19278: PUSH
19279: LD_INT 54
19281: PUSH
19282: EMPTY
19283: LIST
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 3
19291: PUSH
19292: LD_INT 24
19294: PUSH
19295: LD_INT 1000
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: PPUSH
19313: CALL_OW 69
19317: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19318: LD_ADDR_VAR 0 8
19322: PUSH
19323: LD_VAR 0 1
19327: PPUSH
19328: LD_INT 30
19330: PUSH
19331: LD_INT 1
19333: PUSH
19334: EMPTY
19335: LIST
19336: LIST
19337: PPUSH
19338: CALL 11587 0 2
19342: ST_TO_ADDR
// r := [ ] ;
19343: LD_ADDR_VAR 0 6
19347: PUSH
19348: EMPTY
19349: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19350: LD_VAR 0 1
19354: PPUSH
19355: LD_INT 5
19357: PPUSH
19358: EMPTY
19359: PPUSH
19360: CALL 12290 0 3
19364: IFFALSE 19420
// for j in MCF_Tag ( side , 5 , [ ] ) do
19366: LD_ADDR_VAR 0 4
19370: PUSH
19371: LD_VAR 0 1
19375: PPUSH
19376: LD_INT 5
19378: PPUSH
19379: EMPTY
19380: PPUSH
19381: CALL 12290 0 3
19385: PUSH
19386: FOR_IN
19387: IFFALSE 19418
// if GetLives ( j ) = 1000 then
19389: LD_VAR 0 4
19393: PPUSH
19394: CALL_OW 256
19398: PUSH
19399: LD_INT 1000
19401: EQUAL
19402: IFFALSE 19416
// SetTag ( j , 0 ) ;
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 109
19416: GO 19386
19418: POP
19419: POP
// if tmp then
19420: LD_VAR 0 5
19424: IFFALSE 19753
// begin r := [ tmp [ 1 ] ] ;
19426: LD_ADDR_VAR 0 6
19430: PUSH
19431: LD_VAR 0 5
19435: PUSH
19436: LD_INT 1
19438: ARRAY
19439: PUSH
19440: EMPTY
19441: LIST
19442: ST_TO_ADDR
// for i = 2 to tmp do
19443: LD_ADDR_VAR 0 3
19447: PUSH
19448: DOUBLE
19449: LD_INT 2
19451: DEC
19452: ST_TO_ADDR
19453: LD_VAR 0 5
19457: PUSH
19458: FOR_TO
19459: IFFALSE 19751
// begin m := false ;
19461: LD_ADDR_VAR 0 7
19465: PUSH
19466: LD_INT 0
19468: ST_TO_ADDR
// if d then
19469: LD_VAR 0 8
19473: IFFALSE 19628
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19475: LD_VAR 0 5
19479: PUSH
19480: LD_VAR 0 3
19484: ARRAY
19485: PPUSH
19486: CALL_OW 256
19490: PUSH
19491: LD_INT 650
19493: LESS
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_VAR 0 3
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 8
19510: PUSH
19511: LD_INT 1
19513: ARRAY
19514: PPUSH
19515: CALL_OW 250
19519: PPUSH
19520: LD_VAR 0 8
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: PPUSH
19529: CALL_OW 251
19533: PPUSH
19534: CALL_OW 297
19538: PUSH
19539: LD_INT 10
19541: GREATER
19542: AND
19543: IFFALSE 19628
// begin if not GetTag ( tmp [ i ] ) = 5 then
19545: LD_VAR 0 5
19549: PUSH
19550: LD_VAR 0 3
19554: ARRAY
19555: PPUSH
19556: CALL_OW 110
19560: PUSH
19561: LD_INT 5
19563: EQUAL
19564: NOT
19565: IFFALSE 19585
// SetTag ( tmp [ i ] , 5 ) ;
19567: LD_VAR 0 5
19571: PUSH
19572: LD_VAR 0 3
19576: ARRAY
19577: PPUSH
19578: LD_INT 5
19580: PPUSH
19581: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19585: LD_VAR 0 5
19589: PUSH
19590: LD_VAR 0 3
19594: ARRAY
19595: PPUSH
19596: LD_VAR 0 8
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PPUSH
19605: CALL_OW 250
19609: PPUSH
19610: LD_VAR 0 8
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: PPUSH
19619: CALL_OW 251
19623: PPUSH
19624: CALL_OW 111
// end ; for j = 1 to r do
19628: LD_ADDR_VAR 0 4
19632: PUSH
19633: DOUBLE
19634: LD_INT 1
19636: DEC
19637: ST_TO_ADDR
19638: LD_VAR 0 6
19642: PUSH
19643: FOR_TO
19644: IFFALSE 19718
// if GetLives ( tmp [ i ] ) < r [ j ] then
19646: LD_VAR 0 5
19650: PUSH
19651: LD_VAR 0 3
19655: ARRAY
19656: PPUSH
19657: CALL_OW 256
19661: PUSH
19662: LD_VAR 0 6
19666: PUSH
19667: LD_VAR 0 4
19671: ARRAY
19672: LESS
19673: IFFALSE 19716
// begin r := Insert ( r , j , tmp [ i ] ) ;
19675: LD_ADDR_VAR 0 6
19679: PUSH
19680: LD_VAR 0 6
19684: PPUSH
19685: LD_VAR 0 4
19689: PPUSH
19690: LD_VAR 0 5
19694: PUSH
19695: LD_VAR 0 3
19699: ARRAY
19700: PPUSH
19701: CALL_OW 2
19705: ST_TO_ADDR
// m := true ;
19706: LD_ADDR_VAR 0 7
19710: PUSH
19711: LD_INT 1
19713: ST_TO_ADDR
// break ;
19714: GO 19718
// end ;
19716: GO 19643
19718: POP
19719: POP
// if not m then
19720: LD_VAR 0 7
19724: NOT
19725: IFFALSE 19749
// r := r ^ tmp [ i ] ;
19727: LD_ADDR_VAR 0 6
19731: PUSH
19732: LD_VAR 0 6
19736: PUSH
19737: LD_VAR 0 5
19741: PUSH
19742: LD_VAR 0 3
19746: ARRAY
19747: ADD
19748: ST_TO_ADDR
// end ;
19749: GO 19458
19751: POP
19752: POP
// end ; result := r end ; end_of_file
19753: LD_ADDR_VAR 0 2
19757: PUSH
19758: LD_VAR 0 6
19762: ST_TO_ADDR
19763: LD_VAR 0 2
19767: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19768: LD_INT 0
19770: PPUSH
19771: PPUSH
19772: PPUSH
// pom := GetBase ( bdepot ) ;
19773: LD_ADDR_VAR 0 3
19777: PUSH
19778: LD_VAR 0 1
19782: PPUSH
19783: CALL_OW 274
19787: ST_TO_ADDR
// sor := [ ] ;
19788: LD_ADDR_VAR 0 4
19792: PUSH
19793: EMPTY
19794: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_VAR 0 4
19804: PUSH
19805: LD_VAR 0 3
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL_OW 275
19817: ADD
19818: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19819: LD_ADDR_VAR 0 4
19823: PUSH
19824: LD_VAR 0 4
19828: PUSH
19829: LD_VAR 0 3
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 275
19841: ADD
19842: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19843: LD_ADDR_VAR 0 4
19847: PUSH
19848: LD_VAR 0 4
19852: PUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: LD_INT 3
19860: PPUSH
19861: CALL_OW 275
19865: ADD
19866: ST_TO_ADDR
// result := sor ;
19867: LD_ADDR_VAR 0 2
19871: PUSH
19872: LD_VAR 0 4
19876: ST_TO_ADDR
// end ;
19877: LD_VAR 0 2
19881: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19882: LD_INT 0
19884: PPUSH
19885: PPUSH
// while ( coord_list ) do
19886: LD_VAR 0 3
19890: IFFALSE 20064
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19892: LD_ADDR_EXP 48
19896: PUSH
19897: LD_EXP 48
19901: PPUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: LD_VAR 0 2
19911: PPUSH
19912: LD_VAR 0 3
19916: PUSH
19917: LD_INT 1
19919: ARRAY
19920: PUSH
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 2
19928: ARRAY
19929: PUSH
19930: LD_VAR 0 3
19934: PUSH
19935: LD_INT 3
19937: ARRAY
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: PPUSH
19944: CALL 41882 0 4
19948: ST_TO_ADDR
// if weapon_list then
19949: LD_VAR 0 4
19953: IFFALSE 20024
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19955: LD_ADDR_EXP 45
19959: PUSH
19960: LD_EXP 45
19964: PPUSH
19965: LD_VAR 0 1
19969: PPUSH
19970: LD_VAR 0 4
19974: PUSH
19975: LD_INT 1
19977: ARRAY
19978: PPUSH
19979: LD_VAR 0 3
19983: PUSH
19984: LD_INT 1
19986: ARRAY
19987: PUSH
19988: LD_VAR 0 3
19992: PUSH
19993: LD_INT 2
19995: ARRAY
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PPUSH
20001: CALL 41882 0 4
20005: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20006: LD_ADDR_VAR 0 4
20010: PUSH
20011: LD_VAR 0 4
20015: PPUSH
20016: LD_INT 1
20018: PPUSH
20019: CALL_OW 3
20023: ST_TO_ADDR
// end ; for i = 1 to 3 do
20024: LD_ADDR_VAR 0 6
20028: PUSH
20029: DOUBLE
20030: LD_INT 1
20032: DEC
20033: ST_TO_ADDR
20034: LD_INT 3
20036: PUSH
20037: FOR_TO
20038: IFFALSE 20060
// coord_list := Delete ( coord_list , 1 ) ;
20040: LD_ADDR_VAR 0 3
20044: PUSH
20045: LD_VAR 0 3
20049: PPUSH
20050: LD_INT 1
20052: PPUSH
20053: CALL_OW 3
20057: ST_TO_ADDR
20058: GO 20037
20060: POP
20061: POP
// end ;
20062: GO 19886
// result := true ;
20064: LD_ADDR_VAR 0 5
20068: PUSH
20069: LD_INT 1
20071: ST_TO_ADDR
// end ;
20072: LD_VAR 0 5
20076: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20077: LD_INT 0
20079: PPUSH
20080: PPUSH
// if not weapon_list then
20081: LD_VAR 0 3
20085: NOT
20086: IFFALSE 20090
// exit ;
20088: GO 20205
// while ( coord_list ) do
20090: LD_VAR 0 2
20094: IFFALSE 20205
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20096: LD_ADDR_EXP 45
20100: PUSH
20101: LD_EXP 45
20105: PPUSH
20106: LD_VAR 0 1
20110: PPUSH
20111: LD_VAR 0 3
20115: PUSH
20116: LD_INT 1
20118: ARRAY
20119: PPUSH
20120: LD_VAR 0 2
20124: PUSH
20125: LD_INT 1
20127: ARRAY
20128: PUSH
20129: LD_VAR 0 2
20133: PUSH
20134: LD_INT 2
20136: ARRAY
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PPUSH
20142: CALL 41882 0 4
20146: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20147: LD_ADDR_VAR 0 3
20151: PUSH
20152: LD_VAR 0 3
20156: PPUSH
20157: LD_INT 1
20159: PPUSH
20160: CALL_OW 3
20164: ST_TO_ADDR
// for i = 1 to 2 do
20165: LD_ADDR_VAR 0 5
20169: PUSH
20170: DOUBLE
20171: LD_INT 1
20173: DEC
20174: ST_TO_ADDR
20175: LD_INT 2
20177: PUSH
20178: FOR_TO
20179: IFFALSE 20201
// coord_list := Delete ( coord_list , 1 ) ;
20181: LD_ADDR_VAR 0 2
20185: PUSH
20186: LD_VAR 0 2
20190: PPUSH
20191: LD_INT 1
20193: PPUSH
20194: CALL_OW 3
20198: ST_TO_ADDR
20199: GO 20178
20201: POP
20202: POP
// end ;
20203: GO 20090
// end ;
20205: LD_VAR 0 4
20209: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20210: LD_INT 0
20212: PPUSH
20213: PPUSH
// while ( coord_list ) do
20214: LD_VAR 0 2
20218: IFFALSE 20373
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20220: LD_VAR 0 2
20224: PUSH
20225: LD_INT 1
20227: ARRAY
20228: PPUSH
20229: LD_VAR 0 2
20233: PUSH
20234: LD_INT 2
20236: ARRAY
20237: PPUSH
20238: CALL_OW 428
20242: IFFALSE 20333
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20244: LD_VAR 0 2
20248: PUSH
20249: LD_INT 1
20251: ARRAY
20252: PPUSH
20253: LD_VAR 0 2
20257: PUSH
20258: LD_INT 2
20260: ARRAY
20261: PPUSH
20262: CALL_OW 428
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 31
20274: PUSH
20275: LD_INT 32
20277: PUSH
20278: LD_INT 33
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: IN
20286: IFFALSE 20333
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20288: LD_ADDR_EXP 54
20292: PUSH
20293: LD_EXP 54
20297: PPUSH
20298: LD_VAR 0 1
20302: PPUSH
20303: LD_VAR 0 2
20307: PUSH
20308: LD_INT 1
20310: ARRAY
20311: PPUSH
20312: LD_VAR 0 2
20316: PUSH
20317: LD_INT 2
20319: ARRAY
20320: PPUSH
20321: CALL_OW 428
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL 41882 0 4
20332: ST_TO_ADDR
// for i = 1 to 3 do
20333: LD_ADDR_VAR 0 4
20337: PUSH
20338: DOUBLE
20339: LD_INT 1
20341: DEC
20342: ST_TO_ADDR
20343: LD_INT 3
20345: PUSH
20346: FOR_TO
20347: IFFALSE 20369
// coord_list := Delete ( coord_list , 1 ) ;
20349: LD_ADDR_VAR 0 2
20353: PUSH
20354: LD_VAR 0 2
20358: PPUSH
20359: LD_INT 1
20361: PPUSH
20362: CALL_OW 3
20366: ST_TO_ADDR
20367: GO 20346
20369: POP
20370: POP
// end ;
20371: GO 20214
// result := true ;
20373: LD_ADDR_VAR 0 3
20377: PUSH
20378: LD_INT 1
20380: ST_TO_ADDR
// end ;
20381: LD_VAR 0 3
20385: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20386: LD_INT 0
20388: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20389: LD_ADDR_EXP 48
20393: PUSH
20394: LD_EXP 48
20398: PPUSH
20399: LD_VAR 0 1
20403: PPUSH
20404: LD_INT 0
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: CALL 41882 0 4
20416: ST_TO_ADDR
// end ;
20417: LD_VAR 0 3
20421: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20422: LD_INT 0
20424: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20425: LD_ADDR_EXP 48
20429: PUSH
20430: LD_EXP 48
20434: PPUSH
20435: LD_VAR 0 1
20439: PPUSH
20440: LD_INT 6
20442: PPUSH
20443: LD_VAR 0 2
20447: PPUSH
20448: CALL 41882 0 4
20452: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20453: LD_ADDR_EXP 51
20457: PUSH
20458: LD_EXP 51
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_VAR 0 3
20472: PUSH
20473: LD_INT 1
20475: ARRAY
20476: PPUSH
20477: LD_VAR 0 3
20481: PUSH
20482: LD_INT 2
20484: ARRAY
20485: PPUSH
20486: CALL 41882 0 4
20490: ST_TO_ADDR
// end ;
20491: LD_VAR 0 4
20495: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20496: LD_INT 0
20498: PPUSH
20499: PPUSH
// if ext_list > 5 then
20500: LD_VAR 0 3
20504: PUSH
20505: LD_INT 5
20507: GREATER
20508: IFFALSE 20552
// for i = 6 to ext_list do
20510: LD_ADDR_VAR 0 5
20514: PUSH
20515: DOUBLE
20516: LD_INT 6
20518: DEC
20519: ST_TO_ADDR
20520: LD_VAR 0 3
20524: PUSH
20525: FOR_TO
20526: IFFALSE 20550
// ext_list := Delete ( ext_list , ext_list ) ;
20528: LD_ADDR_VAR 0 3
20532: PUSH
20533: LD_VAR 0 3
20537: PPUSH
20538: LD_VAR 0 3
20542: PPUSH
20543: CALL_OW 3
20547: ST_TO_ADDR
20548: GO 20525
20550: POP
20551: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20552: LD_VAR 0 1
20556: PPUSH
20557: LD_VAR 0 2
20561: PUSH
20562: LD_INT 1
20564: ARRAY
20565: PPUSH
20566: LD_VAR 0 2
20570: PUSH
20571: LD_INT 2
20573: ARRAY
20574: PPUSH
20575: LD_VAR 0 2
20579: PUSH
20580: LD_INT 3
20582: ARRAY
20583: PPUSH
20584: LD_VAR 0 3
20588: PPUSH
20589: CALL 9099 0 5
// end ;
20593: LD_VAR 0 4
20597: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20598: LD_INT 0
20600: PPUSH
20601: PPUSH
20602: PPUSH
// p := 1 ;
20603: LD_ADDR_VAR 0 6
20607: PUSH
20608: LD_INT 1
20610: ST_TO_ADDR
// if type_list = [ ] then
20611: LD_VAR 0 3
20615: PUSH
20616: EMPTY
20617: EQUAL
20618: IFFALSE 20628
// type_list := b_oil_power ;
20620: LD_ADDR_VAR 0 3
20624: PUSH
20625: LD_INT 26
20627: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20628: LD_ADDR_VAR 0 5
20632: PUSH
20633: DOUBLE
20634: LD_INT 1
20636: DEC
20637: ST_TO_ADDR
20638: LD_VAR 0 2
20642: PUSH
20643: LD_INT 3
20645: DIVREAL
20646: PUSH
20647: FOR_TO
20648: IFFALSE 20751
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20650: LD_ADDR_EXP 48
20654: PUSH
20655: LD_EXP 48
20659: PPUSH
20660: LD_VAR 0 1
20664: PPUSH
20665: LD_VAR 0 3
20669: PUSH
20670: LD_INT 1
20672: PPUSH
20673: LD_VAR 0 3
20677: PPUSH
20678: CALL_OW 12
20682: ARRAY
20683: PPUSH
20684: LD_VAR 0 2
20688: PUSH
20689: LD_VAR 0 6
20693: ARRAY
20694: PUSH
20695: LD_VAR 0 2
20699: PUSH
20700: LD_VAR 0 6
20704: PUSH
20705: LD_INT 1
20707: PLUS
20708: ARRAY
20709: PUSH
20710: LD_VAR 0 2
20714: PUSH
20715: LD_VAR 0 6
20719: PUSH
20720: LD_INT 2
20722: PLUS
20723: ARRAY
20724: PUSH
20725: EMPTY
20726: LIST
20727: LIST
20728: LIST
20729: PPUSH
20730: CALL 41882 0 4
20734: ST_TO_ADDR
// p := p + 3 ;
20735: LD_ADDR_VAR 0 6
20739: PUSH
20740: LD_VAR 0 6
20744: PUSH
20745: LD_INT 3
20747: PLUS
20748: ST_TO_ADDR
// end ;
20749: GO 20647
20751: POP
20752: POP
// end ;
20753: LD_VAR 0 4
20757: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not MREG_Deposit [ side ] then
20764: LD_EXP 63
20768: PUSH
20769: LD_VAR 0 1
20773: ARRAY
20774: NOT
20775: IFFALSE 20779
// exit ;
20777: GO 20956
// p := 1 ;
20779: LD_ADDR_VAR 0 4
20783: PUSH
20784: LD_INT 1
20786: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: DOUBLE
20793: LD_INT 1
20795: DEC
20796: ST_TO_ADDR
20797: LD_EXP 63
20801: PUSH
20802: LD_VAR 0 1
20806: ARRAY
20807: PUSH
20808: LD_INT 3
20810: DIVREAL
20811: PUSH
20812: FOR_TO
20813: IFFALSE 20954
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20815: LD_EXP 63
20819: PUSH
20820: LD_VAR 0 1
20824: ARRAY
20825: PUSH
20826: LD_VAR 0 4
20830: PUSH
20831: LD_INT 2
20833: PLUS
20834: ARRAY
20835: PUSH
20836: LD_INT 2
20838: EQUAL
20839: IFFALSE 20851
// b := b_oil_mine else
20841: LD_ADDR_VAR 0 5
20845: PUSH
20846: LD_INT 29
20848: ST_TO_ADDR
20849: GO 20859
// b := b_siberite_mine ;
20851: LD_ADDR_VAR 0 5
20855: PUSH
20856: LD_INT 30
20858: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20859: LD_ADDR_EXP 48
20863: PUSH
20864: LD_EXP 48
20868: PPUSH
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_VAR 0 5
20878: PPUSH
20879: LD_EXP 63
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: ARRAY
20895: PUSH
20896: LD_EXP 63
20900: PUSH
20901: LD_VAR 0 1
20905: ARRAY
20906: PUSH
20907: LD_VAR 0 4
20911: PUSH
20912: LD_INT 1
20914: PLUS
20915: ARRAY
20916: PUSH
20917: LD_INT 0
20919: PPUSH
20920: LD_INT 5
20922: PPUSH
20923: CALL_OW 12
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: LIST
20932: PPUSH
20933: CALL 41882 0 4
20937: ST_TO_ADDR
// p := p + 3 ;
20938: LD_ADDR_VAR 0 4
20942: PUSH
20943: LD_VAR 0 4
20947: PUSH
20948: LD_INT 3
20950: PLUS
20951: ST_TO_ADDR
// end ;
20952: GO 20812
20954: POP
20955: POP
// end ;
20956: LD_VAR 0 2
20960: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20961: LD_INT 0
20963: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20964: LD_ADDR_EXP 48
20968: PUSH
20969: LD_EXP 48
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: LD_INT 4
20981: PPUSH
20982: LD_VAR 0 2
20986: PPUSH
20987: CALL 41882 0 4
20991: ST_TO_ADDR
// end ;
20992: LD_VAR 0 3
20996: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20997: LD_INT 0
20999: PPUSH
// case nation of 1 , us :
21000: LD_VAR 0 2
21004: PUSH
21005: LD_INT 1
21007: DOUBLE
21008: EQUAL
21009: IFTRUE 21019
21011: LD_STRING us
21013: DOUBLE
21014: EQUAL
21015: IFTRUE 21019
21017: GO 21050
21019: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21020: LD_ADDR_EXP 48
21024: PUSH
21025: LD_EXP 48
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: LD_INT 36
21037: PPUSH
21038: LD_VAR 0 3
21042: PPUSH
21043: CALL 41882 0 4
21047: ST_TO_ADDR
21048: GO 21101
21050: LD_INT 2
21052: DOUBLE
21053: EQUAL
21054: IFTRUE 21064
21056: LD_STRING ar
21058: DOUBLE
21059: EQUAL
21060: IFTRUE 21064
21062: GO 21100
21064: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21065: LD_ADDR_EXP 48
21069: PUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: LD_INT 14
21077: PUSH
21078: LD_INT 2
21080: PUSH
21081: LD_INT 1
21083: PUSH
21084: LD_INT 31
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: PPUSH
21093: CALL 21106 0 2
21097: ST_TO_ADDR
21098: GO 21101
21100: POP
// end ;
21101: LD_VAR 0 4
21105: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21106: LD_INT 0
21108: PPUSH
21109: PPUSH
// for i = 1 to list do
21110: LD_ADDR_VAR 0 4
21114: PUSH
21115: DOUBLE
21116: LD_INT 1
21118: DEC
21119: ST_TO_ADDR
21120: LD_VAR 0 2
21124: PUSH
21125: FOR_TO
21126: IFFALSE 21176
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21128: LD_ADDR_EXP 53
21132: PUSH
21133: LD_EXP 53
21137: PPUSH
21138: LD_VAR 0 1
21142: PPUSH
21143: LD_EXP 53
21147: PUSH
21148: LD_VAR 0 1
21152: ARRAY
21153: PUSH
21154: LD_INT 1
21156: PLUS
21157: PPUSH
21158: LD_VAR 0 2
21162: PUSH
21163: LD_VAR 0 4
21167: ARRAY
21168: PPUSH
21169: CALL 31052 0 4
21173: ST_TO_ADDR
21174: GO 21125
21176: POP
21177: POP
// end ;
21178: LD_VAR 0 3
21182: RET
// export function MCS_GetVehicleList ( side ) ; begin
21183: LD_INT 0
21185: PPUSH
// result := MREG_ToConstruct [ side ] ;
21186: LD_ADDR_VAR 0 2
21190: PUSH
21191: LD_EXP 53
21195: PUSH
21196: LD_VAR 0 1
21200: ARRAY
21201: ST_TO_ADDR
// end ;
21202: LD_VAR 0 2
21206: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21207: LD_INT 0
21209: PPUSH
21210: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21211: LD_ADDR_EXP 60
21215: PUSH
21216: LD_EXP 60
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: LD_VAR 0 2
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 3
21240: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21241: LD_INT 0
21243: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21244: LD_ADDR_EXP 39
21248: PUSH
21249: LD_EXP 39
21253: PPUSH
21254: LD_VAR 0 1
21258: PPUSH
21259: LD_VAR 0 2
21263: PPUSH
21264: CALL_OW 1
21268: ST_TO_ADDR
// end ;
21269: LD_VAR 0 3
21273: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21274: LD_INT 0
21276: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21277: LD_ADDR_EXP 40
21281: PUSH
21282: LD_EXP 40
21286: PPUSH
21287: LD_VAR 0 1
21291: PPUSH
21292: LD_VAR 0 2
21296: PPUSH
21297: CALL_OW 1
21301: ST_TO_ADDR
// end ;
21302: LD_VAR 0 3
21306: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21307: LD_INT 0
21309: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21310: LD_ADDR_EXP 62
21314: PUSH
21315: LD_EXP 62
21319: PPUSH
21320: LD_VAR 0 1
21324: PPUSH
21325: LD_INT 1
21327: PPUSH
21328: LD_VAR 0 2
21332: PPUSH
21333: CALL 31052 0 4
21337: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21338: LD_ADDR_EXP 62
21342: PUSH
21343: LD_EXP 62
21347: PPUSH
21348: LD_VAR 0 1
21352: PPUSH
21353: LD_INT 2
21355: PPUSH
21356: LD_VAR 0 3
21360: PPUSH
21361: CALL 31052 0 4
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 4
21370: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21374: LD_ADDR_EXP 74
21378: PUSH
21379: LD_EXP 74
21383: PPUSH
21384: LD_INT 1
21386: PPUSH
21387: LD_VAR 0 1
21391: PPUSH
21392: CALL_OW 1
21396: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21397: LD_ADDR_EXP 74
21401: PUSH
21402: LD_EXP 74
21406: PPUSH
21407: LD_INT 2
21409: PPUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: CALL_OW 1
21419: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21420: LD_ADDR_EXP 74
21424: PUSH
21425: LD_EXP 74
21429: PPUSH
21430: LD_INT 3
21432: PPUSH
21433: LD_VAR 0 3
21437: PPUSH
21438: CALL_OW 1
21442: ST_TO_ADDR
// end ;
21443: LD_VAR 0 4
21447: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
// if not side or not list then
21453: LD_VAR 0 1
21457: NOT
21458: PUSH
21459: LD_VAR 0 2
21463: NOT
21464: OR
21465: IFFALSE 21469
// exit ;
21467: GO 21637
// SetTech ( 20 , side , state_researched ) ;
21469: LD_INT 20
21471: PPUSH
21472: LD_VAR 0 1
21476: PPUSH
21477: LD_INT 2
21479: PPUSH
21480: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21484: LD_ADDR_EXP 63
21488: PUSH
21489: LD_EXP 63
21493: PPUSH
21494: LD_VAR 0 1
21498: PPUSH
21499: LD_VAR 0 2
21503: PPUSH
21504: CALL_OW 2
21508: ST_TO_ADDR
// p := 1 ;
21509: LD_ADDR_VAR 0 5
21513: PUSH
21514: LD_INT 1
21516: ST_TO_ADDR
// for i = 1 to list / 3 do
21517: LD_ADDR_VAR 0 4
21521: PUSH
21522: DOUBLE
21523: LD_INT 1
21525: DEC
21526: ST_TO_ADDR
21527: LD_VAR 0 2
21531: PUSH
21532: LD_INT 3
21534: DIVREAL
21535: PUSH
21536: FOR_TO
21537: IFFALSE 21635
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21539: LD_VAR 0 2
21543: PUSH
21544: LD_VAR 0 5
21548: ARRAY
21549: PPUSH
21550: LD_VAR 0 2
21554: PUSH
21555: LD_VAR 0 5
21559: PUSH
21560: LD_INT 1
21562: PLUS
21563: ARRAY
21564: PPUSH
21565: LD_VAR 0 2
21569: PUSH
21570: LD_VAR 0 5
21574: PUSH
21575: LD_INT 2
21577: PLUS
21578: ARRAY
21579: PPUSH
21580: CALL 22339 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21584: LD_VAR 0 2
21588: PUSH
21589: LD_VAR 0 5
21593: ARRAY
21594: PPUSH
21595: LD_VAR 0 2
21599: PUSH
21600: LD_VAR 0 5
21604: PUSH
21605: LD_INT 1
21607: PLUS
21608: ARRAY
21609: PPUSH
21610: LD_VAR 0 1
21614: PPUSH
21615: CALL_OW 441
// p := p + 3 ;
21619: LD_ADDR_VAR 0 5
21623: PUSH
21624: LD_VAR 0 5
21628: PUSH
21629: LD_INT 3
21631: PLUS
21632: ST_TO_ADDR
// end ;
21633: GO 21536
21635: POP
21636: POP
// end ;
21637: LD_VAR 0 3
21641: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21642: LD_INT 0
21644: PPUSH
21645: PPUSH
// if nat = nation_arabian then
21646: LD_VAR 0 2
21650: PUSH
21651: LD_INT 2
21653: EQUAL
21654: IFFALSE 21660
// exit else
21656: GO 21732
21658: GO 21718
// if nat = nation_american then
21660: LD_VAR 0 2
21664: PUSH
21665: LD_INT 1
21667: EQUAL
21668: IFFALSE 21695
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21670: LD_ADDR_VAR 0 4
21674: PUSH
21675: LD_INT 4
21677: PUSH
21678: LD_INT 3
21680: PUSH
21681: LD_INT 1
21683: PUSH
21684: LD_INT 8
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: ST_TO_ADDR
21693: GO 21718
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21695: LD_ADDR_VAR 0 4
21699: PUSH
21700: LD_INT 24
21702: PUSH
21703: LD_INT 3
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: LD_INT 48
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21718: LD_VAR 0 1
21722: PPUSH
21723: LD_VAR 0 4
21727: PPUSH
21728: CALL 21106 0 2
// end ;
21732: LD_VAR 0 3
21736: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21737: LD_INT 0
21739: PPUSH
21740: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21741: LD_ADDR_EXP 65
21745: PUSH
21746: LD_EXP 65
21750: PPUSH
21751: LD_VAR 0 1
21755: PPUSH
21756: LD_INT 1
21758: PPUSH
21759: LD_VAR 0 4
21763: PPUSH
21764: CALL 31052 0 4
21768: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21769: LD_ADDR_EXP 66
21773: PUSH
21774: LD_EXP 66
21778: PPUSH
21779: LD_VAR 0 1
21783: PPUSH
21784: LD_INT 1
21786: PPUSH
21787: LD_VAR 0 2
21791: PPUSH
21792: CALL 31052 0 4
21796: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21797: LD_ADDR_EXP 67
21801: PUSH
21802: LD_EXP 67
21806: PPUSH
21807: LD_VAR 0 1
21811: PPUSH
21812: LD_INT 1
21814: PPUSH
21815: LD_VAR 0 3
21819: PPUSH
21820: CALL 31052 0 4
21824: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21825: LD_ADDR_EXP 68
21829: PUSH
21830: LD_EXP 68
21834: PPUSH
21835: LD_VAR 0 1
21839: PPUSH
21840: LD_INT 1
21842: PPUSH
21843: LD_VAR 0 5
21847: PPUSH
21848: CALL 31052 0 4
21852: ST_TO_ADDR
// while squad do
21853: LD_VAR 0 5
21857: IFFALSE 21950
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_VAR 0 5
21868: PUSH
21869: LD_INT 1
21871: ARRAY
21872: PUSH
21873: LD_VAR 0 5
21877: PUSH
21878: LD_INT 2
21880: ARRAY
21881: PUSH
21882: LD_VAR 0 5
21886: PUSH
21887: LD_INT 3
21889: ARRAY
21890: PUSH
21891: LD_VAR 0 5
21895: PUSH
21896: LD_INT 4
21898: ARRAY
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: LIST
21905: PPUSH
21906: CALL 21106 0 2
// for i = 1 to 4 do
21910: LD_ADDR_VAR 0 7
21914: PUSH
21915: DOUBLE
21916: LD_INT 1
21918: DEC
21919: ST_TO_ADDR
21920: LD_INT 4
21922: PUSH
21923: FOR_TO
21924: IFFALSE 21946
// squad := Delete ( squad , 1 ) ;
21926: LD_ADDR_VAR 0 5
21930: PUSH
21931: LD_VAR 0 5
21935: PPUSH
21936: LD_INT 1
21938: PPUSH
21939: CALL_OW 3
21943: ST_TO_ADDR
21944: GO 21923
21946: POP
21947: POP
// end ;
21948: GO 21853
// end ;
21950: LD_VAR 0 6
21954: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21955: LD_INT 0
21957: PPUSH
21958: PPUSH
// for i = 1 to squad do
21959: LD_ADDR_VAR 0 4
21963: PUSH
21964: DOUBLE
21965: LD_INT 1
21967: DEC
21968: ST_TO_ADDR
21969: LD_VAR 0 2
21973: PUSH
21974: FOR_TO
21975: IFFALSE 22025
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21977: LD_ADDR_EXP 71
21981: PUSH
21982: LD_EXP 71
21986: PPUSH
21987: LD_VAR 0 1
21991: PPUSH
21992: LD_EXP 71
21996: PUSH
21997: LD_VAR 0 1
22001: ARRAY
22002: PUSH
22003: LD_INT 1
22005: PLUS
22006: PPUSH
22007: LD_VAR 0 2
22011: PUSH
22012: LD_VAR 0 4
22016: ARRAY
22017: PPUSH
22018: CALL 31052 0 4
22022: ST_TO_ADDR
22023: GO 21974
22025: POP
22026: POP
// while squad do
22027: LD_VAR 0 2
22031: IFFALSE 22124
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: LD_VAR 0 2
22042: PUSH
22043: LD_INT 1
22045: ARRAY
22046: PUSH
22047: LD_VAR 0 2
22051: PUSH
22052: LD_INT 2
22054: ARRAY
22055: PUSH
22056: LD_VAR 0 2
22060: PUSH
22061: LD_INT 3
22063: ARRAY
22064: PUSH
22065: LD_VAR 0 2
22069: PUSH
22070: LD_INT 4
22072: ARRAY
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: PPUSH
22080: CALL 21106 0 2
// for i = 1 to 4 do
22084: LD_ADDR_VAR 0 4
22088: PUSH
22089: DOUBLE
22090: LD_INT 1
22092: DEC
22093: ST_TO_ADDR
22094: LD_INT 4
22096: PUSH
22097: FOR_TO
22098: IFFALSE 22120
// squad := Delete ( squad , 1 ) ;
22100: LD_ADDR_VAR 0 2
22104: PUSH
22105: LD_VAR 0 2
22109: PPUSH
22110: LD_INT 1
22112: PPUSH
22113: CALL_OW 3
22117: ST_TO_ADDR
22118: GO 22097
22120: POP
22121: POP
// end ;
22122: GO 22027
// end ;
22124: LD_VAR 0 3
22128: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22129: LD_INT 0
22131: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22132: LD_ADDR_EXP 64
22136: PUSH
22137: LD_EXP 64
22141: PPUSH
22142: LD_VAR 0 1
22146: PPUSH
22147: LD_INT 1
22149: PPUSH
22150: LD_VAR 0 2
22154: PPUSH
22155: CALL 31052 0 4
22159: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22160: LD_ADDR_EXP 64
22164: PUSH
22165: LD_EXP 64
22169: PPUSH
22170: LD_VAR 0 1
22174: PPUSH
22175: LD_INT 2
22177: PPUSH
22178: LD_VAR 0 3
22182: PPUSH
22183: CALL 31052 0 4
22187: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22188: LD_ADDR_EXP 64
22192: PUSH
22193: LD_EXP 64
22197: PPUSH
22198: LD_VAR 0 1
22202: PPUSH
22203: LD_INT 3
22205: PPUSH
22206: LD_VAR 0 4
22210: PPUSH
22211: CALL 31052 0 4
22215: ST_TO_ADDR
// end ; end_of_file
22216: LD_VAR 0 5
22220: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22221: LD_INT 0
22223: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22224: LD_ADDR_EXP 44
22228: PUSH
22229: LD_EXP 44
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 1
22241: PPUSH
22242: LD_VAR 0 2
22246: PPUSH
22247: CALL 31052 0 4
22251: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22252: LD_VAR 0 1
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL 11722 0 2
22263: PUSH
22264: LD_INT 1
22266: ARRAY
22267: PPUSH
22268: CALL_OW 248
22272: PUSH
22273: LD_INT 1
22275: EQUAL
22276: IFFALSE 22307
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 4
22285: PUSH
22286: LD_INT 1
22288: PUSH
22289: LD_INT 1
22291: PUSH
22292: LD_INT 14
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: PPUSH
22301: CALL 21106 0 2
22305: GO 22334
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22307: LD_VAR 0 1
22311: PPUSH
22312: LD_INT 24
22314: PUSH
22315: LD_INT 1
22317: PUSH
22318: LD_INT 1
22320: PUSH
22321: LD_INT 53
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL 21106 0 2
// end ;
22334: LD_VAR 0 3
22338: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22339: LD_INT 0
22341: PPUSH
// CreateDepositXY ( x , y , t ) ;
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_VAR 0 2
22351: PPUSH
22352: LD_VAR 0 3
22356: PPUSH
22357: CALL_OW 62
// end ;
22361: LD_VAR 0 4
22365: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22366: LD_INT 0
22368: PPUSH
22369: PPUSH
// c := 1 ;
22370: LD_ADDR_VAR 0 5
22374: PUSH
22375: LD_INT 1
22377: ST_TO_ADDR
// case color of red :
22378: LD_VAR 0 3
22382: PUSH
22383: LD_STRING red
22385: DOUBLE
22386: EQUAL
22387: IFTRUE 22391
22389: GO 22402
22391: POP
// c = 1 ; dark-green :
22392: LD_ADDR_VAR 0 5
22396: PUSH
22397: LD_INT 1
22399: ST_TO_ADDR
22400: GO 22688
22402: LD_STRING dark-green
22404: DOUBLE
22405: EQUAL
22406: IFTRUE 22410
22408: GO 22421
22410: POP
// c = 2 ; purple :
22411: LD_ADDR_VAR 0 5
22415: PUSH
22416: LD_INT 2
22418: ST_TO_ADDR
22419: GO 22688
22421: LD_STRING purple
22423: DOUBLE
22424: EQUAL
22425: IFTRUE 22429
22427: GO 22440
22429: POP
// c = 3 ; aqua :
22430: LD_ADDR_VAR 0 5
22434: PUSH
22435: LD_INT 3
22437: ST_TO_ADDR
22438: GO 22688
22440: LD_STRING aqua
22442: DOUBLE
22443: EQUAL
22444: IFTRUE 22448
22446: GO 22459
22448: POP
// c = 4 ; grey :
22449: LD_ADDR_VAR 0 5
22453: PUSH
22454: LD_INT 4
22456: ST_TO_ADDR
22457: GO 22688
22459: LD_STRING grey
22461: DOUBLE
22462: EQUAL
22463: IFTRUE 22467
22465: GO 22478
22467: POP
// c = 5 ; lime :
22468: LD_ADDR_VAR 0 5
22472: PUSH
22473: LD_INT 5
22475: ST_TO_ADDR
22476: GO 22688
22478: LD_STRING lime
22480: DOUBLE
22481: EQUAL
22482: IFTRUE 22486
22484: GO 22497
22486: POP
// c = 6 ; tan :
22487: LD_ADDR_VAR 0 5
22491: PUSH
22492: LD_INT 6
22494: ST_TO_ADDR
22495: GO 22688
22497: LD_STRING tan
22499: DOUBLE
22500: EQUAL
22501: IFTRUE 22505
22503: GO 22516
22505: POP
// c = 7 ; pink :
22506: LD_ADDR_VAR 0 5
22510: PUSH
22511: LD_INT 7
22513: ST_TO_ADDR
22514: GO 22688
22516: LD_STRING pink
22518: DOUBLE
22519: EQUAL
22520: IFTRUE 22524
22522: GO 22535
22524: POP
// c = 8 ; green :
22525: LD_ADDR_VAR 0 5
22529: PUSH
22530: LD_INT 8
22532: ST_TO_ADDR
22533: GO 22688
22535: LD_STRING green
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22554
22543: POP
// c = 9 ; blue :
22544: LD_ADDR_VAR 0 5
22548: PUSH
22549: LD_INT 9
22551: ST_TO_ADDR
22552: GO 22688
22554: LD_STRING blue
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22573
22562: POP
// c = 10 ; yellow :
22563: LD_ADDR_VAR 0 5
22567: PUSH
22568: LD_INT 10
22570: ST_TO_ADDR
22571: GO 22688
22573: LD_STRING yellow
22575: DOUBLE
22576: EQUAL
22577: IFTRUE 22581
22579: GO 22592
22581: POP
// c = 11 ; brown :
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_INT 11
22589: ST_TO_ADDR
22590: GO 22688
22592: LD_STRING brown
22594: DOUBLE
22595: EQUAL
22596: IFTRUE 22600
22598: GO 22611
22600: POP
// c = 12 ; black :
22601: LD_ADDR_VAR 0 5
22605: PUSH
22606: LD_INT 12
22608: ST_TO_ADDR
22609: GO 22688
22611: LD_STRING black
22613: DOUBLE
22614: EQUAL
22615: IFTRUE 22619
22617: GO 22630
22619: POP
// c = 13 ; aqua2 :
22620: LD_ADDR_VAR 0 5
22624: PUSH
22625: LD_INT 13
22627: ST_TO_ADDR
22628: GO 22688
22630: LD_STRING aqua2
22632: DOUBLE
22633: EQUAL
22634: IFTRUE 22638
22636: GO 22649
22638: POP
// c = 14 ; orange :
22639: LD_ADDR_VAR 0 5
22643: PUSH
22644: LD_INT 14
22646: ST_TO_ADDR
22647: GO 22688
22649: LD_STRING orange
22651: DOUBLE
22652: EQUAL
22653: IFTRUE 22657
22655: GO 22668
22657: POP
// c = 15 ; white :
22658: LD_ADDR_VAR 0 5
22662: PUSH
22663: LD_INT 15
22665: ST_TO_ADDR
22666: GO 22688
22668: LD_STRING white
22670: DOUBLE
22671: EQUAL
22672: IFTRUE 22676
22674: GO 22687
22676: POP
// c = 16 ; end ;
22677: LD_ADDR_VAR 0 5
22681: PUSH
22682: LD_INT 16
22684: ST_TO_ADDR
22685: GO 22688
22687: POP
// if HexInfo ( x , y ) = 0 then
22688: LD_VAR 0 1
22692: PPUSH
22693: LD_VAR 0 2
22697: PPUSH
22698: CALL_OW 428
22702: PUSH
22703: LD_INT 0
22705: EQUAL
22706: IFFALSE 22730
// PlaceEnvironment ( x , y , 58 , c ) ;
22708: LD_VAR 0 1
22712: PPUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: LD_INT 58
22720: PPUSH
22721: LD_VAR 0 5
22725: PPUSH
22726: CALL_OW 349
// end ;
22730: LD_VAR 0 4
22734: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22735: LD_INT 0
22737: PPUSH
// RemoveEnvironment ( x , y ) ;
22738: LD_VAR 0 1
22742: PPUSH
22743: LD_VAR 0 2
22747: PPUSH
22748: CALL_OW 347
// end ;
22752: LD_VAR 0 3
22756: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22757: LD_INT 0
22759: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22760: LD_ADDR_VAR 0 5
22764: PUSH
22765: LD_INT 81
22767: PUSH
22768: LD_VAR 0 1
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: LD_INT 92
22779: PUSH
22780: LD_VAR 0 2
22784: PUSH
22785: LD_VAR 0 3
22789: PUSH
22790: LD_VAR 0 4
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: LIST
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PPUSH
22805: CALL_OW 69
22809: ST_TO_ADDR
// end ;
22810: LD_VAR 0 5
22814: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22815: LD_INT 0
22817: PPUSH
22818: PPUSH
22819: PPUSH
22820: PPUSH
22821: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22822: LD_VAR 0 1
22826: PPUSH
22827: LD_INT 81
22829: PUSH
22830: LD_VAR 0 1
22834: PPUSH
22835: CALL_OW 255
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PPUSH
22844: CALL_OW 69
22848: PPUSH
22849: LD_VAR 0 1
22853: PPUSH
22854: CALL_OW 74
22858: PPUSH
22859: CALL_OW 119
// dir := GetDir ( un ) ;
22863: LD_ADDR_VAR 0 4
22867: PUSH
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 254
22877: ST_TO_ADDR
// dir := dir - 3 ;
22878: LD_ADDR_VAR 0 4
22882: PUSH
22883: LD_VAR 0 4
22887: PUSH
22888: LD_INT 3
22890: MINUS
22891: ST_TO_ADDR
// if dir < 0 then
22892: LD_VAR 0 4
22896: PUSH
22897: LD_INT 0
22899: LESS
22900: IFFALSE 22916
// dir := dir + 6 ;
22902: LD_ADDR_VAR 0 4
22906: PUSH
22907: LD_VAR 0 4
22911: PUSH
22912: LD_INT 6
22914: PLUS
22915: ST_TO_ADDR
// while true do
22916: LD_INT 1
22918: IFFALSE 23415
// begin coord_dist := 3 ;
22920: LD_ADDR_VAR 0 3
22924: PUSH
22925: LD_INT 3
22927: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22928: LD_ADDR_VAR 0 5
22932: PUSH
22933: LD_VAR 0 1
22937: PPUSH
22938: CALL_OW 250
22942: PPUSH
22943: LD_VAR 0 4
22947: PPUSH
22948: LD_VAR 0 3
22952: PPUSH
22953: CALL_OW 272
22957: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22958: LD_ADDR_VAR 0 6
22962: PUSH
22963: LD_VAR 0 1
22967: PPUSH
22968: CALL_OW 251
22972: PPUSH
22973: LD_VAR 0 4
22977: PPUSH
22978: LD_VAR 0 3
22982: PPUSH
22983: CALL_OW 273
22987: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22988: LD_VAR 0 1
22992: PPUSH
22993: CALL_OW 255
22997: PPUSH
22998: LD_VAR 0 1
23002: PPUSH
23003: CALL_OW 250
23007: PPUSH
23008: LD_VAR 0 1
23012: PPUSH
23013: CALL_OW 251
23017: PPUSH
23018: LD_INT 14
23020: PPUSH
23021: CALL 22757 0 4
23025: PUSH
23026: LD_VAR 0 5
23030: PPUSH
23031: LD_VAR 0 6
23035: PPUSH
23036: CALL_OW 351
23040: OR
23041: PUSH
23042: LD_VAR 0 5
23046: PPUSH
23047: LD_VAR 0 6
23051: PPUSH
23052: CALL_OW 488
23056: PUSH
23057: LD_INT 0
23059: EQUAL
23060: OR
23061: PUSH
23062: LD_VAR 0 5
23066: PPUSH
23067: LD_VAR 0 6
23071: PPUSH
23072: CALL_OW 546
23076: PUSH
23077: LD_INT 1
23079: EQUAL
23080: OR
23081: PUSH
23082: LD_VAR 0 5
23086: PPUSH
23087: LD_VAR 0 6
23091: PPUSH
23092: CALL_OW 428
23096: PUSH
23097: LD_INT 0
23099: NONEQUAL
23100: OR
23101: IFFALSE 23329
// begin repeat begin Wait ( 0 0$0.3 ) ;
23103: LD_INT 10
23105: PPUSH
23106: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23110: LD_ADDR_VAR 0 3
23114: PUSH
23115: LD_VAR 0 3
23119: PUSH
23120: LD_INT 1
23122: PLUS
23123: ST_TO_ADDR
// dir := dir + 1 ;
23124: LD_ADDR_VAR 0 4
23128: PUSH
23129: LD_VAR 0 4
23133: PUSH
23134: LD_INT 1
23136: PLUS
23137: ST_TO_ADDR
// if dir > 5 then
23138: LD_VAR 0 4
23142: PUSH
23143: LD_INT 5
23145: GREATER
23146: IFFALSE 23156
// dir = 0 ;
23148: LD_ADDR_VAR 0 4
23152: PUSH
23153: LD_INT 0
23155: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23156: LD_ADDR_VAR 0 5
23160: PUSH
23161: LD_VAR 0 1
23165: PPUSH
23166: CALL_OW 250
23170: PPUSH
23171: LD_VAR 0 4
23175: PPUSH
23176: LD_VAR 0 3
23180: PPUSH
23181: CALL_OW 272
23185: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23186: LD_ADDR_VAR 0 6
23190: PUSH
23191: LD_VAR 0 1
23195: PPUSH
23196: CALL_OW 251
23200: PPUSH
23201: LD_VAR 0 4
23205: PPUSH
23206: LD_VAR 0 3
23210: PPUSH
23211: CALL_OW 273
23215: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23216: LD_VAR 0 1
23220: PPUSH
23221: CALL_OW 255
23225: PPUSH
23226: LD_VAR 0 1
23230: PPUSH
23231: CALL_OW 250
23235: PPUSH
23236: LD_VAR 0 1
23240: PPUSH
23241: CALL_OW 251
23245: PPUSH
23246: LD_INT 14
23248: PPUSH
23249: CALL 22757 0 4
23253: NOT
23254: PUSH
23255: LD_VAR 0 5
23259: PPUSH
23260: LD_VAR 0 6
23264: PPUSH
23265: CALL_OW 351
23269: NOT
23270: AND
23271: PUSH
23272: LD_VAR 0 5
23276: PPUSH
23277: LD_VAR 0 6
23281: PPUSH
23282: CALL_OW 488
23286: AND
23287: PUSH
23288: LD_VAR 0 5
23292: PPUSH
23293: LD_VAR 0 6
23297: PPUSH
23298: CALL_OW 546
23302: PUSH
23303: LD_INT 0
23305: EQUAL
23306: AND
23307: PUSH
23308: LD_VAR 0 5
23312: PPUSH
23313: LD_VAR 0 6
23317: PPUSH
23318: CALL_OW 428
23322: PUSH
23323: LD_INT 0
23325: EQUAL
23326: AND
23327: IFFALSE 23103
// end ; ComMoveXY ( un , x , y ) ;
23329: LD_VAR 0 1
23333: PPUSH
23334: LD_VAR 0 5
23338: PPUSH
23339: LD_VAR 0 6
23343: PPUSH
23344: CALL_OW 111
// Wait ( 0 0$1 ) ;
23348: LD_INT 35
23350: PPUSH
23351: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23355: LD_VAR 0 1
23359: PPUSH
23360: LD_INT 81
23362: PUSH
23363: LD_VAR 0 1
23367: PPUSH
23368: CALL_OW 255
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: PPUSH
23377: CALL_OW 69
23381: PPUSH
23382: LD_VAR 0 1
23386: PPUSH
23387: CALL_OW 74
23391: PPUSH
23392: CALL_OW 296
23396: PUSH
23397: LD_INT 14
23399: GREATEREQUAL
23400: IFFALSE 23413
// begin ComStop ( un ) ;
23402: LD_VAR 0 1
23406: PPUSH
23407: CALL_OW 141
// break ;
23411: GO 23415
// end ; end ;
23413: GO 22916
// end ;
23415: LD_VAR 0 2
23419: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23420: LD_INT 0
23422: PPUSH
23423: PPUSH
23424: PPUSH
23425: PPUSH
23426: PPUSH
23427: PPUSH
23428: PPUSH
23429: PPUSH
// x := GetX ( unit ) ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_VAR 0 1
23439: PPUSH
23440: CALL_OW 250
23444: ST_TO_ADDR
// y := GetY ( unit ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 1
23454: PPUSH
23455: CALL_OW 251
23459: ST_TO_ADDR
// i := 0 ;
23460: LD_ADDR_VAR 0 8
23464: PUSH
23465: LD_INT 0
23467: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23468: LD_VAR 0 1
23472: PPUSH
23473: LD_INT 81
23475: PUSH
23476: LD_VAR 0 1
23480: PPUSH
23481: CALL_OW 255
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PPUSH
23490: CALL_OW 69
23494: PPUSH
23495: LD_VAR 0 1
23499: PPUSH
23500: CALL_OW 74
23504: PPUSH
23505: CALL_OW 119
// dir := GetDir ( unit ) ;
23509: LD_ADDR_VAR 0 7
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 254
23523: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23524: LD_ADDR_VAR 0 9
23528: PUSH
23529: LD_INT 0
23531: PPUSH
23532: LD_INT 1
23534: PPUSH
23535: CALL_OW 12
23539: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23540: LD_INT 10
23542: PPUSH
23543: CALL_OW 67
// if mode then
23547: LD_VAR 0 9
23551: IFFALSE 23569
// dir := dir + 1 else
23553: LD_ADDR_VAR 0 7
23557: PUSH
23558: LD_VAR 0 7
23562: PUSH
23563: LD_INT 1
23565: PLUS
23566: ST_TO_ADDR
23567: GO 23583
// dir := dir - 1 ;
23569: LD_ADDR_VAR 0 7
23573: PUSH
23574: LD_VAR 0 7
23578: PUSH
23579: LD_INT 1
23581: MINUS
23582: ST_TO_ADDR
// if ( dir < 0 ) then
23583: LD_VAR 0 7
23587: PUSH
23588: LD_INT 0
23590: LESS
23591: IFFALSE 23601
// dir := 5 ;
23593: LD_ADDR_VAR 0 7
23597: PUSH
23598: LD_INT 5
23600: ST_TO_ADDR
// if ( dir > 5 ) then
23601: LD_VAR 0 7
23605: PUSH
23606: LD_INT 5
23608: GREATER
23609: IFFALSE 23619
// dir := 0 ;
23611: LD_ADDR_VAR 0 7
23615: PUSH
23616: LD_INT 0
23618: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23619: LD_ADDR_VAR 0 5
23623: PUSH
23624: LD_VAR 0 3
23628: PPUSH
23629: LD_VAR 0 7
23633: PPUSH
23634: LD_INT 4
23636: PPUSH
23637: CALL_OW 272
23641: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23642: LD_ADDR_VAR 0 6
23646: PUSH
23647: LD_VAR 0 4
23651: PPUSH
23652: LD_VAR 0 7
23656: PPUSH
23657: LD_INT 4
23659: PPUSH
23660: CALL_OW 273
23664: ST_TO_ADDR
// i := i + 1 ;
23665: LD_ADDR_VAR 0 8
23669: PUSH
23670: LD_VAR 0 8
23674: PUSH
23675: LD_INT 1
23677: PLUS
23678: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23679: LD_VAR 0 1
23683: PPUSH
23684: CALL_OW 255
23688: PPUSH
23689: LD_VAR 0 5
23693: PPUSH
23694: LD_VAR 0 6
23698: PPUSH
23699: LD_INT 14
23701: PPUSH
23702: CALL 22757 0 4
23706: PUSH
23707: LD_INT 0
23709: EQUAL
23710: PUSH
23711: LD_VAR 0 5
23715: PPUSH
23716: LD_VAR 0 6
23720: PPUSH
23721: CALL_OW 546
23725: PUSH
23726: LD_INT 0
23728: EQUAL
23729: AND
23730: PUSH
23731: LD_VAR 0 5
23735: PPUSH
23736: LD_VAR 0 6
23740: PPUSH
23741: CALL_OW 428
23745: PUSH
23746: LD_INT 0
23748: EQUAL
23749: AND
23750: IFFALSE 23754
// break ;
23752: GO 23764
// end until i > 4 ;
23754: LD_VAR 0 8
23758: PUSH
23759: LD_INT 4
23761: GREATER
23762: IFFALSE 23540
// if x2 and y2 then
23764: LD_VAR 0 5
23768: PUSH
23769: LD_VAR 0 6
23773: AND
23774: IFFALSE 23797
// result := [ x2 , y2 ] else
23776: LD_ADDR_VAR 0 2
23780: PUSH
23781: LD_VAR 0 5
23785: PUSH
23786: LD_VAR 0 6
23790: PUSH
23791: EMPTY
23792: LIST
23793: LIST
23794: ST_TO_ADDR
23795: GO 23826
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23797: LD_ADDR_VAR 0 2
23801: PUSH
23802: LD_VAR 0 1
23806: PPUSH
23807: CALL_OW 250
23811: PUSH
23812: LD_VAR 0 1
23816: PPUSH
23817: CALL_OW 251
23821: PUSH
23822: EMPTY
23823: LIST
23824: LIST
23825: ST_TO_ADDR
// end ;
23826: LD_VAR 0 2
23830: RET
// export function MCT_Hex ( x , y ) ; begin
23831: LD_INT 0
23833: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23834: LD_ADDR_VAR 0 3
23838: PUSH
23839: LD_VAR 0 1
23843: PPUSH
23844: LD_VAR 0 2
23848: PPUSH
23849: CALL_OW 546
23853: PUSH
23854: LD_VAR 0 1
23858: PPUSH
23859: LD_VAR 0 2
23863: PPUSH
23864: CALL_OW 428
23868: PUSH
23869: EMPTY
23870: LIST
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: ST_TO_ADDR
// end ;
23876: LD_VAR 0 3
23880: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23881: LD_INT 0
23883: PPUSH
23884: PPUSH
23885: PPUSH
23886: PPUSH
23887: PPUSH
23888: PPUSH
23889: PPUSH
23890: PPUSH
23891: PPUSH
23892: PPUSH
23893: PPUSH
23894: PPUSH
23895: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23896: LD_ADDR_VAR 0 10
23900: PUSH
23901: LD_EXP 62
23905: PUSH
23906: LD_VAR 0 1
23910: ARRAY
23911: PUSH
23912: LD_INT 1
23914: ARRAY
23915: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23916: LD_ADDR_VAR 0 11
23920: PUSH
23921: LD_EXP 62
23925: PUSH
23926: LD_VAR 0 1
23930: ARRAY
23931: PUSH
23932: LD_INT 2
23934: ARRAY
23935: ST_TO_ADDR
// collectors := [ ] ;
23936: LD_ADDR_VAR 0 12
23940: PUSH
23941: EMPTY
23942: ST_TO_ADDR
// is_cargo := false ;
23943: LD_ADDR_VAR 0 13
23947: PUSH
23948: LD_INT 0
23950: ST_TO_ADDR
// if isTest then
23951: LD_EXP 1
23955: IFFALSE 23961
// TimerStart ( ) ;
23957: CALL_OW 548
// if MCF_Cargo ( side ) then
23961: LD_VAR 0 1
23965: PPUSH
23966: CALL 11938 0 1
23970: IFFALSE 23997
// begin collectors := MCF_Cargo ( side ) ;
23972: LD_ADDR_VAR 0 12
23976: PUSH
23977: LD_VAR 0 1
23981: PPUSH
23982: CALL 11938 0 1
23986: ST_TO_ADDR
// is_cargo := true ;
23987: LD_ADDR_VAR 0 13
23991: PUSH
23992: LD_INT 1
23994: ST_TO_ADDR
// end else
23995: GO 24146
// begin if MCF_ApeSpec ( side , engineer ) then
23997: LD_VAR 0 1
24001: PPUSH
24002: LD_STRING engineer
24004: PPUSH
24005: CALL 12084 0 2
24009: IFFALSE 24029
// collectors := MCF_ApeSpec ( side , engineer ) ;
24011: LD_ADDR_VAR 0 12
24015: PUSH
24016: LD_VAR 0 1
24020: PPUSH
24021: LD_STRING engineer
24023: PPUSH
24024: CALL 12084 0 2
24028: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24029: LD_VAR 0 1
24033: PPUSH
24034: LD_INT 2
24036: PPUSH
24037: EMPTY
24038: PPUSH
24039: CALL 11670 0 3
24043: IFFALSE 24146
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24045: LD_ADDR_VAR 0 7
24049: PUSH
24050: LD_VAR 0 1
24054: PPUSH
24055: LD_INT 2
24057: PPUSH
24058: EMPTY
24059: PPUSH
24060: CALL 11670 0 3
24064: ST_TO_ADDR
// if z > 5 then
24065: LD_VAR 0 7
24069: PUSH
24070: LD_INT 5
24072: GREATER
24073: IFFALSE 24085
// t1 := 5 else
24075: LD_ADDR_VAR 0 8
24079: PUSH
24080: LD_INT 5
24082: ST_TO_ADDR
24083: GO 24095
// t1 := z ;
24085: LD_ADDR_VAR 0 8
24089: PUSH
24090: LD_VAR 0 7
24094: ST_TO_ADDR
// for t2 = 1 to t1 do
24095: LD_ADDR_VAR 0 9
24099: PUSH
24100: DOUBLE
24101: LD_INT 1
24103: DEC
24104: ST_TO_ADDR
24105: LD_VAR 0 8
24109: PUSH
24110: FOR_TO
24111: IFFALSE 24144
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24113: LD_ADDR_VAR 0 12
24117: PUSH
24118: LD_VAR 0 12
24122: PPUSH
24123: LD_INT 1
24125: PPUSH
24126: LD_VAR 0 7
24130: PUSH
24131: LD_VAR 0 9
24135: ARRAY
24136: PPUSH
24137: CALL_OW 2
24141: ST_TO_ADDR
24142: GO 24110
24144: POP
24145: POP
// end ; end ; if not mode then
24146: LD_VAR 0 10
24150: NOT
24151: IFFALSE 24157
// exit else
24153: GO 24416
24155: GO 24416
// begin if collectors then
24157: LD_VAR 0 12
24161: IFFALSE 24416
// for i in areas do
24163: LD_ADDR_VAR 0 3
24167: PUSH
24168: LD_VAR 0 11
24172: PUSH
24173: FOR_IN
24174: IFFALSE 24414
// if GetListOfCratesInArea ( i ) then
24176: LD_VAR 0 3
24180: PPUSH
24181: CALL_OW 435
24185: IFFALSE 24412
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24187: LD_ADDR_VAR 0 5
24191: PUSH
24192: LD_VAR 0 3
24196: PPUSH
24197: CALL_OW 435
24201: PUSH
24202: LD_INT 1
24204: ARRAY
24205: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24206: LD_ADDR_VAR 0 6
24210: PUSH
24211: LD_VAR 0 3
24215: PPUSH
24216: CALL_OW 435
24220: PUSH
24221: LD_INT 2
24223: ARRAY
24224: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24225: LD_VAR 0 13
24229: PUSH
24230: LD_VAR 0 12
24234: PUSH
24235: LD_INT 1
24237: ARRAY
24238: PPUSH
24239: CALL_OW 110
24243: PUSH
24244: LD_INT 0
24246: EQUAL
24247: AND
24248: IFFALSE 24310
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24250: LD_VAR 0 12
24254: PUSH
24255: LD_INT 1
24257: ARRAY
24258: PPUSH
24259: CALL_OW 314
24263: NOT
24264: PUSH
24265: LD_VAR 0 12
24269: PUSH
24270: LD_INT 1
24272: ARRAY
24273: PPUSH
24274: CALL_OW 110
24278: PUSH
24279: LD_INT 0
24281: EQUAL
24282: AND
24283: IFFALSE 24308
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24285: LD_VAR 0 12
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: LD_VAR 0 5
24298: PPUSH
24299: LD_VAR 0 6
24303: PPUSH
24304: CALL_OW 117
// end ; end else
24308: GO 24396
// begin for j = 1 to collectors do
24310: LD_ADDR_VAR 0 4
24314: PUSH
24315: DOUBLE
24316: LD_INT 1
24318: DEC
24319: ST_TO_ADDR
24320: LD_VAR 0 12
24324: PUSH
24325: FOR_TO
24326: IFFALSE 24394
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24328: LD_VAR 0 12
24332: PUSH
24333: LD_VAR 0 4
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_VAR 0 4
24354: ARRAY
24355: PPUSH
24356: CALL_OW 110
24360: PUSH
24361: LD_INT 0
24363: EQUAL
24364: AND
24365: IFFALSE 24392
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24367: LD_VAR 0 12
24371: PUSH
24372: LD_VAR 0 4
24376: ARRAY
24377: PPUSH
24378: LD_VAR 0 5
24382: PPUSH
24383: LD_VAR 0 6
24387: PPUSH
24388: CALL 24787 0 3
// end ;
24392: GO 24325
24394: POP
24395: POP
// end ; if isTest then
24396: LD_EXP 1
24400: IFFALSE 24412
// begin debug_time := TimerEnd ( ) ;
24402: LD_ADDR_VAR 0 14
24406: PUSH
24407: CALL_OW 549
24411: ST_TO_ADDR
// end ; end ;
24412: GO 24173
24414: POP
24415: POP
// end ; end ;
24416: LD_VAR 0 2
24420: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24421: LD_INT 0
24423: PPUSH
24424: PPUSH
24425: PPUSH
24426: PPUSH
24427: PPUSH
24428: PPUSH
// if not area then
24429: LD_VAR 0 1
24433: NOT
24434: IFFALSE 24440
// exit else
24436: GO 24702
24438: GO 24702
// if tick mod interval = 0 and Prob ( percent ) then
24440: LD_OWVAR 1
24444: PUSH
24445: LD_VAR 0 4
24449: MOD
24450: PUSH
24451: LD_INT 0
24453: EQUAL
24454: PUSH
24455: LD_VAR 0 3
24459: PPUSH
24460: CALL_OW 13
24464: AND
24465: IFFALSE 24702
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24467: LD_VAR 0 1
24471: PPUSH
24472: CALL_OW 435
24476: PUSH
24477: LD_VAR 0 5
24481: LESS
24482: PUSH
24483: LD_VAR 0 5
24487: PUSH
24488: LD_INT 0
24490: EQUAL
24491: OR
24492: IFFALSE 24702
// begin Randomize ;
24494: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24498: LD_ADDR_VAR 0 7
24502: PUSH
24503: LD_INT 1
24505: PPUSH
24506: LD_VAR 0 2
24510: PPUSH
24511: CALL_OW 12
24515: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24516: LD_ADDR_VAR 0 9
24520: PUSH
24521: LD_VAR 0 1
24525: PPUSH
24526: LD_INT 0
24528: PPUSH
24529: CALL_OW 517
24533: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24534: LD_ADDR_VAR 0 8
24538: PUSH
24539: LD_INT 1
24541: PPUSH
24542: LD_VAR 0 9
24546: PUSH
24547: LD_INT 1
24549: ARRAY
24550: PPUSH
24551: CALL_OW 12
24555: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24556: LD_VAR 0 9
24560: PUSH
24561: LD_INT 1
24563: ARRAY
24564: PUSH
24565: LD_VAR 0 8
24569: ARRAY
24570: PPUSH
24571: LD_VAR 0 9
24575: PUSH
24576: LD_INT 2
24578: ARRAY
24579: PUSH
24580: LD_VAR 0 8
24584: ARRAY
24585: PPUSH
24586: CALL_OW 428
24590: PUSH
24591: LD_INT 0
24593: GREATER
24594: PUSH
24595: LD_VAR 0 9
24599: PUSH
24600: LD_INT 1
24602: ARRAY
24603: PUSH
24604: LD_VAR 0 8
24608: ARRAY
24609: PPUSH
24610: LD_VAR 0 9
24614: PUSH
24615: LD_INT 2
24617: ARRAY
24618: PUSH
24619: LD_VAR 0 8
24623: ARRAY
24624: PPUSH
24625: CALL_OW 284
24629: PUSH
24630: LD_INT 0
24632: GREATER
24633: AND
24634: IFFALSE 24660
// c := Rand ( 1 , tmp [ 1 ] ) ;
24636: LD_ADDR_VAR 0 8
24640: PUSH
24641: LD_INT 1
24643: PPUSH
24644: LD_VAR 0 9
24648: PUSH
24649: LD_INT 1
24651: ARRAY
24652: PPUSH
24653: CALL_OW 12
24657: ST_TO_ADDR
24658: GO 24556
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24660: LD_VAR 0 7
24664: PPUSH
24665: LD_VAR 0 9
24669: PUSH
24670: LD_INT 1
24672: ARRAY
24673: PUSH
24674: LD_VAR 0 8
24678: ARRAY
24679: PPUSH
24680: LD_VAR 0 9
24684: PUSH
24685: LD_INT 2
24687: ARRAY
24688: PUSH
24689: LD_VAR 0 8
24693: ARRAY
24694: PPUSH
24695: LD_INT 1
24697: PPUSH
24698: CALL_OW 54
// end ; end ; end ;
24702: LD_VAR 0 6
24706: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24707: LD_INT 0
24709: PPUSH
24710: PPUSH
// if not MREG_Crates then
24711: LD_EXP 36
24715: NOT
24716: IFFALSE 24720
// exit ;
24718: GO 24782
// for i = MREG_Crates downto 1 do
24720: LD_ADDR_VAR 0 2
24724: PUSH
24725: DOUBLE
24726: LD_EXP 36
24730: INC
24731: ST_TO_ADDR
24732: LD_INT 1
24734: PUSH
24735: FOR_DOWNTO
24736: IFFALSE 24780
// if MREG_Crates [ i ] [ 3 ] = 0 then
24738: LD_EXP 36
24742: PUSH
24743: LD_VAR 0 2
24747: ARRAY
24748: PUSH
24749: LD_INT 3
24751: ARRAY
24752: PUSH
24753: LD_INT 0
24755: EQUAL
24756: IFFALSE 24778
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24758: LD_ADDR_EXP 36
24762: PUSH
24763: LD_EXP 36
24767: PPUSH
24768: LD_VAR 0 2
24772: PPUSH
24773: CALL_OW 3
24777: ST_TO_ADDR
24778: GO 24735
24780: POP
24781: POP
// end ;
24782: LD_VAR 0 1
24786: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
24791: PPUSH
24792: PPUSH
// if not unit then
24793: LD_VAR 0 1
24797: NOT
24798: IFFALSE 24802
// exit ;
24800: GO 24937
// if HasTask ( unit ) or not CanCarry ( unit ) then
24802: LD_VAR 0 1
24806: PPUSH
24807: CALL_OW 314
24811: PUSH
24812: LD_VAR 0 1
24816: PPUSH
24817: CALL_OW 280
24821: NOT
24822: OR
24823: IFFALSE 24827
// exit ;
24825: GO 24937
// side := GetSide ( unit ) ;
24827: LD_ADDR_VAR 0 6
24831: PUSH
24832: LD_VAR 0 1
24836: PPUSH
24837: CALL_OW 255
24841: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24842: LD_ADDR_VAR 0 7
24846: PUSH
24847: LD_VAR 0 6
24851: PPUSH
24852: LD_INT 30
24854: PUSH
24855: LD_INT 1
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PPUSH
24862: CALL 11587 0 2
24866: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24867: LD_VAR 0 1
24871: PPUSH
24872: CALL_OW 281
24876: PUSH
24877: LD_VAR 0 7
24881: NOT
24882: OR
24883: IFFALSE 24889
// exit else
24885: GO 24937
24887: GO 24937
// if GetResourceAmountXY ( x , y ) then
24889: LD_VAR 0 2
24893: PPUSH
24894: LD_VAR 0 3
24898: PPUSH
24899: CALL_OW 284
24903: IFFALSE 24935
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24905: LD_VAR 0 1
24909: PPUSH
24910: LD_VAR 0 2
24914: PPUSH
24915: LD_VAR 0 3
24919: PPUSH
24920: LD_VAR 0 7
24924: PUSH
24925: LD_INT 1
24927: ARRAY
24928: PPUSH
24929: CALL 31983 0 4
// end else
24933: GO 24937
// exit ;
24935: GO 24937
// end ;
24937: LD_VAR 0 4
24941: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24942: LD_INT 0
24944: PPUSH
24945: PPUSH
24946: PPUSH
24947: PPUSH
24948: PPUSH
// result := [ ] ;
24949: LD_ADDR_VAR 0 2
24953: PUSH
24954: EMPTY
24955: ST_TO_ADDR
// p := 1 ;
24956: LD_ADDR_VAR 0 4
24960: PUSH
24961: LD_INT 1
24963: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24964: LD_ADDR_VAR 0 3
24968: PUSH
24969: DOUBLE
24970: LD_INT 1
24972: DEC
24973: ST_TO_ADDR
24974: LD_EXP 65
24978: PUSH
24979: LD_VAR 0 1
24983: ARRAY
24984: PUSH
24985: LD_INT 1
24987: ARRAY
24988: PUSH
24989: LD_INT 2
24991: DIVREAL
24992: PUSH
24993: FOR_TO
24994: IFFALSE 25118
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24996: LD_ADDR_VAR 0 5
25000: PUSH
25001: LD_INT 81
25003: PUSH
25004: LD_VAR 0 1
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: LD_INT 92
25015: PUSH
25016: LD_EXP 65
25020: PUSH
25021: LD_VAR 0 1
25025: ARRAY
25026: PUSH
25027: LD_INT 1
25029: ARRAY
25030: PUSH
25031: LD_VAR 0 4
25035: ARRAY
25036: PUSH
25037: LD_EXP 65
25041: PUSH
25042: LD_VAR 0 1
25046: ARRAY
25047: PUSH
25048: LD_INT 1
25050: ARRAY
25051: PUSH
25052: LD_VAR 0 4
25056: PUSH
25057: LD_INT 1
25059: PLUS
25060: ARRAY
25061: PUSH
25062: LD_INT 12
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: LIST
25069: LIST
25070: PUSH
25071: EMPTY
25072: LIST
25073: LIST
25074: PPUSH
25075: CALL_OW 69
25079: ST_TO_ADDR
// if tmp then
25080: LD_VAR 0 5
25084: IFFALSE 25102
// result := result union tmp ;
25086: LD_ADDR_VAR 0 2
25090: PUSH
25091: LD_VAR 0 2
25095: PUSH
25096: LD_VAR 0 5
25100: UNION
25101: ST_TO_ADDR
// p := p + 2 ;
25102: LD_ADDR_VAR 0 4
25106: PUSH
25107: LD_VAR 0 4
25111: PUSH
25112: LD_INT 2
25114: PLUS
25115: ST_TO_ADDR
// end ;
25116: GO 24993
25118: POP
25119: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25120: LD_EXP 66
25124: PUSH
25125: LD_VAR 0 1
25129: ARRAY
25130: PPUSH
25131: LD_INT 81
25133: PUSH
25134: LD_VAR 0 1
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PPUSH
25143: CALL_OW 70
25147: IFFALSE 25188
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25149: LD_ADDR_VAR 0 2
25153: PUSH
25154: LD_VAR 0 2
25158: PUSH
25159: LD_EXP 66
25163: PUSH
25164: LD_VAR 0 1
25168: ARRAY
25169: PPUSH
25170: LD_INT 81
25172: PUSH
25173: LD_VAR 0 1
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PPUSH
25182: CALL_OW 70
25186: UNION
25187: ST_TO_ADDR
// end ; end_of_file
25188: LD_VAR 0 2
25192: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25193: LD_INT 0
25195: PPUSH
25196: PPUSH
25197: PPUSH
// pom := GetBase ( fac ) ;
25198: LD_ADDR_VAR 0 5
25202: PUSH
25203: LD_VAR 0 1
25207: PPUSH
25208: CALL_OW 274
25212: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25213: LD_ADDR_VAR 0 4
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_INT 1
25225: ARRAY
25226: PPUSH
25227: LD_VAR 0 2
25231: PUSH
25232: LD_INT 2
25234: ARRAY
25235: PPUSH
25236: LD_VAR 0 2
25240: PUSH
25241: LD_INT 3
25243: ARRAY
25244: PPUSH
25245: LD_VAR 0 2
25249: PUSH
25250: LD_INT 4
25252: ARRAY
25253: PPUSH
25254: CALL_OW 449
25258: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25259: LD_ADDR_VAR 0 3
25263: PUSH
25264: LD_VAR 0 5
25268: PPUSH
25269: LD_INT 1
25271: PPUSH
25272: CALL_OW 275
25276: PUSH
25277: LD_VAR 0 4
25281: PUSH
25282: LD_INT 1
25284: ARRAY
25285: GREATEREQUAL
25286: PUSH
25287: LD_VAR 0 5
25291: PPUSH
25292: LD_INT 2
25294: PPUSH
25295: CALL_OW 275
25299: PUSH
25300: LD_VAR 0 4
25304: PUSH
25305: LD_INT 2
25307: ARRAY
25308: GREATEREQUAL
25309: AND
25310: PUSH
25311: LD_VAR 0 5
25315: PPUSH
25316: LD_INT 3
25318: PPUSH
25319: CALL_OW 275
25323: PUSH
25324: LD_VAR 0 4
25328: PUSH
25329: LD_INT 3
25331: ARRAY
25332: GREATEREQUAL
25333: AND
25334: ST_TO_ADDR
// end ;
25335: LD_VAR 0 3
25339: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25340: LD_INT 0
25342: PPUSH
25343: PPUSH
25344: PPUSH
// result := false ;
25345: LD_ADDR_VAR 0 3
25349: PUSH
25350: LD_INT 0
25352: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25353: LD_ADDR_VAR 0 4
25357: PUSH
25358: LD_EXP 53
25362: PUSH
25363: LD_VAR 0 1
25367: ARRAY
25368: ST_TO_ADDR
// if tmp then
25369: LD_VAR 0 4
25373: IFFALSE 25427
// for i = 1 to tmp do
25375: LD_ADDR_VAR 0 5
25379: PUSH
25380: DOUBLE
25381: LD_INT 1
25383: DEC
25384: ST_TO_ADDR
25385: LD_VAR 0 4
25389: PUSH
25390: FOR_TO
25391: IFFALSE 25425
// if component = tmp [ i ] then
25393: LD_VAR 0 2
25397: PUSH
25398: LD_VAR 0 4
25402: PUSH
25403: LD_VAR 0 5
25407: ARRAY
25408: EQUAL
25409: IFFALSE 25423
// begin result := true ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// exit ;
25419: POP
25420: POP
25421: GO 25427
// end ;
25423: GO 25390
25425: POP
25426: POP
// end ;
25427: LD_VAR 0 3
25431: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25432: LD_INT 0
25434: PPUSH
25435: PPUSH
25436: PPUSH
// result := false ;
25437: LD_ADDR_VAR 0 4
25441: PUSH
25442: LD_INT 0
25444: ST_TO_ADDR
// if fac then
25445: LD_VAR 0 2
25449: IFFALSE 25672
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25451: LD_VAR 0 2
25455: PPUSH
25456: LD_VAR 0 3
25460: PPUSH
25461: CALL 25193 0 2
25465: PUSH
25466: LD_VAR 0 2
25470: PPUSH
25471: CALL_OW 461
25475: PUSH
25476: LD_INT 2
25478: EQUAL
25479: AND
25480: PUSH
25481: LD_VAR 0 2
25485: PPUSH
25486: LD_VAR 0 3
25490: PUSH
25491: LD_INT 1
25493: ARRAY
25494: PPUSH
25495: LD_VAR 0 3
25499: PUSH
25500: LD_INT 2
25502: ARRAY
25503: PPUSH
25504: LD_VAR 0 3
25508: PUSH
25509: LD_INT 3
25511: ARRAY
25512: PPUSH
25513: LD_VAR 0 3
25517: PUSH
25518: LD_INT 4
25520: ARRAY
25521: PPUSH
25522: CALL_OW 448
25526: AND
25527: IFFALSE 25672
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25529: LD_VAR 0 2
25533: PPUSH
25534: LD_VAR 0 3
25538: PUSH
25539: LD_INT 1
25541: ARRAY
25542: PPUSH
25543: LD_VAR 0 3
25547: PUSH
25548: LD_INT 2
25550: ARRAY
25551: PPUSH
25552: LD_VAR 0 3
25556: PUSH
25557: LD_INT 3
25559: ARRAY
25560: PPUSH
25561: LD_VAR 0 3
25565: PUSH
25566: LD_INT 4
25568: ARRAY
25569: PPUSH
25570: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25574: LD_ADDR_VAR 0 6
25578: PUSH
25579: LD_EXP 53
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: ST_TO_ADDR
// for i = 4 downto 1 do
25590: LD_ADDR_VAR 0 5
25594: PUSH
25595: DOUBLE
25596: LD_INT 4
25598: INC
25599: ST_TO_ADDR
25600: LD_INT 1
25602: PUSH
25603: FOR_DOWNTO
25604: IFFALSE 25637
// tab := Remove ( tab , list [ i ] , true ) ;
25606: LD_ADDR_VAR 0 6
25610: PUSH
25611: LD_VAR 0 6
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_VAR 0 5
25625: ARRAY
25626: PPUSH
25627: LD_INT 1
25629: PPUSH
25630: CALL 31211 0 3
25634: ST_TO_ADDR
25635: GO 25603
25637: POP
25638: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25639: LD_ADDR_EXP 53
25643: PUSH
25644: LD_EXP 53
25648: PPUSH
25649: LD_VAR 0 1
25653: PPUSH
25654: LD_VAR 0 6
25658: PPUSH
25659: CALL_OW 1
25663: ST_TO_ADDR
// result := true ;
25664: LD_ADDR_VAR 0 4
25668: PUSH
25669: LD_INT 1
25671: ST_TO_ADDR
// end ; end ; end ;
25672: LD_VAR 0 4
25676: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25677: LD_INT 0
25679: PPUSH
25680: PPUSH
// if not veh then
25681: LD_VAR 0 2
25685: NOT
25686: IFFALSE 25690
// exit ;
25688: GO 25864
// if MREG_Parking [ side ] then
25690: LD_EXP 60
25694: PUSH
25695: LD_VAR 0 1
25699: ARRAY
25700: IFFALSE 25864
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25702: LD_VAR 0 2
25706: PPUSH
25707: LD_EXP 60
25711: PUSH
25712: LD_VAR 0 1
25716: ARRAY
25717: PPUSH
25718: CALL_OW 308
25722: NOT
25723: IFFALSE 25864
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25725: LD_VAR 0 2
25729: PPUSH
25730: LD_EXP 60
25734: PUSH
25735: LD_VAR 0 1
25739: ARRAY
25740: PPUSH
25741: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25745: LD_VAR 0 2
25749: PPUSH
25750: CALL_OW 263
25754: PUSH
25755: LD_INT 1
25757: EQUAL
25758: IFFALSE 25864
// begin i := GetDriver ( veh ) ;
25760: LD_ADDR_VAR 0 4
25764: PUSH
25765: LD_VAR 0 2
25769: PPUSH
25770: CALL 31695 0 1
25774: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25775: LD_INT 35
25777: PPUSH
25778: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 60
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: PUSH
25803: LD_VAR 0 2
25807: PPUSH
25808: CALL_OW 301
25812: OR
25813: IFFALSE 25775
// ComExitVehicle ( i ) ;
25815: LD_VAR 0 4
25819: PPUSH
25820: CALL_OW 121
// Wait ( 1 ) ;
25824: LD_INT 1
25826: PPUSH
25827: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25831: LD_VAR 0 4
25835: PPUSH
25836: LD_VAR 0 1
25840: PPUSH
25841: LD_INT 30
25843: PUSH
25844: LD_INT 3
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PPUSH
25851: CALL 11587 0 2
25855: PUSH
25856: LD_INT 1
25858: ARRAY
25859: PPUSH
25860: CALL_OW 180
// end ; end ; end ;
25864: LD_VAR 0 3
25868: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25869: LD_INT 0
25871: PPUSH
25872: PPUSH
25873: PPUSH
25874: PPUSH
25875: PPUSH
25876: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25877: LD_VAR 0 1
25881: PPUSH
25882: LD_INT 30
25884: PUSH
25885: LD_INT 3
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PPUSH
25892: CALL 11587 0 2
25896: IFFALSE 26080
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25898: LD_VAR 0 1
25902: PPUSH
25903: LD_INT 30
25905: PUSH
25906: LD_INT 3
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL 11587 0 2
25917: PUSH
25918: LD_INT 1
25920: ARRAY
25921: PPUSH
25922: CALL_OW 461
25926: PUSH
25927: LD_INT 2
25929: EQUAL
25930: IFFALSE 26080
// begin for i = 1 to MREG_TurretWeapon do
25932: LD_ADDR_VAR 0 3
25936: PUSH
25937: DOUBLE
25938: LD_INT 1
25940: DEC
25941: ST_TO_ADDR
25942: LD_EXP 45
25946: PUSH
25947: FOR_TO
25948: IFFALSE 26078
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25950: LD_EXP 45
25954: PUSH
25955: LD_VAR 0 3
25959: ARRAY
25960: PUSH
25961: LD_INT 1
25963: ARRAY
25964: PUSH
25965: LD_VAR 0 1
25969: EQUAL
25970: IFFALSE 26076
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25972: LD_ADDR_VAR 0 5
25976: PUSH
25977: LD_EXP 45
25981: PUSH
25982: LD_VAR 0 3
25986: ARRAY
25987: PUSH
25988: LD_INT 2
25990: ARRAY
25991: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25992: LD_ADDR_VAR 0 6
25996: PUSH
25997: LD_EXP 45
26001: PUSH
26002: LD_VAR 0 3
26006: ARRAY
26007: PUSH
26008: LD_INT 3
26010: ARRAY
26011: PUSH
26012: LD_INT 1
26014: ARRAY
26015: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26016: LD_ADDR_VAR 0 7
26020: PUSH
26021: LD_EXP 45
26025: PUSH
26026: LD_VAR 0 3
26030: ARRAY
26031: PUSH
26032: LD_INT 3
26034: ARRAY
26035: PUSH
26036: LD_INT 2
26038: ARRAY
26039: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26040: LD_ADDR_VAR 0 4
26044: PUSH
26045: LD_VAR 0 6
26049: PPUSH
26050: LD_VAR 0 7
26054: PPUSH
26055: CALL_OW 428
26059: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26060: LD_VAR 0 4
26064: PPUSH
26065: LD_VAR 0 5
26069: PPUSH
26070: CALL_OW 148
// break ;
26074: GO 26078
// end ;
26076: GO 25947
26078: POP
26079: POP
// end ; end ;
26080: LD_VAR 0 2
26084: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26085: LD_INT 0
26087: PPUSH
26088: PPUSH
26089: PPUSH
26090: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26091: LD_ADDR_VAR 0 4
26095: PUSH
26096: LD_VAR 0 1
26100: PPUSH
26101: LD_INT 32
26103: PUSH
26104: LD_INT 1
26106: PUSH
26107: EMPTY
26108: LIST
26109: LIST
26110: PPUSH
26111: CALL 11587 0 2
26115: ST_TO_ADDR
// if not tmp then
26116: LD_VAR 0 4
26120: NOT
26121: IFFALSE 26127
// exit else
26123: GO 26209
26125: GO 26209
// begin for i = 1 to tmp do
26127: LD_ADDR_VAR 0 3
26131: PUSH
26132: DOUBLE
26133: LD_INT 1
26135: DEC
26136: ST_TO_ADDR
26137: LD_VAR 0 4
26141: PUSH
26142: FOR_TO
26143: IFFALSE 26207
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26145: LD_VAR 0 4
26149: PUSH
26150: LD_VAR 0 3
26154: ARRAY
26155: PPUSH
26156: CALL_OW 261
26160: PUSH
26161: LD_INT 20
26163: LESS
26164: PUSH
26165: LD_VAR 0 4
26169: PUSH
26170: LD_VAR 0 3
26174: ARRAY
26175: PPUSH
26176: CALL_OW 110
26180: PUSH
26181: LD_INT 0
26183: EQUAL
26184: AND
26185: IFFALSE 26205
// begin SetTag ( tmp [ i ] , 21 ) ;
26187: LD_VAR 0 4
26191: PUSH
26192: LD_VAR 0 3
26196: ARRAY
26197: PPUSH
26198: LD_INT 21
26200: PPUSH
26201: CALL_OW 109
// end ;
26205: GO 26142
26207: POP
26208: POP
// end ; end ;
26209: LD_VAR 0 2
26213: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26214: LD_INT 0
26216: PPUSH
26217: PPUSH
26218: PPUSH
26219: PPUSH
26220: PPUSH
// if not unit then
26221: LD_VAR 0 1
26225: NOT
26226: IFFALSE 26230
// exit ;
26228: GO 26418
// side := GetSide ( unit ) ;
26230: LD_ADDR_VAR 0 3
26234: PUSH
26235: LD_VAR 0 1
26239: PPUSH
26240: CALL_OW 255
26244: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26245: LD_ADDR_VAR 0 5
26249: PUSH
26250: LD_VAR 0 3
26254: PPUSH
26255: LD_INT 2
26257: PUSH
26258: LD_INT 30
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 30
26270: PUSH
26271: LD_INT 3
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: LD_INT 30
26280: PUSH
26281: LD_INT 29
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: PPUSH
26294: CALL 11587 0 2
26298: ST_TO_ADDR
// if not b then
26299: LD_VAR 0 5
26303: NOT
26304: IFFALSE 26308
// exit ;
26306: GO 26418
// if GetTag ( unit ) = 21 then
26308: LD_VAR 0 1
26312: PPUSH
26313: CALL_OW 110
26317: PUSH
26318: LD_INT 21
26320: EQUAL
26321: IFFALSE 26418
// begin c := NearestUnitToUnit ( b , unit ) ;
26323: LD_ADDR_VAR 0 6
26327: PUSH
26328: LD_VAR 0 5
26332: PPUSH
26333: LD_VAR 0 1
26337: PPUSH
26338: CALL_OW 74
26342: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26343: LD_VAR 0 1
26347: PPUSH
26348: LD_VAR 0 6
26352: PPUSH
26353: CALL_OW 250
26357: PPUSH
26358: LD_VAR 0 6
26362: PPUSH
26363: CALL_OW 251
26367: PPUSH
26368: CALL_OW 297
26372: PUSH
26373: LD_INT 6
26375: GREATER
26376: IFFALSE 26394
// ComMoveUnit ( unit , c ) else
26378: LD_VAR 0 1
26382: PPUSH
26383: LD_VAR 0 6
26387: PPUSH
26388: CALL_OW 112
26392: GO 26418
// begin SetFuel ( unit , 100 ) ;
26394: LD_VAR 0 1
26398: PPUSH
26399: LD_INT 100
26401: PPUSH
26402: CALL_OW 240
// SetTag ( unit , 0 ) ;
26406: LD_VAR 0 1
26410: PPUSH
26411: LD_INT 0
26413: PPUSH
26414: CALL_OW 109
// end ; end ; end ;
26418: LD_VAR 0 2
26422: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26423: LD_INT 0
26425: PPUSH
26426: PPUSH
26427: PPUSH
26428: PPUSH
26429: PPUSH
26430: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26431: LD_ADDR_VAR 0 7
26435: PUSH
26436: LD_VAR 0 1
26440: PPUSH
26441: LD_INT 33
26443: PUSH
26444: LD_INT 2
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 61
26456: PUSH
26457: EMPTY
26458: LIST
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PPUSH
26468: CALL 11587 0 2
26472: ST_TO_ADDR
// if not vehs then
26473: LD_VAR 0 7
26477: NOT
26478: IFFALSE 26482
// exit ;
26480: GO 26767
// if nation = 1 then
26482: LD_VAR 0 2
26486: PUSH
26487: LD_INT 1
26489: EQUAL
26490: IFFALSE 26660
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26492: LD_VAR 0 1
26496: PPUSH
26497: LD_INT 30
26499: PUSH
26500: LD_INT 36
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL 11587 0 2
26511: NOT
26512: IFFALSE 26518
// exit else
26514: GO 26767
26516: GO 26658
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26518: LD_ADDR_VAR 0 5
26522: PUSH
26523: LD_VAR 0 1
26527: PPUSH
26528: LD_INT 30
26530: PUSH
26531: LD_INT 36
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PPUSH
26538: CALL 11587 0 2
26542: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26543: LD_ADDR_VAR 0 6
26547: PUSH
26548: LD_VAR 0 5
26552: PUSH
26553: LD_INT 1
26555: ARRAY
26556: PPUSH
26557: CALL_OW 313
26561: ST_TO_ADDR
// for i = vehs downto 1 do
26562: LD_ADDR_VAR 0 4
26566: PUSH
26567: DOUBLE
26568: LD_VAR 0 7
26572: INC
26573: ST_TO_ADDR
26574: LD_INT 1
26576: PUSH
26577: FOR_DOWNTO
26578: IFFALSE 26656
// begin if not IsControledBy ( vehs [ i ] ) then
26580: LD_VAR 0 7
26584: PUSH
26585: LD_VAR 0 4
26589: ARRAY
26590: PPUSH
26591: CALL_OW 312
26595: NOT
26596: IFFALSE 26654
// begin tmp := MCV_RemoteDriver ( oper ) ;
26598: LD_ADDR_VAR 0 8
26602: PUSH
26603: LD_VAR 0 6
26607: PPUSH
26608: CALL 26772 0 1
26612: ST_TO_ADDR
// if not tmp then
26613: LD_VAR 0 8
26617: NOT
26618: IFFALSE 26626
// exit else
26620: POP
26621: POP
26622: GO 26767
26624: GO 26654
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26626: LD_VAR 0 7
26630: PUSH
26631: LD_VAR 0 4
26635: ARRAY
26636: PPUSH
26637: LD_VAR 0 8
26641: PUSH
26642: LD_INT 1
26644: ARRAY
26645: PUSH
26646: LD_INT 1
26648: ARRAY
26649: PPUSH
26650: CALL_OW 135
// end ; end ;
26654: GO 26577
26656: POP
26657: POP
// end ; end else
26658: GO 26767
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26660: LD_VAR 0 1
26664: PPUSH
26665: LD_INT 34
26667: PUSH
26668: LD_INT 31
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PPUSH
26675: CALL 11587 0 2
26679: NOT
26680: IFFALSE 26686
// exit else
26682: GO 26767
26684: GO 26767
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26686: LD_ADDR_VAR 0 5
26690: PUSH
26691: LD_VAR 0 1
26695: PPUSH
26696: LD_INT 34
26698: PUSH
26699: LD_INT 31
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PPUSH
26706: CALL 11587 0 2
26710: ST_TO_ADDR
// oper := [ ] ;
26711: LD_ADDR_VAR 0 6
26715: PUSH
26716: EMPTY
26717: ST_TO_ADDR
// for i = 1 to ct do
26718: LD_ADDR_VAR 0 4
26722: PUSH
26723: DOUBLE
26724: LD_INT 1
26726: DEC
26727: ST_TO_ADDR
26728: LD_VAR 0 5
26732: PUSH
26733: FOR_TO
26734: IFFALSE 26765
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26736: LD_ADDR_VAR 0 6
26740: PUSH
26741: LD_VAR 0 6
26745: PUSH
26746: LD_VAR 0 5
26750: PUSH
26751: LD_VAR 0 4
26755: ARRAY
26756: PPUSH
26757: CALL 31695 0 1
26761: ADD
26762: ST_TO_ADDR
26763: GO 26733
26765: POP
26766: POP
// end ; end ; end ;
26767: LD_VAR 0 3
26771: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26772: LD_INT 0
26774: PPUSH
26775: PPUSH
26776: PPUSH
26777: PPUSH
26778: PPUSH
26779: PPUSH
// if not drivers then
26780: LD_VAR 0 1
26784: NOT
26785: IFFALSE 26791
// exit else
26787: GO 27071
26789: GO 27071
// begin linked := [ ] ;
26791: LD_ADDR_VAR 0 5
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to drivers do
26798: LD_ADDR_VAR 0 3
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 1
26812: PUSH
26813: FOR_TO
26814: IFFALSE 27059
// begin if CanControl ( drivers [ i ] ) then
26816: LD_VAR 0 1
26820: PUSH
26821: LD_VAR 0 3
26825: ARRAY
26826: PPUSH
26827: CALL 32085 0 1
26831: IFFALSE 27057
// if i > 1 then
26833: LD_VAR 0 3
26837: PUSH
26838: LD_INT 1
26840: GREATER
26841: IFFALSE 27018
// begin m := false ;
26843: LD_ADDR_VAR 0 6
26847: PUSH
26848: LD_INT 0
26850: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26851: LD_ADDR_VAR 0 7
26855: PUSH
26856: LD_VAR 0 1
26860: PUSH
26861: LD_VAR 0 3
26865: ARRAY
26866: PPUSH
26867: CALL_OW 432
26871: ST_TO_ADDR
// for j = 1 to linked do
26872: LD_ADDR_VAR 0 4
26876: PUSH
26877: DOUBLE
26878: LD_INT 1
26880: DEC
26881: ST_TO_ADDR
26882: LD_VAR 0 5
26886: PUSH
26887: FOR_TO
26888: IFFALSE 26962
// begin if l < linked [ j ] [ 2 ] then
26890: LD_VAR 0 7
26894: PUSH
26895: LD_VAR 0 5
26899: PUSH
26900: LD_VAR 0 4
26904: ARRAY
26905: PUSH
26906: LD_INT 2
26908: ARRAY
26909: LESS
26910: IFFALSE 26960
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26912: LD_ADDR_VAR 0 5
26916: PUSH
26917: LD_VAR 0 5
26921: PPUSH
26922: LD_INT 1
26924: PPUSH
26925: LD_VAR 0 1
26929: PUSH
26930: LD_VAR 0 3
26934: ARRAY
26935: PUSH
26936: LD_VAR 0 7
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PPUSH
26945: CALL_OW 2
26949: ST_TO_ADDR
// m := true ;
26950: LD_ADDR_VAR 0 6
26954: PUSH
26955: LD_INT 1
26957: ST_TO_ADDR
// break ;
26958: GO 26962
// end ; end ;
26960: GO 26887
26962: POP
26963: POP
// if not m then
26964: LD_VAR 0 6
26968: NOT
26969: IFFALSE 27016
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26971: LD_ADDR_VAR 0 5
26975: PUSH
26976: LD_VAR 0 5
26980: PUSH
26981: LD_VAR 0 1
26985: PUSH
26986: LD_VAR 0 3
26990: ARRAY
26991: PUSH
26992: LD_VAR 0 1
26996: PUSH
26997: LD_VAR 0 3
27001: ARRAY
27002: PPUSH
27003: CALL_OW 432
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: EMPTY
27013: LIST
27014: ADD
27015: ST_TO_ADDR
// end else
27016: GO 27057
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27018: LD_ADDR_VAR 0 5
27022: PUSH
27023: LD_VAR 0 1
27027: PUSH
27028: LD_VAR 0 3
27032: ARRAY
27033: PUSH
27034: LD_VAR 0 1
27038: PUSH
27039: LD_VAR 0 3
27043: ARRAY
27044: PPUSH
27045: CALL_OW 432
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: ST_TO_ADDR
// end ;
27057: GO 26813
27059: POP
27060: POP
// result := linked ;
27061: LD_ADDR_VAR 0 2
27065: PUSH
27066: LD_VAR 0 5
27070: ST_TO_ADDR
// end ; end ;
27071: LD_VAR 0 2
27075: RET
// export function MCV_ToRepair ( unit ) ; begin
27076: LD_INT 0
27078: PPUSH
// if not unit then
27079: LD_VAR 0 1
27083: NOT
27084: IFFALSE 27088
// exit ;
27086: GO 27119
// SetTag ( unit , 6 ) ;
27088: LD_VAR 0 1
27092: PPUSH
27093: LD_INT 6
27095: PPUSH
27096: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27100: LD_VAR 0 1
27104: PPUSH
27105: CALL_OW 255
27109: PPUSH
27110: LD_VAR 0 1
27114: PPUSH
27115: CALL 25677 0 2
// end ;
27119: LD_VAR 0 2
27123: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27124: LD_INT 0
27126: PPUSH
27127: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27128: LD_VAR 0 1
27132: PPUSH
27133: LD_INT 6
27135: PPUSH
27136: EMPTY
27137: PPUSH
27138: CALL 12290 0 3
27142: IFFALSE 27235
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27144: LD_ADDR_VAR 0 3
27148: PUSH
27149: DOUBLE
27150: LD_VAR 0 1
27154: PPUSH
27155: LD_INT 6
27157: PPUSH
27158: EMPTY
27159: PPUSH
27160: CALL 12290 0 3
27164: INC
27165: ST_TO_ADDR
27166: LD_INT 1
27168: PUSH
27169: FOR_DOWNTO
27170: IFFALSE 27233
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27172: LD_VAR 0 1
27176: PPUSH
27177: LD_INT 6
27179: PPUSH
27180: EMPTY
27181: PPUSH
27182: CALL 12290 0 3
27186: PUSH
27187: LD_VAR 0 3
27191: ARRAY
27192: PPUSH
27193: CALL_OW 256
27197: PUSH
27198: LD_INT 1000
27200: EQUAL
27201: IFFALSE 27231
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27203: LD_VAR 0 1
27207: PPUSH
27208: LD_INT 6
27210: PPUSH
27211: EMPTY
27212: PPUSH
27213: CALL 12290 0 3
27217: PUSH
27218: LD_VAR 0 3
27222: ARRAY
27223: PPUSH
27224: LD_INT 0
27226: PPUSH
27227: CALL_OW 109
27231: GO 27169
27233: POP
27234: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27235: LD_VAR 0 1
27239: PPUSH
27240: LD_INT 10
27242: PPUSH
27243: EMPTY
27244: PPUSH
27245: CALL 12290 0 3
27249: IFFALSE 27366
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27251: LD_ADDR_VAR 0 3
27255: PUSH
27256: DOUBLE
27257: LD_VAR 0 1
27261: PPUSH
27262: LD_INT 10
27264: PPUSH
27265: EMPTY
27266: PPUSH
27267: CALL 12290 0 3
27271: INC
27272: ST_TO_ADDR
27273: LD_INT 1
27275: PUSH
27276: FOR_DOWNTO
27277: IFFALSE 27364
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27279: LD_VAR 0 1
27283: PPUSH
27284: LD_INT 10
27286: PPUSH
27287: EMPTY
27288: PPUSH
27289: CALL 12290 0 3
27293: PUSH
27294: LD_VAR 0 3
27298: ARRAY
27299: PPUSH
27300: CALL_OW 302
27304: NOT
27305: PUSH
27306: LD_VAR 0 1
27310: PPUSH
27311: LD_INT 10
27313: PPUSH
27314: EMPTY
27315: PPUSH
27316: CALL 12290 0 3
27320: PUSH
27321: LD_VAR 0 3
27325: ARRAY
27326: PPUSH
27327: CALL_OW 301
27331: OR
27332: IFFALSE 27362
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27334: LD_VAR 0 1
27338: PPUSH
27339: LD_INT 10
27341: PPUSH
27342: EMPTY
27343: PPUSH
27344: CALL 12290 0 3
27348: PUSH
27349: LD_VAR 0 3
27353: ARRAY
27354: PPUSH
27355: LD_INT 0
27357: PPUSH
27358: CALL_OW 109
27362: GO 27276
27364: POP
27365: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27366: LD_ADDR_VAR 0 3
27370: PUSH
27371: LD_VAR 0 1
27375: PPUSH
27376: EMPTY
27377: PPUSH
27378: CALL 11888 0 2
27382: PUSH
27383: LD_VAR 0 1
27387: PPUSH
27388: LD_INT 7
27390: PPUSH
27391: EMPTY
27392: PPUSH
27393: CALL 12290 0 3
27397: DIFF
27398: PUSH
27399: FOR_IN
27400: IFFALSE 27444
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27402: LD_VAR 0 3
27406: PPUSH
27407: CALL_OW 256
27411: PUSH
27412: LD_INT 650
27414: LESS
27415: PUSH
27416: LD_VAR 0 3
27420: PPUSH
27421: CALL_OW 110
27425: PUSH
27426: LD_INT 6
27428: EQUAL
27429: NOT
27430: AND
27431: IFFALSE 27442
// MCV_ToRepair ( i ) ;
27433: LD_VAR 0 3
27437: PPUSH
27438: CALL 27076 0 1
27442: GO 27399
27444: POP
27445: POP
// end ; end_of_file end_of_file
27446: LD_VAR 0 2
27450: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27451: LD_STRING SAILEvent [
27453: PUSH
27454: LD_VAR 0 1
27458: STR
27459: PUSH
27460: LD_STRING ]
27462: STR
27463: PPUSH
27464: CALL 7984 0 1
// if event = 101 and dialog_north then
27468: LD_VAR 0 1
27472: PUSH
27473: LD_INT 101
27475: EQUAL
27476: PUSH
27477: LD_EXP 6
27481: AND
27482: IFFALSE 27546
// begin dialog_north := false ;
27484: LD_ADDR_EXP 6
27488: PUSH
27489: LD_INT 0
27491: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27492: LD_EXP 5
27496: PPUSH
27497: LD_STRING DS1
27499: PUSH
27500: LD_STRING DS2
27502: PUSH
27503: LD_STRING DS3
27505: PUSH
27506: LD_STRING DS6
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: PUSH
27515: LD_INT 1
27517: PPUSH
27518: LD_INT 4
27520: PPUSH
27521: CALL_OW 12
27525: ARRAY
27526: PPUSH
27527: CALL_OW 94
// Wait ( 4 4$00 ) ;
27531: LD_INT 8400
27533: PPUSH
27534: CALL_OW 67
// dialog_north := true ;
27538: LD_ADDR_EXP 6
27542: PUSH
27543: LD_INT 1
27545: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27546: LD_VAR 0 1
27550: PUSH
27551: LD_INT 102
27553: EQUAL
27554: PUSH
27555: LD_EXP 7
27559: AND
27560: IFFALSE 27620
// begin dialog_south := false ;
27562: LD_ADDR_EXP 7
27566: PUSH
27567: LD_INT 0
27569: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27570: LD_EXP 4
27574: PPUSH
27575: LD_STRING DJ1
27577: PUSH
27578: LD_STRING DJ4
27580: PUSH
27581: LD_STRING DJ6
27583: PUSH
27584: EMPTY
27585: LIST
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PPUSH
27592: LD_INT 3
27594: PPUSH
27595: CALL_OW 12
27599: ARRAY
27600: PPUSH
27601: CALL_OW 94
// Wait ( 4 4$00 ) ;
27605: LD_INT 8400
27607: PPUSH
27608: CALL_OW 67
// dialog_south := true ;
27612: LD_ADDR_EXP 7
27616: PUSH
27617: LD_INT 1
27619: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27620: LD_VAR 0 1
27624: PUSH
27625: LD_INT 104
27627: EQUAL
27628: PUSH
27629: LD_EXP 8
27633: AND
27634: IFFALSE 27656
// begin dialog_popov := false ;
27636: LD_ADDR_EXP 8
27640: PUSH
27641: LD_INT 0
27643: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27644: LD_EXP 26
27648: PPUSH
27649: LD_STRING DR4
27651: PPUSH
27652: CALL_OW 94
// end ; end ;
27656: PPOPN 1
27658: END
// on BuildingStarted ( b , unit ) do var side , i ;
27659: LD_INT 0
27661: PPUSH
27662: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27663: LD_EXP 41
27667: PUSH
27668: LD_VAR 0 1
27672: PPUSH
27673: CALL_OW 255
27677: ARRAY
27678: IFFALSE 27856
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27680: LD_STRING BuildingStarted [side: 
27682: PUSH
27683: LD_VAR 0 1
27687: PPUSH
27688: CALL_OW 255
27692: STR
27693: PUSH
27694: LD_STRING ; btype: 
27696: STR
27697: PUSH
27698: LD_VAR 0 1
27702: PPUSH
27703: CALL_OW 266
27707: STR
27708: PUSH
27709: LD_STRING ; unit: 
27711: STR
27712: PUSH
27713: LD_VAR 0 2
27717: STR
27718: PUSH
27719: LD_STRING ]
27721: STR
27722: PPUSH
27723: CALL 7984 0 1
// side := GetSide ( b ) ;
27727: LD_ADDR_VAR 0 3
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27742: LD_VAR 0 3
27746: PPUSH
27747: LD_INT 21
27749: PUSH
27750: LD_INT 3
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PPUSH
27757: CALL 11587 0 2
27761: PUSH
27762: LD_INT 1
27764: EQUAL
27765: IFFALSE 27856
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27767: LD_ADDR_VAR 0 4
27771: PUSH
27772: LD_VAR 0 3
27776: PPUSH
27777: LD_INT 21
27779: PUSH
27780: LD_INT 1
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PPUSH
27787: CALL 11587 0 2
27791: PUSH
27792: LD_VAR 0 3
27796: PPUSH
27797: LD_INT 2
27799: PPUSH
27800: EMPTY
27801: PPUSH
27802: CALL 11670 0 3
27806: DIFF
27807: PUSH
27808: FOR_IN
27809: IFFALSE 27854
// if not HasTask ( i ) then
27811: LD_VAR 0 4
27815: PPUSH
27816: CALL_OW 314
27820: NOT
27821: IFFALSE 27852
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27823: LD_VAR 0 4
27827: PPUSH
27828: LD_VAR 0 1
27832: PPUSH
27833: CALL_OW 250
27837: PPUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 251
27847: PPUSH
27848: CALL_OW 111
27852: GO 27808
27854: POP
27855: POP
// end ;
27856: PPOPN 4
27858: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27859: LD_EXP 41
27863: PUSH
27864: LD_VAR 0 1
27868: PPUSH
27869: CALL_OW 255
27873: ARRAY
27874: IFFALSE 28243
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27876: LD_STRING BuildingComplete [side: 
27878: PUSH
27879: LD_VAR 0 1
27883: PPUSH
27884: CALL_OW 255
27888: STR
27889: PUSH
27890: LD_STRING ; btype: 
27892: STR
27893: PUSH
27894: LD_VAR 0 1
27898: PPUSH
27899: CALL_OW 266
27903: STR
27904: PUSH
27905: LD_STRING ]
27907: STR
27908: PPUSH
27909: CALL 7984 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27913: LD_ADDR_EXP 48
27917: PUSH
27918: LD_EXP 48
27922: PPUSH
27923: LD_VAR 0 1
27927: PPUSH
27928: CALL_OW 255
27932: PPUSH
27933: LD_VAR 0 1
27937: PPUSH
27938: CALL_OW 266
27942: PPUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 250
27952: PUSH
27953: LD_VAR 0 1
27957: PPUSH
27958: CALL_OW 251
27962: PUSH
27963: LD_VAR 0 1
27967: PPUSH
27968: CALL_OW 254
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: LIST
27977: PPUSH
27978: CALL 41973 0 4
27982: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27983: LD_VAR 0 1
27987: PPUSH
27988: CALL_OW 266
27992: PUSH
27993: LD_INT 6
27995: EQUAL
27996: IFFALSE 28030
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27998: LD_ADDR_EXP 42
28002: PUSH
28003: LD_EXP 42
28007: PPUSH
28008: LD_VAR 0 1
28012: PPUSH
28013: CALL_OW 255
28017: PPUSH
28018: LD_VAR 0 1
28022: PPUSH
28023: EMPTY
28024: PPUSH
28025: CALL 41882 0 4
28029: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28030: LD_VAR 0 1
28034: PPUSH
28035: CALL_OW 266
28039: PUSH
28040: LD_INT 0
28042: EQUAL
28043: IFFALSE 28153
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28045: LD_ADDR_EXP 50
28049: PUSH
28050: LD_EXP 50
28054: PPUSH
28055: LD_VAR 0 1
28059: PPUSH
28060: CALL_OW 255
28064: PPUSH
28065: LD_INT 0
28067: PPUSH
28068: EMPTY
28069: PPUSH
28070: CALL 41882 0 4
28074: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28075: LD_VAR 0 1
28079: PPUSH
28080: CALL_OW 274
28084: PPUSH
28085: LD_INT 1
28087: PPUSH
28088: LD_EXP 74
28092: PUSH
28093: LD_INT 1
28095: ARRAY
28096: PPUSH
28097: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28101: LD_VAR 0 1
28105: PPUSH
28106: CALL_OW 274
28110: PPUSH
28111: LD_INT 2
28113: PPUSH
28114: LD_EXP 74
28118: PUSH
28119: LD_INT 2
28121: ARRAY
28122: PPUSH
28123: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28127: LD_VAR 0 1
28131: PPUSH
28132: CALL_OW 274
28136: PPUSH
28137: LD_INT 3
28139: PPUSH
28140: LD_EXP 74
28144: PUSH
28145: LD_INT 3
28147: ARRAY
28148: PPUSH
28149: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28153: LD_VAR 0 1
28157: PPUSH
28158: CALL_OW 266
28162: PUSH
28163: LD_INT 2
28165: EQUAL
28166: IFFALSE 28198
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28168: LD_ADDR_EXP 50
28172: PUSH
28173: LD_EXP 50
28177: PPUSH
28178: LD_VAR 0 1
28182: PPUSH
28183: CALL_OW 255
28187: PPUSH
28188: LD_INT 2
28190: PPUSH
28191: EMPTY
28192: PPUSH
28193: CALL 41882 0 4
28197: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28198: LD_VAR 0 1
28202: PPUSH
28203: CALL_OW 266
28207: PUSH
28208: LD_INT 4
28210: EQUAL
28211: IFFALSE 28243
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28213: LD_ADDR_EXP 50
28217: PUSH
28218: LD_EXP 50
28222: PPUSH
28223: LD_VAR 0 1
28227: PPUSH
28228: CALL_OW 255
28232: PPUSH
28233: LD_INT 4
28235: PPUSH
28236: EMPTY
28237: PPUSH
28238: CALL 41882 0 4
28242: ST_TO_ADDR
// end ;
28243: PPOPN 1
28245: END
// on ResearchComplete ( tech , lab ) do var i ;
28246: LD_INT 0
28248: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28249: LD_EXP 41
28253: PUSH
28254: LD_VAR 0 2
28258: PPUSH
28259: CALL_OW 255
28263: ARRAY
28264: IFFALSE 28548
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28266: LD_STRING ResearchComplete [side: 
28268: PUSH
28269: LD_VAR 0 2
28273: PPUSH
28274: CALL_OW 255
28278: PPUSH
28279: CALL_OW 255
28283: STR
28284: PUSH
28285: LD_STRING ; tech:
28287: STR
28288: PUSH
28289: LD_VAR 0 1
28293: STR
28294: PUSH
28295: LD_STRING ]
28297: STR
28298: PPUSH
28299: CALL 7984 0 1
// for i = 1 to MREG_ToRes do
28303: LD_ADDR_VAR 0 3
28307: PUSH
28308: DOUBLE
28309: LD_INT 1
28311: DEC
28312: ST_TO_ADDR
28313: LD_EXP 52
28317: PUSH
28318: FOR_TO
28319: IFFALSE 28406
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28321: LD_EXP 52
28325: PUSH
28326: LD_VAR 0 3
28330: ARRAY
28331: PUSH
28332: LD_INT 1
28334: ARRAY
28335: PUSH
28336: LD_VAR 0 2
28340: PPUSH
28341: CALL_OW 255
28345: EQUAL
28346: PUSH
28347: LD_EXP 52
28351: PUSH
28352: LD_VAR 0 3
28356: ARRAY
28357: PUSH
28358: LD_INT 2
28360: ARRAY
28361: PUSH
28362: LD_VAR 0 1
28366: EQUAL
28367: AND
28368: IFFALSE 28404
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28370: LD_ADDR_EXP 52
28374: PUSH
28375: LD_EXP 52
28379: PPUSH
28380: LD_VAR 0 2
28384: PPUSH
28385: CALL_OW 255
28389: PPUSH
28390: LD_VAR 0 1
28394: PPUSH
28395: EMPTY
28396: PPUSH
28397: CALL 41973 0 4
28401: ST_TO_ADDR
// break ;
28402: GO 28406
// end ;
28404: GO 28318
28406: POP
28407: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28408: LD_VAR 0 1
28412: PUSH
28413: LD_INT 2
28415: PUSH
28416: LD_INT 11
28418: PUSH
28419: LD_INT 4
28421: PUSH
28422: LD_INT 3
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: IN
28431: IFFALSE 28548
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28433: LD_ADDR_VAR 0 3
28437: PUSH
28438: LD_VAR 0 2
28442: PPUSH
28443: CALL_OW 255
28447: PPUSH
28448: LD_INT 16
28450: PPUSH
28451: LD_INT 25
28453: PUSH
28454: LD_INT 4
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PPUSH
28461: CALL 12290 0 3
28465: ST_TO_ADDR
// if i then
28466: LD_VAR 0 3
28470: IFFALSE 28488
// SetTag ( i [ 1 ] , 0 ) ;
28472: LD_VAR 0 3
28476: PUSH
28477: LD_INT 1
28479: ARRAY
28480: PPUSH
28481: LD_INT 0
28483: PPUSH
28484: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28488: LD_ADDR_VAR 0 3
28492: PUSH
28493: LD_VAR 0 2
28497: PPUSH
28498: CALL_OW 255
28502: PPUSH
28503: LD_INT 171
28505: PPUSH
28506: EMPTY
28507: PPUSH
28508: CALL 12290 0 3
28512: ST_TO_ADDR
// if i then
28513: LD_VAR 0 3
28517: IFFALSE 28548
// begin SetTag ( i [ 1 ] , 0 ) ;
28519: LD_VAR 0 3
28523: PUSH
28524: LD_INT 1
28526: ARRAY
28527: PPUSH
28528: LD_INT 0
28530: PPUSH
28531: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28535: LD_VAR 0 3
28539: PUSH
28540: LD_INT 1
28542: ARRAY
28543: PPUSH
28544: CALL_OW 122
// end ; end ; end ;
28548: PPOPN 3
28550: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28551: LD_INT 0
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
28559: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28560: LD_EXP 41
28564: PUSH
28565: LD_VAR 0 2
28569: PPUSH
28570: CALL_OW 255
28574: ARRAY
28575: IFFALSE 29302
// begin side := GetSide ( veh ) ;
28577: LD_ADDR_VAR 0 4
28581: PUSH
28582: LD_VAR 0 1
28586: PPUSH
28587: CALL_OW 255
28591: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28592: LD_ADDR_VAR 0 6
28596: PUSH
28597: LD_VAR 0 1
28601: PPUSH
28602: CALL_OW 265
28606: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28607: LD_ADDR_VAR 0 7
28611: PUSH
28612: LD_VAR 0 1
28616: PPUSH
28617: CALL_OW 262
28621: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28622: LD_ADDR_VAR 0 8
28626: PUSH
28627: LD_VAR 0 1
28631: PPUSH
28632: CALL_OW 263
28636: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28637: LD_ADDR_VAR 0 9
28641: PUSH
28642: LD_VAR 0 1
28646: PPUSH
28647: CALL_OW 264
28651: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28652: LD_STRING VehicleConstructed [side: 
28654: PUSH
28655: LD_VAR 0 4
28659: STR
28660: PUSH
28661: LD_STRING ; id:
28663: STR
28664: PUSH
28665: LD_VAR 0 1
28669: STR
28670: PUSH
28671: LD_STRING ; components: [
28673: STR
28674: PUSH
28675: LD_VAR 0 6
28679: STR
28680: PUSH
28681: LD_STRING , 
28683: STR
28684: PUSH
28685: LD_VAR 0 7
28689: STR
28690: PUSH
28691: LD_STRING , 
28693: STR
28694: PUSH
28695: LD_VAR 0 8
28699: STR
28700: PUSH
28701: LD_STRING , 
28703: STR
28704: PUSH
28705: LD_VAR 0 9
28709: STR
28710: PUSH
28711: LD_STRING ]]
28713: STR
28714: PPUSH
28715: CALL 7984 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28719: LD_VAR 0 1
28723: PPUSH
28724: CALL_OW 264
28728: PUSH
28729: LD_INT 13
28731: PUSH
28732: LD_INT 12
28734: PUSH
28735: LD_INT 14
28737: PUSH
28738: LD_INT 51
28740: PUSH
28741: LD_INT 53
28743: PUSH
28744: LD_INT 52
28746: PUSH
28747: LD_INT 32
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: IN
28759: NOT
28760: IFFALSE 28802
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28762: LD_ADDR_EXP 61
28766: PUSH
28767: LD_EXP 61
28771: PPUSH
28772: LD_VAR 0 4
28776: PPUSH
28777: LD_EXP 61
28781: PUSH
28782: LD_VAR 0 4
28786: ARRAY
28787: PUSH
28788: LD_INT 1
28790: PLUS
28791: PPUSH
28792: LD_VAR 0 1
28796: PPUSH
28797: CALL 31052 0 4
28801: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28802: LD_VAR 0 1
28806: PPUSH
28807: CALL_OW 264
28811: PUSH
28812: LD_INT 31
28814: EQUAL
28815: IFFALSE 28834
// SetTag ( GetDriver ( veh ) , 9 ) ;
28817: LD_VAR 0 1
28821: PPUSH
28822: CALL 31695 0 1
28826: PPUSH
28827: LD_INT 9
28829: PPUSH
28830: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28834: LD_VAR 0 1
28838: PPUSH
28839: CALL_OW 264
28843: PUSH
28844: LD_INT 14
28846: PUSH
28847: LD_INT 53
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: IN
28854: IFFALSE 28891
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28856: LD_ADDR_EXP 44
28860: PUSH
28861: LD_EXP 44
28865: PPUSH
28866: LD_VAR 0 1
28870: PPUSH
28871: CALL_OW 255
28875: PPUSH
28876: LD_INT 2
28878: PPUSH
28879: LD_VAR 0 1
28883: PPUSH
28884: CALL 31052 0 4
28888: ST_TO_ADDR
// exit ;
28889: GO 29302
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28891: LD_VAR 0 1
28895: PPUSH
28896: CALL_OW 265
28900: PUSH
28901: LD_EXP 68
28905: PUSH
28906: LD_VAR 0 4
28910: ARRAY
28911: PUSH
28912: LD_INT 1
28914: ARRAY
28915: IN
28916: PUSH
28917: LD_VAR 0 1
28921: PPUSH
28922: CALL_OW 262
28926: PUSH
28927: LD_EXP 68
28931: PUSH
28932: LD_VAR 0 4
28936: ARRAY
28937: PUSH
28938: LD_INT 1
28940: ARRAY
28941: IN
28942: AND
28943: PUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 263
28953: PUSH
28954: LD_EXP 68
28958: PUSH
28959: LD_VAR 0 4
28963: ARRAY
28964: PUSH
28965: LD_INT 1
28967: ARRAY
28968: IN
28969: AND
28970: PUSH
28971: LD_VAR 0 1
28975: PPUSH
28976: CALL_OW 264
28980: PUSH
28981: LD_EXP 68
28985: PUSH
28986: LD_VAR 0 4
28990: ARRAY
28991: PUSH
28992: LD_INT 1
28994: ARRAY
28995: IN
28996: AND
28997: IFFALSE 29041
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28999: LD_ADDR_EXP 69
29003: PUSH
29004: LD_EXP 69
29008: PPUSH
29009: LD_VAR 0 4
29013: PPUSH
29014: LD_EXP 69
29018: PUSH
29019: LD_VAR 0 4
29023: ARRAY
29024: PUSH
29025: LD_INT 1
29027: PLUS
29028: PPUSH
29029: LD_VAR 0 1
29033: PPUSH
29034: CALL 31052 0 4
29038: ST_TO_ADDR
// exit ;
29039: GO 29302
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29041: LD_VAR 0 6
29045: PUSH
29046: LD_EXP 71
29050: PUSH
29051: LD_VAR 0 4
29055: ARRAY
29056: PUSH
29057: LD_INT 1
29059: ARRAY
29060: EQUAL
29061: PUSH
29062: LD_VAR 0 7
29066: PUSH
29067: LD_EXP 71
29071: PUSH
29072: LD_VAR 0 4
29076: ARRAY
29077: PUSH
29078: LD_INT 2
29080: ARRAY
29081: EQUAL
29082: AND
29083: PUSH
29084: LD_VAR 0 8
29088: PUSH
29089: LD_EXP 71
29093: PUSH
29094: LD_VAR 0 4
29098: ARRAY
29099: PUSH
29100: LD_INT 3
29102: ARRAY
29103: EQUAL
29104: AND
29105: PUSH
29106: LD_VAR 0 9
29110: PUSH
29111: LD_EXP 71
29115: PUSH
29116: LD_VAR 0 4
29120: ARRAY
29121: PUSH
29122: LD_INT 4
29124: ARRAY
29125: EQUAL
29126: AND
29127: IFFALSE 29283
// begin tmp := MREG_ToAttack [ side ] ;
29129: LD_ADDR_VAR 0 5
29133: PUSH
29134: LD_EXP 71
29138: PUSH
29139: LD_VAR 0 4
29143: ARRAY
29144: ST_TO_ADDR
// for i = 1 to 4 do
29145: LD_ADDR_VAR 0 3
29149: PUSH
29150: DOUBLE
29151: LD_INT 1
29153: DEC
29154: ST_TO_ADDR
29155: LD_INT 4
29157: PUSH
29158: FOR_TO
29159: IFFALSE 29181
// tmp := Delete ( tmp , 1 ) ;
29161: LD_ADDR_VAR 0 5
29165: PUSH
29166: LD_VAR 0 5
29170: PPUSH
29171: LD_INT 1
29173: PPUSH
29174: CALL_OW 3
29178: ST_TO_ADDR
29179: GO 29158
29181: POP
29182: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29183: LD_ADDR_EXP 71
29187: PUSH
29188: LD_EXP 71
29192: PPUSH
29193: LD_VAR 0 4
29197: PPUSH
29198: LD_VAR 0 5
29202: PPUSH
29203: CALL_OW 1
29207: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29208: LD_ADDR_EXP 73
29212: PUSH
29213: LD_EXP 73
29217: PPUSH
29218: LD_VAR 0 4
29222: PPUSH
29223: LD_EXP 73
29227: PUSH
29228: LD_VAR 0 4
29232: ARRAY
29233: PUSH
29234: LD_INT 1
29236: PLUS
29237: PPUSH
29238: LD_VAR 0 1
29242: PPUSH
29243: CALL 31052 0 4
29247: ST_TO_ADDR
// if tmp = 0 then
29248: LD_VAR 0 5
29252: PUSH
29253: LD_INT 0
29255: EQUAL
29256: IFFALSE 29281
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29258: LD_ADDR_EXP 71
29262: PUSH
29263: LD_EXP 71
29267: PPUSH
29268: LD_VAR 0 4
29272: PPUSH
29273: LD_INT 0
29275: PPUSH
29276: CALL_OW 1
29280: ST_TO_ADDR
// exit ;
29281: GO 29302
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 255
29292: PPUSH
29293: LD_VAR 0 1
29297: PPUSH
29298: CALL 25677 0 2
// end ;
29302: PPOPN 9
29304: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29305: LD_EXP 41
29309: PUSH
29310: LD_VAR 0 2
29314: PPUSH
29315: CALL_OW 255
29319: ARRAY
29320: IFFALSE 29552
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29322: LD_STRING ApemanTamed [side: 
29324: PUSH
29325: LD_VAR 0 2
29329: PPUSH
29330: CALL_OW 255
29334: STR
29335: PUSH
29336: LD_STRING ; sci: 
29338: STR
29339: PUSH
29340: LD_VAR 0 2
29344: STR
29345: PUSH
29346: LD_STRING ; ape: 
29348: STR
29349: PUSH
29350: LD_VAR 0 1
29354: STR
29355: PUSH
29356: LD_STRING ]
29358: STR
29359: PPUSH
29360: CALL 7984 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29364: LD_INT 11
29366: PPUSH
29367: LD_VAR 0 2
29371: PPUSH
29372: CALL_OW 255
29376: PPUSH
29377: CALL_OW 321
29381: PUSH
29382: LD_INT 2
29384: EQUAL
29385: NOT
29386: PUSH
29387: LD_INT 2
29389: PPUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: CALL_OW 255
29399: PPUSH
29400: CALL_OW 321
29404: PUSH
29405: LD_INT 2
29407: EQUAL
29408: NOT
29409: OR
29410: PUSH
29411: LD_VAR 0 2
29415: PPUSH
29416: CALL_OW 255
29420: PPUSH
29421: LD_INT 171
29423: PPUSH
29424: EMPTY
29425: PPUSH
29426: CALL 12290 0 3
29430: PUSH
29431: LD_INT 0
29433: EQUAL
29434: AND
29435: IFFALSE 29449
// begin SetTag ( ape , 171 ) ;
29437: LD_VAR 0 1
29441: PPUSH
29442: LD_INT 171
29444: PPUSH
29445: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29449: LD_VAR 0 2
29453: PPUSH
29454: CALL_OW 255
29458: PPUSH
29459: LD_INT 30
29461: PUSH
29462: LD_INT 1
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PPUSH
29469: CALL 11587 0 2
29473: IFFALSE 29552
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29475: LD_VAR 0 1
29479: PPUSH
29480: LD_VAR 0 2
29484: PPUSH
29485: CALL_OW 255
29489: PPUSH
29490: LD_INT 30
29492: PUSH
29493: LD_INT 1
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PPUSH
29500: CALL 11587 0 2
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PPUSH
29509: CALL_OW 250
29513: PPUSH
29514: LD_VAR 0 2
29518: PPUSH
29519: CALL_OW 255
29523: PPUSH
29524: LD_INT 30
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PPUSH
29534: CALL 11587 0 2
29538: PUSH
29539: LD_INT 1
29541: ARRAY
29542: PPUSH
29543: CALL_OW 251
29547: PPUSH
29548: CALL_OW 111
// end ;
29552: PPOPN 2
29554: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29555: LD_EXP 41
29559: PUSH
29560: LD_VAR 0 1
29564: PPUSH
29565: CALL_OW 255
29569: ARRAY
29570: IFFALSE 29848
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29572: LD_VAR 0 2
29576: PUSH
29577: LD_VAR 0 2
29581: PPUSH
29582: CALL_OW 255
29586: PPUSH
29587: CALL 12000 0 1
29591: IN
29592: IFFALSE 29733
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29594: LD_VAR 0 1
29598: PPUSH
29599: CALL_OW 266
29603: PUSH
29604: LD_INT 0
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: IN
29614: IFFALSE 29644
// begin Wait ( 0 0$0.3 ) ;
29616: LD_INT 10
29618: PPUSH
29619: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29623: LD_VAR 0 2
29627: PPUSH
29628: LD_INT 16
29630: PPUSH
29631: CALL_OW 336
// ComExitBuilding ( un ) ;
29635: LD_VAR 0 2
29639: PPUSH
29640: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29644: LD_VAR 0 1
29648: PPUSH
29649: CALL_OW 266
29653: PUSH
29654: LD_INT 4
29656: PUSH
29657: LD_INT 5
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: IN
29664: IFFALSE 29733
// begin Wait ( 0 0$0.3 ) ;
29666: LD_INT 10
29668: PPUSH
29669: CALL_OW 67
// if GetTag ( un ) = 0 then
29673: LD_VAR 0 2
29677: PPUSH
29678: CALL_OW 110
29682: PUSH
29683: LD_INT 0
29685: EQUAL
29686: IFFALSE 29702
// SetClass ( un , class_apeman_soldier ) else
29688: LD_VAR 0 2
29692: PPUSH
29693: LD_INT 15
29695: PPUSH
29696: CALL_OW 336
29700: GO 29733
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29702: LD_INT 3
29704: PPUSH
29705: LD_VAR 0 2
29709: PPUSH
29710: CALL_OW 255
29714: PPUSH
29715: CALL_OW 321
29719: IFFALSE 29733
// SetClass ( un , class_apeman_kamikaze ) ;
29721: LD_VAR 0 2
29725: PPUSH
29726: LD_INT 17
29728: PPUSH
29729: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29733: LD_VAR 0 1
29737: PPUSH
29738: CALL_OW 266
29742: PUSH
29743: LD_INT 32
29745: EQUAL
29746: IFFALSE 29848
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29748: LD_ADDR_EXP 70
29752: PUSH
29753: LD_EXP 70
29757: PPUSH
29758: LD_VAR 0 1
29762: PPUSH
29763: CALL_OW 255
29767: PPUSH
29768: LD_EXP 70
29772: PUSH
29773: LD_VAR 0 1
29777: PPUSH
29778: CALL_OW 255
29782: ARRAY
29783: PUSH
29784: LD_INT 1
29786: PLUS
29787: PPUSH
29788: LD_VAR 0 1
29792: PPUSH
29793: CALL 31052 0 4
29797: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29798: LD_ADDR_EXP 70
29802: PUSH
29803: LD_EXP 70
29807: PPUSH
29808: LD_VAR 0 1
29812: PPUSH
29813: CALL_OW 255
29817: PPUSH
29818: LD_EXP 70
29822: PUSH
29823: LD_VAR 0 1
29827: PPUSH
29828: CALL_OW 255
29832: ARRAY
29833: PUSH
29834: LD_INT 1
29836: PLUS
29837: PPUSH
29838: LD_VAR 0 2
29842: PPUSH
29843: CALL 31052 0 4
29847: ST_TO_ADDR
// end ; end ;
29848: PPOPN 2
29850: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL 56518 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29860: LD_VAR 0 1
29864: PUSH
29865: LD_INT 22
29867: PUSH
29868: LD_INT 3
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 23
29877: PUSH
29878: LD_INT 3
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 21
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: LIST
29899: PPUSH
29900: CALL_OW 69
29904: IN
29905: IFFALSE 29921
// player_loss := player_loss + 1 ;
29907: LD_ADDR_EXP 10
29911: PUSH
29912: LD_EXP 10
29916: PUSH
29917: LD_INT 1
29919: PLUS
29920: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29921: LD_VAR 0 1
29925: PUSH
29926: LD_INT 22
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 21
29938: PUSH
29939: LD_INT 3
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PPUSH
29950: CALL_OW 69
29954: IN
29955: PUSH
29956: LD_EXP 15
29960: NOT
29961: AND
29962: IFFALSE 30025
// begin alfa_north_triggered := true ;
29964: LD_ADDR_EXP 15
29968: PUSH
29969: LD_INT 1
29971: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29972: LD_EXP 5
29976: PPUSH
29977: LD_STRING DS4
29979: PPUSH
29980: CALL_OW 94
// Wait ( 1 1$25 ) ;
29984: LD_INT 2975
29986: PPUSH
29987: CALL_OW 67
// if not isTest then
29991: LD_EXP 1
29995: NOT
29996: IFFALSE 30025
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29998: LD_INT 20
30000: PPUSH
30001: LD_INT 5
30003: PUSH
30004: LD_INT 6
30006: PUSH
30007: LD_INT 7
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: LIST
30014: PUSH
30015: LD_OWVAR 67
30019: ARRAY
30020: PPUSH
30021: CALL 7122 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30025: LD_VAR 0 1
30029: PUSH
30030: LD_INT 22
30032: PUSH
30033: LD_INT 4
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 21
30042: PUSH
30043: LD_INT 3
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PPUSH
30054: CALL_OW 69
30058: IN
30059: PUSH
30060: LD_EXP 16
30064: NOT
30065: AND
30066: IFFALSE 30129
// begin alfa_south_triggered := true ;
30068: LD_ADDR_EXP 16
30072: PUSH
30073: LD_INT 1
30075: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30076: LD_EXP 4
30080: PPUSH
30081: LD_STRING DJ3
30083: PPUSH
30084: CALL_OW 94
// Wait ( 0 0$45 ) ;
30088: LD_INT 1575
30090: PPUSH
30091: CALL_OW 67
// if not isTest then
30095: LD_EXP 1
30099: NOT
30100: IFFALSE 30129
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30102: LD_INT 20
30104: PPUSH
30105: LD_INT 5
30107: PUSH
30108: LD_INT 6
30110: PUSH
30111: LD_INT 7
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: LIST
30118: PUSH
30119: LD_OWVAR 67
30123: ARRAY
30124: PPUSH
30125: CALL 7122 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30129: LD_VAR 0 1
30133: PPUSH
30134: CALL_OW 266
30138: PUSH
30139: LD_INT 1
30141: EQUAL
30142: PUSH
30143: LD_VAR 0 1
30147: PPUSH
30148: CALL_OW 255
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: LD_INT 4
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: IN
30163: AND
30164: IFFALSE 30173
// RaiseSailEvent ( 104 ) ;
30166: LD_INT 104
30168: PPUSH
30169: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30173: LD_EXP 41
30177: PUSH
30178: LD_VAR 0 1
30182: PPUSH
30183: CALL_OW 255
30187: ARRAY
30188: IFFALSE 30575
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30190: LD_STRING UnitDestroyed [side 
30192: PUSH
30193: LD_VAR 0 1
30197: PPUSH
30198: CALL_OW 255
30202: STR
30203: PUSH
30204: LD_STRING ; id: 
30206: STR
30207: PUSH
30208: LD_VAR 0 1
30212: STR
30213: PUSH
30214: LD_STRING ; type: 
30216: STR
30217: PUSH
30218: LD_VAR 0 1
30222: PPUSH
30223: CALL_OW 247
30227: STR
30228: PUSH
30229: LD_STRING ]
30231: STR
30232: PPUSH
30233: CALL 7984 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30237: LD_VAR 0 1
30241: PUSH
30242: LD_VAR 0 1
30246: PPUSH
30247: CALL_OW 255
30251: PPUSH
30252: LD_INT 21
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PPUSH
30262: CALL 11587 0 2
30266: IN
30267: IFFALSE 30423
// begin if MCF_HasClass ( un ) then
30269: LD_VAR 0 1
30273: PPUSH
30274: CALL 14293 0 1
30278: IFFALSE 30423
// case MCF_HasClass ( un ) of 1 :
30280: LD_VAR 0 1
30284: PPUSH
30285: CALL 14293 0 1
30289: PUSH
30290: LD_INT 1
30292: DOUBLE
30293: EQUAL
30294: IFTRUE 30298
30296: GO 30323
30298: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30299: LD_VAR 0 1
30303: PPUSH
30304: CALL_OW 255
30308: PPUSH
30309: LD_STRING ToArm
30311: PPUSH
30312: LD_VAR 0 1
30316: PPUSH
30317: CALL 14466 0 3
30321: GO 30423
30323: LD_INT 2
30325: DOUBLE
30326: EQUAL
30327: IFTRUE 30331
30329: GO 30356
30331: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30332: LD_VAR 0 1
30336: PPUSH
30337: CALL_OW 255
30341: PPUSH
30342: LD_STRING ToDep
30344: PPUSH
30345: LD_VAR 0 1
30349: PPUSH
30350: CALL 14466 0 3
30354: GO 30423
30356: LD_INT 3
30358: DOUBLE
30359: EQUAL
30360: IFTRUE 30364
30362: GO 30389
30364: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30365: LD_VAR 0 1
30369: PPUSH
30370: CALL_OW 255
30374: PPUSH
30375: LD_STRING ToFac
30377: PPUSH
30378: LD_VAR 0 1
30382: PPUSH
30383: CALL 14466 0 3
30387: GO 30423
30389: LD_INT 4
30391: DOUBLE
30392: EQUAL
30393: IFTRUE 30397
30395: GO 30422
30397: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30398: LD_VAR 0 1
30402: PPUSH
30403: CALL_OW 255
30407: PPUSH
30408: LD_STRING ToLab
30410: PPUSH
30411: LD_VAR 0 1
30415: PPUSH
30416: CALL 14466 0 3
30420: GO 30423
30422: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30423: LD_VAR 0 1
30427: PUSH
30428: LD_EXP 69
30432: PUSH
30433: LD_VAR 0 1
30437: PPUSH
30438: CALL_OW 255
30442: ARRAY
30443: IN
30444: IFFALSE 30529
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30446: LD_ADDR_EXP 69
30450: PUSH
30451: LD_EXP 69
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: LD_INT 0
30463: PPUSH
30464: CALL 31211 0 3
30468: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30469: LD_VAR 0 1
30473: PPUSH
30474: CALL_OW 255
30478: PPUSH
30479: LD_VAR 0 1
30483: PPUSH
30484: CALL_OW 265
30488: PUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL_OW 262
30498: PUSH
30499: LD_VAR 0 1
30503: PPUSH
30504: CALL_OW 263
30508: PUSH
30509: LD_VAR 0 1
30513: PPUSH
30514: CALL_OW 264
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: PPUSH
30525: CALL 21106 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30529: LD_VAR 0 1
30533: PUSH
30534: LD_EXP 73
30538: PUSH
30539: LD_VAR 0 1
30543: PPUSH
30544: CALL_OW 255
30548: ARRAY
30549: IN
30550: IFFALSE 30575
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30552: LD_ADDR_EXP 73
30556: PUSH
30557: LD_EXP 73
30561: PPUSH
30562: LD_VAR 0 1
30566: PPUSH
30567: LD_INT 0
30569: PPUSH
30570: CALL 31211 0 3
30574: ST_TO_ADDR
// end ; end ;
30575: PPOPN 1
30577: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30578: LD_EXP 41
30582: PUSH
30583: LD_VAR 0 2
30587: PPUSH
30588: CALL_OW 255
30592: ARRAY
30593: IFFALSE 30765
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30595: LD_VAR 0 2
30599: PUSH
30600: LD_EXP 70
30604: PUSH
30605: LD_VAR 0 2
30609: PPUSH
30610: CALL_OW 255
30614: ARRAY
30615: IN
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 266
30626: PUSH
30627: LD_INT 32
30629: PUSH
30630: LD_INT 31
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: IN
30637: AND
30638: IFFALSE 30738
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30640: LD_ADDR_EXP 70
30644: PUSH
30645: LD_EXP 70
30649: PPUSH
30650: LD_VAR 0 1
30654: PPUSH
30655: LD_INT 0
30657: PPUSH
30658: CALL 31211 0 3
30662: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30663: LD_ADDR_EXP 70
30667: PUSH
30668: LD_EXP 70
30672: PPUSH
30673: LD_VAR 0 2
30677: PPUSH
30678: LD_INT 0
30680: PPUSH
30681: CALL 31211 0 3
30685: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30686: LD_EXP 70
30690: PUSH
30691: LD_VAR 0 2
30695: PPUSH
30696: CALL_OW 255
30700: ARRAY
30701: PUSH
30702: LD_STRING 
30704: EQUAL
30705: IFFALSE 30738
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30707: LD_ADDR_EXP 70
30711: PUSH
30712: LD_EXP 70
30716: PPUSH
30717: LD_VAR 0 2
30721: PPUSH
30722: CALL_OW 255
30726: PPUSH
30727: LD_INT 1
30729: PPUSH
30730: LD_INT 0
30732: PPUSH
30733: CALL 31052 0 4
30737: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30738: LD_VAR 0 1
30742: PPUSH
30743: CALL_OW 266
30747: PUSH
30748: LD_INT 36
30750: IN
30751: IFFALSE 30765
// SetTag ( un , 0 ) ;
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_INT 0
30760: PPUSH
30761: CALL_OW 109
// end ;
30765: PPOPN 2
30767: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30768: LD_EXP 41
30772: PUSH
30773: LD_VAR 0 1
30777: PPUSH
30778: CALL_OW 255
30782: ARRAY
30783: IFFALSE 30809
// begin if GetControl ( un ) = control_remote then
30785: LD_VAR 0 1
30789: PPUSH
30790: CALL_OW 263
30794: PUSH
30795: LD_INT 2
30797: EQUAL
30798: IFFALSE 30809
// ComUnlink ( un ) ;
30800: LD_VAR 0 1
30804: PPUSH
30805: CALL_OW 136
// end ;
30809: PPOPN 1
30811: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30812: LD_EXP 41
30816: PUSH
30817: LD_VAR 0 1
30821: PPUSH
30822: CALL_OW 255
30826: ARRAY
30827: IFFALSE 30856
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30829: LD_VAR 0 2
30833: PPUSH
30834: CALL_OW 264
30838: PUSH
30839: LD_INT 31
30841: IN
30842: IFFALSE 30856
// SetTag ( driver , 0 ) ;
30844: LD_VAR 0 1
30848: PPUSH
30849: LD_INT 0
30851: PPUSH
30852: CALL_OW 109
// end ;
30856: PPOPN 4
30858: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30859: LD_INT 0
30861: PPUSH
30862: PPUSH
30863: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30864: LD_ADDR_VAR 0 3
30868: PUSH
30869: LD_VAR 0 1
30873: PPUSH
30874: CALL_OW 269
30878: ST_TO_ADDR
// x := GetX ( building ) ;
30879: LD_ADDR_VAR 0 4
30883: PUSH
30884: LD_VAR 0 1
30888: PPUSH
30889: CALL_OW 250
30893: ST_TO_ADDR
// y := GetY ( building ) ;
30894: LD_ADDR_VAR 0 5
30898: PUSH
30899: LD_VAR 0 1
30903: PPUSH
30904: CALL_OW 251
30908: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30909: LD_ADDR_EXP 45
30913: PUSH
30914: LD_EXP 45
30918: PPUSH
30919: LD_VAR 0 1
30923: PPUSH
30924: CALL_OW 255
30928: PPUSH
30929: LD_VAR 0 3
30933: PPUSH
30934: LD_VAR 0 4
30938: PUSH
30939: LD_VAR 0 5
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PPUSH
30948: CALL 41973 0 4
30952: ST_TO_ADDR
// end ;
30953: PPOPN 5
30955: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30956: LD_VAR 0 1
30960: PUSH
30961: LD_EXP 32
30965: IN
30966: NOT
30967: IFFALSE 31015
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30969: LD_ADDR_EXP 32
30973: PUSH
30974: LD_EXP 32
30978: PPUSH
30979: LD_EXP 32
30983: PUSH
30984: LD_INT 1
30986: PLUS
30987: PPUSH
30988: LD_VAR 0 1
30992: PPUSH
30993: CALL_OW 2
30997: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30998: LD_STRING DestinationUnrechable. [unit: 
31000: PUSH
31001: LD_VAR 0 1
31005: STR
31006: PUSH
31007: LD_STRING ]
31009: STR
31010: PPUSH
31011: CALL 7984 0 1
// end ; end ;
31015: PPOPN 1
31017: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31018: LD_VAR 0 1
31022: PPUSH
31023: LD_VAR 0 2
31027: PPUSH
31028: LD_VAR 0 3
31032: PPUSH
31033: CALL 56616 0 3
// end ;
31037: PPOPN 3
31039: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31040: LD_VAR 0 1
31044: PPUSH
31045: CALL 56624 0 1
// end ; end_of_file
31049: PPOPN 1
31051: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31052: LD_INT 0
31054: PPUSH
31055: PPUSH
31056: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31057: LD_ADDR_VAR 0 7
31061: PUSH
31062: LD_VAR 0 1
31066: PUSH
31067: LD_VAR 0 2
31071: ARRAY
31072: PPUSH
31073: LD_VAR 0 3
31077: PPUSH
31078: LD_VAR 0 4
31082: PPUSH
31083: CALL_OW 1
31087: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31088: LD_ADDR_VAR 0 1
31092: PUSH
31093: LD_VAR 0 1
31097: PPUSH
31098: LD_VAR 0 2
31102: PPUSH
31103: LD_VAR 0 7
31107: PPUSH
31108: CALL_OW 1
31112: ST_TO_ADDR
// result := tab ;
31113: LD_ADDR_VAR 0 5
31117: PUSH
31118: LD_VAR 0 1
31122: ST_TO_ADDR
// end ;
31123: LD_VAR 0 5
31127: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31128: LD_INT 0
31130: PPUSH
31131: PPUSH
31132: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31133: LD_ADDR_VAR 0 5
31137: PUSH
31138: LD_VAR 0 1
31142: PUSH
31143: LD_VAR 0 2
31147: PUSH
31148: LD_INT 1
31150: ARRAY
31151: ARRAY
31152: PPUSH
31153: LD_VAR 0 2
31157: PUSH
31158: LD_INT 2
31160: ARRAY
31161: PPUSH
31162: CALL_OW 3
31166: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31167: LD_ADDR_VAR 0 1
31171: PUSH
31172: LD_VAR 0 1
31176: PPUSH
31177: LD_VAR 0 2
31181: PUSH
31182: LD_INT 1
31184: ARRAY
31185: PPUSH
31186: LD_VAR 0 5
31190: PPUSH
31191: CALL_OW 1
31195: ST_TO_ADDR
// result := tab ;
31196: LD_ADDR_VAR 0 3
31200: PUSH
31201: LD_VAR 0 1
31205: ST_TO_ADDR
// end ;
31206: LD_VAR 0 3
31210: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31211: LD_INT 0
31213: PPUSH
31214: PPUSH
31215: PPUSH
31216: PPUSH
// i := 1 ;
31217: LD_ADDR_VAR 0 5
31221: PUSH
31222: LD_INT 1
31224: ST_TO_ADDR
// while ( i <= tab ) do
31225: LD_VAR 0 5
31229: PUSH
31230: LD_VAR 0 1
31234: LESSEQUAL
31235: IFFALSE 31610
// begin if not tab [ i ] then
31237: LD_VAR 0 1
31241: PUSH
31242: LD_VAR 0 5
31246: ARRAY
31247: NOT
31248: IFFALSE 31252
// break ;
31250: GO 31610
// if value in tab then
31252: LD_VAR 0 2
31256: PUSH
31257: LD_VAR 0 1
31261: IN
31262: IFFALSE 31375
// begin if not mode then
31264: LD_VAR 0 3
31268: NOT
31269: IFFALSE 31289
// tab := tab diff value else
31271: LD_ADDR_VAR 0 1
31275: PUSH
31276: LD_VAR 0 1
31280: PUSH
31281: LD_VAR 0 2
31285: DIFF
31286: ST_TO_ADDR
31287: GO 31351
// for j = 1 to tab do
31289: LD_ADDR_VAR 0 6
31293: PUSH
31294: DOUBLE
31295: LD_INT 1
31297: DEC
31298: ST_TO_ADDR
31299: LD_VAR 0 1
31303: PUSH
31304: FOR_TO
31305: IFFALSE 31349
// if tab [ j ] = value then
31307: LD_VAR 0 1
31311: PUSH
31312: LD_VAR 0 6
31316: ARRAY
31317: PUSH
31318: LD_VAR 0 2
31322: EQUAL
31323: IFFALSE 31347
// begin tab := Delete ( tab , j ) ;
31325: LD_ADDR_VAR 0 1
31329: PUSH
31330: LD_VAR 0 1
31334: PPUSH
31335: LD_VAR 0 6
31339: PPUSH
31340: CALL_OW 3
31344: ST_TO_ADDR
// break ;
31345: GO 31349
// end ;
31347: GO 31304
31349: POP
31350: POP
// i := i - 1 ;
31351: LD_ADDR_VAR 0 5
31355: PUSH
31356: LD_VAR 0 5
31360: PUSH
31361: LD_INT 1
31363: MINUS
31364: ST_TO_ADDR
// if mode then
31365: LD_VAR 0 3
31369: IFFALSE 31373
// break ;
31371: GO 31610
// end else
31373: GO 31594
// if tab [ i ] and value in tab [ i ] then
31375: LD_VAR 0 1
31379: PUSH
31380: LD_VAR 0 5
31384: ARRAY
31385: PUSH
31386: LD_VAR 0 2
31390: PUSH
31391: LD_VAR 0 1
31395: PUSH
31396: LD_VAR 0 5
31400: ARRAY
31401: IN
31402: AND
31403: IFFALSE 31594
// begin if not mode then
31405: LD_VAR 0 3
31409: NOT
31410: IFFALSE 31436
// tmp := tab [ i ] diff value else
31412: LD_ADDR_VAR 0 7
31416: PUSH
31417: LD_VAR 0 1
31421: PUSH
31422: LD_VAR 0 5
31426: ARRAY
31427: PUSH
31428: LD_VAR 0 2
31432: DIFF
31433: ST_TO_ADDR
31434: GO 31516
// for j = 1 to tab [ i ] do
31436: LD_ADDR_VAR 0 6
31440: PUSH
31441: DOUBLE
31442: LD_INT 1
31444: DEC
31445: ST_TO_ADDR
31446: LD_VAR 0 1
31450: PUSH
31451: LD_VAR 0 5
31455: ARRAY
31456: PUSH
31457: FOR_TO
31458: IFFALSE 31514
// if value = tab [ i ] [ j ] then
31460: LD_VAR 0 2
31464: PUSH
31465: LD_VAR 0 1
31469: PUSH
31470: LD_VAR 0 5
31474: ARRAY
31475: PUSH
31476: LD_VAR 0 6
31480: ARRAY
31481: EQUAL
31482: IFFALSE 31512
// begin tmp := Delete ( tab [ i ] , j ) ;
31484: LD_ADDR_VAR 0 7
31488: PUSH
31489: LD_VAR 0 1
31493: PUSH
31494: LD_VAR 0 5
31498: ARRAY
31499: PPUSH
31500: LD_VAR 0 6
31504: PPUSH
31505: CALL_OW 3
31509: ST_TO_ADDR
// break ;
31510: GO 31514
// end ;
31512: GO 31457
31514: POP
31515: POP
// if tmp = [ ] then
31516: LD_VAR 0 7
31520: PUSH
31521: EMPTY
31522: EQUAL
31523: IFFALSE 31547
// begin tab := Delete ( tab , i ) ;
31525: LD_ADDR_VAR 0 1
31529: PUSH
31530: LD_VAR 0 1
31534: PPUSH
31535: LD_VAR 0 5
31539: PPUSH
31540: CALL_OW 3
31544: ST_TO_ADDR
// end else
31545: GO 31572
// tab := Replace ( tab , i , tmp ) ;
31547: LD_ADDR_VAR 0 1
31551: PUSH
31552: LD_VAR 0 1
31556: PPUSH
31557: LD_VAR 0 5
31561: PPUSH
31562: LD_VAR 0 7
31566: PPUSH
31567: CALL_OW 1
31571: ST_TO_ADDR
// i := i - 1 ;
31572: LD_ADDR_VAR 0 5
31576: PUSH
31577: LD_VAR 0 5
31581: PUSH
31582: LD_INT 1
31584: MINUS
31585: ST_TO_ADDR
// if mode then
31586: LD_VAR 0 3
31590: IFFALSE 31594
// break ;
31592: GO 31610
// end ; i := i + 1 ;
31594: LD_ADDR_VAR 0 5
31598: PUSH
31599: LD_VAR 0 5
31603: PUSH
31604: LD_INT 1
31606: PLUS
31607: ST_TO_ADDR
// end ;
31608: GO 31225
// result := tab ;
31610: LD_ADDR_VAR 0 4
31614: PUSH
31615: LD_VAR 0 1
31619: ST_TO_ADDR
// end ;
31620: LD_VAR 0 4
31624: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31625: LD_INT 0
31627: PPUSH
31628: PPUSH
// for i = 1 to values do
31629: LD_ADDR_VAR 0 4
31633: PUSH
31634: DOUBLE
31635: LD_INT 1
31637: DEC
31638: ST_TO_ADDR
31639: LD_VAR 0 2
31643: PUSH
31644: FOR_TO
31645: IFFALSE 31678
// tab := Remove ( tab , values [ i ] , false ) ;
31647: LD_ADDR_VAR 0 1
31651: PUSH
31652: LD_VAR 0 1
31656: PPUSH
31657: LD_VAR 0 2
31661: PUSH
31662: LD_VAR 0 4
31666: ARRAY
31667: PPUSH
31668: LD_INT 0
31670: PPUSH
31671: CALL 31211 0 3
31675: ST_TO_ADDR
31676: GO 31644
31678: POP
31679: POP
// result := tab ;
31680: LD_ADDR_VAR 0 3
31684: PUSH
31685: LD_VAR 0 1
31689: ST_TO_ADDR
// end ;
31690: LD_VAR 0 3
31694: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31695: LD_INT 0
31697: PPUSH
31698: PPUSH
31699: PPUSH
// if not GetControl ( veh ) = control_manual then
31700: LD_VAR 0 1
31704: PPUSH
31705: CALL_OW 263
31709: PUSH
31710: LD_INT 1
31712: EQUAL
31713: NOT
31714: IFFALSE 31726
// result := false else
31716: LD_ADDR_VAR 0 2
31720: PUSH
31721: LD_INT 0
31723: ST_TO_ADDR
31724: GO 31871
// if veh in FilterAllUnits ( [ f_empty ] ) then
31726: LD_VAR 0 1
31730: PUSH
31731: LD_INT 58
31733: PUSH
31734: EMPTY
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: IN
31742: IFFALSE 31754
// result := false else
31744: LD_ADDR_VAR 0 2
31748: PUSH
31749: LD_INT 0
31751: ST_TO_ADDR
31752: GO 31871
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31754: LD_ADDR_VAR 0 4
31758: PUSH
31759: LD_INT 22
31761: PUSH
31762: LD_VAR 0 1
31766: PPUSH
31767: CALL_OW 255
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 55
31778: PUSH
31779: EMPTY
31780: LIST
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PPUSH
31786: CALL_OW 69
31790: ST_TO_ADDR
// if not filter then
31791: LD_VAR 0 4
31795: NOT
31796: IFFALSE 31808
// result := false else
31798: LD_ADDR_VAR 0 2
31802: PUSH
31803: LD_INT 0
31805: ST_TO_ADDR
31806: GO 31871
// for i = 1 to filter do
31808: LD_ADDR_VAR 0 3
31812: PUSH
31813: DOUBLE
31814: LD_INT 1
31816: DEC
31817: ST_TO_ADDR
31818: LD_VAR 0 4
31822: PUSH
31823: FOR_TO
31824: IFFALSE 31869
// if IsDriver ( filter [ i ] ) = veh then
31826: LD_VAR 0 4
31830: PUSH
31831: LD_VAR 0 3
31835: ARRAY
31836: PPUSH
31837: CALL 94461 0 1
31841: PUSH
31842: LD_VAR 0 1
31846: EQUAL
31847: IFFALSE 31867
// begin result := filter [ i ] ;
31849: LD_ADDR_VAR 0 2
31853: PUSH
31854: LD_VAR 0 4
31858: PUSH
31859: LD_VAR 0 3
31863: ARRAY
31864: ST_TO_ADDR
// break ;
31865: GO 31869
// end ;
31867: GO 31823
31869: POP
31870: POP
// end ; end ;
31871: LD_VAR 0 2
31875: RET
// export function Compare ( val1 , val2 ) ; begin
31876: LD_INT 0
31878: PPUSH
// if val1 = val2 then
31879: LD_VAR 0 1
31883: PUSH
31884: LD_VAR 0 2
31888: EQUAL
31889: IFFALSE 31901
// result := true else
31891: LD_ADDR_VAR 0 3
31895: PUSH
31896: LD_INT 1
31898: ST_TO_ADDR
31899: GO 31909
// result := false ;
31901: LD_ADDR_VAR 0 3
31905: PUSH
31906: LD_INT 0
31908: ST_TO_ADDR
// end ;
31909: LD_VAR 0 3
31913: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31914: LD_INT 0
31916: PPUSH
31917: PPUSH
// result := false ;
31918: LD_ADDR_VAR 0 3
31922: PUSH
31923: LD_INT 0
31925: ST_TO_ADDR
// for j = 1 to e2 do
31926: LD_ADDR_VAR 0 4
31930: PUSH
31931: DOUBLE
31932: LD_INT 1
31934: DEC
31935: ST_TO_ADDR
31936: LD_VAR 0 2
31940: PUSH
31941: FOR_TO
31942: IFFALSE 31976
// if Compare ( e1 , e2 [ j ] ) then
31944: LD_VAR 0 1
31948: PPUSH
31949: LD_VAR 0 2
31953: PUSH
31954: LD_VAR 0 4
31958: ARRAY
31959: PPUSH
31960: CALL 31876 0 2
31964: IFFALSE 31974
// result := true ;
31966: LD_ADDR_VAR 0 3
31970: PUSH
31971: LD_INT 1
31973: ST_TO_ADDR
31974: GO 31941
31976: POP
31977: POP
// end ;
31978: LD_VAR 0 3
31982: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
31983: LD_INT 0
31985: PPUSH
31986: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
31987: LD_VAR 0 1
31991: PPUSH
31992: LD_STRING C
31994: PUSH
31995: LD_VAR 0 2
31999: PUSH
32000: LD_VAR 0 3
32004: PUSH
32005: LD_INT 0
32007: PUSH
32008: LD_INT 0
32010: PUSH
32011: LD_INT 0
32013: PUSH
32014: LD_INT 0
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: PUSH
32026: LD_STRING v
32028: PUSH
32029: LD_VAR 0 4
32033: PPUSH
32034: CALL_OW 250
32038: PUSH
32039: LD_VAR 0 4
32043: PPUSH
32044: CALL_OW 251
32048: PUSH
32049: LD_VAR 0 4
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 0
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PPUSH
32076: CALL_OW 446
// end ;
32080: LD_VAR 0 5
32084: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32085: LD_INT 0
32087: PPUSH
32088: PPUSH
32089: PPUSH
// linked := UnitsLinked ( unit ) ;
32090: LD_ADDR_VAR 0 4
32094: PUSH
32095: LD_VAR 0 1
32099: PPUSH
32100: CALL_OW 432
32104: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32105: LD_ADDR_VAR 0 3
32109: PUSH
32110: LD_VAR 0 1
32114: PPUSH
32115: LD_INT 3
32117: PPUSH
32118: CALL_OW 259
32122: ST_TO_ADDR
// if sk > linked then
32123: LD_VAR 0 3
32127: PUSH
32128: LD_VAR 0 4
32132: GREATER
32133: IFFALSE 32145
// result := true else
32135: LD_ADDR_VAR 0 2
32139: PUSH
32140: LD_INT 1
32142: ST_TO_ADDR
32143: GO 32153
// result := false ;
32145: LD_ADDR_VAR 0 2
32149: PUSH
32150: LD_INT 0
32152: ST_TO_ADDR
// end ;
32153: LD_VAR 0 2
32157: RET
// export function NotTask ( unit ) ; begin
32158: LD_INT 0
32160: PPUSH
// result := true ;
32161: LD_ADDR_VAR 0 2
32165: PUSH
32166: LD_INT 1
32168: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32169: LD_VAR 0 1
32173: PPUSH
32174: CALL_OW 437
32178: PUSH
32179: LD_VAR 0 1
32183: PPUSH
32184: CALL_OW 314
32188: OR
32189: IFFALSE 32199
// result := false ;
32191: LD_ADDR_VAR 0 2
32195: PUSH
32196: LD_INT 0
32198: ST_TO_ADDR
// end ;
32199: LD_VAR 0 2
32203: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32204: LD_INT 0
32206: PPUSH
32207: PPUSH
32208: PPUSH
32209: PPUSH
32210: PPUSH
// dist := 99999 ;
32211: LD_ADDR_VAR 0 7
32215: PUSH
32216: LD_INT 99999
32218: ST_TO_ADDR
// un := - 1 ;
32219: LD_ADDR_VAR 0 6
32223: PUSH
32224: LD_INT 1
32226: NEG
32227: ST_TO_ADDR
// if units1 and units2 then
32228: LD_VAR 0 1
32232: PUSH
32233: LD_VAR 0 2
32237: AND
32238: IFFALSE 32326
// for i in units1 do
32240: LD_ADDR_VAR 0 4
32244: PUSH
32245: LD_VAR 0 1
32249: PUSH
32250: FOR_IN
32251: IFFALSE 32324
// for j in units2 do
32253: LD_ADDR_VAR 0 5
32257: PUSH
32258: LD_VAR 0 2
32262: PUSH
32263: FOR_IN
32264: IFFALSE 32320
// if GetDistUnits ( i , j ) < dist then
32266: LD_VAR 0 4
32270: PPUSH
32271: LD_VAR 0 5
32275: PPUSH
32276: CALL_OW 296
32280: PUSH
32281: LD_VAR 0 7
32285: LESS
32286: IFFALSE 32318
// begin un := i ;
32288: LD_ADDR_VAR 0 6
32292: PUSH
32293: LD_VAR 0 4
32297: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32298: LD_ADDR_VAR 0 7
32302: PUSH
32303: LD_VAR 0 4
32307: PPUSH
32308: LD_VAR 0 5
32312: PPUSH
32313: CALL_OW 296
32317: ST_TO_ADDR
// end ;
32318: GO 32263
32320: POP
32321: POP
32322: GO 32250
32324: POP
32325: POP
// result := [ un , dist ] ;
32326: LD_ADDR_VAR 0 3
32330: PUSH
32331: LD_VAR 0 6
32335: PUSH
32336: LD_VAR 0 7
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// end ;
32345: LD_VAR 0 3
32349: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32350: LD_INT 0
32352: PPUSH
32353: PPUSH
32354: PPUSH
32355: PPUSH
32356: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32357: LD_VAR 0 1
32361: NOT
32362: PUSH
32363: LD_VAR 0 1
32367: PPUSH
32368: CALL_OW 256
32372: PUSH
32373: LD_INT 250
32375: LESS
32376: OR
32377: PUSH
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 314
32387: PUSH
32388: LD_VAR 0 1
32392: PPUSH
32393: CALL_OW 261
32397: PUSH
32398: LD_INT 20
32400: GREATER
32401: AND
32402: OR
32403: IFFALSE 32407
// exit ;
32405: GO 32781
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32407: LD_VAR 0 1
32411: PPUSH
32412: CALL_OW 261
32416: PUSH
32417: LD_INT 20
32419: LESS
32420: PUSH
32421: LD_VAR 0 1
32425: PPUSH
32426: CALL_OW 110
32430: PUSH
32431: LD_INT 21
32433: EQUAL
32434: NOT
32435: AND
32436: IFFALSE 32472
// begin ComStop ( bulldozer ) ;
32438: LD_VAR 0 1
32442: PPUSH
32443: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32447: LD_VAR 0 1
32451: PPUSH
32452: LD_INT 21
32454: PPUSH
32455: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32459: LD_VAR 0 1
32463: PPUSH
32464: CALL 26214 0 1
// exit ;
32468: GO 32781
// end else
32470: GO 32499
// if GetFuel ( bulldozer ) > 20 then
32472: LD_VAR 0 1
32476: PPUSH
32477: CALL_OW 261
32481: PUSH
32482: LD_INT 20
32484: GREATER
32485: IFFALSE 32499
// SetTag ( bulldozer , 0 ) ;
32487: LD_VAR 0 1
32491: PPUSH
32492: LD_INT 0
32494: PPUSH
32495: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32499: LD_ADDR_VAR 0 5
32503: PUSH
32504: LD_VAR 0 2
32508: PPUSH
32509: CALL_OW 353
32513: ST_TO_ADDR
// tmp := [ ] ;
32514: LD_ADDR_VAR 0 6
32518: PUSH
32519: EMPTY
32520: ST_TO_ADDR
// for i = 1 to list do
32521: LD_ADDR_VAR 0 4
32525: PUSH
32526: DOUBLE
32527: LD_INT 1
32529: DEC
32530: ST_TO_ADDR
32531: LD_VAR 0 5
32535: PUSH
32536: FOR_TO
32537: IFFALSE 32635
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32539: LD_VAR 0 5
32543: PUSH
32544: LD_VAR 0 4
32548: ARRAY
32549: PUSH
32550: LD_INT 1
32552: ARRAY
32553: PPUSH
32554: LD_VAR 0 5
32558: PUSH
32559: LD_VAR 0 4
32563: ARRAY
32564: PUSH
32565: LD_INT 2
32567: ARRAY
32568: PPUSH
32569: CALL_OW 554
32573: IFFALSE 32633
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32575: LD_ADDR_VAR 0 6
32579: PUSH
32580: LD_VAR 0 6
32584: PPUSH
32585: LD_VAR 0 6
32589: PUSH
32590: LD_INT 1
32592: PLUS
32593: PPUSH
32594: LD_VAR 0 5
32598: PUSH
32599: LD_VAR 0 4
32603: ARRAY
32604: PUSH
32605: LD_INT 1
32607: ARRAY
32608: PUSH
32609: LD_VAR 0 5
32613: PUSH
32614: LD_VAR 0 4
32618: ARRAY
32619: PUSH
32620: LD_INT 2
32622: ARRAY
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PPUSH
32628: CALL_OW 1
32632: ST_TO_ADDR
// end ;
32633: GO 32536
32635: POP
32636: POP
// ComStop ( bulldozer ) ;
32637: LD_VAR 0 1
32641: PPUSH
32642: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32646: LD_ADDR_VAR 0 7
32650: PUSH
32651: LD_VAR 0 1
32655: PPUSH
32656: CALL_OW 250
32660: PUSH
32661: LD_VAR 0 1
32665: PPUSH
32666: CALL_OW 251
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: ST_TO_ADDR
// for i = tmp downto 1 do
32675: LD_ADDR_VAR 0 4
32679: PUSH
32680: DOUBLE
32681: LD_VAR 0 6
32685: INC
32686: ST_TO_ADDR
32687: LD_INT 1
32689: PUSH
32690: FOR_DOWNTO
32691: IFFALSE 32779
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32693: LD_ADDR_VAR 0 7
32697: PUSH
32698: LD_VAR 0 7
32702: PUSH
32703: LD_INT 1
32705: ARRAY
32706: PPUSH
32707: LD_VAR 0 7
32711: PUSH
32712: LD_INT 2
32714: ARRAY
32715: PPUSH
32716: LD_VAR 0 6
32720: PPUSH
32721: CALL 32882 0 3
32725: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32726: LD_VAR 0 1
32730: PPUSH
32731: LD_VAR 0 7
32735: PUSH
32736: LD_INT 1
32738: ARRAY
32739: PPUSH
32740: LD_VAR 0 7
32744: PUSH
32745: LD_INT 2
32747: ARRAY
32748: PPUSH
32749: CALL 32786 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32753: LD_ADDR_VAR 0 6
32757: PUSH
32758: LD_VAR 0 6
32762: PPUSH
32763: LD_VAR 0 7
32767: PUSH
32768: LD_INT 3
32770: ARRAY
32771: PPUSH
32772: CALL_OW 3
32776: ST_TO_ADDR
// end ;
32777: GO 32690
32779: POP
32780: POP
// end ;
32781: LD_VAR 0 3
32785: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32786: LD_INT 0
32788: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32789: LD_VAR 0 2
32793: PPUSH
32794: LD_VAR 0 3
32798: PPUSH
32799: CALL_OW 351
32803: PUSH
32804: LD_VAR 0 2
32808: PPUSH
32809: LD_VAR 0 3
32813: PPUSH
32814: CALL_OW 554
32818: AND
32819: PUSH
32820: LD_VAR 0 2
32824: PPUSH
32825: LD_VAR 0 3
32829: PPUSH
32830: CALL_OW 488
32834: AND
32835: PUSH
32836: LD_VAR 0 2
32840: PPUSH
32841: LD_VAR 0 3
32845: PPUSH
32846: CALL_OW 428
32850: PUSH
32851: LD_INT 1
32853: NEG
32854: EQUAL
32855: AND
32856: IFFALSE 32877
// AddComMoveXY ( bulldozer , x , y ) ;
32858: LD_VAR 0 1
32862: PPUSH
32863: LD_VAR 0 2
32867: PPUSH
32868: LD_VAR 0 3
32872: PPUSH
32873: CALL_OW 171
// end ;
32877: LD_VAR 0 4
32881: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32882: LD_INT 0
32884: PPUSH
32885: PPUSH
32886: PPUSH
32887: PPUSH
32888: PPUSH
32889: PPUSH
32890: PPUSH
// dist := 99999 ;
32891: LD_ADDR_VAR 0 6
32895: PUSH
32896: LD_INT 99999
32898: ST_TO_ADDR
// for i = 1 to list do
32899: LD_ADDR_VAR 0 5
32903: PUSH
32904: DOUBLE
32905: LD_INT 1
32907: DEC
32908: ST_TO_ADDR
32909: LD_VAR 0 3
32913: PUSH
32914: FOR_TO
32915: IFFALSE 33053
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32917: LD_ADDR_VAR 0 7
32921: PUSH
32922: LD_VAR 0 1
32926: PPUSH
32927: LD_VAR 0 2
32931: PPUSH
32932: LD_VAR 0 3
32936: PUSH
32937: LD_VAR 0 5
32941: ARRAY
32942: PUSH
32943: LD_INT 1
32945: ARRAY
32946: PPUSH
32947: LD_VAR 0 3
32951: PUSH
32952: LD_VAR 0 5
32956: ARRAY
32957: PUSH
32958: LD_INT 2
32960: ARRAY
32961: PPUSH
32962: CALL_OW 298
32966: ST_TO_ADDR
// if d = 0 then
32967: LD_VAR 0 7
32971: PUSH
32972: LD_INT 0
32974: EQUAL
32975: IFFALSE 32979
// continue ;
32977: GO 32914
// if d < dist then
32979: LD_VAR 0 7
32983: PUSH
32984: LD_VAR 0 6
32988: LESS
32989: IFFALSE 33051
// begin _x := list [ i ] [ 1 ] ;
32991: LD_ADDR_VAR 0 8
32995: PUSH
32996: LD_VAR 0 3
33000: PUSH
33001: LD_VAR 0 5
33005: ARRAY
33006: PUSH
33007: LD_INT 1
33009: ARRAY
33010: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33011: LD_ADDR_VAR 0 9
33015: PUSH
33016: LD_VAR 0 3
33020: PUSH
33021: LD_VAR 0 5
33025: ARRAY
33026: PUSH
33027: LD_INT 2
33029: ARRAY
33030: ST_TO_ADDR
// _i := i ;
33031: LD_ADDR_VAR 0 10
33035: PUSH
33036: LD_VAR 0 5
33040: ST_TO_ADDR
// dist := d ;
33041: LD_ADDR_VAR 0 6
33045: PUSH
33046: LD_VAR 0 7
33050: ST_TO_ADDR
// end ; end ;
33051: GO 32914
33053: POP
33054: POP
// result := [ _x , _y , _i , dist ] ;
33055: LD_ADDR_VAR 0 4
33059: PUSH
33060: LD_VAR 0 8
33064: PUSH
33065: LD_VAR 0 9
33069: PUSH
33070: LD_VAR 0 10
33074: PUSH
33075: LD_VAR 0 6
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: ST_TO_ADDR
// end ;
33086: LD_VAR 0 4
33090: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33091: LD_INT 0
33093: PPUSH
33094: PPUSH
33095: PPUSH
33096: PPUSH
33097: PPUSH
// for i = 1 to list do
33098: LD_ADDR_VAR 0 5
33102: PUSH
33103: DOUBLE
33104: LD_INT 1
33106: DEC
33107: ST_TO_ADDR
33108: LD_VAR 0 1
33112: PUSH
33113: FOR_TO
33114: IFFALSE 33428
// begin for j = list downto 2 do
33116: LD_ADDR_VAR 0 6
33120: PUSH
33121: DOUBLE
33122: LD_VAR 0 1
33126: INC
33127: ST_TO_ADDR
33128: LD_INT 2
33130: PUSH
33131: FOR_DOWNTO
33132: IFFALSE 33424
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33134: LD_VAR 0 2
33138: PPUSH
33139: LD_VAR 0 3
33143: PPUSH
33144: LD_VAR 0 1
33148: PUSH
33149: LD_VAR 0 6
33153: ARRAY
33154: PUSH
33155: LD_INT 1
33157: ARRAY
33158: PPUSH
33159: LD_VAR 0 1
33163: PUSH
33164: LD_VAR 0 6
33168: ARRAY
33169: PUSH
33170: LD_INT 2
33172: ARRAY
33173: PPUSH
33174: CALL_OW 298
33178: PUSH
33179: LD_VAR 0 2
33183: PPUSH
33184: LD_VAR 0 3
33188: PPUSH
33189: LD_VAR 0 1
33193: PUSH
33194: LD_VAR 0 6
33198: PUSH
33199: LD_INT 1
33201: MINUS
33202: ARRAY
33203: PUSH
33204: LD_INT 1
33206: ARRAY
33207: PPUSH
33208: LD_VAR 0 1
33212: PUSH
33213: LD_VAR 0 6
33217: PUSH
33218: LD_INT 1
33220: MINUS
33221: ARRAY
33222: PUSH
33223: LD_INT 2
33225: ARRAY
33226: PPUSH
33227: CALL_OW 298
33231: LESS
33232: IFFALSE 33422
// begin _x := list [ j ] [ 1 ] ;
33234: LD_ADDR_VAR 0 7
33238: PUSH
33239: LD_VAR 0 1
33243: PUSH
33244: LD_VAR 0 6
33248: ARRAY
33249: PUSH
33250: LD_INT 1
33252: ARRAY
33253: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33254: LD_ADDR_VAR 0 8
33258: PUSH
33259: LD_VAR 0 1
33263: PUSH
33264: LD_VAR 0 6
33268: ARRAY
33269: PUSH
33270: LD_INT 2
33272: ARRAY
33273: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33274: LD_ADDR_VAR 0 1
33278: PUSH
33279: LD_VAR 0 1
33283: PPUSH
33284: LD_VAR 0 6
33288: PPUSH
33289: LD_INT 1
33291: PPUSH
33292: LD_VAR 0 1
33296: PUSH
33297: LD_VAR 0 6
33301: PUSH
33302: LD_INT 1
33304: MINUS
33305: ARRAY
33306: PUSH
33307: LD_INT 1
33309: ARRAY
33310: PPUSH
33311: CALL 31052 0 4
33315: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33316: LD_ADDR_VAR 0 1
33320: PUSH
33321: LD_VAR 0 1
33325: PPUSH
33326: LD_VAR 0 6
33330: PPUSH
33331: LD_INT 2
33333: PPUSH
33334: LD_VAR 0 1
33338: PUSH
33339: LD_VAR 0 6
33343: PUSH
33344: LD_INT 1
33346: MINUS
33347: ARRAY
33348: PUSH
33349: LD_INT 2
33351: ARRAY
33352: PPUSH
33353: CALL 31052 0 4
33357: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33358: LD_ADDR_VAR 0 1
33362: PUSH
33363: LD_VAR 0 1
33367: PPUSH
33368: LD_VAR 0 6
33372: PUSH
33373: LD_INT 1
33375: MINUS
33376: PPUSH
33377: LD_INT 1
33379: PPUSH
33380: LD_VAR 0 7
33384: PPUSH
33385: CALL 31052 0 4
33389: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33390: LD_ADDR_VAR 0 1
33394: PUSH
33395: LD_VAR 0 1
33399: PPUSH
33400: LD_VAR 0 6
33404: PUSH
33405: LD_INT 1
33407: MINUS
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 8
33416: PPUSH
33417: CALL 31052 0 4
33421: ST_TO_ADDR
// end ; end ;
33422: GO 33131
33424: POP
33425: POP
// end ;
33426: GO 33113
33428: POP
33429: POP
// result := list ;
33430: LD_ADDR_VAR 0 4
33434: PUSH
33435: LD_VAR 0 1
33439: ST_TO_ADDR
// end ;
33440: LD_VAR 0 4
33444: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33445: LD_INT 0
33447: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33448: LD_ADDR_VAR 0 5
33452: PUSH
33453: LD_VAR 0 1
33457: PPUSH
33458: LD_VAR 0 2
33462: PPUSH
33463: CALL_OW 546
33467: PUSH
33468: LD_INT 2
33470: ARRAY
33471: PUSH
33472: LD_VAR 0 3
33476: PPUSH
33477: LD_VAR 0 4
33481: PPUSH
33482: CALL_OW 546
33486: PUSH
33487: LD_INT 2
33489: ARRAY
33490: MINUS
33491: ST_TO_ADDR
// if result < 0 then
33492: LD_VAR 0 5
33496: PUSH
33497: LD_INT 0
33499: LESS
33500: IFFALSE 33517
// result := result * - 1 ;
33502: LD_ADDR_VAR 0 5
33506: PUSH
33507: LD_VAR 0 5
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: MUL
33516: ST_TO_ADDR
// end ;
33517: LD_VAR 0 5
33521: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33522: LD_INT 0
33524: PPUSH
33525: PPUSH
// area = ListEnvironmentArea ( area ) ;
33526: LD_ADDR_VAR 0 2
33530: PUSH
33531: LD_VAR 0 2
33535: PPUSH
33536: CALL_OW 353
33540: ST_TO_ADDR
// if bulldozer > 0 then
33541: LD_VAR 0 1
33545: PUSH
33546: LD_INT 0
33548: GREATER
33549: IFFALSE 33660
// for i = area downto 1 do
33551: LD_ADDR_VAR 0 4
33555: PUSH
33556: DOUBLE
33557: LD_VAR 0 2
33561: INC
33562: ST_TO_ADDR
33563: LD_INT 1
33565: PUSH
33566: FOR_DOWNTO
33567: IFFALSE 33658
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33569: LD_VAR 0 2
33573: PUSH
33574: LD_VAR 0 4
33578: ARRAY
33579: PUSH
33580: LD_INT 1
33582: ARRAY
33583: PPUSH
33584: LD_VAR 0 2
33588: PUSH
33589: LD_VAR 0 4
33593: ARRAY
33594: PUSH
33595: LD_INT 2
33597: ARRAY
33598: PPUSH
33599: CALL_OW 351
33603: IFFALSE 33656
// if not HasTask ( bulldozer ) then
33605: LD_VAR 0 1
33609: PPUSH
33610: CALL_OW 314
33614: NOT
33615: IFFALSE 33656
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33617: LD_VAR 0 1
33621: PPUSH
33622: LD_VAR 0 2
33626: PUSH
33627: LD_VAR 0 4
33631: ARRAY
33632: PUSH
33633: LD_INT 1
33635: ARRAY
33636: PPUSH
33637: LD_VAR 0 2
33641: PUSH
33642: LD_VAR 0 4
33646: ARRAY
33647: PUSH
33648: LD_INT 2
33650: ARRAY
33651: PPUSH
33652: CALL_OW 171
33656: GO 33566
33658: POP
33659: POP
// end ;
33660: LD_VAR 0 3
33664: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33665: LD_INT 0
33667: PPUSH
33668: PPUSH
33669: PPUSH
33670: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33671: LD_ADDR_VAR 0 6
33675: PUSH
33676: LD_INT 22
33678: PUSH
33679: LD_VAR 0 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 21
33690: PUSH
33691: LD_VAR 0 2
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PPUSH
33704: CALL_OW 69
33708: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33709: LD_ADDR_VAR 0 7
33713: PUSH
33714: LD_VAR 0 3
33718: PPUSH
33719: LD_INT 22
33721: PUSH
33722: LD_VAR 0 1
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 21
33733: PUSH
33734: LD_VAR 0 2
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PPUSH
33747: CALL_OW 70
33751: ST_TO_ADDR
// if tmp and pom then
33752: LD_VAR 0 6
33756: PUSH
33757: LD_VAR 0 7
33761: AND
33762: IFFALSE 33782
// result := tmp diff pom else
33764: LD_ADDR_VAR 0 4
33768: PUSH
33769: LD_VAR 0 6
33773: PUSH
33774: LD_VAR 0 7
33778: DIFF
33779: ST_TO_ADDR
33780: GO 33790
// result := false ;
33782: LD_ADDR_VAR 0 4
33786: PUSH
33787: LD_INT 0
33789: ST_TO_ADDR
// end ;
33790: LD_VAR 0 4
33794: RET
// export function SavePosition ( unit ) ; begin
33795: LD_INT 0
33797: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33798: LD_VAR 0 1
33802: PPUSH
33803: LD_VAR 0 1
33807: PPUSH
33808: CALL_OW 250
33812: PPUSH
33813: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33817: LD_VAR 0 1
33821: PPUSH
33822: LD_VAR 0 1
33826: PPUSH
33827: CALL_OW 251
33831: PPUSH
33832: CALL_OW 232
// end ;
33836: LD_VAR 0 2
33840: RET
// export function GetPosition ( unit ) ; begin
33841: LD_INT 0
33843: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33844: LD_ADDR_VAR 0 2
33848: PUSH
33849: LD_VAR 0 1
33853: PPUSH
33854: CALL_OW 252
33858: PUSH
33859: LD_VAR 0 1
33863: PPUSH
33864: CALL_OW 253
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: ST_TO_ADDR
// end ;
33873: LD_VAR 0 2
33877: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33878: LD_INT 0
33880: PPUSH
// if unit in unreachableList then
33881: LD_VAR 0 1
33885: PUSH
33886: LD_EXP 32
33890: IN
33891: IFFALSE 33909
// unreachableList := unreachableList diff unit ;
33893: LD_ADDR_EXP 32
33897: PUSH
33898: LD_EXP 32
33902: PUSH
33903: LD_VAR 0 1
33907: DIFF
33908: ST_TO_ADDR
// if ValidHex ( x , y ) then
33909: LD_VAR 0 2
33913: PPUSH
33914: LD_VAR 0 3
33918: PPUSH
33919: CALL_OW 488
33923: IFFALSE 33949
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
33925: LD_VAR 0 1
33929: PPUSH
33930: LD_VAR 0 2
33934: PPUSH
33935: LD_VAR 0 3
33939: PPUSH
33940: CALL_OW 428
33944: PPUSH
33945: CALL_OW 115
// Wait ( 3 ) ;
33949: LD_INT 3
33951: PPUSH
33952: CALL_OW 67
// if unit in unreachableList then
33956: LD_VAR 0 1
33960: PUSH
33961: LD_EXP 32
33965: IN
33966: IFFALSE 33978
// result := false else
33968: LD_ADDR_VAR 0 4
33972: PUSH
33973: LD_INT 0
33975: ST_TO_ADDR
33976: GO 33986
// result := true ;
33978: LD_ADDR_VAR 0 4
33982: PUSH
33983: LD_INT 1
33985: ST_TO_ADDR
// end ; end_of_file
33986: LD_VAR 0 4
33990: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
33991: LD_EXP 33
33995: IFFALSE 34057
33997: GO 33999
33999: DISABLE
34000: LD_INT 0
34002: PPUSH
// begin enable ;
34003: ENABLE
// for i = 1 to mc_crates_list do
34004: LD_ADDR_VAR 0 1
34008: PUSH
34009: DOUBLE
34010: LD_INT 1
34012: DEC
34013: ST_TO_ADDR
34014: LD_EXP 34
34018: PUSH
34019: FOR_TO
34020: IFFALSE 34051
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34022: LD_EXP 34
34026: PUSH
34027: LD_VAR 0 1
34031: ARRAY
34032: PPUSH
34033: LD_INT 5
34035: PPUSH
34036: LD_INT 50
34038: PPUSH
34039: LD_INT 700
34041: PPUSH
34042: LD_INT 20
34044: PPUSH
34045: CALL 24421 0 5
34049: GO 34019
34051: POP
34052: POP
// MC_Game ( ) ;
34053: CALL 34060 0 0
// end ;
34057: PPOPN 1
34059: END
// export function MC_Game ( ) ; var i , side , un ; begin
34060: LD_INT 0
34062: PPUSH
34063: PPUSH
34064: PPUSH
34065: PPUSH
// if not isTest then
34066: LD_EXP 1
34070: NOT
34071: IFFALSE 34091
// MC_Show ( [ #tick , tick ] ) else
34073: LD_STRING #tick
34075: PUSH
34076: LD_OWVAR 1
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PPUSH
34085: CALL 8505 0 1
34089: GO 34100
// MC_Show ( debug_string ) ;
34091: LD_EXP 2
34095: PPUSH
34096: CALL 8505 0 1
// for side = 1 to 8 do
34100: LD_ADDR_VAR 0 3
34104: PUSH
34105: DOUBLE
34106: LD_INT 1
34108: DEC
34109: ST_TO_ADDR
34110: LD_INT 8
34112: PUSH
34113: FOR_TO
34114: IFFALSE 36114
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34116: LD_EXP 41
34120: PUSH
34121: LD_VAR 0 3
34125: ARRAY
34126: PUSH
34127: LD_INT 0
34129: EQUAL
34130: PUSH
34131: LD_VAR 0 3
34135: PPUSH
34136: EMPTY
34137: PPUSH
34138: CALL 11722 0 2
34142: PUSH
34143: LD_INT 0
34145: EQUAL
34146: OR
34147: IFFALSE 34151
// continue ;
34149: GO 34113
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34151: LD_VAR 0 3
34155: PPUSH
34156: LD_VAR 0 3
34160: PPUSH
34161: CALL 24942 0 1
34165: PPUSH
34166: CALL 36121 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34170: LD_EXP 73
34174: PUSH
34175: LD_VAR 0 3
34179: ARRAY
34180: PUSH
34181: LD_INT 1
34183: ARRAY
34184: PUSH
34185: LD_INT 0
34187: GREATER
34188: PUSH
34189: LD_EXP 71
34193: PUSH
34194: LD_VAR 0 3
34198: ARRAY
34199: PUSH
34200: LD_INT 1
34202: ARRAY
34203: PUSH
34204: LD_INT 0
34206: EQUAL
34207: AND
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: LD_INT 7
34216: PPUSH
34217: EMPTY
34218: PPUSH
34219: CALL 12290 0 3
34223: NOT
34224: AND
34225: IFFALSE 34296
// begin if side = 1 then
34227: LD_VAR 0 3
34231: PUSH
34232: LD_INT 1
34234: EQUAL
34235: IFFALSE 34244
// RaiseSailEvent ( 101 ) ;
34237: LD_INT 101
34239: PPUSH
34240: CALL_OW 427
// if side = 4 then
34244: LD_VAR 0 3
34248: PUSH
34249: LD_INT 4
34251: EQUAL
34252: IFFALSE 34261
// RaiseSailEvent ( 102 ) ;
34254: LD_INT 102
34256: PPUSH
34257: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34261: LD_ADDR_VAR 0 2
34265: PUSH
34266: LD_EXP 73
34270: PUSH
34271: LD_VAR 0 3
34275: ARRAY
34276: PUSH
34277: FOR_IN
34278: IFFALSE 34294
// SetTag ( i , 7 ) ;
34280: LD_VAR 0 2
34284: PPUSH
34285: LD_INT 7
34287: PPUSH
34288: CALL_OW 109
34292: GO 34277
34294: POP
34295: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34296: LD_VAR 0 3
34300: PPUSH
34301: LD_INT 7
34303: PPUSH
34304: EMPTY
34305: PPUSH
34306: CALL 12290 0 3
34310: IFFALSE 34336
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34312: LD_VAR 0 3
34316: PPUSH
34317: LD_VAR 0 3
34321: PPUSH
34322: LD_INT 7
34324: PPUSH
34325: EMPTY
34326: PPUSH
34327: CALL 12290 0 3
34331: PPUSH
34332: CALL 8432 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34336: LD_VAR 0 3
34340: PPUSH
34341: CALL 17970 0 1
34345: PUSH
34346: LD_VAR 0 3
34350: PPUSH
34351: CALL 11626 0 1
34355: AND
34356: IFFALSE 34367
// MCL_Start ( side ) ;
34358: LD_VAR 0 3
34362: PPUSH
34363: CALL 17927 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34367: LD_ADDR_EXP 37
34371: PUSH
34372: LD_EXP 37
34376: PPUSH
34377: LD_VAR 0 3
34381: PPUSH
34382: LD_VAR 0 3
34386: PPUSH
34387: CALL 19227 0 1
34391: PPUSH
34392: CALL_OW 1
34396: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34397: LD_ADDR_EXP 49
34401: PUSH
34402: LD_EXP 49
34406: PPUSH
34407: LD_VAR 0 3
34411: PPUSH
34412: LD_VAR 0 3
34416: PPUSH
34417: CALL 11040 0 1
34421: PPUSH
34422: CALL_OW 1
34426: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34427: LD_VAR 0 3
34431: PPUSH
34432: LD_INT 21
34434: PUSH
34435: LD_INT 2
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PPUSH
34442: CALL 11587 0 2
34446: IFFALSE 34457
// MCV_CheckStatus ( side ) ;
34448: LD_VAR 0 3
34452: PPUSH
34453: CALL 27124 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34457: LD_VAR 0 3
34461: PPUSH
34462: LD_EXP 55
34466: PPUSH
34467: CALL 42921 0 2
34471: IFFALSE 34556
// begin for i = MREG_ToChangeClass downto 1 do
34473: LD_ADDR_VAR 0 2
34477: PUSH
34478: DOUBLE
34479: LD_EXP 55
34483: INC
34484: ST_TO_ADDR
34485: LD_INT 1
34487: PUSH
34488: FOR_DOWNTO
34489: IFFALSE 34554
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34491: LD_EXP 55
34495: PUSH
34496: LD_VAR 0 2
34500: ARRAY
34501: PUSH
34502: LD_INT 1
34504: ARRAY
34505: PUSH
34506: LD_VAR 0 3
34510: EQUAL
34511: IFFALSE 34552
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34513: LD_VAR 0 3
34517: PPUSH
34518: LD_EXP 55
34522: PUSH
34523: LD_VAR 0 2
34527: ARRAY
34528: PUSH
34529: LD_INT 2
34531: ARRAY
34532: PPUSH
34533: LD_EXP 55
34537: PUSH
34538: LD_VAR 0 2
34542: ARRAY
34543: PUSH
34544: LD_INT 3
34546: ARRAY
34547: PPUSH
34548: CALL 16494 0 3
// end ; end ;
34552: GO 34488
34554: POP
34555: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34556: LD_INT 1
34558: PUSH
34559: LD_EXP 40
34563: PUSH
34564: LD_VAR 0 3
34568: ARRAY
34569: IN
34570: IFFALSE 34581
// begin MCN_TrainApe ( side ) ;
34572: LD_VAR 0 3
34576: PPUSH
34577: CALL 18880 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34581: LD_VAR 0 3
34585: PPUSH
34586: LD_INT 30
34588: PUSH
34589: LD_INT 3
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PPUSH
34596: CALL 11587 0 2
34600: IFFALSE 34774
// begin if MCF_Tag ( side , 10 , [ ] ) then
34602: LD_VAR 0 3
34606: PPUSH
34607: LD_INT 10
34609: PPUSH
34610: EMPTY
34611: PPUSH
34612: CALL 12290 0 3
34616: IFFALSE 34663
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34618: LD_VAR 0 3
34622: PPUSH
34623: LD_INT 10
34625: PPUSH
34626: EMPTY
34627: PPUSH
34628: CALL 12290 0 3
34632: PPUSH
34633: LD_VAR 0 3
34637: PPUSH
34638: LD_INT 30
34640: PUSH
34641: LD_INT 3
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PPUSH
34648: CALL 11587 0 2
34652: PUSH
34653: LD_INT 1
34655: ARRAY
34656: PPUSH
34657: CALL_OW 168
// end else
34661: GO 34774
// if MREG_ToConstruct [ side ] then
34663: LD_EXP 53
34667: PUSH
34668: LD_VAR 0 3
34672: ARRAY
34673: IFFALSE 34774
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 30
34687: PUSH
34688: LD_INT 3
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PPUSH
34695: CALL 11587 0 2
34699: PUSH
34700: LD_INT 1
34702: ARRAY
34703: PPUSH
34704: LD_EXP 53
34708: PUSH
34709: LD_VAR 0 3
34713: ARRAY
34714: PUSH
34715: LD_INT 1
34717: ARRAY
34718: PUSH
34719: LD_EXP 53
34723: PUSH
34724: LD_VAR 0 3
34728: ARRAY
34729: PUSH
34730: LD_INT 2
34732: ARRAY
34733: PUSH
34734: LD_EXP 53
34738: PUSH
34739: LD_VAR 0 3
34743: ARRAY
34744: PUSH
34745: LD_INT 3
34747: ARRAY
34748: PUSH
34749: LD_EXP 53
34753: PUSH
34754: LD_VAR 0 3
34758: ARRAY
34759: PUSH
34760: LD_INT 4
34762: ARRAY
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: PPUSH
34770: CALL 25432 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PPUSH
34789: CALL 11587 0 2
34793: PUSH
34794: LD_VAR 0 3
34798: PPUSH
34799: LD_EXP 45
34803: PPUSH
34804: CALL 42921 0 2
34808: AND
34809: PUSH
34810: LD_INT 22
34812: PUSH
34813: LD_VAR 0 3
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 2
34824: PUSH
34825: LD_INT 30
34827: PUSH
34828: LD_INT 33
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 30
34837: PUSH
34838: LD_INT 32
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 35
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: LIST
34864: PPUSH
34865: CALL_OW 69
34869: AND
34870: IFFALSE 34881
// MCV_Turret ( side ) ;
34872: LD_VAR 0 3
34876: PPUSH
34877: CALL 25869 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34881: LD_EXP 44
34885: PUSH
34886: LD_VAR 0 3
34890: ARRAY
34891: PUSH
34892: LD_INT 1
34894: GREATER
34895: PUSH
34896: LD_VAR 0 3
34900: PPUSH
34901: CALL 24942 0 1
34905: PUSH
34906: LD_INT 0
34908: EQUAL
34909: AND
34910: IFFALSE 35072
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34912: LD_EXP 44
34916: PUSH
34917: LD_VAR 0 3
34921: ARRAY
34922: PUSH
34923: LD_INT 1
34925: ARRAY
34926: PPUSH
34927: CALL_OW 353
34931: IFFALSE 34969
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
34933: LD_EXP 44
34937: PUSH
34938: LD_VAR 0 3
34942: ARRAY
34943: PUSH
34944: LD_INT 2
34946: ARRAY
34947: PPUSH
34948: LD_EXP 44
34952: PUSH
34953: LD_VAR 0 3
34957: ARRAY
34958: PUSH
34959: LD_INT 1
34961: ARRAY
34962: PPUSH
34963: CALL 32350 0 2
34967: GO 35072
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
34969: LD_VAR 0 3
34973: PPUSH
34974: LD_INT 30
34976: PUSH
34977: LD_INT 3
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PPUSH
34984: CALL 11587 0 2
34988: IFFALSE 35072
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
34990: LD_VAR 0 3
34994: PPUSH
34995: LD_INT 30
34997: PUSH
34998: LD_INT 3
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PPUSH
35005: CALL 11587 0 2
35009: PUSH
35010: LD_INT 1
35012: ARRAY
35013: PPUSH
35014: CALL_OW 461
35018: PUSH
35019: LD_INT 2
35021: EQUAL
35022: IFFALSE 35072
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35024: LD_EXP 44
35028: PUSH
35029: LD_VAR 0 3
35033: ARRAY
35034: PUSH
35035: LD_INT 2
35037: ARRAY
35038: PPUSH
35039: LD_INT 10
35041: PPUSH
35042: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35046: LD_ADDR_EXP 44
35050: PUSH
35051: LD_EXP 44
35055: PPUSH
35056: LD_VAR 0 3
35060: PPUSH
35061: LD_INT 0
35063: PUSH
35064: EMPTY
35065: LIST
35066: PPUSH
35067: CALL_OW 1
35071: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35072: LD_VAR 0 3
35076: PPUSH
35077: LD_INT 33
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PPUSH
35087: CALL 11587 0 2
35091: IFFALSE 35131
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35093: LD_VAR 0 3
35097: PPUSH
35098: LD_VAR 0 3
35102: PPUSH
35103: LD_INT 33
35105: PUSH
35106: LD_INT 2
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PPUSH
35113: CALL 11587 0 2
35117: PUSH
35118: LD_INT 1
35120: ARRAY
35121: PPUSH
35122: CALL_OW 248
35126: PPUSH
35127: CALL 26423 0 2
// if MREG_ToRepair [ side ] then
35131: LD_EXP 49
35135: PUSH
35136: LD_VAR 0 3
35140: ARRAY
35141: IFFALSE 35154
// begin MCB_Repair ( side ) ;
35143: LD_VAR 0 3
35147: PPUSH
35148: CALL 11327 0 1
// end else
35152: GO 36067
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35154: LD_VAR 0 3
35158: PPUSH
35159: LD_EXP 51
35163: PPUSH
35164: CALL 42921 0 2
35168: PUSH
35169: LD_VAR 0 3
35173: PPUSH
35174: LD_EXP 42
35178: PPUSH
35179: CALL 42921 0 2
35183: AND
35184: IFFALSE 35392
// begin for i = 1 to MREG_ToUpLab do
35186: LD_ADDR_VAR 0 2
35190: PUSH
35191: DOUBLE
35192: LD_INT 1
35194: DEC
35195: ST_TO_ADDR
35196: LD_EXP 51
35200: PUSH
35201: FOR_TO
35202: IFFALSE 35388
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35204: LD_EXP 51
35208: PUSH
35209: LD_VAR 0 2
35213: ARRAY
35214: PUSH
35215: LD_INT 1
35217: ARRAY
35218: PUSH
35219: LD_VAR 0 3
35223: EQUAL
35224: IFFALSE 35386
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35226: LD_EXP 51
35230: PUSH
35231: LD_VAR 0 2
35235: ARRAY
35236: PUSH
35237: LD_INT 2
35239: ARRAY
35240: PUSH
35241: LD_EXP 51
35245: PUSH
35246: LD_VAR 0 2
35250: ARRAY
35251: PUSH
35252: LD_INT 3
35254: ARRAY
35255: AND
35256: IFFALSE 35384
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35258: LD_VAR 0 3
35262: PPUSH
35263: LD_EXP 51
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PUSH
35274: LD_INT 2
35276: ARRAY
35277: PPUSH
35278: LD_EXP 51
35282: PUSH
35283: LD_VAR 0 2
35287: ARRAY
35288: PUSH
35289: LD_INT 3
35291: ARRAY
35292: PPUSH
35293: CALL 8851 0 3
35297: IFFALSE 35384
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35299: LD_ADDR_EXP 51
35303: PUSH
35304: LD_EXP 51
35308: PPUSH
35309: LD_VAR 0 3
35313: PPUSH
35314: LD_EXP 51
35318: PUSH
35319: LD_VAR 0 2
35323: ARRAY
35324: PUSH
35325: LD_INT 2
35327: ARRAY
35328: PPUSH
35329: LD_EXP 51
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: PUSH
35340: LD_INT 3
35342: ARRAY
35343: PPUSH
35344: CALL 41973 0 4
35348: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35349: LD_ADDR_EXP 42
35353: PUSH
35354: LD_EXP 42
35358: PPUSH
35359: LD_VAR 0 3
35363: PPUSH
35364: LD_EXP 42
35368: PUSH
35369: LD_INT 1
35371: ARRAY
35372: PUSH
35373: LD_INT 2
35375: ARRAY
35376: PPUSH
35377: EMPTY
35378: PPUSH
35379: CALL 41973 0 4
35383: ST_TO_ADDR
// end ; break ;
35384: GO 35388
// end ;
35386: GO 35201
35388: POP
35389: POP
// end else
35390: GO 36067
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35392: LD_VAR 0 3
35396: PPUSH
35397: LD_EXP 50
35401: PPUSH
35402: CALL 42921 0 2
35406: IFFALSE 35480
// begin for i = 1 to MREG_ToUpdate do
35408: LD_ADDR_VAR 0 2
35412: PUSH
35413: DOUBLE
35414: LD_INT 1
35416: DEC
35417: ST_TO_ADDR
35418: LD_EXP 50
35422: PUSH
35423: FOR_TO
35424: IFFALSE 35476
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35426: LD_EXP 50
35430: PUSH
35431: LD_VAR 0 2
35435: ARRAY
35436: PUSH
35437: LD_INT 1
35439: ARRAY
35440: PUSH
35441: LD_VAR 0 3
35445: EQUAL
35446: IFFALSE 35474
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35448: LD_VAR 0 3
35452: PPUSH
35453: LD_EXP 50
35457: PUSH
35458: LD_VAR 0 2
35462: ARRAY
35463: PUSH
35464: LD_INT 2
35466: ARRAY
35467: PPUSH
35468: CALL 8687 0 2
// break ;
35472: GO 35476
// end ;
35474: GO 35423
35476: POP
35477: POP
// end else
35478: GO 36067
// if MCF_Get ( side , [ f_constructed ] ) then
35480: LD_VAR 0 3
35484: PPUSH
35485: LD_INT 57
35487: PUSH
35488: EMPTY
35489: LIST
35490: PPUSH
35491: CALL 11587 0 2
35495: IFFALSE 35528
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35497: LD_VAR 0 3
35501: PPUSH
35502: LD_VAR 0 3
35506: PPUSH
35507: LD_INT 57
35509: PUSH
35510: EMPTY
35511: LIST
35512: PPUSH
35513: CALL 11587 0 2
35517: PUSH
35518: LD_INT 1
35520: ARRAY
35521: PPUSH
35522: CALL 10931 0 2
35526: GO 36067
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_EXP 48
35537: PPUSH
35538: CALL 42921 0 2
35542: PUSH
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL_OW 345
35552: NOT
35553: AND
35554: PUSH
35555: LD_VAR 0 3
35559: PPUSH
35560: CALL 24942 0 1
35564: PUSH
35565: LD_INT 0
35567: EQUAL
35568: AND
35569: IFFALSE 35968
// begin for i = 1 to MREG_ToBuild do
35571: LD_ADDR_VAR 0 2
35575: PUSH
35576: DOUBLE
35577: LD_INT 1
35579: DEC
35580: ST_TO_ADDR
35581: LD_EXP 48
35585: PUSH
35586: FOR_TO
35587: IFFALSE 35964
// if MREG_ToBuild [ i ] [ 1 ] = side then
35589: LD_EXP 48
35593: PUSH
35594: LD_VAR 0 2
35598: ARRAY
35599: PUSH
35600: LD_INT 1
35602: ARRAY
35603: PUSH
35604: LD_VAR 0 3
35608: EQUAL
35609: IFFALSE 35962
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35611: LD_OWVAR 84
35615: PUSH
35616: LD_EXP 48
35620: PUSH
35621: LD_VAR 0 2
35625: ARRAY
35626: PUSH
35627: LD_INT 3
35629: ARRAY
35630: PUSH
35631: LD_INT 1
35633: ARRAY
35634: PPUSH
35635: LD_EXP 48
35639: PUSH
35640: LD_VAR 0 2
35644: ARRAY
35645: PUSH
35646: LD_INT 3
35648: ARRAY
35649: PUSH
35650: LD_INT 2
35652: ARRAY
35653: PPUSH
35654: CALL_OW 351
35658: AND
35659: IFFALSE 35703
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35661: LD_EXP 48
35665: PUSH
35666: LD_VAR 0 2
35670: ARRAY
35671: PUSH
35672: LD_INT 3
35674: ARRAY
35675: PUSH
35676: LD_INT 1
35678: ARRAY
35679: PPUSH
35680: LD_EXP 48
35684: PUSH
35685: LD_VAR 0 2
35689: ARRAY
35690: PUSH
35691: LD_INT 3
35693: ARRAY
35694: PUSH
35695: LD_INT 2
35697: ARRAY
35698: PPUSH
35699: CALL 22735 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35703: LD_EXP 48
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: PUSH
35714: LD_INT 2
35716: ARRAY
35717: PUSH
35718: LD_INT 0
35720: EQUAL
35721: IFFALSE 35791
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35723: LD_VAR 0 3
35727: PPUSH
35728: LD_EXP 48
35732: PUSH
35733: LD_VAR 0 2
35737: ARRAY
35738: PUSH
35739: LD_INT 3
35741: ARRAY
35742: PUSH
35743: LD_INT 1
35745: ARRAY
35746: PPUSH
35747: LD_EXP 48
35751: PUSH
35752: LD_VAR 0 2
35756: ARRAY
35757: PUSH
35758: LD_INT 3
35760: ARRAY
35761: PUSH
35762: LD_INT 2
35764: ARRAY
35765: PPUSH
35766: LD_EXP 48
35770: PUSH
35771: LD_VAR 0 2
35775: ARRAY
35776: PUSH
35777: LD_INT 3
35779: ARRAY
35780: PUSH
35781: LD_INT 3
35783: ARRAY
35784: PPUSH
35785: CALL 8523 0 4
35789: GO 35960
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35791: LD_EXP 48
35795: PUSH
35796: LD_VAR 0 2
35800: ARRAY
35801: PUSH
35802: LD_INT 2
35804: ARRAY
35805: PUSH
35806: LD_INT 6
35808: EQUAL
35809: IFFALSE 35879
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35811: LD_VAR 0 3
35815: PPUSH
35816: LD_EXP 48
35820: PUSH
35821: LD_VAR 0 2
35825: ARRAY
35826: PUSH
35827: LD_INT 3
35829: ARRAY
35830: PUSH
35831: LD_INT 1
35833: ARRAY
35834: PPUSH
35835: LD_EXP 48
35839: PUSH
35840: LD_VAR 0 2
35844: ARRAY
35845: PUSH
35846: LD_INT 3
35848: ARRAY
35849: PUSH
35850: LD_INT 2
35852: ARRAY
35853: PPUSH
35854: LD_EXP 48
35858: PUSH
35859: LD_VAR 0 2
35863: ARRAY
35864: PUSH
35865: LD_INT 3
35867: ARRAY
35868: PUSH
35869: LD_INT 3
35871: ARRAY
35872: PPUSH
35873: CALL 8652 0 4
35877: GO 35960
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35879: LD_VAR 0 3
35883: PPUSH
35884: LD_EXP 48
35888: PUSH
35889: LD_VAR 0 2
35893: ARRAY
35894: PUSH
35895: LD_INT 2
35897: ARRAY
35898: PPUSH
35899: LD_EXP 48
35903: PUSH
35904: LD_VAR 0 2
35908: ARRAY
35909: PUSH
35910: LD_INT 3
35912: ARRAY
35913: PUSH
35914: LD_INT 1
35916: ARRAY
35917: PPUSH
35918: LD_EXP 48
35922: PUSH
35923: LD_VAR 0 2
35927: ARRAY
35928: PUSH
35929: LD_INT 3
35931: ARRAY
35932: PUSH
35933: LD_INT 2
35935: ARRAY
35936: PPUSH
35937: LD_EXP 48
35941: PUSH
35942: LD_VAR 0 2
35946: ARRAY
35947: PUSH
35948: LD_INT 3
35950: ARRAY
35951: PUSH
35952: LD_INT 3
35954: ARRAY
35955: PPUSH
35956: CALL 10156 0 5
// break ;
35960: GO 35964
// end ;
35962: GO 35586
35964: POP
35965: POP
// end else
35966: GO 36067
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
35968: LD_VAR 0 3
35972: PPUSH
35973: LD_EXP 54
35977: PPUSH
35978: CALL 42921 0 2
35982: PUSH
35983: LD_VAR 0 3
35987: PPUSH
35988: CALL 24942 0 1
35992: PUSH
35993: LD_INT 0
35995: EQUAL
35996: AND
35997: IFFALSE 36067
// begin for i = 1 to MREG_ToDismantle do
35999: LD_ADDR_VAR 0 2
36003: PUSH
36004: DOUBLE
36005: LD_INT 1
36007: DEC
36008: ST_TO_ADDR
36009: LD_EXP 54
36013: PUSH
36014: FOR_TO
36015: IFFALSE 36065
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36017: LD_EXP 54
36021: PUSH
36022: LD_VAR 0 2
36026: ARRAY
36027: PUSH
36028: LD_INT 1
36030: ARRAY
36031: PUSH
36032: LD_VAR 0 3
36036: EQUAL
36037: IFFALSE 36063
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36039: LD_VAR 0 3
36043: PPUSH
36044: LD_EXP 54
36048: PUSH
36049: LD_VAR 0 2
36053: ARRAY
36054: PUSH
36055: LD_INT 2
36057: ARRAY
36058: PPUSH
36059: CALL 10822 0 2
// end ;
36063: GO 36014
36065: POP
36066: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36067: LD_VAR 0 3
36071: PPUSH
36072: LD_INT 30
36074: PUSH
36075: LD_INT 1
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PPUSH
36082: CALL 11587 0 2
36086: PUSH
36087: LD_VAR 0 3
36091: PPUSH
36092: CALL 24942 0 1
36096: PUSH
36097: LD_INT 0
36099: EQUAL
36100: AND
36101: IFFALSE 36112
// MCT_CollectCrates ( side ) ;
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL 23881 0 1
// end ;
36112: GO 34113
36114: POP
36115: POP
// end ;
36116: LD_VAR 0 1
36120: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36121: LD_INT 0
36123: PPUSH
36124: PPUSH
36125: PPUSH
36126: PPUSH
36127: PPUSH
36128: PPUSH
36129: PPUSH
36130: PPUSH
36131: PPUSH
36132: PPUSH
36133: PPUSH
36134: PPUSH
36135: PPUSH
36136: PPUSH
36137: PPUSH
// all := MCF_All ( side , [ ] ) ;
36138: LD_ADDR_VAR 0 17
36142: PUSH
36143: LD_VAR 0 1
36147: PPUSH
36148: EMPTY
36149: PPUSH
36150: CALL 11722 0 2
36154: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36155: LD_ADDR_VAR 0 13
36159: PUSH
36160: LD_VAR 0 1
36164: PPUSH
36165: LD_INT 1
36167: PPUSH
36168: EMPTY
36169: PPUSH
36170: CALL 11670 0 3
36174: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36175: LD_ADDR_VAR 0 14
36179: PUSH
36180: LD_VAR 0 1
36184: PPUSH
36185: LD_INT 2
36187: PPUSH
36188: EMPTY
36189: PPUSH
36190: CALL 11670 0 3
36194: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36195: LD_ADDR_VAR 0 15
36199: PUSH
36200: LD_VAR 0 1
36204: PPUSH
36205: LD_INT 3
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL 11670 0 3
36214: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36215: LD_ADDR_VAR 0 16
36219: PUSH
36220: LD_VAR 0 1
36224: PPUSH
36225: LD_INT 4
36227: PPUSH
36228: EMPTY
36229: PPUSH
36230: CALL 11670 0 3
36234: ST_TO_ADDR
// if mech then
36235: LD_VAR 0 15
36239: IFFALSE 36256
// mech := MCF_SortListDesc ( mech ) ;
36241: LD_ADDR_VAR 0 15
36245: PUSH
36246: LD_VAR 0 15
36250: PPUSH
36251: CALL 12836 0 1
36255: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36256: LD_EXP 58
36260: PUSH
36261: LD_VAR 0 1
36265: ARRAY
36266: PUSH
36267: LD_STRING 
36269: EQUAL
36270: NOT
36271: IFFALSE 36327
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36273: LD_EXP 58
36277: PUSH
36278: LD_VAR 0 1
36282: ARRAY
36283: PUSH
36284: LD_INT 1
36286: ARRAY
36287: PPUSH
36288: CALL_OW 257
36292: PUSH
36293: LD_INT 1
36295: EQUAL
36296: IFFALSE 36325
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_STRING ToArm
36305: PPUSH
36306: LD_EXP 58
36310: PUSH
36311: LD_VAR 0 1
36315: ARRAY
36316: PUSH
36317: LD_INT 1
36319: ARRAY
36320: PPUSH
36321: CALL 14466 0 3
// end else
36325: GO 36353
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36327: LD_ADDR_EXP 58
36331: PUSH
36332: LD_EXP 58
36336: PPUSH
36337: LD_VAR 0 1
36341: PPUSH
36342: LD_INT 1
36344: PPUSH
36345: LD_INT 0
36347: PPUSH
36348: CALL 31052 0 4
36352: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36353: LD_EXP 59
36357: PUSH
36358: LD_VAR 0 1
36362: ARRAY
36363: PUSH
36364: LD_STRING 
36366: EQUAL
36367: NOT
36368: IFFALSE 36424
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36370: LD_EXP 59
36374: PUSH
36375: LD_VAR 0 1
36379: ARRAY
36380: PUSH
36381: LD_INT 1
36383: ARRAY
36384: PPUSH
36385: CALL_OW 257
36389: PUSH
36390: LD_INT 2
36392: EQUAL
36393: IFFALSE 36422
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36395: LD_VAR 0 1
36399: PPUSH
36400: LD_STRING ToDep
36402: PPUSH
36403: LD_EXP 59
36407: PUSH
36408: LD_VAR 0 1
36412: ARRAY
36413: PUSH
36414: LD_INT 1
36416: ARRAY
36417: PPUSH
36418: CALL 14466 0 3
// end else
36422: GO 36450
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36424: LD_ADDR_EXP 59
36428: PUSH
36429: LD_EXP 59
36433: PPUSH
36434: LD_VAR 0 1
36438: PPUSH
36439: LD_INT 1
36441: PPUSH
36442: LD_INT 0
36444: PPUSH
36445: CALL 31052 0 4
36449: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36450: LD_EXP 57
36454: PUSH
36455: LD_VAR 0 1
36459: ARRAY
36460: PUSH
36461: LD_STRING 
36463: EQUAL
36464: NOT
36465: IFFALSE 36521
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36467: LD_EXP 57
36471: PUSH
36472: LD_VAR 0 1
36476: ARRAY
36477: PUSH
36478: LD_INT 1
36480: ARRAY
36481: PPUSH
36482: CALL_OW 257
36486: PUSH
36487: LD_INT 3
36489: EQUAL
36490: IFFALSE 36519
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36492: LD_VAR 0 1
36496: PPUSH
36497: LD_STRING ToFac
36499: PPUSH
36500: LD_EXP 57
36504: PUSH
36505: LD_VAR 0 1
36509: ARRAY
36510: PUSH
36511: LD_INT 1
36513: ARRAY
36514: PPUSH
36515: CALL 14466 0 3
// end else
36519: GO 36547
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36521: LD_ADDR_EXP 57
36525: PUSH
36526: LD_EXP 57
36530: PPUSH
36531: LD_VAR 0 1
36535: PPUSH
36536: LD_INT 1
36538: PPUSH
36539: LD_INT 0
36541: PPUSH
36542: CALL 31052 0 4
36546: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36547: LD_EXP 56
36551: PUSH
36552: LD_VAR 0 1
36556: ARRAY
36557: PUSH
36558: LD_STRING 
36560: EQUAL
36561: NOT
36562: IFFALSE 36618
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36564: LD_EXP 56
36568: PUSH
36569: LD_VAR 0 1
36573: ARRAY
36574: PUSH
36575: LD_INT 1
36577: ARRAY
36578: PPUSH
36579: CALL_OW 257
36583: PUSH
36584: LD_INT 4
36586: EQUAL
36587: IFFALSE 36616
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36589: LD_VAR 0 1
36593: PPUSH
36594: LD_STRING ToLab
36596: PPUSH
36597: LD_EXP 56
36601: PUSH
36602: LD_VAR 0 1
36606: ARRAY
36607: PUSH
36608: LD_INT 1
36610: ARRAY
36611: PPUSH
36612: CALL 14466 0 3
// end else
36616: GO 36644
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36618: LD_ADDR_EXP 56
36622: PUSH
36623: LD_EXP 56
36627: PPUSH
36628: LD_VAR 0 1
36632: PPUSH
36633: LD_INT 1
36635: PPUSH
36636: LD_INT 0
36638: PPUSH
36639: CALL 31052 0 4
36643: ST_TO_ADDR
// if mode = 0 then
36644: LD_VAR 0 2
36648: PUSH
36649: LD_INT 0
36651: EQUAL
36652: IFFALSE 38490
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36654: LD_VAR 0 1
36658: PPUSH
36659: LD_INT 30
36661: PUSH
36662: LD_INT 1
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PPUSH
36669: CALL 11587 0 2
36673: PUSH
36674: LD_VAR 0 1
36678: PPUSH
36679: LD_INT 21
36681: PUSH
36682: LD_INT 3
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PPUSH
36689: CALL 11587 0 2
36693: PUSH
36694: LD_INT 1
36696: EQUAL
36697: AND
36698: IFFALSE 36763
// begin if all then
36700: LD_VAR 0 17
36704: IFFALSE 36761
// for i in ( all diff eng ) do
36706: LD_ADDR_VAR 0 4
36710: PUSH
36711: LD_VAR 0 17
36715: PUSH
36716: LD_VAR 0 14
36720: DIFF
36721: PUSH
36722: FOR_IN
36723: IFFALSE 36759
// if GetTag ( i ) = 0 then
36725: LD_VAR 0 4
36729: PPUSH
36730: CALL_OW 110
36734: PUSH
36735: LD_INT 0
36737: EQUAL
36738: IFFALSE 36757
// MCH_ChangeClass ( side , i , 2 ) ;
36740: LD_VAR 0 1
36744: PPUSH
36745: LD_VAR 0 4
36749: PPUSH
36750: LD_INT 2
36752: PPUSH
36753: CALL 16494 0 3
36757: GO 36722
36759: POP
36760: POP
// end else
36761: GO 37082
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36763: LD_VAR 0 13
36767: PUSH
36768: LD_EXP 58
36772: PUSH
36773: LD_VAR 0 1
36777: ARRAY
36778: PLUS
36779: PUSH
36780: LD_INT 22
36782: PUSH
36783: LD_VAR 0 1
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 30
36794: PUSH
36795: LD_INT 32
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PPUSH
36806: CALL_OW 69
36810: LESS
36811: IFFALSE 36836
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36813: LD_VAR 0 1
36817: PPUSH
36818: LD_VAR 0 14
36822: PUSH
36823: LD_INT 1
36825: ARRAY
36826: PPUSH
36827: LD_INT 1
36829: PPUSH
36830: CALL 16494 0 3
// end else
36834: GO 37082
// if sci < 6 and MCF_Lab ( side ) then
36836: LD_VAR 0 16
36840: PUSH
36841: LD_INT 6
36843: LESS
36844: PUSH
36845: LD_VAR 0 1
36849: PPUSH
36850: CALL 11626 0 1
36854: AND
36855: IFFALSE 36960
// begin if MREG_ToBunker [ side ] then
36857: LD_EXP 70
36861: PUSH
36862: LD_VAR 0 1
36866: ARRAY
36867: IFFALSE 36893
// tmp := sol diff MREG_ToBunker [ side ] else
36869: LD_ADDR_VAR 0 12
36873: PUSH
36874: LD_VAR 0 13
36878: PUSH
36879: LD_EXP 70
36883: PUSH
36884: LD_VAR 0 1
36888: ARRAY
36889: DIFF
36890: ST_TO_ADDR
36891: GO 36903
// tmp := sol ;
36893: LD_ADDR_VAR 0 12
36897: PUSH
36898: LD_VAR 0 13
36902: ST_TO_ADDR
// if tmp then
36903: LD_VAR 0 12
36907: IFFALSE 36958
// for i in tmp do
36909: LD_ADDR_VAR 0 4
36913: PUSH
36914: LD_VAR 0 12
36918: PUSH
36919: FOR_IN
36920: IFFALSE 36956
// if GetTag ( i ) = 0 then
36922: LD_VAR 0 4
36926: PPUSH
36927: CALL_OW 110
36931: PUSH
36932: LD_INT 0
36934: EQUAL
36935: IFFALSE 36954
// MCH_ChangeClass ( side , i , 4 ) ;
36937: LD_VAR 0 1
36941: PPUSH
36942: LD_VAR 0 4
36946: PPUSH
36947: LD_INT 4
36949: PPUSH
36950: CALL 16494 0 3
36954: GO 36919
36956: POP
36957: POP
// end else
36958: GO 37082
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
36960: LD_VAR 0 1
36964: PPUSH
36965: LD_INT 30
36967: PUSH
36968: LD_INT 1
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PPUSH
36975: CALL 11587 0 2
36979: IFFALSE 37082
// begin if MREG_ToBunker [ side ] then
36981: LD_EXP 70
36985: PUSH
36986: LD_VAR 0 1
36990: ARRAY
36991: IFFALSE 37017
// tmp := sol diff MREG_ToBunker [ side ] else
36993: LD_ADDR_VAR 0 12
36997: PUSH
36998: LD_VAR 0 13
37002: PUSH
37003: LD_EXP 70
37007: PUSH
37008: LD_VAR 0 1
37012: ARRAY
37013: DIFF
37014: ST_TO_ADDR
37015: GO 37027
// tmp := sol ;
37017: LD_ADDR_VAR 0 12
37021: PUSH
37022: LD_VAR 0 13
37026: ST_TO_ADDR
// if tmp then
37027: LD_VAR 0 12
37031: IFFALSE 37082
// for i in tmp do
37033: LD_ADDR_VAR 0 4
37037: PUSH
37038: LD_VAR 0 12
37042: PUSH
37043: FOR_IN
37044: IFFALSE 37080
// if GetTag ( i ) = 0 then
37046: LD_VAR 0 4
37050: PPUSH
37051: CALL_OW 110
37055: PUSH
37056: LD_INT 0
37058: EQUAL
37059: IFFALSE 37078
// MCH_ChangeClass ( side , i , 2 ) ;
37061: LD_VAR 0 1
37065: PPUSH
37066: LD_VAR 0 4
37070: PPUSH
37071: LD_INT 2
37073: PPUSH
37074: CALL 16494 0 3
37078: GO 37043
37080: POP
37081: POP
// end ; if MCF_Lab ( side ) then
37082: LD_VAR 0 1
37086: PPUSH
37087: CALL 11626 0 1
37091: IFFALSE 37631
// begin if MCL_GetTechList ( side ) then
37093: LD_VAR 0 1
37097: PPUSH
37098: CALL 17970 0 1
37102: IFFALSE 37228
// begin if MREG_ToLab [ side ] then
37104: LD_EXP 56
37108: PUSH
37109: LD_VAR 0 1
37113: ARRAY
37114: IFFALSE 37134
// k := MREG_ToLab [ side ] else
37116: LD_ADDR_VAR 0 8
37120: PUSH
37121: LD_EXP 56
37125: PUSH
37126: LD_VAR 0 1
37130: ARRAY
37131: ST_TO_ADDR
37132: GO 37142
// k := 0 ;
37134: LD_ADDR_VAR 0 8
37138: PUSH
37139: LD_INT 0
37141: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37142: LD_VAR 0 16
37146: PUSH
37147: LD_VAR 0 8
37151: PLUS
37152: PUSH
37153: LD_INT 6
37155: LESSEQUAL
37156: PUSH
37157: LD_VAR 0 17
37161: PUSH
37162: LD_INT 6
37164: GREATER
37165: AND
37166: IFFALSE 37182
// MCH_TrainScientist ( side , 1 ) else
37168: LD_VAR 0 1
37172: PPUSH
37173: LD_INT 1
37175: PPUSH
37176: CALL 16046 0 2
37180: GO 37226
// if all < 6 then
37182: LD_VAR 0 17
37186: PUSH
37187: LD_INT 6
37189: LESS
37190: IFFALSE 37226
// if sci + k < all / 2 then
37192: LD_VAR 0 16
37196: PUSH
37197: LD_VAR 0 8
37201: PLUS
37202: PUSH
37203: LD_VAR 0 17
37207: PUSH
37208: LD_INT 2
37210: DIVREAL
37211: LESS
37212: IFFALSE 37226
// MCH_TrainScientist ( side , 1 ) ;
37214: LD_VAR 0 1
37218: PPUSH
37219: LD_INT 1
37221: PPUSH
37222: CALL 16046 0 2
// end else
37226: GO 37304
// begin if sci > 2 then
37228: LD_VAR 0 16
37232: PUSH
37233: LD_INT 2
37235: GREATER
37236: IFFALSE 37304
// for i = sci downto 2 do
37238: LD_ADDR_VAR 0 4
37242: PUSH
37243: DOUBLE
37244: LD_VAR 0 16
37248: INC
37249: ST_TO_ADDR
37250: LD_INT 2
37252: PUSH
37253: FOR_DOWNTO
37254: IFFALSE 37302
// if GetTag ( sci [ i ] ) = 0 then
37256: LD_VAR 0 16
37260: PUSH
37261: LD_VAR 0 4
37265: ARRAY
37266: PPUSH
37267: CALL_OW 110
37271: PUSH
37272: LD_INT 0
37274: EQUAL
37275: IFFALSE 37300
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37277: LD_VAR 0 1
37281: PPUSH
37282: LD_VAR 0 16
37286: PUSH
37287: LD_VAR 0 4
37291: ARRAY
37292: PPUSH
37293: LD_INT 2
37295: PPUSH
37296: CALL 16494 0 3
37300: GO 37253
37302: POP
37303: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37304: LD_VAR 0 1
37308: PPUSH
37309: CALL 17970 0 1
37313: PUSH
37314: LD_VAR 0 1
37318: PPUSH
37319: CALL 11626 0 1
37323: AND
37324: PUSH
37325: LD_EXP 37
37329: PUSH
37330: LD_VAR 0 1
37334: ARRAY
37335: NOT
37336: AND
37337: IFFALSE 37631
// begin for j = 1 to MCF_Lab ( side ) do
37339: LD_ADDR_VAR 0 5
37343: PUSH
37344: DOUBLE
37345: LD_INT 1
37347: DEC
37348: ST_TO_ADDR
37349: LD_VAR 0 1
37353: PPUSH
37354: CALL 11626 0 1
37358: PUSH
37359: FOR_TO
37360: IFFALSE 37420
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37362: LD_VAR 0 1
37366: PPUSH
37367: CALL 11626 0 1
37371: PUSH
37372: LD_VAR 0 5
37376: ARRAY
37377: PPUSH
37378: CALL_OW 461
37382: PUSH
37383: LD_INT 3
37385: PUSH
37386: LD_INT 6
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: IN
37393: IFFALSE 37418
// begin b := MCF_Lab ( side ) [ j ] ;
37395: LD_ADDR_VAR 0 11
37399: PUSH
37400: LD_VAR 0 1
37404: PPUSH
37405: CALL 11626 0 1
37409: PUSH
37410: LD_VAR 0 5
37414: ARRAY
37415: ST_TO_ADDR
// break ;
37416: GO 37420
// end ;
37418: GO 37359
37420: POP
37421: POP
// if MCF_Class ( side , 4 , [ ] ) then
37422: LD_VAR 0 1
37426: PPUSH
37427: LD_INT 4
37429: PPUSH
37430: EMPTY
37431: PPUSH
37432: CALL 11670 0 3
37436: IFFALSE 37631
// for j in MCF_Class ( side , 4 , [ ] ) do
37438: LD_ADDR_VAR 0 5
37442: PUSH
37443: LD_VAR 0 1
37447: PPUSH
37448: LD_INT 4
37450: PPUSH
37451: EMPTY
37452: PPUSH
37453: CALL 11670 0 3
37457: PUSH
37458: FOR_IN
37459: IFFALSE 37629
// begin if GetTag ( j ) = 0 then
37461: LD_VAR 0 5
37465: PPUSH
37466: CALL_OW 110
37470: PUSH
37471: LD_INT 0
37473: EQUAL
37474: IFFALSE 37565
// begin if IsInUnit ( j ) and b then
37476: LD_VAR 0 5
37480: PPUSH
37481: CALL_OW 310
37485: PUSH
37486: LD_VAR 0 11
37490: AND
37491: IFFALSE 37539
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37493: LD_VAR 0 5
37497: PPUSH
37498: CALL_OW 310
37502: PPUSH
37503: CALL_OW 461
37507: PUSH
37508: LD_INT 2
37510: EQUAL
37511: PUSH
37512: LD_VAR 0 5
37516: PPUSH
37517: CALL_OW 310
37521: PUSH
37522: LD_VAR 0 11
37526: NONEQUAL
37527: AND
37528: IFFALSE 37539
// ComExitBuilding ( j ) ;
37530: LD_VAR 0 5
37534: PPUSH
37535: CALL_OW 122
// if not IsInUnit ( j ) then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 310
37548: NOT
37549: IFFALSE 37565
// ComEnterUnit ( j , b ) ;
37551: LD_VAR 0 5
37555: PPUSH
37556: LD_VAR 0 11
37560: PPUSH
37561: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37565: LD_INT 1
37567: PPUSH
37568: LD_VAR 0 5
37572: PPUSH
37573: CALL_OW 255
37577: PPUSH
37578: CALL_OW 321
37582: PUSH
37583: LD_INT 2
37585: EQUAL
37586: PUSH
37587: LD_VAR 0 5
37591: PPUSH
37592: CALL_OW 255
37596: PPUSH
37597: CALL 24942 0 1
37601: PUSH
37602: LD_INT 0
37604: EQUAL
37605: AND
37606: IFFALSE 37627
// MCN_Tame ( GetSide ( j ) , j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 255
37617: PPUSH
37618: LD_VAR 0 5
37622: PPUSH
37623: CALL 18489 0 2
// end ;
37627: GO 37458
37629: POP
37630: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37631: LD_VAR 0 1
37635: PPUSH
37636: LD_INT 30
37638: PUSH
37639: LD_INT 3
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PPUSH
37646: CALL 11587 0 2
37650: IFFALSE 37909
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37652: LD_ADDR_VAR 0 11
37656: PUSH
37657: LD_VAR 0 1
37661: PPUSH
37662: LD_INT 30
37664: PUSH
37665: LD_INT 3
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PPUSH
37672: CALL 11587 0 2
37676: PUSH
37677: LD_INT 1
37679: ARRAY
37680: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37681: LD_ADDR_VAR 0 12
37685: PUSH
37686: LD_VAR 0 1
37690: PPUSH
37691: LD_INT 0
37693: PPUSH
37694: LD_INT 25
37696: PUSH
37697: LD_INT 3
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PPUSH
37704: CALL 12290 0 3
37708: ST_TO_ADDR
// for i = 1 to tmp do
37709: LD_ADDR_VAR 0 4
37713: PUSH
37714: DOUBLE
37715: LD_INT 1
37717: DEC
37718: ST_TO_ADDR
37719: LD_VAR 0 12
37723: PUSH
37724: FOR_TO
37725: IFFALSE 37785
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37727: LD_VAR 0 12
37731: PUSH
37732: LD_VAR 0 4
37736: ARRAY
37737: PPUSH
37738: CALL_OW 310
37742: NOT
37743: PUSH
37744: LD_VAR 0 12
37748: PUSH
37749: LD_VAR 0 4
37753: ARRAY
37754: PPUSH
37755: CALL_OW 314
37759: NOT
37760: AND
37761: IFFALSE 37783
// ComEnterUnit ( tmp [ i ] , b ) ;
37763: LD_VAR 0 12
37767: PUSH
37768: LD_VAR 0 4
37772: ARRAY
37773: PPUSH
37774: LD_VAR 0 11
37778: PPUSH
37779: CALL_OW 120
37783: GO 37724
37785: POP
37786: POP
// if MREG_ToFac [ side ] then
37787: LD_EXP 57
37791: PUSH
37792: LD_VAR 0 1
37796: ARRAY
37797: IFFALSE 37817
// k := MREG_ToFac [ side ] else
37799: LD_ADDR_VAR 0 8
37803: PUSH
37804: LD_EXP 57
37808: PUSH
37809: LD_VAR 0 1
37813: ARRAY
37814: ST_TO_ADDR
37815: GO 37825
// k := 0 ;
37817: LD_ADDR_VAR 0 8
37821: PUSH
37822: LD_INT 0
37824: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37825: LD_VAR 0 15
37829: PUSH
37830: LD_VAR 0 8
37834: PLUS
37835: PUSH
37836: LD_INT 6
37838: LESSEQUAL
37839: PUSH
37840: LD_VAR 0 17
37844: PUSH
37845: LD_INT 6
37847: GREATER
37848: AND
37849: IFFALSE 37865
// MCH_TrainMechanic ( side , 1 ) else
37851: LD_VAR 0 1
37855: PPUSH
37856: LD_INT 1
37858: PPUSH
37859: CALL 15788 0 2
37863: GO 37909
// if all < 6 then
37865: LD_VAR 0 17
37869: PUSH
37870: LD_INT 6
37872: LESS
37873: IFFALSE 37909
// if mech + k < all / 2 then
37875: LD_VAR 0 15
37879: PUSH
37880: LD_VAR 0 8
37884: PLUS
37885: PUSH
37886: LD_VAR 0 17
37890: PUSH
37891: LD_INT 2
37893: DIVREAL
37894: LESS
37895: IFFALSE 37909
// MCH_TrainMechanic ( side , 1 ) ;
37897: LD_VAR 0 1
37901: PPUSH
37902: LD_INT 1
37904: PPUSH
37905: CALL 15788 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37909: LD_ADDR_VAR 0 10
37913: PUSH
37914: LD_VAR 0 1
37918: PPUSH
37919: LD_INT 30
37921: PUSH
37922: LD_INT 36
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PPUSH
37929: CALL 11587 0 2
37933: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
37934: LD_VAR 0 10
37938: PUSH
37939: LD_VAR 0 15
37943: AND
37944: PUSH
37945: LD_VAR 0 1
37949: PPUSH
37950: LD_INT 3
37952: PPUSH
37953: EMPTY
37954: PPUSH
37955: CALL 11670 0 3
37959: AND
37960: IFFALSE 38118
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
37962: LD_VAR 0 1
37966: PPUSH
37967: LD_INT 9
37969: PPUSH
37970: EMPTY
37971: PPUSH
37972: CALL 12290 0 3
37976: PUSH
37977: LD_INT 3
37979: LESS
37980: IFFALSE 38118
// begin if mech < 3 then
37982: LD_VAR 0 15
37986: PUSH
37987: LD_INT 3
37989: LESS
37990: IFFALSE 38004
// k := mech else
37992: LD_ADDR_VAR 0 8
37996: PUSH
37997: LD_VAR 0 15
38001: ST_TO_ADDR
38002: GO 38012
// k := 3 ;
38004: LD_ADDR_VAR 0 8
38008: PUSH
38009: LD_INT 3
38011: ST_TO_ADDR
// for j = 1 to k do
38012: LD_ADDR_VAR 0 5
38016: PUSH
38017: DOUBLE
38018: LD_INT 1
38020: DEC
38021: ST_TO_ADDR
38022: LD_VAR 0 8
38026: PUSH
38027: FOR_TO
38028: IFFALSE 38086
// if GetClass ( mech [ j ] ) = 3 then
38030: LD_VAR 0 15
38034: PUSH
38035: LD_VAR 0 5
38039: ARRAY
38040: PPUSH
38041: CALL_OW 257
38045: PUSH
38046: LD_INT 3
38048: EQUAL
38049: IFFALSE 38084
// begin SetTag ( mech [ j ] , 9 ) ;
38051: LD_VAR 0 15
38055: PUSH
38056: LD_VAR 0 5
38060: ARRAY
38061: PPUSH
38062: LD_INT 9
38064: PPUSH
38065: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38069: LD_VAR 0 15
38073: PUSH
38074: LD_VAR 0 5
38078: ARRAY
38079: PPUSH
38080: CALL_OW 122
// end ;
38084: GO 38027
38086: POP
38087: POP
// if mech < 6 + k then
38088: LD_VAR 0 15
38092: PUSH
38093: LD_INT 6
38095: PUSH
38096: LD_VAR 0 8
38100: PLUS
38101: LESS
38102: IFFALSE 38118
// MCH_TrainMechanic ( side , k ) ;
38104: LD_VAR 0 1
38108: PPUSH
38109: LD_VAR 0 8
38113: PPUSH
38114: CALL 15788 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38118: LD_VAR 0 1
38122: PPUSH
38123: LD_INT 9
38125: PPUSH
38126: EMPTY
38127: PPUSH
38128: CALL 12290 0 3
38132: IFFALSE 38223
// for j in MCF_Tag ( side , 9 , [ ] ) do
38134: LD_ADDR_VAR 0 5
38138: PUSH
38139: LD_VAR 0 1
38143: PPUSH
38144: LD_INT 9
38146: PPUSH
38147: EMPTY
38148: PPUSH
38149: CALL 12290 0 3
38153: PUSH
38154: FOR_IN
38155: IFFALSE 38221
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38157: LD_VAR 0 5
38161: PPUSH
38162: CALL_OW 310
38166: NOT
38167: PUSH
38168: LD_VAR 0 5
38172: PPUSH
38173: CALL 94461 0 1
38177: NOT
38178: AND
38179: IFFALSE 38219
// if ct then
38181: LD_VAR 0 10
38185: IFFALSE 38207
// ComEnterUnit ( j , ct [ 1 ] ) else
38187: LD_VAR 0 5
38191: PPUSH
38192: LD_VAR 0 10
38196: PUSH
38197: LD_INT 1
38199: ARRAY
38200: PPUSH
38201: CALL_OW 120
38205: GO 38219
// SetTag ( j , 0 ) ;
38207: LD_VAR 0 5
38211: PPUSH
38212: LD_INT 0
38214: PPUSH
38215: CALL_OW 109
38219: GO 38154
38221: POP
38222: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38223: LD_INT 1
38225: PPUSH
38226: LD_VAR 0 1
38230: PPUSH
38231: CALL_OW 321
38235: PUSH
38236: LD_INT 2
38238: EQUAL
38239: PUSH
38240: LD_EXP 37
38244: PUSH
38245: LD_VAR 0 1
38249: ARRAY
38250: NOT
38251: AND
38252: PUSH
38253: LD_VAR 0 1
38257: PPUSH
38258: LD_INT 4
38260: PPUSH
38261: EMPTY
38262: PPUSH
38263: CALL 11670 0 3
38267: AND
38268: IFFALSE 38316
// for j in MCF_Class ( side , 4 , [ ] ) do
38270: LD_ADDR_VAR 0 5
38274: PUSH
38275: LD_VAR 0 1
38279: PPUSH
38280: LD_INT 4
38282: PPUSH
38283: EMPTY
38284: PPUSH
38285: CALL 11670 0 3
38289: PUSH
38290: FOR_IN
38291: IFFALSE 38314
// MCN_Tame ( GetSide ( j ) , j ) ;
38293: LD_VAR 0 5
38297: PPUSH
38298: CALL_OW 255
38302: PPUSH
38303: LD_VAR 0 5
38307: PPUSH
38308: CALL 18489 0 2
38312: GO 38290
38314: POP
38315: POP
// if MREG_DefVeh [ side ] then
38316: LD_EXP 69
38320: PUSH
38321: LD_VAR 0 1
38325: ARRAY
38326: IFFALSE 38490
// begin for i in MREG_DefVeh [ side ] do
38328: LD_ADDR_VAR 0 4
38332: PUSH
38333: LD_EXP 69
38337: PUSH
38338: LD_VAR 0 1
38342: ARRAY
38343: PUSH
38344: FOR_IN
38345: IFFALSE 38398
// begin SetTag ( i , 0 ) ;
38347: LD_VAR 0 4
38351: PPUSH
38352: LD_INT 0
38354: PPUSH
38355: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38359: LD_VAR 0 4
38363: PPUSH
38364: LD_EXP 66
38368: PUSH
38369: LD_VAR 0 1
38373: ARRAY
38374: PPUSH
38375: CALL_OW 308
38379: NOT
38380: IFFALSE 38396
// MCV_Parking ( side , i ) ;
38382: LD_VAR 0 1
38386: PPUSH
38387: LD_VAR 0 4
38391: PPUSH
38392: CALL 25677 0 2
// end ;
38396: GO 38344
38398: POP
38399: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38400: LD_VAR 0 1
38404: PPUSH
38405: LD_INT 36
38407: PPUSH
38408: EMPTY
38409: PPUSH
38410: CALL 12290 0 3
38414: IFFALSE 38455
// for i in MCF_Tag ( side , 36 , [ ] ) do
38416: LD_ADDR_VAR 0 4
38420: PUSH
38421: LD_VAR 0 1
38425: PPUSH
38426: LD_INT 36
38428: PPUSH
38429: EMPTY
38430: PPUSH
38431: CALL 12290 0 3
38435: PUSH
38436: FOR_IN
38437: IFFALSE 38453
// SetTag ( i , 0 ) ;
38439: LD_VAR 0 4
38443: PPUSH
38444: LD_INT 0
38446: PPUSH
38447: CALL_OW 109
38451: GO 38436
38453: POP
38454: POP
// if MREG_DefMobActive [ side ] then
38455: LD_EXP 72
38459: PUSH
38460: LD_VAR 0 1
38464: ARRAY
38465: IFFALSE 38490
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38467: LD_ADDR_EXP 72
38471: PUSH
38472: LD_EXP 72
38476: PPUSH
38477: LD_VAR 0 1
38481: PPUSH
38482: LD_INT 0
38484: PPUSH
38485: CALL_OW 1
38489: ST_TO_ADDR
// end ; end ; if mode > 0 then
38490: LD_VAR 0 2
38494: PUSH
38495: LD_INT 0
38497: GREATER
38498: IFFALSE 40393
// begin if tick <= 15 15$00 then
38500: LD_OWVAR 1
38504: PUSH
38505: LD_INT 31500
38507: LESSEQUAL
38508: IFFALSE 38812
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38510: LD_VAR 0 13
38514: PUSH
38515: LD_VAR 0 1
38519: PPUSH
38520: CALL 24942 0 1
38524: PUSH
38525: LD_INT 4
38527: LESS
38528: AND
38529: IFFALSE 38640
// begin for i in sol do
38531: LD_ADDR_VAR 0 4
38535: PUSH
38536: LD_VAR 0 13
38540: PUSH
38541: FOR_IN
38542: IFFALSE 38638
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38544: LD_ADDR_VAR 0 8
38548: PUSH
38549: LD_VAR 0 1
38553: PPUSH
38554: CALL 24942 0 1
38558: PPUSH
38559: LD_VAR 0 4
38563: PPUSH
38564: CALL_OW 74
38568: ST_TO_ADDR
// if IsInUnit ( i ) then
38569: LD_VAR 0 4
38573: PPUSH
38574: CALL_OW 310
38578: IFFALSE 38589
// ComExitBuilding ( i ) ;
38580: LD_VAR 0 4
38584: PPUSH
38585: CALL_OW 122
// if not HasTask ( i ) and k then
38589: LD_VAR 0 4
38593: PPUSH
38594: CALL_OW 314
38598: NOT
38599: PUSH
38600: LD_VAR 0 8
38604: AND
38605: IFFALSE 38636
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38607: LD_VAR 0 4
38611: PPUSH
38612: LD_VAR 0 8
38616: PPUSH
38617: CALL_OW 250
38621: PPUSH
38622: LD_VAR 0 8
38626: PPUSH
38627: CALL_OW 251
38631: PPUSH
38632: CALL_OW 174
// end ;
38636: GO 38541
38638: POP
38639: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38640: LD_VAR 0 1
38644: PPUSH
38645: LD_INT 30
38647: PUSH
38648: LD_INT 5
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PPUSH
38655: CALL 11587 0 2
38659: IFFALSE 38810
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38661: LD_ADDR_VAR 0 11
38665: PUSH
38666: LD_VAR 0 1
38670: PPUSH
38671: LD_INT 30
38673: PUSH
38674: LD_INT 5
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PPUSH
38681: CALL 11587 0 2
38685: PUSH
38686: LD_INT 1
38688: ARRAY
38689: ST_TO_ADDR
// if mech then
38690: LD_VAR 0 15
38694: IFFALSE 38730
// for i in mech do
38696: LD_ADDR_VAR 0 4
38700: PUSH
38701: LD_VAR 0 15
38705: PUSH
38706: FOR_IN
38707: IFFALSE 38728
// MCH_ChangeClass ( side , i , 1 ) ;
38709: LD_VAR 0 1
38713: PPUSH
38714: LD_VAR 0 4
38718: PPUSH
38719: LD_INT 1
38721: PPUSH
38722: CALL 16494 0 3
38726: GO 38706
38728: POP
38729: POP
// if eng > 1 then
38730: LD_VAR 0 14
38734: PUSH
38735: LD_INT 1
38737: GREATER
38738: IFFALSE 38785
// for i = eng downto 2 do
38740: LD_ADDR_VAR 0 4
38744: PUSH
38745: DOUBLE
38746: LD_VAR 0 14
38750: INC
38751: ST_TO_ADDR
38752: LD_INT 2
38754: PUSH
38755: FOR_DOWNTO
38756: IFFALSE 38783
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38758: LD_VAR 0 1
38762: PPUSH
38763: LD_VAR 0 14
38767: PUSH
38768: LD_VAR 0 4
38772: ARRAY
38773: PPUSH
38774: LD_INT 1
38776: PPUSH
38777: CALL 16494 0 3
38781: GO 38755
38783: POP
38784: POP
// if UnitsInside ( b ) then
38785: LD_VAR 0 11
38789: PPUSH
38790: CALL_OW 313
38794: IFFALSE 38810
// ComExitBuilding ( UnitsInside ( b ) ) ;
38796: LD_VAR 0 11
38800: PPUSH
38801: CALL_OW 313
38805: PPUSH
38806: CALL_OW 122
// end ; end else
38810: GO 40393
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38812: LD_VAR 0 1
38816: PPUSH
38817: LD_INT 1
38819: PPUSH
38820: LD_EXP 67
38824: PUSH
38825: LD_VAR 0 1
38829: ARRAY
38830: PUSH
38831: LD_INT 1
38833: ARRAY
38834: PPUSH
38835: CALL 33665 0 3
38839: IFFALSE 38978
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38841: LD_ADDR_VAR 0 12
38845: PUSH
38846: LD_VAR 0 1
38850: PPUSH
38851: LD_INT 21
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PPUSH
38861: CALL 11587 0 2
38865: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38866: LD_ADDR_VAR 0 11
38870: PUSH
38871: LD_VAR 0 1
38875: PPUSH
38876: LD_INT 30
38878: PUSH
38879: LD_INT 1
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PPUSH
38886: CALL 11587 0 2
38890: ST_TO_ADDR
// if b then
38891: LD_VAR 0 11
38895: IFFALSE 38978
// for i in tmp do
38897: LD_ADDR_VAR 0 4
38901: PUSH
38902: LD_VAR 0 12
38906: PUSH
38907: FOR_IN
38908: IFFALSE 38976
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38910: LD_VAR 0 4
38914: PPUSH
38915: LD_EXP 67
38919: PUSH
38920: LD_VAR 0 1
38924: ARRAY
38925: PUSH
38926: LD_INT 1
38928: ARRAY
38929: PPUSH
38930: CALL_OW 308
38934: NOT
38935: IFFALSE 38974
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
38937: LD_VAR 0 4
38941: PPUSH
38942: LD_VAR 0 11
38946: PUSH
38947: LD_INT 1
38949: ARRAY
38950: PPUSH
38951: CALL_OW 250
38955: PPUSH
38956: LD_VAR 0 11
38960: PUSH
38961: LD_INT 1
38963: ARRAY
38964: PPUSH
38965: CALL_OW 251
38969: PPUSH
38970: CALL_OW 111
38974: GO 38907
38976: POP
38977: POP
// end ; if MREG_DefVeh [ side ] then
38978: LD_EXP 69
38982: PUSH
38983: LD_VAR 0 1
38987: ARRAY
38988: IFFALSE 39556
// begin tmp := [ ] ;
38990: LD_ADDR_VAR 0 12
38994: PUSH
38995: EMPTY
38996: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
38997: LD_EXP 72
39001: PUSH
39002: LD_VAR 0 1
39006: ARRAY
39007: PUSH
39008: LD_INT 0
39010: EQUAL
39011: IFFALSE 39151
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39013: LD_ADDR_VAR 0 8
39017: PUSH
39018: LD_VAR 0 1
39022: PPUSH
39023: LD_INT 0
39025: PPUSH
39026: LD_INT 25
39028: PUSH
39029: LD_INT 3
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PPUSH
39036: CALL 12290 0 3
39040: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39041: LD_VAR 0 8
39045: PUSH
39046: LD_EXP 69
39050: PUSH
39051: LD_VAR 0 1
39055: ARRAY
39056: GREATER
39057: IFFALSE 39118
// begin for i = 1 to MREG_DefVeh [ side ] do
39059: LD_ADDR_VAR 0 4
39063: PUSH
39064: DOUBLE
39065: LD_INT 1
39067: DEC
39068: ST_TO_ADDR
39069: LD_EXP 69
39073: PUSH
39074: LD_VAR 0 1
39078: ARRAY
39079: PUSH
39080: FOR_TO
39081: IFFALSE 39114
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39083: LD_ADDR_VAR 0 12
39087: PUSH
39088: LD_VAR 0 12
39092: PPUSH
39093: LD_INT 1
39095: PPUSH
39096: LD_VAR 0 8
39100: PUSH
39101: LD_VAR 0 4
39105: ARRAY
39106: PPUSH
39107: CALL_OW 2
39111: ST_TO_ADDR
39112: GO 39080
39114: POP
39115: POP
// end else
39116: GO 39128
// tmp := k ;
39118: LD_ADDR_VAR 0 12
39122: PUSH
39123: LD_VAR 0 8
39127: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39128: LD_ADDR_EXP 72
39132: PUSH
39133: LD_EXP 72
39137: PPUSH
39138: LD_VAR 0 1
39142: PPUSH
39143: LD_INT 1
39145: PPUSH
39146: CALL_OW 1
39150: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39151: LD_ADDR_VAR 0 4
39155: PUSH
39156: LD_EXP 69
39160: PUSH
39161: LD_VAR 0 1
39165: ARRAY
39166: PUSH
39167: FOR_IN
39168: IFFALSE 39554
// begin if not GetDriver ( i ) then
39170: LD_VAR 0 4
39174: PPUSH
39175: CALL 31695 0 1
39179: NOT
39180: IFFALSE 39255
// begin if tmp then
39182: LD_VAR 0 12
39186: IFFALSE 39253
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39188: LD_VAR 0 12
39192: PUSH
39193: LD_INT 1
39195: ARRAY
39196: PPUSH
39197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39201: LD_VAR 0 12
39205: PUSH
39206: LD_INT 1
39208: ARRAY
39209: PPUSH
39210: LD_VAR 0 4
39214: PPUSH
39215: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39219: LD_VAR 0 12
39223: PUSH
39224: LD_INT 1
39226: ARRAY
39227: PPUSH
39228: LD_INT 36
39230: PPUSH
39231: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39235: LD_ADDR_VAR 0 12
39239: PUSH
39240: LD_VAR 0 12
39244: PPUSH
39245: LD_INT 1
39247: PPUSH
39248: CALL_OW 3
39252: ST_TO_ADDR
// end ; end else
39253: GO 39552
// begin if GetTag ( i ) = 0 then
39255: LD_VAR 0 4
39259: PPUSH
39260: CALL_OW 110
39264: PUSH
39265: LD_INT 0
39267: EQUAL
39268: IFFALSE 39284
// SetTag ( i , 31 ) else
39270: LD_VAR 0 4
39274: PPUSH
39275: LD_INT 31
39277: PPUSH
39278: CALL_OW 109
39282: GO 39552
// if GetTag ( i ) = 31 then
39284: LD_VAR 0 4
39288: PPUSH
39289: CALL_OW 110
39293: PUSH
39294: LD_INT 31
39296: EQUAL
39297: IFFALSE 39552
// begin if GetFuel ( i ) < 20 then
39299: LD_VAR 0 4
39303: PPUSH
39304: CALL_OW 261
39308: PUSH
39309: LD_INT 20
39311: LESS
39312: IFFALSE 39337
// begin SetTag ( i , 21 ) ;
39314: LD_VAR 0 4
39318: PPUSH
39319: LD_INT 21
39321: PPUSH
39322: CALL_OW 109
// MCV_Refuel ( i ) ;
39326: LD_VAR 0 4
39330: PPUSH
39331: CALL 26214 0 1
// continue ;
39335: GO 39167
// end ; if GetLives ( i ) < 700 then
39337: LD_VAR 0 4
39341: PPUSH
39342: CALL_OW 256
39346: PUSH
39347: LD_INT 700
39349: LESS
39350: IFFALSE 39462
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39352: LD_VAR 0 4
39356: PPUSH
39357: LD_EXP 60
39361: PUSH
39362: LD_VAR 0 1
39366: ARRAY
39367: PPUSH
39368: CALL_OW 308
39372: NOT
39373: IFFALSE 39397
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39375: LD_VAR 0 4
39379: PPUSH
39380: LD_EXP 60
39384: PUSH
39385: LD_VAR 0 1
39389: ARRAY
39390: PPUSH
39391: CALL_OW 113
39395: GO 39460
// if GetDriver ( i ) then
39397: LD_VAR 0 4
39401: PPUSH
39402: CALL 31695 0 1
39406: IFFALSE 39460
// begin k := GetDriver ( i ) ;
39408: LD_ADDR_VAR 0 8
39412: PUSH
39413: LD_VAR 0 4
39417: PPUSH
39418: CALL 31695 0 1
39422: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39423: LD_VAR 0 8
39427: PPUSH
39428: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39432: LD_VAR 0 8
39436: PPUSH
39437: LD_VAR 0 4
39441: PPUSH
39442: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39446: LD_VAR 0 8
39450: PPUSH
39451: LD_VAR 0 4
39455: PPUSH
39456: CALL_OW 180
// end ; end else
39460: GO 39552
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39462: LD_ADDR_VAR 0 8
39466: PUSH
39467: LD_VAR 0 1
39471: PPUSH
39472: CALL 24942 0 1
39476: PPUSH
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL_OW 74
39486: ST_TO_ADDR
// if k then
39487: LD_VAR 0 8
39491: IFFALSE 39509
// ComAttackUnit ( i , k ) else
39493: LD_VAR 0 4
39497: PPUSH
39498: LD_VAR 0 8
39502: PPUSH
39503: CALL_OW 115
39507: GO 39552
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39509: LD_VAR 0 4
39513: PPUSH
39514: LD_EXP 60
39518: PUSH
39519: LD_VAR 0 1
39523: ARRAY
39524: PPUSH
39525: CALL_OW 308
39529: NOT
39530: IFFALSE 39552
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39532: LD_VAR 0 4
39536: PPUSH
39537: LD_EXP 60
39541: PUSH
39542: LD_VAR 0 1
39546: ARRAY
39547: PPUSH
39548: CALL_OW 113
// end ; end ; end ; end ;
39552: GO 39167
39554: POP
39555: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39556: LD_VAR 0 1
39560: PPUSH
39561: LD_INT 30
39563: PUSH
39564: LD_INT 5
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PPUSH
39571: CALL 11587 0 2
39575: IFFALSE 40393
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39577: LD_ADDR_VAR 0 11
39581: PUSH
39582: LD_VAR 0 1
39586: PPUSH
39587: LD_INT 30
39589: PUSH
39590: LD_INT 5
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PPUSH
39597: CALL 11587 0 2
39601: PUSH
39602: LD_INT 1
39604: ARRAY
39605: ST_TO_ADDR
// if eng > 1 then
39606: LD_VAR 0 14
39610: PUSH
39611: LD_INT 1
39613: GREATER
39614: IFFALSE 39661
// for i = eng downto 2 do
39616: LD_ADDR_VAR 0 4
39620: PUSH
39621: DOUBLE
39622: LD_VAR 0 14
39626: INC
39627: ST_TO_ADDR
39628: LD_INT 2
39630: PUSH
39631: FOR_DOWNTO
39632: IFFALSE 39659
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_VAR 0 14
39643: PUSH
39644: LD_VAR 0 4
39648: ARRAY
39649: PPUSH
39650: LD_INT 1
39652: PPUSH
39653: CALL 16494 0 3
39657: GO 39631
39659: POP
39660: POP
// if sci > 1 then
39661: LD_VAR 0 16
39665: PUSH
39666: LD_INT 1
39668: GREATER
39669: IFFALSE 39716
// for i = sci downto 2 do
39671: LD_ADDR_VAR 0 4
39675: PUSH
39676: DOUBLE
39677: LD_VAR 0 16
39681: INC
39682: ST_TO_ADDR
39683: LD_INT 2
39685: PUSH
39686: FOR_DOWNTO
39687: IFFALSE 39714
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39689: LD_VAR 0 1
39693: PPUSH
39694: LD_VAR 0 16
39698: PUSH
39699: LD_VAR 0 4
39703: ARRAY
39704: PPUSH
39705: LD_INT 1
39707: PPUSH
39708: CALL 16494 0 3
39712: GO 39686
39714: POP
39715: POP
// if sol then
39716: LD_VAR 0 13
39720: IFFALSE 40393
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39722: LD_VAR 0 13
39726: PUSH
39727: LD_EXP 70
39731: PUSH
39732: LD_VAR 0 1
39736: ARRAY
39737: DIFF
39738: PUSH
39739: LD_INT 22
39741: PUSH
39742: LD_VAR 0 1
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 58
39753: PUSH
39754: EMPTY
39755: LIST
39756: PUSH
39757: LD_INT 2
39759: PUSH
39760: LD_INT 30
39762: PUSH
39763: LD_INT 32
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 30
39772: PUSH
39773: LD_INT 31
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: LIST
39789: PPUSH
39790: CALL_OW 69
39794: PUSH
39795: LD_INT 0
39797: EQUAL
39798: AND
39799: IFFALSE 40393
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39801: LD_ADDR_VAR 0 12
39805: PUSH
39806: LD_VAR 0 13
39810: PUSH
39811: LD_EXP 70
39815: PUSH
39816: LD_VAR 0 1
39820: ARRAY
39821: DIFF
39822: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39823: LD_VAR 0 1
39827: PPUSH
39828: LD_INT 30
39830: PUSH
39831: LD_INT 5
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PPUSH
39838: CALL 11587 0 2
39842: PUSH
39843: LD_INT 1
39845: GREATER
39846: IFFALSE 39877
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39848: LD_ADDR_VAR 0 8
39852: PUSH
39853: LD_VAR 0 1
39857: PPUSH
39858: LD_INT 30
39860: PUSH
39861: LD_INT 5
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL 11587 0 2
39872: PUSH
39873: LD_INT 2
39875: ARRAY
39876: ST_TO_ADDR
// for j in tmp do
39877: LD_ADDR_VAR 0 5
39881: PUSH
39882: LD_VAR 0 12
39886: PUSH
39887: FOR_IN
39888: IFFALSE 40391
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39890: LD_VAR 0 5
39894: PUSH
39895: LD_VAR 0 11
39899: PPUSH
39900: CALL_OW 313
39904: IN
39905: PUSH
39906: LD_VAR 0 11
39910: PPUSH
39911: CALL_OW 313
39915: PUSH
39916: LD_INT 6
39918: EQUAL
39919: AND
39920: PUSH
39921: LD_VAR 0 8
39925: AND
39926: PUSH
39927: LD_VAR 0 8
39931: PPUSH
39932: CALL_OW 313
39936: PUSH
39937: LD_INT 6
39939: LESS
39940: AND
39941: IFFALSE 39968
// begin ComExitBuilding ( j ) ;
39943: LD_VAR 0 5
39947: PPUSH
39948: CALL_OW 122
// AddComEnterunit ( j , k ) ;
39952: LD_VAR 0 5
39956: PPUSH
39957: LD_VAR 0 8
39961: PPUSH
39962: CALL_OW 180
// continue ;
39966: GO 39887
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
39968: LD_VAR 0 5
39972: PPUSH
39973: CALL_OW 314
39977: NOT
39978: PUSH
39979: LD_VAR 0 5
39983: PPUSH
39984: CALL_OW 110
39988: PUSH
39989: LD_INT 0
39991: EQUAL
39992: AND
39993: PUSH
39994: LD_VAR 0 5
39998: PPUSH
39999: CALL_OW 310
40003: NOT
40004: AND
40005: IFFALSE 40111
// begin if k then
40007: LD_VAR 0 8
40011: IFFALSE 40082
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40013: LD_VAR 0 8
40017: PPUSH
40018: CALL_OW 313
40022: PUSH
40023: LD_VAR 0 11
40027: PPUSH
40028: CALL_OW 313
40032: LESS
40033: IFFALSE 40051
// ComEnterUnit ( j , k ) else
40035: LD_VAR 0 5
40039: PPUSH
40040: LD_VAR 0 8
40044: PPUSH
40045: CALL_OW 120
40049: GO 40080
// if UnitsInside ( b ) < 6 then
40051: LD_VAR 0 11
40055: PPUSH
40056: CALL_OW 313
40060: PUSH
40061: LD_INT 6
40063: LESS
40064: IFFALSE 40080
// ComEnterUnit ( j , b ) ;
40066: LD_VAR 0 5
40070: PPUSH
40071: LD_VAR 0 11
40075: PPUSH
40076: CALL_OW 120
// end else
40080: GO 40111
// if UnitsInside ( b ) < 6 then
40082: LD_VAR 0 11
40086: PPUSH
40087: CALL_OW 313
40091: PUSH
40092: LD_INT 6
40094: LESS
40095: IFFALSE 40111
// ComEnterUnit ( j , b ) ;
40097: LD_VAR 0 5
40101: PPUSH
40102: LD_VAR 0 11
40106: PPUSH
40107: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40111: LD_VAR 0 5
40115: PUSH
40116: LD_VAR 0 1
40120: PPUSH
40121: LD_INT 54
40123: PUSH
40124: EMPTY
40125: LIST
40126: PPUSH
40127: CALL 11587 0 2
40131: IN
40132: PUSH
40133: LD_VAR 0 5
40137: PPUSH
40138: CALL_OW 257
40142: PUSH
40143: LD_INT 1
40145: EQUAL
40146: AND
40147: IFFALSE 40389
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40149: LD_EXP 64
40153: PUSH
40154: LD_VAR 0 1
40158: ARRAY
40159: PUSH
40160: LD_INT 1
40162: ARRAY
40163: PUSH
40164: LD_INT 12
40166: PPUSH
40167: LD_VAR 0 1
40171: PPUSH
40172: CALL_OW 321
40176: PUSH
40177: LD_INT 2
40179: EQUAL
40180: AND
40181: IFFALSE 40229
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40183: LD_VAR 0 1
40187: PPUSH
40188: LD_INT 5
40190: PPUSH
40191: EMPTY
40192: PPUSH
40193: CALL 11670 0 3
40197: PUSH
40198: LD_EXP 64
40202: PUSH
40203: LD_VAR 0 1
40207: ARRAY
40208: PUSH
40209: LD_INT 1
40211: ARRAY
40212: LESS
40213: IFFALSE 40229
// begin SetClass ( j , class_sniper ) ;
40215: LD_VAR 0 5
40219: PPUSH
40220: LD_INT 5
40222: PPUSH
40223: CALL_OW 336
// continue ;
40227: GO 39887
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40229: LD_EXP 64
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PUSH
40240: LD_INT 2
40242: ARRAY
40243: PUSH
40244: LD_INT 41
40246: PPUSH
40247: LD_VAR 0 1
40251: PPUSH
40252: CALL_OW 321
40256: PUSH
40257: LD_INT 2
40259: EQUAL
40260: AND
40261: IFFALSE 40309
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40263: LD_VAR 0 1
40267: PPUSH
40268: LD_INT 8
40270: PPUSH
40271: EMPTY
40272: PPUSH
40273: CALL 11670 0 3
40277: PUSH
40278: LD_EXP 64
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PUSH
40289: LD_INT 2
40291: ARRAY
40292: LESS
40293: IFFALSE 40309
// begin SetClass ( j , class_mortar ) ;
40295: LD_VAR 0 5
40299: PPUSH
40300: LD_INT 8
40302: PPUSH
40303: CALL_OW 336
// continue ;
40307: GO 39887
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40309: LD_EXP 64
40313: PUSH
40314: LD_VAR 0 1
40318: ARRAY
40319: PUSH
40320: LD_INT 3
40322: ARRAY
40323: PUSH
40324: LD_INT 44
40326: PPUSH
40327: LD_VAR 0 1
40331: PPUSH
40332: CALL_OW 321
40336: PUSH
40337: LD_INT 2
40339: EQUAL
40340: AND
40341: IFFALSE 40389
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40343: LD_VAR 0 1
40347: PPUSH
40348: LD_INT 9
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL 11670 0 3
40357: PUSH
40358: LD_EXP 64
40362: PUSH
40363: LD_VAR 0 1
40367: ARRAY
40368: PUSH
40369: LD_INT 3
40371: ARRAY
40372: LESS
40373: IFFALSE 40389
// begin SetClass ( j , class_bazooker ) ;
40375: LD_VAR 0 5
40379: PPUSH
40380: LD_INT 9
40382: PPUSH
40383: CALL_OW 336
// continue ;
40387: GO 39887
// end ; end ; end ;
40389: GO 39887
40391: POP
40392: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40393: LD_INT 22
40395: PUSH
40396: LD_VAR 0 1
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 58
40407: PUSH
40408: EMPTY
40409: LIST
40410: PUSH
40411: LD_INT 30
40413: PUSH
40414: LD_INT 32
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: PPUSH
40426: CALL_OW 69
40430: IFFALSE 40580
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40432: LD_ADDR_VAR 0 12
40436: PUSH
40437: LD_INT 22
40439: PUSH
40440: LD_VAR 0 1
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 58
40451: PUSH
40452: EMPTY
40453: LIST
40454: PUSH
40455: LD_INT 30
40457: PUSH
40458: LD_INT 32
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: LIST
40469: PPUSH
40470: CALL_OW 69
40474: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40475: LD_ADDR_VAR 0 8
40479: PUSH
40480: LD_VAR 0 13
40484: PUSH
40485: LD_EXP 70
40489: PUSH
40490: LD_VAR 0 1
40494: ARRAY
40495: DIFF
40496: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40497: LD_VAR 0 12
40501: PUSH
40502: LD_INT 1
40504: ARRAY
40505: PPUSH
40506: CALL_OW 461
40510: PUSH
40511: LD_INT 2
40513: EQUAL
40514: PUSH
40515: LD_VAR 0 12
40519: PUSH
40520: LD_INT 1
40522: ARRAY
40523: PUSH
40524: LD_EXP 70
40528: PUSH
40529: LD_VAR 0 1
40533: ARRAY
40534: IN
40535: NOT
40536: AND
40537: PUSH
40538: LD_VAR 0 8
40542: AND
40543: IFFALSE 40580
// begin ComExitBuilding ( k [ 1 ] ) ;
40545: LD_VAR 0 8
40549: PUSH
40550: LD_INT 1
40552: ARRAY
40553: PPUSH
40554: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40558: LD_VAR 0 8
40562: PUSH
40563: LD_INT 1
40565: ARRAY
40566: PPUSH
40567: LD_VAR 0 12
40571: PUSH
40572: LD_INT 1
40574: ARRAY
40575: PPUSH
40576: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40580: LD_EXP 37
40584: PUSH
40585: LD_VAR 0 1
40589: ARRAY
40590: IFFALSE 40738
// begin if MCF_Class ( side , 4 , [ ] ) then
40592: LD_VAR 0 1
40596: PPUSH
40597: LD_INT 4
40599: PPUSH
40600: EMPTY
40601: PPUSH
40602: CALL 11670 0 3
40606: IFFALSE 40736
// for j in MCF_Class ( side , 4 , [ ] ) do
40608: LD_ADDR_VAR 0 5
40612: PUSH
40613: LD_VAR 0 1
40617: PPUSH
40618: LD_INT 4
40620: PPUSH
40621: EMPTY
40622: PPUSH
40623: CALL 11670 0 3
40627: PUSH
40628: FOR_IN
40629: IFFALSE 40734
// begin if not GetTag ( j ) = 4 then
40631: LD_VAR 0 5
40635: PPUSH
40636: CALL_OW 110
40640: PUSH
40641: LD_INT 4
40643: EQUAL
40644: NOT
40645: IFFALSE 40681
// begin SetTag ( j , 4 ) ;
40647: LD_VAR 0 5
40651: PPUSH
40652: LD_INT 4
40654: PPUSH
40655: CALL_OW 109
// if IsInUnit ( j ) then
40659: LD_VAR 0 5
40663: PPUSH
40664: CALL_OW 310
40668: IFFALSE 40679
// ComExitBuilding ( j ) ;
40670: LD_VAR 0 5
40674: PPUSH
40675: CALL_OW 122
// end else
40679: GO 40732
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40681: LD_VAR 0 5
40685: PPUSH
40686: LD_EXP 37
40690: PUSH
40691: LD_VAR 0 1
40695: ARRAY
40696: PUSH
40697: LD_INT 1
40699: ARRAY
40700: PPUSH
40701: CALL 94085 0 2
40705: NOT
40706: IFFALSE 40732
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40708: LD_VAR 0 5
40712: PPUSH
40713: LD_EXP 37
40717: PUSH
40718: LD_VAR 0 1
40722: ARRAY
40723: PUSH
40724: LD_INT 1
40726: ARRAY
40727: PPUSH
40728: CALL 19157 0 2
// end ;
40732: GO 40628
40734: POP
40735: POP
// end else
40736: GO 40970
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40738: LD_VAR 0 1
40742: PPUSH
40743: LD_INT 4
40745: PPUSH
40746: EMPTY
40747: PPUSH
40748: CALL 11670 0 3
40752: PUSH
40753: LD_VAR 0 1
40757: PPUSH
40758: LD_INT 4
40760: PPUSH
40761: EMPTY
40762: PPUSH
40763: CALL 12290 0 3
40767: AND
40768: IFFALSE 40970
// for j in MCF_Class ( side , 4 , [ ] ) do
40770: LD_ADDR_VAR 0 5
40774: PUSH
40775: LD_VAR 0 1
40779: PPUSH
40780: LD_INT 4
40782: PPUSH
40783: EMPTY
40784: PPUSH
40785: CALL 11670 0 3
40789: PUSH
40790: FOR_IN
40791: IFFALSE 40968
// begin if GetTag ( j ) = 4 then
40793: LD_VAR 0 5
40797: PPUSH
40798: CALL_OW 110
40802: PUSH
40803: LD_INT 4
40805: EQUAL
40806: IFFALSE 40966
// begin SetTag ( j , 0 ) ;
40808: LD_VAR 0 5
40812: PPUSH
40813: LD_INT 0
40815: PPUSH
40816: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40820: LD_VAR 0 1
40824: PPUSH
40825: CALL 11626 0 1
40829: PUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: CALL 17970 0 1
40839: NOT
40840: AND
40841: IFFALSE 40866
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40843: LD_VAR 0 5
40847: PPUSH
40848: LD_VAR 0 1
40852: PPUSH
40853: CALL 11626 0 1
40857: PUSH
40858: LD_INT 1
40860: ARRAY
40861: PPUSH
40862: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40866: LD_VAR 0 1
40870: PPUSH
40871: CALL 11626 0 1
40875: NOT
40876: PUSH
40877: LD_VAR 0 1
40881: PPUSH
40882: LD_INT 30
40884: PUSH
40885: LD_INT 1
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PPUSH
40892: CALL 11587 0 2
40896: AND
40897: IFFALSE 40966
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40899: LD_VAR 0 5
40903: PPUSH
40904: LD_VAR 0 1
40908: PPUSH
40909: LD_INT 30
40911: PUSH
40912: LD_INT 1
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PPUSH
40919: CALL 11587 0 2
40923: PUSH
40924: LD_INT 1
40926: ARRAY
40927: PPUSH
40928: CALL_OW 250
40932: PPUSH
40933: LD_VAR 0 1
40937: PPUSH
40938: LD_INT 30
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PPUSH
40948: CALL 11587 0 2
40952: PUSH
40953: LD_INT 1
40955: ARRAY
40956: PPUSH
40957: CALL_OW 251
40961: PPUSH
40962: CALL_OW 111
// end ; end ;
40966: GO 40790
40968: POP
40969: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
40970: LD_VAR 0 1
40974: PPUSH
40975: LD_INT 3
40977: PPUSH
40978: EMPTY
40979: PPUSH
40980: CALL 11670 0 3
40984: PUSH
40985: LD_EXP 60
40989: PUSH
40990: LD_VAR 0 1
40994: ARRAY
40995: AND
40996: PUSH
40997: LD_VAR 0 1
41001: PPUSH
41002: LD_INT 6
41004: PPUSH
41005: EMPTY
41006: PPUSH
41007: CALL 12290 0 3
41011: AND
41012: IFFALSE 41543
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41014: LD_ADDR_VAR 0 6
41018: PUSH
41019: LD_EXP 60
41023: PUSH
41024: LD_VAR 0 1
41028: ARRAY
41029: PPUSH
41030: LD_INT 0
41032: PPUSH
41033: CALL_OW 517
41037: PUSH
41038: LD_INT 1
41040: ARRAY
41041: PUSH
41042: LD_INT 1
41044: ARRAY
41045: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41046: LD_ADDR_VAR 0 7
41050: PUSH
41051: LD_EXP 60
41055: PUSH
41056: LD_VAR 0 1
41060: ARRAY
41061: PPUSH
41062: LD_INT 0
41064: PPUSH
41065: CALL_OW 517
41069: PUSH
41070: LD_INT 2
41072: ARRAY
41073: PUSH
41074: LD_INT 1
41076: ARRAY
41077: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41078: LD_VAR 0 1
41082: PPUSH
41083: LD_INT 6
41085: PPUSH
41086: EMPTY
41087: PPUSH
41088: CALL 12290 0 3
41092: IFFALSE 41541
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41094: LD_ADDR_VAR 0 8
41098: PUSH
41099: LD_VAR 0 1
41103: PPUSH
41104: LD_INT 6
41106: PPUSH
41107: EMPTY
41108: PPUSH
41109: CALL 12290 0 3
41113: PUSH
41114: FOR_IN
41115: IFFALSE 41146
// if GetLives ( k ) = 1000 then
41117: LD_VAR 0 8
41121: PPUSH
41122: CALL_OW 256
41126: PUSH
41127: LD_INT 1000
41129: EQUAL
41130: IFFALSE 41144
// SetTag ( k , 0 ) ;
41132: LD_VAR 0 8
41136: PPUSH
41137: LD_INT 0
41139: PPUSH
41140: CALL_OW 109
41144: GO 41114
41146: POP
41147: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41148: LD_VAR 0 1
41152: PPUSH
41153: LD_INT 0
41155: PPUSH
41156: LD_INT 25
41158: PUSH
41159: LD_INT 3
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PPUSH
41166: CALL 12290 0 3
41170: IFFALSE 41234
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 4
41181: PPUSH
41182: LD_INT 0
41184: PPUSH
41185: LD_INT 25
41187: PUSH
41188: LD_INT 3
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PPUSH
41195: CALL 12290 0 3
41199: PUSH
41200: FOR_IN
41201: IFFALSE 41232
// if GetTag ( k ) = 0 then
41203: LD_VAR 0 8
41207: PPUSH
41208: CALL_OW 110
41212: PUSH
41213: LD_INT 0
41215: EQUAL
41216: IFFALSE 41230
// begin SetTag ( k , 8 ) ;
41218: LD_VAR 0 8
41222: PPUSH
41223: LD_INT 8
41225: PPUSH
41226: CALL_OW 109
// end ;
41230: GO 41200
41232: POP
41233: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41234: LD_VAR 0 1
41238: PPUSH
41239: LD_INT 6
41241: PPUSH
41242: LD_INT 92
41244: PUSH
41245: LD_VAR 0 6
41249: PUSH
41250: LD_VAR 0 7
41254: PUSH
41255: LD_INT 10
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: PPUSH
41264: CALL 12290 0 3
41268: IFFALSE 41392
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41270: LD_ADDR_VAR 0 5
41274: PUSH
41275: LD_VAR 0 4
41279: PPUSH
41280: LD_INT 6
41282: PPUSH
41283: LD_INT 92
41285: PUSH
41286: LD_VAR 0 6
41290: PUSH
41291: LD_VAR 0 7
41295: PUSH
41296: LD_INT 10
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: PPUSH
41305: CALL 12290 0 3
41309: PUSH
41310: FOR_IN
41311: IFFALSE 41390
// begin if not HasTask ( j ) and GetDriver ( j ) then
41313: LD_VAR 0 5
41317: PPUSH
41318: CALL_OW 314
41322: NOT
41323: PUSH
41324: LD_VAR 0 5
41328: PPUSH
41329: CALL 31695 0 1
41333: AND
41334: IFFALSE 41388
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41336: LD_VAR 0 5
41340: PPUSH
41341: CALL 31695 0 1
41345: PPUSH
41346: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41350: LD_VAR 0 5
41354: PPUSH
41355: CALL 31695 0 1
41359: PPUSH
41360: LD_VAR 0 5
41364: PPUSH
41365: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41369: LD_VAR 0 5
41373: PPUSH
41374: CALL 31695 0 1
41378: PPUSH
41379: LD_VAR 0 5
41383: PPUSH
41384: CALL_OW 180
// end ; end ;
41388: GO 41310
41390: POP
41391: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41392: LD_VAR 0 1
41396: PPUSH
41397: LD_INT 6
41399: PPUSH
41400: LD_INT 92
41402: PUSH
41403: LD_VAR 0 6
41407: PUSH
41408: LD_VAR 0 7
41412: PUSH
41413: LD_INT 10
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL 12290 0 3
41426: PUSH
41427: LD_VAR 0 1
41431: PPUSH
41432: LD_INT 8
41434: PPUSH
41435: EMPTY
41436: PPUSH
41437: CALL 12290 0 3
41441: AND
41442: IFFALSE 41541
// for j in MCF_Tag ( side , 8 , [ ] ) do
41444: LD_ADDR_VAR 0 5
41448: PUSH
41449: LD_VAR 0 1
41453: PPUSH
41454: LD_INT 8
41456: PPUSH
41457: EMPTY
41458: PPUSH
41459: CALL 12290 0 3
41463: PUSH
41464: FOR_IN
41465: IFFALSE 41539
// begin if IsInUnit ( j ) then
41467: LD_VAR 0 5
41471: PPUSH
41472: CALL_OW 310
41476: IFFALSE 41489
// ComExitBuilding ( j ) else
41478: LD_VAR 0 5
41482: PPUSH
41483: CALL_OW 122
41487: GO 41537
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41489: LD_VAR 0 5
41493: PPUSH
41494: LD_VAR 0 1
41498: PPUSH
41499: LD_INT 6
41501: PPUSH
41502: LD_INT 92
41504: PUSH
41505: LD_VAR 0 6
41509: PUSH
41510: LD_VAR 0 7
41514: PUSH
41515: LD_INT 10
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: PPUSH
41524: CALL 12290 0 3
41528: PUSH
41529: LD_INT 1
41531: ARRAY
41532: PPUSH
41533: CALL_OW 129
// end ;
41537: GO 41464
41539: POP
41540: POP
// end ; end else
41541: GO 41598
// if MCF_Tag ( side , 8 , [ ] ) then
41543: LD_VAR 0 1
41547: PPUSH
41548: LD_INT 8
41550: PPUSH
41551: EMPTY
41552: PPUSH
41553: CALL 12290 0 3
41557: IFFALSE 41598
// for k in MCF_Tag ( side , 8 , [ ] ) do
41559: LD_ADDR_VAR 0 8
41563: PUSH
41564: LD_VAR 0 1
41568: PPUSH
41569: LD_INT 8
41571: PPUSH
41572: EMPTY
41573: PPUSH
41574: CALL 12290 0 3
41578: PUSH
41579: FOR_IN
41580: IFFALSE 41596
// SetTag ( k , 0 ) ;
41582: LD_VAR 0 8
41586: PPUSH
41587: LD_INT 0
41589: PPUSH
41590: CALL_OW 109
41594: GO 41579
41596: POP
41597: POP
// end ; end_of_file
41598: LD_VAR 0 3
41602: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41603: LD_INT 0
41605: PPUSH
// MREG_Game := [ ] ;
41606: LD_ADDR_EXP 35
41610: PUSH
41611: EMPTY
41612: ST_TO_ADDR
// MREG_Crates := [ ] ;
41613: LD_ADDR_EXP 36
41617: PUSH
41618: EMPTY
41619: ST_TO_ADDR
// MREG_Heal := [ ] ;
41620: LD_ADDR_EXP 37
41624: PUSH
41625: EMPTY
41626: ST_TO_ADDR
// MREG_Tame := [ ] ;
41627: LD_ADDR_EXP 39
41631: PUSH
41632: EMPTY
41633: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41634: LD_ADDR_EXP 40
41638: PUSH
41639: EMPTY
41640: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41641: LD_ADDR_EXP 41
41645: PUSH
41646: EMPTY
41647: ST_TO_ADDR
// MREG_LabList := [ ] ;
41648: LD_ADDR_EXP 42
41652: PUSH
41653: EMPTY
41654: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41655: LD_ADDR_EXP 43
41659: PUSH
41660: EMPTY
41661: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41662: LD_ADDR_EXP 44
41666: PUSH
41667: EMPTY
41668: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41669: LD_ADDR_EXP 45
41673: PUSH
41674: EMPTY
41675: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41676: LD_ADDR_EXP 46
41680: PUSH
41681: EMPTY
41682: ST_TO_ADDR
// MREG_Status := [ ] ;
41683: LD_ADDR_EXP 47
41687: PUSH
41688: EMPTY
41689: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41690: LD_ADDR_EXP 48
41694: PUSH
41695: EMPTY
41696: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41697: LD_ADDR_EXP 49
41701: PUSH
41702: EMPTY
41703: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41704: LD_ADDR_EXP 50
41708: PUSH
41709: EMPTY
41710: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41711: LD_ADDR_EXP 51
41715: PUSH
41716: EMPTY
41717: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41718: LD_ADDR_EXP 52
41722: PUSH
41723: EMPTY
41724: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41725: LD_ADDR_EXP 53
41729: PUSH
41730: EMPTY
41731: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41732: LD_ADDR_EXP 54
41736: PUSH
41737: EMPTY
41738: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41739: LD_ADDR_EXP 55
41743: PUSH
41744: EMPTY
41745: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41746: LD_ADDR_EXP 56
41750: PUSH
41751: EMPTY
41752: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41753: LD_ADDR_EXP 57
41757: PUSH
41758: EMPTY
41759: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41760: LD_ADDR_EXP 58
41764: PUSH
41765: EMPTY
41766: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41767: LD_ADDR_EXP 59
41771: PUSH
41772: EMPTY
41773: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41774: LD_ADDR_EXP 63
41778: PUSH
41779: EMPTY
41780: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41781: LD_ADDR_EXP 64
41785: PUSH
41786: EMPTY
41787: ST_TO_ADDR
// MREG_Parking := [ ] ;
41788: LD_ADDR_EXP 60
41792: PUSH
41793: EMPTY
41794: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41795: LD_ADDR_EXP 61
41799: PUSH
41800: EMPTY
41801: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41802: LD_ADDR_EXP 65
41806: PUSH
41807: EMPTY
41808: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41809: LD_ADDR_EXP 66
41813: PUSH
41814: EMPTY
41815: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41816: LD_ADDR_EXP 67
41820: PUSH
41821: EMPTY
41822: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41823: LD_ADDR_EXP 69
41827: PUSH
41828: EMPTY
41829: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41830: LD_ADDR_EXP 70
41834: PUSH
41835: EMPTY
41836: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41837: LD_ADDR_EXP 71
41841: PUSH
41842: EMPTY
41843: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41844: LD_ADDR_EXP 73
41848: PUSH
41849: EMPTY
41850: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41851: LD_ADDR_EXP 72
41855: PUSH
41856: EMPTY
41857: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41858: LD_ADDR_EXP 74
41862: PUSH
41863: LD_INT 300
41865: PUSH
41866: LD_INT 100
41868: PUSH
41869: LD_INT 25
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: LIST
41876: ST_TO_ADDR
// end ;
41877: LD_VAR 0 1
41881: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41882: LD_INT 0
41884: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41885: LD_VAR 0 2
41889: PUSH
41890: LD_VAR 0 3
41894: PUSH
41895: LD_VAR 0 4
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: LIST
41904: PUSH
41905: LD_VAR 0 1
41909: IN
41910: IFFALSE 41924
// result := mreg_list else
41912: LD_ADDR_VAR 0 5
41916: PUSH
41917: LD_VAR 0 1
41921: ST_TO_ADDR
41922: GO 41958
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
41924: LD_ADDR_VAR 0 1
41928: PUSH
41929: LD_VAR 0 1
41933: PUSH
41934: LD_VAR 0 2
41938: PUSH
41939: LD_VAR 0 3
41943: PUSH
41944: LD_VAR 0 4
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: LIST
41953: PUSH
41954: EMPTY
41955: LIST
41956: ADD
41957: ST_TO_ADDR
// result := mreg_list ;
41958: LD_ADDR_VAR 0 5
41962: PUSH
41963: LD_VAR 0 1
41967: ST_TO_ADDR
// end ;
41968: LD_VAR 0 5
41972: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
41973: LD_INT 0
41975: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41976: LD_VAR 0 2
41980: PUSH
41981: LD_VAR 0 3
41985: PUSH
41986: LD_VAR 0 4
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: LIST
41995: PUSH
41996: LD_VAR 0 1
42000: IN
42001: IFFALSE 42039
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42003: LD_ADDR_VAR 0 5
42007: PUSH
42008: LD_VAR 0 1
42012: PUSH
42013: LD_VAR 0 2
42017: PUSH
42018: LD_VAR 0 3
42022: PUSH
42023: LD_VAR 0 4
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: LIST
42032: PUSH
42033: EMPTY
42034: LIST
42035: DIFF
42036: ST_TO_ADDR
42037: GO 42049
// result := mreg_list ;
42039: LD_ADDR_VAR 0 5
42043: PUSH
42044: LD_VAR 0 1
42048: ST_TO_ADDR
// end ;
42049: LD_VAR 0 5
42053: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42054: LD_INT 0
42056: PPUSH
42057: PPUSH
42058: PPUSH
// for j = 1 to 8 do
42059: LD_ADDR_VAR 0 3
42063: PUSH
42064: DOUBLE
42065: LD_INT 1
42067: DEC
42068: ST_TO_ADDR
42069: LD_INT 8
42071: PUSH
42072: FOR_TO
42073: IFFALSE 42914
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42075: LD_VAR 0 3
42079: PPUSH
42080: LD_INT 51
42082: PUSH
42083: EMPTY
42084: LIST
42085: PPUSH
42086: CALL 11587 0 2
42090: PUSH
42091: LD_OWVAR 2
42095: PUSH
42096: LD_VAR 0 3
42100: EQUAL
42101: NOT
42102: AND
42103: IFFALSE 42121
// MREG_SidesList := MREG_SidesList ^ 1 else
42105: LD_ADDR_EXP 41
42109: PUSH
42110: LD_EXP 41
42114: PUSH
42115: LD_INT 1
42117: ADD
42118: ST_TO_ADDR
42119: GO 42135
// MREG_SidesList := MREG_SidesList ^ 0 ;
42121: LD_ADDR_EXP 41
42125: PUSH
42126: LD_EXP 41
42130: PUSH
42131: LD_INT 0
42133: ADD
42134: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42135: LD_VAR 0 3
42139: PPUSH
42140: LD_INT 2
42142: PUSH
42143: LD_INT 34
42145: PUSH
42146: LD_INT 12
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 34
42155: PUSH
42156: LD_INT 32
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 34
42165: PUSH
42166: LD_INT 51
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: PUSH
42179: EMPTY
42180: LIST
42181: PPUSH
42182: CALL 11888 0 2
42186: IFFALSE 42287
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42188: LD_ADDR_VAR 0 2
42192: PUSH
42193: LD_VAR 0 3
42197: PPUSH
42198: LD_INT 2
42200: PUSH
42201: LD_INT 34
42203: PUSH
42204: LD_INT 12
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 34
42213: PUSH
42214: LD_INT 32
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 51
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: LIST
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PPUSH
42240: CALL 11888 0 2
42244: PUSH
42245: FOR_IN
42246: IFFALSE 42285
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42248: LD_ADDR_EXP 43
42252: PUSH
42253: LD_EXP 43
42257: PPUSH
42258: LD_VAR 0 3
42262: PPUSH
42263: LD_VAR 0 2
42267: PPUSH
42268: LD_VAR 0 2
42272: PPUSH
42273: CALL_OW 264
42277: PPUSH
42278: CALL 41882 0 4
42282: ST_TO_ADDR
42283: GO 42245
42285: POP
42286: POP
// if MCF_Class ( j , 4 , [ ] ) then
42287: LD_VAR 0 3
42291: PPUSH
42292: LD_INT 4
42294: PPUSH
42295: EMPTY
42296: PPUSH
42297: CALL 11670 0 3
42301: IFFALSE 42334
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42303: LD_ADDR_EXP 56
42307: PUSH
42308: LD_EXP 56
42312: PUSH
42313: LD_VAR 0 3
42317: PPUSH
42318: LD_INT 4
42320: PPUSH
42321: EMPTY
42322: PPUSH
42323: CALL 11670 0 3
42327: PUSH
42328: EMPTY
42329: LIST
42330: ADD
42331: ST_TO_ADDR
42332: GO 42351
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42334: LD_ADDR_EXP 56
42338: PUSH
42339: LD_EXP 56
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: EMPTY
42348: LIST
42349: ADD
42350: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42351: LD_VAR 0 3
42355: PPUSH
42356: LD_INT 3
42358: PPUSH
42359: EMPTY
42360: PPUSH
42361: CALL 11670 0 3
42365: IFFALSE 42398
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42367: LD_ADDR_EXP 57
42371: PUSH
42372: LD_EXP 57
42376: PUSH
42377: LD_VAR 0 3
42381: PPUSH
42382: LD_INT 3
42384: PPUSH
42385: EMPTY
42386: PPUSH
42387: CALL 11670 0 3
42391: PUSH
42392: EMPTY
42393: LIST
42394: ADD
42395: ST_TO_ADDR
42396: GO 42415
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42398: LD_ADDR_EXP 57
42402: PUSH
42403: LD_EXP 57
42407: PUSH
42408: LD_INT 0
42410: PUSH
42411: EMPTY
42412: LIST
42413: ADD
42414: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42415: LD_VAR 0 3
42419: PPUSH
42420: LD_INT 1
42422: PPUSH
42423: EMPTY
42424: PPUSH
42425: CALL 11670 0 3
42429: IFFALSE 42462
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42431: LD_ADDR_EXP 58
42435: PUSH
42436: LD_EXP 58
42440: PUSH
42441: LD_VAR 0 3
42445: PPUSH
42446: LD_INT 1
42448: PPUSH
42449: EMPTY
42450: PPUSH
42451: CALL 11670 0 3
42455: PUSH
42456: EMPTY
42457: LIST
42458: ADD
42459: ST_TO_ADDR
42460: GO 42479
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42462: LD_ADDR_EXP 58
42466: PUSH
42467: LD_EXP 58
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: EMPTY
42476: LIST
42477: ADD
42478: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42479: LD_VAR 0 3
42483: PPUSH
42484: LD_INT 2
42486: PPUSH
42487: EMPTY
42488: PPUSH
42489: CALL 11670 0 3
42493: IFFALSE 42526
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42495: LD_ADDR_EXP 59
42499: PUSH
42500: LD_EXP 59
42504: PUSH
42505: LD_VAR 0 3
42509: PPUSH
42510: LD_INT 2
42512: PPUSH
42513: EMPTY
42514: PPUSH
42515: CALL 11670 0 3
42519: PUSH
42520: EMPTY
42521: LIST
42522: ADD
42523: ST_TO_ADDR
42524: GO 42543
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42526: LD_ADDR_EXP 59
42530: PUSH
42531: LD_EXP 59
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: EMPTY
42540: LIST
42541: ADD
42542: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42543: LD_ADDR_EXP 49
42547: PUSH
42548: LD_EXP 49
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: EMPTY
42557: LIST
42558: ADD
42559: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42560: LD_ADDR_EXP 37
42564: PUSH
42565: LD_EXP 37
42569: PUSH
42570: LD_INT 0
42572: PUSH
42573: EMPTY
42574: LIST
42575: ADD
42576: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42577: LD_ADDR_EXP 39
42581: PUSH
42582: LD_EXP 39
42586: PUSH
42587: LD_INT 0
42589: PUSH
42590: EMPTY
42591: LIST
42592: ADD
42593: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42594: LD_ADDR_EXP 60
42598: PUSH
42599: LD_EXP 60
42603: PUSH
42604: LD_INT 0
42606: PUSH
42607: EMPTY
42608: LIST
42609: ADD
42610: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42611: LD_ADDR_EXP 61
42615: PUSH
42616: LD_EXP 61
42620: PUSH
42621: LD_INT 0
42623: PUSH
42624: EMPTY
42625: LIST
42626: ADD
42627: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42628: LD_ADDR_EXP 53
42632: PUSH
42633: LD_EXP 53
42637: PUSH
42638: LD_INT 0
42640: PUSH
42641: EMPTY
42642: LIST
42643: ADD
42644: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42645: LD_ADDR_EXP 40
42649: PUSH
42650: LD_EXP 40
42654: PUSH
42655: LD_INT 0
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 0
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: PUSH
42673: EMPTY
42674: LIST
42675: ADD
42676: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42677: LD_ADDR_EXP 62
42681: PUSH
42682: LD_EXP 62
42686: PUSH
42687: LD_INT 0
42689: PUSH
42690: EMPTY
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: EMPTY
42697: LIST
42698: ADD
42699: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42700: LD_ADDR_EXP 63
42704: PUSH
42705: LD_EXP 63
42709: PUSH
42710: LD_INT 0
42712: PUSH
42713: EMPTY
42714: LIST
42715: PUSH
42716: EMPTY
42717: LIST
42718: ADD
42719: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42720: LD_ADDR_EXP 44
42724: PUSH
42725: LD_EXP 44
42729: PUSH
42730: LD_INT 0
42732: PUSH
42733: EMPTY
42734: LIST
42735: ADD
42736: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42737: LD_ADDR_EXP 65
42741: PUSH
42742: LD_EXP 65
42746: PUSH
42747: LD_INT 0
42749: PUSH
42750: EMPTY
42751: LIST
42752: ADD
42753: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42754: LD_ADDR_EXP 66
42758: PUSH
42759: LD_EXP 66
42763: PUSH
42764: LD_INT 0
42766: PUSH
42767: EMPTY
42768: LIST
42769: ADD
42770: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42771: LD_ADDR_EXP 67
42775: PUSH
42776: LD_EXP 67
42780: PUSH
42781: LD_INT 0
42783: PUSH
42784: EMPTY
42785: LIST
42786: ADD
42787: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42788: LD_ADDR_EXP 68
42792: PUSH
42793: LD_EXP 68
42797: PUSH
42798: LD_INT 0
42800: PUSH
42801: EMPTY
42802: LIST
42803: ADD
42804: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42805: LD_ADDR_EXP 69
42809: PUSH
42810: LD_EXP 69
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: EMPTY
42819: LIST
42820: ADD
42821: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42822: LD_ADDR_EXP 70
42826: PUSH
42827: LD_EXP 70
42831: PUSH
42832: LD_INT 0
42834: PUSH
42835: EMPTY
42836: LIST
42837: ADD
42838: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42839: LD_ADDR_EXP 71
42843: PUSH
42844: LD_EXP 71
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: EMPTY
42853: LIST
42854: ADD
42855: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42856: LD_ADDR_EXP 73
42860: PUSH
42861: LD_EXP 73
42865: PUSH
42866: LD_INT 0
42868: PUSH
42869: EMPTY
42870: LIST
42871: ADD
42872: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42873: LD_ADDR_EXP 72
42877: PUSH
42878: LD_EXP 72
42882: PUSH
42883: LD_INT 0
42885: ADD
42886: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42887: LD_ADDR_EXP 64
42891: PUSH
42892: LD_EXP 64
42896: PUSH
42897: LD_INT 0
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: LIST
42910: ADD
42911: ST_TO_ADDR
// end ;
42912: GO 42072
42914: POP
42915: POP
// end ;
42916: LD_VAR 0 1
42920: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42921: LD_INT 0
42923: PPUSH
42924: PPUSH
42925: PPUSH
// m := false ;
42926: LD_ADDR_VAR 0 5
42930: PUSH
42931: LD_INT 0
42933: ST_TO_ADDR
// for i = 1 to mreg do
42934: LD_ADDR_VAR 0 4
42938: PUSH
42939: DOUBLE
42940: LD_INT 1
42942: DEC
42943: ST_TO_ADDR
42944: LD_VAR 0 2
42948: PUSH
42949: FOR_TO
42950: IFFALSE 42986
// if mreg [ i ] [ 1 ] = side then
42952: LD_VAR 0 2
42956: PUSH
42957: LD_VAR 0 4
42961: ARRAY
42962: PUSH
42963: LD_INT 1
42965: ARRAY
42966: PUSH
42967: LD_VAR 0 1
42971: EQUAL
42972: IFFALSE 42984
// begin m := true ;
42974: LD_ADDR_VAR 0 5
42978: PUSH
42979: LD_INT 1
42981: ST_TO_ADDR
// break ;
42982: GO 42986
// end ;
42984: GO 42949
42986: POP
42987: POP
// result := m ;
42988: LD_ADDR_VAR 0 3
42992: PUSH
42993: LD_VAR 0 5
42997: ST_TO_ADDR
// end ;
42998: LD_VAR 0 3
43002: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43003: LD_INT 0
43005: PPUSH
43006: PPUSH
43007: PPUSH
// m := 0 ;
43008: LD_ADDR_VAR 0 5
43012: PUSH
43013: LD_INT 0
43015: ST_TO_ADDR
// for i = 1 to mreg do
43016: LD_ADDR_VAR 0 4
43020: PUSH
43021: DOUBLE
43022: LD_INT 1
43024: DEC
43025: ST_TO_ADDR
43026: LD_VAR 0 2
43030: PUSH
43031: FOR_TO
43032: IFFALSE 43072
// if mreg [ i ] [ 1 ] = side then
43034: LD_VAR 0 2
43038: PUSH
43039: LD_VAR 0 4
43043: ARRAY
43044: PUSH
43045: LD_INT 1
43047: ARRAY
43048: PUSH
43049: LD_VAR 0 1
43053: EQUAL
43054: IFFALSE 43070
// begin m := m + 1 ;
43056: LD_ADDR_VAR 0 5
43060: PUSH
43061: LD_VAR 0 5
43065: PUSH
43066: LD_INT 1
43068: PLUS
43069: ST_TO_ADDR
// end ;
43070: GO 43031
43072: POP
43073: POP
// result := m ;
43074: LD_ADDR_VAR 0 3
43078: PUSH
43079: LD_VAR 0 5
43083: ST_TO_ADDR
// end ;
43084: LD_VAR 0 3
43088: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43089: LD_INT 0
43091: PPUSH
43092: PPUSH
// result := 0 ;
43093: LD_ADDR_VAR 0 3
43097: PUSH
43098: LD_INT 0
43100: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43101: LD_ADDR_VAR 0 4
43105: PUSH
43106: DOUBLE
43107: LD_INT 1
43109: DEC
43110: ST_TO_ADDR
43111: LD_EXP 55
43115: PUSH
43116: FOR_TO
43117: IFFALSE 43179
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43119: LD_EXP 55
43123: PUSH
43124: LD_VAR 0 4
43128: ARRAY
43129: PUSH
43130: LD_INT 1
43132: ARRAY
43133: PUSH
43134: LD_VAR 0 1
43138: EQUAL
43139: PUSH
43140: LD_EXP 55
43144: PUSH
43145: LD_VAR 0 4
43149: ARRAY
43150: PUSH
43151: LD_INT 2
43153: ARRAY
43154: PUSH
43155: LD_VAR 0 2
43159: EQUAL
43160: AND
43161: IFFALSE 43177
// begin result := result + 1 ;
43163: LD_ADDR_VAR 0 3
43167: PUSH
43168: LD_VAR 0 3
43172: PUSH
43173: LD_INT 1
43175: PLUS
43176: ST_TO_ADDR
// end ;
43177: GO 43116
43179: POP
43180: POP
// end ; end_of_file
43181: LD_VAR 0 3
43185: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
43186: LD_INT 0
43188: PPUSH
// ar_miner := 81 ;
43189: LD_ADDR_EXP 82
43193: PUSH
43194: LD_INT 81
43196: ST_TO_ADDR
// ar_crane := 88 ;
43197: LD_ADDR_EXP 81
43201: PUSH
43202: LD_INT 88
43204: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43205: LD_ADDR_EXP 76
43209: PUSH
43210: LD_INT 89
43212: ST_TO_ADDR
// us_hack := 99 ;
43213: LD_ADDR_EXP 77
43217: PUSH
43218: LD_INT 99
43220: ST_TO_ADDR
// us_artillery := 97 ;
43221: LD_ADDR_EXP 78
43225: PUSH
43226: LD_INT 97
43228: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43229: LD_ADDR_EXP 79
43233: PUSH
43234: LD_INT 91
43236: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
43237: LD_ADDR_EXP 80
43241: PUSH
43242: LD_INT 92
43244: ST_TO_ADDR
// ru_radar := 98 ;
43245: LD_ADDR_EXP 75
43249: PUSH
43250: LD_INT 98
43252: ST_TO_ADDR
// tech_Artillery := 80 ;
43253: LD_ADDR_EXP 83
43257: PUSH
43258: LD_INT 80
43260: ST_TO_ADDR
// tech_RadMat := 81 ;
43261: LD_ADDR_EXP 84
43265: PUSH
43266: LD_INT 81
43268: ST_TO_ADDR
// tech_BasicTools := 82 ;
43269: LD_ADDR_EXP 85
43273: PUSH
43274: LD_INT 82
43276: ST_TO_ADDR
// tech_Cargo := 83 ;
43277: LD_ADDR_EXP 86
43281: PUSH
43282: LD_INT 83
43284: ST_TO_ADDR
// tech_Track := 84 ;
43285: LD_ADDR_EXP 87
43289: PUSH
43290: LD_INT 84
43292: ST_TO_ADDR
// tech_Crane := 85 ;
43293: LD_ADDR_EXP 88
43297: PUSH
43298: LD_INT 85
43300: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43301: LD_ADDR_EXP 89
43305: PUSH
43306: LD_INT 86
43308: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43309: LD_ADDR_EXP 90
43313: PUSH
43314: LD_INT 87
43316: ST_TO_ADDR
// class_mastodont := 31 ;
43317: LD_ADDR_EXP 91
43321: PUSH
43322: LD_INT 31
43324: ST_TO_ADDR
// class_horse := 21 ;
43325: LD_ADDR_EXP 92
43329: PUSH
43330: LD_INT 21
43332: ST_TO_ADDR
// end ;
43333: LD_VAR 0 1
43337: RET
// every 1 do
43338: GO 43340
43340: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43341: CALL 43186 0 0
43345: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43346: LD_INT 0
43348: PPUSH
// if p2 = 100 then
43349: LD_VAR 0 2
43353: PUSH
43354: LD_INT 100
43356: EQUAL
43357: IFFALSE 44306
// begin if not StreamModeActive then
43359: LD_EXP 93
43363: NOT
43364: IFFALSE 43374
// StreamModeActive := true ;
43366: LD_ADDR_EXP 93
43370: PUSH
43371: LD_INT 1
43373: ST_TO_ADDR
// if p3 = 0 then
43374: LD_VAR 0 3
43378: PUSH
43379: LD_INT 0
43381: EQUAL
43382: IFFALSE 43388
// InitStreamMode ;
43384: CALL 44466 0 0
// if p3 = 1 then
43388: LD_VAR 0 3
43392: PUSH
43393: LD_INT 1
43395: EQUAL
43396: IFFALSE 43406
// sRocket := true ;
43398: LD_ADDR_EXP 98
43402: PUSH
43403: LD_INT 1
43405: ST_TO_ADDR
// if p3 = 2 then
43406: LD_VAR 0 3
43410: PUSH
43411: LD_INT 2
43413: EQUAL
43414: IFFALSE 43424
// sSpeed := true ;
43416: LD_ADDR_EXP 97
43420: PUSH
43421: LD_INT 1
43423: ST_TO_ADDR
// if p3 = 3 then
43424: LD_VAR 0 3
43428: PUSH
43429: LD_INT 3
43431: EQUAL
43432: IFFALSE 43442
// sEngine := true ;
43434: LD_ADDR_EXP 99
43438: PUSH
43439: LD_INT 1
43441: ST_TO_ADDR
// if p3 = 4 then
43442: LD_VAR 0 3
43446: PUSH
43447: LD_INT 4
43449: EQUAL
43450: IFFALSE 43460
// sSpec := true ;
43452: LD_ADDR_EXP 96
43456: PUSH
43457: LD_INT 1
43459: ST_TO_ADDR
// if p3 = 5 then
43460: LD_VAR 0 3
43464: PUSH
43465: LD_INT 5
43467: EQUAL
43468: IFFALSE 43478
// sLevel := true ;
43470: LD_ADDR_EXP 100
43474: PUSH
43475: LD_INT 1
43477: ST_TO_ADDR
// if p3 = 6 then
43478: LD_VAR 0 3
43482: PUSH
43483: LD_INT 6
43485: EQUAL
43486: IFFALSE 43496
// sArmoury := true ;
43488: LD_ADDR_EXP 101
43492: PUSH
43493: LD_INT 1
43495: ST_TO_ADDR
// if p3 = 7 then
43496: LD_VAR 0 3
43500: PUSH
43501: LD_INT 7
43503: EQUAL
43504: IFFALSE 43514
// sRadar := true ;
43506: LD_ADDR_EXP 102
43510: PUSH
43511: LD_INT 1
43513: ST_TO_ADDR
// if p3 = 8 then
43514: LD_VAR 0 3
43518: PUSH
43519: LD_INT 8
43521: EQUAL
43522: IFFALSE 43532
// sBunker := true ;
43524: LD_ADDR_EXP 103
43528: PUSH
43529: LD_INT 1
43531: ST_TO_ADDR
// if p3 = 9 then
43532: LD_VAR 0 3
43536: PUSH
43537: LD_INT 9
43539: EQUAL
43540: IFFALSE 43550
// sHack := true ;
43542: LD_ADDR_EXP 104
43546: PUSH
43547: LD_INT 1
43549: ST_TO_ADDR
// if p3 = 10 then
43550: LD_VAR 0 3
43554: PUSH
43555: LD_INT 10
43557: EQUAL
43558: IFFALSE 43568
// sFire := true ;
43560: LD_ADDR_EXP 105
43564: PUSH
43565: LD_INT 1
43567: ST_TO_ADDR
// if p3 = 11 then
43568: LD_VAR 0 3
43572: PUSH
43573: LD_INT 11
43575: EQUAL
43576: IFFALSE 43586
// sRefresh := true ;
43578: LD_ADDR_EXP 106
43582: PUSH
43583: LD_INT 1
43585: ST_TO_ADDR
// if p3 = 12 then
43586: LD_VAR 0 3
43590: PUSH
43591: LD_INT 12
43593: EQUAL
43594: IFFALSE 43604
// sExp := true ;
43596: LD_ADDR_EXP 107
43600: PUSH
43601: LD_INT 1
43603: ST_TO_ADDR
// if p3 = 13 then
43604: LD_VAR 0 3
43608: PUSH
43609: LD_INT 13
43611: EQUAL
43612: IFFALSE 43622
// sDepot := true ;
43614: LD_ADDR_EXP 108
43618: PUSH
43619: LD_INT 1
43621: ST_TO_ADDR
// if p3 = 14 then
43622: LD_VAR 0 3
43626: PUSH
43627: LD_INT 14
43629: EQUAL
43630: IFFALSE 43640
// sFlag := true ;
43632: LD_ADDR_EXP 109
43636: PUSH
43637: LD_INT 1
43639: ST_TO_ADDR
// if p3 = 15 then
43640: LD_VAR 0 3
43644: PUSH
43645: LD_INT 15
43647: EQUAL
43648: IFFALSE 43658
// sKamikadze := true ;
43650: LD_ADDR_EXP 117
43654: PUSH
43655: LD_INT 1
43657: ST_TO_ADDR
// if p3 = 16 then
43658: LD_VAR 0 3
43662: PUSH
43663: LD_INT 16
43665: EQUAL
43666: IFFALSE 43676
// sTroll := true ;
43668: LD_ADDR_EXP 118
43672: PUSH
43673: LD_INT 1
43675: ST_TO_ADDR
// if p3 = 17 then
43676: LD_VAR 0 3
43680: PUSH
43681: LD_INT 17
43683: EQUAL
43684: IFFALSE 43694
// sSlow := true ;
43686: LD_ADDR_EXP 119
43690: PUSH
43691: LD_INT 1
43693: ST_TO_ADDR
// if p3 = 18 then
43694: LD_VAR 0 3
43698: PUSH
43699: LD_INT 18
43701: EQUAL
43702: IFFALSE 43712
// sLack := true ;
43704: LD_ADDR_EXP 120
43708: PUSH
43709: LD_INT 1
43711: ST_TO_ADDR
// if p3 = 19 then
43712: LD_VAR 0 3
43716: PUSH
43717: LD_INT 19
43719: EQUAL
43720: IFFALSE 43730
// sTank := true ;
43722: LD_ADDR_EXP 122
43726: PUSH
43727: LD_INT 1
43729: ST_TO_ADDR
// if p3 = 20 then
43730: LD_VAR 0 3
43734: PUSH
43735: LD_INT 20
43737: EQUAL
43738: IFFALSE 43748
// sRemote := true ;
43740: LD_ADDR_EXP 123
43744: PUSH
43745: LD_INT 1
43747: ST_TO_ADDR
// if p3 = 21 then
43748: LD_VAR 0 3
43752: PUSH
43753: LD_INT 21
43755: EQUAL
43756: IFFALSE 43766
// sPowell := true ;
43758: LD_ADDR_EXP 124
43762: PUSH
43763: LD_INT 1
43765: ST_TO_ADDR
// if p3 = 22 then
43766: LD_VAR 0 3
43770: PUSH
43771: LD_INT 22
43773: EQUAL
43774: IFFALSE 43784
// sTeleport := true ;
43776: LD_ADDR_EXP 127
43780: PUSH
43781: LD_INT 1
43783: ST_TO_ADDR
// if p3 = 23 then
43784: LD_VAR 0 3
43788: PUSH
43789: LD_INT 23
43791: EQUAL
43792: IFFALSE 43802
// sOilTower := true ;
43794: LD_ADDR_EXP 129
43798: PUSH
43799: LD_INT 1
43801: ST_TO_ADDR
// if p3 = 24 then
43802: LD_VAR 0 3
43806: PUSH
43807: LD_INT 24
43809: EQUAL
43810: IFFALSE 43820
// sShovel := true ;
43812: LD_ADDR_EXP 130
43816: PUSH
43817: LD_INT 1
43819: ST_TO_ADDR
// if p3 = 25 then
43820: LD_VAR 0 3
43824: PUSH
43825: LD_INT 25
43827: EQUAL
43828: IFFALSE 43838
// sSheik := true ;
43830: LD_ADDR_EXP 131
43834: PUSH
43835: LD_INT 1
43837: ST_TO_ADDR
// if p3 = 26 then
43838: LD_VAR 0 3
43842: PUSH
43843: LD_INT 26
43845: EQUAL
43846: IFFALSE 43856
// sEarthquake := true ;
43848: LD_ADDR_EXP 133
43852: PUSH
43853: LD_INT 1
43855: ST_TO_ADDR
// if p3 = 27 then
43856: LD_VAR 0 3
43860: PUSH
43861: LD_INT 27
43863: EQUAL
43864: IFFALSE 43874
// sAI := true ;
43866: LD_ADDR_EXP 134
43870: PUSH
43871: LD_INT 1
43873: ST_TO_ADDR
// if p3 = 28 then
43874: LD_VAR 0 3
43878: PUSH
43879: LD_INT 28
43881: EQUAL
43882: IFFALSE 43892
// sCargo := true ;
43884: LD_ADDR_EXP 137
43888: PUSH
43889: LD_INT 1
43891: ST_TO_ADDR
// if p3 = 29 then
43892: LD_VAR 0 3
43896: PUSH
43897: LD_INT 29
43899: EQUAL
43900: IFFALSE 43910
// sDLaser := true ;
43902: LD_ADDR_EXP 138
43906: PUSH
43907: LD_INT 1
43909: ST_TO_ADDR
// if p3 = 30 then
43910: LD_VAR 0 3
43914: PUSH
43915: LD_INT 30
43917: EQUAL
43918: IFFALSE 43928
// sExchange := true ;
43920: LD_ADDR_EXP 139
43924: PUSH
43925: LD_INT 1
43927: ST_TO_ADDR
// if p3 = 31 then
43928: LD_VAR 0 3
43932: PUSH
43933: LD_INT 31
43935: EQUAL
43936: IFFALSE 43946
// sFac := true ;
43938: LD_ADDR_EXP 140
43942: PUSH
43943: LD_INT 1
43945: ST_TO_ADDR
// if p3 = 32 then
43946: LD_VAR 0 3
43950: PUSH
43951: LD_INT 32
43953: EQUAL
43954: IFFALSE 43964
// sPower := true ;
43956: LD_ADDR_EXP 141
43960: PUSH
43961: LD_INT 1
43963: ST_TO_ADDR
// if p3 = 33 then
43964: LD_VAR 0 3
43968: PUSH
43969: LD_INT 33
43971: EQUAL
43972: IFFALSE 43982
// sRandom := true ;
43974: LD_ADDR_EXP 142
43978: PUSH
43979: LD_INT 1
43981: ST_TO_ADDR
// if p3 = 34 then
43982: LD_VAR 0 3
43986: PUSH
43987: LD_INT 34
43989: EQUAL
43990: IFFALSE 44000
// sShield := true ;
43992: LD_ADDR_EXP 143
43996: PUSH
43997: LD_INT 1
43999: ST_TO_ADDR
// if p3 = 35 then
44000: LD_VAR 0 3
44004: PUSH
44005: LD_INT 35
44007: EQUAL
44008: IFFALSE 44018
// sTime := true ;
44010: LD_ADDR_EXP 144
44014: PUSH
44015: LD_INT 1
44017: ST_TO_ADDR
// if p3 = 36 then
44018: LD_VAR 0 3
44022: PUSH
44023: LD_INT 36
44025: EQUAL
44026: IFFALSE 44036
// sTools := true ;
44028: LD_ADDR_EXP 145
44032: PUSH
44033: LD_INT 1
44035: ST_TO_ADDR
// if p3 = 101 then
44036: LD_VAR 0 3
44040: PUSH
44041: LD_INT 101
44043: EQUAL
44044: IFFALSE 44054
// sSold := true ;
44046: LD_ADDR_EXP 110
44050: PUSH
44051: LD_INT 1
44053: ST_TO_ADDR
// if p3 = 102 then
44054: LD_VAR 0 3
44058: PUSH
44059: LD_INT 102
44061: EQUAL
44062: IFFALSE 44072
// sDiff := true ;
44064: LD_ADDR_EXP 111
44068: PUSH
44069: LD_INT 1
44071: ST_TO_ADDR
// if p3 = 103 then
44072: LD_VAR 0 3
44076: PUSH
44077: LD_INT 103
44079: EQUAL
44080: IFFALSE 44090
// sFog := true ;
44082: LD_ADDR_EXP 114
44086: PUSH
44087: LD_INT 1
44089: ST_TO_ADDR
// if p3 = 104 then
44090: LD_VAR 0 3
44094: PUSH
44095: LD_INT 104
44097: EQUAL
44098: IFFALSE 44108
// sReset := true ;
44100: LD_ADDR_EXP 115
44104: PUSH
44105: LD_INT 1
44107: ST_TO_ADDR
// if p3 = 105 then
44108: LD_VAR 0 3
44112: PUSH
44113: LD_INT 105
44115: EQUAL
44116: IFFALSE 44126
// sSun := true ;
44118: LD_ADDR_EXP 116
44122: PUSH
44123: LD_INT 1
44125: ST_TO_ADDR
// if p3 = 106 then
44126: LD_VAR 0 3
44130: PUSH
44131: LD_INT 106
44133: EQUAL
44134: IFFALSE 44144
// sTiger := true ;
44136: LD_ADDR_EXP 112
44140: PUSH
44141: LD_INT 1
44143: ST_TO_ADDR
// if p3 = 107 then
44144: LD_VAR 0 3
44148: PUSH
44149: LD_INT 107
44151: EQUAL
44152: IFFALSE 44162
// sBomb := true ;
44154: LD_ADDR_EXP 113
44158: PUSH
44159: LD_INT 1
44161: ST_TO_ADDR
// if p3 = 108 then
44162: LD_VAR 0 3
44166: PUSH
44167: LD_INT 108
44169: EQUAL
44170: IFFALSE 44180
// sWound := true ;
44172: LD_ADDR_EXP 121
44176: PUSH
44177: LD_INT 1
44179: ST_TO_ADDR
// if p3 = 109 then
44180: LD_VAR 0 3
44184: PUSH
44185: LD_INT 109
44187: EQUAL
44188: IFFALSE 44198
// sBetray := true ;
44190: LD_ADDR_EXP 125
44194: PUSH
44195: LD_INT 1
44197: ST_TO_ADDR
// if p3 = 110 then
44198: LD_VAR 0 3
44202: PUSH
44203: LD_INT 110
44205: EQUAL
44206: IFFALSE 44216
// sContamin := true ;
44208: LD_ADDR_EXP 126
44212: PUSH
44213: LD_INT 1
44215: ST_TO_ADDR
// if p3 = 111 then
44216: LD_VAR 0 3
44220: PUSH
44221: LD_INT 111
44223: EQUAL
44224: IFFALSE 44234
// sOil := true ;
44226: LD_ADDR_EXP 128
44230: PUSH
44231: LD_INT 1
44233: ST_TO_ADDR
// if p3 = 112 then
44234: LD_VAR 0 3
44238: PUSH
44239: LD_INT 112
44241: EQUAL
44242: IFFALSE 44252
// sStu := true ;
44244: LD_ADDR_EXP 132
44248: PUSH
44249: LD_INT 1
44251: ST_TO_ADDR
// if p3 = 113 then
44252: LD_VAR 0 3
44256: PUSH
44257: LD_INT 113
44259: EQUAL
44260: IFFALSE 44270
// sBazooka := true ;
44262: LD_ADDR_EXP 135
44266: PUSH
44267: LD_INT 1
44269: ST_TO_ADDR
// if p3 = 114 then
44270: LD_VAR 0 3
44274: PUSH
44275: LD_INT 114
44277: EQUAL
44278: IFFALSE 44288
// sMortar := true ;
44280: LD_ADDR_EXP 136
44284: PUSH
44285: LD_INT 1
44287: ST_TO_ADDR
// if p3 = 115 then
44288: LD_VAR 0 3
44292: PUSH
44293: LD_INT 115
44295: EQUAL
44296: IFFALSE 44306
// sRanger := true ;
44298: LD_ADDR_EXP 146
44302: PUSH
44303: LD_INT 1
44305: ST_TO_ADDR
// end ; if p2 = 101 then
44306: LD_VAR 0 2
44310: PUSH
44311: LD_INT 101
44313: EQUAL
44314: IFFALSE 44442
// begin case p3 of 1 :
44316: LD_VAR 0 3
44320: PUSH
44321: LD_INT 1
44323: DOUBLE
44324: EQUAL
44325: IFTRUE 44329
44327: GO 44336
44329: POP
// hHackUnlimitedResources ; 2 :
44330: CALL 55479 0 0
44334: GO 44442
44336: LD_INT 2
44338: DOUBLE
44339: EQUAL
44340: IFTRUE 44344
44342: GO 44351
44344: POP
// hHackSetLevel10 ; 3 :
44345: CALL 55612 0 0
44349: GO 44442
44351: LD_INT 3
44353: DOUBLE
44354: EQUAL
44355: IFTRUE 44359
44357: GO 44366
44359: POP
// hHackSetLevel10YourUnits ; 4 :
44360: CALL 55697 0 0
44364: GO 44442
44366: LD_INT 4
44368: DOUBLE
44369: EQUAL
44370: IFTRUE 44374
44372: GO 44381
44374: POP
// hHackInvincible ; 5 :
44375: CALL 56145 0 0
44379: GO 44442
44381: LD_INT 5
44383: DOUBLE
44384: EQUAL
44385: IFTRUE 44389
44387: GO 44396
44389: POP
// hHackInvisible ; 6 :
44390: CALL 56256 0 0
44394: GO 44442
44396: LD_INT 6
44398: DOUBLE
44399: EQUAL
44400: IFTRUE 44404
44402: GO 44411
44404: POP
// hHackChangeYourSide ; 7 :
44405: CALL 56313 0 0
44409: GO 44442
44411: LD_INT 7
44413: DOUBLE
44414: EQUAL
44415: IFTRUE 44419
44417: GO 44426
44419: POP
// hHackChangeUnitSide ; 8 :
44420: CALL 56355 0 0
44424: GO 44442
44426: LD_INT 8
44428: DOUBLE
44429: EQUAL
44430: IFTRUE 44434
44432: GO 44441
44434: POP
// hHackFog ; end ;
44435: CALL 56456 0 0
44439: GO 44442
44441: POP
// end ; end ;
44442: LD_VAR 0 7
44446: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
44447: GO 44449
44449: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44450: LD_STRING initStreamRollete();
44452: PPUSH
44453: CALL_OW 559
// InitStreamMode ;
44457: CALL 44466 0 0
// DefineStreamItems ( ) ;
44461: CALL 44906 0 0
// end ;
44465: END
// function InitStreamMode ; begin
44466: LD_INT 0
44468: PPUSH
// streamModeActive := false ;
44469: LD_ADDR_EXP 93
44473: PUSH
44474: LD_INT 0
44476: ST_TO_ADDR
// normalCounter := 36 ;
44477: LD_ADDR_EXP 94
44481: PUSH
44482: LD_INT 36
44484: ST_TO_ADDR
// hardcoreCounter := 16 ;
44485: LD_ADDR_EXP 95
44489: PUSH
44490: LD_INT 16
44492: ST_TO_ADDR
// sRocket := false ;
44493: LD_ADDR_EXP 98
44497: PUSH
44498: LD_INT 0
44500: ST_TO_ADDR
// sSpeed := false ;
44501: LD_ADDR_EXP 97
44505: PUSH
44506: LD_INT 0
44508: ST_TO_ADDR
// sEngine := false ;
44509: LD_ADDR_EXP 99
44513: PUSH
44514: LD_INT 0
44516: ST_TO_ADDR
// sSpec := false ;
44517: LD_ADDR_EXP 96
44521: PUSH
44522: LD_INT 0
44524: ST_TO_ADDR
// sLevel := false ;
44525: LD_ADDR_EXP 100
44529: PUSH
44530: LD_INT 0
44532: ST_TO_ADDR
// sArmoury := false ;
44533: LD_ADDR_EXP 101
44537: PUSH
44538: LD_INT 0
44540: ST_TO_ADDR
// sRadar := false ;
44541: LD_ADDR_EXP 102
44545: PUSH
44546: LD_INT 0
44548: ST_TO_ADDR
// sBunker := false ;
44549: LD_ADDR_EXP 103
44553: PUSH
44554: LD_INT 0
44556: ST_TO_ADDR
// sHack := false ;
44557: LD_ADDR_EXP 104
44561: PUSH
44562: LD_INT 0
44564: ST_TO_ADDR
// sFire := false ;
44565: LD_ADDR_EXP 105
44569: PUSH
44570: LD_INT 0
44572: ST_TO_ADDR
// sRefresh := false ;
44573: LD_ADDR_EXP 106
44577: PUSH
44578: LD_INT 0
44580: ST_TO_ADDR
// sExp := false ;
44581: LD_ADDR_EXP 107
44585: PUSH
44586: LD_INT 0
44588: ST_TO_ADDR
// sDepot := false ;
44589: LD_ADDR_EXP 108
44593: PUSH
44594: LD_INT 0
44596: ST_TO_ADDR
// sFlag := false ;
44597: LD_ADDR_EXP 109
44601: PUSH
44602: LD_INT 0
44604: ST_TO_ADDR
// sKamikadze := false ;
44605: LD_ADDR_EXP 117
44609: PUSH
44610: LD_INT 0
44612: ST_TO_ADDR
// sTroll := false ;
44613: LD_ADDR_EXP 118
44617: PUSH
44618: LD_INT 0
44620: ST_TO_ADDR
// sSlow := false ;
44621: LD_ADDR_EXP 119
44625: PUSH
44626: LD_INT 0
44628: ST_TO_ADDR
// sLack := false ;
44629: LD_ADDR_EXP 120
44633: PUSH
44634: LD_INT 0
44636: ST_TO_ADDR
// sTank := false ;
44637: LD_ADDR_EXP 122
44641: PUSH
44642: LD_INT 0
44644: ST_TO_ADDR
// sRemote := false ;
44645: LD_ADDR_EXP 123
44649: PUSH
44650: LD_INT 0
44652: ST_TO_ADDR
// sPowell := false ;
44653: LD_ADDR_EXP 124
44657: PUSH
44658: LD_INT 0
44660: ST_TO_ADDR
// sTeleport := false ;
44661: LD_ADDR_EXP 127
44665: PUSH
44666: LD_INT 0
44668: ST_TO_ADDR
// sOilTower := false ;
44669: LD_ADDR_EXP 129
44673: PUSH
44674: LD_INT 0
44676: ST_TO_ADDR
// sShovel := false ;
44677: LD_ADDR_EXP 130
44681: PUSH
44682: LD_INT 0
44684: ST_TO_ADDR
// sSheik := false ;
44685: LD_ADDR_EXP 131
44689: PUSH
44690: LD_INT 0
44692: ST_TO_ADDR
// sEarthquake := false ;
44693: LD_ADDR_EXP 133
44697: PUSH
44698: LD_INT 0
44700: ST_TO_ADDR
// sAI := false ;
44701: LD_ADDR_EXP 134
44705: PUSH
44706: LD_INT 0
44708: ST_TO_ADDR
// sCargo := false ;
44709: LD_ADDR_EXP 137
44713: PUSH
44714: LD_INT 0
44716: ST_TO_ADDR
// sDLaser := false ;
44717: LD_ADDR_EXP 138
44721: PUSH
44722: LD_INT 0
44724: ST_TO_ADDR
// sExchange := false ;
44725: LD_ADDR_EXP 139
44729: PUSH
44730: LD_INT 0
44732: ST_TO_ADDR
// sFac := false ;
44733: LD_ADDR_EXP 140
44737: PUSH
44738: LD_INT 0
44740: ST_TO_ADDR
// sPower := false ;
44741: LD_ADDR_EXP 141
44745: PUSH
44746: LD_INT 0
44748: ST_TO_ADDR
// sRandom := false ;
44749: LD_ADDR_EXP 142
44753: PUSH
44754: LD_INT 0
44756: ST_TO_ADDR
// sShield := false ;
44757: LD_ADDR_EXP 143
44761: PUSH
44762: LD_INT 0
44764: ST_TO_ADDR
// sTime := false ;
44765: LD_ADDR_EXP 144
44769: PUSH
44770: LD_INT 0
44772: ST_TO_ADDR
// sTools := false ;
44773: LD_ADDR_EXP 145
44777: PUSH
44778: LD_INT 0
44780: ST_TO_ADDR
// sSold := false ;
44781: LD_ADDR_EXP 110
44785: PUSH
44786: LD_INT 0
44788: ST_TO_ADDR
// sDiff := false ;
44789: LD_ADDR_EXP 111
44793: PUSH
44794: LD_INT 0
44796: ST_TO_ADDR
// sFog := false ;
44797: LD_ADDR_EXP 114
44801: PUSH
44802: LD_INT 0
44804: ST_TO_ADDR
// sReset := false ;
44805: LD_ADDR_EXP 115
44809: PUSH
44810: LD_INT 0
44812: ST_TO_ADDR
// sSun := false ;
44813: LD_ADDR_EXP 116
44817: PUSH
44818: LD_INT 0
44820: ST_TO_ADDR
// sTiger := false ;
44821: LD_ADDR_EXP 112
44825: PUSH
44826: LD_INT 0
44828: ST_TO_ADDR
// sBomb := false ;
44829: LD_ADDR_EXP 113
44833: PUSH
44834: LD_INT 0
44836: ST_TO_ADDR
// sWound := false ;
44837: LD_ADDR_EXP 121
44841: PUSH
44842: LD_INT 0
44844: ST_TO_ADDR
// sBetray := false ;
44845: LD_ADDR_EXP 125
44849: PUSH
44850: LD_INT 0
44852: ST_TO_ADDR
// sContamin := false ;
44853: LD_ADDR_EXP 126
44857: PUSH
44858: LD_INT 0
44860: ST_TO_ADDR
// sOil := false ;
44861: LD_ADDR_EXP 128
44865: PUSH
44866: LD_INT 0
44868: ST_TO_ADDR
// sStu := false ;
44869: LD_ADDR_EXP 132
44873: PUSH
44874: LD_INT 0
44876: ST_TO_ADDR
// sBazooka := false ;
44877: LD_ADDR_EXP 135
44881: PUSH
44882: LD_INT 0
44884: ST_TO_ADDR
// sMortar := false ;
44885: LD_ADDR_EXP 136
44889: PUSH
44890: LD_INT 0
44892: ST_TO_ADDR
// sRanger := false ;
44893: LD_ADDR_EXP 146
44897: PUSH
44898: LD_INT 0
44900: ST_TO_ADDR
// end ;
44901: LD_VAR 0 1
44905: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44906: LD_INT 0
44908: PPUSH
44909: PPUSH
44910: PPUSH
44911: PPUSH
44912: PPUSH
// result := [ ] ;
44913: LD_ADDR_VAR 0 1
44917: PUSH
44918: EMPTY
44919: ST_TO_ADDR
// if campaign_id = 1 then
44920: LD_OWVAR 69
44924: PUSH
44925: LD_INT 1
44927: EQUAL
44928: IFFALSE 47866
// begin case mission_number of 1 :
44930: LD_OWVAR 70
44934: PUSH
44935: LD_INT 1
44937: DOUBLE
44938: EQUAL
44939: IFTRUE 44943
44941: GO 45007
44943: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44944: LD_ADDR_VAR 0 1
44948: PUSH
44949: LD_INT 2
44951: PUSH
44952: LD_INT 4
44954: PUSH
44955: LD_INT 11
44957: PUSH
44958: LD_INT 12
44960: PUSH
44961: LD_INT 15
44963: PUSH
44964: LD_INT 16
44966: PUSH
44967: LD_INT 22
44969: PUSH
44970: LD_INT 23
44972: PUSH
44973: LD_INT 26
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: LIST
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 101
44989: PUSH
44990: LD_INT 102
44992: PUSH
44993: LD_INT 106
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: LIST
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: ST_TO_ADDR
45005: GO 47864
45007: LD_INT 2
45009: DOUBLE
45010: EQUAL
45011: IFTRUE 45015
45013: GO 45087
45015: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
45016: LD_ADDR_VAR 0 1
45020: PUSH
45021: LD_INT 2
45023: PUSH
45024: LD_INT 4
45026: PUSH
45027: LD_INT 11
45029: PUSH
45030: LD_INT 12
45032: PUSH
45033: LD_INT 15
45035: PUSH
45036: LD_INT 16
45038: PUSH
45039: LD_INT 22
45041: PUSH
45042: LD_INT 23
45044: PUSH
45045: LD_INT 26
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: LIST
45052: LIST
45053: LIST
45054: LIST
45055: LIST
45056: LIST
45057: LIST
45058: PUSH
45059: LD_INT 101
45061: PUSH
45062: LD_INT 102
45064: PUSH
45065: LD_INT 105
45067: PUSH
45068: LD_INT 106
45070: PUSH
45071: LD_INT 108
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: ST_TO_ADDR
45085: GO 47864
45087: LD_INT 3
45089: DOUBLE
45090: EQUAL
45091: IFTRUE 45095
45093: GO 45171
45095: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
45096: LD_ADDR_VAR 0 1
45100: PUSH
45101: LD_INT 2
45103: PUSH
45104: LD_INT 4
45106: PUSH
45107: LD_INT 5
45109: PUSH
45110: LD_INT 11
45112: PUSH
45113: LD_INT 12
45115: PUSH
45116: LD_INT 15
45118: PUSH
45119: LD_INT 16
45121: PUSH
45122: LD_INT 22
45124: PUSH
45125: LD_INT 26
45127: PUSH
45128: LD_INT 36
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: LIST
45135: LIST
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 101
45145: PUSH
45146: LD_INT 102
45148: PUSH
45149: LD_INT 105
45151: PUSH
45152: LD_INT 106
45154: PUSH
45155: LD_INT 108
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: ST_TO_ADDR
45169: GO 47864
45171: LD_INT 4
45173: DOUBLE
45174: EQUAL
45175: IFTRUE 45179
45177: GO 45263
45179: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
45180: LD_ADDR_VAR 0 1
45184: PUSH
45185: LD_INT 2
45187: PUSH
45188: LD_INT 4
45190: PUSH
45191: LD_INT 5
45193: PUSH
45194: LD_INT 8
45196: PUSH
45197: LD_INT 11
45199: PUSH
45200: LD_INT 12
45202: PUSH
45203: LD_INT 15
45205: PUSH
45206: LD_INT 16
45208: PUSH
45209: LD_INT 22
45211: PUSH
45212: LD_INT 23
45214: PUSH
45215: LD_INT 26
45217: PUSH
45218: LD_INT 36
45220: PUSH
45221: EMPTY
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: LIST
45230: LIST
45231: LIST
45232: LIST
45233: LIST
45234: PUSH
45235: LD_INT 101
45237: PUSH
45238: LD_INT 102
45240: PUSH
45241: LD_INT 105
45243: PUSH
45244: LD_INT 106
45246: PUSH
45247: LD_INT 108
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: ST_TO_ADDR
45261: GO 47864
45263: LD_INT 5
45265: DOUBLE
45266: EQUAL
45267: IFTRUE 45271
45269: GO 45371
45271: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
45272: LD_ADDR_VAR 0 1
45276: PUSH
45277: LD_INT 2
45279: PUSH
45280: LD_INT 4
45282: PUSH
45283: LD_INT 5
45285: PUSH
45286: LD_INT 6
45288: PUSH
45289: LD_INT 8
45291: PUSH
45292: LD_INT 11
45294: PUSH
45295: LD_INT 12
45297: PUSH
45298: LD_INT 15
45300: PUSH
45301: LD_INT 16
45303: PUSH
45304: LD_INT 22
45306: PUSH
45307: LD_INT 23
45309: PUSH
45310: LD_INT 25
45312: PUSH
45313: LD_INT 26
45315: PUSH
45316: LD_INT 36
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: PUSH
45335: LD_INT 101
45337: PUSH
45338: LD_INT 102
45340: PUSH
45341: LD_INT 105
45343: PUSH
45344: LD_INT 106
45346: PUSH
45347: LD_INT 108
45349: PUSH
45350: LD_INT 109
45352: PUSH
45353: LD_INT 112
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: PUSH
45365: EMPTY
45366: LIST
45367: LIST
45368: ST_TO_ADDR
45369: GO 47864
45371: LD_INT 6
45373: DOUBLE
45374: EQUAL
45375: IFTRUE 45379
45377: GO 45499
45379: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
45380: LD_ADDR_VAR 0 1
45384: PUSH
45385: LD_INT 2
45387: PUSH
45388: LD_INT 4
45390: PUSH
45391: LD_INT 5
45393: PUSH
45394: LD_INT 6
45396: PUSH
45397: LD_INT 8
45399: PUSH
45400: LD_INT 11
45402: PUSH
45403: LD_INT 12
45405: PUSH
45406: LD_INT 15
45408: PUSH
45409: LD_INT 16
45411: PUSH
45412: LD_INT 20
45414: PUSH
45415: LD_INT 21
45417: PUSH
45418: LD_INT 22
45420: PUSH
45421: LD_INT 23
45423: PUSH
45424: LD_INT 25
45426: PUSH
45427: LD_INT 26
45429: PUSH
45430: LD_INT 30
45432: PUSH
45433: LD_INT 31
45435: PUSH
45436: LD_INT 32
45438: PUSH
45439: LD_INT 36
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: LIST
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: PUSH
45463: LD_INT 101
45465: PUSH
45466: LD_INT 102
45468: PUSH
45469: LD_INT 105
45471: PUSH
45472: LD_INT 106
45474: PUSH
45475: LD_INT 108
45477: PUSH
45478: LD_INT 109
45480: PUSH
45481: LD_INT 112
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: ST_TO_ADDR
45497: GO 47864
45499: LD_INT 7
45501: DOUBLE
45502: EQUAL
45503: IFTRUE 45507
45505: GO 45607
45507: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
45508: LD_ADDR_VAR 0 1
45512: PUSH
45513: LD_INT 2
45515: PUSH
45516: LD_INT 4
45518: PUSH
45519: LD_INT 5
45521: PUSH
45522: LD_INT 7
45524: PUSH
45525: LD_INT 11
45527: PUSH
45528: LD_INT 12
45530: PUSH
45531: LD_INT 15
45533: PUSH
45534: LD_INT 16
45536: PUSH
45537: LD_INT 20
45539: PUSH
45540: LD_INT 21
45542: PUSH
45543: LD_INT 22
45545: PUSH
45546: LD_INT 23
45548: PUSH
45549: LD_INT 25
45551: PUSH
45552: LD_INT 26
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 101
45573: PUSH
45574: LD_INT 102
45576: PUSH
45577: LD_INT 103
45579: PUSH
45580: LD_INT 105
45582: PUSH
45583: LD_INT 106
45585: PUSH
45586: LD_INT 108
45588: PUSH
45589: LD_INT 112
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: LIST
45596: LIST
45597: LIST
45598: LIST
45599: LIST
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: ST_TO_ADDR
45605: GO 47864
45607: LD_INT 8
45609: DOUBLE
45610: EQUAL
45611: IFTRUE 45615
45613: GO 45743
45615: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
45616: LD_ADDR_VAR 0 1
45620: PUSH
45621: LD_INT 2
45623: PUSH
45624: LD_INT 4
45626: PUSH
45627: LD_INT 5
45629: PUSH
45630: LD_INT 6
45632: PUSH
45633: LD_INT 7
45635: PUSH
45636: LD_INT 8
45638: PUSH
45639: LD_INT 11
45641: PUSH
45642: LD_INT 12
45644: PUSH
45645: LD_INT 15
45647: PUSH
45648: LD_INT 16
45650: PUSH
45651: LD_INT 20
45653: PUSH
45654: LD_INT 21
45656: PUSH
45657: LD_INT 22
45659: PUSH
45660: LD_INT 23
45662: PUSH
45663: LD_INT 25
45665: PUSH
45666: LD_INT 26
45668: PUSH
45669: LD_INT 30
45671: PUSH
45672: LD_INT 31
45674: PUSH
45675: LD_INT 32
45677: PUSH
45678: LD_INT 36
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 101
45705: PUSH
45706: LD_INT 102
45708: PUSH
45709: LD_INT 103
45711: PUSH
45712: LD_INT 105
45714: PUSH
45715: LD_INT 106
45717: PUSH
45718: LD_INT 108
45720: PUSH
45721: LD_INT 109
45723: PUSH
45724: LD_INT 112
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: LIST
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: ST_TO_ADDR
45741: GO 47864
45743: LD_INT 9
45745: DOUBLE
45746: EQUAL
45747: IFTRUE 45751
45749: GO 45887
45751: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45752: LD_ADDR_VAR 0 1
45756: PUSH
45757: LD_INT 2
45759: PUSH
45760: LD_INT 4
45762: PUSH
45763: LD_INT 5
45765: PUSH
45766: LD_INT 6
45768: PUSH
45769: LD_INT 7
45771: PUSH
45772: LD_INT 8
45774: PUSH
45775: LD_INT 11
45777: PUSH
45778: LD_INT 12
45780: PUSH
45781: LD_INT 15
45783: PUSH
45784: LD_INT 16
45786: PUSH
45787: LD_INT 20
45789: PUSH
45790: LD_INT 21
45792: PUSH
45793: LD_INT 22
45795: PUSH
45796: LD_INT 23
45798: PUSH
45799: LD_INT 25
45801: PUSH
45802: LD_INT 26
45804: PUSH
45805: LD_INT 28
45807: PUSH
45808: LD_INT 30
45810: PUSH
45811: LD_INT 31
45813: PUSH
45814: LD_INT 32
45816: PUSH
45817: LD_INT 36
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: LIST
45841: LIST
45842: PUSH
45843: LD_INT 101
45845: PUSH
45846: LD_INT 102
45848: PUSH
45849: LD_INT 103
45851: PUSH
45852: LD_INT 105
45854: PUSH
45855: LD_INT 106
45857: PUSH
45858: LD_INT 108
45860: PUSH
45861: LD_INT 109
45863: PUSH
45864: LD_INT 112
45866: PUSH
45867: LD_INT 114
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: PUSH
45881: EMPTY
45882: LIST
45883: LIST
45884: ST_TO_ADDR
45885: GO 47864
45887: LD_INT 10
45889: DOUBLE
45890: EQUAL
45891: IFTRUE 45895
45893: GO 46079
45895: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45896: LD_ADDR_VAR 0 1
45900: PUSH
45901: LD_INT 2
45903: PUSH
45904: LD_INT 4
45906: PUSH
45907: LD_INT 5
45909: PUSH
45910: LD_INT 6
45912: PUSH
45913: LD_INT 7
45915: PUSH
45916: LD_INT 8
45918: PUSH
45919: LD_INT 9
45921: PUSH
45922: LD_INT 10
45924: PUSH
45925: LD_INT 11
45927: PUSH
45928: LD_INT 12
45930: PUSH
45931: LD_INT 13
45933: PUSH
45934: LD_INT 14
45936: PUSH
45937: LD_INT 15
45939: PUSH
45940: LD_INT 16
45942: PUSH
45943: LD_INT 17
45945: PUSH
45946: LD_INT 18
45948: PUSH
45949: LD_INT 19
45951: PUSH
45952: LD_INT 20
45954: PUSH
45955: LD_INT 21
45957: PUSH
45958: LD_INT 22
45960: PUSH
45961: LD_INT 23
45963: PUSH
45964: LD_INT 24
45966: PUSH
45967: LD_INT 25
45969: PUSH
45970: LD_INT 26
45972: PUSH
45973: LD_INT 28
45975: PUSH
45976: LD_INT 30
45978: PUSH
45979: LD_INT 31
45981: PUSH
45982: LD_INT 32
45984: PUSH
45985: LD_INT 36
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 101
46021: PUSH
46022: LD_INT 102
46024: PUSH
46025: LD_INT 103
46027: PUSH
46028: LD_INT 104
46030: PUSH
46031: LD_INT 105
46033: PUSH
46034: LD_INT 106
46036: PUSH
46037: LD_INT 107
46039: PUSH
46040: LD_INT 108
46042: PUSH
46043: LD_INT 109
46045: PUSH
46046: LD_INT 110
46048: PUSH
46049: LD_INT 111
46051: PUSH
46052: LD_INT 112
46054: PUSH
46055: LD_INT 114
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: LIST
46062: LIST
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: LIST
46068: LIST
46069: LIST
46070: LIST
46071: LIST
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: ST_TO_ADDR
46077: GO 47864
46079: LD_INT 11
46081: DOUBLE
46082: EQUAL
46083: IFTRUE 46087
46085: GO 46279
46087: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
46088: LD_ADDR_VAR 0 1
46092: PUSH
46093: LD_INT 2
46095: PUSH
46096: LD_INT 3
46098: PUSH
46099: LD_INT 4
46101: PUSH
46102: LD_INT 5
46104: PUSH
46105: LD_INT 6
46107: PUSH
46108: LD_INT 7
46110: PUSH
46111: LD_INT 8
46113: PUSH
46114: LD_INT 9
46116: PUSH
46117: LD_INT 10
46119: PUSH
46120: LD_INT 11
46122: PUSH
46123: LD_INT 12
46125: PUSH
46126: LD_INT 13
46128: PUSH
46129: LD_INT 14
46131: PUSH
46132: LD_INT 15
46134: PUSH
46135: LD_INT 16
46137: PUSH
46138: LD_INT 17
46140: PUSH
46141: LD_INT 18
46143: PUSH
46144: LD_INT 19
46146: PUSH
46147: LD_INT 20
46149: PUSH
46150: LD_INT 21
46152: PUSH
46153: LD_INT 22
46155: PUSH
46156: LD_INT 23
46158: PUSH
46159: LD_INT 24
46161: PUSH
46162: LD_INT 25
46164: PUSH
46165: LD_INT 26
46167: PUSH
46168: LD_INT 28
46170: PUSH
46171: LD_INT 30
46173: PUSH
46174: LD_INT 31
46176: PUSH
46177: LD_INT 32
46179: PUSH
46180: LD_INT 34
46182: PUSH
46183: LD_INT 36
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: LIST
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: PUSH
46219: LD_INT 101
46221: PUSH
46222: LD_INT 102
46224: PUSH
46225: LD_INT 103
46227: PUSH
46228: LD_INT 104
46230: PUSH
46231: LD_INT 105
46233: PUSH
46234: LD_INT 106
46236: PUSH
46237: LD_INT 107
46239: PUSH
46240: LD_INT 108
46242: PUSH
46243: LD_INT 109
46245: PUSH
46246: LD_INT 110
46248: PUSH
46249: LD_INT 111
46251: PUSH
46252: LD_INT 112
46254: PUSH
46255: LD_INT 114
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: LIST
46262: LIST
46263: LIST
46264: LIST
46265: LIST
46266: LIST
46267: LIST
46268: LIST
46269: LIST
46270: LIST
46271: LIST
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: ST_TO_ADDR
46277: GO 47864
46279: LD_INT 12
46281: DOUBLE
46282: EQUAL
46283: IFTRUE 46287
46285: GO 46495
46287: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
46288: LD_ADDR_VAR 0 1
46292: PUSH
46293: LD_INT 1
46295: PUSH
46296: LD_INT 2
46298: PUSH
46299: LD_INT 3
46301: PUSH
46302: LD_INT 4
46304: PUSH
46305: LD_INT 5
46307: PUSH
46308: LD_INT 6
46310: PUSH
46311: LD_INT 7
46313: PUSH
46314: LD_INT 8
46316: PUSH
46317: LD_INT 9
46319: PUSH
46320: LD_INT 10
46322: PUSH
46323: LD_INT 11
46325: PUSH
46326: LD_INT 12
46328: PUSH
46329: LD_INT 13
46331: PUSH
46332: LD_INT 14
46334: PUSH
46335: LD_INT 15
46337: PUSH
46338: LD_INT 16
46340: PUSH
46341: LD_INT 17
46343: PUSH
46344: LD_INT 18
46346: PUSH
46347: LD_INT 19
46349: PUSH
46350: LD_INT 20
46352: PUSH
46353: LD_INT 21
46355: PUSH
46356: LD_INT 22
46358: PUSH
46359: LD_INT 23
46361: PUSH
46362: LD_INT 24
46364: PUSH
46365: LD_INT 25
46367: PUSH
46368: LD_INT 26
46370: PUSH
46371: LD_INT 27
46373: PUSH
46374: LD_INT 28
46376: PUSH
46377: LD_INT 30
46379: PUSH
46380: LD_INT 31
46382: PUSH
46383: LD_INT 32
46385: PUSH
46386: LD_INT 33
46388: PUSH
46389: LD_INT 34
46391: PUSH
46392: LD_INT 36
46394: PUSH
46395: EMPTY
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 101
46433: PUSH
46434: LD_INT 102
46436: PUSH
46437: LD_INT 103
46439: PUSH
46440: LD_INT 104
46442: PUSH
46443: LD_INT 105
46445: PUSH
46446: LD_INT 106
46448: PUSH
46449: LD_INT 107
46451: PUSH
46452: LD_INT 108
46454: PUSH
46455: LD_INT 109
46457: PUSH
46458: LD_INT 110
46460: PUSH
46461: LD_INT 111
46463: PUSH
46464: LD_INT 112
46466: PUSH
46467: LD_INT 113
46469: PUSH
46470: LD_INT 114
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: LIST
46477: LIST
46478: LIST
46479: LIST
46480: LIST
46481: LIST
46482: LIST
46483: LIST
46484: LIST
46485: LIST
46486: LIST
46487: LIST
46488: PUSH
46489: EMPTY
46490: LIST
46491: LIST
46492: ST_TO_ADDR
46493: GO 47864
46495: LD_INT 13
46497: DOUBLE
46498: EQUAL
46499: IFTRUE 46503
46501: GO 46699
46503: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
46504: LD_ADDR_VAR 0 1
46508: PUSH
46509: LD_INT 1
46511: PUSH
46512: LD_INT 2
46514: PUSH
46515: LD_INT 3
46517: PUSH
46518: LD_INT 4
46520: PUSH
46521: LD_INT 5
46523: PUSH
46524: LD_INT 8
46526: PUSH
46527: LD_INT 9
46529: PUSH
46530: LD_INT 10
46532: PUSH
46533: LD_INT 11
46535: PUSH
46536: LD_INT 12
46538: PUSH
46539: LD_INT 14
46541: PUSH
46542: LD_INT 15
46544: PUSH
46545: LD_INT 16
46547: PUSH
46548: LD_INT 17
46550: PUSH
46551: LD_INT 18
46553: PUSH
46554: LD_INT 19
46556: PUSH
46557: LD_INT 20
46559: PUSH
46560: LD_INT 21
46562: PUSH
46563: LD_INT 22
46565: PUSH
46566: LD_INT 23
46568: PUSH
46569: LD_INT 24
46571: PUSH
46572: LD_INT 25
46574: PUSH
46575: LD_INT 26
46577: PUSH
46578: LD_INT 27
46580: PUSH
46581: LD_INT 28
46583: PUSH
46584: LD_INT 30
46586: PUSH
46587: LD_INT 31
46589: PUSH
46590: LD_INT 32
46592: PUSH
46593: LD_INT 33
46595: PUSH
46596: LD_INT 34
46598: PUSH
46599: LD_INT 36
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: PUSH
46635: LD_INT 101
46637: PUSH
46638: LD_INT 102
46640: PUSH
46641: LD_INT 103
46643: PUSH
46644: LD_INT 104
46646: PUSH
46647: LD_INT 105
46649: PUSH
46650: LD_INT 106
46652: PUSH
46653: LD_INT 107
46655: PUSH
46656: LD_INT 108
46658: PUSH
46659: LD_INT 109
46661: PUSH
46662: LD_INT 110
46664: PUSH
46665: LD_INT 111
46667: PUSH
46668: LD_INT 112
46670: PUSH
46671: LD_INT 113
46673: PUSH
46674: LD_INT 114
46676: PUSH
46677: EMPTY
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: ST_TO_ADDR
46697: GO 47864
46699: LD_INT 14
46701: DOUBLE
46702: EQUAL
46703: IFTRUE 46707
46705: GO 46919
46707: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46708: LD_ADDR_VAR 0 1
46712: PUSH
46713: LD_INT 1
46715: PUSH
46716: LD_INT 2
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: LD_INT 4
46724: PUSH
46725: LD_INT 5
46727: PUSH
46728: LD_INT 6
46730: PUSH
46731: LD_INT 7
46733: PUSH
46734: LD_INT 8
46736: PUSH
46737: LD_INT 9
46739: PUSH
46740: LD_INT 10
46742: PUSH
46743: LD_INT 11
46745: PUSH
46746: LD_INT 12
46748: PUSH
46749: LD_INT 13
46751: PUSH
46752: LD_INT 14
46754: PUSH
46755: LD_INT 15
46757: PUSH
46758: LD_INT 16
46760: PUSH
46761: LD_INT 17
46763: PUSH
46764: LD_INT 18
46766: PUSH
46767: LD_INT 19
46769: PUSH
46770: LD_INT 20
46772: PUSH
46773: LD_INT 21
46775: PUSH
46776: LD_INT 22
46778: PUSH
46779: LD_INT 23
46781: PUSH
46782: LD_INT 24
46784: PUSH
46785: LD_INT 25
46787: PUSH
46788: LD_INT 26
46790: PUSH
46791: LD_INT 27
46793: PUSH
46794: LD_INT 28
46796: PUSH
46797: LD_INT 29
46799: PUSH
46800: LD_INT 30
46802: PUSH
46803: LD_INT 31
46805: PUSH
46806: LD_INT 32
46808: PUSH
46809: LD_INT 33
46811: PUSH
46812: LD_INT 34
46814: PUSH
46815: LD_INT 36
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: LIST
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: PUSH
46855: LD_INT 101
46857: PUSH
46858: LD_INT 102
46860: PUSH
46861: LD_INT 103
46863: PUSH
46864: LD_INT 104
46866: PUSH
46867: LD_INT 105
46869: PUSH
46870: LD_INT 106
46872: PUSH
46873: LD_INT 107
46875: PUSH
46876: LD_INT 108
46878: PUSH
46879: LD_INT 109
46881: PUSH
46882: LD_INT 110
46884: PUSH
46885: LD_INT 111
46887: PUSH
46888: LD_INT 112
46890: PUSH
46891: LD_INT 113
46893: PUSH
46894: LD_INT 114
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: PUSH
46913: EMPTY
46914: LIST
46915: LIST
46916: ST_TO_ADDR
46917: GO 47864
46919: LD_INT 15
46921: DOUBLE
46922: EQUAL
46923: IFTRUE 46927
46925: GO 47139
46927: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46928: LD_ADDR_VAR 0 1
46932: PUSH
46933: LD_INT 1
46935: PUSH
46936: LD_INT 2
46938: PUSH
46939: LD_INT 3
46941: PUSH
46942: LD_INT 4
46944: PUSH
46945: LD_INT 5
46947: PUSH
46948: LD_INT 6
46950: PUSH
46951: LD_INT 7
46953: PUSH
46954: LD_INT 8
46956: PUSH
46957: LD_INT 9
46959: PUSH
46960: LD_INT 10
46962: PUSH
46963: LD_INT 11
46965: PUSH
46966: LD_INT 12
46968: PUSH
46969: LD_INT 13
46971: PUSH
46972: LD_INT 14
46974: PUSH
46975: LD_INT 15
46977: PUSH
46978: LD_INT 16
46980: PUSH
46981: LD_INT 17
46983: PUSH
46984: LD_INT 18
46986: PUSH
46987: LD_INT 19
46989: PUSH
46990: LD_INT 20
46992: PUSH
46993: LD_INT 21
46995: PUSH
46996: LD_INT 22
46998: PUSH
46999: LD_INT 23
47001: PUSH
47002: LD_INT 24
47004: PUSH
47005: LD_INT 25
47007: PUSH
47008: LD_INT 26
47010: PUSH
47011: LD_INT 27
47013: PUSH
47014: LD_INT 28
47016: PUSH
47017: LD_INT 29
47019: PUSH
47020: LD_INT 30
47022: PUSH
47023: LD_INT 31
47025: PUSH
47026: LD_INT 32
47028: PUSH
47029: LD_INT 33
47031: PUSH
47032: LD_INT 34
47034: PUSH
47035: LD_INT 36
47037: PUSH
47038: EMPTY
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: PUSH
47075: LD_INT 101
47077: PUSH
47078: LD_INT 102
47080: PUSH
47081: LD_INT 103
47083: PUSH
47084: LD_INT 104
47086: PUSH
47087: LD_INT 105
47089: PUSH
47090: LD_INT 106
47092: PUSH
47093: LD_INT 107
47095: PUSH
47096: LD_INT 108
47098: PUSH
47099: LD_INT 109
47101: PUSH
47102: LD_INT 110
47104: PUSH
47105: LD_INT 111
47107: PUSH
47108: LD_INT 112
47110: PUSH
47111: LD_INT 113
47113: PUSH
47114: LD_INT 114
47116: PUSH
47117: EMPTY
47118: LIST
47119: LIST
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: LIST
47126: LIST
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: LIST
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: ST_TO_ADDR
47137: GO 47864
47139: LD_INT 16
47141: DOUBLE
47142: EQUAL
47143: IFTRUE 47147
47145: GO 47271
47147: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
47148: LD_ADDR_VAR 0 1
47152: PUSH
47153: LD_INT 2
47155: PUSH
47156: LD_INT 4
47158: PUSH
47159: LD_INT 5
47161: PUSH
47162: LD_INT 7
47164: PUSH
47165: LD_INT 11
47167: PUSH
47168: LD_INT 12
47170: PUSH
47171: LD_INT 15
47173: PUSH
47174: LD_INT 16
47176: PUSH
47177: LD_INT 20
47179: PUSH
47180: LD_INT 21
47182: PUSH
47183: LD_INT 22
47185: PUSH
47186: LD_INT 23
47188: PUSH
47189: LD_INT 25
47191: PUSH
47192: LD_INT 26
47194: PUSH
47195: LD_INT 30
47197: PUSH
47198: LD_INT 31
47200: PUSH
47201: LD_INT 32
47203: PUSH
47204: LD_INT 33
47206: PUSH
47207: LD_INT 34
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: PUSH
47231: LD_INT 101
47233: PUSH
47234: LD_INT 102
47236: PUSH
47237: LD_INT 103
47239: PUSH
47240: LD_INT 106
47242: PUSH
47243: LD_INT 108
47245: PUSH
47246: LD_INT 112
47248: PUSH
47249: LD_INT 113
47251: PUSH
47252: LD_INT 114
47254: PUSH
47255: EMPTY
47256: LIST
47257: LIST
47258: LIST
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: ST_TO_ADDR
47269: GO 47864
47271: LD_INT 17
47273: DOUBLE
47274: EQUAL
47275: IFTRUE 47279
47277: GO 47491
47279: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
47280: LD_ADDR_VAR 0 1
47284: PUSH
47285: LD_INT 1
47287: PUSH
47288: LD_INT 2
47290: PUSH
47291: LD_INT 3
47293: PUSH
47294: LD_INT 4
47296: PUSH
47297: LD_INT 5
47299: PUSH
47300: LD_INT 6
47302: PUSH
47303: LD_INT 7
47305: PUSH
47306: LD_INT 8
47308: PUSH
47309: LD_INT 9
47311: PUSH
47312: LD_INT 10
47314: PUSH
47315: LD_INT 11
47317: PUSH
47318: LD_INT 12
47320: PUSH
47321: LD_INT 13
47323: PUSH
47324: LD_INT 14
47326: PUSH
47327: LD_INT 15
47329: PUSH
47330: LD_INT 16
47332: PUSH
47333: LD_INT 17
47335: PUSH
47336: LD_INT 18
47338: PUSH
47339: LD_INT 19
47341: PUSH
47342: LD_INT 20
47344: PUSH
47345: LD_INT 21
47347: PUSH
47348: LD_INT 22
47350: PUSH
47351: LD_INT 23
47353: PUSH
47354: LD_INT 24
47356: PUSH
47357: LD_INT 25
47359: PUSH
47360: LD_INT 26
47362: PUSH
47363: LD_INT 27
47365: PUSH
47366: LD_INT 28
47368: PUSH
47369: LD_INT 29
47371: PUSH
47372: LD_INT 30
47374: PUSH
47375: LD_INT 31
47377: PUSH
47378: LD_INT 32
47380: PUSH
47381: LD_INT 33
47383: PUSH
47384: LD_INT 34
47386: PUSH
47387: LD_INT 36
47389: PUSH
47390: EMPTY
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: PUSH
47427: LD_INT 101
47429: PUSH
47430: LD_INT 102
47432: PUSH
47433: LD_INT 103
47435: PUSH
47436: LD_INT 104
47438: PUSH
47439: LD_INT 105
47441: PUSH
47442: LD_INT 106
47444: PUSH
47445: LD_INT 107
47447: PUSH
47448: LD_INT 108
47450: PUSH
47451: LD_INT 109
47453: PUSH
47454: LD_INT 110
47456: PUSH
47457: LD_INT 111
47459: PUSH
47460: LD_INT 112
47462: PUSH
47463: LD_INT 113
47465: PUSH
47466: LD_INT 114
47468: PUSH
47469: EMPTY
47470: LIST
47471: LIST
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: LIST
47479: LIST
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: ST_TO_ADDR
47489: GO 47864
47491: LD_INT 18
47493: DOUBLE
47494: EQUAL
47495: IFTRUE 47499
47497: GO 47635
47499: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
47500: LD_ADDR_VAR 0 1
47504: PUSH
47505: LD_INT 2
47507: PUSH
47508: LD_INT 4
47510: PUSH
47511: LD_INT 5
47513: PUSH
47514: LD_INT 7
47516: PUSH
47517: LD_INT 11
47519: PUSH
47520: LD_INT 12
47522: PUSH
47523: LD_INT 15
47525: PUSH
47526: LD_INT 16
47528: PUSH
47529: LD_INT 20
47531: PUSH
47532: LD_INT 21
47534: PUSH
47535: LD_INT 22
47537: PUSH
47538: LD_INT 23
47540: PUSH
47541: LD_INT 25
47543: PUSH
47544: LD_INT 26
47546: PUSH
47547: LD_INT 30
47549: PUSH
47550: LD_INT 31
47552: PUSH
47553: LD_INT 32
47555: PUSH
47556: LD_INT 33
47558: PUSH
47559: LD_INT 34
47561: PUSH
47562: LD_INT 35
47564: PUSH
47565: LD_INT 36
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: LIST
47577: LIST
47578: LIST
47579: LIST
47580: LIST
47581: LIST
47582: LIST
47583: LIST
47584: LIST
47585: LIST
47586: LIST
47587: LIST
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 101
47593: PUSH
47594: LD_INT 102
47596: PUSH
47597: LD_INT 103
47599: PUSH
47600: LD_INT 106
47602: PUSH
47603: LD_INT 108
47605: PUSH
47606: LD_INT 112
47608: PUSH
47609: LD_INT 113
47611: PUSH
47612: LD_INT 114
47614: PUSH
47615: LD_INT 115
47617: PUSH
47618: EMPTY
47619: LIST
47620: LIST
47621: LIST
47622: LIST
47623: LIST
47624: LIST
47625: LIST
47626: LIST
47627: LIST
47628: PUSH
47629: EMPTY
47630: LIST
47631: LIST
47632: ST_TO_ADDR
47633: GO 47864
47635: LD_INT 19
47637: DOUBLE
47638: EQUAL
47639: IFTRUE 47643
47641: GO 47863
47643: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
47644: LD_ADDR_VAR 0 1
47648: PUSH
47649: LD_INT 1
47651: PUSH
47652: LD_INT 2
47654: PUSH
47655: LD_INT 3
47657: PUSH
47658: LD_INT 4
47660: PUSH
47661: LD_INT 5
47663: PUSH
47664: LD_INT 6
47666: PUSH
47667: LD_INT 7
47669: PUSH
47670: LD_INT 8
47672: PUSH
47673: LD_INT 9
47675: PUSH
47676: LD_INT 10
47678: PUSH
47679: LD_INT 11
47681: PUSH
47682: LD_INT 12
47684: PUSH
47685: LD_INT 13
47687: PUSH
47688: LD_INT 14
47690: PUSH
47691: LD_INT 15
47693: PUSH
47694: LD_INT 16
47696: PUSH
47697: LD_INT 17
47699: PUSH
47700: LD_INT 18
47702: PUSH
47703: LD_INT 19
47705: PUSH
47706: LD_INT 20
47708: PUSH
47709: LD_INT 21
47711: PUSH
47712: LD_INT 22
47714: PUSH
47715: LD_INT 23
47717: PUSH
47718: LD_INT 24
47720: PUSH
47721: LD_INT 25
47723: PUSH
47724: LD_INT 26
47726: PUSH
47727: LD_INT 27
47729: PUSH
47730: LD_INT 28
47732: PUSH
47733: LD_INT 29
47735: PUSH
47736: LD_INT 30
47738: PUSH
47739: LD_INT 31
47741: PUSH
47742: LD_INT 32
47744: PUSH
47745: LD_INT 33
47747: PUSH
47748: LD_INT 34
47750: PUSH
47751: LD_INT 35
47753: PUSH
47754: LD_INT 36
47756: PUSH
47757: EMPTY
47758: LIST
47759: LIST
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: LIST
47767: LIST
47768: LIST
47769: LIST
47770: LIST
47771: LIST
47772: LIST
47773: LIST
47774: LIST
47775: LIST
47776: LIST
47777: LIST
47778: LIST
47779: LIST
47780: LIST
47781: LIST
47782: LIST
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: PUSH
47795: LD_INT 101
47797: PUSH
47798: LD_INT 102
47800: PUSH
47801: LD_INT 103
47803: PUSH
47804: LD_INT 104
47806: PUSH
47807: LD_INT 105
47809: PUSH
47810: LD_INT 106
47812: PUSH
47813: LD_INT 107
47815: PUSH
47816: LD_INT 108
47818: PUSH
47819: LD_INT 109
47821: PUSH
47822: LD_INT 110
47824: PUSH
47825: LD_INT 111
47827: PUSH
47828: LD_INT 112
47830: PUSH
47831: LD_INT 113
47833: PUSH
47834: LD_INT 114
47836: PUSH
47837: LD_INT 115
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: ST_TO_ADDR
47861: GO 47864
47863: POP
// end else
47864: GO 48083
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47866: LD_ADDR_VAR 0 1
47870: PUSH
47871: LD_INT 1
47873: PUSH
47874: LD_INT 2
47876: PUSH
47877: LD_INT 3
47879: PUSH
47880: LD_INT 4
47882: PUSH
47883: LD_INT 5
47885: PUSH
47886: LD_INT 6
47888: PUSH
47889: LD_INT 7
47891: PUSH
47892: LD_INT 8
47894: PUSH
47895: LD_INT 9
47897: PUSH
47898: LD_INT 10
47900: PUSH
47901: LD_INT 11
47903: PUSH
47904: LD_INT 12
47906: PUSH
47907: LD_INT 13
47909: PUSH
47910: LD_INT 14
47912: PUSH
47913: LD_INT 15
47915: PUSH
47916: LD_INT 16
47918: PUSH
47919: LD_INT 17
47921: PUSH
47922: LD_INT 18
47924: PUSH
47925: LD_INT 19
47927: PUSH
47928: LD_INT 20
47930: PUSH
47931: LD_INT 21
47933: PUSH
47934: LD_INT 22
47936: PUSH
47937: LD_INT 23
47939: PUSH
47940: LD_INT 24
47942: PUSH
47943: LD_INT 25
47945: PUSH
47946: LD_INT 26
47948: PUSH
47949: LD_INT 27
47951: PUSH
47952: LD_INT 28
47954: PUSH
47955: LD_INT 29
47957: PUSH
47958: LD_INT 30
47960: PUSH
47961: LD_INT 31
47963: PUSH
47964: LD_INT 32
47966: PUSH
47967: LD_INT 33
47969: PUSH
47970: LD_INT 34
47972: PUSH
47973: LD_INT 35
47975: PUSH
47976: LD_INT 36
47978: PUSH
47979: EMPTY
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: LIST
47996: LIST
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: LIST
48011: LIST
48012: LIST
48013: LIST
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 101
48019: PUSH
48020: LD_INT 102
48022: PUSH
48023: LD_INT 103
48025: PUSH
48026: LD_INT 104
48028: PUSH
48029: LD_INT 105
48031: PUSH
48032: LD_INT 106
48034: PUSH
48035: LD_INT 107
48037: PUSH
48038: LD_INT 108
48040: PUSH
48041: LD_INT 109
48043: PUSH
48044: LD_INT 110
48046: PUSH
48047: LD_INT 111
48049: PUSH
48050: LD_INT 112
48052: PUSH
48053: LD_INT 113
48055: PUSH
48056: LD_INT 114
48058: PUSH
48059: LD_INT 115
48061: PUSH
48062: EMPTY
48063: LIST
48064: LIST
48065: LIST
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: LIST
48072: LIST
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: ST_TO_ADDR
// if result then
48083: LD_VAR 0 1
48087: IFFALSE 48376
// begin normal :=  ;
48089: LD_ADDR_VAR 0 3
48093: PUSH
48094: LD_STRING 
48096: ST_TO_ADDR
// hardcore :=  ;
48097: LD_ADDR_VAR 0 4
48101: PUSH
48102: LD_STRING 
48104: ST_TO_ADDR
// for i = 1 to normalCounter do
48105: LD_ADDR_VAR 0 5
48109: PUSH
48110: DOUBLE
48111: LD_INT 1
48113: DEC
48114: ST_TO_ADDR
48115: LD_EXP 94
48119: PUSH
48120: FOR_TO
48121: IFFALSE 48222
// begin tmp := 0 ;
48123: LD_ADDR_VAR 0 2
48127: PUSH
48128: LD_STRING 0
48130: ST_TO_ADDR
// if result [ 1 ] then
48131: LD_VAR 0 1
48135: PUSH
48136: LD_INT 1
48138: ARRAY
48139: IFFALSE 48204
// if result [ 1 ] [ 1 ] = i then
48141: LD_VAR 0 1
48145: PUSH
48146: LD_INT 1
48148: ARRAY
48149: PUSH
48150: LD_INT 1
48152: ARRAY
48153: PUSH
48154: LD_VAR 0 5
48158: EQUAL
48159: IFFALSE 48204
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48161: LD_ADDR_VAR 0 1
48165: PUSH
48166: LD_VAR 0 1
48170: PPUSH
48171: LD_INT 1
48173: PPUSH
48174: LD_VAR 0 1
48178: PUSH
48179: LD_INT 1
48181: ARRAY
48182: PPUSH
48183: LD_INT 1
48185: PPUSH
48186: CALL_OW 3
48190: PPUSH
48191: CALL_OW 1
48195: ST_TO_ADDR
// tmp := 1 ;
48196: LD_ADDR_VAR 0 2
48200: PUSH
48201: LD_STRING 1
48203: ST_TO_ADDR
// end ; normal := normal & tmp ;
48204: LD_ADDR_VAR 0 3
48208: PUSH
48209: LD_VAR 0 3
48213: PUSH
48214: LD_VAR 0 2
48218: STR
48219: ST_TO_ADDR
// end ;
48220: GO 48120
48222: POP
48223: POP
// for i = 1 to hardcoreCounter do
48224: LD_ADDR_VAR 0 5
48228: PUSH
48229: DOUBLE
48230: LD_INT 1
48232: DEC
48233: ST_TO_ADDR
48234: LD_EXP 95
48238: PUSH
48239: FOR_TO
48240: IFFALSE 48345
// begin tmp := 0 ;
48242: LD_ADDR_VAR 0 2
48246: PUSH
48247: LD_STRING 0
48249: ST_TO_ADDR
// if result [ 2 ] then
48250: LD_VAR 0 1
48254: PUSH
48255: LD_INT 2
48257: ARRAY
48258: IFFALSE 48327
// if result [ 2 ] [ 1 ] = 100 + i then
48260: LD_VAR 0 1
48264: PUSH
48265: LD_INT 2
48267: ARRAY
48268: PUSH
48269: LD_INT 1
48271: ARRAY
48272: PUSH
48273: LD_INT 100
48275: PUSH
48276: LD_VAR 0 5
48280: PLUS
48281: EQUAL
48282: IFFALSE 48327
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48284: LD_ADDR_VAR 0 1
48288: PUSH
48289: LD_VAR 0 1
48293: PPUSH
48294: LD_INT 2
48296: PPUSH
48297: LD_VAR 0 1
48301: PUSH
48302: LD_INT 2
48304: ARRAY
48305: PPUSH
48306: LD_INT 1
48308: PPUSH
48309: CALL_OW 3
48313: PPUSH
48314: CALL_OW 1
48318: ST_TO_ADDR
// tmp := 1 ;
48319: LD_ADDR_VAR 0 2
48323: PUSH
48324: LD_STRING 1
48326: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48327: LD_ADDR_VAR 0 4
48331: PUSH
48332: LD_VAR 0 4
48336: PUSH
48337: LD_VAR 0 2
48341: STR
48342: ST_TO_ADDR
// end ;
48343: GO 48239
48345: POP
48346: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48347: LD_STRING getStreamItemsFromMission("
48349: PUSH
48350: LD_VAR 0 3
48354: STR
48355: PUSH
48356: LD_STRING ","
48358: STR
48359: PUSH
48360: LD_VAR 0 4
48364: STR
48365: PUSH
48366: LD_STRING ")
48368: STR
48369: PPUSH
48370: CALL_OW 559
// end else
48374: GO 48383
// ToLua ( getStreamItemsFromMission("","") ) ;
48376: LD_STRING getStreamItemsFromMission("","")
48378: PPUSH
48379: CALL_OW 559
// end ;
48383: LD_VAR 0 1
48387: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48388: LD_EXP 93
48392: PUSH
48393: LD_EXP 98
48397: AND
48398: IFFALSE 48522
48400: GO 48402
48402: DISABLE
48403: LD_INT 0
48405: PPUSH
48406: PPUSH
// begin enable ;
48407: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48408: LD_ADDR_VAR 0 2
48412: PUSH
48413: LD_INT 22
48415: PUSH
48416: LD_OWVAR 2
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PUSH
48425: LD_INT 2
48427: PUSH
48428: LD_INT 34
48430: PUSH
48431: LD_INT 7
48433: PUSH
48434: EMPTY
48435: LIST
48436: LIST
48437: PUSH
48438: LD_INT 34
48440: PUSH
48441: LD_INT 45
48443: PUSH
48444: EMPTY
48445: LIST
48446: LIST
48447: PUSH
48448: LD_INT 34
48450: PUSH
48451: LD_INT 28
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PUSH
48458: LD_INT 34
48460: PUSH
48461: LD_INT 47
48463: PUSH
48464: EMPTY
48465: LIST
48466: LIST
48467: PUSH
48468: EMPTY
48469: LIST
48470: LIST
48471: LIST
48472: LIST
48473: LIST
48474: PUSH
48475: EMPTY
48476: LIST
48477: LIST
48478: PPUSH
48479: CALL_OW 69
48483: ST_TO_ADDR
// if not tmp then
48484: LD_VAR 0 2
48488: NOT
48489: IFFALSE 48493
// exit ;
48491: GO 48522
// for i in tmp do
48493: LD_ADDR_VAR 0 1
48497: PUSH
48498: LD_VAR 0 2
48502: PUSH
48503: FOR_IN
48504: IFFALSE 48520
// begin SetLives ( i , 0 ) ;
48506: LD_VAR 0 1
48510: PPUSH
48511: LD_INT 0
48513: PPUSH
48514: CALL_OW 234
// end ;
48518: GO 48503
48520: POP
48521: POP
// end ;
48522: PPOPN 2
48524: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48525: LD_EXP 93
48529: PUSH
48530: LD_EXP 99
48534: AND
48535: IFFALSE 48619
48537: GO 48539
48539: DISABLE
48540: LD_INT 0
48542: PPUSH
48543: PPUSH
// begin enable ;
48544: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48545: LD_ADDR_VAR 0 2
48549: PUSH
48550: LD_INT 22
48552: PUSH
48553: LD_OWVAR 2
48557: PUSH
48558: EMPTY
48559: LIST
48560: LIST
48561: PUSH
48562: LD_INT 32
48564: PUSH
48565: LD_INT 3
48567: PUSH
48568: EMPTY
48569: LIST
48570: LIST
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: PPUSH
48576: CALL_OW 69
48580: ST_TO_ADDR
// if not tmp then
48581: LD_VAR 0 2
48585: NOT
48586: IFFALSE 48590
// exit ;
48588: GO 48619
// for i in tmp do
48590: LD_ADDR_VAR 0 1
48594: PUSH
48595: LD_VAR 0 2
48599: PUSH
48600: FOR_IN
48601: IFFALSE 48617
// begin SetLives ( i , 0 ) ;
48603: LD_VAR 0 1
48607: PPUSH
48608: LD_INT 0
48610: PPUSH
48611: CALL_OW 234
// end ;
48615: GO 48600
48617: POP
48618: POP
// end ;
48619: PPOPN 2
48621: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48622: LD_EXP 93
48626: PUSH
48627: LD_EXP 96
48631: AND
48632: IFFALSE 48725
48634: GO 48636
48636: DISABLE
48637: LD_INT 0
48639: PPUSH
// begin enable ;
48640: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48641: LD_ADDR_VAR 0 1
48645: PUSH
48646: LD_INT 22
48648: PUSH
48649: LD_OWVAR 2
48653: PUSH
48654: EMPTY
48655: LIST
48656: LIST
48657: PUSH
48658: LD_INT 2
48660: PUSH
48661: LD_INT 25
48663: PUSH
48664: LD_INT 5
48666: PUSH
48667: EMPTY
48668: LIST
48669: LIST
48670: PUSH
48671: LD_INT 25
48673: PUSH
48674: LD_INT 9
48676: PUSH
48677: EMPTY
48678: LIST
48679: LIST
48680: PUSH
48681: LD_INT 25
48683: PUSH
48684: LD_INT 8
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: LIST
48695: LIST
48696: PUSH
48697: EMPTY
48698: LIST
48699: LIST
48700: PPUSH
48701: CALL_OW 69
48705: PUSH
48706: FOR_IN
48707: IFFALSE 48723
// begin SetClass ( i , 1 ) ;
48709: LD_VAR 0 1
48713: PPUSH
48714: LD_INT 1
48716: PPUSH
48717: CALL_OW 336
// end ;
48721: GO 48706
48723: POP
48724: POP
// end ;
48725: PPOPN 1
48727: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48728: LD_EXP 93
48732: PUSH
48733: LD_EXP 97
48737: AND
48738: PUSH
48739: LD_OWVAR 65
48743: PUSH
48744: LD_INT 7
48746: LESS
48747: AND
48748: IFFALSE 48762
48750: GO 48752
48752: DISABLE
// begin enable ;
48753: ENABLE
// game_speed := 7 ;
48754: LD_ADDR_OWVAR 65
48758: PUSH
48759: LD_INT 7
48761: ST_TO_ADDR
// end ;
48762: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
48763: LD_EXP 93
48767: PUSH
48768: LD_EXP 100
48772: AND
48773: IFFALSE 48975
48775: GO 48777
48777: DISABLE
48778: LD_INT 0
48780: PPUSH
48781: PPUSH
48782: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
48783: LD_ADDR_VAR 0 3
48787: PUSH
48788: LD_INT 81
48790: PUSH
48791: LD_OWVAR 2
48795: PUSH
48796: EMPTY
48797: LIST
48798: LIST
48799: PUSH
48800: LD_INT 21
48802: PUSH
48803: LD_INT 1
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: PPUSH
48814: CALL_OW 69
48818: ST_TO_ADDR
// if not tmp then
48819: LD_VAR 0 3
48823: NOT
48824: IFFALSE 48828
// exit ;
48826: GO 48975
// if tmp > 5 then
48828: LD_VAR 0 3
48832: PUSH
48833: LD_INT 5
48835: GREATER
48836: IFFALSE 48848
// k := 5 else
48838: LD_ADDR_VAR 0 2
48842: PUSH
48843: LD_INT 5
48845: ST_TO_ADDR
48846: GO 48858
// k := tmp ;
48848: LD_ADDR_VAR 0 2
48852: PUSH
48853: LD_VAR 0 3
48857: ST_TO_ADDR
// for i := 1 to k do
48858: LD_ADDR_VAR 0 1
48862: PUSH
48863: DOUBLE
48864: LD_INT 1
48866: DEC
48867: ST_TO_ADDR
48868: LD_VAR 0 2
48872: PUSH
48873: FOR_TO
48874: IFFALSE 48973
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
48876: LD_VAR 0 3
48880: PUSH
48881: LD_VAR 0 1
48885: ARRAY
48886: PPUSH
48887: LD_VAR 0 1
48891: PUSH
48892: LD_INT 4
48894: MOD
48895: PUSH
48896: LD_INT 1
48898: PLUS
48899: PPUSH
48900: CALL_OW 259
48904: PUSH
48905: LD_INT 10
48907: LESS
48908: IFFALSE 48971
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
48910: LD_VAR 0 3
48914: PUSH
48915: LD_VAR 0 1
48919: ARRAY
48920: PPUSH
48921: LD_VAR 0 1
48925: PUSH
48926: LD_INT 4
48928: MOD
48929: PUSH
48930: LD_INT 1
48932: PLUS
48933: PPUSH
48934: LD_VAR 0 3
48938: PUSH
48939: LD_VAR 0 1
48943: ARRAY
48944: PPUSH
48945: LD_VAR 0 1
48949: PUSH
48950: LD_INT 4
48952: MOD
48953: PUSH
48954: LD_INT 1
48956: PLUS
48957: PPUSH
48958: CALL_OW 259
48962: PUSH
48963: LD_INT 1
48965: PLUS
48966: PPUSH
48967: CALL_OW 237
48971: GO 48873
48973: POP
48974: POP
// end ;
48975: PPOPN 3
48977: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
48978: LD_EXP 93
48982: PUSH
48983: LD_EXP 101
48987: AND
48988: IFFALSE 49008
48990: GO 48992
48992: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
48993: LD_INT 4
48995: PPUSH
48996: LD_OWVAR 2
49000: PPUSH
49001: LD_INT 0
49003: PPUSH
49004: CALL_OW 324
49008: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49009: LD_EXP 93
49013: PUSH
49014: LD_EXP 130
49018: AND
49019: IFFALSE 49039
49021: GO 49023
49023: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49024: LD_INT 19
49026: PPUSH
49027: LD_OWVAR 2
49031: PPUSH
49032: LD_INT 0
49034: PPUSH
49035: CALL_OW 324
49039: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49040: LD_EXP 93
49044: PUSH
49045: LD_EXP 102
49049: AND
49050: IFFALSE 49152
49052: GO 49054
49054: DISABLE
49055: LD_INT 0
49057: PPUSH
49058: PPUSH
// begin enable ;
49059: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49060: LD_ADDR_VAR 0 2
49064: PUSH
49065: LD_INT 22
49067: PUSH
49068: LD_OWVAR 2
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: PUSH
49077: LD_INT 2
49079: PUSH
49080: LD_INT 34
49082: PUSH
49083: LD_INT 11
49085: PUSH
49086: EMPTY
49087: LIST
49088: LIST
49089: PUSH
49090: LD_INT 34
49092: PUSH
49093: LD_INT 30
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: LIST
49104: PUSH
49105: EMPTY
49106: LIST
49107: LIST
49108: PPUSH
49109: CALL_OW 69
49113: ST_TO_ADDR
// if not tmp then
49114: LD_VAR 0 2
49118: NOT
49119: IFFALSE 49123
// exit ;
49121: GO 49152
// for i in tmp do
49123: LD_ADDR_VAR 0 1
49127: PUSH
49128: LD_VAR 0 2
49132: PUSH
49133: FOR_IN
49134: IFFALSE 49150
// begin SetLives ( i , 0 ) ;
49136: LD_VAR 0 1
49140: PPUSH
49141: LD_INT 0
49143: PPUSH
49144: CALL_OW 234
// end ;
49148: GO 49133
49150: POP
49151: POP
// end ;
49152: PPOPN 2
49154: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49155: LD_EXP 93
49159: PUSH
49160: LD_EXP 103
49164: AND
49165: IFFALSE 49185
49167: GO 49169
49169: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49170: LD_INT 32
49172: PPUSH
49173: LD_OWVAR 2
49177: PPUSH
49178: LD_INT 0
49180: PPUSH
49181: CALL_OW 324
49185: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49186: LD_EXP 93
49190: PUSH
49191: LD_EXP 104
49195: AND
49196: IFFALSE 49377
49198: GO 49200
49200: DISABLE
49201: LD_INT 0
49203: PPUSH
49204: PPUSH
49205: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49206: LD_ADDR_VAR 0 2
49210: PUSH
49211: LD_INT 22
49213: PUSH
49214: LD_OWVAR 2
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: PUSH
49223: LD_INT 33
49225: PUSH
49226: LD_INT 3
49228: PUSH
49229: EMPTY
49230: LIST
49231: LIST
49232: PUSH
49233: EMPTY
49234: LIST
49235: LIST
49236: PPUSH
49237: CALL_OW 69
49241: ST_TO_ADDR
// if not tmp then
49242: LD_VAR 0 2
49246: NOT
49247: IFFALSE 49251
// exit ;
49249: GO 49377
// side := 0 ;
49251: LD_ADDR_VAR 0 3
49255: PUSH
49256: LD_INT 0
49258: ST_TO_ADDR
// for i := 1 to 8 do
49259: LD_ADDR_VAR 0 1
49263: PUSH
49264: DOUBLE
49265: LD_INT 1
49267: DEC
49268: ST_TO_ADDR
49269: LD_INT 8
49271: PUSH
49272: FOR_TO
49273: IFFALSE 49321
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49275: LD_OWVAR 2
49279: PUSH
49280: LD_VAR 0 1
49284: NONEQUAL
49285: PUSH
49286: LD_OWVAR 2
49290: PPUSH
49291: LD_VAR 0 1
49295: PPUSH
49296: CALL_OW 81
49300: PUSH
49301: LD_INT 2
49303: EQUAL
49304: AND
49305: IFFALSE 49319
// begin side := i ;
49307: LD_ADDR_VAR 0 3
49311: PUSH
49312: LD_VAR 0 1
49316: ST_TO_ADDR
// break ;
49317: GO 49321
// end ;
49319: GO 49272
49321: POP
49322: POP
// if not side then
49323: LD_VAR 0 3
49327: NOT
49328: IFFALSE 49332
// exit ;
49330: GO 49377
// for i := 1 to tmp do
49332: LD_ADDR_VAR 0 1
49336: PUSH
49337: DOUBLE
49338: LD_INT 1
49340: DEC
49341: ST_TO_ADDR
49342: LD_VAR 0 2
49346: PUSH
49347: FOR_TO
49348: IFFALSE 49375
// if Prob ( 60 ) then
49350: LD_INT 60
49352: PPUSH
49353: CALL_OW 13
49357: IFFALSE 49373
// SetSide ( i , side ) ;
49359: LD_VAR 0 1
49363: PPUSH
49364: LD_VAR 0 3
49368: PPUSH
49369: CALL_OW 235
49373: GO 49347
49375: POP
49376: POP
// end ;
49377: PPOPN 3
49379: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49380: LD_EXP 93
49384: PUSH
49385: LD_EXP 106
49389: AND
49390: IFFALSE 49509
49392: GO 49394
49394: DISABLE
49395: LD_INT 0
49397: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49398: LD_ADDR_VAR 0 1
49402: PUSH
49403: LD_INT 22
49405: PUSH
49406: LD_OWVAR 2
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PUSH
49415: LD_INT 21
49417: PUSH
49418: LD_INT 1
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: PUSH
49425: LD_INT 3
49427: PUSH
49428: LD_INT 23
49430: PUSH
49431: LD_INT 0
49433: PUSH
49434: EMPTY
49435: LIST
49436: LIST
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: PUSH
49442: EMPTY
49443: LIST
49444: LIST
49445: LIST
49446: PPUSH
49447: CALL_OW 69
49451: PUSH
49452: FOR_IN
49453: IFFALSE 49507
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49455: LD_VAR 0 1
49459: PPUSH
49460: CALL_OW 257
49464: PUSH
49465: LD_INT 1
49467: PUSH
49468: LD_INT 2
49470: PUSH
49471: LD_INT 3
49473: PUSH
49474: LD_INT 4
49476: PUSH
49477: EMPTY
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: IN
49483: IFFALSE 49505
// SetClass ( un , rand ( 1 , 4 ) ) ;
49485: LD_VAR 0 1
49489: PPUSH
49490: LD_INT 1
49492: PPUSH
49493: LD_INT 4
49495: PPUSH
49496: CALL_OW 12
49500: PPUSH
49501: CALL_OW 336
49505: GO 49452
49507: POP
49508: POP
// end ;
49509: PPOPN 1
49511: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49512: LD_EXP 93
49516: PUSH
49517: LD_EXP 105
49521: AND
49522: IFFALSE 49601
49524: GO 49526
49526: DISABLE
49527: LD_INT 0
49529: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49530: LD_ADDR_VAR 0 1
49534: PUSH
49535: LD_INT 22
49537: PUSH
49538: LD_OWVAR 2
49542: PUSH
49543: EMPTY
49544: LIST
49545: LIST
49546: PUSH
49547: LD_INT 21
49549: PUSH
49550: LD_INT 3
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: PUSH
49557: EMPTY
49558: LIST
49559: LIST
49560: PPUSH
49561: CALL_OW 69
49565: ST_TO_ADDR
// if not tmp then
49566: LD_VAR 0 1
49570: NOT
49571: IFFALSE 49575
// exit ;
49573: GO 49601
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49575: LD_VAR 0 1
49579: PUSH
49580: LD_INT 1
49582: PPUSH
49583: LD_VAR 0 1
49587: PPUSH
49588: CALL_OW 12
49592: ARRAY
49593: PPUSH
49594: LD_INT 100
49596: PPUSH
49597: CALL_OW 234
// end ;
49601: PPOPN 1
49603: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49604: LD_EXP 93
49608: PUSH
49609: LD_EXP 107
49613: AND
49614: IFFALSE 49712
49616: GO 49618
49618: DISABLE
49619: LD_INT 0
49621: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49622: LD_ADDR_VAR 0 1
49626: PUSH
49627: LD_INT 22
49629: PUSH
49630: LD_OWVAR 2
49634: PUSH
49635: EMPTY
49636: LIST
49637: LIST
49638: PUSH
49639: LD_INT 21
49641: PUSH
49642: LD_INT 1
49644: PUSH
49645: EMPTY
49646: LIST
49647: LIST
49648: PUSH
49649: EMPTY
49650: LIST
49651: LIST
49652: PPUSH
49653: CALL_OW 69
49657: ST_TO_ADDR
// if not tmp then
49658: LD_VAR 0 1
49662: NOT
49663: IFFALSE 49667
// exit ;
49665: GO 49712
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49667: LD_VAR 0 1
49671: PUSH
49672: LD_INT 1
49674: PPUSH
49675: LD_VAR 0 1
49679: PPUSH
49680: CALL_OW 12
49684: ARRAY
49685: PPUSH
49686: LD_INT 1
49688: PPUSH
49689: LD_INT 4
49691: PPUSH
49692: CALL_OW 12
49696: PPUSH
49697: LD_INT 3000
49699: PPUSH
49700: LD_INT 9000
49702: PPUSH
49703: CALL_OW 12
49707: PPUSH
49708: CALL_OW 492
// end ;
49712: PPOPN 1
49714: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49715: LD_EXP 93
49719: PUSH
49720: LD_EXP 108
49724: AND
49725: IFFALSE 49745
49727: GO 49729
49729: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49730: LD_INT 1
49732: PPUSH
49733: LD_OWVAR 2
49737: PPUSH
49738: LD_INT 0
49740: PPUSH
49741: CALL_OW 324
49745: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49746: LD_EXP 93
49750: PUSH
49751: LD_EXP 109
49755: AND
49756: IFFALSE 49839
49758: GO 49760
49760: DISABLE
49761: LD_INT 0
49763: PPUSH
49764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49765: LD_ADDR_VAR 0 2
49769: PUSH
49770: LD_INT 22
49772: PUSH
49773: LD_OWVAR 2
49777: PUSH
49778: EMPTY
49779: LIST
49780: LIST
49781: PUSH
49782: LD_INT 21
49784: PUSH
49785: LD_INT 3
49787: PUSH
49788: EMPTY
49789: LIST
49790: LIST
49791: PUSH
49792: EMPTY
49793: LIST
49794: LIST
49795: PPUSH
49796: CALL_OW 69
49800: ST_TO_ADDR
// if not tmp then
49801: LD_VAR 0 2
49805: NOT
49806: IFFALSE 49810
// exit ;
49808: GO 49839
// for i in tmp do
49810: LD_ADDR_VAR 0 1
49814: PUSH
49815: LD_VAR 0 2
49819: PUSH
49820: FOR_IN
49821: IFFALSE 49837
// SetBLevel ( i , 10 ) ;
49823: LD_VAR 0 1
49827: PPUSH
49828: LD_INT 10
49830: PPUSH
49831: CALL_OW 241
49835: GO 49820
49837: POP
49838: POP
// end ;
49839: PPOPN 2
49841: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
49842: LD_EXP 93
49846: PUSH
49847: LD_EXP 110
49851: AND
49852: IFFALSE 49963
49854: GO 49856
49856: DISABLE
49857: LD_INT 0
49859: PPUSH
49860: PPUSH
49861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
49862: LD_ADDR_VAR 0 3
49866: PUSH
49867: LD_INT 22
49869: PUSH
49870: LD_OWVAR 2
49874: PUSH
49875: EMPTY
49876: LIST
49877: LIST
49878: PUSH
49879: LD_INT 25
49881: PUSH
49882: LD_INT 1
49884: PUSH
49885: EMPTY
49886: LIST
49887: LIST
49888: PUSH
49889: EMPTY
49890: LIST
49891: LIST
49892: PPUSH
49893: CALL_OW 69
49897: ST_TO_ADDR
// if not tmp then
49898: LD_VAR 0 3
49902: NOT
49903: IFFALSE 49907
// exit ;
49905: GO 49963
// un := tmp [ rand ( 1 , tmp ) ] ;
49907: LD_ADDR_VAR 0 2
49911: PUSH
49912: LD_VAR 0 3
49916: PUSH
49917: LD_INT 1
49919: PPUSH
49920: LD_VAR 0 3
49924: PPUSH
49925: CALL_OW 12
49929: ARRAY
49930: ST_TO_ADDR
// if Crawls ( un ) then
49931: LD_VAR 0 2
49935: PPUSH
49936: CALL_OW 318
49940: IFFALSE 49951
// ComWalk ( un ) ;
49942: LD_VAR 0 2
49946: PPUSH
49947: CALL_OW 138
// SetClass ( un , class_sniper ) ;
49951: LD_VAR 0 2
49955: PPUSH
49956: LD_INT 5
49958: PPUSH
49959: CALL_OW 336
// end ;
49963: PPOPN 3
49965: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
49966: LD_EXP 93
49970: PUSH
49971: LD_EXP 111
49975: AND
49976: PUSH
49977: LD_OWVAR 67
49981: PUSH
49982: LD_INT 3
49984: LESS
49985: AND
49986: IFFALSE 50005
49988: GO 49990
49990: DISABLE
// Difficulty := Difficulty + 1 ;
49991: LD_ADDR_OWVAR 67
49995: PUSH
49996: LD_OWVAR 67
50000: PUSH
50001: LD_INT 1
50003: PLUS
50004: ST_TO_ADDR
50005: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50006: LD_EXP 93
50010: PUSH
50011: LD_EXP 112
50015: AND
50016: IFFALSE 50119
50018: GO 50020
50020: DISABLE
50021: LD_INT 0
50023: PPUSH
// begin for i := 1 to 5 do
50024: LD_ADDR_VAR 0 1
50028: PUSH
50029: DOUBLE
50030: LD_INT 1
50032: DEC
50033: ST_TO_ADDR
50034: LD_INT 5
50036: PUSH
50037: FOR_TO
50038: IFFALSE 50117
// begin uc_nation := nation_nature ;
50040: LD_ADDR_OWVAR 21
50044: PUSH
50045: LD_INT 0
50047: ST_TO_ADDR
// uc_side := 0 ;
50048: LD_ADDR_OWVAR 20
50052: PUSH
50053: LD_INT 0
50055: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50056: LD_ADDR_OWVAR 29
50060: PUSH
50061: LD_INT 12
50063: PUSH
50064: LD_INT 12
50066: PUSH
50067: EMPTY
50068: LIST
50069: LIST
50070: ST_TO_ADDR
// hc_agressivity := 20 ;
50071: LD_ADDR_OWVAR 35
50075: PUSH
50076: LD_INT 20
50078: ST_TO_ADDR
// hc_class := class_tiger ;
50079: LD_ADDR_OWVAR 28
50083: PUSH
50084: LD_INT 14
50086: ST_TO_ADDR
// hc_gallery :=  ;
50087: LD_ADDR_OWVAR 33
50091: PUSH
50092: LD_STRING 
50094: ST_TO_ADDR
// hc_name :=  ;
50095: LD_ADDR_OWVAR 26
50099: PUSH
50100: LD_STRING 
50102: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50103: CALL_OW 44
50107: PPUSH
50108: LD_INT 0
50110: PPUSH
50111: CALL_OW 51
// end ;
50115: GO 50037
50117: POP
50118: POP
// end ;
50119: PPOPN 1
50121: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50122: LD_EXP 93
50126: PUSH
50127: LD_EXP 113
50131: AND
50132: IFFALSE 50141
50134: GO 50136
50136: DISABLE
// StreamSibBomb ;
50137: CALL 50142 0 0
50141: END
// export function StreamSibBomb ; var i , x , y ; begin
50142: LD_INT 0
50144: PPUSH
50145: PPUSH
50146: PPUSH
50147: PPUSH
// result := false ;
50148: LD_ADDR_VAR 0 1
50152: PUSH
50153: LD_INT 0
50155: ST_TO_ADDR
// for i := 1 to 16 do
50156: LD_ADDR_VAR 0 2
50160: PUSH
50161: DOUBLE
50162: LD_INT 1
50164: DEC
50165: ST_TO_ADDR
50166: LD_INT 16
50168: PUSH
50169: FOR_TO
50170: IFFALSE 50369
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50172: LD_ADDR_VAR 0 3
50176: PUSH
50177: LD_INT 10
50179: PUSH
50180: LD_INT 20
50182: PUSH
50183: LD_INT 30
50185: PUSH
50186: LD_INT 40
50188: PUSH
50189: LD_INT 50
50191: PUSH
50192: LD_INT 60
50194: PUSH
50195: LD_INT 70
50197: PUSH
50198: LD_INT 80
50200: PUSH
50201: LD_INT 90
50203: PUSH
50204: LD_INT 100
50206: PUSH
50207: LD_INT 110
50209: PUSH
50210: LD_INT 120
50212: PUSH
50213: LD_INT 130
50215: PUSH
50216: LD_INT 140
50218: PUSH
50219: LD_INT 150
50221: PUSH
50222: EMPTY
50223: LIST
50224: LIST
50225: LIST
50226: LIST
50227: LIST
50228: LIST
50229: LIST
50230: LIST
50231: LIST
50232: LIST
50233: LIST
50234: LIST
50235: LIST
50236: LIST
50237: LIST
50238: PUSH
50239: LD_INT 1
50241: PPUSH
50242: LD_INT 15
50244: PPUSH
50245: CALL_OW 12
50249: ARRAY
50250: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50251: LD_ADDR_VAR 0 4
50255: PUSH
50256: LD_INT 10
50258: PUSH
50259: LD_INT 20
50261: PUSH
50262: LD_INT 30
50264: PUSH
50265: LD_INT 40
50267: PUSH
50268: LD_INT 50
50270: PUSH
50271: LD_INT 60
50273: PUSH
50274: LD_INT 70
50276: PUSH
50277: LD_INT 80
50279: PUSH
50280: LD_INT 90
50282: PUSH
50283: LD_INT 100
50285: PUSH
50286: LD_INT 110
50288: PUSH
50289: LD_INT 120
50291: PUSH
50292: LD_INT 130
50294: PUSH
50295: LD_INT 140
50297: PUSH
50298: LD_INT 150
50300: PUSH
50301: EMPTY
50302: LIST
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: LIST
50313: LIST
50314: LIST
50315: LIST
50316: LIST
50317: PUSH
50318: LD_INT 1
50320: PPUSH
50321: LD_INT 15
50323: PPUSH
50324: CALL_OW 12
50328: ARRAY
50329: ST_TO_ADDR
// if ValidHex ( x , y ) then
50330: LD_VAR 0 3
50334: PPUSH
50335: LD_VAR 0 4
50339: PPUSH
50340: CALL_OW 488
50344: IFFALSE 50367
// begin result := [ x , y ] ;
50346: LD_ADDR_VAR 0 1
50350: PUSH
50351: LD_VAR 0 3
50355: PUSH
50356: LD_VAR 0 4
50360: PUSH
50361: EMPTY
50362: LIST
50363: LIST
50364: ST_TO_ADDR
// break ;
50365: GO 50369
// end ; end ;
50367: GO 50169
50369: POP
50370: POP
// if result then
50371: LD_VAR 0 1
50375: IFFALSE 50435
// begin ToLua ( playSibBomb() ) ;
50377: LD_STRING playSibBomb()
50379: PPUSH
50380: CALL_OW 559
// wait ( 0 0$14 ) ;
50384: LD_INT 490
50386: PPUSH
50387: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50391: LD_VAR 0 1
50395: PUSH
50396: LD_INT 1
50398: ARRAY
50399: PPUSH
50400: LD_VAR 0 1
50404: PUSH
50405: LD_INT 2
50407: ARRAY
50408: PPUSH
50409: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50413: LD_VAR 0 1
50417: PUSH
50418: LD_INT 1
50420: ARRAY
50421: PPUSH
50422: LD_VAR 0 1
50426: PUSH
50427: LD_INT 2
50429: ARRAY
50430: PPUSH
50431: CALL_OW 429
// end ; end ;
50435: LD_VAR 0 1
50439: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50440: LD_EXP 93
50444: PUSH
50445: LD_EXP 115
50449: AND
50450: IFFALSE 50462
50452: GO 50454
50454: DISABLE
// YouLost (  ) ;
50455: LD_STRING 
50457: PPUSH
50458: CALL_OW 104
50462: END
// every 0 0$1 trigger StreamModeActive and sFog do
50463: LD_EXP 93
50467: PUSH
50468: LD_EXP 114
50472: AND
50473: IFFALSE 50487
50475: GO 50477
50477: DISABLE
// FogOff ( your_side ) ;
50478: LD_OWVAR 2
50482: PPUSH
50483: CALL_OW 344
50487: END
// every 0 0$1 trigger StreamModeActive and sSun do
50488: LD_EXP 93
50492: PUSH
50493: LD_EXP 116
50497: AND
50498: IFFALSE 50526
50500: GO 50502
50502: DISABLE
// begin solar_recharge_percent := 0 ;
50503: LD_ADDR_OWVAR 79
50507: PUSH
50508: LD_INT 0
50510: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50511: LD_INT 10500
50513: PPUSH
50514: CALL_OW 67
// solar_recharge_percent := 100 ;
50518: LD_ADDR_OWVAR 79
50522: PUSH
50523: LD_INT 100
50525: ST_TO_ADDR
// end ;
50526: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50527: LD_EXP 93
50531: PUSH
50532: LD_EXP 117
50536: AND
50537: IFFALSE 50776
50539: GO 50541
50541: DISABLE
50542: LD_INT 0
50544: PPUSH
50545: PPUSH
50546: PPUSH
// begin tmp := [ ] ;
50547: LD_ADDR_VAR 0 3
50551: PUSH
50552: EMPTY
50553: ST_TO_ADDR
// for i := 1 to 6 do
50554: LD_ADDR_VAR 0 1
50558: PUSH
50559: DOUBLE
50560: LD_INT 1
50562: DEC
50563: ST_TO_ADDR
50564: LD_INT 6
50566: PUSH
50567: FOR_TO
50568: IFFALSE 50673
// begin uc_nation := nation_nature ;
50570: LD_ADDR_OWVAR 21
50574: PUSH
50575: LD_INT 0
50577: ST_TO_ADDR
// uc_side := 0 ;
50578: LD_ADDR_OWVAR 20
50582: PUSH
50583: LD_INT 0
50585: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50586: LD_ADDR_OWVAR 29
50590: PUSH
50591: LD_INT 12
50593: PUSH
50594: LD_INT 12
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: ST_TO_ADDR
// hc_agressivity := 20 ;
50601: LD_ADDR_OWVAR 35
50605: PUSH
50606: LD_INT 20
50608: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50609: LD_ADDR_OWVAR 28
50613: PUSH
50614: LD_INT 17
50616: ST_TO_ADDR
// hc_gallery :=  ;
50617: LD_ADDR_OWVAR 33
50621: PUSH
50622: LD_STRING 
50624: ST_TO_ADDR
// hc_name :=  ;
50625: LD_ADDR_OWVAR 26
50629: PUSH
50630: LD_STRING 
50632: ST_TO_ADDR
// un := CreateHuman ;
50633: LD_ADDR_VAR 0 2
50637: PUSH
50638: CALL_OW 44
50642: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50643: LD_VAR 0 2
50647: PPUSH
50648: LD_INT 1
50650: PPUSH
50651: CALL_OW 51
// tmp := tmp ^ un ;
50655: LD_ADDR_VAR 0 3
50659: PUSH
50660: LD_VAR 0 3
50664: PUSH
50665: LD_VAR 0 2
50669: ADD
50670: ST_TO_ADDR
// end ;
50671: GO 50567
50673: POP
50674: POP
// repeat wait ( 0 0$1 ) ;
50675: LD_INT 35
50677: PPUSH
50678: CALL_OW 67
// for un in tmp do
50682: LD_ADDR_VAR 0 2
50686: PUSH
50687: LD_VAR 0 3
50691: PUSH
50692: FOR_IN
50693: IFFALSE 50767
// begin if IsDead ( un ) then
50695: LD_VAR 0 2
50699: PPUSH
50700: CALL_OW 301
50704: IFFALSE 50724
// begin tmp := tmp diff un ;
50706: LD_ADDR_VAR 0 3
50710: PUSH
50711: LD_VAR 0 3
50715: PUSH
50716: LD_VAR 0 2
50720: DIFF
50721: ST_TO_ADDR
// continue ;
50722: GO 50692
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50724: LD_VAR 0 2
50728: PPUSH
50729: LD_INT 3
50731: PUSH
50732: LD_INT 22
50734: PUSH
50735: LD_INT 0
50737: PUSH
50738: EMPTY
50739: LIST
50740: LIST
50741: PUSH
50742: EMPTY
50743: LIST
50744: LIST
50745: PPUSH
50746: CALL_OW 69
50750: PPUSH
50751: LD_VAR 0 2
50755: PPUSH
50756: CALL_OW 74
50760: PPUSH
50761: CALL_OW 115
// end ;
50765: GO 50692
50767: POP
50768: POP
// until not tmp ;
50769: LD_VAR 0 3
50773: NOT
50774: IFFALSE 50675
// end ;
50776: PPOPN 3
50778: END
// every 0 0$1 trigger StreamModeActive and sTroll do
50779: LD_EXP 93
50783: PUSH
50784: LD_EXP 118
50788: AND
50789: IFFALSE 50843
50791: GO 50793
50793: DISABLE
// begin ToLua ( displayTroll(); ) ;
50794: LD_STRING displayTroll();
50796: PPUSH
50797: CALL_OW 559
// wait ( 3 3$00 ) ;
50801: LD_INT 6300
50803: PPUSH
50804: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50808: LD_STRING hideTroll();
50810: PPUSH
50811: CALL_OW 559
// wait ( 1 1$00 ) ;
50815: LD_INT 2100
50817: PPUSH
50818: CALL_OW 67
// ToLua ( displayTroll(); ) ;
50822: LD_STRING displayTroll();
50824: PPUSH
50825: CALL_OW 559
// wait ( 1 1$00 ) ;
50829: LD_INT 2100
50831: PPUSH
50832: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50836: LD_STRING hideTroll();
50838: PPUSH
50839: CALL_OW 559
// end ;
50843: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
50844: LD_EXP 93
50848: PUSH
50849: LD_EXP 119
50853: AND
50854: IFFALSE 50917
50856: GO 50858
50858: DISABLE
50859: LD_INT 0
50861: PPUSH
// begin p := 0 ;
50862: LD_ADDR_VAR 0 1
50866: PUSH
50867: LD_INT 0
50869: ST_TO_ADDR
// repeat game_speed := 1 ;
50870: LD_ADDR_OWVAR 65
50874: PUSH
50875: LD_INT 1
50877: ST_TO_ADDR
// wait ( 0 0$1 ) ;
50878: LD_INT 35
50880: PPUSH
50881: CALL_OW 67
// p := p + 1 ;
50885: LD_ADDR_VAR 0 1
50889: PUSH
50890: LD_VAR 0 1
50894: PUSH
50895: LD_INT 1
50897: PLUS
50898: ST_TO_ADDR
// until p >= 60 ;
50899: LD_VAR 0 1
50903: PUSH
50904: LD_INT 60
50906: GREATEREQUAL
50907: IFFALSE 50870
// game_speed := 4 ;
50909: LD_ADDR_OWVAR 65
50913: PUSH
50914: LD_INT 4
50916: ST_TO_ADDR
// end ;
50917: PPOPN 1
50919: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
50920: LD_EXP 93
50924: PUSH
50925: LD_EXP 120
50929: AND
50930: IFFALSE 51076
50932: GO 50934
50934: DISABLE
50935: LD_INT 0
50937: PPUSH
50938: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
50939: LD_ADDR_VAR 0 1
50943: PUSH
50944: LD_INT 22
50946: PUSH
50947: LD_OWVAR 2
50951: PUSH
50952: EMPTY
50953: LIST
50954: LIST
50955: PUSH
50956: LD_INT 2
50958: PUSH
50959: LD_INT 30
50961: PUSH
50962: LD_INT 0
50964: PUSH
50965: EMPTY
50966: LIST
50967: LIST
50968: PUSH
50969: LD_INT 30
50971: PUSH
50972: LD_INT 1
50974: PUSH
50975: EMPTY
50976: LIST
50977: LIST
50978: PUSH
50979: EMPTY
50980: LIST
50981: LIST
50982: LIST
50983: PUSH
50984: EMPTY
50985: LIST
50986: LIST
50987: PPUSH
50988: CALL_OW 69
50992: ST_TO_ADDR
// if not depot then
50993: LD_VAR 0 1
50997: NOT
50998: IFFALSE 51002
// exit ;
51000: GO 51076
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51002: LD_ADDR_VAR 0 2
51006: PUSH
51007: LD_VAR 0 1
51011: PUSH
51012: LD_INT 1
51014: PPUSH
51015: LD_VAR 0 1
51019: PPUSH
51020: CALL_OW 12
51024: ARRAY
51025: PPUSH
51026: CALL_OW 274
51030: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51031: LD_VAR 0 2
51035: PPUSH
51036: LD_INT 1
51038: PPUSH
51039: LD_INT 0
51041: PPUSH
51042: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51046: LD_VAR 0 2
51050: PPUSH
51051: LD_INT 2
51053: PPUSH
51054: LD_INT 0
51056: PPUSH
51057: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51061: LD_VAR 0 2
51065: PPUSH
51066: LD_INT 3
51068: PPUSH
51069: LD_INT 0
51071: PPUSH
51072: CALL_OW 277
// end ;
51076: PPOPN 2
51078: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51079: LD_EXP 93
51083: PUSH
51084: LD_EXP 121
51088: AND
51089: IFFALSE 51186
51091: GO 51093
51093: DISABLE
51094: LD_INT 0
51096: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51097: LD_ADDR_VAR 0 1
51101: PUSH
51102: LD_INT 22
51104: PUSH
51105: LD_OWVAR 2
51109: PUSH
51110: EMPTY
51111: LIST
51112: LIST
51113: PUSH
51114: LD_INT 21
51116: PUSH
51117: LD_INT 1
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: PUSH
51124: LD_INT 3
51126: PUSH
51127: LD_INT 23
51129: PUSH
51130: LD_INT 0
51132: PUSH
51133: EMPTY
51134: LIST
51135: LIST
51136: PUSH
51137: EMPTY
51138: LIST
51139: LIST
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: LIST
51145: PPUSH
51146: CALL_OW 69
51150: ST_TO_ADDR
// if not tmp then
51151: LD_VAR 0 1
51155: NOT
51156: IFFALSE 51160
// exit ;
51158: GO 51186
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51160: LD_VAR 0 1
51164: PUSH
51165: LD_INT 1
51167: PPUSH
51168: LD_VAR 0 1
51172: PPUSH
51173: CALL_OW 12
51177: ARRAY
51178: PPUSH
51179: LD_INT 200
51181: PPUSH
51182: CALL_OW 234
// end ;
51186: PPOPN 1
51188: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51189: LD_EXP 93
51193: PUSH
51194: LD_EXP 122
51198: AND
51199: IFFALSE 51278
51201: GO 51203
51203: DISABLE
51204: LD_INT 0
51206: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51207: LD_ADDR_VAR 0 1
51211: PUSH
51212: LD_INT 22
51214: PUSH
51215: LD_OWVAR 2
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: PUSH
51224: LD_INT 21
51226: PUSH
51227: LD_INT 2
51229: PUSH
51230: EMPTY
51231: LIST
51232: LIST
51233: PUSH
51234: EMPTY
51235: LIST
51236: LIST
51237: PPUSH
51238: CALL_OW 69
51242: ST_TO_ADDR
// if not tmp then
51243: LD_VAR 0 1
51247: NOT
51248: IFFALSE 51252
// exit ;
51250: GO 51278
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51252: LD_VAR 0 1
51256: PUSH
51257: LD_INT 1
51259: PPUSH
51260: LD_VAR 0 1
51264: PPUSH
51265: CALL_OW 12
51269: ARRAY
51270: PPUSH
51271: LD_INT 60
51273: PPUSH
51274: CALL_OW 234
// end ;
51278: PPOPN 1
51280: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51281: LD_EXP 93
51285: PUSH
51286: LD_EXP 123
51290: AND
51291: IFFALSE 51390
51293: GO 51295
51295: DISABLE
51296: LD_INT 0
51298: PPUSH
51299: PPUSH
// begin enable ;
51300: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51301: LD_ADDR_VAR 0 1
51305: PUSH
51306: LD_INT 22
51308: PUSH
51309: LD_OWVAR 2
51313: PUSH
51314: EMPTY
51315: LIST
51316: LIST
51317: PUSH
51318: LD_INT 61
51320: PUSH
51321: EMPTY
51322: LIST
51323: PUSH
51324: LD_INT 33
51326: PUSH
51327: LD_INT 2
51329: PUSH
51330: EMPTY
51331: LIST
51332: LIST
51333: PUSH
51334: EMPTY
51335: LIST
51336: LIST
51337: LIST
51338: PPUSH
51339: CALL_OW 69
51343: ST_TO_ADDR
// if not tmp then
51344: LD_VAR 0 1
51348: NOT
51349: IFFALSE 51353
// exit ;
51351: GO 51390
// for i in tmp do
51353: LD_ADDR_VAR 0 2
51357: PUSH
51358: LD_VAR 0 1
51362: PUSH
51363: FOR_IN
51364: IFFALSE 51388
// if IsControledBy ( i ) then
51366: LD_VAR 0 2
51370: PPUSH
51371: CALL_OW 312
51375: IFFALSE 51386
// ComUnlink ( i ) ;
51377: LD_VAR 0 2
51381: PPUSH
51382: CALL_OW 136
51386: GO 51363
51388: POP
51389: POP
// end ;
51390: PPOPN 2
51392: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51393: LD_EXP 93
51397: PUSH
51398: LD_EXP 124
51402: AND
51403: IFFALSE 51543
51405: GO 51407
51407: DISABLE
51408: LD_INT 0
51410: PPUSH
51411: PPUSH
// begin ToLua ( displayPowell(); ) ;
51412: LD_STRING displayPowell();
51414: PPUSH
51415: CALL_OW 559
// uc_side := 0 ;
51419: LD_ADDR_OWVAR 20
51423: PUSH
51424: LD_INT 0
51426: ST_TO_ADDR
// uc_nation := 2 ;
51427: LD_ADDR_OWVAR 21
51431: PUSH
51432: LD_INT 2
51434: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51435: LD_ADDR_OWVAR 37
51439: PUSH
51440: LD_INT 14
51442: ST_TO_ADDR
// vc_engine := engine_siberite ;
51443: LD_ADDR_OWVAR 39
51447: PUSH
51448: LD_INT 3
51450: ST_TO_ADDR
// vc_control := control_apeman ;
51451: LD_ADDR_OWVAR 38
51455: PUSH
51456: LD_INT 5
51458: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51459: LD_ADDR_OWVAR 40
51463: PUSH
51464: LD_INT 29
51466: ST_TO_ADDR
// un := CreateVehicle ;
51467: LD_ADDR_VAR 0 2
51471: PUSH
51472: CALL_OW 45
51476: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51477: LD_VAR 0 2
51481: PPUSH
51482: LD_INT 1
51484: PPUSH
51485: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51489: LD_INT 35
51491: PPUSH
51492: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51496: LD_VAR 0 2
51500: PPUSH
51501: LD_INT 22
51503: PUSH
51504: LD_OWVAR 2
51508: PUSH
51509: EMPTY
51510: LIST
51511: LIST
51512: PPUSH
51513: CALL_OW 69
51517: PPUSH
51518: LD_VAR 0 2
51522: PPUSH
51523: CALL_OW 74
51527: PPUSH
51528: CALL_OW 115
// until IsDead ( un ) ;
51532: LD_VAR 0 2
51536: PPUSH
51537: CALL_OW 301
51541: IFFALSE 51489
// end ;
51543: PPOPN 2
51545: END
// every 0 0$1 trigger StreamModeActive and sStu do
51546: LD_EXP 93
51550: PUSH
51551: LD_EXP 132
51555: AND
51556: IFFALSE 51572
51558: GO 51560
51560: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51561: LD_STRING displayStucuk();
51563: PPUSH
51564: CALL_OW 559
// ResetFog ;
51568: CALL_OW 335
// end ;
51572: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51573: LD_EXP 93
51577: PUSH
51578: LD_EXP 125
51582: AND
51583: IFFALSE 51724
51585: GO 51587
51587: DISABLE
51588: LD_INT 0
51590: PPUSH
51591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51592: LD_ADDR_VAR 0 2
51596: PUSH
51597: LD_INT 22
51599: PUSH
51600: LD_OWVAR 2
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: PUSH
51609: LD_INT 21
51611: PUSH
51612: LD_INT 1
51614: PUSH
51615: EMPTY
51616: LIST
51617: LIST
51618: PUSH
51619: EMPTY
51620: LIST
51621: LIST
51622: PPUSH
51623: CALL_OW 69
51627: ST_TO_ADDR
// if not tmp then
51628: LD_VAR 0 2
51632: NOT
51633: IFFALSE 51637
// exit ;
51635: GO 51724
// un := tmp [ rand ( 1 , tmp ) ] ;
51637: LD_ADDR_VAR 0 1
51641: PUSH
51642: LD_VAR 0 2
51646: PUSH
51647: LD_INT 1
51649: PPUSH
51650: LD_VAR 0 2
51654: PPUSH
51655: CALL_OW 12
51659: ARRAY
51660: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51661: LD_VAR 0 1
51665: PPUSH
51666: LD_INT 0
51668: PPUSH
51669: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51673: LD_VAR 0 1
51677: PPUSH
51678: LD_OWVAR 3
51682: PUSH
51683: LD_VAR 0 1
51687: DIFF
51688: PPUSH
51689: LD_VAR 0 1
51693: PPUSH
51694: CALL_OW 74
51698: PPUSH
51699: CALL_OW 115
// wait ( 0 0$20 ) ;
51703: LD_INT 700
51705: PPUSH
51706: CALL_OW 67
// SetSide ( un , your_side ) ;
51710: LD_VAR 0 1
51714: PPUSH
51715: LD_OWVAR 2
51719: PPUSH
51720: CALL_OW 235
// end ;
51724: PPOPN 2
51726: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51727: LD_EXP 93
51731: PUSH
51732: LD_EXP 126
51736: AND
51737: IFFALSE 51843
51739: GO 51741
51741: DISABLE
51742: LD_INT 0
51744: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51745: LD_ADDR_VAR 0 1
51749: PUSH
51750: LD_INT 22
51752: PUSH
51753: LD_OWVAR 2
51757: PUSH
51758: EMPTY
51759: LIST
51760: LIST
51761: PUSH
51762: LD_INT 2
51764: PUSH
51765: LD_INT 30
51767: PUSH
51768: LD_INT 0
51770: PUSH
51771: EMPTY
51772: LIST
51773: LIST
51774: PUSH
51775: LD_INT 30
51777: PUSH
51778: LD_INT 1
51780: PUSH
51781: EMPTY
51782: LIST
51783: LIST
51784: PUSH
51785: EMPTY
51786: LIST
51787: LIST
51788: LIST
51789: PUSH
51790: EMPTY
51791: LIST
51792: LIST
51793: PPUSH
51794: CALL_OW 69
51798: ST_TO_ADDR
// if not depot then
51799: LD_VAR 0 1
51803: NOT
51804: IFFALSE 51808
// exit ;
51806: GO 51843
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
51808: LD_VAR 0 1
51812: PUSH
51813: LD_INT 1
51815: ARRAY
51816: PPUSH
51817: CALL_OW 250
51821: PPUSH
51822: LD_VAR 0 1
51826: PUSH
51827: LD_INT 1
51829: ARRAY
51830: PPUSH
51831: CALL_OW 251
51835: PPUSH
51836: LD_INT 70
51838: PPUSH
51839: CALL_OW 495
// end ;
51843: PPOPN 1
51845: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
51846: LD_EXP 93
51850: PUSH
51851: LD_EXP 127
51855: AND
51856: IFFALSE 52067
51858: GO 51860
51860: DISABLE
51861: LD_INT 0
51863: PPUSH
51864: PPUSH
51865: PPUSH
51866: PPUSH
51867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51868: LD_ADDR_VAR 0 5
51872: PUSH
51873: LD_INT 22
51875: PUSH
51876: LD_OWVAR 2
51880: PUSH
51881: EMPTY
51882: LIST
51883: LIST
51884: PUSH
51885: LD_INT 21
51887: PUSH
51888: LD_INT 1
51890: PUSH
51891: EMPTY
51892: LIST
51893: LIST
51894: PUSH
51895: EMPTY
51896: LIST
51897: LIST
51898: PPUSH
51899: CALL_OW 69
51903: ST_TO_ADDR
// if not tmp then
51904: LD_VAR 0 5
51908: NOT
51909: IFFALSE 51913
// exit ;
51911: GO 52067
// for i in tmp do
51913: LD_ADDR_VAR 0 1
51917: PUSH
51918: LD_VAR 0 5
51922: PUSH
51923: FOR_IN
51924: IFFALSE 52065
// begin d := rand ( 0 , 5 ) ;
51926: LD_ADDR_VAR 0 4
51930: PUSH
51931: LD_INT 0
51933: PPUSH
51934: LD_INT 5
51936: PPUSH
51937: CALL_OW 12
51941: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
51942: LD_ADDR_VAR 0 2
51946: PUSH
51947: LD_VAR 0 1
51951: PPUSH
51952: CALL_OW 250
51956: PPUSH
51957: LD_VAR 0 4
51961: PPUSH
51962: LD_INT 3
51964: PPUSH
51965: LD_INT 12
51967: PPUSH
51968: CALL_OW 12
51972: PPUSH
51973: CALL_OW 272
51977: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
51978: LD_ADDR_VAR 0 3
51982: PUSH
51983: LD_VAR 0 1
51987: PPUSH
51988: CALL_OW 251
51992: PPUSH
51993: LD_VAR 0 4
51997: PPUSH
51998: LD_INT 3
52000: PPUSH
52001: LD_INT 12
52003: PPUSH
52004: CALL_OW 12
52008: PPUSH
52009: CALL_OW 273
52013: ST_TO_ADDR
// if ValidHex ( x , y ) then
52014: LD_VAR 0 2
52018: PPUSH
52019: LD_VAR 0 3
52023: PPUSH
52024: CALL_OW 488
52028: IFFALSE 52063
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52030: LD_VAR 0 1
52034: PPUSH
52035: LD_VAR 0 2
52039: PPUSH
52040: LD_VAR 0 3
52044: PPUSH
52045: LD_INT 3
52047: PPUSH
52048: LD_INT 6
52050: PPUSH
52051: CALL_OW 12
52055: PPUSH
52056: LD_INT 1
52058: PPUSH
52059: CALL_OW 483
// end ;
52063: GO 51923
52065: POP
52066: POP
// end ;
52067: PPOPN 5
52069: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52070: LD_EXP 93
52074: PUSH
52075: LD_EXP 128
52079: AND
52080: IFFALSE 52174
52082: GO 52084
52084: DISABLE
52085: LD_INT 0
52087: PPUSH
52088: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52089: LD_ADDR_VAR 0 2
52093: PUSH
52094: LD_INT 22
52096: PUSH
52097: LD_OWVAR 2
52101: PUSH
52102: EMPTY
52103: LIST
52104: LIST
52105: PUSH
52106: LD_INT 32
52108: PUSH
52109: LD_INT 1
52111: PUSH
52112: EMPTY
52113: LIST
52114: LIST
52115: PUSH
52116: LD_INT 21
52118: PUSH
52119: LD_INT 2
52121: PUSH
52122: EMPTY
52123: LIST
52124: LIST
52125: PUSH
52126: EMPTY
52127: LIST
52128: LIST
52129: LIST
52130: PPUSH
52131: CALL_OW 69
52135: ST_TO_ADDR
// if not tmp then
52136: LD_VAR 0 2
52140: NOT
52141: IFFALSE 52145
// exit ;
52143: GO 52174
// for i in tmp do
52145: LD_ADDR_VAR 0 1
52149: PUSH
52150: LD_VAR 0 2
52154: PUSH
52155: FOR_IN
52156: IFFALSE 52172
// SetFuel ( i , 0 ) ;
52158: LD_VAR 0 1
52162: PPUSH
52163: LD_INT 0
52165: PPUSH
52166: CALL_OW 240
52170: GO 52155
52172: POP
52173: POP
// end ;
52174: PPOPN 2
52176: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52177: LD_EXP 93
52181: PUSH
52182: LD_EXP 129
52186: AND
52187: IFFALSE 52253
52189: GO 52191
52191: DISABLE
52192: LD_INT 0
52194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52195: LD_ADDR_VAR 0 1
52199: PUSH
52200: LD_INT 22
52202: PUSH
52203: LD_OWVAR 2
52207: PUSH
52208: EMPTY
52209: LIST
52210: LIST
52211: PUSH
52212: LD_INT 30
52214: PUSH
52215: LD_INT 29
52217: PUSH
52218: EMPTY
52219: LIST
52220: LIST
52221: PUSH
52222: EMPTY
52223: LIST
52224: LIST
52225: PPUSH
52226: CALL_OW 69
52230: ST_TO_ADDR
// if not tmp then
52231: LD_VAR 0 1
52235: NOT
52236: IFFALSE 52240
// exit ;
52238: GO 52253
// DestroyUnit ( tmp [ 1 ] ) ;
52240: LD_VAR 0 1
52244: PUSH
52245: LD_INT 1
52247: ARRAY
52248: PPUSH
52249: CALL_OW 65
// end ;
52253: PPOPN 1
52255: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52256: LD_EXP 93
52260: PUSH
52261: LD_EXP 131
52265: AND
52266: IFFALSE 52395
52268: GO 52270
52270: DISABLE
52271: LD_INT 0
52273: PPUSH
// begin uc_side := 0 ;
52274: LD_ADDR_OWVAR 20
52278: PUSH
52279: LD_INT 0
52281: ST_TO_ADDR
// uc_nation := nation_arabian ;
52282: LD_ADDR_OWVAR 21
52286: PUSH
52287: LD_INT 2
52289: ST_TO_ADDR
// hc_gallery :=  ;
52290: LD_ADDR_OWVAR 33
52294: PUSH
52295: LD_STRING 
52297: ST_TO_ADDR
// hc_name :=  ;
52298: LD_ADDR_OWVAR 26
52302: PUSH
52303: LD_STRING 
52305: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52306: LD_INT 1
52308: PPUSH
52309: LD_INT 11
52311: PPUSH
52312: LD_INT 10
52314: PPUSH
52315: CALL_OW 380
// un := CreateHuman ;
52319: LD_ADDR_VAR 0 1
52323: PUSH
52324: CALL_OW 44
52328: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52329: LD_VAR 0 1
52333: PPUSH
52334: LD_INT 1
52336: PPUSH
52337: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52341: LD_INT 35
52343: PPUSH
52344: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52348: LD_VAR 0 1
52352: PPUSH
52353: LD_INT 22
52355: PUSH
52356: LD_OWVAR 2
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: PPUSH
52365: CALL_OW 69
52369: PPUSH
52370: LD_VAR 0 1
52374: PPUSH
52375: CALL_OW 74
52379: PPUSH
52380: CALL_OW 115
// until IsDead ( un ) ;
52384: LD_VAR 0 1
52388: PPUSH
52389: CALL_OW 301
52393: IFFALSE 52341
// end ;
52395: PPOPN 1
52397: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52398: LD_EXP 93
52402: PUSH
52403: LD_EXP 133
52407: AND
52408: IFFALSE 52420
52410: GO 52412
52412: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52413: LD_STRING earthquake(getX(game), 0, 32)
52415: PPUSH
52416: CALL_OW 559
52420: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52421: LD_EXP 93
52425: PUSH
52426: LD_EXP 134
52430: AND
52431: IFFALSE 52522
52433: GO 52435
52435: DISABLE
52436: LD_INT 0
52438: PPUSH
// begin enable ;
52439: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52440: LD_ADDR_VAR 0 1
52444: PUSH
52445: LD_INT 22
52447: PUSH
52448: LD_OWVAR 2
52452: PUSH
52453: EMPTY
52454: LIST
52455: LIST
52456: PUSH
52457: LD_INT 21
52459: PUSH
52460: LD_INT 2
52462: PUSH
52463: EMPTY
52464: LIST
52465: LIST
52466: PUSH
52467: LD_INT 33
52469: PUSH
52470: LD_INT 3
52472: PUSH
52473: EMPTY
52474: LIST
52475: LIST
52476: PUSH
52477: EMPTY
52478: LIST
52479: LIST
52480: LIST
52481: PPUSH
52482: CALL_OW 69
52486: ST_TO_ADDR
// if not tmp then
52487: LD_VAR 0 1
52491: NOT
52492: IFFALSE 52496
// exit ;
52494: GO 52522
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52496: LD_VAR 0 1
52500: PUSH
52501: LD_INT 1
52503: PPUSH
52504: LD_VAR 0 1
52508: PPUSH
52509: CALL_OW 12
52513: ARRAY
52514: PPUSH
52515: LD_INT 1
52517: PPUSH
52518: CALL_OW 234
// end ;
52522: PPOPN 1
52524: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52525: LD_EXP 93
52529: PUSH
52530: LD_EXP 135
52534: AND
52535: IFFALSE 52676
52537: GO 52539
52539: DISABLE
52540: LD_INT 0
52542: PPUSH
52543: PPUSH
52544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52545: LD_ADDR_VAR 0 3
52549: PUSH
52550: LD_INT 22
52552: PUSH
52553: LD_OWVAR 2
52557: PUSH
52558: EMPTY
52559: LIST
52560: LIST
52561: PUSH
52562: LD_INT 25
52564: PUSH
52565: LD_INT 1
52567: PUSH
52568: EMPTY
52569: LIST
52570: LIST
52571: PUSH
52572: EMPTY
52573: LIST
52574: LIST
52575: PPUSH
52576: CALL_OW 69
52580: ST_TO_ADDR
// if not tmp then
52581: LD_VAR 0 3
52585: NOT
52586: IFFALSE 52590
// exit ;
52588: GO 52676
// un := tmp [ rand ( 1 , tmp ) ] ;
52590: LD_ADDR_VAR 0 2
52594: PUSH
52595: LD_VAR 0 3
52599: PUSH
52600: LD_INT 1
52602: PPUSH
52603: LD_VAR 0 3
52607: PPUSH
52608: CALL_OW 12
52612: ARRAY
52613: ST_TO_ADDR
// if Crawls ( un ) then
52614: LD_VAR 0 2
52618: PPUSH
52619: CALL_OW 318
52623: IFFALSE 52634
// ComWalk ( un ) ;
52625: LD_VAR 0 2
52629: PPUSH
52630: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52634: LD_VAR 0 2
52638: PPUSH
52639: LD_INT 9
52641: PPUSH
52642: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52646: LD_INT 28
52648: PPUSH
52649: LD_OWVAR 2
52653: PPUSH
52654: LD_INT 2
52656: PPUSH
52657: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52661: LD_INT 29
52663: PPUSH
52664: LD_OWVAR 2
52668: PPUSH
52669: LD_INT 2
52671: PPUSH
52672: CALL_OW 322
// end ;
52676: PPOPN 3
52678: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52679: LD_EXP 93
52683: PUSH
52684: LD_EXP 136
52688: AND
52689: IFFALSE 52800
52691: GO 52693
52693: DISABLE
52694: LD_INT 0
52696: PPUSH
52697: PPUSH
52698: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52699: LD_ADDR_VAR 0 3
52703: PUSH
52704: LD_INT 22
52706: PUSH
52707: LD_OWVAR 2
52711: PUSH
52712: EMPTY
52713: LIST
52714: LIST
52715: PUSH
52716: LD_INT 25
52718: PUSH
52719: LD_INT 1
52721: PUSH
52722: EMPTY
52723: LIST
52724: LIST
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: PPUSH
52730: CALL_OW 69
52734: ST_TO_ADDR
// if not tmp then
52735: LD_VAR 0 3
52739: NOT
52740: IFFALSE 52744
// exit ;
52742: GO 52800
// un := tmp [ rand ( 1 , tmp ) ] ;
52744: LD_ADDR_VAR 0 2
52748: PUSH
52749: LD_VAR 0 3
52753: PUSH
52754: LD_INT 1
52756: PPUSH
52757: LD_VAR 0 3
52761: PPUSH
52762: CALL_OW 12
52766: ARRAY
52767: ST_TO_ADDR
// if Crawls ( un ) then
52768: LD_VAR 0 2
52772: PPUSH
52773: CALL_OW 318
52777: IFFALSE 52788
// ComWalk ( un ) ;
52779: LD_VAR 0 2
52783: PPUSH
52784: CALL_OW 138
// SetClass ( un , class_mortar ) ;
52788: LD_VAR 0 2
52792: PPUSH
52793: LD_INT 8
52795: PPUSH
52796: CALL_OW 336
// end ;
52800: PPOPN 3
52802: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
52803: LD_EXP 93
52807: PUSH
52808: LD_EXP 137
52812: AND
52813: IFFALSE 52957
52815: GO 52817
52817: DISABLE
52818: LD_INT 0
52820: PPUSH
52821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
52822: LD_ADDR_VAR 0 2
52826: PUSH
52827: LD_INT 22
52829: PUSH
52830: LD_OWVAR 2
52834: PUSH
52835: EMPTY
52836: LIST
52837: LIST
52838: PUSH
52839: LD_INT 21
52841: PUSH
52842: LD_INT 2
52844: PUSH
52845: EMPTY
52846: LIST
52847: LIST
52848: PUSH
52849: LD_INT 2
52851: PUSH
52852: LD_INT 34
52854: PUSH
52855: LD_INT 12
52857: PUSH
52858: EMPTY
52859: LIST
52860: LIST
52861: PUSH
52862: LD_INT 34
52864: PUSH
52865: LD_INT 51
52867: PUSH
52868: EMPTY
52869: LIST
52870: LIST
52871: PUSH
52872: LD_INT 34
52874: PUSH
52875: LD_INT 32
52877: PUSH
52878: EMPTY
52879: LIST
52880: LIST
52881: PUSH
52882: EMPTY
52883: LIST
52884: LIST
52885: LIST
52886: LIST
52887: PUSH
52888: EMPTY
52889: LIST
52890: LIST
52891: LIST
52892: PPUSH
52893: CALL_OW 69
52897: ST_TO_ADDR
// if not tmp then
52898: LD_VAR 0 2
52902: NOT
52903: IFFALSE 52907
// exit ;
52905: GO 52957
// for i in tmp do
52907: LD_ADDR_VAR 0 1
52911: PUSH
52912: LD_VAR 0 2
52916: PUSH
52917: FOR_IN
52918: IFFALSE 52955
// if GetCargo ( i , mat_artifact ) = 0 then
52920: LD_VAR 0 1
52924: PPUSH
52925: LD_INT 4
52927: PPUSH
52928: CALL_OW 289
52932: PUSH
52933: LD_INT 0
52935: EQUAL
52936: IFFALSE 52953
// SetCargo ( i , mat_siberit , 100 ) ;
52938: LD_VAR 0 1
52942: PPUSH
52943: LD_INT 3
52945: PPUSH
52946: LD_INT 100
52948: PPUSH
52949: CALL_OW 290
52953: GO 52917
52955: POP
52956: POP
// end ;
52957: PPOPN 2
52959: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
52960: LD_EXP 93
52964: PUSH
52965: LD_EXP 138
52969: AND
52970: IFFALSE 53153
52972: GO 52974
52974: DISABLE
52975: LD_INT 0
52977: PPUSH
52978: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
52979: LD_ADDR_VAR 0 2
52983: PUSH
52984: LD_INT 22
52986: PUSH
52987: LD_OWVAR 2
52991: PUSH
52992: EMPTY
52993: LIST
52994: LIST
52995: PPUSH
52996: CALL_OW 69
53000: ST_TO_ADDR
// if not tmp then
53001: LD_VAR 0 2
53005: NOT
53006: IFFALSE 53010
// exit ;
53008: GO 53153
// for i := 1 to 2 do
53010: LD_ADDR_VAR 0 1
53014: PUSH
53015: DOUBLE
53016: LD_INT 1
53018: DEC
53019: ST_TO_ADDR
53020: LD_INT 2
53022: PUSH
53023: FOR_TO
53024: IFFALSE 53151
// begin uc_side := your_side ;
53026: LD_ADDR_OWVAR 20
53030: PUSH
53031: LD_OWVAR 2
53035: ST_TO_ADDR
// uc_nation := nation_american ;
53036: LD_ADDR_OWVAR 21
53040: PUSH
53041: LD_INT 1
53043: ST_TO_ADDR
// vc_chassis := us_morphling ;
53044: LD_ADDR_OWVAR 37
53048: PUSH
53049: LD_INT 5
53051: ST_TO_ADDR
// vc_engine := engine_siberite ;
53052: LD_ADDR_OWVAR 39
53056: PUSH
53057: LD_INT 3
53059: ST_TO_ADDR
// vc_control := control_computer ;
53060: LD_ADDR_OWVAR 38
53064: PUSH
53065: LD_INT 3
53067: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53068: LD_ADDR_OWVAR 40
53072: PUSH
53073: LD_INT 10
53075: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53076: LD_VAR 0 2
53080: PUSH
53081: LD_INT 1
53083: ARRAY
53084: PPUSH
53085: CALL_OW 310
53089: NOT
53090: IFFALSE 53137
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53092: CALL_OW 45
53096: PPUSH
53097: LD_VAR 0 2
53101: PUSH
53102: LD_INT 1
53104: ARRAY
53105: PPUSH
53106: CALL_OW 250
53110: PPUSH
53111: LD_VAR 0 2
53115: PUSH
53116: LD_INT 1
53118: ARRAY
53119: PPUSH
53120: CALL_OW 251
53124: PPUSH
53125: LD_INT 12
53127: PPUSH
53128: LD_INT 1
53130: PPUSH
53131: CALL_OW 50
53135: GO 53149
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53137: CALL_OW 45
53141: PPUSH
53142: LD_INT 1
53144: PPUSH
53145: CALL_OW 51
// end ;
53149: GO 53023
53151: POP
53152: POP
// end ;
53153: PPOPN 2
53155: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53156: LD_EXP 93
53160: PUSH
53161: LD_EXP 139
53165: AND
53166: IFFALSE 53388
53168: GO 53170
53170: DISABLE
53171: LD_INT 0
53173: PPUSH
53174: PPUSH
53175: PPUSH
53176: PPUSH
53177: PPUSH
53178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53179: LD_ADDR_VAR 0 6
53183: PUSH
53184: LD_INT 22
53186: PUSH
53187: LD_OWVAR 2
53191: PUSH
53192: EMPTY
53193: LIST
53194: LIST
53195: PUSH
53196: LD_INT 21
53198: PUSH
53199: LD_INT 1
53201: PUSH
53202: EMPTY
53203: LIST
53204: LIST
53205: PUSH
53206: LD_INT 3
53208: PUSH
53209: LD_INT 23
53211: PUSH
53212: LD_INT 0
53214: PUSH
53215: EMPTY
53216: LIST
53217: LIST
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: PUSH
53223: EMPTY
53224: LIST
53225: LIST
53226: LIST
53227: PPUSH
53228: CALL_OW 69
53232: ST_TO_ADDR
// if not tmp then
53233: LD_VAR 0 6
53237: NOT
53238: IFFALSE 53242
// exit ;
53240: GO 53388
// s1 := rand ( 1 , 4 ) ;
53242: LD_ADDR_VAR 0 2
53246: PUSH
53247: LD_INT 1
53249: PPUSH
53250: LD_INT 4
53252: PPUSH
53253: CALL_OW 12
53257: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53258: LD_ADDR_VAR 0 4
53262: PUSH
53263: LD_VAR 0 6
53267: PUSH
53268: LD_INT 1
53270: ARRAY
53271: PPUSH
53272: LD_VAR 0 2
53276: PPUSH
53277: CALL_OW 259
53281: ST_TO_ADDR
// if s1 = 1 then
53282: LD_VAR 0 2
53286: PUSH
53287: LD_INT 1
53289: EQUAL
53290: IFFALSE 53310
// s2 := rand ( 2 , 4 ) else
53292: LD_ADDR_VAR 0 3
53296: PUSH
53297: LD_INT 2
53299: PPUSH
53300: LD_INT 4
53302: PPUSH
53303: CALL_OW 12
53307: ST_TO_ADDR
53308: GO 53318
// s2 := 1 ;
53310: LD_ADDR_VAR 0 3
53314: PUSH
53315: LD_INT 1
53317: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53318: LD_ADDR_VAR 0 5
53322: PUSH
53323: LD_VAR 0 6
53327: PUSH
53328: LD_INT 1
53330: ARRAY
53331: PPUSH
53332: LD_VAR 0 3
53336: PPUSH
53337: CALL_OW 259
53341: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53342: LD_VAR 0 6
53346: PUSH
53347: LD_INT 1
53349: ARRAY
53350: PPUSH
53351: LD_VAR 0 2
53355: PPUSH
53356: LD_VAR 0 5
53360: PPUSH
53361: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53365: LD_VAR 0 6
53369: PUSH
53370: LD_INT 1
53372: ARRAY
53373: PPUSH
53374: LD_VAR 0 3
53378: PPUSH
53379: LD_VAR 0 4
53383: PPUSH
53384: CALL_OW 237
// end ;
53388: PPOPN 6
53390: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53391: LD_EXP 93
53395: PUSH
53396: LD_EXP 140
53400: AND
53401: IFFALSE 53480
53403: GO 53405
53405: DISABLE
53406: LD_INT 0
53408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53409: LD_ADDR_VAR 0 1
53413: PUSH
53414: LD_INT 22
53416: PUSH
53417: LD_OWVAR 2
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: PUSH
53426: LD_INT 30
53428: PUSH
53429: LD_INT 3
53431: PUSH
53432: EMPTY
53433: LIST
53434: LIST
53435: PUSH
53436: EMPTY
53437: LIST
53438: LIST
53439: PPUSH
53440: CALL_OW 69
53444: ST_TO_ADDR
// if not tmp then
53445: LD_VAR 0 1
53449: NOT
53450: IFFALSE 53454
// exit ;
53452: GO 53480
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53454: LD_VAR 0 1
53458: PUSH
53459: LD_INT 1
53461: PPUSH
53462: LD_VAR 0 1
53466: PPUSH
53467: CALL_OW 12
53471: ARRAY
53472: PPUSH
53473: LD_INT 1
53475: PPUSH
53476: CALL_OW 234
// end ;
53480: PPOPN 1
53482: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53483: LD_EXP 93
53487: PUSH
53488: LD_EXP 141
53492: AND
53493: IFFALSE 53605
53495: GO 53497
53497: DISABLE
53498: LD_INT 0
53500: PPUSH
53501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53502: LD_ADDR_VAR 0 2
53506: PUSH
53507: LD_INT 22
53509: PUSH
53510: LD_OWVAR 2
53514: PUSH
53515: EMPTY
53516: LIST
53517: LIST
53518: PUSH
53519: LD_INT 2
53521: PUSH
53522: LD_INT 30
53524: PUSH
53525: LD_INT 27
53527: PUSH
53528: EMPTY
53529: LIST
53530: LIST
53531: PUSH
53532: LD_INT 30
53534: PUSH
53535: LD_INT 26
53537: PUSH
53538: EMPTY
53539: LIST
53540: LIST
53541: PUSH
53542: LD_INT 30
53544: PUSH
53545: LD_INT 28
53547: PUSH
53548: EMPTY
53549: LIST
53550: LIST
53551: PUSH
53552: EMPTY
53553: LIST
53554: LIST
53555: LIST
53556: LIST
53557: PUSH
53558: EMPTY
53559: LIST
53560: LIST
53561: PPUSH
53562: CALL_OW 69
53566: ST_TO_ADDR
// if not tmp then
53567: LD_VAR 0 2
53571: NOT
53572: IFFALSE 53576
// exit ;
53574: GO 53605
// for i in tmp do
53576: LD_ADDR_VAR 0 1
53580: PUSH
53581: LD_VAR 0 2
53585: PUSH
53586: FOR_IN
53587: IFFALSE 53603
// SetLives ( i , 1 ) ;
53589: LD_VAR 0 1
53593: PPUSH
53594: LD_INT 1
53596: PPUSH
53597: CALL_OW 234
53601: GO 53586
53603: POP
53604: POP
// end ;
53605: PPOPN 2
53607: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53608: LD_EXP 93
53612: PUSH
53613: LD_EXP 142
53617: AND
53618: IFFALSE 53892
53620: GO 53622
53622: DISABLE
53623: LD_INT 0
53625: PPUSH
53626: PPUSH
53627: PPUSH
// begin i := rand ( 1 , 7 ) ;
53628: LD_ADDR_VAR 0 1
53632: PUSH
53633: LD_INT 1
53635: PPUSH
53636: LD_INT 7
53638: PPUSH
53639: CALL_OW 12
53643: ST_TO_ADDR
// case i of 1 :
53644: LD_VAR 0 1
53648: PUSH
53649: LD_INT 1
53651: DOUBLE
53652: EQUAL
53653: IFTRUE 53657
53655: GO 53667
53657: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53658: LD_STRING earthquake(getX(game), 0, 32)
53660: PPUSH
53661: CALL_OW 559
53665: GO 53892
53667: LD_INT 2
53669: DOUBLE
53670: EQUAL
53671: IFTRUE 53675
53673: GO 53689
53675: POP
// begin ToLua ( displayStucuk(); ) ;
53676: LD_STRING displayStucuk();
53678: PPUSH
53679: CALL_OW 559
// ResetFog ;
53683: CALL_OW 335
// end ; 3 :
53687: GO 53892
53689: LD_INT 3
53691: DOUBLE
53692: EQUAL
53693: IFTRUE 53697
53695: GO 53801
53697: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53698: LD_ADDR_VAR 0 2
53702: PUSH
53703: LD_INT 22
53705: PUSH
53706: LD_OWVAR 2
53710: PUSH
53711: EMPTY
53712: LIST
53713: LIST
53714: PUSH
53715: LD_INT 25
53717: PUSH
53718: LD_INT 1
53720: PUSH
53721: EMPTY
53722: LIST
53723: LIST
53724: PUSH
53725: EMPTY
53726: LIST
53727: LIST
53728: PPUSH
53729: CALL_OW 69
53733: ST_TO_ADDR
// if not tmp then
53734: LD_VAR 0 2
53738: NOT
53739: IFFALSE 53743
// exit ;
53741: GO 53892
// un := tmp [ rand ( 1 , tmp ) ] ;
53743: LD_ADDR_VAR 0 3
53747: PUSH
53748: LD_VAR 0 2
53752: PUSH
53753: LD_INT 1
53755: PPUSH
53756: LD_VAR 0 2
53760: PPUSH
53761: CALL_OW 12
53765: ARRAY
53766: ST_TO_ADDR
// if Crawls ( un ) then
53767: LD_VAR 0 3
53771: PPUSH
53772: CALL_OW 318
53776: IFFALSE 53787
// ComWalk ( un ) ;
53778: LD_VAR 0 3
53782: PPUSH
53783: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53787: LD_VAR 0 3
53791: PPUSH
53792: LD_INT 8
53794: PPUSH
53795: CALL_OW 336
// end ; 4 :
53799: GO 53892
53801: LD_INT 4
53803: DOUBLE
53804: EQUAL
53805: IFTRUE 53809
53807: GO 53870
53809: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53810: LD_ADDR_VAR 0 2
53814: PUSH
53815: LD_INT 22
53817: PUSH
53818: LD_OWVAR 2
53822: PUSH
53823: EMPTY
53824: LIST
53825: LIST
53826: PUSH
53827: LD_INT 30
53829: PUSH
53830: LD_INT 29
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: PUSH
53837: EMPTY
53838: LIST
53839: LIST
53840: PPUSH
53841: CALL_OW 69
53845: ST_TO_ADDR
// if not tmp then
53846: LD_VAR 0 2
53850: NOT
53851: IFFALSE 53855
// exit ;
53853: GO 53892
// DestroyUnit ( tmp [ 1 ] ) ;
53855: LD_VAR 0 2
53859: PUSH
53860: LD_INT 1
53862: ARRAY
53863: PPUSH
53864: CALL_OW 65
// end ; 5 .. 7 :
53868: GO 53892
53870: LD_INT 5
53872: DOUBLE
53873: GREATEREQUAL
53874: IFFALSE 53882
53876: LD_INT 7
53878: DOUBLE
53879: LESSEQUAL
53880: IFTRUE 53884
53882: GO 53891
53884: POP
// StreamSibBomb ; end ;
53885: CALL 50142 0 0
53889: GO 53892
53891: POP
// end ;
53892: PPOPN 3
53894: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
53895: LD_EXP 93
53899: PUSH
53900: LD_EXP 143
53904: AND
53905: IFFALSE 54061
53907: GO 53909
53909: DISABLE
53910: LD_INT 0
53912: PPUSH
53913: PPUSH
53914: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
53915: LD_ADDR_VAR 0 2
53919: PUSH
53920: LD_INT 81
53922: PUSH
53923: LD_OWVAR 2
53927: PUSH
53928: EMPTY
53929: LIST
53930: LIST
53931: PUSH
53932: LD_INT 2
53934: PUSH
53935: LD_INT 21
53937: PUSH
53938: LD_INT 1
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: PUSH
53945: LD_INT 21
53947: PUSH
53948: LD_INT 2
53950: PUSH
53951: EMPTY
53952: LIST
53953: LIST
53954: PUSH
53955: EMPTY
53956: LIST
53957: LIST
53958: LIST
53959: PUSH
53960: EMPTY
53961: LIST
53962: LIST
53963: PPUSH
53964: CALL_OW 69
53968: ST_TO_ADDR
// if not tmp then
53969: LD_VAR 0 2
53973: NOT
53974: IFFALSE 53978
// exit ;
53976: GO 54061
// p := 0 ;
53978: LD_ADDR_VAR 0 3
53982: PUSH
53983: LD_INT 0
53985: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53986: LD_INT 35
53988: PPUSH
53989: CALL_OW 67
// p := p + 1 ;
53993: LD_ADDR_VAR 0 3
53997: PUSH
53998: LD_VAR 0 3
54002: PUSH
54003: LD_INT 1
54005: PLUS
54006: ST_TO_ADDR
// for i in tmp do
54007: LD_ADDR_VAR 0 1
54011: PUSH
54012: LD_VAR 0 2
54016: PUSH
54017: FOR_IN
54018: IFFALSE 54049
// if GetLives ( i ) < 1000 then
54020: LD_VAR 0 1
54024: PPUSH
54025: CALL_OW 256
54029: PUSH
54030: LD_INT 1000
54032: LESS
54033: IFFALSE 54047
// SetLives ( i , 1000 ) ;
54035: LD_VAR 0 1
54039: PPUSH
54040: LD_INT 1000
54042: PPUSH
54043: CALL_OW 234
54047: GO 54017
54049: POP
54050: POP
// until p > 20 ;
54051: LD_VAR 0 3
54055: PUSH
54056: LD_INT 20
54058: GREATER
54059: IFFALSE 53986
// end ;
54061: PPOPN 3
54063: END
// every 0 0$1 trigger StreamModeActive and sTime do
54064: LD_EXP 93
54068: PUSH
54069: LD_EXP 144
54073: AND
54074: IFFALSE 54109
54076: GO 54078
54078: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54079: LD_INT 28
54081: PPUSH
54082: LD_OWVAR 2
54086: PPUSH
54087: LD_INT 2
54089: PPUSH
54090: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54094: LD_INT 30
54096: PPUSH
54097: LD_OWVAR 2
54101: PPUSH
54102: LD_INT 2
54104: PPUSH
54105: CALL_OW 322
// end ;
54109: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54110: LD_EXP 93
54114: PUSH
54115: LD_EXP 145
54119: AND
54120: IFFALSE 54241
54122: GO 54124
54124: DISABLE
54125: LD_INT 0
54127: PPUSH
54128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54129: LD_ADDR_VAR 0 2
54133: PUSH
54134: LD_INT 22
54136: PUSH
54137: LD_OWVAR 2
54141: PUSH
54142: EMPTY
54143: LIST
54144: LIST
54145: PUSH
54146: LD_INT 21
54148: PUSH
54149: LD_INT 1
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: PUSH
54156: LD_INT 3
54158: PUSH
54159: LD_INT 23
54161: PUSH
54162: LD_INT 0
54164: PUSH
54165: EMPTY
54166: LIST
54167: LIST
54168: PUSH
54169: EMPTY
54170: LIST
54171: LIST
54172: PUSH
54173: EMPTY
54174: LIST
54175: LIST
54176: LIST
54177: PPUSH
54178: CALL_OW 69
54182: ST_TO_ADDR
// if not tmp then
54183: LD_VAR 0 2
54187: NOT
54188: IFFALSE 54192
// exit ;
54190: GO 54241
// for i in tmp do
54192: LD_ADDR_VAR 0 1
54196: PUSH
54197: LD_VAR 0 2
54201: PUSH
54202: FOR_IN
54203: IFFALSE 54239
// begin if Crawls ( i ) then
54205: LD_VAR 0 1
54209: PPUSH
54210: CALL_OW 318
54214: IFFALSE 54225
// ComWalk ( i ) ;
54216: LD_VAR 0 1
54220: PPUSH
54221: CALL_OW 138
// SetClass ( i , 2 ) ;
54225: LD_VAR 0 1
54229: PPUSH
54230: LD_INT 2
54232: PPUSH
54233: CALL_OW 336
// end ;
54237: GO 54202
54239: POP
54240: POP
// end ;
54241: PPOPN 2
54243: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54244: LD_EXP 93
54248: PUSH
54249: LD_EXP 146
54253: AND
54254: IFFALSE 54535
54256: GO 54258
54258: DISABLE
54259: LD_INT 0
54261: PPUSH
54262: PPUSH
54263: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54264: LD_OWVAR 2
54268: PPUSH
54269: LD_INT 9
54271: PPUSH
54272: LD_INT 1
54274: PPUSH
54275: LD_INT 1
54277: PPUSH
54278: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54282: LD_INT 9
54284: PPUSH
54285: LD_OWVAR 2
54289: PPUSH
54290: CALL_OW 343
// uc_side := 9 ;
54294: LD_ADDR_OWVAR 20
54298: PUSH
54299: LD_INT 9
54301: ST_TO_ADDR
// uc_nation := 2 ;
54302: LD_ADDR_OWVAR 21
54306: PUSH
54307: LD_INT 2
54309: ST_TO_ADDR
// hc_name := Dark Warrior ;
54310: LD_ADDR_OWVAR 26
54314: PUSH
54315: LD_STRING Dark Warrior
54317: ST_TO_ADDR
// hc_gallery :=  ;
54318: LD_ADDR_OWVAR 33
54322: PUSH
54323: LD_STRING 
54325: ST_TO_ADDR
// hc_noskilllimit := true ;
54326: LD_ADDR_OWVAR 76
54330: PUSH
54331: LD_INT 1
54333: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54334: LD_ADDR_OWVAR 31
54338: PUSH
54339: LD_INT 30
54341: PUSH
54342: LD_INT 30
54344: PUSH
54345: LD_INT 30
54347: PUSH
54348: LD_INT 30
54350: PUSH
54351: EMPTY
54352: LIST
54353: LIST
54354: LIST
54355: LIST
54356: ST_TO_ADDR
// un := CreateHuman ;
54357: LD_ADDR_VAR 0 3
54361: PUSH
54362: CALL_OW 44
54366: ST_TO_ADDR
// hc_noskilllimit := false ;
54367: LD_ADDR_OWVAR 76
54371: PUSH
54372: LD_INT 0
54374: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54375: LD_VAR 0 3
54379: PPUSH
54380: LD_INT 1
54382: PPUSH
54383: CALL_OW 51
// p := 0 ;
54387: LD_ADDR_VAR 0 2
54391: PUSH
54392: LD_INT 0
54394: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54395: LD_INT 35
54397: PPUSH
54398: CALL_OW 67
// p := p + 1 ;
54402: LD_ADDR_VAR 0 2
54406: PUSH
54407: LD_VAR 0 2
54411: PUSH
54412: LD_INT 1
54414: PLUS
54415: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54416: LD_VAR 0 3
54420: PPUSH
54421: CALL_OW 256
54425: PUSH
54426: LD_INT 1000
54428: LESS
54429: IFFALSE 54443
// SetLives ( un , 1000 ) ;
54431: LD_VAR 0 3
54435: PPUSH
54436: LD_INT 1000
54438: PPUSH
54439: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54443: LD_VAR 0 3
54447: PPUSH
54448: LD_INT 81
54450: PUSH
54451: LD_OWVAR 2
54455: PUSH
54456: EMPTY
54457: LIST
54458: LIST
54459: PUSH
54460: LD_INT 91
54462: PUSH
54463: LD_VAR 0 3
54467: PUSH
54468: LD_INT 30
54470: PUSH
54471: EMPTY
54472: LIST
54473: LIST
54474: LIST
54475: PUSH
54476: EMPTY
54477: LIST
54478: LIST
54479: PPUSH
54480: CALL_OW 69
54484: PPUSH
54485: LD_VAR 0 3
54489: PPUSH
54490: CALL_OW 74
54494: PPUSH
54495: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54499: LD_VAR 0 2
54503: PUSH
54504: LD_INT 60
54506: GREATER
54507: PUSH
54508: LD_VAR 0 3
54512: PPUSH
54513: CALL_OW 301
54517: OR
54518: IFFALSE 54395
// if un then
54520: LD_VAR 0 3
54524: IFFALSE 54535
// RemoveUnit ( un ) ;
54526: LD_VAR 0 3
54530: PPUSH
54531: CALL_OW 64
// end ;
54535: PPOPN 3
54537: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
54538: LD_INT 0
54540: PPUSH
// case cmd of 301 :
54541: LD_VAR 0 1
54545: PUSH
54546: LD_INT 301
54548: DOUBLE
54549: EQUAL
54550: IFTRUE 54554
54552: GO 54586
54554: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
54555: LD_VAR 0 6
54559: PPUSH
54560: LD_VAR 0 7
54564: PPUSH
54565: LD_VAR 0 8
54569: PPUSH
54570: LD_VAR 0 4
54574: PPUSH
54575: LD_VAR 0 5
54579: PPUSH
54580: CALL 55787 0 5
54584: GO 54707
54586: LD_INT 302
54588: DOUBLE
54589: EQUAL
54590: IFTRUE 54594
54592: GO 54631
54594: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
54595: LD_VAR 0 6
54599: PPUSH
54600: LD_VAR 0 7
54604: PPUSH
54605: LD_VAR 0 8
54609: PPUSH
54610: LD_VAR 0 9
54614: PPUSH
54615: LD_VAR 0 4
54619: PPUSH
54620: LD_VAR 0 5
54624: PPUSH
54625: CALL 55878 0 6
54629: GO 54707
54631: LD_INT 303
54633: DOUBLE
54634: EQUAL
54635: IFTRUE 54639
54637: GO 54676
54639: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
54640: LD_VAR 0 6
54644: PPUSH
54645: LD_VAR 0 7
54649: PPUSH
54650: LD_VAR 0 8
54654: PPUSH
54655: LD_VAR 0 9
54659: PPUSH
54660: LD_VAR 0 4
54664: PPUSH
54665: LD_VAR 0 5
54669: PPUSH
54670: CALL 54712 0 6
54674: GO 54707
54676: LD_INT 304
54678: DOUBLE
54679: EQUAL
54680: IFTRUE 54684
54682: GO 54706
54684: POP
// hHackTeleport ( unit , x , y ) ; end ;
54685: LD_VAR 0 2
54689: PPUSH
54690: LD_VAR 0 4
54694: PPUSH
54695: LD_VAR 0 5
54699: PPUSH
54700: CALL 56471 0 3
54704: GO 54707
54706: POP
// end ;
54707: LD_VAR 0 12
54711: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
54712: LD_INT 0
54714: PPUSH
54715: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
54716: LD_VAR 0 1
54720: PUSH
54721: LD_INT 1
54723: LESS
54724: PUSH
54725: LD_VAR 0 1
54729: PUSH
54730: LD_INT 3
54732: GREATER
54733: OR
54734: PUSH
54735: LD_VAR 0 5
54739: PPUSH
54740: LD_VAR 0 6
54744: PPUSH
54745: CALL_OW 428
54749: OR
54750: IFFALSE 54754
// exit ;
54752: GO 55474
// uc_side := your_side ;
54754: LD_ADDR_OWVAR 20
54758: PUSH
54759: LD_OWVAR 2
54763: ST_TO_ADDR
// uc_nation := nation ;
54764: LD_ADDR_OWVAR 21
54768: PUSH
54769: LD_VAR 0 1
54773: ST_TO_ADDR
// bc_level = 1 ;
54774: LD_ADDR_OWVAR 43
54778: PUSH
54779: LD_INT 1
54781: ST_TO_ADDR
// case btype of 1 :
54782: LD_VAR 0 2
54786: PUSH
54787: LD_INT 1
54789: DOUBLE
54790: EQUAL
54791: IFTRUE 54795
54793: GO 54806
54795: POP
// bc_type := b_depot ; 2 :
54796: LD_ADDR_OWVAR 42
54800: PUSH
54801: LD_INT 0
54803: ST_TO_ADDR
54804: GO 55418
54806: LD_INT 2
54808: DOUBLE
54809: EQUAL
54810: IFTRUE 54814
54812: GO 54825
54814: POP
// bc_type := b_warehouse ; 3 :
54815: LD_ADDR_OWVAR 42
54819: PUSH
54820: LD_INT 1
54822: ST_TO_ADDR
54823: GO 55418
54825: LD_INT 3
54827: DOUBLE
54828: EQUAL
54829: IFTRUE 54833
54831: GO 54844
54833: POP
// bc_type := b_lab ; 4 .. 9 :
54834: LD_ADDR_OWVAR 42
54838: PUSH
54839: LD_INT 6
54841: ST_TO_ADDR
54842: GO 55418
54844: LD_INT 4
54846: DOUBLE
54847: GREATEREQUAL
54848: IFFALSE 54856
54850: LD_INT 9
54852: DOUBLE
54853: LESSEQUAL
54854: IFTRUE 54858
54856: GO 54910
54858: POP
// begin bc_type := b_lab_half ;
54859: LD_ADDR_OWVAR 42
54863: PUSH
54864: LD_INT 7
54866: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
54867: LD_ADDR_OWVAR 44
54871: PUSH
54872: LD_INT 10
54874: PUSH
54875: LD_INT 11
54877: PUSH
54878: LD_INT 12
54880: PUSH
54881: LD_INT 15
54883: PUSH
54884: LD_INT 14
54886: PUSH
54887: LD_INT 13
54889: PUSH
54890: EMPTY
54891: LIST
54892: LIST
54893: LIST
54894: LIST
54895: LIST
54896: LIST
54897: PUSH
54898: LD_VAR 0 2
54902: PUSH
54903: LD_INT 3
54905: MINUS
54906: ARRAY
54907: ST_TO_ADDR
// end ; 10 .. 13 :
54908: GO 55418
54910: LD_INT 10
54912: DOUBLE
54913: GREATEREQUAL
54914: IFFALSE 54922
54916: LD_INT 13
54918: DOUBLE
54919: LESSEQUAL
54920: IFTRUE 54924
54922: GO 55001
54924: POP
// begin bc_type := b_lab_full ;
54925: LD_ADDR_OWVAR 42
54929: PUSH
54930: LD_INT 8
54932: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
54933: LD_ADDR_OWVAR 44
54937: PUSH
54938: LD_INT 10
54940: PUSH
54941: LD_INT 12
54943: PUSH
54944: LD_INT 14
54946: PUSH
54947: LD_INT 13
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: LIST
54954: LIST
54955: PUSH
54956: LD_VAR 0 2
54960: PUSH
54961: LD_INT 9
54963: MINUS
54964: ARRAY
54965: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
54966: LD_ADDR_OWVAR 45
54970: PUSH
54971: LD_INT 11
54973: PUSH
54974: LD_INT 15
54976: PUSH
54977: LD_INT 12
54979: PUSH
54980: LD_INT 15
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: LIST
54987: LIST
54988: PUSH
54989: LD_VAR 0 2
54993: PUSH
54994: LD_INT 9
54996: MINUS
54997: ARRAY
54998: ST_TO_ADDR
// end ; 14 :
54999: GO 55418
55001: LD_INT 14
55003: DOUBLE
55004: EQUAL
55005: IFTRUE 55009
55007: GO 55020
55009: POP
// bc_type := b_workshop ; 15 :
55010: LD_ADDR_OWVAR 42
55014: PUSH
55015: LD_INT 2
55017: ST_TO_ADDR
55018: GO 55418
55020: LD_INT 15
55022: DOUBLE
55023: EQUAL
55024: IFTRUE 55028
55026: GO 55039
55028: POP
// bc_type := b_factory ; 16 :
55029: LD_ADDR_OWVAR 42
55033: PUSH
55034: LD_INT 3
55036: ST_TO_ADDR
55037: GO 55418
55039: LD_INT 16
55041: DOUBLE
55042: EQUAL
55043: IFTRUE 55047
55045: GO 55058
55047: POP
// bc_type := b_ext_gun ; 17 :
55048: LD_ADDR_OWVAR 42
55052: PUSH
55053: LD_INT 17
55055: ST_TO_ADDR
55056: GO 55418
55058: LD_INT 17
55060: DOUBLE
55061: EQUAL
55062: IFTRUE 55066
55064: GO 55094
55066: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
55067: LD_ADDR_OWVAR 42
55071: PUSH
55072: LD_INT 19
55074: PUSH
55075: LD_INT 23
55077: PUSH
55078: LD_INT 19
55080: PUSH
55081: EMPTY
55082: LIST
55083: LIST
55084: LIST
55085: PUSH
55086: LD_VAR 0 1
55090: ARRAY
55091: ST_TO_ADDR
55092: GO 55418
55094: LD_INT 18
55096: DOUBLE
55097: EQUAL
55098: IFTRUE 55102
55100: GO 55113
55102: POP
// bc_type := b_ext_radar ; 19 :
55103: LD_ADDR_OWVAR 42
55107: PUSH
55108: LD_INT 20
55110: ST_TO_ADDR
55111: GO 55418
55113: LD_INT 19
55115: DOUBLE
55116: EQUAL
55117: IFTRUE 55121
55119: GO 55132
55121: POP
// bc_type := b_ext_radio ; 20 :
55122: LD_ADDR_OWVAR 42
55126: PUSH
55127: LD_INT 22
55129: ST_TO_ADDR
55130: GO 55418
55132: LD_INT 20
55134: DOUBLE
55135: EQUAL
55136: IFTRUE 55140
55138: GO 55151
55140: POP
// bc_type := b_ext_siberium ; 21 :
55141: LD_ADDR_OWVAR 42
55145: PUSH
55146: LD_INT 21
55148: ST_TO_ADDR
55149: GO 55418
55151: LD_INT 21
55153: DOUBLE
55154: EQUAL
55155: IFTRUE 55159
55157: GO 55170
55159: POP
// bc_type := b_ext_computer ; 22 :
55160: LD_ADDR_OWVAR 42
55164: PUSH
55165: LD_INT 24
55167: ST_TO_ADDR
55168: GO 55418
55170: LD_INT 22
55172: DOUBLE
55173: EQUAL
55174: IFTRUE 55178
55176: GO 55189
55178: POP
// bc_type := b_ext_track ; 23 :
55179: LD_ADDR_OWVAR 42
55183: PUSH
55184: LD_INT 16
55186: ST_TO_ADDR
55187: GO 55418
55189: LD_INT 23
55191: DOUBLE
55192: EQUAL
55193: IFTRUE 55197
55195: GO 55208
55197: POP
// bc_type := b_ext_laser ; 24 :
55198: LD_ADDR_OWVAR 42
55202: PUSH
55203: LD_INT 25
55205: ST_TO_ADDR
55206: GO 55418
55208: LD_INT 24
55210: DOUBLE
55211: EQUAL
55212: IFTRUE 55216
55214: GO 55227
55216: POP
// bc_type := b_control_tower ; 25 :
55217: LD_ADDR_OWVAR 42
55221: PUSH
55222: LD_INT 36
55224: ST_TO_ADDR
55225: GO 55418
55227: LD_INT 25
55229: DOUBLE
55230: EQUAL
55231: IFTRUE 55235
55233: GO 55246
55235: POP
// bc_type := b_breastwork ; 26 :
55236: LD_ADDR_OWVAR 42
55240: PUSH
55241: LD_INT 31
55243: ST_TO_ADDR
55244: GO 55418
55246: LD_INT 26
55248: DOUBLE
55249: EQUAL
55250: IFTRUE 55254
55252: GO 55265
55254: POP
// bc_type := b_bunker ; 27 :
55255: LD_ADDR_OWVAR 42
55259: PUSH
55260: LD_INT 32
55262: ST_TO_ADDR
55263: GO 55418
55265: LD_INT 27
55267: DOUBLE
55268: EQUAL
55269: IFTRUE 55273
55271: GO 55284
55273: POP
// bc_type := b_turret ; 28 :
55274: LD_ADDR_OWVAR 42
55278: PUSH
55279: LD_INT 33
55281: ST_TO_ADDR
55282: GO 55418
55284: LD_INT 28
55286: DOUBLE
55287: EQUAL
55288: IFTRUE 55292
55290: GO 55303
55292: POP
// bc_type := b_armoury ; 29 :
55293: LD_ADDR_OWVAR 42
55297: PUSH
55298: LD_INT 4
55300: ST_TO_ADDR
55301: GO 55418
55303: LD_INT 29
55305: DOUBLE
55306: EQUAL
55307: IFTRUE 55311
55309: GO 55322
55311: POP
// bc_type := b_barracks ; 30 :
55312: LD_ADDR_OWVAR 42
55316: PUSH
55317: LD_INT 5
55319: ST_TO_ADDR
55320: GO 55418
55322: LD_INT 30
55324: DOUBLE
55325: EQUAL
55326: IFTRUE 55330
55328: GO 55341
55330: POP
// bc_type := b_solar_power ; 31 :
55331: LD_ADDR_OWVAR 42
55335: PUSH
55336: LD_INT 27
55338: ST_TO_ADDR
55339: GO 55418
55341: LD_INT 31
55343: DOUBLE
55344: EQUAL
55345: IFTRUE 55349
55347: GO 55360
55349: POP
// bc_type := b_oil_power ; 32 :
55350: LD_ADDR_OWVAR 42
55354: PUSH
55355: LD_INT 26
55357: ST_TO_ADDR
55358: GO 55418
55360: LD_INT 32
55362: DOUBLE
55363: EQUAL
55364: IFTRUE 55368
55366: GO 55379
55368: POP
// bc_type := b_siberite_power ; 33 :
55369: LD_ADDR_OWVAR 42
55373: PUSH
55374: LD_INT 28
55376: ST_TO_ADDR
55377: GO 55418
55379: LD_INT 33
55381: DOUBLE
55382: EQUAL
55383: IFTRUE 55387
55385: GO 55398
55387: POP
// bc_type := b_oil_mine ; 34 :
55388: LD_ADDR_OWVAR 42
55392: PUSH
55393: LD_INT 29
55395: ST_TO_ADDR
55396: GO 55418
55398: LD_INT 34
55400: DOUBLE
55401: EQUAL
55402: IFTRUE 55406
55404: GO 55417
55406: POP
// bc_type := b_siberite_mine ; end ;
55407: LD_ADDR_OWVAR 42
55411: PUSH
55412: LD_INT 30
55414: ST_TO_ADDR
55415: GO 55418
55417: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
55418: LD_ADDR_VAR 0 8
55422: PUSH
55423: LD_VAR 0 5
55427: PPUSH
55428: LD_VAR 0 6
55432: PPUSH
55433: LD_VAR 0 3
55437: PPUSH
55438: CALL_OW 47
55442: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
55443: LD_OWVAR 42
55447: PUSH
55448: LD_INT 32
55450: PUSH
55451: LD_INT 33
55453: PUSH
55454: EMPTY
55455: LIST
55456: LIST
55457: IN
55458: IFFALSE 55474
// PlaceWeaponTurret ( b , weapon ) ;
55460: LD_VAR 0 8
55464: PPUSH
55465: LD_VAR 0 4
55469: PPUSH
55470: CALL_OW 431
// end ;
55474: LD_VAR 0 7
55478: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
55479: LD_INT 0
55481: PPUSH
55482: PPUSH
55483: PPUSH
55484: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
55485: LD_ADDR_VAR 0 4
55489: PUSH
55490: LD_INT 22
55492: PUSH
55493: LD_OWVAR 2
55497: PUSH
55498: EMPTY
55499: LIST
55500: LIST
55501: PUSH
55502: LD_INT 2
55504: PUSH
55505: LD_INT 30
55507: PUSH
55508: LD_INT 0
55510: PUSH
55511: EMPTY
55512: LIST
55513: LIST
55514: PUSH
55515: LD_INT 30
55517: PUSH
55518: LD_INT 1
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: LIST
55529: PUSH
55530: EMPTY
55531: LIST
55532: LIST
55533: PPUSH
55534: CALL_OW 69
55538: ST_TO_ADDR
// if not tmp then
55539: LD_VAR 0 4
55543: NOT
55544: IFFALSE 55548
// exit ;
55546: GO 55607
// for i in tmp do
55548: LD_ADDR_VAR 0 2
55552: PUSH
55553: LD_VAR 0 4
55557: PUSH
55558: FOR_IN
55559: IFFALSE 55605
// for j = 1 to 3 do
55561: LD_ADDR_VAR 0 3
55565: PUSH
55566: DOUBLE
55567: LD_INT 1
55569: DEC
55570: ST_TO_ADDR
55571: LD_INT 3
55573: PUSH
55574: FOR_TO
55575: IFFALSE 55601
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
55577: LD_VAR 0 2
55581: PPUSH
55582: CALL_OW 274
55586: PPUSH
55587: LD_VAR 0 3
55591: PPUSH
55592: LD_INT 99999
55594: PPUSH
55595: CALL_OW 277
55599: GO 55574
55601: POP
55602: POP
55603: GO 55558
55605: POP
55606: POP
// end ;
55607: LD_VAR 0 1
55611: RET
// export function hHackSetLevel10 ; var i , j ; begin
55612: LD_INT 0
55614: PPUSH
55615: PPUSH
55616: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
55617: LD_ADDR_VAR 0 2
55621: PUSH
55622: LD_INT 21
55624: PUSH
55625: LD_INT 1
55627: PUSH
55628: EMPTY
55629: LIST
55630: LIST
55631: PPUSH
55632: CALL_OW 69
55636: PUSH
55637: FOR_IN
55638: IFFALSE 55690
// if IsSelected ( i ) then
55640: LD_VAR 0 2
55644: PPUSH
55645: CALL_OW 306
55649: IFFALSE 55688
// begin for j := 1 to 4 do
55651: LD_ADDR_VAR 0 3
55655: PUSH
55656: DOUBLE
55657: LD_INT 1
55659: DEC
55660: ST_TO_ADDR
55661: LD_INT 4
55663: PUSH
55664: FOR_TO
55665: IFFALSE 55686
// SetSkill ( i , j , 10 ) ;
55667: LD_VAR 0 2
55671: PPUSH
55672: LD_VAR 0 3
55676: PPUSH
55677: LD_INT 10
55679: PPUSH
55680: CALL_OW 237
55684: GO 55664
55686: POP
55687: POP
// end ;
55688: GO 55637
55690: POP
55691: POP
// end ;
55692: LD_VAR 0 1
55696: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
55697: LD_INT 0
55699: PPUSH
55700: PPUSH
55701: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
55702: LD_ADDR_VAR 0 2
55706: PUSH
55707: LD_INT 22
55709: PUSH
55710: LD_OWVAR 2
55714: PUSH
55715: EMPTY
55716: LIST
55717: LIST
55718: PUSH
55719: LD_INT 21
55721: PUSH
55722: LD_INT 1
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: PUSH
55729: EMPTY
55730: LIST
55731: LIST
55732: PPUSH
55733: CALL_OW 69
55737: PUSH
55738: FOR_IN
55739: IFFALSE 55780
// begin for j := 1 to 4 do
55741: LD_ADDR_VAR 0 3
55745: PUSH
55746: DOUBLE
55747: LD_INT 1
55749: DEC
55750: ST_TO_ADDR
55751: LD_INT 4
55753: PUSH
55754: FOR_TO
55755: IFFALSE 55776
// SetSkill ( i , j , 10 ) ;
55757: LD_VAR 0 2
55761: PPUSH
55762: LD_VAR 0 3
55766: PPUSH
55767: LD_INT 10
55769: PPUSH
55770: CALL_OW 237
55774: GO 55754
55776: POP
55777: POP
// end ;
55778: GO 55738
55780: POP
55781: POP
// end ;
55782: LD_VAR 0 1
55786: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
55787: LD_INT 0
55789: PPUSH
// uc_side := your_side ;
55790: LD_ADDR_OWVAR 20
55794: PUSH
55795: LD_OWVAR 2
55799: ST_TO_ADDR
// uc_nation := nation ;
55800: LD_ADDR_OWVAR 21
55804: PUSH
55805: LD_VAR 0 1
55809: ST_TO_ADDR
// InitHc ;
55810: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
55814: LD_INT 0
55816: PPUSH
55817: LD_VAR 0 2
55821: PPUSH
55822: LD_VAR 0 3
55826: PPUSH
55827: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
55831: LD_VAR 0 4
55835: PPUSH
55836: LD_VAR 0 5
55840: PPUSH
55841: CALL_OW 428
55845: PUSH
55846: LD_INT 0
55848: EQUAL
55849: IFFALSE 55873
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
55851: CALL_OW 44
55855: PPUSH
55856: LD_VAR 0 4
55860: PPUSH
55861: LD_VAR 0 5
55865: PPUSH
55866: LD_INT 1
55868: PPUSH
55869: CALL_OW 48
// end ;
55873: LD_VAR 0 6
55877: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
55878: LD_INT 0
55880: PPUSH
55881: PPUSH
// uc_side := your_side ;
55882: LD_ADDR_OWVAR 20
55886: PUSH
55887: LD_OWVAR 2
55891: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
55892: LD_VAR 0 1
55896: PUSH
55897: LD_INT 1
55899: PUSH
55900: LD_INT 2
55902: PUSH
55903: LD_INT 3
55905: PUSH
55906: LD_INT 4
55908: PUSH
55909: LD_INT 5
55911: PUSH
55912: EMPTY
55913: LIST
55914: LIST
55915: LIST
55916: LIST
55917: LIST
55918: IN
55919: IFFALSE 55931
// uc_nation := nation_american else
55921: LD_ADDR_OWVAR 21
55925: PUSH
55926: LD_INT 1
55928: ST_TO_ADDR
55929: GO 55974
// if chassis in [ 11 , 12 , 13 , 14 ] then
55931: LD_VAR 0 1
55935: PUSH
55936: LD_INT 11
55938: PUSH
55939: LD_INT 12
55941: PUSH
55942: LD_INT 13
55944: PUSH
55945: LD_INT 14
55947: PUSH
55948: EMPTY
55949: LIST
55950: LIST
55951: LIST
55952: LIST
55953: IN
55954: IFFALSE 55966
// uc_nation := nation_arabian else
55956: LD_ADDR_OWVAR 21
55960: PUSH
55961: LD_INT 2
55963: ST_TO_ADDR
55964: GO 55974
// uc_nation := nation_russian ;
55966: LD_ADDR_OWVAR 21
55970: PUSH
55971: LD_INT 3
55973: ST_TO_ADDR
// vc_chassis := chassis ;
55974: LD_ADDR_OWVAR 37
55978: PUSH
55979: LD_VAR 0 1
55983: ST_TO_ADDR
// vc_engine := engine ;
55984: LD_ADDR_OWVAR 39
55988: PUSH
55989: LD_VAR 0 2
55993: ST_TO_ADDR
// vc_control := control ;
55994: LD_ADDR_OWVAR 38
55998: PUSH
55999: LD_VAR 0 3
56003: ST_TO_ADDR
// vc_weapon := weapon ;
56004: LD_ADDR_OWVAR 40
56008: PUSH
56009: LD_VAR 0 4
56013: ST_TO_ADDR
// un := CreateVehicle ;
56014: LD_ADDR_VAR 0 8
56018: PUSH
56019: CALL_OW 45
56023: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
56024: LD_VAR 0 8
56028: PPUSH
56029: LD_INT 0
56031: PPUSH
56032: LD_INT 5
56034: PPUSH
56035: CALL_OW 12
56039: PPUSH
56040: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
56044: LD_VAR 0 8
56048: PPUSH
56049: LD_VAR 0 5
56053: PPUSH
56054: LD_VAR 0 6
56058: PPUSH
56059: LD_INT 1
56061: PPUSH
56062: CALL_OW 48
// end ;
56066: LD_VAR 0 7
56070: RET
// export hInvincible ; every 1 do
56071: GO 56073
56073: DISABLE
// hInvincible := [ ] ;
56074: LD_ADDR_EXP 147
56078: PUSH
56079: EMPTY
56080: ST_TO_ADDR
56081: END
// every 10 do var i ;
56082: GO 56084
56084: DISABLE
56085: LD_INT 0
56087: PPUSH
// begin enable ;
56088: ENABLE
// if not hInvincible then
56089: LD_EXP 147
56093: NOT
56094: IFFALSE 56098
// exit ;
56096: GO 56142
// for i in hInvincible do
56098: LD_ADDR_VAR 0 1
56102: PUSH
56103: LD_EXP 147
56107: PUSH
56108: FOR_IN
56109: IFFALSE 56140
// if GetLives ( i ) < 1000 then
56111: LD_VAR 0 1
56115: PPUSH
56116: CALL_OW 256
56120: PUSH
56121: LD_INT 1000
56123: LESS
56124: IFFALSE 56138
// SetLives ( i , 1000 ) ;
56126: LD_VAR 0 1
56130: PPUSH
56131: LD_INT 1000
56133: PPUSH
56134: CALL_OW 234
56138: GO 56108
56140: POP
56141: POP
// end ;
56142: PPOPN 1
56144: END
// export function hHackInvincible ; var i ; begin
56145: LD_INT 0
56147: PPUSH
56148: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
56149: LD_ADDR_VAR 0 2
56153: PUSH
56154: LD_INT 2
56156: PUSH
56157: LD_INT 21
56159: PUSH
56160: LD_INT 1
56162: PUSH
56163: EMPTY
56164: LIST
56165: LIST
56166: PUSH
56167: LD_INT 21
56169: PUSH
56170: LD_INT 2
56172: PUSH
56173: EMPTY
56174: LIST
56175: LIST
56176: PUSH
56177: EMPTY
56178: LIST
56179: LIST
56180: LIST
56181: PPUSH
56182: CALL_OW 69
56186: PUSH
56187: FOR_IN
56188: IFFALSE 56249
// if IsSelected ( i ) then
56190: LD_VAR 0 2
56194: PPUSH
56195: CALL_OW 306
56199: IFFALSE 56247
// begin if i in hInvincible then
56201: LD_VAR 0 2
56205: PUSH
56206: LD_EXP 147
56210: IN
56211: IFFALSE 56231
// hInvincible := hInvincible diff i else
56213: LD_ADDR_EXP 147
56217: PUSH
56218: LD_EXP 147
56222: PUSH
56223: LD_VAR 0 2
56227: DIFF
56228: ST_TO_ADDR
56229: GO 56247
// hInvincible := hInvincible union i ;
56231: LD_ADDR_EXP 147
56235: PUSH
56236: LD_EXP 147
56240: PUSH
56241: LD_VAR 0 2
56245: UNION
56246: ST_TO_ADDR
// end ;
56247: GO 56187
56249: POP
56250: POP
// end ;
56251: LD_VAR 0 1
56255: RET
// export function hHackInvisible ; var i , j ; begin
56256: LD_INT 0
56258: PPUSH
56259: PPUSH
56260: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56261: LD_ADDR_VAR 0 2
56265: PUSH
56266: LD_INT 21
56268: PUSH
56269: LD_INT 1
56271: PUSH
56272: EMPTY
56273: LIST
56274: LIST
56275: PPUSH
56276: CALL_OW 69
56280: PUSH
56281: FOR_IN
56282: IFFALSE 56306
// if IsSelected ( i ) then
56284: LD_VAR 0 2
56288: PPUSH
56289: CALL_OW 306
56293: IFFALSE 56304
// ComForceInvisible ( i ) ;
56295: LD_VAR 0 2
56299: PPUSH
56300: CALL_OW 496
56304: GO 56281
56306: POP
56307: POP
// end ;
56308: LD_VAR 0 1
56312: RET
// export function hHackChangeYourSide ; begin
56313: LD_INT 0
56315: PPUSH
// if your_side = 8 then
56316: LD_OWVAR 2
56320: PUSH
56321: LD_INT 8
56323: EQUAL
56324: IFFALSE 56336
// your_side := 0 else
56326: LD_ADDR_OWVAR 2
56330: PUSH
56331: LD_INT 0
56333: ST_TO_ADDR
56334: GO 56350
// your_side := your_side + 1 ;
56336: LD_ADDR_OWVAR 2
56340: PUSH
56341: LD_OWVAR 2
56345: PUSH
56346: LD_INT 1
56348: PLUS
56349: ST_TO_ADDR
// end ;
56350: LD_VAR 0 1
56354: RET
// export function hHackChangeUnitSide ; var i , j ; begin
56355: LD_INT 0
56357: PPUSH
56358: PPUSH
56359: PPUSH
// for i in all_units do
56360: LD_ADDR_VAR 0 2
56364: PUSH
56365: LD_OWVAR 3
56369: PUSH
56370: FOR_IN
56371: IFFALSE 56449
// if IsSelected ( i ) then
56373: LD_VAR 0 2
56377: PPUSH
56378: CALL_OW 306
56382: IFFALSE 56447
// begin j := GetSide ( i ) ;
56384: LD_ADDR_VAR 0 3
56388: PUSH
56389: LD_VAR 0 2
56393: PPUSH
56394: CALL_OW 255
56398: ST_TO_ADDR
// if j = 8 then
56399: LD_VAR 0 3
56403: PUSH
56404: LD_INT 8
56406: EQUAL
56407: IFFALSE 56419
// j := 0 else
56409: LD_ADDR_VAR 0 3
56413: PUSH
56414: LD_INT 0
56416: ST_TO_ADDR
56417: GO 56433
// j := j + 1 ;
56419: LD_ADDR_VAR 0 3
56423: PUSH
56424: LD_VAR 0 3
56428: PUSH
56429: LD_INT 1
56431: PLUS
56432: ST_TO_ADDR
// SetSide ( i , j ) ;
56433: LD_VAR 0 2
56437: PPUSH
56438: LD_VAR 0 3
56442: PPUSH
56443: CALL_OW 235
// end ;
56447: GO 56370
56449: POP
56450: POP
// end ;
56451: LD_VAR 0 1
56455: RET
// export function hHackFog ; begin
56456: LD_INT 0
56458: PPUSH
// FogOff ( true ) ;
56459: LD_INT 1
56461: PPUSH
56462: CALL_OW 344
// end ;
56466: LD_VAR 0 1
56470: RET
// export function hHackTeleport ( unit , x , y ) ; begin
56471: LD_INT 0
56473: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
56474: LD_VAR 0 1
56478: PPUSH
56479: LD_VAR 0 2
56483: PPUSH
56484: LD_VAR 0 3
56488: PPUSH
56489: LD_INT 1
56491: PPUSH
56492: LD_INT 1
56494: PPUSH
56495: CALL_OW 483
// CenterOnXY ( x , y ) ;
56499: LD_VAR 0 2
56503: PPUSH
56504: LD_VAR 0 3
56508: PPUSH
56509: CALL_OW 84
// end ; end_of_file
56513: LD_VAR 0 4
56517: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56518: LD_INT 0
56520: PPUSH
56521: PPUSH
56522: PPUSH
56523: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56524: LD_VAR 0 1
56528: PPUSH
56529: CALL_OW 264
56533: PUSH
56534: LD_EXP 79
56538: EQUAL
56539: IFFALSE 56611
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56541: LD_INT 68
56543: PPUSH
56544: LD_VAR 0 1
56548: PPUSH
56549: CALL_OW 255
56553: PPUSH
56554: CALL_OW 321
56558: PUSH
56559: LD_INT 2
56561: EQUAL
56562: IFFALSE 56574
// eff := 70 else
56564: LD_ADDR_VAR 0 4
56568: PUSH
56569: LD_INT 70
56571: ST_TO_ADDR
56572: GO 56582
// eff := 30 ;
56574: LD_ADDR_VAR 0 4
56578: PUSH
56579: LD_INT 30
56581: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56582: LD_VAR 0 1
56586: PPUSH
56587: CALL_OW 250
56591: PPUSH
56592: LD_VAR 0 1
56596: PPUSH
56597: CALL_OW 251
56601: PPUSH
56602: LD_VAR 0 4
56606: PPUSH
56607: CALL_OW 495
// end ; end ;
56611: LD_VAR 0 2
56615: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56616: LD_INT 0
56618: PPUSH
// end ;
56619: LD_VAR 0 4
56623: RET
// export function SOS_Command ( cmd ) ; begin
56624: LD_INT 0
56626: PPUSH
// end ;
56627: LD_VAR 0 2
56631: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
56632: LD_INT 0
56634: PPUSH
// if cmd = 121 then
56635: LD_VAR 0 1
56639: PUSH
56640: LD_INT 121
56642: EQUAL
56643: IFFALSE 56645
// end ;
56645: LD_VAR 0 6
56649: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
56650: LD_INT 0
56652: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
56653: LD_VAR 0 1
56657: PUSH
56658: LD_INT 250
56660: EQUAL
56661: PUSH
56662: LD_VAR 0 2
56666: PPUSH
56667: CALL_OW 264
56671: PUSH
56672: LD_EXP 82
56676: EQUAL
56677: AND
56678: IFFALSE 56699
// MinerPlaceMine ( unit , x , y ) ;
56680: LD_VAR 0 2
56684: PPUSH
56685: LD_VAR 0 4
56689: PPUSH
56690: LD_VAR 0 5
56694: PPUSH
56695: CALL 59048 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
56699: LD_VAR 0 1
56703: PUSH
56704: LD_INT 251
56706: EQUAL
56707: PUSH
56708: LD_VAR 0 2
56712: PPUSH
56713: CALL_OW 264
56717: PUSH
56718: LD_EXP 82
56722: EQUAL
56723: AND
56724: IFFALSE 56745
// MinerDetonateMine ( unit , x , y ) ;
56726: LD_VAR 0 2
56730: PPUSH
56731: LD_VAR 0 4
56735: PPUSH
56736: LD_VAR 0 5
56740: PPUSH
56741: CALL 59325 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
56745: LD_VAR 0 1
56749: PUSH
56750: LD_INT 252
56752: EQUAL
56753: PUSH
56754: LD_VAR 0 2
56758: PPUSH
56759: CALL_OW 264
56763: PUSH
56764: LD_EXP 82
56768: EQUAL
56769: AND
56770: IFFALSE 56791
// MinerCreateMinefield ( unit , x , y ) ;
56772: LD_VAR 0 2
56776: PPUSH
56777: LD_VAR 0 4
56781: PPUSH
56782: LD_VAR 0 5
56786: PPUSH
56787: CALL 59742 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
56791: LD_VAR 0 1
56795: PUSH
56796: LD_INT 253
56798: EQUAL
56799: PUSH
56800: LD_VAR 0 2
56804: PPUSH
56805: CALL_OW 257
56809: PUSH
56810: LD_INT 5
56812: EQUAL
56813: AND
56814: IFFALSE 56835
// ComBinocular ( unit , x , y ) ;
56816: LD_VAR 0 2
56820: PPUSH
56821: LD_VAR 0 4
56825: PPUSH
56826: LD_VAR 0 5
56830: PPUSH
56831: CALL 60113 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
56835: LD_VAR 0 1
56839: PUSH
56840: LD_INT 254
56842: EQUAL
56843: PUSH
56844: LD_VAR 0 2
56848: PPUSH
56849: CALL_OW 264
56853: PUSH
56854: LD_EXP 77
56858: EQUAL
56859: AND
56860: PUSH
56861: LD_VAR 0 3
56865: PPUSH
56866: CALL_OW 263
56870: PUSH
56871: LD_INT 3
56873: EQUAL
56874: AND
56875: IFFALSE 56891
// HackDestroyVehicle ( unit , selectedUnit ) ;
56877: LD_VAR 0 2
56881: PPUSH
56882: LD_VAR 0 3
56886: PPUSH
56887: CALL 58408 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
56891: LD_VAR 0 1
56895: PUSH
56896: LD_INT 255
56898: EQUAL
56899: PUSH
56900: LD_VAR 0 2
56904: PPUSH
56905: CALL_OW 264
56909: PUSH
56910: LD_INT 14
56912: PUSH
56913: LD_INT 53
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: IN
56920: AND
56921: PUSH
56922: LD_VAR 0 4
56926: PPUSH
56927: LD_VAR 0 5
56931: PPUSH
56932: CALL_OW 488
56936: AND
56937: IFFALSE 56961
// CutTreeXYR ( unit , x , y , 12 ) ;
56939: LD_VAR 0 2
56943: PPUSH
56944: LD_VAR 0 4
56948: PPUSH
56949: LD_VAR 0 5
56953: PPUSH
56954: LD_INT 12
56956: PPUSH
56957: CALL 56974 0 4
// end ;
56961: LD_VAR 0 6
56965: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
56966: LD_INT 0
56968: PPUSH
// end ;
56969: LD_VAR 0 4
56973: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
56974: LD_INT 0
56976: PPUSH
56977: PPUSH
56978: PPUSH
56979: PPUSH
56980: PPUSH
56981: PPUSH
56982: PPUSH
56983: PPUSH
56984: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
56985: LD_VAR 0 1
56989: NOT
56990: PUSH
56991: LD_VAR 0 2
56995: PPUSH
56996: LD_VAR 0 3
57000: PPUSH
57001: CALL_OW 488
57005: NOT
57006: OR
57007: PUSH
57008: LD_VAR 0 4
57012: NOT
57013: OR
57014: IFFALSE 57018
// exit ;
57016: GO 57358
// list := [ ] ;
57018: LD_ADDR_VAR 0 13
57022: PUSH
57023: EMPTY
57024: ST_TO_ADDR
// if x - r < 0 then
57025: LD_VAR 0 2
57029: PUSH
57030: LD_VAR 0 4
57034: MINUS
57035: PUSH
57036: LD_INT 0
57038: LESS
57039: IFFALSE 57051
// min_x := 0 else
57041: LD_ADDR_VAR 0 7
57045: PUSH
57046: LD_INT 0
57048: ST_TO_ADDR
57049: GO 57067
// min_x := x - r ;
57051: LD_ADDR_VAR 0 7
57055: PUSH
57056: LD_VAR 0 2
57060: PUSH
57061: LD_VAR 0 4
57065: MINUS
57066: ST_TO_ADDR
// if y - r < 0 then
57067: LD_VAR 0 3
57071: PUSH
57072: LD_VAR 0 4
57076: MINUS
57077: PUSH
57078: LD_INT 0
57080: LESS
57081: IFFALSE 57093
// min_y := 0 else
57083: LD_ADDR_VAR 0 8
57087: PUSH
57088: LD_INT 0
57090: ST_TO_ADDR
57091: GO 57109
// min_y := y - r ;
57093: LD_ADDR_VAR 0 8
57097: PUSH
57098: LD_VAR 0 3
57102: PUSH
57103: LD_VAR 0 4
57107: MINUS
57108: ST_TO_ADDR
// max_x := x + r ;
57109: LD_ADDR_VAR 0 9
57113: PUSH
57114: LD_VAR 0 2
57118: PUSH
57119: LD_VAR 0 4
57123: PLUS
57124: ST_TO_ADDR
// max_y := y + r ;
57125: LD_ADDR_VAR 0 10
57129: PUSH
57130: LD_VAR 0 3
57134: PUSH
57135: LD_VAR 0 4
57139: PLUS
57140: ST_TO_ADDR
// for _x = min_x to max_x do
57141: LD_ADDR_VAR 0 11
57145: PUSH
57146: DOUBLE
57147: LD_VAR 0 7
57151: DEC
57152: ST_TO_ADDR
57153: LD_VAR 0 9
57157: PUSH
57158: FOR_TO
57159: IFFALSE 57276
// for _y = min_y to max_y do
57161: LD_ADDR_VAR 0 12
57165: PUSH
57166: DOUBLE
57167: LD_VAR 0 8
57171: DEC
57172: ST_TO_ADDR
57173: LD_VAR 0 10
57177: PUSH
57178: FOR_TO
57179: IFFALSE 57272
// begin if not ValidHex ( _x , _y ) then
57181: LD_VAR 0 11
57185: PPUSH
57186: LD_VAR 0 12
57190: PPUSH
57191: CALL_OW 488
57195: NOT
57196: IFFALSE 57200
// continue ;
57198: GO 57178
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57200: LD_VAR 0 11
57204: PPUSH
57205: LD_VAR 0 12
57209: PPUSH
57210: CALL_OW 351
57214: PUSH
57215: LD_VAR 0 11
57219: PPUSH
57220: LD_VAR 0 12
57224: PPUSH
57225: CALL_OW 554
57229: AND
57230: IFFALSE 57270
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57232: LD_ADDR_VAR 0 13
57236: PUSH
57237: LD_VAR 0 13
57241: PPUSH
57242: LD_VAR 0 13
57246: PUSH
57247: LD_INT 1
57249: PLUS
57250: PPUSH
57251: LD_VAR 0 11
57255: PUSH
57256: LD_VAR 0 12
57260: PUSH
57261: EMPTY
57262: LIST
57263: LIST
57264: PPUSH
57265: CALL_OW 2
57269: ST_TO_ADDR
// end ;
57270: GO 57178
57272: POP
57273: POP
57274: GO 57158
57276: POP
57277: POP
// if not list then
57278: LD_VAR 0 13
57282: NOT
57283: IFFALSE 57287
// exit ;
57285: GO 57358
// for i in list do
57287: LD_ADDR_VAR 0 6
57291: PUSH
57292: LD_VAR 0 13
57296: PUSH
57297: FOR_IN
57298: IFFALSE 57356
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57300: LD_VAR 0 1
57304: PPUSH
57305: LD_STRING M
57307: PUSH
57308: LD_VAR 0 6
57312: PUSH
57313: LD_INT 1
57315: ARRAY
57316: PUSH
57317: LD_VAR 0 6
57321: PUSH
57322: LD_INT 2
57324: ARRAY
57325: PUSH
57326: LD_INT 0
57328: PUSH
57329: LD_INT 0
57331: PUSH
57332: LD_INT 0
57334: PUSH
57335: LD_INT 0
57337: PUSH
57338: EMPTY
57339: LIST
57340: LIST
57341: LIST
57342: LIST
57343: LIST
57344: LIST
57345: LIST
57346: PUSH
57347: EMPTY
57348: LIST
57349: PPUSH
57350: CALL_OW 447
57354: GO 57297
57356: POP
57357: POP
// end ;
57358: LD_VAR 0 5
57362: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
57363: LD_EXP 150
57367: NOT
57368: IFFALSE 57418
57370: GO 57372
57372: DISABLE
// begin initHack := true ;
57373: LD_ADDR_EXP 150
57377: PUSH
57378: LD_INT 1
57380: ST_TO_ADDR
// hackTanks := [ ] ;
57381: LD_ADDR_EXP 151
57385: PUSH
57386: EMPTY
57387: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
57388: LD_ADDR_EXP 152
57392: PUSH
57393: EMPTY
57394: ST_TO_ADDR
// hackLimit := 3 ;
57395: LD_ADDR_EXP 153
57399: PUSH
57400: LD_INT 3
57402: ST_TO_ADDR
// hackDist := 12 ;
57403: LD_ADDR_EXP 154
57407: PUSH
57408: LD_INT 12
57410: ST_TO_ADDR
// hackCounter := [ ] ;
57411: LD_ADDR_EXP 155
57415: PUSH
57416: EMPTY
57417: ST_TO_ADDR
// end ;
57418: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
57419: LD_EXP 150
57423: PUSH
57424: LD_INT 34
57426: PUSH
57427: LD_EXP 77
57431: PUSH
57432: EMPTY
57433: LIST
57434: LIST
57435: PPUSH
57436: CALL_OW 69
57440: AND
57441: IFFALSE 57696
57443: GO 57445
57445: DISABLE
57446: LD_INT 0
57448: PPUSH
57449: PPUSH
// begin enable ;
57450: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
57451: LD_ADDR_VAR 0 1
57455: PUSH
57456: LD_INT 34
57458: PUSH
57459: LD_EXP 77
57463: PUSH
57464: EMPTY
57465: LIST
57466: LIST
57467: PPUSH
57468: CALL_OW 69
57472: PUSH
57473: FOR_IN
57474: IFFALSE 57694
// begin if not i in hackTanks then
57476: LD_VAR 0 1
57480: PUSH
57481: LD_EXP 151
57485: IN
57486: NOT
57487: IFFALSE 57570
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
57489: LD_ADDR_EXP 151
57493: PUSH
57494: LD_EXP 151
57498: PPUSH
57499: LD_EXP 151
57503: PUSH
57504: LD_INT 1
57506: PLUS
57507: PPUSH
57508: LD_VAR 0 1
57512: PPUSH
57513: CALL_OW 1
57517: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
57518: LD_ADDR_EXP 152
57522: PUSH
57523: LD_EXP 152
57527: PPUSH
57528: LD_EXP 152
57532: PUSH
57533: LD_INT 1
57535: PLUS
57536: PPUSH
57537: EMPTY
57538: PPUSH
57539: CALL_OW 1
57543: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
57544: LD_ADDR_EXP 155
57548: PUSH
57549: LD_EXP 155
57553: PPUSH
57554: LD_EXP 155
57558: PUSH
57559: LD_INT 1
57561: PLUS
57562: PPUSH
57563: EMPTY
57564: PPUSH
57565: CALL_OW 1
57569: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57570: LD_VAR 0 1
57574: PPUSH
57575: CALL_OW 302
57579: NOT
57580: IFFALSE 57593
// begin HackUnlinkAll ( i ) ;
57582: LD_VAR 0 1
57586: PPUSH
57587: CALL 57699 0 1
// continue ;
57591: GO 57473
// end ; HackCheckCapturedStatus ( i ) ;
57593: LD_VAR 0 1
57597: PPUSH
57598: CALL 58142 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57602: LD_ADDR_VAR 0 2
57606: PUSH
57607: LD_INT 81
57609: PUSH
57610: LD_VAR 0 1
57614: PPUSH
57615: CALL_OW 255
57619: PUSH
57620: EMPTY
57621: LIST
57622: LIST
57623: PUSH
57624: LD_INT 33
57626: PUSH
57627: LD_INT 3
57629: PUSH
57630: EMPTY
57631: LIST
57632: LIST
57633: PUSH
57634: LD_INT 91
57636: PUSH
57637: LD_VAR 0 1
57641: PUSH
57642: LD_EXP 154
57646: PUSH
57647: EMPTY
57648: LIST
57649: LIST
57650: LIST
57651: PUSH
57652: LD_INT 50
57654: PUSH
57655: EMPTY
57656: LIST
57657: PUSH
57658: EMPTY
57659: LIST
57660: LIST
57661: LIST
57662: LIST
57663: PPUSH
57664: CALL_OW 69
57668: ST_TO_ADDR
// if not tmp then
57669: LD_VAR 0 2
57673: NOT
57674: IFFALSE 57678
// continue ;
57676: GO 57473
// HackLink ( i , tmp ) ;
57678: LD_VAR 0 1
57682: PPUSH
57683: LD_VAR 0 2
57687: PPUSH
57688: CALL 57835 0 2
// end ;
57692: GO 57473
57694: POP
57695: POP
// end ;
57696: PPOPN 2
57698: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57699: LD_INT 0
57701: PPUSH
57702: PPUSH
57703: PPUSH
// if not hack in hackTanks then
57704: LD_VAR 0 1
57708: PUSH
57709: LD_EXP 151
57713: IN
57714: NOT
57715: IFFALSE 57719
// exit ;
57717: GO 57830
// index := GetElementIndex ( hackTanks , hack ) ;
57719: LD_ADDR_VAR 0 4
57723: PUSH
57724: LD_EXP 151
57728: PPUSH
57729: LD_VAR 0 1
57733: PPUSH
57734: CALL 65264 0 2
57738: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
57739: LD_EXP 152
57743: PUSH
57744: LD_VAR 0 4
57748: ARRAY
57749: IFFALSE 57830
// begin for i in hackTanksCaptured [ index ] do
57751: LD_ADDR_VAR 0 3
57755: PUSH
57756: LD_EXP 152
57760: PUSH
57761: LD_VAR 0 4
57765: ARRAY
57766: PUSH
57767: FOR_IN
57768: IFFALSE 57794
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
57770: LD_VAR 0 3
57774: PUSH
57775: LD_INT 1
57777: ARRAY
57778: PPUSH
57779: LD_VAR 0 3
57783: PUSH
57784: LD_INT 2
57786: ARRAY
57787: PPUSH
57788: CALL_OW 235
57792: GO 57767
57794: POP
57795: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
57796: LD_ADDR_EXP 152
57800: PUSH
57801: LD_EXP 152
57805: PPUSH
57806: LD_VAR 0 4
57810: PPUSH
57811: EMPTY
57812: PPUSH
57813: CALL_OW 1
57817: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
57818: LD_VAR 0 1
57822: PPUSH
57823: LD_INT 0
57825: PPUSH
57826: CALL_OW 505
// end ; end ;
57830: LD_VAR 0 2
57834: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
57835: LD_INT 0
57837: PPUSH
57838: PPUSH
57839: PPUSH
// if not hack in hackTanks or not vehicles then
57840: LD_VAR 0 1
57844: PUSH
57845: LD_EXP 151
57849: IN
57850: NOT
57851: PUSH
57852: LD_VAR 0 2
57856: NOT
57857: OR
57858: IFFALSE 57862
// exit ;
57860: GO 58137
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
57862: LD_ADDR_VAR 0 2
57866: PUSH
57867: LD_VAR 0 1
57871: PPUSH
57872: LD_VAR 0 2
57876: PPUSH
57877: LD_INT 1
57879: PPUSH
57880: LD_INT 1
57882: PPUSH
57883: CALL 65914 0 4
57887: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
57888: LD_ADDR_VAR 0 5
57892: PUSH
57893: LD_EXP 151
57897: PPUSH
57898: LD_VAR 0 1
57902: PPUSH
57903: CALL 65264 0 2
57907: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
57908: LD_EXP 152
57912: PUSH
57913: LD_VAR 0 5
57917: ARRAY
57918: PUSH
57919: LD_EXP 153
57923: LESS
57924: IFFALSE 58113
// begin for i := 1 to vehicles do
57926: LD_ADDR_VAR 0 4
57930: PUSH
57931: DOUBLE
57932: LD_INT 1
57934: DEC
57935: ST_TO_ADDR
57936: LD_VAR 0 2
57940: PUSH
57941: FOR_TO
57942: IFFALSE 58111
// begin if hackTanksCaptured [ index ] = hackLimit then
57944: LD_EXP 152
57948: PUSH
57949: LD_VAR 0 5
57953: ARRAY
57954: PUSH
57955: LD_EXP 153
57959: EQUAL
57960: IFFALSE 57964
// break ;
57962: GO 58111
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
57964: LD_ADDR_EXP 155
57968: PUSH
57969: LD_EXP 155
57973: PPUSH
57974: LD_VAR 0 5
57978: PPUSH
57979: LD_EXP 155
57983: PUSH
57984: LD_VAR 0 5
57988: ARRAY
57989: PUSH
57990: LD_INT 1
57992: PLUS
57993: PPUSH
57994: CALL_OW 1
57998: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
57999: LD_ADDR_EXP 152
58003: PUSH
58004: LD_EXP 152
58008: PPUSH
58009: LD_VAR 0 5
58013: PUSH
58014: LD_EXP 152
58018: PUSH
58019: LD_VAR 0 5
58023: ARRAY
58024: PUSH
58025: LD_INT 1
58027: PLUS
58028: PUSH
58029: EMPTY
58030: LIST
58031: LIST
58032: PPUSH
58033: LD_VAR 0 2
58037: PUSH
58038: LD_VAR 0 4
58042: ARRAY
58043: PUSH
58044: LD_VAR 0 2
58048: PUSH
58049: LD_VAR 0 4
58053: ARRAY
58054: PPUSH
58055: CALL_OW 255
58059: PUSH
58060: EMPTY
58061: LIST
58062: LIST
58063: PPUSH
58064: CALL 65479 0 3
58068: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
58069: LD_VAR 0 2
58073: PUSH
58074: LD_VAR 0 4
58078: ARRAY
58079: PPUSH
58080: LD_VAR 0 1
58084: PPUSH
58085: CALL_OW 255
58089: PPUSH
58090: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
58094: LD_VAR 0 2
58098: PUSH
58099: LD_VAR 0 4
58103: ARRAY
58104: PPUSH
58105: CALL_OW 141
// end ;
58109: GO 57941
58111: POP
58112: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58113: LD_VAR 0 1
58117: PPUSH
58118: LD_EXP 152
58122: PUSH
58123: LD_VAR 0 5
58127: ARRAY
58128: PUSH
58129: LD_INT 0
58131: PLUS
58132: PPUSH
58133: CALL_OW 505
// end ;
58137: LD_VAR 0 3
58141: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
58142: LD_INT 0
58144: PPUSH
58145: PPUSH
58146: PPUSH
58147: PPUSH
// if not hack in hackTanks then
58148: LD_VAR 0 1
58152: PUSH
58153: LD_EXP 151
58157: IN
58158: NOT
58159: IFFALSE 58163
// exit ;
58161: GO 58403
// index := GetElementIndex ( hackTanks , hack ) ;
58163: LD_ADDR_VAR 0 4
58167: PUSH
58168: LD_EXP 151
58172: PPUSH
58173: LD_VAR 0 1
58177: PPUSH
58178: CALL 65264 0 2
58182: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58183: LD_ADDR_VAR 0 3
58187: PUSH
58188: DOUBLE
58189: LD_EXP 152
58193: PUSH
58194: LD_VAR 0 4
58198: ARRAY
58199: INC
58200: ST_TO_ADDR
58201: LD_INT 1
58203: PUSH
58204: FOR_DOWNTO
58205: IFFALSE 58377
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58207: LD_ADDR_VAR 0 5
58211: PUSH
58212: LD_EXP 152
58216: PUSH
58217: LD_VAR 0 4
58221: ARRAY
58222: PUSH
58223: LD_VAR 0 3
58227: ARRAY
58228: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58229: LD_VAR 0 5
58233: PUSH
58234: LD_INT 1
58236: ARRAY
58237: PPUSH
58238: CALL_OW 302
58242: NOT
58243: PUSH
58244: LD_VAR 0 5
58248: PUSH
58249: LD_INT 1
58251: ARRAY
58252: PPUSH
58253: CALL_OW 255
58257: PUSH
58258: LD_VAR 0 1
58262: PPUSH
58263: CALL_OW 255
58267: NONEQUAL
58268: OR
58269: IFFALSE 58375
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58271: LD_VAR 0 5
58275: PUSH
58276: LD_INT 1
58278: ARRAY
58279: PPUSH
58280: CALL_OW 305
58284: PUSH
58285: LD_VAR 0 5
58289: PUSH
58290: LD_INT 1
58292: ARRAY
58293: PPUSH
58294: CALL_OW 255
58298: PUSH
58299: LD_VAR 0 1
58303: PPUSH
58304: CALL_OW 255
58308: EQUAL
58309: AND
58310: IFFALSE 58334
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
58312: LD_VAR 0 5
58316: PUSH
58317: LD_INT 1
58319: ARRAY
58320: PPUSH
58321: LD_VAR 0 5
58325: PUSH
58326: LD_INT 2
58328: ARRAY
58329: PPUSH
58330: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
58334: LD_ADDR_EXP 152
58338: PUSH
58339: LD_EXP 152
58343: PPUSH
58344: LD_VAR 0 4
58348: PPUSH
58349: LD_EXP 152
58353: PUSH
58354: LD_VAR 0 4
58358: ARRAY
58359: PPUSH
58360: LD_VAR 0 3
58364: PPUSH
58365: CALL_OW 3
58369: PPUSH
58370: CALL_OW 1
58374: ST_TO_ADDR
// end ; end ;
58375: GO 58204
58377: POP
58378: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58379: LD_VAR 0 1
58383: PPUSH
58384: LD_EXP 152
58388: PUSH
58389: LD_VAR 0 4
58393: ARRAY
58394: PUSH
58395: LD_INT 0
58397: PLUS
58398: PPUSH
58399: CALL_OW 505
// end ;
58403: LD_VAR 0 2
58407: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
58408: LD_INT 0
58410: PPUSH
58411: PPUSH
58412: PPUSH
58413: PPUSH
// if not hack in hackTanks then
58414: LD_VAR 0 1
58418: PUSH
58419: LD_EXP 151
58423: IN
58424: NOT
58425: IFFALSE 58429
// exit ;
58427: GO 58514
// index := GetElementIndex ( hackTanks , hack ) ;
58429: LD_ADDR_VAR 0 5
58433: PUSH
58434: LD_EXP 151
58438: PPUSH
58439: LD_VAR 0 1
58443: PPUSH
58444: CALL 65264 0 2
58448: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
58449: LD_ADDR_VAR 0 4
58453: PUSH
58454: DOUBLE
58455: LD_INT 1
58457: DEC
58458: ST_TO_ADDR
58459: LD_EXP 152
58463: PUSH
58464: LD_VAR 0 5
58468: ARRAY
58469: PUSH
58470: FOR_TO
58471: IFFALSE 58512
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
58473: LD_EXP 152
58477: PUSH
58478: LD_VAR 0 5
58482: ARRAY
58483: PUSH
58484: LD_VAR 0 4
58488: ARRAY
58489: PUSH
58490: LD_INT 1
58492: ARRAY
58493: PUSH
58494: LD_VAR 0 2
58498: EQUAL
58499: IFFALSE 58510
// KillUnit ( vehicle ) ;
58501: LD_VAR 0 2
58505: PPUSH
58506: CALL_OW 66
58510: GO 58470
58512: POP
58513: POP
// end ;
58514: LD_VAR 0 3
58518: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
58519: LD_EXP 156
58523: NOT
58524: IFFALSE 58559
58526: GO 58528
58528: DISABLE
// begin initMiner := true ;
58529: LD_ADDR_EXP 156
58533: PUSH
58534: LD_INT 1
58536: ST_TO_ADDR
// minersList := [ ] ;
58537: LD_ADDR_EXP 157
58541: PUSH
58542: EMPTY
58543: ST_TO_ADDR
// minerMinesList := [ ] ;
58544: LD_ADDR_EXP 158
58548: PUSH
58549: EMPTY
58550: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
58551: LD_ADDR_EXP 159
58555: PUSH
58556: LD_INT 5
58558: ST_TO_ADDR
// end ;
58559: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
58560: LD_EXP 156
58564: PUSH
58565: LD_INT 34
58567: PUSH
58568: LD_EXP 82
58572: PUSH
58573: EMPTY
58574: LIST
58575: LIST
58576: PPUSH
58577: CALL_OW 69
58581: AND
58582: IFFALSE 59045
58584: GO 58586
58586: DISABLE
58587: LD_INT 0
58589: PPUSH
58590: PPUSH
58591: PPUSH
58592: PPUSH
// begin enable ;
58593: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
58594: LD_ADDR_VAR 0 1
58598: PUSH
58599: LD_INT 34
58601: PUSH
58602: LD_EXP 82
58606: PUSH
58607: EMPTY
58608: LIST
58609: LIST
58610: PPUSH
58611: CALL_OW 69
58615: PUSH
58616: FOR_IN
58617: IFFALSE 58689
// begin if not i in minersList then
58619: LD_VAR 0 1
58623: PUSH
58624: LD_EXP 157
58628: IN
58629: NOT
58630: IFFALSE 58687
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
58632: LD_ADDR_EXP 157
58636: PUSH
58637: LD_EXP 157
58641: PPUSH
58642: LD_EXP 157
58646: PUSH
58647: LD_INT 1
58649: PLUS
58650: PPUSH
58651: LD_VAR 0 1
58655: PPUSH
58656: CALL_OW 1
58660: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
58661: LD_ADDR_EXP 158
58665: PUSH
58666: LD_EXP 158
58670: PPUSH
58671: LD_EXP 158
58675: PUSH
58676: LD_INT 1
58678: PLUS
58679: PPUSH
58680: EMPTY
58681: PPUSH
58682: CALL_OW 1
58686: ST_TO_ADDR
// end end ;
58687: GO 58616
58689: POP
58690: POP
// for i := minerMinesList downto 1 do
58691: LD_ADDR_VAR 0 1
58695: PUSH
58696: DOUBLE
58697: LD_EXP 158
58701: INC
58702: ST_TO_ADDR
58703: LD_INT 1
58705: PUSH
58706: FOR_DOWNTO
58707: IFFALSE 59043
// begin if IsLive ( minersList [ i ] ) then
58709: LD_EXP 157
58713: PUSH
58714: LD_VAR 0 1
58718: ARRAY
58719: PPUSH
58720: CALL_OW 300
58724: IFFALSE 58752
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
58726: LD_EXP 157
58730: PUSH
58731: LD_VAR 0 1
58735: ARRAY
58736: PPUSH
58737: LD_EXP 158
58741: PUSH
58742: LD_VAR 0 1
58746: ARRAY
58747: PPUSH
58748: CALL_OW 505
// if not minerMinesList [ i ] then
58752: LD_EXP 158
58756: PUSH
58757: LD_VAR 0 1
58761: ARRAY
58762: NOT
58763: IFFALSE 58767
// continue ;
58765: GO 58706
// for j := minerMinesList [ i ] downto 1 do
58767: LD_ADDR_VAR 0 2
58771: PUSH
58772: DOUBLE
58773: LD_EXP 158
58777: PUSH
58778: LD_VAR 0 1
58782: ARRAY
58783: INC
58784: ST_TO_ADDR
58785: LD_INT 1
58787: PUSH
58788: FOR_DOWNTO
58789: IFFALSE 59039
// begin side := GetSide ( minersList [ i ] ) ;
58791: LD_ADDR_VAR 0 3
58795: PUSH
58796: LD_EXP 157
58800: PUSH
58801: LD_VAR 0 1
58805: ARRAY
58806: PPUSH
58807: CALL_OW 255
58811: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
58812: LD_ADDR_VAR 0 4
58816: PUSH
58817: LD_EXP 158
58821: PUSH
58822: LD_VAR 0 1
58826: ARRAY
58827: PUSH
58828: LD_VAR 0 2
58832: ARRAY
58833: PUSH
58834: LD_INT 1
58836: ARRAY
58837: PPUSH
58838: LD_EXP 158
58842: PUSH
58843: LD_VAR 0 1
58847: ARRAY
58848: PUSH
58849: LD_VAR 0 2
58853: ARRAY
58854: PUSH
58855: LD_INT 2
58857: ARRAY
58858: PPUSH
58859: CALL_OW 428
58863: ST_TO_ADDR
// if not tmp then
58864: LD_VAR 0 4
58868: NOT
58869: IFFALSE 58873
// continue ;
58871: GO 58788
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
58873: LD_VAR 0 4
58877: PUSH
58878: LD_INT 81
58880: PUSH
58881: LD_VAR 0 3
58885: PUSH
58886: EMPTY
58887: LIST
58888: LIST
58889: PPUSH
58890: CALL_OW 69
58894: IN
58895: PUSH
58896: LD_EXP 158
58900: PUSH
58901: LD_VAR 0 1
58905: ARRAY
58906: PUSH
58907: LD_VAR 0 2
58911: ARRAY
58912: PUSH
58913: LD_INT 1
58915: ARRAY
58916: PPUSH
58917: LD_EXP 158
58921: PUSH
58922: LD_VAR 0 1
58926: ARRAY
58927: PUSH
58928: LD_VAR 0 2
58932: ARRAY
58933: PUSH
58934: LD_INT 2
58936: ARRAY
58937: PPUSH
58938: CALL_OW 458
58942: AND
58943: IFFALSE 59037
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
58945: LD_EXP 158
58949: PUSH
58950: LD_VAR 0 1
58954: ARRAY
58955: PUSH
58956: LD_VAR 0 2
58960: ARRAY
58961: PUSH
58962: LD_INT 1
58964: ARRAY
58965: PPUSH
58966: LD_EXP 158
58970: PUSH
58971: LD_VAR 0 1
58975: ARRAY
58976: PUSH
58977: LD_VAR 0 2
58981: ARRAY
58982: PUSH
58983: LD_INT 2
58985: ARRAY
58986: PPUSH
58987: LD_VAR 0 3
58991: PPUSH
58992: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
58996: LD_ADDR_EXP 158
59000: PUSH
59001: LD_EXP 158
59005: PPUSH
59006: LD_VAR 0 1
59010: PPUSH
59011: LD_EXP 158
59015: PUSH
59016: LD_VAR 0 1
59020: ARRAY
59021: PPUSH
59022: LD_VAR 0 2
59026: PPUSH
59027: CALL_OW 3
59031: PPUSH
59032: CALL_OW 1
59036: ST_TO_ADDR
// end ; end ;
59037: GO 58788
59039: POP
59040: POP
// end ;
59041: GO 58706
59043: POP
59044: POP
// end ;
59045: PPOPN 4
59047: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
59048: LD_INT 0
59050: PPUSH
59051: PPUSH
// result := false ;
59052: LD_ADDR_VAR 0 4
59056: PUSH
59057: LD_INT 0
59059: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
59060: LD_VAR 0 1
59064: PPUSH
59065: CALL_OW 264
59069: PUSH
59070: LD_EXP 82
59074: EQUAL
59075: NOT
59076: IFFALSE 59080
// exit ;
59078: GO 59320
// index := GetElementIndex ( minersList , unit ) ;
59080: LD_ADDR_VAR 0 5
59084: PUSH
59085: LD_EXP 157
59089: PPUSH
59090: LD_VAR 0 1
59094: PPUSH
59095: CALL 65264 0 2
59099: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
59100: LD_EXP 158
59104: PUSH
59105: LD_VAR 0 5
59109: ARRAY
59110: PUSH
59111: LD_EXP 159
59115: GREATEREQUAL
59116: IFFALSE 59120
// exit ;
59118: GO 59320
// ComMoveXY ( unit , x , y ) ;
59120: LD_VAR 0 1
59124: PPUSH
59125: LD_VAR 0 2
59129: PPUSH
59130: LD_VAR 0 3
59134: PPUSH
59135: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
59139: LD_INT 35
59141: PPUSH
59142: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
59146: LD_VAR 0 1
59150: PPUSH
59151: LD_VAR 0 2
59155: PPUSH
59156: LD_VAR 0 3
59160: PPUSH
59161: CALL 95661 0 3
59165: NOT
59166: PUSH
59167: LD_VAR 0 1
59171: PPUSH
59172: CALL_OW 314
59176: AND
59177: IFFALSE 59181
// exit ;
59179: GO 59320
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59181: LD_VAR 0 2
59185: PPUSH
59186: LD_VAR 0 3
59190: PPUSH
59191: CALL_OW 428
59195: PUSH
59196: LD_VAR 0 1
59200: EQUAL
59201: PUSH
59202: LD_VAR 0 1
59206: PPUSH
59207: CALL_OW 314
59211: NOT
59212: AND
59213: IFFALSE 59139
// PlaySoundXY ( x , y , PlantMine ) ;
59215: LD_VAR 0 2
59219: PPUSH
59220: LD_VAR 0 3
59224: PPUSH
59225: LD_STRING PlantMine
59227: PPUSH
59228: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59232: LD_VAR 0 2
59236: PPUSH
59237: LD_VAR 0 3
59241: PPUSH
59242: LD_VAR 0 1
59246: PPUSH
59247: CALL_OW 255
59251: PPUSH
59252: LD_INT 0
59254: PPUSH
59255: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59259: LD_ADDR_EXP 158
59263: PUSH
59264: LD_EXP 158
59268: PPUSH
59269: LD_VAR 0 5
59273: PUSH
59274: LD_EXP 158
59278: PUSH
59279: LD_VAR 0 5
59283: ARRAY
59284: PUSH
59285: LD_INT 1
59287: PLUS
59288: PUSH
59289: EMPTY
59290: LIST
59291: LIST
59292: PPUSH
59293: LD_VAR 0 2
59297: PUSH
59298: LD_VAR 0 3
59302: PUSH
59303: EMPTY
59304: LIST
59305: LIST
59306: PPUSH
59307: CALL 65479 0 3
59311: ST_TO_ADDR
// result := true ;
59312: LD_ADDR_VAR 0 4
59316: PUSH
59317: LD_INT 1
59319: ST_TO_ADDR
// end ;
59320: LD_VAR 0 4
59324: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
59325: LD_INT 0
59327: PPUSH
59328: PPUSH
59329: PPUSH
// if not unit in minersList then
59330: LD_VAR 0 1
59334: PUSH
59335: LD_EXP 157
59339: IN
59340: NOT
59341: IFFALSE 59345
// exit ;
59343: GO 59737
// index := GetElementIndex ( minersList , unit ) ;
59345: LD_ADDR_VAR 0 6
59349: PUSH
59350: LD_EXP 157
59354: PPUSH
59355: LD_VAR 0 1
59359: PPUSH
59360: CALL 65264 0 2
59364: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
59365: LD_ADDR_VAR 0 5
59369: PUSH
59370: DOUBLE
59371: LD_EXP 158
59375: PUSH
59376: LD_VAR 0 6
59380: ARRAY
59381: INC
59382: ST_TO_ADDR
59383: LD_INT 1
59385: PUSH
59386: FOR_DOWNTO
59387: IFFALSE 59548
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
59389: LD_EXP 158
59393: PUSH
59394: LD_VAR 0 6
59398: ARRAY
59399: PUSH
59400: LD_VAR 0 5
59404: ARRAY
59405: PUSH
59406: LD_INT 1
59408: ARRAY
59409: PUSH
59410: LD_VAR 0 2
59414: EQUAL
59415: PUSH
59416: LD_EXP 158
59420: PUSH
59421: LD_VAR 0 6
59425: ARRAY
59426: PUSH
59427: LD_VAR 0 5
59431: ARRAY
59432: PUSH
59433: LD_INT 2
59435: ARRAY
59436: PUSH
59437: LD_VAR 0 3
59441: EQUAL
59442: AND
59443: IFFALSE 59546
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59445: LD_EXP 158
59449: PUSH
59450: LD_VAR 0 6
59454: ARRAY
59455: PUSH
59456: LD_VAR 0 5
59460: ARRAY
59461: PUSH
59462: LD_INT 1
59464: ARRAY
59465: PPUSH
59466: LD_EXP 158
59470: PUSH
59471: LD_VAR 0 6
59475: ARRAY
59476: PUSH
59477: LD_VAR 0 5
59481: ARRAY
59482: PUSH
59483: LD_INT 2
59485: ARRAY
59486: PPUSH
59487: LD_VAR 0 1
59491: PPUSH
59492: CALL_OW 255
59496: PPUSH
59497: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59501: LD_ADDR_EXP 158
59505: PUSH
59506: LD_EXP 158
59510: PPUSH
59511: LD_VAR 0 6
59515: PPUSH
59516: LD_EXP 158
59520: PUSH
59521: LD_VAR 0 6
59525: ARRAY
59526: PPUSH
59527: LD_VAR 0 5
59531: PPUSH
59532: CALL_OW 3
59536: PPUSH
59537: CALL_OW 1
59541: ST_TO_ADDR
// exit ;
59542: POP
59543: POP
59544: GO 59737
// end ; end ;
59546: GO 59386
59548: POP
59549: POP
// for i := minerMinesList [ index ] downto 1 do
59550: LD_ADDR_VAR 0 5
59554: PUSH
59555: DOUBLE
59556: LD_EXP 158
59560: PUSH
59561: LD_VAR 0 6
59565: ARRAY
59566: INC
59567: ST_TO_ADDR
59568: LD_INT 1
59570: PUSH
59571: FOR_DOWNTO
59572: IFFALSE 59735
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
59574: LD_EXP 158
59578: PUSH
59579: LD_VAR 0 6
59583: ARRAY
59584: PUSH
59585: LD_VAR 0 5
59589: ARRAY
59590: PUSH
59591: LD_INT 1
59593: ARRAY
59594: PPUSH
59595: LD_EXP 158
59599: PUSH
59600: LD_VAR 0 6
59604: ARRAY
59605: PUSH
59606: LD_VAR 0 5
59610: ARRAY
59611: PUSH
59612: LD_INT 2
59614: ARRAY
59615: PPUSH
59616: LD_VAR 0 2
59620: PPUSH
59621: LD_VAR 0 3
59625: PPUSH
59626: CALL_OW 298
59630: PUSH
59631: LD_INT 6
59633: LESS
59634: IFFALSE 59733
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59636: LD_EXP 158
59640: PUSH
59641: LD_VAR 0 6
59645: ARRAY
59646: PUSH
59647: LD_VAR 0 5
59651: ARRAY
59652: PUSH
59653: LD_INT 1
59655: ARRAY
59656: PPUSH
59657: LD_EXP 158
59661: PUSH
59662: LD_VAR 0 6
59666: ARRAY
59667: PUSH
59668: LD_VAR 0 5
59672: ARRAY
59673: PUSH
59674: LD_INT 2
59676: ARRAY
59677: PPUSH
59678: LD_VAR 0 1
59682: PPUSH
59683: CALL_OW 255
59687: PPUSH
59688: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59692: LD_ADDR_EXP 158
59696: PUSH
59697: LD_EXP 158
59701: PPUSH
59702: LD_VAR 0 6
59706: PPUSH
59707: LD_EXP 158
59711: PUSH
59712: LD_VAR 0 6
59716: ARRAY
59717: PPUSH
59718: LD_VAR 0 5
59722: PPUSH
59723: CALL_OW 3
59727: PPUSH
59728: CALL_OW 1
59732: ST_TO_ADDR
// end ; end ;
59733: GO 59571
59735: POP
59736: POP
// end ;
59737: LD_VAR 0 4
59741: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
59742: LD_INT 0
59744: PPUSH
59745: PPUSH
59746: PPUSH
59747: PPUSH
59748: PPUSH
59749: PPUSH
59750: PPUSH
59751: PPUSH
59752: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
59753: LD_VAR 0 1
59757: PPUSH
59758: CALL_OW 264
59762: PUSH
59763: LD_EXP 82
59767: EQUAL
59768: NOT
59769: PUSH
59770: LD_VAR 0 1
59774: PUSH
59775: LD_EXP 157
59779: IN
59780: NOT
59781: OR
59782: IFFALSE 59786
// exit ;
59784: GO 60108
// index := GetElementIndex ( minersList , unit ) ;
59786: LD_ADDR_VAR 0 6
59790: PUSH
59791: LD_EXP 157
59795: PPUSH
59796: LD_VAR 0 1
59800: PPUSH
59801: CALL 65264 0 2
59805: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
59806: LD_ADDR_VAR 0 8
59810: PUSH
59811: LD_EXP 159
59815: PUSH
59816: LD_EXP 158
59820: PUSH
59821: LD_VAR 0 6
59825: ARRAY
59826: MINUS
59827: ST_TO_ADDR
// if not minesFreeAmount then
59828: LD_VAR 0 8
59832: NOT
59833: IFFALSE 59837
// exit ;
59835: GO 60108
// tmp := [ ] ;
59837: LD_ADDR_VAR 0 7
59841: PUSH
59842: EMPTY
59843: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
59844: LD_ADDR_VAR 0 5
59848: PUSH
59849: DOUBLE
59850: LD_INT 1
59852: DEC
59853: ST_TO_ADDR
59854: LD_VAR 0 8
59858: PUSH
59859: FOR_TO
59860: IFFALSE 60055
// begin _d := rand ( 0 , 5 ) ;
59862: LD_ADDR_VAR 0 11
59866: PUSH
59867: LD_INT 0
59869: PPUSH
59870: LD_INT 5
59872: PPUSH
59873: CALL_OW 12
59877: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
59878: LD_ADDR_VAR 0 12
59882: PUSH
59883: LD_INT 2
59885: PPUSH
59886: LD_INT 6
59888: PPUSH
59889: CALL_OW 12
59893: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
59894: LD_ADDR_VAR 0 9
59898: PUSH
59899: LD_VAR 0 2
59903: PPUSH
59904: LD_VAR 0 11
59908: PPUSH
59909: LD_VAR 0 12
59913: PPUSH
59914: CALL_OW 272
59918: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
59919: LD_ADDR_VAR 0 10
59923: PUSH
59924: LD_VAR 0 3
59928: PPUSH
59929: LD_VAR 0 11
59933: PPUSH
59934: LD_VAR 0 12
59938: PPUSH
59939: CALL_OW 273
59943: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
59944: LD_VAR 0 9
59948: PPUSH
59949: LD_VAR 0 10
59953: PPUSH
59954: CALL_OW 488
59958: PUSH
59959: LD_VAR 0 9
59963: PUSH
59964: LD_VAR 0 10
59968: PUSH
59969: EMPTY
59970: LIST
59971: LIST
59972: PUSH
59973: LD_VAR 0 7
59977: IN
59978: NOT
59979: AND
59980: PUSH
59981: LD_VAR 0 9
59985: PPUSH
59986: LD_VAR 0 10
59990: PPUSH
59991: CALL_OW 458
59995: NOT
59996: AND
59997: IFFALSE 60039
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
59999: LD_ADDR_VAR 0 7
60003: PUSH
60004: LD_VAR 0 7
60008: PPUSH
60009: LD_VAR 0 7
60013: PUSH
60014: LD_INT 1
60016: PLUS
60017: PPUSH
60018: LD_VAR 0 9
60022: PUSH
60023: LD_VAR 0 10
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: PPUSH
60032: CALL_OW 1
60036: ST_TO_ADDR
60037: GO 60053
// i := i - 1 ;
60039: LD_ADDR_VAR 0 5
60043: PUSH
60044: LD_VAR 0 5
60048: PUSH
60049: LD_INT 1
60051: MINUS
60052: ST_TO_ADDR
// end ;
60053: GO 59859
60055: POP
60056: POP
// for i in tmp do
60057: LD_ADDR_VAR 0 5
60061: PUSH
60062: LD_VAR 0 7
60066: PUSH
60067: FOR_IN
60068: IFFALSE 60106
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
60070: LD_VAR 0 1
60074: PPUSH
60075: LD_VAR 0 5
60079: PUSH
60080: LD_INT 1
60082: ARRAY
60083: PPUSH
60084: LD_VAR 0 5
60088: PUSH
60089: LD_INT 2
60091: ARRAY
60092: PPUSH
60093: CALL 59048 0 3
60097: NOT
60098: IFFALSE 60104
// exit ;
60100: POP
60101: POP
60102: GO 60108
60104: GO 60067
60106: POP
60107: POP
// end ;
60108: LD_VAR 0 4
60112: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
60113: LD_INT 0
60115: PPUSH
60116: PPUSH
60117: PPUSH
60118: PPUSH
60119: PPUSH
60120: PPUSH
60121: PPUSH
// if not GetClass ( unit ) = class_sniper then
60122: LD_VAR 0 1
60126: PPUSH
60127: CALL_OW 257
60131: PUSH
60132: LD_INT 5
60134: EQUAL
60135: NOT
60136: IFFALSE 60140
// exit ;
60138: GO 60528
// dist := 8 ;
60140: LD_ADDR_VAR 0 5
60144: PUSH
60145: LD_INT 8
60147: ST_TO_ADDR
// viewRange := 12 ;
60148: LD_ADDR_VAR 0 7
60152: PUSH
60153: LD_INT 12
60155: ST_TO_ADDR
// side := GetSide ( unit ) ;
60156: LD_ADDR_VAR 0 6
60160: PUSH
60161: LD_VAR 0 1
60165: PPUSH
60166: CALL_OW 255
60170: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60171: LD_INT 61
60173: PPUSH
60174: LD_VAR 0 6
60178: PPUSH
60179: CALL_OW 321
60183: PUSH
60184: LD_INT 2
60186: EQUAL
60187: IFFALSE 60197
// viewRange := 16 ;
60189: LD_ADDR_VAR 0 7
60193: PUSH
60194: LD_INT 16
60196: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60197: LD_VAR 0 1
60201: PPUSH
60202: LD_VAR 0 2
60206: PPUSH
60207: LD_VAR 0 3
60211: PPUSH
60212: CALL_OW 297
60216: PUSH
60217: LD_VAR 0 5
60221: GREATER
60222: IFFALSE 60301
// begin ComMoveXY ( unit , x , y ) ;
60224: LD_VAR 0 1
60228: PPUSH
60229: LD_VAR 0 2
60233: PPUSH
60234: LD_VAR 0 3
60238: PPUSH
60239: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60243: LD_INT 35
60245: PPUSH
60246: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60250: LD_VAR 0 1
60254: PPUSH
60255: LD_VAR 0 2
60259: PPUSH
60260: LD_VAR 0 3
60264: PPUSH
60265: CALL 95661 0 3
60269: NOT
60270: IFFALSE 60274
// exit ;
60272: GO 60528
// until GetDistUnitXY ( unit , x , y ) < dist ;
60274: LD_VAR 0 1
60278: PPUSH
60279: LD_VAR 0 2
60283: PPUSH
60284: LD_VAR 0 3
60288: PPUSH
60289: CALL_OW 297
60293: PUSH
60294: LD_VAR 0 5
60298: LESS
60299: IFFALSE 60243
// end ; ComTurnXY ( unit , x , y ) ;
60301: LD_VAR 0 1
60305: PPUSH
60306: LD_VAR 0 2
60310: PPUSH
60311: LD_VAR 0 3
60315: PPUSH
60316: CALL_OW 118
// wait ( 5 ) ;
60320: LD_INT 5
60322: PPUSH
60323: CALL_OW 67
// _d := GetDir ( unit ) ;
60327: LD_ADDR_VAR 0 10
60331: PUSH
60332: LD_VAR 0 1
60336: PPUSH
60337: CALL_OW 254
60341: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
60342: LD_ADDR_VAR 0 8
60346: PUSH
60347: LD_VAR 0 1
60351: PPUSH
60352: CALL_OW 250
60356: PPUSH
60357: LD_VAR 0 10
60361: PPUSH
60362: LD_VAR 0 5
60366: PPUSH
60367: CALL_OW 272
60371: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
60372: LD_ADDR_VAR 0 9
60376: PUSH
60377: LD_VAR 0 1
60381: PPUSH
60382: CALL_OW 251
60386: PPUSH
60387: LD_VAR 0 10
60391: PPUSH
60392: LD_VAR 0 5
60396: PPUSH
60397: CALL_OW 273
60401: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60402: LD_VAR 0 8
60406: PPUSH
60407: LD_VAR 0 9
60411: PPUSH
60412: CALL_OW 488
60416: NOT
60417: IFFALSE 60421
// exit ;
60419: GO 60528
// ComAnimCustom ( unit , 1 ) ;
60421: LD_VAR 0 1
60425: PPUSH
60426: LD_INT 1
60428: PPUSH
60429: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
60433: LD_VAR 0 8
60437: PPUSH
60438: LD_VAR 0 9
60442: PPUSH
60443: LD_VAR 0 6
60447: PPUSH
60448: LD_VAR 0 7
60452: PPUSH
60453: CALL_OW 330
// repeat wait ( 1 ) ;
60457: LD_INT 1
60459: PPUSH
60460: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
60464: LD_VAR 0 1
60468: PPUSH
60469: CALL_OW 316
60473: PUSH
60474: LD_VAR 0 1
60478: PPUSH
60479: CALL_OW 314
60483: OR
60484: PUSH
60485: LD_VAR 0 1
60489: PPUSH
60490: CALL_OW 302
60494: NOT
60495: OR
60496: PUSH
60497: LD_VAR 0 1
60501: PPUSH
60502: CALL_OW 301
60506: OR
60507: IFFALSE 60457
// RemoveSeeing ( _x , _y , side ) ;
60509: LD_VAR 0 8
60513: PPUSH
60514: LD_VAR 0 9
60518: PPUSH
60519: LD_VAR 0 6
60523: PPUSH
60524: CALL_OW 331
// end ; end_of_file
60528: LD_VAR 0 4
60532: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
60533: LD_INT 0
60535: PPUSH
60536: PPUSH
// if exist_mode then
60537: LD_VAR 0 2
60541: IFFALSE 60566
// unit := CreateCharacter ( prefix & ident ) else
60543: LD_ADDR_VAR 0 5
60547: PUSH
60548: LD_VAR 0 3
60552: PUSH
60553: LD_VAR 0 1
60557: STR
60558: PPUSH
60559: CALL_OW 34
60563: ST_TO_ADDR
60564: GO 60581
// unit := NewCharacter ( ident ) ;
60566: LD_ADDR_VAR 0 5
60570: PUSH
60571: LD_VAR 0 1
60575: PPUSH
60576: CALL_OW 25
60580: ST_TO_ADDR
// result := unit ;
60581: LD_ADDR_VAR 0 4
60585: PUSH
60586: LD_VAR 0 5
60590: ST_TO_ADDR
// end ;
60591: LD_VAR 0 4
60595: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
60596: LD_INT 0
60598: PPUSH
60599: PPUSH
// if not side or not nation then
60600: LD_VAR 0 1
60604: NOT
60605: PUSH
60606: LD_VAR 0 2
60610: NOT
60611: OR
60612: IFFALSE 60616
// exit ;
60614: GO 61380
// case nation of nation_american :
60616: LD_VAR 0 2
60620: PUSH
60621: LD_INT 1
60623: DOUBLE
60624: EQUAL
60625: IFTRUE 60629
60627: GO 60843
60629: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
60630: LD_ADDR_VAR 0 4
60634: PUSH
60635: LD_INT 35
60637: PUSH
60638: LD_INT 45
60640: PUSH
60641: LD_INT 46
60643: PUSH
60644: LD_INT 47
60646: PUSH
60647: LD_INT 82
60649: PUSH
60650: LD_INT 83
60652: PUSH
60653: LD_INT 84
60655: PUSH
60656: LD_INT 85
60658: PUSH
60659: LD_INT 86
60661: PUSH
60662: LD_INT 1
60664: PUSH
60665: LD_INT 2
60667: PUSH
60668: LD_INT 6
60670: PUSH
60671: LD_INT 15
60673: PUSH
60674: LD_INT 16
60676: PUSH
60677: LD_INT 7
60679: PUSH
60680: LD_INT 12
60682: PUSH
60683: LD_INT 13
60685: PUSH
60686: LD_INT 10
60688: PUSH
60689: LD_INT 14
60691: PUSH
60692: LD_INT 20
60694: PUSH
60695: LD_INT 21
60697: PUSH
60698: LD_INT 22
60700: PUSH
60701: LD_INT 25
60703: PUSH
60704: LD_INT 32
60706: PUSH
60707: LD_INT 27
60709: PUSH
60710: LD_INT 36
60712: PUSH
60713: LD_INT 69
60715: PUSH
60716: LD_INT 39
60718: PUSH
60719: LD_INT 34
60721: PUSH
60722: LD_INT 40
60724: PUSH
60725: LD_INT 48
60727: PUSH
60728: LD_INT 49
60730: PUSH
60731: LD_INT 50
60733: PUSH
60734: LD_INT 51
60736: PUSH
60737: LD_INT 52
60739: PUSH
60740: LD_INT 53
60742: PUSH
60743: LD_INT 54
60745: PUSH
60746: LD_INT 55
60748: PUSH
60749: LD_INT 56
60751: PUSH
60752: LD_INT 57
60754: PUSH
60755: LD_INT 58
60757: PUSH
60758: LD_INT 59
60760: PUSH
60761: LD_INT 60
60763: PUSH
60764: LD_INT 61
60766: PUSH
60767: LD_INT 62
60769: PUSH
60770: LD_INT 80
60772: PUSH
60773: LD_INT 82
60775: PUSH
60776: LD_INT 83
60778: PUSH
60779: LD_INT 84
60781: PUSH
60782: LD_INT 85
60784: PUSH
60785: LD_INT 86
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: LIST
60792: LIST
60793: LIST
60794: LIST
60795: LIST
60796: LIST
60797: LIST
60798: LIST
60799: LIST
60800: LIST
60801: LIST
60802: LIST
60803: LIST
60804: LIST
60805: LIST
60806: LIST
60807: LIST
60808: LIST
60809: LIST
60810: LIST
60811: LIST
60812: LIST
60813: LIST
60814: LIST
60815: LIST
60816: LIST
60817: LIST
60818: LIST
60819: LIST
60820: LIST
60821: LIST
60822: LIST
60823: LIST
60824: LIST
60825: LIST
60826: LIST
60827: LIST
60828: LIST
60829: LIST
60830: LIST
60831: LIST
60832: LIST
60833: LIST
60834: LIST
60835: LIST
60836: LIST
60837: LIST
60838: LIST
60839: LIST
60840: ST_TO_ADDR
60841: GO 61304
60843: LD_INT 2
60845: DOUBLE
60846: EQUAL
60847: IFTRUE 60851
60849: GO 61073
60851: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
60852: LD_ADDR_VAR 0 4
60856: PUSH
60857: LD_INT 35
60859: PUSH
60860: LD_INT 45
60862: PUSH
60863: LD_INT 46
60865: PUSH
60866: LD_INT 47
60868: PUSH
60869: LD_INT 82
60871: PUSH
60872: LD_INT 83
60874: PUSH
60875: LD_INT 84
60877: PUSH
60878: LD_INT 85
60880: PUSH
60881: LD_INT 87
60883: PUSH
60884: LD_INT 70
60886: PUSH
60887: LD_INT 1
60889: PUSH
60890: LD_INT 11
60892: PUSH
60893: LD_INT 3
60895: PUSH
60896: LD_INT 4
60898: PUSH
60899: LD_INT 5
60901: PUSH
60902: LD_INT 6
60904: PUSH
60905: LD_INT 15
60907: PUSH
60908: LD_INT 18
60910: PUSH
60911: LD_INT 7
60913: PUSH
60914: LD_INT 17
60916: PUSH
60917: LD_INT 8
60919: PUSH
60920: LD_INT 20
60922: PUSH
60923: LD_INT 21
60925: PUSH
60926: LD_INT 22
60928: PUSH
60929: LD_INT 72
60931: PUSH
60932: LD_INT 26
60934: PUSH
60935: LD_INT 69
60937: PUSH
60938: LD_INT 39
60940: PUSH
60941: LD_INT 40
60943: PUSH
60944: LD_INT 41
60946: PUSH
60947: LD_INT 42
60949: PUSH
60950: LD_INT 43
60952: PUSH
60953: LD_INT 48
60955: PUSH
60956: LD_INT 49
60958: PUSH
60959: LD_INT 50
60961: PUSH
60962: LD_INT 51
60964: PUSH
60965: LD_INT 52
60967: PUSH
60968: LD_INT 53
60970: PUSH
60971: LD_INT 54
60973: PUSH
60974: LD_INT 55
60976: PUSH
60977: LD_INT 56
60979: PUSH
60980: LD_INT 60
60982: PUSH
60983: LD_INT 61
60985: PUSH
60986: LD_INT 62
60988: PUSH
60989: LD_INT 66
60991: PUSH
60992: LD_INT 67
60994: PUSH
60995: LD_INT 68
60997: PUSH
60998: LD_INT 81
61000: PUSH
61001: LD_INT 82
61003: PUSH
61004: LD_INT 83
61006: PUSH
61007: LD_INT 84
61009: PUSH
61010: LD_INT 85
61012: PUSH
61013: LD_INT 87
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: LIST
61020: LIST
61021: LIST
61022: LIST
61023: LIST
61024: LIST
61025: LIST
61026: LIST
61027: LIST
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: LIST
61033: LIST
61034: LIST
61035: LIST
61036: LIST
61037: LIST
61038: LIST
61039: LIST
61040: LIST
61041: LIST
61042: LIST
61043: LIST
61044: LIST
61045: LIST
61046: LIST
61047: LIST
61048: LIST
61049: LIST
61050: LIST
61051: LIST
61052: LIST
61053: LIST
61054: LIST
61055: LIST
61056: LIST
61057: LIST
61058: LIST
61059: LIST
61060: LIST
61061: LIST
61062: LIST
61063: LIST
61064: LIST
61065: LIST
61066: LIST
61067: LIST
61068: LIST
61069: LIST
61070: ST_TO_ADDR
61071: GO 61304
61073: LD_INT 3
61075: DOUBLE
61076: EQUAL
61077: IFTRUE 61081
61079: GO 61303
61081: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
61082: LD_ADDR_VAR 0 4
61086: PUSH
61087: LD_INT 46
61089: PUSH
61090: LD_INT 47
61092: PUSH
61093: LD_INT 1
61095: PUSH
61096: LD_INT 2
61098: PUSH
61099: LD_INT 82
61101: PUSH
61102: LD_INT 83
61104: PUSH
61105: LD_INT 84
61107: PUSH
61108: LD_INT 85
61110: PUSH
61111: LD_INT 86
61113: PUSH
61114: LD_INT 11
61116: PUSH
61117: LD_INT 9
61119: PUSH
61120: LD_INT 20
61122: PUSH
61123: LD_INT 19
61125: PUSH
61126: LD_INT 21
61128: PUSH
61129: LD_INT 24
61131: PUSH
61132: LD_INT 22
61134: PUSH
61135: LD_INT 25
61137: PUSH
61138: LD_INT 28
61140: PUSH
61141: LD_INT 29
61143: PUSH
61144: LD_INT 30
61146: PUSH
61147: LD_INT 31
61149: PUSH
61150: LD_INT 37
61152: PUSH
61153: LD_INT 38
61155: PUSH
61156: LD_INT 32
61158: PUSH
61159: LD_INT 27
61161: PUSH
61162: LD_INT 33
61164: PUSH
61165: LD_INT 69
61167: PUSH
61168: LD_INT 39
61170: PUSH
61171: LD_INT 34
61173: PUSH
61174: LD_INT 40
61176: PUSH
61177: LD_INT 71
61179: PUSH
61180: LD_INT 23
61182: PUSH
61183: LD_INT 44
61185: PUSH
61186: LD_INT 48
61188: PUSH
61189: LD_INT 49
61191: PUSH
61192: LD_INT 50
61194: PUSH
61195: LD_INT 51
61197: PUSH
61198: LD_INT 52
61200: PUSH
61201: LD_INT 53
61203: PUSH
61204: LD_INT 54
61206: PUSH
61207: LD_INT 55
61209: PUSH
61210: LD_INT 56
61212: PUSH
61213: LD_INT 57
61215: PUSH
61216: LD_INT 58
61218: PUSH
61219: LD_INT 59
61221: PUSH
61222: LD_INT 63
61224: PUSH
61225: LD_INT 64
61227: PUSH
61228: LD_INT 65
61230: PUSH
61231: LD_INT 82
61233: PUSH
61234: LD_INT 83
61236: PUSH
61237: LD_INT 84
61239: PUSH
61240: LD_INT 85
61242: PUSH
61243: LD_INT 86
61245: PUSH
61246: EMPTY
61247: LIST
61248: LIST
61249: LIST
61250: LIST
61251: LIST
61252: LIST
61253: LIST
61254: LIST
61255: LIST
61256: LIST
61257: LIST
61258: LIST
61259: LIST
61260: LIST
61261: LIST
61262: LIST
61263: LIST
61264: LIST
61265: LIST
61266: LIST
61267: LIST
61268: LIST
61269: LIST
61270: LIST
61271: LIST
61272: LIST
61273: LIST
61274: LIST
61275: LIST
61276: LIST
61277: LIST
61278: LIST
61279: LIST
61280: LIST
61281: LIST
61282: LIST
61283: LIST
61284: LIST
61285: LIST
61286: LIST
61287: LIST
61288: LIST
61289: LIST
61290: LIST
61291: LIST
61292: LIST
61293: LIST
61294: LIST
61295: LIST
61296: LIST
61297: LIST
61298: LIST
61299: LIST
61300: ST_TO_ADDR
61301: GO 61304
61303: POP
// if state > - 1 and state < 3 then
61304: LD_VAR 0 3
61308: PUSH
61309: LD_INT 1
61311: NEG
61312: GREATER
61313: PUSH
61314: LD_VAR 0 3
61318: PUSH
61319: LD_INT 3
61321: LESS
61322: AND
61323: IFFALSE 61380
// for i in result do
61325: LD_ADDR_VAR 0 5
61329: PUSH
61330: LD_VAR 0 4
61334: PUSH
61335: FOR_IN
61336: IFFALSE 61378
// if GetTech ( i , side ) <> state then
61338: LD_VAR 0 5
61342: PPUSH
61343: LD_VAR 0 1
61347: PPUSH
61348: CALL_OW 321
61352: PUSH
61353: LD_VAR 0 3
61357: NONEQUAL
61358: IFFALSE 61376
// result := result diff i ;
61360: LD_ADDR_VAR 0 4
61364: PUSH
61365: LD_VAR 0 4
61369: PUSH
61370: LD_VAR 0 5
61374: DIFF
61375: ST_TO_ADDR
61376: GO 61335
61378: POP
61379: POP
// end ;
61380: LD_VAR 0 4
61384: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
61385: LD_INT 0
61387: PPUSH
61388: PPUSH
61389: PPUSH
// result := true ;
61390: LD_ADDR_VAR 0 3
61394: PUSH
61395: LD_INT 1
61397: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
61398: LD_ADDR_VAR 0 5
61402: PUSH
61403: LD_VAR 0 2
61407: PPUSH
61408: CALL_OW 480
61412: ST_TO_ADDR
// if not tmp then
61413: LD_VAR 0 5
61417: NOT
61418: IFFALSE 61422
// exit ;
61420: GO 61471
// for i in tmp do
61422: LD_ADDR_VAR 0 4
61426: PUSH
61427: LD_VAR 0 5
61431: PUSH
61432: FOR_IN
61433: IFFALSE 61469
// if GetTech ( i , side ) <> state_researched then
61435: LD_VAR 0 4
61439: PPUSH
61440: LD_VAR 0 1
61444: PPUSH
61445: CALL_OW 321
61449: PUSH
61450: LD_INT 2
61452: NONEQUAL
61453: IFFALSE 61467
// begin result := false ;
61455: LD_ADDR_VAR 0 3
61459: PUSH
61460: LD_INT 0
61462: ST_TO_ADDR
// exit ;
61463: POP
61464: POP
61465: GO 61471
// end ;
61467: GO 61432
61469: POP
61470: POP
// end ;
61471: LD_VAR 0 3
61475: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
61476: LD_INT 0
61478: PPUSH
61479: PPUSH
61480: PPUSH
61481: PPUSH
61482: PPUSH
61483: PPUSH
61484: PPUSH
61485: PPUSH
61486: PPUSH
61487: PPUSH
61488: PPUSH
61489: PPUSH
61490: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
61491: LD_VAR 0 1
61495: NOT
61496: PUSH
61497: LD_VAR 0 1
61501: PPUSH
61502: CALL_OW 257
61506: PUSH
61507: LD_INT 9
61509: NONEQUAL
61510: OR
61511: IFFALSE 61515
// exit ;
61513: GO 62088
// side := GetSide ( unit ) ;
61515: LD_ADDR_VAR 0 9
61519: PUSH
61520: LD_VAR 0 1
61524: PPUSH
61525: CALL_OW 255
61529: ST_TO_ADDR
// tech_space := tech_spacanom ;
61530: LD_ADDR_VAR 0 12
61534: PUSH
61535: LD_INT 29
61537: ST_TO_ADDR
// tech_time := tech_taurad ;
61538: LD_ADDR_VAR 0 13
61542: PUSH
61543: LD_INT 28
61545: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
61546: LD_ADDR_VAR 0 11
61550: PUSH
61551: LD_VAR 0 1
61555: PPUSH
61556: CALL_OW 310
61560: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
61561: LD_VAR 0 11
61565: PPUSH
61566: CALL_OW 247
61570: PUSH
61571: LD_INT 2
61573: EQUAL
61574: IFFALSE 61578
// exit ;
61576: GO 62088
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
61578: LD_ADDR_VAR 0 8
61582: PUSH
61583: LD_INT 81
61585: PUSH
61586: LD_VAR 0 9
61590: PUSH
61591: EMPTY
61592: LIST
61593: LIST
61594: PUSH
61595: LD_INT 3
61597: PUSH
61598: LD_INT 21
61600: PUSH
61601: LD_INT 3
61603: PUSH
61604: EMPTY
61605: LIST
61606: LIST
61607: PUSH
61608: EMPTY
61609: LIST
61610: LIST
61611: PUSH
61612: EMPTY
61613: LIST
61614: LIST
61615: PPUSH
61616: CALL_OW 69
61620: ST_TO_ADDR
// if not tmp then
61621: LD_VAR 0 8
61625: NOT
61626: IFFALSE 61630
// exit ;
61628: GO 62088
// if in_unit then
61630: LD_VAR 0 11
61634: IFFALSE 61658
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
61636: LD_ADDR_VAR 0 10
61640: PUSH
61641: LD_VAR 0 8
61645: PPUSH
61646: LD_VAR 0 11
61650: PPUSH
61651: CALL_OW 74
61655: ST_TO_ADDR
61656: GO 61678
// enemy := NearestUnitToUnit ( tmp , unit ) ;
61658: LD_ADDR_VAR 0 10
61662: PUSH
61663: LD_VAR 0 8
61667: PPUSH
61668: LD_VAR 0 1
61672: PPUSH
61673: CALL_OW 74
61677: ST_TO_ADDR
// if not enemy then
61678: LD_VAR 0 10
61682: NOT
61683: IFFALSE 61687
// exit ;
61685: GO 62088
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
61687: LD_VAR 0 11
61691: PUSH
61692: LD_VAR 0 11
61696: PPUSH
61697: LD_VAR 0 10
61701: PPUSH
61702: CALL_OW 296
61706: PUSH
61707: LD_INT 13
61709: GREATER
61710: AND
61711: PUSH
61712: LD_VAR 0 1
61716: PPUSH
61717: LD_VAR 0 10
61721: PPUSH
61722: CALL_OW 296
61726: PUSH
61727: LD_INT 12
61729: GREATER
61730: OR
61731: IFFALSE 61735
// exit ;
61733: GO 62088
// missile := [ 1 ] ;
61735: LD_ADDR_VAR 0 14
61739: PUSH
61740: LD_INT 1
61742: PUSH
61743: EMPTY
61744: LIST
61745: ST_TO_ADDR
// if Researched ( side , tech_space ) then
61746: LD_VAR 0 9
61750: PPUSH
61751: LD_VAR 0 12
61755: PPUSH
61756: CALL_OW 325
61760: IFFALSE 61789
// missile := Insert ( missile , missile + 1 , 2 ) ;
61762: LD_ADDR_VAR 0 14
61766: PUSH
61767: LD_VAR 0 14
61771: PPUSH
61772: LD_VAR 0 14
61776: PUSH
61777: LD_INT 1
61779: PLUS
61780: PPUSH
61781: LD_INT 2
61783: PPUSH
61784: CALL_OW 2
61788: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
61789: LD_VAR 0 9
61793: PPUSH
61794: LD_VAR 0 13
61798: PPUSH
61799: CALL_OW 325
61803: PUSH
61804: LD_VAR 0 10
61808: PPUSH
61809: CALL_OW 255
61813: PPUSH
61814: LD_VAR 0 13
61818: PPUSH
61819: CALL_OW 325
61823: NOT
61824: AND
61825: IFFALSE 61854
// missile := Insert ( missile , missile + 1 , 3 ) ;
61827: LD_ADDR_VAR 0 14
61831: PUSH
61832: LD_VAR 0 14
61836: PPUSH
61837: LD_VAR 0 14
61841: PUSH
61842: LD_INT 1
61844: PLUS
61845: PPUSH
61846: LD_INT 3
61848: PPUSH
61849: CALL_OW 2
61853: ST_TO_ADDR
// if missile < 2 then
61854: LD_VAR 0 14
61858: PUSH
61859: LD_INT 2
61861: LESS
61862: IFFALSE 61866
// exit ;
61864: GO 62088
// x := GetX ( enemy ) ;
61866: LD_ADDR_VAR 0 4
61870: PUSH
61871: LD_VAR 0 10
61875: PPUSH
61876: CALL_OW 250
61880: ST_TO_ADDR
// y := GetY ( enemy ) ;
61881: LD_ADDR_VAR 0 5
61885: PUSH
61886: LD_VAR 0 10
61890: PPUSH
61891: CALL_OW 251
61895: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
61896: LD_ADDR_VAR 0 6
61900: PUSH
61901: LD_VAR 0 4
61905: PUSH
61906: LD_INT 1
61908: NEG
61909: PPUSH
61910: LD_INT 1
61912: PPUSH
61913: CALL_OW 12
61917: PLUS
61918: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
61919: LD_ADDR_VAR 0 7
61923: PUSH
61924: LD_VAR 0 5
61928: PUSH
61929: LD_INT 1
61931: NEG
61932: PPUSH
61933: LD_INT 1
61935: PPUSH
61936: CALL_OW 12
61940: PLUS
61941: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
61942: LD_VAR 0 6
61946: PPUSH
61947: LD_VAR 0 7
61951: PPUSH
61952: CALL_OW 488
61956: NOT
61957: IFFALSE 61979
// begin _x := x ;
61959: LD_ADDR_VAR 0 6
61963: PUSH
61964: LD_VAR 0 4
61968: ST_TO_ADDR
// _y := y ;
61969: LD_ADDR_VAR 0 7
61973: PUSH
61974: LD_VAR 0 5
61978: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
61979: LD_ADDR_VAR 0 3
61983: PUSH
61984: LD_INT 1
61986: PPUSH
61987: LD_VAR 0 14
61991: PPUSH
61992: CALL_OW 12
61996: ST_TO_ADDR
// case i of 1 :
61997: LD_VAR 0 3
62001: PUSH
62002: LD_INT 1
62004: DOUBLE
62005: EQUAL
62006: IFTRUE 62010
62008: GO 62027
62010: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
62011: LD_VAR 0 1
62015: PPUSH
62016: LD_VAR 0 10
62020: PPUSH
62021: CALL_OW 115
62025: GO 62088
62027: LD_INT 2
62029: DOUBLE
62030: EQUAL
62031: IFTRUE 62035
62033: GO 62057
62035: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
62036: LD_VAR 0 1
62040: PPUSH
62041: LD_VAR 0 6
62045: PPUSH
62046: LD_VAR 0 7
62050: PPUSH
62051: CALL_OW 153
62055: GO 62088
62057: LD_INT 3
62059: DOUBLE
62060: EQUAL
62061: IFTRUE 62065
62063: GO 62087
62065: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62066: LD_VAR 0 1
62070: PPUSH
62071: LD_VAR 0 6
62075: PPUSH
62076: LD_VAR 0 7
62080: PPUSH
62081: CALL_OW 154
62085: GO 62088
62087: POP
// end ;
62088: LD_VAR 0 2
62092: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62093: LD_INT 0
62095: PPUSH
62096: PPUSH
62097: PPUSH
62098: PPUSH
62099: PPUSH
62100: PPUSH
// if not unit or not building then
62101: LD_VAR 0 1
62105: NOT
62106: PUSH
62107: LD_VAR 0 2
62111: NOT
62112: OR
62113: IFFALSE 62117
// exit ;
62115: GO 62275
// x := GetX ( building ) ;
62117: LD_ADDR_VAR 0 5
62121: PUSH
62122: LD_VAR 0 2
62126: PPUSH
62127: CALL_OW 250
62131: ST_TO_ADDR
// y := GetY ( building ) ;
62132: LD_ADDR_VAR 0 6
62136: PUSH
62137: LD_VAR 0 2
62141: PPUSH
62142: CALL_OW 251
62146: ST_TO_ADDR
// for i = 0 to 5 do
62147: LD_ADDR_VAR 0 4
62151: PUSH
62152: DOUBLE
62153: LD_INT 0
62155: DEC
62156: ST_TO_ADDR
62157: LD_INT 5
62159: PUSH
62160: FOR_TO
62161: IFFALSE 62273
// begin _x := ShiftX ( x , i , 3 ) ;
62163: LD_ADDR_VAR 0 7
62167: PUSH
62168: LD_VAR 0 5
62172: PPUSH
62173: LD_VAR 0 4
62177: PPUSH
62178: LD_INT 3
62180: PPUSH
62181: CALL_OW 272
62185: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
62186: LD_ADDR_VAR 0 8
62190: PUSH
62191: LD_VAR 0 6
62195: PPUSH
62196: LD_VAR 0 4
62200: PPUSH
62201: LD_INT 3
62203: PPUSH
62204: CALL_OW 273
62208: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62209: LD_VAR 0 7
62213: PPUSH
62214: LD_VAR 0 8
62218: PPUSH
62219: CALL_OW 488
62223: NOT
62224: IFFALSE 62228
// continue ;
62226: GO 62160
// if HexInfo ( _x , _y ) = 0 then
62228: LD_VAR 0 7
62232: PPUSH
62233: LD_VAR 0 8
62237: PPUSH
62238: CALL_OW 428
62242: PUSH
62243: LD_INT 0
62245: EQUAL
62246: IFFALSE 62271
// begin ComMoveXY ( unit , _x , _y ) ;
62248: LD_VAR 0 1
62252: PPUSH
62253: LD_VAR 0 7
62257: PPUSH
62258: LD_VAR 0 8
62262: PPUSH
62263: CALL_OW 111
// exit ;
62267: POP
62268: POP
62269: GO 62275
// end ; end ;
62271: GO 62160
62273: POP
62274: POP
// end ;
62275: LD_VAR 0 3
62279: RET
// export function ScanBase ( side , base_area ) ; begin
62280: LD_INT 0
62282: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
62283: LD_ADDR_VAR 0 3
62287: PUSH
62288: LD_VAR 0 2
62292: PPUSH
62293: LD_INT 81
62295: PUSH
62296: LD_VAR 0 1
62300: PUSH
62301: EMPTY
62302: LIST
62303: LIST
62304: PPUSH
62305: CALL_OW 70
62309: ST_TO_ADDR
// end ;
62310: LD_VAR 0 3
62314: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
62315: LD_INT 0
62317: PPUSH
62318: PPUSH
62319: PPUSH
62320: PPUSH
// result := false ;
62321: LD_ADDR_VAR 0 2
62325: PUSH
62326: LD_INT 0
62328: ST_TO_ADDR
// side := GetSide ( unit ) ;
62329: LD_ADDR_VAR 0 3
62333: PUSH
62334: LD_VAR 0 1
62338: PPUSH
62339: CALL_OW 255
62343: ST_TO_ADDR
// nat := GetNation ( unit ) ;
62344: LD_ADDR_VAR 0 4
62348: PUSH
62349: LD_VAR 0 1
62353: PPUSH
62354: CALL_OW 248
62358: ST_TO_ADDR
// case nat of 1 :
62359: LD_VAR 0 4
62363: PUSH
62364: LD_INT 1
62366: DOUBLE
62367: EQUAL
62368: IFTRUE 62372
62370: GO 62383
62372: POP
// tech := tech_lassight ; 2 :
62373: LD_ADDR_VAR 0 5
62377: PUSH
62378: LD_INT 12
62380: ST_TO_ADDR
62381: GO 62422
62383: LD_INT 2
62385: DOUBLE
62386: EQUAL
62387: IFTRUE 62391
62389: GO 62402
62391: POP
// tech := tech_mortar ; 3 :
62392: LD_ADDR_VAR 0 5
62396: PUSH
62397: LD_INT 41
62399: ST_TO_ADDR
62400: GO 62422
62402: LD_INT 3
62404: DOUBLE
62405: EQUAL
62406: IFTRUE 62410
62408: GO 62421
62410: POP
// tech := tech_bazooka ; end ;
62411: LD_ADDR_VAR 0 5
62415: PUSH
62416: LD_INT 44
62418: ST_TO_ADDR
62419: GO 62422
62421: POP
// if Researched ( side , tech ) then
62422: LD_VAR 0 3
62426: PPUSH
62427: LD_VAR 0 5
62431: PPUSH
62432: CALL_OW 325
62436: IFFALSE 62463
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
62438: LD_ADDR_VAR 0 2
62442: PUSH
62443: LD_INT 5
62445: PUSH
62446: LD_INT 8
62448: PUSH
62449: LD_INT 9
62451: PUSH
62452: EMPTY
62453: LIST
62454: LIST
62455: LIST
62456: PUSH
62457: LD_VAR 0 4
62461: ARRAY
62462: ST_TO_ADDR
// end ;
62463: LD_VAR 0 2
62467: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
62468: LD_INT 0
62470: PPUSH
62471: PPUSH
62472: PPUSH
// if not mines then
62473: LD_VAR 0 2
62477: NOT
62478: IFFALSE 62482
// exit ;
62480: GO 62626
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62482: LD_ADDR_VAR 0 5
62486: PUSH
62487: LD_INT 81
62489: PUSH
62490: LD_VAR 0 1
62494: PUSH
62495: EMPTY
62496: LIST
62497: LIST
62498: PUSH
62499: LD_INT 3
62501: PUSH
62502: LD_INT 21
62504: PUSH
62505: LD_INT 3
62507: PUSH
62508: EMPTY
62509: LIST
62510: LIST
62511: PUSH
62512: EMPTY
62513: LIST
62514: LIST
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PPUSH
62520: CALL_OW 69
62524: ST_TO_ADDR
// for i in mines do
62525: LD_ADDR_VAR 0 4
62529: PUSH
62530: LD_VAR 0 2
62534: PUSH
62535: FOR_IN
62536: IFFALSE 62624
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
62538: LD_VAR 0 4
62542: PUSH
62543: LD_INT 1
62545: ARRAY
62546: PPUSH
62547: LD_VAR 0 4
62551: PUSH
62552: LD_INT 2
62554: ARRAY
62555: PPUSH
62556: CALL_OW 458
62560: NOT
62561: IFFALSE 62565
// continue ;
62563: GO 62535
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
62565: LD_VAR 0 4
62569: PUSH
62570: LD_INT 1
62572: ARRAY
62573: PPUSH
62574: LD_VAR 0 4
62578: PUSH
62579: LD_INT 2
62581: ARRAY
62582: PPUSH
62583: CALL_OW 428
62587: PUSH
62588: LD_VAR 0 5
62592: IN
62593: IFFALSE 62622
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
62595: LD_VAR 0 4
62599: PUSH
62600: LD_INT 1
62602: ARRAY
62603: PPUSH
62604: LD_VAR 0 4
62608: PUSH
62609: LD_INT 2
62611: ARRAY
62612: PPUSH
62613: LD_VAR 0 1
62617: PPUSH
62618: CALL_OW 456
// end ;
62622: GO 62535
62624: POP
62625: POP
// end ;
62626: LD_VAR 0 3
62630: RET
// export function Count ( array ) ; var i ; begin
62631: LD_INT 0
62633: PPUSH
62634: PPUSH
// result := 0 ;
62635: LD_ADDR_VAR 0 2
62639: PUSH
62640: LD_INT 0
62642: ST_TO_ADDR
// for i in array do
62643: LD_ADDR_VAR 0 3
62647: PUSH
62648: LD_VAR 0 1
62652: PUSH
62653: FOR_IN
62654: IFFALSE 62678
// if i then
62656: LD_VAR 0 3
62660: IFFALSE 62676
// result := result + 1 ;
62662: LD_ADDR_VAR 0 2
62666: PUSH
62667: LD_VAR 0 2
62671: PUSH
62672: LD_INT 1
62674: PLUS
62675: ST_TO_ADDR
62676: GO 62653
62678: POP
62679: POP
// end ;
62680: LD_VAR 0 2
62684: RET
// export function IsEmpty ( building ) ; begin
62685: LD_INT 0
62687: PPUSH
// if not building then
62688: LD_VAR 0 1
62692: NOT
62693: IFFALSE 62697
// exit ;
62695: GO 62740
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
62697: LD_ADDR_VAR 0 2
62701: PUSH
62702: LD_VAR 0 1
62706: PUSH
62707: LD_INT 22
62709: PUSH
62710: LD_VAR 0 1
62714: PPUSH
62715: CALL_OW 255
62719: PUSH
62720: EMPTY
62721: LIST
62722: LIST
62723: PUSH
62724: LD_INT 58
62726: PUSH
62727: EMPTY
62728: LIST
62729: PUSH
62730: EMPTY
62731: LIST
62732: LIST
62733: PPUSH
62734: CALL_OW 69
62738: IN
62739: ST_TO_ADDR
// end ;
62740: LD_VAR 0 2
62744: RET
// export function IsNotFull ( building ) ; begin
62745: LD_INT 0
62747: PPUSH
// if not building then
62748: LD_VAR 0 1
62752: NOT
62753: IFFALSE 62757
// exit ;
62755: GO 62776
// result := UnitsInside ( building ) < 6 ;
62757: LD_ADDR_VAR 0 2
62761: PUSH
62762: LD_VAR 0 1
62766: PPUSH
62767: CALL_OW 313
62771: PUSH
62772: LD_INT 6
62774: LESS
62775: ST_TO_ADDR
// end ;
62776: LD_VAR 0 2
62780: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
62781: LD_INT 0
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
// tmp := [ ] ;
62787: LD_ADDR_VAR 0 3
62791: PUSH
62792: EMPTY
62793: ST_TO_ADDR
// list := [ ] ;
62794: LD_ADDR_VAR 0 5
62798: PUSH
62799: EMPTY
62800: ST_TO_ADDR
// for i = 16 to 25 do
62801: LD_ADDR_VAR 0 4
62805: PUSH
62806: DOUBLE
62807: LD_INT 16
62809: DEC
62810: ST_TO_ADDR
62811: LD_INT 25
62813: PUSH
62814: FOR_TO
62815: IFFALSE 62888
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
62817: LD_ADDR_VAR 0 3
62821: PUSH
62822: LD_VAR 0 3
62826: PUSH
62827: LD_INT 22
62829: PUSH
62830: LD_VAR 0 1
62834: PPUSH
62835: CALL_OW 255
62839: PUSH
62840: EMPTY
62841: LIST
62842: LIST
62843: PUSH
62844: LD_INT 91
62846: PUSH
62847: LD_VAR 0 1
62851: PUSH
62852: LD_INT 6
62854: PUSH
62855: EMPTY
62856: LIST
62857: LIST
62858: LIST
62859: PUSH
62860: LD_INT 30
62862: PUSH
62863: LD_VAR 0 4
62867: PUSH
62868: EMPTY
62869: LIST
62870: LIST
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: LIST
62876: PUSH
62877: EMPTY
62878: LIST
62879: PPUSH
62880: CALL_OW 69
62884: ADD
62885: ST_TO_ADDR
62886: GO 62814
62888: POP
62889: POP
// for i = 1 to tmp do
62890: LD_ADDR_VAR 0 4
62894: PUSH
62895: DOUBLE
62896: LD_INT 1
62898: DEC
62899: ST_TO_ADDR
62900: LD_VAR 0 3
62904: PUSH
62905: FOR_TO
62906: IFFALSE 62994
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
62908: LD_ADDR_VAR 0 5
62912: PUSH
62913: LD_VAR 0 5
62917: PUSH
62918: LD_VAR 0 3
62922: PUSH
62923: LD_VAR 0 4
62927: ARRAY
62928: PPUSH
62929: CALL_OW 266
62933: PUSH
62934: LD_VAR 0 3
62938: PUSH
62939: LD_VAR 0 4
62943: ARRAY
62944: PPUSH
62945: CALL_OW 250
62949: PUSH
62950: LD_VAR 0 3
62954: PUSH
62955: LD_VAR 0 4
62959: ARRAY
62960: PPUSH
62961: CALL_OW 251
62965: PUSH
62966: LD_VAR 0 3
62970: PUSH
62971: LD_VAR 0 4
62975: ARRAY
62976: PPUSH
62977: CALL_OW 254
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: LIST
62986: LIST
62987: PUSH
62988: EMPTY
62989: LIST
62990: ADD
62991: ST_TO_ADDR
62992: GO 62905
62994: POP
62995: POP
// result := list ;
62996: LD_ADDR_VAR 0 2
63000: PUSH
63001: LD_VAR 0 5
63005: ST_TO_ADDR
// end ;
63006: LD_VAR 0 2
63010: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
63011: LD_INT 0
63013: PPUSH
63014: PPUSH
63015: PPUSH
63016: PPUSH
63017: PPUSH
63018: PPUSH
63019: PPUSH
// if not factory then
63020: LD_VAR 0 1
63024: NOT
63025: IFFALSE 63029
// exit ;
63027: GO 63622
// if control = control_apeman then
63029: LD_VAR 0 4
63033: PUSH
63034: LD_INT 5
63036: EQUAL
63037: IFFALSE 63146
// begin tmp := UnitsInside ( factory ) ;
63039: LD_ADDR_VAR 0 8
63043: PUSH
63044: LD_VAR 0 1
63048: PPUSH
63049: CALL_OW 313
63053: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
63054: LD_VAR 0 8
63058: PPUSH
63059: LD_INT 25
63061: PUSH
63062: LD_INT 12
63064: PUSH
63065: EMPTY
63066: LIST
63067: LIST
63068: PPUSH
63069: CALL_OW 72
63073: NOT
63074: IFFALSE 63084
// control := control_manual ;
63076: LD_ADDR_VAR 0 4
63080: PUSH
63081: LD_INT 1
63083: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
63084: LD_ADDR_VAR 0 8
63088: PUSH
63089: LD_VAR 0 1
63093: PPUSH
63094: CALL 62781 0 1
63098: ST_TO_ADDR
// if tmp then
63099: LD_VAR 0 8
63103: IFFALSE 63146
// begin for i in tmp do
63105: LD_ADDR_VAR 0 7
63109: PUSH
63110: LD_VAR 0 8
63114: PUSH
63115: FOR_IN
63116: IFFALSE 63144
// if i [ 1 ] = b_ext_radio then
63118: LD_VAR 0 7
63122: PUSH
63123: LD_INT 1
63125: ARRAY
63126: PUSH
63127: LD_INT 22
63129: EQUAL
63130: IFFALSE 63142
// begin control := control_remote ;
63132: LD_ADDR_VAR 0 4
63136: PUSH
63137: LD_INT 2
63139: ST_TO_ADDR
// break ;
63140: GO 63144
// end ;
63142: GO 63115
63144: POP
63145: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63146: LD_VAR 0 1
63150: PPUSH
63151: LD_VAR 0 2
63155: PPUSH
63156: LD_VAR 0 3
63160: PPUSH
63161: LD_VAR 0 4
63165: PPUSH
63166: LD_VAR 0 5
63170: PPUSH
63171: CALL_OW 448
63175: IFFALSE 63210
// begin result := [ chassis , engine , control , weapon ] ;
63177: LD_ADDR_VAR 0 6
63181: PUSH
63182: LD_VAR 0 2
63186: PUSH
63187: LD_VAR 0 3
63191: PUSH
63192: LD_VAR 0 4
63196: PUSH
63197: LD_VAR 0 5
63201: PUSH
63202: EMPTY
63203: LIST
63204: LIST
63205: LIST
63206: LIST
63207: ST_TO_ADDR
// exit ;
63208: GO 63622
// end ; _chassis := AvailableChassisList ( factory ) ;
63210: LD_ADDR_VAR 0 9
63214: PUSH
63215: LD_VAR 0 1
63219: PPUSH
63220: CALL_OW 475
63224: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
63225: LD_ADDR_VAR 0 11
63229: PUSH
63230: LD_VAR 0 1
63234: PPUSH
63235: CALL_OW 476
63239: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
63240: LD_ADDR_VAR 0 12
63244: PUSH
63245: LD_VAR 0 1
63249: PPUSH
63250: CALL_OW 477
63254: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
63255: LD_ADDR_VAR 0 10
63259: PUSH
63260: LD_VAR 0 1
63264: PPUSH
63265: CALL_OW 478
63269: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
63270: LD_VAR 0 9
63274: NOT
63275: PUSH
63276: LD_VAR 0 11
63280: NOT
63281: OR
63282: PUSH
63283: LD_VAR 0 12
63287: NOT
63288: OR
63289: PUSH
63290: LD_VAR 0 10
63294: NOT
63295: OR
63296: IFFALSE 63331
// begin result := [ chassis , engine , control , weapon ] ;
63298: LD_ADDR_VAR 0 6
63302: PUSH
63303: LD_VAR 0 2
63307: PUSH
63308: LD_VAR 0 3
63312: PUSH
63313: LD_VAR 0 4
63317: PUSH
63318: LD_VAR 0 5
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: LIST
63327: LIST
63328: ST_TO_ADDR
// exit ;
63329: GO 63622
// end ; if not chassis in _chassis then
63331: LD_VAR 0 2
63335: PUSH
63336: LD_VAR 0 9
63340: IN
63341: NOT
63342: IFFALSE 63368
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
63344: LD_ADDR_VAR 0 2
63348: PUSH
63349: LD_VAR 0 9
63353: PUSH
63354: LD_INT 1
63356: PPUSH
63357: LD_VAR 0 9
63361: PPUSH
63362: CALL_OW 12
63366: ARRAY
63367: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
63368: LD_VAR 0 2
63372: PPUSH
63373: LD_VAR 0 3
63377: PPUSH
63378: CALL 63627 0 2
63382: NOT
63383: IFFALSE 63442
// repeat engine := _engine [ 1 ] ;
63385: LD_ADDR_VAR 0 3
63389: PUSH
63390: LD_VAR 0 11
63394: PUSH
63395: LD_INT 1
63397: ARRAY
63398: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
63399: LD_ADDR_VAR 0 11
63403: PUSH
63404: LD_VAR 0 11
63408: PPUSH
63409: LD_INT 1
63411: PPUSH
63412: CALL_OW 3
63416: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
63417: LD_VAR 0 2
63421: PPUSH
63422: LD_VAR 0 3
63426: PPUSH
63427: CALL 63627 0 2
63431: PUSH
63432: LD_VAR 0 11
63436: PUSH
63437: EMPTY
63438: EQUAL
63439: OR
63440: IFFALSE 63385
// if not control in _control then
63442: LD_VAR 0 4
63446: PUSH
63447: LD_VAR 0 12
63451: IN
63452: NOT
63453: IFFALSE 63479
// control := _control [ rand ( 1 , _control ) ] ;
63455: LD_ADDR_VAR 0 4
63459: PUSH
63460: LD_VAR 0 12
63464: PUSH
63465: LD_INT 1
63467: PPUSH
63468: LD_VAR 0 12
63472: PPUSH
63473: CALL_OW 12
63477: ARRAY
63478: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
63479: LD_VAR 0 2
63483: PPUSH
63484: LD_VAR 0 5
63488: PPUSH
63489: CALL 63847 0 2
63493: NOT
63494: IFFALSE 63553
// repeat weapon := _weapon [ 1 ] ;
63496: LD_ADDR_VAR 0 5
63500: PUSH
63501: LD_VAR 0 10
63505: PUSH
63506: LD_INT 1
63508: ARRAY
63509: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
63510: LD_ADDR_VAR 0 10
63514: PUSH
63515: LD_VAR 0 10
63519: PPUSH
63520: LD_INT 1
63522: PPUSH
63523: CALL_OW 3
63527: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
63528: LD_VAR 0 2
63532: PPUSH
63533: LD_VAR 0 5
63537: PPUSH
63538: CALL 63847 0 2
63542: PUSH
63543: LD_VAR 0 10
63547: PUSH
63548: EMPTY
63549: EQUAL
63550: OR
63551: IFFALSE 63496
// result := [ ] ;
63553: LD_ADDR_VAR 0 6
63557: PUSH
63558: EMPTY
63559: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63560: LD_VAR 0 1
63564: PPUSH
63565: LD_VAR 0 2
63569: PPUSH
63570: LD_VAR 0 3
63574: PPUSH
63575: LD_VAR 0 4
63579: PPUSH
63580: LD_VAR 0 5
63584: PPUSH
63585: CALL_OW 448
63589: IFFALSE 63622
// result := [ chassis , engine , control , weapon ] ;
63591: LD_ADDR_VAR 0 6
63595: PUSH
63596: LD_VAR 0 2
63600: PUSH
63601: LD_VAR 0 3
63605: PUSH
63606: LD_VAR 0 4
63610: PUSH
63611: LD_VAR 0 5
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: LIST
63620: LIST
63621: ST_TO_ADDR
// end ;
63622: LD_VAR 0 6
63626: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
63627: LD_INT 0
63629: PPUSH
// if not chassis or not engine then
63630: LD_VAR 0 1
63634: NOT
63635: PUSH
63636: LD_VAR 0 2
63640: NOT
63641: OR
63642: IFFALSE 63646
// exit ;
63644: GO 63842
// case engine of engine_solar :
63646: LD_VAR 0 2
63650: PUSH
63651: LD_INT 2
63653: DOUBLE
63654: EQUAL
63655: IFTRUE 63659
63657: GO 63697
63659: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
63660: LD_ADDR_VAR 0 3
63664: PUSH
63665: LD_INT 11
63667: PUSH
63668: LD_INT 12
63670: PUSH
63671: LD_INT 13
63673: PUSH
63674: LD_INT 14
63676: PUSH
63677: LD_INT 1
63679: PUSH
63680: LD_INT 2
63682: PUSH
63683: LD_INT 3
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: LIST
63690: LIST
63691: LIST
63692: LIST
63693: LIST
63694: ST_TO_ADDR
63695: GO 63826
63697: LD_INT 1
63699: DOUBLE
63700: EQUAL
63701: IFTRUE 63705
63703: GO 63767
63705: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
63706: LD_ADDR_VAR 0 3
63710: PUSH
63711: LD_INT 11
63713: PUSH
63714: LD_INT 12
63716: PUSH
63717: LD_INT 13
63719: PUSH
63720: LD_INT 14
63722: PUSH
63723: LD_INT 1
63725: PUSH
63726: LD_INT 2
63728: PUSH
63729: LD_INT 3
63731: PUSH
63732: LD_INT 4
63734: PUSH
63735: LD_INT 5
63737: PUSH
63738: LD_INT 21
63740: PUSH
63741: LD_INT 23
63743: PUSH
63744: LD_INT 22
63746: PUSH
63747: LD_INT 24
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: LIST
63754: LIST
63755: LIST
63756: LIST
63757: LIST
63758: LIST
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: ST_TO_ADDR
63765: GO 63826
63767: LD_INT 3
63769: DOUBLE
63770: EQUAL
63771: IFTRUE 63775
63773: GO 63825
63775: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
63776: LD_ADDR_VAR 0 3
63780: PUSH
63781: LD_INT 13
63783: PUSH
63784: LD_INT 14
63786: PUSH
63787: LD_INT 2
63789: PUSH
63790: LD_INT 3
63792: PUSH
63793: LD_INT 4
63795: PUSH
63796: LD_INT 5
63798: PUSH
63799: LD_INT 21
63801: PUSH
63802: LD_INT 22
63804: PUSH
63805: LD_INT 23
63807: PUSH
63808: LD_INT 24
63810: PUSH
63811: EMPTY
63812: LIST
63813: LIST
63814: LIST
63815: LIST
63816: LIST
63817: LIST
63818: LIST
63819: LIST
63820: LIST
63821: LIST
63822: ST_TO_ADDR
63823: GO 63826
63825: POP
// result := ( chassis in result ) ;
63826: LD_ADDR_VAR 0 3
63830: PUSH
63831: LD_VAR 0 1
63835: PUSH
63836: LD_VAR 0 3
63840: IN
63841: ST_TO_ADDR
// end ;
63842: LD_VAR 0 3
63846: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
63847: LD_INT 0
63849: PPUSH
// if not chassis or not weapon then
63850: LD_VAR 0 1
63854: NOT
63855: PUSH
63856: LD_VAR 0 2
63860: NOT
63861: OR
63862: IFFALSE 63866
// exit ;
63864: GO 64892
// case weapon of us_machine_gun :
63866: LD_VAR 0 2
63870: PUSH
63871: LD_INT 2
63873: DOUBLE
63874: EQUAL
63875: IFTRUE 63879
63877: GO 63909
63879: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
63880: LD_ADDR_VAR 0 3
63884: PUSH
63885: LD_INT 1
63887: PUSH
63888: LD_INT 2
63890: PUSH
63891: LD_INT 3
63893: PUSH
63894: LD_INT 4
63896: PUSH
63897: LD_INT 5
63899: PUSH
63900: EMPTY
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: ST_TO_ADDR
63907: GO 64876
63909: LD_INT 3
63911: DOUBLE
63912: EQUAL
63913: IFTRUE 63917
63915: GO 63947
63917: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
63918: LD_ADDR_VAR 0 3
63922: PUSH
63923: LD_INT 1
63925: PUSH
63926: LD_INT 2
63928: PUSH
63929: LD_INT 3
63931: PUSH
63932: LD_INT 4
63934: PUSH
63935: LD_INT 5
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: LIST
63944: ST_TO_ADDR
63945: GO 64876
63947: LD_INT 11
63949: DOUBLE
63950: EQUAL
63951: IFTRUE 63955
63953: GO 63985
63955: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
63956: LD_ADDR_VAR 0 3
63960: PUSH
63961: LD_INT 1
63963: PUSH
63964: LD_INT 2
63966: PUSH
63967: LD_INT 3
63969: PUSH
63970: LD_INT 4
63972: PUSH
63973: LD_INT 5
63975: PUSH
63976: EMPTY
63977: LIST
63978: LIST
63979: LIST
63980: LIST
63981: LIST
63982: ST_TO_ADDR
63983: GO 64876
63985: LD_INT 4
63987: DOUBLE
63988: EQUAL
63989: IFTRUE 63993
63991: GO 64019
63993: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
63994: LD_ADDR_VAR 0 3
63998: PUSH
63999: LD_INT 2
64001: PUSH
64002: LD_INT 3
64004: PUSH
64005: LD_INT 4
64007: PUSH
64008: LD_INT 5
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: LIST
64015: LIST
64016: ST_TO_ADDR
64017: GO 64876
64019: LD_INT 5
64021: DOUBLE
64022: EQUAL
64023: IFTRUE 64027
64025: GO 64053
64027: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
64028: LD_ADDR_VAR 0 3
64032: PUSH
64033: LD_INT 2
64035: PUSH
64036: LD_INT 3
64038: PUSH
64039: LD_INT 4
64041: PUSH
64042: LD_INT 5
64044: PUSH
64045: EMPTY
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: ST_TO_ADDR
64051: GO 64876
64053: LD_INT 9
64055: DOUBLE
64056: EQUAL
64057: IFTRUE 64061
64059: GO 64087
64061: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
64062: LD_ADDR_VAR 0 3
64066: PUSH
64067: LD_INT 2
64069: PUSH
64070: LD_INT 3
64072: PUSH
64073: LD_INT 4
64075: PUSH
64076: LD_INT 5
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: ST_TO_ADDR
64085: GO 64876
64087: LD_INT 7
64089: DOUBLE
64090: EQUAL
64091: IFTRUE 64095
64093: GO 64121
64095: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
64096: LD_ADDR_VAR 0 3
64100: PUSH
64101: LD_INT 2
64103: PUSH
64104: LD_INT 3
64106: PUSH
64107: LD_INT 4
64109: PUSH
64110: LD_INT 5
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: LIST
64117: LIST
64118: ST_TO_ADDR
64119: GO 64876
64121: LD_INT 12
64123: DOUBLE
64124: EQUAL
64125: IFTRUE 64129
64127: GO 64155
64129: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
64130: LD_ADDR_VAR 0 3
64134: PUSH
64135: LD_INT 2
64137: PUSH
64138: LD_INT 3
64140: PUSH
64141: LD_INT 4
64143: PUSH
64144: LD_INT 5
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: LIST
64151: LIST
64152: ST_TO_ADDR
64153: GO 64876
64155: LD_INT 13
64157: DOUBLE
64158: EQUAL
64159: IFTRUE 64163
64161: GO 64189
64163: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
64164: LD_ADDR_VAR 0 3
64168: PUSH
64169: LD_INT 2
64171: PUSH
64172: LD_INT 3
64174: PUSH
64175: LD_INT 4
64177: PUSH
64178: LD_INT 5
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: LIST
64185: LIST
64186: ST_TO_ADDR
64187: GO 64876
64189: LD_INT 14
64191: DOUBLE
64192: EQUAL
64193: IFTRUE 64197
64195: GO 64215
64197: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
64198: LD_ADDR_VAR 0 3
64202: PUSH
64203: LD_INT 4
64205: PUSH
64206: LD_INT 5
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: ST_TO_ADDR
64213: GO 64876
64215: LD_INT 6
64217: DOUBLE
64218: EQUAL
64219: IFTRUE 64223
64221: GO 64241
64223: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
64224: LD_ADDR_VAR 0 3
64228: PUSH
64229: LD_INT 4
64231: PUSH
64232: LD_INT 5
64234: PUSH
64235: EMPTY
64236: LIST
64237: LIST
64238: ST_TO_ADDR
64239: GO 64876
64241: LD_INT 10
64243: DOUBLE
64244: EQUAL
64245: IFTRUE 64249
64247: GO 64267
64249: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
64250: LD_ADDR_VAR 0 3
64254: PUSH
64255: LD_INT 4
64257: PUSH
64258: LD_INT 5
64260: PUSH
64261: EMPTY
64262: LIST
64263: LIST
64264: ST_TO_ADDR
64265: GO 64876
64267: LD_INT 22
64269: DOUBLE
64270: EQUAL
64271: IFTRUE 64275
64273: GO 64301
64275: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
64276: LD_ADDR_VAR 0 3
64280: PUSH
64281: LD_INT 11
64283: PUSH
64284: LD_INT 12
64286: PUSH
64287: LD_INT 13
64289: PUSH
64290: LD_INT 14
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: ST_TO_ADDR
64299: GO 64876
64301: LD_INT 23
64303: DOUBLE
64304: EQUAL
64305: IFTRUE 64309
64307: GO 64335
64309: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
64310: LD_ADDR_VAR 0 3
64314: PUSH
64315: LD_INT 11
64317: PUSH
64318: LD_INT 12
64320: PUSH
64321: LD_INT 13
64323: PUSH
64324: LD_INT 14
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: ST_TO_ADDR
64333: GO 64876
64335: LD_INT 24
64337: DOUBLE
64338: EQUAL
64339: IFTRUE 64343
64341: GO 64369
64343: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
64344: LD_ADDR_VAR 0 3
64348: PUSH
64349: LD_INT 11
64351: PUSH
64352: LD_INT 12
64354: PUSH
64355: LD_INT 13
64357: PUSH
64358: LD_INT 14
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: LIST
64365: LIST
64366: ST_TO_ADDR
64367: GO 64876
64369: LD_INT 30
64371: DOUBLE
64372: EQUAL
64373: IFTRUE 64377
64375: GO 64403
64377: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
64378: LD_ADDR_VAR 0 3
64382: PUSH
64383: LD_INT 11
64385: PUSH
64386: LD_INT 12
64388: PUSH
64389: LD_INT 13
64391: PUSH
64392: LD_INT 14
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: LIST
64399: LIST
64400: ST_TO_ADDR
64401: GO 64876
64403: LD_INT 25
64405: DOUBLE
64406: EQUAL
64407: IFTRUE 64411
64409: GO 64429
64411: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
64412: LD_ADDR_VAR 0 3
64416: PUSH
64417: LD_INT 13
64419: PUSH
64420: LD_INT 14
64422: PUSH
64423: EMPTY
64424: LIST
64425: LIST
64426: ST_TO_ADDR
64427: GO 64876
64429: LD_INT 27
64431: DOUBLE
64432: EQUAL
64433: IFTRUE 64437
64435: GO 64455
64437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
64438: LD_ADDR_VAR 0 3
64442: PUSH
64443: LD_INT 13
64445: PUSH
64446: LD_INT 14
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: ST_TO_ADDR
64453: GO 64876
64455: LD_INT 28
64457: DOUBLE
64458: EQUAL
64459: IFTRUE 64463
64461: GO 64481
64463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
64464: LD_ADDR_VAR 0 3
64468: PUSH
64469: LD_INT 13
64471: PUSH
64472: LD_INT 14
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: ST_TO_ADDR
64479: GO 64876
64481: LD_INT 29
64483: DOUBLE
64484: EQUAL
64485: IFTRUE 64489
64487: GO 64507
64489: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
64490: LD_ADDR_VAR 0 3
64494: PUSH
64495: LD_INT 13
64497: PUSH
64498: LD_INT 14
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: ST_TO_ADDR
64505: GO 64876
64507: LD_INT 31
64509: DOUBLE
64510: EQUAL
64511: IFTRUE 64515
64513: GO 64533
64515: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
64516: LD_ADDR_VAR 0 3
64520: PUSH
64521: LD_INT 13
64523: PUSH
64524: LD_INT 14
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: ST_TO_ADDR
64531: GO 64876
64533: LD_INT 26
64535: DOUBLE
64536: EQUAL
64537: IFTRUE 64541
64539: GO 64559
64541: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
64542: LD_ADDR_VAR 0 3
64546: PUSH
64547: LD_INT 13
64549: PUSH
64550: LD_INT 14
64552: PUSH
64553: EMPTY
64554: LIST
64555: LIST
64556: ST_TO_ADDR
64557: GO 64876
64559: LD_INT 42
64561: DOUBLE
64562: EQUAL
64563: IFTRUE 64567
64565: GO 64593
64567: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
64568: LD_ADDR_VAR 0 3
64572: PUSH
64573: LD_INT 21
64575: PUSH
64576: LD_INT 22
64578: PUSH
64579: LD_INT 23
64581: PUSH
64582: LD_INT 24
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: ST_TO_ADDR
64591: GO 64876
64593: LD_INT 43
64595: DOUBLE
64596: EQUAL
64597: IFTRUE 64601
64599: GO 64627
64601: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
64602: LD_ADDR_VAR 0 3
64606: PUSH
64607: LD_INT 21
64609: PUSH
64610: LD_INT 22
64612: PUSH
64613: LD_INT 23
64615: PUSH
64616: LD_INT 24
64618: PUSH
64619: EMPTY
64620: LIST
64621: LIST
64622: LIST
64623: LIST
64624: ST_TO_ADDR
64625: GO 64876
64627: LD_INT 44
64629: DOUBLE
64630: EQUAL
64631: IFTRUE 64635
64633: GO 64661
64635: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
64636: LD_ADDR_VAR 0 3
64640: PUSH
64641: LD_INT 21
64643: PUSH
64644: LD_INT 22
64646: PUSH
64647: LD_INT 23
64649: PUSH
64650: LD_INT 24
64652: PUSH
64653: EMPTY
64654: LIST
64655: LIST
64656: LIST
64657: LIST
64658: ST_TO_ADDR
64659: GO 64876
64661: LD_INT 45
64663: DOUBLE
64664: EQUAL
64665: IFTRUE 64669
64667: GO 64695
64669: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
64670: LD_ADDR_VAR 0 3
64674: PUSH
64675: LD_INT 21
64677: PUSH
64678: LD_INT 22
64680: PUSH
64681: LD_INT 23
64683: PUSH
64684: LD_INT 24
64686: PUSH
64687: EMPTY
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: ST_TO_ADDR
64693: GO 64876
64695: LD_INT 49
64697: DOUBLE
64698: EQUAL
64699: IFTRUE 64703
64701: GO 64729
64703: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
64704: LD_ADDR_VAR 0 3
64708: PUSH
64709: LD_INT 21
64711: PUSH
64712: LD_INT 22
64714: PUSH
64715: LD_INT 23
64717: PUSH
64718: LD_INT 24
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: LIST
64725: LIST
64726: ST_TO_ADDR
64727: GO 64876
64729: LD_INT 51
64731: DOUBLE
64732: EQUAL
64733: IFTRUE 64737
64735: GO 64763
64737: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
64738: LD_ADDR_VAR 0 3
64742: PUSH
64743: LD_INT 21
64745: PUSH
64746: LD_INT 22
64748: PUSH
64749: LD_INT 23
64751: PUSH
64752: LD_INT 24
64754: PUSH
64755: EMPTY
64756: LIST
64757: LIST
64758: LIST
64759: LIST
64760: ST_TO_ADDR
64761: GO 64876
64763: LD_INT 52
64765: DOUBLE
64766: EQUAL
64767: IFTRUE 64771
64769: GO 64797
64771: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
64772: LD_ADDR_VAR 0 3
64776: PUSH
64777: LD_INT 21
64779: PUSH
64780: LD_INT 22
64782: PUSH
64783: LD_INT 23
64785: PUSH
64786: LD_INT 24
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: LIST
64793: LIST
64794: ST_TO_ADDR
64795: GO 64876
64797: LD_INT 53
64799: DOUBLE
64800: EQUAL
64801: IFTRUE 64805
64803: GO 64823
64805: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
64806: LD_ADDR_VAR 0 3
64810: PUSH
64811: LD_INT 23
64813: PUSH
64814: LD_INT 24
64816: PUSH
64817: EMPTY
64818: LIST
64819: LIST
64820: ST_TO_ADDR
64821: GO 64876
64823: LD_INT 46
64825: DOUBLE
64826: EQUAL
64827: IFTRUE 64831
64829: GO 64849
64831: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
64832: LD_ADDR_VAR 0 3
64836: PUSH
64837: LD_INT 23
64839: PUSH
64840: LD_INT 24
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: ST_TO_ADDR
64847: GO 64876
64849: LD_INT 47
64851: DOUBLE
64852: EQUAL
64853: IFTRUE 64857
64855: GO 64875
64857: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
64858: LD_ADDR_VAR 0 3
64862: PUSH
64863: LD_INT 23
64865: PUSH
64866: LD_INT 24
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: ST_TO_ADDR
64873: GO 64876
64875: POP
// result := ( chassis in result ) ;
64876: LD_ADDR_VAR 0 3
64880: PUSH
64881: LD_VAR 0 1
64885: PUSH
64886: LD_VAR 0 3
64890: IN
64891: ST_TO_ADDR
// end ;
64892: LD_VAR 0 3
64896: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
64897: LD_INT 0
64899: PPUSH
64900: PPUSH
64901: PPUSH
64902: PPUSH
64903: PPUSH
64904: PPUSH
64905: PPUSH
// result := array ;
64906: LD_ADDR_VAR 0 5
64910: PUSH
64911: LD_VAR 0 1
64915: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
64916: LD_VAR 0 1
64920: NOT
64921: PUSH
64922: LD_VAR 0 2
64926: NOT
64927: OR
64928: PUSH
64929: LD_VAR 0 3
64933: NOT
64934: OR
64935: PUSH
64936: LD_VAR 0 2
64940: PUSH
64941: LD_VAR 0 1
64945: GREATER
64946: OR
64947: PUSH
64948: LD_VAR 0 3
64952: PUSH
64953: LD_VAR 0 1
64957: GREATER
64958: OR
64959: IFFALSE 64963
// exit ;
64961: GO 65259
// if direction then
64963: LD_VAR 0 4
64967: IFFALSE 65031
// begin d := 1 ;
64969: LD_ADDR_VAR 0 9
64973: PUSH
64974: LD_INT 1
64976: ST_TO_ADDR
// if i_from > i_to then
64977: LD_VAR 0 2
64981: PUSH
64982: LD_VAR 0 3
64986: GREATER
64987: IFFALSE 65013
// length := ( array - i_from ) + i_to else
64989: LD_ADDR_VAR 0 11
64993: PUSH
64994: LD_VAR 0 1
64998: PUSH
64999: LD_VAR 0 2
65003: MINUS
65004: PUSH
65005: LD_VAR 0 3
65009: PLUS
65010: ST_TO_ADDR
65011: GO 65029
// length := i_to - i_from ;
65013: LD_ADDR_VAR 0 11
65017: PUSH
65018: LD_VAR 0 3
65022: PUSH
65023: LD_VAR 0 2
65027: MINUS
65028: ST_TO_ADDR
// end else
65029: GO 65092
// begin d := - 1 ;
65031: LD_ADDR_VAR 0 9
65035: PUSH
65036: LD_INT 1
65038: NEG
65039: ST_TO_ADDR
// if i_from > i_to then
65040: LD_VAR 0 2
65044: PUSH
65045: LD_VAR 0 3
65049: GREATER
65050: IFFALSE 65070
// length := i_from - i_to else
65052: LD_ADDR_VAR 0 11
65056: PUSH
65057: LD_VAR 0 2
65061: PUSH
65062: LD_VAR 0 3
65066: MINUS
65067: ST_TO_ADDR
65068: GO 65092
// length := ( array - i_to ) + i_from ;
65070: LD_ADDR_VAR 0 11
65074: PUSH
65075: LD_VAR 0 1
65079: PUSH
65080: LD_VAR 0 3
65084: MINUS
65085: PUSH
65086: LD_VAR 0 2
65090: PLUS
65091: ST_TO_ADDR
// end ; if not length then
65092: LD_VAR 0 11
65096: NOT
65097: IFFALSE 65101
// exit ;
65099: GO 65259
// tmp := array ;
65101: LD_ADDR_VAR 0 10
65105: PUSH
65106: LD_VAR 0 1
65110: ST_TO_ADDR
// for i = 1 to length do
65111: LD_ADDR_VAR 0 6
65115: PUSH
65116: DOUBLE
65117: LD_INT 1
65119: DEC
65120: ST_TO_ADDR
65121: LD_VAR 0 11
65125: PUSH
65126: FOR_TO
65127: IFFALSE 65247
// begin for j = 1 to array do
65129: LD_ADDR_VAR 0 7
65133: PUSH
65134: DOUBLE
65135: LD_INT 1
65137: DEC
65138: ST_TO_ADDR
65139: LD_VAR 0 1
65143: PUSH
65144: FOR_TO
65145: IFFALSE 65233
// begin k := j + d ;
65147: LD_ADDR_VAR 0 8
65151: PUSH
65152: LD_VAR 0 7
65156: PUSH
65157: LD_VAR 0 9
65161: PLUS
65162: ST_TO_ADDR
// if k > array then
65163: LD_VAR 0 8
65167: PUSH
65168: LD_VAR 0 1
65172: GREATER
65173: IFFALSE 65183
// k := 1 ;
65175: LD_ADDR_VAR 0 8
65179: PUSH
65180: LD_INT 1
65182: ST_TO_ADDR
// if not k then
65183: LD_VAR 0 8
65187: NOT
65188: IFFALSE 65200
// k := array ;
65190: LD_ADDR_VAR 0 8
65194: PUSH
65195: LD_VAR 0 1
65199: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
65200: LD_ADDR_VAR 0 10
65204: PUSH
65205: LD_VAR 0 10
65209: PPUSH
65210: LD_VAR 0 8
65214: PPUSH
65215: LD_VAR 0 1
65219: PUSH
65220: LD_VAR 0 7
65224: ARRAY
65225: PPUSH
65226: CALL_OW 1
65230: ST_TO_ADDR
// end ;
65231: GO 65144
65233: POP
65234: POP
// array := tmp ;
65235: LD_ADDR_VAR 0 1
65239: PUSH
65240: LD_VAR 0 10
65244: ST_TO_ADDR
// end ;
65245: GO 65126
65247: POP
65248: POP
// result := array ;
65249: LD_ADDR_VAR 0 5
65253: PUSH
65254: LD_VAR 0 1
65258: ST_TO_ADDR
// end ;
65259: LD_VAR 0 5
65263: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
65264: LD_INT 0
65266: PPUSH
65267: PPUSH
// result := 0 ;
65268: LD_ADDR_VAR 0 3
65272: PUSH
65273: LD_INT 0
65275: ST_TO_ADDR
// if not array or not value in array then
65276: LD_VAR 0 1
65280: NOT
65281: PUSH
65282: LD_VAR 0 2
65286: PUSH
65287: LD_VAR 0 1
65291: IN
65292: NOT
65293: OR
65294: IFFALSE 65298
// exit ;
65296: GO 65352
// for i = 1 to array do
65298: LD_ADDR_VAR 0 4
65302: PUSH
65303: DOUBLE
65304: LD_INT 1
65306: DEC
65307: ST_TO_ADDR
65308: LD_VAR 0 1
65312: PUSH
65313: FOR_TO
65314: IFFALSE 65350
// if value = array [ i ] then
65316: LD_VAR 0 2
65320: PUSH
65321: LD_VAR 0 1
65325: PUSH
65326: LD_VAR 0 4
65330: ARRAY
65331: EQUAL
65332: IFFALSE 65348
// begin result := i ;
65334: LD_ADDR_VAR 0 3
65338: PUSH
65339: LD_VAR 0 4
65343: ST_TO_ADDR
// exit ;
65344: POP
65345: POP
65346: GO 65352
// end ;
65348: GO 65313
65350: POP
65351: POP
// end ;
65352: LD_VAR 0 3
65356: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
65357: LD_INT 0
65359: PPUSH
// vc_chassis := chassis ;
65360: LD_ADDR_OWVAR 37
65364: PUSH
65365: LD_VAR 0 1
65369: ST_TO_ADDR
// vc_engine := engine ;
65370: LD_ADDR_OWVAR 39
65374: PUSH
65375: LD_VAR 0 2
65379: ST_TO_ADDR
// vc_control := control ;
65380: LD_ADDR_OWVAR 38
65384: PUSH
65385: LD_VAR 0 3
65389: ST_TO_ADDR
// vc_weapon := weapon ;
65390: LD_ADDR_OWVAR 40
65394: PUSH
65395: LD_VAR 0 4
65399: ST_TO_ADDR
// vc_fuel_battery := fuel ;
65400: LD_ADDR_OWVAR 41
65404: PUSH
65405: LD_VAR 0 5
65409: ST_TO_ADDR
// end ;
65410: LD_VAR 0 6
65414: RET
// export function WantPlant ( unit ) ; var task ; begin
65415: LD_INT 0
65417: PPUSH
65418: PPUSH
// result := false ;
65419: LD_ADDR_VAR 0 2
65423: PUSH
65424: LD_INT 0
65426: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
65427: LD_ADDR_VAR 0 3
65431: PUSH
65432: LD_VAR 0 1
65436: PPUSH
65437: CALL_OW 437
65441: ST_TO_ADDR
// if task then
65442: LD_VAR 0 3
65446: IFFALSE 65474
// if task [ 1 ] [ 1 ] = p then
65448: LD_VAR 0 3
65452: PUSH
65453: LD_INT 1
65455: ARRAY
65456: PUSH
65457: LD_INT 1
65459: ARRAY
65460: PUSH
65461: LD_STRING p
65463: EQUAL
65464: IFFALSE 65474
// result := true ;
65466: LD_ADDR_VAR 0 2
65470: PUSH
65471: LD_INT 1
65473: ST_TO_ADDR
// end ;
65474: LD_VAR 0 2
65478: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
65479: LD_INT 0
65481: PPUSH
65482: PPUSH
65483: PPUSH
65484: PPUSH
// if pos < 1 then
65485: LD_VAR 0 2
65489: PUSH
65490: LD_INT 1
65492: LESS
65493: IFFALSE 65497
// exit ;
65495: GO 65800
// if pos = 1 then
65497: LD_VAR 0 2
65501: PUSH
65502: LD_INT 1
65504: EQUAL
65505: IFFALSE 65538
// result := Replace ( arr , pos [ 1 ] , value ) else
65507: LD_ADDR_VAR 0 4
65511: PUSH
65512: LD_VAR 0 1
65516: PPUSH
65517: LD_VAR 0 2
65521: PUSH
65522: LD_INT 1
65524: ARRAY
65525: PPUSH
65526: LD_VAR 0 3
65530: PPUSH
65531: CALL_OW 1
65535: ST_TO_ADDR
65536: GO 65800
// begin tmp := arr ;
65538: LD_ADDR_VAR 0 6
65542: PUSH
65543: LD_VAR 0 1
65547: ST_TO_ADDR
// s_arr := [ tmp ] ;
65548: LD_ADDR_VAR 0 7
65552: PUSH
65553: LD_VAR 0 6
65557: PUSH
65558: EMPTY
65559: LIST
65560: ST_TO_ADDR
// for i = 1 to pos - 1 do
65561: LD_ADDR_VAR 0 5
65565: PUSH
65566: DOUBLE
65567: LD_INT 1
65569: DEC
65570: ST_TO_ADDR
65571: LD_VAR 0 2
65575: PUSH
65576: LD_INT 1
65578: MINUS
65579: PUSH
65580: FOR_TO
65581: IFFALSE 65626
// begin tmp := tmp [ pos [ i ] ] ;
65583: LD_ADDR_VAR 0 6
65587: PUSH
65588: LD_VAR 0 6
65592: PUSH
65593: LD_VAR 0 2
65597: PUSH
65598: LD_VAR 0 5
65602: ARRAY
65603: ARRAY
65604: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
65605: LD_ADDR_VAR 0 7
65609: PUSH
65610: LD_VAR 0 7
65614: PUSH
65615: LD_VAR 0 6
65619: PUSH
65620: EMPTY
65621: LIST
65622: ADD
65623: ST_TO_ADDR
// end ;
65624: GO 65580
65626: POP
65627: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
65628: LD_ADDR_VAR 0 6
65632: PUSH
65633: LD_VAR 0 6
65637: PPUSH
65638: LD_VAR 0 2
65642: PUSH
65643: LD_VAR 0 2
65647: ARRAY
65648: PPUSH
65649: LD_VAR 0 3
65653: PPUSH
65654: CALL_OW 1
65658: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
65659: LD_ADDR_VAR 0 7
65663: PUSH
65664: LD_VAR 0 7
65668: PPUSH
65669: LD_VAR 0 7
65673: PPUSH
65674: LD_VAR 0 6
65678: PPUSH
65679: CALL_OW 1
65683: ST_TO_ADDR
// for i = s_arr downto 2 do
65684: LD_ADDR_VAR 0 5
65688: PUSH
65689: DOUBLE
65690: LD_VAR 0 7
65694: INC
65695: ST_TO_ADDR
65696: LD_INT 2
65698: PUSH
65699: FOR_DOWNTO
65700: IFFALSE 65784
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
65702: LD_ADDR_VAR 0 6
65706: PUSH
65707: LD_VAR 0 7
65711: PUSH
65712: LD_VAR 0 5
65716: PUSH
65717: LD_INT 1
65719: MINUS
65720: ARRAY
65721: PPUSH
65722: LD_VAR 0 2
65726: PUSH
65727: LD_VAR 0 5
65731: PUSH
65732: LD_INT 1
65734: MINUS
65735: ARRAY
65736: PPUSH
65737: LD_VAR 0 7
65741: PUSH
65742: LD_VAR 0 5
65746: ARRAY
65747: PPUSH
65748: CALL_OW 1
65752: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
65753: LD_ADDR_VAR 0 7
65757: PUSH
65758: LD_VAR 0 7
65762: PPUSH
65763: LD_VAR 0 5
65767: PUSH
65768: LD_INT 1
65770: MINUS
65771: PPUSH
65772: LD_VAR 0 6
65776: PPUSH
65777: CALL_OW 1
65781: ST_TO_ADDR
// end ;
65782: GO 65699
65784: POP
65785: POP
// result := s_arr [ 1 ] ;
65786: LD_ADDR_VAR 0 4
65790: PUSH
65791: LD_VAR 0 7
65795: PUSH
65796: LD_INT 1
65798: ARRAY
65799: ST_TO_ADDR
// end ; end ;
65800: LD_VAR 0 4
65804: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
65805: LD_INT 0
65807: PPUSH
65808: PPUSH
// if not list then
65809: LD_VAR 0 1
65813: NOT
65814: IFFALSE 65818
// exit ;
65816: GO 65909
// i := list [ pos1 ] ;
65818: LD_ADDR_VAR 0 5
65822: PUSH
65823: LD_VAR 0 1
65827: PUSH
65828: LD_VAR 0 2
65832: ARRAY
65833: ST_TO_ADDR
// if not i then
65834: LD_VAR 0 5
65838: NOT
65839: IFFALSE 65843
// exit ;
65841: GO 65909
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
65843: LD_ADDR_VAR 0 1
65847: PUSH
65848: LD_VAR 0 1
65852: PPUSH
65853: LD_VAR 0 2
65857: PPUSH
65858: LD_VAR 0 1
65862: PUSH
65863: LD_VAR 0 3
65867: ARRAY
65868: PPUSH
65869: CALL_OW 1
65873: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
65874: LD_ADDR_VAR 0 1
65878: PUSH
65879: LD_VAR 0 1
65883: PPUSH
65884: LD_VAR 0 3
65888: PPUSH
65889: LD_VAR 0 5
65893: PPUSH
65894: CALL_OW 1
65898: ST_TO_ADDR
// result := list ;
65899: LD_ADDR_VAR 0 4
65903: PUSH
65904: LD_VAR 0 1
65908: ST_TO_ADDR
// end ;
65909: LD_VAR 0 4
65913: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
65914: LD_INT 0
65916: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
65917: LD_ADDR_VAR 0 5
65921: PUSH
65922: LD_VAR 0 1
65926: PPUSH
65927: CALL_OW 250
65931: PPUSH
65932: LD_VAR 0 1
65936: PPUSH
65937: CALL_OW 251
65941: PPUSH
65942: LD_VAR 0 2
65946: PPUSH
65947: LD_VAR 0 3
65951: PPUSH
65952: LD_VAR 0 4
65956: PPUSH
65957: CALL 65967 0 5
65961: ST_TO_ADDR
// end ;
65962: LD_VAR 0 5
65966: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
65967: LD_INT 0
65969: PPUSH
65970: PPUSH
65971: PPUSH
65972: PPUSH
// if not list then
65973: LD_VAR 0 3
65977: NOT
65978: IFFALSE 65982
// exit ;
65980: GO 66370
// result := [ ] ;
65982: LD_ADDR_VAR 0 6
65986: PUSH
65987: EMPTY
65988: ST_TO_ADDR
// for i in list do
65989: LD_ADDR_VAR 0 7
65993: PUSH
65994: LD_VAR 0 3
65998: PUSH
65999: FOR_IN
66000: IFFALSE 66202
// begin tmp := GetDistUnitXY ( i , x , y ) ;
66002: LD_ADDR_VAR 0 9
66006: PUSH
66007: LD_VAR 0 7
66011: PPUSH
66012: LD_VAR 0 1
66016: PPUSH
66017: LD_VAR 0 2
66021: PPUSH
66022: CALL_OW 297
66026: ST_TO_ADDR
// if not result then
66027: LD_VAR 0 6
66031: NOT
66032: IFFALSE 66058
// result := [ [ i , tmp ] ] else
66034: LD_ADDR_VAR 0 6
66038: PUSH
66039: LD_VAR 0 7
66043: PUSH
66044: LD_VAR 0 9
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: PUSH
66053: EMPTY
66054: LIST
66055: ST_TO_ADDR
66056: GO 66200
// begin if result [ result ] [ 2 ] < tmp then
66058: LD_VAR 0 6
66062: PUSH
66063: LD_VAR 0 6
66067: ARRAY
66068: PUSH
66069: LD_INT 2
66071: ARRAY
66072: PUSH
66073: LD_VAR 0 9
66077: LESS
66078: IFFALSE 66120
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
66080: LD_ADDR_VAR 0 6
66084: PUSH
66085: LD_VAR 0 6
66089: PPUSH
66090: LD_VAR 0 6
66094: PUSH
66095: LD_INT 1
66097: PLUS
66098: PPUSH
66099: LD_VAR 0 7
66103: PUSH
66104: LD_VAR 0 9
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PPUSH
66113: CALL_OW 2
66117: ST_TO_ADDR
66118: GO 66200
// for j = 1 to result do
66120: LD_ADDR_VAR 0 8
66124: PUSH
66125: DOUBLE
66126: LD_INT 1
66128: DEC
66129: ST_TO_ADDR
66130: LD_VAR 0 6
66134: PUSH
66135: FOR_TO
66136: IFFALSE 66198
// begin if tmp < result [ j ] [ 2 ] then
66138: LD_VAR 0 9
66142: PUSH
66143: LD_VAR 0 6
66147: PUSH
66148: LD_VAR 0 8
66152: ARRAY
66153: PUSH
66154: LD_INT 2
66156: ARRAY
66157: LESS
66158: IFFALSE 66196
// begin result := Insert ( result , j , [ i , tmp ] ) ;
66160: LD_ADDR_VAR 0 6
66164: PUSH
66165: LD_VAR 0 6
66169: PPUSH
66170: LD_VAR 0 8
66174: PPUSH
66175: LD_VAR 0 7
66179: PUSH
66180: LD_VAR 0 9
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PPUSH
66189: CALL_OW 2
66193: ST_TO_ADDR
// break ;
66194: GO 66198
// end ; end ;
66196: GO 66135
66198: POP
66199: POP
// end ; end ;
66200: GO 65999
66202: POP
66203: POP
// if result and not asc then
66204: LD_VAR 0 6
66208: PUSH
66209: LD_VAR 0 4
66213: NOT
66214: AND
66215: IFFALSE 66290
// begin tmp := result ;
66217: LD_ADDR_VAR 0 9
66221: PUSH
66222: LD_VAR 0 6
66226: ST_TO_ADDR
// for i = tmp downto 1 do
66227: LD_ADDR_VAR 0 7
66231: PUSH
66232: DOUBLE
66233: LD_VAR 0 9
66237: INC
66238: ST_TO_ADDR
66239: LD_INT 1
66241: PUSH
66242: FOR_DOWNTO
66243: IFFALSE 66288
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
66245: LD_ADDR_VAR 0 6
66249: PUSH
66250: LD_VAR 0 6
66254: PPUSH
66255: LD_VAR 0 9
66259: PUSH
66260: LD_VAR 0 7
66264: MINUS
66265: PUSH
66266: LD_INT 1
66268: PLUS
66269: PPUSH
66270: LD_VAR 0 9
66274: PUSH
66275: LD_VAR 0 7
66279: ARRAY
66280: PPUSH
66281: CALL_OW 1
66285: ST_TO_ADDR
66286: GO 66242
66288: POP
66289: POP
// end ; tmp := [ ] ;
66290: LD_ADDR_VAR 0 9
66294: PUSH
66295: EMPTY
66296: ST_TO_ADDR
// if mode then
66297: LD_VAR 0 5
66301: IFFALSE 66370
// begin for i = 1 to result do
66303: LD_ADDR_VAR 0 7
66307: PUSH
66308: DOUBLE
66309: LD_INT 1
66311: DEC
66312: ST_TO_ADDR
66313: LD_VAR 0 6
66317: PUSH
66318: FOR_TO
66319: IFFALSE 66358
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
66321: LD_ADDR_VAR 0 9
66325: PUSH
66326: LD_VAR 0 9
66330: PPUSH
66331: LD_VAR 0 7
66335: PPUSH
66336: LD_VAR 0 6
66340: PUSH
66341: LD_VAR 0 7
66345: ARRAY
66346: PUSH
66347: LD_INT 1
66349: ARRAY
66350: PPUSH
66351: CALL_OW 1
66355: ST_TO_ADDR
66356: GO 66318
66358: POP
66359: POP
// result := tmp ;
66360: LD_ADDR_VAR 0 6
66364: PUSH
66365: LD_VAR 0 9
66369: ST_TO_ADDR
// end ; end ;
66370: LD_VAR 0 6
66374: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
66375: LD_INT 0
66377: PPUSH
66378: PPUSH
66379: PPUSH
66380: PPUSH
66381: PPUSH
66382: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
66383: LD_ADDR_VAR 0 5
66387: PUSH
66388: LD_INT 0
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: LD_INT 0
66396: PUSH
66397: EMPTY
66398: PUSH
66399: EMPTY
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: ST_TO_ADDR
// if not x or not y then
66405: LD_VAR 0 2
66409: NOT
66410: PUSH
66411: LD_VAR 0 3
66415: NOT
66416: OR
66417: IFFALSE 66421
// exit ;
66419: GO 68067
// if not range then
66421: LD_VAR 0 4
66425: NOT
66426: IFFALSE 66436
// range := 10 ;
66428: LD_ADDR_VAR 0 4
66432: PUSH
66433: LD_INT 10
66435: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66436: LD_ADDR_VAR 0 8
66440: PUSH
66441: LD_INT 81
66443: PUSH
66444: LD_VAR 0 1
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 92
66455: PUSH
66456: LD_VAR 0 2
66460: PUSH
66461: LD_VAR 0 3
66465: PUSH
66466: LD_VAR 0 4
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: PUSH
66477: LD_INT 3
66479: PUSH
66480: LD_INT 21
66482: PUSH
66483: LD_INT 3
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: LIST
66498: PPUSH
66499: CALL_OW 69
66503: ST_TO_ADDR
// if not tmp then
66504: LD_VAR 0 8
66508: NOT
66509: IFFALSE 66513
// exit ;
66511: GO 68067
// for i in tmp do
66513: LD_ADDR_VAR 0 6
66517: PUSH
66518: LD_VAR 0 8
66522: PUSH
66523: FOR_IN
66524: IFFALSE 68042
// begin points := [ 0 , 0 , 0 ] ;
66526: LD_ADDR_VAR 0 9
66530: PUSH
66531: LD_INT 0
66533: PUSH
66534: LD_INT 0
66536: PUSH
66537: LD_INT 0
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: LIST
66544: ST_TO_ADDR
// bpoints := 1 ;
66545: LD_ADDR_VAR 0 10
66549: PUSH
66550: LD_INT 1
66552: ST_TO_ADDR
// case GetType ( i ) of unit_human :
66553: LD_VAR 0 6
66557: PPUSH
66558: CALL_OW 247
66562: PUSH
66563: LD_INT 1
66565: DOUBLE
66566: EQUAL
66567: IFTRUE 66571
66569: GO 67149
66571: POP
// begin if GetClass ( i ) = 1 then
66572: LD_VAR 0 6
66576: PPUSH
66577: CALL_OW 257
66581: PUSH
66582: LD_INT 1
66584: EQUAL
66585: IFFALSE 66606
// points := [ 10 , 5 , 3 ] ;
66587: LD_ADDR_VAR 0 9
66591: PUSH
66592: LD_INT 10
66594: PUSH
66595: LD_INT 5
66597: PUSH
66598: LD_INT 3
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: LIST
66605: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
66606: LD_VAR 0 6
66610: PPUSH
66611: CALL_OW 257
66615: PUSH
66616: LD_INT 2
66618: PUSH
66619: LD_INT 3
66621: PUSH
66622: LD_INT 4
66624: PUSH
66625: EMPTY
66626: LIST
66627: LIST
66628: LIST
66629: IN
66630: IFFALSE 66651
// points := [ 3 , 2 , 1 ] ;
66632: LD_ADDR_VAR 0 9
66636: PUSH
66637: LD_INT 3
66639: PUSH
66640: LD_INT 2
66642: PUSH
66643: LD_INT 1
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: LIST
66650: ST_TO_ADDR
// if GetClass ( i ) = 5 then
66651: LD_VAR 0 6
66655: PPUSH
66656: CALL_OW 257
66660: PUSH
66661: LD_INT 5
66663: EQUAL
66664: IFFALSE 66685
// points := [ 130 , 5 , 2 ] ;
66666: LD_ADDR_VAR 0 9
66670: PUSH
66671: LD_INT 130
66673: PUSH
66674: LD_INT 5
66676: PUSH
66677: LD_INT 2
66679: PUSH
66680: EMPTY
66681: LIST
66682: LIST
66683: LIST
66684: ST_TO_ADDR
// if GetClass ( i ) = 8 then
66685: LD_VAR 0 6
66689: PPUSH
66690: CALL_OW 257
66694: PUSH
66695: LD_INT 8
66697: EQUAL
66698: IFFALSE 66719
// points := [ 35 , 35 , 30 ] ;
66700: LD_ADDR_VAR 0 9
66704: PUSH
66705: LD_INT 35
66707: PUSH
66708: LD_INT 35
66710: PUSH
66711: LD_INT 30
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: LIST
66718: ST_TO_ADDR
// if GetClass ( i ) = 9 then
66719: LD_VAR 0 6
66723: PPUSH
66724: CALL_OW 257
66728: PUSH
66729: LD_INT 9
66731: EQUAL
66732: IFFALSE 66753
// points := [ 20 , 55 , 40 ] ;
66734: LD_ADDR_VAR 0 9
66738: PUSH
66739: LD_INT 20
66741: PUSH
66742: LD_INT 55
66744: PUSH
66745: LD_INT 40
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: LIST
66752: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
66753: LD_VAR 0 6
66757: PPUSH
66758: CALL_OW 257
66762: PUSH
66763: LD_INT 12
66765: PUSH
66766: LD_INT 16
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: IN
66773: IFFALSE 66794
// points := [ 5 , 3 , 2 ] ;
66775: LD_ADDR_VAR 0 9
66779: PUSH
66780: LD_INT 5
66782: PUSH
66783: LD_INT 3
66785: PUSH
66786: LD_INT 2
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: LIST
66793: ST_TO_ADDR
// if GetClass ( i ) = 17 then
66794: LD_VAR 0 6
66798: PPUSH
66799: CALL_OW 257
66803: PUSH
66804: LD_INT 17
66806: EQUAL
66807: IFFALSE 66828
// points := [ 100 , 50 , 75 ] ;
66809: LD_ADDR_VAR 0 9
66813: PUSH
66814: LD_INT 100
66816: PUSH
66817: LD_INT 50
66819: PUSH
66820: LD_INT 75
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: LIST
66827: ST_TO_ADDR
// if GetClass ( i ) = 15 then
66828: LD_VAR 0 6
66832: PPUSH
66833: CALL_OW 257
66837: PUSH
66838: LD_INT 15
66840: EQUAL
66841: IFFALSE 66862
// points := [ 10 , 5 , 3 ] ;
66843: LD_ADDR_VAR 0 9
66847: PUSH
66848: LD_INT 10
66850: PUSH
66851: LD_INT 5
66853: PUSH
66854: LD_INT 3
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: LIST
66861: ST_TO_ADDR
// if GetClass ( i ) = 14 then
66862: LD_VAR 0 6
66866: PPUSH
66867: CALL_OW 257
66871: PUSH
66872: LD_INT 14
66874: EQUAL
66875: IFFALSE 66896
// points := [ 10 , 0 , 0 ] ;
66877: LD_ADDR_VAR 0 9
66881: PUSH
66882: LD_INT 10
66884: PUSH
66885: LD_INT 0
66887: PUSH
66888: LD_INT 0
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: LIST
66895: ST_TO_ADDR
// if GetClass ( i ) = 11 then
66896: LD_VAR 0 6
66900: PPUSH
66901: CALL_OW 257
66905: PUSH
66906: LD_INT 11
66908: EQUAL
66909: IFFALSE 66930
// points := [ 30 , 10 , 5 ] ;
66911: LD_ADDR_VAR 0 9
66915: PUSH
66916: LD_INT 30
66918: PUSH
66919: LD_INT 10
66921: PUSH
66922: LD_INT 5
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: LIST
66929: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
66930: LD_VAR 0 1
66934: PPUSH
66935: LD_INT 5
66937: PPUSH
66938: CALL_OW 321
66942: PUSH
66943: LD_INT 2
66945: EQUAL
66946: IFFALSE 66963
// bpoints := bpoints * 1.8 ;
66948: LD_ADDR_VAR 0 10
66952: PUSH
66953: LD_VAR 0 10
66957: PUSH
66958: LD_REAL  1.80000000000000E+0000
66961: MUL
66962: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
66963: LD_VAR 0 6
66967: PPUSH
66968: CALL_OW 257
66972: PUSH
66973: LD_INT 1
66975: PUSH
66976: LD_INT 2
66978: PUSH
66979: LD_INT 3
66981: PUSH
66982: LD_INT 4
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: LIST
66989: LIST
66990: IN
66991: PUSH
66992: LD_VAR 0 1
66996: PPUSH
66997: LD_INT 51
66999: PPUSH
67000: CALL_OW 321
67004: PUSH
67005: LD_INT 2
67007: EQUAL
67008: AND
67009: IFFALSE 67026
// bpoints := bpoints * 1.2 ;
67011: LD_ADDR_VAR 0 10
67015: PUSH
67016: LD_VAR 0 10
67020: PUSH
67021: LD_REAL  1.20000000000000E+0000
67024: MUL
67025: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
67026: LD_VAR 0 6
67030: PPUSH
67031: CALL_OW 257
67035: PUSH
67036: LD_INT 5
67038: PUSH
67039: LD_INT 7
67041: PUSH
67042: LD_INT 9
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: LIST
67049: IN
67050: PUSH
67051: LD_VAR 0 1
67055: PPUSH
67056: LD_INT 52
67058: PPUSH
67059: CALL_OW 321
67063: PUSH
67064: LD_INT 2
67066: EQUAL
67067: AND
67068: IFFALSE 67085
// bpoints := bpoints * 1.5 ;
67070: LD_ADDR_VAR 0 10
67074: PUSH
67075: LD_VAR 0 10
67079: PUSH
67080: LD_REAL  1.50000000000000E+0000
67083: MUL
67084: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
67085: LD_VAR 0 1
67089: PPUSH
67090: LD_INT 66
67092: PPUSH
67093: CALL_OW 321
67097: PUSH
67098: LD_INT 2
67100: EQUAL
67101: IFFALSE 67118
// bpoints := bpoints * 1.1 ;
67103: LD_ADDR_VAR 0 10
67107: PUSH
67108: LD_VAR 0 10
67112: PUSH
67113: LD_REAL  1.10000000000000E+0000
67116: MUL
67117: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
67118: LD_ADDR_VAR 0 10
67122: PUSH
67123: LD_VAR 0 10
67127: PUSH
67128: LD_VAR 0 6
67132: PPUSH
67133: LD_INT 1
67135: PPUSH
67136: CALL_OW 259
67140: PUSH
67141: LD_REAL  1.15000000000000E+0000
67144: MUL
67145: MUL
67146: ST_TO_ADDR
// end ; unit_vehicle :
67147: GO 67971
67149: LD_INT 2
67151: DOUBLE
67152: EQUAL
67153: IFTRUE 67157
67155: GO 67959
67157: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
67158: LD_VAR 0 6
67162: PPUSH
67163: CALL_OW 264
67167: PUSH
67168: LD_INT 2
67170: PUSH
67171: LD_INT 42
67173: PUSH
67174: LD_INT 24
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: LIST
67181: IN
67182: IFFALSE 67203
// points := [ 25 , 5 , 3 ] ;
67184: LD_ADDR_VAR 0 9
67188: PUSH
67189: LD_INT 25
67191: PUSH
67192: LD_INT 5
67194: PUSH
67195: LD_INT 3
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: LIST
67202: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
67203: LD_VAR 0 6
67207: PPUSH
67208: CALL_OW 264
67212: PUSH
67213: LD_INT 4
67215: PUSH
67216: LD_INT 43
67218: PUSH
67219: LD_INT 25
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: LIST
67226: IN
67227: IFFALSE 67248
// points := [ 40 , 15 , 5 ] ;
67229: LD_ADDR_VAR 0 9
67233: PUSH
67234: LD_INT 40
67236: PUSH
67237: LD_INT 15
67239: PUSH
67240: LD_INT 5
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: LIST
67247: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
67248: LD_VAR 0 6
67252: PPUSH
67253: CALL_OW 264
67257: PUSH
67258: LD_INT 3
67260: PUSH
67261: LD_INT 23
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: IN
67268: IFFALSE 67289
// points := [ 7 , 25 , 8 ] ;
67270: LD_ADDR_VAR 0 9
67274: PUSH
67275: LD_INT 7
67277: PUSH
67278: LD_INT 25
67280: PUSH
67281: LD_INT 8
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: LIST
67288: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
67289: LD_VAR 0 6
67293: PPUSH
67294: CALL_OW 264
67298: PUSH
67299: LD_INT 5
67301: PUSH
67302: LD_INT 27
67304: PUSH
67305: LD_INT 44
67307: PUSH
67308: EMPTY
67309: LIST
67310: LIST
67311: LIST
67312: IN
67313: IFFALSE 67334
// points := [ 14 , 50 , 16 ] ;
67315: LD_ADDR_VAR 0 9
67319: PUSH
67320: LD_INT 14
67322: PUSH
67323: LD_INT 50
67325: PUSH
67326: LD_INT 16
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: LIST
67333: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
67334: LD_VAR 0 6
67338: PPUSH
67339: CALL_OW 264
67343: PUSH
67344: LD_INT 6
67346: PUSH
67347: LD_INT 46
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: IN
67354: IFFALSE 67375
// points := [ 32 , 120 , 70 ] ;
67356: LD_ADDR_VAR 0 9
67360: PUSH
67361: LD_INT 32
67363: PUSH
67364: LD_INT 120
67366: PUSH
67367: LD_INT 70
67369: PUSH
67370: EMPTY
67371: LIST
67372: LIST
67373: LIST
67374: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
67375: LD_VAR 0 6
67379: PPUSH
67380: CALL_OW 264
67384: PUSH
67385: LD_INT 7
67387: PUSH
67388: LD_INT 28
67390: PUSH
67391: LD_INT 45
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: LIST
67398: IN
67399: IFFALSE 67420
// points := [ 35 , 20 , 45 ] ;
67401: LD_ADDR_VAR 0 9
67405: PUSH
67406: LD_INT 35
67408: PUSH
67409: LD_INT 20
67411: PUSH
67412: LD_INT 45
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: LIST
67419: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
67420: LD_VAR 0 6
67424: PPUSH
67425: CALL_OW 264
67429: PUSH
67430: LD_INT 47
67432: PUSH
67433: EMPTY
67434: LIST
67435: IN
67436: IFFALSE 67457
// points := [ 67 , 45 , 75 ] ;
67438: LD_ADDR_VAR 0 9
67442: PUSH
67443: LD_INT 67
67445: PUSH
67446: LD_INT 45
67448: PUSH
67449: LD_INT 75
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: LIST
67456: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
67457: LD_VAR 0 6
67461: PPUSH
67462: CALL_OW 264
67466: PUSH
67467: LD_INT 26
67469: PUSH
67470: EMPTY
67471: LIST
67472: IN
67473: IFFALSE 67494
// points := [ 120 , 30 , 80 ] ;
67475: LD_ADDR_VAR 0 9
67479: PUSH
67480: LD_INT 120
67482: PUSH
67483: LD_INT 30
67485: PUSH
67486: LD_INT 80
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: LIST
67493: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
67494: LD_VAR 0 6
67498: PPUSH
67499: CALL_OW 264
67503: PUSH
67504: LD_INT 22
67506: PUSH
67507: EMPTY
67508: LIST
67509: IN
67510: IFFALSE 67531
// points := [ 40 , 1 , 1 ] ;
67512: LD_ADDR_VAR 0 9
67516: PUSH
67517: LD_INT 40
67519: PUSH
67520: LD_INT 1
67522: PUSH
67523: LD_INT 1
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: LIST
67530: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
67531: LD_VAR 0 6
67535: PPUSH
67536: CALL_OW 264
67540: PUSH
67541: LD_INT 29
67543: PUSH
67544: EMPTY
67545: LIST
67546: IN
67547: IFFALSE 67568
// points := [ 70 , 200 , 400 ] ;
67549: LD_ADDR_VAR 0 9
67553: PUSH
67554: LD_INT 70
67556: PUSH
67557: LD_INT 200
67559: PUSH
67560: LD_INT 400
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: LIST
67567: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
67568: LD_VAR 0 6
67572: PPUSH
67573: CALL_OW 264
67577: PUSH
67578: LD_INT 14
67580: PUSH
67581: LD_INT 53
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: IN
67588: IFFALSE 67609
// points := [ 40 , 10 , 20 ] ;
67590: LD_ADDR_VAR 0 9
67594: PUSH
67595: LD_INT 40
67597: PUSH
67598: LD_INT 10
67600: PUSH
67601: LD_INT 20
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: LIST
67608: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
67609: LD_VAR 0 6
67613: PPUSH
67614: CALL_OW 264
67618: PUSH
67619: LD_INT 9
67621: PUSH
67622: EMPTY
67623: LIST
67624: IN
67625: IFFALSE 67646
// points := [ 5 , 70 , 20 ] ;
67627: LD_ADDR_VAR 0 9
67631: PUSH
67632: LD_INT 5
67634: PUSH
67635: LD_INT 70
67637: PUSH
67638: LD_INT 20
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: LIST
67645: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
67646: LD_VAR 0 6
67650: PPUSH
67651: CALL_OW 264
67655: PUSH
67656: LD_INT 10
67658: PUSH
67659: EMPTY
67660: LIST
67661: IN
67662: IFFALSE 67683
// points := [ 35 , 110 , 70 ] ;
67664: LD_ADDR_VAR 0 9
67668: PUSH
67669: LD_INT 35
67671: PUSH
67672: LD_INT 110
67674: PUSH
67675: LD_INT 70
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: LIST
67682: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
67683: LD_VAR 0 6
67687: PPUSH
67688: CALL_OW 265
67692: PUSH
67693: LD_INT 25
67695: EQUAL
67696: IFFALSE 67717
// points := [ 80 , 65 , 100 ] ;
67698: LD_ADDR_VAR 0 9
67702: PUSH
67703: LD_INT 80
67705: PUSH
67706: LD_INT 65
67708: PUSH
67709: LD_INT 100
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: LIST
67716: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
67717: LD_VAR 0 6
67721: PPUSH
67722: CALL_OW 263
67726: PUSH
67727: LD_INT 1
67729: EQUAL
67730: IFFALSE 67765
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
67732: LD_ADDR_VAR 0 10
67736: PUSH
67737: LD_VAR 0 10
67741: PUSH
67742: LD_VAR 0 6
67746: PPUSH
67747: CALL_OW 311
67751: PPUSH
67752: LD_INT 3
67754: PPUSH
67755: CALL_OW 259
67759: PUSH
67760: LD_INT 4
67762: MUL
67763: MUL
67764: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
67765: LD_VAR 0 6
67769: PPUSH
67770: CALL_OW 263
67774: PUSH
67775: LD_INT 2
67777: EQUAL
67778: IFFALSE 67829
// begin j := IsControledBy ( i ) ;
67780: LD_ADDR_VAR 0 7
67784: PUSH
67785: LD_VAR 0 6
67789: PPUSH
67790: CALL_OW 312
67794: ST_TO_ADDR
// if j then
67795: LD_VAR 0 7
67799: IFFALSE 67829
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
67801: LD_ADDR_VAR 0 10
67805: PUSH
67806: LD_VAR 0 10
67810: PUSH
67811: LD_VAR 0 7
67815: PPUSH
67816: LD_INT 3
67818: PPUSH
67819: CALL_OW 259
67823: PUSH
67824: LD_INT 3
67826: MUL
67827: MUL
67828: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
67829: LD_VAR 0 6
67833: PPUSH
67834: CALL_OW 264
67838: PUSH
67839: LD_INT 5
67841: PUSH
67842: LD_INT 6
67844: PUSH
67845: LD_INT 46
67847: PUSH
67848: LD_INT 44
67850: PUSH
67851: LD_INT 47
67853: PUSH
67854: LD_INT 45
67856: PUSH
67857: LD_INT 28
67859: PUSH
67860: LD_INT 7
67862: PUSH
67863: LD_INT 27
67865: PUSH
67866: LD_INT 29
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: IN
67881: PUSH
67882: LD_VAR 0 1
67886: PPUSH
67887: LD_INT 52
67889: PPUSH
67890: CALL_OW 321
67894: PUSH
67895: LD_INT 2
67897: EQUAL
67898: AND
67899: IFFALSE 67916
// bpoints := bpoints * 1.2 ;
67901: LD_ADDR_VAR 0 10
67905: PUSH
67906: LD_VAR 0 10
67910: PUSH
67911: LD_REAL  1.20000000000000E+0000
67914: MUL
67915: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
67916: LD_VAR 0 6
67920: PPUSH
67921: CALL_OW 264
67925: PUSH
67926: LD_INT 6
67928: PUSH
67929: LD_INT 46
67931: PUSH
67932: LD_INT 47
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: LIST
67939: IN
67940: IFFALSE 67957
// bpoints := bpoints * 1.2 ;
67942: LD_ADDR_VAR 0 10
67946: PUSH
67947: LD_VAR 0 10
67951: PUSH
67952: LD_REAL  1.20000000000000E+0000
67955: MUL
67956: ST_TO_ADDR
// end ; unit_building :
67957: GO 67971
67959: LD_INT 3
67961: DOUBLE
67962: EQUAL
67963: IFTRUE 67967
67965: GO 67970
67967: POP
// ; end ;
67968: GO 67971
67970: POP
// for j = 1 to 3 do
67971: LD_ADDR_VAR 0 7
67975: PUSH
67976: DOUBLE
67977: LD_INT 1
67979: DEC
67980: ST_TO_ADDR
67981: LD_INT 3
67983: PUSH
67984: FOR_TO
67985: IFFALSE 68038
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
67987: LD_ADDR_VAR 0 5
67991: PUSH
67992: LD_VAR 0 5
67996: PPUSH
67997: LD_VAR 0 7
68001: PPUSH
68002: LD_VAR 0 5
68006: PUSH
68007: LD_VAR 0 7
68011: ARRAY
68012: PUSH
68013: LD_VAR 0 9
68017: PUSH
68018: LD_VAR 0 7
68022: ARRAY
68023: PUSH
68024: LD_VAR 0 10
68028: MUL
68029: PLUS
68030: PPUSH
68031: CALL_OW 1
68035: ST_TO_ADDR
68036: GO 67984
68038: POP
68039: POP
// end ;
68040: GO 66523
68042: POP
68043: POP
// result := Replace ( result , 4 , tmp ) ;
68044: LD_ADDR_VAR 0 5
68048: PUSH
68049: LD_VAR 0 5
68053: PPUSH
68054: LD_INT 4
68056: PPUSH
68057: LD_VAR 0 8
68061: PPUSH
68062: CALL_OW 1
68066: ST_TO_ADDR
// end ;
68067: LD_VAR 0 5
68071: RET
// export function DangerAtRange ( unit , range ) ; begin
68072: LD_INT 0
68074: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
68075: LD_ADDR_VAR 0 3
68079: PUSH
68080: LD_VAR 0 1
68084: PPUSH
68085: CALL_OW 255
68089: PPUSH
68090: LD_VAR 0 1
68094: PPUSH
68095: CALL_OW 250
68099: PPUSH
68100: LD_VAR 0 1
68104: PPUSH
68105: CALL_OW 251
68109: PPUSH
68110: LD_VAR 0 2
68114: PPUSH
68115: CALL 66375 0 4
68119: ST_TO_ADDR
// end ;
68120: LD_VAR 0 3
68124: RET
// export function DangerInArea ( side , area ) ; begin
68125: LD_INT 0
68127: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
68128: LD_ADDR_VAR 0 3
68132: PUSH
68133: LD_VAR 0 2
68137: PPUSH
68138: LD_INT 81
68140: PUSH
68141: LD_VAR 0 1
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: PPUSH
68150: CALL_OW 70
68154: ST_TO_ADDR
// end ;
68155: LD_VAR 0 3
68159: RET
// export function IsExtension ( b ) ; begin
68160: LD_INT 0
68162: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
68163: LD_ADDR_VAR 0 2
68167: PUSH
68168: LD_VAR 0 1
68172: PUSH
68173: LD_INT 23
68175: PUSH
68176: LD_INT 20
68178: PUSH
68179: LD_INT 22
68181: PUSH
68182: LD_INT 17
68184: PUSH
68185: LD_INT 24
68187: PUSH
68188: LD_INT 21
68190: PUSH
68191: LD_INT 19
68193: PUSH
68194: LD_INT 16
68196: PUSH
68197: LD_INT 25
68199: PUSH
68200: LD_INT 18
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: LIST
68212: LIST
68213: LIST
68214: IN
68215: ST_TO_ADDR
// end ;
68216: LD_VAR 0 2
68220: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
68221: LD_INT 0
68223: PPUSH
68224: PPUSH
68225: PPUSH
// result := [ ] ;
68226: LD_ADDR_VAR 0 4
68230: PUSH
68231: EMPTY
68232: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
68233: LD_ADDR_VAR 0 5
68237: PUSH
68238: LD_VAR 0 2
68242: PPUSH
68243: LD_INT 21
68245: PUSH
68246: LD_INT 3
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PPUSH
68253: CALL_OW 70
68257: ST_TO_ADDR
// if not tmp then
68258: LD_VAR 0 5
68262: NOT
68263: IFFALSE 68267
// exit ;
68265: GO 68331
// if checkLink then
68267: LD_VAR 0 3
68271: IFFALSE 68321
// begin for i in tmp do
68273: LD_ADDR_VAR 0 6
68277: PUSH
68278: LD_VAR 0 5
68282: PUSH
68283: FOR_IN
68284: IFFALSE 68319
// if GetBase ( i ) <> base then
68286: LD_VAR 0 6
68290: PPUSH
68291: CALL_OW 274
68295: PUSH
68296: LD_VAR 0 1
68300: NONEQUAL
68301: IFFALSE 68317
// ComLinkToBase ( base , i ) ;
68303: LD_VAR 0 1
68307: PPUSH
68308: LD_VAR 0 6
68312: PPUSH
68313: CALL_OW 169
68317: GO 68283
68319: POP
68320: POP
// end ; result := tmp ;
68321: LD_ADDR_VAR 0 4
68325: PUSH
68326: LD_VAR 0 5
68330: ST_TO_ADDR
// end ;
68331: LD_VAR 0 4
68335: RET
// export function ComComplete ( units , b ) ; var i ; begin
68336: LD_INT 0
68338: PPUSH
68339: PPUSH
// if not units then
68340: LD_VAR 0 1
68344: NOT
68345: IFFALSE 68349
// exit ;
68347: GO 68439
// for i in units do
68349: LD_ADDR_VAR 0 4
68353: PUSH
68354: LD_VAR 0 1
68358: PUSH
68359: FOR_IN
68360: IFFALSE 68437
// if BuildingStatus ( b ) = bs_build then
68362: LD_VAR 0 2
68366: PPUSH
68367: CALL_OW 461
68371: PUSH
68372: LD_INT 1
68374: EQUAL
68375: IFFALSE 68435
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
68377: LD_VAR 0 4
68381: PPUSH
68382: LD_STRING h
68384: PUSH
68385: LD_VAR 0 2
68389: PPUSH
68390: CALL_OW 250
68394: PUSH
68395: LD_VAR 0 2
68399: PPUSH
68400: CALL_OW 251
68404: PUSH
68405: LD_VAR 0 2
68409: PUSH
68410: LD_INT 0
68412: PUSH
68413: LD_INT 0
68415: PUSH
68416: LD_INT 0
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: PUSH
68428: EMPTY
68429: LIST
68430: PPUSH
68431: CALL_OW 446
68435: GO 68359
68437: POP
68438: POP
// end ;
68439: LD_VAR 0 3
68443: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
68444: LD_INT 0
68446: PPUSH
68447: PPUSH
68448: PPUSH
68449: PPUSH
68450: PPUSH
68451: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
68452: LD_VAR 0 1
68456: NOT
68457: PUSH
68458: LD_VAR 0 1
68462: PPUSH
68463: CALL_OW 263
68467: PUSH
68468: LD_INT 2
68470: EQUAL
68471: NOT
68472: OR
68473: IFFALSE 68477
// exit ;
68475: GO 68793
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
68477: LD_ADDR_VAR 0 6
68481: PUSH
68482: LD_INT 22
68484: PUSH
68485: LD_VAR 0 1
68489: PPUSH
68490: CALL_OW 255
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: PUSH
68499: LD_INT 2
68501: PUSH
68502: LD_INT 30
68504: PUSH
68505: LD_INT 36
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 34
68514: PUSH
68515: LD_INT 31
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: LIST
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PPUSH
68531: CALL_OW 69
68535: ST_TO_ADDR
// if not tmp then
68536: LD_VAR 0 6
68540: NOT
68541: IFFALSE 68545
// exit ;
68543: GO 68793
// result := [ ] ;
68545: LD_ADDR_VAR 0 2
68549: PUSH
68550: EMPTY
68551: ST_TO_ADDR
// for i in tmp do
68552: LD_ADDR_VAR 0 3
68556: PUSH
68557: LD_VAR 0 6
68561: PUSH
68562: FOR_IN
68563: IFFALSE 68634
// begin t := UnitsInside ( i ) ;
68565: LD_ADDR_VAR 0 4
68569: PUSH
68570: LD_VAR 0 3
68574: PPUSH
68575: CALL_OW 313
68579: ST_TO_ADDR
// if t then
68580: LD_VAR 0 4
68584: IFFALSE 68632
// for j in t do
68586: LD_ADDR_VAR 0 7
68590: PUSH
68591: LD_VAR 0 4
68595: PUSH
68596: FOR_IN
68597: IFFALSE 68630
// result := Insert ( result , result + 1 , j ) ;
68599: LD_ADDR_VAR 0 2
68603: PUSH
68604: LD_VAR 0 2
68608: PPUSH
68609: LD_VAR 0 2
68613: PUSH
68614: LD_INT 1
68616: PLUS
68617: PPUSH
68618: LD_VAR 0 7
68622: PPUSH
68623: CALL_OW 2
68627: ST_TO_ADDR
68628: GO 68596
68630: POP
68631: POP
// end ;
68632: GO 68562
68634: POP
68635: POP
// if not result then
68636: LD_VAR 0 2
68640: NOT
68641: IFFALSE 68645
// exit ;
68643: GO 68793
// mech := result [ 1 ] ;
68645: LD_ADDR_VAR 0 5
68649: PUSH
68650: LD_VAR 0 2
68654: PUSH
68655: LD_INT 1
68657: ARRAY
68658: ST_TO_ADDR
// if result > 1 then
68659: LD_VAR 0 2
68663: PUSH
68664: LD_INT 1
68666: GREATER
68667: IFFALSE 68779
// for i = 2 to result do
68669: LD_ADDR_VAR 0 3
68673: PUSH
68674: DOUBLE
68675: LD_INT 2
68677: DEC
68678: ST_TO_ADDR
68679: LD_VAR 0 2
68683: PUSH
68684: FOR_TO
68685: IFFALSE 68777
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
68687: LD_ADDR_VAR 0 4
68691: PUSH
68692: LD_VAR 0 2
68696: PUSH
68697: LD_VAR 0 3
68701: ARRAY
68702: PPUSH
68703: LD_INT 3
68705: PPUSH
68706: CALL_OW 259
68710: PUSH
68711: LD_VAR 0 2
68715: PUSH
68716: LD_VAR 0 3
68720: ARRAY
68721: PPUSH
68722: CALL_OW 432
68726: MINUS
68727: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
68728: LD_VAR 0 4
68732: PUSH
68733: LD_VAR 0 5
68737: PPUSH
68738: LD_INT 3
68740: PPUSH
68741: CALL_OW 259
68745: PUSH
68746: LD_VAR 0 5
68750: PPUSH
68751: CALL_OW 432
68755: MINUS
68756: GREATEREQUAL
68757: IFFALSE 68775
// mech := result [ i ] ;
68759: LD_ADDR_VAR 0 5
68763: PUSH
68764: LD_VAR 0 2
68768: PUSH
68769: LD_VAR 0 3
68773: ARRAY
68774: ST_TO_ADDR
// end ;
68775: GO 68684
68777: POP
68778: POP
// ComLinkTo ( vehicle , mech ) ;
68779: LD_VAR 0 1
68783: PPUSH
68784: LD_VAR 0 5
68788: PPUSH
68789: CALL_OW 135
// end ;
68793: LD_VAR 0 2
68797: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
68798: LD_INT 0
68800: PPUSH
68801: PPUSH
68802: PPUSH
68803: PPUSH
68804: PPUSH
68805: PPUSH
68806: PPUSH
68807: PPUSH
68808: PPUSH
68809: PPUSH
68810: PPUSH
68811: PPUSH
68812: PPUSH
// result := [ ] ;
68813: LD_ADDR_VAR 0 7
68817: PUSH
68818: EMPTY
68819: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
68820: LD_VAR 0 1
68824: PPUSH
68825: CALL_OW 266
68829: PUSH
68830: LD_INT 0
68832: PUSH
68833: LD_INT 1
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: IN
68840: NOT
68841: IFFALSE 68845
// exit ;
68843: GO 70479
// if name then
68845: LD_VAR 0 3
68849: IFFALSE 68865
// SetBName ( base_dep , name ) ;
68851: LD_VAR 0 1
68855: PPUSH
68856: LD_VAR 0 3
68860: PPUSH
68861: CALL_OW 500
// base := GetBase ( base_dep ) ;
68865: LD_ADDR_VAR 0 15
68869: PUSH
68870: LD_VAR 0 1
68874: PPUSH
68875: CALL_OW 274
68879: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
68880: LD_ADDR_VAR 0 16
68884: PUSH
68885: LD_VAR 0 1
68889: PPUSH
68890: CALL_OW 255
68894: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
68895: LD_ADDR_VAR 0 17
68899: PUSH
68900: LD_VAR 0 1
68904: PPUSH
68905: CALL_OW 248
68909: ST_TO_ADDR
// if sources then
68910: LD_VAR 0 5
68914: IFFALSE 68961
// for i = 1 to 3 do
68916: LD_ADDR_VAR 0 8
68920: PUSH
68921: DOUBLE
68922: LD_INT 1
68924: DEC
68925: ST_TO_ADDR
68926: LD_INT 3
68928: PUSH
68929: FOR_TO
68930: IFFALSE 68959
// AddResourceType ( base , i , sources [ i ] ) ;
68932: LD_VAR 0 15
68936: PPUSH
68937: LD_VAR 0 8
68941: PPUSH
68942: LD_VAR 0 5
68946: PUSH
68947: LD_VAR 0 8
68951: ARRAY
68952: PPUSH
68953: CALL_OW 276
68957: GO 68929
68959: POP
68960: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
68961: LD_ADDR_VAR 0 18
68965: PUSH
68966: LD_VAR 0 15
68970: PPUSH
68971: LD_VAR 0 2
68975: PPUSH
68976: LD_INT 1
68978: PPUSH
68979: CALL 68221 0 3
68983: ST_TO_ADDR
// InitHc ;
68984: CALL_OW 19
// InitUc ;
68988: CALL_OW 18
// uc_side := side ;
68992: LD_ADDR_OWVAR 20
68996: PUSH
68997: LD_VAR 0 16
69001: ST_TO_ADDR
// uc_nation := nation ;
69002: LD_ADDR_OWVAR 21
69006: PUSH
69007: LD_VAR 0 17
69011: ST_TO_ADDR
// if buildings then
69012: LD_VAR 0 18
69016: IFFALSE 70338
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
69018: LD_ADDR_VAR 0 19
69022: PUSH
69023: LD_VAR 0 18
69027: PPUSH
69028: LD_INT 2
69030: PUSH
69031: LD_INT 30
69033: PUSH
69034: LD_INT 29
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 30
69043: PUSH
69044: LD_INT 30
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: LIST
69055: PPUSH
69056: CALL_OW 72
69060: ST_TO_ADDR
// if tmp then
69061: LD_VAR 0 19
69065: IFFALSE 69113
// for i in tmp do
69067: LD_ADDR_VAR 0 8
69071: PUSH
69072: LD_VAR 0 19
69076: PUSH
69077: FOR_IN
69078: IFFALSE 69111
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
69080: LD_VAR 0 8
69084: PPUSH
69085: CALL_OW 250
69089: PPUSH
69090: LD_VAR 0 8
69094: PPUSH
69095: CALL_OW 251
69099: PPUSH
69100: LD_VAR 0 16
69104: PPUSH
69105: CALL_OW 441
69109: GO 69077
69111: POP
69112: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
69113: LD_VAR 0 18
69117: PPUSH
69118: LD_INT 2
69120: PUSH
69121: LD_INT 30
69123: PUSH
69124: LD_INT 32
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: PUSH
69131: LD_INT 30
69133: PUSH
69134: LD_INT 33
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: LIST
69145: PPUSH
69146: CALL_OW 72
69150: IFFALSE 69238
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
69152: LD_ADDR_VAR 0 8
69156: PUSH
69157: LD_VAR 0 18
69161: PPUSH
69162: LD_INT 2
69164: PUSH
69165: LD_INT 30
69167: PUSH
69168: LD_INT 32
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: LD_INT 30
69177: PUSH
69178: LD_INT 33
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: LIST
69189: PPUSH
69190: CALL_OW 72
69194: PUSH
69195: FOR_IN
69196: IFFALSE 69236
// begin if not GetBWeapon ( i ) then
69198: LD_VAR 0 8
69202: PPUSH
69203: CALL_OW 269
69207: NOT
69208: IFFALSE 69234
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
69210: LD_VAR 0 8
69214: PPUSH
69215: LD_VAR 0 8
69219: PPUSH
69220: LD_VAR 0 2
69224: PPUSH
69225: CALL 70484 0 2
69229: PPUSH
69230: CALL_OW 431
// end ;
69234: GO 69195
69236: POP
69237: POP
// end ; for i = 1 to personel do
69238: LD_ADDR_VAR 0 8
69242: PUSH
69243: DOUBLE
69244: LD_INT 1
69246: DEC
69247: ST_TO_ADDR
69248: LD_VAR 0 6
69252: PUSH
69253: FOR_TO
69254: IFFALSE 70318
// begin if i > 4 then
69256: LD_VAR 0 8
69260: PUSH
69261: LD_INT 4
69263: GREATER
69264: IFFALSE 69268
// break ;
69266: GO 70318
// case i of 1 :
69268: LD_VAR 0 8
69272: PUSH
69273: LD_INT 1
69275: DOUBLE
69276: EQUAL
69277: IFTRUE 69281
69279: GO 69361
69281: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
69282: LD_ADDR_VAR 0 12
69286: PUSH
69287: LD_VAR 0 18
69291: PPUSH
69292: LD_INT 22
69294: PUSH
69295: LD_VAR 0 16
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PUSH
69304: LD_INT 58
69306: PUSH
69307: EMPTY
69308: LIST
69309: PUSH
69310: LD_INT 2
69312: PUSH
69313: LD_INT 30
69315: PUSH
69316: LD_INT 32
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 30
69325: PUSH
69326: LD_INT 4
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 30
69335: PUSH
69336: LD_INT 5
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: LIST
69353: PPUSH
69354: CALL_OW 72
69358: ST_TO_ADDR
69359: GO 69583
69361: LD_INT 2
69363: DOUBLE
69364: EQUAL
69365: IFTRUE 69369
69367: GO 69431
69369: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
69370: LD_ADDR_VAR 0 12
69374: PUSH
69375: LD_VAR 0 18
69379: PPUSH
69380: LD_INT 22
69382: PUSH
69383: LD_VAR 0 16
69387: PUSH
69388: EMPTY
69389: LIST
69390: LIST
69391: PUSH
69392: LD_INT 2
69394: PUSH
69395: LD_INT 30
69397: PUSH
69398: LD_INT 0
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 30
69407: PUSH
69408: LD_INT 1
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: LIST
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PPUSH
69424: CALL_OW 72
69428: ST_TO_ADDR
69429: GO 69583
69431: LD_INT 3
69433: DOUBLE
69434: EQUAL
69435: IFTRUE 69439
69437: GO 69501
69439: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
69440: LD_ADDR_VAR 0 12
69444: PUSH
69445: LD_VAR 0 18
69449: PPUSH
69450: LD_INT 22
69452: PUSH
69453: LD_VAR 0 16
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: PUSH
69462: LD_INT 2
69464: PUSH
69465: LD_INT 30
69467: PUSH
69468: LD_INT 2
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 30
69477: PUSH
69478: LD_INT 3
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: LIST
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PPUSH
69494: CALL_OW 72
69498: ST_TO_ADDR
69499: GO 69583
69501: LD_INT 4
69503: DOUBLE
69504: EQUAL
69505: IFTRUE 69509
69507: GO 69582
69509: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
69510: LD_ADDR_VAR 0 12
69514: PUSH
69515: LD_VAR 0 18
69519: PPUSH
69520: LD_INT 22
69522: PUSH
69523: LD_VAR 0 16
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 2
69534: PUSH
69535: LD_INT 30
69537: PUSH
69538: LD_INT 6
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 30
69547: PUSH
69548: LD_INT 7
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: PUSH
69555: LD_INT 30
69557: PUSH
69558: LD_INT 8
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PPUSH
69575: CALL_OW 72
69579: ST_TO_ADDR
69580: GO 69583
69582: POP
// if i = 1 then
69583: LD_VAR 0 8
69587: PUSH
69588: LD_INT 1
69590: EQUAL
69591: IFFALSE 69702
// begin tmp := [ ] ;
69593: LD_ADDR_VAR 0 19
69597: PUSH
69598: EMPTY
69599: ST_TO_ADDR
// for j in f do
69600: LD_ADDR_VAR 0 9
69604: PUSH
69605: LD_VAR 0 12
69609: PUSH
69610: FOR_IN
69611: IFFALSE 69684
// if GetBType ( j ) = b_bunker then
69613: LD_VAR 0 9
69617: PPUSH
69618: CALL_OW 266
69622: PUSH
69623: LD_INT 32
69625: EQUAL
69626: IFFALSE 69653
// tmp := Insert ( tmp , 1 , j ) else
69628: LD_ADDR_VAR 0 19
69632: PUSH
69633: LD_VAR 0 19
69637: PPUSH
69638: LD_INT 1
69640: PPUSH
69641: LD_VAR 0 9
69645: PPUSH
69646: CALL_OW 2
69650: ST_TO_ADDR
69651: GO 69682
// tmp := Insert ( tmp , tmp + 1 , j ) ;
69653: LD_ADDR_VAR 0 19
69657: PUSH
69658: LD_VAR 0 19
69662: PPUSH
69663: LD_VAR 0 19
69667: PUSH
69668: LD_INT 1
69670: PLUS
69671: PPUSH
69672: LD_VAR 0 9
69676: PPUSH
69677: CALL_OW 2
69681: ST_TO_ADDR
69682: GO 69610
69684: POP
69685: POP
// if tmp then
69686: LD_VAR 0 19
69690: IFFALSE 69702
// f := tmp ;
69692: LD_ADDR_VAR 0 12
69696: PUSH
69697: LD_VAR 0 19
69701: ST_TO_ADDR
// end ; x := personel [ i ] ;
69702: LD_ADDR_VAR 0 13
69706: PUSH
69707: LD_VAR 0 6
69711: PUSH
69712: LD_VAR 0 8
69716: ARRAY
69717: ST_TO_ADDR
// if x = - 1 then
69718: LD_VAR 0 13
69722: PUSH
69723: LD_INT 1
69725: NEG
69726: EQUAL
69727: IFFALSE 69936
// begin for j in f do
69729: LD_ADDR_VAR 0 9
69733: PUSH
69734: LD_VAR 0 12
69738: PUSH
69739: FOR_IN
69740: IFFALSE 69932
// repeat InitHc ;
69742: CALL_OW 19
// if GetBType ( j ) = b_barracks then
69746: LD_VAR 0 9
69750: PPUSH
69751: CALL_OW 266
69755: PUSH
69756: LD_INT 5
69758: EQUAL
69759: IFFALSE 69829
// begin if UnitsInside ( j ) < 3 then
69761: LD_VAR 0 9
69765: PPUSH
69766: CALL_OW 313
69770: PUSH
69771: LD_INT 3
69773: LESS
69774: IFFALSE 69810
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
69776: LD_INT 0
69778: PPUSH
69779: LD_INT 5
69781: PUSH
69782: LD_INT 8
69784: PUSH
69785: LD_INT 9
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: LIST
69792: PUSH
69793: LD_VAR 0 17
69797: ARRAY
69798: PPUSH
69799: LD_VAR 0 4
69803: PPUSH
69804: CALL_OW 380
69808: GO 69827
// PrepareHuman ( false , i , skill ) ;
69810: LD_INT 0
69812: PPUSH
69813: LD_VAR 0 8
69817: PPUSH
69818: LD_VAR 0 4
69822: PPUSH
69823: CALL_OW 380
// end else
69827: GO 69846
// PrepareHuman ( false , i , skill ) ;
69829: LD_INT 0
69831: PPUSH
69832: LD_VAR 0 8
69836: PPUSH
69837: LD_VAR 0 4
69841: PPUSH
69842: CALL_OW 380
// un := CreateHuman ;
69846: LD_ADDR_VAR 0 14
69850: PUSH
69851: CALL_OW 44
69855: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
69856: LD_ADDR_VAR 0 7
69860: PUSH
69861: LD_VAR 0 7
69865: PPUSH
69866: LD_INT 1
69868: PPUSH
69869: LD_VAR 0 14
69873: PPUSH
69874: CALL_OW 2
69878: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
69879: LD_VAR 0 14
69883: PPUSH
69884: LD_VAR 0 9
69888: PPUSH
69889: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
69893: LD_VAR 0 9
69897: PPUSH
69898: CALL_OW 313
69902: PUSH
69903: LD_INT 6
69905: EQUAL
69906: PUSH
69907: LD_VAR 0 9
69911: PPUSH
69912: CALL_OW 266
69916: PUSH
69917: LD_INT 32
69919: PUSH
69920: LD_INT 31
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: IN
69927: OR
69928: IFFALSE 69742
69930: GO 69739
69932: POP
69933: POP
// end else
69934: GO 70316
// for j = 1 to x do
69936: LD_ADDR_VAR 0 9
69940: PUSH
69941: DOUBLE
69942: LD_INT 1
69944: DEC
69945: ST_TO_ADDR
69946: LD_VAR 0 13
69950: PUSH
69951: FOR_TO
69952: IFFALSE 70314
// begin InitHc ;
69954: CALL_OW 19
// if not f then
69958: LD_VAR 0 12
69962: NOT
69963: IFFALSE 70052
// begin PrepareHuman ( false , i , skill ) ;
69965: LD_INT 0
69967: PPUSH
69968: LD_VAR 0 8
69972: PPUSH
69973: LD_VAR 0 4
69977: PPUSH
69978: CALL_OW 380
// un := CreateHuman ;
69982: LD_ADDR_VAR 0 14
69986: PUSH
69987: CALL_OW 44
69991: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
69992: LD_ADDR_VAR 0 7
69996: PUSH
69997: LD_VAR 0 7
70001: PPUSH
70002: LD_INT 1
70004: PPUSH
70005: LD_VAR 0 14
70009: PPUSH
70010: CALL_OW 2
70014: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70015: LD_VAR 0 14
70019: PPUSH
70020: LD_VAR 0 1
70024: PPUSH
70025: CALL_OW 250
70029: PPUSH
70030: LD_VAR 0 1
70034: PPUSH
70035: CALL_OW 251
70039: PPUSH
70040: LD_INT 10
70042: PPUSH
70043: LD_INT 0
70045: PPUSH
70046: CALL_OW 50
// continue ;
70050: GO 69951
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
70052: LD_VAR 0 12
70056: PUSH
70057: LD_INT 1
70059: ARRAY
70060: PPUSH
70061: CALL_OW 313
70065: PUSH
70066: LD_VAR 0 12
70070: PUSH
70071: LD_INT 1
70073: ARRAY
70074: PPUSH
70075: CALL_OW 266
70079: PUSH
70080: LD_INT 32
70082: PUSH
70083: LD_INT 31
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: IN
70090: AND
70091: PUSH
70092: LD_VAR 0 12
70096: PUSH
70097: LD_INT 1
70099: ARRAY
70100: PPUSH
70101: CALL_OW 313
70105: PUSH
70106: LD_INT 6
70108: EQUAL
70109: OR
70110: IFFALSE 70130
// f := Delete ( f , 1 ) ;
70112: LD_ADDR_VAR 0 12
70116: PUSH
70117: LD_VAR 0 12
70121: PPUSH
70122: LD_INT 1
70124: PPUSH
70125: CALL_OW 3
70129: ST_TO_ADDR
// if not f then
70130: LD_VAR 0 12
70134: NOT
70135: IFFALSE 70153
// begin x := x + 2 ;
70137: LD_ADDR_VAR 0 13
70141: PUSH
70142: LD_VAR 0 13
70146: PUSH
70147: LD_INT 2
70149: PLUS
70150: ST_TO_ADDR
// continue ;
70151: GO 69951
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
70153: LD_VAR 0 12
70157: PUSH
70158: LD_INT 1
70160: ARRAY
70161: PPUSH
70162: CALL_OW 266
70166: PUSH
70167: LD_INT 5
70169: EQUAL
70170: IFFALSE 70244
// begin if UnitsInside ( f [ 1 ] ) < 3 then
70172: LD_VAR 0 12
70176: PUSH
70177: LD_INT 1
70179: ARRAY
70180: PPUSH
70181: CALL_OW 313
70185: PUSH
70186: LD_INT 3
70188: LESS
70189: IFFALSE 70225
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70191: LD_INT 0
70193: PPUSH
70194: LD_INT 5
70196: PUSH
70197: LD_INT 8
70199: PUSH
70200: LD_INT 9
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: LIST
70207: PUSH
70208: LD_VAR 0 17
70212: ARRAY
70213: PPUSH
70214: LD_VAR 0 4
70218: PPUSH
70219: CALL_OW 380
70223: GO 70242
// PrepareHuman ( false , i , skill ) ;
70225: LD_INT 0
70227: PPUSH
70228: LD_VAR 0 8
70232: PPUSH
70233: LD_VAR 0 4
70237: PPUSH
70238: CALL_OW 380
// end else
70242: GO 70261
// PrepareHuman ( false , i , skill ) ;
70244: LD_INT 0
70246: PPUSH
70247: LD_VAR 0 8
70251: PPUSH
70252: LD_VAR 0 4
70256: PPUSH
70257: CALL_OW 380
// un := CreateHuman ;
70261: LD_ADDR_VAR 0 14
70265: PUSH
70266: CALL_OW 44
70270: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70271: LD_ADDR_VAR 0 7
70275: PUSH
70276: LD_VAR 0 7
70280: PPUSH
70281: LD_INT 1
70283: PPUSH
70284: LD_VAR 0 14
70288: PPUSH
70289: CALL_OW 2
70293: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
70294: LD_VAR 0 14
70298: PPUSH
70299: LD_VAR 0 12
70303: PUSH
70304: LD_INT 1
70306: ARRAY
70307: PPUSH
70308: CALL_OW 52
// end ;
70312: GO 69951
70314: POP
70315: POP
// end ;
70316: GO 69253
70318: POP
70319: POP
// result := result ^ buildings ;
70320: LD_ADDR_VAR 0 7
70324: PUSH
70325: LD_VAR 0 7
70329: PUSH
70330: LD_VAR 0 18
70334: ADD
70335: ST_TO_ADDR
// end else
70336: GO 70479
// begin for i = 1 to personel do
70338: LD_ADDR_VAR 0 8
70342: PUSH
70343: DOUBLE
70344: LD_INT 1
70346: DEC
70347: ST_TO_ADDR
70348: LD_VAR 0 6
70352: PUSH
70353: FOR_TO
70354: IFFALSE 70477
// begin if i > 4 then
70356: LD_VAR 0 8
70360: PUSH
70361: LD_INT 4
70363: GREATER
70364: IFFALSE 70368
// break ;
70366: GO 70477
// x := personel [ i ] ;
70368: LD_ADDR_VAR 0 13
70372: PUSH
70373: LD_VAR 0 6
70377: PUSH
70378: LD_VAR 0 8
70382: ARRAY
70383: ST_TO_ADDR
// if x = - 1 then
70384: LD_VAR 0 13
70388: PUSH
70389: LD_INT 1
70391: NEG
70392: EQUAL
70393: IFFALSE 70397
// continue ;
70395: GO 70353
// PrepareHuman ( false , i , skill ) ;
70397: LD_INT 0
70399: PPUSH
70400: LD_VAR 0 8
70404: PPUSH
70405: LD_VAR 0 4
70409: PPUSH
70410: CALL_OW 380
// un := CreateHuman ;
70414: LD_ADDR_VAR 0 14
70418: PUSH
70419: CALL_OW 44
70423: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70424: LD_VAR 0 14
70428: PPUSH
70429: LD_VAR 0 1
70433: PPUSH
70434: CALL_OW 250
70438: PPUSH
70439: LD_VAR 0 1
70443: PPUSH
70444: CALL_OW 251
70448: PPUSH
70449: LD_INT 10
70451: PPUSH
70452: LD_INT 0
70454: PPUSH
70455: CALL_OW 50
// result := result ^ un ;
70459: LD_ADDR_VAR 0 7
70463: PUSH
70464: LD_VAR 0 7
70468: PUSH
70469: LD_VAR 0 14
70473: ADD
70474: ST_TO_ADDR
// end ;
70475: GO 70353
70477: POP
70478: POP
// end ; end ;
70479: LD_VAR 0 7
70483: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
70484: LD_INT 0
70486: PPUSH
70487: PPUSH
70488: PPUSH
70489: PPUSH
70490: PPUSH
70491: PPUSH
70492: PPUSH
70493: PPUSH
70494: PPUSH
70495: PPUSH
70496: PPUSH
70497: PPUSH
70498: PPUSH
70499: PPUSH
70500: PPUSH
70501: PPUSH
// result := false ;
70502: LD_ADDR_VAR 0 3
70506: PUSH
70507: LD_INT 0
70509: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
70510: LD_VAR 0 1
70514: NOT
70515: PUSH
70516: LD_VAR 0 1
70520: PPUSH
70521: CALL_OW 266
70525: PUSH
70526: LD_INT 32
70528: PUSH
70529: LD_INT 33
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: IN
70536: NOT
70537: OR
70538: IFFALSE 70542
// exit ;
70540: GO 71681
// nat := GetNation ( tower ) ;
70542: LD_ADDR_VAR 0 12
70546: PUSH
70547: LD_VAR 0 1
70551: PPUSH
70552: CALL_OW 248
70556: ST_TO_ADDR
// side := GetSide ( tower ) ;
70557: LD_ADDR_VAR 0 16
70561: PUSH
70562: LD_VAR 0 1
70566: PPUSH
70567: CALL_OW 255
70571: ST_TO_ADDR
// x := GetX ( tower ) ;
70572: LD_ADDR_VAR 0 10
70576: PUSH
70577: LD_VAR 0 1
70581: PPUSH
70582: CALL_OW 250
70586: ST_TO_ADDR
// y := GetY ( tower ) ;
70587: LD_ADDR_VAR 0 11
70591: PUSH
70592: LD_VAR 0 1
70596: PPUSH
70597: CALL_OW 251
70601: ST_TO_ADDR
// if not x or not y then
70602: LD_VAR 0 10
70606: NOT
70607: PUSH
70608: LD_VAR 0 11
70612: NOT
70613: OR
70614: IFFALSE 70618
// exit ;
70616: GO 71681
// weapon := 0 ;
70618: LD_ADDR_VAR 0 18
70622: PUSH
70623: LD_INT 0
70625: ST_TO_ADDR
// fac_list := [ ] ;
70626: LD_ADDR_VAR 0 17
70630: PUSH
70631: EMPTY
70632: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
70633: LD_ADDR_VAR 0 6
70637: PUSH
70638: LD_VAR 0 1
70642: PPUSH
70643: CALL_OW 274
70647: PPUSH
70648: LD_VAR 0 2
70652: PPUSH
70653: LD_INT 0
70655: PPUSH
70656: CALL 68221 0 3
70660: PPUSH
70661: LD_INT 30
70663: PUSH
70664: LD_INT 3
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: PPUSH
70671: CALL_OW 72
70675: ST_TO_ADDR
// if not factories then
70676: LD_VAR 0 6
70680: NOT
70681: IFFALSE 70685
// exit ;
70683: GO 71681
// for i in factories do
70685: LD_ADDR_VAR 0 8
70689: PUSH
70690: LD_VAR 0 6
70694: PUSH
70695: FOR_IN
70696: IFFALSE 70721
// fac_list := fac_list union AvailableWeaponList ( i ) ;
70698: LD_ADDR_VAR 0 17
70702: PUSH
70703: LD_VAR 0 17
70707: PUSH
70708: LD_VAR 0 8
70712: PPUSH
70713: CALL_OW 478
70717: UNION
70718: ST_TO_ADDR
70719: GO 70695
70721: POP
70722: POP
// if not fac_list then
70723: LD_VAR 0 17
70727: NOT
70728: IFFALSE 70732
// exit ;
70730: GO 71681
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
70732: LD_ADDR_VAR 0 5
70736: PUSH
70737: LD_INT 4
70739: PUSH
70740: LD_INT 5
70742: PUSH
70743: LD_INT 9
70745: PUSH
70746: LD_INT 10
70748: PUSH
70749: LD_INT 6
70751: PUSH
70752: LD_INT 7
70754: PUSH
70755: LD_INT 11
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 27
70769: PUSH
70770: LD_INT 28
70772: PUSH
70773: LD_INT 26
70775: PUSH
70776: LD_INT 30
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 43
70787: PUSH
70788: LD_INT 44
70790: PUSH
70791: LD_INT 46
70793: PUSH
70794: LD_INT 45
70796: PUSH
70797: LD_INT 47
70799: PUSH
70800: LD_INT 49
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: LIST
70815: PUSH
70816: LD_VAR 0 12
70820: ARRAY
70821: ST_TO_ADDR
// for i in list do
70822: LD_ADDR_VAR 0 8
70826: PUSH
70827: LD_VAR 0 5
70831: PUSH
70832: FOR_IN
70833: IFFALSE 70866
// if not i in fac_list then
70835: LD_VAR 0 8
70839: PUSH
70840: LD_VAR 0 17
70844: IN
70845: NOT
70846: IFFALSE 70864
// list := list diff i ;
70848: LD_ADDR_VAR 0 5
70852: PUSH
70853: LD_VAR 0 5
70857: PUSH
70858: LD_VAR 0 8
70862: DIFF
70863: ST_TO_ADDR
70864: GO 70832
70866: POP
70867: POP
// if not list then
70868: LD_VAR 0 5
70872: NOT
70873: IFFALSE 70877
// exit ;
70875: GO 71681
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
70877: LD_VAR 0 12
70881: PUSH
70882: LD_INT 3
70884: EQUAL
70885: PUSH
70886: LD_INT 49
70888: PUSH
70889: LD_VAR 0 5
70893: IN
70894: AND
70895: PUSH
70896: LD_INT 31
70898: PPUSH
70899: LD_VAR 0 16
70903: PPUSH
70904: CALL_OW 321
70908: PUSH
70909: LD_INT 2
70911: EQUAL
70912: AND
70913: IFFALSE 70973
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
70915: LD_INT 22
70917: PUSH
70918: LD_VAR 0 16
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 35
70929: PUSH
70930: LD_INT 49
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 91
70939: PUSH
70940: LD_VAR 0 1
70944: PUSH
70945: LD_INT 10
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: LIST
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: LIST
70957: PPUSH
70958: CALL_OW 69
70962: NOT
70963: IFFALSE 70973
// weapon := ru_time_lapser ;
70965: LD_ADDR_VAR 0 18
70969: PUSH
70970: LD_INT 49
70972: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
70973: LD_VAR 0 12
70977: PUSH
70978: LD_INT 1
70980: PUSH
70981: LD_INT 2
70983: PUSH
70984: EMPTY
70985: LIST
70986: LIST
70987: IN
70988: PUSH
70989: LD_INT 11
70991: PUSH
70992: LD_VAR 0 5
70996: IN
70997: PUSH
70998: LD_INT 30
71000: PUSH
71001: LD_VAR 0 5
71005: IN
71006: OR
71007: AND
71008: PUSH
71009: LD_INT 6
71011: PPUSH
71012: LD_VAR 0 16
71016: PPUSH
71017: CALL_OW 321
71021: PUSH
71022: LD_INT 2
71024: EQUAL
71025: AND
71026: IFFALSE 71191
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
71028: LD_INT 22
71030: PUSH
71031: LD_VAR 0 16
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 2
71042: PUSH
71043: LD_INT 35
71045: PUSH
71046: LD_INT 11
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 35
71055: PUSH
71056: LD_INT 30
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 91
71070: PUSH
71071: LD_VAR 0 1
71075: PUSH
71076: LD_INT 18
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: LIST
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: LIST
71088: PPUSH
71089: CALL_OW 69
71093: NOT
71094: PUSH
71095: LD_INT 22
71097: PUSH
71098: LD_VAR 0 16
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 2
71109: PUSH
71110: LD_INT 30
71112: PUSH
71113: LD_INT 32
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 30
71122: PUSH
71123: LD_INT 33
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 91
71137: PUSH
71138: LD_VAR 0 1
71142: PUSH
71143: LD_INT 12
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: LIST
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: LIST
71155: PUSH
71156: EMPTY
71157: LIST
71158: PPUSH
71159: CALL_OW 69
71163: PUSH
71164: LD_INT 2
71166: GREATER
71167: AND
71168: IFFALSE 71191
// weapon := [ us_radar , ar_radar ] [ nat ] ;
71170: LD_ADDR_VAR 0 18
71174: PUSH
71175: LD_INT 11
71177: PUSH
71178: LD_INT 30
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_VAR 0 12
71189: ARRAY
71190: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
71191: LD_VAR 0 18
71195: NOT
71196: PUSH
71197: LD_INT 40
71199: PPUSH
71200: LD_VAR 0 16
71204: PPUSH
71205: CALL_OW 321
71209: PUSH
71210: LD_INT 2
71212: EQUAL
71213: AND
71214: PUSH
71215: LD_INT 7
71217: PUSH
71218: LD_VAR 0 5
71222: IN
71223: PUSH
71224: LD_INT 28
71226: PUSH
71227: LD_VAR 0 5
71231: IN
71232: OR
71233: PUSH
71234: LD_INT 45
71236: PUSH
71237: LD_VAR 0 5
71241: IN
71242: OR
71243: AND
71244: IFFALSE 71498
// begin hex := GetHexInfo ( x , y ) ;
71246: LD_ADDR_VAR 0 4
71250: PUSH
71251: LD_VAR 0 10
71255: PPUSH
71256: LD_VAR 0 11
71260: PPUSH
71261: CALL_OW 546
71265: ST_TO_ADDR
// if hex [ 1 ] then
71266: LD_VAR 0 4
71270: PUSH
71271: LD_INT 1
71273: ARRAY
71274: IFFALSE 71278
// exit ;
71276: GO 71681
// height := hex [ 2 ] ;
71278: LD_ADDR_VAR 0 15
71282: PUSH
71283: LD_VAR 0 4
71287: PUSH
71288: LD_INT 2
71290: ARRAY
71291: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
71292: LD_ADDR_VAR 0 14
71296: PUSH
71297: LD_INT 0
71299: PUSH
71300: LD_INT 2
71302: PUSH
71303: LD_INT 3
71305: PUSH
71306: LD_INT 5
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: ST_TO_ADDR
// for i in tmp do
71315: LD_ADDR_VAR 0 8
71319: PUSH
71320: LD_VAR 0 14
71324: PUSH
71325: FOR_IN
71326: IFFALSE 71496
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
71328: LD_ADDR_VAR 0 9
71332: PUSH
71333: LD_VAR 0 10
71337: PPUSH
71338: LD_VAR 0 8
71342: PPUSH
71343: LD_INT 5
71345: PPUSH
71346: CALL_OW 272
71350: PUSH
71351: LD_VAR 0 11
71355: PPUSH
71356: LD_VAR 0 8
71360: PPUSH
71361: LD_INT 5
71363: PPUSH
71364: CALL_OW 273
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
71373: LD_VAR 0 9
71377: PUSH
71378: LD_INT 1
71380: ARRAY
71381: PPUSH
71382: LD_VAR 0 9
71386: PUSH
71387: LD_INT 2
71389: ARRAY
71390: PPUSH
71391: CALL_OW 488
71395: IFFALSE 71494
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
71397: LD_ADDR_VAR 0 4
71401: PUSH
71402: LD_VAR 0 9
71406: PUSH
71407: LD_INT 1
71409: ARRAY
71410: PPUSH
71411: LD_VAR 0 9
71415: PUSH
71416: LD_INT 2
71418: ARRAY
71419: PPUSH
71420: CALL_OW 546
71424: ST_TO_ADDR
// if hex [ 1 ] then
71425: LD_VAR 0 4
71429: PUSH
71430: LD_INT 1
71432: ARRAY
71433: IFFALSE 71437
// continue ;
71435: GO 71325
// h := hex [ 2 ] ;
71437: LD_ADDR_VAR 0 13
71441: PUSH
71442: LD_VAR 0 4
71446: PUSH
71447: LD_INT 2
71449: ARRAY
71450: ST_TO_ADDR
// if h + 7 < height then
71451: LD_VAR 0 13
71455: PUSH
71456: LD_INT 7
71458: PLUS
71459: PUSH
71460: LD_VAR 0 15
71464: LESS
71465: IFFALSE 71494
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
71467: LD_ADDR_VAR 0 18
71471: PUSH
71472: LD_INT 7
71474: PUSH
71475: LD_INT 28
71477: PUSH
71478: LD_INT 45
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: LIST
71485: PUSH
71486: LD_VAR 0 12
71490: ARRAY
71491: ST_TO_ADDR
// break ;
71492: GO 71496
// end ; end ; end ;
71494: GO 71325
71496: POP
71497: POP
// end ; if not weapon then
71498: LD_VAR 0 18
71502: NOT
71503: IFFALSE 71563
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
71505: LD_ADDR_VAR 0 5
71509: PUSH
71510: LD_VAR 0 5
71514: PUSH
71515: LD_INT 11
71517: PUSH
71518: LD_INT 30
71520: PUSH
71521: LD_INT 49
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: LIST
71528: DIFF
71529: ST_TO_ADDR
// if not list then
71530: LD_VAR 0 5
71534: NOT
71535: IFFALSE 71539
// exit ;
71537: GO 71681
// weapon := list [ rand ( 1 , list ) ] ;
71539: LD_ADDR_VAR 0 18
71543: PUSH
71544: LD_VAR 0 5
71548: PUSH
71549: LD_INT 1
71551: PPUSH
71552: LD_VAR 0 5
71556: PPUSH
71557: CALL_OW 12
71561: ARRAY
71562: ST_TO_ADDR
// end ; if weapon then
71563: LD_VAR 0 18
71567: IFFALSE 71681
// begin tmp := CostOfWeapon ( weapon ) ;
71569: LD_ADDR_VAR 0 14
71573: PUSH
71574: LD_VAR 0 18
71578: PPUSH
71579: CALL_OW 451
71583: ST_TO_ADDR
// j := GetBase ( tower ) ;
71584: LD_ADDR_VAR 0 9
71588: PUSH
71589: LD_VAR 0 1
71593: PPUSH
71594: CALL_OW 274
71598: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
71599: LD_VAR 0 9
71603: PPUSH
71604: LD_INT 1
71606: PPUSH
71607: CALL_OW 275
71611: PUSH
71612: LD_VAR 0 14
71616: PUSH
71617: LD_INT 1
71619: ARRAY
71620: GREATEREQUAL
71621: PUSH
71622: LD_VAR 0 9
71626: PPUSH
71627: LD_INT 2
71629: PPUSH
71630: CALL_OW 275
71634: PUSH
71635: LD_VAR 0 14
71639: PUSH
71640: LD_INT 2
71642: ARRAY
71643: GREATEREQUAL
71644: AND
71645: PUSH
71646: LD_VAR 0 9
71650: PPUSH
71651: LD_INT 3
71653: PPUSH
71654: CALL_OW 275
71658: PUSH
71659: LD_VAR 0 14
71663: PUSH
71664: LD_INT 3
71666: ARRAY
71667: GREATEREQUAL
71668: AND
71669: IFFALSE 71681
// result := weapon ;
71671: LD_ADDR_VAR 0 3
71675: PUSH
71676: LD_VAR 0 18
71680: ST_TO_ADDR
// end ; end ;
71681: LD_VAR 0 3
71685: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
71686: LD_INT 0
71688: PPUSH
71689: PPUSH
// result := true ;
71690: LD_ADDR_VAR 0 3
71694: PUSH
71695: LD_INT 1
71697: ST_TO_ADDR
// if array1 = array2 then
71698: LD_VAR 0 1
71702: PUSH
71703: LD_VAR 0 2
71707: EQUAL
71708: IFFALSE 71768
// begin for i = 1 to array1 do
71710: LD_ADDR_VAR 0 4
71714: PUSH
71715: DOUBLE
71716: LD_INT 1
71718: DEC
71719: ST_TO_ADDR
71720: LD_VAR 0 1
71724: PUSH
71725: FOR_TO
71726: IFFALSE 71764
// if array1 [ i ] <> array2 [ i ] then
71728: LD_VAR 0 1
71732: PUSH
71733: LD_VAR 0 4
71737: ARRAY
71738: PUSH
71739: LD_VAR 0 2
71743: PUSH
71744: LD_VAR 0 4
71748: ARRAY
71749: NONEQUAL
71750: IFFALSE 71762
// begin result := false ;
71752: LD_ADDR_VAR 0 3
71756: PUSH
71757: LD_INT 0
71759: ST_TO_ADDR
// break ;
71760: GO 71764
// end ;
71762: GO 71725
71764: POP
71765: POP
// end else
71766: GO 71776
// result := false ;
71768: LD_ADDR_VAR 0 3
71772: PUSH
71773: LD_INT 0
71775: ST_TO_ADDR
// end ;
71776: LD_VAR 0 3
71780: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
71781: LD_INT 0
71783: PPUSH
71784: PPUSH
// if not array1 or not array2 then
71785: LD_VAR 0 1
71789: NOT
71790: PUSH
71791: LD_VAR 0 2
71795: NOT
71796: OR
71797: IFFALSE 71801
// exit ;
71799: GO 71865
// result := true ;
71801: LD_ADDR_VAR 0 3
71805: PUSH
71806: LD_INT 1
71808: ST_TO_ADDR
// for i = 1 to array1 do
71809: LD_ADDR_VAR 0 4
71813: PUSH
71814: DOUBLE
71815: LD_INT 1
71817: DEC
71818: ST_TO_ADDR
71819: LD_VAR 0 1
71823: PUSH
71824: FOR_TO
71825: IFFALSE 71863
// if array1 [ i ] <> array2 [ i ] then
71827: LD_VAR 0 1
71831: PUSH
71832: LD_VAR 0 4
71836: ARRAY
71837: PUSH
71838: LD_VAR 0 2
71842: PUSH
71843: LD_VAR 0 4
71847: ARRAY
71848: NONEQUAL
71849: IFFALSE 71861
// begin result := false ;
71851: LD_ADDR_VAR 0 3
71855: PUSH
71856: LD_INT 0
71858: ST_TO_ADDR
// break ;
71859: GO 71863
// end ;
71861: GO 71824
71863: POP
71864: POP
// end ;
71865: LD_VAR 0 3
71869: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
71870: LD_INT 0
71872: PPUSH
71873: PPUSH
71874: PPUSH
// pom := GetBase ( fac ) ;
71875: LD_ADDR_VAR 0 5
71879: PUSH
71880: LD_VAR 0 1
71884: PPUSH
71885: CALL_OW 274
71889: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
71890: LD_ADDR_VAR 0 4
71894: PUSH
71895: LD_VAR 0 2
71899: PUSH
71900: LD_INT 1
71902: ARRAY
71903: PPUSH
71904: LD_VAR 0 2
71908: PUSH
71909: LD_INT 2
71911: ARRAY
71912: PPUSH
71913: LD_VAR 0 2
71917: PUSH
71918: LD_INT 3
71920: ARRAY
71921: PPUSH
71922: LD_VAR 0 2
71926: PUSH
71927: LD_INT 4
71929: ARRAY
71930: PPUSH
71931: CALL_OW 449
71935: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
71936: LD_ADDR_VAR 0 3
71940: PUSH
71941: LD_VAR 0 5
71945: PPUSH
71946: LD_INT 1
71948: PPUSH
71949: CALL_OW 275
71953: PUSH
71954: LD_VAR 0 4
71958: PUSH
71959: LD_INT 1
71961: ARRAY
71962: GREATEREQUAL
71963: PUSH
71964: LD_VAR 0 5
71968: PPUSH
71969: LD_INT 2
71971: PPUSH
71972: CALL_OW 275
71976: PUSH
71977: LD_VAR 0 4
71981: PUSH
71982: LD_INT 2
71984: ARRAY
71985: GREATEREQUAL
71986: AND
71987: PUSH
71988: LD_VAR 0 5
71992: PPUSH
71993: LD_INT 3
71995: PPUSH
71996: CALL_OW 275
72000: PUSH
72001: LD_VAR 0 4
72005: PUSH
72006: LD_INT 3
72008: ARRAY
72009: GREATEREQUAL
72010: AND
72011: ST_TO_ADDR
// end ;
72012: LD_VAR 0 3
72016: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
72017: LD_INT 0
72019: PPUSH
72020: PPUSH
72021: PPUSH
72022: PPUSH
// pom := GetBase ( building ) ;
72023: LD_ADDR_VAR 0 3
72027: PUSH
72028: LD_VAR 0 1
72032: PPUSH
72033: CALL_OW 274
72037: ST_TO_ADDR
// if not pom then
72038: LD_VAR 0 3
72042: NOT
72043: IFFALSE 72047
// exit ;
72045: GO 72217
// btype := GetBType ( building ) ;
72047: LD_ADDR_VAR 0 5
72051: PUSH
72052: LD_VAR 0 1
72056: PPUSH
72057: CALL_OW 266
72061: ST_TO_ADDR
// if btype = b_armoury then
72062: LD_VAR 0 5
72066: PUSH
72067: LD_INT 4
72069: EQUAL
72070: IFFALSE 72080
// btype := b_barracks ;
72072: LD_ADDR_VAR 0 5
72076: PUSH
72077: LD_INT 5
72079: ST_TO_ADDR
// if btype = b_depot then
72080: LD_VAR 0 5
72084: PUSH
72085: LD_INT 0
72087: EQUAL
72088: IFFALSE 72098
// btype := b_warehouse ;
72090: LD_ADDR_VAR 0 5
72094: PUSH
72095: LD_INT 1
72097: ST_TO_ADDR
// if btype = b_workshop then
72098: LD_VAR 0 5
72102: PUSH
72103: LD_INT 2
72105: EQUAL
72106: IFFALSE 72116
// btype := b_factory ;
72108: LD_ADDR_VAR 0 5
72112: PUSH
72113: LD_INT 3
72115: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72116: LD_ADDR_VAR 0 4
72120: PUSH
72121: LD_VAR 0 5
72125: PPUSH
72126: LD_VAR 0 1
72130: PPUSH
72131: CALL_OW 248
72135: PPUSH
72136: CALL_OW 450
72140: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72141: LD_ADDR_VAR 0 2
72145: PUSH
72146: LD_VAR 0 3
72150: PPUSH
72151: LD_INT 1
72153: PPUSH
72154: CALL_OW 275
72158: PUSH
72159: LD_VAR 0 4
72163: PUSH
72164: LD_INT 1
72166: ARRAY
72167: GREATEREQUAL
72168: PUSH
72169: LD_VAR 0 3
72173: PPUSH
72174: LD_INT 2
72176: PPUSH
72177: CALL_OW 275
72181: PUSH
72182: LD_VAR 0 4
72186: PUSH
72187: LD_INT 2
72189: ARRAY
72190: GREATEREQUAL
72191: AND
72192: PUSH
72193: LD_VAR 0 3
72197: PPUSH
72198: LD_INT 3
72200: PPUSH
72201: CALL_OW 275
72205: PUSH
72206: LD_VAR 0 4
72210: PUSH
72211: LD_INT 3
72213: ARRAY
72214: GREATEREQUAL
72215: AND
72216: ST_TO_ADDR
// end ;
72217: LD_VAR 0 2
72221: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
72222: LD_INT 0
72224: PPUSH
72225: PPUSH
72226: PPUSH
// pom := GetBase ( building ) ;
72227: LD_ADDR_VAR 0 4
72231: PUSH
72232: LD_VAR 0 1
72236: PPUSH
72237: CALL_OW 274
72241: ST_TO_ADDR
// if not pom then
72242: LD_VAR 0 4
72246: NOT
72247: IFFALSE 72251
// exit ;
72249: GO 72352
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72251: LD_ADDR_VAR 0 5
72255: PUSH
72256: LD_VAR 0 2
72260: PPUSH
72261: LD_VAR 0 1
72265: PPUSH
72266: CALL_OW 248
72270: PPUSH
72271: CALL_OW 450
72275: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72276: LD_ADDR_VAR 0 3
72280: PUSH
72281: LD_VAR 0 4
72285: PPUSH
72286: LD_INT 1
72288: PPUSH
72289: CALL_OW 275
72293: PUSH
72294: LD_VAR 0 5
72298: PUSH
72299: LD_INT 1
72301: ARRAY
72302: GREATEREQUAL
72303: PUSH
72304: LD_VAR 0 4
72308: PPUSH
72309: LD_INT 2
72311: PPUSH
72312: CALL_OW 275
72316: PUSH
72317: LD_VAR 0 5
72321: PUSH
72322: LD_INT 2
72324: ARRAY
72325: GREATEREQUAL
72326: AND
72327: PUSH
72328: LD_VAR 0 4
72332: PPUSH
72333: LD_INT 3
72335: PPUSH
72336: CALL_OW 275
72340: PUSH
72341: LD_VAR 0 5
72345: PUSH
72346: LD_INT 3
72348: ARRAY
72349: GREATEREQUAL
72350: AND
72351: ST_TO_ADDR
// end ;
72352: LD_VAR 0 3
72356: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
72357: LD_INT 0
72359: PPUSH
72360: PPUSH
72361: PPUSH
72362: PPUSH
72363: PPUSH
72364: PPUSH
72365: PPUSH
72366: PPUSH
72367: PPUSH
72368: PPUSH
72369: PPUSH
// result := false ;
72370: LD_ADDR_VAR 0 8
72374: PUSH
72375: LD_INT 0
72377: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
72378: LD_VAR 0 5
72382: NOT
72383: PUSH
72384: LD_VAR 0 1
72388: NOT
72389: OR
72390: PUSH
72391: LD_VAR 0 2
72395: NOT
72396: OR
72397: PUSH
72398: LD_VAR 0 3
72402: NOT
72403: OR
72404: IFFALSE 72408
// exit ;
72406: GO 73222
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
72408: LD_ADDR_VAR 0 14
72412: PUSH
72413: LD_VAR 0 1
72417: PPUSH
72418: LD_VAR 0 2
72422: PPUSH
72423: LD_VAR 0 3
72427: PPUSH
72428: LD_VAR 0 4
72432: PPUSH
72433: LD_VAR 0 5
72437: PUSH
72438: LD_INT 1
72440: ARRAY
72441: PPUSH
72442: CALL_OW 248
72446: PPUSH
72447: LD_INT 0
72449: PPUSH
72450: CALL 74059 0 6
72454: ST_TO_ADDR
// if not hexes then
72455: LD_VAR 0 14
72459: NOT
72460: IFFALSE 72464
// exit ;
72462: GO 73222
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72464: LD_ADDR_VAR 0 17
72468: PUSH
72469: LD_VAR 0 5
72473: PPUSH
72474: LD_INT 22
72476: PUSH
72477: LD_VAR 0 13
72481: PPUSH
72482: CALL_OW 255
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 2
72493: PUSH
72494: LD_INT 30
72496: PUSH
72497: LD_INT 0
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: PUSH
72504: LD_INT 30
72506: PUSH
72507: LD_INT 1
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: LIST
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PPUSH
72523: CALL_OW 72
72527: ST_TO_ADDR
// for i = 1 to hexes do
72528: LD_ADDR_VAR 0 9
72532: PUSH
72533: DOUBLE
72534: LD_INT 1
72536: DEC
72537: ST_TO_ADDR
72538: LD_VAR 0 14
72542: PUSH
72543: FOR_TO
72544: IFFALSE 73220
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
72546: LD_ADDR_VAR 0 13
72550: PUSH
72551: LD_VAR 0 14
72555: PUSH
72556: LD_VAR 0 9
72560: ARRAY
72561: PUSH
72562: LD_INT 1
72564: ARRAY
72565: PPUSH
72566: LD_VAR 0 14
72570: PUSH
72571: LD_VAR 0 9
72575: ARRAY
72576: PUSH
72577: LD_INT 2
72579: ARRAY
72580: PPUSH
72581: CALL_OW 428
72585: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
72586: LD_VAR 0 14
72590: PUSH
72591: LD_VAR 0 9
72595: ARRAY
72596: PUSH
72597: LD_INT 1
72599: ARRAY
72600: PPUSH
72601: LD_VAR 0 14
72605: PUSH
72606: LD_VAR 0 9
72610: ARRAY
72611: PUSH
72612: LD_INT 2
72614: ARRAY
72615: PPUSH
72616: CALL_OW 351
72620: PUSH
72621: LD_VAR 0 14
72625: PUSH
72626: LD_VAR 0 9
72630: ARRAY
72631: PUSH
72632: LD_INT 1
72634: ARRAY
72635: PPUSH
72636: LD_VAR 0 14
72640: PUSH
72641: LD_VAR 0 9
72645: ARRAY
72646: PUSH
72647: LD_INT 2
72649: ARRAY
72650: PPUSH
72651: CALL_OW 488
72655: NOT
72656: OR
72657: PUSH
72658: LD_VAR 0 13
72662: PPUSH
72663: CALL_OW 247
72667: PUSH
72668: LD_INT 3
72670: EQUAL
72671: OR
72672: IFFALSE 72678
// exit ;
72674: POP
72675: POP
72676: GO 73222
// if not tmp then
72678: LD_VAR 0 13
72682: NOT
72683: IFFALSE 72687
// continue ;
72685: GO 72543
// result := true ;
72687: LD_ADDR_VAR 0 8
72691: PUSH
72692: LD_INT 1
72694: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
72695: LD_VAR 0 6
72699: PUSH
72700: LD_VAR 0 13
72704: PPUSH
72705: CALL_OW 247
72709: PUSH
72710: LD_INT 2
72712: EQUAL
72713: AND
72714: PUSH
72715: LD_VAR 0 13
72719: PPUSH
72720: CALL_OW 263
72724: PUSH
72725: LD_INT 1
72727: EQUAL
72728: AND
72729: IFFALSE 72893
// begin if IsDrivenBy ( tmp ) then
72731: LD_VAR 0 13
72735: PPUSH
72736: CALL_OW 311
72740: IFFALSE 72744
// continue ;
72742: GO 72543
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
72744: LD_VAR 0 6
72748: PPUSH
72749: LD_INT 3
72751: PUSH
72752: LD_INT 60
72754: PUSH
72755: EMPTY
72756: LIST
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 3
72764: PUSH
72765: LD_INT 55
72767: PUSH
72768: EMPTY
72769: LIST
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PPUSH
72779: CALL_OW 72
72783: IFFALSE 72891
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
72785: LD_ADDR_VAR 0 18
72789: PUSH
72790: LD_VAR 0 6
72794: PPUSH
72795: LD_INT 3
72797: PUSH
72798: LD_INT 60
72800: PUSH
72801: EMPTY
72802: LIST
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PUSH
72808: LD_INT 3
72810: PUSH
72811: LD_INT 55
72813: PUSH
72814: EMPTY
72815: LIST
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PPUSH
72825: CALL_OW 72
72829: PUSH
72830: LD_INT 1
72832: ARRAY
72833: ST_TO_ADDR
// if IsInUnit ( driver ) then
72834: LD_VAR 0 18
72838: PPUSH
72839: CALL_OW 310
72843: IFFALSE 72854
// ComExit ( driver ) ;
72845: LD_VAR 0 18
72849: PPUSH
72850: CALL 97243 0 1
// AddComEnterUnit ( driver , tmp ) ;
72854: LD_VAR 0 18
72858: PPUSH
72859: LD_VAR 0 13
72863: PPUSH
72864: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
72868: LD_VAR 0 18
72872: PPUSH
72873: LD_VAR 0 7
72877: PPUSH
72878: CALL_OW 173
// AddComExitVehicle ( driver ) ;
72882: LD_VAR 0 18
72886: PPUSH
72887: CALL_OW 181
// end ; continue ;
72891: GO 72543
// end ; if not cleaners or not tmp in cleaners then
72893: LD_VAR 0 6
72897: NOT
72898: PUSH
72899: LD_VAR 0 13
72903: PUSH
72904: LD_VAR 0 6
72908: IN
72909: NOT
72910: OR
72911: IFFALSE 73218
// begin if dep then
72913: LD_VAR 0 17
72917: IFFALSE 73053
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
72919: LD_ADDR_VAR 0 16
72923: PUSH
72924: LD_VAR 0 17
72928: PUSH
72929: LD_INT 1
72931: ARRAY
72932: PPUSH
72933: CALL_OW 250
72937: PPUSH
72938: LD_VAR 0 17
72942: PUSH
72943: LD_INT 1
72945: ARRAY
72946: PPUSH
72947: CALL_OW 254
72951: PPUSH
72952: LD_INT 5
72954: PPUSH
72955: CALL_OW 272
72959: PUSH
72960: LD_VAR 0 17
72964: PUSH
72965: LD_INT 1
72967: ARRAY
72968: PPUSH
72969: CALL_OW 251
72973: PPUSH
72974: LD_VAR 0 17
72978: PUSH
72979: LD_INT 1
72981: ARRAY
72982: PPUSH
72983: CALL_OW 254
72987: PPUSH
72988: LD_INT 5
72990: PPUSH
72991: CALL_OW 273
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
73000: LD_VAR 0 16
73004: PUSH
73005: LD_INT 1
73007: ARRAY
73008: PPUSH
73009: LD_VAR 0 16
73013: PUSH
73014: LD_INT 2
73016: ARRAY
73017: PPUSH
73018: CALL_OW 488
73022: IFFALSE 73053
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
73024: LD_VAR 0 13
73028: PPUSH
73029: LD_VAR 0 16
73033: PUSH
73034: LD_INT 1
73036: ARRAY
73037: PPUSH
73038: LD_VAR 0 16
73042: PUSH
73043: LD_INT 2
73045: ARRAY
73046: PPUSH
73047: CALL_OW 111
// continue ;
73051: GO 72543
// end ; end ; r := GetDir ( tmp ) ;
73053: LD_ADDR_VAR 0 15
73057: PUSH
73058: LD_VAR 0 13
73062: PPUSH
73063: CALL_OW 254
73067: ST_TO_ADDR
// if r = 5 then
73068: LD_VAR 0 15
73072: PUSH
73073: LD_INT 5
73075: EQUAL
73076: IFFALSE 73086
// r := 0 ;
73078: LD_ADDR_VAR 0 15
73082: PUSH
73083: LD_INT 0
73085: ST_TO_ADDR
// for j = r to 5 do
73086: LD_ADDR_VAR 0 10
73090: PUSH
73091: DOUBLE
73092: LD_VAR 0 15
73096: DEC
73097: ST_TO_ADDR
73098: LD_INT 5
73100: PUSH
73101: FOR_TO
73102: IFFALSE 73216
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
73104: LD_ADDR_VAR 0 11
73108: PUSH
73109: LD_VAR 0 13
73113: PPUSH
73114: CALL_OW 250
73118: PPUSH
73119: LD_VAR 0 10
73123: PPUSH
73124: LD_INT 2
73126: PPUSH
73127: CALL_OW 272
73131: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
73132: LD_ADDR_VAR 0 12
73136: PUSH
73137: LD_VAR 0 13
73141: PPUSH
73142: CALL_OW 251
73146: PPUSH
73147: LD_VAR 0 10
73151: PPUSH
73152: LD_INT 2
73154: PPUSH
73155: CALL_OW 273
73159: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
73160: LD_VAR 0 11
73164: PPUSH
73165: LD_VAR 0 12
73169: PPUSH
73170: CALL_OW 488
73174: PUSH
73175: LD_VAR 0 11
73179: PPUSH
73180: LD_VAR 0 12
73184: PPUSH
73185: CALL_OW 428
73189: NOT
73190: AND
73191: IFFALSE 73214
// begin ComMoveXY ( tmp , _x , _y ) ;
73193: LD_VAR 0 13
73197: PPUSH
73198: LD_VAR 0 11
73202: PPUSH
73203: LD_VAR 0 12
73207: PPUSH
73208: CALL_OW 111
// break ;
73212: GO 73216
// end ; end ;
73214: GO 73101
73216: POP
73217: POP
// end ; end ;
73218: GO 72543
73220: POP
73221: POP
// end ;
73222: LD_VAR 0 8
73226: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
73227: LD_INT 0
73229: PPUSH
73230: PPUSH
73231: PPUSH
73232: PPUSH
73233: PPUSH
73234: PPUSH
73235: PPUSH
73236: PPUSH
73237: PPUSH
73238: PPUSH
// result := false ;
73239: LD_ADDR_VAR 0 6
73243: PUSH
73244: LD_INT 0
73246: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
73247: LD_VAR 0 1
73251: NOT
73252: PUSH
73253: LD_VAR 0 1
73257: PPUSH
73258: CALL_OW 266
73262: PUSH
73263: LD_INT 0
73265: PUSH
73266: LD_INT 1
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: IN
73273: NOT
73274: OR
73275: PUSH
73276: LD_VAR 0 2
73280: NOT
73281: OR
73282: PUSH
73283: LD_VAR 0 5
73287: PUSH
73288: LD_INT 0
73290: PUSH
73291: LD_INT 1
73293: PUSH
73294: LD_INT 2
73296: PUSH
73297: LD_INT 3
73299: PUSH
73300: LD_INT 4
73302: PUSH
73303: LD_INT 5
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: IN
73314: NOT
73315: OR
73316: PUSH
73317: LD_VAR 0 3
73321: PPUSH
73322: LD_VAR 0 4
73326: PPUSH
73327: CALL_OW 488
73331: NOT
73332: OR
73333: IFFALSE 73337
// exit ;
73335: GO 74054
// pom := GetBase ( depot ) ;
73337: LD_ADDR_VAR 0 10
73341: PUSH
73342: LD_VAR 0 1
73346: PPUSH
73347: CALL_OW 274
73351: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
73352: LD_ADDR_VAR 0 11
73356: PUSH
73357: LD_VAR 0 2
73361: PPUSH
73362: LD_VAR 0 1
73366: PPUSH
73367: CALL_OW 248
73371: PPUSH
73372: CALL_OW 450
73376: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
73377: LD_VAR 0 10
73381: PPUSH
73382: LD_INT 1
73384: PPUSH
73385: CALL_OW 275
73389: PUSH
73390: LD_VAR 0 11
73394: PUSH
73395: LD_INT 1
73397: ARRAY
73398: GREATEREQUAL
73399: PUSH
73400: LD_VAR 0 10
73404: PPUSH
73405: LD_INT 2
73407: PPUSH
73408: CALL_OW 275
73412: PUSH
73413: LD_VAR 0 11
73417: PUSH
73418: LD_INT 2
73420: ARRAY
73421: GREATEREQUAL
73422: AND
73423: PUSH
73424: LD_VAR 0 10
73428: PPUSH
73429: LD_INT 3
73431: PPUSH
73432: CALL_OW 275
73436: PUSH
73437: LD_VAR 0 11
73441: PUSH
73442: LD_INT 3
73444: ARRAY
73445: GREATEREQUAL
73446: AND
73447: NOT
73448: IFFALSE 73452
// exit ;
73450: GO 74054
// if GetBType ( depot ) = b_depot then
73452: LD_VAR 0 1
73456: PPUSH
73457: CALL_OW 266
73461: PUSH
73462: LD_INT 0
73464: EQUAL
73465: IFFALSE 73477
// dist := 28 else
73467: LD_ADDR_VAR 0 14
73471: PUSH
73472: LD_INT 28
73474: ST_TO_ADDR
73475: GO 73485
// dist := 36 ;
73477: LD_ADDR_VAR 0 14
73481: PUSH
73482: LD_INT 36
73484: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
73485: LD_VAR 0 1
73489: PPUSH
73490: LD_VAR 0 3
73494: PPUSH
73495: LD_VAR 0 4
73499: PPUSH
73500: CALL_OW 297
73504: PUSH
73505: LD_VAR 0 14
73509: GREATER
73510: IFFALSE 73514
// exit ;
73512: GO 74054
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
73514: LD_ADDR_VAR 0 12
73518: PUSH
73519: LD_VAR 0 2
73523: PPUSH
73524: LD_VAR 0 3
73528: PPUSH
73529: LD_VAR 0 4
73533: PPUSH
73534: LD_VAR 0 5
73538: PPUSH
73539: LD_VAR 0 1
73543: PPUSH
73544: CALL_OW 248
73548: PPUSH
73549: LD_INT 0
73551: PPUSH
73552: CALL 74059 0 6
73556: ST_TO_ADDR
// if not hexes then
73557: LD_VAR 0 12
73561: NOT
73562: IFFALSE 73566
// exit ;
73564: GO 74054
// hex := GetHexInfo ( x , y ) ;
73566: LD_ADDR_VAR 0 15
73570: PUSH
73571: LD_VAR 0 3
73575: PPUSH
73576: LD_VAR 0 4
73580: PPUSH
73581: CALL_OW 546
73585: ST_TO_ADDR
// if hex [ 1 ] then
73586: LD_VAR 0 15
73590: PUSH
73591: LD_INT 1
73593: ARRAY
73594: IFFALSE 73598
// exit ;
73596: GO 74054
// height := hex [ 2 ] ;
73598: LD_ADDR_VAR 0 13
73602: PUSH
73603: LD_VAR 0 15
73607: PUSH
73608: LD_INT 2
73610: ARRAY
73611: ST_TO_ADDR
// for i = 1 to hexes do
73612: LD_ADDR_VAR 0 7
73616: PUSH
73617: DOUBLE
73618: LD_INT 1
73620: DEC
73621: ST_TO_ADDR
73622: LD_VAR 0 12
73626: PUSH
73627: FOR_TO
73628: IFFALSE 73958
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
73630: LD_VAR 0 12
73634: PUSH
73635: LD_VAR 0 7
73639: ARRAY
73640: PUSH
73641: LD_INT 1
73643: ARRAY
73644: PPUSH
73645: LD_VAR 0 12
73649: PUSH
73650: LD_VAR 0 7
73654: ARRAY
73655: PUSH
73656: LD_INT 2
73658: ARRAY
73659: PPUSH
73660: CALL_OW 488
73664: NOT
73665: PUSH
73666: LD_VAR 0 12
73670: PUSH
73671: LD_VAR 0 7
73675: ARRAY
73676: PUSH
73677: LD_INT 1
73679: ARRAY
73680: PPUSH
73681: LD_VAR 0 12
73685: PUSH
73686: LD_VAR 0 7
73690: ARRAY
73691: PUSH
73692: LD_INT 2
73694: ARRAY
73695: PPUSH
73696: CALL_OW 428
73700: PUSH
73701: LD_INT 0
73703: GREATER
73704: OR
73705: PUSH
73706: LD_VAR 0 12
73710: PUSH
73711: LD_VAR 0 7
73715: ARRAY
73716: PUSH
73717: LD_INT 1
73719: ARRAY
73720: PPUSH
73721: LD_VAR 0 12
73725: PUSH
73726: LD_VAR 0 7
73730: ARRAY
73731: PUSH
73732: LD_INT 2
73734: ARRAY
73735: PPUSH
73736: CALL_OW 351
73740: OR
73741: IFFALSE 73747
// exit ;
73743: POP
73744: POP
73745: GO 74054
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
73747: LD_ADDR_VAR 0 8
73751: PUSH
73752: LD_VAR 0 12
73756: PUSH
73757: LD_VAR 0 7
73761: ARRAY
73762: PUSH
73763: LD_INT 1
73765: ARRAY
73766: PPUSH
73767: LD_VAR 0 12
73771: PUSH
73772: LD_VAR 0 7
73776: ARRAY
73777: PUSH
73778: LD_INT 2
73780: ARRAY
73781: PPUSH
73782: CALL_OW 546
73786: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
73787: LD_VAR 0 8
73791: PUSH
73792: LD_INT 1
73794: ARRAY
73795: PUSH
73796: LD_VAR 0 8
73800: PUSH
73801: LD_INT 2
73803: ARRAY
73804: PUSH
73805: LD_VAR 0 13
73809: PUSH
73810: LD_INT 2
73812: PLUS
73813: GREATER
73814: OR
73815: PUSH
73816: LD_VAR 0 8
73820: PUSH
73821: LD_INT 2
73823: ARRAY
73824: PUSH
73825: LD_VAR 0 13
73829: PUSH
73830: LD_INT 2
73832: MINUS
73833: LESS
73834: OR
73835: PUSH
73836: LD_VAR 0 8
73840: PUSH
73841: LD_INT 3
73843: ARRAY
73844: PUSH
73845: LD_INT 0
73847: PUSH
73848: LD_INT 8
73850: PUSH
73851: LD_INT 9
73853: PUSH
73854: LD_INT 10
73856: PUSH
73857: LD_INT 11
73859: PUSH
73860: LD_INT 12
73862: PUSH
73863: LD_INT 13
73865: PUSH
73866: LD_INT 16
73868: PUSH
73869: LD_INT 17
73871: PUSH
73872: LD_INT 18
73874: PUSH
73875: LD_INT 19
73877: PUSH
73878: LD_INT 20
73880: PUSH
73881: LD_INT 21
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: IN
73899: NOT
73900: OR
73901: PUSH
73902: LD_VAR 0 8
73906: PUSH
73907: LD_INT 5
73909: ARRAY
73910: NOT
73911: OR
73912: PUSH
73913: LD_VAR 0 8
73917: PUSH
73918: LD_INT 6
73920: ARRAY
73921: PUSH
73922: LD_INT 1
73924: PUSH
73925: LD_INT 2
73927: PUSH
73928: LD_INT 7
73930: PUSH
73931: LD_INT 9
73933: PUSH
73934: LD_INT 10
73936: PUSH
73937: LD_INT 11
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: LIST
73944: LIST
73945: LIST
73946: LIST
73947: IN
73948: NOT
73949: OR
73950: IFFALSE 73956
// exit ;
73952: POP
73953: POP
73954: GO 74054
// end ;
73956: GO 73627
73958: POP
73959: POP
// side := GetSide ( depot ) ;
73960: LD_ADDR_VAR 0 9
73964: PUSH
73965: LD_VAR 0 1
73969: PPUSH
73970: CALL_OW 255
73974: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73975: LD_VAR 0 9
73979: PPUSH
73980: LD_VAR 0 3
73984: PPUSH
73985: LD_VAR 0 4
73989: PPUSH
73990: LD_INT 20
73992: PPUSH
73993: CALL 66375 0 4
73997: PUSH
73998: LD_INT 4
74000: ARRAY
74001: IFFALSE 74005
// exit ;
74003: GO 74054
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
74005: LD_VAR 0 2
74009: PUSH
74010: LD_INT 29
74012: PUSH
74013: LD_INT 30
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: IN
74020: PUSH
74021: LD_VAR 0 3
74025: PPUSH
74026: LD_VAR 0 4
74030: PPUSH
74031: LD_VAR 0 9
74035: PPUSH
74036: CALL_OW 440
74040: NOT
74041: AND
74042: IFFALSE 74046
// exit ;
74044: GO 74054
// result := true ;
74046: LD_ADDR_VAR 0 6
74050: PUSH
74051: LD_INT 1
74053: ST_TO_ADDR
// end ;
74054: LD_VAR 0 6
74058: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
74059: LD_INT 0
74061: PPUSH
74062: PPUSH
74063: PPUSH
74064: PPUSH
74065: PPUSH
74066: PPUSH
74067: PPUSH
74068: PPUSH
74069: PPUSH
74070: PPUSH
74071: PPUSH
74072: PPUSH
74073: PPUSH
74074: PPUSH
74075: PPUSH
74076: PPUSH
74077: PPUSH
74078: PPUSH
74079: PPUSH
74080: PPUSH
74081: PPUSH
74082: PPUSH
74083: PPUSH
74084: PPUSH
74085: PPUSH
74086: PPUSH
74087: PPUSH
74088: PPUSH
74089: PPUSH
74090: PPUSH
74091: PPUSH
74092: PPUSH
74093: PPUSH
74094: PPUSH
74095: PPUSH
74096: PPUSH
74097: PPUSH
74098: PPUSH
74099: PPUSH
74100: PPUSH
74101: PPUSH
74102: PPUSH
74103: PPUSH
74104: PPUSH
74105: PPUSH
74106: PPUSH
74107: PPUSH
74108: PPUSH
74109: PPUSH
74110: PPUSH
74111: PPUSH
74112: PPUSH
74113: PPUSH
74114: PPUSH
74115: PPUSH
74116: PPUSH
74117: PPUSH
74118: PPUSH
// result = [ ] ;
74119: LD_ADDR_VAR 0 7
74123: PUSH
74124: EMPTY
74125: ST_TO_ADDR
// temp_list = [ ] ;
74126: LD_ADDR_VAR 0 9
74130: PUSH
74131: EMPTY
74132: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
74133: LD_VAR 0 4
74137: PUSH
74138: LD_INT 0
74140: PUSH
74141: LD_INT 1
74143: PUSH
74144: LD_INT 2
74146: PUSH
74147: LD_INT 3
74149: PUSH
74150: LD_INT 4
74152: PUSH
74153: LD_INT 5
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: LIST
74160: LIST
74161: LIST
74162: LIST
74163: IN
74164: NOT
74165: PUSH
74166: LD_VAR 0 1
74170: PUSH
74171: LD_INT 0
74173: PUSH
74174: LD_INT 1
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: IN
74181: PUSH
74182: LD_VAR 0 5
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: LD_INT 2
74192: PUSH
74193: LD_INT 3
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: LIST
74200: IN
74201: NOT
74202: AND
74203: OR
74204: IFFALSE 74208
// exit ;
74206: GO 92599
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
74208: LD_VAR 0 1
74212: PUSH
74213: LD_INT 6
74215: PUSH
74216: LD_INT 7
74218: PUSH
74219: LD_INT 8
74221: PUSH
74222: LD_INT 13
74224: PUSH
74225: LD_INT 12
74227: PUSH
74228: LD_INT 15
74230: PUSH
74231: LD_INT 11
74233: PUSH
74234: LD_INT 14
74236: PUSH
74237: LD_INT 10
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: LIST
74244: LIST
74245: LIST
74246: LIST
74247: LIST
74248: LIST
74249: LIST
74250: IN
74251: IFFALSE 74261
// btype = b_lab ;
74253: LD_ADDR_VAR 0 1
74257: PUSH
74258: LD_INT 6
74260: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
74261: LD_VAR 0 6
74265: PUSH
74266: LD_INT 0
74268: PUSH
74269: LD_INT 1
74271: PUSH
74272: LD_INT 2
74274: PUSH
74275: EMPTY
74276: LIST
74277: LIST
74278: LIST
74279: IN
74280: NOT
74281: PUSH
74282: LD_VAR 0 1
74286: PUSH
74287: LD_INT 0
74289: PUSH
74290: LD_INT 1
74292: PUSH
74293: LD_INT 2
74295: PUSH
74296: LD_INT 3
74298: PUSH
74299: LD_INT 6
74301: PUSH
74302: LD_INT 36
74304: PUSH
74305: LD_INT 4
74307: PUSH
74308: LD_INT 5
74310: PUSH
74311: LD_INT 31
74313: PUSH
74314: LD_INT 32
74316: PUSH
74317: LD_INT 33
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: LIST
74324: LIST
74325: LIST
74326: LIST
74327: LIST
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: IN
74333: NOT
74334: PUSH
74335: LD_VAR 0 6
74339: PUSH
74340: LD_INT 1
74342: EQUAL
74343: AND
74344: OR
74345: PUSH
74346: LD_VAR 0 1
74350: PUSH
74351: LD_INT 2
74353: PUSH
74354: LD_INT 3
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: IN
74361: NOT
74362: PUSH
74363: LD_VAR 0 6
74367: PUSH
74368: LD_INT 2
74370: EQUAL
74371: AND
74372: OR
74373: IFFALSE 74383
// mode = 0 ;
74375: LD_ADDR_VAR 0 6
74379: PUSH
74380: LD_INT 0
74382: ST_TO_ADDR
// case mode of 0 :
74383: LD_VAR 0 6
74387: PUSH
74388: LD_INT 0
74390: DOUBLE
74391: EQUAL
74392: IFTRUE 74396
74394: GO 85849
74396: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74397: LD_ADDR_VAR 0 11
74401: PUSH
74402: LD_INT 0
74404: PUSH
74405: LD_INT 0
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: PUSH
74412: LD_INT 0
74414: PUSH
74415: LD_INT 1
74417: NEG
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 1
74425: PUSH
74426: LD_INT 0
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 1
74435: PUSH
74436: LD_INT 1
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 0
74445: PUSH
74446: LD_INT 1
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 1
74455: NEG
74456: PUSH
74457: LD_INT 0
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: PUSH
74464: LD_INT 1
74466: NEG
74467: PUSH
74468: LD_INT 1
74470: NEG
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 1
74478: NEG
74479: PUSH
74480: LD_INT 2
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 0
74490: PUSH
74491: LD_INT 2
74493: NEG
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: LD_INT 1
74504: NEG
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 1
74512: PUSH
74513: LD_INT 2
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 0
74522: PUSH
74523: LD_INT 2
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: LD_INT 1
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: PUSH
74541: LD_INT 1
74543: PUSH
74544: LD_INT 3
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: LD_INT 0
74553: PUSH
74554: LD_INT 3
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 1
74563: NEG
74564: PUSH
74565: LD_INT 2
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: LIST
74580: LIST
74581: LIST
74582: LIST
74583: LIST
74584: LIST
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74590: LD_ADDR_VAR 0 12
74594: PUSH
74595: LD_INT 0
74597: PUSH
74598: LD_INT 0
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PUSH
74605: LD_INT 0
74607: PUSH
74608: LD_INT 1
74610: NEG
74611: PUSH
74612: EMPTY
74613: LIST
74614: LIST
74615: PUSH
74616: LD_INT 1
74618: PUSH
74619: LD_INT 0
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: PUSH
74626: LD_INT 1
74628: PUSH
74629: LD_INT 1
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 0
74638: PUSH
74639: LD_INT 1
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 1
74648: NEG
74649: PUSH
74650: LD_INT 0
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: LD_INT 1
74659: NEG
74660: PUSH
74661: LD_INT 1
74663: NEG
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: LD_INT 1
74671: PUSH
74672: LD_INT 1
74674: NEG
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: PUSH
74680: LD_INT 2
74682: PUSH
74683: LD_INT 0
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 2
74692: PUSH
74693: LD_INT 1
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 1
74702: NEG
74703: PUSH
74704: LD_INT 1
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 2
74713: NEG
74714: PUSH
74715: LD_INT 0
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 2
74724: NEG
74725: PUSH
74726: LD_INT 1
74728: NEG
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: LD_INT 2
74736: NEG
74737: PUSH
74738: LD_INT 1
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 3
74747: NEG
74748: PUSH
74749: LD_INT 0
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 3
74758: NEG
74759: PUSH
74760: LD_INT 1
74762: NEG
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: LIST
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74786: LD_ADDR_VAR 0 13
74790: PUSH
74791: LD_INT 0
74793: PUSH
74794: LD_INT 0
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: LD_INT 1
74806: NEG
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: LD_INT 1
74814: PUSH
74815: LD_INT 0
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 1
74824: PUSH
74825: LD_INT 1
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 0
74834: PUSH
74835: LD_INT 1
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 1
74844: NEG
74845: PUSH
74846: LD_INT 0
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 1
74855: NEG
74856: PUSH
74857: LD_INT 1
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 1
74867: NEG
74868: PUSH
74869: LD_INT 2
74871: NEG
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 2
74879: PUSH
74880: LD_INT 1
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 2
74889: PUSH
74890: LD_INT 2
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 1
74899: PUSH
74900: LD_INT 2
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 2
74909: NEG
74910: PUSH
74911: LD_INT 1
74913: NEG
74914: PUSH
74915: EMPTY
74916: LIST
74917: LIST
74918: PUSH
74919: LD_INT 2
74921: NEG
74922: PUSH
74923: LD_INT 2
74925: NEG
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: PUSH
74931: LD_INT 2
74933: NEG
74934: PUSH
74935: LD_INT 3
74937: NEG
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 3
74945: NEG
74946: PUSH
74947: LD_INT 2
74949: NEG
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 3
74957: NEG
74958: PUSH
74959: LD_INT 3
74961: NEG
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: LIST
74971: LIST
74972: LIST
74973: LIST
74974: LIST
74975: LIST
74976: LIST
74977: LIST
74978: LIST
74979: LIST
74980: LIST
74981: LIST
74982: LIST
74983: LIST
74984: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74985: LD_ADDR_VAR 0 14
74989: PUSH
74990: LD_INT 0
74992: PUSH
74993: LD_INT 0
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 0
75002: PUSH
75003: LD_INT 1
75005: NEG
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PUSH
75011: LD_INT 1
75013: PUSH
75014: LD_INT 0
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 1
75023: PUSH
75024: LD_INT 1
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: LD_INT 0
75033: PUSH
75034: LD_INT 1
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: LD_INT 1
75043: NEG
75044: PUSH
75045: LD_INT 0
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 1
75054: NEG
75055: PUSH
75056: LD_INT 1
75058: NEG
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 1
75066: NEG
75067: PUSH
75068: LD_INT 2
75070: NEG
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 0
75078: PUSH
75079: LD_INT 2
75081: NEG
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 1
75089: PUSH
75090: LD_INT 1
75092: NEG
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 1
75100: PUSH
75101: LD_INT 2
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: LD_INT 0
75110: PUSH
75111: LD_INT 2
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: LD_INT 1
75120: NEG
75121: PUSH
75122: LD_INT 1
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 1
75131: NEG
75132: PUSH
75133: LD_INT 3
75135: NEG
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PUSH
75141: LD_INT 0
75143: PUSH
75144: LD_INT 3
75146: NEG
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: LD_INT 2
75157: NEG
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: LIST
75167: LIST
75168: LIST
75169: LIST
75170: LIST
75171: LIST
75172: LIST
75173: LIST
75174: LIST
75175: LIST
75176: LIST
75177: LIST
75178: LIST
75179: LIST
75180: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75181: LD_ADDR_VAR 0 15
75185: PUSH
75186: LD_INT 0
75188: PUSH
75189: LD_INT 0
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 0
75198: PUSH
75199: LD_INT 1
75201: NEG
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: PUSH
75207: LD_INT 1
75209: PUSH
75210: LD_INT 0
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: PUSH
75217: LD_INT 1
75219: PUSH
75220: LD_INT 1
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 0
75229: PUSH
75230: LD_INT 1
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 1
75239: NEG
75240: PUSH
75241: LD_INT 0
75243: PUSH
75244: EMPTY
75245: LIST
75246: LIST
75247: PUSH
75248: LD_INT 1
75250: NEG
75251: PUSH
75252: LD_INT 1
75254: NEG
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 1
75262: PUSH
75263: LD_INT 1
75265: NEG
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 2
75273: PUSH
75274: LD_INT 0
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 2
75283: PUSH
75284: LD_INT 1
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 1
75293: NEG
75294: PUSH
75295: LD_INT 1
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 2
75304: NEG
75305: PUSH
75306: LD_INT 0
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 2
75315: NEG
75316: PUSH
75317: LD_INT 1
75319: NEG
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 2
75327: PUSH
75328: LD_INT 1
75330: NEG
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 3
75338: PUSH
75339: LD_INT 0
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 3
75348: PUSH
75349: LD_INT 1
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: LIST
75360: LIST
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: LIST
75368: LIST
75369: LIST
75370: LIST
75371: LIST
75372: LIST
75373: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75374: LD_ADDR_VAR 0 16
75378: PUSH
75379: LD_INT 0
75381: PUSH
75382: LD_INT 0
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 0
75391: PUSH
75392: LD_INT 1
75394: NEG
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 1
75402: PUSH
75403: LD_INT 0
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: LD_INT 1
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 0
75422: PUSH
75423: LD_INT 1
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 1
75432: NEG
75433: PUSH
75434: LD_INT 0
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 1
75443: NEG
75444: PUSH
75445: LD_INT 1
75447: NEG
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 1
75455: NEG
75456: PUSH
75457: LD_INT 2
75459: NEG
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 2
75467: PUSH
75468: LD_INT 1
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: PUSH
75475: LD_INT 2
75477: PUSH
75478: LD_INT 2
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: LD_INT 1
75487: PUSH
75488: LD_INT 2
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 2
75497: NEG
75498: PUSH
75499: LD_INT 1
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 2
75509: NEG
75510: PUSH
75511: LD_INT 2
75513: NEG
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 3
75521: PUSH
75522: LD_INT 2
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 3
75531: PUSH
75532: LD_INT 3
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 2
75541: PUSH
75542: LD_INT 3
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75567: LD_ADDR_VAR 0 17
75571: PUSH
75572: LD_INT 0
75574: PUSH
75575: LD_INT 0
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 0
75584: PUSH
75585: LD_INT 1
75587: NEG
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: PUSH
75593: LD_INT 1
75595: PUSH
75596: LD_INT 0
75598: PUSH
75599: EMPTY
75600: LIST
75601: LIST
75602: PUSH
75603: LD_INT 1
75605: PUSH
75606: LD_INT 1
75608: PUSH
75609: EMPTY
75610: LIST
75611: LIST
75612: PUSH
75613: LD_INT 0
75615: PUSH
75616: LD_INT 1
75618: PUSH
75619: EMPTY
75620: LIST
75621: LIST
75622: PUSH
75623: LD_INT 1
75625: NEG
75626: PUSH
75627: LD_INT 0
75629: PUSH
75630: EMPTY
75631: LIST
75632: LIST
75633: PUSH
75634: LD_INT 1
75636: NEG
75637: PUSH
75638: LD_INT 1
75640: NEG
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: LD_INT 1
75648: NEG
75649: PUSH
75650: LD_INT 2
75652: NEG
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 0
75660: PUSH
75661: LD_INT 2
75663: NEG
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 1
75671: PUSH
75672: LD_INT 1
75674: NEG
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 2
75682: PUSH
75683: LD_INT 0
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 2
75692: PUSH
75693: LD_INT 1
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 2
75702: PUSH
75703: LD_INT 2
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PUSH
75710: LD_INT 1
75712: PUSH
75713: LD_INT 2
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: LD_INT 0
75722: PUSH
75723: LD_INT 2
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: LD_INT 1
75732: NEG
75733: PUSH
75734: LD_INT 1
75736: PUSH
75737: EMPTY
75738: LIST
75739: LIST
75740: PUSH
75741: LD_INT 2
75743: NEG
75744: PUSH
75745: LD_INT 0
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 2
75754: NEG
75755: PUSH
75756: LD_INT 1
75758: NEG
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: PUSH
75764: LD_INT 2
75766: NEG
75767: PUSH
75768: LD_INT 2
75770: NEG
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: LIST
75780: LIST
75781: LIST
75782: LIST
75783: LIST
75784: LIST
75785: LIST
75786: LIST
75787: LIST
75788: LIST
75789: LIST
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: LIST
75795: LIST
75796: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75797: LD_ADDR_VAR 0 18
75801: PUSH
75802: LD_INT 0
75804: PUSH
75805: LD_INT 0
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: LD_INT 0
75814: PUSH
75815: LD_INT 1
75817: NEG
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: PUSH
75823: LD_INT 1
75825: PUSH
75826: LD_INT 0
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: LD_INT 1
75835: PUSH
75836: LD_INT 1
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: PUSH
75843: LD_INT 0
75845: PUSH
75846: LD_INT 1
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: PUSH
75853: LD_INT 1
75855: NEG
75856: PUSH
75857: LD_INT 0
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: PUSH
75864: LD_INT 1
75866: NEG
75867: PUSH
75868: LD_INT 1
75870: NEG
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 1
75878: NEG
75879: PUSH
75880: LD_INT 2
75882: NEG
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 0
75890: PUSH
75891: LD_INT 2
75893: NEG
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 1
75901: PUSH
75902: LD_INT 1
75904: NEG
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 2
75912: PUSH
75913: LD_INT 0
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 2
75922: PUSH
75923: LD_INT 1
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PUSH
75930: LD_INT 2
75932: PUSH
75933: LD_INT 2
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: LD_INT 1
75942: PUSH
75943: LD_INT 2
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: LD_INT 0
75952: PUSH
75953: LD_INT 2
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 1
75962: NEG
75963: PUSH
75964: LD_INT 1
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PUSH
75971: LD_INT 2
75973: NEG
75974: PUSH
75975: LD_INT 0
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: LD_INT 2
75984: NEG
75985: PUSH
75986: LD_INT 1
75988: NEG
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: PUSH
75994: LD_INT 2
75996: NEG
75997: PUSH
75998: LD_INT 2
76000: NEG
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: LIST
76010: LIST
76011: LIST
76012: LIST
76013: LIST
76014: LIST
76015: LIST
76016: LIST
76017: LIST
76018: LIST
76019: LIST
76020: LIST
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: LIST
76026: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76027: LD_ADDR_VAR 0 19
76031: PUSH
76032: LD_INT 0
76034: PUSH
76035: LD_INT 0
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 0
76044: PUSH
76045: LD_INT 1
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 1
76055: PUSH
76056: LD_INT 0
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 1
76065: PUSH
76066: LD_INT 1
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: LD_INT 1
76085: NEG
76086: PUSH
76087: LD_INT 0
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 1
76096: NEG
76097: PUSH
76098: LD_INT 1
76100: NEG
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: LD_INT 1
76108: NEG
76109: PUSH
76110: LD_INT 2
76112: NEG
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 0
76120: PUSH
76121: LD_INT 2
76123: NEG
76124: PUSH
76125: EMPTY
76126: LIST
76127: LIST
76128: PUSH
76129: LD_INT 1
76131: PUSH
76132: LD_INT 1
76134: NEG
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PUSH
76140: LD_INT 2
76142: PUSH
76143: LD_INT 0
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: PUSH
76150: LD_INT 2
76152: PUSH
76153: LD_INT 1
76155: PUSH
76156: EMPTY
76157: LIST
76158: LIST
76159: PUSH
76160: LD_INT 2
76162: PUSH
76163: LD_INT 2
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: LD_INT 1
76172: PUSH
76173: LD_INT 2
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 0
76182: PUSH
76183: LD_INT 2
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 1
76192: NEG
76193: PUSH
76194: LD_INT 1
76196: PUSH
76197: EMPTY
76198: LIST
76199: LIST
76200: PUSH
76201: LD_INT 2
76203: NEG
76204: PUSH
76205: LD_INT 0
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: LD_INT 2
76214: NEG
76215: PUSH
76216: LD_INT 1
76218: NEG
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 2
76226: NEG
76227: PUSH
76228: LD_INT 2
76230: NEG
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: LIST
76240: LIST
76241: LIST
76242: LIST
76243: LIST
76244: LIST
76245: LIST
76246: LIST
76247: LIST
76248: LIST
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76257: LD_ADDR_VAR 0 20
76261: PUSH
76262: LD_INT 0
76264: PUSH
76265: LD_INT 0
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 0
76274: PUSH
76275: LD_INT 1
76277: NEG
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 1
76285: PUSH
76286: LD_INT 0
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 1
76295: PUSH
76296: LD_INT 1
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 0
76305: PUSH
76306: LD_INT 1
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 1
76315: NEG
76316: PUSH
76317: LD_INT 0
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 1
76326: NEG
76327: PUSH
76328: LD_INT 1
76330: NEG
76331: PUSH
76332: EMPTY
76333: LIST
76334: LIST
76335: PUSH
76336: LD_INT 1
76338: NEG
76339: PUSH
76340: LD_INT 2
76342: NEG
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 0
76350: PUSH
76351: LD_INT 2
76353: NEG
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 1
76361: PUSH
76362: LD_INT 1
76364: NEG
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: PUSH
76370: LD_INT 2
76372: PUSH
76373: LD_INT 0
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: LD_INT 2
76382: PUSH
76383: LD_INT 1
76385: PUSH
76386: EMPTY
76387: LIST
76388: LIST
76389: PUSH
76390: LD_INT 2
76392: PUSH
76393: LD_INT 2
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PUSH
76400: LD_INT 1
76402: PUSH
76403: LD_INT 2
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: PUSH
76410: LD_INT 0
76412: PUSH
76413: LD_INT 2
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 1
76422: NEG
76423: PUSH
76424: LD_INT 1
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 2
76433: NEG
76434: PUSH
76435: LD_INT 0
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 2
76444: NEG
76445: PUSH
76446: LD_INT 1
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 2
76456: NEG
76457: PUSH
76458: LD_INT 2
76460: NEG
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: LIST
76470: LIST
76471: LIST
76472: LIST
76473: LIST
76474: LIST
76475: LIST
76476: LIST
76477: LIST
76478: LIST
76479: LIST
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76487: LD_ADDR_VAR 0 21
76491: PUSH
76492: LD_INT 0
76494: PUSH
76495: LD_INT 0
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 0
76504: PUSH
76505: LD_INT 1
76507: NEG
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_INT 1
76515: PUSH
76516: LD_INT 0
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 1
76525: PUSH
76526: LD_INT 1
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 0
76535: PUSH
76536: LD_INT 1
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 1
76545: NEG
76546: PUSH
76547: LD_INT 0
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 1
76556: NEG
76557: PUSH
76558: LD_INT 1
76560: NEG
76561: PUSH
76562: EMPTY
76563: LIST
76564: LIST
76565: PUSH
76566: LD_INT 1
76568: NEG
76569: PUSH
76570: LD_INT 2
76572: NEG
76573: PUSH
76574: EMPTY
76575: LIST
76576: LIST
76577: PUSH
76578: LD_INT 0
76580: PUSH
76581: LD_INT 2
76583: NEG
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: LD_INT 1
76591: PUSH
76592: LD_INT 1
76594: NEG
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 2
76602: PUSH
76603: LD_INT 0
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 2
76612: PUSH
76613: LD_INT 1
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 2
76622: PUSH
76623: LD_INT 2
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 1
76632: PUSH
76633: LD_INT 2
76635: PUSH
76636: EMPTY
76637: LIST
76638: LIST
76639: PUSH
76640: LD_INT 0
76642: PUSH
76643: LD_INT 2
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 1
76652: NEG
76653: PUSH
76654: LD_INT 1
76656: PUSH
76657: EMPTY
76658: LIST
76659: LIST
76660: PUSH
76661: LD_INT 2
76663: NEG
76664: PUSH
76665: LD_INT 0
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: LD_INT 2
76674: NEG
76675: PUSH
76676: LD_INT 1
76678: NEG
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 2
76686: NEG
76687: PUSH
76688: LD_INT 2
76690: NEG
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: LIST
76700: LIST
76701: LIST
76702: LIST
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76717: LD_ADDR_VAR 0 22
76721: PUSH
76722: LD_INT 0
76724: PUSH
76725: LD_INT 0
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 0
76734: PUSH
76735: LD_INT 1
76737: NEG
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PUSH
76743: LD_INT 1
76745: PUSH
76746: LD_INT 0
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 1
76755: PUSH
76756: LD_INT 1
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 0
76765: PUSH
76766: LD_INT 1
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 1
76775: NEG
76776: PUSH
76777: LD_INT 0
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 1
76786: NEG
76787: PUSH
76788: LD_INT 1
76790: NEG
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 1
76798: NEG
76799: PUSH
76800: LD_INT 2
76802: NEG
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 0
76810: PUSH
76811: LD_INT 2
76813: NEG
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: LD_INT 1
76821: PUSH
76822: LD_INT 1
76824: NEG
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 2
76832: PUSH
76833: LD_INT 0
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 2
76842: PUSH
76843: LD_INT 1
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 2
76852: PUSH
76853: LD_INT 2
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 1
76862: PUSH
76863: LD_INT 2
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 0
76872: PUSH
76873: LD_INT 2
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 1
76882: NEG
76883: PUSH
76884: LD_INT 1
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 2
76893: NEG
76894: PUSH
76895: LD_INT 0
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 2
76904: NEG
76905: PUSH
76906: LD_INT 1
76908: NEG
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 2
76916: NEG
76917: PUSH
76918: LD_INT 2
76920: NEG
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: LIST
76930: LIST
76931: LIST
76932: LIST
76933: LIST
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: LIST
76940: LIST
76941: LIST
76942: LIST
76943: LIST
76944: LIST
76945: LIST
76946: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76947: LD_ADDR_VAR 0 23
76951: PUSH
76952: LD_INT 0
76954: PUSH
76955: LD_INT 0
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 0
76964: PUSH
76965: LD_INT 1
76967: NEG
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: LD_INT 1
76975: PUSH
76976: LD_INT 0
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 1
76985: PUSH
76986: LD_INT 1
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 0
76995: PUSH
76996: LD_INT 1
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 1
77005: NEG
77006: PUSH
77007: LD_INT 0
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 1
77016: NEG
77017: PUSH
77018: LD_INT 1
77020: NEG
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 1
77028: NEG
77029: PUSH
77030: LD_INT 2
77032: NEG
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 0
77040: PUSH
77041: LD_INT 2
77043: NEG
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 1
77051: PUSH
77052: LD_INT 1
77054: NEG
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 2
77062: PUSH
77063: LD_INT 0
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: PUSH
77070: LD_INT 2
77072: PUSH
77073: LD_INT 1
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: PUSH
77080: LD_INT 2
77082: PUSH
77083: LD_INT 2
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: LD_INT 1
77092: PUSH
77093: LD_INT 2
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 0
77102: PUSH
77103: LD_INT 2
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 1
77112: NEG
77113: PUSH
77114: LD_INT 1
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: PUSH
77121: LD_INT 2
77123: NEG
77124: PUSH
77125: LD_INT 0
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PUSH
77132: LD_INT 2
77134: NEG
77135: PUSH
77136: LD_INT 1
77138: NEG
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 2
77146: NEG
77147: PUSH
77148: LD_INT 2
77150: NEG
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: PUSH
77156: LD_INT 2
77158: NEG
77159: PUSH
77160: LD_INT 3
77162: NEG
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 1
77170: NEG
77171: PUSH
77172: LD_INT 3
77174: NEG
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 1
77182: PUSH
77183: LD_INT 2
77185: NEG
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 2
77193: PUSH
77194: LD_INT 1
77196: NEG
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: LIST
77208: LIST
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: LIST
77225: LIST
77226: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
77227: LD_ADDR_VAR 0 24
77231: PUSH
77232: LD_INT 0
77234: PUSH
77235: LD_INT 0
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 0
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: LD_INT 1
77255: PUSH
77256: LD_INT 0
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 1
77265: PUSH
77266: LD_INT 1
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: PUSH
77273: LD_INT 0
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: LD_INT 1
77285: NEG
77286: PUSH
77287: LD_INT 0
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 1
77296: NEG
77297: PUSH
77298: LD_INT 1
77300: NEG
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 1
77308: NEG
77309: PUSH
77310: LD_INT 2
77312: NEG
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 0
77320: PUSH
77321: LD_INT 2
77323: NEG
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 1
77331: PUSH
77332: LD_INT 1
77334: NEG
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: PUSH
77340: LD_INT 2
77342: PUSH
77343: LD_INT 0
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 2
77352: PUSH
77353: LD_INT 1
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: LD_INT 2
77362: PUSH
77363: LD_INT 2
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PUSH
77370: LD_INT 1
77372: PUSH
77373: LD_INT 2
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 0
77382: PUSH
77383: LD_INT 2
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 1
77392: NEG
77393: PUSH
77394: LD_INT 1
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 2
77403: NEG
77404: PUSH
77405: LD_INT 0
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 2
77414: NEG
77415: PUSH
77416: LD_INT 1
77418: NEG
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: LD_INT 2
77426: NEG
77427: PUSH
77428: LD_INT 2
77430: NEG
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 1
77438: PUSH
77439: LD_INT 2
77441: NEG
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 2
77449: PUSH
77450: LD_INT 1
77452: NEG
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PUSH
77458: LD_INT 3
77460: PUSH
77461: LD_INT 1
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: LD_INT 3
77470: PUSH
77471: LD_INT 2
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: LIST
77482: LIST
77483: LIST
77484: LIST
77485: LIST
77486: LIST
77487: LIST
77488: LIST
77489: LIST
77490: LIST
77491: LIST
77492: LIST
77493: LIST
77494: LIST
77495: LIST
77496: LIST
77497: LIST
77498: LIST
77499: LIST
77500: LIST
77501: LIST
77502: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
77503: LD_ADDR_VAR 0 25
77507: PUSH
77508: LD_INT 0
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 0
77520: PUSH
77521: LD_INT 1
77523: NEG
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 1
77531: PUSH
77532: LD_INT 0
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 1
77541: PUSH
77542: LD_INT 1
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 0
77551: PUSH
77552: LD_INT 1
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 1
77561: NEG
77562: PUSH
77563: LD_INT 0
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: LD_INT 1
77572: NEG
77573: PUSH
77574: LD_INT 1
77576: NEG
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 1
77584: NEG
77585: PUSH
77586: LD_INT 2
77588: NEG
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 0
77596: PUSH
77597: LD_INT 2
77599: NEG
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 1
77607: PUSH
77608: LD_INT 1
77610: NEG
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: PUSH
77616: LD_INT 2
77618: PUSH
77619: LD_INT 0
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 2
77628: PUSH
77629: LD_INT 1
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 2
77638: PUSH
77639: LD_INT 2
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 1
77648: PUSH
77649: LD_INT 2
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: LD_INT 0
77658: PUSH
77659: LD_INT 2
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 1
77668: NEG
77669: PUSH
77670: LD_INT 1
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 2
77679: NEG
77680: PUSH
77681: LD_INT 0
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 2
77690: NEG
77691: PUSH
77692: LD_INT 1
77694: NEG
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: PUSH
77700: LD_INT 2
77702: NEG
77703: PUSH
77704: LD_INT 2
77706: NEG
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 3
77714: PUSH
77715: LD_INT 1
77717: PUSH
77718: EMPTY
77719: LIST
77720: LIST
77721: PUSH
77722: LD_INT 3
77724: PUSH
77725: LD_INT 2
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: LD_INT 2
77734: PUSH
77735: LD_INT 3
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: PUSH
77742: LD_INT 1
77744: PUSH
77745: LD_INT 3
77747: PUSH
77748: EMPTY
77749: LIST
77750: LIST
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77777: LD_ADDR_VAR 0 26
77781: PUSH
77782: LD_INT 0
77784: PUSH
77785: LD_INT 0
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 0
77794: PUSH
77795: LD_INT 1
77797: NEG
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: PUSH
77803: LD_INT 1
77805: PUSH
77806: LD_INT 0
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 1
77815: PUSH
77816: LD_INT 1
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 0
77825: PUSH
77826: LD_INT 1
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 1
77835: NEG
77836: PUSH
77837: LD_INT 0
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 1
77846: NEG
77847: PUSH
77848: LD_INT 1
77850: NEG
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 1
77858: NEG
77859: PUSH
77860: LD_INT 2
77862: NEG
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 0
77870: PUSH
77871: LD_INT 2
77873: NEG
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 1
77881: PUSH
77882: LD_INT 1
77884: NEG
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 2
77892: PUSH
77893: LD_INT 0
77895: PUSH
77896: EMPTY
77897: LIST
77898: LIST
77899: PUSH
77900: LD_INT 2
77902: PUSH
77903: LD_INT 1
77905: PUSH
77906: EMPTY
77907: LIST
77908: LIST
77909: PUSH
77910: LD_INT 2
77912: PUSH
77913: LD_INT 2
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 1
77922: PUSH
77923: LD_INT 2
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 0
77932: PUSH
77933: LD_INT 2
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 1
77942: NEG
77943: PUSH
77944: LD_INT 1
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 2
77953: NEG
77954: PUSH
77955: LD_INT 0
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 2
77964: NEG
77965: PUSH
77966: LD_INT 1
77968: NEG
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 2
77976: NEG
77977: PUSH
77978: LD_INT 2
77980: NEG
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: LD_INT 2
77988: PUSH
77989: LD_INT 3
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 1
77998: PUSH
77999: LD_INT 3
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 1
78008: NEG
78009: PUSH
78010: LD_INT 2
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: LD_INT 2
78019: NEG
78020: PUSH
78021: LD_INT 1
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: LIST
78032: LIST
78033: LIST
78034: LIST
78035: LIST
78036: LIST
78037: LIST
78038: LIST
78039: LIST
78040: LIST
78041: LIST
78042: LIST
78043: LIST
78044: LIST
78045: LIST
78046: LIST
78047: LIST
78048: LIST
78049: LIST
78050: LIST
78051: LIST
78052: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78053: LD_ADDR_VAR 0 27
78057: PUSH
78058: LD_INT 0
78060: PUSH
78061: LD_INT 0
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 0
78070: PUSH
78071: LD_INT 1
78073: NEG
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 1
78081: PUSH
78082: LD_INT 0
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 1
78091: PUSH
78092: LD_INT 1
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: LD_INT 0
78101: PUSH
78102: LD_INT 1
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 1
78111: NEG
78112: PUSH
78113: LD_INT 0
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 1
78122: NEG
78123: PUSH
78124: LD_INT 1
78126: NEG
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 1
78134: NEG
78135: PUSH
78136: LD_INT 2
78138: NEG
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 0
78146: PUSH
78147: LD_INT 2
78149: NEG
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 1
78157: PUSH
78158: LD_INT 1
78160: NEG
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 2
78168: PUSH
78169: LD_INT 0
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 2
78178: PUSH
78179: LD_INT 1
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 2
78188: PUSH
78189: LD_INT 2
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: LD_INT 1
78198: PUSH
78199: LD_INT 2
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 0
78208: PUSH
78209: LD_INT 2
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: LD_INT 1
78218: NEG
78219: PUSH
78220: LD_INT 1
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 2
78229: NEG
78230: PUSH
78231: LD_INT 0
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 2
78240: NEG
78241: PUSH
78242: LD_INT 1
78244: NEG
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 2
78252: NEG
78253: PUSH
78254: LD_INT 2
78256: NEG
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 1
78264: NEG
78265: PUSH
78266: LD_INT 2
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 2
78275: NEG
78276: PUSH
78277: LD_INT 1
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 3
78286: NEG
78287: PUSH
78288: LD_INT 1
78290: NEG
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 3
78298: NEG
78299: PUSH
78300: LD_INT 2
78302: NEG
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: LIST
78312: LIST
78313: LIST
78314: LIST
78315: LIST
78316: LIST
78317: LIST
78318: LIST
78319: LIST
78320: LIST
78321: LIST
78322: LIST
78323: LIST
78324: LIST
78325: LIST
78326: LIST
78327: LIST
78328: LIST
78329: LIST
78330: LIST
78331: LIST
78332: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78333: LD_ADDR_VAR 0 28
78337: PUSH
78338: LD_INT 0
78340: PUSH
78341: LD_INT 0
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 0
78350: PUSH
78351: LD_INT 1
78353: NEG
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: PUSH
78359: LD_INT 1
78361: PUSH
78362: LD_INT 0
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 1
78371: PUSH
78372: LD_INT 1
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 0
78381: PUSH
78382: LD_INT 1
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PUSH
78389: LD_INT 1
78391: NEG
78392: PUSH
78393: LD_INT 0
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 1
78402: NEG
78403: PUSH
78404: LD_INT 1
78406: NEG
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 1
78414: NEG
78415: PUSH
78416: LD_INT 2
78418: NEG
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: LD_INT 0
78426: PUSH
78427: LD_INT 2
78429: NEG
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 1
78437: PUSH
78438: LD_INT 1
78440: NEG
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 2
78448: PUSH
78449: LD_INT 0
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 2
78458: PUSH
78459: LD_INT 1
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 2
78468: PUSH
78469: LD_INT 2
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 1
78478: PUSH
78479: LD_INT 2
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: LD_INT 2
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 1
78498: NEG
78499: PUSH
78500: LD_INT 1
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 2
78509: NEG
78510: PUSH
78511: LD_INT 0
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_INT 2
78520: NEG
78521: PUSH
78522: LD_INT 1
78524: NEG
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 2
78532: NEG
78533: PUSH
78534: LD_INT 2
78536: NEG
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: LD_INT 2
78544: NEG
78545: PUSH
78546: LD_INT 3
78548: NEG
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: LD_INT 1
78556: NEG
78557: PUSH
78558: LD_INT 3
78560: NEG
78561: PUSH
78562: EMPTY
78563: LIST
78564: LIST
78565: PUSH
78566: LD_INT 3
78568: NEG
78569: PUSH
78570: LD_INT 1
78572: NEG
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 3
78580: NEG
78581: PUSH
78582: LD_INT 2
78584: NEG
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
78615: LD_ADDR_VAR 0 29
78619: PUSH
78620: LD_INT 0
78622: PUSH
78623: LD_INT 0
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 0
78632: PUSH
78633: LD_INT 1
78635: NEG
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 1
78643: PUSH
78644: LD_INT 0
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 1
78653: PUSH
78654: LD_INT 1
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 0
78663: PUSH
78664: LD_INT 1
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 1
78673: NEG
78674: PUSH
78675: LD_INT 0
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 1
78684: NEG
78685: PUSH
78686: LD_INT 1
78688: NEG
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 1
78696: NEG
78697: PUSH
78698: LD_INT 2
78700: NEG
78701: PUSH
78702: EMPTY
78703: LIST
78704: LIST
78705: PUSH
78706: LD_INT 0
78708: PUSH
78709: LD_INT 2
78711: NEG
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: LD_INT 1
78719: PUSH
78720: LD_INT 1
78722: NEG
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 2
78730: PUSH
78731: LD_INT 0
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 2
78740: PUSH
78741: LD_INT 1
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 1
78750: PUSH
78751: LD_INT 2
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 0
78760: PUSH
78761: LD_INT 2
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 1
78770: NEG
78771: PUSH
78772: LD_INT 1
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: LD_INT 2
78781: NEG
78782: PUSH
78783: LD_INT 1
78785: NEG
78786: PUSH
78787: EMPTY
78788: LIST
78789: LIST
78790: PUSH
78791: LD_INT 2
78793: NEG
78794: PUSH
78795: LD_INT 2
78797: NEG
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 2
78805: NEG
78806: PUSH
78807: LD_INT 3
78809: NEG
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 2
78817: PUSH
78818: LD_INT 1
78820: NEG
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 3
78828: PUSH
78829: LD_INT 1
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 1
78838: PUSH
78839: LD_INT 3
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 1
78848: NEG
78849: PUSH
78850: LD_INT 2
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 3
78859: NEG
78860: PUSH
78861: LD_INT 2
78863: NEG
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78894: LD_ADDR_VAR 0 30
78898: PUSH
78899: LD_INT 0
78901: PUSH
78902: LD_INT 0
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 0
78911: PUSH
78912: LD_INT 1
78914: NEG
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 1
78922: PUSH
78923: LD_INT 0
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 1
78932: PUSH
78933: LD_INT 1
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 0
78942: PUSH
78943: LD_INT 1
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 1
78952: NEG
78953: PUSH
78954: LD_INT 0
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 1
78963: NEG
78964: PUSH
78965: LD_INT 1
78967: NEG
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 1
78975: NEG
78976: PUSH
78977: LD_INT 2
78979: NEG
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PUSH
78985: LD_INT 0
78987: PUSH
78988: LD_INT 2
78990: NEG
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 1
78998: PUSH
78999: LD_INT 1
79001: NEG
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 2
79009: PUSH
79010: LD_INT 0
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 2
79019: PUSH
79020: LD_INT 1
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 2
79029: PUSH
79030: LD_INT 2
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 1
79039: PUSH
79040: LD_INT 2
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: LD_INT 1
79049: NEG
79050: PUSH
79051: LD_INT 1
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 2
79060: NEG
79061: PUSH
79062: LD_INT 0
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 2
79071: NEG
79072: PUSH
79073: LD_INT 1
79075: NEG
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 1
79083: NEG
79084: PUSH
79085: LD_INT 3
79087: NEG
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 1
79095: PUSH
79096: LD_INT 2
79098: NEG
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 3
79106: PUSH
79107: LD_INT 2
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 2
79116: PUSH
79117: LD_INT 3
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 2
79126: NEG
79127: PUSH
79128: LD_INT 1
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 3
79137: NEG
79138: PUSH
79139: LD_INT 1
79141: NEG
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: LIST
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: LIST
79165: LIST
79166: LIST
79167: LIST
79168: LIST
79169: LIST
79170: LIST
79171: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79172: LD_ADDR_VAR 0 31
79176: PUSH
79177: LD_INT 0
79179: PUSH
79180: LD_INT 0
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 0
79189: PUSH
79190: LD_INT 1
79192: NEG
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 1
79200: PUSH
79201: LD_INT 0
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 1
79210: PUSH
79211: LD_INT 1
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 0
79220: PUSH
79221: LD_INT 1
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: PUSH
79228: LD_INT 1
79230: NEG
79231: PUSH
79232: LD_INT 0
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 1
79241: NEG
79242: PUSH
79243: LD_INT 1
79245: NEG
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 1
79253: NEG
79254: PUSH
79255: LD_INT 2
79257: NEG
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 1
79265: PUSH
79266: LD_INT 1
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 2
79276: PUSH
79277: LD_INT 0
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 2
79286: PUSH
79287: LD_INT 1
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 2
79296: PUSH
79297: LD_INT 2
79299: PUSH
79300: EMPTY
79301: LIST
79302: LIST
79303: PUSH
79304: LD_INT 1
79306: PUSH
79307: LD_INT 2
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 0
79316: PUSH
79317: LD_INT 2
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 1
79326: NEG
79327: PUSH
79328: LD_INT 1
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 2
79337: NEG
79338: PUSH
79339: LD_INT 1
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 2
79349: NEG
79350: PUSH
79351: LD_INT 2
79353: NEG
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 2
79361: NEG
79362: PUSH
79363: LD_INT 3
79365: NEG
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PUSH
79371: LD_INT 2
79373: PUSH
79374: LD_INT 1
79376: NEG
79377: PUSH
79378: EMPTY
79379: LIST
79380: LIST
79381: PUSH
79382: LD_INT 3
79384: PUSH
79385: LD_INT 1
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 1
79394: PUSH
79395: LD_INT 3
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 1
79404: NEG
79405: PUSH
79406: LD_INT 2
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PUSH
79413: LD_INT 3
79415: NEG
79416: PUSH
79417: LD_INT 2
79419: NEG
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: EMPTY
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79450: LD_ADDR_VAR 0 32
79454: PUSH
79455: LD_INT 0
79457: PUSH
79458: LD_INT 0
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 0
79467: PUSH
79468: LD_INT 1
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 1
79478: PUSH
79479: LD_INT 0
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 1
79488: PUSH
79489: LD_INT 1
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 0
79498: PUSH
79499: LD_INT 1
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 1
79508: NEG
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 1
79519: NEG
79520: PUSH
79521: LD_INT 1
79523: NEG
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 1
79531: NEG
79532: PUSH
79533: LD_INT 2
79535: NEG
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 0
79543: PUSH
79544: LD_INT 2
79546: NEG
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 1
79554: PUSH
79555: LD_INT 1
79557: NEG
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 2
79565: PUSH
79566: LD_INT 1
79568: PUSH
79569: EMPTY
79570: LIST
79571: LIST
79572: PUSH
79573: LD_INT 2
79575: PUSH
79576: LD_INT 2
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PUSH
79583: LD_INT 1
79585: PUSH
79586: LD_INT 2
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 0
79595: PUSH
79596: LD_INT 2
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: PUSH
79603: LD_INT 1
79605: NEG
79606: PUSH
79607: LD_INT 1
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 2
79616: NEG
79617: PUSH
79618: LD_INT 0
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 2
79627: NEG
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 1
79639: NEG
79640: PUSH
79641: LD_INT 3
79643: NEG
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 1
79651: PUSH
79652: LD_INT 2
79654: NEG
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 3
79662: PUSH
79663: LD_INT 2
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 2
79672: PUSH
79673: LD_INT 3
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 2
79682: NEG
79683: PUSH
79684: LD_INT 1
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 3
79693: NEG
79694: PUSH
79695: LD_INT 1
79697: NEG
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: LIST
79721: LIST
79722: LIST
79723: LIST
79724: LIST
79725: LIST
79726: LIST
79727: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79728: LD_ADDR_VAR 0 33
79732: PUSH
79733: LD_INT 0
79735: PUSH
79736: LD_INT 0
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: PUSH
79743: LD_INT 0
79745: PUSH
79746: LD_INT 1
79748: NEG
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 1
79756: PUSH
79757: LD_INT 0
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: LD_INT 1
79766: PUSH
79767: LD_INT 1
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 0
79776: PUSH
79777: LD_INT 1
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 1
79786: NEG
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 1
79797: NEG
79798: PUSH
79799: LD_INT 1
79801: NEG
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 1
79809: NEG
79810: PUSH
79811: LD_INT 2
79813: NEG
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 1
79821: PUSH
79822: LD_INT 1
79824: NEG
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 2
79832: PUSH
79833: LD_INT 0
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 2
79842: PUSH
79843: LD_INT 1
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 1
79852: PUSH
79853: LD_INT 2
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 0
79862: PUSH
79863: LD_INT 2
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 1
79872: NEG
79873: PUSH
79874: LD_INT 1
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: PUSH
79881: LD_INT 2
79883: NEG
79884: PUSH
79885: LD_INT 0
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: LD_INT 2
79894: NEG
79895: PUSH
79896: LD_INT 1
79898: NEG
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 2
79906: NEG
79907: PUSH
79908: LD_INT 2
79910: NEG
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 2
79918: NEG
79919: PUSH
79920: LD_INT 3
79922: NEG
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 2
79930: PUSH
79931: LD_INT 1
79933: NEG
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 3
79941: PUSH
79942: LD_INT 1
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 1
79951: PUSH
79952: LD_INT 3
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 1
79961: NEG
79962: PUSH
79963: LD_INT 2
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 3
79972: NEG
79973: PUSH
79974: LD_INT 2
79976: NEG
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80007: LD_ADDR_VAR 0 34
80011: PUSH
80012: LD_INT 0
80014: PUSH
80015: LD_INT 0
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: LD_INT 0
80024: PUSH
80025: LD_INT 1
80027: NEG
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 1
80035: PUSH
80036: LD_INT 0
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 1
80045: PUSH
80046: LD_INT 1
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 0
80055: PUSH
80056: LD_INT 1
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 1
80065: NEG
80066: PUSH
80067: LD_INT 0
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 1
80076: NEG
80077: PUSH
80078: LD_INT 1
80080: NEG
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 1
80088: NEG
80089: PUSH
80090: LD_INT 2
80092: NEG
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 0
80100: PUSH
80101: LD_INT 2
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 1
80111: PUSH
80112: LD_INT 1
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 2
80122: PUSH
80123: LD_INT 1
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 2
80132: PUSH
80133: LD_INT 2
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 1
80142: PUSH
80143: LD_INT 2
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 1
80152: NEG
80153: PUSH
80154: LD_INT 1
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 2
80163: NEG
80164: PUSH
80165: LD_INT 0
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 2
80174: NEG
80175: PUSH
80176: LD_INT 1
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 2
80186: NEG
80187: PUSH
80188: LD_INT 2
80190: NEG
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 1
80198: NEG
80199: PUSH
80200: LD_INT 3
80202: NEG
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: LD_INT 2
80213: NEG
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 3
80221: PUSH
80222: LD_INT 2
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 2
80231: PUSH
80232: LD_INT 3
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 2
80241: NEG
80242: PUSH
80243: LD_INT 1
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 3
80252: NEG
80253: PUSH
80254: LD_INT 1
80256: NEG
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: LIST
80266: LIST
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80287: LD_ADDR_VAR 0 35
80291: PUSH
80292: LD_INT 0
80294: PUSH
80295: LD_INT 0
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 0
80304: PUSH
80305: LD_INT 1
80307: NEG
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 1
80315: PUSH
80316: LD_INT 0
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 1
80325: PUSH
80326: LD_INT 1
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 0
80335: PUSH
80336: LD_INT 1
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 1
80345: NEG
80346: PUSH
80347: LD_INT 0
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: PUSH
80354: LD_INT 1
80356: NEG
80357: PUSH
80358: LD_INT 1
80360: NEG
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 2
80368: PUSH
80369: LD_INT 1
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: PUSH
80376: LD_INT 2
80378: NEG
80379: PUSH
80380: LD_INT 1
80382: NEG
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80399: LD_ADDR_VAR 0 36
80403: PUSH
80404: LD_INT 0
80406: PUSH
80407: LD_INT 0
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 0
80416: PUSH
80417: LD_INT 1
80419: NEG
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 1
80427: PUSH
80428: LD_INT 0
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 1
80437: PUSH
80438: LD_INT 1
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 0
80447: PUSH
80448: LD_INT 1
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 1
80457: NEG
80458: PUSH
80459: LD_INT 0
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: PUSH
80466: LD_INT 1
80468: NEG
80469: PUSH
80470: LD_INT 1
80472: NEG
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 1
80480: NEG
80481: PUSH
80482: LD_INT 2
80484: NEG
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 1
80492: PUSH
80493: LD_INT 2
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: LIST
80504: LIST
80505: LIST
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
80511: LD_ADDR_VAR 0 37
80515: PUSH
80516: LD_INT 0
80518: PUSH
80519: LD_INT 0
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 0
80528: PUSH
80529: LD_INT 1
80531: NEG
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 1
80539: PUSH
80540: LD_INT 0
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 1
80549: PUSH
80550: LD_INT 1
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: LD_INT 1
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: PUSH
80567: LD_INT 1
80569: NEG
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 1
80580: NEG
80581: PUSH
80582: LD_INT 1
80584: NEG
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 1
80592: PUSH
80593: LD_INT 1
80595: NEG
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 1
80603: NEG
80604: PUSH
80605: LD_INT 1
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80623: LD_ADDR_VAR 0 38
80627: PUSH
80628: LD_INT 0
80630: PUSH
80631: LD_INT 0
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: LD_INT 1
80643: NEG
80644: PUSH
80645: EMPTY
80646: LIST
80647: LIST
80648: PUSH
80649: LD_INT 1
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 1
80661: PUSH
80662: LD_INT 1
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 0
80671: PUSH
80672: LD_INT 1
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 1
80681: NEG
80682: PUSH
80683: LD_INT 0
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 1
80692: NEG
80693: PUSH
80694: LD_INT 1
80696: NEG
80697: PUSH
80698: EMPTY
80699: LIST
80700: LIST
80701: PUSH
80702: LD_INT 2
80704: PUSH
80705: LD_INT 1
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 2
80714: NEG
80715: PUSH
80716: LD_INT 1
80718: NEG
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80735: LD_ADDR_VAR 0 39
80739: PUSH
80740: LD_INT 0
80742: PUSH
80743: LD_INT 0
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 0
80752: PUSH
80753: LD_INT 1
80755: NEG
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 1
80763: PUSH
80764: LD_INT 0
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 1
80773: PUSH
80774: LD_INT 1
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PUSH
80781: LD_INT 0
80783: PUSH
80784: LD_INT 1
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: LD_INT 1
80793: NEG
80794: PUSH
80795: LD_INT 0
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 1
80804: NEG
80805: PUSH
80806: LD_INT 1
80808: NEG
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: PUSH
80814: LD_INT 1
80816: NEG
80817: PUSH
80818: LD_INT 2
80820: NEG
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 1
80828: PUSH
80829: LD_INT 2
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: LIST
80840: LIST
80841: LIST
80842: LIST
80843: LIST
80844: LIST
80845: LIST
80846: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
80847: LD_ADDR_VAR 0 40
80851: PUSH
80852: LD_INT 0
80854: PUSH
80855: LD_INT 0
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 0
80864: PUSH
80865: LD_INT 1
80867: NEG
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 1
80875: PUSH
80876: LD_INT 0
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 1
80885: PUSH
80886: LD_INT 1
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 0
80895: PUSH
80896: LD_INT 1
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: LD_INT 0
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 1
80916: NEG
80917: PUSH
80918: LD_INT 1
80920: NEG
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 1
80928: PUSH
80929: LD_INT 1
80931: NEG
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 1
80939: NEG
80940: PUSH
80941: LD_INT 1
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80959: LD_ADDR_VAR 0 41
80963: PUSH
80964: LD_INT 0
80966: PUSH
80967: LD_INT 0
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 0
80976: PUSH
80977: LD_INT 1
80979: NEG
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 1
80987: PUSH
80988: LD_INT 0
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: LD_INT 1
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 0
81007: PUSH
81008: LD_INT 1
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 1
81017: NEG
81018: PUSH
81019: LD_INT 0
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 1
81028: NEG
81029: PUSH
81030: LD_INT 1
81032: NEG
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: PUSH
81038: LD_INT 1
81040: NEG
81041: PUSH
81042: LD_INT 2
81044: NEG
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 1
81052: PUSH
81053: LD_INT 1
81055: NEG
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 2
81063: PUSH
81064: LD_INT 0
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 2
81073: PUSH
81074: LD_INT 1
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 2
81083: PUSH
81084: LD_INT 2
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: LD_INT 2
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 1
81103: NEG
81104: PUSH
81105: LD_INT 1
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 2
81114: NEG
81115: PUSH
81116: LD_INT 0
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 2
81125: NEG
81126: PUSH
81127: LD_INT 1
81129: NEG
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 2
81137: NEG
81138: PUSH
81139: LD_INT 2
81141: NEG
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 2
81149: NEG
81150: PUSH
81151: LD_INT 3
81153: NEG
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 2
81161: PUSH
81162: LD_INT 1
81164: NEG
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PUSH
81170: LD_INT 3
81172: PUSH
81173: LD_INT 0
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 3
81182: PUSH
81183: LD_INT 1
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 3
81192: PUSH
81193: LD_INT 2
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 3
81202: PUSH
81203: LD_INT 3
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 2
81212: PUSH
81213: LD_INT 3
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 2
81222: NEG
81223: PUSH
81224: LD_INT 1
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 3
81233: NEG
81234: PUSH
81235: LD_INT 0
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 3
81244: NEG
81245: PUSH
81246: LD_INT 1
81248: NEG
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 3
81256: NEG
81257: PUSH
81258: LD_INT 2
81260: NEG
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 3
81268: NEG
81269: PUSH
81270: LD_INT 3
81272: NEG
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: EMPTY
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: LIST
81289: LIST
81290: LIST
81291: LIST
81292: LIST
81293: LIST
81294: LIST
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: LIST
81303: LIST
81304: LIST
81305: LIST
81306: LIST
81307: LIST
81308: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81309: LD_ADDR_VAR 0 42
81313: PUSH
81314: LD_INT 0
81316: PUSH
81317: LD_INT 0
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 0
81326: PUSH
81327: LD_INT 1
81329: NEG
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 1
81337: PUSH
81338: LD_INT 0
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 1
81347: PUSH
81348: LD_INT 1
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: LD_INT 1
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 1
81367: NEG
81368: PUSH
81369: LD_INT 0
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 1
81378: NEG
81379: PUSH
81380: LD_INT 1
81382: NEG
81383: PUSH
81384: EMPTY
81385: LIST
81386: LIST
81387: PUSH
81388: LD_INT 1
81390: NEG
81391: PUSH
81392: LD_INT 2
81394: NEG
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 0
81402: PUSH
81403: LD_INT 2
81405: NEG
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 1
81413: PUSH
81414: LD_INT 1
81416: NEG
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 2
81424: PUSH
81425: LD_INT 1
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 2
81434: PUSH
81435: LD_INT 2
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 1
81444: PUSH
81445: LD_INT 2
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 0
81454: PUSH
81455: LD_INT 2
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 1
81464: NEG
81465: PUSH
81466: LD_INT 1
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 2
81475: NEG
81476: PUSH
81477: LD_INT 1
81479: NEG
81480: PUSH
81481: EMPTY
81482: LIST
81483: LIST
81484: PUSH
81485: LD_INT 2
81487: NEG
81488: PUSH
81489: LD_INT 2
81491: NEG
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 2
81499: NEG
81500: PUSH
81501: LD_INT 3
81503: NEG
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 1
81511: NEG
81512: PUSH
81513: LD_INT 3
81515: NEG
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 0
81523: PUSH
81524: LD_INT 3
81526: NEG
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 1
81534: PUSH
81535: LD_INT 2
81537: NEG
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PUSH
81543: LD_INT 3
81545: PUSH
81546: LD_INT 2
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 3
81555: PUSH
81556: LD_INT 3
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: PUSH
81563: LD_INT 2
81565: PUSH
81566: LD_INT 3
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 1
81575: PUSH
81576: LD_INT 3
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_INT 0
81585: PUSH
81586: LD_INT 3
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: PUSH
81593: LD_INT 1
81595: NEG
81596: PUSH
81597: LD_INT 2
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: PUSH
81604: LD_INT 3
81606: NEG
81607: PUSH
81608: LD_INT 2
81610: NEG
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 3
81618: NEG
81619: PUSH
81620: LD_INT 3
81622: NEG
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81659: LD_ADDR_VAR 0 43
81663: PUSH
81664: LD_INT 0
81666: PUSH
81667: LD_INT 0
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 0
81676: PUSH
81677: LD_INT 1
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 1
81687: PUSH
81688: LD_INT 0
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 1
81697: PUSH
81698: LD_INT 1
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 0
81707: PUSH
81708: LD_INT 1
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 1
81717: NEG
81718: PUSH
81719: LD_INT 0
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PUSH
81726: LD_INT 1
81728: NEG
81729: PUSH
81730: LD_INT 1
81732: NEG
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 1
81740: NEG
81741: PUSH
81742: LD_INT 2
81744: NEG
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 0
81752: PUSH
81753: LD_INT 2
81755: NEG
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 1
81763: PUSH
81764: LD_INT 1
81766: NEG
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PUSH
81772: LD_INT 2
81774: PUSH
81775: LD_INT 0
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: PUSH
81782: LD_INT 2
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 1
81794: PUSH
81795: LD_INT 2
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 0
81804: PUSH
81805: LD_INT 2
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 1
81814: NEG
81815: PUSH
81816: LD_INT 1
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: LD_INT 2
81825: NEG
81826: PUSH
81827: LD_INT 0
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PUSH
81834: LD_INT 2
81836: NEG
81837: PUSH
81838: LD_INT 1
81840: NEG
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 1
81848: NEG
81849: PUSH
81850: LD_INT 3
81852: NEG
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 0
81860: PUSH
81861: LD_INT 3
81863: NEG
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 1
81871: PUSH
81872: LD_INT 2
81874: NEG
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 2
81882: PUSH
81883: LD_INT 1
81885: NEG
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 3
81893: PUSH
81894: LD_INT 0
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 3
81903: PUSH
81904: LD_INT 1
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 1
81913: PUSH
81914: LD_INT 3
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 0
81923: PUSH
81924: LD_INT 3
81926: PUSH
81927: EMPTY
81928: LIST
81929: LIST
81930: PUSH
81931: LD_INT 1
81933: NEG
81934: PUSH
81935: LD_INT 2
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 2
81944: NEG
81945: PUSH
81946: LD_INT 1
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 3
81955: NEG
81956: PUSH
81957: LD_INT 0
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 3
81966: NEG
81967: PUSH
81968: LD_INT 1
81970: NEG
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82007: LD_ADDR_VAR 0 44
82011: PUSH
82012: LD_INT 0
82014: PUSH
82015: LD_INT 0
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 0
82024: PUSH
82025: LD_INT 1
82027: NEG
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 1
82035: PUSH
82036: LD_INT 0
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 1
82045: PUSH
82046: LD_INT 1
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 0
82055: PUSH
82056: LD_INT 1
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 1
82065: NEG
82066: PUSH
82067: LD_INT 0
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PUSH
82074: LD_INT 1
82076: NEG
82077: PUSH
82078: LD_INT 1
82080: NEG
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 1
82088: NEG
82089: PUSH
82090: LD_INT 2
82092: NEG
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 1
82100: PUSH
82101: LD_INT 1
82103: NEG
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 2
82111: PUSH
82112: LD_INT 0
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 2
82121: PUSH
82122: LD_INT 1
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 2
82131: PUSH
82132: LD_INT 2
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 1
82141: PUSH
82142: LD_INT 2
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 1
82151: NEG
82152: PUSH
82153: LD_INT 1
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 2
82162: NEG
82163: PUSH
82164: LD_INT 0
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 2
82173: NEG
82174: PUSH
82175: LD_INT 1
82177: NEG
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: PUSH
82183: LD_INT 2
82185: NEG
82186: PUSH
82187: LD_INT 2
82189: NEG
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 2
82197: NEG
82198: PUSH
82199: LD_INT 3
82201: NEG
82202: PUSH
82203: EMPTY
82204: LIST
82205: LIST
82206: PUSH
82207: LD_INT 2
82209: PUSH
82210: LD_INT 1
82212: NEG
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 3
82220: PUSH
82221: LD_INT 0
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: LD_INT 3
82230: PUSH
82231: LD_INT 1
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 3
82240: PUSH
82241: LD_INT 2
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 3
82250: PUSH
82251: LD_INT 3
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 2
82260: PUSH
82261: LD_INT 3
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 2
82270: NEG
82271: PUSH
82272: LD_INT 1
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PUSH
82279: LD_INT 3
82281: NEG
82282: PUSH
82283: LD_INT 0
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 3
82292: NEG
82293: PUSH
82294: LD_INT 1
82296: NEG
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 3
82304: NEG
82305: PUSH
82306: LD_INT 2
82308: NEG
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 3
82316: NEG
82317: PUSH
82318: LD_INT 3
82320: NEG
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: LIST
82350: LIST
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: LIST
82356: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82357: LD_ADDR_VAR 0 45
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: LD_INT 0
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 0
82374: PUSH
82375: LD_INT 1
82377: NEG
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 1
82385: PUSH
82386: LD_INT 0
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 1
82395: PUSH
82396: LD_INT 1
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 0
82405: PUSH
82406: LD_INT 1
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 1
82415: NEG
82416: PUSH
82417: LD_INT 0
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 1
82426: NEG
82427: PUSH
82428: LD_INT 1
82430: NEG
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 1
82438: NEG
82439: PUSH
82440: LD_INT 2
82442: NEG
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 0
82450: PUSH
82451: LD_INT 2
82453: NEG
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 1
82461: PUSH
82462: LD_INT 1
82464: NEG
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 2
82472: PUSH
82473: LD_INT 1
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 2
82482: PUSH
82483: LD_INT 2
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: PUSH
82490: LD_INT 1
82492: PUSH
82493: LD_INT 2
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 0
82502: PUSH
82503: LD_INT 2
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 1
82512: NEG
82513: PUSH
82514: LD_INT 1
82516: PUSH
82517: EMPTY
82518: LIST
82519: LIST
82520: PUSH
82521: LD_INT 2
82523: NEG
82524: PUSH
82525: LD_INT 1
82527: NEG
82528: PUSH
82529: EMPTY
82530: LIST
82531: LIST
82532: PUSH
82533: LD_INT 2
82535: NEG
82536: PUSH
82537: LD_INT 2
82539: NEG
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PUSH
82545: LD_INT 2
82547: NEG
82548: PUSH
82549: LD_INT 3
82551: NEG
82552: PUSH
82553: EMPTY
82554: LIST
82555: LIST
82556: PUSH
82557: LD_INT 1
82559: NEG
82560: PUSH
82561: LD_INT 3
82563: NEG
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 0
82571: PUSH
82572: LD_INT 3
82574: NEG
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 1
82582: PUSH
82583: LD_INT 2
82585: NEG
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 3
82593: PUSH
82594: LD_INT 2
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: PUSH
82601: LD_INT 3
82603: PUSH
82604: LD_INT 3
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 2
82613: PUSH
82614: LD_INT 3
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: PUSH
82621: LD_INT 1
82623: PUSH
82624: LD_INT 3
82626: PUSH
82627: EMPTY
82628: LIST
82629: LIST
82630: PUSH
82631: LD_INT 0
82633: PUSH
82634: LD_INT 3
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: PUSH
82641: LD_INT 1
82643: NEG
82644: PUSH
82645: LD_INT 2
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 3
82654: NEG
82655: PUSH
82656: LD_INT 2
82658: NEG
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: PUSH
82664: LD_INT 3
82666: NEG
82667: PUSH
82668: LD_INT 3
82670: NEG
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: LIST
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82707: LD_ADDR_VAR 0 46
82711: PUSH
82712: LD_INT 0
82714: PUSH
82715: LD_INT 0
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 0
82724: PUSH
82725: LD_INT 1
82727: NEG
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 1
82735: PUSH
82736: LD_INT 0
82738: PUSH
82739: EMPTY
82740: LIST
82741: LIST
82742: PUSH
82743: LD_INT 1
82745: PUSH
82746: LD_INT 1
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: LD_INT 0
82755: PUSH
82756: LD_INT 1
82758: PUSH
82759: EMPTY
82760: LIST
82761: LIST
82762: PUSH
82763: LD_INT 1
82765: NEG
82766: PUSH
82767: LD_INT 0
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 1
82776: NEG
82777: PUSH
82778: LD_INT 1
82780: NEG
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 1
82788: NEG
82789: PUSH
82790: LD_INT 2
82792: NEG
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 0
82800: PUSH
82801: LD_INT 2
82803: NEG
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 1
82811: PUSH
82812: LD_INT 1
82814: NEG
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PUSH
82820: LD_INT 2
82822: PUSH
82823: LD_INT 0
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: LD_INT 2
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: LD_INT 1
82842: PUSH
82843: LD_INT 2
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 0
82852: PUSH
82853: LD_INT 2
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 1
82862: NEG
82863: PUSH
82864: LD_INT 1
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 2
82873: NEG
82874: PUSH
82875: LD_INT 0
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 2
82884: NEG
82885: PUSH
82886: LD_INT 1
82888: NEG
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 1
82896: NEG
82897: PUSH
82898: LD_INT 3
82900: NEG
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 0
82908: PUSH
82909: LD_INT 3
82911: NEG
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 1
82919: PUSH
82920: LD_INT 2
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 2
82930: PUSH
82931: LD_INT 1
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 3
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 3
82951: PUSH
82952: LD_INT 1
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: LD_INT 1
82961: PUSH
82962: LD_INT 3
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 0
82971: PUSH
82972: LD_INT 3
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 1
82981: NEG
82982: PUSH
82983: LD_INT 2
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 2
82992: NEG
82993: PUSH
82994: LD_INT 1
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 3
83003: NEG
83004: PUSH
83005: LD_INT 0
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 3
83014: NEG
83015: PUSH
83016: LD_INT 1
83018: NEG
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: LIST
83028: LIST
83029: LIST
83030: LIST
83031: LIST
83032: LIST
83033: LIST
83034: LIST
83035: LIST
83036: LIST
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83055: LD_ADDR_VAR 0 47
83059: PUSH
83060: LD_INT 0
83062: PUSH
83063: LD_INT 0
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 0
83072: PUSH
83073: LD_INT 1
83075: NEG
83076: PUSH
83077: EMPTY
83078: LIST
83079: LIST
83080: PUSH
83081: LD_INT 1
83083: PUSH
83084: LD_INT 0
83086: PUSH
83087: EMPTY
83088: LIST
83089: LIST
83090: PUSH
83091: LD_INT 1
83093: PUSH
83094: LD_INT 1
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: LD_INT 0
83103: PUSH
83104: LD_INT 1
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_INT 1
83113: NEG
83114: PUSH
83115: LD_INT 0
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 1
83124: NEG
83125: PUSH
83126: LD_INT 1
83128: NEG
83129: PUSH
83130: EMPTY
83131: LIST
83132: LIST
83133: PUSH
83134: LD_INT 1
83136: NEG
83137: PUSH
83138: LD_INT 2
83140: NEG
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 0
83148: PUSH
83149: LD_INT 2
83151: NEG
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 1
83159: PUSH
83160: LD_INT 1
83162: NEG
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 2
83170: NEG
83171: PUSH
83172: LD_INT 1
83174: NEG
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 2
83182: NEG
83183: PUSH
83184: LD_INT 2
83186: NEG
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
83206: LD_ADDR_VAR 0 48
83210: PUSH
83211: LD_INT 0
83213: PUSH
83214: LD_INT 0
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 0
83223: PUSH
83224: LD_INT 1
83226: NEG
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 1
83234: PUSH
83235: LD_INT 0
83237: PUSH
83238: EMPTY
83239: LIST
83240: LIST
83241: PUSH
83242: LD_INT 1
83244: PUSH
83245: LD_INT 1
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: LD_INT 0
83254: PUSH
83255: LD_INT 1
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PUSH
83262: LD_INT 1
83264: NEG
83265: PUSH
83266: LD_INT 0
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 1
83275: NEG
83276: PUSH
83277: LD_INT 1
83279: NEG
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 1
83287: NEG
83288: PUSH
83289: LD_INT 2
83291: NEG
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 0
83299: PUSH
83300: LD_INT 2
83302: NEG
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 1
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 2
83321: PUSH
83322: LD_INT 0
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 2
83331: PUSH
83332: LD_INT 1
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: LIST
83348: LIST
83349: LIST
83350: LIST
83351: LIST
83352: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
83353: LD_ADDR_VAR 0 49
83357: PUSH
83358: LD_INT 0
83360: PUSH
83361: LD_INT 0
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: LD_INT 0
83370: PUSH
83371: LD_INT 1
83373: NEG
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 1
83381: PUSH
83382: LD_INT 0
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: LD_INT 1
83391: PUSH
83392: LD_INT 1
83394: PUSH
83395: EMPTY
83396: LIST
83397: LIST
83398: PUSH
83399: LD_INT 0
83401: PUSH
83402: LD_INT 1
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: LD_INT 1
83411: NEG
83412: PUSH
83413: LD_INT 0
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 1
83422: NEG
83423: PUSH
83424: LD_INT 1
83426: NEG
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: LD_INT 1
83437: NEG
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 2
83445: PUSH
83446: LD_INT 0
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 2
83455: PUSH
83456: LD_INT 1
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 2
83465: PUSH
83466: LD_INT 2
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 1
83475: PUSH
83476: LD_INT 2
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: LIST
83487: LIST
83488: LIST
83489: LIST
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
83497: LD_ADDR_VAR 0 50
83501: PUSH
83502: LD_INT 0
83504: PUSH
83505: LD_INT 0
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 0
83514: PUSH
83515: LD_INT 1
83517: NEG
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 1
83525: PUSH
83526: LD_INT 0
83528: PUSH
83529: EMPTY
83530: LIST
83531: LIST
83532: PUSH
83533: LD_INT 1
83535: PUSH
83536: LD_INT 1
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 0
83545: PUSH
83546: LD_INT 1
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 1
83555: NEG
83556: PUSH
83557: LD_INT 0
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: LD_INT 1
83566: NEG
83567: PUSH
83568: LD_INT 1
83570: NEG
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: LD_INT 2
83578: PUSH
83579: LD_INT 1
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_INT 2
83588: PUSH
83589: LD_INT 2
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PUSH
83596: LD_INT 1
83598: PUSH
83599: LD_INT 2
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PUSH
83606: LD_INT 0
83608: PUSH
83609: LD_INT 2
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PUSH
83616: LD_INT 1
83618: NEG
83619: PUSH
83620: LD_INT 1
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
83641: LD_ADDR_VAR 0 51
83645: PUSH
83646: LD_INT 0
83648: PUSH
83649: LD_INT 0
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: PUSH
83656: LD_INT 0
83658: PUSH
83659: LD_INT 1
83661: NEG
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PUSH
83667: LD_INT 1
83669: PUSH
83670: LD_INT 0
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 1
83679: PUSH
83680: LD_INT 1
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 0
83689: PUSH
83690: LD_INT 1
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 1
83699: NEG
83700: PUSH
83701: LD_INT 0
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 1
83710: NEG
83711: PUSH
83712: LD_INT 1
83714: NEG
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 1
83722: PUSH
83723: LD_INT 2
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 0
83732: PUSH
83733: LD_INT 2
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PUSH
83740: LD_INT 1
83742: NEG
83743: PUSH
83744: LD_INT 1
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 2
83753: NEG
83754: PUSH
83755: LD_INT 0
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 2
83764: NEG
83765: PUSH
83766: LD_INT 1
83768: NEG
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83788: LD_ADDR_VAR 0 52
83792: PUSH
83793: LD_INT 0
83795: PUSH
83796: LD_INT 0
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 0
83805: PUSH
83806: LD_INT 1
83808: NEG
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 1
83826: PUSH
83827: LD_INT 1
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 0
83836: PUSH
83837: LD_INT 1
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: PUSH
83844: LD_INT 1
83846: NEG
83847: PUSH
83848: LD_INT 0
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 1
83857: NEG
83858: PUSH
83859: LD_INT 1
83861: NEG
83862: PUSH
83863: EMPTY
83864: LIST
83865: LIST
83866: PUSH
83867: LD_INT 1
83869: NEG
83870: PUSH
83871: LD_INT 2
83873: NEG
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: NEG
83882: PUSH
83883: LD_INT 1
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 2
83892: NEG
83893: PUSH
83894: LD_INT 0
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 2
83903: NEG
83904: PUSH
83905: LD_INT 1
83907: NEG
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: LD_INT 2
83915: NEG
83916: PUSH
83917: LD_INT 2
83919: NEG
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83939: LD_ADDR_VAR 0 53
83943: PUSH
83944: LD_INT 0
83946: PUSH
83947: LD_INT 0
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 0
83956: PUSH
83957: LD_INT 1
83959: NEG
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 0
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: PUSH
83978: LD_INT 1
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 0
83987: PUSH
83988: LD_INT 1
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 1
83997: NEG
83998: PUSH
83999: LD_INT 0
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: NEG
84009: PUSH
84010: LD_INT 1
84012: NEG
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 1
84020: NEG
84021: PUSH
84022: LD_INT 2
84024: NEG
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 0
84032: PUSH
84033: LD_INT 2
84035: NEG
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 1
84043: PUSH
84044: LD_INT 1
84046: NEG
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 2
84054: PUSH
84055: LD_INT 0
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: PUSH
84062: LD_INT 2
84064: PUSH
84065: LD_INT 1
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: PUSH
84072: LD_INT 2
84074: PUSH
84075: LD_INT 2
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 1
84084: PUSH
84085: LD_INT 2
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: LD_INT 0
84094: PUSH
84095: LD_INT 2
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 1
84104: NEG
84105: PUSH
84106: LD_INT 1
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: LD_INT 2
84115: NEG
84116: PUSH
84117: LD_INT 0
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: LD_INT 2
84126: NEG
84127: PUSH
84128: LD_INT 1
84130: NEG
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: PUSH
84136: LD_INT 2
84138: NEG
84139: PUSH
84140: LD_INT 2
84142: NEG
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84169: LD_ADDR_VAR 0 54
84173: PUSH
84174: LD_INT 0
84176: PUSH
84177: LD_INT 0
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: LD_INT 0
84186: PUSH
84187: LD_INT 1
84189: NEG
84190: PUSH
84191: EMPTY
84192: LIST
84193: LIST
84194: PUSH
84195: LD_INT 1
84197: PUSH
84198: LD_INT 0
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 1
84207: PUSH
84208: LD_INT 1
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 0
84217: PUSH
84218: LD_INT 1
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 1
84227: NEG
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 1
84238: NEG
84239: PUSH
84240: LD_INT 1
84242: NEG
84243: PUSH
84244: EMPTY
84245: LIST
84246: LIST
84247: PUSH
84248: LD_INT 1
84250: NEG
84251: PUSH
84252: LD_INT 2
84254: NEG
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 0
84262: PUSH
84263: LD_INT 2
84265: NEG
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 1
84273: PUSH
84274: LD_INT 1
84276: NEG
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 2
84284: PUSH
84285: LD_INT 0
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 2
84294: PUSH
84295: LD_INT 1
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: PUSH
84302: LD_INT 2
84304: PUSH
84305: LD_INT 2
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 1
84314: PUSH
84315: LD_INT 2
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: LD_INT 0
84324: PUSH
84325: LD_INT 2
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 1
84334: NEG
84335: PUSH
84336: LD_INT 1
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: PUSH
84343: LD_INT 2
84345: NEG
84346: PUSH
84347: LD_INT 0
84349: PUSH
84350: EMPTY
84351: LIST
84352: LIST
84353: PUSH
84354: LD_INT 2
84356: NEG
84357: PUSH
84358: LD_INT 1
84360: NEG
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: LD_INT 2
84368: NEG
84369: PUSH
84370: LD_INT 2
84372: NEG
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84399: LD_ADDR_VAR 0 55
84403: PUSH
84404: LD_INT 0
84406: PUSH
84407: LD_INT 0
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 0
84416: PUSH
84417: LD_INT 1
84419: NEG
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 1
84427: PUSH
84428: LD_INT 0
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: PUSH
84435: LD_INT 1
84437: PUSH
84438: LD_INT 1
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 0
84447: PUSH
84448: LD_INT 1
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 1
84457: NEG
84458: PUSH
84459: LD_INT 0
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 1
84468: NEG
84469: PUSH
84470: LD_INT 1
84472: NEG
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 1
84480: NEG
84481: PUSH
84482: LD_INT 2
84484: NEG
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 0
84492: PUSH
84493: LD_INT 2
84495: NEG
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 1
84503: PUSH
84504: LD_INT 1
84506: NEG
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: LD_INT 2
84514: PUSH
84515: LD_INT 0
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 2
84524: PUSH
84525: LD_INT 1
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: PUSH
84532: LD_INT 2
84534: PUSH
84535: LD_INT 2
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 1
84544: PUSH
84545: LD_INT 2
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: PUSH
84552: LD_INT 0
84554: PUSH
84555: LD_INT 2
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 1
84564: NEG
84565: PUSH
84566: LD_INT 1
84568: PUSH
84569: EMPTY
84570: LIST
84571: LIST
84572: PUSH
84573: LD_INT 2
84575: NEG
84576: PUSH
84577: LD_INT 0
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: PUSH
84584: LD_INT 2
84586: NEG
84587: PUSH
84588: LD_INT 1
84590: NEG
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 2
84598: NEG
84599: PUSH
84600: LD_INT 2
84602: NEG
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: LIST
84626: LIST
84627: LIST
84628: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84629: LD_ADDR_VAR 0 56
84633: PUSH
84634: LD_INT 0
84636: PUSH
84637: LD_INT 0
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: PUSH
84644: LD_INT 0
84646: PUSH
84647: LD_INT 1
84649: NEG
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: PUSH
84655: LD_INT 1
84657: PUSH
84658: LD_INT 0
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 1
84667: PUSH
84668: LD_INT 1
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 0
84677: PUSH
84678: LD_INT 1
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: PUSH
84685: LD_INT 1
84687: NEG
84688: PUSH
84689: LD_INT 0
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: LD_INT 1
84702: NEG
84703: PUSH
84704: EMPTY
84705: LIST
84706: LIST
84707: PUSH
84708: LD_INT 1
84710: NEG
84711: PUSH
84712: LD_INT 2
84714: NEG
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 0
84722: PUSH
84723: LD_INT 2
84725: NEG
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 1
84733: PUSH
84734: LD_INT 1
84736: NEG
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: PUSH
84742: LD_INT 2
84744: PUSH
84745: LD_INT 0
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 2
84754: PUSH
84755: LD_INT 1
84757: PUSH
84758: EMPTY
84759: LIST
84760: LIST
84761: PUSH
84762: LD_INT 2
84764: PUSH
84765: LD_INT 2
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 1
84774: PUSH
84775: LD_INT 2
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 0
84784: PUSH
84785: LD_INT 2
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 1
84794: NEG
84795: PUSH
84796: LD_INT 1
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 2
84805: NEG
84806: PUSH
84807: LD_INT 0
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 2
84816: NEG
84817: PUSH
84818: LD_INT 1
84820: NEG
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 2
84828: NEG
84829: PUSH
84830: LD_INT 2
84832: NEG
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84859: LD_ADDR_VAR 0 57
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 0
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 0
84876: PUSH
84877: LD_INT 1
84879: NEG
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: LD_INT 0
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 0
84907: PUSH
84908: LD_INT 1
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 1
84917: NEG
84918: PUSH
84919: LD_INT 0
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: LD_INT 1
84932: NEG
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 1
84940: NEG
84941: PUSH
84942: LD_INT 2
84944: NEG
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: LD_INT 2
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 1
84963: PUSH
84964: LD_INT 1
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: LD_INT 0
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 2
84984: PUSH
84985: LD_INT 1
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 2
84994: PUSH
84995: LD_INT 2
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: LD_INT 1
85004: PUSH
85005: LD_INT 2
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 0
85014: PUSH
85015: LD_INT 2
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 1
85024: NEG
85025: PUSH
85026: LD_INT 1
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 2
85035: NEG
85036: PUSH
85037: LD_INT 0
85039: PUSH
85040: EMPTY
85041: LIST
85042: LIST
85043: PUSH
85044: LD_INT 2
85046: NEG
85047: PUSH
85048: LD_INT 1
85050: NEG
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PUSH
85056: LD_INT 2
85058: NEG
85059: PUSH
85060: LD_INT 2
85062: NEG
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85089: LD_ADDR_VAR 0 58
85093: PUSH
85094: LD_INT 0
85096: PUSH
85097: LD_INT 0
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: PUSH
85104: LD_INT 0
85106: PUSH
85107: LD_INT 1
85109: NEG
85110: PUSH
85111: EMPTY
85112: LIST
85113: LIST
85114: PUSH
85115: LD_INT 1
85117: PUSH
85118: LD_INT 0
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_INT 1
85127: PUSH
85128: LD_INT 1
85130: PUSH
85131: EMPTY
85132: LIST
85133: LIST
85134: PUSH
85135: LD_INT 0
85137: PUSH
85138: LD_INT 1
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 1
85147: NEG
85148: PUSH
85149: LD_INT 0
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 1
85158: NEG
85159: PUSH
85160: LD_INT 1
85162: NEG
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 1
85170: NEG
85171: PUSH
85172: LD_INT 2
85174: NEG
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 0
85182: PUSH
85183: LD_INT 2
85185: NEG
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 1
85193: PUSH
85194: LD_INT 1
85196: NEG
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: PUSH
85202: LD_INT 2
85204: PUSH
85205: LD_INT 0
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: PUSH
85212: LD_INT 2
85214: PUSH
85215: LD_INT 1
85217: PUSH
85218: EMPTY
85219: LIST
85220: LIST
85221: PUSH
85222: LD_INT 2
85224: PUSH
85225: LD_INT 2
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 1
85234: PUSH
85235: LD_INT 2
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 0
85244: PUSH
85245: LD_INT 2
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 1
85254: NEG
85255: PUSH
85256: LD_INT 1
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 2
85265: NEG
85266: PUSH
85267: LD_INT 0
85269: PUSH
85270: EMPTY
85271: LIST
85272: LIST
85273: PUSH
85274: LD_INT 2
85276: NEG
85277: PUSH
85278: LD_INT 1
85280: NEG
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 2
85288: NEG
85289: PUSH
85290: LD_INT 2
85292: NEG
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: EMPTY
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85319: LD_ADDR_VAR 0 59
85323: PUSH
85324: LD_INT 0
85326: PUSH
85327: LD_INT 0
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 0
85336: PUSH
85337: LD_INT 1
85339: NEG
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: LD_INT 1
85347: PUSH
85348: LD_INT 0
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_INT 1
85357: PUSH
85358: LD_INT 1
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_INT 0
85367: PUSH
85368: LD_INT 1
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 1
85377: NEG
85378: PUSH
85379: LD_INT 0
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 1
85388: NEG
85389: PUSH
85390: LD_INT 1
85392: NEG
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: EMPTY
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85407: LD_ADDR_VAR 0 60
85411: PUSH
85412: LD_INT 0
85414: PUSH
85415: LD_INT 0
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 0
85424: PUSH
85425: LD_INT 1
85427: NEG
85428: PUSH
85429: EMPTY
85430: LIST
85431: LIST
85432: PUSH
85433: LD_INT 1
85435: PUSH
85436: LD_INT 0
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 1
85445: PUSH
85446: LD_INT 1
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 0
85455: PUSH
85456: LD_INT 1
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 1
85465: NEG
85466: PUSH
85467: LD_INT 0
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 1
85476: NEG
85477: PUSH
85478: LD_INT 1
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85495: LD_ADDR_VAR 0 61
85499: PUSH
85500: LD_INT 0
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 0
85512: PUSH
85513: LD_INT 1
85515: NEG
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: LD_INT 0
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 1
85533: PUSH
85534: LD_INT 1
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 0
85543: PUSH
85544: LD_INT 1
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 1
85553: NEG
85554: PUSH
85555: LD_INT 0
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 1
85564: NEG
85565: PUSH
85566: LD_INT 1
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85583: LD_ADDR_VAR 0 62
85587: PUSH
85588: LD_INT 0
85590: PUSH
85591: LD_INT 0
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: LD_INT 0
85600: PUSH
85601: LD_INT 1
85603: NEG
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 1
85611: PUSH
85612: LD_INT 0
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 1
85621: PUSH
85622: LD_INT 1
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 0
85631: PUSH
85632: LD_INT 1
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 1
85641: NEG
85642: PUSH
85643: LD_INT 0
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 1
85652: NEG
85653: PUSH
85654: LD_INT 1
85656: NEG
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: EMPTY
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85671: LD_ADDR_VAR 0 63
85675: PUSH
85676: LD_INT 0
85678: PUSH
85679: LD_INT 0
85681: PUSH
85682: EMPTY
85683: LIST
85684: LIST
85685: PUSH
85686: LD_INT 0
85688: PUSH
85689: LD_INT 1
85691: NEG
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: PUSH
85697: LD_INT 1
85699: PUSH
85700: LD_INT 0
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 1
85709: PUSH
85710: LD_INT 1
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: LD_INT 1
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 1
85729: NEG
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 1
85740: NEG
85741: PUSH
85742: LD_INT 1
85744: NEG
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85759: LD_ADDR_VAR 0 64
85763: PUSH
85764: LD_INT 0
85766: PUSH
85767: LD_INT 0
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 0
85776: PUSH
85777: LD_INT 1
85779: NEG
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: PUSH
85785: LD_INT 1
85787: PUSH
85788: LD_INT 0
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PUSH
85795: LD_INT 1
85797: PUSH
85798: LD_INT 1
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 0
85807: PUSH
85808: LD_INT 1
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 1
85817: NEG
85818: PUSH
85819: LD_INT 0
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: PUSH
85826: LD_INT 1
85828: NEG
85829: PUSH
85830: LD_INT 1
85832: NEG
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: ST_TO_ADDR
// end ; 1 :
85847: GO 91744
85849: LD_INT 1
85851: DOUBLE
85852: EQUAL
85853: IFTRUE 85857
85855: GO 88480
85857: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85858: LD_ADDR_VAR 0 11
85862: PUSH
85863: LD_INT 1
85865: NEG
85866: PUSH
85867: LD_INT 3
85869: NEG
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 0
85877: PUSH
85878: LD_INT 3
85880: NEG
85881: PUSH
85882: EMPTY
85883: LIST
85884: LIST
85885: PUSH
85886: LD_INT 1
85888: PUSH
85889: LD_INT 2
85891: NEG
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: LIST
85901: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85902: LD_ADDR_VAR 0 12
85906: PUSH
85907: LD_INT 2
85909: PUSH
85910: LD_INT 1
85912: NEG
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 3
85920: PUSH
85921: LD_INT 0
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 3
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: LIST
85942: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85943: LD_ADDR_VAR 0 13
85947: PUSH
85948: LD_INT 3
85950: PUSH
85951: LD_INT 2
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 3
85960: PUSH
85961: LD_INT 3
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: PUSH
85968: LD_INT 2
85970: PUSH
85971: LD_INT 3
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: LIST
85982: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85983: LD_ADDR_VAR 0 14
85987: PUSH
85988: LD_INT 1
85990: PUSH
85991: LD_INT 3
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 0
86000: PUSH
86001: LD_INT 3
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: LD_INT 1
86010: NEG
86011: PUSH
86012: LD_INT 2
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: LIST
86023: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86024: LD_ADDR_VAR 0 15
86028: PUSH
86029: LD_INT 2
86031: NEG
86032: PUSH
86033: LD_INT 1
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 3
86042: NEG
86043: PUSH
86044: LD_INT 0
86046: PUSH
86047: EMPTY
86048: LIST
86049: LIST
86050: PUSH
86051: LD_INT 3
86053: NEG
86054: PUSH
86055: LD_INT 1
86057: NEG
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: EMPTY
86064: LIST
86065: LIST
86066: LIST
86067: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86068: LD_ADDR_VAR 0 16
86072: PUSH
86073: LD_INT 2
86075: NEG
86076: PUSH
86077: LD_INT 3
86079: NEG
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 3
86087: NEG
86088: PUSH
86089: LD_INT 2
86091: NEG
86092: PUSH
86093: EMPTY
86094: LIST
86095: LIST
86096: PUSH
86097: LD_INT 3
86099: NEG
86100: PUSH
86101: LD_INT 3
86103: NEG
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: LIST
86113: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86114: LD_ADDR_VAR 0 17
86118: PUSH
86119: LD_INT 1
86121: NEG
86122: PUSH
86123: LD_INT 3
86125: NEG
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 0
86133: PUSH
86134: LD_INT 3
86136: NEG
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 1
86144: PUSH
86145: LD_INT 2
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: LIST
86157: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86158: LD_ADDR_VAR 0 18
86162: PUSH
86163: LD_INT 2
86165: PUSH
86166: LD_INT 1
86168: NEG
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 3
86176: PUSH
86177: LD_INT 0
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 3
86186: PUSH
86187: LD_INT 1
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: LIST
86198: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86199: LD_ADDR_VAR 0 19
86203: PUSH
86204: LD_INT 3
86206: PUSH
86207: LD_INT 2
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 3
86216: PUSH
86217: LD_INT 3
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 2
86226: PUSH
86227: LD_INT 3
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: LIST
86238: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
86239: LD_ADDR_VAR 0 20
86243: PUSH
86244: LD_INT 1
86246: PUSH
86247: LD_INT 3
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: LD_INT 0
86256: PUSH
86257: LD_INT 3
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: PUSH
86264: LD_INT 1
86266: NEG
86267: PUSH
86268: LD_INT 2
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: LIST
86279: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86280: LD_ADDR_VAR 0 21
86284: PUSH
86285: LD_INT 2
86287: NEG
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 3
86298: NEG
86299: PUSH
86300: LD_INT 0
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: LD_INT 3
86309: NEG
86310: PUSH
86311: LD_INT 1
86313: NEG
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: LIST
86323: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86324: LD_ADDR_VAR 0 22
86328: PUSH
86329: LD_INT 2
86331: NEG
86332: PUSH
86333: LD_INT 3
86335: NEG
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PUSH
86341: LD_INT 3
86343: NEG
86344: PUSH
86345: LD_INT 2
86347: NEG
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PUSH
86353: LD_INT 3
86355: NEG
86356: PUSH
86357: LD_INT 3
86359: NEG
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: LIST
86369: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
86370: LD_ADDR_VAR 0 23
86374: PUSH
86375: LD_INT 0
86377: PUSH
86378: LD_INT 3
86380: NEG
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 1
86388: NEG
86389: PUSH
86390: LD_INT 4
86392: NEG
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 1
86400: PUSH
86401: LD_INT 3
86403: NEG
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: EMPTY
86410: LIST
86411: LIST
86412: LIST
86413: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
86414: LD_ADDR_VAR 0 24
86418: PUSH
86419: LD_INT 3
86421: PUSH
86422: LD_INT 0
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 3
86431: PUSH
86432: LD_INT 1
86434: NEG
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: LD_INT 4
86442: PUSH
86443: LD_INT 1
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: LIST
86454: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
86455: LD_ADDR_VAR 0 25
86459: PUSH
86460: LD_INT 3
86462: PUSH
86463: LD_INT 3
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: PUSH
86470: LD_INT 4
86472: PUSH
86473: LD_INT 3
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 3
86482: PUSH
86483: LD_INT 4
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: EMPTY
86491: LIST
86492: LIST
86493: LIST
86494: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
86495: LD_ADDR_VAR 0 26
86499: PUSH
86500: LD_INT 0
86502: PUSH
86503: LD_INT 3
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: PUSH
86513: LD_INT 4
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: LD_INT 3
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: EMPTY
86532: LIST
86533: LIST
86534: LIST
86535: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
86536: LD_ADDR_VAR 0 27
86540: PUSH
86541: LD_INT 3
86543: NEG
86544: PUSH
86545: LD_INT 0
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: PUSH
86552: LD_INT 3
86554: NEG
86555: PUSH
86556: LD_INT 1
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: LD_INT 4
86565: NEG
86566: PUSH
86567: LD_INT 1
86569: NEG
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: LIST
86579: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
86580: LD_ADDR_VAR 0 28
86584: PUSH
86585: LD_INT 3
86587: NEG
86588: PUSH
86589: LD_INT 3
86591: NEG
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 3
86599: NEG
86600: PUSH
86601: LD_INT 4
86603: NEG
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: LD_INT 4
86611: NEG
86612: PUSH
86613: LD_INT 3
86615: NEG
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: LIST
86625: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
86626: LD_ADDR_VAR 0 29
86630: PUSH
86631: LD_INT 1
86633: NEG
86634: PUSH
86635: LD_INT 3
86637: NEG
86638: PUSH
86639: EMPTY
86640: LIST
86641: LIST
86642: PUSH
86643: LD_INT 0
86645: PUSH
86646: LD_INT 3
86648: NEG
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: LD_INT 1
86656: PUSH
86657: LD_INT 2
86659: NEG
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: PUSH
86665: LD_INT 1
86667: NEG
86668: PUSH
86669: LD_INT 4
86671: NEG
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 0
86679: PUSH
86680: LD_INT 4
86682: NEG
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: PUSH
86688: LD_INT 1
86690: PUSH
86691: LD_INT 3
86693: NEG
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 1
86701: NEG
86702: PUSH
86703: LD_INT 5
86705: NEG
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: PUSH
86711: LD_INT 0
86713: PUSH
86714: LD_INT 5
86716: NEG
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: LD_INT 1
86724: PUSH
86725: LD_INT 4
86727: NEG
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 1
86735: NEG
86736: PUSH
86737: LD_INT 6
86739: NEG
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 0
86747: PUSH
86748: LD_INT 6
86750: NEG
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: PUSH
86759: LD_INT 5
86761: NEG
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
86781: LD_ADDR_VAR 0 30
86785: PUSH
86786: LD_INT 2
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 3
86799: PUSH
86800: LD_INT 0
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 3
86809: PUSH
86810: LD_INT 1
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 3
86819: PUSH
86820: LD_INT 1
86822: NEG
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 4
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 4
86840: PUSH
86841: LD_INT 1
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 4
86850: PUSH
86851: LD_INT 1
86853: NEG
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 5
86861: PUSH
86862: LD_INT 0
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 5
86871: PUSH
86872: LD_INT 1
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 5
86881: PUSH
86882: LD_INT 1
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 6
86892: PUSH
86893: LD_INT 0
86895: PUSH
86896: EMPTY
86897: LIST
86898: LIST
86899: PUSH
86900: LD_INT 6
86902: PUSH
86903: LD_INT 1
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
86924: LD_ADDR_VAR 0 31
86928: PUSH
86929: LD_INT 3
86931: PUSH
86932: LD_INT 2
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 3
86941: PUSH
86942: LD_INT 3
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 2
86951: PUSH
86952: LD_INT 3
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 4
86961: PUSH
86962: LD_INT 3
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 4
86971: PUSH
86972: LD_INT 4
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 3
86981: PUSH
86982: LD_INT 4
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 5
86991: PUSH
86992: LD_INT 4
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 5
87001: PUSH
87002: LD_INT 5
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 4
87011: PUSH
87012: LD_INT 5
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 6
87021: PUSH
87022: LD_INT 5
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 6
87031: PUSH
87032: LD_INT 6
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 5
87041: PUSH
87042: LD_INT 6
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
87063: LD_ADDR_VAR 0 32
87067: PUSH
87068: LD_INT 1
87070: PUSH
87071: LD_INT 3
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 0
87080: PUSH
87081: LD_INT 3
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 1
87090: NEG
87091: PUSH
87092: LD_INT 2
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 1
87101: PUSH
87102: LD_INT 4
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 0
87111: PUSH
87112: LD_INT 4
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: LD_INT 1
87121: NEG
87122: PUSH
87123: LD_INT 3
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 1
87132: PUSH
87133: LD_INT 5
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 0
87142: PUSH
87143: LD_INT 5
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 1
87152: NEG
87153: PUSH
87154: LD_INT 4
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 1
87163: PUSH
87164: LD_INT 6
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: LD_INT 0
87173: PUSH
87174: LD_INT 6
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: LD_INT 5
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
87206: LD_ADDR_VAR 0 33
87210: PUSH
87211: LD_INT 2
87213: NEG
87214: PUSH
87215: LD_INT 1
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 3
87224: NEG
87225: PUSH
87226: LD_INT 0
87228: PUSH
87229: EMPTY
87230: LIST
87231: LIST
87232: PUSH
87233: LD_INT 3
87235: NEG
87236: PUSH
87237: LD_INT 1
87239: NEG
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 3
87247: NEG
87248: PUSH
87249: LD_INT 1
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PUSH
87256: LD_INT 4
87258: NEG
87259: PUSH
87260: LD_INT 0
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: LD_INT 4
87269: NEG
87270: PUSH
87271: LD_INT 1
87273: NEG
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 4
87281: NEG
87282: PUSH
87283: LD_INT 1
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 5
87292: NEG
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 5
87303: NEG
87304: PUSH
87305: LD_INT 1
87307: NEG
87308: PUSH
87309: EMPTY
87310: LIST
87311: LIST
87312: PUSH
87313: LD_INT 5
87315: NEG
87316: PUSH
87317: LD_INT 1
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 6
87326: NEG
87327: PUSH
87328: LD_INT 0
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: PUSH
87335: LD_INT 6
87337: NEG
87338: PUSH
87339: LD_INT 1
87341: NEG
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
87361: LD_ADDR_VAR 0 34
87365: PUSH
87366: LD_INT 2
87368: NEG
87369: PUSH
87370: LD_INT 3
87372: NEG
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 3
87380: NEG
87381: PUSH
87382: LD_INT 2
87384: NEG
87385: PUSH
87386: EMPTY
87387: LIST
87388: LIST
87389: PUSH
87390: LD_INT 3
87392: NEG
87393: PUSH
87394: LD_INT 3
87396: NEG
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: LD_INT 3
87404: NEG
87405: PUSH
87406: LD_INT 4
87408: NEG
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: PUSH
87414: LD_INT 4
87416: NEG
87417: PUSH
87418: LD_INT 3
87420: NEG
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 4
87428: NEG
87429: PUSH
87430: LD_INT 4
87432: NEG
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 4
87440: NEG
87441: PUSH
87442: LD_INT 5
87444: NEG
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 5
87452: NEG
87453: PUSH
87454: LD_INT 4
87456: NEG
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 5
87464: NEG
87465: PUSH
87466: LD_INT 5
87468: NEG
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: PUSH
87474: LD_INT 5
87476: NEG
87477: PUSH
87478: LD_INT 6
87480: NEG
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: PUSH
87486: LD_INT 6
87488: NEG
87489: PUSH
87490: LD_INT 5
87492: NEG
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 6
87500: NEG
87501: PUSH
87502: LD_INT 6
87504: NEG
87505: PUSH
87506: EMPTY
87507: LIST
87508: LIST
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: LIST
87514: LIST
87515: LIST
87516: LIST
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
87524: LD_ADDR_VAR 0 41
87528: PUSH
87529: LD_INT 0
87531: PUSH
87532: LD_INT 2
87534: NEG
87535: PUSH
87536: EMPTY
87537: LIST
87538: LIST
87539: PUSH
87540: LD_INT 1
87542: NEG
87543: PUSH
87544: LD_INT 3
87546: NEG
87547: PUSH
87548: EMPTY
87549: LIST
87550: LIST
87551: PUSH
87552: LD_INT 1
87554: PUSH
87555: LD_INT 2
87557: NEG
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: LIST
87567: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
87568: LD_ADDR_VAR 0 42
87572: PUSH
87573: LD_INT 2
87575: PUSH
87576: LD_INT 0
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: LD_INT 2
87585: PUSH
87586: LD_INT 1
87588: NEG
87589: PUSH
87590: EMPTY
87591: LIST
87592: LIST
87593: PUSH
87594: LD_INT 3
87596: PUSH
87597: LD_INT 1
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: LIST
87608: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
87609: LD_ADDR_VAR 0 43
87613: PUSH
87614: LD_INT 2
87616: PUSH
87617: LD_INT 2
87619: PUSH
87620: EMPTY
87621: LIST
87622: LIST
87623: PUSH
87624: LD_INT 3
87626: PUSH
87627: LD_INT 2
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 2
87636: PUSH
87637: LD_INT 3
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: PUSH
87644: EMPTY
87645: LIST
87646: LIST
87647: LIST
87648: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
87649: LD_ADDR_VAR 0 44
87653: PUSH
87654: LD_INT 0
87656: PUSH
87657: LD_INT 2
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 1
87666: PUSH
87667: LD_INT 3
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 1
87676: NEG
87677: PUSH
87678: LD_INT 2
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: LIST
87689: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87690: LD_ADDR_VAR 0 45
87694: PUSH
87695: LD_INT 2
87697: NEG
87698: PUSH
87699: LD_INT 0
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: PUSH
87706: LD_INT 2
87708: NEG
87709: PUSH
87710: LD_INT 1
87712: PUSH
87713: EMPTY
87714: LIST
87715: LIST
87716: PUSH
87717: LD_INT 3
87719: NEG
87720: PUSH
87721: LD_INT 1
87723: NEG
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: LIST
87733: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
87734: LD_ADDR_VAR 0 46
87738: PUSH
87739: LD_INT 2
87741: NEG
87742: PUSH
87743: LD_INT 2
87745: NEG
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 2
87753: NEG
87754: PUSH
87755: LD_INT 3
87757: NEG
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 3
87765: NEG
87766: PUSH
87767: LD_INT 2
87769: NEG
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: LIST
87779: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
87780: LD_ADDR_VAR 0 47
87784: PUSH
87785: LD_INT 2
87787: NEG
87788: PUSH
87789: LD_INT 3
87791: NEG
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 1
87799: NEG
87800: PUSH
87801: LD_INT 3
87803: NEG
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
87813: LD_ADDR_VAR 0 48
87817: PUSH
87818: LD_INT 1
87820: PUSH
87821: LD_INT 2
87823: NEG
87824: PUSH
87825: EMPTY
87826: LIST
87827: LIST
87828: PUSH
87829: LD_INT 2
87831: PUSH
87832: LD_INT 1
87834: NEG
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: PUSH
87840: EMPTY
87841: LIST
87842: LIST
87843: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
87844: LD_ADDR_VAR 0 49
87848: PUSH
87849: LD_INT 3
87851: PUSH
87852: LD_INT 1
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: LD_INT 3
87861: PUSH
87862: LD_INT 2
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
87873: LD_ADDR_VAR 0 50
87877: PUSH
87878: LD_INT 2
87880: PUSH
87881: LD_INT 3
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 1
87890: PUSH
87891: LD_INT 3
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87902: LD_ADDR_VAR 0 51
87906: PUSH
87907: LD_INT 1
87909: NEG
87910: PUSH
87911: LD_INT 2
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 2
87920: NEG
87921: PUSH
87922: LD_INT 1
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: EMPTY
87930: LIST
87931: LIST
87932: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87933: LD_ADDR_VAR 0 52
87937: PUSH
87938: LD_INT 3
87940: NEG
87941: PUSH
87942: LD_INT 1
87944: NEG
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 3
87952: NEG
87953: PUSH
87954: LD_INT 2
87956: NEG
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
87966: LD_ADDR_VAR 0 53
87970: PUSH
87971: LD_INT 1
87973: NEG
87974: PUSH
87975: LD_INT 3
87977: NEG
87978: PUSH
87979: EMPTY
87980: LIST
87981: LIST
87982: PUSH
87983: LD_INT 0
87985: PUSH
87986: LD_INT 3
87988: NEG
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: PUSH
87994: LD_INT 1
87996: PUSH
87997: LD_INT 2
87999: NEG
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: LIST
88009: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88010: LD_ADDR_VAR 0 54
88014: PUSH
88015: LD_INT 2
88017: PUSH
88018: LD_INT 1
88020: NEG
88021: PUSH
88022: EMPTY
88023: LIST
88024: LIST
88025: PUSH
88026: LD_INT 3
88028: PUSH
88029: LD_INT 0
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: PUSH
88036: LD_INT 3
88038: PUSH
88039: LD_INT 1
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: LIST
88050: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88051: LD_ADDR_VAR 0 55
88055: PUSH
88056: LD_INT 3
88058: PUSH
88059: LD_INT 2
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PUSH
88066: LD_INT 3
88068: PUSH
88069: LD_INT 3
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 2
88078: PUSH
88079: LD_INT 3
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: LIST
88090: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88091: LD_ADDR_VAR 0 56
88095: PUSH
88096: LD_INT 1
88098: PUSH
88099: LD_INT 3
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: PUSH
88106: LD_INT 0
88108: PUSH
88109: LD_INT 3
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 1
88118: NEG
88119: PUSH
88120: LD_INT 2
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: LIST
88131: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88132: LD_ADDR_VAR 0 57
88136: PUSH
88137: LD_INT 2
88139: NEG
88140: PUSH
88141: LD_INT 1
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PUSH
88148: LD_INT 3
88150: NEG
88151: PUSH
88152: LD_INT 0
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 3
88161: NEG
88162: PUSH
88163: LD_INT 1
88165: NEG
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: LIST
88175: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88176: LD_ADDR_VAR 0 58
88180: PUSH
88181: LD_INT 2
88183: NEG
88184: PUSH
88185: LD_INT 3
88187: NEG
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 3
88195: NEG
88196: PUSH
88197: LD_INT 2
88199: NEG
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 3
88207: NEG
88208: PUSH
88209: LD_INT 3
88211: NEG
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: LIST
88221: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
88222: LD_ADDR_VAR 0 59
88226: PUSH
88227: LD_INT 1
88229: NEG
88230: PUSH
88231: LD_INT 2
88233: NEG
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 0
88241: PUSH
88242: LD_INT 2
88244: NEG
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 1
88252: PUSH
88253: LD_INT 1
88255: NEG
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: LIST
88265: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88266: LD_ADDR_VAR 0 60
88270: PUSH
88271: LD_INT 1
88273: PUSH
88274: LD_INT 1
88276: NEG
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PUSH
88282: LD_INT 2
88284: PUSH
88285: LD_INT 0
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 2
88294: PUSH
88295: LD_INT 1
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: LIST
88306: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88307: LD_ADDR_VAR 0 61
88311: PUSH
88312: LD_INT 2
88314: PUSH
88315: LD_INT 1
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 2
88324: PUSH
88325: LD_INT 2
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 1
88334: PUSH
88335: LD_INT 2
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: LIST
88346: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88347: LD_ADDR_VAR 0 62
88351: PUSH
88352: LD_INT 1
88354: PUSH
88355: LD_INT 2
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 0
88364: PUSH
88365: LD_INT 2
88367: PUSH
88368: EMPTY
88369: LIST
88370: LIST
88371: PUSH
88372: LD_INT 1
88374: NEG
88375: PUSH
88376: LD_INT 1
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: LIST
88387: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88388: LD_ADDR_VAR 0 63
88392: PUSH
88393: LD_INT 1
88395: NEG
88396: PUSH
88397: LD_INT 1
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 2
88406: NEG
88407: PUSH
88408: LD_INT 0
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 2
88417: NEG
88418: PUSH
88419: LD_INT 1
88421: NEG
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: LIST
88431: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88432: LD_ADDR_VAR 0 64
88436: PUSH
88437: LD_INT 1
88439: NEG
88440: PUSH
88441: LD_INT 2
88443: NEG
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: LD_INT 2
88451: NEG
88452: PUSH
88453: LD_INT 1
88455: NEG
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 2
88463: NEG
88464: PUSH
88465: LD_INT 2
88467: NEG
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: LIST
88477: ST_TO_ADDR
// end ; 2 :
88478: GO 91744
88480: LD_INT 2
88482: DOUBLE
88483: EQUAL
88484: IFTRUE 88488
88486: GO 91743
88488: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
88489: LD_ADDR_VAR 0 29
88493: PUSH
88494: LD_INT 4
88496: PUSH
88497: LD_INT 0
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 4
88506: PUSH
88507: LD_INT 1
88509: NEG
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 5
88517: PUSH
88518: LD_INT 0
88520: PUSH
88521: EMPTY
88522: LIST
88523: LIST
88524: PUSH
88525: LD_INT 5
88527: PUSH
88528: LD_INT 1
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 4
88537: PUSH
88538: LD_INT 1
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 3
88547: PUSH
88548: LD_INT 0
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: PUSH
88555: LD_INT 3
88557: PUSH
88558: LD_INT 1
88560: NEG
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: PUSH
88566: LD_INT 3
88568: PUSH
88569: LD_INT 2
88571: NEG
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 5
88579: PUSH
88580: LD_INT 2
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 3
88589: PUSH
88590: LD_INT 3
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 3
88599: PUSH
88600: LD_INT 2
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 4
88609: PUSH
88610: LD_INT 3
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 4
88619: PUSH
88620: LD_INT 4
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 3
88629: PUSH
88630: LD_INT 4
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PUSH
88637: LD_INT 2
88639: PUSH
88640: LD_INT 3
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 2
88649: PUSH
88650: LD_INT 2
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: LD_INT 4
88659: PUSH
88660: LD_INT 2
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: PUSH
88667: LD_INT 2
88669: PUSH
88670: LD_INT 4
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: LD_INT 4
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 0
88689: PUSH
88690: LD_INT 3
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 1
88699: PUSH
88700: LD_INT 4
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 1
88709: PUSH
88710: LD_INT 5
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 0
88719: PUSH
88720: LD_INT 5
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: LD_INT 1
88729: NEG
88730: PUSH
88731: LD_INT 4
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 1
88740: NEG
88741: PUSH
88742: LD_INT 3
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 2
88751: PUSH
88752: LD_INT 5
88754: PUSH
88755: EMPTY
88756: LIST
88757: LIST
88758: PUSH
88759: LD_INT 2
88761: NEG
88762: PUSH
88763: LD_INT 3
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 3
88772: NEG
88773: PUSH
88774: LD_INT 0
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: PUSH
88781: LD_INT 3
88783: NEG
88784: PUSH
88785: LD_INT 1
88787: NEG
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 2
88795: NEG
88796: PUSH
88797: LD_INT 0
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 2
88806: NEG
88807: PUSH
88808: LD_INT 1
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 3
88817: NEG
88818: PUSH
88819: LD_INT 1
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: PUSH
88826: LD_INT 4
88828: NEG
88829: PUSH
88830: LD_INT 0
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 4
88839: NEG
88840: PUSH
88841: LD_INT 1
88843: NEG
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: LD_INT 4
88851: NEG
88852: PUSH
88853: LD_INT 2
88855: NEG
88856: PUSH
88857: EMPTY
88858: LIST
88859: LIST
88860: PUSH
88861: LD_INT 2
88863: NEG
88864: PUSH
88865: LD_INT 2
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 4
88874: NEG
88875: PUSH
88876: LD_INT 4
88878: NEG
88879: PUSH
88880: EMPTY
88881: LIST
88882: LIST
88883: PUSH
88884: LD_INT 4
88886: NEG
88887: PUSH
88888: LD_INT 5
88890: NEG
88891: PUSH
88892: EMPTY
88893: LIST
88894: LIST
88895: PUSH
88896: LD_INT 3
88898: NEG
88899: PUSH
88900: LD_INT 4
88902: NEG
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 3
88910: NEG
88911: PUSH
88912: LD_INT 3
88914: NEG
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 4
88922: NEG
88923: PUSH
88924: LD_INT 3
88926: NEG
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: PUSH
88932: LD_INT 5
88934: NEG
88935: PUSH
88936: LD_INT 4
88938: NEG
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: PUSH
88944: LD_INT 5
88946: NEG
88947: PUSH
88948: LD_INT 5
88950: NEG
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 3
88958: NEG
88959: PUSH
88960: LD_INT 5
88962: NEG
88963: PUSH
88964: EMPTY
88965: LIST
88966: LIST
88967: PUSH
88968: LD_INT 5
88970: NEG
88971: PUSH
88972: LD_INT 3
88974: NEG
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
89027: LD_ADDR_VAR 0 30
89031: PUSH
89032: LD_INT 4
89034: PUSH
89035: LD_INT 4
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 4
89044: PUSH
89045: LD_INT 3
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 5
89054: PUSH
89055: LD_INT 4
89057: PUSH
89058: EMPTY
89059: LIST
89060: LIST
89061: PUSH
89062: LD_INT 5
89064: PUSH
89065: LD_INT 5
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 4
89074: PUSH
89075: LD_INT 5
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 3
89084: PUSH
89085: LD_INT 4
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: PUSH
89092: LD_INT 3
89094: PUSH
89095: LD_INT 3
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: PUSH
89102: LD_INT 5
89104: PUSH
89105: LD_INT 3
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PUSH
89112: LD_INT 3
89114: PUSH
89115: LD_INT 5
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: PUSH
89122: LD_INT 0
89124: PUSH
89125: LD_INT 3
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: PUSH
89132: LD_INT 0
89134: PUSH
89135: LD_INT 2
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 1
89144: PUSH
89145: LD_INT 3
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 1
89154: PUSH
89155: LD_INT 4
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: LD_INT 0
89164: PUSH
89165: LD_INT 4
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 1
89174: NEG
89175: PUSH
89176: LD_INT 3
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: LD_INT 1
89185: NEG
89186: PUSH
89187: LD_INT 2
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 2
89196: PUSH
89197: LD_INT 4
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: LD_INT 2
89206: NEG
89207: PUSH
89208: LD_INT 2
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: PUSH
89215: LD_INT 4
89217: NEG
89218: PUSH
89219: LD_INT 0
89221: PUSH
89222: EMPTY
89223: LIST
89224: LIST
89225: PUSH
89226: LD_INT 4
89228: NEG
89229: PUSH
89230: LD_INT 1
89232: NEG
89233: PUSH
89234: EMPTY
89235: LIST
89236: LIST
89237: PUSH
89238: LD_INT 3
89240: NEG
89241: PUSH
89242: LD_INT 0
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: PUSH
89249: LD_INT 3
89251: NEG
89252: PUSH
89253: LD_INT 1
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: PUSH
89260: LD_INT 4
89262: NEG
89263: PUSH
89264: LD_INT 1
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 5
89273: NEG
89274: PUSH
89275: LD_INT 0
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 5
89284: NEG
89285: PUSH
89286: LD_INT 1
89288: NEG
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 5
89296: NEG
89297: PUSH
89298: LD_INT 2
89300: NEG
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: PUSH
89306: LD_INT 3
89308: NEG
89309: PUSH
89310: LD_INT 2
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: LD_INT 3
89319: NEG
89320: PUSH
89321: LD_INT 3
89323: NEG
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 3
89331: NEG
89332: PUSH
89333: LD_INT 4
89335: NEG
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: LD_INT 2
89343: NEG
89344: PUSH
89345: LD_INT 3
89347: NEG
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 2
89355: NEG
89356: PUSH
89357: LD_INT 2
89359: NEG
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 3
89367: NEG
89368: PUSH
89369: LD_INT 2
89371: NEG
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: PUSH
89377: LD_INT 4
89379: NEG
89380: PUSH
89381: LD_INT 3
89383: NEG
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: LD_INT 4
89391: NEG
89392: PUSH
89393: LD_INT 4
89395: NEG
89396: PUSH
89397: EMPTY
89398: LIST
89399: LIST
89400: PUSH
89401: LD_INT 2
89403: NEG
89404: PUSH
89405: LD_INT 4
89407: NEG
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: PUSH
89413: LD_INT 4
89415: NEG
89416: PUSH
89417: LD_INT 2
89419: NEG
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PUSH
89425: LD_INT 0
89427: PUSH
89428: LD_INT 4
89430: NEG
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 0
89438: PUSH
89439: LD_INT 5
89441: NEG
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: LD_INT 4
89452: NEG
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: LD_INT 1
89460: PUSH
89461: LD_INT 3
89463: NEG
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 0
89471: PUSH
89472: LD_INT 3
89474: NEG
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 1
89482: NEG
89483: PUSH
89484: LD_INT 4
89486: NEG
89487: PUSH
89488: EMPTY
89489: LIST
89490: LIST
89491: PUSH
89492: LD_INT 1
89494: NEG
89495: PUSH
89496: LD_INT 5
89498: NEG
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: PUSH
89504: LD_INT 2
89506: PUSH
89507: LD_INT 3
89509: NEG
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 2
89517: NEG
89518: PUSH
89519: LD_INT 5
89521: NEG
89522: PUSH
89523: EMPTY
89524: LIST
89525: LIST
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
89574: LD_ADDR_VAR 0 31
89578: PUSH
89579: LD_INT 0
89581: PUSH
89582: LD_INT 4
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 0
89591: PUSH
89592: LD_INT 3
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 1
89601: PUSH
89602: LD_INT 4
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 1
89611: PUSH
89612: LD_INT 5
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: LD_INT 0
89621: PUSH
89622: LD_INT 5
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: PUSH
89629: LD_INT 1
89631: NEG
89632: PUSH
89633: LD_INT 4
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 1
89642: NEG
89643: PUSH
89644: LD_INT 3
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 2
89653: PUSH
89654: LD_INT 5
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 2
89663: NEG
89664: PUSH
89665: LD_INT 3
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 3
89674: NEG
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 3
89685: NEG
89686: PUSH
89687: LD_INT 1
89689: NEG
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PUSH
89695: LD_INT 2
89697: NEG
89698: PUSH
89699: LD_INT 0
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 2
89708: NEG
89709: PUSH
89710: LD_INT 1
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 3
89719: NEG
89720: PUSH
89721: LD_INT 1
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 4
89730: NEG
89731: PUSH
89732: LD_INT 0
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 4
89741: NEG
89742: PUSH
89743: LD_INT 1
89745: NEG
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 4
89753: NEG
89754: PUSH
89755: LD_INT 2
89757: NEG
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 2
89765: NEG
89766: PUSH
89767: LD_INT 2
89769: PUSH
89770: EMPTY
89771: LIST
89772: LIST
89773: PUSH
89774: LD_INT 4
89776: NEG
89777: PUSH
89778: LD_INT 4
89780: NEG
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: PUSH
89786: LD_INT 4
89788: NEG
89789: PUSH
89790: LD_INT 5
89792: NEG
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: LD_INT 3
89800: NEG
89801: PUSH
89802: LD_INT 4
89804: NEG
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 3
89812: NEG
89813: PUSH
89814: LD_INT 3
89816: NEG
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 4
89824: NEG
89825: PUSH
89826: LD_INT 3
89828: NEG
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: LD_INT 5
89836: NEG
89837: PUSH
89838: LD_INT 4
89840: NEG
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 5
89848: NEG
89849: PUSH
89850: LD_INT 5
89852: NEG
89853: PUSH
89854: EMPTY
89855: LIST
89856: LIST
89857: PUSH
89858: LD_INT 3
89860: NEG
89861: PUSH
89862: LD_INT 5
89864: NEG
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PUSH
89870: LD_INT 5
89872: NEG
89873: PUSH
89874: LD_INT 3
89876: NEG
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: LD_INT 0
89884: PUSH
89885: LD_INT 3
89887: NEG
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: PUSH
89893: LD_INT 0
89895: PUSH
89896: LD_INT 4
89898: NEG
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: PUSH
89904: LD_INT 1
89906: PUSH
89907: LD_INT 3
89909: NEG
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: LD_INT 1
89917: PUSH
89918: LD_INT 2
89920: NEG
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 0
89928: PUSH
89929: LD_INT 2
89931: NEG
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 1
89939: NEG
89940: PUSH
89941: LD_INT 3
89943: NEG
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: LD_INT 1
89951: NEG
89952: PUSH
89953: LD_INT 4
89955: NEG
89956: PUSH
89957: EMPTY
89958: LIST
89959: LIST
89960: PUSH
89961: LD_INT 2
89963: PUSH
89964: LD_INT 2
89966: NEG
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: PUSH
89972: LD_INT 2
89974: NEG
89975: PUSH
89976: LD_INT 4
89978: NEG
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 4
89986: PUSH
89987: LD_INT 0
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: PUSH
89994: LD_INT 4
89996: PUSH
89997: LD_INT 1
89999: NEG
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 5
90007: PUSH
90008: LD_INT 0
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: PUSH
90015: LD_INT 5
90017: PUSH
90018: LD_INT 1
90020: PUSH
90021: EMPTY
90022: LIST
90023: LIST
90024: PUSH
90025: LD_INT 4
90027: PUSH
90028: LD_INT 1
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 3
90037: PUSH
90038: LD_INT 0
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: LD_INT 3
90047: PUSH
90048: LD_INT 1
90050: NEG
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: LD_INT 3
90058: PUSH
90059: LD_INT 2
90061: NEG
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: LD_INT 5
90069: PUSH
90070: LD_INT 2
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
90124: LD_ADDR_VAR 0 32
90128: PUSH
90129: LD_INT 4
90131: NEG
90132: PUSH
90133: LD_INT 0
90135: PUSH
90136: EMPTY
90137: LIST
90138: LIST
90139: PUSH
90140: LD_INT 4
90142: NEG
90143: PUSH
90144: LD_INT 1
90146: NEG
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: LD_INT 3
90154: NEG
90155: PUSH
90156: LD_INT 0
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 3
90165: NEG
90166: PUSH
90167: LD_INT 1
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 4
90176: NEG
90177: PUSH
90178: LD_INT 1
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: PUSH
90185: LD_INT 5
90187: NEG
90188: PUSH
90189: LD_INT 0
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 5
90198: NEG
90199: PUSH
90200: LD_INT 1
90202: NEG
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 5
90210: NEG
90211: PUSH
90212: LD_INT 2
90214: NEG
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 3
90222: NEG
90223: PUSH
90224: LD_INT 2
90226: PUSH
90227: EMPTY
90228: LIST
90229: LIST
90230: PUSH
90231: LD_INT 3
90233: NEG
90234: PUSH
90235: LD_INT 3
90237: NEG
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 3
90245: NEG
90246: PUSH
90247: LD_INT 4
90249: NEG
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: LD_INT 2
90257: NEG
90258: PUSH
90259: LD_INT 3
90261: NEG
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 2
90269: NEG
90270: PUSH
90271: LD_INT 2
90273: NEG
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 3
90281: NEG
90282: PUSH
90283: LD_INT 2
90285: NEG
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: LD_INT 4
90293: NEG
90294: PUSH
90295: LD_INT 3
90297: NEG
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: LD_INT 4
90305: NEG
90306: PUSH
90307: LD_INT 4
90309: NEG
90310: PUSH
90311: EMPTY
90312: LIST
90313: LIST
90314: PUSH
90315: LD_INT 2
90317: NEG
90318: PUSH
90319: LD_INT 4
90321: NEG
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: LD_INT 4
90329: NEG
90330: PUSH
90331: LD_INT 2
90333: NEG
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: LD_INT 0
90341: PUSH
90342: LD_INT 4
90344: NEG
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 0
90352: PUSH
90353: LD_INT 5
90355: NEG
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 1
90363: PUSH
90364: LD_INT 4
90366: NEG
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 1
90374: PUSH
90375: LD_INT 3
90377: NEG
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 0
90385: PUSH
90386: LD_INT 3
90388: NEG
90389: PUSH
90390: EMPTY
90391: LIST
90392: LIST
90393: PUSH
90394: LD_INT 1
90396: NEG
90397: PUSH
90398: LD_INT 4
90400: NEG
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 1
90408: NEG
90409: PUSH
90410: LD_INT 5
90412: NEG
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 2
90420: PUSH
90421: LD_INT 3
90423: NEG
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 2
90431: NEG
90432: PUSH
90433: LD_INT 5
90435: NEG
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 3
90443: PUSH
90444: LD_INT 0
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 3
90453: PUSH
90454: LD_INT 1
90456: NEG
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 4
90464: PUSH
90465: LD_INT 0
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 4
90474: PUSH
90475: LD_INT 1
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: PUSH
90482: LD_INT 3
90484: PUSH
90485: LD_INT 1
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PUSH
90492: LD_INT 2
90494: PUSH
90495: LD_INT 0
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 2
90504: PUSH
90505: LD_INT 1
90507: NEG
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 2
90515: PUSH
90516: LD_INT 2
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 4
90526: PUSH
90527: LD_INT 2
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 4
90536: PUSH
90537: LD_INT 4
90539: PUSH
90540: EMPTY
90541: LIST
90542: LIST
90543: PUSH
90544: LD_INT 4
90546: PUSH
90547: LD_INT 3
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 5
90556: PUSH
90557: LD_INT 4
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 5
90566: PUSH
90567: LD_INT 5
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: LD_INT 4
90576: PUSH
90577: LD_INT 5
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 3
90586: PUSH
90587: LD_INT 4
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 3
90596: PUSH
90597: LD_INT 3
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 5
90606: PUSH
90607: LD_INT 3
90609: PUSH
90610: EMPTY
90611: LIST
90612: LIST
90613: PUSH
90614: LD_INT 3
90616: PUSH
90617: LD_INT 5
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
90671: LD_ADDR_VAR 0 33
90675: PUSH
90676: LD_INT 4
90678: NEG
90679: PUSH
90680: LD_INT 4
90682: NEG
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 4
90690: NEG
90691: PUSH
90692: LD_INT 5
90694: NEG
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 3
90702: NEG
90703: PUSH
90704: LD_INT 4
90706: NEG
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: PUSH
90712: LD_INT 3
90714: NEG
90715: PUSH
90716: LD_INT 3
90718: NEG
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 4
90726: NEG
90727: PUSH
90728: LD_INT 3
90730: NEG
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: LD_INT 5
90738: NEG
90739: PUSH
90740: LD_INT 4
90742: NEG
90743: PUSH
90744: EMPTY
90745: LIST
90746: LIST
90747: PUSH
90748: LD_INT 5
90750: NEG
90751: PUSH
90752: LD_INT 5
90754: NEG
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: PUSH
90760: LD_INT 3
90762: NEG
90763: PUSH
90764: LD_INT 5
90766: NEG
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 5
90774: NEG
90775: PUSH
90776: LD_INT 3
90778: NEG
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 0
90786: PUSH
90787: LD_INT 3
90789: NEG
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: LD_INT 0
90797: PUSH
90798: LD_INT 4
90800: NEG
90801: PUSH
90802: EMPTY
90803: LIST
90804: LIST
90805: PUSH
90806: LD_INT 1
90808: PUSH
90809: LD_INT 3
90811: NEG
90812: PUSH
90813: EMPTY
90814: LIST
90815: LIST
90816: PUSH
90817: LD_INT 1
90819: PUSH
90820: LD_INT 2
90822: NEG
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: LD_INT 0
90830: PUSH
90831: LD_INT 2
90833: NEG
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: PUSH
90839: LD_INT 1
90841: NEG
90842: PUSH
90843: LD_INT 3
90845: NEG
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 1
90853: NEG
90854: PUSH
90855: LD_INT 4
90857: NEG
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 2
90865: PUSH
90866: LD_INT 2
90868: NEG
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: LD_INT 2
90876: NEG
90877: PUSH
90878: LD_INT 4
90880: NEG
90881: PUSH
90882: EMPTY
90883: LIST
90884: LIST
90885: PUSH
90886: LD_INT 4
90888: PUSH
90889: LD_INT 0
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: PUSH
90896: LD_INT 4
90898: PUSH
90899: LD_INT 1
90901: NEG
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: PUSH
90907: LD_INT 5
90909: PUSH
90910: LD_INT 0
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: LD_INT 5
90919: PUSH
90920: LD_INT 1
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: PUSH
90927: LD_INT 4
90929: PUSH
90930: LD_INT 1
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 3
90939: PUSH
90940: LD_INT 0
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 3
90949: PUSH
90950: LD_INT 1
90952: NEG
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 3
90960: PUSH
90961: LD_INT 2
90963: NEG
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 5
90971: PUSH
90972: LD_INT 2
90974: PUSH
90975: EMPTY
90976: LIST
90977: LIST
90978: PUSH
90979: LD_INT 3
90981: PUSH
90982: LD_INT 3
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: LD_INT 3
90991: PUSH
90992: LD_INT 2
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 4
91001: PUSH
91002: LD_INT 3
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PUSH
91009: LD_INT 4
91011: PUSH
91012: LD_INT 4
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 3
91021: PUSH
91022: LD_INT 4
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 2
91031: PUSH
91032: LD_INT 3
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 2
91041: PUSH
91042: LD_INT 2
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 4
91051: PUSH
91052: LD_INT 2
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 2
91061: PUSH
91062: LD_INT 4
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PUSH
91069: LD_INT 0
91071: PUSH
91072: LD_INT 4
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 0
91081: PUSH
91082: LD_INT 3
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 1
91091: PUSH
91092: LD_INT 4
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 1
91101: PUSH
91102: LD_INT 5
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 0
91111: PUSH
91112: LD_INT 5
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 1
91121: NEG
91122: PUSH
91123: LD_INT 4
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: LD_INT 1
91132: NEG
91133: PUSH
91134: LD_INT 3
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 2
91143: PUSH
91144: LD_INT 5
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PUSH
91151: LD_INT 2
91153: NEG
91154: PUSH
91155: LD_INT 3
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
91209: LD_ADDR_VAR 0 34
91213: PUSH
91214: LD_INT 0
91216: PUSH
91217: LD_INT 4
91219: NEG
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 0
91227: PUSH
91228: LD_INT 5
91230: NEG
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: LD_INT 1
91238: PUSH
91239: LD_INT 4
91241: NEG
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 1
91249: PUSH
91250: LD_INT 3
91252: NEG
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: PUSH
91258: LD_INT 0
91260: PUSH
91261: LD_INT 3
91263: NEG
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 1
91271: NEG
91272: PUSH
91273: LD_INT 4
91275: NEG
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: PUSH
91281: LD_INT 1
91283: NEG
91284: PUSH
91285: LD_INT 5
91287: NEG
91288: PUSH
91289: EMPTY
91290: LIST
91291: LIST
91292: PUSH
91293: LD_INT 2
91295: PUSH
91296: LD_INT 3
91298: NEG
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: PUSH
91304: LD_INT 2
91306: NEG
91307: PUSH
91308: LD_INT 5
91310: NEG
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: LD_INT 3
91318: PUSH
91319: LD_INT 0
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 3
91328: PUSH
91329: LD_INT 1
91331: NEG
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 4
91339: PUSH
91340: LD_INT 0
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 4
91349: PUSH
91350: LD_INT 1
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 3
91359: PUSH
91360: LD_INT 1
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 2
91369: PUSH
91370: LD_INT 0
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 2
91379: PUSH
91380: LD_INT 1
91382: NEG
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 2
91390: PUSH
91391: LD_INT 2
91393: NEG
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: LD_INT 4
91401: PUSH
91402: LD_INT 2
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 4
91411: PUSH
91412: LD_INT 4
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 4
91421: PUSH
91422: LD_INT 3
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 5
91431: PUSH
91432: LD_INT 4
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: PUSH
91439: LD_INT 5
91441: PUSH
91442: LD_INT 5
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 4
91451: PUSH
91452: LD_INT 5
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: LD_INT 3
91461: PUSH
91462: LD_INT 4
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: LD_INT 3
91471: PUSH
91472: LD_INT 3
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: LD_INT 5
91481: PUSH
91482: LD_INT 3
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 3
91491: PUSH
91492: LD_INT 5
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 0
91501: PUSH
91502: LD_INT 3
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: LD_INT 0
91511: PUSH
91512: LD_INT 2
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: LD_INT 1
91521: PUSH
91522: LD_INT 3
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: LD_INT 1
91531: PUSH
91532: LD_INT 4
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 0
91541: PUSH
91542: LD_INT 4
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: PUSH
91549: LD_INT 1
91551: NEG
91552: PUSH
91553: LD_INT 3
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 1
91562: NEG
91563: PUSH
91564: LD_INT 2
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 2
91573: PUSH
91574: LD_INT 4
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 2
91583: NEG
91584: PUSH
91585: LD_INT 2
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: PUSH
91592: LD_INT 4
91594: NEG
91595: PUSH
91596: LD_INT 0
91598: PUSH
91599: EMPTY
91600: LIST
91601: LIST
91602: PUSH
91603: LD_INT 4
91605: NEG
91606: PUSH
91607: LD_INT 1
91609: NEG
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: PUSH
91615: LD_INT 3
91617: NEG
91618: PUSH
91619: LD_INT 0
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 3
91628: NEG
91629: PUSH
91630: LD_INT 1
91632: PUSH
91633: EMPTY
91634: LIST
91635: LIST
91636: PUSH
91637: LD_INT 4
91639: NEG
91640: PUSH
91641: LD_INT 1
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: PUSH
91648: LD_INT 5
91650: NEG
91651: PUSH
91652: LD_INT 0
91654: PUSH
91655: EMPTY
91656: LIST
91657: LIST
91658: PUSH
91659: LD_INT 5
91661: NEG
91662: PUSH
91663: LD_INT 1
91665: NEG
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: PUSH
91671: LD_INT 5
91673: NEG
91674: PUSH
91675: LD_INT 2
91677: NEG
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: PUSH
91683: LD_INT 3
91685: NEG
91686: PUSH
91687: LD_INT 2
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: ST_TO_ADDR
// end ; end ;
91741: GO 91744
91743: POP
// case btype of b_depot , b_warehouse :
91744: LD_VAR 0 1
91748: PUSH
91749: LD_INT 0
91751: DOUBLE
91752: EQUAL
91753: IFTRUE 91763
91755: LD_INT 1
91757: DOUBLE
91758: EQUAL
91759: IFTRUE 91763
91761: GO 91964
91763: POP
// case nation of nation_american :
91764: LD_VAR 0 5
91768: PUSH
91769: LD_INT 1
91771: DOUBLE
91772: EQUAL
91773: IFTRUE 91777
91775: GO 91833
91777: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
91778: LD_ADDR_VAR 0 9
91782: PUSH
91783: LD_VAR 0 11
91787: PUSH
91788: LD_VAR 0 12
91792: PUSH
91793: LD_VAR 0 13
91797: PUSH
91798: LD_VAR 0 14
91802: PUSH
91803: LD_VAR 0 15
91807: PUSH
91808: LD_VAR 0 16
91812: PUSH
91813: EMPTY
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: PUSH
91821: LD_VAR 0 4
91825: PUSH
91826: LD_INT 1
91828: PLUS
91829: ARRAY
91830: ST_TO_ADDR
91831: GO 91962
91833: LD_INT 2
91835: DOUBLE
91836: EQUAL
91837: IFTRUE 91841
91839: GO 91897
91841: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
91842: LD_ADDR_VAR 0 9
91846: PUSH
91847: LD_VAR 0 17
91851: PUSH
91852: LD_VAR 0 18
91856: PUSH
91857: LD_VAR 0 19
91861: PUSH
91862: LD_VAR 0 20
91866: PUSH
91867: LD_VAR 0 21
91871: PUSH
91872: LD_VAR 0 22
91876: PUSH
91877: EMPTY
91878: LIST
91879: LIST
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: PUSH
91885: LD_VAR 0 4
91889: PUSH
91890: LD_INT 1
91892: PLUS
91893: ARRAY
91894: ST_TO_ADDR
91895: GO 91962
91897: LD_INT 3
91899: DOUBLE
91900: EQUAL
91901: IFTRUE 91905
91903: GO 91961
91905: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
91906: LD_ADDR_VAR 0 9
91910: PUSH
91911: LD_VAR 0 23
91915: PUSH
91916: LD_VAR 0 24
91920: PUSH
91921: LD_VAR 0 25
91925: PUSH
91926: LD_VAR 0 26
91930: PUSH
91931: LD_VAR 0 27
91935: PUSH
91936: LD_VAR 0 28
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: PUSH
91949: LD_VAR 0 4
91953: PUSH
91954: LD_INT 1
91956: PLUS
91957: ARRAY
91958: ST_TO_ADDR
91959: GO 91962
91961: POP
91962: GO 92517
91964: LD_INT 2
91966: DOUBLE
91967: EQUAL
91968: IFTRUE 91978
91970: LD_INT 3
91972: DOUBLE
91973: EQUAL
91974: IFTRUE 91978
91976: GO 92034
91978: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
91979: LD_ADDR_VAR 0 9
91983: PUSH
91984: LD_VAR 0 29
91988: PUSH
91989: LD_VAR 0 30
91993: PUSH
91994: LD_VAR 0 31
91998: PUSH
91999: LD_VAR 0 32
92003: PUSH
92004: LD_VAR 0 33
92008: PUSH
92009: LD_VAR 0 34
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: PUSH
92022: LD_VAR 0 4
92026: PUSH
92027: LD_INT 1
92029: PLUS
92030: ARRAY
92031: ST_TO_ADDR
92032: GO 92517
92034: LD_INT 16
92036: DOUBLE
92037: EQUAL
92038: IFTRUE 92096
92040: LD_INT 17
92042: DOUBLE
92043: EQUAL
92044: IFTRUE 92096
92046: LD_INT 18
92048: DOUBLE
92049: EQUAL
92050: IFTRUE 92096
92052: LD_INT 19
92054: DOUBLE
92055: EQUAL
92056: IFTRUE 92096
92058: LD_INT 22
92060: DOUBLE
92061: EQUAL
92062: IFTRUE 92096
92064: LD_INT 20
92066: DOUBLE
92067: EQUAL
92068: IFTRUE 92096
92070: LD_INT 21
92072: DOUBLE
92073: EQUAL
92074: IFTRUE 92096
92076: LD_INT 23
92078: DOUBLE
92079: EQUAL
92080: IFTRUE 92096
92082: LD_INT 24
92084: DOUBLE
92085: EQUAL
92086: IFTRUE 92096
92088: LD_INT 25
92090: DOUBLE
92091: EQUAL
92092: IFTRUE 92096
92094: GO 92152
92096: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
92097: LD_ADDR_VAR 0 9
92101: PUSH
92102: LD_VAR 0 35
92106: PUSH
92107: LD_VAR 0 36
92111: PUSH
92112: LD_VAR 0 37
92116: PUSH
92117: LD_VAR 0 38
92121: PUSH
92122: LD_VAR 0 39
92126: PUSH
92127: LD_VAR 0 40
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: PUSH
92140: LD_VAR 0 4
92144: PUSH
92145: LD_INT 1
92147: PLUS
92148: ARRAY
92149: ST_TO_ADDR
92150: GO 92517
92152: LD_INT 6
92154: DOUBLE
92155: EQUAL
92156: IFTRUE 92208
92158: LD_INT 7
92160: DOUBLE
92161: EQUAL
92162: IFTRUE 92208
92164: LD_INT 8
92166: DOUBLE
92167: EQUAL
92168: IFTRUE 92208
92170: LD_INT 13
92172: DOUBLE
92173: EQUAL
92174: IFTRUE 92208
92176: LD_INT 12
92178: DOUBLE
92179: EQUAL
92180: IFTRUE 92208
92182: LD_INT 15
92184: DOUBLE
92185: EQUAL
92186: IFTRUE 92208
92188: LD_INT 11
92190: DOUBLE
92191: EQUAL
92192: IFTRUE 92208
92194: LD_INT 14
92196: DOUBLE
92197: EQUAL
92198: IFTRUE 92208
92200: LD_INT 10
92202: DOUBLE
92203: EQUAL
92204: IFTRUE 92208
92206: GO 92264
92208: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
92209: LD_ADDR_VAR 0 9
92213: PUSH
92214: LD_VAR 0 41
92218: PUSH
92219: LD_VAR 0 42
92223: PUSH
92224: LD_VAR 0 43
92228: PUSH
92229: LD_VAR 0 44
92233: PUSH
92234: LD_VAR 0 45
92238: PUSH
92239: LD_VAR 0 46
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: PUSH
92252: LD_VAR 0 4
92256: PUSH
92257: LD_INT 1
92259: PLUS
92260: ARRAY
92261: ST_TO_ADDR
92262: GO 92517
92264: LD_INT 36
92266: DOUBLE
92267: EQUAL
92268: IFTRUE 92272
92270: GO 92328
92272: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
92273: LD_ADDR_VAR 0 9
92277: PUSH
92278: LD_VAR 0 47
92282: PUSH
92283: LD_VAR 0 48
92287: PUSH
92288: LD_VAR 0 49
92292: PUSH
92293: LD_VAR 0 50
92297: PUSH
92298: LD_VAR 0 51
92302: PUSH
92303: LD_VAR 0 52
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: PUSH
92316: LD_VAR 0 4
92320: PUSH
92321: LD_INT 1
92323: PLUS
92324: ARRAY
92325: ST_TO_ADDR
92326: GO 92517
92328: LD_INT 4
92330: DOUBLE
92331: EQUAL
92332: IFTRUE 92354
92334: LD_INT 5
92336: DOUBLE
92337: EQUAL
92338: IFTRUE 92354
92340: LD_INT 34
92342: DOUBLE
92343: EQUAL
92344: IFTRUE 92354
92346: LD_INT 37
92348: DOUBLE
92349: EQUAL
92350: IFTRUE 92354
92352: GO 92410
92354: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
92355: LD_ADDR_VAR 0 9
92359: PUSH
92360: LD_VAR 0 53
92364: PUSH
92365: LD_VAR 0 54
92369: PUSH
92370: LD_VAR 0 55
92374: PUSH
92375: LD_VAR 0 56
92379: PUSH
92380: LD_VAR 0 57
92384: PUSH
92385: LD_VAR 0 58
92389: PUSH
92390: EMPTY
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: PUSH
92398: LD_VAR 0 4
92402: PUSH
92403: LD_INT 1
92405: PLUS
92406: ARRAY
92407: ST_TO_ADDR
92408: GO 92517
92410: LD_INT 31
92412: DOUBLE
92413: EQUAL
92414: IFTRUE 92460
92416: LD_INT 32
92418: DOUBLE
92419: EQUAL
92420: IFTRUE 92460
92422: LD_INT 33
92424: DOUBLE
92425: EQUAL
92426: IFTRUE 92460
92428: LD_INT 27
92430: DOUBLE
92431: EQUAL
92432: IFTRUE 92460
92434: LD_INT 26
92436: DOUBLE
92437: EQUAL
92438: IFTRUE 92460
92440: LD_INT 28
92442: DOUBLE
92443: EQUAL
92444: IFTRUE 92460
92446: LD_INT 29
92448: DOUBLE
92449: EQUAL
92450: IFTRUE 92460
92452: LD_INT 30
92454: DOUBLE
92455: EQUAL
92456: IFTRUE 92460
92458: GO 92516
92460: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
92461: LD_ADDR_VAR 0 9
92465: PUSH
92466: LD_VAR 0 59
92470: PUSH
92471: LD_VAR 0 60
92475: PUSH
92476: LD_VAR 0 61
92480: PUSH
92481: LD_VAR 0 62
92485: PUSH
92486: LD_VAR 0 63
92490: PUSH
92491: LD_VAR 0 64
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: LIST
92500: LIST
92501: LIST
92502: LIST
92503: PUSH
92504: LD_VAR 0 4
92508: PUSH
92509: LD_INT 1
92511: PLUS
92512: ARRAY
92513: ST_TO_ADDR
92514: GO 92517
92516: POP
// temp_list2 = [ ] ;
92517: LD_ADDR_VAR 0 10
92521: PUSH
92522: EMPTY
92523: ST_TO_ADDR
// for i in temp_list do
92524: LD_ADDR_VAR 0 8
92528: PUSH
92529: LD_VAR 0 9
92533: PUSH
92534: FOR_IN
92535: IFFALSE 92587
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
92537: LD_ADDR_VAR 0 10
92541: PUSH
92542: LD_VAR 0 10
92546: PUSH
92547: LD_VAR 0 8
92551: PUSH
92552: LD_INT 1
92554: ARRAY
92555: PUSH
92556: LD_VAR 0 2
92560: PLUS
92561: PUSH
92562: LD_VAR 0 8
92566: PUSH
92567: LD_INT 2
92569: ARRAY
92570: PUSH
92571: LD_VAR 0 3
92575: PLUS
92576: PUSH
92577: EMPTY
92578: LIST
92579: LIST
92580: PUSH
92581: EMPTY
92582: LIST
92583: ADD
92584: ST_TO_ADDR
92585: GO 92534
92587: POP
92588: POP
// result = temp_list2 ;
92589: LD_ADDR_VAR 0 7
92593: PUSH
92594: LD_VAR 0 10
92598: ST_TO_ADDR
// end ;
92599: LD_VAR 0 7
92603: RET
// export function EnemyInRange ( unit , dist ) ; begin
92604: LD_INT 0
92606: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
92607: LD_ADDR_VAR 0 3
92611: PUSH
92612: LD_VAR 0 1
92616: PPUSH
92617: CALL_OW 255
92621: PPUSH
92622: LD_VAR 0 1
92626: PPUSH
92627: CALL_OW 250
92631: PPUSH
92632: LD_VAR 0 1
92636: PPUSH
92637: CALL_OW 251
92641: PPUSH
92642: LD_VAR 0 2
92646: PPUSH
92647: CALL 66375 0 4
92651: PUSH
92652: LD_INT 4
92654: ARRAY
92655: ST_TO_ADDR
// end ;
92656: LD_VAR 0 3
92660: RET
// export function PlayerSeeMe ( unit ) ; begin
92661: LD_INT 0
92663: PPUSH
// result := See ( your_side , unit ) ;
92664: LD_ADDR_VAR 0 2
92668: PUSH
92669: LD_OWVAR 2
92673: PPUSH
92674: LD_VAR 0 1
92678: PPUSH
92679: CALL_OW 292
92683: ST_TO_ADDR
// end ;
92684: LD_VAR 0 2
92688: RET
// export function ReverseDir ( unit ) ; begin
92689: LD_INT 0
92691: PPUSH
// if not unit then
92692: LD_VAR 0 1
92696: NOT
92697: IFFALSE 92701
// exit ;
92699: GO 92724
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
92701: LD_ADDR_VAR 0 2
92705: PUSH
92706: LD_VAR 0 1
92710: PPUSH
92711: CALL_OW 254
92715: PUSH
92716: LD_INT 3
92718: PLUS
92719: PUSH
92720: LD_INT 6
92722: MOD
92723: ST_TO_ADDR
// end ;
92724: LD_VAR 0 2
92728: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
92729: LD_INT 0
92731: PPUSH
92732: PPUSH
92733: PPUSH
92734: PPUSH
92735: PPUSH
// if not hexes then
92736: LD_VAR 0 2
92740: NOT
92741: IFFALSE 92745
// exit ;
92743: GO 92893
// dist := 9999 ;
92745: LD_ADDR_VAR 0 5
92749: PUSH
92750: LD_INT 9999
92752: ST_TO_ADDR
// for i = 1 to hexes do
92753: LD_ADDR_VAR 0 4
92757: PUSH
92758: DOUBLE
92759: LD_INT 1
92761: DEC
92762: ST_TO_ADDR
92763: LD_VAR 0 2
92767: PUSH
92768: FOR_TO
92769: IFFALSE 92881
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
92771: LD_VAR 0 1
92775: PPUSH
92776: LD_VAR 0 2
92780: PUSH
92781: LD_VAR 0 4
92785: ARRAY
92786: PUSH
92787: LD_INT 1
92789: ARRAY
92790: PPUSH
92791: LD_VAR 0 2
92795: PUSH
92796: LD_VAR 0 4
92800: ARRAY
92801: PUSH
92802: LD_INT 2
92804: ARRAY
92805: PPUSH
92806: CALL_OW 297
92810: PUSH
92811: LD_VAR 0 5
92815: LESS
92816: IFFALSE 92879
// begin hex := hexes [ i ] ;
92818: LD_ADDR_VAR 0 7
92822: PUSH
92823: LD_VAR 0 2
92827: PUSH
92828: LD_VAR 0 4
92832: ARRAY
92833: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
92834: LD_ADDR_VAR 0 5
92838: PUSH
92839: LD_VAR 0 1
92843: PPUSH
92844: LD_VAR 0 2
92848: PUSH
92849: LD_VAR 0 4
92853: ARRAY
92854: PUSH
92855: LD_INT 1
92857: ARRAY
92858: PPUSH
92859: LD_VAR 0 2
92863: PUSH
92864: LD_VAR 0 4
92868: ARRAY
92869: PUSH
92870: LD_INT 2
92872: ARRAY
92873: PPUSH
92874: CALL_OW 297
92878: ST_TO_ADDR
// end ; end ;
92879: GO 92768
92881: POP
92882: POP
// result := hex ;
92883: LD_ADDR_VAR 0 3
92887: PUSH
92888: LD_VAR 0 7
92892: ST_TO_ADDR
// end ;
92893: LD_VAR 0 3
92897: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
92898: LD_INT 0
92900: PPUSH
92901: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
92902: LD_VAR 0 1
92906: NOT
92907: PUSH
92908: LD_VAR 0 1
92912: PUSH
92913: LD_INT 21
92915: PUSH
92916: LD_INT 2
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: LD_INT 23
92925: PUSH
92926: LD_INT 2
92928: PUSH
92929: EMPTY
92930: LIST
92931: LIST
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: PPUSH
92937: CALL_OW 69
92941: IN
92942: NOT
92943: OR
92944: IFFALSE 92948
// exit ;
92946: GO 92995
// for i = 1 to 3 do
92948: LD_ADDR_VAR 0 3
92952: PUSH
92953: DOUBLE
92954: LD_INT 1
92956: DEC
92957: ST_TO_ADDR
92958: LD_INT 3
92960: PUSH
92961: FOR_TO
92962: IFFALSE 92993
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
92964: LD_VAR 0 1
92968: PPUSH
92969: CALL_OW 250
92973: PPUSH
92974: LD_VAR 0 1
92978: PPUSH
92979: CALL_OW 251
92983: PPUSH
92984: LD_INT 1
92986: PPUSH
92987: CALL_OW 453
92991: GO 92961
92993: POP
92994: POP
// end ;
92995: LD_VAR 0 2
92999: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
93000: LD_INT 0
93002: PPUSH
93003: PPUSH
93004: PPUSH
93005: PPUSH
93006: PPUSH
93007: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
93008: LD_VAR 0 1
93012: NOT
93013: PUSH
93014: LD_VAR 0 2
93018: NOT
93019: OR
93020: PUSH
93021: LD_VAR 0 1
93025: PPUSH
93026: CALL_OW 314
93030: OR
93031: IFFALSE 93035
// exit ;
93033: GO 93476
// x := GetX ( enemy_unit ) ;
93035: LD_ADDR_VAR 0 7
93039: PUSH
93040: LD_VAR 0 2
93044: PPUSH
93045: CALL_OW 250
93049: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
93050: LD_ADDR_VAR 0 8
93054: PUSH
93055: LD_VAR 0 2
93059: PPUSH
93060: CALL_OW 251
93064: ST_TO_ADDR
// if not x or not y then
93065: LD_VAR 0 7
93069: NOT
93070: PUSH
93071: LD_VAR 0 8
93075: NOT
93076: OR
93077: IFFALSE 93081
// exit ;
93079: GO 93476
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
93081: LD_ADDR_VAR 0 6
93085: PUSH
93086: LD_VAR 0 7
93090: PPUSH
93091: LD_INT 0
93093: PPUSH
93094: LD_INT 4
93096: PPUSH
93097: CALL_OW 272
93101: PUSH
93102: LD_VAR 0 8
93106: PPUSH
93107: LD_INT 0
93109: PPUSH
93110: LD_INT 4
93112: PPUSH
93113: CALL_OW 273
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_VAR 0 7
93126: PPUSH
93127: LD_INT 1
93129: PPUSH
93130: LD_INT 4
93132: PPUSH
93133: CALL_OW 272
93137: PUSH
93138: LD_VAR 0 8
93142: PPUSH
93143: LD_INT 1
93145: PPUSH
93146: LD_INT 4
93148: PPUSH
93149: CALL_OW 273
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: PUSH
93158: LD_VAR 0 7
93162: PPUSH
93163: LD_INT 2
93165: PPUSH
93166: LD_INT 4
93168: PPUSH
93169: CALL_OW 272
93173: PUSH
93174: LD_VAR 0 8
93178: PPUSH
93179: LD_INT 2
93181: PPUSH
93182: LD_INT 4
93184: PPUSH
93185: CALL_OW 273
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_VAR 0 7
93198: PPUSH
93199: LD_INT 3
93201: PPUSH
93202: LD_INT 4
93204: PPUSH
93205: CALL_OW 272
93209: PUSH
93210: LD_VAR 0 8
93214: PPUSH
93215: LD_INT 3
93217: PPUSH
93218: LD_INT 4
93220: PPUSH
93221: CALL_OW 273
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PUSH
93230: LD_VAR 0 7
93234: PPUSH
93235: LD_INT 4
93237: PPUSH
93238: LD_INT 4
93240: PPUSH
93241: CALL_OW 272
93245: PUSH
93246: LD_VAR 0 8
93250: PPUSH
93251: LD_INT 4
93253: PPUSH
93254: LD_INT 4
93256: PPUSH
93257: CALL_OW 273
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: PUSH
93266: LD_VAR 0 7
93270: PPUSH
93271: LD_INT 5
93273: PPUSH
93274: LD_INT 4
93276: PPUSH
93277: CALL_OW 272
93281: PUSH
93282: LD_VAR 0 8
93286: PPUSH
93287: LD_INT 5
93289: PPUSH
93290: LD_INT 4
93292: PPUSH
93293: CALL_OW 273
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: ST_TO_ADDR
// for i = tmp downto 1 do
93310: LD_ADDR_VAR 0 4
93314: PUSH
93315: DOUBLE
93316: LD_VAR 0 6
93320: INC
93321: ST_TO_ADDR
93322: LD_INT 1
93324: PUSH
93325: FOR_DOWNTO
93326: IFFALSE 93427
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
93328: LD_VAR 0 6
93332: PUSH
93333: LD_VAR 0 4
93337: ARRAY
93338: PUSH
93339: LD_INT 1
93341: ARRAY
93342: PPUSH
93343: LD_VAR 0 6
93347: PUSH
93348: LD_VAR 0 4
93352: ARRAY
93353: PUSH
93354: LD_INT 2
93356: ARRAY
93357: PPUSH
93358: CALL_OW 488
93362: NOT
93363: PUSH
93364: LD_VAR 0 6
93368: PUSH
93369: LD_VAR 0 4
93373: ARRAY
93374: PUSH
93375: LD_INT 1
93377: ARRAY
93378: PPUSH
93379: LD_VAR 0 6
93383: PUSH
93384: LD_VAR 0 4
93388: ARRAY
93389: PUSH
93390: LD_INT 2
93392: ARRAY
93393: PPUSH
93394: CALL_OW 428
93398: PUSH
93399: LD_INT 0
93401: NONEQUAL
93402: OR
93403: IFFALSE 93425
// tmp := Delete ( tmp , i ) ;
93405: LD_ADDR_VAR 0 6
93409: PUSH
93410: LD_VAR 0 6
93414: PPUSH
93415: LD_VAR 0 4
93419: PPUSH
93420: CALL_OW 3
93424: ST_TO_ADDR
93425: GO 93325
93427: POP
93428: POP
// j := GetClosestHex ( unit , tmp ) ;
93429: LD_ADDR_VAR 0 5
93433: PUSH
93434: LD_VAR 0 1
93438: PPUSH
93439: LD_VAR 0 6
93443: PPUSH
93444: CALL 92729 0 2
93448: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
93449: LD_VAR 0 1
93453: PPUSH
93454: LD_VAR 0 5
93458: PUSH
93459: LD_INT 1
93461: ARRAY
93462: PPUSH
93463: LD_VAR 0 5
93467: PUSH
93468: LD_INT 2
93470: ARRAY
93471: PPUSH
93472: CALL_OW 111
// end ;
93476: LD_VAR 0 3
93480: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
93481: LD_INT 0
93483: PPUSH
93484: PPUSH
93485: PPUSH
// uc_side = 0 ;
93486: LD_ADDR_OWVAR 20
93490: PUSH
93491: LD_INT 0
93493: ST_TO_ADDR
// uc_nation = 0 ;
93494: LD_ADDR_OWVAR 21
93498: PUSH
93499: LD_INT 0
93501: ST_TO_ADDR
// InitHc_All ( ) ;
93502: CALL_OW 584
// InitVc ;
93506: CALL_OW 20
// if mastodonts then
93510: LD_VAR 0 6
93514: IFFALSE 93581
// for i = 1 to mastodonts do
93516: LD_ADDR_VAR 0 11
93520: PUSH
93521: DOUBLE
93522: LD_INT 1
93524: DEC
93525: ST_TO_ADDR
93526: LD_VAR 0 6
93530: PUSH
93531: FOR_TO
93532: IFFALSE 93579
// begin vc_chassis := 31 ;
93534: LD_ADDR_OWVAR 37
93538: PUSH
93539: LD_INT 31
93541: ST_TO_ADDR
// vc_control := control_rider ;
93542: LD_ADDR_OWVAR 38
93546: PUSH
93547: LD_INT 4
93549: ST_TO_ADDR
// animal := CreateVehicle ;
93550: LD_ADDR_VAR 0 12
93554: PUSH
93555: CALL_OW 45
93559: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93560: LD_VAR 0 12
93564: PPUSH
93565: LD_VAR 0 8
93569: PPUSH
93570: LD_INT 0
93572: PPUSH
93573: CALL 95769 0 3
// end ;
93577: GO 93531
93579: POP
93580: POP
// if horses then
93581: LD_VAR 0 5
93585: IFFALSE 93652
// for i = 1 to horses do
93587: LD_ADDR_VAR 0 11
93591: PUSH
93592: DOUBLE
93593: LD_INT 1
93595: DEC
93596: ST_TO_ADDR
93597: LD_VAR 0 5
93601: PUSH
93602: FOR_TO
93603: IFFALSE 93650
// begin hc_class := 21 ;
93605: LD_ADDR_OWVAR 28
93609: PUSH
93610: LD_INT 21
93612: ST_TO_ADDR
// hc_gallery :=  ;
93613: LD_ADDR_OWVAR 33
93617: PUSH
93618: LD_STRING 
93620: ST_TO_ADDR
// animal := CreateHuman ;
93621: LD_ADDR_VAR 0 12
93625: PUSH
93626: CALL_OW 44
93630: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93631: LD_VAR 0 12
93635: PPUSH
93636: LD_VAR 0 8
93640: PPUSH
93641: LD_INT 0
93643: PPUSH
93644: CALL 95769 0 3
// end ;
93648: GO 93602
93650: POP
93651: POP
// if birds then
93652: LD_VAR 0 1
93656: IFFALSE 93723
// for i = 1 to birds do
93658: LD_ADDR_VAR 0 11
93662: PUSH
93663: DOUBLE
93664: LD_INT 1
93666: DEC
93667: ST_TO_ADDR
93668: LD_VAR 0 1
93672: PUSH
93673: FOR_TO
93674: IFFALSE 93721
// begin hc_class = 18 ;
93676: LD_ADDR_OWVAR 28
93680: PUSH
93681: LD_INT 18
93683: ST_TO_ADDR
// hc_gallery =  ;
93684: LD_ADDR_OWVAR 33
93688: PUSH
93689: LD_STRING 
93691: ST_TO_ADDR
// animal := CreateHuman ;
93692: LD_ADDR_VAR 0 12
93696: PUSH
93697: CALL_OW 44
93701: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93702: LD_VAR 0 12
93706: PPUSH
93707: LD_VAR 0 8
93711: PPUSH
93712: LD_INT 0
93714: PPUSH
93715: CALL 95769 0 3
// end ;
93719: GO 93673
93721: POP
93722: POP
// if tigers then
93723: LD_VAR 0 2
93727: IFFALSE 93811
// for i = 1 to tigers do
93729: LD_ADDR_VAR 0 11
93733: PUSH
93734: DOUBLE
93735: LD_INT 1
93737: DEC
93738: ST_TO_ADDR
93739: LD_VAR 0 2
93743: PUSH
93744: FOR_TO
93745: IFFALSE 93809
// begin hc_class = class_tiger ;
93747: LD_ADDR_OWVAR 28
93751: PUSH
93752: LD_INT 14
93754: ST_TO_ADDR
// hc_gallery =  ;
93755: LD_ADDR_OWVAR 33
93759: PUSH
93760: LD_STRING 
93762: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
93763: LD_ADDR_OWVAR 35
93767: PUSH
93768: LD_INT 7
93770: NEG
93771: PPUSH
93772: LD_INT 7
93774: PPUSH
93775: CALL_OW 12
93779: ST_TO_ADDR
// animal := CreateHuman ;
93780: LD_ADDR_VAR 0 12
93784: PUSH
93785: CALL_OW 44
93789: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93790: LD_VAR 0 12
93794: PPUSH
93795: LD_VAR 0 8
93799: PPUSH
93800: LD_INT 0
93802: PPUSH
93803: CALL 95769 0 3
// end ;
93807: GO 93744
93809: POP
93810: POP
// if apemans then
93811: LD_VAR 0 3
93815: IFFALSE 93938
// for i = 1 to apemans do
93817: LD_ADDR_VAR 0 11
93821: PUSH
93822: DOUBLE
93823: LD_INT 1
93825: DEC
93826: ST_TO_ADDR
93827: LD_VAR 0 3
93831: PUSH
93832: FOR_TO
93833: IFFALSE 93936
// begin hc_class = class_apeman ;
93835: LD_ADDR_OWVAR 28
93839: PUSH
93840: LD_INT 12
93842: ST_TO_ADDR
// hc_gallery =  ;
93843: LD_ADDR_OWVAR 33
93847: PUSH
93848: LD_STRING 
93850: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
93851: LD_ADDR_OWVAR 35
93855: PUSH
93856: LD_INT 5
93858: NEG
93859: PPUSH
93860: LD_INT 5
93862: PPUSH
93863: CALL_OW 12
93867: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
93868: LD_ADDR_OWVAR 31
93872: PUSH
93873: LD_INT 1
93875: PPUSH
93876: LD_INT 3
93878: PPUSH
93879: CALL_OW 12
93883: PUSH
93884: LD_INT 1
93886: PPUSH
93887: LD_INT 3
93889: PPUSH
93890: CALL_OW 12
93894: PUSH
93895: LD_INT 0
93897: PUSH
93898: LD_INT 0
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: ST_TO_ADDR
// animal := CreateHuman ;
93907: LD_ADDR_VAR 0 12
93911: PUSH
93912: CALL_OW 44
93916: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93917: LD_VAR 0 12
93921: PPUSH
93922: LD_VAR 0 8
93926: PPUSH
93927: LD_INT 0
93929: PPUSH
93930: CALL 95769 0 3
// end ;
93934: GO 93832
93936: POP
93937: POP
// if enchidnas then
93938: LD_VAR 0 4
93942: IFFALSE 94009
// for i = 1 to enchidnas do
93944: LD_ADDR_VAR 0 11
93948: PUSH
93949: DOUBLE
93950: LD_INT 1
93952: DEC
93953: ST_TO_ADDR
93954: LD_VAR 0 4
93958: PUSH
93959: FOR_TO
93960: IFFALSE 94007
// begin hc_class = 13 ;
93962: LD_ADDR_OWVAR 28
93966: PUSH
93967: LD_INT 13
93969: ST_TO_ADDR
// hc_gallery =  ;
93970: LD_ADDR_OWVAR 33
93974: PUSH
93975: LD_STRING 
93977: ST_TO_ADDR
// animal := CreateHuman ;
93978: LD_ADDR_VAR 0 12
93982: PUSH
93983: CALL_OW 44
93987: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93988: LD_VAR 0 12
93992: PPUSH
93993: LD_VAR 0 8
93997: PPUSH
93998: LD_INT 0
94000: PPUSH
94001: CALL 95769 0 3
// end ;
94005: GO 93959
94007: POP
94008: POP
// if fishes then
94009: LD_VAR 0 7
94013: IFFALSE 94080
// for i = 1 to fishes do
94015: LD_ADDR_VAR 0 11
94019: PUSH
94020: DOUBLE
94021: LD_INT 1
94023: DEC
94024: ST_TO_ADDR
94025: LD_VAR 0 7
94029: PUSH
94030: FOR_TO
94031: IFFALSE 94078
// begin hc_class = 20 ;
94033: LD_ADDR_OWVAR 28
94037: PUSH
94038: LD_INT 20
94040: ST_TO_ADDR
// hc_gallery =  ;
94041: LD_ADDR_OWVAR 33
94045: PUSH
94046: LD_STRING 
94048: ST_TO_ADDR
// animal := CreateHuman ;
94049: LD_ADDR_VAR 0 12
94053: PUSH
94054: CALL_OW 44
94058: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
94059: LD_VAR 0 12
94063: PPUSH
94064: LD_VAR 0 9
94068: PPUSH
94069: LD_INT 0
94071: PPUSH
94072: CALL 95769 0 3
// end ;
94076: GO 94030
94078: POP
94079: POP
// end ;
94080: LD_VAR 0 10
94084: RET
// export function WantHeal ( sci , unit ) ; begin
94085: LD_INT 0
94087: PPUSH
// if GetTaskList ( sci ) > 0 then
94088: LD_VAR 0 1
94092: PPUSH
94093: CALL_OW 437
94097: PUSH
94098: LD_INT 0
94100: GREATER
94101: IFFALSE 94171
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
94103: LD_VAR 0 1
94107: PPUSH
94108: CALL_OW 437
94112: PUSH
94113: LD_INT 1
94115: ARRAY
94116: PUSH
94117: LD_INT 1
94119: ARRAY
94120: PUSH
94121: LD_STRING l
94123: EQUAL
94124: PUSH
94125: LD_VAR 0 1
94129: PPUSH
94130: CALL_OW 437
94134: PUSH
94135: LD_INT 1
94137: ARRAY
94138: PUSH
94139: LD_INT 4
94141: ARRAY
94142: PUSH
94143: LD_VAR 0 2
94147: EQUAL
94148: AND
94149: IFFALSE 94161
// result := true else
94151: LD_ADDR_VAR 0 3
94155: PUSH
94156: LD_INT 1
94158: ST_TO_ADDR
94159: GO 94169
// result := false ;
94161: LD_ADDR_VAR 0 3
94165: PUSH
94166: LD_INT 0
94168: ST_TO_ADDR
// end else
94169: GO 94179
// result := false ;
94171: LD_ADDR_VAR 0 3
94175: PUSH
94176: LD_INT 0
94178: ST_TO_ADDR
// end ;
94179: LD_VAR 0 3
94183: RET
// export function HealTarget ( sci ) ; begin
94184: LD_INT 0
94186: PPUSH
// if not sci then
94187: LD_VAR 0 1
94191: NOT
94192: IFFALSE 94196
// exit ;
94194: GO 94261
// result := 0 ;
94196: LD_ADDR_VAR 0 2
94200: PUSH
94201: LD_INT 0
94203: ST_TO_ADDR
// if GetTaskList ( sci ) then
94204: LD_VAR 0 1
94208: PPUSH
94209: CALL_OW 437
94213: IFFALSE 94261
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
94215: LD_VAR 0 1
94219: PPUSH
94220: CALL_OW 437
94224: PUSH
94225: LD_INT 1
94227: ARRAY
94228: PUSH
94229: LD_INT 1
94231: ARRAY
94232: PUSH
94233: LD_STRING l
94235: EQUAL
94236: IFFALSE 94261
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
94238: LD_ADDR_VAR 0 2
94242: PUSH
94243: LD_VAR 0 1
94247: PPUSH
94248: CALL_OW 437
94252: PUSH
94253: LD_INT 1
94255: ARRAY
94256: PUSH
94257: LD_INT 4
94259: ARRAY
94260: ST_TO_ADDR
// end ;
94261: LD_VAR 0 2
94265: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
94266: LD_INT 0
94268: PPUSH
94269: PPUSH
94270: PPUSH
94271: PPUSH
// if not base_units then
94272: LD_VAR 0 1
94276: NOT
94277: IFFALSE 94281
// exit ;
94279: GO 94368
// result := false ;
94281: LD_ADDR_VAR 0 2
94285: PUSH
94286: LD_INT 0
94288: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
94289: LD_ADDR_VAR 0 5
94293: PUSH
94294: LD_VAR 0 1
94298: PPUSH
94299: LD_INT 21
94301: PUSH
94302: LD_INT 3
94304: PUSH
94305: EMPTY
94306: LIST
94307: LIST
94308: PPUSH
94309: CALL_OW 72
94313: ST_TO_ADDR
// if not tmp then
94314: LD_VAR 0 5
94318: NOT
94319: IFFALSE 94323
// exit ;
94321: GO 94368
// for i in tmp do
94323: LD_ADDR_VAR 0 3
94327: PUSH
94328: LD_VAR 0 5
94332: PUSH
94333: FOR_IN
94334: IFFALSE 94366
// begin result := EnemyInRange ( i , 22 ) ;
94336: LD_ADDR_VAR 0 2
94340: PUSH
94341: LD_VAR 0 3
94345: PPUSH
94346: LD_INT 22
94348: PPUSH
94349: CALL 92604 0 2
94353: ST_TO_ADDR
// if result then
94354: LD_VAR 0 2
94358: IFFALSE 94364
// exit ;
94360: POP
94361: POP
94362: GO 94368
// end ;
94364: GO 94333
94366: POP
94367: POP
// end ;
94368: LD_VAR 0 2
94372: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
94373: LD_INT 0
94375: PPUSH
94376: PPUSH
// if not units then
94377: LD_VAR 0 1
94381: NOT
94382: IFFALSE 94386
// exit ;
94384: GO 94456
// result := [ ] ;
94386: LD_ADDR_VAR 0 3
94390: PUSH
94391: EMPTY
94392: ST_TO_ADDR
// for i in units do
94393: LD_ADDR_VAR 0 4
94397: PUSH
94398: LD_VAR 0 1
94402: PUSH
94403: FOR_IN
94404: IFFALSE 94454
// if GetTag ( i ) = tag then
94406: LD_VAR 0 4
94410: PPUSH
94411: CALL_OW 110
94415: PUSH
94416: LD_VAR 0 2
94420: EQUAL
94421: IFFALSE 94452
// result := Insert ( result , result + 1 , i ) ;
94423: LD_ADDR_VAR 0 3
94427: PUSH
94428: LD_VAR 0 3
94432: PPUSH
94433: LD_VAR 0 3
94437: PUSH
94438: LD_INT 1
94440: PLUS
94441: PPUSH
94442: LD_VAR 0 4
94446: PPUSH
94447: CALL_OW 2
94451: ST_TO_ADDR
94452: GO 94403
94454: POP
94455: POP
// end ;
94456: LD_VAR 0 3
94460: RET
// export function IsDriver ( un ) ; begin
94461: LD_INT 0
94463: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
94464: LD_ADDR_VAR 0 2
94468: PUSH
94469: LD_VAR 0 1
94473: PUSH
94474: LD_INT 55
94476: PUSH
94477: EMPTY
94478: LIST
94479: PPUSH
94480: CALL_OW 69
94484: IN
94485: ST_TO_ADDR
// end ;
94486: LD_VAR 0 2
94490: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
94491: LD_INT 0
94493: PPUSH
94494: PPUSH
// list := [ ] ;
94495: LD_ADDR_VAR 0 5
94499: PUSH
94500: EMPTY
94501: ST_TO_ADDR
// case d of 0 :
94502: LD_VAR 0 3
94506: PUSH
94507: LD_INT 0
94509: DOUBLE
94510: EQUAL
94511: IFTRUE 94515
94513: GO 94648
94515: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
94516: LD_ADDR_VAR 0 5
94520: PUSH
94521: LD_VAR 0 1
94525: PUSH
94526: LD_INT 4
94528: MINUS
94529: PUSH
94530: LD_VAR 0 2
94534: PUSH
94535: LD_INT 4
94537: MINUS
94538: PUSH
94539: LD_INT 2
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: LIST
94546: PUSH
94547: LD_VAR 0 1
94551: PUSH
94552: LD_INT 3
94554: MINUS
94555: PUSH
94556: LD_VAR 0 2
94560: PUSH
94561: LD_INT 1
94563: PUSH
94564: EMPTY
94565: LIST
94566: LIST
94567: LIST
94568: PUSH
94569: LD_VAR 0 1
94573: PUSH
94574: LD_INT 4
94576: PLUS
94577: PUSH
94578: LD_VAR 0 2
94582: PUSH
94583: LD_INT 4
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: LIST
94590: PUSH
94591: LD_VAR 0 1
94595: PUSH
94596: LD_INT 3
94598: PLUS
94599: PUSH
94600: LD_VAR 0 2
94604: PUSH
94605: LD_INT 3
94607: PLUS
94608: PUSH
94609: LD_INT 5
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: LIST
94616: PUSH
94617: LD_VAR 0 1
94621: PUSH
94622: LD_VAR 0 2
94626: PUSH
94627: LD_INT 4
94629: PLUS
94630: PUSH
94631: LD_INT 0
94633: PUSH
94634: EMPTY
94635: LIST
94636: LIST
94637: LIST
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: ST_TO_ADDR
// end ; 1 :
94646: GO 95346
94648: LD_INT 1
94650: DOUBLE
94651: EQUAL
94652: IFTRUE 94656
94654: GO 94789
94656: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
94657: LD_ADDR_VAR 0 5
94661: PUSH
94662: LD_VAR 0 1
94666: PUSH
94667: LD_VAR 0 2
94671: PUSH
94672: LD_INT 4
94674: MINUS
94675: PUSH
94676: LD_INT 3
94678: PUSH
94679: EMPTY
94680: LIST
94681: LIST
94682: LIST
94683: PUSH
94684: LD_VAR 0 1
94688: PUSH
94689: LD_INT 3
94691: MINUS
94692: PUSH
94693: LD_VAR 0 2
94697: PUSH
94698: LD_INT 3
94700: MINUS
94701: PUSH
94702: LD_INT 2
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: LIST
94709: PUSH
94710: LD_VAR 0 1
94714: PUSH
94715: LD_INT 4
94717: MINUS
94718: PUSH
94719: LD_VAR 0 2
94723: PUSH
94724: LD_INT 1
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: LIST
94731: PUSH
94732: LD_VAR 0 1
94736: PUSH
94737: LD_VAR 0 2
94741: PUSH
94742: LD_INT 3
94744: PLUS
94745: PUSH
94746: LD_INT 0
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: LIST
94753: PUSH
94754: LD_VAR 0 1
94758: PUSH
94759: LD_INT 4
94761: PLUS
94762: PUSH
94763: LD_VAR 0 2
94767: PUSH
94768: LD_INT 4
94770: PLUS
94771: PUSH
94772: LD_INT 5
94774: PUSH
94775: EMPTY
94776: LIST
94777: LIST
94778: LIST
94779: PUSH
94780: EMPTY
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: ST_TO_ADDR
// end ; 2 :
94787: GO 95346
94789: LD_INT 2
94791: DOUBLE
94792: EQUAL
94793: IFTRUE 94797
94795: GO 94926
94797: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
94798: LD_ADDR_VAR 0 5
94802: PUSH
94803: LD_VAR 0 1
94807: PUSH
94808: LD_VAR 0 2
94812: PUSH
94813: LD_INT 3
94815: MINUS
94816: PUSH
94817: LD_INT 3
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: LIST
94824: PUSH
94825: LD_VAR 0 1
94829: PUSH
94830: LD_INT 4
94832: PLUS
94833: PUSH
94834: LD_VAR 0 2
94838: PUSH
94839: LD_INT 4
94841: PUSH
94842: EMPTY
94843: LIST
94844: LIST
94845: LIST
94846: PUSH
94847: LD_VAR 0 1
94851: PUSH
94852: LD_VAR 0 2
94856: PUSH
94857: LD_INT 4
94859: PLUS
94860: PUSH
94861: LD_INT 0
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: LIST
94868: PUSH
94869: LD_VAR 0 1
94873: PUSH
94874: LD_INT 3
94876: MINUS
94877: PUSH
94878: LD_VAR 0 2
94882: PUSH
94883: LD_INT 1
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: LIST
94890: PUSH
94891: LD_VAR 0 1
94895: PUSH
94896: LD_INT 4
94898: MINUS
94899: PUSH
94900: LD_VAR 0 2
94904: PUSH
94905: LD_INT 4
94907: MINUS
94908: PUSH
94909: LD_INT 2
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: LIST
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: ST_TO_ADDR
// end ; 3 :
94924: GO 95346
94926: LD_INT 3
94928: DOUBLE
94929: EQUAL
94930: IFTRUE 94934
94932: GO 95067
94934: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
94935: LD_ADDR_VAR 0 5
94939: PUSH
94940: LD_VAR 0 1
94944: PUSH
94945: LD_INT 3
94947: PLUS
94948: PUSH
94949: LD_VAR 0 2
94953: PUSH
94954: LD_INT 4
94956: PUSH
94957: EMPTY
94958: LIST
94959: LIST
94960: LIST
94961: PUSH
94962: LD_VAR 0 1
94966: PUSH
94967: LD_INT 4
94969: PLUS
94970: PUSH
94971: LD_VAR 0 2
94975: PUSH
94976: LD_INT 4
94978: PLUS
94979: PUSH
94980: LD_INT 5
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: LIST
94987: PUSH
94988: LD_VAR 0 1
94992: PUSH
94993: LD_INT 4
94995: MINUS
94996: PUSH
94997: LD_VAR 0 2
95001: PUSH
95002: LD_INT 1
95004: PUSH
95005: EMPTY
95006: LIST
95007: LIST
95008: LIST
95009: PUSH
95010: LD_VAR 0 1
95014: PUSH
95015: LD_VAR 0 2
95019: PUSH
95020: LD_INT 4
95022: MINUS
95023: PUSH
95024: LD_INT 3
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: LIST
95031: PUSH
95032: LD_VAR 0 1
95036: PUSH
95037: LD_INT 3
95039: MINUS
95040: PUSH
95041: LD_VAR 0 2
95045: PUSH
95046: LD_INT 3
95048: MINUS
95049: PUSH
95050: LD_INT 2
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: LIST
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: ST_TO_ADDR
// end ; 4 :
95065: GO 95346
95067: LD_INT 4
95069: DOUBLE
95070: EQUAL
95071: IFTRUE 95075
95073: GO 95208
95075: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
95076: LD_ADDR_VAR 0 5
95080: PUSH
95081: LD_VAR 0 1
95085: PUSH
95086: LD_VAR 0 2
95090: PUSH
95091: LD_INT 4
95093: PLUS
95094: PUSH
95095: LD_INT 0
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: LIST
95102: PUSH
95103: LD_VAR 0 1
95107: PUSH
95108: LD_INT 3
95110: PLUS
95111: PUSH
95112: LD_VAR 0 2
95116: PUSH
95117: LD_INT 3
95119: PLUS
95120: PUSH
95121: LD_INT 5
95123: PUSH
95124: EMPTY
95125: LIST
95126: LIST
95127: LIST
95128: PUSH
95129: LD_VAR 0 1
95133: PUSH
95134: LD_INT 4
95136: PLUS
95137: PUSH
95138: LD_VAR 0 2
95142: PUSH
95143: LD_INT 4
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: LIST
95150: PUSH
95151: LD_VAR 0 1
95155: PUSH
95156: LD_VAR 0 2
95160: PUSH
95161: LD_INT 3
95163: MINUS
95164: PUSH
95165: LD_INT 3
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: LIST
95172: PUSH
95173: LD_VAR 0 1
95177: PUSH
95178: LD_INT 4
95180: MINUS
95181: PUSH
95182: LD_VAR 0 2
95186: PUSH
95187: LD_INT 4
95189: MINUS
95190: PUSH
95191: LD_INT 2
95193: PUSH
95194: EMPTY
95195: LIST
95196: LIST
95197: LIST
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: ST_TO_ADDR
// end ; 5 :
95206: GO 95346
95208: LD_INT 5
95210: DOUBLE
95211: EQUAL
95212: IFTRUE 95216
95214: GO 95345
95216: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
95217: LD_ADDR_VAR 0 5
95221: PUSH
95222: LD_VAR 0 1
95226: PUSH
95227: LD_INT 4
95229: MINUS
95230: PUSH
95231: LD_VAR 0 2
95235: PUSH
95236: LD_INT 1
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: LIST
95243: PUSH
95244: LD_VAR 0 1
95248: PUSH
95249: LD_VAR 0 2
95253: PUSH
95254: LD_INT 4
95256: MINUS
95257: PUSH
95258: LD_INT 3
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: LIST
95265: PUSH
95266: LD_VAR 0 1
95270: PUSH
95271: LD_INT 4
95273: PLUS
95274: PUSH
95275: LD_VAR 0 2
95279: PUSH
95280: LD_INT 4
95282: PLUS
95283: PUSH
95284: LD_INT 5
95286: PUSH
95287: EMPTY
95288: LIST
95289: LIST
95290: LIST
95291: PUSH
95292: LD_VAR 0 1
95296: PUSH
95297: LD_INT 3
95299: PLUS
95300: PUSH
95301: LD_VAR 0 2
95305: PUSH
95306: LD_INT 4
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: LIST
95313: PUSH
95314: LD_VAR 0 1
95318: PUSH
95319: LD_VAR 0 2
95323: PUSH
95324: LD_INT 3
95326: PLUS
95327: PUSH
95328: LD_INT 0
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: LIST
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: ST_TO_ADDR
// end ; end ;
95343: GO 95346
95345: POP
// result := list ;
95346: LD_ADDR_VAR 0 4
95350: PUSH
95351: LD_VAR 0 5
95355: ST_TO_ADDR
// end ;
95356: LD_VAR 0 4
95360: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
95361: LD_INT 0
95363: PPUSH
95364: PPUSH
95365: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
95366: LD_VAR 0 1
95370: NOT
95371: PUSH
95372: LD_VAR 0 2
95376: PUSH
95377: LD_INT 1
95379: PUSH
95380: LD_INT 2
95382: PUSH
95383: LD_INT 3
95385: PUSH
95386: LD_INT 4
95388: PUSH
95389: EMPTY
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: IN
95395: NOT
95396: OR
95397: IFFALSE 95401
// exit ;
95399: GO 95493
// tmp := [ ] ;
95401: LD_ADDR_VAR 0 5
95405: PUSH
95406: EMPTY
95407: ST_TO_ADDR
// for i in units do
95408: LD_ADDR_VAR 0 4
95412: PUSH
95413: LD_VAR 0 1
95417: PUSH
95418: FOR_IN
95419: IFFALSE 95462
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
95421: LD_ADDR_VAR 0 5
95425: PUSH
95426: LD_VAR 0 5
95430: PPUSH
95431: LD_VAR 0 5
95435: PUSH
95436: LD_INT 1
95438: PLUS
95439: PPUSH
95440: LD_VAR 0 4
95444: PPUSH
95445: LD_VAR 0 2
95449: PPUSH
95450: CALL_OW 259
95454: PPUSH
95455: CALL_OW 2
95459: ST_TO_ADDR
95460: GO 95418
95462: POP
95463: POP
// if not tmp then
95464: LD_VAR 0 5
95468: NOT
95469: IFFALSE 95473
// exit ;
95471: GO 95493
// result := SortListByListDesc ( units , tmp ) ;
95473: LD_ADDR_VAR 0 3
95477: PUSH
95478: LD_VAR 0 1
95482: PPUSH
95483: LD_VAR 0 5
95487: PPUSH
95488: CALL_OW 77
95492: ST_TO_ADDR
// end ;
95493: LD_VAR 0 3
95497: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
95498: LD_INT 0
95500: PPUSH
95501: PPUSH
95502: PPUSH
// result := false ;
95503: LD_ADDR_VAR 0 3
95507: PUSH
95508: LD_INT 0
95510: ST_TO_ADDR
// x := GetX ( building ) ;
95511: LD_ADDR_VAR 0 4
95515: PUSH
95516: LD_VAR 0 2
95520: PPUSH
95521: CALL_OW 250
95525: ST_TO_ADDR
// y := GetY ( building ) ;
95526: LD_ADDR_VAR 0 5
95530: PUSH
95531: LD_VAR 0 2
95535: PPUSH
95536: CALL_OW 251
95540: ST_TO_ADDR
// if not building or not x or not y then
95541: LD_VAR 0 2
95545: NOT
95546: PUSH
95547: LD_VAR 0 4
95551: NOT
95552: OR
95553: PUSH
95554: LD_VAR 0 5
95558: NOT
95559: OR
95560: IFFALSE 95564
// exit ;
95562: GO 95656
// if GetTaskList ( unit ) then
95564: LD_VAR 0 1
95568: PPUSH
95569: CALL_OW 437
95573: IFFALSE 95656
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
95575: LD_STRING e
95577: PUSH
95578: LD_VAR 0 1
95582: PPUSH
95583: CALL_OW 437
95587: PUSH
95588: LD_INT 1
95590: ARRAY
95591: PUSH
95592: LD_INT 1
95594: ARRAY
95595: EQUAL
95596: PUSH
95597: LD_VAR 0 4
95601: PUSH
95602: LD_VAR 0 1
95606: PPUSH
95607: CALL_OW 437
95611: PUSH
95612: LD_INT 1
95614: ARRAY
95615: PUSH
95616: LD_INT 2
95618: ARRAY
95619: EQUAL
95620: AND
95621: PUSH
95622: LD_VAR 0 5
95626: PUSH
95627: LD_VAR 0 1
95631: PPUSH
95632: CALL_OW 437
95636: PUSH
95637: LD_INT 1
95639: ARRAY
95640: PUSH
95641: LD_INT 3
95643: ARRAY
95644: EQUAL
95645: AND
95646: IFFALSE 95656
// result := true end ;
95648: LD_ADDR_VAR 0 3
95652: PUSH
95653: LD_INT 1
95655: ST_TO_ADDR
// end ;
95656: LD_VAR 0 3
95660: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
95661: LD_INT 0
95663: PPUSH
// result := false ;
95664: LD_ADDR_VAR 0 4
95668: PUSH
95669: LD_INT 0
95671: ST_TO_ADDR
// if GetTaskList ( unit ) then
95672: LD_VAR 0 1
95676: PPUSH
95677: CALL_OW 437
95681: IFFALSE 95764
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
95683: LD_STRING M
95685: PUSH
95686: LD_VAR 0 1
95690: PPUSH
95691: CALL_OW 437
95695: PUSH
95696: LD_INT 1
95698: ARRAY
95699: PUSH
95700: LD_INT 1
95702: ARRAY
95703: EQUAL
95704: PUSH
95705: LD_VAR 0 2
95709: PUSH
95710: LD_VAR 0 1
95714: PPUSH
95715: CALL_OW 437
95719: PUSH
95720: LD_INT 1
95722: ARRAY
95723: PUSH
95724: LD_INT 2
95726: ARRAY
95727: EQUAL
95728: AND
95729: PUSH
95730: LD_VAR 0 3
95734: PUSH
95735: LD_VAR 0 1
95739: PPUSH
95740: CALL_OW 437
95744: PUSH
95745: LD_INT 1
95747: ARRAY
95748: PUSH
95749: LD_INT 3
95751: ARRAY
95752: EQUAL
95753: AND
95754: IFFALSE 95764
// result := true ;
95756: LD_ADDR_VAR 0 4
95760: PUSH
95761: LD_INT 1
95763: ST_TO_ADDR
// end ; end ;
95764: LD_VAR 0 4
95768: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
95769: LD_INT 0
95771: PPUSH
95772: PPUSH
95773: PPUSH
95774: PPUSH
// if not unit or not area then
95775: LD_VAR 0 1
95779: NOT
95780: PUSH
95781: LD_VAR 0 2
95785: NOT
95786: OR
95787: IFFALSE 95791
// exit ;
95789: GO 95955
// tmp := AreaToList ( area , i ) ;
95791: LD_ADDR_VAR 0 6
95795: PUSH
95796: LD_VAR 0 2
95800: PPUSH
95801: LD_VAR 0 5
95805: PPUSH
95806: CALL_OW 517
95810: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
95811: LD_ADDR_VAR 0 5
95815: PUSH
95816: DOUBLE
95817: LD_INT 1
95819: DEC
95820: ST_TO_ADDR
95821: LD_VAR 0 6
95825: PUSH
95826: LD_INT 1
95828: ARRAY
95829: PUSH
95830: FOR_TO
95831: IFFALSE 95953
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
95833: LD_ADDR_VAR 0 7
95837: PUSH
95838: LD_VAR 0 6
95842: PUSH
95843: LD_INT 1
95845: ARRAY
95846: PUSH
95847: LD_VAR 0 5
95851: ARRAY
95852: PUSH
95853: LD_VAR 0 6
95857: PUSH
95858: LD_INT 2
95860: ARRAY
95861: PUSH
95862: LD_VAR 0 5
95866: ARRAY
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
95872: LD_VAR 0 7
95876: PUSH
95877: LD_INT 1
95879: ARRAY
95880: PPUSH
95881: LD_VAR 0 7
95885: PUSH
95886: LD_INT 2
95888: ARRAY
95889: PPUSH
95890: CALL_OW 428
95894: PUSH
95895: LD_INT 0
95897: EQUAL
95898: IFFALSE 95951
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
95900: LD_VAR 0 1
95904: PPUSH
95905: LD_VAR 0 7
95909: PUSH
95910: LD_INT 1
95912: ARRAY
95913: PPUSH
95914: LD_VAR 0 7
95918: PUSH
95919: LD_INT 2
95921: ARRAY
95922: PPUSH
95923: LD_VAR 0 3
95927: PPUSH
95928: CALL_OW 48
// result := IsPlaced ( unit ) ;
95932: LD_ADDR_VAR 0 4
95936: PUSH
95937: LD_VAR 0 1
95941: PPUSH
95942: CALL_OW 305
95946: ST_TO_ADDR
// exit ;
95947: POP
95948: POP
95949: GO 95955
// end ; end ;
95951: GO 95830
95953: POP
95954: POP
// end ;
95955: LD_VAR 0 4
95959: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
95960: LD_INT 0
95962: PPUSH
95963: PPUSH
95964: PPUSH
// if not side or side > 8 then
95965: LD_VAR 0 1
95969: NOT
95970: PUSH
95971: LD_VAR 0 1
95975: PUSH
95976: LD_INT 8
95978: GREATER
95979: OR
95980: IFFALSE 95984
// exit ;
95982: GO 96171
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
95984: LD_ADDR_VAR 0 4
95988: PUSH
95989: LD_INT 22
95991: PUSH
95992: LD_VAR 0 1
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PUSH
96001: LD_INT 21
96003: PUSH
96004: LD_INT 3
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: PPUSH
96015: CALL_OW 69
96019: ST_TO_ADDR
// if not tmp then
96020: LD_VAR 0 4
96024: NOT
96025: IFFALSE 96029
// exit ;
96027: GO 96171
// enable_addtolog := true ;
96029: LD_ADDR_OWVAR 81
96033: PUSH
96034: LD_INT 1
96036: ST_TO_ADDR
// AddToLog ( [ ) ;
96037: LD_STRING [
96039: PPUSH
96040: CALL_OW 561
// for i in tmp do
96044: LD_ADDR_VAR 0 3
96048: PUSH
96049: LD_VAR 0 4
96053: PUSH
96054: FOR_IN
96055: IFFALSE 96162
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
96057: LD_STRING [
96059: PUSH
96060: LD_VAR 0 3
96064: PPUSH
96065: CALL_OW 266
96069: STR
96070: PUSH
96071: LD_STRING , 
96073: STR
96074: PUSH
96075: LD_VAR 0 3
96079: PPUSH
96080: CALL_OW 250
96084: STR
96085: PUSH
96086: LD_STRING , 
96088: STR
96089: PUSH
96090: LD_VAR 0 3
96094: PPUSH
96095: CALL_OW 251
96099: STR
96100: PUSH
96101: LD_STRING , 
96103: STR
96104: PUSH
96105: LD_VAR 0 3
96109: PPUSH
96110: CALL_OW 254
96114: STR
96115: PUSH
96116: LD_STRING , 
96118: STR
96119: PUSH
96120: LD_VAR 0 3
96124: PPUSH
96125: LD_INT 1
96127: PPUSH
96128: CALL_OW 268
96132: STR
96133: PUSH
96134: LD_STRING , 
96136: STR
96137: PUSH
96138: LD_VAR 0 3
96142: PPUSH
96143: LD_INT 2
96145: PPUSH
96146: CALL_OW 268
96150: STR
96151: PUSH
96152: LD_STRING ],
96154: STR
96155: PPUSH
96156: CALL_OW 561
// end ;
96160: GO 96054
96162: POP
96163: POP
// AddToLog ( ]; ) ;
96164: LD_STRING ];
96166: PPUSH
96167: CALL_OW 561
// end ;
96171: LD_VAR 0 2
96175: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
96176: LD_INT 0
96178: PPUSH
96179: PPUSH
96180: PPUSH
96181: PPUSH
96182: PPUSH
// if not area or not rate or not max then
96183: LD_VAR 0 1
96187: NOT
96188: PUSH
96189: LD_VAR 0 2
96193: NOT
96194: OR
96195: PUSH
96196: LD_VAR 0 4
96200: NOT
96201: OR
96202: IFFALSE 96206
// exit ;
96204: GO 96398
// while 1 do
96206: LD_INT 1
96208: IFFALSE 96398
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
96210: LD_ADDR_VAR 0 9
96214: PUSH
96215: LD_VAR 0 1
96219: PPUSH
96220: LD_INT 1
96222: PPUSH
96223: CALL_OW 287
96227: PUSH
96228: LD_INT 10
96230: MUL
96231: ST_TO_ADDR
// r := rate / 10 ;
96232: LD_ADDR_VAR 0 7
96236: PUSH
96237: LD_VAR 0 2
96241: PUSH
96242: LD_INT 10
96244: DIVREAL
96245: ST_TO_ADDR
// time := 1 1$00 ;
96246: LD_ADDR_VAR 0 8
96250: PUSH
96251: LD_INT 2100
96253: ST_TO_ADDR
// if amount < min then
96254: LD_VAR 0 9
96258: PUSH
96259: LD_VAR 0 3
96263: LESS
96264: IFFALSE 96282
// r := r * 2 else
96266: LD_ADDR_VAR 0 7
96270: PUSH
96271: LD_VAR 0 7
96275: PUSH
96276: LD_INT 2
96278: MUL
96279: ST_TO_ADDR
96280: GO 96308
// if amount > max then
96282: LD_VAR 0 9
96286: PUSH
96287: LD_VAR 0 4
96291: GREATER
96292: IFFALSE 96308
// r := r / 2 ;
96294: LD_ADDR_VAR 0 7
96298: PUSH
96299: LD_VAR 0 7
96303: PUSH
96304: LD_INT 2
96306: DIVREAL
96307: ST_TO_ADDR
// time := time / r ;
96308: LD_ADDR_VAR 0 8
96312: PUSH
96313: LD_VAR 0 8
96317: PUSH
96318: LD_VAR 0 7
96322: DIVREAL
96323: ST_TO_ADDR
// if time < 0 then
96324: LD_VAR 0 8
96328: PUSH
96329: LD_INT 0
96331: LESS
96332: IFFALSE 96349
// time := time * - 1 ;
96334: LD_ADDR_VAR 0 8
96338: PUSH
96339: LD_VAR 0 8
96343: PUSH
96344: LD_INT 1
96346: NEG
96347: MUL
96348: ST_TO_ADDR
// wait ( time ) ;
96349: LD_VAR 0 8
96353: PPUSH
96354: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
96358: LD_INT 35
96360: PPUSH
96361: LD_INT 875
96363: PPUSH
96364: CALL_OW 12
96368: PPUSH
96369: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
96373: LD_INT 1
96375: PPUSH
96376: LD_INT 5
96378: PPUSH
96379: CALL_OW 12
96383: PPUSH
96384: LD_VAR 0 1
96388: PPUSH
96389: LD_INT 1
96391: PPUSH
96392: CALL_OW 55
// end ;
96396: GO 96206
// end ;
96398: LD_VAR 0 5
96402: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
96403: LD_INT 0
96405: PPUSH
96406: PPUSH
96407: PPUSH
96408: PPUSH
96409: PPUSH
96410: PPUSH
96411: PPUSH
96412: PPUSH
// if not turrets or not factories then
96413: LD_VAR 0 1
96417: NOT
96418: PUSH
96419: LD_VAR 0 2
96423: NOT
96424: OR
96425: IFFALSE 96429
// exit ;
96427: GO 96736
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
96429: LD_ADDR_VAR 0 10
96433: PUSH
96434: LD_INT 5
96436: PUSH
96437: LD_INT 6
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: PUSH
96444: LD_INT 2
96446: PUSH
96447: LD_INT 4
96449: PUSH
96450: EMPTY
96451: LIST
96452: LIST
96453: PUSH
96454: LD_INT 3
96456: PUSH
96457: LD_INT 5
96459: PUSH
96460: EMPTY
96461: LIST
96462: LIST
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: LIST
96468: PUSH
96469: LD_INT 24
96471: PUSH
96472: LD_INT 25
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: LD_INT 23
96481: PUSH
96482: LD_INT 27
96484: PUSH
96485: EMPTY
96486: LIST
96487: LIST
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 42
96495: PUSH
96496: LD_INT 43
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PUSH
96503: LD_INT 44
96505: PUSH
96506: LD_INT 46
96508: PUSH
96509: EMPTY
96510: LIST
96511: LIST
96512: PUSH
96513: LD_INT 45
96515: PUSH
96516: LD_INT 47
96518: PUSH
96519: EMPTY
96520: LIST
96521: LIST
96522: PUSH
96523: EMPTY
96524: LIST
96525: LIST
96526: LIST
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: LIST
96532: ST_TO_ADDR
// result := [ ] ;
96533: LD_ADDR_VAR 0 3
96537: PUSH
96538: EMPTY
96539: ST_TO_ADDR
// for i in turrets do
96540: LD_ADDR_VAR 0 4
96544: PUSH
96545: LD_VAR 0 1
96549: PUSH
96550: FOR_IN
96551: IFFALSE 96734
// begin nat := GetNation ( i ) ;
96553: LD_ADDR_VAR 0 7
96557: PUSH
96558: LD_VAR 0 4
96562: PPUSH
96563: CALL_OW 248
96567: ST_TO_ADDR
// weapon := 0 ;
96568: LD_ADDR_VAR 0 8
96572: PUSH
96573: LD_INT 0
96575: ST_TO_ADDR
// if not nat then
96576: LD_VAR 0 7
96580: NOT
96581: IFFALSE 96585
// continue ;
96583: GO 96550
// for j in list [ nat ] do
96585: LD_ADDR_VAR 0 5
96589: PUSH
96590: LD_VAR 0 10
96594: PUSH
96595: LD_VAR 0 7
96599: ARRAY
96600: PUSH
96601: FOR_IN
96602: IFFALSE 96643
// if GetBWeapon ( i ) = j [ 1 ] then
96604: LD_VAR 0 4
96608: PPUSH
96609: CALL_OW 269
96613: PUSH
96614: LD_VAR 0 5
96618: PUSH
96619: LD_INT 1
96621: ARRAY
96622: EQUAL
96623: IFFALSE 96641
// begin weapon := j [ 2 ] ;
96625: LD_ADDR_VAR 0 8
96629: PUSH
96630: LD_VAR 0 5
96634: PUSH
96635: LD_INT 2
96637: ARRAY
96638: ST_TO_ADDR
// break ;
96639: GO 96643
// end ;
96641: GO 96601
96643: POP
96644: POP
// if not weapon then
96645: LD_VAR 0 8
96649: NOT
96650: IFFALSE 96654
// continue ;
96652: GO 96550
// for k in factories do
96654: LD_ADDR_VAR 0 6
96658: PUSH
96659: LD_VAR 0 2
96663: PUSH
96664: FOR_IN
96665: IFFALSE 96730
// begin weapons := AvailableWeaponList ( k ) ;
96667: LD_ADDR_VAR 0 9
96671: PUSH
96672: LD_VAR 0 6
96676: PPUSH
96677: CALL_OW 478
96681: ST_TO_ADDR
// if not weapons then
96682: LD_VAR 0 9
96686: NOT
96687: IFFALSE 96691
// continue ;
96689: GO 96664
// if weapon in weapons then
96691: LD_VAR 0 8
96695: PUSH
96696: LD_VAR 0 9
96700: IN
96701: IFFALSE 96728
// begin result := [ i , weapon ] ;
96703: LD_ADDR_VAR 0 3
96707: PUSH
96708: LD_VAR 0 4
96712: PUSH
96713: LD_VAR 0 8
96717: PUSH
96718: EMPTY
96719: LIST
96720: LIST
96721: ST_TO_ADDR
// exit ;
96722: POP
96723: POP
96724: POP
96725: POP
96726: GO 96736
// end ; end ;
96728: GO 96664
96730: POP
96731: POP
// end ;
96732: GO 96550
96734: POP
96735: POP
// end ;
96736: LD_VAR 0 3
96740: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
96741: LD_INT 0
96743: PPUSH
// if not side or side > 8 then
96744: LD_VAR 0 3
96748: NOT
96749: PUSH
96750: LD_VAR 0 3
96754: PUSH
96755: LD_INT 8
96757: GREATER
96758: OR
96759: IFFALSE 96763
// exit ;
96761: GO 96822
// if not range then
96763: LD_VAR 0 4
96767: NOT
96768: IFFALSE 96779
// range := - 12 ;
96770: LD_ADDR_VAR 0 4
96774: PUSH
96775: LD_INT 12
96777: NEG
96778: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
96779: LD_VAR 0 1
96783: PPUSH
96784: LD_VAR 0 2
96788: PPUSH
96789: LD_VAR 0 3
96793: PPUSH
96794: LD_VAR 0 4
96798: PPUSH
96799: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
96803: LD_VAR 0 1
96807: PPUSH
96808: LD_VAR 0 2
96812: PPUSH
96813: LD_VAR 0 3
96817: PPUSH
96818: CALL_OW 331
// end ;
96822: LD_VAR 0 5
96826: RET
// export function Video ( mode ) ; begin
96827: LD_INT 0
96829: PPUSH
// ingame_video = mode ;
96830: LD_ADDR_OWVAR 52
96834: PUSH
96835: LD_VAR 0 1
96839: ST_TO_ADDR
// interface_hidden = mode ;
96840: LD_ADDR_OWVAR 54
96844: PUSH
96845: LD_VAR 0 1
96849: ST_TO_ADDR
// end ;
96850: LD_VAR 0 2
96854: RET
// export function Join ( array , element ) ; begin
96855: LD_INT 0
96857: PPUSH
// result := Replace ( array , array + 1 , element ) ;
96858: LD_ADDR_VAR 0 3
96862: PUSH
96863: LD_VAR 0 1
96867: PPUSH
96868: LD_VAR 0 1
96872: PUSH
96873: LD_INT 1
96875: PLUS
96876: PPUSH
96877: LD_VAR 0 2
96881: PPUSH
96882: CALL_OW 1
96886: ST_TO_ADDR
// end ;
96887: LD_VAR 0 3
96891: RET
// export function JoinUnion ( array , element ) ; begin
96892: LD_INT 0
96894: PPUSH
// result := array union element ;
96895: LD_ADDR_VAR 0 3
96899: PUSH
96900: LD_VAR 0 1
96904: PUSH
96905: LD_VAR 0 2
96909: UNION
96910: ST_TO_ADDR
// end ;
96911: LD_VAR 0 3
96915: RET
// export function GetBehemoths ( side ) ; begin
96916: LD_INT 0
96918: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
96919: LD_ADDR_VAR 0 2
96923: PUSH
96924: LD_INT 22
96926: PUSH
96927: LD_VAR 0 1
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 31
96938: PUSH
96939: LD_INT 25
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: PUSH
96946: EMPTY
96947: LIST
96948: LIST
96949: PPUSH
96950: CALL_OW 69
96954: ST_TO_ADDR
// end ;
96955: LD_VAR 0 2
96959: RET
// export function Shuffle ( array ) ; var i , index ; begin
96960: LD_INT 0
96962: PPUSH
96963: PPUSH
96964: PPUSH
// result := [ ] ;
96965: LD_ADDR_VAR 0 2
96969: PUSH
96970: EMPTY
96971: ST_TO_ADDR
// if not array then
96972: LD_VAR 0 1
96976: NOT
96977: IFFALSE 96981
// exit ;
96979: GO 97080
// Randomize ;
96981: CALL_OW 10
// for i = array downto 1 do
96985: LD_ADDR_VAR 0 3
96989: PUSH
96990: DOUBLE
96991: LD_VAR 0 1
96995: INC
96996: ST_TO_ADDR
96997: LD_INT 1
96999: PUSH
97000: FOR_DOWNTO
97001: IFFALSE 97078
// begin index := rand ( 1 , array ) ;
97003: LD_ADDR_VAR 0 4
97007: PUSH
97008: LD_INT 1
97010: PPUSH
97011: LD_VAR 0 1
97015: PPUSH
97016: CALL_OW 12
97020: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
97021: LD_ADDR_VAR 0 2
97025: PUSH
97026: LD_VAR 0 2
97030: PPUSH
97031: LD_VAR 0 2
97035: PUSH
97036: LD_INT 1
97038: PLUS
97039: PPUSH
97040: LD_VAR 0 1
97044: PUSH
97045: LD_VAR 0 4
97049: ARRAY
97050: PPUSH
97051: CALL_OW 2
97055: ST_TO_ADDR
// array := Delete ( array , index ) ;
97056: LD_ADDR_VAR 0 1
97060: PUSH
97061: LD_VAR 0 1
97065: PPUSH
97066: LD_VAR 0 4
97070: PPUSH
97071: CALL_OW 3
97075: ST_TO_ADDR
// end ;
97076: GO 97000
97078: POP
97079: POP
// end ;
97080: LD_VAR 0 2
97084: RET
// export function GetBaseMaterials ( base ) ; begin
97085: LD_INT 0
97087: PPUSH
// result := [ 0 , 0 , 0 ] ;
97088: LD_ADDR_VAR 0 2
97092: PUSH
97093: LD_INT 0
97095: PUSH
97096: LD_INT 0
97098: PUSH
97099: LD_INT 0
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: LIST
97106: ST_TO_ADDR
// if not base then
97107: LD_VAR 0 1
97111: NOT
97112: IFFALSE 97116
// exit ;
97114: GO 97165
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
97116: LD_ADDR_VAR 0 2
97120: PUSH
97121: LD_VAR 0 1
97125: PPUSH
97126: LD_INT 1
97128: PPUSH
97129: CALL_OW 275
97133: PUSH
97134: LD_VAR 0 1
97138: PPUSH
97139: LD_INT 2
97141: PPUSH
97142: CALL_OW 275
97146: PUSH
97147: LD_VAR 0 1
97151: PPUSH
97152: LD_INT 3
97154: PPUSH
97155: CALL_OW 275
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: LIST
97164: ST_TO_ADDR
// end ;
97165: LD_VAR 0 2
97169: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
97170: LD_INT 0
97172: PPUSH
97173: PPUSH
// result := array ;
97174: LD_ADDR_VAR 0 3
97178: PUSH
97179: LD_VAR 0 1
97183: ST_TO_ADDR
// if size > 0 then
97184: LD_VAR 0 2
97188: PUSH
97189: LD_INT 0
97191: GREATER
97192: IFFALSE 97238
// for i := array downto size do
97194: LD_ADDR_VAR 0 4
97198: PUSH
97199: DOUBLE
97200: LD_VAR 0 1
97204: INC
97205: ST_TO_ADDR
97206: LD_VAR 0 2
97210: PUSH
97211: FOR_DOWNTO
97212: IFFALSE 97236
// result := Delete ( result , result ) ;
97214: LD_ADDR_VAR 0 3
97218: PUSH
97219: LD_VAR 0 3
97223: PPUSH
97224: LD_VAR 0 3
97228: PPUSH
97229: CALL_OW 3
97233: ST_TO_ADDR
97234: GO 97211
97236: POP
97237: POP
// end ;
97238: LD_VAR 0 3
97242: RET
// export function ComExit ( unit ) ; var tmp ; begin
97243: LD_INT 0
97245: PPUSH
97246: PPUSH
// if not IsInUnit ( unit ) then
97247: LD_VAR 0 1
97251: PPUSH
97252: CALL_OW 310
97256: NOT
97257: IFFALSE 97261
// exit ;
97259: GO 97321
// tmp := IsInUnit ( unit ) ;
97261: LD_ADDR_VAR 0 3
97265: PUSH
97266: LD_VAR 0 1
97270: PPUSH
97271: CALL_OW 310
97275: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
97276: LD_VAR 0 3
97280: PPUSH
97281: CALL_OW 247
97285: PUSH
97286: LD_INT 2
97288: EQUAL
97289: IFFALSE 97302
// ComExitVehicle ( unit ) else
97291: LD_VAR 0 1
97295: PPUSH
97296: CALL_OW 121
97300: GO 97311
// ComExitBuilding ( unit ) ;
97302: LD_VAR 0 1
97306: PPUSH
97307: CALL_OW 122
// result := tmp ;
97311: LD_ADDR_VAR 0 2
97315: PUSH
97316: LD_VAR 0 3
97320: ST_TO_ADDR
// end ;
97321: LD_VAR 0 2
97325: RET
// export function ComExitAll ( units ) ; var i ; begin
97326: LD_INT 0
97328: PPUSH
97329: PPUSH
// if not units then
97330: LD_VAR 0 1
97334: NOT
97335: IFFALSE 97339
// exit ;
97337: GO 97365
// for i in units do
97339: LD_ADDR_VAR 0 3
97343: PUSH
97344: LD_VAR 0 1
97348: PUSH
97349: FOR_IN
97350: IFFALSE 97363
// ComExit ( i ) ;
97352: LD_VAR 0 3
97356: PPUSH
97357: CALL 97243 0 1
97361: GO 97349
97363: POP
97364: POP
// end ;
97365: LD_VAR 0 2
97369: RET
// export function ResetHc ; begin
97370: LD_INT 0
97372: PPUSH
// InitHc ;
97373: CALL_OW 19
// hc_importance := 0 ;
97377: LD_ADDR_OWVAR 32
97381: PUSH
97382: LD_INT 0
97384: ST_TO_ADDR
// end ;
97385: LD_VAR 0 1
97389: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
97390: LD_INT 0
97392: PPUSH
97393: PPUSH
97394: PPUSH
// _x := ( x1 + x2 ) div 2 ;
97395: LD_ADDR_VAR 0 6
97399: PUSH
97400: LD_VAR 0 1
97404: PUSH
97405: LD_VAR 0 3
97409: PLUS
97410: PUSH
97411: LD_INT 2
97413: DIV
97414: ST_TO_ADDR
// if _x < 0 then
97415: LD_VAR 0 6
97419: PUSH
97420: LD_INT 0
97422: LESS
97423: IFFALSE 97440
// _x := _x * - 1 ;
97425: LD_ADDR_VAR 0 6
97429: PUSH
97430: LD_VAR 0 6
97434: PUSH
97435: LD_INT 1
97437: NEG
97438: MUL
97439: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
97440: LD_ADDR_VAR 0 7
97444: PUSH
97445: LD_VAR 0 2
97449: PUSH
97450: LD_VAR 0 4
97454: PLUS
97455: PUSH
97456: LD_INT 2
97458: DIV
97459: ST_TO_ADDR
// if _y < 0 then
97460: LD_VAR 0 7
97464: PUSH
97465: LD_INT 0
97467: LESS
97468: IFFALSE 97485
// _y := _y * - 1 ;
97470: LD_ADDR_VAR 0 7
97474: PUSH
97475: LD_VAR 0 7
97479: PUSH
97480: LD_INT 1
97482: NEG
97483: MUL
97484: ST_TO_ADDR
// result := [ _x , _y ] ;
97485: LD_ADDR_VAR 0 5
97489: PUSH
97490: LD_VAR 0 6
97494: PUSH
97495: LD_VAR 0 7
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: ST_TO_ADDR
// end ;
97504: LD_VAR 0 5
97508: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
97509: LD_INT 0
97511: PPUSH
97512: PPUSH
97513: PPUSH
97514: PPUSH
// task := GetTaskList ( unit ) ;
97515: LD_ADDR_VAR 0 7
97519: PUSH
97520: LD_VAR 0 1
97524: PPUSH
97525: CALL_OW 437
97529: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
97530: LD_VAR 0 7
97534: NOT
97535: PUSH
97536: LD_VAR 0 1
97540: PPUSH
97541: LD_VAR 0 2
97545: PPUSH
97546: CALL_OW 308
97550: NOT
97551: AND
97552: IFFALSE 97556
// exit ;
97554: GO 97674
// if IsInArea ( unit , area ) then
97556: LD_VAR 0 1
97560: PPUSH
97561: LD_VAR 0 2
97565: PPUSH
97566: CALL_OW 308
97570: IFFALSE 97588
// begin ComMoveToArea ( unit , goAway ) ;
97572: LD_VAR 0 1
97576: PPUSH
97577: LD_VAR 0 3
97581: PPUSH
97582: CALL_OW 113
// exit ;
97586: GO 97674
// end ; if task [ 1 ] [ 1 ] <> M then
97588: LD_VAR 0 7
97592: PUSH
97593: LD_INT 1
97595: ARRAY
97596: PUSH
97597: LD_INT 1
97599: ARRAY
97600: PUSH
97601: LD_STRING M
97603: NONEQUAL
97604: IFFALSE 97608
// exit ;
97606: GO 97674
// x := task [ 1 ] [ 2 ] ;
97608: LD_ADDR_VAR 0 5
97612: PUSH
97613: LD_VAR 0 7
97617: PUSH
97618: LD_INT 1
97620: ARRAY
97621: PUSH
97622: LD_INT 2
97624: ARRAY
97625: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
97626: LD_ADDR_VAR 0 6
97630: PUSH
97631: LD_VAR 0 7
97635: PUSH
97636: LD_INT 1
97638: ARRAY
97639: PUSH
97640: LD_INT 3
97642: ARRAY
97643: ST_TO_ADDR
// if InArea ( x , y , area ) then
97644: LD_VAR 0 5
97648: PPUSH
97649: LD_VAR 0 6
97653: PPUSH
97654: LD_VAR 0 2
97658: PPUSH
97659: CALL_OW 309
97663: IFFALSE 97674
// ComStop ( unit ) ;
97665: LD_VAR 0 1
97669: PPUSH
97670: CALL_OW 141
// end ;
97674: LD_VAR 0 4
97678: RET
// export function Abs ( value ) ; begin
97679: LD_INT 0
97681: PPUSH
// result := value ;
97682: LD_ADDR_VAR 0 2
97686: PUSH
97687: LD_VAR 0 1
97691: ST_TO_ADDR
// if value < 0 then
97692: LD_VAR 0 1
97696: PUSH
97697: LD_INT 0
97699: LESS
97700: IFFALSE 97717
// result := value * - 1 ;
97702: LD_ADDR_VAR 0 2
97706: PUSH
97707: LD_VAR 0 1
97711: PUSH
97712: LD_INT 1
97714: NEG
97715: MUL
97716: ST_TO_ADDR
// end ;
97717: LD_VAR 0 2
97721: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
97722: LD_INT 0
97724: PPUSH
97725: PPUSH
97726: PPUSH
97727: PPUSH
97728: PPUSH
97729: PPUSH
97730: PPUSH
97731: PPUSH
// if not unit or not building then
97732: LD_VAR 0 1
97736: NOT
97737: PUSH
97738: LD_VAR 0 2
97742: NOT
97743: OR
97744: IFFALSE 97748
// exit ;
97746: GO 97974
// x := GetX ( building ) ;
97748: LD_ADDR_VAR 0 4
97752: PUSH
97753: LD_VAR 0 2
97757: PPUSH
97758: CALL_OW 250
97762: ST_TO_ADDR
// y := GetY ( building ) ;
97763: LD_ADDR_VAR 0 6
97767: PUSH
97768: LD_VAR 0 2
97772: PPUSH
97773: CALL_OW 251
97777: ST_TO_ADDR
// d := GetDir ( building ) ;
97778: LD_ADDR_VAR 0 8
97782: PUSH
97783: LD_VAR 0 2
97787: PPUSH
97788: CALL_OW 254
97792: ST_TO_ADDR
// r := 4 ;
97793: LD_ADDR_VAR 0 9
97797: PUSH
97798: LD_INT 4
97800: ST_TO_ADDR
// for i := 1 to 5 do
97801: LD_ADDR_VAR 0 10
97805: PUSH
97806: DOUBLE
97807: LD_INT 1
97809: DEC
97810: ST_TO_ADDR
97811: LD_INT 5
97813: PUSH
97814: FOR_TO
97815: IFFALSE 97972
// begin _x := ShiftX ( x , d , r + i ) ;
97817: LD_ADDR_VAR 0 5
97821: PUSH
97822: LD_VAR 0 4
97826: PPUSH
97827: LD_VAR 0 8
97831: PPUSH
97832: LD_VAR 0 9
97836: PUSH
97837: LD_VAR 0 10
97841: PLUS
97842: PPUSH
97843: CALL_OW 272
97847: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
97848: LD_ADDR_VAR 0 7
97852: PUSH
97853: LD_VAR 0 6
97857: PPUSH
97858: LD_VAR 0 8
97862: PPUSH
97863: LD_VAR 0 9
97867: PUSH
97868: LD_VAR 0 10
97872: PLUS
97873: PPUSH
97874: CALL_OW 273
97878: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
97879: LD_VAR 0 5
97883: PPUSH
97884: LD_VAR 0 7
97888: PPUSH
97889: CALL_OW 488
97893: PUSH
97894: LD_VAR 0 5
97898: PPUSH
97899: LD_VAR 0 7
97903: PPUSH
97904: CALL_OW 428
97908: PPUSH
97909: CALL_OW 247
97913: PUSH
97914: LD_INT 3
97916: PUSH
97917: LD_INT 2
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: IN
97924: NOT
97925: AND
97926: IFFALSE 97970
// begin ComMoveXY ( unit , _x , _y ) ;
97928: LD_VAR 0 1
97932: PPUSH
97933: LD_VAR 0 5
97937: PPUSH
97938: LD_VAR 0 7
97942: PPUSH
97943: CALL_OW 111
// result := [ _x , _y ] ;
97947: LD_ADDR_VAR 0 3
97951: PUSH
97952: LD_VAR 0 5
97956: PUSH
97957: LD_VAR 0 7
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: ST_TO_ADDR
// exit ;
97966: POP
97967: POP
97968: GO 97974
// end ; end ;
97970: GO 97814
97972: POP
97973: POP
// end ;
97974: LD_VAR 0 3
97978: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
97979: LD_INT 0
97981: PPUSH
97982: PPUSH
97983: PPUSH
// result := 0 ;
97984: LD_ADDR_VAR 0 3
97988: PUSH
97989: LD_INT 0
97991: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
97992: LD_VAR 0 1
97996: PUSH
97997: LD_INT 0
97999: LESS
98000: PUSH
98001: LD_VAR 0 1
98005: PUSH
98006: LD_INT 8
98008: GREATER
98009: OR
98010: PUSH
98011: LD_VAR 0 2
98015: PUSH
98016: LD_INT 0
98018: LESS
98019: OR
98020: PUSH
98021: LD_VAR 0 2
98025: PUSH
98026: LD_INT 8
98028: GREATER
98029: OR
98030: IFFALSE 98034
// exit ;
98032: GO 98109
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
98034: LD_ADDR_VAR 0 4
98038: PUSH
98039: LD_INT 22
98041: PUSH
98042: LD_VAR 0 2
98046: PUSH
98047: EMPTY
98048: LIST
98049: LIST
98050: PPUSH
98051: CALL_OW 69
98055: PUSH
98056: FOR_IN
98057: IFFALSE 98107
// begin un := UnitShoot ( i ) ;
98059: LD_ADDR_VAR 0 5
98063: PUSH
98064: LD_VAR 0 4
98068: PPUSH
98069: CALL_OW 504
98073: ST_TO_ADDR
// if GetSide ( un ) = side1 then
98074: LD_VAR 0 5
98078: PPUSH
98079: CALL_OW 255
98083: PUSH
98084: LD_VAR 0 1
98088: EQUAL
98089: IFFALSE 98105
// begin result := un ;
98091: LD_ADDR_VAR 0 3
98095: PUSH
98096: LD_VAR 0 5
98100: ST_TO_ADDR
// exit ;
98101: POP
98102: POP
98103: GO 98109
// end ; end ;
98105: GO 98056
98107: POP
98108: POP
// end ;
98109: LD_VAR 0 3
98113: RET
// export function GetCargoBay ( units ) ; begin
98114: LD_INT 0
98116: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
98117: LD_ADDR_VAR 0 2
98121: PUSH
98122: LD_VAR 0 1
98126: PPUSH
98127: LD_INT 2
98129: PUSH
98130: LD_INT 34
98132: PUSH
98133: LD_INT 12
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PUSH
98140: LD_INT 34
98142: PUSH
98143: LD_INT 51
98145: PUSH
98146: EMPTY
98147: LIST
98148: LIST
98149: PUSH
98150: LD_INT 34
98152: PUSH
98153: LD_INT 32
98155: PUSH
98156: EMPTY
98157: LIST
98158: LIST
98159: PUSH
98160: LD_INT 34
98162: PUSH
98163: LD_EXP 76
98167: PUSH
98168: EMPTY
98169: LIST
98170: LIST
98171: PUSH
98172: EMPTY
98173: LIST
98174: LIST
98175: LIST
98176: LIST
98177: LIST
98178: PPUSH
98179: CALL_OW 72
98183: ST_TO_ADDR
// end ; end_of_file
98184: LD_VAR 0 2
98188: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
98189: LD_VAR 0 1
98193: PUSH
98194: LD_INT 200
98196: DOUBLE
98197: GREATEREQUAL
98198: IFFALSE 98206
98200: LD_INT 299
98202: DOUBLE
98203: LESSEQUAL
98204: IFTRUE 98208
98206: GO 98240
98208: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
98209: LD_VAR 0 1
98213: PPUSH
98214: LD_VAR 0 2
98218: PPUSH
98219: LD_VAR 0 3
98223: PPUSH
98224: LD_VAR 0 4
98228: PPUSH
98229: LD_VAR 0 5
98233: PPUSH
98234: CALL 56650 0 5
98238: GO 98317
98240: LD_INT 300
98242: DOUBLE
98243: GREATEREQUAL
98244: IFFALSE 98252
98246: LD_INT 399
98248: DOUBLE
98249: LESSEQUAL
98250: IFTRUE 98254
98252: GO 98316
98254: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
98255: LD_VAR 0 1
98259: PPUSH
98260: LD_VAR 0 2
98264: PPUSH
98265: LD_VAR 0 3
98269: PPUSH
98270: LD_VAR 0 4
98274: PPUSH
98275: LD_VAR 0 5
98279: PPUSH
98280: LD_VAR 0 6
98284: PPUSH
98285: LD_VAR 0 7
98289: PPUSH
98290: LD_VAR 0 8
98294: PPUSH
98295: LD_VAR 0 9
98299: PPUSH
98300: LD_VAR 0 10
98304: PPUSH
98305: LD_VAR 0 11
98309: PPUSH
98310: CALL 54538 0 11
98314: GO 98317
98316: POP
// end ;
98317: PPOPN 11
98319: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
98320: LD_VAR 0 1
98324: PPUSH
98325: LD_VAR 0 2
98329: PPUSH
98330: LD_VAR 0 3
98334: PPUSH
98335: LD_VAR 0 4
98339: PPUSH
98340: LD_VAR 0 5
98344: PPUSH
98345: CALL 56632 0 5
// end ; end_of_file
98349: PPOPN 5
98351: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
98352: LD_VAR 0 1
98356: PPUSH
98357: LD_VAR 0 2
98361: PPUSH
98362: LD_VAR 0 3
98366: PPUSH
98367: LD_VAR 0 4
98371: PPUSH
98372: LD_VAR 0 5
98376: PPUSH
98377: LD_VAR 0 6
98381: PPUSH
98382: CALL 43346 0 6
// end ;
98386: PPOPN 6
98388: END
