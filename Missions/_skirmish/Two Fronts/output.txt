// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7695 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4864 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41681 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42132 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21435 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21371 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18364 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21271 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22285 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21512 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21305 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21338 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18143 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22193 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20450 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21025 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21025 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20822 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20486 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20662 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19946 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20560 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21061 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21801 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21371 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18364 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21271 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21512 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18143 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22193 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20450 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21025 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21025 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20822 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20486 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20662 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19946 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20560 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21061 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21801 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19946 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11651 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22019 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11651 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22019 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11651 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22019 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11651 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22019 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7914 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7914 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7914 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7914 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7914 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18364 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4861
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4859
// begin PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4785: LD_EXP 22
4789: PUSH
4790: LD_INT 1
4792: ARRAY
4793: PPUSH
4794: LD_INT 18
4796: PPUSH
4797: LD_INT 0
4799: PPUSH
4800: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4804: LD_EXP 22
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: LD_INT 107
4815: PPUSH
4816: LD_INT 88
4818: PPUSH
4819: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4823: LD_EXP 22
4827: PUSH
4828: LD_INT 1
4830: ARRAY
4831: PPUSH
4832: LD_INT 3
4834: PPUSH
4835: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4839: LD_ADDR_EXP 22
4843: PUSH
4844: LD_EXP 22
4848: PPUSH
4849: LD_INT 1
4851: PPUSH
4852: CALL_OW 3
4856: ST_TO_ADDR
// end ;
4857: GO 4782
4859: POP
4860: POP
// end ;
4861: PPOPN 1
4863: END
// export function Dialog ; var i ; begin
4864: LD_INT 0
4866: PPUSH
4867: PPUSH
// if not isTest then
4868: LD_EXP 1
4872: NOT
4873: IFFALSE 4895
// case query ( task ) of 1 :
4875: LD_STRING task
4877: PPUSH
4878: CALL_OW 97
4882: PUSH
4883: LD_INT 1
4885: DOUBLE
4886: EQUAL
4887: IFTRUE 4891
4889: GO 4894
4891: POP
// ; end ;
4892: GO 4895
4894: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4895: LD_INT 105
4897: PPUSH
4898: LD_INT 84
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 30
4906: NEG
4907: PPUSH
4908: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4912: LD_INT 105
4914: PPUSH
4915: LD_INT 84
4917: PPUSH
4918: LD_INT 3
4920: PPUSH
4921: CALL_OW 331
// InGameOn ;
4925: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4929: LD_INT 128
4931: PPUSH
4932: LD_INT 64
4934: PPUSH
4935: CALL_OW 86
// if isTest then
4939: LD_EXP 1
4943: IFFALSE 4953
// dialogue_skipped := true ;
4945: LD_ADDR_OWVAR 59
4949: PUSH
4950: LD_INT 1
4952: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4953: LD_EXP 24
4957: PPUSH
4958: LD_STRING DR1
4960: PPUSH
4961: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4965: LD_EXP 24
4969: PPUSH
4970: LD_STRING DR2
4972: PPUSH
4973: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4977: LD_EXP 24
4981: PPUSH
4982: LD_STRING DR3
4984: PPUSH
4985: CALL_OW 94
// InGameOff ;
4989: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4993: LD_STRING C1
4995: PPUSH
4996: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5000: LD_INT 35
5002: PPUSH
5003: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5007: LD_INT 9
5009: PPUSH
5010: LD_INT 22
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 70
5024: IFFALSE 5000
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: LD_INT 9
5033: PPUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 6
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL_OW 70
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5066
// SetSide ( i , 3 ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_INT 3
5059: PPUSH
5060: CALL_OW 235
5064: GO 5049
5066: POP
5067: POP
// if not isTest then
5068: LD_EXP 1
5072: NOT
5073: IFFALSE 5095
// case query ( support ) of 1 :
5075: LD_STRING support
5077: PPUSH
5078: CALL_OW 97
5082: PUSH
5083: LD_INT 1
5085: DOUBLE
5086: EQUAL
5087: IFTRUE 5091
5089: GO 5094
5091: POP
// ; end ;
5092: GO 5095
5094: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5095: LD_INT 3
5097: PPUSH
5098: LD_INT 12
5100: PPUSH
5101: LD_INT 2
5103: PPUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 30
5116: PUSH
5117: LD_INT 0
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: LD_INT 1
5135: ARRAY
5136: PPUSH
5137: CALL_OW 468
// if player_com = stolypin then
5141: LD_EXP 23
5145: PUSH
5146: LD_EXP 21
5150: EQUAL
5151: IFFALSE 5180
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5153: LD_INT 18
5155: PPUSH
5156: LD_INT 3
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: LD_INT 2
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: PUSH
5170: LD_OWVAR 67
5174: ARRAY
5175: PPUSH
5176: CALL 6592 0 2
// end ;
5180: LD_VAR 0 1
5184: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5185: LD_EXP 11
5189: PUSH
5190: LD_OWVAR 1
5194: PUSH
5195: LD_INT 31500
5197: LESS
5198: AND
5199: IFFALSE 5367
// case query ( call1 ) of 1 :
5201: LD_STRING call1
5203: PPUSH
5204: CALL_OW 97
5208: PUSH
5209: LD_INT 1
5211: DOUBLE
5212: EQUAL
5213: IFTRUE 5217
5215: GO 5355
5217: POP
// begin callUsed := true ;
5218: LD_ADDR_EXP 3
5222: PUSH
5223: LD_INT 1
5225: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5226: LD_INT 3
5228: PPUSH
5229: LD_INT 12
5231: PPUSH
5232: LD_INT 1
5234: PPUSH
5235: LD_INT 1
5237: PPUSH
5238: CALL_OW 468
// call := false ;
5242: LD_ADDR_EXP 11
5246: PUSH
5247: LD_INT 0
5249: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5250: LD_EXP 24
5254: PPUSH
5255: LD_STRING DR6
5257: PPUSH
5258: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5262: LD_INT 6300
5264: PPUSH
5265: LD_INT 8400
5267: PPUSH
5268: CALL_OW 12
5272: PPUSH
5273: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5277: LD_INT 18
5279: PUSH
5280: LD_INT 19
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 1
5289: PPUSH
5290: LD_INT 2
5292: PPUSH
5293: CALL_OW 12
5297: ARRAY
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: LD_INT 2
5304: PPUSH
5305: CALL_OW 12
5309: PPUSH
5310: CALL 6592 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5314: LD_INT 25200
5316: PPUSH
5317: LD_INT 35700
5319: PPUSH
5320: CALL_OW 12
5324: PPUSH
5325: CALL_OW 67
// call := true ;
5329: LD_ADDR_EXP 11
5333: PUSH
5334: LD_INT 1
5336: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 12
5342: PPUSH
5343: LD_INT 2
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 468
// end ; 2 :
5353: GO 5367
5355: LD_INT 2
5357: DOUBLE
5358: EQUAL
5359: IFTRUE 5363
5361: GO 5366
5363: POP
// ; end ;
5364: GO 5367
5366: POP
// if call and tick >= 15 15$00 then
5367: LD_EXP 11
5371: PUSH
5372: LD_OWVAR 1
5376: PUSH
5377: LD_INT 31500
5379: GREATEREQUAL
5380: AND
5381: IFFALSE 5820
// case query ( call2 ) of 1 :
5383: LD_STRING call2
5385: PPUSH
5386: CALL_OW 97
5390: PUSH
5391: LD_INT 1
5393: DOUBLE
5394: EQUAL
5395: IFTRUE 5399
5397: GO 5641
5399: POP
// begin callUsed := true ;
5400: LD_ADDR_EXP 3
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// call := false ;
5408: LD_ADDR_EXP 11
5412: PUSH
5413: LD_INT 0
5415: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5416: LD_INT 1
5418: PPUSH
5419: LD_INT 21
5421: PUSH
5422: LD_INT 3
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PPUSH
5429: CALL 11651 0 2
5433: PUSH
5434: LD_INT 4
5436: PPUSH
5437: LD_INT 21
5439: PUSH
5440: LD_INT 3
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: PPUSH
5447: CALL 11651 0 2
5451: AND
5452: IFFALSE 5500
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5454: LD_INT 18
5456: PUSH
5457: LD_INT 19
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PUSH
5464: LD_INT 1
5466: PPUSH
5467: LD_INT 2
5469: PPUSH
5470: CALL_OW 12
5474: ARRAY
5475: PPUSH
5476: LD_INT 5
5478: PUSH
5479: LD_INT 4
5481: PUSH
5482: LD_INT 4
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_OWVAR 67
5494: ARRAY
5495: PPUSH
5496: CALL 6353 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5500: LD_INT 1
5502: PPUSH
5503: LD_INT 21
5505: PUSH
5506: LD_INT 3
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PPUSH
5513: CALL 11651 0 2
5517: PUSH
5518: LD_INT 0
5520: EQUAL
5521: IFFALSE 5550
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5523: LD_INT 19
5525: PPUSH
5526: LD_INT 5
5528: PUSH
5529: LD_INT 4
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: LIST
5539: PUSH
5540: LD_OWVAR 67
5544: ARRAY
5545: PPUSH
5546: CALL 6353 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5550: LD_INT 4
5552: PPUSH
5553: LD_INT 21
5555: PUSH
5556: LD_INT 3
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 11651 0 2
5567: PUSH
5568: LD_INT 0
5570: EQUAL
5571: IFFALSE 5600
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5573: LD_INT 18
5575: PPUSH
5576: LD_INT 5
5578: PUSH
5579: LD_INT 4
5581: PUSH
5582: LD_INT 4
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_OWVAR 67
5594: ARRAY
5595: PPUSH
5596: CALL 6353 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5600: LD_INT 10500
5602: PPUSH
5603: LD_INT 23100
5605: PPUSH
5606: CALL_OW 12
5610: PPUSH
5611: CALL_OW 67
// call := true ;
5615: LD_ADDR_EXP 11
5619: PUSH
5620: LD_INT 1
5622: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5623: LD_INT 3
5625: PPUSH
5626: LD_INT 12
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: LD_INT 1
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5820
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5808
5649: POP
// begin callUsed := true ;
5650: LD_ADDR_EXP 3
5654: PUSH
5655: LD_INT 1
5657: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5658: LD_INT 3
5660: PPUSH
5661: LD_INT 12
5663: PPUSH
5664: LD_INT 1
5666: PPUSH
5667: LD_INT 1
5669: PPUSH
5670: CALL_OW 468
// call := false ;
5674: LD_ADDR_EXP 11
5678: PUSH
5679: LD_INT 0
5681: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5682: LD_EXP 24
5686: PPUSH
5687: LD_STRING DR6
5689: PPUSH
5690: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5694: LD_INT 6300
5696: PPUSH
5697: LD_INT 8400
5699: PPUSH
5700: CALL_OW 12
5704: PPUSH
5705: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5709: LD_INT 18
5711: PUSH
5712: LD_INT 19
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 1
5721: PPUSH
5722: LD_INT 2
5724: PPUSH
5725: CALL_OW 12
5729: ARRAY
5730: PPUSH
5731: LD_INT 3
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 2
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: LIST
5744: PUSH
5745: LD_OWVAR 67
5749: ARRAY
5750: PUSH
5751: LD_INT 0
5753: PPUSH
5754: LD_INT 1
5756: PPUSH
5757: CALL_OW 12
5761: MINUS
5762: PPUSH
5763: CALL 6592 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5767: LD_INT 35700
5769: PPUSH
5770: LD_INT 44100
5772: PPUSH
5773: CALL_OW 12
5777: PPUSH
5778: CALL_OW 67
// call := true ;
5782: LD_ADDR_EXP 11
5786: PUSH
5787: LD_INT 1
5789: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 12
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: LD_INT 1
5801: PPUSH
5802: CALL_OW 468
// end ; 3 :
5806: GO 5820
5808: LD_INT 3
5810: DOUBLE
5811: EQUAL
5812: IFTRUE 5816
5814: GO 5819
5816: POP
// ; end ;
5817: GO 5820
5819: POP
// end ;
5820: PPOPN 4
5822: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5823: LD_INT 22
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 21
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: PUSH
5852: LD_INT 0
5854: EQUAL
5855: PUSH
5856: LD_INT 22
5858: PUSH
5859: LD_INT 4
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PUSH
5866: LD_INT 21
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: PUSH
5885: LD_INT 0
5887: EQUAL
5888: AND
5889: IFFALSE 6193
5891: GO 5893
5893: DISABLE
// begin DialogueOn ;
5894: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5898: LD_EXP 24
5902: PPUSH
5903: LD_STRING DR7
5905: PPUSH
5906: CALL_OW 94
// case player_com of Gorki :
5910: LD_EXP 23
5914: PUSH
5915: LD_EXP 20
5919: DOUBLE
5920: EQUAL
5921: IFTRUE 5925
5923: GO 5935
5925: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5926: LD_STRING ACH_GORKI
5928: PPUSH
5929: CALL_OW 543
5933: GO 5996
5935: LD_EXP 21
5939: DOUBLE
5940: EQUAL
5941: IFTRUE 5945
5943: GO 5955
5945: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5946: LD_STRING ACH_STOLYP
5948: PPUSH
5949: CALL_OW 543
5953: GO 5996
5955: LD_EXP 19
5959: DOUBLE
5960: EQUAL
5961: IFTRUE 5965
5963: GO 5975
5965: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5966: LD_STRING ACH_DAVIDOV
5968: PPUSH
5969: CALL_OW 543
5973: GO 5996
5975: LD_EXP 18
5979: DOUBLE
5980: EQUAL
5981: IFTRUE 5985
5983: GO 5995
5985: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
5986: LD_STRING ACH_GLADKOV
5988: PPUSH
5989: CALL_OW 543
5993: GO 5996
5995: POP
// if not callUsed then
5996: LD_EXP 3
6000: NOT
6001: IFFALSE 6010
// SetAchievement ( ACH_NOSUPP ) ;
6003: LD_STRING ACH_NOSUPP
6005: PPUSH
6006: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6010: LD_OWVAR 1
6014: PUSH
6015: LD_INT 116550
6017: PUSH
6018: LD_INT 95550
6020: PUSH
6021: LD_INT 89250
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_OWVAR 67
6033: ARRAY
6034: LESS
6035: IFFALSE 6049
// AddMedal ( med1 , 1 ) else
6037: LD_STRING med1
6039: PPUSH
6040: LD_INT 1
6042: PPUSH
6043: CALL_OW 101
6047: GO 6060
// AddMedal ( med1 , - 1 ) ;
6049: LD_STRING med1
6051: PPUSH
6052: LD_INT 1
6054: NEG
6055: PPUSH
6056: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6060: LD_INT 81
6062: PUSH
6063: LD_INT 3
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: LD_INT 21
6072: PUSH
6073: LD_INT 3
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 69
6088: PUSH
6089: LD_INT 0
6091: EQUAL
6092: IFFALSE 6106
// AddMedal ( med3 , 1 ) else
6094: LD_STRING med3
6096: PPUSH
6097: LD_INT 1
6099: PPUSH
6100: CALL_OW 101
6104: GO 6117
// AddMedal ( med3 , - 1 ) ;
6106: LD_STRING med3
6108: PPUSH
6109: LD_INT 1
6111: NEG
6112: PPUSH
6113: CALL_OW 101
// if player_loss = 0 then
6117: LD_EXP 10
6121: PUSH
6122: LD_INT 0
6124: EQUAL
6125: IFFALSE 6139
// AddMedal ( med2 , 1 ) else
6127: LD_STRING med2
6129: PPUSH
6130: LD_INT 1
6132: PPUSH
6133: CALL_OW 101
6137: GO 6182
// if player_loss > 0 and player_loss < 3 then
6139: LD_EXP 10
6143: PUSH
6144: LD_INT 0
6146: GREATER
6147: PUSH
6148: LD_EXP 10
6152: PUSH
6153: LD_INT 3
6155: LESS
6156: AND
6157: IFFALSE 6171
// AddMedal ( med2 , 2 ) else
6159: LD_STRING med2
6161: PPUSH
6162: LD_INT 2
6164: PPUSH
6165: CALL_OW 101
6169: GO 6182
// AddMedal ( med2 , - 1 ) ;
6171: LD_STRING med2
6173: PPUSH
6174: LD_INT 1
6176: NEG
6177: PPUSH
6178: CALL_OW 101
// GiveMedals ( MAIN ) ;
6182: LD_STRING MAIN
6184: PPUSH
6185: CALL_OW 102
// YouWin ;
6189: CALL_OW 103
// end ;
6193: END
// every 0 0$01 trigger IsDead ( player_com ) do
6194: LD_EXP 23
6198: PPUSH
6199: CALL_OW 301
6203: IFFALSE 6270
6205: GO 6207
6207: DISABLE
// begin if IsLive ( Houten ) then
6208: LD_EXP 4
6212: PPUSH
6213: CALL_OW 300
6217: IFFALSE 6233
// SayRadio ( Houten , DJ5 ) else
6219: LD_EXP 4
6223: PPUSH
6224: LD_STRING DJ5
6226: PPUSH
6227: CALL_OW 94
6231: GO 6256
// if IsLive ( Brown ) then
6233: LD_EXP 5
6237: PPUSH
6238: CALL_OW 300
6242: IFFALSE 6256
// SayRadio ( Brown , DS5 ) ;
6244: LD_EXP 5
6248: PPUSH
6249: LD_STRING DS5
6251: PPUSH
6252: CALL_OW 94
// Wait ( 0 0$01 ) ;
6256: LD_INT 35
6258: PPUSH
6259: CALL_OW 67
// YouLost ( dead ) ;
6263: LD_STRING dead
6265: PPUSH
6266: CALL_OW 104
// end ;
6270: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 301
6278: PUSH
6279: LD_EXP 1
6283: NOT
6284: AND
6285: IFFALSE 6352
6287: GO 6289
6289: DISABLE
// begin if IsLive ( Brown ) then
6290: LD_EXP 5
6294: PPUSH
6295: CALL_OW 300
6299: IFFALSE 6315
// SayRadio ( Brown , DS5 ) else
6301: LD_EXP 5
6305: PPUSH
6306: LD_STRING DS5
6308: PPUSH
6309: CALL_OW 94
6313: GO 6338
// if IsLive ( Houten ) then
6315: LD_EXP 4
6319: PPUSH
6320: CALL_OW 300
6324: IFFALSE 6338
// SayRadio ( Houten , DJ5 ) ;
6326: LD_EXP 4
6330: PPUSH
6331: LD_STRING DJ5
6333: PPUSH
6334: CALL_OW 94
// Wait ( 0 0$01 ) ;
6338: LD_INT 35
6340: PPUSH
6341: CALL_OW 67
// YouLost ( depot ) ;
6345: LD_STRING depot
6347: PPUSH
6348: CALL_OW 104
// end ;
6352: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6353: LD_INT 0
6355: PPUSH
6356: PPUSH
6357: PPUSH
// for i = 1 to n do
6358: LD_ADDR_VAR 0 4
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_VAR 0 2
6372: PUSH
6373: FOR_TO
6374: IFFALSE 6577
// begin uc_side := 6 ;
6376: LD_ADDR_OWVAR 20
6380: PUSH
6381: LD_INT 6
6383: ST_TO_ADDR
// uc_nation := 3 ;
6384: LD_ADDR_OWVAR 21
6388: PUSH
6389: LD_INT 3
6391: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6392: LD_ADDR_OWVAR 37
6396: PUSH
6397: LD_INT 23
6399: PUSH
6400: LD_INT 22
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: ST_TO_ADDR
// vc_control := control_computer ;
6419: LD_ADDR_OWVAR 38
6423: PUSH
6424: LD_INT 3
6426: ST_TO_ADDR
// vc_engine := engine_siberite ;
6427: LD_ADDR_OWVAR 39
6431: PUSH
6432: LD_INT 3
6434: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6435: LD_ADDR_OWVAR 40
6439: PUSH
6440: LD_INT 43
6442: PUSH
6443: LD_INT 44
6445: PUSH
6446: LD_INT 44
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 1
6456: PPUSH
6457: LD_INT 3
6459: PPUSH
6460: CALL_OW 12
6464: ARRAY
6465: ST_TO_ADDR
// un := CreateVehicle ;
6466: LD_ADDR_VAR 0 5
6470: PUSH
6471: CALL_OW 45
6475: ST_TO_ADDR
// case area of east_arr :
6476: LD_VAR 0 1
6480: PUSH
6481: LD_INT 18
6483: DOUBLE
6484: EQUAL
6485: IFTRUE 6489
6487: GO 6524
6489: POP
// begin PlaceUnitArea ( un , area , false ) ;
6490: LD_VAR 0 5
6494: PPUSH
6495: LD_VAR 0 1
6499: PPUSH
6500: LD_INT 0
6502: PPUSH
6503: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6507: LD_VAR 0 5
6511: PPUSH
6512: LD_INT 79
6514: PPUSH
6515: LD_INT 33
6517: PPUSH
6518: CALL_OW 111
// end ; south_arr :
6522: GO 6568
6524: LD_INT 19
6526: DOUBLE
6527: EQUAL
6528: IFTRUE 6532
6530: GO 6567
6532: POP
// begin PlaceUnitArea ( un , area , false ) ;
6533: LD_VAR 0 5
6537: PPUSH
6538: LD_VAR 0 1
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_INT 131
6557: PPUSH
6558: LD_INT 148
6560: PPUSH
6561: CALL_OW 111
// end ; end ;
6565: GO 6568
6567: POP
// Wait ( 0 0$02 ) ;
6568: LD_INT 70
6570: PPUSH
6571: CALL_OW 67
// end ;
6575: GO 6373
6577: POP
6578: POP
// pink_attack := true ;
6579: LD_ADDR_EXP 12
6583: PUSH
6584: LD_INT 1
6586: ST_TO_ADDR
// end ;
6587: LD_VAR 0 3
6591: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
// for i = 1 to n do
6597: LD_ADDR_VAR 0 4
6601: PUSH
6602: DOUBLE
6603: LD_INT 1
6605: DEC
6606: ST_TO_ADDR
6607: LD_VAR 0 2
6611: PUSH
6612: FOR_TO
6613: IFFALSE 6839
// begin uc_side := 6 ;
6615: LD_ADDR_OWVAR 20
6619: PUSH
6620: LD_INT 6
6622: ST_TO_ADDR
// uc_nation := 3 ;
6623: LD_ADDR_OWVAR 21
6627: PUSH
6628: LD_INT 3
6630: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6631: LD_INT 0
6633: PPUSH
6634: LD_INT 3
6636: PPUSH
6637: LD_INT 4
6639: PPUSH
6640: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6644: LD_ADDR_OWVAR 37
6648: PUSH
6649: LD_INT 22
6651: ST_TO_ADDR
// vc_control := control_manual ;
6652: LD_ADDR_OWVAR 38
6656: PUSH
6657: LD_INT 1
6659: ST_TO_ADDR
// vc_engine := engine_combustion ;
6660: LD_ADDR_OWVAR 39
6664: PUSH
6665: LD_INT 1
6667: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6668: LD_ADDR_OWVAR 40
6672: PUSH
6673: LD_INT 51
6675: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6676: LD_ADDR_OWVAR 41
6680: PUSH
6681: LD_INT 50
6683: ST_TO_ADDR
// un := CreateVehicle ;
6684: LD_ADDR_VAR 0 5
6688: PUSH
6689: CALL_OW 45
6693: ST_TO_ADDR
// case area of east_arr :
6694: LD_VAR 0 1
6698: PUSH
6699: LD_INT 18
6701: DOUBLE
6702: EQUAL
6703: IFTRUE 6707
6705: GO 6722
6707: POP
// SetDir ( un , 4 ) ; south_arr :
6708: LD_VAR 0 5
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: CALL_OW 233
6720: GO 6746
6722: LD_INT 19
6724: DOUBLE
6725: EQUAL
6726: IFTRUE 6730
6728: GO 6745
6730: POP
// SetDir ( un , 5 ) ; end ;
6731: LD_VAR 0 5
6735: PPUSH
6736: LD_INT 5
6738: PPUSH
6739: CALL_OW 233
6743: GO 6746
6745: POP
// PlaceUnitArea ( un , area , false ) ;
6746: LD_VAR 0 5
6750: PPUSH
6751: LD_VAR 0 1
6755: PPUSH
6756: LD_INT 0
6758: PPUSH
6759: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6763: CALL_OW 44
6767: PPUSH
6768: LD_VAR 0 5
6772: PPUSH
6773: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6777: LD_VAR 0 5
6781: PPUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 100
6787: PPUSH
6788: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6792: LD_VAR 0 5
6796: PPUSH
6797: LD_INT 106
6799: PPUSH
6800: LD_INT 88
6802: PPUSH
6803: CALL_OW 111
// AddComUnload ( un ) ;
6807: LD_VAR 0 5
6811: PPUSH
6812: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6816: LD_VAR 0 5
6820: PPUSH
6821: LD_VAR 0 1
6825: PPUSH
6826: CALL_OW 173
// Wait ( 0 0$02 ) ;
6830: LD_INT 70
6832: PPUSH
6833: CALL_OW 67
// end ;
6837: GO 6612
6839: POP
6840: POP
// Wait ( 0 0$05 ) ;
6841: LD_INT 175
6843: PPUSH
6844: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6848: LD_INT 6
6850: PPUSH
6851: LD_INT 34
6853: PUSH
6854: LD_INT 51
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL 11651 0 2
6865: IFFALSE 7053
// begin wait ( 0 0$01 ) ;
6867: LD_INT 35
6869: PPUSH
6870: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6874: LD_ADDR_VAR 0 4
6878: PUSH
6879: LD_INT 6
6881: PPUSH
6882: LD_INT 34
6884: PUSH
6885: LD_INT 51
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: PPUSH
6892: CALL 11651 0 2
6896: PUSH
6897: FOR_IN
6898: IFFALSE 7049
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6900: LD_VAR 0 4
6904: PPUSH
6905: LD_INT 9
6907: PPUSH
6908: CALL_OW 308
6912: PUSH
6913: LD_VAR 0 4
6917: PPUSH
6918: CALL 31773 0 1
6922: PPUSH
6923: CALL_OW 258
6927: PUSH
6928: LD_INT 1
6930: EQUAL
6931: AND
6932: PUSH
6933: LD_EXP 9
6937: AND
6938: IFFALSE 6965
// begin Say ( GetDriver ( i ) , Dtran ) ;
6940: LD_VAR 0 4
6944: PPUSH
6945: CALL 31773 0 1
6949: PPUSH
6950: LD_STRING Dtran
6952: PPUSH
6953: CALL_OW 88
// dialog_trans := false ;
6957: LD_ADDR_EXP 9
6961: PUSH
6962: LD_INT 0
6964: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6965: LD_VAR 0 4
6969: PPUSH
6970: CALL_OW 316
6974: IFFALSE 6990
// ComMoveToArea ( i , area ) ;
6976: LD_VAR 0 4
6980: PPUSH
6981: LD_VAR 0 1
6985: PPUSH
6986: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6990: LD_VAR 0 4
6994: PPUSH
6995: LD_VAR 0 1
6999: PPUSH
7000: CALL_OW 308
7004: PUSH
7005: LD_VAR 0 4
7009: PPUSH
7010: LD_INT 1
7012: PPUSH
7013: CALL_OW 289
7017: PUSH
7018: LD_INT 0
7020: EQUAL
7021: AND
7022: IFFALSE 7047
// begin RemoveUnit ( GetDriver ( i ) ) ;
7024: LD_VAR 0 4
7028: PPUSH
7029: CALL 31773 0 1
7033: PPUSH
7034: CALL_OW 64
// RemoveUnit ( i ) ;
7038: LD_VAR 0 4
7042: PPUSH
7043: CALL_OW 64
// end ; end ;
7047: GO 6897
7049: POP
7050: POP
// end ;
7051: GO 6848
// end ;
7053: LD_VAR 0 3
7057: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7058: LD_INT 0
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
// if isTest then
7064: LD_EXP 1
7068: IFFALSE 7072
// exit ;
7070: GO 7517
// for i = 1 to n do
7072: LD_ADDR_VAR 0 4
7076: PUSH
7077: DOUBLE
7078: LD_INT 1
7080: DEC
7081: ST_TO_ADDR
7082: LD_VAR 0 2
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7376
// begin uc_side := 8 ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_INT 8
7097: ST_TO_ADDR
// uc_nation := 1 ;
7098: LD_ADDR_OWVAR 21
7102: PUSH
7103: LD_INT 1
7105: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7106: LD_ADDR_VAR 0 6
7110: PUSH
7111: LD_INT 3
7113: PUSH
7114: LD_INT 4
7116: PUSH
7117: LD_INT 4
7119: PUSH
7120: EMPTY
7121: LIST
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 1
7127: PPUSH
7128: LD_OWVAR 67
7132: PPUSH
7133: CALL_OW 12
7137: ARRAY
7138: ST_TO_ADDR
// vc_chassis := ch ;
7139: LD_ADDR_OWVAR 37
7143: PUSH
7144: LD_VAR 0 6
7148: ST_TO_ADDR
// vc_control := control_computer ;
7149: LD_ADDR_OWVAR 38
7153: PUSH
7154: LD_INT 3
7156: ST_TO_ADDR
// vc_engine := engine_combustion ;
7157: LD_ADDR_OWVAR 39
7161: PUSH
7162: LD_INT 1
7164: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7165: LD_OWVAR 1
7169: PUSH
7170: LD_INT 42000
7172: PUSH
7173: LD_INT 33600
7175: PUSH
7176: LD_INT 29400
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: LIST
7183: PUSH
7184: LD_OWVAR 67
7188: ARRAY
7189: LESS
7190: IFFALSE 7221
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7192: LD_ADDR_OWVAR 40
7196: PUSH
7197: LD_INT 3
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 1
7209: PPUSH
7210: LD_INT 2
7212: PPUSH
7213: CALL_OW 12
7217: ARRAY
7218: ST_TO_ADDR
7219: GO 7317
// if ch = us_medium_tracked then
7221: LD_VAR 0 6
7225: PUSH
7226: LD_INT 3
7228: EQUAL
7229: IFFALSE 7276
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7231: LD_ADDR_OWVAR 40
7235: PUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 4
7241: PUSH
7242: LD_INT 5
7244: PUSH
7245: LD_INT 7
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: LIST
7252: LIST
7253: PUSH
7254: LD_OWVAR 67
7258: PPUSH
7259: LD_OWVAR 67
7263: PUSH
7264: LD_INT 1
7266: PLUS
7267: PPUSH
7268: CALL_OW 12
7272: ARRAY
7273: ST_TO_ADDR
7274: GO 7317
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7276: LD_ADDR_OWVAR 40
7280: PUSH
7281: LD_INT 5
7283: PUSH
7284: LD_INT 6
7286: PUSH
7287: LD_INT 7
7289: PUSH
7290: LD_INT 7
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: LIST
7297: LIST
7298: PUSH
7299: LD_INT 1
7301: PPUSH
7302: LD_OWVAR 67
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PPUSH
7311: CALL_OW 12
7315: ARRAY
7316: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7317: LD_ADDR_OWVAR 41
7321: PUSH
7322: LD_INT 70
7324: ST_TO_ADDR
// un := CreateVehicle ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: CALL_OW 45
7334: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7335: LD_VAR 0 5
7339: PPUSH
7340: LD_VAR 0 1
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7352: LD_VAR 0 5
7356: PPUSH
7357: LD_INT 65
7359: PPUSH
7360: LD_INT 9
7362: PPUSH
7363: CALL_OW 111
// Wait ( 0 0$02 ) ;
7367: LD_INT 70
7369: PPUSH
7370: CALL_OW 67
// end ;
7374: GO 7087
7376: POP
7377: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7378: LD_INT 90
7380: PUSH
7381: LD_INT 80
7383: PUSH
7384: LD_INT 70
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: PUSH
7392: LD_OWVAR 67
7396: ARRAY
7397: PPUSH
7398: CALL_OW 13
7402: IFFALSE 7509
// begin uc_side := 8 ;
7404: LD_ADDR_OWVAR 20
7408: PUSH
7409: LD_INT 8
7411: ST_TO_ADDR
// uc_nation := 1 ;
7412: LD_ADDR_OWVAR 21
7416: PUSH
7417: LD_INT 1
7419: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7420: LD_ADDR_OWVAR 37
7424: PUSH
7425: LD_INT 4
7427: ST_TO_ADDR
// vc_control := control_computer ;
7428: LD_ADDR_OWVAR 38
7432: PUSH
7433: LD_INT 3
7435: ST_TO_ADDR
// vc_engine := engine_combustion ;
7436: LD_ADDR_OWVAR 39
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7444: LD_ADDR_OWVAR 40
7448: PUSH
7449: LD_INT 14
7451: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7452: LD_ADDR_OWVAR 41
7456: PUSH
7457: LD_INT 70
7459: ST_TO_ADDR
// un := CreateVehicle ;
7460: LD_ADDR_VAR 0 5
7464: PUSH
7465: CALL_OW 45
7469: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7470: LD_VAR 0 5
7474: PPUSH
7475: LD_VAR 0 1
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7487: LD_VAR 0 5
7491: PPUSH
7492: LD_INT 65
7494: PPUSH
7495: LD_INT 9
7497: PPUSH
7498: CALL_OW 111
// Wait ( 0 0$02 ) ;
7502: LD_INT 70
7504: PPUSH
7505: CALL_OW 67
// end ; alfa_support := true ;
7509: LD_ADDR_EXP 13
7513: PUSH
7514: LD_INT 1
7516: ST_TO_ADDR
// end ;
7517: LD_VAR 0 3
7521: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7522: LD_OWVAR 1
7526: PUSH
7527: LD_INT 25200
7529: PUSH
7530: LD_INT 23100
7532: PUSH
7533: LD_INT 21000
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: LD_OWVAR 67
7545: ARRAY
7546: GREATER
7547: IFFALSE 7692
7549: GO 7551
7551: DISABLE
7552: LD_INT 0
7554: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_INT 3
7562: PUSH
7563: LD_INT 4
7565: PUSH
7566: LD_INT 5
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_OWVAR 67
7578: ARRAY
7579: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7580: LD_INT 1050
7582: PPUSH
7583: LD_INT 4200
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7595: LD_INT 20
7597: PPUSH
7598: LD_VAR 0 1
7602: PPUSH
7603: CALL 7058 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7607: LD_INT 22
7609: PUSH
7610: LD_INT 8
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PPUSH
7617: CALL_OW 69
7621: IFFALSE 7635
// SayRadio ( Popov , DR5 ) ;
7623: LD_EXP 24
7627: PPUSH
7628: LD_STRING DR5
7630: PPUSH
7631: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7635: LD_INT 8400
7637: PPUSH
7638: LD_INT 12600
7640: PPUSH
7641: CALL_OW 12
7645: PPUSH
7646: CALL_OW 67
// n := n + 1 ;
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: LD_VAR 0 1
7659: PUSH
7660: LD_INT 1
7662: PLUS
7663: ST_TO_ADDR
// if n > 9 then
7664: LD_VAR 0 1
7668: PUSH
7669: LD_INT 9
7671: GREATER
7672: IFFALSE 7682
// n := 9 ;
7674: LD_ADDR_VAR 0 1
7678: PUSH
7679: LD_INT 9
7681: ST_TO_ADDR
// until tick >= 120 120$00 ;
7682: LD_OWVAR 1
7686: PUSH
7687: LD_INT 252000
7689: GREATEREQUAL
7690: IFFALSE 7580
// end ; end_of_file
7692: PPOPN 1
7694: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7695: LD_INT 0
7697: PPUSH
// enable_addtolog := isTest ;
7698: LD_ADDR_OWVAR 81
7702: PUSH
7703: LD_EXP 1
7707: ST_TO_ADDR
// lines_break_limit := 5 ;
7708: LD_ADDR_EXP 26
7712: PUSH
7713: LD_INT 5
7715: ST_TO_ADDR
// lines_break_type := --- ;
7716: LD_ADDR_EXP 27
7720: PUSH
7721: LD_STRING ---
7723: ST_TO_ADDR
// lines_counter := 0 ;
7724: LD_ADDR_EXP 25
7728: PUSH
7729: LD_INT 0
7731: ST_TO_ADDR
// show_line_index := true ;
7732: LD_ADDR_EXP 28
7736: PUSH
7737: LD_INT 1
7739: ST_TO_ADDR
// tick_log := true ;
7740: LD_ADDR_EXP 29
7744: PUSH
7745: LD_INT 1
7747: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7748: LD_STRING ----------SAND OF SIBERIA LOG----------
7750: PPUSH
7751: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7755: LD_STRING Map Name: 
7757: PUSH
7758: LD_OWVAR 68
7762: STR
7763: PPUSH
7764: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7768: LD_STRING Map Number: 
7770: PUSH
7771: LD_OWVAR 70
7775: STR
7776: PPUSH
7777: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7781: LD_STRING Difficulty: 
7783: PUSH
7784: LD_OWVAR 67
7788: STR
7789: PPUSH
7790: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7794: LD_STRING ---------------------------------------
7796: PPUSH
7797: CALL_OW 561
// end ;
7801: LD_VAR 0 1
7805: RET
// function Log ( text ) ; begin
7806: LD_INT 0
7808: PPUSH
// if show_line_index then
7809: LD_EXP 28
7813: IFFALSE 7825
// result := lines_counter ;
7815: LD_ADDR_VAR 0 2
7819: PUSH
7820: LD_EXP 25
7824: ST_TO_ADDR
// if tick_log then
7825: LD_EXP 29
7829: IFFALSE 7855
// result := result &  T:  & tick &   ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_VAR 0 2
7840: PUSH
7841: LD_STRING  T: 
7843: STR
7844: PUSH
7845: LD_OWVAR 1
7849: STR
7850: PUSH
7851: LD_STRING  
7853: STR
7854: ST_TO_ADDR
// AddToLog ( result & text ) ;
7855: LD_VAR 0 2
7859: PUSH
7860: LD_VAR 0 1
7864: STR
7865: PPUSH
7866: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7870: LD_ADDR_EXP 25
7874: PUSH
7875: LD_EXP 25
7879: PUSH
7880: LD_INT 1
7882: PLUS
7883: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7884: LD_EXP 25
7888: PUSH
7889: LD_EXP 26
7893: MOD
7894: PUSH
7895: LD_INT 0
7897: EQUAL
7898: IFFALSE 7909
// AddToLog ( lines_break_type ) ;
7900: LD_EXP 27
7904: PPUSH
7905: CALL_OW 561
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogHuman ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7917: LD_STRING Human Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; class: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 257
7954: STR
7955: PUSH
7956: LD_STRING ; 
7958: STR
7959: PPUSH
7960: CALL 7806 0 1
// end ;
7964: LD_VAR 0 2
7968: RET
// export function LogVeh ( id ) ; begin
7969: LD_INT 0
7971: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7972: LD_STRING Vehicle Created. id: 
7974: PUSH
7975: LD_VAR 0 1
7979: STR
7980: PUSH
7981: LD_STRING ; side: 
7983: STR
7984: PUSH
7985: LD_VAR 0 1
7989: PPUSH
7990: CALL_OW 255
7994: STR
7995: PUSH
7996: LD_STRING ; nation: 
7998: STR
7999: PUSH
8000: LD_VAR 0 1
8004: PPUSH
8005: CALL_OW 248
8009: STR
8010: PUSH
8011: LD_STRING ; weapon: 
8013: STR
8014: PUSH
8015: LD_VAR 0 1
8019: PPUSH
8020: CALL_OW 264
8024: STR
8025: PUSH
8026: LD_STRING ; 
8028: STR
8029: PPUSH
8030: CALL 7806 0 1
// end ;
8034: LD_VAR 0 2
8038: RET
// export function LogEvent ( event ) ; begin
8039: LD_INT 0
8041: PPUSH
// Log ( Event Executed. id:  & event ) ;
8042: LD_STRING Event Executed. id: 
8044: PUSH
8045: LD_VAR 0 1
8049: STR
8050: PPUSH
8051: CALL 7806 0 1
// end ; end_of_file
8055: LD_VAR 0 2
8059: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
8064: PPUSH
8065: PPUSH
8066: PPUSH
8067: PPUSH
8068: PPUSH
8069: PPUSH
// if unit then
8070: LD_VAR 0 1
8074: IFFALSE 8474
// begin if mode = 0 then
8076: LD_VAR 0 3
8080: PUSH
8081: LD_INT 0
8083: EQUAL
8084: IFFALSE 8232
// begin if coords then
8086: LD_VAR 0 2
8090: IFFALSE 8230
// while ( coords > 1 ) do
8092: LD_VAR 0 2
8096: PUSH
8097: LD_INT 1
8099: GREATER
8100: IFFALSE 8230
// if not HasTask ( unit ) then
8102: LD_VAR 0 1
8106: PPUSH
8107: CALL_OW 314
8111: NOT
8112: IFFALSE 8228
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_VAR 0 2
8123: PUSH
8124: LD_INT 1
8126: ARRAY
8127: PPUSH
8128: LD_VAR 0 2
8132: PUSH
8133: LD_INT 2
8135: ARRAY
8136: PPUSH
8137: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8141: LD_INT 35
8143: PPUSH
8144: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 250
8157: PUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 1
8165: ARRAY
8166: EQUAL
8167: PUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 251
8177: PUSH
8178: LD_VAR 0 2
8182: PUSH
8183: LD_INT 2
8185: ARRAY
8186: EQUAL
8187: AND
8188: IFFALSE 8141
// for i = 1 to 2 do
8190: LD_ADDR_VAR 0 5
8194: PUSH
8195: DOUBLE
8196: LD_INT 1
8198: DEC
8199: ST_TO_ADDR
8200: LD_INT 2
8202: PUSH
8203: FOR_TO
8204: IFFALSE 8226
// coords := Delete ( coords , 1 ) ;
8206: LD_ADDR_VAR 0 2
8210: PUSH
8211: LD_VAR 0 2
8215: PPUSH
8216: LD_INT 1
8218: PPUSH
8219: CALL_OW 3
8223: ST_TO_ADDR
8224: GO 8203
8226: POP
8227: POP
// end ;
8228: GO 8092
// end else
8230: GO 8474
// begin if coords then
8232: LD_VAR 0 2
8236: IFFALSE 8474
// begin x := GetX ( unit ) ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 250
8252: ST_TO_ADDR
// y := GetY ( unit ) ;
8253: LD_ADDR_VAR 0 7
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 251
8267: ST_TO_ADDR
// while ( coords > 1 ) do
8268: LD_VAR 0 2
8272: PUSH
8273: LD_INT 1
8275: GREATER
8276: IFFALSE 8474
// begin Wait ( 0 0$0.3 ) ;
8278: LD_INT 10
8280: PPUSH
8281: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8285: LD_VAR 0 1
8289: PPUSH
8290: CALL_OW 255
8294: PPUSH
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 250
8304: PPUSH
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 251
8314: PPUSH
8315: LD_INT 14
8317: PPUSH
8318: CALL 22821 0 4
8322: IFFALSE 8353
// begin ComMoveXY ( unit , x , y ) ;
8324: LD_VAR 0 1
8328: PPUSH
8329: LD_VAR 0 6
8333: PPUSH
8334: LD_VAR 0 7
8338: PPUSH
8339: CALL_OW 111
// result := false ;
8343: LD_ADDR_VAR 0 4
8347: PUSH
8348: LD_INT 0
8350: ST_TO_ADDR
// end else
8351: GO 8392
// if not HasTask ( unit ) then
8353: LD_VAR 0 1
8357: PPUSH
8358: CALL_OW 314
8362: NOT
8363: IFFALSE 8392
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8365: LD_VAR 0 1
8369: PPUSH
8370: LD_VAR 0 2
8374: PUSH
8375: LD_INT 1
8377: ARRAY
8378: PPUSH
8379: LD_VAR 0 2
8383: PUSH
8384: LD_INT 2
8386: ARRAY
8387: PPUSH
8388: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8392: LD_VAR 0 1
8396: PPUSH
8397: CALL_OW 250
8401: PUSH
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: EQUAL
8411: PUSH
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 251
8421: PUSH
8422: LD_VAR 0 2
8426: PUSH
8427: LD_INT 2
8429: ARRAY
8430: EQUAL
8431: AND
8432: IFFALSE 8472
// for i = 1 to 2 do
8434: LD_ADDR_VAR 0 5
8438: PUSH
8439: DOUBLE
8440: LD_INT 1
8442: DEC
8443: ST_TO_ADDR
8444: LD_INT 2
8446: PUSH
8447: FOR_TO
8448: IFFALSE 8470
// coords := Delete ( coords , 1 ) ;
8450: LD_ADDR_VAR 0 2
8454: PUSH
8455: LD_VAR 0 2
8459: PPUSH
8460: LD_INT 1
8462: PPUSH
8463: CALL_OW 3
8467: ST_TO_ADDR
8468: GO 8447
8470: POP
8471: POP
// end ;
8472: GO 8268
// end ; end ; end ; result := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// end ;
8482: LD_VAR 0 4
8486: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8487: LD_INT 0
8489: PPUSH
8490: PPUSH
8491: PPUSH
// if not units then
8492: LD_VAR 0 2
8496: NOT
8497: IFFALSE 8501
// exit ;
8499: GO 8564
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8501: LD_ADDR_VAR 0 5
8505: PUSH
8506: LD_INT 81
8508: PUSH
8509: LD_VAR 0 1
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// for i in units do
8523: LD_ADDR_VAR 0 4
8527: PUSH
8528: LD_VAR 0 2
8532: PUSH
8533: FOR_IN
8534: IFFALSE 8562
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8536: LD_VAR 0 4
8540: PPUSH
8541: LD_VAR 0 5
8545: PPUSH
8546: LD_VAR 0 4
8550: PPUSH
8551: CALL_OW 74
8555: PPUSH
8556: CALL_OW 115
// end ;
8560: GO 8533
8562: POP
8563: POP
// end ;
8564: LD_VAR 0 3
8568: RET
// export function MC_Show ( string ) ; begin
8569: LD_INT 0
8571: PPUSH
// display_strings := string ;
8572: LD_ADDR_OWVAR 47
8576: PUSH
8577: LD_VAR 0 1
8581: ST_TO_ADDR
// end ; end_of_file
8582: LD_VAR 0 2
8586: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8587: LD_INT 0
8589: PPUSH
8590: PPUSH
8591: PPUSH
8592: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8593: LD_ADDR_VAR 0 8
8597: PUSH
8598: LD_VAR 0 1
8602: PPUSH
8603: LD_INT 2
8605: PPUSH
8606: EMPTY
8607: PPUSH
8608: CALL 11734 0 3
8612: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8613: LD_VAR 0 8
8617: PUSH
8618: LD_VAR 0 2
8622: PPUSH
8623: LD_VAR 0 3
8627: PPUSH
8628: CALL_OW 428
8632: PUSH
8633: LD_INT 0
8635: EQUAL
8636: AND
8637: IFFALSE 8711
// for i = 1 to plist do
8639: LD_ADDR_VAR 0 6
8643: PUSH
8644: DOUBLE
8645: LD_INT 1
8647: DEC
8648: ST_TO_ADDR
8649: LD_VAR 0 8
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8709
// if NotTask ( plist [ i ] ) then
8657: LD_VAR 0 8
8661: PUSH
8662: LD_VAR 0 6
8666: ARRAY
8667: PPUSH
8668: CALL 32236 0 1
8672: IFFALSE 8707
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8674: LD_VAR 0 8
8678: PUSH
8679: LD_VAR 0 6
8683: ARRAY
8684: PPUSH
8685: LD_INT 0
8687: PPUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: LD_VAR 0 3
8697: PPUSH
8698: LD_VAR 0 4
8702: PPUSH
8703: CALL_OW 145
// end ;
8707: GO 8654
8709: POP
8710: POP
// end ;
8711: LD_VAR 0 5
8715: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8716: LD_INT 0
8718: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8719: LD_VAR 0 1
8723: PPUSH
8724: LD_INT 6
8726: PPUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_VAR 0 3
8736: PPUSH
8737: LD_VAR 0 4
8741: PPUSH
8742: CALL 10220 0 5
// end ;
8746: LD_VAR 0 5
8750: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8751: LD_INT 0
8753: PPUSH
8754: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8755: LD_ADDR_VAR 0 4
8759: PUSH
8760: LD_INT 22
8762: PUSH
8763: LD_VAR 0 1
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PUSH
8772: LD_INT 2
8774: PUSH
8775: LD_INT 30
8777: PUSH
8778: LD_INT 0
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: LD_INT 30
8787: PUSH
8788: LD_INT 1
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: EMPTY
8805: LIST
8806: PPUSH
8807: CALL_OW 69
8811: PPUSH
8812: LD_VAR 0 2
8816: PPUSH
8817: CALL_OW 250
8821: PPUSH
8822: LD_VAR 0 2
8826: PPUSH
8827: CALL_OW 251
8831: PPUSH
8832: CALL_OW 73
8836: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8837: LD_VAR 0 4
8841: PPUSH
8842: LD_VAR 0 2
8846: PPUSH
8847: CALL 10509 0 2
8851: IFFALSE 8910
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8853: LD_VAR 0 1
8857: PPUSH
8858: LD_INT 30
8860: PUSH
8861: LD_VAR 0 2
8865: PUSH
8866: EMPTY
8867: LIST
8868: LIST
8869: PPUSH
8870: CALL 11651 0 2
8874: PUSH
8875: LD_INT 1
8877: ARRAY
8878: PPUSH
8879: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8883: LD_ADDR_EXP 48
8887: PUSH
8888: LD_EXP 48
8892: PPUSH
8893: LD_VAR 0 1
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: EMPTY
8904: PPUSH
8905: CALL 42051 0 4
8909: ST_TO_ADDR
// end ; end ;
8910: LD_VAR 0 3
8914: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8915: LD_INT 0
8917: PPUSH
8918: PPUSH
8919: PPUSH
8920: PPUSH
8921: PPUSH
8922: PPUSH
// result := false ;
8923: LD_ADDR_VAR 0 4
8927: PUSH
8928: LD_INT 0
8930: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8931: LD_VAR 0 1
8935: PPUSH
8936: LD_EXP 40
8940: PPUSH
8941: CALL 42999 0 2
8945: IFFALSE 9158
// for i = 1 to MREG_LabList do
8947: LD_ADDR_VAR 0 5
8951: PUSH
8952: DOUBLE
8953: LD_INT 1
8955: DEC
8956: ST_TO_ADDR
8957: LD_EXP 40
8961: PUSH
8962: FOR_TO
8963: IFFALSE 9156
// begin if MREG_LabList [ i ] [ 1 ] = side then
8965: LD_EXP 40
8969: PUSH
8970: LD_VAR 0 5
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PUSH
8980: LD_VAR 0 1
8984: EQUAL
8985: IFFALSE 9154
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8987: LD_ADDR_VAR 0 7
8991: PUSH
8992: LD_EXP 40
8996: PUSH
8997: LD_VAR 0 5
9001: ARRAY
9002: PUSH
9003: LD_INT 2
9005: ARRAY
9006: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9007: LD_ADDR_VAR 0 9
9011: PUSH
9012: LD_INT 22
9014: PUSH
9015: LD_VAR 0 1
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 2
9026: PUSH
9027: LD_INT 30
9029: PUSH
9030: LD_INT 0
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: LD_INT 30
9039: PUSH
9040: LD_INT 1
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: LIST
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: PUSH
9056: EMPTY
9057: LIST
9058: PPUSH
9059: CALL_OW 69
9063: PPUSH
9064: LD_VAR 0 7
9068: PPUSH
9069: CALL_OW 250
9073: PPUSH
9074: LD_VAR 0 7
9078: PPUSH
9079: CALL_OW 251
9083: PPUSH
9084: CALL_OW 73
9088: ST_TO_ADDR
// if dep then
9089: LD_VAR 0 9
9093: IFFALSE 9152
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9095: LD_VAR 0 9
9099: PPUSH
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 3
9109: PPUSH
9110: CALL 10625 0 3
9114: IFFALSE 9152
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9116: LD_VAR 0 7
9120: PPUSH
9121: LD_VAR 0 2
9125: PPUSH
9126: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9130: LD_VAR 0 7
9134: PPUSH
9135: LD_VAR 0 3
9139: PPUSH
9140: CALL_OW 207
// result := true ;
9144: LD_ADDR_VAR 0 4
9148: PUSH
9149: LD_INT 1
9151: ST_TO_ADDR
// end ; end ; break ;
9152: GO 9156
// end ; end ;
9154: GO 8962
9156: POP
9157: POP
// end ;
9158: LD_VAR 0 4
9162: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
9167: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9168: LD_ADDR_VAR 0 7
9172: PUSH
9173: LD_VAR 0 2
9177: PPUSH
9178: LD_VAR 0 3
9182: PPUSH
9183: LD_VAR 0 4
9187: PPUSH
9188: CALL 9350 0 3
9192: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9193: LD_ADDR_EXP 46
9197: PUSH
9198: LD_EXP 46
9202: PPUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: LD_INT 2
9210: PPUSH
9211: LD_VAR 0 2
9215: PUSH
9216: LD_VAR 0 3
9220: PUSH
9221: LD_VAR 0 4
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 41960 0 4
9235: ST_TO_ADDR
// if ext_list then
9236: LD_VAR 0 5
9240: IFFALSE 9345
// for i = 1 to ext_list do
9242: LD_ADDR_VAR 0 8
9246: PUSH
9247: DOUBLE
9248: LD_INT 1
9250: DEC
9251: ST_TO_ADDR
9252: LD_VAR 0 5
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9343
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9260: LD_ADDR_EXP 46
9264: PUSH
9265: LD_EXP 46
9269: PPUSH
9270: LD_VAR 0 1
9274: PPUSH
9275: LD_VAR 0 5
9279: PUSH
9280: LD_VAR 0 8
9284: ARRAY
9285: PPUSH
9286: LD_VAR 0 7
9290: PUSH
9291: LD_VAR 0 8
9295: ARRAY
9296: PUSH
9297: LD_INT 1
9299: ARRAY
9300: PUSH
9301: LD_VAR 0 7
9305: PUSH
9306: LD_VAR 0 8
9310: ARRAY
9311: PUSH
9312: LD_INT 2
9314: ARRAY
9315: PUSH
9316: LD_VAR 0 7
9320: PUSH
9321: LD_VAR 0 8
9325: ARRAY
9326: PUSH
9327: LD_INT 3
9329: ARRAY
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL 41960 0 4
9340: ST_TO_ADDR
9341: GO 9257
9343: POP
9344: POP
// end ;
9345: LD_VAR 0 6
9349: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9350: LD_INT 0
9352: PPUSH
9353: PPUSH
// list := [ ] ;
9354: LD_ADDR_VAR 0 5
9358: PUSH
9359: EMPTY
9360: ST_TO_ADDR
// case d of 0 :
9361: LD_VAR 0 3
9365: PUSH
9366: LD_INT 0
9368: DOUBLE
9369: EQUAL
9370: IFTRUE 9374
9372: GO 9507
9374: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_VAR 0 1
9384: PUSH
9385: LD_INT 4
9387: MINUS
9388: PUSH
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 4
9396: MINUS
9397: PUSH
9398: LD_INT 2
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: LD_VAR 0 1
9410: PUSH
9411: LD_INT 3
9413: MINUS
9414: PUSH
9415: LD_VAR 0 2
9419: PUSH
9420: LD_INT 1
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: PUSH
9428: LD_VAR 0 1
9432: PUSH
9433: LD_INT 4
9435: PLUS
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 4
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: LIST
9449: PUSH
9450: LD_VAR 0 1
9454: PUSH
9455: LD_INT 3
9457: PLUS
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: LD_INT 3
9466: PLUS
9467: PUSH
9468: LD_INT 5
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: ST_TO_ADDR
// end ; 1 :
9505: GO 10205
9507: LD_INT 1
9509: DOUBLE
9510: EQUAL
9511: IFTRUE 9515
9513: GO 9648
9515: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9516: LD_ADDR_VAR 0 5
9520: PUSH
9521: LD_VAR 0 1
9525: PUSH
9526: LD_VAR 0 2
9530: PUSH
9531: LD_INT 4
9533: MINUS
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: PUSH
9543: LD_VAR 0 1
9547: PUSH
9548: LD_INT 3
9550: MINUS
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: LD_INT 3
9559: MINUS
9560: PUSH
9561: LD_INT 2
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 4
9576: MINUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 1
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_VAR 0 2
9600: PUSH
9601: LD_INT 3
9603: PLUS
9604: PUSH
9605: LD_INT 0
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: LD_VAR 0 1
9617: PUSH
9618: LD_INT 4
9620: PLUS
9621: PUSH
9622: LD_VAR 0 2
9626: PUSH
9627: LD_INT 4
9629: PLUS
9630: PUSH
9631: LD_INT 5
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: ST_TO_ADDR
// end ; 2 :
9646: GO 10205
9648: LD_INT 2
9650: DOUBLE
9651: EQUAL
9652: IFTRUE 9656
9654: GO 9785
9656: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_VAR 0 1
9666: PUSH
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: MINUS
9675: PUSH
9676: LD_INT 3
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: LIST
9683: PUSH
9684: LD_VAR 0 1
9688: PUSH
9689: LD_INT 4
9691: PLUS
9692: PUSH
9693: LD_VAR 0 2
9697: PUSH
9698: LD_INT 4
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: PUSH
9706: LD_VAR 0 1
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 4
9718: PLUS
9719: PUSH
9720: LD_INT 0
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: PUSH
9728: LD_VAR 0 1
9732: PUSH
9733: LD_INT 3
9735: MINUS
9736: PUSH
9737: LD_VAR 0 2
9741: PUSH
9742: LD_INT 1
9744: PUSH
9745: EMPTY
9746: LIST
9747: LIST
9748: LIST
9749: PUSH
9750: LD_VAR 0 1
9754: PUSH
9755: LD_INT 4
9757: MINUS
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: LD_INT 4
9766: MINUS
9767: PUSH
9768: LD_INT 2
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: LIST
9782: ST_TO_ADDR
// end ; 3 :
9783: GO 10205
9785: LD_INT 3
9787: DOUBLE
9788: EQUAL
9789: IFTRUE 9793
9791: GO 9926
9793: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9794: LD_ADDR_VAR 0 5
9798: PUSH
9799: LD_VAR 0 1
9803: PUSH
9804: LD_INT 3
9806: PLUS
9807: PUSH
9808: LD_VAR 0 2
9812: PUSH
9813: LD_INT 4
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: PUSH
9821: LD_VAR 0 1
9825: PUSH
9826: LD_INT 4
9828: PLUS
9829: PUSH
9830: LD_VAR 0 2
9834: PUSH
9835: LD_INT 4
9837: PLUS
9838: PUSH
9839: LD_INT 5
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_VAR 0 1
9851: PUSH
9852: LD_INT 4
9854: MINUS
9855: PUSH
9856: LD_VAR 0 2
9860: PUSH
9861: LD_INT 1
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: LIST
9868: PUSH
9869: LD_VAR 0 1
9873: PUSH
9874: LD_VAR 0 2
9878: PUSH
9879: LD_INT 4
9881: MINUS
9882: PUSH
9883: LD_INT 3
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: LIST
9890: PUSH
9891: LD_VAR 0 1
9895: PUSH
9896: LD_INT 3
9898: MINUS
9899: PUSH
9900: LD_VAR 0 2
9904: PUSH
9905: LD_INT 3
9907: MINUS
9908: PUSH
9909: LD_INT 2
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: ST_TO_ADDR
// end ; 4 :
9924: GO 10205
9926: LD_INT 4
9928: DOUBLE
9929: EQUAL
9930: IFTRUE 9934
9932: GO 10067
9934: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9935: LD_ADDR_VAR 0 5
9939: PUSH
9940: LD_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: LD_INT 4
9952: PLUS
9953: PUSH
9954: LD_INT 0
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: LIST
9961: PUSH
9962: LD_VAR 0 1
9966: PUSH
9967: LD_INT 3
9969: PLUS
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 3
9978: PLUS
9979: PUSH
9980: LD_INT 5
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: LIST
9987: PUSH
9988: LD_VAR 0 1
9992: PUSH
9993: LD_INT 3
9995: PLUS
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: LD_INT 4
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: PUSH
10010: LD_VAR 0 1
10014: PUSH
10015: LD_VAR 0 2
10019: PUSH
10020: LD_INT 3
10022: MINUS
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: LD_VAR 0 1
10036: PUSH
10037: LD_INT 4
10039: MINUS
10040: PUSH
10041: LD_VAR 0 2
10045: PUSH
10046: LD_INT 4
10048: MINUS
10049: PUSH
10050: LD_INT 2
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: ST_TO_ADDR
// end ; 5 :
10065: GO 10205
10067: LD_INT 5
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10204
10075: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10076: LD_ADDR_VAR 0 5
10080: PUSH
10081: LD_VAR 0 1
10085: PUSH
10086: LD_INT 4
10088: MINUS
10089: PUSH
10090: LD_VAR 0 2
10094: PUSH
10095: LD_INT 1
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_VAR 0 1
10107: PUSH
10108: LD_VAR 0 2
10112: PUSH
10113: LD_INT 4
10115: MINUS
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: PUSH
10125: LD_VAR 0 1
10129: PUSH
10130: LD_INT 4
10132: PLUS
10133: PUSH
10134: LD_VAR 0 2
10138: PUSH
10139: LD_INT 4
10141: PLUS
10142: PUSH
10143: LD_INT 5
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: PUSH
10151: LD_VAR 0 1
10155: PUSH
10156: LD_INT 3
10158: PLUS
10159: PUSH
10160: LD_VAR 0 2
10164: PUSH
10165: LD_INT 4
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 1
10177: PUSH
10178: LD_VAR 0 2
10182: PUSH
10183: LD_INT 3
10185: PLUS
10186: PUSH
10187: LD_INT 0
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: ST_TO_ADDR
// end ; end ;
10202: GO 10205
10204: POP
// result := list ;
10205: LD_ADDR_VAR 0 4
10209: PUSH
10210: LD_VAR 0 5
10214: ST_TO_ADDR
// end ;
10215: LD_VAR 0 4
10219: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10220: LD_INT 0
10222: PPUSH
10223: PPUSH
10224: PPUSH
10225: PPUSH
10226: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10227: LD_ADDR_VAR 0 10
10231: PUSH
10232: LD_VAR 0 1
10236: PPUSH
10237: LD_INT 2
10239: PPUSH
10240: EMPTY
10241: PPUSH
10242: CALL 11734 0 3
10246: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10247: LD_ADDR_VAR 0 9
10251: PUSH
10252: LD_INT 22
10254: PUSH
10255: LD_VAR 0 1
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 2
10266: PUSH
10267: LD_INT 30
10269: PUSH
10270: LD_INT 0
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 30
10279: PUSH
10280: LD_INT 1
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: PPUSH
10299: CALL_OW 69
10303: PPUSH
10304: LD_VAR 0 3
10308: PPUSH
10309: LD_VAR 0 4
10313: PPUSH
10314: CALL_OW 73
10318: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10319: LD_ADDR_VAR 0 8
10323: PUSH
10324: LD_VAR 0 9
10328: PPUSH
10329: LD_VAR 0 2
10333: PPUSH
10334: CALL 10509 0 2
10338: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10339: LD_VAR 0 10
10343: PUSH
10344: LD_VAR 0 8
10348: AND
10349: PUSH
10350: LD_VAR 0 9
10354: PPUSH
10355: LD_VAR 0 3
10359: PPUSH
10360: LD_VAR 0 4
10364: PPUSH
10365: CALL_OW 297
10369: PUSH
10370: LD_INT 26
10372: LESSEQUAL
10373: AND
10374: PUSH
10375: LD_VAR 0 3
10379: PPUSH
10380: LD_VAR 0 4
10384: PPUSH
10385: CALL_OW 428
10389: PUSH
10390: LD_INT 0
10392: EQUAL
10393: AND
10394: IFFALSE 10504
// for i = 1 to plist do
10396: LD_ADDR_VAR 0 7
10400: PUSH
10401: DOUBLE
10402: LD_INT 1
10404: DEC
10405: ST_TO_ADDR
10406: LD_VAR 0 10
10410: PUSH
10411: FOR_TO
10412: IFFALSE 10502
// if IsInUnit ( plist [ i ] ) then
10414: LD_VAR 0 10
10418: PUSH
10419: LD_VAR 0 7
10423: ARRAY
10424: PPUSH
10425: CALL_OW 310
10429: IFFALSE 10448
// ComExitBuilding ( plist [ i ] ) else
10431: LD_VAR 0 10
10435: PUSH
10436: LD_VAR 0 7
10440: ARRAY
10441: PPUSH
10442: CALL_OW 122
10446: GO 10500
// if NotTask ( plist [ i ] ) then
10448: LD_VAR 0 10
10452: PUSH
10453: LD_VAR 0 7
10457: ARRAY
10458: PPUSH
10459: CALL 32236 0 1
10463: IFFALSE 10500
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10465: LD_VAR 0 10
10469: PUSH
10470: LD_VAR 0 7
10474: ARRAY
10475: PPUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 4
10490: PPUSH
10491: LD_VAR 0 5
10495: PPUSH
10496: CALL_OW 145
// end ;
10500: GO 10411
10502: POP
10503: POP
// end ;
10504: LD_VAR 0 6
10508: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10509: LD_INT 0
10511: PPUSH
10512: PPUSH
10513: PPUSH
// pom := GetBase ( bdepot ) ;
10514: LD_ADDR_VAR 0 4
10518: PUSH
10519: LD_VAR 0 1
10523: PPUSH
10524: CALL_OW 274
10528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10529: LD_ADDR_VAR 0 5
10533: PUSH
10534: LD_VAR 0 2
10538: PPUSH
10539: LD_VAR 0 1
10543: PPUSH
10544: CALL_OW 248
10548: PPUSH
10549: CALL_OW 450
10553: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10554: LD_VAR 0 4
10558: PPUSH
10559: LD_INT 1
10561: PPUSH
10562: CALL_OW 275
10566: PUSH
10567: LD_VAR 0 5
10571: PUSH
10572: LD_INT 1
10574: ARRAY
10575: GREATEREQUAL
10576: PUSH
10577: LD_VAR 0 4
10581: PPUSH
10582: LD_INT 3
10584: PPUSH
10585: CALL_OW 275
10589: PUSH
10590: LD_VAR 0 5
10594: PUSH
10595: LD_INT 3
10597: ARRAY
10598: GREATEREQUAL
10599: AND
10600: IFFALSE 10612
// result := true else
10602: LD_ADDR_VAR 0 3
10606: PUSH
10607: LD_INT 1
10609: ST_TO_ADDR
10610: GO 10620
// result := false ;
10612: LD_ADDR_VAR 0 3
10616: PUSH
10617: LD_INT 0
10619: ST_TO_ADDR
// end ;
10620: LD_VAR 0 3
10624: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10625: LD_INT 0
10627: PPUSH
10628: PPUSH
10629: PPUSH
10630: PPUSH
10631: PPUSH
// pom := GetBase ( bdepot ) ;
10632: LD_ADDR_VAR 0 5
10636: PUSH
10637: LD_VAR 0 1
10641: PPUSH
10642: CALL_OW 274
10646: ST_TO_ADDR
// cost := [ ] ;
10647: LD_ADDR_VAR 0 8
10651: PUSH
10652: EMPTY
10653: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10654: LD_ADDR_VAR 0 6
10658: PUSH
10659: LD_VAR 0 2
10663: PPUSH
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 248
10673: PPUSH
10674: CALL_OW 450
10678: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10679: LD_ADDR_VAR 0 7
10683: PUSH
10684: LD_VAR 0 3
10688: PPUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 248
10698: PPUSH
10699: CALL_OW 450
10703: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10704: LD_ADDR_VAR 0 8
10708: PUSH
10709: LD_VAR 0 8
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: LD_VAR 0 6
10721: PUSH
10722: LD_INT 1
10724: ARRAY
10725: PUSH
10726: LD_VAR 0 7
10730: PUSH
10731: LD_INT 1
10733: ARRAY
10734: PLUS
10735: PPUSH
10736: CALL_OW 1
10740: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10741: LD_ADDR_VAR 0 8
10745: PUSH
10746: LD_VAR 0 8
10750: PPUSH
10751: LD_INT 2
10753: PPUSH
10754: LD_VAR 0 6
10758: PUSH
10759: LD_INT 2
10761: ARRAY
10762: PUSH
10763: LD_VAR 0 7
10767: PUSH
10768: LD_INT 2
10770: ARRAY
10771: PLUS
10772: PPUSH
10773: CALL_OW 1
10777: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10778: LD_ADDR_VAR 0 8
10782: PUSH
10783: LD_VAR 0 8
10787: PPUSH
10788: LD_INT 3
10790: PPUSH
10791: LD_VAR 0 6
10795: PUSH
10796: LD_INT 3
10798: ARRAY
10799: PUSH
10800: LD_VAR 0 7
10804: PUSH
10805: LD_INT 3
10807: ARRAY
10808: PLUS
10809: PPUSH
10810: CALL_OW 1
10814: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10815: LD_VAR 0 5
10819: PPUSH
10820: LD_INT 1
10822: PPUSH
10823: CALL_OW 275
10827: PUSH
10828: LD_VAR 0 8
10832: PUSH
10833: LD_INT 1
10835: ARRAY
10836: GREATEREQUAL
10837: PUSH
10838: LD_VAR 0 5
10842: PPUSH
10843: LD_INT 3
10845: PPUSH
10846: CALL_OW 275
10850: PUSH
10851: LD_VAR 0 8
10855: PUSH
10856: LD_INT 3
10858: ARRAY
10859: GREATEREQUAL
10860: AND
10861: IFFALSE 10873
// result := true else
10863: LD_ADDR_VAR 0 4
10867: PUSH
10868: LD_INT 1
10870: ST_TO_ADDR
10871: GO 10881
// result := false ;
10873: LD_ADDR_VAR 0 4
10877: PUSH
10878: LD_INT 0
10880: ST_TO_ADDR
// end ;
10881: LD_VAR 0 4
10885: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10886: LD_INT 0
10888: PPUSH
10889: PPUSH
10890: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10891: LD_ADDR_VAR 0 5
10895: PUSH
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_INT 2
10903: PPUSH
10904: EMPTY
10905: PPUSH
10906: CALL 11734 0 3
10910: ST_TO_ADDR
// if unit and plist then
10911: LD_VAR 0 2
10915: PUSH
10916: LD_VAR 0 5
10920: AND
10921: IFFALSE 10982
// for i = 1 to plist do
10923: LD_ADDR_VAR 0 4
10927: PUSH
10928: DOUBLE
10929: LD_INT 1
10931: DEC
10932: ST_TO_ADDR
10933: LD_VAR 0 5
10937: PUSH
10938: FOR_TO
10939: IFFALSE 10980
// if NotTask ( plist [ i ] ) then
10941: LD_VAR 0 5
10945: PUSH
10946: LD_VAR 0 4
10950: ARRAY
10951: PPUSH
10952: CALL 32236 0 1
10956: IFFALSE 10978
// ComDismantle ( plist [ i ] , unit ) ;
10958: LD_VAR 0 5
10962: PUSH
10963: LD_VAR 0 4
10967: ARRAY
10968: PPUSH
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 167
10978: GO 10938
10980: POP
10981: POP
// result := true ;
10982: LD_ADDR_VAR 0 3
10986: PUSH
10987: LD_INT 1
10989: ST_TO_ADDR
// end ;
10990: LD_VAR 0 3
10994: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10995: LD_INT 0
10997: PPUSH
10998: PPUSH
10999: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11000: LD_ADDR_VAR 0 5
11004: PUSH
11005: LD_VAR 0 1
11009: PPUSH
11010: LD_INT 2
11012: PPUSH
11013: EMPTY
11014: PPUSH
11015: CALL 11734 0 3
11019: ST_TO_ADDR
// if unit and plist then
11020: LD_VAR 0 2
11024: PUSH
11025: LD_VAR 0 5
11029: AND
11030: IFFALSE 11091
// for i = 1 to plist do
11032: LD_ADDR_VAR 0 4
11036: PUSH
11037: DOUBLE
11038: LD_INT 1
11040: DEC
11041: ST_TO_ADDR
11042: LD_VAR 0 5
11046: PUSH
11047: FOR_TO
11048: IFFALSE 11089
// if NotTask ( plist [ i ] ) then
11050: LD_VAR 0 5
11054: PUSH
11055: LD_VAR 0 4
11059: ARRAY
11060: PPUSH
11061: CALL 32236 0 1
11065: IFFALSE 11087
// ComComplete ( plist [ i ] , unit ) ;
11067: LD_VAR 0 5
11071: PUSH
11072: LD_VAR 0 4
11076: ARRAY
11077: PPUSH
11078: LD_VAR 0 2
11082: PPUSH
11083: CALL 71187 0 2
11087: GO 11047
11089: POP
11090: POP
// result := true ;
11091: LD_ADDR_VAR 0 3
11095: PUSH
11096: LD_INT 1
11098: ST_TO_ADDR
// end ;
11099: LD_VAR 0 3
11103: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11104: LD_INT 0
11106: PPUSH
11107: PPUSH
11108: PPUSH
11109: PPUSH
11110: PPUSH
11111: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11112: LD_ADDR_VAR 0 5
11116: PUSH
11117: LD_INT 22
11119: PUSH
11120: LD_VAR 0 1
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 21
11131: PUSH
11132: LD_INT 3
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: PUSH
11139: LD_INT 3
11141: PUSH
11142: LD_INT 57
11144: PUSH
11145: EMPTY
11146: LIST
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 24
11157: PUSH
11158: LD_INT 1000
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: PPUSH
11175: CALL_OW 69
11179: ST_TO_ADDR
// r := [ ] ;
11180: LD_ADDR_VAR 0 6
11184: PUSH
11185: EMPTY
11186: ST_TO_ADDR
// if not tmp then
11187: LD_VAR 0 5
11191: NOT
11192: IFFALSE 11198
// exit else
11194: GO 11386
11196: GO 11366
// begin r := [ tmp [ 1 ] ] ;
11198: LD_ADDR_VAR 0 6
11202: PUSH
11203: LD_VAR 0 5
11207: PUSH
11208: LD_INT 1
11210: ARRAY
11211: PUSH
11212: EMPTY
11213: LIST
11214: ST_TO_ADDR
// for i = 2 to tmp do
11215: LD_ADDR_VAR 0 3
11219: PUSH
11220: DOUBLE
11221: LD_INT 2
11223: DEC
11224: ST_TO_ADDR
11225: LD_VAR 0 5
11229: PUSH
11230: FOR_TO
11231: IFFALSE 11364
// begin m := false ;
11233: LD_ADDR_VAR 0 7
11237: PUSH
11238: LD_INT 0
11240: ST_TO_ADDR
// for j = 1 to r do
11241: LD_ADDR_VAR 0 4
11245: PUSH
11246: DOUBLE
11247: LD_INT 1
11249: DEC
11250: ST_TO_ADDR
11251: LD_VAR 0 6
11255: PUSH
11256: FOR_TO
11257: IFFALSE 11331
// if GetLives ( tmp [ i ] ) < r [ j ] then
11259: LD_VAR 0 5
11263: PUSH
11264: LD_VAR 0 3
11268: ARRAY
11269: PPUSH
11270: CALL_OW 256
11274: PUSH
11275: LD_VAR 0 6
11279: PUSH
11280: LD_VAR 0 4
11284: ARRAY
11285: LESS
11286: IFFALSE 11329
// begin r := Insert ( r , j , tmp [ i ] ) ;
11288: LD_ADDR_VAR 0 6
11292: PUSH
11293: LD_VAR 0 6
11297: PPUSH
11298: LD_VAR 0 4
11302: PPUSH
11303: LD_VAR 0 5
11307: PUSH
11308: LD_VAR 0 3
11312: ARRAY
11313: PPUSH
11314: CALL_OW 2
11318: ST_TO_ADDR
// m := true ;
11319: LD_ADDR_VAR 0 7
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// break ;
11327: GO 11331
// end ;
11329: GO 11256
11331: POP
11332: POP
// if not m then
11333: LD_VAR 0 7
11337: NOT
11338: IFFALSE 11362
// r := r ^ tmp [ i ] ;
11340: LD_ADDR_VAR 0 6
11344: PUSH
11345: LD_VAR 0 6
11349: PUSH
11350: LD_VAR 0 5
11354: PUSH
11355: LD_VAR 0 3
11359: ARRAY
11360: ADD
11361: ST_TO_ADDR
// end ;
11362: GO 11230
11364: POP
11365: POP
// end ; if r then
11366: LD_VAR 0 6
11370: IFFALSE 11384
// result := r else
11372: LD_ADDR_VAR 0 2
11376: PUSH
11377: LD_VAR 0 6
11381: ST_TO_ADDR
11382: GO 11386
// exit ;
11384: GO 11386
// end ;
11386: LD_VAR 0 2
11390: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11391: LD_INT 0
11393: PPUSH
11394: PPUSH
11395: PPUSH
11396: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11397: LD_ADDR_VAR 0 5
11401: PUSH
11402: LD_INT 22
11404: PUSH
11405: LD_VAR 0 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: LD_INT 25
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 25
11429: PUSH
11430: LD_INT 16
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 34
11439: PUSH
11440: LD_INT 13
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: PUSH
11447: LD_INT 34
11449: PUSH
11450: LD_INT 52
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PUSH
11464: LD_INT 24
11466: PUSH
11467: LD_INT 650
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: PPUSH
11479: CALL_OW 69
11483: ST_TO_ADDR
// p := 1 ;
11484: LD_ADDR_VAR 0 4
11488: PUSH
11489: LD_INT 1
11491: ST_TO_ADDR
// for i = 1 to repairs do
11492: LD_ADDR_VAR 0 3
11496: PUSH
11497: DOUBLE
11498: LD_INT 1
11500: DEC
11501: ST_TO_ADDR
11502: LD_VAR 0 5
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11644
// begin if IsInUnit ( repairs [ i ] ) then
11510: LD_VAR 0 5
11514: PUSH
11515: LD_VAR 0 3
11519: ARRAY
11520: PPUSH
11521: CALL_OW 310
11525: IFFALSE 11544
// ComExitBuilding ( repairs [ i ] ) else
11527: LD_VAR 0 5
11531: PUSH
11532: LD_VAR 0 3
11536: ARRAY
11537: PPUSH
11538: CALL_OW 122
11542: GO 11642
// if not HasTask ( repairs [ i ] ) then
11544: LD_VAR 0 5
11548: PUSH
11549: LD_VAR 0 3
11553: ARRAY
11554: PPUSH
11555: CALL_OW 314
11559: NOT
11560: IFFALSE 11642
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11562: LD_VAR 0 5
11566: PUSH
11567: LD_VAR 0 3
11571: ARRAY
11572: PPUSH
11573: LD_EXP 47
11577: PUSH
11578: LD_VAR 0 1
11582: ARRAY
11583: PUSH
11584: LD_VAR 0 4
11588: ARRAY
11589: PPUSH
11590: CALL_OW 130
// if i mod 3 = 0 then
11594: LD_VAR 0 3
11598: PUSH
11599: LD_INT 3
11601: MOD
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: IFFALSE 11622
// p := p + 1 ;
11608: LD_ADDR_VAR 0 4
11612: PUSH
11613: LD_VAR 0 4
11617: PUSH
11618: LD_INT 1
11620: PLUS
11621: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11622: LD_EXP 47
11626: PUSH
11627: LD_VAR 0 1
11631: ARRAY
11632: PUSH
11633: LD_VAR 0 4
11637: LESS
11638: IFFALSE 11642
// break ;
11640: GO 11644
// end ; end ;
11642: GO 11507
11644: POP
11645: POP
// end ; end_of_file
11646: LD_VAR 0 2
11650: RET
// export function MCF_Get ( side , filter ) ; begin
11651: LD_INT 0
11653: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11654: LD_ADDR_VAR 0 3
11658: PUSH
11659: LD_INT 22
11661: PUSH
11662: LD_VAR 0 1
11666: PUSH
11667: EMPTY
11668: LIST
11669: LIST
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PPUSH
11680: CALL_OW 69
11684: ST_TO_ADDR
// end ;
11685: LD_VAR 0 3
11689: RET
// export function MCF_Lab ( side ) ; begin
11690: LD_INT 0
11692: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11693: LD_ADDR_VAR 0 2
11697: PUSH
11698: LD_INT 22
11700: PUSH
11701: LD_VAR 0 1
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PUSH
11710: LD_INT 30
11712: PUSH
11713: LD_INT 8
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PPUSH
11724: CALL_OW 69
11728: ST_TO_ADDR
// end ;
11729: LD_VAR 0 2
11733: RET
// export function MCF_Class ( side , class , filter ) ; begin
11734: LD_INT 0
11736: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11737: LD_ADDR_VAR 0 4
11741: PUSH
11742: LD_INT 22
11744: PUSH
11745: LD_VAR 0 1
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PUSH
11754: LD_INT 25
11756: PUSH
11757: LD_VAR 0 2
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: PUSH
11766: LD_VAR 0 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: LIST
11775: PPUSH
11776: CALL_OW 69
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 4
11785: RET
// export function MCF_All ( side , filter ) ; begin
11786: LD_INT 0
11788: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11789: LD_ADDR_VAR 0 3
11793: PUSH
11794: LD_INT 22
11796: PUSH
11797: LD_VAR 0 1
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 25
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 25
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 3
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 25
11841: PUSH
11842: LD_INT 4
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: PUSH
11856: LD_VAR 0 2
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: ST_TO_ADDR
// end ;
11871: LD_VAR 0 3
11875: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11876: LD_INT 0
11878: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11879: LD_ADDR_VAR 0 4
11883: PUSH
11884: LD_INT 22
11886: PUSH
11887: LD_VAR 0 1
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 92
11898: PUSH
11899: LD_VAR 0 2
11903: PUSH
11904: LD_INT 1
11906: ARRAY
11907: PUSH
11908: LD_VAR 0 2
11912: PUSH
11913: LD_INT 2
11915: ARRAY
11916: PUSH
11917: LD_VAR 0 2
11921: PUSH
11922: LD_INT 3
11924: ARRAY
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: PUSH
11932: LD_VAR 0 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: ST_TO_ADDR
// end ;
11947: LD_VAR 0 4
11951: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11952: LD_INT 0
11954: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11955: LD_ADDR_VAR 0 3
11959: PUSH
11960: LD_INT 22
11962: PUSH
11963: LD_VAR 0 1
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 21
11974: PUSH
11975: LD_INT 2
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_VAR 0 2
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: ST_TO_ADDR
// end ;
11997: LD_VAR 0 3
12001: RET
// export function MCF_Cargo ( side ) ; begin
12002: LD_INT 0
12004: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12005: LD_ADDR_VAR 0 2
12009: PUSH
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_INT 2
12017: PUSH
12018: LD_INT 34
12020: PUSH
12021: LD_INT 12
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 34
12030: PUSH
12031: LD_INT 32
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 34
12040: PUSH
12041: LD_INT 51
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: PPUSH
12054: CALL 11952 0 2
12058: ST_TO_ADDR
// end ;
12059: LD_VAR 0 2
12063: RET
// export function MCF_Ape ( side ) ; begin
12064: LD_INT 0
12066: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12067: LD_ADDR_VAR 0 2
12071: PUSH
12072: LD_INT 22
12074: PUSH
12075: LD_VAR 0 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 2
12086: PUSH
12087: LD_INT 25
12089: PUSH
12090: LD_INT 12
12092: PUSH
12093: EMPTY
12094: LIST
12095: LIST
12096: PUSH
12097: LD_INT 25
12099: PUSH
12100: LD_INT 15
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 25
12109: PUSH
12110: LD_INT 16
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 25
12119: PUSH
12120: LD_INT 17
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 69
12142: ST_TO_ADDR
// end ;
12143: LD_VAR 0 2
12147: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
12153: PPUSH
// result := [ ] ;
12154: LD_ADDR_VAR 0 3
12158: PUSH
12159: EMPTY
12160: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL 12064 0 1
12175: ST_TO_ADDR
// case type of 0 , normal :
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 0
12183: DOUBLE
12184: EQUAL
12185: IFTRUE 12195
12187: LD_STRING normal
12189: DOUBLE
12190: EQUAL
12191: IFTRUE 12195
12193: GO 12206
12195: POP
// cl := class_apeman ; 1 , soldier :
12196: LD_ADDR_VAR 0 5
12200: PUSH
12201: LD_INT 12
12203: ST_TO_ADDR
12204: GO 12282
12206: LD_INT 1
12208: DOUBLE
12209: EQUAL
12210: IFTRUE 12220
12212: LD_STRING soldier
12214: DOUBLE
12215: EQUAL
12216: IFTRUE 12220
12218: GO 12231
12220: POP
// cl := class_apeman_soldier ; 2 , engineer :
12221: LD_ADDR_VAR 0 5
12225: PUSH
12226: LD_INT 15
12228: ST_TO_ADDR
12229: GO 12282
12231: LD_INT 2
12233: DOUBLE
12234: EQUAL
12235: IFTRUE 12245
12237: LD_STRING engineer
12239: DOUBLE
12240: EQUAL
12241: IFTRUE 12245
12243: GO 12256
12245: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12246: LD_ADDR_VAR 0 5
12250: PUSH
12251: LD_INT 16
12253: ST_TO_ADDR
12254: GO 12282
12256: LD_INT 3
12258: DOUBLE
12259: EQUAL
12260: IFTRUE 12270
12262: LD_STRING kamikaze
12264: DOUBLE
12265: EQUAL
12266: IFTRUE 12270
12268: GO 12281
12270: POP
// cl := class_apeman_kamikaze ; end ;
12271: LD_ADDR_VAR 0 5
12275: PUSH
12276: LD_INT 17
12278: ST_TO_ADDR
12279: GO 12282
12281: POP
// for i = 1 to tmp do
12282: LD_ADDR_VAR 0 6
12286: PUSH
12287: DOUBLE
12288: LD_INT 1
12290: DEC
12291: ST_TO_ADDR
12292: LD_VAR 0 4
12296: PUSH
12297: FOR_TO
12298: IFFALSE 12347
// if GetClass ( tmp [ i ] ) = cl then
12300: LD_VAR 0 4
12304: PUSH
12305: LD_VAR 0 6
12309: ARRAY
12310: PPUSH
12311: CALL_OW 257
12315: PUSH
12316: LD_VAR 0 5
12320: EQUAL
12321: IFFALSE 12345
// result := result ^ tmp [ i ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 3
12332: PUSH
12333: LD_VAR 0 4
12337: PUSH
12338: LD_VAR 0 6
12342: ARRAY
12343: ADD
12344: ST_TO_ADDR
12345: GO 12297
12347: POP
12348: POP
// end ;
12349: LD_VAR 0 3
12353: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12354: LD_INT 0
12356: PPUSH
12357: PPUSH
12358: PPUSH
12359: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12360: LD_ADDR_VAR 0 5
12364: PUSH
12365: LD_INT 22
12367: PUSH
12368: LD_VAR 0 1
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PUSH
12377: LD_VAR 0 3
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PPUSH
12386: CALL_OW 69
12390: ST_TO_ADDR
// r := [ ] ;
12391: LD_ADDR_VAR 0 6
12395: PUSH
12396: EMPTY
12397: ST_TO_ADDR
// if tmp then
12398: LD_VAR 0 5
12402: IFFALSE 12471
// for i = 1 to tmp do
12404: LD_ADDR_VAR 0 7
12408: PUSH
12409: DOUBLE
12410: LD_INT 1
12412: DEC
12413: ST_TO_ADDR
12414: LD_VAR 0 5
12418: PUSH
12419: FOR_TO
12420: IFFALSE 12469
// if GetTag ( tmp [ i ] ) = tag then
12422: LD_VAR 0 5
12426: PUSH
12427: LD_VAR 0 7
12431: ARRAY
12432: PPUSH
12433: CALL_OW 110
12437: PUSH
12438: LD_VAR 0 2
12442: EQUAL
12443: IFFALSE 12467
// r := r ^ tmp [ i ] ;
12445: LD_ADDR_VAR 0 6
12449: PUSH
12450: LD_VAR 0 6
12454: PUSH
12455: LD_VAR 0 5
12459: PUSH
12460: LD_VAR 0 7
12464: ARRAY
12465: ADD
12466: ST_TO_ADDR
12467: GO 12419
12469: POP
12470: POP
// result := r ;
12471: LD_ADDR_VAR 0 4
12475: PUSH
12476: LD_VAR 0 6
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 4
12485: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
// tmp := plist ;
12491: LD_ADDR_VAR 0 5
12495: PUSH
12496: LD_VAR 0 2
12500: ST_TO_ADDR
// if tmp then
12501: LD_VAR 0 5
12505: IFFALSE 12582
// begin for i = 1 to tmp do
12507: LD_ADDR_VAR 0 6
12511: PUSH
12512: DOUBLE
12513: LD_INT 1
12515: DEC
12516: ST_TO_ADDR
12517: LD_VAR 0 5
12521: PUSH
12522: FOR_TO
12523: IFFALSE 12570
// if GetTag ( tmp [ i ] ) <> tag then
12525: LD_VAR 0 5
12529: PUSH
12530: LD_VAR 0 6
12534: ARRAY
12535: PPUSH
12536: CALL_OW 110
12540: PUSH
12541: LD_VAR 0 3
12545: NONEQUAL
12546: IFFALSE 12568
// SetTag ( tmp [ i ] , tag ) ;
12548: LD_VAR 0 5
12552: PUSH
12553: LD_VAR 0 6
12557: ARRAY
12558: PPUSH
12559: LD_VAR 0 3
12563: PPUSH
12564: CALL_OW 109
12568: GO 12522
12570: POP
12571: POP
// result := true ;
12572: LD_ADDR_VAR 0 4
12576: PUSH
12577: LD_INT 1
12579: ST_TO_ADDR
// end else
12580: GO 12590
// result := false ;
12582: LD_ADDR_VAR 0 4
12586: PUSH
12587: LD_INT 0
12589: ST_TO_ADDR
// end ;
12590: LD_VAR 0 4
12594: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12595: LD_INT 0
12597: PPUSH
12598: PPUSH
12599: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12600: LD_ADDR_VAR 0 4
12604: PUSH
12605: LD_VAR 0 1
12609: PPUSH
12610: LD_VAR 0 2
12614: PPUSH
12615: EMPTY
12616: PPUSH
12617: CALL 12354 0 3
12621: ST_TO_ADDR
// if tmp then
12622: LD_VAR 0 4
12626: IFFALSE 12678
// begin for i = 1 to tmp do
12628: LD_ADDR_VAR 0 5
12632: PUSH
12633: DOUBLE
12634: LD_INT 1
12636: DEC
12637: ST_TO_ADDR
12638: LD_VAR 0 4
12642: PUSH
12643: FOR_TO
12644: IFFALSE 12666
// SetTag ( tmp [ i ] , 0 ) ;
12646: LD_VAR 0 4
12650: PUSH
12651: LD_VAR 0 5
12655: ARRAY
12656: PPUSH
12657: LD_INT 0
12659: PPUSH
12660: CALL_OW 109
12664: GO 12643
12666: POP
12667: POP
// result := true ;
12668: LD_ADDR_VAR 0 3
12672: PUSH
12673: LD_INT 1
12675: ST_TO_ADDR
// end else
12676: GO 12686
// result := false ;
12678: LD_ADDR_VAR 0 3
12682: PUSH
12683: LD_INT 0
12685: ST_TO_ADDR
// end ;
12686: LD_VAR 0 3
12690: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12691: LD_INT 0
12693: PPUSH
12694: PPUSH
12695: PPUSH
12696: PPUSH
12697: PPUSH
// sort_list := [ ] ;
12698: LD_ADDR_VAR 0 5
12702: PUSH
12703: EMPTY
12704: ST_TO_ADDR
// for i = 1 to list do
12705: LD_ADDR_VAR 0 3
12709: PUSH
12710: DOUBLE
12711: LD_INT 1
12713: DEC
12714: ST_TO_ADDR
12715: LD_VAR 0 1
12719: PUSH
12720: FOR_TO
12721: IFFALSE 12883
// begin if i = 1 then
12723: LD_VAR 0 3
12727: PUSH
12728: LD_INT 1
12730: EQUAL
12731: IFFALSE 12757
// sort_list := sort_list ^ list [ i ] else
12733: LD_ADDR_VAR 0 5
12737: PUSH
12738: LD_VAR 0 5
12742: PUSH
12743: LD_VAR 0 1
12747: PUSH
12748: LD_VAR 0 3
12752: ARRAY
12753: ADD
12754: ST_TO_ADDR
12755: GO 12881
// begin for j = 1 to sort_list do
12757: LD_ADDR_VAR 0 4
12761: PUSH
12762: DOUBLE
12763: LD_INT 1
12765: DEC
12766: ST_TO_ADDR
12767: LD_VAR 0 5
12771: PUSH
12772: FOR_TO
12773: IFFALSE 12850
// begin add := false ;
12775: LD_ADDR_VAR 0 6
12779: PUSH
12780: LD_INT 0
12782: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12783: LD_VAR 0 1
12787: PUSH
12788: LD_VAR 0 3
12792: ARRAY
12793: PUSH
12794: LD_VAR 0 5
12798: PUSH
12799: LD_VAR 0 4
12803: ARRAY
12804: LESS
12805: IFFALSE 12848
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12807: LD_ADDR_VAR 0 5
12811: PUSH
12812: LD_VAR 0 5
12816: PPUSH
12817: LD_VAR 0 4
12821: PPUSH
12822: LD_VAR 0 1
12826: PUSH
12827: LD_VAR 0 3
12831: ARRAY
12832: PPUSH
12833: CALL_OW 2
12837: ST_TO_ADDR
// add := true ;
12838: LD_ADDR_VAR 0 6
12842: PUSH
12843: LD_INT 1
12845: ST_TO_ADDR
// break ;
12846: GO 12850
// end ; end ;
12848: GO 12772
12850: POP
12851: POP
// if not add then
12852: LD_VAR 0 6
12856: NOT
12857: IFFALSE 12881
// sort_list := sort_list ^ list [ i ] ;
12859: LD_ADDR_VAR 0 5
12863: PUSH
12864: LD_VAR 0 5
12868: PUSH
12869: LD_VAR 0 1
12873: PUSH
12874: LD_VAR 0 3
12878: ARRAY
12879: ADD
12880: ST_TO_ADDR
// end ; end ;
12881: GO 12720
12883: POP
12884: POP
// result := sort_list ;
12885: LD_ADDR_VAR 0 2
12889: PUSH
12890: LD_VAR 0 5
12894: ST_TO_ADDR
// end ;
12895: LD_VAR 0 2
12899: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12900: LD_INT 0
12902: PPUSH
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// sort_list := [ ] ;
12907: LD_ADDR_VAR 0 5
12911: PUSH
12912: EMPTY
12913: ST_TO_ADDR
// for i = 1 to list do
12914: LD_ADDR_VAR 0 3
12918: PUSH
12919: DOUBLE
12920: LD_INT 1
12922: DEC
12923: ST_TO_ADDR
12924: LD_VAR 0 1
12928: PUSH
12929: FOR_TO
12930: IFFALSE 13092
// begin if i = 1 then
12932: LD_VAR 0 3
12936: PUSH
12937: LD_INT 1
12939: EQUAL
12940: IFFALSE 12966
// sort_list := sort_list ^ list [ i ] else
12942: LD_ADDR_VAR 0 5
12946: PUSH
12947: LD_VAR 0 5
12951: PUSH
12952: LD_VAR 0 1
12956: PUSH
12957: LD_VAR 0 3
12961: ARRAY
12962: ADD
12963: ST_TO_ADDR
12964: GO 13090
// begin for j = 1 to sort_list do
12966: LD_ADDR_VAR 0 4
12970: PUSH
12971: DOUBLE
12972: LD_INT 1
12974: DEC
12975: ST_TO_ADDR
12976: LD_VAR 0 5
12980: PUSH
12981: FOR_TO
12982: IFFALSE 13059
// begin add := false ;
12984: LD_ADDR_VAR 0 6
12988: PUSH
12989: LD_INT 0
12991: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12992: LD_VAR 0 1
12996: PUSH
12997: LD_VAR 0 3
13001: ARRAY
13002: PUSH
13003: LD_VAR 0 5
13007: PUSH
13008: LD_VAR 0 4
13012: ARRAY
13013: GREATER
13014: IFFALSE 13057
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13016: LD_ADDR_VAR 0 5
13020: PUSH
13021: LD_VAR 0 5
13025: PPUSH
13026: LD_VAR 0 4
13030: PPUSH
13031: LD_VAR 0 1
13035: PUSH
13036: LD_VAR 0 3
13040: ARRAY
13041: PPUSH
13042: CALL_OW 2
13046: ST_TO_ADDR
// add := true ;
13047: LD_ADDR_VAR 0 6
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// break ;
13055: GO 13059
// end ; end ;
13057: GO 12981
13059: POP
13060: POP
// if not add then
13061: LD_VAR 0 6
13065: NOT
13066: IFFALSE 13090
// sort_list := sort_list ^ list [ i ] ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_VAR 0 5
13077: PUSH
13078: LD_VAR 0 1
13082: PUSH
13083: LD_VAR 0 3
13087: ARRAY
13088: ADD
13089: ST_TO_ADDR
// end ; end ;
13090: GO 12929
13092: POP
13093: POP
// result := sort_list ;
13094: LD_ADDR_VAR 0 2
13098: PUSH
13099: LD_VAR 0 5
13103: ST_TO_ADDR
// end ;
13104: LD_VAR 0 2
13108: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13109: LD_INT 0
13111: PPUSH
13112: PPUSH
13113: PPUSH
13114: PPUSH
13115: PPUSH
13116: PPUSH
// tmp := [ ] ;
13117: LD_ADDR_VAR 0 8
13121: PUSH
13122: EMPTY
13123: ST_TO_ADDR
// r := [ ] ;
13124: LD_ADDR_VAR 0 7
13128: PUSH
13129: EMPTY
13130: ST_TO_ADDR
// add := false ;
13131: LD_ADDR_VAR 0 9
13135: PUSH
13136: LD_INT 0
13138: ST_TO_ADDR
// if plist then
13139: LD_VAR 0 2
13143: IFFALSE 13219
// begin for i = 1 to plist do
13145: LD_ADDR_VAR 0 5
13149: PUSH
13150: DOUBLE
13151: LD_INT 1
13153: DEC
13154: ST_TO_ADDR
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_TO
13161: IFFALSE 13215
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13163: LD_ADDR_VAR 0 8
13167: PUSH
13168: LD_VAR 0 8
13172: PUSH
13173: LD_VAR 0 2
13177: PUSH
13178: LD_VAR 0 5
13182: ARRAY
13183: PUSH
13184: LD_VAR 0 2
13188: PUSH
13189: LD_VAR 0 5
13193: ARRAY
13194: PPUSH
13195: LD_VAR 0 3
13199: PPUSH
13200: CALL_OW 259
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: EMPTY
13210: LIST
13211: ADD
13212: ST_TO_ADDR
// end ;
13213: GO 13160
13215: POP
13216: POP
// end else
13217: GO 13227
// result := false ;
13219: LD_ADDR_VAR 0 4
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// if tmp then
13227: LD_VAR 0 8
13231: IFFALSE 13405
// begin r := r ^ [ tmp [ 1 ] ] ;
13233: LD_ADDR_VAR 0 7
13237: PUSH
13238: LD_VAR 0 7
13242: PUSH
13243: LD_VAR 0 8
13247: PUSH
13248: LD_INT 1
13250: ARRAY
13251: PUSH
13252: EMPTY
13253: LIST
13254: ADD
13255: ST_TO_ADDR
// for i = 2 to tmp do
13256: LD_ADDR_VAR 0 5
13260: PUSH
13261: DOUBLE
13262: LD_INT 2
13264: DEC
13265: ST_TO_ADDR
13266: LD_VAR 0 8
13270: PUSH
13271: FOR_TO
13272: IFFALSE 13403
// begin for j = 1 to r do
13274: LD_ADDR_VAR 0 6
13278: PUSH
13279: DOUBLE
13280: LD_INT 1
13282: DEC
13283: ST_TO_ADDR
13284: LD_VAR 0 7
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13367
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13292: LD_VAR 0 8
13296: PUSH
13297: LD_VAR 0 5
13301: ARRAY
13302: PUSH
13303: LD_INT 2
13305: ARRAY
13306: PUSH
13307: LD_VAR 0 7
13311: PUSH
13312: LD_VAR 0 6
13316: ARRAY
13317: PUSH
13318: LD_INT 2
13320: ARRAY
13321: LESS
13322: IFFALSE 13365
// begin r := Insert ( r , j , tmp [ i ] ) ;
13324: LD_ADDR_VAR 0 7
13328: PUSH
13329: LD_VAR 0 7
13333: PPUSH
13334: LD_VAR 0 6
13338: PPUSH
13339: LD_VAR 0 8
13343: PUSH
13344: LD_VAR 0 5
13348: ARRAY
13349: PPUSH
13350: CALL_OW 2
13354: ST_TO_ADDR
// add := true ;
13355: LD_ADDR_VAR 0 9
13359: PUSH
13360: LD_INT 1
13362: ST_TO_ADDR
// break ;
13363: GO 13367
// end ; end ;
13365: GO 13289
13367: POP
13368: POP
// if not add then
13369: LD_VAR 0 9
13373: NOT
13374: IFFALSE 13401
// r := r ^ [ tmp [ i ] ] ;
13376: LD_ADDR_VAR 0 7
13380: PUSH
13381: LD_VAR 0 7
13385: PUSH
13386: LD_VAR 0 8
13390: PUSH
13391: LD_VAR 0 5
13395: ARRAY
13396: PUSH
13397: EMPTY
13398: LIST
13399: ADD
13400: ST_TO_ADDR
// end ;
13401: GO 13271
13403: POP
13404: POP
// end ; result := r ;
13405: LD_ADDR_VAR 0 4
13409: PUSH
13410: LD_VAR 0 7
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 4
13419: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
13426: PPUSH
13427: PPUSH
// tmp := [ ] ;
13428: LD_ADDR_VAR 0 8
13432: PUSH
13433: EMPTY
13434: ST_TO_ADDR
// r := [ ] ;
13435: LD_ADDR_VAR 0 7
13439: PUSH
13440: EMPTY
13441: ST_TO_ADDR
// add := false ;
13442: LD_ADDR_VAR 0 9
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// if plist then
13450: LD_VAR 0 2
13454: IFFALSE 13530
// begin for i = 1 to plist do
13456: LD_ADDR_VAR 0 5
13460: PUSH
13461: DOUBLE
13462: LD_INT 1
13464: DEC
13465: ST_TO_ADDR
13466: LD_VAR 0 2
13470: PUSH
13471: FOR_TO
13472: IFFALSE 13526
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13474: LD_ADDR_VAR 0 8
13478: PUSH
13479: LD_VAR 0 8
13483: PUSH
13484: LD_VAR 0 2
13488: PUSH
13489: LD_VAR 0 5
13493: ARRAY
13494: PUSH
13495: LD_VAR 0 2
13499: PUSH
13500: LD_VAR 0 5
13504: ARRAY
13505: PPUSH
13506: LD_VAR 0 3
13510: PPUSH
13511: CALL_OW 259
13515: PUSH
13516: EMPTY
13517: LIST
13518: LIST
13519: PUSH
13520: EMPTY
13521: LIST
13522: ADD
13523: ST_TO_ADDR
// end ;
13524: GO 13471
13526: POP
13527: POP
// end else
13528: GO 13538
// result := false ;
13530: LD_ADDR_VAR 0 4
13534: PUSH
13535: LD_INT 0
13537: ST_TO_ADDR
// if tmp then
13538: LD_VAR 0 8
13542: IFFALSE 13716
// begin r := r ^ [ tmp [ 1 ] ] ;
13544: LD_ADDR_VAR 0 7
13548: PUSH
13549: LD_VAR 0 7
13553: PUSH
13554: LD_VAR 0 8
13558: PUSH
13559: LD_INT 1
13561: ARRAY
13562: PUSH
13563: EMPTY
13564: LIST
13565: ADD
13566: ST_TO_ADDR
// for i = 2 to tmp do
13567: LD_ADDR_VAR 0 5
13571: PUSH
13572: DOUBLE
13573: LD_INT 2
13575: DEC
13576: ST_TO_ADDR
13577: LD_VAR 0 8
13581: PUSH
13582: FOR_TO
13583: IFFALSE 13714
// begin for j = 1 to r do
13585: LD_ADDR_VAR 0 6
13589: PUSH
13590: DOUBLE
13591: LD_INT 1
13593: DEC
13594: ST_TO_ADDR
13595: LD_VAR 0 7
13599: PUSH
13600: FOR_TO
13601: IFFALSE 13678
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13603: LD_VAR 0 8
13607: PUSH
13608: LD_VAR 0 5
13612: ARRAY
13613: PUSH
13614: LD_INT 2
13616: ARRAY
13617: PUSH
13618: LD_VAR 0 7
13622: PUSH
13623: LD_VAR 0 6
13627: ARRAY
13628: PUSH
13629: LD_INT 2
13631: ARRAY
13632: GREATER
13633: IFFALSE 13676
// begin r := Insert ( r , j , tmp [ i ] ) ;
13635: LD_ADDR_VAR 0 7
13639: PUSH
13640: LD_VAR 0 7
13644: PPUSH
13645: LD_VAR 0 6
13649: PPUSH
13650: LD_VAR 0 8
13654: PUSH
13655: LD_VAR 0 5
13659: ARRAY
13660: PPUSH
13661: CALL_OW 2
13665: ST_TO_ADDR
// add := true ;
13666: LD_ADDR_VAR 0 9
13670: PUSH
13671: LD_INT 1
13673: ST_TO_ADDR
// break ;
13674: GO 13678
// end ; end ;
13676: GO 13600
13678: POP
13679: POP
// if not add then
13680: LD_VAR 0 9
13684: NOT
13685: IFFALSE 13712
// r := r ^ [ tmp [ i ] ] ;
13687: LD_ADDR_VAR 0 7
13691: PUSH
13692: LD_VAR 0 7
13696: PUSH
13697: LD_VAR 0 8
13701: PUSH
13702: LD_VAR 0 5
13706: ARRAY
13707: PUSH
13708: EMPTY
13709: LIST
13710: ADD
13711: ST_TO_ADDR
// end ;
13712: GO 13582
13714: POP
13715: POP
// end ; result := r ;
13716: LD_ADDR_VAR 0 4
13720: PUSH
13721: LD_VAR 0 7
13725: ST_TO_ADDR
// end ;
13726: LD_VAR 0 4
13730: RET
// export function MCF_Clear ( side ) ; var i ; begin
13731: LD_INT 0
13733: PPUSH
13734: PPUSH
// for i = 1 to 100 do
13735: LD_ADDR_VAR 0 3
13739: PUSH
13740: DOUBLE
13741: LD_INT 1
13743: DEC
13744: ST_TO_ADDR
13745: LD_INT 100
13747: PUSH
13748: FOR_TO
13749: IFFALSE 13785
// if MCF_Tag ( side , i , [ ] ) then
13751: LD_VAR 0 1
13755: PPUSH
13756: LD_VAR 0 3
13760: PPUSH
13761: EMPTY
13762: PPUSH
13763: CALL 12354 0 3
13767: IFFALSE 13783
// MCF_ClearTag ( side , i ) ;
13769: LD_VAR 0 1
13773: PPUSH
13774: LD_VAR 0 3
13778: PPUSH
13779: CALL 12595 0 2
13783: GO 13748
13785: POP
13786: POP
// result := true ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 1
13794: ST_TO_ADDR
// end ;
13795: LD_VAR 0 2
13799: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13800: LD_INT 0
13802: PPUSH
13803: PPUSH
13804: PPUSH
// for i = 1 to plist do
13805: LD_ADDR_VAR 0 4
13809: PUSH
13810: DOUBLE
13811: LD_INT 1
13813: DEC
13814: ST_TO_ADDR
13815: LD_VAR 0 1
13819: PUSH
13820: FOR_TO
13821: IFFALSE 13870
// if MCF_HasClass ( plist [ i ] ) = n then
13823: LD_VAR 0 1
13827: PUSH
13828: LD_VAR 0 4
13832: ARRAY
13833: PPUSH
13834: CALL 14357 0 1
13838: PUSH
13839: LD_VAR 0 2
13843: EQUAL
13844: IFFALSE 13868
// tmp := tmp ^ plist [ i ] ;
13846: LD_ADDR_VAR 0 5
13850: PUSH
13851: LD_VAR 0 5
13855: PUSH
13856: LD_VAR 0 1
13860: PUSH
13861: LD_VAR 0 4
13865: ARRAY
13866: ADD
13867: ST_TO_ADDR
13868: GO 13820
13870: POP
13871: POP
// result := tmp ;
13872: LD_ADDR_VAR 0 3
13876: PUSH
13877: LD_VAR 0 5
13881: ST_TO_ADDR
// end ;
13882: LD_VAR 0 3
13886: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13887: LD_INT 0
13889: PPUSH
13890: PPUSH
13891: PPUSH
// if mreg = ToArm then
13892: LD_VAR 0 2
13896: PUSH
13897: LD_STRING ToArm
13899: EQUAL
13900: IFFALSE 14005
// begin tmp := MREG_ToArm [ side ] ;
13902: LD_ADDR_VAR 0 6
13906: PUSH
13907: LD_EXP 56
13911: PUSH
13912: LD_VAR 0 1
13916: ARRAY
13917: ST_TO_ADDR
// if tmp = 0 then
13918: LD_VAR 0 6
13922: PUSH
13923: LD_INT 0
13925: EQUAL
13926: IFFALSE 13932
// exit else
13928: GO 14352
13930: GO 14005
// begin for i = MREG_ToArm [ side ] downto n do
13932: LD_ADDR_VAR 0 5
13936: PUSH
13937: DOUBLE
13938: LD_EXP 56
13942: PUSH
13943: LD_VAR 0 1
13947: ARRAY
13948: INC
13949: ST_TO_ADDR
13950: LD_VAR 0 3
13954: PUSH
13955: FOR_DOWNTO
13956: IFFALSE 13978
// tmp := Delete ( tmp , 1 ) ;
13958: LD_ADDR_VAR 0 6
13962: PUSH
13963: LD_VAR 0 6
13967: PPUSH
13968: LD_INT 1
13970: PPUSH
13971: CALL_OW 3
13975: ST_TO_ADDR
13976: GO 13955
13978: POP
13979: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13980: LD_ADDR_EXP 56
13984: PUSH
13985: LD_EXP 56
13989: PPUSH
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_VAR 0 6
13999: PPUSH
14000: CALL_OW 1
14004: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14005: LD_VAR 0 2
14009: PUSH
14010: LD_STRING ToDep
14012: EQUAL
14013: IFFALSE 14118
// begin tmp := MREG_ToDep [ side ] ;
14015: LD_ADDR_VAR 0 6
14019: PUSH
14020: LD_EXP 57
14024: PUSH
14025: LD_VAR 0 1
14029: ARRAY
14030: ST_TO_ADDR
// if tmp = 0 then
14031: LD_VAR 0 6
14035: PUSH
14036: LD_INT 0
14038: EQUAL
14039: IFFALSE 14045
// exit else
14041: GO 14352
14043: GO 14118
// begin for i = MREG_ToDep [ side ] downto n do
14045: LD_ADDR_VAR 0 5
14049: PUSH
14050: DOUBLE
14051: LD_EXP 57
14055: PUSH
14056: LD_VAR 0 1
14060: ARRAY
14061: INC
14062: ST_TO_ADDR
14063: LD_VAR 0 3
14067: PUSH
14068: FOR_DOWNTO
14069: IFFALSE 14091
// tmp := Delete ( tmp , 1 ) ;
14071: LD_ADDR_VAR 0 6
14075: PUSH
14076: LD_VAR 0 6
14080: PPUSH
14081: LD_INT 1
14083: PPUSH
14084: CALL_OW 3
14088: ST_TO_ADDR
14089: GO 14068
14091: POP
14092: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14093: LD_ADDR_EXP 57
14097: PUSH
14098: LD_EXP 57
14102: PPUSH
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_VAR 0 6
14112: PPUSH
14113: CALL_OW 1
14117: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14118: LD_VAR 0 2
14122: PUSH
14123: LD_STRING ToFac
14125: EQUAL
14126: IFFALSE 14231
// begin tmp := MREG_ToFac [ side ] ;
14128: LD_ADDR_VAR 0 6
14132: PUSH
14133: LD_EXP 55
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: ST_TO_ADDR
// if tmp = 0 then
14144: LD_VAR 0 6
14148: PUSH
14149: LD_INT 0
14151: EQUAL
14152: IFFALSE 14158
// exit else
14154: GO 14352
14156: GO 14231
// begin for i = MREG_ToFac [ side ] downto n do
14158: LD_ADDR_VAR 0 5
14162: PUSH
14163: DOUBLE
14164: LD_EXP 55
14168: PUSH
14169: LD_VAR 0 1
14173: ARRAY
14174: INC
14175: ST_TO_ADDR
14176: LD_VAR 0 3
14180: PUSH
14181: FOR_DOWNTO
14182: IFFALSE 14204
// tmp := Delete ( tmp , 1 ) ;
14184: LD_ADDR_VAR 0 6
14188: PUSH
14189: LD_VAR 0 6
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 3
14201: ST_TO_ADDR
14202: GO 14181
14204: POP
14205: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14206: LD_ADDR_EXP 55
14210: PUSH
14211: LD_EXP 55
14215: PPUSH
14216: LD_VAR 0 1
14220: PPUSH
14221: LD_VAR 0 6
14225: PPUSH
14226: CALL_OW 1
14230: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14231: LD_VAR 0 2
14235: PUSH
14236: LD_STRING ToLab
14238: EQUAL
14239: IFFALSE 14344
// begin tmp := MREG_ToLab [ side ] ;
14241: LD_ADDR_VAR 0 6
14245: PUSH
14246: LD_EXP 54
14250: PUSH
14251: LD_VAR 0 1
14255: ARRAY
14256: ST_TO_ADDR
// if tmp = 0 then
14257: LD_VAR 0 6
14261: PUSH
14262: LD_INT 0
14264: EQUAL
14265: IFFALSE 14271
// exit else
14267: GO 14352
14269: GO 14344
// begin for i = MREG_ToLab [ side ] downto n do
14271: LD_ADDR_VAR 0 5
14275: PUSH
14276: DOUBLE
14277: LD_EXP 54
14281: PUSH
14282: LD_VAR 0 1
14286: ARRAY
14287: INC
14288: ST_TO_ADDR
14289: LD_VAR 0 3
14293: PUSH
14294: FOR_DOWNTO
14295: IFFALSE 14317
// tmp := Delete ( tmp , 1 ) ;
14297: LD_ADDR_VAR 0 6
14301: PUSH
14302: LD_VAR 0 6
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 3
14314: ST_TO_ADDR
14315: GO 14294
14317: POP
14318: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14319: LD_ADDR_EXP 54
14323: PUSH
14324: LD_EXP 54
14328: PPUSH
14329: LD_VAR 0 1
14333: PPUSH
14334: LD_VAR 0 6
14338: PPUSH
14339: CALL_OW 1
14343: ST_TO_ADDR
// end ; end ; result := true ;
14344: LD_ADDR_VAR 0 4
14348: PUSH
14349: LD_INT 1
14351: ST_TO_ADDR
// end ;
14352: LD_VAR 0 4
14356: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14357: LD_INT 0
14359: PPUSH
14360: PPUSH
14361: PPUSH
// side := GetSide ( unit ) ;
14362: LD_ADDR_VAR 0 4
14366: PUSH
14367: LD_VAR 0 1
14371: PPUSH
14372: CALL_OW 255
14376: ST_TO_ADDR
// tmp := 0 ;
14377: LD_ADDR_VAR 0 3
14381: PUSH
14382: LD_INT 0
14384: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14385: LD_VAR 0 1
14389: PUSH
14390: LD_EXP 56
14394: PUSH
14395: LD_VAR 0 4
14399: ARRAY
14400: IN
14401: IFFALSE 14411
// tmp := 1 ;
14403: LD_ADDR_VAR 0 3
14407: PUSH
14408: LD_INT 1
14410: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14411: LD_VAR 0 1
14415: PUSH
14416: LD_EXP 57
14420: PUSH
14421: LD_VAR 0 4
14425: ARRAY
14426: IN
14427: IFFALSE 14437
// tmp := 2 ;
14429: LD_ADDR_VAR 0 3
14433: PUSH
14434: LD_INT 2
14436: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14437: LD_VAR 0 1
14441: PUSH
14442: LD_EXP 55
14446: PUSH
14447: LD_VAR 0 4
14451: ARRAY
14452: IN
14453: IFFALSE 14463
// tmp := 3 ;
14455: LD_ADDR_VAR 0 3
14459: PUSH
14460: LD_INT 3
14462: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14463: LD_VAR 0 1
14467: PUSH
14468: LD_EXP 54
14472: PUSH
14473: LD_VAR 0 4
14477: ARRAY
14478: IN
14479: IFFALSE 14489
// tmp := 4 ;
14481: LD_ADDR_VAR 0 3
14485: PUSH
14486: LD_INT 4
14488: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 68
14498: PUSH
14499: LD_VAR 0 4
14503: ARRAY
14504: IN
14505: IFFALSE 14515
// tmp := 5 ;
14507: LD_ADDR_VAR 0 3
14511: PUSH
14512: LD_INT 5
14514: ST_TO_ADDR
// result := tmp ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_VAR 0 3
14524: ST_TO_ADDR
// end ;
14525: LD_VAR 0 2
14529: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14530: LD_INT 0
14532: PPUSH
14533: PPUSH
// if mreg = ToArm then
14534: LD_VAR 0 2
14538: PUSH
14539: LD_STRING ToArm
14541: EQUAL
14542: IFFALSE 14631
// for i = MREG_ToArm [ side ] downto 1 do
14544: LD_ADDR_VAR 0 5
14548: PUSH
14549: DOUBLE
14550: LD_EXP 56
14554: PUSH
14555: LD_VAR 0 1
14559: ARRAY
14560: INC
14561: ST_TO_ADDR
14562: LD_INT 1
14564: PUSH
14565: FOR_DOWNTO
14566: IFFALSE 14629
// if MREG_ToArm [ side ] [ i ] = unit then
14568: LD_EXP 56
14572: PUSH
14573: LD_VAR 0 1
14577: ARRAY
14578: PUSH
14579: LD_VAR 0 5
14583: ARRAY
14584: PUSH
14585: LD_VAR 0 3
14589: EQUAL
14590: IFFALSE 14627
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14592: LD_ADDR_EXP 56
14596: PUSH
14597: LD_EXP 56
14601: PPUSH
14602: LD_EXP 56
14606: PUSH
14607: LD_VAR 0 1
14611: ARRAY
14612: PUSH
14613: LD_VAR 0 5
14617: ARRAY
14618: PPUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL 31289 0 3
14626: ST_TO_ADDR
// end ;
14627: GO 14565
14629: POP
14630: POP
// if mreg = ToDep then
14631: LD_VAR 0 2
14635: PUSH
14636: LD_STRING ToDep
14638: EQUAL
14639: IFFALSE 14728
// for i = MREG_ToDep [ side ] downto 1 do
14641: LD_ADDR_VAR 0 5
14645: PUSH
14646: DOUBLE
14647: LD_EXP 57
14651: PUSH
14652: LD_VAR 0 1
14656: ARRAY
14657: INC
14658: ST_TO_ADDR
14659: LD_INT 1
14661: PUSH
14662: FOR_DOWNTO
14663: IFFALSE 14726
// if MREG_ToDep [ side ] [ i ] = unit then
14665: LD_EXP 57
14669: PUSH
14670: LD_VAR 0 1
14674: ARRAY
14675: PUSH
14676: LD_VAR 0 5
14680: ARRAY
14681: PUSH
14682: LD_VAR 0 3
14686: EQUAL
14687: IFFALSE 14724
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14689: LD_ADDR_EXP 57
14693: PUSH
14694: LD_EXP 57
14698: PPUSH
14699: LD_EXP 57
14703: PUSH
14704: LD_VAR 0 1
14708: ARRAY
14709: PUSH
14710: LD_VAR 0 5
14714: ARRAY
14715: PPUSH
14716: LD_INT 1
14718: PPUSH
14719: CALL 31289 0 3
14723: ST_TO_ADDR
// end ;
14724: GO 14662
14726: POP
14727: POP
// if mreg = ToFac then
14728: LD_VAR 0 2
14732: PUSH
14733: LD_STRING ToFac
14735: EQUAL
14736: IFFALSE 14825
// for i = MREG_ToFac [ side ] downto 1 do
14738: LD_ADDR_VAR 0 5
14742: PUSH
14743: DOUBLE
14744: LD_EXP 55
14748: PUSH
14749: LD_VAR 0 1
14753: ARRAY
14754: INC
14755: ST_TO_ADDR
14756: LD_INT 1
14758: PUSH
14759: FOR_DOWNTO
14760: IFFALSE 14823
// if MREG_ToFac [ side ] [ i ] = unit then
14762: LD_EXP 55
14766: PUSH
14767: LD_VAR 0 1
14771: ARRAY
14772: PUSH
14773: LD_VAR 0 5
14777: ARRAY
14778: PUSH
14779: LD_VAR 0 3
14783: EQUAL
14784: IFFALSE 14821
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14786: LD_ADDR_EXP 55
14790: PUSH
14791: LD_EXP 55
14795: PPUSH
14796: LD_EXP 55
14800: PUSH
14801: LD_VAR 0 1
14805: ARRAY
14806: PUSH
14807: LD_VAR 0 5
14811: ARRAY
14812: PPUSH
14813: LD_INT 1
14815: PPUSH
14816: CALL 31289 0 3
14820: ST_TO_ADDR
// end ;
14821: GO 14759
14823: POP
14824: POP
// if mreg = ToLab then
14825: LD_VAR 0 2
14829: PUSH
14830: LD_STRING ToLab
14832: EQUAL
14833: IFFALSE 14922
// for i = MREG_ToLab [ side ] downto 1 do
14835: LD_ADDR_VAR 0 5
14839: PUSH
14840: DOUBLE
14841: LD_EXP 54
14845: PUSH
14846: LD_VAR 0 1
14850: ARRAY
14851: INC
14852: ST_TO_ADDR
14853: LD_INT 1
14855: PUSH
14856: FOR_DOWNTO
14857: IFFALSE 14920
// if MREG_ToLab [ side ] [ i ] = unit then
14859: LD_EXP 54
14863: PUSH
14864: LD_VAR 0 1
14868: ARRAY
14869: PUSH
14870: LD_VAR 0 5
14874: ARRAY
14875: PUSH
14876: LD_VAR 0 3
14880: EQUAL
14881: IFFALSE 14918
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14883: LD_ADDR_EXP 54
14887: PUSH
14888: LD_EXP 54
14892: PPUSH
14893: LD_EXP 54
14897: PUSH
14898: LD_VAR 0 1
14902: ARRAY
14903: PUSH
14904: LD_VAR 0 5
14908: ARRAY
14909: PPUSH
14910: LD_INT 1
14912: PPUSH
14913: CALL 31289 0 3
14917: ST_TO_ADDR
// end ;
14918: GO 14856
14920: POP
14921: POP
// end ;
14922: LD_VAR 0 4
14926: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
// result := false ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_INT 0
14938: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14939: LD_ADDR_VAR 0 3
14943: PUSH
14944: DOUBLE
14945: LD_INT 1
14947: DEC
14948: ST_TO_ADDR
14949: LD_EXP 46
14953: PUSH
14954: FOR_TO
14955: IFFALSE 15019
// if MREG_ToBuild [ i ] [ 1 ] = side then
14957: LD_EXP 46
14961: PUSH
14962: LD_VAR 0 3
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PUSH
14972: LD_VAR 0 1
14976: EQUAL
14977: IFFALSE 15017
// begin if MREG_ToBuild [ i ] [ 1 ] then
14979: LD_EXP 46
14983: PUSH
14984: LD_VAR 0 3
14988: ARRAY
14989: PUSH
14990: LD_INT 1
14992: ARRAY
14993: IFFALSE 15017
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14995: LD_ADDR_VAR 0 2
14999: PUSH
15000: LD_EXP 46
15004: PUSH
15005: LD_VAR 0 3
15009: ARRAY
15010: PUSH
15011: LD_INT 1
15013: ARRAY
15014: ST_TO_ADDR
// break ;
15015: GO 15019
// end ; end ;
15017: GO 14954
15019: POP
15020: POP
// for i = 1 to MREG_ToRepair do
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: DOUBLE
15027: LD_INT 1
15029: DEC
15030: ST_TO_ADDR
15031: LD_EXP 47
15035: PUSH
15036: FOR_TO
15037: IFFALSE 15101
// if MREG_ToRepair [ i ] [ 1 ] = side then
15039: LD_EXP 47
15043: PUSH
15044: LD_VAR 0 3
15048: ARRAY
15049: PUSH
15050: LD_INT 1
15052: ARRAY
15053: PUSH
15054: LD_VAR 0 1
15058: EQUAL
15059: IFFALSE 15099
// begin if MREG_ToRepair [ i ] [ 1 ] then
15061: LD_EXP 47
15065: PUSH
15066: LD_VAR 0 3
15070: ARRAY
15071: PUSH
15072: LD_INT 1
15074: ARRAY
15075: IFFALSE 15099
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15077: LD_ADDR_VAR 0 2
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: LD_VAR 0 3
15091: ARRAY
15092: PUSH
15093: LD_INT 1
15095: ARRAY
15096: ST_TO_ADDR
// break ;
15097: GO 15101
// end ; end ;
15099: GO 15036
15101: POP
15102: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15103: LD_VAR 0 1
15107: PPUSH
15108: LD_INT 57
15110: PUSH
15111: EMPTY
15112: LIST
15113: PPUSH
15114: CALL 11651 0 2
15118: IFFALSE 15145
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15120: LD_ADDR_VAR 0 2
15124: PUSH
15125: LD_VAR 0 1
15129: PPUSH
15130: LD_INT 57
15132: PUSH
15133: EMPTY
15134: LIST
15135: PPUSH
15136: CALL 11651 0 2
15140: PUSH
15141: LD_INT 1
15143: ARRAY
15144: ST_TO_ADDR
// end ;
15145: LD_VAR 0 2
15149: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15150: LD_INT 0
15152: PPUSH
15153: PPUSH
15154: PPUSH
15155: PPUSH
15156: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15157: LD_ADDR_VAR 0 6
15161: PUSH
15162: LD_VAR 0 1
15166: PPUSH
15167: LD_INT 21
15169: PUSH
15170: LD_INT 3
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PPUSH
15177: CALL 11651 0 2
15181: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15182: LD_ADDR_VAR 0 7
15186: PUSH
15187: LD_VAR 0 1
15191: PPUSH
15192: LD_INT 81
15194: PUSH
15195: LD_VAR 0 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL 11651 0 2
15208: ST_TO_ADDR
// if not enemy then
15209: LD_VAR 0 7
15213: NOT
15214: IFFALSE 15226
// result := false else
15216: LD_ADDR_VAR 0 3
15220: PUSH
15221: LD_INT 0
15223: ST_TO_ADDR
15224: GO 15280
// begin scan := NearestUnit ( b , enemy ) ;
15226: LD_ADDR_VAR 0 5
15230: PUSH
15231: LD_VAR 0 6
15235: PPUSH
15236: LD_VAR 0 7
15240: PPUSH
15241: CALL 32282 0 2
15245: ST_TO_ADDR
// if scan [ 2 ] < dist then
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 2
15253: ARRAY
15254: PUSH
15255: LD_VAR 0 2
15259: LESS
15260: IFFALSE 15272
// result := true else
15262: LD_ADDR_VAR 0 3
15266: PUSH
15267: LD_INT 1
15269: ST_TO_ADDR
15270: GO 15280
// result := false ;
15272: LD_ADDR_VAR 0 3
15276: PUSH
15277: LD_INT 0
15279: ST_TO_ADDR
// end ; end ;
15280: LD_VAR 0 3
15284: RET
// export function MCF_Info ( ) ; begin
15285: LD_INT 0
15287: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15288: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15290: PUSH
15291: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15293: ADD
15294: PUSH
15295: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15297: ADD
15298: PUSH
15299: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15301: ADD
15302: PUSH
15303: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15305: ADD
15306: PUSH
15307: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15325: ADD
15326: PPUSH
15327: CALL 8569 0 1
// end ; end_of_file
15331: LD_VAR 0 1
15335: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15336: LD_INT 0
15338: PPUSH
15339: PPUSH
15340: PPUSH
15341: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15342: LD_ADDR_VAR 0 5
15346: PUSH
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_INT 2
15354: PUSH
15355: LD_INT 25
15357: PUSH
15358: LD_INT 2
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 25
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PUSH
15375: LD_INT 25
15377: PUSH
15378: LD_INT 4
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: PPUSH
15391: CALL 11651 0 2
15395: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15396: LD_ADDR_VAR 0 5
15400: PUSH
15401: LD_VAR 0 5
15405: PPUSH
15406: LD_INT 0
15408: PPUSH
15409: CALL 13800 0 2
15413: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15414: LD_ADDR_VAR 0 6
15418: PUSH
15419: LD_VAR 0 1
15423: PPUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_INT 1
15431: PPUSH
15432: CALL 13420 0 3
15436: ST_TO_ADDR
// if n > sk then
15437: LD_VAR 0 2
15441: PUSH
15442: LD_VAR 0 6
15446: GREATER
15447: IFFALSE 15459
// n := sk ;
15449: LD_ADDR_VAR 0 2
15453: PUSH
15454: LD_VAR 0 6
15458: ST_TO_ADDR
// for i = 1 to n do
15459: LD_ADDR_VAR 0 4
15463: PUSH
15464: DOUBLE
15465: LD_INT 1
15467: DEC
15468: ST_TO_ADDR
15469: LD_VAR 0 2
15473: PUSH
15474: FOR_TO
15475: IFFALSE 15587
// if ( sk [ i ] [ 1 ] ) <> 0 then
15477: LD_VAR 0 6
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: PUSH
15488: LD_INT 1
15490: ARRAY
15491: PUSH
15492: LD_INT 0
15494: NONEQUAL
15495: IFFALSE 15585
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15497: LD_ADDR_EXP 53
15501: PUSH
15502: LD_EXP 53
15506: PPUSH
15507: LD_VAR 0 1
15511: PPUSH
15512: LD_VAR 0 6
15516: PUSH
15517: LD_VAR 0 4
15521: ARRAY
15522: PUSH
15523: LD_INT 1
15525: ARRAY
15526: PPUSH
15527: LD_INT 1
15529: PPUSH
15530: CALL 41960 0 4
15534: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15535: LD_ADDR_EXP 56
15539: PUSH
15540: LD_EXP 56
15544: PPUSH
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_EXP 56
15554: PUSH
15555: LD_VAR 0 1
15559: ARRAY
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_VAR 0 6
15569: PUSH
15570: LD_VAR 0 4
15574: ARRAY
15575: PUSH
15576: LD_INT 1
15578: ARRAY
15579: PPUSH
15580: CALL 31130 0 4
15584: ST_TO_ADDR
// end ;
15585: GO 15474
15587: POP
15588: POP
// end ;
15589: LD_VAR 0 3
15593: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15600: LD_ADDR_VAR 0 5
15604: PUSH
15605: LD_VAR 0 1
15609: PPUSH
15610: LD_INT 2
15612: PUSH
15613: LD_INT 25
15615: PUSH
15616: LD_INT 1
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 25
15625: PUSH
15626: LD_INT 3
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 25
15635: PUSH
15636: LD_INT 4
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL 11651 0 2
15653: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15654: LD_ADDR_VAR 0 5
15658: PUSH
15659: LD_VAR 0 5
15663: PPUSH
15664: LD_INT 0
15666: PPUSH
15667: CALL 13800 0 2
15671: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15672: LD_ADDR_VAR 0 6
15676: PUSH
15677: LD_VAR 0 1
15681: PPUSH
15682: LD_VAR 0 5
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL 13420 0 3
15694: ST_TO_ADDR
// if n > sk then
15695: LD_VAR 0 2
15699: PUSH
15700: LD_VAR 0 6
15704: GREATER
15705: IFFALSE 15717
// n := sk ;
15707: LD_ADDR_VAR 0 2
15711: PUSH
15712: LD_VAR 0 6
15716: ST_TO_ADDR
// for i = 1 to n do
15717: LD_ADDR_VAR 0 4
15721: PUSH
15722: DOUBLE
15723: LD_INT 1
15725: DEC
15726: ST_TO_ADDR
15727: LD_VAR 0 2
15731: PUSH
15732: FOR_TO
15733: IFFALSE 15845
// if ( sk [ i ] [ 1 ] ) <> 0 then
15735: LD_VAR 0 6
15739: PUSH
15740: LD_VAR 0 4
15744: ARRAY
15745: PUSH
15746: LD_INT 1
15748: ARRAY
15749: PUSH
15750: LD_INT 0
15752: NONEQUAL
15753: IFFALSE 15843
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15755: LD_ADDR_EXP 53
15759: PUSH
15760: LD_EXP 53
15764: PPUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_VAR 0 6
15774: PUSH
15775: LD_VAR 0 4
15779: ARRAY
15780: PUSH
15781: LD_INT 1
15783: ARRAY
15784: PPUSH
15785: LD_INT 2
15787: PPUSH
15788: CALL 41960 0 4
15792: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15793: LD_ADDR_EXP 57
15797: PUSH
15798: LD_EXP 57
15802: PPUSH
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_EXP 57
15812: PUSH
15813: LD_VAR 0 1
15817: ARRAY
15818: PUSH
15819: LD_INT 1
15821: PLUS
15822: PPUSH
15823: LD_VAR 0 6
15827: PUSH
15828: LD_VAR 0 4
15832: ARRAY
15833: PUSH
15834: LD_INT 1
15836: ARRAY
15837: PPUSH
15838: CALL 31130 0 4
15842: ST_TO_ADDR
// end ;
15843: GO 15732
15845: POP
15846: POP
// end ;
15847: LD_VAR 0 3
15851: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15858: LD_ADDR_VAR 0 5
15862: PUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_INT 2
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 25
15883: PUSH
15884: LD_INT 2
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PUSH
15891: LD_INT 25
15893: PUSH
15894: LD_INT 4
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL 11651 0 2
15911: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15912: LD_ADDR_VAR 0 5
15916: PUSH
15917: LD_VAR 0 5
15921: PPUSH
15922: LD_INT 0
15924: PPUSH
15925: CALL 13800 0 2
15929: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 1
15939: PPUSH
15940: LD_VAR 0 5
15944: PPUSH
15945: LD_INT 3
15947: PPUSH
15948: CALL 13420 0 3
15952: ST_TO_ADDR
// if n > sk then
15953: LD_VAR 0 2
15957: PUSH
15958: LD_VAR 0 6
15962: GREATER
15963: IFFALSE 15975
// n := sk ;
15965: LD_ADDR_VAR 0 2
15969: PUSH
15970: LD_VAR 0 6
15974: ST_TO_ADDR
// for i = 1 to n do
15975: LD_ADDR_VAR 0 4
15979: PUSH
15980: DOUBLE
15981: LD_INT 1
15983: DEC
15984: ST_TO_ADDR
15985: LD_VAR 0 2
15989: PUSH
15990: FOR_TO
15991: IFFALSE 16103
// if ( sk [ i ] [ 1 ] ) <> 0 then
15993: LD_VAR 0 6
15997: PUSH
15998: LD_VAR 0 4
16002: ARRAY
16003: PUSH
16004: LD_INT 1
16006: ARRAY
16007: PUSH
16008: LD_INT 0
16010: NONEQUAL
16011: IFFALSE 16101
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16013: LD_ADDR_EXP 53
16017: PUSH
16018: LD_EXP 53
16022: PPUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 6
16032: PUSH
16033: LD_VAR 0 4
16037: ARRAY
16038: PUSH
16039: LD_INT 1
16041: ARRAY
16042: PPUSH
16043: LD_INT 3
16045: PPUSH
16046: CALL 41960 0 4
16050: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16051: LD_ADDR_EXP 55
16055: PUSH
16056: LD_EXP 55
16060: PPUSH
16061: LD_VAR 0 1
16065: PPUSH
16066: LD_EXP 55
16070: PUSH
16071: LD_VAR 0 1
16075: ARRAY
16076: PUSH
16077: LD_INT 1
16079: PLUS
16080: PPUSH
16081: LD_VAR 0 6
16085: PUSH
16086: LD_VAR 0 4
16090: ARRAY
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: PPUSH
16096: CALL 31130 0 4
16100: ST_TO_ADDR
// end ;
16101: GO 15990
16103: POP
16104: POP
// end ;
16105: LD_VAR 0 3
16109: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16110: LD_INT 0
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16116: LD_ADDR_VAR 0 5
16120: PUSH
16121: LD_VAR 0 1
16125: PPUSH
16126: LD_INT 2
16128: PUSH
16129: LD_INT 25
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 25
16141: PUSH
16142: LD_INT 2
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: LIST
16153: PPUSH
16154: CALL 11651 0 2
16158: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: LD_VAR 0 5
16168: PPUSH
16169: LD_INT 0
16171: PPUSH
16172: CALL 13800 0 2
16176: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16177: LD_ADDR_VAR 0 6
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: LD_VAR 0 5
16191: PPUSH
16192: LD_INT 4
16194: PPUSH
16195: CALL 13420 0 3
16199: ST_TO_ADDR
// if n > sk then
16200: LD_VAR 0 2
16204: PUSH
16205: LD_VAR 0 6
16209: GREATER
16210: IFFALSE 16222
// n := sk ;
16212: LD_ADDR_VAR 0 2
16216: PUSH
16217: LD_VAR 0 6
16221: ST_TO_ADDR
// for i = 1 to n do
16222: LD_ADDR_VAR 0 4
16226: PUSH
16227: DOUBLE
16228: LD_INT 1
16230: DEC
16231: ST_TO_ADDR
16232: LD_VAR 0 2
16236: PUSH
16237: FOR_TO
16238: IFFALSE 16350
// if ( sk [ i ] [ 1 ] ) <> 0 then
16240: LD_VAR 0 6
16244: PUSH
16245: LD_VAR 0 4
16249: ARRAY
16250: PUSH
16251: LD_INT 1
16253: ARRAY
16254: PUSH
16255: LD_INT 0
16257: NONEQUAL
16258: IFFALSE 16348
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16260: LD_ADDR_EXP 53
16264: PUSH
16265: LD_EXP 53
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: LD_VAR 0 6
16279: PUSH
16280: LD_VAR 0 4
16284: ARRAY
16285: PUSH
16286: LD_INT 1
16288: ARRAY
16289: PPUSH
16290: LD_INT 4
16292: PPUSH
16293: CALL 41960 0 4
16297: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16298: LD_ADDR_EXP 54
16302: PUSH
16303: LD_EXP 54
16307: PPUSH
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_EXP 54
16317: PUSH
16318: LD_VAR 0 1
16322: ARRAY
16323: PUSH
16324: LD_INT 1
16326: PLUS
16327: PPUSH
16328: LD_VAR 0 6
16332: PUSH
16333: LD_VAR 0 4
16337: ARRAY
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL 31130 0 4
16347: ST_TO_ADDR
// end ;
16348: GO 16237
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 3
16356: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
16362: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16363: LD_ADDR_VAR 0 6
16367: PUSH
16368: LD_VAR 0 1
16372: PPUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 25
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 25
16388: PUSH
16389: LD_INT 2
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 25
16398: PUSH
16399: LD_INT 3
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: LD_INT 25
16408: PUSH
16409: LD_INT 4
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: PPUSH
16423: CALL 11651 0 2
16427: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16428: LD_ADDR_VAR 0 6
16432: PUSH
16433: LD_VAR 0 6
16437: PPUSH
16438: LD_INT 0
16440: PPUSH
16441: CALL 13800 0 2
16445: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16446: LD_ADDR_VAR 0 7
16450: PUSH
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_VAR 0 6
16460: PPUSH
16461: LD_INT 1
16463: PPUSH
16464: CALL 13420 0 3
16468: ST_TO_ADDR
// if n > sk then
16469: LD_VAR 0 2
16473: PUSH
16474: LD_VAR 0 7
16478: GREATER
16479: IFFALSE 16491
// n := sk ;
16481: LD_ADDR_VAR 0 2
16485: PUSH
16486: LD_VAR 0 7
16490: ST_TO_ADDR
// for i = 1 to n do
16491: LD_ADDR_VAR 0 5
16495: PUSH
16496: DOUBLE
16497: LD_INT 1
16499: DEC
16500: ST_TO_ADDR
16501: LD_VAR 0 2
16505: PUSH
16506: FOR_TO
16507: IFFALSE 16551
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16509: LD_ADDR_EXP 53
16513: PUSH
16514: LD_EXP 53
16518: PPUSH
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_VAR 0 7
16528: PUSH
16529: LD_VAR 0 5
16533: ARRAY
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_VAR 0 3
16543: PPUSH
16544: CALL 41960 0 4
16548: ST_TO_ADDR
// end ;
16549: GO 16506
16551: POP
16552: POP
// end ;
16553: LD_VAR 0 4
16557: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16558: LD_INT 0
16560: PPUSH
16561: PPUSH
16562: PPUSH
// b := false ;
16563: LD_ADDR_VAR 0 6
16567: PUSH
16568: LD_INT 0
16570: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16571: LD_VAR 0 3
16575: PUSH
16576: LD_INT 1
16578: PUSH
16579: LD_INT 9
16581: PUSH
16582: LD_INT 5
16584: PUSH
16585: LD_INT 8
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: IN
16594: IFFALSE 16682
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16596: LD_VAR 0 1
16600: PPUSH
16601: LD_INT 2
16603: PUSH
16604: LD_INT 30
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 30
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL 11651 0 2
16633: IFFALSE 16682
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16635: LD_ADDR_VAR 0 6
16639: PUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: LD_INT 2
16647: PUSH
16648: LD_INT 30
16650: PUSH
16651: LD_INT 4
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: PUSH
16658: LD_INT 30
16660: PUSH
16661: LD_INT 5
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: LIST
16672: PPUSH
16673: CALL 11651 0 2
16677: PUSH
16678: LD_INT 1
16680: ARRAY
16681: ST_TO_ADDR
// if class = class_engineer then
16682: LD_VAR 0 3
16686: PUSH
16687: LD_INT 2
16689: EQUAL
16690: IFFALSE 16778
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16692: LD_VAR 0 1
16696: PPUSH
16697: LD_INT 2
16699: PUSH
16700: LD_INT 30
16702: PUSH
16703: LD_INT 0
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 30
16712: PUSH
16713: LD_INT 1
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: LIST
16724: PPUSH
16725: CALL 11651 0 2
16729: IFFALSE 16778
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16731: LD_ADDR_VAR 0 6
16735: PUSH
16736: LD_VAR 0 1
16740: PPUSH
16741: LD_INT 2
16743: PUSH
16744: LD_INT 30
16746: PUSH
16747: LD_INT 0
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: PUSH
16754: LD_INT 30
16756: PUSH
16757: LD_INT 1
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: LIST
16768: PPUSH
16769: CALL 11651 0 2
16773: PUSH
16774: LD_INT 1
16776: ARRAY
16777: ST_TO_ADDR
// if class = class_mechanic then
16778: LD_VAR 0 3
16782: PUSH
16783: LD_INT 3
16785: EQUAL
16786: IFFALSE 16856
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16788: LD_VAR 0 1
16792: PPUSH
16793: LD_INT 30
16795: PUSH
16796: LD_INT 3
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PPUSH
16803: CALL 11651 0 2
16807: IFFALSE 16856
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16809: LD_ADDR_VAR 0 6
16813: PUSH
16814: LD_VAR 0 1
16818: PPUSH
16819: LD_INT 2
16821: PUSH
16822: LD_INT 30
16824: PUSH
16825: LD_INT 2
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 30
16834: PUSH
16835: LD_INT 3
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: LIST
16846: PPUSH
16847: CALL 11651 0 2
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: ST_TO_ADDR
// if class = class_scientistic then
16856: LD_VAR 0 3
16860: PUSH
16861: LD_INT 4
16863: EQUAL
16864: IFFALSE 16974
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16866: LD_VAR 0 1
16870: PPUSH
16871: LD_INT 2
16873: PUSH
16874: LD_INT 30
16876: PUSH
16877: LD_INT 6
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: PUSH
16884: LD_INT 30
16886: PUSH
16887: LD_INT 7
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PUSH
16894: LD_INT 30
16896: PUSH
16897: LD_INT 8
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: PPUSH
16910: CALL 11651 0 2
16914: IFFALSE 16974
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16916: LD_ADDR_VAR 0 6
16920: PUSH
16921: LD_VAR 0 1
16925: PPUSH
16926: LD_INT 2
16928: PUSH
16929: LD_INT 30
16931: PUSH
16932: LD_INT 6
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 30
16941: PUSH
16942: LD_INT 7
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PUSH
16949: LD_INT 30
16951: PUSH
16952: LD_INT 8
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: PPUSH
16965: CALL 11651 0 2
16969: PUSH
16970: LD_INT 1
16972: ARRAY
16973: ST_TO_ADDR
// if GetClass ( unit ) = class then
16974: LD_VAR 0 2
16978: PPUSH
16979: CALL_OW 257
16983: PUSH
16984: LD_VAR 0 3
16988: EQUAL
16989: IFFALSE 17023
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16991: LD_ADDR_EXP 53
16995: PUSH
16996: LD_EXP 53
17000: PPUSH
17001: LD_VAR 0 1
17005: PPUSH
17006: LD_VAR 0 2
17010: PPUSH
17011: LD_VAR 0 3
17015: PPUSH
17016: CALL 42051 0 4
17020: ST_TO_ADDR
// end else
17021: GO 17116
// if b then
17023: LD_VAR 0 6
17027: IFFALSE 17108
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17029: LD_VAR 0 2
17033: PPUSH
17034: CALL_OW 310
17038: PUSH
17039: LD_VAR 0 2
17043: PPUSH
17044: CALL_OW 310
17048: PUSH
17049: LD_VAR 0 6
17053: NONEQUAL
17054: AND
17055: IFFALSE 17066
// ComExitBuilding ( unit ) ;
17057: LD_VAR 0 2
17061: PPUSH
17062: CALL_OW 122
// if not IsInUnit ( unit ) then
17066: LD_VAR 0 2
17070: PPUSH
17071: CALL_OW 310
17075: NOT
17076: IFFALSE 17092
// ComEnterUnit ( unit , b ) ;
17078: LD_VAR 0 2
17082: PPUSH
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17092: LD_VAR 0 2
17096: PPUSH
17097: LD_VAR 0 3
17101: PPUSH
17102: CALL_OW 183
// end else
17106: GO 17116
// result := false ;
17108: LD_ADDR_VAR 0 4
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// end ; end_of_file
17116: LD_VAR 0 4
17120: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17121: LD_INT 0
17123: PPUSH
17124: PPUSH
17125: PPUSH
17126: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17127: LD_ADDR_VAR 0 5
17131: PUSH
17132: LD_INT 35
17134: PUSH
17135: LD_INT 45
17137: PUSH
17138: LD_INT 46
17140: PUSH
17141: LD_INT 47
17143: PUSH
17144: LD_INT 1
17146: PUSH
17147: LD_INT 2
17149: PUSH
17150: LD_INT 48
17152: PUSH
17153: LD_INT 49
17155: PUSH
17156: LD_INT 50
17158: PUSH
17159: LD_INT 20
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: ST_TO_ADDR
// if MCF_Lab ( side ) then
17174: LD_VAR 0 1
17178: PPUSH
17179: CALL 11690 0 1
17183: IFFALSE 17422
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17185: LD_VAR 0 1
17189: PPUSH
17190: CALL 11690 0 1
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: CALL_OW 461
17203: PUSH
17204: LD_INT 2
17206: EQUAL
17207: IFFALSE 17346
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17209: LD_VAR 0 1
17213: PPUSH
17214: CALL 11690 0 1
17218: PUSH
17219: LD_INT 1
17221: ARRAY
17222: PPUSH
17223: LD_VAR 0 2
17227: PPUSH
17228: CALL 17518 0 2
17232: IFFALSE 17259
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11690 0 1
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL_OW 124
17257: GO 17346
// if MCF_Lab ( side ) > 1 then
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11690 0 1
17268: PUSH
17269: LD_INT 1
17271: GREATER
17272: IFFALSE 17346
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17274: LD_VAR 0 1
17278: PPUSH
17279: CALL 11690 0 1
17283: PUSH
17284: LD_INT 2
17286: ARRAY
17287: PPUSH
17288: CALL_OW 461
17292: PUSH
17293: LD_INT 2
17295: EQUAL
17296: IFFALSE 17346
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17298: LD_VAR 0 1
17302: PPUSH
17303: CALL 11690 0 1
17307: PUSH
17308: LD_INT 2
17310: ARRAY
17311: PPUSH
17312: LD_VAR 0 2
17316: PPUSH
17317: CALL 17518 0 2
17321: IFFALSE 17346
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17323: LD_VAR 0 1
17327: PPUSH
17328: CALL 11690 0 1
17332: PUSH
17333: LD_INT 2
17335: ARRAY
17336: PPUSH
17337: LD_VAR 0 2
17341: PPUSH
17342: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_INT 2
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 4
17359: PUSH
17360: LD_INT 3
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: LIST
17367: LIST
17368: IN
17369: IFFALSE 17422
// begin for lab in MCF_Lab ( side ) do
17371: LD_ADDR_VAR 0 6
17375: PUSH
17376: LD_VAR 0 1
17380: PPUSH
17381: CALL 11690 0 1
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17420
// if BuildingStatus ( lab ) = bs_need_ape then
17389: LD_VAR 0 6
17393: PPUSH
17394: CALL_OW 461
17398: PUSH
17399: LD_INT 10
17401: EQUAL
17402: IFFALSE 17418
// MCL_ResTame ( side , lab ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: LD_VAR 0 6
17413: PPUSH
17414: CALL 17643 0 2
17418: GO 17386
17420: POP
17421: POP
// end ; end ; end ;
17422: LD_VAR 0 3
17426: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17427: LD_INT 0
17429: PPUSH
17430: PPUSH
// tmp := [ ] ;
17431: LD_ADDR_VAR 0 3
17435: PUSH
17436: EMPTY
17437: ST_TO_ADDR
// if not lab then
17438: LD_VAR 0 1
17442: NOT
17443: IFFALSE 17455
// result := false else
17445: LD_ADDR_VAR 0 2
17449: PUSH
17450: LD_INT 0
17452: ST_TO_ADDR
17453: GO 17513
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17455: LD_ADDR_VAR 0 3
17459: PUSH
17460: LD_VAR 0 3
17464: PUSH
17465: LD_VAR 0 1
17469: PPUSH
17470: LD_INT 1
17472: PPUSH
17473: CALL_OW 268
17477: ADD
17478: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17479: LD_ADDR_VAR 0 3
17483: PUSH
17484: LD_VAR 0 3
17488: PUSH
17489: LD_VAR 0 1
17493: PPUSH
17494: LD_INT 2
17496: PPUSH
17497: CALL_OW 268
17501: ADD
17502: ST_TO_ADDR
// result := tmp ;
17503: LD_ADDR_VAR 0 2
17507: PUSH
17508: LD_VAR 0 3
17512: ST_TO_ADDR
// end ; end ;
17513: LD_VAR 0 2
17517: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17518: LD_INT 0
17520: PPUSH
17521: PPUSH
17522: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17523: LD_ADDR_VAR 0 5
17527: PUSH
17528: LD_INT 35
17530: PUSH
17531: LD_INT 45
17533: PUSH
17534: LD_INT 46
17536: PUSH
17537: LD_INT 47
17539: PUSH
17540: LD_INT 1
17542: PUSH
17543: LD_INT 2
17545: PUSH
17546: LD_INT 48
17548: PUSH
17549: LD_INT 49
17551: PUSH
17552: LD_INT 50
17554: PUSH
17555: LD_INT 20
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: ST_TO_ADDR
// if lab then
17570: LD_VAR 0 1
17574: IFFALSE 17630
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17576: LD_VAR 0 2
17580: PUSH
17581: LD_VAR 0 5
17585: IN
17586: PUSH
17587: LD_VAR 0 2
17591: PPUSH
17592: CALL_OW 481
17596: PUSH
17597: LD_VAR 0 1
17601: PPUSH
17602: CALL 17427 0 1
17606: IN
17607: OR
17608: IFFALSE 17620
// result := true else
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_INT 1
17617: ST_TO_ADDR
17618: GO 17628
// result := false ;
17620: LD_ADDR_VAR 0 3
17624: PUSH
17625: LD_INT 0
17627: ST_TO_ADDR
// end else
17628: GO 17638
// result := false ;
17630: LD_ADDR_VAR 0 3
17634: PUSH
17635: LD_INT 0
17637: ST_TO_ADDR
// end ;
17638: LD_VAR 0 3
17642: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17643: LD_INT 0
17645: PPUSH
17646: PPUSH
17647: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17648: LD_ADDR_VAR 0 4
17652: PUSH
17653: LD_VAR 0 1
17657: PPUSH
17658: LD_INT 171
17660: PPUSH
17661: EMPTY
17662: PPUSH
17663: CALL 12354 0 3
17667: ST_TO_ADDR
// if not ape then
17668: LD_VAR 0 4
17672: NOT
17673: IFFALSE 17705
// if MCF_Ape ( side ) then
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL 12064 0 1
17684: IFFALSE 17705
// ape := MCF_Ape ( side ) [ 1 ] ;
17686: LD_ADDR_VAR 0 4
17690: PUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12064 0 1
17700: PUSH
17701: LD_INT 1
17703: ARRAY
17704: ST_TO_ADDR
// if ape then
17705: LD_VAR 0 4
17709: IFFALSE 17760
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17711: LD_VAR 0 4
17715: PUSH
17716: LD_INT 1
17718: ARRAY
17719: PPUSH
17720: CALL_OW 310
17724: PUSH
17725: LD_VAR 0 4
17729: PUSH
17730: LD_INT 1
17732: ARRAY
17733: PPUSH
17734: CALL_OW 310
17738: PUSH
17739: LD_VAR 0 2
17743: NONEQUAL
17744: AND
17745: IFFALSE 17760
// ComExitBuilding ( ape [ 1 ] ) ;
17747: LD_VAR 0 4
17751: PUSH
17752: LD_INT 1
17754: ARRAY
17755: PPUSH
17756: CALL_OW 122
// if not lab then
17760: LD_VAR 0 2
17764: NOT
17765: IFFALSE 17771
// exit else
17767: GO 17919
17769: GO 17879
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17771: LD_VAR 0 1
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: LD_INT 25
17781: PUSH
17782: LD_INT 4
17784: PUSH
17785: EMPTY
17786: LIST
17787: LIST
17788: PPUSH
17789: CALL 12354 0 3
17793: PUSH
17794: LD_INT 0
17796: EQUAL
17797: PUSH
17798: LD_VAR 0 2
17802: PPUSH
17803: CALL_OW 313
17807: PUSH
17808: LD_INT 6
17810: EQUAL
17811: AND
17812: IFFALSE 17879
// begin tmp := UnitsInside ( lab ) ;
17814: LD_ADDR_VAR 0 5
17818: PUSH
17819: LD_VAR 0 2
17823: PPUSH
17824: CALL_OW 313
17828: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17829: LD_VAR 0 5
17833: PUSH
17834: LD_VAR 0 5
17838: ARRAY
17839: PPUSH
17840: LD_INT 16
17842: PPUSH
17843: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17847: LD_VAR 0 5
17851: PUSH
17852: LD_VAR 0 5
17856: ARRAY
17857: PPUSH
17858: CALL_OW 310
17862: IFFALSE 17879
// ComExitBuilding ( tmp [ tmp ] ) ;
17864: LD_VAR 0 5
17868: PUSH
17869: LD_VAR 0 5
17873: ARRAY
17874: PPUSH
17875: CALL_OW 122
// end ; if ape then
17879: LD_VAR 0 4
17883: IFFALSE 17919
// if not IsInUnit ( ape [ 1 ] ) then
17885: LD_VAR 0 4
17889: PUSH
17890: LD_INT 1
17892: ARRAY
17893: PPUSH
17894: CALL_OW 310
17898: NOT
17899: IFFALSE 17919
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: LD_VAR 0 2
17914: PPUSH
17915: CALL_OW 120
// end ;
17919: LD_VAR 0 3
17923: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17924: LD_INT 0
17926: PPUSH
17927: PPUSH
17928: PPUSH
// result := false ;
17929: LD_ADDR_VAR 0 2
17933: PUSH
17934: LD_INT 0
17936: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17937: LD_ADDR_VAR 0 3
17941: PUSH
17942: LD_VAR 0 1
17946: PPUSH
17947: CALL 18034 0 1
17951: ST_TO_ADDR
// if techs then
17952: LD_VAR 0 3
17956: IFFALSE 17986
// if techs [ 2 ] then
17958: LD_VAR 0 3
17962: PUSH
17963: LD_INT 2
17965: ARRAY
17966: IFFALSE 17978
// result := true else
17968: LD_ADDR_VAR 0 2
17972: PUSH
17973: LD_INT 1
17975: ST_TO_ADDR
17976: GO 17986
// result := false ;
17978: LD_ADDR_VAR 0 2
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// end ;
17986: LD_VAR 0 2
17990: RET
// export function MCL_Start ( side ) ; var i ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
// if MCL_GetTechList ( side ) then
17995: LD_VAR 0 1
17999: PPUSH
18000: CALL 18034 0 1
18004: IFFALSE 18029
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18006: LD_VAR 0 1
18010: PPUSH
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18034 0 1
18020: PUSH
18021: LD_INT 1
18023: ARRAY
18024: PPUSH
18025: CALL 17121 0 2
// end ;
18029: LD_VAR 0 2
18033: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18034: LD_INT 0
18036: PPUSH
18037: PPUSH
18038: PPUSH
// if MREG_ToRes then
18039: LD_EXP 50
18043: IFFALSE 18128
// for i = 1 to MREG_ToRes do
18045: LD_ADDR_VAR 0 3
18049: PUSH
18050: DOUBLE
18051: LD_INT 1
18053: DEC
18054: ST_TO_ADDR
18055: LD_EXP 50
18059: PUSH
18060: FOR_TO
18061: IFFALSE 18126
// if MREG_ToRes [ i ] [ 1 ] = side then
18063: LD_EXP 50
18067: PUSH
18068: LD_VAR 0 3
18072: ARRAY
18073: PUSH
18074: LD_INT 1
18076: ARRAY
18077: PUSH
18078: LD_VAR 0 1
18082: EQUAL
18083: IFFALSE 18124
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18085: LD_ADDR_VAR 0 4
18089: PUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: LD_VAR 0 4
18099: PUSH
18100: LD_INT 1
18102: PLUS
18103: PPUSH
18104: LD_EXP 50
18108: PUSH
18109: LD_VAR 0 3
18113: ARRAY
18114: PUSH
18115: LD_INT 2
18117: ARRAY
18118: PPUSH
18119: CALL_OW 1
18123: ST_TO_ADDR
// end ;
18124: GO 18060
18126: POP
18127: POP
// result := techs ;
18128: LD_ADDR_VAR 0 2
18132: PUSH
18133: LD_VAR 0 4
18137: ST_TO_ADDR
// end ;
18138: LD_VAR 0 2
18142: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18143: LD_INT 0
18145: PPUSH
18146: PPUSH
// for i = 1 to tech_list do
18147: LD_ADDR_VAR 0 4
18151: PUSH
18152: DOUBLE
18153: LD_INT 1
18155: DEC
18156: ST_TO_ADDR
18157: LD_VAR 0 2
18161: PUSH
18162: FOR_TO
18163: IFFALSE 18217
// if not tech_list [ i ] = 20 then
18165: LD_VAR 0 2
18169: PUSH
18170: LD_VAR 0 4
18174: ARRAY
18175: PUSH
18176: LD_INT 20
18178: EQUAL
18179: NOT
18180: IFFALSE 18215
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18182: LD_ADDR_EXP 50
18186: PUSH
18187: LD_EXP 50
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: LD_VAR 0 2
18201: PUSH
18202: LD_VAR 0 4
18206: ARRAY
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL 41960 0 4
18214: ST_TO_ADDR
18215: GO 18162
18217: POP
18218: POP
// result := true ;
18219: LD_ADDR_VAR 0 3
18223: PUSH
18224: LD_INT 1
18226: ST_TO_ADDR
// end ;
18227: LD_VAR 0 3
18231: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18232: LD_INT 0
18234: PPUSH
18235: PPUSH
// for i = MREG_ToRes downto 1 do
18236: LD_ADDR_VAR 0 3
18240: PUSH
18241: DOUBLE
18242: LD_EXP 50
18246: INC
18247: ST_TO_ADDR
18248: LD_INT 1
18250: PUSH
18251: FOR_DOWNTO
18252: IFFALSE 18298
// if MREG_ToRes [ i ] [ 1 ] = side then
18254: LD_EXP 50
18258: PUSH
18259: LD_VAR 0 3
18263: ARRAY
18264: PUSH
18265: LD_INT 1
18267: ARRAY
18268: PUSH
18269: LD_VAR 0 1
18273: EQUAL
18274: IFFALSE 18296
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18276: LD_ADDR_EXP 50
18280: PUSH
18281: LD_EXP 50
18285: PPUSH
18286: LD_VAR 0 3
18290: PPUSH
18291: CALL_OW 3
18295: ST_TO_ADDR
18296: GO 18251
18298: POP
18299: POP
// result := true ;
18300: LD_ADDR_VAR 0 2
18304: PUSH
18305: LD_INT 1
18307: ST_TO_ADDR
// end ;
18308: LD_VAR 0 2
18312: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18313: LD_INT 0
18315: PPUSH
// result := GetTechProgress ( side , tech ) ;
18316: LD_ADDR_VAR 0 3
18320: PUSH
18321: LD_VAR 0 1
18325: PPUSH
18326: LD_VAR 0 2
18330: PPUSH
18331: CALL_OW 326
18335: ST_TO_ADDR
// end ;
18336: LD_VAR 0 3
18340: RET
// export function MCL_Require ( tech ) ; begin
18341: LD_INT 0
18343: PPUSH
// result := GetTechTechsReq ( tech ) ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_VAR 0 1
18353: PPUSH
18354: CALL_OW 480
18358: ST_TO_ADDR
// end ; end_of_file
18359: LD_VAR 0 2
18363: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18364: LD_INT 0
18366: PPUSH
18367: PPUSH
18368: PPUSH
// uc_side := 0 ;
18369: LD_ADDR_OWVAR 20
18373: PUSH
18374: LD_INT 0
18376: ST_TO_ADDR
// uc_nation := 0 ;
18377: LD_ADDR_OWVAR 21
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// for i = 1 to n do
18385: LD_ADDR_VAR 0 5
18389: PUSH
18390: DOUBLE
18391: LD_INT 1
18393: DEC
18394: ST_TO_ADDR
18395: LD_VAR 0 2
18399: PUSH
18400: FOR_TO
18401: IFFALSE 18546
// begin hc_importance := 0 ;
18403: LD_ADDR_OWVAR 32
18407: PUSH
18408: LD_INT 0
18410: ST_TO_ADDR
// hc_gallery :=  ;
18411: LD_ADDR_OWVAR 33
18415: PUSH
18416: LD_STRING 
18418: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18419: LD_ADDR_OWVAR 35
18423: PUSH
18424: LD_VAR 0 3
18428: PUSH
18429: LD_INT 20
18431: MINUS
18432: PPUSH
18433: LD_VAR 0 3
18437: PUSH
18438: LD_INT 20
18440: PLUS
18441: PPUSH
18442: CALL_OW 12
18446: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18447: LD_ADDR_OWVAR 31
18451: PUSH
18452: LD_INT 0
18454: PPUSH
18455: LD_INT 2
18457: PPUSH
18458: CALL_OW 12
18462: PUSH
18463: LD_INT 0
18465: PUSH
18466: LD_INT 0
18468: PUSH
18469: LD_INT 0
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18478: LD_ADDR_OWVAR 30
18482: PUSH
18483: LD_INT 0
18485: PUSH
18486: LD_INT 0
18488: PUSH
18489: LD_INT 0
18491: PUSH
18492: LD_INT 0
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: ST_TO_ADDR
// hc_name :=  ;
18501: LD_ADDR_OWVAR 26
18505: PUSH
18506: LD_STRING 
18508: ST_TO_ADDR
// hc_class := class_apeman ;
18509: LD_ADDR_OWVAR 28
18513: PUSH
18514: LD_INT 12
18516: ST_TO_ADDR
// ape := CreateHuman ;
18517: LD_ADDR_VAR 0 6
18521: PUSH
18522: CALL_OW 44
18526: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18527: LD_VAR 0 6
18531: PPUSH
18532: LD_VAR 0 1
18536: PPUSH
18537: LD_INT 0
18539: PPUSH
18540: CALL_OW 49
// end ;
18544: GO 18400
18546: POP
18547: POP
// end ;
18548: LD_VAR 0 4
18552: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18553: LD_INT 0
18555: PPUSH
18556: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18557: LD_VAR 0 1
18561: PPUSH
18562: CALL 12064 0 1
18566: PUSH
18567: LD_EXP 37
18571: PUSH
18572: LD_VAR 0 1
18576: ARRAY
18577: GREATEREQUAL
18578: IFFALSE 18755
// begin if GetTag ( unit ) = 17 then
18580: LD_VAR 0 2
18584: PPUSH
18585: CALL_OW 110
18589: PUSH
18590: LD_INT 17
18592: EQUAL
18593: IFFALSE 18753
// begin SetTag ( unit , 0 ) ;
18595: LD_VAR 0 2
18599: PPUSH
18600: LD_INT 0
18602: PPUSH
18603: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL 11690 0 1
18616: PUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL 18034 0 1
18626: NOT
18627: AND
18628: IFFALSE 18653
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18630: LD_VAR 0 2
18634: PPUSH
18635: LD_VAR 0 1
18639: PPUSH
18640: CALL 11690 0 1
18644: PUSH
18645: LD_INT 1
18647: ARRAY
18648: PPUSH
18649: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18653: LD_VAR 0 1
18657: PPUSH
18658: CALL 11690 0 1
18662: NOT
18663: PUSH
18664: LD_VAR 0 1
18668: PPUSH
18669: LD_INT 30
18671: PUSH
18672: LD_INT 1
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL 11651 0 2
18683: AND
18684: IFFALSE 18753
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18686: LD_VAR 0 2
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 1
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PPUSH
18706: CALL 11651 0 2
18710: PUSH
18711: LD_INT 1
18713: ARRAY
18714: PPUSH
18715: CALL_OW 250
18719: PPUSH
18720: LD_VAR 0 1
18724: PPUSH
18725: LD_INT 30
18727: PUSH
18728: LD_INT 1
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL 11651 0 2
18739: PUSH
18740: LD_INT 1
18742: ARRAY
18743: PPUSH
18744: CALL_OW 251
18748: PPUSH
18749: CALL_OW 111
// end ; end else
18753: GO 18939
// if GetClass ( unit ) <> 4 then
18755: LD_VAR 0 2
18759: PPUSH
18760: CALL_OW 257
18764: PUSH
18765: LD_INT 4
18767: NONEQUAL
18768: IFFALSE 18774
// exit else
18770: GO 18939
18772: GO 18939
// if GetTag ( unit ) = 0 then
18774: LD_VAR 0 2
18778: PPUSH
18779: CALL_OW 110
18783: PUSH
18784: LD_INT 0
18786: EQUAL
18787: IFFALSE 18803
// SetTag ( unit , 17 ) else
18789: LD_VAR 0 2
18793: PPUSH
18794: LD_INT 17
18796: PPUSH
18797: CALL_OW 109
18801: GO 18939
// begin if IsInUnit ( unit ) then
18803: LD_VAR 0 2
18807: PPUSH
18808: CALL_OW 310
18812: IFFALSE 18823
// ComExitBuilding ( unit ) ;
18814: LD_VAR 0 2
18818: PPUSH
18819: CALL_OW 122
// Wait ( 1 ) ;
18823: LD_INT 1
18825: PPUSH
18826: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18830: LD_ADDR_VAR 0 4
18834: PUSH
18835: LD_INT 22
18837: PUSH
18838: LD_INT 0
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 25
18847: PUSH
18848: LD_INT 12
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PPUSH
18859: CALL_OW 69
18863: PPUSH
18864: LD_VAR 0 2
18868: PPUSH
18869: CALL_OW 74
18873: ST_TO_ADDR
// if not ape then
18874: LD_VAR 0 4
18878: NOT
18879: IFFALSE 18885
// exit else
18881: GO 18939
18883: GO 18894
// ComHold ( ape ) ;
18885: LD_VAR 0 4
18889: PPUSH
18890: CALL_OW 140
// if not HasTask ( unit ) then
18894: LD_VAR 0 2
18898: PPUSH
18899: CALL_OW 314
18903: NOT
18904: IFFALSE 18937
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18906: LD_VAR 0 2
18910: PPUSH
18911: LD_VAR 0 4
18915: PPUSH
18916: CALL_OW 250
18920: PPUSH
18921: LD_VAR 0 4
18925: PPUSH
18926: CALL_OW 251
18930: PPUSH
18931: CALL_OW 131
18935: GO 18939
// exit ;
18937: GO 18939
// end ; end ;
18939: LD_VAR 0 3
18943: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18944: LD_INT 0
18946: PPUSH
18947: PPUSH
18948: PPUSH
18949: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18950: LD_ADDR_VAR 0 4
18954: PUSH
18955: LD_EXP 38
18959: PUSH
18960: LD_VAR 0 1
18964: ARRAY
18965: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18966: LD_ADDR_VAR 0 5
18970: PUSH
18971: LD_VAR 0 1
18975: PPUSH
18976: LD_STRING normal
18978: PPUSH
18979: CALL 12148 0 2
18983: ST_TO_ADDR
// if apes then
18984: LD_VAR 0 5
18988: IFFALSE 19216
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18990: LD_INT 2
18992: PPUSH
18993: LD_VAR 0 1
18997: PPUSH
18998: CALL_OW 321
19002: PUSH
19003: LD_INT 2
19005: EQUAL
19006: PUSH
19007: LD_VAR 0 4
19011: PUSH
19012: LD_INT 2
19014: ARRAY
19015: PUSH
19016: LD_INT 1
19018: EQUAL
19019: AND
19020: PUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: LD_STRING engineer
19028: PPUSH
19029: CALL 12148 0 2
19033: PUSH
19034: LD_INT 3
19036: LESS
19037: AND
19038: PUSH
19039: LD_VAR 0 1
19043: PPUSH
19044: LD_INT 30
19046: PUSH
19047: LD_INT 1
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PPUSH
19054: CALL 11651 0 2
19058: AND
19059: IFFALSE 19113
// begin for i in apes do
19061: LD_ADDR_VAR 0 3
19065: PUSH
19066: LD_VAR 0 5
19070: PUSH
19071: FOR_IN
19072: IFFALSE 19109
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19074: LD_VAR 0 3
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: LD_INT 30
19086: PUSH
19087: LD_INT 1
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: PPUSH
19094: CALL 11651 0 2
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: CALL_OW 120
// end ;
19107: GO 19071
19109: POP
19110: POP
// end else
19111: GO 19216
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19113: LD_INT 11
19115: PPUSH
19116: LD_VAR 0 1
19120: PPUSH
19121: CALL_OW 321
19125: PUSH
19126: LD_INT 2
19128: EQUAL
19129: PUSH
19130: LD_VAR 0 4
19134: PUSH
19135: LD_INT 1
19137: ARRAY
19138: PUSH
19139: LD_INT 1
19141: EQUAL
19142: AND
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: LD_INT 30
19151: PUSH
19152: LD_INT 5
19154: PUSH
19155: EMPTY
19156: LIST
19157: LIST
19158: PPUSH
19159: CALL 11651 0 2
19163: AND
19164: IFFALSE 19216
// begin for i in apes do
19166: LD_ADDR_VAR 0 3
19170: PUSH
19171: LD_VAR 0 5
19175: PUSH
19176: FOR_IN
19177: IFFALSE 19214
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19179: LD_VAR 0 3
19183: PPUSH
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 30
19191: PUSH
19192: LD_INT 5
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: PPUSH
19199: CALL 11651 0 2
19203: PUSH
19204: LD_INT 1
19206: ARRAY
19207: PPUSH
19208: CALL_OW 120
// end ;
19212: GO 19176
19214: POP
19215: POP
// end ; end ; end ; end_of_file
19216: LD_VAR 0 2
19220: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19221: LD_INT 0
19223: PPUSH
19224: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19225: LD_VAR 0 1
19229: PPUSH
19230: CALL_OW 257
19234: PUSH
19235: LD_INT 4
19237: EQUAL
19238: NOT
19239: PUSH
19240: LD_VAR 0 2
19244: NOT
19245: OR
19246: IFFALSE 19252
// exit else
19248: GO 19286
19250: GO 19286
// if not GetTag ( unit ) = 4 then
19252: LD_VAR 0 1
19256: PPUSH
19257: CALL_OW 110
19261: PUSH
19262: LD_INT 4
19264: EQUAL
19265: NOT
19266: IFFALSE 19272
// exit else
19268: GO 19286
19270: GO 19286
// ComHeal ( unit , target ) ;
19272: LD_VAR 0 1
19276: PPUSH
19277: LD_VAR 0 2
19281: PPUSH
19282: CALL_OW 128
// end ;
19286: LD_VAR 0 3
19290: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19291: LD_INT 0
19293: PPUSH
19294: PPUSH
19295: PPUSH
19296: PPUSH
19297: PPUSH
19298: PPUSH
19299: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19300: LD_ADDR_VAR 0 5
19304: PUSH
19305: LD_INT 22
19307: PUSH
19308: LD_VAR 0 1
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 21
19319: PUSH
19320: LD_INT 1
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: PUSH
19327: LD_INT 3
19329: PUSH
19330: LD_INT 55
19332: PUSH
19333: EMPTY
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PUSH
19340: LD_INT 3
19342: PUSH
19343: LD_INT 54
19345: PUSH
19346: EMPTY
19347: LIST
19348: PUSH
19349: EMPTY
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 3
19355: PUSH
19356: LD_INT 24
19358: PUSH
19359: LD_INT 1000
19361: PUSH
19362: EMPTY
19363: LIST
19364: LIST
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: PPUSH
19377: CALL_OW 69
19381: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19382: LD_ADDR_VAR 0 8
19386: PUSH
19387: LD_VAR 0 1
19391: PPUSH
19392: LD_INT 30
19394: PUSH
19395: LD_INT 1
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: PPUSH
19402: CALL 11651 0 2
19406: ST_TO_ADDR
// r := [ ] ;
19407: LD_ADDR_VAR 0 6
19411: PUSH
19412: EMPTY
19413: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19414: LD_VAR 0 1
19418: PPUSH
19419: LD_INT 5
19421: PPUSH
19422: EMPTY
19423: PPUSH
19424: CALL 12354 0 3
19428: IFFALSE 19484
// for j in MCF_Tag ( side , 5 , [ ] ) do
19430: LD_ADDR_VAR 0 4
19434: PUSH
19435: LD_VAR 0 1
19439: PPUSH
19440: LD_INT 5
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL 12354 0 3
19449: PUSH
19450: FOR_IN
19451: IFFALSE 19482
// if GetLives ( j ) = 1000 then
19453: LD_VAR 0 4
19457: PPUSH
19458: CALL_OW 256
19462: PUSH
19463: LD_INT 1000
19465: EQUAL
19466: IFFALSE 19480
// SetTag ( j , 0 ) ;
19468: LD_VAR 0 4
19472: PPUSH
19473: LD_INT 0
19475: PPUSH
19476: CALL_OW 109
19480: GO 19450
19482: POP
19483: POP
// if tmp then
19484: LD_VAR 0 5
19488: IFFALSE 19817
// begin r := [ tmp [ 1 ] ] ;
19490: LD_ADDR_VAR 0 6
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_INT 1
19502: ARRAY
19503: PUSH
19504: EMPTY
19505: LIST
19506: ST_TO_ADDR
// for i = 2 to tmp do
19507: LD_ADDR_VAR 0 3
19511: PUSH
19512: DOUBLE
19513: LD_INT 2
19515: DEC
19516: ST_TO_ADDR
19517: LD_VAR 0 5
19521: PUSH
19522: FOR_TO
19523: IFFALSE 19815
// begin m := false ;
19525: LD_ADDR_VAR 0 7
19529: PUSH
19530: LD_INT 0
19532: ST_TO_ADDR
// if d then
19533: LD_VAR 0 8
19537: IFFALSE 19692
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19539: LD_VAR 0 5
19543: PUSH
19544: LD_VAR 0 3
19548: ARRAY
19549: PPUSH
19550: CALL_OW 256
19554: PUSH
19555: LD_INT 650
19557: LESS
19558: PUSH
19559: LD_VAR 0 5
19563: PUSH
19564: LD_VAR 0 3
19568: ARRAY
19569: PPUSH
19570: LD_VAR 0 8
19574: PUSH
19575: LD_INT 1
19577: ARRAY
19578: PPUSH
19579: CALL_OW 250
19583: PPUSH
19584: LD_VAR 0 8
19588: PUSH
19589: LD_INT 1
19591: ARRAY
19592: PPUSH
19593: CALL_OW 251
19597: PPUSH
19598: CALL_OW 297
19602: PUSH
19603: LD_INT 10
19605: GREATER
19606: AND
19607: IFFALSE 19692
// begin if not GetTag ( tmp [ i ] ) = 5 then
19609: LD_VAR 0 5
19613: PUSH
19614: LD_VAR 0 3
19618: ARRAY
19619: PPUSH
19620: CALL_OW 110
19624: PUSH
19625: LD_INT 5
19627: EQUAL
19628: NOT
19629: IFFALSE 19649
// SetTag ( tmp [ i ] , 5 ) ;
19631: LD_VAR 0 5
19635: PUSH
19636: LD_VAR 0 3
19640: ARRAY
19641: PPUSH
19642: LD_INT 5
19644: PPUSH
19645: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19649: LD_VAR 0 5
19653: PUSH
19654: LD_VAR 0 3
19658: ARRAY
19659: PPUSH
19660: LD_VAR 0 8
19664: PUSH
19665: LD_INT 1
19667: ARRAY
19668: PPUSH
19669: CALL_OW 250
19673: PPUSH
19674: LD_VAR 0 8
19678: PUSH
19679: LD_INT 1
19681: ARRAY
19682: PPUSH
19683: CALL_OW 251
19687: PPUSH
19688: CALL_OW 111
// end ; for j = 1 to r do
19692: LD_ADDR_VAR 0 4
19696: PUSH
19697: DOUBLE
19698: LD_INT 1
19700: DEC
19701: ST_TO_ADDR
19702: LD_VAR 0 6
19706: PUSH
19707: FOR_TO
19708: IFFALSE 19782
// if GetLives ( tmp [ i ] ) < r [ j ] then
19710: LD_VAR 0 5
19714: PUSH
19715: LD_VAR 0 3
19719: ARRAY
19720: PPUSH
19721: CALL_OW 256
19725: PUSH
19726: LD_VAR 0 6
19730: PUSH
19731: LD_VAR 0 4
19735: ARRAY
19736: LESS
19737: IFFALSE 19780
// begin r := Insert ( r , j , tmp [ i ] ) ;
19739: LD_ADDR_VAR 0 6
19743: PUSH
19744: LD_VAR 0 6
19748: PPUSH
19749: LD_VAR 0 4
19753: PPUSH
19754: LD_VAR 0 5
19758: PUSH
19759: LD_VAR 0 3
19763: ARRAY
19764: PPUSH
19765: CALL_OW 2
19769: ST_TO_ADDR
// m := true ;
19770: LD_ADDR_VAR 0 7
19774: PUSH
19775: LD_INT 1
19777: ST_TO_ADDR
// break ;
19778: GO 19782
// end ;
19780: GO 19707
19782: POP
19783: POP
// if not m then
19784: LD_VAR 0 7
19788: NOT
19789: IFFALSE 19813
// r := r ^ tmp [ i ] ;
19791: LD_ADDR_VAR 0 6
19795: PUSH
19796: LD_VAR 0 6
19800: PUSH
19801: LD_VAR 0 5
19805: PUSH
19806: LD_VAR 0 3
19810: ARRAY
19811: ADD
19812: ST_TO_ADDR
// end ;
19813: GO 19522
19815: POP
19816: POP
// end ; result := r end ; end_of_file
19817: LD_ADDR_VAR 0 2
19821: PUSH
19822: LD_VAR 0 6
19826: ST_TO_ADDR
19827: LD_VAR 0 2
19831: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19832: LD_INT 0
19834: PPUSH
19835: PPUSH
19836: PPUSH
// pom := GetBase ( bdepot ) ;
19837: LD_ADDR_VAR 0 3
19841: PUSH
19842: LD_VAR 0 1
19846: PPUSH
19847: CALL_OW 274
19851: ST_TO_ADDR
// sor := [ ] ;
19852: LD_ADDR_VAR 0 4
19856: PUSH
19857: EMPTY
19858: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19859: LD_ADDR_VAR 0 4
19863: PUSH
19864: LD_VAR 0 4
19868: PUSH
19869: LD_VAR 0 3
19873: PPUSH
19874: LD_INT 1
19876: PPUSH
19877: CALL_OW 275
19881: ADD
19882: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19883: LD_ADDR_VAR 0 4
19887: PUSH
19888: LD_VAR 0 4
19892: PUSH
19893: LD_VAR 0 3
19897: PPUSH
19898: LD_INT 2
19900: PPUSH
19901: CALL_OW 275
19905: ADD
19906: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19907: LD_ADDR_VAR 0 4
19911: PUSH
19912: LD_VAR 0 4
19916: PUSH
19917: LD_VAR 0 3
19921: PPUSH
19922: LD_INT 3
19924: PPUSH
19925: CALL_OW 275
19929: ADD
19930: ST_TO_ADDR
// result := sor ;
19931: LD_ADDR_VAR 0 2
19935: PUSH
19936: LD_VAR 0 4
19940: ST_TO_ADDR
// end ;
19941: LD_VAR 0 2
19945: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19946: LD_INT 0
19948: PPUSH
19949: PPUSH
// while ( coord_list ) do
19950: LD_VAR 0 3
19954: IFFALSE 20128
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19956: LD_ADDR_EXP 46
19960: PUSH
19961: LD_EXP 46
19965: PPUSH
19966: LD_VAR 0 1
19970: PPUSH
19971: LD_VAR 0 2
19975: PPUSH
19976: LD_VAR 0 3
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PUSH
19985: LD_VAR 0 3
19989: PUSH
19990: LD_INT 2
19992: ARRAY
19993: PUSH
19994: LD_VAR 0 3
19998: PUSH
19999: LD_INT 3
20001: ARRAY
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: PPUSH
20008: CALL 41960 0 4
20012: ST_TO_ADDR
// if weapon_list then
20013: LD_VAR 0 4
20017: IFFALSE 20088
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20019: LD_ADDR_EXP 43
20023: PUSH
20024: LD_EXP 43
20028: PPUSH
20029: LD_VAR 0 1
20033: PPUSH
20034: LD_VAR 0 4
20038: PUSH
20039: LD_INT 1
20041: ARRAY
20042: PPUSH
20043: LD_VAR 0 3
20047: PUSH
20048: LD_INT 1
20050: ARRAY
20051: PUSH
20052: LD_VAR 0 3
20056: PUSH
20057: LD_INT 2
20059: ARRAY
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PPUSH
20065: CALL 41960 0 4
20069: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20070: LD_ADDR_VAR 0 4
20074: PUSH
20075: LD_VAR 0 4
20079: PPUSH
20080: LD_INT 1
20082: PPUSH
20083: CALL_OW 3
20087: ST_TO_ADDR
// end ; for i = 1 to 3 do
20088: LD_ADDR_VAR 0 6
20092: PUSH
20093: DOUBLE
20094: LD_INT 1
20096: DEC
20097: ST_TO_ADDR
20098: LD_INT 3
20100: PUSH
20101: FOR_TO
20102: IFFALSE 20124
// coord_list := Delete ( coord_list , 1 ) ;
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_VAR 0 3
20113: PPUSH
20114: LD_INT 1
20116: PPUSH
20117: CALL_OW 3
20121: ST_TO_ADDR
20122: GO 20101
20124: POP
20125: POP
// end ;
20126: GO 19950
// result := true ;
20128: LD_ADDR_VAR 0 5
20132: PUSH
20133: LD_INT 1
20135: ST_TO_ADDR
// end ;
20136: LD_VAR 0 5
20140: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20141: LD_INT 0
20143: PPUSH
20144: PPUSH
// if not weapon_list then
20145: LD_VAR 0 3
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20269
// while ( coord_list ) do
20154: LD_VAR 0 2
20158: IFFALSE 20269
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20160: LD_ADDR_EXP 43
20164: PUSH
20165: LD_EXP 43
20169: PPUSH
20170: LD_VAR 0 1
20174: PPUSH
20175: LD_VAR 0 3
20179: PUSH
20180: LD_INT 1
20182: ARRAY
20183: PPUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_INT 1
20191: ARRAY
20192: PUSH
20193: LD_VAR 0 2
20197: PUSH
20198: LD_INT 2
20200: ARRAY
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PPUSH
20206: CALL 41960 0 4
20210: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20211: LD_ADDR_VAR 0 3
20215: PUSH
20216: LD_VAR 0 3
20220: PPUSH
20221: LD_INT 1
20223: PPUSH
20224: CALL_OW 3
20228: ST_TO_ADDR
// for i = 1 to 2 do
20229: LD_ADDR_VAR 0 5
20233: PUSH
20234: DOUBLE
20235: LD_INT 1
20237: DEC
20238: ST_TO_ADDR
20239: LD_INT 2
20241: PUSH
20242: FOR_TO
20243: IFFALSE 20265
// coord_list := Delete ( coord_list , 1 ) ;
20245: LD_ADDR_VAR 0 2
20249: PUSH
20250: LD_VAR 0 2
20254: PPUSH
20255: LD_INT 1
20257: PPUSH
20258: CALL_OW 3
20262: ST_TO_ADDR
20263: GO 20242
20265: POP
20266: POP
// end ;
20267: GO 20154
// end ;
20269: LD_VAR 0 4
20273: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
// while ( coord_list ) do
20278: LD_VAR 0 2
20282: IFFALSE 20437
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20284: LD_VAR 0 2
20288: PUSH
20289: LD_INT 1
20291: ARRAY
20292: PPUSH
20293: LD_VAR 0 2
20297: PUSH
20298: LD_INT 2
20300: ARRAY
20301: PPUSH
20302: CALL_OW 428
20306: IFFALSE 20397
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 2
20321: PUSH
20322: LD_INT 2
20324: ARRAY
20325: PPUSH
20326: CALL_OW 428
20330: PPUSH
20331: CALL_OW 266
20335: PUSH
20336: LD_INT 31
20338: PUSH
20339: LD_INT 32
20341: PUSH
20342: LD_INT 33
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: LIST
20349: IN
20350: IFFALSE 20397
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20352: LD_ADDR_EXP 52
20356: PUSH
20357: LD_EXP 52
20361: PPUSH
20362: LD_VAR 0 1
20366: PPUSH
20367: LD_VAR 0 2
20371: PUSH
20372: LD_INT 1
20374: ARRAY
20375: PPUSH
20376: LD_VAR 0 2
20380: PUSH
20381: LD_INT 2
20383: ARRAY
20384: PPUSH
20385: CALL_OW 428
20389: PPUSH
20390: EMPTY
20391: PPUSH
20392: CALL 41960 0 4
20396: ST_TO_ADDR
// for i = 1 to 3 do
20397: LD_ADDR_VAR 0 4
20401: PUSH
20402: DOUBLE
20403: LD_INT 1
20405: DEC
20406: ST_TO_ADDR
20407: LD_INT 3
20409: PUSH
20410: FOR_TO
20411: IFFALSE 20433
// coord_list := Delete ( coord_list , 1 ) ;
20413: LD_ADDR_VAR 0 2
20417: PUSH
20418: LD_VAR 0 2
20422: PPUSH
20423: LD_INT 1
20425: PPUSH
20426: CALL_OW 3
20430: ST_TO_ADDR
20431: GO 20410
20433: POP
20434: POP
// end ;
20435: GO 20278
// result := true ;
20437: LD_ADDR_VAR 0 3
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 3
20449: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20450: LD_INT 0
20452: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20453: LD_ADDR_EXP 46
20457: PUSH
20458: LD_EXP 46
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_INT 0
20470: PPUSH
20471: LD_VAR 0 2
20475: PPUSH
20476: CALL 41960 0 4
20480: ST_TO_ADDR
// end ;
20481: LD_VAR 0 3
20485: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20486: LD_INT 0
20488: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20489: LD_ADDR_EXP 46
20493: PUSH
20494: LD_EXP 46
20498: PPUSH
20499: LD_VAR 0 1
20503: PPUSH
20504: LD_INT 6
20506: PPUSH
20507: LD_VAR 0 2
20511: PPUSH
20512: CALL 41960 0 4
20516: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20517: LD_ADDR_EXP 49
20521: PUSH
20522: LD_EXP 49
20526: PPUSH
20527: LD_VAR 0 1
20531: PPUSH
20532: LD_VAR 0 3
20536: PUSH
20537: LD_INT 1
20539: ARRAY
20540: PPUSH
20541: LD_VAR 0 3
20545: PUSH
20546: LD_INT 2
20548: ARRAY
20549: PPUSH
20550: CALL 41960 0 4
20554: ST_TO_ADDR
// end ;
20555: LD_VAR 0 4
20559: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20560: LD_INT 0
20562: PPUSH
20563: PPUSH
// if ext_list > 5 then
20564: LD_VAR 0 3
20568: PUSH
20569: LD_INT 5
20571: GREATER
20572: IFFALSE 20616
// for i = 6 to ext_list do
20574: LD_ADDR_VAR 0 5
20578: PUSH
20579: DOUBLE
20580: LD_INT 6
20582: DEC
20583: ST_TO_ADDR
20584: LD_VAR 0 3
20588: PUSH
20589: FOR_TO
20590: IFFALSE 20614
// ext_list := Delete ( ext_list , ext_list ) ;
20592: LD_ADDR_VAR 0 3
20596: PUSH
20597: LD_VAR 0 3
20601: PPUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: CALL_OW 3
20611: ST_TO_ADDR
20612: GO 20589
20614: POP
20615: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20616: LD_VAR 0 1
20620: PPUSH
20621: LD_VAR 0 2
20625: PUSH
20626: LD_INT 1
20628: ARRAY
20629: PPUSH
20630: LD_VAR 0 2
20634: PUSH
20635: LD_INT 2
20637: ARRAY
20638: PPUSH
20639: LD_VAR 0 2
20643: PUSH
20644: LD_INT 3
20646: ARRAY
20647: PPUSH
20648: LD_VAR 0 3
20652: PPUSH
20653: CALL 9163 0 5
// end ;
20657: LD_VAR 0 4
20661: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20662: LD_INT 0
20664: PPUSH
20665: PPUSH
20666: PPUSH
// p := 1 ;
20667: LD_ADDR_VAR 0 6
20671: PUSH
20672: LD_INT 1
20674: ST_TO_ADDR
// if type_list = [ ] then
20675: LD_VAR 0 3
20679: PUSH
20680: EMPTY
20681: EQUAL
20682: IFFALSE 20692
// type_list := b_oil_power ;
20684: LD_ADDR_VAR 0 3
20688: PUSH
20689: LD_INT 26
20691: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20692: LD_ADDR_VAR 0 5
20696: PUSH
20697: DOUBLE
20698: LD_INT 1
20700: DEC
20701: ST_TO_ADDR
20702: LD_VAR 0 2
20706: PUSH
20707: LD_INT 3
20709: DIVREAL
20710: PUSH
20711: FOR_TO
20712: IFFALSE 20815
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20714: LD_ADDR_EXP 46
20718: PUSH
20719: LD_EXP 46
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: LD_VAR 0 3
20733: PUSH
20734: LD_INT 1
20736: PPUSH
20737: LD_VAR 0 3
20741: PPUSH
20742: CALL_OW 12
20746: ARRAY
20747: PPUSH
20748: LD_VAR 0 2
20752: PUSH
20753: LD_VAR 0 6
20757: ARRAY
20758: PUSH
20759: LD_VAR 0 2
20763: PUSH
20764: LD_VAR 0 6
20768: PUSH
20769: LD_INT 1
20771: PLUS
20772: ARRAY
20773: PUSH
20774: LD_VAR 0 2
20778: PUSH
20779: LD_VAR 0 6
20783: PUSH
20784: LD_INT 2
20786: PLUS
20787: ARRAY
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: PPUSH
20794: CALL 41960 0 4
20798: ST_TO_ADDR
// p := p + 3 ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_VAR 0 6
20808: PUSH
20809: LD_INT 3
20811: PLUS
20812: ST_TO_ADDR
// end ;
20813: GO 20711
20815: POP
20816: POP
// end ;
20817: LD_VAR 0 4
20821: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20822: LD_INT 0
20824: PPUSH
20825: PPUSH
20826: PPUSH
20827: PPUSH
// if not MREG_Deposit [ side ] then
20828: LD_EXP 61
20832: PUSH
20833: LD_VAR 0 1
20837: ARRAY
20838: NOT
20839: IFFALSE 20843
// exit ;
20841: GO 21020
// p := 1 ;
20843: LD_ADDR_VAR 0 4
20847: PUSH
20848: LD_INT 1
20850: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20851: LD_ADDR_VAR 0 3
20855: PUSH
20856: DOUBLE
20857: LD_INT 1
20859: DEC
20860: ST_TO_ADDR
20861: LD_EXP 61
20865: PUSH
20866: LD_VAR 0 1
20870: ARRAY
20871: PUSH
20872: LD_INT 3
20874: DIVREAL
20875: PUSH
20876: FOR_TO
20877: IFFALSE 21018
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20879: LD_EXP 61
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: PUSH
20895: LD_INT 2
20897: PLUS
20898: ARRAY
20899: PUSH
20900: LD_INT 2
20902: EQUAL
20903: IFFALSE 20915
// b := b_oil_mine else
20905: LD_ADDR_VAR 0 5
20909: PUSH
20910: LD_INT 29
20912: ST_TO_ADDR
20913: GO 20923
// b := b_siberite_mine ;
20915: LD_ADDR_VAR 0 5
20919: PUSH
20920: LD_INT 30
20922: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20923: LD_ADDR_EXP 46
20927: PUSH
20928: LD_EXP 46
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_VAR 0 5
20942: PPUSH
20943: LD_EXP 61
20947: PUSH
20948: LD_VAR 0 1
20952: ARRAY
20953: PUSH
20954: LD_VAR 0 4
20958: ARRAY
20959: PUSH
20960: LD_EXP 61
20964: PUSH
20965: LD_VAR 0 1
20969: ARRAY
20970: PUSH
20971: LD_VAR 0 4
20975: PUSH
20976: LD_INT 1
20978: PLUS
20979: ARRAY
20980: PUSH
20981: LD_INT 0
20983: PPUSH
20984: LD_INT 5
20986: PPUSH
20987: CALL_OW 12
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: LIST
20996: PPUSH
20997: CALL 41960 0 4
21001: ST_TO_ADDR
// p := p + 3 ;
21002: LD_ADDR_VAR 0 4
21006: PUSH
21007: LD_VAR 0 4
21011: PUSH
21012: LD_INT 3
21014: PLUS
21015: ST_TO_ADDR
// end ;
21016: GO 20876
21018: POP
21019: POP
// end ;
21020: LD_VAR 0 2
21024: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21025: LD_INT 0
21027: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21028: LD_ADDR_EXP 46
21032: PUSH
21033: LD_EXP 46
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: LD_INT 4
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: CALL 41960 0 4
21055: ST_TO_ADDR
// end ;
21056: LD_VAR 0 3
21060: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21061: LD_INT 0
21063: PPUSH
// case nation of 1 , us :
21064: LD_VAR 0 2
21068: PUSH
21069: LD_INT 1
21071: DOUBLE
21072: EQUAL
21073: IFTRUE 21083
21075: LD_STRING us
21077: DOUBLE
21078: EQUAL
21079: IFTRUE 21083
21081: GO 21114
21083: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21084: LD_ADDR_EXP 46
21088: PUSH
21089: LD_EXP 46
21093: PPUSH
21094: LD_VAR 0 1
21098: PPUSH
21099: LD_INT 36
21101: PPUSH
21102: LD_VAR 0 3
21106: PPUSH
21107: CALL 41960 0 4
21111: ST_TO_ADDR
21112: GO 21165
21114: LD_INT 2
21116: DOUBLE
21117: EQUAL
21118: IFTRUE 21128
21120: LD_STRING ar
21122: DOUBLE
21123: EQUAL
21124: IFTRUE 21128
21126: GO 21164
21128: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21129: LD_ADDR_EXP 46
21133: PUSH
21134: LD_VAR 0 1
21138: PPUSH
21139: LD_INT 14
21141: PUSH
21142: LD_INT 2
21144: PUSH
21145: LD_INT 1
21147: PUSH
21148: LD_INT 31
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL 21170 0 2
21161: ST_TO_ADDR
21162: GO 21165
21164: POP
// end ;
21165: LD_VAR 0 4
21169: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21170: LD_INT 0
21172: PPUSH
21173: PPUSH
// for i = 1 to list do
21174: LD_ADDR_VAR 0 4
21178: PUSH
21179: DOUBLE
21180: LD_INT 1
21182: DEC
21183: ST_TO_ADDR
21184: LD_VAR 0 2
21188: PUSH
21189: FOR_TO
21190: IFFALSE 21240
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21192: LD_ADDR_EXP 51
21196: PUSH
21197: LD_EXP 51
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_EXP 51
21211: PUSH
21212: LD_VAR 0 1
21216: ARRAY
21217: PUSH
21218: LD_INT 1
21220: PLUS
21221: PPUSH
21222: LD_VAR 0 2
21226: PUSH
21227: LD_VAR 0 4
21231: ARRAY
21232: PPUSH
21233: CALL 31130 0 4
21237: ST_TO_ADDR
21238: GO 21189
21240: POP
21241: POP
// end ;
21242: LD_VAR 0 3
21246: RET
// export function MCS_GetVehicleList ( side ) ; begin
21247: LD_INT 0
21249: PPUSH
// result := MREG_ToConstruct [ side ] ;
21250: LD_ADDR_VAR 0 2
21254: PUSH
21255: LD_EXP 51
21259: PUSH
21260: LD_VAR 0 1
21264: ARRAY
21265: ST_TO_ADDR
// end ;
21266: LD_VAR 0 2
21270: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21271: LD_INT 0
21273: PPUSH
21274: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21275: LD_ADDR_EXP 58
21279: PUSH
21280: LD_EXP 58
21284: PPUSH
21285: LD_VAR 0 1
21289: PPUSH
21290: LD_VAR 0 2
21294: PPUSH
21295: CALL_OW 1
21299: ST_TO_ADDR
// end ;
21300: LD_VAR 0 3
21304: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21305: LD_INT 0
21307: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21308: LD_ADDR_EXP 37
21312: PUSH
21313: LD_EXP 37
21317: PPUSH
21318: LD_VAR 0 1
21322: PPUSH
21323: LD_VAR 0 2
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// end ;
21333: LD_VAR 0 3
21337: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21338: LD_INT 0
21340: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21341: LD_ADDR_EXP 38
21345: PUSH
21346: LD_EXP 38
21350: PPUSH
21351: LD_VAR 0 1
21355: PPUSH
21356: LD_VAR 0 2
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 3
21370: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21374: LD_ADDR_EXP 60
21378: PUSH
21379: LD_EXP 60
21383: PPUSH
21384: LD_VAR 0 1
21388: PPUSH
21389: LD_INT 1
21391: PPUSH
21392: LD_VAR 0 2
21396: PPUSH
21397: CALL 31130 0 4
21401: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21402: LD_ADDR_EXP 60
21406: PUSH
21407: LD_EXP 60
21411: PPUSH
21412: LD_VAR 0 1
21416: PPUSH
21417: LD_INT 2
21419: PPUSH
21420: LD_VAR 0 3
21424: PPUSH
21425: CALL 31130 0 4
21429: ST_TO_ADDR
// end ;
21430: LD_VAR 0 4
21434: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21435: LD_INT 0
21437: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21438: LD_ADDR_EXP 72
21442: PUSH
21443: LD_EXP 72
21447: PPUSH
21448: LD_INT 1
21450: PPUSH
21451: LD_VAR 0 1
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21461: LD_ADDR_EXP 72
21465: PUSH
21466: LD_EXP 72
21470: PPUSH
21471: LD_INT 2
21473: PPUSH
21474: LD_VAR 0 2
21478: PPUSH
21479: CALL_OW 1
21483: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21484: LD_ADDR_EXP 72
21488: PUSH
21489: LD_EXP 72
21493: PPUSH
21494: LD_INT 3
21496: PPUSH
21497: LD_VAR 0 3
21501: PPUSH
21502: CALL_OW 1
21506: ST_TO_ADDR
// end ;
21507: LD_VAR 0 4
21511: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21512: LD_INT 0
21514: PPUSH
21515: PPUSH
21516: PPUSH
// if not side or not list then
21517: LD_VAR 0 1
21521: NOT
21522: PUSH
21523: LD_VAR 0 2
21527: NOT
21528: OR
21529: IFFALSE 21533
// exit ;
21531: GO 21701
// SetTech ( 20 , side , state_researched ) ;
21533: LD_INT 20
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: LD_INT 2
21543: PPUSH
21544: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21548: LD_ADDR_EXP 61
21552: PUSH
21553: LD_EXP 61
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: CALL_OW 2
21572: ST_TO_ADDR
// p := 1 ;
21573: LD_ADDR_VAR 0 5
21577: PUSH
21578: LD_INT 1
21580: ST_TO_ADDR
// for i = 1 to list / 3 do
21581: LD_ADDR_VAR 0 4
21585: PUSH
21586: DOUBLE
21587: LD_INT 1
21589: DEC
21590: ST_TO_ADDR
21591: LD_VAR 0 2
21595: PUSH
21596: LD_INT 3
21598: DIVREAL
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21699
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21603: LD_VAR 0 2
21607: PUSH
21608: LD_VAR 0 5
21612: ARRAY
21613: PPUSH
21614: LD_VAR 0 2
21618: PUSH
21619: LD_VAR 0 5
21623: PUSH
21624: LD_INT 1
21626: PLUS
21627: ARRAY
21628: PPUSH
21629: LD_VAR 0 2
21633: PUSH
21634: LD_VAR 0 5
21638: PUSH
21639: LD_INT 2
21641: PLUS
21642: ARRAY
21643: PPUSH
21644: CALL 22403 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21648: LD_VAR 0 2
21652: PUSH
21653: LD_VAR 0 5
21657: ARRAY
21658: PPUSH
21659: LD_VAR 0 2
21663: PUSH
21664: LD_VAR 0 5
21668: PUSH
21669: LD_INT 1
21671: PLUS
21672: ARRAY
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: CALL_OW 441
// p := p + 3 ;
21683: LD_ADDR_VAR 0 5
21687: PUSH
21688: LD_VAR 0 5
21692: PUSH
21693: LD_INT 3
21695: PLUS
21696: ST_TO_ADDR
// end ;
21697: GO 21600
21699: POP
21700: POP
// end ;
21701: LD_VAR 0 3
21705: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
// if nat = nation_arabian then
21710: LD_VAR 0 2
21714: PUSH
21715: LD_INT 2
21717: EQUAL
21718: IFFALSE 21724
// exit else
21720: GO 21796
21722: GO 21782
// if nat = nation_american then
21724: LD_VAR 0 2
21728: PUSH
21729: LD_INT 1
21731: EQUAL
21732: IFFALSE 21759
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21734: LD_ADDR_VAR 0 4
21738: PUSH
21739: LD_INT 4
21741: PUSH
21742: LD_INT 3
21744: PUSH
21745: LD_INT 1
21747: PUSH
21748: LD_INT 8
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: ST_TO_ADDR
21757: GO 21782
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21759: LD_ADDR_VAR 0 4
21763: PUSH
21764: LD_INT 24
21766: PUSH
21767: LD_INT 3
21769: PUSH
21770: LD_INT 1
21772: PUSH
21773: LD_INT 48
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21782: LD_VAR 0 1
21786: PPUSH
21787: LD_VAR 0 4
21791: PPUSH
21792: CALL 21170 0 2
// end ;
21796: LD_VAR 0 3
21800: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21801: LD_INT 0
21803: PPUSH
21804: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21805: LD_ADDR_EXP 63
21809: PUSH
21810: LD_EXP 63
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: LD_INT 1
21822: PPUSH
21823: LD_VAR 0 4
21827: PPUSH
21828: CALL 31130 0 4
21832: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21833: LD_ADDR_EXP 64
21837: PUSH
21838: LD_EXP 64
21842: PPUSH
21843: LD_VAR 0 1
21847: PPUSH
21848: LD_INT 1
21850: PPUSH
21851: LD_VAR 0 2
21855: PPUSH
21856: CALL 31130 0 4
21860: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21861: LD_ADDR_EXP 65
21865: PUSH
21866: LD_EXP 65
21870: PPUSH
21871: LD_VAR 0 1
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: LD_VAR 0 3
21883: PPUSH
21884: CALL 31130 0 4
21888: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21889: LD_ADDR_EXP 66
21893: PUSH
21894: LD_EXP 66
21898: PPUSH
21899: LD_VAR 0 1
21903: PPUSH
21904: LD_INT 1
21906: PPUSH
21907: LD_VAR 0 5
21911: PPUSH
21912: CALL 31130 0 4
21916: ST_TO_ADDR
// while squad do
21917: LD_VAR 0 5
21921: IFFALSE 22014
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21923: LD_VAR 0 1
21927: PPUSH
21928: LD_VAR 0 5
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PUSH
21937: LD_VAR 0 5
21941: PUSH
21942: LD_INT 2
21944: ARRAY
21945: PUSH
21946: LD_VAR 0 5
21950: PUSH
21951: LD_INT 3
21953: ARRAY
21954: PUSH
21955: LD_VAR 0 5
21959: PUSH
21960: LD_INT 4
21962: ARRAY
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: PPUSH
21970: CALL 21170 0 2
// for i = 1 to 4 do
21974: LD_ADDR_VAR 0 7
21978: PUSH
21979: DOUBLE
21980: LD_INT 1
21982: DEC
21983: ST_TO_ADDR
21984: LD_INT 4
21986: PUSH
21987: FOR_TO
21988: IFFALSE 22010
// squad := Delete ( squad , 1 ) ;
21990: LD_ADDR_VAR 0 5
21994: PUSH
21995: LD_VAR 0 5
21999: PPUSH
22000: LD_INT 1
22002: PPUSH
22003: CALL_OW 3
22007: ST_TO_ADDR
22008: GO 21987
22010: POP
22011: POP
// end ;
22012: GO 21917
// end ;
22014: LD_VAR 0 6
22018: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22019: LD_INT 0
22021: PPUSH
22022: PPUSH
// for i = 1 to squad do
22023: LD_ADDR_VAR 0 4
22027: PUSH
22028: DOUBLE
22029: LD_INT 1
22031: DEC
22032: ST_TO_ADDR
22033: LD_VAR 0 2
22037: PUSH
22038: FOR_TO
22039: IFFALSE 22089
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22041: LD_ADDR_EXP 69
22045: PUSH
22046: LD_EXP 69
22050: PPUSH
22051: LD_VAR 0 1
22055: PPUSH
22056: LD_EXP 69
22060: PUSH
22061: LD_VAR 0 1
22065: ARRAY
22066: PUSH
22067: LD_INT 1
22069: PLUS
22070: PPUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 4
22080: ARRAY
22081: PPUSH
22082: CALL 31130 0 4
22086: ST_TO_ADDR
22087: GO 22038
22089: POP
22090: POP
// while squad do
22091: LD_VAR 0 2
22095: IFFALSE 22188
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22097: LD_VAR 0 1
22101: PPUSH
22102: LD_VAR 0 2
22106: PUSH
22107: LD_INT 1
22109: ARRAY
22110: PUSH
22111: LD_VAR 0 2
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PUSH
22120: LD_VAR 0 2
22124: PUSH
22125: LD_INT 3
22127: ARRAY
22128: PUSH
22129: LD_VAR 0 2
22133: PUSH
22134: LD_INT 4
22136: ARRAY
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: LIST
22142: LIST
22143: PPUSH
22144: CALL 21170 0 2
// for i = 1 to 4 do
22148: LD_ADDR_VAR 0 4
22152: PUSH
22153: DOUBLE
22154: LD_INT 1
22156: DEC
22157: ST_TO_ADDR
22158: LD_INT 4
22160: PUSH
22161: FOR_TO
22162: IFFALSE 22184
// squad := Delete ( squad , 1 ) ;
22164: LD_ADDR_VAR 0 2
22168: PUSH
22169: LD_VAR 0 2
22173: PPUSH
22174: LD_INT 1
22176: PPUSH
22177: CALL_OW 3
22181: ST_TO_ADDR
22182: GO 22161
22184: POP
22185: POP
// end ;
22186: GO 22091
// end ;
22188: LD_VAR 0 3
22192: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22193: LD_INT 0
22195: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22196: LD_ADDR_EXP 62
22200: PUSH
22201: LD_EXP 62
22205: PPUSH
22206: LD_VAR 0 1
22210: PPUSH
22211: LD_INT 1
22213: PPUSH
22214: LD_VAR 0 2
22218: PPUSH
22219: CALL 31130 0 4
22223: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22224: LD_ADDR_EXP 62
22228: PUSH
22229: LD_EXP 62
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 2
22241: PPUSH
22242: LD_VAR 0 3
22246: PPUSH
22247: CALL 31130 0 4
22251: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22252: LD_ADDR_EXP 62
22256: PUSH
22257: LD_EXP 62
22261: PPUSH
22262: LD_VAR 0 1
22266: PPUSH
22267: LD_INT 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: CALL 31130 0 4
22279: ST_TO_ADDR
// end ; end_of_file
22280: LD_VAR 0 5
22284: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22285: LD_INT 0
22287: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22288: LD_ADDR_EXP 42
22292: PUSH
22293: LD_EXP 42
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_INT 1
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: CALL 31130 0 4
22315: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22316: LD_VAR 0 1
22320: PPUSH
22321: EMPTY
22322: PPUSH
22323: CALL 11786 0 2
22327: PUSH
22328: LD_INT 1
22330: ARRAY
22331: PPUSH
22332: CALL_OW 248
22336: PUSH
22337: LD_INT 1
22339: EQUAL
22340: IFFALSE 22371
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_INT 4
22349: PUSH
22350: LD_INT 1
22352: PUSH
22353: LD_INT 1
22355: PUSH
22356: LD_INT 14
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: PPUSH
22365: CALL 21170 0 2
22369: GO 22398
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22371: LD_VAR 0 1
22375: PPUSH
22376: LD_INT 24
22378: PUSH
22379: LD_INT 1
22381: PUSH
22382: LD_INT 1
22384: PUSH
22385: LD_INT 53
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: PPUSH
22394: CALL 21170 0 2
// end ;
22398: LD_VAR 0 3
22402: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22403: LD_INT 0
22405: PPUSH
// CreateDepositXY ( x , y , t ) ;
22406: LD_VAR 0 1
22410: PPUSH
22411: LD_VAR 0 2
22415: PPUSH
22416: LD_VAR 0 3
22420: PPUSH
22421: CALL_OW 62
// end ;
22425: LD_VAR 0 4
22429: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22430: LD_INT 0
22432: PPUSH
22433: PPUSH
// c := 1 ;
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_INT 1
22441: ST_TO_ADDR
// case color of red :
22442: LD_VAR 0 3
22446: PUSH
22447: LD_STRING red
22449: DOUBLE
22450: EQUAL
22451: IFTRUE 22455
22453: GO 22466
22455: POP
// c = 1 ; dark-green :
22456: LD_ADDR_VAR 0 5
22460: PUSH
22461: LD_INT 1
22463: ST_TO_ADDR
22464: GO 22752
22466: LD_STRING dark-green
22468: DOUBLE
22469: EQUAL
22470: IFTRUE 22474
22472: GO 22485
22474: POP
// c = 2 ; purple :
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_INT 2
22482: ST_TO_ADDR
22483: GO 22752
22485: LD_STRING purple
22487: DOUBLE
22488: EQUAL
22489: IFTRUE 22493
22491: GO 22504
22493: POP
// c = 3 ; aqua :
22494: LD_ADDR_VAR 0 5
22498: PUSH
22499: LD_INT 3
22501: ST_TO_ADDR
22502: GO 22752
22504: LD_STRING aqua
22506: DOUBLE
22507: EQUAL
22508: IFTRUE 22512
22510: GO 22523
22512: POP
// c = 4 ; grey :
22513: LD_ADDR_VAR 0 5
22517: PUSH
22518: LD_INT 4
22520: ST_TO_ADDR
22521: GO 22752
22523: LD_STRING grey
22525: DOUBLE
22526: EQUAL
22527: IFTRUE 22531
22529: GO 22542
22531: POP
// c = 5 ; lime :
22532: LD_ADDR_VAR 0 5
22536: PUSH
22537: LD_INT 5
22539: ST_TO_ADDR
22540: GO 22752
22542: LD_STRING lime
22544: DOUBLE
22545: EQUAL
22546: IFTRUE 22550
22548: GO 22561
22550: POP
// c = 6 ; tan :
22551: LD_ADDR_VAR 0 5
22555: PUSH
22556: LD_INT 6
22558: ST_TO_ADDR
22559: GO 22752
22561: LD_STRING tan
22563: DOUBLE
22564: EQUAL
22565: IFTRUE 22569
22567: GO 22580
22569: POP
// c = 7 ; pink :
22570: LD_ADDR_VAR 0 5
22574: PUSH
22575: LD_INT 7
22577: ST_TO_ADDR
22578: GO 22752
22580: LD_STRING pink
22582: DOUBLE
22583: EQUAL
22584: IFTRUE 22588
22586: GO 22599
22588: POP
// c = 8 ; green :
22589: LD_ADDR_VAR 0 5
22593: PUSH
22594: LD_INT 8
22596: ST_TO_ADDR
22597: GO 22752
22599: LD_STRING green
22601: DOUBLE
22602: EQUAL
22603: IFTRUE 22607
22605: GO 22618
22607: POP
// c = 9 ; blue :
22608: LD_ADDR_VAR 0 5
22612: PUSH
22613: LD_INT 9
22615: ST_TO_ADDR
22616: GO 22752
22618: LD_STRING blue
22620: DOUBLE
22621: EQUAL
22622: IFTRUE 22626
22624: GO 22637
22626: POP
// c = 10 ; yellow :
22627: LD_ADDR_VAR 0 5
22631: PUSH
22632: LD_INT 10
22634: ST_TO_ADDR
22635: GO 22752
22637: LD_STRING yellow
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22656
22645: POP
// c = 11 ; brown :
22646: LD_ADDR_VAR 0 5
22650: PUSH
22651: LD_INT 11
22653: ST_TO_ADDR
22654: GO 22752
22656: LD_STRING brown
22658: DOUBLE
22659: EQUAL
22660: IFTRUE 22664
22662: GO 22675
22664: POP
// c = 12 ; black :
22665: LD_ADDR_VAR 0 5
22669: PUSH
22670: LD_INT 12
22672: ST_TO_ADDR
22673: GO 22752
22675: LD_STRING black
22677: DOUBLE
22678: EQUAL
22679: IFTRUE 22683
22681: GO 22694
22683: POP
// c = 13 ; aqua2 :
22684: LD_ADDR_VAR 0 5
22688: PUSH
22689: LD_INT 13
22691: ST_TO_ADDR
22692: GO 22752
22694: LD_STRING aqua2
22696: DOUBLE
22697: EQUAL
22698: IFTRUE 22702
22700: GO 22713
22702: POP
// c = 14 ; orange :
22703: LD_ADDR_VAR 0 5
22707: PUSH
22708: LD_INT 14
22710: ST_TO_ADDR
22711: GO 22752
22713: LD_STRING orange
22715: DOUBLE
22716: EQUAL
22717: IFTRUE 22721
22719: GO 22732
22721: POP
// c = 15 ; white :
22722: LD_ADDR_VAR 0 5
22726: PUSH
22727: LD_INT 15
22729: ST_TO_ADDR
22730: GO 22752
22732: LD_STRING white
22734: DOUBLE
22735: EQUAL
22736: IFTRUE 22740
22738: GO 22751
22740: POP
// c = 16 ; end ;
22741: LD_ADDR_VAR 0 5
22745: PUSH
22746: LD_INT 16
22748: ST_TO_ADDR
22749: GO 22752
22751: POP
// if HexInfo ( x , y ) = 0 then
22752: LD_VAR 0 1
22756: PPUSH
22757: LD_VAR 0 2
22761: PPUSH
22762: CALL_OW 428
22766: PUSH
22767: LD_INT 0
22769: EQUAL
22770: IFFALSE 22794
// PlaceEnvironment ( x , y , 58 , c ) ;
22772: LD_VAR 0 1
22776: PPUSH
22777: LD_VAR 0 2
22781: PPUSH
22782: LD_INT 58
22784: PPUSH
22785: LD_VAR 0 5
22789: PPUSH
22790: CALL_OW 349
// end ;
22794: LD_VAR 0 4
22798: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22799: LD_INT 0
22801: PPUSH
// RemoveEnvironment ( x , y ) ;
22802: LD_VAR 0 1
22806: PPUSH
22807: LD_VAR 0 2
22811: PPUSH
22812: CALL_OW 347
// end ;
22816: LD_VAR 0 3
22820: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22821: LD_INT 0
22823: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22824: LD_ADDR_VAR 0 5
22828: PUSH
22829: LD_INT 81
22831: PUSH
22832: LD_VAR 0 1
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 92
22843: PUSH
22844: LD_VAR 0 2
22848: PUSH
22849: LD_VAR 0 3
22853: PUSH
22854: LD_VAR 0 4
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PPUSH
22869: CALL_OW 69
22873: ST_TO_ADDR
// end ;
22874: LD_VAR 0 5
22878: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22879: LD_INT 0
22881: PPUSH
22882: PPUSH
22883: PPUSH
22884: PPUSH
22885: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22886: LD_VAR 0 1
22890: PPUSH
22891: LD_INT 81
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 255
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PPUSH
22908: CALL_OW 69
22912: PPUSH
22913: LD_VAR 0 1
22917: PPUSH
22918: CALL_OW 74
22922: PPUSH
22923: CALL_OW 119
// dir := GetDir ( un ) ;
22927: LD_ADDR_VAR 0 4
22931: PUSH
22932: LD_VAR 0 1
22936: PPUSH
22937: CALL_OW 254
22941: ST_TO_ADDR
// dir := dir - 3 ;
22942: LD_ADDR_VAR 0 4
22946: PUSH
22947: LD_VAR 0 4
22951: PUSH
22952: LD_INT 3
22954: MINUS
22955: ST_TO_ADDR
// if dir < 0 then
22956: LD_VAR 0 4
22960: PUSH
22961: LD_INT 0
22963: LESS
22964: IFFALSE 22980
// dir := dir + 6 ;
22966: LD_ADDR_VAR 0 4
22970: PUSH
22971: LD_VAR 0 4
22975: PUSH
22976: LD_INT 6
22978: PLUS
22979: ST_TO_ADDR
// while true do
22980: LD_INT 1
22982: IFFALSE 23479
// begin coord_dist := 3 ;
22984: LD_ADDR_VAR 0 3
22988: PUSH
22989: LD_INT 3
22991: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22992: LD_ADDR_VAR 0 5
22996: PUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 250
23006: PPUSH
23007: LD_VAR 0 4
23011: PPUSH
23012: LD_VAR 0 3
23016: PPUSH
23017: CALL_OW 272
23021: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23022: LD_ADDR_VAR 0 6
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: CALL_OW 251
23036: PPUSH
23037: LD_VAR 0 4
23041: PPUSH
23042: LD_VAR 0 3
23046: PPUSH
23047: CALL_OW 273
23051: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23052: LD_VAR 0 1
23056: PPUSH
23057: CALL_OW 255
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: CALL_OW 250
23071: PPUSH
23072: LD_VAR 0 1
23076: PPUSH
23077: CALL_OW 251
23081: PPUSH
23082: LD_INT 14
23084: PPUSH
23085: CALL 22821 0 4
23089: PUSH
23090: LD_VAR 0 5
23094: PPUSH
23095: LD_VAR 0 6
23099: PPUSH
23100: CALL_OW 351
23104: OR
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 488
23120: PUSH
23121: LD_INT 0
23123: EQUAL
23124: OR
23125: PUSH
23126: LD_VAR 0 5
23130: PPUSH
23131: LD_VAR 0 6
23135: PPUSH
23136: CALL_OW 546
23140: PUSH
23141: LD_INT 1
23143: EQUAL
23144: OR
23145: PUSH
23146: LD_VAR 0 5
23150: PPUSH
23151: LD_VAR 0 6
23155: PPUSH
23156: CALL_OW 428
23160: PUSH
23161: LD_INT 0
23163: NONEQUAL
23164: OR
23165: IFFALSE 23393
// begin repeat begin Wait ( 0 0$0.3 ) ;
23167: LD_INT 10
23169: PPUSH
23170: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23174: LD_ADDR_VAR 0 3
23178: PUSH
23179: LD_VAR 0 3
23183: PUSH
23184: LD_INT 1
23186: PLUS
23187: ST_TO_ADDR
// dir := dir + 1 ;
23188: LD_ADDR_VAR 0 4
23192: PUSH
23193: LD_VAR 0 4
23197: PUSH
23198: LD_INT 1
23200: PLUS
23201: ST_TO_ADDR
// if dir > 5 then
23202: LD_VAR 0 4
23206: PUSH
23207: LD_INT 5
23209: GREATER
23210: IFFALSE 23220
// dir = 0 ;
23212: LD_ADDR_VAR 0 4
23216: PUSH
23217: LD_INT 0
23219: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23220: LD_ADDR_VAR 0 5
23224: PUSH
23225: LD_VAR 0 1
23229: PPUSH
23230: CALL_OW 250
23234: PPUSH
23235: LD_VAR 0 4
23239: PPUSH
23240: LD_VAR 0 3
23244: PPUSH
23245: CALL_OW 272
23249: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23250: LD_ADDR_VAR 0 6
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 251
23264: PPUSH
23265: LD_VAR 0 4
23269: PPUSH
23270: LD_VAR 0 3
23274: PPUSH
23275: CALL_OW 273
23279: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 255
23289: PPUSH
23290: LD_VAR 0 1
23294: PPUSH
23295: CALL_OW 250
23299: PPUSH
23300: LD_VAR 0 1
23304: PPUSH
23305: CALL_OW 251
23309: PPUSH
23310: LD_INT 14
23312: PPUSH
23313: CALL 22821 0 4
23317: NOT
23318: PUSH
23319: LD_VAR 0 5
23323: PPUSH
23324: LD_VAR 0 6
23328: PPUSH
23329: CALL_OW 351
23333: NOT
23334: AND
23335: PUSH
23336: LD_VAR 0 5
23340: PPUSH
23341: LD_VAR 0 6
23345: PPUSH
23346: CALL_OW 488
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 546
23366: PUSH
23367: LD_INT 0
23369: EQUAL
23370: AND
23371: PUSH
23372: LD_VAR 0 5
23376: PPUSH
23377: LD_VAR 0 6
23381: PPUSH
23382: CALL_OW 428
23386: PUSH
23387: LD_INT 0
23389: EQUAL
23390: AND
23391: IFFALSE 23167
// end ; ComMoveXY ( un , x , y ) ;
23393: LD_VAR 0 1
23397: PPUSH
23398: LD_VAR 0 5
23402: PPUSH
23403: LD_VAR 0 6
23407: PPUSH
23408: CALL_OW 111
// Wait ( 0 0$1 ) ;
23412: LD_INT 35
23414: PPUSH
23415: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23419: LD_VAR 0 1
23423: PPUSH
23424: LD_INT 81
23426: PUSH
23427: LD_VAR 0 1
23431: PPUSH
23432: CALL_OW 255
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 69
23445: PPUSH
23446: LD_VAR 0 1
23450: PPUSH
23451: CALL_OW 74
23455: PPUSH
23456: CALL_OW 296
23460: PUSH
23461: LD_INT 14
23463: GREATEREQUAL
23464: IFFALSE 23477
// begin ComStop ( un ) ;
23466: LD_VAR 0 1
23470: PPUSH
23471: CALL_OW 141
// break ;
23475: GO 23479
// end ; end ;
23477: GO 22980
// end ;
23479: LD_VAR 0 2
23483: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23484: LD_INT 0
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
23492: PPUSH
23493: PPUSH
// x := GetX ( unit ) ;
23494: LD_ADDR_VAR 0 3
23498: PUSH
23499: LD_VAR 0 1
23503: PPUSH
23504: CALL_OW 250
23508: ST_TO_ADDR
// y := GetY ( unit ) ;
23509: LD_ADDR_VAR 0 4
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 251
23523: ST_TO_ADDR
// i := 0 ;
23524: LD_ADDR_VAR 0 8
23528: PUSH
23529: LD_INT 0
23531: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23532: LD_VAR 0 1
23536: PPUSH
23537: LD_INT 81
23539: PUSH
23540: LD_VAR 0 1
23544: PPUSH
23545: CALL_OW 255
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PPUSH
23554: CALL_OW 69
23558: PPUSH
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 74
23568: PPUSH
23569: CALL_OW 119
// dir := GetDir ( unit ) ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 1
23582: PPUSH
23583: CALL_OW 254
23587: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23588: LD_ADDR_VAR 0 9
23592: PUSH
23593: LD_INT 0
23595: PPUSH
23596: LD_INT 1
23598: PPUSH
23599: CALL_OW 12
23603: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23604: LD_INT 10
23606: PPUSH
23607: CALL_OW 67
// if mode then
23611: LD_VAR 0 9
23615: IFFALSE 23633
// dir := dir + 1 else
23617: LD_ADDR_VAR 0 7
23621: PUSH
23622: LD_VAR 0 7
23626: PUSH
23627: LD_INT 1
23629: PLUS
23630: ST_TO_ADDR
23631: GO 23647
// dir := dir - 1 ;
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: MINUS
23646: ST_TO_ADDR
// if ( dir < 0 ) then
23647: LD_VAR 0 7
23651: PUSH
23652: LD_INT 0
23654: LESS
23655: IFFALSE 23665
// dir := 5 ;
23657: LD_ADDR_VAR 0 7
23661: PUSH
23662: LD_INT 5
23664: ST_TO_ADDR
// if ( dir > 5 ) then
23665: LD_VAR 0 7
23669: PUSH
23670: LD_INT 5
23672: GREATER
23673: IFFALSE 23683
// dir := 0 ;
23675: LD_ADDR_VAR 0 7
23679: PUSH
23680: LD_INT 0
23682: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23683: LD_ADDR_VAR 0 5
23687: PUSH
23688: LD_VAR 0 3
23692: PPUSH
23693: LD_VAR 0 7
23697: PPUSH
23698: LD_INT 4
23700: PPUSH
23701: CALL_OW 272
23705: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23706: LD_ADDR_VAR 0 6
23710: PUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: LD_VAR 0 7
23720: PPUSH
23721: LD_INT 4
23723: PPUSH
23724: CALL_OW 273
23728: ST_TO_ADDR
// i := i + 1 ;
23729: LD_ADDR_VAR 0 8
23733: PUSH
23734: LD_VAR 0 8
23738: PUSH
23739: LD_INT 1
23741: PLUS
23742: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23743: LD_VAR 0 1
23747: PPUSH
23748: CALL_OW 255
23752: PPUSH
23753: LD_VAR 0 5
23757: PPUSH
23758: LD_VAR 0 6
23762: PPUSH
23763: LD_INT 14
23765: PPUSH
23766: CALL 22821 0 4
23770: PUSH
23771: LD_INT 0
23773: EQUAL
23774: PUSH
23775: LD_VAR 0 5
23779: PPUSH
23780: LD_VAR 0 6
23784: PPUSH
23785: CALL_OW 546
23789: PUSH
23790: LD_INT 0
23792: EQUAL
23793: AND
23794: PUSH
23795: LD_VAR 0 5
23799: PPUSH
23800: LD_VAR 0 6
23804: PPUSH
23805: CALL_OW 428
23809: PUSH
23810: LD_INT 0
23812: EQUAL
23813: AND
23814: IFFALSE 23818
// break ;
23816: GO 23828
// end until i > 4 ;
23818: LD_VAR 0 8
23822: PUSH
23823: LD_INT 4
23825: GREATER
23826: IFFALSE 23604
// if x2 and y2 then
23828: LD_VAR 0 5
23832: PUSH
23833: LD_VAR 0 6
23837: AND
23838: IFFALSE 23861
// result := [ x2 , y2 ] else
23840: LD_ADDR_VAR 0 2
23844: PUSH
23845: LD_VAR 0 5
23849: PUSH
23850: LD_VAR 0 6
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: ST_TO_ADDR
23859: GO 23890
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23861: LD_ADDR_VAR 0 2
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: CALL_OW 250
23875: PUSH
23876: LD_VAR 0 1
23880: PPUSH
23881: CALL_OW 251
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: ST_TO_ADDR
// end ;
23890: LD_VAR 0 2
23894: RET
// export function MCT_Hex ( x , y ) ; begin
23895: LD_INT 0
23897: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23898: LD_ADDR_VAR 0 3
23902: PUSH
23903: LD_VAR 0 1
23907: PPUSH
23908: LD_VAR 0 2
23912: PPUSH
23913: CALL_OW 546
23917: PUSH
23918: LD_VAR 0 1
23922: PPUSH
23923: LD_VAR 0 2
23927: PPUSH
23928: CALL_OW 428
23932: PUSH
23933: EMPTY
23934: LIST
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: ST_TO_ADDR
// end ;
23940: LD_VAR 0 3
23944: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23945: LD_INT 0
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23960: LD_ADDR_VAR 0 10
23964: PUSH
23965: LD_EXP 60
23969: PUSH
23970: LD_VAR 0 1
23974: ARRAY
23975: PUSH
23976: LD_INT 1
23978: ARRAY
23979: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23980: LD_ADDR_VAR 0 11
23984: PUSH
23985: LD_EXP 60
23989: PUSH
23990: LD_VAR 0 1
23994: ARRAY
23995: PUSH
23996: LD_INT 2
23998: ARRAY
23999: ST_TO_ADDR
// collectors := [ ] ;
24000: LD_ADDR_VAR 0 12
24004: PUSH
24005: EMPTY
24006: ST_TO_ADDR
// is_cargo := false ;
24007: LD_ADDR_VAR 0 13
24011: PUSH
24012: LD_INT 0
24014: ST_TO_ADDR
// if isTest then
24015: LD_EXP 1
24019: IFFALSE 24025
// TimerStart ( ) ;
24021: CALL_OW 548
// if MCF_Cargo ( side ) then
24025: LD_VAR 0 1
24029: PPUSH
24030: CALL 12002 0 1
24034: IFFALSE 24061
// begin collectors := MCF_Cargo ( side ) ;
24036: LD_ADDR_VAR 0 12
24040: PUSH
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12002 0 1
24050: ST_TO_ADDR
// is_cargo := true ;
24051: LD_ADDR_VAR 0 13
24055: PUSH
24056: LD_INT 1
24058: ST_TO_ADDR
// end else
24059: GO 24210
// begin if MCF_ApeSpec ( side , engineer ) then
24061: LD_VAR 0 1
24065: PPUSH
24066: LD_STRING engineer
24068: PPUSH
24069: CALL 12148 0 2
24073: IFFALSE 24093
// collectors := MCF_ApeSpec ( side , engineer ) ;
24075: LD_ADDR_VAR 0 12
24079: PUSH
24080: LD_VAR 0 1
24084: PPUSH
24085: LD_STRING engineer
24087: PPUSH
24088: CALL 12148 0 2
24092: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24093: LD_VAR 0 1
24097: PPUSH
24098: LD_INT 2
24100: PPUSH
24101: EMPTY
24102: PPUSH
24103: CALL 11734 0 3
24107: IFFALSE 24210
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24109: LD_ADDR_VAR 0 7
24113: PUSH
24114: LD_VAR 0 1
24118: PPUSH
24119: LD_INT 2
24121: PPUSH
24122: EMPTY
24123: PPUSH
24124: CALL 11734 0 3
24128: ST_TO_ADDR
// if z > 5 then
24129: LD_VAR 0 7
24133: PUSH
24134: LD_INT 5
24136: GREATER
24137: IFFALSE 24149
// t1 := 5 else
24139: LD_ADDR_VAR 0 8
24143: PUSH
24144: LD_INT 5
24146: ST_TO_ADDR
24147: GO 24159
// t1 := z ;
24149: LD_ADDR_VAR 0 8
24153: PUSH
24154: LD_VAR 0 7
24158: ST_TO_ADDR
// for t2 = 1 to t1 do
24159: LD_ADDR_VAR 0 9
24163: PUSH
24164: DOUBLE
24165: LD_INT 1
24167: DEC
24168: ST_TO_ADDR
24169: LD_VAR 0 8
24173: PUSH
24174: FOR_TO
24175: IFFALSE 24208
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24177: LD_ADDR_VAR 0 12
24181: PUSH
24182: LD_VAR 0 12
24186: PPUSH
24187: LD_INT 1
24189: PPUSH
24190: LD_VAR 0 7
24194: PUSH
24195: LD_VAR 0 9
24199: ARRAY
24200: PPUSH
24201: CALL_OW 2
24205: ST_TO_ADDR
24206: GO 24174
24208: POP
24209: POP
// end ; end ; if not mode then
24210: LD_VAR 0 10
24214: NOT
24215: IFFALSE 24221
// exit else
24217: GO 24480
24219: GO 24480
// begin if collectors then
24221: LD_VAR 0 12
24225: IFFALSE 24480
// for i in areas do
24227: LD_ADDR_VAR 0 3
24231: PUSH
24232: LD_VAR 0 11
24236: PUSH
24237: FOR_IN
24238: IFFALSE 24478
// if GetListOfCratesInArea ( i ) then
24240: LD_VAR 0 3
24244: PPUSH
24245: CALL_OW 435
24249: IFFALSE 24476
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24251: LD_ADDR_VAR 0 5
24255: PUSH
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: PUSH
24266: LD_INT 1
24268: ARRAY
24269: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24270: LD_ADDR_VAR 0 6
24274: PUSH
24275: LD_VAR 0 3
24279: PPUSH
24280: CALL_OW 435
24284: PUSH
24285: LD_INT 2
24287: ARRAY
24288: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24289: LD_VAR 0 13
24293: PUSH
24294: LD_VAR 0 12
24298: PUSH
24299: LD_INT 1
24301: ARRAY
24302: PPUSH
24303: CALL_OW 110
24307: PUSH
24308: LD_INT 0
24310: EQUAL
24311: AND
24312: IFFALSE 24374
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24314: LD_VAR 0 12
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 314
24327: NOT
24328: PUSH
24329: LD_VAR 0 12
24333: PUSH
24334: LD_INT 1
24336: ARRAY
24337: PPUSH
24338: CALL_OW 110
24342: PUSH
24343: LD_INT 0
24345: EQUAL
24346: AND
24347: IFFALSE 24372
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24349: LD_VAR 0 12
24353: PUSH
24354: LD_INT 1
24356: ARRAY
24357: PPUSH
24358: LD_VAR 0 5
24362: PPUSH
24363: LD_VAR 0 6
24367: PPUSH
24368: CALL_OW 117
// end ; end else
24372: GO 24460
// begin for j = 1 to collectors do
24374: LD_ADDR_VAR 0 4
24378: PUSH
24379: DOUBLE
24380: LD_INT 1
24382: DEC
24383: ST_TO_ADDR
24384: LD_VAR 0 12
24388: PUSH
24389: FOR_TO
24390: IFFALSE 24458
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24392: LD_VAR 0 12
24396: PUSH
24397: LD_VAR 0 4
24401: ARRAY
24402: PPUSH
24403: CALL_OW 314
24407: NOT
24408: PUSH
24409: LD_VAR 0 12
24413: PUSH
24414: LD_VAR 0 4
24418: ARRAY
24419: PPUSH
24420: CALL_OW 110
24424: PUSH
24425: LD_INT 0
24427: EQUAL
24428: AND
24429: IFFALSE 24456
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24431: LD_VAR 0 12
24435: PUSH
24436: LD_VAR 0 4
24440: ARRAY
24441: PPUSH
24442: LD_VAR 0 5
24446: PPUSH
24447: LD_VAR 0 6
24451: PPUSH
24452: CALL 24851 0 3
// end ;
24456: GO 24389
24458: POP
24459: POP
// end ; if isTest then
24460: LD_EXP 1
24464: IFFALSE 24476
// begin debug_time := TimerEnd ( ) ;
24466: LD_ADDR_VAR 0 14
24470: PUSH
24471: CALL_OW 549
24475: ST_TO_ADDR
// end ; end ;
24476: GO 24237
24478: POP
24479: POP
// end ; end ;
24480: LD_VAR 0 2
24484: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24485: LD_INT 0
24487: PPUSH
24488: PPUSH
24489: PPUSH
24490: PPUSH
24491: PPUSH
24492: PPUSH
// if not area then
24493: LD_VAR 0 1
24497: NOT
24498: IFFALSE 24504
// exit else
24500: GO 24766
24502: GO 24766
// if tick mod interval = 0 and Prob ( percent ) then
24504: LD_OWVAR 1
24508: PUSH
24509: LD_VAR 0 4
24513: MOD
24514: PUSH
24515: LD_INT 0
24517: EQUAL
24518: PUSH
24519: LD_VAR 0 3
24523: PPUSH
24524: CALL_OW 13
24528: AND
24529: IFFALSE 24766
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24531: LD_VAR 0 1
24535: PPUSH
24536: CALL_OW 435
24540: PUSH
24541: LD_VAR 0 5
24545: LESS
24546: PUSH
24547: LD_VAR 0 5
24551: PUSH
24552: LD_INT 0
24554: EQUAL
24555: OR
24556: IFFALSE 24766
// begin Randomize ;
24558: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24562: LD_ADDR_VAR 0 7
24566: PUSH
24567: LD_INT 1
24569: PPUSH
24570: LD_VAR 0 2
24574: PPUSH
24575: CALL_OW 12
24579: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24580: LD_ADDR_VAR 0 9
24584: PUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: LD_INT 0
24592: PPUSH
24593: CALL_OW 517
24597: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24598: LD_ADDR_VAR 0 8
24602: PUSH
24603: LD_INT 1
24605: PPUSH
24606: LD_VAR 0 9
24610: PUSH
24611: LD_INT 1
24613: ARRAY
24614: PPUSH
24615: CALL_OW 12
24619: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24620: LD_VAR 0 9
24624: PUSH
24625: LD_INT 1
24627: ARRAY
24628: PUSH
24629: LD_VAR 0 8
24633: ARRAY
24634: PPUSH
24635: LD_VAR 0 9
24639: PUSH
24640: LD_INT 2
24642: ARRAY
24643: PUSH
24644: LD_VAR 0 8
24648: ARRAY
24649: PPUSH
24650: CALL_OW 428
24654: PUSH
24655: LD_INT 0
24657: GREATER
24658: PUSH
24659: LD_VAR 0 9
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PUSH
24668: LD_VAR 0 8
24672: ARRAY
24673: PPUSH
24674: LD_VAR 0 9
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PUSH
24683: LD_VAR 0 8
24687: ARRAY
24688: PPUSH
24689: CALL_OW 284
24693: PUSH
24694: LD_INT 0
24696: GREATER
24697: AND
24698: IFFALSE 24724
// c := Rand ( 1 , tmp [ 1 ] ) ;
24700: LD_ADDR_VAR 0 8
24704: PUSH
24705: LD_INT 1
24707: PPUSH
24708: LD_VAR 0 9
24712: PUSH
24713: LD_INT 1
24715: ARRAY
24716: PPUSH
24717: CALL_OW 12
24721: ST_TO_ADDR
24722: GO 24620
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24724: LD_VAR 0 7
24728: PPUSH
24729: LD_VAR 0 9
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PUSH
24738: LD_VAR 0 8
24742: ARRAY
24743: PPUSH
24744: LD_VAR 0 9
24748: PUSH
24749: LD_INT 2
24751: ARRAY
24752: PUSH
24753: LD_VAR 0 8
24757: ARRAY
24758: PPUSH
24759: LD_INT 1
24761: PPUSH
24762: CALL_OW 54
// end ; end ; end ;
24766: LD_VAR 0 6
24770: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24771: LD_INT 0
24773: PPUSH
24774: PPUSH
// if not MREG_Crates then
24775: LD_EXP 34
24779: NOT
24780: IFFALSE 24784
// exit ;
24782: GO 24846
// for i = MREG_Crates downto 1 do
24784: LD_ADDR_VAR 0 2
24788: PUSH
24789: DOUBLE
24790: LD_EXP 34
24794: INC
24795: ST_TO_ADDR
24796: LD_INT 1
24798: PUSH
24799: FOR_DOWNTO
24800: IFFALSE 24844
// if MREG_Crates [ i ] [ 3 ] = 0 then
24802: LD_EXP 34
24806: PUSH
24807: LD_VAR 0 2
24811: ARRAY
24812: PUSH
24813: LD_INT 3
24815: ARRAY
24816: PUSH
24817: LD_INT 0
24819: EQUAL
24820: IFFALSE 24842
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24822: LD_ADDR_EXP 34
24826: PUSH
24827: LD_EXP 34
24831: PPUSH
24832: LD_VAR 0 2
24836: PPUSH
24837: CALL_OW 3
24841: ST_TO_ADDR
24842: GO 24799
24844: POP
24845: POP
// end ;
24846: LD_VAR 0 1
24850: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24851: LD_INT 0
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
// if not unit then
24857: LD_VAR 0 1
24861: NOT
24862: IFFALSE 24866
// exit ;
24864: GO 25001
// if HasTask ( unit ) or not CanCarry ( unit ) then
24866: LD_VAR 0 1
24870: PPUSH
24871: CALL_OW 314
24875: PUSH
24876: LD_VAR 0 1
24880: PPUSH
24881: CALL_OW 280
24885: NOT
24886: OR
24887: IFFALSE 24891
// exit ;
24889: GO 25001
// side := GetSide ( unit ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 1
24900: PPUSH
24901: CALL_OW 255
24905: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24906: LD_ADDR_VAR 0 7
24910: PUSH
24911: LD_VAR 0 6
24915: PPUSH
24916: LD_INT 30
24918: PUSH
24919: LD_INT 1
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PPUSH
24926: CALL 11651 0 2
24930: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24931: LD_VAR 0 1
24935: PPUSH
24936: CALL_OW 281
24940: PUSH
24941: LD_VAR 0 7
24945: NOT
24946: OR
24947: IFFALSE 24953
// exit else
24949: GO 25001
24951: GO 25001
// if GetResourceAmountXY ( x , y ) then
24953: LD_VAR 0 2
24957: PPUSH
24958: LD_VAR 0 3
24962: PPUSH
24963: CALL_OW 284
24967: IFFALSE 24999
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24969: LD_VAR 0 1
24973: PPUSH
24974: LD_VAR 0 2
24978: PPUSH
24979: LD_VAR 0 3
24983: PPUSH
24984: LD_VAR 0 7
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: CALL 32061 0 4
// end else
24997: GO 25001
// exit ;
24999: GO 25001
// end ;
25001: LD_VAR 0 4
25005: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25006: LD_INT 0
25008: PPUSH
25009: PPUSH
25010: PPUSH
25011: PPUSH
25012: PPUSH
// result := [ ] ;
25013: LD_ADDR_VAR 0 2
25017: PUSH
25018: EMPTY
25019: ST_TO_ADDR
// p := 1 ;
25020: LD_ADDR_VAR 0 4
25024: PUSH
25025: LD_INT 1
25027: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25028: LD_ADDR_VAR 0 3
25032: PUSH
25033: DOUBLE
25034: LD_INT 1
25036: DEC
25037: ST_TO_ADDR
25038: LD_EXP 63
25042: PUSH
25043: LD_VAR 0 1
25047: ARRAY
25048: PUSH
25049: LD_INT 1
25051: ARRAY
25052: PUSH
25053: LD_INT 2
25055: DIVREAL
25056: PUSH
25057: FOR_TO
25058: IFFALSE 25182
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25060: LD_ADDR_VAR 0 5
25064: PUSH
25065: LD_INT 81
25067: PUSH
25068: LD_VAR 0 1
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: LD_INT 92
25079: PUSH
25080: LD_EXP 63
25084: PUSH
25085: LD_VAR 0 1
25089: ARRAY
25090: PUSH
25091: LD_INT 1
25093: ARRAY
25094: PUSH
25095: LD_VAR 0 4
25099: ARRAY
25100: PUSH
25101: LD_EXP 63
25105: PUSH
25106: LD_VAR 0 1
25110: ARRAY
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_INT 1
25123: PLUS
25124: ARRAY
25125: PUSH
25126: LD_INT 12
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PPUSH
25139: CALL_OW 69
25143: ST_TO_ADDR
// if tmp then
25144: LD_VAR 0 5
25148: IFFALSE 25166
// result := result union tmp ;
25150: LD_ADDR_VAR 0 2
25154: PUSH
25155: LD_VAR 0 2
25159: PUSH
25160: LD_VAR 0 5
25164: UNION
25165: ST_TO_ADDR
// p := p + 2 ;
25166: LD_ADDR_VAR 0 4
25170: PUSH
25171: LD_VAR 0 4
25175: PUSH
25176: LD_INT 2
25178: PLUS
25179: ST_TO_ADDR
// end ;
25180: GO 25057
25182: POP
25183: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25184: LD_EXP 64
25188: PUSH
25189: LD_VAR 0 1
25193: ARRAY
25194: PPUSH
25195: LD_INT 81
25197: PUSH
25198: LD_VAR 0 1
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: PPUSH
25207: CALL_OW 70
25211: IFFALSE 25252
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25213: LD_ADDR_VAR 0 2
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_EXP 64
25227: PUSH
25228: LD_VAR 0 1
25232: ARRAY
25233: PPUSH
25234: LD_INT 81
25236: PUSH
25237: LD_VAR 0 1
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: PPUSH
25246: CALL_OW 70
25250: UNION
25251: ST_TO_ADDR
// end ; end_of_file
25252: LD_VAR 0 2
25256: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25257: LD_INT 0
25259: PPUSH
25260: PPUSH
25261: PPUSH
// pom := GetBase ( fac ) ;
25262: LD_ADDR_VAR 0 5
25266: PUSH
25267: LD_VAR 0 1
25271: PPUSH
25272: CALL_OW 274
25276: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25277: LD_ADDR_VAR 0 4
25281: PUSH
25282: LD_VAR 0 2
25286: PUSH
25287: LD_INT 1
25289: ARRAY
25290: PPUSH
25291: LD_VAR 0 2
25295: PUSH
25296: LD_INT 2
25298: ARRAY
25299: PPUSH
25300: LD_VAR 0 2
25304: PUSH
25305: LD_INT 3
25307: ARRAY
25308: PPUSH
25309: LD_VAR 0 2
25313: PUSH
25314: LD_INT 4
25316: ARRAY
25317: PPUSH
25318: CALL_OW 449
25322: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25323: LD_ADDR_VAR 0 3
25327: PUSH
25328: LD_VAR 0 5
25332: PPUSH
25333: LD_INT 1
25335: PPUSH
25336: CALL_OW 275
25340: PUSH
25341: LD_VAR 0 4
25345: PUSH
25346: LD_INT 1
25348: ARRAY
25349: GREATEREQUAL
25350: PUSH
25351: LD_VAR 0 5
25355: PPUSH
25356: LD_INT 2
25358: PPUSH
25359: CALL_OW 275
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_INT 2
25371: ARRAY
25372: GREATEREQUAL
25373: AND
25374: PUSH
25375: LD_VAR 0 5
25379: PPUSH
25380: LD_INT 3
25382: PPUSH
25383: CALL_OW 275
25387: PUSH
25388: LD_VAR 0 4
25392: PUSH
25393: LD_INT 3
25395: ARRAY
25396: GREATEREQUAL
25397: AND
25398: ST_TO_ADDR
// end ;
25399: LD_VAR 0 3
25403: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25404: LD_INT 0
25406: PPUSH
25407: PPUSH
25408: PPUSH
// result := false ;
25409: LD_ADDR_VAR 0 3
25413: PUSH
25414: LD_INT 0
25416: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25417: LD_ADDR_VAR 0 4
25421: PUSH
25422: LD_EXP 51
25426: PUSH
25427: LD_VAR 0 1
25431: ARRAY
25432: ST_TO_ADDR
// if tmp then
25433: LD_VAR 0 4
25437: IFFALSE 25491
// for i = 1 to tmp do
25439: LD_ADDR_VAR 0 5
25443: PUSH
25444: DOUBLE
25445: LD_INT 1
25447: DEC
25448: ST_TO_ADDR
25449: LD_VAR 0 4
25453: PUSH
25454: FOR_TO
25455: IFFALSE 25489
// if component = tmp [ i ] then
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 4
25466: PUSH
25467: LD_VAR 0 5
25471: ARRAY
25472: EQUAL
25473: IFFALSE 25487
// begin result := true ;
25475: LD_ADDR_VAR 0 3
25479: PUSH
25480: LD_INT 1
25482: ST_TO_ADDR
// exit ;
25483: POP
25484: POP
25485: GO 25491
// end ;
25487: GO 25454
25489: POP
25490: POP
// end ;
25491: LD_VAR 0 3
25495: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25496: LD_INT 0
25498: PPUSH
25499: PPUSH
25500: PPUSH
// result := false ;
25501: LD_ADDR_VAR 0 4
25505: PUSH
25506: LD_INT 0
25508: ST_TO_ADDR
// if fac then
25509: LD_VAR 0 2
25513: IFFALSE 25736
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25515: LD_VAR 0 2
25519: PPUSH
25520: LD_VAR 0 3
25524: PPUSH
25525: CALL 25257 0 2
25529: PUSH
25530: LD_VAR 0 2
25534: PPUSH
25535: CALL_OW 461
25539: PUSH
25540: LD_INT 2
25542: EQUAL
25543: AND
25544: PUSH
25545: LD_VAR 0 2
25549: PPUSH
25550: LD_VAR 0 3
25554: PUSH
25555: LD_INT 1
25557: ARRAY
25558: PPUSH
25559: LD_VAR 0 3
25563: PUSH
25564: LD_INT 2
25566: ARRAY
25567: PPUSH
25568: LD_VAR 0 3
25572: PUSH
25573: LD_INT 3
25575: ARRAY
25576: PPUSH
25577: LD_VAR 0 3
25581: PUSH
25582: LD_INT 4
25584: ARRAY
25585: PPUSH
25586: CALL_OW 448
25590: AND
25591: IFFALSE 25736
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25593: LD_VAR 0 2
25597: PPUSH
25598: LD_VAR 0 3
25602: PUSH
25603: LD_INT 1
25605: ARRAY
25606: PPUSH
25607: LD_VAR 0 3
25611: PUSH
25612: LD_INT 2
25614: ARRAY
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_INT 3
25623: ARRAY
25624: PPUSH
25625: LD_VAR 0 3
25629: PUSH
25630: LD_INT 4
25632: ARRAY
25633: PPUSH
25634: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25638: LD_ADDR_VAR 0 6
25642: PUSH
25643: LD_EXP 51
25647: PUSH
25648: LD_VAR 0 1
25652: ARRAY
25653: ST_TO_ADDR
// for i = 4 downto 1 do
25654: LD_ADDR_VAR 0 5
25658: PUSH
25659: DOUBLE
25660: LD_INT 4
25662: INC
25663: ST_TO_ADDR
25664: LD_INT 1
25666: PUSH
25667: FOR_DOWNTO
25668: IFFALSE 25701
// tab := Remove ( tab , list [ i ] , true ) ;
25670: LD_ADDR_VAR 0 6
25674: PUSH
25675: LD_VAR 0 6
25679: PPUSH
25680: LD_VAR 0 3
25684: PUSH
25685: LD_VAR 0 5
25689: ARRAY
25690: PPUSH
25691: LD_INT 1
25693: PPUSH
25694: CALL 31289 0 3
25698: ST_TO_ADDR
25699: GO 25667
25701: POP
25702: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25703: LD_ADDR_EXP 51
25707: PUSH
25708: LD_EXP 51
25712: PPUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: LD_VAR 0 6
25722: PPUSH
25723: CALL_OW 1
25727: ST_TO_ADDR
// result := true ;
25728: LD_ADDR_VAR 0 4
25732: PUSH
25733: LD_INT 1
25735: ST_TO_ADDR
// end ; end ; end ;
25736: LD_VAR 0 4
25740: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25741: LD_INT 0
25743: PPUSH
25744: PPUSH
// if not veh then
25745: LD_VAR 0 2
25749: NOT
25750: IFFALSE 25754
// exit ;
25752: GO 25928
// if MREG_Parking [ side ] then
25754: LD_EXP 58
25758: PUSH
25759: LD_VAR 0 1
25763: ARRAY
25764: IFFALSE 25928
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25766: LD_VAR 0 2
25770: PPUSH
25771: LD_EXP 58
25775: PUSH
25776: LD_VAR 0 1
25780: ARRAY
25781: PPUSH
25782: CALL_OW 308
25786: NOT
25787: IFFALSE 25928
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25789: LD_VAR 0 2
25793: PPUSH
25794: LD_EXP 58
25798: PUSH
25799: LD_VAR 0 1
25803: ARRAY
25804: PPUSH
25805: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25809: LD_VAR 0 2
25813: PPUSH
25814: CALL_OW 263
25818: PUSH
25819: LD_INT 1
25821: EQUAL
25822: IFFALSE 25928
// begin i := GetDriver ( veh ) ;
25824: LD_ADDR_VAR 0 4
25828: PUSH
25829: LD_VAR 0 2
25833: PPUSH
25834: CALL 31773 0 1
25838: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25839: LD_INT 35
25841: PPUSH
25842: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25846: LD_VAR 0 2
25850: PPUSH
25851: LD_EXP 58
25855: PUSH
25856: LD_VAR 0 1
25860: ARRAY
25861: PPUSH
25862: CALL_OW 308
25866: PUSH
25867: LD_VAR 0 2
25871: PPUSH
25872: CALL_OW 301
25876: OR
25877: IFFALSE 25839
// ComExitVehicle ( i ) ;
25879: LD_VAR 0 4
25883: PPUSH
25884: CALL_OW 121
// Wait ( 1 ) ;
25888: LD_INT 1
25890: PPUSH
25891: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: LD_VAR 0 1
25904: PPUSH
25905: LD_INT 30
25907: PUSH
25908: LD_INT 3
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PPUSH
25915: CALL 11651 0 2
25919: PUSH
25920: LD_INT 1
25922: ARRAY
25923: PPUSH
25924: CALL_OW 180
// end ; end ; end ;
25928: LD_VAR 0 3
25932: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25933: LD_INT 0
25935: PPUSH
25936: PPUSH
25937: PPUSH
25938: PPUSH
25939: PPUSH
25940: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25941: LD_VAR 0 1
25945: PPUSH
25946: LD_INT 30
25948: PUSH
25949: LD_INT 3
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: PPUSH
25956: CALL 11651 0 2
25960: IFFALSE 26144
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25962: LD_VAR 0 1
25966: PPUSH
25967: LD_INT 30
25969: PUSH
25970: LD_INT 3
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: CALL 11651 0 2
25981: PUSH
25982: LD_INT 1
25984: ARRAY
25985: PPUSH
25986: CALL_OW 461
25990: PUSH
25991: LD_INT 2
25993: EQUAL
25994: IFFALSE 26144
// begin for i = 1 to MREG_TurretWeapon do
25996: LD_ADDR_VAR 0 3
26000: PUSH
26001: DOUBLE
26002: LD_INT 1
26004: DEC
26005: ST_TO_ADDR
26006: LD_EXP 43
26010: PUSH
26011: FOR_TO
26012: IFFALSE 26142
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26014: LD_EXP 43
26018: PUSH
26019: LD_VAR 0 3
26023: ARRAY
26024: PUSH
26025: LD_INT 1
26027: ARRAY
26028: PUSH
26029: LD_VAR 0 1
26033: EQUAL
26034: IFFALSE 26140
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26036: LD_ADDR_VAR 0 5
26040: PUSH
26041: LD_EXP 43
26045: PUSH
26046: LD_VAR 0 3
26050: ARRAY
26051: PUSH
26052: LD_INT 2
26054: ARRAY
26055: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26056: LD_ADDR_VAR 0 6
26060: PUSH
26061: LD_EXP 43
26065: PUSH
26066: LD_VAR 0 3
26070: ARRAY
26071: PUSH
26072: LD_INT 3
26074: ARRAY
26075: PUSH
26076: LD_INT 1
26078: ARRAY
26079: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26080: LD_ADDR_VAR 0 7
26084: PUSH
26085: LD_EXP 43
26089: PUSH
26090: LD_VAR 0 3
26094: ARRAY
26095: PUSH
26096: LD_INT 3
26098: ARRAY
26099: PUSH
26100: LD_INT 2
26102: ARRAY
26103: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26104: LD_ADDR_VAR 0 4
26108: PUSH
26109: LD_VAR 0 6
26113: PPUSH
26114: LD_VAR 0 7
26118: PPUSH
26119: CALL_OW 428
26123: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26124: LD_VAR 0 4
26128: PPUSH
26129: LD_VAR 0 5
26133: PPUSH
26134: CALL_OW 148
// break ;
26138: GO 26142
// end ;
26140: GO 26011
26142: POP
26143: POP
// end ; end ;
26144: LD_VAR 0 2
26148: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26149: LD_INT 0
26151: PPUSH
26152: PPUSH
26153: PPUSH
26154: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26155: LD_ADDR_VAR 0 4
26159: PUSH
26160: LD_VAR 0 1
26164: PPUSH
26165: LD_INT 32
26167: PUSH
26168: LD_INT 1
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: CALL 11651 0 2
26179: ST_TO_ADDR
// if not tmp then
26180: LD_VAR 0 4
26184: NOT
26185: IFFALSE 26191
// exit else
26187: GO 26273
26189: GO 26273
// begin for i = 1 to tmp do
26191: LD_ADDR_VAR 0 3
26195: PUSH
26196: DOUBLE
26197: LD_INT 1
26199: DEC
26200: ST_TO_ADDR
26201: LD_VAR 0 4
26205: PUSH
26206: FOR_TO
26207: IFFALSE 26271
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26209: LD_VAR 0 4
26213: PUSH
26214: LD_VAR 0 3
26218: ARRAY
26219: PPUSH
26220: CALL_OW 261
26224: PUSH
26225: LD_INT 20
26227: LESS
26228: PUSH
26229: LD_VAR 0 4
26233: PUSH
26234: LD_VAR 0 3
26238: ARRAY
26239: PPUSH
26240: CALL_OW 110
26244: PUSH
26245: LD_INT 0
26247: EQUAL
26248: AND
26249: IFFALSE 26269
// begin SetTag ( tmp [ i ] , 21 ) ;
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 3
26260: ARRAY
26261: PPUSH
26262: LD_INT 21
26264: PPUSH
26265: CALL_OW 109
// end ;
26269: GO 26206
26271: POP
26272: POP
// end ; end ;
26273: LD_VAR 0 2
26277: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26278: LD_INT 0
26280: PPUSH
26281: PPUSH
26282: PPUSH
26283: PPUSH
26284: PPUSH
// if not unit then
26285: LD_VAR 0 1
26289: NOT
26290: IFFALSE 26294
// exit ;
26292: GO 26482
// side := GetSide ( unit ) ;
26294: LD_ADDR_VAR 0 3
26298: PUSH
26299: LD_VAR 0 1
26303: PPUSH
26304: CALL_OW 255
26308: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26309: LD_ADDR_VAR 0 5
26313: PUSH
26314: LD_VAR 0 3
26318: PPUSH
26319: LD_INT 2
26321: PUSH
26322: LD_INT 30
26324: PUSH
26325: LD_INT 1
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_INT 3
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: LD_INT 30
26344: PUSH
26345: LD_INT 29
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: PPUSH
26358: CALL 11651 0 2
26362: ST_TO_ADDR
// if not b then
26363: LD_VAR 0 5
26367: NOT
26368: IFFALSE 26372
// exit ;
26370: GO 26482
// if GetTag ( unit ) = 21 then
26372: LD_VAR 0 1
26376: PPUSH
26377: CALL_OW 110
26381: PUSH
26382: LD_INT 21
26384: EQUAL
26385: IFFALSE 26482
// begin c := NearestUnitToUnit ( b , unit ) ;
26387: LD_ADDR_VAR 0 6
26391: PUSH
26392: LD_VAR 0 5
26396: PPUSH
26397: LD_VAR 0 1
26401: PPUSH
26402: CALL_OW 74
26406: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26407: LD_VAR 0 1
26411: PPUSH
26412: LD_VAR 0 6
26416: PPUSH
26417: CALL_OW 250
26421: PPUSH
26422: LD_VAR 0 6
26426: PPUSH
26427: CALL_OW 251
26431: PPUSH
26432: CALL_OW 297
26436: PUSH
26437: LD_INT 6
26439: GREATER
26440: IFFALSE 26458
// ComMoveUnit ( unit , c ) else
26442: LD_VAR 0 1
26446: PPUSH
26447: LD_VAR 0 6
26451: PPUSH
26452: CALL_OW 112
26456: GO 26482
// begin SetFuel ( unit , 100 ) ;
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_INT 100
26465: PPUSH
26466: CALL_OW 240
// SetTag ( unit , 0 ) ;
26470: LD_VAR 0 1
26474: PPUSH
26475: LD_INT 0
26477: PPUSH
26478: CALL_OW 109
// end ; end ; end ;
26482: LD_VAR 0 2
26486: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26487: LD_INT 0
26489: PPUSH
26490: PPUSH
26491: PPUSH
26492: PPUSH
26493: PPUSH
26494: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26495: LD_ADDR_VAR 0 7
26499: PUSH
26500: LD_VAR 0 1
26504: PPUSH
26505: LD_INT 33
26507: PUSH
26508: LD_INT 2
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 3
26517: PUSH
26518: LD_INT 61
26520: PUSH
26521: EMPTY
26522: LIST
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PPUSH
26532: CALL 11651 0 2
26536: ST_TO_ADDR
// if not vehs then
26537: LD_VAR 0 7
26541: NOT
26542: IFFALSE 26546
// exit ;
26544: GO 26831
// if nation = 1 then
26546: LD_VAR 0 2
26550: PUSH
26551: LD_INT 1
26553: EQUAL
26554: IFFALSE 26724
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26556: LD_VAR 0 1
26560: PPUSH
26561: LD_INT 30
26563: PUSH
26564: LD_INT 36
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PPUSH
26571: CALL 11651 0 2
26575: NOT
26576: IFFALSE 26582
// exit else
26578: GO 26831
26580: GO 26722
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26582: LD_ADDR_VAR 0 5
26586: PUSH
26587: LD_VAR 0 1
26591: PPUSH
26592: LD_INT 30
26594: PUSH
26595: LD_INT 36
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PPUSH
26602: CALL 11651 0 2
26606: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26607: LD_ADDR_VAR 0 6
26611: PUSH
26612: LD_VAR 0 5
26616: PUSH
26617: LD_INT 1
26619: ARRAY
26620: PPUSH
26621: CALL_OW 313
26625: ST_TO_ADDR
// for i = vehs downto 1 do
26626: LD_ADDR_VAR 0 4
26630: PUSH
26631: DOUBLE
26632: LD_VAR 0 7
26636: INC
26637: ST_TO_ADDR
26638: LD_INT 1
26640: PUSH
26641: FOR_DOWNTO
26642: IFFALSE 26720
// begin if not IsControledBy ( vehs [ i ] ) then
26644: LD_VAR 0 7
26648: PUSH
26649: LD_VAR 0 4
26653: ARRAY
26654: PPUSH
26655: CALL_OW 312
26659: NOT
26660: IFFALSE 26718
// begin tmp := MCV_RemoteDriver ( oper ) ;
26662: LD_ADDR_VAR 0 8
26666: PUSH
26667: LD_VAR 0 6
26671: PPUSH
26672: CALL 26836 0 1
26676: ST_TO_ADDR
// if not tmp then
26677: LD_VAR 0 8
26681: NOT
26682: IFFALSE 26690
// exit else
26684: POP
26685: POP
26686: GO 26831
26688: GO 26718
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26690: LD_VAR 0 7
26694: PUSH
26695: LD_VAR 0 4
26699: ARRAY
26700: PPUSH
26701: LD_VAR 0 8
26705: PUSH
26706: LD_INT 1
26708: ARRAY
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: CALL_OW 135
// end ; end ;
26718: GO 26641
26720: POP
26721: POP
// end ; end else
26722: GO 26831
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26724: LD_VAR 0 1
26728: PPUSH
26729: LD_INT 34
26731: PUSH
26732: LD_INT 31
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL 11651 0 2
26743: NOT
26744: IFFALSE 26750
// exit else
26746: GO 26831
26748: GO 26831
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: LD_VAR 0 1
26759: PPUSH
26760: LD_INT 34
26762: PUSH
26763: LD_INT 31
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PPUSH
26770: CALL 11651 0 2
26774: ST_TO_ADDR
// oper := [ ] ;
26775: LD_ADDR_VAR 0 6
26779: PUSH
26780: EMPTY
26781: ST_TO_ADDR
// for i = 1 to ct do
26782: LD_ADDR_VAR 0 4
26786: PUSH
26787: DOUBLE
26788: LD_INT 1
26790: DEC
26791: ST_TO_ADDR
26792: LD_VAR 0 5
26796: PUSH
26797: FOR_TO
26798: IFFALSE 26829
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26800: LD_ADDR_VAR 0 6
26804: PUSH
26805: LD_VAR 0 6
26809: PUSH
26810: LD_VAR 0 5
26814: PUSH
26815: LD_VAR 0 4
26819: ARRAY
26820: PPUSH
26821: CALL 31773 0 1
26825: ADD
26826: ST_TO_ADDR
26827: GO 26797
26829: POP
26830: POP
// end ; end ; end ;
26831: LD_VAR 0 3
26835: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26836: LD_INT 0
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
// if not drivers then
26844: LD_VAR 0 1
26848: NOT
26849: IFFALSE 26855
// exit else
26851: GO 27135
26853: GO 27135
// begin linked := [ ] ;
26855: LD_ADDR_VAR 0 5
26859: PUSH
26860: EMPTY
26861: ST_TO_ADDR
// for i = 1 to drivers do
26862: LD_ADDR_VAR 0 3
26866: PUSH
26867: DOUBLE
26868: LD_INT 1
26870: DEC
26871: ST_TO_ADDR
26872: LD_VAR 0 1
26876: PUSH
26877: FOR_TO
26878: IFFALSE 27123
// begin if CanControl ( drivers [ i ] ) then
26880: LD_VAR 0 1
26884: PUSH
26885: LD_VAR 0 3
26889: ARRAY
26890: PPUSH
26891: CALL 32163 0 1
26895: IFFALSE 27121
// if i > 1 then
26897: LD_VAR 0 3
26901: PUSH
26902: LD_INT 1
26904: GREATER
26905: IFFALSE 27082
// begin m := false ;
26907: LD_ADDR_VAR 0 6
26911: PUSH
26912: LD_INT 0
26914: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26915: LD_ADDR_VAR 0 7
26919: PUSH
26920: LD_VAR 0 1
26924: PUSH
26925: LD_VAR 0 3
26929: ARRAY
26930: PPUSH
26931: CALL_OW 432
26935: ST_TO_ADDR
// for j = 1 to linked do
26936: LD_ADDR_VAR 0 4
26940: PUSH
26941: DOUBLE
26942: LD_INT 1
26944: DEC
26945: ST_TO_ADDR
26946: LD_VAR 0 5
26950: PUSH
26951: FOR_TO
26952: IFFALSE 27026
// begin if l < linked [ j ] [ 2 ] then
26954: LD_VAR 0 7
26958: PUSH
26959: LD_VAR 0 5
26963: PUSH
26964: LD_VAR 0 4
26968: ARRAY
26969: PUSH
26970: LD_INT 2
26972: ARRAY
26973: LESS
26974: IFFALSE 27024
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26976: LD_ADDR_VAR 0 5
26980: PUSH
26981: LD_VAR 0 5
26985: PPUSH
26986: LD_INT 1
26988: PPUSH
26989: LD_VAR 0 1
26993: PUSH
26994: LD_VAR 0 3
26998: ARRAY
26999: PUSH
27000: LD_VAR 0 7
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PPUSH
27009: CALL_OW 2
27013: ST_TO_ADDR
// m := true ;
27014: LD_ADDR_VAR 0 6
27018: PUSH
27019: LD_INT 1
27021: ST_TO_ADDR
// break ;
27022: GO 27026
// end ; end ;
27024: GO 26951
27026: POP
27027: POP
// if not m then
27028: LD_VAR 0 6
27032: NOT
27033: IFFALSE 27080
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27035: LD_ADDR_VAR 0 5
27039: PUSH
27040: LD_VAR 0 5
27044: PUSH
27045: LD_VAR 0 1
27049: PUSH
27050: LD_VAR 0 3
27054: ARRAY
27055: PUSH
27056: LD_VAR 0 1
27060: PUSH
27061: LD_VAR 0 3
27065: ARRAY
27066: PPUSH
27067: CALL_OW 432
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: EMPTY
27077: LIST
27078: ADD
27079: ST_TO_ADDR
// end else
27080: GO 27121
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27082: LD_ADDR_VAR 0 5
27086: PUSH
27087: LD_VAR 0 1
27091: PUSH
27092: LD_VAR 0 3
27096: ARRAY
27097: PUSH
27098: LD_VAR 0 1
27102: PUSH
27103: LD_VAR 0 3
27107: ARRAY
27108: PPUSH
27109: CALL_OW 432
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: EMPTY
27119: LIST
27120: ST_TO_ADDR
// end ;
27121: GO 26877
27123: POP
27124: POP
// result := linked ;
27125: LD_ADDR_VAR 0 2
27129: PUSH
27130: LD_VAR 0 5
27134: ST_TO_ADDR
// end ; end ;
27135: LD_VAR 0 2
27139: RET
// export function MCV_ToRepair ( unit ) ; begin
27140: LD_INT 0
27142: PPUSH
// if not unit then
27143: LD_VAR 0 1
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 27183
// SetTag ( unit , 6 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 6
27159: PPUSH
27160: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27164: LD_VAR 0 1
27168: PPUSH
27169: CALL_OW 255
27173: PPUSH
27174: LD_VAR 0 1
27178: PPUSH
27179: CALL 25741 0 2
// end ;
27183: LD_VAR 0 2
27187: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27188: LD_INT 0
27190: PPUSH
27191: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27192: LD_VAR 0 1
27196: PPUSH
27197: LD_INT 6
27199: PPUSH
27200: EMPTY
27201: PPUSH
27202: CALL 12354 0 3
27206: IFFALSE 27299
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27208: LD_ADDR_VAR 0 3
27212: PUSH
27213: DOUBLE
27214: LD_VAR 0 1
27218: PPUSH
27219: LD_INT 6
27221: PPUSH
27222: EMPTY
27223: PPUSH
27224: CALL 12354 0 3
27228: INC
27229: ST_TO_ADDR
27230: LD_INT 1
27232: PUSH
27233: FOR_DOWNTO
27234: IFFALSE 27297
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27236: LD_VAR 0 1
27240: PPUSH
27241: LD_INT 6
27243: PPUSH
27244: EMPTY
27245: PPUSH
27246: CALL 12354 0 3
27250: PUSH
27251: LD_VAR 0 3
27255: ARRAY
27256: PPUSH
27257: CALL_OW 256
27261: PUSH
27262: LD_INT 1000
27264: EQUAL
27265: IFFALSE 27295
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27267: LD_VAR 0 1
27271: PPUSH
27272: LD_INT 6
27274: PPUSH
27275: EMPTY
27276: PPUSH
27277: CALL 12354 0 3
27281: PUSH
27282: LD_VAR 0 3
27286: ARRAY
27287: PPUSH
27288: LD_INT 0
27290: PPUSH
27291: CALL_OW 109
27295: GO 27233
27297: POP
27298: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27299: LD_VAR 0 1
27303: PPUSH
27304: LD_INT 10
27306: PPUSH
27307: EMPTY
27308: PPUSH
27309: CALL 12354 0 3
27313: IFFALSE 27430
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27315: LD_ADDR_VAR 0 3
27319: PUSH
27320: DOUBLE
27321: LD_VAR 0 1
27325: PPUSH
27326: LD_INT 10
27328: PPUSH
27329: EMPTY
27330: PPUSH
27331: CALL 12354 0 3
27335: INC
27336: ST_TO_ADDR
27337: LD_INT 1
27339: PUSH
27340: FOR_DOWNTO
27341: IFFALSE 27428
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27343: LD_VAR 0 1
27347: PPUSH
27348: LD_INT 10
27350: PPUSH
27351: EMPTY
27352: PPUSH
27353: CALL 12354 0 3
27357: PUSH
27358: LD_VAR 0 3
27362: ARRAY
27363: PPUSH
27364: CALL_OW 302
27368: NOT
27369: PUSH
27370: LD_VAR 0 1
27374: PPUSH
27375: LD_INT 10
27377: PPUSH
27378: EMPTY
27379: PPUSH
27380: CALL 12354 0 3
27384: PUSH
27385: LD_VAR 0 3
27389: ARRAY
27390: PPUSH
27391: CALL_OW 301
27395: OR
27396: IFFALSE 27426
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27398: LD_VAR 0 1
27402: PPUSH
27403: LD_INT 10
27405: PPUSH
27406: EMPTY
27407: PPUSH
27408: CALL 12354 0 3
27412: PUSH
27413: LD_VAR 0 3
27417: ARRAY
27418: PPUSH
27419: LD_INT 0
27421: PPUSH
27422: CALL_OW 109
27426: GO 27340
27428: POP
27429: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27430: LD_ADDR_VAR 0 3
27434: PUSH
27435: LD_VAR 0 1
27439: PPUSH
27440: EMPTY
27441: PPUSH
27442: CALL 11952 0 2
27446: PUSH
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 7
27454: PPUSH
27455: EMPTY
27456: PPUSH
27457: CALL 12354 0 3
27461: DIFF
27462: PUSH
27463: FOR_IN
27464: IFFALSE 27508
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27466: LD_VAR 0 3
27470: PPUSH
27471: CALL_OW 256
27475: PUSH
27476: LD_INT 650
27478: LESS
27479: PUSH
27480: LD_VAR 0 3
27484: PPUSH
27485: CALL_OW 110
27489: PUSH
27490: LD_INT 6
27492: EQUAL
27493: NOT
27494: AND
27495: IFFALSE 27506
// MCV_ToRepair ( i ) ;
27497: LD_VAR 0 3
27501: PPUSH
27502: CALL 27140 0 1
27506: GO 27463
27508: POP
27509: POP
// end ; end_of_file end_of_file
27510: LD_VAR 0 2
27514: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27515: LD_STRING SAILEvent [
27517: PUSH
27518: LD_VAR 0 1
27522: STR
27523: PUSH
27524: LD_STRING ]
27526: STR
27527: PPUSH
27528: CALL 8039 0 1
// if event = 101 and dialog_north then
27532: LD_VAR 0 1
27536: PUSH
27537: LD_INT 101
27539: EQUAL
27540: PUSH
27541: LD_EXP 6
27545: AND
27546: IFFALSE 27610
// begin dialog_north := false ;
27548: LD_ADDR_EXP 6
27552: PUSH
27553: LD_INT 0
27555: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27556: LD_EXP 5
27560: PPUSH
27561: LD_STRING DS1
27563: PUSH
27564: LD_STRING DS2
27566: PUSH
27567: LD_STRING DS3
27569: PUSH
27570: LD_STRING DS6
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PPUSH
27582: LD_INT 4
27584: PPUSH
27585: CALL_OW 12
27589: ARRAY
27590: PPUSH
27591: CALL_OW 94
// Wait ( 4 4$00 ) ;
27595: LD_INT 8400
27597: PPUSH
27598: CALL_OW 67
// dialog_north := true ;
27602: LD_ADDR_EXP 6
27606: PUSH
27607: LD_INT 1
27609: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27610: LD_VAR 0 1
27614: PUSH
27615: LD_INT 102
27617: EQUAL
27618: PUSH
27619: LD_EXP 7
27623: AND
27624: IFFALSE 27684
// begin dialog_south := false ;
27626: LD_ADDR_EXP 7
27630: PUSH
27631: LD_INT 0
27633: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27634: LD_EXP 4
27638: PPUSH
27639: LD_STRING DJ1
27641: PUSH
27642: LD_STRING DJ4
27644: PUSH
27645: LD_STRING DJ6
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PPUSH
27656: LD_INT 3
27658: PPUSH
27659: CALL_OW 12
27663: ARRAY
27664: PPUSH
27665: CALL_OW 94
// Wait ( 4 4$00 ) ;
27669: LD_INT 8400
27671: PPUSH
27672: CALL_OW 67
// dialog_south := true ;
27676: LD_ADDR_EXP 7
27680: PUSH
27681: LD_INT 1
27683: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27684: LD_VAR 0 1
27688: PUSH
27689: LD_INT 104
27691: EQUAL
27692: PUSH
27693: LD_EXP 8
27697: AND
27698: IFFALSE 27720
// begin dialog_popov := false ;
27700: LD_ADDR_EXP 8
27704: PUSH
27705: LD_INT 0
27707: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27708: LD_EXP 24
27712: PPUSH
27713: LD_STRING DR4
27715: PPUSH
27716: CALL_OW 94
// end ; end ;
27720: PPOPN 1
27722: END
// on BuildingStarted ( b , unit ) do var side , i ;
27723: LD_INT 0
27725: PPUSH
27726: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27727: LD_EXP 39
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ARRAY
27742: IFFALSE 27920
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27744: LD_STRING BuildingStarted [side: 
27746: PUSH
27747: LD_VAR 0 1
27751: PPUSH
27752: CALL_OW 255
27756: STR
27757: PUSH
27758: LD_STRING ; btype: 
27760: STR
27761: PUSH
27762: LD_VAR 0 1
27766: PPUSH
27767: CALL_OW 266
27771: STR
27772: PUSH
27773: LD_STRING ; unit: 
27775: STR
27776: PUSH
27777: LD_VAR 0 2
27781: STR
27782: PUSH
27783: LD_STRING ]
27785: STR
27786: PPUSH
27787: CALL 8039 0 1
// side := GetSide ( b ) ;
27791: LD_ADDR_VAR 0 3
27795: PUSH
27796: LD_VAR 0 1
27800: PPUSH
27801: CALL_OW 255
27805: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27806: LD_VAR 0 3
27810: PPUSH
27811: LD_INT 21
27813: PUSH
27814: LD_INT 3
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PPUSH
27821: CALL 11651 0 2
27825: PUSH
27826: LD_INT 1
27828: EQUAL
27829: IFFALSE 27920
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27831: LD_ADDR_VAR 0 4
27835: PUSH
27836: LD_VAR 0 3
27840: PPUSH
27841: LD_INT 21
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PPUSH
27851: CALL 11651 0 2
27855: PUSH
27856: LD_VAR 0 3
27860: PPUSH
27861: LD_INT 2
27863: PPUSH
27864: EMPTY
27865: PPUSH
27866: CALL 11734 0 3
27870: DIFF
27871: PUSH
27872: FOR_IN
27873: IFFALSE 27918
// if not HasTask ( i ) then
27875: LD_VAR 0 4
27879: PPUSH
27880: CALL_OW 314
27884: NOT
27885: IFFALSE 27916
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27887: LD_VAR 0 4
27891: PPUSH
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 250
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 251
27911: PPUSH
27912: CALL_OW 111
27916: GO 27872
27918: POP
27919: POP
// end ;
27920: PPOPN 4
27922: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27923: LD_EXP 39
27927: PUSH
27928: LD_VAR 0 1
27932: PPUSH
27933: CALL_OW 255
27937: ARRAY
27938: IFFALSE 28307
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27940: LD_STRING BuildingComplete [side: 
27942: PUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 255
27952: STR
27953: PUSH
27954: LD_STRING ; btype: 
27956: STR
27957: PUSH
27958: LD_VAR 0 1
27962: PPUSH
27963: CALL_OW 266
27967: STR
27968: PUSH
27969: LD_STRING ]
27971: STR
27972: PPUSH
27973: CALL 8039 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27977: LD_ADDR_EXP 46
27981: PUSH
27982: LD_EXP 46
27986: PPUSH
27987: LD_VAR 0 1
27991: PPUSH
27992: CALL_OW 255
27996: PPUSH
27997: LD_VAR 0 1
28001: PPUSH
28002: CALL_OW 266
28006: PPUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 250
28016: PUSH
28017: LD_VAR 0 1
28021: PPUSH
28022: CALL_OW 251
28026: PUSH
28027: LD_VAR 0 1
28031: PPUSH
28032: CALL_OW 254
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: LIST
28041: PPUSH
28042: CALL 42051 0 4
28046: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28047: LD_VAR 0 1
28051: PPUSH
28052: CALL_OW 266
28056: PUSH
28057: LD_INT 6
28059: EQUAL
28060: IFFALSE 28094
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28062: LD_ADDR_EXP 40
28066: PUSH
28067: LD_EXP 40
28071: PPUSH
28072: LD_VAR 0 1
28076: PPUSH
28077: CALL_OW 255
28081: PPUSH
28082: LD_VAR 0 1
28086: PPUSH
28087: EMPTY
28088: PPUSH
28089: CALL 41960 0 4
28093: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28094: LD_VAR 0 1
28098: PPUSH
28099: CALL_OW 266
28103: PUSH
28104: LD_INT 0
28106: EQUAL
28107: IFFALSE 28217
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28109: LD_ADDR_EXP 48
28113: PUSH
28114: LD_EXP 48
28118: PPUSH
28119: LD_VAR 0 1
28123: PPUSH
28124: CALL_OW 255
28128: PPUSH
28129: LD_INT 0
28131: PPUSH
28132: EMPTY
28133: PPUSH
28134: CALL 41960 0 4
28138: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28139: LD_VAR 0 1
28143: PPUSH
28144: CALL_OW 274
28148: PPUSH
28149: LD_INT 1
28151: PPUSH
28152: LD_EXP 72
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: CALL_OW 274
28174: PPUSH
28175: LD_INT 2
28177: PPUSH
28178: LD_EXP 72
28182: PUSH
28183: LD_INT 2
28185: ARRAY
28186: PPUSH
28187: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28191: LD_VAR 0 1
28195: PPUSH
28196: CALL_OW 274
28200: PPUSH
28201: LD_INT 3
28203: PPUSH
28204: LD_EXP 72
28208: PUSH
28209: LD_INT 3
28211: ARRAY
28212: PPUSH
28213: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28217: LD_VAR 0 1
28221: PPUSH
28222: CALL_OW 266
28226: PUSH
28227: LD_INT 2
28229: EQUAL
28230: IFFALSE 28262
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28232: LD_ADDR_EXP 48
28236: PUSH
28237: LD_EXP 48
28241: PPUSH
28242: LD_VAR 0 1
28246: PPUSH
28247: CALL_OW 255
28251: PPUSH
28252: LD_INT 2
28254: PPUSH
28255: EMPTY
28256: PPUSH
28257: CALL 41960 0 4
28261: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 266
28271: PUSH
28272: LD_INT 4
28274: EQUAL
28275: IFFALSE 28307
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28277: LD_ADDR_EXP 48
28281: PUSH
28282: LD_EXP 48
28286: PPUSH
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_INT 4
28299: PPUSH
28300: EMPTY
28301: PPUSH
28302: CALL 41960 0 4
28306: ST_TO_ADDR
// end ;
28307: PPOPN 1
28309: END
// on ResearchComplete ( tech , lab ) do var i ;
28310: LD_INT 0
28312: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28313: LD_EXP 39
28317: PUSH
28318: LD_VAR 0 2
28322: PPUSH
28323: CALL_OW 255
28327: ARRAY
28328: IFFALSE 28612
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28330: LD_STRING ResearchComplete [side: 
28332: PUSH
28333: LD_VAR 0 2
28337: PPUSH
28338: CALL_OW 255
28342: PPUSH
28343: CALL_OW 255
28347: STR
28348: PUSH
28349: LD_STRING ; tech:
28351: STR
28352: PUSH
28353: LD_VAR 0 1
28357: STR
28358: PUSH
28359: LD_STRING ]
28361: STR
28362: PPUSH
28363: CALL 8039 0 1
// for i = 1 to MREG_ToRes do
28367: LD_ADDR_VAR 0 3
28371: PUSH
28372: DOUBLE
28373: LD_INT 1
28375: DEC
28376: ST_TO_ADDR
28377: LD_EXP 50
28381: PUSH
28382: FOR_TO
28383: IFFALSE 28470
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28385: LD_EXP 50
28389: PUSH
28390: LD_VAR 0 3
28394: ARRAY
28395: PUSH
28396: LD_INT 1
28398: ARRAY
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: EQUAL
28410: PUSH
28411: LD_EXP 50
28415: PUSH
28416: LD_VAR 0 3
28420: ARRAY
28421: PUSH
28422: LD_INT 2
28424: ARRAY
28425: PUSH
28426: LD_VAR 0 1
28430: EQUAL
28431: AND
28432: IFFALSE 28468
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28434: LD_ADDR_EXP 50
28438: PUSH
28439: LD_EXP 50
28443: PPUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: CALL_OW 255
28453: PPUSH
28454: LD_VAR 0 1
28458: PPUSH
28459: EMPTY
28460: PPUSH
28461: CALL 42051 0 4
28465: ST_TO_ADDR
// break ;
28466: GO 28470
// end ;
28468: GO 28382
28470: POP
28471: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28472: LD_VAR 0 1
28476: PUSH
28477: LD_INT 2
28479: PUSH
28480: LD_INT 11
28482: PUSH
28483: LD_INT 4
28485: PUSH
28486: LD_INT 3
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: IN
28495: IFFALSE 28612
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28497: LD_ADDR_VAR 0 3
28501: PUSH
28502: LD_VAR 0 2
28506: PPUSH
28507: CALL_OW 255
28511: PPUSH
28512: LD_INT 16
28514: PPUSH
28515: LD_INT 25
28517: PUSH
28518: LD_INT 4
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PPUSH
28525: CALL 12354 0 3
28529: ST_TO_ADDR
// if i then
28530: LD_VAR 0 3
28534: IFFALSE 28552
// SetTag ( i [ 1 ] , 0 ) ;
28536: LD_VAR 0 3
28540: PUSH
28541: LD_INT 1
28543: ARRAY
28544: PPUSH
28545: LD_INT 0
28547: PPUSH
28548: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28552: LD_ADDR_VAR 0 3
28556: PUSH
28557: LD_VAR 0 2
28561: PPUSH
28562: CALL_OW 255
28566: PPUSH
28567: LD_INT 171
28569: PPUSH
28570: EMPTY
28571: PPUSH
28572: CALL 12354 0 3
28576: ST_TO_ADDR
// if i then
28577: LD_VAR 0 3
28581: IFFALSE 28612
// begin SetTag ( i [ 1 ] , 0 ) ;
28583: LD_VAR 0 3
28587: PUSH
28588: LD_INT 1
28590: ARRAY
28591: PPUSH
28592: LD_INT 0
28594: PPUSH
28595: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: CALL_OW 122
// end ; end ; end ;
28612: PPOPN 3
28614: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28615: LD_INT 0
28617: PPUSH
28618: PPUSH
28619: PPUSH
28620: PPUSH
28621: PPUSH
28622: PPUSH
28623: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28624: LD_VAR 0 1
28628: PPUSH
28629: LD_VAR 0 2
28633: PPUSH
28634: CALL 59186 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28638: LD_EXP 39
28642: PUSH
28643: LD_VAR 0 2
28647: PPUSH
28648: CALL_OW 255
28652: ARRAY
28653: IFFALSE 29380
// begin side := GetSide ( veh ) ;
28655: LD_ADDR_VAR 0 4
28659: PUSH
28660: LD_VAR 0 1
28664: PPUSH
28665: CALL_OW 255
28669: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28670: LD_ADDR_VAR 0 6
28674: PUSH
28675: LD_VAR 0 1
28679: PPUSH
28680: CALL_OW 265
28684: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28685: LD_ADDR_VAR 0 7
28689: PUSH
28690: LD_VAR 0 1
28694: PPUSH
28695: CALL_OW 262
28699: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28700: LD_ADDR_VAR 0 8
28704: PUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL_OW 263
28714: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28715: LD_ADDR_VAR 0 9
28719: PUSH
28720: LD_VAR 0 1
28724: PPUSH
28725: CALL_OW 264
28729: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28730: LD_STRING VehicleConstructed [side: 
28732: PUSH
28733: LD_VAR 0 4
28737: STR
28738: PUSH
28739: LD_STRING ; id:
28741: STR
28742: PUSH
28743: LD_VAR 0 1
28747: STR
28748: PUSH
28749: LD_STRING ; components: [
28751: STR
28752: PUSH
28753: LD_VAR 0 6
28757: STR
28758: PUSH
28759: LD_STRING , 
28761: STR
28762: PUSH
28763: LD_VAR 0 7
28767: STR
28768: PUSH
28769: LD_STRING , 
28771: STR
28772: PUSH
28773: LD_VAR 0 8
28777: STR
28778: PUSH
28779: LD_STRING , 
28781: STR
28782: PUSH
28783: LD_VAR 0 9
28787: STR
28788: PUSH
28789: LD_STRING ]]
28791: STR
28792: PPUSH
28793: CALL 8039 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28797: LD_VAR 0 1
28801: PPUSH
28802: CALL_OW 264
28806: PUSH
28807: LD_INT 13
28809: PUSH
28810: LD_INT 12
28812: PUSH
28813: LD_INT 14
28815: PUSH
28816: LD_INT 51
28818: PUSH
28819: LD_INT 53
28821: PUSH
28822: LD_INT 52
28824: PUSH
28825: LD_INT 32
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: IN
28837: NOT
28838: IFFALSE 28880
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28840: LD_ADDR_EXP 59
28844: PUSH
28845: LD_EXP 59
28849: PPUSH
28850: LD_VAR 0 4
28854: PPUSH
28855: LD_EXP 59
28859: PUSH
28860: LD_VAR 0 4
28864: ARRAY
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 1
28874: PPUSH
28875: CALL 31130 0 4
28879: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28880: LD_VAR 0 1
28884: PPUSH
28885: CALL_OW 264
28889: PUSH
28890: LD_INT 31
28892: EQUAL
28893: IFFALSE 28912
// SetTag ( GetDriver ( veh ) , 9 ) ;
28895: LD_VAR 0 1
28899: PPUSH
28900: CALL 31773 0 1
28904: PPUSH
28905: LD_INT 9
28907: PPUSH
28908: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28912: LD_VAR 0 1
28916: PPUSH
28917: CALL_OW 264
28921: PUSH
28922: LD_INT 14
28924: PUSH
28925: LD_INT 53
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: IN
28932: IFFALSE 28969
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28934: LD_ADDR_EXP 42
28938: PUSH
28939: LD_EXP 42
28943: PPUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 255
28953: PPUSH
28954: LD_INT 2
28956: PPUSH
28957: LD_VAR 0 1
28961: PPUSH
28962: CALL 31130 0 4
28966: ST_TO_ADDR
// exit ;
28967: GO 29380
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28969: LD_VAR 0 1
28973: PPUSH
28974: CALL_OW 265
28978: PUSH
28979: LD_EXP 66
28983: PUSH
28984: LD_VAR 0 4
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: IN
28994: PUSH
28995: LD_VAR 0 1
28999: PPUSH
29000: CALL_OW 262
29004: PUSH
29005: LD_EXP 66
29009: PUSH
29010: LD_VAR 0 4
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: IN
29020: AND
29021: PUSH
29022: LD_VAR 0 1
29026: PPUSH
29027: CALL_OW 263
29031: PUSH
29032: LD_EXP 66
29036: PUSH
29037: LD_VAR 0 4
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: IN
29047: AND
29048: PUSH
29049: LD_VAR 0 1
29053: PPUSH
29054: CALL_OW 264
29058: PUSH
29059: LD_EXP 66
29063: PUSH
29064: LD_VAR 0 4
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: IN
29074: AND
29075: IFFALSE 29119
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29077: LD_ADDR_EXP 67
29081: PUSH
29082: LD_EXP 67
29086: PPUSH
29087: LD_VAR 0 4
29091: PPUSH
29092: LD_EXP 67
29096: PUSH
29097: LD_VAR 0 4
29101: ARRAY
29102: PUSH
29103: LD_INT 1
29105: PLUS
29106: PPUSH
29107: LD_VAR 0 1
29111: PPUSH
29112: CALL 31130 0 4
29116: ST_TO_ADDR
// exit ;
29117: GO 29380
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29119: LD_VAR 0 6
29123: PUSH
29124: LD_EXP 69
29128: PUSH
29129: LD_VAR 0 4
29133: ARRAY
29134: PUSH
29135: LD_INT 1
29137: ARRAY
29138: EQUAL
29139: PUSH
29140: LD_VAR 0 7
29144: PUSH
29145: LD_EXP 69
29149: PUSH
29150: LD_VAR 0 4
29154: ARRAY
29155: PUSH
29156: LD_INT 2
29158: ARRAY
29159: EQUAL
29160: AND
29161: PUSH
29162: LD_VAR 0 8
29166: PUSH
29167: LD_EXP 69
29171: PUSH
29172: LD_VAR 0 4
29176: ARRAY
29177: PUSH
29178: LD_INT 3
29180: ARRAY
29181: EQUAL
29182: AND
29183: PUSH
29184: LD_VAR 0 9
29188: PUSH
29189: LD_EXP 69
29193: PUSH
29194: LD_VAR 0 4
29198: ARRAY
29199: PUSH
29200: LD_INT 4
29202: ARRAY
29203: EQUAL
29204: AND
29205: IFFALSE 29361
// begin tmp := MREG_ToAttack [ side ] ;
29207: LD_ADDR_VAR 0 5
29211: PUSH
29212: LD_EXP 69
29216: PUSH
29217: LD_VAR 0 4
29221: ARRAY
29222: ST_TO_ADDR
// for i = 1 to 4 do
29223: LD_ADDR_VAR 0 3
29227: PUSH
29228: DOUBLE
29229: LD_INT 1
29231: DEC
29232: ST_TO_ADDR
29233: LD_INT 4
29235: PUSH
29236: FOR_TO
29237: IFFALSE 29259
// tmp := Delete ( tmp , 1 ) ;
29239: LD_ADDR_VAR 0 5
29243: PUSH
29244: LD_VAR 0 5
29248: PPUSH
29249: LD_INT 1
29251: PPUSH
29252: CALL_OW 3
29256: ST_TO_ADDR
29257: GO 29236
29259: POP
29260: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29261: LD_ADDR_EXP 69
29265: PUSH
29266: LD_EXP 69
29270: PPUSH
29271: LD_VAR 0 4
29275: PPUSH
29276: LD_VAR 0 5
29280: PPUSH
29281: CALL_OW 1
29285: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29286: LD_ADDR_EXP 71
29290: PUSH
29291: LD_EXP 71
29295: PPUSH
29296: LD_VAR 0 4
29300: PPUSH
29301: LD_EXP 71
29305: PUSH
29306: LD_VAR 0 4
29310: ARRAY
29311: PUSH
29312: LD_INT 1
29314: PLUS
29315: PPUSH
29316: LD_VAR 0 1
29320: PPUSH
29321: CALL 31130 0 4
29325: ST_TO_ADDR
// if tmp = 0 then
29326: LD_VAR 0 5
29330: PUSH
29331: LD_INT 0
29333: EQUAL
29334: IFFALSE 29359
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29336: LD_ADDR_EXP 69
29340: PUSH
29341: LD_EXP 69
29345: PPUSH
29346: LD_VAR 0 4
29350: PPUSH
29351: LD_INT 0
29353: PPUSH
29354: CALL_OW 1
29358: ST_TO_ADDR
// exit ;
29359: GO 29380
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29361: LD_VAR 0 1
29365: PPUSH
29366: CALL_OW 255
29370: PPUSH
29371: LD_VAR 0 1
29375: PPUSH
29376: CALL 25741 0 2
// end ; end ;
29380: PPOPN 9
29382: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29383: LD_EXP 39
29387: PUSH
29388: LD_VAR 0 2
29392: PPUSH
29393: CALL_OW 255
29397: ARRAY
29398: IFFALSE 29630
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29400: LD_STRING ApemanTamed [side: 
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: CALL_OW 255
29412: STR
29413: PUSH
29414: LD_STRING ; sci: 
29416: STR
29417: PUSH
29418: LD_VAR 0 2
29422: STR
29423: PUSH
29424: LD_STRING ; ape: 
29426: STR
29427: PUSH
29428: LD_VAR 0 1
29432: STR
29433: PUSH
29434: LD_STRING ]
29436: STR
29437: PPUSH
29438: CALL 8039 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29442: LD_INT 11
29444: PPUSH
29445: LD_VAR 0 2
29449: PPUSH
29450: CALL_OW 255
29454: PPUSH
29455: CALL_OW 321
29459: PUSH
29460: LD_INT 2
29462: EQUAL
29463: NOT
29464: PUSH
29465: LD_INT 2
29467: PPUSH
29468: LD_VAR 0 2
29472: PPUSH
29473: CALL_OW 255
29477: PPUSH
29478: CALL_OW 321
29482: PUSH
29483: LD_INT 2
29485: EQUAL
29486: NOT
29487: OR
29488: PUSH
29489: LD_VAR 0 2
29493: PPUSH
29494: CALL_OW 255
29498: PPUSH
29499: LD_INT 171
29501: PPUSH
29502: EMPTY
29503: PPUSH
29504: CALL 12354 0 3
29508: PUSH
29509: LD_INT 0
29511: EQUAL
29512: AND
29513: IFFALSE 29527
// begin SetTag ( ape , 171 ) ;
29515: LD_VAR 0 1
29519: PPUSH
29520: LD_INT 171
29522: PPUSH
29523: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29527: LD_VAR 0 2
29531: PPUSH
29532: CALL_OW 255
29536: PPUSH
29537: LD_INT 30
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL 11651 0 2
29551: IFFALSE 29630
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29553: LD_VAR 0 1
29557: PPUSH
29558: LD_VAR 0 2
29562: PPUSH
29563: CALL_OW 255
29567: PPUSH
29568: LD_INT 30
29570: PUSH
29571: LD_INT 1
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PPUSH
29578: CALL 11651 0 2
29582: PUSH
29583: LD_INT 1
29585: ARRAY
29586: PPUSH
29587: CALL_OW 250
29591: PPUSH
29592: LD_VAR 0 2
29596: PPUSH
29597: CALL_OW 255
29601: PPUSH
29602: LD_INT 30
29604: PUSH
29605: LD_INT 1
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL 11651 0 2
29616: PUSH
29617: LD_INT 1
29619: ARRAY
29620: PPUSH
29621: CALL_OW 251
29625: PPUSH
29626: CALL_OW 111
// end ;
29630: PPOPN 2
29632: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29633: LD_EXP 39
29637: PUSH
29638: LD_VAR 0 1
29642: PPUSH
29643: CALL_OW 255
29647: ARRAY
29648: IFFALSE 29926
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29650: LD_VAR 0 2
29654: PUSH
29655: LD_VAR 0 2
29659: PPUSH
29660: CALL_OW 255
29664: PPUSH
29665: CALL 12064 0 1
29669: IN
29670: IFFALSE 29811
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29672: LD_VAR 0 1
29676: PPUSH
29677: CALL_OW 266
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 1
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: IN
29692: IFFALSE 29722
// begin Wait ( 0 0$0.3 ) ;
29694: LD_INT 10
29696: PPUSH
29697: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29701: LD_VAR 0 2
29705: PPUSH
29706: LD_INT 16
29708: PPUSH
29709: CALL_OW 336
// ComExitBuilding ( un ) ;
29713: LD_VAR 0 2
29717: PPUSH
29718: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 266
29731: PUSH
29732: LD_INT 4
29734: PUSH
29735: LD_INT 5
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: IN
29742: IFFALSE 29811
// begin Wait ( 0 0$0.3 ) ;
29744: LD_INT 10
29746: PPUSH
29747: CALL_OW 67
// if GetTag ( un ) = 0 then
29751: LD_VAR 0 2
29755: PPUSH
29756: CALL_OW 110
29760: PUSH
29761: LD_INT 0
29763: EQUAL
29764: IFFALSE 29780
// SetClass ( un , class_apeman_soldier ) else
29766: LD_VAR 0 2
29770: PPUSH
29771: LD_INT 15
29773: PPUSH
29774: CALL_OW 336
29778: GO 29811
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29780: LD_INT 3
29782: PPUSH
29783: LD_VAR 0 2
29787: PPUSH
29788: CALL_OW 255
29792: PPUSH
29793: CALL_OW 321
29797: IFFALSE 29811
// SetClass ( un , class_apeman_kamikaze ) ;
29799: LD_VAR 0 2
29803: PPUSH
29804: LD_INT 17
29806: PPUSH
29807: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29811: LD_VAR 0 1
29815: PPUSH
29816: CALL_OW 266
29820: PUSH
29821: LD_INT 32
29823: EQUAL
29824: IFFALSE 29926
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29826: LD_ADDR_EXP 68
29830: PUSH
29831: LD_EXP 68
29835: PPUSH
29836: LD_VAR 0 1
29840: PPUSH
29841: CALL_OW 255
29845: PPUSH
29846: LD_EXP 68
29850: PUSH
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL_OW 255
29860: ARRAY
29861: PUSH
29862: LD_INT 1
29864: PLUS
29865: PPUSH
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL 31130 0 4
29875: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29876: LD_ADDR_EXP 68
29880: PUSH
29881: LD_EXP 68
29885: PPUSH
29886: LD_VAR 0 1
29890: PPUSH
29891: CALL_OW 255
29895: PPUSH
29896: LD_EXP 68
29900: PUSH
29901: LD_VAR 0 1
29905: PPUSH
29906: CALL_OW 255
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: PLUS
29915: PPUSH
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL 31130 0 4
29925: ST_TO_ADDR
// end ; end ;
29926: PPOPN 2
29928: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29929: LD_VAR 0 1
29933: PPUSH
29934: CALL 59066 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29938: LD_VAR 0 1
29942: PUSH
29943: LD_INT 22
29945: PUSH
29946: LD_INT 3
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 23
29955: PUSH
29956: LD_INT 3
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 21
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: LIST
29977: PPUSH
29978: CALL_OW 69
29982: IN
29983: IFFALSE 29999
// player_loss := player_loss + 1 ;
29985: LD_ADDR_EXP 10
29989: PUSH
29990: LD_EXP 10
29994: PUSH
29995: LD_INT 1
29997: PLUS
29998: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29999: LD_VAR 0 1
30003: PUSH
30004: LD_INT 22
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: LD_INT 21
30016: PUSH
30017: LD_INT 3
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: CALL_OW 69
30032: IN
30033: PUSH
30034: LD_EXP 14
30038: NOT
30039: AND
30040: IFFALSE 30103
// begin alfa_north_triggered := true ;
30042: LD_ADDR_EXP 14
30046: PUSH
30047: LD_INT 1
30049: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30050: LD_EXP 5
30054: PPUSH
30055: LD_STRING DS4
30057: PPUSH
30058: CALL_OW 94
// Wait ( 1 1$25 ) ;
30062: LD_INT 2975
30064: PPUSH
30065: CALL_OW 67
// if not isTest then
30069: LD_EXP 1
30073: NOT
30074: IFFALSE 30103
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30076: LD_INT 20
30078: PPUSH
30079: LD_INT 5
30081: PUSH
30082: LD_INT 6
30084: PUSH
30085: LD_INT 7
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: LIST
30092: PUSH
30093: LD_OWVAR 67
30097: ARRAY
30098: PPUSH
30099: CALL 7058 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30103: LD_VAR 0 1
30107: PUSH
30108: LD_INT 22
30110: PUSH
30111: LD_INT 4
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 21
30120: PUSH
30121: LD_INT 3
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PPUSH
30132: CALL_OW 69
30136: IN
30137: PUSH
30138: LD_EXP 15
30142: NOT
30143: AND
30144: IFFALSE 30207
// begin alfa_south_triggered := true ;
30146: LD_ADDR_EXP 15
30150: PUSH
30151: LD_INT 1
30153: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30154: LD_EXP 4
30158: PPUSH
30159: LD_STRING DJ3
30161: PPUSH
30162: CALL_OW 94
// Wait ( 0 0$45 ) ;
30166: LD_INT 1575
30168: PPUSH
30169: CALL_OW 67
// if not isTest then
30173: LD_EXP 1
30177: NOT
30178: IFFALSE 30207
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30180: LD_INT 20
30182: PPUSH
30183: LD_INT 5
30185: PUSH
30186: LD_INT 6
30188: PUSH
30189: LD_INT 7
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: LIST
30196: PUSH
30197: LD_OWVAR 67
30201: ARRAY
30202: PPUSH
30203: CALL 7058 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30207: LD_VAR 0 1
30211: PPUSH
30212: CALL_OW 266
30216: PUSH
30217: LD_INT 1
30219: EQUAL
30220: PUSH
30221: LD_VAR 0 1
30225: PPUSH
30226: CALL_OW 255
30230: PUSH
30231: LD_INT 1
30233: PUSH
30234: LD_INT 4
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: IN
30241: AND
30242: IFFALSE 30251
// RaiseSailEvent ( 104 ) ;
30244: LD_INT 104
30246: PPUSH
30247: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30251: LD_EXP 39
30255: PUSH
30256: LD_VAR 0 1
30260: PPUSH
30261: CALL_OW 255
30265: ARRAY
30266: IFFALSE 30653
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30268: LD_STRING UnitDestroyed [side 
30270: PUSH
30271: LD_VAR 0 1
30275: PPUSH
30276: CALL_OW 255
30280: STR
30281: PUSH
30282: LD_STRING ; id: 
30284: STR
30285: PUSH
30286: LD_VAR 0 1
30290: STR
30291: PUSH
30292: LD_STRING ; type: 
30294: STR
30295: PUSH
30296: LD_VAR 0 1
30300: PPUSH
30301: CALL_OW 247
30305: STR
30306: PUSH
30307: LD_STRING ]
30309: STR
30310: PPUSH
30311: CALL 8039 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30315: LD_VAR 0 1
30319: PUSH
30320: LD_VAR 0 1
30324: PPUSH
30325: CALL_OW 255
30329: PPUSH
30330: LD_INT 21
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PPUSH
30340: CALL 11651 0 2
30344: IN
30345: IFFALSE 30501
// begin if MCF_HasClass ( un ) then
30347: LD_VAR 0 1
30351: PPUSH
30352: CALL 14357 0 1
30356: IFFALSE 30501
// case MCF_HasClass ( un ) of 1 :
30358: LD_VAR 0 1
30362: PPUSH
30363: CALL 14357 0 1
30367: PUSH
30368: LD_INT 1
30370: DOUBLE
30371: EQUAL
30372: IFTRUE 30376
30374: GO 30401
30376: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30377: LD_VAR 0 1
30381: PPUSH
30382: CALL_OW 255
30386: PPUSH
30387: LD_STRING ToArm
30389: PPUSH
30390: LD_VAR 0 1
30394: PPUSH
30395: CALL 14530 0 3
30399: GO 30501
30401: LD_INT 2
30403: DOUBLE
30404: EQUAL
30405: IFTRUE 30409
30407: GO 30434
30409: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30410: LD_VAR 0 1
30414: PPUSH
30415: CALL_OW 255
30419: PPUSH
30420: LD_STRING ToDep
30422: PPUSH
30423: LD_VAR 0 1
30427: PPUSH
30428: CALL 14530 0 3
30432: GO 30501
30434: LD_INT 3
30436: DOUBLE
30437: EQUAL
30438: IFTRUE 30442
30440: GO 30467
30442: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30443: LD_VAR 0 1
30447: PPUSH
30448: CALL_OW 255
30452: PPUSH
30453: LD_STRING ToFac
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: CALL 14530 0 3
30465: GO 30501
30467: LD_INT 4
30469: DOUBLE
30470: EQUAL
30471: IFTRUE 30475
30473: GO 30500
30475: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30476: LD_VAR 0 1
30480: PPUSH
30481: CALL_OW 255
30485: PPUSH
30486: LD_STRING ToLab
30488: PPUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL 14530 0 3
30498: GO 30501
30500: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30501: LD_VAR 0 1
30505: PUSH
30506: LD_EXP 67
30510: PUSH
30511: LD_VAR 0 1
30515: PPUSH
30516: CALL_OW 255
30520: ARRAY
30521: IN
30522: IFFALSE 30607
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30524: LD_ADDR_EXP 67
30528: PUSH
30529: LD_EXP 67
30533: PPUSH
30534: LD_VAR 0 1
30538: PPUSH
30539: LD_INT 0
30541: PPUSH
30542: CALL 31289 0 3
30546: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30547: LD_VAR 0 1
30551: PPUSH
30552: CALL_OW 255
30556: PPUSH
30557: LD_VAR 0 1
30561: PPUSH
30562: CALL_OW 265
30566: PUSH
30567: LD_VAR 0 1
30571: PPUSH
30572: CALL_OW 262
30576: PUSH
30577: LD_VAR 0 1
30581: PPUSH
30582: CALL_OW 263
30586: PUSH
30587: LD_VAR 0 1
30591: PPUSH
30592: CALL_OW 264
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: PPUSH
30603: CALL 21170 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30607: LD_VAR 0 1
30611: PUSH
30612: LD_EXP 71
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 255
30626: ARRAY
30627: IN
30628: IFFALSE 30653
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30630: LD_ADDR_EXP 71
30634: PUSH
30635: LD_EXP 71
30639: PPUSH
30640: LD_VAR 0 1
30644: PPUSH
30645: LD_INT 0
30647: PPUSH
30648: CALL 31289 0 3
30652: ST_TO_ADDR
// end ; end ;
30653: PPOPN 1
30655: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30656: LD_EXP 39
30660: PUSH
30661: LD_VAR 0 2
30665: PPUSH
30666: CALL_OW 255
30670: ARRAY
30671: IFFALSE 30843
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30673: LD_VAR 0 2
30677: PUSH
30678: LD_EXP 68
30682: PUSH
30683: LD_VAR 0 2
30687: PPUSH
30688: CALL_OW 255
30692: ARRAY
30693: IN
30694: PUSH
30695: LD_VAR 0 1
30699: PPUSH
30700: CALL_OW 266
30704: PUSH
30705: LD_INT 32
30707: PUSH
30708: LD_INT 31
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: IN
30715: AND
30716: IFFALSE 30816
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30718: LD_ADDR_EXP 68
30722: PUSH
30723: LD_EXP 68
30727: PPUSH
30728: LD_VAR 0 1
30732: PPUSH
30733: LD_INT 0
30735: PPUSH
30736: CALL 31289 0 3
30740: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30741: LD_ADDR_EXP 68
30745: PUSH
30746: LD_EXP 68
30750: PPUSH
30751: LD_VAR 0 2
30755: PPUSH
30756: LD_INT 0
30758: PPUSH
30759: CALL 31289 0 3
30763: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30764: LD_EXP 68
30768: PUSH
30769: LD_VAR 0 2
30773: PPUSH
30774: CALL_OW 255
30778: ARRAY
30779: PUSH
30780: LD_STRING 
30782: EQUAL
30783: IFFALSE 30816
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30785: LD_ADDR_EXP 68
30789: PUSH
30790: LD_EXP 68
30794: PPUSH
30795: LD_VAR 0 2
30799: PPUSH
30800: CALL_OW 255
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 0
30810: PPUSH
30811: CALL 31130 0 4
30815: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30816: LD_VAR 0 1
30820: PPUSH
30821: CALL_OW 266
30825: PUSH
30826: LD_INT 36
30828: IN
30829: IFFALSE 30843
// SetTag ( un , 0 ) ;
30831: LD_VAR 0 2
30835: PPUSH
30836: LD_INT 0
30838: PPUSH
30839: CALL_OW 109
// end ;
30843: PPOPN 2
30845: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30846: LD_EXP 39
30850: PUSH
30851: LD_VAR 0 1
30855: PPUSH
30856: CALL_OW 255
30860: ARRAY
30861: IFFALSE 30887
// begin if GetControl ( un ) = control_remote then
30863: LD_VAR 0 1
30867: PPUSH
30868: CALL_OW 263
30872: PUSH
30873: LD_INT 2
30875: EQUAL
30876: IFFALSE 30887
// ComUnlink ( un ) ;
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 136
// end ;
30887: PPOPN 1
30889: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30890: LD_EXP 39
30894: PUSH
30895: LD_VAR 0 1
30899: PPUSH
30900: CALL_OW 255
30904: ARRAY
30905: IFFALSE 30934
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30907: LD_VAR 0 2
30911: PPUSH
30912: CALL_OW 264
30916: PUSH
30917: LD_INT 31
30919: IN
30920: IFFALSE 30934
// SetTag ( driver , 0 ) ;
30922: LD_VAR 0 1
30926: PPUSH
30927: LD_INT 0
30929: PPUSH
30930: CALL_OW 109
// end ;
30934: PPOPN 4
30936: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30937: LD_INT 0
30939: PPUSH
30940: PPUSH
30941: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30942: LD_ADDR_VAR 0 3
30946: PUSH
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL_OW 269
30956: ST_TO_ADDR
// x := GetX ( building ) ;
30957: LD_ADDR_VAR 0 4
30961: PUSH
30962: LD_VAR 0 1
30966: PPUSH
30967: CALL_OW 250
30971: ST_TO_ADDR
// y := GetY ( building ) ;
30972: LD_ADDR_VAR 0 5
30976: PUSH
30977: LD_VAR 0 1
30981: PPUSH
30982: CALL_OW 251
30986: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30987: LD_ADDR_EXP 43
30991: PUSH
30992: LD_EXP 43
30996: PPUSH
30997: LD_VAR 0 1
31001: PPUSH
31002: CALL_OW 255
31006: PPUSH
31007: LD_VAR 0 3
31011: PPUSH
31012: LD_VAR 0 4
31016: PUSH
31017: LD_VAR 0 5
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PPUSH
31026: CALL 42051 0 4
31030: ST_TO_ADDR
// end ;
31031: PPOPN 5
31033: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31034: LD_VAR 0 1
31038: PUSH
31039: LD_EXP 30
31043: IN
31044: NOT
31045: IFFALSE 31093
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31047: LD_ADDR_EXP 30
31051: PUSH
31052: LD_EXP 30
31056: PPUSH
31057: LD_EXP 30
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PPUSH
31066: LD_VAR 0 1
31070: PPUSH
31071: CALL_OW 2
31075: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31076: LD_STRING DestinationUnrechable. [unit: 
31078: PUSH
31079: LD_VAR 0 1
31083: STR
31084: PUSH
31085: LD_STRING ]
31087: STR
31088: PPUSH
31089: CALL 8039 0 1
// end ; end ;
31093: PPOPN 1
31095: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: LD_VAR 0 2
31105: PPUSH
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL 59162 0 3
// end ;
31115: PPOPN 3
31117: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL 59170 0 1
// end ; end_of_file
31127: PPOPN 1
31129: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31130: LD_INT 0
31132: PPUSH
31133: PPUSH
31134: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31135: LD_ADDR_VAR 0 7
31139: PUSH
31140: LD_VAR 0 1
31144: PUSH
31145: LD_VAR 0 2
31149: ARRAY
31150: PPUSH
31151: LD_VAR 0 3
31155: PPUSH
31156: LD_VAR 0 4
31160: PPUSH
31161: CALL_OW 1
31165: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31166: LD_ADDR_VAR 0 1
31170: PUSH
31171: LD_VAR 0 1
31175: PPUSH
31176: LD_VAR 0 2
31180: PPUSH
31181: LD_VAR 0 7
31185: PPUSH
31186: CALL_OW 1
31190: ST_TO_ADDR
// result := tab ;
31191: LD_ADDR_VAR 0 5
31195: PUSH
31196: LD_VAR 0 1
31200: ST_TO_ADDR
// end ;
31201: LD_VAR 0 5
31205: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31206: LD_INT 0
31208: PPUSH
31209: PPUSH
31210: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31211: LD_ADDR_VAR 0 5
31215: PUSH
31216: LD_VAR 0 1
31220: PUSH
31221: LD_VAR 0 2
31225: PUSH
31226: LD_INT 1
31228: ARRAY
31229: ARRAY
31230: PPUSH
31231: LD_VAR 0 2
31235: PUSH
31236: LD_INT 2
31238: ARRAY
31239: PPUSH
31240: CALL_OW 3
31244: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31245: LD_ADDR_VAR 0 1
31249: PUSH
31250: LD_VAR 0 1
31254: PPUSH
31255: LD_VAR 0 2
31259: PUSH
31260: LD_INT 1
31262: ARRAY
31263: PPUSH
31264: LD_VAR 0 5
31268: PPUSH
31269: CALL_OW 1
31273: ST_TO_ADDR
// result := tab ;
31274: LD_ADDR_VAR 0 3
31278: PUSH
31279: LD_VAR 0 1
31283: ST_TO_ADDR
// end ;
31284: LD_VAR 0 3
31288: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31289: LD_INT 0
31291: PPUSH
31292: PPUSH
31293: PPUSH
31294: PPUSH
// i := 1 ;
31295: LD_ADDR_VAR 0 5
31299: PUSH
31300: LD_INT 1
31302: ST_TO_ADDR
// while ( i <= tab ) do
31303: LD_VAR 0 5
31307: PUSH
31308: LD_VAR 0 1
31312: LESSEQUAL
31313: IFFALSE 31688
// begin if not tab [ i ] then
31315: LD_VAR 0 1
31319: PUSH
31320: LD_VAR 0 5
31324: ARRAY
31325: NOT
31326: IFFALSE 31330
// break ;
31328: GO 31688
// if value in tab then
31330: LD_VAR 0 2
31334: PUSH
31335: LD_VAR 0 1
31339: IN
31340: IFFALSE 31453
// begin if not mode then
31342: LD_VAR 0 3
31346: NOT
31347: IFFALSE 31367
// tab := tab diff value else
31349: LD_ADDR_VAR 0 1
31353: PUSH
31354: LD_VAR 0 1
31358: PUSH
31359: LD_VAR 0 2
31363: DIFF
31364: ST_TO_ADDR
31365: GO 31429
// for j = 1 to tab do
31367: LD_ADDR_VAR 0 6
31371: PUSH
31372: DOUBLE
31373: LD_INT 1
31375: DEC
31376: ST_TO_ADDR
31377: LD_VAR 0 1
31381: PUSH
31382: FOR_TO
31383: IFFALSE 31427
// if tab [ j ] = value then
31385: LD_VAR 0 1
31389: PUSH
31390: LD_VAR 0 6
31394: ARRAY
31395: PUSH
31396: LD_VAR 0 2
31400: EQUAL
31401: IFFALSE 31425
// begin tab := Delete ( tab , j ) ;
31403: LD_ADDR_VAR 0 1
31407: PUSH
31408: LD_VAR 0 1
31412: PPUSH
31413: LD_VAR 0 6
31417: PPUSH
31418: CALL_OW 3
31422: ST_TO_ADDR
// break ;
31423: GO 31427
// end ;
31425: GO 31382
31427: POP
31428: POP
// i := i - 1 ;
31429: LD_ADDR_VAR 0 5
31433: PUSH
31434: LD_VAR 0 5
31438: PUSH
31439: LD_INT 1
31441: MINUS
31442: ST_TO_ADDR
// if mode then
31443: LD_VAR 0 3
31447: IFFALSE 31451
// break ;
31449: GO 31688
// end else
31451: GO 31672
// if tab [ i ] and value in tab [ i ] then
31453: LD_VAR 0 1
31457: PUSH
31458: LD_VAR 0 5
31462: ARRAY
31463: PUSH
31464: LD_VAR 0 2
31468: PUSH
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: IN
31480: AND
31481: IFFALSE 31672
// begin if not mode then
31483: LD_VAR 0 3
31487: NOT
31488: IFFALSE 31514
// tmp := tab [ i ] diff value else
31490: LD_ADDR_VAR 0 7
31494: PUSH
31495: LD_VAR 0 1
31499: PUSH
31500: LD_VAR 0 5
31504: ARRAY
31505: PUSH
31506: LD_VAR 0 2
31510: DIFF
31511: ST_TO_ADDR
31512: GO 31594
// for j = 1 to tab [ i ] do
31514: LD_ADDR_VAR 0 6
31518: PUSH
31519: DOUBLE
31520: LD_INT 1
31522: DEC
31523: ST_TO_ADDR
31524: LD_VAR 0 1
31528: PUSH
31529: LD_VAR 0 5
31533: ARRAY
31534: PUSH
31535: FOR_TO
31536: IFFALSE 31592
// if value = tab [ i ] [ j ] then
31538: LD_VAR 0 2
31542: PUSH
31543: LD_VAR 0 1
31547: PUSH
31548: LD_VAR 0 5
31552: ARRAY
31553: PUSH
31554: LD_VAR 0 6
31558: ARRAY
31559: EQUAL
31560: IFFALSE 31590
// begin tmp := Delete ( tab [ i ] , j ) ;
31562: LD_ADDR_VAR 0 7
31566: PUSH
31567: LD_VAR 0 1
31571: PUSH
31572: LD_VAR 0 5
31576: ARRAY
31577: PPUSH
31578: LD_VAR 0 6
31582: PPUSH
31583: CALL_OW 3
31587: ST_TO_ADDR
// break ;
31588: GO 31592
// end ;
31590: GO 31535
31592: POP
31593: POP
// if tmp = [ ] then
31594: LD_VAR 0 7
31598: PUSH
31599: EMPTY
31600: EQUAL
31601: IFFALSE 31625
// begin tab := Delete ( tab , i ) ;
31603: LD_ADDR_VAR 0 1
31607: PUSH
31608: LD_VAR 0 1
31612: PPUSH
31613: LD_VAR 0 5
31617: PPUSH
31618: CALL_OW 3
31622: ST_TO_ADDR
// end else
31623: GO 31650
// tab := Replace ( tab , i , tmp ) ;
31625: LD_ADDR_VAR 0 1
31629: PUSH
31630: LD_VAR 0 1
31634: PPUSH
31635: LD_VAR 0 5
31639: PPUSH
31640: LD_VAR 0 7
31644: PPUSH
31645: CALL_OW 1
31649: ST_TO_ADDR
// i := i - 1 ;
31650: LD_ADDR_VAR 0 5
31654: PUSH
31655: LD_VAR 0 5
31659: PUSH
31660: LD_INT 1
31662: MINUS
31663: ST_TO_ADDR
// if mode then
31664: LD_VAR 0 3
31668: IFFALSE 31672
// break ;
31670: GO 31688
// end ; i := i + 1 ;
31672: LD_ADDR_VAR 0 5
31676: PUSH
31677: LD_VAR 0 5
31681: PUSH
31682: LD_INT 1
31684: PLUS
31685: ST_TO_ADDR
// end ;
31686: GO 31303
// result := tab ;
31688: LD_ADDR_VAR 0 4
31692: PUSH
31693: LD_VAR 0 1
31697: ST_TO_ADDR
// end ;
31698: LD_VAR 0 4
31702: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31703: LD_INT 0
31705: PPUSH
31706: PPUSH
// for i = 1 to values do
31707: LD_ADDR_VAR 0 4
31711: PUSH
31712: DOUBLE
31713: LD_INT 1
31715: DEC
31716: ST_TO_ADDR
31717: LD_VAR 0 2
31721: PUSH
31722: FOR_TO
31723: IFFALSE 31756
// tab := Remove ( tab , values [ i ] , false ) ;
31725: LD_ADDR_VAR 0 1
31729: PUSH
31730: LD_VAR 0 1
31734: PPUSH
31735: LD_VAR 0 2
31739: PUSH
31740: LD_VAR 0 4
31744: ARRAY
31745: PPUSH
31746: LD_INT 0
31748: PPUSH
31749: CALL 31289 0 3
31753: ST_TO_ADDR
31754: GO 31722
31756: POP
31757: POP
// result := tab ;
31758: LD_ADDR_VAR 0 3
31762: PUSH
31763: LD_VAR 0 1
31767: ST_TO_ADDR
// end ;
31768: LD_VAR 0 3
31772: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31773: LD_INT 0
31775: PPUSH
31776: PPUSH
31777: PPUSH
// if not GetControl ( veh ) = control_manual then
31778: LD_VAR 0 1
31782: PPUSH
31783: CALL_OW 263
31787: PUSH
31788: LD_INT 1
31790: EQUAL
31791: NOT
31792: IFFALSE 31804
// result := false else
31794: LD_ADDR_VAR 0 2
31798: PUSH
31799: LD_INT 0
31801: ST_TO_ADDR
31802: GO 31949
// if veh in FilterAllUnits ( [ f_empty ] ) then
31804: LD_VAR 0 1
31808: PUSH
31809: LD_INT 58
31811: PUSH
31812: EMPTY
31813: LIST
31814: PPUSH
31815: CALL_OW 69
31819: IN
31820: IFFALSE 31832
// result := false else
31822: LD_ADDR_VAR 0 2
31826: PUSH
31827: LD_INT 0
31829: ST_TO_ADDR
31830: GO 31949
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31832: LD_ADDR_VAR 0 4
31836: PUSH
31837: LD_INT 22
31839: PUSH
31840: LD_VAR 0 1
31844: PPUSH
31845: CALL_OW 255
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 55
31856: PUSH
31857: EMPTY
31858: LIST
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PPUSH
31864: CALL_OW 69
31868: ST_TO_ADDR
// if not filter then
31869: LD_VAR 0 4
31873: NOT
31874: IFFALSE 31886
// result := false else
31876: LD_ADDR_VAR 0 2
31880: PUSH
31881: LD_INT 0
31883: ST_TO_ADDR
31884: GO 31949
// for i = 1 to filter do
31886: LD_ADDR_VAR 0 3
31890: PUSH
31891: DOUBLE
31892: LD_INT 1
31894: DEC
31895: ST_TO_ADDR
31896: LD_VAR 0 4
31900: PUSH
31901: FOR_TO
31902: IFFALSE 31947
// if IsDriver ( filter [ i ] ) = veh then
31904: LD_VAR 0 4
31908: PUSH
31909: LD_VAR 0 3
31913: ARRAY
31914: PPUSH
31915: CALL 98293 0 1
31919: PUSH
31920: LD_VAR 0 1
31924: EQUAL
31925: IFFALSE 31945
// begin result := filter [ i ] ;
31927: LD_ADDR_VAR 0 2
31931: PUSH
31932: LD_VAR 0 4
31936: PUSH
31937: LD_VAR 0 3
31941: ARRAY
31942: ST_TO_ADDR
// break ;
31943: GO 31947
// end ;
31945: GO 31901
31947: POP
31948: POP
// end ; end ;
31949: LD_VAR 0 2
31953: RET
// export function Compare ( val1 , val2 ) ; begin
31954: LD_INT 0
31956: PPUSH
// if val1 = val2 then
31957: LD_VAR 0 1
31961: PUSH
31962: LD_VAR 0 2
31966: EQUAL
31967: IFFALSE 31979
// result := true else
31969: LD_ADDR_VAR 0 3
31973: PUSH
31974: LD_INT 1
31976: ST_TO_ADDR
31977: GO 31987
// result := false ;
31979: LD_ADDR_VAR 0 3
31983: PUSH
31984: LD_INT 0
31986: ST_TO_ADDR
// end ;
31987: LD_VAR 0 3
31991: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31992: LD_INT 0
31994: PPUSH
31995: PPUSH
// result := false ;
31996: LD_ADDR_VAR 0 3
32000: PUSH
32001: LD_INT 0
32003: ST_TO_ADDR
// for j = 1 to e2 do
32004: LD_ADDR_VAR 0 4
32008: PUSH
32009: DOUBLE
32010: LD_INT 1
32012: DEC
32013: ST_TO_ADDR
32014: LD_VAR 0 2
32018: PUSH
32019: FOR_TO
32020: IFFALSE 32054
// if Compare ( e1 , e2 [ j ] ) then
32022: LD_VAR 0 1
32026: PPUSH
32027: LD_VAR 0 2
32031: PUSH
32032: LD_VAR 0 4
32036: ARRAY
32037: PPUSH
32038: CALL 31954 0 2
32042: IFFALSE 32052
// result := true ;
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_INT 1
32051: ST_TO_ADDR
32052: GO 32019
32054: POP
32055: POP
// end ;
32056: LD_VAR 0 3
32060: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32061: LD_INT 0
32063: PPUSH
32064: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32065: LD_VAR 0 1
32069: PPUSH
32070: LD_STRING C
32072: PUSH
32073: LD_VAR 0 2
32077: PUSH
32078: LD_VAR 0 3
32082: PUSH
32083: LD_INT 0
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: LD_INT 0
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: PUSH
32104: LD_STRING v
32106: PUSH
32107: LD_VAR 0 4
32111: PPUSH
32112: CALL_OW 250
32116: PUSH
32117: LD_VAR 0 4
32121: PPUSH
32122: CALL_OW 251
32126: PUSH
32127: LD_VAR 0 4
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 0
32137: PUSH
32138: LD_INT 0
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PPUSH
32154: CALL_OW 446
// end ;
32158: LD_VAR 0 5
32162: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32163: LD_INT 0
32165: PPUSH
32166: PPUSH
32167: PPUSH
// linked := UnitsLinked ( unit ) ;
32168: LD_ADDR_VAR 0 4
32172: PUSH
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 432
32182: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32183: LD_ADDR_VAR 0 3
32187: PUSH
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_INT 3
32195: PPUSH
32196: CALL_OW 259
32200: ST_TO_ADDR
// if sk > linked then
32201: LD_VAR 0 3
32205: PUSH
32206: LD_VAR 0 4
32210: GREATER
32211: IFFALSE 32223
// result := true else
32213: LD_ADDR_VAR 0 2
32217: PUSH
32218: LD_INT 1
32220: ST_TO_ADDR
32221: GO 32231
// result := false ;
32223: LD_ADDR_VAR 0 2
32227: PUSH
32228: LD_INT 0
32230: ST_TO_ADDR
// end ;
32231: LD_VAR 0 2
32235: RET
// export function NotTask ( unit ) ; begin
32236: LD_INT 0
32238: PPUSH
// result := true ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 1
32246: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32247: LD_VAR 0 1
32251: PPUSH
32252: CALL_OW 437
32256: PUSH
32257: LD_VAR 0 1
32261: PPUSH
32262: CALL_OW 314
32266: OR
32267: IFFALSE 32277
// result := false ;
32269: LD_ADDR_VAR 0 2
32273: PUSH
32274: LD_INT 0
32276: ST_TO_ADDR
// end ;
32277: LD_VAR 0 2
32281: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32282: LD_INT 0
32284: PPUSH
32285: PPUSH
32286: PPUSH
32287: PPUSH
32288: PPUSH
// dist := 99999 ;
32289: LD_ADDR_VAR 0 7
32293: PUSH
32294: LD_INT 99999
32296: ST_TO_ADDR
// un := - 1 ;
32297: LD_ADDR_VAR 0 6
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: ST_TO_ADDR
// if units1 and units2 then
32306: LD_VAR 0 1
32310: PUSH
32311: LD_VAR 0 2
32315: AND
32316: IFFALSE 32404
// for i in units1 do
32318: LD_ADDR_VAR 0 4
32322: PUSH
32323: LD_VAR 0 1
32327: PUSH
32328: FOR_IN
32329: IFFALSE 32402
// for j in units2 do
32331: LD_ADDR_VAR 0 5
32335: PUSH
32336: LD_VAR 0 2
32340: PUSH
32341: FOR_IN
32342: IFFALSE 32398
// if GetDistUnits ( i , j ) < dist then
32344: LD_VAR 0 4
32348: PPUSH
32349: LD_VAR 0 5
32353: PPUSH
32354: CALL_OW 296
32358: PUSH
32359: LD_VAR 0 7
32363: LESS
32364: IFFALSE 32396
// begin un := i ;
32366: LD_ADDR_VAR 0 6
32370: PUSH
32371: LD_VAR 0 4
32375: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32376: LD_ADDR_VAR 0 7
32380: PUSH
32381: LD_VAR 0 4
32385: PPUSH
32386: LD_VAR 0 5
32390: PPUSH
32391: CALL_OW 296
32395: ST_TO_ADDR
// end ;
32396: GO 32341
32398: POP
32399: POP
32400: GO 32328
32402: POP
32403: POP
// result := [ un , dist ] ;
32404: LD_ADDR_VAR 0 3
32408: PUSH
32409: LD_VAR 0 6
32413: PUSH
32414: LD_VAR 0 7
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: ST_TO_ADDR
// end ;
32423: LD_VAR 0 3
32427: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32428: LD_INT 0
32430: PPUSH
32431: PPUSH
32432: PPUSH
32433: PPUSH
32434: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32435: LD_VAR 0 1
32439: NOT
32440: PUSH
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 256
32450: PUSH
32451: LD_INT 250
32453: LESS
32454: OR
32455: PUSH
32456: LD_VAR 0 1
32460: PPUSH
32461: CALL_OW 314
32465: PUSH
32466: LD_VAR 0 1
32470: PPUSH
32471: CALL_OW 261
32475: PUSH
32476: LD_INT 20
32478: GREATER
32479: AND
32480: OR
32481: IFFALSE 32485
// exit ;
32483: GO 32859
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 261
32494: PUSH
32495: LD_INT 20
32497: LESS
32498: PUSH
32499: LD_VAR 0 1
32503: PPUSH
32504: CALL_OW 110
32508: PUSH
32509: LD_INT 21
32511: EQUAL
32512: NOT
32513: AND
32514: IFFALSE 32550
// begin ComStop ( bulldozer ) ;
32516: LD_VAR 0 1
32520: PPUSH
32521: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32525: LD_VAR 0 1
32529: PPUSH
32530: LD_INT 21
32532: PPUSH
32533: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32537: LD_VAR 0 1
32541: PPUSH
32542: CALL 26278 0 1
// exit ;
32546: GO 32859
// end else
32548: GO 32577
// if GetFuel ( bulldozer ) > 20 then
32550: LD_VAR 0 1
32554: PPUSH
32555: CALL_OW 261
32559: PUSH
32560: LD_INT 20
32562: GREATER
32563: IFFALSE 32577
// SetTag ( bulldozer , 0 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 0
32572: PPUSH
32573: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32577: LD_ADDR_VAR 0 5
32581: PUSH
32582: LD_VAR 0 2
32586: PPUSH
32587: CALL_OW 353
32591: ST_TO_ADDR
// tmp := [ ] ;
32592: LD_ADDR_VAR 0 6
32596: PUSH
32597: EMPTY
32598: ST_TO_ADDR
// for i = 1 to list do
32599: LD_ADDR_VAR 0 4
32603: PUSH
32604: DOUBLE
32605: LD_INT 1
32607: DEC
32608: ST_TO_ADDR
32609: LD_VAR 0 5
32613: PUSH
32614: FOR_TO
32615: IFFALSE 32713
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32617: LD_VAR 0 5
32621: PUSH
32622: LD_VAR 0 4
32626: ARRAY
32627: PUSH
32628: LD_INT 1
32630: ARRAY
32631: PPUSH
32632: LD_VAR 0 5
32636: PUSH
32637: LD_VAR 0 4
32641: ARRAY
32642: PUSH
32643: LD_INT 2
32645: ARRAY
32646: PPUSH
32647: CALL_OW 554
32651: IFFALSE 32711
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32653: LD_ADDR_VAR 0 6
32657: PUSH
32658: LD_VAR 0 6
32662: PPUSH
32663: LD_VAR 0 6
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PPUSH
32672: LD_VAR 0 5
32676: PUSH
32677: LD_VAR 0 4
32681: ARRAY
32682: PUSH
32683: LD_INT 1
32685: ARRAY
32686: PUSH
32687: LD_VAR 0 5
32691: PUSH
32692: LD_VAR 0 4
32696: ARRAY
32697: PUSH
32698: LD_INT 2
32700: ARRAY
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL_OW 1
32710: ST_TO_ADDR
// end ;
32711: GO 32614
32713: POP
32714: POP
// ComStop ( bulldozer ) ;
32715: LD_VAR 0 1
32719: PPUSH
32720: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32724: LD_ADDR_VAR 0 7
32728: PUSH
32729: LD_VAR 0 1
32733: PPUSH
32734: CALL_OW 250
32738: PUSH
32739: LD_VAR 0 1
32743: PPUSH
32744: CALL_OW 251
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: ST_TO_ADDR
// for i = tmp downto 1 do
32753: LD_ADDR_VAR 0 4
32757: PUSH
32758: DOUBLE
32759: LD_VAR 0 6
32763: INC
32764: ST_TO_ADDR
32765: LD_INT 1
32767: PUSH
32768: FOR_DOWNTO
32769: IFFALSE 32857
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32771: LD_ADDR_VAR 0 7
32775: PUSH
32776: LD_VAR 0 7
32780: PUSH
32781: LD_INT 1
32783: ARRAY
32784: PPUSH
32785: LD_VAR 0 7
32789: PUSH
32790: LD_INT 2
32792: ARRAY
32793: PPUSH
32794: LD_VAR 0 6
32798: PPUSH
32799: CALL 32960 0 3
32803: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32804: LD_VAR 0 1
32808: PPUSH
32809: LD_VAR 0 7
32813: PUSH
32814: LD_INT 1
32816: ARRAY
32817: PPUSH
32818: LD_VAR 0 7
32822: PUSH
32823: LD_INT 2
32825: ARRAY
32826: PPUSH
32827: CALL 32864 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32831: LD_ADDR_VAR 0 6
32835: PUSH
32836: LD_VAR 0 6
32840: PPUSH
32841: LD_VAR 0 7
32845: PUSH
32846: LD_INT 3
32848: ARRAY
32849: PPUSH
32850: CALL_OW 3
32854: ST_TO_ADDR
// end ;
32855: GO 32768
32857: POP
32858: POP
// end ;
32859: LD_VAR 0 3
32863: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32864: LD_INT 0
32866: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32867: LD_VAR 0 2
32871: PPUSH
32872: LD_VAR 0 3
32876: PPUSH
32877: CALL_OW 351
32881: PUSH
32882: LD_VAR 0 2
32886: PPUSH
32887: LD_VAR 0 3
32891: PPUSH
32892: CALL_OW 554
32896: AND
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 488
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 428
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: EQUAL
32933: AND
32934: IFFALSE 32955
// AddComMoveXY ( bulldozer , x , y ) ;
32936: LD_VAR 0 1
32940: PPUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_VAR 0 3
32950: PPUSH
32951: CALL_OW 171
// end ;
32955: LD_VAR 0 4
32959: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32960: LD_INT 0
32962: PPUSH
32963: PPUSH
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
// dist := 99999 ;
32969: LD_ADDR_VAR 0 6
32973: PUSH
32974: LD_INT 99999
32976: ST_TO_ADDR
// for i = 1 to list do
32977: LD_ADDR_VAR 0 5
32981: PUSH
32982: DOUBLE
32983: LD_INT 1
32985: DEC
32986: ST_TO_ADDR
32987: LD_VAR 0 3
32991: PUSH
32992: FOR_TO
32993: IFFALSE 33131
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32995: LD_ADDR_VAR 0 7
32999: PUSH
33000: LD_VAR 0 1
33004: PPUSH
33005: LD_VAR 0 2
33009: PPUSH
33010: LD_VAR 0 3
33014: PUSH
33015: LD_VAR 0 5
33019: ARRAY
33020: PUSH
33021: LD_INT 1
33023: ARRAY
33024: PPUSH
33025: LD_VAR 0 3
33029: PUSH
33030: LD_VAR 0 5
33034: ARRAY
33035: PUSH
33036: LD_INT 2
33038: ARRAY
33039: PPUSH
33040: CALL_OW 298
33044: ST_TO_ADDR
// if d = 0 then
33045: LD_VAR 0 7
33049: PUSH
33050: LD_INT 0
33052: EQUAL
33053: IFFALSE 33057
// continue ;
33055: GO 32992
// if d < dist then
33057: LD_VAR 0 7
33061: PUSH
33062: LD_VAR 0 6
33066: LESS
33067: IFFALSE 33129
// begin _x := list [ i ] [ 1 ] ;
33069: LD_ADDR_VAR 0 8
33073: PUSH
33074: LD_VAR 0 3
33078: PUSH
33079: LD_VAR 0 5
33083: ARRAY
33084: PUSH
33085: LD_INT 1
33087: ARRAY
33088: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33089: LD_ADDR_VAR 0 9
33093: PUSH
33094: LD_VAR 0 3
33098: PUSH
33099: LD_VAR 0 5
33103: ARRAY
33104: PUSH
33105: LD_INT 2
33107: ARRAY
33108: ST_TO_ADDR
// _i := i ;
33109: LD_ADDR_VAR 0 10
33113: PUSH
33114: LD_VAR 0 5
33118: ST_TO_ADDR
// dist := d ;
33119: LD_ADDR_VAR 0 6
33123: PUSH
33124: LD_VAR 0 7
33128: ST_TO_ADDR
// end ; end ;
33129: GO 32992
33131: POP
33132: POP
// result := [ _x , _y , _i , dist ] ;
33133: LD_ADDR_VAR 0 4
33137: PUSH
33138: LD_VAR 0 8
33142: PUSH
33143: LD_VAR 0 9
33147: PUSH
33148: LD_VAR 0 10
33152: PUSH
33153: LD_VAR 0 6
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: ST_TO_ADDR
// end ;
33164: LD_VAR 0 4
33168: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33169: LD_INT 0
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
// for i = 1 to list do
33176: LD_ADDR_VAR 0 5
33180: PUSH
33181: DOUBLE
33182: LD_INT 1
33184: DEC
33185: ST_TO_ADDR
33186: LD_VAR 0 1
33190: PUSH
33191: FOR_TO
33192: IFFALSE 33506
// begin for j = list downto 2 do
33194: LD_ADDR_VAR 0 6
33198: PUSH
33199: DOUBLE
33200: LD_VAR 0 1
33204: INC
33205: ST_TO_ADDR
33206: LD_INT 2
33208: PUSH
33209: FOR_DOWNTO
33210: IFFALSE 33502
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33212: LD_VAR 0 2
33216: PPUSH
33217: LD_VAR 0 3
33221: PPUSH
33222: LD_VAR 0 1
33226: PUSH
33227: LD_VAR 0 6
33231: ARRAY
33232: PUSH
33233: LD_INT 1
33235: ARRAY
33236: PPUSH
33237: LD_VAR 0 1
33241: PUSH
33242: LD_VAR 0 6
33246: ARRAY
33247: PUSH
33248: LD_INT 2
33250: ARRAY
33251: PPUSH
33252: CALL_OW 298
33256: PUSH
33257: LD_VAR 0 2
33261: PPUSH
33262: LD_VAR 0 3
33266: PPUSH
33267: LD_VAR 0 1
33271: PUSH
33272: LD_VAR 0 6
33276: PUSH
33277: LD_INT 1
33279: MINUS
33280: ARRAY
33281: PUSH
33282: LD_INT 1
33284: ARRAY
33285: PPUSH
33286: LD_VAR 0 1
33290: PUSH
33291: LD_VAR 0 6
33295: PUSH
33296: LD_INT 1
33298: MINUS
33299: ARRAY
33300: PUSH
33301: LD_INT 2
33303: ARRAY
33304: PPUSH
33305: CALL_OW 298
33309: LESS
33310: IFFALSE 33500
// begin _x := list [ j ] [ 1 ] ;
33312: LD_ADDR_VAR 0 7
33316: PUSH
33317: LD_VAR 0 1
33321: PUSH
33322: LD_VAR 0 6
33326: ARRAY
33327: PUSH
33328: LD_INT 1
33330: ARRAY
33331: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33332: LD_ADDR_VAR 0 8
33336: PUSH
33337: LD_VAR 0 1
33341: PUSH
33342: LD_VAR 0 6
33346: ARRAY
33347: PUSH
33348: LD_INT 2
33350: ARRAY
33351: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33352: LD_ADDR_VAR 0 1
33356: PUSH
33357: LD_VAR 0 1
33361: PPUSH
33362: LD_VAR 0 6
33366: PPUSH
33367: LD_INT 1
33369: PPUSH
33370: LD_VAR 0 1
33374: PUSH
33375: LD_VAR 0 6
33379: PUSH
33380: LD_INT 1
33382: MINUS
33383: ARRAY
33384: PUSH
33385: LD_INT 1
33387: ARRAY
33388: PPUSH
33389: CALL 31130 0 4
33393: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33394: LD_ADDR_VAR 0 1
33398: PUSH
33399: LD_VAR 0 1
33403: PPUSH
33404: LD_VAR 0 6
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 1
33416: PUSH
33417: LD_VAR 0 6
33421: PUSH
33422: LD_INT 1
33424: MINUS
33425: ARRAY
33426: PUSH
33427: LD_INT 2
33429: ARRAY
33430: PPUSH
33431: CALL 31130 0 4
33435: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33436: LD_ADDR_VAR 0 1
33440: PUSH
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_VAR 0 6
33450: PUSH
33451: LD_INT 1
33453: MINUS
33454: PPUSH
33455: LD_INT 1
33457: PPUSH
33458: LD_VAR 0 7
33462: PPUSH
33463: CALL 31130 0 4
33467: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33468: LD_ADDR_VAR 0 1
33472: PUSH
33473: LD_VAR 0 1
33477: PPUSH
33478: LD_VAR 0 6
33482: PUSH
33483: LD_INT 1
33485: MINUS
33486: PPUSH
33487: LD_INT 2
33489: PPUSH
33490: LD_VAR 0 8
33494: PPUSH
33495: CALL 31130 0 4
33499: ST_TO_ADDR
// end ; end ;
33500: GO 33209
33502: POP
33503: POP
// end ;
33504: GO 33191
33506: POP
33507: POP
// result := list ;
33508: LD_ADDR_VAR 0 4
33512: PUSH
33513: LD_VAR 0 1
33517: ST_TO_ADDR
// end ;
33518: LD_VAR 0 4
33522: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33523: LD_INT 0
33525: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33526: LD_ADDR_VAR 0 5
33530: PUSH
33531: LD_VAR 0 1
33535: PPUSH
33536: LD_VAR 0 2
33540: PPUSH
33541: CALL_OW 546
33545: PUSH
33546: LD_INT 2
33548: ARRAY
33549: PUSH
33550: LD_VAR 0 3
33554: PPUSH
33555: LD_VAR 0 4
33559: PPUSH
33560: CALL_OW 546
33564: PUSH
33565: LD_INT 2
33567: ARRAY
33568: MINUS
33569: ST_TO_ADDR
// if result < 0 then
33570: LD_VAR 0 5
33574: PUSH
33575: LD_INT 0
33577: LESS
33578: IFFALSE 33595
// result := result * - 1 ;
33580: LD_ADDR_VAR 0 5
33584: PUSH
33585: LD_VAR 0 5
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: MUL
33594: ST_TO_ADDR
// end ;
33595: LD_VAR 0 5
33599: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33600: LD_INT 0
33602: PPUSH
33603: PPUSH
// area = ListEnvironmentArea ( area ) ;
33604: LD_ADDR_VAR 0 2
33608: PUSH
33609: LD_VAR 0 2
33613: PPUSH
33614: CALL_OW 353
33618: ST_TO_ADDR
// if bulldozer > 0 then
33619: LD_VAR 0 1
33623: PUSH
33624: LD_INT 0
33626: GREATER
33627: IFFALSE 33738
// for i = area downto 1 do
33629: LD_ADDR_VAR 0 4
33633: PUSH
33634: DOUBLE
33635: LD_VAR 0 2
33639: INC
33640: ST_TO_ADDR
33641: LD_INT 1
33643: PUSH
33644: FOR_DOWNTO
33645: IFFALSE 33736
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33647: LD_VAR 0 2
33651: PUSH
33652: LD_VAR 0 4
33656: ARRAY
33657: PUSH
33658: LD_INT 1
33660: ARRAY
33661: PPUSH
33662: LD_VAR 0 2
33666: PUSH
33667: LD_VAR 0 4
33671: ARRAY
33672: PUSH
33673: LD_INT 2
33675: ARRAY
33676: PPUSH
33677: CALL_OW 351
33681: IFFALSE 33734
// if not HasTask ( bulldozer ) then
33683: LD_VAR 0 1
33687: PPUSH
33688: CALL_OW 314
33692: NOT
33693: IFFALSE 33734
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33695: LD_VAR 0 1
33699: PPUSH
33700: LD_VAR 0 2
33704: PUSH
33705: LD_VAR 0 4
33709: ARRAY
33710: PUSH
33711: LD_INT 1
33713: ARRAY
33714: PPUSH
33715: LD_VAR 0 2
33719: PUSH
33720: LD_VAR 0 4
33724: ARRAY
33725: PUSH
33726: LD_INT 2
33728: ARRAY
33729: PPUSH
33730: CALL_OW 171
33734: GO 33644
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 3
33742: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33749: LD_ADDR_VAR 0 6
33753: PUSH
33754: LD_INT 22
33756: PUSH
33757: LD_VAR 0 1
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 21
33768: PUSH
33769: LD_VAR 0 2
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PPUSH
33782: CALL_OW 69
33786: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33787: LD_ADDR_VAR 0 7
33791: PUSH
33792: LD_VAR 0 3
33796: PPUSH
33797: LD_INT 22
33799: PUSH
33800: LD_VAR 0 1
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 21
33811: PUSH
33812: LD_VAR 0 2
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PPUSH
33825: CALL_OW 70
33829: ST_TO_ADDR
// if tmp and pom then
33830: LD_VAR 0 6
33834: PUSH
33835: LD_VAR 0 7
33839: AND
33840: IFFALSE 33860
// result := tmp diff pom else
33842: LD_ADDR_VAR 0 4
33846: PUSH
33847: LD_VAR 0 6
33851: PUSH
33852: LD_VAR 0 7
33856: DIFF
33857: ST_TO_ADDR
33858: GO 33868
// result := false ;
33860: LD_ADDR_VAR 0 4
33864: PUSH
33865: LD_INT 0
33867: ST_TO_ADDR
// end ;
33868: LD_VAR 0 4
33872: RET
// export function SavePosition ( unit ) ; begin
33873: LD_INT 0
33875: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33876: LD_VAR 0 1
33880: PPUSH
33881: LD_VAR 0 1
33885: PPUSH
33886: CALL_OW 250
33890: PPUSH
33891: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: LD_VAR 0 1
33904: PPUSH
33905: CALL_OW 251
33909: PPUSH
33910: CALL_OW 232
// end ;
33914: LD_VAR 0 2
33918: RET
// export function GetPosition ( unit ) ; begin
33919: LD_INT 0
33921: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33922: LD_ADDR_VAR 0 2
33926: PUSH
33927: LD_VAR 0 1
33931: PPUSH
33932: CALL_OW 252
33936: PUSH
33937: LD_VAR 0 1
33941: PPUSH
33942: CALL_OW 253
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: ST_TO_ADDR
// end ;
33951: LD_VAR 0 2
33955: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33956: LD_INT 0
33958: PPUSH
// if unit in unreachableList then
33959: LD_VAR 0 1
33963: PUSH
33964: LD_EXP 30
33968: IN
33969: IFFALSE 33987
// unreachableList := unreachableList diff unit ;
33971: LD_ADDR_EXP 30
33975: PUSH
33976: LD_EXP 30
33980: PUSH
33981: LD_VAR 0 1
33985: DIFF
33986: ST_TO_ADDR
// if ValidHex ( x , y ) then
33987: LD_VAR 0 2
33991: PPUSH
33992: LD_VAR 0 3
33996: PPUSH
33997: CALL_OW 488
34001: IFFALSE 34027
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34003: LD_VAR 0 1
34007: PPUSH
34008: LD_VAR 0 2
34012: PPUSH
34013: LD_VAR 0 3
34017: PPUSH
34018: CALL_OW 428
34022: PPUSH
34023: CALL_OW 115
// Wait ( 3 ) ;
34027: LD_INT 3
34029: PPUSH
34030: CALL_OW 67
// if unit in unreachableList then
34034: LD_VAR 0 1
34038: PUSH
34039: LD_EXP 30
34043: IN
34044: IFFALSE 34056
// result := false else
34046: LD_ADDR_VAR 0 4
34050: PUSH
34051: LD_INT 0
34053: ST_TO_ADDR
34054: GO 34064
// result := true ;
34056: LD_ADDR_VAR 0 4
34060: PUSH
34061: LD_INT 1
34063: ST_TO_ADDR
// end ; end_of_file
34064: LD_VAR 0 4
34068: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34069: LD_EXP 31
34073: IFFALSE 34135
34075: GO 34077
34077: DISABLE
34078: LD_INT 0
34080: PPUSH
// begin enable ;
34081: ENABLE
// for i = 1 to mc_crates_list do
34082: LD_ADDR_VAR 0 1
34086: PUSH
34087: DOUBLE
34088: LD_INT 1
34090: DEC
34091: ST_TO_ADDR
34092: LD_EXP 32
34096: PUSH
34097: FOR_TO
34098: IFFALSE 34129
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34100: LD_EXP 32
34104: PUSH
34105: LD_VAR 0 1
34109: ARRAY
34110: PPUSH
34111: LD_INT 5
34113: PPUSH
34114: LD_INT 50
34116: PPUSH
34117: LD_INT 700
34119: PPUSH
34120: LD_INT 20
34122: PPUSH
34123: CALL 24485 0 5
34127: GO 34097
34129: POP
34130: POP
// MC_Game ( ) ;
34131: CALL 34138 0 0
// end ;
34135: PPOPN 1
34137: END
// export function MC_Game ( ) ; var i , side , un ; begin
34138: LD_INT 0
34140: PPUSH
34141: PPUSH
34142: PPUSH
34143: PPUSH
// if not isTest then
34144: LD_EXP 1
34148: NOT
34149: IFFALSE 34169
// MC_Show ( [ #tick , tick ] ) else
34151: LD_STRING #tick
34153: PUSH
34154: LD_OWVAR 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PPUSH
34163: CALL 8569 0 1
34167: GO 34178
// MC_Show ( debug_string ) ;
34169: LD_EXP 2
34173: PPUSH
34174: CALL 8569 0 1
// for side = 1 to 8 do
34178: LD_ADDR_VAR 0 3
34182: PUSH
34183: DOUBLE
34184: LD_INT 1
34186: DEC
34187: ST_TO_ADDR
34188: LD_INT 8
34190: PUSH
34191: FOR_TO
34192: IFFALSE 36192
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34194: LD_EXP 39
34198: PUSH
34199: LD_VAR 0 3
34203: ARRAY
34204: PUSH
34205: LD_INT 0
34207: EQUAL
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: EMPTY
34215: PPUSH
34216: CALL 11786 0 2
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: OR
34225: IFFALSE 34229
// continue ;
34227: GO 34191
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34229: LD_VAR 0 3
34233: PPUSH
34234: LD_VAR 0 3
34238: PPUSH
34239: CALL 25006 0 1
34243: PPUSH
34244: CALL 36199 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34248: LD_EXP 71
34252: PUSH
34253: LD_VAR 0 3
34257: ARRAY
34258: PUSH
34259: LD_INT 1
34261: ARRAY
34262: PUSH
34263: LD_INT 0
34265: GREATER
34266: PUSH
34267: LD_EXP 69
34271: PUSH
34272: LD_VAR 0 3
34276: ARRAY
34277: PUSH
34278: LD_INT 1
34280: ARRAY
34281: PUSH
34282: LD_INT 0
34284: EQUAL
34285: AND
34286: PUSH
34287: LD_VAR 0 3
34291: PPUSH
34292: LD_INT 7
34294: PPUSH
34295: EMPTY
34296: PPUSH
34297: CALL 12354 0 3
34301: NOT
34302: AND
34303: IFFALSE 34340
// begin for i in MREG_Attackers [ side ] do
34305: LD_ADDR_VAR 0 2
34309: PUSH
34310: LD_EXP 71
34314: PUSH
34315: LD_VAR 0 3
34319: ARRAY
34320: PUSH
34321: FOR_IN
34322: IFFALSE 34338
// SetTag ( i , 7 ) ;
34324: LD_VAR 0 2
34328: PPUSH
34329: LD_INT 7
34331: PPUSH
34332: CALL_OW 109
34336: GO 34321
34338: POP
34339: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34340: LD_VAR 0 3
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: EMPTY
34349: PPUSH
34350: CALL 12354 0 3
34354: IFFALSE 34414
// begin if side = 1 then
34356: LD_VAR 0 3
34360: PUSH
34361: LD_INT 1
34363: EQUAL
34364: IFFALSE 34373
// RaiseSailEvent ( 101 ) ;
34366: LD_INT 101
34368: PPUSH
34369: CALL_OW 427
// if side = 4 then
34373: LD_VAR 0 3
34377: PUSH
34378: LD_INT 4
34380: EQUAL
34381: IFFALSE 34390
// RaiseSailEvent ( 102 ) ;
34383: LD_INT 102
34385: PPUSH
34386: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: LD_INT 7
34402: PPUSH
34403: EMPTY
34404: PPUSH
34405: CALL 12354 0 3
34409: PPUSH
34410: CALL 8487 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34414: LD_VAR 0 3
34418: PPUSH
34419: CALL 18034 0 1
34423: PUSH
34424: LD_VAR 0 3
34428: PPUSH
34429: CALL 11690 0 1
34433: AND
34434: IFFALSE 34445
// MCL_Start ( side ) ;
34436: LD_VAR 0 3
34440: PPUSH
34441: CALL 17991 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34445: LD_ADDR_EXP 35
34449: PUSH
34450: LD_EXP 35
34454: PPUSH
34455: LD_VAR 0 3
34459: PPUSH
34460: LD_VAR 0 3
34464: PPUSH
34465: CALL 19291 0 1
34469: PPUSH
34470: CALL_OW 1
34474: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34475: LD_ADDR_EXP 47
34479: PUSH
34480: LD_EXP 47
34484: PPUSH
34485: LD_VAR 0 3
34489: PPUSH
34490: LD_VAR 0 3
34494: PPUSH
34495: CALL 11104 0 1
34499: PPUSH
34500: CALL_OW 1
34504: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34505: LD_VAR 0 3
34509: PPUSH
34510: LD_INT 21
34512: PUSH
34513: LD_INT 2
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PPUSH
34520: CALL 11651 0 2
34524: IFFALSE 34535
// MCV_CheckStatus ( side ) ;
34526: LD_VAR 0 3
34530: PPUSH
34531: CALL 27188 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_EXP 53
34544: PPUSH
34545: CALL 42999 0 2
34549: IFFALSE 34634
// begin for i = MREG_ToChangeClass downto 1 do
34551: LD_ADDR_VAR 0 2
34555: PUSH
34556: DOUBLE
34557: LD_EXP 53
34561: INC
34562: ST_TO_ADDR
34563: LD_INT 1
34565: PUSH
34566: FOR_DOWNTO
34567: IFFALSE 34632
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34569: LD_EXP 53
34573: PUSH
34574: LD_VAR 0 2
34578: ARRAY
34579: PUSH
34580: LD_INT 1
34582: ARRAY
34583: PUSH
34584: LD_VAR 0 3
34588: EQUAL
34589: IFFALSE 34630
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34591: LD_VAR 0 3
34595: PPUSH
34596: LD_EXP 53
34600: PUSH
34601: LD_VAR 0 2
34605: ARRAY
34606: PUSH
34607: LD_INT 2
34609: ARRAY
34610: PPUSH
34611: LD_EXP 53
34615: PUSH
34616: LD_VAR 0 2
34620: ARRAY
34621: PUSH
34622: LD_INT 3
34624: ARRAY
34625: PPUSH
34626: CALL 16558 0 3
// end ; end ;
34630: GO 34566
34632: POP
34633: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34634: LD_INT 1
34636: PUSH
34637: LD_EXP 38
34641: PUSH
34642: LD_VAR 0 3
34646: ARRAY
34647: IN
34648: IFFALSE 34659
// begin MCN_TrainApe ( side ) ;
34650: LD_VAR 0 3
34654: PPUSH
34655: CALL 18944 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34659: LD_VAR 0 3
34663: PPUSH
34664: LD_INT 30
34666: PUSH
34667: LD_INT 3
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PPUSH
34674: CALL 11651 0 2
34678: IFFALSE 34852
// begin if MCF_Tag ( side , 10 , [ ] ) then
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 10
34687: PPUSH
34688: EMPTY
34689: PPUSH
34690: CALL 12354 0 3
34694: IFFALSE 34741
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12354 0 3
34710: PPUSH
34711: LD_VAR 0 3
34715: PPUSH
34716: LD_INT 30
34718: PUSH
34719: LD_INT 3
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PPUSH
34726: CALL 11651 0 2
34730: PUSH
34731: LD_INT 1
34733: ARRAY
34734: PPUSH
34735: CALL_OW 168
// end else
34739: GO 34852
// if MREG_ToConstruct [ side ] then
34741: LD_EXP 51
34745: PUSH
34746: LD_VAR 0 3
34750: ARRAY
34751: IFFALSE 34852
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34753: LD_VAR 0 3
34757: PPUSH
34758: LD_VAR 0 3
34762: PPUSH
34763: LD_INT 30
34765: PUSH
34766: LD_INT 3
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PPUSH
34773: CALL 11651 0 2
34777: PUSH
34778: LD_INT 1
34780: ARRAY
34781: PPUSH
34782: LD_EXP 51
34786: PUSH
34787: LD_VAR 0 3
34791: ARRAY
34792: PUSH
34793: LD_INT 1
34795: ARRAY
34796: PUSH
34797: LD_EXP 51
34801: PUSH
34802: LD_VAR 0 3
34806: ARRAY
34807: PUSH
34808: LD_INT 2
34810: ARRAY
34811: PUSH
34812: LD_EXP 51
34816: PUSH
34817: LD_VAR 0 3
34821: ARRAY
34822: PUSH
34823: LD_INT 3
34825: ARRAY
34826: PUSH
34827: LD_EXP 51
34831: PUSH
34832: LD_VAR 0 3
34836: ARRAY
34837: PUSH
34838: LD_INT 4
34840: ARRAY
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: PPUSH
34848: CALL 25496 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34852: LD_VAR 0 3
34856: PPUSH
34857: LD_INT 30
34859: PUSH
34860: LD_INT 3
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PPUSH
34867: CALL 11651 0 2
34871: PUSH
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_EXP 43
34881: PPUSH
34882: CALL 42999 0 2
34886: AND
34887: PUSH
34888: LD_INT 22
34890: PUSH
34891: LD_VAR 0 3
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 2
34902: PUSH
34903: LD_INT 30
34905: PUSH
34906: LD_INT 33
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 30
34915: PUSH
34916: LD_INT 32
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 35
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: LIST
34942: PPUSH
34943: CALL_OW 69
34947: AND
34948: IFFALSE 34959
// MCV_Turret ( side ) ;
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL 25933 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34959: LD_EXP 42
34963: PUSH
34964: LD_VAR 0 3
34968: ARRAY
34969: PUSH
34970: LD_INT 1
34972: GREATER
34973: PUSH
34974: LD_VAR 0 3
34978: PPUSH
34979: CALL 25006 0 1
34983: PUSH
34984: LD_INT 0
34986: EQUAL
34987: AND
34988: IFFALSE 35150
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34990: LD_EXP 42
34994: PUSH
34995: LD_VAR 0 3
34999: ARRAY
35000: PUSH
35001: LD_INT 1
35003: ARRAY
35004: PPUSH
35005: CALL_OW 353
35009: IFFALSE 35047
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35011: LD_EXP 42
35015: PUSH
35016: LD_VAR 0 3
35020: ARRAY
35021: PUSH
35022: LD_INT 2
35024: ARRAY
35025: PPUSH
35026: LD_EXP 42
35030: PUSH
35031: LD_VAR 0 3
35035: ARRAY
35036: PUSH
35037: LD_INT 1
35039: ARRAY
35040: PPUSH
35041: CALL 32428 0 2
35045: GO 35150
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35047: LD_VAR 0 3
35051: PPUSH
35052: LD_INT 30
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PPUSH
35062: CALL 11651 0 2
35066: IFFALSE 35150
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35068: LD_VAR 0 3
35072: PPUSH
35073: LD_INT 30
35075: PUSH
35076: LD_INT 3
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PPUSH
35083: CALL 11651 0 2
35087: PUSH
35088: LD_INT 1
35090: ARRAY
35091: PPUSH
35092: CALL_OW 461
35096: PUSH
35097: LD_INT 2
35099: EQUAL
35100: IFFALSE 35150
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35102: LD_EXP 42
35106: PUSH
35107: LD_VAR 0 3
35111: ARRAY
35112: PUSH
35113: LD_INT 2
35115: ARRAY
35116: PPUSH
35117: LD_INT 10
35119: PPUSH
35120: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35124: LD_ADDR_EXP 42
35128: PUSH
35129: LD_EXP 42
35133: PPUSH
35134: LD_VAR 0 3
35138: PPUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: PPUSH
35145: CALL_OW 1
35149: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 33
35157: PUSH
35158: LD_INT 2
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PPUSH
35165: CALL 11651 0 2
35169: IFFALSE 35209
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_VAR 0 3
35180: PPUSH
35181: LD_INT 33
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PPUSH
35191: CALL 11651 0 2
35195: PUSH
35196: LD_INT 1
35198: ARRAY
35199: PPUSH
35200: CALL_OW 248
35204: PPUSH
35205: CALL 26487 0 2
// if MREG_ToRepair [ side ] then
35209: LD_EXP 47
35213: PUSH
35214: LD_VAR 0 3
35218: ARRAY
35219: IFFALSE 35232
// begin MCB_Repair ( side ) ;
35221: LD_VAR 0 3
35225: PPUSH
35226: CALL 11391 0 1
// end else
35230: GO 36145
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35232: LD_VAR 0 3
35236: PPUSH
35237: LD_EXP 49
35241: PPUSH
35242: CALL 42999 0 2
35246: PUSH
35247: LD_VAR 0 3
35251: PPUSH
35252: LD_EXP 40
35256: PPUSH
35257: CALL 42999 0 2
35261: AND
35262: IFFALSE 35470
// begin for i = 1 to MREG_ToUpLab do
35264: LD_ADDR_VAR 0 2
35268: PUSH
35269: DOUBLE
35270: LD_INT 1
35272: DEC
35273: ST_TO_ADDR
35274: LD_EXP 49
35278: PUSH
35279: FOR_TO
35280: IFFALSE 35466
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35282: LD_EXP 49
35286: PUSH
35287: LD_VAR 0 2
35291: ARRAY
35292: PUSH
35293: LD_INT 1
35295: ARRAY
35296: PUSH
35297: LD_VAR 0 3
35301: EQUAL
35302: IFFALSE 35464
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35304: LD_EXP 49
35308: PUSH
35309: LD_VAR 0 2
35313: ARRAY
35314: PUSH
35315: LD_INT 2
35317: ARRAY
35318: PUSH
35319: LD_EXP 49
35323: PUSH
35324: LD_VAR 0 2
35328: ARRAY
35329: PUSH
35330: LD_INT 3
35332: ARRAY
35333: AND
35334: IFFALSE 35462
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35336: LD_VAR 0 3
35340: PPUSH
35341: LD_EXP 49
35345: PUSH
35346: LD_VAR 0 2
35350: ARRAY
35351: PUSH
35352: LD_INT 2
35354: ARRAY
35355: PPUSH
35356: LD_EXP 49
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 3
35369: ARRAY
35370: PPUSH
35371: CALL 8915 0 3
35375: IFFALSE 35462
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35377: LD_ADDR_EXP 49
35381: PUSH
35382: LD_EXP 49
35386: PPUSH
35387: LD_VAR 0 3
35391: PPUSH
35392: LD_EXP 49
35396: PUSH
35397: LD_VAR 0 2
35401: ARRAY
35402: PUSH
35403: LD_INT 2
35405: ARRAY
35406: PPUSH
35407: LD_EXP 49
35411: PUSH
35412: LD_VAR 0 2
35416: ARRAY
35417: PUSH
35418: LD_INT 3
35420: ARRAY
35421: PPUSH
35422: CALL 42051 0 4
35426: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35427: LD_ADDR_EXP 40
35431: PUSH
35432: LD_EXP 40
35436: PPUSH
35437: LD_VAR 0 3
35441: PPUSH
35442: LD_EXP 40
35446: PUSH
35447: LD_INT 1
35449: ARRAY
35450: PUSH
35451: LD_INT 2
35453: ARRAY
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL 42051 0 4
35461: ST_TO_ADDR
// end ; break ;
35462: GO 35466
// end ;
35464: GO 35279
35466: POP
35467: POP
// end else
35468: GO 36145
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35470: LD_VAR 0 3
35474: PPUSH
35475: LD_EXP 48
35479: PPUSH
35480: CALL 42999 0 2
35484: IFFALSE 35558
// begin for i = 1 to MREG_ToUpdate do
35486: LD_ADDR_VAR 0 2
35490: PUSH
35491: DOUBLE
35492: LD_INT 1
35494: DEC
35495: ST_TO_ADDR
35496: LD_EXP 48
35500: PUSH
35501: FOR_TO
35502: IFFALSE 35554
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35504: LD_EXP 48
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PUSH
35519: LD_VAR 0 3
35523: EQUAL
35524: IFFALSE 35552
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35526: LD_VAR 0 3
35530: PPUSH
35531: LD_EXP 48
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_INT 2
35544: ARRAY
35545: PPUSH
35546: CALL 8751 0 2
// break ;
35550: GO 35554
// end ;
35552: GO 35501
35554: POP
35555: POP
// end else
35556: GO 36145
// if MCF_Get ( side , [ f_constructed ] ) then
35558: LD_VAR 0 3
35562: PPUSH
35563: LD_INT 57
35565: PUSH
35566: EMPTY
35567: LIST
35568: PPUSH
35569: CALL 11651 0 2
35573: IFFALSE 35606
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35575: LD_VAR 0 3
35579: PPUSH
35580: LD_VAR 0 3
35584: PPUSH
35585: LD_INT 57
35587: PUSH
35588: EMPTY
35589: LIST
35590: PPUSH
35591: CALL 11651 0 2
35595: PUSH
35596: LD_INT 1
35598: ARRAY
35599: PPUSH
35600: CALL 10995 0 2
35604: GO 36145
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35606: LD_VAR 0 3
35610: PPUSH
35611: LD_EXP 46
35615: PPUSH
35616: CALL 42999 0 2
35620: PUSH
35621: LD_VAR 0 3
35625: PPUSH
35626: CALL_OW 345
35630: NOT
35631: AND
35632: PUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: CALL 25006 0 1
35642: PUSH
35643: LD_INT 0
35645: EQUAL
35646: AND
35647: IFFALSE 36046
// begin for i = 1 to MREG_ToBuild do
35649: LD_ADDR_VAR 0 2
35653: PUSH
35654: DOUBLE
35655: LD_INT 1
35657: DEC
35658: ST_TO_ADDR
35659: LD_EXP 46
35663: PUSH
35664: FOR_TO
35665: IFFALSE 36042
// if MREG_ToBuild [ i ] [ 1 ] = side then
35667: LD_EXP 46
35671: PUSH
35672: LD_VAR 0 2
35676: ARRAY
35677: PUSH
35678: LD_INT 1
35680: ARRAY
35681: PUSH
35682: LD_VAR 0 3
35686: EQUAL
35687: IFFALSE 36040
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35689: LD_OWVAR 84
35693: PUSH
35694: LD_EXP 46
35698: PUSH
35699: LD_VAR 0 2
35703: ARRAY
35704: PUSH
35705: LD_INT 3
35707: ARRAY
35708: PUSH
35709: LD_INT 1
35711: ARRAY
35712: PPUSH
35713: LD_EXP 46
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: PUSH
35724: LD_INT 3
35726: ARRAY
35727: PUSH
35728: LD_INT 2
35730: ARRAY
35731: PPUSH
35732: CALL_OW 351
35736: AND
35737: IFFALSE 35781
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35739: LD_EXP 46
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_INT 3
35752: ARRAY
35753: PUSH
35754: LD_INT 1
35756: ARRAY
35757: PPUSH
35758: LD_EXP 46
35762: PUSH
35763: LD_VAR 0 2
35767: ARRAY
35768: PUSH
35769: LD_INT 3
35771: ARRAY
35772: PUSH
35773: LD_INT 2
35775: ARRAY
35776: PPUSH
35777: CALL 22799 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35781: LD_EXP 46
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 2
35794: ARRAY
35795: PUSH
35796: LD_INT 0
35798: EQUAL
35799: IFFALSE 35869
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35801: LD_VAR 0 3
35805: PPUSH
35806: LD_EXP 46
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: PUSH
35817: LD_INT 3
35819: ARRAY
35820: PUSH
35821: LD_INT 1
35823: ARRAY
35824: PPUSH
35825: LD_EXP 46
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PUSH
35836: LD_INT 3
35838: ARRAY
35839: PUSH
35840: LD_INT 2
35842: ARRAY
35843: PPUSH
35844: LD_EXP 46
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PUSH
35855: LD_INT 3
35857: ARRAY
35858: PUSH
35859: LD_INT 3
35861: ARRAY
35862: PPUSH
35863: CALL 8587 0 4
35867: GO 36038
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35869: LD_EXP 46
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PUSH
35880: LD_INT 2
35882: ARRAY
35883: PUSH
35884: LD_INT 6
35886: EQUAL
35887: IFFALSE 35957
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35889: LD_VAR 0 3
35893: PPUSH
35894: LD_EXP 46
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PUSH
35905: LD_INT 3
35907: ARRAY
35908: PUSH
35909: LD_INT 1
35911: ARRAY
35912: PPUSH
35913: LD_EXP 46
35917: PUSH
35918: LD_VAR 0 2
35922: ARRAY
35923: PUSH
35924: LD_INT 3
35926: ARRAY
35927: PUSH
35928: LD_INT 2
35930: ARRAY
35931: PPUSH
35932: LD_EXP 46
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 3
35945: ARRAY
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL 8716 0 4
35955: GO 36038
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35957: LD_VAR 0 3
35961: PPUSH
35962: LD_EXP 46
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 2
35975: ARRAY
35976: PPUSH
35977: LD_EXP 46
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: PUSH
35988: LD_INT 3
35990: ARRAY
35991: PUSH
35992: LD_INT 1
35994: ARRAY
35995: PPUSH
35996: LD_EXP 46
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 3
36009: ARRAY
36010: PUSH
36011: LD_INT 2
36013: ARRAY
36014: PPUSH
36015: LD_EXP 46
36019: PUSH
36020: LD_VAR 0 2
36024: ARRAY
36025: PUSH
36026: LD_INT 3
36028: ARRAY
36029: PUSH
36030: LD_INT 3
36032: ARRAY
36033: PPUSH
36034: CALL 10220 0 5
// break ;
36038: GO 36042
// end ;
36040: GO 35664
36042: POP
36043: POP
// end else
36044: GO 36145
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36046: LD_VAR 0 3
36050: PPUSH
36051: LD_EXP 52
36055: PPUSH
36056: CALL 42999 0 2
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL 25006 0 1
36070: PUSH
36071: LD_INT 0
36073: EQUAL
36074: AND
36075: IFFALSE 36145
// begin for i = 1 to MREG_ToDismantle do
36077: LD_ADDR_VAR 0 2
36081: PUSH
36082: DOUBLE
36083: LD_INT 1
36085: DEC
36086: ST_TO_ADDR
36087: LD_EXP 52
36091: PUSH
36092: FOR_TO
36093: IFFALSE 36143
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36095: LD_EXP 52
36099: PUSH
36100: LD_VAR 0 2
36104: ARRAY
36105: PUSH
36106: LD_INT 1
36108: ARRAY
36109: PUSH
36110: LD_VAR 0 3
36114: EQUAL
36115: IFFALSE 36141
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36117: LD_VAR 0 3
36121: PPUSH
36122: LD_EXP 52
36126: PUSH
36127: LD_VAR 0 2
36131: ARRAY
36132: PUSH
36133: LD_INT 2
36135: ARRAY
36136: PPUSH
36137: CALL 10886 0 2
// end ;
36141: GO 36092
36143: POP
36144: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36145: LD_VAR 0 3
36149: PPUSH
36150: LD_INT 30
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PPUSH
36160: CALL 11651 0 2
36164: PUSH
36165: LD_VAR 0 3
36169: PPUSH
36170: CALL 25006 0 1
36174: PUSH
36175: LD_INT 0
36177: EQUAL
36178: AND
36179: IFFALSE 36190
// MCT_CollectCrates ( side ) ;
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 23945 0 1
// end ;
36190: GO 34191
36192: POP
36193: POP
// end ;
36194: LD_VAR 0 1
36198: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36199: LD_INT 0
36201: PPUSH
36202: PPUSH
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
// all := MCF_All ( side , [ ] ) ;
36216: LD_ADDR_VAR 0 17
36220: PUSH
36221: LD_VAR 0 1
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL 11786 0 2
36232: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36233: LD_ADDR_VAR 0 13
36237: PUSH
36238: LD_VAR 0 1
36242: PPUSH
36243: LD_INT 1
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL 11734 0 3
36252: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36253: LD_ADDR_VAR 0 14
36257: PUSH
36258: LD_VAR 0 1
36262: PPUSH
36263: LD_INT 2
36265: PPUSH
36266: EMPTY
36267: PPUSH
36268: CALL 11734 0 3
36272: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36273: LD_ADDR_VAR 0 15
36277: PUSH
36278: LD_VAR 0 1
36282: PPUSH
36283: LD_INT 3
36285: PPUSH
36286: EMPTY
36287: PPUSH
36288: CALL 11734 0 3
36292: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36293: LD_ADDR_VAR 0 16
36297: PUSH
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_INT 4
36305: PPUSH
36306: EMPTY
36307: PPUSH
36308: CALL 11734 0 3
36312: ST_TO_ADDR
// if mech then
36313: LD_VAR 0 15
36317: IFFALSE 36334
// mech := MCF_SortListDesc ( mech ) ;
36319: LD_ADDR_VAR 0 15
36323: PUSH
36324: LD_VAR 0 15
36328: PPUSH
36329: CALL 12900 0 1
36333: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36334: LD_EXP 56
36338: PUSH
36339: LD_VAR 0 1
36343: ARRAY
36344: PUSH
36345: LD_STRING 
36347: EQUAL
36348: NOT
36349: IFFALSE 36405
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36351: LD_EXP 56
36355: PUSH
36356: LD_VAR 0 1
36360: ARRAY
36361: PUSH
36362: LD_INT 1
36364: ARRAY
36365: PPUSH
36366: CALL_OW 257
36370: PUSH
36371: LD_INT 1
36373: EQUAL
36374: IFFALSE 36403
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36376: LD_VAR 0 1
36380: PPUSH
36381: LD_STRING ToArm
36383: PPUSH
36384: LD_EXP 56
36388: PUSH
36389: LD_VAR 0 1
36393: ARRAY
36394: PUSH
36395: LD_INT 1
36397: ARRAY
36398: PPUSH
36399: CALL 14530 0 3
// end else
36403: GO 36431
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36405: LD_ADDR_EXP 56
36409: PUSH
36410: LD_EXP 56
36414: PPUSH
36415: LD_VAR 0 1
36419: PPUSH
36420: LD_INT 1
36422: PPUSH
36423: LD_INT 0
36425: PPUSH
36426: CALL 31130 0 4
36430: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36431: LD_EXP 57
36435: PUSH
36436: LD_VAR 0 1
36440: ARRAY
36441: PUSH
36442: LD_STRING 
36444: EQUAL
36445: NOT
36446: IFFALSE 36502
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36448: LD_EXP 57
36452: PUSH
36453: LD_VAR 0 1
36457: ARRAY
36458: PUSH
36459: LD_INT 1
36461: ARRAY
36462: PPUSH
36463: CALL_OW 257
36467: PUSH
36468: LD_INT 2
36470: EQUAL
36471: IFFALSE 36500
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36473: LD_VAR 0 1
36477: PPUSH
36478: LD_STRING ToDep
36480: PPUSH
36481: LD_EXP 57
36485: PUSH
36486: LD_VAR 0 1
36490: ARRAY
36491: PUSH
36492: LD_INT 1
36494: ARRAY
36495: PPUSH
36496: CALL 14530 0 3
// end else
36500: GO 36528
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36502: LD_ADDR_EXP 57
36506: PUSH
36507: LD_EXP 57
36511: PPUSH
36512: LD_VAR 0 1
36516: PPUSH
36517: LD_INT 1
36519: PPUSH
36520: LD_INT 0
36522: PPUSH
36523: CALL 31130 0 4
36527: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36528: LD_EXP 55
36532: PUSH
36533: LD_VAR 0 1
36537: ARRAY
36538: PUSH
36539: LD_STRING 
36541: EQUAL
36542: NOT
36543: IFFALSE 36599
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36545: LD_EXP 55
36549: PUSH
36550: LD_VAR 0 1
36554: ARRAY
36555: PUSH
36556: LD_INT 1
36558: ARRAY
36559: PPUSH
36560: CALL_OW 257
36564: PUSH
36565: LD_INT 3
36567: EQUAL
36568: IFFALSE 36597
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36570: LD_VAR 0 1
36574: PPUSH
36575: LD_STRING ToFac
36577: PPUSH
36578: LD_EXP 55
36582: PUSH
36583: LD_VAR 0 1
36587: ARRAY
36588: PUSH
36589: LD_INT 1
36591: ARRAY
36592: PPUSH
36593: CALL 14530 0 3
// end else
36597: GO 36625
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36599: LD_ADDR_EXP 55
36603: PUSH
36604: LD_EXP 55
36608: PPUSH
36609: LD_VAR 0 1
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: LD_INT 0
36619: PPUSH
36620: CALL 31130 0 4
36624: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36625: LD_EXP 54
36629: PUSH
36630: LD_VAR 0 1
36634: ARRAY
36635: PUSH
36636: LD_STRING 
36638: EQUAL
36639: NOT
36640: IFFALSE 36696
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36642: LD_EXP 54
36646: PUSH
36647: LD_VAR 0 1
36651: ARRAY
36652: PUSH
36653: LD_INT 1
36655: ARRAY
36656: PPUSH
36657: CALL_OW 257
36661: PUSH
36662: LD_INT 4
36664: EQUAL
36665: IFFALSE 36694
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36667: LD_VAR 0 1
36671: PPUSH
36672: LD_STRING ToLab
36674: PPUSH
36675: LD_EXP 54
36679: PUSH
36680: LD_VAR 0 1
36684: ARRAY
36685: PUSH
36686: LD_INT 1
36688: ARRAY
36689: PPUSH
36690: CALL 14530 0 3
// end else
36694: GO 36722
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36696: LD_ADDR_EXP 54
36700: PUSH
36701: LD_EXP 54
36705: PPUSH
36706: LD_VAR 0 1
36710: PPUSH
36711: LD_INT 1
36713: PPUSH
36714: LD_INT 0
36716: PPUSH
36717: CALL 31130 0 4
36721: ST_TO_ADDR
// if mode = 0 then
36722: LD_VAR 0 2
36726: PUSH
36727: LD_INT 0
36729: EQUAL
36730: IFFALSE 38568
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36732: LD_VAR 0 1
36736: PPUSH
36737: LD_INT 30
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PPUSH
36747: CALL 11651 0 2
36751: PUSH
36752: LD_VAR 0 1
36756: PPUSH
36757: LD_INT 21
36759: PUSH
36760: LD_INT 3
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PPUSH
36767: CALL 11651 0 2
36771: PUSH
36772: LD_INT 1
36774: EQUAL
36775: AND
36776: IFFALSE 36841
// begin if all then
36778: LD_VAR 0 17
36782: IFFALSE 36839
// for i in ( all diff eng ) do
36784: LD_ADDR_VAR 0 4
36788: PUSH
36789: LD_VAR 0 17
36793: PUSH
36794: LD_VAR 0 14
36798: DIFF
36799: PUSH
36800: FOR_IN
36801: IFFALSE 36837
// if GetTag ( i ) = 0 then
36803: LD_VAR 0 4
36807: PPUSH
36808: CALL_OW 110
36812: PUSH
36813: LD_INT 0
36815: EQUAL
36816: IFFALSE 36835
// MCH_ChangeClass ( side , i , 2 ) ;
36818: LD_VAR 0 1
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: LD_INT 2
36830: PPUSH
36831: CALL 16558 0 3
36835: GO 36800
36837: POP
36838: POP
// end else
36839: GO 37160
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36841: LD_VAR 0 13
36845: PUSH
36846: LD_EXP 56
36850: PUSH
36851: LD_VAR 0 1
36855: ARRAY
36856: PLUS
36857: PUSH
36858: LD_INT 22
36860: PUSH
36861: LD_VAR 0 1
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 30
36872: PUSH
36873: LD_INT 32
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PPUSH
36884: CALL_OW 69
36888: LESS
36889: IFFALSE 36914
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36891: LD_VAR 0 1
36895: PPUSH
36896: LD_VAR 0 14
36900: PUSH
36901: LD_INT 1
36903: ARRAY
36904: PPUSH
36905: LD_INT 1
36907: PPUSH
36908: CALL 16558 0 3
// end else
36912: GO 37160
// if sci < 6 and MCF_Lab ( side ) then
36914: LD_VAR 0 16
36918: PUSH
36919: LD_INT 6
36921: LESS
36922: PUSH
36923: LD_VAR 0 1
36927: PPUSH
36928: CALL 11690 0 1
36932: AND
36933: IFFALSE 37038
// begin if MREG_ToBunker [ side ] then
36935: LD_EXP 68
36939: PUSH
36940: LD_VAR 0 1
36944: ARRAY
36945: IFFALSE 36971
// tmp := sol diff MREG_ToBunker [ side ] else
36947: LD_ADDR_VAR 0 12
36951: PUSH
36952: LD_VAR 0 13
36956: PUSH
36957: LD_EXP 68
36961: PUSH
36962: LD_VAR 0 1
36966: ARRAY
36967: DIFF
36968: ST_TO_ADDR
36969: GO 36981
// tmp := sol ;
36971: LD_ADDR_VAR 0 12
36975: PUSH
36976: LD_VAR 0 13
36980: ST_TO_ADDR
// if tmp then
36981: LD_VAR 0 12
36985: IFFALSE 37036
// for i in tmp do
36987: LD_ADDR_VAR 0 4
36991: PUSH
36992: LD_VAR 0 12
36996: PUSH
36997: FOR_IN
36998: IFFALSE 37034
// if GetTag ( i ) = 0 then
37000: LD_VAR 0 4
37004: PPUSH
37005: CALL_OW 110
37009: PUSH
37010: LD_INT 0
37012: EQUAL
37013: IFFALSE 37032
// MCH_ChangeClass ( side , i , 4 ) ;
37015: LD_VAR 0 1
37019: PPUSH
37020: LD_VAR 0 4
37024: PPUSH
37025: LD_INT 4
37027: PPUSH
37028: CALL 16558 0 3
37032: GO 36997
37034: POP
37035: POP
// end else
37036: GO 37160
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37038: LD_VAR 0 1
37042: PPUSH
37043: LD_INT 30
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PPUSH
37053: CALL 11651 0 2
37057: IFFALSE 37160
// begin if MREG_ToBunker [ side ] then
37059: LD_EXP 68
37063: PUSH
37064: LD_VAR 0 1
37068: ARRAY
37069: IFFALSE 37095
// tmp := sol diff MREG_ToBunker [ side ] else
37071: LD_ADDR_VAR 0 12
37075: PUSH
37076: LD_VAR 0 13
37080: PUSH
37081: LD_EXP 68
37085: PUSH
37086: LD_VAR 0 1
37090: ARRAY
37091: DIFF
37092: ST_TO_ADDR
37093: GO 37105
// tmp := sol ;
37095: LD_ADDR_VAR 0 12
37099: PUSH
37100: LD_VAR 0 13
37104: ST_TO_ADDR
// if tmp then
37105: LD_VAR 0 12
37109: IFFALSE 37160
// for i in tmp do
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 12
37120: PUSH
37121: FOR_IN
37122: IFFALSE 37158
// if GetTag ( i ) = 0 then
37124: LD_VAR 0 4
37128: PPUSH
37129: CALL_OW 110
37133: PUSH
37134: LD_INT 0
37136: EQUAL
37137: IFFALSE 37156
// MCH_ChangeClass ( side , i , 2 ) ;
37139: LD_VAR 0 1
37143: PPUSH
37144: LD_VAR 0 4
37148: PPUSH
37149: LD_INT 2
37151: PPUSH
37152: CALL 16558 0 3
37156: GO 37121
37158: POP
37159: POP
// end ; if MCF_Lab ( side ) then
37160: LD_VAR 0 1
37164: PPUSH
37165: CALL 11690 0 1
37169: IFFALSE 37709
// begin if MCL_GetTechList ( side ) then
37171: LD_VAR 0 1
37175: PPUSH
37176: CALL 18034 0 1
37180: IFFALSE 37306
// begin if MREG_ToLab [ side ] then
37182: LD_EXP 54
37186: PUSH
37187: LD_VAR 0 1
37191: ARRAY
37192: IFFALSE 37212
// k := MREG_ToLab [ side ] else
37194: LD_ADDR_VAR 0 8
37198: PUSH
37199: LD_EXP 54
37203: PUSH
37204: LD_VAR 0 1
37208: ARRAY
37209: ST_TO_ADDR
37210: GO 37220
// k := 0 ;
37212: LD_ADDR_VAR 0 8
37216: PUSH
37217: LD_INT 0
37219: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37220: LD_VAR 0 16
37224: PUSH
37225: LD_VAR 0 8
37229: PLUS
37230: PUSH
37231: LD_INT 6
37233: LESSEQUAL
37234: PUSH
37235: LD_VAR 0 17
37239: PUSH
37240: LD_INT 6
37242: GREATER
37243: AND
37244: IFFALSE 37260
// MCH_TrainScientist ( side , 1 ) else
37246: LD_VAR 0 1
37250: PPUSH
37251: LD_INT 1
37253: PPUSH
37254: CALL 16110 0 2
37258: GO 37304
// if all < 6 then
37260: LD_VAR 0 17
37264: PUSH
37265: LD_INT 6
37267: LESS
37268: IFFALSE 37304
// if sci + k < all / 2 then
37270: LD_VAR 0 16
37274: PUSH
37275: LD_VAR 0 8
37279: PLUS
37280: PUSH
37281: LD_VAR 0 17
37285: PUSH
37286: LD_INT 2
37288: DIVREAL
37289: LESS
37290: IFFALSE 37304
// MCH_TrainScientist ( side , 1 ) ;
37292: LD_VAR 0 1
37296: PPUSH
37297: LD_INT 1
37299: PPUSH
37300: CALL 16110 0 2
// end else
37304: GO 37382
// begin if sci > 2 then
37306: LD_VAR 0 16
37310: PUSH
37311: LD_INT 2
37313: GREATER
37314: IFFALSE 37382
// for i = sci downto 2 do
37316: LD_ADDR_VAR 0 4
37320: PUSH
37321: DOUBLE
37322: LD_VAR 0 16
37326: INC
37327: ST_TO_ADDR
37328: LD_INT 2
37330: PUSH
37331: FOR_DOWNTO
37332: IFFALSE 37380
// if GetTag ( sci [ i ] ) = 0 then
37334: LD_VAR 0 16
37338: PUSH
37339: LD_VAR 0 4
37343: ARRAY
37344: PPUSH
37345: CALL_OW 110
37349: PUSH
37350: LD_INT 0
37352: EQUAL
37353: IFFALSE 37378
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37355: LD_VAR 0 1
37359: PPUSH
37360: LD_VAR 0 16
37364: PUSH
37365: LD_VAR 0 4
37369: ARRAY
37370: PPUSH
37371: LD_INT 2
37373: PPUSH
37374: CALL 16558 0 3
37378: GO 37331
37380: POP
37381: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37382: LD_VAR 0 1
37386: PPUSH
37387: CALL 18034 0 1
37391: PUSH
37392: LD_VAR 0 1
37396: PPUSH
37397: CALL 11690 0 1
37401: AND
37402: PUSH
37403: LD_EXP 35
37407: PUSH
37408: LD_VAR 0 1
37412: ARRAY
37413: NOT
37414: AND
37415: IFFALSE 37709
// begin for j = 1 to MCF_Lab ( side ) do
37417: LD_ADDR_VAR 0 5
37421: PUSH
37422: DOUBLE
37423: LD_INT 1
37425: DEC
37426: ST_TO_ADDR
37427: LD_VAR 0 1
37431: PPUSH
37432: CALL 11690 0 1
37436: PUSH
37437: FOR_TO
37438: IFFALSE 37498
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37440: LD_VAR 0 1
37444: PPUSH
37445: CALL 11690 0 1
37449: PUSH
37450: LD_VAR 0 5
37454: ARRAY
37455: PPUSH
37456: CALL_OW 461
37460: PUSH
37461: LD_INT 3
37463: PUSH
37464: LD_INT 6
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: IN
37471: IFFALSE 37496
// begin b := MCF_Lab ( side ) [ j ] ;
37473: LD_ADDR_VAR 0 11
37477: PUSH
37478: LD_VAR 0 1
37482: PPUSH
37483: CALL 11690 0 1
37487: PUSH
37488: LD_VAR 0 5
37492: ARRAY
37493: ST_TO_ADDR
// break ;
37494: GO 37498
// end ;
37496: GO 37437
37498: POP
37499: POP
// if MCF_Class ( side , 4 , [ ] ) then
37500: LD_VAR 0 1
37504: PPUSH
37505: LD_INT 4
37507: PPUSH
37508: EMPTY
37509: PPUSH
37510: CALL 11734 0 3
37514: IFFALSE 37709
// for j in MCF_Class ( side , 4 , [ ] ) do
37516: LD_ADDR_VAR 0 5
37520: PUSH
37521: LD_VAR 0 1
37525: PPUSH
37526: LD_INT 4
37528: PPUSH
37529: EMPTY
37530: PPUSH
37531: CALL 11734 0 3
37535: PUSH
37536: FOR_IN
37537: IFFALSE 37707
// begin if GetTag ( j ) = 0 then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 110
37548: PUSH
37549: LD_INT 0
37551: EQUAL
37552: IFFALSE 37643
// begin if IsInUnit ( j ) and b then
37554: LD_VAR 0 5
37558: PPUSH
37559: CALL_OW 310
37563: PUSH
37564: LD_VAR 0 11
37568: AND
37569: IFFALSE 37617
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37571: LD_VAR 0 5
37575: PPUSH
37576: CALL_OW 310
37580: PPUSH
37581: CALL_OW 461
37585: PUSH
37586: LD_INT 2
37588: EQUAL
37589: PUSH
37590: LD_VAR 0 5
37594: PPUSH
37595: CALL_OW 310
37599: PUSH
37600: LD_VAR 0 11
37604: NONEQUAL
37605: AND
37606: IFFALSE 37617
// ComExitBuilding ( j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 122
// if not IsInUnit ( j ) then
37617: LD_VAR 0 5
37621: PPUSH
37622: CALL_OW 310
37626: NOT
37627: IFFALSE 37643
// ComEnterUnit ( j , b ) ;
37629: LD_VAR 0 5
37633: PPUSH
37634: LD_VAR 0 11
37638: PPUSH
37639: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37643: LD_INT 1
37645: PPUSH
37646: LD_VAR 0 5
37650: PPUSH
37651: CALL_OW 255
37655: PPUSH
37656: CALL_OW 321
37660: PUSH
37661: LD_INT 2
37663: EQUAL
37664: PUSH
37665: LD_VAR 0 5
37669: PPUSH
37670: CALL_OW 255
37674: PPUSH
37675: CALL 25006 0 1
37679: PUSH
37680: LD_INT 0
37682: EQUAL
37683: AND
37684: IFFALSE 37705
// MCN_Tame ( GetSide ( j ) , j ) ;
37686: LD_VAR 0 5
37690: PPUSH
37691: CALL_OW 255
37695: PPUSH
37696: LD_VAR 0 5
37700: PPUSH
37701: CALL 18553 0 2
// end ;
37705: GO 37536
37707: POP
37708: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37709: LD_VAR 0 1
37713: PPUSH
37714: LD_INT 30
37716: PUSH
37717: LD_INT 3
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PPUSH
37724: CALL 11651 0 2
37728: IFFALSE 37987
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37730: LD_ADDR_VAR 0 11
37734: PUSH
37735: LD_VAR 0 1
37739: PPUSH
37740: LD_INT 30
37742: PUSH
37743: LD_INT 3
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PPUSH
37750: CALL 11651 0 2
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37759: LD_ADDR_VAR 0 12
37763: PUSH
37764: LD_VAR 0 1
37768: PPUSH
37769: LD_INT 0
37771: PPUSH
37772: LD_INT 25
37774: PUSH
37775: LD_INT 3
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PPUSH
37782: CALL 12354 0 3
37786: ST_TO_ADDR
// for i = 1 to tmp do
37787: LD_ADDR_VAR 0 4
37791: PUSH
37792: DOUBLE
37793: LD_INT 1
37795: DEC
37796: ST_TO_ADDR
37797: LD_VAR 0 12
37801: PUSH
37802: FOR_TO
37803: IFFALSE 37863
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37805: LD_VAR 0 12
37809: PUSH
37810: LD_VAR 0 4
37814: ARRAY
37815: PPUSH
37816: CALL_OW 310
37820: NOT
37821: PUSH
37822: LD_VAR 0 12
37826: PUSH
37827: LD_VAR 0 4
37831: ARRAY
37832: PPUSH
37833: CALL_OW 314
37837: NOT
37838: AND
37839: IFFALSE 37861
// ComEnterUnit ( tmp [ i ] , b ) ;
37841: LD_VAR 0 12
37845: PUSH
37846: LD_VAR 0 4
37850: ARRAY
37851: PPUSH
37852: LD_VAR 0 11
37856: PPUSH
37857: CALL_OW 120
37861: GO 37802
37863: POP
37864: POP
// if MREG_ToFac [ side ] then
37865: LD_EXP 55
37869: PUSH
37870: LD_VAR 0 1
37874: ARRAY
37875: IFFALSE 37895
// k := MREG_ToFac [ side ] else
37877: LD_ADDR_VAR 0 8
37881: PUSH
37882: LD_EXP 55
37886: PUSH
37887: LD_VAR 0 1
37891: ARRAY
37892: ST_TO_ADDR
37893: GO 37903
// k := 0 ;
37895: LD_ADDR_VAR 0 8
37899: PUSH
37900: LD_INT 0
37902: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37903: LD_VAR 0 15
37907: PUSH
37908: LD_VAR 0 8
37912: PLUS
37913: PUSH
37914: LD_INT 6
37916: LESSEQUAL
37917: PUSH
37918: LD_VAR 0 17
37922: PUSH
37923: LD_INT 6
37925: GREATER
37926: AND
37927: IFFALSE 37943
// MCH_TrainMechanic ( side , 1 ) else
37929: LD_VAR 0 1
37933: PPUSH
37934: LD_INT 1
37936: PPUSH
37937: CALL 15852 0 2
37941: GO 37987
// if all < 6 then
37943: LD_VAR 0 17
37947: PUSH
37948: LD_INT 6
37950: LESS
37951: IFFALSE 37987
// if mech + k < all / 2 then
37953: LD_VAR 0 15
37957: PUSH
37958: LD_VAR 0 8
37962: PLUS
37963: PUSH
37964: LD_VAR 0 17
37968: PUSH
37969: LD_INT 2
37971: DIVREAL
37972: LESS
37973: IFFALSE 37987
// MCH_TrainMechanic ( side , 1 ) ;
37975: LD_VAR 0 1
37979: PPUSH
37980: LD_INT 1
37982: PPUSH
37983: CALL 15852 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37987: LD_ADDR_VAR 0 10
37991: PUSH
37992: LD_VAR 0 1
37996: PPUSH
37997: LD_INT 30
37999: PUSH
38000: LD_INT 36
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PPUSH
38007: CALL 11651 0 2
38011: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38012: LD_VAR 0 10
38016: PUSH
38017: LD_VAR 0 15
38021: AND
38022: PUSH
38023: LD_VAR 0 1
38027: PPUSH
38028: LD_INT 3
38030: PPUSH
38031: EMPTY
38032: PPUSH
38033: CALL 11734 0 3
38037: AND
38038: IFFALSE 38196
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38040: LD_VAR 0 1
38044: PPUSH
38045: LD_INT 9
38047: PPUSH
38048: EMPTY
38049: PPUSH
38050: CALL 12354 0 3
38054: PUSH
38055: LD_INT 3
38057: LESS
38058: IFFALSE 38196
// begin if mech < 3 then
38060: LD_VAR 0 15
38064: PUSH
38065: LD_INT 3
38067: LESS
38068: IFFALSE 38082
// k := mech else
38070: LD_ADDR_VAR 0 8
38074: PUSH
38075: LD_VAR 0 15
38079: ST_TO_ADDR
38080: GO 38090
// k := 3 ;
38082: LD_ADDR_VAR 0 8
38086: PUSH
38087: LD_INT 3
38089: ST_TO_ADDR
// for j = 1 to k do
38090: LD_ADDR_VAR 0 5
38094: PUSH
38095: DOUBLE
38096: LD_INT 1
38098: DEC
38099: ST_TO_ADDR
38100: LD_VAR 0 8
38104: PUSH
38105: FOR_TO
38106: IFFALSE 38164
// if GetClass ( mech [ j ] ) = 3 then
38108: LD_VAR 0 15
38112: PUSH
38113: LD_VAR 0 5
38117: ARRAY
38118: PPUSH
38119: CALL_OW 257
38123: PUSH
38124: LD_INT 3
38126: EQUAL
38127: IFFALSE 38162
// begin SetTag ( mech [ j ] , 9 ) ;
38129: LD_VAR 0 15
38133: PUSH
38134: LD_VAR 0 5
38138: ARRAY
38139: PPUSH
38140: LD_INT 9
38142: PPUSH
38143: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38147: LD_VAR 0 15
38151: PUSH
38152: LD_VAR 0 5
38156: ARRAY
38157: PPUSH
38158: CALL_OW 122
// end ;
38162: GO 38105
38164: POP
38165: POP
// if mech < 6 + k then
38166: LD_VAR 0 15
38170: PUSH
38171: LD_INT 6
38173: PUSH
38174: LD_VAR 0 8
38178: PLUS
38179: LESS
38180: IFFALSE 38196
// MCH_TrainMechanic ( side , k ) ;
38182: LD_VAR 0 1
38186: PPUSH
38187: LD_VAR 0 8
38191: PPUSH
38192: CALL 15852 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38196: LD_VAR 0 1
38200: PPUSH
38201: LD_INT 9
38203: PPUSH
38204: EMPTY
38205: PPUSH
38206: CALL 12354 0 3
38210: IFFALSE 38301
// for j in MCF_Tag ( side , 9 , [ ] ) do
38212: LD_ADDR_VAR 0 5
38216: PUSH
38217: LD_VAR 0 1
38221: PPUSH
38222: LD_INT 9
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL 12354 0 3
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38299
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38235: LD_VAR 0 5
38239: PPUSH
38240: CALL_OW 310
38244: NOT
38245: PUSH
38246: LD_VAR 0 5
38250: PPUSH
38251: CALL 98293 0 1
38255: NOT
38256: AND
38257: IFFALSE 38297
// if ct then
38259: LD_VAR 0 10
38263: IFFALSE 38285
// ComEnterUnit ( j , ct [ 1 ] ) else
38265: LD_VAR 0 5
38269: PPUSH
38270: LD_VAR 0 10
38274: PUSH
38275: LD_INT 1
38277: ARRAY
38278: PPUSH
38279: CALL_OW 120
38283: GO 38297
// SetTag ( j , 0 ) ;
38285: LD_VAR 0 5
38289: PPUSH
38290: LD_INT 0
38292: PPUSH
38293: CALL_OW 109
38297: GO 38232
38299: POP
38300: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38301: LD_INT 1
38303: PPUSH
38304: LD_VAR 0 1
38308: PPUSH
38309: CALL_OW 321
38313: PUSH
38314: LD_INT 2
38316: EQUAL
38317: PUSH
38318: LD_EXP 35
38322: PUSH
38323: LD_VAR 0 1
38327: ARRAY
38328: NOT
38329: AND
38330: PUSH
38331: LD_VAR 0 1
38335: PPUSH
38336: LD_INT 4
38338: PPUSH
38339: EMPTY
38340: PPUSH
38341: CALL 11734 0 3
38345: AND
38346: IFFALSE 38394
// for j in MCF_Class ( side , 4 , [ ] ) do
38348: LD_ADDR_VAR 0 5
38352: PUSH
38353: LD_VAR 0 1
38357: PPUSH
38358: LD_INT 4
38360: PPUSH
38361: EMPTY
38362: PPUSH
38363: CALL 11734 0 3
38367: PUSH
38368: FOR_IN
38369: IFFALSE 38392
// MCN_Tame ( GetSide ( j ) , j ) ;
38371: LD_VAR 0 5
38375: PPUSH
38376: CALL_OW 255
38380: PPUSH
38381: LD_VAR 0 5
38385: PPUSH
38386: CALL 18553 0 2
38390: GO 38368
38392: POP
38393: POP
// if MREG_DefVeh [ side ] then
38394: LD_EXP 67
38398: PUSH
38399: LD_VAR 0 1
38403: ARRAY
38404: IFFALSE 38568
// begin for i in MREG_DefVeh [ side ] do
38406: LD_ADDR_VAR 0 4
38410: PUSH
38411: LD_EXP 67
38415: PUSH
38416: LD_VAR 0 1
38420: ARRAY
38421: PUSH
38422: FOR_IN
38423: IFFALSE 38476
// begin SetTag ( i , 0 ) ;
38425: LD_VAR 0 4
38429: PPUSH
38430: LD_INT 0
38432: PPUSH
38433: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38437: LD_VAR 0 4
38441: PPUSH
38442: LD_EXP 64
38446: PUSH
38447: LD_VAR 0 1
38451: ARRAY
38452: PPUSH
38453: CALL_OW 308
38457: NOT
38458: IFFALSE 38474
// MCV_Parking ( side , i ) ;
38460: LD_VAR 0 1
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: CALL 25741 0 2
// end ;
38474: GO 38422
38476: POP
38477: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38478: LD_VAR 0 1
38482: PPUSH
38483: LD_INT 36
38485: PPUSH
38486: EMPTY
38487: PPUSH
38488: CALL 12354 0 3
38492: IFFALSE 38533
// for i in MCF_Tag ( side , 36 , [ ] ) do
38494: LD_ADDR_VAR 0 4
38498: PUSH
38499: LD_VAR 0 1
38503: PPUSH
38504: LD_INT 36
38506: PPUSH
38507: EMPTY
38508: PPUSH
38509: CALL 12354 0 3
38513: PUSH
38514: FOR_IN
38515: IFFALSE 38531
// SetTag ( i , 0 ) ;
38517: LD_VAR 0 4
38521: PPUSH
38522: LD_INT 0
38524: PPUSH
38525: CALL_OW 109
38529: GO 38514
38531: POP
38532: POP
// if MREG_DefMobActive [ side ] then
38533: LD_EXP 70
38537: PUSH
38538: LD_VAR 0 1
38542: ARRAY
38543: IFFALSE 38568
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38545: LD_ADDR_EXP 70
38549: PUSH
38550: LD_EXP 70
38554: PPUSH
38555: LD_VAR 0 1
38559: PPUSH
38560: LD_INT 0
38562: PPUSH
38563: CALL_OW 1
38567: ST_TO_ADDR
// end ; end ; if mode > 0 then
38568: LD_VAR 0 2
38572: PUSH
38573: LD_INT 0
38575: GREATER
38576: IFFALSE 40471
// begin if tick <= 15 15$00 then
38578: LD_OWVAR 1
38582: PUSH
38583: LD_INT 31500
38585: LESSEQUAL
38586: IFFALSE 38890
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38588: LD_VAR 0 13
38592: PUSH
38593: LD_VAR 0 1
38597: PPUSH
38598: CALL 25006 0 1
38602: PUSH
38603: LD_INT 4
38605: LESS
38606: AND
38607: IFFALSE 38718
// begin for i in sol do
38609: LD_ADDR_VAR 0 4
38613: PUSH
38614: LD_VAR 0 13
38618: PUSH
38619: FOR_IN
38620: IFFALSE 38716
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38622: LD_ADDR_VAR 0 8
38626: PUSH
38627: LD_VAR 0 1
38631: PPUSH
38632: CALL 25006 0 1
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: CALL_OW 74
38646: ST_TO_ADDR
// if IsInUnit ( i ) then
38647: LD_VAR 0 4
38651: PPUSH
38652: CALL_OW 310
38656: IFFALSE 38667
// ComExitBuilding ( i ) ;
38658: LD_VAR 0 4
38662: PPUSH
38663: CALL_OW 122
// if not HasTask ( i ) and k then
38667: LD_VAR 0 4
38671: PPUSH
38672: CALL_OW 314
38676: NOT
38677: PUSH
38678: LD_VAR 0 8
38682: AND
38683: IFFALSE 38714
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38685: LD_VAR 0 4
38689: PPUSH
38690: LD_VAR 0 8
38694: PPUSH
38695: CALL_OW 250
38699: PPUSH
38700: LD_VAR 0 8
38704: PPUSH
38705: CALL_OW 251
38709: PPUSH
38710: CALL_OW 174
// end ;
38714: GO 38619
38716: POP
38717: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38718: LD_VAR 0 1
38722: PPUSH
38723: LD_INT 30
38725: PUSH
38726: LD_INT 5
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PPUSH
38733: CALL 11651 0 2
38737: IFFALSE 38888
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38739: LD_ADDR_VAR 0 11
38743: PUSH
38744: LD_VAR 0 1
38748: PPUSH
38749: LD_INT 30
38751: PUSH
38752: LD_INT 5
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL 11651 0 2
38763: PUSH
38764: LD_INT 1
38766: ARRAY
38767: ST_TO_ADDR
// if mech then
38768: LD_VAR 0 15
38772: IFFALSE 38808
// for i in mech do
38774: LD_ADDR_VAR 0 4
38778: PUSH
38779: LD_VAR 0 15
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38806
// MCH_ChangeClass ( side , i , 1 ) ;
38787: LD_VAR 0 1
38791: PPUSH
38792: LD_VAR 0 4
38796: PPUSH
38797: LD_INT 1
38799: PPUSH
38800: CALL 16558 0 3
38804: GO 38784
38806: POP
38807: POP
// if eng > 1 then
38808: LD_VAR 0 14
38812: PUSH
38813: LD_INT 1
38815: GREATER
38816: IFFALSE 38863
// for i = eng downto 2 do
38818: LD_ADDR_VAR 0 4
38822: PUSH
38823: DOUBLE
38824: LD_VAR 0 14
38828: INC
38829: ST_TO_ADDR
38830: LD_INT 2
38832: PUSH
38833: FOR_DOWNTO
38834: IFFALSE 38861
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38836: LD_VAR 0 1
38840: PPUSH
38841: LD_VAR 0 14
38845: PUSH
38846: LD_VAR 0 4
38850: ARRAY
38851: PPUSH
38852: LD_INT 1
38854: PPUSH
38855: CALL 16558 0 3
38859: GO 38833
38861: POP
38862: POP
// if UnitsInside ( b ) then
38863: LD_VAR 0 11
38867: PPUSH
38868: CALL_OW 313
38872: IFFALSE 38888
// ComExitBuilding ( UnitsInside ( b ) ) ;
38874: LD_VAR 0 11
38878: PPUSH
38879: CALL_OW 313
38883: PPUSH
38884: CALL_OW 122
// end ; end else
38888: GO 40471
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38890: LD_VAR 0 1
38894: PPUSH
38895: LD_INT 1
38897: PPUSH
38898: LD_EXP 65
38902: PUSH
38903: LD_VAR 0 1
38907: ARRAY
38908: PUSH
38909: LD_INT 1
38911: ARRAY
38912: PPUSH
38913: CALL 33743 0 3
38917: IFFALSE 39056
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38919: LD_ADDR_VAR 0 12
38923: PUSH
38924: LD_VAR 0 1
38928: PPUSH
38929: LD_INT 21
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PPUSH
38939: CALL 11651 0 2
38943: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38944: LD_ADDR_VAR 0 11
38948: PUSH
38949: LD_VAR 0 1
38953: PPUSH
38954: LD_INT 30
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PPUSH
38964: CALL 11651 0 2
38968: ST_TO_ADDR
// if b then
38969: LD_VAR 0 11
38973: IFFALSE 39056
// for i in tmp do
38975: LD_ADDR_VAR 0 4
38979: PUSH
38980: LD_VAR 0 12
38984: PUSH
38985: FOR_IN
38986: IFFALSE 39054
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38988: LD_VAR 0 4
38992: PPUSH
38993: LD_EXP 65
38997: PUSH
38998: LD_VAR 0 1
39002: ARRAY
39003: PUSH
39004: LD_INT 1
39006: ARRAY
39007: PPUSH
39008: CALL_OW 308
39012: NOT
39013: IFFALSE 39052
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39015: LD_VAR 0 4
39019: PPUSH
39020: LD_VAR 0 11
39024: PUSH
39025: LD_INT 1
39027: ARRAY
39028: PPUSH
39029: CALL_OW 250
39033: PPUSH
39034: LD_VAR 0 11
39038: PUSH
39039: LD_INT 1
39041: ARRAY
39042: PPUSH
39043: CALL_OW 251
39047: PPUSH
39048: CALL_OW 111
39052: GO 38985
39054: POP
39055: POP
// end ; if MREG_DefVeh [ side ] then
39056: LD_EXP 67
39060: PUSH
39061: LD_VAR 0 1
39065: ARRAY
39066: IFFALSE 39634
// begin tmp := [ ] ;
39068: LD_ADDR_VAR 0 12
39072: PUSH
39073: EMPTY
39074: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39075: LD_EXP 70
39079: PUSH
39080: LD_VAR 0 1
39084: ARRAY
39085: PUSH
39086: LD_INT 0
39088: EQUAL
39089: IFFALSE 39229
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39091: LD_ADDR_VAR 0 8
39095: PUSH
39096: LD_VAR 0 1
39100: PPUSH
39101: LD_INT 0
39103: PPUSH
39104: LD_INT 25
39106: PUSH
39107: LD_INT 3
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PPUSH
39114: CALL 12354 0 3
39118: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39119: LD_VAR 0 8
39123: PUSH
39124: LD_EXP 67
39128: PUSH
39129: LD_VAR 0 1
39133: ARRAY
39134: GREATER
39135: IFFALSE 39196
// begin for i = 1 to MREG_DefVeh [ side ] do
39137: LD_ADDR_VAR 0 4
39141: PUSH
39142: DOUBLE
39143: LD_INT 1
39145: DEC
39146: ST_TO_ADDR
39147: LD_EXP 67
39151: PUSH
39152: LD_VAR 0 1
39156: ARRAY
39157: PUSH
39158: FOR_TO
39159: IFFALSE 39192
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39161: LD_ADDR_VAR 0 12
39165: PUSH
39166: LD_VAR 0 12
39170: PPUSH
39171: LD_INT 1
39173: PPUSH
39174: LD_VAR 0 8
39178: PUSH
39179: LD_VAR 0 4
39183: ARRAY
39184: PPUSH
39185: CALL_OW 2
39189: ST_TO_ADDR
39190: GO 39158
39192: POP
39193: POP
// end else
39194: GO 39206
// tmp := k ;
39196: LD_ADDR_VAR 0 12
39200: PUSH
39201: LD_VAR 0 8
39205: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39206: LD_ADDR_EXP 70
39210: PUSH
39211: LD_EXP 70
39215: PPUSH
39216: LD_VAR 0 1
39220: PPUSH
39221: LD_INT 1
39223: PPUSH
39224: CALL_OW 1
39228: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39229: LD_ADDR_VAR 0 4
39233: PUSH
39234: LD_EXP 67
39238: PUSH
39239: LD_VAR 0 1
39243: ARRAY
39244: PUSH
39245: FOR_IN
39246: IFFALSE 39632
// begin if not GetDriver ( i ) then
39248: LD_VAR 0 4
39252: PPUSH
39253: CALL 31773 0 1
39257: NOT
39258: IFFALSE 39333
// begin if tmp then
39260: LD_VAR 0 12
39264: IFFALSE 39331
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39266: LD_VAR 0 12
39270: PUSH
39271: LD_INT 1
39273: ARRAY
39274: PPUSH
39275: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39279: LD_VAR 0 12
39283: PUSH
39284: LD_INT 1
39286: ARRAY
39287: PPUSH
39288: LD_VAR 0 4
39292: PPUSH
39293: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39297: LD_VAR 0 12
39301: PUSH
39302: LD_INT 1
39304: ARRAY
39305: PPUSH
39306: LD_INT 36
39308: PPUSH
39309: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39313: LD_ADDR_VAR 0 12
39317: PUSH
39318: LD_VAR 0 12
39322: PPUSH
39323: LD_INT 1
39325: PPUSH
39326: CALL_OW 3
39330: ST_TO_ADDR
// end ; end else
39331: GO 39630
// begin if GetTag ( i ) = 0 then
39333: LD_VAR 0 4
39337: PPUSH
39338: CALL_OW 110
39342: PUSH
39343: LD_INT 0
39345: EQUAL
39346: IFFALSE 39362
// SetTag ( i , 31 ) else
39348: LD_VAR 0 4
39352: PPUSH
39353: LD_INT 31
39355: PPUSH
39356: CALL_OW 109
39360: GO 39630
// if GetTag ( i ) = 31 then
39362: LD_VAR 0 4
39366: PPUSH
39367: CALL_OW 110
39371: PUSH
39372: LD_INT 31
39374: EQUAL
39375: IFFALSE 39630
// begin if GetFuel ( i ) < 20 then
39377: LD_VAR 0 4
39381: PPUSH
39382: CALL_OW 261
39386: PUSH
39387: LD_INT 20
39389: LESS
39390: IFFALSE 39415
// begin SetTag ( i , 21 ) ;
39392: LD_VAR 0 4
39396: PPUSH
39397: LD_INT 21
39399: PPUSH
39400: CALL_OW 109
// MCV_Refuel ( i ) ;
39404: LD_VAR 0 4
39408: PPUSH
39409: CALL 26278 0 1
// continue ;
39413: GO 39245
// end ; if GetLives ( i ) < 700 then
39415: LD_VAR 0 4
39419: PPUSH
39420: CALL_OW 256
39424: PUSH
39425: LD_INT 700
39427: LESS
39428: IFFALSE 39540
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39430: LD_VAR 0 4
39434: PPUSH
39435: LD_EXP 58
39439: PUSH
39440: LD_VAR 0 1
39444: ARRAY
39445: PPUSH
39446: CALL_OW 308
39450: NOT
39451: IFFALSE 39475
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39453: LD_VAR 0 4
39457: PPUSH
39458: LD_EXP 58
39462: PUSH
39463: LD_VAR 0 1
39467: ARRAY
39468: PPUSH
39469: CALL_OW 113
39473: GO 39538
// if GetDriver ( i ) then
39475: LD_VAR 0 4
39479: PPUSH
39480: CALL 31773 0 1
39484: IFFALSE 39538
// begin k := GetDriver ( i ) ;
39486: LD_ADDR_VAR 0 8
39490: PUSH
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31773 0 1
39500: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39501: LD_VAR 0 8
39505: PPUSH
39506: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39510: LD_VAR 0 8
39514: PPUSH
39515: LD_VAR 0 4
39519: PPUSH
39520: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39524: LD_VAR 0 8
39528: PPUSH
39529: LD_VAR 0 4
39533: PPUSH
39534: CALL_OW 180
// end ; end else
39538: GO 39630
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39540: LD_ADDR_VAR 0 8
39544: PUSH
39545: LD_VAR 0 1
39549: PPUSH
39550: CALL 25006 0 1
39554: PPUSH
39555: LD_VAR 0 4
39559: PPUSH
39560: CALL_OW 74
39564: ST_TO_ADDR
// if k then
39565: LD_VAR 0 8
39569: IFFALSE 39587
// ComAttackUnit ( i , k ) else
39571: LD_VAR 0 4
39575: PPUSH
39576: LD_VAR 0 8
39580: PPUSH
39581: CALL_OW 115
39585: GO 39630
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_EXP 58
39596: PUSH
39597: LD_VAR 0 1
39601: ARRAY
39602: PPUSH
39603: CALL_OW 308
39607: NOT
39608: IFFALSE 39630
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39610: LD_VAR 0 4
39614: PPUSH
39615: LD_EXP 58
39619: PUSH
39620: LD_VAR 0 1
39624: ARRAY
39625: PPUSH
39626: CALL_OW 113
// end ; end ; end ; end ;
39630: GO 39245
39632: POP
39633: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_INT 30
39641: PUSH
39642: LD_INT 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PPUSH
39649: CALL 11651 0 2
39653: IFFALSE 40471
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39655: LD_ADDR_VAR 0 11
39659: PUSH
39660: LD_VAR 0 1
39664: PPUSH
39665: LD_INT 30
39667: PUSH
39668: LD_INT 5
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PPUSH
39675: CALL 11651 0 2
39679: PUSH
39680: LD_INT 1
39682: ARRAY
39683: ST_TO_ADDR
// if eng > 1 then
39684: LD_VAR 0 14
39688: PUSH
39689: LD_INT 1
39691: GREATER
39692: IFFALSE 39739
// for i = eng downto 2 do
39694: LD_ADDR_VAR 0 4
39698: PUSH
39699: DOUBLE
39700: LD_VAR 0 14
39704: INC
39705: ST_TO_ADDR
39706: LD_INT 2
39708: PUSH
39709: FOR_DOWNTO
39710: IFFALSE 39737
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39712: LD_VAR 0 1
39716: PPUSH
39717: LD_VAR 0 14
39721: PUSH
39722: LD_VAR 0 4
39726: ARRAY
39727: PPUSH
39728: LD_INT 1
39730: PPUSH
39731: CALL 16558 0 3
39735: GO 39709
39737: POP
39738: POP
// if sci > 1 then
39739: LD_VAR 0 16
39743: PUSH
39744: LD_INT 1
39746: GREATER
39747: IFFALSE 39794
// for i = sci downto 2 do
39749: LD_ADDR_VAR 0 4
39753: PUSH
39754: DOUBLE
39755: LD_VAR 0 16
39759: INC
39760: ST_TO_ADDR
39761: LD_INT 2
39763: PUSH
39764: FOR_DOWNTO
39765: IFFALSE 39792
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39767: LD_VAR 0 1
39771: PPUSH
39772: LD_VAR 0 16
39776: PUSH
39777: LD_VAR 0 4
39781: ARRAY
39782: PPUSH
39783: LD_INT 1
39785: PPUSH
39786: CALL 16558 0 3
39790: GO 39764
39792: POP
39793: POP
// if sol then
39794: LD_VAR 0 13
39798: IFFALSE 40471
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39800: LD_VAR 0 13
39804: PUSH
39805: LD_EXP 68
39809: PUSH
39810: LD_VAR 0 1
39814: ARRAY
39815: DIFF
39816: PUSH
39817: LD_INT 22
39819: PUSH
39820: LD_VAR 0 1
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 58
39831: PUSH
39832: EMPTY
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: LD_INT 30
39840: PUSH
39841: LD_INT 32
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 31
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL_OW 69
39872: PUSH
39873: LD_INT 0
39875: EQUAL
39876: AND
39877: IFFALSE 40471
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39879: LD_ADDR_VAR 0 12
39883: PUSH
39884: LD_VAR 0 13
39888: PUSH
39889: LD_EXP 68
39893: PUSH
39894: LD_VAR 0 1
39898: ARRAY
39899: DIFF
39900: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39901: LD_VAR 0 1
39905: PPUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 5
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PPUSH
39916: CALL 11651 0 2
39920: PUSH
39921: LD_INT 1
39923: GREATER
39924: IFFALSE 39955
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39926: LD_ADDR_VAR 0 8
39930: PUSH
39931: LD_VAR 0 1
39935: PPUSH
39936: LD_INT 30
39938: PUSH
39939: LD_INT 5
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PPUSH
39946: CALL 11651 0 2
39950: PUSH
39951: LD_INT 2
39953: ARRAY
39954: ST_TO_ADDR
// for j in tmp do
39955: LD_ADDR_VAR 0 5
39959: PUSH
39960: LD_VAR 0 12
39964: PUSH
39965: FOR_IN
39966: IFFALSE 40469
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39968: LD_VAR 0 5
39972: PUSH
39973: LD_VAR 0 11
39977: PPUSH
39978: CALL_OW 313
39982: IN
39983: PUSH
39984: LD_VAR 0 11
39988: PPUSH
39989: CALL_OW 313
39993: PUSH
39994: LD_INT 6
39996: EQUAL
39997: AND
39998: PUSH
39999: LD_VAR 0 8
40003: AND
40004: PUSH
40005: LD_VAR 0 8
40009: PPUSH
40010: CALL_OW 313
40014: PUSH
40015: LD_INT 6
40017: LESS
40018: AND
40019: IFFALSE 40046
// begin ComExitBuilding ( j ) ;
40021: LD_VAR 0 5
40025: PPUSH
40026: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40030: LD_VAR 0 5
40034: PPUSH
40035: LD_VAR 0 8
40039: PPUSH
40040: CALL_OW 180
// continue ;
40044: GO 39965
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40046: LD_VAR 0 5
40050: PPUSH
40051: CALL_OW 314
40055: NOT
40056: PUSH
40057: LD_VAR 0 5
40061: PPUSH
40062: CALL_OW 110
40066: PUSH
40067: LD_INT 0
40069: EQUAL
40070: AND
40071: PUSH
40072: LD_VAR 0 5
40076: PPUSH
40077: CALL_OW 310
40081: NOT
40082: AND
40083: IFFALSE 40189
// begin if k then
40085: LD_VAR 0 8
40089: IFFALSE 40160
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40091: LD_VAR 0 8
40095: PPUSH
40096: CALL_OW 313
40100: PUSH
40101: LD_VAR 0 11
40105: PPUSH
40106: CALL_OW 313
40110: LESS
40111: IFFALSE 40129
// ComEnterUnit ( j , k ) else
40113: LD_VAR 0 5
40117: PPUSH
40118: LD_VAR 0 8
40122: PPUSH
40123: CALL_OW 120
40127: GO 40158
// if UnitsInside ( b ) < 6 then
40129: LD_VAR 0 11
40133: PPUSH
40134: CALL_OW 313
40138: PUSH
40139: LD_INT 6
40141: LESS
40142: IFFALSE 40158
// ComEnterUnit ( j , b ) ;
40144: LD_VAR 0 5
40148: PPUSH
40149: LD_VAR 0 11
40153: PPUSH
40154: CALL_OW 120
// end else
40158: GO 40189
// if UnitsInside ( b ) < 6 then
40160: LD_VAR 0 11
40164: PPUSH
40165: CALL_OW 313
40169: PUSH
40170: LD_INT 6
40172: LESS
40173: IFFALSE 40189
// ComEnterUnit ( j , b ) ;
40175: LD_VAR 0 5
40179: PPUSH
40180: LD_VAR 0 11
40184: PPUSH
40185: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40189: LD_VAR 0 5
40193: PUSH
40194: LD_VAR 0 1
40198: PPUSH
40199: LD_INT 54
40201: PUSH
40202: EMPTY
40203: LIST
40204: PPUSH
40205: CALL 11651 0 2
40209: IN
40210: PUSH
40211: LD_VAR 0 5
40215: PPUSH
40216: CALL_OW 257
40220: PUSH
40221: LD_INT 1
40223: EQUAL
40224: AND
40225: IFFALSE 40467
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40227: LD_EXP 62
40231: PUSH
40232: LD_VAR 0 1
40236: ARRAY
40237: PUSH
40238: LD_INT 1
40240: ARRAY
40241: PUSH
40242: LD_INT 12
40244: PPUSH
40245: LD_VAR 0 1
40249: PPUSH
40250: CALL_OW 321
40254: PUSH
40255: LD_INT 2
40257: EQUAL
40258: AND
40259: IFFALSE 40307
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40261: LD_VAR 0 1
40265: PPUSH
40266: LD_INT 5
40268: PPUSH
40269: EMPTY
40270: PPUSH
40271: CALL 11734 0 3
40275: PUSH
40276: LD_EXP 62
40280: PUSH
40281: LD_VAR 0 1
40285: ARRAY
40286: PUSH
40287: LD_INT 1
40289: ARRAY
40290: LESS
40291: IFFALSE 40307
// begin SetClass ( j , class_sniper ) ;
40293: LD_VAR 0 5
40297: PPUSH
40298: LD_INT 5
40300: PPUSH
40301: CALL_OW 336
// continue ;
40305: GO 39965
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40307: LD_EXP 62
40311: PUSH
40312: LD_VAR 0 1
40316: ARRAY
40317: PUSH
40318: LD_INT 2
40320: ARRAY
40321: PUSH
40322: LD_INT 41
40324: PPUSH
40325: LD_VAR 0 1
40329: PPUSH
40330: CALL_OW 321
40334: PUSH
40335: LD_INT 2
40337: EQUAL
40338: AND
40339: IFFALSE 40387
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40341: LD_VAR 0 1
40345: PPUSH
40346: LD_INT 8
40348: PPUSH
40349: EMPTY
40350: PPUSH
40351: CALL 11734 0 3
40355: PUSH
40356: LD_EXP 62
40360: PUSH
40361: LD_VAR 0 1
40365: ARRAY
40366: PUSH
40367: LD_INT 2
40369: ARRAY
40370: LESS
40371: IFFALSE 40387
// begin SetClass ( j , class_mortar ) ;
40373: LD_VAR 0 5
40377: PPUSH
40378: LD_INT 8
40380: PPUSH
40381: CALL_OW 336
// continue ;
40385: GO 39965
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40387: LD_EXP 62
40391: PUSH
40392: LD_VAR 0 1
40396: ARRAY
40397: PUSH
40398: LD_INT 3
40400: ARRAY
40401: PUSH
40402: LD_INT 44
40404: PPUSH
40405: LD_VAR 0 1
40409: PPUSH
40410: CALL_OW 321
40414: PUSH
40415: LD_INT 2
40417: EQUAL
40418: AND
40419: IFFALSE 40467
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40421: LD_VAR 0 1
40425: PPUSH
40426: LD_INT 9
40428: PPUSH
40429: EMPTY
40430: PPUSH
40431: CALL 11734 0 3
40435: PUSH
40436: LD_EXP 62
40440: PUSH
40441: LD_VAR 0 1
40445: ARRAY
40446: PUSH
40447: LD_INT 3
40449: ARRAY
40450: LESS
40451: IFFALSE 40467
// begin SetClass ( j , class_bazooker ) ;
40453: LD_VAR 0 5
40457: PPUSH
40458: LD_INT 9
40460: PPUSH
40461: CALL_OW 336
// continue ;
40465: GO 39965
// end ; end ; end ;
40467: GO 39965
40469: POP
40470: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40471: LD_INT 22
40473: PUSH
40474: LD_VAR 0 1
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 58
40485: PUSH
40486: EMPTY
40487: LIST
40488: PUSH
40489: LD_INT 30
40491: PUSH
40492: LD_INT 32
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: LIST
40503: PPUSH
40504: CALL_OW 69
40508: IFFALSE 40658
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40510: LD_ADDR_VAR 0 12
40514: PUSH
40515: LD_INT 22
40517: PUSH
40518: LD_VAR 0 1
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 58
40529: PUSH
40530: EMPTY
40531: LIST
40532: PUSH
40533: LD_INT 30
40535: PUSH
40536: LD_INT 32
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: LIST
40547: PPUSH
40548: CALL_OW 69
40552: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40553: LD_ADDR_VAR 0 8
40557: PUSH
40558: LD_VAR 0 13
40562: PUSH
40563: LD_EXP 68
40567: PUSH
40568: LD_VAR 0 1
40572: ARRAY
40573: DIFF
40574: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40575: LD_VAR 0 12
40579: PUSH
40580: LD_INT 1
40582: ARRAY
40583: PPUSH
40584: CALL_OW 461
40588: PUSH
40589: LD_INT 2
40591: EQUAL
40592: PUSH
40593: LD_VAR 0 12
40597: PUSH
40598: LD_INT 1
40600: ARRAY
40601: PUSH
40602: LD_EXP 68
40606: PUSH
40607: LD_VAR 0 1
40611: ARRAY
40612: IN
40613: NOT
40614: AND
40615: PUSH
40616: LD_VAR 0 8
40620: AND
40621: IFFALSE 40658
// begin ComExitBuilding ( k [ 1 ] ) ;
40623: LD_VAR 0 8
40627: PUSH
40628: LD_INT 1
40630: ARRAY
40631: PPUSH
40632: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40636: LD_VAR 0 8
40640: PUSH
40641: LD_INT 1
40643: ARRAY
40644: PPUSH
40645: LD_VAR 0 12
40649: PUSH
40650: LD_INT 1
40652: ARRAY
40653: PPUSH
40654: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40658: LD_EXP 35
40662: PUSH
40663: LD_VAR 0 1
40667: ARRAY
40668: IFFALSE 40816
// begin if MCF_Class ( side , 4 , [ ] ) then
40670: LD_VAR 0 1
40674: PPUSH
40675: LD_INT 4
40677: PPUSH
40678: EMPTY
40679: PPUSH
40680: CALL 11734 0 3
40684: IFFALSE 40814
// for j in MCF_Class ( side , 4 , [ ] ) do
40686: LD_ADDR_VAR 0 5
40690: PUSH
40691: LD_VAR 0 1
40695: PPUSH
40696: LD_INT 4
40698: PPUSH
40699: EMPTY
40700: PPUSH
40701: CALL 11734 0 3
40705: PUSH
40706: FOR_IN
40707: IFFALSE 40812
// begin if not GetTag ( j ) = 4 then
40709: LD_VAR 0 5
40713: PPUSH
40714: CALL_OW 110
40718: PUSH
40719: LD_INT 4
40721: EQUAL
40722: NOT
40723: IFFALSE 40759
// begin SetTag ( j , 4 ) ;
40725: LD_VAR 0 5
40729: PPUSH
40730: LD_INT 4
40732: PPUSH
40733: CALL_OW 109
// if IsInUnit ( j ) then
40737: LD_VAR 0 5
40741: PPUSH
40742: CALL_OW 310
40746: IFFALSE 40757
// ComExitBuilding ( j ) ;
40748: LD_VAR 0 5
40752: PPUSH
40753: CALL_OW 122
// end else
40757: GO 40810
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40759: LD_VAR 0 5
40763: PPUSH
40764: LD_EXP 35
40768: PUSH
40769: LD_VAR 0 1
40773: ARRAY
40774: PUSH
40775: LD_INT 1
40777: ARRAY
40778: PPUSH
40779: CALL 97970 0 2
40783: NOT
40784: IFFALSE 40810
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40786: LD_VAR 0 5
40790: PPUSH
40791: LD_EXP 35
40795: PUSH
40796: LD_VAR 0 1
40800: ARRAY
40801: PUSH
40802: LD_INT 1
40804: ARRAY
40805: PPUSH
40806: CALL 19221 0 2
// end ;
40810: GO 40706
40812: POP
40813: POP
// end else
40814: GO 41048
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40816: LD_VAR 0 1
40820: PPUSH
40821: LD_INT 4
40823: PPUSH
40824: EMPTY
40825: PPUSH
40826: CALL 11734 0 3
40830: PUSH
40831: LD_VAR 0 1
40835: PPUSH
40836: LD_INT 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL 12354 0 3
40845: AND
40846: IFFALSE 41048
// for j in MCF_Class ( side , 4 , [ ] ) do
40848: LD_ADDR_VAR 0 5
40852: PUSH
40853: LD_VAR 0 1
40857: PPUSH
40858: LD_INT 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL 11734 0 3
40867: PUSH
40868: FOR_IN
40869: IFFALSE 41046
// begin if GetTag ( j ) = 4 then
40871: LD_VAR 0 5
40875: PPUSH
40876: CALL_OW 110
40880: PUSH
40881: LD_INT 4
40883: EQUAL
40884: IFFALSE 41044
// begin SetTag ( j , 0 ) ;
40886: LD_VAR 0 5
40890: PPUSH
40891: LD_INT 0
40893: PPUSH
40894: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40898: LD_VAR 0 1
40902: PPUSH
40903: CALL 11690 0 1
40907: PUSH
40908: LD_VAR 0 1
40912: PPUSH
40913: CALL 18034 0 1
40917: NOT
40918: AND
40919: IFFALSE 40944
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40921: LD_VAR 0 5
40925: PPUSH
40926: LD_VAR 0 1
40930: PPUSH
40931: CALL 11690 0 1
40935: PUSH
40936: LD_INT 1
40938: ARRAY
40939: PPUSH
40940: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40944: LD_VAR 0 1
40948: PPUSH
40949: CALL 11690 0 1
40953: NOT
40954: PUSH
40955: LD_VAR 0 1
40959: PPUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL 11651 0 2
40974: AND
40975: IFFALSE 41044
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40977: LD_VAR 0 5
40981: PPUSH
40982: LD_VAR 0 1
40986: PPUSH
40987: LD_INT 30
40989: PUSH
40990: LD_INT 1
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PPUSH
40997: CALL 11651 0 2
41001: PUSH
41002: LD_INT 1
41004: ARRAY
41005: PPUSH
41006: CALL_OW 250
41010: PPUSH
41011: LD_VAR 0 1
41015: PPUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PPUSH
41026: CALL 11651 0 2
41030: PUSH
41031: LD_INT 1
41033: ARRAY
41034: PPUSH
41035: CALL_OW 251
41039: PPUSH
41040: CALL_OW 111
// end ; end ;
41044: GO 40868
41046: POP
41047: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41048: LD_VAR 0 1
41052: PPUSH
41053: LD_INT 3
41055: PPUSH
41056: EMPTY
41057: PPUSH
41058: CALL 11734 0 3
41062: PUSH
41063: LD_EXP 58
41067: PUSH
41068: LD_VAR 0 1
41072: ARRAY
41073: AND
41074: PUSH
41075: LD_VAR 0 1
41079: PPUSH
41080: LD_INT 6
41082: PPUSH
41083: EMPTY
41084: PPUSH
41085: CALL 12354 0 3
41089: AND
41090: IFFALSE 41621
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41092: LD_ADDR_VAR 0 6
41096: PUSH
41097: LD_EXP 58
41101: PUSH
41102: LD_VAR 0 1
41106: ARRAY
41107: PPUSH
41108: LD_INT 0
41110: PPUSH
41111: CALL_OW 517
41115: PUSH
41116: LD_INT 1
41118: ARRAY
41119: PUSH
41120: LD_INT 1
41122: ARRAY
41123: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41124: LD_ADDR_VAR 0 7
41128: PUSH
41129: LD_EXP 58
41133: PUSH
41134: LD_VAR 0 1
41138: ARRAY
41139: PPUSH
41140: LD_INT 0
41142: PPUSH
41143: CALL_OW 517
41147: PUSH
41148: LD_INT 2
41150: ARRAY
41151: PUSH
41152: LD_INT 1
41154: ARRAY
41155: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41156: LD_VAR 0 1
41160: PPUSH
41161: LD_INT 6
41163: PPUSH
41164: EMPTY
41165: PPUSH
41166: CALL 12354 0 3
41170: IFFALSE 41619
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 1
41181: PPUSH
41182: LD_INT 6
41184: PPUSH
41185: EMPTY
41186: PPUSH
41187: CALL 12354 0 3
41191: PUSH
41192: FOR_IN
41193: IFFALSE 41224
// if GetLives ( k ) = 1000 then
41195: LD_VAR 0 8
41199: PPUSH
41200: CALL_OW 256
41204: PUSH
41205: LD_INT 1000
41207: EQUAL
41208: IFFALSE 41222
// SetTag ( k , 0 ) ;
41210: LD_VAR 0 8
41214: PPUSH
41215: LD_INT 0
41217: PPUSH
41218: CALL_OW 109
41222: GO 41192
41224: POP
41225: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41226: LD_VAR 0 1
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: LD_INT 25
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PPUSH
41244: CALL 12354 0 3
41248: IFFALSE 41312
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41250: LD_ADDR_VAR 0 8
41254: PUSH
41255: LD_VAR 0 4
41259: PPUSH
41260: LD_INT 0
41262: PPUSH
41263: LD_INT 25
41265: PUSH
41266: LD_INT 3
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PPUSH
41273: CALL 12354 0 3
41277: PUSH
41278: FOR_IN
41279: IFFALSE 41310
// if GetTag ( k ) = 0 then
41281: LD_VAR 0 8
41285: PPUSH
41286: CALL_OW 110
41290: PUSH
41291: LD_INT 0
41293: EQUAL
41294: IFFALSE 41308
// begin SetTag ( k , 8 ) ;
41296: LD_VAR 0 8
41300: PPUSH
41301: LD_INT 8
41303: PPUSH
41304: CALL_OW 109
// end ;
41308: GO 41278
41310: POP
41311: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41312: LD_VAR 0 1
41316: PPUSH
41317: LD_INT 6
41319: PPUSH
41320: LD_INT 92
41322: PUSH
41323: LD_VAR 0 6
41327: PUSH
41328: LD_VAR 0 7
41332: PUSH
41333: LD_INT 10
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: LIST
41340: LIST
41341: PPUSH
41342: CALL 12354 0 3
41346: IFFALSE 41470
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41348: LD_ADDR_VAR 0 5
41352: PUSH
41353: LD_VAR 0 4
41357: PPUSH
41358: LD_INT 6
41360: PPUSH
41361: LD_INT 92
41363: PUSH
41364: LD_VAR 0 6
41368: PUSH
41369: LD_VAR 0 7
41373: PUSH
41374: LD_INT 10
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL 12354 0 3
41387: PUSH
41388: FOR_IN
41389: IFFALSE 41468
// begin if not HasTask ( j ) and GetDriver ( j ) then
41391: LD_VAR 0 5
41395: PPUSH
41396: CALL_OW 314
41400: NOT
41401: PUSH
41402: LD_VAR 0 5
41406: PPUSH
41407: CALL 31773 0 1
41411: AND
41412: IFFALSE 41466
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41414: LD_VAR 0 5
41418: PPUSH
41419: CALL 31773 0 1
41423: PPUSH
41424: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41428: LD_VAR 0 5
41432: PPUSH
41433: CALL 31773 0 1
41437: PPUSH
41438: LD_VAR 0 5
41442: PPUSH
41443: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41447: LD_VAR 0 5
41451: PPUSH
41452: CALL 31773 0 1
41456: PPUSH
41457: LD_VAR 0 5
41461: PPUSH
41462: CALL_OW 180
// end ; end ;
41466: GO 41388
41468: POP
41469: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41470: LD_VAR 0 1
41474: PPUSH
41475: LD_INT 6
41477: PPUSH
41478: LD_INT 92
41480: PUSH
41481: LD_VAR 0 6
41485: PUSH
41486: LD_VAR 0 7
41490: PUSH
41491: LD_INT 10
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: PPUSH
41500: CALL 12354 0 3
41504: PUSH
41505: LD_VAR 0 1
41509: PPUSH
41510: LD_INT 8
41512: PPUSH
41513: EMPTY
41514: PPUSH
41515: CALL 12354 0 3
41519: AND
41520: IFFALSE 41619
// for j in MCF_Tag ( side , 8 , [ ] ) do
41522: LD_ADDR_VAR 0 5
41526: PUSH
41527: LD_VAR 0 1
41531: PPUSH
41532: LD_INT 8
41534: PPUSH
41535: EMPTY
41536: PPUSH
41537: CALL 12354 0 3
41541: PUSH
41542: FOR_IN
41543: IFFALSE 41617
// begin if IsInUnit ( j ) then
41545: LD_VAR 0 5
41549: PPUSH
41550: CALL_OW 310
41554: IFFALSE 41567
// ComExitBuilding ( j ) else
41556: LD_VAR 0 5
41560: PPUSH
41561: CALL_OW 122
41565: GO 41615
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41567: LD_VAR 0 5
41571: PPUSH
41572: LD_VAR 0 1
41576: PPUSH
41577: LD_INT 6
41579: PPUSH
41580: LD_INT 92
41582: PUSH
41583: LD_VAR 0 6
41587: PUSH
41588: LD_VAR 0 7
41592: PUSH
41593: LD_INT 10
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: PPUSH
41602: CALL 12354 0 3
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PPUSH
41611: CALL_OW 129
// end ;
41615: GO 41542
41617: POP
41618: POP
// end ; end else
41619: GO 41676
// if MCF_Tag ( side , 8 , [ ] ) then
41621: LD_VAR 0 1
41625: PPUSH
41626: LD_INT 8
41628: PPUSH
41629: EMPTY
41630: PPUSH
41631: CALL 12354 0 3
41635: IFFALSE 41676
// for k in MCF_Tag ( side , 8 , [ ] ) do
41637: LD_ADDR_VAR 0 8
41641: PUSH
41642: LD_VAR 0 1
41646: PPUSH
41647: LD_INT 8
41649: PPUSH
41650: EMPTY
41651: PPUSH
41652: CALL 12354 0 3
41656: PUSH
41657: FOR_IN
41658: IFFALSE 41674
// SetTag ( k , 0 ) ;
41660: LD_VAR 0 8
41664: PPUSH
41665: LD_INT 0
41667: PPUSH
41668: CALL_OW 109
41672: GO 41657
41674: POP
41675: POP
// end ; end_of_file
41676: LD_VAR 0 3
41680: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41681: LD_INT 0
41683: PPUSH
// MREG_Game := [ ] ;
41684: LD_ADDR_EXP 33
41688: PUSH
41689: EMPTY
41690: ST_TO_ADDR
// MREG_Crates := [ ] ;
41691: LD_ADDR_EXP 34
41695: PUSH
41696: EMPTY
41697: ST_TO_ADDR
// MREG_Heal := [ ] ;
41698: LD_ADDR_EXP 35
41702: PUSH
41703: EMPTY
41704: ST_TO_ADDR
// MREG_Tame := [ ] ;
41705: LD_ADDR_EXP 37
41709: PUSH
41710: EMPTY
41711: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41712: LD_ADDR_EXP 38
41716: PUSH
41717: EMPTY
41718: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41719: LD_ADDR_EXP 39
41723: PUSH
41724: EMPTY
41725: ST_TO_ADDR
// MREG_LabList := [ ] ;
41726: LD_ADDR_EXP 40
41730: PUSH
41731: EMPTY
41732: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41733: LD_ADDR_EXP 41
41737: PUSH
41738: EMPTY
41739: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41740: LD_ADDR_EXP 42
41744: PUSH
41745: EMPTY
41746: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41747: LD_ADDR_EXP 43
41751: PUSH
41752: EMPTY
41753: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41754: LD_ADDR_EXP 44
41758: PUSH
41759: EMPTY
41760: ST_TO_ADDR
// MREG_Status := [ ] ;
41761: LD_ADDR_EXP 45
41765: PUSH
41766: EMPTY
41767: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41768: LD_ADDR_EXP 46
41772: PUSH
41773: EMPTY
41774: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41775: LD_ADDR_EXP 47
41779: PUSH
41780: EMPTY
41781: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41782: LD_ADDR_EXP 48
41786: PUSH
41787: EMPTY
41788: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41789: LD_ADDR_EXP 49
41793: PUSH
41794: EMPTY
41795: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41796: LD_ADDR_EXP 50
41800: PUSH
41801: EMPTY
41802: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41803: LD_ADDR_EXP 51
41807: PUSH
41808: EMPTY
41809: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41810: LD_ADDR_EXP 52
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41817: LD_ADDR_EXP 53
41821: PUSH
41822: EMPTY
41823: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41824: LD_ADDR_EXP 54
41828: PUSH
41829: EMPTY
41830: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41831: LD_ADDR_EXP 55
41835: PUSH
41836: EMPTY
41837: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41838: LD_ADDR_EXP 56
41842: PUSH
41843: EMPTY
41844: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41845: LD_ADDR_EXP 57
41849: PUSH
41850: EMPTY
41851: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41852: LD_ADDR_EXP 61
41856: PUSH
41857: EMPTY
41858: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41859: LD_ADDR_EXP 62
41863: PUSH
41864: EMPTY
41865: ST_TO_ADDR
// MREG_Parking := [ ] ;
41866: LD_ADDR_EXP 58
41870: PUSH
41871: EMPTY
41872: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41873: LD_ADDR_EXP 59
41877: PUSH
41878: EMPTY
41879: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41880: LD_ADDR_EXP 63
41884: PUSH
41885: EMPTY
41886: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41887: LD_ADDR_EXP 64
41891: PUSH
41892: EMPTY
41893: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41894: LD_ADDR_EXP 65
41898: PUSH
41899: EMPTY
41900: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41901: LD_ADDR_EXP 67
41905: PUSH
41906: EMPTY
41907: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41908: LD_ADDR_EXP 68
41912: PUSH
41913: EMPTY
41914: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41915: LD_ADDR_EXP 69
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41922: LD_ADDR_EXP 71
41926: PUSH
41927: EMPTY
41928: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41929: LD_ADDR_EXP 70
41933: PUSH
41934: EMPTY
41935: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41936: LD_ADDR_EXP 72
41940: PUSH
41941: LD_INT 300
41943: PUSH
41944: LD_INT 100
41946: PUSH
41947: LD_INT 25
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: ST_TO_ADDR
// end ;
41955: LD_VAR 0 1
41959: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41960: LD_INT 0
41962: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41963: LD_VAR 0 2
41967: PUSH
41968: LD_VAR 0 3
41972: PUSH
41973: LD_VAR 0 4
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: LIST
41982: PUSH
41983: LD_VAR 0 1
41987: IN
41988: IFFALSE 42002
// result := mreg_list else
41990: LD_ADDR_VAR 0 5
41994: PUSH
41995: LD_VAR 0 1
41999: ST_TO_ADDR
42000: GO 42036
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42002: LD_ADDR_VAR 0 1
42006: PUSH
42007: LD_VAR 0 1
42011: PUSH
42012: LD_VAR 0 2
42016: PUSH
42017: LD_VAR 0 3
42021: PUSH
42022: LD_VAR 0 4
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: ADD
42035: ST_TO_ADDR
// result := mreg_list ;
42036: LD_ADDR_VAR 0 5
42040: PUSH
42041: LD_VAR 0 1
42045: ST_TO_ADDR
// end ;
42046: LD_VAR 0 5
42050: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42051: LD_INT 0
42053: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42054: LD_VAR 0 2
42058: PUSH
42059: LD_VAR 0 3
42063: PUSH
42064: LD_VAR 0 4
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: LIST
42073: PUSH
42074: LD_VAR 0 1
42078: IN
42079: IFFALSE 42117
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42081: LD_ADDR_VAR 0 5
42085: PUSH
42086: LD_VAR 0 1
42090: PUSH
42091: LD_VAR 0 2
42095: PUSH
42096: LD_VAR 0 3
42100: PUSH
42101: LD_VAR 0 4
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: PUSH
42111: EMPTY
42112: LIST
42113: DIFF
42114: ST_TO_ADDR
42115: GO 42127
// result := mreg_list ;
42117: LD_ADDR_VAR 0 5
42121: PUSH
42122: LD_VAR 0 1
42126: ST_TO_ADDR
// end ;
42127: LD_VAR 0 5
42131: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42132: LD_INT 0
42134: PPUSH
42135: PPUSH
42136: PPUSH
// for j = 1 to 8 do
42137: LD_ADDR_VAR 0 3
42141: PUSH
42142: DOUBLE
42143: LD_INT 1
42145: DEC
42146: ST_TO_ADDR
42147: LD_INT 8
42149: PUSH
42150: FOR_TO
42151: IFFALSE 42992
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42153: LD_VAR 0 3
42157: PPUSH
42158: LD_INT 51
42160: PUSH
42161: EMPTY
42162: LIST
42163: PPUSH
42164: CALL 11651 0 2
42168: PUSH
42169: LD_OWVAR 2
42173: PUSH
42174: LD_VAR 0 3
42178: EQUAL
42179: NOT
42180: AND
42181: IFFALSE 42199
// MREG_SidesList := MREG_SidesList ^ 1 else
42183: LD_ADDR_EXP 39
42187: PUSH
42188: LD_EXP 39
42192: PUSH
42193: LD_INT 1
42195: ADD
42196: ST_TO_ADDR
42197: GO 42213
// MREG_SidesList := MREG_SidesList ^ 0 ;
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 0
42211: ADD
42212: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42213: LD_VAR 0 3
42217: PPUSH
42218: LD_INT 2
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 12
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 34
42233: PUSH
42234: LD_INT 32
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 34
42243: PUSH
42244: LD_INT 51
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: PUSH
42257: EMPTY
42258: LIST
42259: PPUSH
42260: CALL 11952 0 2
42264: IFFALSE 42365
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42266: LD_ADDR_VAR 0 2
42270: PUSH
42271: LD_VAR 0 3
42275: PPUSH
42276: LD_INT 2
42278: PUSH
42279: LD_INT 34
42281: PUSH
42282: LD_INT 12
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 34
42291: PUSH
42292: LD_INT 32
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 34
42301: PUSH
42302: LD_INT 51
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PPUSH
42318: CALL 11952 0 2
42322: PUSH
42323: FOR_IN
42324: IFFALSE 42363
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42326: LD_ADDR_EXP 41
42330: PUSH
42331: LD_EXP 41
42335: PPUSH
42336: LD_VAR 0 3
42340: PPUSH
42341: LD_VAR 0 2
42345: PPUSH
42346: LD_VAR 0 2
42350: PPUSH
42351: CALL_OW 264
42355: PPUSH
42356: CALL 41960 0 4
42360: ST_TO_ADDR
42361: GO 42323
42363: POP
42364: POP
// if MCF_Class ( j , 4 , [ ] ) then
42365: LD_VAR 0 3
42369: PPUSH
42370: LD_INT 4
42372: PPUSH
42373: EMPTY
42374: PPUSH
42375: CALL 11734 0 3
42379: IFFALSE 42412
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42381: LD_ADDR_EXP 54
42385: PUSH
42386: LD_EXP 54
42390: PUSH
42391: LD_VAR 0 3
42395: PPUSH
42396: LD_INT 4
42398: PPUSH
42399: EMPTY
42400: PPUSH
42401: CALL 11734 0 3
42405: PUSH
42406: EMPTY
42407: LIST
42408: ADD
42409: ST_TO_ADDR
42410: GO 42429
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42412: LD_ADDR_EXP 54
42416: PUSH
42417: LD_EXP 54
42421: PUSH
42422: LD_INT 0
42424: PUSH
42425: EMPTY
42426: LIST
42427: ADD
42428: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42429: LD_VAR 0 3
42433: PPUSH
42434: LD_INT 3
42436: PPUSH
42437: EMPTY
42438: PPUSH
42439: CALL 11734 0 3
42443: IFFALSE 42476
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42445: LD_ADDR_EXP 55
42449: PUSH
42450: LD_EXP 55
42454: PUSH
42455: LD_VAR 0 3
42459: PPUSH
42460: LD_INT 3
42462: PPUSH
42463: EMPTY
42464: PPUSH
42465: CALL 11734 0 3
42469: PUSH
42470: EMPTY
42471: LIST
42472: ADD
42473: ST_TO_ADDR
42474: GO 42493
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42476: LD_ADDR_EXP 55
42480: PUSH
42481: LD_EXP 55
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: ADD
42492: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42493: LD_VAR 0 3
42497: PPUSH
42498: LD_INT 1
42500: PPUSH
42501: EMPTY
42502: PPUSH
42503: CALL 11734 0 3
42507: IFFALSE 42540
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42509: LD_ADDR_EXP 56
42513: PUSH
42514: LD_EXP 56
42518: PUSH
42519: LD_VAR 0 3
42523: PPUSH
42524: LD_INT 1
42526: PPUSH
42527: EMPTY
42528: PPUSH
42529: CALL 11734 0 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: ADD
42537: ST_TO_ADDR
42538: GO 42557
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42540: LD_ADDR_EXP 56
42544: PUSH
42545: LD_EXP 56
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: ADD
42556: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42557: LD_VAR 0 3
42561: PPUSH
42562: LD_INT 2
42564: PPUSH
42565: EMPTY
42566: PPUSH
42567: CALL 11734 0 3
42571: IFFALSE 42604
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42573: LD_ADDR_EXP 57
42577: PUSH
42578: LD_EXP 57
42582: PUSH
42583: LD_VAR 0 3
42587: PPUSH
42588: LD_INT 2
42590: PPUSH
42591: EMPTY
42592: PPUSH
42593: CALL 11734 0 3
42597: PUSH
42598: EMPTY
42599: LIST
42600: ADD
42601: ST_TO_ADDR
42602: GO 42621
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42604: LD_ADDR_EXP 57
42608: PUSH
42609: LD_EXP 57
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: EMPTY
42618: LIST
42619: ADD
42620: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42621: LD_ADDR_EXP 47
42625: PUSH
42626: LD_EXP 47
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: EMPTY
42635: LIST
42636: ADD
42637: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42638: LD_ADDR_EXP 35
42642: PUSH
42643: LD_EXP 35
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: EMPTY
42652: LIST
42653: ADD
42654: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42655: LD_ADDR_EXP 37
42659: PUSH
42660: LD_EXP 37
42664: PUSH
42665: LD_INT 0
42667: PUSH
42668: EMPTY
42669: LIST
42670: ADD
42671: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42672: LD_ADDR_EXP 58
42676: PUSH
42677: LD_EXP 58
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: EMPTY
42686: LIST
42687: ADD
42688: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42689: LD_ADDR_EXP 59
42693: PUSH
42694: LD_EXP 59
42698: PUSH
42699: LD_INT 0
42701: PUSH
42702: EMPTY
42703: LIST
42704: ADD
42705: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42706: LD_ADDR_EXP 51
42710: PUSH
42711: LD_EXP 51
42715: PUSH
42716: LD_INT 0
42718: PUSH
42719: EMPTY
42720: LIST
42721: ADD
42722: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42723: LD_ADDR_EXP 38
42727: PUSH
42728: LD_EXP 38
42732: PUSH
42733: LD_INT 0
42735: PUSH
42736: LD_INT 0
42738: PUSH
42739: LD_INT 0
42741: PUSH
42742: LD_INT 0
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: ADD
42754: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42755: LD_ADDR_EXP 60
42759: PUSH
42760: LD_EXP 60
42764: PUSH
42765: LD_INT 0
42767: PUSH
42768: EMPTY
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: ADD
42777: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42778: LD_ADDR_EXP 61
42782: PUSH
42783: LD_EXP 61
42787: PUSH
42788: LD_INT 0
42790: PUSH
42791: EMPTY
42792: LIST
42793: PUSH
42794: EMPTY
42795: LIST
42796: ADD
42797: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42798: LD_ADDR_EXP 42
42802: PUSH
42803: LD_EXP 42
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: ADD
42814: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42815: LD_ADDR_EXP 63
42819: PUSH
42820: LD_EXP 63
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: EMPTY
42829: LIST
42830: ADD
42831: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42832: LD_ADDR_EXP 64
42836: PUSH
42837: LD_EXP 64
42841: PUSH
42842: LD_INT 0
42844: PUSH
42845: EMPTY
42846: LIST
42847: ADD
42848: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42849: LD_ADDR_EXP 65
42853: PUSH
42854: LD_EXP 65
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: EMPTY
42863: LIST
42864: ADD
42865: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42866: LD_ADDR_EXP 66
42870: PUSH
42871: LD_EXP 66
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: EMPTY
42880: LIST
42881: ADD
42882: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42883: LD_ADDR_EXP 67
42887: PUSH
42888: LD_EXP 67
42892: PUSH
42893: LD_INT 0
42895: PUSH
42896: EMPTY
42897: LIST
42898: ADD
42899: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42900: LD_ADDR_EXP 68
42904: PUSH
42905: LD_EXP 68
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: EMPTY
42914: LIST
42915: ADD
42916: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42917: LD_ADDR_EXP 69
42921: PUSH
42922: LD_EXP 69
42926: PUSH
42927: LD_INT 0
42929: PUSH
42930: EMPTY
42931: LIST
42932: ADD
42933: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42934: LD_ADDR_EXP 71
42938: PUSH
42939: LD_EXP 71
42943: PUSH
42944: LD_INT 0
42946: PUSH
42947: EMPTY
42948: LIST
42949: ADD
42950: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42951: LD_ADDR_EXP 70
42955: PUSH
42956: LD_EXP 70
42960: PUSH
42961: LD_INT 0
42963: ADD
42964: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42965: LD_ADDR_EXP 62
42969: PUSH
42970: LD_EXP 62
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: LIST
42988: ADD
42989: ST_TO_ADDR
// end ;
42990: GO 42150
42992: POP
42993: POP
// end ;
42994: LD_VAR 0 1
42998: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42999: LD_INT 0
43001: PPUSH
43002: PPUSH
43003: PPUSH
// m := false ;
43004: LD_ADDR_VAR 0 5
43008: PUSH
43009: LD_INT 0
43011: ST_TO_ADDR
// for i = 1 to mreg do
43012: LD_ADDR_VAR 0 4
43016: PUSH
43017: DOUBLE
43018: LD_INT 1
43020: DEC
43021: ST_TO_ADDR
43022: LD_VAR 0 2
43026: PUSH
43027: FOR_TO
43028: IFFALSE 43064
// if mreg [ i ] [ 1 ] = side then
43030: LD_VAR 0 2
43034: PUSH
43035: LD_VAR 0 4
43039: ARRAY
43040: PUSH
43041: LD_INT 1
43043: ARRAY
43044: PUSH
43045: LD_VAR 0 1
43049: EQUAL
43050: IFFALSE 43062
// begin m := true ;
43052: LD_ADDR_VAR 0 5
43056: PUSH
43057: LD_INT 1
43059: ST_TO_ADDR
// break ;
43060: GO 43064
// end ;
43062: GO 43027
43064: POP
43065: POP
// result := m ;
43066: LD_ADDR_VAR 0 3
43070: PUSH
43071: LD_VAR 0 5
43075: ST_TO_ADDR
// end ;
43076: LD_VAR 0 3
43080: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43081: LD_INT 0
43083: PPUSH
43084: PPUSH
43085: PPUSH
// m := 0 ;
43086: LD_ADDR_VAR 0 5
43090: PUSH
43091: LD_INT 0
43093: ST_TO_ADDR
// for i = 1 to mreg do
43094: LD_ADDR_VAR 0 4
43098: PUSH
43099: DOUBLE
43100: LD_INT 1
43102: DEC
43103: ST_TO_ADDR
43104: LD_VAR 0 2
43108: PUSH
43109: FOR_TO
43110: IFFALSE 43150
// if mreg [ i ] [ 1 ] = side then
43112: LD_VAR 0 2
43116: PUSH
43117: LD_VAR 0 4
43121: ARRAY
43122: PUSH
43123: LD_INT 1
43125: ARRAY
43126: PUSH
43127: LD_VAR 0 1
43131: EQUAL
43132: IFFALSE 43148
// begin m := m + 1 ;
43134: LD_ADDR_VAR 0 5
43138: PUSH
43139: LD_VAR 0 5
43143: PUSH
43144: LD_INT 1
43146: PLUS
43147: ST_TO_ADDR
// end ;
43148: GO 43109
43150: POP
43151: POP
// result := m ;
43152: LD_ADDR_VAR 0 3
43156: PUSH
43157: LD_VAR 0 5
43161: ST_TO_ADDR
// end ;
43162: LD_VAR 0 3
43166: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43167: LD_INT 0
43169: PPUSH
43170: PPUSH
// result := 0 ;
43171: LD_ADDR_VAR 0 3
43175: PUSH
43176: LD_INT 0
43178: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43179: LD_ADDR_VAR 0 4
43183: PUSH
43184: DOUBLE
43185: LD_INT 1
43187: DEC
43188: ST_TO_ADDR
43189: LD_EXP 53
43193: PUSH
43194: FOR_TO
43195: IFFALSE 43257
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43197: LD_EXP 53
43201: PUSH
43202: LD_VAR 0 4
43206: ARRAY
43207: PUSH
43208: LD_INT 1
43210: ARRAY
43211: PUSH
43212: LD_VAR 0 1
43216: EQUAL
43217: PUSH
43218: LD_EXP 53
43222: PUSH
43223: LD_VAR 0 4
43227: ARRAY
43228: PUSH
43229: LD_INT 2
43231: ARRAY
43232: PUSH
43233: LD_VAR 0 2
43237: EQUAL
43238: AND
43239: IFFALSE 43255
// begin result := result + 1 ;
43241: LD_ADDR_VAR 0 3
43245: PUSH
43246: LD_VAR 0 3
43250: PUSH
43251: LD_INT 1
43253: PLUS
43254: ST_TO_ADDR
// end ;
43255: GO 43194
43257: POP
43258: POP
// end ; end_of_file end_of_file
43259: LD_VAR 0 3
43263: RET
// export globalGameSaveCounter ; every 0 0$1 do
43264: GO 43266
43266: DISABLE
// begin enable ;
43267: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43268: LD_STRING updateTimer(
43270: PUSH
43271: LD_OWVAR 1
43275: STR
43276: PUSH
43277: LD_STRING );
43279: STR
43280: PPUSH
43281: CALL_OW 559
// end ;
43285: END
// every 0 0$1 do
43286: GO 43288
43288: DISABLE
// begin globalGameSaveCounter := 0 ;
43289: LD_ADDR_EXP 73
43293: PUSH
43294: LD_INT 0
43296: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
43297: LD_STRING setGameSaveCounter(0)
43299: PPUSH
43300: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
43304: LD_STRING initStreamRollete();
43306: PPUSH
43307: CALL_OW 559
// InitStreamMode ;
43311: CALL 44637 0 0
// DefineStreamItems ( false ) ;
43315: LD_INT 0
43317: PPUSH
43318: CALL 45101 0 1
// end ;
43322: END
// export function SOS_MapStart ( ) ; begin
43323: LD_INT 0
43325: PPUSH
// if streamModeActive then
43326: LD_EXP 74
43330: IFFALSE 43339
// DefineStreamItems ( true ) ;
43332: LD_INT 1
43334: PPUSH
43335: CALL 45101 0 1
// UpdateLuaVariables ( ) ;
43339: CALL 43356 0 0
// UpdateFactoryWaypoints ( ) ;
43343: CALL 57970 0 0
// UpdateWarehouseGatheringPoints ( ) ;
43347: CALL 58227 0 0
// end ;
43351: LD_VAR 0 1
43355: RET
// function UpdateLuaVariables ( ) ; begin
43356: LD_INT 0
43358: PPUSH
// if globalGameSaveCounter then
43359: LD_EXP 73
43363: IFFALSE 43397
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
43365: LD_ADDR_EXP 73
43369: PUSH
43370: LD_EXP 73
43374: PPUSH
43375: CALL 102037 0 1
43379: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
43380: LD_STRING setGameSaveCounter(
43382: PUSH
43383: LD_EXP 73
43387: STR
43388: PUSH
43389: LD_STRING )
43391: STR
43392: PPUSH
43393: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
43397: LD_STRING setGameDifficulty(
43399: PUSH
43400: LD_OWVAR 67
43404: STR
43405: PUSH
43406: LD_STRING )
43408: STR
43409: PPUSH
43410: CALL_OW 559
// end ;
43414: LD_VAR 0 1
43418: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43419: LD_INT 0
43421: PPUSH
// if p2 = stream_mode then
43422: LD_VAR 0 2
43426: PUSH
43427: LD_INT 100
43429: EQUAL
43430: IFFALSE 44433
// begin if not StreamModeActive then
43432: LD_EXP 74
43436: NOT
43437: IFFALSE 43447
// StreamModeActive := true ;
43439: LD_ADDR_EXP 74
43443: PUSH
43444: LD_INT 1
43446: ST_TO_ADDR
// if p3 = 0 then
43447: LD_VAR 0 3
43451: PUSH
43452: LD_INT 0
43454: EQUAL
43455: IFFALSE 43461
// InitStreamMode ;
43457: CALL 44637 0 0
// if p3 = 1 then
43461: LD_VAR 0 3
43465: PUSH
43466: LD_INT 1
43468: EQUAL
43469: IFFALSE 43479
// sRocket := true ;
43471: LD_ADDR_EXP 79
43475: PUSH
43476: LD_INT 1
43478: ST_TO_ADDR
// if p3 = 2 then
43479: LD_VAR 0 3
43483: PUSH
43484: LD_INT 2
43486: EQUAL
43487: IFFALSE 43497
// sSpeed := true ;
43489: LD_ADDR_EXP 78
43493: PUSH
43494: LD_INT 1
43496: ST_TO_ADDR
// if p3 = 3 then
43497: LD_VAR 0 3
43501: PUSH
43502: LD_INT 3
43504: EQUAL
43505: IFFALSE 43515
// sEngine := true ;
43507: LD_ADDR_EXP 80
43511: PUSH
43512: LD_INT 1
43514: ST_TO_ADDR
// if p3 = 4 then
43515: LD_VAR 0 3
43519: PUSH
43520: LD_INT 4
43522: EQUAL
43523: IFFALSE 43533
// sSpec := true ;
43525: LD_ADDR_EXP 77
43529: PUSH
43530: LD_INT 1
43532: ST_TO_ADDR
// if p3 = 5 then
43533: LD_VAR 0 3
43537: PUSH
43538: LD_INT 5
43540: EQUAL
43541: IFFALSE 43551
// sLevel := true ;
43543: LD_ADDR_EXP 81
43547: PUSH
43548: LD_INT 1
43550: ST_TO_ADDR
// if p3 = 6 then
43551: LD_VAR 0 3
43555: PUSH
43556: LD_INT 6
43558: EQUAL
43559: IFFALSE 43569
// sArmoury := true ;
43561: LD_ADDR_EXP 82
43565: PUSH
43566: LD_INT 1
43568: ST_TO_ADDR
// if p3 = 7 then
43569: LD_VAR 0 3
43573: PUSH
43574: LD_INT 7
43576: EQUAL
43577: IFFALSE 43587
// sRadar := true ;
43579: LD_ADDR_EXP 83
43583: PUSH
43584: LD_INT 1
43586: ST_TO_ADDR
// if p3 = 8 then
43587: LD_VAR 0 3
43591: PUSH
43592: LD_INT 8
43594: EQUAL
43595: IFFALSE 43605
// sBunker := true ;
43597: LD_ADDR_EXP 84
43601: PUSH
43602: LD_INT 1
43604: ST_TO_ADDR
// if p3 = 9 then
43605: LD_VAR 0 3
43609: PUSH
43610: LD_INT 9
43612: EQUAL
43613: IFFALSE 43623
// sHack := true ;
43615: LD_ADDR_EXP 85
43619: PUSH
43620: LD_INT 1
43622: ST_TO_ADDR
// if p3 = 10 then
43623: LD_VAR 0 3
43627: PUSH
43628: LD_INT 10
43630: EQUAL
43631: IFFALSE 43641
// sFire := true ;
43633: LD_ADDR_EXP 86
43637: PUSH
43638: LD_INT 1
43640: ST_TO_ADDR
// if p3 = 11 then
43641: LD_VAR 0 3
43645: PUSH
43646: LD_INT 11
43648: EQUAL
43649: IFFALSE 43659
// sRefresh := true ;
43651: LD_ADDR_EXP 87
43655: PUSH
43656: LD_INT 1
43658: ST_TO_ADDR
// if p3 = 12 then
43659: LD_VAR 0 3
43663: PUSH
43664: LD_INT 12
43666: EQUAL
43667: IFFALSE 43677
// sExp := true ;
43669: LD_ADDR_EXP 88
43673: PUSH
43674: LD_INT 1
43676: ST_TO_ADDR
// if p3 = 13 then
43677: LD_VAR 0 3
43681: PUSH
43682: LD_INT 13
43684: EQUAL
43685: IFFALSE 43695
// sDepot := true ;
43687: LD_ADDR_EXP 89
43691: PUSH
43692: LD_INT 1
43694: ST_TO_ADDR
// if p3 = 14 then
43695: LD_VAR 0 3
43699: PUSH
43700: LD_INT 14
43702: EQUAL
43703: IFFALSE 43713
// sFlag := true ;
43705: LD_ADDR_EXP 90
43709: PUSH
43710: LD_INT 1
43712: ST_TO_ADDR
// if p3 = 15 then
43713: LD_VAR 0 3
43717: PUSH
43718: LD_INT 15
43720: EQUAL
43721: IFFALSE 43731
// sKamikadze := true ;
43723: LD_ADDR_EXP 98
43727: PUSH
43728: LD_INT 1
43730: ST_TO_ADDR
// if p3 = 16 then
43731: LD_VAR 0 3
43735: PUSH
43736: LD_INT 16
43738: EQUAL
43739: IFFALSE 43749
// sTroll := true ;
43741: LD_ADDR_EXP 99
43745: PUSH
43746: LD_INT 1
43748: ST_TO_ADDR
// if p3 = 17 then
43749: LD_VAR 0 3
43753: PUSH
43754: LD_INT 17
43756: EQUAL
43757: IFFALSE 43767
// sSlow := true ;
43759: LD_ADDR_EXP 100
43763: PUSH
43764: LD_INT 1
43766: ST_TO_ADDR
// if p3 = 18 then
43767: LD_VAR 0 3
43771: PUSH
43772: LD_INT 18
43774: EQUAL
43775: IFFALSE 43785
// sLack := true ;
43777: LD_ADDR_EXP 101
43781: PUSH
43782: LD_INT 1
43784: ST_TO_ADDR
// if p3 = 19 then
43785: LD_VAR 0 3
43789: PUSH
43790: LD_INT 19
43792: EQUAL
43793: IFFALSE 43803
// sTank := true ;
43795: LD_ADDR_EXP 103
43799: PUSH
43800: LD_INT 1
43802: ST_TO_ADDR
// if p3 = 20 then
43803: LD_VAR 0 3
43807: PUSH
43808: LD_INT 20
43810: EQUAL
43811: IFFALSE 43821
// sRemote := true ;
43813: LD_ADDR_EXP 104
43817: PUSH
43818: LD_INT 1
43820: ST_TO_ADDR
// if p3 = 21 then
43821: LD_VAR 0 3
43825: PUSH
43826: LD_INT 21
43828: EQUAL
43829: IFFALSE 43839
// sPowell := true ;
43831: LD_ADDR_EXP 105
43835: PUSH
43836: LD_INT 1
43838: ST_TO_ADDR
// if p3 = 22 then
43839: LD_VAR 0 3
43843: PUSH
43844: LD_INT 22
43846: EQUAL
43847: IFFALSE 43857
// sTeleport := true ;
43849: LD_ADDR_EXP 108
43853: PUSH
43854: LD_INT 1
43856: ST_TO_ADDR
// if p3 = 23 then
43857: LD_VAR 0 3
43861: PUSH
43862: LD_INT 23
43864: EQUAL
43865: IFFALSE 43875
// sOilTower := true ;
43867: LD_ADDR_EXP 110
43871: PUSH
43872: LD_INT 1
43874: ST_TO_ADDR
// if p3 = 24 then
43875: LD_VAR 0 3
43879: PUSH
43880: LD_INT 24
43882: EQUAL
43883: IFFALSE 43893
// sShovel := true ;
43885: LD_ADDR_EXP 111
43889: PUSH
43890: LD_INT 1
43892: ST_TO_ADDR
// if p3 = 25 then
43893: LD_VAR 0 3
43897: PUSH
43898: LD_INT 25
43900: EQUAL
43901: IFFALSE 43911
// sSheik := true ;
43903: LD_ADDR_EXP 112
43907: PUSH
43908: LD_INT 1
43910: ST_TO_ADDR
// if p3 = 26 then
43911: LD_VAR 0 3
43915: PUSH
43916: LD_INT 26
43918: EQUAL
43919: IFFALSE 43929
// sEarthquake := true ;
43921: LD_ADDR_EXP 114
43925: PUSH
43926: LD_INT 1
43928: ST_TO_ADDR
// if p3 = 27 then
43929: LD_VAR 0 3
43933: PUSH
43934: LD_INT 27
43936: EQUAL
43937: IFFALSE 43947
// sAI := true ;
43939: LD_ADDR_EXP 115
43943: PUSH
43944: LD_INT 1
43946: ST_TO_ADDR
// if p3 = 28 then
43947: LD_VAR 0 3
43951: PUSH
43952: LD_INT 28
43954: EQUAL
43955: IFFALSE 43965
// sCargo := true ;
43957: LD_ADDR_EXP 118
43961: PUSH
43962: LD_INT 1
43964: ST_TO_ADDR
// if p3 = 29 then
43965: LD_VAR 0 3
43969: PUSH
43970: LD_INT 29
43972: EQUAL
43973: IFFALSE 43983
// sDLaser := true ;
43975: LD_ADDR_EXP 119
43979: PUSH
43980: LD_INT 1
43982: ST_TO_ADDR
// if p3 = 30 then
43983: LD_VAR 0 3
43987: PUSH
43988: LD_INT 30
43990: EQUAL
43991: IFFALSE 44001
// sExchange := true ;
43993: LD_ADDR_EXP 120
43997: PUSH
43998: LD_INT 1
44000: ST_TO_ADDR
// if p3 = 31 then
44001: LD_VAR 0 3
44005: PUSH
44006: LD_INT 31
44008: EQUAL
44009: IFFALSE 44019
// sFac := true ;
44011: LD_ADDR_EXP 121
44015: PUSH
44016: LD_INT 1
44018: ST_TO_ADDR
// if p3 = 32 then
44019: LD_VAR 0 3
44023: PUSH
44024: LD_INT 32
44026: EQUAL
44027: IFFALSE 44037
// sPower := true ;
44029: LD_ADDR_EXP 122
44033: PUSH
44034: LD_INT 1
44036: ST_TO_ADDR
// if p3 = 33 then
44037: LD_VAR 0 3
44041: PUSH
44042: LD_INT 33
44044: EQUAL
44045: IFFALSE 44055
// sRandom := true ;
44047: LD_ADDR_EXP 123
44051: PUSH
44052: LD_INT 1
44054: ST_TO_ADDR
// if p3 = 34 then
44055: LD_VAR 0 3
44059: PUSH
44060: LD_INT 34
44062: EQUAL
44063: IFFALSE 44073
// sShield := true ;
44065: LD_ADDR_EXP 124
44069: PUSH
44070: LD_INT 1
44072: ST_TO_ADDR
// if p3 = 35 then
44073: LD_VAR 0 3
44077: PUSH
44078: LD_INT 35
44080: EQUAL
44081: IFFALSE 44091
// sTime := true ;
44083: LD_ADDR_EXP 125
44087: PUSH
44088: LD_INT 1
44090: ST_TO_ADDR
// if p3 = 36 then
44091: LD_VAR 0 3
44095: PUSH
44096: LD_INT 36
44098: EQUAL
44099: IFFALSE 44109
// sTools := true ;
44101: LD_ADDR_EXP 126
44105: PUSH
44106: LD_INT 1
44108: ST_TO_ADDR
// if p3 = 101 then
44109: LD_VAR 0 3
44113: PUSH
44114: LD_INT 101
44116: EQUAL
44117: IFFALSE 44127
// sSold := true ;
44119: LD_ADDR_EXP 91
44123: PUSH
44124: LD_INT 1
44126: ST_TO_ADDR
// if p3 = 102 then
44127: LD_VAR 0 3
44131: PUSH
44132: LD_INT 102
44134: EQUAL
44135: IFFALSE 44145
// sDiff := true ;
44137: LD_ADDR_EXP 92
44141: PUSH
44142: LD_INT 1
44144: ST_TO_ADDR
// if p3 = 103 then
44145: LD_VAR 0 3
44149: PUSH
44150: LD_INT 103
44152: EQUAL
44153: IFFALSE 44163
// sFog := true ;
44155: LD_ADDR_EXP 95
44159: PUSH
44160: LD_INT 1
44162: ST_TO_ADDR
// if p3 = 104 then
44163: LD_VAR 0 3
44167: PUSH
44168: LD_INT 104
44170: EQUAL
44171: IFFALSE 44181
// sReset := true ;
44173: LD_ADDR_EXP 96
44177: PUSH
44178: LD_INT 1
44180: ST_TO_ADDR
// if p3 = 105 then
44181: LD_VAR 0 3
44185: PUSH
44186: LD_INT 105
44188: EQUAL
44189: IFFALSE 44199
// sSun := true ;
44191: LD_ADDR_EXP 97
44195: PUSH
44196: LD_INT 1
44198: ST_TO_ADDR
// if p3 = 106 then
44199: LD_VAR 0 3
44203: PUSH
44204: LD_INT 106
44206: EQUAL
44207: IFFALSE 44217
// sTiger := true ;
44209: LD_ADDR_EXP 93
44213: PUSH
44214: LD_INT 1
44216: ST_TO_ADDR
// if p3 = 107 then
44217: LD_VAR 0 3
44221: PUSH
44222: LD_INT 107
44224: EQUAL
44225: IFFALSE 44235
// sBomb := true ;
44227: LD_ADDR_EXP 94
44231: PUSH
44232: LD_INT 1
44234: ST_TO_ADDR
// if p3 = 108 then
44235: LD_VAR 0 3
44239: PUSH
44240: LD_INT 108
44242: EQUAL
44243: IFFALSE 44253
// sWound := true ;
44245: LD_ADDR_EXP 102
44249: PUSH
44250: LD_INT 1
44252: ST_TO_ADDR
// if p3 = 109 then
44253: LD_VAR 0 3
44257: PUSH
44258: LD_INT 109
44260: EQUAL
44261: IFFALSE 44271
// sBetray := true ;
44263: LD_ADDR_EXP 106
44267: PUSH
44268: LD_INT 1
44270: ST_TO_ADDR
// if p3 = 110 then
44271: LD_VAR 0 3
44275: PUSH
44276: LD_INT 110
44278: EQUAL
44279: IFFALSE 44289
// sContamin := true ;
44281: LD_ADDR_EXP 107
44285: PUSH
44286: LD_INT 1
44288: ST_TO_ADDR
// if p3 = 111 then
44289: LD_VAR 0 3
44293: PUSH
44294: LD_INT 111
44296: EQUAL
44297: IFFALSE 44307
// sOil := true ;
44299: LD_ADDR_EXP 109
44303: PUSH
44304: LD_INT 1
44306: ST_TO_ADDR
// if p3 = 112 then
44307: LD_VAR 0 3
44311: PUSH
44312: LD_INT 112
44314: EQUAL
44315: IFFALSE 44325
// sStu := true ;
44317: LD_ADDR_EXP 113
44321: PUSH
44322: LD_INT 1
44324: ST_TO_ADDR
// if p3 = 113 then
44325: LD_VAR 0 3
44329: PUSH
44330: LD_INT 113
44332: EQUAL
44333: IFFALSE 44343
// sBazooka := true ;
44335: LD_ADDR_EXP 116
44339: PUSH
44340: LD_INT 1
44342: ST_TO_ADDR
// if p3 = 114 then
44343: LD_VAR 0 3
44347: PUSH
44348: LD_INT 114
44350: EQUAL
44351: IFFALSE 44361
// sMortar := true ;
44353: LD_ADDR_EXP 117
44357: PUSH
44358: LD_INT 1
44360: ST_TO_ADDR
// if p3 = 115 then
44361: LD_VAR 0 3
44365: PUSH
44366: LD_INT 115
44368: EQUAL
44369: IFFALSE 44379
// sRanger := true ;
44371: LD_ADDR_EXP 127
44375: PUSH
44376: LD_INT 1
44378: ST_TO_ADDR
// if p3 = 116 then
44379: LD_VAR 0 3
44383: PUSH
44384: LD_INT 116
44386: EQUAL
44387: IFFALSE 44397
// sComputer := true ;
44389: LD_ADDR_EXP 128
44393: PUSH
44394: LD_INT 1
44396: ST_TO_ADDR
// if p3 = 117 then
44397: LD_VAR 0 3
44401: PUSH
44402: LD_INT 117
44404: EQUAL
44405: IFFALSE 44415
// s30 := true ;
44407: LD_ADDR_EXP 129
44411: PUSH
44412: LD_INT 1
44414: ST_TO_ADDR
// if p3 = 118 then
44415: LD_VAR 0 3
44419: PUSH
44420: LD_INT 118
44422: EQUAL
44423: IFFALSE 44433
// s60 := true ;
44425: LD_ADDR_EXP 130
44429: PUSH
44430: LD_INT 1
44432: ST_TO_ADDR
// end ; if p2 = hack_mode then
44433: LD_VAR 0 2
44437: PUSH
44438: LD_INT 101
44440: EQUAL
44441: IFFALSE 44569
// begin case p3 of 1 :
44443: LD_VAR 0 3
44447: PUSH
44448: LD_INT 1
44450: DOUBLE
44451: EQUAL
44452: IFTRUE 44456
44454: GO 44463
44456: POP
// hHackUnlimitedResources ; 2 :
44457: CALL 56716 0 0
44461: GO 44569
44463: LD_INT 2
44465: DOUBLE
44466: EQUAL
44467: IFTRUE 44471
44469: GO 44478
44471: POP
// hHackSetLevel10 ; 3 :
44472: CALL 56849 0 0
44476: GO 44569
44478: LD_INT 3
44480: DOUBLE
44481: EQUAL
44482: IFTRUE 44486
44484: GO 44493
44486: POP
// hHackSetLevel10YourUnits ; 4 :
44487: CALL 56934 0 0
44491: GO 44569
44493: LD_INT 4
44495: DOUBLE
44496: EQUAL
44497: IFTRUE 44501
44499: GO 44508
44501: POP
// hHackInvincible ; 5 :
44502: CALL 57382 0 0
44506: GO 44569
44508: LD_INT 5
44510: DOUBLE
44511: EQUAL
44512: IFTRUE 44516
44514: GO 44523
44516: POP
// hHackInvisible ; 6 :
44517: CALL 57493 0 0
44521: GO 44569
44523: LD_INT 6
44525: DOUBLE
44526: EQUAL
44527: IFTRUE 44531
44529: GO 44538
44531: POP
// hHackChangeYourSide ; 7 :
44532: CALL 57550 0 0
44536: GO 44569
44538: LD_INT 7
44540: DOUBLE
44541: EQUAL
44542: IFTRUE 44546
44544: GO 44553
44546: POP
// hHackChangeUnitSide ; 8 :
44547: CALL 57592 0 0
44551: GO 44569
44553: LD_INT 8
44555: DOUBLE
44556: EQUAL
44557: IFTRUE 44561
44559: GO 44568
44561: POP
// hHackFog ; end ;
44562: CALL 57693 0 0
44566: GO 44569
44568: POP
// end ; if p2 = game_save_mode then
44569: LD_VAR 0 2
44573: PUSH
44574: LD_INT 102
44576: EQUAL
44577: IFFALSE 44632
// begin if p3 = 1 then
44579: LD_VAR 0 3
44583: PUSH
44584: LD_INT 1
44586: EQUAL
44587: IFFALSE 44599
// globalGameSaveCounter := p4 ;
44589: LD_ADDR_EXP 73
44593: PUSH
44594: LD_VAR 0 4
44598: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
44599: LD_VAR 0 3
44603: PUSH
44604: LD_INT 2
44606: EQUAL
44607: PUSH
44608: LD_EXP 73
44612: AND
44613: IFFALSE 44632
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
44615: LD_STRING setGameSaveCounter(
44617: PUSH
44618: LD_EXP 73
44622: STR
44623: PUSH
44624: LD_STRING )
44626: STR
44627: PPUSH
44628: CALL_OW 559
// end ; end ;
44632: LD_VAR 0 7
44636: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
44637: LD_INT 0
44639: PPUSH
// streamModeActive := false ;
44640: LD_ADDR_EXP 74
44644: PUSH
44645: LD_INT 0
44647: ST_TO_ADDR
// normalCounter := 36 ;
44648: LD_ADDR_EXP 75
44652: PUSH
44653: LD_INT 36
44655: ST_TO_ADDR
// hardcoreCounter := 18 ;
44656: LD_ADDR_EXP 76
44660: PUSH
44661: LD_INT 18
44663: ST_TO_ADDR
// sRocket := false ;
44664: LD_ADDR_EXP 79
44668: PUSH
44669: LD_INT 0
44671: ST_TO_ADDR
// sSpeed := false ;
44672: LD_ADDR_EXP 78
44676: PUSH
44677: LD_INT 0
44679: ST_TO_ADDR
// sEngine := false ;
44680: LD_ADDR_EXP 80
44684: PUSH
44685: LD_INT 0
44687: ST_TO_ADDR
// sSpec := false ;
44688: LD_ADDR_EXP 77
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// sLevel := false ;
44696: LD_ADDR_EXP 81
44700: PUSH
44701: LD_INT 0
44703: ST_TO_ADDR
// sArmoury := false ;
44704: LD_ADDR_EXP 82
44708: PUSH
44709: LD_INT 0
44711: ST_TO_ADDR
// sRadar := false ;
44712: LD_ADDR_EXP 83
44716: PUSH
44717: LD_INT 0
44719: ST_TO_ADDR
// sBunker := false ;
44720: LD_ADDR_EXP 84
44724: PUSH
44725: LD_INT 0
44727: ST_TO_ADDR
// sHack := false ;
44728: LD_ADDR_EXP 85
44732: PUSH
44733: LD_INT 0
44735: ST_TO_ADDR
// sFire := false ;
44736: LD_ADDR_EXP 86
44740: PUSH
44741: LD_INT 0
44743: ST_TO_ADDR
// sRefresh := false ;
44744: LD_ADDR_EXP 87
44748: PUSH
44749: LD_INT 0
44751: ST_TO_ADDR
// sExp := false ;
44752: LD_ADDR_EXP 88
44756: PUSH
44757: LD_INT 0
44759: ST_TO_ADDR
// sDepot := false ;
44760: LD_ADDR_EXP 89
44764: PUSH
44765: LD_INT 0
44767: ST_TO_ADDR
// sFlag := false ;
44768: LD_ADDR_EXP 90
44772: PUSH
44773: LD_INT 0
44775: ST_TO_ADDR
// sKamikadze := false ;
44776: LD_ADDR_EXP 98
44780: PUSH
44781: LD_INT 0
44783: ST_TO_ADDR
// sTroll := false ;
44784: LD_ADDR_EXP 99
44788: PUSH
44789: LD_INT 0
44791: ST_TO_ADDR
// sSlow := false ;
44792: LD_ADDR_EXP 100
44796: PUSH
44797: LD_INT 0
44799: ST_TO_ADDR
// sLack := false ;
44800: LD_ADDR_EXP 101
44804: PUSH
44805: LD_INT 0
44807: ST_TO_ADDR
// sTank := false ;
44808: LD_ADDR_EXP 103
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// sRemote := false ;
44816: LD_ADDR_EXP 104
44820: PUSH
44821: LD_INT 0
44823: ST_TO_ADDR
// sPowell := false ;
44824: LD_ADDR_EXP 105
44828: PUSH
44829: LD_INT 0
44831: ST_TO_ADDR
// sTeleport := false ;
44832: LD_ADDR_EXP 108
44836: PUSH
44837: LD_INT 0
44839: ST_TO_ADDR
// sOilTower := false ;
44840: LD_ADDR_EXP 110
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// sShovel := false ;
44848: LD_ADDR_EXP 111
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// sSheik := false ;
44856: LD_ADDR_EXP 112
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// sEarthquake := false ;
44864: LD_ADDR_EXP 114
44868: PUSH
44869: LD_INT 0
44871: ST_TO_ADDR
// sAI := false ;
44872: LD_ADDR_EXP 115
44876: PUSH
44877: LD_INT 0
44879: ST_TO_ADDR
// sCargo := false ;
44880: LD_ADDR_EXP 118
44884: PUSH
44885: LD_INT 0
44887: ST_TO_ADDR
// sDLaser := false ;
44888: LD_ADDR_EXP 119
44892: PUSH
44893: LD_INT 0
44895: ST_TO_ADDR
// sExchange := false ;
44896: LD_ADDR_EXP 120
44900: PUSH
44901: LD_INT 0
44903: ST_TO_ADDR
// sFac := false ;
44904: LD_ADDR_EXP 121
44908: PUSH
44909: LD_INT 0
44911: ST_TO_ADDR
// sPower := false ;
44912: LD_ADDR_EXP 122
44916: PUSH
44917: LD_INT 0
44919: ST_TO_ADDR
// sRandom := false ;
44920: LD_ADDR_EXP 123
44924: PUSH
44925: LD_INT 0
44927: ST_TO_ADDR
// sShield := false ;
44928: LD_ADDR_EXP 124
44932: PUSH
44933: LD_INT 0
44935: ST_TO_ADDR
// sTime := false ;
44936: LD_ADDR_EXP 125
44940: PUSH
44941: LD_INT 0
44943: ST_TO_ADDR
// sTools := false ;
44944: LD_ADDR_EXP 126
44948: PUSH
44949: LD_INT 0
44951: ST_TO_ADDR
// sSold := false ;
44952: LD_ADDR_EXP 91
44956: PUSH
44957: LD_INT 0
44959: ST_TO_ADDR
// sDiff := false ;
44960: LD_ADDR_EXP 92
44964: PUSH
44965: LD_INT 0
44967: ST_TO_ADDR
// sFog := false ;
44968: LD_ADDR_EXP 95
44972: PUSH
44973: LD_INT 0
44975: ST_TO_ADDR
// sReset := false ;
44976: LD_ADDR_EXP 96
44980: PUSH
44981: LD_INT 0
44983: ST_TO_ADDR
// sSun := false ;
44984: LD_ADDR_EXP 97
44988: PUSH
44989: LD_INT 0
44991: ST_TO_ADDR
// sTiger := false ;
44992: LD_ADDR_EXP 93
44996: PUSH
44997: LD_INT 0
44999: ST_TO_ADDR
// sBomb := false ;
45000: LD_ADDR_EXP 94
45004: PUSH
45005: LD_INT 0
45007: ST_TO_ADDR
// sWound := false ;
45008: LD_ADDR_EXP 102
45012: PUSH
45013: LD_INT 0
45015: ST_TO_ADDR
// sBetray := false ;
45016: LD_ADDR_EXP 106
45020: PUSH
45021: LD_INT 0
45023: ST_TO_ADDR
// sContamin := false ;
45024: LD_ADDR_EXP 107
45028: PUSH
45029: LD_INT 0
45031: ST_TO_ADDR
// sOil := false ;
45032: LD_ADDR_EXP 109
45036: PUSH
45037: LD_INT 0
45039: ST_TO_ADDR
// sStu := false ;
45040: LD_ADDR_EXP 113
45044: PUSH
45045: LD_INT 0
45047: ST_TO_ADDR
// sBazooka := false ;
45048: LD_ADDR_EXP 116
45052: PUSH
45053: LD_INT 0
45055: ST_TO_ADDR
// sMortar := false ;
45056: LD_ADDR_EXP 117
45060: PUSH
45061: LD_INT 0
45063: ST_TO_ADDR
// sRanger := false ;
45064: LD_ADDR_EXP 127
45068: PUSH
45069: LD_INT 0
45071: ST_TO_ADDR
// sComputer := false ;
45072: LD_ADDR_EXP 128
45076: PUSH
45077: LD_INT 0
45079: ST_TO_ADDR
// s30 := false ;
45080: LD_ADDR_EXP 129
45084: PUSH
45085: LD_INT 0
45087: ST_TO_ADDR
// s60 := false ;
45088: LD_ADDR_EXP 130
45092: PUSH
45093: LD_INT 0
45095: ST_TO_ADDR
// end ;
45096: LD_VAR 0 1
45100: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
45101: LD_INT 0
45103: PPUSH
45104: PPUSH
45105: PPUSH
45106: PPUSH
45107: PPUSH
45108: PPUSH
45109: PPUSH
// result := [ ] ;
45110: LD_ADDR_VAR 0 2
45114: PUSH
45115: EMPTY
45116: ST_TO_ADDR
// if campaign_id = 1 then
45117: LD_OWVAR 69
45121: PUSH
45122: LD_INT 1
45124: EQUAL
45125: IFFALSE 48291
// begin case mission_number of 1 :
45127: LD_OWVAR 70
45131: PUSH
45132: LD_INT 1
45134: DOUBLE
45135: EQUAL
45136: IFTRUE 45140
45138: GO 45216
45140: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45141: LD_ADDR_VAR 0 2
45145: PUSH
45146: LD_INT 2
45148: PUSH
45149: LD_INT 4
45151: PUSH
45152: LD_INT 11
45154: PUSH
45155: LD_INT 12
45157: PUSH
45158: LD_INT 15
45160: PUSH
45161: LD_INT 16
45163: PUSH
45164: LD_INT 22
45166: PUSH
45167: LD_INT 23
45169: PUSH
45170: LD_INT 26
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: PUSH
45184: LD_INT 101
45186: PUSH
45187: LD_INT 102
45189: PUSH
45190: LD_INT 106
45192: PUSH
45193: LD_INT 116
45195: PUSH
45196: LD_INT 117
45198: PUSH
45199: LD_INT 118
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: ST_TO_ADDR
45214: GO 48289
45216: LD_INT 2
45218: DOUBLE
45219: EQUAL
45220: IFTRUE 45224
45222: GO 45308
45224: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45225: LD_ADDR_VAR 0 2
45229: PUSH
45230: LD_INT 2
45232: PUSH
45233: LD_INT 4
45235: PUSH
45236: LD_INT 11
45238: PUSH
45239: LD_INT 12
45241: PUSH
45242: LD_INT 15
45244: PUSH
45245: LD_INT 16
45247: PUSH
45248: LD_INT 22
45250: PUSH
45251: LD_INT 23
45253: PUSH
45254: LD_INT 26
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 101
45270: PUSH
45271: LD_INT 102
45273: PUSH
45274: LD_INT 105
45276: PUSH
45277: LD_INT 106
45279: PUSH
45280: LD_INT 108
45282: PUSH
45283: LD_INT 116
45285: PUSH
45286: LD_INT 117
45288: PUSH
45289: LD_INT 118
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: ST_TO_ADDR
45306: GO 48289
45308: LD_INT 3
45310: DOUBLE
45311: EQUAL
45312: IFTRUE 45316
45314: GO 45404
45316: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45317: LD_ADDR_VAR 0 2
45321: PUSH
45322: LD_INT 2
45324: PUSH
45325: LD_INT 4
45327: PUSH
45328: LD_INT 5
45330: PUSH
45331: LD_INT 11
45333: PUSH
45334: LD_INT 12
45336: PUSH
45337: LD_INT 15
45339: PUSH
45340: LD_INT 16
45342: PUSH
45343: LD_INT 22
45345: PUSH
45346: LD_INT 26
45348: PUSH
45349: LD_INT 36
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 101
45366: PUSH
45367: LD_INT 102
45369: PUSH
45370: LD_INT 105
45372: PUSH
45373: LD_INT 106
45375: PUSH
45376: LD_INT 108
45378: PUSH
45379: LD_INT 116
45381: PUSH
45382: LD_INT 117
45384: PUSH
45385: LD_INT 118
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: ST_TO_ADDR
45402: GO 48289
45404: LD_INT 4
45406: DOUBLE
45407: EQUAL
45408: IFTRUE 45412
45410: GO 45508
45412: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45413: LD_ADDR_VAR 0 2
45417: PUSH
45418: LD_INT 2
45420: PUSH
45421: LD_INT 4
45423: PUSH
45424: LD_INT 5
45426: PUSH
45427: LD_INT 8
45429: PUSH
45430: LD_INT 11
45432: PUSH
45433: LD_INT 12
45435: PUSH
45436: LD_INT 15
45438: PUSH
45439: LD_INT 16
45441: PUSH
45442: LD_INT 22
45444: PUSH
45445: LD_INT 23
45447: PUSH
45448: LD_INT 26
45450: PUSH
45451: LD_INT 36
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: PUSH
45468: LD_INT 101
45470: PUSH
45471: LD_INT 102
45473: PUSH
45474: LD_INT 105
45476: PUSH
45477: LD_INT 106
45479: PUSH
45480: LD_INT 108
45482: PUSH
45483: LD_INT 116
45485: PUSH
45486: LD_INT 117
45488: PUSH
45489: LD_INT 118
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: ST_TO_ADDR
45506: GO 48289
45508: LD_INT 5
45510: DOUBLE
45511: EQUAL
45512: IFTRUE 45516
45514: GO 45628
45516: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45517: LD_ADDR_VAR 0 2
45521: PUSH
45522: LD_INT 2
45524: PUSH
45525: LD_INT 4
45527: PUSH
45528: LD_INT 5
45530: PUSH
45531: LD_INT 6
45533: PUSH
45534: LD_INT 8
45536: PUSH
45537: LD_INT 11
45539: PUSH
45540: LD_INT 12
45542: PUSH
45543: LD_INT 15
45545: PUSH
45546: LD_INT 16
45548: PUSH
45549: LD_INT 22
45551: PUSH
45552: LD_INT 23
45554: PUSH
45555: LD_INT 25
45557: PUSH
45558: LD_INT 26
45560: PUSH
45561: LD_INT 36
45563: PUSH
45564: EMPTY
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 101
45582: PUSH
45583: LD_INT 102
45585: PUSH
45586: LD_INT 105
45588: PUSH
45589: LD_INT 106
45591: PUSH
45592: LD_INT 108
45594: PUSH
45595: LD_INT 109
45597: PUSH
45598: LD_INT 112
45600: PUSH
45601: LD_INT 116
45603: PUSH
45604: LD_INT 117
45606: PUSH
45607: LD_INT 118
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: ST_TO_ADDR
45626: GO 48289
45628: LD_INT 6
45630: DOUBLE
45631: EQUAL
45632: IFTRUE 45636
45634: GO 45768
45636: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45637: LD_ADDR_VAR 0 2
45641: PUSH
45642: LD_INT 2
45644: PUSH
45645: LD_INT 4
45647: PUSH
45648: LD_INT 5
45650: PUSH
45651: LD_INT 6
45653: PUSH
45654: LD_INT 8
45656: PUSH
45657: LD_INT 11
45659: PUSH
45660: LD_INT 12
45662: PUSH
45663: LD_INT 15
45665: PUSH
45666: LD_INT 16
45668: PUSH
45669: LD_INT 20
45671: PUSH
45672: LD_INT 21
45674: PUSH
45675: LD_INT 22
45677: PUSH
45678: LD_INT 23
45680: PUSH
45681: LD_INT 25
45683: PUSH
45684: LD_INT 26
45686: PUSH
45687: LD_INT 30
45689: PUSH
45690: LD_INT 31
45692: PUSH
45693: LD_INT 32
45695: PUSH
45696: LD_INT 36
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: LIST
45713: LIST
45714: LIST
45715: LIST
45716: LIST
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 101
45722: PUSH
45723: LD_INT 102
45725: PUSH
45726: LD_INT 105
45728: PUSH
45729: LD_INT 106
45731: PUSH
45732: LD_INT 108
45734: PUSH
45735: LD_INT 109
45737: PUSH
45738: LD_INT 112
45740: PUSH
45741: LD_INT 116
45743: PUSH
45744: LD_INT 117
45746: PUSH
45747: LD_INT 118
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: LIST
45760: LIST
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: ST_TO_ADDR
45766: GO 48289
45768: LD_INT 7
45770: DOUBLE
45771: EQUAL
45772: IFTRUE 45776
45774: GO 45888
45776: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45777: LD_ADDR_VAR 0 2
45781: PUSH
45782: LD_INT 2
45784: PUSH
45785: LD_INT 4
45787: PUSH
45788: LD_INT 5
45790: PUSH
45791: LD_INT 7
45793: PUSH
45794: LD_INT 11
45796: PUSH
45797: LD_INT 12
45799: PUSH
45800: LD_INT 15
45802: PUSH
45803: LD_INT 16
45805: PUSH
45806: LD_INT 20
45808: PUSH
45809: LD_INT 21
45811: PUSH
45812: LD_INT 22
45814: PUSH
45815: LD_INT 23
45817: PUSH
45818: LD_INT 25
45820: PUSH
45821: LD_INT 26
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: PUSH
45840: LD_INT 101
45842: PUSH
45843: LD_INT 102
45845: PUSH
45846: LD_INT 103
45848: PUSH
45849: LD_INT 105
45851: PUSH
45852: LD_INT 106
45854: PUSH
45855: LD_INT 108
45857: PUSH
45858: LD_INT 112
45860: PUSH
45861: LD_INT 116
45863: PUSH
45864: LD_INT 117
45866: PUSH
45867: LD_INT 118
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: ST_TO_ADDR
45886: GO 48289
45888: LD_INT 8
45890: DOUBLE
45891: EQUAL
45892: IFTRUE 45896
45894: GO 46036
45896: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45897: LD_ADDR_VAR 0 2
45901: PUSH
45902: LD_INT 2
45904: PUSH
45905: LD_INT 4
45907: PUSH
45908: LD_INT 5
45910: PUSH
45911: LD_INT 6
45913: PUSH
45914: LD_INT 7
45916: PUSH
45917: LD_INT 8
45919: PUSH
45920: LD_INT 11
45922: PUSH
45923: LD_INT 12
45925: PUSH
45926: LD_INT 15
45928: PUSH
45929: LD_INT 16
45931: PUSH
45932: LD_INT 20
45934: PUSH
45935: LD_INT 21
45937: PUSH
45938: LD_INT 22
45940: PUSH
45941: LD_INT 23
45943: PUSH
45944: LD_INT 25
45946: PUSH
45947: LD_INT 26
45949: PUSH
45950: LD_INT 30
45952: PUSH
45953: LD_INT 31
45955: PUSH
45956: LD_INT 32
45958: PUSH
45959: LD_INT 36
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: PUSH
45984: LD_INT 101
45986: PUSH
45987: LD_INT 102
45989: PUSH
45990: LD_INT 103
45992: PUSH
45993: LD_INT 105
45995: PUSH
45996: LD_INT 106
45998: PUSH
45999: LD_INT 108
46001: PUSH
46002: LD_INT 109
46004: PUSH
46005: LD_INT 112
46007: PUSH
46008: LD_INT 116
46010: PUSH
46011: LD_INT 117
46013: PUSH
46014: LD_INT 118
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: ST_TO_ADDR
46034: GO 48289
46036: LD_INT 9
46038: DOUBLE
46039: EQUAL
46040: IFTRUE 46044
46042: GO 46192
46044: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46045: LD_ADDR_VAR 0 2
46049: PUSH
46050: LD_INT 2
46052: PUSH
46053: LD_INT 4
46055: PUSH
46056: LD_INT 5
46058: PUSH
46059: LD_INT 6
46061: PUSH
46062: LD_INT 7
46064: PUSH
46065: LD_INT 8
46067: PUSH
46068: LD_INT 11
46070: PUSH
46071: LD_INT 12
46073: PUSH
46074: LD_INT 15
46076: PUSH
46077: LD_INT 16
46079: PUSH
46080: LD_INT 20
46082: PUSH
46083: LD_INT 21
46085: PUSH
46086: LD_INT 22
46088: PUSH
46089: LD_INT 23
46091: PUSH
46092: LD_INT 25
46094: PUSH
46095: LD_INT 26
46097: PUSH
46098: LD_INT 28
46100: PUSH
46101: LD_INT 30
46103: PUSH
46104: LD_INT 31
46106: PUSH
46107: LD_INT 32
46109: PUSH
46110: LD_INT 36
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: LIST
46117: LIST
46118: LIST
46119: LIST
46120: LIST
46121: LIST
46122: LIST
46123: LIST
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: PUSH
46136: LD_INT 101
46138: PUSH
46139: LD_INT 102
46141: PUSH
46142: LD_INT 103
46144: PUSH
46145: LD_INT 105
46147: PUSH
46148: LD_INT 106
46150: PUSH
46151: LD_INT 108
46153: PUSH
46154: LD_INT 109
46156: PUSH
46157: LD_INT 112
46159: PUSH
46160: LD_INT 114
46162: PUSH
46163: LD_INT 116
46165: PUSH
46166: LD_INT 117
46168: PUSH
46169: LD_INT 118
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: ST_TO_ADDR
46190: GO 48289
46192: LD_INT 10
46194: DOUBLE
46195: EQUAL
46196: IFTRUE 46200
46198: GO 46396
46200: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46201: LD_ADDR_VAR 0 2
46205: PUSH
46206: LD_INT 2
46208: PUSH
46209: LD_INT 4
46211: PUSH
46212: LD_INT 5
46214: PUSH
46215: LD_INT 6
46217: PUSH
46218: LD_INT 7
46220: PUSH
46221: LD_INT 8
46223: PUSH
46224: LD_INT 9
46226: PUSH
46227: LD_INT 10
46229: PUSH
46230: LD_INT 11
46232: PUSH
46233: LD_INT 12
46235: PUSH
46236: LD_INT 13
46238: PUSH
46239: LD_INT 14
46241: PUSH
46242: LD_INT 15
46244: PUSH
46245: LD_INT 16
46247: PUSH
46248: LD_INT 17
46250: PUSH
46251: LD_INT 18
46253: PUSH
46254: LD_INT 19
46256: PUSH
46257: LD_INT 20
46259: PUSH
46260: LD_INT 21
46262: PUSH
46263: LD_INT 22
46265: PUSH
46266: LD_INT 23
46268: PUSH
46269: LD_INT 24
46271: PUSH
46272: LD_INT 25
46274: PUSH
46275: LD_INT 26
46277: PUSH
46278: LD_INT 28
46280: PUSH
46281: LD_INT 30
46283: PUSH
46284: LD_INT 31
46286: PUSH
46287: LD_INT 32
46289: PUSH
46290: LD_INT 36
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 101
46326: PUSH
46327: LD_INT 102
46329: PUSH
46330: LD_INT 103
46332: PUSH
46333: LD_INT 104
46335: PUSH
46336: LD_INT 105
46338: PUSH
46339: LD_INT 106
46341: PUSH
46342: LD_INT 107
46344: PUSH
46345: LD_INT 108
46347: PUSH
46348: LD_INT 109
46350: PUSH
46351: LD_INT 110
46353: PUSH
46354: LD_INT 111
46356: PUSH
46357: LD_INT 112
46359: PUSH
46360: LD_INT 114
46362: PUSH
46363: LD_INT 116
46365: PUSH
46366: LD_INT 117
46368: PUSH
46369: LD_INT 118
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: ST_TO_ADDR
46394: GO 48289
46396: LD_INT 11
46398: DOUBLE
46399: EQUAL
46400: IFTRUE 46404
46402: GO 46608
46404: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46405: LD_ADDR_VAR 0 2
46409: PUSH
46410: LD_INT 2
46412: PUSH
46413: LD_INT 3
46415: PUSH
46416: LD_INT 4
46418: PUSH
46419: LD_INT 5
46421: PUSH
46422: LD_INT 6
46424: PUSH
46425: LD_INT 7
46427: PUSH
46428: LD_INT 8
46430: PUSH
46431: LD_INT 9
46433: PUSH
46434: LD_INT 10
46436: PUSH
46437: LD_INT 11
46439: PUSH
46440: LD_INT 12
46442: PUSH
46443: LD_INT 13
46445: PUSH
46446: LD_INT 14
46448: PUSH
46449: LD_INT 15
46451: PUSH
46452: LD_INT 16
46454: PUSH
46455: LD_INT 17
46457: PUSH
46458: LD_INT 18
46460: PUSH
46461: LD_INT 19
46463: PUSH
46464: LD_INT 20
46466: PUSH
46467: LD_INT 21
46469: PUSH
46470: LD_INT 22
46472: PUSH
46473: LD_INT 23
46475: PUSH
46476: LD_INT 24
46478: PUSH
46479: LD_INT 25
46481: PUSH
46482: LD_INT 26
46484: PUSH
46485: LD_INT 28
46487: PUSH
46488: LD_INT 30
46490: PUSH
46491: LD_INT 31
46493: PUSH
46494: LD_INT 32
46496: PUSH
46497: LD_INT 34
46499: PUSH
46500: LD_INT 36
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: PUSH
46536: LD_INT 101
46538: PUSH
46539: LD_INT 102
46541: PUSH
46542: LD_INT 103
46544: PUSH
46545: LD_INT 104
46547: PUSH
46548: LD_INT 105
46550: PUSH
46551: LD_INT 106
46553: PUSH
46554: LD_INT 107
46556: PUSH
46557: LD_INT 108
46559: PUSH
46560: LD_INT 109
46562: PUSH
46563: LD_INT 110
46565: PUSH
46566: LD_INT 111
46568: PUSH
46569: LD_INT 112
46571: PUSH
46572: LD_INT 114
46574: PUSH
46575: LD_INT 116
46577: PUSH
46578: LD_INT 117
46580: PUSH
46581: LD_INT 118
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: ST_TO_ADDR
46606: GO 48289
46608: LD_INT 12
46610: DOUBLE
46611: EQUAL
46612: IFTRUE 46616
46614: GO 46836
46616: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46617: LD_ADDR_VAR 0 2
46621: PUSH
46622: LD_INT 1
46624: PUSH
46625: LD_INT 2
46627: PUSH
46628: LD_INT 3
46630: PUSH
46631: LD_INT 4
46633: PUSH
46634: LD_INT 5
46636: PUSH
46637: LD_INT 6
46639: PUSH
46640: LD_INT 7
46642: PUSH
46643: LD_INT 8
46645: PUSH
46646: LD_INT 9
46648: PUSH
46649: LD_INT 10
46651: PUSH
46652: LD_INT 11
46654: PUSH
46655: LD_INT 12
46657: PUSH
46658: LD_INT 13
46660: PUSH
46661: LD_INT 14
46663: PUSH
46664: LD_INT 15
46666: PUSH
46667: LD_INT 16
46669: PUSH
46670: LD_INT 17
46672: PUSH
46673: LD_INT 18
46675: PUSH
46676: LD_INT 19
46678: PUSH
46679: LD_INT 20
46681: PUSH
46682: LD_INT 21
46684: PUSH
46685: LD_INT 22
46687: PUSH
46688: LD_INT 23
46690: PUSH
46691: LD_INT 24
46693: PUSH
46694: LD_INT 25
46696: PUSH
46697: LD_INT 26
46699: PUSH
46700: LD_INT 27
46702: PUSH
46703: LD_INT 28
46705: PUSH
46706: LD_INT 30
46708: PUSH
46709: LD_INT 31
46711: PUSH
46712: LD_INT 32
46714: PUSH
46715: LD_INT 33
46717: PUSH
46718: LD_INT 34
46720: PUSH
46721: LD_INT 36
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: PUSH
46760: LD_INT 101
46762: PUSH
46763: LD_INT 102
46765: PUSH
46766: LD_INT 103
46768: PUSH
46769: LD_INT 104
46771: PUSH
46772: LD_INT 105
46774: PUSH
46775: LD_INT 106
46777: PUSH
46778: LD_INT 107
46780: PUSH
46781: LD_INT 108
46783: PUSH
46784: LD_INT 109
46786: PUSH
46787: LD_INT 110
46789: PUSH
46790: LD_INT 111
46792: PUSH
46793: LD_INT 112
46795: PUSH
46796: LD_INT 113
46798: PUSH
46799: LD_INT 114
46801: PUSH
46802: LD_INT 116
46804: PUSH
46805: LD_INT 117
46807: PUSH
46808: LD_INT 118
46810: PUSH
46811: EMPTY
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: ST_TO_ADDR
46834: GO 48289
46836: LD_INT 13
46838: DOUBLE
46839: EQUAL
46840: IFTRUE 46844
46842: GO 47052
46844: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46845: LD_ADDR_VAR 0 2
46849: PUSH
46850: LD_INT 1
46852: PUSH
46853: LD_INT 2
46855: PUSH
46856: LD_INT 3
46858: PUSH
46859: LD_INT 4
46861: PUSH
46862: LD_INT 5
46864: PUSH
46865: LD_INT 8
46867: PUSH
46868: LD_INT 9
46870: PUSH
46871: LD_INT 10
46873: PUSH
46874: LD_INT 11
46876: PUSH
46877: LD_INT 12
46879: PUSH
46880: LD_INT 14
46882: PUSH
46883: LD_INT 15
46885: PUSH
46886: LD_INT 16
46888: PUSH
46889: LD_INT 17
46891: PUSH
46892: LD_INT 18
46894: PUSH
46895: LD_INT 19
46897: PUSH
46898: LD_INT 20
46900: PUSH
46901: LD_INT 21
46903: PUSH
46904: LD_INT 22
46906: PUSH
46907: LD_INT 23
46909: PUSH
46910: LD_INT 24
46912: PUSH
46913: LD_INT 25
46915: PUSH
46916: LD_INT 26
46918: PUSH
46919: LD_INT 27
46921: PUSH
46922: LD_INT 28
46924: PUSH
46925: LD_INT 30
46927: PUSH
46928: LD_INT 31
46930: PUSH
46931: LD_INT 32
46933: PUSH
46934: LD_INT 33
46936: PUSH
46937: LD_INT 34
46939: PUSH
46940: LD_INT 36
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 101
46978: PUSH
46979: LD_INT 102
46981: PUSH
46982: LD_INT 103
46984: PUSH
46985: LD_INT 104
46987: PUSH
46988: LD_INT 105
46990: PUSH
46991: LD_INT 106
46993: PUSH
46994: LD_INT 107
46996: PUSH
46997: LD_INT 108
46999: PUSH
47000: LD_INT 109
47002: PUSH
47003: LD_INT 110
47005: PUSH
47006: LD_INT 111
47008: PUSH
47009: LD_INT 112
47011: PUSH
47012: LD_INT 113
47014: PUSH
47015: LD_INT 114
47017: PUSH
47018: LD_INT 116
47020: PUSH
47021: LD_INT 117
47023: PUSH
47024: LD_INT 118
47026: PUSH
47027: EMPTY
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: ST_TO_ADDR
47050: GO 48289
47052: LD_INT 14
47054: DOUBLE
47055: EQUAL
47056: IFTRUE 47060
47058: GO 47284
47060: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47061: LD_ADDR_VAR 0 2
47065: PUSH
47066: LD_INT 1
47068: PUSH
47069: LD_INT 2
47071: PUSH
47072: LD_INT 3
47074: PUSH
47075: LD_INT 4
47077: PUSH
47078: LD_INT 5
47080: PUSH
47081: LD_INT 6
47083: PUSH
47084: LD_INT 7
47086: PUSH
47087: LD_INT 8
47089: PUSH
47090: LD_INT 9
47092: PUSH
47093: LD_INT 10
47095: PUSH
47096: LD_INT 11
47098: PUSH
47099: LD_INT 12
47101: PUSH
47102: LD_INT 13
47104: PUSH
47105: LD_INT 14
47107: PUSH
47108: LD_INT 15
47110: PUSH
47111: LD_INT 16
47113: PUSH
47114: LD_INT 17
47116: PUSH
47117: LD_INT 18
47119: PUSH
47120: LD_INT 19
47122: PUSH
47123: LD_INT 20
47125: PUSH
47126: LD_INT 21
47128: PUSH
47129: LD_INT 22
47131: PUSH
47132: LD_INT 23
47134: PUSH
47135: LD_INT 24
47137: PUSH
47138: LD_INT 25
47140: PUSH
47141: LD_INT 26
47143: PUSH
47144: LD_INT 27
47146: PUSH
47147: LD_INT 28
47149: PUSH
47150: LD_INT 29
47152: PUSH
47153: LD_INT 30
47155: PUSH
47156: LD_INT 31
47158: PUSH
47159: LD_INT 32
47161: PUSH
47162: LD_INT 33
47164: PUSH
47165: LD_INT 34
47167: PUSH
47168: LD_INT 36
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: LIST
47175: LIST
47176: LIST
47177: LIST
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 101
47210: PUSH
47211: LD_INT 102
47213: PUSH
47214: LD_INT 103
47216: PUSH
47217: LD_INT 104
47219: PUSH
47220: LD_INT 105
47222: PUSH
47223: LD_INT 106
47225: PUSH
47226: LD_INT 107
47228: PUSH
47229: LD_INT 108
47231: PUSH
47232: LD_INT 109
47234: PUSH
47235: LD_INT 110
47237: PUSH
47238: LD_INT 111
47240: PUSH
47241: LD_INT 112
47243: PUSH
47244: LD_INT 113
47246: PUSH
47247: LD_INT 114
47249: PUSH
47250: LD_INT 116
47252: PUSH
47253: LD_INT 117
47255: PUSH
47256: LD_INT 118
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: ST_TO_ADDR
47282: GO 48289
47284: LD_INT 15
47286: DOUBLE
47287: EQUAL
47288: IFTRUE 47292
47290: GO 47516
47292: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47293: LD_ADDR_VAR 0 2
47297: PUSH
47298: LD_INT 1
47300: PUSH
47301: LD_INT 2
47303: PUSH
47304: LD_INT 3
47306: PUSH
47307: LD_INT 4
47309: PUSH
47310: LD_INT 5
47312: PUSH
47313: LD_INT 6
47315: PUSH
47316: LD_INT 7
47318: PUSH
47319: LD_INT 8
47321: PUSH
47322: LD_INT 9
47324: PUSH
47325: LD_INT 10
47327: PUSH
47328: LD_INT 11
47330: PUSH
47331: LD_INT 12
47333: PUSH
47334: LD_INT 13
47336: PUSH
47337: LD_INT 14
47339: PUSH
47340: LD_INT 15
47342: PUSH
47343: LD_INT 16
47345: PUSH
47346: LD_INT 17
47348: PUSH
47349: LD_INT 18
47351: PUSH
47352: LD_INT 19
47354: PUSH
47355: LD_INT 20
47357: PUSH
47358: LD_INT 21
47360: PUSH
47361: LD_INT 22
47363: PUSH
47364: LD_INT 23
47366: PUSH
47367: LD_INT 24
47369: PUSH
47370: LD_INT 25
47372: PUSH
47373: LD_INT 26
47375: PUSH
47376: LD_INT 27
47378: PUSH
47379: LD_INT 28
47381: PUSH
47382: LD_INT 29
47384: PUSH
47385: LD_INT 30
47387: PUSH
47388: LD_INT 31
47390: PUSH
47391: LD_INT 32
47393: PUSH
47394: LD_INT 33
47396: PUSH
47397: LD_INT 34
47399: PUSH
47400: LD_INT 36
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: PUSH
47440: LD_INT 101
47442: PUSH
47443: LD_INT 102
47445: PUSH
47446: LD_INT 103
47448: PUSH
47449: LD_INT 104
47451: PUSH
47452: LD_INT 105
47454: PUSH
47455: LD_INT 106
47457: PUSH
47458: LD_INT 107
47460: PUSH
47461: LD_INT 108
47463: PUSH
47464: LD_INT 109
47466: PUSH
47467: LD_INT 110
47469: PUSH
47470: LD_INT 111
47472: PUSH
47473: LD_INT 112
47475: PUSH
47476: LD_INT 113
47478: PUSH
47479: LD_INT 114
47481: PUSH
47482: LD_INT 116
47484: PUSH
47485: LD_INT 117
47487: PUSH
47488: LD_INT 118
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: PUSH
47510: EMPTY
47511: LIST
47512: LIST
47513: ST_TO_ADDR
47514: GO 48289
47516: LD_INT 16
47518: DOUBLE
47519: EQUAL
47520: IFTRUE 47524
47522: GO 47660
47524: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47525: LD_ADDR_VAR 0 2
47529: PUSH
47530: LD_INT 2
47532: PUSH
47533: LD_INT 4
47535: PUSH
47536: LD_INT 5
47538: PUSH
47539: LD_INT 7
47541: PUSH
47542: LD_INT 11
47544: PUSH
47545: LD_INT 12
47547: PUSH
47548: LD_INT 15
47550: PUSH
47551: LD_INT 16
47553: PUSH
47554: LD_INT 20
47556: PUSH
47557: LD_INT 21
47559: PUSH
47560: LD_INT 22
47562: PUSH
47563: LD_INT 23
47565: PUSH
47566: LD_INT 25
47568: PUSH
47569: LD_INT 26
47571: PUSH
47572: LD_INT 30
47574: PUSH
47575: LD_INT 31
47577: PUSH
47578: LD_INT 32
47580: PUSH
47581: LD_INT 33
47583: PUSH
47584: LD_INT 34
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: LIST
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: LIST
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: PUSH
47608: LD_INT 101
47610: PUSH
47611: LD_INT 102
47613: PUSH
47614: LD_INT 103
47616: PUSH
47617: LD_INT 106
47619: PUSH
47620: LD_INT 108
47622: PUSH
47623: LD_INT 112
47625: PUSH
47626: LD_INT 113
47628: PUSH
47629: LD_INT 114
47631: PUSH
47632: LD_INT 116
47634: PUSH
47635: LD_INT 117
47637: PUSH
47638: LD_INT 118
47640: PUSH
47641: EMPTY
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: PUSH
47654: EMPTY
47655: LIST
47656: LIST
47657: ST_TO_ADDR
47658: GO 48289
47660: LD_INT 17
47662: DOUBLE
47663: EQUAL
47664: IFTRUE 47668
47666: GO 47892
47668: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47669: LD_ADDR_VAR 0 2
47673: PUSH
47674: LD_INT 1
47676: PUSH
47677: LD_INT 2
47679: PUSH
47680: LD_INT 3
47682: PUSH
47683: LD_INT 4
47685: PUSH
47686: LD_INT 5
47688: PUSH
47689: LD_INT 6
47691: PUSH
47692: LD_INT 7
47694: PUSH
47695: LD_INT 8
47697: PUSH
47698: LD_INT 9
47700: PUSH
47701: LD_INT 10
47703: PUSH
47704: LD_INT 11
47706: PUSH
47707: LD_INT 12
47709: PUSH
47710: LD_INT 13
47712: PUSH
47713: LD_INT 14
47715: PUSH
47716: LD_INT 15
47718: PUSH
47719: LD_INT 16
47721: PUSH
47722: LD_INT 17
47724: PUSH
47725: LD_INT 18
47727: PUSH
47728: LD_INT 19
47730: PUSH
47731: LD_INT 20
47733: PUSH
47734: LD_INT 21
47736: PUSH
47737: LD_INT 22
47739: PUSH
47740: LD_INT 23
47742: PUSH
47743: LD_INT 24
47745: PUSH
47746: LD_INT 25
47748: PUSH
47749: LD_INT 26
47751: PUSH
47752: LD_INT 27
47754: PUSH
47755: LD_INT 28
47757: PUSH
47758: LD_INT 29
47760: PUSH
47761: LD_INT 30
47763: PUSH
47764: LD_INT 31
47766: PUSH
47767: LD_INT 32
47769: PUSH
47770: LD_INT 33
47772: PUSH
47773: LD_INT 34
47775: PUSH
47776: LD_INT 36
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: LIST
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: PUSH
47816: LD_INT 101
47818: PUSH
47819: LD_INT 102
47821: PUSH
47822: LD_INT 103
47824: PUSH
47825: LD_INT 104
47827: PUSH
47828: LD_INT 105
47830: PUSH
47831: LD_INT 106
47833: PUSH
47834: LD_INT 107
47836: PUSH
47837: LD_INT 108
47839: PUSH
47840: LD_INT 109
47842: PUSH
47843: LD_INT 110
47845: PUSH
47846: LD_INT 111
47848: PUSH
47849: LD_INT 112
47851: PUSH
47852: LD_INT 113
47854: PUSH
47855: LD_INT 114
47857: PUSH
47858: LD_INT 116
47860: PUSH
47861: LD_INT 117
47863: PUSH
47864: LD_INT 118
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: PUSH
47886: EMPTY
47887: LIST
47888: LIST
47889: ST_TO_ADDR
47890: GO 48289
47892: LD_INT 18
47894: DOUBLE
47895: EQUAL
47896: IFTRUE 47900
47898: GO 48048
47900: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47901: LD_ADDR_VAR 0 2
47905: PUSH
47906: LD_INT 2
47908: PUSH
47909: LD_INT 4
47911: PUSH
47912: LD_INT 5
47914: PUSH
47915: LD_INT 7
47917: PUSH
47918: LD_INT 11
47920: PUSH
47921: LD_INT 12
47923: PUSH
47924: LD_INT 15
47926: PUSH
47927: LD_INT 16
47929: PUSH
47930: LD_INT 20
47932: PUSH
47933: LD_INT 21
47935: PUSH
47936: LD_INT 22
47938: PUSH
47939: LD_INT 23
47941: PUSH
47942: LD_INT 25
47944: PUSH
47945: LD_INT 26
47947: PUSH
47948: LD_INT 30
47950: PUSH
47951: LD_INT 31
47953: PUSH
47954: LD_INT 32
47956: PUSH
47957: LD_INT 33
47959: PUSH
47960: LD_INT 34
47962: PUSH
47963: LD_INT 35
47965: PUSH
47966: LD_INT 36
47968: PUSH
47969: EMPTY
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: PUSH
47992: LD_INT 101
47994: PUSH
47995: LD_INT 102
47997: PUSH
47998: LD_INT 103
48000: PUSH
48001: LD_INT 106
48003: PUSH
48004: LD_INT 108
48006: PUSH
48007: LD_INT 112
48009: PUSH
48010: LD_INT 113
48012: PUSH
48013: LD_INT 114
48015: PUSH
48016: LD_INT 115
48018: PUSH
48019: LD_INT 116
48021: PUSH
48022: LD_INT 117
48024: PUSH
48025: LD_INT 118
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: ST_TO_ADDR
48046: GO 48289
48048: LD_INT 19
48050: DOUBLE
48051: EQUAL
48052: IFTRUE 48056
48054: GO 48288
48056: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48057: LD_ADDR_VAR 0 2
48061: PUSH
48062: LD_INT 1
48064: PUSH
48065: LD_INT 2
48067: PUSH
48068: LD_INT 3
48070: PUSH
48071: LD_INT 4
48073: PUSH
48074: LD_INT 5
48076: PUSH
48077: LD_INT 6
48079: PUSH
48080: LD_INT 7
48082: PUSH
48083: LD_INT 8
48085: PUSH
48086: LD_INT 9
48088: PUSH
48089: LD_INT 10
48091: PUSH
48092: LD_INT 11
48094: PUSH
48095: LD_INT 12
48097: PUSH
48098: LD_INT 13
48100: PUSH
48101: LD_INT 14
48103: PUSH
48104: LD_INT 15
48106: PUSH
48107: LD_INT 16
48109: PUSH
48110: LD_INT 17
48112: PUSH
48113: LD_INT 18
48115: PUSH
48116: LD_INT 19
48118: PUSH
48119: LD_INT 20
48121: PUSH
48122: LD_INT 21
48124: PUSH
48125: LD_INT 22
48127: PUSH
48128: LD_INT 23
48130: PUSH
48131: LD_INT 24
48133: PUSH
48134: LD_INT 25
48136: PUSH
48137: LD_INT 26
48139: PUSH
48140: LD_INT 27
48142: PUSH
48143: LD_INT 28
48145: PUSH
48146: LD_INT 29
48148: PUSH
48149: LD_INT 30
48151: PUSH
48152: LD_INT 31
48154: PUSH
48155: LD_INT 32
48157: PUSH
48158: LD_INT 33
48160: PUSH
48161: LD_INT 34
48163: PUSH
48164: LD_INT 35
48166: PUSH
48167: LD_INT 36
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: LIST
48197: LIST
48198: LIST
48199: LIST
48200: LIST
48201: LIST
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 101
48210: PUSH
48211: LD_INT 102
48213: PUSH
48214: LD_INT 103
48216: PUSH
48217: LD_INT 104
48219: PUSH
48220: LD_INT 105
48222: PUSH
48223: LD_INT 106
48225: PUSH
48226: LD_INT 107
48228: PUSH
48229: LD_INT 108
48231: PUSH
48232: LD_INT 109
48234: PUSH
48235: LD_INT 110
48237: PUSH
48238: LD_INT 111
48240: PUSH
48241: LD_INT 112
48243: PUSH
48244: LD_INT 113
48246: PUSH
48247: LD_INT 114
48249: PUSH
48250: LD_INT 115
48252: PUSH
48253: LD_INT 116
48255: PUSH
48256: LD_INT 117
48258: PUSH
48259: LD_INT 118
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: PUSH
48282: EMPTY
48283: LIST
48284: LIST
48285: ST_TO_ADDR
48286: GO 48289
48288: POP
// end else
48289: GO 48520
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48291: LD_ADDR_VAR 0 2
48295: PUSH
48296: LD_INT 1
48298: PUSH
48299: LD_INT 2
48301: PUSH
48302: LD_INT 3
48304: PUSH
48305: LD_INT 4
48307: PUSH
48308: LD_INT 5
48310: PUSH
48311: LD_INT 6
48313: PUSH
48314: LD_INT 7
48316: PUSH
48317: LD_INT 8
48319: PUSH
48320: LD_INT 9
48322: PUSH
48323: LD_INT 10
48325: PUSH
48326: LD_INT 11
48328: PUSH
48329: LD_INT 12
48331: PUSH
48332: LD_INT 13
48334: PUSH
48335: LD_INT 14
48337: PUSH
48338: LD_INT 15
48340: PUSH
48341: LD_INT 16
48343: PUSH
48344: LD_INT 17
48346: PUSH
48347: LD_INT 18
48349: PUSH
48350: LD_INT 19
48352: PUSH
48353: LD_INT 20
48355: PUSH
48356: LD_INT 21
48358: PUSH
48359: LD_INT 22
48361: PUSH
48362: LD_INT 23
48364: PUSH
48365: LD_INT 24
48367: PUSH
48368: LD_INT 25
48370: PUSH
48371: LD_INT 26
48373: PUSH
48374: LD_INT 27
48376: PUSH
48377: LD_INT 28
48379: PUSH
48380: LD_INT 29
48382: PUSH
48383: LD_INT 30
48385: PUSH
48386: LD_INT 31
48388: PUSH
48389: LD_INT 32
48391: PUSH
48392: LD_INT 33
48394: PUSH
48395: LD_INT 34
48397: PUSH
48398: LD_INT 35
48400: PUSH
48401: LD_INT 36
48403: PUSH
48404: EMPTY
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 101
48444: PUSH
48445: LD_INT 102
48447: PUSH
48448: LD_INT 103
48450: PUSH
48451: LD_INT 104
48453: PUSH
48454: LD_INT 105
48456: PUSH
48457: LD_INT 106
48459: PUSH
48460: LD_INT 107
48462: PUSH
48463: LD_INT 108
48465: PUSH
48466: LD_INT 109
48468: PUSH
48469: LD_INT 110
48471: PUSH
48472: LD_INT 111
48474: PUSH
48475: LD_INT 112
48477: PUSH
48478: LD_INT 113
48480: PUSH
48481: LD_INT 114
48483: PUSH
48484: LD_INT 115
48486: PUSH
48487: LD_INT 116
48489: PUSH
48490: LD_INT 117
48492: PUSH
48493: LD_INT 118
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: LIST
48505: LIST
48506: LIST
48507: LIST
48508: LIST
48509: LIST
48510: LIST
48511: LIST
48512: LIST
48513: LIST
48514: LIST
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: ST_TO_ADDR
// if result then
48520: LD_VAR 0 2
48524: IFFALSE 49310
// begin normal :=  ;
48526: LD_ADDR_VAR 0 5
48530: PUSH
48531: LD_STRING 
48533: ST_TO_ADDR
// hardcore :=  ;
48534: LD_ADDR_VAR 0 6
48538: PUSH
48539: LD_STRING 
48541: ST_TO_ADDR
// active :=  ;
48542: LD_ADDR_VAR 0 7
48546: PUSH
48547: LD_STRING 
48549: ST_TO_ADDR
// for i = 1 to normalCounter do
48550: LD_ADDR_VAR 0 8
48554: PUSH
48555: DOUBLE
48556: LD_INT 1
48558: DEC
48559: ST_TO_ADDR
48560: LD_EXP 75
48564: PUSH
48565: FOR_TO
48566: IFFALSE 48667
// begin tmp := 0 ;
48568: LD_ADDR_VAR 0 3
48572: PUSH
48573: LD_STRING 0
48575: ST_TO_ADDR
// if result [ 1 ] then
48576: LD_VAR 0 2
48580: PUSH
48581: LD_INT 1
48583: ARRAY
48584: IFFALSE 48649
// if result [ 1 ] [ 1 ] = i then
48586: LD_VAR 0 2
48590: PUSH
48591: LD_INT 1
48593: ARRAY
48594: PUSH
48595: LD_INT 1
48597: ARRAY
48598: PUSH
48599: LD_VAR 0 8
48603: EQUAL
48604: IFFALSE 48649
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48606: LD_ADDR_VAR 0 2
48610: PUSH
48611: LD_VAR 0 2
48615: PPUSH
48616: LD_INT 1
48618: PPUSH
48619: LD_VAR 0 2
48623: PUSH
48624: LD_INT 1
48626: ARRAY
48627: PPUSH
48628: LD_INT 1
48630: PPUSH
48631: CALL_OW 3
48635: PPUSH
48636: CALL_OW 1
48640: ST_TO_ADDR
// tmp := 1 ;
48641: LD_ADDR_VAR 0 3
48645: PUSH
48646: LD_STRING 1
48648: ST_TO_ADDR
// end ; normal := normal & tmp ;
48649: LD_ADDR_VAR 0 5
48653: PUSH
48654: LD_VAR 0 5
48658: PUSH
48659: LD_VAR 0 3
48663: STR
48664: ST_TO_ADDR
// end ;
48665: GO 48565
48667: POP
48668: POP
// for i = 1 to hardcoreCounter do
48669: LD_ADDR_VAR 0 8
48673: PUSH
48674: DOUBLE
48675: LD_INT 1
48677: DEC
48678: ST_TO_ADDR
48679: LD_EXP 76
48683: PUSH
48684: FOR_TO
48685: IFFALSE 48790
// begin tmp := 0 ;
48687: LD_ADDR_VAR 0 3
48691: PUSH
48692: LD_STRING 0
48694: ST_TO_ADDR
// if result [ 2 ] then
48695: LD_VAR 0 2
48699: PUSH
48700: LD_INT 2
48702: ARRAY
48703: IFFALSE 48772
// if result [ 2 ] [ 1 ] = 100 + i then
48705: LD_VAR 0 2
48709: PUSH
48710: LD_INT 2
48712: ARRAY
48713: PUSH
48714: LD_INT 1
48716: ARRAY
48717: PUSH
48718: LD_INT 100
48720: PUSH
48721: LD_VAR 0 8
48725: PLUS
48726: EQUAL
48727: IFFALSE 48772
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48729: LD_ADDR_VAR 0 2
48733: PUSH
48734: LD_VAR 0 2
48738: PPUSH
48739: LD_INT 2
48741: PPUSH
48742: LD_VAR 0 2
48746: PUSH
48747: LD_INT 2
48749: ARRAY
48750: PPUSH
48751: LD_INT 1
48753: PPUSH
48754: CALL_OW 3
48758: PPUSH
48759: CALL_OW 1
48763: ST_TO_ADDR
// tmp := 1 ;
48764: LD_ADDR_VAR 0 3
48768: PUSH
48769: LD_STRING 1
48771: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48772: LD_ADDR_VAR 0 6
48776: PUSH
48777: LD_VAR 0 6
48781: PUSH
48782: LD_VAR 0 3
48786: STR
48787: ST_TO_ADDR
// end ;
48788: GO 48684
48790: POP
48791: POP
// if isGameLoad then
48792: LD_VAR 0 1
48796: IFFALSE 49271
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48798: LD_ADDR_VAR 0 4
48802: PUSH
48803: LD_EXP 79
48807: PUSH
48808: LD_EXP 78
48812: PUSH
48813: LD_EXP 80
48817: PUSH
48818: LD_EXP 77
48822: PUSH
48823: LD_EXP 81
48827: PUSH
48828: LD_EXP 82
48832: PUSH
48833: LD_EXP 83
48837: PUSH
48838: LD_EXP 84
48842: PUSH
48843: LD_EXP 85
48847: PUSH
48848: LD_EXP 86
48852: PUSH
48853: LD_EXP 87
48857: PUSH
48858: LD_EXP 88
48862: PUSH
48863: LD_EXP 89
48867: PUSH
48868: LD_EXP 90
48872: PUSH
48873: LD_EXP 98
48877: PUSH
48878: LD_EXP 99
48882: PUSH
48883: LD_EXP 100
48887: PUSH
48888: LD_EXP 101
48892: PUSH
48893: LD_EXP 103
48897: PUSH
48898: LD_EXP 104
48902: PUSH
48903: LD_EXP 105
48907: PUSH
48908: LD_EXP 108
48912: PUSH
48913: LD_EXP 110
48917: PUSH
48918: LD_EXP 111
48922: PUSH
48923: LD_EXP 112
48927: PUSH
48928: LD_EXP 114
48932: PUSH
48933: LD_EXP 115
48937: PUSH
48938: LD_EXP 118
48942: PUSH
48943: LD_EXP 119
48947: PUSH
48948: LD_EXP 120
48952: PUSH
48953: LD_EXP 121
48957: PUSH
48958: LD_EXP 122
48962: PUSH
48963: LD_EXP 123
48967: PUSH
48968: LD_EXP 124
48972: PUSH
48973: LD_EXP 125
48977: PUSH
48978: LD_EXP 126
48982: PUSH
48983: LD_EXP 91
48987: PUSH
48988: LD_EXP 92
48992: PUSH
48993: LD_EXP 95
48997: PUSH
48998: LD_EXP 96
49002: PUSH
49003: LD_EXP 97
49007: PUSH
49008: LD_EXP 93
49012: PUSH
49013: LD_EXP 94
49017: PUSH
49018: LD_EXP 102
49022: PUSH
49023: LD_EXP 106
49027: PUSH
49028: LD_EXP 107
49032: PUSH
49033: LD_EXP 109
49037: PUSH
49038: LD_EXP 113
49042: PUSH
49043: LD_EXP 116
49047: PUSH
49048: LD_EXP 117
49052: PUSH
49053: LD_EXP 127
49057: PUSH
49058: LD_EXP 128
49062: PUSH
49063: LD_EXP 129
49067: PUSH
49068: LD_EXP 130
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: ST_TO_ADDR
// tmp :=  ;
49129: LD_ADDR_VAR 0 3
49133: PUSH
49134: LD_STRING 
49136: ST_TO_ADDR
// for i = 1 to normalCounter do
49137: LD_ADDR_VAR 0 8
49141: PUSH
49142: DOUBLE
49143: LD_INT 1
49145: DEC
49146: ST_TO_ADDR
49147: LD_EXP 75
49151: PUSH
49152: FOR_TO
49153: IFFALSE 49189
// begin if flags [ i ] then
49155: LD_VAR 0 4
49159: PUSH
49160: LD_VAR 0 8
49164: ARRAY
49165: IFFALSE 49187
// tmp := tmp & i & ; ;
49167: LD_ADDR_VAR 0 3
49171: PUSH
49172: LD_VAR 0 3
49176: PUSH
49177: LD_VAR 0 8
49181: STR
49182: PUSH
49183: LD_STRING ;
49185: STR
49186: ST_TO_ADDR
// end ;
49187: GO 49152
49189: POP
49190: POP
// for i = 1 to hardcoreCounter do
49191: LD_ADDR_VAR 0 8
49195: PUSH
49196: DOUBLE
49197: LD_INT 1
49199: DEC
49200: ST_TO_ADDR
49201: LD_EXP 76
49205: PUSH
49206: FOR_TO
49207: IFFALSE 49253
// begin if flags [ normalCounter + i ] then
49209: LD_VAR 0 4
49213: PUSH
49214: LD_EXP 75
49218: PUSH
49219: LD_VAR 0 8
49223: PLUS
49224: ARRAY
49225: IFFALSE 49251
// tmp := tmp & ( 100 + i ) & ; ;
49227: LD_ADDR_VAR 0 3
49231: PUSH
49232: LD_VAR 0 3
49236: PUSH
49237: LD_INT 100
49239: PUSH
49240: LD_VAR 0 8
49244: PLUS
49245: STR
49246: PUSH
49247: LD_STRING ;
49249: STR
49250: ST_TO_ADDR
// end ;
49251: GO 49206
49253: POP
49254: POP
// if tmp then
49255: LD_VAR 0 3
49259: IFFALSE 49271
// active := tmp ;
49261: LD_ADDR_VAR 0 7
49265: PUSH
49266: LD_VAR 0 3
49270: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49271: LD_STRING getStreamItemsFromMission("
49273: PUSH
49274: LD_VAR 0 5
49278: STR
49279: PUSH
49280: LD_STRING ","
49282: STR
49283: PUSH
49284: LD_VAR 0 6
49288: STR
49289: PUSH
49290: LD_STRING ","
49292: STR
49293: PUSH
49294: LD_VAR 0 7
49298: STR
49299: PUSH
49300: LD_STRING ")
49302: STR
49303: PPUSH
49304: CALL_OW 559
// end else
49308: GO 49317
// ToLua ( getStreamItemsFromMission("","","") ) ;
49310: LD_STRING getStreamItemsFromMission("","","")
49312: PPUSH
49313: CALL_OW 559
// end ;
49317: LD_VAR 0 2
49321: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49322: LD_EXP 74
49326: PUSH
49327: LD_EXP 79
49331: AND
49332: IFFALSE 49456
49334: GO 49336
49336: DISABLE
49337: LD_INT 0
49339: PPUSH
49340: PPUSH
// begin enable ;
49341: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49342: LD_ADDR_VAR 0 2
49346: PUSH
49347: LD_INT 22
49349: PUSH
49350: LD_OWVAR 2
49354: PUSH
49355: EMPTY
49356: LIST
49357: LIST
49358: PUSH
49359: LD_INT 2
49361: PUSH
49362: LD_INT 34
49364: PUSH
49365: LD_INT 7
49367: PUSH
49368: EMPTY
49369: LIST
49370: LIST
49371: PUSH
49372: LD_INT 34
49374: PUSH
49375: LD_INT 45
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 34
49384: PUSH
49385: LD_INT 28
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 34
49394: PUSH
49395: LD_INT 47
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: PPUSH
49413: CALL_OW 69
49417: ST_TO_ADDR
// if not tmp then
49418: LD_VAR 0 2
49422: NOT
49423: IFFALSE 49427
// exit ;
49425: GO 49456
// for i in tmp do
49427: LD_ADDR_VAR 0 1
49431: PUSH
49432: LD_VAR 0 2
49436: PUSH
49437: FOR_IN
49438: IFFALSE 49454
// begin SetLives ( i , 0 ) ;
49440: LD_VAR 0 1
49444: PPUSH
49445: LD_INT 0
49447: PPUSH
49448: CALL_OW 234
// end ;
49452: GO 49437
49454: POP
49455: POP
// end ;
49456: PPOPN 2
49458: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49459: LD_EXP 74
49463: PUSH
49464: LD_EXP 80
49468: AND
49469: IFFALSE 49553
49471: GO 49473
49473: DISABLE
49474: LD_INT 0
49476: PPUSH
49477: PPUSH
// begin enable ;
49478: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49479: LD_ADDR_VAR 0 2
49483: PUSH
49484: LD_INT 22
49486: PUSH
49487: LD_OWVAR 2
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 32
49498: PUSH
49499: LD_INT 3
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PPUSH
49510: CALL_OW 69
49514: ST_TO_ADDR
// if not tmp then
49515: LD_VAR 0 2
49519: NOT
49520: IFFALSE 49524
// exit ;
49522: GO 49553
// for i in tmp do
49524: LD_ADDR_VAR 0 1
49528: PUSH
49529: LD_VAR 0 2
49533: PUSH
49534: FOR_IN
49535: IFFALSE 49551
// begin SetLives ( i , 0 ) ;
49537: LD_VAR 0 1
49541: PPUSH
49542: LD_INT 0
49544: PPUSH
49545: CALL_OW 234
// end ;
49549: GO 49534
49551: POP
49552: POP
// end ;
49553: PPOPN 2
49555: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49556: LD_EXP 74
49560: PUSH
49561: LD_EXP 77
49565: AND
49566: IFFALSE 49659
49568: GO 49570
49570: DISABLE
49571: LD_INT 0
49573: PPUSH
// begin enable ;
49574: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49575: LD_ADDR_VAR 0 1
49579: PUSH
49580: LD_INT 22
49582: PUSH
49583: LD_OWVAR 2
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: PUSH
49592: LD_INT 2
49594: PUSH
49595: LD_INT 25
49597: PUSH
49598: LD_INT 5
49600: PUSH
49601: EMPTY
49602: LIST
49603: LIST
49604: PUSH
49605: LD_INT 25
49607: PUSH
49608: LD_INT 9
49610: PUSH
49611: EMPTY
49612: LIST
49613: LIST
49614: PUSH
49615: LD_INT 25
49617: PUSH
49618: LD_INT 8
49620: PUSH
49621: EMPTY
49622: LIST
49623: LIST
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: PUSH
49631: EMPTY
49632: LIST
49633: LIST
49634: PPUSH
49635: CALL_OW 69
49639: PUSH
49640: FOR_IN
49641: IFFALSE 49657
// begin SetClass ( i , 1 ) ;
49643: LD_VAR 0 1
49647: PPUSH
49648: LD_INT 1
49650: PPUSH
49651: CALL_OW 336
// end ;
49655: GO 49640
49657: POP
49658: POP
// end ;
49659: PPOPN 1
49661: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49662: LD_EXP 74
49666: PUSH
49667: LD_EXP 78
49671: AND
49672: PUSH
49673: LD_OWVAR 65
49677: PUSH
49678: LD_INT 7
49680: LESS
49681: AND
49682: IFFALSE 49696
49684: GO 49686
49686: DISABLE
// begin enable ;
49687: ENABLE
// game_speed := 7 ;
49688: LD_ADDR_OWVAR 65
49692: PUSH
49693: LD_INT 7
49695: ST_TO_ADDR
// end ;
49696: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49697: LD_EXP 74
49701: PUSH
49702: LD_EXP 81
49706: AND
49707: IFFALSE 49909
49709: GO 49711
49711: DISABLE
49712: LD_INT 0
49714: PPUSH
49715: PPUSH
49716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49717: LD_ADDR_VAR 0 3
49721: PUSH
49722: LD_INT 81
49724: PUSH
49725: LD_OWVAR 2
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: PUSH
49734: LD_INT 21
49736: PUSH
49737: LD_INT 1
49739: PUSH
49740: EMPTY
49741: LIST
49742: LIST
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: PPUSH
49748: CALL_OW 69
49752: ST_TO_ADDR
// if not tmp then
49753: LD_VAR 0 3
49757: NOT
49758: IFFALSE 49762
// exit ;
49760: GO 49909
// if tmp > 5 then
49762: LD_VAR 0 3
49766: PUSH
49767: LD_INT 5
49769: GREATER
49770: IFFALSE 49782
// k := 5 else
49772: LD_ADDR_VAR 0 2
49776: PUSH
49777: LD_INT 5
49779: ST_TO_ADDR
49780: GO 49792
// k := tmp ;
49782: LD_ADDR_VAR 0 2
49786: PUSH
49787: LD_VAR 0 3
49791: ST_TO_ADDR
// for i := 1 to k do
49792: LD_ADDR_VAR 0 1
49796: PUSH
49797: DOUBLE
49798: LD_INT 1
49800: DEC
49801: ST_TO_ADDR
49802: LD_VAR 0 2
49806: PUSH
49807: FOR_TO
49808: IFFALSE 49907
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49810: LD_VAR 0 3
49814: PUSH
49815: LD_VAR 0 1
49819: ARRAY
49820: PPUSH
49821: LD_VAR 0 1
49825: PUSH
49826: LD_INT 4
49828: MOD
49829: PUSH
49830: LD_INT 1
49832: PLUS
49833: PPUSH
49834: CALL_OW 259
49838: PUSH
49839: LD_INT 10
49841: LESS
49842: IFFALSE 49905
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49844: LD_VAR 0 3
49848: PUSH
49849: LD_VAR 0 1
49853: ARRAY
49854: PPUSH
49855: LD_VAR 0 1
49859: PUSH
49860: LD_INT 4
49862: MOD
49863: PUSH
49864: LD_INT 1
49866: PLUS
49867: PPUSH
49868: LD_VAR 0 3
49872: PUSH
49873: LD_VAR 0 1
49877: ARRAY
49878: PPUSH
49879: LD_VAR 0 1
49883: PUSH
49884: LD_INT 4
49886: MOD
49887: PUSH
49888: LD_INT 1
49890: PLUS
49891: PPUSH
49892: CALL_OW 259
49896: PUSH
49897: LD_INT 1
49899: PLUS
49900: PPUSH
49901: CALL_OW 237
49905: GO 49807
49907: POP
49908: POP
// end ;
49909: PPOPN 3
49911: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49912: LD_EXP 74
49916: PUSH
49917: LD_EXP 82
49921: AND
49922: IFFALSE 49942
49924: GO 49926
49926: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49927: LD_INT 4
49929: PPUSH
49930: LD_OWVAR 2
49934: PPUSH
49935: LD_INT 0
49937: PPUSH
49938: CALL_OW 324
49942: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49943: LD_EXP 74
49947: PUSH
49948: LD_EXP 111
49952: AND
49953: IFFALSE 49973
49955: GO 49957
49957: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49958: LD_INT 19
49960: PPUSH
49961: LD_OWVAR 2
49965: PPUSH
49966: LD_INT 0
49968: PPUSH
49969: CALL_OW 324
49973: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49974: LD_EXP 74
49978: PUSH
49979: LD_EXP 83
49983: AND
49984: IFFALSE 50086
49986: GO 49988
49988: DISABLE
49989: LD_INT 0
49991: PPUSH
49992: PPUSH
// begin enable ;
49993: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49994: LD_ADDR_VAR 0 2
49998: PUSH
49999: LD_INT 22
50001: PUSH
50002: LD_OWVAR 2
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: PUSH
50011: LD_INT 2
50013: PUSH
50014: LD_INT 34
50016: PUSH
50017: LD_INT 11
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: PUSH
50024: LD_INT 34
50026: PUSH
50027: LD_INT 30
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: PUSH
50034: EMPTY
50035: LIST
50036: LIST
50037: LIST
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PPUSH
50043: CALL_OW 69
50047: ST_TO_ADDR
// if not tmp then
50048: LD_VAR 0 2
50052: NOT
50053: IFFALSE 50057
// exit ;
50055: GO 50086
// for i in tmp do
50057: LD_ADDR_VAR 0 1
50061: PUSH
50062: LD_VAR 0 2
50066: PUSH
50067: FOR_IN
50068: IFFALSE 50084
// begin SetLives ( i , 0 ) ;
50070: LD_VAR 0 1
50074: PPUSH
50075: LD_INT 0
50077: PPUSH
50078: CALL_OW 234
// end ;
50082: GO 50067
50084: POP
50085: POP
// end ;
50086: PPOPN 2
50088: END
// every 0 0$1 trigger StreamModeActive and sBunker do
50089: LD_EXP 74
50093: PUSH
50094: LD_EXP 84
50098: AND
50099: IFFALSE 50119
50101: GO 50103
50103: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
50104: LD_INT 32
50106: PPUSH
50107: LD_OWVAR 2
50111: PPUSH
50112: LD_INT 0
50114: PPUSH
50115: CALL_OW 324
50119: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
50120: LD_EXP 74
50124: PUSH
50125: LD_EXP 85
50129: AND
50130: IFFALSE 50311
50132: GO 50134
50134: DISABLE
50135: LD_INT 0
50137: PPUSH
50138: PPUSH
50139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50140: LD_ADDR_VAR 0 2
50144: PUSH
50145: LD_INT 22
50147: PUSH
50148: LD_OWVAR 2
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: PUSH
50157: LD_INT 33
50159: PUSH
50160: LD_INT 3
50162: PUSH
50163: EMPTY
50164: LIST
50165: LIST
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PPUSH
50171: CALL_OW 69
50175: ST_TO_ADDR
// if not tmp then
50176: LD_VAR 0 2
50180: NOT
50181: IFFALSE 50185
// exit ;
50183: GO 50311
// side := 0 ;
50185: LD_ADDR_VAR 0 3
50189: PUSH
50190: LD_INT 0
50192: ST_TO_ADDR
// for i := 1 to 8 do
50193: LD_ADDR_VAR 0 1
50197: PUSH
50198: DOUBLE
50199: LD_INT 1
50201: DEC
50202: ST_TO_ADDR
50203: LD_INT 8
50205: PUSH
50206: FOR_TO
50207: IFFALSE 50255
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50209: LD_OWVAR 2
50213: PUSH
50214: LD_VAR 0 1
50218: NONEQUAL
50219: PUSH
50220: LD_OWVAR 2
50224: PPUSH
50225: LD_VAR 0 1
50229: PPUSH
50230: CALL_OW 81
50234: PUSH
50235: LD_INT 2
50237: EQUAL
50238: AND
50239: IFFALSE 50253
// begin side := i ;
50241: LD_ADDR_VAR 0 3
50245: PUSH
50246: LD_VAR 0 1
50250: ST_TO_ADDR
// break ;
50251: GO 50255
// end ;
50253: GO 50206
50255: POP
50256: POP
// if not side then
50257: LD_VAR 0 3
50261: NOT
50262: IFFALSE 50266
// exit ;
50264: GO 50311
// for i := 1 to tmp do
50266: LD_ADDR_VAR 0 1
50270: PUSH
50271: DOUBLE
50272: LD_INT 1
50274: DEC
50275: ST_TO_ADDR
50276: LD_VAR 0 2
50280: PUSH
50281: FOR_TO
50282: IFFALSE 50309
// if Prob ( 60 ) then
50284: LD_INT 60
50286: PPUSH
50287: CALL_OW 13
50291: IFFALSE 50307
// SetSide ( i , side ) ;
50293: LD_VAR 0 1
50297: PPUSH
50298: LD_VAR 0 3
50302: PPUSH
50303: CALL_OW 235
50307: GO 50281
50309: POP
50310: POP
// end ;
50311: PPOPN 3
50313: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50314: LD_EXP 74
50318: PUSH
50319: LD_EXP 87
50323: AND
50324: IFFALSE 50443
50326: GO 50328
50328: DISABLE
50329: LD_INT 0
50331: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50332: LD_ADDR_VAR 0 1
50336: PUSH
50337: LD_INT 22
50339: PUSH
50340: LD_OWVAR 2
50344: PUSH
50345: EMPTY
50346: LIST
50347: LIST
50348: PUSH
50349: LD_INT 21
50351: PUSH
50352: LD_INT 1
50354: PUSH
50355: EMPTY
50356: LIST
50357: LIST
50358: PUSH
50359: LD_INT 3
50361: PUSH
50362: LD_INT 23
50364: PUSH
50365: LD_INT 0
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: EMPTY
50377: LIST
50378: LIST
50379: LIST
50380: PPUSH
50381: CALL_OW 69
50385: PUSH
50386: FOR_IN
50387: IFFALSE 50441
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50389: LD_VAR 0 1
50393: PPUSH
50394: CALL_OW 257
50398: PUSH
50399: LD_INT 1
50401: PUSH
50402: LD_INT 2
50404: PUSH
50405: LD_INT 3
50407: PUSH
50408: LD_INT 4
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: LIST
50415: LIST
50416: IN
50417: IFFALSE 50439
// SetClass ( un , rand ( 1 , 4 ) ) ;
50419: LD_VAR 0 1
50423: PPUSH
50424: LD_INT 1
50426: PPUSH
50427: LD_INT 4
50429: PPUSH
50430: CALL_OW 12
50434: PPUSH
50435: CALL_OW 336
50439: GO 50386
50441: POP
50442: POP
// end ;
50443: PPOPN 1
50445: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50446: LD_EXP 74
50450: PUSH
50451: LD_EXP 86
50455: AND
50456: IFFALSE 50535
50458: GO 50460
50460: DISABLE
50461: LD_INT 0
50463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50464: LD_ADDR_VAR 0 1
50468: PUSH
50469: LD_INT 22
50471: PUSH
50472: LD_OWVAR 2
50476: PUSH
50477: EMPTY
50478: LIST
50479: LIST
50480: PUSH
50481: LD_INT 21
50483: PUSH
50484: LD_INT 3
50486: PUSH
50487: EMPTY
50488: LIST
50489: LIST
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PPUSH
50495: CALL_OW 69
50499: ST_TO_ADDR
// if not tmp then
50500: LD_VAR 0 1
50504: NOT
50505: IFFALSE 50509
// exit ;
50507: GO 50535
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50509: LD_VAR 0 1
50513: PUSH
50514: LD_INT 1
50516: PPUSH
50517: LD_VAR 0 1
50521: PPUSH
50522: CALL_OW 12
50526: ARRAY
50527: PPUSH
50528: LD_INT 100
50530: PPUSH
50531: CALL_OW 234
// end ;
50535: PPOPN 1
50537: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50538: LD_EXP 74
50542: PUSH
50543: LD_EXP 88
50547: AND
50548: IFFALSE 50646
50550: GO 50552
50552: DISABLE
50553: LD_INT 0
50555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50556: LD_ADDR_VAR 0 1
50560: PUSH
50561: LD_INT 22
50563: PUSH
50564: LD_OWVAR 2
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: PUSH
50573: LD_INT 21
50575: PUSH
50576: LD_INT 1
50578: PUSH
50579: EMPTY
50580: LIST
50581: LIST
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: PPUSH
50587: CALL_OW 69
50591: ST_TO_ADDR
// if not tmp then
50592: LD_VAR 0 1
50596: NOT
50597: IFFALSE 50601
// exit ;
50599: GO 50646
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50601: LD_VAR 0 1
50605: PUSH
50606: LD_INT 1
50608: PPUSH
50609: LD_VAR 0 1
50613: PPUSH
50614: CALL_OW 12
50618: ARRAY
50619: PPUSH
50620: LD_INT 1
50622: PPUSH
50623: LD_INT 4
50625: PPUSH
50626: CALL_OW 12
50630: PPUSH
50631: LD_INT 3000
50633: PPUSH
50634: LD_INT 9000
50636: PPUSH
50637: CALL_OW 12
50641: PPUSH
50642: CALL_OW 492
// end ;
50646: PPOPN 1
50648: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50649: LD_EXP 74
50653: PUSH
50654: LD_EXP 89
50658: AND
50659: IFFALSE 50679
50661: GO 50663
50663: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50664: LD_INT 1
50666: PPUSH
50667: LD_OWVAR 2
50671: PPUSH
50672: LD_INT 0
50674: PPUSH
50675: CALL_OW 324
50679: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50680: LD_EXP 74
50684: PUSH
50685: LD_EXP 90
50689: AND
50690: IFFALSE 50773
50692: GO 50694
50694: DISABLE
50695: LD_INT 0
50697: PPUSH
50698: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50699: LD_ADDR_VAR 0 2
50703: PUSH
50704: LD_INT 22
50706: PUSH
50707: LD_OWVAR 2
50711: PUSH
50712: EMPTY
50713: LIST
50714: LIST
50715: PUSH
50716: LD_INT 21
50718: PUSH
50719: LD_INT 3
50721: PUSH
50722: EMPTY
50723: LIST
50724: LIST
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: PPUSH
50730: CALL_OW 69
50734: ST_TO_ADDR
// if not tmp then
50735: LD_VAR 0 2
50739: NOT
50740: IFFALSE 50744
// exit ;
50742: GO 50773
// for i in tmp do
50744: LD_ADDR_VAR 0 1
50748: PUSH
50749: LD_VAR 0 2
50753: PUSH
50754: FOR_IN
50755: IFFALSE 50771
// SetBLevel ( i , 10 ) ;
50757: LD_VAR 0 1
50761: PPUSH
50762: LD_INT 10
50764: PPUSH
50765: CALL_OW 241
50769: GO 50754
50771: POP
50772: POP
// end ;
50773: PPOPN 2
50775: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50776: LD_EXP 74
50780: PUSH
50781: LD_EXP 91
50785: AND
50786: IFFALSE 50897
50788: GO 50790
50790: DISABLE
50791: LD_INT 0
50793: PPUSH
50794: PPUSH
50795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50796: LD_ADDR_VAR 0 3
50800: PUSH
50801: LD_INT 22
50803: PUSH
50804: LD_OWVAR 2
50808: PUSH
50809: EMPTY
50810: LIST
50811: LIST
50812: PUSH
50813: LD_INT 25
50815: PUSH
50816: LD_INT 1
50818: PUSH
50819: EMPTY
50820: LIST
50821: LIST
50822: PUSH
50823: EMPTY
50824: LIST
50825: LIST
50826: PPUSH
50827: CALL_OW 69
50831: ST_TO_ADDR
// if not tmp then
50832: LD_VAR 0 3
50836: NOT
50837: IFFALSE 50841
// exit ;
50839: GO 50897
// un := tmp [ rand ( 1 , tmp ) ] ;
50841: LD_ADDR_VAR 0 2
50845: PUSH
50846: LD_VAR 0 3
50850: PUSH
50851: LD_INT 1
50853: PPUSH
50854: LD_VAR 0 3
50858: PPUSH
50859: CALL_OW 12
50863: ARRAY
50864: ST_TO_ADDR
// if Crawls ( un ) then
50865: LD_VAR 0 2
50869: PPUSH
50870: CALL_OW 318
50874: IFFALSE 50885
// ComWalk ( un ) ;
50876: LD_VAR 0 2
50880: PPUSH
50881: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50885: LD_VAR 0 2
50889: PPUSH
50890: LD_INT 5
50892: PPUSH
50893: CALL_OW 336
// end ;
50897: PPOPN 3
50899: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50900: LD_EXP 74
50904: PUSH
50905: LD_EXP 92
50909: AND
50910: PUSH
50911: LD_OWVAR 67
50915: PUSH
50916: LD_INT 4
50918: LESS
50919: AND
50920: IFFALSE 50939
50922: GO 50924
50924: DISABLE
// begin Difficulty := Difficulty + 1 ;
50925: LD_ADDR_OWVAR 67
50929: PUSH
50930: LD_OWVAR 67
50934: PUSH
50935: LD_INT 1
50937: PLUS
50938: ST_TO_ADDR
// end ;
50939: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50940: LD_EXP 74
50944: PUSH
50945: LD_EXP 93
50949: AND
50950: IFFALSE 51053
50952: GO 50954
50954: DISABLE
50955: LD_INT 0
50957: PPUSH
// begin for i := 1 to 5 do
50958: LD_ADDR_VAR 0 1
50962: PUSH
50963: DOUBLE
50964: LD_INT 1
50966: DEC
50967: ST_TO_ADDR
50968: LD_INT 5
50970: PUSH
50971: FOR_TO
50972: IFFALSE 51051
// begin uc_nation := nation_nature ;
50974: LD_ADDR_OWVAR 21
50978: PUSH
50979: LD_INT 0
50981: ST_TO_ADDR
// uc_side := 0 ;
50982: LD_ADDR_OWVAR 20
50986: PUSH
50987: LD_INT 0
50989: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50990: LD_ADDR_OWVAR 29
50994: PUSH
50995: LD_INT 12
50997: PUSH
50998: LD_INT 12
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: ST_TO_ADDR
// hc_agressivity := 20 ;
51005: LD_ADDR_OWVAR 35
51009: PUSH
51010: LD_INT 20
51012: ST_TO_ADDR
// hc_class := class_tiger ;
51013: LD_ADDR_OWVAR 28
51017: PUSH
51018: LD_INT 14
51020: ST_TO_ADDR
// hc_gallery :=  ;
51021: LD_ADDR_OWVAR 33
51025: PUSH
51026: LD_STRING 
51028: ST_TO_ADDR
// hc_name :=  ;
51029: LD_ADDR_OWVAR 26
51033: PUSH
51034: LD_STRING 
51036: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
51037: CALL_OW 44
51041: PPUSH
51042: LD_INT 0
51044: PPUSH
51045: CALL_OW 51
// end ;
51049: GO 50971
51051: POP
51052: POP
// end ;
51053: PPOPN 1
51055: END
// every 0 0$1 trigger StreamModeActive and sBomb do
51056: LD_EXP 74
51060: PUSH
51061: LD_EXP 94
51065: AND
51066: IFFALSE 51075
51068: GO 51070
51070: DISABLE
// StreamSibBomb ;
51071: CALL 51076 0 0
51075: END
// export function StreamSibBomb ; var i , x , y ; begin
51076: LD_INT 0
51078: PPUSH
51079: PPUSH
51080: PPUSH
51081: PPUSH
// result := false ;
51082: LD_ADDR_VAR 0 1
51086: PUSH
51087: LD_INT 0
51089: ST_TO_ADDR
// for i := 1 to 16 do
51090: LD_ADDR_VAR 0 2
51094: PUSH
51095: DOUBLE
51096: LD_INT 1
51098: DEC
51099: ST_TO_ADDR
51100: LD_INT 16
51102: PUSH
51103: FOR_TO
51104: IFFALSE 51303
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51106: LD_ADDR_VAR 0 3
51110: PUSH
51111: LD_INT 10
51113: PUSH
51114: LD_INT 20
51116: PUSH
51117: LD_INT 30
51119: PUSH
51120: LD_INT 40
51122: PUSH
51123: LD_INT 50
51125: PUSH
51126: LD_INT 60
51128: PUSH
51129: LD_INT 70
51131: PUSH
51132: LD_INT 80
51134: PUSH
51135: LD_INT 90
51137: PUSH
51138: LD_INT 100
51140: PUSH
51141: LD_INT 110
51143: PUSH
51144: LD_INT 120
51146: PUSH
51147: LD_INT 130
51149: PUSH
51150: LD_INT 140
51152: PUSH
51153: LD_INT 150
51155: PUSH
51156: EMPTY
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: PUSH
51173: LD_INT 1
51175: PPUSH
51176: LD_INT 15
51178: PPUSH
51179: CALL_OW 12
51183: ARRAY
51184: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51185: LD_ADDR_VAR 0 4
51189: PUSH
51190: LD_INT 10
51192: PUSH
51193: LD_INT 20
51195: PUSH
51196: LD_INT 30
51198: PUSH
51199: LD_INT 40
51201: PUSH
51202: LD_INT 50
51204: PUSH
51205: LD_INT 60
51207: PUSH
51208: LD_INT 70
51210: PUSH
51211: LD_INT 80
51213: PUSH
51214: LD_INT 90
51216: PUSH
51217: LD_INT 100
51219: PUSH
51220: LD_INT 110
51222: PUSH
51223: LD_INT 120
51225: PUSH
51226: LD_INT 130
51228: PUSH
51229: LD_INT 140
51231: PUSH
51232: LD_INT 150
51234: PUSH
51235: EMPTY
51236: LIST
51237: LIST
51238: LIST
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: LIST
51248: LIST
51249: LIST
51250: LIST
51251: PUSH
51252: LD_INT 1
51254: PPUSH
51255: LD_INT 15
51257: PPUSH
51258: CALL_OW 12
51262: ARRAY
51263: ST_TO_ADDR
// if ValidHex ( x , y ) then
51264: LD_VAR 0 3
51268: PPUSH
51269: LD_VAR 0 4
51273: PPUSH
51274: CALL_OW 488
51278: IFFALSE 51301
// begin result := [ x , y ] ;
51280: LD_ADDR_VAR 0 1
51284: PUSH
51285: LD_VAR 0 3
51289: PUSH
51290: LD_VAR 0 4
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: ST_TO_ADDR
// break ;
51299: GO 51303
// end ; end ;
51301: GO 51103
51303: POP
51304: POP
// if result then
51305: LD_VAR 0 1
51309: IFFALSE 51369
// begin ToLua ( playSibBomb() ) ;
51311: LD_STRING playSibBomb()
51313: PPUSH
51314: CALL_OW 559
// wait ( 0 0$14 ) ;
51318: LD_INT 490
51320: PPUSH
51321: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51325: LD_VAR 0 1
51329: PUSH
51330: LD_INT 1
51332: ARRAY
51333: PPUSH
51334: LD_VAR 0 1
51338: PUSH
51339: LD_INT 2
51341: ARRAY
51342: PPUSH
51343: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51347: LD_VAR 0 1
51351: PUSH
51352: LD_INT 1
51354: ARRAY
51355: PPUSH
51356: LD_VAR 0 1
51360: PUSH
51361: LD_INT 2
51363: ARRAY
51364: PPUSH
51365: CALL_OW 429
// end ; end ;
51369: LD_VAR 0 1
51373: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51374: LD_EXP 74
51378: PUSH
51379: LD_EXP 96
51383: AND
51384: IFFALSE 51396
51386: GO 51388
51388: DISABLE
// YouLost (  ) ;
51389: LD_STRING 
51391: PPUSH
51392: CALL_OW 104
51396: END
// every 0 0$1 trigger StreamModeActive and sFog do
51397: LD_EXP 74
51401: PUSH
51402: LD_EXP 95
51406: AND
51407: IFFALSE 51421
51409: GO 51411
51411: DISABLE
// FogOff ( your_side ) ;
51412: LD_OWVAR 2
51416: PPUSH
51417: CALL_OW 344
51421: END
// every 0 0$1 trigger StreamModeActive and sSun do
51422: LD_EXP 74
51426: PUSH
51427: LD_EXP 97
51431: AND
51432: IFFALSE 51460
51434: GO 51436
51436: DISABLE
// begin solar_recharge_percent := 0 ;
51437: LD_ADDR_OWVAR 79
51441: PUSH
51442: LD_INT 0
51444: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51445: LD_INT 10500
51447: PPUSH
51448: CALL_OW 67
// solar_recharge_percent := 100 ;
51452: LD_ADDR_OWVAR 79
51456: PUSH
51457: LD_INT 100
51459: ST_TO_ADDR
// end ;
51460: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51461: LD_EXP 74
51465: PUSH
51466: LD_EXP 98
51470: AND
51471: IFFALSE 51710
51473: GO 51475
51475: DISABLE
51476: LD_INT 0
51478: PPUSH
51479: PPUSH
51480: PPUSH
// begin tmp := [ ] ;
51481: LD_ADDR_VAR 0 3
51485: PUSH
51486: EMPTY
51487: ST_TO_ADDR
// for i := 1 to 6 do
51488: LD_ADDR_VAR 0 1
51492: PUSH
51493: DOUBLE
51494: LD_INT 1
51496: DEC
51497: ST_TO_ADDR
51498: LD_INT 6
51500: PUSH
51501: FOR_TO
51502: IFFALSE 51607
// begin uc_nation := nation_nature ;
51504: LD_ADDR_OWVAR 21
51508: PUSH
51509: LD_INT 0
51511: ST_TO_ADDR
// uc_side := 0 ;
51512: LD_ADDR_OWVAR 20
51516: PUSH
51517: LD_INT 0
51519: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51520: LD_ADDR_OWVAR 29
51524: PUSH
51525: LD_INT 12
51527: PUSH
51528: LD_INT 12
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: ST_TO_ADDR
// hc_agressivity := 20 ;
51535: LD_ADDR_OWVAR 35
51539: PUSH
51540: LD_INT 20
51542: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51543: LD_ADDR_OWVAR 28
51547: PUSH
51548: LD_INT 17
51550: ST_TO_ADDR
// hc_gallery :=  ;
51551: LD_ADDR_OWVAR 33
51555: PUSH
51556: LD_STRING 
51558: ST_TO_ADDR
// hc_name :=  ;
51559: LD_ADDR_OWVAR 26
51563: PUSH
51564: LD_STRING 
51566: ST_TO_ADDR
// un := CreateHuman ;
51567: LD_ADDR_VAR 0 2
51571: PUSH
51572: CALL_OW 44
51576: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51577: LD_VAR 0 2
51581: PPUSH
51582: LD_INT 1
51584: PPUSH
51585: CALL_OW 51
// tmp := tmp ^ un ;
51589: LD_ADDR_VAR 0 3
51593: PUSH
51594: LD_VAR 0 3
51598: PUSH
51599: LD_VAR 0 2
51603: ADD
51604: ST_TO_ADDR
// end ;
51605: GO 51501
51607: POP
51608: POP
// repeat wait ( 0 0$1 ) ;
51609: LD_INT 35
51611: PPUSH
51612: CALL_OW 67
// for un in tmp do
51616: LD_ADDR_VAR 0 2
51620: PUSH
51621: LD_VAR 0 3
51625: PUSH
51626: FOR_IN
51627: IFFALSE 51701
// begin if IsDead ( un ) then
51629: LD_VAR 0 2
51633: PPUSH
51634: CALL_OW 301
51638: IFFALSE 51658
// begin tmp := tmp diff un ;
51640: LD_ADDR_VAR 0 3
51644: PUSH
51645: LD_VAR 0 3
51649: PUSH
51650: LD_VAR 0 2
51654: DIFF
51655: ST_TO_ADDR
// continue ;
51656: GO 51626
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51658: LD_VAR 0 2
51662: PPUSH
51663: LD_INT 3
51665: PUSH
51666: LD_INT 22
51668: PUSH
51669: LD_INT 0
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PPUSH
51680: CALL_OW 69
51684: PPUSH
51685: LD_VAR 0 2
51689: PPUSH
51690: CALL_OW 74
51694: PPUSH
51695: CALL_OW 115
// end ;
51699: GO 51626
51701: POP
51702: POP
// until not tmp ;
51703: LD_VAR 0 3
51707: NOT
51708: IFFALSE 51609
// end ;
51710: PPOPN 3
51712: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51713: LD_EXP 74
51717: PUSH
51718: LD_EXP 99
51722: AND
51723: IFFALSE 51777
51725: GO 51727
51727: DISABLE
// begin ToLua ( displayTroll(); ) ;
51728: LD_STRING displayTroll();
51730: PPUSH
51731: CALL_OW 559
// wait ( 3 3$00 ) ;
51735: LD_INT 6300
51737: PPUSH
51738: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51742: LD_STRING hideTroll();
51744: PPUSH
51745: CALL_OW 559
// wait ( 1 1$00 ) ;
51749: LD_INT 2100
51751: PPUSH
51752: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51756: LD_STRING displayTroll();
51758: PPUSH
51759: CALL_OW 559
// wait ( 1 1$00 ) ;
51763: LD_INT 2100
51765: PPUSH
51766: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51770: LD_STRING hideTroll();
51772: PPUSH
51773: CALL_OW 559
// end ;
51777: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51778: LD_EXP 74
51782: PUSH
51783: LD_EXP 100
51787: AND
51788: IFFALSE 51851
51790: GO 51792
51792: DISABLE
51793: LD_INT 0
51795: PPUSH
// begin p := 0 ;
51796: LD_ADDR_VAR 0 1
51800: PUSH
51801: LD_INT 0
51803: ST_TO_ADDR
// repeat game_speed := 1 ;
51804: LD_ADDR_OWVAR 65
51808: PUSH
51809: LD_INT 1
51811: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51812: LD_INT 35
51814: PPUSH
51815: CALL_OW 67
// p := p + 1 ;
51819: LD_ADDR_VAR 0 1
51823: PUSH
51824: LD_VAR 0 1
51828: PUSH
51829: LD_INT 1
51831: PLUS
51832: ST_TO_ADDR
// until p >= 60 ;
51833: LD_VAR 0 1
51837: PUSH
51838: LD_INT 60
51840: GREATEREQUAL
51841: IFFALSE 51804
// game_speed := 4 ;
51843: LD_ADDR_OWVAR 65
51847: PUSH
51848: LD_INT 4
51850: ST_TO_ADDR
// end ;
51851: PPOPN 1
51853: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51854: LD_EXP 74
51858: PUSH
51859: LD_EXP 101
51863: AND
51864: IFFALSE 52010
51866: GO 51868
51868: DISABLE
51869: LD_INT 0
51871: PPUSH
51872: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51873: LD_ADDR_VAR 0 1
51877: PUSH
51878: LD_INT 22
51880: PUSH
51881: LD_OWVAR 2
51885: PUSH
51886: EMPTY
51887: LIST
51888: LIST
51889: PUSH
51890: LD_INT 2
51892: PUSH
51893: LD_INT 30
51895: PUSH
51896: LD_INT 0
51898: PUSH
51899: EMPTY
51900: LIST
51901: LIST
51902: PUSH
51903: LD_INT 30
51905: PUSH
51906: LD_INT 1
51908: PUSH
51909: EMPTY
51910: LIST
51911: LIST
51912: PUSH
51913: EMPTY
51914: LIST
51915: LIST
51916: LIST
51917: PUSH
51918: EMPTY
51919: LIST
51920: LIST
51921: PPUSH
51922: CALL_OW 69
51926: ST_TO_ADDR
// if not depot then
51927: LD_VAR 0 1
51931: NOT
51932: IFFALSE 51936
// exit ;
51934: GO 52010
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51936: LD_ADDR_VAR 0 2
51940: PUSH
51941: LD_VAR 0 1
51945: PUSH
51946: LD_INT 1
51948: PPUSH
51949: LD_VAR 0 1
51953: PPUSH
51954: CALL_OW 12
51958: ARRAY
51959: PPUSH
51960: CALL_OW 274
51964: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51965: LD_VAR 0 2
51969: PPUSH
51970: LD_INT 1
51972: PPUSH
51973: LD_INT 0
51975: PPUSH
51976: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51980: LD_VAR 0 2
51984: PPUSH
51985: LD_INT 2
51987: PPUSH
51988: LD_INT 0
51990: PPUSH
51991: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51995: LD_VAR 0 2
51999: PPUSH
52000: LD_INT 3
52002: PPUSH
52003: LD_INT 0
52005: PPUSH
52006: CALL_OW 277
// end ;
52010: PPOPN 2
52012: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
52013: LD_EXP 74
52017: PUSH
52018: LD_EXP 102
52022: AND
52023: IFFALSE 52120
52025: GO 52027
52027: DISABLE
52028: LD_INT 0
52030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
52031: LD_ADDR_VAR 0 1
52035: PUSH
52036: LD_INT 22
52038: PUSH
52039: LD_OWVAR 2
52043: PUSH
52044: EMPTY
52045: LIST
52046: LIST
52047: PUSH
52048: LD_INT 21
52050: PUSH
52051: LD_INT 1
52053: PUSH
52054: EMPTY
52055: LIST
52056: LIST
52057: PUSH
52058: LD_INT 3
52060: PUSH
52061: LD_INT 23
52063: PUSH
52064: LD_INT 0
52066: PUSH
52067: EMPTY
52068: LIST
52069: LIST
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: PUSH
52075: EMPTY
52076: LIST
52077: LIST
52078: LIST
52079: PPUSH
52080: CALL_OW 69
52084: ST_TO_ADDR
// if not tmp then
52085: LD_VAR 0 1
52089: NOT
52090: IFFALSE 52094
// exit ;
52092: GO 52120
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
52094: LD_VAR 0 1
52098: PUSH
52099: LD_INT 1
52101: PPUSH
52102: LD_VAR 0 1
52106: PPUSH
52107: CALL_OW 12
52111: ARRAY
52112: PPUSH
52113: LD_INT 200
52115: PPUSH
52116: CALL_OW 234
// end ;
52120: PPOPN 1
52122: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
52123: LD_EXP 74
52127: PUSH
52128: LD_EXP 103
52132: AND
52133: IFFALSE 52212
52135: GO 52137
52137: DISABLE
52138: LD_INT 0
52140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52141: LD_ADDR_VAR 0 1
52145: PUSH
52146: LD_INT 22
52148: PUSH
52149: LD_OWVAR 2
52153: PUSH
52154: EMPTY
52155: LIST
52156: LIST
52157: PUSH
52158: LD_INT 21
52160: PUSH
52161: LD_INT 2
52163: PUSH
52164: EMPTY
52165: LIST
52166: LIST
52167: PUSH
52168: EMPTY
52169: LIST
52170: LIST
52171: PPUSH
52172: CALL_OW 69
52176: ST_TO_ADDR
// if not tmp then
52177: LD_VAR 0 1
52181: NOT
52182: IFFALSE 52186
// exit ;
52184: GO 52212
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52186: LD_VAR 0 1
52190: PUSH
52191: LD_INT 1
52193: PPUSH
52194: LD_VAR 0 1
52198: PPUSH
52199: CALL_OW 12
52203: ARRAY
52204: PPUSH
52205: LD_INT 60
52207: PPUSH
52208: CALL_OW 234
// end ;
52212: PPOPN 1
52214: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52215: LD_EXP 74
52219: PUSH
52220: LD_EXP 104
52224: AND
52225: IFFALSE 52324
52227: GO 52229
52229: DISABLE
52230: LD_INT 0
52232: PPUSH
52233: PPUSH
// begin enable ;
52234: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52235: LD_ADDR_VAR 0 1
52239: PUSH
52240: LD_INT 22
52242: PUSH
52243: LD_OWVAR 2
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: PUSH
52252: LD_INT 61
52254: PUSH
52255: EMPTY
52256: LIST
52257: PUSH
52258: LD_INT 33
52260: PUSH
52261: LD_INT 2
52263: PUSH
52264: EMPTY
52265: LIST
52266: LIST
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: LIST
52272: PPUSH
52273: CALL_OW 69
52277: ST_TO_ADDR
// if not tmp then
52278: LD_VAR 0 1
52282: NOT
52283: IFFALSE 52287
// exit ;
52285: GO 52324
// for i in tmp do
52287: LD_ADDR_VAR 0 2
52291: PUSH
52292: LD_VAR 0 1
52296: PUSH
52297: FOR_IN
52298: IFFALSE 52322
// if IsControledBy ( i ) then
52300: LD_VAR 0 2
52304: PPUSH
52305: CALL_OW 312
52309: IFFALSE 52320
// ComUnlink ( i ) ;
52311: LD_VAR 0 2
52315: PPUSH
52316: CALL_OW 136
52320: GO 52297
52322: POP
52323: POP
// end ;
52324: PPOPN 2
52326: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52327: LD_EXP 74
52331: PUSH
52332: LD_EXP 105
52336: AND
52337: IFFALSE 52477
52339: GO 52341
52341: DISABLE
52342: LD_INT 0
52344: PPUSH
52345: PPUSH
// begin ToLua ( displayPowell(); ) ;
52346: LD_STRING displayPowell();
52348: PPUSH
52349: CALL_OW 559
// uc_side := 0 ;
52353: LD_ADDR_OWVAR 20
52357: PUSH
52358: LD_INT 0
52360: ST_TO_ADDR
// uc_nation := 2 ;
52361: LD_ADDR_OWVAR 21
52365: PUSH
52366: LD_INT 2
52368: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52369: LD_ADDR_OWVAR 37
52373: PUSH
52374: LD_INT 14
52376: ST_TO_ADDR
// vc_engine := engine_siberite ;
52377: LD_ADDR_OWVAR 39
52381: PUSH
52382: LD_INT 3
52384: ST_TO_ADDR
// vc_control := control_apeman ;
52385: LD_ADDR_OWVAR 38
52389: PUSH
52390: LD_INT 5
52392: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52393: LD_ADDR_OWVAR 40
52397: PUSH
52398: LD_INT 29
52400: ST_TO_ADDR
// un := CreateVehicle ;
52401: LD_ADDR_VAR 0 2
52405: PUSH
52406: CALL_OW 45
52410: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52411: LD_VAR 0 2
52415: PPUSH
52416: LD_INT 1
52418: PPUSH
52419: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52423: LD_INT 35
52425: PPUSH
52426: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52430: LD_VAR 0 2
52434: PPUSH
52435: LD_INT 22
52437: PUSH
52438: LD_OWVAR 2
52442: PUSH
52443: EMPTY
52444: LIST
52445: LIST
52446: PPUSH
52447: CALL_OW 69
52451: PPUSH
52452: LD_VAR 0 2
52456: PPUSH
52457: CALL_OW 74
52461: PPUSH
52462: CALL_OW 115
// until IsDead ( un ) ;
52466: LD_VAR 0 2
52470: PPUSH
52471: CALL_OW 301
52475: IFFALSE 52423
// end ;
52477: PPOPN 2
52479: END
// every 0 0$1 trigger StreamModeActive and sStu do
52480: LD_EXP 74
52484: PUSH
52485: LD_EXP 113
52489: AND
52490: IFFALSE 52506
52492: GO 52494
52494: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52495: LD_STRING displayStucuk();
52497: PPUSH
52498: CALL_OW 559
// ResetFog ;
52502: CALL_OW 335
// end ;
52506: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52507: LD_EXP 74
52511: PUSH
52512: LD_EXP 106
52516: AND
52517: IFFALSE 52658
52519: GO 52521
52521: DISABLE
52522: LD_INT 0
52524: PPUSH
52525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52526: LD_ADDR_VAR 0 2
52530: PUSH
52531: LD_INT 22
52533: PUSH
52534: LD_OWVAR 2
52538: PUSH
52539: EMPTY
52540: LIST
52541: LIST
52542: PUSH
52543: LD_INT 21
52545: PUSH
52546: LD_INT 1
52548: PUSH
52549: EMPTY
52550: LIST
52551: LIST
52552: PUSH
52553: EMPTY
52554: LIST
52555: LIST
52556: PPUSH
52557: CALL_OW 69
52561: ST_TO_ADDR
// if not tmp then
52562: LD_VAR 0 2
52566: NOT
52567: IFFALSE 52571
// exit ;
52569: GO 52658
// un := tmp [ rand ( 1 , tmp ) ] ;
52571: LD_ADDR_VAR 0 1
52575: PUSH
52576: LD_VAR 0 2
52580: PUSH
52581: LD_INT 1
52583: PPUSH
52584: LD_VAR 0 2
52588: PPUSH
52589: CALL_OW 12
52593: ARRAY
52594: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52595: LD_VAR 0 1
52599: PPUSH
52600: LD_INT 0
52602: PPUSH
52603: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52607: LD_VAR 0 1
52611: PPUSH
52612: LD_OWVAR 3
52616: PUSH
52617: LD_VAR 0 1
52621: DIFF
52622: PPUSH
52623: LD_VAR 0 1
52627: PPUSH
52628: CALL_OW 74
52632: PPUSH
52633: CALL_OW 115
// wait ( 0 0$20 ) ;
52637: LD_INT 700
52639: PPUSH
52640: CALL_OW 67
// SetSide ( un , your_side ) ;
52644: LD_VAR 0 1
52648: PPUSH
52649: LD_OWVAR 2
52653: PPUSH
52654: CALL_OW 235
// end ;
52658: PPOPN 2
52660: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52661: LD_EXP 74
52665: PUSH
52666: LD_EXP 107
52670: AND
52671: IFFALSE 52777
52673: GO 52675
52675: DISABLE
52676: LD_INT 0
52678: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52679: LD_ADDR_VAR 0 1
52683: PUSH
52684: LD_INT 22
52686: PUSH
52687: LD_OWVAR 2
52691: PUSH
52692: EMPTY
52693: LIST
52694: LIST
52695: PUSH
52696: LD_INT 2
52698: PUSH
52699: LD_INT 30
52701: PUSH
52702: LD_INT 0
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: PUSH
52709: LD_INT 30
52711: PUSH
52712: LD_INT 1
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: PUSH
52719: EMPTY
52720: LIST
52721: LIST
52722: LIST
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: PPUSH
52728: CALL_OW 69
52732: ST_TO_ADDR
// if not depot then
52733: LD_VAR 0 1
52737: NOT
52738: IFFALSE 52742
// exit ;
52740: GO 52777
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52742: LD_VAR 0 1
52746: PUSH
52747: LD_INT 1
52749: ARRAY
52750: PPUSH
52751: CALL_OW 250
52755: PPUSH
52756: LD_VAR 0 1
52760: PUSH
52761: LD_INT 1
52763: ARRAY
52764: PPUSH
52765: CALL_OW 251
52769: PPUSH
52770: LD_INT 70
52772: PPUSH
52773: CALL_OW 495
// end ;
52777: PPOPN 1
52779: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52780: LD_EXP 74
52784: PUSH
52785: LD_EXP 108
52789: AND
52790: IFFALSE 53001
52792: GO 52794
52794: DISABLE
52795: LD_INT 0
52797: PPUSH
52798: PPUSH
52799: PPUSH
52800: PPUSH
52801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52802: LD_ADDR_VAR 0 5
52806: PUSH
52807: LD_INT 22
52809: PUSH
52810: LD_OWVAR 2
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: LD_INT 21
52821: PUSH
52822: LD_INT 1
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: PPUSH
52833: CALL_OW 69
52837: ST_TO_ADDR
// if not tmp then
52838: LD_VAR 0 5
52842: NOT
52843: IFFALSE 52847
// exit ;
52845: GO 53001
// for i in tmp do
52847: LD_ADDR_VAR 0 1
52851: PUSH
52852: LD_VAR 0 5
52856: PUSH
52857: FOR_IN
52858: IFFALSE 52999
// begin d := rand ( 0 , 5 ) ;
52860: LD_ADDR_VAR 0 4
52864: PUSH
52865: LD_INT 0
52867: PPUSH
52868: LD_INT 5
52870: PPUSH
52871: CALL_OW 12
52875: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52876: LD_ADDR_VAR 0 2
52880: PUSH
52881: LD_VAR 0 1
52885: PPUSH
52886: CALL_OW 250
52890: PPUSH
52891: LD_VAR 0 4
52895: PPUSH
52896: LD_INT 3
52898: PPUSH
52899: LD_INT 12
52901: PPUSH
52902: CALL_OW 12
52906: PPUSH
52907: CALL_OW 272
52911: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52912: LD_ADDR_VAR 0 3
52916: PUSH
52917: LD_VAR 0 1
52921: PPUSH
52922: CALL_OW 251
52926: PPUSH
52927: LD_VAR 0 4
52931: PPUSH
52932: LD_INT 3
52934: PPUSH
52935: LD_INT 12
52937: PPUSH
52938: CALL_OW 12
52942: PPUSH
52943: CALL_OW 273
52947: ST_TO_ADDR
// if ValidHex ( x , y ) then
52948: LD_VAR 0 2
52952: PPUSH
52953: LD_VAR 0 3
52957: PPUSH
52958: CALL_OW 488
52962: IFFALSE 52997
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52964: LD_VAR 0 1
52968: PPUSH
52969: LD_VAR 0 2
52973: PPUSH
52974: LD_VAR 0 3
52978: PPUSH
52979: LD_INT 3
52981: PPUSH
52982: LD_INT 6
52984: PPUSH
52985: CALL_OW 12
52989: PPUSH
52990: LD_INT 1
52992: PPUSH
52993: CALL_OW 483
// end ;
52997: GO 52857
52999: POP
53000: POP
// end ;
53001: PPOPN 5
53003: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
53004: LD_EXP 74
53008: PUSH
53009: LD_EXP 109
53013: AND
53014: IFFALSE 53108
53016: GO 53018
53018: DISABLE
53019: LD_INT 0
53021: PPUSH
53022: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
53023: LD_ADDR_VAR 0 2
53027: PUSH
53028: LD_INT 22
53030: PUSH
53031: LD_OWVAR 2
53035: PUSH
53036: EMPTY
53037: LIST
53038: LIST
53039: PUSH
53040: LD_INT 32
53042: PUSH
53043: LD_INT 1
53045: PUSH
53046: EMPTY
53047: LIST
53048: LIST
53049: PUSH
53050: LD_INT 21
53052: PUSH
53053: LD_INT 2
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: PUSH
53060: EMPTY
53061: LIST
53062: LIST
53063: LIST
53064: PPUSH
53065: CALL_OW 69
53069: ST_TO_ADDR
// if not tmp then
53070: LD_VAR 0 2
53074: NOT
53075: IFFALSE 53079
// exit ;
53077: GO 53108
// for i in tmp do
53079: LD_ADDR_VAR 0 1
53083: PUSH
53084: LD_VAR 0 2
53088: PUSH
53089: FOR_IN
53090: IFFALSE 53106
// SetFuel ( i , 0 ) ;
53092: LD_VAR 0 1
53096: PPUSH
53097: LD_INT 0
53099: PPUSH
53100: CALL_OW 240
53104: GO 53089
53106: POP
53107: POP
// end ;
53108: PPOPN 2
53110: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
53111: LD_EXP 74
53115: PUSH
53116: LD_EXP 110
53120: AND
53121: IFFALSE 53187
53123: GO 53125
53125: DISABLE
53126: LD_INT 0
53128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53129: LD_ADDR_VAR 0 1
53133: PUSH
53134: LD_INT 22
53136: PUSH
53137: LD_OWVAR 2
53141: PUSH
53142: EMPTY
53143: LIST
53144: LIST
53145: PUSH
53146: LD_INT 30
53148: PUSH
53149: LD_INT 29
53151: PUSH
53152: EMPTY
53153: LIST
53154: LIST
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PPUSH
53160: CALL_OW 69
53164: ST_TO_ADDR
// if not tmp then
53165: LD_VAR 0 1
53169: NOT
53170: IFFALSE 53174
// exit ;
53172: GO 53187
// DestroyUnit ( tmp [ 1 ] ) ;
53174: LD_VAR 0 1
53178: PUSH
53179: LD_INT 1
53181: ARRAY
53182: PPUSH
53183: CALL_OW 65
// end ;
53187: PPOPN 1
53189: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53190: LD_EXP 74
53194: PUSH
53195: LD_EXP 112
53199: AND
53200: IFFALSE 53329
53202: GO 53204
53204: DISABLE
53205: LD_INT 0
53207: PPUSH
// begin uc_side := 0 ;
53208: LD_ADDR_OWVAR 20
53212: PUSH
53213: LD_INT 0
53215: ST_TO_ADDR
// uc_nation := nation_arabian ;
53216: LD_ADDR_OWVAR 21
53220: PUSH
53221: LD_INT 2
53223: ST_TO_ADDR
// hc_gallery :=  ;
53224: LD_ADDR_OWVAR 33
53228: PUSH
53229: LD_STRING 
53231: ST_TO_ADDR
// hc_name :=  ;
53232: LD_ADDR_OWVAR 26
53236: PUSH
53237: LD_STRING 
53239: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53240: LD_INT 1
53242: PPUSH
53243: LD_INT 11
53245: PPUSH
53246: LD_INT 10
53248: PPUSH
53249: CALL_OW 380
// un := CreateHuman ;
53253: LD_ADDR_VAR 0 1
53257: PUSH
53258: CALL_OW 44
53262: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53263: LD_VAR 0 1
53267: PPUSH
53268: LD_INT 1
53270: PPUSH
53271: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53275: LD_INT 35
53277: PPUSH
53278: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53282: LD_VAR 0 1
53286: PPUSH
53287: LD_INT 22
53289: PUSH
53290: LD_OWVAR 2
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: PPUSH
53299: CALL_OW 69
53303: PPUSH
53304: LD_VAR 0 1
53308: PPUSH
53309: CALL_OW 74
53313: PPUSH
53314: CALL_OW 115
// until IsDead ( un ) ;
53318: LD_VAR 0 1
53322: PPUSH
53323: CALL_OW 301
53327: IFFALSE 53275
// end ;
53329: PPOPN 1
53331: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53332: LD_EXP 74
53336: PUSH
53337: LD_EXP 114
53341: AND
53342: IFFALSE 53354
53344: GO 53346
53346: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53347: LD_STRING earthquake(getX(game), 0, 32)
53349: PPUSH
53350: CALL_OW 559
53354: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53355: LD_EXP 74
53359: PUSH
53360: LD_EXP 115
53364: AND
53365: IFFALSE 53456
53367: GO 53369
53369: DISABLE
53370: LD_INT 0
53372: PPUSH
// begin enable ;
53373: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53374: LD_ADDR_VAR 0 1
53378: PUSH
53379: LD_INT 22
53381: PUSH
53382: LD_OWVAR 2
53386: PUSH
53387: EMPTY
53388: LIST
53389: LIST
53390: PUSH
53391: LD_INT 21
53393: PUSH
53394: LD_INT 2
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: PUSH
53401: LD_INT 33
53403: PUSH
53404: LD_INT 3
53406: PUSH
53407: EMPTY
53408: LIST
53409: LIST
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: LIST
53415: PPUSH
53416: CALL_OW 69
53420: ST_TO_ADDR
// if not tmp then
53421: LD_VAR 0 1
53425: NOT
53426: IFFALSE 53430
// exit ;
53428: GO 53456
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53430: LD_VAR 0 1
53434: PUSH
53435: LD_INT 1
53437: PPUSH
53438: LD_VAR 0 1
53442: PPUSH
53443: CALL_OW 12
53447: ARRAY
53448: PPUSH
53449: LD_INT 1
53451: PPUSH
53452: CALL_OW 234
// end ;
53456: PPOPN 1
53458: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53459: LD_EXP 74
53463: PUSH
53464: LD_EXP 116
53468: AND
53469: IFFALSE 53610
53471: GO 53473
53473: DISABLE
53474: LD_INT 0
53476: PPUSH
53477: PPUSH
53478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53479: LD_ADDR_VAR 0 3
53483: PUSH
53484: LD_INT 22
53486: PUSH
53487: LD_OWVAR 2
53491: PUSH
53492: EMPTY
53493: LIST
53494: LIST
53495: PUSH
53496: LD_INT 25
53498: PUSH
53499: LD_INT 1
53501: PUSH
53502: EMPTY
53503: LIST
53504: LIST
53505: PUSH
53506: EMPTY
53507: LIST
53508: LIST
53509: PPUSH
53510: CALL_OW 69
53514: ST_TO_ADDR
// if not tmp then
53515: LD_VAR 0 3
53519: NOT
53520: IFFALSE 53524
// exit ;
53522: GO 53610
// un := tmp [ rand ( 1 , tmp ) ] ;
53524: LD_ADDR_VAR 0 2
53528: PUSH
53529: LD_VAR 0 3
53533: PUSH
53534: LD_INT 1
53536: PPUSH
53537: LD_VAR 0 3
53541: PPUSH
53542: CALL_OW 12
53546: ARRAY
53547: ST_TO_ADDR
// if Crawls ( un ) then
53548: LD_VAR 0 2
53552: PPUSH
53553: CALL_OW 318
53557: IFFALSE 53568
// ComWalk ( un ) ;
53559: LD_VAR 0 2
53563: PPUSH
53564: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53568: LD_VAR 0 2
53572: PPUSH
53573: LD_INT 9
53575: PPUSH
53576: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53580: LD_INT 28
53582: PPUSH
53583: LD_OWVAR 2
53587: PPUSH
53588: LD_INT 2
53590: PPUSH
53591: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53595: LD_INT 29
53597: PPUSH
53598: LD_OWVAR 2
53602: PPUSH
53603: LD_INT 2
53605: PPUSH
53606: CALL_OW 322
// end ;
53610: PPOPN 3
53612: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53613: LD_EXP 74
53617: PUSH
53618: LD_EXP 117
53622: AND
53623: IFFALSE 53734
53625: GO 53627
53627: DISABLE
53628: LD_INT 0
53630: PPUSH
53631: PPUSH
53632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53633: LD_ADDR_VAR 0 3
53637: PUSH
53638: LD_INT 22
53640: PUSH
53641: LD_OWVAR 2
53645: PUSH
53646: EMPTY
53647: LIST
53648: LIST
53649: PUSH
53650: LD_INT 25
53652: PUSH
53653: LD_INT 1
53655: PUSH
53656: EMPTY
53657: LIST
53658: LIST
53659: PUSH
53660: EMPTY
53661: LIST
53662: LIST
53663: PPUSH
53664: CALL_OW 69
53668: ST_TO_ADDR
// if not tmp then
53669: LD_VAR 0 3
53673: NOT
53674: IFFALSE 53678
// exit ;
53676: GO 53734
// un := tmp [ rand ( 1 , tmp ) ] ;
53678: LD_ADDR_VAR 0 2
53682: PUSH
53683: LD_VAR 0 3
53687: PUSH
53688: LD_INT 1
53690: PPUSH
53691: LD_VAR 0 3
53695: PPUSH
53696: CALL_OW 12
53700: ARRAY
53701: ST_TO_ADDR
// if Crawls ( un ) then
53702: LD_VAR 0 2
53706: PPUSH
53707: CALL_OW 318
53711: IFFALSE 53722
// ComWalk ( un ) ;
53713: LD_VAR 0 2
53717: PPUSH
53718: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53722: LD_VAR 0 2
53726: PPUSH
53727: LD_INT 8
53729: PPUSH
53730: CALL_OW 336
// end ;
53734: PPOPN 3
53736: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53737: LD_EXP 74
53741: PUSH
53742: LD_EXP 118
53746: AND
53747: IFFALSE 53891
53749: GO 53751
53751: DISABLE
53752: LD_INT 0
53754: PPUSH
53755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53756: LD_ADDR_VAR 0 2
53760: PUSH
53761: LD_INT 22
53763: PUSH
53764: LD_OWVAR 2
53768: PUSH
53769: EMPTY
53770: LIST
53771: LIST
53772: PUSH
53773: LD_INT 21
53775: PUSH
53776: LD_INT 2
53778: PUSH
53779: EMPTY
53780: LIST
53781: LIST
53782: PUSH
53783: LD_INT 2
53785: PUSH
53786: LD_INT 34
53788: PUSH
53789: LD_INT 12
53791: PUSH
53792: EMPTY
53793: LIST
53794: LIST
53795: PUSH
53796: LD_INT 34
53798: PUSH
53799: LD_INT 51
53801: PUSH
53802: EMPTY
53803: LIST
53804: LIST
53805: PUSH
53806: LD_INT 34
53808: PUSH
53809: LD_INT 32
53811: PUSH
53812: EMPTY
53813: LIST
53814: LIST
53815: PUSH
53816: EMPTY
53817: LIST
53818: LIST
53819: LIST
53820: LIST
53821: PUSH
53822: EMPTY
53823: LIST
53824: LIST
53825: LIST
53826: PPUSH
53827: CALL_OW 69
53831: ST_TO_ADDR
// if not tmp then
53832: LD_VAR 0 2
53836: NOT
53837: IFFALSE 53841
// exit ;
53839: GO 53891
// for i in tmp do
53841: LD_ADDR_VAR 0 1
53845: PUSH
53846: LD_VAR 0 2
53850: PUSH
53851: FOR_IN
53852: IFFALSE 53889
// if GetCargo ( i , mat_artifact ) = 0 then
53854: LD_VAR 0 1
53858: PPUSH
53859: LD_INT 4
53861: PPUSH
53862: CALL_OW 289
53866: PUSH
53867: LD_INT 0
53869: EQUAL
53870: IFFALSE 53887
// SetCargo ( i , mat_siberit , 100 ) ;
53872: LD_VAR 0 1
53876: PPUSH
53877: LD_INT 3
53879: PPUSH
53880: LD_INT 100
53882: PPUSH
53883: CALL_OW 290
53887: GO 53851
53889: POP
53890: POP
// end ;
53891: PPOPN 2
53893: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53894: LD_EXP 74
53898: PUSH
53899: LD_EXP 119
53903: AND
53904: IFFALSE 54087
53906: GO 53908
53908: DISABLE
53909: LD_INT 0
53911: PPUSH
53912: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53913: LD_ADDR_VAR 0 2
53917: PUSH
53918: LD_INT 22
53920: PUSH
53921: LD_OWVAR 2
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: PPUSH
53930: CALL_OW 69
53934: ST_TO_ADDR
// if not tmp then
53935: LD_VAR 0 2
53939: NOT
53940: IFFALSE 53944
// exit ;
53942: GO 54087
// for i := 1 to 2 do
53944: LD_ADDR_VAR 0 1
53948: PUSH
53949: DOUBLE
53950: LD_INT 1
53952: DEC
53953: ST_TO_ADDR
53954: LD_INT 2
53956: PUSH
53957: FOR_TO
53958: IFFALSE 54085
// begin uc_side := your_side ;
53960: LD_ADDR_OWVAR 20
53964: PUSH
53965: LD_OWVAR 2
53969: ST_TO_ADDR
// uc_nation := nation_american ;
53970: LD_ADDR_OWVAR 21
53974: PUSH
53975: LD_INT 1
53977: ST_TO_ADDR
// vc_chassis := us_morphling ;
53978: LD_ADDR_OWVAR 37
53982: PUSH
53983: LD_INT 5
53985: ST_TO_ADDR
// vc_engine := engine_siberite ;
53986: LD_ADDR_OWVAR 39
53990: PUSH
53991: LD_INT 3
53993: ST_TO_ADDR
// vc_control := control_computer ;
53994: LD_ADDR_OWVAR 38
53998: PUSH
53999: LD_INT 3
54001: ST_TO_ADDR
// vc_weapon := us_double_laser ;
54002: LD_ADDR_OWVAR 40
54006: PUSH
54007: LD_INT 10
54009: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
54010: LD_VAR 0 2
54014: PUSH
54015: LD_INT 1
54017: ARRAY
54018: PPUSH
54019: CALL_OW 310
54023: NOT
54024: IFFALSE 54071
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
54026: CALL_OW 45
54030: PPUSH
54031: LD_VAR 0 2
54035: PUSH
54036: LD_INT 1
54038: ARRAY
54039: PPUSH
54040: CALL_OW 250
54044: PPUSH
54045: LD_VAR 0 2
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: PPUSH
54054: CALL_OW 251
54058: PPUSH
54059: LD_INT 12
54061: PPUSH
54062: LD_INT 1
54064: PPUSH
54065: CALL_OW 50
54069: GO 54083
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
54071: CALL_OW 45
54075: PPUSH
54076: LD_INT 1
54078: PPUSH
54079: CALL_OW 51
// end ;
54083: GO 53957
54085: POP
54086: POP
// end ;
54087: PPOPN 2
54089: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
54090: LD_EXP 74
54094: PUSH
54095: LD_EXP 120
54099: AND
54100: IFFALSE 54322
54102: GO 54104
54104: DISABLE
54105: LD_INT 0
54107: PPUSH
54108: PPUSH
54109: PPUSH
54110: PPUSH
54111: PPUSH
54112: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54113: LD_ADDR_VAR 0 6
54117: PUSH
54118: LD_INT 22
54120: PUSH
54121: LD_OWVAR 2
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: PUSH
54130: LD_INT 21
54132: PUSH
54133: LD_INT 1
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: PUSH
54140: LD_INT 3
54142: PUSH
54143: LD_INT 23
54145: PUSH
54146: LD_INT 0
54148: PUSH
54149: EMPTY
54150: LIST
54151: LIST
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: PUSH
54157: EMPTY
54158: LIST
54159: LIST
54160: LIST
54161: PPUSH
54162: CALL_OW 69
54166: ST_TO_ADDR
// if not tmp then
54167: LD_VAR 0 6
54171: NOT
54172: IFFALSE 54176
// exit ;
54174: GO 54322
// s1 := rand ( 1 , 4 ) ;
54176: LD_ADDR_VAR 0 2
54180: PUSH
54181: LD_INT 1
54183: PPUSH
54184: LD_INT 4
54186: PPUSH
54187: CALL_OW 12
54191: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54192: LD_ADDR_VAR 0 4
54196: PUSH
54197: LD_VAR 0 6
54201: PUSH
54202: LD_INT 1
54204: ARRAY
54205: PPUSH
54206: LD_VAR 0 2
54210: PPUSH
54211: CALL_OW 259
54215: ST_TO_ADDR
// if s1 = 1 then
54216: LD_VAR 0 2
54220: PUSH
54221: LD_INT 1
54223: EQUAL
54224: IFFALSE 54244
// s2 := rand ( 2 , 4 ) else
54226: LD_ADDR_VAR 0 3
54230: PUSH
54231: LD_INT 2
54233: PPUSH
54234: LD_INT 4
54236: PPUSH
54237: CALL_OW 12
54241: ST_TO_ADDR
54242: GO 54252
// s2 := 1 ;
54244: LD_ADDR_VAR 0 3
54248: PUSH
54249: LD_INT 1
54251: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54252: LD_ADDR_VAR 0 5
54256: PUSH
54257: LD_VAR 0 6
54261: PUSH
54262: LD_INT 1
54264: ARRAY
54265: PPUSH
54266: LD_VAR 0 3
54270: PPUSH
54271: CALL_OW 259
54275: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54276: LD_VAR 0 6
54280: PUSH
54281: LD_INT 1
54283: ARRAY
54284: PPUSH
54285: LD_VAR 0 2
54289: PPUSH
54290: LD_VAR 0 5
54294: PPUSH
54295: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54299: LD_VAR 0 6
54303: PUSH
54304: LD_INT 1
54306: ARRAY
54307: PPUSH
54308: LD_VAR 0 3
54312: PPUSH
54313: LD_VAR 0 4
54317: PPUSH
54318: CALL_OW 237
// end ;
54322: PPOPN 6
54324: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54325: LD_EXP 74
54329: PUSH
54330: LD_EXP 121
54334: AND
54335: IFFALSE 54414
54337: GO 54339
54339: DISABLE
54340: LD_INT 0
54342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54343: LD_ADDR_VAR 0 1
54347: PUSH
54348: LD_INT 22
54350: PUSH
54351: LD_OWVAR 2
54355: PUSH
54356: EMPTY
54357: LIST
54358: LIST
54359: PUSH
54360: LD_INT 30
54362: PUSH
54363: LD_INT 3
54365: PUSH
54366: EMPTY
54367: LIST
54368: LIST
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: PPUSH
54374: CALL_OW 69
54378: ST_TO_ADDR
// if not tmp then
54379: LD_VAR 0 1
54383: NOT
54384: IFFALSE 54388
// exit ;
54386: GO 54414
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54388: LD_VAR 0 1
54392: PUSH
54393: LD_INT 1
54395: PPUSH
54396: LD_VAR 0 1
54400: PPUSH
54401: CALL_OW 12
54405: ARRAY
54406: PPUSH
54407: LD_INT 1
54409: PPUSH
54410: CALL_OW 234
// end ;
54414: PPOPN 1
54416: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54417: LD_EXP 74
54421: PUSH
54422: LD_EXP 122
54426: AND
54427: IFFALSE 54539
54429: GO 54431
54431: DISABLE
54432: LD_INT 0
54434: PPUSH
54435: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54436: LD_ADDR_VAR 0 2
54440: PUSH
54441: LD_INT 22
54443: PUSH
54444: LD_OWVAR 2
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: PUSH
54453: LD_INT 2
54455: PUSH
54456: LD_INT 30
54458: PUSH
54459: LD_INT 27
54461: PUSH
54462: EMPTY
54463: LIST
54464: LIST
54465: PUSH
54466: LD_INT 30
54468: PUSH
54469: LD_INT 26
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: PUSH
54476: LD_INT 30
54478: PUSH
54479: LD_INT 28
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: PUSH
54486: EMPTY
54487: LIST
54488: LIST
54489: LIST
54490: LIST
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: PPUSH
54496: CALL_OW 69
54500: ST_TO_ADDR
// if not tmp then
54501: LD_VAR 0 2
54505: NOT
54506: IFFALSE 54510
// exit ;
54508: GO 54539
// for i in tmp do
54510: LD_ADDR_VAR 0 1
54514: PUSH
54515: LD_VAR 0 2
54519: PUSH
54520: FOR_IN
54521: IFFALSE 54537
// SetLives ( i , 1 ) ;
54523: LD_VAR 0 1
54527: PPUSH
54528: LD_INT 1
54530: PPUSH
54531: CALL_OW 234
54535: GO 54520
54537: POP
54538: POP
// end ;
54539: PPOPN 2
54541: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54542: LD_EXP 74
54546: PUSH
54547: LD_EXP 123
54551: AND
54552: IFFALSE 54839
54554: GO 54556
54556: DISABLE
54557: LD_INT 0
54559: PPUSH
54560: PPUSH
54561: PPUSH
// begin i := rand ( 1 , 7 ) ;
54562: LD_ADDR_VAR 0 1
54566: PUSH
54567: LD_INT 1
54569: PPUSH
54570: LD_INT 7
54572: PPUSH
54573: CALL_OW 12
54577: ST_TO_ADDR
// case i of 1 :
54578: LD_VAR 0 1
54582: PUSH
54583: LD_INT 1
54585: DOUBLE
54586: EQUAL
54587: IFTRUE 54591
54589: GO 54601
54591: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54592: LD_STRING earthquake(getX(game), 0, 32)
54594: PPUSH
54595: CALL_OW 559
54599: GO 54839
54601: LD_INT 2
54603: DOUBLE
54604: EQUAL
54605: IFTRUE 54609
54607: GO 54623
54609: POP
// begin ToLua ( displayStucuk(); ) ;
54610: LD_STRING displayStucuk();
54612: PPUSH
54613: CALL_OW 559
// ResetFog ;
54617: CALL_OW 335
// end ; 3 :
54621: GO 54839
54623: LD_INT 3
54625: DOUBLE
54626: EQUAL
54627: IFTRUE 54631
54629: GO 54735
54631: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54632: LD_ADDR_VAR 0 2
54636: PUSH
54637: LD_INT 22
54639: PUSH
54640: LD_OWVAR 2
54644: PUSH
54645: EMPTY
54646: LIST
54647: LIST
54648: PUSH
54649: LD_INT 25
54651: PUSH
54652: LD_INT 1
54654: PUSH
54655: EMPTY
54656: LIST
54657: LIST
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: PPUSH
54663: CALL_OW 69
54667: ST_TO_ADDR
// if not tmp then
54668: LD_VAR 0 2
54672: NOT
54673: IFFALSE 54677
// exit ;
54675: GO 54839
// un := tmp [ rand ( 1 , tmp ) ] ;
54677: LD_ADDR_VAR 0 3
54681: PUSH
54682: LD_VAR 0 2
54686: PUSH
54687: LD_INT 1
54689: PPUSH
54690: LD_VAR 0 2
54694: PPUSH
54695: CALL_OW 12
54699: ARRAY
54700: ST_TO_ADDR
// if Crawls ( un ) then
54701: LD_VAR 0 3
54705: PPUSH
54706: CALL_OW 318
54710: IFFALSE 54721
// ComWalk ( un ) ;
54712: LD_VAR 0 3
54716: PPUSH
54717: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54721: LD_VAR 0 3
54725: PPUSH
54726: LD_INT 8
54728: PPUSH
54729: CALL_OW 336
// end ; 4 :
54733: GO 54839
54735: LD_INT 4
54737: DOUBLE
54738: EQUAL
54739: IFTRUE 54743
54741: GO 54817
54743: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54744: LD_ADDR_VAR 0 2
54748: PUSH
54749: LD_INT 22
54751: PUSH
54752: LD_OWVAR 2
54756: PUSH
54757: EMPTY
54758: LIST
54759: LIST
54760: PUSH
54761: LD_INT 30
54763: PUSH
54764: LD_INT 29
54766: PUSH
54767: EMPTY
54768: LIST
54769: LIST
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PPUSH
54775: CALL_OW 69
54779: ST_TO_ADDR
// if not tmp then
54780: LD_VAR 0 2
54784: NOT
54785: IFFALSE 54789
// exit ;
54787: GO 54839
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54789: LD_VAR 0 2
54793: PUSH
54794: LD_INT 1
54796: ARRAY
54797: PPUSH
54798: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54802: LD_VAR 0 2
54806: PUSH
54807: LD_INT 1
54809: ARRAY
54810: PPUSH
54811: CALL_OW 65
// end ; 5 .. 7 :
54815: GO 54839
54817: LD_INT 5
54819: DOUBLE
54820: GREATEREQUAL
54821: IFFALSE 54829
54823: LD_INT 7
54825: DOUBLE
54826: LESSEQUAL
54827: IFTRUE 54831
54829: GO 54838
54831: POP
// StreamSibBomb ; end ;
54832: CALL 51076 0 0
54836: GO 54839
54838: POP
// end ;
54839: PPOPN 3
54841: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54842: LD_EXP 74
54846: PUSH
54847: LD_EXP 124
54851: AND
54852: IFFALSE 55008
54854: GO 54856
54856: DISABLE
54857: LD_INT 0
54859: PPUSH
54860: PPUSH
54861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54862: LD_ADDR_VAR 0 2
54866: PUSH
54867: LD_INT 81
54869: PUSH
54870: LD_OWVAR 2
54874: PUSH
54875: EMPTY
54876: LIST
54877: LIST
54878: PUSH
54879: LD_INT 2
54881: PUSH
54882: LD_INT 21
54884: PUSH
54885: LD_INT 1
54887: PUSH
54888: EMPTY
54889: LIST
54890: LIST
54891: PUSH
54892: LD_INT 21
54894: PUSH
54895: LD_INT 2
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: LIST
54906: PUSH
54907: EMPTY
54908: LIST
54909: LIST
54910: PPUSH
54911: CALL_OW 69
54915: ST_TO_ADDR
// if not tmp then
54916: LD_VAR 0 2
54920: NOT
54921: IFFALSE 54925
// exit ;
54923: GO 55008
// p := 0 ;
54925: LD_ADDR_VAR 0 3
54929: PUSH
54930: LD_INT 0
54932: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54933: LD_INT 35
54935: PPUSH
54936: CALL_OW 67
// p := p + 1 ;
54940: LD_ADDR_VAR 0 3
54944: PUSH
54945: LD_VAR 0 3
54949: PUSH
54950: LD_INT 1
54952: PLUS
54953: ST_TO_ADDR
// for i in tmp do
54954: LD_ADDR_VAR 0 1
54958: PUSH
54959: LD_VAR 0 2
54963: PUSH
54964: FOR_IN
54965: IFFALSE 54996
// if GetLives ( i ) < 1000 then
54967: LD_VAR 0 1
54971: PPUSH
54972: CALL_OW 256
54976: PUSH
54977: LD_INT 1000
54979: LESS
54980: IFFALSE 54994
// SetLives ( i , 1000 ) ;
54982: LD_VAR 0 1
54986: PPUSH
54987: LD_INT 1000
54989: PPUSH
54990: CALL_OW 234
54994: GO 54964
54996: POP
54997: POP
// until p > 20 ;
54998: LD_VAR 0 3
55002: PUSH
55003: LD_INT 20
55005: GREATER
55006: IFFALSE 54933
// end ;
55008: PPOPN 3
55010: END
// every 0 0$1 trigger StreamModeActive and sTime do
55011: LD_EXP 74
55015: PUSH
55016: LD_EXP 125
55020: AND
55021: IFFALSE 55056
55023: GO 55025
55025: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
55026: LD_INT 28
55028: PPUSH
55029: LD_OWVAR 2
55033: PPUSH
55034: LD_INT 2
55036: PPUSH
55037: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
55041: LD_INT 30
55043: PPUSH
55044: LD_OWVAR 2
55048: PPUSH
55049: LD_INT 2
55051: PPUSH
55052: CALL_OW 322
// end ;
55056: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
55057: LD_EXP 74
55061: PUSH
55062: LD_EXP 126
55066: AND
55067: IFFALSE 55188
55069: GO 55071
55071: DISABLE
55072: LD_INT 0
55074: PPUSH
55075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
55076: LD_ADDR_VAR 0 2
55080: PUSH
55081: LD_INT 22
55083: PUSH
55084: LD_OWVAR 2
55088: PUSH
55089: EMPTY
55090: LIST
55091: LIST
55092: PUSH
55093: LD_INT 21
55095: PUSH
55096: LD_INT 1
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: PUSH
55103: LD_INT 3
55105: PUSH
55106: LD_INT 23
55108: PUSH
55109: LD_INT 0
55111: PUSH
55112: EMPTY
55113: LIST
55114: LIST
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: LIST
55124: PPUSH
55125: CALL_OW 69
55129: ST_TO_ADDR
// if not tmp then
55130: LD_VAR 0 2
55134: NOT
55135: IFFALSE 55139
// exit ;
55137: GO 55188
// for i in tmp do
55139: LD_ADDR_VAR 0 1
55143: PUSH
55144: LD_VAR 0 2
55148: PUSH
55149: FOR_IN
55150: IFFALSE 55186
// begin if Crawls ( i ) then
55152: LD_VAR 0 1
55156: PPUSH
55157: CALL_OW 318
55161: IFFALSE 55172
// ComWalk ( i ) ;
55163: LD_VAR 0 1
55167: PPUSH
55168: CALL_OW 138
// SetClass ( i , 2 ) ;
55172: LD_VAR 0 1
55176: PPUSH
55177: LD_INT 2
55179: PPUSH
55180: CALL_OW 336
// end ;
55184: GO 55149
55186: POP
55187: POP
// end ;
55188: PPOPN 2
55190: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55191: LD_EXP 74
55195: PUSH
55196: LD_EXP 127
55200: AND
55201: IFFALSE 55489
55203: GO 55205
55205: DISABLE
55206: LD_INT 0
55208: PPUSH
55209: PPUSH
55210: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55211: LD_OWVAR 2
55215: PPUSH
55216: LD_INT 9
55218: PPUSH
55219: LD_INT 1
55221: PPUSH
55222: LD_INT 1
55224: PPUSH
55225: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55229: LD_INT 9
55231: PPUSH
55232: LD_OWVAR 2
55236: PPUSH
55237: CALL_OW 343
// uc_side := 9 ;
55241: LD_ADDR_OWVAR 20
55245: PUSH
55246: LD_INT 9
55248: ST_TO_ADDR
// uc_nation := 2 ;
55249: LD_ADDR_OWVAR 21
55253: PUSH
55254: LD_INT 2
55256: ST_TO_ADDR
// hc_name := Dark Warrior ;
55257: LD_ADDR_OWVAR 26
55261: PUSH
55262: LD_STRING Dark Warrior
55264: ST_TO_ADDR
// hc_gallery :=  ;
55265: LD_ADDR_OWVAR 33
55269: PUSH
55270: LD_STRING 
55272: ST_TO_ADDR
// hc_noskilllimit := true ;
55273: LD_ADDR_OWVAR 76
55277: PUSH
55278: LD_INT 1
55280: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55281: LD_ADDR_OWVAR 31
55285: PUSH
55286: LD_INT 30
55288: PUSH
55289: LD_INT 30
55291: PUSH
55292: LD_INT 30
55294: PUSH
55295: LD_INT 30
55297: PUSH
55298: EMPTY
55299: LIST
55300: LIST
55301: LIST
55302: LIST
55303: ST_TO_ADDR
// un := CreateHuman ;
55304: LD_ADDR_VAR 0 3
55308: PUSH
55309: CALL_OW 44
55313: ST_TO_ADDR
// hc_noskilllimit := false ;
55314: LD_ADDR_OWVAR 76
55318: PUSH
55319: LD_INT 0
55321: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55322: LD_VAR 0 3
55326: PPUSH
55327: LD_INT 1
55329: PPUSH
55330: CALL_OW 51
// ToLua ( playRanger() ) ;
55334: LD_STRING playRanger()
55336: PPUSH
55337: CALL_OW 559
// p := 0 ;
55341: LD_ADDR_VAR 0 2
55345: PUSH
55346: LD_INT 0
55348: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55349: LD_INT 35
55351: PPUSH
55352: CALL_OW 67
// p := p + 1 ;
55356: LD_ADDR_VAR 0 2
55360: PUSH
55361: LD_VAR 0 2
55365: PUSH
55366: LD_INT 1
55368: PLUS
55369: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55370: LD_VAR 0 3
55374: PPUSH
55375: CALL_OW 256
55379: PUSH
55380: LD_INT 1000
55382: LESS
55383: IFFALSE 55397
// SetLives ( un , 1000 ) ;
55385: LD_VAR 0 3
55389: PPUSH
55390: LD_INT 1000
55392: PPUSH
55393: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55397: LD_VAR 0 3
55401: PPUSH
55402: LD_INT 81
55404: PUSH
55405: LD_OWVAR 2
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: PUSH
55414: LD_INT 91
55416: PUSH
55417: LD_VAR 0 3
55421: PUSH
55422: LD_INT 30
55424: PUSH
55425: EMPTY
55426: LIST
55427: LIST
55428: LIST
55429: PUSH
55430: EMPTY
55431: LIST
55432: LIST
55433: PPUSH
55434: CALL_OW 69
55438: PPUSH
55439: LD_VAR 0 3
55443: PPUSH
55444: CALL_OW 74
55448: PPUSH
55449: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55453: LD_VAR 0 2
55457: PUSH
55458: LD_INT 80
55460: GREATER
55461: PUSH
55462: LD_VAR 0 3
55466: PPUSH
55467: CALL_OW 301
55471: OR
55472: IFFALSE 55349
// if un then
55474: LD_VAR 0 3
55478: IFFALSE 55489
// RemoveUnit ( un ) ;
55480: LD_VAR 0 3
55484: PPUSH
55485: CALL_OW 64
// end ;
55489: PPOPN 3
55491: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55492: LD_EXP 128
55496: IFFALSE 55612
55498: GO 55500
55500: DISABLE
55501: LD_INT 0
55503: PPUSH
55504: PPUSH
55505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55506: LD_ADDR_VAR 0 2
55510: PUSH
55511: LD_INT 81
55513: PUSH
55514: LD_OWVAR 2
55518: PUSH
55519: EMPTY
55520: LIST
55521: LIST
55522: PUSH
55523: LD_INT 21
55525: PUSH
55526: LD_INT 1
55528: PUSH
55529: EMPTY
55530: LIST
55531: LIST
55532: PUSH
55533: EMPTY
55534: LIST
55535: LIST
55536: PPUSH
55537: CALL_OW 69
55541: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55542: LD_STRING playComputer()
55544: PPUSH
55545: CALL_OW 559
// if not tmp then
55549: LD_VAR 0 2
55553: NOT
55554: IFFALSE 55558
// exit ;
55556: GO 55612
// for i in tmp do
55558: LD_ADDR_VAR 0 1
55562: PUSH
55563: LD_VAR 0 2
55567: PUSH
55568: FOR_IN
55569: IFFALSE 55610
// for j := 1 to 4 do
55571: LD_ADDR_VAR 0 3
55575: PUSH
55576: DOUBLE
55577: LD_INT 1
55579: DEC
55580: ST_TO_ADDR
55581: LD_INT 4
55583: PUSH
55584: FOR_TO
55585: IFFALSE 55606
// SetSkill ( i , j , 10 ) ;
55587: LD_VAR 0 1
55591: PPUSH
55592: LD_VAR 0 3
55596: PPUSH
55597: LD_INT 10
55599: PPUSH
55600: CALL_OW 237
55604: GO 55584
55606: POP
55607: POP
55608: GO 55568
55610: POP
55611: POP
// end ;
55612: PPOPN 3
55614: END
// every 0 0$1 trigger s30 do var i , tmp ;
55615: LD_EXP 129
55619: IFFALSE 55688
55621: GO 55623
55623: DISABLE
55624: LD_INT 0
55626: PPUSH
55627: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55628: LD_ADDR_VAR 0 2
55632: PUSH
55633: LD_INT 22
55635: PUSH
55636: LD_OWVAR 2
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: PPUSH
55645: CALL_OW 69
55649: ST_TO_ADDR
// if not tmp then
55650: LD_VAR 0 2
55654: NOT
55655: IFFALSE 55659
// exit ;
55657: GO 55688
// for i in tmp do
55659: LD_ADDR_VAR 0 1
55663: PUSH
55664: LD_VAR 0 2
55668: PUSH
55669: FOR_IN
55670: IFFALSE 55686
// SetLives ( i , 300 ) ;
55672: LD_VAR 0 1
55676: PPUSH
55677: LD_INT 300
55679: PPUSH
55680: CALL_OW 234
55684: GO 55669
55686: POP
55687: POP
// end ;
55688: PPOPN 2
55690: END
// every 0 0$1 trigger s60 do var i , tmp ;
55691: LD_EXP 130
55695: IFFALSE 55764
55697: GO 55699
55699: DISABLE
55700: LD_INT 0
55702: PPUSH
55703: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55704: LD_ADDR_VAR 0 2
55708: PUSH
55709: LD_INT 22
55711: PUSH
55712: LD_OWVAR 2
55716: PUSH
55717: EMPTY
55718: LIST
55719: LIST
55720: PPUSH
55721: CALL_OW 69
55725: ST_TO_ADDR
// if not tmp then
55726: LD_VAR 0 2
55730: NOT
55731: IFFALSE 55735
// exit ;
55733: GO 55764
// for i in tmp do
55735: LD_ADDR_VAR 0 1
55739: PUSH
55740: LD_VAR 0 2
55744: PUSH
55745: FOR_IN
55746: IFFALSE 55762
// SetLives ( i , 600 ) ;
55748: LD_VAR 0 1
55752: PPUSH
55753: LD_INT 600
55755: PPUSH
55756: CALL_OW 234
55760: GO 55745
55762: POP
55763: POP
// end ;
55764: PPOPN 2
55766: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55767: LD_INT 0
55769: PPUSH
// case cmd of 301 :
55770: LD_VAR 0 1
55774: PUSH
55775: LD_INT 301
55777: DOUBLE
55778: EQUAL
55779: IFTRUE 55783
55781: GO 55815
55783: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55784: LD_VAR 0 6
55788: PPUSH
55789: LD_VAR 0 7
55793: PPUSH
55794: LD_VAR 0 8
55798: PPUSH
55799: LD_VAR 0 4
55803: PPUSH
55804: LD_VAR 0 5
55808: PPUSH
55809: CALL 57024 0 5
55813: GO 55936
55815: LD_INT 302
55817: DOUBLE
55818: EQUAL
55819: IFTRUE 55823
55821: GO 55860
55823: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55824: LD_VAR 0 6
55828: PPUSH
55829: LD_VAR 0 7
55833: PPUSH
55834: LD_VAR 0 8
55838: PPUSH
55839: LD_VAR 0 9
55843: PPUSH
55844: LD_VAR 0 4
55848: PPUSH
55849: LD_VAR 0 5
55853: PPUSH
55854: CALL 57115 0 6
55858: GO 55936
55860: LD_INT 303
55862: DOUBLE
55863: EQUAL
55864: IFTRUE 55868
55866: GO 55905
55868: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55869: LD_VAR 0 6
55873: PPUSH
55874: LD_VAR 0 7
55878: PPUSH
55879: LD_VAR 0 8
55883: PPUSH
55884: LD_VAR 0 9
55888: PPUSH
55889: LD_VAR 0 4
55893: PPUSH
55894: LD_VAR 0 5
55898: PPUSH
55899: CALL 55941 0 6
55903: GO 55936
55905: LD_INT 304
55907: DOUBLE
55908: EQUAL
55909: IFTRUE 55913
55911: GO 55935
55913: POP
// hHackTeleport ( unit , x , y ) ; end ;
55914: LD_VAR 0 2
55918: PPUSH
55919: LD_VAR 0 4
55923: PPUSH
55924: LD_VAR 0 5
55928: PPUSH
55929: CALL 57708 0 3
55933: GO 55936
55935: POP
// end ;
55936: LD_VAR 0 12
55940: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55941: LD_INT 0
55943: PPUSH
55944: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55945: LD_VAR 0 1
55949: PUSH
55950: LD_INT 1
55952: LESS
55953: PUSH
55954: LD_VAR 0 1
55958: PUSH
55959: LD_INT 3
55961: GREATER
55962: OR
55963: PUSH
55964: LD_VAR 0 5
55968: PPUSH
55969: LD_VAR 0 6
55973: PPUSH
55974: CALL_OW 428
55978: OR
55979: IFFALSE 55983
// exit ;
55981: GO 56711
// uc_side := your_side ;
55983: LD_ADDR_OWVAR 20
55987: PUSH
55988: LD_OWVAR 2
55992: ST_TO_ADDR
// uc_nation := nation ;
55993: LD_ADDR_OWVAR 21
55997: PUSH
55998: LD_VAR 0 1
56002: ST_TO_ADDR
// bc_level = 1 ;
56003: LD_ADDR_OWVAR 43
56007: PUSH
56008: LD_INT 1
56010: ST_TO_ADDR
// case btype of 1 :
56011: LD_VAR 0 2
56015: PUSH
56016: LD_INT 1
56018: DOUBLE
56019: EQUAL
56020: IFTRUE 56024
56022: GO 56035
56024: POP
// bc_type := b_depot ; 2 :
56025: LD_ADDR_OWVAR 42
56029: PUSH
56030: LD_INT 0
56032: ST_TO_ADDR
56033: GO 56655
56035: LD_INT 2
56037: DOUBLE
56038: EQUAL
56039: IFTRUE 56043
56041: GO 56054
56043: POP
// bc_type := b_warehouse ; 3 :
56044: LD_ADDR_OWVAR 42
56048: PUSH
56049: LD_INT 1
56051: ST_TO_ADDR
56052: GO 56655
56054: LD_INT 3
56056: DOUBLE
56057: EQUAL
56058: IFTRUE 56062
56060: GO 56073
56062: POP
// bc_type := b_lab ; 4 .. 9 :
56063: LD_ADDR_OWVAR 42
56067: PUSH
56068: LD_INT 6
56070: ST_TO_ADDR
56071: GO 56655
56073: LD_INT 4
56075: DOUBLE
56076: GREATEREQUAL
56077: IFFALSE 56085
56079: LD_INT 9
56081: DOUBLE
56082: LESSEQUAL
56083: IFTRUE 56087
56085: GO 56147
56087: POP
// begin bc_type := b_lab_half ;
56088: LD_ADDR_OWVAR 42
56092: PUSH
56093: LD_INT 7
56095: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
56096: LD_ADDR_OWVAR 44
56100: PUSH
56101: LD_INT 10
56103: PUSH
56104: LD_INT 11
56106: PUSH
56107: LD_INT 12
56109: PUSH
56110: LD_INT 15
56112: PUSH
56113: LD_INT 14
56115: PUSH
56116: LD_INT 13
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: LIST
56123: LIST
56124: LIST
56125: LIST
56126: PUSH
56127: LD_VAR 0 2
56131: PUSH
56132: LD_INT 3
56134: MINUS
56135: ARRAY
56136: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
56137: LD_ADDR_OWVAR 45
56141: PUSH
56142: LD_INT 9
56144: ST_TO_ADDR
// end ; 10 .. 13 :
56145: GO 56655
56147: LD_INT 10
56149: DOUBLE
56150: GREATEREQUAL
56151: IFFALSE 56159
56153: LD_INT 13
56155: DOUBLE
56156: LESSEQUAL
56157: IFTRUE 56161
56159: GO 56238
56161: POP
// begin bc_type := b_lab_full ;
56162: LD_ADDR_OWVAR 42
56166: PUSH
56167: LD_INT 8
56169: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56170: LD_ADDR_OWVAR 44
56174: PUSH
56175: LD_INT 10
56177: PUSH
56178: LD_INT 12
56180: PUSH
56181: LD_INT 14
56183: PUSH
56184: LD_INT 13
56186: PUSH
56187: EMPTY
56188: LIST
56189: LIST
56190: LIST
56191: LIST
56192: PUSH
56193: LD_VAR 0 2
56197: PUSH
56198: LD_INT 9
56200: MINUS
56201: ARRAY
56202: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56203: LD_ADDR_OWVAR 45
56207: PUSH
56208: LD_INT 11
56210: PUSH
56211: LD_INT 15
56213: PUSH
56214: LD_INT 12
56216: PUSH
56217: LD_INT 15
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: LIST
56224: LIST
56225: PUSH
56226: LD_VAR 0 2
56230: PUSH
56231: LD_INT 9
56233: MINUS
56234: ARRAY
56235: ST_TO_ADDR
// end ; 14 :
56236: GO 56655
56238: LD_INT 14
56240: DOUBLE
56241: EQUAL
56242: IFTRUE 56246
56244: GO 56257
56246: POP
// bc_type := b_workshop ; 15 :
56247: LD_ADDR_OWVAR 42
56251: PUSH
56252: LD_INT 2
56254: ST_TO_ADDR
56255: GO 56655
56257: LD_INT 15
56259: DOUBLE
56260: EQUAL
56261: IFTRUE 56265
56263: GO 56276
56265: POP
// bc_type := b_factory ; 16 :
56266: LD_ADDR_OWVAR 42
56270: PUSH
56271: LD_INT 3
56273: ST_TO_ADDR
56274: GO 56655
56276: LD_INT 16
56278: DOUBLE
56279: EQUAL
56280: IFTRUE 56284
56282: GO 56295
56284: POP
// bc_type := b_ext_gun ; 17 :
56285: LD_ADDR_OWVAR 42
56289: PUSH
56290: LD_INT 17
56292: ST_TO_ADDR
56293: GO 56655
56295: LD_INT 17
56297: DOUBLE
56298: EQUAL
56299: IFTRUE 56303
56301: GO 56331
56303: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56304: LD_ADDR_OWVAR 42
56308: PUSH
56309: LD_INT 19
56311: PUSH
56312: LD_INT 23
56314: PUSH
56315: LD_INT 19
56317: PUSH
56318: EMPTY
56319: LIST
56320: LIST
56321: LIST
56322: PUSH
56323: LD_VAR 0 1
56327: ARRAY
56328: ST_TO_ADDR
56329: GO 56655
56331: LD_INT 18
56333: DOUBLE
56334: EQUAL
56335: IFTRUE 56339
56337: GO 56350
56339: POP
// bc_type := b_ext_radar ; 19 :
56340: LD_ADDR_OWVAR 42
56344: PUSH
56345: LD_INT 20
56347: ST_TO_ADDR
56348: GO 56655
56350: LD_INT 19
56352: DOUBLE
56353: EQUAL
56354: IFTRUE 56358
56356: GO 56369
56358: POP
// bc_type := b_ext_radio ; 20 :
56359: LD_ADDR_OWVAR 42
56363: PUSH
56364: LD_INT 22
56366: ST_TO_ADDR
56367: GO 56655
56369: LD_INT 20
56371: DOUBLE
56372: EQUAL
56373: IFTRUE 56377
56375: GO 56388
56377: POP
// bc_type := b_ext_siberium ; 21 :
56378: LD_ADDR_OWVAR 42
56382: PUSH
56383: LD_INT 21
56385: ST_TO_ADDR
56386: GO 56655
56388: LD_INT 21
56390: DOUBLE
56391: EQUAL
56392: IFTRUE 56396
56394: GO 56407
56396: POP
// bc_type := b_ext_computer ; 22 :
56397: LD_ADDR_OWVAR 42
56401: PUSH
56402: LD_INT 24
56404: ST_TO_ADDR
56405: GO 56655
56407: LD_INT 22
56409: DOUBLE
56410: EQUAL
56411: IFTRUE 56415
56413: GO 56426
56415: POP
// bc_type := b_ext_track ; 23 :
56416: LD_ADDR_OWVAR 42
56420: PUSH
56421: LD_INT 16
56423: ST_TO_ADDR
56424: GO 56655
56426: LD_INT 23
56428: DOUBLE
56429: EQUAL
56430: IFTRUE 56434
56432: GO 56445
56434: POP
// bc_type := b_ext_laser ; 24 :
56435: LD_ADDR_OWVAR 42
56439: PUSH
56440: LD_INT 25
56442: ST_TO_ADDR
56443: GO 56655
56445: LD_INT 24
56447: DOUBLE
56448: EQUAL
56449: IFTRUE 56453
56451: GO 56464
56453: POP
// bc_type := b_control_tower ; 25 :
56454: LD_ADDR_OWVAR 42
56458: PUSH
56459: LD_INT 36
56461: ST_TO_ADDR
56462: GO 56655
56464: LD_INT 25
56466: DOUBLE
56467: EQUAL
56468: IFTRUE 56472
56470: GO 56483
56472: POP
// bc_type := b_breastwork ; 26 :
56473: LD_ADDR_OWVAR 42
56477: PUSH
56478: LD_INT 31
56480: ST_TO_ADDR
56481: GO 56655
56483: LD_INT 26
56485: DOUBLE
56486: EQUAL
56487: IFTRUE 56491
56489: GO 56502
56491: POP
// bc_type := b_bunker ; 27 :
56492: LD_ADDR_OWVAR 42
56496: PUSH
56497: LD_INT 32
56499: ST_TO_ADDR
56500: GO 56655
56502: LD_INT 27
56504: DOUBLE
56505: EQUAL
56506: IFTRUE 56510
56508: GO 56521
56510: POP
// bc_type := b_turret ; 28 :
56511: LD_ADDR_OWVAR 42
56515: PUSH
56516: LD_INT 33
56518: ST_TO_ADDR
56519: GO 56655
56521: LD_INT 28
56523: DOUBLE
56524: EQUAL
56525: IFTRUE 56529
56527: GO 56540
56529: POP
// bc_type := b_armoury ; 29 :
56530: LD_ADDR_OWVAR 42
56534: PUSH
56535: LD_INT 4
56537: ST_TO_ADDR
56538: GO 56655
56540: LD_INT 29
56542: DOUBLE
56543: EQUAL
56544: IFTRUE 56548
56546: GO 56559
56548: POP
// bc_type := b_barracks ; 30 :
56549: LD_ADDR_OWVAR 42
56553: PUSH
56554: LD_INT 5
56556: ST_TO_ADDR
56557: GO 56655
56559: LD_INT 30
56561: DOUBLE
56562: EQUAL
56563: IFTRUE 56567
56565: GO 56578
56567: POP
// bc_type := b_solar_power ; 31 :
56568: LD_ADDR_OWVAR 42
56572: PUSH
56573: LD_INT 27
56575: ST_TO_ADDR
56576: GO 56655
56578: LD_INT 31
56580: DOUBLE
56581: EQUAL
56582: IFTRUE 56586
56584: GO 56597
56586: POP
// bc_type := b_oil_power ; 32 :
56587: LD_ADDR_OWVAR 42
56591: PUSH
56592: LD_INT 26
56594: ST_TO_ADDR
56595: GO 56655
56597: LD_INT 32
56599: DOUBLE
56600: EQUAL
56601: IFTRUE 56605
56603: GO 56616
56605: POP
// bc_type := b_siberite_power ; 33 :
56606: LD_ADDR_OWVAR 42
56610: PUSH
56611: LD_INT 28
56613: ST_TO_ADDR
56614: GO 56655
56616: LD_INT 33
56618: DOUBLE
56619: EQUAL
56620: IFTRUE 56624
56622: GO 56635
56624: POP
// bc_type := b_oil_mine ; 34 :
56625: LD_ADDR_OWVAR 42
56629: PUSH
56630: LD_INT 29
56632: ST_TO_ADDR
56633: GO 56655
56635: LD_INT 34
56637: DOUBLE
56638: EQUAL
56639: IFTRUE 56643
56641: GO 56654
56643: POP
// bc_type := b_siberite_mine ; end ;
56644: LD_ADDR_OWVAR 42
56648: PUSH
56649: LD_INT 30
56651: ST_TO_ADDR
56652: GO 56655
56654: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56655: LD_ADDR_VAR 0 8
56659: PUSH
56660: LD_VAR 0 5
56664: PPUSH
56665: LD_VAR 0 6
56669: PPUSH
56670: LD_VAR 0 3
56674: PPUSH
56675: CALL_OW 47
56679: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56680: LD_OWVAR 42
56684: PUSH
56685: LD_INT 32
56687: PUSH
56688: LD_INT 33
56690: PUSH
56691: EMPTY
56692: LIST
56693: LIST
56694: IN
56695: IFFALSE 56711
// PlaceWeaponTurret ( b , weapon ) ;
56697: LD_VAR 0 8
56701: PPUSH
56702: LD_VAR 0 4
56706: PPUSH
56707: CALL_OW 431
// end ;
56711: LD_VAR 0 7
56715: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56716: LD_INT 0
56718: PPUSH
56719: PPUSH
56720: PPUSH
56721: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56722: LD_ADDR_VAR 0 4
56726: PUSH
56727: LD_INT 22
56729: PUSH
56730: LD_OWVAR 2
56734: PUSH
56735: EMPTY
56736: LIST
56737: LIST
56738: PUSH
56739: LD_INT 2
56741: PUSH
56742: LD_INT 30
56744: PUSH
56745: LD_INT 0
56747: PUSH
56748: EMPTY
56749: LIST
56750: LIST
56751: PUSH
56752: LD_INT 30
56754: PUSH
56755: LD_INT 1
56757: PUSH
56758: EMPTY
56759: LIST
56760: LIST
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: LIST
56766: PUSH
56767: EMPTY
56768: LIST
56769: LIST
56770: PPUSH
56771: CALL_OW 69
56775: ST_TO_ADDR
// if not tmp then
56776: LD_VAR 0 4
56780: NOT
56781: IFFALSE 56785
// exit ;
56783: GO 56844
// for i in tmp do
56785: LD_ADDR_VAR 0 2
56789: PUSH
56790: LD_VAR 0 4
56794: PUSH
56795: FOR_IN
56796: IFFALSE 56842
// for j = 1 to 3 do
56798: LD_ADDR_VAR 0 3
56802: PUSH
56803: DOUBLE
56804: LD_INT 1
56806: DEC
56807: ST_TO_ADDR
56808: LD_INT 3
56810: PUSH
56811: FOR_TO
56812: IFFALSE 56838
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56814: LD_VAR 0 2
56818: PPUSH
56819: CALL_OW 274
56823: PPUSH
56824: LD_VAR 0 3
56828: PPUSH
56829: LD_INT 99999
56831: PPUSH
56832: CALL_OW 277
56836: GO 56811
56838: POP
56839: POP
56840: GO 56795
56842: POP
56843: POP
// end ;
56844: LD_VAR 0 1
56848: RET
// export function hHackSetLevel10 ; var i , j ; begin
56849: LD_INT 0
56851: PPUSH
56852: PPUSH
56853: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56854: LD_ADDR_VAR 0 2
56858: PUSH
56859: LD_INT 21
56861: PUSH
56862: LD_INT 1
56864: PUSH
56865: EMPTY
56866: LIST
56867: LIST
56868: PPUSH
56869: CALL_OW 69
56873: PUSH
56874: FOR_IN
56875: IFFALSE 56927
// if IsSelected ( i ) then
56877: LD_VAR 0 2
56881: PPUSH
56882: CALL_OW 306
56886: IFFALSE 56925
// begin for j := 1 to 4 do
56888: LD_ADDR_VAR 0 3
56892: PUSH
56893: DOUBLE
56894: LD_INT 1
56896: DEC
56897: ST_TO_ADDR
56898: LD_INT 4
56900: PUSH
56901: FOR_TO
56902: IFFALSE 56923
// SetSkill ( i , j , 10 ) ;
56904: LD_VAR 0 2
56908: PPUSH
56909: LD_VAR 0 3
56913: PPUSH
56914: LD_INT 10
56916: PPUSH
56917: CALL_OW 237
56921: GO 56901
56923: POP
56924: POP
// end ;
56925: GO 56874
56927: POP
56928: POP
// end ;
56929: LD_VAR 0 1
56933: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56934: LD_INT 0
56936: PPUSH
56937: PPUSH
56938: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56939: LD_ADDR_VAR 0 2
56943: PUSH
56944: LD_INT 22
56946: PUSH
56947: LD_OWVAR 2
56951: PUSH
56952: EMPTY
56953: LIST
56954: LIST
56955: PUSH
56956: LD_INT 21
56958: PUSH
56959: LD_INT 1
56961: PUSH
56962: EMPTY
56963: LIST
56964: LIST
56965: PUSH
56966: EMPTY
56967: LIST
56968: LIST
56969: PPUSH
56970: CALL_OW 69
56974: PUSH
56975: FOR_IN
56976: IFFALSE 57017
// begin for j := 1 to 4 do
56978: LD_ADDR_VAR 0 3
56982: PUSH
56983: DOUBLE
56984: LD_INT 1
56986: DEC
56987: ST_TO_ADDR
56988: LD_INT 4
56990: PUSH
56991: FOR_TO
56992: IFFALSE 57013
// SetSkill ( i , j , 10 ) ;
56994: LD_VAR 0 2
56998: PPUSH
56999: LD_VAR 0 3
57003: PPUSH
57004: LD_INT 10
57006: PPUSH
57007: CALL_OW 237
57011: GO 56991
57013: POP
57014: POP
// end ;
57015: GO 56975
57017: POP
57018: POP
// end ;
57019: LD_VAR 0 1
57023: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
57024: LD_INT 0
57026: PPUSH
// uc_side := your_side ;
57027: LD_ADDR_OWVAR 20
57031: PUSH
57032: LD_OWVAR 2
57036: ST_TO_ADDR
// uc_nation := nation ;
57037: LD_ADDR_OWVAR 21
57041: PUSH
57042: LD_VAR 0 1
57046: ST_TO_ADDR
// InitHc ;
57047: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
57051: LD_INT 0
57053: PPUSH
57054: LD_VAR 0 2
57058: PPUSH
57059: LD_VAR 0 3
57063: PPUSH
57064: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
57068: LD_VAR 0 4
57072: PPUSH
57073: LD_VAR 0 5
57077: PPUSH
57078: CALL_OW 428
57082: PUSH
57083: LD_INT 0
57085: EQUAL
57086: IFFALSE 57110
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
57088: CALL_OW 44
57092: PPUSH
57093: LD_VAR 0 4
57097: PPUSH
57098: LD_VAR 0 5
57102: PPUSH
57103: LD_INT 1
57105: PPUSH
57106: CALL_OW 48
// end ;
57110: LD_VAR 0 6
57114: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
57115: LD_INT 0
57117: PPUSH
57118: PPUSH
// uc_side := your_side ;
57119: LD_ADDR_OWVAR 20
57123: PUSH
57124: LD_OWVAR 2
57128: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
57129: LD_VAR 0 1
57133: PUSH
57134: LD_INT 1
57136: PUSH
57137: LD_INT 2
57139: PUSH
57140: LD_INT 3
57142: PUSH
57143: LD_INT 4
57145: PUSH
57146: LD_INT 5
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: LIST
57153: LIST
57154: LIST
57155: IN
57156: IFFALSE 57168
// uc_nation := nation_american else
57158: LD_ADDR_OWVAR 21
57162: PUSH
57163: LD_INT 1
57165: ST_TO_ADDR
57166: GO 57211
// if chassis in [ 11 , 12 , 13 , 14 ] then
57168: LD_VAR 0 1
57172: PUSH
57173: LD_INT 11
57175: PUSH
57176: LD_INT 12
57178: PUSH
57179: LD_INT 13
57181: PUSH
57182: LD_INT 14
57184: PUSH
57185: EMPTY
57186: LIST
57187: LIST
57188: LIST
57189: LIST
57190: IN
57191: IFFALSE 57203
// uc_nation := nation_arabian else
57193: LD_ADDR_OWVAR 21
57197: PUSH
57198: LD_INT 2
57200: ST_TO_ADDR
57201: GO 57211
// uc_nation := nation_russian ;
57203: LD_ADDR_OWVAR 21
57207: PUSH
57208: LD_INT 3
57210: ST_TO_ADDR
// vc_chassis := chassis ;
57211: LD_ADDR_OWVAR 37
57215: PUSH
57216: LD_VAR 0 1
57220: ST_TO_ADDR
// vc_engine := engine ;
57221: LD_ADDR_OWVAR 39
57225: PUSH
57226: LD_VAR 0 2
57230: ST_TO_ADDR
// vc_control := control ;
57231: LD_ADDR_OWVAR 38
57235: PUSH
57236: LD_VAR 0 3
57240: ST_TO_ADDR
// vc_weapon := weapon ;
57241: LD_ADDR_OWVAR 40
57245: PUSH
57246: LD_VAR 0 4
57250: ST_TO_ADDR
// un := CreateVehicle ;
57251: LD_ADDR_VAR 0 8
57255: PUSH
57256: CALL_OW 45
57260: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57261: LD_VAR 0 8
57265: PPUSH
57266: LD_INT 0
57268: PPUSH
57269: LD_INT 5
57271: PPUSH
57272: CALL_OW 12
57276: PPUSH
57277: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57281: LD_VAR 0 8
57285: PPUSH
57286: LD_VAR 0 5
57290: PPUSH
57291: LD_VAR 0 6
57295: PPUSH
57296: LD_INT 1
57298: PPUSH
57299: CALL_OW 48
// end ;
57303: LD_VAR 0 7
57307: RET
// export hInvincible ; every 1 do
57308: GO 57310
57310: DISABLE
// hInvincible := [ ] ;
57311: LD_ADDR_EXP 131
57315: PUSH
57316: EMPTY
57317: ST_TO_ADDR
57318: END
// every 10 do var i ;
57319: GO 57321
57321: DISABLE
57322: LD_INT 0
57324: PPUSH
// begin enable ;
57325: ENABLE
// if not hInvincible then
57326: LD_EXP 131
57330: NOT
57331: IFFALSE 57335
// exit ;
57333: GO 57379
// for i in hInvincible do
57335: LD_ADDR_VAR 0 1
57339: PUSH
57340: LD_EXP 131
57344: PUSH
57345: FOR_IN
57346: IFFALSE 57377
// if GetLives ( i ) < 1000 then
57348: LD_VAR 0 1
57352: PPUSH
57353: CALL_OW 256
57357: PUSH
57358: LD_INT 1000
57360: LESS
57361: IFFALSE 57375
// SetLives ( i , 1000 ) ;
57363: LD_VAR 0 1
57367: PPUSH
57368: LD_INT 1000
57370: PPUSH
57371: CALL_OW 234
57375: GO 57345
57377: POP
57378: POP
// end ;
57379: PPOPN 1
57381: END
// export function hHackInvincible ; var i ; begin
57382: LD_INT 0
57384: PPUSH
57385: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57386: LD_ADDR_VAR 0 2
57390: PUSH
57391: LD_INT 2
57393: PUSH
57394: LD_INT 21
57396: PUSH
57397: LD_INT 1
57399: PUSH
57400: EMPTY
57401: LIST
57402: LIST
57403: PUSH
57404: LD_INT 21
57406: PUSH
57407: LD_INT 2
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: PUSH
57414: EMPTY
57415: LIST
57416: LIST
57417: LIST
57418: PPUSH
57419: CALL_OW 69
57423: PUSH
57424: FOR_IN
57425: IFFALSE 57486
// if IsSelected ( i ) then
57427: LD_VAR 0 2
57431: PPUSH
57432: CALL_OW 306
57436: IFFALSE 57484
// begin if i in hInvincible then
57438: LD_VAR 0 2
57442: PUSH
57443: LD_EXP 131
57447: IN
57448: IFFALSE 57468
// hInvincible := hInvincible diff i else
57450: LD_ADDR_EXP 131
57454: PUSH
57455: LD_EXP 131
57459: PUSH
57460: LD_VAR 0 2
57464: DIFF
57465: ST_TO_ADDR
57466: GO 57484
// hInvincible := hInvincible union i ;
57468: LD_ADDR_EXP 131
57472: PUSH
57473: LD_EXP 131
57477: PUSH
57478: LD_VAR 0 2
57482: UNION
57483: ST_TO_ADDR
// end ;
57484: GO 57424
57486: POP
57487: POP
// end ;
57488: LD_VAR 0 1
57492: RET
// export function hHackInvisible ; var i , j ; begin
57493: LD_INT 0
57495: PPUSH
57496: PPUSH
57497: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57498: LD_ADDR_VAR 0 2
57502: PUSH
57503: LD_INT 21
57505: PUSH
57506: LD_INT 1
57508: PUSH
57509: EMPTY
57510: LIST
57511: LIST
57512: PPUSH
57513: CALL_OW 69
57517: PUSH
57518: FOR_IN
57519: IFFALSE 57543
// if IsSelected ( i ) then
57521: LD_VAR 0 2
57525: PPUSH
57526: CALL_OW 306
57530: IFFALSE 57541
// ComForceInvisible ( i ) ;
57532: LD_VAR 0 2
57536: PPUSH
57537: CALL_OW 496
57541: GO 57518
57543: POP
57544: POP
// end ;
57545: LD_VAR 0 1
57549: RET
// export function hHackChangeYourSide ; begin
57550: LD_INT 0
57552: PPUSH
// if your_side = 8 then
57553: LD_OWVAR 2
57557: PUSH
57558: LD_INT 8
57560: EQUAL
57561: IFFALSE 57573
// your_side := 0 else
57563: LD_ADDR_OWVAR 2
57567: PUSH
57568: LD_INT 0
57570: ST_TO_ADDR
57571: GO 57587
// your_side := your_side + 1 ;
57573: LD_ADDR_OWVAR 2
57577: PUSH
57578: LD_OWVAR 2
57582: PUSH
57583: LD_INT 1
57585: PLUS
57586: ST_TO_ADDR
// end ;
57587: LD_VAR 0 1
57591: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57592: LD_INT 0
57594: PPUSH
57595: PPUSH
57596: PPUSH
// for i in all_units do
57597: LD_ADDR_VAR 0 2
57601: PUSH
57602: LD_OWVAR 3
57606: PUSH
57607: FOR_IN
57608: IFFALSE 57686
// if IsSelected ( i ) then
57610: LD_VAR 0 2
57614: PPUSH
57615: CALL_OW 306
57619: IFFALSE 57684
// begin j := GetSide ( i ) ;
57621: LD_ADDR_VAR 0 3
57625: PUSH
57626: LD_VAR 0 2
57630: PPUSH
57631: CALL_OW 255
57635: ST_TO_ADDR
// if j = 8 then
57636: LD_VAR 0 3
57640: PUSH
57641: LD_INT 8
57643: EQUAL
57644: IFFALSE 57656
// j := 0 else
57646: LD_ADDR_VAR 0 3
57650: PUSH
57651: LD_INT 0
57653: ST_TO_ADDR
57654: GO 57670
// j := j + 1 ;
57656: LD_ADDR_VAR 0 3
57660: PUSH
57661: LD_VAR 0 3
57665: PUSH
57666: LD_INT 1
57668: PLUS
57669: ST_TO_ADDR
// SetSide ( i , j ) ;
57670: LD_VAR 0 2
57674: PPUSH
57675: LD_VAR 0 3
57679: PPUSH
57680: CALL_OW 235
// end ;
57684: GO 57607
57686: POP
57687: POP
// end ;
57688: LD_VAR 0 1
57692: RET
// export function hHackFog ; begin
57693: LD_INT 0
57695: PPUSH
// FogOff ( true ) ;
57696: LD_INT 1
57698: PPUSH
57699: CALL_OW 344
// end ;
57703: LD_VAR 0 1
57707: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57708: LD_INT 0
57710: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57711: LD_VAR 0 1
57715: PPUSH
57716: LD_VAR 0 2
57720: PPUSH
57721: LD_VAR 0 3
57725: PPUSH
57726: LD_INT 1
57728: PPUSH
57729: LD_INT 1
57731: PPUSH
57732: CALL_OW 483
// CenterOnXY ( x , y ) ;
57736: LD_VAR 0 2
57740: PPUSH
57741: LD_VAR 0 3
57745: PPUSH
57746: CALL_OW 84
// end ;
57750: LD_VAR 0 4
57754: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
57755: LD_INT 0
57757: PPUSH
57758: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
57759: LD_VAR 0 1
57763: NOT
57764: PUSH
57765: LD_VAR 0 2
57769: PPUSH
57770: LD_VAR 0 3
57774: PPUSH
57775: CALL_OW 488
57779: NOT
57780: OR
57781: PUSH
57782: LD_VAR 0 1
57786: PPUSH
57787: CALL_OW 266
57791: PUSH
57792: LD_INT 3
57794: NONEQUAL
57795: PUSH
57796: LD_VAR 0 1
57800: PPUSH
57801: CALL_OW 247
57805: PUSH
57806: LD_INT 1
57808: EQUAL
57809: NOT
57810: AND
57811: OR
57812: IFFALSE 57816
// exit ;
57814: GO 57965
// if GetType ( factory ) = unit_human then
57816: LD_VAR 0 1
57820: PPUSH
57821: CALL_OW 247
57825: PUSH
57826: LD_INT 1
57828: EQUAL
57829: IFFALSE 57846
// factory := IsInUnit ( factory ) ;
57831: LD_ADDR_VAR 0 1
57835: PUSH
57836: LD_VAR 0 1
57840: PPUSH
57841: CALL_OW 310
57845: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
57846: LD_VAR 0 1
57850: PPUSH
57851: CALL_OW 266
57855: PUSH
57856: LD_INT 3
57858: NONEQUAL
57859: IFFALSE 57863
// exit ;
57861: GO 57965
// if HexInfo ( x , y ) = factory then
57863: LD_VAR 0 2
57867: PPUSH
57868: LD_VAR 0 3
57872: PPUSH
57873: CALL_OW 428
57877: PUSH
57878: LD_VAR 0 1
57882: EQUAL
57883: IFFALSE 57910
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
57885: LD_ADDR_EXP 132
57889: PUSH
57890: LD_EXP 132
57894: PPUSH
57895: LD_VAR 0 1
57899: PPUSH
57900: LD_INT 0
57902: PPUSH
57903: CALL_OW 1
57907: ST_TO_ADDR
57908: GO 57961
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
57910: LD_ADDR_EXP 132
57914: PUSH
57915: LD_EXP 132
57919: PPUSH
57920: LD_VAR 0 1
57924: PPUSH
57925: LD_VAR 0 1
57929: PPUSH
57930: CALL_OW 255
57934: PUSH
57935: LD_VAR 0 1
57939: PUSH
57940: LD_VAR 0 2
57944: PUSH
57945: LD_VAR 0 3
57949: PUSH
57950: EMPTY
57951: LIST
57952: LIST
57953: LIST
57954: LIST
57955: PPUSH
57956: CALL_OW 1
57960: ST_TO_ADDR
// UpdateFactoryWaypoints ;
57961: CALL 57970 0 0
// end ;
57965: LD_VAR 0 4
57969: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
57970: LD_INT 0
57972: PPUSH
57973: PPUSH
57974: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
57975: LD_STRING resetFactoryWaypoint();
57977: PPUSH
57978: CALL_OW 559
// if factoryWaypoints then
57982: LD_EXP 132
57986: IFFALSE 58112
// begin list := PrepareArray ( factoryWaypoints ) ;
57988: LD_ADDR_VAR 0 3
57992: PUSH
57993: LD_EXP 132
57997: PPUSH
57998: CALL 104434 0 1
58002: ST_TO_ADDR
// for i := 1 to list do
58003: LD_ADDR_VAR 0 2
58007: PUSH
58008: DOUBLE
58009: LD_INT 1
58011: DEC
58012: ST_TO_ADDR
58013: LD_VAR 0 3
58017: PUSH
58018: FOR_TO
58019: IFFALSE 58110
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58021: LD_STRING setFactoryWaypointXY(
58023: PUSH
58024: LD_VAR 0 3
58028: PUSH
58029: LD_VAR 0 2
58033: ARRAY
58034: PUSH
58035: LD_INT 1
58037: ARRAY
58038: STR
58039: PUSH
58040: LD_STRING ,
58042: STR
58043: PUSH
58044: LD_VAR 0 3
58048: PUSH
58049: LD_VAR 0 2
58053: ARRAY
58054: PUSH
58055: LD_INT 2
58057: ARRAY
58058: STR
58059: PUSH
58060: LD_STRING ,
58062: STR
58063: PUSH
58064: LD_VAR 0 3
58068: PUSH
58069: LD_VAR 0 2
58073: ARRAY
58074: PUSH
58075: LD_INT 3
58077: ARRAY
58078: STR
58079: PUSH
58080: LD_STRING ,
58082: STR
58083: PUSH
58084: LD_VAR 0 3
58088: PUSH
58089: LD_VAR 0 2
58093: ARRAY
58094: PUSH
58095: LD_INT 4
58097: ARRAY
58098: STR
58099: PUSH
58100: LD_STRING )
58102: STR
58103: PPUSH
58104: CALL_OW 559
58108: GO 58018
58110: POP
58111: POP
// end ; end ;
58112: LD_VAR 0 1
58116: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
58117: LD_INT 0
58119: PPUSH
// if HexInfo ( x , y ) = warehouse then
58120: LD_VAR 0 2
58124: PPUSH
58125: LD_VAR 0 3
58129: PPUSH
58130: CALL_OW 428
58134: PUSH
58135: LD_VAR 0 1
58139: EQUAL
58140: IFFALSE 58167
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
58142: LD_ADDR_EXP 133
58146: PUSH
58147: LD_EXP 133
58151: PPUSH
58152: LD_VAR 0 1
58156: PPUSH
58157: LD_INT 0
58159: PPUSH
58160: CALL_OW 1
58164: ST_TO_ADDR
58165: GO 58218
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
58167: LD_ADDR_EXP 133
58171: PUSH
58172: LD_EXP 133
58176: PPUSH
58177: LD_VAR 0 1
58181: PPUSH
58182: LD_VAR 0 1
58186: PPUSH
58187: CALL_OW 255
58191: PUSH
58192: LD_VAR 0 1
58196: PUSH
58197: LD_VAR 0 2
58201: PUSH
58202: LD_VAR 0 3
58206: PUSH
58207: EMPTY
58208: LIST
58209: LIST
58210: LIST
58211: LIST
58212: PPUSH
58213: CALL_OW 1
58217: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
58218: CALL 58227 0 0
// end ;
58222: LD_VAR 0 4
58226: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
58227: LD_INT 0
58229: PPUSH
58230: PPUSH
58231: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
58232: LD_STRING resetWarehouseGatheringPoints();
58234: PPUSH
58235: CALL_OW 559
// if warehouseGatheringPoints then
58239: LD_EXP 133
58243: IFFALSE 58369
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
58245: LD_ADDR_VAR 0 3
58249: PUSH
58250: LD_EXP 133
58254: PPUSH
58255: CALL 104434 0 1
58259: ST_TO_ADDR
// for i := 1 to list do
58260: LD_ADDR_VAR 0 2
58264: PUSH
58265: DOUBLE
58266: LD_INT 1
58268: DEC
58269: ST_TO_ADDR
58270: LD_VAR 0 3
58274: PUSH
58275: FOR_TO
58276: IFFALSE 58367
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58278: LD_STRING setWarehouseGatheringPointXY(
58280: PUSH
58281: LD_VAR 0 3
58285: PUSH
58286: LD_VAR 0 2
58290: ARRAY
58291: PUSH
58292: LD_INT 1
58294: ARRAY
58295: STR
58296: PUSH
58297: LD_STRING ,
58299: STR
58300: PUSH
58301: LD_VAR 0 3
58305: PUSH
58306: LD_VAR 0 2
58310: ARRAY
58311: PUSH
58312: LD_INT 2
58314: ARRAY
58315: STR
58316: PUSH
58317: LD_STRING ,
58319: STR
58320: PUSH
58321: LD_VAR 0 3
58325: PUSH
58326: LD_VAR 0 2
58330: ARRAY
58331: PUSH
58332: LD_INT 3
58334: ARRAY
58335: STR
58336: PUSH
58337: LD_STRING ,
58339: STR
58340: PUSH
58341: LD_VAR 0 3
58345: PUSH
58346: LD_VAR 0 2
58350: ARRAY
58351: PUSH
58352: LD_INT 4
58354: ARRAY
58355: STR
58356: PUSH
58357: LD_STRING )
58359: STR
58360: PPUSH
58361: CALL_OW 559
58365: GO 58275
58367: POP
58368: POP
// end ; end ;
58369: LD_VAR 0 1
58373: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
58374: LD_EXP 133
58378: IFFALSE 59063
58380: GO 58382
58382: DISABLE
58383: LD_INT 0
58385: PPUSH
58386: PPUSH
58387: PPUSH
58388: PPUSH
58389: PPUSH
58390: PPUSH
58391: PPUSH
58392: PPUSH
58393: PPUSH
// begin enable ;
58394: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
58395: LD_ADDR_VAR 0 3
58399: PUSH
58400: LD_EXP 133
58404: PPUSH
58405: CALL 104434 0 1
58409: ST_TO_ADDR
// if not list then
58410: LD_VAR 0 3
58414: NOT
58415: IFFALSE 58419
// exit ;
58417: GO 59063
// for i := 1 to list do
58419: LD_ADDR_VAR 0 1
58423: PUSH
58424: DOUBLE
58425: LD_INT 1
58427: DEC
58428: ST_TO_ADDR
58429: LD_VAR 0 3
58433: PUSH
58434: FOR_TO
58435: IFFALSE 59061
// begin depot := list [ i ] [ 2 ] ;
58437: LD_ADDR_VAR 0 8
58441: PUSH
58442: LD_VAR 0 3
58446: PUSH
58447: LD_VAR 0 1
58451: ARRAY
58452: PUSH
58453: LD_INT 2
58455: ARRAY
58456: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
58457: LD_ADDR_VAR 0 5
58461: PUSH
58462: LD_VAR 0 3
58466: PUSH
58467: LD_VAR 0 1
58471: ARRAY
58472: PUSH
58473: LD_INT 1
58475: ARRAY
58476: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
58477: LD_VAR 0 8
58481: PPUSH
58482: CALL_OW 301
58486: PUSH
58487: LD_VAR 0 5
58491: PUSH
58492: LD_VAR 0 8
58496: PPUSH
58497: CALL_OW 255
58501: NONEQUAL
58502: OR
58503: IFFALSE 58532
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
58505: LD_ADDR_EXP 133
58509: PUSH
58510: LD_EXP 133
58514: PPUSH
58515: LD_VAR 0 8
58519: PPUSH
58520: LD_INT 0
58522: PPUSH
58523: CALL_OW 1
58527: ST_TO_ADDR
// exit ;
58528: POP
58529: POP
58530: GO 59063
// end ; x := list [ i ] [ 3 ] ;
58532: LD_ADDR_VAR 0 6
58536: PUSH
58537: LD_VAR 0 3
58541: PUSH
58542: LD_VAR 0 1
58546: ARRAY
58547: PUSH
58548: LD_INT 3
58550: ARRAY
58551: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
58552: LD_ADDR_VAR 0 7
58556: PUSH
58557: LD_VAR 0 3
58561: PUSH
58562: LD_VAR 0 1
58566: ARRAY
58567: PUSH
58568: LD_INT 4
58570: ARRAY
58571: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
58572: LD_ADDR_VAR 0 9
58576: PUSH
58577: LD_VAR 0 6
58581: PPUSH
58582: LD_VAR 0 7
58586: PPUSH
58587: LD_INT 16
58589: PPUSH
58590: CALL 103022 0 3
58594: ST_TO_ADDR
// if not cratesNearbyPoint then
58595: LD_VAR 0 9
58599: NOT
58600: IFFALSE 58606
// exit ;
58602: POP
58603: POP
58604: GO 59063
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
58606: LD_ADDR_VAR 0 4
58610: PUSH
58611: LD_INT 22
58613: PUSH
58614: LD_VAR 0 5
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: PUSH
58623: LD_INT 3
58625: PUSH
58626: LD_INT 60
58628: PUSH
58629: EMPTY
58630: LIST
58631: PUSH
58632: EMPTY
58633: LIST
58634: LIST
58635: PUSH
58636: LD_INT 91
58638: PUSH
58639: LD_VAR 0 8
58643: PUSH
58644: LD_INT 6
58646: PUSH
58647: EMPTY
58648: LIST
58649: LIST
58650: LIST
58651: PUSH
58652: LD_INT 2
58654: PUSH
58655: LD_INT 25
58657: PUSH
58658: LD_INT 2
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: PUSH
58665: LD_INT 25
58667: PUSH
58668: LD_INT 16
58670: PUSH
58671: EMPTY
58672: LIST
58673: LIST
58674: PUSH
58675: EMPTY
58676: LIST
58677: LIST
58678: LIST
58679: PUSH
58680: EMPTY
58681: LIST
58682: LIST
58683: LIST
58684: LIST
58685: PPUSH
58686: CALL_OW 69
58690: PUSH
58691: LD_VAR 0 8
58695: PPUSH
58696: CALL_OW 313
58700: PPUSH
58701: LD_INT 3
58703: PUSH
58704: LD_INT 60
58706: PUSH
58707: EMPTY
58708: LIST
58709: PUSH
58710: EMPTY
58711: LIST
58712: LIST
58713: PUSH
58714: LD_INT 2
58716: PUSH
58717: LD_INT 25
58719: PUSH
58720: LD_INT 2
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: PUSH
58727: LD_INT 25
58729: PUSH
58730: LD_INT 16
58732: PUSH
58733: EMPTY
58734: LIST
58735: LIST
58736: PUSH
58737: EMPTY
58738: LIST
58739: LIST
58740: LIST
58741: PUSH
58742: EMPTY
58743: LIST
58744: LIST
58745: PPUSH
58746: CALL_OW 72
58750: UNION
58751: ST_TO_ADDR
// if tmp then
58752: LD_VAR 0 4
58756: IFFALSE 58836
// begin tmp := ShrinkArray ( tmp , 3 ) ;
58758: LD_ADDR_VAR 0 4
58762: PUSH
58763: LD_VAR 0 4
58767: PPUSH
58768: LD_INT 3
58770: PPUSH
58771: CALL 100991 0 2
58775: ST_TO_ADDR
// for j in tmp do
58776: LD_ADDR_VAR 0 2
58780: PUSH
58781: LD_VAR 0 4
58785: PUSH
58786: FOR_IN
58787: IFFALSE 58830
// begin if IsInUnit ( j ) then
58789: LD_VAR 0 2
58793: PPUSH
58794: CALL_OW 310
58798: IFFALSE 58809
// ComExit ( j ) ;
58800: LD_VAR 0 2
58804: PPUSH
58805: CALL 101074 0 1
// AddComCollect ( j , x , y ) ;
58809: LD_VAR 0 2
58813: PPUSH
58814: LD_VAR 0 6
58818: PPUSH
58819: LD_VAR 0 7
58823: PPUSH
58824: CALL_OW 177
// end ;
58828: GO 58786
58830: POP
58831: POP
// exit ;
58832: POP
58833: POP
58834: GO 59063
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
58836: LD_ADDR_VAR 0 4
58840: PUSH
58841: LD_INT 22
58843: PUSH
58844: LD_VAR 0 5
58848: PUSH
58849: EMPTY
58850: LIST
58851: LIST
58852: PUSH
58853: LD_INT 91
58855: PUSH
58856: LD_VAR 0 8
58860: PUSH
58861: LD_INT 8
58863: PUSH
58864: EMPTY
58865: LIST
58866: LIST
58867: LIST
58868: PUSH
58869: LD_INT 2
58871: PUSH
58872: LD_INT 34
58874: PUSH
58875: LD_INT 12
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: PUSH
58882: LD_INT 34
58884: PUSH
58885: LD_INT 51
58887: PUSH
58888: EMPTY
58889: LIST
58890: LIST
58891: PUSH
58892: LD_INT 34
58894: PUSH
58895: LD_INT 32
58897: PUSH
58898: EMPTY
58899: LIST
58900: LIST
58901: PUSH
58902: LD_INT 34
58904: PUSH
58905: LD_INT 89
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: PUSH
58912: EMPTY
58913: LIST
58914: LIST
58915: LIST
58916: LIST
58917: LIST
58918: PUSH
58919: EMPTY
58920: LIST
58921: LIST
58922: LIST
58923: PPUSH
58924: CALL_OW 69
58928: ST_TO_ADDR
// if tmp then
58929: LD_VAR 0 4
58933: IFFALSE 59059
// begin for j in tmp do
58935: LD_ADDR_VAR 0 2
58939: PUSH
58940: LD_VAR 0 4
58944: PUSH
58945: FOR_IN
58946: IFFALSE 59057
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
58948: LD_VAR 0 2
58952: PPUSH
58953: CALL_OW 262
58957: PUSH
58958: LD_INT 3
58960: EQUAL
58961: PUSH
58962: LD_VAR 0 2
58966: PPUSH
58967: CALL_OW 261
58971: PUSH
58972: LD_INT 20
58974: GREATER
58975: OR
58976: PUSH
58977: LD_VAR 0 2
58981: PPUSH
58982: CALL_OW 314
58986: NOT
58987: AND
58988: PUSH
58989: LD_VAR 0 2
58993: PPUSH
58994: CALL_OW 263
58998: PUSH
58999: LD_INT 1
59001: NONEQUAL
59002: PUSH
59003: LD_VAR 0 2
59007: PPUSH
59008: CALL_OW 311
59012: OR
59013: AND
59014: IFFALSE 59055
// begin ComCollect ( j , x , y ) ;
59016: LD_VAR 0 2
59020: PPUSH
59021: LD_VAR 0 6
59025: PPUSH
59026: LD_VAR 0 7
59030: PPUSH
59031: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
59035: LD_VAR 0 2
59039: PPUSH
59040: LD_VAR 0 8
59044: PPUSH
59045: CALL_OW 172
// exit ;
59049: POP
59050: POP
59051: POP
59052: POP
59053: GO 59063
// end ;
59055: GO 58945
59057: POP
59058: POP
// end ; end ;
59059: GO 58434
59061: POP
59062: POP
// end ; end_of_file
59063: PPOPN 9
59065: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
59066: LD_INT 0
59068: PPUSH
59069: PPUSH
59070: PPUSH
59071: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
59072: LD_VAR 0 1
59076: PPUSH
59077: CALL_OW 264
59081: PUSH
59082: LD_INT 91
59084: EQUAL
59085: IFFALSE 59157
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
59087: LD_INT 68
59089: PPUSH
59090: LD_VAR 0 1
59094: PPUSH
59095: CALL_OW 255
59099: PPUSH
59100: CALL_OW 321
59104: PUSH
59105: LD_INT 2
59107: EQUAL
59108: IFFALSE 59120
// eff := 70 else
59110: LD_ADDR_VAR 0 4
59114: PUSH
59115: LD_INT 70
59117: ST_TO_ADDR
59118: GO 59128
// eff := 30 ;
59120: LD_ADDR_VAR 0 4
59124: PUSH
59125: LD_INT 30
59127: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
59128: LD_VAR 0 1
59132: PPUSH
59133: CALL_OW 250
59137: PPUSH
59138: LD_VAR 0 1
59142: PPUSH
59143: CALL_OW 251
59147: PPUSH
59148: LD_VAR 0 4
59152: PPUSH
59153: CALL_OW 495
// end ; end ;
59157: LD_VAR 0 2
59161: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59162: LD_INT 0
59164: PPUSH
// end ;
59165: LD_VAR 0 4
59169: RET
// export function SOS_Command ( cmd ) ; begin
59170: LD_INT 0
59172: PPUSH
// end ;
59173: LD_VAR 0 2
59177: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59178: LD_INT 0
59180: PPUSH
// end ;
59181: LD_VAR 0 6
59185: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59186: LD_INT 0
59188: PPUSH
59189: PPUSH
// if not vehicle or not factory then
59190: LD_VAR 0 1
59194: NOT
59195: PUSH
59196: LD_VAR 0 2
59200: NOT
59201: OR
59202: IFFALSE 59206
// exit ;
59204: GO 59437
// if factoryWaypoints >= factory then
59206: LD_EXP 132
59210: PUSH
59211: LD_VAR 0 2
59215: GREATEREQUAL
59216: IFFALSE 59437
// if factoryWaypoints [ factory ] then
59218: LD_EXP 132
59222: PUSH
59223: LD_VAR 0 2
59227: ARRAY
59228: IFFALSE 59437
// begin if GetControl ( vehicle ) = control_manual then
59230: LD_VAR 0 1
59234: PPUSH
59235: CALL_OW 263
59239: PUSH
59240: LD_INT 1
59242: EQUAL
59243: IFFALSE 59324
// begin driver := IsDrivenBy ( vehicle ) ;
59245: LD_ADDR_VAR 0 4
59249: PUSH
59250: LD_VAR 0 1
59254: PPUSH
59255: CALL_OW 311
59259: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59260: LD_VAR 0 4
59264: PPUSH
59265: LD_EXP 132
59269: PUSH
59270: LD_VAR 0 2
59274: ARRAY
59275: PUSH
59276: LD_INT 3
59278: ARRAY
59279: PPUSH
59280: LD_EXP 132
59284: PUSH
59285: LD_VAR 0 2
59289: ARRAY
59290: PUSH
59291: LD_INT 4
59293: ARRAY
59294: PPUSH
59295: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59299: LD_VAR 0 4
59303: PPUSH
59304: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59308: LD_VAR 0 4
59312: PPUSH
59313: LD_VAR 0 2
59317: PPUSH
59318: CALL_OW 180
// end else
59322: GO 59437
// if GetControl ( vehicle ) = control_remote then
59324: LD_VAR 0 1
59328: PPUSH
59329: CALL_OW 263
59333: PUSH
59334: LD_INT 2
59336: EQUAL
59337: IFFALSE 59398
// begin wait ( 0 0$2 ) ;
59339: LD_INT 70
59341: PPUSH
59342: CALL_OW 67
// if Connect ( vehicle ) then
59346: LD_VAR 0 1
59350: PPUSH
59351: CALL 71295 0 1
59355: IFFALSE 59396
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59357: LD_VAR 0 1
59361: PPUSH
59362: LD_EXP 132
59366: PUSH
59367: LD_VAR 0 2
59371: ARRAY
59372: PUSH
59373: LD_INT 3
59375: ARRAY
59376: PPUSH
59377: LD_EXP 132
59381: PUSH
59382: LD_VAR 0 2
59386: ARRAY
59387: PUSH
59388: LD_INT 4
59390: ARRAY
59391: PPUSH
59392: CALL_OW 171
// end else
59396: GO 59437
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59398: LD_VAR 0 1
59402: PPUSH
59403: LD_EXP 132
59407: PUSH
59408: LD_VAR 0 2
59412: ARRAY
59413: PUSH
59414: LD_INT 3
59416: ARRAY
59417: PPUSH
59418: LD_EXP 132
59422: PUSH
59423: LD_VAR 0 2
59427: ARRAY
59428: PUSH
59429: LD_INT 4
59431: ARRAY
59432: PPUSH
59433: CALL_OW 171
// end ; end ;
59437: LD_VAR 0 3
59441: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59442: LD_INT 0
59444: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59445: LD_VAR 0 1
59449: PUSH
59450: LD_INT 250
59452: EQUAL
59453: PUSH
59454: LD_VAR 0 2
59458: PPUSH
59459: CALL_OW 264
59463: PUSH
59464: LD_INT 81
59466: EQUAL
59467: AND
59468: IFFALSE 59489
// MinerPlaceMine ( unit , x , y ) ;
59470: LD_VAR 0 2
59474: PPUSH
59475: LD_VAR 0 4
59479: PPUSH
59480: LD_VAR 0 5
59484: PPUSH
59485: CALL 61874 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59489: LD_VAR 0 1
59493: PUSH
59494: LD_INT 251
59496: EQUAL
59497: PUSH
59498: LD_VAR 0 2
59502: PPUSH
59503: CALL_OW 264
59507: PUSH
59508: LD_INT 81
59510: EQUAL
59511: AND
59512: IFFALSE 59533
// MinerDetonateMine ( unit , x , y ) ;
59514: LD_VAR 0 2
59518: PPUSH
59519: LD_VAR 0 4
59523: PPUSH
59524: LD_VAR 0 5
59528: PPUSH
59529: CALL 62149 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59533: LD_VAR 0 1
59537: PUSH
59538: LD_INT 252
59540: EQUAL
59541: PUSH
59542: LD_VAR 0 2
59546: PPUSH
59547: CALL_OW 264
59551: PUSH
59552: LD_INT 81
59554: EQUAL
59555: AND
59556: IFFALSE 59577
// MinerCreateMinefield ( unit , x , y ) ;
59558: LD_VAR 0 2
59562: PPUSH
59563: LD_VAR 0 4
59567: PPUSH
59568: LD_VAR 0 5
59572: PPUSH
59573: CALL 62566 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59577: LD_VAR 0 1
59581: PUSH
59582: LD_INT 253
59584: EQUAL
59585: PUSH
59586: LD_VAR 0 2
59590: PPUSH
59591: CALL_OW 257
59595: PUSH
59596: LD_INT 5
59598: EQUAL
59599: AND
59600: IFFALSE 59621
// ComBinocular ( unit , x , y ) ;
59602: LD_VAR 0 2
59606: PPUSH
59607: LD_VAR 0 4
59611: PPUSH
59612: LD_VAR 0 5
59616: PPUSH
59617: CALL 62935 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59621: LD_VAR 0 1
59625: PUSH
59626: LD_INT 254
59628: EQUAL
59629: PUSH
59630: LD_VAR 0 2
59634: PPUSH
59635: CALL_OW 264
59639: PUSH
59640: LD_INT 99
59642: EQUAL
59643: AND
59644: PUSH
59645: LD_VAR 0 3
59649: PPUSH
59650: CALL_OW 263
59654: PUSH
59655: LD_INT 3
59657: EQUAL
59658: AND
59659: IFFALSE 59675
// HackDestroyVehicle ( unit , selectedUnit ) ;
59661: LD_VAR 0 2
59665: PPUSH
59666: LD_VAR 0 3
59670: PPUSH
59671: CALL 61238 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59675: LD_VAR 0 1
59679: PUSH
59680: LD_INT 255
59682: EQUAL
59683: PUSH
59684: LD_VAR 0 2
59688: PPUSH
59689: CALL_OW 264
59693: PUSH
59694: LD_INT 14
59696: PUSH
59697: LD_INT 53
59699: PUSH
59700: EMPTY
59701: LIST
59702: LIST
59703: IN
59704: AND
59705: PUSH
59706: LD_VAR 0 4
59710: PPUSH
59711: LD_VAR 0 5
59715: PPUSH
59716: CALL_OW 488
59720: AND
59721: IFFALSE 59745
// CutTreeXYR ( unit , x , y , 12 ) ;
59723: LD_VAR 0 2
59727: PPUSH
59728: LD_VAR 0 4
59732: PPUSH
59733: LD_VAR 0 5
59737: PPUSH
59738: LD_INT 12
59740: PPUSH
59741: CALL 59808 0 4
// if cmd = 256 then
59745: LD_VAR 0 1
59749: PUSH
59750: LD_INT 256
59752: EQUAL
59753: IFFALSE 59774
// SetFactoryWaypoint ( unit , x , y ) ;
59755: LD_VAR 0 2
59759: PPUSH
59760: LD_VAR 0 4
59764: PPUSH
59765: LD_VAR 0 5
59769: PPUSH
59770: CALL 57755 0 3
// if cmd = 257 then
59774: LD_VAR 0 1
59778: PUSH
59779: LD_INT 257
59781: EQUAL
59782: IFFALSE 59803
// SetWarehouseGatheringPoint ( unit , x , y ) ;
59784: LD_VAR 0 2
59788: PPUSH
59789: LD_VAR 0 4
59793: PPUSH
59794: LD_VAR 0 5
59798: PPUSH
59799: CALL 58117 0 3
// end ;
59803: LD_VAR 0 6
59807: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59808: LD_INT 0
59810: PPUSH
59811: PPUSH
59812: PPUSH
59813: PPUSH
59814: PPUSH
59815: PPUSH
59816: PPUSH
59817: PPUSH
59818: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59819: LD_VAR 0 1
59823: NOT
59824: PUSH
59825: LD_VAR 0 2
59829: PPUSH
59830: LD_VAR 0 3
59834: PPUSH
59835: CALL_OW 488
59839: NOT
59840: OR
59841: PUSH
59842: LD_VAR 0 4
59846: NOT
59847: OR
59848: IFFALSE 59852
// exit ;
59850: GO 60192
// list := [ ] ;
59852: LD_ADDR_VAR 0 13
59856: PUSH
59857: EMPTY
59858: ST_TO_ADDR
// if x - r < 0 then
59859: LD_VAR 0 2
59863: PUSH
59864: LD_VAR 0 4
59868: MINUS
59869: PUSH
59870: LD_INT 0
59872: LESS
59873: IFFALSE 59885
// min_x := 0 else
59875: LD_ADDR_VAR 0 7
59879: PUSH
59880: LD_INT 0
59882: ST_TO_ADDR
59883: GO 59901
// min_x := x - r ;
59885: LD_ADDR_VAR 0 7
59889: PUSH
59890: LD_VAR 0 2
59894: PUSH
59895: LD_VAR 0 4
59899: MINUS
59900: ST_TO_ADDR
// if y - r < 0 then
59901: LD_VAR 0 3
59905: PUSH
59906: LD_VAR 0 4
59910: MINUS
59911: PUSH
59912: LD_INT 0
59914: LESS
59915: IFFALSE 59927
// min_y := 0 else
59917: LD_ADDR_VAR 0 8
59921: PUSH
59922: LD_INT 0
59924: ST_TO_ADDR
59925: GO 59943
// min_y := y - r ;
59927: LD_ADDR_VAR 0 8
59931: PUSH
59932: LD_VAR 0 3
59936: PUSH
59937: LD_VAR 0 4
59941: MINUS
59942: ST_TO_ADDR
// max_x := x + r ;
59943: LD_ADDR_VAR 0 9
59947: PUSH
59948: LD_VAR 0 2
59952: PUSH
59953: LD_VAR 0 4
59957: PLUS
59958: ST_TO_ADDR
// max_y := y + r ;
59959: LD_ADDR_VAR 0 10
59963: PUSH
59964: LD_VAR 0 3
59968: PUSH
59969: LD_VAR 0 4
59973: PLUS
59974: ST_TO_ADDR
// for _x = min_x to max_x do
59975: LD_ADDR_VAR 0 11
59979: PUSH
59980: DOUBLE
59981: LD_VAR 0 7
59985: DEC
59986: ST_TO_ADDR
59987: LD_VAR 0 9
59991: PUSH
59992: FOR_TO
59993: IFFALSE 60110
// for _y = min_y to max_y do
59995: LD_ADDR_VAR 0 12
59999: PUSH
60000: DOUBLE
60001: LD_VAR 0 8
60005: DEC
60006: ST_TO_ADDR
60007: LD_VAR 0 10
60011: PUSH
60012: FOR_TO
60013: IFFALSE 60106
// begin if not ValidHex ( _x , _y ) then
60015: LD_VAR 0 11
60019: PPUSH
60020: LD_VAR 0 12
60024: PPUSH
60025: CALL_OW 488
60029: NOT
60030: IFFALSE 60034
// continue ;
60032: GO 60012
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60034: LD_VAR 0 11
60038: PPUSH
60039: LD_VAR 0 12
60043: PPUSH
60044: CALL_OW 351
60048: PUSH
60049: LD_VAR 0 11
60053: PPUSH
60054: LD_VAR 0 12
60058: PPUSH
60059: CALL_OW 554
60063: AND
60064: IFFALSE 60104
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60066: LD_ADDR_VAR 0 13
60070: PUSH
60071: LD_VAR 0 13
60075: PPUSH
60076: LD_VAR 0 13
60080: PUSH
60081: LD_INT 1
60083: PLUS
60084: PPUSH
60085: LD_VAR 0 11
60089: PUSH
60090: LD_VAR 0 12
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: PPUSH
60099: CALL_OW 2
60103: ST_TO_ADDR
// end ;
60104: GO 60012
60106: POP
60107: POP
60108: GO 59992
60110: POP
60111: POP
// if not list then
60112: LD_VAR 0 13
60116: NOT
60117: IFFALSE 60121
// exit ;
60119: GO 60192
// for i in list do
60121: LD_ADDR_VAR 0 6
60125: PUSH
60126: LD_VAR 0 13
60130: PUSH
60131: FOR_IN
60132: IFFALSE 60190
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
60134: LD_VAR 0 1
60138: PPUSH
60139: LD_STRING M
60141: PUSH
60142: LD_VAR 0 6
60146: PUSH
60147: LD_INT 1
60149: ARRAY
60150: PUSH
60151: LD_VAR 0 6
60155: PUSH
60156: LD_INT 2
60158: ARRAY
60159: PUSH
60160: LD_INT 0
60162: PUSH
60163: LD_INT 0
60165: PUSH
60166: LD_INT 0
60168: PUSH
60169: LD_INT 0
60171: PUSH
60172: EMPTY
60173: LIST
60174: LIST
60175: LIST
60176: LIST
60177: LIST
60178: LIST
60179: LIST
60180: PUSH
60181: EMPTY
60182: LIST
60183: PPUSH
60184: CALL_OW 447
60188: GO 60131
60190: POP
60191: POP
// end ;
60192: LD_VAR 0 5
60196: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60197: LD_EXP 135
60201: NOT
60202: IFFALSE 60252
60204: GO 60206
60206: DISABLE
// begin initHack := true ;
60207: LD_ADDR_EXP 135
60211: PUSH
60212: LD_INT 1
60214: ST_TO_ADDR
// hackTanks := [ ] ;
60215: LD_ADDR_EXP 136
60219: PUSH
60220: EMPTY
60221: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60222: LD_ADDR_EXP 137
60226: PUSH
60227: EMPTY
60228: ST_TO_ADDR
// hackLimit := 3 ;
60229: LD_ADDR_EXP 138
60233: PUSH
60234: LD_INT 3
60236: ST_TO_ADDR
// hackDist := 12 ;
60237: LD_ADDR_EXP 139
60241: PUSH
60242: LD_INT 12
60244: ST_TO_ADDR
// hackCounter := [ ] ;
60245: LD_ADDR_EXP 140
60249: PUSH
60250: EMPTY
60251: ST_TO_ADDR
// end ;
60252: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60253: LD_EXP 135
60257: PUSH
60258: LD_INT 34
60260: PUSH
60261: LD_INT 99
60263: PUSH
60264: EMPTY
60265: LIST
60266: LIST
60267: PPUSH
60268: CALL_OW 69
60272: AND
60273: IFFALSE 60526
60275: GO 60277
60277: DISABLE
60278: LD_INT 0
60280: PPUSH
60281: PPUSH
// begin enable ;
60282: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60283: LD_ADDR_VAR 0 1
60287: PUSH
60288: LD_INT 34
60290: PUSH
60291: LD_INT 99
60293: PUSH
60294: EMPTY
60295: LIST
60296: LIST
60297: PPUSH
60298: CALL_OW 69
60302: PUSH
60303: FOR_IN
60304: IFFALSE 60524
// begin if not i in hackTanks then
60306: LD_VAR 0 1
60310: PUSH
60311: LD_EXP 136
60315: IN
60316: NOT
60317: IFFALSE 60400
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60319: LD_ADDR_EXP 136
60323: PUSH
60324: LD_EXP 136
60328: PPUSH
60329: LD_EXP 136
60333: PUSH
60334: LD_INT 1
60336: PLUS
60337: PPUSH
60338: LD_VAR 0 1
60342: PPUSH
60343: CALL_OW 1
60347: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60348: LD_ADDR_EXP 137
60352: PUSH
60353: LD_EXP 137
60357: PPUSH
60358: LD_EXP 137
60362: PUSH
60363: LD_INT 1
60365: PLUS
60366: PPUSH
60367: EMPTY
60368: PPUSH
60369: CALL_OW 1
60373: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60374: LD_ADDR_EXP 140
60378: PUSH
60379: LD_EXP 140
60383: PPUSH
60384: LD_EXP 140
60388: PUSH
60389: LD_INT 1
60391: PLUS
60392: PPUSH
60393: EMPTY
60394: PPUSH
60395: CALL_OW 1
60399: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60400: LD_VAR 0 1
60404: PPUSH
60405: CALL_OW 302
60409: NOT
60410: IFFALSE 60423
// begin HackUnlinkAll ( i ) ;
60412: LD_VAR 0 1
60416: PPUSH
60417: CALL 60529 0 1
// continue ;
60421: GO 60303
// end ; HackCheckCapturedStatus ( i ) ;
60423: LD_VAR 0 1
60427: PPUSH
60428: CALL 60972 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
60432: LD_ADDR_VAR 0 2
60436: PUSH
60437: LD_INT 81
60439: PUSH
60440: LD_VAR 0 1
60444: PPUSH
60445: CALL_OW 255
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: PUSH
60454: LD_INT 33
60456: PUSH
60457: LD_INT 3
60459: PUSH
60460: EMPTY
60461: LIST
60462: LIST
60463: PUSH
60464: LD_INT 91
60466: PUSH
60467: LD_VAR 0 1
60471: PUSH
60472: LD_EXP 139
60476: PUSH
60477: EMPTY
60478: LIST
60479: LIST
60480: LIST
60481: PUSH
60482: LD_INT 50
60484: PUSH
60485: EMPTY
60486: LIST
60487: PUSH
60488: EMPTY
60489: LIST
60490: LIST
60491: LIST
60492: LIST
60493: PPUSH
60494: CALL_OW 69
60498: ST_TO_ADDR
// if not tmp then
60499: LD_VAR 0 2
60503: NOT
60504: IFFALSE 60508
// continue ;
60506: GO 60303
// HackLink ( i , tmp ) ;
60508: LD_VAR 0 1
60512: PPUSH
60513: LD_VAR 0 2
60517: PPUSH
60518: CALL 60665 0 2
// end ;
60522: GO 60303
60524: POP
60525: POP
// end ;
60526: PPOPN 2
60528: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
60529: LD_INT 0
60531: PPUSH
60532: PPUSH
60533: PPUSH
// if not hack in hackTanks then
60534: LD_VAR 0 1
60538: PUSH
60539: LD_EXP 136
60543: IN
60544: NOT
60545: IFFALSE 60549
// exit ;
60547: GO 60660
// index := GetElementIndex ( hackTanks , hack ) ;
60549: LD_ADDR_VAR 0 4
60553: PUSH
60554: LD_EXP 136
60558: PPUSH
60559: LD_VAR 0 1
60563: PPUSH
60564: CALL 68102 0 2
60568: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
60569: LD_EXP 137
60573: PUSH
60574: LD_VAR 0 4
60578: ARRAY
60579: IFFALSE 60660
// begin for i in hackTanksCaptured [ index ] do
60581: LD_ADDR_VAR 0 3
60585: PUSH
60586: LD_EXP 137
60590: PUSH
60591: LD_VAR 0 4
60595: ARRAY
60596: PUSH
60597: FOR_IN
60598: IFFALSE 60624
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60600: LD_VAR 0 3
60604: PUSH
60605: LD_INT 1
60607: ARRAY
60608: PPUSH
60609: LD_VAR 0 3
60613: PUSH
60614: LD_INT 2
60616: ARRAY
60617: PPUSH
60618: CALL_OW 235
60622: GO 60597
60624: POP
60625: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60626: LD_ADDR_EXP 137
60630: PUSH
60631: LD_EXP 137
60635: PPUSH
60636: LD_VAR 0 4
60640: PPUSH
60641: EMPTY
60642: PPUSH
60643: CALL_OW 1
60647: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60648: LD_VAR 0 1
60652: PPUSH
60653: LD_INT 0
60655: PPUSH
60656: CALL_OW 505
// end ; end ;
60660: LD_VAR 0 2
60664: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60665: LD_INT 0
60667: PPUSH
60668: PPUSH
60669: PPUSH
// if not hack in hackTanks or not vehicles then
60670: LD_VAR 0 1
60674: PUSH
60675: LD_EXP 136
60679: IN
60680: NOT
60681: PUSH
60682: LD_VAR 0 2
60686: NOT
60687: OR
60688: IFFALSE 60692
// exit ;
60690: GO 60967
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60692: LD_ADDR_VAR 0 2
60696: PUSH
60697: LD_VAR 0 1
60701: PPUSH
60702: LD_VAR 0 2
60706: PPUSH
60707: LD_INT 1
60709: PPUSH
60710: LD_INT 1
60712: PPUSH
60713: CALL 68752 0 4
60717: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60718: LD_ADDR_VAR 0 5
60722: PUSH
60723: LD_EXP 136
60727: PPUSH
60728: LD_VAR 0 1
60732: PPUSH
60733: CALL 68102 0 2
60737: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60738: LD_EXP 137
60742: PUSH
60743: LD_VAR 0 5
60747: ARRAY
60748: PUSH
60749: LD_EXP 138
60753: LESS
60754: IFFALSE 60943
// begin for i := 1 to vehicles do
60756: LD_ADDR_VAR 0 4
60760: PUSH
60761: DOUBLE
60762: LD_INT 1
60764: DEC
60765: ST_TO_ADDR
60766: LD_VAR 0 2
60770: PUSH
60771: FOR_TO
60772: IFFALSE 60941
// begin if hackTanksCaptured [ index ] = hackLimit then
60774: LD_EXP 137
60778: PUSH
60779: LD_VAR 0 5
60783: ARRAY
60784: PUSH
60785: LD_EXP 138
60789: EQUAL
60790: IFFALSE 60794
// break ;
60792: GO 60941
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60794: LD_ADDR_EXP 140
60798: PUSH
60799: LD_EXP 140
60803: PPUSH
60804: LD_VAR 0 5
60808: PPUSH
60809: LD_EXP 140
60813: PUSH
60814: LD_VAR 0 5
60818: ARRAY
60819: PUSH
60820: LD_INT 1
60822: PLUS
60823: PPUSH
60824: CALL_OW 1
60828: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60829: LD_ADDR_EXP 137
60833: PUSH
60834: LD_EXP 137
60838: PPUSH
60839: LD_VAR 0 5
60843: PUSH
60844: LD_EXP 137
60848: PUSH
60849: LD_VAR 0 5
60853: ARRAY
60854: PUSH
60855: LD_INT 1
60857: PLUS
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: PPUSH
60863: LD_VAR 0 2
60867: PUSH
60868: LD_VAR 0 4
60872: ARRAY
60873: PUSH
60874: LD_VAR 0 2
60878: PUSH
60879: LD_VAR 0 4
60883: ARRAY
60884: PPUSH
60885: CALL_OW 255
60889: PUSH
60890: EMPTY
60891: LIST
60892: LIST
60893: PPUSH
60894: CALL 68317 0 3
60898: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60899: LD_VAR 0 2
60903: PUSH
60904: LD_VAR 0 4
60908: ARRAY
60909: PPUSH
60910: LD_VAR 0 1
60914: PPUSH
60915: CALL_OW 255
60919: PPUSH
60920: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60924: LD_VAR 0 2
60928: PUSH
60929: LD_VAR 0 4
60933: ARRAY
60934: PPUSH
60935: CALL_OW 141
// end ;
60939: GO 60771
60941: POP
60942: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60943: LD_VAR 0 1
60947: PPUSH
60948: LD_EXP 137
60952: PUSH
60953: LD_VAR 0 5
60957: ARRAY
60958: PUSH
60959: LD_INT 0
60961: PLUS
60962: PPUSH
60963: CALL_OW 505
// end ;
60967: LD_VAR 0 3
60971: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60972: LD_INT 0
60974: PPUSH
60975: PPUSH
60976: PPUSH
60977: PPUSH
// if not hack in hackTanks then
60978: LD_VAR 0 1
60982: PUSH
60983: LD_EXP 136
60987: IN
60988: NOT
60989: IFFALSE 60993
// exit ;
60991: GO 61233
// index := GetElementIndex ( hackTanks , hack ) ;
60993: LD_ADDR_VAR 0 4
60997: PUSH
60998: LD_EXP 136
61002: PPUSH
61003: LD_VAR 0 1
61007: PPUSH
61008: CALL 68102 0 2
61012: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
61013: LD_ADDR_VAR 0 3
61017: PUSH
61018: DOUBLE
61019: LD_EXP 137
61023: PUSH
61024: LD_VAR 0 4
61028: ARRAY
61029: INC
61030: ST_TO_ADDR
61031: LD_INT 1
61033: PUSH
61034: FOR_DOWNTO
61035: IFFALSE 61207
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
61037: LD_ADDR_VAR 0 5
61041: PUSH
61042: LD_EXP 137
61046: PUSH
61047: LD_VAR 0 4
61051: ARRAY
61052: PUSH
61053: LD_VAR 0 3
61057: ARRAY
61058: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
61059: LD_VAR 0 5
61063: PUSH
61064: LD_INT 1
61066: ARRAY
61067: PPUSH
61068: CALL_OW 302
61072: NOT
61073: PUSH
61074: LD_VAR 0 5
61078: PUSH
61079: LD_INT 1
61081: ARRAY
61082: PPUSH
61083: CALL_OW 255
61087: PUSH
61088: LD_VAR 0 1
61092: PPUSH
61093: CALL_OW 255
61097: NONEQUAL
61098: OR
61099: IFFALSE 61205
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
61101: LD_VAR 0 5
61105: PUSH
61106: LD_INT 1
61108: ARRAY
61109: PPUSH
61110: CALL_OW 305
61114: PUSH
61115: LD_VAR 0 5
61119: PUSH
61120: LD_INT 1
61122: ARRAY
61123: PPUSH
61124: CALL_OW 255
61128: PUSH
61129: LD_VAR 0 1
61133: PPUSH
61134: CALL_OW 255
61138: EQUAL
61139: AND
61140: IFFALSE 61164
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61142: LD_VAR 0 5
61146: PUSH
61147: LD_INT 1
61149: ARRAY
61150: PPUSH
61151: LD_VAR 0 5
61155: PUSH
61156: LD_INT 2
61158: ARRAY
61159: PPUSH
61160: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61164: LD_ADDR_EXP 137
61168: PUSH
61169: LD_EXP 137
61173: PPUSH
61174: LD_VAR 0 4
61178: PPUSH
61179: LD_EXP 137
61183: PUSH
61184: LD_VAR 0 4
61188: ARRAY
61189: PPUSH
61190: LD_VAR 0 3
61194: PPUSH
61195: CALL_OW 3
61199: PPUSH
61200: CALL_OW 1
61204: ST_TO_ADDR
// end ; end ;
61205: GO 61034
61207: POP
61208: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61209: LD_VAR 0 1
61213: PPUSH
61214: LD_EXP 137
61218: PUSH
61219: LD_VAR 0 4
61223: ARRAY
61224: PUSH
61225: LD_INT 0
61227: PLUS
61228: PPUSH
61229: CALL_OW 505
// end ;
61233: LD_VAR 0 2
61237: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61238: LD_INT 0
61240: PPUSH
61241: PPUSH
61242: PPUSH
61243: PPUSH
// if not hack in hackTanks then
61244: LD_VAR 0 1
61248: PUSH
61249: LD_EXP 136
61253: IN
61254: NOT
61255: IFFALSE 61259
// exit ;
61257: GO 61344
// index := GetElementIndex ( hackTanks , hack ) ;
61259: LD_ADDR_VAR 0 5
61263: PUSH
61264: LD_EXP 136
61268: PPUSH
61269: LD_VAR 0 1
61273: PPUSH
61274: CALL 68102 0 2
61278: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61279: LD_ADDR_VAR 0 4
61283: PUSH
61284: DOUBLE
61285: LD_INT 1
61287: DEC
61288: ST_TO_ADDR
61289: LD_EXP 137
61293: PUSH
61294: LD_VAR 0 5
61298: ARRAY
61299: PUSH
61300: FOR_TO
61301: IFFALSE 61342
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61303: LD_EXP 137
61307: PUSH
61308: LD_VAR 0 5
61312: ARRAY
61313: PUSH
61314: LD_VAR 0 4
61318: ARRAY
61319: PUSH
61320: LD_INT 1
61322: ARRAY
61323: PUSH
61324: LD_VAR 0 2
61328: EQUAL
61329: IFFALSE 61340
// KillUnit ( vehicle ) ;
61331: LD_VAR 0 2
61335: PPUSH
61336: CALL_OW 66
61340: GO 61300
61342: POP
61343: POP
// end ;
61344: LD_VAR 0 3
61348: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61349: LD_EXP 141
61353: NOT
61354: IFFALSE 61389
61356: GO 61358
61358: DISABLE
// begin initMiner := true ;
61359: LD_ADDR_EXP 141
61363: PUSH
61364: LD_INT 1
61366: ST_TO_ADDR
// minersList := [ ] ;
61367: LD_ADDR_EXP 142
61371: PUSH
61372: EMPTY
61373: ST_TO_ADDR
// minerMinesList := [ ] ;
61374: LD_ADDR_EXP 143
61378: PUSH
61379: EMPTY
61380: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61381: LD_ADDR_EXP 144
61385: PUSH
61386: LD_INT 5
61388: ST_TO_ADDR
// end ;
61389: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61390: LD_EXP 141
61394: PUSH
61395: LD_INT 34
61397: PUSH
61398: LD_INT 81
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: PPUSH
61405: CALL_OW 69
61409: AND
61410: IFFALSE 61871
61412: GO 61414
61414: DISABLE
61415: LD_INT 0
61417: PPUSH
61418: PPUSH
61419: PPUSH
61420: PPUSH
// begin enable ;
61421: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
61422: LD_ADDR_VAR 0 1
61426: PUSH
61427: LD_INT 34
61429: PUSH
61430: LD_INT 81
61432: PUSH
61433: EMPTY
61434: LIST
61435: LIST
61436: PPUSH
61437: CALL_OW 69
61441: PUSH
61442: FOR_IN
61443: IFFALSE 61515
// begin if not i in minersList then
61445: LD_VAR 0 1
61449: PUSH
61450: LD_EXP 142
61454: IN
61455: NOT
61456: IFFALSE 61513
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
61458: LD_ADDR_EXP 142
61462: PUSH
61463: LD_EXP 142
61467: PPUSH
61468: LD_EXP 142
61472: PUSH
61473: LD_INT 1
61475: PLUS
61476: PPUSH
61477: LD_VAR 0 1
61481: PPUSH
61482: CALL_OW 1
61486: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
61487: LD_ADDR_EXP 143
61491: PUSH
61492: LD_EXP 143
61496: PPUSH
61497: LD_EXP 143
61501: PUSH
61502: LD_INT 1
61504: PLUS
61505: PPUSH
61506: EMPTY
61507: PPUSH
61508: CALL_OW 1
61512: ST_TO_ADDR
// end end ;
61513: GO 61442
61515: POP
61516: POP
// for i := minerMinesList downto 1 do
61517: LD_ADDR_VAR 0 1
61521: PUSH
61522: DOUBLE
61523: LD_EXP 143
61527: INC
61528: ST_TO_ADDR
61529: LD_INT 1
61531: PUSH
61532: FOR_DOWNTO
61533: IFFALSE 61869
// begin if IsLive ( minersList [ i ] ) then
61535: LD_EXP 142
61539: PUSH
61540: LD_VAR 0 1
61544: ARRAY
61545: PPUSH
61546: CALL_OW 300
61550: IFFALSE 61578
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
61552: LD_EXP 142
61556: PUSH
61557: LD_VAR 0 1
61561: ARRAY
61562: PPUSH
61563: LD_EXP 143
61567: PUSH
61568: LD_VAR 0 1
61572: ARRAY
61573: PPUSH
61574: CALL_OW 505
// if not minerMinesList [ i ] then
61578: LD_EXP 143
61582: PUSH
61583: LD_VAR 0 1
61587: ARRAY
61588: NOT
61589: IFFALSE 61593
// continue ;
61591: GO 61532
// for j := minerMinesList [ i ] downto 1 do
61593: LD_ADDR_VAR 0 2
61597: PUSH
61598: DOUBLE
61599: LD_EXP 143
61603: PUSH
61604: LD_VAR 0 1
61608: ARRAY
61609: INC
61610: ST_TO_ADDR
61611: LD_INT 1
61613: PUSH
61614: FOR_DOWNTO
61615: IFFALSE 61865
// begin side := GetSide ( minersList [ i ] ) ;
61617: LD_ADDR_VAR 0 3
61621: PUSH
61622: LD_EXP 142
61626: PUSH
61627: LD_VAR 0 1
61631: ARRAY
61632: PPUSH
61633: CALL_OW 255
61637: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61638: LD_ADDR_VAR 0 4
61642: PUSH
61643: LD_EXP 143
61647: PUSH
61648: LD_VAR 0 1
61652: ARRAY
61653: PUSH
61654: LD_VAR 0 2
61658: ARRAY
61659: PUSH
61660: LD_INT 1
61662: ARRAY
61663: PPUSH
61664: LD_EXP 143
61668: PUSH
61669: LD_VAR 0 1
61673: ARRAY
61674: PUSH
61675: LD_VAR 0 2
61679: ARRAY
61680: PUSH
61681: LD_INT 2
61683: ARRAY
61684: PPUSH
61685: CALL_OW 428
61689: ST_TO_ADDR
// if not tmp then
61690: LD_VAR 0 4
61694: NOT
61695: IFFALSE 61699
// continue ;
61697: GO 61614
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61699: LD_VAR 0 4
61703: PUSH
61704: LD_INT 81
61706: PUSH
61707: LD_VAR 0 3
61711: PUSH
61712: EMPTY
61713: LIST
61714: LIST
61715: PPUSH
61716: CALL_OW 69
61720: IN
61721: PUSH
61722: LD_EXP 143
61726: PUSH
61727: LD_VAR 0 1
61731: ARRAY
61732: PUSH
61733: LD_VAR 0 2
61737: ARRAY
61738: PUSH
61739: LD_INT 1
61741: ARRAY
61742: PPUSH
61743: LD_EXP 143
61747: PUSH
61748: LD_VAR 0 1
61752: ARRAY
61753: PUSH
61754: LD_VAR 0 2
61758: ARRAY
61759: PUSH
61760: LD_INT 2
61762: ARRAY
61763: PPUSH
61764: CALL_OW 458
61768: AND
61769: IFFALSE 61863
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61771: LD_EXP 143
61775: PUSH
61776: LD_VAR 0 1
61780: ARRAY
61781: PUSH
61782: LD_VAR 0 2
61786: ARRAY
61787: PUSH
61788: LD_INT 1
61790: ARRAY
61791: PPUSH
61792: LD_EXP 143
61796: PUSH
61797: LD_VAR 0 1
61801: ARRAY
61802: PUSH
61803: LD_VAR 0 2
61807: ARRAY
61808: PUSH
61809: LD_INT 2
61811: ARRAY
61812: PPUSH
61813: LD_VAR 0 3
61817: PPUSH
61818: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61822: LD_ADDR_EXP 143
61826: PUSH
61827: LD_EXP 143
61831: PPUSH
61832: LD_VAR 0 1
61836: PPUSH
61837: LD_EXP 143
61841: PUSH
61842: LD_VAR 0 1
61846: ARRAY
61847: PPUSH
61848: LD_VAR 0 2
61852: PPUSH
61853: CALL_OW 3
61857: PPUSH
61858: CALL_OW 1
61862: ST_TO_ADDR
// end ; end ;
61863: GO 61614
61865: POP
61866: POP
// end ;
61867: GO 61532
61869: POP
61870: POP
// end ;
61871: PPOPN 4
61873: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61874: LD_INT 0
61876: PPUSH
61877: PPUSH
// result := false ;
61878: LD_ADDR_VAR 0 4
61882: PUSH
61883: LD_INT 0
61885: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61886: LD_VAR 0 1
61890: PPUSH
61891: CALL_OW 264
61895: PUSH
61896: LD_INT 81
61898: EQUAL
61899: NOT
61900: IFFALSE 61904
// exit ;
61902: GO 62144
// index := GetElementIndex ( minersList , unit ) ;
61904: LD_ADDR_VAR 0 5
61908: PUSH
61909: LD_EXP 142
61913: PPUSH
61914: LD_VAR 0 1
61918: PPUSH
61919: CALL 68102 0 2
61923: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61924: LD_EXP 143
61928: PUSH
61929: LD_VAR 0 5
61933: ARRAY
61934: PUSH
61935: LD_EXP 144
61939: GREATEREQUAL
61940: IFFALSE 61944
// exit ;
61942: GO 62144
// ComMoveXY ( unit , x , y ) ;
61944: LD_VAR 0 1
61948: PPUSH
61949: LD_VAR 0 2
61953: PPUSH
61954: LD_VAR 0 3
61958: PPUSH
61959: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61963: LD_INT 35
61965: PPUSH
61966: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61970: LD_VAR 0 1
61974: PPUSH
61975: LD_VAR 0 2
61979: PPUSH
61980: LD_VAR 0 3
61984: PPUSH
61985: CALL 99486 0 3
61989: NOT
61990: PUSH
61991: LD_VAR 0 1
61995: PPUSH
61996: CALL_OW 314
62000: AND
62001: IFFALSE 62005
// exit ;
62003: GO 62144
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
62005: LD_VAR 0 2
62009: PPUSH
62010: LD_VAR 0 3
62014: PPUSH
62015: CALL_OW 428
62019: PUSH
62020: LD_VAR 0 1
62024: EQUAL
62025: PUSH
62026: LD_VAR 0 1
62030: PPUSH
62031: CALL_OW 314
62035: NOT
62036: AND
62037: IFFALSE 61963
// PlaySoundXY ( x , y , PlantMine ) ;
62039: LD_VAR 0 2
62043: PPUSH
62044: LD_VAR 0 3
62048: PPUSH
62049: LD_STRING PlantMine
62051: PPUSH
62052: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
62056: LD_VAR 0 2
62060: PPUSH
62061: LD_VAR 0 3
62065: PPUSH
62066: LD_VAR 0 1
62070: PPUSH
62071: CALL_OW 255
62075: PPUSH
62076: LD_INT 0
62078: PPUSH
62079: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
62083: LD_ADDR_EXP 143
62087: PUSH
62088: LD_EXP 143
62092: PPUSH
62093: LD_VAR 0 5
62097: PUSH
62098: LD_EXP 143
62102: PUSH
62103: LD_VAR 0 5
62107: ARRAY
62108: PUSH
62109: LD_INT 1
62111: PLUS
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: PPUSH
62117: LD_VAR 0 2
62121: PUSH
62122: LD_VAR 0 3
62126: PUSH
62127: EMPTY
62128: LIST
62129: LIST
62130: PPUSH
62131: CALL 68317 0 3
62135: ST_TO_ADDR
// result := true ;
62136: LD_ADDR_VAR 0 4
62140: PUSH
62141: LD_INT 1
62143: ST_TO_ADDR
// end ;
62144: LD_VAR 0 4
62148: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62149: LD_INT 0
62151: PPUSH
62152: PPUSH
62153: PPUSH
// if not unit in minersList then
62154: LD_VAR 0 1
62158: PUSH
62159: LD_EXP 142
62163: IN
62164: NOT
62165: IFFALSE 62169
// exit ;
62167: GO 62561
// index := GetElementIndex ( minersList , unit ) ;
62169: LD_ADDR_VAR 0 6
62173: PUSH
62174: LD_EXP 142
62178: PPUSH
62179: LD_VAR 0 1
62183: PPUSH
62184: CALL 68102 0 2
62188: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62189: LD_ADDR_VAR 0 5
62193: PUSH
62194: DOUBLE
62195: LD_EXP 143
62199: PUSH
62200: LD_VAR 0 6
62204: ARRAY
62205: INC
62206: ST_TO_ADDR
62207: LD_INT 1
62209: PUSH
62210: FOR_DOWNTO
62211: IFFALSE 62372
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62213: LD_EXP 143
62217: PUSH
62218: LD_VAR 0 6
62222: ARRAY
62223: PUSH
62224: LD_VAR 0 5
62228: ARRAY
62229: PUSH
62230: LD_INT 1
62232: ARRAY
62233: PUSH
62234: LD_VAR 0 2
62238: EQUAL
62239: PUSH
62240: LD_EXP 143
62244: PUSH
62245: LD_VAR 0 6
62249: ARRAY
62250: PUSH
62251: LD_VAR 0 5
62255: ARRAY
62256: PUSH
62257: LD_INT 2
62259: ARRAY
62260: PUSH
62261: LD_VAR 0 3
62265: EQUAL
62266: AND
62267: IFFALSE 62370
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62269: LD_EXP 143
62273: PUSH
62274: LD_VAR 0 6
62278: ARRAY
62279: PUSH
62280: LD_VAR 0 5
62284: ARRAY
62285: PUSH
62286: LD_INT 1
62288: ARRAY
62289: PPUSH
62290: LD_EXP 143
62294: PUSH
62295: LD_VAR 0 6
62299: ARRAY
62300: PUSH
62301: LD_VAR 0 5
62305: ARRAY
62306: PUSH
62307: LD_INT 2
62309: ARRAY
62310: PPUSH
62311: LD_VAR 0 1
62315: PPUSH
62316: CALL_OW 255
62320: PPUSH
62321: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62325: LD_ADDR_EXP 143
62329: PUSH
62330: LD_EXP 143
62334: PPUSH
62335: LD_VAR 0 6
62339: PPUSH
62340: LD_EXP 143
62344: PUSH
62345: LD_VAR 0 6
62349: ARRAY
62350: PPUSH
62351: LD_VAR 0 5
62355: PPUSH
62356: CALL_OW 3
62360: PPUSH
62361: CALL_OW 1
62365: ST_TO_ADDR
// exit ;
62366: POP
62367: POP
62368: GO 62561
// end ; end ;
62370: GO 62210
62372: POP
62373: POP
// for i := minerMinesList [ index ] downto 1 do
62374: LD_ADDR_VAR 0 5
62378: PUSH
62379: DOUBLE
62380: LD_EXP 143
62384: PUSH
62385: LD_VAR 0 6
62389: ARRAY
62390: INC
62391: ST_TO_ADDR
62392: LD_INT 1
62394: PUSH
62395: FOR_DOWNTO
62396: IFFALSE 62559
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62398: LD_EXP 143
62402: PUSH
62403: LD_VAR 0 6
62407: ARRAY
62408: PUSH
62409: LD_VAR 0 5
62413: ARRAY
62414: PUSH
62415: LD_INT 1
62417: ARRAY
62418: PPUSH
62419: LD_EXP 143
62423: PUSH
62424: LD_VAR 0 6
62428: ARRAY
62429: PUSH
62430: LD_VAR 0 5
62434: ARRAY
62435: PUSH
62436: LD_INT 2
62438: ARRAY
62439: PPUSH
62440: LD_VAR 0 2
62444: PPUSH
62445: LD_VAR 0 3
62449: PPUSH
62450: CALL_OW 298
62454: PUSH
62455: LD_INT 6
62457: LESS
62458: IFFALSE 62557
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62460: LD_EXP 143
62464: PUSH
62465: LD_VAR 0 6
62469: ARRAY
62470: PUSH
62471: LD_VAR 0 5
62475: ARRAY
62476: PUSH
62477: LD_INT 1
62479: ARRAY
62480: PPUSH
62481: LD_EXP 143
62485: PUSH
62486: LD_VAR 0 6
62490: ARRAY
62491: PUSH
62492: LD_VAR 0 5
62496: ARRAY
62497: PUSH
62498: LD_INT 2
62500: ARRAY
62501: PPUSH
62502: LD_VAR 0 1
62506: PPUSH
62507: CALL_OW 255
62511: PPUSH
62512: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62516: LD_ADDR_EXP 143
62520: PUSH
62521: LD_EXP 143
62525: PPUSH
62526: LD_VAR 0 6
62530: PPUSH
62531: LD_EXP 143
62535: PUSH
62536: LD_VAR 0 6
62540: ARRAY
62541: PPUSH
62542: LD_VAR 0 5
62546: PPUSH
62547: CALL_OW 3
62551: PPUSH
62552: CALL_OW 1
62556: ST_TO_ADDR
// end ; end ;
62557: GO 62395
62559: POP
62560: POP
// end ;
62561: LD_VAR 0 4
62565: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
62566: LD_INT 0
62568: PPUSH
62569: PPUSH
62570: PPUSH
62571: PPUSH
62572: PPUSH
62573: PPUSH
62574: PPUSH
62575: PPUSH
62576: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62577: LD_VAR 0 1
62581: PPUSH
62582: CALL_OW 264
62586: PUSH
62587: LD_INT 81
62589: EQUAL
62590: NOT
62591: PUSH
62592: LD_VAR 0 1
62596: PUSH
62597: LD_EXP 142
62601: IN
62602: NOT
62603: OR
62604: IFFALSE 62608
// exit ;
62606: GO 62930
// index := GetElementIndex ( minersList , unit ) ;
62608: LD_ADDR_VAR 0 6
62612: PUSH
62613: LD_EXP 142
62617: PPUSH
62618: LD_VAR 0 1
62622: PPUSH
62623: CALL 68102 0 2
62627: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62628: LD_ADDR_VAR 0 8
62632: PUSH
62633: LD_EXP 144
62637: PUSH
62638: LD_EXP 143
62642: PUSH
62643: LD_VAR 0 6
62647: ARRAY
62648: MINUS
62649: ST_TO_ADDR
// if not minesFreeAmount then
62650: LD_VAR 0 8
62654: NOT
62655: IFFALSE 62659
// exit ;
62657: GO 62930
// tmp := [ ] ;
62659: LD_ADDR_VAR 0 7
62663: PUSH
62664: EMPTY
62665: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62666: LD_ADDR_VAR 0 5
62670: PUSH
62671: DOUBLE
62672: LD_INT 1
62674: DEC
62675: ST_TO_ADDR
62676: LD_VAR 0 8
62680: PUSH
62681: FOR_TO
62682: IFFALSE 62877
// begin _d := rand ( 0 , 5 ) ;
62684: LD_ADDR_VAR 0 11
62688: PUSH
62689: LD_INT 0
62691: PPUSH
62692: LD_INT 5
62694: PPUSH
62695: CALL_OW 12
62699: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62700: LD_ADDR_VAR 0 12
62704: PUSH
62705: LD_INT 2
62707: PPUSH
62708: LD_INT 6
62710: PPUSH
62711: CALL_OW 12
62715: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62716: LD_ADDR_VAR 0 9
62720: PUSH
62721: LD_VAR 0 2
62725: PPUSH
62726: LD_VAR 0 11
62730: PPUSH
62731: LD_VAR 0 12
62735: PPUSH
62736: CALL_OW 272
62740: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62741: LD_ADDR_VAR 0 10
62745: PUSH
62746: LD_VAR 0 3
62750: PPUSH
62751: LD_VAR 0 11
62755: PPUSH
62756: LD_VAR 0 12
62760: PPUSH
62761: CALL_OW 273
62765: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62766: LD_VAR 0 9
62770: PPUSH
62771: LD_VAR 0 10
62775: PPUSH
62776: CALL_OW 488
62780: PUSH
62781: LD_VAR 0 9
62785: PUSH
62786: LD_VAR 0 10
62790: PUSH
62791: EMPTY
62792: LIST
62793: LIST
62794: PUSH
62795: LD_VAR 0 7
62799: IN
62800: NOT
62801: AND
62802: PUSH
62803: LD_VAR 0 9
62807: PPUSH
62808: LD_VAR 0 10
62812: PPUSH
62813: CALL_OW 458
62817: NOT
62818: AND
62819: IFFALSE 62861
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62821: LD_ADDR_VAR 0 7
62825: PUSH
62826: LD_VAR 0 7
62830: PPUSH
62831: LD_VAR 0 7
62835: PUSH
62836: LD_INT 1
62838: PLUS
62839: PPUSH
62840: LD_VAR 0 9
62844: PUSH
62845: LD_VAR 0 10
62849: PUSH
62850: EMPTY
62851: LIST
62852: LIST
62853: PPUSH
62854: CALL_OW 1
62858: ST_TO_ADDR
62859: GO 62875
// i := i - 1 ;
62861: LD_ADDR_VAR 0 5
62865: PUSH
62866: LD_VAR 0 5
62870: PUSH
62871: LD_INT 1
62873: MINUS
62874: ST_TO_ADDR
// end ;
62875: GO 62681
62877: POP
62878: POP
// for i in tmp do
62879: LD_ADDR_VAR 0 5
62883: PUSH
62884: LD_VAR 0 7
62888: PUSH
62889: FOR_IN
62890: IFFALSE 62928
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62892: LD_VAR 0 1
62896: PPUSH
62897: LD_VAR 0 5
62901: PUSH
62902: LD_INT 1
62904: ARRAY
62905: PPUSH
62906: LD_VAR 0 5
62910: PUSH
62911: LD_INT 2
62913: ARRAY
62914: PPUSH
62915: CALL 61874 0 3
62919: NOT
62920: IFFALSE 62926
// exit ;
62922: POP
62923: POP
62924: GO 62930
62926: GO 62889
62928: POP
62929: POP
// end ;
62930: LD_VAR 0 4
62934: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62935: LD_INT 0
62937: PPUSH
62938: PPUSH
62939: PPUSH
62940: PPUSH
62941: PPUSH
62942: PPUSH
62943: PPUSH
// if not GetClass ( unit ) = class_sniper then
62944: LD_VAR 0 1
62948: PPUSH
62949: CALL_OW 257
62953: PUSH
62954: LD_INT 5
62956: EQUAL
62957: NOT
62958: IFFALSE 62962
// exit ;
62960: GO 63350
// dist := 8 ;
62962: LD_ADDR_VAR 0 5
62966: PUSH
62967: LD_INT 8
62969: ST_TO_ADDR
// viewRange := 12 ;
62970: LD_ADDR_VAR 0 7
62974: PUSH
62975: LD_INT 12
62977: ST_TO_ADDR
// side := GetSide ( unit ) ;
62978: LD_ADDR_VAR 0 6
62982: PUSH
62983: LD_VAR 0 1
62987: PPUSH
62988: CALL_OW 255
62992: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62993: LD_INT 61
62995: PPUSH
62996: LD_VAR 0 6
63000: PPUSH
63001: CALL_OW 321
63005: PUSH
63006: LD_INT 2
63008: EQUAL
63009: IFFALSE 63019
// viewRange := 16 ;
63011: LD_ADDR_VAR 0 7
63015: PUSH
63016: LD_INT 16
63018: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
63019: LD_VAR 0 1
63023: PPUSH
63024: LD_VAR 0 2
63028: PPUSH
63029: LD_VAR 0 3
63033: PPUSH
63034: CALL_OW 297
63038: PUSH
63039: LD_VAR 0 5
63043: GREATER
63044: IFFALSE 63123
// begin ComMoveXY ( unit , x , y ) ;
63046: LD_VAR 0 1
63050: PPUSH
63051: LD_VAR 0 2
63055: PPUSH
63056: LD_VAR 0 3
63060: PPUSH
63061: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63065: LD_INT 35
63067: PPUSH
63068: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
63072: LD_VAR 0 1
63076: PPUSH
63077: LD_VAR 0 2
63081: PPUSH
63082: LD_VAR 0 3
63086: PPUSH
63087: CALL 99486 0 3
63091: NOT
63092: IFFALSE 63096
// exit ;
63094: GO 63350
// until GetDistUnitXY ( unit , x , y ) < dist ;
63096: LD_VAR 0 1
63100: PPUSH
63101: LD_VAR 0 2
63105: PPUSH
63106: LD_VAR 0 3
63110: PPUSH
63111: CALL_OW 297
63115: PUSH
63116: LD_VAR 0 5
63120: LESS
63121: IFFALSE 63065
// end ; ComTurnXY ( unit , x , y ) ;
63123: LD_VAR 0 1
63127: PPUSH
63128: LD_VAR 0 2
63132: PPUSH
63133: LD_VAR 0 3
63137: PPUSH
63138: CALL_OW 118
// wait ( 5 ) ;
63142: LD_INT 5
63144: PPUSH
63145: CALL_OW 67
// _d := GetDir ( unit ) ;
63149: LD_ADDR_VAR 0 10
63153: PUSH
63154: LD_VAR 0 1
63158: PPUSH
63159: CALL_OW 254
63163: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63164: LD_ADDR_VAR 0 8
63168: PUSH
63169: LD_VAR 0 1
63173: PPUSH
63174: CALL_OW 250
63178: PPUSH
63179: LD_VAR 0 10
63183: PPUSH
63184: LD_VAR 0 5
63188: PPUSH
63189: CALL_OW 272
63193: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63194: LD_ADDR_VAR 0 9
63198: PUSH
63199: LD_VAR 0 1
63203: PPUSH
63204: CALL_OW 251
63208: PPUSH
63209: LD_VAR 0 10
63213: PPUSH
63214: LD_VAR 0 5
63218: PPUSH
63219: CALL_OW 273
63223: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63224: LD_VAR 0 8
63228: PPUSH
63229: LD_VAR 0 9
63233: PPUSH
63234: CALL_OW 488
63238: NOT
63239: IFFALSE 63243
// exit ;
63241: GO 63350
// ComAnimCustom ( unit , 1 ) ;
63243: LD_VAR 0 1
63247: PPUSH
63248: LD_INT 1
63250: PPUSH
63251: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63255: LD_VAR 0 8
63259: PPUSH
63260: LD_VAR 0 9
63264: PPUSH
63265: LD_VAR 0 6
63269: PPUSH
63270: LD_VAR 0 7
63274: PPUSH
63275: CALL_OW 330
// repeat wait ( 1 ) ;
63279: LD_INT 1
63281: PPUSH
63282: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63286: LD_VAR 0 1
63290: PPUSH
63291: CALL_OW 316
63295: PUSH
63296: LD_VAR 0 1
63300: PPUSH
63301: CALL_OW 314
63305: OR
63306: PUSH
63307: LD_VAR 0 1
63311: PPUSH
63312: CALL_OW 302
63316: NOT
63317: OR
63318: PUSH
63319: LD_VAR 0 1
63323: PPUSH
63324: CALL_OW 301
63328: OR
63329: IFFALSE 63279
// RemoveSeeing ( _x , _y , side ) ;
63331: LD_VAR 0 8
63335: PPUSH
63336: LD_VAR 0 9
63340: PPUSH
63341: LD_VAR 0 6
63345: PPUSH
63346: CALL_OW 331
// end ; end_of_file
63350: LD_VAR 0 4
63354: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63355: LD_INT 0
63357: PPUSH
63358: PPUSH
// if exist_mode then
63359: LD_VAR 0 2
63363: IFFALSE 63388
// unit := CreateCharacter ( prefix & ident ) else
63365: LD_ADDR_VAR 0 5
63369: PUSH
63370: LD_VAR 0 3
63374: PUSH
63375: LD_VAR 0 1
63379: STR
63380: PPUSH
63381: CALL_OW 34
63385: ST_TO_ADDR
63386: GO 63403
// unit := NewCharacter ( ident ) ;
63388: LD_ADDR_VAR 0 5
63392: PUSH
63393: LD_VAR 0 1
63397: PPUSH
63398: CALL_OW 25
63402: ST_TO_ADDR
// result := unit ;
63403: LD_ADDR_VAR 0 4
63407: PUSH
63408: LD_VAR 0 5
63412: ST_TO_ADDR
// end ;
63413: LD_VAR 0 4
63417: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63418: LD_INT 0
63420: PPUSH
63421: PPUSH
// if not side or not nation then
63422: LD_VAR 0 1
63426: NOT
63427: PUSH
63428: LD_VAR 0 2
63432: NOT
63433: OR
63434: IFFALSE 63438
// exit ;
63436: GO 64206
// case nation of nation_american :
63438: LD_VAR 0 2
63442: PUSH
63443: LD_INT 1
63445: DOUBLE
63446: EQUAL
63447: IFTRUE 63451
63449: GO 63665
63451: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
63452: LD_ADDR_VAR 0 4
63456: PUSH
63457: LD_INT 35
63459: PUSH
63460: LD_INT 45
63462: PUSH
63463: LD_INT 46
63465: PUSH
63466: LD_INT 47
63468: PUSH
63469: LD_INT 82
63471: PUSH
63472: LD_INT 83
63474: PUSH
63475: LD_INT 84
63477: PUSH
63478: LD_INT 85
63480: PUSH
63481: LD_INT 86
63483: PUSH
63484: LD_INT 1
63486: PUSH
63487: LD_INT 2
63489: PUSH
63490: LD_INT 6
63492: PUSH
63493: LD_INT 15
63495: PUSH
63496: LD_INT 16
63498: PUSH
63499: LD_INT 7
63501: PUSH
63502: LD_INT 12
63504: PUSH
63505: LD_INT 13
63507: PUSH
63508: LD_INT 10
63510: PUSH
63511: LD_INT 14
63513: PUSH
63514: LD_INT 20
63516: PUSH
63517: LD_INT 21
63519: PUSH
63520: LD_INT 22
63522: PUSH
63523: LD_INT 25
63525: PUSH
63526: LD_INT 32
63528: PUSH
63529: LD_INT 27
63531: PUSH
63532: LD_INT 36
63534: PUSH
63535: LD_INT 69
63537: PUSH
63538: LD_INT 39
63540: PUSH
63541: LD_INT 34
63543: PUSH
63544: LD_INT 40
63546: PUSH
63547: LD_INT 48
63549: PUSH
63550: LD_INT 49
63552: PUSH
63553: LD_INT 50
63555: PUSH
63556: LD_INT 51
63558: PUSH
63559: LD_INT 52
63561: PUSH
63562: LD_INT 53
63564: PUSH
63565: LD_INT 54
63567: PUSH
63568: LD_INT 55
63570: PUSH
63571: LD_INT 56
63573: PUSH
63574: LD_INT 57
63576: PUSH
63577: LD_INT 58
63579: PUSH
63580: LD_INT 59
63582: PUSH
63583: LD_INT 60
63585: PUSH
63586: LD_INT 61
63588: PUSH
63589: LD_INT 62
63591: PUSH
63592: LD_INT 80
63594: PUSH
63595: LD_INT 82
63597: PUSH
63598: LD_INT 83
63600: PUSH
63601: LD_INT 84
63603: PUSH
63604: LD_INT 85
63606: PUSH
63607: LD_INT 86
63609: PUSH
63610: EMPTY
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: LIST
63619: LIST
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: LIST
63642: LIST
63643: LIST
63644: LIST
63645: LIST
63646: LIST
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: ST_TO_ADDR
63663: GO 64130
63665: LD_INT 2
63667: DOUBLE
63668: EQUAL
63669: IFTRUE 63673
63671: GO 63899
63673: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
63674: LD_ADDR_VAR 0 4
63678: PUSH
63679: LD_INT 35
63681: PUSH
63682: LD_INT 45
63684: PUSH
63685: LD_INT 46
63687: PUSH
63688: LD_INT 47
63690: PUSH
63691: LD_INT 82
63693: PUSH
63694: LD_INT 83
63696: PUSH
63697: LD_INT 84
63699: PUSH
63700: LD_INT 85
63702: PUSH
63703: LD_INT 87
63705: PUSH
63706: LD_INT 70
63708: PUSH
63709: LD_INT 1
63711: PUSH
63712: LD_INT 11
63714: PUSH
63715: LD_INT 3
63717: PUSH
63718: LD_INT 4
63720: PUSH
63721: LD_INT 5
63723: PUSH
63724: LD_INT 6
63726: PUSH
63727: LD_INT 15
63729: PUSH
63730: LD_INT 18
63732: PUSH
63733: LD_INT 7
63735: PUSH
63736: LD_INT 17
63738: PUSH
63739: LD_INT 8
63741: PUSH
63742: LD_INT 20
63744: PUSH
63745: LD_INT 21
63747: PUSH
63748: LD_INT 22
63750: PUSH
63751: LD_INT 72
63753: PUSH
63754: LD_INT 26
63756: PUSH
63757: LD_INT 69
63759: PUSH
63760: LD_INT 39
63762: PUSH
63763: LD_INT 40
63765: PUSH
63766: LD_INT 41
63768: PUSH
63769: LD_INT 42
63771: PUSH
63772: LD_INT 43
63774: PUSH
63775: LD_INT 48
63777: PUSH
63778: LD_INT 49
63780: PUSH
63781: LD_INT 50
63783: PUSH
63784: LD_INT 51
63786: PUSH
63787: LD_INT 52
63789: PUSH
63790: LD_INT 53
63792: PUSH
63793: LD_INT 54
63795: PUSH
63796: LD_INT 55
63798: PUSH
63799: LD_INT 56
63801: PUSH
63802: LD_INT 60
63804: PUSH
63805: LD_INT 61
63807: PUSH
63808: LD_INT 62
63810: PUSH
63811: LD_INT 66
63813: PUSH
63814: LD_INT 67
63816: PUSH
63817: LD_INT 68
63819: PUSH
63820: LD_INT 81
63822: PUSH
63823: LD_INT 82
63825: PUSH
63826: LD_INT 83
63828: PUSH
63829: LD_INT 84
63831: PUSH
63832: LD_INT 85
63834: PUSH
63835: LD_INT 87
63837: PUSH
63838: LD_INT 88
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: LIST
63873: LIST
63874: LIST
63875: LIST
63876: LIST
63877: LIST
63878: LIST
63879: LIST
63880: LIST
63881: LIST
63882: LIST
63883: LIST
63884: LIST
63885: LIST
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: ST_TO_ADDR
63897: GO 64130
63899: LD_INT 3
63901: DOUBLE
63902: EQUAL
63903: IFTRUE 63907
63905: GO 64129
63907: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
63908: LD_ADDR_VAR 0 4
63912: PUSH
63913: LD_INT 46
63915: PUSH
63916: LD_INT 47
63918: PUSH
63919: LD_INT 1
63921: PUSH
63922: LD_INT 2
63924: PUSH
63925: LD_INT 82
63927: PUSH
63928: LD_INT 83
63930: PUSH
63931: LD_INT 84
63933: PUSH
63934: LD_INT 85
63936: PUSH
63937: LD_INT 86
63939: PUSH
63940: LD_INT 11
63942: PUSH
63943: LD_INT 9
63945: PUSH
63946: LD_INT 20
63948: PUSH
63949: LD_INT 19
63951: PUSH
63952: LD_INT 21
63954: PUSH
63955: LD_INT 24
63957: PUSH
63958: LD_INT 22
63960: PUSH
63961: LD_INT 25
63963: PUSH
63964: LD_INT 28
63966: PUSH
63967: LD_INT 29
63969: PUSH
63970: LD_INT 30
63972: PUSH
63973: LD_INT 31
63975: PUSH
63976: LD_INT 37
63978: PUSH
63979: LD_INT 38
63981: PUSH
63982: LD_INT 32
63984: PUSH
63985: LD_INT 27
63987: PUSH
63988: LD_INT 33
63990: PUSH
63991: LD_INT 69
63993: PUSH
63994: LD_INT 39
63996: PUSH
63997: LD_INT 34
63999: PUSH
64000: LD_INT 40
64002: PUSH
64003: LD_INT 71
64005: PUSH
64006: LD_INT 23
64008: PUSH
64009: LD_INT 44
64011: PUSH
64012: LD_INT 48
64014: PUSH
64015: LD_INT 49
64017: PUSH
64018: LD_INT 50
64020: PUSH
64021: LD_INT 51
64023: PUSH
64024: LD_INT 52
64026: PUSH
64027: LD_INT 53
64029: PUSH
64030: LD_INT 54
64032: PUSH
64033: LD_INT 55
64035: PUSH
64036: LD_INT 56
64038: PUSH
64039: LD_INT 57
64041: PUSH
64042: LD_INT 58
64044: PUSH
64045: LD_INT 59
64047: PUSH
64048: LD_INT 63
64050: PUSH
64051: LD_INT 64
64053: PUSH
64054: LD_INT 65
64056: PUSH
64057: LD_INT 82
64059: PUSH
64060: LD_INT 83
64062: PUSH
64063: LD_INT 84
64065: PUSH
64066: LD_INT 85
64068: PUSH
64069: LD_INT 86
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: LIST
64093: LIST
64094: LIST
64095: LIST
64096: LIST
64097: LIST
64098: LIST
64099: LIST
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: LIST
64112: LIST
64113: LIST
64114: LIST
64115: LIST
64116: LIST
64117: LIST
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: ST_TO_ADDR
64127: GO 64130
64129: POP
// if state > - 1 and state < 3 then
64130: LD_VAR 0 3
64134: PUSH
64135: LD_INT 1
64137: NEG
64138: GREATER
64139: PUSH
64140: LD_VAR 0 3
64144: PUSH
64145: LD_INT 3
64147: LESS
64148: AND
64149: IFFALSE 64206
// for i in result do
64151: LD_ADDR_VAR 0 5
64155: PUSH
64156: LD_VAR 0 4
64160: PUSH
64161: FOR_IN
64162: IFFALSE 64204
// if GetTech ( i , side ) <> state then
64164: LD_VAR 0 5
64168: PPUSH
64169: LD_VAR 0 1
64173: PPUSH
64174: CALL_OW 321
64178: PUSH
64179: LD_VAR 0 3
64183: NONEQUAL
64184: IFFALSE 64202
// result := result diff i ;
64186: LD_ADDR_VAR 0 4
64190: PUSH
64191: LD_VAR 0 4
64195: PUSH
64196: LD_VAR 0 5
64200: DIFF
64201: ST_TO_ADDR
64202: GO 64161
64204: POP
64205: POP
// end ;
64206: LD_VAR 0 4
64210: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64211: LD_INT 0
64213: PPUSH
64214: PPUSH
64215: PPUSH
// result := true ;
64216: LD_ADDR_VAR 0 3
64220: PUSH
64221: LD_INT 1
64223: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64224: LD_ADDR_VAR 0 5
64228: PUSH
64229: LD_VAR 0 2
64233: PPUSH
64234: CALL_OW 480
64238: ST_TO_ADDR
// if not tmp then
64239: LD_VAR 0 5
64243: NOT
64244: IFFALSE 64248
// exit ;
64246: GO 64297
// for i in tmp do
64248: LD_ADDR_VAR 0 4
64252: PUSH
64253: LD_VAR 0 5
64257: PUSH
64258: FOR_IN
64259: IFFALSE 64295
// if GetTech ( i , side ) <> state_researched then
64261: LD_VAR 0 4
64265: PPUSH
64266: LD_VAR 0 1
64270: PPUSH
64271: CALL_OW 321
64275: PUSH
64276: LD_INT 2
64278: NONEQUAL
64279: IFFALSE 64293
// begin result := false ;
64281: LD_ADDR_VAR 0 3
64285: PUSH
64286: LD_INT 0
64288: ST_TO_ADDR
// exit ;
64289: POP
64290: POP
64291: GO 64297
// end ;
64293: GO 64258
64295: POP
64296: POP
// end ;
64297: LD_VAR 0 3
64301: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64302: LD_INT 0
64304: PPUSH
64305: PPUSH
64306: PPUSH
64307: PPUSH
64308: PPUSH
64309: PPUSH
64310: PPUSH
64311: PPUSH
64312: PPUSH
64313: PPUSH
64314: PPUSH
64315: PPUSH
64316: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64317: LD_VAR 0 1
64321: NOT
64322: PUSH
64323: LD_VAR 0 1
64327: PPUSH
64328: CALL_OW 257
64332: PUSH
64333: LD_INT 9
64335: NONEQUAL
64336: OR
64337: IFFALSE 64341
// exit ;
64339: GO 64914
// side := GetSide ( unit ) ;
64341: LD_ADDR_VAR 0 9
64345: PUSH
64346: LD_VAR 0 1
64350: PPUSH
64351: CALL_OW 255
64355: ST_TO_ADDR
// tech_space := tech_spacanom ;
64356: LD_ADDR_VAR 0 12
64360: PUSH
64361: LD_INT 29
64363: ST_TO_ADDR
// tech_time := tech_taurad ;
64364: LD_ADDR_VAR 0 13
64368: PUSH
64369: LD_INT 28
64371: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64372: LD_ADDR_VAR 0 11
64376: PUSH
64377: LD_VAR 0 1
64381: PPUSH
64382: CALL_OW 310
64386: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64387: LD_VAR 0 11
64391: PPUSH
64392: CALL_OW 247
64396: PUSH
64397: LD_INT 2
64399: EQUAL
64400: IFFALSE 64404
// exit ;
64402: GO 64914
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64404: LD_ADDR_VAR 0 8
64408: PUSH
64409: LD_INT 81
64411: PUSH
64412: LD_VAR 0 9
64416: PUSH
64417: EMPTY
64418: LIST
64419: LIST
64420: PUSH
64421: LD_INT 3
64423: PUSH
64424: LD_INT 21
64426: PUSH
64427: LD_INT 3
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PUSH
64434: EMPTY
64435: LIST
64436: LIST
64437: PUSH
64438: EMPTY
64439: LIST
64440: LIST
64441: PPUSH
64442: CALL_OW 69
64446: ST_TO_ADDR
// if not tmp then
64447: LD_VAR 0 8
64451: NOT
64452: IFFALSE 64456
// exit ;
64454: GO 64914
// if in_unit then
64456: LD_VAR 0 11
64460: IFFALSE 64484
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64462: LD_ADDR_VAR 0 10
64466: PUSH
64467: LD_VAR 0 8
64471: PPUSH
64472: LD_VAR 0 11
64476: PPUSH
64477: CALL_OW 74
64481: ST_TO_ADDR
64482: GO 64504
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64484: LD_ADDR_VAR 0 10
64488: PUSH
64489: LD_VAR 0 8
64493: PPUSH
64494: LD_VAR 0 1
64498: PPUSH
64499: CALL_OW 74
64503: ST_TO_ADDR
// if not enemy then
64504: LD_VAR 0 10
64508: NOT
64509: IFFALSE 64513
// exit ;
64511: GO 64914
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64513: LD_VAR 0 11
64517: PUSH
64518: LD_VAR 0 11
64522: PPUSH
64523: LD_VAR 0 10
64527: PPUSH
64528: CALL_OW 296
64532: PUSH
64533: LD_INT 13
64535: GREATER
64536: AND
64537: PUSH
64538: LD_VAR 0 1
64542: PPUSH
64543: LD_VAR 0 10
64547: PPUSH
64548: CALL_OW 296
64552: PUSH
64553: LD_INT 12
64555: GREATER
64556: OR
64557: IFFALSE 64561
// exit ;
64559: GO 64914
// missile := [ 1 ] ;
64561: LD_ADDR_VAR 0 14
64565: PUSH
64566: LD_INT 1
64568: PUSH
64569: EMPTY
64570: LIST
64571: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64572: LD_VAR 0 9
64576: PPUSH
64577: LD_VAR 0 12
64581: PPUSH
64582: CALL_OW 325
64586: IFFALSE 64615
// missile := Replace ( missile , missile + 1 , 2 ) ;
64588: LD_ADDR_VAR 0 14
64592: PUSH
64593: LD_VAR 0 14
64597: PPUSH
64598: LD_VAR 0 14
64602: PUSH
64603: LD_INT 1
64605: PLUS
64606: PPUSH
64607: LD_INT 2
64609: PPUSH
64610: CALL_OW 1
64614: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64615: LD_VAR 0 9
64619: PPUSH
64620: LD_VAR 0 13
64624: PPUSH
64625: CALL_OW 325
64629: PUSH
64630: LD_VAR 0 10
64634: PPUSH
64635: CALL_OW 255
64639: PPUSH
64640: LD_VAR 0 13
64644: PPUSH
64645: CALL_OW 325
64649: NOT
64650: AND
64651: IFFALSE 64680
// missile := Replace ( missile , missile + 1 , 3 ) ;
64653: LD_ADDR_VAR 0 14
64657: PUSH
64658: LD_VAR 0 14
64662: PPUSH
64663: LD_VAR 0 14
64667: PUSH
64668: LD_INT 1
64670: PLUS
64671: PPUSH
64672: LD_INT 3
64674: PPUSH
64675: CALL_OW 1
64679: ST_TO_ADDR
// if missile < 2 then
64680: LD_VAR 0 14
64684: PUSH
64685: LD_INT 2
64687: LESS
64688: IFFALSE 64692
// exit ;
64690: GO 64914
// x := GetX ( enemy ) ;
64692: LD_ADDR_VAR 0 4
64696: PUSH
64697: LD_VAR 0 10
64701: PPUSH
64702: CALL_OW 250
64706: ST_TO_ADDR
// y := GetY ( enemy ) ;
64707: LD_ADDR_VAR 0 5
64711: PUSH
64712: LD_VAR 0 10
64716: PPUSH
64717: CALL_OW 251
64721: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64722: LD_ADDR_VAR 0 6
64726: PUSH
64727: LD_VAR 0 4
64731: PUSH
64732: LD_INT 1
64734: NEG
64735: PPUSH
64736: LD_INT 1
64738: PPUSH
64739: CALL_OW 12
64743: PLUS
64744: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64745: LD_ADDR_VAR 0 7
64749: PUSH
64750: LD_VAR 0 5
64754: PUSH
64755: LD_INT 1
64757: NEG
64758: PPUSH
64759: LD_INT 1
64761: PPUSH
64762: CALL_OW 12
64766: PLUS
64767: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64768: LD_VAR 0 6
64772: PPUSH
64773: LD_VAR 0 7
64777: PPUSH
64778: CALL_OW 488
64782: NOT
64783: IFFALSE 64805
// begin _x := x ;
64785: LD_ADDR_VAR 0 6
64789: PUSH
64790: LD_VAR 0 4
64794: ST_TO_ADDR
// _y := y ;
64795: LD_ADDR_VAR 0 7
64799: PUSH
64800: LD_VAR 0 5
64804: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64805: LD_ADDR_VAR 0 3
64809: PUSH
64810: LD_INT 1
64812: PPUSH
64813: LD_VAR 0 14
64817: PPUSH
64818: CALL_OW 12
64822: ST_TO_ADDR
// case i of 1 :
64823: LD_VAR 0 3
64827: PUSH
64828: LD_INT 1
64830: DOUBLE
64831: EQUAL
64832: IFTRUE 64836
64834: GO 64853
64836: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64837: LD_VAR 0 1
64841: PPUSH
64842: LD_VAR 0 10
64846: PPUSH
64847: CALL_OW 115
64851: GO 64914
64853: LD_INT 2
64855: DOUBLE
64856: EQUAL
64857: IFTRUE 64861
64859: GO 64883
64861: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64862: LD_VAR 0 1
64866: PPUSH
64867: LD_VAR 0 6
64871: PPUSH
64872: LD_VAR 0 7
64876: PPUSH
64877: CALL_OW 153
64881: GO 64914
64883: LD_INT 3
64885: DOUBLE
64886: EQUAL
64887: IFTRUE 64891
64889: GO 64913
64891: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64892: LD_VAR 0 1
64896: PPUSH
64897: LD_VAR 0 6
64901: PPUSH
64902: LD_VAR 0 7
64906: PPUSH
64907: CALL_OW 154
64911: GO 64914
64913: POP
// end ;
64914: LD_VAR 0 2
64918: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64919: LD_INT 0
64921: PPUSH
64922: PPUSH
64923: PPUSH
64924: PPUSH
64925: PPUSH
64926: PPUSH
// if not unit or not building then
64927: LD_VAR 0 1
64931: NOT
64932: PUSH
64933: LD_VAR 0 2
64937: NOT
64938: OR
64939: IFFALSE 64943
// exit ;
64941: GO 65101
// x := GetX ( building ) ;
64943: LD_ADDR_VAR 0 5
64947: PUSH
64948: LD_VAR 0 2
64952: PPUSH
64953: CALL_OW 250
64957: ST_TO_ADDR
// y := GetY ( building ) ;
64958: LD_ADDR_VAR 0 6
64962: PUSH
64963: LD_VAR 0 2
64967: PPUSH
64968: CALL_OW 251
64972: ST_TO_ADDR
// for i = 0 to 5 do
64973: LD_ADDR_VAR 0 4
64977: PUSH
64978: DOUBLE
64979: LD_INT 0
64981: DEC
64982: ST_TO_ADDR
64983: LD_INT 5
64985: PUSH
64986: FOR_TO
64987: IFFALSE 65099
// begin _x := ShiftX ( x , i , 3 ) ;
64989: LD_ADDR_VAR 0 7
64993: PUSH
64994: LD_VAR 0 5
64998: PPUSH
64999: LD_VAR 0 4
65003: PPUSH
65004: LD_INT 3
65006: PPUSH
65007: CALL_OW 272
65011: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65012: LD_ADDR_VAR 0 8
65016: PUSH
65017: LD_VAR 0 6
65021: PPUSH
65022: LD_VAR 0 4
65026: PPUSH
65027: LD_INT 3
65029: PPUSH
65030: CALL_OW 273
65034: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65035: LD_VAR 0 7
65039: PPUSH
65040: LD_VAR 0 8
65044: PPUSH
65045: CALL_OW 488
65049: NOT
65050: IFFALSE 65054
// continue ;
65052: GO 64986
// if HexInfo ( _x , _y ) = 0 then
65054: LD_VAR 0 7
65058: PPUSH
65059: LD_VAR 0 8
65063: PPUSH
65064: CALL_OW 428
65068: PUSH
65069: LD_INT 0
65071: EQUAL
65072: IFFALSE 65097
// begin ComMoveXY ( unit , _x , _y ) ;
65074: LD_VAR 0 1
65078: PPUSH
65079: LD_VAR 0 7
65083: PPUSH
65084: LD_VAR 0 8
65088: PPUSH
65089: CALL_OW 111
// exit ;
65093: POP
65094: POP
65095: GO 65101
// end ; end ;
65097: GO 64986
65099: POP
65100: POP
// end ;
65101: LD_VAR 0 3
65105: RET
// export function ScanBase ( side , base_area ) ; begin
65106: LD_INT 0
65108: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65109: LD_ADDR_VAR 0 3
65113: PUSH
65114: LD_VAR 0 2
65118: PPUSH
65119: LD_INT 81
65121: PUSH
65122: LD_VAR 0 1
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: PPUSH
65131: CALL_OW 70
65135: ST_TO_ADDR
// end ;
65136: LD_VAR 0 3
65140: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65141: LD_INT 0
65143: PPUSH
65144: PPUSH
65145: PPUSH
65146: PPUSH
// result := false ;
65147: LD_ADDR_VAR 0 2
65151: PUSH
65152: LD_INT 0
65154: ST_TO_ADDR
// side := GetSide ( unit ) ;
65155: LD_ADDR_VAR 0 3
65159: PUSH
65160: LD_VAR 0 1
65164: PPUSH
65165: CALL_OW 255
65169: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65170: LD_ADDR_VAR 0 4
65174: PUSH
65175: LD_VAR 0 1
65179: PPUSH
65180: CALL_OW 248
65184: ST_TO_ADDR
// case nat of 1 :
65185: LD_VAR 0 4
65189: PUSH
65190: LD_INT 1
65192: DOUBLE
65193: EQUAL
65194: IFTRUE 65198
65196: GO 65209
65198: POP
// tech := tech_lassight ; 2 :
65199: LD_ADDR_VAR 0 5
65203: PUSH
65204: LD_INT 12
65206: ST_TO_ADDR
65207: GO 65248
65209: LD_INT 2
65211: DOUBLE
65212: EQUAL
65213: IFTRUE 65217
65215: GO 65228
65217: POP
// tech := tech_mortar ; 3 :
65218: LD_ADDR_VAR 0 5
65222: PUSH
65223: LD_INT 41
65225: ST_TO_ADDR
65226: GO 65248
65228: LD_INT 3
65230: DOUBLE
65231: EQUAL
65232: IFTRUE 65236
65234: GO 65247
65236: POP
// tech := tech_bazooka ; end ;
65237: LD_ADDR_VAR 0 5
65241: PUSH
65242: LD_INT 44
65244: ST_TO_ADDR
65245: GO 65248
65247: POP
// if Researched ( side , tech ) then
65248: LD_VAR 0 3
65252: PPUSH
65253: LD_VAR 0 5
65257: PPUSH
65258: CALL_OW 325
65262: IFFALSE 65289
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65264: LD_ADDR_VAR 0 2
65268: PUSH
65269: LD_INT 5
65271: PUSH
65272: LD_INT 8
65274: PUSH
65275: LD_INT 9
65277: PUSH
65278: EMPTY
65279: LIST
65280: LIST
65281: LIST
65282: PUSH
65283: LD_VAR 0 4
65287: ARRAY
65288: ST_TO_ADDR
// end ;
65289: LD_VAR 0 2
65293: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65294: LD_INT 0
65296: PPUSH
65297: PPUSH
65298: PPUSH
// if not mines then
65299: LD_VAR 0 2
65303: NOT
65304: IFFALSE 65308
// exit ;
65306: GO 65452
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65308: LD_ADDR_VAR 0 5
65312: PUSH
65313: LD_INT 81
65315: PUSH
65316: LD_VAR 0 1
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: PUSH
65325: LD_INT 3
65327: PUSH
65328: LD_INT 21
65330: PUSH
65331: LD_INT 3
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: EMPTY
65343: LIST
65344: LIST
65345: PPUSH
65346: CALL_OW 69
65350: ST_TO_ADDR
// for i in mines do
65351: LD_ADDR_VAR 0 4
65355: PUSH
65356: LD_VAR 0 2
65360: PUSH
65361: FOR_IN
65362: IFFALSE 65450
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65364: LD_VAR 0 4
65368: PUSH
65369: LD_INT 1
65371: ARRAY
65372: PPUSH
65373: LD_VAR 0 4
65377: PUSH
65378: LD_INT 2
65380: ARRAY
65381: PPUSH
65382: CALL_OW 458
65386: NOT
65387: IFFALSE 65391
// continue ;
65389: GO 65361
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65391: LD_VAR 0 4
65395: PUSH
65396: LD_INT 1
65398: ARRAY
65399: PPUSH
65400: LD_VAR 0 4
65404: PUSH
65405: LD_INT 2
65407: ARRAY
65408: PPUSH
65409: CALL_OW 428
65413: PUSH
65414: LD_VAR 0 5
65418: IN
65419: IFFALSE 65448
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65421: LD_VAR 0 4
65425: PUSH
65426: LD_INT 1
65428: ARRAY
65429: PPUSH
65430: LD_VAR 0 4
65434: PUSH
65435: LD_INT 2
65437: ARRAY
65438: PPUSH
65439: LD_VAR 0 1
65443: PPUSH
65444: CALL_OW 456
// end ;
65448: GO 65361
65450: POP
65451: POP
// end ;
65452: LD_VAR 0 3
65456: RET
// export function Count ( array ) ; begin
65457: LD_INT 0
65459: PPUSH
// result := array + 0 ;
65460: LD_ADDR_VAR 0 2
65464: PUSH
65465: LD_VAR 0 1
65469: PUSH
65470: LD_INT 0
65472: PLUS
65473: ST_TO_ADDR
// end ;
65474: LD_VAR 0 2
65478: RET
// export function IsEmpty ( building ) ; begin
65479: LD_INT 0
65481: PPUSH
// if not building then
65482: LD_VAR 0 1
65486: NOT
65487: IFFALSE 65491
// exit ;
65489: GO 65534
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65491: LD_ADDR_VAR 0 2
65495: PUSH
65496: LD_VAR 0 1
65500: PUSH
65501: LD_INT 22
65503: PUSH
65504: LD_VAR 0 1
65508: PPUSH
65509: CALL_OW 255
65513: PUSH
65514: EMPTY
65515: LIST
65516: LIST
65517: PUSH
65518: LD_INT 58
65520: PUSH
65521: EMPTY
65522: LIST
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PPUSH
65528: CALL_OW 69
65532: IN
65533: ST_TO_ADDR
// end ;
65534: LD_VAR 0 2
65538: RET
// export function IsNotFull ( building ) ; var places ; begin
65539: LD_INT 0
65541: PPUSH
65542: PPUSH
// if not building then
65543: LD_VAR 0 1
65547: NOT
65548: IFFALSE 65552
// exit ;
65550: GO 65580
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
65552: LD_ADDR_VAR 0 2
65556: PUSH
65557: LD_VAR 0 1
65561: PPUSH
65562: LD_INT 3
65564: PUSH
65565: LD_INT 62
65567: PUSH
65568: EMPTY
65569: LIST
65570: PUSH
65571: EMPTY
65572: LIST
65573: LIST
65574: PPUSH
65575: CALL_OW 72
65579: ST_TO_ADDR
// end ;
65580: LD_VAR 0 2
65584: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65585: LD_INT 0
65587: PPUSH
65588: PPUSH
65589: PPUSH
65590: PPUSH
// tmp := [ ] ;
65591: LD_ADDR_VAR 0 3
65595: PUSH
65596: EMPTY
65597: ST_TO_ADDR
// list := [ ] ;
65598: LD_ADDR_VAR 0 5
65602: PUSH
65603: EMPTY
65604: ST_TO_ADDR
// for i = 16 to 25 do
65605: LD_ADDR_VAR 0 4
65609: PUSH
65610: DOUBLE
65611: LD_INT 16
65613: DEC
65614: ST_TO_ADDR
65615: LD_INT 25
65617: PUSH
65618: FOR_TO
65619: IFFALSE 65692
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65621: LD_ADDR_VAR 0 3
65625: PUSH
65626: LD_VAR 0 3
65630: PUSH
65631: LD_INT 22
65633: PUSH
65634: LD_VAR 0 1
65638: PPUSH
65639: CALL_OW 255
65643: PUSH
65644: EMPTY
65645: LIST
65646: LIST
65647: PUSH
65648: LD_INT 91
65650: PUSH
65651: LD_VAR 0 1
65655: PUSH
65656: LD_INT 6
65658: PUSH
65659: EMPTY
65660: LIST
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 30
65666: PUSH
65667: LD_VAR 0 4
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: LIST
65680: PUSH
65681: EMPTY
65682: LIST
65683: PPUSH
65684: CALL_OW 69
65688: ADD
65689: ST_TO_ADDR
65690: GO 65618
65692: POP
65693: POP
// for i = 1 to tmp do
65694: LD_ADDR_VAR 0 4
65698: PUSH
65699: DOUBLE
65700: LD_INT 1
65702: DEC
65703: ST_TO_ADDR
65704: LD_VAR 0 3
65708: PUSH
65709: FOR_TO
65710: IFFALSE 65798
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65712: LD_ADDR_VAR 0 5
65716: PUSH
65717: LD_VAR 0 5
65721: PUSH
65722: LD_VAR 0 3
65726: PUSH
65727: LD_VAR 0 4
65731: ARRAY
65732: PPUSH
65733: CALL_OW 266
65737: PUSH
65738: LD_VAR 0 3
65742: PUSH
65743: LD_VAR 0 4
65747: ARRAY
65748: PPUSH
65749: CALL_OW 250
65753: PUSH
65754: LD_VAR 0 3
65758: PUSH
65759: LD_VAR 0 4
65763: ARRAY
65764: PPUSH
65765: CALL_OW 251
65769: PUSH
65770: LD_VAR 0 3
65774: PUSH
65775: LD_VAR 0 4
65779: ARRAY
65780: PPUSH
65781: CALL_OW 254
65785: PUSH
65786: EMPTY
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: PUSH
65792: EMPTY
65793: LIST
65794: ADD
65795: ST_TO_ADDR
65796: GO 65709
65798: POP
65799: POP
// result := list ;
65800: LD_ADDR_VAR 0 2
65804: PUSH
65805: LD_VAR 0 5
65809: ST_TO_ADDR
// end ;
65810: LD_VAR 0 2
65814: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
65815: LD_INT 0
65817: PPUSH
65818: PPUSH
65819: PPUSH
65820: PPUSH
65821: PPUSH
65822: PPUSH
65823: PPUSH
// if not factory then
65824: LD_VAR 0 1
65828: NOT
65829: IFFALSE 65833
// exit ;
65831: GO 66426
// if control = control_apeman then
65833: LD_VAR 0 4
65837: PUSH
65838: LD_INT 5
65840: EQUAL
65841: IFFALSE 65950
// begin tmp := UnitsInside ( factory ) ;
65843: LD_ADDR_VAR 0 8
65847: PUSH
65848: LD_VAR 0 1
65852: PPUSH
65853: CALL_OW 313
65857: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
65858: LD_VAR 0 8
65862: PPUSH
65863: LD_INT 25
65865: PUSH
65866: LD_INT 12
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PPUSH
65873: CALL_OW 72
65877: NOT
65878: IFFALSE 65888
// control := control_manual ;
65880: LD_ADDR_VAR 0 4
65884: PUSH
65885: LD_INT 1
65887: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
65888: LD_ADDR_VAR 0 8
65892: PUSH
65893: LD_VAR 0 1
65897: PPUSH
65898: CALL 65585 0 1
65902: ST_TO_ADDR
// if tmp then
65903: LD_VAR 0 8
65907: IFFALSE 65950
// begin for i in tmp do
65909: LD_ADDR_VAR 0 7
65913: PUSH
65914: LD_VAR 0 8
65918: PUSH
65919: FOR_IN
65920: IFFALSE 65948
// if i [ 1 ] = b_ext_radio then
65922: LD_VAR 0 7
65926: PUSH
65927: LD_INT 1
65929: ARRAY
65930: PUSH
65931: LD_INT 22
65933: EQUAL
65934: IFFALSE 65946
// begin control := control_remote ;
65936: LD_ADDR_VAR 0 4
65940: PUSH
65941: LD_INT 2
65943: ST_TO_ADDR
// break ;
65944: GO 65948
// end ;
65946: GO 65919
65948: POP
65949: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65950: LD_VAR 0 1
65954: PPUSH
65955: LD_VAR 0 2
65959: PPUSH
65960: LD_VAR 0 3
65964: PPUSH
65965: LD_VAR 0 4
65969: PPUSH
65970: LD_VAR 0 5
65974: PPUSH
65975: CALL_OW 448
65979: IFFALSE 66014
// begin result := [ chassis , engine , control , weapon ] ;
65981: LD_ADDR_VAR 0 6
65985: PUSH
65986: LD_VAR 0 2
65990: PUSH
65991: LD_VAR 0 3
65995: PUSH
65996: LD_VAR 0 4
66000: PUSH
66001: LD_VAR 0 5
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: ST_TO_ADDR
// exit ;
66012: GO 66426
// end ; _chassis := AvailableChassisList ( factory ) ;
66014: LD_ADDR_VAR 0 9
66018: PUSH
66019: LD_VAR 0 1
66023: PPUSH
66024: CALL_OW 475
66028: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66029: LD_ADDR_VAR 0 11
66033: PUSH
66034: LD_VAR 0 1
66038: PPUSH
66039: CALL_OW 476
66043: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66044: LD_ADDR_VAR 0 12
66048: PUSH
66049: LD_VAR 0 1
66053: PPUSH
66054: CALL_OW 477
66058: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66059: LD_ADDR_VAR 0 10
66063: PUSH
66064: LD_VAR 0 1
66068: PPUSH
66069: CALL_OW 478
66073: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
66074: LD_VAR 0 9
66078: NOT
66079: PUSH
66080: LD_VAR 0 11
66084: NOT
66085: OR
66086: PUSH
66087: LD_VAR 0 12
66091: NOT
66092: OR
66093: PUSH
66094: LD_VAR 0 10
66098: NOT
66099: OR
66100: IFFALSE 66135
// begin result := [ chassis , engine , control , weapon ] ;
66102: LD_ADDR_VAR 0 6
66106: PUSH
66107: LD_VAR 0 2
66111: PUSH
66112: LD_VAR 0 3
66116: PUSH
66117: LD_VAR 0 4
66121: PUSH
66122: LD_VAR 0 5
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: ST_TO_ADDR
// exit ;
66133: GO 66426
// end ; if not chassis in _chassis then
66135: LD_VAR 0 2
66139: PUSH
66140: LD_VAR 0 9
66144: IN
66145: NOT
66146: IFFALSE 66172
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66148: LD_ADDR_VAR 0 2
66152: PUSH
66153: LD_VAR 0 9
66157: PUSH
66158: LD_INT 1
66160: PPUSH
66161: LD_VAR 0 9
66165: PPUSH
66166: CALL_OW 12
66170: ARRAY
66171: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66172: LD_VAR 0 2
66176: PPUSH
66177: LD_VAR 0 3
66181: PPUSH
66182: CALL 66431 0 2
66186: NOT
66187: IFFALSE 66246
// repeat engine := _engine [ 1 ] ;
66189: LD_ADDR_VAR 0 3
66193: PUSH
66194: LD_VAR 0 11
66198: PUSH
66199: LD_INT 1
66201: ARRAY
66202: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66203: LD_ADDR_VAR 0 11
66207: PUSH
66208: LD_VAR 0 11
66212: PPUSH
66213: LD_INT 1
66215: PPUSH
66216: CALL_OW 3
66220: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66221: LD_VAR 0 2
66225: PPUSH
66226: LD_VAR 0 3
66230: PPUSH
66231: CALL 66431 0 2
66235: PUSH
66236: LD_VAR 0 11
66240: PUSH
66241: EMPTY
66242: EQUAL
66243: OR
66244: IFFALSE 66189
// if not control in _control then
66246: LD_VAR 0 4
66250: PUSH
66251: LD_VAR 0 12
66255: IN
66256: NOT
66257: IFFALSE 66283
// control := _control [ rand ( 1 , _control ) ] ;
66259: LD_ADDR_VAR 0 4
66263: PUSH
66264: LD_VAR 0 12
66268: PUSH
66269: LD_INT 1
66271: PPUSH
66272: LD_VAR 0 12
66276: PPUSH
66277: CALL_OW 12
66281: ARRAY
66282: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66283: LD_VAR 0 2
66287: PPUSH
66288: LD_VAR 0 5
66292: PPUSH
66293: CALL 66651 0 2
66297: NOT
66298: IFFALSE 66357
// repeat weapon := _weapon [ 1 ] ;
66300: LD_ADDR_VAR 0 5
66304: PUSH
66305: LD_VAR 0 10
66309: PUSH
66310: LD_INT 1
66312: ARRAY
66313: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66314: LD_ADDR_VAR 0 10
66318: PUSH
66319: LD_VAR 0 10
66323: PPUSH
66324: LD_INT 1
66326: PPUSH
66327: CALL_OW 3
66331: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66332: LD_VAR 0 2
66336: PPUSH
66337: LD_VAR 0 5
66341: PPUSH
66342: CALL 66651 0 2
66346: PUSH
66347: LD_VAR 0 10
66351: PUSH
66352: EMPTY
66353: EQUAL
66354: OR
66355: IFFALSE 66300
// result := [ ] ;
66357: LD_ADDR_VAR 0 6
66361: PUSH
66362: EMPTY
66363: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66364: LD_VAR 0 1
66368: PPUSH
66369: LD_VAR 0 2
66373: PPUSH
66374: LD_VAR 0 3
66378: PPUSH
66379: LD_VAR 0 4
66383: PPUSH
66384: LD_VAR 0 5
66388: PPUSH
66389: CALL_OW 448
66393: IFFALSE 66426
// result := [ chassis , engine , control , weapon ] ;
66395: LD_ADDR_VAR 0 6
66399: PUSH
66400: LD_VAR 0 2
66404: PUSH
66405: LD_VAR 0 3
66409: PUSH
66410: LD_VAR 0 4
66414: PUSH
66415: LD_VAR 0 5
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: LIST
66424: LIST
66425: ST_TO_ADDR
// end ;
66426: LD_VAR 0 6
66430: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66431: LD_INT 0
66433: PPUSH
// if not chassis or not engine then
66434: LD_VAR 0 1
66438: NOT
66439: PUSH
66440: LD_VAR 0 2
66444: NOT
66445: OR
66446: IFFALSE 66450
// exit ;
66448: GO 66646
// case engine of engine_solar :
66450: LD_VAR 0 2
66454: PUSH
66455: LD_INT 2
66457: DOUBLE
66458: EQUAL
66459: IFTRUE 66463
66461: GO 66501
66463: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66464: LD_ADDR_VAR 0 3
66468: PUSH
66469: LD_INT 11
66471: PUSH
66472: LD_INT 12
66474: PUSH
66475: LD_INT 13
66477: PUSH
66478: LD_INT 14
66480: PUSH
66481: LD_INT 1
66483: PUSH
66484: LD_INT 2
66486: PUSH
66487: LD_INT 3
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: ST_TO_ADDR
66499: GO 66630
66501: LD_INT 1
66503: DOUBLE
66504: EQUAL
66505: IFTRUE 66509
66507: GO 66571
66509: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66510: LD_ADDR_VAR 0 3
66514: PUSH
66515: LD_INT 11
66517: PUSH
66518: LD_INT 12
66520: PUSH
66521: LD_INT 13
66523: PUSH
66524: LD_INT 14
66526: PUSH
66527: LD_INT 1
66529: PUSH
66530: LD_INT 2
66532: PUSH
66533: LD_INT 3
66535: PUSH
66536: LD_INT 4
66538: PUSH
66539: LD_INT 5
66541: PUSH
66542: LD_INT 21
66544: PUSH
66545: LD_INT 23
66547: PUSH
66548: LD_INT 22
66550: PUSH
66551: LD_INT 24
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: ST_TO_ADDR
66569: GO 66630
66571: LD_INT 3
66573: DOUBLE
66574: EQUAL
66575: IFTRUE 66579
66577: GO 66629
66579: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66580: LD_ADDR_VAR 0 3
66584: PUSH
66585: LD_INT 13
66587: PUSH
66588: LD_INT 14
66590: PUSH
66591: LD_INT 2
66593: PUSH
66594: LD_INT 3
66596: PUSH
66597: LD_INT 4
66599: PUSH
66600: LD_INT 5
66602: PUSH
66603: LD_INT 21
66605: PUSH
66606: LD_INT 22
66608: PUSH
66609: LD_INT 23
66611: PUSH
66612: LD_INT 24
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: ST_TO_ADDR
66627: GO 66630
66629: POP
// result := ( chassis in result ) ;
66630: LD_ADDR_VAR 0 3
66634: PUSH
66635: LD_VAR 0 1
66639: PUSH
66640: LD_VAR 0 3
66644: IN
66645: ST_TO_ADDR
// end ;
66646: LD_VAR 0 3
66650: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66651: LD_INT 0
66653: PPUSH
// if not chassis or not weapon then
66654: LD_VAR 0 1
66658: NOT
66659: PUSH
66660: LD_VAR 0 2
66664: NOT
66665: OR
66666: IFFALSE 66670
// exit ;
66668: GO 67730
// case weapon of us_machine_gun :
66670: LD_VAR 0 2
66674: PUSH
66675: LD_INT 2
66677: DOUBLE
66678: EQUAL
66679: IFTRUE 66683
66681: GO 66713
66683: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66684: LD_ADDR_VAR 0 3
66688: PUSH
66689: LD_INT 1
66691: PUSH
66692: LD_INT 2
66694: PUSH
66695: LD_INT 3
66697: PUSH
66698: LD_INT 4
66700: PUSH
66701: LD_INT 5
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: LIST
66708: LIST
66709: LIST
66710: ST_TO_ADDR
66711: GO 67714
66713: LD_INT 3
66715: DOUBLE
66716: EQUAL
66717: IFTRUE 66721
66719: GO 66751
66721: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66722: LD_ADDR_VAR 0 3
66726: PUSH
66727: LD_INT 1
66729: PUSH
66730: LD_INT 2
66732: PUSH
66733: LD_INT 3
66735: PUSH
66736: LD_INT 4
66738: PUSH
66739: LD_INT 5
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: ST_TO_ADDR
66749: GO 67714
66751: LD_INT 11
66753: DOUBLE
66754: EQUAL
66755: IFTRUE 66759
66757: GO 66789
66759: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66760: LD_ADDR_VAR 0 3
66764: PUSH
66765: LD_INT 1
66767: PUSH
66768: LD_INT 2
66770: PUSH
66771: LD_INT 3
66773: PUSH
66774: LD_INT 4
66776: PUSH
66777: LD_INT 5
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: ST_TO_ADDR
66787: GO 67714
66789: LD_INT 4
66791: DOUBLE
66792: EQUAL
66793: IFTRUE 66797
66795: GO 66823
66797: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
66798: LD_ADDR_VAR 0 3
66802: PUSH
66803: LD_INT 2
66805: PUSH
66806: LD_INT 3
66808: PUSH
66809: LD_INT 4
66811: PUSH
66812: LD_INT 5
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: LIST
66819: LIST
66820: ST_TO_ADDR
66821: GO 67714
66823: LD_INT 5
66825: DOUBLE
66826: EQUAL
66827: IFTRUE 66831
66829: GO 66857
66831: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
66832: LD_ADDR_VAR 0 3
66836: PUSH
66837: LD_INT 2
66839: PUSH
66840: LD_INT 3
66842: PUSH
66843: LD_INT 4
66845: PUSH
66846: LD_INT 5
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: ST_TO_ADDR
66855: GO 67714
66857: LD_INT 9
66859: DOUBLE
66860: EQUAL
66861: IFTRUE 66865
66863: GO 66891
66865: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
66866: LD_ADDR_VAR 0 3
66870: PUSH
66871: LD_INT 2
66873: PUSH
66874: LD_INT 3
66876: PUSH
66877: LD_INT 4
66879: PUSH
66880: LD_INT 5
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: ST_TO_ADDR
66889: GO 67714
66891: LD_INT 7
66893: DOUBLE
66894: EQUAL
66895: IFTRUE 66899
66897: GO 66925
66899: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
66900: LD_ADDR_VAR 0 3
66904: PUSH
66905: LD_INT 2
66907: PUSH
66908: LD_INT 3
66910: PUSH
66911: LD_INT 4
66913: PUSH
66914: LD_INT 5
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: ST_TO_ADDR
66923: GO 67714
66925: LD_INT 12
66927: DOUBLE
66928: EQUAL
66929: IFTRUE 66933
66931: GO 66959
66933: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
66934: LD_ADDR_VAR 0 3
66938: PUSH
66939: LD_INT 2
66941: PUSH
66942: LD_INT 3
66944: PUSH
66945: LD_INT 4
66947: PUSH
66948: LD_INT 5
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: LIST
66955: LIST
66956: ST_TO_ADDR
66957: GO 67714
66959: LD_INT 13
66961: DOUBLE
66962: EQUAL
66963: IFTRUE 66967
66965: GO 66993
66967: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
66968: LD_ADDR_VAR 0 3
66972: PUSH
66973: LD_INT 2
66975: PUSH
66976: LD_INT 3
66978: PUSH
66979: LD_INT 4
66981: PUSH
66982: LD_INT 5
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: LIST
66989: LIST
66990: ST_TO_ADDR
66991: GO 67714
66993: LD_INT 14
66995: DOUBLE
66996: EQUAL
66997: IFTRUE 67001
66999: GO 67019
67001: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67002: LD_ADDR_VAR 0 3
67006: PUSH
67007: LD_INT 4
67009: PUSH
67010: LD_INT 5
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: ST_TO_ADDR
67017: GO 67714
67019: LD_INT 6
67021: DOUBLE
67022: EQUAL
67023: IFTRUE 67027
67025: GO 67045
67027: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67028: LD_ADDR_VAR 0 3
67032: PUSH
67033: LD_INT 4
67035: PUSH
67036: LD_INT 5
67038: PUSH
67039: EMPTY
67040: LIST
67041: LIST
67042: ST_TO_ADDR
67043: GO 67714
67045: LD_INT 10
67047: DOUBLE
67048: EQUAL
67049: IFTRUE 67053
67051: GO 67071
67053: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67054: LD_ADDR_VAR 0 3
67058: PUSH
67059: LD_INT 4
67061: PUSH
67062: LD_INT 5
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: ST_TO_ADDR
67069: GO 67714
67071: LD_INT 22
67073: DOUBLE
67074: EQUAL
67075: IFTRUE 67079
67077: GO 67105
67079: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67080: LD_ADDR_VAR 0 3
67084: PUSH
67085: LD_INT 11
67087: PUSH
67088: LD_INT 12
67090: PUSH
67091: LD_INT 13
67093: PUSH
67094: LD_INT 14
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: LIST
67101: LIST
67102: ST_TO_ADDR
67103: GO 67714
67105: LD_INT 23
67107: DOUBLE
67108: EQUAL
67109: IFTRUE 67113
67111: GO 67139
67113: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67114: LD_ADDR_VAR 0 3
67118: PUSH
67119: LD_INT 11
67121: PUSH
67122: LD_INT 12
67124: PUSH
67125: LD_INT 13
67127: PUSH
67128: LD_INT 14
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: ST_TO_ADDR
67137: GO 67714
67139: LD_INT 24
67141: DOUBLE
67142: EQUAL
67143: IFTRUE 67147
67145: GO 67173
67147: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67148: LD_ADDR_VAR 0 3
67152: PUSH
67153: LD_INT 11
67155: PUSH
67156: LD_INT 12
67158: PUSH
67159: LD_INT 13
67161: PUSH
67162: LD_INT 14
67164: PUSH
67165: EMPTY
67166: LIST
67167: LIST
67168: LIST
67169: LIST
67170: ST_TO_ADDR
67171: GO 67714
67173: LD_INT 30
67175: DOUBLE
67176: EQUAL
67177: IFTRUE 67181
67179: GO 67207
67181: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67182: LD_ADDR_VAR 0 3
67186: PUSH
67187: LD_INT 11
67189: PUSH
67190: LD_INT 12
67192: PUSH
67193: LD_INT 13
67195: PUSH
67196: LD_INT 14
67198: PUSH
67199: EMPTY
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: ST_TO_ADDR
67205: GO 67714
67207: LD_INT 25
67209: DOUBLE
67210: EQUAL
67211: IFTRUE 67215
67213: GO 67233
67215: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67216: LD_ADDR_VAR 0 3
67220: PUSH
67221: LD_INT 13
67223: PUSH
67224: LD_INT 14
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: ST_TO_ADDR
67231: GO 67714
67233: LD_INT 27
67235: DOUBLE
67236: EQUAL
67237: IFTRUE 67241
67239: GO 67259
67241: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
67242: LD_ADDR_VAR 0 3
67246: PUSH
67247: LD_INT 13
67249: PUSH
67250: LD_INT 14
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: ST_TO_ADDR
67257: GO 67714
67259: LD_INT 92
67261: DOUBLE
67262: EQUAL
67263: IFTRUE 67267
67265: GO 67293
67267: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67268: LD_ADDR_VAR 0 3
67272: PUSH
67273: LD_INT 11
67275: PUSH
67276: LD_INT 12
67278: PUSH
67279: LD_INT 13
67281: PUSH
67282: LD_INT 14
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: ST_TO_ADDR
67291: GO 67714
67293: LD_INT 28
67295: DOUBLE
67296: EQUAL
67297: IFTRUE 67301
67299: GO 67319
67301: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67302: LD_ADDR_VAR 0 3
67306: PUSH
67307: LD_INT 13
67309: PUSH
67310: LD_INT 14
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: ST_TO_ADDR
67317: GO 67714
67319: LD_INT 29
67321: DOUBLE
67322: EQUAL
67323: IFTRUE 67327
67325: GO 67345
67327: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67328: LD_ADDR_VAR 0 3
67332: PUSH
67333: LD_INT 13
67335: PUSH
67336: LD_INT 14
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: ST_TO_ADDR
67343: GO 67714
67345: LD_INT 31
67347: DOUBLE
67348: EQUAL
67349: IFTRUE 67353
67351: GO 67371
67353: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67354: LD_ADDR_VAR 0 3
67358: PUSH
67359: LD_INT 13
67361: PUSH
67362: LD_INT 14
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: ST_TO_ADDR
67369: GO 67714
67371: LD_INT 26
67373: DOUBLE
67374: EQUAL
67375: IFTRUE 67379
67377: GO 67397
67379: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67380: LD_ADDR_VAR 0 3
67384: PUSH
67385: LD_INT 13
67387: PUSH
67388: LD_INT 14
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: ST_TO_ADDR
67395: GO 67714
67397: LD_INT 42
67399: DOUBLE
67400: EQUAL
67401: IFTRUE 67405
67403: GO 67431
67405: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67406: LD_ADDR_VAR 0 3
67410: PUSH
67411: LD_INT 21
67413: PUSH
67414: LD_INT 22
67416: PUSH
67417: LD_INT 23
67419: PUSH
67420: LD_INT 24
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: LIST
67427: LIST
67428: ST_TO_ADDR
67429: GO 67714
67431: LD_INT 43
67433: DOUBLE
67434: EQUAL
67435: IFTRUE 67439
67437: GO 67465
67439: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67440: LD_ADDR_VAR 0 3
67444: PUSH
67445: LD_INT 21
67447: PUSH
67448: LD_INT 22
67450: PUSH
67451: LD_INT 23
67453: PUSH
67454: LD_INT 24
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: ST_TO_ADDR
67463: GO 67714
67465: LD_INT 44
67467: DOUBLE
67468: EQUAL
67469: IFTRUE 67473
67471: GO 67499
67473: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67474: LD_ADDR_VAR 0 3
67478: PUSH
67479: LD_INT 21
67481: PUSH
67482: LD_INT 22
67484: PUSH
67485: LD_INT 23
67487: PUSH
67488: LD_INT 24
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: ST_TO_ADDR
67497: GO 67714
67499: LD_INT 45
67501: DOUBLE
67502: EQUAL
67503: IFTRUE 67507
67505: GO 67533
67507: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67508: LD_ADDR_VAR 0 3
67512: PUSH
67513: LD_INT 21
67515: PUSH
67516: LD_INT 22
67518: PUSH
67519: LD_INT 23
67521: PUSH
67522: LD_INT 24
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: ST_TO_ADDR
67531: GO 67714
67533: LD_INT 49
67535: DOUBLE
67536: EQUAL
67537: IFTRUE 67541
67539: GO 67567
67541: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67542: LD_ADDR_VAR 0 3
67546: PUSH
67547: LD_INT 21
67549: PUSH
67550: LD_INT 22
67552: PUSH
67553: LD_INT 23
67555: PUSH
67556: LD_INT 24
67558: PUSH
67559: EMPTY
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: ST_TO_ADDR
67565: GO 67714
67567: LD_INT 51
67569: DOUBLE
67570: EQUAL
67571: IFTRUE 67575
67573: GO 67601
67575: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67576: LD_ADDR_VAR 0 3
67580: PUSH
67581: LD_INT 21
67583: PUSH
67584: LD_INT 22
67586: PUSH
67587: LD_INT 23
67589: PUSH
67590: LD_INT 24
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: ST_TO_ADDR
67599: GO 67714
67601: LD_INT 52
67603: DOUBLE
67604: EQUAL
67605: IFTRUE 67609
67607: GO 67635
67609: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67610: LD_ADDR_VAR 0 3
67614: PUSH
67615: LD_INT 21
67617: PUSH
67618: LD_INT 22
67620: PUSH
67621: LD_INT 23
67623: PUSH
67624: LD_INT 24
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: ST_TO_ADDR
67633: GO 67714
67635: LD_INT 53
67637: DOUBLE
67638: EQUAL
67639: IFTRUE 67643
67641: GO 67661
67643: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67644: LD_ADDR_VAR 0 3
67648: PUSH
67649: LD_INT 23
67651: PUSH
67652: LD_INT 24
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: ST_TO_ADDR
67659: GO 67714
67661: LD_INT 46
67663: DOUBLE
67664: EQUAL
67665: IFTRUE 67669
67667: GO 67687
67669: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67670: LD_ADDR_VAR 0 3
67674: PUSH
67675: LD_INT 23
67677: PUSH
67678: LD_INT 24
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: ST_TO_ADDR
67685: GO 67714
67687: LD_INT 47
67689: DOUBLE
67690: EQUAL
67691: IFTRUE 67695
67693: GO 67713
67695: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67696: LD_ADDR_VAR 0 3
67700: PUSH
67701: LD_INT 23
67703: PUSH
67704: LD_INT 24
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: ST_TO_ADDR
67711: GO 67714
67713: POP
// result := ( chassis in result ) ;
67714: LD_ADDR_VAR 0 3
67718: PUSH
67719: LD_VAR 0 1
67723: PUSH
67724: LD_VAR 0 3
67728: IN
67729: ST_TO_ADDR
// end ;
67730: LD_VAR 0 3
67734: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67735: LD_INT 0
67737: PPUSH
67738: PPUSH
67739: PPUSH
67740: PPUSH
67741: PPUSH
67742: PPUSH
67743: PPUSH
// result := array ;
67744: LD_ADDR_VAR 0 5
67748: PUSH
67749: LD_VAR 0 1
67753: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67754: LD_VAR 0 1
67758: NOT
67759: PUSH
67760: LD_VAR 0 2
67764: NOT
67765: OR
67766: PUSH
67767: LD_VAR 0 3
67771: NOT
67772: OR
67773: PUSH
67774: LD_VAR 0 2
67778: PUSH
67779: LD_VAR 0 1
67783: GREATER
67784: OR
67785: PUSH
67786: LD_VAR 0 3
67790: PUSH
67791: LD_VAR 0 1
67795: GREATER
67796: OR
67797: IFFALSE 67801
// exit ;
67799: GO 68097
// if direction then
67801: LD_VAR 0 4
67805: IFFALSE 67869
// begin d := 1 ;
67807: LD_ADDR_VAR 0 9
67811: PUSH
67812: LD_INT 1
67814: ST_TO_ADDR
// if i_from > i_to then
67815: LD_VAR 0 2
67819: PUSH
67820: LD_VAR 0 3
67824: GREATER
67825: IFFALSE 67851
// length := ( array - i_from ) + i_to else
67827: LD_ADDR_VAR 0 11
67831: PUSH
67832: LD_VAR 0 1
67836: PUSH
67837: LD_VAR 0 2
67841: MINUS
67842: PUSH
67843: LD_VAR 0 3
67847: PLUS
67848: ST_TO_ADDR
67849: GO 67867
// length := i_to - i_from ;
67851: LD_ADDR_VAR 0 11
67855: PUSH
67856: LD_VAR 0 3
67860: PUSH
67861: LD_VAR 0 2
67865: MINUS
67866: ST_TO_ADDR
// end else
67867: GO 67930
// begin d := - 1 ;
67869: LD_ADDR_VAR 0 9
67873: PUSH
67874: LD_INT 1
67876: NEG
67877: ST_TO_ADDR
// if i_from > i_to then
67878: LD_VAR 0 2
67882: PUSH
67883: LD_VAR 0 3
67887: GREATER
67888: IFFALSE 67908
// length := i_from - i_to else
67890: LD_ADDR_VAR 0 11
67894: PUSH
67895: LD_VAR 0 2
67899: PUSH
67900: LD_VAR 0 3
67904: MINUS
67905: ST_TO_ADDR
67906: GO 67930
// length := ( array - i_to ) + i_from ;
67908: LD_ADDR_VAR 0 11
67912: PUSH
67913: LD_VAR 0 1
67917: PUSH
67918: LD_VAR 0 3
67922: MINUS
67923: PUSH
67924: LD_VAR 0 2
67928: PLUS
67929: ST_TO_ADDR
// end ; if not length then
67930: LD_VAR 0 11
67934: NOT
67935: IFFALSE 67939
// exit ;
67937: GO 68097
// tmp := array ;
67939: LD_ADDR_VAR 0 10
67943: PUSH
67944: LD_VAR 0 1
67948: ST_TO_ADDR
// for i = 1 to length do
67949: LD_ADDR_VAR 0 6
67953: PUSH
67954: DOUBLE
67955: LD_INT 1
67957: DEC
67958: ST_TO_ADDR
67959: LD_VAR 0 11
67963: PUSH
67964: FOR_TO
67965: IFFALSE 68085
// begin for j = 1 to array do
67967: LD_ADDR_VAR 0 7
67971: PUSH
67972: DOUBLE
67973: LD_INT 1
67975: DEC
67976: ST_TO_ADDR
67977: LD_VAR 0 1
67981: PUSH
67982: FOR_TO
67983: IFFALSE 68071
// begin k := j + d ;
67985: LD_ADDR_VAR 0 8
67989: PUSH
67990: LD_VAR 0 7
67994: PUSH
67995: LD_VAR 0 9
67999: PLUS
68000: ST_TO_ADDR
// if k > array then
68001: LD_VAR 0 8
68005: PUSH
68006: LD_VAR 0 1
68010: GREATER
68011: IFFALSE 68021
// k := 1 ;
68013: LD_ADDR_VAR 0 8
68017: PUSH
68018: LD_INT 1
68020: ST_TO_ADDR
// if not k then
68021: LD_VAR 0 8
68025: NOT
68026: IFFALSE 68038
// k := array ;
68028: LD_ADDR_VAR 0 8
68032: PUSH
68033: LD_VAR 0 1
68037: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68038: LD_ADDR_VAR 0 10
68042: PUSH
68043: LD_VAR 0 10
68047: PPUSH
68048: LD_VAR 0 8
68052: PPUSH
68053: LD_VAR 0 1
68057: PUSH
68058: LD_VAR 0 7
68062: ARRAY
68063: PPUSH
68064: CALL_OW 1
68068: ST_TO_ADDR
// end ;
68069: GO 67982
68071: POP
68072: POP
// array := tmp ;
68073: LD_ADDR_VAR 0 1
68077: PUSH
68078: LD_VAR 0 10
68082: ST_TO_ADDR
// end ;
68083: GO 67964
68085: POP
68086: POP
// result := array ;
68087: LD_ADDR_VAR 0 5
68091: PUSH
68092: LD_VAR 0 1
68096: ST_TO_ADDR
// end ;
68097: LD_VAR 0 5
68101: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68102: LD_INT 0
68104: PPUSH
68105: PPUSH
// result := 0 ;
68106: LD_ADDR_VAR 0 3
68110: PUSH
68111: LD_INT 0
68113: ST_TO_ADDR
// if not array or not value in array then
68114: LD_VAR 0 1
68118: NOT
68119: PUSH
68120: LD_VAR 0 2
68124: PUSH
68125: LD_VAR 0 1
68129: IN
68130: NOT
68131: OR
68132: IFFALSE 68136
// exit ;
68134: GO 68190
// for i = 1 to array do
68136: LD_ADDR_VAR 0 4
68140: PUSH
68141: DOUBLE
68142: LD_INT 1
68144: DEC
68145: ST_TO_ADDR
68146: LD_VAR 0 1
68150: PUSH
68151: FOR_TO
68152: IFFALSE 68188
// if value = array [ i ] then
68154: LD_VAR 0 2
68158: PUSH
68159: LD_VAR 0 1
68163: PUSH
68164: LD_VAR 0 4
68168: ARRAY
68169: EQUAL
68170: IFFALSE 68186
// begin result := i ;
68172: LD_ADDR_VAR 0 3
68176: PUSH
68177: LD_VAR 0 4
68181: ST_TO_ADDR
// exit ;
68182: POP
68183: POP
68184: GO 68190
// end ;
68186: GO 68151
68188: POP
68189: POP
// end ;
68190: LD_VAR 0 3
68194: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68195: LD_INT 0
68197: PPUSH
// vc_chassis := chassis ;
68198: LD_ADDR_OWVAR 37
68202: PUSH
68203: LD_VAR 0 1
68207: ST_TO_ADDR
// vc_engine := engine ;
68208: LD_ADDR_OWVAR 39
68212: PUSH
68213: LD_VAR 0 2
68217: ST_TO_ADDR
// vc_control := control ;
68218: LD_ADDR_OWVAR 38
68222: PUSH
68223: LD_VAR 0 3
68227: ST_TO_ADDR
// vc_weapon := weapon ;
68228: LD_ADDR_OWVAR 40
68232: PUSH
68233: LD_VAR 0 4
68237: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68238: LD_ADDR_OWVAR 41
68242: PUSH
68243: LD_VAR 0 5
68247: ST_TO_ADDR
// end ;
68248: LD_VAR 0 6
68252: RET
// export function WantPlant ( unit ) ; var task ; begin
68253: LD_INT 0
68255: PPUSH
68256: PPUSH
// result := false ;
68257: LD_ADDR_VAR 0 2
68261: PUSH
68262: LD_INT 0
68264: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68265: LD_ADDR_VAR 0 3
68269: PUSH
68270: LD_VAR 0 1
68274: PPUSH
68275: CALL_OW 437
68279: ST_TO_ADDR
// if task then
68280: LD_VAR 0 3
68284: IFFALSE 68312
// if task [ 1 ] [ 1 ] = p then
68286: LD_VAR 0 3
68290: PUSH
68291: LD_INT 1
68293: ARRAY
68294: PUSH
68295: LD_INT 1
68297: ARRAY
68298: PUSH
68299: LD_STRING p
68301: EQUAL
68302: IFFALSE 68312
// result := true ;
68304: LD_ADDR_VAR 0 2
68308: PUSH
68309: LD_INT 1
68311: ST_TO_ADDR
// end ;
68312: LD_VAR 0 2
68316: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68317: LD_INT 0
68319: PPUSH
68320: PPUSH
68321: PPUSH
68322: PPUSH
// if pos < 1 then
68323: LD_VAR 0 2
68327: PUSH
68328: LD_INT 1
68330: LESS
68331: IFFALSE 68335
// exit ;
68333: GO 68638
// if pos = 1 then
68335: LD_VAR 0 2
68339: PUSH
68340: LD_INT 1
68342: EQUAL
68343: IFFALSE 68376
// result := Replace ( arr , pos [ 1 ] , value ) else
68345: LD_ADDR_VAR 0 4
68349: PUSH
68350: LD_VAR 0 1
68354: PPUSH
68355: LD_VAR 0 2
68359: PUSH
68360: LD_INT 1
68362: ARRAY
68363: PPUSH
68364: LD_VAR 0 3
68368: PPUSH
68369: CALL_OW 1
68373: ST_TO_ADDR
68374: GO 68638
// begin tmp := arr ;
68376: LD_ADDR_VAR 0 6
68380: PUSH
68381: LD_VAR 0 1
68385: ST_TO_ADDR
// s_arr := [ tmp ] ;
68386: LD_ADDR_VAR 0 7
68390: PUSH
68391: LD_VAR 0 6
68395: PUSH
68396: EMPTY
68397: LIST
68398: ST_TO_ADDR
// for i = 1 to pos - 1 do
68399: LD_ADDR_VAR 0 5
68403: PUSH
68404: DOUBLE
68405: LD_INT 1
68407: DEC
68408: ST_TO_ADDR
68409: LD_VAR 0 2
68413: PUSH
68414: LD_INT 1
68416: MINUS
68417: PUSH
68418: FOR_TO
68419: IFFALSE 68464
// begin tmp := tmp [ pos [ i ] ] ;
68421: LD_ADDR_VAR 0 6
68425: PUSH
68426: LD_VAR 0 6
68430: PUSH
68431: LD_VAR 0 2
68435: PUSH
68436: LD_VAR 0 5
68440: ARRAY
68441: ARRAY
68442: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68443: LD_ADDR_VAR 0 7
68447: PUSH
68448: LD_VAR 0 7
68452: PUSH
68453: LD_VAR 0 6
68457: PUSH
68458: EMPTY
68459: LIST
68460: ADD
68461: ST_TO_ADDR
// end ;
68462: GO 68418
68464: POP
68465: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68466: LD_ADDR_VAR 0 6
68470: PUSH
68471: LD_VAR 0 6
68475: PPUSH
68476: LD_VAR 0 2
68480: PUSH
68481: LD_VAR 0 2
68485: ARRAY
68486: PPUSH
68487: LD_VAR 0 3
68491: PPUSH
68492: CALL_OW 1
68496: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68497: LD_ADDR_VAR 0 7
68501: PUSH
68502: LD_VAR 0 7
68506: PPUSH
68507: LD_VAR 0 7
68511: PPUSH
68512: LD_VAR 0 6
68516: PPUSH
68517: CALL_OW 1
68521: ST_TO_ADDR
// for i = s_arr downto 2 do
68522: LD_ADDR_VAR 0 5
68526: PUSH
68527: DOUBLE
68528: LD_VAR 0 7
68532: INC
68533: ST_TO_ADDR
68534: LD_INT 2
68536: PUSH
68537: FOR_DOWNTO
68538: IFFALSE 68622
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68540: LD_ADDR_VAR 0 6
68544: PUSH
68545: LD_VAR 0 7
68549: PUSH
68550: LD_VAR 0 5
68554: PUSH
68555: LD_INT 1
68557: MINUS
68558: ARRAY
68559: PPUSH
68560: LD_VAR 0 2
68564: PUSH
68565: LD_VAR 0 5
68569: PUSH
68570: LD_INT 1
68572: MINUS
68573: ARRAY
68574: PPUSH
68575: LD_VAR 0 7
68579: PUSH
68580: LD_VAR 0 5
68584: ARRAY
68585: PPUSH
68586: CALL_OW 1
68590: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68591: LD_ADDR_VAR 0 7
68595: PUSH
68596: LD_VAR 0 7
68600: PPUSH
68601: LD_VAR 0 5
68605: PUSH
68606: LD_INT 1
68608: MINUS
68609: PPUSH
68610: LD_VAR 0 6
68614: PPUSH
68615: CALL_OW 1
68619: ST_TO_ADDR
// end ;
68620: GO 68537
68622: POP
68623: POP
// result := s_arr [ 1 ] ;
68624: LD_ADDR_VAR 0 4
68628: PUSH
68629: LD_VAR 0 7
68633: PUSH
68634: LD_INT 1
68636: ARRAY
68637: ST_TO_ADDR
// end ; end ;
68638: LD_VAR 0 4
68642: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68643: LD_INT 0
68645: PPUSH
68646: PPUSH
// if not list then
68647: LD_VAR 0 1
68651: NOT
68652: IFFALSE 68656
// exit ;
68654: GO 68747
// i := list [ pos1 ] ;
68656: LD_ADDR_VAR 0 5
68660: PUSH
68661: LD_VAR 0 1
68665: PUSH
68666: LD_VAR 0 2
68670: ARRAY
68671: ST_TO_ADDR
// if not i then
68672: LD_VAR 0 5
68676: NOT
68677: IFFALSE 68681
// exit ;
68679: GO 68747
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68681: LD_ADDR_VAR 0 1
68685: PUSH
68686: LD_VAR 0 1
68690: PPUSH
68691: LD_VAR 0 2
68695: PPUSH
68696: LD_VAR 0 1
68700: PUSH
68701: LD_VAR 0 3
68705: ARRAY
68706: PPUSH
68707: CALL_OW 1
68711: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68712: LD_ADDR_VAR 0 1
68716: PUSH
68717: LD_VAR 0 1
68721: PPUSH
68722: LD_VAR 0 3
68726: PPUSH
68727: LD_VAR 0 5
68731: PPUSH
68732: CALL_OW 1
68736: ST_TO_ADDR
// result := list ;
68737: LD_ADDR_VAR 0 4
68741: PUSH
68742: LD_VAR 0 1
68746: ST_TO_ADDR
// end ;
68747: LD_VAR 0 4
68751: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68752: LD_INT 0
68754: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68755: LD_ADDR_VAR 0 5
68759: PUSH
68760: LD_VAR 0 1
68764: PPUSH
68765: CALL_OW 250
68769: PPUSH
68770: LD_VAR 0 1
68774: PPUSH
68775: CALL_OW 251
68779: PPUSH
68780: LD_VAR 0 2
68784: PPUSH
68785: LD_VAR 0 3
68789: PPUSH
68790: LD_VAR 0 4
68794: PPUSH
68795: CALL 68805 0 5
68799: ST_TO_ADDR
// end ;
68800: LD_VAR 0 5
68804: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
68805: LD_INT 0
68807: PPUSH
68808: PPUSH
68809: PPUSH
68810: PPUSH
// if not list then
68811: LD_VAR 0 3
68815: NOT
68816: IFFALSE 68820
// exit ;
68818: GO 69208
// result := [ ] ;
68820: LD_ADDR_VAR 0 6
68824: PUSH
68825: EMPTY
68826: ST_TO_ADDR
// for i in list do
68827: LD_ADDR_VAR 0 7
68831: PUSH
68832: LD_VAR 0 3
68836: PUSH
68837: FOR_IN
68838: IFFALSE 69040
// begin tmp := GetDistUnitXY ( i , x , y ) ;
68840: LD_ADDR_VAR 0 9
68844: PUSH
68845: LD_VAR 0 7
68849: PPUSH
68850: LD_VAR 0 1
68854: PPUSH
68855: LD_VAR 0 2
68859: PPUSH
68860: CALL_OW 297
68864: ST_TO_ADDR
// if not result then
68865: LD_VAR 0 6
68869: NOT
68870: IFFALSE 68896
// result := [ [ i , tmp ] ] else
68872: LD_ADDR_VAR 0 6
68876: PUSH
68877: LD_VAR 0 7
68881: PUSH
68882: LD_VAR 0 9
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: EMPTY
68892: LIST
68893: ST_TO_ADDR
68894: GO 69038
// begin if result [ result ] [ 2 ] < tmp then
68896: LD_VAR 0 6
68900: PUSH
68901: LD_VAR 0 6
68905: ARRAY
68906: PUSH
68907: LD_INT 2
68909: ARRAY
68910: PUSH
68911: LD_VAR 0 9
68915: LESS
68916: IFFALSE 68958
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
68918: LD_ADDR_VAR 0 6
68922: PUSH
68923: LD_VAR 0 6
68927: PPUSH
68928: LD_VAR 0 6
68932: PUSH
68933: LD_INT 1
68935: PLUS
68936: PPUSH
68937: LD_VAR 0 7
68941: PUSH
68942: LD_VAR 0 9
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PPUSH
68951: CALL_OW 2
68955: ST_TO_ADDR
68956: GO 69038
// for j = 1 to result do
68958: LD_ADDR_VAR 0 8
68962: PUSH
68963: DOUBLE
68964: LD_INT 1
68966: DEC
68967: ST_TO_ADDR
68968: LD_VAR 0 6
68972: PUSH
68973: FOR_TO
68974: IFFALSE 69036
// begin if tmp < result [ j ] [ 2 ] then
68976: LD_VAR 0 9
68980: PUSH
68981: LD_VAR 0 6
68985: PUSH
68986: LD_VAR 0 8
68990: ARRAY
68991: PUSH
68992: LD_INT 2
68994: ARRAY
68995: LESS
68996: IFFALSE 69034
// begin result := Insert ( result , j , [ i , tmp ] ) ;
68998: LD_ADDR_VAR 0 6
69002: PUSH
69003: LD_VAR 0 6
69007: PPUSH
69008: LD_VAR 0 8
69012: PPUSH
69013: LD_VAR 0 7
69017: PUSH
69018: LD_VAR 0 9
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PPUSH
69027: CALL_OW 2
69031: ST_TO_ADDR
// break ;
69032: GO 69036
// end ; end ;
69034: GO 68973
69036: POP
69037: POP
// end ; end ;
69038: GO 68837
69040: POP
69041: POP
// if result and not asc then
69042: LD_VAR 0 6
69046: PUSH
69047: LD_VAR 0 4
69051: NOT
69052: AND
69053: IFFALSE 69128
// begin tmp := result ;
69055: LD_ADDR_VAR 0 9
69059: PUSH
69060: LD_VAR 0 6
69064: ST_TO_ADDR
// for i = tmp downto 1 do
69065: LD_ADDR_VAR 0 7
69069: PUSH
69070: DOUBLE
69071: LD_VAR 0 9
69075: INC
69076: ST_TO_ADDR
69077: LD_INT 1
69079: PUSH
69080: FOR_DOWNTO
69081: IFFALSE 69126
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69083: LD_ADDR_VAR 0 6
69087: PUSH
69088: LD_VAR 0 6
69092: PPUSH
69093: LD_VAR 0 9
69097: PUSH
69098: LD_VAR 0 7
69102: MINUS
69103: PUSH
69104: LD_INT 1
69106: PLUS
69107: PPUSH
69108: LD_VAR 0 9
69112: PUSH
69113: LD_VAR 0 7
69117: ARRAY
69118: PPUSH
69119: CALL_OW 1
69123: ST_TO_ADDR
69124: GO 69080
69126: POP
69127: POP
// end ; tmp := [ ] ;
69128: LD_ADDR_VAR 0 9
69132: PUSH
69133: EMPTY
69134: ST_TO_ADDR
// if mode then
69135: LD_VAR 0 5
69139: IFFALSE 69208
// begin for i = 1 to result do
69141: LD_ADDR_VAR 0 7
69145: PUSH
69146: DOUBLE
69147: LD_INT 1
69149: DEC
69150: ST_TO_ADDR
69151: LD_VAR 0 6
69155: PUSH
69156: FOR_TO
69157: IFFALSE 69196
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69159: LD_ADDR_VAR 0 9
69163: PUSH
69164: LD_VAR 0 9
69168: PPUSH
69169: LD_VAR 0 7
69173: PPUSH
69174: LD_VAR 0 6
69178: PUSH
69179: LD_VAR 0 7
69183: ARRAY
69184: PUSH
69185: LD_INT 1
69187: ARRAY
69188: PPUSH
69189: CALL_OW 1
69193: ST_TO_ADDR
69194: GO 69156
69196: POP
69197: POP
// result := tmp ;
69198: LD_ADDR_VAR 0 6
69202: PUSH
69203: LD_VAR 0 9
69207: ST_TO_ADDR
// end ; end ;
69208: LD_VAR 0 6
69212: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69213: LD_INT 0
69215: PPUSH
69216: PPUSH
69217: PPUSH
69218: PPUSH
69219: PPUSH
69220: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69221: LD_ADDR_VAR 0 5
69225: PUSH
69226: LD_INT 0
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: LD_INT 0
69234: PUSH
69235: EMPTY
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: LIST
69241: LIST
69242: ST_TO_ADDR
// if not x or not y then
69243: LD_VAR 0 2
69247: NOT
69248: PUSH
69249: LD_VAR 0 3
69253: NOT
69254: OR
69255: IFFALSE 69259
// exit ;
69257: GO 70909
// if not range then
69259: LD_VAR 0 4
69263: NOT
69264: IFFALSE 69274
// range := 10 ;
69266: LD_ADDR_VAR 0 4
69270: PUSH
69271: LD_INT 10
69273: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69274: LD_ADDR_VAR 0 8
69278: PUSH
69279: LD_INT 81
69281: PUSH
69282: LD_VAR 0 1
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 92
69293: PUSH
69294: LD_VAR 0 2
69298: PUSH
69299: LD_VAR 0 3
69303: PUSH
69304: LD_VAR 0 4
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 3
69317: PUSH
69318: LD_INT 21
69320: PUSH
69321: LD_INT 3
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: LIST
69336: PPUSH
69337: CALL_OW 69
69341: ST_TO_ADDR
// if not tmp then
69342: LD_VAR 0 8
69346: NOT
69347: IFFALSE 69351
// exit ;
69349: GO 70909
// for i in tmp do
69351: LD_ADDR_VAR 0 6
69355: PUSH
69356: LD_VAR 0 8
69360: PUSH
69361: FOR_IN
69362: IFFALSE 70884
// begin points := [ 0 , 0 , 0 ] ;
69364: LD_ADDR_VAR 0 9
69368: PUSH
69369: LD_INT 0
69371: PUSH
69372: LD_INT 0
69374: PUSH
69375: LD_INT 0
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: LIST
69382: ST_TO_ADDR
// bpoints := 1 ;
69383: LD_ADDR_VAR 0 10
69387: PUSH
69388: LD_INT 1
69390: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69391: LD_VAR 0 6
69395: PPUSH
69396: CALL_OW 247
69400: PUSH
69401: LD_INT 1
69403: DOUBLE
69404: EQUAL
69405: IFTRUE 69409
69407: GO 69987
69409: POP
// begin if GetClass ( i ) = 1 then
69410: LD_VAR 0 6
69414: PPUSH
69415: CALL_OW 257
69419: PUSH
69420: LD_INT 1
69422: EQUAL
69423: IFFALSE 69444
// points := [ 10 , 5 , 3 ] ;
69425: LD_ADDR_VAR 0 9
69429: PUSH
69430: LD_INT 10
69432: PUSH
69433: LD_INT 5
69435: PUSH
69436: LD_INT 3
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: LIST
69443: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69444: LD_VAR 0 6
69448: PPUSH
69449: CALL_OW 257
69453: PUSH
69454: LD_INT 2
69456: PUSH
69457: LD_INT 3
69459: PUSH
69460: LD_INT 4
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: LIST
69467: IN
69468: IFFALSE 69489
// points := [ 3 , 2 , 1 ] ;
69470: LD_ADDR_VAR 0 9
69474: PUSH
69475: LD_INT 3
69477: PUSH
69478: LD_INT 2
69480: PUSH
69481: LD_INT 1
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: LIST
69488: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69489: LD_VAR 0 6
69493: PPUSH
69494: CALL_OW 257
69498: PUSH
69499: LD_INT 5
69501: EQUAL
69502: IFFALSE 69523
// points := [ 130 , 5 , 2 ] ;
69504: LD_ADDR_VAR 0 9
69508: PUSH
69509: LD_INT 130
69511: PUSH
69512: LD_INT 5
69514: PUSH
69515: LD_INT 2
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: LIST
69522: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69523: LD_VAR 0 6
69527: PPUSH
69528: CALL_OW 257
69532: PUSH
69533: LD_INT 8
69535: EQUAL
69536: IFFALSE 69557
// points := [ 35 , 35 , 30 ] ;
69538: LD_ADDR_VAR 0 9
69542: PUSH
69543: LD_INT 35
69545: PUSH
69546: LD_INT 35
69548: PUSH
69549: LD_INT 30
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: LIST
69556: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69557: LD_VAR 0 6
69561: PPUSH
69562: CALL_OW 257
69566: PUSH
69567: LD_INT 9
69569: EQUAL
69570: IFFALSE 69591
// points := [ 20 , 55 , 40 ] ;
69572: LD_ADDR_VAR 0 9
69576: PUSH
69577: LD_INT 20
69579: PUSH
69580: LD_INT 55
69582: PUSH
69583: LD_INT 40
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: LIST
69590: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69591: LD_VAR 0 6
69595: PPUSH
69596: CALL_OW 257
69600: PUSH
69601: LD_INT 12
69603: PUSH
69604: LD_INT 16
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: IN
69611: IFFALSE 69632
// points := [ 5 , 3 , 2 ] ;
69613: LD_ADDR_VAR 0 9
69617: PUSH
69618: LD_INT 5
69620: PUSH
69621: LD_INT 3
69623: PUSH
69624: LD_INT 2
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: LIST
69631: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69632: LD_VAR 0 6
69636: PPUSH
69637: CALL_OW 257
69641: PUSH
69642: LD_INT 17
69644: EQUAL
69645: IFFALSE 69666
// points := [ 100 , 50 , 75 ] ;
69647: LD_ADDR_VAR 0 9
69651: PUSH
69652: LD_INT 100
69654: PUSH
69655: LD_INT 50
69657: PUSH
69658: LD_INT 75
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: LIST
69665: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69666: LD_VAR 0 6
69670: PPUSH
69671: CALL_OW 257
69675: PUSH
69676: LD_INT 15
69678: EQUAL
69679: IFFALSE 69700
// points := [ 10 , 5 , 3 ] ;
69681: LD_ADDR_VAR 0 9
69685: PUSH
69686: LD_INT 10
69688: PUSH
69689: LD_INT 5
69691: PUSH
69692: LD_INT 3
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: LIST
69699: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69700: LD_VAR 0 6
69704: PPUSH
69705: CALL_OW 257
69709: PUSH
69710: LD_INT 14
69712: EQUAL
69713: IFFALSE 69734
// points := [ 10 , 0 , 0 ] ;
69715: LD_ADDR_VAR 0 9
69719: PUSH
69720: LD_INT 10
69722: PUSH
69723: LD_INT 0
69725: PUSH
69726: LD_INT 0
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: LIST
69733: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69734: LD_VAR 0 6
69738: PPUSH
69739: CALL_OW 257
69743: PUSH
69744: LD_INT 11
69746: EQUAL
69747: IFFALSE 69768
// points := [ 30 , 10 , 5 ] ;
69749: LD_ADDR_VAR 0 9
69753: PUSH
69754: LD_INT 30
69756: PUSH
69757: LD_INT 10
69759: PUSH
69760: LD_INT 5
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: LIST
69767: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69768: LD_VAR 0 1
69772: PPUSH
69773: LD_INT 5
69775: PPUSH
69776: CALL_OW 321
69780: PUSH
69781: LD_INT 2
69783: EQUAL
69784: IFFALSE 69801
// bpoints := bpoints * 1.8 ;
69786: LD_ADDR_VAR 0 10
69790: PUSH
69791: LD_VAR 0 10
69795: PUSH
69796: LD_REAL  1.80000000000000E+0000
69799: MUL
69800: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
69801: LD_VAR 0 6
69805: PPUSH
69806: CALL_OW 257
69810: PUSH
69811: LD_INT 1
69813: PUSH
69814: LD_INT 2
69816: PUSH
69817: LD_INT 3
69819: PUSH
69820: LD_INT 4
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: IN
69829: PUSH
69830: LD_VAR 0 1
69834: PPUSH
69835: LD_INT 51
69837: PPUSH
69838: CALL_OW 321
69842: PUSH
69843: LD_INT 2
69845: EQUAL
69846: AND
69847: IFFALSE 69864
// bpoints := bpoints * 1.2 ;
69849: LD_ADDR_VAR 0 10
69853: PUSH
69854: LD_VAR 0 10
69858: PUSH
69859: LD_REAL  1.20000000000000E+0000
69862: MUL
69863: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
69864: LD_VAR 0 6
69868: PPUSH
69869: CALL_OW 257
69873: PUSH
69874: LD_INT 5
69876: PUSH
69877: LD_INT 7
69879: PUSH
69880: LD_INT 9
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: LIST
69887: IN
69888: PUSH
69889: LD_VAR 0 1
69893: PPUSH
69894: LD_INT 52
69896: PPUSH
69897: CALL_OW 321
69901: PUSH
69902: LD_INT 2
69904: EQUAL
69905: AND
69906: IFFALSE 69923
// bpoints := bpoints * 1.5 ;
69908: LD_ADDR_VAR 0 10
69912: PUSH
69913: LD_VAR 0 10
69917: PUSH
69918: LD_REAL  1.50000000000000E+0000
69921: MUL
69922: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
69923: LD_VAR 0 1
69927: PPUSH
69928: LD_INT 66
69930: PPUSH
69931: CALL_OW 321
69935: PUSH
69936: LD_INT 2
69938: EQUAL
69939: IFFALSE 69956
// bpoints := bpoints * 1.1 ;
69941: LD_ADDR_VAR 0 10
69945: PUSH
69946: LD_VAR 0 10
69950: PUSH
69951: LD_REAL  1.10000000000000E+0000
69954: MUL
69955: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
69956: LD_ADDR_VAR 0 10
69960: PUSH
69961: LD_VAR 0 10
69965: PUSH
69966: LD_VAR 0 6
69970: PPUSH
69971: LD_INT 1
69973: PPUSH
69974: CALL_OW 259
69978: PUSH
69979: LD_REAL  1.15000000000000E+0000
69982: MUL
69983: MUL
69984: ST_TO_ADDR
// end ; unit_vehicle :
69985: GO 70813
69987: LD_INT 2
69989: DOUBLE
69990: EQUAL
69991: IFTRUE 69995
69993: GO 70801
69995: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
69996: LD_VAR 0 6
70000: PPUSH
70001: CALL_OW 264
70005: PUSH
70006: LD_INT 2
70008: PUSH
70009: LD_INT 42
70011: PUSH
70012: LD_INT 24
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: LIST
70019: IN
70020: IFFALSE 70041
// points := [ 25 , 5 , 3 ] ;
70022: LD_ADDR_VAR 0 9
70026: PUSH
70027: LD_INT 25
70029: PUSH
70030: LD_INT 5
70032: PUSH
70033: LD_INT 3
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: LIST
70040: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70041: LD_VAR 0 6
70045: PPUSH
70046: CALL_OW 264
70050: PUSH
70051: LD_INT 4
70053: PUSH
70054: LD_INT 43
70056: PUSH
70057: LD_INT 25
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: LIST
70064: IN
70065: IFFALSE 70086
// points := [ 40 , 15 , 5 ] ;
70067: LD_ADDR_VAR 0 9
70071: PUSH
70072: LD_INT 40
70074: PUSH
70075: LD_INT 15
70077: PUSH
70078: LD_INT 5
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: LIST
70085: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70086: LD_VAR 0 6
70090: PPUSH
70091: CALL_OW 264
70095: PUSH
70096: LD_INT 3
70098: PUSH
70099: LD_INT 23
70101: PUSH
70102: EMPTY
70103: LIST
70104: LIST
70105: IN
70106: IFFALSE 70127
// points := [ 7 , 25 , 8 ] ;
70108: LD_ADDR_VAR 0 9
70112: PUSH
70113: LD_INT 7
70115: PUSH
70116: LD_INT 25
70118: PUSH
70119: LD_INT 8
70121: PUSH
70122: EMPTY
70123: LIST
70124: LIST
70125: LIST
70126: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70127: LD_VAR 0 6
70131: PPUSH
70132: CALL_OW 264
70136: PUSH
70137: LD_INT 5
70139: PUSH
70140: LD_INT 27
70142: PUSH
70143: LD_INT 44
70145: PUSH
70146: EMPTY
70147: LIST
70148: LIST
70149: LIST
70150: IN
70151: IFFALSE 70172
// points := [ 14 , 50 , 16 ] ;
70153: LD_ADDR_VAR 0 9
70157: PUSH
70158: LD_INT 14
70160: PUSH
70161: LD_INT 50
70163: PUSH
70164: LD_INT 16
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: LIST
70171: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70172: LD_VAR 0 6
70176: PPUSH
70177: CALL_OW 264
70181: PUSH
70182: LD_INT 6
70184: PUSH
70185: LD_INT 46
70187: PUSH
70188: EMPTY
70189: LIST
70190: LIST
70191: IN
70192: IFFALSE 70213
// points := [ 32 , 120 , 70 ] ;
70194: LD_ADDR_VAR 0 9
70198: PUSH
70199: LD_INT 32
70201: PUSH
70202: LD_INT 120
70204: PUSH
70205: LD_INT 70
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: LIST
70212: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
70213: LD_VAR 0 6
70217: PPUSH
70218: CALL_OW 264
70222: PUSH
70223: LD_INT 7
70225: PUSH
70226: LD_INT 28
70228: PUSH
70229: LD_INT 45
70231: PUSH
70232: LD_INT 92
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: IN
70241: IFFALSE 70262
// points := [ 35 , 20 , 45 ] ;
70243: LD_ADDR_VAR 0 9
70247: PUSH
70248: LD_INT 35
70250: PUSH
70251: LD_INT 20
70253: PUSH
70254: LD_INT 45
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: LIST
70261: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70262: LD_VAR 0 6
70266: PPUSH
70267: CALL_OW 264
70271: PUSH
70272: LD_INT 47
70274: PUSH
70275: EMPTY
70276: LIST
70277: IN
70278: IFFALSE 70299
// points := [ 67 , 45 , 75 ] ;
70280: LD_ADDR_VAR 0 9
70284: PUSH
70285: LD_INT 67
70287: PUSH
70288: LD_INT 45
70290: PUSH
70291: LD_INT 75
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: LIST
70298: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70299: LD_VAR 0 6
70303: PPUSH
70304: CALL_OW 264
70308: PUSH
70309: LD_INT 26
70311: PUSH
70312: EMPTY
70313: LIST
70314: IN
70315: IFFALSE 70336
// points := [ 120 , 30 , 80 ] ;
70317: LD_ADDR_VAR 0 9
70321: PUSH
70322: LD_INT 120
70324: PUSH
70325: LD_INT 30
70327: PUSH
70328: LD_INT 80
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: LIST
70335: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70336: LD_VAR 0 6
70340: PPUSH
70341: CALL_OW 264
70345: PUSH
70346: LD_INT 22
70348: PUSH
70349: EMPTY
70350: LIST
70351: IN
70352: IFFALSE 70373
// points := [ 40 , 1 , 1 ] ;
70354: LD_ADDR_VAR 0 9
70358: PUSH
70359: LD_INT 40
70361: PUSH
70362: LD_INT 1
70364: PUSH
70365: LD_INT 1
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: LIST
70372: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70373: LD_VAR 0 6
70377: PPUSH
70378: CALL_OW 264
70382: PUSH
70383: LD_INT 29
70385: PUSH
70386: EMPTY
70387: LIST
70388: IN
70389: IFFALSE 70410
// points := [ 70 , 200 , 400 ] ;
70391: LD_ADDR_VAR 0 9
70395: PUSH
70396: LD_INT 70
70398: PUSH
70399: LD_INT 200
70401: PUSH
70402: LD_INT 400
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: LIST
70409: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70410: LD_VAR 0 6
70414: PPUSH
70415: CALL_OW 264
70419: PUSH
70420: LD_INT 14
70422: PUSH
70423: LD_INT 53
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: IN
70430: IFFALSE 70451
// points := [ 40 , 10 , 20 ] ;
70432: LD_ADDR_VAR 0 9
70436: PUSH
70437: LD_INT 40
70439: PUSH
70440: LD_INT 10
70442: PUSH
70443: LD_INT 20
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: LIST
70450: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70451: LD_VAR 0 6
70455: PPUSH
70456: CALL_OW 264
70460: PUSH
70461: LD_INT 9
70463: PUSH
70464: EMPTY
70465: LIST
70466: IN
70467: IFFALSE 70488
// points := [ 5 , 70 , 20 ] ;
70469: LD_ADDR_VAR 0 9
70473: PUSH
70474: LD_INT 5
70476: PUSH
70477: LD_INT 70
70479: PUSH
70480: LD_INT 20
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: LIST
70487: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70488: LD_VAR 0 6
70492: PPUSH
70493: CALL_OW 264
70497: PUSH
70498: LD_INT 10
70500: PUSH
70501: EMPTY
70502: LIST
70503: IN
70504: IFFALSE 70525
// points := [ 35 , 110 , 70 ] ;
70506: LD_ADDR_VAR 0 9
70510: PUSH
70511: LD_INT 35
70513: PUSH
70514: LD_INT 110
70516: PUSH
70517: LD_INT 70
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: LIST
70524: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70525: LD_VAR 0 6
70529: PPUSH
70530: CALL_OW 265
70534: PUSH
70535: LD_INT 25
70537: EQUAL
70538: IFFALSE 70559
// points := [ 80 , 65 , 100 ] ;
70540: LD_ADDR_VAR 0 9
70544: PUSH
70545: LD_INT 80
70547: PUSH
70548: LD_INT 65
70550: PUSH
70551: LD_INT 100
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: LIST
70558: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70559: LD_VAR 0 6
70563: PPUSH
70564: CALL_OW 263
70568: PUSH
70569: LD_INT 1
70571: EQUAL
70572: IFFALSE 70607
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70574: LD_ADDR_VAR 0 10
70578: PUSH
70579: LD_VAR 0 10
70583: PUSH
70584: LD_VAR 0 6
70588: PPUSH
70589: CALL_OW 311
70593: PPUSH
70594: LD_INT 3
70596: PPUSH
70597: CALL_OW 259
70601: PUSH
70602: LD_INT 4
70604: MUL
70605: MUL
70606: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70607: LD_VAR 0 6
70611: PPUSH
70612: CALL_OW 263
70616: PUSH
70617: LD_INT 2
70619: EQUAL
70620: IFFALSE 70671
// begin j := IsControledBy ( i ) ;
70622: LD_ADDR_VAR 0 7
70626: PUSH
70627: LD_VAR 0 6
70631: PPUSH
70632: CALL_OW 312
70636: ST_TO_ADDR
// if j then
70637: LD_VAR 0 7
70641: IFFALSE 70671
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70643: LD_ADDR_VAR 0 10
70647: PUSH
70648: LD_VAR 0 10
70652: PUSH
70653: LD_VAR 0 7
70657: PPUSH
70658: LD_INT 3
70660: PPUSH
70661: CALL_OW 259
70665: PUSH
70666: LD_INT 3
70668: MUL
70669: MUL
70670: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70671: LD_VAR 0 6
70675: PPUSH
70676: CALL_OW 264
70680: PUSH
70681: LD_INT 5
70683: PUSH
70684: LD_INT 6
70686: PUSH
70687: LD_INT 46
70689: PUSH
70690: LD_INT 44
70692: PUSH
70693: LD_INT 47
70695: PUSH
70696: LD_INT 45
70698: PUSH
70699: LD_INT 28
70701: PUSH
70702: LD_INT 7
70704: PUSH
70705: LD_INT 27
70707: PUSH
70708: LD_INT 29
70710: PUSH
70711: EMPTY
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: IN
70723: PUSH
70724: LD_VAR 0 1
70728: PPUSH
70729: LD_INT 52
70731: PPUSH
70732: CALL_OW 321
70736: PUSH
70737: LD_INT 2
70739: EQUAL
70740: AND
70741: IFFALSE 70758
// bpoints := bpoints * 1.2 ;
70743: LD_ADDR_VAR 0 10
70747: PUSH
70748: LD_VAR 0 10
70752: PUSH
70753: LD_REAL  1.20000000000000E+0000
70756: MUL
70757: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70758: LD_VAR 0 6
70762: PPUSH
70763: CALL_OW 264
70767: PUSH
70768: LD_INT 6
70770: PUSH
70771: LD_INT 46
70773: PUSH
70774: LD_INT 47
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: LIST
70781: IN
70782: IFFALSE 70799
// bpoints := bpoints * 1.2 ;
70784: LD_ADDR_VAR 0 10
70788: PUSH
70789: LD_VAR 0 10
70793: PUSH
70794: LD_REAL  1.20000000000000E+0000
70797: MUL
70798: ST_TO_ADDR
// end ; unit_building :
70799: GO 70813
70801: LD_INT 3
70803: DOUBLE
70804: EQUAL
70805: IFTRUE 70809
70807: GO 70812
70809: POP
// ; end ;
70810: GO 70813
70812: POP
// for j = 1 to 3 do
70813: LD_ADDR_VAR 0 7
70817: PUSH
70818: DOUBLE
70819: LD_INT 1
70821: DEC
70822: ST_TO_ADDR
70823: LD_INT 3
70825: PUSH
70826: FOR_TO
70827: IFFALSE 70880
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
70829: LD_ADDR_VAR 0 5
70833: PUSH
70834: LD_VAR 0 5
70838: PPUSH
70839: LD_VAR 0 7
70843: PPUSH
70844: LD_VAR 0 5
70848: PUSH
70849: LD_VAR 0 7
70853: ARRAY
70854: PUSH
70855: LD_VAR 0 9
70859: PUSH
70860: LD_VAR 0 7
70864: ARRAY
70865: PUSH
70866: LD_VAR 0 10
70870: MUL
70871: PLUS
70872: PPUSH
70873: CALL_OW 1
70877: ST_TO_ADDR
70878: GO 70826
70880: POP
70881: POP
// end ;
70882: GO 69361
70884: POP
70885: POP
// result := Replace ( result , 4 , tmp ) ;
70886: LD_ADDR_VAR 0 5
70890: PUSH
70891: LD_VAR 0 5
70895: PPUSH
70896: LD_INT 4
70898: PPUSH
70899: LD_VAR 0 8
70903: PPUSH
70904: CALL_OW 1
70908: ST_TO_ADDR
// end ;
70909: LD_VAR 0 5
70913: RET
// export function DangerAtRange ( unit , range ) ; begin
70914: LD_INT 0
70916: PPUSH
// if not unit then
70917: LD_VAR 0 1
70921: NOT
70922: IFFALSE 70926
// exit ;
70924: GO 70971
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
70926: LD_ADDR_VAR 0 3
70930: PUSH
70931: LD_VAR 0 1
70935: PPUSH
70936: CALL_OW 255
70940: PPUSH
70941: LD_VAR 0 1
70945: PPUSH
70946: CALL_OW 250
70950: PPUSH
70951: LD_VAR 0 1
70955: PPUSH
70956: CALL_OW 251
70960: PPUSH
70961: LD_VAR 0 2
70965: PPUSH
70966: CALL 69213 0 4
70970: ST_TO_ADDR
// end ;
70971: LD_VAR 0 3
70975: RET
// export function DangerInArea ( side , area ) ; begin
70976: LD_INT 0
70978: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
70979: LD_ADDR_VAR 0 3
70983: PUSH
70984: LD_VAR 0 2
70988: PPUSH
70989: LD_INT 81
70991: PUSH
70992: LD_VAR 0 1
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PPUSH
71001: CALL_OW 70
71005: ST_TO_ADDR
// end ;
71006: LD_VAR 0 3
71010: RET
// export function IsExtension ( b ) ; begin
71011: LD_INT 0
71013: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71014: LD_ADDR_VAR 0 2
71018: PUSH
71019: LD_VAR 0 1
71023: PUSH
71024: LD_INT 23
71026: PUSH
71027: LD_INT 20
71029: PUSH
71030: LD_INT 22
71032: PUSH
71033: LD_INT 17
71035: PUSH
71036: LD_INT 24
71038: PUSH
71039: LD_INT 21
71041: PUSH
71042: LD_INT 19
71044: PUSH
71045: LD_INT 16
71047: PUSH
71048: LD_INT 25
71050: PUSH
71051: LD_INT 18
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: IN
71066: ST_TO_ADDR
// end ;
71067: LD_VAR 0 2
71071: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
71072: LD_INT 0
71074: PPUSH
71075: PPUSH
71076: PPUSH
// result := [ ] ;
71077: LD_ADDR_VAR 0 4
71081: PUSH
71082: EMPTY
71083: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71084: LD_ADDR_VAR 0 5
71088: PUSH
71089: LD_VAR 0 2
71093: PPUSH
71094: LD_INT 21
71096: PUSH
71097: LD_INT 3
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PPUSH
71104: CALL_OW 70
71108: ST_TO_ADDR
// if not tmp then
71109: LD_VAR 0 5
71113: NOT
71114: IFFALSE 71118
// exit ;
71116: GO 71182
// if checkLink then
71118: LD_VAR 0 3
71122: IFFALSE 71172
// begin for i in tmp do
71124: LD_ADDR_VAR 0 6
71128: PUSH
71129: LD_VAR 0 5
71133: PUSH
71134: FOR_IN
71135: IFFALSE 71170
// if GetBase ( i ) <> base then
71137: LD_VAR 0 6
71141: PPUSH
71142: CALL_OW 274
71146: PUSH
71147: LD_VAR 0 1
71151: NONEQUAL
71152: IFFALSE 71168
// ComLinkToBase ( base , i ) ;
71154: LD_VAR 0 1
71158: PPUSH
71159: LD_VAR 0 6
71163: PPUSH
71164: CALL_OW 169
71168: GO 71134
71170: POP
71171: POP
// end ; result := tmp ;
71172: LD_ADDR_VAR 0 4
71176: PUSH
71177: LD_VAR 0 5
71181: ST_TO_ADDR
// end ;
71182: LD_VAR 0 4
71186: RET
// export function ComComplete ( units , b ) ; var i ; begin
71187: LD_INT 0
71189: PPUSH
71190: PPUSH
// if not units then
71191: LD_VAR 0 1
71195: NOT
71196: IFFALSE 71200
// exit ;
71198: GO 71290
// for i in units do
71200: LD_ADDR_VAR 0 4
71204: PUSH
71205: LD_VAR 0 1
71209: PUSH
71210: FOR_IN
71211: IFFALSE 71288
// if BuildingStatus ( b ) = bs_build then
71213: LD_VAR 0 2
71217: PPUSH
71218: CALL_OW 461
71222: PUSH
71223: LD_INT 1
71225: EQUAL
71226: IFFALSE 71286
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71228: LD_VAR 0 4
71232: PPUSH
71233: LD_STRING h
71235: PUSH
71236: LD_VAR 0 2
71240: PPUSH
71241: CALL_OW 250
71245: PUSH
71246: LD_VAR 0 2
71250: PPUSH
71251: CALL_OW 251
71255: PUSH
71256: LD_VAR 0 2
71260: PUSH
71261: LD_INT 0
71263: PUSH
71264: LD_INT 0
71266: PUSH
71267: LD_INT 0
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: PUSH
71279: EMPTY
71280: LIST
71281: PPUSH
71282: CALL_OW 446
71286: GO 71210
71288: POP
71289: POP
// end ;
71290: LD_VAR 0 3
71294: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71295: LD_INT 0
71297: PPUSH
71298: PPUSH
71299: PPUSH
71300: PPUSH
71301: PPUSH
71302: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
71303: LD_VAR 0 1
71307: NOT
71308: PUSH
71309: LD_VAR 0 1
71313: PPUSH
71314: CALL_OW 263
71318: PUSH
71319: LD_INT 2
71321: NONEQUAL
71322: OR
71323: IFFALSE 71327
// exit ;
71325: GO 71643
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71327: LD_ADDR_VAR 0 6
71331: PUSH
71332: LD_INT 22
71334: PUSH
71335: LD_VAR 0 1
71339: PPUSH
71340: CALL_OW 255
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 2
71351: PUSH
71352: LD_INT 30
71354: PUSH
71355: LD_INT 36
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: PUSH
71362: LD_INT 34
71364: PUSH
71365: LD_INT 31
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: LIST
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PPUSH
71381: CALL_OW 69
71385: ST_TO_ADDR
// if not tmp then
71386: LD_VAR 0 6
71390: NOT
71391: IFFALSE 71395
// exit ;
71393: GO 71643
// result := [ ] ;
71395: LD_ADDR_VAR 0 2
71399: PUSH
71400: EMPTY
71401: ST_TO_ADDR
// for i in tmp do
71402: LD_ADDR_VAR 0 3
71406: PUSH
71407: LD_VAR 0 6
71411: PUSH
71412: FOR_IN
71413: IFFALSE 71484
// begin t := UnitsInside ( i ) ;
71415: LD_ADDR_VAR 0 4
71419: PUSH
71420: LD_VAR 0 3
71424: PPUSH
71425: CALL_OW 313
71429: ST_TO_ADDR
// if t then
71430: LD_VAR 0 4
71434: IFFALSE 71482
// for j in t do
71436: LD_ADDR_VAR 0 7
71440: PUSH
71441: LD_VAR 0 4
71445: PUSH
71446: FOR_IN
71447: IFFALSE 71480
// result := Replace ( result , result + 1 , j ) ;
71449: LD_ADDR_VAR 0 2
71453: PUSH
71454: LD_VAR 0 2
71458: PPUSH
71459: LD_VAR 0 2
71463: PUSH
71464: LD_INT 1
71466: PLUS
71467: PPUSH
71468: LD_VAR 0 7
71472: PPUSH
71473: CALL_OW 1
71477: ST_TO_ADDR
71478: GO 71446
71480: POP
71481: POP
// end ;
71482: GO 71412
71484: POP
71485: POP
// if not result then
71486: LD_VAR 0 2
71490: NOT
71491: IFFALSE 71495
// exit ;
71493: GO 71643
// mech := result [ 1 ] ;
71495: LD_ADDR_VAR 0 5
71499: PUSH
71500: LD_VAR 0 2
71504: PUSH
71505: LD_INT 1
71507: ARRAY
71508: ST_TO_ADDR
// if result > 1 then
71509: LD_VAR 0 2
71513: PUSH
71514: LD_INT 1
71516: GREATER
71517: IFFALSE 71629
// begin for i = 2 to result do
71519: LD_ADDR_VAR 0 3
71523: PUSH
71524: DOUBLE
71525: LD_INT 2
71527: DEC
71528: ST_TO_ADDR
71529: LD_VAR 0 2
71533: PUSH
71534: FOR_TO
71535: IFFALSE 71627
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71537: LD_ADDR_VAR 0 4
71541: PUSH
71542: LD_VAR 0 2
71546: PUSH
71547: LD_VAR 0 3
71551: ARRAY
71552: PPUSH
71553: LD_INT 3
71555: PPUSH
71556: CALL_OW 259
71560: PUSH
71561: LD_VAR 0 2
71565: PUSH
71566: LD_VAR 0 3
71570: ARRAY
71571: PPUSH
71572: CALL_OW 432
71576: MINUS
71577: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71578: LD_VAR 0 4
71582: PUSH
71583: LD_VAR 0 5
71587: PPUSH
71588: LD_INT 3
71590: PPUSH
71591: CALL_OW 259
71595: PUSH
71596: LD_VAR 0 5
71600: PPUSH
71601: CALL_OW 432
71605: MINUS
71606: GREATEREQUAL
71607: IFFALSE 71625
// mech := result [ i ] ;
71609: LD_ADDR_VAR 0 5
71613: PUSH
71614: LD_VAR 0 2
71618: PUSH
71619: LD_VAR 0 3
71623: ARRAY
71624: ST_TO_ADDR
// end ;
71625: GO 71534
71627: POP
71628: POP
// end ; ComLinkTo ( vehicle , mech ) ;
71629: LD_VAR 0 1
71633: PPUSH
71634: LD_VAR 0 5
71638: PPUSH
71639: CALL_OW 135
// end ;
71643: LD_VAR 0 2
71647: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71648: LD_INT 0
71650: PPUSH
71651: PPUSH
71652: PPUSH
71653: PPUSH
71654: PPUSH
71655: PPUSH
71656: PPUSH
71657: PPUSH
71658: PPUSH
71659: PPUSH
71660: PPUSH
71661: PPUSH
71662: PPUSH
// result := [ ] ;
71663: LD_ADDR_VAR 0 7
71667: PUSH
71668: EMPTY
71669: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71670: LD_VAR 0 1
71674: PPUSH
71675: CALL_OW 266
71679: PUSH
71680: LD_INT 0
71682: PUSH
71683: LD_INT 1
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: IN
71690: NOT
71691: IFFALSE 71695
// exit ;
71693: GO 73329
// if name then
71695: LD_VAR 0 3
71699: IFFALSE 71715
// SetBName ( base_dep , name ) ;
71701: LD_VAR 0 1
71705: PPUSH
71706: LD_VAR 0 3
71710: PPUSH
71711: CALL_OW 500
// base := GetBase ( base_dep ) ;
71715: LD_ADDR_VAR 0 15
71719: PUSH
71720: LD_VAR 0 1
71724: PPUSH
71725: CALL_OW 274
71729: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71730: LD_ADDR_VAR 0 16
71734: PUSH
71735: LD_VAR 0 1
71739: PPUSH
71740: CALL_OW 255
71744: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71745: LD_ADDR_VAR 0 17
71749: PUSH
71750: LD_VAR 0 1
71754: PPUSH
71755: CALL_OW 248
71759: ST_TO_ADDR
// if sources then
71760: LD_VAR 0 5
71764: IFFALSE 71811
// for i = 1 to 3 do
71766: LD_ADDR_VAR 0 8
71770: PUSH
71771: DOUBLE
71772: LD_INT 1
71774: DEC
71775: ST_TO_ADDR
71776: LD_INT 3
71778: PUSH
71779: FOR_TO
71780: IFFALSE 71809
// AddResourceType ( base , i , sources [ i ] ) ;
71782: LD_VAR 0 15
71786: PPUSH
71787: LD_VAR 0 8
71791: PPUSH
71792: LD_VAR 0 5
71796: PUSH
71797: LD_VAR 0 8
71801: ARRAY
71802: PPUSH
71803: CALL_OW 276
71807: GO 71779
71809: POP
71810: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
71811: LD_ADDR_VAR 0 18
71815: PUSH
71816: LD_VAR 0 15
71820: PPUSH
71821: LD_VAR 0 2
71825: PPUSH
71826: LD_INT 1
71828: PPUSH
71829: CALL 71072 0 3
71833: ST_TO_ADDR
// InitHc ;
71834: CALL_OW 19
// InitUc ;
71838: CALL_OW 18
// uc_side := side ;
71842: LD_ADDR_OWVAR 20
71846: PUSH
71847: LD_VAR 0 16
71851: ST_TO_ADDR
// uc_nation := nation ;
71852: LD_ADDR_OWVAR 21
71856: PUSH
71857: LD_VAR 0 17
71861: ST_TO_ADDR
// if buildings then
71862: LD_VAR 0 18
71866: IFFALSE 73188
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
71868: LD_ADDR_VAR 0 19
71872: PUSH
71873: LD_VAR 0 18
71877: PPUSH
71878: LD_INT 2
71880: PUSH
71881: LD_INT 30
71883: PUSH
71884: LD_INT 29
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: PUSH
71891: LD_INT 30
71893: PUSH
71894: LD_INT 30
71896: PUSH
71897: EMPTY
71898: LIST
71899: LIST
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: LIST
71905: PPUSH
71906: CALL_OW 72
71910: ST_TO_ADDR
// if tmp then
71911: LD_VAR 0 19
71915: IFFALSE 71963
// for i in tmp do
71917: LD_ADDR_VAR 0 8
71921: PUSH
71922: LD_VAR 0 19
71926: PUSH
71927: FOR_IN
71928: IFFALSE 71961
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
71930: LD_VAR 0 8
71934: PPUSH
71935: CALL_OW 250
71939: PPUSH
71940: LD_VAR 0 8
71944: PPUSH
71945: CALL_OW 251
71949: PPUSH
71950: LD_VAR 0 16
71954: PPUSH
71955: CALL_OW 441
71959: GO 71927
71961: POP
71962: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
71963: LD_VAR 0 18
71967: PPUSH
71968: LD_INT 2
71970: PUSH
71971: LD_INT 30
71973: PUSH
71974: LD_INT 32
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 30
71983: PUSH
71984: LD_INT 33
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: LIST
71995: PPUSH
71996: CALL_OW 72
72000: IFFALSE 72088
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72002: LD_ADDR_VAR 0 8
72006: PUSH
72007: LD_VAR 0 18
72011: PPUSH
72012: LD_INT 2
72014: PUSH
72015: LD_INT 30
72017: PUSH
72018: LD_INT 32
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 30
72027: PUSH
72028: LD_INT 33
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: LIST
72039: PPUSH
72040: CALL_OW 72
72044: PUSH
72045: FOR_IN
72046: IFFALSE 72086
// begin if not GetBWeapon ( i ) then
72048: LD_VAR 0 8
72052: PPUSH
72053: CALL_OW 269
72057: NOT
72058: IFFALSE 72084
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72060: LD_VAR 0 8
72064: PPUSH
72065: LD_VAR 0 8
72069: PPUSH
72070: LD_VAR 0 2
72074: PPUSH
72075: CALL 73334 0 2
72079: PPUSH
72080: CALL_OW 431
// end ;
72084: GO 72045
72086: POP
72087: POP
// end ; for i = 1 to personel do
72088: LD_ADDR_VAR 0 8
72092: PUSH
72093: DOUBLE
72094: LD_INT 1
72096: DEC
72097: ST_TO_ADDR
72098: LD_VAR 0 6
72102: PUSH
72103: FOR_TO
72104: IFFALSE 73168
// begin if i > 4 then
72106: LD_VAR 0 8
72110: PUSH
72111: LD_INT 4
72113: GREATER
72114: IFFALSE 72118
// break ;
72116: GO 73168
// case i of 1 :
72118: LD_VAR 0 8
72122: PUSH
72123: LD_INT 1
72125: DOUBLE
72126: EQUAL
72127: IFTRUE 72131
72129: GO 72211
72131: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72132: LD_ADDR_VAR 0 12
72136: PUSH
72137: LD_VAR 0 18
72141: PPUSH
72142: LD_INT 22
72144: PUSH
72145: LD_VAR 0 16
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 58
72156: PUSH
72157: EMPTY
72158: LIST
72159: PUSH
72160: LD_INT 2
72162: PUSH
72163: LD_INT 30
72165: PUSH
72166: LD_INT 32
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PUSH
72173: LD_INT 30
72175: PUSH
72176: LD_INT 4
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: LD_INT 30
72185: PUSH
72186: LD_INT 5
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: LIST
72197: LIST
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: LIST
72203: PPUSH
72204: CALL_OW 72
72208: ST_TO_ADDR
72209: GO 72433
72211: LD_INT 2
72213: DOUBLE
72214: EQUAL
72215: IFTRUE 72219
72217: GO 72281
72219: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72220: LD_ADDR_VAR 0 12
72224: PUSH
72225: LD_VAR 0 18
72229: PPUSH
72230: LD_INT 22
72232: PUSH
72233: LD_VAR 0 16
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: LD_INT 2
72244: PUSH
72245: LD_INT 30
72247: PUSH
72248: LD_INT 0
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 30
72257: PUSH
72258: LD_INT 1
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: LIST
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PPUSH
72274: CALL_OW 72
72278: ST_TO_ADDR
72279: GO 72433
72281: LD_INT 3
72283: DOUBLE
72284: EQUAL
72285: IFTRUE 72289
72287: GO 72351
72289: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72290: LD_ADDR_VAR 0 12
72294: PUSH
72295: LD_VAR 0 18
72299: PPUSH
72300: LD_INT 22
72302: PUSH
72303: LD_VAR 0 16
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 2
72314: PUSH
72315: LD_INT 30
72317: PUSH
72318: LD_INT 2
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 30
72327: PUSH
72328: LD_INT 3
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: LIST
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PPUSH
72344: CALL_OW 72
72348: ST_TO_ADDR
72349: GO 72433
72351: LD_INT 4
72353: DOUBLE
72354: EQUAL
72355: IFTRUE 72359
72357: GO 72432
72359: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72360: LD_ADDR_VAR 0 12
72364: PUSH
72365: LD_VAR 0 18
72369: PPUSH
72370: LD_INT 22
72372: PUSH
72373: LD_VAR 0 16
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: PUSH
72382: LD_INT 2
72384: PUSH
72385: LD_INT 30
72387: PUSH
72388: LD_INT 6
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 30
72397: PUSH
72398: LD_INT 7
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 30
72407: PUSH
72408: LD_INT 8
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PPUSH
72425: CALL_OW 72
72429: ST_TO_ADDR
72430: GO 72433
72432: POP
// if i = 1 then
72433: LD_VAR 0 8
72437: PUSH
72438: LD_INT 1
72440: EQUAL
72441: IFFALSE 72552
// begin tmp := [ ] ;
72443: LD_ADDR_VAR 0 19
72447: PUSH
72448: EMPTY
72449: ST_TO_ADDR
// for j in f do
72450: LD_ADDR_VAR 0 9
72454: PUSH
72455: LD_VAR 0 12
72459: PUSH
72460: FOR_IN
72461: IFFALSE 72534
// if GetBType ( j ) = b_bunker then
72463: LD_VAR 0 9
72467: PPUSH
72468: CALL_OW 266
72472: PUSH
72473: LD_INT 32
72475: EQUAL
72476: IFFALSE 72503
// tmp := Insert ( tmp , 1 , j ) else
72478: LD_ADDR_VAR 0 19
72482: PUSH
72483: LD_VAR 0 19
72487: PPUSH
72488: LD_INT 1
72490: PPUSH
72491: LD_VAR 0 9
72495: PPUSH
72496: CALL_OW 2
72500: ST_TO_ADDR
72501: GO 72532
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72503: LD_ADDR_VAR 0 19
72507: PUSH
72508: LD_VAR 0 19
72512: PPUSH
72513: LD_VAR 0 19
72517: PUSH
72518: LD_INT 1
72520: PLUS
72521: PPUSH
72522: LD_VAR 0 9
72526: PPUSH
72527: CALL_OW 2
72531: ST_TO_ADDR
72532: GO 72460
72534: POP
72535: POP
// if tmp then
72536: LD_VAR 0 19
72540: IFFALSE 72552
// f := tmp ;
72542: LD_ADDR_VAR 0 12
72546: PUSH
72547: LD_VAR 0 19
72551: ST_TO_ADDR
// end ; x := personel [ i ] ;
72552: LD_ADDR_VAR 0 13
72556: PUSH
72557: LD_VAR 0 6
72561: PUSH
72562: LD_VAR 0 8
72566: ARRAY
72567: ST_TO_ADDR
// if x = - 1 then
72568: LD_VAR 0 13
72572: PUSH
72573: LD_INT 1
72575: NEG
72576: EQUAL
72577: IFFALSE 72786
// begin for j in f do
72579: LD_ADDR_VAR 0 9
72583: PUSH
72584: LD_VAR 0 12
72588: PUSH
72589: FOR_IN
72590: IFFALSE 72782
// repeat InitHc ;
72592: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72596: LD_VAR 0 9
72600: PPUSH
72601: CALL_OW 266
72605: PUSH
72606: LD_INT 5
72608: EQUAL
72609: IFFALSE 72679
// begin if UnitsInside ( j ) < 3 then
72611: LD_VAR 0 9
72615: PPUSH
72616: CALL_OW 313
72620: PUSH
72621: LD_INT 3
72623: LESS
72624: IFFALSE 72660
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72626: LD_INT 0
72628: PPUSH
72629: LD_INT 5
72631: PUSH
72632: LD_INT 8
72634: PUSH
72635: LD_INT 9
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: LIST
72642: PUSH
72643: LD_VAR 0 17
72647: ARRAY
72648: PPUSH
72649: LD_VAR 0 4
72653: PPUSH
72654: CALL_OW 380
72658: GO 72677
// PrepareHuman ( false , i , skill ) ;
72660: LD_INT 0
72662: PPUSH
72663: LD_VAR 0 8
72667: PPUSH
72668: LD_VAR 0 4
72672: PPUSH
72673: CALL_OW 380
// end else
72677: GO 72696
// PrepareHuman ( false , i , skill ) ;
72679: LD_INT 0
72681: PPUSH
72682: LD_VAR 0 8
72686: PPUSH
72687: LD_VAR 0 4
72691: PPUSH
72692: CALL_OW 380
// un := CreateHuman ;
72696: LD_ADDR_VAR 0 14
72700: PUSH
72701: CALL_OW 44
72705: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72706: LD_ADDR_VAR 0 7
72710: PUSH
72711: LD_VAR 0 7
72715: PPUSH
72716: LD_INT 1
72718: PPUSH
72719: LD_VAR 0 14
72723: PPUSH
72724: CALL_OW 2
72728: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72729: LD_VAR 0 14
72733: PPUSH
72734: LD_VAR 0 9
72738: PPUSH
72739: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72743: LD_VAR 0 9
72747: PPUSH
72748: CALL_OW 313
72752: PUSH
72753: LD_INT 6
72755: EQUAL
72756: PUSH
72757: LD_VAR 0 9
72761: PPUSH
72762: CALL_OW 266
72766: PUSH
72767: LD_INT 32
72769: PUSH
72770: LD_INT 31
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: IN
72777: OR
72778: IFFALSE 72592
72780: GO 72589
72782: POP
72783: POP
// end else
72784: GO 73166
// for j = 1 to x do
72786: LD_ADDR_VAR 0 9
72790: PUSH
72791: DOUBLE
72792: LD_INT 1
72794: DEC
72795: ST_TO_ADDR
72796: LD_VAR 0 13
72800: PUSH
72801: FOR_TO
72802: IFFALSE 73164
// begin InitHc ;
72804: CALL_OW 19
// if not f then
72808: LD_VAR 0 12
72812: NOT
72813: IFFALSE 72902
// begin PrepareHuman ( false , i , skill ) ;
72815: LD_INT 0
72817: PPUSH
72818: LD_VAR 0 8
72822: PPUSH
72823: LD_VAR 0 4
72827: PPUSH
72828: CALL_OW 380
// un := CreateHuman ;
72832: LD_ADDR_VAR 0 14
72836: PUSH
72837: CALL_OW 44
72841: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72842: LD_ADDR_VAR 0 7
72846: PUSH
72847: LD_VAR 0 7
72851: PPUSH
72852: LD_INT 1
72854: PPUSH
72855: LD_VAR 0 14
72859: PPUSH
72860: CALL_OW 2
72864: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72865: LD_VAR 0 14
72869: PPUSH
72870: LD_VAR 0 1
72874: PPUSH
72875: CALL_OW 250
72879: PPUSH
72880: LD_VAR 0 1
72884: PPUSH
72885: CALL_OW 251
72889: PPUSH
72890: LD_INT 10
72892: PPUSH
72893: LD_INT 0
72895: PPUSH
72896: CALL_OW 50
// continue ;
72900: GO 72801
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
72902: LD_VAR 0 12
72906: PUSH
72907: LD_INT 1
72909: ARRAY
72910: PPUSH
72911: CALL_OW 313
72915: PUSH
72916: LD_VAR 0 12
72920: PUSH
72921: LD_INT 1
72923: ARRAY
72924: PPUSH
72925: CALL_OW 266
72929: PUSH
72930: LD_INT 32
72932: PUSH
72933: LD_INT 31
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: IN
72940: AND
72941: PUSH
72942: LD_VAR 0 12
72946: PUSH
72947: LD_INT 1
72949: ARRAY
72950: PPUSH
72951: CALL_OW 313
72955: PUSH
72956: LD_INT 6
72958: EQUAL
72959: OR
72960: IFFALSE 72980
// f := Delete ( f , 1 ) ;
72962: LD_ADDR_VAR 0 12
72966: PUSH
72967: LD_VAR 0 12
72971: PPUSH
72972: LD_INT 1
72974: PPUSH
72975: CALL_OW 3
72979: ST_TO_ADDR
// if not f then
72980: LD_VAR 0 12
72984: NOT
72985: IFFALSE 73003
// begin x := x + 2 ;
72987: LD_ADDR_VAR 0 13
72991: PUSH
72992: LD_VAR 0 13
72996: PUSH
72997: LD_INT 2
72999: PLUS
73000: ST_TO_ADDR
// continue ;
73001: GO 72801
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73003: LD_VAR 0 12
73007: PUSH
73008: LD_INT 1
73010: ARRAY
73011: PPUSH
73012: CALL_OW 266
73016: PUSH
73017: LD_INT 5
73019: EQUAL
73020: IFFALSE 73094
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73022: LD_VAR 0 12
73026: PUSH
73027: LD_INT 1
73029: ARRAY
73030: PPUSH
73031: CALL_OW 313
73035: PUSH
73036: LD_INT 3
73038: LESS
73039: IFFALSE 73075
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73041: LD_INT 0
73043: PPUSH
73044: LD_INT 5
73046: PUSH
73047: LD_INT 8
73049: PUSH
73050: LD_INT 9
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: LIST
73057: PUSH
73058: LD_VAR 0 17
73062: ARRAY
73063: PPUSH
73064: LD_VAR 0 4
73068: PPUSH
73069: CALL_OW 380
73073: GO 73092
// PrepareHuman ( false , i , skill ) ;
73075: LD_INT 0
73077: PPUSH
73078: LD_VAR 0 8
73082: PPUSH
73083: LD_VAR 0 4
73087: PPUSH
73088: CALL_OW 380
// end else
73092: GO 73111
// PrepareHuman ( false , i , skill ) ;
73094: LD_INT 0
73096: PPUSH
73097: LD_VAR 0 8
73101: PPUSH
73102: LD_VAR 0 4
73106: PPUSH
73107: CALL_OW 380
// un := CreateHuman ;
73111: LD_ADDR_VAR 0 14
73115: PUSH
73116: CALL_OW 44
73120: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73121: LD_ADDR_VAR 0 7
73125: PUSH
73126: LD_VAR 0 7
73130: PPUSH
73131: LD_INT 1
73133: PPUSH
73134: LD_VAR 0 14
73138: PPUSH
73139: CALL_OW 2
73143: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73144: LD_VAR 0 14
73148: PPUSH
73149: LD_VAR 0 12
73153: PUSH
73154: LD_INT 1
73156: ARRAY
73157: PPUSH
73158: CALL_OW 52
// end ;
73162: GO 72801
73164: POP
73165: POP
// end ;
73166: GO 72103
73168: POP
73169: POP
// result := result ^ buildings ;
73170: LD_ADDR_VAR 0 7
73174: PUSH
73175: LD_VAR 0 7
73179: PUSH
73180: LD_VAR 0 18
73184: ADD
73185: ST_TO_ADDR
// end else
73186: GO 73329
// begin for i = 1 to personel do
73188: LD_ADDR_VAR 0 8
73192: PUSH
73193: DOUBLE
73194: LD_INT 1
73196: DEC
73197: ST_TO_ADDR
73198: LD_VAR 0 6
73202: PUSH
73203: FOR_TO
73204: IFFALSE 73327
// begin if i > 4 then
73206: LD_VAR 0 8
73210: PUSH
73211: LD_INT 4
73213: GREATER
73214: IFFALSE 73218
// break ;
73216: GO 73327
// x := personel [ i ] ;
73218: LD_ADDR_VAR 0 13
73222: PUSH
73223: LD_VAR 0 6
73227: PUSH
73228: LD_VAR 0 8
73232: ARRAY
73233: ST_TO_ADDR
// if x = - 1 then
73234: LD_VAR 0 13
73238: PUSH
73239: LD_INT 1
73241: NEG
73242: EQUAL
73243: IFFALSE 73247
// continue ;
73245: GO 73203
// PrepareHuman ( false , i , skill ) ;
73247: LD_INT 0
73249: PPUSH
73250: LD_VAR 0 8
73254: PPUSH
73255: LD_VAR 0 4
73259: PPUSH
73260: CALL_OW 380
// un := CreateHuman ;
73264: LD_ADDR_VAR 0 14
73268: PUSH
73269: CALL_OW 44
73273: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73274: LD_VAR 0 14
73278: PPUSH
73279: LD_VAR 0 1
73283: PPUSH
73284: CALL_OW 250
73288: PPUSH
73289: LD_VAR 0 1
73293: PPUSH
73294: CALL_OW 251
73298: PPUSH
73299: LD_INT 10
73301: PPUSH
73302: LD_INT 0
73304: PPUSH
73305: CALL_OW 50
// result := result ^ un ;
73309: LD_ADDR_VAR 0 7
73313: PUSH
73314: LD_VAR 0 7
73318: PUSH
73319: LD_VAR 0 14
73323: ADD
73324: ST_TO_ADDR
// end ;
73325: GO 73203
73327: POP
73328: POP
// end ; end ;
73329: LD_VAR 0 7
73333: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73334: LD_INT 0
73336: PPUSH
73337: PPUSH
73338: PPUSH
73339: PPUSH
73340: PPUSH
73341: PPUSH
73342: PPUSH
73343: PPUSH
73344: PPUSH
73345: PPUSH
73346: PPUSH
73347: PPUSH
73348: PPUSH
73349: PPUSH
73350: PPUSH
73351: PPUSH
// result := false ;
73352: LD_ADDR_VAR 0 3
73356: PUSH
73357: LD_INT 0
73359: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73360: LD_VAR 0 1
73364: NOT
73365: PUSH
73366: LD_VAR 0 1
73370: PPUSH
73371: CALL_OW 266
73375: PUSH
73376: LD_INT 32
73378: PUSH
73379: LD_INT 33
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: IN
73386: NOT
73387: OR
73388: IFFALSE 73392
// exit ;
73390: GO 74501
// nat := GetNation ( tower ) ;
73392: LD_ADDR_VAR 0 12
73396: PUSH
73397: LD_VAR 0 1
73401: PPUSH
73402: CALL_OW 248
73406: ST_TO_ADDR
// side := GetSide ( tower ) ;
73407: LD_ADDR_VAR 0 16
73411: PUSH
73412: LD_VAR 0 1
73416: PPUSH
73417: CALL_OW 255
73421: ST_TO_ADDR
// x := GetX ( tower ) ;
73422: LD_ADDR_VAR 0 10
73426: PUSH
73427: LD_VAR 0 1
73431: PPUSH
73432: CALL_OW 250
73436: ST_TO_ADDR
// y := GetY ( tower ) ;
73437: LD_ADDR_VAR 0 11
73441: PUSH
73442: LD_VAR 0 1
73446: PPUSH
73447: CALL_OW 251
73451: ST_TO_ADDR
// if not x or not y then
73452: LD_VAR 0 10
73456: NOT
73457: PUSH
73458: LD_VAR 0 11
73462: NOT
73463: OR
73464: IFFALSE 73468
// exit ;
73466: GO 74501
// weapon := 0 ;
73468: LD_ADDR_VAR 0 18
73472: PUSH
73473: LD_INT 0
73475: ST_TO_ADDR
// fac_list := [ ] ;
73476: LD_ADDR_VAR 0 17
73480: PUSH
73481: EMPTY
73482: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
73483: LD_ADDR_VAR 0 6
73487: PUSH
73488: LD_VAR 0 1
73492: PPUSH
73493: CALL_OW 274
73497: PPUSH
73498: LD_VAR 0 2
73502: PPUSH
73503: LD_INT 0
73505: PPUSH
73506: CALL 71072 0 3
73510: PPUSH
73511: LD_INT 30
73513: PUSH
73514: LD_INT 3
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: PPUSH
73521: CALL_OW 72
73525: ST_TO_ADDR
// if not factories then
73526: LD_VAR 0 6
73530: NOT
73531: IFFALSE 73535
// exit ;
73533: GO 74501
// for i in factories do
73535: LD_ADDR_VAR 0 8
73539: PUSH
73540: LD_VAR 0 6
73544: PUSH
73545: FOR_IN
73546: IFFALSE 73571
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73548: LD_ADDR_VAR 0 17
73552: PUSH
73553: LD_VAR 0 17
73557: PUSH
73558: LD_VAR 0 8
73562: PPUSH
73563: CALL_OW 478
73567: UNION
73568: ST_TO_ADDR
73569: GO 73545
73571: POP
73572: POP
// if not fac_list then
73573: LD_VAR 0 17
73577: NOT
73578: IFFALSE 73582
// exit ;
73580: GO 74501
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73582: LD_ADDR_VAR 0 5
73586: PUSH
73587: LD_INT 4
73589: PUSH
73590: LD_INT 5
73592: PUSH
73593: LD_INT 9
73595: PUSH
73596: LD_INT 10
73598: PUSH
73599: LD_INT 6
73601: PUSH
73602: LD_INT 7
73604: PUSH
73605: LD_INT 11
73607: PUSH
73608: EMPTY
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 27
73619: PUSH
73620: LD_INT 28
73622: PUSH
73623: LD_INT 26
73625: PUSH
73626: LD_INT 30
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: LIST
73633: LIST
73634: PUSH
73635: LD_INT 43
73637: PUSH
73638: LD_INT 44
73640: PUSH
73641: LD_INT 46
73643: PUSH
73644: LD_INT 45
73646: PUSH
73647: LD_INT 47
73649: PUSH
73650: LD_INT 49
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: LIST
73659: LIST
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: LIST
73665: PUSH
73666: LD_VAR 0 12
73670: ARRAY
73671: ST_TO_ADDR
// list := list isect fac_list ;
73672: LD_ADDR_VAR 0 5
73676: PUSH
73677: LD_VAR 0 5
73681: PUSH
73682: LD_VAR 0 17
73686: ISECT
73687: ST_TO_ADDR
// if not list then
73688: LD_VAR 0 5
73692: NOT
73693: IFFALSE 73697
// exit ;
73695: GO 74501
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73697: LD_VAR 0 12
73701: PUSH
73702: LD_INT 3
73704: EQUAL
73705: PUSH
73706: LD_INT 49
73708: PUSH
73709: LD_VAR 0 5
73713: IN
73714: AND
73715: PUSH
73716: LD_INT 31
73718: PPUSH
73719: LD_VAR 0 16
73723: PPUSH
73724: CALL_OW 321
73728: PUSH
73729: LD_INT 2
73731: EQUAL
73732: AND
73733: IFFALSE 73793
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73735: LD_INT 22
73737: PUSH
73738: LD_VAR 0 16
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 35
73749: PUSH
73750: LD_INT 49
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: PUSH
73757: LD_INT 91
73759: PUSH
73760: LD_VAR 0 1
73764: PUSH
73765: LD_INT 10
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: LIST
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: LIST
73777: PPUSH
73778: CALL_OW 69
73782: NOT
73783: IFFALSE 73793
// weapon := ru_time_lapser ;
73785: LD_ADDR_VAR 0 18
73789: PUSH
73790: LD_INT 49
73792: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
73793: LD_VAR 0 12
73797: PUSH
73798: LD_INT 1
73800: PUSH
73801: LD_INT 2
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: IN
73808: PUSH
73809: LD_INT 11
73811: PUSH
73812: LD_VAR 0 5
73816: IN
73817: PUSH
73818: LD_INT 30
73820: PUSH
73821: LD_VAR 0 5
73825: IN
73826: OR
73827: AND
73828: PUSH
73829: LD_INT 6
73831: PPUSH
73832: LD_VAR 0 16
73836: PPUSH
73837: CALL_OW 321
73841: PUSH
73842: LD_INT 2
73844: EQUAL
73845: AND
73846: IFFALSE 74011
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
73848: LD_INT 22
73850: PUSH
73851: LD_VAR 0 16
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 2
73862: PUSH
73863: LD_INT 35
73865: PUSH
73866: LD_INT 11
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: PUSH
73873: LD_INT 35
73875: PUSH
73876: LD_INT 30
73878: PUSH
73879: EMPTY
73880: LIST
73881: LIST
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 91
73890: PUSH
73891: LD_VAR 0 1
73895: PUSH
73896: LD_INT 18
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: LIST
73903: PUSH
73904: EMPTY
73905: LIST
73906: LIST
73907: LIST
73908: PPUSH
73909: CALL_OW 69
73913: NOT
73914: PUSH
73915: LD_INT 22
73917: PUSH
73918: LD_VAR 0 16
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 2
73929: PUSH
73930: LD_INT 30
73932: PUSH
73933: LD_INT 32
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 30
73942: PUSH
73943: LD_INT 33
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 91
73957: PUSH
73958: LD_VAR 0 1
73962: PUSH
73963: LD_INT 12
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: LIST
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: LIST
73975: PUSH
73976: EMPTY
73977: LIST
73978: PPUSH
73979: CALL_OW 69
73983: PUSH
73984: LD_INT 2
73986: GREATER
73987: AND
73988: IFFALSE 74011
// weapon := [ us_radar , ar_radar ] [ nat ] ;
73990: LD_ADDR_VAR 0 18
73994: PUSH
73995: LD_INT 11
73997: PUSH
73998: LD_INT 30
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_VAR 0 12
74009: ARRAY
74010: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74011: LD_VAR 0 18
74015: NOT
74016: PUSH
74017: LD_INT 40
74019: PPUSH
74020: LD_VAR 0 16
74024: PPUSH
74025: CALL_OW 321
74029: PUSH
74030: LD_INT 2
74032: EQUAL
74033: AND
74034: PUSH
74035: LD_INT 7
74037: PUSH
74038: LD_VAR 0 5
74042: IN
74043: PUSH
74044: LD_INT 28
74046: PUSH
74047: LD_VAR 0 5
74051: IN
74052: OR
74053: PUSH
74054: LD_INT 45
74056: PUSH
74057: LD_VAR 0 5
74061: IN
74062: OR
74063: AND
74064: IFFALSE 74318
// begin hex := GetHexInfo ( x , y ) ;
74066: LD_ADDR_VAR 0 4
74070: PUSH
74071: LD_VAR 0 10
74075: PPUSH
74076: LD_VAR 0 11
74080: PPUSH
74081: CALL_OW 546
74085: ST_TO_ADDR
// if hex [ 1 ] then
74086: LD_VAR 0 4
74090: PUSH
74091: LD_INT 1
74093: ARRAY
74094: IFFALSE 74098
// exit ;
74096: GO 74501
// height := hex [ 2 ] ;
74098: LD_ADDR_VAR 0 15
74102: PUSH
74103: LD_VAR 0 4
74107: PUSH
74108: LD_INT 2
74110: ARRAY
74111: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74112: LD_ADDR_VAR 0 14
74116: PUSH
74117: LD_INT 0
74119: PUSH
74120: LD_INT 2
74122: PUSH
74123: LD_INT 3
74125: PUSH
74126: LD_INT 5
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: LIST
74133: LIST
74134: ST_TO_ADDR
// for i in tmp do
74135: LD_ADDR_VAR 0 8
74139: PUSH
74140: LD_VAR 0 14
74144: PUSH
74145: FOR_IN
74146: IFFALSE 74316
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74148: LD_ADDR_VAR 0 9
74152: PUSH
74153: LD_VAR 0 10
74157: PPUSH
74158: LD_VAR 0 8
74162: PPUSH
74163: LD_INT 5
74165: PPUSH
74166: CALL_OW 272
74170: PUSH
74171: LD_VAR 0 11
74175: PPUSH
74176: LD_VAR 0 8
74180: PPUSH
74181: LD_INT 5
74183: PPUSH
74184: CALL_OW 273
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74193: LD_VAR 0 9
74197: PUSH
74198: LD_INT 1
74200: ARRAY
74201: PPUSH
74202: LD_VAR 0 9
74206: PUSH
74207: LD_INT 2
74209: ARRAY
74210: PPUSH
74211: CALL_OW 488
74215: IFFALSE 74314
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74217: LD_ADDR_VAR 0 4
74221: PUSH
74222: LD_VAR 0 9
74226: PUSH
74227: LD_INT 1
74229: ARRAY
74230: PPUSH
74231: LD_VAR 0 9
74235: PUSH
74236: LD_INT 2
74238: ARRAY
74239: PPUSH
74240: CALL_OW 546
74244: ST_TO_ADDR
// if hex [ 1 ] then
74245: LD_VAR 0 4
74249: PUSH
74250: LD_INT 1
74252: ARRAY
74253: IFFALSE 74257
// continue ;
74255: GO 74145
// h := hex [ 2 ] ;
74257: LD_ADDR_VAR 0 13
74261: PUSH
74262: LD_VAR 0 4
74266: PUSH
74267: LD_INT 2
74269: ARRAY
74270: ST_TO_ADDR
// if h + 7 < height then
74271: LD_VAR 0 13
74275: PUSH
74276: LD_INT 7
74278: PLUS
74279: PUSH
74280: LD_VAR 0 15
74284: LESS
74285: IFFALSE 74314
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74287: LD_ADDR_VAR 0 18
74291: PUSH
74292: LD_INT 7
74294: PUSH
74295: LD_INT 28
74297: PUSH
74298: LD_INT 45
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: LIST
74305: PUSH
74306: LD_VAR 0 12
74310: ARRAY
74311: ST_TO_ADDR
// break ;
74312: GO 74316
// end ; end ; end ;
74314: GO 74145
74316: POP
74317: POP
// end ; if not weapon then
74318: LD_VAR 0 18
74322: NOT
74323: IFFALSE 74383
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74325: LD_ADDR_VAR 0 5
74329: PUSH
74330: LD_VAR 0 5
74334: PUSH
74335: LD_INT 11
74337: PUSH
74338: LD_INT 30
74340: PUSH
74341: LD_INT 49
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: LIST
74348: DIFF
74349: ST_TO_ADDR
// if not list then
74350: LD_VAR 0 5
74354: NOT
74355: IFFALSE 74359
// exit ;
74357: GO 74501
// weapon := list [ rand ( 1 , list ) ] ;
74359: LD_ADDR_VAR 0 18
74363: PUSH
74364: LD_VAR 0 5
74368: PUSH
74369: LD_INT 1
74371: PPUSH
74372: LD_VAR 0 5
74376: PPUSH
74377: CALL_OW 12
74381: ARRAY
74382: ST_TO_ADDR
// end ; if weapon then
74383: LD_VAR 0 18
74387: IFFALSE 74501
// begin tmp := CostOfWeapon ( weapon ) ;
74389: LD_ADDR_VAR 0 14
74393: PUSH
74394: LD_VAR 0 18
74398: PPUSH
74399: CALL_OW 451
74403: ST_TO_ADDR
// j := GetBase ( tower ) ;
74404: LD_ADDR_VAR 0 9
74408: PUSH
74409: LD_VAR 0 1
74413: PPUSH
74414: CALL_OW 274
74418: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74419: LD_VAR 0 9
74423: PPUSH
74424: LD_INT 1
74426: PPUSH
74427: CALL_OW 275
74431: PUSH
74432: LD_VAR 0 14
74436: PUSH
74437: LD_INT 1
74439: ARRAY
74440: GREATEREQUAL
74441: PUSH
74442: LD_VAR 0 9
74446: PPUSH
74447: LD_INT 2
74449: PPUSH
74450: CALL_OW 275
74454: PUSH
74455: LD_VAR 0 14
74459: PUSH
74460: LD_INT 2
74462: ARRAY
74463: GREATEREQUAL
74464: AND
74465: PUSH
74466: LD_VAR 0 9
74470: PPUSH
74471: LD_INT 3
74473: PPUSH
74474: CALL_OW 275
74478: PUSH
74479: LD_VAR 0 14
74483: PUSH
74484: LD_INT 3
74486: ARRAY
74487: GREATEREQUAL
74488: AND
74489: IFFALSE 74501
// result := weapon ;
74491: LD_ADDR_VAR 0 3
74495: PUSH
74496: LD_VAR 0 18
74500: ST_TO_ADDR
// end ; end ;
74501: LD_VAR 0 3
74505: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74506: LD_INT 0
74508: PPUSH
74509: PPUSH
// result := true ;
74510: LD_ADDR_VAR 0 3
74514: PUSH
74515: LD_INT 1
74517: ST_TO_ADDR
// if array1 = array2 then
74518: LD_VAR 0 1
74522: PUSH
74523: LD_VAR 0 2
74527: EQUAL
74528: IFFALSE 74588
// begin for i = 1 to array1 do
74530: LD_ADDR_VAR 0 4
74534: PUSH
74535: DOUBLE
74536: LD_INT 1
74538: DEC
74539: ST_TO_ADDR
74540: LD_VAR 0 1
74544: PUSH
74545: FOR_TO
74546: IFFALSE 74584
// if array1 [ i ] <> array2 [ i ] then
74548: LD_VAR 0 1
74552: PUSH
74553: LD_VAR 0 4
74557: ARRAY
74558: PUSH
74559: LD_VAR 0 2
74563: PUSH
74564: LD_VAR 0 4
74568: ARRAY
74569: NONEQUAL
74570: IFFALSE 74582
// begin result := false ;
74572: LD_ADDR_VAR 0 3
74576: PUSH
74577: LD_INT 0
74579: ST_TO_ADDR
// break ;
74580: GO 74584
// end ;
74582: GO 74545
74584: POP
74585: POP
// end else
74586: GO 74596
// result := false ;
74588: LD_ADDR_VAR 0 3
74592: PUSH
74593: LD_INT 0
74595: ST_TO_ADDR
// end ;
74596: LD_VAR 0 3
74600: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
74601: LD_INT 0
74603: PPUSH
74604: PPUSH
// if not array1 or not array2 then
74605: LD_VAR 0 1
74609: NOT
74610: PUSH
74611: LD_VAR 0 2
74615: NOT
74616: OR
74617: IFFALSE 74621
// exit ;
74619: GO 74685
// result := true ;
74621: LD_ADDR_VAR 0 3
74625: PUSH
74626: LD_INT 1
74628: ST_TO_ADDR
// for i = 1 to array1 do
74629: LD_ADDR_VAR 0 4
74633: PUSH
74634: DOUBLE
74635: LD_INT 1
74637: DEC
74638: ST_TO_ADDR
74639: LD_VAR 0 1
74643: PUSH
74644: FOR_TO
74645: IFFALSE 74683
// if array1 [ i ] <> array2 [ i ] then
74647: LD_VAR 0 1
74651: PUSH
74652: LD_VAR 0 4
74656: ARRAY
74657: PUSH
74658: LD_VAR 0 2
74662: PUSH
74663: LD_VAR 0 4
74667: ARRAY
74668: NONEQUAL
74669: IFFALSE 74681
// begin result := false ;
74671: LD_ADDR_VAR 0 3
74675: PUSH
74676: LD_INT 0
74678: ST_TO_ADDR
// break ;
74679: GO 74683
// end ;
74681: GO 74644
74683: POP
74684: POP
// end ;
74685: LD_VAR 0 3
74689: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74690: LD_INT 0
74692: PPUSH
74693: PPUSH
74694: PPUSH
// pom := GetBase ( fac ) ;
74695: LD_ADDR_VAR 0 5
74699: PUSH
74700: LD_VAR 0 1
74704: PPUSH
74705: CALL_OW 274
74709: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74710: LD_ADDR_VAR 0 4
74714: PUSH
74715: LD_VAR 0 2
74719: PUSH
74720: LD_INT 1
74722: ARRAY
74723: PPUSH
74724: LD_VAR 0 2
74728: PUSH
74729: LD_INT 2
74731: ARRAY
74732: PPUSH
74733: LD_VAR 0 2
74737: PUSH
74738: LD_INT 3
74740: ARRAY
74741: PPUSH
74742: LD_VAR 0 2
74746: PUSH
74747: LD_INT 4
74749: ARRAY
74750: PPUSH
74751: CALL_OW 449
74755: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74756: LD_ADDR_VAR 0 3
74760: PUSH
74761: LD_VAR 0 5
74765: PPUSH
74766: LD_INT 1
74768: PPUSH
74769: CALL_OW 275
74773: PUSH
74774: LD_VAR 0 4
74778: PUSH
74779: LD_INT 1
74781: ARRAY
74782: GREATEREQUAL
74783: PUSH
74784: LD_VAR 0 5
74788: PPUSH
74789: LD_INT 2
74791: PPUSH
74792: CALL_OW 275
74796: PUSH
74797: LD_VAR 0 4
74801: PUSH
74802: LD_INT 2
74804: ARRAY
74805: GREATEREQUAL
74806: AND
74807: PUSH
74808: LD_VAR 0 5
74812: PPUSH
74813: LD_INT 3
74815: PPUSH
74816: CALL_OW 275
74820: PUSH
74821: LD_VAR 0 4
74825: PUSH
74826: LD_INT 3
74828: ARRAY
74829: GREATEREQUAL
74830: AND
74831: ST_TO_ADDR
// end ;
74832: LD_VAR 0 3
74836: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
74837: LD_INT 0
74839: PPUSH
74840: PPUSH
74841: PPUSH
74842: PPUSH
// pom := GetBase ( building ) ;
74843: LD_ADDR_VAR 0 3
74847: PUSH
74848: LD_VAR 0 1
74852: PPUSH
74853: CALL_OW 274
74857: ST_TO_ADDR
// if not pom then
74858: LD_VAR 0 3
74862: NOT
74863: IFFALSE 74867
// exit ;
74865: GO 75037
// btype := GetBType ( building ) ;
74867: LD_ADDR_VAR 0 5
74871: PUSH
74872: LD_VAR 0 1
74876: PPUSH
74877: CALL_OW 266
74881: ST_TO_ADDR
// if btype = b_armoury then
74882: LD_VAR 0 5
74886: PUSH
74887: LD_INT 4
74889: EQUAL
74890: IFFALSE 74900
// btype := b_barracks ;
74892: LD_ADDR_VAR 0 5
74896: PUSH
74897: LD_INT 5
74899: ST_TO_ADDR
// if btype = b_depot then
74900: LD_VAR 0 5
74904: PUSH
74905: LD_INT 0
74907: EQUAL
74908: IFFALSE 74918
// btype := b_warehouse ;
74910: LD_ADDR_VAR 0 5
74914: PUSH
74915: LD_INT 1
74917: ST_TO_ADDR
// if btype = b_workshop then
74918: LD_VAR 0 5
74922: PUSH
74923: LD_INT 2
74925: EQUAL
74926: IFFALSE 74936
// btype := b_factory ;
74928: LD_ADDR_VAR 0 5
74932: PUSH
74933: LD_INT 3
74935: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74936: LD_ADDR_VAR 0 4
74940: PUSH
74941: LD_VAR 0 5
74945: PPUSH
74946: LD_VAR 0 1
74950: PPUSH
74951: CALL_OW 248
74955: PPUSH
74956: CALL_OW 450
74960: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74961: LD_ADDR_VAR 0 2
74965: PUSH
74966: LD_VAR 0 3
74970: PPUSH
74971: LD_INT 1
74973: PPUSH
74974: CALL_OW 275
74978: PUSH
74979: LD_VAR 0 4
74983: PUSH
74984: LD_INT 1
74986: ARRAY
74987: GREATEREQUAL
74988: PUSH
74989: LD_VAR 0 3
74993: PPUSH
74994: LD_INT 2
74996: PPUSH
74997: CALL_OW 275
75001: PUSH
75002: LD_VAR 0 4
75006: PUSH
75007: LD_INT 2
75009: ARRAY
75010: GREATEREQUAL
75011: AND
75012: PUSH
75013: LD_VAR 0 3
75017: PPUSH
75018: LD_INT 3
75020: PPUSH
75021: CALL_OW 275
75025: PUSH
75026: LD_VAR 0 4
75030: PUSH
75031: LD_INT 3
75033: ARRAY
75034: GREATEREQUAL
75035: AND
75036: ST_TO_ADDR
// end ;
75037: LD_VAR 0 2
75041: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75042: LD_INT 0
75044: PPUSH
75045: PPUSH
75046: PPUSH
// pom := GetBase ( building ) ;
75047: LD_ADDR_VAR 0 4
75051: PUSH
75052: LD_VAR 0 1
75056: PPUSH
75057: CALL_OW 274
75061: ST_TO_ADDR
// if not pom then
75062: LD_VAR 0 4
75066: NOT
75067: IFFALSE 75071
// exit ;
75069: GO 75172
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75071: LD_ADDR_VAR 0 5
75075: PUSH
75076: LD_VAR 0 2
75080: PPUSH
75081: LD_VAR 0 1
75085: PPUSH
75086: CALL_OW 248
75090: PPUSH
75091: CALL_OW 450
75095: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75096: LD_ADDR_VAR 0 3
75100: PUSH
75101: LD_VAR 0 4
75105: PPUSH
75106: LD_INT 1
75108: PPUSH
75109: CALL_OW 275
75113: PUSH
75114: LD_VAR 0 5
75118: PUSH
75119: LD_INT 1
75121: ARRAY
75122: GREATEREQUAL
75123: PUSH
75124: LD_VAR 0 4
75128: PPUSH
75129: LD_INT 2
75131: PPUSH
75132: CALL_OW 275
75136: PUSH
75137: LD_VAR 0 5
75141: PUSH
75142: LD_INT 2
75144: ARRAY
75145: GREATEREQUAL
75146: AND
75147: PUSH
75148: LD_VAR 0 4
75152: PPUSH
75153: LD_INT 3
75155: PPUSH
75156: CALL_OW 275
75160: PUSH
75161: LD_VAR 0 5
75165: PUSH
75166: LD_INT 3
75168: ARRAY
75169: GREATEREQUAL
75170: AND
75171: ST_TO_ADDR
// end ;
75172: LD_VAR 0 3
75176: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
75177: LD_INT 0
75179: PPUSH
75180: PPUSH
75181: PPUSH
75182: PPUSH
75183: PPUSH
75184: PPUSH
75185: PPUSH
75186: PPUSH
75187: PPUSH
75188: PPUSH
75189: PPUSH
// result := false ;
75190: LD_ADDR_VAR 0 8
75194: PUSH
75195: LD_INT 0
75197: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
75198: LD_VAR 0 5
75202: NOT
75203: PUSH
75204: LD_VAR 0 1
75208: NOT
75209: OR
75210: PUSH
75211: LD_VAR 0 2
75215: NOT
75216: OR
75217: PUSH
75218: LD_VAR 0 3
75222: NOT
75223: OR
75224: IFFALSE 75228
// exit ;
75226: GO 76042
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
75228: LD_ADDR_VAR 0 14
75232: PUSH
75233: LD_VAR 0 1
75237: PPUSH
75238: LD_VAR 0 2
75242: PPUSH
75243: LD_VAR 0 3
75247: PPUSH
75248: LD_VAR 0 4
75252: PPUSH
75253: LD_VAR 0 5
75257: PUSH
75258: LD_INT 1
75260: ARRAY
75261: PPUSH
75262: CALL_OW 248
75266: PPUSH
75267: LD_INT 0
75269: PPUSH
75270: CALL 77295 0 6
75274: ST_TO_ADDR
// if not hexes then
75275: LD_VAR 0 14
75279: NOT
75280: IFFALSE 75284
// exit ;
75282: GO 76042
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75284: LD_ADDR_VAR 0 17
75288: PUSH
75289: LD_VAR 0 5
75293: PPUSH
75294: LD_INT 22
75296: PUSH
75297: LD_VAR 0 13
75301: PPUSH
75302: CALL_OW 255
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 2
75313: PUSH
75314: LD_INT 30
75316: PUSH
75317: LD_INT 0
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 30
75326: PUSH
75327: LD_INT 1
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: LIST
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: PPUSH
75343: CALL_OW 72
75347: ST_TO_ADDR
// for i = 1 to hexes do
75348: LD_ADDR_VAR 0 9
75352: PUSH
75353: DOUBLE
75354: LD_INT 1
75356: DEC
75357: ST_TO_ADDR
75358: LD_VAR 0 14
75362: PUSH
75363: FOR_TO
75364: IFFALSE 76040
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75366: LD_ADDR_VAR 0 13
75370: PUSH
75371: LD_VAR 0 14
75375: PUSH
75376: LD_VAR 0 9
75380: ARRAY
75381: PUSH
75382: LD_INT 1
75384: ARRAY
75385: PPUSH
75386: LD_VAR 0 14
75390: PUSH
75391: LD_VAR 0 9
75395: ARRAY
75396: PUSH
75397: LD_INT 2
75399: ARRAY
75400: PPUSH
75401: CALL_OW 428
75405: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75406: LD_VAR 0 14
75410: PUSH
75411: LD_VAR 0 9
75415: ARRAY
75416: PUSH
75417: LD_INT 1
75419: ARRAY
75420: PPUSH
75421: LD_VAR 0 14
75425: PUSH
75426: LD_VAR 0 9
75430: ARRAY
75431: PUSH
75432: LD_INT 2
75434: ARRAY
75435: PPUSH
75436: CALL_OW 351
75440: PUSH
75441: LD_VAR 0 14
75445: PUSH
75446: LD_VAR 0 9
75450: ARRAY
75451: PUSH
75452: LD_INT 1
75454: ARRAY
75455: PPUSH
75456: LD_VAR 0 14
75460: PUSH
75461: LD_VAR 0 9
75465: ARRAY
75466: PUSH
75467: LD_INT 2
75469: ARRAY
75470: PPUSH
75471: CALL_OW 488
75475: NOT
75476: OR
75477: PUSH
75478: LD_VAR 0 13
75482: PPUSH
75483: CALL_OW 247
75487: PUSH
75488: LD_INT 3
75490: EQUAL
75491: OR
75492: IFFALSE 75498
// exit ;
75494: POP
75495: POP
75496: GO 76042
// if not tmp then
75498: LD_VAR 0 13
75502: NOT
75503: IFFALSE 75507
// continue ;
75505: GO 75363
// result := true ;
75507: LD_ADDR_VAR 0 8
75511: PUSH
75512: LD_INT 1
75514: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
75515: LD_VAR 0 6
75519: PUSH
75520: LD_VAR 0 13
75524: PPUSH
75525: CALL_OW 247
75529: PUSH
75530: LD_INT 2
75532: EQUAL
75533: AND
75534: PUSH
75535: LD_VAR 0 13
75539: PPUSH
75540: CALL_OW 263
75544: PUSH
75545: LD_INT 1
75547: EQUAL
75548: AND
75549: IFFALSE 75713
// begin if IsDrivenBy ( tmp ) then
75551: LD_VAR 0 13
75555: PPUSH
75556: CALL_OW 311
75560: IFFALSE 75564
// continue ;
75562: GO 75363
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
75564: LD_VAR 0 6
75568: PPUSH
75569: LD_INT 3
75571: PUSH
75572: LD_INT 60
75574: PUSH
75575: EMPTY
75576: LIST
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 3
75584: PUSH
75585: LD_INT 55
75587: PUSH
75588: EMPTY
75589: LIST
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: EMPTY
75596: LIST
75597: LIST
75598: PPUSH
75599: CALL_OW 72
75603: IFFALSE 75711
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
75605: LD_ADDR_VAR 0 18
75609: PUSH
75610: LD_VAR 0 6
75614: PPUSH
75615: LD_INT 3
75617: PUSH
75618: LD_INT 60
75620: PUSH
75621: EMPTY
75622: LIST
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 3
75630: PUSH
75631: LD_INT 55
75633: PUSH
75634: EMPTY
75635: LIST
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: EMPTY
75642: LIST
75643: LIST
75644: PPUSH
75645: CALL_OW 72
75649: PUSH
75650: LD_INT 1
75652: ARRAY
75653: ST_TO_ADDR
// if IsInUnit ( driver ) then
75654: LD_VAR 0 18
75658: PPUSH
75659: CALL_OW 310
75663: IFFALSE 75674
// ComExit ( driver ) ;
75665: LD_VAR 0 18
75669: PPUSH
75670: CALL 101074 0 1
// AddComEnterUnit ( driver , tmp ) ;
75674: LD_VAR 0 18
75678: PPUSH
75679: LD_VAR 0 13
75683: PPUSH
75684: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
75688: LD_VAR 0 18
75692: PPUSH
75693: LD_VAR 0 7
75697: PPUSH
75698: CALL_OW 173
// AddComExitVehicle ( driver ) ;
75702: LD_VAR 0 18
75706: PPUSH
75707: CALL_OW 181
// end ; continue ;
75711: GO 75363
// end ; if not cleaners or not tmp in cleaners then
75713: LD_VAR 0 6
75717: NOT
75718: PUSH
75719: LD_VAR 0 13
75723: PUSH
75724: LD_VAR 0 6
75728: IN
75729: NOT
75730: OR
75731: IFFALSE 76038
// begin if dep then
75733: LD_VAR 0 17
75737: IFFALSE 75873
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75739: LD_ADDR_VAR 0 16
75743: PUSH
75744: LD_VAR 0 17
75748: PUSH
75749: LD_INT 1
75751: ARRAY
75752: PPUSH
75753: CALL_OW 250
75757: PPUSH
75758: LD_VAR 0 17
75762: PUSH
75763: LD_INT 1
75765: ARRAY
75766: PPUSH
75767: CALL_OW 254
75771: PPUSH
75772: LD_INT 5
75774: PPUSH
75775: CALL_OW 272
75779: PUSH
75780: LD_VAR 0 17
75784: PUSH
75785: LD_INT 1
75787: ARRAY
75788: PPUSH
75789: CALL_OW 251
75793: PPUSH
75794: LD_VAR 0 17
75798: PUSH
75799: LD_INT 1
75801: ARRAY
75802: PPUSH
75803: CALL_OW 254
75807: PPUSH
75808: LD_INT 5
75810: PPUSH
75811: CALL_OW 273
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
75820: LD_VAR 0 16
75824: PUSH
75825: LD_INT 1
75827: ARRAY
75828: PPUSH
75829: LD_VAR 0 16
75833: PUSH
75834: LD_INT 2
75836: ARRAY
75837: PPUSH
75838: CALL_OW 488
75842: IFFALSE 75873
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
75844: LD_VAR 0 13
75848: PPUSH
75849: LD_VAR 0 16
75853: PUSH
75854: LD_INT 1
75856: ARRAY
75857: PPUSH
75858: LD_VAR 0 16
75862: PUSH
75863: LD_INT 2
75865: ARRAY
75866: PPUSH
75867: CALL_OW 111
// continue ;
75871: GO 75363
// end ; end ; r := GetDir ( tmp ) ;
75873: LD_ADDR_VAR 0 15
75877: PUSH
75878: LD_VAR 0 13
75882: PPUSH
75883: CALL_OW 254
75887: ST_TO_ADDR
// if r = 5 then
75888: LD_VAR 0 15
75892: PUSH
75893: LD_INT 5
75895: EQUAL
75896: IFFALSE 75906
// r := 0 ;
75898: LD_ADDR_VAR 0 15
75902: PUSH
75903: LD_INT 0
75905: ST_TO_ADDR
// for j = r to 5 do
75906: LD_ADDR_VAR 0 10
75910: PUSH
75911: DOUBLE
75912: LD_VAR 0 15
75916: DEC
75917: ST_TO_ADDR
75918: LD_INT 5
75920: PUSH
75921: FOR_TO
75922: IFFALSE 76036
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
75924: LD_ADDR_VAR 0 11
75928: PUSH
75929: LD_VAR 0 13
75933: PPUSH
75934: CALL_OW 250
75938: PPUSH
75939: LD_VAR 0 10
75943: PPUSH
75944: LD_INT 2
75946: PPUSH
75947: CALL_OW 272
75951: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75952: LD_ADDR_VAR 0 12
75956: PUSH
75957: LD_VAR 0 13
75961: PPUSH
75962: CALL_OW 251
75966: PPUSH
75967: LD_VAR 0 10
75971: PPUSH
75972: LD_INT 2
75974: PPUSH
75975: CALL_OW 273
75979: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
75980: LD_VAR 0 11
75984: PPUSH
75985: LD_VAR 0 12
75989: PPUSH
75990: CALL_OW 488
75994: PUSH
75995: LD_VAR 0 11
75999: PPUSH
76000: LD_VAR 0 12
76004: PPUSH
76005: CALL_OW 428
76009: NOT
76010: AND
76011: IFFALSE 76034
// begin ComMoveXY ( tmp , _x , _y ) ;
76013: LD_VAR 0 13
76017: PPUSH
76018: LD_VAR 0 11
76022: PPUSH
76023: LD_VAR 0 12
76027: PPUSH
76028: CALL_OW 111
// break ;
76032: GO 76036
// end ; end ;
76034: GO 75921
76036: POP
76037: POP
// end ; end ;
76038: GO 75363
76040: POP
76041: POP
// end ;
76042: LD_VAR 0 8
76046: RET
// export function BuildingTechInvented ( side , btype ) ; begin
76047: LD_INT 0
76049: PPUSH
// result := true ;
76050: LD_ADDR_VAR 0 3
76054: PUSH
76055: LD_INT 1
76057: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
76058: LD_VAR 0 2
76062: PUSH
76063: LD_INT 24
76065: DOUBLE
76066: EQUAL
76067: IFTRUE 76077
76069: LD_INT 33
76071: DOUBLE
76072: EQUAL
76073: IFTRUE 76077
76075: GO 76102
76077: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
76078: LD_ADDR_VAR 0 3
76082: PUSH
76083: LD_INT 32
76085: PPUSH
76086: LD_VAR 0 1
76090: PPUSH
76091: CALL_OW 321
76095: PUSH
76096: LD_INT 2
76098: EQUAL
76099: ST_TO_ADDR
76100: GO 76418
76102: LD_INT 20
76104: DOUBLE
76105: EQUAL
76106: IFTRUE 76110
76108: GO 76135
76110: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
76111: LD_ADDR_VAR 0 3
76115: PUSH
76116: LD_INT 6
76118: PPUSH
76119: LD_VAR 0 1
76123: PPUSH
76124: CALL_OW 321
76128: PUSH
76129: LD_INT 2
76131: EQUAL
76132: ST_TO_ADDR
76133: GO 76418
76135: LD_INT 22
76137: DOUBLE
76138: EQUAL
76139: IFTRUE 76149
76141: LD_INT 36
76143: DOUBLE
76144: EQUAL
76145: IFTRUE 76149
76147: GO 76174
76149: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
76150: LD_ADDR_VAR 0 3
76154: PUSH
76155: LD_INT 15
76157: PPUSH
76158: LD_VAR 0 1
76162: PPUSH
76163: CALL_OW 321
76167: PUSH
76168: LD_INT 2
76170: EQUAL
76171: ST_TO_ADDR
76172: GO 76418
76174: LD_INT 30
76176: DOUBLE
76177: EQUAL
76178: IFTRUE 76182
76180: GO 76207
76182: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
76183: LD_ADDR_VAR 0 3
76187: PUSH
76188: LD_INT 20
76190: PPUSH
76191: LD_VAR 0 1
76195: PPUSH
76196: CALL_OW 321
76200: PUSH
76201: LD_INT 2
76203: EQUAL
76204: ST_TO_ADDR
76205: GO 76418
76207: LD_INT 28
76209: DOUBLE
76210: EQUAL
76211: IFTRUE 76221
76213: LD_INT 21
76215: DOUBLE
76216: EQUAL
76217: IFTRUE 76221
76219: GO 76246
76221: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
76222: LD_ADDR_VAR 0 3
76226: PUSH
76227: LD_INT 21
76229: PPUSH
76230: LD_VAR 0 1
76234: PPUSH
76235: CALL_OW 321
76239: PUSH
76240: LD_INT 2
76242: EQUAL
76243: ST_TO_ADDR
76244: GO 76418
76246: LD_INT 16
76248: DOUBLE
76249: EQUAL
76250: IFTRUE 76254
76252: GO 76279
76254: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
76255: LD_ADDR_VAR 0 3
76259: PUSH
76260: LD_INT 84
76262: PPUSH
76263: LD_VAR 0 1
76267: PPUSH
76268: CALL_OW 321
76272: PUSH
76273: LD_INT 2
76275: EQUAL
76276: ST_TO_ADDR
76277: GO 76418
76279: LD_INT 19
76281: DOUBLE
76282: EQUAL
76283: IFTRUE 76293
76285: LD_INT 23
76287: DOUBLE
76288: EQUAL
76289: IFTRUE 76293
76291: GO 76318
76293: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
76294: LD_ADDR_VAR 0 3
76298: PUSH
76299: LD_INT 83
76301: PPUSH
76302: LD_VAR 0 1
76306: PPUSH
76307: CALL_OW 321
76311: PUSH
76312: LD_INT 2
76314: EQUAL
76315: ST_TO_ADDR
76316: GO 76418
76318: LD_INT 17
76320: DOUBLE
76321: EQUAL
76322: IFTRUE 76326
76324: GO 76351
76326: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
76327: LD_ADDR_VAR 0 3
76331: PUSH
76332: LD_INT 39
76334: PPUSH
76335: LD_VAR 0 1
76339: PPUSH
76340: CALL_OW 321
76344: PUSH
76345: LD_INT 2
76347: EQUAL
76348: ST_TO_ADDR
76349: GO 76418
76351: LD_INT 18
76353: DOUBLE
76354: EQUAL
76355: IFTRUE 76359
76357: GO 76384
76359: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
76360: LD_ADDR_VAR 0 3
76364: PUSH
76365: LD_INT 40
76367: PPUSH
76368: LD_VAR 0 1
76372: PPUSH
76373: CALL_OW 321
76377: PUSH
76378: LD_INT 2
76380: EQUAL
76381: ST_TO_ADDR
76382: GO 76418
76384: LD_INT 27
76386: DOUBLE
76387: EQUAL
76388: IFTRUE 76392
76390: GO 76417
76392: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
76393: LD_ADDR_VAR 0 3
76397: PUSH
76398: LD_INT 35
76400: PPUSH
76401: LD_VAR 0 1
76405: PPUSH
76406: CALL_OW 321
76410: PUSH
76411: LD_INT 2
76413: EQUAL
76414: ST_TO_ADDR
76415: GO 76418
76417: POP
// end ;
76418: LD_VAR 0 3
76422: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
76423: LD_INT 0
76425: PPUSH
76426: PPUSH
76427: PPUSH
76428: PPUSH
76429: PPUSH
76430: PPUSH
76431: PPUSH
76432: PPUSH
76433: PPUSH
76434: PPUSH
76435: PPUSH
// result := false ;
76436: LD_ADDR_VAR 0 6
76440: PUSH
76441: LD_INT 0
76443: ST_TO_ADDR
// if btype = b_depot then
76444: LD_VAR 0 2
76448: PUSH
76449: LD_INT 0
76451: EQUAL
76452: IFFALSE 76464
// begin result := true ;
76454: LD_ADDR_VAR 0 6
76458: PUSH
76459: LD_INT 1
76461: ST_TO_ADDR
// exit ;
76462: GO 77290
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
76464: LD_VAR 0 1
76468: NOT
76469: PUSH
76470: LD_VAR 0 1
76474: PPUSH
76475: CALL_OW 266
76479: PUSH
76480: LD_INT 0
76482: PUSH
76483: LD_INT 1
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: IN
76490: NOT
76491: OR
76492: PUSH
76493: LD_VAR 0 2
76497: NOT
76498: OR
76499: PUSH
76500: LD_VAR 0 5
76504: PUSH
76505: LD_INT 0
76507: PUSH
76508: LD_INT 1
76510: PUSH
76511: LD_INT 2
76513: PUSH
76514: LD_INT 3
76516: PUSH
76517: LD_INT 4
76519: PUSH
76520: LD_INT 5
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: IN
76531: NOT
76532: OR
76533: PUSH
76534: LD_VAR 0 3
76538: PPUSH
76539: LD_VAR 0 4
76543: PPUSH
76544: CALL_OW 488
76548: NOT
76549: OR
76550: IFFALSE 76554
// exit ;
76552: GO 77290
// side := GetSide ( depot ) ;
76554: LD_ADDR_VAR 0 9
76558: PUSH
76559: LD_VAR 0 1
76563: PPUSH
76564: CALL_OW 255
76568: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
76569: LD_VAR 0 9
76573: PPUSH
76574: LD_VAR 0 2
76578: PPUSH
76579: CALL 76047 0 2
76583: NOT
76584: IFFALSE 76588
// exit ;
76586: GO 77290
// pom := GetBase ( depot ) ;
76588: LD_ADDR_VAR 0 10
76592: PUSH
76593: LD_VAR 0 1
76597: PPUSH
76598: CALL_OW 274
76602: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
76603: LD_ADDR_VAR 0 11
76607: PUSH
76608: LD_VAR 0 2
76612: PPUSH
76613: LD_VAR 0 1
76617: PPUSH
76618: CALL_OW 248
76622: PPUSH
76623: CALL_OW 450
76627: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
76628: LD_VAR 0 10
76632: PPUSH
76633: LD_INT 1
76635: PPUSH
76636: CALL_OW 275
76640: PUSH
76641: LD_VAR 0 11
76645: PUSH
76646: LD_INT 1
76648: ARRAY
76649: GREATEREQUAL
76650: PUSH
76651: LD_VAR 0 10
76655: PPUSH
76656: LD_INT 2
76658: PPUSH
76659: CALL_OW 275
76663: PUSH
76664: LD_VAR 0 11
76668: PUSH
76669: LD_INT 2
76671: ARRAY
76672: GREATEREQUAL
76673: AND
76674: PUSH
76675: LD_VAR 0 10
76679: PPUSH
76680: LD_INT 3
76682: PPUSH
76683: CALL_OW 275
76687: PUSH
76688: LD_VAR 0 11
76692: PUSH
76693: LD_INT 3
76695: ARRAY
76696: GREATEREQUAL
76697: AND
76698: NOT
76699: IFFALSE 76703
// exit ;
76701: GO 77290
// if GetBType ( depot ) = b_depot then
76703: LD_VAR 0 1
76707: PPUSH
76708: CALL_OW 266
76712: PUSH
76713: LD_INT 0
76715: EQUAL
76716: IFFALSE 76728
// dist := 28 else
76718: LD_ADDR_VAR 0 14
76722: PUSH
76723: LD_INT 28
76725: ST_TO_ADDR
76726: GO 76736
// dist := 36 ;
76728: LD_ADDR_VAR 0 14
76732: PUSH
76733: LD_INT 36
76735: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
76736: LD_VAR 0 1
76740: PPUSH
76741: LD_VAR 0 3
76745: PPUSH
76746: LD_VAR 0 4
76750: PPUSH
76751: CALL_OW 297
76755: PUSH
76756: LD_VAR 0 14
76760: GREATER
76761: IFFALSE 76765
// exit ;
76763: GO 77290
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
76765: LD_ADDR_VAR 0 12
76769: PUSH
76770: LD_VAR 0 2
76774: PPUSH
76775: LD_VAR 0 3
76779: PPUSH
76780: LD_VAR 0 4
76784: PPUSH
76785: LD_VAR 0 5
76789: PPUSH
76790: LD_VAR 0 1
76794: PPUSH
76795: CALL_OW 248
76799: PPUSH
76800: LD_INT 0
76802: PPUSH
76803: CALL 77295 0 6
76807: ST_TO_ADDR
// if not hexes then
76808: LD_VAR 0 12
76812: NOT
76813: IFFALSE 76817
// exit ;
76815: GO 77290
// hex := GetHexInfo ( x , y ) ;
76817: LD_ADDR_VAR 0 15
76821: PUSH
76822: LD_VAR 0 3
76826: PPUSH
76827: LD_VAR 0 4
76831: PPUSH
76832: CALL_OW 546
76836: ST_TO_ADDR
// if hex [ 1 ] then
76837: LD_VAR 0 15
76841: PUSH
76842: LD_INT 1
76844: ARRAY
76845: IFFALSE 76849
// exit ;
76847: GO 77290
// height := hex [ 2 ] ;
76849: LD_ADDR_VAR 0 13
76853: PUSH
76854: LD_VAR 0 15
76858: PUSH
76859: LD_INT 2
76861: ARRAY
76862: ST_TO_ADDR
// for i = 1 to hexes do
76863: LD_ADDR_VAR 0 7
76867: PUSH
76868: DOUBLE
76869: LD_INT 1
76871: DEC
76872: ST_TO_ADDR
76873: LD_VAR 0 12
76877: PUSH
76878: FOR_TO
76879: IFFALSE 77209
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
76881: LD_VAR 0 12
76885: PUSH
76886: LD_VAR 0 7
76890: ARRAY
76891: PUSH
76892: LD_INT 1
76894: ARRAY
76895: PPUSH
76896: LD_VAR 0 12
76900: PUSH
76901: LD_VAR 0 7
76905: ARRAY
76906: PUSH
76907: LD_INT 2
76909: ARRAY
76910: PPUSH
76911: CALL_OW 488
76915: NOT
76916: PUSH
76917: LD_VAR 0 12
76921: PUSH
76922: LD_VAR 0 7
76926: ARRAY
76927: PUSH
76928: LD_INT 1
76930: ARRAY
76931: PPUSH
76932: LD_VAR 0 12
76936: PUSH
76937: LD_VAR 0 7
76941: ARRAY
76942: PUSH
76943: LD_INT 2
76945: ARRAY
76946: PPUSH
76947: CALL_OW 428
76951: PUSH
76952: LD_INT 0
76954: GREATER
76955: OR
76956: PUSH
76957: LD_VAR 0 12
76961: PUSH
76962: LD_VAR 0 7
76966: ARRAY
76967: PUSH
76968: LD_INT 1
76970: ARRAY
76971: PPUSH
76972: LD_VAR 0 12
76976: PUSH
76977: LD_VAR 0 7
76981: ARRAY
76982: PUSH
76983: LD_INT 2
76985: ARRAY
76986: PPUSH
76987: CALL_OW 351
76991: OR
76992: IFFALSE 76998
// exit ;
76994: POP
76995: POP
76996: GO 77290
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76998: LD_ADDR_VAR 0 8
77002: PUSH
77003: LD_VAR 0 12
77007: PUSH
77008: LD_VAR 0 7
77012: ARRAY
77013: PUSH
77014: LD_INT 1
77016: ARRAY
77017: PPUSH
77018: LD_VAR 0 12
77022: PUSH
77023: LD_VAR 0 7
77027: ARRAY
77028: PUSH
77029: LD_INT 2
77031: ARRAY
77032: PPUSH
77033: CALL_OW 546
77037: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77038: LD_VAR 0 8
77042: PUSH
77043: LD_INT 1
77045: ARRAY
77046: PUSH
77047: LD_VAR 0 8
77051: PUSH
77052: LD_INT 2
77054: ARRAY
77055: PUSH
77056: LD_VAR 0 13
77060: PUSH
77061: LD_INT 2
77063: PLUS
77064: GREATER
77065: OR
77066: PUSH
77067: LD_VAR 0 8
77071: PUSH
77072: LD_INT 2
77074: ARRAY
77075: PUSH
77076: LD_VAR 0 13
77080: PUSH
77081: LD_INT 2
77083: MINUS
77084: LESS
77085: OR
77086: PUSH
77087: LD_VAR 0 8
77091: PUSH
77092: LD_INT 3
77094: ARRAY
77095: PUSH
77096: LD_INT 0
77098: PUSH
77099: LD_INT 8
77101: PUSH
77102: LD_INT 9
77104: PUSH
77105: LD_INT 10
77107: PUSH
77108: LD_INT 11
77110: PUSH
77111: LD_INT 12
77113: PUSH
77114: LD_INT 13
77116: PUSH
77117: LD_INT 16
77119: PUSH
77120: LD_INT 17
77122: PUSH
77123: LD_INT 18
77125: PUSH
77126: LD_INT 19
77128: PUSH
77129: LD_INT 20
77131: PUSH
77132: LD_INT 21
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: LIST
77143: LIST
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: IN
77150: NOT
77151: OR
77152: PUSH
77153: LD_VAR 0 8
77157: PUSH
77158: LD_INT 5
77160: ARRAY
77161: NOT
77162: OR
77163: PUSH
77164: LD_VAR 0 8
77168: PUSH
77169: LD_INT 6
77171: ARRAY
77172: PUSH
77173: LD_INT 1
77175: PUSH
77176: LD_INT 2
77178: PUSH
77179: LD_INT 7
77181: PUSH
77182: LD_INT 9
77184: PUSH
77185: LD_INT 10
77187: PUSH
77188: LD_INT 11
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: LIST
77195: LIST
77196: LIST
77197: LIST
77198: IN
77199: NOT
77200: OR
77201: IFFALSE 77207
// exit ;
77203: POP
77204: POP
77205: GO 77290
// end ;
77207: GO 76878
77209: POP
77210: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77211: LD_VAR 0 9
77215: PPUSH
77216: LD_VAR 0 3
77220: PPUSH
77221: LD_VAR 0 4
77225: PPUSH
77226: LD_INT 20
77228: PPUSH
77229: CALL 69213 0 4
77233: PUSH
77234: LD_INT 4
77236: ARRAY
77237: IFFALSE 77241
// exit ;
77239: GO 77290
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77241: LD_VAR 0 2
77245: PUSH
77246: LD_INT 29
77248: PUSH
77249: LD_INT 30
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: IN
77256: PUSH
77257: LD_VAR 0 3
77261: PPUSH
77262: LD_VAR 0 4
77266: PPUSH
77267: LD_VAR 0 9
77271: PPUSH
77272: CALL_OW 440
77276: NOT
77277: AND
77278: IFFALSE 77282
// exit ;
77280: GO 77290
// result := true ;
77282: LD_ADDR_VAR 0 6
77286: PUSH
77287: LD_INT 1
77289: ST_TO_ADDR
// end ;
77290: LD_VAR 0 6
77294: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
77295: LD_INT 0
77297: PPUSH
77298: PPUSH
77299: PPUSH
77300: PPUSH
77301: PPUSH
77302: PPUSH
77303: PPUSH
77304: PPUSH
77305: PPUSH
77306: PPUSH
77307: PPUSH
77308: PPUSH
77309: PPUSH
77310: PPUSH
77311: PPUSH
77312: PPUSH
77313: PPUSH
77314: PPUSH
77315: PPUSH
77316: PPUSH
77317: PPUSH
77318: PPUSH
77319: PPUSH
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
77324: PPUSH
77325: PPUSH
77326: PPUSH
77327: PPUSH
77328: PPUSH
77329: PPUSH
77330: PPUSH
77331: PPUSH
77332: PPUSH
77333: PPUSH
77334: PPUSH
77335: PPUSH
77336: PPUSH
77337: PPUSH
77338: PPUSH
77339: PPUSH
77340: PPUSH
77341: PPUSH
77342: PPUSH
77343: PPUSH
77344: PPUSH
77345: PPUSH
77346: PPUSH
77347: PPUSH
77348: PPUSH
77349: PPUSH
77350: PPUSH
77351: PPUSH
77352: PPUSH
77353: PPUSH
77354: PPUSH
// result = [ ] ;
77355: LD_ADDR_VAR 0 7
77359: PUSH
77360: EMPTY
77361: ST_TO_ADDR
// temp_list = [ ] ;
77362: LD_ADDR_VAR 0 9
77366: PUSH
77367: EMPTY
77368: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77369: LD_VAR 0 4
77373: PUSH
77374: LD_INT 0
77376: PUSH
77377: LD_INT 1
77379: PUSH
77380: LD_INT 2
77382: PUSH
77383: LD_INT 3
77385: PUSH
77386: LD_INT 4
77388: PUSH
77389: LD_INT 5
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: IN
77400: NOT
77401: PUSH
77402: LD_VAR 0 1
77406: PUSH
77407: LD_INT 0
77409: PUSH
77410: LD_INT 1
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: IN
77417: PUSH
77418: LD_VAR 0 5
77422: PUSH
77423: LD_INT 1
77425: PUSH
77426: LD_INT 2
77428: PUSH
77429: LD_INT 3
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: LIST
77436: IN
77437: NOT
77438: AND
77439: OR
77440: IFFALSE 77444
// exit ;
77442: GO 95835
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
77444: LD_VAR 0 1
77448: PUSH
77449: LD_INT 6
77451: PUSH
77452: LD_INT 7
77454: PUSH
77455: LD_INT 8
77457: PUSH
77458: LD_INT 13
77460: PUSH
77461: LD_INT 12
77463: PUSH
77464: LD_INT 15
77466: PUSH
77467: LD_INT 11
77469: PUSH
77470: LD_INT 14
77472: PUSH
77473: LD_INT 10
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: LIST
77480: LIST
77481: LIST
77482: LIST
77483: LIST
77484: LIST
77485: LIST
77486: IN
77487: IFFALSE 77497
// btype = b_lab ;
77489: LD_ADDR_VAR 0 1
77493: PUSH
77494: LD_INT 6
77496: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
77497: LD_VAR 0 6
77501: PUSH
77502: LD_INT 0
77504: PUSH
77505: LD_INT 1
77507: PUSH
77508: LD_INT 2
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: LIST
77515: IN
77516: NOT
77517: PUSH
77518: LD_VAR 0 1
77522: PUSH
77523: LD_INT 0
77525: PUSH
77526: LD_INT 1
77528: PUSH
77529: LD_INT 2
77531: PUSH
77532: LD_INT 3
77534: PUSH
77535: LD_INT 6
77537: PUSH
77538: LD_INT 36
77540: PUSH
77541: LD_INT 4
77543: PUSH
77544: LD_INT 5
77546: PUSH
77547: LD_INT 31
77549: PUSH
77550: LD_INT 32
77552: PUSH
77553: LD_INT 33
77555: PUSH
77556: EMPTY
77557: LIST
77558: LIST
77559: LIST
77560: LIST
77561: LIST
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: LIST
77567: LIST
77568: IN
77569: NOT
77570: PUSH
77571: LD_VAR 0 6
77575: PUSH
77576: LD_INT 1
77578: EQUAL
77579: AND
77580: OR
77581: PUSH
77582: LD_VAR 0 1
77586: PUSH
77587: LD_INT 2
77589: PUSH
77590: LD_INT 3
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: IN
77597: NOT
77598: PUSH
77599: LD_VAR 0 6
77603: PUSH
77604: LD_INT 2
77606: EQUAL
77607: AND
77608: OR
77609: IFFALSE 77619
// mode = 0 ;
77611: LD_ADDR_VAR 0 6
77615: PUSH
77616: LD_INT 0
77618: ST_TO_ADDR
// case mode of 0 :
77619: LD_VAR 0 6
77623: PUSH
77624: LD_INT 0
77626: DOUBLE
77627: EQUAL
77628: IFTRUE 77632
77630: GO 89085
77632: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77633: LD_ADDR_VAR 0 11
77637: PUSH
77638: LD_INT 0
77640: PUSH
77641: LD_INT 0
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 0
77650: PUSH
77651: LD_INT 1
77653: NEG
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: PUSH
77659: LD_INT 1
77661: PUSH
77662: LD_INT 0
77664: PUSH
77665: EMPTY
77666: LIST
77667: LIST
77668: PUSH
77669: LD_INT 1
77671: PUSH
77672: LD_INT 1
77674: PUSH
77675: EMPTY
77676: LIST
77677: LIST
77678: PUSH
77679: LD_INT 0
77681: PUSH
77682: LD_INT 1
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: PUSH
77689: LD_INT 1
77691: NEG
77692: PUSH
77693: LD_INT 0
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: PUSH
77700: LD_INT 1
77702: NEG
77703: PUSH
77704: LD_INT 1
77706: NEG
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 1
77714: NEG
77715: PUSH
77716: LD_INT 2
77718: NEG
77719: PUSH
77720: EMPTY
77721: LIST
77722: LIST
77723: PUSH
77724: LD_INT 0
77726: PUSH
77727: LD_INT 2
77729: NEG
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: PUSH
77735: LD_INT 1
77737: PUSH
77738: LD_INT 1
77740: NEG
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: LD_INT 1
77748: PUSH
77749: LD_INT 2
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 0
77758: PUSH
77759: LD_INT 2
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 1
77768: NEG
77769: PUSH
77770: LD_INT 1
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 1
77779: PUSH
77780: LD_INT 3
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: LD_INT 0
77789: PUSH
77790: LD_INT 3
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 1
77799: NEG
77800: PUSH
77801: LD_INT 2
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: LIST
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77826: LD_ADDR_VAR 0 12
77830: PUSH
77831: LD_INT 0
77833: PUSH
77834: LD_INT 0
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 0
77843: PUSH
77844: LD_INT 1
77846: NEG
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: PUSH
77852: LD_INT 1
77854: PUSH
77855: LD_INT 0
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 1
77864: PUSH
77865: LD_INT 1
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: PUSH
77872: LD_INT 0
77874: PUSH
77875: LD_INT 1
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 1
77884: NEG
77885: PUSH
77886: LD_INT 0
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 1
77895: NEG
77896: PUSH
77897: LD_INT 1
77899: NEG
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 1
77907: PUSH
77908: LD_INT 1
77910: NEG
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 2
77918: PUSH
77919: LD_INT 0
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: PUSH
77926: LD_INT 2
77928: PUSH
77929: LD_INT 1
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 1
77938: NEG
77939: PUSH
77940: LD_INT 1
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 2
77949: NEG
77950: PUSH
77951: LD_INT 0
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 2
77960: NEG
77961: PUSH
77962: LD_INT 1
77964: NEG
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 2
77972: NEG
77973: PUSH
77974: LD_INT 1
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 3
77983: NEG
77984: PUSH
77985: LD_INT 0
77987: PUSH
77988: EMPTY
77989: LIST
77990: LIST
77991: PUSH
77992: LD_INT 3
77994: NEG
77995: PUSH
77996: LD_INT 1
77998: NEG
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78022: LD_ADDR_VAR 0 13
78026: PUSH
78027: LD_INT 0
78029: PUSH
78030: LD_INT 0
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 0
78039: PUSH
78040: LD_INT 1
78042: NEG
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 1
78050: PUSH
78051: LD_INT 0
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: LD_INT 1
78060: PUSH
78061: LD_INT 1
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 0
78070: PUSH
78071: LD_INT 1
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 1
78080: NEG
78081: PUSH
78082: LD_INT 0
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 1
78091: NEG
78092: PUSH
78093: LD_INT 1
78095: NEG
78096: PUSH
78097: EMPTY
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 1
78103: NEG
78104: PUSH
78105: LD_INT 2
78107: NEG
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 2
78115: PUSH
78116: LD_INT 1
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 2
78125: PUSH
78126: LD_INT 2
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: LD_INT 1
78135: PUSH
78136: LD_INT 2
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 2
78145: NEG
78146: PUSH
78147: LD_INT 1
78149: NEG
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 2
78157: NEG
78158: PUSH
78159: LD_INT 2
78161: NEG
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 2
78169: NEG
78170: PUSH
78171: LD_INT 3
78173: NEG
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 3
78181: NEG
78182: PUSH
78183: LD_INT 2
78185: NEG
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PUSH
78191: LD_INT 3
78193: NEG
78194: PUSH
78195: LD_INT 3
78197: NEG
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: LIST
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78221: LD_ADDR_VAR 0 14
78225: PUSH
78226: LD_INT 0
78228: PUSH
78229: LD_INT 0
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 0
78238: PUSH
78239: LD_INT 1
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 1
78249: PUSH
78250: LD_INT 0
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 1
78259: PUSH
78260: LD_INT 1
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: LD_INT 0
78269: PUSH
78270: LD_INT 1
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PUSH
78277: LD_INT 1
78279: NEG
78280: PUSH
78281: LD_INT 0
78283: PUSH
78284: EMPTY
78285: LIST
78286: LIST
78287: PUSH
78288: LD_INT 1
78290: NEG
78291: PUSH
78292: LD_INT 1
78294: NEG
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: LD_INT 1
78302: NEG
78303: PUSH
78304: LD_INT 2
78306: NEG
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 0
78314: PUSH
78315: LD_INT 2
78317: NEG
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: LD_INT 1
78325: PUSH
78326: LD_INT 1
78328: NEG
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 1
78336: PUSH
78337: LD_INT 2
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: LD_INT 0
78346: PUSH
78347: LD_INT 2
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 1
78356: NEG
78357: PUSH
78358: LD_INT 1
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: PUSH
78365: LD_INT 1
78367: NEG
78368: PUSH
78369: LD_INT 3
78371: NEG
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: PUSH
78377: LD_INT 0
78379: PUSH
78380: LD_INT 3
78382: NEG
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 1
78390: PUSH
78391: LD_INT 2
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78417: LD_ADDR_VAR 0 15
78421: PUSH
78422: LD_INT 0
78424: PUSH
78425: LD_INT 0
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: PUSH
78432: LD_INT 0
78434: PUSH
78435: LD_INT 1
78437: NEG
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: PUSH
78443: LD_INT 1
78445: PUSH
78446: LD_INT 0
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 1
78455: PUSH
78456: LD_INT 1
78458: PUSH
78459: EMPTY
78460: LIST
78461: LIST
78462: PUSH
78463: LD_INT 0
78465: PUSH
78466: LD_INT 1
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: PUSH
78473: LD_INT 1
78475: NEG
78476: PUSH
78477: LD_INT 0
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 1
78486: NEG
78487: PUSH
78488: LD_INT 1
78490: NEG
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 1
78498: PUSH
78499: LD_INT 1
78501: NEG
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 2
78509: PUSH
78510: LD_INT 0
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 2
78519: PUSH
78520: LD_INT 1
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 1
78529: NEG
78530: PUSH
78531: LD_INT 1
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: PUSH
78538: LD_INT 2
78540: NEG
78541: PUSH
78542: LD_INT 0
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: LD_INT 2
78551: NEG
78552: PUSH
78553: LD_INT 1
78555: NEG
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: LD_INT 2
78563: PUSH
78564: LD_INT 1
78566: NEG
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 3
78574: PUSH
78575: LD_INT 0
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: PUSH
78582: LD_INT 3
78584: PUSH
78585: LD_INT 1
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78610: LD_ADDR_VAR 0 16
78614: PUSH
78615: LD_INT 0
78617: PUSH
78618: LD_INT 0
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 0
78627: PUSH
78628: LD_INT 1
78630: NEG
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 1
78638: PUSH
78639: LD_INT 0
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 1
78648: PUSH
78649: LD_INT 1
78651: PUSH
78652: EMPTY
78653: LIST
78654: LIST
78655: PUSH
78656: LD_INT 0
78658: PUSH
78659: LD_INT 1
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: PUSH
78666: LD_INT 1
78668: NEG
78669: PUSH
78670: LD_INT 0
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PUSH
78677: LD_INT 1
78679: NEG
78680: PUSH
78681: LD_INT 1
78683: NEG
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 1
78691: NEG
78692: PUSH
78693: LD_INT 2
78695: NEG
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: PUSH
78701: LD_INT 2
78703: PUSH
78704: LD_INT 1
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 2
78713: PUSH
78714: LD_INT 2
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 1
78723: PUSH
78724: LD_INT 2
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 2
78733: NEG
78734: PUSH
78735: LD_INT 1
78737: NEG
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 2
78745: NEG
78746: PUSH
78747: LD_INT 2
78749: NEG
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PUSH
78755: LD_INT 3
78757: PUSH
78758: LD_INT 2
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: PUSH
78765: LD_INT 3
78767: PUSH
78768: LD_INT 3
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 2
78777: PUSH
78778: LD_INT 3
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78803: LD_ADDR_VAR 0 17
78807: PUSH
78808: LD_INT 0
78810: PUSH
78811: LD_INT 0
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 0
78820: PUSH
78821: LD_INT 1
78823: NEG
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 1
78831: PUSH
78832: LD_INT 0
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 1
78841: PUSH
78842: LD_INT 1
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 0
78851: PUSH
78852: LD_INT 1
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 1
78861: NEG
78862: PUSH
78863: LD_INT 0
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 1
78872: NEG
78873: PUSH
78874: LD_INT 1
78876: NEG
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: LD_INT 1
78884: NEG
78885: PUSH
78886: LD_INT 2
78888: NEG
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PUSH
78894: LD_INT 0
78896: PUSH
78897: LD_INT 2
78899: NEG
78900: PUSH
78901: EMPTY
78902: LIST
78903: LIST
78904: PUSH
78905: LD_INT 1
78907: PUSH
78908: LD_INT 1
78910: NEG
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: LD_INT 2
78918: PUSH
78919: LD_INT 0
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 2
78928: PUSH
78929: LD_INT 1
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 2
78938: PUSH
78939: LD_INT 2
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 1
78948: PUSH
78949: LD_INT 2
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: LD_INT 0
78958: PUSH
78959: LD_INT 2
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 1
78968: NEG
78969: PUSH
78970: LD_INT 1
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: PUSH
78977: LD_INT 2
78979: NEG
78980: PUSH
78981: LD_INT 0
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: PUSH
78988: LD_INT 2
78990: NEG
78991: PUSH
78992: LD_INT 1
78994: NEG
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 2
79002: NEG
79003: PUSH
79004: LD_INT 2
79006: NEG
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79033: LD_ADDR_VAR 0 18
79037: PUSH
79038: LD_INT 0
79040: PUSH
79041: LD_INT 0
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 0
79050: PUSH
79051: LD_INT 1
79053: NEG
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 1
79061: PUSH
79062: LD_INT 0
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 1
79071: PUSH
79072: LD_INT 1
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 0
79081: PUSH
79082: LD_INT 1
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 1
79091: NEG
79092: PUSH
79093: LD_INT 0
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 1
79102: NEG
79103: PUSH
79104: LD_INT 1
79106: NEG
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 1
79114: NEG
79115: PUSH
79116: LD_INT 2
79118: NEG
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 0
79126: PUSH
79127: LD_INT 2
79129: NEG
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 1
79137: PUSH
79138: LD_INT 1
79140: NEG
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 2
79148: PUSH
79149: LD_INT 0
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PUSH
79156: LD_INT 2
79158: PUSH
79159: LD_INT 1
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: LD_INT 2
79168: PUSH
79169: LD_INT 2
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 1
79178: PUSH
79179: LD_INT 2
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 0
79188: PUSH
79189: LD_INT 2
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: LD_INT 1
79198: NEG
79199: PUSH
79200: LD_INT 1
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 2
79209: NEG
79210: PUSH
79211: LD_INT 0
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 2
79220: NEG
79221: PUSH
79222: LD_INT 1
79224: NEG
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 2
79232: NEG
79233: PUSH
79234: LD_INT 2
79236: NEG
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: LIST
79246: LIST
79247: LIST
79248: LIST
79249: LIST
79250: LIST
79251: LIST
79252: LIST
79253: LIST
79254: LIST
79255: LIST
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79263: LD_ADDR_VAR 0 19
79267: PUSH
79268: LD_INT 0
79270: PUSH
79271: LD_INT 0
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 0
79280: PUSH
79281: LD_INT 1
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 1
79291: PUSH
79292: LD_INT 0
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 1
79301: PUSH
79302: LD_INT 1
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 0
79311: PUSH
79312: LD_INT 1
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 1
79321: NEG
79322: PUSH
79323: LD_INT 0
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 1
79332: NEG
79333: PUSH
79334: LD_INT 1
79336: NEG
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: PUSH
79342: LD_INT 1
79344: NEG
79345: PUSH
79346: LD_INT 2
79348: NEG
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 0
79356: PUSH
79357: LD_INT 2
79359: NEG
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 1
79367: PUSH
79368: LD_INT 1
79370: NEG
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: PUSH
79376: LD_INT 2
79378: PUSH
79379: LD_INT 0
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 2
79388: PUSH
79389: LD_INT 1
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 2
79398: PUSH
79399: LD_INT 2
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 1
79408: PUSH
79409: LD_INT 2
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 0
79418: PUSH
79419: LD_INT 2
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 1
79428: NEG
79429: PUSH
79430: LD_INT 1
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 2
79439: NEG
79440: PUSH
79441: LD_INT 0
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 2
79450: NEG
79451: PUSH
79452: LD_INT 1
79454: NEG
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 2
79462: NEG
79463: PUSH
79464: LD_INT 2
79466: NEG
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: LIST
79487: LIST
79488: LIST
79489: LIST
79490: LIST
79491: LIST
79492: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79493: LD_ADDR_VAR 0 20
79497: PUSH
79498: LD_INT 0
79500: PUSH
79501: LD_INT 0
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 0
79510: PUSH
79511: LD_INT 1
79513: NEG
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 1
79521: PUSH
79522: LD_INT 0
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 1
79531: PUSH
79532: LD_INT 1
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 0
79541: PUSH
79542: LD_INT 1
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 1
79551: NEG
79552: PUSH
79553: LD_INT 0
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: NEG
79563: PUSH
79564: LD_INT 1
79566: NEG
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 1
79574: NEG
79575: PUSH
79576: LD_INT 2
79578: NEG
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 0
79586: PUSH
79587: LD_INT 2
79589: NEG
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 1
79597: PUSH
79598: LD_INT 1
79600: NEG
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 2
79608: PUSH
79609: LD_INT 0
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 2
79618: PUSH
79619: LD_INT 1
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 2
79628: PUSH
79629: LD_INT 2
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 1
79638: PUSH
79639: LD_INT 2
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 0
79648: PUSH
79649: LD_INT 2
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: LD_INT 1
79658: NEG
79659: PUSH
79660: LD_INT 1
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 2
79669: NEG
79670: PUSH
79671: LD_INT 0
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 2
79680: NEG
79681: PUSH
79682: LD_INT 1
79684: NEG
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 2
79692: NEG
79693: PUSH
79694: LD_INT 2
79696: NEG
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: LIST
79721: LIST
79722: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79723: LD_ADDR_VAR 0 21
79727: PUSH
79728: LD_INT 0
79730: PUSH
79731: LD_INT 0
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 0
79740: PUSH
79741: LD_INT 1
79743: NEG
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 1
79751: PUSH
79752: LD_INT 0
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 1
79761: PUSH
79762: LD_INT 1
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 0
79771: PUSH
79772: LD_INT 1
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 1
79781: NEG
79782: PUSH
79783: LD_INT 0
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 1
79792: NEG
79793: PUSH
79794: LD_INT 1
79796: NEG
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 1
79804: NEG
79805: PUSH
79806: LD_INT 2
79808: NEG
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 0
79816: PUSH
79817: LD_INT 2
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 1
79827: PUSH
79828: LD_INT 1
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 2
79838: PUSH
79839: LD_INT 0
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 2
79848: PUSH
79849: LD_INT 1
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 2
79858: PUSH
79859: LD_INT 2
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 1
79868: PUSH
79869: LD_INT 2
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 0
79878: PUSH
79879: LD_INT 2
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 1
79888: NEG
79889: PUSH
79890: LD_INT 1
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 2
79899: NEG
79900: PUSH
79901: LD_INT 0
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 2
79910: NEG
79911: PUSH
79912: LD_INT 1
79914: NEG
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 2
79922: NEG
79923: PUSH
79924: LD_INT 2
79926: NEG
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: LIST
79952: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79953: LD_ADDR_VAR 0 22
79957: PUSH
79958: LD_INT 0
79960: PUSH
79961: LD_INT 0
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 0
79970: PUSH
79971: LD_INT 1
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 1
79981: PUSH
79982: LD_INT 0
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 1
79991: PUSH
79992: LD_INT 1
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 0
80001: PUSH
80002: LD_INT 1
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: PUSH
80009: LD_INT 1
80011: NEG
80012: PUSH
80013: LD_INT 0
80015: PUSH
80016: EMPTY
80017: LIST
80018: LIST
80019: PUSH
80020: LD_INT 1
80022: NEG
80023: PUSH
80024: LD_INT 1
80026: NEG
80027: PUSH
80028: EMPTY
80029: LIST
80030: LIST
80031: PUSH
80032: LD_INT 1
80034: NEG
80035: PUSH
80036: LD_INT 2
80038: NEG
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 0
80046: PUSH
80047: LD_INT 2
80049: NEG
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 1
80057: PUSH
80058: LD_INT 1
80060: NEG
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 2
80068: PUSH
80069: LD_INT 0
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: PUSH
80076: LD_INT 2
80078: PUSH
80079: LD_INT 1
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 2
80088: PUSH
80089: LD_INT 2
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 1
80098: PUSH
80099: LD_INT 2
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 0
80108: PUSH
80109: LD_INT 2
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 1
80118: NEG
80119: PUSH
80120: LD_INT 1
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PUSH
80127: LD_INT 2
80129: NEG
80130: PUSH
80131: LD_INT 0
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 2
80140: NEG
80141: PUSH
80142: LD_INT 1
80144: NEG
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 2
80152: NEG
80153: PUSH
80154: LD_INT 2
80156: NEG
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80183: LD_ADDR_VAR 0 23
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 0
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 0
80200: PUSH
80201: LD_INT 1
80203: NEG
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 1
80211: PUSH
80212: LD_INT 0
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 1
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 0
80231: PUSH
80232: LD_INT 1
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 1
80241: NEG
80242: PUSH
80243: LD_INT 0
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 1
80252: NEG
80253: PUSH
80254: LD_INT 1
80256: NEG
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 1
80264: NEG
80265: PUSH
80266: LD_INT 2
80268: NEG
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 0
80276: PUSH
80277: LD_INT 2
80279: NEG
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 1
80287: PUSH
80288: LD_INT 1
80290: NEG
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 2
80298: PUSH
80299: LD_INT 0
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 2
80308: PUSH
80309: LD_INT 1
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 2
80318: PUSH
80319: LD_INT 2
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 1
80328: PUSH
80329: LD_INT 2
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 0
80338: PUSH
80339: LD_INT 2
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 1
80348: NEG
80349: PUSH
80350: LD_INT 1
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 2
80359: NEG
80360: PUSH
80361: LD_INT 0
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 2
80370: NEG
80371: PUSH
80372: LD_INT 1
80374: NEG
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 2
80382: NEG
80383: PUSH
80384: LD_INT 2
80386: NEG
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 2
80394: NEG
80395: PUSH
80396: LD_INT 3
80398: NEG
80399: PUSH
80400: EMPTY
80401: LIST
80402: LIST
80403: PUSH
80404: LD_INT 1
80406: NEG
80407: PUSH
80408: LD_INT 3
80410: NEG
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: LD_INT 1
80418: PUSH
80419: LD_INT 2
80421: NEG
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: LD_INT 2
80429: PUSH
80430: LD_INT 1
80432: NEG
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
80463: LD_ADDR_VAR 0 24
80467: PUSH
80468: LD_INT 0
80470: PUSH
80471: LD_INT 0
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 0
80480: PUSH
80481: LD_INT 1
80483: NEG
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 1
80491: PUSH
80492: LD_INT 0
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 1
80501: PUSH
80502: LD_INT 1
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 0
80511: PUSH
80512: LD_INT 1
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 1
80521: NEG
80522: PUSH
80523: LD_INT 0
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 1
80532: NEG
80533: PUSH
80534: LD_INT 1
80536: NEG
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 1
80544: NEG
80545: PUSH
80546: LD_INT 2
80548: NEG
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 0
80556: PUSH
80557: LD_INT 2
80559: NEG
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 1
80567: PUSH
80568: LD_INT 1
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 2
80578: PUSH
80579: LD_INT 0
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 2
80588: PUSH
80589: LD_INT 1
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 2
80598: PUSH
80599: LD_INT 2
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: LD_INT 1
80608: PUSH
80609: LD_INT 2
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 0
80618: PUSH
80619: LD_INT 2
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 1
80628: NEG
80629: PUSH
80630: LD_INT 1
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 2
80639: NEG
80640: PUSH
80641: LD_INT 0
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 2
80650: NEG
80651: PUSH
80652: LD_INT 1
80654: NEG
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 2
80662: NEG
80663: PUSH
80664: LD_INT 2
80666: NEG
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 1
80674: PUSH
80675: LD_INT 2
80677: NEG
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 2
80685: PUSH
80686: LD_INT 1
80688: NEG
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 3
80696: PUSH
80697: LD_INT 1
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 3
80706: PUSH
80707: LD_INT 2
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: EMPTY
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
80739: LD_ADDR_VAR 0 25
80743: PUSH
80744: LD_INT 0
80746: PUSH
80747: LD_INT 0
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 0
80756: PUSH
80757: LD_INT 1
80759: NEG
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: LD_INT 1
80767: PUSH
80768: LD_INT 0
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 1
80777: PUSH
80778: LD_INT 1
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 0
80787: PUSH
80788: LD_INT 1
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 1
80797: NEG
80798: PUSH
80799: LD_INT 0
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 1
80808: NEG
80809: PUSH
80810: LD_INT 1
80812: NEG
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 1
80820: NEG
80821: PUSH
80822: LD_INT 2
80824: NEG
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 0
80832: PUSH
80833: LD_INT 2
80835: NEG
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: PUSH
80841: LD_INT 1
80843: PUSH
80844: LD_INT 1
80846: NEG
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 2
80854: PUSH
80855: LD_INT 0
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 2
80864: PUSH
80865: LD_INT 1
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 2
80874: PUSH
80875: LD_INT 2
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 1
80884: PUSH
80885: LD_INT 2
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 0
80894: PUSH
80895: LD_INT 2
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: PUSH
80902: LD_INT 1
80904: NEG
80905: PUSH
80906: LD_INT 1
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 2
80915: NEG
80916: PUSH
80917: LD_INT 0
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 2
80926: NEG
80927: PUSH
80928: LD_INT 1
80930: NEG
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 2
80938: NEG
80939: PUSH
80940: LD_INT 2
80942: NEG
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 3
80950: PUSH
80951: LD_INT 1
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 3
80960: PUSH
80961: LD_INT 2
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 2
80970: PUSH
80971: LD_INT 3
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 1
80980: PUSH
80981: LD_INT 3
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: LIST
81010: LIST
81011: LIST
81012: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81013: LD_ADDR_VAR 0 26
81017: PUSH
81018: LD_INT 0
81020: PUSH
81021: LD_INT 0
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 0
81030: PUSH
81031: LD_INT 1
81033: NEG
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 1
81041: PUSH
81042: LD_INT 0
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 1
81051: PUSH
81052: LD_INT 1
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 0
81061: PUSH
81062: LD_INT 1
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 1
81071: NEG
81072: PUSH
81073: LD_INT 0
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 1
81082: NEG
81083: PUSH
81084: LD_INT 1
81086: NEG
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 1
81094: NEG
81095: PUSH
81096: LD_INT 2
81098: NEG
81099: PUSH
81100: EMPTY
81101: LIST
81102: LIST
81103: PUSH
81104: LD_INT 0
81106: PUSH
81107: LD_INT 2
81109: NEG
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 1
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 2
81128: PUSH
81129: LD_INT 0
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: LD_INT 2
81138: PUSH
81139: LD_INT 1
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 2
81148: PUSH
81149: LD_INT 2
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 1
81158: PUSH
81159: LD_INT 2
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 0
81168: PUSH
81169: LD_INT 2
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PUSH
81176: LD_INT 1
81178: NEG
81179: PUSH
81180: LD_INT 1
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 2
81189: NEG
81190: PUSH
81191: LD_INT 0
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 2
81200: NEG
81201: PUSH
81202: LD_INT 1
81204: NEG
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 2
81212: NEG
81213: PUSH
81214: LD_INT 2
81216: NEG
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: PUSH
81222: LD_INT 2
81224: PUSH
81225: LD_INT 3
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 1
81234: PUSH
81235: LD_INT 3
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 1
81244: NEG
81245: PUSH
81246: LD_INT 2
81248: PUSH
81249: EMPTY
81250: LIST
81251: LIST
81252: PUSH
81253: LD_INT 2
81255: NEG
81256: PUSH
81257: LD_INT 1
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81289: LD_ADDR_VAR 0 27
81293: PUSH
81294: LD_INT 0
81296: PUSH
81297: LD_INT 0
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 0
81306: PUSH
81307: LD_INT 1
81309: NEG
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 1
81317: PUSH
81318: LD_INT 0
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 1
81327: PUSH
81328: LD_INT 1
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 0
81337: PUSH
81338: LD_INT 1
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 1
81347: NEG
81348: PUSH
81349: LD_INT 0
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 1
81358: NEG
81359: PUSH
81360: LD_INT 1
81362: NEG
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 1
81370: NEG
81371: PUSH
81372: LD_INT 2
81374: NEG
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: LD_INT 2
81385: NEG
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: LD_INT 1
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 2
81404: PUSH
81405: LD_INT 0
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 2
81414: PUSH
81415: LD_INT 1
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 2
81424: PUSH
81425: LD_INT 2
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 1
81434: PUSH
81435: LD_INT 2
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 0
81444: PUSH
81445: LD_INT 2
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 1
81454: NEG
81455: PUSH
81456: LD_INT 1
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 2
81465: NEG
81466: PUSH
81467: LD_INT 0
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 2
81476: NEG
81477: PUSH
81478: LD_INT 1
81480: NEG
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: PUSH
81486: LD_INT 2
81488: NEG
81489: PUSH
81490: LD_INT 2
81492: NEG
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: LD_INT 1
81500: NEG
81501: PUSH
81502: LD_INT 2
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 2
81511: NEG
81512: PUSH
81513: LD_INT 1
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 3
81522: NEG
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 3
81534: NEG
81535: PUSH
81536: LD_INT 2
81538: NEG
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: LIST
81562: LIST
81563: LIST
81564: LIST
81565: LIST
81566: LIST
81567: LIST
81568: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81569: LD_ADDR_VAR 0 28
81573: PUSH
81574: LD_INT 0
81576: PUSH
81577: LD_INT 0
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PUSH
81584: LD_INT 0
81586: PUSH
81587: LD_INT 1
81589: NEG
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_INT 1
81597: PUSH
81598: LD_INT 0
81600: PUSH
81601: EMPTY
81602: LIST
81603: LIST
81604: PUSH
81605: LD_INT 1
81607: PUSH
81608: LD_INT 1
81610: PUSH
81611: EMPTY
81612: LIST
81613: LIST
81614: PUSH
81615: LD_INT 0
81617: PUSH
81618: LD_INT 1
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 1
81627: NEG
81628: PUSH
81629: LD_INT 0
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 1
81638: NEG
81639: PUSH
81640: LD_INT 1
81642: NEG
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 1
81650: NEG
81651: PUSH
81652: LD_INT 2
81654: NEG
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: PUSH
81660: LD_INT 0
81662: PUSH
81663: LD_INT 2
81665: NEG
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: PUSH
81671: LD_INT 1
81673: PUSH
81674: LD_INT 1
81676: NEG
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 2
81684: PUSH
81685: LD_INT 0
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 2
81694: PUSH
81695: LD_INT 1
81697: PUSH
81698: EMPTY
81699: LIST
81700: LIST
81701: PUSH
81702: LD_INT 2
81704: PUSH
81705: LD_INT 2
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: PUSH
81712: LD_INT 1
81714: PUSH
81715: LD_INT 2
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: LD_INT 0
81724: PUSH
81725: LD_INT 2
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: PUSH
81732: LD_INT 1
81734: NEG
81735: PUSH
81736: LD_INT 1
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: PUSH
81743: LD_INT 2
81745: NEG
81746: PUSH
81747: LD_INT 0
81749: PUSH
81750: EMPTY
81751: LIST
81752: LIST
81753: PUSH
81754: LD_INT 2
81756: NEG
81757: PUSH
81758: LD_INT 1
81760: NEG
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 2
81768: NEG
81769: PUSH
81770: LD_INT 2
81772: NEG
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 2
81780: NEG
81781: PUSH
81782: LD_INT 3
81784: NEG
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: LD_INT 1
81792: NEG
81793: PUSH
81794: LD_INT 3
81796: NEG
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 3
81804: NEG
81805: PUSH
81806: LD_INT 1
81808: NEG
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: PUSH
81814: LD_INT 3
81816: NEG
81817: PUSH
81818: LD_INT 2
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: LIST
81844: LIST
81845: LIST
81846: LIST
81847: LIST
81848: LIST
81849: LIST
81850: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81851: LD_ADDR_VAR 0 29
81855: PUSH
81856: LD_INT 0
81858: PUSH
81859: LD_INT 0
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 0
81868: PUSH
81869: LD_INT 1
81871: NEG
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 1
81879: PUSH
81880: LD_INT 0
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 1
81889: PUSH
81890: LD_INT 1
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 0
81899: PUSH
81900: LD_INT 1
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 1
81909: NEG
81910: PUSH
81911: LD_INT 0
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 1
81920: NEG
81921: PUSH
81922: LD_INT 1
81924: NEG
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 1
81932: NEG
81933: PUSH
81934: LD_INT 2
81936: NEG
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 0
81944: PUSH
81945: LD_INT 2
81947: NEG
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 1
81955: PUSH
81956: LD_INT 1
81958: NEG
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 2
81966: PUSH
81967: LD_INT 0
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 2
81976: PUSH
81977: LD_INT 1
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: LD_INT 1
81986: PUSH
81987: LD_INT 2
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: LD_INT 2
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 1
82006: NEG
82007: PUSH
82008: LD_INT 1
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 2
82017: NEG
82018: PUSH
82019: LD_INT 1
82021: NEG
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 2
82029: NEG
82030: PUSH
82031: LD_INT 2
82033: NEG
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 2
82041: NEG
82042: PUSH
82043: LD_INT 3
82045: NEG
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: LD_INT 2
82053: PUSH
82054: LD_INT 1
82056: NEG
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 3
82064: PUSH
82065: LD_INT 1
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PUSH
82072: LD_INT 1
82074: PUSH
82075: LD_INT 3
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 1
82084: NEG
82085: PUSH
82086: LD_INT 2
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 3
82095: NEG
82096: PUSH
82097: LD_INT 2
82099: NEG
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: LIST
82127: LIST
82128: LIST
82129: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82130: LD_ADDR_VAR 0 30
82134: PUSH
82135: LD_INT 0
82137: PUSH
82138: LD_INT 0
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 0
82147: PUSH
82148: LD_INT 1
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 1
82158: PUSH
82159: LD_INT 0
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 1
82168: PUSH
82169: LD_INT 1
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: PUSH
82176: LD_INT 0
82178: PUSH
82179: LD_INT 1
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: LD_INT 1
82188: NEG
82189: PUSH
82190: LD_INT 0
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PUSH
82197: LD_INT 1
82199: NEG
82200: PUSH
82201: LD_INT 1
82203: NEG
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: LD_INT 2
82215: NEG
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 0
82223: PUSH
82224: LD_INT 2
82226: NEG
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 1
82234: PUSH
82235: LD_INT 1
82237: NEG
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 2
82245: PUSH
82246: LD_INT 0
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 2
82255: PUSH
82256: LD_INT 1
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 2
82265: PUSH
82266: LD_INT 2
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PUSH
82273: LD_INT 1
82275: PUSH
82276: LD_INT 2
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PUSH
82283: LD_INT 1
82285: NEG
82286: PUSH
82287: LD_INT 1
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 2
82296: NEG
82297: PUSH
82298: LD_INT 0
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: LD_INT 2
82307: NEG
82308: PUSH
82309: LD_INT 1
82311: NEG
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 1
82319: NEG
82320: PUSH
82321: LD_INT 3
82323: NEG
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 1
82331: PUSH
82332: LD_INT 2
82334: NEG
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: LD_INT 3
82342: PUSH
82343: LD_INT 2
82345: PUSH
82346: EMPTY
82347: LIST
82348: LIST
82349: PUSH
82350: LD_INT 2
82352: PUSH
82353: LD_INT 3
82355: PUSH
82356: EMPTY
82357: LIST
82358: LIST
82359: PUSH
82360: LD_INT 2
82362: NEG
82363: PUSH
82364: LD_INT 1
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: PUSH
82371: LD_INT 3
82373: NEG
82374: PUSH
82375: LD_INT 1
82377: NEG
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82408: LD_ADDR_VAR 0 31
82412: PUSH
82413: LD_INT 0
82415: PUSH
82416: LD_INT 0
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 0
82425: PUSH
82426: LD_INT 1
82428: NEG
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 1
82436: PUSH
82437: LD_INT 0
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 1
82446: PUSH
82447: LD_INT 1
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 0
82456: PUSH
82457: LD_INT 1
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 1
82466: NEG
82467: PUSH
82468: LD_INT 0
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: PUSH
82475: LD_INT 1
82477: NEG
82478: PUSH
82479: LD_INT 1
82481: NEG
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 1
82489: NEG
82490: PUSH
82491: LD_INT 2
82493: NEG
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 1
82501: PUSH
82502: LD_INT 1
82504: NEG
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 2
82512: PUSH
82513: LD_INT 0
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 2
82522: PUSH
82523: LD_INT 1
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 2
82532: PUSH
82533: LD_INT 2
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 1
82542: PUSH
82543: LD_INT 2
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PUSH
82550: LD_INT 0
82552: PUSH
82553: LD_INT 2
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 1
82562: NEG
82563: PUSH
82564: LD_INT 1
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 2
82573: NEG
82574: PUSH
82575: LD_INT 1
82577: NEG
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 2
82585: NEG
82586: PUSH
82587: LD_INT 2
82589: NEG
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 2
82597: NEG
82598: PUSH
82599: LD_INT 3
82601: NEG
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 2
82609: PUSH
82610: LD_INT 1
82612: NEG
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 3
82620: PUSH
82621: LD_INT 1
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 1
82630: PUSH
82631: LD_INT 3
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 1
82640: NEG
82641: PUSH
82642: LD_INT 2
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 3
82651: NEG
82652: PUSH
82653: LD_INT 2
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82686: LD_ADDR_VAR 0 32
82690: PUSH
82691: LD_INT 0
82693: PUSH
82694: LD_INT 0
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 0
82703: PUSH
82704: LD_INT 1
82706: NEG
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 1
82714: PUSH
82715: LD_INT 0
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 1
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 0
82734: PUSH
82735: LD_INT 1
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: NEG
82745: PUSH
82746: LD_INT 0
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: LD_INT 1
82755: NEG
82756: PUSH
82757: LD_INT 1
82759: NEG
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 1
82767: NEG
82768: PUSH
82769: LD_INT 2
82771: NEG
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 0
82779: PUSH
82780: LD_INT 2
82782: NEG
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 1
82790: PUSH
82791: LD_INT 1
82793: NEG
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 2
82801: PUSH
82802: LD_INT 1
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 2
82811: PUSH
82812: LD_INT 2
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 1
82821: PUSH
82822: LD_INT 2
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 0
82831: PUSH
82832: LD_INT 2
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 1
82841: NEG
82842: PUSH
82843: LD_INT 1
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 2
82852: NEG
82853: PUSH
82854: LD_INT 0
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 2
82863: NEG
82864: PUSH
82865: LD_INT 1
82867: NEG
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 1
82875: NEG
82876: PUSH
82877: LD_INT 3
82879: NEG
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 1
82887: PUSH
82888: LD_INT 2
82890: NEG
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: PUSH
82896: LD_INT 3
82898: PUSH
82899: LD_INT 2
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 2
82908: PUSH
82909: LD_INT 3
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 2
82918: NEG
82919: PUSH
82920: LD_INT 1
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 3
82929: NEG
82930: PUSH
82931: LD_INT 1
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: LIST
82943: LIST
82944: LIST
82945: LIST
82946: LIST
82947: LIST
82948: LIST
82949: LIST
82950: LIST
82951: LIST
82952: LIST
82953: LIST
82954: LIST
82955: LIST
82956: LIST
82957: LIST
82958: LIST
82959: LIST
82960: LIST
82961: LIST
82962: LIST
82963: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82964: LD_ADDR_VAR 0 33
82968: PUSH
82969: LD_INT 0
82971: PUSH
82972: LD_INT 0
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 0
82981: PUSH
82982: LD_INT 1
82984: NEG
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 1
82992: PUSH
82993: LD_INT 0
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 1
83002: PUSH
83003: LD_INT 1
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 0
83012: PUSH
83013: LD_INT 1
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 1
83022: NEG
83023: PUSH
83024: LD_INT 0
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 1
83033: NEG
83034: PUSH
83035: LD_INT 1
83037: NEG
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 1
83045: NEG
83046: PUSH
83047: LD_INT 2
83049: NEG
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: LD_INT 1
83060: NEG
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 2
83068: PUSH
83069: LD_INT 0
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 2
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: PUSH
83089: LD_INT 2
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 0
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 1
83108: NEG
83109: PUSH
83110: LD_INT 1
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 2
83119: NEG
83120: PUSH
83121: LD_INT 0
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 2
83130: NEG
83131: PUSH
83132: LD_INT 1
83134: NEG
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 2
83142: NEG
83143: PUSH
83144: LD_INT 2
83146: NEG
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: PUSH
83152: LD_INT 2
83154: NEG
83155: PUSH
83156: LD_INT 3
83158: NEG
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: LD_INT 2
83166: PUSH
83167: LD_INT 1
83169: NEG
83170: PUSH
83171: EMPTY
83172: LIST
83173: LIST
83174: PUSH
83175: LD_INT 3
83177: PUSH
83178: LD_INT 1
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: PUSH
83185: LD_INT 1
83187: PUSH
83188: LD_INT 3
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 1
83197: NEG
83198: PUSH
83199: LD_INT 2
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 3
83208: NEG
83209: PUSH
83210: LD_INT 2
83212: NEG
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83243: LD_ADDR_VAR 0 34
83247: PUSH
83248: LD_INT 0
83250: PUSH
83251: LD_INT 0
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PUSH
83258: LD_INT 0
83260: PUSH
83261: LD_INT 1
83263: NEG
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: PUSH
83269: LD_INT 1
83271: PUSH
83272: LD_INT 0
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: PUSH
83279: LD_INT 1
83281: PUSH
83282: LD_INT 1
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 0
83291: PUSH
83292: LD_INT 1
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 1
83301: NEG
83302: PUSH
83303: LD_INT 0
83305: PUSH
83306: EMPTY
83307: LIST
83308: LIST
83309: PUSH
83310: LD_INT 1
83312: NEG
83313: PUSH
83314: LD_INT 1
83316: NEG
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 1
83324: NEG
83325: PUSH
83326: LD_INT 2
83328: NEG
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 0
83336: PUSH
83337: LD_INT 2
83339: NEG
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 1
83347: PUSH
83348: LD_INT 1
83350: NEG
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 2
83358: PUSH
83359: LD_INT 1
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 2
83368: PUSH
83369: LD_INT 2
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: PUSH
83376: LD_INT 1
83378: PUSH
83379: LD_INT 2
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 1
83388: NEG
83389: PUSH
83390: LD_INT 1
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 2
83399: NEG
83400: PUSH
83401: LD_INT 0
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 2
83410: NEG
83411: PUSH
83412: LD_INT 1
83414: NEG
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 2
83422: NEG
83423: PUSH
83424: LD_INT 2
83426: NEG
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 1
83434: NEG
83435: PUSH
83436: LD_INT 3
83438: NEG
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: LD_INT 2
83449: NEG
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 3
83457: PUSH
83458: LD_INT 2
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: LD_INT 2
83467: PUSH
83468: LD_INT 3
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PUSH
83475: LD_INT 2
83477: NEG
83478: PUSH
83479: LD_INT 1
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 3
83488: NEG
83489: PUSH
83490: LD_INT 1
83492: NEG
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: LIST
83510: LIST
83511: LIST
83512: LIST
83513: LIST
83514: LIST
83515: LIST
83516: LIST
83517: LIST
83518: LIST
83519: LIST
83520: LIST
83521: LIST
83522: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83523: LD_ADDR_VAR 0 35
83527: PUSH
83528: LD_INT 0
83530: PUSH
83531: LD_INT 0
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 0
83540: PUSH
83541: LD_INT 1
83543: NEG
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 1
83551: PUSH
83552: LD_INT 0
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 1
83561: PUSH
83562: LD_INT 1
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: LD_INT 0
83571: PUSH
83572: LD_INT 1
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 1
83581: NEG
83582: PUSH
83583: LD_INT 0
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 1
83592: NEG
83593: PUSH
83594: LD_INT 1
83596: NEG
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 2
83604: PUSH
83605: LD_INT 1
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 2
83614: NEG
83615: PUSH
83616: LD_INT 1
83618: NEG
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83635: LD_ADDR_VAR 0 36
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: LD_INT 0
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: LD_INT 1
83655: NEG
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 1
83663: PUSH
83664: LD_INT 0
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: LD_INT 1
83673: PUSH
83674: LD_INT 1
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 0
83683: PUSH
83684: LD_INT 1
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: PUSH
83691: LD_INT 1
83693: NEG
83694: PUSH
83695: LD_INT 0
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: LD_INT 1
83704: NEG
83705: PUSH
83706: LD_INT 1
83708: NEG
83709: PUSH
83710: EMPTY
83711: LIST
83712: LIST
83713: PUSH
83714: LD_INT 1
83716: NEG
83717: PUSH
83718: LD_INT 2
83720: NEG
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 1
83728: PUSH
83729: LD_INT 2
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83747: LD_ADDR_VAR 0 37
83751: PUSH
83752: LD_INT 0
83754: PUSH
83755: LD_INT 0
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 0
83764: PUSH
83765: LD_INT 1
83767: NEG
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 1
83775: PUSH
83776: LD_INT 0
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 1
83785: PUSH
83786: LD_INT 1
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: LD_INT 0
83795: PUSH
83796: LD_INT 1
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 1
83805: NEG
83806: PUSH
83807: LD_INT 0
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 1
83816: NEG
83817: PUSH
83818: LD_INT 1
83820: NEG
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: PUSH
83826: LD_INT 1
83828: PUSH
83829: LD_INT 1
83831: NEG
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PUSH
83837: LD_INT 1
83839: NEG
83840: PUSH
83841: LD_INT 1
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83859: LD_ADDR_VAR 0 38
83863: PUSH
83864: LD_INT 0
83866: PUSH
83867: LD_INT 0
83869: PUSH
83870: EMPTY
83871: LIST
83872: LIST
83873: PUSH
83874: LD_INT 0
83876: PUSH
83877: LD_INT 1
83879: NEG
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: LD_INT 1
83887: PUSH
83888: LD_INT 0
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 1
83897: PUSH
83898: LD_INT 1
83900: PUSH
83901: EMPTY
83902: LIST
83903: LIST
83904: PUSH
83905: LD_INT 0
83907: PUSH
83908: LD_INT 1
83910: PUSH
83911: EMPTY
83912: LIST
83913: LIST
83914: PUSH
83915: LD_INT 1
83917: NEG
83918: PUSH
83919: LD_INT 0
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: PUSH
83926: LD_INT 1
83928: NEG
83929: PUSH
83930: LD_INT 1
83932: NEG
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 2
83940: PUSH
83941: LD_INT 1
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: PUSH
83948: LD_INT 2
83950: NEG
83951: PUSH
83952: LD_INT 1
83954: NEG
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83971: LD_ADDR_VAR 0 39
83975: PUSH
83976: LD_INT 0
83978: PUSH
83979: LD_INT 0
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 0
83988: PUSH
83989: LD_INT 1
83991: NEG
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 1
83999: PUSH
84000: LD_INT 0
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 1
84009: PUSH
84010: LD_INT 1
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 0
84019: PUSH
84020: LD_INT 1
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PUSH
84027: LD_INT 1
84029: NEG
84030: PUSH
84031: LD_INT 0
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PUSH
84038: LD_INT 1
84040: NEG
84041: PUSH
84042: LD_INT 1
84044: NEG
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 1
84052: NEG
84053: PUSH
84054: LD_INT 2
84056: NEG
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: PUSH
84062: LD_INT 1
84064: PUSH
84065: LD_INT 2
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84083: LD_ADDR_VAR 0 40
84087: PUSH
84088: LD_INT 0
84090: PUSH
84091: LD_INT 0
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: LD_INT 0
84100: PUSH
84101: LD_INT 1
84103: NEG
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: PUSH
84109: LD_INT 1
84111: PUSH
84112: LD_INT 0
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 1
84121: PUSH
84122: LD_INT 1
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 1
84141: NEG
84142: PUSH
84143: LD_INT 0
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 1
84152: NEG
84153: PUSH
84154: LD_INT 1
84156: NEG
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 1
84164: PUSH
84165: LD_INT 1
84167: NEG
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 1
84175: NEG
84176: PUSH
84177: LD_INT 1
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: LIST
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: LIST
84193: LIST
84194: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84195: LD_ADDR_VAR 0 41
84199: PUSH
84200: LD_INT 0
84202: PUSH
84203: LD_INT 0
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: PUSH
84210: LD_INT 0
84212: PUSH
84213: LD_INT 1
84215: NEG
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 1
84223: PUSH
84224: LD_INT 0
84226: PUSH
84227: EMPTY
84228: LIST
84229: LIST
84230: PUSH
84231: LD_INT 1
84233: PUSH
84234: LD_INT 1
84236: PUSH
84237: EMPTY
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 0
84243: PUSH
84244: LD_INT 1
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 1
84253: NEG
84254: PUSH
84255: LD_INT 0
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 1
84264: NEG
84265: PUSH
84266: LD_INT 1
84268: NEG
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: PUSH
84274: LD_INT 1
84276: NEG
84277: PUSH
84278: LD_INT 2
84280: NEG
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_INT 1
84288: PUSH
84289: LD_INT 1
84291: NEG
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 2
84299: PUSH
84300: LD_INT 0
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: LD_INT 2
84309: PUSH
84310: LD_INT 1
84312: PUSH
84313: EMPTY
84314: LIST
84315: LIST
84316: PUSH
84317: LD_INT 2
84319: PUSH
84320: LD_INT 2
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 1
84329: PUSH
84330: LD_INT 2
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 1
84339: NEG
84340: PUSH
84341: LD_INT 1
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 2
84350: NEG
84351: PUSH
84352: LD_INT 0
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 2
84361: NEG
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 2
84373: NEG
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 2
84385: NEG
84386: PUSH
84387: LD_INT 3
84389: NEG
84390: PUSH
84391: EMPTY
84392: LIST
84393: LIST
84394: PUSH
84395: LD_INT 2
84397: PUSH
84398: LD_INT 1
84400: NEG
84401: PUSH
84402: EMPTY
84403: LIST
84404: LIST
84405: PUSH
84406: LD_INT 3
84408: PUSH
84409: LD_INT 0
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: PUSH
84416: LD_INT 3
84418: PUSH
84419: LD_INT 1
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 3
84428: PUSH
84429: LD_INT 2
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 3
84438: PUSH
84439: LD_INT 3
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 2
84448: PUSH
84449: LD_INT 3
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 2
84458: NEG
84459: PUSH
84460: LD_INT 1
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: PUSH
84467: LD_INT 3
84469: NEG
84470: PUSH
84471: LD_INT 0
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 3
84480: NEG
84481: PUSH
84482: LD_INT 1
84484: NEG
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 3
84492: NEG
84493: PUSH
84494: LD_INT 2
84496: NEG
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: LD_INT 3
84504: NEG
84505: PUSH
84506: LD_INT 3
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84545: LD_ADDR_VAR 0 42
84549: PUSH
84550: LD_INT 0
84552: PUSH
84553: LD_INT 0
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 0
84562: PUSH
84563: LD_INT 1
84565: NEG
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 1
84573: PUSH
84574: LD_INT 0
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 1
84583: PUSH
84584: LD_INT 1
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PUSH
84591: LD_INT 0
84593: PUSH
84594: LD_INT 1
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 1
84603: NEG
84604: PUSH
84605: LD_INT 0
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 1
84614: NEG
84615: PUSH
84616: LD_INT 1
84618: NEG
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 1
84626: NEG
84627: PUSH
84628: LD_INT 2
84630: NEG
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_INT 0
84638: PUSH
84639: LD_INT 2
84641: NEG
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: LD_INT 1
84652: NEG
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: LD_INT 2
84660: PUSH
84661: LD_INT 1
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 2
84670: PUSH
84671: LD_INT 2
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 1
84680: PUSH
84681: LD_INT 2
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: PUSH
84688: LD_INT 0
84690: PUSH
84691: LD_INT 2
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: PUSH
84698: LD_INT 1
84700: NEG
84701: PUSH
84702: LD_INT 1
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 2
84711: NEG
84712: PUSH
84713: LD_INT 1
84715: NEG
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 2
84723: NEG
84724: PUSH
84725: LD_INT 2
84727: NEG
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 2
84735: NEG
84736: PUSH
84737: LD_INT 3
84739: NEG
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 1
84747: NEG
84748: PUSH
84749: LD_INT 3
84751: NEG
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 0
84759: PUSH
84760: LD_INT 3
84762: NEG
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 1
84770: PUSH
84771: LD_INT 2
84773: NEG
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 3
84781: PUSH
84782: LD_INT 2
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 3
84791: PUSH
84792: LD_INT 3
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 2
84801: PUSH
84802: LD_INT 3
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 1
84811: PUSH
84812: LD_INT 3
84814: PUSH
84815: EMPTY
84816: LIST
84817: LIST
84818: PUSH
84819: LD_INT 0
84821: PUSH
84822: LD_INT 3
84824: PUSH
84825: EMPTY
84826: LIST
84827: LIST
84828: PUSH
84829: LD_INT 1
84831: NEG
84832: PUSH
84833: LD_INT 2
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: LD_INT 3
84842: NEG
84843: PUSH
84844: LD_INT 2
84846: NEG
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: PUSH
84852: LD_INT 3
84854: NEG
84855: PUSH
84856: LD_INT 3
84858: NEG
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84895: LD_ADDR_VAR 0 43
84899: PUSH
84900: LD_INT 0
84902: PUSH
84903: LD_INT 0
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 0
84912: PUSH
84913: LD_INT 1
84915: NEG
84916: PUSH
84917: EMPTY
84918: LIST
84919: LIST
84920: PUSH
84921: LD_INT 1
84923: PUSH
84924: LD_INT 0
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: PUSH
84931: LD_INT 1
84933: PUSH
84934: LD_INT 1
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: PUSH
84941: LD_INT 0
84943: PUSH
84944: LD_INT 1
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PUSH
84951: LD_INT 1
84953: NEG
84954: PUSH
84955: LD_INT 0
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 1
84964: NEG
84965: PUSH
84966: LD_INT 1
84968: NEG
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 1
84976: NEG
84977: PUSH
84978: LD_INT 2
84980: NEG
84981: PUSH
84982: EMPTY
84983: LIST
84984: LIST
84985: PUSH
84986: LD_INT 0
84988: PUSH
84989: LD_INT 2
84991: NEG
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 1
84999: PUSH
85000: LD_INT 1
85002: NEG
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 2
85010: PUSH
85011: LD_INT 0
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 2
85020: PUSH
85021: LD_INT 1
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 1
85030: PUSH
85031: LD_INT 2
85033: PUSH
85034: EMPTY
85035: LIST
85036: LIST
85037: PUSH
85038: LD_INT 0
85040: PUSH
85041: LD_INT 2
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 1
85050: NEG
85051: PUSH
85052: LD_INT 1
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 2
85061: NEG
85062: PUSH
85063: LD_INT 0
85065: PUSH
85066: EMPTY
85067: LIST
85068: LIST
85069: PUSH
85070: LD_INT 2
85072: NEG
85073: PUSH
85074: LD_INT 1
85076: NEG
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 1
85084: NEG
85085: PUSH
85086: LD_INT 3
85088: NEG
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 0
85096: PUSH
85097: LD_INT 3
85099: NEG
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: PUSH
85105: LD_INT 1
85107: PUSH
85108: LD_INT 2
85110: NEG
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 2
85118: PUSH
85119: LD_INT 1
85121: NEG
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 3
85129: PUSH
85130: LD_INT 0
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: PUSH
85137: LD_INT 3
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: PUSH
85150: LD_INT 3
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: PUSH
85157: LD_INT 0
85159: PUSH
85160: LD_INT 3
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 1
85169: NEG
85170: PUSH
85171: LD_INT 2
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 2
85180: NEG
85181: PUSH
85182: LD_INT 1
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PUSH
85189: LD_INT 3
85191: NEG
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 3
85202: NEG
85203: PUSH
85204: LD_INT 1
85206: NEG
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85243: LD_ADDR_VAR 0 44
85247: PUSH
85248: LD_INT 0
85250: PUSH
85251: LD_INT 0
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: PUSH
85258: LD_INT 0
85260: PUSH
85261: LD_INT 1
85263: NEG
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 1
85271: PUSH
85272: LD_INT 0
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: LD_INT 1
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 0
85291: PUSH
85292: LD_INT 1
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 1
85301: NEG
85302: PUSH
85303: LD_INT 0
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 1
85312: NEG
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 1
85324: NEG
85325: PUSH
85326: LD_INT 2
85328: NEG
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 1
85336: PUSH
85337: LD_INT 1
85339: NEG
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: LD_INT 2
85347: PUSH
85348: LD_INT 0
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_INT 2
85357: PUSH
85358: LD_INT 1
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_INT 2
85367: PUSH
85368: LD_INT 2
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 1
85377: PUSH
85378: LD_INT 2
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 1
85387: NEG
85388: PUSH
85389: LD_INT 1
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 2
85398: NEG
85399: PUSH
85400: LD_INT 0
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 2
85409: NEG
85410: PUSH
85411: LD_INT 1
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 2
85421: NEG
85422: PUSH
85423: LD_INT 2
85425: NEG
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 2
85433: NEG
85434: PUSH
85435: LD_INT 3
85437: NEG
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 2
85445: PUSH
85446: LD_INT 1
85448: NEG
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 3
85456: PUSH
85457: LD_INT 0
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 3
85466: PUSH
85467: LD_INT 1
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 3
85476: PUSH
85477: LD_INT 2
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 3
85486: PUSH
85487: LD_INT 3
85489: PUSH
85490: EMPTY
85491: LIST
85492: LIST
85493: PUSH
85494: LD_INT 2
85496: PUSH
85497: LD_INT 3
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: PUSH
85504: LD_INT 2
85506: NEG
85507: PUSH
85508: LD_INT 1
85510: PUSH
85511: EMPTY
85512: LIST
85513: LIST
85514: PUSH
85515: LD_INT 3
85517: NEG
85518: PUSH
85519: LD_INT 0
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 3
85528: NEG
85529: PUSH
85530: LD_INT 1
85532: NEG
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 3
85540: NEG
85541: PUSH
85542: LD_INT 2
85544: NEG
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: PUSH
85550: LD_INT 3
85552: NEG
85553: PUSH
85554: LD_INT 3
85556: NEG
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85593: LD_ADDR_VAR 0 45
85597: PUSH
85598: LD_INT 0
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: EMPTY
85605: LIST
85606: LIST
85607: PUSH
85608: LD_INT 0
85610: PUSH
85611: LD_INT 1
85613: NEG
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 1
85621: PUSH
85622: LD_INT 0
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 1
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 0
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 1
85651: NEG
85652: PUSH
85653: LD_INT 0
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: LD_INT 1
85666: NEG
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 1
85674: NEG
85675: PUSH
85676: LD_INT 2
85678: NEG
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: PUSH
85684: LD_INT 0
85686: PUSH
85687: LD_INT 2
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 1
85697: PUSH
85698: LD_INT 1
85700: NEG
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: PUSH
85706: LD_INT 2
85708: PUSH
85709: LD_INT 1
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 2
85718: PUSH
85719: LD_INT 2
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 1
85728: PUSH
85729: LD_INT 2
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 0
85738: PUSH
85739: LD_INT 2
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 1
85748: NEG
85749: PUSH
85750: LD_INT 1
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 2
85759: NEG
85760: PUSH
85761: LD_INT 1
85763: NEG
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 2
85771: NEG
85772: PUSH
85773: LD_INT 2
85775: NEG
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 2
85783: NEG
85784: PUSH
85785: LD_INT 3
85787: NEG
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: PUSH
85793: LD_INT 1
85795: NEG
85796: PUSH
85797: LD_INT 3
85799: NEG
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 0
85807: PUSH
85808: LD_INT 3
85810: NEG
85811: PUSH
85812: EMPTY
85813: LIST
85814: LIST
85815: PUSH
85816: LD_INT 1
85818: PUSH
85819: LD_INT 2
85821: NEG
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: LD_INT 3
85829: PUSH
85830: LD_INT 2
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: PUSH
85837: LD_INT 3
85839: PUSH
85840: LD_INT 3
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 2
85849: PUSH
85850: LD_INT 3
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 1
85859: PUSH
85860: LD_INT 3
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 0
85869: PUSH
85870: LD_INT 3
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 1
85879: NEG
85880: PUSH
85881: LD_INT 2
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 3
85890: NEG
85891: PUSH
85892: LD_INT 2
85894: NEG
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 3
85902: NEG
85903: PUSH
85904: LD_INT 3
85906: NEG
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85943: LD_ADDR_VAR 0 46
85947: PUSH
85948: LD_INT 0
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 0
85960: PUSH
85961: LD_INT 1
85963: NEG
85964: PUSH
85965: EMPTY
85966: LIST
85967: LIST
85968: PUSH
85969: LD_INT 1
85971: PUSH
85972: LD_INT 0
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: LD_INT 1
85981: PUSH
85982: LD_INT 1
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: PUSH
85989: LD_INT 0
85991: PUSH
85992: LD_INT 1
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 1
86001: NEG
86002: PUSH
86003: LD_INT 0
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 1
86012: NEG
86013: PUSH
86014: LD_INT 1
86016: NEG
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 1
86024: NEG
86025: PUSH
86026: LD_INT 2
86028: NEG
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: PUSH
86034: LD_INT 0
86036: PUSH
86037: LD_INT 2
86039: NEG
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: LD_INT 1
86047: PUSH
86048: LD_INT 1
86050: NEG
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 2
86058: PUSH
86059: LD_INT 0
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 2
86068: PUSH
86069: LD_INT 1
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 1
86078: PUSH
86079: LD_INT 2
86081: PUSH
86082: EMPTY
86083: LIST
86084: LIST
86085: PUSH
86086: LD_INT 0
86088: PUSH
86089: LD_INT 2
86091: PUSH
86092: EMPTY
86093: LIST
86094: LIST
86095: PUSH
86096: LD_INT 1
86098: NEG
86099: PUSH
86100: LD_INT 1
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 2
86109: NEG
86110: PUSH
86111: LD_INT 0
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 2
86120: NEG
86121: PUSH
86122: LD_INT 1
86124: NEG
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: NEG
86133: PUSH
86134: LD_INT 3
86136: NEG
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 0
86144: PUSH
86145: LD_INT 3
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 1
86155: PUSH
86156: LD_INT 2
86158: NEG
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PUSH
86164: LD_INT 2
86166: PUSH
86167: LD_INT 1
86169: NEG
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: LD_INT 3
86177: PUSH
86178: LD_INT 0
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: LD_INT 3
86187: PUSH
86188: LD_INT 1
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: LD_INT 1
86197: PUSH
86198: LD_INT 3
86200: PUSH
86201: EMPTY
86202: LIST
86203: LIST
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: LD_INT 3
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: PUSH
86215: LD_INT 1
86217: NEG
86218: PUSH
86219: LD_INT 2
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: PUSH
86226: LD_INT 2
86228: NEG
86229: PUSH
86230: LD_INT 1
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: PUSH
86237: LD_INT 3
86239: NEG
86240: PUSH
86241: LD_INT 0
86243: PUSH
86244: EMPTY
86245: LIST
86246: LIST
86247: PUSH
86248: LD_INT 3
86250: NEG
86251: PUSH
86252: LD_INT 1
86254: NEG
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: LIST
86280: LIST
86281: LIST
86282: LIST
86283: LIST
86284: LIST
86285: LIST
86286: LIST
86287: LIST
86288: LIST
86289: LIST
86290: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86291: LD_ADDR_VAR 0 47
86295: PUSH
86296: LD_INT 0
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 0
86308: PUSH
86309: LD_INT 1
86311: NEG
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: PUSH
86317: LD_INT 1
86319: PUSH
86320: LD_INT 0
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: LD_INT 1
86329: PUSH
86330: LD_INT 1
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 0
86339: PUSH
86340: LD_INT 1
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 1
86349: NEG
86350: PUSH
86351: LD_INT 0
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 1
86360: NEG
86361: PUSH
86362: LD_INT 1
86364: NEG
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 1
86372: NEG
86373: PUSH
86374: LD_INT 2
86376: NEG
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 0
86384: PUSH
86385: LD_INT 2
86387: NEG
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 1
86395: PUSH
86396: LD_INT 1
86398: NEG
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: LD_INT 2
86406: NEG
86407: PUSH
86408: LD_INT 1
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 2
86418: NEG
86419: PUSH
86420: LD_INT 2
86422: NEG
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
86442: LD_ADDR_VAR 0 48
86446: PUSH
86447: LD_INT 0
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 0
86459: PUSH
86460: LD_INT 1
86462: NEG
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 1
86470: PUSH
86471: LD_INT 0
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 1
86480: PUSH
86481: LD_INT 1
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 0
86490: PUSH
86491: LD_INT 1
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 1
86500: NEG
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 1
86511: NEG
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 1
86523: NEG
86524: PUSH
86525: LD_INT 2
86527: NEG
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 0
86535: PUSH
86536: LD_INT 2
86538: NEG
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 1
86546: PUSH
86547: LD_INT 1
86549: NEG
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: PUSH
86555: LD_INT 2
86557: PUSH
86558: LD_INT 0
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 2
86567: PUSH
86568: LD_INT 1
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
86589: LD_ADDR_VAR 0 49
86593: PUSH
86594: LD_INT 0
86596: PUSH
86597: LD_INT 0
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 0
86606: PUSH
86607: LD_INT 1
86609: NEG
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: PUSH
86615: LD_INT 1
86617: PUSH
86618: LD_INT 0
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PUSH
86625: LD_INT 1
86627: PUSH
86628: LD_INT 1
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: LD_INT 1
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 1
86647: NEG
86648: PUSH
86649: LD_INT 0
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 1
86658: NEG
86659: PUSH
86660: LD_INT 1
86662: NEG
86663: PUSH
86664: EMPTY
86665: LIST
86666: LIST
86667: PUSH
86668: LD_INT 1
86670: PUSH
86671: LD_INT 1
86673: NEG
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PUSH
86679: LD_INT 2
86681: PUSH
86682: LD_INT 0
86684: PUSH
86685: EMPTY
86686: LIST
86687: LIST
86688: PUSH
86689: LD_INT 2
86691: PUSH
86692: LD_INT 1
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 2
86701: PUSH
86702: LD_INT 2
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 1
86711: PUSH
86712: LD_INT 2
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
86733: LD_ADDR_VAR 0 50
86737: PUSH
86738: LD_INT 0
86740: PUSH
86741: LD_INT 0
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PUSH
86748: LD_INT 0
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PUSH
86759: LD_INT 1
86761: PUSH
86762: LD_INT 0
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 1
86771: PUSH
86772: LD_INT 1
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: LD_INT 1
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: LD_INT 0
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 1
86802: NEG
86803: PUSH
86804: LD_INT 1
86806: NEG
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 2
86814: PUSH
86815: LD_INT 1
86817: PUSH
86818: EMPTY
86819: LIST
86820: LIST
86821: PUSH
86822: LD_INT 2
86824: PUSH
86825: LD_INT 2
86827: PUSH
86828: EMPTY
86829: LIST
86830: LIST
86831: PUSH
86832: LD_INT 1
86834: PUSH
86835: LD_INT 2
86837: PUSH
86838: EMPTY
86839: LIST
86840: LIST
86841: PUSH
86842: LD_INT 0
86844: PUSH
86845: LD_INT 2
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 1
86854: NEG
86855: PUSH
86856: LD_INT 1
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
86877: LD_ADDR_VAR 0 51
86881: PUSH
86882: LD_INT 0
86884: PUSH
86885: LD_INT 0
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PUSH
86892: LD_INT 0
86894: PUSH
86895: LD_INT 1
86897: NEG
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: LD_INT 1
86905: PUSH
86906: LD_INT 0
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: LD_INT 1
86915: PUSH
86916: LD_INT 1
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: PUSH
86923: LD_INT 0
86925: PUSH
86926: LD_INT 1
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 1
86935: NEG
86936: PUSH
86937: LD_INT 0
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 1
86946: NEG
86947: PUSH
86948: LD_INT 1
86950: NEG
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_INT 1
86958: PUSH
86959: LD_INT 2
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: LD_INT 2
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 1
86978: NEG
86979: PUSH
86980: LD_INT 1
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 2
86989: NEG
86990: PUSH
86991: LD_INT 0
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 2
87000: NEG
87001: PUSH
87002: LD_INT 1
87004: NEG
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87024: LD_ADDR_VAR 0 52
87028: PUSH
87029: LD_INT 0
87031: PUSH
87032: LD_INT 0
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 0
87041: PUSH
87042: LD_INT 1
87044: NEG
87045: PUSH
87046: EMPTY
87047: LIST
87048: LIST
87049: PUSH
87050: LD_INT 1
87052: PUSH
87053: LD_INT 0
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 1
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 0
87072: PUSH
87073: LD_INT 1
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: NEG
87083: PUSH
87084: LD_INT 0
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 1
87093: NEG
87094: PUSH
87095: LD_INT 1
87097: NEG
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 1
87105: NEG
87106: PUSH
87107: LD_INT 2
87109: NEG
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PUSH
87115: LD_INT 1
87117: NEG
87118: PUSH
87119: LD_INT 1
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 2
87128: NEG
87129: PUSH
87130: LD_INT 0
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: PUSH
87137: LD_INT 2
87139: NEG
87140: PUSH
87141: LD_INT 1
87143: NEG
87144: PUSH
87145: EMPTY
87146: LIST
87147: LIST
87148: PUSH
87149: LD_INT 2
87151: NEG
87152: PUSH
87153: LD_INT 2
87155: NEG
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: LIST
87167: LIST
87168: LIST
87169: LIST
87170: LIST
87171: LIST
87172: LIST
87173: LIST
87174: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87175: LD_ADDR_VAR 0 53
87179: PUSH
87180: LD_INT 0
87182: PUSH
87183: LD_INT 0
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 0
87192: PUSH
87193: LD_INT 1
87195: NEG
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 1
87203: PUSH
87204: LD_INT 0
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 1
87213: PUSH
87214: LD_INT 1
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 0
87223: PUSH
87224: LD_INT 1
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: LD_INT 1
87233: NEG
87234: PUSH
87235: LD_INT 0
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 1
87244: NEG
87245: PUSH
87246: LD_INT 1
87248: NEG
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 1
87256: NEG
87257: PUSH
87258: LD_INT 2
87260: NEG
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: LD_INT 0
87268: PUSH
87269: LD_INT 2
87271: NEG
87272: PUSH
87273: EMPTY
87274: LIST
87275: LIST
87276: PUSH
87277: LD_INT 1
87279: PUSH
87280: LD_INT 1
87282: NEG
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 2
87290: PUSH
87291: LD_INT 0
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 2
87300: PUSH
87301: LD_INT 1
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 2
87310: PUSH
87311: LD_INT 2
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 1
87320: PUSH
87321: LD_INT 2
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 0
87330: PUSH
87331: LD_INT 2
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: LD_INT 1
87340: NEG
87341: PUSH
87342: LD_INT 1
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 2
87351: NEG
87352: PUSH
87353: LD_INT 0
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 2
87362: NEG
87363: PUSH
87364: LD_INT 1
87366: NEG
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 2
87374: NEG
87375: PUSH
87376: LD_INT 2
87378: NEG
87379: PUSH
87380: EMPTY
87381: LIST
87382: LIST
87383: PUSH
87384: EMPTY
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87405: LD_ADDR_VAR 0 54
87409: PUSH
87410: LD_INT 0
87412: PUSH
87413: LD_INT 0
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 0
87422: PUSH
87423: LD_INT 1
87425: NEG
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 1
87433: PUSH
87434: LD_INT 0
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 1
87443: PUSH
87444: LD_INT 1
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 0
87453: PUSH
87454: LD_INT 1
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 1
87463: NEG
87464: PUSH
87465: LD_INT 0
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 1
87474: NEG
87475: PUSH
87476: LD_INT 1
87478: NEG
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: LD_INT 1
87486: NEG
87487: PUSH
87488: LD_INT 2
87490: NEG
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 0
87498: PUSH
87499: LD_INT 2
87501: NEG
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PUSH
87507: LD_INT 1
87509: PUSH
87510: LD_INT 1
87512: NEG
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 2
87520: PUSH
87521: LD_INT 0
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 2
87530: PUSH
87531: LD_INT 1
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 2
87540: PUSH
87541: LD_INT 2
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 1
87550: PUSH
87551: LD_INT 2
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 0
87560: PUSH
87561: LD_INT 2
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 1
87570: NEG
87571: PUSH
87572: LD_INT 1
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 2
87581: NEG
87582: PUSH
87583: LD_INT 0
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 2
87592: NEG
87593: PUSH
87594: LD_INT 1
87596: NEG
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 2
87604: NEG
87605: PUSH
87606: LD_INT 2
87608: NEG
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87635: LD_ADDR_VAR 0 55
87639: PUSH
87640: LD_INT 0
87642: PUSH
87643: LD_INT 0
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 0
87652: PUSH
87653: LD_INT 1
87655: NEG
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 1
87663: PUSH
87664: LD_INT 0
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 1
87673: PUSH
87674: LD_INT 1
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 0
87683: PUSH
87684: LD_INT 1
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 1
87693: NEG
87694: PUSH
87695: LD_INT 0
87697: PUSH
87698: EMPTY
87699: LIST
87700: LIST
87701: PUSH
87702: LD_INT 1
87704: NEG
87705: PUSH
87706: LD_INT 1
87708: NEG
87709: PUSH
87710: EMPTY
87711: LIST
87712: LIST
87713: PUSH
87714: LD_INT 1
87716: NEG
87717: PUSH
87718: LD_INT 2
87720: NEG
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 0
87728: PUSH
87729: LD_INT 2
87731: NEG
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: PUSH
87737: LD_INT 1
87739: PUSH
87740: LD_INT 1
87742: NEG
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: PUSH
87748: LD_INT 2
87750: PUSH
87751: LD_INT 0
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: PUSH
87758: LD_INT 2
87760: PUSH
87761: LD_INT 1
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 2
87770: PUSH
87771: LD_INT 2
87773: PUSH
87774: EMPTY
87775: LIST
87776: LIST
87777: PUSH
87778: LD_INT 1
87780: PUSH
87781: LD_INT 2
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: PUSH
87788: LD_INT 0
87790: PUSH
87791: LD_INT 2
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: PUSH
87798: LD_INT 1
87800: NEG
87801: PUSH
87802: LD_INT 1
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: LD_INT 2
87811: NEG
87812: PUSH
87813: LD_INT 0
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PUSH
87820: LD_INT 2
87822: NEG
87823: PUSH
87824: LD_INT 1
87826: NEG
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: PUSH
87832: LD_INT 2
87834: NEG
87835: PUSH
87836: LD_INT 2
87838: NEG
87839: PUSH
87840: EMPTY
87841: LIST
87842: LIST
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87865: LD_ADDR_VAR 0 56
87869: PUSH
87870: LD_INT 0
87872: PUSH
87873: LD_INT 0
87875: PUSH
87876: EMPTY
87877: LIST
87878: LIST
87879: PUSH
87880: LD_INT 0
87882: PUSH
87883: LD_INT 1
87885: NEG
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 1
87893: PUSH
87894: LD_INT 0
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: LD_INT 1
87903: PUSH
87904: LD_INT 1
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: PUSH
87911: LD_INT 0
87913: PUSH
87914: LD_INT 1
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: LD_INT 1
87923: NEG
87924: PUSH
87925: LD_INT 0
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 1
87934: NEG
87935: PUSH
87936: LD_INT 1
87938: NEG
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 1
87946: NEG
87947: PUSH
87948: LD_INT 2
87950: NEG
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 0
87958: PUSH
87959: LD_INT 2
87961: NEG
87962: PUSH
87963: EMPTY
87964: LIST
87965: LIST
87966: PUSH
87967: LD_INT 1
87969: PUSH
87970: LD_INT 1
87972: NEG
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 2
87980: PUSH
87981: LD_INT 0
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 2
87990: PUSH
87991: LD_INT 1
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 2
88000: PUSH
88001: LD_INT 2
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 1
88010: PUSH
88011: LD_INT 2
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 0
88020: PUSH
88021: LD_INT 2
88023: PUSH
88024: EMPTY
88025: LIST
88026: LIST
88027: PUSH
88028: LD_INT 1
88030: NEG
88031: PUSH
88032: LD_INT 1
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: LD_INT 2
88041: NEG
88042: PUSH
88043: LD_INT 0
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PUSH
88050: LD_INT 2
88052: NEG
88053: PUSH
88054: LD_INT 1
88056: NEG
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: PUSH
88062: LD_INT 2
88064: NEG
88065: PUSH
88066: LD_INT 2
88068: NEG
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88095: LD_ADDR_VAR 0 57
88099: PUSH
88100: LD_INT 0
88102: PUSH
88103: LD_INT 0
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 0
88112: PUSH
88113: LD_INT 1
88115: NEG
88116: PUSH
88117: EMPTY
88118: LIST
88119: LIST
88120: PUSH
88121: LD_INT 1
88123: PUSH
88124: LD_INT 0
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PUSH
88131: LD_INT 1
88133: PUSH
88134: LD_INT 1
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 0
88143: PUSH
88144: LD_INT 1
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: LD_INT 1
88153: NEG
88154: PUSH
88155: LD_INT 0
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 1
88164: NEG
88165: PUSH
88166: LD_INT 1
88168: NEG
88169: PUSH
88170: EMPTY
88171: LIST
88172: LIST
88173: PUSH
88174: LD_INT 1
88176: NEG
88177: PUSH
88178: LD_INT 2
88180: NEG
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: LD_INT 2
88191: NEG
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: PUSH
88197: LD_INT 1
88199: PUSH
88200: LD_INT 1
88202: NEG
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: PUSH
88208: LD_INT 2
88210: PUSH
88211: LD_INT 0
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 2
88220: PUSH
88221: LD_INT 1
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 2
88230: PUSH
88231: LD_INT 2
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: PUSH
88238: LD_INT 1
88240: PUSH
88241: LD_INT 2
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 0
88250: PUSH
88251: LD_INT 2
88253: PUSH
88254: EMPTY
88255: LIST
88256: LIST
88257: PUSH
88258: LD_INT 1
88260: NEG
88261: PUSH
88262: LD_INT 1
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 2
88271: NEG
88272: PUSH
88273: LD_INT 0
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 2
88282: NEG
88283: PUSH
88284: LD_INT 1
88286: NEG
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 2
88294: NEG
88295: PUSH
88296: LD_INT 2
88298: NEG
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88325: LD_ADDR_VAR 0 58
88329: PUSH
88330: LD_INT 0
88332: PUSH
88333: LD_INT 0
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: PUSH
88340: LD_INT 0
88342: PUSH
88343: LD_INT 1
88345: NEG
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 1
88353: PUSH
88354: LD_INT 0
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: PUSH
88361: LD_INT 1
88363: PUSH
88364: LD_INT 1
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: PUSH
88371: LD_INT 0
88373: PUSH
88374: LD_INT 1
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: PUSH
88381: LD_INT 1
88383: NEG
88384: PUSH
88385: LD_INT 0
88387: PUSH
88388: EMPTY
88389: LIST
88390: LIST
88391: PUSH
88392: LD_INT 1
88394: NEG
88395: PUSH
88396: LD_INT 1
88398: NEG
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 1
88406: NEG
88407: PUSH
88408: LD_INT 2
88410: NEG
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 0
88418: PUSH
88419: LD_INT 2
88421: NEG
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: LD_INT 1
88429: PUSH
88430: LD_INT 1
88432: NEG
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: PUSH
88438: LD_INT 2
88440: PUSH
88441: LD_INT 0
88443: PUSH
88444: EMPTY
88445: LIST
88446: LIST
88447: PUSH
88448: LD_INT 2
88450: PUSH
88451: LD_INT 1
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PUSH
88458: LD_INT 2
88460: PUSH
88461: LD_INT 2
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PUSH
88468: LD_INT 1
88470: PUSH
88471: LD_INT 2
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: LD_INT 2
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 1
88490: NEG
88491: PUSH
88492: LD_INT 1
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: PUSH
88499: LD_INT 2
88501: NEG
88502: PUSH
88503: LD_INT 0
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 2
88512: NEG
88513: PUSH
88514: LD_INT 1
88516: NEG
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 2
88524: NEG
88525: PUSH
88526: LD_INT 2
88528: NEG
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88555: LD_ADDR_VAR 0 59
88559: PUSH
88560: LD_INT 0
88562: PUSH
88563: LD_INT 0
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 0
88572: PUSH
88573: LD_INT 1
88575: NEG
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 1
88583: PUSH
88584: LD_INT 0
88586: PUSH
88587: EMPTY
88588: LIST
88589: LIST
88590: PUSH
88591: LD_INT 1
88593: PUSH
88594: LD_INT 1
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: LD_INT 0
88603: PUSH
88604: LD_INT 1
88606: PUSH
88607: EMPTY
88608: LIST
88609: LIST
88610: PUSH
88611: LD_INT 1
88613: NEG
88614: PUSH
88615: LD_INT 0
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: PUSH
88622: LD_INT 1
88624: NEG
88625: PUSH
88626: LD_INT 1
88628: NEG
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88643: LD_ADDR_VAR 0 60
88647: PUSH
88648: LD_INT 0
88650: PUSH
88651: LD_INT 0
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: PUSH
88658: LD_INT 0
88660: PUSH
88661: LD_INT 1
88663: NEG
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: PUSH
88669: LD_INT 1
88671: PUSH
88672: LD_INT 0
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PUSH
88679: LD_INT 1
88681: PUSH
88682: LD_INT 1
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 0
88691: PUSH
88692: LD_INT 1
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 1
88701: NEG
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 1
88712: NEG
88713: PUSH
88714: LD_INT 1
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88731: LD_ADDR_VAR 0 61
88735: PUSH
88736: LD_INT 0
88738: PUSH
88739: LD_INT 0
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: PUSH
88746: LD_INT 0
88748: PUSH
88749: LD_INT 1
88751: NEG
88752: PUSH
88753: EMPTY
88754: LIST
88755: LIST
88756: PUSH
88757: LD_INT 1
88759: PUSH
88760: LD_INT 0
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 1
88769: PUSH
88770: LD_INT 1
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 0
88779: PUSH
88780: LD_INT 1
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 1
88789: NEG
88790: PUSH
88791: LD_INT 0
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 1
88800: NEG
88801: PUSH
88802: LD_INT 1
88804: NEG
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88819: LD_ADDR_VAR 0 62
88823: PUSH
88824: LD_INT 0
88826: PUSH
88827: LD_INT 0
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 0
88836: PUSH
88837: LD_INT 1
88839: NEG
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: PUSH
88845: LD_INT 1
88847: PUSH
88848: LD_INT 0
88850: PUSH
88851: EMPTY
88852: LIST
88853: LIST
88854: PUSH
88855: LD_INT 1
88857: PUSH
88858: LD_INT 1
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: LD_INT 0
88867: PUSH
88868: LD_INT 1
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 1
88877: NEG
88878: PUSH
88879: LD_INT 0
88881: PUSH
88882: EMPTY
88883: LIST
88884: LIST
88885: PUSH
88886: LD_INT 1
88888: NEG
88889: PUSH
88890: LD_INT 1
88892: NEG
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88907: LD_ADDR_VAR 0 63
88911: PUSH
88912: LD_INT 0
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: PUSH
88922: LD_INT 0
88924: PUSH
88925: LD_INT 1
88927: NEG
88928: PUSH
88929: EMPTY
88930: LIST
88931: LIST
88932: PUSH
88933: LD_INT 1
88935: PUSH
88936: LD_INT 0
88938: PUSH
88939: EMPTY
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 1
88945: PUSH
88946: LD_INT 1
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: PUSH
88953: LD_INT 0
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: PUSH
88963: LD_INT 1
88965: NEG
88966: PUSH
88967: LD_INT 0
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 1
88976: NEG
88977: PUSH
88978: LD_INT 1
88980: NEG
88981: PUSH
88982: EMPTY
88983: LIST
88984: LIST
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88995: LD_ADDR_VAR 0 64
88999: PUSH
89000: LD_INT 0
89002: PUSH
89003: LD_INT 0
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 0
89012: PUSH
89013: LD_INT 1
89015: NEG
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 1
89023: PUSH
89024: LD_INT 0
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PUSH
89031: LD_INT 1
89033: PUSH
89034: LD_INT 1
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 0
89043: PUSH
89044: LD_INT 1
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PUSH
89051: LD_INT 1
89053: NEG
89054: PUSH
89055: LD_INT 0
89057: PUSH
89058: EMPTY
89059: LIST
89060: LIST
89061: PUSH
89062: LD_INT 1
89064: NEG
89065: PUSH
89066: LD_INT 1
89068: NEG
89069: PUSH
89070: EMPTY
89071: LIST
89072: LIST
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: ST_TO_ADDR
// end ; 1 :
89083: GO 94980
89085: LD_INT 1
89087: DOUBLE
89088: EQUAL
89089: IFTRUE 89093
89091: GO 91716
89093: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89094: LD_ADDR_VAR 0 11
89098: PUSH
89099: LD_INT 1
89101: NEG
89102: PUSH
89103: LD_INT 3
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 0
89113: PUSH
89114: LD_INT 3
89116: NEG
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: PUSH
89122: LD_INT 1
89124: PUSH
89125: LD_INT 2
89127: NEG
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: LIST
89137: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89138: LD_ADDR_VAR 0 12
89142: PUSH
89143: LD_INT 2
89145: PUSH
89146: LD_INT 1
89148: NEG
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 3
89156: PUSH
89157: LD_INT 0
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 3
89166: PUSH
89167: LD_INT 1
89169: PUSH
89170: EMPTY
89171: LIST
89172: LIST
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: LIST
89178: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89179: LD_ADDR_VAR 0 13
89183: PUSH
89184: LD_INT 3
89186: PUSH
89187: LD_INT 2
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 3
89196: PUSH
89197: LD_INT 3
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: LD_INT 2
89206: PUSH
89207: LD_INT 3
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: LIST
89218: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89219: LD_ADDR_VAR 0 14
89223: PUSH
89224: LD_INT 1
89226: PUSH
89227: LD_INT 3
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: LD_INT 3
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 1
89246: NEG
89247: PUSH
89248: LD_INT 2
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: LIST
89259: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89260: LD_ADDR_VAR 0 15
89264: PUSH
89265: LD_INT 2
89267: NEG
89268: PUSH
89269: LD_INT 1
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 3
89278: NEG
89279: PUSH
89280: LD_INT 0
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 3
89289: NEG
89290: PUSH
89291: LD_INT 1
89293: NEG
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: LIST
89303: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89304: LD_ADDR_VAR 0 16
89308: PUSH
89309: LD_INT 2
89311: NEG
89312: PUSH
89313: LD_INT 3
89315: NEG
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: PUSH
89321: LD_INT 3
89323: NEG
89324: PUSH
89325: LD_INT 2
89327: NEG
89328: PUSH
89329: EMPTY
89330: LIST
89331: LIST
89332: PUSH
89333: LD_INT 3
89335: NEG
89336: PUSH
89337: LD_INT 3
89339: NEG
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: LIST
89349: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89350: LD_ADDR_VAR 0 17
89354: PUSH
89355: LD_INT 1
89357: NEG
89358: PUSH
89359: LD_INT 3
89361: NEG
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 0
89369: PUSH
89370: LD_INT 3
89372: NEG
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 1
89380: PUSH
89381: LD_INT 2
89383: NEG
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: LIST
89393: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89394: LD_ADDR_VAR 0 18
89398: PUSH
89399: LD_INT 2
89401: PUSH
89402: LD_INT 1
89404: NEG
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: LD_INT 3
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 3
89422: PUSH
89423: LD_INT 1
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: LIST
89434: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89435: LD_ADDR_VAR 0 19
89439: PUSH
89440: LD_INT 3
89442: PUSH
89443: LD_INT 2
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: PUSH
89450: LD_INT 3
89452: PUSH
89453: LD_INT 3
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 2
89462: PUSH
89463: LD_INT 3
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: LIST
89474: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89475: LD_ADDR_VAR 0 20
89479: PUSH
89480: LD_INT 1
89482: PUSH
89483: LD_INT 3
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 0
89492: PUSH
89493: LD_INT 3
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 1
89502: NEG
89503: PUSH
89504: LD_INT 2
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: LIST
89515: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89516: LD_ADDR_VAR 0 21
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: LD_INT 1
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 3
89534: NEG
89535: PUSH
89536: LD_INT 0
89538: PUSH
89539: EMPTY
89540: LIST
89541: LIST
89542: PUSH
89543: LD_INT 3
89545: NEG
89546: PUSH
89547: LD_INT 1
89549: NEG
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: LIST
89559: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89560: LD_ADDR_VAR 0 22
89564: PUSH
89565: LD_INT 2
89567: NEG
89568: PUSH
89569: LD_INT 3
89571: NEG
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: PUSH
89577: LD_INT 3
89579: NEG
89580: PUSH
89581: LD_INT 2
89583: NEG
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 3
89591: NEG
89592: PUSH
89593: LD_INT 3
89595: NEG
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: LIST
89605: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
89606: LD_ADDR_VAR 0 23
89610: PUSH
89611: LD_INT 0
89613: PUSH
89614: LD_INT 3
89616: NEG
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 1
89624: NEG
89625: PUSH
89626: LD_INT 4
89628: NEG
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 1
89636: PUSH
89637: LD_INT 3
89639: NEG
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: LIST
89649: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
89650: LD_ADDR_VAR 0 24
89654: PUSH
89655: LD_INT 3
89657: PUSH
89658: LD_INT 0
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: PUSH
89665: LD_INT 3
89667: PUSH
89668: LD_INT 1
89670: NEG
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 4
89678: PUSH
89679: LD_INT 1
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: LIST
89690: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
89691: LD_ADDR_VAR 0 25
89695: PUSH
89696: LD_INT 3
89698: PUSH
89699: LD_INT 3
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 4
89708: PUSH
89709: LD_INT 3
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: PUSH
89716: LD_INT 3
89718: PUSH
89719: LD_INT 4
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: LIST
89730: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
89731: LD_ADDR_VAR 0 26
89735: PUSH
89736: LD_INT 0
89738: PUSH
89739: LD_INT 3
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: PUSH
89746: LD_INT 1
89748: PUSH
89749: LD_INT 4
89751: PUSH
89752: EMPTY
89753: LIST
89754: LIST
89755: PUSH
89756: LD_INT 1
89758: NEG
89759: PUSH
89760: LD_INT 3
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: LIST
89771: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89772: LD_ADDR_VAR 0 27
89776: PUSH
89777: LD_INT 3
89779: NEG
89780: PUSH
89781: LD_INT 0
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PUSH
89788: LD_INT 3
89790: NEG
89791: PUSH
89792: LD_INT 1
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 4
89801: NEG
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: LIST
89815: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
89816: LD_ADDR_VAR 0 28
89820: PUSH
89821: LD_INT 3
89823: NEG
89824: PUSH
89825: LD_INT 3
89827: NEG
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 3
89835: NEG
89836: PUSH
89837: LD_INT 4
89839: NEG
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 4
89847: NEG
89848: PUSH
89849: LD_INT 3
89851: NEG
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: LIST
89861: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
89862: LD_ADDR_VAR 0 29
89866: PUSH
89867: LD_INT 1
89869: NEG
89870: PUSH
89871: LD_INT 3
89873: NEG
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 0
89881: PUSH
89882: LD_INT 3
89884: NEG
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: PUSH
89890: LD_INT 1
89892: PUSH
89893: LD_INT 2
89895: NEG
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: LD_INT 1
89903: NEG
89904: PUSH
89905: LD_INT 4
89907: NEG
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 0
89915: PUSH
89916: LD_INT 4
89918: NEG
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 1
89926: PUSH
89927: LD_INT 3
89929: NEG
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 1
89937: NEG
89938: PUSH
89939: LD_INT 5
89941: NEG
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 0
89949: PUSH
89950: LD_INT 5
89952: NEG
89953: PUSH
89954: EMPTY
89955: LIST
89956: LIST
89957: PUSH
89958: LD_INT 1
89960: PUSH
89961: LD_INT 4
89963: NEG
89964: PUSH
89965: EMPTY
89966: LIST
89967: LIST
89968: PUSH
89969: LD_INT 1
89971: NEG
89972: PUSH
89973: LD_INT 6
89975: NEG
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: LD_INT 0
89983: PUSH
89984: LD_INT 6
89986: NEG
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: PUSH
89995: LD_INT 5
89997: NEG
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90017: LD_ADDR_VAR 0 30
90021: PUSH
90022: LD_INT 2
90024: PUSH
90025: LD_INT 1
90027: NEG
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 3
90035: PUSH
90036: LD_INT 0
90038: PUSH
90039: EMPTY
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 3
90045: PUSH
90046: LD_INT 1
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 3
90055: PUSH
90056: LD_INT 1
90058: NEG
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: LD_INT 4
90066: PUSH
90067: LD_INT 0
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 4
90076: PUSH
90077: LD_INT 1
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 4
90086: PUSH
90087: LD_INT 1
90089: NEG
90090: PUSH
90091: EMPTY
90092: LIST
90093: LIST
90094: PUSH
90095: LD_INT 5
90097: PUSH
90098: LD_INT 0
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 5
90107: PUSH
90108: LD_INT 1
90110: PUSH
90111: EMPTY
90112: LIST
90113: LIST
90114: PUSH
90115: LD_INT 5
90117: PUSH
90118: LD_INT 1
90120: NEG
90121: PUSH
90122: EMPTY
90123: LIST
90124: LIST
90125: PUSH
90126: LD_INT 6
90128: PUSH
90129: LD_INT 0
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PUSH
90136: LD_INT 6
90138: PUSH
90139: LD_INT 1
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90160: LD_ADDR_VAR 0 31
90164: PUSH
90165: LD_INT 3
90167: PUSH
90168: LD_INT 2
90170: PUSH
90171: EMPTY
90172: LIST
90173: LIST
90174: PUSH
90175: LD_INT 3
90177: PUSH
90178: LD_INT 3
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: PUSH
90185: LD_INT 2
90187: PUSH
90188: LD_INT 3
90190: PUSH
90191: EMPTY
90192: LIST
90193: LIST
90194: PUSH
90195: LD_INT 4
90197: PUSH
90198: LD_INT 3
90200: PUSH
90201: EMPTY
90202: LIST
90203: LIST
90204: PUSH
90205: LD_INT 4
90207: PUSH
90208: LD_INT 4
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 3
90217: PUSH
90218: LD_INT 4
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PUSH
90225: LD_INT 5
90227: PUSH
90228: LD_INT 4
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 5
90237: PUSH
90238: LD_INT 5
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 4
90247: PUSH
90248: LD_INT 5
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: LD_INT 6
90257: PUSH
90258: LD_INT 5
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 6
90267: PUSH
90268: LD_INT 6
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: LD_INT 5
90277: PUSH
90278: LD_INT 6
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90299: LD_ADDR_VAR 0 32
90303: PUSH
90304: LD_INT 1
90306: PUSH
90307: LD_INT 3
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 0
90316: PUSH
90317: LD_INT 3
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: PUSH
90324: LD_INT 1
90326: NEG
90327: PUSH
90328: LD_INT 2
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: LD_INT 1
90337: PUSH
90338: LD_INT 4
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: LD_INT 4
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: LD_INT 1
90357: NEG
90358: PUSH
90359: LD_INT 3
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 1
90368: PUSH
90369: LD_INT 5
90371: PUSH
90372: EMPTY
90373: LIST
90374: LIST
90375: PUSH
90376: LD_INT 0
90378: PUSH
90379: LD_INT 5
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 1
90388: NEG
90389: PUSH
90390: LD_INT 4
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 1
90399: PUSH
90400: LD_INT 6
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 0
90409: PUSH
90410: LD_INT 6
90412: PUSH
90413: EMPTY
90414: LIST
90415: LIST
90416: PUSH
90417: LD_INT 1
90419: NEG
90420: PUSH
90421: LD_INT 5
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
90442: LD_ADDR_VAR 0 33
90446: PUSH
90447: LD_INT 2
90449: NEG
90450: PUSH
90451: LD_INT 1
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: PUSH
90458: LD_INT 3
90460: NEG
90461: PUSH
90462: LD_INT 0
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 3
90471: NEG
90472: PUSH
90473: LD_INT 1
90475: NEG
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: LD_INT 3
90483: NEG
90484: PUSH
90485: LD_INT 1
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PUSH
90492: LD_INT 4
90494: NEG
90495: PUSH
90496: LD_INT 0
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 4
90505: NEG
90506: PUSH
90507: LD_INT 1
90509: NEG
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PUSH
90515: LD_INT 4
90517: NEG
90518: PUSH
90519: LD_INT 1
90521: PUSH
90522: EMPTY
90523: LIST
90524: LIST
90525: PUSH
90526: LD_INT 5
90528: NEG
90529: PUSH
90530: LD_INT 0
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 5
90539: NEG
90540: PUSH
90541: LD_INT 1
90543: NEG
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 5
90551: NEG
90552: PUSH
90553: LD_INT 1
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: LD_INT 6
90562: NEG
90563: PUSH
90564: LD_INT 0
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: LD_INT 6
90573: NEG
90574: PUSH
90575: LD_INT 1
90577: NEG
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
90597: LD_ADDR_VAR 0 34
90601: PUSH
90602: LD_INT 2
90604: NEG
90605: PUSH
90606: LD_INT 3
90608: NEG
90609: PUSH
90610: EMPTY
90611: LIST
90612: LIST
90613: PUSH
90614: LD_INT 3
90616: NEG
90617: PUSH
90618: LD_INT 2
90620: NEG
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 3
90628: NEG
90629: PUSH
90630: LD_INT 3
90632: NEG
90633: PUSH
90634: EMPTY
90635: LIST
90636: LIST
90637: PUSH
90638: LD_INT 3
90640: NEG
90641: PUSH
90642: LD_INT 4
90644: NEG
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 4
90652: NEG
90653: PUSH
90654: LD_INT 3
90656: NEG
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 4
90664: NEG
90665: PUSH
90666: LD_INT 4
90668: NEG
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 4
90676: NEG
90677: PUSH
90678: LD_INT 5
90680: NEG
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 5
90688: NEG
90689: PUSH
90690: LD_INT 4
90692: NEG
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 5
90700: NEG
90701: PUSH
90702: LD_INT 5
90704: NEG
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 5
90712: NEG
90713: PUSH
90714: LD_INT 6
90716: NEG
90717: PUSH
90718: EMPTY
90719: LIST
90720: LIST
90721: PUSH
90722: LD_INT 6
90724: NEG
90725: PUSH
90726: LD_INT 5
90728: NEG
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: LD_INT 6
90736: NEG
90737: PUSH
90738: LD_INT 6
90740: NEG
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90760: LD_ADDR_VAR 0 41
90764: PUSH
90765: LD_INT 0
90767: PUSH
90768: LD_INT 2
90770: NEG
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PUSH
90776: LD_INT 1
90778: NEG
90779: PUSH
90780: LD_INT 3
90782: NEG
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: LD_INT 1
90790: PUSH
90791: LD_INT 2
90793: NEG
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: LIST
90803: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
90804: LD_ADDR_VAR 0 42
90808: PUSH
90809: LD_INT 2
90811: PUSH
90812: LD_INT 0
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 2
90821: PUSH
90822: LD_INT 1
90824: NEG
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 3
90832: PUSH
90833: LD_INT 1
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: LIST
90844: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
90845: LD_ADDR_VAR 0 43
90849: PUSH
90850: LD_INT 2
90852: PUSH
90853: LD_INT 2
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 3
90862: PUSH
90863: LD_INT 2
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 2
90872: PUSH
90873: LD_INT 3
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: PUSH
90880: EMPTY
90881: LIST
90882: LIST
90883: LIST
90884: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
90885: LD_ADDR_VAR 0 44
90889: PUSH
90890: LD_INT 0
90892: PUSH
90893: LD_INT 2
90895: PUSH
90896: EMPTY
90897: LIST
90898: LIST
90899: PUSH
90900: LD_INT 1
90902: PUSH
90903: LD_INT 3
90905: PUSH
90906: EMPTY
90907: LIST
90908: LIST
90909: PUSH
90910: LD_INT 1
90912: NEG
90913: PUSH
90914: LD_INT 2
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: LIST
90925: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90926: LD_ADDR_VAR 0 45
90930: PUSH
90931: LD_INT 2
90933: NEG
90934: PUSH
90935: LD_INT 0
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 2
90944: NEG
90945: PUSH
90946: LD_INT 1
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: LD_INT 3
90955: NEG
90956: PUSH
90957: LD_INT 1
90959: NEG
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: LIST
90969: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
90970: LD_ADDR_VAR 0 46
90974: PUSH
90975: LD_INT 2
90977: NEG
90978: PUSH
90979: LD_INT 2
90981: NEG
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 2
90989: NEG
90990: PUSH
90991: LD_INT 3
90993: NEG
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 3
91001: NEG
91002: PUSH
91003: LD_INT 2
91005: NEG
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: LIST
91015: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91016: LD_ADDR_VAR 0 47
91020: PUSH
91021: LD_INT 2
91023: NEG
91024: PUSH
91025: LD_INT 3
91027: NEG
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 1
91035: NEG
91036: PUSH
91037: LD_INT 3
91039: NEG
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91049: LD_ADDR_VAR 0 48
91053: PUSH
91054: LD_INT 1
91056: PUSH
91057: LD_INT 2
91059: NEG
91060: PUSH
91061: EMPTY
91062: LIST
91063: LIST
91064: PUSH
91065: LD_INT 2
91067: PUSH
91068: LD_INT 1
91070: NEG
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91080: LD_ADDR_VAR 0 49
91084: PUSH
91085: LD_INT 3
91087: PUSH
91088: LD_INT 1
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: PUSH
91095: LD_INT 3
91097: PUSH
91098: LD_INT 2
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91109: LD_ADDR_VAR 0 50
91113: PUSH
91114: LD_INT 2
91116: PUSH
91117: LD_INT 3
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: LD_INT 1
91126: PUSH
91127: LD_INT 3
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91138: LD_ADDR_VAR 0 51
91142: PUSH
91143: LD_INT 1
91145: NEG
91146: PUSH
91147: LD_INT 2
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: LD_INT 2
91156: NEG
91157: PUSH
91158: LD_INT 1
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91169: LD_ADDR_VAR 0 52
91173: PUSH
91174: LD_INT 3
91176: NEG
91177: PUSH
91178: LD_INT 1
91180: NEG
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 3
91188: NEG
91189: PUSH
91190: LD_INT 2
91192: NEG
91193: PUSH
91194: EMPTY
91195: LIST
91196: LIST
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91202: LD_ADDR_VAR 0 53
91206: PUSH
91207: LD_INT 1
91209: NEG
91210: PUSH
91211: LD_INT 3
91213: NEG
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 0
91221: PUSH
91222: LD_INT 3
91224: NEG
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 1
91232: PUSH
91233: LD_INT 2
91235: NEG
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: LIST
91245: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91246: LD_ADDR_VAR 0 54
91250: PUSH
91251: LD_INT 2
91253: PUSH
91254: LD_INT 1
91256: NEG
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 3
91264: PUSH
91265: LD_INT 0
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 3
91274: PUSH
91275: LD_INT 1
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: PUSH
91282: EMPTY
91283: LIST
91284: LIST
91285: LIST
91286: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91287: LD_ADDR_VAR 0 55
91291: PUSH
91292: LD_INT 3
91294: PUSH
91295: LD_INT 2
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 3
91304: PUSH
91305: LD_INT 3
91307: PUSH
91308: EMPTY
91309: LIST
91310: LIST
91311: PUSH
91312: LD_INT 2
91314: PUSH
91315: LD_INT 3
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: LIST
91326: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91327: LD_ADDR_VAR 0 56
91331: PUSH
91332: LD_INT 1
91334: PUSH
91335: LD_INT 3
91337: PUSH
91338: EMPTY
91339: LIST
91340: LIST
91341: PUSH
91342: LD_INT 0
91344: PUSH
91345: LD_INT 3
91347: PUSH
91348: EMPTY
91349: LIST
91350: LIST
91351: PUSH
91352: LD_INT 1
91354: NEG
91355: PUSH
91356: LD_INT 2
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: LIST
91367: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91368: LD_ADDR_VAR 0 57
91372: PUSH
91373: LD_INT 2
91375: NEG
91376: PUSH
91377: LD_INT 1
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: PUSH
91384: LD_INT 3
91386: NEG
91387: PUSH
91388: LD_INT 0
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 3
91397: NEG
91398: PUSH
91399: LD_INT 1
91401: NEG
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: EMPTY
91408: LIST
91409: LIST
91410: LIST
91411: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91412: LD_ADDR_VAR 0 58
91416: PUSH
91417: LD_INT 2
91419: NEG
91420: PUSH
91421: LD_INT 3
91423: NEG
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 3
91431: NEG
91432: PUSH
91433: LD_INT 2
91435: NEG
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: PUSH
91441: LD_INT 3
91443: NEG
91444: PUSH
91445: LD_INT 3
91447: NEG
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: LIST
91457: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
91458: LD_ADDR_VAR 0 59
91462: PUSH
91463: LD_INT 1
91465: NEG
91466: PUSH
91467: LD_INT 2
91469: NEG
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 0
91477: PUSH
91478: LD_INT 2
91480: NEG
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 1
91488: PUSH
91489: LD_INT 1
91491: NEG
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: LIST
91501: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91502: LD_ADDR_VAR 0 60
91506: PUSH
91507: LD_INT 1
91509: PUSH
91510: LD_INT 1
91512: NEG
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PUSH
91518: LD_INT 2
91520: PUSH
91521: LD_INT 0
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 2
91530: PUSH
91531: LD_INT 1
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: PUSH
91538: EMPTY
91539: LIST
91540: LIST
91541: LIST
91542: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91543: LD_ADDR_VAR 0 61
91547: PUSH
91548: LD_INT 2
91550: PUSH
91551: LD_INT 1
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: PUSH
91558: LD_INT 2
91560: PUSH
91561: LD_INT 2
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 1
91570: PUSH
91571: LD_INT 2
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: LIST
91582: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91583: LD_ADDR_VAR 0 62
91587: PUSH
91588: LD_INT 1
91590: PUSH
91591: LD_INT 2
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: PUSH
91598: LD_INT 0
91600: PUSH
91601: LD_INT 2
91603: PUSH
91604: EMPTY
91605: LIST
91606: LIST
91607: PUSH
91608: LD_INT 1
91610: NEG
91611: PUSH
91612: LD_INT 1
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: LIST
91623: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91624: LD_ADDR_VAR 0 63
91628: PUSH
91629: LD_INT 1
91631: NEG
91632: PUSH
91633: LD_INT 1
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 2
91642: NEG
91643: PUSH
91644: LD_INT 0
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 2
91653: NEG
91654: PUSH
91655: LD_INT 1
91657: NEG
91658: PUSH
91659: EMPTY
91660: LIST
91661: LIST
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: LIST
91667: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91668: LD_ADDR_VAR 0 64
91672: PUSH
91673: LD_INT 1
91675: NEG
91676: PUSH
91677: LD_INT 2
91679: NEG
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: LD_INT 2
91687: NEG
91688: PUSH
91689: LD_INT 1
91691: NEG
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PUSH
91697: LD_INT 2
91699: NEG
91700: PUSH
91701: LD_INT 2
91703: NEG
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: LIST
91713: ST_TO_ADDR
// end ; 2 :
91714: GO 94980
91716: LD_INT 2
91718: DOUBLE
91719: EQUAL
91720: IFTRUE 91724
91722: GO 94979
91724: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
91725: LD_ADDR_VAR 0 29
91729: PUSH
91730: LD_INT 4
91732: PUSH
91733: LD_INT 0
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 4
91742: PUSH
91743: LD_INT 1
91745: NEG
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 5
91753: PUSH
91754: LD_INT 0
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: PUSH
91761: LD_INT 5
91763: PUSH
91764: LD_INT 1
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: PUSH
91771: LD_INT 4
91773: PUSH
91774: LD_INT 1
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: PUSH
91781: LD_INT 3
91783: PUSH
91784: LD_INT 0
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: PUSH
91791: LD_INT 3
91793: PUSH
91794: LD_INT 1
91796: NEG
91797: PUSH
91798: EMPTY
91799: LIST
91800: LIST
91801: PUSH
91802: LD_INT 3
91804: PUSH
91805: LD_INT 2
91807: NEG
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: PUSH
91813: LD_INT 5
91815: PUSH
91816: LD_INT 2
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 3
91825: PUSH
91826: LD_INT 3
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: LD_INT 3
91835: PUSH
91836: LD_INT 2
91838: PUSH
91839: EMPTY
91840: LIST
91841: LIST
91842: PUSH
91843: LD_INT 4
91845: PUSH
91846: LD_INT 3
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: PUSH
91853: LD_INT 4
91855: PUSH
91856: LD_INT 4
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: PUSH
91863: LD_INT 3
91865: PUSH
91866: LD_INT 4
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 2
91875: PUSH
91876: LD_INT 3
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 2
91885: PUSH
91886: LD_INT 2
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PUSH
91893: LD_INT 4
91895: PUSH
91896: LD_INT 2
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 2
91905: PUSH
91906: LD_INT 4
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: LD_INT 0
91915: PUSH
91916: LD_INT 4
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: LD_INT 0
91925: PUSH
91926: LD_INT 3
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PUSH
91933: LD_INT 1
91935: PUSH
91936: LD_INT 4
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 1
91945: PUSH
91946: LD_INT 5
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 0
91955: PUSH
91956: LD_INT 5
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 1
91965: NEG
91966: PUSH
91967: LD_INT 4
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: LD_INT 1
91976: NEG
91977: PUSH
91978: LD_INT 3
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: PUSH
91985: LD_INT 2
91987: PUSH
91988: LD_INT 5
91990: PUSH
91991: EMPTY
91992: LIST
91993: LIST
91994: PUSH
91995: LD_INT 2
91997: NEG
91998: PUSH
91999: LD_INT 3
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: PUSH
92006: LD_INT 3
92008: NEG
92009: PUSH
92010: LD_INT 0
92012: PUSH
92013: EMPTY
92014: LIST
92015: LIST
92016: PUSH
92017: LD_INT 3
92019: NEG
92020: PUSH
92021: LD_INT 1
92023: NEG
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 2
92031: NEG
92032: PUSH
92033: LD_INT 0
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 2
92042: NEG
92043: PUSH
92044: LD_INT 1
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 3
92053: NEG
92054: PUSH
92055: LD_INT 1
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: PUSH
92062: LD_INT 4
92064: NEG
92065: PUSH
92066: LD_INT 0
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: PUSH
92073: LD_INT 4
92075: NEG
92076: PUSH
92077: LD_INT 1
92079: NEG
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 4
92087: NEG
92088: PUSH
92089: LD_INT 2
92091: NEG
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 2
92099: NEG
92100: PUSH
92101: LD_INT 2
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 4
92110: NEG
92111: PUSH
92112: LD_INT 4
92114: NEG
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: LD_INT 4
92122: NEG
92123: PUSH
92124: LD_INT 5
92126: NEG
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: PUSH
92132: LD_INT 3
92134: NEG
92135: PUSH
92136: LD_INT 4
92138: NEG
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 3
92146: NEG
92147: PUSH
92148: LD_INT 3
92150: NEG
92151: PUSH
92152: EMPTY
92153: LIST
92154: LIST
92155: PUSH
92156: LD_INT 4
92158: NEG
92159: PUSH
92160: LD_INT 3
92162: NEG
92163: PUSH
92164: EMPTY
92165: LIST
92166: LIST
92167: PUSH
92168: LD_INT 5
92170: NEG
92171: PUSH
92172: LD_INT 4
92174: NEG
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 5
92182: NEG
92183: PUSH
92184: LD_INT 5
92186: NEG
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 3
92194: NEG
92195: PUSH
92196: LD_INT 5
92198: NEG
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 5
92206: NEG
92207: PUSH
92208: LD_INT 3
92210: NEG
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: PUSH
92216: EMPTY
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92263: LD_ADDR_VAR 0 30
92267: PUSH
92268: LD_INT 4
92270: PUSH
92271: LD_INT 4
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 4
92280: PUSH
92281: LD_INT 3
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 5
92290: PUSH
92291: LD_INT 4
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: LD_INT 5
92300: PUSH
92301: LD_INT 5
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 4
92310: PUSH
92311: LD_INT 5
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: LD_INT 3
92320: PUSH
92321: LD_INT 4
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: PUSH
92328: LD_INT 3
92330: PUSH
92331: LD_INT 3
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: PUSH
92338: LD_INT 5
92340: PUSH
92341: LD_INT 3
92343: PUSH
92344: EMPTY
92345: LIST
92346: LIST
92347: PUSH
92348: LD_INT 3
92350: PUSH
92351: LD_INT 5
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: LD_INT 0
92360: PUSH
92361: LD_INT 3
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 0
92370: PUSH
92371: LD_INT 2
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: PUSH
92378: LD_INT 1
92380: PUSH
92381: LD_INT 3
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 1
92390: PUSH
92391: LD_INT 4
92393: PUSH
92394: EMPTY
92395: LIST
92396: LIST
92397: PUSH
92398: LD_INT 0
92400: PUSH
92401: LD_INT 4
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: PUSH
92408: LD_INT 1
92410: NEG
92411: PUSH
92412: LD_INT 3
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: PUSH
92419: LD_INT 1
92421: NEG
92422: PUSH
92423: LD_INT 2
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: PUSH
92430: LD_INT 2
92432: PUSH
92433: LD_INT 4
92435: PUSH
92436: EMPTY
92437: LIST
92438: LIST
92439: PUSH
92440: LD_INT 2
92442: NEG
92443: PUSH
92444: LD_INT 2
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 4
92453: NEG
92454: PUSH
92455: LD_INT 0
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 4
92464: NEG
92465: PUSH
92466: LD_INT 1
92468: NEG
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: PUSH
92474: LD_INT 3
92476: NEG
92477: PUSH
92478: LD_INT 0
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 3
92487: NEG
92488: PUSH
92489: LD_INT 1
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 4
92498: NEG
92499: PUSH
92500: LD_INT 1
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 5
92509: NEG
92510: PUSH
92511: LD_INT 0
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: LD_INT 5
92520: NEG
92521: PUSH
92522: LD_INT 1
92524: NEG
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 5
92532: NEG
92533: PUSH
92534: LD_INT 2
92536: NEG
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: PUSH
92542: LD_INT 3
92544: NEG
92545: PUSH
92546: LD_INT 2
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 3
92555: NEG
92556: PUSH
92557: LD_INT 3
92559: NEG
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: LD_INT 3
92567: NEG
92568: PUSH
92569: LD_INT 4
92571: NEG
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: LD_INT 2
92579: NEG
92580: PUSH
92581: LD_INT 3
92583: NEG
92584: PUSH
92585: EMPTY
92586: LIST
92587: LIST
92588: PUSH
92589: LD_INT 2
92591: NEG
92592: PUSH
92593: LD_INT 2
92595: NEG
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: LD_INT 3
92603: NEG
92604: PUSH
92605: LD_INT 2
92607: NEG
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PUSH
92613: LD_INT 4
92615: NEG
92616: PUSH
92617: LD_INT 3
92619: NEG
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 4
92627: NEG
92628: PUSH
92629: LD_INT 4
92631: NEG
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: LD_INT 2
92639: NEG
92640: PUSH
92641: LD_INT 4
92643: NEG
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: PUSH
92649: LD_INT 4
92651: NEG
92652: PUSH
92653: LD_INT 2
92655: NEG
92656: PUSH
92657: EMPTY
92658: LIST
92659: LIST
92660: PUSH
92661: LD_INT 0
92663: PUSH
92664: LD_INT 4
92666: NEG
92667: PUSH
92668: EMPTY
92669: LIST
92670: LIST
92671: PUSH
92672: LD_INT 0
92674: PUSH
92675: LD_INT 5
92677: NEG
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: PUSH
92683: LD_INT 1
92685: PUSH
92686: LD_INT 4
92688: NEG
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PUSH
92694: LD_INT 1
92696: PUSH
92697: LD_INT 3
92699: NEG
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 0
92707: PUSH
92708: LD_INT 3
92710: NEG
92711: PUSH
92712: EMPTY
92713: LIST
92714: LIST
92715: PUSH
92716: LD_INT 1
92718: NEG
92719: PUSH
92720: LD_INT 4
92722: NEG
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 1
92730: NEG
92731: PUSH
92732: LD_INT 5
92734: NEG
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: PUSH
92740: LD_INT 2
92742: PUSH
92743: LD_INT 3
92745: NEG
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: PUSH
92751: LD_INT 2
92753: NEG
92754: PUSH
92755: LD_INT 5
92757: NEG
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: EMPTY
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
92810: LD_ADDR_VAR 0 31
92814: PUSH
92815: LD_INT 0
92817: PUSH
92818: LD_INT 4
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 0
92827: PUSH
92828: LD_INT 3
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: LD_INT 1
92837: PUSH
92838: LD_INT 4
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 1
92847: PUSH
92848: LD_INT 5
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 0
92857: PUSH
92858: LD_INT 5
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: LD_INT 1
92867: NEG
92868: PUSH
92869: LD_INT 4
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: PUSH
92876: LD_INT 1
92878: NEG
92879: PUSH
92880: LD_INT 3
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: PUSH
92887: LD_INT 2
92889: PUSH
92890: LD_INT 5
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 2
92899: NEG
92900: PUSH
92901: LD_INT 3
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 3
92910: NEG
92911: PUSH
92912: LD_INT 0
92914: PUSH
92915: EMPTY
92916: LIST
92917: LIST
92918: PUSH
92919: LD_INT 3
92921: NEG
92922: PUSH
92923: LD_INT 1
92925: NEG
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 2
92933: NEG
92934: PUSH
92935: LD_INT 0
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: PUSH
92942: LD_INT 2
92944: NEG
92945: PUSH
92946: LD_INT 1
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 3
92955: NEG
92956: PUSH
92957: LD_INT 1
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 4
92966: NEG
92967: PUSH
92968: LD_INT 0
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 4
92977: NEG
92978: PUSH
92979: LD_INT 1
92981: NEG
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 4
92989: NEG
92990: PUSH
92991: LD_INT 2
92993: NEG
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 2
93001: NEG
93002: PUSH
93003: LD_INT 2
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 4
93012: NEG
93013: PUSH
93014: LD_INT 4
93016: NEG
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 4
93024: NEG
93025: PUSH
93026: LD_INT 5
93028: NEG
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: PUSH
93034: LD_INT 3
93036: NEG
93037: PUSH
93038: LD_INT 4
93040: NEG
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 3
93048: NEG
93049: PUSH
93050: LD_INT 3
93052: NEG
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 4
93060: NEG
93061: PUSH
93062: LD_INT 3
93064: NEG
93065: PUSH
93066: EMPTY
93067: LIST
93068: LIST
93069: PUSH
93070: LD_INT 5
93072: NEG
93073: PUSH
93074: LD_INT 4
93076: NEG
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 5
93084: NEG
93085: PUSH
93086: LD_INT 5
93088: NEG
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 3
93096: NEG
93097: PUSH
93098: LD_INT 5
93100: NEG
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: LD_INT 5
93108: NEG
93109: PUSH
93110: LD_INT 3
93112: NEG
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: PUSH
93118: LD_INT 0
93120: PUSH
93121: LD_INT 3
93123: NEG
93124: PUSH
93125: EMPTY
93126: LIST
93127: LIST
93128: PUSH
93129: LD_INT 0
93131: PUSH
93132: LD_INT 4
93134: NEG
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: PUSH
93140: LD_INT 1
93142: PUSH
93143: LD_INT 3
93145: NEG
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 1
93153: PUSH
93154: LD_INT 2
93156: NEG
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: LD_INT 0
93164: PUSH
93165: LD_INT 2
93167: NEG
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_INT 1
93175: NEG
93176: PUSH
93177: LD_INT 3
93179: NEG
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 1
93187: NEG
93188: PUSH
93189: LD_INT 4
93191: NEG
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PUSH
93197: LD_INT 2
93199: PUSH
93200: LD_INT 2
93202: NEG
93203: PUSH
93204: EMPTY
93205: LIST
93206: LIST
93207: PUSH
93208: LD_INT 2
93210: NEG
93211: PUSH
93212: LD_INT 4
93214: NEG
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: LD_INT 4
93222: PUSH
93223: LD_INT 0
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PUSH
93230: LD_INT 4
93232: PUSH
93233: LD_INT 1
93235: NEG
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: PUSH
93241: LD_INT 5
93243: PUSH
93244: LD_INT 0
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: PUSH
93251: LD_INT 5
93253: PUSH
93254: LD_INT 1
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 4
93263: PUSH
93264: LD_INT 1
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: PUSH
93271: LD_INT 3
93273: PUSH
93274: LD_INT 0
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: LD_INT 3
93283: PUSH
93284: LD_INT 1
93286: NEG
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 3
93294: PUSH
93295: LD_INT 2
93297: NEG
93298: PUSH
93299: EMPTY
93300: LIST
93301: LIST
93302: PUSH
93303: LD_INT 5
93305: PUSH
93306: LD_INT 2
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93360: LD_ADDR_VAR 0 32
93364: PUSH
93365: LD_INT 4
93367: NEG
93368: PUSH
93369: LD_INT 0
93371: PUSH
93372: EMPTY
93373: LIST
93374: LIST
93375: PUSH
93376: LD_INT 4
93378: NEG
93379: PUSH
93380: LD_INT 1
93382: NEG
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 3
93390: NEG
93391: PUSH
93392: LD_INT 0
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: LD_INT 3
93401: NEG
93402: PUSH
93403: LD_INT 1
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 4
93412: NEG
93413: PUSH
93414: LD_INT 1
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 5
93423: NEG
93424: PUSH
93425: LD_INT 0
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: PUSH
93432: LD_INT 5
93434: NEG
93435: PUSH
93436: LD_INT 1
93438: NEG
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 5
93446: NEG
93447: PUSH
93448: LD_INT 2
93450: NEG
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 3
93458: NEG
93459: PUSH
93460: LD_INT 2
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 3
93469: NEG
93470: PUSH
93471: LD_INT 3
93473: NEG
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: PUSH
93479: LD_INT 3
93481: NEG
93482: PUSH
93483: LD_INT 4
93485: NEG
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 2
93493: NEG
93494: PUSH
93495: LD_INT 3
93497: NEG
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: LD_INT 2
93505: NEG
93506: PUSH
93507: LD_INT 2
93509: NEG
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 3
93517: NEG
93518: PUSH
93519: LD_INT 2
93521: NEG
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 4
93529: NEG
93530: PUSH
93531: LD_INT 3
93533: NEG
93534: PUSH
93535: EMPTY
93536: LIST
93537: LIST
93538: PUSH
93539: LD_INT 4
93541: NEG
93542: PUSH
93543: LD_INT 4
93545: NEG
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: PUSH
93551: LD_INT 2
93553: NEG
93554: PUSH
93555: LD_INT 4
93557: NEG
93558: PUSH
93559: EMPTY
93560: LIST
93561: LIST
93562: PUSH
93563: LD_INT 4
93565: NEG
93566: PUSH
93567: LD_INT 2
93569: NEG
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: LD_INT 0
93577: PUSH
93578: LD_INT 4
93580: NEG
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: PUSH
93586: LD_INT 0
93588: PUSH
93589: LD_INT 5
93591: NEG
93592: PUSH
93593: EMPTY
93594: LIST
93595: LIST
93596: PUSH
93597: LD_INT 1
93599: PUSH
93600: LD_INT 4
93602: NEG
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: PUSH
93608: LD_INT 1
93610: PUSH
93611: LD_INT 3
93613: NEG
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 0
93621: PUSH
93622: LD_INT 3
93624: NEG
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: PUSH
93630: LD_INT 1
93632: NEG
93633: PUSH
93634: LD_INT 4
93636: NEG
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: PUSH
93642: LD_INT 1
93644: NEG
93645: PUSH
93646: LD_INT 5
93648: NEG
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 2
93656: PUSH
93657: LD_INT 3
93659: NEG
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: LD_INT 2
93667: NEG
93668: PUSH
93669: LD_INT 5
93671: NEG
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 3
93679: PUSH
93680: LD_INT 0
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: PUSH
93687: LD_INT 3
93689: PUSH
93690: LD_INT 1
93692: NEG
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: PUSH
93698: LD_INT 4
93700: PUSH
93701: LD_INT 0
93703: PUSH
93704: EMPTY
93705: LIST
93706: LIST
93707: PUSH
93708: LD_INT 4
93710: PUSH
93711: LD_INT 1
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 3
93720: PUSH
93721: LD_INT 1
93723: PUSH
93724: EMPTY
93725: LIST
93726: LIST
93727: PUSH
93728: LD_INT 2
93730: PUSH
93731: LD_INT 0
93733: PUSH
93734: EMPTY
93735: LIST
93736: LIST
93737: PUSH
93738: LD_INT 2
93740: PUSH
93741: LD_INT 1
93743: NEG
93744: PUSH
93745: EMPTY
93746: LIST
93747: LIST
93748: PUSH
93749: LD_INT 2
93751: PUSH
93752: LD_INT 2
93754: NEG
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: PUSH
93760: LD_INT 4
93762: PUSH
93763: LD_INT 2
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 4
93772: PUSH
93773: LD_INT 4
93775: PUSH
93776: EMPTY
93777: LIST
93778: LIST
93779: PUSH
93780: LD_INT 4
93782: PUSH
93783: LD_INT 3
93785: PUSH
93786: EMPTY
93787: LIST
93788: LIST
93789: PUSH
93790: LD_INT 5
93792: PUSH
93793: LD_INT 4
93795: PUSH
93796: EMPTY
93797: LIST
93798: LIST
93799: PUSH
93800: LD_INT 5
93802: PUSH
93803: LD_INT 5
93805: PUSH
93806: EMPTY
93807: LIST
93808: LIST
93809: PUSH
93810: LD_INT 4
93812: PUSH
93813: LD_INT 5
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: LD_INT 3
93822: PUSH
93823: LD_INT 4
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PUSH
93830: LD_INT 3
93832: PUSH
93833: LD_INT 3
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: PUSH
93840: LD_INT 5
93842: PUSH
93843: LD_INT 3
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 3
93852: PUSH
93853: LD_INT 5
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: EMPTY
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
93907: LD_ADDR_VAR 0 33
93911: PUSH
93912: LD_INT 4
93914: NEG
93915: PUSH
93916: LD_INT 4
93918: NEG
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: PUSH
93924: LD_INT 4
93926: NEG
93927: PUSH
93928: LD_INT 5
93930: NEG
93931: PUSH
93932: EMPTY
93933: LIST
93934: LIST
93935: PUSH
93936: LD_INT 3
93938: NEG
93939: PUSH
93940: LD_INT 4
93942: NEG
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: LD_INT 3
93950: NEG
93951: PUSH
93952: LD_INT 3
93954: NEG
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 4
93962: NEG
93963: PUSH
93964: LD_INT 3
93966: NEG
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 5
93974: NEG
93975: PUSH
93976: LD_INT 4
93978: NEG
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 5
93986: NEG
93987: PUSH
93988: LD_INT 5
93990: NEG
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: PUSH
93996: LD_INT 3
93998: NEG
93999: PUSH
94000: LD_INT 5
94002: NEG
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: LD_INT 5
94010: NEG
94011: PUSH
94012: LD_INT 3
94014: NEG
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: PUSH
94020: LD_INT 0
94022: PUSH
94023: LD_INT 3
94025: NEG
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: PUSH
94031: LD_INT 0
94033: PUSH
94034: LD_INT 4
94036: NEG
94037: PUSH
94038: EMPTY
94039: LIST
94040: LIST
94041: PUSH
94042: LD_INT 1
94044: PUSH
94045: LD_INT 3
94047: NEG
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: LD_INT 1
94055: PUSH
94056: LD_INT 2
94058: NEG
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: LD_INT 0
94066: PUSH
94067: LD_INT 2
94069: NEG
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: PUSH
94075: LD_INT 1
94077: NEG
94078: PUSH
94079: LD_INT 3
94081: NEG
94082: PUSH
94083: EMPTY
94084: LIST
94085: LIST
94086: PUSH
94087: LD_INT 1
94089: NEG
94090: PUSH
94091: LD_INT 4
94093: NEG
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 2
94101: PUSH
94102: LD_INT 2
94104: NEG
94105: PUSH
94106: EMPTY
94107: LIST
94108: LIST
94109: PUSH
94110: LD_INT 2
94112: NEG
94113: PUSH
94114: LD_INT 4
94116: NEG
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 4
94124: PUSH
94125: LD_INT 0
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: LD_INT 4
94134: PUSH
94135: LD_INT 1
94137: NEG
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: PUSH
94143: LD_INT 5
94145: PUSH
94146: LD_INT 0
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: PUSH
94153: LD_INT 5
94155: PUSH
94156: LD_INT 1
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 4
94165: PUSH
94166: LD_INT 1
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: LD_INT 3
94175: PUSH
94176: LD_INT 0
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 3
94185: PUSH
94186: LD_INT 1
94188: NEG
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 3
94196: PUSH
94197: LD_INT 2
94199: NEG
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: PUSH
94205: LD_INT 5
94207: PUSH
94208: LD_INT 2
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 3
94217: PUSH
94218: LD_INT 3
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 3
94227: PUSH
94228: LD_INT 2
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 4
94237: PUSH
94238: LD_INT 3
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: PUSH
94245: LD_INT 4
94247: PUSH
94248: LD_INT 4
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 3
94257: PUSH
94258: LD_INT 4
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: PUSH
94265: LD_INT 2
94267: PUSH
94268: LD_INT 3
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 2
94277: PUSH
94278: LD_INT 2
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 4
94287: PUSH
94288: LD_INT 2
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 2
94297: PUSH
94298: LD_INT 4
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 0
94307: PUSH
94308: LD_INT 4
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: PUSH
94315: LD_INT 0
94317: PUSH
94318: LD_INT 3
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 1
94327: PUSH
94328: LD_INT 4
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 1
94337: PUSH
94338: LD_INT 5
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 0
94347: PUSH
94348: LD_INT 5
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 1
94357: NEG
94358: PUSH
94359: LD_INT 4
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 1
94368: NEG
94369: PUSH
94370: LD_INT 3
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: PUSH
94377: LD_INT 2
94379: PUSH
94380: LD_INT 5
94382: PUSH
94383: EMPTY
94384: LIST
94385: LIST
94386: PUSH
94387: LD_INT 2
94389: NEG
94390: PUSH
94391: LD_INT 3
94393: PUSH
94394: EMPTY
94395: LIST
94396: LIST
94397: PUSH
94398: EMPTY
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
94445: LD_ADDR_VAR 0 34
94449: PUSH
94450: LD_INT 0
94452: PUSH
94453: LD_INT 4
94455: NEG
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: PUSH
94461: LD_INT 0
94463: PUSH
94464: LD_INT 5
94466: NEG
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PUSH
94472: LD_INT 1
94474: PUSH
94475: LD_INT 4
94477: NEG
94478: PUSH
94479: EMPTY
94480: LIST
94481: LIST
94482: PUSH
94483: LD_INT 1
94485: PUSH
94486: LD_INT 3
94488: NEG
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: LD_INT 0
94496: PUSH
94497: LD_INT 3
94499: NEG
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 1
94507: NEG
94508: PUSH
94509: LD_INT 4
94511: NEG
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 1
94519: NEG
94520: PUSH
94521: LD_INT 5
94523: NEG
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 2
94531: PUSH
94532: LD_INT 3
94534: NEG
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: LD_INT 2
94542: NEG
94543: PUSH
94544: LD_INT 5
94546: NEG
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 3
94554: PUSH
94555: LD_INT 0
94557: PUSH
94558: EMPTY
94559: LIST
94560: LIST
94561: PUSH
94562: LD_INT 3
94564: PUSH
94565: LD_INT 1
94567: NEG
94568: PUSH
94569: EMPTY
94570: LIST
94571: LIST
94572: PUSH
94573: LD_INT 4
94575: PUSH
94576: LD_INT 0
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 4
94585: PUSH
94586: LD_INT 1
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 3
94595: PUSH
94596: LD_INT 1
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: PUSH
94603: LD_INT 2
94605: PUSH
94606: LD_INT 0
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 2
94615: PUSH
94616: LD_INT 1
94618: NEG
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 2
94626: PUSH
94627: LD_INT 2
94629: NEG
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: PUSH
94635: LD_INT 4
94637: PUSH
94638: LD_INT 2
94640: PUSH
94641: EMPTY
94642: LIST
94643: LIST
94644: PUSH
94645: LD_INT 4
94647: PUSH
94648: LD_INT 4
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 4
94657: PUSH
94658: LD_INT 3
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: PUSH
94665: LD_INT 5
94667: PUSH
94668: LD_INT 4
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 5
94677: PUSH
94678: LD_INT 5
94680: PUSH
94681: EMPTY
94682: LIST
94683: LIST
94684: PUSH
94685: LD_INT 4
94687: PUSH
94688: LD_INT 5
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: PUSH
94695: LD_INT 3
94697: PUSH
94698: LD_INT 4
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 3
94707: PUSH
94708: LD_INT 3
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PUSH
94715: LD_INT 5
94717: PUSH
94718: LD_INT 3
94720: PUSH
94721: EMPTY
94722: LIST
94723: LIST
94724: PUSH
94725: LD_INT 3
94727: PUSH
94728: LD_INT 5
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: PUSH
94735: LD_INT 0
94737: PUSH
94738: LD_INT 3
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: PUSH
94745: LD_INT 0
94747: PUSH
94748: LD_INT 2
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: LD_INT 1
94757: PUSH
94758: LD_INT 3
94760: PUSH
94761: EMPTY
94762: LIST
94763: LIST
94764: PUSH
94765: LD_INT 1
94767: PUSH
94768: LD_INT 4
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 0
94777: PUSH
94778: LD_INT 4
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: PUSH
94785: LD_INT 1
94787: NEG
94788: PUSH
94789: LD_INT 3
94791: PUSH
94792: EMPTY
94793: LIST
94794: LIST
94795: PUSH
94796: LD_INT 1
94798: NEG
94799: PUSH
94800: LD_INT 2
94802: PUSH
94803: EMPTY
94804: LIST
94805: LIST
94806: PUSH
94807: LD_INT 2
94809: PUSH
94810: LD_INT 4
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: PUSH
94817: LD_INT 2
94819: NEG
94820: PUSH
94821: LD_INT 2
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 4
94830: NEG
94831: PUSH
94832: LD_INT 0
94834: PUSH
94835: EMPTY
94836: LIST
94837: LIST
94838: PUSH
94839: LD_INT 4
94841: NEG
94842: PUSH
94843: LD_INT 1
94845: NEG
94846: PUSH
94847: EMPTY
94848: LIST
94849: LIST
94850: PUSH
94851: LD_INT 3
94853: NEG
94854: PUSH
94855: LD_INT 0
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: LD_INT 3
94864: NEG
94865: PUSH
94866: LD_INT 1
94868: PUSH
94869: EMPTY
94870: LIST
94871: LIST
94872: PUSH
94873: LD_INT 4
94875: NEG
94876: PUSH
94877: LD_INT 1
94879: PUSH
94880: EMPTY
94881: LIST
94882: LIST
94883: PUSH
94884: LD_INT 5
94886: NEG
94887: PUSH
94888: LD_INT 0
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: PUSH
94895: LD_INT 5
94897: NEG
94898: PUSH
94899: LD_INT 1
94901: NEG
94902: PUSH
94903: EMPTY
94904: LIST
94905: LIST
94906: PUSH
94907: LD_INT 5
94909: NEG
94910: PUSH
94911: LD_INT 2
94913: NEG
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 3
94921: NEG
94922: PUSH
94923: LD_INT 2
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: ST_TO_ADDR
// end ; end ;
94977: GO 94980
94979: POP
// case btype of b_depot , b_warehouse :
94980: LD_VAR 0 1
94984: PUSH
94985: LD_INT 0
94987: DOUBLE
94988: EQUAL
94989: IFTRUE 94999
94991: LD_INT 1
94993: DOUBLE
94994: EQUAL
94995: IFTRUE 94999
94997: GO 95200
94999: POP
// case nation of nation_american :
95000: LD_VAR 0 5
95004: PUSH
95005: LD_INT 1
95007: DOUBLE
95008: EQUAL
95009: IFTRUE 95013
95011: GO 95069
95013: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
95014: LD_ADDR_VAR 0 9
95018: PUSH
95019: LD_VAR 0 11
95023: PUSH
95024: LD_VAR 0 12
95028: PUSH
95029: LD_VAR 0 13
95033: PUSH
95034: LD_VAR 0 14
95038: PUSH
95039: LD_VAR 0 15
95043: PUSH
95044: LD_VAR 0 16
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: PUSH
95057: LD_VAR 0 4
95061: PUSH
95062: LD_INT 1
95064: PLUS
95065: ARRAY
95066: ST_TO_ADDR
95067: GO 95198
95069: LD_INT 2
95071: DOUBLE
95072: EQUAL
95073: IFTRUE 95077
95075: GO 95133
95077: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
95078: LD_ADDR_VAR 0 9
95082: PUSH
95083: LD_VAR 0 17
95087: PUSH
95088: LD_VAR 0 18
95092: PUSH
95093: LD_VAR 0 19
95097: PUSH
95098: LD_VAR 0 20
95102: PUSH
95103: LD_VAR 0 21
95107: PUSH
95108: LD_VAR 0 22
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: PUSH
95121: LD_VAR 0 4
95125: PUSH
95126: LD_INT 1
95128: PLUS
95129: ARRAY
95130: ST_TO_ADDR
95131: GO 95198
95133: LD_INT 3
95135: DOUBLE
95136: EQUAL
95137: IFTRUE 95141
95139: GO 95197
95141: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95142: LD_ADDR_VAR 0 9
95146: PUSH
95147: LD_VAR 0 23
95151: PUSH
95152: LD_VAR 0 24
95156: PUSH
95157: LD_VAR 0 25
95161: PUSH
95162: LD_VAR 0 26
95166: PUSH
95167: LD_VAR 0 27
95171: PUSH
95172: LD_VAR 0 28
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: PUSH
95185: LD_VAR 0 4
95189: PUSH
95190: LD_INT 1
95192: PLUS
95193: ARRAY
95194: ST_TO_ADDR
95195: GO 95198
95197: POP
95198: GO 95753
95200: LD_INT 2
95202: DOUBLE
95203: EQUAL
95204: IFTRUE 95214
95206: LD_INT 3
95208: DOUBLE
95209: EQUAL
95210: IFTRUE 95214
95212: GO 95270
95214: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95215: LD_ADDR_VAR 0 9
95219: PUSH
95220: LD_VAR 0 29
95224: PUSH
95225: LD_VAR 0 30
95229: PUSH
95230: LD_VAR 0 31
95234: PUSH
95235: LD_VAR 0 32
95239: PUSH
95240: LD_VAR 0 33
95244: PUSH
95245: LD_VAR 0 34
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: PUSH
95258: LD_VAR 0 4
95262: PUSH
95263: LD_INT 1
95265: PLUS
95266: ARRAY
95267: ST_TO_ADDR
95268: GO 95753
95270: LD_INT 16
95272: DOUBLE
95273: EQUAL
95274: IFTRUE 95332
95276: LD_INT 17
95278: DOUBLE
95279: EQUAL
95280: IFTRUE 95332
95282: LD_INT 18
95284: DOUBLE
95285: EQUAL
95286: IFTRUE 95332
95288: LD_INT 19
95290: DOUBLE
95291: EQUAL
95292: IFTRUE 95332
95294: LD_INT 22
95296: DOUBLE
95297: EQUAL
95298: IFTRUE 95332
95300: LD_INT 20
95302: DOUBLE
95303: EQUAL
95304: IFTRUE 95332
95306: LD_INT 21
95308: DOUBLE
95309: EQUAL
95310: IFTRUE 95332
95312: LD_INT 23
95314: DOUBLE
95315: EQUAL
95316: IFTRUE 95332
95318: LD_INT 24
95320: DOUBLE
95321: EQUAL
95322: IFTRUE 95332
95324: LD_INT 25
95326: DOUBLE
95327: EQUAL
95328: IFTRUE 95332
95330: GO 95388
95332: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95333: LD_ADDR_VAR 0 9
95337: PUSH
95338: LD_VAR 0 35
95342: PUSH
95343: LD_VAR 0 36
95347: PUSH
95348: LD_VAR 0 37
95352: PUSH
95353: LD_VAR 0 38
95357: PUSH
95358: LD_VAR 0 39
95362: PUSH
95363: LD_VAR 0 40
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: PUSH
95376: LD_VAR 0 4
95380: PUSH
95381: LD_INT 1
95383: PLUS
95384: ARRAY
95385: ST_TO_ADDR
95386: GO 95753
95388: LD_INT 6
95390: DOUBLE
95391: EQUAL
95392: IFTRUE 95444
95394: LD_INT 7
95396: DOUBLE
95397: EQUAL
95398: IFTRUE 95444
95400: LD_INT 8
95402: DOUBLE
95403: EQUAL
95404: IFTRUE 95444
95406: LD_INT 13
95408: DOUBLE
95409: EQUAL
95410: IFTRUE 95444
95412: LD_INT 12
95414: DOUBLE
95415: EQUAL
95416: IFTRUE 95444
95418: LD_INT 15
95420: DOUBLE
95421: EQUAL
95422: IFTRUE 95444
95424: LD_INT 11
95426: DOUBLE
95427: EQUAL
95428: IFTRUE 95444
95430: LD_INT 14
95432: DOUBLE
95433: EQUAL
95434: IFTRUE 95444
95436: LD_INT 10
95438: DOUBLE
95439: EQUAL
95440: IFTRUE 95444
95442: GO 95500
95444: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
95445: LD_ADDR_VAR 0 9
95449: PUSH
95450: LD_VAR 0 41
95454: PUSH
95455: LD_VAR 0 42
95459: PUSH
95460: LD_VAR 0 43
95464: PUSH
95465: LD_VAR 0 44
95469: PUSH
95470: LD_VAR 0 45
95474: PUSH
95475: LD_VAR 0 46
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: PUSH
95488: LD_VAR 0 4
95492: PUSH
95493: LD_INT 1
95495: PLUS
95496: ARRAY
95497: ST_TO_ADDR
95498: GO 95753
95500: LD_INT 36
95502: DOUBLE
95503: EQUAL
95504: IFTRUE 95508
95506: GO 95564
95508: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
95509: LD_ADDR_VAR 0 9
95513: PUSH
95514: LD_VAR 0 47
95518: PUSH
95519: LD_VAR 0 48
95523: PUSH
95524: LD_VAR 0 49
95528: PUSH
95529: LD_VAR 0 50
95533: PUSH
95534: LD_VAR 0 51
95538: PUSH
95539: LD_VAR 0 52
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: PUSH
95552: LD_VAR 0 4
95556: PUSH
95557: LD_INT 1
95559: PLUS
95560: ARRAY
95561: ST_TO_ADDR
95562: GO 95753
95564: LD_INT 4
95566: DOUBLE
95567: EQUAL
95568: IFTRUE 95590
95570: LD_INT 5
95572: DOUBLE
95573: EQUAL
95574: IFTRUE 95590
95576: LD_INT 34
95578: DOUBLE
95579: EQUAL
95580: IFTRUE 95590
95582: LD_INT 37
95584: DOUBLE
95585: EQUAL
95586: IFTRUE 95590
95588: GO 95646
95590: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
95591: LD_ADDR_VAR 0 9
95595: PUSH
95596: LD_VAR 0 53
95600: PUSH
95601: LD_VAR 0 54
95605: PUSH
95606: LD_VAR 0 55
95610: PUSH
95611: LD_VAR 0 56
95615: PUSH
95616: LD_VAR 0 57
95620: PUSH
95621: LD_VAR 0 58
95625: PUSH
95626: EMPTY
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: PUSH
95634: LD_VAR 0 4
95638: PUSH
95639: LD_INT 1
95641: PLUS
95642: ARRAY
95643: ST_TO_ADDR
95644: GO 95753
95646: LD_INT 31
95648: DOUBLE
95649: EQUAL
95650: IFTRUE 95696
95652: LD_INT 32
95654: DOUBLE
95655: EQUAL
95656: IFTRUE 95696
95658: LD_INT 33
95660: DOUBLE
95661: EQUAL
95662: IFTRUE 95696
95664: LD_INT 27
95666: DOUBLE
95667: EQUAL
95668: IFTRUE 95696
95670: LD_INT 26
95672: DOUBLE
95673: EQUAL
95674: IFTRUE 95696
95676: LD_INT 28
95678: DOUBLE
95679: EQUAL
95680: IFTRUE 95696
95682: LD_INT 29
95684: DOUBLE
95685: EQUAL
95686: IFTRUE 95696
95688: LD_INT 30
95690: DOUBLE
95691: EQUAL
95692: IFTRUE 95696
95694: GO 95752
95696: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
95697: LD_ADDR_VAR 0 9
95701: PUSH
95702: LD_VAR 0 59
95706: PUSH
95707: LD_VAR 0 60
95711: PUSH
95712: LD_VAR 0 61
95716: PUSH
95717: LD_VAR 0 62
95721: PUSH
95722: LD_VAR 0 63
95726: PUSH
95727: LD_VAR 0 64
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: PUSH
95740: LD_VAR 0 4
95744: PUSH
95745: LD_INT 1
95747: PLUS
95748: ARRAY
95749: ST_TO_ADDR
95750: GO 95753
95752: POP
// temp_list2 = [ ] ;
95753: LD_ADDR_VAR 0 10
95757: PUSH
95758: EMPTY
95759: ST_TO_ADDR
// for i in temp_list do
95760: LD_ADDR_VAR 0 8
95764: PUSH
95765: LD_VAR 0 9
95769: PUSH
95770: FOR_IN
95771: IFFALSE 95823
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95773: LD_ADDR_VAR 0 10
95777: PUSH
95778: LD_VAR 0 10
95782: PUSH
95783: LD_VAR 0 8
95787: PUSH
95788: LD_INT 1
95790: ARRAY
95791: PUSH
95792: LD_VAR 0 2
95796: PLUS
95797: PUSH
95798: LD_VAR 0 8
95802: PUSH
95803: LD_INT 2
95805: ARRAY
95806: PUSH
95807: LD_VAR 0 3
95811: PLUS
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: EMPTY
95818: LIST
95819: ADD
95820: ST_TO_ADDR
95821: GO 95770
95823: POP
95824: POP
// result = temp_list2 ;
95825: LD_ADDR_VAR 0 7
95829: PUSH
95830: LD_VAR 0 10
95834: ST_TO_ADDR
// end ;
95835: LD_VAR 0 7
95839: RET
// export function EnemyInRange ( unit , dist ) ; begin
95840: LD_INT 0
95842: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
95843: LD_ADDR_VAR 0 3
95847: PUSH
95848: LD_VAR 0 1
95852: PPUSH
95853: CALL_OW 255
95857: PPUSH
95858: LD_VAR 0 1
95862: PPUSH
95863: CALL_OW 250
95867: PPUSH
95868: LD_VAR 0 1
95872: PPUSH
95873: CALL_OW 251
95877: PPUSH
95878: LD_VAR 0 2
95882: PPUSH
95883: CALL 69213 0 4
95887: PUSH
95888: LD_INT 4
95890: ARRAY
95891: ST_TO_ADDR
// end ;
95892: LD_VAR 0 3
95896: RET
// export function PlayerSeeMe ( unit ) ; begin
95897: LD_INT 0
95899: PPUSH
// result := See ( your_side , unit ) ;
95900: LD_ADDR_VAR 0 2
95904: PUSH
95905: LD_OWVAR 2
95909: PPUSH
95910: LD_VAR 0 1
95914: PPUSH
95915: CALL_OW 292
95919: ST_TO_ADDR
// end ;
95920: LD_VAR 0 2
95924: RET
// export function ReverseDir ( unit ) ; begin
95925: LD_INT 0
95927: PPUSH
// if not unit then
95928: LD_VAR 0 1
95932: NOT
95933: IFFALSE 95937
// exit ;
95935: GO 95960
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
95937: LD_ADDR_VAR 0 2
95941: PUSH
95942: LD_VAR 0 1
95946: PPUSH
95947: CALL_OW 254
95951: PUSH
95952: LD_INT 3
95954: PLUS
95955: PUSH
95956: LD_INT 6
95958: MOD
95959: ST_TO_ADDR
// end ;
95960: LD_VAR 0 2
95964: RET
// export function ReverseArray ( array ) ; var i ; begin
95965: LD_INT 0
95967: PPUSH
95968: PPUSH
// if not array then
95969: LD_VAR 0 1
95973: NOT
95974: IFFALSE 95978
// exit ;
95976: GO 96033
// result := [ ] ;
95978: LD_ADDR_VAR 0 2
95982: PUSH
95983: EMPTY
95984: ST_TO_ADDR
// for i := array downto 1 do
95985: LD_ADDR_VAR 0 3
95989: PUSH
95990: DOUBLE
95991: LD_VAR 0 1
95995: INC
95996: ST_TO_ADDR
95997: LD_INT 1
95999: PUSH
96000: FOR_DOWNTO
96001: IFFALSE 96031
// result := Join ( result , array [ i ] ) ;
96003: LD_ADDR_VAR 0 2
96007: PUSH
96008: LD_VAR 0 2
96012: PPUSH
96013: LD_VAR 0 1
96017: PUSH
96018: LD_VAR 0 3
96022: ARRAY
96023: PPUSH
96024: CALL 100676 0 2
96028: ST_TO_ADDR
96029: GO 96000
96031: POP
96032: POP
// end ;
96033: LD_VAR 0 2
96037: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
96038: LD_INT 0
96040: PPUSH
96041: PPUSH
96042: PPUSH
96043: PPUSH
96044: PPUSH
96045: PPUSH
// if not unit or not hexes then
96046: LD_VAR 0 1
96050: NOT
96051: PUSH
96052: LD_VAR 0 2
96056: NOT
96057: OR
96058: IFFALSE 96062
// exit ;
96060: GO 96185
// dist := 9999 ;
96062: LD_ADDR_VAR 0 5
96066: PUSH
96067: LD_INT 9999
96069: ST_TO_ADDR
// for i = 1 to hexes do
96070: LD_ADDR_VAR 0 4
96074: PUSH
96075: DOUBLE
96076: LD_INT 1
96078: DEC
96079: ST_TO_ADDR
96080: LD_VAR 0 2
96084: PUSH
96085: FOR_TO
96086: IFFALSE 96173
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96088: LD_ADDR_VAR 0 6
96092: PUSH
96093: LD_VAR 0 1
96097: PPUSH
96098: LD_VAR 0 2
96102: PUSH
96103: LD_VAR 0 4
96107: ARRAY
96108: PUSH
96109: LD_INT 1
96111: ARRAY
96112: PPUSH
96113: LD_VAR 0 2
96117: PUSH
96118: LD_VAR 0 4
96122: ARRAY
96123: PUSH
96124: LD_INT 2
96126: ARRAY
96127: PPUSH
96128: CALL_OW 297
96132: ST_TO_ADDR
// if tdist < dist then
96133: LD_VAR 0 6
96137: PUSH
96138: LD_VAR 0 5
96142: LESS
96143: IFFALSE 96171
// begin hex := hexes [ i ] ;
96145: LD_ADDR_VAR 0 8
96149: PUSH
96150: LD_VAR 0 2
96154: PUSH
96155: LD_VAR 0 4
96159: ARRAY
96160: ST_TO_ADDR
// dist := tdist ;
96161: LD_ADDR_VAR 0 5
96165: PUSH
96166: LD_VAR 0 6
96170: ST_TO_ADDR
// end ; end ;
96171: GO 96085
96173: POP
96174: POP
// result := hex ;
96175: LD_ADDR_VAR 0 3
96179: PUSH
96180: LD_VAR 0 8
96184: ST_TO_ADDR
// end ;
96185: LD_VAR 0 3
96189: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96190: LD_INT 0
96192: PPUSH
96193: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96194: LD_VAR 0 1
96198: NOT
96199: PUSH
96200: LD_VAR 0 1
96204: PUSH
96205: LD_INT 21
96207: PUSH
96208: LD_INT 2
96210: PUSH
96211: EMPTY
96212: LIST
96213: LIST
96214: PUSH
96215: LD_INT 23
96217: PUSH
96218: LD_INT 2
96220: PUSH
96221: EMPTY
96222: LIST
96223: LIST
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PPUSH
96229: CALL_OW 69
96233: IN
96234: NOT
96235: OR
96236: IFFALSE 96240
// exit ;
96238: GO 96287
// for i = 1 to 3 do
96240: LD_ADDR_VAR 0 3
96244: PUSH
96245: DOUBLE
96246: LD_INT 1
96248: DEC
96249: ST_TO_ADDR
96250: LD_INT 3
96252: PUSH
96253: FOR_TO
96254: IFFALSE 96285
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96256: LD_VAR 0 1
96260: PPUSH
96261: CALL_OW 250
96265: PPUSH
96266: LD_VAR 0 1
96270: PPUSH
96271: CALL_OW 251
96275: PPUSH
96276: LD_INT 1
96278: PPUSH
96279: CALL_OW 453
96283: GO 96253
96285: POP
96286: POP
// end ;
96287: LD_VAR 0 2
96291: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96292: LD_INT 0
96294: PPUSH
96295: PPUSH
96296: PPUSH
96297: PPUSH
96298: PPUSH
96299: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96300: LD_VAR 0 1
96304: NOT
96305: PUSH
96306: LD_VAR 0 2
96310: NOT
96311: OR
96312: PUSH
96313: LD_VAR 0 1
96317: PPUSH
96318: CALL_OW 314
96322: OR
96323: IFFALSE 96327
// exit ;
96325: GO 96794
// if GetLives ( i ) < 250 then
96327: LD_VAR 0 4
96331: PPUSH
96332: CALL_OW 256
96336: PUSH
96337: LD_INT 250
96339: LESS
96340: IFFALSE 96353
// begin ComAutodestruct ( i ) ;
96342: LD_VAR 0 4
96346: PPUSH
96347: CALL 96190 0 1
// exit ;
96351: GO 96794
// end ; x := GetX ( enemy_unit ) ;
96353: LD_ADDR_VAR 0 7
96357: PUSH
96358: LD_VAR 0 2
96362: PPUSH
96363: CALL_OW 250
96367: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96368: LD_ADDR_VAR 0 8
96372: PUSH
96373: LD_VAR 0 2
96377: PPUSH
96378: CALL_OW 251
96382: ST_TO_ADDR
// if not x or not y then
96383: LD_VAR 0 7
96387: NOT
96388: PUSH
96389: LD_VAR 0 8
96393: NOT
96394: OR
96395: IFFALSE 96399
// exit ;
96397: GO 96794
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96399: LD_ADDR_VAR 0 6
96403: PUSH
96404: LD_VAR 0 7
96408: PPUSH
96409: LD_INT 0
96411: PPUSH
96412: LD_INT 4
96414: PPUSH
96415: CALL_OW 272
96419: PUSH
96420: LD_VAR 0 8
96424: PPUSH
96425: LD_INT 0
96427: PPUSH
96428: LD_INT 4
96430: PPUSH
96431: CALL_OW 273
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PUSH
96440: LD_VAR 0 7
96444: PPUSH
96445: LD_INT 1
96447: PPUSH
96448: LD_INT 4
96450: PPUSH
96451: CALL_OW 272
96455: PUSH
96456: LD_VAR 0 8
96460: PPUSH
96461: LD_INT 1
96463: PPUSH
96464: LD_INT 4
96466: PPUSH
96467: CALL_OW 273
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: PUSH
96476: LD_VAR 0 7
96480: PPUSH
96481: LD_INT 2
96483: PPUSH
96484: LD_INT 4
96486: PPUSH
96487: CALL_OW 272
96491: PUSH
96492: LD_VAR 0 8
96496: PPUSH
96497: LD_INT 2
96499: PPUSH
96500: LD_INT 4
96502: PPUSH
96503: CALL_OW 273
96507: PUSH
96508: EMPTY
96509: LIST
96510: LIST
96511: PUSH
96512: LD_VAR 0 7
96516: PPUSH
96517: LD_INT 3
96519: PPUSH
96520: LD_INT 4
96522: PPUSH
96523: CALL_OW 272
96527: PUSH
96528: LD_VAR 0 8
96532: PPUSH
96533: LD_INT 3
96535: PPUSH
96536: LD_INT 4
96538: PPUSH
96539: CALL_OW 273
96543: PUSH
96544: EMPTY
96545: LIST
96546: LIST
96547: PUSH
96548: LD_VAR 0 7
96552: PPUSH
96553: LD_INT 4
96555: PPUSH
96556: LD_INT 4
96558: PPUSH
96559: CALL_OW 272
96563: PUSH
96564: LD_VAR 0 8
96568: PPUSH
96569: LD_INT 4
96571: PPUSH
96572: LD_INT 4
96574: PPUSH
96575: CALL_OW 273
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: LD_VAR 0 7
96588: PPUSH
96589: LD_INT 5
96591: PPUSH
96592: LD_INT 4
96594: PPUSH
96595: CALL_OW 272
96599: PUSH
96600: LD_VAR 0 8
96604: PPUSH
96605: LD_INT 5
96607: PPUSH
96608: LD_INT 4
96610: PPUSH
96611: CALL_OW 273
96615: PUSH
96616: EMPTY
96617: LIST
96618: LIST
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: ST_TO_ADDR
// for i = tmp downto 1 do
96628: LD_ADDR_VAR 0 4
96632: PUSH
96633: DOUBLE
96634: LD_VAR 0 6
96638: INC
96639: ST_TO_ADDR
96640: LD_INT 1
96642: PUSH
96643: FOR_DOWNTO
96644: IFFALSE 96745
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
96646: LD_VAR 0 6
96650: PUSH
96651: LD_VAR 0 4
96655: ARRAY
96656: PUSH
96657: LD_INT 1
96659: ARRAY
96660: PPUSH
96661: LD_VAR 0 6
96665: PUSH
96666: LD_VAR 0 4
96670: ARRAY
96671: PUSH
96672: LD_INT 2
96674: ARRAY
96675: PPUSH
96676: CALL_OW 488
96680: NOT
96681: PUSH
96682: LD_VAR 0 6
96686: PUSH
96687: LD_VAR 0 4
96691: ARRAY
96692: PUSH
96693: LD_INT 1
96695: ARRAY
96696: PPUSH
96697: LD_VAR 0 6
96701: PUSH
96702: LD_VAR 0 4
96706: ARRAY
96707: PUSH
96708: LD_INT 2
96710: ARRAY
96711: PPUSH
96712: CALL_OW 428
96716: PUSH
96717: LD_INT 0
96719: NONEQUAL
96720: OR
96721: IFFALSE 96743
// tmp := Delete ( tmp , i ) ;
96723: LD_ADDR_VAR 0 6
96727: PUSH
96728: LD_VAR 0 6
96732: PPUSH
96733: LD_VAR 0 4
96737: PPUSH
96738: CALL_OW 3
96742: ST_TO_ADDR
96743: GO 96643
96745: POP
96746: POP
// j := GetClosestHex ( unit , tmp ) ;
96747: LD_ADDR_VAR 0 5
96751: PUSH
96752: LD_VAR 0 1
96756: PPUSH
96757: LD_VAR 0 6
96761: PPUSH
96762: CALL 96038 0 2
96766: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
96767: LD_VAR 0 1
96771: PPUSH
96772: LD_VAR 0 5
96776: PUSH
96777: LD_INT 1
96779: ARRAY
96780: PPUSH
96781: LD_VAR 0 5
96785: PUSH
96786: LD_INT 2
96788: ARRAY
96789: PPUSH
96790: CALL_OW 111
// end ;
96794: LD_VAR 0 3
96798: RET
// export function PrepareApemanSoldier ( ) ; begin
96799: LD_INT 0
96801: PPUSH
// uc_nation := 0 ;
96802: LD_ADDR_OWVAR 21
96806: PUSH
96807: LD_INT 0
96809: ST_TO_ADDR
// hc_sex := sex_male ;
96810: LD_ADDR_OWVAR 27
96814: PUSH
96815: LD_INT 1
96817: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
96818: LD_ADDR_OWVAR 28
96822: PUSH
96823: LD_INT 15
96825: ST_TO_ADDR
// hc_gallery :=  ;
96826: LD_ADDR_OWVAR 33
96830: PUSH
96831: LD_STRING 
96833: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96834: LD_ADDR_OWVAR 31
96838: PUSH
96839: LD_INT 0
96841: PPUSH
96842: LD_INT 3
96844: PPUSH
96845: CALL_OW 12
96849: PUSH
96850: LD_INT 0
96852: PPUSH
96853: LD_INT 3
96855: PPUSH
96856: CALL_OW 12
96860: PUSH
96861: LD_INT 0
96863: PUSH
96864: LD_INT 0
96866: PUSH
96867: EMPTY
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: ST_TO_ADDR
// end ;
96873: LD_VAR 0 1
96877: RET
// export function PrepareApemanEngineer ( ) ; begin
96878: LD_INT 0
96880: PPUSH
// uc_nation := 0 ;
96881: LD_ADDR_OWVAR 21
96885: PUSH
96886: LD_INT 0
96888: ST_TO_ADDR
// hc_sex := sex_male ;
96889: LD_ADDR_OWVAR 27
96893: PUSH
96894: LD_INT 1
96896: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
96897: LD_ADDR_OWVAR 28
96901: PUSH
96902: LD_INT 16
96904: ST_TO_ADDR
// hc_gallery :=  ;
96905: LD_ADDR_OWVAR 33
96909: PUSH
96910: LD_STRING 
96912: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96913: LD_ADDR_OWVAR 31
96917: PUSH
96918: LD_INT 0
96920: PPUSH
96921: LD_INT 3
96923: PPUSH
96924: CALL_OW 12
96928: PUSH
96929: LD_INT 0
96931: PPUSH
96932: LD_INT 3
96934: PPUSH
96935: CALL_OW 12
96939: PUSH
96940: LD_INT 0
96942: PUSH
96943: LD_INT 0
96945: PUSH
96946: EMPTY
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: ST_TO_ADDR
// end ;
96952: LD_VAR 0 1
96956: RET
// export function PrepareApeman ( agressivity ) ; begin
96957: LD_INT 0
96959: PPUSH
// uc_side := 0 ;
96960: LD_ADDR_OWVAR 20
96964: PUSH
96965: LD_INT 0
96967: ST_TO_ADDR
// uc_nation := 0 ;
96968: LD_ADDR_OWVAR 21
96972: PUSH
96973: LD_INT 0
96975: ST_TO_ADDR
// hc_sex := sex_male ;
96976: LD_ADDR_OWVAR 27
96980: PUSH
96981: LD_INT 1
96983: ST_TO_ADDR
// hc_class := class_apeman ;
96984: LD_ADDR_OWVAR 28
96988: PUSH
96989: LD_INT 12
96991: ST_TO_ADDR
// hc_gallery :=  ;
96992: LD_ADDR_OWVAR 33
96996: PUSH
96997: LD_STRING 
96999: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97000: LD_ADDR_OWVAR 35
97004: PUSH
97005: LD_VAR 0 1
97009: NEG
97010: PPUSH
97011: LD_VAR 0 1
97015: PPUSH
97016: CALL_OW 12
97020: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97021: LD_ADDR_OWVAR 31
97025: PUSH
97026: LD_INT 0
97028: PPUSH
97029: LD_INT 3
97031: PPUSH
97032: CALL_OW 12
97036: PUSH
97037: LD_INT 0
97039: PPUSH
97040: LD_INT 3
97042: PPUSH
97043: CALL_OW 12
97047: PUSH
97048: LD_INT 0
97050: PUSH
97051: LD_INT 0
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: ST_TO_ADDR
// end ;
97060: LD_VAR 0 2
97064: RET
// export function PrepareTiger ( agressivity ) ; begin
97065: LD_INT 0
97067: PPUSH
// uc_side := 0 ;
97068: LD_ADDR_OWVAR 20
97072: PUSH
97073: LD_INT 0
97075: ST_TO_ADDR
// uc_nation := 0 ;
97076: LD_ADDR_OWVAR 21
97080: PUSH
97081: LD_INT 0
97083: ST_TO_ADDR
// hc_class := class_tiger ;
97084: LD_ADDR_OWVAR 28
97088: PUSH
97089: LD_INT 14
97091: ST_TO_ADDR
// hc_gallery :=  ;
97092: LD_ADDR_OWVAR 33
97096: PUSH
97097: LD_STRING 
97099: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97100: LD_ADDR_OWVAR 35
97104: PUSH
97105: LD_VAR 0 1
97109: NEG
97110: PPUSH
97111: LD_VAR 0 1
97115: PPUSH
97116: CALL_OW 12
97120: ST_TO_ADDR
// end ;
97121: LD_VAR 0 2
97125: RET
// export function PrepareEnchidna ( ) ; begin
97126: LD_INT 0
97128: PPUSH
// uc_side := 0 ;
97129: LD_ADDR_OWVAR 20
97133: PUSH
97134: LD_INT 0
97136: ST_TO_ADDR
// uc_nation := 0 ;
97137: LD_ADDR_OWVAR 21
97141: PUSH
97142: LD_INT 0
97144: ST_TO_ADDR
// hc_class := class_baggie ;
97145: LD_ADDR_OWVAR 28
97149: PUSH
97150: LD_INT 13
97152: ST_TO_ADDR
// hc_gallery :=  ;
97153: LD_ADDR_OWVAR 33
97157: PUSH
97158: LD_STRING 
97160: ST_TO_ADDR
// end ;
97161: LD_VAR 0 1
97165: RET
// export function PrepareFrog ( ) ; begin
97166: LD_INT 0
97168: PPUSH
// uc_side := 0 ;
97169: LD_ADDR_OWVAR 20
97173: PUSH
97174: LD_INT 0
97176: ST_TO_ADDR
// uc_nation := 0 ;
97177: LD_ADDR_OWVAR 21
97181: PUSH
97182: LD_INT 0
97184: ST_TO_ADDR
// hc_class := class_frog ;
97185: LD_ADDR_OWVAR 28
97189: PUSH
97190: LD_INT 19
97192: ST_TO_ADDR
// hc_gallery :=  ;
97193: LD_ADDR_OWVAR 33
97197: PUSH
97198: LD_STRING 
97200: ST_TO_ADDR
// end ;
97201: LD_VAR 0 1
97205: RET
// export function PrepareFish ( ) ; begin
97206: LD_INT 0
97208: PPUSH
// uc_side := 0 ;
97209: LD_ADDR_OWVAR 20
97213: PUSH
97214: LD_INT 0
97216: ST_TO_ADDR
// uc_nation := 0 ;
97217: LD_ADDR_OWVAR 21
97221: PUSH
97222: LD_INT 0
97224: ST_TO_ADDR
// hc_class := class_fish ;
97225: LD_ADDR_OWVAR 28
97229: PUSH
97230: LD_INT 20
97232: ST_TO_ADDR
// hc_gallery :=  ;
97233: LD_ADDR_OWVAR 33
97237: PUSH
97238: LD_STRING 
97240: ST_TO_ADDR
// end ;
97241: LD_VAR 0 1
97245: RET
// export function PrepareBird ( ) ; begin
97246: LD_INT 0
97248: PPUSH
// uc_side := 0 ;
97249: LD_ADDR_OWVAR 20
97253: PUSH
97254: LD_INT 0
97256: ST_TO_ADDR
// uc_nation := 0 ;
97257: LD_ADDR_OWVAR 21
97261: PUSH
97262: LD_INT 0
97264: ST_TO_ADDR
// hc_class := class_phororhacos ;
97265: LD_ADDR_OWVAR 28
97269: PUSH
97270: LD_INT 18
97272: ST_TO_ADDR
// hc_gallery :=  ;
97273: LD_ADDR_OWVAR 33
97277: PUSH
97278: LD_STRING 
97280: ST_TO_ADDR
// end ;
97281: LD_VAR 0 1
97285: RET
// export function PrepareHorse ( ) ; begin
97286: LD_INT 0
97288: PPUSH
// uc_side := 0 ;
97289: LD_ADDR_OWVAR 20
97293: PUSH
97294: LD_INT 0
97296: ST_TO_ADDR
// uc_nation := 0 ;
97297: LD_ADDR_OWVAR 21
97301: PUSH
97302: LD_INT 0
97304: ST_TO_ADDR
// hc_class := class_horse ;
97305: LD_ADDR_OWVAR 28
97309: PUSH
97310: LD_INT 21
97312: ST_TO_ADDR
// hc_gallery :=  ;
97313: LD_ADDR_OWVAR 33
97317: PUSH
97318: LD_STRING 
97320: ST_TO_ADDR
// end ;
97321: LD_VAR 0 1
97325: RET
// export function PrepareMastodont ( ) ; begin
97326: LD_INT 0
97328: PPUSH
// uc_side := 0 ;
97329: LD_ADDR_OWVAR 20
97333: PUSH
97334: LD_INT 0
97336: ST_TO_ADDR
// uc_nation := 0 ;
97337: LD_ADDR_OWVAR 21
97341: PUSH
97342: LD_INT 0
97344: ST_TO_ADDR
// vc_chassis := class_mastodont ;
97345: LD_ADDR_OWVAR 37
97349: PUSH
97350: LD_INT 31
97352: ST_TO_ADDR
// vc_control := control_rider ;
97353: LD_ADDR_OWVAR 38
97357: PUSH
97358: LD_INT 4
97360: ST_TO_ADDR
// end ;
97361: LD_VAR 0 1
97365: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97366: LD_INT 0
97368: PPUSH
97369: PPUSH
97370: PPUSH
// uc_side = 0 ;
97371: LD_ADDR_OWVAR 20
97375: PUSH
97376: LD_INT 0
97378: ST_TO_ADDR
// uc_nation = 0 ;
97379: LD_ADDR_OWVAR 21
97383: PUSH
97384: LD_INT 0
97386: ST_TO_ADDR
// InitHc_All ( ) ;
97387: CALL_OW 584
// InitVc ;
97391: CALL_OW 20
// if mastodonts then
97395: LD_VAR 0 6
97399: IFFALSE 97466
// for i = 1 to mastodonts do
97401: LD_ADDR_VAR 0 11
97405: PUSH
97406: DOUBLE
97407: LD_INT 1
97409: DEC
97410: ST_TO_ADDR
97411: LD_VAR 0 6
97415: PUSH
97416: FOR_TO
97417: IFFALSE 97464
// begin vc_chassis := 31 ;
97419: LD_ADDR_OWVAR 37
97423: PUSH
97424: LD_INT 31
97426: ST_TO_ADDR
// vc_control := control_rider ;
97427: LD_ADDR_OWVAR 38
97431: PUSH
97432: LD_INT 4
97434: ST_TO_ADDR
// animal := CreateVehicle ;
97435: LD_ADDR_VAR 0 12
97439: PUSH
97440: CALL_OW 45
97444: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97445: LD_VAR 0 12
97449: PPUSH
97450: LD_VAR 0 8
97454: PPUSH
97455: LD_INT 0
97457: PPUSH
97458: CALL 99594 0 3
// end ;
97462: GO 97416
97464: POP
97465: POP
// if horses then
97466: LD_VAR 0 5
97470: IFFALSE 97537
// for i = 1 to horses do
97472: LD_ADDR_VAR 0 11
97476: PUSH
97477: DOUBLE
97478: LD_INT 1
97480: DEC
97481: ST_TO_ADDR
97482: LD_VAR 0 5
97486: PUSH
97487: FOR_TO
97488: IFFALSE 97535
// begin hc_class := 21 ;
97490: LD_ADDR_OWVAR 28
97494: PUSH
97495: LD_INT 21
97497: ST_TO_ADDR
// hc_gallery :=  ;
97498: LD_ADDR_OWVAR 33
97502: PUSH
97503: LD_STRING 
97505: ST_TO_ADDR
// animal := CreateHuman ;
97506: LD_ADDR_VAR 0 12
97510: PUSH
97511: CALL_OW 44
97515: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97516: LD_VAR 0 12
97520: PPUSH
97521: LD_VAR 0 8
97525: PPUSH
97526: LD_INT 0
97528: PPUSH
97529: CALL 99594 0 3
// end ;
97533: GO 97487
97535: POP
97536: POP
// if birds then
97537: LD_VAR 0 1
97541: IFFALSE 97608
// for i = 1 to birds do
97543: LD_ADDR_VAR 0 11
97547: PUSH
97548: DOUBLE
97549: LD_INT 1
97551: DEC
97552: ST_TO_ADDR
97553: LD_VAR 0 1
97557: PUSH
97558: FOR_TO
97559: IFFALSE 97606
// begin hc_class := 18 ;
97561: LD_ADDR_OWVAR 28
97565: PUSH
97566: LD_INT 18
97568: ST_TO_ADDR
// hc_gallery =  ;
97569: LD_ADDR_OWVAR 33
97573: PUSH
97574: LD_STRING 
97576: ST_TO_ADDR
// animal := CreateHuman ;
97577: LD_ADDR_VAR 0 12
97581: PUSH
97582: CALL_OW 44
97586: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97587: LD_VAR 0 12
97591: PPUSH
97592: LD_VAR 0 8
97596: PPUSH
97597: LD_INT 0
97599: PPUSH
97600: CALL 99594 0 3
// end ;
97604: GO 97558
97606: POP
97607: POP
// if tigers then
97608: LD_VAR 0 2
97612: IFFALSE 97696
// for i = 1 to tigers do
97614: LD_ADDR_VAR 0 11
97618: PUSH
97619: DOUBLE
97620: LD_INT 1
97622: DEC
97623: ST_TO_ADDR
97624: LD_VAR 0 2
97628: PUSH
97629: FOR_TO
97630: IFFALSE 97694
// begin hc_class = class_tiger ;
97632: LD_ADDR_OWVAR 28
97636: PUSH
97637: LD_INT 14
97639: ST_TO_ADDR
// hc_gallery =  ;
97640: LD_ADDR_OWVAR 33
97644: PUSH
97645: LD_STRING 
97647: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97648: LD_ADDR_OWVAR 35
97652: PUSH
97653: LD_INT 7
97655: NEG
97656: PPUSH
97657: LD_INT 7
97659: PPUSH
97660: CALL_OW 12
97664: ST_TO_ADDR
// animal := CreateHuman ;
97665: LD_ADDR_VAR 0 12
97669: PUSH
97670: CALL_OW 44
97674: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97675: LD_VAR 0 12
97679: PPUSH
97680: LD_VAR 0 8
97684: PPUSH
97685: LD_INT 0
97687: PPUSH
97688: CALL 99594 0 3
// end ;
97692: GO 97629
97694: POP
97695: POP
// if apemans then
97696: LD_VAR 0 3
97700: IFFALSE 97823
// for i = 1 to apemans do
97702: LD_ADDR_VAR 0 11
97706: PUSH
97707: DOUBLE
97708: LD_INT 1
97710: DEC
97711: ST_TO_ADDR
97712: LD_VAR 0 3
97716: PUSH
97717: FOR_TO
97718: IFFALSE 97821
// begin hc_class = class_apeman ;
97720: LD_ADDR_OWVAR 28
97724: PUSH
97725: LD_INT 12
97727: ST_TO_ADDR
// hc_gallery =  ;
97728: LD_ADDR_OWVAR 33
97732: PUSH
97733: LD_STRING 
97735: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
97736: LD_ADDR_OWVAR 35
97740: PUSH
97741: LD_INT 2
97743: NEG
97744: PPUSH
97745: LD_INT 2
97747: PPUSH
97748: CALL_OW 12
97752: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97753: LD_ADDR_OWVAR 31
97757: PUSH
97758: LD_INT 1
97760: PPUSH
97761: LD_INT 3
97763: PPUSH
97764: CALL_OW 12
97768: PUSH
97769: LD_INT 1
97771: PPUSH
97772: LD_INT 3
97774: PPUSH
97775: CALL_OW 12
97779: PUSH
97780: LD_INT 0
97782: PUSH
97783: LD_INT 0
97785: PUSH
97786: EMPTY
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: ST_TO_ADDR
// animal := CreateHuman ;
97792: LD_ADDR_VAR 0 12
97796: PUSH
97797: CALL_OW 44
97801: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97802: LD_VAR 0 12
97806: PPUSH
97807: LD_VAR 0 8
97811: PPUSH
97812: LD_INT 0
97814: PPUSH
97815: CALL 99594 0 3
// end ;
97819: GO 97717
97821: POP
97822: POP
// if enchidnas then
97823: LD_VAR 0 4
97827: IFFALSE 97894
// for i = 1 to enchidnas do
97829: LD_ADDR_VAR 0 11
97833: PUSH
97834: DOUBLE
97835: LD_INT 1
97837: DEC
97838: ST_TO_ADDR
97839: LD_VAR 0 4
97843: PUSH
97844: FOR_TO
97845: IFFALSE 97892
// begin hc_class = 13 ;
97847: LD_ADDR_OWVAR 28
97851: PUSH
97852: LD_INT 13
97854: ST_TO_ADDR
// hc_gallery =  ;
97855: LD_ADDR_OWVAR 33
97859: PUSH
97860: LD_STRING 
97862: ST_TO_ADDR
// animal := CreateHuman ;
97863: LD_ADDR_VAR 0 12
97867: PUSH
97868: CALL_OW 44
97872: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97873: LD_VAR 0 12
97877: PPUSH
97878: LD_VAR 0 8
97882: PPUSH
97883: LD_INT 0
97885: PPUSH
97886: CALL 99594 0 3
// end ;
97890: GO 97844
97892: POP
97893: POP
// if fishes then
97894: LD_VAR 0 7
97898: IFFALSE 97965
// for i = 1 to fishes do
97900: LD_ADDR_VAR 0 11
97904: PUSH
97905: DOUBLE
97906: LD_INT 1
97908: DEC
97909: ST_TO_ADDR
97910: LD_VAR 0 7
97914: PUSH
97915: FOR_TO
97916: IFFALSE 97963
// begin hc_class = 20 ;
97918: LD_ADDR_OWVAR 28
97922: PUSH
97923: LD_INT 20
97925: ST_TO_ADDR
// hc_gallery =  ;
97926: LD_ADDR_OWVAR 33
97930: PUSH
97931: LD_STRING 
97933: ST_TO_ADDR
// animal := CreateHuman ;
97934: LD_ADDR_VAR 0 12
97938: PUSH
97939: CALL_OW 44
97943: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
97944: LD_VAR 0 12
97948: PPUSH
97949: LD_VAR 0 9
97953: PPUSH
97954: LD_INT 0
97956: PPUSH
97957: CALL 99594 0 3
// end ;
97961: GO 97915
97963: POP
97964: POP
// end ;
97965: LD_VAR 0 10
97969: RET
// export function WantHeal ( sci , unit ) ; begin
97970: LD_INT 0
97972: PPUSH
// if GetTaskList ( sci ) > 0 then
97973: LD_VAR 0 1
97977: PPUSH
97978: CALL_OW 437
97982: PUSH
97983: LD_INT 0
97985: GREATER
97986: IFFALSE 98056
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
97988: LD_VAR 0 1
97992: PPUSH
97993: CALL_OW 437
97997: PUSH
97998: LD_INT 1
98000: ARRAY
98001: PUSH
98002: LD_INT 1
98004: ARRAY
98005: PUSH
98006: LD_STRING l
98008: EQUAL
98009: PUSH
98010: LD_VAR 0 1
98014: PPUSH
98015: CALL_OW 437
98019: PUSH
98020: LD_INT 1
98022: ARRAY
98023: PUSH
98024: LD_INT 4
98026: ARRAY
98027: PUSH
98028: LD_VAR 0 2
98032: EQUAL
98033: AND
98034: IFFALSE 98046
// result := true else
98036: LD_ADDR_VAR 0 3
98040: PUSH
98041: LD_INT 1
98043: ST_TO_ADDR
98044: GO 98054
// result := false ;
98046: LD_ADDR_VAR 0 3
98050: PUSH
98051: LD_INT 0
98053: ST_TO_ADDR
// end else
98054: GO 98064
// result := false ;
98056: LD_ADDR_VAR 0 3
98060: PUSH
98061: LD_INT 0
98063: ST_TO_ADDR
// end ;
98064: LD_VAR 0 3
98068: RET
// export function HealTarget ( sci ) ; begin
98069: LD_INT 0
98071: PPUSH
// if not sci then
98072: LD_VAR 0 1
98076: NOT
98077: IFFALSE 98081
// exit ;
98079: GO 98146
// result := 0 ;
98081: LD_ADDR_VAR 0 2
98085: PUSH
98086: LD_INT 0
98088: ST_TO_ADDR
// if GetTaskList ( sci ) then
98089: LD_VAR 0 1
98093: PPUSH
98094: CALL_OW 437
98098: IFFALSE 98146
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98100: LD_VAR 0 1
98104: PPUSH
98105: CALL_OW 437
98109: PUSH
98110: LD_INT 1
98112: ARRAY
98113: PUSH
98114: LD_INT 1
98116: ARRAY
98117: PUSH
98118: LD_STRING l
98120: EQUAL
98121: IFFALSE 98146
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98123: LD_ADDR_VAR 0 2
98127: PUSH
98128: LD_VAR 0 1
98132: PPUSH
98133: CALL_OW 437
98137: PUSH
98138: LD_INT 1
98140: ARRAY
98141: PUSH
98142: LD_INT 4
98144: ARRAY
98145: ST_TO_ADDR
// end ;
98146: LD_VAR 0 2
98150: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98151: LD_INT 0
98153: PPUSH
98154: PPUSH
98155: PPUSH
98156: PPUSH
// if not base_units then
98157: LD_VAR 0 1
98161: NOT
98162: IFFALSE 98166
// exit ;
98164: GO 98253
// result := false ;
98166: LD_ADDR_VAR 0 2
98170: PUSH
98171: LD_INT 0
98173: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98174: LD_ADDR_VAR 0 5
98178: PUSH
98179: LD_VAR 0 1
98183: PPUSH
98184: LD_INT 21
98186: PUSH
98187: LD_INT 3
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: PPUSH
98194: CALL_OW 72
98198: ST_TO_ADDR
// if not tmp then
98199: LD_VAR 0 5
98203: NOT
98204: IFFALSE 98208
// exit ;
98206: GO 98253
// for i in tmp do
98208: LD_ADDR_VAR 0 3
98212: PUSH
98213: LD_VAR 0 5
98217: PUSH
98218: FOR_IN
98219: IFFALSE 98251
// begin result := EnemyInRange ( i , 22 ) ;
98221: LD_ADDR_VAR 0 2
98225: PUSH
98226: LD_VAR 0 3
98230: PPUSH
98231: LD_INT 22
98233: PPUSH
98234: CALL 95840 0 2
98238: ST_TO_ADDR
// if result then
98239: LD_VAR 0 2
98243: IFFALSE 98249
// exit ;
98245: POP
98246: POP
98247: GO 98253
// end ;
98249: GO 98218
98251: POP
98252: POP
// end ;
98253: LD_VAR 0 2
98257: RET
// export function FilterByTag ( units , tag ) ; begin
98258: LD_INT 0
98260: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
98261: LD_ADDR_VAR 0 3
98265: PUSH
98266: LD_VAR 0 1
98270: PPUSH
98271: LD_INT 120
98273: PUSH
98274: LD_VAR 0 2
98278: PUSH
98279: EMPTY
98280: LIST
98281: LIST
98282: PPUSH
98283: CALL_OW 72
98287: ST_TO_ADDR
// end ;
98288: LD_VAR 0 3
98292: RET
// export function IsDriver ( un ) ; begin
98293: LD_INT 0
98295: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98296: LD_ADDR_VAR 0 2
98300: PUSH
98301: LD_VAR 0 1
98305: PUSH
98306: LD_INT 55
98308: PUSH
98309: EMPTY
98310: LIST
98311: PPUSH
98312: CALL_OW 69
98316: IN
98317: ST_TO_ADDR
// end ;
98318: LD_VAR 0 2
98322: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98323: LD_INT 0
98325: PPUSH
98326: PPUSH
// list := [ ] ;
98327: LD_ADDR_VAR 0 5
98331: PUSH
98332: EMPTY
98333: ST_TO_ADDR
// case d of 0 :
98334: LD_VAR 0 3
98338: PUSH
98339: LD_INT 0
98341: DOUBLE
98342: EQUAL
98343: IFTRUE 98347
98345: GO 98480
98347: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98348: LD_ADDR_VAR 0 5
98352: PUSH
98353: LD_VAR 0 1
98357: PUSH
98358: LD_INT 4
98360: MINUS
98361: PUSH
98362: LD_VAR 0 2
98366: PUSH
98367: LD_INT 4
98369: MINUS
98370: PUSH
98371: LD_INT 2
98373: PUSH
98374: EMPTY
98375: LIST
98376: LIST
98377: LIST
98378: PUSH
98379: LD_VAR 0 1
98383: PUSH
98384: LD_INT 3
98386: MINUS
98387: PUSH
98388: LD_VAR 0 2
98392: PUSH
98393: LD_INT 1
98395: PUSH
98396: EMPTY
98397: LIST
98398: LIST
98399: LIST
98400: PUSH
98401: LD_VAR 0 1
98405: PUSH
98406: LD_INT 4
98408: PLUS
98409: PUSH
98410: LD_VAR 0 2
98414: PUSH
98415: LD_INT 4
98417: PUSH
98418: EMPTY
98419: LIST
98420: LIST
98421: LIST
98422: PUSH
98423: LD_VAR 0 1
98427: PUSH
98428: LD_INT 3
98430: PLUS
98431: PUSH
98432: LD_VAR 0 2
98436: PUSH
98437: LD_INT 3
98439: PLUS
98440: PUSH
98441: LD_INT 5
98443: PUSH
98444: EMPTY
98445: LIST
98446: LIST
98447: LIST
98448: PUSH
98449: LD_VAR 0 1
98453: PUSH
98454: LD_VAR 0 2
98458: PUSH
98459: LD_INT 4
98461: PLUS
98462: PUSH
98463: LD_INT 0
98465: PUSH
98466: EMPTY
98467: LIST
98468: LIST
98469: LIST
98470: PUSH
98471: EMPTY
98472: LIST
98473: LIST
98474: LIST
98475: LIST
98476: LIST
98477: ST_TO_ADDR
// end ; 1 :
98478: GO 99178
98480: LD_INT 1
98482: DOUBLE
98483: EQUAL
98484: IFTRUE 98488
98486: GO 98621
98488: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98489: LD_ADDR_VAR 0 5
98493: PUSH
98494: LD_VAR 0 1
98498: PUSH
98499: LD_VAR 0 2
98503: PUSH
98504: LD_INT 4
98506: MINUS
98507: PUSH
98508: LD_INT 3
98510: PUSH
98511: EMPTY
98512: LIST
98513: LIST
98514: LIST
98515: PUSH
98516: LD_VAR 0 1
98520: PUSH
98521: LD_INT 3
98523: MINUS
98524: PUSH
98525: LD_VAR 0 2
98529: PUSH
98530: LD_INT 3
98532: MINUS
98533: PUSH
98534: LD_INT 2
98536: PUSH
98537: EMPTY
98538: LIST
98539: LIST
98540: LIST
98541: PUSH
98542: LD_VAR 0 1
98546: PUSH
98547: LD_INT 4
98549: MINUS
98550: PUSH
98551: LD_VAR 0 2
98555: PUSH
98556: LD_INT 1
98558: PUSH
98559: EMPTY
98560: LIST
98561: LIST
98562: LIST
98563: PUSH
98564: LD_VAR 0 1
98568: PUSH
98569: LD_VAR 0 2
98573: PUSH
98574: LD_INT 3
98576: PLUS
98577: PUSH
98578: LD_INT 0
98580: PUSH
98581: EMPTY
98582: LIST
98583: LIST
98584: LIST
98585: PUSH
98586: LD_VAR 0 1
98590: PUSH
98591: LD_INT 4
98593: PLUS
98594: PUSH
98595: LD_VAR 0 2
98599: PUSH
98600: LD_INT 4
98602: PLUS
98603: PUSH
98604: LD_INT 5
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: LIST
98611: PUSH
98612: EMPTY
98613: LIST
98614: LIST
98615: LIST
98616: LIST
98617: LIST
98618: ST_TO_ADDR
// end ; 2 :
98619: GO 99178
98621: LD_INT 2
98623: DOUBLE
98624: EQUAL
98625: IFTRUE 98629
98627: GO 98758
98629: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
98630: LD_ADDR_VAR 0 5
98634: PUSH
98635: LD_VAR 0 1
98639: PUSH
98640: LD_VAR 0 2
98644: PUSH
98645: LD_INT 3
98647: MINUS
98648: PUSH
98649: LD_INT 3
98651: PUSH
98652: EMPTY
98653: LIST
98654: LIST
98655: LIST
98656: PUSH
98657: LD_VAR 0 1
98661: PUSH
98662: LD_INT 4
98664: PLUS
98665: PUSH
98666: LD_VAR 0 2
98670: PUSH
98671: LD_INT 4
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: LIST
98678: PUSH
98679: LD_VAR 0 1
98683: PUSH
98684: LD_VAR 0 2
98688: PUSH
98689: LD_INT 4
98691: PLUS
98692: PUSH
98693: LD_INT 0
98695: PUSH
98696: EMPTY
98697: LIST
98698: LIST
98699: LIST
98700: PUSH
98701: LD_VAR 0 1
98705: PUSH
98706: LD_INT 3
98708: MINUS
98709: PUSH
98710: LD_VAR 0 2
98714: PUSH
98715: LD_INT 1
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: LIST
98722: PUSH
98723: LD_VAR 0 1
98727: PUSH
98728: LD_INT 4
98730: MINUS
98731: PUSH
98732: LD_VAR 0 2
98736: PUSH
98737: LD_INT 4
98739: MINUS
98740: PUSH
98741: LD_INT 2
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: LIST
98748: PUSH
98749: EMPTY
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: ST_TO_ADDR
// end ; 3 :
98756: GO 99178
98758: LD_INT 3
98760: DOUBLE
98761: EQUAL
98762: IFTRUE 98766
98764: GO 98899
98766: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
98767: LD_ADDR_VAR 0 5
98771: PUSH
98772: LD_VAR 0 1
98776: PUSH
98777: LD_INT 3
98779: PLUS
98780: PUSH
98781: LD_VAR 0 2
98785: PUSH
98786: LD_INT 4
98788: PUSH
98789: EMPTY
98790: LIST
98791: LIST
98792: LIST
98793: PUSH
98794: LD_VAR 0 1
98798: PUSH
98799: LD_INT 4
98801: PLUS
98802: PUSH
98803: LD_VAR 0 2
98807: PUSH
98808: LD_INT 4
98810: PLUS
98811: PUSH
98812: LD_INT 5
98814: PUSH
98815: EMPTY
98816: LIST
98817: LIST
98818: LIST
98819: PUSH
98820: LD_VAR 0 1
98824: PUSH
98825: LD_INT 4
98827: MINUS
98828: PUSH
98829: LD_VAR 0 2
98833: PUSH
98834: LD_INT 1
98836: PUSH
98837: EMPTY
98838: LIST
98839: LIST
98840: LIST
98841: PUSH
98842: LD_VAR 0 1
98846: PUSH
98847: LD_VAR 0 2
98851: PUSH
98852: LD_INT 4
98854: MINUS
98855: PUSH
98856: LD_INT 3
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: LIST
98863: PUSH
98864: LD_VAR 0 1
98868: PUSH
98869: LD_INT 3
98871: MINUS
98872: PUSH
98873: LD_VAR 0 2
98877: PUSH
98878: LD_INT 3
98880: MINUS
98881: PUSH
98882: LD_INT 2
98884: PUSH
98885: EMPTY
98886: LIST
98887: LIST
98888: LIST
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: LIST
98894: LIST
98895: LIST
98896: ST_TO_ADDR
// end ; 4 :
98897: GO 99178
98899: LD_INT 4
98901: DOUBLE
98902: EQUAL
98903: IFTRUE 98907
98905: GO 99040
98907: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
98908: LD_ADDR_VAR 0 5
98912: PUSH
98913: LD_VAR 0 1
98917: PUSH
98918: LD_VAR 0 2
98922: PUSH
98923: LD_INT 4
98925: PLUS
98926: PUSH
98927: LD_INT 0
98929: PUSH
98930: EMPTY
98931: LIST
98932: LIST
98933: LIST
98934: PUSH
98935: LD_VAR 0 1
98939: PUSH
98940: LD_INT 3
98942: PLUS
98943: PUSH
98944: LD_VAR 0 2
98948: PUSH
98949: LD_INT 3
98951: PLUS
98952: PUSH
98953: LD_INT 5
98955: PUSH
98956: EMPTY
98957: LIST
98958: LIST
98959: LIST
98960: PUSH
98961: LD_VAR 0 1
98965: PUSH
98966: LD_INT 4
98968: PLUS
98969: PUSH
98970: LD_VAR 0 2
98974: PUSH
98975: LD_INT 4
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: LIST
98982: PUSH
98983: LD_VAR 0 1
98987: PUSH
98988: LD_VAR 0 2
98992: PUSH
98993: LD_INT 3
98995: MINUS
98996: PUSH
98997: LD_INT 3
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: LIST
99004: PUSH
99005: LD_VAR 0 1
99009: PUSH
99010: LD_INT 4
99012: MINUS
99013: PUSH
99014: LD_VAR 0 2
99018: PUSH
99019: LD_INT 4
99021: MINUS
99022: PUSH
99023: LD_INT 2
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: LIST
99030: PUSH
99031: EMPTY
99032: LIST
99033: LIST
99034: LIST
99035: LIST
99036: LIST
99037: ST_TO_ADDR
// end ; 5 :
99038: GO 99178
99040: LD_INT 5
99042: DOUBLE
99043: EQUAL
99044: IFTRUE 99048
99046: GO 99177
99048: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99049: LD_ADDR_VAR 0 5
99053: PUSH
99054: LD_VAR 0 1
99058: PUSH
99059: LD_INT 4
99061: MINUS
99062: PUSH
99063: LD_VAR 0 2
99067: PUSH
99068: LD_INT 1
99070: PUSH
99071: EMPTY
99072: LIST
99073: LIST
99074: LIST
99075: PUSH
99076: LD_VAR 0 1
99080: PUSH
99081: LD_VAR 0 2
99085: PUSH
99086: LD_INT 4
99088: MINUS
99089: PUSH
99090: LD_INT 3
99092: PUSH
99093: EMPTY
99094: LIST
99095: LIST
99096: LIST
99097: PUSH
99098: LD_VAR 0 1
99102: PUSH
99103: LD_INT 4
99105: PLUS
99106: PUSH
99107: LD_VAR 0 2
99111: PUSH
99112: LD_INT 4
99114: PLUS
99115: PUSH
99116: LD_INT 5
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: LIST
99123: PUSH
99124: LD_VAR 0 1
99128: PUSH
99129: LD_INT 3
99131: PLUS
99132: PUSH
99133: LD_VAR 0 2
99137: PUSH
99138: LD_INT 4
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: LIST
99145: PUSH
99146: LD_VAR 0 1
99150: PUSH
99151: LD_VAR 0 2
99155: PUSH
99156: LD_INT 3
99158: PLUS
99159: PUSH
99160: LD_INT 0
99162: PUSH
99163: EMPTY
99164: LIST
99165: LIST
99166: LIST
99167: PUSH
99168: EMPTY
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: ST_TO_ADDR
// end ; end ;
99175: GO 99178
99177: POP
// result := list ;
99178: LD_ADDR_VAR 0 4
99182: PUSH
99183: LD_VAR 0 5
99187: ST_TO_ADDR
// end ;
99188: LD_VAR 0 4
99192: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99193: LD_INT 0
99195: PPUSH
99196: PPUSH
99197: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99198: LD_VAR 0 1
99202: NOT
99203: PUSH
99204: LD_VAR 0 2
99208: PUSH
99209: LD_INT 1
99211: PUSH
99212: LD_INT 2
99214: PUSH
99215: LD_INT 3
99217: PUSH
99218: LD_INT 4
99220: PUSH
99221: EMPTY
99222: LIST
99223: LIST
99224: LIST
99225: LIST
99226: IN
99227: NOT
99228: OR
99229: IFFALSE 99233
// exit ;
99231: GO 99316
// tmp := [ ] ;
99233: LD_ADDR_VAR 0 5
99237: PUSH
99238: EMPTY
99239: ST_TO_ADDR
// for i in units do
99240: LD_ADDR_VAR 0 4
99244: PUSH
99245: LD_VAR 0 1
99249: PUSH
99250: FOR_IN
99251: IFFALSE 99285
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
99253: LD_ADDR_VAR 0 5
99257: PUSH
99258: LD_VAR 0 5
99262: PPUSH
99263: LD_VAR 0 4
99267: PPUSH
99268: LD_VAR 0 2
99272: PPUSH
99273: CALL_OW 259
99277: PPUSH
99278: CALL 100676 0 2
99282: ST_TO_ADDR
99283: GO 99250
99285: POP
99286: POP
// if not tmp then
99287: LD_VAR 0 5
99291: NOT
99292: IFFALSE 99296
// exit ;
99294: GO 99316
// result := SortListByListDesc ( units , tmp ) ;
99296: LD_ADDR_VAR 0 3
99300: PUSH
99301: LD_VAR 0 1
99305: PPUSH
99306: LD_VAR 0 5
99310: PPUSH
99311: CALL_OW 77
99315: ST_TO_ADDR
// end ;
99316: LD_VAR 0 3
99320: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99321: LD_INT 0
99323: PPUSH
99324: PPUSH
99325: PPUSH
// result := false ;
99326: LD_ADDR_VAR 0 3
99330: PUSH
99331: LD_INT 0
99333: ST_TO_ADDR
// if not building then
99334: LD_VAR 0 2
99338: NOT
99339: IFFALSE 99343
// exit ;
99341: GO 99481
// x := GetX ( building ) ;
99343: LD_ADDR_VAR 0 4
99347: PUSH
99348: LD_VAR 0 2
99352: PPUSH
99353: CALL_OW 250
99357: ST_TO_ADDR
// y := GetY ( building ) ;
99358: LD_ADDR_VAR 0 5
99362: PUSH
99363: LD_VAR 0 2
99367: PPUSH
99368: CALL_OW 251
99372: ST_TO_ADDR
// if not x or not y then
99373: LD_VAR 0 4
99377: NOT
99378: PUSH
99379: LD_VAR 0 5
99383: NOT
99384: OR
99385: IFFALSE 99389
// exit ;
99387: GO 99481
// if GetTaskList ( unit ) then
99389: LD_VAR 0 1
99393: PPUSH
99394: CALL_OW 437
99398: IFFALSE 99481
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99400: LD_STRING e
99402: PUSH
99403: LD_VAR 0 1
99407: PPUSH
99408: CALL_OW 437
99412: PUSH
99413: LD_INT 1
99415: ARRAY
99416: PUSH
99417: LD_INT 1
99419: ARRAY
99420: EQUAL
99421: PUSH
99422: LD_VAR 0 4
99426: PUSH
99427: LD_VAR 0 1
99431: PPUSH
99432: CALL_OW 437
99436: PUSH
99437: LD_INT 1
99439: ARRAY
99440: PUSH
99441: LD_INT 2
99443: ARRAY
99444: EQUAL
99445: AND
99446: PUSH
99447: LD_VAR 0 5
99451: PUSH
99452: LD_VAR 0 1
99456: PPUSH
99457: CALL_OW 437
99461: PUSH
99462: LD_INT 1
99464: ARRAY
99465: PUSH
99466: LD_INT 3
99468: ARRAY
99469: EQUAL
99470: AND
99471: IFFALSE 99481
// result := true end ;
99473: LD_ADDR_VAR 0 3
99477: PUSH
99478: LD_INT 1
99480: ST_TO_ADDR
// end ;
99481: LD_VAR 0 3
99485: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99486: LD_INT 0
99488: PPUSH
// result := false ;
99489: LD_ADDR_VAR 0 4
99493: PUSH
99494: LD_INT 0
99496: ST_TO_ADDR
// if GetTaskList ( unit ) then
99497: LD_VAR 0 1
99501: PPUSH
99502: CALL_OW 437
99506: IFFALSE 99589
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99508: LD_STRING M
99510: PUSH
99511: LD_VAR 0 1
99515: PPUSH
99516: CALL_OW 437
99520: PUSH
99521: LD_INT 1
99523: ARRAY
99524: PUSH
99525: LD_INT 1
99527: ARRAY
99528: EQUAL
99529: PUSH
99530: LD_VAR 0 2
99534: PUSH
99535: LD_VAR 0 1
99539: PPUSH
99540: CALL_OW 437
99544: PUSH
99545: LD_INT 1
99547: ARRAY
99548: PUSH
99549: LD_INT 2
99551: ARRAY
99552: EQUAL
99553: AND
99554: PUSH
99555: LD_VAR 0 3
99559: PUSH
99560: LD_VAR 0 1
99564: PPUSH
99565: CALL_OW 437
99569: PUSH
99570: LD_INT 1
99572: ARRAY
99573: PUSH
99574: LD_INT 3
99576: ARRAY
99577: EQUAL
99578: AND
99579: IFFALSE 99589
// result := true ;
99581: LD_ADDR_VAR 0 4
99585: PUSH
99586: LD_INT 1
99588: ST_TO_ADDR
// end ; end ;
99589: LD_VAR 0 4
99593: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99594: LD_INT 0
99596: PPUSH
99597: PPUSH
99598: PPUSH
99599: PPUSH
// if not unit or not area then
99600: LD_VAR 0 1
99604: NOT
99605: PUSH
99606: LD_VAR 0 2
99610: NOT
99611: OR
99612: IFFALSE 99616
// exit ;
99614: GO 99779
// tmp := AreaToList ( area , i ) ;
99616: LD_ADDR_VAR 0 6
99620: PUSH
99621: LD_VAR 0 2
99625: PPUSH
99626: LD_VAR 0 5
99630: PPUSH
99631: CALL_OW 517
99635: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99636: LD_ADDR_VAR 0 5
99640: PUSH
99641: DOUBLE
99642: LD_INT 1
99644: DEC
99645: ST_TO_ADDR
99646: LD_VAR 0 6
99650: PUSH
99651: LD_INT 1
99653: ARRAY
99654: PUSH
99655: FOR_TO
99656: IFFALSE 99777
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99658: LD_ADDR_VAR 0 7
99662: PUSH
99663: LD_VAR 0 6
99667: PUSH
99668: LD_INT 1
99670: ARRAY
99671: PUSH
99672: LD_VAR 0 5
99676: ARRAY
99677: PUSH
99678: LD_VAR 0 6
99682: PUSH
99683: LD_INT 2
99685: ARRAY
99686: PUSH
99687: LD_VAR 0 5
99691: ARRAY
99692: PUSH
99693: EMPTY
99694: LIST
99695: LIST
99696: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
99697: LD_INT 92
99699: PUSH
99700: LD_VAR 0 7
99704: PUSH
99705: LD_INT 1
99707: ARRAY
99708: PUSH
99709: LD_VAR 0 7
99713: PUSH
99714: LD_INT 2
99716: ARRAY
99717: PUSH
99718: LD_INT 3
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: LIST
99725: LIST
99726: PPUSH
99727: CALL_OW 69
99731: PUSH
99732: LD_INT 0
99734: EQUAL
99735: IFFALSE 99775
// begin PlaceUnitArea ( unit , area , mode ) ;
99737: LD_VAR 0 1
99741: PPUSH
99742: LD_VAR 0 2
99746: PPUSH
99747: LD_VAR 0 3
99751: PPUSH
99752: CALL_OW 49
// result := IsPlaced ( unit ) ;
99756: LD_ADDR_VAR 0 4
99760: PUSH
99761: LD_VAR 0 1
99765: PPUSH
99766: CALL_OW 305
99770: ST_TO_ADDR
// exit ;
99771: POP
99772: POP
99773: GO 99779
// end ; end ;
99775: GO 99655
99777: POP
99778: POP
// end ;
99779: LD_VAR 0 4
99783: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
99784: LD_INT 0
99786: PPUSH
99787: PPUSH
99788: PPUSH
// if not side or side > 8 then
99789: LD_VAR 0 1
99793: NOT
99794: PUSH
99795: LD_VAR 0 1
99799: PUSH
99800: LD_INT 8
99802: GREATER
99803: OR
99804: IFFALSE 99808
// exit ;
99806: GO 99995
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
99808: LD_ADDR_VAR 0 4
99812: PUSH
99813: LD_INT 22
99815: PUSH
99816: LD_VAR 0 1
99820: PUSH
99821: EMPTY
99822: LIST
99823: LIST
99824: PUSH
99825: LD_INT 21
99827: PUSH
99828: LD_INT 3
99830: PUSH
99831: EMPTY
99832: LIST
99833: LIST
99834: PUSH
99835: EMPTY
99836: LIST
99837: LIST
99838: PPUSH
99839: CALL_OW 69
99843: ST_TO_ADDR
// if not tmp then
99844: LD_VAR 0 4
99848: NOT
99849: IFFALSE 99853
// exit ;
99851: GO 99995
// enable_addtolog := true ;
99853: LD_ADDR_OWVAR 81
99857: PUSH
99858: LD_INT 1
99860: ST_TO_ADDR
// AddToLog ( [ ) ;
99861: LD_STRING [
99863: PPUSH
99864: CALL_OW 561
// for i in tmp do
99868: LD_ADDR_VAR 0 3
99872: PUSH
99873: LD_VAR 0 4
99877: PUSH
99878: FOR_IN
99879: IFFALSE 99986
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
99881: LD_STRING [
99883: PUSH
99884: LD_VAR 0 3
99888: PPUSH
99889: CALL_OW 266
99893: STR
99894: PUSH
99895: LD_STRING , 
99897: STR
99898: PUSH
99899: LD_VAR 0 3
99903: PPUSH
99904: CALL_OW 250
99908: STR
99909: PUSH
99910: LD_STRING , 
99912: STR
99913: PUSH
99914: LD_VAR 0 3
99918: PPUSH
99919: CALL_OW 251
99923: STR
99924: PUSH
99925: LD_STRING , 
99927: STR
99928: PUSH
99929: LD_VAR 0 3
99933: PPUSH
99934: CALL_OW 254
99938: STR
99939: PUSH
99940: LD_STRING , 
99942: STR
99943: PUSH
99944: LD_VAR 0 3
99948: PPUSH
99949: LD_INT 1
99951: PPUSH
99952: CALL_OW 268
99956: STR
99957: PUSH
99958: LD_STRING , 
99960: STR
99961: PUSH
99962: LD_VAR 0 3
99966: PPUSH
99967: LD_INT 2
99969: PPUSH
99970: CALL_OW 268
99974: STR
99975: PUSH
99976: LD_STRING ],
99978: STR
99979: PPUSH
99980: CALL_OW 561
// end ;
99984: GO 99878
99986: POP
99987: POP
// AddToLog ( ]; ) ;
99988: LD_STRING ];
99990: PPUSH
99991: CALL_OW 561
// end ;
99995: LD_VAR 0 2
99999: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100000: LD_INT 0
100002: PPUSH
100003: PPUSH
100004: PPUSH
100005: PPUSH
100006: PPUSH
// if not area or not rate or not max then
100007: LD_VAR 0 1
100011: NOT
100012: PUSH
100013: LD_VAR 0 2
100017: NOT
100018: OR
100019: PUSH
100020: LD_VAR 0 4
100024: NOT
100025: OR
100026: IFFALSE 100030
// exit ;
100028: GO 100219
// while 1 do
100030: LD_INT 1
100032: IFFALSE 100219
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100034: LD_ADDR_VAR 0 9
100038: PUSH
100039: LD_VAR 0 1
100043: PPUSH
100044: LD_INT 1
100046: PPUSH
100047: CALL_OW 287
100051: PUSH
100052: LD_INT 10
100054: MUL
100055: ST_TO_ADDR
// r := rate / 10 ;
100056: LD_ADDR_VAR 0 7
100060: PUSH
100061: LD_VAR 0 2
100065: PUSH
100066: LD_INT 10
100068: DIVREAL
100069: ST_TO_ADDR
// time := 1 1$00 ;
100070: LD_ADDR_VAR 0 8
100074: PUSH
100075: LD_INT 2100
100077: ST_TO_ADDR
// if amount < min then
100078: LD_VAR 0 9
100082: PUSH
100083: LD_VAR 0 3
100087: LESS
100088: IFFALSE 100106
// r := r * 2 else
100090: LD_ADDR_VAR 0 7
100094: PUSH
100095: LD_VAR 0 7
100099: PUSH
100100: LD_INT 2
100102: MUL
100103: ST_TO_ADDR
100104: GO 100132
// if amount > max then
100106: LD_VAR 0 9
100110: PUSH
100111: LD_VAR 0 4
100115: GREATER
100116: IFFALSE 100132
// r := r / 2 ;
100118: LD_ADDR_VAR 0 7
100122: PUSH
100123: LD_VAR 0 7
100127: PUSH
100128: LD_INT 2
100130: DIVREAL
100131: ST_TO_ADDR
// time := time / r ;
100132: LD_ADDR_VAR 0 8
100136: PUSH
100137: LD_VAR 0 8
100141: PUSH
100142: LD_VAR 0 7
100146: DIVREAL
100147: ST_TO_ADDR
// if time < 0 then
100148: LD_VAR 0 8
100152: PUSH
100153: LD_INT 0
100155: LESS
100156: IFFALSE 100173
// time := time * - 1 ;
100158: LD_ADDR_VAR 0 8
100162: PUSH
100163: LD_VAR 0 8
100167: PUSH
100168: LD_INT 1
100170: NEG
100171: MUL
100172: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
100173: LD_VAR 0 8
100177: PUSH
100178: LD_INT 35
100180: PPUSH
100181: LD_INT 875
100183: PPUSH
100184: CALL_OW 12
100188: PLUS
100189: PPUSH
100190: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100194: LD_INT 1
100196: PPUSH
100197: LD_INT 5
100199: PPUSH
100200: CALL_OW 12
100204: PPUSH
100205: LD_VAR 0 1
100209: PPUSH
100210: LD_INT 1
100212: PPUSH
100213: CALL_OW 55
// end ;
100217: GO 100030
// end ;
100219: LD_VAR 0 5
100223: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100224: LD_INT 0
100226: PPUSH
100227: PPUSH
100228: PPUSH
100229: PPUSH
100230: PPUSH
100231: PPUSH
100232: PPUSH
100233: PPUSH
// if not turrets or not factories then
100234: LD_VAR 0 1
100238: NOT
100239: PUSH
100240: LD_VAR 0 2
100244: NOT
100245: OR
100246: IFFALSE 100250
// exit ;
100248: GO 100557
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100250: LD_ADDR_VAR 0 10
100254: PUSH
100255: LD_INT 5
100257: PUSH
100258: LD_INT 6
100260: PUSH
100261: EMPTY
100262: LIST
100263: LIST
100264: PUSH
100265: LD_INT 2
100267: PUSH
100268: LD_INT 4
100270: PUSH
100271: EMPTY
100272: LIST
100273: LIST
100274: PUSH
100275: LD_INT 3
100277: PUSH
100278: LD_INT 5
100280: PUSH
100281: EMPTY
100282: LIST
100283: LIST
100284: PUSH
100285: EMPTY
100286: LIST
100287: LIST
100288: LIST
100289: PUSH
100290: LD_INT 24
100292: PUSH
100293: LD_INT 25
100295: PUSH
100296: EMPTY
100297: LIST
100298: LIST
100299: PUSH
100300: LD_INT 23
100302: PUSH
100303: LD_INT 27
100305: PUSH
100306: EMPTY
100307: LIST
100308: LIST
100309: PUSH
100310: EMPTY
100311: LIST
100312: LIST
100313: PUSH
100314: LD_INT 42
100316: PUSH
100317: LD_INT 43
100319: PUSH
100320: EMPTY
100321: LIST
100322: LIST
100323: PUSH
100324: LD_INT 44
100326: PUSH
100327: LD_INT 46
100329: PUSH
100330: EMPTY
100331: LIST
100332: LIST
100333: PUSH
100334: LD_INT 45
100336: PUSH
100337: LD_INT 47
100339: PUSH
100340: EMPTY
100341: LIST
100342: LIST
100343: PUSH
100344: EMPTY
100345: LIST
100346: LIST
100347: LIST
100348: PUSH
100349: EMPTY
100350: LIST
100351: LIST
100352: LIST
100353: ST_TO_ADDR
// result := [ ] ;
100354: LD_ADDR_VAR 0 3
100358: PUSH
100359: EMPTY
100360: ST_TO_ADDR
// for i in turrets do
100361: LD_ADDR_VAR 0 4
100365: PUSH
100366: LD_VAR 0 1
100370: PUSH
100371: FOR_IN
100372: IFFALSE 100555
// begin nat := GetNation ( i ) ;
100374: LD_ADDR_VAR 0 7
100378: PUSH
100379: LD_VAR 0 4
100383: PPUSH
100384: CALL_OW 248
100388: ST_TO_ADDR
// weapon := 0 ;
100389: LD_ADDR_VAR 0 8
100393: PUSH
100394: LD_INT 0
100396: ST_TO_ADDR
// if not nat then
100397: LD_VAR 0 7
100401: NOT
100402: IFFALSE 100406
// continue ;
100404: GO 100371
// for j in list [ nat ] do
100406: LD_ADDR_VAR 0 5
100410: PUSH
100411: LD_VAR 0 10
100415: PUSH
100416: LD_VAR 0 7
100420: ARRAY
100421: PUSH
100422: FOR_IN
100423: IFFALSE 100464
// if GetBWeapon ( i ) = j [ 1 ] then
100425: LD_VAR 0 4
100429: PPUSH
100430: CALL_OW 269
100434: PUSH
100435: LD_VAR 0 5
100439: PUSH
100440: LD_INT 1
100442: ARRAY
100443: EQUAL
100444: IFFALSE 100462
// begin weapon := j [ 2 ] ;
100446: LD_ADDR_VAR 0 8
100450: PUSH
100451: LD_VAR 0 5
100455: PUSH
100456: LD_INT 2
100458: ARRAY
100459: ST_TO_ADDR
// break ;
100460: GO 100464
// end ;
100462: GO 100422
100464: POP
100465: POP
// if not weapon then
100466: LD_VAR 0 8
100470: NOT
100471: IFFALSE 100475
// continue ;
100473: GO 100371
// for k in factories do
100475: LD_ADDR_VAR 0 6
100479: PUSH
100480: LD_VAR 0 2
100484: PUSH
100485: FOR_IN
100486: IFFALSE 100551
// begin weapons := AvailableWeaponList ( k ) ;
100488: LD_ADDR_VAR 0 9
100492: PUSH
100493: LD_VAR 0 6
100497: PPUSH
100498: CALL_OW 478
100502: ST_TO_ADDR
// if not weapons then
100503: LD_VAR 0 9
100507: NOT
100508: IFFALSE 100512
// continue ;
100510: GO 100485
// if weapon in weapons then
100512: LD_VAR 0 8
100516: PUSH
100517: LD_VAR 0 9
100521: IN
100522: IFFALSE 100549
// begin result := [ i , weapon ] ;
100524: LD_ADDR_VAR 0 3
100528: PUSH
100529: LD_VAR 0 4
100533: PUSH
100534: LD_VAR 0 8
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: ST_TO_ADDR
// exit ;
100543: POP
100544: POP
100545: POP
100546: POP
100547: GO 100557
// end ; end ;
100549: GO 100485
100551: POP
100552: POP
// end ;
100553: GO 100371
100555: POP
100556: POP
// end ;
100557: LD_VAR 0 3
100561: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100562: LD_INT 0
100564: PPUSH
// if not side or side > 8 then
100565: LD_VAR 0 3
100569: NOT
100570: PUSH
100571: LD_VAR 0 3
100575: PUSH
100576: LD_INT 8
100578: GREATER
100579: OR
100580: IFFALSE 100584
// exit ;
100582: GO 100643
// if not range then
100584: LD_VAR 0 4
100588: NOT
100589: IFFALSE 100600
// range := - 12 ;
100591: LD_ADDR_VAR 0 4
100595: PUSH
100596: LD_INT 12
100598: NEG
100599: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100600: LD_VAR 0 1
100604: PPUSH
100605: LD_VAR 0 2
100609: PPUSH
100610: LD_VAR 0 3
100614: PPUSH
100615: LD_VAR 0 4
100619: PPUSH
100620: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100624: LD_VAR 0 1
100628: PPUSH
100629: LD_VAR 0 2
100633: PPUSH
100634: LD_VAR 0 3
100638: PPUSH
100639: CALL_OW 331
// end ;
100643: LD_VAR 0 5
100647: RET
// export function Video ( mode ) ; begin
100648: LD_INT 0
100650: PPUSH
// ingame_video = mode ;
100651: LD_ADDR_OWVAR 52
100655: PUSH
100656: LD_VAR 0 1
100660: ST_TO_ADDR
// interface_hidden = mode ;
100661: LD_ADDR_OWVAR 54
100665: PUSH
100666: LD_VAR 0 1
100670: ST_TO_ADDR
// end ;
100671: LD_VAR 0 2
100675: RET
// export function Join ( array , element ) ; begin
100676: LD_INT 0
100678: PPUSH
// result := Replace ( array , array + 1 , element ) ;
100679: LD_ADDR_VAR 0 3
100683: PUSH
100684: LD_VAR 0 1
100688: PPUSH
100689: LD_VAR 0 1
100693: PUSH
100694: LD_INT 1
100696: PLUS
100697: PPUSH
100698: LD_VAR 0 2
100702: PPUSH
100703: CALL_OW 1
100707: ST_TO_ADDR
// end ;
100708: LD_VAR 0 3
100712: RET
// export function JoinUnion ( array , element ) ; begin
100713: LD_INT 0
100715: PPUSH
// result := array union element ;
100716: LD_ADDR_VAR 0 3
100720: PUSH
100721: LD_VAR 0 1
100725: PUSH
100726: LD_VAR 0 2
100730: UNION
100731: ST_TO_ADDR
// end ;
100732: LD_VAR 0 3
100736: RET
// export function GetBehemoths ( side ) ; begin
100737: LD_INT 0
100739: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
100740: LD_ADDR_VAR 0 2
100744: PUSH
100745: LD_INT 22
100747: PUSH
100748: LD_VAR 0 1
100752: PUSH
100753: EMPTY
100754: LIST
100755: LIST
100756: PUSH
100757: LD_INT 31
100759: PUSH
100760: LD_INT 25
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: PUSH
100767: EMPTY
100768: LIST
100769: LIST
100770: PPUSH
100771: CALL_OW 69
100775: ST_TO_ADDR
// end ;
100776: LD_VAR 0 2
100780: RET
// export function Shuffle ( array ) ; var i , index ; begin
100781: LD_INT 0
100783: PPUSH
100784: PPUSH
100785: PPUSH
// result := [ ] ;
100786: LD_ADDR_VAR 0 2
100790: PUSH
100791: EMPTY
100792: ST_TO_ADDR
// if not array then
100793: LD_VAR 0 1
100797: NOT
100798: IFFALSE 100802
// exit ;
100800: GO 100901
// Randomize ;
100802: CALL_OW 10
// for i = array downto 1 do
100806: LD_ADDR_VAR 0 3
100810: PUSH
100811: DOUBLE
100812: LD_VAR 0 1
100816: INC
100817: ST_TO_ADDR
100818: LD_INT 1
100820: PUSH
100821: FOR_DOWNTO
100822: IFFALSE 100899
// begin index := rand ( 1 , array ) ;
100824: LD_ADDR_VAR 0 4
100828: PUSH
100829: LD_INT 1
100831: PPUSH
100832: LD_VAR 0 1
100836: PPUSH
100837: CALL_OW 12
100841: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
100842: LD_ADDR_VAR 0 2
100846: PUSH
100847: LD_VAR 0 2
100851: PPUSH
100852: LD_VAR 0 2
100856: PUSH
100857: LD_INT 1
100859: PLUS
100860: PPUSH
100861: LD_VAR 0 1
100865: PUSH
100866: LD_VAR 0 4
100870: ARRAY
100871: PPUSH
100872: CALL_OW 2
100876: ST_TO_ADDR
// array := Delete ( array , index ) ;
100877: LD_ADDR_VAR 0 1
100881: PUSH
100882: LD_VAR 0 1
100886: PPUSH
100887: LD_VAR 0 4
100891: PPUSH
100892: CALL_OW 3
100896: ST_TO_ADDR
// end ;
100897: GO 100821
100899: POP
100900: POP
// end ;
100901: LD_VAR 0 2
100905: RET
// export function GetBaseMaterials ( base ) ; begin
100906: LD_INT 0
100908: PPUSH
// result := [ 0 , 0 , 0 ] ;
100909: LD_ADDR_VAR 0 2
100913: PUSH
100914: LD_INT 0
100916: PUSH
100917: LD_INT 0
100919: PUSH
100920: LD_INT 0
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: LIST
100927: ST_TO_ADDR
// if not base then
100928: LD_VAR 0 1
100932: NOT
100933: IFFALSE 100937
// exit ;
100935: GO 100986
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
100937: LD_ADDR_VAR 0 2
100941: PUSH
100942: LD_VAR 0 1
100946: PPUSH
100947: LD_INT 1
100949: PPUSH
100950: CALL_OW 275
100954: PUSH
100955: LD_VAR 0 1
100959: PPUSH
100960: LD_INT 2
100962: PPUSH
100963: CALL_OW 275
100967: PUSH
100968: LD_VAR 0 1
100972: PPUSH
100973: LD_INT 3
100975: PPUSH
100976: CALL_OW 275
100980: PUSH
100981: EMPTY
100982: LIST
100983: LIST
100984: LIST
100985: ST_TO_ADDR
// end ;
100986: LD_VAR 0 2
100990: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
100991: LD_INT 0
100993: PPUSH
100994: PPUSH
// result := array ;
100995: LD_ADDR_VAR 0 3
100999: PUSH
101000: LD_VAR 0 1
101004: ST_TO_ADDR
// if size >= result then
101005: LD_VAR 0 2
101009: PUSH
101010: LD_VAR 0 3
101014: GREATEREQUAL
101015: IFFALSE 101019
// exit ;
101017: GO 101069
// if size then
101019: LD_VAR 0 2
101023: IFFALSE 101069
// for i := array downto size do
101025: LD_ADDR_VAR 0 4
101029: PUSH
101030: DOUBLE
101031: LD_VAR 0 1
101035: INC
101036: ST_TO_ADDR
101037: LD_VAR 0 2
101041: PUSH
101042: FOR_DOWNTO
101043: IFFALSE 101067
// result := Delete ( result , result ) ;
101045: LD_ADDR_VAR 0 3
101049: PUSH
101050: LD_VAR 0 3
101054: PPUSH
101055: LD_VAR 0 3
101059: PPUSH
101060: CALL_OW 3
101064: ST_TO_ADDR
101065: GO 101042
101067: POP
101068: POP
// end ;
101069: LD_VAR 0 3
101073: RET
// export function ComExit ( unit ) ; var tmp ; begin
101074: LD_INT 0
101076: PPUSH
101077: PPUSH
// if not IsInUnit ( unit ) then
101078: LD_VAR 0 1
101082: PPUSH
101083: CALL_OW 310
101087: NOT
101088: IFFALSE 101092
// exit ;
101090: GO 101152
// tmp := IsInUnit ( unit ) ;
101092: LD_ADDR_VAR 0 3
101096: PUSH
101097: LD_VAR 0 1
101101: PPUSH
101102: CALL_OW 310
101106: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101107: LD_VAR 0 3
101111: PPUSH
101112: CALL_OW 247
101116: PUSH
101117: LD_INT 2
101119: EQUAL
101120: IFFALSE 101133
// ComExitVehicle ( unit ) else
101122: LD_VAR 0 1
101126: PPUSH
101127: CALL_OW 121
101131: GO 101142
// ComExitBuilding ( unit ) ;
101133: LD_VAR 0 1
101137: PPUSH
101138: CALL_OW 122
// result := tmp ;
101142: LD_ADDR_VAR 0 2
101146: PUSH
101147: LD_VAR 0 3
101151: ST_TO_ADDR
// end ;
101152: LD_VAR 0 2
101156: RET
// export function ComExitAll ( units ) ; var i ; begin
101157: LD_INT 0
101159: PPUSH
101160: PPUSH
// if not units then
101161: LD_VAR 0 1
101165: NOT
101166: IFFALSE 101170
// exit ;
101168: GO 101196
// for i in units do
101170: LD_ADDR_VAR 0 3
101174: PUSH
101175: LD_VAR 0 1
101179: PUSH
101180: FOR_IN
101181: IFFALSE 101194
// ComExit ( i ) ;
101183: LD_VAR 0 3
101187: PPUSH
101188: CALL 101074 0 1
101192: GO 101180
101194: POP
101195: POP
// end ;
101196: LD_VAR 0 2
101200: RET
// export function ResetHc ; begin
101201: LD_INT 0
101203: PPUSH
// InitHc ;
101204: CALL_OW 19
// hc_importance := 0 ;
101208: LD_ADDR_OWVAR 32
101212: PUSH
101213: LD_INT 0
101215: ST_TO_ADDR
// end ;
101216: LD_VAR 0 1
101220: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101221: LD_INT 0
101223: PPUSH
101224: PPUSH
101225: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101226: LD_ADDR_VAR 0 6
101230: PUSH
101231: LD_VAR 0 1
101235: PUSH
101236: LD_VAR 0 3
101240: PLUS
101241: PUSH
101242: LD_INT 2
101244: DIV
101245: ST_TO_ADDR
// if _x < 0 then
101246: LD_VAR 0 6
101250: PUSH
101251: LD_INT 0
101253: LESS
101254: IFFALSE 101271
// _x := _x * - 1 ;
101256: LD_ADDR_VAR 0 6
101260: PUSH
101261: LD_VAR 0 6
101265: PUSH
101266: LD_INT 1
101268: NEG
101269: MUL
101270: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101271: LD_ADDR_VAR 0 7
101275: PUSH
101276: LD_VAR 0 2
101280: PUSH
101281: LD_VAR 0 4
101285: PLUS
101286: PUSH
101287: LD_INT 2
101289: DIV
101290: ST_TO_ADDR
// if _y < 0 then
101291: LD_VAR 0 7
101295: PUSH
101296: LD_INT 0
101298: LESS
101299: IFFALSE 101316
// _y := _y * - 1 ;
101301: LD_ADDR_VAR 0 7
101305: PUSH
101306: LD_VAR 0 7
101310: PUSH
101311: LD_INT 1
101313: NEG
101314: MUL
101315: ST_TO_ADDR
// result := [ _x , _y ] ;
101316: LD_ADDR_VAR 0 5
101320: PUSH
101321: LD_VAR 0 6
101325: PUSH
101326: LD_VAR 0 7
101330: PUSH
101331: EMPTY
101332: LIST
101333: LIST
101334: ST_TO_ADDR
// end ;
101335: LD_VAR 0 5
101339: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101340: LD_INT 0
101342: PPUSH
101343: PPUSH
101344: PPUSH
101345: PPUSH
// task := GetTaskList ( unit ) ;
101346: LD_ADDR_VAR 0 7
101350: PUSH
101351: LD_VAR 0 1
101355: PPUSH
101356: CALL_OW 437
101360: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101361: LD_VAR 0 7
101365: NOT
101366: PUSH
101367: LD_VAR 0 1
101371: PPUSH
101372: LD_VAR 0 2
101376: PPUSH
101377: CALL_OW 308
101381: NOT
101382: AND
101383: IFFALSE 101387
// exit ;
101385: GO 101505
// if IsInArea ( unit , area ) then
101387: LD_VAR 0 1
101391: PPUSH
101392: LD_VAR 0 2
101396: PPUSH
101397: CALL_OW 308
101401: IFFALSE 101419
// begin ComMoveToArea ( unit , goAway ) ;
101403: LD_VAR 0 1
101407: PPUSH
101408: LD_VAR 0 3
101412: PPUSH
101413: CALL_OW 113
// exit ;
101417: GO 101505
// end ; if task [ 1 ] [ 1 ] <> M then
101419: LD_VAR 0 7
101423: PUSH
101424: LD_INT 1
101426: ARRAY
101427: PUSH
101428: LD_INT 1
101430: ARRAY
101431: PUSH
101432: LD_STRING M
101434: NONEQUAL
101435: IFFALSE 101439
// exit ;
101437: GO 101505
// x := task [ 1 ] [ 2 ] ;
101439: LD_ADDR_VAR 0 5
101443: PUSH
101444: LD_VAR 0 7
101448: PUSH
101449: LD_INT 1
101451: ARRAY
101452: PUSH
101453: LD_INT 2
101455: ARRAY
101456: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101457: LD_ADDR_VAR 0 6
101461: PUSH
101462: LD_VAR 0 7
101466: PUSH
101467: LD_INT 1
101469: ARRAY
101470: PUSH
101471: LD_INT 3
101473: ARRAY
101474: ST_TO_ADDR
// if InArea ( x , y , area ) then
101475: LD_VAR 0 5
101479: PPUSH
101480: LD_VAR 0 6
101484: PPUSH
101485: LD_VAR 0 2
101489: PPUSH
101490: CALL_OW 309
101494: IFFALSE 101505
// ComStop ( unit ) ;
101496: LD_VAR 0 1
101500: PPUSH
101501: CALL_OW 141
// end ;
101505: LD_VAR 0 4
101509: RET
// export function Abs ( value ) ; begin
101510: LD_INT 0
101512: PPUSH
// result := value ;
101513: LD_ADDR_VAR 0 2
101517: PUSH
101518: LD_VAR 0 1
101522: ST_TO_ADDR
// if value < 0 then
101523: LD_VAR 0 1
101527: PUSH
101528: LD_INT 0
101530: LESS
101531: IFFALSE 101548
// result := value * - 1 ;
101533: LD_ADDR_VAR 0 2
101537: PUSH
101538: LD_VAR 0 1
101542: PUSH
101543: LD_INT 1
101545: NEG
101546: MUL
101547: ST_TO_ADDR
// end ;
101548: LD_VAR 0 2
101552: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
101553: LD_INT 0
101555: PPUSH
101556: PPUSH
101557: PPUSH
101558: PPUSH
101559: PPUSH
101560: PPUSH
101561: PPUSH
101562: PPUSH
// if not unit or not building then
101563: LD_VAR 0 1
101567: NOT
101568: PUSH
101569: LD_VAR 0 2
101573: NOT
101574: OR
101575: IFFALSE 101579
// exit ;
101577: GO 101805
// x := GetX ( building ) ;
101579: LD_ADDR_VAR 0 4
101583: PUSH
101584: LD_VAR 0 2
101588: PPUSH
101589: CALL_OW 250
101593: ST_TO_ADDR
// y := GetY ( building ) ;
101594: LD_ADDR_VAR 0 6
101598: PUSH
101599: LD_VAR 0 2
101603: PPUSH
101604: CALL_OW 251
101608: ST_TO_ADDR
// d := GetDir ( building ) ;
101609: LD_ADDR_VAR 0 8
101613: PUSH
101614: LD_VAR 0 2
101618: PPUSH
101619: CALL_OW 254
101623: ST_TO_ADDR
// r := 4 ;
101624: LD_ADDR_VAR 0 9
101628: PUSH
101629: LD_INT 4
101631: ST_TO_ADDR
// for i := 1 to 5 do
101632: LD_ADDR_VAR 0 10
101636: PUSH
101637: DOUBLE
101638: LD_INT 1
101640: DEC
101641: ST_TO_ADDR
101642: LD_INT 5
101644: PUSH
101645: FOR_TO
101646: IFFALSE 101803
// begin _x := ShiftX ( x , d , r + i ) ;
101648: LD_ADDR_VAR 0 5
101652: PUSH
101653: LD_VAR 0 4
101657: PPUSH
101658: LD_VAR 0 8
101662: PPUSH
101663: LD_VAR 0 9
101667: PUSH
101668: LD_VAR 0 10
101672: PLUS
101673: PPUSH
101674: CALL_OW 272
101678: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
101679: LD_ADDR_VAR 0 7
101683: PUSH
101684: LD_VAR 0 6
101688: PPUSH
101689: LD_VAR 0 8
101693: PPUSH
101694: LD_VAR 0 9
101698: PUSH
101699: LD_VAR 0 10
101703: PLUS
101704: PPUSH
101705: CALL_OW 273
101709: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
101710: LD_VAR 0 5
101714: PPUSH
101715: LD_VAR 0 7
101719: PPUSH
101720: CALL_OW 488
101724: PUSH
101725: LD_VAR 0 5
101729: PPUSH
101730: LD_VAR 0 7
101734: PPUSH
101735: CALL_OW 428
101739: PPUSH
101740: CALL_OW 247
101744: PUSH
101745: LD_INT 3
101747: PUSH
101748: LD_INT 2
101750: PUSH
101751: EMPTY
101752: LIST
101753: LIST
101754: IN
101755: NOT
101756: AND
101757: IFFALSE 101801
// begin ComMoveXY ( unit , _x , _y ) ;
101759: LD_VAR 0 1
101763: PPUSH
101764: LD_VAR 0 5
101768: PPUSH
101769: LD_VAR 0 7
101773: PPUSH
101774: CALL_OW 111
// result := [ _x , _y ] ;
101778: LD_ADDR_VAR 0 3
101782: PUSH
101783: LD_VAR 0 5
101787: PUSH
101788: LD_VAR 0 7
101792: PUSH
101793: EMPTY
101794: LIST
101795: LIST
101796: ST_TO_ADDR
// exit ;
101797: POP
101798: POP
101799: GO 101805
// end ; end ;
101801: GO 101645
101803: POP
101804: POP
// end ;
101805: LD_VAR 0 3
101809: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
101810: LD_INT 0
101812: PPUSH
101813: PPUSH
101814: PPUSH
// result := 0 ;
101815: LD_ADDR_VAR 0 3
101819: PUSH
101820: LD_INT 0
101822: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
101823: LD_VAR 0 1
101827: PUSH
101828: LD_INT 0
101830: LESS
101831: PUSH
101832: LD_VAR 0 1
101836: PUSH
101837: LD_INT 8
101839: GREATER
101840: OR
101841: PUSH
101842: LD_VAR 0 2
101846: PUSH
101847: LD_INT 0
101849: LESS
101850: OR
101851: PUSH
101852: LD_VAR 0 2
101856: PUSH
101857: LD_INT 8
101859: GREATER
101860: OR
101861: IFFALSE 101865
// exit ;
101863: GO 101940
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
101865: LD_ADDR_VAR 0 4
101869: PUSH
101870: LD_INT 22
101872: PUSH
101873: LD_VAR 0 2
101877: PUSH
101878: EMPTY
101879: LIST
101880: LIST
101881: PPUSH
101882: CALL_OW 69
101886: PUSH
101887: FOR_IN
101888: IFFALSE 101938
// begin un := UnitShoot ( i ) ;
101890: LD_ADDR_VAR 0 5
101894: PUSH
101895: LD_VAR 0 4
101899: PPUSH
101900: CALL_OW 504
101904: ST_TO_ADDR
// if GetSide ( un ) = side1 then
101905: LD_VAR 0 5
101909: PPUSH
101910: CALL_OW 255
101914: PUSH
101915: LD_VAR 0 1
101919: EQUAL
101920: IFFALSE 101936
// begin result := un ;
101922: LD_ADDR_VAR 0 3
101926: PUSH
101927: LD_VAR 0 5
101931: ST_TO_ADDR
// exit ;
101932: POP
101933: POP
101934: GO 101940
// end ; end ;
101936: GO 101887
101938: POP
101939: POP
// end ;
101940: LD_VAR 0 3
101944: RET
// export function GetCargoBay ( units ) ; begin
101945: LD_INT 0
101947: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
101948: LD_ADDR_VAR 0 2
101952: PUSH
101953: LD_VAR 0 1
101957: PPUSH
101958: LD_INT 2
101960: PUSH
101961: LD_INT 34
101963: PUSH
101964: LD_INT 12
101966: PUSH
101967: EMPTY
101968: LIST
101969: LIST
101970: PUSH
101971: LD_INT 34
101973: PUSH
101974: LD_INT 51
101976: PUSH
101977: EMPTY
101978: LIST
101979: LIST
101980: PUSH
101981: LD_INT 34
101983: PUSH
101984: LD_INT 32
101986: PUSH
101987: EMPTY
101988: LIST
101989: LIST
101990: PUSH
101991: LD_INT 34
101993: PUSH
101994: LD_INT 89
101996: PUSH
101997: EMPTY
101998: LIST
101999: LIST
102000: PUSH
102001: EMPTY
102002: LIST
102003: LIST
102004: LIST
102005: LIST
102006: LIST
102007: PPUSH
102008: CALL_OW 72
102012: ST_TO_ADDR
// end ;
102013: LD_VAR 0 2
102017: RET
// export function Negate ( value ) ; begin
102018: LD_INT 0
102020: PPUSH
// result := not value ;
102021: LD_ADDR_VAR 0 2
102025: PUSH
102026: LD_VAR 0 1
102030: NOT
102031: ST_TO_ADDR
// end ;
102032: LD_VAR 0 2
102036: RET
// export function Inc ( value ) ; begin
102037: LD_INT 0
102039: PPUSH
// result := value + 1 ;
102040: LD_ADDR_VAR 0 2
102044: PUSH
102045: LD_VAR 0 1
102049: PUSH
102050: LD_INT 1
102052: PLUS
102053: ST_TO_ADDR
// end ;
102054: LD_VAR 0 2
102058: RET
// export function Dec ( value ) ; begin
102059: LD_INT 0
102061: PPUSH
// result := value - 1 ;
102062: LD_ADDR_VAR 0 2
102066: PUSH
102067: LD_VAR 0 1
102071: PUSH
102072: LD_INT 1
102074: MINUS
102075: ST_TO_ADDR
// end ;
102076: LD_VAR 0 2
102080: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
102081: LD_INT 0
102083: PPUSH
102084: PPUSH
102085: PPUSH
102086: PPUSH
102087: PPUSH
102088: PPUSH
102089: PPUSH
102090: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
102091: LD_VAR 0 1
102095: PPUSH
102096: LD_VAR 0 2
102100: PPUSH
102101: CALL_OW 488
102105: NOT
102106: PUSH
102107: LD_VAR 0 3
102111: PPUSH
102112: LD_VAR 0 4
102116: PPUSH
102117: CALL_OW 488
102121: NOT
102122: OR
102123: IFFALSE 102136
// begin result := - 1 ;
102125: LD_ADDR_VAR 0 5
102129: PUSH
102130: LD_INT 1
102132: NEG
102133: ST_TO_ADDR
// exit ;
102134: GO 102371
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
102136: LD_ADDR_VAR 0 12
102140: PUSH
102141: LD_VAR 0 1
102145: PPUSH
102146: LD_VAR 0 2
102150: PPUSH
102151: LD_VAR 0 3
102155: PPUSH
102156: LD_VAR 0 4
102160: PPUSH
102161: CALL 101221 0 4
102165: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
102166: LD_ADDR_VAR 0 11
102170: PUSH
102171: LD_VAR 0 1
102175: PPUSH
102176: LD_VAR 0 2
102180: PPUSH
102181: LD_VAR 0 12
102185: PUSH
102186: LD_INT 1
102188: ARRAY
102189: PPUSH
102190: LD_VAR 0 12
102194: PUSH
102195: LD_INT 2
102197: ARRAY
102198: PPUSH
102199: CALL_OW 298
102203: ST_TO_ADDR
// distance := 9999 ;
102204: LD_ADDR_VAR 0 10
102208: PUSH
102209: LD_INT 9999
102211: ST_TO_ADDR
// for i := 0 to 5 do
102212: LD_ADDR_VAR 0 6
102216: PUSH
102217: DOUBLE
102218: LD_INT 0
102220: DEC
102221: ST_TO_ADDR
102222: LD_INT 5
102224: PUSH
102225: FOR_TO
102226: IFFALSE 102369
// begin _x := ShiftX ( x1 , i , centerDist ) ;
102228: LD_ADDR_VAR 0 7
102232: PUSH
102233: LD_VAR 0 1
102237: PPUSH
102238: LD_VAR 0 6
102242: PPUSH
102243: LD_VAR 0 11
102247: PPUSH
102248: CALL_OW 272
102252: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
102253: LD_ADDR_VAR 0 8
102257: PUSH
102258: LD_VAR 0 2
102262: PPUSH
102263: LD_VAR 0 6
102267: PPUSH
102268: LD_VAR 0 11
102272: PPUSH
102273: CALL_OW 273
102277: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102278: LD_VAR 0 7
102282: PPUSH
102283: LD_VAR 0 8
102287: PPUSH
102288: CALL_OW 488
102292: NOT
102293: IFFALSE 102297
// continue ;
102295: GO 102225
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
102297: LD_ADDR_VAR 0 9
102301: PUSH
102302: LD_VAR 0 12
102306: PUSH
102307: LD_INT 1
102309: ARRAY
102310: PPUSH
102311: LD_VAR 0 12
102315: PUSH
102316: LD_INT 2
102318: ARRAY
102319: PPUSH
102320: LD_VAR 0 7
102324: PPUSH
102325: LD_VAR 0 8
102329: PPUSH
102330: CALL_OW 298
102334: ST_TO_ADDR
// if tmp < distance then
102335: LD_VAR 0 9
102339: PUSH
102340: LD_VAR 0 10
102344: LESS
102345: IFFALSE 102367
// begin result := i ;
102347: LD_ADDR_VAR 0 5
102351: PUSH
102352: LD_VAR 0 6
102356: ST_TO_ADDR
// distance := tmp ;
102357: LD_ADDR_VAR 0 10
102361: PUSH
102362: LD_VAR 0 9
102366: ST_TO_ADDR
// end ; end ;
102367: GO 102225
102369: POP
102370: POP
// end ;
102371: LD_VAR 0 5
102375: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102376: LD_INT 0
102378: PPUSH
102379: PPUSH
// if not driver or not IsInUnit ( driver ) then
102380: LD_VAR 0 1
102384: NOT
102385: PUSH
102386: LD_VAR 0 1
102390: PPUSH
102391: CALL_OW 310
102395: NOT
102396: OR
102397: IFFALSE 102401
// exit ;
102399: GO 102491
// vehicle := IsInUnit ( driver ) ;
102401: LD_ADDR_VAR 0 3
102405: PUSH
102406: LD_VAR 0 1
102410: PPUSH
102411: CALL_OW 310
102415: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102416: LD_VAR 0 1
102420: PPUSH
102421: LD_STRING \
102423: PUSH
102424: LD_INT 0
102426: PUSH
102427: LD_INT 0
102429: PUSH
102430: LD_INT 0
102432: PUSH
102433: LD_INT 0
102435: PUSH
102436: LD_INT 0
102438: PUSH
102439: LD_INT 0
102441: PUSH
102442: EMPTY
102443: LIST
102444: LIST
102445: LIST
102446: LIST
102447: LIST
102448: LIST
102449: LIST
102450: PUSH
102451: LD_STRING E
102453: PUSH
102454: LD_INT 0
102456: PUSH
102457: LD_INT 0
102459: PUSH
102460: LD_VAR 0 3
102464: PUSH
102465: LD_INT 0
102467: PUSH
102468: LD_INT 0
102470: PUSH
102471: LD_INT 0
102473: PUSH
102474: EMPTY
102475: LIST
102476: LIST
102477: LIST
102478: LIST
102479: LIST
102480: LIST
102481: LIST
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: PPUSH
102487: CALL_OW 446
// end ;
102491: LD_VAR 0 2
102495: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102496: LD_INT 0
102498: PPUSH
102499: PPUSH
// if not driver or not IsInUnit ( driver ) then
102500: LD_VAR 0 1
102504: NOT
102505: PUSH
102506: LD_VAR 0 1
102510: PPUSH
102511: CALL_OW 310
102515: NOT
102516: OR
102517: IFFALSE 102521
// exit ;
102519: GO 102611
// vehicle := IsInUnit ( driver ) ;
102521: LD_ADDR_VAR 0 3
102525: PUSH
102526: LD_VAR 0 1
102530: PPUSH
102531: CALL_OW 310
102535: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102536: LD_VAR 0 1
102540: PPUSH
102541: LD_STRING \
102543: PUSH
102544: LD_INT 0
102546: PUSH
102547: LD_INT 0
102549: PUSH
102550: LD_INT 0
102552: PUSH
102553: LD_INT 0
102555: PUSH
102556: LD_INT 0
102558: PUSH
102559: LD_INT 0
102561: PUSH
102562: EMPTY
102563: LIST
102564: LIST
102565: LIST
102566: LIST
102567: LIST
102568: LIST
102569: LIST
102570: PUSH
102571: LD_STRING E
102573: PUSH
102574: LD_INT 0
102576: PUSH
102577: LD_INT 0
102579: PUSH
102580: LD_VAR 0 3
102584: PUSH
102585: LD_INT 0
102587: PUSH
102588: LD_INT 0
102590: PUSH
102591: LD_INT 0
102593: PUSH
102594: EMPTY
102595: LIST
102596: LIST
102597: LIST
102598: LIST
102599: LIST
102600: LIST
102601: LIST
102602: PUSH
102603: EMPTY
102604: LIST
102605: LIST
102606: PPUSH
102607: CALL_OW 447
// end ;
102611: LD_VAR 0 2
102615: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
102616: LD_INT 0
102618: PPUSH
102619: PPUSH
102620: PPUSH
// tmp := [ ] ;
102621: LD_ADDR_VAR 0 5
102625: PUSH
102626: EMPTY
102627: ST_TO_ADDR
// for i in units do
102628: LD_ADDR_VAR 0 4
102632: PUSH
102633: LD_VAR 0 1
102637: PUSH
102638: FOR_IN
102639: IFFALSE 102677
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
102641: LD_ADDR_VAR 0 5
102645: PUSH
102646: LD_VAR 0 5
102650: PPUSH
102651: LD_VAR 0 5
102655: PUSH
102656: LD_INT 1
102658: PLUS
102659: PPUSH
102660: LD_VAR 0 4
102664: PPUSH
102665: CALL_OW 256
102669: PPUSH
102670: CALL_OW 2
102674: ST_TO_ADDR
102675: GO 102638
102677: POP
102678: POP
// if not tmp then
102679: LD_VAR 0 5
102683: NOT
102684: IFFALSE 102688
// exit ;
102686: GO 102736
// if asc then
102688: LD_VAR 0 2
102692: IFFALSE 102716
// result := SortListByListAsc ( units , tmp ) else
102694: LD_ADDR_VAR 0 3
102698: PUSH
102699: LD_VAR 0 1
102703: PPUSH
102704: LD_VAR 0 5
102708: PPUSH
102709: CALL_OW 76
102713: ST_TO_ADDR
102714: GO 102736
// result := SortListByListDesc ( units , tmp ) ;
102716: LD_ADDR_VAR 0 3
102720: PUSH
102721: LD_VAR 0 1
102725: PPUSH
102726: LD_VAR 0 5
102730: PPUSH
102731: CALL_OW 77
102735: ST_TO_ADDR
// end ;
102736: LD_VAR 0 3
102740: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
102741: LD_INT 0
102743: PPUSH
102744: PPUSH
// task := GetTaskList ( mech ) ;
102745: LD_ADDR_VAR 0 4
102749: PUSH
102750: LD_VAR 0 1
102754: PPUSH
102755: CALL_OW 437
102759: ST_TO_ADDR
// if not task then
102760: LD_VAR 0 4
102764: NOT
102765: IFFALSE 102769
// exit ;
102767: GO 102811
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
102769: LD_ADDR_VAR 0 3
102773: PUSH
102774: LD_VAR 0 4
102778: PUSH
102779: LD_INT 1
102781: ARRAY
102782: PUSH
102783: LD_INT 1
102785: ARRAY
102786: PUSH
102787: LD_STRING r
102789: EQUAL
102790: PUSH
102791: LD_VAR 0 4
102795: PUSH
102796: LD_INT 1
102798: ARRAY
102799: PUSH
102800: LD_INT 4
102802: ARRAY
102803: PUSH
102804: LD_VAR 0 2
102808: EQUAL
102809: AND
102810: ST_TO_ADDR
// end ;
102811: LD_VAR 0 3
102815: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
102816: LD_INT 0
102818: PPUSH
// SetDir ( unit , d ) ;
102819: LD_VAR 0 1
102823: PPUSH
102824: LD_VAR 0 4
102828: PPUSH
102829: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
102833: LD_VAR 0 1
102837: PPUSH
102838: LD_VAR 0 2
102842: PPUSH
102843: LD_VAR 0 3
102847: PPUSH
102848: LD_VAR 0 5
102852: PPUSH
102853: CALL_OW 48
// end ;
102857: LD_VAR 0 6
102861: RET
// export function ToNaturalNumber ( number ) ; begin
102862: LD_INT 0
102864: PPUSH
// result := number div 1 ;
102865: LD_ADDR_VAR 0 2
102869: PUSH
102870: LD_VAR 0 1
102874: PUSH
102875: LD_INT 1
102877: DIV
102878: ST_TO_ADDR
// if number < 0 then
102879: LD_VAR 0 1
102883: PUSH
102884: LD_INT 0
102886: LESS
102887: IFFALSE 102897
// result := 0 ;
102889: LD_ADDR_VAR 0 2
102893: PUSH
102894: LD_INT 0
102896: ST_TO_ADDR
// end ;
102897: LD_VAR 0 2
102901: RET
// export function SortByClass ( units , class ) ; var un ; begin
102902: LD_INT 0
102904: PPUSH
102905: PPUSH
// if not units or not class then
102906: LD_VAR 0 1
102910: NOT
102911: PUSH
102912: LD_VAR 0 2
102916: NOT
102917: OR
102918: IFFALSE 102922
// exit ;
102920: GO 103017
// result := [ ] ;
102922: LD_ADDR_VAR 0 3
102926: PUSH
102927: EMPTY
102928: ST_TO_ADDR
// for un in units do
102929: LD_ADDR_VAR 0 4
102933: PUSH
102934: LD_VAR 0 1
102938: PUSH
102939: FOR_IN
102940: IFFALSE 103015
// if GetClass ( un ) = class then
102942: LD_VAR 0 4
102946: PPUSH
102947: CALL_OW 257
102951: PUSH
102952: LD_VAR 0 2
102956: EQUAL
102957: IFFALSE 102984
// result := Insert ( result , 1 , un ) else
102959: LD_ADDR_VAR 0 3
102963: PUSH
102964: LD_VAR 0 3
102968: PPUSH
102969: LD_INT 1
102971: PPUSH
102972: LD_VAR 0 4
102976: PPUSH
102977: CALL_OW 2
102981: ST_TO_ADDR
102982: GO 103013
// result := Replace ( result , result + 1 , un ) ;
102984: LD_ADDR_VAR 0 3
102988: PUSH
102989: LD_VAR 0 3
102993: PPUSH
102994: LD_VAR 0 3
102998: PUSH
102999: LD_INT 1
103001: PLUS
103002: PPUSH
103003: LD_VAR 0 4
103007: PPUSH
103008: CALL_OW 1
103012: ST_TO_ADDR
103013: GO 102939
103015: POP
103016: POP
// end ;
103017: LD_VAR 0 3
103021: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
103022: LD_INT 0
103024: PPUSH
103025: PPUSH
103026: PPUSH
103027: PPUSH
103028: PPUSH
103029: PPUSH
103030: PPUSH
// result := [ ] ;
103031: LD_ADDR_VAR 0 4
103035: PUSH
103036: EMPTY
103037: ST_TO_ADDR
// if x - r < 0 then
103038: LD_VAR 0 1
103042: PUSH
103043: LD_VAR 0 3
103047: MINUS
103048: PUSH
103049: LD_INT 0
103051: LESS
103052: IFFALSE 103064
// min_x := 0 else
103054: LD_ADDR_VAR 0 8
103058: PUSH
103059: LD_INT 0
103061: ST_TO_ADDR
103062: GO 103080
// min_x := x - r ;
103064: LD_ADDR_VAR 0 8
103068: PUSH
103069: LD_VAR 0 1
103073: PUSH
103074: LD_VAR 0 3
103078: MINUS
103079: ST_TO_ADDR
// if y - r < 0 then
103080: LD_VAR 0 2
103084: PUSH
103085: LD_VAR 0 3
103089: MINUS
103090: PUSH
103091: LD_INT 0
103093: LESS
103094: IFFALSE 103106
// min_y := 0 else
103096: LD_ADDR_VAR 0 7
103100: PUSH
103101: LD_INT 0
103103: ST_TO_ADDR
103104: GO 103122
// min_y := y - r ;
103106: LD_ADDR_VAR 0 7
103110: PUSH
103111: LD_VAR 0 2
103115: PUSH
103116: LD_VAR 0 3
103120: MINUS
103121: ST_TO_ADDR
// max_x := x + r ;
103122: LD_ADDR_VAR 0 9
103126: PUSH
103127: LD_VAR 0 1
103131: PUSH
103132: LD_VAR 0 3
103136: PLUS
103137: ST_TO_ADDR
// max_y := y + r ;
103138: LD_ADDR_VAR 0 10
103142: PUSH
103143: LD_VAR 0 2
103147: PUSH
103148: LD_VAR 0 3
103152: PLUS
103153: ST_TO_ADDR
// for _x = min_x to max_x do
103154: LD_ADDR_VAR 0 5
103158: PUSH
103159: DOUBLE
103160: LD_VAR 0 8
103164: DEC
103165: ST_TO_ADDR
103166: LD_VAR 0 9
103170: PUSH
103171: FOR_TO
103172: IFFALSE 103273
// for _y = min_y to max_y do
103174: LD_ADDR_VAR 0 6
103178: PUSH
103179: DOUBLE
103180: LD_VAR 0 7
103184: DEC
103185: ST_TO_ADDR
103186: LD_VAR 0 10
103190: PUSH
103191: FOR_TO
103192: IFFALSE 103269
// begin if not ValidHex ( _x , _y ) then
103194: LD_VAR 0 5
103198: PPUSH
103199: LD_VAR 0 6
103203: PPUSH
103204: CALL_OW 488
103208: NOT
103209: IFFALSE 103213
// continue ;
103211: GO 103191
// if GetResourceTypeXY ( _x , _y ) then
103213: LD_VAR 0 5
103217: PPUSH
103218: LD_VAR 0 6
103222: PPUSH
103223: CALL_OW 283
103227: IFFALSE 103267
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
103229: LD_ADDR_VAR 0 4
103233: PUSH
103234: LD_VAR 0 4
103238: PPUSH
103239: LD_VAR 0 4
103243: PUSH
103244: LD_INT 1
103246: PLUS
103247: PPUSH
103248: LD_VAR 0 5
103252: PUSH
103253: LD_VAR 0 6
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: PPUSH
103262: CALL_OW 1
103266: ST_TO_ADDR
// end ;
103267: GO 103191
103269: POP
103270: POP
103271: GO 103171
103273: POP
103274: POP
// end ;
103275: LD_VAR 0 4
103279: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
103280: LD_INT 0
103282: PPUSH
103283: PPUSH
103284: PPUSH
103285: PPUSH
103286: PPUSH
103287: PPUSH
103288: PPUSH
103289: PPUSH
// if not units then
103290: LD_VAR 0 1
103294: NOT
103295: IFFALSE 103299
// exit ;
103297: GO 103823
// result := UnitFilter ( units , [ f_ok ] ) ;
103299: LD_ADDR_VAR 0 3
103303: PUSH
103304: LD_VAR 0 1
103308: PPUSH
103309: LD_INT 50
103311: PUSH
103312: EMPTY
103313: LIST
103314: PPUSH
103315: CALL_OW 72
103319: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
103320: LD_ADDR_VAR 0 8
103324: PUSH
103325: LD_VAR 0 1
103329: PUSH
103330: LD_INT 1
103332: ARRAY
103333: PPUSH
103334: CALL_OW 255
103338: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
103339: LD_ADDR_VAR 0 10
103343: PUSH
103344: LD_INT 29
103346: PUSH
103347: LD_INT 91
103349: PUSH
103350: LD_INT 49
103352: PUSH
103353: EMPTY
103354: LIST
103355: LIST
103356: LIST
103357: ST_TO_ADDR
// if not result then
103358: LD_VAR 0 3
103362: NOT
103363: IFFALSE 103367
// exit ;
103365: GO 103823
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
103367: LD_ADDR_VAR 0 5
103371: PUSH
103372: LD_INT 81
103374: PUSH
103375: LD_VAR 0 8
103379: PUSH
103380: EMPTY
103381: LIST
103382: LIST
103383: PPUSH
103384: CALL_OW 69
103388: ST_TO_ADDR
// for i in result do
103389: LD_ADDR_VAR 0 4
103393: PUSH
103394: LD_VAR 0 3
103398: PUSH
103399: FOR_IN
103400: IFFALSE 103821
// begin tag := GetTag ( i ) + 1 ;
103402: LD_ADDR_VAR 0 9
103406: PUSH
103407: LD_VAR 0 4
103411: PPUSH
103412: CALL_OW 110
103416: PUSH
103417: LD_INT 1
103419: PLUS
103420: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
103421: LD_ADDR_VAR 0 7
103425: PUSH
103426: LD_VAR 0 4
103430: PPUSH
103431: CALL_OW 250
103435: PPUSH
103436: LD_VAR 0 4
103440: PPUSH
103441: CALL_OW 251
103445: PPUSH
103446: LD_INT 6
103448: PPUSH
103449: CALL 103022 0 3
103453: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
103454: LD_VAR 0 4
103458: PPUSH
103459: CALL_OW 247
103463: PUSH
103464: LD_INT 2
103466: EQUAL
103467: PUSH
103468: LD_VAR 0 7
103472: AND
103473: PUSH
103474: LD_VAR 0 4
103478: PPUSH
103479: CALL_OW 264
103483: PUSH
103484: LD_VAR 0 10
103488: IN
103489: NOT
103490: AND
103491: IFFALSE 103530
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
103493: LD_VAR 0 4
103497: PPUSH
103498: LD_VAR 0 7
103502: PUSH
103503: LD_INT 1
103505: ARRAY
103506: PUSH
103507: LD_INT 1
103509: ARRAY
103510: PPUSH
103511: LD_VAR 0 7
103515: PUSH
103516: LD_INT 1
103518: ARRAY
103519: PUSH
103520: LD_INT 2
103522: ARRAY
103523: PPUSH
103524: CALL_OW 116
103528: GO 103819
// if path > tag then
103530: LD_VAR 0 2
103534: PUSH
103535: LD_VAR 0 9
103539: GREATER
103540: IFFALSE 103748
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
103542: LD_ADDR_VAR 0 6
103546: PUSH
103547: LD_VAR 0 5
103551: PPUSH
103552: LD_INT 91
103554: PUSH
103555: LD_VAR 0 4
103559: PUSH
103560: LD_INT 8
103562: PUSH
103563: EMPTY
103564: LIST
103565: LIST
103566: LIST
103567: PPUSH
103568: CALL_OW 72
103572: ST_TO_ADDR
// if nearEnemy then
103573: LD_VAR 0 6
103577: IFFALSE 103646
// begin if GetWeapon ( i ) = ru_time_lapser then
103579: LD_VAR 0 4
103583: PPUSH
103584: CALL_OW 264
103588: PUSH
103589: LD_INT 49
103591: EQUAL
103592: IFFALSE 103620
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
103594: LD_VAR 0 4
103598: PPUSH
103599: LD_VAR 0 6
103603: PPUSH
103604: LD_VAR 0 4
103608: PPUSH
103609: CALL_OW 74
103613: PPUSH
103614: CALL_OW 112
103618: GO 103644
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
103620: LD_VAR 0 4
103624: PPUSH
103625: LD_VAR 0 6
103629: PPUSH
103630: LD_VAR 0 4
103634: PPUSH
103635: CALL_OW 74
103639: PPUSH
103640: CALL 104748 0 2
// end else
103644: GO 103746
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
103646: LD_VAR 0 4
103650: PPUSH
103651: LD_VAR 0 2
103655: PUSH
103656: LD_VAR 0 9
103660: ARRAY
103661: PUSH
103662: LD_INT 1
103664: ARRAY
103665: PPUSH
103666: LD_VAR 0 2
103670: PUSH
103671: LD_VAR 0 9
103675: ARRAY
103676: PUSH
103677: LD_INT 2
103679: ARRAY
103680: PPUSH
103681: CALL_OW 297
103685: PUSH
103686: LD_INT 6
103688: GREATER
103689: IFFALSE 103732
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
103691: LD_VAR 0 4
103695: PPUSH
103696: LD_VAR 0 2
103700: PUSH
103701: LD_VAR 0 9
103705: ARRAY
103706: PUSH
103707: LD_INT 1
103709: ARRAY
103710: PPUSH
103711: LD_VAR 0 2
103715: PUSH
103716: LD_VAR 0 9
103720: ARRAY
103721: PUSH
103722: LD_INT 2
103724: ARRAY
103725: PPUSH
103726: CALL_OW 114
103730: GO 103746
// SetTag ( i , tag ) ;
103732: LD_VAR 0 4
103736: PPUSH
103737: LD_VAR 0 9
103741: PPUSH
103742: CALL_OW 109
// end else
103746: GO 103819
// if enemy then
103748: LD_VAR 0 5
103752: IFFALSE 103819
// begin if GetWeapon ( i ) = ru_time_lapser then
103754: LD_VAR 0 4
103758: PPUSH
103759: CALL_OW 264
103763: PUSH
103764: LD_INT 49
103766: EQUAL
103767: IFFALSE 103795
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103769: LD_VAR 0 4
103773: PPUSH
103774: LD_VAR 0 5
103778: PPUSH
103779: LD_VAR 0 4
103783: PPUSH
103784: CALL_OW 74
103788: PPUSH
103789: CALL_OW 112
103793: GO 103819
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
103795: LD_VAR 0 4
103799: PPUSH
103800: LD_VAR 0 5
103804: PPUSH
103805: LD_VAR 0 4
103809: PPUSH
103810: CALL_OW 74
103814: PPUSH
103815: CALL 104748 0 2
// end ; end ;
103819: GO 103399
103821: POP
103822: POP
// end ;
103823: LD_VAR 0 3
103827: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
103828: LD_INT 0
103830: PPUSH
103831: PPUSH
103832: PPUSH
// if not unit or IsInUnit ( unit ) then
103833: LD_VAR 0 1
103837: NOT
103838: PUSH
103839: LD_VAR 0 1
103843: PPUSH
103844: CALL_OW 310
103848: OR
103849: IFFALSE 103853
// exit ;
103851: GO 103944
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
103853: LD_ADDR_VAR 0 4
103857: PUSH
103858: LD_VAR 0 1
103862: PPUSH
103863: CALL_OW 250
103867: PPUSH
103868: LD_VAR 0 2
103872: PPUSH
103873: LD_INT 1
103875: PPUSH
103876: CALL_OW 272
103880: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
103881: LD_ADDR_VAR 0 5
103885: PUSH
103886: LD_VAR 0 1
103890: PPUSH
103891: CALL_OW 251
103895: PPUSH
103896: LD_VAR 0 2
103900: PPUSH
103901: LD_INT 1
103903: PPUSH
103904: CALL_OW 273
103908: ST_TO_ADDR
// if ValidHex ( x , y ) then
103909: LD_VAR 0 4
103913: PPUSH
103914: LD_VAR 0 5
103918: PPUSH
103919: CALL_OW 488
103923: IFFALSE 103944
// ComTurnXY ( unit , x , y ) ;
103925: LD_VAR 0 1
103929: PPUSH
103930: LD_VAR 0 4
103934: PPUSH
103935: LD_VAR 0 5
103939: PPUSH
103940: CALL_OW 118
// end ;
103944: LD_VAR 0 3
103948: RET
// export function SeeUnits ( side , units ) ; var i ; begin
103949: LD_INT 0
103951: PPUSH
103952: PPUSH
// result := false ;
103953: LD_ADDR_VAR 0 3
103957: PUSH
103958: LD_INT 0
103960: ST_TO_ADDR
// if not units then
103961: LD_VAR 0 2
103965: NOT
103966: IFFALSE 103970
// exit ;
103968: GO 104015
// for i in units do
103970: LD_ADDR_VAR 0 4
103974: PUSH
103975: LD_VAR 0 2
103979: PUSH
103980: FOR_IN
103981: IFFALSE 104013
// if See ( side , i ) then
103983: LD_VAR 0 1
103987: PPUSH
103988: LD_VAR 0 4
103992: PPUSH
103993: CALL_OW 292
103997: IFFALSE 104011
// begin result := true ;
103999: LD_ADDR_VAR 0 3
104003: PUSH
104004: LD_INT 1
104006: ST_TO_ADDR
// exit ;
104007: POP
104008: POP
104009: GO 104015
// end ;
104011: GO 103980
104013: POP
104014: POP
// end ;
104015: LD_VAR 0 3
104019: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
104020: LD_INT 0
104022: PPUSH
104023: PPUSH
104024: PPUSH
104025: PPUSH
// if not unit or not points then
104026: LD_VAR 0 1
104030: NOT
104031: PUSH
104032: LD_VAR 0 2
104036: NOT
104037: OR
104038: IFFALSE 104042
// exit ;
104040: GO 104132
// dist := 99999 ;
104042: LD_ADDR_VAR 0 5
104046: PUSH
104047: LD_INT 99999
104049: ST_TO_ADDR
// for i in points do
104050: LD_ADDR_VAR 0 4
104054: PUSH
104055: LD_VAR 0 2
104059: PUSH
104060: FOR_IN
104061: IFFALSE 104130
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
104063: LD_ADDR_VAR 0 6
104067: PUSH
104068: LD_VAR 0 1
104072: PPUSH
104073: LD_VAR 0 4
104077: PUSH
104078: LD_INT 1
104080: ARRAY
104081: PPUSH
104082: LD_VAR 0 4
104086: PUSH
104087: LD_INT 2
104089: ARRAY
104090: PPUSH
104091: CALL_OW 297
104095: ST_TO_ADDR
// if tmpDist < dist then
104096: LD_VAR 0 6
104100: PUSH
104101: LD_VAR 0 5
104105: LESS
104106: IFFALSE 104128
// begin result := i ;
104108: LD_ADDR_VAR 0 3
104112: PUSH
104113: LD_VAR 0 4
104117: ST_TO_ADDR
// dist := tmpDist ;
104118: LD_ADDR_VAR 0 5
104122: PUSH
104123: LD_VAR 0 6
104127: ST_TO_ADDR
// end ; end ;
104128: GO 104060
104130: POP
104131: POP
// end ;
104132: LD_VAR 0 3
104136: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
104137: LD_INT 0
104139: PPUSH
// uc_side := side ;
104140: LD_ADDR_OWVAR 20
104144: PUSH
104145: LD_VAR 0 1
104149: ST_TO_ADDR
// uc_nation := 3 ;
104150: LD_ADDR_OWVAR 21
104154: PUSH
104155: LD_INT 3
104157: ST_TO_ADDR
// vc_chassis := 25 ;
104158: LD_ADDR_OWVAR 37
104162: PUSH
104163: LD_INT 25
104165: ST_TO_ADDR
// vc_engine := engine_siberite ;
104166: LD_ADDR_OWVAR 39
104170: PUSH
104171: LD_INT 3
104173: ST_TO_ADDR
// vc_control := control_computer ;
104174: LD_ADDR_OWVAR 38
104178: PUSH
104179: LD_INT 3
104181: ST_TO_ADDR
// vc_weapon := 59 ;
104182: LD_ADDR_OWVAR 40
104186: PUSH
104187: LD_INT 59
104189: ST_TO_ADDR
// result := CreateVehicle ;
104190: LD_ADDR_VAR 0 5
104194: PUSH
104195: CALL_OW 45
104199: ST_TO_ADDR
// SetDir ( result , d ) ;
104200: LD_VAR 0 5
104204: PPUSH
104205: LD_VAR 0 4
104209: PPUSH
104210: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
104214: LD_VAR 0 5
104218: PPUSH
104219: LD_VAR 0 2
104223: PPUSH
104224: LD_VAR 0 3
104228: PPUSH
104229: LD_INT 0
104231: PPUSH
104232: CALL_OW 48
// end ;
104236: LD_VAR 0 5
104240: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
104241: LD_INT 0
104243: PPUSH
104244: PPUSH
104245: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
104246: LD_ADDR_VAR 0 2
104250: PUSH
104251: LD_INT 0
104253: PUSH
104254: LD_INT 0
104256: PUSH
104257: LD_INT 0
104259: PUSH
104260: LD_INT 0
104262: PUSH
104263: EMPTY
104264: LIST
104265: LIST
104266: LIST
104267: LIST
104268: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
104269: LD_VAR 0 1
104273: NOT
104274: PUSH
104275: LD_VAR 0 1
104279: PPUSH
104280: CALL_OW 264
104284: PUSH
104285: LD_INT 12
104287: PUSH
104288: LD_INT 51
104290: PUSH
104291: LD_INT 32
104293: PUSH
104294: LD_INT 89
104296: PUSH
104297: EMPTY
104298: LIST
104299: LIST
104300: LIST
104301: LIST
104302: IN
104303: NOT
104304: OR
104305: IFFALSE 104309
// exit ;
104307: GO 104407
// for i := 1 to 3 do
104309: LD_ADDR_VAR 0 3
104313: PUSH
104314: DOUBLE
104315: LD_INT 1
104317: DEC
104318: ST_TO_ADDR
104319: LD_INT 3
104321: PUSH
104322: FOR_TO
104323: IFFALSE 104405
// begin tmp := GetCargo ( cargo , i ) ;
104325: LD_ADDR_VAR 0 4
104329: PUSH
104330: LD_VAR 0 1
104334: PPUSH
104335: LD_VAR 0 3
104339: PPUSH
104340: CALL_OW 289
104344: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
104345: LD_ADDR_VAR 0 2
104349: PUSH
104350: LD_VAR 0 2
104354: PPUSH
104355: LD_VAR 0 3
104359: PPUSH
104360: LD_VAR 0 4
104364: PPUSH
104365: CALL_OW 1
104369: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
104370: LD_ADDR_VAR 0 2
104374: PUSH
104375: LD_VAR 0 2
104379: PPUSH
104380: LD_INT 4
104382: PPUSH
104383: LD_VAR 0 2
104387: PUSH
104388: LD_INT 4
104390: ARRAY
104391: PUSH
104392: LD_VAR 0 4
104396: PLUS
104397: PPUSH
104398: CALL_OW 1
104402: ST_TO_ADDR
// end ;
104403: GO 104322
104405: POP
104406: POP
// end ;
104407: LD_VAR 0 2
104411: RET
// export function Length ( array ) ; begin
104412: LD_INT 0
104414: PPUSH
// result := array + 0 ;
104415: LD_ADDR_VAR 0 2
104419: PUSH
104420: LD_VAR 0 1
104424: PUSH
104425: LD_INT 0
104427: PLUS
104428: ST_TO_ADDR
// end ;
104429: LD_VAR 0 2
104433: RET
// export function PrepareArray ( array ) ; begin
104434: LD_INT 0
104436: PPUSH
// result := array diff 0 ;
104437: LD_ADDR_VAR 0 2
104441: PUSH
104442: LD_VAR 0 1
104446: PUSH
104447: LD_INT 0
104449: DIFF
104450: ST_TO_ADDR
// if not result [ 1 ] then
104451: LD_VAR 0 2
104455: PUSH
104456: LD_INT 1
104458: ARRAY
104459: NOT
104460: IFFALSE 104480
// result := Delete ( result , 1 ) ;
104462: LD_ADDR_VAR 0 2
104466: PUSH
104467: LD_VAR 0 2
104471: PPUSH
104472: LD_INT 1
104474: PPUSH
104475: CALL_OW 3
104479: ST_TO_ADDR
// end ;
104480: LD_VAR 0 2
104484: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
104485: LD_INT 0
104487: PPUSH
104488: PPUSH
104489: PPUSH
104490: PPUSH
// sibRocketRange := 25 ;
104491: LD_ADDR_VAR 0 6
104495: PUSH
104496: LD_INT 25
104498: ST_TO_ADDR
// result := false ;
104499: LD_ADDR_VAR 0 4
104503: PUSH
104504: LD_INT 0
104506: ST_TO_ADDR
// for i := 0 to 5 do
104507: LD_ADDR_VAR 0 5
104511: PUSH
104512: DOUBLE
104513: LD_INT 0
104515: DEC
104516: ST_TO_ADDR
104517: LD_INT 5
104519: PUSH
104520: FOR_TO
104521: IFFALSE 104588
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
104523: LD_VAR 0 1
104527: PPUSH
104528: LD_VAR 0 5
104532: PPUSH
104533: LD_VAR 0 6
104537: PPUSH
104538: CALL_OW 272
104542: PPUSH
104543: LD_VAR 0 2
104547: PPUSH
104548: LD_VAR 0 5
104552: PPUSH
104553: LD_VAR 0 6
104557: PPUSH
104558: CALL_OW 273
104562: PPUSH
104563: LD_VAR 0 3
104567: PPUSH
104568: CALL_OW 309
104572: IFFALSE 104586
// begin result := true ;
104574: LD_ADDR_VAR 0 4
104578: PUSH
104579: LD_INT 1
104581: ST_TO_ADDR
// exit ;
104582: POP
104583: POP
104584: GO 104590
// end ;
104586: GO 104520
104588: POP
104589: POP
// end ;
104590: LD_VAR 0 4
104594: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
104595: LD_INT 0
104597: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
104598: LD_VAR 0 1
104602: PPUSH
104603: LD_VAR 0 2
104607: PPUSH
104608: LD_INT 0
104610: PPUSH
104611: LD_INT 0
104613: PPUSH
104614: LD_INT 1
104616: PPUSH
104617: LD_INT 0
104619: PPUSH
104620: CALL_OW 587
// end ;
104624: LD_VAR 0 3
104628: RET
// export function CenterOnNow ( unit ) ; begin
104629: LD_INT 0
104631: PPUSH
// result := IsInUnit ( unit ) ;
104632: LD_ADDR_VAR 0 2
104636: PUSH
104637: LD_VAR 0 1
104641: PPUSH
104642: CALL_OW 310
104646: ST_TO_ADDR
// if not result then
104647: LD_VAR 0 2
104651: NOT
104652: IFFALSE 104664
// result := unit ;
104654: LD_ADDR_VAR 0 2
104658: PUSH
104659: LD_VAR 0 1
104663: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
104664: LD_VAR 0 1
104668: PPUSH
104669: CALL_OW 87
// end ;
104673: LD_VAR 0 2
104677: RET
// export function ComMoveHex ( unit , hex ) ; begin
104678: LD_INT 0
104680: PPUSH
// if not hex then
104681: LD_VAR 0 2
104685: NOT
104686: IFFALSE 104690
// exit ;
104688: GO 104743
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
104690: LD_VAR 0 2
104694: PUSH
104695: LD_INT 1
104697: ARRAY
104698: PPUSH
104699: LD_VAR 0 2
104703: PUSH
104704: LD_INT 2
104706: ARRAY
104707: PPUSH
104708: CALL_OW 428
104712: IFFALSE 104716
// exit ;
104714: GO 104743
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
104716: LD_VAR 0 1
104720: PPUSH
104721: LD_VAR 0 2
104725: PUSH
104726: LD_INT 1
104728: ARRAY
104729: PPUSH
104730: LD_VAR 0 2
104734: PUSH
104735: LD_INT 2
104737: ARRAY
104738: PPUSH
104739: CALL_OW 111
// end ;
104743: LD_VAR 0 3
104747: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
104748: LD_INT 0
104750: PPUSH
104751: PPUSH
104752: PPUSH
// if not unit or not enemy then
104753: LD_VAR 0 1
104757: NOT
104758: PUSH
104759: LD_VAR 0 2
104763: NOT
104764: OR
104765: IFFALSE 104769
// exit ;
104767: GO 104893
// x := GetX ( enemy ) ;
104769: LD_ADDR_VAR 0 4
104773: PUSH
104774: LD_VAR 0 2
104778: PPUSH
104779: CALL_OW 250
104783: ST_TO_ADDR
// y := GetY ( enemy ) ;
104784: LD_ADDR_VAR 0 5
104788: PUSH
104789: LD_VAR 0 2
104793: PPUSH
104794: CALL_OW 251
104798: ST_TO_ADDR
// if ValidHex ( x , y ) then
104799: LD_VAR 0 4
104803: PPUSH
104804: LD_VAR 0 5
104808: PPUSH
104809: CALL_OW 488
104813: IFFALSE 104893
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
104815: LD_VAR 0 2
104819: PPUSH
104820: CALL_OW 247
104824: PUSH
104825: LD_INT 3
104827: PUSH
104828: LD_INT 2
104830: PUSH
104831: EMPTY
104832: LIST
104833: LIST
104834: IN
104835: PUSH
104836: LD_VAR 0 1
104840: PPUSH
104841: CALL_OW 255
104845: PPUSH
104846: LD_VAR 0 2
104850: PPUSH
104851: CALL_OW 292
104855: AND
104856: IFFALSE 104874
// ComAttackUnit ( unit , enemy ) else
104858: LD_VAR 0 1
104862: PPUSH
104863: LD_VAR 0 2
104867: PPUSH
104868: CALL_OW 115
104872: GO 104893
// ComAgressiveMove ( unit , x , y ) ;
104874: LD_VAR 0 1
104878: PPUSH
104879: LD_VAR 0 4
104883: PPUSH
104884: LD_VAR 0 5
104888: PPUSH
104889: CALL_OW 114
// end ; end_of_file
104893: LD_VAR 0 3
104897: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
104898: LD_VAR 0 1
104902: PUSH
104903: LD_INT 200
104905: DOUBLE
104906: GREATEREQUAL
104907: IFFALSE 104915
104909: LD_INT 299
104911: DOUBLE
104912: LESSEQUAL
104913: IFTRUE 104917
104915: GO 104949
104917: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
104918: LD_VAR 0 1
104922: PPUSH
104923: LD_VAR 0 2
104927: PPUSH
104928: LD_VAR 0 3
104932: PPUSH
104933: LD_VAR 0 4
104937: PPUSH
104938: LD_VAR 0 5
104942: PPUSH
104943: CALL 59442 0 5
104947: GO 105026
104949: LD_INT 300
104951: DOUBLE
104952: GREATEREQUAL
104953: IFFALSE 104961
104955: LD_INT 399
104957: DOUBLE
104958: LESSEQUAL
104959: IFTRUE 104963
104961: GO 105025
104963: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
104964: LD_VAR 0 1
104968: PPUSH
104969: LD_VAR 0 2
104973: PPUSH
104974: LD_VAR 0 3
104978: PPUSH
104979: LD_VAR 0 4
104983: PPUSH
104984: LD_VAR 0 5
104988: PPUSH
104989: LD_VAR 0 6
104993: PPUSH
104994: LD_VAR 0 7
104998: PPUSH
104999: LD_VAR 0 8
105003: PPUSH
105004: LD_VAR 0 9
105008: PPUSH
105009: LD_VAR 0 10
105013: PPUSH
105014: LD_VAR 0 11
105018: PPUSH
105019: CALL 55767 0 11
105023: GO 105026
105025: POP
// end ;
105026: PPOPN 11
105028: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
105029: LD_VAR 0 1
105033: PPUSH
105034: LD_VAR 0 2
105038: PPUSH
105039: LD_VAR 0 3
105043: PPUSH
105044: LD_VAR 0 4
105048: PPUSH
105049: LD_VAR 0 5
105053: PPUSH
105054: CALL 59178 0 5
// end ; end_of_file
105058: PPOPN 5
105060: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
105061: LD_VAR 0 1
105065: PPUSH
105066: LD_VAR 0 2
105070: PPUSH
105071: LD_VAR 0 3
105075: PPUSH
105076: LD_VAR 0 4
105080: PPUSH
105081: LD_VAR 0 5
105085: PPUSH
105086: LD_VAR 0 6
105090: PPUSH
105091: CALL 43419 0 6
// end ;
105095: PPOPN 6
105097: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
105098: LD_INT 0
105100: PPUSH
// begin if not units then
105101: LD_VAR 0 1
105105: NOT
105106: IFFALSE 105110
// exit ;
105108: GO 105110
// end ;
105110: PPOPN 7
105112: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
105113: CALL 43323 0 0
// end ;
105117: PPOPN 1
105119: END
