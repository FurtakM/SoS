// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7640 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4617 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4916 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 41796 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42247 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21371 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21307 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18300 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21207 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22221 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21448 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21241 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21274 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 18079 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 22129 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20386 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20961 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20961 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20758 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20422 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20598 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19882 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20496 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20997 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21737 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21307 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18300 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21207 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21448 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21241 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21274 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 18079 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 22129 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20386 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20961 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20961 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20758 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20422 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20598 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19882 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20496 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20997 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21737 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 6
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 7
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 8
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 9
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 12
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 13
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 14
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 15
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 16
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 10
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// callUsed := false ;
1629: LD_ADDR_EXP 3
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19882 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11587 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21955 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11587 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21955 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11587 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21955 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11587 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21955 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 4
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 4
2743: PPUSH
2744: CALL 7859 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 4
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 5
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 5
2828: PPUSH
2829: CALL 7859 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 5
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7859 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7859 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7859 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4477
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 10
4389: PUSH
4390: LD_INT 9
4392: PUSH
4393: LD_INT 8
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: LIST
4400: PUSH
4401: LD_OWVAR 67
4405: ARRAY
4406: PPUSH
4407: LD_INT 10
4409: PUSH
4410: LD_INT 9
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: PUSH
4421: LD_OWVAR 67
4425: ARRAY
4426: PPUSH
4427: LD_INT -2
4429: PUSH
4430: LD_INT -5
4432: PUSH
4433: LD_INT -3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: LD_VAR 0 6
4445: ADD
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 2
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 3
4462: PUSH
4463: LD_INT 4
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 42
4476: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4477: LD_EXP 25
4481: PPUSH
4482: LD_INT 9
4484: PPUSH
4485: LD_INT 0
4487: PPUSH
4488: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4492: LD_VAR 0 5
4496: PUSH
4497: LD_INT 1
4499: ARRAY
4500: PPUSH
4501: LD_INT 2
4503: PPUSH
4504: CALL_OW 336
// for i = 1 to tmp do
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: DOUBLE
4514: LD_INT 1
4516: DEC
4517: ST_TO_ADDR
4518: LD_VAR 0 5
4522: PUSH
4523: FOR_TO
4524: IFFALSE 4579
// if i < 4 then
4526: LD_VAR 0 3
4530: PUSH
4531: LD_INT 4
4533: LESS
4534: IFFALSE 4559
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4536: LD_VAR 0 5
4540: PUSH
4541: LD_VAR 0 3
4545: ARRAY
4546: PPUSH
4547: LD_INT 9
4549: PPUSH
4550: LD_INT 0
4552: PPUSH
4553: CALL_OW 49
4557: GO 4577
// SetSide ( tmp [ i ] , 6 ) ;
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 3
4568: ARRAY
4569: PPUSH
4570: LD_INT 6
4572: PPUSH
4573: CALL_OW 235
4577: GO 4523
4579: POP
4580: POP
// player_squad := tmp ;
4581: LD_ADDR_EXP 23
4585: PUSH
4586: LD_VAR 0 5
4590: ST_TO_ADDR
// pl_counter := 4 ;
4591: LD_ADDR_EXP 24
4595: PUSH
4596: LD_INT 4
4598: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4599: LD_INT 17
4601: PPUSH
4602: LD_INT 5
4604: PPUSH
4605: LD_INT 1
4607: PPUSH
4608: CALL 18300 0 3
// end ;
4612: LD_VAR 0 2
4616: RET
// export Popov ; export function InitAction ; var commander ; begin
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4621: LD_INT 6
4623: PPUSH
4624: LD_INT 3
4626: PPUSH
4627: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 1
4636: PPUSH
4637: CALL_OW 86
// uc_side := 6 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 6
4648: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4649: LD_ADDR_EXP 26
4653: PUSH
4654: LD_STRING Popov
4656: PPUSH
4657: CALL_OW 25
4661: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4662: LD_ADDR_OWVAR 67
4666: PUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 426
4674: ST_TO_ADDR
// if not Difficulty then
4675: LD_OWVAR 67
4679: NOT
4680: IFFALSE 4690
// Difficulty := 2 ;
4682: LD_ADDR_OWVAR 67
4686: PUSH
4687: LD_INT 2
4689: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4690: LD_ADDR_VAR 0 2
4694: PUSH
4695: LD_INT 1
4697: PPUSH
4698: CALL_OW 426
4702: ST_TO_ADDR
// if not commander then
4703: LD_VAR 0 2
4707: NOT
4708: IFFALSE 4718
// commander := 1 ;
4710: LD_ADDR_VAR 0 2
4714: PUSH
4715: LD_INT 1
4717: ST_TO_ADDR
// InitCommanders ( commander ) ;
4718: LD_VAR 0 2
4722: PPUSH
4723: CALL 3137 0 1
// end ;
4727: LD_VAR 0 1
4731: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4732: LD_EXP 24
4736: PUSH
4737: LD_INT 12
4739: LESS
4740: IFFALSE 4913
4742: GO 4744
4744: DISABLE
4745: LD_INT 0
4747: PPUSH
// begin enable ;
4748: ENABLE
// for i = pl_counter to pl_counter + 2 do
4749: LD_ADDR_VAR 0 1
4753: PUSH
4754: DOUBLE
4755: LD_EXP 24
4759: DEC
4760: ST_TO_ADDR
4761: LD_EXP 24
4765: PUSH
4766: LD_INT 2
4768: PLUS
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4817
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4773: LD_EXP 23
4777: PUSH
4778: LD_VAR 0 1
4782: ARRAY
4783: PPUSH
4784: LD_INT 18
4786: PPUSH
4787: LD_INT 0
4789: PPUSH
4790: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4794: LD_EXP 23
4798: PUSH
4799: LD_VAR 0 1
4803: ARRAY
4804: PPUSH
4805: LD_INT 107
4807: PPUSH
4808: LD_INT 88
4810: PPUSH
4811: CALL_OW 111
// end ;
4815: GO 4770
4817: POP
4818: POP
// for i = pl_counter to pl_counter + 2 do
4819: LD_ADDR_VAR 0 1
4823: PUSH
4824: DOUBLE
4825: LD_EXP 24
4829: DEC
4830: ST_TO_ADDR
4831: LD_EXP 24
4835: PUSH
4836: LD_INT 2
4838: PLUS
4839: PUSH
4840: FOR_TO
4841: IFFALSE 4897
// begin repeat wait ( 0 0$01 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4850: LD_EXP 23
4854: PUSH
4855: LD_VAR 0 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 107
4863: PPUSH
4864: LD_INT 88
4866: PPUSH
4867: CALL_OW 297
4871: PUSH
4872: LD_INT 6
4874: LESS
4875: IFFALSE 4843
// SetSide ( player_squad [ i ] , 3 ) ;
4877: LD_EXP 23
4881: PUSH
4882: LD_VAR 0 1
4886: ARRAY
4887: PPUSH
4888: LD_INT 3
4890: PPUSH
4891: CALL_OW 235
// end ;
4895: GO 4840
4897: POP
4898: POP
// pl_counter := pl_counter + 3 ;
4899: LD_ADDR_EXP 24
4903: PUSH
4904: LD_EXP 24
4908: PUSH
4909: LD_INT 3
4911: PLUS
4912: ST_TO_ADDR
// end ;
4913: PPOPN 1
4915: END
// export function Dialog ; begin
4916: LD_INT 0
4918: PPUSH
// if not isTest then
4919: LD_EXP 1
4923: NOT
4924: IFFALSE 4946
// case query ( task ) of 1 :
4926: LD_STRING task
4928: PPUSH
4929: CALL_OW 97
4933: PUSH
4934: LD_INT 1
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4945
4942: POP
// ; end ;
4943: GO 4946
4945: POP
// InGameOn ;
4946: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4950: LD_INT 107
4952: PPUSH
4953: LD_INT 84
4955: PPUSH
4956: CALL_OW 86
// if isTest then
4960: LD_EXP 1
4964: IFFALSE 4974
// dialogue_skipped := true ;
4966: LD_ADDR_OWVAR 59
4970: PUSH
4971: LD_INT 1
4973: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4974: LD_ADDR_EXP 11
4978: PUSH
4979: LD_EXP 23
4983: PUSH
4984: LD_INT 1
4986: ARRAY
4987: PPUSH
4988: LD_INT 0
4990: PPUSH
4991: LD_INT 96
4993: PPUSH
4994: LD_INT 79
4996: PPUSH
4997: LD_INT 2
4999: PPUSH
5000: CALL_OW 145
5004: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5005: LD_INT 35
5007: PPUSH
5008: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
5012: LD_EXP 26
5016: PPUSH
5017: LD_STRING DR1
5019: PPUSH
5020: CALL_OW 94
// Wait ( 0 0$01 ) ;
5024: LD_INT 35
5026: PPUSH
5027: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
5031: LD_EXP 26
5035: PPUSH
5036: LD_STRING DR2
5038: PPUSH
5039: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5043: LD_EXP 26
5047: PPUSH
5048: LD_STRING DR3
5050: PPUSH
5051: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5062: LD_INT 3
5064: PPUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 0
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PPUSH
5075: CALL 11587 0 2
5079: PUSH
5080: LD_EXP 1
5084: OR
5085: IFFALSE 5055
// InGameOff ;
5087: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5091: LD_STRING C1
5093: PPUSH
5094: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5105: LD_EXP 11
5109: PPUSH
5110: CALL_OW 461
5114: PUSH
5115: LD_INT 2
5117: EQUAL
5118: IFFALSE 5098
// if not isTest then
5120: LD_EXP 1
5124: NOT
5125: IFFALSE 5147
// case query ( support ) of 1 :
5127: LD_STRING support
5129: PPUSH
5130: CALL_OW 97
5134: PUSH
5135: LD_INT 1
5137: DOUBLE
5138: EQUAL
5139: IFTRUE 5143
5141: GO 5146
5143: POP
// ; end ;
5144: GO 5147
5146: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5147: LD_INT 3
5149: PPUSH
5150: LD_INT 12
5152: PPUSH
5153: LD_INT 2
5155: PPUSH
5156: LD_INT 22
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 30
5168: PUSH
5169: LD_INT 0
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 69
5184: PUSH
5185: LD_INT 1
5187: ARRAY
5188: PPUSH
5189: CALL_OW 468
// if player_com = stolypin then
5193: LD_EXP 25
5197: PUSH
5198: LD_EXP 22
5202: EQUAL
5203: IFFALSE 5232
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5205: LD_INT 18
5207: PPUSH
5208: LD_INT 3
5210: PUSH
5211: LD_INT 3
5213: PUSH
5214: LD_INT 2
5216: PUSH
5217: EMPTY
5218: LIST
5219: LIST
5220: LIST
5221: PUSH
5222: LD_OWVAR 67
5226: ARRAY
5227: PPUSH
5228: CALL 6656 0 2
// end ;
5232: LD_VAR 0 1
5236: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5237: LD_EXP 12
5241: PUSH
5242: LD_OWVAR 1
5246: PUSH
5247: LD_INT 31500
5249: LESS
5250: AND
5251: IFFALSE 5423
// case query ( call1 ) of 1 :
5253: LD_STRING call1
5255: PPUSH
5256: CALL_OW 97
5260: PUSH
5261: LD_INT 1
5263: DOUBLE
5264: EQUAL
5265: IFTRUE 5269
5267: GO 5411
5269: POP
// begin callUsed := true ;
5270: LD_ADDR_EXP 3
5274: PUSH
5275: LD_INT 1
5277: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5278: LD_INT 3
5280: PPUSH
5281: LD_INT 12
5283: PPUSH
5284: LD_INT 1
5286: PPUSH
5287: LD_EXP 11
5291: PPUSH
5292: CALL_OW 468
// call := false ;
5296: LD_ADDR_EXP 12
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5304: LD_EXP 26
5308: PPUSH
5309: LD_STRING DR6
5311: PPUSH
5312: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5316: LD_INT 6300
5318: PPUSH
5319: LD_INT 8400
5321: PPUSH
5322: CALL_OW 12
5326: PPUSH
5327: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5331: LD_INT 18
5333: PUSH
5334: LD_INT 19
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 1
5343: PPUSH
5344: LD_INT 2
5346: PPUSH
5347: CALL_OW 12
5351: ARRAY
5352: PPUSH
5353: LD_INT 1
5355: PPUSH
5356: LD_INT 2
5358: PPUSH
5359: CALL_OW 12
5363: PPUSH
5364: CALL 6656 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5368: LD_INT 25200
5370: PPUSH
5371: LD_INT 35700
5373: PPUSH
5374: CALL_OW 12
5378: PPUSH
5379: CALL_OW 67
// call := true ;
5383: LD_ADDR_EXP 12
5387: PUSH
5388: LD_INT 1
5390: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 12
5396: PPUSH
5397: LD_INT 2
5399: PPUSH
5400: LD_EXP 11
5404: PPUSH
5405: CALL_OW 468
// end ; 2 :
5409: GO 5423
5411: LD_INT 2
5413: DOUBLE
5414: EQUAL
5415: IFTRUE 5419
5417: GO 5422
5419: POP
// ; end ;
5420: GO 5423
5422: POP
// if call and tick >= 15 15$00 then
5423: LD_EXP 12
5427: PUSH
5428: LD_OWVAR 1
5432: PUSH
5433: LD_INT 31500
5435: GREATEREQUAL
5436: AND
5437: IFFALSE 5882
// case query ( call2 ) of 1 :
5439: LD_STRING call2
5441: PPUSH
5442: CALL_OW 97
5446: PUSH
5447: LD_INT 1
5449: DOUBLE
5450: EQUAL
5451: IFTRUE 5455
5453: GO 5699
5455: POP
// begin callUsed := true ;
5456: LD_ADDR_EXP 3
5460: PUSH
5461: LD_INT 1
5463: ST_TO_ADDR
// call := false ;
5464: LD_ADDR_EXP 12
5468: PUSH
5469: LD_INT 0
5471: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5472: LD_INT 1
5474: PPUSH
5475: LD_INT 21
5477: PUSH
5478: LD_INT 3
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PPUSH
5485: CALL 11587 0 2
5489: PUSH
5490: LD_INT 4
5492: PPUSH
5493: LD_INT 21
5495: PUSH
5496: LD_INT 3
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 11587 0 2
5507: AND
5508: IFFALSE 5556
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5510: LD_INT 18
5512: PUSH
5513: LD_INT 19
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: LD_INT 1
5522: PPUSH
5523: LD_INT 2
5525: PPUSH
5526: CALL_OW 12
5530: ARRAY
5531: PPUSH
5532: LD_INT 5
5534: PUSH
5535: LD_INT 4
5537: PUSH
5538: LD_INT 4
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_OWVAR 67
5550: ARRAY
5551: PPUSH
5552: CALL 6417 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5556: LD_INT 1
5558: PPUSH
5559: LD_INT 21
5561: PUSH
5562: LD_INT 3
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PPUSH
5569: CALL 11587 0 2
5573: PUSH
5574: LD_INT 0
5576: EQUAL
5577: IFFALSE 5606
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5579: LD_INT 19
5581: PPUSH
5582: LD_INT 5
5584: PUSH
5585: LD_INT 4
5587: PUSH
5588: LD_INT 3
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PUSH
5596: LD_OWVAR 67
5600: ARRAY
5601: PPUSH
5602: CALL 6417 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5606: LD_INT 4
5608: PPUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 3
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PPUSH
5619: CALL 11587 0 2
5623: PUSH
5624: LD_INT 0
5626: EQUAL
5627: IFFALSE 5656
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5629: LD_INT 18
5631: PPUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 4
5637: PUSH
5638: LD_INT 4
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: LIST
5645: PUSH
5646: LD_OWVAR 67
5650: ARRAY
5651: PPUSH
5652: CALL 6417 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5656: LD_INT 10500
5658: PPUSH
5659: LD_INT 23100
5661: PPUSH
5662: CALL_OW 12
5666: PPUSH
5667: CALL_OW 67
// call := true ;
5671: LD_ADDR_EXP 12
5675: PUSH
5676: LD_INT 1
5678: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5679: LD_INT 3
5681: PPUSH
5682: LD_INT 12
5684: PPUSH
5685: LD_INT 2
5687: PPUSH
5688: LD_EXP 11
5692: PPUSH
5693: CALL_OW 468
// end ; 2 :
5697: GO 5882
5699: LD_INT 2
5701: DOUBLE
5702: EQUAL
5703: IFTRUE 5707
5705: GO 5870
5707: POP
// begin callUsed := true ;
5708: LD_ADDR_EXP 3
5712: PUSH
5713: LD_INT 1
5715: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5716: LD_INT 3
5718: PPUSH
5719: LD_INT 12
5721: PPUSH
5722: LD_INT 1
5724: PPUSH
5725: LD_EXP 11
5729: PPUSH
5730: CALL_OW 468
// call := false ;
5734: LD_ADDR_EXP 12
5738: PUSH
5739: LD_INT 0
5741: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5742: LD_EXP 26
5746: PPUSH
5747: LD_STRING DR6
5749: PPUSH
5750: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5754: LD_INT 6300
5756: PPUSH
5757: LD_INT 8400
5759: PPUSH
5760: CALL_OW 12
5764: PPUSH
5765: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5769: LD_INT 18
5771: PUSH
5772: LD_INT 19
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PUSH
5779: LD_INT 1
5781: PPUSH
5782: LD_INT 2
5784: PPUSH
5785: CALL_OW 12
5789: ARRAY
5790: PPUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 2
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PUSH
5805: LD_OWVAR 67
5809: ARRAY
5810: PUSH
5811: LD_INT 0
5813: PPUSH
5814: LD_INT 1
5816: PPUSH
5817: CALL_OW 12
5821: MINUS
5822: PPUSH
5823: CALL 6656 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5827: LD_INT 35700
5829: PPUSH
5830: LD_INT 44100
5832: PPUSH
5833: CALL_OW 12
5837: PPUSH
5838: CALL_OW 67
// call := true ;
5842: LD_ADDR_EXP 12
5846: PUSH
5847: LD_INT 1
5849: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5850: LD_INT 3
5852: PPUSH
5853: LD_INT 12
5855: PPUSH
5856: LD_INT 2
5858: PPUSH
5859: LD_EXP 11
5863: PPUSH
5864: CALL_OW 468
// end ; 3 :
5868: GO 5882
5870: LD_INT 3
5872: DOUBLE
5873: EQUAL
5874: IFTRUE 5878
5876: GO 5881
5878: POP
// ; end ;
5879: GO 5882
5881: POP
// end ;
5882: PPOPN 4
5884: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5885: LD_INT 22
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 21
5897: PUSH
5898: LD_INT 1
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PPUSH
5909: CALL_OW 69
5913: PUSH
5914: LD_INT 0
5916: EQUAL
5917: PUSH
5918: LD_INT 22
5920: PUSH
5921: LD_INT 4
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: LD_INT 21
5930: PUSH
5931: LD_INT 1
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL_OW 69
5946: PUSH
5947: LD_INT 0
5949: EQUAL
5950: AND
5951: IFFALSE 6255
5953: GO 5955
5955: DISABLE
// begin DialogueOn ;
5956: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5960: LD_EXP 26
5964: PPUSH
5965: LD_STRING DR7
5967: PPUSH
5968: CALL_OW 94
// case player_com of Gorki :
5972: LD_EXP 25
5976: PUSH
5977: LD_EXP 21
5981: DOUBLE
5982: EQUAL
5983: IFTRUE 5987
5985: GO 5997
5987: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5988: LD_STRING ACH_GORKI
5990: PPUSH
5991: CALL_OW 543
5995: GO 6058
5997: LD_EXP 22
6001: DOUBLE
6002: EQUAL
6003: IFTRUE 6007
6005: GO 6017
6007: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
6008: LD_STRING ACH_STOLYP
6010: PPUSH
6011: CALL_OW 543
6015: GO 6058
6017: LD_EXP 20
6021: DOUBLE
6022: EQUAL
6023: IFTRUE 6027
6025: GO 6037
6027: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
6028: LD_STRING ACH_DAVIDOV
6030: PPUSH
6031: CALL_OW 543
6035: GO 6058
6037: LD_EXP 19
6041: DOUBLE
6042: EQUAL
6043: IFTRUE 6047
6045: GO 6057
6047: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6048: LD_STRING ACH_GLADKOV
6050: PPUSH
6051: CALL_OW 543
6055: GO 6058
6057: POP
// if not callUsed then
6058: LD_EXP 3
6062: NOT
6063: IFFALSE 6072
// SetAchievement ( ACH_NOSUPP ) ;
6065: LD_STRING ACH_NOSUPP
6067: PPUSH
6068: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6072: LD_OWVAR 1
6076: PUSH
6077: LD_INT 116550
6079: PUSH
6080: LD_INT 95550
6082: PUSH
6083: LD_INT 89250
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: PUSH
6091: LD_OWVAR 67
6095: ARRAY
6096: LESS
6097: IFFALSE 6111
// AddMedal ( med1 , 1 ) else
6099: LD_STRING med1
6101: PPUSH
6102: LD_INT 1
6104: PPUSH
6105: CALL_OW 101
6109: GO 6122
// AddMedal ( med1 , - 1 ) ;
6111: LD_STRING med1
6113: PPUSH
6114: LD_INT 1
6116: NEG
6117: PPUSH
6118: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6122: LD_INT 81
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 21
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PUSH
6151: LD_INT 0
6153: EQUAL
6154: IFFALSE 6168
// AddMedal ( med3 , 1 ) else
6156: LD_STRING med3
6158: PPUSH
6159: LD_INT 1
6161: PPUSH
6162: CALL_OW 101
6166: GO 6179
// AddMedal ( med3 , - 1 ) ;
6168: LD_STRING med3
6170: PPUSH
6171: LD_INT 1
6173: NEG
6174: PPUSH
6175: CALL_OW 101
// if player_loss = 0 then
6179: LD_EXP 10
6183: PUSH
6184: LD_INT 0
6186: EQUAL
6187: IFFALSE 6201
// AddMedal ( med2 , 1 ) else
6189: LD_STRING med2
6191: PPUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 101
6199: GO 6244
// if player_loss > 0 and player_loss < 3 then
6201: LD_EXP 10
6205: PUSH
6206: LD_INT 0
6208: GREATER
6209: PUSH
6210: LD_EXP 10
6214: PUSH
6215: LD_INT 3
6217: LESS
6218: AND
6219: IFFALSE 6233
// AddMedal ( med2 , 2 ) else
6221: LD_STRING med2
6223: PPUSH
6224: LD_INT 2
6226: PPUSH
6227: CALL_OW 101
6231: GO 6244
// AddMedal ( med2 , - 1 ) ;
6233: LD_STRING med2
6235: PPUSH
6236: LD_INT 1
6238: NEG
6239: PPUSH
6240: CALL_OW 101
// GiveMedals ( MAIN ) ;
6244: LD_STRING MAIN
6246: PPUSH
6247: CALL_OW 102
// YouWin ;
6251: CALL_OW 103
// end ;
6255: END
// every 0 0$01 trigger IsDead ( player_com ) do
6256: LD_EXP 25
6260: PPUSH
6261: CALL_OW 301
6265: IFFALSE 6332
6267: GO 6269
6269: DISABLE
// begin if IsLive ( Houten ) then
6270: LD_EXP 4
6274: PPUSH
6275: CALL_OW 300
6279: IFFALSE 6295
// SayRadio ( Houten , DJ5 ) else
6281: LD_EXP 4
6285: PPUSH
6286: LD_STRING DJ5
6288: PPUSH
6289: CALL_OW 94
6293: GO 6318
// if IsLive ( Brown ) then
6295: LD_EXP 5
6299: PPUSH
6300: CALL_OW 300
6304: IFFALSE 6318
// SayRadio ( Brown , DS5 ) ;
6306: LD_EXP 5
6310: PPUSH
6311: LD_STRING DS5
6313: PPUSH
6314: CALL_OW 94
// Wait ( 0 0$01 ) ;
6318: LD_INT 35
6320: PPUSH
6321: CALL_OW 67
// YouLost ( dead ) ;
6325: LD_STRING dead
6327: PPUSH
6328: CALL_OW 104
// end ;
6332: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6333: LD_EXP 11
6337: PPUSH
6338: CALL_OW 301
6342: PUSH
6343: LD_EXP 1
6347: NOT
6348: AND
6349: IFFALSE 6416
6351: GO 6353
6353: DISABLE
// begin if IsLive ( Brown ) then
6354: LD_EXP 5
6358: PPUSH
6359: CALL_OW 300
6363: IFFALSE 6379
// SayRadio ( Brown , DS5 ) else
6365: LD_EXP 5
6369: PPUSH
6370: LD_STRING DS5
6372: PPUSH
6373: CALL_OW 94
6377: GO 6402
// if IsLive ( Houten ) then
6379: LD_EXP 4
6383: PPUSH
6384: CALL_OW 300
6388: IFFALSE 6402
// SayRadio ( Houten , DJ5 ) ;
6390: LD_EXP 4
6394: PPUSH
6395: LD_STRING DJ5
6397: PPUSH
6398: CALL_OW 94
// Wait ( 0 0$01 ) ;
6402: LD_INT 35
6404: PPUSH
6405: CALL_OW 67
// YouLost ( depot ) ;
6409: LD_STRING depot
6411: PPUSH
6412: CALL_OW 104
// end ;
6416: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6417: LD_INT 0
6419: PPUSH
6420: PPUSH
6421: PPUSH
// for i = 1 to n do
6422: LD_ADDR_VAR 0 4
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_TO
6438: IFFALSE 6641
// begin uc_side := 6 ;
6440: LD_ADDR_OWVAR 20
6444: PUSH
6445: LD_INT 6
6447: ST_TO_ADDR
// uc_nation := 3 ;
6448: LD_ADDR_OWVAR 21
6452: PUSH
6453: LD_INT 3
6455: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6456: LD_ADDR_OWVAR 37
6460: PUSH
6461: LD_INT 23
6463: PUSH
6464: LD_INT 22
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 1
6473: PPUSH
6474: LD_INT 2
6476: PPUSH
6477: CALL_OW 12
6481: ARRAY
6482: ST_TO_ADDR
// vc_control := control_computer ;
6483: LD_ADDR_OWVAR 38
6487: PUSH
6488: LD_INT 3
6490: ST_TO_ADDR
// vc_engine := engine_siberite ;
6491: LD_ADDR_OWVAR 39
6495: PUSH
6496: LD_INT 3
6498: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6499: LD_ADDR_OWVAR 40
6503: PUSH
6504: LD_INT 43
6506: PUSH
6507: LD_INT 44
6509: PUSH
6510: LD_INT 44
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 1
6520: PPUSH
6521: LD_INT 3
6523: PPUSH
6524: CALL_OW 12
6528: ARRAY
6529: ST_TO_ADDR
// un := CreateVehicle ;
6530: LD_ADDR_VAR 0 5
6534: PUSH
6535: CALL_OW 45
6539: ST_TO_ADDR
// case area of east_arr :
6540: LD_VAR 0 1
6544: PUSH
6545: LD_INT 18
6547: DOUBLE
6548: EQUAL
6549: IFTRUE 6553
6551: GO 6588
6553: POP
// begin PlaceUnitArea ( un , area , false ) ;
6554: LD_VAR 0 5
6558: PPUSH
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 0
6566: PPUSH
6567: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_INT 79
6578: PPUSH
6579: LD_INT 33
6581: PPUSH
6582: CALL_OW 111
// end ; south_arr :
6586: GO 6632
6588: LD_INT 19
6590: DOUBLE
6591: EQUAL
6592: IFTRUE 6596
6594: GO 6631
6596: POP
// begin PlaceUnitArea ( un , area , false ) ;
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 1
6606: PPUSH
6607: LD_INT 0
6609: PPUSH
6610: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 131
6621: PPUSH
6622: LD_INT 148
6624: PPUSH
6625: CALL_OW 111
// end ; end ;
6629: GO 6632
6631: POP
// Wait ( 0 0$02 ) ;
6632: LD_INT 70
6634: PPUSH
6635: CALL_OW 67
// end ;
6639: GO 6437
6641: POP
6642: POP
// pink_attack := true ;
6643: LD_ADDR_EXP 13
6647: PUSH
6648: LD_INT 1
6650: ST_TO_ADDR
// end ;
6651: LD_VAR 0 3
6655: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// for i = 1 to n do
6661: LD_ADDR_VAR 0 4
6665: PUSH
6666: DOUBLE
6667: LD_INT 1
6669: DEC
6670: ST_TO_ADDR
6671: LD_VAR 0 2
6675: PUSH
6676: FOR_TO
6677: IFFALSE 6903
// begin uc_side := 6 ;
6679: LD_ADDR_OWVAR 20
6683: PUSH
6684: LD_INT 6
6686: ST_TO_ADDR
// uc_nation := 3 ;
6687: LD_ADDR_OWVAR 21
6691: PUSH
6692: LD_INT 3
6694: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6695: LD_INT 0
6697: PPUSH
6698: LD_INT 3
6700: PPUSH
6701: LD_INT 4
6703: PPUSH
6704: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6708: LD_ADDR_OWVAR 37
6712: PUSH
6713: LD_INT 22
6715: ST_TO_ADDR
// vc_control := control_manual ;
6716: LD_ADDR_OWVAR 38
6720: PUSH
6721: LD_INT 1
6723: ST_TO_ADDR
// vc_engine := engine_combustion ;
6724: LD_ADDR_OWVAR 39
6728: PUSH
6729: LD_INT 1
6731: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6732: LD_ADDR_OWVAR 40
6736: PUSH
6737: LD_INT 51
6739: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6740: LD_ADDR_OWVAR 41
6744: PUSH
6745: LD_INT 50
6747: ST_TO_ADDR
// un := CreateVehicle ;
6748: LD_ADDR_VAR 0 5
6752: PUSH
6753: CALL_OW 45
6757: ST_TO_ADDR
// case area of east_arr :
6758: LD_VAR 0 1
6762: PUSH
6763: LD_INT 18
6765: DOUBLE
6766: EQUAL
6767: IFTRUE 6771
6769: GO 6786
6771: POP
// SetDir ( un , 4 ) ; south_arr :
6772: LD_VAR 0 5
6776: PPUSH
6777: LD_INT 4
6779: PPUSH
6780: CALL_OW 233
6784: GO 6810
6786: LD_INT 19
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6809
6794: POP
// SetDir ( un , 5 ) ; end ;
6795: LD_VAR 0 5
6799: PPUSH
6800: LD_INT 5
6802: PPUSH
6803: CALL_OW 233
6807: GO 6810
6809: POP
// PlaceUnitArea ( un , area , false ) ;
6810: LD_VAR 0 5
6814: PPUSH
6815: LD_VAR 0 1
6819: PPUSH
6820: LD_INT 0
6822: PPUSH
6823: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6827: CALL_OW 44
6831: PPUSH
6832: LD_VAR 0 5
6836: PPUSH
6837: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6841: LD_VAR 0 5
6845: PPUSH
6846: LD_INT 1
6848: PPUSH
6849: LD_INT 100
6851: PPUSH
6852: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6856: LD_VAR 0 5
6860: PPUSH
6861: LD_INT 106
6863: PPUSH
6864: LD_INT 88
6866: PPUSH
6867: CALL_OW 111
// AddComUnload ( un ) ;
6871: LD_VAR 0 5
6875: PPUSH
6876: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6880: LD_VAR 0 5
6884: PPUSH
6885: LD_VAR 0 1
6889: PPUSH
6890: CALL_OW 173
// Wait ( 0 0$02 ) ;
6894: LD_INT 70
6896: PPUSH
6897: CALL_OW 67
// end ;
6901: GO 6676
6903: POP
6904: POP
// Wait ( 0 0$05 ) ;
6905: LD_INT 175
6907: PPUSH
6908: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6912: LD_INT 6
6914: PPUSH
6915: LD_INT 34
6917: PUSH
6918: LD_INT 51
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: CALL 11587 0 2
6929: IFFALSE 7117
// begin wait ( 0 0$01 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6938: LD_ADDR_VAR 0 4
6942: PUSH
6943: LD_INT 6
6945: PPUSH
6946: LD_INT 34
6948: PUSH
6949: LD_INT 51
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: CALL 11587 0 2
6960: PUSH
6961: FOR_IN
6962: IFFALSE 7113
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6964: LD_VAR 0 4
6968: PPUSH
6969: LD_INT 9
6971: PPUSH
6972: CALL_OW 308
6976: PUSH
6977: LD_VAR 0 4
6981: PPUSH
6982: CALL 31768 0 1
6986: PPUSH
6987: CALL_OW 258
6991: PUSH
6992: LD_INT 1
6994: EQUAL
6995: AND
6996: PUSH
6997: LD_EXP 9
7001: AND
7002: IFFALSE 7029
// begin Say ( GetDriver ( i ) , Dtran ) ;
7004: LD_VAR 0 4
7008: PPUSH
7009: CALL 31768 0 1
7013: PPUSH
7014: LD_STRING Dtran
7016: PPUSH
7017: CALL_OW 88
// dialog_trans := false ;
7021: LD_ADDR_EXP 9
7025: PUSH
7026: LD_INT 0
7028: ST_TO_ADDR
// end ; if IsIdle ( i ) then
7029: LD_VAR 0 4
7033: PPUSH
7034: CALL_OW 316
7038: IFFALSE 7054
// ComMoveToArea ( i , area ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: LD_VAR 0 1
7049: PPUSH
7050: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7054: LD_VAR 0 4
7058: PPUSH
7059: LD_VAR 0 1
7063: PPUSH
7064: CALL_OW 308
7068: PUSH
7069: LD_VAR 0 4
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL_OW 289
7081: PUSH
7082: LD_INT 0
7084: EQUAL
7085: AND
7086: IFFALSE 7111
// begin RemoveUnit ( GetDriver ( i ) ) ;
7088: LD_VAR 0 4
7092: PPUSH
7093: CALL 31768 0 1
7097: PPUSH
7098: CALL_OW 64
// RemoveUnit ( i ) ;
7102: LD_VAR 0 4
7106: PPUSH
7107: CALL_OW 64
// end ; end ;
7111: GO 6961
7113: POP
7114: POP
// end ;
7115: GO 6912
// end ;
7117: LD_VAR 0 3
7121: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7122: LD_INT 0
7124: PPUSH
7125: PPUSH
7126: PPUSH
7127: PPUSH
// if isTest then
7128: LD_EXP 1
7132: IFFALSE 7136
// exit ;
7134: GO 7525
// for i = 1 to n do
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: DOUBLE
7142: LD_INT 1
7144: DEC
7145: ST_TO_ADDR
7146: LD_VAR 0 2
7150: PUSH
7151: FOR_TO
7152: IFFALSE 7384
// begin uc_side := 8 ;
7154: LD_ADDR_OWVAR 20
7158: PUSH
7159: LD_INT 8
7161: ST_TO_ADDR
// uc_nation := 1 ;
7162: LD_ADDR_OWVAR 21
7166: PUSH
7167: LD_INT 1
7169: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7170: LD_ADDR_VAR 0 6
7174: PUSH
7175: LD_INT 3
7177: PUSH
7178: LD_INT 4
7180: PUSH
7181: LD_INT 4
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_INT 1
7191: PPUSH
7192: LD_OWVAR 67
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: ST_TO_ADDR
// vc_chassis := ch ;
7203: LD_ADDR_OWVAR 37
7207: PUSH
7208: LD_VAR 0 6
7212: ST_TO_ADDR
// vc_control := control_computer ;
7213: LD_ADDR_OWVAR 38
7217: PUSH
7218: LD_INT 3
7220: ST_TO_ADDR
// vc_engine := engine_combustion ;
7221: LD_ADDR_OWVAR 39
7225: PUSH
7226: LD_INT 1
7228: ST_TO_ADDR
// if ch = us_medium_tracked then
7229: LD_VAR 0 6
7233: PUSH
7234: LD_INT 3
7236: EQUAL
7237: IFFALSE 7284
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7239: LD_ADDR_OWVAR 40
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 4
7249: PUSH
7250: LD_INT 5
7252: PUSH
7253: LD_INT 7
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: PPUSH
7267: LD_OWVAR 67
7271: PUSH
7272: LD_INT 1
7274: PLUS
7275: PPUSH
7276: CALL_OW 12
7280: ARRAY
7281: ST_TO_ADDR
7282: GO 7325
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7284: LD_ADDR_OWVAR 40
7288: PUSH
7289: LD_INT 5
7291: PUSH
7292: LD_INT 6
7294: PUSH
7295: LD_INT 7
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 1
7309: PPUSH
7310: LD_OWVAR 67
7314: PUSH
7315: LD_INT 1
7317: PLUS
7318: PPUSH
7319: CALL_OW 12
7323: ARRAY
7324: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7325: LD_ADDR_OWVAR 41
7329: PUSH
7330: LD_INT 70
7332: ST_TO_ADDR
// un := CreateVehicle ;
7333: LD_ADDR_VAR 0 5
7337: PUSH
7338: CALL_OW 45
7342: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7343: LD_VAR 0 5
7347: PPUSH
7348: LD_VAR 0 1
7352: PPUSH
7353: LD_INT 0
7355: PPUSH
7356: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7360: LD_VAR 0 5
7364: PPUSH
7365: LD_INT 65
7367: PPUSH
7368: LD_INT 9
7370: PPUSH
7371: CALL_OW 111
// Wait ( 0 0$02 ) ;
7375: LD_INT 70
7377: PPUSH
7378: CALL_OW 67
// end ;
7382: GO 7151
7384: POP
7385: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7386: LD_INT 90
7388: PUSH
7389: LD_INT 80
7391: PUSH
7392: LD_INT 70
7394: PUSH
7395: EMPTY
7396: LIST
7397: LIST
7398: LIST
7399: PUSH
7400: LD_OWVAR 67
7404: ARRAY
7405: PPUSH
7406: CALL_OW 13
7410: IFFALSE 7517
// begin uc_side := 8 ;
7412: LD_ADDR_OWVAR 20
7416: PUSH
7417: LD_INT 8
7419: ST_TO_ADDR
// uc_nation := 1 ;
7420: LD_ADDR_OWVAR 21
7424: PUSH
7425: LD_INT 1
7427: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7428: LD_ADDR_OWVAR 37
7432: PUSH
7433: LD_INT 4
7435: ST_TO_ADDR
// vc_control := control_computer ;
7436: LD_ADDR_OWVAR 38
7440: PUSH
7441: LD_INT 3
7443: ST_TO_ADDR
// vc_engine := engine_combustion ;
7444: LD_ADDR_OWVAR 39
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7452: LD_ADDR_OWVAR 40
7456: PUSH
7457: LD_INT 14
7459: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7460: LD_ADDR_OWVAR 41
7464: PUSH
7465: LD_INT 70
7467: ST_TO_ADDR
// un := CreateVehicle ;
7468: LD_ADDR_VAR 0 5
7472: PUSH
7473: CALL_OW 45
7477: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7478: LD_VAR 0 5
7482: PPUSH
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 0
7490: PPUSH
7491: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7495: LD_VAR 0 5
7499: PPUSH
7500: LD_INT 65
7502: PPUSH
7503: LD_INT 9
7505: PPUSH
7506: CALL_OW 111
// Wait ( 0 0$02 ) ;
7510: LD_INT 70
7512: PPUSH
7513: CALL_OW 67
// end ; alfa_support := true ;
7517: LD_ADDR_EXP 14
7521: PUSH
7522: LD_INT 1
7524: ST_TO_ADDR
// end ;
7525: LD_VAR 0 3
7529: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7530: LD_OWVAR 1
7534: PUSH
7535: LD_INT 21000
7537: PUSH
7538: LD_INT 18900
7540: PUSH
7541: LD_INT 16800
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: LD_OWVAR 67
7553: ARRAY
7554: GREATER
7555: IFFALSE 7639
7557: GO 7559
7559: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7560: LD_EXP 26
7564: PPUSH
7565: LD_STRING DR5
7567: PPUSH
7568: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7572: LD_INT 1050
7574: PPUSH
7575: LD_INT 4200
7577: PPUSH
7578: CALL_OW 12
7582: PPUSH
7583: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 8 ] [ Difficulty ] ) ;
7587: LD_INT 20
7589: PPUSH
7590: LD_INT 5
7592: PUSH
7593: LD_INT 6
7595: PUSH
7596: LD_INT 8
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: PUSH
7604: LD_OWVAR 67
7608: ARRAY
7609: PPUSH
7610: CALL 7122 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7614: LD_INT 8400
7616: PPUSH
7617: LD_INT 12600
7619: PPUSH
7620: CALL_OW 12
7624: PPUSH
7625: CALL_OW 67
// until tick >= 120 120$00 ;
7629: LD_OWVAR 1
7633: PUSH
7634: LD_INT 252000
7636: GREATEREQUAL
7637: IFFALSE 7560
// end ; end_of_file
7639: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7640: LD_INT 0
7642: PPUSH
// enable_addtolog := isTest ;
7643: LD_ADDR_OWVAR 81
7647: PUSH
7648: LD_EXP 1
7652: ST_TO_ADDR
// lines_break_limit := 5 ;
7653: LD_ADDR_EXP 28
7657: PUSH
7658: LD_INT 5
7660: ST_TO_ADDR
// lines_break_type := --- ;
7661: LD_ADDR_EXP 29
7665: PUSH
7666: LD_STRING ---
7668: ST_TO_ADDR
// lines_counter := 0 ;
7669: LD_ADDR_EXP 27
7673: PUSH
7674: LD_INT 0
7676: ST_TO_ADDR
// show_line_index := true ;
7677: LD_ADDR_EXP 30
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// tick_log := true ;
7685: LD_ADDR_EXP 31
7689: PUSH
7690: LD_INT 1
7692: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7693: LD_STRING ----------SAND OF SIBERIA LOG----------
7695: PPUSH
7696: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7700: LD_STRING Map Name: 
7702: PUSH
7703: LD_OWVAR 68
7707: STR
7708: PPUSH
7709: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7713: LD_STRING Map Number: 
7715: PUSH
7716: LD_OWVAR 70
7720: STR
7721: PPUSH
7722: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7726: LD_STRING Difficulty: 
7728: PUSH
7729: LD_OWVAR 67
7733: STR
7734: PPUSH
7735: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7739: LD_STRING ---------------------------------------
7741: PPUSH
7742: CALL_OW 561
// end ;
7746: LD_VAR 0 1
7750: RET
// function Log ( text ) ; begin
7751: LD_INT 0
7753: PPUSH
// if show_line_index then
7754: LD_EXP 30
7758: IFFALSE 7770
// result := lines_counter ;
7760: LD_ADDR_VAR 0 2
7764: PUSH
7765: LD_EXP 27
7769: ST_TO_ADDR
// if tick_log then
7770: LD_EXP 31
7774: IFFALSE 7800
// result := result &  T:  & tick &   ;
7776: LD_ADDR_VAR 0 2
7780: PUSH
7781: LD_VAR 0 2
7785: PUSH
7786: LD_STRING  T: 
7788: STR
7789: PUSH
7790: LD_OWVAR 1
7794: STR
7795: PUSH
7796: LD_STRING  
7798: STR
7799: ST_TO_ADDR
// AddToLog ( result & text ) ;
7800: LD_VAR 0 2
7804: PUSH
7805: LD_VAR 0 1
7809: STR
7810: PPUSH
7811: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7815: LD_ADDR_EXP 27
7819: PUSH
7820: LD_EXP 27
7824: PUSH
7825: LD_INT 1
7827: PLUS
7828: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7829: LD_EXP 27
7833: PUSH
7834: LD_EXP 28
7838: MOD
7839: PUSH
7840: LD_INT 0
7842: EQUAL
7843: IFFALSE 7854
// AddToLog ( lines_break_type ) ;
7845: LD_EXP 29
7849: PPUSH
7850: CALL_OW 561
// end ;
7854: LD_VAR 0 2
7858: RET
// export function LogHuman ( id ) ; begin
7859: LD_INT 0
7861: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7862: LD_STRING Human Created. id: 
7864: PUSH
7865: LD_VAR 0 1
7869: STR
7870: PUSH
7871: LD_STRING ; side: 
7873: STR
7874: PUSH
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 255
7884: STR
7885: PUSH
7886: LD_STRING ; class: 
7888: STR
7889: PUSH
7890: LD_VAR 0 1
7894: PPUSH
7895: CALL_OW 257
7899: STR
7900: PUSH
7901: LD_STRING ; 
7903: STR
7904: PPUSH
7905: CALL 7751 0 1
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogVeh ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7917: LD_STRING Vehicle Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; nation: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 248
7954: STR
7955: PUSH
7956: LD_STRING ; weapon: 
7958: STR
7959: PUSH
7960: LD_VAR 0 1
7964: PPUSH
7965: CALL_OW 264
7969: STR
7970: PUSH
7971: LD_STRING ; 
7973: STR
7974: PPUSH
7975: CALL 7751 0 1
// end ;
7979: LD_VAR 0 2
7983: RET
// export function LogEvent ( event ) ; begin
7984: LD_INT 0
7986: PPUSH
// Log ( Event Executed. id:  & event ) ;
7987: LD_STRING Event Executed. id: 
7989: PUSH
7990: LD_VAR 0 1
7994: STR
7995: PPUSH
7996: CALL 7751 0 1
// end ; end_of_file
8000: LD_VAR 0 2
8004: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8005: LD_INT 0
8007: PPUSH
8008: PPUSH
8009: PPUSH
8010: PPUSH
8011: PPUSH
8012: PPUSH
8013: PPUSH
8014: PPUSH
// if unit then
8015: LD_VAR 0 1
8019: IFFALSE 8419
// begin if mode = 0 then
8021: LD_VAR 0 3
8025: PUSH
8026: LD_INT 0
8028: EQUAL
8029: IFFALSE 8177
// begin if coords then
8031: LD_VAR 0 2
8035: IFFALSE 8175
// while ( coords > 1 ) do
8037: LD_VAR 0 2
8041: PUSH
8042: LD_INT 1
8044: GREATER
8045: IFFALSE 8175
// if not HasTask ( unit ) then
8047: LD_VAR 0 1
8051: PPUSH
8052: CALL_OW 314
8056: NOT
8057: IFFALSE 8173
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8059: LD_VAR 0 1
8063: PPUSH
8064: LD_VAR 0 2
8068: PUSH
8069: LD_INT 1
8071: ARRAY
8072: PPUSH
8073: LD_VAR 0 2
8077: PUSH
8078: LD_INT 2
8080: ARRAY
8081: PPUSH
8082: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8086: LD_INT 35
8088: PPUSH
8089: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8093: LD_VAR 0 1
8097: PPUSH
8098: CALL_OW 250
8102: PUSH
8103: LD_VAR 0 2
8107: PUSH
8108: LD_INT 1
8110: ARRAY
8111: EQUAL
8112: PUSH
8113: LD_VAR 0 1
8117: PPUSH
8118: CALL_OW 251
8122: PUSH
8123: LD_VAR 0 2
8127: PUSH
8128: LD_INT 2
8130: ARRAY
8131: EQUAL
8132: AND
8133: IFFALSE 8086
// for i = 1 to 2 do
8135: LD_ADDR_VAR 0 5
8139: PUSH
8140: DOUBLE
8141: LD_INT 1
8143: DEC
8144: ST_TO_ADDR
8145: LD_INT 2
8147: PUSH
8148: FOR_TO
8149: IFFALSE 8171
// coords := Delete ( coords , 1 ) ;
8151: LD_ADDR_VAR 0 2
8155: PUSH
8156: LD_VAR 0 2
8160: PPUSH
8161: LD_INT 1
8163: PPUSH
8164: CALL_OW 3
8168: ST_TO_ADDR
8169: GO 8148
8171: POP
8172: POP
// end ;
8173: GO 8037
// end else
8175: GO 8419
// begin if coords then
8177: LD_VAR 0 2
8181: IFFALSE 8419
// begin x := GetX ( unit ) ;
8183: LD_ADDR_VAR 0 6
8187: PUSH
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 250
8197: ST_TO_ADDR
// y := GetY ( unit ) ;
8198: LD_ADDR_VAR 0 7
8202: PUSH
8203: LD_VAR 0 1
8207: PPUSH
8208: CALL_OW 251
8212: ST_TO_ADDR
// while ( coords > 1 ) do
8213: LD_VAR 0 2
8217: PUSH
8218: LD_INT 1
8220: GREATER
8221: IFFALSE 8419
// begin Wait ( 0 0$0.3 ) ;
8223: LD_INT 10
8225: PPUSH
8226: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 255
8239: PPUSH
8240: LD_VAR 0 1
8244: PPUSH
8245: CALL_OW 250
8249: PPUSH
8250: LD_VAR 0 1
8254: PPUSH
8255: CALL_OW 251
8259: PPUSH
8260: LD_INT 14
8262: PPUSH
8263: CALL 22757 0 4
8267: IFFALSE 8298
// begin ComMoveXY ( unit , x , y ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: LD_VAR 0 6
8278: PPUSH
8279: LD_VAR 0 7
8283: PPUSH
8284: CALL_OW 111
// result := false ;
8288: LD_ADDR_VAR 0 4
8292: PUSH
8293: LD_INT 0
8295: ST_TO_ADDR
// end else
8296: GO 8337
// if not HasTask ( unit ) then
8298: LD_VAR 0 1
8302: PPUSH
8303: CALL_OW 314
8307: NOT
8308: IFFALSE 8337
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8310: LD_VAR 0 1
8314: PPUSH
8315: LD_VAR 0 2
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_VAR 0 2
8328: PUSH
8329: LD_INT 2
8331: ARRAY
8332: PPUSH
8333: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8337: LD_VAR 0 1
8341: PPUSH
8342: CALL_OW 250
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: EQUAL
8356: PUSH
8357: LD_VAR 0 1
8361: PPUSH
8362: CALL_OW 251
8366: PUSH
8367: LD_VAR 0 2
8371: PUSH
8372: LD_INT 2
8374: ARRAY
8375: EQUAL
8376: AND
8377: IFFALSE 8417
// for i = 1 to 2 do
8379: LD_ADDR_VAR 0 5
8383: PUSH
8384: DOUBLE
8385: LD_INT 1
8387: DEC
8388: ST_TO_ADDR
8389: LD_INT 2
8391: PUSH
8392: FOR_TO
8393: IFFALSE 8415
// coords := Delete ( coords , 1 ) ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 2
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 3
8412: ST_TO_ADDR
8413: GO 8392
8415: POP
8416: POP
// end ;
8417: GO 8213
// end ; end ; end ; result := true ;
8419: LD_ADDR_VAR 0 4
8423: PUSH
8424: LD_INT 1
8426: ST_TO_ADDR
// end ;
8427: LD_VAR 0 4
8431: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8432: LD_INT 0
8434: PPUSH
8435: PPUSH
8436: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8437: LD_ADDR_VAR 0 5
8441: PUSH
8442: LD_INT 81
8444: PUSH
8445: LD_VAR 0 1
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PPUSH
8454: CALL_OW 69
8458: ST_TO_ADDR
// for i in units do
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_VAR 0 2
8468: PUSH
8469: FOR_IN
8470: IFFALSE 8498
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8472: LD_VAR 0 4
8476: PPUSH
8477: LD_VAR 0 5
8481: PPUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL_OW 74
8491: PPUSH
8492: CALL_OW 115
// end ;
8496: GO 8469
8498: POP
8499: POP
// end ;
8500: LD_VAR 0 3
8504: RET
// export function MC_Show ( string ) ; begin
8505: LD_INT 0
8507: PPUSH
// display_strings := string ;
8508: LD_ADDR_OWVAR 47
8512: PUSH
8513: LD_VAR 0 1
8517: ST_TO_ADDR
// end ; end_of_file
8518: LD_VAR 0 2
8522: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8523: LD_INT 0
8525: PPUSH
8526: PPUSH
8527: PPUSH
8528: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8529: LD_ADDR_VAR 0 8
8533: PUSH
8534: LD_VAR 0 1
8538: PPUSH
8539: LD_INT 2
8541: PPUSH
8542: EMPTY
8543: PPUSH
8544: CALL 11670 0 3
8548: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8549: LD_VAR 0 8
8553: PUSH
8554: LD_VAR 0 2
8558: PPUSH
8559: LD_VAR 0 3
8563: PPUSH
8564: CALL_OW 428
8568: PUSH
8569: LD_INT 0
8571: EQUAL
8572: AND
8573: IFFALSE 8647
// for i = 1 to plist do
8575: LD_ADDR_VAR 0 6
8579: PUSH
8580: DOUBLE
8581: LD_INT 1
8583: DEC
8584: ST_TO_ADDR
8585: LD_VAR 0 8
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8645
// if NotTask ( plist [ i ] ) then
8593: LD_VAR 0 8
8597: PUSH
8598: LD_VAR 0 6
8602: ARRAY
8603: PPUSH
8604: CALL 32231 0 1
8608: IFFALSE 8643
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8610: LD_VAR 0 8
8614: PUSH
8615: LD_VAR 0 6
8619: ARRAY
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: LD_VAR 0 2
8628: PPUSH
8629: LD_VAR 0 3
8633: PPUSH
8634: LD_VAR 0 4
8638: PPUSH
8639: CALL_OW 145
// end ;
8643: GO 8590
8645: POP
8646: POP
// end ;
8647: LD_VAR 0 5
8651: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8652: LD_INT 0
8654: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 6
8662: PPUSH
8663: LD_VAR 0 2
8667: PPUSH
8668: LD_VAR 0 3
8672: PPUSH
8673: LD_VAR 0 4
8677: PPUSH
8678: CALL 10156 0 5
// end ;
8682: LD_VAR 0 5
8686: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8691: LD_ADDR_VAR 0 4
8695: PUSH
8696: LD_INT 22
8698: PUSH
8699: LD_VAR 0 1
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 30
8713: PUSH
8714: LD_INT 0
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: LD_INT 30
8723: PUSH
8724: LD_INT 1
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: EMPTY
8741: LIST
8742: PPUSH
8743: CALL_OW 69
8747: PPUSH
8748: LD_VAR 0 2
8752: PPUSH
8753: CALL_OW 250
8757: PPUSH
8758: LD_VAR 0 2
8762: PPUSH
8763: CALL_OW 251
8767: PPUSH
8768: CALL_OW 73
8772: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8773: LD_VAR 0 4
8777: PPUSH
8778: LD_VAR 0 2
8782: PPUSH
8783: CALL 10445 0 2
8787: IFFALSE 8846
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8789: LD_VAR 0 1
8793: PPUSH
8794: LD_INT 30
8796: PUSH
8797: LD_VAR 0 2
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: PPUSH
8806: CALL 11587 0 2
8810: PUSH
8811: LD_INT 1
8813: ARRAY
8814: PPUSH
8815: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8819: LD_ADDR_EXP 50
8823: PUSH
8824: LD_EXP 50
8828: PPUSH
8829: LD_VAR 0 1
8833: PPUSH
8834: LD_VAR 0 2
8838: PPUSH
8839: EMPTY
8840: PPUSH
8841: CALL 42166 0 4
8845: ST_TO_ADDR
// end ; end ;
8846: LD_VAR 0 3
8850: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8851: LD_INT 0
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// result := false ;
8859: LD_ADDR_VAR 0 4
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8867: LD_VAR 0 1
8871: PPUSH
8872: LD_EXP 42
8876: PPUSH
8877: CALL 43114 0 2
8881: IFFALSE 9094
// for i = 1 to MREG_LabList do
8883: LD_ADDR_VAR 0 5
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_EXP 42
8897: PUSH
8898: FOR_TO
8899: IFFALSE 9092
// begin if MREG_LabList [ i ] [ 1 ] = side then
8901: LD_EXP 42
8905: PUSH
8906: LD_VAR 0 5
8910: ARRAY
8911: PUSH
8912: LD_INT 1
8914: ARRAY
8915: PUSH
8916: LD_VAR 0 1
8920: EQUAL
8921: IFFALSE 9090
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8923: LD_ADDR_VAR 0 7
8927: PUSH
8928: LD_EXP 42
8932: PUSH
8933: LD_VAR 0 5
8937: ARRAY
8938: PUSH
8939: LD_INT 2
8941: ARRAY
8942: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8943: LD_ADDR_VAR 0 9
8947: PUSH
8948: LD_INT 22
8950: PUSH
8951: LD_VAR 0 1
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 2
8962: PUSH
8963: LD_INT 30
8965: PUSH
8966: LD_INT 0
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 30
8975: PUSH
8976: LD_INT 1
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: LIST
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: PUSH
8992: EMPTY
8993: LIST
8994: PPUSH
8995: CALL_OW 69
8999: PPUSH
9000: LD_VAR 0 7
9004: PPUSH
9005: CALL_OW 250
9009: PPUSH
9010: LD_VAR 0 7
9014: PPUSH
9015: CALL_OW 251
9019: PPUSH
9020: CALL_OW 73
9024: ST_TO_ADDR
// if dep then
9025: LD_VAR 0 9
9029: IFFALSE 9088
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9031: LD_VAR 0 9
9035: PPUSH
9036: LD_VAR 0 2
9040: PPUSH
9041: LD_VAR 0 3
9045: PPUSH
9046: CALL 10561 0 3
9050: IFFALSE 9088
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9052: LD_VAR 0 7
9056: PPUSH
9057: LD_VAR 0 2
9061: PPUSH
9062: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9066: LD_VAR 0 7
9070: PPUSH
9071: LD_VAR 0 3
9075: PPUSH
9076: CALL_OW 207
// result := true ;
9080: LD_ADDR_VAR 0 4
9084: PUSH
9085: LD_INT 1
9087: ST_TO_ADDR
// end ; end ; break ;
9088: GO 9092
// end ; end ;
9090: GO 8898
9092: POP
9093: POP
// end ;
9094: LD_VAR 0 4
9098: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9099: LD_INT 0
9101: PPUSH
9102: PPUSH
9103: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9104: LD_ADDR_VAR 0 7
9108: PUSH
9109: LD_VAR 0 2
9113: PPUSH
9114: LD_VAR 0 3
9118: PPUSH
9119: LD_VAR 0 4
9123: PPUSH
9124: CALL 9286 0 3
9128: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9129: LD_ADDR_EXP 48
9133: PUSH
9134: LD_EXP 48
9138: PPUSH
9139: LD_VAR 0 1
9143: PPUSH
9144: LD_INT 2
9146: PPUSH
9147: LD_VAR 0 2
9151: PUSH
9152: LD_VAR 0 3
9156: PUSH
9157: LD_VAR 0 4
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL 42075 0 4
9171: ST_TO_ADDR
// if ext_list then
9172: LD_VAR 0 5
9176: IFFALSE 9281
// for i = 1 to ext_list do
9178: LD_ADDR_VAR 0 8
9182: PUSH
9183: DOUBLE
9184: LD_INT 1
9186: DEC
9187: ST_TO_ADDR
9188: LD_VAR 0 5
9192: PUSH
9193: FOR_TO
9194: IFFALSE 9279
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9196: LD_ADDR_EXP 48
9200: PUSH
9201: LD_EXP 48
9205: PPUSH
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_VAR 0 5
9215: PUSH
9216: LD_VAR 0 8
9220: ARRAY
9221: PPUSH
9222: LD_VAR 0 7
9226: PUSH
9227: LD_VAR 0 8
9231: ARRAY
9232: PUSH
9233: LD_INT 1
9235: ARRAY
9236: PUSH
9237: LD_VAR 0 7
9241: PUSH
9242: LD_VAR 0 8
9246: ARRAY
9247: PUSH
9248: LD_INT 2
9250: ARRAY
9251: PUSH
9252: LD_VAR 0 7
9256: PUSH
9257: LD_VAR 0 8
9261: ARRAY
9262: PUSH
9263: LD_INT 3
9265: ARRAY
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: PPUSH
9272: CALL 42075 0 4
9276: ST_TO_ADDR
9277: GO 9193
9279: POP
9280: POP
// end ;
9281: LD_VAR 0 6
9285: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
// list := [ ] ;
9290: LD_ADDR_VAR 0 5
9294: PUSH
9295: EMPTY
9296: ST_TO_ADDR
// case d of 0 :
9297: LD_VAR 0 3
9301: PUSH
9302: LD_INT 0
9304: DOUBLE
9305: EQUAL
9306: IFTRUE 9310
9308: GO 9443
9310: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9311: LD_ADDR_VAR 0 5
9315: PUSH
9316: LD_VAR 0 1
9320: PUSH
9321: LD_INT 4
9323: MINUS
9324: PUSH
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 4
9332: MINUS
9333: PUSH
9334: LD_INT 2
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: LIST
9341: PUSH
9342: LD_VAR 0 1
9346: PUSH
9347: LD_INT 3
9349: MINUS
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: LD_INT 1
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 1
9368: PUSH
9369: LD_INT 4
9371: PLUS
9372: PUSH
9373: LD_VAR 0 2
9377: PUSH
9378: LD_INT 4
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: LD_VAR 0 1
9390: PUSH
9391: LD_INT 3
9393: PLUS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 3
9402: PLUS
9403: PUSH
9404: LD_INT 5
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: PUSH
9412: LD_VAR 0 1
9416: PUSH
9417: LD_VAR 0 2
9421: PUSH
9422: LD_INT 4
9424: PLUS
9425: PUSH
9426: LD_INT 0
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: LIST
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: ST_TO_ADDR
// end ; 1 :
9441: GO 10141
9443: LD_INT 1
9445: DOUBLE
9446: EQUAL
9447: IFTRUE 9451
9449: GO 9584
9451: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9452: LD_ADDR_VAR 0 5
9456: PUSH
9457: LD_VAR 0 1
9461: PUSH
9462: LD_VAR 0 2
9466: PUSH
9467: LD_INT 4
9469: MINUS
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: LIST
9478: PUSH
9479: LD_VAR 0 1
9483: PUSH
9484: LD_INT 3
9486: MINUS
9487: PUSH
9488: LD_VAR 0 2
9492: PUSH
9493: LD_INT 3
9495: MINUS
9496: PUSH
9497: LD_INT 2
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: PUSH
9505: LD_VAR 0 1
9509: PUSH
9510: LD_INT 4
9512: MINUS
9513: PUSH
9514: LD_VAR 0 2
9518: PUSH
9519: LD_INT 1
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: PUSH
9527: LD_VAR 0 1
9531: PUSH
9532: LD_VAR 0 2
9536: PUSH
9537: LD_INT 3
9539: PLUS
9540: PUSH
9541: LD_INT 0
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: PUSH
9549: LD_VAR 0 1
9553: PUSH
9554: LD_INT 4
9556: PLUS
9557: PUSH
9558: LD_VAR 0 2
9562: PUSH
9563: LD_INT 4
9565: PLUS
9566: PUSH
9567: LD_INT 5
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: ST_TO_ADDR
// end ; 2 :
9582: GO 10141
9584: LD_INT 2
9586: DOUBLE
9587: EQUAL
9588: IFTRUE 9592
9590: GO 9721
9592: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9593: LD_ADDR_VAR 0 5
9597: PUSH
9598: LD_VAR 0 1
9602: PUSH
9603: LD_VAR 0 2
9607: PUSH
9608: LD_INT 3
9610: MINUS
9611: PUSH
9612: LD_INT 3
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: PUSH
9620: LD_VAR 0 1
9624: PUSH
9625: LD_INT 4
9627: PLUS
9628: PUSH
9629: LD_VAR 0 2
9633: PUSH
9634: LD_INT 4
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: LIST
9641: PUSH
9642: LD_VAR 0 1
9646: PUSH
9647: LD_VAR 0 2
9651: PUSH
9652: LD_INT 4
9654: PLUS
9655: PUSH
9656: LD_INT 0
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_VAR 0 1
9668: PUSH
9669: LD_INT 3
9671: MINUS
9672: PUSH
9673: LD_VAR 0 2
9677: PUSH
9678: LD_INT 1
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: LIST
9685: PUSH
9686: LD_VAR 0 1
9690: PUSH
9691: LD_INT 4
9693: MINUS
9694: PUSH
9695: LD_VAR 0 2
9699: PUSH
9700: LD_INT 4
9702: MINUS
9703: PUSH
9704: LD_INT 2
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: LIST
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: ST_TO_ADDR
// end ; 3 :
9719: GO 10141
9721: LD_INT 3
9723: DOUBLE
9724: EQUAL
9725: IFTRUE 9729
9727: GO 9862
9729: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9730: LD_ADDR_VAR 0 5
9734: PUSH
9735: LD_VAR 0 1
9739: PUSH
9740: LD_INT 3
9742: PLUS
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: LD_INT 4
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: LIST
9756: PUSH
9757: LD_VAR 0 1
9761: PUSH
9762: LD_INT 4
9764: PLUS
9765: PUSH
9766: LD_VAR 0 2
9770: PUSH
9771: LD_INT 4
9773: PLUS
9774: PUSH
9775: LD_INT 5
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_VAR 0 1
9787: PUSH
9788: LD_INT 4
9790: MINUS
9791: PUSH
9792: LD_VAR 0 2
9796: PUSH
9797: LD_INT 1
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: LIST
9804: PUSH
9805: LD_VAR 0 1
9809: PUSH
9810: LD_VAR 0 2
9814: PUSH
9815: LD_INT 4
9817: MINUS
9818: PUSH
9819: LD_INT 3
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: LIST
9826: PUSH
9827: LD_VAR 0 1
9831: PUSH
9832: LD_INT 3
9834: MINUS
9835: PUSH
9836: LD_VAR 0 2
9840: PUSH
9841: LD_INT 3
9843: MINUS
9844: PUSH
9845: LD_INT 2
9847: PUSH
9848: EMPTY
9849: LIST
9850: LIST
9851: LIST
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: ST_TO_ADDR
// end ; 4 :
9860: GO 10141
9862: LD_INT 4
9864: DOUBLE
9865: EQUAL
9866: IFTRUE 9870
9868: GO 10003
9870: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9871: LD_ADDR_VAR 0 5
9875: PUSH
9876: LD_VAR 0 1
9880: PUSH
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 4
9888: PLUS
9889: PUSH
9890: LD_INT 0
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: PUSH
9898: LD_VAR 0 1
9902: PUSH
9903: LD_INT 3
9905: PLUS
9906: PUSH
9907: LD_VAR 0 2
9911: PUSH
9912: LD_INT 3
9914: PLUS
9915: PUSH
9916: LD_INT 5
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: LIST
9923: PUSH
9924: LD_VAR 0 1
9928: PUSH
9929: LD_INT 3
9931: PLUS
9932: PUSH
9933: LD_VAR 0 2
9937: PUSH
9938: LD_INT 4
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: PUSH
9946: LD_VAR 0 1
9950: PUSH
9951: LD_VAR 0 2
9955: PUSH
9956: LD_INT 3
9958: MINUS
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: LIST
9967: PUSH
9968: LD_VAR 0 1
9972: PUSH
9973: LD_INT 4
9975: MINUS
9976: PUSH
9977: LD_VAR 0 2
9981: PUSH
9982: LD_INT 4
9984: MINUS
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: ST_TO_ADDR
// end ; 5 :
10001: GO 10141
10003: LD_INT 5
10005: DOUBLE
10006: EQUAL
10007: IFTRUE 10011
10009: GO 10140
10011: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10012: LD_ADDR_VAR 0 5
10016: PUSH
10017: LD_VAR 0 1
10021: PUSH
10022: LD_INT 4
10024: MINUS
10025: PUSH
10026: LD_VAR 0 2
10030: PUSH
10031: LD_INT 1
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: LIST
10038: PUSH
10039: LD_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: LD_INT 4
10051: MINUS
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: PUSH
10061: LD_VAR 0 1
10065: PUSH
10066: LD_INT 4
10068: PLUS
10069: PUSH
10070: LD_VAR 0 2
10074: PUSH
10075: LD_INT 4
10077: PLUS
10078: PUSH
10079: LD_INT 5
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: LIST
10086: PUSH
10087: LD_VAR 0 1
10091: PUSH
10092: LD_INT 3
10094: PLUS
10095: PUSH
10096: LD_VAR 0 2
10100: PUSH
10101: LD_INT 4
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PUSH
10109: LD_VAR 0 1
10113: PUSH
10114: LD_VAR 0 2
10118: PUSH
10119: LD_INT 3
10121: PLUS
10122: PUSH
10123: LD_INT 0
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: ST_TO_ADDR
// end ; end ;
10138: GO 10141
10140: POP
// result := list ;
10141: LD_ADDR_VAR 0 4
10145: PUSH
10146: LD_VAR 0 5
10150: ST_TO_ADDR
// end ;
10151: LD_VAR 0 4
10155: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10156: LD_INT 0
10158: PPUSH
10159: PPUSH
10160: PPUSH
10161: PPUSH
10162: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10163: LD_ADDR_VAR 0 10
10167: PUSH
10168: LD_VAR 0 1
10172: PPUSH
10173: LD_INT 2
10175: PPUSH
10176: EMPTY
10177: PPUSH
10178: CALL 11670 0 3
10182: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10183: LD_ADDR_VAR 0 9
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_VAR 0 1
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 2
10202: PUSH
10203: LD_INT 30
10205: PUSH
10206: LD_INT 0
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: PUSH
10213: LD_INT 30
10215: PUSH
10216: LD_INT 1
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: PPUSH
10235: CALL_OW 69
10239: PPUSH
10240: LD_VAR 0 3
10244: PPUSH
10245: LD_VAR 0 4
10249: PPUSH
10250: CALL_OW 73
10254: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10255: LD_ADDR_VAR 0 8
10259: PUSH
10260: LD_VAR 0 9
10264: PPUSH
10265: LD_VAR 0 2
10269: PPUSH
10270: CALL 10445 0 2
10274: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10275: LD_VAR 0 10
10279: PUSH
10280: LD_VAR 0 8
10284: AND
10285: PUSH
10286: LD_VAR 0 9
10290: PPUSH
10291: LD_VAR 0 3
10295: PPUSH
10296: LD_VAR 0 4
10300: PPUSH
10301: CALL_OW 297
10305: PUSH
10306: LD_INT 26
10308: LESSEQUAL
10309: AND
10310: PUSH
10311: LD_VAR 0 3
10315: PPUSH
10316: LD_VAR 0 4
10320: PPUSH
10321: CALL_OW 428
10325: PUSH
10326: LD_INT 0
10328: EQUAL
10329: AND
10330: IFFALSE 10440
// for i = 1 to plist do
10332: LD_ADDR_VAR 0 7
10336: PUSH
10337: DOUBLE
10338: LD_INT 1
10340: DEC
10341: ST_TO_ADDR
10342: LD_VAR 0 10
10346: PUSH
10347: FOR_TO
10348: IFFALSE 10438
// if IsInUnit ( plist [ i ] ) then
10350: LD_VAR 0 10
10354: PUSH
10355: LD_VAR 0 7
10359: ARRAY
10360: PPUSH
10361: CALL_OW 310
10365: IFFALSE 10384
// ComExitBuilding ( plist [ i ] ) else
10367: LD_VAR 0 10
10371: PUSH
10372: LD_VAR 0 7
10376: ARRAY
10377: PPUSH
10378: CALL_OW 122
10382: GO 10436
// if NotTask ( plist [ i ] ) then
10384: LD_VAR 0 10
10388: PUSH
10389: LD_VAR 0 7
10393: ARRAY
10394: PPUSH
10395: CALL 32231 0 1
10399: IFFALSE 10436
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10401: LD_VAR 0 10
10405: PUSH
10406: LD_VAR 0 7
10410: ARRAY
10411: PPUSH
10412: LD_VAR 0 2
10416: PPUSH
10417: LD_VAR 0 3
10421: PPUSH
10422: LD_VAR 0 4
10426: PPUSH
10427: LD_VAR 0 5
10431: PPUSH
10432: CALL_OW 145
// end ;
10436: GO 10347
10438: POP
10439: POP
// end ;
10440: LD_VAR 0 6
10444: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10445: LD_INT 0
10447: PPUSH
10448: PPUSH
10449: PPUSH
// pom := GetBase ( bdepot ) ;
10450: LD_ADDR_VAR 0 4
10454: PUSH
10455: LD_VAR 0 1
10459: PPUSH
10460: CALL_OW 274
10464: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10465: LD_ADDR_VAR 0 5
10469: PUSH
10470: LD_VAR 0 2
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 248
10484: PPUSH
10485: CALL_OW 450
10489: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10490: LD_VAR 0 4
10494: PPUSH
10495: LD_INT 1
10497: PPUSH
10498: CALL_OW 275
10502: PUSH
10503: LD_VAR 0 5
10507: PUSH
10508: LD_INT 1
10510: ARRAY
10511: GREATEREQUAL
10512: PUSH
10513: LD_VAR 0 4
10517: PPUSH
10518: LD_INT 3
10520: PPUSH
10521: CALL_OW 275
10525: PUSH
10526: LD_VAR 0 5
10530: PUSH
10531: LD_INT 3
10533: ARRAY
10534: GREATEREQUAL
10535: AND
10536: IFFALSE 10548
// result := true else
10538: LD_ADDR_VAR 0 3
10542: PUSH
10543: LD_INT 1
10545: ST_TO_ADDR
10546: GO 10556
// result := false ;
10548: LD_ADDR_VAR 0 3
10552: PUSH
10553: LD_INT 0
10555: ST_TO_ADDR
// end ;
10556: LD_VAR 0 3
10560: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10561: LD_INT 0
10563: PPUSH
10564: PPUSH
10565: PPUSH
10566: PPUSH
10567: PPUSH
// pom := GetBase ( bdepot ) ;
10568: LD_ADDR_VAR 0 5
10572: PUSH
10573: LD_VAR 0 1
10577: PPUSH
10578: CALL_OW 274
10582: ST_TO_ADDR
// cost := [ ] ;
10583: LD_ADDR_VAR 0 8
10587: PUSH
10588: EMPTY
10589: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10590: LD_ADDR_VAR 0 6
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_VAR 0 1
10604: PPUSH
10605: CALL_OW 248
10609: PPUSH
10610: CALL_OW 450
10614: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10615: LD_ADDR_VAR 0 7
10619: PUSH
10620: LD_VAR 0 3
10624: PPUSH
10625: LD_VAR 0 1
10629: PPUSH
10630: CALL_OW 248
10634: PPUSH
10635: CALL_OW 450
10639: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10640: LD_ADDR_VAR 0 8
10644: PUSH
10645: LD_VAR 0 8
10649: PPUSH
10650: LD_INT 1
10652: PPUSH
10653: LD_VAR 0 6
10657: PUSH
10658: LD_INT 1
10660: ARRAY
10661: PUSH
10662: LD_VAR 0 7
10666: PUSH
10667: LD_INT 1
10669: ARRAY
10670: PLUS
10671: PPUSH
10672: CALL_OW 1
10676: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10677: LD_ADDR_VAR 0 8
10681: PUSH
10682: LD_VAR 0 8
10686: PPUSH
10687: LD_INT 2
10689: PPUSH
10690: LD_VAR 0 6
10694: PUSH
10695: LD_INT 2
10697: ARRAY
10698: PUSH
10699: LD_VAR 0 7
10703: PUSH
10704: LD_INT 2
10706: ARRAY
10707: PLUS
10708: PPUSH
10709: CALL_OW 1
10713: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10714: LD_ADDR_VAR 0 8
10718: PUSH
10719: LD_VAR 0 8
10723: PPUSH
10724: LD_INT 3
10726: PPUSH
10727: LD_VAR 0 6
10731: PUSH
10732: LD_INT 3
10734: ARRAY
10735: PUSH
10736: LD_VAR 0 7
10740: PUSH
10741: LD_INT 3
10743: ARRAY
10744: PLUS
10745: PPUSH
10746: CALL_OW 1
10750: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10751: LD_VAR 0 5
10755: PPUSH
10756: LD_INT 1
10758: PPUSH
10759: CALL_OW 275
10763: PUSH
10764: LD_VAR 0 8
10768: PUSH
10769: LD_INT 1
10771: ARRAY
10772: GREATEREQUAL
10773: PUSH
10774: LD_VAR 0 5
10778: PPUSH
10779: LD_INT 3
10781: PPUSH
10782: CALL_OW 275
10786: PUSH
10787: LD_VAR 0 8
10791: PUSH
10792: LD_INT 3
10794: ARRAY
10795: GREATEREQUAL
10796: AND
10797: IFFALSE 10809
// result := true else
10799: LD_ADDR_VAR 0 4
10803: PUSH
10804: LD_INT 1
10806: ST_TO_ADDR
10807: GO 10817
// result := false ;
10809: LD_ADDR_VAR 0 4
10813: PUSH
10814: LD_INT 0
10816: ST_TO_ADDR
// end ;
10817: LD_VAR 0 4
10821: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10822: LD_INT 0
10824: PPUSH
10825: PPUSH
10826: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10827: LD_ADDR_VAR 0 5
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: LD_INT 2
10839: PPUSH
10840: EMPTY
10841: PPUSH
10842: CALL 11670 0 3
10846: ST_TO_ADDR
// if unit and plist then
10847: LD_VAR 0 2
10851: PUSH
10852: LD_VAR 0 5
10856: AND
10857: IFFALSE 10918
// for i = 1 to plist do
10859: LD_ADDR_VAR 0 4
10863: PUSH
10864: DOUBLE
10865: LD_INT 1
10867: DEC
10868: ST_TO_ADDR
10869: LD_VAR 0 5
10873: PUSH
10874: FOR_TO
10875: IFFALSE 10916
// if NotTask ( plist [ i ] ) then
10877: LD_VAR 0 5
10881: PUSH
10882: LD_VAR 0 4
10886: ARRAY
10887: PPUSH
10888: CALL 32231 0 1
10892: IFFALSE 10914
// ComDismantle ( plist [ i ] , unit ) ;
10894: LD_VAR 0 5
10898: PUSH
10899: LD_VAR 0 4
10903: ARRAY
10904: PPUSH
10905: LD_VAR 0 2
10909: PPUSH
10910: CALL_OW 167
10914: GO 10874
10916: POP
10917: POP
// result := true ;
10918: LD_ADDR_VAR 0 3
10922: PUSH
10923: LD_INT 1
10925: ST_TO_ADDR
// end ;
10926: LD_VAR 0 3
10930: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10931: LD_INT 0
10933: PPUSH
10934: PPUSH
10935: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10936: LD_ADDR_VAR 0 5
10940: PUSH
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: EMPTY
10950: PPUSH
10951: CALL 11670 0 3
10955: ST_TO_ADDR
// if unit and plist then
10956: LD_VAR 0 2
10960: PUSH
10961: LD_VAR 0 5
10965: AND
10966: IFFALSE 11027
// for i = 1 to plist do
10968: LD_ADDR_VAR 0 4
10972: PUSH
10973: DOUBLE
10974: LD_INT 1
10976: DEC
10977: ST_TO_ADDR
10978: LD_VAR 0 5
10982: PUSH
10983: FOR_TO
10984: IFFALSE 11025
// if NotTask ( plist [ i ] ) then
10986: LD_VAR 0 5
10990: PUSH
10991: LD_VAR 0 4
10995: ARRAY
10996: PPUSH
10997: CALL 32231 0 1
11001: IFFALSE 11023
// ComComplete ( plist [ i ] , unit ) ;
11003: LD_VAR 0 5
11007: PUSH
11008: LD_VAR 0 4
11012: ARRAY
11013: PPUSH
11014: LD_VAR 0 2
11018: PPUSH
11019: CALL 65758 0 2
11023: GO 10983
11025: POP
11026: POP
// result := true ;
11027: LD_ADDR_VAR 0 3
11031: PUSH
11032: LD_INT 1
11034: ST_TO_ADDR
// end ;
11035: LD_VAR 0 3
11039: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11040: LD_INT 0
11042: PPUSH
11043: PPUSH
11044: PPUSH
11045: PPUSH
11046: PPUSH
11047: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11048: LD_ADDR_VAR 0 5
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_VAR 0 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 21
11067: PUSH
11068: LD_INT 3
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 3
11077: PUSH
11078: LD_INT 57
11080: PUSH
11081: EMPTY
11082: LIST
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 3
11090: PUSH
11091: LD_INT 24
11093: PUSH
11094: LD_INT 1000
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 69
11115: ST_TO_ADDR
// r := [ ] ;
11116: LD_ADDR_VAR 0 6
11120: PUSH
11121: EMPTY
11122: ST_TO_ADDR
// if not tmp then
11123: LD_VAR 0 5
11127: NOT
11128: IFFALSE 11134
// exit else
11130: GO 11322
11132: GO 11302
// begin r := [ tmp [ 1 ] ] ;
11134: LD_ADDR_VAR 0 6
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_INT 1
11146: ARRAY
11147: PUSH
11148: EMPTY
11149: LIST
11150: ST_TO_ADDR
// for i = 2 to tmp do
11151: LD_ADDR_VAR 0 3
11155: PUSH
11156: DOUBLE
11157: LD_INT 2
11159: DEC
11160: ST_TO_ADDR
11161: LD_VAR 0 5
11165: PUSH
11166: FOR_TO
11167: IFFALSE 11300
// begin m := false ;
11169: LD_ADDR_VAR 0 7
11173: PUSH
11174: LD_INT 0
11176: ST_TO_ADDR
// for j = 1 to r do
11177: LD_ADDR_VAR 0 4
11181: PUSH
11182: DOUBLE
11183: LD_INT 1
11185: DEC
11186: ST_TO_ADDR
11187: LD_VAR 0 6
11191: PUSH
11192: FOR_TO
11193: IFFALSE 11267
// if GetLives ( tmp [ i ] ) < r [ j ] then
11195: LD_VAR 0 5
11199: PUSH
11200: LD_VAR 0 3
11204: ARRAY
11205: PPUSH
11206: CALL_OW 256
11210: PUSH
11211: LD_VAR 0 6
11215: PUSH
11216: LD_VAR 0 4
11220: ARRAY
11221: LESS
11222: IFFALSE 11265
// begin r := Insert ( r , j , tmp [ i ] ) ;
11224: LD_ADDR_VAR 0 6
11228: PUSH
11229: LD_VAR 0 6
11233: PPUSH
11234: LD_VAR 0 4
11238: PPUSH
11239: LD_VAR 0 5
11243: PUSH
11244: LD_VAR 0 3
11248: ARRAY
11249: PPUSH
11250: CALL_OW 2
11254: ST_TO_ADDR
// m := true ;
11255: LD_ADDR_VAR 0 7
11259: PUSH
11260: LD_INT 1
11262: ST_TO_ADDR
// break ;
11263: GO 11267
// end ;
11265: GO 11192
11267: POP
11268: POP
// if not m then
11269: LD_VAR 0 7
11273: NOT
11274: IFFALSE 11298
// r := r ^ tmp [ i ] ;
11276: LD_ADDR_VAR 0 6
11280: PUSH
11281: LD_VAR 0 6
11285: PUSH
11286: LD_VAR 0 5
11290: PUSH
11291: LD_VAR 0 3
11295: ARRAY
11296: ADD
11297: ST_TO_ADDR
// end ;
11298: GO 11166
11300: POP
11301: POP
// end ; if r then
11302: LD_VAR 0 6
11306: IFFALSE 11320
// result := r else
11308: LD_ADDR_VAR 0 2
11312: PUSH
11313: LD_VAR 0 6
11317: ST_TO_ADDR
11318: GO 11322
// exit ;
11320: GO 11322
// end ;
11322: LD_VAR 0 2
11326: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11327: LD_INT 0
11329: PPUSH
11330: PPUSH
11331: PPUSH
11332: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11333: LD_ADDR_VAR 0 5
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 1
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 2
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 25
11365: PUSH
11366: LD_INT 16
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 34
11375: PUSH
11376: LD_INT 13
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: LD_INT 34
11385: PUSH
11386: LD_INT 52
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: PUSH
11400: LD_INT 24
11402: PUSH
11403: LD_INT 650
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: LIST
11414: PPUSH
11415: CALL_OW 69
11419: ST_TO_ADDR
// p := 1 ;
11420: LD_ADDR_VAR 0 4
11424: PUSH
11425: LD_INT 1
11427: ST_TO_ADDR
// for i = 1 to repairs do
11428: LD_ADDR_VAR 0 3
11432: PUSH
11433: DOUBLE
11434: LD_INT 1
11436: DEC
11437: ST_TO_ADDR
11438: LD_VAR 0 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11580
// begin if IsInUnit ( repairs [ i ] ) then
11446: LD_VAR 0 5
11450: PUSH
11451: LD_VAR 0 3
11455: ARRAY
11456: PPUSH
11457: CALL_OW 310
11461: IFFALSE 11480
// ComExitBuilding ( repairs [ i ] ) else
11463: LD_VAR 0 5
11467: PUSH
11468: LD_VAR 0 3
11472: ARRAY
11473: PPUSH
11474: CALL_OW 122
11478: GO 11578
// if not HasTask ( repairs [ i ] ) then
11480: LD_VAR 0 5
11484: PUSH
11485: LD_VAR 0 3
11489: ARRAY
11490: PPUSH
11491: CALL_OW 314
11495: NOT
11496: IFFALSE 11578
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11498: LD_VAR 0 5
11502: PUSH
11503: LD_VAR 0 3
11507: ARRAY
11508: PPUSH
11509: LD_EXP 49
11513: PUSH
11514: LD_VAR 0 1
11518: ARRAY
11519: PUSH
11520: LD_VAR 0 4
11524: ARRAY
11525: PPUSH
11526: CALL_OW 130
// if i mod 3 = 0 then
11530: LD_VAR 0 3
11534: PUSH
11535: LD_INT 3
11537: MOD
11538: PUSH
11539: LD_INT 0
11541: EQUAL
11542: IFFALSE 11558
// p := p + 1 ;
11544: LD_ADDR_VAR 0 4
11548: PUSH
11549: LD_VAR 0 4
11553: PUSH
11554: LD_INT 1
11556: PLUS
11557: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11558: LD_EXP 49
11562: PUSH
11563: LD_VAR 0 1
11567: ARRAY
11568: PUSH
11569: LD_VAR 0 4
11573: LESS
11574: IFFALSE 11578
// break ;
11576: GO 11580
// end ; end ;
11578: GO 11443
11580: POP
11581: POP
// end ; end_of_file
11582: LD_VAR 0 2
11586: RET
// export function MCF_Get ( side , filter ) ; begin
11587: LD_INT 0
11589: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_INT 22
11597: PUSH
11598: LD_VAR 0 1
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_VAR 0 2
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// end ;
11621: LD_VAR 0 3
11625: RET
// export function MCF_Lab ( side ) ; begin
11626: LD_INT 0
11628: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11629: LD_ADDR_VAR 0 2
11633: PUSH
11634: LD_INT 22
11636: PUSH
11637: LD_VAR 0 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: LD_INT 30
11648: PUSH
11649: LD_INT 8
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: EMPTY
11657: LIST
11658: LIST
11659: PPUSH
11660: CALL_OW 69
11664: ST_TO_ADDR
// end ;
11665: LD_VAR 0 2
11669: RET
// export function MCF_Class ( side , class , filter ) ; begin
11670: LD_INT 0
11672: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11673: LD_ADDR_VAR 0 4
11677: PUSH
11678: LD_INT 22
11680: PUSH
11681: LD_VAR 0 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 25
11692: PUSH
11693: LD_VAR 0 2
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_All ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 2
11744: PUSH
11745: LD_INT 25
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: LD_INT 25
11757: PUSH
11758: LD_INT 2
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 25
11767: PUSH
11768: LD_INT 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 4
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: PUSH
11792: LD_VAR 0 2
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: LIST
11801: PPUSH
11802: CALL_OW 69
11806: ST_TO_ADDR
// end ;
11807: LD_VAR 0 3
11811: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11812: LD_INT 0
11814: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11815: LD_ADDR_VAR 0 4
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_VAR 0 1
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: PUSH
11832: LD_INT 92
11834: PUSH
11835: LD_VAR 0 2
11839: PUSH
11840: LD_INT 1
11842: ARRAY
11843: PUSH
11844: LD_VAR 0 2
11848: PUSH
11849: LD_INT 2
11851: ARRAY
11852: PUSH
11853: LD_VAR 0 2
11857: PUSH
11858: LD_INT 3
11860: ARRAY
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: PUSH
11868: LD_VAR 0 3
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PPUSH
11878: CALL_OW 69
11882: ST_TO_ADDR
// end ;
11883: LD_VAR 0 4
11887: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11888: LD_INT 0
11890: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11891: LD_ADDR_VAR 0 3
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_VAR 0 1
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PUSH
11908: LD_INT 21
11910: PUSH
11911: LD_INT 2
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_VAR 0 2
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PPUSH
11928: CALL_OW 69
11932: ST_TO_ADDR
// end ;
11933: LD_VAR 0 3
11937: RET
// export function MCF_Cargo ( side ) ; begin
11938: LD_INT 0
11940: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11941: LD_ADDR_VAR 0 2
11945: PUSH
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_INT 2
11953: PUSH
11954: LD_INT 34
11956: PUSH
11957: LD_INT 12
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 34
11966: PUSH
11967: LD_INT 32
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: LD_INT 34
11976: PUSH
11977: LD_INT 51
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: PPUSH
11990: CALL 11888 0 2
11994: ST_TO_ADDR
// end ;
11995: LD_VAR 0 2
11999: RET
// export function MCF_Ape ( side ) ; begin
12000: LD_INT 0
12002: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12003: LD_ADDR_VAR 0 2
12007: PUSH
12008: LD_INT 22
12010: PUSH
12011: LD_VAR 0 1
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 2
12022: PUSH
12023: LD_INT 25
12025: PUSH
12026: LD_INT 12
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: LD_INT 25
12035: PUSH
12036: LD_INT 15
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: LD_INT 25
12045: PUSH
12046: LD_INT 16
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PUSH
12053: LD_INT 25
12055: PUSH
12056: LD_INT 17
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PPUSH
12074: CALL_OW 69
12078: ST_TO_ADDR
// end ;
12079: LD_VAR 0 2
12083: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12084: LD_INT 0
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
// result := [ ] ;
12090: LD_ADDR_VAR 0 3
12094: PUSH
12095: EMPTY
12096: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12097: LD_ADDR_VAR 0 4
12101: PUSH
12102: LD_VAR 0 1
12106: PPUSH
12107: CALL 12000 0 1
12111: ST_TO_ADDR
// case type of 0 , normal :
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 0
12119: DOUBLE
12120: EQUAL
12121: IFTRUE 12131
12123: LD_STRING normal
12125: DOUBLE
12126: EQUAL
12127: IFTRUE 12131
12129: GO 12142
12131: POP
// cl := class_apeman ; 1 , soldier :
12132: LD_ADDR_VAR 0 5
12136: PUSH
12137: LD_INT 12
12139: ST_TO_ADDR
12140: GO 12218
12142: LD_INT 1
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12156
12148: LD_STRING soldier
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12156
12154: GO 12167
12156: POP
// cl := class_apeman_soldier ; 2 , engineer :
12157: LD_ADDR_VAR 0 5
12161: PUSH
12162: LD_INT 15
12164: ST_TO_ADDR
12165: GO 12218
12167: LD_INT 2
12169: DOUBLE
12170: EQUAL
12171: IFTRUE 12181
12173: LD_STRING engineer
12175: DOUBLE
12176: EQUAL
12177: IFTRUE 12181
12179: GO 12192
12181: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12182: LD_ADDR_VAR 0 5
12186: PUSH
12187: LD_INT 16
12189: ST_TO_ADDR
12190: GO 12218
12192: LD_INT 3
12194: DOUBLE
12195: EQUAL
12196: IFTRUE 12206
12198: LD_STRING kamikaze
12200: DOUBLE
12201: EQUAL
12202: IFTRUE 12206
12204: GO 12217
12206: POP
// cl := class_apeman_kamikaze ; end ;
12207: LD_ADDR_VAR 0 5
12211: PUSH
12212: LD_INT 17
12214: ST_TO_ADDR
12215: GO 12218
12217: POP
// for i = 1 to tmp do
12218: LD_ADDR_VAR 0 6
12222: PUSH
12223: DOUBLE
12224: LD_INT 1
12226: DEC
12227: ST_TO_ADDR
12228: LD_VAR 0 4
12232: PUSH
12233: FOR_TO
12234: IFFALSE 12283
// if GetClass ( tmp [ i ] ) = cl then
12236: LD_VAR 0 4
12240: PUSH
12241: LD_VAR 0 6
12245: ARRAY
12246: PPUSH
12247: CALL_OW 257
12251: PUSH
12252: LD_VAR 0 5
12256: EQUAL
12257: IFFALSE 12281
// result := result ^ tmp [ i ] ;
12259: LD_ADDR_VAR 0 3
12263: PUSH
12264: LD_VAR 0 3
12268: PUSH
12269: LD_VAR 0 4
12273: PUSH
12274: LD_VAR 0 6
12278: ARRAY
12279: ADD
12280: ST_TO_ADDR
12281: GO 12233
12283: POP
12284: POP
// end ;
12285: LD_VAR 0 3
12289: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12290: LD_INT 0
12292: PPUSH
12293: PPUSH
12294: PPUSH
12295: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12296: LD_ADDR_VAR 0 5
12300: PUSH
12301: LD_INT 22
12303: PUSH
12304: LD_VAR 0 1
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: LD_VAR 0 3
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PPUSH
12322: CALL_OW 69
12326: ST_TO_ADDR
// r := [ ] ;
12327: LD_ADDR_VAR 0 6
12331: PUSH
12332: EMPTY
12333: ST_TO_ADDR
// if tmp then
12334: LD_VAR 0 5
12338: IFFALSE 12407
// for i = 1 to tmp do
12340: LD_ADDR_VAR 0 7
12344: PUSH
12345: DOUBLE
12346: LD_INT 1
12348: DEC
12349: ST_TO_ADDR
12350: LD_VAR 0 5
12354: PUSH
12355: FOR_TO
12356: IFFALSE 12405
// if GetTag ( tmp [ i ] ) = tag then
12358: LD_VAR 0 5
12362: PUSH
12363: LD_VAR 0 7
12367: ARRAY
12368: PPUSH
12369: CALL_OW 110
12373: PUSH
12374: LD_VAR 0 2
12378: EQUAL
12379: IFFALSE 12403
// r := r ^ tmp [ i ] ;
12381: LD_ADDR_VAR 0 6
12385: PUSH
12386: LD_VAR 0 6
12390: PUSH
12391: LD_VAR 0 5
12395: PUSH
12396: LD_VAR 0 7
12400: ARRAY
12401: ADD
12402: ST_TO_ADDR
12403: GO 12355
12405: POP
12406: POP
// result := r ;
12407: LD_ADDR_VAR 0 4
12411: PUSH
12412: LD_VAR 0 6
12416: ST_TO_ADDR
// end ;
12417: LD_VAR 0 4
12421: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12422: LD_INT 0
12424: PPUSH
12425: PPUSH
12426: PPUSH
// tmp := plist ;
12427: LD_ADDR_VAR 0 5
12431: PUSH
12432: LD_VAR 0 2
12436: ST_TO_ADDR
// if tmp then
12437: LD_VAR 0 5
12441: IFFALSE 12518
// begin for i = 1 to tmp do
12443: LD_ADDR_VAR 0 6
12447: PUSH
12448: DOUBLE
12449: LD_INT 1
12451: DEC
12452: ST_TO_ADDR
12453: LD_VAR 0 5
12457: PUSH
12458: FOR_TO
12459: IFFALSE 12506
// if GetTag ( tmp [ i ] ) <> tag then
12461: LD_VAR 0 5
12465: PUSH
12466: LD_VAR 0 6
12470: ARRAY
12471: PPUSH
12472: CALL_OW 110
12476: PUSH
12477: LD_VAR 0 3
12481: NONEQUAL
12482: IFFALSE 12504
// SetTag ( tmp [ i ] , tag ) ;
12484: LD_VAR 0 5
12488: PUSH
12489: LD_VAR 0 6
12493: ARRAY
12494: PPUSH
12495: LD_VAR 0 3
12499: PPUSH
12500: CALL_OW 109
12504: GO 12458
12506: POP
12507: POP
// result := true ;
12508: LD_ADDR_VAR 0 4
12512: PUSH
12513: LD_INT 1
12515: ST_TO_ADDR
// end else
12516: GO 12526
// result := false ;
12518: LD_ADDR_VAR 0 4
12522: PUSH
12523: LD_INT 0
12525: ST_TO_ADDR
// end ;
12526: LD_VAR 0 4
12530: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12536: LD_ADDR_VAR 0 4
12540: PUSH
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 2
12550: PPUSH
12551: EMPTY
12552: PPUSH
12553: CALL 12290 0 3
12557: ST_TO_ADDR
// if tmp then
12558: LD_VAR 0 4
12562: IFFALSE 12614
// begin for i = 1 to tmp do
12564: LD_ADDR_VAR 0 5
12568: PUSH
12569: DOUBLE
12570: LD_INT 1
12572: DEC
12573: ST_TO_ADDR
12574: LD_VAR 0 4
12578: PUSH
12579: FOR_TO
12580: IFFALSE 12602
// SetTag ( tmp [ i ] , 0 ) ;
12582: LD_VAR 0 4
12586: PUSH
12587: LD_VAR 0 5
12591: ARRAY
12592: PPUSH
12593: LD_INT 0
12595: PPUSH
12596: CALL_OW 109
12600: GO 12579
12602: POP
12603: POP
// result := true ;
12604: LD_ADDR_VAR 0 3
12608: PUSH
12609: LD_INT 1
12611: ST_TO_ADDR
// end else
12612: GO 12622
// result := false ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_INT 0
12621: ST_TO_ADDR
// end ;
12622: LD_VAR 0 3
12626: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12627: LD_INT 0
12629: PPUSH
12630: PPUSH
12631: PPUSH
12632: PPUSH
12633: PPUSH
// sort_list := [ ] ;
12634: LD_ADDR_VAR 0 5
12638: PUSH
12639: EMPTY
12640: ST_TO_ADDR
// for i = 1 to list do
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: DOUBLE
12647: LD_INT 1
12649: DEC
12650: ST_TO_ADDR
12651: LD_VAR 0 1
12655: PUSH
12656: FOR_TO
12657: IFFALSE 12819
// begin if i = 1 then
12659: LD_VAR 0 3
12663: PUSH
12664: LD_INT 1
12666: EQUAL
12667: IFFALSE 12693
// sort_list := sort_list ^ list [ i ] else
12669: LD_ADDR_VAR 0 5
12673: PUSH
12674: LD_VAR 0 5
12678: PUSH
12679: LD_VAR 0 1
12683: PUSH
12684: LD_VAR 0 3
12688: ARRAY
12689: ADD
12690: ST_TO_ADDR
12691: GO 12817
// begin for j = 1 to sort_list do
12693: LD_ADDR_VAR 0 4
12697: PUSH
12698: DOUBLE
12699: LD_INT 1
12701: DEC
12702: ST_TO_ADDR
12703: LD_VAR 0 5
12707: PUSH
12708: FOR_TO
12709: IFFALSE 12786
// begin add := false ;
12711: LD_ADDR_VAR 0 6
12715: PUSH
12716: LD_INT 0
12718: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12719: LD_VAR 0 1
12723: PUSH
12724: LD_VAR 0 3
12728: ARRAY
12729: PUSH
12730: LD_VAR 0 5
12734: PUSH
12735: LD_VAR 0 4
12739: ARRAY
12740: LESS
12741: IFFALSE 12784
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12743: LD_ADDR_VAR 0 5
12747: PUSH
12748: LD_VAR 0 5
12752: PPUSH
12753: LD_VAR 0 4
12757: PPUSH
12758: LD_VAR 0 1
12762: PUSH
12763: LD_VAR 0 3
12767: ARRAY
12768: PPUSH
12769: CALL_OW 2
12773: ST_TO_ADDR
// add := true ;
12774: LD_ADDR_VAR 0 6
12778: PUSH
12779: LD_INT 1
12781: ST_TO_ADDR
// break ;
12782: GO 12786
// end ; end ;
12784: GO 12708
12786: POP
12787: POP
// if not add then
12788: LD_VAR 0 6
12792: NOT
12793: IFFALSE 12817
// sort_list := sort_list ^ list [ i ] ;
12795: LD_ADDR_VAR 0 5
12799: PUSH
12800: LD_VAR 0 5
12804: PUSH
12805: LD_VAR 0 1
12809: PUSH
12810: LD_VAR 0 3
12814: ARRAY
12815: ADD
12816: ST_TO_ADDR
// end ; end ;
12817: GO 12656
12819: POP
12820: POP
// result := sort_list ;
12821: LD_ADDR_VAR 0 2
12825: PUSH
12826: LD_VAR 0 5
12830: ST_TO_ADDR
// end ;
12831: LD_VAR 0 2
12835: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
12840: PPUSH
12841: PPUSH
12842: PPUSH
// sort_list := [ ] ;
12843: LD_ADDR_VAR 0 5
12847: PUSH
12848: EMPTY
12849: ST_TO_ADDR
// for i = 1 to list do
12850: LD_ADDR_VAR 0 3
12854: PUSH
12855: DOUBLE
12856: LD_INT 1
12858: DEC
12859: ST_TO_ADDR
12860: LD_VAR 0 1
12864: PUSH
12865: FOR_TO
12866: IFFALSE 13028
// begin if i = 1 then
12868: LD_VAR 0 3
12872: PUSH
12873: LD_INT 1
12875: EQUAL
12876: IFFALSE 12902
// sort_list := sort_list ^ list [ i ] else
12878: LD_ADDR_VAR 0 5
12882: PUSH
12883: LD_VAR 0 5
12887: PUSH
12888: LD_VAR 0 1
12892: PUSH
12893: LD_VAR 0 3
12897: ARRAY
12898: ADD
12899: ST_TO_ADDR
12900: GO 13026
// begin for j = 1 to sort_list do
12902: LD_ADDR_VAR 0 4
12906: PUSH
12907: DOUBLE
12908: LD_INT 1
12910: DEC
12911: ST_TO_ADDR
12912: LD_VAR 0 5
12916: PUSH
12917: FOR_TO
12918: IFFALSE 12995
// begin add := false ;
12920: LD_ADDR_VAR 0 6
12924: PUSH
12925: LD_INT 0
12927: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12928: LD_VAR 0 1
12932: PUSH
12933: LD_VAR 0 3
12937: ARRAY
12938: PUSH
12939: LD_VAR 0 5
12943: PUSH
12944: LD_VAR 0 4
12948: ARRAY
12949: GREATER
12950: IFFALSE 12993
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12952: LD_ADDR_VAR 0 5
12956: PUSH
12957: LD_VAR 0 5
12961: PPUSH
12962: LD_VAR 0 4
12966: PPUSH
12967: LD_VAR 0 1
12971: PUSH
12972: LD_VAR 0 3
12976: ARRAY
12977: PPUSH
12978: CALL_OW 2
12982: ST_TO_ADDR
// add := true ;
12983: LD_ADDR_VAR 0 6
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// break ;
12991: GO 12995
// end ; end ;
12993: GO 12917
12995: POP
12996: POP
// if not add then
12997: LD_VAR 0 6
13001: NOT
13002: IFFALSE 13026
// sort_list := sort_list ^ list [ i ] ;
13004: LD_ADDR_VAR 0 5
13008: PUSH
13009: LD_VAR 0 5
13013: PUSH
13014: LD_VAR 0 1
13018: PUSH
13019: LD_VAR 0 3
13023: ARRAY
13024: ADD
13025: ST_TO_ADDR
// end ; end ;
13026: GO 12865
13028: POP
13029: POP
// result := sort_list ;
13030: LD_ADDR_VAR 0 2
13034: PUSH
13035: LD_VAR 0 5
13039: ST_TO_ADDR
// end ;
13040: LD_VAR 0 2
13044: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13045: LD_INT 0
13047: PPUSH
13048: PPUSH
13049: PPUSH
13050: PPUSH
13051: PPUSH
13052: PPUSH
// tmp := [ ] ;
13053: LD_ADDR_VAR 0 8
13057: PUSH
13058: EMPTY
13059: ST_TO_ADDR
// r := [ ] ;
13060: LD_ADDR_VAR 0 7
13064: PUSH
13065: EMPTY
13066: ST_TO_ADDR
// add := false ;
13067: LD_ADDR_VAR 0 9
13071: PUSH
13072: LD_INT 0
13074: ST_TO_ADDR
// if plist then
13075: LD_VAR 0 2
13079: IFFALSE 13155
// begin for i = 1 to plist do
13081: LD_ADDR_VAR 0 5
13085: PUSH
13086: DOUBLE
13087: LD_INT 1
13089: DEC
13090: ST_TO_ADDR
13091: LD_VAR 0 2
13095: PUSH
13096: FOR_TO
13097: IFFALSE 13151
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13099: LD_ADDR_VAR 0 8
13103: PUSH
13104: LD_VAR 0 8
13108: PUSH
13109: LD_VAR 0 2
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PUSH
13120: LD_VAR 0 2
13124: PUSH
13125: LD_VAR 0 5
13129: ARRAY
13130: PPUSH
13131: LD_VAR 0 3
13135: PPUSH
13136: CALL_OW 259
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: ADD
13148: ST_TO_ADDR
// end ;
13149: GO 13096
13151: POP
13152: POP
// end else
13153: GO 13163
// result := false ;
13155: LD_ADDR_VAR 0 4
13159: PUSH
13160: LD_INT 0
13162: ST_TO_ADDR
// if tmp then
13163: LD_VAR 0 8
13167: IFFALSE 13341
// begin r := r ^ [ tmp [ 1 ] ] ;
13169: LD_ADDR_VAR 0 7
13173: PUSH
13174: LD_VAR 0 7
13178: PUSH
13179: LD_VAR 0 8
13183: PUSH
13184: LD_INT 1
13186: ARRAY
13187: PUSH
13188: EMPTY
13189: LIST
13190: ADD
13191: ST_TO_ADDR
// for i = 2 to tmp do
13192: LD_ADDR_VAR 0 5
13196: PUSH
13197: DOUBLE
13198: LD_INT 2
13200: DEC
13201: ST_TO_ADDR
13202: LD_VAR 0 8
13206: PUSH
13207: FOR_TO
13208: IFFALSE 13339
// begin for j = 1 to r do
13210: LD_ADDR_VAR 0 6
13214: PUSH
13215: DOUBLE
13216: LD_INT 1
13218: DEC
13219: ST_TO_ADDR
13220: LD_VAR 0 7
13224: PUSH
13225: FOR_TO
13226: IFFALSE 13303
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13228: LD_VAR 0 8
13232: PUSH
13233: LD_VAR 0 5
13237: ARRAY
13238: PUSH
13239: LD_INT 2
13241: ARRAY
13242: PUSH
13243: LD_VAR 0 7
13247: PUSH
13248: LD_VAR 0 6
13252: ARRAY
13253: PUSH
13254: LD_INT 2
13256: ARRAY
13257: LESS
13258: IFFALSE 13301
// begin r := Insert ( r , j , tmp [ i ] ) ;
13260: LD_ADDR_VAR 0 7
13264: PUSH
13265: LD_VAR 0 7
13269: PPUSH
13270: LD_VAR 0 6
13274: PPUSH
13275: LD_VAR 0 8
13279: PUSH
13280: LD_VAR 0 5
13284: ARRAY
13285: PPUSH
13286: CALL_OW 2
13290: ST_TO_ADDR
// add := true ;
13291: LD_ADDR_VAR 0 9
13295: PUSH
13296: LD_INT 1
13298: ST_TO_ADDR
// break ;
13299: GO 13303
// end ; end ;
13301: GO 13225
13303: POP
13304: POP
// if not add then
13305: LD_VAR 0 9
13309: NOT
13310: IFFALSE 13337
// r := r ^ [ tmp [ i ] ] ;
13312: LD_ADDR_VAR 0 7
13316: PUSH
13317: LD_VAR 0 7
13321: PUSH
13322: LD_VAR 0 8
13326: PUSH
13327: LD_VAR 0 5
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// end ;
13337: GO 13207
13339: POP
13340: POP
// end ; result := r ;
13341: LD_ADDR_VAR 0 4
13345: PUSH
13346: LD_VAR 0 7
13350: ST_TO_ADDR
// end ;
13351: LD_VAR 0 4
13355: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13356: LD_INT 0
13358: PPUSH
13359: PPUSH
13360: PPUSH
13361: PPUSH
13362: PPUSH
13363: PPUSH
// tmp := [ ] ;
13364: LD_ADDR_VAR 0 8
13368: PUSH
13369: EMPTY
13370: ST_TO_ADDR
// r := [ ] ;
13371: LD_ADDR_VAR 0 7
13375: PUSH
13376: EMPTY
13377: ST_TO_ADDR
// add := false ;
13378: LD_ADDR_VAR 0 9
13382: PUSH
13383: LD_INT 0
13385: ST_TO_ADDR
// if plist then
13386: LD_VAR 0 2
13390: IFFALSE 13466
// begin for i = 1 to plist do
13392: LD_ADDR_VAR 0 5
13396: PUSH
13397: DOUBLE
13398: LD_INT 1
13400: DEC
13401: ST_TO_ADDR
13402: LD_VAR 0 2
13406: PUSH
13407: FOR_TO
13408: IFFALSE 13462
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13410: LD_ADDR_VAR 0 8
13414: PUSH
13415: LD_VAR 0 8
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PUSH
13431: LD_VAR 0 2
13435: PUSH
13436: LD_VAR 0 5
13440: ARRAY
13441: PPUSH
13442: LD_VAR 0 3
13446: PPUSH
13447: CALL_OW 259
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: EMPTY
13457: LIST
13458: ADD
13459: ST_TO_ADDR
// end ;
13460: GO 13407
13462: POP
13463: POP
// end else
13464: GO 13474
// result := false ;
13466: LD_ADDR_VAR 0 4
13470: PUSH
13471: LD_INT 0
13473: ST_TO_ADDR
// if tmp then
13474: LD_VAR 0 8
13478: IFFALSE 13652
// begin r := r ^ [ tmp [ 1 ] ] ;
13480: LD_ADDR_VAR 0 7
13484: PUSH
13485: LD_VAR 0 7
13489: PUSH
13490: LD_VAR 0 8
13494: PUSH
13495: LD_INT 1
13497: ARRAY
13498: PUSH
13499: EMPTY
13500: LIST
13501: ADD
13502: ST_TO_ADDR
// for i = 2 to tmp do
13503: LD_ADDR_VAR 0 5
13507: PUSH
13508: DOUBLE
13509: LD_INT 2
13511: DEC
13512: ST_TO_ADDR
13513: LD_VAR 0 8
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13650
// begin for j = 1 to r do
13521: LD_ADDR_VAR 0 6
13525: PUSH
13526: DOUBLE
13527: LD_INT 1
13529: DEC
13530: ST_TO_ADDR
13531: LD_VAR 0 7
13535: PUSH
13536: FOR_TO
13537: IFFALSE 13614
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13539: LD_VAR 0 8
13543: PUSH
13544: LD_VAR 0 5
13548: ARRAY
13549: PUSH
13550: LD_INT 2
13552: ARRAY
13553: PUSH
13554: LD_VAR 0 7
13558: PUSH
13559: LD_VAR 0 6
13563: ARRAY
13564: PUSH
13565: LD_INT 2
13567: ARRAY
13568: GREATER
13569: IFFALSE 13612
// begin r := Insert ( r , j , tmp [ i ] ) ;
13571: LD_ADDR_VAR 0 7
13575: PUSH
13576: LD_VAR 0 7
13580: PPUSH
13581: LD_VAR 0 6
13585: PPUSH
13586: LD_VAR 0 8
13590: PUSH
13591: LD_VAR 0 5
13595: ARRAY
13596: PPUSH
13597: CALL_OW 2
13601: ST_TO_ADDR
// add := true ;
13602: LD_ADDR_VAR 0 9
13606: PUSH
13607: LD_INT 1
13609: ST_TO_ADDR
// break ;
13610: GO 13614
// end ; end ;
13612: GO 13536
13614: POP
13615: POP
// if not add then
13616: LD_VAR 0 9
13620: NOT
13621: IFFALSE 13648
// r := r ^ [ tmp [ i ] ] ;
13623: LD_ADDR_VAR 0 7
13627: PUSH
13628: LD_VAR 0 7
13632: PUSH
13633: LD_VAR 0 8
13637: PUSH
13638: LD_VAR 0 5
13642: ARRAY
13643: PUSH
13644: EMPTY
13645: LIST
13646: ADD
13647: ST_TO_ADDR
// end ;
13648: GO 13518
13650: POP
13651: POP
// end ; result := r ;
13652: LD_ADDR_VAR 0 4
13656: PUSH
13657: LD_VAR 0 7
13661: ST_TO_ADDR
// end ;
13662: LD_VAR 0 4
13666: RET
// export function MCF_Clear ( side ) ; var i ; begin
13667: LD_INT 0
13669: PPUSH
13670: PPUSH
// for i = 1 to 100 do
13671: LD_ADDR_VAR 0 3
13675: PUSH
13676: DOUBLE
13677: LD_INT 1
13679: DEC
13680: ST_TO_ADDR
13681: LD_INT 100
13683: PUSH
13684: FOR_TO
13685: IFFALSE 13721
// if MCF_Tag ( side , i , [ ] ) then
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_VAR 0 3
13696: PPUSH
13697: EMPTY
13698: PPUSH
13699: CALL 12290 0 3
13703: IFFALSE 13719
// MCF_ClearTag ( side , i ) ;
13705: LD_VAR 0 1
13709: PPUSH
13710: LD_VAR 0 3
13714: PPUSH
13715: CALL 12531 0 2
13719: GO 13684
13721: POP
13722: POP
// result := true ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_INT 1
13730: ST_TO_ADDR
// end ;
13731: LD_VAR 0 2
13735: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
13740: PPUSH
// for i = 1 to plist do
13741: LD_ADDR_VAR 0 4
13745: PUSH
13746: DOUBLE
13747: LD_INT 1
13749: DEC
13750: ST_TO_ADDR
13751: LD_VAR 0 1
13755: PUSH
13756: FOR_TO
13757: IFFALSE 13806
// if MCF_HasClass ( plist [ i ] ) = n then
13759: LD_VAR 0 1
13763: PUSH
13764: LD_VAR 0 4
13768: ARRAY
13769: PPUSH
13770: CALL 14293 0 1
13774: PUSH
13775: LD_VAR 0 2
13779: EQUAL
13780: IFFALSE 13804
// tmp := tmp ^ plist [ i ] ;
13782: LD_ADDR_VAR 0 5
13786: PUSH
13787: LD_VAR 0 5
13791: PUSH
13792: LD_VAR 0 1
13796: PUSH
13797: LD_VAR 0 4
13801: ARRAY
13802: ADD
13803: ST_TO_ADDR
13804: GO 13756
13806: POP
13807: POP
// result := tmp ;
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_VAR 0 5
13817: ST_TO_ADDR
// end ;
13818: LD_VAR 0 3
13822: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13823: LD_INT 0
13825: PPUSH
13826: PPUSH
13827: PPUSH
// if mreg = ToArm then
13828: LD_VAR 0 2
13832: PUSH
13833: LD_STRING ToArm
13835: EQUAL
13836: IFFALSE 13941
// begin tmp := MREG_ToArm [ side ] ;
13838: LD_ADDR_VAR 0 6
13842: PUSH
13843: LD_EXP 58
13847: PUSH
13848: LD_VAR 0 1
13852: ARRAY
13853: ST_TO_ADDR
// if tmp = 0 then
13854: LD_VAR 0 6
13858: PUSH
13859: LD_INT 0
13861: EQUAL
13862: IFFALSE 13868
// exit else
13864: GO 14288
13866: GO 13941
// begin for i = MREG_ToArm [ side ] downto n do
13868: LD_ADDR_VAR 0 5
13872: PUSH
13873: DOUBLE
13874: LD_EXP 58
13878: PUSH
13879: LD_VAR 0 1
13883: ARRAY
13884: INC
13885: ST_TO_ADDR
13886: LD_VAR 0 3
13890: PUSH
13891: FOR_DOWNTO
13892: IFFALSE 13914
// tmp := Delete ( tmp , 1 ) ;
13894: LD_ADDR_VAR 0 6
13898: PUSH
13899: LD_VAR 0 6
13903: PPUSH
13904: LD_INT 1
13906: PPUSH
13907: CALL_OW 3
13911: ST_TO_ADDR
13912: GO 13891
13914: POP
13915: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13916: LD_ADDR_EXP 58
13920: PUSH
13921: LD_EXP 58
13925: PPUSH
13926: LD_VAR 0 1
13930: PPUSH
13931: LD_VAR 0 6
13935: PPUSH
13936: CALL_OW 1
13940: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13941: LD_VAR 0 2
13945: PUSH
13946: LD_STRING ToDep
13948: EQUAL
13949: IFFALSE 14054
// begin tmp := MREG_ToDep [ side ] ;
13951: LD_ADDR_VAR 0 6
13955: PUSH
13956: LD_EXP 59
13960: PUSH
13961: LD_VAR 0 1
13965: ARRAY
13966: ST_TO_ADDR
// if tmp = 0 then
13967: LD_VAR 0 6
13971: PUSH
13972: LD_INT 0
13974: EQUAL
13975: IFFALSE 13981
// exit else
13977: GO 14288
13979: GO 14054
// begin for i = MREG_ToDep [ side ] downto n do
13981: LD_ADDR_VAR 0 5
13985: PUSH
13986: DOUBLE
13987: LD_EXP 59
13991: PUSH
13992: LD_VAR 0 1
13996: ARRAY
13997: INC
13998: ST_TO_ADDR
13999: LD_VAR 0 3
14003: PUSH
14004: FOR_DOWNTO
14005: IFFALSE 14027
// tmp := Delete ( tmp , 1 ) ;
14007: LD_ADDR_VAR 0 6
14011: PUSH
14012: LD_VAR 0 6
14016: PPUSH
14017: LD_INT 1
14019: PPUSH
14020: CALL_OW 3
14024: ST_TO_ADDR
14025: GO 14004
14027: POP
14028: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14029: LD_ADDR_EXP 59
14033: PUSH
14034: LD_EXP 59
14038: PPUSH
14039: LD_VAR 0 1
14043: PPUSH
14044: LD_VAR 0 6
14048: PPUSH
14049: CALL_OW 1
14053: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14054: LD_VAR 0 2
14058: PUSH
14059: LD_STRING ToFac
14061: EQUAL
14062: IFFALSE 14167
// begin tmp := MREG_ToFac [ side ] ;
14064: LD_ADDR_VAR 0 6
14068: PUSH
14069: LD_EXP 57
14073: PUSH
14074: LD_VAR 0 1
14078: ARRAY
14079: ST_TO_ADDR
// if tmp = 0 then
14080: LD_VAR 0 6
14084: PUSH
14085: LD_INT 0
14087: EQUAL
14088: IFFALSE 14094
// exit else
14090: GO 14288
14092: GO 14167
// begin for i = MREG_ToFac [ side ] downto n do
14094: LD_ADDR_VAR 0 5
14098: PUSH
14099: DOUBLE
14100: LD_EXP 57
14104: PUSH
14105: LD_VAR 0 1
14109: ARRAY
14110: INC
14111: ST_TO_ADDR
14112: LD_VAR 0 3
14116: PUSH
14117: FOR_DOWNTO
14118: IFFALSE 14140
// tmp := Delete ( tmp , 1 ) ;
14120: LD_ADDR_VAR 0 6
14124: PUSH
14125: LD_VAR 0 6
14129: PPUSH
14130: LD_INT 1
14132: PPUSH
14133: CALL_OW 3
14137: ST_TO_ADDR
14138: GO 14117
14140: POP
14141: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14142: LD_ADDR_EXP 57
14146: PUSH
14147: LD_EXP 57
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: LD_VAR 0 6
14161: PPUSH
14162: CALL_OW 1
14166: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14167: LD_VAR 0 2
14171: PUSH
14172: LD_STRING ToLab
14174: EQUAL
14175: IFFALSE 14280
// begin tmp := MREG_ToLab [ side ] ;
14177: LD_ADDR_VAR 0 6
14181: PUSH
14182: LD_EXP 56
14186: PUSH
14187: LD_VAR 0 1
14191: ARRAY
14192: ST_TO_ADDR
// if tmp = 0 then
14193: LD_VAR 0 6
14197: PUSH
14198: LD_INT 0
14200: EQUAL
14201: IFFALSE 14207
// exit else
14203: GO 14288
14205: GO 14280
// begin for i = MREG_ToLab [ side ] downto n do
14207: LD_ADDR_VAR 0 5
14211: PUSH
14212: DOUBLE
14213: LD_EXP 56
14217: PUSH
14218: LD_VAR 0 1
14222: ARRAY
14223: INC
14224: ST_TO_ADDR
14225: LD_VAR 0 3
14229: PUSH
14230: FOR_DOWNTO
14231: IFFALSE 14253
// tmp := Delete ( tmp , 1 ) ;
14233: LD_ADDR_VAR 0 6
14237: PUSH
14238: LD_VAR 0 6
14242: PPUSH
14243: LD_INT 1
14245: PPUSH
14246: CALL_OW 3
14250: ST_TO_ADDR
14251: GO 14230
14253: POP
14254: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14255: LD_ADDR_EXP 56
14259: PUSH
14260: LD_EXP 56
14264: PPUSH
14265: LD_VAR 0 1
14269: PPUSH
14270: LD_VAR 0 6
14274: PPUSH
14275: CALL_OW 1
14279: ST_TO_ADDR
// end ; end ; result := true ;
14280: LD_ADDR_VAR 0 4
14284: PUSH
14285: LD_INT 1
14287: ST_TO_ADDR
// end ;
14288: LD_VAR 0 4
14292: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14293: LD_INT 0
14295: PPUSH
14296: PPUSH
14297: PPUSH
// side := GetSide ( unit ) ;
14298: LD_ADDR_VAR 0 4
14302: PUSH
14303: LD_VAR 0 1
14307: PPUSH
14308: CALL_OW 255
14312: ST_TO_ADDR
// tmp := 0 ;
14313: LD_ADDR_VAR 0 3
14317: PUSH
14318: LD_INT 0
14320: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14321: LD_VAR 0 1
14325: PUSH
14326: LD_EXP 58
14330: PUSH
14331: LD_VAR 0 4
14335: ARRAY
14336: IN
14337: IFFALSE 14347
// tmp := 1 ;
14339: LD_ADDR_VAR 0 3
14343: PUSH
14344: LD_INT 1
14346: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14347: LD_VAR 0 1
14351: PUSH
14352: LD_EXP 59
14356: PUSH
14357: LD_VAR 0 4
14361: ARRAY
14362: IN
14363: IFFALSE 14373
// tmp := 2 ;
14365: LD_ADDR_VAR 0 3
14369: PUSH
14370: LD_INT 2
14372: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14373: LD_VAR 0 1
14377: PUSH
14378: LD_EXP 57
14382: PUSH
14383: LD_VAR 0 4
14387: ARRAY
14388: IN
14389: IFFALSE 14399
// tmp := 3 ;
14391: LD_ADDR_VAR 0 3
14395: PUSH
14396: LD_INT 3
14398: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 56
14408: PUSH
14409: LD_VAR 0 4
14413: ARRAY
14414: IN
14415: IFFALSE 14425
// tmp := 4 ;
14417: LD_ADDR_VAR 0 3
14421: PUSH
14422: LD_INT 4
14424: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14425: LD_VAR 0 1
14429: PUSH
14430: LD_EXP 70
14434: PUSH
14435: LD_VAR 0 4
14439: ARRAY
14440: IN
14441: IFFALSE 14451
// tmp := 5 ;
14443: LD_ADDR_VAR 0 3
14447: PUSH
14448: LD_INT 5
14450: ST_TO_ADDR
// result := tmp ;
14451: LD_ADDR_VAR 0 2
14455: PUSH
14456: LD_VAR 0 3
14460: ST_TO_ADDR
// end ;
14461: LD_VAR 0 2
14465: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14466: LD_INT 0
14468: PPUSH
14469: PPUSH
// if mreg = ToArm then
14470: LD_VAR 0 2
14474: PUSH
14475: LD_STRING ToArm
14477: EQUAL
14478: IFFALSE 14567
// for i = MREG_ToArm [ side ] downto 1 do
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: DOUBLE
14486: LD_EXP 58
14490: PUSH
14491: LD_VAR 0 1
14495: ARRAY
14496: INC
14497: ST_TO_ADDR
14498: LD_INT 1
14500: PUSH
14501: FOR_DOWNTO
14502: IFFALSE 14565
// if MREG_ToArm [ side ] [ i ] = unit then
14504: LD_EXP 58
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 5
14519: ARRAY
14520: PUSH
14521: LD_VAR 0 3
14525: EQUAL
14526: IFFALSE 14563
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14528: LD_ADDR_EXP 58
14532: PUSH
14533: LD_EXP 58
14537: PPUSH
14538: LD_EXP 58
14542: PUSH
14543: LD_VAR 0 1
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 5
14553: ARRAY
14554: PPUSH
14555: LD_INT 1
14557: PPUSH
14558: CALL 31284 0 3
14562: ST_TO_ADDR
// end ;
14563: GO 14501
14565: POP
14566: POP
// if mreg = ToDep then
14567: LD_VAR 0 2
14571: PUSH
14572: LD_STRING ToDep
14574: EQUAL
14575: IFFALSE 14664
// for i = MREG_ToDep [ side ] downto 1 do
14577: LD_ADDR_VAR 0 5
14581: PUSH
14582: DOUBLE
14583: LD_EXP 59
14587: PUSH
14588: LD_VAR 0 1
14592: ARRAY
14593: INC
14594: ST_TO_ADDR
14595: LD_INT 1
14597: PUSH
14598: FOR_DOWNTO
14599: IFFALSE 14662
// if MREG_ToDep [ side ] [ i ] = unit then
14601: LD_EXP 59
14605: PUSH
14606: LD_VAR 0 1
14610: ARRAY
14611: PUSH
14612: LD_VAR 0 5
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 3
14622: EQUAL
14623: IFFALSE 14660
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14625: LD_ADDR_EXP 59
14629: PUSH
14630: LD_EXP 59
14634: PPUSH
14635: LD_EXP 59
14639: PUSH
14640: LD_VAR 0 1
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 5
14650: ARRAY
14651: PPUSH
14652: LD_INT 1
14654: PPUSH
14655: CALL 31284 0 3
14659: ST_TO_ADDR
// end ;
14660: GO 14598
14662: POP
14663: POP
// if mreg = ToFac then
14664: LD_VAR 0 2
14668: PUSH
14669: LD_STRING ToFac
14671: EQUAL
14672: IFFALSE 14761
// for i = MREG_ToFac [ side ] downto 1 do
14674: LD_ADDR_VAR 0 5
14678: PUSH
14679: DOUBLE
14680: LD_EXP 57
14684: PUSH
14685: LD_VAR 0 1
14689: ARRAY
14690: INC
14691: ST_TO_ADDR
14692: LD_INT 1
14694: PUSH
14695: FOR_DOWNTO
14696: IFFALSE 14759
// if MREG_ToFac [ side ] [ i ] = unit then
14698: LD_EXP 57
14702: PUSH
14703: LD_VAR 0 1
14707: ARRAY
14708: PUSH
14709: LD_VAR 0 5
14713: ARRAY
14714: PUSH
14715: LD_VAR 0 3
14719: EQUAL
14720: IFFALSE 14757
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14722: LD_ADDR_EXP 57
14726: PUSH
14727: LD_EXP 57
14731: PPUSH
14732: LD_EXP 57
14736: PUSH
14737: LD_VAR 0 1
14741: ARRAY
14742: PUSH
14743: LD_VAR 0 5
14747: ARRAY
14748: PPUSH
14749: LD_INT 1
14751: PPUSH
14752: CALL 31284 0 3
14756: ST_TO_ADDR
// end ;
14757: GO 14695
14759: POP
14760: POP
// if mreg = ToLab then
14761: LD_VAR 0 2
14765: PUSH
14766: LD_STRING ToLab
14768: EQUAL
14769: IFFALSE 14858
// for i = MREG_ToLab [ side ] downto 1 do
14771: LD_ADDR_VAR 0 5
14775: PUSH
14776: DOUBLE
14777: LD_EXP 56
14781: PUSH
14782: LD_VAR 0 1
14786: ARRAY
14787: INC
14788: ST_TO_ADDR
14789: LD_INT 1
14791: PUSH
14792: FOR_DOWNTO
14793: IFFALSE 14856
// if MREG_ToLab [ side ] [ i ] = unit then
14795: LD_EXP 56
14799: PUSH
14800: LD_VAR 0 1
14804: ARRAY
14805: PUSH
14806: LD_VAR 0 5
14810: ARRAY
14811: PUSH
14812: LD_VAR 0 3
14816: EQUAL
14817: IFFALSE 14854
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14819: LD_ADDR_EXP 56
14823: PUSH
14824: LD_EXP 56
14828: PPUSH
14829: LD_EXP 56
14833: PUSH
14834: LD_VAR 0 1
14838: ARRAY
14839: PUSH
14840: LD_VAR 0 5
14844: ARRAY
14845: PPUSH
14846: LD_INT 1
14848: PPUSH
14849: CALL 31284 0 3
14853: ST_TO_ADDR
// end ;
14854: GO 14792
14856: POP
14857: POP
// end ;
14858: LD_VAR 0 4
14862: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14863: LD_INT 0
14865: PPUSH
14866: PPUSH
// result := false ;
14867: LD_ADDR_VAR 0 2
14871: PUSH
14872: LD_INT 0
14874: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14875: LD_ADDR_VAR 0 3
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_EXP 48
14889: PUSH
14890: FOR_TO
14891: IFFALSE 14955
// if MREG_ToBuild [ i ] [ 1 ] = side then
14893: LD_EXP 48
14897: PUSH
14898: LD_VAR 0 3
14902: ARRAY
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 1
14912: EQUAL
14913: IFFALSE 14953
// begin if MREG_ToBuild [ i ] [ 1 ] then
14915: LD_EXP 48
14919: PUSH
14920: LD_VAR 0 3
14924: ARRAY
14925: PUSH
14926: LD_INT 1
14928: ARRAY
14929: IFFALSE 14953
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_EXP 48
14940: PUSH
14941: LD_VAR 0 3
14945: ARRAY
14946: PUSH
14947: LD_INT 1
14949: ARRAY
14950: ST_TO_ADDR
// break ;
14951: GO 14955
// end ; end ;
14953: GO 14890
14955: POP
14956: POP
// for i = 1 to MREG_ToRepair do
14957: LD_ADDR_VAR 0 3
14961: PUSH
14962: DOUBLE
14963: LD_INT 1
14965: DEC
14966: ST_TO_ADDR
14967: LD_EXP 49
14971: PUSH
14972: FOR_TO
14973: IFFALSE 15037
// if MREG_ToRepair [ i ] [ 1 ] = side then
14975: LD_EXP 49
14979: PUSH
14980: LD_VAR 0 3
14984: ARRAY
14985: PUSH
14986: LD_INT 1
14988: ARRAY
14989: PUSH
14990: LD_VAR 0 1
14994: EQUAL
14995: IFFALSE 15035
// begin if MREG_ToRepair [ i ] [ 1 ] then
14997: LD_EXP 49
15001: PUSH
15002: LD_VAR 0 3
15006: ARRAY
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: IFFALSE 15035
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15013: LD_ADDR_VAR 0 2
15017: PUSH
15018: LD_EXP 49
15022: PUSH
15023: LD_VAR 0 3
15027: ARRAY
15028: PUSH
15029: LD_INT 1
15031: ARRAY
15032: ST_TO_ADDR
// break ;
15033: GO 15037
// end ; end ;
15035: GO 14972
15037: POP
15038: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_INT 57
15046: PUSH
15047: EMPTY
15048: LIST
15049: PPUSH
15050: CALL 11587 0 2
15054: IFFALSE 15081
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15056: LD_ADDR_VAR 0 2
15060: PUSH
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 57
15068: PUSH
15069: EMPTY
15070: LIST
15071: PPUSH
15072: CALL 11587 0 2
15076: PUSH
15077: LD_INT 1
15079: ARRAY
15080: ST_TO_ADDR
// end ;
15081: LD_VAR 0 2
15085: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15086: LD_INT 0
15088: PPUSH
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15093: LD_ADDR_VAR 0 6
15097: PUSH
15098: LD_VAR 0 1
15102: PPUSH
15103: LD_INT 21
15105: PUSH
15106: LD_INT 3
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PPUSH
15113: CALL 11587 0 2
15117: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15118: LD_ADDR_VAR 0 7
15122: PUSH
15123: LD_VAR 0 1
15127: PPUSH
15128: LD_INT 81
15130: PUSH
15131: LD_VAR 0 1
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: PPUSH
15140: CALL 11587 0 2
15144: ST_TO_ADDR
// if not enemy then
15145: LD_VAR 0 7
15149: NOT
15150: IFFALSE 15162
// result := false else
15152: LD_ADDR_VAR 0 3
15156: PUSH
15157: LD_INT 0
15159: ST_TO_ADDR
15160: GO 15216
// begin scan := NearestUnit ( b , enemy ) ;
15162: LD_ADDR_VAR 0 5
15166: PUSH
15167: LD_VAR 0 6
15171: PPUSH
15172: LD_VAR 0 7
15176: PPUSH
15177: CALL 32277 0 2
15181: ST_TO_ADDR
// if scan [ 2 ] < dist then
15182: LD_VAR 0 5
15186: PUSH
15187: LD_INT 2
15189: ARRAY
15190: PUSH
15191: LD_VAR 0 2
15195: LESS
15196: IFFALSE 15208
// result := true else
15198: LD_ADDR_VAR 0 3
15202: PUSH
15203: LD_INT 1
15205: ST_TO_ADDR
15206: GO 15216
// result := false ;
15208: LD_ADDR_VAR 0 3
15212: PUSH
15213: LD_INT 0
15215: ST_TO_ADDR
// end ; end ;
15216: LD_VAR 0 3
15220: RET
// export function MCF_Info ( ) ; begin
15221: LD_INT 0
15223: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15224: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15226: PUSH
15227: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15229: ADD
15230: PUSH
15231: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15233: ADD
15234: PUSH
15235: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15237: ADD
15238: PUSH
15239: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15241: ADD
15242: PUSH
15243: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15245: ADD
15246: PUSH
15247: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15249: ADD
15250: PUSH
15251: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15253: ADD
15254: PUSH
15255: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15257: ADD
15258: PUSH
15259: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15261: ADD
15262: PPUSH
15263: CALL 8505 0 1
// end ; end_of_file
15267: LD_VAR 0 1
15271: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15272: LD_INT 0
15274: PPUSH
15275: PPUSH
15276: PPUSH
15277: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15278: LD_ADDR_VAR 0 5
15282: PUSH
15283: LD_VAR 0 1
15287: PPUSH
15288: LD_INT 2
15290: PUSH
15291: LD_INT 25
15293: PUSH
15294: LD_INT 2
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: PUSH
15301: LD_INT 25
15303: PUSH
15304: LD_INT 3
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 25
15313: PUSH
15314: LD_INT 4
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL 11587 0 2
15331: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15332: LD_ADDR_VAR 0 5
15336: PUSH
15337: LD_VAR 0 5
15341: PPUSH
15342: LD_INT 0
15344: PPUSH
15345: CALL 13736 0 2
15349: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15350: LD_ADDR_VAR 0 6
15354: PUSH
15355: LD_VAR 0 1
15359: PPUSH
15360: LD_VAR 0 5
15364: PPUSH
15365: LD_INT 1
15367: PPUSH
15368: CALL 13356 0 3
15372: ST_TO_ADDR
// if n > sk then
15373: LD_VAR 0 2
15377: PUSH
15378: LD_VAR 0 6
15382: GREATER
15383: IFFALSE 15395
// n := sk ;
15385: LD_ADDR_VAR 0 2
15389: PUSH
15390: LD_VAR 0 6
15394: ST_TO_ADDR
// for i = 1 to n do
15395: LD_ADDR_VAR 0 4
15399: PUSH
15400: DOUBLE
15401: LD_INT 1
15403: DEC
15404: ST_TO_ADDR
15405: LD_VAR 0 2
15409: PUSH
15410: FOR_TO
15411: IFFALSE 15523
// if ( sk [ i ] [ 1 ] ) <> 0 then
15413: LD_VAR 0 6
15417: PUSH
15418: LD_VAR 0 4
15422: ARRAY
15423: PUSH
15424: LD_INT 1
15426: ARRAY
15427: PUSH
15428: LD_INT 0
15430: NONEQUAL
15431: IFFALSE 15521
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15433: LD_ADDR_EXP 55
15437: PUSH
15438: LD_EXP 55
15442: PPUSH
15443: LD_VAR 0 1
15447: PPUSH
15448: LD_VAR 0 6
15452: PUSH
15453: LD_VAR 0 4
15457: ARRAY
15458: PUSH
15459: LD_INT 1
15461: ARRAY
15462: PPUSH
15463: LD_INT 1
15465: PPUSH
15466: CALL 42075 0 4
15470: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15471: LD_ADDR_EXP 58
15475: PUSH
15476: LD_EXP 58
15480: PPUSH
15481: LD_VAR 0 1
15485: PPUSH
15486: LD_EXP 58
15490: PUSH
15491: LD_VAR 0 1
15495: ARRAY
15496: PUSH
15497: LD_INT 1
15499: PLUS
15500: PPUSH
15501: LD_VAR 0 6
15505: PUSH
15506: LD_VAR 0 4
15510: ARRAY
15511: PUSH
15512: LD_INT 1
15514: ARRAY
15515: PPUSH
15516: CALL 31125 0 4
15520: ST_TO_ADDR
// end ;
15521: GO 15410
15523: POP
15524: POP
// end ;
15525: LD_VAR 0 3
15529: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15530: LD_INT 0
15532: PPUSH
15533: PPUSH
15534: PPUSH
15535: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15536: LD_ADDR_VAR 0 5
15540: PUSH
15541: LD_VAR 0 1
15545: PPUSH
15546: LD_INT 2
15548: PUSH
15549: LD_INT 25
15551: PUSH
15552: LD_INT 1
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PUSH
15559: LD_INT 25
15561: PUSH
15562: LD_INT 3
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: PUSH
15569: LD_INT 25
15571: PUSH
15572: LD_INT 4
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: PPUSH
15585: CALL 11587 0 2
15589: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15590: LD_ADDR_VAR 0 5
15594: PUSH
15595: LD_VAR 0 5
15599: PPUSH
15600: LD_INT 0
15602: PPUSH
15603: CALL 13736 0 2
15607: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15608: LD_ADDR_VAR 0 6
15612: PUSH
15613: LD_VAR 0 1
15617: PPUSH
15618: LD_VAR 0 5
15622: PPUSH
15623: LD_INT 2
15625: PPUSH
15626: CALL 13356 0 3
15630: ST_TO_ADDR
// if n > sk then
15631: LD_VAR 0 2
15635: PUSH
15636: LD_VAR 0 6
15640: GREATER
15641: IFFALSE 15653
// n := sk ;
15643: LD_ADDR_VAR 0 2
15647: PUSH
15648: LD_VAR 0 6
15652: ST_TO_ADDR
// for i = 1 to n do
15653: LD_ADDR_VAR 0 4
15657: PUSH
15658: DOUBLE
15659: LD_INT 1
15661: DEC
15662: ST_TO_ADDR
15663: LD_VAR 0 2
15667: PUSH
15668: FOR_TO
15669: IFFALSE 15781
// if ( sk [ i ] [ 1 ] ) <> 0 then
15671: LD_VAR 0 6
15675: PUSH
15676: LD_VAR 0 4
15680: ARRAY
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PUSH
15686: LD_INT 0
15688: NONEQUAL
15689: IFFALSE 15779
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15691: LD_ADDR_EXP 55
15695: PUSH
15696: LD_EXP 55
15700: PPUSH
15701: LD_VAR 0 1
15705: PPUSH
15706: LD_VAR 0 6
15710: PUSH
15711: LD_VAR 0 4
15715: ARRAY
15716: PUSH
15717: LD_INT 1
15719: ARRAY
15720: PPUSH
15721: LD_INT 2
15723: PPUSH
15724: CALL 42075 0 4
15728: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15729: LD_ADDR_EXP 59
15733: PUSH
15734: LD_EXP 59
15738: PPUSH
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_EXP 59
15748: PUSH
15749: LD_VAR 0 1
15753: ARRAY
15754: PUSH
15755: LD_INT 1
15757: PLUS
15758: PPUSH
15759: LD_VAR 0 6
15763: PUSH
15764: LD_VAR 0 4
15768: ARRAY
15769: PUSH
15770: LD_INT 1
15772: ARRAY
15773: PPUSH
15774: CALL 31125 0 4
15778: ST_TO_ADDR
// end ;
15779: GO 15668
15781: POP
15782: POP
// end ;
15783: LD_VAR 0 3
15787: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15788: LD_INT 0
15790: PPUSH
15791: PPUSH
15792: PPUSH
15793: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15794: LD_ADDR_VAR 0 5
15798: PUSH
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 2
15806: PUSH
15807: LD_INT 25
15809: PUSH
15810: LD_INT 1
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: PUSH
15817: LD_INT 25
15819: PUSH
15820: LD_INT 2
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 25
15829: PUSH
15830: LD_INT 4
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: PPUSH
15843: CALL 11587 0 2
15847: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15848: LD_ADDR_VAR 0 5
15852: PUSH
15853: LD_VAR 0 5
15857: PPUSH
15858: LD_INT 0
15860: PPUSH
15861: CALL 13736 0 2
15865: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15866: LD_ADDR_VAR 0 6
15870: PUSH
15871: LD_VAR 0 1
15875: PPUSH
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_INT 3
15883: PPUSH
15884: CALL 13356 0 3
15888: ST_TO_ADDR
// if n > sk then
15889: LD_VAR 0 2
15893: PUSH
15894: LD_VAR 0 6
15898: GREATER
15899: IFFALSE 15911
// n := sk ;
15901: LD_ADDR_VAR 0 2
15905: PUSH
15906: LD_VAR 0 6
15910: ST_TO_ADDR
// for i = 1 to n do
15911: LD_ADDR_VAR 0 4
15915: PUSH
15916: DOUBLE
15917: LD_INT 1
15919: DEC
15920: ST_TO_ADDR
15921: LD_VAR 0 2
15925: PUSH
15926: FOR_TO
15927: IFFALSE 16039
// if ( sk [ i ] [ 1 ] ) <> 0 then
15929: LD_VAR 0 6
15933: PUSH
15934: LD_VAR 0 4
15938: ARRAY
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PUSH
15944: LD_INT 0
15946: NONEQUAL
15947: IFFALSE 16037
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15949: LD_ADDR_EXP 55
15953: PUSH
15954: LD_EXP 55
15958: PPUSH
15959: LD_VAR 0 1
15963: PPUSH
15964: LD_VAR 0 6
15968: PUSH
15969: LD_VAR 0 4
15973: ARRAY
15974: PUSH
15975: LD_INT 1
15977: ARRAY
15978: PPUSH
15979: LD_INT 3
15981: PPUSH
15982: CALL 42075 0 4
15986: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15987: LD_ADDR_EXP 57
15991: PUSH
15992: LD_EXP 57
15996: PPUSH
15997: LD_VAR 0 1
16001: PPUSH
16002: LD_EXP 57
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: PUSH
16013: LD_INT 1
16015: PLUS
16016: PPUSH
16017: LD_VAR 0 6
16021: PUSH
16022: LD_VAR 0 4
16026: ARRAY
16027: PUSH
16028: LD_INT 1
16030: ARRAY
16031: PPUSH
16032: CALL 31125 0 4
16036: ST_TO_ADDR
// end ;
16037: GO 15926
16039: POP
16040: POP
// end ;
16041: LD_VAR 0 3
16045: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
16050: PPUSH
16051: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16052: LD_ADDR_VAR 0 5
16056: PUSH
16057: LD_VAR 0 1
16061: PPUSH
16062: LD_INT 2
16064: PUSH
16065: LD_INT 25
16067: PUSH
16068: LD_INT 1
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: LD_INT 25
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL 11587 0 2
16094: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16095: LD_ADDR_VAR 0 5
16099: PUSH
16100: LD_VAR 0 5
16104: PPUSH
16105: LD_INT 0
16107: PPUSH
16108: CALL 13736 0 2
16112: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16113: LD_ADDR_VAR 0 6
16117: PUSH
16118: LD_VAR 0 1
16122: PPUSH
16123: LD_VAR 0 5
16127: PPUSH
16128: LD_INT 4
16130: PPUSH
16131: CALL 13356 0 3
16135: ST_TO_ADDR
// if n > sk then
16136: LD_VAR 0 2
16140: PUSH
16141: LD_VAR 0 6
16145: GREATER
16146: IFFALSE 16158
// n := sk ;
16148: LD_ADDR_VAR 0 2
16152: PUSH
16153: LD_VAR 0 6
16157: ST_TO_ADDR
// for i = 1 to n do
16158: LD_ADDR_VAR 0 4
16162: PUSH
16163: DOUBLE
16164: LD_INT 1
16166: DEC
16167: ST_TO_ADDR
16168: LD_VAR 0 2
16172: PUSH
16173: FOR_TO
16174: IFFALSE 16286
// if ( sk [ i ] [ 1 ] ) <> 0 then
16176: LD_VAR 0 6
16180: PUSH
16181: LD_VAR 0 4
16185: ARRAY
16186: PUSH
16187: LD_INT 1
16189: ARRAY
16190: PUSH
16191: LD_INT 0
16193: NONEQUAL
16194: IFFALSE 16284
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16196: LD_ADDR_EXP 55
16200: PUSH
16201: LD_EXP 55
16205: PPUSH
16206: LD_VAR 0 1
16210: PPUSH
16211: LD_VAR 0 6
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: PPUSH
16226: LD_INT 4
16228: PPUSH
16229: CALL 42075 0 4
16233: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16234: LD_ADDR_EXP 56
16238: PUSH
16239: LD_EXP 56
16243: PPUSH
16244: LD_VAR 0 1
16248: PPUSH
16249: LD_EXP 56
16253: PUSH
16254: LD_VAR 0 1
16258: ARRAY
16259: PUSH
16260: LD_INT 1
16262: PLUS
16263: PPUSH
16264: LD_VAR 0 6
16268: PUSH
16269: LD_VAR 0 4
16273: ARRAY
16274: PUSH
16275: LD_INT 1
16277: ARRAY
16278: PPUSH
16279: CALL 31125 0 4
16283: ST_TO_ADDR
// end ;
16284: GO 16173
16286: POP
16287: POP
// end ;
16288: LD_VAR 0 3
16292: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16293: LD_INT 0
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16299: LD_ADDR_VAR 0 6
16303: PUSH
16304: LD_VAR 0 1
16308: PPUSH
16309: LD_INT 2
16311: PUSH
16312: LD_INT 25
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PUSH
16322: LD_INT 25
16324: PUSH
16325: LD_INT 2
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: PUSH
16332: LD_INT 25
16334: PUSH
16335: LD_INT 3
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PUSH
16342: LD_INT 25
16344: PUSH
16345: LD_INT 4
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: PPUSH
16359: CALL 11587 0 2
16363: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16364: LD_ADDR_VAR 0 6
16368: PUSH
16369: LD_VAR 0 6
16373: PPUSH
16374: LD_INT 0
16376: PPUSH
16377: CALL 13736 0 2
16381: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16382: LD_ADDR_VAR 0 7
16386: PUSH
16387: LD_VAR 0 1
16391: PPUSH
16392: LD_VAR 0 6
16396: PPUSH
16397: LD_INT 1
16399: PPUSH
16400: CALL 13356 0 3
16404: ST_TO_ADDR
// if n > sk then
16405: LD_VAR 0 2
16409: PUSH
16410: LD_VAR 0 7
16414: GREATER
16415: IFFALSE 16427
// n := sk ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 7
16426: ST_TO_ADDR
// for i = 1 to n do
16427: LD_ADDR_VAR 0 5
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16487
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16445: LD_ADDR_EXP 55
16449: PUSH
16450: LD_EXP 55
16454: PPUSH
16455: LD_VAR 0 1
16459: PPUSH
16460: LD_VAR 0 7
16464: PUSH
16465: LD_VAR 0 5
16469: ARRAY
16470: PUSH
16471: LD_INT 1
16473: ARRAY
16474: PPUSH
16475: LD_VAR 0 3
16479: PPUSH
16480: CALL 42075 0 4
16484: ST_TO_ADDR
// end ;
16485: GO 16442
16487: POP
16488: POP
// end ;
16489: LD_VAR 0 4
16493: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
// b := false ;
16499: LD_ADDR_VAR 0 6
16503: PUSH
16504: LD_INT 0
16506: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16507: LD_VAR 0 3
16511: PUSH
16512: LD_INT 1
16514: PUSH
16515: LD_INT 9
16517: PUSH
16518: LD_INT 5
16520: PUSH
16521: LD_INT 8
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: IN
16530: IFFALSE 16618
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16532: LD_VAR 0 1
16536: PPUSH
16537: LD_INT 2
16539: PUSH
16540: LD_INT 30
16542: PUSH
16543: LD_INT 4
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: PUSH
16550: LD_INT 30
16552: PUSH
16553: LD_INT 5
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: PPUSH
16565: CALL 11587 0 2
16569: IFFALSE 16618
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16571: LD_ADDR_VAR 0 6
16575: PUSH
16576: LD_VAR 0 1
16580: PPUSH
16581: LD_INT 2
16583: PUSH
16584: LD_INT 30
16586: PUSH
16587: LD_INT 4
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 30
16596: PUSH
16597: LD_INT 5
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: PPUSH
16609: CALL 11587 0 2
16613: PUSH
16614: LD_INT 1
16616: ARRAY
16617: ST_TO_ADDR
// if class = class_engineer then
16618: LD_VAR 0 3
16622: PUSH
16623: LD_INT 2
16625: EQUAL
16626: IFFALSE 16714
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16628: LD_VAR 0 1
16632: PPUSH
16633: LD_INT 2
16635: PUSH
16636: LD_INT 30
16638: PUSH
16639: LD_INT 0
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: LD_INT 30
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PPUSH
16661: CALL 11587 0 2
16665: IFFALSE 16714
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16667: LD_ADDR_VAR 0 6
16671: PUSH
16672: LD_VAR 0 1
16676: PPUSH
16677: LD_INT 2
16679: PUSH
16680: LD_INT 30
16682: PUSH
16683: LD_INT 0
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: LD_INT 30
16692: PUSH
16693: LD_INT 1
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL 11587 0 2
16709: PUSH
16710: LD_INT 1
16712: ARRAY
16713: ST_TO_ADDR
// if class = class_mechanic then
16714: LD_VAR 0 3
16718: PUSH
16719: LD_INT 3
16721: EQUAL
16722: IFFALSE 16792
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16724: LD_VAR 0 1
16728: PPUSH
16729: LD_INT 30
16731: PUSH
16732: LD_INT 3
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: PPUSH
16739: CALL 11587 0 2
16743: IFFALSE 16792
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16745: LD_ADDR_VAR 0 6
16749: PUSH
16750: LD_VAR 0 1
16754: PPUSH
16755: LD_INT 2
16757: PUSH
16758: LD_INT 30
16760: PUSH
16761: LD_INT 2
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 30
16770: PUSH
16771: LD_INT 3
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: PPUSH
16783: CALL 11587 0 2
16787: PUSH
16788: LD_INT 1
16790: ARRAY
16791: ST_TO_ADDR
// if class = class_scientistic then
16792: LD_VAR 0 3
16796: PUSH
16797: LD_INT 4
16799: EQUAL
16800: IFFALSE 16910
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16802: LD_VAR 0 1
16806: PPUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 30
16812: PUSH
16813: LD_INT 6
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PUSH
16820: LD_INT 30
16822: PUSH
16823: LD_INT 7
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: PUSH
16830: LD_INT 30
16832: PUSH
16833: LD_INT 8
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL 11587 0 2
16850: IFFALSE 16910
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16852: LD_ADDR_VAR 0 6
16856: PUSH
16857: LD_VAR 0 1
16861: PPUSH
16862: LD_INT 2
16864: PUSH
16865: LD_INT 30
16867: PUSH
16868: LD_INT 6
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 30
16877: PUSH
16878: LD_INT 7
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: PUSH
16885: LD_INT 30
16887: PUSH
16888: LD_INT 8
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: PPUSH
16901: CALL 11587 0 2
16905: PUSH
16906: LD_INT 1
16908: ARRAY
16909: ST_TO_ADDR
// if GetClass ( unit ) = class then
16910: LD_VAR 0 2
16914: PPUSH
16915: CALL_OW 257
16919: PUSH
16920: LD_VAR 0 3
16924: EQUAL
16925: IFFALSE 16959
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16927: LD_ADDR_EXP 55
16931: PUSH
16932: LD_EXP 55
16936: PPUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_VAR 0 2
16946: PPUSH
16947: LD_VAR 0 3
16951: PPUSH
16952: CALL 42166 0 4
16956: ST_TO_ADDR
// end else
16957: GO 17052
// if b then
16959: LD_VAR 0 6
16963: IFFALSE 17044
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16965: LD_VAR 0 2
16969: PPUSH
16970: CALL_OW 310
16974: PUSH
16975: LD_VAR 0 2
16979: PPUSH
16980: CALL_OW 310
16984: PUSH
16985: LD_VAR 0 6
16989: NONEQUAL
16990: AND
16991: IFFALSE 17002
// ComExitBuilding ( unit ) ;
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL_OW 122
// if not IsInUnit ( unit ) then
17002: LD_VAR 0 2
17006: PPUSH
17007: CALL_OW 310
17011: NOT
17012: IFFALSE 17028
// ComEnterUnit ( unit , b ) ;
17014: LD_VAR 0 2
17018: PPUSH
17019: LD_VAR 0 6
17023: PPUSH
17024: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17028: LD_VAR 0 2
17032: PPUSH
17033: LD_VAR 0 3
17037: PPUSH
17038: CALL_OW 183
// end else
17042: GO 17052
// result := false ;
17044: LD_ADDR_VAR 0 4
17048: PUSH
17049: LD_INT 0
17051: ST_TO_ADDR
// end ; end_of_file
17052: LD_VAR 0 4
17056: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
17061: PPUSH
17062: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17063: LD_ADDR_VAR 0 5
17067: PUSH
17068: LD_INT 35
17070: PUSH
17071: LD_INT 45
17073: PUSH
17074: LD_INT 46
17076: PUSH
17077: LD_INT 47
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: LD_INT 2
17085: PUSH
17086: LD_INT 48
17088: PUSH
17089: LD_INT 49
17091: PUSH
17092: LD_INT 50
17094: PUSH
17095: LD_INT 20
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: LIST
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: ST_TO_ADDR
// if MCF_Lab ( side ) then
17110: LD_VAR 0 1
17114: PPUSH
17115: CALL 11626 0 1
17119: IFFALSE 17358
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17121: LD_VAR 0 1
17125: PPUSH
17126: CALL 11626 0 1
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: PPUSH
17135: CALL_OW 461
17139: PUSH
17140: LD_INT 2
17142: EQUAL
17143: IFFALSE 17282
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17145: LD_VAR 0 1
17149: PPUSH
17150: CALL 11626 0 1
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL 17454 0 2
17168: IFFALSE 17195
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17170: LD_VAR 0 1
17174: PPUSH
17175: CALL 11626 0 1
17179: PUSH
17180: LD_INT 1
17182: ARRAY
17183: PPUSH
17184: LD_VAR 0 2
17188: PPUSH
17189: CALL_OW 124
17193: GO 17282
// if MCF_Lab ( side ) > 1 then
17195: LD_VAR 0 1
17199: PPUSH
17200: CALL 11626 0 1
17204: PUSH
17205: LD_INT 1
17207: GREATER
17208: IFFALSE 17282
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17210: LD_VAR 0 1
17214: PPUSH
17215: CALL 11626 0 1
17219: PUSH
17220: LD_INT 2
17222: ARRAY
17223: PPUSH
17224: CALL_OW 461
17228: PUSH
17229: LD_INT 2
17231: EQUAL
17232: IFFALSE 17282
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11626 0 1
17243: PUSH
17244: LD_INT 2
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL 17454 0 2
17257: IFFALSE 17282
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11626 0 1
17268: PUSH
17269: LD_INT 2
17271: ARRAY
17272: PPUSH
17273: LD_VAR 0 2
17277: PPUSH
17278: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17282: LD_VAR 0 2
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: LD_INT 11
17292: PUSH
17293: LD_INT 4
17295: PUSH
17296: LD_INT 3
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: LIST
17304: IN
17305: IFFALSE 17358
// begin for lab in MCF_Lab ( side ) do
17307: LD_ADDR_VAR 0 6
17311: PUSH
17312: LD_VAR 0 1
17316: PPUSH
17317: CALL 11626 0 1
17321: PUSH
17322: FOR_IN
17323: IFFALSE 17356
// if BuildingStatus ( lab ) = bs_need_ape then
17325: LD_VAR 0 6
17329: PPUSH
17330: CALL_OW 461
17334: PUSH
17335: LD_INT 10
17337: EQUAL
17338: IFFALSE 17354
// MCL_ResTame ( side , lab ) ;
17340: LD_VAR 0 1
17344: PPUSH
17345: LD_VAR 0 6
17349: PPUSH
17350: CALL 17579 0 2
17354: GO 17322
17356: POP
17357: POP
// end ; end ; end ;
17358: LD_VAR 0 3
17362: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17363: LD_INT 0
17365: PPUSH
17366: PPUSH
// tmp := [ ] ;
17367: LD_ADDR_VAR 0 3
17371: PUSH
17372: EMPTY
17373: ST_TO_ADDR
// if not lab then
17374: LD_VAR 0 1
17378: NOT
17379: IFFALSE 17391
// result := false else
17381: LD_ADDR_VAR 0 2
17385: PUSH
17386: LD_INT 0
17388: ST_TO_ADDR
17389: GO 17449
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17391: LD_ADDR_VAR 0 3
17395: PUSH
17396: LD_VAR 0 3
17400: PUSH
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: CALL_OW 268
17413: ADD
17414: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17415: LD_ADDR_VAR 0 3
17419: PUSH
17420: LD_VAR 0 3
17424: PUSH
17425: LD_VAR 0 1
17429: PPUSH
17430: LD_INT 2
17432: PPUSH
17433: CALL_OW 268
17437: ADD
17438: ST_TO_ADDR
// result := tmp ;
17439: LD_ADDR_VAR 0 2
17443: PUSH
17444: LD_VAR 0 3
17448: ST_TO_ADDR
// end ; end ;
17449: LD_VAR 0 2
17453: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17454: LD_INT 0
17456: PPUSH
17457: PPUSH
17458: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17459: LD_ADDR_VAR 0 5
17463: PUSH
17464: LD_INT 35
17466: PUSH
17467: LD_INT 45
17469: PUSH
17470: LD_INT 46
17472: PUSH
17473: LD_INT 47
17475: PUSH
17476: LD_INT 1
17478: PUSH
17479: LD_INT 2
17481: PUSH
17482: LD_INT 48
17484: PUSH
17485: LD_INT 49
17487: PUSH
17488: LD_INT 50
17490: PUSH
17491: LD_INT 20
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: LIST
17505: ST_TO_ADDR
// if lab then
17506: LD_VAR 0 1
17510: IFFALSE 17566
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17512: LD_VAR 0 2
17516: PUSH
17517: LD_VAR 0 5
17521: IN
17522: PUSH
17523: LD_VAR 0 2
17527: PPUSH
17528: CALL_OW 481
17532: PUSH
17533: LD_VAR 0 1
17537: PPUSH
17538: CALL 17363 0 1
17542: IN
17543: OR
17544: IFFALSE 17556
// result := true else
17546: LD_ADDR_VAR 0 3
17550: PUSH
17551: LD_INT 1
17553: ST_TO_ADDR
17554: GO 17564
// result := false ;
17556: LD_ADDR_VAR 0 3
17560: PUSH
17561: LD_INT 0
17563: ST_TO_ADDR
// end else
17564: GO 17574
// result := false ;
17566: LD_ADDR_VAR 0 3
17570: PUSH
17571: LD_INT 0
17573: ST_TO_ADDR
// end ;
17574: LD_VAR 0 3
17578: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17579: LD_INT 0
17581: PPUSH
17582: PPUSH
17583: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17584: LD_ADDR_VAR 0 4
17588: PUSH
17589: LD_VAR 0 1
17593: PPUSH
17594: LD_INT 171
17596: PPUSH
17597: EMPTY
17598: PPUSH
17599: CALL 12290 0 3
17603: ST_TO_ADDR
// if not ape then
17604: LD_VAR 0 4
17608: NOT
17609: IFFALSE 17641
// if MCF_Ape ( side ) then
17611: LD_VAR 0 1
17615: PPUSH
17616: CALL 12000 0 1
17620: IFFALSE 17641
// ape := MCF_Ape ( side ) [ 1 ] ;
17622: LD_ADDR_VAR 0 4
17626: PUSH
17627: LD_VAR 0 1
17631: PPUSH
17632: CALL 12000 0 1
17636: PUSH
17637: LD_INT 1
17639: ARRAY
17640: ST_TO_ADDR
// if ape then
17641: LD_VAR 0 4
17645: IFFALSE 17696
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17647: LD_VAR 0 4
17651: PUSH
17652: LD_INT 1
17654: ARRAY
17655: PPUSH
17656: CALL_OW 310
17660: PUSH
17661: LD_VAR 0 4
17665: PUSH
17666: LD_INT 1
17668: ARRAY
17669: PPUSH
17670: CALL_OW 310
17674: PUSH
17675: LD_VAR 0 2
17679: NONEQUAL
17680: AND
17681: IFFALSE 17696
// ComExitBuilding ( ape [ 1 ] ) ;
17683: LD_VAR 0 4
17687: PUSH
17688: LD_INT 1
17690: ARRAY
17691: PPUSH
17692: CALL_OW 122
// if not lab then
17696: LD_VAR 0 2
17700: NOT
17701: IFFALSE 17707
// exit else
17703: GO 17855
17705: GO 17815
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17707: LD_VAR 0 1
17711: PPUSH
17712: LD_INT 16
17714: PPUSH
17715: LD_INT 25
17717: PUSH
17718: LD_INT 4
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: PPUSH
17725: CALL 12290 0 3
17729: PUSH
17730: LD_INT 0
17732: EQUAL
17733: PUSH
17734: LD_VAR 0 2
17738: PPUSH
17739: CALL_OW 313
17743: PUSH
17744: LD_INT 6
17746: EQUAL
17747: AND
17748: IFFALSE 17815
// begin tmp := UnitsInside ( lab ) ;
17750: LD_ADDR_VAR 0 5
17754: PUSH
17755: LD_VAR 0 2
17759: PPUSH
17760: CALL_OW 313
17764: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17765: LD_VAR 0 5
17769: PUSH
17770: LD_VAR 0 5
17774: ARRAY
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17783: LD_VAR 0 5
17787: PUSH
17788: LD_VAR 0 5
17792: ARRAY
17793: PPUSH
17794: CALL_OW 310
17798: IFFALSE 17815
// ComExitBuilding ( tmp [ tmp ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 5
17809: ARRAY
17810: PPUSH
17811: CALL_OW 122
// end ; if ape then
17815: LD_VAR 0 4
17819: IFFALSE 17855
// if not IsInUnit ( ape [ 1 ] ) then
17821: LD_VAR 0 4
17825: PUSH
17826: LD_INT 1
17828: ARRAY
17829: PPUSH
17830: CALL_OW 310
17834: NOT
17835: IFFALSE 17855
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17837: LD_VAR 0 4
17841: PUSH
17842: LD_INT 1
17844: ARRAY
17845: PPUSH
17846: LD_VAR 0 2
17850: PPUSH
17851: CALL_OW 120
// end ;
17855: LD_VAR 0 3
17859: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17860: LD_INT 0
17862: PPUSH
17863: PPUSH
17864: PPUSH
// result := false ;
17865: LD_ADDR_VAR 0 2
17869: PUSH
17870: LD_INT 0
17872: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_VAR 0 1
17882: PPUSH
17883: CALL 17970 0 1
17887: ST_TO_ADDR
// if techs then
17888: LD_VAR 0 3
17892: IFFALSE 17922
// if techs [ 2 ] then
17894: LD_VAR 0 3
17898: PUSH
17899: LD_INT 2
17901: ARRAY
17902: IFFALSE 17914
// result := true else
17904: LD_ADDR_VAR 0 2
17908: PUSH
17909: LD_INT 1
17911: ST_TO_ADDR
17912: GO 17922
// result := false ;
17914: LD_ADDR_VAR 0 2
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// end ;
17922: LD_VAR 0 2
17926: RET
// export function MCL_Start ( side ) ; var i ; begin
17927: LD_INT 0
17929: PPUSH
17930: PPUSH
// if MCL_GetTechList ( side ) then
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL 17970 0 1
17940: IFFALSE 17965
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 1
17951: PPUSH
17952: CALL 17970 0 1
17956: PUSH
17957: LD_INT 1
17959: ARRAY
17960: PPUSH
17961: CALL 17057 0 2
// end ;
17965: LD_VAR 0 2
17969: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17970: LD_INT 0
17972: PPUSH
17973: PPUSH
17974: PPUSH
// if MREG_ToRes then
17975: LD_EXP 52
17979: IFFALSE 18064
// for i = 1 to MREG_ToRes do
17981: LD_ADDR_VAR 0 3
17985: PUSH
17986: DOUBLE
17987: LD_INT 1
17989: DEC
17990: ST_TO_ADDR
17991: LD_EXP 52
17995: PUSH
17996: FOR_TO
17997: IFFALSE 18062
// if MREG_ToRes [ i ] [ 1 ] = side then
17999: LD_EXP 52
18003: PUSH
18004: LD_VAR 0 3
18008: ARRAY
18009: PUSH
18010: LD_INT 1
18012: ARRAY
18013: PUSH
18014: LD_VAR 0 1
18018: EQUAL
18019: IFFALSE 18060
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18021: LD_ADDR_VAR 0 4
18025: PUSH
18026: LD_VAR 0 4
18030: PPUSH
18031: LD_VAR 0 4
18035: PUSH
18036: LD_INT 1
18038: PLUS
18039: PPUSH
18040: LD_EXP 52
18044: PUSH
18045: LD_VAR 0 3
18049: ARRAY
18050: PUSH
18051: LD_INT 2
18053: ARRAY
18054: PPUSH
18055: CALL_OW 1
18059: ST_TO_ADDR
// end ;
18060: GO 17996
18062: POP
18063: POP
// result := techs ;
18064: LD_ADDR_VAR 0 2
18068: PUSH
18069: LD_VAR 0 4
18073: ST_TO_ADDR
// end ;
18074: LD_VAR 0 2
18078: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18079: LD_INT 0
18081: PPUSH
18082: PPUSH
// for i = 1 to tech_list do
18083: LD_ADDR_VAR 0 4
18087: PUSH
18088: DOUBLE
18089: LD_INT 1
18091: DEC
18092: ST_TO_ADDR
18093: LD_VAR 0 2
18097: PUSH
18098: FOR_TO
18099: IFFALSE 18153
// if not tech_list [ i ] = 20 then
18101: LD_VAR 0 2
18105: PUSH
18106: LD_VAR 0 4
18110: ARRAY
18111: PUSH
18112: LD_INT 20
18114: EQUAL
18115: NOT
18116: IFFALSE 18151
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18118: LD_ADDR_EXP 52
18122: PUSH
18123: LD_EXP 52
18127: PPUSH
18128: LD_VAR 0 1
18132: PPUSH
18133: LD_VAR 0 2
18137: PUSH
18138: LD_VAR 0 4
18142: ARRAY
18143: PPUSH
18144: EMPTY
18145: PPUSH
18146: CALL 42075 0 4
18150: ST_TO_ADDR
18151: GO 18098
18153: POP
18154: POP
// result := true ;
18155: LD_ADDR_VAR 0 3
18159: PUSH
18160: LD_INT 1
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 3
18167: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18168: LD_INT 0
18170: PPUSH
18171: PPUSH
// for i = MREG_ToRes downto 1 do
18172: LD_ADDR_VAR 0 3
18176: PUSH
18177: DOUBLE
18178: LD_EXP 52
18182: INC
18183: ST_TO_ADDR
18184: LD_INT 1
18186: PUSH
18187: FOR_DOWNTO
18188: IFFALSE 18234
// if MREG_ToRes [ i ] [ 1 ] = side then
18190: LD_EXP 52
18194: PUSH
18195: LD_VAR 0 3
18199: ARRAY
18200: PUSH
18201: LD_INT 1
18203: ARRAY
18204: PUSH
18205: LD_VAR 0 1
18209: EQUAL
18210: IFFALSE 18232
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18212: LD_ADDR_EXP 52
18216: PUSH
18217: LD_EXP 52
18221: PPUSH
18222: LD_VAR 0 3
18226: PPUSH
18227: CALL_OW 3
18231: ST_TO_ADDR
18232: GO 18187
18234: POP
18235: POP
// result := true ;
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: LD_INT 1
18243: ST_TO_ADDR
// end ;
18244: LD_VAR 0 2
18248: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18249: LD_INT 0
18251: PPUSH
// result := GetTechProgress ( side , tech ) ;
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: LD_VAR 0 1
18261: PPUSH
18262: LD_VAR 0 2
18266: PPUSH
18267: CALL_OW 326
18271: ST_TO_ADDR
// end ;
18272: LD_VAR 0 3
18276: RET
// export function MCL_Require ( tech ) ; begin
18277: LD_INT 0
18279: PPUSH
// result := GetTechTechsReq ( tech ) ;
18280: LD_ADDR_VAR 0 2
18284: PUSH
18285: LD_VAR 0 1
18289: PPUSH
18290: CALL_OW 480
18294: ST_TO_ADDR
// end ; end_of_file
18295: LD_VAR 0 2
18299: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18300: LD_INT 0
18302: PPUSH
18303: PPUSH
18304: PPUSH
// uc_side := 0 ;
18305: LD_ADDR_OWVAR 20
18309: PUSH
18310: LD_INT 0
18312: ST_TO_ADDR
// uc_nation := 0 ;
18313: LD_ADDR_OWVAR 21
18317: PUSH
18318: LD_INT 0
18320: ST_TO_ADDR
// for i = 1 to n do
18321: LD_ADDR_VAR 0 5
18325: PUSH
18326: DOUBLE
18327: LD_INT 1
18329: DEC
18330: ST_TO_ADDR
18331: LD_VAR 0 2
18335: PUSH
18336: FOR_TO
18337: IFFALSE 18482
// begin hc_importance := 0 ;
18339: LD_ADDR_OWVAR 32
18343: PUSH
18344: LD_INT 0
18346: ST_TO_ADDR
// hc_gallery :=  ;
18347: LD_ADDR_OWVAR 33
18351: PUSH
18352: LD_STRING 
18354: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18355: LD_ADDR_OWVAR 35
18359: PUSH
18360: LD_VAR 0 3
18364: PUSH
18365: LD_INT 20
18367: MINUS
18368: PPUSH
18369: LD_VAR 0 3
18373: PUSH
18374: LD_INT 20
18376: PLUS
18377: PPUSH
18378: CALL_OW 12
18382: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18383: LD_ADDR_OWVAR 31
18387: PUSH
18388: LD_INT 0
18390: PPUSH
18391: LD_INT 2
18393: PPUSH
18394: CALL_OW 12
18398: PUSH
18399: LD_INT 0
18401: PUSH
18402: LD_INT 0
18404: PUSH
18405: LD_INT 0
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18414: LD_ADDR_OWVAR 30
18418: PUSH
18419: LD_INT 0
18421: PUSH
18422: LD_INT 0
18424: PUSH
18425: LD_INT 0
18427: PUSH
18428: LD_INT 0
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: ST_TO_ADDR
// hc_name :=  ;
18437: LD_ADDR_OWVAR 26
18441: PUSH
18442: LD_STRING 
18444: ST_TO_ADDR
// hc_class := class_apeman ;
18445: LD_ADDR_OWVAR 28
18449: PUSH
18450: LD_INT 12
18452: ST_TO_ADDR
// ape := CreateHuman ;
18453: LD_ADDR_VAR 0 6
18457: PUSH
18458: CALL_OW 44
18462: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18463: LD_VAR 0 6
18467: PPUSH
18468: LD_VAR 0 1
18472: PPUSH
18473: LD_INT 0
18475: PPUSH
18476: CALL_OW 49
// end ;
18480: GO 18336
18482: POP
18483: POP
// end ;
18484: LD_VAR 0 4
18488: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18489: LD_INT 0
18491: PPUSH
18492: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18493: LD_VAR 0 1
18497: PPUSH
18498: CALL 12000 0 1
18502: PUSH
18503: LD_EXP 39
18507: PUSH
18508: LD_VAR 0 1
18512: ARRAY
18513: GREATEREQUAL
18514: IFFALSE 18691
// begin if GetTag ( unit ) = 17 then
18516: LD_VAR 0 2
18520: PPUSH
18521: CALL_OW 110
18525: PUSH
18526: LD_INT 17
18528: EQUAL
18529: IFFALSE 18689
// begin SetTag ( unit , 0 ) ;
18531: LD_VAR 0 2
18535: PPUSH
18536: LD_INT 0
18538: PPUSH
18539: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18543: LD_VAR 0 1
18547: PPUSH
18548: CALL 11626 0 1
18552: PUSH
18553: LD_VAR 0 1
18557: PPUSH
18558: CALL 17970 0 1
18562: NOT
18563: AND
18564: IFFALSE 18589
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18566: LD_VAR 0 2
18570: PPUSH
18571: LD_VAR 0 1
18575: PPUSH
18576: CALL 11626 0 1
18580: PUSH
18581: LD_INT 1
18583: ARRAY
18584: PPUSH
18585: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18589: LD_VAR 0 1
18593: PPUSH
18594: CALL 11626 0 1
18598: NOT
18599: PUSH
18600: LD_VAR 0 1
18604: PPUSH
18605: LD_INT 30
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PPUSH
18615: CALL 11587 0 2
18619: AND
18620: IFFALSE 18689
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18622: LD_VAR 0 2
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: LD_INT 30
18634: PUSH
18635: LD_INT 1
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: PPUSH
18642: CALL 11587 0 2
18646: PUSH
18647: LD_INT 1
18649: ARRAY
18650: PPUSH
18651: CALL_OW 250
18655: PPUSH
18656: LD_VAR 0 1
18660: PPUSH
18661: LD_INT 30
18663: PUSH
18664: LD_INT 1
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PPUSH
18671: CALL 11587 0 2
18675: PUSH
18676: LD_INT 1
18678: ARRAY
18679: PPUSH
18680: CALL_OW 251
18684: PPUSH
18685: CALL_OW 111
// end ; end else
18689: GO 18875
// if GetClass ( unit ) <> 4 then
18691: LD_VAR 0 2
18695: PPUSH
18696: CALL_OW 257
18700: PUSH
18701: LD_INT 4
18703: NONEQUAL
18704: IFFALSE 18710
// exit else
18706: GO 18875
18708: GO 18875
// if GetTag ( unit ) = 0 then
18710: LD_VAR 0 2
18714: PPUSH
18715: CALL_OW 110
18719: PUSH
18720: LD_INT 0
18722: EQUAL
18723: IFFALSE 18739
// SetTag ( unit , 17 ) else
18725: LD_VAR 0 2
18729: PPUSH
18730: LD_INT 17
18732: PPUSH
18733: CALL_OW 109
18737: GO 18875
// begin if IsInUnit ( unit ) then
18739: LD_VAR 0 2
18743: PPUSH
18744: CALL_OW 310
18748: IFFALSE 18759
// ComExitBuilding ( unit ) ;
18750: LD_VAR 0 2
18754: PPUSH
18755: CALL_OW 122
// Wait ( 1 ) ;
18759: LD_INT 1
18761: PPUSH
18762: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18766: LD_ADDR_VAR 0 4
18770: PUSH
18771: LD_INT 22
18773: PUSH
18774: LD_INT 0
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: PUSH
18781: LD_INT 25
18783: PUSH
18784: LD_INT 12
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: PPUSH
18795: CALL_OW 69
18799: PPUSH
18800: LD_VAR 0 2
18804: PPUSH
18805: CALL_OW 74
18809: ST_TO_ADDR
// if not ape then
18810: LD_VAR 0 4
18814: NOT
18815: IFFALSE 18821
// exit else
18817: GO 18875
18819: GO 18830
// ComHold ( ape ) ;
18821: LD_VAR 0 4
18825: PPUSH
18826: CALL_OW 140
// if not HasTask ( unit ) then
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 314
18839: NOT
18840: IFFALSE 18873
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18842: LD_VAR 0 2
18846: PPUSH
18847: LD_VAR 0 4
18851: PPUSH
18852: CALL_OW 250
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: CALL_OW 251
18866: PPUSH
18867: CALL_OW 131
18871: GO 18875
// exit ;
18873: GO 18875
// end ; end ;
18875: LD_VAR 0 3
18879: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18880: LD_INT 0
18882: PPUSH
18883: PPUSH
18884: PPUSH
18885: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18886: LD_ADDR_VAR 0 4
18890: PUSH
18891: LD_EXP 40
18895: PUSH
18896: LD_VAR 0 1
18900: ARRAY
18901: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18902: LD_ADDR_VAR 0 5
18906: PUSH
18907: LD_VAR 0 1
18911: PPUSH
18912: LD_STRING normal
18914: PPUSH
18915: CALL 12084 0 2
18919: ST_TO_ADDR
// if apes then
18920: LD_VAR 0 5
18924: IFFALSE 19152
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18926: LD_INT 2
18928: PPUSH
18929: LD_VAR 0 1
18933: PPUSH
18934: CALL_OW 321
18938: PUSH
18939: LD_INT 2
18941: EQUAL
18942: PUSH
18943: LD_VAR 0 4
18947: PUSH
18948: LD_INT 2
18950: ARRAY
18951: PUSH
18952: LD_INT 1
18954: EQUAL
18955: AND
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_STRING engineer
18964: PPUSH
18965: CALL 12084 0 2
18969: PUSH
18970: LD_INT 3
18972: LESS
18973: AND
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_INT 30
18982: PUSH
18983: LD_INT 1
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: PPUSH
18990: CALL 11587 0 2
18994: AND
18995: IFFALSE 19049
// begin for i in apes do
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 5
19006: PUSH
19007: FOR_IN
19008: IFFALSE 19045
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_VAR 0 1
19019: PPUSH
19020: LD_INT 30
19022: PUSH
19023: LD_INT 1
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: PPUSH
19030: CALL 11587 0 2
19034: PUSH
19035: LD_INT 1
19037: ARRAY
19038: PPUSH
19039: CALL_OW 120
// end ;
19043: GO 19007
19045: POP
19046: POP
// end else
19047: GO 19152
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19049: LD_INT 11
19051: PPUSH
19052: LD_VAR 0 1
19056: PPUSH
19057: CALL_OW 321
19061: PUSH
19062: LD_INT 2
19064: EQUAL
19065: PUSH
19066: LD_VAR 0 4
19070: PUSH
19071: LD_INT 1
19073: ARRAY
19074: PUSH
19075: LD_INT 1
19077: EQUAL
19078: AND
19079: PUSH
19080: LD_VAR 0 1
19084: PPUSH
19085: LD_INT 30
19087: PUSH
19088: LD_INT 5
19090: PUSH
19091: EMPTY
19092: LIST
19093: LIST
19094: PPUSH
19095: CALL 11587 0 2
19099: AND
19100: IFFALSE 19152
// begin for i in apes do
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19150
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19115: LD_VAR 0 3
19119: PPUSH
19120: LD_VAR 0 1
19124: PPUSH
19125: LD_INT 30
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: PPUSH
19135: CALL 11587 0 2
19139: PUSH
19140: LD_INT 1
19142: ARRAY
19143: PPUSH
19144: CALL_OW 120
// end ;
19148: GO 19112
19150: POP
19151: POP
// end ; end ; end ; end_of_file
19152: LD_VAR 0 2
19156: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19157: LD_INT 0
19159: PPUSH
19160: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19161: LD_VAR 0 1
19165: PPUSH
19166: CALL_OW 257
19170: PUSH
19171: LD_INT 4
19173: EQUAL
19174: NOT
19175: PUSH
19176: LD_VAR 0 2
19180: NOT
19181: OR
19182: IFFALSE 19188
// exit else
19184: GO 19222
19186: GO 19222
// if not GetTag ( unit ) = 4 then
19188: LD_VAR 0 1
19192: PPUSH
19193: CALL_OW 110
19197: PUSH
19198: LD_INT 4
19200: EQUAL
19201: NOT
19202: IFFALSE 19208
// exit else
19204: GO 19222
19206: GO 19222
// ComHeal ( unit , target ) ;
19208: LD_VAR 0 1
19212: PPUSH
19213: LD_VAR 0 2
19217: PPUSH
19218: CALL_OW 128
// end ;
19222: LD_VAR 0 3
19226: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19227: LD_INT 0
19229: PPUSH
19230: PPUSH
19231: PPUSH
19232: PPUSH
19233: PPUSH
19234: PPUSH
19235: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19236: LD_ADDR_VAR 0 5
19240: PUSH
19241: LD_INT 22
19243: PUSH
19244: LD_VAR 0 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 1
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: LD_INT 3
19265: PUSH
19266: LD_INT 55
19268: PUSH
19269: EMPTY
19270: LIST
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: PUSH
19276: LD_INT 3
19278: PUSH
19279: LD_INT 54
19281: PUSH
19282: EMPTY
19283: LIST
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 3
19291: PUSH
19292: LD_INT 24
19294: PUSH
19295: LD_INT 1000
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: PPUSH
19313: CALL_OW 69
19317: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19318: LD_ADDR_VAR 0 8
19322: PUSH
19323: LD_VAR 0 1
19327: PPUSH
19328: LD_INT 30
19330: PUSH
19331: LD_INT 1
19333: PUSH
19334: EMPTY
19335: LIST
19336: LIST
19337: PPUSH
19338: CALL 11587 0 2
19342: ST_TO_ADDR
// r := [ ] ;
19343: LD_ADDR_VAR 0 6
19347: PUSH
19348: EMPTY
19349: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19350: LD_VAR 0 1
19354: PPUSH
19355: LD_INT 5
19357: PPUSH
19358: EMPTY
19359: PPUSH
19360: CALL 12290 0 3
19364: IFFALSE 19420
// for j in MCF_Tag ( side , 5 , [ ] ) do
19366: LD_ADDR_VAR 0 4
19370: PUSH
19371: LD_VAR 0 1
19375: PPUSH
19376: LD_INT 5
19378: PPUSH
19379: EMPTY
19380: PPUSH
19381: CALL 12290 0 3
19385: PUSH
19386: FOR_IN
19387: IFFALSE 19418
// if GetLives ( j ) = 1000 then
19389: LD_VAR 0 4
19393: PPUSH
19394: CALL_OW 256
19398: PUSH
19399: LD_INT 1000
19401: EQUAL
19402: IFFALSE 19416
// SetTag ( j , 0 ) ;
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 109
19416: GO 19386
19418: POP
19419: POP
// if tmp then
19420: LD_VAR 0 5
19424: IFFALSE 19753
// begin r := [ tmp [ 1 ] ] ;
19426: LD_ADDR_VAR 0 6
19430: PUSH
19431: LD_VAR 0 5
19435: PUSH
19436: LD_INT 1
19438: ARRAY
19439: PUSH
19440: EMPTY
19441: LIST
19442: ST_TO_ADDR
// for i = 2 to tmp do
19443: LD_ADDR_VAR 0 3
19447: PUSH
19448: DOUBLE
19449: LD_INT 2
19451: DEC
19452: ST_TO_ADDR
19453: LD_VAR 0 5
19457: PUSH
19458: FOR_TO
19459: IFFALSE 19751
// begin m := false ;
19461: LD_ADDR_VAR 0 7
19465: PUSH
19466: LD_INT 0
19468: ST_TO_ADDR
// if d then
19469: LD_VAR 0 8
19473: IFFALSE 19628
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19475: LD_VAR 0 5
19479: PUSH
19480: LD_VAR 0 3
19484: ARRAY
19485: PPUSH
19486: CALL_OW 256
19490: PUSH
19491: LD_INT 650
19493: LESS
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_VAR 0 3
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 8
19510: PUSH
19511: LD_INT 1
19513: ARRAY
19514: PPUSH
19515: CALL_OW 250
19519: PPUSH
19520: LD_VAR 0 8
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: PPUSH
19529: CALL_OW 251
19533: PPUSH
19534: CALL_OW 297
19538: PUSH
19539: LD_INT 10
19541: GREATER
19542: AND
19543: IFFALSE 19628
// begin if not GetTag ( tmp [ i ] ) = 5 then
19545: LD_VAR 0 5
19549: PUSH
19550: LD_VAR 0 3
19554: ARRAY
19555: PPUSH
19556: CALL_OW 110
19560: PUSH
19561: LD_INT 5
19563: EQUAL
19564: NOT
19565: IFFALSE 19585
// SetTag ( tmp [ i ] , 5 ) ;
19567: LD_VAR 0 5
19571: PUSH
19572: LD_VAR 0 3
19576: ARRAY
19577: PPUSH
19578: LD_INT 5
19580: PPUSH
19581: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19585: LD_VAR 0 5
19589: PUSH
19590: LD_VAR 0 3
19594: ARRAY
19595: PPUSH
19596: LD_VAR 0 8
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PPUSH
19605: CALL_OW 250
19609: PPUSH
19610: LD_VAR 0 8
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: PPUSH
19619: CALL_OW 251
19623: PPUSH
19624: CALL_OW 111
// end ; for j = 1 to r do
19628: LD_ADDR_VAR 0 4
19632: PUSH
19633: DOUBLE
19634: LD_INT 1
19636: DEC
19637: ST_TO_ADDR
19638: LD_VAR 0 6
19642: PUSH
19643: FOR_TO
19644: IFFALSE 19718
// if GetLives ( tmp [ i ] ) < r [ j ] then
19646: LD_VAR 0 5
19650: PUSH
19651: LD_VAR 0 3
19655: ARRAY
19656: PPUSH
19657: CALL_OW 256
19661: PUSH
19662: LD_VAR 0 6
19666: PUSH
19667: LD_VAR 0 4
19671: ARRAY
19672: LESS
19673: IFFALSE 19716
// begin r := Insert ( r , j , tmp [ i ] ) ;
19675: LD_ADDR_VAR 0 6
19679: PUSH
19680: LD_VAR 0 6
19684: PPUSH
19685: LD_VAR 0 4
19689: PPUSH
19690: LD_VAR 0 5
19694: PUSH
19695: LD_VAR 0 3
19699: ARRAY
19700: PPUSH
19701: CALL_OW 2
19705: ST_TO_ADDR
// m := true ;
19706: LD_ADDR_VAR 0 7
19710: PUSH
19711: LD_INT 1
19713: ST_TO_ADDR
// break ;
19714: GO 19718
// end ;
19716: GO 19643
19718: POP
19719: POP
// if not m then
19720: LD_VAR 0 7
19724: NOT
19725: IFFALSE 19749
// r := r ^ tmp [ i ] ;
19727: LD_ADDR_VAR 0 6
19731: PUSH
19732: LD_VAR 0 6
19736: PUSH
19737: LD_VAR 0 5
19741: PUSH
19742: LD_VAR 0 3
19746: ARRAY
19747: ADD
19748: ST_TO_ADDR
// end ;
19749: GO 19458
19751: POP
19752: POP
// end ; result := r end ; end_of_file
19753: LD_ADDR_VAR 0 2
19757: PUSH
19758: LD_VAR 0 6
19762: ST_TO_ADDR
19763: LD_VAR 0 2
19767: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19768: LD_INT 0
19770: PPUSH
19771: PPUSH
19772: PPUSH
// pom := GetBase ( bdepot ) ;
19773: LD_ADDR_VAR 0 3
19777: PUSH
19778: LD_VAR 0 1
19782: PPUSH
19783: CALL_OW 274
19787: ST_TO_ADDR
// sor := [ ] ;
19788: LD_ADDR_VAR 0 4
19792: PUSH
19793: EMPTY
19794: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_VAR 0 4
19804: PUSH
19805: LD_VAR 0 3
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL_OW 275
19817: ADD
19818: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19819: LD_ADDR_VAR 0 4
19823: PUSH
19824: LD_VAR 0 4
19828: PUSH
19829: LD_VAR 0 3
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 275
19841: ADD
19842: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19843: LD_ADDR_VAR 0 4
19847: PUSH
19848: LD_VAR 0 4
19852: PUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: LD_INT 3
19860: PPUSH
19861: CALL_OW 275
19865: ADD
19866: ST_TO_ADDR
// result := sor ;
19867: LD_ADDR_VAR 0 2
19871: PUSH
19872: LD_VAR 0 4
19876: ST_TO_ADDR
// end ;
19877: LD_VAR 0 2
19881: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19882: LD_INT 0
19884: PPUSH
19885: PPUSH
// while ( coord_list ) do
19886: LD_VAR 0 3
19890: IFFALSE 20064
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19892: LD_ADDR_EXP 48
19896: PUSH
19897: LD_EXP 48
19901: PPUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: LD_VAR 0 2
19911: PPUSH
19912: LD_VAR 0 3
19916: PUSH
19917: LD_INT 1
19919: ARRAY
19920: PUSH
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 2
19928: ARRAY
19929: PUSH
19930: LD_VAR 0 3
19934: PUSH
19935: LD_INT 3
19937: ARRAY
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: PPUSH
19944: CALL 42075 0 4
19948: ST_TO_ADDR
// if weapon_list then
19949: LD_VAR 0 4
19953: IFFALSE 20024
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19955: LD_ADDR_EXP 45
19959: PUSH
19960: LD_EXP 45
19964: PPUSH
19965: LD_VAR 0 1
19969: PPUSH
19970: LD_VAR 0 4
19974: PUSH
19975: LD_INT 1
19977: ARRAY
19978: PPUSH
19979: LD_VAR 0 3
19983: PUSH
19984: LD_INT 1
19986: ARRAY
19987: PUSH
19988: LD_VAR 0 3
19992: PUSH
19993: LD_INT 2
19995: ARRAY
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PPUSH
20001: CALL 42075 0 4
20005: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20006: LD_ADDR_VAR 0 4
20010: PUSH
20011: LD_VAR 0 4
20015: PPUSH
20016: LD_INT 1
20018: PPUSH
20019: CALL_OW 3
20023: ST_TO_ADDR
// end ; for i = 1 to 3 do
20024: LD_ADDR_VAR 0 6
20028: PUSH
20029: DOUBLE
20030: LD_INT 1
20032: DEC
20033: ST_TO_ADDR
20034: LD_INT 3
20036: PUSH
20037: FOR_TO
20038: IFFALSE 20060
// coord_list := Delete ( coord_list , 1 ) ;
20040: LD_ADDR_VAR 0 3
20044: PUSH
20045: LD_VAR 0 3
20049: PPUSH
20050: LD_INT 1
20052: PPUSH
20053: CALL_OW 3
20057: ST_TO_ADDR
20058: GO 20037
20060: POP
20061: POP
// end ;
20062: GO 19886
// result := true ;
20064: LD_ADDR_VAR 0 5
20068: PUSH
20069: LD_INT 1
20071: ST_TO_ADDR
// end ;
20072: LD_VAR 0 5
20076: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20077: LD_INT 0
20079: PPUSH
20080: PPUSH
// if not weapon_list then
20081: LD_VAR 0 3
20085: NOT
20086: IFFALSE 20090
// exit ;
20088: GO 20205
// while ( coord_list ) do
20090: LD_VAR 0 2
20094: IFFALSE 20205
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20096: LD_ADDR_EXP 45
20100: PUSH
20101: LD_EXP 45
20105: PPUSH
20106: LD_VAR 0 1
20110: PPUSH
20111: LD_VAR 0 3
20115: PUSH
20116: LD_INT 1
20118: ARRAY
20119: PPUSH
20120: LD_VAR 0 2
20124: PUSH
20125: LD_INT 1
20127: ARRAY
20128: PUSH
20129: LD_VAR 0 2
20133: PUSH
20134: LD_INT 2
20136: ARRAY
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PPUSH
20142: CALL 42075 0 4
20146: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20147: LD_ADDR_VAR 0 3
20151: PUSH
20152: LD_VAR 0 3
20156: PPUSH
20157: LD_INT 1
20159: PPUSH
20160: CALL_OW 3
20164: ST_TO_ADDR
// for i = 1 to 2 do
20165: LD_ADDR_VAR 0 5
20169: PUSH
20170: DOUBLE
20171: LD_INT 1
20173: DEC
20174: ST_TO_ADDR
20175: LD_INT 2
20177: PUSH
20178: FOR_TO
20179: IFFALSE 20201
// coord_list := Delete ( coord_list , 1 ) ;
20181: LD_ADDR_VAR 0 2
20185: PUSH
20186: LD_VAR 0 2
20190: PPUSH
20191: LD_INT 1
20193: PPUSH
20194: CALL_OW 3
20198: ST_TO_ADDR
20199: GO 20178
20201: POP
20202: POP
// end ;
20203: GO 20090
// end ;
20205: LD_VAR 0 4
20209: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20210: LD_INT 0
20212: PPUSH
20213: PPUSH
// while ( coord_list ) do
20214: LD_VAR 0 2
20218: IFFALSE 20373
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20220: LD_VAR 0 2
20224: PUSH
20225: LD_INT 1
20227: ARRAY
20228: PPUSH
20229: LD_VAR 0 2
20233: PUSH
20234: LD_INT 2
20236: ARRAY
20237: PPUSH
20238: CALL_OW 428
20242: IFFALSE 20333
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20244: LD_VAR 0 2
20248: PUSH
20249: LD_INT 1
20251: ARRAY
20252: PPUSH
20253: LD_VAR 0 2
20257: PUSH
20258: LD_INT 2
20260: ARRAY
20261: PPUSH
20262: CALL_OW 428
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 31
20274: PUSH
20275: LD_INT 32
20277: PUSH
20278: LD_INT 33
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: IN
20286: IFFALSE 20333
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20288: LD_ADDR_EXP 54
20292: PUSH
20293: LD_EXP 54
20297: PPUSH
20298: LD_VAR 0 1
20302: PPUSH
20303: LD_VAR 0 2
20307: PUSH
20308: LD_INT 1
20310: ARRAY
20311: PPUSH
20312: LD_VAR 0 2
20316: PUSH
20317: LD_INT 2
20319: ARRAY
20320: PPUSH
20321: CALL_OW 428
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL 42075 0 4
20332: ST_TO_ADDR
// for i = 1 to 3 do
20333: LD_ADDR_VAR 0 4
20337: PUSH
20338: DOUBLE
20339: LD_INT 1
20341: DEC
20342: ST_TO_ADDR
20343: LD_INT 3
20345: PUSH
20346: FOR_TO
20347: IFFALSE 20369
// coord_list := Delete ( coord_list , 1 ) ;
20349: LD_ADDR_VAR 0 2
20353: PUSH
20354: LD_VAR 0 2
20358: PPUSH
20359: LD_INT 1
20361: PPUSH
20362: CALL_OW 3
20366: ST_TO_ADDR
20367: GO 20346
20369: POP
20370: POP
// end ;
20371: GO 20214
// result := true ;
20373: LD_ADDR_VAR 0 3
20377: PUSH
20378: LD_INT 1
20380: ST_TO_ADDR
// end ;
20381: LD_VAR 0 3
20385: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20386: LD_INT 0
20388: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20389: LD_ADDR_EXP 48
20393: PUSH
20394: LD_EXP 48
20398: PPUSH
20399: LD_VAR 0 1
20403: PPUSH
20404: LD_INT 0
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: CALL 42075 0 4
20416: ST_TO_ADDR
// end ;
20417: LD_VAR 0 3
20421: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20422: LD_INT 0
20424: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20425: LD_ADDR_EXP 48
20429: PUSH
20430: LD_EXP 48
20434: PPUSH
20435: LD_VAR 0 1
20439: PPUSH
20440: LD_INT 6
20442: PPUSH
20443: LD_VAR 0 2
20447: PPUSH
20448: CALL 42075 0 4
20452: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20453: LD_ADDR_EXP 51
20457: PUSH
20458: LD_EXP 51
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_VAR 0 3
20472: PUSH
20473: LD_INT 1
20475: ARRAY
20476: PPUSH
20477: LD_VAR 0 3
20481: PUSH
20482: LD_INT 2
20484: ARRAY
20485: PPUSH
20486: CALL 42075 0 4
20490: ST_TO_ADDR
// end ;
20491: LD_VAR 0 4
20495: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20496: LD_INT 0
20498: PPUSH
20499: PPUSH
// if ext_list > 5 then
20500: LD_VAR 0 3
20504: PUSH
20505: LD_INT 5
20507: GREATER
20508: IFFALSE 20552
// for i = 6 to ext_list do
20510: LD_ADDR_VAR 0 5
20514: PUSH
20515: DOUBLE
20516: LD_INT 6
20518: DEC
20519: ST_TO_ADDR
20520: LD_VAR 0 3
20524: PUSH
20525: FOR_TO
20526: IFFALSE 20550
// ext_list := Delete ( ext_list , ext_list ) ;
20528: LD_ADDR_VAR 0 3
20532: PUSH
20533: LD_VAR 0 3
20537: PPUSH
20538: LD_VAR 0 3
20542: PPUSH
20543: CALL_OW 3
20547: ST_TO_ADDR
20548: GO 20525
20550: POP
20551: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20552: LD_VAR 0 1
20556: PPUSH
20557: LD_VAR 0 2
20561: PUSH
20562: LD_INT 1
20564: ARRAY
20565: PPUSH
20566: LD_VAR 0 2
20570: PUSH
20571: LD_INT 2
20573: ARRAY
20574: PPUSH
20575: LD_VAR 0 2
20579: PUSH
20580: LD_INT 3
20582: ARRAY
20583: PPUSH
20584: LD_VAR 0 3
20588: PPUSH
20589: CALL 9099 0 5
// end ;
20593: LD_VAR 0 4
20597: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20598: LD_INT 0
20600: PPUSH
20601: PPUSH
20602: PPUSH
// p := 1 ;
20603: LD_ADDR_VAR 0 6
20607: PUSH
20608: LD_INT 1
20610: ST_TO_ADDR
// if type_list = [ ] then
20611: LD_VAR 0 3
20615: PUSH
20616: EMPTY
20617: EQUAL
20618: IFFALSE 20628
// type_list := b_oil_power ;
20620: LD_ADDR_VAR 0 3
20624: PUSH
20625: LD_INT 26
20627: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20628: LD_ADDR_VAR 0 5
20632: PUSH
20633: DOUBLE
20634: LD_INT 1
20636: DEC
20637: ST_TO_ADDR
20638: LD_VAR 0 2
20642: PUSH
20643: LD_INT 3
20645: DIVREAL
20646: PUSH
20647: FOR_TO
20648: IFFALSE 20751
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20650: LD_ADDR_EXP 48
20654: PUSH
20655: LD_EXP 48
20659: PPUSH
20660: LD_VAR 0 1
20664: PPUSH
20665: LD_VAR 0 3
20669: PUSH
20670: LD_INT 1
20672: PPUSH
20673: LD_VAR 0 3
20677: PPUSH
20678: CALL_OW 12
20682: ARRAY
20683: PPUSH
20684: LD_VAR 0 2
20688: PUSH
20689: LD_VAR 0 6
20693: ARRAY
20694: PUSH
20695: LD_VAR 0 2
20699: PUSH
20700: LD_VAR 0 6
20704: PUSH
20705: LD_INT 1
20707: PLUS
20708: ARRAY
20709: PUSH
20710: LD_VAR 0 2
20714: PUSH
20715: LD_VAR 0 6
20719: PUSH
20720: LD_INT 2
20722: PLUS
20723: ARRAY
20724: PUSH
20725: EMPTY
20726: LIST
20727: LIST
20728: LIST
20729: PPUSH
20730: CALL 42075 0 4
20734: ST_TO_ADDR
// p := p + 3 ;
20735: LD_ADDR_VAR 0 6
20739: PUSH
20740: LD_VAR 0 6
20744: PUSH
20745: LD_INT 3
20747: PLUS
20748: ST_TO_ADDR
// end ;
20749: GO 20647
20751: POP
20752: POP
// end ;
20753: LD_VAR 0 4
20757: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not MREG_Deposit [ side ] then
20764: LD_EXP 63
20768: PUSH
20769: LD_VAR 0 1
20773: ARRAY
20774: NOT
20775: IFFALSE 20779
// exit ;
20777: GO 20956
// p := 1 ;
20779: LD_ADDR_VAR 0 4
20783: PUSH
20784: LD_INT 1
20786: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: DOUBLE
20793: LD_INT 1
20795: DEC
20796: ST_TO_ADDR
20797: LD_EXP 63
20801: PUSH
20802: LD_VAR 0 1
20806: ARRAY
20807: PUSH
20808: LD_INT 3
20810: DIVREAL
20811: PUSH
20812: FOR_TO
20813: IFFALSE 20954
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20815: LD_EXP 63
20819: PUSH
20820: LD_VAR 0 1
20824: ARRAY
20825: PUSH
20826: LD_VAR 0 4
20830: PUSH
20831: LD_INT 2
20833: PLUS
20834: ARRAY
20835: PUSH
20836: LD_INT 2
20838: EQUAL
20839: IFFALSE 20851
// b := b_oil_mine else
20841: LD_ADDR_VAR 0 5
20845: PUSH
20846: LD_INT 29
20848: ST_TO_ADDR
20849: GO 20859
// b := b_siberite_mine ;
20851: LD_ADDR_VAR 0 5
20855: PUSH
20856: LD_INT 30
20858: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20859: LD_ADDR_EXP 48
20863: PUSH
20864: LD_EXP 48
20868: PPUSH
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_VAR 0 5
20878: PPUSH
20879: LD_EXP 63
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: ARRAY
20895: PUSH
20896: LD_EXP 63
20900: PUSH
20901: LD_VAR 0 1
20905: ARRAY
20906: PUSH
20907: LD_VAR 0 4
20911: PUSH
20912: LD_INT 1
20914: PLUS
20915: ARRAY
20916: PUSH
20917: LD_INT 0
20919: PPUSH
20920: LD_INT 5
20922: PPUSH
20923: CALL_OW 12
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: LIST
20932: PPUSH
20933: CALL 42075 0 4
20937: ST_TO_ADDR
// p := p + 3 ;
20938: LD_ADDR_VAR 0 4
20942: PUSH
20943: LD_VAR 0 4
20947: PUSH
20948: LD_INT 3
20950: PLUS
20951: ST_TO_ADDR
// end ;
20952: GO 20812
20954: POP
20955: POP
// end ;
20956: LD_VAR 0 2
20960: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20961: LD_INT 0
20963: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20964: LD_ADDR_EXP 48
20968: PUSH
20969: LD_EXP 48
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: LD_INT 4
20981: PPUSH
20982: LD_VAR 0 2
20986: PPUSH
20987: CALL 42075 0 4
20991: ST_TO_ADDR
// end ;
20992: LD_VAR 0 3
20996: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20997: LD_INT 0
20999: PPUSH
// case nation of 1 , us :
21000: LD_VAR 0 2
21004: PUSH
21005: LD_INT 1
21007: DOUBLE
21008: EQUAL
21009: IFTRUE 21019
21011: LD_STRING us
21013: DOUBLE
21014: EQUAL
21015: IFTRUE 21019
21017: GO 21050
21019: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21020: LD_ADDR_EXP 48
21024: PUSH
21025: LD_EXP 48
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: LD_INT 36
21037: PPUSH
21038: LD_VAR 0 3
21042: PPUSH
21043: CALL 42075 0 4
21047: ST_TO_ADDR
21048: GO 21101
21050: LD_INT 2
21052: DOUBLE
21053: EQUAL
21054: IFTRUE 21064
21056: LD_STRING ar
21058: DOUBLE
21059: EQUAL
21060: IFTRUE 21064
21062: GO 21100
21064: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21065: LD_ADDR_EXP 48
21069: PUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: LD_INT 14
21077: PUSH
21078: LD_INT 2
21080: PUSH
21081: LD_INT 1
21083: PUSH
21084: LD_INT 31
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: PPUSH
21093: CALL 21106 0 2
21097: ST_TO_ADDR
21098: GO 21101
21100: POP
// end ;
21101: LD_VAR 0 4
21105: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21106: LD_INT 0
21108: PPUSH
21109: PPUSH
// for i = 1 to list do
21110: LD_ADDR_VAR 0 4
21114: PUSH
21115: DOUBLE
21116: LD_INT 1
21118: DEC
21119: ST_TO_ADDR
21120: LD_VAR 0 2
21124: PUSH
21125: FOR_TO
21126: IFFALSE 21176
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21128: LD_ADDR_EXP 53
21132: PUSH
21133: LD_EXP 53
21137: PPUSH
21138: LD_VAR 0 1
21142: PPUSH
21143: LD_EXP 53
21147: PUSH
21148: LD_VAR 0 1
21152: ARRAY
21153: PUSH
21154: LD_INT 1
21156: PLUS
21157: PPUSH
21158: LD_VAR 0 2
21162: PUSH
21163: LD_VAR 0 4
21167: ARRAY
21168: PPUSH
21169: CALL 31125 0 4
21173: ST_TO_ADDR
21174: GO 21125
21176: POP
21177: POP
// end ;
21178: LD_VAR 0 3
21182: RET
// export function MCS_GetVehicleList ( side ) ; begin
21183: LD_INT 0
21185: PPUSH
// result := MREG_ToConstruct [ side ] ;
21186: LD_ADDR_VAR 0 2
21190: PUSH
21191: LD_EXP 53
21195: PUSH
21196: LD_VAR 0 1
21200: ARRAY
21201: ST_TO_ADDR
// end ;
21202: LD_VAR 0 2
21206: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21207: LD_INT 0
21209: PPUSH
21210: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21211: LD_ADDR_EXP 60
21215: PUSH
21216: LD_EXP 60
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: LD_VAR 0 2
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 3
21240: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21241: LD_INT 0
21243: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21244: LD_ADDR_EXP 39
21248: PUSH
21249: LD_EXP 39
21253: PPUSH
21254: LD_VAR 0 1
21258: PPUSH
21259: LD_VAR 0 2
21263: PPUSH
21264: CALL_OW 1
21268: ST_TO_ADDR
// end ;
21269: LD_VAR 0 3
21273: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21274: LD_INT 0
21276: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21277: LD_ADDR_EXP 40
21281: PUSH
21282: LD_EXP 40
21286: PPUSH
21287: LD_VAR 0 1
21291: PPUSH
21292: LD_VAR 0 2
21296: PPUSH
21297: CALL_OW 1
21301: ST_TO_ADDR
// end ;
21302: LD_VAR 0 3
21306: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21307: LD_INT 0
21309: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21310: LD_ADDR_EXP 62
21314: PUSH
21315: LD_EXP 62
21319: PPUSH
21320: LD_VAR 0 1
21324: PPUSH
21325: LD_INT 1
21327: PPUSH
21328: LD_VAR 0 2
21332: PPUSH
21333: CALL 31125 0 4
21337: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21338: LD_ADDR_EXP 62
21342: PUSH
21343: LD_EXP 62
21347: PPUSH
21348: LD_VAR 0 1
21352: PPUSH
21353: LD_INT 2
21355: PPUSH
21356: LD_VAR 0 3
21360: PPUSH
21361: CALL 31125 0 4
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 4
21370: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21374: LD_ADDR_EXP 74
21378: PUSH
21379: LD_EXP 74
21383: PPUSH
21384: LD_INT 1
21386: PPUSH
21387: LD_VAR 0 1
21391: PPUSH
21392: CALL_OW 1
21396: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21397: LD_ADDR_EXP 74
21401: PUSH
21402: LD_EXP 74
21406: PPUSH
21407: LD_INT 2
21409: PPUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: CALL_OW 1
21419: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21420: LD_ADDR_EXP 74
21424: PUSH
21425: LD_EXP 74
21429: PPUSH
21430: LD_INT 3
21432: PPUSH
21433: LD_VAR 0 3
21437: PPUSH
21438: CALL_OW 1
21442: ST_TO_ADDR
// end ;
21443: LD_VAR 0 4
21447: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
// if not side or not list then
21453: LD_VAR 0 1
21457: NOT
21458: PUSH
21459: LD_VAR 0 2
21463: NOT
21464: OR
21465: IFFALSE 21469
// exit ;
21467: GO 21637
// SetTech ( 20 , side , state_researched ) ;
21469: LD_INT 20
21471: PPUSH
21472: LD_VAR 0 1
21476: PPUSH
21477: LD_INT 2
21479: PPUSH
21480: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21484: LD_ADDR_EXP 63
21488: PUSH
21489: LD_EXP 63
21493: PPUSH
21494: LD_VAR 0 1
21498: PPUSH
21499: LD_VAR 0 2
21503: PPUSH
21504: CALL_OW 2
21508: ST_TO_ADDR
// p := 1 ;
21509: LD_ADDR_VAR 0 5
21513: PUSH
21514: LD_INT 1
21516: ST_TO_ADDR
// for i = 1 to list / 3 do
21517: LD_ADDR_VAR 0 4
21521: PUSH
21522: DOUBLE
21523: LD_INT 1
21525: DEC
21526: ST_TO_ADDR
21527: LD_VAR 0 2
21531: PUSH
21532: LD_INT 3
21534: DIVREAL
21535: PUSH
21536: FOR_TO
21537: IFFALSE 21635
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21539: LD_VAR 0 2
21543: PUSH
21544: LD_VAR 0 5
21548: ARRAY
21549: PPUSH
21550: LD_VAR 0 2
21554: PUSH
21555: LD_VAR 0 5
21559: PUSH
21560: LD_INT 1
21562: PLUS
21563: ARRAY
21564: PPUSH
21565: LD_VAR 0 2
21569: PUSH
21570: LD_VAR 0 5
21574: PUSH
21575: LD_INT 2
21577: PLUS
21578: ARRAY
21579: PPUSH
21580: CALL 22339 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21584: LD_VAR 0 2
21588: PUSH
21589: LD_VAR 0 5
21593: ARRAY
21594: PPUSH
21595: LD_VAR 0 2
21599: PUSH
21600: LD_VAR 0 5
21604: PUSH
21605: LD_INT 1
21607: PLUS
21608: ARRAY
21609: PPUSH
21610: LD_VAR 0 1
21614: PPUSH
21615: CALL_OW 441
// p := p + 3 ;
21619: LD_ADDR_VAR 0 5
21623: PUSH
21624: LD_VAR 0 5
21628: PUSH
21629: LD_INT 3
21631: PLUS
21632: ST_TO_ADDR
// end ;
21633: GO 21536
21635: POP
21636: POP
// end ;
21637: LD_VAR 0 3
21641: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21642: LD_INT 0
21644: PPUSH
21645: PPUSH
// if nat = nation_arabian then
21646: LD_VAR 0 2
21650: PUSH
21651: LD_INT 2
21653: EQUAL
21654: IFFALSE 21660
// exit else
21656: GO 21732
21658: GO 21718
// if nat = nation_american then
21660: LD_VAR 0 2
21664: PUSH
21665: LD_INT 1
21667: EQUAL
21668: IFFALSE 21695
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21670: LD_ADDR_VAR 0 4
21674: PUSH
21675: LD_INT 4
21677: PUSH
21678: LD_INT 3
21680: PUSH
21681: LD_INT 1
21683: PUSH
21684: LD_INT 8
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: ST_TO_ADDR
21693: GO 21718
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21695: LD_ADDR_VAR 0 4
21699: PUSH
21700: LD_INT 24
21702: PUSH
21703: LD_INT 3
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: LD_INT 48
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21718: LD_VAR 0 1
21722: PPUSH
21723: LD_VAR 0 4
21727: PPUSH
21728: CALL 21106 0 2
// end ;
21732: LD_VAR 0 3
21736: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21737: LD_INT 0
21739: PPUSH
21740: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21741: LD_ADDR_EXP 65
21745: PUSH
21746: LD_EXP 65
21750: PPUSH
21751: LD_VAR 0 1
21755: PPUSH
21756: LD_INT 1
21758: PPUSH
21759: LD_VAR 0 4
21763: PPUSH
21764: CALL 31125 0 4
21768: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21769: LD_ADDR_EXP 66
21773: PUSH
21774: LD_EXP 66
21778: PPUSH
21779: LD_VAR 0 1
21783: PPUSH
21784: LD_INT 1
21786: PPUSH
21787: LD_VAR 0 2
21791: PPUSH
21792: CALL 31125 0 4
21796: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21797: LD_ADDR_EXP 67
21801: PUSH
21802: LD_EXP 67
21806: PPUSH
21807: LD_VAR 0 1
21811: PPUSH
21812: LD_INT 1
21814: PPUSH
21815: LD_VAR 0 3
21819: PPUSH
21820: CALL 31125 0 4
21824: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21825: LD_ADDR_EXP 68
21829: PUSH
21830: LD_EXP 68
21834: PPUSH
21835: LD_VAR 0 1
21839: PPUSH
21840: LD_INT 1
21842: PPUSH
21843: LD_VAR 0 5
21847: PPUSH
21848: CALL 31125 0 4
21852: ST_TO_ADDR
// while squad do
21853: LD_VAR 0 5
21857: IFFALSE 21950
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_VAR 0 5
21868: PUSH
21869: LD_INT 1
21871: ARRAY
21872: PUSH
21873: LD_VAR 0 5
21877: PUSH
21878: LD_INT 2
21880: ARRAY
21881: PUSH
21882: LD_VAR 0 5
21886: PUSH
21887: LD_INT 3
21889: ARRAY
21890: PUSH
21891: LD_VAR 0 5
21895: PUSH
21896: LD_INT 4
21898: ARRAY
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: LIST
21905: PPUSH
21906: CALL 21106 0 2
// for i = 1 to 4 do
21910: LD_ADDR_VAR 0 7
21914: PUSH
21915: DOUBLE
21916: LD_INT 1
21918: DEC
21919: ST_TO_ADDR
21920: LD_INT 4
21922: PUSH
21923: FOR_TO
21924: IFFALSE 21946
// squad := Delete ( squad , 1 ) ;
21926: LD_ADDR_VAR 0 5
21930: PUSH
21931: LD_VAR 0 5
21935: PPUSH
21936: LD_INT 1
21938: PPUSH
21939: CALL_OW 3
21943: ST_TO_ADDR
21944: GO 21923
21946: POP
21947: POP
// end ;
21948: GO 21853
// end ;
21950: LD_VAR 0 6
21954: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21955: LD_INT 0
21957: PPUSH
21958: PPUSH
// for i = 1 to squad do
21959: LD_ADDR_VAR 0 4
21963: PUSH
21964: DOUBLE
21965: LD_INT 1
21967: DEC
21968: ST_TO_ADDR
21969: LD_VAR 0 2
21973: PUSH
21974: FOR_TO
21975: IFFALSE 22025
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21977: LD_ADDR_EXP 71
21981: PUSH
21982: LD_EXP 71
21986: PPUSH
21987: LD_VAR 0 1
21991: PPUSH
21992: LD_EXP 71
21996: PUSH
21997: LD_VAR 0 1
22001: ARRAY
22002: PUSH
22003: LD_INT 1
22005: PLUS
22006: PPUSH
22007: LD_VAR 0 2
22011: PUSH
22012: LD_VAR 0 4
22016: ARRAY
22017: PPUSH
22018: CALL 31125 0 4
22022: ST_TO_ADDR
22023: GO 21974
22025: POP
22026: POP
// while squad do
22027: LD_VAR 0 2
22031: IFFALSE 22124
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: LD_VAR 0 2
22042: PUSH
22043: LD_INT 1
22045: ARRAY
22046: PUSH
22047: LD_VAR 0 2
22051: PUSH
22052: LD_INT 2
22054: ARRAY
22055: PUSH
22056: LD_VAR 0 2
22060: PUSH
22061: LD_INT 3
22063: ARRAY
22064: PUSH
22065: LD_VAR 0 2
22069: PUSH
22070: LD_INT 4
22072: ARRAY
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: PPUSH
22080: CALL 21106 0 2
// for i = 1 to 4 do
22084: LD_ADDR_VAR 0 4
22088: PUSH
22089: DOUBLE
22090: LD_INT 1
22092: DEC
22093: ST_TO_ADDR
22094: LD_INT 4
22096: PUSH
22097: FOR_TO
22098: IFFALSE 22120
// squad := Delete ( squad , 1 ) ;
22100: LD_ADDR_VAR 0 2
22104: PUSH
22105: LD_VAR 0 2
22109: PPUSH
22110: LD_INT 1
22112: PPUSH
22113: CALL_OW 3
22117: ST_TO_ADDR
22118: GO 22097
22120: POP
22121: POP
// end ;
22122: GO 22027
// end ;
22124: LD_VAR 0 3
22128: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22129: LD_INT 0
22131: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22132: LD_ADDR_EXP 64
22136: PUSH
22137: LD_EXP 64
22141: PPUSH
22142: LD_VAR 0 1
22146: PPUSH
22147: LD_INT 1
22149: PPUSH
22150: LD_VAR 0 2
22154: PPUSH
22155: CALL 31125 0 4
22159: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22160: LD_ADDR_EXP 64
22164: PUSH
22165: LD_EXP 64
22169: PPUSH
22170: LD_VAR 0 1
22174: PPUSH
22175: LD_INT 2
22177: PPUSH
22178: LD_VAR 0 3
22182: PPUSH
22183: CALL 31125 0 4
22187: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22188: LD_ADDR_EXP 64
22192: PUSH
22193: LD_EXP 64
22197: PPUSH
22198: LD_VAR 0 1
22202: PPUSH
22203: LD_INT 3
22205: PPUSH
22206: LD_VAR 0 4
22210: PPUSH
22211: CALL 31125 0 4
22215: ST_TO_ADDR
// end ; end_of_file
22216: LD_VAR 0 5
22220: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22221: LD_INT 0
22223: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22224: LD_ADDR_EXP 44
22228: PUSH
22229: LD_EXP 44
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 1
22241: PPUSH
22242: LD_VAR 0 2
22246: PPUSH
22247: CALL 31125 0 4
22251: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22252: LD_VAR 0 1
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL 11722 0 2
22263: PUSH
22264: LD_INT 1
22266: ARRAY
22267: PPUSH
22268: CALL_OW 248
22272: PUSH
22273: LD_INT 1
22275: EQUAL
22276: IFFALSE 22307
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 4
22285: PUSH
22286: LD_INT 1
22288: PUSH
22289: LD_INT 1
22291: PUSH
22292: LD_INT 14
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: PPUSH
22301: CALL 21106 0 2
22305: GO 22334
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22307: LD_VAR 0 1
22311: PPUSH
22312: LD_INT 24
22314: PUSH
22315: LD_INT 1
22317: PUSH
22318: LD_INT 1
22320: PUSH
22321: LD_INT 53
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL 21106 0 2
// end ;
22334: LD_VAR 0 3
22338: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22339: LD_INT 0
22341: PPUSH
// CreateDepositXY ( x , y , t ) ;
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_VAR 0 2
22351: PPUSH
22352: LD_VAR 0 3
22356: PPUSH
22357: CALL_OW 62
// end ;
22361: LD_VAR 0 4
22365: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22366: LD_INT 0
22368: PPUSH
22369: PPUSH
// c := 1 ;
22370: LD_ADDR_VAR 0 5
22374: PUSH
22375: LD_INT 1
22377: ST_TO_ADDR
// case color of red :
22378: LD_VAR 0 3
22382: PUSH
22383: LD_STRING red
22385: DOUBLE
22386: EQUAL
22387: IFTRUE 22391
22389: GO 22402
22391: POP
// c = 1 ; dark-green :
22392: LD_ADDR_VAR 0 5
22396: PUSH
22397: LD_INT 1
22399: ST_TO_ADDR
22400: GO 22688
22402: LD_STRING dark-green
22404: DOUBLE
22405: EQUAL
22406: IFTRUE 22410
22408: GO 22421
22410: POP
// c = 2 ; purple :
22411: LD_ADDR_VAR 0 5
22415: PUSH
22416: LD_INT 2
22418: ST_TO_ADDR
22419: GO 22688
22421: LD_STRING purple
22423: DOUBLE
22424: EQUAL
22425: IFTRUE 22429
22427: GO 22440
22429: POP
// c = 3 ; aqua :
22430: LD_ADDR_VAR 0 5
22434: PUSH
22435: LD_INT 3
22437: ST_TO_ADDR
22438: GO 22688
22440: LD_STRING aqua
22442: DOUBLE
22443: EQUAL
22444: IFTRUE 22448
22446: GO 22459
22448: POP
// c = 4 ; grey :
22449: LD_ADDR_VAR 0 5
22453: PUSH
22454: LD_INT 4
22456: ST_TO_ADDR
22457: GO 22688
22459: LD_STRING grey
22461: DOUBLE
22462: EQUAL
22463: IFTRUE 22467
22465: GO 22478
22467: POP
// c = 5 ; lime :
22468: LD_ADDR_VAR 0 5
22472: PUSH
22473: LD_INT 5
22475: ST_TO_ADDR
22476: GO 22688
22478: LD_STRING lime
22480: DOUBLE
22481: EQUAL
22482: IFTRUE 22486
22484: GO 22497
22486: POP
// c = 6 ; tan :
22487: LD_ADDR_VAR 0 5
22491: PUSH
22492: LD_INT 6
22494: ST_TO_ADDR
22495: GO 22688
22497: LD_STRING tan
22499: DOUBLE
22500: EQUAL
22501: IFTRUE 22505
22503: GO 22516
22505: POP
// c = 7 ; pink :
22506: LD_ADDR_VAR 0 5
22510: PUSH
22511: LD_INT 7
22513: ST_TO_ADDR
22514: GO 22688
22516: LD_STRING pink
22518: DOUBLE
22519: EQUAL
22520: IFTRUE 22524
22522: GO 22535
22524: POP
// c = 8 ; green :
22525: LD_ADDR_VAR 0 5
22529: PUSH
22530: LD_INT 8
22532: ST_TO_ADDR
22533: GO 22688
22535: LD_STRING green
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22554
22543: POP
// c = 9 ; blue :
22544: LD_ADDR_VAR 0 5
22548: PUSH
22549: LD_INT 9
22551: ST_TO_ADDR
22552: GO 22688
22554: LD_STRING blue
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22573
22562: POP
// c = 10 ; yellow :
22563: LD_ADDR_VAR 0 5
22567: PUSH
22568: LD_INT 10
22570: ST_TO_ADDR
22571: GO 22688
22573: LD_STRING yellow
22575: DOUBLE
22576: EQUAL
22577: IFTRUE 22581
22579: GO 22592
22581: POP
// c = 11 ; brown :
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_INT 11
22589: ST_TO_ADDR
22590: GO 22688
22592: LD_STRING brown
22594: DOUBLE
22595: EQUAL
22596: IFTRUE 22600
22598: GO 22611
22600: POP
// c = 12 ; black :
22601: LD_ADDR_VAR 0 5
22605: PUSH
22606: LD_INT 12
22608: ST_TO_ADDR
22609: GO 22688
22611: LD_STRING black
22613: DOUBLE
22614: EQUAL
22615: IFTRUE 22619
22617: GO 22630
22619: POP
// c = 13 ; aqua2 :
22620: LD_ADDR_VAR 0 5
22624: PUSH
22625: LD_INT 13
22627: ST_TO_ADDR
22628: GO 22688
22630: LD_STRING aqua2
22632: DOUBLE
22633: EQUAL
22634: IFTRUE 22638
22636: GO 22649
22638: POP
// c = 14 ; orange :
22639: LD_ADDR_VAR 0 5
22643: PUSH
22644: LD_INT 14
22646: ST_TO_ADDR
22647: GO 22688
22649: LD_STRING orange
22651: DOUBLE
22652: EQUAL
22653: IFTRUE 22657
22655: GO 22668
22657: POP
// c = 15 ; white :
22658: LD_ADDR_VAR 0 5
22662: PUSH
22663: LD_INT 15
22665: ST_TO_ADDR
22666: GO 22688
22668: LD_STRING white
22670: DOUBLE
22671: EQUAL
22672: IFTRUE 22676
22674: GO 22687
22676: POP
// c = 16 ; end ;
22677: LD_ADDR_VAR 0 5
22681: PUSH
22682: LD_INT 16
22684: ST_TO_ADDR
22685: GO 22688
22687: POP
// if HexInfo ( x , y ) = 0 then
22688: LD_VAR 0 1
22692: PPUSH
22693: LD_VAR 0 2
22697: PPUSH
22698: CALL_OW 428
22702: PUSH
22703: LD_INT 0
22705: EQUAL
22706: IFFALSE 22730
// PlaceEnvironment ( x , y , 58 , c ) ;
22708: LD_VAR 0 1
22712: PPUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: LD_INT 58
22720: PPUSH
22721: LD_VAR 0 5
22725: PPUSH
22726: CALL_OW 349
// end ;
22730: LD_VAR 0 4
22734: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22735: LD_INT 0
22737: PPUSH
// RemoveEnvironment ( x , y ) ;
22738: LD_VAR 0 1
22742: PPUSH
22743: LD_VAR 0 2
22747: PPUSH
22748: CALL_OW 347
// end ;
22752: LD_VAR 0 3
22756: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22757: LD_INT 0
22759: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22760: LD_INT 81
22762: PUSH
22763: LD_VAR 0 1
22767: PUSH
22768: EMPTY
22769: LIST
22770: LIST
22771: PPUSH
22772: CALL_OW 69
22776: PUSH
22777: LD_INT 0
22779: EQUAL
22780: IFFALSE 22792
// result := false else
22782: LD_ADDR_VAR 0 5
22786: PUSH
22787: LD_INT 0
22789: ST_TO_ADDR
22790: GO 22856
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22792: LD_INT 81
22794: PUSH
22795: LD_VAR 0 1
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: PUSH
22804: LD_INT 92
22806: PUSH
22807: LD_VAR 0 2
22811: PUSH
22812: LD_VAR 0 3
22816: PUSH
22817: LD_VAR 0 4
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: LIST
22826: LIST
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: PPUSH
22832: CALL_OW 69
22836: IFFALSE 22848
// result := true else
22838: LD_ADDR_VAR 0 5
22842: PUSH
22843: LD_INT 1
22845: ST_TO_ADDR
22846: GO 22856
// result := false ;
22848: LD_ADDR_VAR 0 5
22852: PUSH
22853: LD_INT 0
22855: ST_TO_ADDR
// end ;
22856: LD_VAR 0 5
22860: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22861: LD_INT 0
22863: PPUSH
22864: PPUSH
22865: PPUSH
22866: PPUSH
22867: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22868: LD_VAR 0 1
22872: PPUSH
22873: LD_INT 81
22875: PUSH
22876: LD_VAR 0 1
22880: PPUSH
22881: CALL_OW 255
22885: PUSH
22886: EMPTY
22887: LIST
22888: LIST
22889: PPUSH
22890: CALL_OW 69
22894: PPUSH
22895: LD_VAR 0 1
22899: PPUSH
22900: CALL_OW 74
22904: PPUSH
22905: CALL_OW 119
// dir := GetDir ( un ) ;
22909: LD_ADDR_VAR 0 4
22913: PUSH
22914: LD_VAR 0 1
22918: PPUSH
22919: CALL_OW 254
22923: ST_TO_ADDR
// dir := dir - 3 ;
22924: LD_ADDR_VAR 0 4
22928: PUSH
22929: LD_VAR 0 4
22933: PUSH
22934: LD_INT 3
22936: MINUS
22937: ST_TO_ADDR
// if dir < 0 then
22938: LD_VAR 0 4
22942: PUSH
22943: LD_INT 0
22945: LESS
22946: IFFALSE 22962
// dir := dir + 6 ;
22948: LD_ADDR_VAR 0 4
22952: PUSH
22953: LD_VAR 0 4
22957: PUSH
22958: LD_INT 6
22960: PLUS
22961: ST_TO_ADDR
// while true do
22962: LD_INT 1
22964: IFFALSE 23461
// begin coord_dist := 3 ;
22966: LD_ADDR_VAR 0 3
22970: PUSH
22971: LD_INT 3
22973: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22974: LD_ADDR_VAR 0 5
22978: PUSH
22979: LD_VAR 0 1
22983: PPUSH
22984: CALL_OW 250
22988: PPUSH
22989: LD_VAR 0 4
22993: PPUSH
22994: LD_VAR 0 3
22998: PPUSH
22999: CALL_OW 272
23003: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23004: LD_ADDR_VAR 0 6
23008: PUSH
23009: LD_VAR 0 1
23013: PPUSH
23014: CALL_OW 251
23018: PPUSH
23019: LD_VAR 0 4
23023: PPUSH
23024: LD_VAR 0 3
23028: PPUSH
23029: CALL_OW 273
23033: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23034: LD_VAR 0 1
23038: PPUSH
23039: CALL_OW 255
23043: PPUSH
23044: LD_VAR 0 1
23048: PPUSH
23049: CALL_OW 250
23053: PPUSH
23054: LD_VAR 0 1
23058: PPUSH
23059: CALL_OW 251
23063: PPUSH
23064: LD_INT 14
23066: PPUSH
23067: CALL 22757 0 4
23071: PUSH
23072: LD_VAR 0 5
23076: PPUSH
23077: LD_VAR 0 6
23081: PPUSH
23082: CALL_OW 351
23086: OR
23087: PUSH
23088: LD_VAR 0 5
23092: PPUSH
23093: LD_VAR 0 6
23097: PPUSH
23098: CALL_OW 488
23102: PUSH
23103: LD_INT 0
23105: EQUAL
23106: OR
23107: PUSH
23108: LD_VAR 0 5
23112: PPUSH
23113: LD_VAR 0 6
23117: PPUSH
23118: CALL_OW 546
23122: PUSH
23123: LD_INT 1
23125: EQUAL
23126: OR
23127: PUSH
23128: LD_VAR 0 5
23132: PPUSH
23133: LD_VAR 0 6
23137: PPUSH
23138: CALL_OW 428
23142: PUSH
23143: LD_INT 0
23145: NONEQUAL
23146: OR
23147: IFFALSE 23375
// begin repeat begin Wait ( 0 0$0.3 ) ;
23149: LD_INT 10
23151: PPUSH
23152: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23156: LD_ADDR_VAR 0 3
23160: PUSH
23161: LD_VAR 0 3
23165: PUSH
23166: LD_INT 1
23168: PLUS
23169: ST_TO_ADDR
// dir := dir + 1 ;
23170: LD_ADDR_VAR 0 4
23174: PUSH
23175: LD_VAR 0 4
23179: PUSH
23180: LD_INT 1
23182: PLUS
23183: ST_TO_ADDR
// if dir > 5 then
23184: LD_VAR 0 4
23188: PUSH
23189: LD_INT 5
23191: GREATER
23192: IFFALSE 23202
// dir = 0 ;
23194: LD_ADDR_VAR 0 4
23198: PUSH
23199: LD_INT 0
23201: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23202: LD_ADDR_VAR 0 5
23206: PUSH
23207: LD_VAR 0 1
23211: PPUSH
23212: CALL_OW 250
23216: PPUSH
23217: LD_VAR 0 4
23221: PPUSH
23222: LD_VAR 0 3
23226: PPUSH
23227: CALL_OW 272
23231: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23232: LD_ADDR_VAR 0 6
23236: PUSH
23237: LD_VAR 0 1
23241: PPUSH
23242: CALL_OW 251
23246: PPUSH
23247: LD_VAR 0 4
23251: PPUSH
23252: LD_VAR 0 3
23256: PPUSH
23257: CALL_OW 273
23261: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23262: LD_VAR 0 1
23266: PPUSH
23267: CALL_OW 255
23271: PPUSH
23272: LD_VAR 0 1
23276: PPUSH
23277: CALL_OW 250
23281: PPUSH
23282: LD_VAR 0 1
23286: PPUSH
23287: CALL_OW 251
23291: PPUSH
23292: LD_INT 14
23294: PPUSH
23295: CALL 22757 0 4
23299: NOT
23300: PUSH
23301: LD_VAR 0 5
23305: PPUSH
23306: LD_VAR 0 6
23310: PPUSH
23311: CALL_OW 351
23315: NOT
23316: AND
23317: PUSH
23318: LD_VAR 0 5
23322: PPUSH
23323: LD_VAR 0 6
23327: PPUSH
23328: CALL_OW 488
23332: AND
23333: PUSH
23334: LD_VAR 0 5
23338: PPUSH
23339: LD_VAR 0 6
23343: PPUSH
23344: CALL_OW 546
23348: PUSH
23349: LD_INT 0
23351: EQUAL
23352: AND
23353: PUSH
23354: LD_VAR 0 5
23358: PPUSH
23359: LD_VAR 0 6
23363: PPUSH
23364: CALL_OW 428
23368: PUSH
23369: LD_INT 0
23371: EQUAL
23372: AND
23373: IFFALSE 23149
// end ; ComMoveXY ( un , x , y ) ;
23375: LD_VAR 0 1
23379: PPUSH
23380: LD_VAR 0 5
23384: PPUSH
23385: LD_VAR 0 6
23389: PPUSH
23390: CALL_OW 111
// Wait ( 0 0$1 ) ;
23394: LD_INT 35
23396: PPUSH
23397: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23401: LD_VAR 0 1
23405: PPUSH
23406: LD_INT 81
23408: PUSH
23409: LD_VAR 0 1
23413: PPUSH
23414: CALL_OW 255
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: PPUSH
23423: CALL_OW 69
23427: PPUSH
23428: LD_VAR 0 1
23432: PPUSH
23433: CALL_OW 74
23437: PPUSH
23438: CALL_OW 296
23442: PUSH
23443: LD_INT 14
23445: GREATEREQUAL
23446: IFFALSE 23459
// begin ComStop ( un ) ;
23448: LD_VAR 0 1
23452: PPUSH
23453: CALL_OW 141
// break ;
23457: GO 23461
// end ; end ;
23459: GO 22962
// end ;
23461: LD_VAR 0 2
23465: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23466: LD_INT 0
23468: PPUSH
23469: PPUSH
23470: PPUSH
23471: PPUSH
23472: PPUSH
23473: PPUSH
23474: PPUSH
23475: PPUSH
// x := GetX ( unit ) ;
23476: LD_ADDR_VAR 0 3
23480: PUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: CALL_OW 250
23490: ST_TO_ADDR
// y := GetY ( unit ) ;
23491: LD_ADDR_VAR 0 4
23495: PUSH
23496: LD_VAR 0 1
23500: PPUSH
23501: CALL_OW 251
23505: ST_TO_ADDR
// i := 0 ;
23506: LD_ADDR_VAR 0 8
23510: PUSH
23511: LD_INT 0
23513: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23514: LD_VAR 0 1
23518: PPUSH
23519: LD_INT 81
23521: PUSH
23522: LD_VAR 0 1
23526: PPUSH
23527: CALL_OW 255
23531: PUSH
23532: EMPTY
23533: LIST
23534: LIST
23535: PPUSH
23536: CALL_OW 69
23540: PPUSH
23541: LD_VAR 0 1
23545: PPUSH
23546: CALL_OW 74
23550: PPUSH
23551: CALL_OW 119
// dir := GetDir ( unit ) ;
23555: LD_ADDR_VAR 0 7
23559: PUSH
23560: LD_VAR 0 1
23564: PPUSH
23565: CALL_OW 254
23569: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23570: LD_ADDR_VAR 0 9
23574: PUSH
23575: LD_INT 0
23577: PPUSH
23578: LD_INT 1
23580: PPUSH
23581: CALL_OW 12
23585: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23586: LD_INT 10
23588: PPUSH
23589: CALL_OW 67
// if mode then
23593: LD_VAR 0 9
23597: IFFALSE 23615
// dir := dir + 1 else
23599: LD_ADDR_VAR 0 7
23603: PUSH
23604: LD_VAR 0 7
23608: PUSH
23609: LD_INT 1
23611: PLUS
23612: ST_TO_ADDR
23613: GO 23629
// dir := dir - 1 ;
23615: LD_ADDR_VAR 0 7
23619: PUSH
23620: LD_VAR 0 7
23624: PUSH
23625: LD_INT 1
23627: MINUS
23628: ST_TO_ADDR
// if ( dir < 0 ) then
23629: LD_VAR 0 7
23633: PUSH
23634: LD_INT 0
23636: LESS
23637: IFFALSE 23647
// dir := 5 ;
23639: LD_ADDR_VAR 0 7
23643: PUSH
23644: LD_INT 5
23646: ST_TO_ADDR
// if ( dir > 5 ) then
23647: LD_VAR 0 7
23651: PUSH
23652: LD_INT 5
23654: GREATER
23655: IFFALSE 23665
// dir := 0 ;
23657: LD_ADDR_VAR 0 7
23661: PUSH
23662: LD_INT 0
23664: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23665: LD_ADDR_VAR 0 5
23669: PUSH
23670: LD_VAR 0 3
23674: PPUSH
23675: LD_VAR 0 7
23679: PPUSH
23680: LD_INT 4
23682: PPUSH
23683: CALL_OW 272
23687: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23688: LD_ADDR_VAR 0 6
23692: PUSH
23693: LD_VAR 0 4
23697: PPUSH
23698: LD_VAR 0 7
23702: PPUSH
23703: LD_INT 4
23705: PPUSH
23706: CALL_OW 273
23710: ST_TO_ADDR
// i := i + 1 ;
23711: LD_ADDR_VAR 0 8
23715: PUSH
23716: LD_VAR 0 8
23720: PUSH
23721: LD_INT 1
23723: PLUS
23724: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23725: LD_VAR 0 1
23729: PPUSH
23730: CALL_OW 255
23734: PPUSH
23735: LD_VAR 0 5
23739: PPUSH
23740: LD_VAR 0 6
23744: PPUSH
23745: LD_INT 14
23747: PPUSH
23748: CALL 22757 0 4
23752: PUSH
23753: LD_INT 0
23755: EQUAL
23756: PUSH
23757: LD_VAR 0 5
23761: PPUSH
23762: LD_VAR 0 6
23766: PPUSH
23767: CALL_OW 546
23771: PUSH
23772: LD_INT 0
23774: EQUAL
23775: AND
23776: PUSH
23777: LD_VAR 0 5
23781: PPUSH
23782: LD_VAR 0 6
23786: PPUSH
23787: CALL_OW 428
23791: PUSH
23792: LD_INT 0
23794: EQUAL
23795: AND
23796: IFFALSE 23800
// break ;
23798: GO 23810
// end until i > 4 ;
23800: LD_VAR 0 8
23804: PUSH
23805: LD_INT 4
23807: GREATER
23808: IFFALSE 23586
// if x2 and y2 then
23810: LD_VAR 0 5
23814: PUSH
23815: LD_VAR 0 6
23819: AND
23820: IFFALSE 23843
// result := [ x2 , y2 ] else
23822: LD_ADDR_VAR 0 2
23826: PUSH
23827: LD_VAR 0 5
23831: PUSH
23832: LD_VAR 0 6
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: ST_TO_ADDR
23841: GO 23872
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23843: LD_ADDR_VAR 0 2
23847: PUSH
23848: LD_VAR 0 1
23852: PPUSH
23853: CALL_OW 250
23857: PUSH
23858: LD_VAR 0 1
23862: PPUSH
23863: CALL_OW 251
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: ST_TO_ADDR
// end ;
23872: LD_VAR 0 2
23876: RET
// export function MCT_Hex ( x , y ) ; begin
23877: LD_INT 0
23879: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23880: LD_ADDR_VAR 0 3
23884: PUSH
23885: LD_VAR 0 1
23889: PPUSH
23890: LD_VAR 0 2
23894: PPUSH
23895: CALL_OW 546
23899: PUSH
23900: LD_VAR 0 1
23904: PPUSH
23905: LD_VAR 0 2
23909: PPUSH
23910: CALL_OW 428
23914: PUSH
23915: EMPTY
23916: LIST
23917: PUSH
23918: EMPTY
23919: LIST
23920: LIST
23921: ST_TO_ADDR
// end ;
23922: LD_VAR 0 3
23926: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23927: LD_INT 0
23929: PPUSH
23930: PPUSH
23931: PPUSH
23932: PPUSH
23933: PPUSH
23934: PPUSH
23935: PPUSH
23936: PPUSH
23937: PPUSH
23938: PPUSH
23939: PPUSH
23940: PPUSH
23941: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23942: LD_ADDR_VAR 0 10
23946: PUSH
23947: LD_EXP 62
23951: PUSH
23952: LD_VAR 0 1
23956: ARRAY
23957: PUSH
23958: LD_INT 1
23960: ARRAY
23961: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23962: LD_ADDR_VAR 0 11
23966: PUSH
23967: LD_EXP 62
23971: PUSH
23972: LD_VAR 0 1
23976: ARRAY
23977: PUSH
23978: LD_INT 2
23980: ARRAY
23981: ST_TO_ADDR
// collectors := [ ] ;
23982: LD_ADDR_VAR 0 12
23986: PUSH
23987: EMPTY
23988: ST_TO_ADDR
// is_cargo := false ;
23989: LD_ADDR_VAR 0 13
23993: PUSH
23994: LD_INT 0
23996: ST_TO_ADDR
// if isTest then
23997: LD_EXP 1
24001: IFFALSE 24007
// TimerStart ( ) ;
24003: CALL_OW 548
// if MCF_Cargo ( side ) then
24007: LD_VAR 0 1
24011: PPUSH
24012: CALL 11938 0 1
24016: IFFALSE 24043
// begin collectors := MCF_Cargo ( side ) ;
24018: LD_ADDR_VAR 0 12
24022: PUSH
24023: LD_VAR 0 1
24027: PPUSH
24028: CALL 11938 0 1
24032: ST_TO_ADDR
// is_cargo := true ;
24033: LD_ADDR_VAR 0 13
24037: PUSH
24038: LD_INT 1
24040: ST_TO_ADDR
// end else
24041: GO 24192
// begin if MCF_ApeSpec ( side , engineer ) then
24043: LD_VAR 0 1
24047: PPUSH
24048: LD_STRING engineer
24050: PPUSH
24051: CALL 12084 0 2
24055: IFFALSE 24075
// collectors := MCF_ApeSpec ( side , engineer ) ;
24057: LD_ADDR_VAR 0 12
24061: PUSH
24062: LD_VAR 0 1
24066: PPUSH
24067: LD_STRING engineer
24069: PPUSH
24070: CALL 12084 0 2
24074: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24075: LD_VAR 0 1
24079: PPUSH
24080: LD_INT 2
24082: PPUSH
24083: EMPTY
24084: PPUSH
24085: CALL 11670 0 3
24089: IFFALSE 24192
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24091: LD_ADDR_VAR 0 7
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_INT 2
24103: PPUSH
24104: EMPTY
24105: PPUSH
24106: CALL 11670 0 3
24110: ST_TO_ADDR
// if z > 5 then
24111: LD_VAR 0 7
24115: PUSH
24116: LD_INT 5
24118: GREATER
24119: IFFALSE 24131
// t1 := 5 else
24121: LD_ADDR_VAR 0 8
24125: PUSH
24126: LD_INT 5
24128: ST_TO_ADDR
24129: GO 24141
// t1 := z ;
24131: LD_ADDR_VAR 0 8
24135: PUSH
24136: LD_VAR 0 7
24140: ST_TO_ADDR
// for t2 = 1 to t1 do
24141: LD_ADDR_VAR 0 9
24145: PUSH
24146: DOUBLE
24147: LD_INT 1
24149: DEC
24150: ST_TO_ADDR
24151: LD_VAR 0 8
24155: PUSH
24156: FOR_TO
24157: IFFALSE 24190
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24159: LD_ADDR_VAR 0 12
24163: PUSH
24164: LD_VAR 0 12
24168: PPUSH
24169: LD_INT 1
24171: PPUSH
24172: LD_VAR 0 7
24176: PUSH
24177: LD_VAR 0 9
24181: ARRAY
24182: PPUSH
24183: CALL_OW 2
24187: ST_TO_ADDR
24188: GO 24156
24190: POP
24191: POP
// end ; end ; if not mode then
24192: LD_VAR 0 10
24196: NOT
24197: IFFALSE 24203
// exit else
24199: GO 24462
24201: GO 24462
// begin if collectors then
24203: LD_VAR 0 12
24207: IFFALSE 24462
// for i in areas do
24209: LD_ADDR_VAR 0 3
24213: PUSH
24214: LD_VAR 0 11
24218: PUSH
24219: FOR_IN
24220: IFFALSE 24460
// if GetListOfCratesInArea ( i ) then
24222: LD_VAR 0 3
24226: PPUSH
24227: CALL_OW 435
24231: IFFALSE 24458
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24233: LD_ADDR_VAR 0 5
24237: PUSH
24238: LD_VAR 0 3
24242: PPUSH
24243: CALL_OW 435
24247: PUSH
24248: LD_INT 1
24250: ARRAY
24251: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24252: LD_ADDR_VAR 0 6
24256: PUSH
24257: LD_VAR 0 3
24261: PPUSH
24262: CALL_OW 435
24266: PUSH
24267: LD_INT 2
24269: ARRAY
24270: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24271: LD_VAR 0 13
24275: PUSH
24276: LD_VAR 0 12
24280: PUSH
24281: LD_INT 1
24283: ARRAY
24284: PPUSH
24285: CALL_OW 110
24289: PUSH
24290: LD_INT 0
24292: EQUAL
24293: AND
24294: IFFALSE 24356
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24296: LD_VAR 0 12
24300: PUSH
24301: LD_INT 1
24303: ARRAY
24304: PPUSH
24305: CALL_OW 314
24309: NOT
24310: PUSH
24311: LD_VAR 0 12
24315: PUSH
24316: LD_INT 1
24318: ARRAY
24319: PPUSH
24320: CALL_OW 110
24324: PUSH
24325: LD_INT 0
24327: EQUAL
24328: AND
24329: IFFALSE 24354
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24331: LD_VAR 0 12
24335: PUSH
24336: LD_INT 1
24338: ARRAY
24339: PPUSH
24340: LD_VAR 0 5
24344: PPUSH
24345: LD_VAR 0 6
24349: PPUSH
24350: CALL_OW 117
// end ; end else
24354: GO 24442
// begin for j = 1 to collectors do
24356: LD_ADDR_VAR 0 4
24360: PUSH
24361: DOUBLE
24362: LD_INT 1
24364: DEC
24365: ST_TO_ADDR
24366: LD_VAR 0 12
24370: PUSH
24371: FOR_TO
24372: IFFALSE 24440
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24374: LD_VAR 0 12
24378: PUSH
24379: LD_VAR 0 4
24383: ARRAY
24384: PPUSH
24385: CALL_OW 314
24389: NOT
24390: PUSH
24391: LD_VAR 0 12
24395: PUSH
24396: LD_VAR 0 4
24400: ARRAY
24401: PPUSH
24402: CALL_OW 110
24406: PUSH
24407: LD_INT 0
24409: EQUAL
24410: AND
24411: IFFALSE 24438
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24413: LD_VAR 0 12
24417: PUSH
24418: LD_VAR 0 4
24422: ARRAY
24423: PPUSH
24424: LD_VAR 0 5
24428: PPUSH
24429: LD_VAR 0 6
24433: PPUSH
24434: CALL 24833 0 3
// end ;
24438: GO 24371
24440: POP
24441: POP
// end ; if isTest then
24442: LD_EXP 1
24446: IFFALSE 24458
// begin debug_time := TimerEnd ( ) ;
24448: LD_ADDR_VAR 0 14
24452: PUSH
24453: CALL_OW 549
24457: ST_TO_ADDR
// end ; end ;
24458: GO 24219
24460: POP
24461: POP
// end ; end ;
24462: LD_VAR 0 2
24466: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24467: LD_INT 0
24469: PPUSH
24470: PPUSH
24471: PPUSH
24472: PPUSH
24473: PPUSH
24474: PPUSH
// if not area then
24475: LD_VAR 0 1
24479: NOT
24480: IFFALSE 24486
// exit else
24482: GO 24748
24484: GO 24748
// if tick mod interval = 0 and Prob ( percent ) then
24486: LD_OWVAR 1
24490: PUSH
24491: LD_VAR 0 4
24495: MOD
24496: PUSH
24497: LD_INT 0
24499: EQUAL
24500: PUSH
24501: LD_VAR 0 3
24505: PPUSH
24506: CALL_OW 13
24510: AND
24511: IFFALSE 24748
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24513: LD_VAR 0 1
24517: PPUSH
24518: CALL_OW 435
24522: PUSH
24523: LD_VAR 0 5
24527: LESS
24528: PUSH
24529: LD_VAR 0 5
24533: PUSH
24534: LD_INT 0
24536: EQUAL
24537: OR
24538: IFFALSE 24748
// begin Randomize ;
24540: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24544: LD_ADDR_VAR 0 7
24548: PUSH
24549: LD_INT 1
24551: PPUSH
24552: LD_VAR 0 2
24556: PPUSH
24557: CALL_OW 12
24561: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24562: LD_ADDR_VAR 0 9
24566: PUSH
24567: LD_VAR 0 1
24571: PPUSH
24572: LD_INT 0
24574: PPUSH
24575: CALL_OW 517
24579: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24580: LD_ADDR_VAR 0 8
24584: PUSH
24585: LD_INT 1
24587: PPUSH
24588: LD_VAR 0 9
24592: PUSH
24593: LD_INT 1
24595: ARRAY
24596: PPUSH
24597: CALL_OW 12
24601: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24602: LD_VAR 0 9
24606: PUSH
24607: LD_INT 1
24609: ARRAY
24610: PUSH
24611: LD_VAR 0 8
24615: ARRAY
24616: PPUSH
24617: LD_VAR 0 9
24621: PUSH
24622: LD_INT 2
24624: ARRAY
24625: PUSH
24626: LD_VAR 0 8
24630: ARRAY
24631: PPUSH
24632: CALL_OW 428
24636: PUSH
24637: LD_INT 0
24639: GREATER
24640: PUSH
24641: LD_VAR 0 9
24645: PUSH
24646: LD_INT 1
24648: ARRAY
24649: PUSH
24650: LD_VAR 0 8
24654: ARRAY
24655: PPUSH
24656: LD_VAR 0 9
24660: PUSH
24661: LD_INT 2
24663: ARRAY
24664: PUSH
24665: LD_VAR 0 8
24669: ARRAY
24670: PPUSH
24671: CALL_OW 284
24675: PUSH
24676: LD_INT 0
24678: GREATER
24679: AND
24680: IFFALSE 24706
// c := Rand ( 1 , tmp [ 1 ] ) ;
24682: LD_ADDR_VAR 0 8
24686: PUSH
24687: LD_INT 1
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 1
24697: ARRAY
24698: PPUSH
24699: CALL_OW 12
24703: ST_TO_ADDR
24704: GO 24602
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24706: LD_VAR 0 7
24710: PPUSH
24711: LD_VAR 0 9
24715: PUSH
24716: LD_INT 1
24718: ARRAY
24719: PUSH
24720: LD_VAR 0 8
24724: ARRAY
24725: PPUSH
24726: LD_VAR 0 9
24730: PUSH
24731: LD_INT 2
24733: ARRAY
24734: PUSH
24735: LD_VAR 0 8
24739: ARRAY
24740: PPUSH
24741: LD_INT 1
24743: PPUSH
24744: CALL_OW 54
// end ; end ; end ;
24748: LD_VAR 0 6
24752: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24753: LD_INT 0
24755: PPUSH
24756: PPUSH
// if not MREG_Crates then
24757: LD_EXP 36
24761: NOT
24762: IFFALSE 24766
// exit ;
24764: GO 24828
// for i = MREG_Crates downto 1 do
24766: LD_ADDR_VAR 0 2
24770: PUSH
24771: DOUBLE
24772: LD_EXP 36
24776: INC
24777: ST_TO_ADDR
24778: LD_INT 1
24780: PUSH
24781: FOR_DOWNTO
24782: IFFALSE 24826
// if MREG_Crates [ i ] [ 3 ] = 0 then
24784: LD_EXP 36
24788: PUSH
24789: LD_VAR 0 2
24793: ARRAY
24794: PUSH
24795: LD_INT 3
24797: ARRAY
24798: PUSH
24799: LD_INT 0
24801: EQUAL
24802: IFFALSE 24824
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24804: LD_ADDR_EXP 36
24808: PUSH
24809: LD_EXP 36
24813: PPUSH
24814: LD_VAR 0 2
24818: PPUSH
24819: CALL_OW 3
24823: ST_TO_ADDR
24824: GO 24781
24826: POP
24827: POP
// end ;
24828: LD_VAR 0 1
24832: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24833: LD_INT 0
24835: PPUSH
24836: PPUSH
24837: PPUSH
24838: PPUSH
// if not unit then
24839: LD_VAR 0 1
24843: NOT
24844: IFFALSE 24848
// exit ;
24846: GO 24983
// if HasTask ( unit ) or not CanCarry ( unit ) then
24848: LD_VAR 0 1
24852: PPUSH
24853: CALL_OW 314
24857: PUSH
24858: LD_VAR 0 1
24862: PPUSH
24863: CALL_OW 280
24867: NOT
24868: OR
24869: IFFALSE 24873
// exit ;
24871: GO 24983
// side := GetSide ( unit ) ;
24873: LD_ADDR_VAR 0 6
24877: PUSH
24878: LD_VAR 0 1
24882: PPUSH
24883: CALL_OW 255
24887: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24888: LD_ADDR_VAR 0 7
24892: PUSH
24893: LD_VAR 0 6
24897: PPUSH
24898: LD_INT 30
24900: PUSH
24901: LD_INT 1
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: PPUSH
24908: CALL 11587 0 2
24912: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24913: LD_VAR 0 1
24917: PPUSH
24918: CALL_OW 281
24922: PUSH
24923: LD_VAR 0 7
24927: NOT
24928: OR
24929: IFFALSE 24935
// exit else
24931: GO 24983
24933: GO 24983
// if GetResourceAmountXY ( x , y ) then
24935: LD_VAR 0 2
24939: PPUSH
24940: LD_VAR 0 3
24944: PPUSH
24945: CALL_OW 284
24949: IFFALSE 24981
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24951: LD_VAR 0 1
24955: PPUSH
24956: LD_VAR 0 2
24960: PPUSH
24961: LD_VAR 0 3
24965: PPUSH
24966: LD_VAR 0 7
24970: PUSH
24971: LD_INT 1
24973: ARRAY
24974: PPUSH
24975: CALL 32056 0 4
// end else
24979: GO 24983
// exit ;
24981: GO 24983
// end ;
24983: LD_VAR 0 4
24987: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24988: LD_INT 0
24990: PPUSH
24991: PPUSH
24992: PPUSH
24993: PPUSH
24994: PPUSH
// result := 0 ;
24995: LD_ADDR_VAR 0 2
24999: PUSH
25000: LD_INT 0
25002: ST_TO_ADDR
// p := 1 ;
25003: LD_ADDR_VAR 0 4
25007: PUSH
25008: LD_INT 1
25010: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25011: LD_ADDR_VAR 0 3
25015: PUSH
25016: DOUBLE
25017: LD_INT 1
25019: DEC
25020: ST_TO_ADDR
25021: LD_EXP 65
25025: PUSH
25026: LD_VAR 0 1
25030: ARRAY
25031: PUSH
25032: LD_INT 1
25034: ARRAY
25035: PUSH
25036: LD_INT 2
25038: DIVREAL
25039: PUSH
25040: FOR_TO
25041: IFFALSE 25165
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25043: LD_ADDR_VAR 0 5
25047: PUSH
25048: LD_INT 81
25050: PUSH
25051: LD_VAR 0 1
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: PUSH
25060: LD_INT 92
25062: PUSH
25063: LD_EXP 65
25067: PUSH
25068: LD_VAR 0 1
25072: ARRAY
25073: PUSH
25074: LD_INT 1
25076: ARRAY
25077: PUSH
25078: LD_VAR 0 4
25082: ARRAY
25083: PUSH
25084: LD_EXP 65
25088: PUSH
25089: LD_VAR 0 1
25093: ARRAY
25094: PUSH
25095: LD_INT 1
25097: ARRAY
25098: PUSH
25099: LD_VAR 0 4
25103: PUSH
25104: LD_INT 1
25106: PLUS
25107: ARRAY
25108: PUSH
25109: LD_INT 12
25111: PUSH
25112: EMPTY
25113: LIST
25114: LIST
25115: LIST
25116: LIST
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PPUSH
25122: CALL_OW 69
25126: ST_TO_ADDR
// if tmp then
25127: LD_VAR 0 5
25131: IFFALSE 25149
// result := result ^ tmp ;
25133: LD_ADDR_VAR 0 2
25137: PUSH
25138: LD_VAR 0 2
25142: PUSH
25143: LD_VAR 0 5
25147: ADD
25148: ST_TO_ADDR
// p := p + 2 ;
25149: LD_ADDR_VAR 0 4
25153: PUSH
25154: LD_VAR 0 4
25158: PUSH
25159: LD_INT 2
25161: PLUS
25162: ST_TO_ADDR
// end ;
25163: GO 25040
25165: POP
25166: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25167: LD_EXP 66
25171: PUSH
25172: LD_VAR 0 1
25176: ARRAY
25177: PPUSH
25178: LD_INT 81
25180: PUSH
25181: LD_VAR 0 1
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PPUSH
25190: CALL_OW 70
25194: IFFALSE 25235
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25196: LD_ADDR_VAR 0 2
25200: PUSH
25201: LD_VAR 0 2
25205: PUSH
25206: LD_EXP 66
25210: PUSH
25211: LD_VAR 0 1
25215: ARRAY
25216: PPUSH
25217: LD_INT 81
25219: PUSH
25220: LD_VAR 0 1
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: PPUSH
25229: CALL_OW 70
25233: ADD
25234: ST_TO_ADDR
// end ; end_of_file
25235: LD_VAR 0 2
25239: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25240: LD_INT 0
25242: PPUSH
25243: PPUSH
25244: PPUSH
// pom := GetBase ( fac ) ;
25245: LD_ADDR_VAR 0 5
25249: PUSH
25250: LD_VAR 0 1
25254: PPUSH
25255: CALL_OW 274
25259: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25260: LD_ADDR_VAR 0 4
25264: PUSH
25265: LD_VAR 0 2
25269: PUSH
25270: LD_INT 1
25272: ARRAY
25273: PPUSH
25274: LD_VAR 0 2
25278: PUSH
25279: LD_INT 2
25281: ARRAY
25282: PPUSH
25283: LD_VAR 0 2
25287: PUSH
25288: LD_INT 3
25290: ARRAY
25291: PPUSH
25292: LD_VAR 0 2
25296: PUSH
25297: LD_INT 4
25299: ARRAY
25300: PPUSH
25301: CALL_OW 449
25305: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25306: LD_VAR 0 5
25310: PPUSH
25311: LD_INT 1
25313: PPUSH
25314: CALL_OW 275
25318: PUSH
25319: LD_VAR 0 4
25323: PUSH
25324: LD_INT 1
25326: ARRAY
25327: GREATEREQUAL
25328: PUSH
25329: LD_VAR 0 5
25333: PPUSH
25334: LD_INT 2
25336: PPUSH
25337: CALL_OW 275
25341: PUSH
25342: LD_VAR 0 4
25346: PUSH
25347: LD_INT 2
25349: ARRAY
25350: GREATEREQUAL
25351: AND
25352: PUSH
25353: LD_VAR 0 5
25357: PPUSH
25358: LD_INT 3
25360: PPUSH
25361: CALL_OW 275
25365: PUSH
25366: LD_VAR 0 4
25370: PUSH
25371: LD_INT 3
25373: ARRAY
25374: GREATEREQUAL
25375: AND
25376: IFFALSE 25388
// result := true else
25378: LD_ADDR_VAR 0 3
25382: PUSH
25383: LD_INT 1
25385: ST_TO_ADDR
25386: GO 25396
// result := false ;
25388: LD_ADDR_VAR 0 3
25392: PUSH
25393: LD_INT 0
25395: ST_TO_ADDR
// end ;
25396: LD_VAR 0 3
25400: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25401: LD_INT 0
25403: PPUSH
25404: PPUSH
25405: PPUSH
// result := false ;
25406: LD_ADDR_VAR 0 3
25410: PUSH
25411: LD_INT 0
25413: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25414: LD_ADDR_VAR 0 4
25418: PUSH
25419: LD_EXP 53
25423: PUSH
25424: LD_VAR 0 1
25428: ARRAY
25429: ST_TO_ADDR
// if tmp then
25430: LD_VAR 0 4
25434: IFFALSE 25486
// for i = 1 to tmp do
25436: LD_ADDR_VAR 0 5
25440: PUSH
25441: DOUBLE
25442: LD_INT 1
25444: DEC
25445: ST_TO_ADDR
25446: LD_VAR 0 4
25450: PUSH
25451: FOR_TO
25452: IFFALSE 25484
// if component = tmp [ i ] then
25454: LD_VAR 0 2
25458: PUSH
25459: LD_VAR 0 4
25463: PUSH
25464: LD_VAR 0 5
25468: ARRAY
25469: EQUAL
25470: IFFALSE 25482
// begin result := true ;
25472: LD_ADDR_VAR 0 3
25476: PUSH
25477: LD_INT 1
25479: ST_TO_ADDR
// break ;
25480: GO 25484
// end ;
25482: GO 25451
25484: POP
25485: POP
// end ;
25486: LD_VAR 0 3
25490: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25491: LD_INT 0
25493: PPUSH
25494: PPUSH
25495: PPUSH
// if fac then
25496: LD_VAR 0 2
25500: IFFALSE 25735
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25502: LD_VAR 0 2
25506: PPUSH
25507: LD_VAR 0 3
25511: PPUSH
25512: CALL 25240 0 2
25516: PUSH
25517: LD_VAR 0 2
25521: PPUSH
25522: CALL_OW 461
25526: PUSH
25527: LD_INT 2
25529: EQUAL
25530: AND
25531: PUSH
25532: LD_VAR 0 2
25536: PPUSH
25537: LD_VAR 0 3
25541: PUSH
25542: LD_INT 1
25544: ARRAY
25545: PPUSH
25546: LD_VAR 0 3
25550: PUSH
25551: LD_INT 2
25553: ARRAY
25554: PPUSH
25555: LD_VAR 0 3
25559: PUSH
25560: LD_INT 3
25562: ARRAY
25563: PPUSH
25564: LD_VAR 0 3
25568: PUSH
25569: LD_INT 4
25571: ARRAY
25572: PPUSH
25573: CALL_OW 448
25577: AND
25578: IFFALSE 25725
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25580: LD_VAR 0 2
25584: PPUSH
25585: LD_VAR 0 3
25589: PUSH
25590: LD_INT 1
25592: ARRAY
25593: PPUSH
25594: LD_VAR 0 3
25598: PUSH
25599: LD_INT 2
25601: ARRAY
25602: PPUSH
25603: LD_VAR 0 3
25607: PUSH
25608: LD_INT 3
25610: ARRAY
25611: PPUSH
25612: LD_VAR 0 3
25616: PUSH
25617: LD_INT 4
25619: ARRAY
25620: PPUSH
25621: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25625: LD_ADDR_VAR 0 6
25629: PUSH
25630: LD_EXP 53
25634: PUSH
25635: LD_VAR 0 1
25639: ARRAY
25640: ST_TO_ADDR
// for i = 4 downto 1 do
25641: LD_ADDR_VAR 0 5
25645: PUSH
25646: DOUBLE
25647: LD_INT 4
25649: INC
25650: ST_TO_ADDR
25651: LD_INT 1
25653: PUSH
25654: FOR_DOWNTO
25655: IFFALSE 25688
// tab := Remove ( tab , list [ i ] , true ) ;
25657: LD_ADDR_VAR 0 6
25661: PUSH
25662: LD_VAR 0 6
25666: PPUSH
25667: LD_VAR 0 3
25671: PUSH
25672: LD_VAR 0 5
25676: ARRAY
25677: PPUSH
25678: LD_INT 1
25680: PPUSH
25681: CALL 31284 0 3
25685: ST_TO_ADDR
25686: GO 25654
25688: POP
25689: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25690: LD_ADDR_EXP 53
25694: PUSH
25695: LD_EXP 53
25699: PPUSH
25700: LD_VAR 0 1
25704: PPUSH
25705: LD_VAR 0 6
25709: PPUSH
25710: CALL_OW 1
25714: ST_TO_ADDR
// result := true ;
25715: LD_ADDR_VAR 0 4
25719: PUSH
25720: LD_INT 1
25722: ST_TO_ADDR
// end else
25723: GO 25733
// result := false ;
25725: LD_ADDR_VAR 0 4
25729: PUSH
25730: LD_INT 0
25732: ST_TO_ADDR
// end else
25733: GO 25743
// result := false ;
25735: LD_ADDR_VAR 0 4
25739: PUSH
25740: LD_INT 0
25742: ST_TO_ADDR
// end ;
25743: LD_VAR 0 4
25747: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25748: LD_INT 0
25750: PPUSH
25751: PPUSH
// if not veh then
25752: LD_VAR 0 2
25756: NOT
25757: IFFALSE 25761
// exit ;
25759: GO 25935
// if MREG_Parking [ side ] then
25761: LD_EXP 60
25765: PUSH
25766: LD_VAR 0 1
25770: ARRAY
25771: IFFALSE 25935
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25773: LD_VAR 0 2
25777: PPUSH
25778: LD_EXP 60
25782: PUSH
25783: LD_VAR 0 1
25787: ARRAY
25788: PPUSH
25789: CALL_OW 308
25793: NOT
25794: IFFALSE 25935
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25796: LD_VAR 0 2
25800: PPUSH
25801: LD_EXP 60
25805: PUSH
25806: LD_VAR 0 1
25810: ARRAY
25811: PPUSH
25812: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25816: LD_VAR 0 2
25820: PPUSH
25821: CALL_OW 263
25825: PUSH
25826: LD_INT 1
25828: EQUAL
25829: IFFALSE 25935
// begin i := GetDriver ( veh ) ;
25831: LD_ADDR_VAR 0 4
25835: PUSH
25836: LD_VAR 0 2
25840: PPUSH
25841: CALL 31768 0 1
25845: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25846: LD_INT 35
25848: PPUSH
25849: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25853: LD_VAR 0 2
25857: PPUSH
25858: LD_EXP 60
25862: PUSH
25863: LD_VAR 0 1
25867: ARRAY
25868: PPUSH
25869: CALL_OW 308
25873: PUSH
25874: LD_VAR 0 2
25878: PPUSH
25879: CALL_OW 301
25883: OR
25884: IFFALSE 25846
// ComExitVehicle ( i ) ;
25886: LD_VAR 0 4
25890: PPUSH
25891: CALL_OW 121
// Wait ( 1 ) ;
25895: LD_INT 1
25897: PPUSH
25898: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25902: LD_VAR 0 4
25906: PPUSH
25907: LD_VAR 0 1
25911: PPUSH
25912: LD_INT 30
25914: PUSH
25915: LD_INT 3
25917: PUSH
25918: EMPTY
25919: LIST
25920: LIST
25921: PPUSH
25922: CALL 11587 0 2
25926: PUSH
25927: LD_INT 1
25929: ARRAY
25930: PPUSH
25931: CALL_OW 180
// end ; end ; end ;
25935: LD_VAR 0 3
25939: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25940: LD_INT 0
25942: PPUSH
25943: PPUSH
25944: PPUSH
25945: PPUSH
25946: PPUSH
25947: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25948: LD_VAR 0 1
25952: PPUSH
25953: LD_INT 30
25955: PUSH
25956: LD_INT 3
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PPUSH
25963: CALL 11587 0 2
25967: IFFALSE 26151
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25969: LD_VAR 0 1
25973: PPUSH
25974: LD_INT 30
25976: PUSH
25977: LD_INT 3
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PPUSH
25984: CALL 11587 0 2
25988: PUSH
25989: LD_INT 1
25991: ARRAY
25992: PPUSH
25993: CALL_OW 461
25997: PUSH
25998: LD_INT 2
26000: EQUAL
26001: IFFALSE 26151
// begin for i = 1 to MREG_TurretWeapon do
26003: LD_ADDR_VAR 0 3
26007: PUSH
26008: DOUBLE
26009: LD_INT 1
26011: DEC
26012: ST_TO_ADDR
26013: LD_EXP 45
26017: PUSH
26018: FOR_TO
26019: IFFALSE 26149
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26021: LD_EXP 45
26025: PUSH
26026: LD_VAR 0 3
26030: ARRAY
26031: PUSH
26032: LD_INT 1
26034: ARRAY
26035: PUSH
26036: LD_VAR 0 1
26040: EQUAL
26041: IFFALSE 26147
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26043: LD_ADDR_VAR 0 5
26047: PUSH
26048: LD_EXP 45
26052: PUSH
26053: LD_VAR 0 3
26057: ARRAY
26058: PUSH
26059: LD_INT 2
26061: ARRAY
26062: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26063: LD_ADDR_VAR 0 6
26067: PUSH
26068: LD_EXP 45
26072: PUSH
26073: LD_VAR 0 3
26077: ARRAY
26078: PUSH
26079: LD_INT 3
26081: ARRAY
26082: PUSH
26083: LD_INT 1
26085: ARRAY
26086: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26087: LD_ADDR_VAR 0 7
26091: PUSH
26092: LD_EXP 45
26096: PUSH
26097: LD_VAR 0 3
26101: ARRAY
26102: PUSH
26103: LD_INT 3
26105: ARRAY
26106: PUSH
26107: LD_INT 2
26109: ARRAY
26110: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26111: LD_ADDR_VAR 0 4
26115: PUSH
26116: LD_VAR 0 6
26120: PPUSH
26121: LD_VAR 0 7
26125: PPUSH
26126: CALL_OW 428
26130: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26131: LD_VAR 0 4
26135: PPUSH
26136: LD_VAR 0 5
26140: PPUSH
26141: CALL_OW 148
// break ;
26145: GO 26149
// end ;
26147: GO 26018
26149: POP
26150: POP
// end ; end ;
26151: LD_VAR 0 2
26155: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26156: LD_INT 0
26158: PPUSH
26159: PPUSH
26160: PPUSH
26161: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26162: LD_ADDR_VAR 0 4
26166: PUSH
26167: LD_VAR 0 1
26171: PPUSH
26172: LD_INT 32
26174: PUSH
26175: LD_INT 1
26177: PUSH
26178: EMPTY
26179: LIST
26180: LIST
26181: PPUSH
26182: CALL 11587 0 2
26186: ST_TO_ADDR
// if not tmp then
26187: LD_VAR 0 4
26191: NOT
26192: IFFALSE 26198
// exit else
26194: GO 26280
26196: GO 26280
// begin for i = 1 to tmp do
26198: LD_ADDR_VAR 0 3
26202: PUSH
26203: DOUBLE
26204: LD_INT 1
26206: DEC
26207: ST_TO_ADDR
26208: LD_VAR 0 4
26212: PUSH
26213: FOR_TO
26214: IFFALSE 26278
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26216: LD_VAR 0 4
26220: PUSH
26221: LD_VAR 0 3
26225: ARRAY
26226: PPUSH
26227: CALL_OW 261
26231: PUSH
26232: LD_INT 20
26234: LESS
26235: PUSH
26236: LD_VAR 0 4
26240: PUSH
26241: LD_VAR 0 3
26245: ARRAY
26246: PPUSH
26247: CALL_OW 110
26251: PUSH
26252: LD_INT 0
26254: EQUAL
26255: AND
26256: IFFALSE 26276
// begin SetTag ( tmp [ i ] , 21 ) ;
26258: LD_VAR 0 4
26262: PUSH
26263: LD_VAR 0 3
26267: ARRAY
26268: PPUSH
26269: LD_INT 21
26271: PPUSH
26272: CALL_OW 109
// end ;
26276: GO 26213
26278: POP
26279: POP
// end ; end ;
26280: LD_VAR 0 2
26284: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26285: LD_INT 0
26287: PPUSH
26288: PPUSH
26289: PPUSH
26290: PPUSH
26291: PPUSH
// if not unit then
26292: LD_VAR 0 1
26296: NOT
26297: IFFALSE 26301
// exit ;
26299: GO 26489
// side := GetSide ( unit ) ;
26301: LD_ADDR_VAR 0 3
26305: PUSH
26306: LD_VAR 0 1
26310: PPUSH
26311: CALL_OW 255
26315: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26316: LD_ADDR_VAR 0 5
26320: PUSH
26321: LD_VAR 0 3
26325: PPUSH
26326: LD_INT 2
26328: PUSH
26329: LD_INT 30
26331: PUSH
26332: LD_INT 1
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 30
26341: PUSH
26342: LD_INT 3
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: PUSH
26349: LD_INT 30
26351: PUSH
26352: LD_INT 29
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PUSH
26359: EMPTY
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: PPUSH
26365: CALL 11587 0 2
26369: ST_TO_ADDR
// if not b then
26370: LD_VAR 0 5
26374: NOT
26375: IFFALSE 26379
// exit ;
26377: GO 26489
// if GetTag ( unit ) = 21 then
26379: LD_VAR 0 1
26383: PPUSH
26384: CALL_OW 110
26388: PUSH
26389: LD_INT 21
26391: EQUAL
26392: IFFALSE 26489
// begin c := NearestUnitToUnit ( b , unit ) ;
26394: LD_ADDR_VAR 0 6
26398: PUSH
26399: LD_VAR 0 5
26403: PPUSH
26404: LD_VAR 0 1
26408: PPUSH
26409: CALL_OW 74
26413: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26414: LD_VAR 0 1
26418: PPUSH
26419: LD_VAR 0 6
26423: PPUSH
26424: CALL_OW 250
26428: PPUSH
26429: LD_VAR 0 6
26433: PPUSH
26434: CALL_OW 251
26438: PPUSH
26439: CALL_OW 297
26443: PUSH
26444: LD_INT 6
26446: GREATER
26447: IFFALSE 26465
// ComMoveUnit ( unit , c ) else
26449: LD_VAR 0 1
26453: PPUSH
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 112
26463: GO 26489
// begin SetFuel ( unit , 100 ) ;
26465: LD_VAR 0 1
26469: PPUSH
26470: LD_INT 100
26472: PPUSH
26473: CALL_OW 240
// SetTag ( unit , 0 ) ;
26477: LD_VAR 0 1
26481: PPUSH
26482: LD_INT 0
26484: PPUSH
26485: CALL_OW 109
// end ; end ; end ;
26489: LD_VAR 0 2
26493: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26494: LD_INT 0
26496: PPUSH
26497: PPUSH
26498: PPUSH
26499: PPUSH
26500: PPUSH
26501: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26502: LD_ADDR_VAR 0 7
26506: PUSH
26507: LD_VAR 0 1
26511: PPUSH
26512: LD_INT 33
26514: PUSH
26515: LD_INT 2
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: LD_INT 3
26524: PUSH
26525: LD_INT 61
26527: PUSH
26528: EMPTY
26529: LIST
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PPUSH
26539: CALL 11587 0 2
26543: ST_TO_ADDR
// if not vehs then
26544: LD_VAR 0 7
26548: NOT
26549: IFFALSE 26553
// exit ;
26551: GO 26838
// if nation = 1 then
26553: LD_VAR 0 2
26557: PUSH
26558: LD_INT 1
26560: EQUAL
26561: IFFALSE 26731
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26563: LD_VAR 0 1
26567: PPUSH
26568: LD_INT 30
26570: PUSH
26571: LD_INT 36
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PPUSH
26578: CALL 11587 0 2
26582: NOT
26583: IFFALSE 26589
// exit else
26585: GO 26838
26587: GO 26729
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26589: LD_ADDR_VAR 0 5
26593: PUSH
26594: LD_VAR 0 1
26598: PPUSH
26599: LD_INT 30
26601: PUSH
26602: LD_INT 36
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PPUSH
26609: CALL 11587 0 2
26613: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26614: LD_ADDR_VAR 0 6
26618: PUSH
26619: LD_VAR 0 5
26623: PUSH
26624: LD_INT 1
26626: ARRAY
26627: PPUSH
26628: CALL_OW 313
26632: ST_TO_ADDR
// for i = vehs downto 1 do
26633: LD_ADDR_VAR 0 4
26637: PUSH
26638: DOUBLE
26639: LD_VAR 0 7
26643: INC
26644: ST_TO_ADDR
26645: LD_INT 1
26647: PUSH
26648: FOR_DOWNTO
26649: IFFALSE 26727
// begin if not IsControledBy ( vehs [ i ] ) then
26651: LD_VAR 0 7
26655: PUSH
26656: LD_VAR 0 4
26660: ARRAY
26661: PPUSH
26662: CALL_OW 312
26666: NOT
26667: IFFALSE 26725
// begin tmp := MCV_RemoteDriver ( oper ) ;
26669: LD_ADDR_VAR 0 8
26673: PUSH
26674: LD_VAR 0 6
26678: PPUSH
26679: CALL 26843 0 1
26683: ST_TO_ADDR
// if not tmp then
26684: LD_VAR 0 8
26688: NOT
26689: IFFALSE 26697
// exit else
26691: POP
26692: POP
26693: GO 26838
26695: GO 26725
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26697: LD_VAR 0 7
26701: PUSH
26702: LD_VAR 0 4
26706: ARRAY
26707: PPUSH
26708: LD_VAR 0 8
26712: PUSH
26713: LD_INT 1
26715: ARRAY
26716: PUSH
26717: LD_INT 1
26719: ARRAY
26720: PPUSH
26721: CALL_OW 135
// end ; end ;
26725: GO 26648
26727: POP
26728: POP
// end ; end else
26729: GO 26838
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26731: LD_VAR 0 1
26735: PPUSH
26736: LD_INT 34
26738: PUSH
26739: LD_INT 31
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PPUSH
26746: CALL 11587 0 2
26750: NOT
26751: IFFALSE 26757
// exit else
26753: GO 26838
26755: GO 26838
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26757: LD_ADDR_VAR 0 5
26761: PUSH
26762: LD_VAR 0 1
26766: PPUSH
26767: LD_INT 34
26769: PUSH
26770: LD_INT 31
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: PPUSH
26777: CALL 11587 0 2
26781: ST_TO_ADDR
// oper := [ ] ;
26782: LD_ADDR_VAR 0 6
26786: PUSH
26787: EMPTY
26788: ST_TO_ADDR
// for i = 1 to ct do
26789: LD_ADDR_VAR 0 4
26793: PUSH
26794: DOUBLE
26795: LD_INT 1
26797: DEC
26798: ST_TO_ADDR
26799: LD_VAR 0 5
26803: PUSH
26804: FOR_TO
26805: IFFALSE 26836
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26807: LD_ADDR_VAR 0 6
26811: PUSH
26812: LD_VAR 0 6
26816: PUSH
26817: LD_VAR 0 5
26821: PUSH
26822: LD_VAR 0 4
26826: ARRAY
26827: PPUSH
26828: CALL 31768 0 1
26832: ADD
26833: ST_TO_ADDR
26834: GO 26804
26836: POP
26837: POP
// end ; end ; end ;
26838: LD_VAR 0 3
26842: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26843: LD_INT 0
26845: PPUSH
26846: PPUSH
26847: PPUSH
26848: PPUSH
26849: PPUSH
26850: PPUSH
// if not drivers then
26851: LD_VAR 0 1
26855: NOT
26856: IFFALSE 26862
// exit else
26858: GO 27142
26860: GO 27142
// begin linked := [ ] ;
26862: LD_ADDR_VAR 0 5
26866: PUSH
26867: EMPTY
26868: ST_TO_ADDR
// for i = 1 to drivers do
26869: LD_ADDR_VAR 0 3
26873: PUSH
26874: DOUBLE
26875: LD_INT 1
26877: DEC
26878: ST_TO_ADDR
26879: LD_VAR 0 1
26883: PUSH
26884: FOR_TO
26885: IFFALSE 27130
// begin if CanControl ( drivers [ i ] ) then
26887: LD_VAR 0 1
26891: PUSH
26892: LD_VAR 0 3
26896: ARRAY
26897: PPUSH
26898: CALL 32158 0 1
26902: IFFALSE 27128
// if i > 1 then
26904: LD_VAR 0 3
26908: PUSH
26909: LD_INT 1
26911: GREATER
26912: IFFALSE 27089
// begin m := false ;
26914: LD_ADDR_VAR 0 6
26918: PUSH
26919: LD_INT 0
26921: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26922: LD_ADDR_VAR 0 7
26926: PUSH
26927: LD_VAR 0 1
26931: PUSH
26932: LD_VAR 0 3
26936: ARRAY
26937: PPUSH
26938: CALL_OW 432
26942: ST_TO_ADDR
// for j = 1 to linked do
26943: LD_ADDR_VAR 0 4
26947: PUSH
26948: DOUBLE
26949: LD_INT 1
26951: DEC
26952: ST_TO_ADDR
26953: LD_VAR 0 5
26957: PUSH
26958: FOR_TO
26959: IFFALSE 27033
// begin if l < linked [ j ] [ 2 ] then
26961: LD_VAR 0 7
26965: PUSH
26966: LD_VAR 0 5
26970: PUSH
26971: LD_VAR 0 4
26975: ARRAY
26976: PUSH
26977: LD_INT 2
26979: ARRAY
26980: LESS
26981: IFFALSE 27031
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26983: LD_ADDR_VAR 0 5
26987: PUSH
26988: LD_VAR 0 5
26992: PPUSH
26993: LD_INT 1
26995: PPUSH
26996: LD_VAR 0 1
27000: PUSH
27001: LD_VAR 0 3
27005: ARRAY
27006: PUSH
27007: LD_VAR 0 7
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: PPUSH
27016: CALL_OW 2
27020: ST_TO_ADDR
// m := true ;
27021: LD_ADDR_VAR 0 6
27025: PUSH
27026: LD_INT 1
27028: ST_TO_ADDR
// break ;
27029: GO 27033
// end ; end ;
27031: GO 26958
27033: POP
27034: POP
// if not m then
27035: LD_VAR 0 6
27039: NOT
27040: IFFALSE 27087
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27042: LD_ADDR_VAR 0 5
27046: PUSH
27047: LD_VAR 0 5
27051: PUSH
27052: LD_VAR 0 1
27056: PUSH
27057: LD_VAR 0 3
27061: ARRAY
27062: PUSH
27063: LD_VAR 0 1
27067: PUSH
27068: LD_VAR 0 3
27072: ARRAY
27073: PPUSH
27074: CALL_OW 432
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: EMPTY
27084: LIST
27085: ADD
27086: ST_TO_ADDR
// end else
27087: GO 27128
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27089: LD_ADDR_VAR 0 5
27093: PUSH
27094: LD_VAR 0 1
27098: PUSH
27099: LD_VAR 0 3
27103: ARRAY
27104: PUSH
27105: LD_VAR 0 1
27109: PUSH
27110: LD_VAR 0 3
27114: ARRAY
27115: PPUSH
27116: CALL_OW 432
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: EMPTY
27126: LIST
27127: ST_TO_ADDR
// end ;
27128: GO 26884
27130: POP
27131: POP
// result := linked ;
27132: LD_ADDR_VAR 0 2
27136: PUSH
27137: LD_VAR 0 5
27141: ST_TO_ADDR
// end ; end ;
27142: LD_VAR 0 2
27146: RET
// export function MCV_ToRepair ( unit ) ; begin
27147: LD_INT 0
27149: PPUSH
// if not unit then
27150: LD_VAR 0 1
27154: NOT
27155: IFFALSE 27161
// exit else
27157: GO 27192
27159: GO 27192
// begin SetTag ( unit , 6 ) ;
27161: LD_VAR 0 1
27165: PPUSH
27166: LD_INT 6
27168: PPUSH
27169: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27173: LD_VAR 0 1
27177: PPUSH
27178: CALL_OW 255
27182: PPUSH
27183: LD_VAR 0 1
27187: PPUSH
27188: CALL 25748 0 2
// end ; end ;
27192: LD_VAR 0 2
27196: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27197: LD_INT 0
27199: PPUSH
27200: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27201: LD_VAR 0 1
27205: PPUSH
27206: LD_INT 6
27208: PPUSH
27209: EMPTY
27210: PPUSH
27211: CALL 12290 0 3
27215: IFFALSE 27308
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27217: LD_ADDR_VAR 0 3
27221: PUSH
27222: DOUBLE
27223: LD_VAR 0 1
27227: PPUSH
27228: LD_INT 6
27230: PPUSH
27231: EMPTY
27232: PPUSH
27233: CALL 12290 0 3
27237: INC
27238: ST_TO_ADDR
27239: LD_INT 1
27241: PUSH
27242: FOR_DOWNTO
27243: IFFALSE 27306
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27245: LD_VAR 0 1
27249: PPUSH
27250: LD_INT 6
27252: PPUSH
27253: EMPTY
27254: PPUSH
27255: CALL 12290 0 3
27259: PUSH
27260: LD_VAR 0 3
27264: ARRAY
27265: PPUSH
27266: CALL_OW 256
27270: PUSH
27271: LD_INT 1000
27273: EQUAL
27274: IFFALSE 27304
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27276: LD_VAR 0 1
27280: PPUSH
27281: LD_INT 6
27283: PPUSH
27284: EMPTY
27285: PPUSH
27286: CALL 12290 0 3
27290: PUSH
27291: LD_VAR 0 3
27295: ARRAY
27296: PPUSH
27297: LD_INT 0
27299: PPUSH
27300: CALL_OW 109
27304: GO 27242
27306: POP
27307: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27308: LD_VAR 0 1
27312: PPUSH
27313: LD_INT 10
27315: PPUSH
27316: EMPTY
27317: PPUSH
27318: CALL 12290 0 3
27322: IFFALSE 27439
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27324: LD_ADDR_VAR 0 3
27328: PUSH
27329: DOUBLE
27330: LD_VAR 0 1
27334: PPUSH
27335: LD_INT 10
27337: PPUSH
27338: EMPTY
27339: PPUSH
27340: CALL 12290 0 3
27344: INC
27345: ST_TO_ADDR
27346: LD_INT 1
27348: PUSH
27349: FOR_DOWNTO
27350: IFFALSE 27437
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27352: LD_VAR 0 1
27356: PPUSH
27357: LD_INT 10
27359: PPUSH
27360: EMPTY
27361: PPUSH
27362: CALL 12290 0 3
27366: PUSH
27367: LD_VAR 0 3
27371: ARRAY
27372: PPUSH
27373: CALL_OW 302
27377: NOT
27378: PUSH
27379: LD_VAR 0 1
27383: PPUSH
27384: LD_INT 10
27386: PPUSH
27387: EMPTY
27388: PPUSH
27389: CALL 12290 0 3
27393: PUSH
27394: LD_VAR 0 3
27398: ARRAY
27399: PPUSH
27400: CALL_OW 301
27404: OR
27405: IFFALSE 27435
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27407: LD_VAR 0 1
27411: PPUSH
27412: LD_INT 10
27414: PPUSH
27415: EMPTY
27416: PPUSH
27417: CALL 12290 0 3
27421: PUSH
27422: LD_VAR 0 3
27426: ARRAY
27427: PPUSH
27428: LD_INT 0
27430: PPUSH
27431: CALL_OW 109
27435: GO 27349
27437: POP
27438: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27439: LD_ADDR_VAR 0 3
27443: PUSH
27444: LD_VAR 0 1
27448: PPUSH
27449: EMPTY
27450: PPUSH
27451: CALL 11888 0 2
27455: PUSH
27456: LD_VAR 0 1
27460: PPUSH
27461: LD_INT 7
27463: PPUSH
27464: EMPTY
27465: PPUSH
27466: CALL 12290 0 3
27470: DIFF
27471: PUSH
27472: FOR_IN
27473: IFFALSE 27517
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27475: LD_VAR 0 3
27479: PPUSH
27480: CALL_OW 256
27484: PUSH
27485: LD_INT 650
27487: LESS
27488: PUSH
27489: LD_VAR 0 3
27493: PPUSH
27494: CALL_OW 110
27498: PUSH
27499: LD_INT 6
27501: EQUAL
27502: NOT
27503: AND
27504: IFFALSE 27515
// MCV_ToRepair ( i ) ;
27506: LD_VAR 0 3
27510: PPUSH
27511: CALL 27147 0 1
27515: GO 27472
27517: POP
27518: POP
// end ; end_of_file end_of_file
27519: LD_VAR 0 2
27523: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27524: LD_STRING SAILEvent [
27526: PUSH
27527: LD_VAR 0 1
27531: STR
27532: PUSH
27533: LD_STRING ]
27535: STR
27536: PPUSH
27537: CALL 7984 0 1
// if event = 101 and dialog_north then
27541: LD_VAR 0 1
27545: PUSH
27546: LD_INT 101
27548: EQUAL
27549: PUSH
27550: LD_EXP 6
27554: AND
27555: IFFALSE 27619
// begin dialog_north := false ;
27557: LD_ADDR_EXP 6
27561: PUSH
27562: LD_INT 0
27564: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27565: LD_EXP 5
27569: PPUSH
27570: LD_STRING DS1
27572: PUSH
27573: LD_STRING DS2
27575: PUSH
27576: LD_STRING DS3
27578: PUSH
27579: LD_STRING DS6
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: PUSH
27588: LD_INT 1
27590: PPUSH
27591: LD_INT 4
27593: PPUSH
27594: CALL_OW 12
27598: ARRAY
27599: PPUSH
27600: CALL_OW 94
// Wait ( 4 4$00 ) ;
27604: LD_INT 8400
27606: PPUSH
27607: CALL_OW 67
// dialog_north := true ;
27611: LD_ADDR_EXP 6
27615: PUSH
27616: LD_INT 1
27618: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27619: LD_VAR 0 1
27623: PUSH
27624: LD_INT 102
27626: EQUAL
27627: PUSH
27628: LD_EXP 7
27632: AND
27633: IFFALSE 27693
// begin dialog_south := false ;
27635: LD_ADDR_EXP 7
27639: PUSH
27640: LD_INT 0
27642: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27643: LD_EXP 4
27647: PPUSH
27648: LD_STRING DJ1
27650: PUSH
27651: LD_STRING DJ4
27653: PUSH
27654: LD_STRING DJ6
27656: PUSH
27657: EMPTY
27658: LIST
27659: LIST
27660: LIST
27661: PUSH
27662: LD_INT 1
27664: PPUSH
27665: LD_INT 3
27667: PPUSH
27668: CALL_OW 12
27672: ARRAY
27673: PPUSH
27674: CALL_OW 94
// Wait ( 4 4$00 ) ;
27678: LD_INT 8400
27680: PPUSH
27681: CALL_OW 67
// dialog_south := true ;
27685: LD_ADDR_EXP 7
27689: PUSH
27690: LD_INT 1
27692: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27693: LD_VAR 0 1
27697: PUSH
27698: LD_INT 104
27700: EQUAL
27701: PUSH
27702: LD_EXP 8
27706: AND
27707: IFFALSE 27729
// begin dialog_popov := false ;
27709: LD_ADDR_EXP 8
27713: PUSH
27714: LD_INT 0
27716: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27717: LD_EXP 26
27721: PPUSH
27722: LD_STRING DR4
27724: PPUSH
27725: CALL_OW 94
// end ; end ;
27729: PPOPN 1
27731: END
// on BuildingStarted ( b , unit ) do var side , i ;
27732: LD_INT 0
27734: PPUSH
27735: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27736: LD_EXP 41
27740: PUSH
27741: LD_VAR 0 1
27745: PPUSH
27746: CALL_OW 255
27750: ARRAY
27751: IFFALSE 27929
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27753: LD_STRING BuildingStarted [side: 
27755: PUSH
27756: LD_VAR 0 1
27760: PPUSH
27761: CALL_OW 255
27765: STR
27766: PUSH
27767: LD_STRING ; btype: 
27769: STR
27770: PUSH
27771: LD_VAR 0 1
27775: PPUSH
27776: CALL_OW 266
27780: STR
27781: PUSH
27782: LD_STRING ; unit: 
27784: STR
27785: PUSH
27786: LD_VAR 0 2
27790: STR
27791: PUSH
27792: LD_STRING ]
27794: STR
27795: PPUSH
27796: CALL 7984 0 1
// side := GetSide ( b ) ;
27800: LD_ADDR_VAR 0 3
27804: PUSH
27805: LD_VAR 0 1
27809: PPUSH
27810: CALL_OW 255
27814: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27815: LD_VAR 0 3
27819: PPUSH
27820: LD_INT 21
27822: PUSH
27823: LD_INT 3
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PPUSH
27830: CALL 11587 0 2
27834: PUSH
27835: LD_INT 1
27837: EQUAL
27838: IFFALSE 27929
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27840: LD_ADDR_VAR 0 4
27844: PUSH
27845: LD_VAR 0 3
27849: PPUSH
27850: LD_INT 21
27852: PUSH
27853: LD_INT 1
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PPUSH
27860: CALL 11587 0 2
27864: PUSH
27865: LD_VAR 0 3
27869: PPUSH
27870: LD_INT 2
27872: PPUSH
27873: EMPTY
27874: PPUSH
27875: CALL 11670 0 3
27879: DIFF
27880: PUSH
27881: FOR_IN
27882: IFFALSE 27927
// if not HasTask ( i ) then
27884: LD_VAR 0 4
27888: PPUSH
27889: CALL_OW 314
27893: NOT
27894: IFFALSE 27925
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27896: LD_VAR 0 4
27900: PPUSH
27901: LD_VAR 0 1
27905: PPUSH
27906: CALL_OW 250
27910: PPUSH
27911: LD_VAR 0 1
27915: PPUSH
27916: CALL_OW 251
27920: PPUSH
27921: CALL_OW 111
27925: GO 27881
27927: POP
27928: POP
// end ;
27929: PPOPN 4
27931: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27932: LD_EXP 41
27936: PUSH
27937: LD_VAR 0 1
27941: PPUSH
27942: CALL_OW 255
27946: ARRAY
27947: IFFALSE 28316
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27949: LD_STRING BuildingComplete [side: 
27951: PUSH
27952: LD_VAR 0 1
27956: PPUSH
27957: CALL_OW 255
27961: STR
27962: PUSH
27963: LD_STRING ; btype: 
27965: STR
27966: PUSH
27967: LD_VAR 0 1
27971: PPUSH
27972: CALL_OW 266
27976: STR
27977: PUSH
27978: LD_STRING ]
27980: STR
27981: PPUSH
27982: CALL 7984 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27986: LD_ADDR_EXP 48
27990: PUSH
27991: LD_EXP 48
27995: PPUSH
27996: LD_VAR 0 1
28000: PPUSH
28001: CALL_OW 255
28005: PPUSH
28006: LD_VAR 0 1
28010: PPUSH
28011: CALL_OW 266
28015: PPUSH
28016: LD_VAR 0 1
28020: PPUSH
28021: CALL_OW 250
28025: PUSH
28026: LD_VAR 0 1
28030: PPUSH
28031: CALL_OW 251
28035: PUSH
28036: LD_VAR 0 1
28040: PPUSH
28041: CALL_OW 254
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: LIST
28050: PPUSH
28051: CALL 42166 0 4
28055: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28056: LD_VAR 0 1
28060: PPUSH
28061: CALL_OW 266
28065: PUSH
28066: LD_INT 6
28068: EQUAL
28069: IFFALSE 28103
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28071: LD_ADDR_EXP 42
28075: PUSH
28076: LD_EXP 42
28080: PPUSH
28081: LD_VAR 0 1
28085: PPUSH
28086: CALL_OW 255
28090: PPUSH
28091: LD_VAR 0 1
28095: PPUSH
28096: EMPTY
28097: PPUSH
28098: CALL 42075 0 4
28102: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28103: LD_VAR 0 1
28107: PPUSH
28108: CALL_OW 266
28112: PUSH
28113: LD_INT 0
28115: EQUAL
28116: IFFALSE 28226
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28118: LD_ADDR_EXP 50
28122: PUSH
28123: LD_EXP 50
28127: PPUSH
28128: LD_VAR 0 1
28132: PPUSH
28133: CALL_OW 255
28137: PPUSH
28138: LD_INT 0
28140: PPUSH
28141: EMPTY
28142: PPUSH
28143: CALL 42075 0 4
28147: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28148: LD_VAR 0 1
28152: PPUSH
28153: CALL_OW 274
28157: PPUSH
28158: LD_INT 1
28160: PPUSH
28161: LD_EXP 74
28165: PUSH
28166: LD_INT 1
28168: ARRAY
28169: PPUSH
28170: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28174: LD_VAR 0 1
28178: PPUSH
28179: CALL_OW 274
28183: PPUSH
28184: LD_INT 2
28186: PPUSH
28187: LD_EXP 74
28191: PUSH
28192: LD_INT 2
28194: ARRAY
28195: PPUSH
28196: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28200: LD_VAR 0 1
28204: PPUSH
28205: CALL_OW 274
28209: PPUSH
28210: LD_INT 3
28212: PPUSH
28213: LD_EXP 74
28217: PUSH
28218: LD_INT 3
28220: ARRAY
28221: PPUSH
28222: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28226: LD_VAR 0 1
28230: PPUSH
28231: CALL_OW 266
28235: PUSH
28236: LD_INT 2
28238: EQUAL
28239: IFFALSE 28271
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28241: LD_ADDR_EXP 50
28245: PUSH
28246: LD_EXP 50
28250: PPUSH
28251: LD_VAR 0 1
28255: PPUSH
28256: CALL_OW 255
28260: PPUSH
28261: LD_INT 2
28263: PPUSH
28264: EMPTY
28265: PPUSH
28266: CALL 42075 0 4
28270: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28271: LD_VAR 0 1
28275: PPUSH
28276: CALL_OW 266
28280: PUSH
28281: LD_INT 4
28283: EQUAL
28284: IFFALSE 28316
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28286: LD_ADDR_EXP 50
28290: PUSH
28291: LD_EXP 50
28295: PPUSH
28296: LD_VAR 0 1
28300: PPUSH
28301: CALL_OW 255
28305: PPUSH
28306: LD_INT 4
28308: PPUSH
28309: EMPTY
28310: PPUSH
28311: CALL 42075 0 4
28315: ST_TO_ADDR
// end ;
28316: PPOPN 1
28318: END
// on ResearchComplete ( tech , lab ) do var i ;
28319: LD_INT 0
28321: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28322: LD_EXP 41
28326: PUSH
28327: LD_VAR 0 2
28331: PPUSH
28332: CALL_OW 255
28336: ARRAY
28337: IFFALSE 28621
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28339: LD_STRING ResearchComplete [side: 
28341: PUSH
28342: LD_VAR 0 2
28346: PPUSH
28347: CALL_OW 255
28351: PPUSH
28352: CALL_OW 255
28356: STR
28357: PUSH
28358: LD_STRING ; tech:
28360: STR
28361: PUSH
28362: LD_VAR 0 1
28366: STR
28367: PUSH
28368: LD_STRING ]
28370: STR
28371: PPUSH
28372: CALL 7984 0 1
// for i = 1 to MREG_ToRes do
28376: LD_ADDR_VAR 0 3
28380: PUSH
28381: DOUBLE
28382: LD_INT 1
28384: DEC
28385: ST_TO_ADDR
28386: LD_EXP 52
28390: PUSH
28391: FOR_TO
28392: IFFALSE 28479
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28394: LD_EXP 52
28398: PUSH
28399: LD_VAR 0 3
28403: ARRAY
28404: PUSH
28405: LD_INT 1
28407: ARRAY
28408: PUSH
28409: LD_VAR 0 2
28413: PPUSH
28414: CALL_OW 255
28418: EQUAL
28419: PUSH
28420: LD_EXP 52
28424: PUSH
28425: LD_VAR 0 3
28429: ARRAY
28430: PUSH
28431: LD_INT 2
28433: ARRAY
28434: PUSH
28435: LD_VAR 0 1
28439: EQUAL
28440: AND
28441: IFFALSE 28477
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28443: LD_ADDR_EXP 52
28447: PUSH
28448: LD_EXP 52
28452: PPUSH
28453: LD_VAR 0 2
28457: PPUSH
28458: CALL_OW 255
28462: PPUSH
28463: LD_VAR 0 1
28467: PPUSH
28468: EMPTY
28469: PPUSH
28470: CALL 42166 0 4
28474: ST_TO_ADDR
// break ;
28475: GO 28479
// end ;
28477: GO 28391
28479: POP
28480: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28481: LD_VAR 0 1
28485: PUSH
28486: LD_INT 2
28488: PUSH
28489: LD_INT 11
28491: PUSH
28492: LD_INT 4
28494: PUSH
28495: LD_INT 3
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: LIST
28502: LIST
28503: IN
28504: IFFALSE 28621
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28506: LD_ADDR_VAR 0 3
28510: PUSH
28511: LD_VAR 0 2
28515: PPUSH
28516: CALL_OW 255
28520: PPUSH
28521: LD_INT 16
28523: PPUSH
28524: LD_INT 25
28526: PUSH
28527: LD_INT 4
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PPUSH
28534: CALL 12290 0 3
28538: ST_TO_ADDR
// if i then
28539: LD_VAR 0 3
28543: IFFALSE 28561
// SetTag ( i [ 1 ] , 0 ) ;
28545: LD_VAR 0 3
28549: PUSH
28550: LD_INT 1
28552: ARRAY
28553: PPUSH
28554: LD_INT 0
28556: PPUSH
28557: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28561: LD_ADDR_VAR 0 3
28565: PUSH
28566: LD_VAR 0 2
28570: PPUSH
28571: CALL_OW 255
28575: PPUSH
28576: LD_INT 171
28578: PPUSH
28579: EMPTY
28580: PPUSH
28581: CALL 12290 0 3
28585: ST_TO_ADDR
// if i then
28586: LD_VAR 0 3
28590: IFFALSE 28621
// begin SetTag ( i [ 1 ] , 0 ) ;
28592: LD_VAR 0 3
28596: PUSH
28597: LD_INT 1
28599: ARRAY
28600: PPUSH
28601: LD_INT 0
28603: PPUSH
28604: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28608: LD_VAR 0 3
28612: PUSH
28613: LD_INT 1
28615: ARRAY
28616: PPUSH
28617: CALL_OW 122
// end ; end ; end ;
28621: PPOPN 3
28623: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28624: LD_INT 0
28626: PPUSH
28627: PPUSH
28628: PPUSH
28629: PPUSH
28630: PPUSH
28631: PPUSH
28632: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28633: LD_EXP 41
28637: PUSH
28638: LD_VAR 0 2
28642: PPUSH
28643: CALL_OW 255
28647: ARRAY
28648: IFFALSE 29375
// begin side := GetSide ( veh ) ;
28650: LD_ADDR_VAR 0 4
28654: PUSH
28655: LD_VAR 0 1
28659: PPUSH
28660: CALL_OW 255
28664: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28665: LD_ADDR_VAR 0 6
28669: PUSH
28670: LD_VAR 0 1
28674: PPUSH
28675: CALL_OW 265
28679: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28680: LD_ADDR_VAR 0 7
28684: PUSH
28685: LD_VAR 0 1
28689: PPUSH
28690: CALL_OW 262
28694: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28695: LD_ADDR_VAR 0 8
28699: PUSH
28700: LD_VAR 0 1
28704: PPUSH
28705: CALL_OW 263
28709: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28710: LD_ADDR_VAR 0 9
28714: PUSH
28715: LD_VAR 0 1
28719: PPUSH
28720: CALL_OW 264
28724: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28725: LD_STRING VehicleConstructed [side: 
28727: PUSH
28728: LD_VAR 0 4
28732: STR
28733: PUSH
28734: LD_STRING ; id:
28736: STR
28737: PUSH
28738: LD_VAR 0 1
28742: STR
28743: PUSH
28744: LD_STRING ; components: [
28746: STR
28747: PUSH
28748: LD_VAR 0 6
28752: STR
28753: PUSH
28754: LD_STRING , 
28756: STR
28757: PUSH
28758: LD_VAR 0 7
28762: STR
28763: PUSH
28764: LD_STRING , 
28766: STR
28767: PUSH
28768: LD_VAR 0 8
28772: STR
28773: PUSH
28774: LD_STRING , 
28776: STR
28777: PUSH
28778: LD_VAR 0 9
28782: STR
28783: PUSH
28784: LD_STRING ]]
28786: STR
28787: PPUSH
28788: CALL 7984 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28792: LD_VAR 0 1
28796: PPUSH
28797: CALL_OW 264
28801: PUSH
28802: LD_INT 13
28804: PUSH
28805: LD_INT 12
28807: PUSH
28808: LD_INT 14
28810: PUSH
28811: LD_INT 51
28813: PUSH
28814: LD_INT 53
28816: PUSH
28817: LD_INT 52
28819: PUSH
28820: LD_INT 32
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: LIST
28827: LIST
28828: LIST
28829: LIST
28830: LIST
28831: IN
28832: NOT
28833: IFFALSE 28875
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28835: LD_ADDR_EXP 61
28839: PUSH
28840: LD_EXP 61
28844: PPUSH
28845: LD_VAR 0 4
28849: PPUSH
28850: LD_EXP 61
28854: PUSH
28855: LD_VAR 0 4
28859: ARRAY
28860: PUSH
28861: LD_INT 1
28863: PLUS
28864: PPUSH
28865: LD_VAR 0 1
28869: PPUSH
28870: CALL 31125 0 4
28874: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28875: LD_VAR 0 1
28879: PPUSH
28880: CALL_OW 264
28884: PUSH
28885: LD_INT 31
28887: EQUAL
28888: IFFALSE 28907
// SetTag ( GetDriver ( veh ) , 9 ) ;
28890: LD_VAR 0 1
28894: PPUSH
28895: CALL 31768 0 1
28899: PPUSH
28900: LD_INT 9
28902: PPUSH
28903: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28907: LD_VAR 0 1
28911: PPUSH
28912: CALL_OW 264
28916: PUSH
28917: LD_INT 14
28919: PUSH
28920: LD_INT 53
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: IN
28927: IFFALSE 28964
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28929: LD_ADDR_EXP 44
28933: PUSH
28934: LD_EXP 44
28938: PPUSH
28939: LD_VAR 0 1
28943: PPUSH
28944: CALL_OW 255
28948: PPUSH
28949: LD_INT 2
28951: PPUSH
28952: LD_VAR 0 1
28956: PPUSH
28957: CALL 31125 0 4
28961: ST_TO_ADDR
// exit ;
28962: GO 29375
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28964: LD_VAR 0 1
28968: PPUSH
28969: CALL_OW 265
28973: PUSH
28974: LD_EXP 68
28978: PUSH
28979: LD_VAR 0 4
28983: ARRAY
28984: PUSH
28985: LD_INT 1
28987: ARRAY
28988: IN
28989: PUSH
28990: LD_VAR 0 1
28994: PPUSH
28995: CALL_OW 262
28999: PUSH
29000: LD_EXP 68
29004: PUSH
29005: LD_VAR 0 4
29009: ARRAY
29010: PUSH
29011: LD_INT 1
29013: ARRAY
29014: IN
29015: AND
29016: PUSH
29017: LD_VAR 0 1
29021: PPUSH
29022: CALL_OW 263
29026: PUSH
29027: LD_EXP 68
29031: PUSH
29032: LD_VAR 0 4
29036: ARRAY
29037: PUSH
29038: LD_INT 1
29040: ARRAY
29041: IN
29042: AND
29043: PUSH
29044: LD_VAR 0 1
29048: PPUSH
29049: CALL_OW 264
29053: PUSH
29054: LD_EXP 68
29058: PUSH
29059: LD_VAR 0 4
29063: ARRAY
29064: PUSH
29065: LD_INT 1
29067: ARRAY
29068: IN
29069: AND
29070: IFFALSE 29114
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29072: LD_ADDR_EXP 69
29076: PUSH
29077: LD_EXP 69
29081: PPUSH
29082: LD_VAR 0 4
29086: PPUSH
29087: LD_EXP 69
29091: PUSH
29092: LD_VAR 0 4
29096: ARRAY
29097: PUSH
29098: LD_INT 1
29100: PLUS
29101: PPUSH
29102: LD_VAR 0 1
29106: PPUSH
29107: CALL 31125 0 4
29111: ST_TO_ADDR
// exit ;
29112: GO 29375
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29114: LD_VAR 0 6
29118: PUSH
29119: LD_EXP 71
29123: PUSH
29124: LD_VAR 0 4
29128: ARRAY
29129: PUSH
29130: LD_INT 1
29132: ARRAY
29133: EQUAL
29134: PUSH
29135: LD_VAR 0 7
29139: PUSH
29140: LD_EXP 71
29144: PUSH
29145: LD_VAR 0 4
29149: ARRAY
29150: PUSH
29151: LD_INT 2
29153: ARRAY
29154: EQUAL
29155: AND
29156: PUSH
29157: LD_VAR 0 8
29161: PUSH
29162: LD_EXP 71
29166: PUSH
29167: LD_VAR 0 4
29171: ARRAY
29172: PUSH
29173: LD_INT 3
29175: ARRAY
29176: EQUAL
29177: AND
29178: PUSH
29179: LD_VAR 0 9
29183: PUSH
29184: LD_EXP 71
29188: PUSH
29189: LD_VAR 0 4
29193: ARRAY
29194: PUSH
29195: LD_INT 4
29197: ARRAY
29198: EQUAL
29199: AND
29200: IFFALSE 29356
// begin tmp := MREG_ToAttack [ side ] ;
29202: LD_ADDR_VAR 0 5
29206: PUSH
29207: LD_EXP 71
29211: PUSH
29212: LD_VAR 0 4
29216: ARRAY
29217: ST_TO_ADDR
// for i = 1 to 4 do
29218: LD_ADDR_VAR 0 3
29222: PUSH
29223: DOUBLE
29224: LD_INT 1
29226: DEC
29227: ST_TO_ADDR
29228: LD_INT 4
29230: PUSH
29231: FOR_TO
29232: IFFALSE 29254
// tmp := Delete ( tmp , 1 ) ;
29234: LD_ADDR_VAR 0 5
29238: PUSH
29239: LD_VAR 0 5
29243: PPUSH
29244: LD_INT 1
29246: PPUSH
29247: CALL_OW 3
29251: ST_TO_ADDR
29252: GO 29231
29254: POP
29255: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29256: LD_ADDR_EXP 71
29260: PUSH
29261: LD_EXP 71
29265: PPUSH
29266: LD_VAR 0 4
29270: PPUSH
29271: LD_VAR 0 5
29275: PPUSH
29276: CALL_OW 1
29280: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29281: LD_ADDR_EXP 73
29285: PUSH
29286: LD_EXP 73
29290: PPUSH
29291: LD_VAR 0 4
29295: PPUSH
29296: LD_EXP 73
29300: PUSH
29301: LD_VAR 0 4
29305: ARRAY
29306: PUSH
29307: LD_INT 1
29309: PLUS
29310: PPUSH
29311: LD_VAR 0 1
29315: PPUSH
29316: CALL 31125 0 4
29320: ST_TO_ADDR
// if tmp = 0 then
29321: LD_VAR 0 5
29325: PUSH
29326: LD_INT 0
29328: EQUAL
29329: IFFALSE 29354
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29331: LD_ADDR_EXP 71
29335: PUSH
29336: LD_EXP 71
29340: PPUSH
29341: LD_VAR 0 4
29345: PPUSH
29346: LD_INT 0
29348: PPUSH
29349: CALL_OW 1
29353: ST_TO_ADDR
// exit ;
29354: GO 29375
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29356: LD_VAR 0 1
29360: PPUSH
29361: CALL_OW 255
29365: PPUSH
29366: LD_VAR 0 1
29370: PPUSH
29371: CALL 25748 0 2
// end ;
29375: PPOPN 9
29377: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29378: LD_EXP 41
29382: PUSH
29383: LD_VAR 0 2
29387: PPUSH
29388: CALL_OW 255
29392: ARRAY
29393: IFFALSE 29625
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29395: LD_STRING ApemanTamed [side: 
29397: PUSH
29398: LD_VAR 0 2
29402: PPUSH
29403: CALL_OW 255
29407: STR
29408: PUSH
29409: LD_STRING ; sci: 
29411: STR
29412: PUSH
29413: LD_VAR 0 2
29417: STR
29418: PUSH
29419: LD_STRING ; ape: 
29421: STR
29422: PUSH
29423: LD_VAR 0 1
29427: STR
29428: PUSH
29429: LD_STRING ]
29431: STR
29432: PPUSH
29433: CALL 7984 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29437: LD_INT 11
29439: PPUSH
29440: LD_VAR 0 2
29444: PPUSH
29445: CALL_OW 255
29449: PPUSH
29450: CALL_OW 321
29454: PUSH
29455: LD_INT 2
29457: EQUAL
29458: NOT
29459: PUSH
29460: LD_INT 2
29462: PPUSH
29463: LD_VAR 0 2
29467: PPUSH
29468: CALL_OW 255
29472: PPUSH
29473: CALL_OW 321
29477: PUSH
29478: LD_INT 2
29480: EQUAL
29481: NOT
29482: OR
29483: PUSH
29484: LD_VAR 0 2
29488: PPUSH
29489: CALL_OW 255
29493: PPUSH
29494: LD_INT 171
29496: PPUSH
29497: EMPTY
29498: PPUSH
29499: CALL 12290 0 3
29503: PUSH
29504: LD_INT 0
29506: EQUAL
29507: AND
29508: IFFALSE 29522
// begin SetTag ( ape , 171 ) ;
29510: LD_VAR 0 1
29514: PPUSH
29515: LD_INT 171
29517: PPUSH
29518: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29522: LD_VAR 0 2
29526: PPUSH
29527: CALL_OW 255
29531: PPUSH
29532: LD_INT 30
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PPUSH
29542: CALL 11587 0 2
29546: IFFALSE 29625
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29548: LD_VAR 0 1
29552: PPUSH
29553: LD_VAR 0 2
29557: PPUSH
29558: CALL_OW 255
29562: PPUSH
29563: LD_INT 30
29565: PUSH
29566: LD_INT 1
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PPUSH
29573: CALL 11587 0 2
29577: PUSH
29578: LD_INT 1
29580: ARRAY
29581: PPUSH
29582: CALL_OW 250
29586: PPUSH
29587: LD_VAR 0 2
29591: PPUSH
29592: CALL_OW 255
29596: PPUSH
29597: LD_INT 30
29599: PUSH
29600: LD_INT 1
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PPUSH
29607: CALL 11587 0 2
29611: PUSH
29612: LD_INT 1
29614: ARRAY
29615: PPUSH
29616: CALL_OW 251
29620: PPUSH
29621: CALL_OW 111
// end ;
29625: PPOPN 2
29627: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29628: LD_EXP 41
29632: PUSH
29633: LD_VAR 0 1
29637: PPUSH
29638: CALL_OW 255
29642: ARRAY
29643: IFFALSE 29921
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29645: LD_VAR 0 2
29649: PUSH
29650: LD_VAR 0 2
29654: PPUSH
29655: CALL_OW 255
29659: PPUSH
29660: CALL 12000 0 1
29664: IN
29665: IFFALSE 29806
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29667: LD_VAR 0 1
29671: PPUSH
29672: CALL_OW 266
29676: PUSH
29677: LD_INT 0
29679: PUSH
29680: LD_INT 1
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: IN
29687: IFFALSE 29717
// begin Wait ( 0 0$0.3 ) ;
29689: LD_INT 10
29691: PPUSH
29692: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29696: LD_VAR 0 2
29700: PPUSH
29701: LD_INT 16
29703: PPUSH
29704: CALL_OW 336
// ComExitBuilding ( un ) ;
29708: LD_VAR 0 2
29712: PPUSH
29713: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29717: LD_VAR 0 1
29721: PPUSH
29722: CALL_OW 266
29726: PUSH
29727: LD_INT 4
29729: PUSH
29730: LD_INT 5
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: IN
29737: IFFALSE 29806
// begin Wait ( 0 0$0.3 ) ;
29739: LD_INT 10
29741: PPUSH
29742: CALL_OW 67
// if GetTag ( un ) = 0 then
29746: LD_VAR 0 2
29750: PPUSH
29751: CALL_OW 110
29755: PUSH
29756: LD_INT 0
29758: EQUAL
29759: IFFALSE 29775
// SetClass ( un , class_apeman_soldier ) else
29761: LD_VAR 0 2
29765: PPUSH
29766: LD_INT 15
29768: PPUSH
29769: CALL_OW 336
29773: GO 29806
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29775: LD_INT 3
29777: PPUSH
29778: LD_VAR 0 2
29782: PPUSH
29783: CALL_OW 255
29787: PPUSH
29788: CALL_OW 321
29792: IFFALSE 29806
// SetClass ( un , class_apeman_kamikaze ) ;
29794: LD_VAR 0 2
29798: PPUSH
29799: LD_INT 17
29801: PPUSH
29802: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29806: LD_VAR 0 1
29810: PPUSH
29811: CALL_OW 266
29815: PUSH
29816: LD_INT 32
29818: EQUAL
29819: IFFALSE 29921
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29821: LD_ADDR_EXP 70
29825: PUSH
29826: LD_EXP 70
29830: PPUSH
29831: LD_VAR 0 1
29835: PPUSH
29836: CALL_OW 255
29840: PPUSH
29841: LD_EXP 70
29845: PUSH
29846: LD_VAR 0 1
29850: PPUSH
29851: CALL_OW 255
29855: ARRAY
29856: PUSH
29857: LD_INT 1
29859: PLUS
29860: PPUSH
29861: LD_VAR 0 1
29865: PPUSH
29866: CALL 31125 0 4
29870: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29871: LD_ADDR_EXP 70
29875: PUSH
29876: LD_EXP 70
29880: PPUSH
29881: LD_VAR 0 1
29885: PPUSH
29886: CALL_OW 255
29890: PPUSH
29891: LD_EXP 70
29895: PUSH
29896: LD_VAR 0 1
29900: PPUSH
29901: CALL_OW 255
29905: ARRAY
29906: PUSH
29907: LD_INT 1
29909: PLUS
29910: PPUSH
29911: LD_VAR 0 2
29915: PPUSH
29916: CALL 31125 0 4
29920: ST_TO_ADDR
// end ; end ;
29921: PPOPN 2
29923: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29924: LD_VAR 0 1
29928: PPUSH
29929: CALL 56173 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29933: LD_VAR 0 1
29937: PUSH
29938: LD_INT 22
29940: PUSH
29941: LD_INT 3
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 23
29950: PUSH
29951: LD_INT 3
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 21
29960: PUSH
29961: LD_INT 1
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: LIST
29972: PPUSH
29973: CALL_OW 69
29977: IN
29978: IFFALSE 29994
// player_loss := player_loss + 1 ;
29980: LD_ADDR_EXP 10
29984: PUSH
29985: LD_EXP 10
29989: PUSH
29990: LD_INT 1
29992: PLUS
29993: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29994: LD_VAR 0 1
29998: PUSH
29999: LD_INT 22
30001: PUSH
30002: LD_INT 1
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 21
30011: PUSH
30012: LD_INT 3
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PPUSH
30023: CALL_OW 69
30027: IN
30028: PUSH
30029: LD_EXP 15
30033: NOT
30034: AND
30035: IFFALSE 30098
// begin alfa_north_triggered := true ;
30037: LD_ADDR_EXP 15
30041: PUSH
30042: LD_INT 1
30044: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30045: LD_EXP 5
30049: PPUSH
30050: LD_STRING DS4
30052: PPUSH
30053: CALL_OW 94
// Wait ( 1 1$25 ) ;
30057: LD_INT 2975
30059: PPUSH
30060: CALL_OW 67
// if not isTest then
30064: LD_EXP 1
30068: NOT
30069: IFFALSE 30098
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30071: LD_INT 20
30073: PPUSH
30074: LD_INT 5
30076: PUSH
30077: LD_INT 6
30079: PUSH
30080: LD_INT 7
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: LIST
30087: PUSH
30088: LD_OWVAR 67
30092: ARRAY
30093: PPUSH
30094: CALL 7122 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30098: LD_VAR 0 1
30102: PUSH
30103: LD_INT 22
30105: PUSH
30106: LD_INT 4
30108: PUSH
30109: EMPTY
30110: LIST
30111: LIST
30112: PUSH
30113: LD_INT 21
30115: PUSH
30116: LD_INT 3
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PPUSH
30127: CALL_OW 69
30131: IN
30132: PUSH
30133: LD_EXP 16
30137: NOT
30138: AND
30139: IFFALSE 30202
// begin alfa_south_triggered := true ;
30141: LD_ADDR_EXP 16
30145: PUSH
30146: LD_INT 1
30148: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30149: LD_EXP 4
30153: PPUSH
30154: LD_STRING DJ3
30156: PPUSH
30157: CALL_OW 94
// Wait ( 0 0$45 ) ;
30161: LD_INT 1575
30163: PPUSH
30164: CALL_OW 67
// if not isTest then
30168: LD_EXP 1
30172: NOT
30173: IFFALSE 30202
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30175: LD_INT 20
30177: PPUSH
30178: LD_INT 5
30180: PUSH
30181: LD_INT 6
30183: PUSH
30184: LD_INT 7
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: LIST
30191: PUSH
30192: LD_OWVAR 67
30196: ARRAY
30197: PPUSH
30198: CALL 7122 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30202: LD_VAR 0 1
30206: PPUSH
30207: CALL_OW 266
30211: PUSH
30212: LD_INT 1
30214: EQUAL
30215: PUSH
30216: LD_VAR 0 1
30220: PPUSH
30221: CALL_OW 255
30225: PUSH
30226: LD_INT 1
30228: PUSH
30229: LD_INT 4
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: IN
30236: AND
30237: IFFALSE 30246
// RaiseSailEvent ( 104 ) ;
30239: LD_INT 104
30241: PPUSH
30242: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30246: LD_EXP 41
30250: PUSH
30251: LD_VAR 0 1
30255: PPUSH
30256: CALL_OW 255
30260: ARRAY
30261: IFFALSE 30648
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30263: LD_STRING UnitDestroyed [side 
30265: PUSH
30266: LD_VAR 0 1
30270: PPUSH
30271: CALL_OW 255
30275: STR
30276: PUSH
30277: LD_STRING ; id: 
30279: STR
30280: PUSH
30281: LD_VAR 0 1
30285: STR
30286: PUSH
30287: LD_STRING ; type: 
30289: STR
30290: PUSH
30291: LD_VAR 0 1
30295: PPUSH
30296: CALL_OW 247
30300: STR
30301: PUSH
30302: LD_STRING ]
30304: STR
30305: PPUSH
30306: CALL 7984 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30310: LD_VAR 0 1
30314: PUSH
30315: LD_VAR 0 1
30319: PPUSH
30320: CALL_OW 255
30324: PPUSH
30325: LD_INT 21
30327: PUSH
30328: LD_INT 1
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PPUSH
30335: CALL 11587 0 2
30339: IN
30340: IFFALSE 30496
// begin if MCF_HasClass ( un ) then
30342: LD_VAR 0 1
30346: PPUSH
30347: CALL 14293 0 1
30351: IFFALSE 30496
// case MCF_HasClass ( un ) of 1 :
30353: LD_VAR 0 1
30357: PPUSH
30358: CALL 14293 0 1
30362: PUSH
30363: LD_INT 1
30365: DOUBLE
30366: EQUAL
30367: IFTRUE 30371
30369: GO 30396
30371: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30372: LD_VAR 0 1
30376: PPUSH
30377: CALL_OW 255
30381: PPUSH
30382: LD_STRING ToArm
30384: PPUSH
30385: LD_VAR 0 1
30389: PPUSH
30390: CALL 14466 0 3
30394: GO 30496
30396: LD_INT 2
30398: DOUBLE
30399: EQUAL
30400: IFTRUE 30404
30402: GO 30429
30404: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30405: LD_VAR 0 1
30409: PPUSH
30410: CALL_OW 255
30414: PPUSH
30415: LD_STRING ToDep
30417: PPUSH
30418: LD_VAR 0 1
30422: PPUSH
30423: CALL 14466 0 3
30427: GO 30496
30429: LD_INT 3
30431: DOUBLE
30432: EQUAL
30433: IFTRUE 30437
30435: GO 30462
30437: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30438: LD_VAR 0 1
30442: PPUSH
30443: CALL_OW 255
30447: PPUSH
30448: LD_STRING ToFac
30450: PPUSH
30451: LD_VAR 0 1
30455: PPUSH
30456: CALL 14466 0 3
30460: GO 30496
30462: LD_INT 4
30464: DOUBLE
30465: EQUAL
30466: IFTRUE 30470
30468: GO 30495
30470: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30471: LD_VAR 0 1
30475: PPUSH
30476: CALL_OW 255
30480: PPUSH
30481: LD_STRING ToLab
30483: PPUSH
30484: LD_VAR 0 1
30488: PPUSH
30489: CALL 14466 0 3
30493: GO 30496
30495: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30496: LD_VAR 0 1
30500: PUSH
30501: LD_EXP 69
30505: PUSH
30506: LD_VAR 0 1
30510: PPUSH
30511: CALL_OW 255
30515: ARRAY
30516: IN
30517: IFFALSE 30602
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30519: LD_ADDR_EXP 69
30523: PUSH
30524: LD_EXP 69
30528: PPUSH
30529: LD_VAR 0 1
30533: PPUSH
30534: LD_INT 0
30536: PPUSH
30537: CALL 31284 0 3
30541: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30542: LD_VAR 0 1
30546: PPUSH
30547: CALL_OW 255
30551: PPUSH
30552: LD_VAR 0 1
30556: PPUSH
30557: CALL_OW 265
30561: PUSH
30562: LD_VAR 0 1
30566: PPUSH
30567: CALL_OW 262
30571: PUSH
30572: LD_VAR 0 1
30576: PPUSH
30577: CALL_OW 263
30581: PUSH
30582: LD_VAR 0 1
30586: PPUSH
30587: CALL_OW 264
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: PPUSH
30598: CALL 21106 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30602: LD_VAR 0 1
30606: PUSH
30607: LD_EXP 73
30611: PUSH
30612: LD_VAR 0 1
30616: PPUSH
30617: CALL_OW 255
30621: ARRAY
30622: IN
30623: IFFALSE 30648
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30625: LD_ADDR_EXP 73
30629: PUSH
30630: LD_EXP 73
30634: PPUSH
30635: LD_VAR 0 1
30639: PPUSH
30640: LD_INT 0
30642: PPUSH
30643: CALL 31284 0 3
30647: ST_TO_ADDR
// end ; end ;
30648: PPOPN 1
30650: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30651: LD_EXP 41
30655: PUSH
30656: LD_VAR 0 2
30660: PPUSH
30661: CALL_OW 255
30665: ARRAY
30666: IFFALSE 30838
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30668: LD_VAR 0 2
30672: PUSH
30673: LD_EXP 70
30677: PUSH
30678: LD_VAR 0 2
30682: PPUSH
30683: CALL_OW 255
30687: ARRAY
30688: IN
30689: PUSH
30690: LD_VAR 0 1
30694: PPUSH
30695: CALL_OW 266
30699: PUSH
30700: LD_INT 32
30702: PUSH
30703: LD_INT 31
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: IN
30710: AND
30711: IFFALSE 30811
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30713: LD_ADDR_EXP 70
30717: PUSH
30718: LD_EXP 70
30722: PPUSH
30723: LD_VAR 0 1
30727: PPUSH
30728: LD_INT 0
30730: PPUSH
30731: CALL 31284 0 3
30735: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30736: LD_ADDR_EXP 70
30740: PUSH
30741: LD_EXP 70
30745: PPUSH
30746: LD_VAR 0 2
30750: PPUSH
30751: LD_INT 0
30753: PPUSH
30754: CALL 31284 0 3
30758: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30759: LD_EXP 70
30763: PUSH
30764: LD_VAR 0 2
30768: PPUSH
30769: CALL_OW 255
30773: ARRAY
30774: PUSH
30775: LD_STRING 
30777: EQUAL
30778: IFFALSE 30811
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30780: LD_ADDR_EXP 70
30784: PUSH
30785: LD_EXP 70
30789: PPUSH
30790: LD_VAR 0 2
30794: PPUSH
30795: CALL_OW 255
30799: PPUSH
30800: LD_INT 1
30802: PPUSH
30803: LD_INT 0
30805: PPUSH
30806: CALL 31125 0 4
30810: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30811: LD_VAR 0 1
30815: PPUSH
30816: CALL_OW 266
30820: PUSH
30821: LD_INT 36
30823: IN
30824: IFFALSE 30838
// SetTag ( un , 0 ) ;
30826: LD_VAR 0 2
30830: PPUSH
30831: LD_INT 0
30833: PPUSH
30834: CALL_OW 109
// end ;
30838: PPOPN 2
30840: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30841: LD_EXP 41
30845: PUSH
30846: LD_VAR 0 1
30850: PPUSH
30851: CALL_OW 255
30855: ARRAY
30856: IFFALSE 30882
// begin if GetControl ( un ) = control_remote then
30858: LD_VAR 0 1
30862: PPUSH
30863: CALL_OW 263
30867: PUSH
30868: LD_INT 2
30870: EQUAL
30871: IFFALSE 30882
// ComUnlink ( un ) ;
30873: LD_VAR 0 1
30877: PPUSH
30878: CALL_OW 136
// end ;
30882: PPOPN 1
30884: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30885: LD_EXP 41
30889: PUSH
30890: LD_VAR 0 1
30894: PPUSH
30895: CALL_OW 255
30899: ARRAY
30900: IFFALSE 30929
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30902: LD_VAR 0 2
30906: PPUSH
30907: CALL_OW 264
30911: PUSH
30912: LD_INT 31
30914: IN
30915: IFFALSE 30929
// SetTag ( driver , 0 ) ;
30917: LD_VAR 0 1
30921: PPUSH
30922: LD_INT 0
30924: PPUSH
30925: CALL_OW 109
// end ;
30929: PPOPN 4
30931: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30932: LD_INT 0
30934: PPUSH
30935: PPUSH
30936: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30937: LD_ADDR_VAR 0 3
30941: PUSH
30942: LD_VAR 0 1
30946: PPUSH
30947: CALL_OW 269
30951: ST_TO_ADDR
// x := GetX ( building ) ;
30952: LD_ADDR_VAR 0 4
30956: PUSH
30957: LD_VAR 0 1
30961: PPUSH
30962: CALL_OW 250
30966: ST_TO_ADDR
// y := GetY ( building ) ;
30967: LD_ADDR_VAR 0 5
30971: PUSH
30972: LD_VAR 0 1
30976: PPUSH
30977: CALL_OW 251
30981: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30982: LD_ADDR_EXP 45
30986: PUSH
30987: LD_EXP 45
30991: PPUSH
30992: LD_VAR 0 1
30996: PPUSH
30997: CALL_OW 255
31001: PPUSH
31002: LD_VAR 0 3
31006: PPUSH
31007: LD_VAR 0 4
31011: PUSH
31012: LD_VAR 0 5
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PPUSH
31021: CALL 42166 0 4
31025: ST_TO_ADDR
// end ;
31026: PPOPN 5
31028: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31029: LD_VAR 0 1
31033: PUSH
31034: LD_EXP 32
31038: IN
31039: NOT
31040: IFFALSE 31088
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31042: LD_ADDR_EXP 32
31046: PUSH
31047: LD_EXP 32
31051: PPUSH
31052: LD_EXP 32
31056: PUSH
31057: LD_INT 1
31059: PLUS
31060: PPUSH
31061: LD_VAR 0 1
31065: PPUSH
31066: CALL_OW 2
31070: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31071: LD_STRING DestinationUnrechable. [unit: 
31073: PUSH
31074: LD_VAR 0 1
31078: STR
31079: PUSH
31080: LD_STRING ]
31082: STR
31083: PPUSH
31084: CALL 7984 0 1
// end ; end ;
31088: PPOPN 1
31090: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31091: LD_VAR 0 1
31095: PPUSH
31096: LD_VAR 0 2
31100: PPUSH
31101: LD_VAR 0 3
31105: PPUSH
31106: CALL 56271 0 3
// end ;
31110: PPOPN 3
31112: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31113: LD_VAR 0 1
31117: PPUSH
31118: CALL 56279 0 1
// end ; end_of_file
31122: PPOPN 1
31124: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31125: LD_INT 0
31127: PPUSH
31128: PPUSH
31129: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31130: LD_ADDR_VAR 0 7
31134: PUSH
31135: LD_VAR 0 1
31139: PUSH
31140: LD_VAR 0 2
31144: ARRAY
31145: PPUSH
31146: LD_VAR 0 3
31150: PPUSH
31151: LD_VAR 0 4
31155: PPUSH
31156: CALL_OW 1
31160: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31161: LD_ADDR_VAR 0 1
31165: PUSH
31166: LD_VAR 0 1
31170: PPUSH
31171: LD_VAR 0 2
31175: PPUSH
31176: LD_VAR 0 7
31180: PPUSH
31181: CALL_OW 1
31185: ST_TO_ADDR
// result := tab ;
31186: LD_ADDR_VAR 0 5
31190: PUSH
31191: LD_VAR 0 1
31195: ST_TO_ADDR
// end ;
31196: LD_VAR 0 5
31200: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31201: LD_INT 0
31203: PPUSH
31204: PPUSH
31205: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31206: LD_ADDR_VAR 0 5
31210: PUSH
31211: LD_VAR 0 1
31215: PUSH
31216: LD_VAR 0 2
31220: PUSH
31221: LD_INT 1
31223: ARRAY
31224: ARRAY
31225: PPUSH
31226: LD_VAR 0 2
31230: PUSH
31231: LD_INT 2
31233: ARRAY
31234: PPUSH
31235: CALL_OW 3
31239: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31240: LD_ADDR_VAR 0 1
31244: PUSH
31245: LD_VAR 0 1
31249: PPUSH
31250: LD_VAR 0 2
31254: PUSH
31255: LD_INT 1
31257: ARRAY
31258: PPUSH
31259: LD_VAR 0 5
31263: PPUSH
31264: CALL_OW 1
31268: ST_TO_ADDR
// result := tab ;
31269: LD_ADDR_VAR 0 3
31273: PUSH
31274: LD_VAR 0 1
31278: ST_TO_ADDR
// end ;
31279: LD_VAR 0 3
31283: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31284: LD_INT 0
31286: PPUSH
31287: PPUSH
31288: PPUSH
31289: PPUSH
// i := 1 ;
31290: LD_ADDR_VAR 0 5
31294: PUSH
31295: LD_INT 1
31297: ST_TO_ADDR
// while ( i <= tab ) do
31298: LD_VAR 0 5
31302: PUSH
31303: LD_VAR 0 1
31307: LESSEQUAL
31308: IFFALSE 31683
// begin if not tab [ i ] then
31310: LD_VAR 0 1
31314: PUSH
31315: LD_VAR 0 5
31319: ARRAY
31320: NOT
31321: IFFALSE 31325
// break ;
31323: GO 31683
// if value in tab then
31325: LD_VAR 0 2
31329: PUSH
31330: LD_VAR 0 1
31334: IN
31335: IFFALSE 31448
// begin if not mode then
31337: LD_VAR 0 3
31341: NOT
31342: IFFALSE 31362
// tab := tab diff value else
31344: LD_ADDR_VAR 0 1
31348: PUSH
31349: LD_VAR 0 1
31353: PUSH
31354: LD_VAR 0 2
31358: DIFF
31359: ST_TO_ADDR
31360: GO 31424
// for j = 1 to tab do
31362: LD_ADDR_VAR 0 6
31366: PUSH
31367: DOUBLE
31368: LD_INT 1
31370: DEC
31371: ST_TO_ADDR
31372: LD_VAR 0 1
31376: PUSH
31377: FOR_TO
31378: IFFALSE 31422
// if tab [ j ] = value then
31380: LD_VAR 0 1
31384: PUSH
31385: LD_VAR 0 6
31389: ARRAY
31390: PUSH
31391: LD_VAR 0 2
31395: EQUAL
31396: IFFALSE 31420
// begin tab := Delete ( tab , j ) ;
31398: LD_ADDR_VAR 0 1
31402: PUSH
31403: LD_VAR 0 1
31407: PPUSH
31408: LD_VAR 0 6
31412: PPUSH
31413: CALL_OW 3
31417: ST_TO_ADDR
// break ;
31418: GO 31422
// end ;
31420: GO 31377
31422: POP
31423: POP
// i := i - 1 ;
31424: LD_ADDR_VAR 0 5
31428: PUSH
31429: LD_VAR 0 5
31433: PUSH
31434: LD_INT 1
31436: MINUS
31437: ST_TO_ADDR
// if mode then
31438: LD_VAR 0 3
31442: IFFALSE 31446
// break ;
31444: GO 31683
// end else
31446: GO 31667
// if tab [ i ] and value in tab [ i ] then
31448: LD_VAR 0 1
31452: PUSH
31453: LD_VAR 0 5
31457: ARRAY
31458: PUSH
31459: LD_VAR 0 2
31463: PUSH
31464: LD_VAR 0 1
31468: PUSH
31469: LD_VAR 0 5
31473: ARRAY
31474: IN
31475: AND
31476: IFFALSE 31667
// begin if not mode then
31478: LD_VAR 0 3
31482: NOT
31483: IFFALSE 31509
// tmp := tab [ i ] diff value else
31485: LD_ADDR_VAR 0 7
31489: PUSH
31490: LD_VAR 0 1
31494: PUSH
31495: LD_VAR 0 5
31499: ARRAY
31500: PUSH
31501: LD_VAR 0 2
31505: DIFF
31506: ST_TO_ADDR
31507: GO 31589
// for j = 1 to tab [ i ] do
31509: LD_ADDR_VAR 0 6
31513: PUSH
31514: DOUBLE
31515: LD_INT 1
31517: DEC
31518: ST_TO_ADDR
31519: LD_VAR 0 1
31523: PUSH
31524: LD_VAR 0 5
31528: ARRAY
31529: PUSH
31530: FOR_TO
31531: IFFALSE 31587
// if value = tab [ i ] [ j ] then
31533: LD_VAR 0 2
31537: PUSH
31538: LD_VAR 0 1
31542: PUSH
31543: LD_VAR 0 5
31547: ARRAY
31548: PUSH
31549: LD_VAR 0 6
31553: ARRAY
31554: EQUAL
31555: IFFALSE 31585
// begin tmp := Delete ( tab [ i ] , j ) ;
31557: LD_ADDR_VAR 0 7
31561: PUSH
31562: LD_VAR 0 1
31566: PUSH
31567: LD_VAR 0 5
31571: ARRAY
31572: PPUSH
31573: LD_VAR 0 6
31577: PPUSH
31578: CALL_OW 3
31582: ST_TO_ADDR
// break ;
31583: GO 31587
// end ;
31585: GO 31530
31587: POP
31588: POP
// if tmp = [ ] then
31589: LD_VAR 0 7
31593: PUSH
31594: EMPTY
31595: EQUAL
31596: IFFALSE 31620
// begin tab := Delete ( tab , i ) ;
31598: LD_ADDR_VAR 0 1
31602: PUSH
31603: LD_VAR 0 1
31607: PPUSH
31608: LD_VAR 0 5
31612: PPUSH
31613: CALL_OW 3
31617: ST_TO_ADDR
// end else
31618: GO 31645
// tab := Replace ( tab , i , tmp ) ;
31620: LD_ADDR_VAR 0 1
31624: PUSH
31625: LD_VAR 0 1
31629: PPUSH
31630: LD_VAR 0 5
31634: PPUSH
31635: LD_VAR 0 7
31639: PPUSH
31640: CALL_OW 1
31644: ST_TO_ADDR
// i := i - 1 ;
31645: LD_ADDR_VAR 0 5
31649: PUSH
31650: LD_VAR 0 5
31654: PUSH
31655: LD_INT 1
31657: MINUS
31658: ST_TO_ADDR
// if mode then
31659: LD_VAR 0 3
31663: IFFALSE 31667
// break ;
31665: GO 31683
// end ; i := i + 1 ;
31667: LD_ADDR_VAR 0 5
31671: PUSH
31672: LD_VAR 0 5
31676: PUSH
31677: LD_INT 1
31679: PLUS
31680: ST_TO_ADDR
// end ;
31681: GO 31298
// result := tab ;
31683: LD_ADDR_VAR 0 4
31687: PUSH
31688: LD_VAR 0 1
31692: ST_TO_ADDR
// end ;
31693: LD_VAR 0 4
31697: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31698: LD_INT 0
31700: PPUSH
31701: PPUSH
// for i = 1 to values do
31702: LD_ADDR_VAR 0 4
31706: PUSH
31707: DOUBLE
31708: LD_INT 1
31710: DEC
31711: ST_TO_ADDR
31712: LD_VAR 0 2
31716: PUSH
31717: FOR_TO
31718: IFFALSE 31751
// tab := Remove ( tab , values [ i ] , false ) ;
31720: LD_ADDR_VAR 0 1
31724: PUSH
31725: LD_VAR 0 1
31729: PPUSH
31730: LD_VAR 0 2
31734: PUSH
31735: LD_VAR 0 4
31739: ARRAY
31740: PPUSH
31741: LD_INT 0
31743: PPUSH
31744: CALL 31284 0 3
31748: ST_TO_ADDR
31749: GO 31717
31751: POP
31752: POP
// result := tab ;
31753: LD_ADDR_VAR 0 3
31757: PUSH
31758: LD_VAR 0 1
31762: ST_TO_ADDR
// end ;
31763: LD_VAR 0 3
31767: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31768: LD_INT 0
31770: PPUSH
31771: PPUSH
31772: PPUSH
// if not GetControl ( veh ) = control_manual then
31773: LD_VAR 0 1
31777: PPUSH
31778: CALL_OW 263
31782: PUSH
31783: LD_INT 1
31785: EQUAL
31786: NOT
31787: IFFALSE 31799
// result := false else
31789: LD_ADDR_VAR 0 2
31793: PUSH
31794: LD_INT 0
31796: ST_TO_ADDR
31797: GO 31944
// if veh in FilterAllUnits ( [ f_empty ] ) then
31799: LD_VAR 0 1
31803: PUSH
31804: LD_INT 58
31806: PUSH
31807: EMPTY
31808: LIST
31809: PPUSH
31810: CALL_OW 69
31814: IN
31815: IFFALSE 31827
// result := false else
31817: LD_ADDR_VAR 0 2
31821: PUSH
31822: LD_INT 0
31824: ST_TO_ADDR
31825: GO 31944
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31827: LD_ADDR_VAR 0 4
31831: PUSH
31832: LD_INT 22
31834: PUSH
31835: LD_VAR 0 1
31839: PPUSH
31840: CALL_OW 255
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 55
31851: PUSH
31852: EMPTY
31853: LIST
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PPUSH
31859: CALL_OW 69
31863: ST_TO_ADDR
// if not filter then
31864: LD_VAR 0 4
31868: NOT
31869: IFFALSE 31881
// result := false else
31871: LD_ADDR_VAR 0 2
31875: PUSH
31876: LD_INT 0
31878: ST_TO_ADDR
31879: GO 31944
// for i = 1 to filter do
31881: LD_ADDR_VAR 0 3
31885: PUSH
31886: DOUBLE
31887: LD_INT 1
31889: DEC
31890: ST_TO_ADDR
31891: LD_VAR 0 4
31895: PUSH
31896: FOR_TO
31897: IFFALSE 31942
// if IsDriver ( filter [ i ] ) = veh then
31899: LD_VAR 0 4
31903: PUSH
31904: LD_VAR 0 3
31908: ARRAY
31909: PPUSH
31910: CALL 91556 0 1
31914: PUSH
31915: LD_VAR 0 1
31919: EQUAL
31920: IFFALSE 31940
// begin result := filter [ i ] ;
31922: LD_ADDR_VAR 0 2
31926: PUSH
31927: LD_VAR 0 4
31931: PUSH
31932: LD_VAR 0 3
31936: ARRAY
31937: ST_TO_ADDR
// break ;
31938: GO 31942
// end ;
31940: GO 31896
31942: POP
31943: POP
// end ; end ;
31944: LD_VAR 0 2
31948: RET
// export function Compare ( val1 , val2 ) ; begin
31949: LD_INT 0
31951: PPUSH
// if val1 = val2 then
31952: LD_VAR 0 1
31956: PUSH
31957: LD_VAR 0 2
31961: EQUAL
31962: IFFALSE 31974
// result := true else
31964: LD_ADDR_VAR 0 3
31968: PUSH
31969: LD_INT 1
31971: ST_TO_ADDR
31972: GO 31982
// result := false ;
31974: LD_ADDR_VAR 0 3
31978: PUSH
31979: LD_INT 0
31981: ST_TO_ADDR
// end ;
31982: LD_VAR 0 3
31986: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31987: LD_INT 0
31989: PPUSH
31990: PPUSH
// result := false ;
31991: LD_ADDR_VAR 0 3
31995: PUSH
31996: LD_INT 0
31998: ST_TO_ADDR
// for j = 1 to e2 do
31999: LD_ADDR_VAR 0 4
32003: PUSH
32004: DOUBLE
32005: LD_INT 1
32007: DEC
32008: ST_TO_ADDR
32009: LD_VAR 0 2
32013: PUSH
32014: FOR_TO
32015: IFFALSE 32049
// if Compare ( e1 , e2 [ j ] ) then
32017: LD_VAR 0 1
32021: PPUSH
32022: LD_VAR 0 2
32026: PUSH
32027: LD_VAR 0 4
32031: ARRAY
32032: PPUSH
32033: CALL 31949 0 2
32037: IFFALSE 32047
// result := true ;
32039: LD_ADDR_VAR 0 3
32043: PUSH
32044: LD_INT 1
32046: ST_TO_ADDR
32047: GO 32014
32049: POP
32050: POP
// end ;
32051: LD_VAR 0 3
32055: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32056: LD_INT 0
32058: PPUSH
32059: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32060: LD_VAR 0 1
32064: PPUSH
32065: LD_STRING C
32067: PUSH
32068: LD_VAR 0 2
32072: PUSH
32073: LD_VAR 0 3
32077: PUSH
32078: LD_INT 0
32080: PUSH
32081: LD_INT 0
32083: PUSH
32084: LD_INT 0
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: PUSH
32099: LD_STRING v
32101: PUSH
32102: LD_VAR 0 4
32106: PPUSH
32107: CALL_OW 250
32111: PUSH
32112: LD_VAR 0 4
32116: PPUSH
32117: CALL_OW 251
32121: PUSH
32122: LD_VAR 0 4
32126: PUSH
32127: LD_INT 0
32129: PUSH
32130: LD_INT 0
32132: PUSH
32133: LD_INT 0
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: LIST
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PPUSH
32149: CALL_OW 446
// end ;
32153: LD_VAR 0 5
32157: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32158: LD_INT 0
32160: PPUSH
32161: PPUSH
32162: PPUSH
// linked := UnitsLinked ( unit ) ;
32163: LD_ADDR_VAR 0 4
32167: PUSH
32168: LD_VAR 0 1
32172: PPUSH
32173: CALL_OW 432
32177: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32178: LD_ADDR_VAR 0 3
32182: PUSH
32183: LD_VAR 0 1
32187: PPUSH
32188: LD_INT 3
32190: PPUSH
32191: CALL_OW 259
32195: ST_TO_ADDR
// if sk > linked then
32196: LD_VAR 0 3
32200: PUSH
32201: LD_VAR 0 4
32205: GREATER
32206: IFFALSE 32218
// result := true else
32208: LD_ADDR_VAR 0 2
32212: PUSH
32213: LD_INT 1
32215: ST_TO_ADDR
32216: GO 32226
// result := false ;
32218: LD_ADDR_VAR 0 2
32222: PUSH
32223: LD_INT 0
32225: ST_TO_ADDR
// end ;
32226: LD_VAR 0 2
32230: RET
// export function NotTask ( unit ) ; begin
32231: LD_INT 0
32233: PPUSH
// result := true ;
32234: LD_ADDR_VAR 0 2
32238: PUSH
32239: LD_INT 1
32241: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32242: LD_VAR 0 1
32246: PPUSH
32247: CALL_OW 437
32251: PUSH
32252: LD_VAR 0 1
32256: PPUSH
32257: CALL_OW 314
32261: OR
32262: IFFALSE 32272
// result := false ;
32264: LD_ADDR_VAR 0 2
32268: PUSH
32269: LD_INT 0
32271: ST_TO_ADDR
// end ;
32272: LD_VAR 0 2
32276: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32277: LD_INT 0
32279: PPUSH
32280: PPUSH
32281: PPUSH
32282: PPUSH
32283: PPUSH
// dist := 99999 ;
32284: LD_ADDR_VAR 0 7
32288: PUSH
32289: LD_INT 99999
32291: ST_TO_ADDR
// un := - 1 ;
32292: LD_ADDR_VAR 0 6
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: ST_TO_ADDR
// if units1 and units2 then
32301: LD_VAR 0 1
32305: PUSH
32306: LD_VAR 0 2
32310: AND
32311: IFFALSE 32399
// for i in units1 do
32313: LD_ADDR_VAR 0 4
32317: PUSH
32318: LD_VAR 0 1
32322: PUSH
32323: FOR_IN
32324: IFFALSE 32397
// for j in units2 do
32326: LD_ADDR_VAR 0 5
32330: PUSH
32331: LD_VAR 0 2
32335: PUSH
32336: FOR_IN
32337: IFFALSE 32393
// if GetDistUnits ( i , j ) < dist then
32339: LD_VAR 0 4
32343: PPUSH
32344: LD_VAR 0 5
32348: PPUSH
32349: CALL_OW 296
32353: PUSH
32354: LD_VAR 0 7
32358: LESS
32359: IFFALSE 32391
// begin un := i ;
32361: LD_ADDR_VAR 0 6
32365: PUSH
32366: LD_VAR 0 4
32370: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32371: LD_ADDR_VAR 0 7
32375: PUSH
32376: LD_VAR 0 4
32380: PPUSH
32381: LD_VAR 0 5
32385: PPUSH
32386: CALL_OW 296
32390: ST_TO_ADDR
// end ;
32391: GO 32336
32393: POP
32394: POP
32395: GO 32323
32397: POP
32398: POP
// result := [ un , dist ] ;
32399: LD_ADDR_VAR 0 3
32403: PUSH
32404: LD_VAR 0 6
32408: PUSH
32409: LD_VAR 0 7
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: ST_TO_ADDR
// end ;
32418: LD_VAR 0 3
32422: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32423: LD_INT 0
32425: PPUSH
32426: PPUSH
32427: PPUSH
32428: PPUSH
32429: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32430: LD_VAR 0 1
32434: NOT
32435: PUSH
32436: LD_VAR 0 1
32440: PPUSH
32441: CALL_OW 256
32445: PUSH
32446: LD_INT 250
32448: LESS
32449: OR
32450: PUSH
32451: LD_VAR 0 1
32455: PPUSH
32456: CALL_OW 314
32460: PUSH
32461: LD_VAR 0 1
32465: PPUSH
32466: CALL_OW 261
32470: PUSH
32471: LD_INT 20
32473: GREATER
32474: AND
32475: OR
32476: IFFALSE 32480
// exit ;
32478: GO 32854
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32480: LD_VAR 0 1
32484: PPUSH
32485: CALL_OW 261
32489: PUSH
32490: LD_INT 20
32492: LESS
32493: PUSH
32494: LD_VAR 0 1
32498: PPUSH
32499: CALL_OW 110
32503: PUSH
32504: LD_INT 21
32506: EQUAL
32507: NOT
32508: AND
32509: IFFALSE 32545
// begin ComStop ( bulldozer ) ;
32511: LD_VAR 0 1
32515: PPUSH
32516: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32520: LD_VAR 0 1
32524: PPUSH
32525: LD_INT 21
32527: PPUSH
32528: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32532: LD_VAR 0 1
32536: PPUSH
32537: CALL 26285 0 1
// exit ;
32541: GO 32854
// end else
32543: GO 32572
// if GetFuel ( bulldozer ) > 20 then
32545: LD_VAR 0 1
32549: PPUSH
32550: CALL_OW 261
32554: PUSH
32555: LD_INT 20
32557: GREATER
32558: IFFALSE 32572
// SetTag ( bulldozer , 0 ) ;
32560: LD_VAR 0 1
32564: PPUSH
32565: LD_INT 0
32567: PPUSH
32568: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32572: LD_ADDR_VAR 0 5
32576: PUSH
32577: LD_VAR 0 2
32581: PPUSH
32582: CALL_OW 353
32586: ST_TO_ADDR
// tmp := [ ] ;
32587: LD_ADDR_VAR 0 6
32591: PUSH
32592: EMPTY
32593: ST_TO_ADDR
// for i = 1 to list do
32594: LD_ADDR_VAR 0 4
32598: PUSH
32599: DOUBLE
32600: LD_INT 1
32602: DEC
32603: ST_TO_ADDR
32604: LD_VAR 0 5
32608: PUSH
32609: FOR_TO
32610: IFFALSE 32708
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32612: LD_VAR 0 5
32616: PUSH
32617: LD_VAR 0 4
32621: ARRAY
32622: PUSH
32623: LD_INT 1
32625: ARRAY
32626: PPUSH
32627: LD_VAR 0 5
32631: PUSH
32632: LD_VAR 0 4
32636: ARRAY
32637: PUSH
32638: LD_INT 2
32640: ARRAY
32641: PPUSH
32642: CALL_OW 554
32646: IFFALSE 32706
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32648: LD_ADDR_VAR 0 6
32652: PUSH
32653: LD_VAR 0 6
32657: PPUSH
32658: LD_VAR 0 6
32662: PUSH
32663: LD_INT 1
32665: PLUS
32666: PPUSH
32667: LD_VAR 0 5
32671: PUSH
32672: LD_VAR 0 4
32676: ARRAY
32677: PUSH
32678: LD_INT 1
32680: ARRAY
32681: PUSH
32682: LD_VAR 0 5
32686: PUSH
32687: LD_VAR 0 4
32691: ARRAY
32692: PUSH
32693: LD_INT 2
32695: ARRAY
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PPUSH
32701: CALL_OW 1
32705: ST_TO_ADDR
// end ;
32706: GO 32609
32708: POP
32709: POP
// ComStop ( bulldozer ) ;
32710: LD_VAR 0 1
32714: PPUSH
32715: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32719: LD_ADDR_VAR 0 7
32723: PUSH
32724: LD_VAR 0 1
32728: PPUSH
32729: CALL_OW 250
32733: PUSH
32734: LD_VAR 0 1
32738: PPUSH
32739: CALL_OW 251
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: ST_TO_ADDR
// for i = tmp downto 1 do
32748: LD_ADDR_VAR 0 4
32752: PUSH
32753: DOUBLE
32754: LD_VAR 0 6
32758: INC
32759: ST_TO_ADDR
32760: LD_INT 1
32762: PUSH
32763: FOR_DOWNTO
32764: IFFALSE 32852
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32766: LD_ADDR_VAR 0 7
32770: PUSH
32771: LD_VAR 0 7
32775: PUSH
32776: LD_INT 1
32778: ARRAY
32779: PPUSH
32780: LD_VAR 0 7
32784: PUSH
32785: LD_INT 2
32787: ARRAY
32788: PPUSH
32789: LD_VAR 0 6
32793: PPUSH
32794: CALL 32955 0 3
32798: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32799: LD_VAR 0 1
32803: PPUSH
32804: LD_VAR 0 7
32808: PUSH
32809: LD_INT 1
32811: ARRAY
32812: PPUSH
32813: LD_VAR 0 7
32817: PUSH
32818: LD_INT 2
32820: ARRAY
32821: PPUSH
32822: CALL 32859 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32826: LD_ADDR_VAR 0 6
32830: PUSH
32831: LD_VAR 0 6
32835: PPUSH
32836: LD_VAR 0 7
32840: PUSH
32841: LD_INT 3
32843: ARRAY
32844: PPUSH
32845: CALL_OW 3
32849: ST_TO_ADDR
// end ;
32850: GO 32763
32852: POP
32853: POP
// end ;
32854: LD_VAR 0 3
32858: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32859: LD_INT 0
32861: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32862: LD_VAR 0 2
32866: PPUSH
32867: LD_VAR 0 3
32871: PPUSH
32872: CALL_OW 351
32876: PUSH
32877: LD_VAR 0 2
32881: PPUSH
32882: LD_VAR 0 3
32886: PPUSH
32887: CALL_OW 554
32891: AND
32892: PUSH
32893: LD_VAR 0 2
32897: PPUSH
32898: LD_VAR 0 3
32902: PPUSH
32903: CALL_OW 488
32907: AND
32908: PUSH
32909: LD_VAR 0 2
32913: PPUSH
32914: LD_VAR 0 3
32918: PPUSH
32919: CALL_OW 428
32923: PUSH
32924: LD_INT 1
32926: NEG
32927: EQUAL
32928: AND
32929: IFFALSE 32950
// AddComMoveXY ( bulldozer , x , y ) ;
32931: LD_VAR 0 1
32935: PPUSH
32936: LD_VAR 0 2
32940: PPUSH
32941: LD_VAR 0 3
32945: PPUSH
32946: CALL_OW 171
// end ;
32950: LD_VAR 0 4
32954: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32955: LD_INT 0
32957: PPUSH
32958: PPUSH
32959: PPUSH
32960: PPUSH
32961: PPUSH
32962: PPUSH
32963: PPUSH
// dist := 99999 ;
32964: LD_ADDR_VAR 0 6
32968: PUSH
32969: LD_INT 99999
32971: ST_TO_ADDR
// for i = 1 to list do
32972: LD_ADDR_VAR 0 5
32976: PUSH
32977: DOUBLE
32978: LD_INT 1
32980: DEC
32981: ST_TO_ADDR
32982: LD_VAR 0 3
32986: PUSH
32987: FOR_TO
32988: IFFALSE 33126
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32990: LD_ADDR_VAR 0 7
32994: PUSH
32995: LD_VAR 0 1
32999: PPUSH
33000: LD_VAR 0 2
33004: PPUSH
33005: LD_VAR 0 3
33009: PUSH
33010: LD_VAR 0 5
33014: ARRAY
33015: PUSH
33016: LD_INT 1
33018: ARRAY
33019: PPUSH
33020: LD_VAR 0 3
33024: PUSH
33025: LD_VAR 0 5
33029: ARRAY
33030: PUSH
33031: LD_INT 2
33033: ARRAY
33034: PPUSH
33035: CALL_OW 298
33039: ST_TO_ADDR
// if d = 0 then
33040: LD_VAR 0 7
33044: PUSH
33045: LD_INT 0
33047: EQUAL
33048: IFFALSE 33052
// continue ;
33050: GO 32987
// if d < dist then
33052: LD_VAR 0 7
33056: PUSH
33057: LD_VAR 0 6
33061: LESS
33062: IFFALSE 33124
// begin _x := list [ i ] [ 1 ] ;
33064: LD_ADDR_VAR 0 8
33068: PUSH
33069: LD_VAR 0 3
33073: PUSH
33074: LD_VAR 0 5
33078: ARRAY
33079: PUSH
33080: LD_INT 1
33082: ARRAY
33083: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33084: LD_ADDR_VAR 0 9
33088: PUSH
33089: LD_VAR 0 3
33093: PUSH
33094: LD_VAR 0 5
33098: ARRAY
33099: PUSH
33100: LD_INT 2
33102: ARRAY
33103: ST_TO_ADDR
// _i := i ;
33104: LD_ADDR_VAR 0 10
33108: PUSH
33109: LD_VAR 0 5
33113: ST_TO_ADDR
// dist := d ;
33114: LD_ADDR_VAR 0 6
33118: PUSH
33119: LD_VAR 0 7
33123: ST_TO_ADDR
// end ; end ;
33124: GO 32987
33126: POP
33127: POP
// result := [ _x , _y , _i , dist ] ;
33128: LD_ADDR_VAR 0 4
33132: PUSH
33133: LD_VAR 0 8
33137: PUSH
33138: LD_VAR 0 9
33142: PUSH
33143: LD_VAR 0 10
33147: PUSH
33148: LD_VAR 0 6
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: ST_TO_ADDR
// end ;
33159: LD_VAR 0 4
33163: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33164: LD_INT 0
33166: PPUSH
33167: PPUSH
33168: PPUSH
33169: PPUSH
33170: PPUSH
// for i = 1 to list do
33171: LD_ADDR_VAR 0 5
33175: PUSH
33176: DOUBLE
33177: LD_INT 1
33179: DEC
33180: ST_TO_ADDR
33181: LD_VAR 0 1
33185: PUSH
33186: FOR_TO
33187: IFFALSE 33501
// begin for j = list downto 2 do
33189: LD_ADDR_VAR 0 6
33193: PUSH
33194: DOUBLE
33195: LD_VAR 0 1
33199: INC
33200: ST_TO_ADDR
33201: LD_INT 2
33203: PUSH
33204: FOR_DOWNTO
33205: IFFALSE 33497
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33207: LD_VAR 0 2
33211: PPUSH
33212: LD_VAR 0 3
33216: PPUSH
33217: LD_VAR 0 1
33221: PUSH
33222: LD_VAR 0 6
33226: ARRAY
33227: PUSH
33228: LD_INT 1
33230: ARRAY
33231: PPUSH
33232: LD_VAR 0 1
33236: PUSH
33237: LD_VAR 0 6
33241: ARRAY
33242: PUSH
33243: LD_INT 2
33245: ARRAY
33246: PPUSH
33247: CALL_OW 298
33251: PUSH
33252: LD_VAR 0 2
33256: PPUSH
33257: LD_VAR 0 3
33261: PPUSH
33262: LD_VAR 0 1
33266: PUSH
33267: LD_VAR 0 6
33271: PUSH
33272: LD_INT 1
33274: MINUS
33275: ARRAY
33276: PUSH
33277: LD_INT 1
33279: ARRAY
33280: PPUSH
33281: LD_VAR 0 1
33285: PUSH
33286: LD_VAR 0 6
33290: PUSH
33291: LD_INT 1
33293: MINUS
33294: ARRAY
33295: PUSH
33296: LD_INT 2
33298: ARRAY
33299: PPUSH
33300: CALL_OW 298
33304: LESS
33305: IFFALSE 33495
// begin _x := list [ j ] [ 1 ] ;
33307: LD_ADDR_VAR 0 7
33311: PUSH
33312: LD_VAR 0 1
33316: PUSH
33317: LD_VAR 0 6
33321: ARRAY
33322: PUSH
33323: LD_INT 1
33325: ARRAY
33326: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33327: LD_ADDR_VAR 0 8
33331: PUSH
33332: LD_VAR 0 1
33336: PUSH
33337: LD_VAR 0 6
33341: ARRAY
33342: PUSH
33343: LD_INT 2
33345: ARRAY
33346: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33347: LD_ADDR_VAR 0 1
33351: PUSH
33352: LD_VAR 0 1
33356: PPUSH
33357: LD_VAR 0 6
33361: PPUSH
33362: LD_INT 1
33364: PPUSH
33365: LD_VAR 0 1
33369: PUSH
33370: LD_VAR 0 6
33374: PUSH
33375: LD_INT 1
33377: MINUS
33378: ARRAY
33379: PUSH
33380: LD_INT 1
33382: ARRAY
33383: PPUSH
33384: CALL 31125 0 4
33388: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33389: LD_ADDR_VAR 0 1
33393: PUSH
33394: LD_VAR 0 1
33398: PPUSH
33399: LD_VAR 0 6
33403: PPUSH
33404: LD_INT 2
33406: PPUSH
33407: LD_VAR 0 1
33411: PUSH
33412: LD_VAR 0 6
33416: PUSH
33417: LD_INT 1
33419: MINUS
33420: ARRAY
33421: PUSH
33422: LD_INT 2
33424: ARRAY
33425: PPUSH
33426: CALL 31125 0 4
33430: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33431: LD_ADDR_VAR 0 1
33435: PUSH
33436: LD_VAR 0 1
33440: PPUSH
33441: LD_VAR 0 6
33445: PUSH
33446: LD_INT 1
33448: MINUS
33449: PPUSH
33450: LD_INT 1
33452: PPUSH
33453: LD_VAR 0 7
33457: PPUSH
33458: CALL 31125 0 4
33462: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33463: LD_ADDR_VAR 0 1
33467: PUSH
33468: LD_VAR 0 1
33472: PPUSH
33473: LD_VAR 0 6
33477: PUSH
33478: LD_INT 1
33480: MINUS
33481: PPUSH
33482: LD_INT 2
33484: PPUSH
33485: LD_VAR 0 8
33489: PPUSH
33490: CALL 31125 0 4
33494: ST_TO_ADDR
// end ; end ;
33495: GO 33204
33497: POP
33498: POP
// end ;
33499: GO 33186
33501: POP
33502: POP
// result := list ;
33503: LD_ADDR_VAR 0 4
33507: PUSH
33508: LD_VAR 0 1
33512: ST_TO_ADDR
// end ;
33513: LD_VAR 0 4
33517: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33518: LD_INT 0
33520: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33521: LD_ADDR_VAR 0 5
33525: PUSH
33526: LD_VAR 0 1
33530: PPUSH
33531: LD_VAR 0 2
33535: PPUSH
33536: CALL_OW 546
33540: PUSH
33541: LD_INT 2
33543: ARRAY
33544: PUSH
33545: LD_VAR 0 3
33549: PPUSH
33550: LD_VAR 0 4
33554: PPUSH
33555: CALL_OW 546
33559: PUSH
33560: LD_INT 2
33562: ARRAY
33563: MINUS
33564: ST_TO_ADDR
// if result < 0 then
33565: LD_VAR 0 5
33569: PUSH
33570: LD_INT 0
33572: LESS
33573: IFFALSE 33590
// result := result * - 1 ;
33575: LD_ADDR_VAR 0 5
33579: PUSH
33580: LD_VAR 0 5
33584: PUSH
33585: LD_INT 1
33587: NEG
33588: MUL
33589: ST_TO_ADDR
// end ;
33590: LD_VAR 0 5
33594: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33595: LD_INT 0
33597: PPUSH
33598: PPUSH
// area = ListEnvironmentArea ( area ) ;
33599: LD_ADDR_VAR 0 2
33603: PUSH
33604: LD_VAR 0 2
33608: PPUSH
33609: CALL_OW 353
33613: ST_TO_ADDR
// if bulldozer > 0 then
33614: LD_VAR 0 1
33618: PUSH
33619: LD_INT 0
33621: GREATER
33622: IFFALSE 33733
// for i = area downto 1 do
33624: LD_ADDR_VAR 0 4
33628: PUSH
33629: DOUBLE
33630: LD_VAR 0 2
33634: INC
33635: ST_TO_ADDR
33636: LD_INT 1
33638: PUSH
33639: FOR_DOWNTO
33640: IFFALSE 33731
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33642: LD_VAR 0 2
33646: PUSH
33647: LD_VAR 0 4
33651: ARRAY
33652: PUSH
33653: LD_INT 1
33655: ARRAY
33656: PPUSH
33657: LD_VAR 0 2
33661: PUSH
33662: LD_VAR 0 4
33666: ARRAY
33667: PUSH
33668: LD_INT 2
33670: ARRAY
33671: PPUSH
33672: CALL_OW 351
33676: IFFALSE 33729
// if not HasTask ( bulldozer ) then
33678: LD_VAR 0 1
33682: PPUSH
33683: CALL_OW 314
33687: NOT
33688: IFFALSE 33729
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33690: LD_VAR 0 1
33694: PPUSH
33695: LD_VAR 0 2
33699: PUSH
33700: LD_VAR 0 4
33704: ARRAY
33705: PUSH
33706: LD_INT 1
33708: ARRAY
33709: PPUSH
33710: LD_VAR 0 2
33714: PUSH
33715: LD_VAR 0 4
33719: ARRAY
33720: PUSH
33721: LD_INT 2
33723: ARRAY
33724: PPUSH
33725: CALL_OW 171
33729: GO 33639
33731: POP
33732: POP
// end ;
33733: LD_VAR 0 3
33737: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33738: LD_INT 0
33740: PPUSH
33741: PPUSH
33742: PPUSH
33743: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33744: LD_ADDR_VAR 0 6
33748: PUSH
33749: LD_INT 22
33751: PUSH
33752: LD_VAR 0 1
33756: PUSH
33757: EMPTY
33758: LIST
33759: LIST
33760: PUSH
33761: LD_INT 21
33763: PUSH
33764: LD_VAR 0 2
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PPUSH
33777: CALL_OW 69
33781: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33782: LD_ADDR_VAR 0 7
33786: PUSH
33787: LD_VAR 0 3
33791: PPUSH
33792: LD_INT 22
33794: PUSH
33795: LD_VAR 0 1
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PUSH
33804: LD_INT 21
33806: PUSH
33807: LD_VAR 0 2
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PPUSH
33820: CALL_OW 70
33824: ST_TO_ADDR
// if tmp and pom then
33825: LD_VAR 0 6
33829: PUSH
33830: LD_VAR 0 7
33834: AND
33835: IFFALSE 33855
// result := tmp diff pom else
33837: LD_ADDR_VAR 0 4
33841: PUSH
33842: LD_VAR 0 6
33846: PUSH
33847: LD_VAR 0 7
33851: DIFF
33852: ST_TO_ADDR
33853: GO 33863
// result := false ;
33855: LD_ADDR_VAR 0 4
33859: PUSH
33860: LD_INT 0
33862: ST_TO_ADDR
// end ;
33863: LD_VAR 0 4
33867: RET
// export function SavePosition ( unit ) ; begin
33868: LD_INT 0
33870: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33871: LD_VAR 0 1
33875: PPUSH
33876: LD_VAR 0 1
33880: PPUSH
33881: CALL_OW 250
33885: PPUSH
33886: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33890: LD_VAR 0 1
33894: PPUSH
33895: LD_VAR 0 1
33899: PPUSH
33900: CALL_OW 251
33904: PPUSH
33905: CALL_OW 232
// end ;
33909: LD_VAR 0 2
33913: RET
// export function GetPosition ( unit ) ; begin
33914: LD_INT 0
33916: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33917: LD_ADDR_VAR 0 2
33921: PUSH
33922: LD_VAR 0 1
33926: PPUSH
33927: CALL_OW 252
33931: PUSH
33932: LD_VAR 0 1
33936: PPUSH
33937: CALL_OW 253
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: ST_TO_ADDR
// end ;
33946: LD_VAR 0 2
33950: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33951: LD_INT 0
33953: PPUSH
// if unit in unreachableList then
33954: LD_VAR 0 1
33958: PUSH
33959: LD_EXP 32
33963: IN
33964: IFFALSE 33982
// unreachableList := unreachableList diff unit ;
33966: LD_ADDR_EXP 32
33970: PUSH
33971: LD_EXP 32
33975: PUSH
33976: LD_VAR 0 1
33980: DIFF
33981: ST_TO_ADDR
// if ValidHex ( x , y ) then
33982: LD_VAR 0 2
33986: PPUSH
33987: LD_VAR 0 3
33991: PPUSH
33992: CALL_OW 488
33996: IFFALSE 34022
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
33998: LD_VAR 0 1
34002: PPUSH
34003: LD_VAR 0 2
34007: PPUSH
34008: LD_VAR 0 3
34012: PPUSH
34013: CALL_OW 428
34017: PPUSH
34018: CALL_OW 115
// Wait ( 3 ) ;
34022: LD_INT 3
34024: PPUSH
34025: CALL_OW 67
// if unit in unreachableList then
34029: LD_VAR 0 1
34033: PUSH
34034: LD_EXP 32
34038: IN
34039: IFFALSE 34051
// result := false else
34041: LD_ADDR_VAR 0 4
34045: PUSH
34046: LD_INT 0
34048: ST_TO_ADDR
34049: GO 34059
// result := true ;
34051: LD_ADDR_VAR 0 4
34055: PUSH
34056: LD_INT 1
34058: ST_TO_ADDR
// end ; end_of_file
34059: LD_VAR 0 4
34063: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34064: LD_EXP 33
34068: IFFALSE 34130
34070: GO 34072
34072: DISABLE
34073: LD_INT 0
34075: PPUSH
// begin enable ;
34076: ENABLE
// for i = 1 to mc_crates_list do
34077: LD_ADDR_VAR 0 1
34081: PUSH
34082: DOUBLE
34083: LD_INT 1
34085: DEC
34086: ST_TO_ADDR
34087: LD_EXP 34
34091: PUSH
34092: FOR_TO
34093: IFFALSE 34124
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34095: LD_EXP 34
34099: PUSH
34100: LD_VAR 0 1
34104: ARRAY
34105: PPUSH
34106: LD_INT 5
34108: PPUSH
34109: LD_INT 50
34111: PPUSH
34112: LD_INT 700
34114: PPUSH
34115: LD_INT 20
34117: PPUSH
34118: CALL 24467 0 5
34122: GO 34092
34124: POP
34125: POP
// MC_Game ( ) ;
34126: CALL 34133 0 0
// end ;
34130: PPOPN 1
34132: END
// export function MC_Game ( ) ; var i , side , un ; begin
34133: LD_INT 0
34135: PPUSH
34136: PPUSH
34137: PPUSH
34138: PPUSH
// if not isTest then
34139: LD_EXP 1
34143: NOT
34144: IFFALSE 34164
// MC_Show ( [ #tick , tick ] ) else
34146: LD_STRING #tick
34148: PUSH
34149: LD_OWVAR 1
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PPUSH
34158: CALL 8505 0 1
34162: GO 34173
// MC_Show ( debug_string ) ;
34164: LD_EXP 2
34168: PPUSH
34169: CALL 8505 0 1
// for side = 1 to 8 do
34173: LD_ADDR_VAR 0 3
34177: PUSH
34178: DOUBLE
34179: LD_INT 1
34181: DEC
34182: ST_TO_ADDR
34183: LD_INT 8
34185: PUSH
34186: FOR_TO
34187: IFFALSE 36187
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34189: LD_EXP 41
34193: PUSH
34194: LD_VAR 0 3
34198: ARRAY
34199: PUSH
34200: LD_INT 0
34202: EQUAL
34203: PUSH
34204: LD_VAR 0 3
34208: PPUSH
34209: EMPTY
34210: PPUSH
34211: CALL 11722 0 2
34215: PUSH
34216: LD_INT 0
34218: EQUAL
34219: OR
34220: IFFALSE 34224
// continue ;
34222: GO 34186
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34224: LD_VAR 0 3
34228: PPUSH
34229: LD_VAR 0 3
34233: PPUSH
34234: CALL 24988 0 1
34238: PPUSH
34239: CALL 36194 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34243: LD_EXP 73
34247: PUSH
34248: LD_VAR 0 3
34252: ARRAY
34253: PUSH
34254: LD_INT 1
34256: ARRAY
34257: PUSH
34258: LD_INT 0
34260: GREATER
34261: PUSH
34262: LD_EXP 71
34266: PUSH
34267: LD_VAR 0 3
34271: ARRAY
34272: PUSH
34273: LD_INT 1
34275: ARRAY
34276: PUSH
34277: LD_INT 0
34279: EQUAL
34280: AND
34281: PUSH
34282: LD_VAR 0 3
34286: PPUSH
34287: LD_INT 7
34289: PPUSH
34290: EMPTY
34291: PPUSH
34292: CALL 12290 0 3
34296: NOT
34297: AND
34298: IFFALSE 34369
// begin if side = 1 then
34300: LD_VAR 0 3
34304: PUSH
34305: LD_INT 1
34307: EQUAL
34308: IFFALSE 34317
// RaiseSailEvent ( 101 ) ;
34310: LD_INT 101
34312: PPUSH
34313: CALL_OW 427
// if side = 4 then
34317: LD_VAR 0 3
34321: PUSH
34322: LD_INT 4
34324: EQUAL
34325: IFFALSE 34334
// RaiseSailEvent ( 102 ) ;
34327: LD_INT 102
34329: PPUSH
34330: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34334: LD_ADDR_VAR 0 2
34338: PUSH
34339: LD_EXP 73
34343: PUSH
34344: LD_VAR 0 3
34348: ARRAY
34349: PUSH
34350: FOR_IN
34351: IFFALSE 34367
// SetTag ( i , 7 ) ;
34353: LD_VAR 0 2
34357: PPUSH
34358: LD_INT 7
34360: PPUSH
34361: CALL_OW 109
34365: GO 34350
34367: POP
34368: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34369: LD_VAR 0 3
34373: PPUSH
34374: LD_INT 7
34376: PPUSH
34377: EMPTY
34378: PPUSH
34379: CALL 12290 0 3
34383: IFFALSE 34409
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34385: LD_VAR 0 3
34389: PPUSH
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_INT 7
34397: PPUSH
34398: EMPTY
34399: PPUSH
34400: CALL 12290 0 3
34404: PPUSH
34405: CALL 8432 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34409: LD_VAR 0 3
34413: PPUSH
34414: CALL 17970 0 1
34418: PUSH
34419: LD_VAR 0 3
34423: PPUSH
34424: CALL 11626 0 1
34428: AND
34429: IFFALSE 34440
// MCL_Start ( side ) ;
34431: LD_VAR 0 3
34435: PPUSH
34436: CALL 17927 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34440: LD_ADDR_EXP 37
34444: PUSH
34445: LD_EXP 37
34449: PPUSH
34450: LD_VAR 0 3
34454: PPUSH
34455: LD_VAR 0 3
34459: PPUSH
34460: CALL 19227 0 1
34464: PPUSH
34465: CALL_OW 1
34469: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34470: LD_ADDR_EXP 49
34474: PUSH
34475: LD_EXP 49
34479: PPUSH
34480: LD_VAR 0 3
34484: PPUSH
34485: LD_VAR 0 3
34489: PPUSH
34490: CALL 11040 0 1
34494: PPUSH
34495: CALL_OW 1
34499: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34500: LD_VAR 0 3
34504: PPUSH
34505: LD_INT 21
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PPUSH
34515: CALL 11587 0 2
34519: IFFALSE 34530
// MCV_CheckStatus ( side ) ;
34521: LD_VAR 0 3
34525: PPUSH
34526: CALL 27197 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34530: LD_VAR 0 3
34534: PPUSH
34535: LD_EXP 55
34539: PPUSH
34540: CALL 43114 0 2
34544: IFFALSE 34629
// begin for i = MREG_ToChangeClass downto 1 do
34546: LD_ADDR_VAR 0 2
34550: PUSH
34551: DOUBLE
34552: LD_EXP 55
34556: INC
34557: ST_TO_ADDR
34558: LD_INT 1
34560: PUSH
34561: FOR_DOWNTO
34562: IFFALSE 34627
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34564: LD_EXP 55
34568: PUSH
34569: LD_VAR 0 2
34573: ARRAY
34574: PUSH
34575: LD_INT 1
34577: ARRAY
34578: PUSH
34579: LD_VAR 0 3
34583: EQUAL
34584: IFFALSE 34625
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34586: LD_VAR 0 3
34590: PPUSH
34591: LD_EXP 55
34595: PUSH
34596: LD_VAR 0 2
34600: ARRAY
34601: PUSH
34602: LD_INT 2
34604: ARRAY
34605: PPUSH
34606: LD_EXP 55
34610: PUSH
34611: LD_VAR 0 2
34615: ARRAY
34616: PUSH
34617: LD_INT 3
34619: ARRAY
34620: PPUSH
34621: CALL 16494 0 3
// end ; end ;
34625: GO 34561
34627: POP
34628: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34629: LD_INT 1
34631: PUSH
34632: LD_EXP 40
34636: PUSH
34637: LD_VAR 0 3
34641: ARRAY
34642: IN
34643: IFFALSE 34654
// begin MCN_TrainApe ( side ) ;
34645: LD_VAR 0 3
34649: PPUSH
34650: CALL 18880 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34654: LD_VAR 0 3
34658: PPUSH
34659: LD_INT 30
34661: PUSH
34662: LD_INT 3
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PPUSH
34669: CALL 11587 0 2
34673: IFFALSE 34847
// begin if MCF_Tag ( side , 10 , [ ] ) then
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_INT 10
34682: PPUSH
34683: EMPTY
34684: PPUSH
34685: CALL 12290 0 3
34689: IFFALSE 34736
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34691: LD_VAR 0 3
34695: PPUSH
34696: LD_INT 10
34698: PPUSH
34699: EMPTY
34700: PPUSH
34701: CALL 12290 0 3
34705: PPUSH
34706: LD_VAR 0 3
34710: PPUSH
34711: LD_INT 30
34713: PUSH
34714: LD_INT 3
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PPUSH
34721: CALL 11587 0 2
34725: PUSH
34726: LD_INT 1
34728: ARRAY
34729: PPUSH
34730: CALL_OW 168
// end else
34734: GO 34847
// if MREG_ToConstruct [ side ] then
34736: LD_EXP 53
34740: PUSH
34741: LD_VAR 0 3
34745: ARRAY
34746: IFFALSE 34847
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34748: LD_VAR 0 3
34752: PPUSH
34753: LD_VAR 0 3
34757: PPUSH
34758: LD_INT 30
34760: PUSH
34761: LD_INT 3
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: PPUSH
34768: CALL 11587 0 2
34772: PUSH
34773: LD_INT 1
34775: ARRAY
34776: PPUSH
34777: LD_EXP 53
34781: PUSH
34782: LD_VAR 0 3
34786: ARRAY
34787: PUSH
34788: LD_INT 1
34790: ARRAY
34791: PUSH
34792: LD_EXP 53
34796: PUSH
34797: LD_VAR 0 3
34801: ARRAY
34802: PUSH
34803: LD_INT 2
34805: ARRAY
34806: PUSH
34807: LD_EXP 53
34811: PUSH
34812: LD_VAR 0 3
34816: ARRAY
34817: PUSH
34818: LD_INT 3
34820: ARRAY
34821: PUSH
34822: LD_EXP 53
34826: PUSH
34827: LD_VAR 0 3
34831: ARRAY
34832: PUSH
34833: LD_INT 4
34835: ARRAY
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: LIST
34841: LIST
34842: PPUSH
34843: CALL 25491 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34847: LD_VAR 0 3
34851: PPUSH
34852: LD_INT 30
34854: PUSH
34855: LD_INT 3
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PPUSH
34862: CALL 11587 0 2
34866: PUSH
34867: LD_VAR 0 3
34871: PPUSH
34872: LD_EXP 45
34876: PPUSH
34877: CALL 43114 0 2
34881: AND
34882: PUSH
34883: LD_INT 22
34885: PUSH
34886: LD_VAR 0 3
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 2
34897: PUSH
34898: LD_INT 30
34900: PUSH
34901: LD_INT 33
34903: PUSH
34904: EMPTY
34905: LIST
34906: LIST
34907: PUSH
34908: LD_INT 30
34910: PUSH
34911: LD_INT 32
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: LIST
34922: PUSH
34923: LD_INT 35
34925: PUSH
34926: LD_INT 0
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: LIST
34937: PPUSH
34938: CALL_OW 69
34942: AND
34943: IFFALSE 34954
// MCV_Turret ( side ) ;
34945: LD_VAR 0 3
34949: PPUSH
34950: CALL 25940 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34954: LD_EXP 44
34958: PUSH
34959: LD_VAR 0 3
34963: ARRAY
34964: PUSH
34965: LD_INT 1
34967: GREATER
34968: PUSH
34969: LD_VAR 0 3
34973: PPUSH
34974: CALL 24988 0 1
34978: PUSH
34979: LD_INT 0
34981: EQUAL
34982: AND
34983: IFFALSE 35145
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34985: LD_EXP 44
34989: PUSH
34990: LD_VAR 0 3
34994: ARRAY
34995: PUSH
34996: LD_INT 1
34998: ARRAY
34999: PPUSH
35000: CALL_OW 353
35004: IFFALSE 35042
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35006: LD_EXP 44
35010: PUSH
35011: LD_VAR 0 3
35015: ARRAY
35016: PUSH
35017: LD_INT 2
35019: ARRAY
35020: PPUSH
35021: LD_EXP 44
35025: PUSH
35026: LD_VAR 0 3
35030: ARRAY
35031: PUSH
35032: LD_INT 1
35034: ARRAY
35035: PPUSH
35036: CALL 32423 0 2
35040: GO 35145
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35042: LD_VAR 0 3
35046: PPUSH
35047: LD_INT 30
35049: PUSH
35050: LD_INT 3
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PPUSH
35057: CALL 11587 0 2
35061: IFFALSE 35145
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35063: LD_VAR 0 3
35067: PPUSH
35068: LD_INT 30
35070: PUSH
35071: LD_INT 3
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PPUSH
35078: CALL 11587 0 2
35082: PUSH
35083: LD_INT 1
35085: ARRAY
35086: PPUSH
35087: CALL_OW 461
35091: PUSH
35092: LD_INT 2
35094: EQUAL
35095: IFFALSE 35145
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35097: LD_EXP 44
35101: PUSH
35102: LD_VAR 0 3
35106: ARRAY
35107: PUSH
35108: LD_INT 2
35110: ARRAY
35111: PPUSH
35112: LD_INT 10
35114: PPUSH
35115: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35119: LD_ADDR_EXP 44
35123: PUSH
35124: LD_EXP 44
35128: PPUSH
35129: LD_VAR 0 3
35133: PPUSH
35134: LD_INT 0
35136: PUSH
35137: EMPTY
35138: LIST
35139: PPUSH
35140: CALL_OW 1
35144: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35145: LD_VAR 0 3
35149: PPUSH
35150: LD_INT 33
35152: PUSH
35153: LD_INT 2
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PPUSH
35160: CALL 11587 0 2
35164: IFFALSE 35204
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35166: LD_VAR 0 3
35170: PPUSH
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_INT 33
35178: PUSH
35179: LD_INT 2
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PPUSH
35186: CALL 11587 0 2
35190: PUSH
35191: LD_INT 1
35193: ARRAY
35194: PPUSH
35195: CALL_OW 248
35199: PPUSH
35200: CALL 26494 0 2
// if MREG_ToRepair [ side ] then
35204: LD_EXP 49
35208: PUSH
35209: LD_VAR 0 3
35213: ARRAY
35214: IFFALSE 35227
// begin MCB_Repair ( side ) ;
35216: LD_VAR 0 3
35220: PPUSH
35221: CALL 11327 0 1
// end else
35225: GO 36140
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35227: LD_VAR 0 3
35231: PPUSH
35232: LD_EXP 51
35236: PPUSH
35237: CALL 43114 0 2
35241: PUSH
35242: LD_VAR 0 3
35246: PPUSH
35247: LD_EXP 42
35251: PPUSH
35252: CALL 43114 0 2
35256: AND
35257: IFFALSE 35465
// begin for i = 1 to MREG_ToUpLab do
35259: LD_ADDR_VAR 0 2
35263: PUSH
35264: DOUBLE
35265: LD_INT 1
35267: DEC
35268: ST_TO_ADDR
35269: LD_EXP 51
35273: PUSH
35274: FOR_TO
35275: IFFALSE 35461
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35277: LD_EXP 51
35281: PUSH
35282: LD_VAR 0 2
35286: ARRAY
35287: PUSH
35288: LD_INT 1
35290: ARRAY
35291: PUSH
35292: LD_VAR 0 3
35296: EQUAL
35297: IFFALSE 35459
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35299: LD_EXP 51
35303: PUSH
35304: LD_VAR 0 2
35308: ARRAY
35309: PUSH
35310: LD_INT 2
35312: ARRAY
35313: PUSH
35314: LD_EXP 51
35318: PUSH
35319: LD_VAR 0 2
35323: ARRAY
35324: PUSH
35325: LD_INT 3
35327: ARRAY
35328: AND
35329: IFFALSE 35457
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35331: LD_VAR 0 3
35335: PPUSH
35336: LD_EXP 51
35340: PUSH
35341: LD_VAR 0 2
35345: ARRAY
35346: PUSH
35347: LD_INT 2
35349: ARRAY
35350: PPUSH
35351: LD_EXP 51
35355: PUSH
35356: LD_VAR 0 2
35360: ARRAY
35361: PUSH
35362: LD_INT 3
35364: ARRAY
35365: PPUSH
35366: CALL 8851 0 3
35370: IFFALSE 35457
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35372: LD_ADDR_EXP 51
35376: PUSH
35377: LD_EXP 51
35381: PPUSH
35382: LD_VAR 0 3
35386: PPUSH
35387: LD_EXP 51
35391: PUSH
35392: LD_VAR 0 2
35396: ARRAY
35397: PUSH
35398: LD_INT 2
35400: ARRAY
35401: PPUSH
35402: LD_EXP 51
35406: PUSH
35407: LD_VAR 0 2
35411: ARRAY
35412: PUSH
35413: LD_INT 3
35415: ARRAY
35416: PPUSH
35417: CALL 42166 0 4
35421: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35422: LD_ADDR_EXP 42
35426: PUSH
35427: LD_EXP 42
35431: PPUSH
35432: LD_VAR 0 3
35436: PPUSH
35437: LD_EXP 42
35441: PUSH
35442: LD_INT 1
35444: ARRAY
35445: PUSH
35446: LD_INT 2
35448: ARRAY
35449: PPUSH
35450: EMPTY
35451: PPUSH
35452: CALL 42166 0 4
35456: ST_TO_ADDR
// end ; break ;
35457: GO 35461
// end ;
35459: GO 35274
35461: POP
35462: POP
// end else
35463: GO 36140
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35465: LD_VAR 0 3
35469: PPUSH
35470: LD_EXP 50
35474: PPUSH
35475: CALL 43114 0 2
35479: IFFALSE 35553
// begin for i = 1 to MREG_ToUpdate do
35481: LD_ADDR_VAR 0 2
35485: PUSH
35486: DOUBLE
35487: LD_INT 1
35489: DEC
35490: ST_TO_ADDR
35491: LD_EXP 50
35495: PUSH
35496: FOR_TO
35497: IFFALSE 35549
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35499: LD_EXP 50
35503: PUSH
35504: LD_VAR 0 2
35508: ARRAY
35509: PUSH
35510: LD_INT 1
35512: ARRAY
35513: PUSH
35514: LD_VAR 0 3
35518: EQUAL
35519: IFFALSE 35547
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35521: LD_VAR 0 3
35525: PPUSH
35526: LD_EXP 50
35530: PUSH
35531: LD_VAR 0 2
35535: ARRAY
35536: PUSH
35537: LD_INT 2
35539: ARRAY
35540: PPUSH
35541: CALL 8687 0 2
// break ;
35545: GO 35549
// end ;
35547: GO 35496
35549: POP
35550: POP
// end else
35551: GO 36140
// if MCF_Get ( side , [ f_constructed ] ) then
35553: LD_VAR 0 3
35557: PPUSH
35558: LD_INT 57
35560: PUSH
35561: EMPTY
35562: LIST
35563: PPUSH
35564: CALL 11587 0 2
35568: IFFALSE 35601
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35570: LD_VAR 0 3
35574: PPUSH
35575: LD_VAR 0 3
35579: PPUSH
35580: LD_INT 57
35582: PUSH
35583: EMPTY
35584: LIST
35585: PPUSH
35586: CALL 11587 0 2
35590: PUSH
35591: LD_INT 1
35593: ARRAY
35594: PPUSH
35595: CALL 10931 0 2
35599: GO 36140
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35601: LD_VAR 0 3
35605: PPUSH
35606: LD_EXP 48
35610: PPUSH
35611: CALL 43114 0 2
35615: PUSH
35616: LD_VAR 0 3
35620: PPUSH
35621: CALL_OW 345
35625: NOT
35626: AND
35627: PUSH
35628: LD_VAR 0 3
35632: PPUSH
35633: CALL 24988 0 1
35637: PUSH
35638: LD_INT 0
35640: EQUAL
35641: AND
35642: IFFALSE 36041
// begin for i = 1 to MREG_ToBuild do
35644: LD_ADDR_VAR 0 2
35648: PUSH
35649: DOUBLE
35650: LD_INT 1
35652: DEC
35653: ST_TO_ADDR
35654: LD_EXP 48
35658: PUSH
35659: FOR_TO
35660: IFFALSE 36037
// if MREG_ToBuild [ i ] [ 1 ] = side then
35662: LD_EXP 48
35666: PUSH
35667: LD_VAR 0 2
35671: ARRAY
35672: PUSH
35673: LD_INT 1
35675: ARRAY
35676: PUSH
35677: LD_VAR 0 3
35681: EQUAL
35682: IFFALSE 36035
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35684: LD_OWVAR 84
35688: PUSH
35689: LD_EXP 48
35693: PUSH
35694: LD_VAR 0 2
35698: ARRAY
35699: PUSH
35700: LD_INT 3
35702: ARRAY
35703: PUSH
35704: LD_INT 1
35706: ARRAY
35707: PPUSH
35708: LD_EXP 48
35712: PUSH
35713: LD_VAR 0 2
35717: ARRAY
35718: PUSH
35719: LD_INT 3
35721: ARRAY
35722: PUSH
35723: LD_INT 2
35725: ARRAY
35726: PPUSH
35727: CALL_OW 351
35731: AND
35732: IFFALSE 35776
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35734: LD_EXP 48
35738: PUSH
35739: LD_VAR 0 2
35743: ARRAY
35744: PUSH
35745: LD_INT 3
35747: ARRAY
35748: PUSH
35749: LD_INT 1
35751: ARRAY
35752: PPUSH
35753: LD_EXP 48
35757: PUSH
35758: LD_VAR 0 2
35762: ARRAY
35763: PUSH
35764: LD_INT 3
35766: ARRAY
35767: PUSH
35768: LD_INT 2
35770: ARRAY
35771: PPUSH
35772: CALL 22735 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35776: LD_EXP 48
35780: PUSH
35781: LD_VAR 0 2
35785: ARRAY
35786: PUSH
35787: LD_INT 2
35789: ARRAY
35790: PUSH
35791: LD_INT 0
35793: EQUAL
35794: IFFALSE 35864
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35796: LD_VAR 0 3
35800: PPUSH
35801: LD_EXP 48
35805: PUSH
35806: LD_VAR 0 2
35810: ARRAY
35811: PUSH
35812: LD_INT 3
35814: ARRAY
35815: PUSH
35816: LD_INT 1
35818: ARRAY
35819: PPUSH
35820: LD_EXP 48
35824: PUSH
35825: LD_VAR 0 2
35829: ARRAY
35830: PUSH
35831: LD_INT 3
35833: ARRAY
35834: PUSH
35835: LD_INT 2
35837: ARRAY
35838: PPUSH
35839: LD_EXP 48
35843: PUSH
35844: LD_VAR 0 2
35848: ARRAY
35849: PUSH
35850: LD_INT 3
35852: ARRAY
35853: PUSH
35854: LD_INT 3
35856: ARRAY
35857: PPUSH
35858: CALL 8523 0 4
35862: GO 36033
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35864: LD_EXP 48
35868: PUSH
35869: LD_VAR 0 2
35873: ARRAY
35874: PUSH
35875: LD_INT 2
35877: ARRAY
35878: PUSH
35879: LD_INT 6
35881: EQUAL
35882: IFFALSE 35952
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35884: LD_VAR 0 3
35888: PPUSH
35889: LD_EXP 48
35893: PUSH
35894: LD_VAR 0 2
35898: ARRAY
35899: PUSH
35900: LD_INT 3
35902: ARRAY
35903: PUSH
35904: LD_INT 1
35906: ARRAY
35907: PPUSH
35908: LD_EXP 48
35912: PUSH
35913: LD_VAR 0 2
35917: ARRAY
35918: PUSH
35919: LD_INT 3
35921: ARRAY
35922: PUSH
35923: LD_INT 2
35925: ARRAY
35926: PPUSH
35927: LD_EXP 48
35931: PUSH
35932: LD_VAR 0 2
35936: ARRAY
35937: PUSH
35938: LD_INT 3
35940: ARRAY
35941: PUSH
35942: LD_INT 3
35944: ARRAY
35945: PPUSH
35946: CALL 8652 0 4
35950: GO 36033
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35952: LD_VAR 0 3
35956: PPUSH
35957: LD_EXP 48
35961: PUSH
35962: LD_VAR 0 2
35966: ARRAY
35967: PUSH
35968: LD_INT 2
35970: ARRAY
35971: PPUSH
35972: LD_EXP 48
35976: PUSH
35977: LD_VAR 0 2
35981: ARRAY
35982: PUSH
35983: LD_INT 3
35985: ARRAY
35986: PUSH
35987: LD_INT 1
35989: ARRAY
35990: PPUSH
35991: LD_EXP 48
35995: PUSH
35996: LD_VAR 0 2
36000: ARRAY
36001: PUSH
36002: LD_INT 3
36004: ARRAY
36005: PUSH
36006: LD_INT 2
36008: ARRAY
36009: PPUSH
36010: LD_EXP 48
36014: PUSH
36015: LD_VAR 0 2
36019: ARRAY
36020: PUSH
36021: LD_INT 3
36023: ARRAY
36024: PUSH
36025: LD_INT 3
36027: ARRAY
36028: PPUSH
36029: CALL 10156 0 5
// break ;
36033: GO 36037
// end ;
36035: GO 35659
36037: POP
36038: POP
// end else
36039: GO 36140
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36041: LD_VAR 0 3
36045: PPUSH
36046: LD_EXP 54
36050: PPUSH
36051: CALL 43114 0 2
36055: PUSH
36056: LD_VAR 0 3
36060: PPUSH
36061: CALL 24988 0 1
36065: PUSH
36066: LD_INT 0
36068: EQUAL
36069: AND
36070: IFFALSE 36140
// begin for i = 1 to MREG_ToDismantle do
36072: LD_ADDR_VAR 0 2
36076: PUSH
36077: DOUBLE
36078: LD_INT 1
36080: DEC
36081: ST_TO_ADDR
36082: LD_EXP 54
36086: PUSH
36087: FOR_TO
36088: IFFALSE 36138
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36090: LD_EXP 54
36094: PUSH
36095: LD_VAR 0 2
36099: ARRAY
36100: PUSH
36101: LD_INT 1
36103: ARRAY
36104: PUSH
36105: LD_VAR 0 3
36109: EQUAL
36110: IFFALSE 36136
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36112: LD_VAR 0 3
36116: PPUSH
36117: LD_EXP 54
36121: PUSH
36122: LD_VAR 0 2
36126: ARRAY
36127: PUSH
36128: LD_INT 2
36130: ARRAY
36131: PPUSH
36132: CALL 10822 0 2
// end ;
36136: GO 36087
36138: POP
36139: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36140: LD_VAR 0 3
36144: PPUSH
36145: LD_INT 30
36147: PUSH
36148: LD_INT 1
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PPUSH
36155: CALL 11587 0 2
36159: PUSH
36160: LD_VAR 0 3
36164: PPUSH
36165: CALL 24988 0 1
36169: PUSH
36170: LD_INT 0
36172: EQUAL
36173: AND
36174: IFFALSE 36185
// MCT_CollectCrates ( side ) ;
36176: LD_VAR 0 3
36180: PPUSH
36181: CALL 23927 0 1
// end ;
36185: GO 34186
36187: POP
36188: POP
// end ;
36189: LD_VAR 0 1
36193: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36194: LD_INT 0
36196: PPUSH
36197: PPUSH
36198: PPUSH
36199: PPUSH
36200: PPUSH
36201: PPUSH
36202: PPUSH
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
// all := MCF_All ( side , [ ] ) ;
36211: LD_ADDR_VAR 0 17
36215: PUSH
36216: LD_VAR 0 1
36220: PPUSH
36221: EMPTY
36222: PPUSH
36223: CALL 11722 0 2
36227: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36228: LD_ADDR_VAR 0 13
36232: PUSH
36233: LD_VAR 0 1
36237: PPUSH
36238: LD_INT 1
36240: PPUSH
36241: EMPTY
36242: PPUSH
36243: CALL 11670 0 3
36247: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36248: LD_ADDR_VAR 0 14
36252: PUSH
36253: LD_VAR 0 1
36257: PPUSH
36258: LD_INT 2
36260: PPUSH
36261: EMPTY
36262: PPUSH
36263: CALL 11670 0 3
36267: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36268: LD_ADDR_VAR 0 15
36272: PUSH
36273: LD_VAR 0 1
36277: PPUSH
36278: LD_INT 3
36280: PPUSH
36281: EMPTY
36282: PPUSH
36283: CALL 11670 0 3
36287: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36288: LD_ADDR_VAR 0 16
36292: PUSH
36293: LD_VAR 0 1
36297: PPUSH
36298: LD_INT 4
36300: PPUSH
36301: EMPTY
36302: PPUSH
36303: CALL 11670 0 3
36307: ST_TO_ADDR
// if mech then
36308: LD_VAR 0 15
36312: IFFALSE 36329
// mech := MCF_SortListDesc ( mech ) ;
36314: LD_ADDR_VAR 0 15
36318: PUSH
36319: LD_VAR 0 15
36323: PPUSH
36324: CALL 12836 0 1
36328: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36329: LD_EXP 58
36333: PUSH
36334: LD_VAR 0 1
36338: ARRAY
36339: PUSH
36340: LD_STRING 
36342: EQUAL
36343: NOT
36344: IFFALSE 36400
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36346: LD_EXP 58
36350: PUSH
36351: LD_VAR 0 1
36355: ARRAY
36356: PUSH
36357: LD_INT 1
36359: ARRAY
36360: PPUSH
36361: CALL_OW 257
36365: PUSH
36366: LD_INT 1
36368: EQUAL
36369: IFFALSE 36398
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36371: LD_VAR 0 1
36375: PPUSH
36376: LD_STRING ToArm
36378: PPUSH
36379: LD_EXP 58
36383: PUSH
36384: LD_VAR 0 1
36388: ARRAY
36389: PUSH
36390: LD_INT 1
36392: ARRAY
36393: PPUSH
36394: CALL 14466 0 3
// end else
36398: GO 36426
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36400: LD_ADDR_EXP 58
36404: PUSH
36405: LD_EXP 58
36409: PPUSH
36410: LD_VAR 0 1
36414: PPUSH
36415: LD_INT 1
36417: PPUSH
36418: LD_INT 0
36420: PPUSH
36421: CALL 31125 0 4
36425: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36426: LD_EXP 59
36430: PUSH
36431: LD_VAR 0 1
36435: ARRAY
36436: PUSH
36437: LD_STRING 
36439: EQUAL
36440: NOT
36441: IFFALSE 36497
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36443: LD_EXP 59
36447: PUSH
36448: LD_VAR 0 1
36452: ARRAY
36453: PUSH
36454: LD_INT 1
36456: ARRAY
36457: PPUSH
36458: CALL_OW 257
36462: PUSH
36463: LD_INT 2
36465: EQUAL
36466: IFFALSE 36495
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36468: LD_VAR 0 1
36472: PPUSH
36473: LD_STRING ToDep
36475: PPUSH
36476: LD_EXP 59
36480: PUSH
36481: LD_VAR 0 1
36485: ARRAY
36486: PUSH
36487: LD_INT 1
36489: ARRAY
36490: PPUSH
36491: CALL 14466 0 3
// end else
36495: GO 36523
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36497: LD_ADDR_EXP 59
36501: PUSH
36502: LD_EXP 59
36506: PPUSH
36507: LD_VAR 0 1
36511: PPUSH
36512: LD_INT 1
36514: PPUSH
36515: LD_INT 0
36517: PPUSH
36518: CALL 31125 0 4
36522: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36523: LD_EXP 57
36527: PUSH
36528: LD_VAR 0 1
36532: ARRAY
36533: PUSH
36534: LD_STRING 
36536: EQUAL
36537: NOT
36538: IFFALSE 36594
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36540: LD_EXP 57
36544: PUSH
36545: LD_VAR 0 1
36549: ARRAY
36550: PUSH
36551: LD_INT 1
36553: ARRAY
36554: PPUSH
36555: CALL_OW 257
36559: PUSH
36560: LD_INT 3
36562: EQUAL
36563: IFFALSE 36592
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36565: LD_VAR 0 1
36569: PPUSH
36570: LD_STRING ToFac
36572: PPUSH
36573: LD_EXP 57
36577: PUSH
36578: LD_VAR 0 1
36582: ARRAY
36583: PUSH
36584: LD_INT 1
36586: ARRAY
36587: PPUSH
36588: CALL 14466 0 3
// end else
36592: GO 36620
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36594: LD_ADDR_EXP 57
36598: PUSH
36599: LD_EXP 57
36603: PPUSH
36604: LD_VAR 0 1
36608: PPUSH
36609: LD_INT 1
36611: PPUSH
36612: LD_INT 0
36614: PPUSH
36615: CALL 31125 0 4
36619: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36620: LD_EXP 56
36624: PUSH
36625: LD_VAR 0 1
36629: ARRAY
36630: PUSH
36631: LD_STRING 
36633: EQUAL
36634: NOT
36635: IFFALSE 36691
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36637: LD_EXP 56
36641: PUSH
36642: LD_VAR 0 1
36646: ARRAY
36647: PUSH
36648: LD_INT 1
36650: ARRAY
36651: PPUSH
36652: CALL_OW 257
36656: PUSH
36657: LD_INT 4
36659: EQUAL
36660: IFFALSE 36689
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36662: LD_VAR 0 1
36666: PPUSH
36667: LD_STRING ToLab
36669: PPUSH
36670: LD_EXP 56
36674: PUSH
36675: LD_VAR 0 1
36679: ARRAY
36680: PUSH
36681: LD_INT 1
36683: ARRAY
36684: PPUSH
36685: CALL 14466 0 3
// end else
36689: GO 36717
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36691: LD_ADDR_EXP 56
36695: PUSH
36696: LD_EXP 56
36700: PPUSH
36701: LD_VAR 0 1
36705: PPUSH
36706: LD_INT 1
36708: PPUSH
36709: LD_INT 0
36711: PPUSH
36712: CALL 31125 0 4
36716: ST_TO_ADDR
// if mode = 0 then
36717: LD_VAR 0 2
36721: PUSH
36722: LD_INT 0
36724: EQUAL
36725: IFFALSE 38563
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36727: LD_VAR 0 1
36731: PPUSH
36732: LD_INT 30
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PPUSH
36742: CALL 11587 0 2
36746: PUSH
36747: LD_VAR 0 1
36751: PPUSH
36752: LD_INT 21
36754: PUSH
36755: LD_INT 3
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PPUSH
36762: CALL 11587 0 2
36766: PUSH
36767: LD_INT 1
36769: EQUAL
36770: AND
36771: IFFALSE 36836
// begin if all then
36773: LD_VAR 0 17
36777: IFFALSE 36834
// for i in ( all diff eng ) do
36779: LD_ADDR_VAR 0 4
36783: PUSH
36784: LD_VAR 0 17
36788: PUSH
36789: LD_VAR 0 14
36793: DIFF
36794: PUSH
36795: FOR_IN
36796: IFFALSE 36832
// if GetTag ( i ) = 0 then
36798: LD_VAR 0 4
36802: PPUSH
36803: CALL_OW 110
36807: PUSH
36808: LD_INT 0
36810: EQUAL
36811: IFFALSE 36830
// MCH_ChangeClass ( side , i , 2 ) ;
36813: LD_VAR 0 1
36817: PPUSH
36818: LD_VAR 0 4
36822: PPUSH
36823: LD_INT 2
36825: PPUSH
36826: CALL 16494 0 3
36830: GO 36795
36832: POP
36833: POP
// end else
36834: GO 37155
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36836: LD_VAR 0 13
36840: PUSH
36841: LD_EXP 58
36845: PUSH
36846: LD_VAR 0 1
36850: ARRAY
36851: PLUS
36852: PUSH
36853: LD_INT 22
36855: PUSH
36856: LD_VAR 0 1
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 30
36867: PUSH
36868: LD_INT 32
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PPUSH
36879: CALL_OW 69
36883: LESS
36884: IFFALSE 36909
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36886: LD_VAR 0 1
36890: PPUSH
36891: LD_VAR 0 14
36895: PUSH
36896: LD_INT 1
36898: ARRAY
36899: PPUSH
36900: LD_INT 1
36902: PPUSH
36903: CALL 16494 0 3
// end else
36907: GO 37155
// if sci < 6 and MCF_Lab ( side ) then
36909: LD_VAR 0 16
36913: PUSH
36914: LD_INT 6
36916: LESS
36917: PUSH
36918: LD_VAR 0 1
36922: PPUSH
36923: CALL 11626 0 1
36927: AND
36928: IFFALSE 37033
// begin if MREG_ToBunker [ side ] then
36930: LD_EXP 70
36934: PUSH
36935: LD_VAR 0 1
36939: ARRAY
36940: IFFALSE 36966
// tmp := sol diff MREG_ToBunker [ side ] else
36942: LD_ADDR_VAR 0 12
36946: PUSH
36947: LD_VAR 0 13
36951: PUSH
36952: LD_EXP 70
36956: PUSH
36957: LD_VAR 0 1
36961: ARRAY
36962: DIFF
36963: ST_TO_ADDR
36964: GO 36976
// tmp := sol ;
36966: LD_ADDR_VAR 0 12
36970: PUSH
36971: LD_VAR 0 13
36975: ST_TO_ADDR
// if tmp then
36976: LD_VAR 0 12
36980: IFFALSE 37031
// for i in tmp do
36982: LD_ADDR_VAR 0 4
36986: PUSH
36987: LD_VAR 0 12
36991: PUSH
36992: FOR_IN
36993: IFFALSE 37029
// if GetTag ( i ) = 0 then
36995: LD_VAR 0 4
36999: PPUSH
37000: CALL_OW 110
37004: PUSH
37005: LD_INT 0
37007: EQUAL
37008: IFFALSE 37027
// MCH_ChangeClass ( side , i , 4 ) ;
37010: LD_VAR 0 1
37014: PPUSH
37015: LD_VAR 0 4
37019: PPUSH
37020: LD_INT 4
37022: PPUSH
37023: CALL 16494 0 3
37027: GO 36992
37029: POP
37030: POP
// end else
37031: GO 37155
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37033: LD_VAR 0 1
37037: PPUSH
37038: LD_INT 30
37040: PUSH
37041: LD_INT 1
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PPUSH
37048: CALL 11587 0 2
37052: IFFALSE 37155
// begin if MREG_ToBunker [ side ] then
37054: LD_EXP 70
37058: PUSH
37059: LD_VAR 0 1
37063: ARRAY
37064: IFFALSE 37090
// tmp := sol diff MREG_ToBunker [ side ] else
37066: LD_ADDR_VAR 0 12
37070: PUSH
37071: LD_VAR 0 13
37075: PUSH
37076: LD_EXP 70
37080: PUSH
37081: LD_VAR 0 1
37085: ARRAY
37086: DIFF
37087: ST_TO_ADDR
37088: GO 37100
// tmp := sol ;
37090: LD_ADDR_VAR 0 12
37094: PUSH
37095: LD_VAR 0 13
37099: ST_TO_ADDR
// if tmp then
37100: LD_VAR 0 12
37104: IFFALSE 37155
// for i in tmp do
37106: LD_ADDR_VAR 0 4
37110: PUSH
37111: LD_VAR 0 12
37115: PUSH
37116: FOR_IN
37117: IFFALSE 37153
// if GetTag ( i ) = 0 then
37119: LD_VAR 0 4
37123: PPUSH
37124: CALL_OW 110
37128: PUSH
37129: LD_INT 0
37131: EQUAL
37132: IFFALSE 37151
// MCH_ChangeClass ( side , i , 2 ) ;
37134: LD_VAR 0 1
37138: PPUSH
37139: LD_VAR 0 4
37143: PPUSH
37144: LD_INT 2
37146: PPUSH
37147: CALL 16494 0 3
37151: GO 37116
37153: POP
37154: POP
// end ; if MCF_Lab ( side ) then
37155: LD_VAR 0 1
37159: PPUSH
37160: CALL 11626 0 1
37164: IFFALSE 37704
// begin if MCL_GetTechList ( side ) then
37166: LD_VAR 0 1
37170: PPUSH
37171: CALL 17970 0 1
37175: IFFALSE 37301
// begin if MREG_ToLab [ side ] then
37177: LD_EXP 56
37181: PUSH
37182: LD_VAR 0 1
37186: ARRAY
37187: IFFALSE 37207
// k := MREG_ToLab [ side ] else
37189: LD_ADDR_VAR 0 8
37193: PUSH
37194: LD_EXP 56
37198: PUSH
37199: LD_VAR 0 1
37203: ARRAY
37204: ST_TO_ADDR
37205: GO 37215
// k := 0 ;
37207: LD_ADDR_VAR 0 8
37211: PUSH
37212: LD_INT 0
37214: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37215: LD_VAR 0 16
37219: PUSH
37220: LD_VAR 0 8
37224: PLUS
37225: PUSH
37226: LD_INT 6
37228: LESSEQUAL
37229: PUSH
37230: LD_VAR 0 17
37234: PUSH
37235: LD_INT 6
37237: GREATER
37238: AND
37239: IFFALSE 37255
// MCH_TrainScientist ( side , 1 ) else
37241: LD_VAR 0 1
37245: PPUSH
37246: LD_INT 1
37248: PPUSH
37249: CALL 16046 0 2
37253: GO 37299
// if all < 6 then
37255: LD_VAR 0 17
37259: PUSH
37260: LD_INT 6
37262: LESS
37263: IFFALSE 37299
// if sci + k < all / 2 then
37265: LD_VAR 0 16
37269: PUSH
37270: LD_VAR 0 8
37274: PLUS
37275: PUSH
37276: LD_VAR 0 17
37280: PUSH
37281: LD_INT 2
37283: DIVREAL
37284: LESS
37285: IFFALSE 37299
// MCH_TrainScientist ( side , 1 ) ;
37287: LD_VAR 0 1
37291: PPUSH
37292: LD_INT 1
37294: PPUSH
37295: CALL 16046 0 2
// end else
37299: GO 37377
// begin if sci > 2 then
37301: LD_VAR 0 16
37305: PUSH
37306: LD_INT 2
37308: GREATER
37309: IFFALSE 37377
// for i = sci downto 2 do
37311: LD_ADDR_VAR 0 4
37315: PUSH
37316: DOUBLE
37317: LD_VAR 0 16
37321: INC
37322: ST_TO_ADDR
37323: LD_INT 2
37325: PUSH
37326: FOR_DOWNTO
37327: IFFALSE 37375
// if GetTag ( sci [ i ] ) = 0 then
37329: LD_VAR 0 16
37333: PUSH
37334: LD_VAR 0 4
37338: ARRAY
37339: PPUSH
37340: CALL_OW 110
37344: PUSH
37345: LD_INT 0
37347: EQUAL
37348: IFFALSE 37373
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37350: LD_VAR 0 1
37354: PPUSH
37355: LD_VAR 0 16
37359: PUSH
37360: LD_VAR 0 4
37364: ARRAY
37365: PPUSH
37366: LD_INT 2
37368: PPUSH
37369: CALL 16494 0 3
37373: GO 37326
37375: POP
37376: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37377: LD_VAR 0 1
37381: PPUSH
37382: CALL 17970 0 1
37386: PUSH
37387: LD_VAR 0 1
37391: PPUSH
37392: CALL 11626 0 1
37396: AND
37397: PUSH
37398: LD_EXP 37
37402: PUSH
37403: LD_VAR 0 1
37407: ARRAY
37408: NOT
37409: AND
37410: IFFALSE 37704
// begin for j = 1 to MCF_Lab ( side ) do
37412: LD_ADDR_VAR 0 5
37416: PUSH
37417: DOUBLE
37418: LD_INT 1
37420: DEC
37421: ST_TO_ADDR
37422: LD_VAR 0 1
37426: PPUSH
37427: CALL 11626 0 1
37431: PUSH
37432: FOR_TO
37433: IFFALSE 37493
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37435: LD_VAR 0 1
37439: PPUSH
37440: CALL 11626 0 1
37444: PUSH
37445: LD_VAR 0 5
37449: ARRAY
37450: PPUSH
37451: CALL_OW 461
37455: PUSH
37456: LD_INT 3
37458: PUSH
37459: LD_INT 6
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: IN
37466: IFFALSE 37491
// begin b := MCF_Lab ( side ) [ j ] ;
37468: LD_ADDR_VAR 0 11
37472: PUSH
37473: LD_VAR 0 1
37477: PPUSH
37478: CALL 11626 0 1
37482: PUSH
37483: LD_VAR 0 5
37487: ARRAY
37488: ST_TO_ADDR
// break ;
37489: GO 37493
// end ;
37491: GO 37432
37493: POP
37494: POP
// if MCF_Class ( side , 4 , [ ] ) then
37495: LD_VAR 0 1
37499: PPUSH
37500: LD_INT 4
37502: PPUSH
37503: EMPTY
37504: PPUSH
37505: CALL 11670 0 3
37509: IFFALSE 37704
// for j in MCF_Class ( side , 4 , [ ] ) do
37511: LD_ADDR_VAR 0 5
37515: PUSH
37516: LD_VAR 0 1
37520: PPUSH
37521: LD_INT 4
37523: PPUSH
37524: EMPTY
37525: PPUSH
37526: CALL 11670 0 3
37530: PUSH
37531: FOR_IN
37532: IFFALSE 37702
// begin if GetTag ( j ) = 0 then
37534: LD_VAR 0 5
37538: PPUSH
37539: CALL_OW 110
37543: PUSH
37544: LD_INT 0
37546: EQUAL
37547: IFFALSE 37638
// begin if IsInUnit ( j ) and b then
37549: LD_VAR 0 5
37553: PPUSH
37554: CALL_OW 310
37558: PUSH
37559: LD_VAR 0 11
37563: AND
37564: IFFALSE 37612
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37566: LD_VAR 0 5
37570: PPUSH
37571: CALL_OW 310
37575: PPUSH
37576: CALL_OW 461
37580: PUSH
37581: LD_INT 2
37583: EQUAL
37584: PUSH
37585: LD_VAR 0 5
37589: PPUSH
37590: CALL_OW 310
37594: PUSH
37595: LD_VAR 0 11
37599: NONEQUAL
37600: AND
37601: IFFALSE 37612
// ComExitBuilding ( j ) ;
37603: LD_VAR 0 5
37607: PPUSH
37608: CALL_OW 122
// if not IsInUnit ( j ) then
37612: LD_VAR 0 5
37616: PPUSH
37617: CALL_OW 310
37621: NOT
37622: IFFALSE 37638
// ComEnterUnit ( j , b ) ;
37624: LD_VAR 0 5
37628: PPUSH
37629: LD_VAR 0 11
37633: PPUSH
37634: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37638: LD_INT 1
37640: PPUSH
37641: LD_VAR 0 5
37645: PPUSH
37646: CALL_OW 255
37650: PPUSH
37651: CALL_OW 321
37655: PUSH
37656: LD_INT 2
37658: EQUAL
37659: PUSH
37660: LD_VAR 0 5
37664: PPUSH
37665: CALL_OW 255
37669: PPUSH
37670: CALL 24988 0 1
37674: PUSH
37675: LD_INT 0
37677: EQUAL
37678: AND
37679: IFFALSE 37700
// MCN_Tame ( GetSide ( j ) , j ) ;
37681: LD_VAR 0 5
37685: PPUSH
37686: CALL_OW 255
37690: PPUSH
37691: LD_VAR 0 5
37695: PPUSH
37696: CALL 18489 0 2
// end ;
37700: GO 37531
37702: POP
37703: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37704: LD_VAR 0 1
37708: PPUSH
37709: LD_INT 30
37711: PUSH
37712: LD_INT 3
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PPUSH
37719: CALL 11587 0 2
37723: IFFALSE 37982
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37725: LD_ADDR_VAR 0 11
37729: PUSH
37730: LD_VAR 0 1
37734: PPUSH
37735: LD_INT 30
37737: PUSH
37738: LD_INT 3
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PPUSH
37745: CALL 11587 0 2
37749: PUSH
37750: LD_INT 1
37752: ARRAY
37753: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37754: LD_ADDR_VAR 0 12
37758: PUSH
37759: LD_VAR 0 1
37763: PPUSH
37764: LD_INT 0
37766: PPUSH
37767: LD_INT 25
37769: PUSH
37770: LD_INT 3
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PPUSH
37777: CALL 12290 0 3
37781: ST_TO_ADDR
// for i = 1 to tmp do
37782: LD_ADDR_VAR 0 4
37786: PUSH
37787: DOUBLE
37788: LD_INT 1
37790: DEC
37791: ST_TO_ADDR
37792: LD_VAR 0 12
37796: PUSH
37797: FOR_TO
37798: IFFALSE 37858
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37800: LD_VAR 0 12
37804: PUSH
37805: LD_VAR 0 4
37809: ARRAY
37810: PPUSH
37811: CALL_OW 310
37815: NOT
37816: PUSH
37817: LD_VAR 0 12
37821: PUSH
37822: LD_VAR 0 4
37826: ARRAY
37827: PPUSH
37828: CALL_OW 314
37832: NOT
37833: AND
37834: IFFALSE 37856
// ComEnterUnit ( tmp [ i ] , b ) ;
37836: LD_VAR 0 12
37840: PUSH
37841: LD_VAR 0 4
37845: ARRAY
37846: PPUSH
37847: LD_VAR 0 11
37851: PPUSH
37852: CALL_OW 120
37856: GO 37797
37858: POP
37859: POP
// if MREG_ToFac [ side ] then
37860: LD_EXP 57
37864: PUSH
37865: LD_VAR 0 1
37869: ARRAY
37870: IFFALSE 37890
// k := MREG_ToFac [ side ] else
37872: LD_ADDR_VAR 0 8
37876: PUSH
37877: LD_EXP 57
37881: PUSH
37882: LD_VAR 0 1
37886: ARRAY
37887: ST_TO_ADDR
37888: GO 37898
// k := 0 ;
37890: LD_ADDR_VAR 0 8
37894: PUSH
37895: LD_INT 0
37897: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37898: LD_VAR 0 15
37902: PUSH
37903: LD_VAR 0 8
37907: PLUS
37908: PUSH
37909: LD_INT 6
37911: LESSEQUAL
37912: PUSH
37913: LD_VAR 0 17
37917: PUSH
37918: LD_INT 6
37920: GREATER
37921: AND
37922: IFFALSE 37938
// MCH_TrainMechanic ( side , 1 ) else
37924: LD_VAR 0 1
37928: PPUSH
37929: LD_INT 1
37931: PPUSH
37932: CALL 15788 0 2
37936: GO 37982
// if all < 6 then
37938: LD_VAR 0 17
37942: PUSH
37943: LD_INT 6
37945: LESS
37946: IFFALSE 37982
// if mech + k < all / 2 then
37948: LD_VAR 0 15
37952: PUSH
37953: LD_VAR 0 8
37957: PLUS
37958: PUSH
37959: LD_VAR 0 17
37963: PUSH
37964: LD_INT 2
37966: DIVREAL
37967: LESS
37968: IFFALSE 37982
// MCH_TrainMechanic ( side , 1 ) ;
37970: LD_VAR 0 1
37974: PPUSH
37975: LD_INT 1
37977: PPUSH
37978: CALL 15788 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37982: LD_ADDR_VAR 0 10
37986: PUSH
37987: LD_VAR 0 1
37991: PPUSH
37992: LD_INT 30
37994: PUSH
37995: LD_INT 36
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PPUSH
38002: CALL 11587 0 2
38006: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38007: LD_VAR 0 10
38011: PUSH
38012: LD_VAR 0 15
38016: AND
38017: PUSH
38018: LD_VAR 0 1
38022: PPUSH
38023: LD_INT 3
38025: PPUSH
38026: EMPTY
38027: PPUSH
38028: CALL 11670 0 3
38032: AND
38033: IFFALSE 38191
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38035: LD_VAR 0 1
38039: PPUSH
38040: LD_INT 9
38042: PPUSH
38043: EMPTY
38044: PPUSH
38045: CALL 12290 0 3
38049: PUSH
38050: LD_INT 3
38052: LESS
38053: IFFALSE 38191
// begin if mech < 3 then
38055: LD_VAR 0 15
38059: PUSH
38060: LD_INT 3
38062: LESS
38063: IFFALSE 38077
// k := mech else
38065: LD_ADDR_VAR 0 8
38069: PUSH
38070: LD_VAR 0 15
38074: ST_TO_ADDR
38075: GO 38085
// k := 3 ;
38077: LD_ADDR_VAR 0 8
38081: PUSH
38082: LD_INT 3
38084: ST_TO_ADDR
// for j = 1 to k do
38085: LD_ADDR_VAR 0 5
38089: PUSH
38090: DOUBLE
38091: LD_INT 1
38093: DEC
38094: ST_TO_ADDR
38095: LD_VAR 0 8
38099: PUSH
38100: FOR_TO
38101: IFFALSE 38159
// if GetClass ( mech [ j ] ) = 3 then
38103: LD_VAR 0 15
38107: PUSH
38108: LD_VAR 0 5
38112: ARRAY
38113: PPUSH
38114: CALL_OW 257
38118: PUSH
38119: LD_INT 3
38121: EQUAL
38122: IFFALSE 38157
// begin SetTag ( mech [ j ] , 9 ) ;
38124: LD_VAR 0 15
38128: PUSH
38129: LD_VAR 0 5
38133: ARRAY
38134: PPUSH
38135: LD_INT 9
38137: PPUSH
38138: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38142: LD_VAR 0 15
38146: PUSH
38147: LD_VAR 0 5
38151: ARRAY
38152: PPUSH
38153: CALL_OW 122
// end ;
38157: GO 38100
38159: POP
38160: POP
// if mech < 6 + k then
38161: LD_VAR 0 15
38165: PUSH
38166: LD_INT 6
38168: PUSH
38169: LD_VAR 0 8
38173: PLUS
38174: LESS
38175: IFFALSE 38191
// MCH_TrainMechanic ( side , k ) ;
38177: LD_VAR 0 1
38181: PPUSH
38182: LD_VAR 0 8
38186: PPUSH
38187: CALL 15788 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38191: LD_VAR 0 1
38195: PPUSH
38196: LD_INT 9
38198: PPUSH
38199: EMPTY
38200: PPUSH
38201: CALL 12290 0 3
38205: IFFALSE 38296
// for j in MCF_Tag ( side , 9 , [ ] ) do
38207: LD_ADDR_VAR 0 5
38211: PUSH
38212: LD_VAR 0 1
38216: PPUSH
38217: LD_INT 9
38219: PPUSH
38220: EMPTY
38221: PPUSH
38222: CALL 12290 0 3
38226: PUSH
38227: FOR_IN
38228: IFFALSE 38294
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38230: LD_VAR 0 5
38234: PPUSH
38235: CALL_OW 310
38239: NOT
38240: PUSH
38241: LD_VAR 0 5
38245: PPUSH
38246: CALL 91556 0 1
38250: NOT
38251: AND
38252: IFFALSE 38292
// if ct then
38254: LD_VAR 0 10
38258: IFFALSE 38280
// ComEnterUnit ( j , ct [ 1 ] ) else
38260: LD_VAR 0 5
38264: PPUSH
38265: LD_VAR 0 10
38269: PUSH
38270: LD_INT 1
38272: ARRAY
38273: PPUSH
38274: CALL_OW 120
38278: GO 38292
// SetTag ( j , 0 ) ;
38280: LD_VAR 0 5
38284: PPUSH
38285: LD_INT 0
38287: PPUSH
38288: CALL_OW 109
38292: GO 38227
38294: POP
38295: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38296: LD_INT 1
38298: PPUSH
38299: LD_VAR 0 1
38303: PPUSH
38304: CALL_OW 321
38308: PUSH
38309: LD_INT 2
38311: EQUAL
38312: PUSH
38313: LD_EXP 37
38317: PUSH
38318: LD_VAR 0 1
38322: ARRAY
38323: NOT
38324: AND
38325: PUSH
38326: LD_VAR 0 1
38330: PPUSH
38331: LD_INT 4
38333: PPUSH
38334: EMPTY
38335: PPUSH
38336: CALL 11670 0 3
38340: AND
38341: IFFALSE 38389
// for j in MCF_Class ( side , 4 , [ ] ) do
38343: LD_ADDR_VAR 0 5
38347: PUSH
38348: LD_VAR 0 1
38352: PPUSH
38353: LD_INT 4
38355: PPUSH
38356: EMPTY
38357: PPUSH
38358: CALL 11670 0 3
38362: PUSH
38363: FOR_IN
38364: IFFALSE 38387
// MCN_Tame ( GetSide ( j ) , j ) ;
38366: LD_VAR 0 5
38370: PPUSH
38371: CALL_OW 255
38375: PPUSH
38376: LD_VAR 0 5
38380: PPUSH
38381: CALL 18489 0 2
38385: GO 38363
38387: POP
38388: POP
// if MREG_DefVeh [ side ] then
38389: LD_EXP 69
38393: PUSH
38394: LD_VAR 0 1
38398: ARRAY
38399: IFFALSE 38563
// begin for i in MREG_DefVeh [ side ] do
38401: LD_ADDR_VAR 0 4
38405: PUSH
38406: LD_EXP 69
38410: PUSH
38411: LD_VAR 0 1
38415: ARRAY
38416: PUSH
38417: FOR_IN
38418: IFFALSE 38471
// begin SetTag ( i , 0 ) ;
38420: LD_VAR 0 4
38424: PPUSH
38425: LD_INT 0
38427: PPUSH
38428: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38432: LD_VAR 0 4
38436: PPUSH
38437: LD_EXP 66
38441: PUSH
38442: LD_VAR 0 1
38446: ARRAY
38447: PPUSH
38448: CALL_OW 308
38452: NOT
38453: IFFALSE 38469
// MCV_Parking ( side , i ) ;
38455: LD_VAR 0 1
38459: PPUSH
38460: LD_VAR 0 4
38464: PPUSH
38465: CALL 25748 0 2
// end ;
38469: GO 38417
38471: POP
38472: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38473: LD_VAR 0 1
38477: PPUSH
38478: LD_INT 36
38480: PPUSH
38481: EMPTY
38482: PPUSH
38483: CALL 12290 0 3
38487: IFFALSE 38528
// for i in MCF_Tag ( side , 36 , [ ] ) do
38489: LD_ADDR_VAR 0 4
38493: PUSH
38494: LD_VAR 0 1
38498: PPUSH
38499: LD_INT 36
38501: PPUSH
38502: EMPTY
38503: PPUSH
38504: CALL 12290 0 3
38508: PUSH
38509: FOR_IN
38510: IFFALSE 38526
// SetTag ( i , 0 ) ;
38512: LD_VAR 0 4
38516: PPUSH
38517: LD_INT 0
38519: PPUSH
38520: CALL_OW 109
38524: GO 38509
38526: POP
38527: POP
// if MREG_DefMobActive [ side ] then
38528: LD_EXP 72
38532: PUSH
38533: LD_VAR 0 1
38537: ARRAY
38538: IFFALSE 38563
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38540: LD_ADDR_EXP 72
38544: PUSH
38545: LD_EXP 72
38549: PPUSH
38550: LD_VAR 0 1
38554: PPUSH
38555: LD_INT 0
38557: PPUSH
38558: CALL_OW 1
38562: ST_TO_ADDR
// end ; end ; if mode > 0 then
38563: LD_VAR 0 2
38567: PUSH
38568: LD_INT 0
38570: GREATER
38571: IFFALSE 40586
// begin if tick <= 15 15$00 then
38573: LD_OWVAR 1
38577: PUSH
38578: LD_INT 31500
38580: LESSEQUAL
38581: IFFALSE 39005
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38583: LD_VAR 0 13
38587: PUSH
38588: LD_INT 4
38590: GREATER
38591: PUSH
38592: LD_VAR 0 1
38596: PPUSH
38597: CALL 24988 0 1
38601: PUSH
38602: LD_INT 4
38604: LESS
38605: AND
38606: IFFALSE 38717
// for i in sol do
38608: LD_ADDR_VAR 0 4
38612: PUSH
38613: LD_VAR 0 13
38617: PUSH
38618: FOR_IN
38619: IFFALSE 38715
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38621: LD_ADDR_VAR 0 8
38625: PUSH
38626: LD_VAR 0 1
38630: PPUSH
38631: CALL 24988 0 1
38635: PPUSH
38636: LD_VAR 0 4
38640: PPUSH
38641: CALL_OW 74
38645: ST_TO_ADDR
// if IsInUnit ( i ) then
38646: LD_VAR 0 4
38650: PPUSH
38651: CALL_OW 310
38655: IFFALSE 38666
// ComExitBuilding ( i ) ;
38657: LD_VAR 0 4
38661: PPUSH
38662: CALL_OW 122
// if not HasTask ( i ) and k then
38666: LD_VAR 0 4
38670: PPUSH
38671: CALL_OW 314
38675: NOT
38676: PUSH
38677: LD_VAR 0 8
38681: AND
38682: IFFALSE 38713
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38684: LD_VAR 0 4
38688: PPUSH
38689: LD_VAR 0 8
38693: PPUSH
38694: CALL_OW 250
38698: PPUSH
38699: LD_VAR 0 8
38703: PPUSH
38704: CALL_OW 251
38708: PPUSH
38709: CALL_OW 114
// end ;
38713: GO 38618
38715: POP
38716: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38717: LD_VAR 0 1
38721: PPUSH
38722: LD_INT 30
38724: PUSH
38725: LD_INT 5
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PPUSH
38732: CALL 11587 0 2
38736: IFFALSE 39003
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38738: LD_ADDR_VAR 0 11
38742: PUSH
38743: LD_VAR 0 1
38747: PPUSH
38748: LD_INT 30
38750: PUSH
38751: LD_INT 5
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PPUSH
38758: CALL 11587 0 2
38762: PUSH
38763: LD_INT 1
38765: ARRAY
38766: ST_TO_ADDR
// if mech then
38767: LD_VAR 0 15
38771: IFFALSE 38807
// for i in mech do
38773: LD_ADDR_VAR 0 4
38777: PUSH
38778: LD_VAR 0 15
38782: PUSH
38783: FOR_IN
38784: IFFALSE 38805
// MCH_ChangeClass ( side , i , 1 ) ;
38786: LD_VAR 0 1
38790: PPUSH
38791: LD_VAR 0 4
38795: PPUSH
38796: LD_INT 1
38798: PPUSH
38799: CALL 16494 0 3
38803: GO 38783
38805: POP
38806: POP
// if eng > 1 then
38807: LD_VAR 0 14
38811: PUSH
38812: LD_INT 1
38814: GREATER
38815: IFFALSE 38862
// for i = eng downto 2 do
38817: LD_ADDR_VAR 0 4
38821: PUSH
38822: DOUBLE
38823: LD_VAR 0 14
38827: INC
38828: ST_TO_ADDR
38829: LD_INT 2
38831: PUSH
38832: FOR_DOWNTO
38833: IFFALSE 38860
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38835: LD_VAR 0 1
38839: PPUSH
38840: LD_VAR 0 14
38844: PUSH
38845: LD_VAR 0 4
38849: ARRAY
38850: PPUSH
38851: LD_INT 1
38853: PPUSH
38854: CALL 16494 0 3
38858: GO 38832
38860: POP
38861: POP
// if UnitsInside ( b ) = 6 then
38862: LD_VAR 0 11
38866: PPUSH
38867: CALL_OW 313
38871: PUSH
38872: LD_INT 6
38874: EQUAL
38875: IFFALSE 39003
// begin un := UnitsInside ( b ) [ 1 ] ;
38877: LD_ADDR_VAR 0 9
38881: PUSH
38882: LD_VAR 0 11
38886: PPUSH
38887: CALL_OW 313
38891: PUSH
38892: LD_INT 1
38894: ARRAY
38895: ST_TO_ADDR
// ComExitBuilding ( un ) ;
38896: LD_VAR 0 9
38900: PPUSH
38901: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
38905: LD_VAR 0 1
38909: PPUSH
38910: LD_INT 30
38912: PUSH
38913: LD_INT 5
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PPUSH
38920: CALL 11587 0 2
38924: PUSH
38925: LD_INT 1
38927: GREATER
38928: PUSH
38929: LD_VAR 0 1
38933: PPUSH
38934: CALL 24988 0 1
38938: PUSH
38939: LD_INT 4
38941: GREATEREQUAL
38942: AND
38943: IFFALSE 39003
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
38945: LD_ADDR_VAR 0 8
38949: PUSH
38950: LD_VAR 0 1
38954: PPUSH
38955: LD_INT 30
38957: PUSH
38958: LD_INT 5
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PPUSH
38965: CALL 11587 0 2
38969: PUSH
38970: LD_INT 2
38972: ARRAY
38973: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
38974: LD_VAR 0 8
38978: PPUSH
38979: CALL_OW 313
38983: PUSH
38984: LD_INT 6
38986: LESS
38987: IFFALSE 39003
// AddComEnterUnit ( un , k ) ;
38989: LD_VAR 0 9
38993: PPUSH
38994: LD_VAR 0 8
38998: PPUSH
38999: CALL_OW 180
// end ; end ; end ; end else
39003: GO 40586
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39005: LD_VAR 0 1
39009: PPUSH
39010: LD_INT 1
39012: PPUSH
39013: LD_EXP 67
39017: PUSH
39018: LD_VAR 0 1
39022: ARRAY
39023: PUSH
39024: LD_INT 1
39026: ARRAY
39027: PPUSH
39028: CALL 33738 0 3
39032: IFFALSE 39171
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39034: LD_ADDR_VAR 0 12
39038: PUSH
39039: LD_VAR 0 1
39043: PPUSH
39044: LD_INT 21
39046: PUSH
39047: LD_INT 1
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PPUSH
39054: CALL 11587 0 2
39058: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39059: LD_ADDR_VAR 0 11
39063: PUSH
39064: LD_VAR 0 1
39068: PPUSH
39069: LD_INT 30
39071: PUSH
39072: LD_INT 1
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PPUSH
39079: CALL 11587 0 2
39083: ST_TO_ADDR
// if b then
39084: LD_VAR 0 11
39088: IFFALSE 39171
// for i in tmp do
39090: LD_ADDR_VAR 0 4
39094: PUSH
39095: LD_VAR 0 12
39099: PUSH
39100: FOR_IN
39101: IFFALSE 39169
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39103: LD_VAR 0 4
39107: PPUSH
39108: LD_EXP 67
39112: PUSH
39113: LD_VAR 0 1
39117: ARRAY
39118: PUSH
39119: LD_INT 1
39121: ARRAY
39122: PPUSH
39123: CALL_OW 308
39127: NOT
39128: IFFALSE 39167
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39130: LD_VAR 0 4
39134: PPUSH
39135: LD_VAR 0 11
39139: PUSH
39140: LD_INT 1
39142: ARRAY
39143: PPUSH
39144: CALL_OW 250
39148: PPUSH
39149: LD_VAR 0 11
39153: PUSH
39154: LD_INT 1
39156: ARRAY
39157: PPUSH
39158: CALL_OW 251
39162: PPUSH
39163: CALL_OW 111
39167: GO 39100
39169: POP
39170: POP
// end ; if MREG_DefVeh [ side ] then
39171: LD_EXP 69
39175: PUSH
39176: LD_VAR 0 1
39180: ARRAY
39181: IFFALSE 39749
// begin tmp := [ ] ;
39183: LD_ADDR_VAR 0 12
39187: PUSH
39188: EMPTY
39189: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39190: LD_EXP 72
39194: PUSH
39195: LD_VAR 0 1
39199: ARRAY
39200: PUSH
39201: LD_INT 0
39203: EQUAL
39204: IFFALSE 39344
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39206: LD_ADDR_VAR 0 8
39210: PUSH
39211: LD_VAR 0 1
39215: PPUSH
39216: LD_INT 0
39218: PPUSH
39219: LD_INT 25
39221: PUSH
39222: LD_INT 3
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PPUSH
39229: CALL 12290 0 3
39233: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39234: LD_VAR 0 8
39238: PUSH
39239: LD_EXP 69
39243: PUSH
39244: LD_VAR 0 1
39248: ARRAY
39249: GREATER
39250: IFFALSE 39311
// begin for i = 1 to MREG_DefVeh [ side ] do
39252: LD_ADDR_VAR 0 4
39256: PUSH
39257: DOUBLE
39258: LD_INT 1
39260: DEC
39261: ST_TO_ADDR
39262: LD_EXP 69
39266: PUSH
39267: LD_VAR 0 1
39271: ARRAY
39272: PUSH
39273: FOR_TO
39274: IFFALSE 39307
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39276: LD_ADDR_VAR 0 12
39280: PUSH
39281: LD_VAR 0 12
39285: PPUSH
39286: LD_INT 1
39288: PPUSH
39289: LD_VAR 0 8
39293: PUSH
39294: LD_VAR 0 4
39298: ARRAY
39299: PPUSH
39300: CALL_OW 2
39304: ST_TO_ADDR
39305: GO 39273
39307: POP
39308: POP
// end else
39309: GO 39321
// tmp := k ;
39311: LD_ADDR_VAR 0 12
39315: PUSH
39316: LD_VAR 0 8
39320: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39321: LD_ADDR_EXP 72
39325: PUSH
39326: LD_EXP 72
39330: PPUSH
39331: LD_VAR 0 1
39335: PPUSH
39336: LD_INT 1
39338: PPUSH
39339: CALL_OW 1
39343: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39344: LD_ADDR_VAR 0 4
39348: PUSH
39349: LD_EXP 69
39353: PUSH
39354: LD_VAR 0 1
39358: ARRAY
39359: PUSH
39360: FOR_IN
39361: IFFALSE 39747
// begin if not GetDriver ( i ) then
39363: LD_VAR 0 4
39367: PPUSH
39368: CALL 31768 0 1
39372: NOT
39373: IFFALSE 39448
// begin if tmp then
39375: LD_VAR 0 12
39379: IFFALSE 39446
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39381: LD_VAR 0 12
39385: PUSH
39386: LD_INT 1
39388: ARRAY
39389: PPUSH
39390: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39394: LD_VAR 0 12
39398: PUSH
39399: LD_INT 1
39401: ARRAY
39402: PPUSH
39403: LD_VAR 0 4
39407: PPUSH
39408: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39412: LD_VAR 0 12
39416: PUSH
39417: LD_INT 1
39419: ARRAY
39420: PPUSH
39421: LD_INT 36
39423: PPUSH
39424: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39428: LD_ADDR_VAR 0 12
39432: PUSH
39433: LD_VAR 0 12
39437: PPUSH
39438: LD_INT 1
39440: PPUSH
39441: CALL_OW 3
39445: ST_TO_ADDR
// end ; end else
39446: GO 39745
// begin if GetTag ( i ) = 0 then
39448: LD_VAR 0 4
39452: PPUSH
39453: CALL_OW 110
39457: PUSH
39458: LD_INT 0
39460: EQUAL
39461: IFFALSE 39477
// SetTag ( i , 31 ) else
39463: LD_VAR 0 4
39467: PPUSH
39468: LD_INT 31
39470: PPUSH
39471: CALL_OW 109
39475: GO 39745
// if GetTag ( i ) = 31 then
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL_OW 110
39486: PUSH
39487: LD_INT 31
39489: EQUAL
39490: IFFALSE 39745
// begin if GetFuel ( i ) < 20 then
39492: LD_VAR 0 4
39496: PPUSH
39497: CALL_OW 261
39501: PUSH
39502: LD_INT 20
39504: LESS
39505: IFFALSE 39530
// begin SetTag ( i , 21 ) ;
39507: LD_VAR 0 4
39511: PPUSH
39512: LD_INT 21
39514: PPUSH
39515: CALL_OW 109
// MCV_Refuel ( i ) ;
39519: LD_VAR 0 4
39523: PPUSH
39524: CALL 26285 0 1
// continue ;
39528: GO 39360
// end ; if GetLives ( i ) < 700 then
39530: LD_VAR 0 4
39534: PPUSH
39535: CALL_OW 256
39539: PUSH
39540: LD_INT 700
39542: LESS
39543: IFFALSE 39655
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39545: LD_VAR 0 4
39549: PPUSH
39550: LD_EXP 60
39554: PUSH
39555: LD_VAR 0 1
39559: ARRAY
39560: PPUSH
39561: CALL_OW 308
39565: NOT
39566: IFFALSE 39590
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39568: LD_VAR 0 4
39572: PPUSH
39573: LD_EXP 60
39577: PUSH
39578: LD_VAR 0 1
39582: ARRAY
39583: PPUSH
39584: CALL_OW 113
39588: GO 39653
// if GetDriver ( i ) then
39590: LD_VAR 0 4
39594: PPUSH
39595: CALL 31768 0 1
39599: IFFALSE 39653
// begin k := GetDriver ( i ) ;
39601: LD_ADDR_VAR 0 8
39605: PUSH
39606: LD_VAR 0 4
39610: PPUSH
39611: CALL 31768 0 1
39615: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39616: LD_VAR 0 8
39620: PPUSH
39621: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39625: LD_VAR 0 8
39629: PPUSH
39630: LD_VAR 0 4
39634: PPUSH
39635: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39639: LD_VAR 0 8
39643: PPUSH
39644: LD_VAR 0 4
39648: PPUSH
39649: CALL_OW 180
// end ; end else
39653: GO 39745
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39655: LD_ADDR_VAR 0 8
39659: PUSH
39660: LD_VAR 0 1
39664: PPUSH
39665: CALL 24988 0 1
39669: PPUSH
39670: LD_VAR 0 4
39674: PPUSH
39675: CALL_OW 74
39679: ST_TO_ADDR
// if k then
39680: LD_VAR 0 8
39684: IFFALSE 39702
// ComAttackUnit ( i , k ) else
39686: LD_VAR 0 4
39690: PPUSH
39691: LD_VAR 0 8
39695: PPUSH
39696: CALL_OW 115
39700: GO 39745
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39702: LD_VAR 0 4
39706: PPUSH
39707: LD_EXP 60
39711: PUSH
39712: LD_VAR 0 1
39716: ARRAY
39717: PPUSH
39718: CALL_OW 308
39722: NOT
39723: IFFALSE 39745
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39725: LD_VAR 0 4
39729: PPUSH
39730: LD_EXP 60
39734: PUSH
39735: LD_VAR 0 1
39739: ARRAY
39740: PPUSH
39741: CALL_OW 113
// end ; end ; end ; end ;
39745: GO 39360
39747: POP
39748: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39749: LD_VAR 0 1
39753: PPUSH
39754: LD_INT 30
39756: PUSH
39757: LD_INT 5
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PPUSH
39764: CALL 11587 0 2
39768: IFFALSE 40586
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39770: LD_ADDR_VAR 0 11
39774: PUSH
39775: LD_VAR 0 1
39779: PPUSH
39780: LD_INT 30
39782: PUSH
39783: LD_INT 5
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PPUSH
39790: CALL 11587 0 2
39794: PUSH
39795: LD_INT 1
39797: ARRAY
39798: ST_TO_ADDR
// if eng > 1 then
39799: LD_VAR 0 14
39803: PUSH
39804: LD_INT 1
39806: GREATER
39807: IFFALSE 39854
// for i = eng downto 2 do
39809: LD_ADDR_VAR 0 4
39813: PUSH
39814: DOUBLE
39815: LD_VAR 0 14
39819: INC
39820: ST_TO_ADDR
39821: LD_INT 2
39823: PUSH
39824: FOR_DOWNTO
39825: IFFALSE 39852
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39827: LD_VAR 0 1
39831: PPUSH
39832: LD_VAR 0 14
39836: PUSH
39837: LD_VAR 0 4
39841: ARRAY
39842: PPUSH
39843: LD_INT 1
39845: PPUSH
39846: CALL 16494 0 3
39850: GO 39824
39852: POP
39853: POP
// if sci > 1 then
39854: LD_VAR 0 16
39858: PUSH
39859: LD_INT 1
39861: GREATER
39862: IFFALSE 39909
// for i = sci downto 2 do
39864: LD_ADDR_VAR 0 4
39868: PUSH
39869: DOUBLE
39870: LD_VAR 0 16
39874: INC
39875: ST_TO_ADDR
39876: LD_INT 2
39878: PUSH
39879: FOR_DOWNTO
39880: IFFALSE 39907
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39882: LD_VAR 0 1
39886: PPUSH
39887: LD_VAR 0 16
39891: PUSH
39892: LD_VAR 0 4
39896: ARRAY
39897: PPUSH
39898: LD_INT 1
39900: PPUSH
39901: CALL 16494 0 3
39905: GO 39879
39907: POP
39908: POP
// if sol then
39909: LD_VAR 0 13
39913: IFFALSE 40586
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39915: LD_VAR 0 13
39919: PUSH
39920: LD_EXP 70
39924: PUSH
39925: LD_VAR 0 1
39929: ARRAY
39930: DIFF
39931: PUSH
39932: LD_INT 22
39934: PUSH
39935: LD_VAR 0 1
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 58
39946: PUSH
39947: EMPTY
39948: LIST
39949: PUSH
39950: LD_INT 2
39952: PUSH
39953: LD_INT 30
39955: PUSH
39956: LD_INT 32
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PUSH
39963: LD_INT 30
39965: PUSH
39966: LD_INT 31
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: LIST
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: LIST
39982: PPUSH
39983: CALL_OW 69
39987: PUSH
39988: LD_INT 0
39990: EQUAL
39991: AND
39992: IFFALSE 40586
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39994: LD_ADDR_VAR 0 12
39998: PUSH
39999: LD_VAR 0 13
40003: PUSH
40004: LD_EXP 70
40008: PUSH
40009: LD_VAR 0 1
40013: ARRAY
40014: DIFF
40015: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40016: LD_VAR 0 1
40020: PPUSH
40021: LD_INT 30
40023: PUSH
40024: LD_INT 5
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PPUSH
40031: CALL 11587 0 2
40035: PUSH
40036: LD_INT 1
40038: GREATER
40039: IFFALSE 40070
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40041: LD_ADDR_VAR 0 8
40045: PUSH
40046: LD_VAR 0 1
40050: PPUSH
40051: LD_INT 30
40053: PUSH
40054: LD_INT 5
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PPUSH
40061: CALL 11587 0 2
40065: PUSH
40066: LD_INT 2
40068: ARRAY
40069: ST_TO_ADDR
// for j in tmp do
40070: LD_ADDR_VAR 0 5
40074: PUSH
40075: LD_VAR 0 12
40079: PUSH
40080: FOR_IN
40081: IFFALSE 40584
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40083: LD_VAR 0 5
40087: PUSH
40088: LD_VAR 0 11
40092: PPUSH
40093: CALL_OW 313
40097: IN
40098: PUSH
40099: LD_VAR 0 11
40103: PPUSH
40104: CALL_OW 313
40108: PUSH
40109: LD_INT 6
40111: EQUAL
40112: AND
40113: PUSH
40114: LD_VAR 0 8
40118: AND
40119: PUSH
40120: LD_VAR 0 8
40124: PPUSH
40125: CALL_OW 313
40129: PUSH
40130: LD_INT 6
40132: LESS
40133: AND
40134: IFFALSE 40161
// begin ComExitBuilding ( j ) ;
40136: LD_VAR 0 5
40140: PPUSH
40141: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40145: LD_VAR 0 5
40149: PPUSH
40150: LD_VAR 0 8
40154: PPUSH
40155: CALL_OW 180
// continue ;
40159: GO 40080
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40161: LD_VAR 0 5
40165: PPUSH
40166: CALL_OW 314
40170: NOT
40171: PUSH
40172: LD_VAR 0 5
40176: PPUSH
40177: CALL_OW 110
40181: PUSH
40182: LD_INT 0
40184: EQUAL
40185: AND
40186: PUSH
40187: LD_VAR 0 5
40191: PPUSH
40192: CALL_OW 310
40196: NOT
40197: AND
40198: IFFALSE 40304
// begin if k then
40200: LD_VAR 0 8
40204: IFFALSE 40275
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40206: LD_VAR 0 8
40210: PPUSH
40211: CALL_OW 313
40215: PUSH
40216: LD_VAR 0 11
40220: PPUSH
40221: CALL_OW 313
40225: LESS
40226: IFFALSE 40244
// ComEnterUnit ( j , k ) else
40228: LD_VAR 0 5
40232: PPUSH
40233: LD_VAR 0 8
40237: PPUSH
40238: CALL_OW 120
40242: GO 40273
// if UnitsInside ( b ) < 6 then
40244: LD_VAR 0 11
40248: PPUSH
40249: CALL_OW 313
40253: PUSH
40254: LD_INT 6
40256: LESS
40257: IFFALSE 40273
// ComEnterUnit ( j , b ) ;
40259: LD_VAR 0 5
40263: PPUSH
40264: LD_VAR 0 11
40268: PPUSH
40269: CALL_OW 120
// end else
40273: GO 40304
// if UnitsInside ( b ) < 6 then
40275: LD_VAR 0 11
40279: PPUSH
40280: CALL_OW 313
40284: PUSH
40285: LD_INT 6
40287: LESS
40288: IFFALSE 40304
// ComEnterUnit ( j , b ) ;
40290: LD_VAR 0 5
40294: PPUSH
40295: LD_VAR 0 11
40299: PPUSH
40300: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40304: LD_VAR 0 5
40308: PUSH
40309: LD_VAR 0 1
40313: PPUSH
40314: LD_INT 54
40316: PUSH
40317: EMPTY
40318: LIST
40319: PPUSH
40320: CALL 11587 0 2
40324: IN
40325: PUSH
40326: LD_VAR 0 5
40330: PPUSH
40331: CALL_OW 257
40335: PUSH
40336: LD_INT 1
40338: EQUAL
40339: AND
40340: IFFALSE 40582
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40342: LD_EXP 64
40346: PUSH
40347: LD_VAR 0 1
40351: ARRAY
40352: PUSH
40353: LD_INT 1
40355: ARRAY
40356: PUSH
40357: LD_INT 12
40359: PPUSH
40360: LD_VAR 0 1
40364: PPUSH
40365: CALL_OW 321
40369: PUSH
40370: LD_INT 2
40372: EQUAL
40373: AND
40374: IFFALSE 40422
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40376: LD_VAR 0 1
40380: PPUSH
40381: LD_INT 5
40383: PPUSH
40384: EMPTY
40385: PPUSH
40386: CALL 11670 0 3
40390: PUSH
40391: LD_EXP 64
40395: PUSH
40396: LD_VAR 0 1
40400: ARRAY
40401: PUSH
40402: LD_INT 1
40404: ARRAY
40405: LESS
40406: IFFALSE 40422
// begin SetClass ( j , class_sniper ) ;
40408: LD_VAR 0 5
40412: PPUSH
40413: LD_INT 5
40415: PPUSH
40416: CALL_OW 336
// continue ;
40420: GO 40080
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40422: LD_EXP 64
40426: PUSH
40427: LD_VAR 0 1
40431: ARRAY
40432: PUSH
40433: LD_INT 2
40435: ARRAY
40436: PUSH
40437: LD_INT 41
40439: PPUSH
40440: LD_VAR 0 1
40444: PPUSH
40445: CALL_OW 321
40449: PUSH
40450: LD_INT 2
40452: EQUAL
40453: AND
40454: IFFALSE 40502
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40456: LD_VAR 0 1
40460: PPUSH
40461: LD_INT 8
40463: PPUSH
40464: EMPTY
40465: PPUSH
40466: CALL 11670 0 3
40470: PUSH
40471: LD_EXP 64
40475: PUSH
40476: LD_VAR 0 1
40480: ARRAY
40481: PUSH
40482: LD_INT 2
40484: ARRAY
40485: LESS
40486: IFFALSE 40502
// begin SetClass ( j , class_mortar ) ;
40488: LD_VAR 0 5
40492: PPUSH
40493: LD_INT 8
40495: PPUSH
40496: CALL_OW 336
// continue ;
40500: GO 40080
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40502: LD_EXP 64
40506: PUSH
40507: LD_VAR 0 1
40511: ARRAY
40512: PUSH
40513: LD_INT 3
40515: ARRAY
40516: PUSH
40517: LD_INT 44
40519: PPUSH
40520: LD_VAR 0 1
40524: PPUSH
40525: CALL_OW 321
40529: PUSH
40530: LD_INT 2
40532: EQUAL
40533: AND
40534: IFFALSE 40582
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40536: LD_VAR 0 1
40540: PPUSH
40541: LD_INT 9
40543: PPUSH
40544: EMPTY
40545: PPUSH
40546: CALL 11670 0 3
40550: PUSH
40551: LD_EXP 64
40555: PUSH
40556: LD_VAR 0 1
40560: ARRAY
40561: PUSH
40562: LD_INT 3
40564: ARRAY
40565: LESS
40566: IFFALSE 40582
// begin SetClass ( j , class_bazooker ) ;
40568: LD_VAR 0 5
40572: PPUSH
40573: LD_INT 9
40575: PPUSH
40576: CALL_OW 336
// continue ;
40580: GO 40080
// end ; end ; end ;
40582: GO 40080
40584: POP
40585: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40586: LD_INT 22
40588: PUSH
40589: LD_VAR 0 1
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 58
40600: PUSH
40601: EMPTY
40602: LIST
40603: PUSH
40604: LD_INT 30
40606: PUSH
40607: LD_INT 32
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: LIST
40618: PPUSH
40619: CALL_OW 69
40623: IFFALSE 40773
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40625: LD_ADDR_VAR 0 12
40629: PUSH
40630: LD_INT 22
40632: PUSH
40633: LD_VAR 0 1
40637: PUSH
40638: EMPTY
40639: LIST
40640: LIST
40641: PUSH
40642: LD_INT 58
40644: PUSH
40645: EMPTY
40646: LIST
40647: PUSH
40648: LD_INT 30
40650: PUSH
40651: LD_INT 32
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: LIST
40662: PPUSH
40663: CALL_OW 69
40667: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40668: LD_ADDR_VAR 0 8
40672: PUSH
40673: LD_VAR 0 13
40677: PUSH
40678: LD_EXP 70
40682: PUSH
40683: LD_VAR 0 1
40687: ARRAY
40688: DIFF
40689: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40690: LD_VAR 0 12
40694: PUSH
40695: LD_INT 1
40697: ARRAY
40698: PPUSH
40699: CALL_OW 461
40703: PUSH
40704: LD_INT 2
40706: EQUAL
40707: PUSH
40708: LD_VAR 0 12
40712: PUSH
40713: LD_INT 1
40715: ARRAY
40716: PUSH
40717: LD_EXP 70
40721: PUSH
40722: LD_VAR 0 1
40726: ARRAY
40727: IN
40728: NOT
40729: AND
40730: PUSH
40731: LD_VAR 0 8
40735: AND
40736: IFFALSE 40773
// begin ComExitBuilding ( k [ 1 ] ) ;
40738: LD_VAR 0 8
40742: PUSH
40743: LD_INT 1
40745: ARRAY
40746: PPUSH
40747: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40751: LD_VAR 0 8
40755: PUSH
40756: LD_INT 1
40758: ARRAY
40759: PPUSH
40760: LD_VAR 0 12
40764: PUSH
40765: LD_INT 1
40767: ARRAY
40768: PPUSH
40769: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40773: LD_EXP 37
40777: PUSH
40778: LD_VAR 0 1
40782: ARRAY
40783: IFFALSE 40931
// begin if MCF_Class ( side , 4 , [ ] ) then
40785: LD_VAR 0 1
40789: PPUSH
40790: LD_INT 4
40792: PPUSH
40793: EMPTY
40794: PPUSH
40795: CALL 11670 0 3
40799: IFFALSE 40929
// for j in MCF_Class ( side , 4 , [ ] ) do
40801: LD_ADDR_VAR 0 5
40805: PUSH
40806: LD_VAR 0 1
40810: PPUSH
40811: LD_INT 4
40813: PPUSH
40814: EMPTY
40815: PPUSH
40816: CALL 11670 0 3
40820: PUSH
40821: FOR_IN
40822: IFFALSE 40927
// begin if not GetTag ( j ) = 4 then
40824: LD_VAR 0 5
40828: PPUSH
40829: CALL_OW 110
40833: PUSH
40834: LD_INT 4
40836: EQUAL
40837: NOT
40838: IFFALSE 40874
// begin SetTag ( j , 4 ) ;
40840: LD_VAR 0 5
40844: PPUSH
40845: LD_INT 4
40847: PPUSH
40848: CALL_OW 109
// if IsInUnit ( j ) then
40852: LD_VAR 0 5
40856: PPUSH
40857: CALL_OW 310
40861: IFFALSE 40872
// ComExitBuilding ( j ) ;
40863: LD_VAR 0 5
40867: PPUSH
40868: CALL_OW 122
// end else
40872: GO 40925
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40874: LD_VAR 0 5
40878: PPUSH
40879: LD_EXP 37
40883: PUSH
40884: LD_VAR 0 1
40888: ARRAY
40889: PUSH
40890: LD_INT 1
40892: ARRAY
40893: PPUSH
40894: CALL 91180 0 2
40898: NOT
40899: IFFALSE 40925
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40901: LD_VAR 0 5
40905: PPUSH
40906: LD_EXP 37
40910: PUSH
40911: LD_VAR 0 1
40915: ARRAY
40916: PUSH
40917: LD_INT 1
40919: ARRAY
40920: PPUSH
40921: CALL 19157 0 2
// end ;
40925: GO 40821
40927: POP
40928: POP
// end else
40929: GO 41163
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40931: LD_VAR 0 1
40935: PPUSH
40936: LD_INT 4
40938: PPUSH
40939: EMPTY
40940: PPUSH
40941: CALL 11670 0 3
40945: PUSH
40946: LD_VAR 0 1
40950: PPUSH
40951: LD_INT 4
40953: PPUSH
40954: EMPTY
40955: PPUSH
40956: CALL 12290 0 3
40960: AND
40961: IFFALSE 41163
// for j in MCF_Class ( side , 4 , [ ] ) do
40963: LD_ADDR_VAR 0 5
40967: PUSH
40968: LD_VAR 0 1
40972: PPUSH
40973: LD_INT 4
40975: PPUSH
40976: EMPTY
40977: PPUSH
40978: CALL 11670 0 3
40982: PUSH
40983: FOR_IN
40984: IFFALSE 41161
// begin if GetTag ( j ) = 4 then
40986: LD_VAR 0 5
40990: PPUSH
40991: CALL_OW 110
40995: PUSH
40996: LD_INT 4
40998: EQUAL
40999: IFFALSE 41159
// begin SetTag ( j , 0 ) ;
41001: LD_VAR 0 5
41005: PPUSH
41006: LD_INT 0
41008: PPUSH
41009: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41013: LD_VAR 0 1
41017: PPUSH
41018: CALL 11626 0 1
41022: PUSH
41023: LD_VAR 0 1
41027: PPUSH
41028: CALL 17970 0 1
41032: NOT
41033: AND
41034: IFFALSE 41059
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41036: LD_VAR 0 5
41040: PPUSH
41041: LD_VAR 0 1
41045: PPUSH
41046: CALL 11626 0 1
41050: PUSH
41051: LD_INT 1
41053: ARRAY
41054: PPUSH
41055: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41059: LD_VAR 0 1
41063: PPUSH
41064: CALL 11626 0 1
41068: NOT
41069: PUSH
41070: LD_VAR 0 1
41074: PPUSH
41075: LD_INT 30
41077: PUSH
41078: LD_INT 1
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PPUSH
41085: CALL 11587 0 2
41089: AND
41090: IFFALSE 41159
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41092: LD_VAR 0 5
41096: PPUSH
41097: LD_VAR 0 1
41101: PPUSH
41102: LD_INT 30
41104: PUSH
41105: LD_INT 1
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PPUSH
41112: CALL 11587 0 2
41116: PUSH
41117: LD_INT 1
41119: ARRAY
41120: PPUSH
41121: CALL_OW 250
41125: PPUSH
41126: LD_VAR 0 1
41130: PPUSH
41131: LD_INT 30
41133: PUSH
41134: LD_INT 1
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PPUSH
41141: CALL 11587 0 2
41145: PUSH
41146: LD_INT 1
41148: ARRAY
41149: PPUSH
41150: CALL_OW 251
41154: PPUSH
41155: CALL_OW 111
// end ; end ;
41159: GO 40983
41161: POP
41162: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41163: LD_VAR 0 1
41167: PPUSH
41168: LD_INT 3
41170: PPUSH
41171: EMPTY
41172: PPUSH
41173: CALL 11670 0 3
41177: PUSH
41178: LD_EXP 60
41182: PUSH
41183: LD_VAR 0 1
41187: ARRAY
41188: AND
41189: PUSH
41190: LD_VAR 0 1
41194: PPUSH
41195: LD_INT 6
41197: PPUSH
41198: EMPTY
41199: PPUSH
41200: CALL 12290 0 3
41204: AND
41205: IFFALSE 41736
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41207: LD_ADDR_VAR 0 6
41211: PUSH
41212: LD_EXP 60
41216: PUSH
41217: LD_VAR 0 1
41221: ARRAY
41222: PPUSH
41223: LD_INT 0
41225: PPUSH
41226: CALL_OW 517
41230: PUSH
41231: LD_INT 1
41233: ARRAY
41234: PUSH
41235: LD_INT 1
41237: ARRAY
41238: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41239: LD_ADDR_VAR 0 7
41243: PUSH
41244: LD_EXP 60
41248: PUSH
41249: LD_VAR 0 1
41253: ARRAY
41254: PPUSH
41255: LD_INT 0
41257: PPUSH
41258: CALL_OW 517
41262: PUSH
41263: LD_INT 2
41265: ARRAY
41266: PUSH
41267: LD_INT 1
41269: ARRAY
41270: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41271: LD_VAR 0 1
41275: PPUSH
41276: LD_INT 6
41278: PPUSH
41279: EMPTY
41280: PPUSH
41281: CALL 12290 0 3
41285: IFFALSE 41734
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41287: LD_ADDR_VAR 0 8
41291: PUSH
41292: LD_VAR 0 1
41296: PPUSH
41297: LD_INT 6
41299: PPUSH
41300: EMPTY
41301: PPUSH
41302: CALL 12290 0 3
41306: PUSH
41307: FOR_IN
41308: IFFALSE 41339
// if GetLives ( k ) = 1000 then
41310: LD_VAR 0 8
41314: PPUSH
41315: CALL_OW 256
41319: PUSH
41320: LD_INT 1000
41322: EQUAL
41323: IFFALSE 41337
// SetTag ( k , 0 ) ;
41325: LD_VAR 0 8
41329: PPUSH
41330: LD_INT 0
41332: PPUSH
41333: CALL_OW 109
41337: GO 41307
41339: POP
41340: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41341: LD_VAR 0 1
41345: PPUSH
41346: LD_INT 0
41348: PPUSH
41349: LD_INT 25
41351: PUSH
41352: LD_INT 3
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PPUSH
41359: CALL 12290 0 3
41363: IFFALSE 41427
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41365: LD_ADDR_VAR 0 8
41369: PUSH
41370: LD_VAR 0 4
41374: PPUSH
41375: LD_INT 0
41377: PPUSH
41378: LD_INT 25
41380: PUSH
41381: LD_INT 3
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PPUSH
41388: CALL 12290 0 3
41392: PUSH
41393: FOR_IN
41394: IFFALSE 41425
// if GetTag ( k ) = 0 then
41396: LD_VAR 0 8
41400: PPUSH
41401: CALL_OW 110
41405: PUSH
41406: LD_INT 0
41408: EQUAL
41409: IFFALSE 41423
// begin SetTag ( k , 8 ) ;
41411: LD_VAR 0 8
41415: PPUSH
41416: LD_INT 8
41418: PPUSH
41419: CALL_OW 109
// end ;
41423: GO 41393
41425: POP
41426: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41427: LD_VAR 0 1
41431: PPUSH
41432: LD_INT 6
41434: PPUSH
41435: LD_INT 92
41437: PUSH
41438: LD_VAR 0 6
41442: PUSH
41443: LD_VAR 0 7
41447: PUSH
41448: LD_INT 10
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: PPUSH
41457: CALL 12290 0 3
41461: IFFALSE 41585
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41463: LD_ADDR_VAR 0 5
41467: PUSH
41468: LD_VAR 0 4
41472: PPUSH
41473: LD_INT 6
41475: PPUSH
41476: LD_INT 92
41478: PUSH
41479: LD_VAR 0 6
41483: PUSH
41484: LD_VAR 0 7
41488: PUSH
41489: LD_INT 10
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: LIST
41496: LIST
41497: PPUSH
41498: CALL 12290 0 3
41502: PUSH
41503: FOR_IN
41504: IFFALSE 41583
// begin if not HasTask ( j ) and GetDriver ( j ) then
41506: LD_VAR 0 5
41510: PPUSH
41511: CALL_OW 314
41515: NOT
41516: PUSH
41517: LD_VAR 0 5
41521: PPUSH
41522: CALL 31768 0 1
41526: AND
41527: IFFALSE 41581
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41529: LD_VAR 0 5
41533: PPUSH
41534: CALL 31768 0 1
41538: PPUSH
41539: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41543: LD_VAR 0 5
41547: PPUSH
41548: CALL 31768 0 1
41552: PPUSH
41553: LD_VAR 0 5
41557: PPUSH
41558: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41562: LD_VAR 0 5
41566: PPUSH
41567: CALL 31768 0 1
41571: PPUSH
41572: LD_VAR 0 5
41576: PPUSH
41577: CALL_OW 180
// end ; end ;
41581: GO 41503
41583: POP
41584: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41585: LD_VAR 0 1
41589: PPUSH
41590: LD_INT 6
41592: PPUSH
41593: LD_INT 92
41595: PUSH
41596: LD_VAR 0 6
41600: PUSH
41601: LD_VAR 0 7
41605: PUSH
41606: LD_INT 10
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: PPUSH
41615: CALL 12290 0 3
41619: PUSH
41620: LD_VAR 0 1
41624: PPUSH
41625: LD_INT 8
41627: PPUSH
41628: EMPTY
41629: PPUSH
41630: CALL 12290 0 3
41634: AND
41635: IFFALSE 41734
// for j in MCF_Tag ( side , 8 , [ ] ) do
41637: LD_ADDR_VAR 0 5
41641: PUSH
41642: LD_VAR 0 1
41646: PPUSH
41647: LD_INT 8
41649: PPUSH
41650: EMPTY
41651: PPUSH
41652: CALL 12290 0 3
41656: PUSH
41657: FOR_IN
41658: IFFALSE 41732
// begin if IsInUnit ( j ) then
41660: LD_VAR 0 5
41664: PPUSH
41665: CALL_OW 310
41669: IFFALSE 41682
// ComExitBuilding ( j ) else
41671: LD_VAR 0 5
41675: PPUSH
41676: CALL_OW 122
41680: GO 41730
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41682: LD_VAR 0 5
41686: PPUSH
41687: LD_VAR 0 1
41691: PPUSH
41692: LD_INT 6
41694: PPUSH
41695: LD_INT 92
41697: PUSH
41698: LD_VAR 0 6
41702: PUSH
41703: LD_VAR 0 7
41707: PUSH
41708: LD_INT 10
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: LIST
41715: LIST
41716: PPUSH
41717: CALL 12290 0 3
41721: PUSH
41722: LD_INT 1
41724: ARRAY
41725: PPUSH
41726: CALL_OW 129
// end ;
41730: GO 41657
41732: POP
41733: POP
// end ; end else
41734: GO 41791
// if MCF_Tag ( side , 8 , [ ] ) then
41736: LD_VAR 0 1
41740: PPUSH
41741: LD_INT 8
41743: PPUSH
41744: EMPTY
41745: PPUSH
41746: CALL 12290 0 3
41750: IFFALSE 41791
// for k in MCF_Tag ( side , 8 , [ ] ) do
41752: LD_ADDR_VAR 0 8
41756: PUSH
41757: LD_VAR 0 1
41761: PPUSH
41762: LD_INT 8
41764: PPUSH
41765: EMPTY
41766: PPUSH
41767: CALL 12290 0 3
41771: PUSH
41772: FOR_IN
41773: IFFALSE 41789
// SetTag ( k , 0 ) ;
41775: LD_VAR 0 8
41779: PPUSH
41780: LD_INT 0
41782: PPUSH
41783: CALL_OW 109
41787: GO 41772
41789: POP
41790: POP
// end ; end_of_file
41791: LD_VAR 0 3
41795: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41796: LD_INT 0
41798: PPUSH
// MREG_Game := [ ] ;
41799: LD_ADDR_EXP 35
41803: PUSH
41804: EMPTY
41805: ST_TO_ADDR
// MREG_Crates := [ ] ;
41806: LD_ADDR_EXP 36
41810: PUSH
41811: EMPTY
41812: ST_TO_ADDR
// MREG_Heal := [ ] ;
41813: LD_ADDR_EXP 37
41817: PUSH
41818: EMPTY
41819: ST_TO_ADDR
// MREG_Tame := [ ] ;
41820: LD_ADDR_EXP 39
41824: PUSH
41825: EMPTY
41826: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41827: LD_ADDR_EXP 40
41831: PUSH
41832: EMPTY
41833: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41834: LD_ADDR_EXP 41
41838: PUSH
41839: EMPTY
41840: ST_TO_ADDR
// MREG_LabList := [ ] ;
41841: LD_ADDR_EXP 42
41845: PUSH
41846: EMPTY
41847: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41848: LD_ADDR_EXP 43
41852: PUSH
41853: EMPTY
41854: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41855: LD_ADDR_EXP 44
41859: PUSH
41860: EMPTY
41861: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41862: LD_ADDR_EXP 45
41866: PUSH
41867: EMPTY
41868: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41869: LD_ADDR_EXP 46
41873: PUSH
41874: EMPTY
41875: ST_TO_ADDR
// MREG_Status := [ ] ;
41876: LD_ADDR_EXP 47
41880: PUSH
41881: EMPTY
41882: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41883: LD_ADDR_EXP 48
41887: PUSH
41888: EMPTY
41889: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41890: LD_ADDR_EXP 49
41894: PUSH
41895: EMPTY
41896: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41897: LD_ADDR_EXP 50
41901: PUSH
41902: EMPTY
41903: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41904: LD_ADDR_EXP 51
41908: PUSH
41909: EMPTY
41910: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41911: LD_ADDR_EXP 52
41915: PUSH
41916: EMPTY
41917: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41918: LD_ADDR_EXP 53
41922: PUSH
41923: EMPTY
41924: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41925: LD_ADDR_EXP 54
41929: PUSH
41930: EMPTY
41931: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41932: LD_ADDR_EXP 55
41936: PUSH
41937: EMPTY
41938: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41939: LD_ADDR_EXP 56
41943: PUSH
41944: EMPTY
41945: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41946: LD_ADDR_EXP 57
41950: PUSH
41951: EMPTY
41952: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41953: LD_ADDR_EXP 58
41957: PUSH
41958: EMPTY
41959: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41960: LD_ADDR_EXP 59
41964: PUSH
41965: EMPTY
41966: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41967: LD_ADDR_EXP 63
41971: PUSH
41972: EMPTY
41973: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41974: LD_ADDR_EXP 64
41978: PUSH
41979: EMPTY
41980: ST_TO_ADDR
// MREG_Parking := [ ] ;
41981: LD_ADDR_EXP 60
41985: PUSH
41986: EMPTY
41987: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41988: LD_ADDR_EXP 61
41992: PUSH
41993: EMPTY
41994: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41995: LD_ADDR_EXP 65
41999: PUSH
42000: EMPTY
42001: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42002: LD_ADDR_EXP 66
42006: PUSH
42007: EMPTY
42008: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42009: LD_ADDR_EXP 67
42013: PUSH
42014: EMPTY
42015: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42016: LD_ADDR_EXP 69
42020: PUSH
42021: EMPTY
42022: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42023: LD_ADDR_EXP 70
42027: PUSH
42028: EMPTY
42029: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42030: LD_ADDR_EXP 71
42034: PUSH
42035: EMPTY
42036: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42037: LD_ADDR_EXP 73
42041: PUSH
42042: EMPTY
42043: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42044: LD_ADDR_EXP 72
42048: PUSH
42049: EMPTY
42050: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42051: LD_ADDR_EXP 74
42055: PUSH
42056: LD_INT 300
42058: PUSH
42059: LD_INT 100
42061: PUSH
42062: LD_INT 25
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: LIST
42069: ST_TO_ADDR
// end ;
42070: LD_VAR 0 1
42074: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42075: LD_INT 0
42077: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42078: LD_VAR 0 2
42082: PUSH
42083: LD_VAR 0 3
42087: PUSH
42088: LD_VAR 0 4
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: LIST
42097: PUSH
42098: LD_VAR 0 1
42102: IN
42103: IFFALSE 42117
// result := mreg_list else
42105: LD_ADDR_VAR 0 5
42109: PUSH
42110: LD_VAR 0 1
42114: ST_TO_ADDR
42115: GO 42151
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42117: LD_ADDR_VAR 0 1
42121: PUSH
42122: LD_VAR 0 1
42126: PUSH
42127: LD_VAR 0 2
42131: PUSH
42132: LD_VAR 0 3
42136: PUSH
42137: LD_VAR 0 4
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: LIST
42146: PUSH
42147: EMPTY
42148: LIST
42149: ADD
42150: ST_TO_ADDR
// result := mreg_list ;
42151: LD_ADDR_VAR 0 5
42155: PUSH
42156: LD_VAR 0 1
42160: ST_TO_ADDR
// end ;
42161: LD_VAR 0 5
42165: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42166: LD_INT 0
42168: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42169: LD_VAR 0 2
42173: PUSH
42174: LD_VAR 0 3
42178: PUSH
42179: LD_VAR 0 4
42183: PUSH
42184: EMPTY
42185: LIST
42186: LIST
42187: LIST
42188: PUSH
42189: LD_VAR 0 1
42193: IN
42194: IFFALSE 42232
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42196: LD_ADDR_VAR 0 5
42200: PUSH
42201: LD_VAR 0 1
42205: PUSH
42206: LD_VAR 0 2
42210: PUSH
42211: LD_VAR 0 3
42215: PUSH
42216: LD_VAR 0 4
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: LIST
42225: PUSH
42226: EMPTY
42227: LIST
42228: DIFF
42229: ST_TO_ADDR
42230: GO 42242
// result := mreg_list ;
42232: LD_ADDR_VAR 0 5
42236: PUSH
42237: LD_VAR 0 1
42241: ST_TO_ADDR
// end ;
42242: LD_VAR 0 5
42246: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42247: LD_INT 0
42249: PPUSH
42250: PPUSH
42251: PPUSH
// for j = 1 to 8 do
42252: LD_ADDR_VAR 0 3
42256: PUSH
42257: DOUBLE
42258: LD_INT 1
42260: DEC
42261: ST_TO_ADDR
42262: LD_INT 8
42264: PUSH
42265: FOR_TO
42266: IFFALSE 43107
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42268: LD_VAR 0 3
42272: PPUSH
42273: LD_INT 51
42275: PUSH
42276: EMPTY
42277: LIST
42278: PPUSH
42279: CALL 11587 0 2
42283: PUSH
42284: LD_OWVAR 2
42288: PUSH
42289: LD_VAR 0 3
42293: EQUAL
42294: NOT
42295: AND
42296: IFFALSE 42314
// MREG_SidesList := MREG_SidesList ^ 1 else
42298: LD_ADDR_EXP 41
42302: PUSH
42303: LD_EXP 41
42307: PUSH
42308: LD_INT 1
42310: ADD
42311: ST_TO_ADDR
42312: GO 42328
// MREG_SidesList := MREG_SidesList ^ 0 ;
42314: LD_ADDR_EXP 41
42318: PUSH
42319: LD_EXP 41
42323: PUSH
42324: LD_INT 0
42326: ADD
42327: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42328: LD_VAR 0 3
42332: PPUSH
42333: LD_INT 2
42335: PUSH
42336: LD_INT 34
42338: PUSH
42339: LD_INT 12
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 34
42348: PUSH
42349: LD_INT 32
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 34
42358: PUSH
42359: LD_INT 51
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: LIST
42370: LIST
42371: PUSH
42372: EMPTY
42373: LIST
42374: PPUSH
42375: CALL 11888 0 2
42379: IFFALSE 42480
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42381: LD_ADDR_VAR 0 2
42385: PUSH
42386: LD_VAR 0 3
42390: PPUSH
42391: LD_INT 2
42393: PUSH
42394: LD_INT 34
42396: PUSH
42397: LD_INT 12
42399: PUSH
42400: EMPTY
42401: LIST
42402: LIST
42403: PUSH
42404: LD_INT 34
42406: PUSH
42407: LD_INT 32
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 34
42416: PUSH
42417: LD_INT 51
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: LIST
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PPUSH
42433: CALL 11888 0 2
42437: PUSH
42438: FOR_IN
42439: IFFALSE 42478
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42441: LD_ADDR_EXP 43
42445: PUSH
42446: LD_EXP 43
42450: PPUSH
42451: LD_VAR 0 3
42455: PPUSH
42456: LD_VAR 0 2
42460: PPUSH
42461: LD_VAR 0 2
42465: PPUSH
42466: CALL_OW 264
42470: PPUSH
42471: CALL 42075 0 4
42475: ST_TO_ADDR
42476: GO 42438
42478: POP
42479: POP
// if MCF_Class ( j , 4 , [ ] ) then
42480: LD_VAR 0 3
42484: PPUSH
42485: LD_INT 4
42487: PPUSH
42488: EMPTY
42489: PPUSH
42490: CALL 11670 0 3
42494: IFFALSE 42527
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42496: LD_ADDR_EXP 56
42500: PUSH
42501: LD_EXP 56
42505: PUSH
42506: LD_VAR 0 3
42510: PPUSH
42511: LD_INT 4
42513: PPUSH
42514: EMPTY
42515: PPUSH
42516: CALL 11670 0 3
42520: PUSH
42521: EMPTY
42522: LIST
42523: ADD
42524: ST_TO_ADDR
42525: GO 42544
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42527: LD_ADDR_EXP 56
42531: PUSH
42532: LD_EXP 56
42536: PUSH
42537: LD_INT 0
42539: PUSH
42540: EMPTY
42541: LIST
42542: ADD
42543: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42544: LD_VAR 0 3
42548: PPUSH
42549: LD_INT 3
42551: PPUSH
42552: EMPTY
42553: PPUSH
42554: CALL 11670 0 3
42558: IFFALSE 42591
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42560: LD_ADDR_EXP 57
42564: PUSH
42565: LD_EXP 57
42569: PUSH
42570: LD_VAR 0 3
42574: PPUSH
42575: LD_INT 3
42577: PPUSH
42578: EMPTY
42579: PPUSH
42580: CALL 11670 0 3
42584: PUSH
42585: EMPTY
42586: LIST
42587: ADD
42588: ST_TO_ADDR
42589: GO 42608
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42591: LD_ADDR_EXP 57
42595: PUSH
42596: LD_EXP 57
42600: PUSH
42601: LD_INT 0
42603: PUSH
42604: EMPTY
42605: LIST
42606: ADD
42607: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42608: LD_VAR 0 3
42612: PPUSH
42613: LD_INT 1
42615: PPUSH
42616: EMPTY
42617: PPUSH
42618: CALL 11670 0 3
42622: IFFALSE 42655
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42624: LD_ADDR_EXP 58
42628: PUSH
42629: LD_EXP 58
42633: PUSH
42634: LD_VAR 0 3
42638: PPUSH
42639: LD_INT 1
42641: PPUSH
42642: EMPTY
42643: PPUSH
42644: CALL 11670 0 3
42648: PUSH
42649: EMPTY
42650: LIST
42651: ADD
42652: ST_TO_ADDR
42653: GO 42672
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42655: LD_ADDR_EXP 58
42659: PUSH
42660: LD_EXP 58
42664: PUSH
42665: LD_INT 0
42667: PUSH
42668: EMPTY
42669: LIST
42670: ADD
42671: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42672: LD_VAR 0 3
42676: PPUSH
42677: LD_INT 2
42679: PPUSH
42680: EMPTY
42681: PPUSH
42682: CALL 11670 0 3
42686: IFFALSE 42719
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42688: LD_ADDR_EXP 59
42692: PUSH
42693: LD_EXP 59
42697: PUSH
42698: LD_VAR 0 3
42702: PPUSH
42703: LD_INT 2
42705: PPUSH
42706: EMPTY
42707: PPUSH
42708: CALL 11670 0 3
42712: PUSH
42713: EMPTY
42714: LIST
42715: ADD
42716: ST_TO_ADDR
42717: GO 42736
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42719: LD_ADDR_EXP 59
42723: PUSH
42724: LD_EXP 59
42728: PUSH
42729: LD_INT 0
42731: PUSH
42732: EMPTY
42733: LIST
42734: ADD
42735: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42736: LD_ADDR_EXP 49
42740: PUSH
42741: LD_EXP 49
42745: PUSH
42746: LD_INT 0
42748: PUSH
42749: EMPTY
42750: LIST
42751: ADD
42752: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42753: LD_ADDR_EXP 37
42757: PUSH
42758: LD_EXP 37
42762: PUSH
42763: LD_INT 0
42765: PUSH
42766: EMPTY
42767: LIST
42768: ADD
42769: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42770: LD_ADDR_EXP 39
42774: PUSH
42775: LD_EXP 39
42779: PUSH
42780: LD_INT 0
42782: PUSH
42783: EMPTY
42784: LIST
42785: ADD
42786: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42787: LD_ADDR_EXP 60
42791: PUSH
42792: LD_EXP 60
42796: PUSH
42797: LD_INT 0
42799: PUSH
42800: EMPTY
42801: LIST
42802: ADD
42803: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42804: LD_ADDR_EXP 61
42808: PUSH
42809: LD_EXP 61
42813: PUSH
42814: LD_INT 0
42816: PUSH
42817: EMPTY
42818: LIST
42819: ADD
42820: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42821: LD_ADDR_EXP 53
42825: PUSH
42826: LD_EXP 53
42830: PUSH
42831: LD_INT 0
42833: PUSH
42834: EMPTY
42835: LIST
42836: ADD
42837: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42838: LD_ADDR_EXP 40
42842: PUSH
42843: LD_EXP 40
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: LD_INT 0
42853: PUSH
42854: LD_INT 0
42856: PUSH
42857: LD_INT 0
42859: PUSH
42860: EMPTY
42861: LIST
42862: LIST
42863: LIST
42864: LIST
42865: PUSH
42866: EMPTY
42867: LIST
42868: ADD
42869: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42870: LD_ADDR_EXP 62
42874: PUSH
42875: LD_EXP 62
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: EMPTY
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: EMPTY
42890: LIST
42891: ADD
42892: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42893: LD_ADDR_EXP 63
42897: PUSH
42898: LD_EXP 63
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: EMPTY
42907: LIST
42908: PUSH
42909: EMPTY
42910: LIST
42911: ADD
42912: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42913: LD_ADDR_EXP 44
42917: PUSH
42918: LD_EXP 44
42922: PUSH
42923: LD_INT 0
42925: PUSH
42926: EMPTY
42927: LIST
42928: ADD
42929: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42930: LD_ADDR_EXP 65
42934: PUSH
42935: LD_EXP 65
42939: PUSH
42940: LD_INT 0
42942: PUSH
42943: EMPTY
42944: LIST
42945: ADD
42946: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42947: LD_ADDR_EXP 66
42951: PUSH
42952: LD_EXP 66
42956: PUSH
42957: LD_INT 0
42959: PUSH
42960: EMPTY
42961: LIST
42962: ADD
42963: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42964: LD_ADDR_EXP 67
42968: PUSH
42969: LD_EXP 67
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: EMPTY
42978: LIST
42979: ADD
42980: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42981: LD_ADDR_EXP 68
42985: PUSH
42986: LD_EXP 68
42990: PUSH
42991: LD_INT 0
42993: PUSH
42994: EMPTY
42995: LIST
42996: ADD
42997: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42998: LD_ADDR_EXP 69
43002: PUSH
43003: LD_EXP 69
43007: PUSH
43008: LD_INT 0
43010: PUSH
43011: EMPTY
43012: LIST
43013: ADD
43014: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43015: LD_ADDR_EXP 70
43019: PUSH
43020: LD_EXP 70
43024: PUSH
43025: LD_INT 0
43027: PUSH
43028: EMPTY
43029: LIST
43030: ADD
43031: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43032: LD_ADDR_EXP 71
43036: PUSH
43037: LD_EXP 71
43041: PUSH
43042: LD_INT 0
43044: PUSH
43045: EMPTY
43046: LIST
43047: ADD
43048: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43049: LD_ADDR_EXP 73
43053: PUSH
43054: LD_EXP 73
43058: PUSH
43059: LD_INT 0
43061: PUSH
43062: EMPTY
43063: LIST
43064: ADD
43065: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43066: LD_ADDR_EXP 72
43070: PUSH
43071: LD_EXP 72
43075: PUSH
43076: LD_INT 0
43078: ADD
43079: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43080: LD_ADDR_EXP 64
43084: PUSH
43085: LD_EXP 64
43089: PUSH
43090: LD_INT 0
43092: PUSH
43093: LD_INT 0
43095: PUSH
43096: LD_INT 0
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: LIST
43103: ADD
43104: ST_TO_ADDR
// end ;
43105: GO 42265
43107: POP
43108: POP
// end ;
43109: LD_VAR 0 1
43113: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43114: LD_INT 0
43116: PPUSH
43117: PPUSH
43118: PPUSH
// m := false ;
43119: LD_ADDR_VAR 0 5
43123: PUSH
43124: LD_INT 0
43126: ST_TO_ADDR
// for i = 1 to mreg do
43127: LD_ADDR_VAR 0 4
43131: PUSH
43132: DOUBLE
43133: LD_INT 1
43135: DEC
43136: ST_TO_ADDR
43137: LD_VAR 0 2
43141: PUSH
43142: FOR_TO
43143: IFFALSE 43179
// if mreg [ i ] [ 1 ] = side then
43145: LD_VAR 0 2
43149: PUSH
43150: LD_VAR 0 4
43154: ARRAY
43155: PUSH
43156: LD_INT 1
43158: ARRAY
43159: PUSH
43160: LD_VAR 0 1
43164: EQUAL
43165: IFFALSE 43177
// begin m := true ;
43167: LD_ADDR_VAR 0 5
43171: PUSH
43172: LD_INT 1
43174: ST_TO_ADDR
// break ;
43175: GO 43179
// end ;
43177: GO 43142
43179: POP
43180: POP
// result := m ;
43181: LD_ADDR_VAR 0 3
43185: PUSH
43186: LD_VAR 0 5
43190: ST_TO_ADDR
// end ;
43191: LD_VAR 0 3
43195: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43196: LD_INT 0
43198: PPUSH
43199: PPUSH
43200: PPUSH
// m := 0 ;
43201: LD_ADDR_VAR 0 5
43205: PUSH
43206: LD_INT 0
43208: ST_TO_ADDR
// for i = 1 to mreg do
43209: LD_ADDR_VAR 0 4
43213: PUSH
43214: DOUBLE
43215: LD_INT 1
43217: DEC
43218: ST_TO_ADDR
43219: LD_VAR 0 2
43223: PUSH
43224: FOR_TO
43225: IFFALSE 43265
// if mreg [ i ] [ 1 ] = side then
43227: LD_VAR 0 2
43231: PUSH
43232: LD_VAR 0 4
43236: ARRAY
43237: PUSH
43238: LD_INT 1
43240: ARRAY
43241: PUSH
43242: LD_VAR 0 1
43246: EQUAL
43247: IFFALSE 43263
// begin m := m + 1 ;
43249: LD_ADDR_VAR 0 5
43253: PUSH
43254: LD_VAR 0 5
43258: PUSH
43259: LD_INT 1
43261: PLUS
43262: ST_TO_ADDR
// end ;
43263: GO 43224
43265: POP
43266: POP
// result := m ;
43267: LD_ADDR_VAR 0 3
43271: PUSH
43272: LD_VAR 0 5
43276: ST_TO_ADDR
// end ;
43277: LD_VAR 0 3
43281: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43282: LD_INT 0
43284: PPUSH
43285: PPUSH
// result := 0 ;
43286: LD_ADDR_VAR 0 3
43290: PUSH
43291: LD_INT 0
43293: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43294: LD_ADDR_VAR 0 4
43298: PUSH
43299: DOUBLE
43300: LD_INT 1
43302: DEC
43303: ST_TO_ADDR
43304: LD_EXP 55
43308: PUSH
43309: FOR_TO
43310: IFFALSE 43372
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43312: LD_EXP 55
43316: PUSH
43317: LD_VAR 0 4
43321: ARRAY
43322: PUSH
43323: LD_INT 1
43325: ARRAY
43326: PUSH
43327: LD_VAR 0 1
43331: EQUAL
43332: PUSH
43333: LD_EXP 55
43337: PUSH
43338: LD_VAR 0 4
43342: ARRAY
43343: PUSH
43344: LD_INT 2
43346: ARRAY
43347: PUSH
43348: LD_VAR 0 2
43352: EQUAL
43353: AND
43354: IFFALSE 43370
// begin result := result + 1 ;
43356: LD_ADDR_VAR 0 3
43360: PUSH
43361: LD_VAR 0 3
43365: PUSH
43366: LD_INT 1
43368: PLUS
43369: ST_TO_ADDR
// end ;
43370: GO 43309
43372: POP
43373: POP
// end ; end_of_file
43374: LD_VAR 0 3
43378: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
43379: LD_INT 0
43381: PPUSH
// ar_crane := 88 ;
43382: LD_ADDR_EXP 81
43386: PUSH
43387: LD_INT 88
43389: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43390: LD_ADDR_EXP 76
43394: PUSH
43395: LD_INT 89
43397: ST_TO_ADDR
// us_hack := 99 ;
43398: LD_ADDR_EXP 77
43402: PUSH
43403: LD_INT 99
43405: ST_TO_ADDR
// us_artillery := 97 ;
43406: LD_ADDR_EXP 78
43410: PUSH
43411: LD_INT 97
43413: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43414: LD_ADDR_EXP 79
43418: PUSH
43419: LD_INT 91
43421: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
43422: LD_ADDR_EXP 80
43426: PUSH
43427: LD_INT 92
43429: ST_TO_ADDR
// ru_radar := 98 ;
43430: LD_ADDR_EXP 75
43434: PUSH
43435: LD_INT 98
43437: ST_TO_ADDR
// tech_Artillery := 80 ;
43438: LD_ADDR_EXP 82
43442: PUSH
43443: LD_INT 80
43445: ST_TO_ADDR
// tech_RadMat := 81 ;
43446: LD_ADDR_EXP 83
43450: PUSH
43451: LD_INT 81
43453: ST_TO_ADDR
// tech_BasicTools := 82 ;
43454: LD_ADDR_EXP 84
43458: PUSH
43459: LD_INT 82
43461: ST_TO_ADDR
// tech_Cargo := 83 ;
43462: LD_ADDR_EXP 85
43466: PUSH
43467: LD_INT 83
43469: ST_TO_ADDR
// tech_Track := 84 ;
43470: LD_ADDR_EXP 86
43474: PUSH
43475: LD_INT 84
43477: ST_TO_ADDR
// tech_Crane := 85 ;
43478: LD_ADDR_EXP 87
43482: PUSH
43483: LD_INT 85
43485: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43486: LD_ADDR_EXP 88
43490: PUSH
43491: LD_INT 86
43493: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43494: LD_ADDR_EXP 89
43498: PUSH
43499: LD_INT 87
43501: ST_TO_ADDR
// end ;
43502: LD_VAR 0 1
43506: RET
// every 1 do
43507: GO 43509
43509: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43510: CALL 43379 0 0
43514: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
43515: LD_VAR 0 2
43519: PUSH
43520: LD_INT 100
43522: EQUAL
43523: IFFALSE 44472
// begin if not StreamModeActive then
43525: LD_EXP 90
43529: NOT
43530: IFFALSE 43540
// StreamModeActive := true ;
43532: LD_ADDR_EXP 90
43536: PUSH
43537: LD_INT 1
43539: ST_TO_ADDR
// if p3 = 0 then
43540: LD_VAR 0 3
43544: PUSH
43545: LD_INT 0
43547: EQUAL
43548: IFFALSE 43554
// InitStreamMode ;
43550: CALL 44705 0 0
// if p3 = 1 then
43554: LD_VAR 0 3
43558: PUSH
43559: LD_INT 1
43561: EQUAL
43562: IFFALSE 43572
// sRocket := true ;
43564: LD_ADDR_EXP 95
43568: PUSH
43569: LD_INT 1
43571: ST_TO_ADDR
// if p3 = 2 then
43572: LD_VAR 0 3
43576: PUSH
43577: LD_INT 2
43579: EQUAL
43580: IFFALSE 43590
// sSpeed := true ;
43582: LD_ADDR_EXP 94
43586: PUSH
43587: LD_INT 1
43589: ST_TO_ADDR
// if p3 = 3 then
43590: LD_VAR 0 3
43594: PUSH
43595: LD_INT 3
43597: EQUAL
43598: IFFALSE 43608
// sEngine := true ;
43600: LD_ADDR_EXP 96
43604: PUSH
43605: LD_INT 1
43607: ST_TO_ADDR
// if p3 = 4 then
43608: LD_VAR 0 3
43612: PUSH
43613: LD_INT 4
43615: EQUAL
43616: IFFALSE 43626
// sSpec := true ;
43618: LD_ADDR_EXP 93
43622: PUSH
43623: LD_INT 1
43625: ST_TO_ADDR
// if p3 = 5 then
43626: LD_VAR 0 3
43630: PUSH
43631: LD_INT 5
43633: EQUAL
43634: IFFALSE 43644
// sLevel := true ;
43636: LD_ADDR_EXP 97
43640: PUSH
43641: LD_INT 1
43643: ST_TO_ADDR
// if p3 = 6 then
43644: LD_VAR 0 3
43648: PUSH
43649: LD_INT 6
43651: EQUAL
43652: IFFALSE 43662
// sArmoury := true ;
43654: LD_ADDR_EXP 98
43658: PUSH
43659: LD_INT 1
43661: ST_TO_ADDR
// if p3 = 7 then
43662: LD_VAR 0 3
43666: PUSH
43667: LD_INT 7
43669: EQUAL
43670: IFFALSE 43680
// sRadar := true ;
43672: LD_ADDR_EXP 99
43676: PUSH
43677: LD_INT 1
43679: ST_TO_ADDR
// if p3 = 8 then
43680: LD_VAR 0 3
43684: PUSH
43685: LD_INT 8
43687: EQUAL
43688: IFFALSE 43698
// sBunker := true ;
43690: LD_ADDR_EXP 100
43694: PUSH
43695: LD_INT 1
43697: ST_TO_ADDR
// if p3 = 9 then
43698: LD_VAR 0 3
43702: PUSH
43703: LD_INT 9
43705: EQUAL
43706: IFFALSE 43716
// sHack := true ;
43708: LD_ADDR_EXP 101
43712: PUSH
43713: LD_INT 1
43715: ST_TO_ADDR
// if p3 = 10 then
43716: LD_VAR 0 3
43720: PUSH
43721: LD_INT 10
43723: EQUAL
43724: IFFALSE 43734
// sFire := true ;
43726: LD_ADDR_EXP 102
43730: PUSH
43731: LD_INT 1
43733: ST_TO_ADDR
// if p3 = 11 then
43734: LD_VAR 0 3
43738: PUSH
43739: LD_INT 11
43741: EQUAL
43742: IFFALSE 43752
// sRefresh := true ;
43744: LD_ADDR_EXP 103
43748: PUSH
43749: LD_INT 1
43751: ST_TO_ADDR
// if p3 = 12 then
43752: LD_VAR 0 3
43756: PUSH
43757: LD_INT 12
43759: EQUAL
43760: IFFALSE 43770
// sExp := true ;
43762: LD_ADDR_EXP 104
43766: PUSH
43767: LD_INT 1
43769: ST_TO_ADDR
// if p3 = 13 then
43770: LD_VAR 0 3
43774: PUSH
43775: LD_INT 13
43777: EQUAL
43778: IFFALSE 43788
// sDepot := true ;
43780: LD_ADDR_EXP 105
43784: PUSH
43785: LD_INT 1
43787: ST_TO_ADDR
// if p3 = 14 then
43788: LD_VAR 0 3
43792: PUSH
43793: LD_INT 14
43795: EQUAL
43796: IFFALSE 43806
// sFlag := true ;
43798: LD_ADDR_EXP 106
43802: PUSH
43803: LD_INT 1
43805: ST_TO_ADDR
// if p3 = 15 then
43806: LD_VAR 0 3
43810: PUSH
43811: LD_INT 15
43813: EQUAL
43814: IFFALSE 43824
// sKamikadze := true ;
43816: LD_ADDR_EXP 114
43820: PUSH
43821: LD_INT 1
43823: ST_TO_ADDR
// if p3 = 16 then
43824: LD_VAR 0 3
43828: PUSH
43829: LD_INT 16
43831: EQUAL
43832: IFFALSE 43842
// sTroll := true ;
43834: LD_ADDR_EXP 115
43838: PUSH
43839: LD_INT 1
43841: ST_TO_ADDR
// if p3 = 17 then
43842: LD_VAR 0 3
43846: PUSH
43847: LD_INT 17
43849: EQUAL
43850: IFFALSE 43860
// sSlow := true ;
43852: LD_ADDR_EXP 116
43856: PUSH
43857: LD_INT 1
43859: ST_TO_ADDR
// if p3 = 18 then
43860: LD_VAR 0 3
43864: PUSH
43865: LD_INT 18
43867: EQUAL
43868: IFFALSE 43878
// sLack := true ;
43870: LD_ADDR_EXP 117
43874: PUSH
43875: LD_INT 1
43877: ST_TO_ADDR
// if p3 = 19 then
43878: LD_VAR 0 3
43882: PUSH
43883: LD_INT 19
43885: EQUAL
43886: IFFALSE 43896
// sTank := true ;
43888: LD_ADDR_EXP 119
43892: PUSH
43893: LD_INT 1
43895: ST_TO_ADDR
// if p3 = 20 then
43896: LD_VAR 0 3
43900: PUSH
43901: LD_INT 20
43903: EQUAL
43904: IFFALSE 43914
// sRemote := true ;
43906: LD_ADDR_EXP 120
43910: PUSH
43911: LD_INT 1
43913: ST_TO_ADDR
// if p3 = 21 then
43914: LD_VAR 0 3
43918: PUSH
43919: LD_INT 21
43921: EQUAL
43922: IFFALSE 43932
// sPowell := true ;
43924: LD_ADDR_EXP 121
43928: PUSH
43929: LD_INT 1
43931: ST_TO_ADDR
// if p3 = 22 then
43932: LD_VAR 0 3
43936: PUSH
43937: LD_INT 22
43939: EQUAL
43940: IFFALSE 43950
// sTeleport := true ;
43942: LD_ADDR_EXP 124
43946: PUSH
43947: LD_INT 1
43949: ST_TO_ADDR
// if p3 = 23 then
43950: LD_VAR 0 3
43954: PUSH
43955: LD_INT 23
43957: EQUAL
43958: IFFALSE 43968
// sOilTower := true ;
43960: LD_ADDR_EXP 126
43964: PUSH
43965: LD_INT 1
43967: ST_TO_ADDR
// if p3 = 24 then
43968: LD_VAR 0 3
43972: PUSH
43973: LD_INT 24
43975: EQUAL
43976: IFFALSE 43986
// sShovel := true ;
43978: LD_ADDR_EXP 127
43982: PUSH
43983: LD_INT 1
43985: ST_TO_ADDR
// if p3 = 25 then
43986: LD_VAR 0 3
43990: PUSH
43991: LD_INT 25
43993: EQUAL
43994: IFFALSE 44004
// sSheik := true ;
43996: LD_ADDR_EXP 128
44000: PUSH
44001: LD_INT 1
44003: ST_TO_ADDR
// if p3 = 26 then
44004: LD_VAR 0 3
44008: PUSH
44009: LD_INT 26
44011: EQUAL
44012: IFFALSE 44022
// sEarthquake := true ;
44014: LD_ADDR_EXP 130
44018: PUSH
44019: LD_INT 1
44021: ST_TO_ADDR
// if p3 = 27 then
44022: LD_VAR 0 3
44026: PUSH
44027: LD_INT 27
44029: EQUAL
44030: IFFALSE 44040
// sAI := true ;
44032: LD_ADDR_EXP 131
44036: PUSH
44037: LD_INT 1
44039: ST_TO_ADDR
// if p3 = 28 then
44040: LD_VAR 0 3
44044: PUSH
44045: LD_INT 28
44047: EQUAL
44048: IFFALSE 44058
// sCargo := true ;
44050: LD_ADDR_EXP 134
44054: PUSH
44055: LD_INT 1
44057: ST_TO_ADDR
// if p3 = 29 then
44058: LD_VAR 0 3
44062: PUSH
44063: LD_INT 29
44065: EQUAL
44066: IFFALSE 44076
// sDLaser := true ;
44068: LD_ADDR_EXP 135
44072: PUSH
44073: LD_INT 1
44075: ST_TO_ADDR
// if p3 = 30 then
44076: LD_VAR 0 3
44080: PUSH
44081: LD_INT 30
44083: EQUAL
44084: IFFALSE 44094
// sExchange := true ;
44086: LD_ADDR_EXP 136
44090: PUSH
44091: LD_INT 1
44093: ST_TO_ADDR
// if p3 = 31 then
44094: LD_VAR 0 3
44098: PUSH
44099: LD_INT 31
44101: EQUAL
44102: IFFALSE 44112
// sFac := true ;
44104: LD_ADDR_EXP 137
44108: PUSH
44109: LD_INT 1
44111: ST_TO_ADDR
// if p3 = 32 then
44112: LD_VAR 0 3
44116: PUSH
44117: LD_INT 32
44119: EQUAL
44120: IFFALSE 44130
// sPower := true ;
44122: LD_ADDR_EXP 138
44126: PUSH
44127: LD_INT 1
44129: ST_TO_ADDR
// if p3 = 33 then
44130: LD_VAR 0 3
44134: PUSH
44135: LD_INT 33
44137: EQUAL
44138: IFFALSE 44148
// sRandom := true ;
44140: LD_ADDR_EXP 139
44144: PUSH
44145: LD_INT 1
44147: ST_TO_ADDR
// if p3 = 34 then
44148: LD_VAR 0 3
44152: PUSH
44153: LD_INT 34
44155: EQUAL
44156: IFFALSE 44166
// sShield := true ;
44158: LD_ADDR_EXP 140
44162: PUSH
44163: LD_INT 1
44165: ST_TO_ADDR
// if p3 = 35 then
44166: LD_VAR 0 3
44170: PUSH
44171: LD_INT 35
44173: EQUAL
44174: IFFALSE 44184
// sTime := true ;
44176: LD_ADDR_EXP 141
44180: PUSH
44181: LD_INT 1
44183: ST_TO_ADDR
// if p3 = 36 then
44184: LD_VAR 0 3
44188: PUSH
44189: LD_INT 36
44191: EQUAL
44192: IFFALSE 44202
// sTools := true ;
44194: LD_ADDR_EXP 142
44198: PUSH
44199: LD_INT 1
44201: ST_TO_ADDR
// if p3 = 101 then
44202: LD_VAR 0 3
44206: PUSH
44207: LD_INT 101
44209: EQUAL
44210: IFFALSE 44220
// sSold := true ;
44212: LD_ADDR_EXP 107
44216: PUSH
44217: LD_INT 1
44219: ST_TO_ADDR
// if p3 = 102 then
44220: LD_VAR 0 3
44224: PUSH
44225: LD_INT 102
44227: EQUAL
44228: IFFALSE 44238
// sDiff := true ;
44230: LD_ADDR_EXP 108
44234: PUSH
44235: LD_INT 1
44237: ST_TO_ADDR
// if p3 = 103 then
44238: LD_VAR 0 3
44242: PUSH
44243: LD_INT 103
44245: EQUAL
44246: IFFALSE 44256
// sFog := true ;
44248: LD_ADDR_EXP 111
44252: PUSH
44253: LD_INT 1
44255: ST_TO_ADDR
// if p3 = 104 then
44256: LD_VAR 0 3
44260: PUSH
44261: LD_INT 104
44263: EQUAL
44264: IFFALSE 44274
// sReset := true ;
44266: LD_ADDR_EXP 112
44270: PUSH
44271: LD_INT 1
44273: ST_TO_ADDR
// if p3 = 105 then
44274: LD_VAR 0 3
44278: PUSH
44279: LD_INT 105
44281: EQUAL
44282: IFFALSE 44292
// sSun := true ;
44284: LD_ADDR_EXP 113
44288: PUSH
44289: LD_INT 1
44291: ST_TO_ADDR
// if p3 = 106 then
44292: LD_VAR 0 3
44296: PUSH
44297: LD_INT 106
44299: EQUAL
44300: IFFALSE 44310
// sTiger := true ;
44302: LD_ADDR_EXP 109
44306: PUSH
44307: LD_INT 1
44309: ST_TO_ADDR
// if p3 = 107 then
44310: LD_VAR 0 3
44314: PUSH
44315: LD_INT 107
44317: EQUAL
44318: IFFALSE 44328
// sBomb := true ;
44320: LD_ADDR_EXP 110
44324: PUSH
44325: LD_INT 1
44327: ST_TO_ADDR
// if p3 = 108 then
44328: LD_VAR 0 3
44332: PUSH
44333: LD_INT 108
44335: EQUAL
44336: IFFALSE 44346
// sWound := true ;
44338: LD_ADDR_EXP 118
44342: PUSH
44343: LD_INT 1
44345: ST_TO_ADDR
// if p3 = 109 then
44346: LD_VAR 0 3
44350: PUSH
44351: LD_INT 109
44353: EQUAL
44354: IFFALSE 44364
// sBetray := true ;
44356: LD_ADDR_EXP 122
44360: PUSH
44361: LD_INT 1
44363: ST_TO_ADDR
// if p3 = 110 then
44364: LD_VAR 0 3
44368: PUSH
44369: LD_INT 110
44371: EQUAL
44372: IFFALSE 44382
// sContamin := true ;
44374: LD_ADDR_EXP 123
44378: PUSH
44379: LD_INT 1
44381: ST_TO_ADDR
// if p3 = 111 then
44382: LD_VAR 0 3
44386: PUSH
44387: LD_INT 111
44389: EQUAL
44390: IFFALSE 44400
// sOil := true ;
44392: LD_ADDR_EXP 125
44396: PUSH
44397: LD_INT 1
44399: ST_TO_ADDR
// if p3 = 112 then
44400: LD_VAR 0 3
44404: PUSH
44405: LD_INT 112
44407: EQUAL
44408: IFFALSE 44418
// sStu := true ;
44410: LD_ADDR_EXP 129
44414: PUSH
44415: LD_INT 1
44417: ST_TO_ADDR
// if p3 = 113 then
44418: LD_VAR 0 3
44422: PUSH
44423: LD_INT 113
44425: EQUAL
44426: IFFALSE 44436
// sBazooka := true ;
44428: LD_ADDR_EXP 132
44432: PUSH
44433: LD_INT 1
44435: ST_TO_ADDR
// if p3 = 114 then
44436: LD_VAR 0 3
44440: PUSH
44441: LD_INT 114
44443: EQUAL
44444: IFFALSE 44454
// sMortar := true ;
44446: LD_ADDR_EXP 133
44450: PUSH
44451: LD_INT 1
44453: ST_TO_ADDR
// if p3 = 115 then
44454: LD_VAR 0 3
44458: PUSH
44459: LD_INT 115
44461: EQUAL
44462: IFFALSE 44472
// sRanger := true ;
44464: LD_ADDR_EXP 143
44468: PUSH
44469: LD_INT 1
44471: ST_TO_ADDR
// end ; if p2 = 101 then
44472: LD_VAR 0 2
44476: PUSH
44477: LD_INT 101
44479: EQUAL
44480: IFFALSE 44683
// begin case p3 of 1 :
44482: LD_VAR 0 3
44486: PUSH
44487: LD_INT 1
44489: DOUBLE
44490: EQUAL
44491: IFTRUE 44495
44493: GO 44502
44495: POP
// hHackUnlimitedResources ; 2 :
44496: CALL 54777 0 0
44500: GO 44683
44502: LD_INT 2
44504: DOUBLE
44505: EQUAL
44506: IFTRUE 44510
44508: GO 44517
44510: POP
// hHackSetLevel10 ; 3 :
44511: CALL 54910 0 0
44515: GO 44683
44517: LD_INT 3
44519: DOUBLE
44520: EQUAL
44521: IFTRUE 44525
44523: GO 44532
44525: POP
// hHackSetLevel10YourUnits ; 4 :
44526: CALL 54995 0 0
44530: GO 44683
44532: LD_INT 4
44534: DOUBLE
44535: EQUAL
44536: IFTRUE 44540
44538: GO 44562
44540: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
44541: LD_VAR 0 4
44545: PPUSH
44546: LD_VAR 0 5
44550: PPUSH
44551: LD_VAR 0 6
44555: PPUSH
44556: CALL 55085 0 3
44560: GO 44683
44562: LD_INT 5
44564: DOUBLE
44565: EQUAL
44566: IFTRUE 44570
44568: GO 44577
44570: POP
// hHackSpawnVehicle ; 6 :
44571: CALL 55146 0 0
44575: GO 44683
44577: LD_INT 6
44579: DOUBLE
44580: EQUAL
44581: IFTRUE 44585
44583: GO 44592
44585: POP
// hHackInvincible ; 7 :
44586: CALL 55692 0 0
44590: GO 44683
44592: LD_INT 7
44594: DOUBLE
44595: EQUAL
44596: IFTRUE 44600
44598: GO 44607
44600: POP
// hHackInvisible ; 8 :
44601: CALL 55803 0 0
44605: GO 44683
44607: LD_INT 8
44609: DOUBLE
44610: EQUAL
44611: IFTRUE 44615
44613: GO 44622
44615: POP
// hHackChangeYourSide ; 9 :
44616: CALL 55860 0 0
44620: GO 44683
44622: LD_INT 9
44624: DOUBLE
44625: EQUAL
44626: IFTRUE 44630
44628: GO 44637
44630: POP
// hHackChangeUnitSide ; 10 :
44631: CALL 55902 0 0
44635: GO 44683
44637: LD_INT 10
44639: DOUBLE
44640: EQUAL
44641: IFTRUE 44645
44643: GO 44652
44645: POP
// hHackFog ; 11 :
44646: CALL 56003 0 0
44650: GO 44683
44652: LD_INT 11
44654: DOUBLE
44655: EQUAL
44656: IFTRUE 44660
44658: GO 44667
44660: POP
// hHackApeman ; 12 :
44661: CALL 56018 0 0
44665: GO 44683
44667: LD_INT 12
44669: DOUBLE
44670: EQUAL
44671: IFTRUE 44675
44673: GO 44682
44675: POP
// hHackBoom ; end ;
44676: CALL 56103 0 0
44680: GO 44683
44682: POP
// end ; end ;
44683: PPOPN 6
44685: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
44686: GO 44688
44688: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44689: LD_STRING initStreamRollete();
44691: PPUSH
44692: CALL_OW 559
// InitStreamMode ;
44696: CALL 44705 0 0
// DefineStreamItems ( ) ;
44700: CALL 45145 0 0
// end ;
44704: END
// function InitStreamMode ; begin
44705: LD_INT 0
44707: PPUSH
// streamModeActive := false ;
44708: LD_ADDR_EXP 90
44712: PUSH
44713: LD_INT 0
44715: ST_TO_ADDR
// normalCounter := 36 ;
44716: LD_ADDR_EXP 91
44720: PUSH
44721: LD_INT 36
44723: ST_TO_ADDR
// hardcoreCounter := 16 ;
44724: LD_ADDR_EXP 92
44728: PUSH
44729: LD_INT 16
44731: ST_TO_ADDR
// sRocket := false ;
44732: LD_ADDR_EXP 95
44736: PUSH
44737: LD_INT 0
44739: ST_TO_ADDR
// sSpeed := false ;
44740: LD_ADDR_EXP 94
44744: PUSH
44745: LD_INT 0
44747: ST_TO_ADDR
// sEngine := false ;
44748: LD_ADDR_EXP 96
44752: PUSH
44753: LD_INT 0
44755: ST_TO_ADDR
// sSpec := false ;
44756: LD_ADDR_EXP 93
44760: PUSH
44761: LD_INT 0
44763: ST_TO_ADDR
// sLevel := false ;
44764: LD_ADDR_EXP 97
44768: PUSH
44769: LD_INT 0
44771: ST_TO_ADDR
// sArmoury := false ;
44772: LD_ADDR_EXP 98
44776: PUSH
44777: LD_INT 0
44779: ST_TO_ADDR
// sRadar := false ;
44780: LD_ADDR_EXP 99
44784: PUSH
44785: LD_INT 0
44787: ST_TO_ADDR
// sBunker := false ;
44788: LD_ADDR_EXP 100
44792: PUSH
44793: LD_INT 0
44795: ST_TO_ADDR
// sHack := false ;
44796: LD_ADDR_EXP 101
44800: PUSH
44801: LD_INT 0
44803: ST_TO_ADDR
// sFire := false ;
44804: LD_ADDR_EXP 102
44808: PUSH
44809: LD_INT 0
44811: ST_TO_ADDR
// sRefresh := false ;
44812: LD_ADDR_EXP 103
44816: PUSH
44817: LD_INT 0
44819: ST_TO_ADDR
// sExp := false ;
44820: LD_ADDR_EXP 104
44824: PUSH
44825: LD_INT 0
44827: ST_TO_ADDR
// sDepot := false ;
44828: LD_ADDR_EXP 105
44832: PUSH
44833: LD_INT 0
44835: ST_TO_ADDR
// sFlag := false ;
44836: LD_ADDR_EXP 106
44840: PUSH
44841: LD_INT 0
44843: ST_TO_ADDR
// sKamikadze := false ;
44844: LD_ADDR_EXP 114
44848: PUSH
44849: LD_INT 0
44851: ST_TO_ADDR
// sTroll := false ;
44852: LD_ADDR_EXP 115
44856: PUSH
44857: LD_INT 0
44859: ST_TO_ADDR
// sSlow := false ;
44860: LD_ADDR_EXP 116
44864: PUSH
44865: LD_INT 0
44867: ST_TO_ADDR
// sLack := false ;
44868: LD_ADDR_EXP 117
44872: PUSH
44873: LD_INT 0
44875: ST_TO_ADDR
// sTank := false ;
44876: LD_ADDR_EXP 119
44880: PUSH
44881: LD_INT 0
44883: ST_TO_ADDR
// sRemote := false ;
44884: LD_ADDR_EXP 120
44888: PUSH
44889: LD_INT 0
44891: ST_TO_ADDR
// sPowell := false ;
44892: LD_ADDR_EXP 121
44896: PUSH
44897: LD_INT 0
44899: ST_TO_ADDR
// sTeleport := false ;
44900: LD_ADDR_EXP 124
44904: PUSH
44905: LD_INT 0
44907: ST_TO_ADDR
// sOilTower := false ;
44908: LD_ADDR_EXP 126
44912: PUSH
44913: LD_INT 0
44915: ST_TO_ADDR
// sShovel := false ;
44916: LD_ADDR_EXP 127
44920: PUSH
44921: LD_INT 0
44923: ST_TO_ADDR
// sSheik := false ;
44924: LD_ADDR_EXP 128
44928: PUSH
44929: LD_INT 0
44931: ST_TO_ADDR
// sEarthquake := false ;
44932: LD_ADDR_EXP 130
44936: PUSH
44937: LD_INT 0
44939: ST_TO_ADDR
// sAI := false ;
44940: LD_ADDR_EXP 131
44944: PUSH
44945: LD_INT 0
44947: ST_TO_ADDR
// sCargo := false ;
44948: LD_ADDR_EXP 134
44952: PUSH
44953: LD_INT 0
44955: ST_TO_ADDR
// sDLaser := false ;
44956: LD_ADDR_EXP 135
44960: PUSH
44961: LD_INT 0
44963: ST_TO_ADDR
// sExchange := false ;
44964: LD_ADDR_EXP 136
44968: PUSH
44969: LD_INT 0
44971: ST_TO_ADDR
// sFac := false ;
44972: LD_ADDR_EXP 137
44976: PUSH
44977: LD_INT 0
44979: ST_TO_ADDR
// sPower := false ;
44980: LD_ADDR_EXP 138
44984: PUSH
44985: LD_INT 0
44987: ST_TO_ADDR
// sRandom := false ;
44988: LD_ADDR_EXP 139
44992: PUSH
44993: LD_INT 0
44995: ST_TO_ADDR
// sShield := false ;
44996: LD_ADDR_EXP 140
45000: PUSH
45001: LD_INT 0
45003: ST_TO_ADDR
// sTime := false ;
45004: LD_ADDR_EXP 141
45008: PUSH
45009: LD_INT 0
45011: ST_TO_ADDR
// sTools := false ;
45012: LD_ADDR_EXP 142
45016: PUSH
45017: LD_INT 0
45019: ST_TO_ADDR
// sSold := false ;
45020: LD_ADDR_EXP 107
45024: PUSH
45025: LD_INT 0
45027: ST_TO_ADDR
// sDiff := false ;
45028: LD_ADDR_EXP 108
45032: PUSH
45033: LD_INT 0
45035: ST_TO_ADDR
// sFog := false ;
45036: LD_ADDR_EXP 111
45040: PUSH
45041: LD_INT 0
45043: ST_TO_ADDR
// sReset := false ;
45044: LD_ADDR_EXP 112
45048: PUSH
45049: LD_INT 0
45051: ST_TO_ADDR
// sSun := false ;
45052: LD_ADDR_EXP 113
45056: PUSH
45057: LD_INT 0
45059: ST_TO_ADDR
// sTiger := false ;
45060: LD_ADDR_EXP 109
45064: PUSH
45065: LD_INT 0
45067: ST_TO_ADDR
// sBomb := false ;
45068: LD_ADDR_EXP 110
45072: PUSH
45073: LD_INT 0
45075: ST_TO_ADDR
// sWound := false ;
45076: LD_ADDR_EXP 118
45080: PUSH
45081: LD_INT 0
45083: ST_TO_ADDR
// sBetray := false ;
45084: LD_ADDR_EXP 122
45088: PUSH
45089: LD_INT 0
45091: ST_TO_ADDR
// sContamin := false ;
45092: LD_ADDR_EXP 123
45096: PUSH
45097: LD_INT 0
45099: ST_TO_ADDR
// sOil := false ;
45100: LD_ADDR_EXP 125
45104: PUSH
45105: LD_INT 0
45107: ST_TO_ADDR
// sStu := false ;
45108: LD_ADDR_EXP 129
45112: PUSH
45113: LD_INT 0
45115: ST_TO_ADDR
// sBazooka := false ;
45116: LD_ADDR_EXP 132
45120: PUSH
45121: LD_INT 0
45123: ST_TO_ADDR
// sMortar := false ;
45124: LD_ADDR_EXP 133
45128: PUSH
45129: LD_INT 0
45131: ST_TO_ADDR
// sRanger := false ;
45132: LD_ADDR_EXP 143
45136: PUSH
45137: LD_INT 0
45139: ST_TO_ADDR
// end ;
45140: LD_VAR 0 1
45144: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
45145: LD_INT 0
45147: PPUSH
45148: PPUSH
45149: PPUSH
45150: PPUSH
45151: PPUSH
// result := [ ] ;
45152: LD_ADDR_VAR 0 1
45156: PUSH
45157: EMPTY
45158: ST_TO_ADDR
// if campaign_id = 1 then
45159: LD_OWVAR 69
45163: PUSH
45164: LD_INT 1
45166: EQUAL
45167: IFFALSE 48105
// begin case mission_number of 1 :
45169: LD_OWVAR 70
45173: PUSH
45174: LD_INT 1
45176: DOUBLE
45177: EQUAL
45178: IFTRUE 45182
45180: GO 45246
45182: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
45183: LD_ADDR_VAR 0 1
45187: PUSH
45188: LD_INT 2
45190: PUSH
45191: LD_INT 4
45193: PUSH
45194: LD_INT 11
45196: PUSH
45197: LD_INT 12
45199: PUSH
45200: LD_INT 15
45202: PUSH
45203: LD_INT 16
45205: PUSH
45206: LD_INT 22
45208: PUSH
45209: LD_INT 23
45211: PUSH
45212: LD_INT 26
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 101
45228: PUSH
45229: LD_INT 102
45231: PUSH
45232: LD_INT 106
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: LIST
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: ST_TO_ADDR
45244: GO 48103
45246: LD_INT 2
45248: DOUBLE
45249: EQUAL
45250: IFTRUE 45254
45252: GO 45326
45254: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
45255: LD_ADDR_VAR 0 1
45259: PUSH
45260: LD_INT 2
45262: PUSH
45263: LD_INT 4
45265: PUSH
45266: LD_INT 11
45268: PUSH
45269: LD_INT 12
45271: PUSH
45272: LD_INT 15
45274: PUSH
45275: LD_INT 16
45277: PUSH
45278: LD_INT 22
45280: PUSH
45281: LD_INT 23
45283: PUSH
45284: LD_INT 26
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: LIST
45291: LIST
45292: LIST
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 101
45300: PUSH
45301: LD_INT 102
45303: PUSH
45304: LD_INT 105
45306: PUSH
45307: LD_INT 106
45309: PUSH
45310: LD_INT 108
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: PUSH
45320: EMPTY
45321: LIST
45322: LIST
45323: ST_TO_ADDR
45324: GO 48103
45326: LD_INT 3
45328: DOUBLE
45329: EQUAL
45330: IFTRUE 45334
45332: GO 45410
45334: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
45335: LD_ADDR_VAR 0 1
45339: PUSH
45340: LD_INT 2
45342: PUSH
45343: LD_INT 4
45345: PUSH
45346: LD_INT 5
45348: PUSH
45349: LD_INT 11
45351: PUSH
45352: LD_INT 12
45354: PUSH
45355: LD_INT 15
45357: PUSH
45358: LD_INT 16
45360: PUSH
45361: LD_INT 22
45363: PUSH
45364: LD_INT 26
45366: PUSH
45367: LD_INT 36
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: PUSH
45382: LD_INT 101
45384: PUSH
45385: LD_INT 102
45387: PUSH
45388: LD_INT 105
45390: PUSH
45391: LD_INT 106
45393: PUSH
45394: LD_INT 108
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: ST_TO_ADDR
45408: GO 48103
45410: LD_INT 4
45412: DOUBLE
45413: EQUAL
45414: IFTRUE 45418
45416: GO 45502
45418: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
45419: LD_ADDR_VAR 0 1
45423: PUSH
45424: LD_INT 2
45426: PUSH
45427: LD_INT 4
45429: PUSH
45430: LD_INT 5
45432: PUSH
45433: LD_INT 8
45435: PUSH
45436: LD_INT 11
45438: PUSH
45439: LD_INT 12
45441: PUSH
45442: LD_INT 15
45444: PUSH
45445: LD_INT 16
45447: PUSH
45448: LD_INT 22
45450: PUSH
45451: LD_INT 23
45453: PUSH
45454: LD_INT 26
45456: PUSH
45457: LD_INT 36
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: PUSH
45474: LD_INT 101
45476: PUSH
45477: LD_INT 102
45479: PUSH
45480: LD_INT 105
45482: PUSH
45483: LD_INT 106
45485: PUSH
45486: LD_INT 108
45488: PUSH
45489: EMPTY
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: ST_TO_ADDR
45500: GO 48103
45502: LD_INT 5
45504: DOUBLE
45505: EQUAL
45506: IFTRUE 45510
45508: GO 45610
45510: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
45511: LD_ADDR_VAR 0 1
45515: PUSH
45516: LD_INT 2
45518: PUSH
45519: LD_INT 4
45521: PUSH
45522: LD_INT 5
45524: PUSH
45525: LD_INT 6
45527: PUSH
45528: LD_INT 8
45530: PUSH
45531: LD_INT 11
45533: PUSH
45534: LD_INT 12
45536: PUSH
45537: LD_INT 15
45539: PUSH
45540: LD_INT 16
45542: PUSH
45543: LD_INT 22
45545: PUSH
45546: LD_INT 23
45548: PUSH
45549: LD_INT 25
45551: PUSH
45552: LD_INT 26
45554: PUSH
45555: LD_INT 36
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 101
45576: PUSH
45577: LD_INT 102
45579: PUSH
45580: LD_INT 105
45582: PUSH
45583: LD_INT 106
45585: PUSH
45586: LD_INT 108
45588: PUSH
45589: LD_INT 109
45591: PUSH
45592: LD_INT 112
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: LIST
45599: LIST
45600: LIST
45601: LIST
45602: LIST
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: ST_TO_ADDR
45608: GO 48103
45610: LD_INT 6
45612: DOUBLE
45613: EQUAL
45614: IFTRUE 45618
45616: GO 45738
45618: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
45619: LD_ADDR_VAR 0 1
45623: PUSH
45624: LD_INT 2
45626: PUSH
45627: LD_INT 4
45629: PUSH
45630: LD_INT 5
45632: PUSH
45633: LD_INT 6
45635: PUSH
45636: LD_INT 8
45638: PUSH
45639: LD_INT 11
45641: PUSH
45642: LD_INT 12
45644: PUSH
45645: LD_INT 15
45647: PUSH
45648: LD_INT 16
45650: PUSH
45651: LD_INT 20
45653: PUSH
45654: LD_INT 21
45656: PUSH
45657: LD_INT 22
45659: PUSH
45660: LD_INT 23
45662: PUSH
45663: LD_INT 25
45665: PUSH
45666: LD_INT 26
45668: PUSH
45669: LD_INT 30
45671: PUSH
45672: LD_INT 31
45674: PUSH
45675: LD_INT 32
45677: PUSH
45678: LD_INT 36
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: PUSH
45702: LD_INT 101
45704: PUSH
45705: LD_INT 102
45707: PUSH
45708: LD_INT 105
45710: PUSH
45711: LD_INT 106
45713: PUSH
45714: LD_INT 108
45716: PUSH
45717: LD_INT 109
45719: PUSH
45720: LD_INT 112
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: LIST
45727: LIST
45728: LIST
45729: LIST
45730: LIST
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: ST_TO_ADDR
45736: GO 48103
45738: LD_INT 7
45740: DOUBLE
45741: EQUAL
45742: IFTRUE 45746
45744: GO 45846
45746: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
45747: LD_ADDR_VAR 0 1
45751: PUSH
45752: LD_INT 2
45754: PUSH
45755: LD_INT 4
45757: PUSH
45758: LD_INT 5
45760: PUSH
45761: LD_INT 7
45763: PUSH
45764: LD_INT 11
45766: PUSH
45767: LD_INT 12
45769: PUSH
45770: LD_INT 15
45772: PUSH
45773: LD_INT 16
45775: PUSH
45776: LD_INT 20
45778: PUSH
45779: LD_INT 21
45781: PUSH
45782: LD_INT 22
45784: PUSH
45785: LD_INT 23
45787: PUSH
45788: LD_INT 25
45790: PUSH
45791: LD_INT 26
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: PUSH
45810: LD_INT 101
45812: PUSH
45813: LD_INT 102
45815: PUSH
45816: LD_INT 103
45818: PUSH
45819: LD_INT 105
45821: PUSH
45822: LD_INT 106
45824: PUSH
45825: LD_INT 108
45827: PUSH
45828: LD_INT 112
45830: PUSH
45831: EMPTY
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: ST_TO_ADDR
45844: GO 48103
45846: LD_INT 8
45848: DOUBLE
45849: EQUAL
45850: IFTRUE 45854
45852: GO 45982
45854: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
45855: LD_ADDR_VAR 0 1
45859: PUSH
45860: LD_INT 2
45862: PUSH
45863: LD_INT 4
45865: PUSH
45866: LD_INT 5
45868: PUSH
45869: LD_INT 6
45871: PUSH
45872: LD_INT 7
45874: PUSH
45875: LD_INT 8
45877: PUSH
45878: LD_INT 11
45880: PUSH
45881: LD_INT 12
45883: PUSH
45884: LD_INT 15
45886: PUSH
45887: LD_INT 16
45889: PUSH
45890: LD_INT 20
45892: PUSH
45893: LD_INT 21
45895: PUSH
45896: LD_INT 22
45898: PUSH
45899: LD_INT 23
45901: PUSH
45902: LD_INT 25
45904: PUSH
45905: LD_INT 26
45907: PUSH
45908: LD_INT 30
45910: PUSH
45911: LD_INT 31
45913: PUSH
45914: LD_INT 32
45916: PUSH
45917: LD_INT 36
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: LIST
45929: LIST
45930: LIST
45931: LIST
45932: LIST
45933: LIST
45934: LIST
45935: LIST
45936: LIST
45937: LIST
45938: LIST
45939: LIST
45940: LIST
45941: PUSH
45942: LD_INT 101
45944: PUSH
45945: LD_INT 102
45947: PUSH
45948: LD_INT 103
45950: PUSH
45951: LD_INT 105
45953: PUSH
45954: LD_INT 106
45956: PUSH
45957: LD_INT 108
45959: PUSH
45960: LD_INT 109
45962: PUSH
45963: LD_INT 112
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: PUSH
45976: EMPTY
45977: LIST
45978: LIST
45979: ST_TO_ADDR
45980: GO 48103
45982: LD_INT 9
45984: DOUBLE
45985: EQUAL
45986: IFTRUE 45990
45988: GO 46126
45990: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45991: LD_ADDR_VAR 0 1
45995: PUSH
45996: LD_INT 2
45998: PUSH
45999: LD_INT 4
46001: PUSH
46002: LD_INT 5
46004: PUSH
46005: LD_INT 6
46007: PUSH
46008: LD_INT 7
46010: PUSH
46011: LD_INT 8
46013: PUSH
46014: LD_INT 11
46016: PUSH
46017: LD_INT 12
46019: PUSH
46020: LD_INT 15
46022: PUSH
46023: LD_INT 16
46025: PUSH
46026: LD_INT 20
46028: PUSH
46029: LD_INT 21
46031: PUSH
46032: LD_INT 22
46034: PUSH
46035: LD_INT 23
46037: PUSH
46038: LD_INT 25
46040: PUSH
46041: LD_INT 26
46043: PUSH
46044: LD_INT 28
46046: PUSH
46047: LD_INT 30
46049: PUSH
46050: LD_INT 31
46052: PUSH
46053: LD_INT 32
46055: PUSH
46056: LD_INT 36
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: LIST
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: LIST
46068: LIST
46069: LIST
46070: LIST
46071: LIST
46072: LIST
46073: LIST
46074: LIST
46075: LIST
46076: LIST
46077: LIST
46078: LIST
46079: LIST
46080: LIST
46081: PUSH
46082: LD_INT 101
46084: PUSH
46085: LD_INT 102
46087: PUSH
46088: LD_INT 103
46090: PUSH
46091: LD_INT 105
46093: PUSH
46094: LD_INT 106
46096: PUSH
46097: LD_INT 108
46099: PUSH
46100: LD_INT 109
46102: PUSH
46103: LD_INT 112
46105: PUSH
46106: LD_INT 114
46108: PUSH
46109: EMPTY
46110: LIST
46111: LIST
46112: LIST
46113: LIST
46114: LIST
46115: LIST
46116: LIST
46117: LIST
46118: LIST
46119: PUSH
46120: EMPTY
46121: LIST
46122: LIST
46123: ST_TO_ADDR
46124: GO 48103
46126: LD_INT 10
46128: DOUBLE
46129: EQUAL
46130: IFTRUE 46134
46132: GO 46318
46134: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
46135: LD_ADDR_VAR 0 1
46139: PUSH
46140: LD_INT 2
46142: PUSH
46143: LD_INT 4
46145: PUSH
46146: LD_INT 5
46148: PUSH
46149: LD_INT 6
46151: PUSH
46152: LD_INT 7
46154: PUSH
46155: LD_INT 8
46157: PUSH
46158: LD_INT 9
46160: PUSH
46161: LD_INT 10
46163: PUSH
46164: LD_INT 11
46166: PUSH
46167: LD_INT 12
46169: PUSH
46170: LD_INT 13
46172: PUSH
46173: LD_INT 14
46175: PUSH
46176: LD_INT 15
46178: PUSH
46179: LD_INT 16
46181: PUSH
46182: LD_INT 17
46184: PUSH
46185: LD_INT 18
46187: PUSH
46188: LD_INT 19
46190: PUSH
46191: LD_INT 20
46193: PUSH
46194: LD_INT 21
46196: PUSH
46197: LD_INT 22
46199: PUSH
46200: LD_INT 23
46202: PUSH
46203: LD_INT 24
46205: PUSH
46206: LD_INT 25
46208: PUSH
46209: LD_INT 26
46211: PUSH
46212: LD_INT 28
46214: PUSH
46215: LD_INT 30
46217: PUSH
46218: LD_INT 31
46220: PUSH
46221: LD_INT 32
46223: PUSH
46224: LD_INT 36
46226: PUSH
46227: EMPTY
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: LIST
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: PUSH
46258: LD_INT 101
46260: PUSH
46261: LD_INT 102
46263: PUSH
46264: LD_INT 103
46266: PUSH
46267: LD_INT 104
46269: PUSH
46270: LD_INT 105
46272: PUSH
46273: LD_INT 106
46275: PUSH
46276: LD_INT 107
46278: PUSH
46279: LD_INT 108
46281: PUSH
46282: LD_INT 109
46284: PUSH
46285: LD_INT 110
46287: PUSH
46288: LD_INT 111
46290: PUSH
46291: LD_INT 112
46293: PUSH
46294: LD_INT 114
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: ST_TO_ADDR
46316: GO 48103
46318: LD_INT 11
46320: DOUBLE
46321: EQUAL
46322: IFTRUE 46326
46324: GO 46518
46326: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
46327: LD_ADDR_VAR 0 1
46331: PUSH
46332: LD_INT 2
46334: PUSH
46335: LD_INT 3
46337: PUSH
46338: LD_INT 4
46340: PUSH
46341: LD_INT 5
46343: PUSH
46344: LD_INT 6
46346: PUSH
46347: LD_INT 7
46349: PUSH
46350: LD_INT 8
46352: PUSH
46353: LD_INT 9
46355: PUSH
46356: LD_INT 10
46358: PUSH
46359: LD_INT 11
46361: PUSH
46362: LD_INT 12
46364: PUSH
46365: LD_INT 13
46367: PUSH
46368: LD_INT 14
46370: PUSH
46371: LD_INT 15
46373: PUSH
46374: LD_INT 16
46376: PUSH
46377: LD_INT 17
46379: PUSH
46380: LD_INT 18
46382: PUSH
46383: LD_INT 19
46385: PUSH
46386: LD_INT 20
46388: PUSH
46389: LD_INT 21
46391: PUSH
46392: LD_INT 22
46394: PUSH
46395: LD_INT 23
46397: PUSH
46398: LD_INT 24
46400: PUSH
46401: LD_INT 25
46403: PUSH
46404: LD_INT 26
46406: PUSH
46407: LD_INT 28
46409: PUSH
46410: LD_INT 30
46412: PUSH
46413: LD_INT 31
46415: PUSH
46416: LD_INT 32
46418: PUSH
46419: LD_INT 34
46421: PUSH
46422: LD_INT 36
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: LIST
46438: LIST
46439: LIST
46440: LIST
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 101
46460: PUSH
46461: LD_INT 102
46463: PUSH
46464: LD_INT 103
46466: PUSH
46467: LD_INT 104
46469: PUSH
46470: LD_INT 105
46472: PUSH
46473: LD_INT 106
46475: PUSH
46476: LD_INT 107
46478: PUSH
46479: LD_INT 108
46481: PUSH
46482: LD_INT 109
46484: PUSH
46485: LD_INT 110
46487: PUSH
46488: LD_INT 111
46490: PUSH
46491: LD_INT 112
46493: PUSH
46494: LD_INT 114
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: PUSH
46512: EMPTY
46513: LIST
46514: LIST
46515: ST_TO_ADDR
46516: GO 48103
46518: LD_INT 12
46520: DOUBLE
46521: EQUAL
46522: IFTRUE 46526
46524: GO 46734
46526: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
46527: LD_ADDR_VAR 0 1
46531: PUSH
46532: LD_INT 1
46534: PUSH
46535: LD_INT 2
46537: PUSH
46538: LD_INT 3
46540: PUSH
46541: LD_INT 4
46543: PUSH
46544: LD_INT 5
46546: PUSH
46547: LD_INT 6
46549: PUSH
46550: LD_INT 7
46552: PUSH
46553: LD_INT 8
46555: PUSH
46556: LD_INT 9
46558: PUSH
46559: LD_INT 10
46561: PUSH
46562: LD_INT 11
46564: PUSH
46565: LD_INT 12
46567: PUSH
46568: LD_INT 13
46570: PUSH
46571: LD_INT 14
46573: PUSH
46574: LD_INT 15
46576: PUSH
46577: LD_INT 16
46579: PUSH
46580: LD_INT 17
46582: PUSH
46583: LD_INT 18
46585: PUSH
46586: LD_INT 19
46588: PUSH
46589: LD_INT 20
46591: PUSH
46592: LD_INT 21
46594: PUSH
46595: LD_INT 22
46597: PUSH
46598: LD_INT 23
46600: PUSH
46601: LD_INT 24
46603: PUSH
46604: LD_INT 25
46606: PUSH
46607: LD_INT 26
46609: PUSH
46610: LD_INT 27
46612: PUSH
46613: LD_INT 28
46615: PUSH
46616: LD_INT 30
46618: PUSH
46619: LD_INT 31
46621: PUSH
46622: LD_INT 32
46624: PUSH
46625: LD_INT 33
46627: PUSH
46628: LD_INT 34
46630: PUSH
46631: LD_INT 36
46633: PUSH
46634: EMPTY
46635: LIST
46636: LIST
46637: LIST
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: LIST
46644: LIST
46645: LIST
46646: LIST
46647: LIST
46648: LIST
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: LIST
46664: LIST
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: PUSH
46670: LD_INT 101
46672: PUSH
46673: LD_INT 102
46675: PUSH
46676: LD_INT 103
46678: PUSH
46679: LD_INT 104
46681: PUSH
46682: LD_INT 105
46684: PUSH
46685: LD_INT 106
46687: PUSH
46688: LD_INT 107
46690: PUSH
46691: LD_INT 108
46693: PUSH
46694: LD_INT 109
46696: PUSH
46697: LD_INT 110
46699: PUSH
46700: LD_INT 111
46702: PUSH
46703: LD_INT 112
46705: PUSH
46706: LD_INT 113
46708: PUSH
46709: LD_INT 114
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: LIST
46720: LIST
46721: LIST
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: LIST
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: ST_TO_ADDR
46732: GO 48103
46734: LD_INT 13
46736: DOUBLE
46737: EQUAL
46738: IFTRUE 46742
46740: GO 46938
46742: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
46743: LD_ADDR_VAR 0 1
46747: PUSH
46748: LD_INT 1
46750: PUSH
46751: LD_INT 2
46753: PUSH
46754: LD_INT 3
46756: PUSH
46757: LD_INT 4
46759: PUSH
46760: LD_INT 5
46762: PUSH
46763: LD_INT 8
46765: PUSH
46766: LD_INT 9
46768: PUSH
46769: LD_INT 10
46771: PUSH
46772: LD_INT 11
46774: PUSH
46775: LD_INT 12
46777: PUSH
46778: LD_INT 14
46780: PUSH
46781: LD_INT 15
46783: PUSH
46784: LD_INT 16
46786: PUSH
46787: LD_INT 17
46789: PUSH
46790: LD_INT 18
46792: PUSH
46793: LD_INT 19
46795: PUSH
46796: LD_INT 20
46798: PUSH
46799: LD_INT 21
46801: PUSH
46802: LD_INT 22
46804: PUSH
46805: LD_INT 23
46807: PUSH
46808: LD_INT 24
46810: PUSH
46811: LD_INT 25
46813: PUSH
46814: LD_INT 26
46816: PUSH
46817: LD_INT 27
46819: PUSH
46820: LD_INT 28
46822: PUSH
46823: LD_INT 30
46825: PUSH
46826: LD_INT 31
46828: PUSH
46829: LD_INT 32
46831: PUSH
46832: LD_INT 33
46834: PUSH
46835: LD_INT 34
46837: PUSH
46838: LD_INT 36
46840: PUSH
46841: EMPTY
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: LIST
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: LIST
46862: LIST
46863: LIST
46864: LIST
46865: LIST
46866: LIST
46867: LIST
46868: LIST
46869: LIST
46870: LIST
46871: LIST
46872: LIST
46873: PUSH
46874: LD_INT 101
46876: PUSH
46877: LD_INT 102
46879: PUSH
46880: LD_INT 103
46882: PUSH
46883: LD_INT 104
46885: PUSH
46886: LD_INT 105
46888: PUSH
46889: LD_INT 106
46891: PUSH
46892: LD_INT 107
46894: PUSH
46895: LD_INT 108
46897: PUSH
46898: LD_INT 109
46900: PUSH
46901: LD_INT 110
46903: PUSH
46904: LD_INT 111
46906: PUSH
46907: LD_INT 112
46909: PUSH
46910: LD_INT 113
46912: PUSH
46913: LD_INT 114
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: LIST
46926: LIST
46927: LIST
46928: LIST
46929: LIST
46930: LIST
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: ST_TO_ADDR
46936: GO 48103
46938: LD_INT 14
46940: DOUBLE
46941: EQUAL
46942: IFTRUE 46946
46944: GO 47158
46946: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46947: LD_ADDR_VAR 0 1
46951: PUSH
46952: LD_INT 1
46954: PUSH
46955: LD_INT 2
46957: PUSH
46958: LD_INT 3
46960: PUSH
46961: LD_INT 4
46963: PUSH
46964: LD_INT 5
46966: PUSH
46967: LD_INT 6
46969: PUSH
46970: LD_INT 7
46972: PUSH
46973: LD_INT 8
46975: PUSH
46976: LD_INT 9
46978: PUSH
46979: LD_INT 10
46981: PUSH
46982: LD_INT 11
46984: PUSH
46985: LD_INT 12
46987: PUSH
46988: LD_INT 13
46990: PUSH
46991: LD_INT 14
46993: PUSH
46994: LD_INT 15
46996: PUSH
46997: LD_INT 16
46999: PUSH
47000: LD_INT 17
47002: PUSH
47003: LD_INT 18
47005: PUSH
47006: LD_INT 19
47008: PUSH
47009: LD_INT 20
47011: PUSH
47012: LD_INT 21
47014: PUSH
47015: LD_INT 22
47017: PUSH
47018: LD_INT 23
47020: PUSH
47021: LD_INT 24
47023: PUSH
47024: LD_INT 25
47026: PUSH
47027: LD_INT 26
47029: PUSH
47030: LD_INT 27
47032: PUSH
47033: LD_INT 28
47035: PUSH
47036: LD_INT 29
47038: PUSH
47039: LD_INT 30
47041: PUSH
47042: LD_INT 31
47044: PUSH
47045: LD_INT 32
47047: PUSH
47048: LD_INT 33
47050: PUSH
47051: LD_INT 34
47053: PUSH
47054: LD_INT 36
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: LIST
47082: LIST
47083: LIST
47084: LIST
47085: LIST
47086: LIST
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: PUSH
47094: LD_INT 101
47096: PUSH
47097: LD_INT 102
47099: PUSH
47100: LD_INT 103
47102: PUSH
47103: LD_INT 104
47105: PUSH
47106: LD_INT 105
47108: PUSH
47109: LD_INT 106
47111: PUSH
47112: LD_INT 107
47114: PUSH
47115: LD_INT 108
47117: PUSH
47118: LD_INT 109
47120: PUSH
47121: LD_INT 110
47123: PUSH
47124: LD_INT 111
47126: PUSH
47127: LD_INT 112
47129: PUSH
47130: LD_INT 113
47132: PUSH
47133: LD_INT 114
47135: PUSH
47136: EMPTY
47137: LIST
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: LIST
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: ST_TO_ADDR
47156: GO 48103
47158: LD_INT 15
47160: DOUBLE
47161: EQUAL
47162: IFTRUE 47166
47164: GO 47378
47166: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
47167: LD_ADDR_VAR 0 1
47171: PUSH
47172: LD_INT 1
47174: PUSH
47175: LD_INT 2
47177: PUSH
47178: LD_INT 3
47180: PUSH
47181: LD_INT 4
47183: PUSH
47184: LD_INT 5
47186: PUSH
47187: LD_INT 6
47189: PUSH
47190: LD_INT 7
47192: PUSH
47193: LD_INT 8
47195: PUSH
47196: LD_INT 9
47198: PUSH
47199: LD_INT 10
47201: PUSH
47202: LD_INT 11
47204: PUSH
47205: LD_INT 12
47207: PUSH
47208: LD_INT 13
47210: PUSH
47211: LD_INT 14
47213: PUSH
47214: LD_INT 15
47216: PUSH
47217: LD_INT 16
47219: PUSH
47220: LD_INT 17
47222: PUSH
47223: LD_INT 18
47225: PUSH
47226: LD_INT 19
47228: PUSH
47229: LD_INT 20
47231: PUSH
47232: LD_INT 21
47234: PUSH
47235: LD_INT 22
47237: PUSH
47238: LD_INT 23
47240: PUSH
47241: LD_INT 24
47243: PUSH
47244: LD_INT 25
47246: PUSH
47247: LD_INT 26
47249: PUSH
47250: LD_INT 27
47252: PUSH
47253: LD_INT 28
47255: PUSH
47256: LD_INT 29
47258: PUSH
47259: LD_INT 30
47261: PUSH
47262: LD_INT 31
47264: PUSH
47265: LD_INT 32
47267: PUSH
47268: LD_INT 33
47270: PUSH
47271: LD_INT 34
47273: PUSH
47274: LD_INT 36
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: LIST
47295: LIST
47296: LIST
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: LIST
47311: LIST
47312: LIST
47313: PUSH
47314: LD_INT 101
47316: PUSH
47317: LD_INT 102
47319: PUSH
47320: LD_INT 103
47322: PUSH
47323: LD_INT 104
47325: PUSH
47326: LD_INT 105
47328: PUSH
47329: LD_INT 106
47331: PUSH
47332: LD_INT 107
47334: PUSH
47335: LD_INT 108
47337: PUSH
47338: LD_INT 109
47340: PUSH
47341: LD_INT 110
47343: PUSH
47344: LD_INT 111
47346: PUSH
47347: LD_INT 112
47349: PUSH
47350: LD_INT 113
47352: PUSH
47353: LD_INT 114
47355: PUSH
47356: EMPTY
47357: LIST
47358: LIST
47359: LIST
47360: LIST
47361: LIST
47362: LIST
47363: LIST
47364: LIST
47365: LIST
47366: LIST
47367: LIST
47368: LIST
47369: LIST
47370: LIST
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: ST_TO_ADDR
47376: GO 48103
47378: LD_INT 16
47380: DOUBLE
47381: EQUAL
47382: IFTRUE 47386
47384: GO 47510
47386: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
47387: LD_ADDR_VAR 0 1
47391: PUSH
47392: LD_INT 2
47394: PUSH
47395: LD_INT 4
47397: PUSH
47398: LD_INT 5
47400: PUSH
47401: LD_INT 7
47403: PUSH
47404: LD_INT 11
47406: PUSH
47407: LD_INT 12
47409: PUSH
47410: LD_INT 15
47412: PUSH
47413: LD_INT 16
47415: PUSH
47416: LD_INT 20
47418: PUSH
47419: LD_INT 21
47421: PUSH
47422: LD_INT 22
47424: PUSH
47425: LD_INT 23
47427: PUSH
47428: LD_INT 25
47430: PUSH
47431: LD_INT 26
47433: PUSH
47434: LD_INT 30
47436: PUSH
47437: LD_INT 31
47439: PUSH
47440: LD_INT 32
47442: PUSH
47443: LD_INT 33
47445: PUSH
47446: LD_INT 34
47448: PUSH
47449: EMPTY
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: PUSH
47470: LD_INT 101
47472: PUSH
47473: LD_INT 102
47475: PUSH
47476: LD_INT 103
47478: PUSH
47479: LD_INT 106
47481: PUSH
47482: LD_INT 108
47484: PUSH
47485: LD_INT 112
47487: PUSH
47488: LD_INT 113
47490: PUSH
47491: LD_INT 114
47493: PUSH
47494: EMPTY
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: PUSH
47504: EMPTY
47505: LIST
47506: LIST
47507: ST_TO_ADDR
47508: GO 48103
47510: LD_INT 17
47512: DOUBLE
47513: EQUAL
47514: IFTRUE 47518
47516: GO 47730
47518: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
47519: LD_ADDR_VAR 0 1
47523: PUSH
47524: LD_INT 1
47526: PUSH
47527: LD_INT 2
47529: PUSH
47530: LD_INT 3
47532: PUSH
47533: LD_INT 4
47535: PUSH
47536: LD_INT 5
47538: PUSH
47539: LD_INT 6
47541: PUSH
47542: LD_INT 7
47544: PUSH
47545: LD_INT 8
47547: PUSH
47548: LD_INT 9
47550: PUSH
47551: LD_INT 10
47553: PUSH
47554: LD_INT 11
47556: PUSH
47557: LD_INT 12
47559: PUSH
47560: LD_INT 13
47562: PUSH
47563: LD_INT 14
47565: PUSH
47566: LD_INT 15
47568: PUSH
47569: LD_INT 16
47571: PUSH
47572: LD_INT 17
47574: PUSH
47575: LD_INT 18
47577: PUSH
47578: LD_INT 19
47580: PUSH
47581: LD_INT 20
47583: PUSH
47584: LD_INT 21
47586: PUSH
47587: LD_INT 22
47589: PUSH
47590: LD_INT 23
47592: PUSH
47593: LD_INT 24
47595: PUSH
47596: LD_INT 25
47598: PUSH
47599: LD_INT 26
47601: PUSH
47602: LD_INT 27
47604: PUSH
47605: LD_INT 28
47607: PUSH
47608: LD_INT 29
47610: PUSH
47611: LD_INT 30
47613: PUSH
47614: LD_INT 31
47616: PUSH
47617: LD_INT 32
47619: PUSH
47620: LD_INT 33
47622: PUSH
47623: LD_INT 34
47625: PUSH
47626: LD_INT 36
47628: PUSH
47629: EMPTY
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: LIST
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: PUSH
47666: LD_INT 101
47668: PUSH
47669: LD_INT 102
47671: PUSH
47672: LD_INT 103
47674: PUSH
47675: LD_INT 104
47677: PUSH
47678: LD_INT 105
47680: PUSH
47681: LD_INT 106
47683: PUSH
47684: LD_INT 107
47686: PUSH
47687: LD_INT 108
47689: PUSH
47690: LD_INT 109
47692: PUSH
47693: LD_INT 110
47695: PUSH
47696: LD_INT 111
47698: PUSH
47699: LD_INT 112
47701: PUSH
47702: LD_INT 113
47704: PUSH
47705: LD_INT 114
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: LIST
47715: LIST
47716: LIST
47717: LIST
47718: LIST
47719: LIST
47720: LIST
47721: LIST
47722: LIST
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: ST_TO_ADDR
47728: GO 48103
47730: LD_INT 18
47732: DOUBLE
47733: EQUAL
47734: IFTRUE 47738
47736: GO 47874
47738: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
47739: LD_ADDR_VAR 0 1
47743: PUSH
47744: LD_INT 2
47746: PUSH
47747: LD_INT 4
47749: PUSH
47750: LD_INT 5
47752: PUSH
47753: LD_INT 7
47755: PUSH
47756: LD_INT 11
47758: PUSH
47759: LD_INT 12
47761: PUSH
47762: LD_INT 15
47764: PUSH
47765: LD_INT 16
47767: PUSH
47768: LD_INT 20
47770: PUSH
47771: LD_INT 21
47773: PUSH
47774: LD_INT 22
47776: PUSH
47777: LD_INT 23
47779: PUSH
47780: LD_INT 25
47782: PUSH
47783: LD_INT 26
47785: PUSH
47786: LD_INT 30
47788: PUSH
47789: LD_INT 31
47791: PUSH
47792: LD_INT 32
47794: PUSH
47795: LD_INT 33
47797: PUSH
47798: LD_INT 34
47800: PUSH
47801: LD_INT 35
47803: PUSH
47804: LD_INT 36
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: PUSH
47830: LD_INT 101
47832: PUSH
47833: LD_INT 102
47835: PUSH
47836: LD_INT 103
47838: PUSH
47839: LD_INT 106
47841: PUSH
47842: LD_INT 108
47844: PUSH
47845: LD_INT 112
47847: PUSH
47848: LD_INT 113
47850: PUSH
47851: LD_INT 114
47853: PUSH
47854: LD_INT 115
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: PUSH
47868: EMPTY
47869: LIST
47870: LIST
47871: ST_TO_ADDR
47872: GO 48103
47874: LD_INT 19
47876: DOUBLE
47877: EQUAL
47878: IFTRUE 47882
47880: GO 48102
47882: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
47883: LD_ADDR_VAR 0 1
47887: PUSH
47888: LD_INT 1
47890: PUSH
47891: LD_INT 2
47893: PUSH
47894: LD_INT 3
47896: PUSH
47897: LD_INT 4
47899: PUSH
47900: LD_INT 5
47902: PUSH
47903: LD_INT 6
47905: PUSH
47906: LD_INT 7
47908: PUSH
47909: LD_INT 8
47911: PUSH
47912: LD_INT 9
47914: PUSH
47915: LD_INT 10
47917: PUSH
47918: LD_INT 11
47920: PUSH
47921: LD_INT 12
47923: PUSH
47924: LD_INT 13
47926: PUSH
47927: LD_INT 14
47929: PUSH
47930: LD_INT 15
47932: PUSH
47933: LD_INT 16
47935: PUSH
47936: LD_INT 17
47938: PUSH
47939: LD_INT 18
47941: PUSH
47942: LD_INT 19
47944: PUSH
47945: LD_INT 20
47947: PUSH
47948: LD_INT 21
47950: PUSH
47951: LD_INT 22
47953: PUSH
47954: LD_INT 23
47956: PUSH
47957: LD_INT 24
47959: PUSH
47960: LD_INT 25
47962: PUSH
47963: LD_INT 26
47965: PUSH
47966: LD_INT 27
47968: PUSH
47969: LD_INT 28
47971: PUSH
47972: LD_INT 29
47974: PUSH
47975: LD_INT 30
47977: PUSH
47978: LD_INT 31
47980: PUSH
47981: LD_INT 32
47983: PUSH
47984: LD_INT 33
47986: PUSH
47987: LD_INT 34
47989: PUSH
47990: LD_INT 35
47992: PUSH
47993: LD_INT 36
47995: PUSH
47996: EMPTY
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: LIST
48011: LIST
48012: LIST
48013: LIST
48014: LIST
48015: LIST
48016: LIST
48017: LIST
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: PUSH
48034: LD_INT 101
48036: PUSH
48037: LD_INT 102
48039: PUSH
48040: LD_INT 103
48042: PUSH
48043: LD_INT 104
48045: PUSH
48046: LD_INT 105
48048: PUSH
48049: LD_INT 106
48051: PUSH
48052: LD_INT 107
48054: PUSH
48055: LD_INT 108
48057: PUSH
48058: LD_INT 109
48060: PUSH
48061: LD_INT 110
48063: PUSH
48064: LD_INT 111
48066: PUSH
48067: LD_INT 112
48069: PUSH
48070: LD_INT 113
48072: PUSH
48073: LD_INT 114
48075: PUSH
48076: LD_INT 115
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: LIST
48083: LIST
48084: LIST
48085: LIST
48086: LIST
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: ST_TO_ADDR
48100: GO 48103
48102: POP
// end else
48103: GO 48322
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
48105: LD_ADDR_VAR 0 1
48109: PUSH
48110: LD_INT 1
48112: PUSH
48113: LD_INT 2
48115: PUSH
48116: LD_INT 3
48118: PUSH
48119: LD_INT 4
48121: PUSH
48122: LD_INT 5
48124: PUSH
48125: LD_INT 6
48127: PUSH
48128: LD_INT 7
48130: PUSH
48131: LD_INT 8
48133: PUSH
48134: LD_INT 9
48136: PUSH
48137: LD_INT 10
48139: PUSH
48140: LD_INT 11
48142: PUSH
48143: LD_INT 12
48145: PUSH
48146: LD_INT 13
48148: PUSH
48149: LD_INT 14
48151: PUSH
48152: LD_INT 15
48154: PUSH
48155: LD_INT 16
48157: PUSH
48158: LD_INT 17
48160: PUSH
48161: LD_INT 18
48163: PUSH
48164: LD_INT 19
48166: PUSH
48167: LD_INT 20
48169: PUSH
48170: LD_INT 21
48172: PUSH
48173: LD_INT 22
48175: PUSH
48176: LD_INT 23
48178: PUSH
48179: LD_INT 24
48181: PUSH
48182: LD_INT 25
48184: PUSH
48185: LD_INT 26
48187: PUSH
48188: LD_INT 27
48190: PUSH
48191: LD_INT 28
48193: PUSH
48194: LD_INT 29
48196: PUSH
48197: LD_INT 30
48199: PUSH
48200: LD_INT 31
48202: PUSH
48203: LD_INT 32
48205: PUSH
48206: LD_INT 33
48208: PUSH
48209: LD_INT 34
48211: PUSH
48212: LD_INT 35
48214: PUSH
48215: LD_INT 36
48217: PUSH
48218: EMPTY
48219: LIST
48220: LIST
48221: LIST
48222: LIST
48223: LIST
48224: LIST
48225: LIST
48226: LIST
48227: LIST
48228: LIST
48229: LIST
48230: LIST
48231: LIST
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: PUSH
48256: LD_INT 101
48258: PUSH
48259: LD_INT 102
48261: PUSH
48262: LD_INT 103
48264: PUSH
48265: LD_INT 104
48267: PUSH
48268: LD_INT 105
48270: PUSH
48271: LD_INT 106
48273: PUSH
48274: LD_INT 107
48276: PUSH
48277: LD_INT 108
48279: PUSH
48280: LD_INT 109
48282: PUSH
48283: LD_INT 110
48285: PUSH
48286: LD_INT 111
48288: PUSH
48289: LD_INT 112
48291: PUSH
48292: LD_INT 113
48294: PUSH
48295: LD_INT 114
48297: PUSH
48298: LD_INT 115
48300: PUSH
48301: EMPTY
48302: LIST
48303: LIST
48304: LIST
48305: LIST
48306: LIST
48307: LIST
48308: LIST
48309: LIST
48310: LIST
48311: LIST
48312: LIST
48313: LIST
48314: LIST
48315: LIST
48316: LIST
48317: PUSH
48318: EMPTY
48319: LIST
48320: LIST
48321: ST_TO_ADDR
// if result then
48322: LD_VAR 0 1
48326: IFFALSE 48615
// begin normal :=  ;
48328: LD_ADDR_VAR 0 3
48332: PUSH
48333: LD_STRING 
48335: ST_TO_ADDR
// hardcore :=  ;
48336: LD_ADDR_VAR 0 4
48340: PUSH
48341: LD_STRING 
48343: ST_TO_ADDR
// for i = 1 to normalCounter do
48344: LD_ADDR_VAR 0 5
48348: PUSH
48349: DOUBLE
48350: LD_INT 1
48352: DEC
48353: ST_TO_ADDR
48354: LD_EXP 91
48358: PUSH
48359: FOR_TO
48360: IFFALSE 48461
// begin tmp := 0 ;
48362: LD_ADDR_VAR 0 2
48366: PUSH
48367: LD_STRING 0
48369: ST_TO_ADDR
// if result [ 1 ] then
48370: LD_VAR 0 1
48374: PUSH
48375: LD_INT 1
48377: ARRAY
48378: IFFALSE 48443
// if result [ 1 ] [ 1 ] = i then
48380: LD_VAR 0 1
48384: PUSH
48385: LD_INT 1
48387: ARRAY
48388: PUSH
48389: LD_INT 1
48391: ARRAY
48392: PUSH
48393: LD_VAR 0 5
48397: EQUAL
48398: IFFALSE 48443
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48400: LD_ADDR_VAR 0 1
48404: PUSH
48405: LD_VAR 0 1
48409: PPUSH
48410: LD_INT 1
48412: PPUSH
48413: LD_VAR 0 1
48417: PUSH
48418: LD_INT 1
48420: ARRAY
48421: PPUSH
48422: LD_INT 1
48424: PPUSH
48425: CALL_OW 3
48429: PPUSH
48430: CALL_OW 1
48434: ST_TO_ADDR
// tmp := 1 ;
48435: LD_ADDR_VAR 0 2
48439: PUSH
48440: LD_STRING 1
48442: ST_TO_ADDR
// end ; normal := normal & tmp ;
48443: LD_ADDR_VAR 0 3
48447: PUSH
48448: LD_VAR 0 3
48452: PUSH
48453: LD_VAR 0 2
48457: STR
48458: ST_TO_ADDR
// end ;
48459: GO 48359
48461: POP
48462: POP
// for i = 1 to hardcoreCounter do
48463: LD_ADDR_VAR 0 5
48467: PUSH
48468: DOUBLE
48469: LD_INT 1
48471: DEC
48472: ST_TO_ADDR
48473: LD_EXP 92
48477: PUSH
48478: FOR_TO
48479: IFFALSE 48584
// begin tmp := 0 ;
48481: LD_ADDR_VAR 0 2
48485: PUSH
48486: LD_STRING 0
48488: ST_TO_ADDR
// if result [ 2 ] then
48489: LD_VAR 0 1
48493: PUSH
48494: LD_INT 2
48496: ARRAY
48497: IFFALSE 48566
// if result [ 2 ] [ 1 ] = 100 + i then
48499: LD_VAR 0 1
48503: PUSH
48504: LD_INT 2
48506: ARRAY
48507: PUSH
48508: LD_INT 1
48510: ARRAY
48511: PUSH
48512: LD_INT 100
48514: PUSH
48515: LD_VAR 0 5
48519: PLUS
48520: EQUAL
48521: IFFALSE 48566
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48523: LD_ADDR_VAR 0 1
48527: PUSH
48528: LD_VAR 0 1
48532: PPUSH
48533: LD_INT 2
48535: PPUSH
48536: LD_VAR 0 1
48540: PUSH
48541: LD_INT 2
48543: ARRAY
48544: PPUSH
48545: LD_INT 1
48547: PPUSH
48548: CALL_OW 3
48552: PPUSH
48553: CALL_OW 1
48557: ST_TO_ADDR
// tmp := 1 ;
48558: LD_ADDR_VAR 0 2
48562: PUSH
48563: LD_STRING 1
48565: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48566: LD_ADDR_VAR 0 4
48570: PUSH
48571: LD_VAR 0 4
48575: PUSH
48576: LD_VAR 0 2
48580: STR
48581: ST_TO_ADDR
// end ;
48582: GO 48478
48584: POP
48585: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48586: LD_STRING getStreamItemsFromMission("
48588: PUSH
48589: LD_VAR 0 3
48593: STR
48594: PUSH
48595: LD_STRING ","
48597: STR
48598: PUSH
48599: LD_VAR 0 4
48603: STR
48604: PUSH
48605: LD_STRING ")
48607: STR
48608: PPUSH
48609: CALL_OW 559
// end else
48613: GO 48622
// ToLua ( getStreamItemsFromMission("","") ) ;
48615: LD_STRING getStreamItemsFromMission("","")
48617: PPUSH
48618: CALL_OW 559
// end ;
48622: LD_VAR 0 1
48626: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48627: LD_EXP 90
48631: PUSH
48632: LD_EXP 95
48636: AND
48637: IFFALSE 48761
48639: GO 48641
48641: DISABLE
48642: LD_INT 0
48644: PPUSH
48645: PPUSH
// begin enable ;
48646: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48647: LD_ADDR_VAR 0 2
48651: PUSH
48652: LD_INT 22
48654: PUSH
48655: LD_OWVAR 2
48659: PUSH
48660: EMPTY
48661: LIST
48662: LIST
48663: PUSH
48664: LD_INT 2
48666: PUSH
48667: LD_INT 34
48669: PUSH
48670: LD_INT 7
48672: PUSH
48673: EMPTY
48674: LIST
48675: LIST
48676: PUSH
48677: LD_INT 34
48679: PUSH
48680: LD_INT 45
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: LD_INT 34
48689: PUSH
48690: LD_INT 28
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: PUSH
48697: LD_INT 34
48699: PUSH
48700: LD_INT 47
48702: PUSH
48703: EMPTY
48704: LIST
48705: LIST
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: LIST
48711: LIST
48712: LIST
48713: PUSH
48714: EMPTY
48715: LIST
48716: LIST
48717: PPUSH
48718: CALL_OW 69
48722: ST_TO_ADDR
// if not tmp then
48723: LD_VAR 0 2
48727: NOT
48728: IFFALSE 48732
// exit ;
48730: GO 48761
// for i in tmp do
48732: LD_ADDR_VAR 0 1
48736: PUSH
48737: LD_VAR 0 2
48741: PUSH
48742: FOR_IN
48743: IFFALSE 48759
// begin SetLives ( i , 0 ) ;
48745: LD_VAR 0 1
48749: PPUSH
48750: LD_INT 0
48752: PPUSH
48753: CALL_OW 234
// end ;
48757: GO 48742
48759: POP
48760: POP
// end ;
48761: PPOPN 2
48763: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48764: LD_EXP 90
48768: PUSH
48769: LD_EXP 96
48773: AND
48774: IFFALSE 48858
48776: GO 48778
48778: DISABLE
48779: LD_INT 0
48781: PPUSH
48782: PPUSH
// begin enable ;
48783: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48784: LD_ADDR_VAR 0 2
48788: PUSH
48789: LD_INT 22
48791: PUSH
48792: LD_OWVAR 2
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: PUSH
48801: LD_INT 32
48803: PUSH
48804: LD_INT 3
48806: PUSH
48807: EMPTY
48808: LIST
48809: LIST
48810: PUSH
48811: EMPTY
48812: LIST
48813: LIST
48814: PPUSH
48815: CALL_OW 69
48819: ST_TO_ADDR
// if not tmp then
48820: LD_VAR 0 2
48824: NOT
48825: IFFALSE 48829
// exit ;
48827: GO 48858
// for i in tmp do
48829: LD_ADDR_VAR 0 1
48833: PUSH
48834: LD_VAR 0 2
48838: PUSH
48839: FOR_IN
48840: IFFALSE 48856
// begin SetLives ( i , 0 ) ;
48842: LD_VAR 0 1
48846: PPUSH
48847: LD_INT 0
48849: PPUSH
48850: CALL_OW 234
// end ;
48854: GO 48839
48856: POP
48857: POP
// end ;
48858: PPOPN 2
48860: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48861: LD_EXP 90
48865: PUSH
48866: LD_EXP 93
48870: AND
48871: IFFALSE 48964
48873: GO 48875
48875: DISABLE
48876: LD_INT 0
48878: PPUSH
// begin enable ;
48879: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48880: LD_ADDR_VAR 0 1
48884: PUSH
48885: LD_INT 22
48887: PUSH
48888: LD_OWVAR 2
48892: PUSH
48893: EMPTY
48894: LIST
48895: LIST
48896: PUSH
48897: LD_INT 2
48899: PUSH
48900: LD_INT 25
48902: PUSH
48903: LD_INT 5
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: LD_INT 25
48912: PUSH
48913: LD_INT 9
48915: PUSH
48916: EMPTY
48917: LIST
48918: LIST
48919: PUSH
48920: LD_INT 25
48922: PUSH
48923: LD_INT 8
48925: PUSH
48926: EMPTY
48927: LIST
48928: LIST
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PPUSH
48940: CALL_OW 69
48944: PUSH
48945: FOR_IN
48946: IFFALSE 48962
// begin SetClass ( i , 1 ) ;
48948: LD_VAR 0 1
48952: PPUSH
48953: LD_INT 1
48955: PPUSH
48956: CALL_OW 336
// end ;
48960: GO 48945
48962: POP
48963: POP
// end ;
48964: PPOPN 1
48966: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48967: LD_EXP 90
48971: PUSH
48972: LD_EXP 94
48976: AND
48977: PUSH
48978: LD_OWVAR 65
48982: PUSH
48983: LD_INT 7
48985: LESS
48986: AND
48987: IFFALSE 49001
48989: GO 48991
48991: DISABLE
// begin enable ;
48992: ENABLE
// game_speed := 7 ;
48993: LD_ADDR_OWVAR 65
48997: PUSH
48998: LD_INT 7
49000: ST_TO_ADDR
// end ;
49001: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49002: LD_EXP 90
49006: PUSH
49007: LD_EXP 97
49011: AND
49012: IFFALSE 49214
49014: GO 49016
49016: DISABLE
49017: LD_INT 0
49019: PPUSH
49020: PPUSH
49021: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49022: LD_ADDR_VAR 0 3
49026: PUSH
49027: LD_INT 81
49029: PUSH
49030: LD_OWVAR 2
49034: PUSH
49035: EMPTY
49036: LIST
49037: LIST
49038: PUSH
49039: LD_INT 21
49041: PUSH
49042: LD_INT 1
49044: PUSH
49045: EMPTY
49046: LIST
49047: LIST
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PPUSH
49053: CALL_OW 69
49057: ST_TO_ADDR
// if not tmp then
49058: LD_VAR 0 3
49062: NOT
49063: IFFALSE 49067
// exit ;
49065: GO 49214
// if tmp > 5 then
49067: LD_VAR 0 3
49071: PUSH
49072: LD_INT 5
49074: GREATER
49075: IFFALSE 49087
// k := 5 else
49077: LD_ADDR_VAR 0 2
49081: PUSH
49082: LD_INT 5
49084: ST_TO_ADDR
49085: GO 49097
// k := tmp ;
49087: LD_ADDR_VAR 0 2
49091: PUSH
49092: LD_VAR 0 3
49096: ST_TO_ADDR
// for i := 1 to k do
49097: LD_ADDR_VAR 0 1
49101: PUSH
49102: DOUBLE
49103: LD_INT 1
49105: DEC
49106: ST_TO_ADDR
49107: LD_VAR 0 2
49111: PUSH
49112: FOR_TO
49113: IFFALSE 49212
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49115: LD_VAR 0 3
49119: PUSH
49120: LD_VAR 0 1
49124: ARRAY
49125: PPUSH
49126: LD_VAR 0 1
49130: PUSH
49131: LD_INT 4
49133: MOD
49134: PUSH
49135: LD_INT 1
49137: PLUS
49138: PPUSH
49139: CALL_OW 259
49143: PUSH
49144: LD_INT 10
49146: LESS
49147: IFFALSE 49210
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49149: LD_VAR 0 3
49153: PUSH
49154: LD_VAR 0 1
49158: ARRAY
49159: PPUSH
49160: LD_VAR 0 1
49164: PUSH
49165: LD_INT 4
49167: MOD
49168: PUSH
49169: LD_INT 1
49171: PLUS
49172: PPUSH
49173: LD_VAR 0 3
49177: PUSH
49178: LD_VAR 0 1
49182: ARRAY
49183: PPUSH
49184: LD_VAR 0 1
49188: PUSH
49189: LD_INT 4
49191: MOD
49192: PUSH
49193: LD_INT 1
49195: PLUS
49196: PPUSH
49197: CALL_OW 259
49201: PUSH
49202: LD_INT 1
49204: PLUS
49205: PPUSH
49206: CALL_OW 237
49210: GO 49112
49212: POP
49213: POP
// end ;
49214: PPOPN 3
49216: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49217: LD_EXP 90
49221: PUSH
49222: LD_EXP 98
49226: AND
49227: IFFALSE 49247
49229: GO 49231
49231: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49232: LD_INT 4
49234: PPUSH
49235: LD_OWVAR 2
49239: PPUSH
49240: LD_INT 0
49242: PPUSH
49243: CALL_OW 324
49247: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49248: LD_EXP 90
49252: PUSH
49253: LD_EXP 127
49257: AND
49258: IFFALSE 49278
49260: GO 49262
49262: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49263: LD_INT 19
49265: PPUSH
49266: LD_OWVAR 2
49270: PPUSH
49271: LD_INT 0
49273: PPUSH
49274: CALL_OW 324
49278: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49279: LD_EXP 90
49283: PUSH
49284: LD_EXP 99
49288: AND
49289: IFFALSE 49391
49291: GO 49293
49293: DISABLE
49294: LD_INT 0
49296: PPUSH
49297: PPUSH
// begin enable ;
49298: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49299: LD_ADDR_VAR 0 2
49303: PUSH
49304: LD_INT 22
49306: PUSH
49307: LD_OWVAR 2
49311: PUSH
49312: EMPTY
49313: LIST
49314: LIST
49315: PUSH
49316: LD_INT 2
49318: PUSH
49319: LD_INT 34
49321: PUSH
49322: LD_INT 11
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: PUSH
49329: LD_INT 34
49331: PUSH
49332: LD_INT 30
49334: PUSH
49335: EMPTY
49336: LIST
49337: LIST
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: LIST
49343: PUSH
49344: EMPTY
49345: LIST
49346: LIST
49347: PPUSH
49348: CALL_OW 69
49352: ST_TO_ADDR
// if not tmp then
49353: LD_VAR 0 2
49357: NOT
49358: IFFALSE 49362
// exit ;
49360: GO 49391
// for i in tmp do
49362: LD_ADDR_VAR 0 1
49366: PUSH
49367: LD_VAR 0 2
49371: PUSH
49372: FOR_IN
49373: IFFALSE 49389
// begin SetLives ( i , 0 ) ;
49375: LD_VAR 0 1
49379: PPUSH
49380: LD_INT 0
49382: PPUSH
49383: CALL_OW 234
// end ;
49387: GO 49372
49389: POP
49390: POP
// end ;
49391: PPOPN 2
49393: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49394: LD_EXP 90
49398: PUSH
49399: LD_EXP 100
49403: AND
49404: IFFALSE 49424
49406: GO 49408
49408: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49409: LD_INT 32
49411: PPUSH
49412: LD_OWVAR 2
49416: PPUSH
49417: LD_INT 0
49419: PPUSH
49420: CALL_OW 324
49424: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49425: LD_EXP 90
49429: PUSH
49430: LD_EXP 101
49434: AND
49435: IFFALSE 49616
49437: GO 49439
49439: DISABLE
49440: LD_INT 0
49442: PPUSH
49443: PPUSH
49444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49445: LD_ADDR_VAR 0 2
49449: PUSH
49450: LD_INT 22
49452: PUSH
49453: LD_OWVAR 2
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: LD_INT 33
49464: PUSH
49465: LD_INT 3
49467: PUSH
49468: EMPTY
49469: LIST
49470: LIST
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: PPUSH
49476: CALL_OW 69
49480: ST_TO_ADDR
// if not tmp then
49481: LD_VAR 0 2
49485: NOT
49486: IFFALSE 49490
// exit ;
49488: GO 49616
// side := 0 ;
49490: LD_ADDR_VAR 0 3
49494: PUSH
49495: LD_INT 0
49497: ST_TO_ADDR
// for i := 1 to 8 do
49498: LD_ADDR_VAR 0 1
49502: PUSH
49503: DOUBLE
49504: LD_INT 1
49506: DEC
49507: ST_TO_ADDR
49508: LD_INT 8
49510: PUSH
49511: FOR_TO
49512: IFFALSE 49560
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49514: LD_OWVAR 2
49518: PUSH
49519: LD_VAR 0 1
49523: NONEQUAL
49524: PUSH
49525: LD_OWVAR 2
49529: PPUSH
49530: LD_VAR 0 1
49534: PPUSH
49535: CALL_OW 81
49539: PUSH
49540: LD_INT 2
49542: EQUAL
49543: AND
49544: IFFALSE 49558
// begin side := i ;
49546: LD_ADDR_VAR 0 3
49550: PUSH
49551: LD_VAR 0 1
49555: ST_TO_ADDR
// break ;
49556: GO 49560
// end ;
49558: GO 49511
49560: POP
49561: POP
// if not side then
49562: LD_VAR 0 3
49566: NOT
49567: IFFALSE 49571
// exit ;
49569: GO 49616
// for i := 1 to tmp do
49571: LD_ADDR_VAR 0 1
49575: PUSH
49576: DOUBLE
49577: LD_INT 1
49579: DEC
49580: ST_TO_ADDR
49581: LD_VAR 0 2
49585: PUSH
49586: FOR_TO
49587: IFFALSE 49614
// if Prob ( 60 ) then
49589: LD_INT 60
49591: PPUSH
49592: CALL_OW 13
49596: IFFALSE 49612
// SetSide ( i , side ) ;
49598: LD_VAR 0 1
49602: PPUSH
49603: LD_VAR 0 3
49607: PPUSH
49608: CALL_OW 235
49612: GO 49586
49614: POP
49615: POP
// end ;
49616: PPOPN 3
49618: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49619: LD_EXP 90
49623: PUSH
49624: LD_EXP 103
49628: AND
49629: IFFALSE 49748
49631: GO 49633
49633: DISABLE
49634: LD_INT 0
49636: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49637: LD_ADDR_VAR 0 1
49641: PUSH
49642: LD_INT 22
49644: PUSH
49645: LD_OWVAR 2
49649: PUSH
49650: EMPTY
49651: LIST
49652: LIST
49653: PUSH
49654: LD_INT 21
49656: PUSH
49657: LD_INT 1
49659: PUSH
49660: EMPTY
49661: LIST
49662: LIST
49663: PUSH
49664: LD_INT 3
49666: PUSH
49667: LD_INT 23
49669: PUSH
49670: LD_INT 0
49672: PUSH
49673: EMPTY
49674: LIST
49675: LIST
49676: PUSH
49677: EMPTY
49678: LIST
49679: LIST
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: LIST
49685: PPUSH
49686: CALL_OW 69
49690: PUSH
49691: FOR_IN
49692: IFFALSE 49746
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49694: LD_VAR 0 1
49698: PPUSH
49699: CALL_OW 257
49703: PUSH
49704: LD_INT 1
49706: PUSH
49707: LD_INT 2
49709: PUSH
49710: LD_INT 3
49712: PUSH
49713: LD_INT 4
49715: PUSH
49716: EMPTY
49717: LIST
49718: LIST
49719: LIST
49720: LIST
49721: IN
49722: IFFALSE 49744
// SetClass ( un , rand ( 1 , 4 ) ) ;
49724: LD_VAR 0 1
49728: PPUSH
49729: LD_INT 1
49731: PPUSH
49732: LD_INT 4
49734: PPUSH
49735: CALL_OW 12
49739: PPUSH
49740: CALL_OW 336
49744: GO 49691
49746: POP
49747: POP
// end ;
49748: PPOPN 1
49750: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49751: LD_EXP 90
49755: PUSH
49756: LD_EXP 102
49760: AND
49761: IFFALSE 49840
49763: GO 49765
49765: DISABLE
49766: LD_INT 0
49768: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49769: LD_ADDR_VAR 0 1
49773: PUSH
49774: LD_INT 22
49776: PUSH
49777: LD_OWVAR 2
49781: PUSH
49782: EMPTY
49783: LIST
49784: LIST
49785: PUSH
49786: LD_INT 21
49788: PUSH
49789: LD_INT 3
49791: PUSH
49792: EMPTY
49793: LIST
49794: LIST
49795: PUSH
49796: EMPTY
49797: LIST
49798: LIST
49799: PPUSH
49800: CALL_OW 69
49804: ST_TO_ADDR
// if not tmp then
49805: LD_VAR 0 1
49809: NOT
49810: IFFALSE 49814
// exit ;
49812: GO 49840
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49814: LD_VAR 0 1
49818: PUSH
49819: LD_INT 1
49821: PPUSH
49822: LD_VAR 0 1
49826: PPUSH
49827: CALL_OW 12
49831: ARRAY
49832: PPUSH
49833: LD_INT 100
49835: PPUSH
49836: CALL_OW 234
// end ;
49840: PPOPN 1
49842: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49843: LD_EXP 90
49847: PUSH
49848: LD_EXP 104
49852: AND
49853: IFFALSE 49951
49855: GO 49857
49857: DISABLE
49858: LD_INT 0
49860: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49861: LD_ADDR_VAR 0 1
49865: PUSH
49866: LD_INT 22
49868: PUSH
49869: LD_OWVAR 2
49873: PUSH
49874: EMPTY
49875: LIST
49876: LIST
49877: PUSH
49878: LD_INT 21
49880: PUSH
49881: LD_INT 1
49883: PUSH
49884: EMPTY
49885: LIST
49886: LIST
49887: PUSH
49888: EMPTY
49889: LIST
49890: LIST
49891: PPUSH
49892: CALL_OW 69
49896: ST_TO_ADDR
// if not tmp then
49897: LD_VAR 0 1
49901: NOT
49902: IFFALSE 49906
// exit ;
49904: GO 49951
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49906: LD_VAR 0 1
49910: PUSH
49911: LD_INT 1
49913: PPUSH
49914: LD_VAR 0 1
49918: PPUSH
49919: CALL_OW 12
49923: ARRAY
49924: PPUSH
49925: LD_INT 1
49927: PPUSH
49928: LD_INT 4
49930: PPUSH
49931: CALL_OW 12
49935: PPUSH
49936: LD_INT 3000
49938: PPUSH
49939: LD_INT 9000
49941: PPUSH
49942: CALL_OW 12
49946: PPUSH
49947: CALL_OW 492
// end ;
49951: PPOPN 1
49953: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49954: LD_EXP 90
49958: PUSH
49959: LD_EXP 105
49963: AND
49964: IFFALSE 49984
49966: GO 49968
49968: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49969: LD_INT 1
49971: PPUSH
49972: LD_OWVAR 2
49976: PPUSH
49977: LD_INT 0
49979: PPUSH
49980: CALL_OW 324
49984: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49985: LD_EXP 90
49989: PUSH
49990: LD_EXP 106
49994: AND
49995: IFFALSE 50078
49997: GO 49999
49999: DISABLE
50000: LD_INT 0
50002: PPUSH
50003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50004: LD_ADDR_VAR 0 2
50008: PUSH
50009: LD_INT 22
50011: PUSH
50012: LD_OWVAR 2
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: PUSH
50021: LD_INT 21
50023: PUSH
50024: LD_INT 3
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: PUSH
50031: EMPTY
50032: LIST
50033: LIST
50034: PPUSH
50035: CALL_OW 69
50039: ST_TO_ADDR
// if not tmp then
50040: LD_VAR 0 2
50044: NOT
50045: IFFALSE 50049
// exit ;
50047: GO 50078
// for i in tmp do
50049: LD_ADDR_VAR 0 1
50053: PUSH
50054: LD_VAR 0 2
50058: PUSH
50059: FOR_IN
50060: IFFALSE 50076
// SetBLevel ( i , 10 ) ;
50062: LD_VAR 0 1
50066: PPUSH
50067: LD_INT 10
50069: PPUSH
50070: CALL_OW 241
50074: GO 50059
50076: POP
50077: POP
// end ;
50078: PPOPN 2
50080: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50081: LD_EXP 90
50085: PUSH
50086: LD_EXP 107
50090: AND
50091: IFFALSE 50202
50093: GO 50095
50095: DISABLE
50096: LD_INT 0
50098: PPUSH
50099: PPUSH
50100: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50101: LD_ADDR_VAR 0 3
50105: PUSH
50106: LD_INT 22
50108: PUSH
50109: LD_OWVAR 2
50113: PUSH
50114: EMPTY
50115: LIST
50116: LIST
50117: PUSH
50118: LD_INT 25
50120: PUSH
50121: LD_INT 1
50123: PUSH
50124: EMPTY
50125: LIST
50126: LIST
50127: PUSH
50128: EMPTY
50129: LIST
50130: LIST
50131: PPUSH
50132: CALL_OW 69
50136: ST_TO_ADDR
// if not tmp then
50137: LD_VAR 0 3
50141: NOT
50142: IFFALSE 50146
// exit ;
50144: GO 50202
// un := tmp [ rand ( 1 , tmp ) ] ;
50146: LD_ADDR_VAR 0 2
50150: PUSH
50151: LD_VAR 0 3
50155: PUSH
50156: LD_INT 1
50158: PPUSH
50159: LD_VAR 0 3
50163: PPUSH
50164: CALL_OW 12
50168: ARRAY
50169: ST_TO_ADDR
// if Crawls ( un ) then
50170: LD_VAR 0 2
50174: PPUSH
50175: CALL_OW 318
50179: IFFALSE 50190
// ComWalk ( un ) ;
50181: LD_VAR 0 2
50185: PPUSH
50186: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50190: LD_VAR 0 2
50194: PPUSH
50195: LD_INT 5
50197: PPUSH
50198: CALL_OW 336
// end ;
50202: PPOPN 3
50204: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
50205: LD_EXP 90
50209: PUSH
50210: LD_EXP 108
50214: AND
50215: PUSH
50216: LD_OWVAR 67
50220: PUSH
50221: LD_INT 3
50223: LESS
50224: AND
50225: IFFALSE 50244
50227: GO 50229
50229: DISABLE
// Difficulty := Difficulty + 1 ;
50230: LD_ADDR_OWVAR 67
50234: PUSH
50235: LD_OWVAR 67
50239: PUSH
50240: LD_INT 1
50242: PLUS
50243: ST_TO_ADDR
50244: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50245: LD_EXP 90
50249: PUSH
50250: LD_EXP 109
50254: AND
50255: IFFALSE 50358
50257: GO 50259
50259: DISABLE
50260: LD_INT 0
50262: PPUSH
// begin for i := 1 to 5 do
50263: LD_ADDR_VAR 0 1
50267: PUSH
50268: DOUBLE
50269: LD_INT 1
50271: DEC
50272: ST_TO_ADDR
50273: LD_INT 5
50275: PUSH
50276: FOR_TO
50277: IFFALSE 50356
// begin uc_nation := nation_nature ;
50279: LD_ADDR_OWVAR 21
50283: PUSH
50284: LD_INT 0
50286: ST_TO_ADDR
// uc_side := 0 ;
50287: LD_ADDR_OWVAR 20
50291: PUSH
50292: LD_INT 0
50294: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50295: LD_ADDR_OWVAR 29
50299: PUSH
50300: LD_INT 12
50302: PUSH
50303: LD_INT 12
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: ST_TO_ADDR
// hc_agressivity := 20 ;
50310: LD_ADDR_OWVAR 35
50314: PUSH
50315: LD_INT 20
50317: ST_TO_ADDR
// hc_class := class_tiger ;
50318: LD_ADDR_OWVAR 28
50322: PUSH
50323: LD_INT 14
50325: ST_TO_ADDR
// hc_gallery :=  ;
50326: LD_ADDR_OWVAR 33
50330: PUSH
50331: LD_STRING 
50333: ST_TO_ADDR
// hc_name :=  ;
50334: LD_ADDR_OWVAR 26
50338: PUSH
50339: LD_STRING 
50341: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50342: CALL_OW 44
50346: PPUSH
50347: LD_INT 0
50349: PPUSH
50350: CALL_OW 51
// end ;
50354: GO 50276
50356: POP
50357: POP
// end ;
50358: PPOPN 1
50360: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50361: LD_EXP 90
50365: PUSH
50366: LD_EXP 110
50370: AND
50371: IFFALSE 50380
50373: GO 50375
50375: DISABLE
// StreamSibBomb ;
50376: CALL 50381 0 0
50380: END
// export function StreamSibBomb ; var i , x , y ; begin
50381: LD_INT 0
50383: PPUSH
50384: PPUSH
50385: PPUSH
50386: PPUSH
// result := false ;
50387: LD_ADDR_VAR 0 1
50391: PUSH
50392: LD_INT 0
50394: ST_TO_ADDR
// for i := 1 to 16 do
50395: LD_ADDR_VAR 0 2
50399: PUSH
50400: DOUBLE
50401: LD_INT 1
50403: DEC
50404: ST_TO_ADDR
50405: LD_INT 16
50407: PUSH
50408: FOR_TO
50409: IFFALSE 50608
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50411: LD_ADDR_VAR 0 3
50415: PUSH
50416: LD_INT 10
50418: PUSH
50419: LD_INT 20
50421: PUSH
50422: LD_INT 30
50424: PUSH
50425: LD_INT 40
50427: PUSH
50428: LD_INT 50
50430: PUSH
50431: LD_INT 60
50433: PUSH
50434: LD_INT 70
50436: PUSH
50437: LD_INT 80
50439: PUSH
50440: LD_INT 90
50442: PUSH
50443: LD_INT 100
50445: PUSH
50446: LD_INT 110
50448: PUSH
50449: LD_INT 120
50451: PUSH
50452: LD_INT 130
50454: PUSH
50455: LD_INT 140
50457: PUSH
50458: LD_INT 150
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: LIST
50465: LIST
50466: LIST
50467: LIST
50468: LIST
50469: LIST
50470: LIST
50471: LIST
50472: LIST
50473: LIST
50474: LIST
50475: LIST
50476: LIST
50477: PUSH
50478: LD_INT 1
50480: PPUSH
50481: LD_INT 15
50483: PPUSH
50484: CALL_OW 12
50488: ARRAY
50489: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50490: LD_ADDR_VAR 0 4
50494: PUSH
50495: LD_INT 10
50497: PUSH
50498: LD_INT 20
50500: PUSH
50501: LD_INT 30
50503: PUSH
50504: LD_INT 40
50506: PUSH
50507: LD_INT 50
50509: PUSH
50510: LD_INT 60
50512: PUSH
50513: LD_INT 70
50515: PUSH
50516: LD_INT 80
50518: PUSH
50519: LD_INT 90
50521: PUSH
50522: LD_INT 100
50524: PUSH
50525: LD_INT 110
50527: PUSH
50528: LD_INT 120
50530: PUSH
50531: LD_INT 130
50533: PUSH
50534: LD_INT 140
50536: PUSH
50537: LD_INT 150
50539: PUSH
50540: EMPTY
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: PUSH
50557: LD_INT 1
50559: PPUSH
50560: LD_INT 15
50562: PPUSH
50563: CALL_OW 12
50567: ARRAY
50568: ST_TO_ADDR
// if ValidHex ( x , y ) then
50569: LD_VAR 0 3
50573: PPUSH
50574: LD_VAR 0 4
50578: PPUSH
50579: CALL_OW 488
50583: IFFALSE 50606
// begin result := [ x , y ] ;
50585: LD_ADDR_VAR 0 1
50589: PUSH
50590: LD_VAR 0 3
50594: PUSH
50595: LD_VAR 0 4
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: ST_TO_ADDR
// break ;
50604: GO 50608
// end ; end ;
50606: GO 50408
50608: POP
50609: POP
// if result then
50610: LD_VAR 0 1
50614: IFFALSE 50674
// begin ToLua ( playSibBomb() ) ;
50616: LD_STRING playSibBomb()
50618: PPUSH
50619: CALL_OW 559
// wait ( 0 0$14 ) ;
50623: LD_INT 490
50625: PPUSH
50626: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50630: LD_VAR 0 1
50634: PUSH
50635: LD_INT 1
50637: ARRAY
50638: PPUSH
50639: LD_VAR 0 1
50643: PUSH
50644: LD_INT 2
50646: ARRAY
50647: PPUSH
50648: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50652: LD_VAR 0 1
50656: PUSH
50657: LD_INT 1
50659: ARRAY
50660: PPUSH
50661: LD_VAR 0 1
50665: PUSH
50666: LD_INT 2
50668: ARRAY
50669: PPUSH
50670: CALL_OW 429
// end ; end ;
50674: LD_VAR 0 1
50678: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50679: LD_EXP 90
50683: PUSH
50684: LD_EXP 112
50688: AND
50689: IFFALSE 50701
50691: GO 50693
50693: DISABLE
// YouLost (  ) ;
50694: LD_STRING 
50696: PPUSH
50697: CALL_OW 104
50701: END
// every 0 0$1 trigger StreamModeActive and sFog do
50702: LD_EXP 90
50706: PUSH
50707: LD_EXP 111
50711: AND
50712: IFFALSE 50726
50714: GO 50716
50716: DISABLE
// FogOff ( your_side ) ;
50717: LD_OWVAR 2
50721: PPUSH
50722: CALL_OW 344
50726: END
// every 0 0$1 trigger StreamModeActive and sSun do
50727: LD_EXP 90
50731: PUSH
50732: LD_EXP 113
50736: AND
50737: IFFALSE 50765
50739: GO 50741
50741: DISABLE
// begin solar_recharge_percent := 0 ;
50742: LD_ADDR_OWVAR 79
50746: PUSH
50747: LD_INT 0
50749: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50750: LD_INT 10500
50752: PPUSH
50753: CALL_OW 67
// solar_recharge_percent := 100 ;
50757: LD_ADDR_OWVAR 79
50761: PUSH
50762: LD_INT 100
50764: ST_TO_ADDR
// end ;
50765: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50766: LD_EXP 90
50770: PUSH
50771: LD_EXP 114
50775: AND
50776: IFFALSE 51015
50778: GO 50780
50780: DISABLE
50781: LD_INT 0
50783: PPUSH
50784: PPUSH
50785: PPUSH
// begin tmp := [ ] ;
50786: LD_ADDR_VAR 0 3
50790: PUSH
50791: EMPTY
50792: ST_TO_ADDR
// for i := 1 to 6 do
50793: LD_ADDR_VAR 0 1
50797: PUSH
50798: DOUBLE
50799: LD_INT 1
50801: DEC
50802: ST_TO_ADDR
50803: LD_INT 6
50805: PUSH
50806: FOR_TO
50807: IFFALSE 50912
// begin uc_nation := nation_nature ;
50809: LD_ADDR_OWVAR 21
50813: PUSH
50814: LD_INT 0
50816: ST_TO_ADDR
// uc_side := 0 ;
50817: LD_ADDR_OWVAR 20
50821: PUSH
50822: LD_INT 0
50824: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50825: LD_ADDR_OWVAR 29
50829: PUSH
50830: LD_INT 12
50832: PUSH
50833: LD_INT 12
50835: PUSH
50836: EMPTY
50837: LIST
50838: LIST
50839: ST_TO_ADDR
// hc_agressivity := 20 ;
50840: LD_ADDR_OWVAR 35
50844: PUSH
50845: LD_INT 20
50847: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50848: LD_ADDR_OWVAR 28
50852: PUSH
50853: LD_INT 17
50855: ST_TO_ADDR
// hc_gallery :=  ;
50856: LD_ADDR_OWVAR 33
50860: PUSH
50861: LD_STRING 
50863: ST_TO_ADDR
// hc_name :=  ;
50864: LD_ADDR_OWVAR 26
50868: PUSH
50869: LD_STRING 
50871: ST_TO_ADDR
// un := CreateHuman ;
50872: LD_ADDR_VAR 0 2
50876: PUSH
50877: CALL_OW 44
50881: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50882: LD_VAR 0 2
50886: PPUSH
50887: LD_INT 1
50889: PPUSH
50890: CALL_OW 51
// tmp := tmp ^ un ;
50894: LD_ADDR_VAR 0 3
50898: PUSH
50899: LD_VAR 0 3
50903: PUSH
50904: LD_VAR 0 2
50908: ADD
50909: ST_TO_ADDR
// end ;
50910: GO 50806
50912: POP
50913: POP
// repeat wait ( 0 0$1 ) ;
50914: LD_INT 35
50916: PPUSH
50917: CALL_OW 67
// for un in tmp do
50921: LD_ADDR_VAR 0 2
50925: PUSH
50926: LD_VAR 0 3
50930: PUSH
50931: FOR_IN
50932: IFFALSE 51006
// begin if IsDead ( un ) then
50934: LD_VAR 0 2
50938: PPUSH
50939: CALL_OW 301
50943: IFFALSE 50963
// begin tmp := tmp diff un ;
50945: LD_ADDR_VAR 0 3
50949: PUSH
50950: LD_VAR 0 3
50954: PUSH
50955: LD_VAR 0 2
50959: DIFF
50960: ST_TO_ADDR
// continue ;
50961: GO 50931
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50963: LD_VAR 0 2
50967: PPUSH
50968: LD_INT 3
50970: PUSH
50971: LD_INT 22
50973: PUSH
50974: LD_INT 0
50976: PUSH
50977: EMPTY
50978: LIST
50979: LIST
50980: PUSH
50981: EMPTY
50982: LIST
50983: LIST
50984: PPUSH
50985: CALL_OW 69
50989: PPUSH
50990: LD_VAR 0 2
50994: PPUSH
50995: CALL_OW 74
50999: PPUSH
51000: CALL_OW 115
// end ;
51004: GO 50931
51006: POP
51007: POP
// until not tmp ;
51008: LD_VAR 0 3
51012: NOT
51013: IFFALSE 50914
// end ;
51015: PPOPN 3
51017: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51018: LD_EXP 90
51022: PUSH
51023: LD_EXP 115
51027: AND
51028: IFFALSE 51082
51030: GO 51032
51032: DISABLE
// begin ToLua ( displayTroll(); ) ;
51033: LD_STRING displayTroll();
51035: PPUSH
51036: CALL_OW 559
// wait ( 3 3$00 ) ;
51040: LD_INT 6300
51042: PPUSH
51043: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51047: LD_STRING hideTroll();
51049: PPUSH
51050: CALL_OW 559
// wait ( 1 1$00 ) ;
51054: LD_INT 2100
51056: PPUSH
51057: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51061: LD_STRING displayTroll();
51063: PPUSH
51064: CALL_OW 559
// wait ( 1 1$00 ) ;
51068: LD_INT 2100
51070: PPUSH
51071: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51075: LD_STRING hideTroll();
51077: PPUSH
51078: CALL_OW 559
// end ;
51082: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51083: LD_EXP 90
51087: PUSH
51088: LD_EXP 116
51092: AND
51093: IFFALSE 51156
51095: GO 51097
51097: DISABLE
51098: LD_INT 0
51100: PPUSH
// begin p := 0 ;
51101: LD_ADDR_VAR 0 1
51105: PUSH
51106: LD_INT 0
51108: ST_TO_ADDR
// repeat game_speed := 1 ;
51109: LD_ADDR_OWVAR 65
51113: PUSH
51114: LD_INT 1
51116: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51117: LD_INT 35
51119: PPUSH
51120: CALL_OW 67
// p := p + 1 ;
51124: LD_ADDR_VAR 0 1
51128: PUSH
51129: LD_VAR 0 1
51133: PUSH
51134: LD_INT 1
51136: PLUS
51137: ST_TO_ADDR
// until p >= 60 ;
51138: LD_VAR 0 1
51142: PUSH
51143: LD_INT 60
51145: GREATEREQUAL
51146: IFFALSE 51109
// game_speed := 4 ;
51148: LD_ADDR_OWVAR 65
51152: PUSH
51153: LD_INT 4
51155: ST_TO_ADDR
// end ;
51156: PPOPN 1
51158: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51159: LD_EXP 90
51163: PUSH
51164: LD_EXP 117
51168: AND
51169: IFFALSE 51315
51171: GO 51173
51173: DISABLE
51174: LD_INT 0
51176: PPUSH
51177: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51178: LD_ADDR_VAR 0 1
51182: PUSH
51183: LD_INT 22
51185: PUSH
51186: LD_OWVAR 2
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: PUSH
51195: LD_INT 2
51197: PUSH
51198: LD_INT 30
51200: PUSH
51201: LD_INT 0
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: PUSH
51208: LD_INT 30
51210: PUSH
51211: LD_INT 1
51213: PUSH
51214: EMPTY
51215: LIST
51216: LIST
51217: PUSH
51218: EMPTY
51219: LIST
51220: LIST
51221: LIST
51222: PUSH
51223: EMPTY
51224: LIST
51225: LIST
51226: PPUSH
51227: CALL_OW 69
51231: ST_TO_ADDR
// if not depot then
51232: LD_VAR 0 1
51236: NOT
51237: IFFALSE 51241
// exit ;
51239: GO 51315
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51241: LD_ADDR_VAR 0 2
51245: PUSH
51246: LD_VAR 0 1
51250: PUSH
51251: LD_INT 1
51253: PPUSH
51254: LD_VAR 0 1
51258: PPUSH
51259: CALL_OW 12
51263: ARRAY
51264: PPUSH
51265: CALL_OW 274
51269: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51270: LD_VAR 0 2
51274: PPUSH
51275: LD_INT 1
51277: PPUSH
51278: LD_INT 0
51280: PPUSH
51281: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51285: LD_VAR 0 2
51289: PPUSH
51290: LD_INT 2
51292: PPUSH
51293: LD_INT 0
51295: PPUSH
51296: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51300: LD_VAR 0 2
51304: PPUSH
51305: LD_INT 3
51307: PPUSH
51308: LD_INT 0
51310: PPUSH
51311: CALL_OW 277
// end ;
51315: PPOPN 2
51317: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51318: LD_EXP 90
51322: PUSH
51323: LD_EXP 118
51327: AND
51328: IFFALSE 51425
51330: GO 51332
51332: DISABLE
51333: LD_INT 0
51335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51336: LD_ADDR_VAR 0 1
51340: PUSH
51341: LD_INT 22
51343: PUSH
51344: LD_OWVAR 2
51348: PUSH
51349: EMPTY
51350: LIST
51351: LIST
51352: PUSH
51353: LD_INT 21
51355: PUSH
51356: LD_INT 1
51358: PUSH
51359: EMPTY
51360: LIST
51361: LIST
51362: PUSH
51363: LD_INT 3
51365: PUSH
51366: LD_INT 23
51368: PUSH
51369: LD_INT 0
51371: PUSH
51372: EMPTY
51373: LIST
51374: LIST
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: EMPTY
51381: LIST
51382: LIST
51383: LIST
51384: PPUSH
51385: CALL_OW 69
51389: ST_TO_ADDR
// if not tmp then
51390: LD_VAR 0 1
51394: NOT
51395: IFFALSE 51399
// exit ;
51397: GO 51425
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51399: LD_VAR 0 1
51403: PUSH
51404: LD_INT 1
51406: PPUSH
51407: LD_VAR 0 1
51411: PPUSH
51412: CALL_OW 12
51416: ARRAY
51417: PPUSH
51418: LD_INT 200
51420: PPUSH
51421: CALL_OW 234
// end ;
51425: PPOPN 1
51427: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51428: LD_EXP 90
51432: PUSH
51433: LD_EXP 119
51437: AND
51438: IFFALSE 51517
51440: GO 51442
51442: DISABLE
51443: LD_INT 0
51445: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51446: LD_ADDR_VAR 0 1
51450: PUSH
51451: LD_INT 22
51453: PUSH
51454: LD_OWVAR 2
51458: PUSH
51459: EMPTY
51460: LIST
51461: LIST
51462: PUSH
51463: LD_INT 21
51465: PUSH
51466: LD_INT 2
51468: PUSH
51469: EMPTY
51470: LIST
51471: LIST
51472: PUSH
51473: EMPTY
51474: LIST
51475: LIST
51476: PPUSH
51477: CALL_OW 69
51481: ST_TO_ADDR
// if not tmp then
51482: LD_VAR 0 1
51486: NOT
51487: IFFALSE 51491
// exit ;
51489: GO 51517
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51491: LD_VAR 0 1
51495: PUSH
51496: LD_INT 1
51498: PPUSH
51499: LD_VAR 0 1
51503: PPUSH
51504: CALL_OW 12
51508: ARRAY
51509: PPUSH
51510: LD_INT 60
51512: PPUSH
51513: CALL_OW 234
// end ;
51517: PPOPN 1
51519: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51520: LD_EXP 90
51524: PUSH
51525: LD_EXP 120
51529: AND
51530: IFFALSE 51629
51532: GO 51534
51534: DISABLE
51535: LD_INT 0
51537: PPUSH
51538: PPUSH
// begin enable ;
51539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51540: LD_ADDR_VAR 0 1
51544: PUSH
51545: LD_INT 22
51547: PUSH
51548: LD_OWVAR 2
51552: PUSH
51553: EMPTY
51554: LIST
51555: LIST
51556: PUSH
51557: LD_INT 61
51559: PUSH
51560: EMPTY
51561: LIST
51562: PUSH
51563: LD_INT 33
51565: PUSH
51566: LD_INT 2
51568: PUSH
51569: EMPTY
51570: LIST
51571: LIST
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: LIST
51577: PPUSH
51578: CALL_OW 69
51582: ST_TO_ADDR
// if not tmp then
51583: LD_VAR 0 1
51587: NOT
51588: IFFALSE 51592
// exit ;
51590: GO 51629
// for i in tmp do
51592: LD_ADDR_VAR 0 2
51596: PUSH
51597: LD_VAR 0 1
51601: PUSH
51602: FOR_IN
51603: IFFALSE 51627
// if IsControledBy ( i ) then
51605: LD_VAR 0 2
51609: PPUSH
51610: CALL_OW 312
51614: IFFALSE 51625
// ComUnlink ( i ) ;
51616: LD_VAR 0 2
51620: PPUSH
51621: CALL_OW 136
51625: GO 51602
51627: POP
51628: POP
// end ;
51629: PPOPN 2
51631: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51632: LD_EXP 90
51636: PUSH
51637: LD_EXP 121
51641: AND
51642: IFFALSE 51782
51644: GO 51646
51646: DISABLE
51647: LD_INT 0
51649: PPUSH
51650: PPUSH
// begin ToLua ( displayPowell(); ) ;
51651: LD_STRING displayPowell();
51653: PPUSH
51654: CALL_OW 559
// uc_side := 0 ;
51658: LD_ADDR_OWVAR 20
51662: PUSH
51663: LD_INT 0
51665: ST_TO_ADDR
// uc_nation := 2 ;
51666: LD_ADDR_OWVAR 21
51670: PUSH
51671: LD_INT 2
51673: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51674: LD_ADDR_OWVAR 37
51678: PUSH
51679: LD_INT 14
51681: ST_TO_ADDR
// vc_engine := engine_siberite ;
51682: LD_ADDR_OWVAR 39
51686: PUSH
51687: LD_INT 3
51689: ST_TO_ADDR
// vc_control := control_apeman ;
51690: LD_ADDR_OWVAR 38
51694: PUSH
51695: LD_INT 5
51697: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51698: LD_ADDR_OWVAR 40
51702: PUSH
51703: LD_INT 29
51705: ST_TO_ADDR
// un := CreateVehicle ;
51706: LD_ADDR_VAR 0 2
51710: PUSH
51711: CALL_OW 45
51715: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51716: LD_VAR 0 2
51720: PPUSH
51721: LD_INT 1
51723: PPUSH
51724: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51728: LD_INT 35
51730: PPUSH
51731: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51735: LD_VAR 0 2
51739: PPUSH
51740: LD_INT 22
51742: PUSH
51743: LD_OWVAR 2
51747: PUSH
51748: EMPTY
51749: LIST
51750: LIST
51751: PPUSH
51752: CALL_OW 69
51756: PPUSH
51757: LD_VAR 0 2
51761: PPUSH
51762: CALL_OW 74
51766: PPUSH
51767: CALL_OW 115
// until IsDead ( un ) ;
51771: LD_VAR 0 2
51775: PPUSH
51776: CALL_OW 301
51780: IFFALSE 51728
// end ;
51782: PPOPN 2
51784: END
// every 0 0$1 trigger StreamModeActive and sStu do
51785: LD_EXP 90
51789: PUSH
51790: LD_EXP 129
51794: AND
51795: IFFALSE 51811
51797: GO 51799
51799: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51800: LD_STRING displayStucuk();
51802: PPUSH
51803: CALL_OW 559
// ResetFog ;
51807: CALL_OW 335
// end ;
51811: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51812: LD_EXP 90
51816: PUSH
51817: LD_EXP 122
51821: AND
51822: IFFALSE 51963
51824: GO 51826
51826: DISABLE
51827: LD_INT 0
51829: PPUSH
51830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51831: LD_ADDR_VAR 0 2
51835: PUSH
51836: LD_INT 22
51838: PUSH
51839: LD_OWVAR 2
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: PUSH
51848: LD_INT 21
51850: PUSH
51851: LD_INT 1
51853: PUSH
51854: EMPTY
51855: LIST
51856: LIST
51857: PUSH
51858: EMPTY
51859: LIST
51860: LIST
51861: PPUSH
51862: CALL_OW 69
51866: ST_TO_ADDR
// if not tmp then
51867: LD_VAR 0 2
51871: NOT
51872: IFFALSE 51876
// exit ;
51874: GO 51963
// un := tmp [ rand ( 1 , tmp ) ] ;
51876: LD_ADDR_VAR 0 1
51880: PUSH
51881: LD_VAR 0 2
51885: PUSH
51886: LD_INT 1
51888: PPUSH
51889: LD_VAR 0 2
51893: PPUSH
51894: CALL_OW 12
51898: ARRAY
51899: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51900: LD_VAR 0 1
51904: PPUSH
51905: LD_INT 0
51907: PPUSH
51908: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51912: LD_VAR 0 1
51916: PPUSH
51917: LD_OWVAR 3
51921: PUSH
51922: LD_VAR 0 1
51926: DIFF
51927: PPUSH
51928: LD_VAR 0 1
51932: PPUSH
51933: CALL_OW 74
51937: PPUSH
51938: CALL_OW 115
// wait ( 0 0$20 ) ;
51942: LD_INT 700
51944: PPUSH
51945: CALL_OW 67
// SetSide ( un , your_side ) ;
51949: LD_VAR 0 1
51953: PPUSH
51954: LD_OWVAR 2
51958: PPUSH
51959: CALL_OW 235
// end ;
51963: PPOPN 2
51965: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51966: LD_EXP 90
51970: PUSH
51971: LD_EXP 123
51975: AND
51976: IFFALSE 52082
51978: GO 51980
51980: DISABLE
51981: LD_INT 0
51983: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51984: LD_ADDR_VAR 0 1
51988: PUSH
51989: LD_INT 22
51991: PUSH
51992: LD_OWVAR 2
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: PUSH
52001: LD_INT 2
52003: PUSH
52004: LD_INT 30
52006: PUSH
52007: LD_INT 0
52009: PUSH
52010: EMPTY
52011: LIST
52012: LIST
52013: PUSH
52014: LD_INT 30
52016: PUSH
52017: LD_INT 1
52019: PUSH
52020: EMPTY
52021: LIST
52022: LIST
52023: PUSH
52024: EMPTY
52025: LIST
52026: LIST
52027: LIST
52028: PUSH
52029: EMPTY
52030: LIST
52031: LIST
52032: PPUSH
52033: CALL_OW 69
52037: ST_TO_ADDR
// if not depot then
52038: LD_VAR 0 1
52042: NOT
52043: IFFALSE 52047
// exit ;
52045: GO 52082
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52047: LD_VAR 0 1
52051: PUSH
52052: LD_INT 1
52054: ARRAY
52055: PPUSH
52056: CALL_OW 250
52060: PPUSH
52061: LD_VAR 0 1
52065: PUSH
52066: LD_INT 1
52068: ARRAY
52069: PPUSH
52070: CALL_OW 251
52074: PPUSH
52075: LD_INT 70
52077: PPUSH
52078: CALL_OW 495
// end ;
52082: PPOPN 1
52084: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52085: LD_EXP 90
52089: PUSH
52090: LD_EXP 124
52094: AND
52095: IFFALSE 52306
52097: GO 52099
52099: DISABLE
52100: LD_INT 0
52102: PPUSH
52103: PPUSH
52104: PPUSH
52105: PPUSH
52106: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52107: LD_ADDR_VAR 0 5
52111: PUSH
52112: LD_INT 22
52114: PUSH
52115: LD_OWVAR 2
52119: PUSH
52120: EMPTY
52121: LIST
52122: LIST
52123: PUSH
52124: LD_INT 21
52126: PUSH
52127: LD_INT 1
52129: PUSH
52130: EMPTY
52131: LIST
52132: LIST
52133: PUSH
52134: EMPTY
52135: LIST
52136: LIST
52137: PPUSH
52138: CALL_OW 69
52142: ST_TO_ADDR
// if not tmp then
52143: LD_VAR 0 5
52147: NOT
52148: IFFALSE 52152
// exit ;
52150: GO 52306
// for i in tmp do
52152: LD_ADDR_VAR 0 1
52156: PUSH
52157: LD_VAR 0 5
52161: PUSH
52162: FOR_IN
52163: IFFALSE 52304
// begin d := rand ( 0 , 5 ) ;
52165: LD_ADDR_VAR 0 4
52169: PUSH
52170: LD_INT 0
52172: PPUSH
52173: LD_INT 5
52175: PPUSH
52176: CALL_OW 12
52180: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52181: LD_ADDR_VAR 0 2
52185: PUSH
52186: LD_VAR 0 1
52190: PPUSH
52191: CALL_OW 250
52195: PPUSH
52196: LD_VAR 0 4
52200: PPUSH
52201: LD_INT 3
52203: PPUSH
52204: LD_INT 12
52206: PPUSH
52207: CALL_OW 12
52211: PPUSH
52212: CALL_OW 272
52216: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52217: LD_ADDR_VAR 0 3
52221: PUSH
52222: LD_VAR 0 1
52226: PPUSH
52227: CALL_OW 251
52231: PPUSH
52232: LD_VAR 0 4
52236: PPUSH
52237: LD_INT 3
52239: PPUSH
52240: LD_INT 12
52242: PPUSH
52243: CALL_OW 12
52247: PPUSH
52248: CALL_OW 273
52252: ST_TO_ADDR
// if ValidHex ( x , y ) then
52253: LD_VAR 0 2
52257: PPUSH
52258: LD_VAR 0 3
52262: PPUSH
52263: CALL_OW 488
52267: IFFALSE 52302
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52269: LD_VAR 0 1
52273: PPUSH
52274: LD_VAR 0 2
52278: PPUSH
52279: LD_VAR 0 3
52283: PPUSH
52284: LD_INT 3
52286: PPUSH
52287: LD_INT 6
52289: PPUSH
52290: CALL_OW 12
52294: PPUSH
52295: LD_INT 1
52297: PPUSH
52298: CALL_OW 483
// end ;
52302: GO 52162
52304: POP
52305: POP
// end ;
52306: PPOPN 5
52308: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52309: LD_EXP 90
52313: PUSH
52314: LD_EXP 125
52318: AND
52319: IFFALSE 52413
52321: GO 52323
52323: DISABLE
52324: LD_INT 0
52326: PPUSH
52327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52328: LD_ADDR_VAR 0 2
52332: PUSH
52333: LD_INT 22
52335: PUSH
52336: LD_OWVAR 2
52340: PUSH
52341: EMPTY
52342: LIST
52343: LIST
52344: PUSH
52345: LD_INT 32
52347: PUSH
52348: LD_INT 1
52350: PUSH
52351: EMPTY
52352: LIST
52353: LIST
52354: PUSH
52355: LD_INT 21
52357: PUSH
52358: LD_INT 2
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: PUSH
52365: EMPTY
52366: LIST
52367: LIST
52368: LIST
52369: PPUSH
52370: CALL_OW 69
52374: ST_TO_ADDR
// if not tmp then
52375: LD_VAR 0 2
52379: NOT
52380: IFFALSE 52384
// exit ;
52382: GO 52413
// for i in tmp do
52384: LD_ADDR_VAR 0 1
52388: PUSH
52389: LD_VAR 0 2
52393: PUSH
52394: FOR_IN
52395: IFFALSE 52411
// SetFuel ( i , 0 ) ;
52397: LD_VAR 0 1
52401: PPUSH
52402: LD_INT 0
52404: PPUSH
52405: CALL_OW 240
52409: GO 52394
52411: POP
52412: POP
// end ;
52413: PPOPN 2
52415: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52416: LD_EXP 90
52420: PUSH
52421: LD_EXP 126
52425: AND
52426: IFFALSE 52492
52428: GO 52430
52430: DISABLE
52431: LD_INT 0
52433: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52434: LD_ADDR_VAR 0 1
52438: PUSH
52439: LD_INT 22
52441: PUSH
52442: LD_OWVAR 2
52446: PUSH
52447: EMPTY
52448: LIST
52449: LIST
52450: PUSH
52451: LD_INT 30
52453: PUSH
52454: LD_INT 29
52456: PUSH
52457: EMPTY
52458: LIST
52459: LIST
52460: PUSH
52461: EMPTY
52462: LIST
52463: LIST
52464: PPUSH
52465: CALL_OW 69
52469: ST_TO_ADDR
// if not tmp then
52470: LD_VAR 0 1
52474: NOT
52475: IFFALSE 52479
// exit ;
52477: GO 52492
// DestroyUnit ( tmp [ 1 ] ) ;
52479: LD_VAR 0 1
52483: PUSH
52484: LD_INT 1
52486: ARRAY
52487: PPUSH
52488: CALL_OW 65
// end ;
52492: PPOPN 1
52494: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52495: LD_EXP 90
52499: PUSH
52500: LD_EXP 128
52504: AND
52505: IFFALSE 52634
52507: GO 52509
52509: DISABLE
52510: LD_INT 0
52512: PPUSH
// begin uc_side := 0 ;
52513: LD_ADDR_OWVAR 20
52517: PUSH
52518: LD_INT 0
52520: ST_TO_ADDR
// uc_nation := nation_arabian ;
52521: LD_ADDR_OWVAR 21
52525: PUSH
52526: LD_INT 2
52528: ST_TO_ADDR
// hc_gallery :=  ;
52529: LD_ADDR_OWVAR 33
52533: PUSH
52534: LD_STRING 
52536: ST_TO_ADDR
// hc_name :=  ;
52537: LD_ADDR_OWVAR 26
52541: PUSH
52542: LD_STRING 
52544: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52545: LD_INT 1
52547: PPUSH
52548: LD_INT 11
52550: PPUSH
52551: LD_INT 10
52553: PPUSH
52554: CALL_OW 380
// un := CreateHuman ;
52558: LD_ADDR_VAR 0 1
52562: PUSH
52563: CALL_OW 44
52567: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52568: LD_VAR 0 1
52572: PPUSH
52573: LD_INT 1
52575: PPUSH
52576: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52580: LD_INT 35
52582: PPUSH
52583: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52587: LD_VAR 0 1
52591: PPUSH
52592: LD_INT 22
52594: PUSH
52595: LD_OWVAR 2
52599: PUSH
52600: EMPTY
52601: LIST
52602: LIST
52603: PPUSH
52604: CALL_OW 69
52608: PPUSH
52609: LD_VAR 0 1
52613: PPUSH
52614: CALL_OW 74
52618: PPUSH
52619: CALL_OW 115
// until IsDead ( un ) ;
52623: LD_VAR 0 1
52627: PPUSH
52628: CALL_OW 301
52632: IFFALSE 52580
// end ;
52634: PPOPN 1
52636: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52637: LD_EXP 90
52641: PUSH
52642: LD_EXP 130
52646: AND
52647: IFFALSE 52659
52649: GO 52651
52651: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52652: LD_STRING earthquake(getX(game), 0, 32)
52654: PPUSH
52655: CALL_OW 559
52659: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52660: LD_EXP 90
52664: PUSH
52665: LD_EXP 131
52669: AND
52670: IFFALSE 52761
52672: GO 52674
52674: DISABLE
52675: LD_INT 0
52677: PPUSH
// begin enable ;
52678: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52679: LD_ADDR_VAR 0 1
52683: PUSH
52684: LD_INT 22
52686: PUSH
52687: LD_OWVAR 2
52691: PUSH
52692: EMPTY
52693: LIST
52694: LIST
52695: PUSH
52696: LD_INT 21
52698: PUSH
52699: LD_INT 2
52701: PUSH
52702: EMPTY
52703: LIST
52704: LIST
52705: PUSH
52706: LD_INT 33
52708: PUSH
52709: LD_INT 3
52711: PUSH
52712: EMPTY
52713: LIST
52714: LIST
52715: PUSH
52716: EMPTY
52717: LIST
52718: LIST
52719: LIST
52720: PPUSH
52721: CALL_OW 69
52725: ST_TO_ADDR
// if not tmp then
52726: LD_VAR 0 1
52730: NOT
52731: IFFALSE 52735
// exit ;
52733: GO 52761
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52735: LD_VAR 0 1
52739: PUSH
52740: LD_INT 1
52742: PPUSH
52743: LD_VAR 0 1
52747: PPUSH
52748: CALL_OW 12
52752: ARRAY
52753: PPUSH
52754: LD_INT 1
52756: PPUSH
52757: CALL_OW 234
// end ;
52761: PPOPN 1
52763: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52764: LD_EXP 90
52768: PUSH
52769: LD_EXP 132
52773: AND
52774: IFFALSE 52915
52776: GO 52778
52778: DISABLE
52779: LD_INT 0
52781: PPUSH
52782: PPUSH
52783: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52784: LD_ADDR_VAR 0 3
52788: PUSH
52789: LD_INT 22
52791: PUSH
52792: LD_OWVAR 2
52796: PUSH
52797: EMPTY
52798: LIST
52799: LIST
52800: PUSH
52801: LD_INT 25
52803: PUSH
52804: LD_INT 1
52806: PUSH
52807: EMPTY
52808: LIST
52809: LIST
52810: PUSH
52811: EMPTY
52812: LIST
52813: LIST
52814: PPUSH
52815: CALL_OW 69
52819: ST_TO_ADDR
// if not tmp then
52820: LD_VAR 0 3
52824: NOT
52825: IFFALSE 52829
// exit ;
52827: GO 52915
// un := tmp [ rand ( 1 , tmp ) ] ;
52829: LD_ADDR_VAR 0 2
52833: PUSH
52834: LD_VAR 0 3
52838: PUSH
52839: LD_INT 1
52841: PPUSH
52842: LD_VAR 0 3
52846: PPUSH
52847: CALL_OW 12
52851: ARRAY
52852: ST_TO_ADDR
// if Crawls ( un ) then
52853: LD_VAR 0 2
52857: PPUSH
52858: CALL_OW 318
52862: IFFALSE 52873
// ComWalk ( un ) ;
52864: LD_VAR 0 2
52868: PPUSH
52869: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52873: LD_VAR 0 2
52877: PPUSH
52878: LD_INT 9
52880: PPUSH
52881: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52885: LD_INT 28
52887: PPUSH
52888: LD_OWVAR 2
52892: PPUSH
52893: LD_INT 2
52895: PPUSH
52896: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52900: LD_INT 29
52902: PPUSH
52903: LD_OWVAR 2
52907: PPUSH
52908: LD_INT 2
52910: PPUSH
52911: CALL_OW 322
// end ;
52915: PPOPN 3
52917: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52918: LD_EXP 90
52922: PUSH
52923: LD_EXP 133
52927: AND
52928: IFFALSE 53039
52930: GO 52932
52932: DISABLE
52933: LD_INT 0
52935: PPUSH
52936: PPUSH
52937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52938: LD_ADDR_VAR 0 3
52942: PUSH
52943: LD_INT 22
52945: PUSH
52946: LD_OWVAR 2
52950: PUSH
52951: EMPTY
52952: LIST
52953: LIST
52954: PUSH
52955: LD_INT 25
52957: PUSH
52958: LD_INT 1
52960: PUSH
52961: EMPTY
52962: LIST
52963: LIST
52964: PUSH
52965: EMPTY
52966: LIST
52967: LIST
52968: PPUSH
52969: CALL_OW 69
52973: ST_TO_ADDR
// if not tmp then
52974: LD_VAR 0 3
52978: NOT
52979: IFFALSE 52983
// exit ;
52981: GO 53039
// un := tmp [ rand ( 1 , tmp ) ] ;
52983: LD_ADDR_VAR 0 2
52987: PUSH
52988: LD_VAR 0 3
52992: PUSH
52993: LD_INT 1
52995: PPUSH
52996: LD_VAR 0 3
53000: PPUSH
53001: CALL_OW 12
53005: ARRAY
53006: ST_TO_ADDR
// if Crawls ( un ) then
53007: LD_VAR 0 2
53011: PPUSH
53012: CALL_OW 318
53016: IFFALSE 53027
// ComWalk ( un ) ;
53018: LD_VAR 0 2
53022: PPUSH
53023: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53027: LD_VAR 0 2
53031: PPUSH
53032: LD_INT 8
53034: PPUSH
53035: CALL_OW 336
// end ;
53039: PPOPN 3
53041: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53042: LD_EXP 90
53046: PUSH
53047: LD_EXP 134
53051: AND
53052: IFFALSE 53196
53054: GO 53056
53056: DISABLE
53057: LD_INT 0
53059: PPUSH
53060: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53061: LD_ADDR_VAR 0 2
53065: PUSH
53066: LD_INT 22
53068: PUSH
53069: LD_OWVAR 2
53073: PUSH
53074: EMPTY
53075: LIST
53076: LIST
53077: PUSH
53078: LD_INT 21
53080: PUSH
53081: LD_INT 2
53083: PUSH
53084: EMPTY
53085: LIST
53086: LIST
53087: PUSH
53088: LD_INT 2
53090: PUSH
53091: LD_INT 34
53093: PUSH
53094: LD_INT 12
53096: PUSH
53097: EMPTY
53098: LIST
53099: LIST
53100: PUSH
53101: LD_INT 34
53103: PUSH
53104: LD_INT 51
53106: PUSH
53107: EMPTY
53108: LIST
53109: LIST
53110: PUSH
53111: LD_INT 34
53113: PUSH
53114: LD_INT 32
53116: PUSH
53117: EMPTY
53118: LIST
53119: LIST
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: LIST
53125: LIST
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: LIST
53131: PPUSH
53132: CALL_OW 69
53136: ST_TO_ADDR
// if not tmp then
53137: LD_VAR 0 2
53141: NOT
53142: IFFALSE 53146
// exit ;
53144: GO 53196
// for i in tmp do
53146: LD_ADDR_VAR 0 1
53150: PUSH
53151: LD_VAR 0 2
53155: PUSH
53156: FOR_IN
53157: IFFALSE 53194
// if GetCargo ( i , mat_artifact ) = 0 then
53159: LD_VAR 0 1
53163: PPUSH
53164: LD_INT 4
53166: PPUSH
53167: CALL_OW 289
53171: PUSH
53172: LD_INT 0
53174: EQUAL
53175: IFFALSE 53192
// SetCargo ( i , mat_siberit , 100 ) ;
53177: LD_VAR 0 1
53181: PPUSH
53182: LD_INT 3
53184: PPUSH
53185: LD_INT 100
53187: PPUSH
53188: CALL_OW 290
53192: GO 53156
53194: POP
53195: POP
// end ;
53196: PPOPN 2
53198: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53199: LD_EXP 90
53203: PUSH
53204: LD_EXP 135
53208: AND
53209: IFFALSE 53392
53211: GO 53213
53213: DISABLE
53214: LD_INT 0
53216: PPUSH
53217: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53218: LD_ADDR_VAR 0 2
53222: PUSH
53223: LD_INT 22
53225: PUSH
53226: LD_OWVAR 2
53230: PUSH
53231: EMPTY
53232: LIST
53233: LIST
53234: PPUSH
53235: CALL_OW 69
53239: ST_TO_ADDR
// if not tmp then
53240: LD_VAR 0 2
53244: NOT
53245: IFFALSE 53249
// exit ;
53247: GO 53392
// for i := 1 to 2 do
53249: LD_ADDR_VAR 0 1
53253: PUSH
53254: DOUBLE
53255: LD_INT 1
53257: DEC
53258: ST_TO_ADDR
53259: LD_INT 2
53261: PUSH
53262: FOR_TO
53263: IFFALSE 53390
// begin uc_side := your_side ;
53265: LD_ADDR_OWVAR 20
53269: PUSH
53270: LD_OWVAR 2
53274: ST_TO_ADDR
// uc_nation := nation_american ;
53275: LD_ADDR_OWVAR 21
53279: PUSH
53280: LD_INT 1
53282: ST_TO_ADDR
// vc_chassis := us_morphling ;
53283: LD_ADDR_OWVAR 37
53287: PUSH
53288: LD_INT 5
53290: ST_TO_ADDR
// vc_engine := engine_siberite ;
53291: LD_ADDR_OWVAR 39
53295: PUSH
53296: LD_INT 3
53298: ST_TO_ADDR
// vc_control := control_computer ;
53299: LD_ADDR_OWVAR 38
53303: PUSH
53304: LD_INT 3
53306: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53307: LD_ADDR_OWVAR 40
53311: PUSH
53312: LD_INT 10
53314: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53315: LD_VAR 0 2
53319: PUSH
53320: LD_INT 1
53322: ARRAY
53323: PPUSH
53324: CALL_OW 310
53328: NOT
53329: IFFALSE 53376
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53331: CALL_OW 45
53335: PPUSH
53336: LD_VAR 0 2
53340: PUSH
53341: LD_INT 1
53343: ARRAY
53344: PPUSH
53345: CALL_OW 250
53349: PPUSH
53350: LD_VAR 0 2
53354: PUSH
53355: LD_INT 1
53357: ARRAY
53358: PPUSH
53359: CALL_OW 251
53363: PPUSH
53364: LD_INT 12
53366: PPUSH
53367: LD_INT 1
53369: PPUSH
53370: CALL_OW 50
53374: GO 53388
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53376: CALL_OW 45
53380: PPUSH
53381: LD_INT 1
53383: PPUSH
53384: CALL_OW 51
// end ;
53388: GO 53262
53390: POP
53391: POP
// end ;
53392: PPOPN 2
53394: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53395: LD_EXP 90
53399: PUSH
53400: LD_EXP 136
53404: AND
53405: IFFALSE 53627
53407: GO 53409
53409: DISABLE
53410: LD_INT 0
53412: PPUSH
53413: PPUSH
53414: PPUSH
53415: PPUSH
53416: PPUSH
53417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53418: LD_ADDR_VAR 0 6
53422: PUSH
53423: LD_INT 22
53425: PUSH
53426: LD_OWVAR 2
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: PUSH
53435: LD_INT 21
53437: PUSH
53438: LD_INT 1
53440: PUSH
53441: EMPTY
53442: LIST
53443: LIST
53444: PUSH
53445: LD_INT 3
53447: PUSH
53448: LD_INT 23
53450: PUSH
53451: LD_INT 0
53453: PUSH
53454: EMPTY
53455: LIST
53456: LIST
53457: PUSH
53458: EMPTY
53459: LIST
53460: LIST
53461: PUSH
53462: EMPTY
53463: LIST
53464: LIST
53465: LIST
53466: PPUSH
53467: CALL_OW 69
53471: ST_TO_ADDR
// if not tmp then
53472: LD_VAR 0 6
53476: NOT
53477: IFFALSE 53481
// exit ;
53479: GO 53627
// s1 := rand ( 1 , 4 ) ;
53481: LD_ADDR_VAR 0 2
53485: PUSH
53486: LD_INT 1
53488: PPUSH
53489: LD_INT 4
53491: PPUSH
53492: CALL_OW 12
53496: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53497: LD_ADDR_VAR 0 4
53501: PUSH
53502: LD_VAR 0 6
53506: PUSH
53507: LD_INT 1
53509: ARRAY
53510: PPUSH
53511: LD_VAR 0 2
53515: PPUSH
53516: CALL_OW 259
53520: ST_TO_ADDR
// if s1 = 1 then
53521: LD_VAR 0 2
53525: PUSH
53526: LD_INT 1
53528: EQUAL
53529: IFFALSE 53549
// s2 := rand ( 2 , 4 ) else
53531: LD_ADDR_VAR 0 3
53535: PUSH
53536: LD_INT 2
53538: PPUSH
53539: LD_INT 4
53541: PPUSH
53542: CALL_OW 12
53546: ST_TO_ADDR
53547: GO 53557
// s2 := 1 ;
53549: LD_ADDR_VAR 0 3
53553: PUSH
53554: LD_INT 1
53556: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53557: LD_ADDR_VAR 0 5
53561: PUSH
53562: LD_VAR 0 6
53566: PUSH
53567: LD_INT 1
53569: ARRAY
53570: PPUSH
53571: LD_VAR 0 3
53575: PPUSH
53576: CALL_OW 259
53580: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53581: LD_VAR 0 6
53585: PUSH
53586: LD_INT 1
53588: ARRAY
53589: PPUSH
53590: LD_VAR 0 2
53594: PPUSH
53595: LD_VAR 0 5
53599: PPUSH
53600: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53604: LD_VAR 0 6
53608: PUSH
53609: LD_INT 1
53611: ARRAY
53612: PPUSH
53613: LD_VAR 0 3
53617: PPUSH
53618: LD_VAR 0 4
53622: PPUSH
53623: CALL_OW 237
// end ;
53627: PPOPN 6
53629: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53630: LD_EXP 90
53634: PUSH
53635: LD_EXP 137
53639: AND
53640: IFFALSE 53719
53642: GO 53644
53644: DISABLE
53645: LD_INT 0
53647: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53648: LD_ADDR_VAR 0 1
53652: PUSH
53653: LD_INT 22
53655: PUSH
53656: LD_OWVAR 2
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: PUSH
53665: LD_INT 30
53667: PUSH
53668: LD_INT 3
53670: PUSH
53671: EMPTY
53672: LIST
53673: LIST
53674: PUSH
53675: EMPTY
53676: LIST
53677: LIST
53678: PPUSH
53679: CALL_OW 69
53683: ST_TO_ADDR
// if not tmp then
53684: LD_VAR 0 1
53688: NOT
53689: IFFALSE 53693
// exit ;
53691: GO 53719
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53693: LD_VAR 0 1
53697: PUSH
53698: LD_INT 1
53700: PPUSH
53701: LD_VAR 0 1
53705: PPUSH
53706: CALL_OW 12
53710: ARRAY
53711: PPUSH
53712: LD_INT 1
53714: PPUSH
53715: CALL_OW 234
// end ;
53719: PPOPN 1
53721: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53722: LD_EXP 90
53726: PUSH
53727: LD_EXP 138
53731: AND
53732: IFFALSE 53844
53734: GO 53736
53736: DISABLE
53737: LD_INT 0
53739: PPUSH
53740: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53741: LD_ADDR_VAR 0 2
53745: PUSH
53746: LD_INT 22
53748: PUSH
53749: LD_OWVAR 2
53753: PUSH
53754: EMPTY
53755: LIST
53756: LIST
53757: PUSH
53758: LD_INT 2
53760: PUSH
53761: LD_INT 30
53763: PUSH
53764: LD_INT 27
53766: PUSH
53767: EMPTY
53768: LIST
53769: LIST
53770: PUSH
53771: LD_INT 30
53773: PUSH
53774: LD_INT 26
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: PUSH
53781: LD_INT 30
53783: PUSH
53784: LD_INT 28
53786: PUSH
53787: EMPTY
53788: LIST
53789: LIST
53790: PUSH
53791: EMPTY
53792: LIST
53793: LIST
53794: LIST
53795: LIST
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: PPUSH
53801: CALL_OW 69
53805: ST_TO_ADDR
// if not tmp then
53806: LD_VAR 0 2
53810: NOT
53811: IFFALSE 53815
// exit ;
53813: GO 53844
// for i in tmp do
53815: LD_ADDR_VAR 0 1
53819: PUSH
53820: LD_VAR 0 2
53824: PUSH
53825: FOR_IN
53826: IFFALSE 53842
// SetLives ( i , 1 ) ;
53828: LD_VAR 0 1
53832: PPUSH
53833: LD_INT 1
53835: PPUSH
53836: CALL_OW 234
53840: GO 53825
53842: POP
53843: POP
// end ;
53844: PPOPN 2
53846: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53847: LD_EXP 90
53851: PUSH
53852: LD_EXP 139
53856: AND
53857: IFFALSE 54131
53859: GO 53861
53861: DISABLE
53862: LD_INT 0
53864: PPUSH
53865: PPUSH
53866: PPUSH
// begin i := rand ( 1 , 7 ) ;
53867: LD_ADDR_VAR 0 1
53871: PUSH
53872: LD_INT 1
53874: PPUSH
53875: LD_INT 7
53877: PPUSH
53878: CALL_OW 12
53882: ST_TO_ADDR
// case i of 1 :
53883: LD_VAR 0 1
53887: PUSH
53888: LD_INT 1
53890: DOUBLE
53891: EQUAL
53892: IFTRUE 53896
53894: GO 53906
53896: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53897: LD_STRING earthquake(getX(game), 0, 32)
53899: PPUSH
53900: CALL_OW 559
53904: GO 54131
53906: LD_INT 2
53908: DOUBLE
53909: EQUAL
53910: IFTRUE 53914
53912: GO 53928
53914: POP
// begin ToLua ( displayStucuk(); ) ;
53915: LD_STRING displayStucuk();
53917: PPUSH
53918: CALL_OW 559
// ResetFog ;
53922: CALL_OW 335
// end ; 3 :
53926: GO 54131
53928: LD_INT 3
53930: DOUBLE
53931: EQUAL
53932: IFTRUE 53936
53934: GO 54040
53936: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53937: LD_ADDR_VAR 0 2
53941: PUSH
53942: LD_INT 22
53944: PUSH
53945: LD_OWVAR 2
53949: PUSH
53950: EMPTY
53951: LIST
53952: LIST
53953: PUSH
53954: LD_INT 25
53956: PUSH
53957: LD_INT 1
53959: PUSH
53960: EMPTY
53961: LIST
53962: LIST
53963: PUSH
53964: EMPTY
53965: LIST
53966: LIST
53967: PPUSH
53968: CALL_OW 69
53972: ST_TO_ADDR
// if not tmp then
53973: LD_VAR 0 2
53977: NOT
53978: IFFALSE 53982
// exit ;
53980: GO 54131
// un := tmp [ rand ( 1 , tmp ) ] ;
53982: LD_ADDR_VAR 0 3
53986: PUSH
53987: LD_VAR 0 2
53991: PUSH
53992: LD_INT 1
53994: PPUSH
53995: LD_VAR 0 2
53999: PPUSH
54000: CALL_OW 12
54004: ARRAY
54005: ST_TO_ADDR
// if Crawls ( un ) then
54006: LD_VAR 0 3
54010: PPUSH
54011: CALL_OW 318
54015: IFFALSE 54026
// ComWalk ( un ) ;
54017: LD_VAR 0 3
54021: PPUSH
54022: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54026: LD_VAR 0 3
54030: PPUSH
54031: LD_INT 8
54033: PPUSH
54034: CALL_OW 336
// end ; 4 :
54038: GO 54131
54040: LD_INT 4
54042: DOUBLE
54043: EQUAL
54044: IFTRUE 54048
54046: GO 54109
54048: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54049: LD_ADDR_VAR 0 2
54053: PUSH
54054: LD_INT 22
54056: PUSH
54057: LD_OWVAR 2
54061: PUSH
54062: EMPTY
54063: LIST
54064: LIST
54065: PUSH
54066: LD_INT 30
54068: PUSH
54069: LD_INT 29
54071: PUSH
54072: EMPTY
54073: LIST
54074: LIST
54075: PUSH
54076: EMPTY
54077: LIST
54078: LIST
54079: PPUSH
54080: CALL_OW 69
54084: ST_TO_ADDR
// if not tmp then
54085: LD_VAR 0 2
54089: NOT
54090: IFFALSE 54094
// exit ;
54092: GO 54131
// DestroyUnit ( tmp [ 1 ] ) ;
54094: LD_VAR 0 2
54098: PUSH
54099: LD_INT 1
54101: ARRAY
54102: PPUSH
54103: CALL_OW 65
// end ; 5 .. 7 :
54107: GO 54131
54109: LD_INT 5
54111: DOUBLE
54112: GREATEREQUAL
54113: IFFALSE 54121
54115: LD_INT 7
54117: DOUBLE
54118: LESSEQUAL
54119: IFTRUE 54123
54121: GO 54130
54123: POP
// StreamSibBomb ; end ;
54124: CALL 50381 0 0
54128: GO 54131
54130: POP
// end ;
54131: PPOPN 3
54133: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54134: LD_EXP 90
54138: PUSH
54139: LD_EXP 140
54143: AND
54144: IFFALSE 54300
54146: GO 54148
54148: DISABLE
54149: LD_INT 0
54151: PPUSH
54152: PPUSH
54153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54154: LD_ADDR_VAR 0 2
54158: PUSH
54159: LD_INT 81
54161: PUSH
54162: LD_OWVAR 2
54166: PUSH
54167: EMPTY
54168: LIST
54169: LIST
54170: PUSH
54171: LD_INT 2
54173: PUSH
54174: LD_INT 21
54176: PUSH
54177: LD_INT 1
54179: PUSH
54180: EMPTY
54181: LIST
54182: LIST
54183: PUSH
54184: LD_INT 21
54186: PUSH
54187: LD_INT 2
54189: PUSH
54190: EMPTY
54191: LIST
54192: LIST
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: LIST
54198: PUSH
54199: EMPTY
54200: LIST
54201: LIST
54202: PPUSH
54203: CALL_OW 69
54207: ST_TO_ADDR
// if not tmp then
54208: LD_VAR 0 2
54212: NOT
54213: IFFALSE 54217
// exit ;
54215: GO 54300
// p := 0 ;
54217: LD_ADDR_VAR 0 3
54221: PUSH
54222: LD_INT 0
54224: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54225: LD_INT 35
54227: PPUSH
54228: CALL_OW 67
// p := p + 1 ;
54232: LD_ADDR_VAR 0 3
54236: PUSH
54237: LD_VAR 0 3
54241: PUSH
54242: LD_INT 1
54244: PLUS
54245: ST_TO_ADDR
// for i in tmp do
54246: LD_ADDR_VAR 0 1
54250: PUSH
54251: LD_VAR 0 2
54255: PUSH
54256: FOR_IN
54257: IFFALSE 54288
// if GetLives ( i ) < 1000 then
54259: LD_VAR 0 1
54263: PPUSH
54264: CALL_OW 256
54268: PUSH
54269: LD_INT 1000
54271: LESS
54272: IFFALSE 54286
// SetLives ( i , 1000 ) ;
54274: LD_VAR 0 1
54278: PPUSH
54279: LD_INT 1000
54281: PPUSH
54282: CALL_OW 234
54286: GO 54256
54288: POP
54289: POP
// until p > 20 ;
54290: LD_VAR 0 3
54294: PUSH
54295: LD_INT 20
54297: GREATER
54298: IFFALSE 54225
// end ;
54300: PPOPN 3
54302: END
// every 0 0$1 trigger StreamModeActive and sTime do
54303: LD_EXP 90
54307: PUSH
54308: LD_EXP 141
54312: AND
54313: IFFALSE 54348
54315: GO 54317
54317: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54318: LD_INT 28
54320: PPUSH
54321: LD_OWVAR 2
54325: PPUSH
54326: LD_INT 2
54328: PPUSH
54329: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54333: LD_INT 30
54335: PPUSH
54336: LD_OWVAR 2
54340: PPUSH
54341: LD_INT 2
54343: PPUSH
54344: CALL_OW 322
// end ;
54348: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54349: LD_EXP 90
54353: PUSH
54354: LD_EXP 142
54358: AND
54359: IFFALSE 54480
54361: GO 54363
54363: DISABLE
54364: LD_INT 0
54366: PPUSH
54367: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54368: LD_ADDR_VAR 0 2
54372: PUSH
54373: LD_INT 22
54375: PUSH
54376: LD_OWVAR 2
54380: PUSH
54381: EMPTY
54382: LIST
54383: LIST
54384: PUSH
54385: LD_INT 21
54387: PUSH
54388: LD_INT 1
54390: PUSH
54391: EMPTY
54392: LIST
54393: LIST
54394: PUSH
54395: LD_INT 3
54397: PUSH
54398: LD_INT 23
54400: PUSH
54401: LD_INT 0
54403: PUSH
54404: EMPTY
54405: LIST
54406: LIST
54407: PUSH
54408: EMPTY
54409: LIST
54410: LIST
54411: PUSH
54412: EMPTY
54413: LIST
54414: LIST
54415: LIST
54416: PPUSH
54417: CALL_OW 69
54421: ST_TO_ADDR
// if not tmp then
54422: LD_VAR 0 2
54426: NOT
54427: IFFALSE 54431
// exit ;
54429: GO 54480
// for i in tmp do
54431: LD_ADDR_VAR 0 1
54435: PUSH
54436: LD_VAR 0 2
54440: PUSH
54441: FOR_IN
54442: IFFALSE 54478
// begin if Crawls ( i ) then
54444: LD_VAR 0 1
54448: PPUSH
54449: CALL_OW 318
54453: IFFALSE 54464
// ComWalk ( i ) ;
54455: LD_VAR 0 1
54459: PPUSH
54460: CALL_OW 138
// SetClass ( i , 2 ) ;
54464: LD_VAR 0 1
54468: PPUSH
54469: LD_INT 2
54471: PPUSH
54472: CALL_OW 336
// end ;
54476: GO 54441
54478: POP
54479: POP
// end ;
54480: PPOPN 2
54482: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54483: LD_EXP 90
54487: PUSH
54488: LD_EXP 143
54492: AND
54493: IFFALSE 54774
54495: GO 54497
54497: DISABLE
54498: LD_INT 0
54500: PPUSH
54501: PPUSH
54502: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54503: LD_OWVAR 2
54507: PPUSH
54508: LD_INT 9
54510: PPUSH
54511: LD_INT 1
54513: PPUSH
54514: LD_INT 1
54516: PPUSH
54517: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54521: LD_INT 9
54523: PPUSH
54524: LD_OWVAR 2
54528: PPUSH
54529: CALL_OW 343
// uc_side := 9 ;
54533: LD_ADDR_OWVAR 20
54537: PUSH
54538: LD_INT 9
54540: ST_TO_ADDR
// uc_nation := 2 ;
54541: LD_ADDR_OWVAR 21
54545: PUSH
54546: LD_INT 2
54548: ST_TO_ADDR
// hc_name := Dark Warrior ;
54549: LD_ADDR_OWVAR 26
54553: PUSH
54554: LD_STRING Dark Warrior
54556: ST_TO_ADDR
// hc_gallery :=  ;
54557: LD_ADDR_OWVAR 33
54561: PUSH
54562: LD_STRING 
54564: ST_TO_ADDR
// hc_noskilllimit := true ;
54565: LD_ADDR_OWVAR 76
54569: PUSH
54570: LD_INT 1
54572: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54573: LD_ADDR_OWVAR 31
54577: PUSH
54578: LD_INT 30
54580: PUSH
54581: LD_INT 30
54583: PUSH
54584: LD_INT 30
54586: PUSH
54587: LD_INT 30
54589: PUSH
54590: EMPTY
54591: LIST
54592: LIST
54593: LIST
54594: LIST
54595: ST_TO_ADDR
// un := CreateHuman ;
54596: LD_ADDR_VAR 0 3
54600: PUSH
54601: CALL_OW 44
54605: ST_TO_ADDR
// hc_noskilllimit := false ;
54606: LD_ADDR_OWVAR 76
54610: PUSH
54611: LD_INT 0
54613: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54614: LD_VAR 0 3
54618: PPUSH
54619: LD_INT 1
54621: PPUSH
54622: CALL_OW 51
// p := 0 ;
54626: LD_ADDR_VAR 0 2
54630: PUSH
54631: LD_INT 0
54633: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54634: LD_INT 35
54636: PPUSH
54637: CALL_OW 67
// p := p + 1 ;
54641: LD_ADDR_VAR 0 2
54645: PUSH
54646: LD_VAR 0 2
54650: PUSH
54651: LD_INT 1
54653: PLUS
54654: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54655: LD_VAR 0 3
54659: PPUSH
54660: CALL_OW 256
54664: PUSH
54665: LD_INT 1000
54667: LESS
54668: IFFALSE 54682
// SetLives ( un , 1000 ) ;
54670: LD_VAR 0 3
54674: PPUSH
54675: LD_INT 1000
54677: PPUSH
54678: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54682: LD_VAR 0 3
54686: PPUSH
54687: LD_INT 81
54689: PUSH
54690: LD_OWVAR 2
54694: PUSH
54695: EMPTY
54696: LIST
54697: LIST
54698: PUSH
54699: LD_INT 91
54701: PUSH
54702: LD_VAR 0 3
54706: PUSH
54707: LD_INT 30
54709: PUSH
54710: EMPTY
54711: LIST
54712: LIST
54713: LIST
54714: PUSH
54715: EMPTY
54716: LIST
54717: LIST
54718: PPUSH
54719: CALL_OW 69
54723: PPUSH
54724: LD_VAR 0 3
54728: PPUSH
54729: CALL_OW 74
54733: PPUSH
54734: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54738: LD_VAR 0 2
54742: PUSH
54743: LD_INT 60
54745: GREATER
54746: PUSH
54747: LD_VAR 0 3
54751: PPUSH
54752: CALL_OW 301
54756: OR
54757: IFFALSE 54634
// if un then
54759: LD_VAR 0 3
54763: IFFALSE 54774
// RemoveUnit ( un ) ;
54765: LD_VAR 0 3
54769: PPUSH
54770: CALL_OW 64
// end ;
54774: PPOPN 3
54776: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
54777: LD_INT 0
54779: PPUSH
54780: PPUSH
54781: PPUSH
54782: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
54783: LD_ADDR_VAR 0 4
54787: PUSH
54788: LD_INT 22
54790: PUSH
54791: LD_OWVAR 2
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PUSH
54800: LD_INT 2
54802: PUSH
54803: LD_INT 30
54805: PUSH
54806: LD_INT 0
54808: PUSH
54809: EMPTY
54810: LIST
54811: LIST
54812: PUSH
54813: LD_INT 30
54815: PUSH
54816: LD_INT 1
54818: PUSH
54819: EMPTY
54820: LIST
54821: LIST
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: LIST
54827: PUSH
54828: EMPTY
54829: LIST
54830: LIST
54831: PPUSH
54832: CALL_OW 69
54836: ST_TO_ADDR
// if not tmp then
54837: LD_VAR 0 4
54841: NOT
54842: IFFALSE 54846
// exit ;
54844: GO 54905
// for i in tmp do
54846: LD_ADDR_VAR 0 2
54850: PUSH
54851: LD_VAR 0 4
54855: PUSH
54856: FOR_IN
54857: IFFALSE 54903
// for j = 1 to 3 do
54859: LD_ADDR_VAR 0 3
54863: PUSH
54864: DOUBLE
54865: LD_INT 1
54867: DEC
54868: ST_TO_ADDR
54869: LD_INT 3
54871: PUSH
54872: FOR_TO
54873: IFFALSE 54899
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
54875: LD_VAR 0 2
54879: PPUSH
54880: CALL_OW 274
54884: PPUSH
54885: LD_VAR 0 3
54889: PPUSH
54890: LD_INT 99999
54892: PPUSH
54893: CALL_OW 277
54897: GO 54872
54899: POP
54900: POP
54901: GO 54856
54903: POP
54904: POP
// end ;
54905: LD_VAR 0 1
54909: RET
// export function hHackSetLevel10 ; var i , j ; begin
54910: LD_INT 0
54912: PPUSH
54913: PPUSH
54914: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
54915: LD_ADDR_VAR 0 2
54919: PUSH
54920: LD_INT 21
54922: PUSH
54923: LD_INT 1
54925: PUSH
54926: EMPTY
54927: LIST
54928: LIST
54929: PPUSH
54930: CALL_OW 69
54934: PUSH
54935: FOR_IN
54936: IFFALSE 54988
// if IsSelected ( i ) then
54938: LD_VAR 0 2
54942: PPUSH
54943: CALL_OW 306
54947: IFFALSE 54986
// begin for j := 1 to 4 do
54949: LD_ADDR_VAR 0 3
54953: PUSH
54954: DOUBLE
54955: LD_INT 1
54957: DEC
54958: ST_TO_ADDR
54959: LD_INT 4
54961: PUSH
54962: FOR_TO
54963: IFFALSE 54984
// SetSkill ( i , j , 10 ) ;
54965: LD_VAR 0 2
54969: PPUSH
54970: LD_VAR 0 3
54974: PPUSH
54975: LD_INT 10
54977: PPUSH
54978: CALL_OW 237
54982: GO 54962
54984: POP
54985: POP
// end ;
54986: GO 54935
54988: POP
54989: POP
// end ;
54990: LD_VAR 0 1
54994: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
54995: LD_INT 0
54997: PPUSH
54998: PPUSH
54999: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
55000: LD_ADDR_VAR 0 2
55004: PUSH
55005: LD_INT 22
55007: PUSH
55008: LD_OWVAR 2
55012: PUSH
55013: EMPTY
55014: LIST
55015: LIST
55016: PUSH
55017: LD_INT 21
55019: PUSH
55020: LD_INT 1
55022: PUSH
55023: EMPTY
55024: LIST
55025: LIST
55026: PUSH
55027: EMPTY
55028: LIST
55029: LIST
55030: PPUSH
55031: CALL_OW 69
55035: PUSH
55036: FOR_IN
55037: IFFALSE 55078
// begin for j := 1 to 4 do
55039: LD_ADDR_VAR 0 3
55043: PUSH
55044: DOUBLE
55045: LD_INT 1
55047: DEC
55048: ST_TO_ADDR
55049: LD_INT 4
55051: PUSH
55052: FOR_TO
55053: IFFALSE 55074
// SetSkill ( i , j , 10 ) ;
55055: LD_VAR 0 2
55059: PPUSH
55060: LD_VAR 0 3
55064: PPUSH
55065: LD_INT 10
55067: PPUSH
55068: CALL_OW 237
55072: GO 55052
55074: POP
55075: POP
// end ;
55076: GO 55036
55078: POP
55079: POP
// end ;
55080: LD_VAR 0 1
55084: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
55085: LD_INT 0
55087: PPUSH
// uc_side := your_side ;
55088: LD_ADDR_OWVAR 20
55092: PUSH
55093: LD_OWVAR 2
55097: ST_TO_ADDR
// uc_nation := nation ;
55098: LD_ADDR_OWVAR 21
55102: PUSH
55103: LD_VAR 0 1
55107: ST_TO_ADDR
// InitHc ;
55108: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
55112: LD_INT 0
55114: PPUSH
55115: LD_VAR 0 2
55119: PPUSH
55120: LD_VAR 0 3
55124: PPUSH
55125: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
55129: CALL_OW 44
55133: PPUSH
55134: LD_INT 1
55136: PPUSH
55137: CALL_OW 51
// end ;
55141: LD_VAR 0 4
55145: RET
// export function hHackSpawnVehicle ; begin
55146: LD_INT 0
55148: PPUSH
// uc_side := your_side ;
55149: LD_ADDR_OWVAR 20
55153: PUSH
55154: LD_OWVAR 2
55158: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
55159: LD_ADDR_OWVAR 21
55163: PUSH
55164: LD_INT 1
55166: PPUSH
55167: LD_INT 3
55169: PPUSH
55170: CALL_OW 12
55174: ST_TO_ADDR
// InitVc ;
55175: CALL_OW 20
// case uc_nation of 1 :
55179: LD_OWVAR 21
55183: PUSH
55184: LD_INT 1
55186: DOUBLE
55187: EQUAL
55188: IFTRUE 55192
55190: GO 55336
55192: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
55193: LD_ADDR_OWVAR 37
55197: PUSH
55198: LD_INT 1
55200: PUSH
55201: LD_INT 2
55203: PUSH
55204: LD_INT 3
55206: PUSH
55207: LD_INT 4
55209: PUSH
55210: LD_INT 5
55212: PUSH
55213: EMPTY
55214: LIST
55215: LIST
55216: LIST
55217: LIST
55218: LIST
55219: PUSH
55220: LD_INT 1
55222: PPUSH
55223: LD_INT 5
55225: PPUSH
55226: CALL_OW 12
55230: ARRAY
55231: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
55232: LD_ADDR_OWVAR 39
55236: PUSH
55237: LD_INT 1
55239: PPUSH
55240: LD_INT 3
55242: PPUSH
55243: CALL_OW 12
55247: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
55248: LD_ADDR_OWVAR 38
55252: PUSH
55253: LD_INT 1
55255: PUSH
55256: LD_INT 2
55258: PUSH
55259: LD_INT 3
55261: PUSH
55262: EMPTY
55263: LIST
55264: LIST
55265: LIST
55266: PUSH
55267: LD_INT 1
55269: PPUSH
55270: LD_INT 3
55272: PPUSH
55273: CALL_OW 12
55277: ARRAY
55278: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
55279: LD_ADDR_OWVAR 40
55283: PUSH
55284: LD_INT 2
55286: PUSH
55287: LD_INT 4
55289: PUSH
55290: LD_INT 5
55292: PUSH
55293: LD_INT 3
55295: PUSH
55296: LD_INT 7
55298: PUSH
55299: LD_INT 8
55301: PUSH
55302: LD_INT 9
55304: PUSH
55305: LD_INT 10
55307: PUSH
55308: LD_INT 6
55310: PUSH
55311: EMPTY
55312: LIST
55313: LIST
55314: LIST
55315: LIST
55316: LIST
55317: LIST
55318: LIST
55319: LIST
55320: LIST
55321: PUSH
55322: LD_INT 1
55324: PPUSH
55325: LD_INT 9
55327: PPUSH
55328: CALL_OW 12
55332: ARRAY
55333: ST_TO_ADDR
// end ; 2 :
55334: GO 55601
55336: LD_INT 2
55338: DOUBLE
55339: EQUAL
55340: IFTRUE 55344
55342: GO 55468
55344: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
55345: LD_ADDR_OWVAR 37
55349: PUSH
55350: LD_INT 11
55352: PUSH
55353: LD_INT 12
55355: PUSH
55356: LD_INT 13
55358: PUSH
55359: LD_INT 14
55361: PUSH
55362: EMPTY
55363: LIST
55364: LIST
55365: LIST
55366: LIST
55367: PUSH
55368: LD_INT 1
55370: PPUSH
55371: LD_INT 4
55373: PPUSH
55374: CALL_OW 12
55378: ARRAY
55379: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
55380: LD_ADDR_OWVAR 39
55384: PUSH
55385: LD_INT 1
55387: PPUSH
55388: LD_INT 3
55390: PPUSH
55391: CALL_OW 12
55395: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
55396: LD_ADDR_OWVAR 38
55400: PUSH
55401: LD_INT 1
55403: PUSH
55404: LD_INT 2
55406: PUSH
55407: LD_INT 5
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: LIST
55414: PUSH
55415: LD_INT 1
55417: PPUSH
55418: LD_INT 3
55420: PPUSH
55421: CALL_OW 12
55425: ARRAY
55426: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
55427: LD_ADDR_OWVAR 40
55431: PUSH
55432: LD_INT 24
55434: PUSH
55435: LD_INT 26
55437: PUSH
55438: LD_INT 27
55440: PUSH
55441: LD_INT 28
55443: PUSH
55444: LD_INT 29
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: LIST
55451: LIST
55452: LIST
55453: PUSH
55454: LD_INT 1
55456: PPUSH
55457: LD_INT 5
55459: PPUSH
55460: CALL_OW 12
55464: ARRAY
55465: ST_TO_ADDR
// end ; 3 :
55466: GO 55601
55468: LD_INT 3
55470: DOUBLE
55471: EQUAL
55472: IFTRUE 55476
55474: GO 55600
55476: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
55477: LD_ADDR_OWVAR 37
55481: PUSH
55482: LD_INT 21
55484: PUSH
55485: LD_INT 23
55487: PUSH
55488: LD_INT 22
55490: PUSH
55491: LD_INT 24
55493: PUSH
55494: EMPTY
55495: LIST
55496: LIST
55497: LIST
55498: LIST
55499: PUSH
55500: LD_INT 1
55502: PPUSH
55503: LD_INT 4
55505: PPUSH
55506: CALL_OW 12
55510: ARRAY
55511: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
55512: LD_ADDR_OWVAR 39
55516: PUSH
55517: LD_INT 1
55519: PPUSH
55520: LD_INT 3
55522: PPUSH
55523: CALL_OW 12
55527: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
55528: LD_ADDR_OWVAR 38
55532: PUSH
55533: LD_INT 1
55535: PUSH
55536: LD_INT 3
55538: PUSH
55539: EMPTY
55540: LIST
55541: LIST
55542: PUSH
55543: LD_INT 1
55545: PPUSH
55546: LD_INT 2
55548: PPUSH
55549: CALL_OW 12
55553: ARRAY
55554: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
55555: LD_ADDR_OWVAR 40
55559: PUSH
55560: LD_INT 42
55562: PUSH
55563: LD_INT 43
55565: PUSH
55566: LD_INT 44
55568: PUSH
55569: LD_INT 46
55571: PUSH
55572: LD_INT 48
55574: PUSH
55575: LD_INT 47
55577: PUSH
55578: EMPTY
55579: LIST
55580: LIST
55581: LIST
55582: LIST
55583: LIST
55584: LIST
55585: PUSH
55586: LD_INT 1
55588: PPUSH
55589: LD_INT 6
55591: PPUSH
55592: CALL_OW 12
55596: ARRAY
55597: ST_TO_ADDR
// end ; end ;
55598: GO 55601
55600: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
55601: CALL_OW 45
55605: PPUSH
55606: LD_INT 1
55608: PPUSH
55609: CALL_OW 51
// end ;
55613: LD_VAR 0 1
55617: RET
// export hInvincible ; every 1 do
55618: GO 55620
55620: DISABLE
// hInvincible := [ ] ;
55621: LD_ADDR_EXP 144
55625: PUSH
55626: EMPTY
55627: ST_TO_ADDR
55628: END
// every 10 do var i ;
55629: GO 55631
55631: DISABLE
55632: LD_INT 0
55634: PPUSH
// begin enable ;
55635: ENABLE
// if not hInvincible then
55636: LD_EXP 144
55640: NOT
55641: IFFALSE 55645
// exit ;
55643: GO 55689
// for i in hInvincible do
55645: LD_ADDR_VAR 0 1
55649: PUSH
55650: LD_EXP 144
55654: PUSH
55655: FOR_IN
55656: IFFALSE 55687
// if GetLives ( i ) < 1000 then
55658: LD_VAR 0 1
55662: PPUSH
55663: CALL_OW 256
55667: PUSH
55668: LD_INT 1000
55670: LESS
55671: IFFALSE 55685
// SetLives ( i , 1000 ) ;
55673: LD_VAR 0 1
55677: PPUSH
55678: LD_INT 1000
55680: PPUSH
55681: CALL_OW 234
55685: GO 55655
55687: POP
55688: POP
// end ;
55689: PPOPN 1
55691: END
// export function hHackInvincible ; var i ; begin
55692: LD_INT 0
55694: PPUSH
55695: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
55696: LD_ADDR_VAR 0 2
55700: PUSH
55701: LD_INT 2
55703: PUSH
55704: LD_INT 21
55706: PUSH
55707: LD_INT 1
55709: PUSH
55710: EMPTY
55711: LIST
55712: LIST
55713: PUSH
55714: LD_INT 21
55716: PUSH
55717: LD_INT 2
55719: PUSH
55720: EMPTY
55721: LIST
55722: LIST
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: LIST
55728: PPUSH
55729: CALL_OW 69
55733: PUSH
55734: FOR_IN
55735: IFFALSE 55796
// if IsSelected ( i ) then
55737: LD_VAR 0 2
55741: PPUSH
55742: CALL_OW 306
55746: IFFALSE 55794
// begin if i in hInvincible then
55748: LD_VAR 0 2
55752: PUSH
55753: LD_EXP 144
55757: IN
55758: IFFALSE 55778
// hInvincible := hInvincible diff i else
55760: LD_ADDR_EXP 144
55764: PUSH
55765: LD_EXP 144
55769: PUSH
55770: LD_VAR 0 2
55774: DIFF
55775: ST_TO_ADDR
55776: GO 55794
// hInvincible := hInvincible union i ;
55778: LD_ADDR_EXP 144
55782: PUSH
55783: LD_EXP 144
55787: PUSH
55788: LD_VAR 0 2
55792: UNION
55793: ST_TO_ADDR
// end ;
55794: GO 55734
55796: POP
55797: POP
// end ;
55798: LD_VAR 0 1
55802: RET
// export function hHackInvisible ; var i , j ; begin
55803: LD_INT 0
55805: PPUSH
55806: PPUSH
55807: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
55808: LD_ADDR_VAR 0 2
55812: PUSH
55813: LD_INT 21
55815: PUSH
55816: LD_INT 1
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PPUSH
55823: CALL_OW 69
55827: PUSH
55828: FOR_IN
55829: IFFALSE 55853
// if IsSelected ( i ) then
55831: LD_VAR 0 2
55835: PPUSH
55836: CALL_OW 306
55840: IFFALSE 55851
// ComForceInvisible ( i ) ;
55842: LD_VAR 0 2
55846: PPUSH
55847: CALL_OW 496
55851: GO 55828
55853: POP
55854: POP
// end ;
55855: LD_VAR 0 1
55859: RET
// export function hHackChangeYourSide ; begin
55860: LD_INT 0
55862: PPUSH
// if your_side = 8 then
55863: LD_OWVAR 2
55867: PUSH
55868: LD_INT 8
55870: EQUAL
55871: IFFALSE 55883
// your_side := 0 else
55873: LD_ADDR_OWVAR 2
55877: PUSH
55878: LD_INT 0
55880: ST_TO_ADDR
55881: GO 55897
// your_side := your_side + 1 ;
55883: LD_ADDR_OWVAR 2
55887: PUSH
55888: LD_OWVAR 2
55892: PUSH
55893: LD_INT 1
55895: PLUS
55896: ST_TO_ADDR
// end ;
55897: LD_VAR 0 1
55901: RET
// export function hHackChangeUnitSide ; var i , j ; begin
55902: LD_INT 0
55904: PPUSH
55905: PPUSH
55906: PPUSH
// for i in all_units do
55907: LD_ADDR_VAR 0 2
55911: PUSH
55912: LD_OWVAR 3
55916: PUSH
55917: FOR_IN
55918: IFFALSE 55996
// if IsSelected ( i ) then
55920: LD_VAR 0 2
55924: PPUSH
55925: CALL_OW 306
55929: IFFALSE 55994
// begin j := GetSide ( i ) ;
55931: LD_ADDR_VAR 0 3
55935: PUSH
55936: LD_VAR 0 2
55940: PPUSH
55941: CALL_OW 255
55945: ST_TO_ADDR
// if j = 8 then
55946: LD_VAR 0 3
55950: PUSH
55951: LD_INT 8
55953: EQUAL
55954: IFFALSE 55966
// j := 0 else
55956: LD_ADDR_VAR 0 3
55960: PUSH
55961: LD_INT 0
55963: ST_TO_ADDR
55964: GO 55980
// j := j + 1 ;
55966: LD_ADDR_VAR 0 3
55970: PUSH
55971: LD_VAR 0 3
55975: PUSH
55976: LD_INT 1
55978: PLUS
55979: ST_TO_ADDR
// SetSide ( i , j ) ;
55980: LD_VAR 0 2
55984: PPUSH
55985: LD_VAR 0 3
55989: PPUSH
55990: CALL_OW 235
// end ;
55994: GO 55917
55996: POP
55997: POP
// end ;
55998: LD_VAR 0 1
56002: RET
// export function hHackFog ; begin
56003: LD_INT 0
56005: PPUSH
// FogOff ( true ) ;
56006: LD_INT 1
56008: PPUSH
56009: CALL_OW 344
// end ;
56013: LD_VAR 0 1
56017: RET
// export function hHackApeman ; begin
56018: LD_INT 0
56020: PPUSH
// uc_side := your_side ;
56021: LD_ADDR_OWVAR 20
56025: PUSH
56026: LD_OWVAR 2
56030: ST_TO_ADDR
// uc_nation := 0 ;
56031: LD_ADDR_OWVAR 21
56035: PUSH
56036: LD_INT 0
56038: ST_TO_ADDR
// hc_name :=  ;
56039: LD_ADDR_OWVAR 26
56043: PUSH
56044: LD_STRING 
56046: ST_TO_ADDR
// hc_gallery :=  ;
56047: LD_ADDR_OWVAR 33
56051: PUSH
56052: LD_STRING 
56054: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
56055: LD_ADDR_OWVAR 31
56059: PUSH
56060: LD_INT 0
56062: PUSH
56063: LD_INT 0
56065: PUSH
56066: LD_INT 0
56068: PUSH
56069: LD_INT 0
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: LIST
56076: LIST
56077: ST_TO_ADDR
// hc_class := class_apeman ;
56078: LD_ADDR_OWVAR 28
56082: PUSH
56083: LD_INT 12
56085: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
56086: CALL_OW 44
56090: PPUSH
56091: LD_INT 1
56093: PPUSH
56094: CALL_OW 51
// end ;
56098: LD_VAR 0 1
56102: RET
// export function hHackBoom ; begin
56103: LD_INT 0
56105: PPUSH
// uc_side := your_side ;
56106: LD_ADDR_OWVAR 20
56110: PUSH
56111: LD_OWVAR 2
56115: ST_TO_ADDR
// uc_nation := 1 ;
56116: LD_ADDR_OWVAR 21
56120: PUSH
56121: LD_INT 1
56123: ST_TO_ADDR
// vc_chassis := us_morphling ;
56124: LD_ADDR_OWVAR 37
56128: PUSH
56129: LD_INT 5
56131: ST_TO_ADDR
// vc_engine := engine_siberite ;
56132: LD_ADDR_OWVAR 39
56136: PUSH
56137: LD_INT 3
56139: ST_TO_ADDR
// vc_control := control_computer ;
56140: LD_ADDR_OWVAR 38
56144: PUSH
56145: LD_INT 3
56147: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
56148: LD_ADDR_OWVAR 40
56152: PUSH
56153: LD_INT 8
56155: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
56156: CALL_OW 45
56160: PPUSH
56161: LD_INT 1
56163: PPUSH
56164: CALL_OW 51
// end ; end_of_file
56168: LD_VAR 0 1
56172: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56173: LD_INT 0
56175: PPUSH
56176: PPUSH
56177: PPUSH
56178: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56179: LD_VAR 0 1
56183: PPUSH
56184: CALL_OW 264
56188: PUSH
56189: LD_EXP 79
56193: EQUAL
56194: IFFALSE 56266
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56196: LD_INT 68
56198: PPUSH
56199: LD_VAR 0 1
56203: PPUSH
56204: CALL_OW 255
56208: PPUSH
56209: CALL_OW 321
56213: PUSH
56214: LD_INT 2
56216: EQUAL
56217: IFFALSE 56229
// eff := 70 else
56219: LD_ADDR_VAR 0 4
56223: PUSH
56224: LD_INT 70
56226: ST_TO_ADDR
56227: GO 56237
// eff := 30 ;
56229: LD_ADDR_VAR 0 4
56233: PUSH
56234: LD_INT 30
56236: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56237: LD_VAR 0 1
56241: PPUSH
56242: CALL_OW 250
56246: PPUSH
56247: LD_VAR 0 1
56251: PPUSH
56252: CALL_OW 251
56256: PPUSH
56257: LD_VAR 0 4
56261: PPUSH
56262: CALL_OW 495
// end ; end ;
56266: LD_VAR 0 2
56270: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56271: LD_INT 0
56273: PPUSH
// end ;
56274: LD_VAR 0 4
56278: RET
// export function SOS_Command ( cmd ) ; begin
56279: LD_INT 0
56281: PPUSH
// end ;
56282: LD_VAR 0 2
56286: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y ) do begin if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
56287: LD_VAR 0 1
56291: PUSH
56292: LD_INT 254
56294: EQUAL
56295: PUSH
56296: LD_VAR 0 2
56300: PPUSH
56301: CALL_OW 264
56305: PUSH
56306: LD_EXP 77
56310: EQUAL
56311: AND
56312: PUSH
56313: LD_VAR 0 3
56317: PPUSH
56318: CALL_OW 263
56322: PUSH
56323: LD_INT 3
56325: EQUAL
56326: AND
56327: IFFALSE 56343
// HackDestroyVehicle ( unit , selectedUnit ) ;
56329: LD_VAR 0 2
56333: PPUSH
56334: LD_VAR 0 3
56338: PPUSH
56339: CALL 57850 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
56343: LD_VAR 0 1
56347: PUSH
56348: LD_INT 255
56350: EQUAL
56351: PUSH
56352: LD_VAR 0 2
56356: PPUSH
56357: CALL_OW 264
56361: PUSH
56362: LD_INT 14
56364: PUSH
56365: LD_INT 53
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: IN
56372: AND
56373: PUSH
56374: LD_VAR 0 4
56378: PPUSH
56379: LD_VAR 0 5
56383: PPUSH
56384: CALL_OW 488
56388: AND
56389: IFFALSE 56413
// CutTreeXYR ( unit , x , y , 12 ) ;
56391: LD_VAR 0 2
56395: PPUSH
56396: LD_VAR 0 4
56400: PPUSH
56401: LD_VAR 0 5
56405: PPUSH
56406: LD_INT 12
56408: PPUSH
56409: CALL 56416 0 4
// end ;
56413: PPOPN 5
56415: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
56416: LD_INT 0
56418: PPUSH
56419: PPUSH
56420: PPUSH
56421: PPUSH
56422: PPUSH
56423: PPUSH
56424: PPUSH
56425: PPUSH
56426: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
56427: LD_VAR 0 1
56431: NOT
56432: PUSH
56433: LD_VAR 0 2
56437: PPUSH
56438: LD_VAR 0 3
56442: PPUSH
56443: CALL_OW 488
56447: NOT
56448: OR
56449: PUSH
56450: LD_VAR 0 4
56454: NOT
56455: OR
56456: IFFALSE 56460
// exit ;
56458: GO 56800
// list := [ ] ;
56460: LD_ADDR_VAR 0 13
56464: PUSH
56465: EMPTY
56466: ST_TO_ADDR
// if x - r < 0 then
56467: LD_VAR 0 2
56471: PUSH
56472: LD_VAR 0 4
56476: MINUS
56477: PUSH
56478: LD_INT 0
56480: LESS
56481: IFFALSE 56493
// min_x := 0 else
56483: LD_ADDR_VAR 0 7
56487: PUSH
56488: LD_INT 0
56490: ST_TO_ADDR
56491: GO 56509
// min_x := x - r ;
56493: LD_ADDR_VAR 0 7
56497: PUSH
56498: LD_VAR 0 2
56502: PUSH
56503: LD_VAR 0 4
56507: MINUS
56508: ST_TO_ADDR
// if y - r < 0 then
56509: LD_VAR 0 3
56513: PUSH
56514: LD_VAR 0 4
56518: MINUS
56519: PUSH
56520: LD_INT 0
56522: LESS
56523: IFFALSE 56535
// min_y := 0 else
56525: LD_ADDR_VAR 0 8
56529: PUSH
56530: LD_INT 0
56532: ST_TO_ADDR
56533: GO 56551
// min_y := y - r ;
56535: LD_ADDR_VAR 0 8
56539: PUSH
56540: LD_VAR 0 3
56544: PUSH
56545: LD_VAR 0 4
56549: MINUS
56550: ST_TO_ADDR
// max_x := x + r ;
56551: LD_ADDR_VAR 0 9
56555: PUSH
56556: LD_VAR 0 2
56560: PUSH
56561: LD_VAR 0 4
56565: PLUS
56566: ST_TO_ADDR
// max_y := y + r ;
56567: LD_ADDR_VAR 0 10
56571: PUSH
56572: LD_VAR 0 3
56576: PUSH
56577: LD_VAR 0 4
56581: PLUS
56582: ST_TO_ADDR
// for _x = min_x to max_x do
56583: LD_ADDR_VAR 0 11
56587: PUSH
56588: DOUBLE
56589: LD_VAR 0 7
56593: DEC
56594: ST_TO_ADDR
56595: LD_VAR 0 9
56599: PUSH
56600: FOR_TO
56601: IFFALSE 56718
// for _y = min_y to max_y do
56603: LD_ADDR_VAR 0 12
56607: PUSH
56608: DOUBLE
56609: LD_VAR 0 8
56613: DEC
56614: ST_TO_ADDR
56615: LD_VAR 0 10
56619: PUSH
56620: FOR_TO
56621: IFFALSE 56714
// begin if not ValidHex ( _x , _y ) then
56623: LD_VAR 0 11
56627: PPUSH
56628: LD_VAR 0 12
56632: PPUSH
56633: CALL_OW 488
56637: NOT
56638: IFFALSE 56642
// continue ;
56640: GO 56620
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
56642: LD_VAR 0 11
56646: PPUSH
56647: LD_VAR 0 12
56651: PPUSH
56652: CALL_OW 351
56656: PUSH
56657: LD_VAR 0 11
56661: PPUSH
56662: LD_VAR 0 12
56666: PPUSH
56667: CALL_OW 554
56671: AND
56672: IFFALSE 56712
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
56674: LD_ADDR_VAR 0 13
56678: PUSH
56679: LD_VAR 0 13
56683: PPUSH
56684: LD_VAR 0 13
56688: PUSH
56689: LD_INT 1
56691: PLUS
56692: PPUSH
56693: LD_VAR 0 11
56697: PUSH
56698: LD_VAR 0 12
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: PPUSH
56707: CALL_OW 2
56711: ST_TO_ADDR
// end ;
56712: GO 56620
56714: POP
56715: POP
56716: GO 56600
56718: POP
56719: POP
// if not list then
56720: LD_VAR 0 13
56724: NOT
56725: IFFALSE 56729
// exit ;
56727: GO 56800
// for i in list do
56729: LD_ADDR_VAR 0 6
56733: PUSH
56734: LD_VAR 0 13
56738: PUSH
56739: FOR_IN
56740: IFFALSE 56798
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
56742: LD_VAR 0 1
56746: PPUSH
56747: LD_STRING M
56749: PUSH
56750: LD_VAR 0 6
56754: PUSH
56755: LD_INT 1
56757: ARRAY
56758: PUSH
56759: LD_VAR 0 6
56763: PUSH
56764: LD_INT 2
56766: ARRAY
56767: PUSH
56768: LD_INT 0
56770: PUSH
56771: LD_INT 0
56773: PUSH
56774: LD_INT 0
56776: PUSH
56777: LD_INT 0
56779: PUSH
56780: EMPTY
56781: LIST
56782: LIST
56783: LIST
56784: LIST
56785: LIST
56786: LIST
56787: LIST
56788: PUSH
56789: EMPTY
56790: LIST
56791: PPUSH
56792: CALL_OW 447
56796: GO 56739
56798: POP
56799: POP
// end ;
56800: LD_VAR 0 5
56804: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
56805: LD_EXP 145
56809: NOT
56810: IFFALSE 56860
56812: GO 56814
56814: DISABLE
// begin initHack := true ;
56815: LD_ADDR_EXP 145
56819: PUSH
56820: LD_INT 1
56822: ST_TO_ADDR
// hackTanks := [ ] ;
56823: LD_ADDR_EXP 146
56827: PUSH
56828: EMPTY
56829: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
56830: LD_ADDR_EXP 147
56834: PUSH
56835: EMPTY
56836: ST_TO_ADDR
// hackLimit := 3 ;
56837: LD_ADDR_EXP 148
56841: PUSH
56842: LD_INT 3
56844: ST_TO_ADDR
// hackDist := 12 ;
56845: LD_ADDR_EXP 149
56849: PUSH
56850: LD_INT 12
56852: ST_TO_ADDR
// hackCounter := [ ] ;
56853: LD_ADDR_EXP 150
56857: PUSH
56858: EMPTY
56859: ST_TO_ADDR
// end ;
56860: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
56861: LD_EXP 145
56865: PUSH
56866: LD_INT 34
56868: PUSH
56869: LD_EXP 77
56873: PUSH
56874: EMPTY
56875: LIST
56876: LIST
56877: PPUSH
56878: CALL_OW 69
56882: AND
56883: IFFALSE 57138
56885: GO 56887
56887: DISABLE
56888: LD_INT 0
56890: PPUSH
56891: PPUSH
// begin enable ;
56892: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
56893: LD_ADDR_VAR 0 1
56897: PUSH
56898: LD_INT 34
56900: PUSH
56901: LD_EXP 77
56905: PUSH
56906: EMPTY
56907: LIST
56908: LIST
56909: PPUSH
56910: CALL_OW 69
56914: PUSH
56915: FOR_IN
56916: IFFALSE 57136
// begin if not i in hackTanks then
56918: LD_VAR 0 1
56922: PUSH
56923: LD_EXP 146
56927: IN
56928: NOT
56929: IFFALSE 57012
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
56931: LD_ADDR_EXP 146
56935: PUSH
56936: LD_EXP 146
56940: PPUSH
56941: LD_EXP 146
56945: PUSH
56946: LD_INT 1
56948: PLUS
56949: PPUSH
56950: LD_VAR 0 1
56954: PPUSH
56955: CALL_OW 1
56959: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
56960: LD_ADDR_EXP 147
56964: PUSH
56965: LD_EXP 147
56969: PPUSH
56970: LD_EXP 147
56974: PUSH
56975: LD_INT 1
56977: PLUS
56978: PPUSH
56979: EMPTY
56980: PPUSH
56981: CALL_OW 1
56985: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
56986: LD_ADDR_EXP 150
56990: PUSH
56991: LD_EXP 150
56995: PPUSH
56996: LD_EXP 150
57000: PUSH
57001: LD_INT 1
57003: PLUS
57004: PPUSH
57005: EMPTY
57006: PPUSH
57007: CALL_OW 1
57011: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57012: LD_VAR 0 1
57016: PPUSH
57017: CALL_OW 302
57021: NOT
57022: IFFALSE 57035
// begin HackUnlinkAll ( i ) ;
57024: LD_VAR 0 1
57028: PPUSH
57029: CALL 57141 0 1
// continue ;
57033: GO 56915
// end ; HackCheckCapturedStatus ( i ) ;
57035: LD_VAR 0 1
57039: PPUSH
57040: CALL 57584 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57044: LD_ADDR_VAR 0 2
57048: PUSH
57049: LD_INT 81
57051: PUSH
57052: LD_VAR 0 1
57056: PPUSH
57057: CALL_OW 255
57061: PUSH
57062: EMPTY
57063: LIST
57064: LIST
57065: PUSH
57066: LD_INT 33
57068: PUSH
57069: LD_INT 3
57071: PUSH
57072: EMPTY
57073: LIST
57074: LIST
57075: PUSH
57076: LD_INT 91
57078: PUSH
57079: LD_VAR 0 1
57083: PUSH
57084: LD_EXP 149
57088: PUSH
57089: EMPTY
57090: LIST
57091: LIST
57092: LIST
57093: PUSH
57094: LD_INT 50
57096: PUSH
57097: EMPTY
57098: LIST
57099: PUSH
57100: EMPTY
57101: LIST
57102: LIST
57103: LIST
57104: LIST
57105: PPUSH
57106: CALL_OW 69
57110: ST_TO_ADDR
// if not tmp then
57111: LD_VAR 0 2
57115: NOT
57116: IFFALSE 57120
// continue ;
57118: GO 56915
// HackLink ( i , tmp ) ;
57120: LD_VAR 0 1
57124: PPUSH
57125: LD_VAR 0 2
57129: PPUSH
57130: CALL 57277 0 2
// end ;
57134: GO 56915
57136: POP
57137: POP
// end ;
57138: PPOPN 2
57140: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57141: LD_INT 0
57143: PPUSH
57144: PPUSH
57145: PPUSH
// if not hack in hackTanks then
57146: LD_VAR 0 1
57150: PUSH
57151: LD_EXP 146
57155: IN
57156: NOT
57157: IFFALSE 57161
// exit ;
57159: GO 57272
// index := GetElementIndex ( hackTanks , hack ) ;
57161: LD_ADDR_VAR 0 4
57165: PUSH
57166: LD_EXP 146
57170: PPUSH
57171: LD_VAR 0 1
57175: PPUSH
57176: CALL 62692 0 2
57180: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
57181: LD_EXP 147
57185: PUSH
57186: LD_VAR 0 4
57190: ARRAY
57191: IFFALSE 57272
// begin for i in hackTanksCaptured [ index ] do
57193: LD_ADDR_VAR 0 3
57197: PUSH
57198: LD_EXP 147
57202: PUSH
57203: LD_VAR 0 4
57207: ARRAY
57208: PUSH
57209: FOR_IN
57210: IFFALSE 57236
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
57212: LD_VAR 0 3
57216: PUSH
57217: LD_INT 1
57219: ARRAY
57220: PPUSH
57221: LD_VAR 0 3
57225: PUSH
57226: LD_INT 2
57228: ARRAY
57229: PPUSH
57230: CALL_OW 235
57234: GO 57209
57236: POP
57237: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
57238: LD_ADDR_EXP 147
57242: PUSH
57243: LD_EXP 147
57247: PPUSH
57248: LD_VAR 0 4
57252: PPUSH
57253: EMPTY
57254: PPUSH
57255: CALL_OW 1
57259: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
57260: LD_VAR 0 1
57264: PPUSH
57265: LD_INT 0
57267: PPUSH
57268: CALL_OW 505
// end ; end ;
57272: LD_VAR 0 2
57276: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
57277: LD_INT 0
57279: PPUSH
57280: PPUSH
57281: PPUSH
// if not hack in hackTanks or not vehicles then
57282: LD_VAR 0 1
57286: PUSH
57287: LD_EXP 146
57291: IN
57292: NOT
57293: PUSH
57294: LD_VAR 0 2
57298: NOT
57299: OR
57300: IFFALSE 57304
// exit ;
57302: GO 57579
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
57304: LD_ADDR_VAR 0 2
57308: PUSH
57309: LD_VAR 0 1
57313: PPUSH
57314: LD_VAR 0 2
57318: PPUSH
57319: LD_INT 1
57321: PPUSH
57322: LD_INT 1
57324: PPUSH
57325: CALL 63342 0 4
57329: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
57330: LD_ADDR_VAR 0 5
57334: PUSH
57335: LD_EXP 146
57339: PPUSH
57340: LD_VAR 0 1
57344: PPUSH
57345: CALL 62692 0 2
57349: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
57350: LD_EXP 147
57354: PUSH
57355: LD_VAR 0 5
57359: ARRAY
57360: PUSH
57361: LD_EXP 148
57365: LESS
57366: IFFALSE 57555
// begin for i := 1 to vehicles do
57368: LD_ADDR_VAR 0 4
57372: PUSH
57373: DOUBLE
57374: LD_INT 1
57376: DEC
57377: ST_TO_ADDR
57378: LD_VAR 0 2
57382: PUSH
57383: FOR_TO
57384: IFFALSE 57553
// begin if hackTanksCaptured [ index ] = hackLimit then
57386: LD_EXP 147
57390: PUSH
57391: LD_VAR 0 5
57395: ARRAY
57396: PUSH
57397: LD_EXP 148
57401: EQUAL
57402: IFFALSE 57406
// break ;
57404: GO 57553
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
57406: LD_ADDR_EXP 150
57410: PUSH
57411: LD_EXP 150
57415: PPUSH
57416: LD_VAR 0 5
57420: PPUSH
57421: LD_EXP 150
57425: PUSH
57426: LD_VAR 0 5
57430: ARRAY
57431: PUSH
57432: LD_INT 1
57434: PLUS
57435: PPUSH
57436: CALL_OW 1
57440: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
57441: LD_ADDR_EXP 147
57445: PUSH
57446: LD_EXP 147
57450: PPUSH
57451: LD_VAR 0 5
57455: PUSH
57456: LD_EXP 147
57460: PUSH
57461: LD_VAR 0 5
57465: ARRAY
57466: PUSH
57467: LD_INT 1
57469: PLUS
57470: PUSH
57471: EMPTY
57472: LIST
57473: LIST
57474: PPUSH
57475: LD_VAR 0 2
57479: PUSH
57480: LD_VAR 0 4
57484: ARRAY
57485: PUSH
57486: LD_VAR 0 2
57490: PUSH
57491: LD_VAR 0 4
57495: ARRAY
57496: PPUSH
57497: CALL_OW 255
57501: PUSH
57502: EMPTY
57503: LIST
57504: LIST
57505: PPUSH
57506: CALL 62907 0 3
57510: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
57511: LD_VAR 0 2
57515: PUSH
57516: LD_VAR 0 4
57520: ARRAY
57521: PPUSH
57522: LD_VAR 0 1
57526: PPUSH
57527: CALL_OW 255
57531: PPUSH
57532: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
57536: LD_VAR 0 2
57540: PUSH
57541: LD_VAR 0 4
57545: ARRAY
57546: PPUSH
57547: CALL_OW 141
// end ;
57551: GO 57383
57553: POP
57554: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
57555: LD_VAR 0 1
57559: PPUSH
57560: LD_EXP 147
57564: PUSH
57565: LD_VAR 0 5
57569: ARRAY
57570: PUSH
57571: LD_INT 0
57573: PLUS
57574: PPUSH
57575: CALL_OW 505
// end ;
57579: LD_VAR 0 3
57583: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
57584: LD_INT 0
57586: PPUSH
57587: PPUSH
57588: PPUSH
57589: PPUSH
// if not hack in hackTanks then
57590: LD_VAR 0 1
57594: PUSH
57595: LD_EXP 146
57599: IN
57600: NOT
57601: IFFALSE 57605
// exit ;
57603: GO 57845
// index := GetElementIndex ( hackTanks , hack ) ;
57605: LD_ADDR_VAR 0 4
57609: PUSH
57610: LD_EXP 146
57614: PPUSH
57615: LD_VAR 0 1
57619: PPUSH
57620: CALL 62692 0 2
57624: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
57625: LD_ADDR_VAR 0 3
57629: PUSH
57630: DOUBLE
57631: LD_EXP 147
57635: PUSH
57636: LD_VAR 0 4
57640: ARRAY
57641: INC
57642: ST_TO_ADDR
57643: LD_INT 1
57645: PUSH
57646: FOR_DOWNTO
57647: IFFALSE 57819
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
57649: LD_ADDR_VAR 0 5
57653: PUSH
57654: LD_EXP 147
57658: PUSH
57659: LD_VAR 0 4
57663: ARRAY
57664: PUSH
57665: LD_VAR 0 3
57669: ARRAY
57670: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
57671: LD_VAR 0 5
57675: PUSH
57676: LD_INT 1
57678: ARRAY
57679: PPUSH
57680: CALL_OW 302
57684: NOT
57685: PUSH
57686: LD_VAR 0 5
57690: PUSH
57691: LD_INT 1
57693: ARRAY
57694: PPUSH
57695: CALL_OW 255
57699: PUSH
57700: LD_VAR 0 1
57704: PPUSH
57705: CALL_OW 255
57709: NONEQUAL
57710: OR
57711: IFFALSE 57817
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
57713: LD_VAR 0 5
57717: PUSH
57718: LD_INT 1
57720: ARRAY
57721: PPUSH
57722: CALL_OW 305
57726: PUSH
57727: LD_VAR 0 5
57731: PUSH
57732: LD_INT 1
57734: ARRAY
57735: PPUSH
57736: CALL_OW 255
57740: PUSH
57741: LD_VAR 0 1
57745: PPUSH
57746: CALL_OW 255
57750: EQUAL
57751: AND
57752: IFFALSE 57776
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
57754: LD_VAR 0 5
57758: PUSH
57759: LD_INT 1
57761: ARRAY
57762: PPUSH
57763: LD_VAR 0 5
57767: PUSH
57768: LD_INT 2
57770: ARRAY
57771: PPUSH
57772: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
57776: LD_ADDR_EXP 147
57780: PUSH
57781: LD_EXP 147
57785: PPUSH
57786: LD_VAR 0 4
57790: PPUSH
57791: LD_EXP 147
57795: PUSH
57796: LD_VAR 0 4
57800: ARRAY
57801: PPUSH
57802: LD_VAR 0 3
57806: PPUSH
57807: CALL_OW 3
57811: PPUSH
57812: CALL_OW 1
57816: ST_TO_ADDR
// end ; end ;
57817: GO 57646
57819: POP
57820: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
57821: LD_VAR 0 1
57825: PPUSH
57826: LD_EXP 147
57830: PUSH
57831: LD_VAR 0 4
57835: ARRAY
57836: PUSH
57837: LD_INT 0
57839: PLUS
57840: PPUSH
57841: CALL_OW 505
// end ;
57845: LD_VAR 0 2
57849: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
57850: LD_INT 0
57852: PPUSH
57853: PPUSH
57854: PPUSH
57855: PPUSH
// if not hack in hackTanks then
57856: LD_VAR 0 1
57860: PUSH
57861: LD_EXP 146
57865: IN
57866: NOT
57867: IFFALSE 57871
// exit ;
57869: GO 57956
// index := GetElementIndex ( hackTanks , hack ) ;
57871: LD_ADDR_VAR 0 5
57875: PUSH
57876: LD_EXP 146
57880: PPUSH
57881: LD_VAR 0 1
57885: PPUSH
57886: CALL 62692 0 2
57890: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
57891: LD_ADDR_VAR 0 4
57895: PUSH
57896: DOUBLE
57897: LD_INT 1
57899: DEC
57900: ST_TO_ADDR
57901: LD_EXP 147
57905: PUSH
57906: LD_VAR 0 5
57910: ARRAY
57911: PUSH
57912: FOR_TO
57913: IFFALSE 57954
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
57915: LD_EXP 147
57919: PUSH
57920: LD_VAR 0 5
57924: ARRAY
57925: PUSH
57926: LD_VAR 0 4
57930: ARRAY
57931: PUSH
57932: LD_INT 1
57934: ARRAY
57935: PUSH
57936: LD_VAR 0 2
57940: EQUAL
57941: IFFALSE 57952
// KillUnit ( vehicle ) ;
57943: LD_VAR 0 2
57947: PPUSH
57948: CALL_OW 66
57952: GO 57912
57954: POP
57955: POP
// end ; end_of_file
57956: LD_VAR 0 3
57960: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
57961: LD_INT 0
57963: PPUSH
57964: PPUSH
// if exist_mode then
57965: LD_VAR 0 2
57969: IFFALSE 57994
// unit := CreateCharacter ( prefix & ident ) else
57971: LD_ADDR_VAR 0 5
57975: PUSH
57976: LD_VAR 0 3
57980: PUSH
57981: LD_VAR 0 1
57985: STR
57986: PPUSH
57987: CALL_OW 34
57991: ST_TO_ADDR
57992: GO 58009
// unit := NewCharacter ( ident ) ;
57994: LD_ADDR_VAR 0 5
57998: PUSH
57999: LD_VAR 0 1
58003: PPUSH
58004: CALL_OW 25
58008: ST_TO_ADDR
// result := unit ;
58009: LD_ADDR_VAR 0 4
58013: PUSH
58014: LD_VAR 0 5
58018: ST_TO_ADDR
// end ;
58019: LD_VAR 0 4
58023: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
58024: LD_INT 0
58026: PPUSH
58027: PPUSH
// if not side or not nation then
58028: LD_VAR 0 1
58032: NOT
58033: PUSH
58034: LD_VAR 0 2
58038: NOT
58039: OR
58040: IFFALSE 58044
// exit ;
58042: GO 58808
// case nation of nation_american :
58044: LD_VAR 0 2
58048: PUSH
58049: LD_INT 1
58051: DOUBLE
58052: EQUAL
58053: IFTRUE 58057
58055: GO 58271
58057: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
58058: LD_ADDR_VAR 0 4
58062: PUSH
58063: LD_INT 35
58065: PUSH
58066: LD_INT 45
58068: PUSH
58069: LD_INT 46
58071: PUSH
58072: LD_INT 47
58074: PUSH
58075: LD_INT 82
58077: PUSH
58078: LD_INT 83
58080: PUSH
58081: LD_INT 84
58083: PUSH
58084: LD_INT 85
58086: PUSH
58087: LD_INT 86
58089: PUSH
58090: LD_INT 1
58092: PUSH
58093: LD_INT 2
58095: PUSH
58096: LD_INT 6
58098: PUSH
58099: LD_INT 15
58101: PUSH
58102: LD_INT 16
58104: PUSH
58105: LD_INT 7
58107: PUSH
58108: LD_INT 12
58110: PUSH
58111: LD_INT 13
58113: PUSH
58114: LD_INT 10
58116: PUSH
58117: LD_INT 14
58119: PUSH
58120: LD_INT 20
58122: PUSH
58123: LD_INT 21
58125: PUSH
58126: LD_INT 22
58128: PUSH
58129: LD_INT 25
58131: PUSH
58132: LD_INT 32
58134: PUSH
58135: LD_INT 27
58137: PUSH
58138: LD_INT 36
58140: PUSH
58141: LD_INT 69
58143: PUSH
58144: LD_INT 39
58146: PUSH
58147: LD_INT 34
58149: PUSH
58150: LD_INT 40
58152: PUSH
58153: LD_INT 48
58155: PUSH
58156: LD_INT 49
58158: PUSH
58159: LD_INT 50
58161: PUSH
58162: LD_INT 51
58164: PUSH
58165: LD_INT 52
58167: PUSH
58168: LD_INT 53
58170: PUSH
58171: LD_INT 54
58173: PUSH
58174: LD_INT 55
58176: PUSH
58177: LD_INT 56
58179: PUSH
58180: LD_INT 57
58182: PUSH
58183: LD_INT 58
58185: PUSH
58186: LD_INT 59
58188: PUSH
58189: LD_INT 60
58191: PUSH
58192: LD_INT 61
58194: PUSH
58195: LD_INT 62
58197: PUSH
58198: LD_INT 80
58200: PUSH
58201: LD_INT 82
58203: PUSH
58204: LD_INT 83
58206: PUSH
58207: LD_INT 84
58209: PUSH
58210: LD_INT 85
58212: PUSH
58213: LD_INT 86
58215: PUSH
58216: EMPTY
58217: LIST
58218: LIST
58219: LIST
58220: LIST
58221: LIST
58222: LIST
58223: LIST
58224: LIST
58225: LIST
58226: LIST
58227: LIST
58228: LIST
58229: LIST
58230: LIST
58231: LIST
58232: LIST
58233: LIST
58234: LIST
58235: LIST
58236: LIST
58237: LIST
58238: LIST
58239: LIST
58240: LIST
58241: LIST
58242: LIST
58243: LIST
58244: LIST
58245: LIST
58246: LIST
58247: LIST
58248: LIST
58249: LIST
58250: LIST
58251: LIST
58252: LIST
58253: LIST
58254: LIST
58255: LIST
58256: LIST
58257: LIST
58258: LIST
58259: LIST
58260: LIST
58261: LIST
58262: LIST
58263: LIST
58264: LIST
58265: LIST
58266: LIST
58267: LIST
58268: ST_TO_ADDR
58269: GO 58732
58271: LD_INT 2
58273: DOUBLE
58274: EQUAL
58275: IFTRUE 58279
58277: GO 58501
58279: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
58280: LD_ADDR_VAR 0 4
58284: PUSH
58285: LD_INT 35
58287: PUSH
58288: LD_INT 45
58290: PUSH
58291: LD_INT 46
58293: PUSH
58294: LD_INT 47
58296: PUSH
58297: LD_INT 82
58299: PUSH
58300: LD_INT 83
58302: PUSH
58303: LD_INT 84
58305: PUSH
58306: LD_INT 85
58308: PUSH
58309: LD_INT 87
58311: PUSH
58312: LD_INT 70
58314: PUSH
58315: LD_INT 1
58317: PUSH
58318: LD_INT 11
58320: PUSH
58321: LD_INT 3
58323: PUSH
58324: LD_INT 4
58326: PUSH
58327: LD_INT 5
58329: PUSH
58330: LD_INT 6
58332: PUSH
58333: LD_INT 15
58335: PUSH
58336: LD_INT 18
58338: PUSH
58339: LD_INT 7
58341: PUSH
58342: LD_INT 17
58344: PUSH
58345: LD_INT 8
58347: PUSH
58348: LD_INT 20
58350: PUSH
58351: LD_INT 21
58353: PUSH
58354: LD_INT 22
58356: PUSH
58357: LD_INT 72
58359: PUSH
58360: LD_INT 26
58362: PUSH
58363: LD_INT 69
58365: PUSH
58366: LD_INT 39
58368: PUSH
58369: LD_INT 40
58371: PUSH
58372: LD_INT 41
58374: PUSH
58375: LD_INT 42
58377: PUSH
58378: LD_INT 43
58380: PUSH
58381: LD_INT 48
58383: PUSH
58384: LD_INT 49
58386: PUSH
58387: LD_INT 50
58389: PUSH
58390: LD_INT 51
58392: PUSH
58393: LD_INT 52
58395: PUSH
58396: LD_INT 53
58398: PUSH
58399: LD_INT 54
58401: PUSH
58402: LD_INT 55
58404: PUSH
58405: LD_INT 56
58407: PUSH
58408: LD_INT 60
58410: PUSH
58411: LD_INT 61
58413: PUSH
58414: LD_INT 62
58416: PUSH
58417: LD_INT 66
58419: PUSH
58420: LD_INT 67
58422: PUSH
58423: LD_INT 68
58425: PUSH
58426: LD_INT 81
58428: PUSH
58429: LD_INT 82
58431: PUSH
58432: LD_INT 83
58434: PUSH
58435: LD_INT 84
58437: PUSH
58438: LD_INT 85
58440: PUSH
58441: LD_INT 87
58443: PUSH
58444: EMPTY
58445: LIST
58446: LIST
58447: LIST
58448: LIST
58449: LIST
58450: LIST
58451: LIST
58452: LIST
58453: LIST
58454: LIST
58455: LIST
58456: LIST
58457: LIST
58458: LIST
58459: LIST
58460: LIST
58461: LIST
58462: LIST
58463: LIST
58464: LIST
58465: LIST
58466: LIST
58467: LIST
58468: LIST
58469: LIST
58470: LIST
58471: LIST
58472: LIST
58473: LIST
58474: LIST
58475: LIST
58476: LIST
58477: LIST
58478: LIST
58479: LIST
58480: LIST
58481: LIST
58482: LIST
58483: LIST
58484: LIST
58485: LIST
58486: LIST
58487: LIST
58488: LIST
58489: LIST
58490: LIST
58491: LIST
58492: LIST
58493: LIST
58494: LIST
58495: LIST
58496: LIST
58497: LIST
58498: ST_TO_ADDR
58499: GO 58732
58501: LD_INT 3
58503: DOUBLE
58504: EQUAL
58505: IFTRUE 58509
58507: GO 58731
58509: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
58510: LD_ADDR_VAR 0 4
58514: PUSH
58515: LD_INT 46
58517: PUSH
58518: LD_INT 47
58520: PUSH
58521: LD_INT 1
58523: PUSH
58524: LD_INT 2
58526: PUSH
58527: LD_INT 82
58529: PUSH
58530: LD_INT 83
58532: PUSH
58533: LD_INT 84
58535: PUSH
58536: LD_INT 85
58538: PUSH
58539: LD_INT 86
58541: PUSH
58542: LD_INT 11
58544: PUSH
58545: LD_INT 9
58547: PUSH
58548: LD_INT 20
58550: PUSH
58551: LD_INT 19
58553: PUSH
58554: LD_INT 21
58556: PUSH
58557: LD_INT 24
58559: PUSH
58560: LD_INT 22
58562: PUSH
58563: LD_INT 25
58565: PUSH
58566: LD_INT 28
58568: PUSH
58569: LD_INT 29
58571: PUSH
58572: LD_INT 30
58574: PUSH
58575: LD_INT 31
58577: PUSH
58578: LD_INT 37
58580: PUSH
58581: LD_INT 38
58583: PUSH
58584: LD_INT 32
58586: PUSH
58587: LD_INT 27
58589: PUSH
58590: LD_INT 33
58592: PUSH
58593: LD_INT 69
58595: PUSH
58596: LD_INT 39
58598: PUSH
58599: LD_INT 34
58601: PUSH
58602: LD_INT 40
58604: PUSH
58605: LD_INT 71
58607: PUSH
58608: LD_INT 23
58610: PUSH
58611: LD_INT 44
58613: PUSH
58614: LD_INT 48
58616: PUSH
58617: LD_INT 49
58619: PUSH
58620: LD_INT 50
58622: PUSH
58623: LD_INT 51
58625: PUSH
58626: LD_INT 52
58628: PUSH
58629: LD_INT 53
58631: PUSH
58632: LD_INT 54
58634: PUSH
58635: LD_INT 55
58637: PUSH
58638: LD_INT 56
58640: PUSH
58641: LD_INT 57
58643: PUSH
58644: LD_INT 58
58646: PUSH
58647: LD_INT 59
58649: PUSH
58650: LD_INT 63
58652: PUSH
58653: LD_INT 64
58655: PUSH
58656: LD_INT 65
58658: PUSH
58659: LD_INT 82
58661: PUSH
58662: LD_INT 83
58664: PUSH
58665: LD_INT 84
58667: PUSH
58668: LD_INT 85
58670: PUSH
58671: LD_INT 86
58673: PUSH
58674: EMPTY
58675: LIST
58676: LIST
58677: LIST
58678: LIST
58679: LIST
58680: LIST
58681: LIST
58682: LIST
58683: LIST
58684: LIST
58685: LIST
58686: LIST
58687: LIST
58688: LIST
58689: LIST
58690: LIST
58691: LIST
58692: LIST
58693: LIST
58694: LIST
58695: LIST
58696: LIST
58697: LIST
58698: LIST
58699: LIST
58700: LIST
58701: LIST
58702: LIST
58703: LIST
58704: LIST
58705: LIST
58706: LIST
58707: LIST
58708: LIST
58709: LIST
58710: LIST
58711: LIST
58712: LIST
58713: LIST
58714: LIST
58715: LIST
58716: LIST
58717: LIST
58718: LIST
58719: LIST
58720: LIST
58721: LIST
58722: LIST
58723: LIST
58724: LIST
58725: LIST
58726: LIST
58727: LIST
58728: ST_TO_ADDR
58729: GO 58732
58731: POP
// if state > - 1 and state < 3 then
58732: LD_VAR 0 3
58736: PUSH
58737: LD_INT 1
58739: NEG
58740: GREATER
58741: PUSH
58742: LD_VAR 0 3
58746: PUSH
58747: LD_INT 3
58749: LESS
58750: AND
58751: IFFALSE 58808
// for i in result do
58753: LD_ADDR_VAR 0 5
58757: PUSH
58758: LD_VAR 0 4
58762: PUSH
58763: FOR_IN
58764: IFFALSE 58806
// if GetTech ( i , side ) <> state then
58766: LD_VAR 0 5
58770: PPUSH
58771: LD_VAR 0 1
58775: PPUSH
58776: CALL_OW 321
58780: PUSH
58781: LD_VAR 0 3
58785: NONEQUAL
58786: IFFALSE 58804
// result := result diff i ;
58788: LD_ADDR_VAR 0 4
58792: PUSH
58793: LD_VAR 0 4
58797: PUSH
58798: LD_VAR 0 5
58802: DIFF
58803: ST_TO_ADDR
58804: GO 58763
58806: POP
58807: POP
// end ;
58808: LD_VAR 0 4
58812: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
58813: LD_INT 0
58815: PPUSH
58816: PPUSH
58817: PPUSH
// result := true ;
58818: LD_ADDR_VAR 0 3
58822: PUSH
58823: LD_INT 1
58825: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
58826: LD_ADDR_VAR 0 5
58830: PUSH
58831: LD_VAR 0 2
58835: PPUSH
58836: CALL_OW 480
58840: ST_TO_ADDR
// if not tmp then
58841: LD_VAR 0 5
58845: NOT
58846: IFFALSE 58850
// exit ;
58848: GO 58899
// for i in tmp do
58850: LD_ADDR_VAR 0 4
58854: PUSH
58855: LD_VAR 0 5
58859: PUSH
58860: FOR_IN
58861: IFFALSE 58897
// if GetTech ( i , side ) <> state_researched then
58863: LD_VAR 0 4
58867: PPUSH
58868: LD_VAR 0 1
58872: PPUSH
58873: CALL_OW 321
58877: PUSH
58878: LD_INT 2
58880: NONEQUAL
58881: IFFALSE 58895
// begin result := false ;
58883: LD_ADDR_VAR 0 3
58887: PUSH
58888: LD_INT 0
58890: ST_TO_ADDR
// exit ;
58891: POP
58892: POP
58893: GO 58899
// end ;
58895: GO 58860
58897: POP
58898: POP
// end ;
58899: LD_VAR 0 3
58903: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
58904: LD_INT 0
58906: PPUSH
58907: PPUSH
58908: PPUSH
58909: PPUSH
58910: PPUSH
58911: PPUSH
58912: PPUSH
58913: PPUSH
58914: PPUSH
58915: PPUSH
58916: PPUSH
58917: PPUSH
58918: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
58919: LD_VAR 0 1
58923: NOT
58924: PUSH
58925: LD_VAR 0 1
58929: PPUSH
58930: CALL_OW 257
58934: PUSH
58935: LD_INT 9
58937: NONEQUAL
58938: OR
58939: IFFALSE 58943
// exit ;
58941: GO 59516
// side := GetSide ( unit ) ;
58943: LD_ADDR_VAR 0 9
58947: PUSH
58948: LD_VAR 0 1
58952: PPUSH
58953: CALL_OW 255
58957: ST_TO_ADDR
// tech_space := tech_spacanom ;
58958: LD_ADDR_VAR 0 12
58962: PUSH
58963: LD_INT 29
58965: ST_TO_ADDR
// tech_time := tech_taurad ;
58966: LD_ADDR_VAR 0 13
58970: PUSH
58971: LD_INT 28
58973: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
58974: LD_ADDR_VAR 0 11
58978: PUSH
58979: LD_VAR 0 1
58983: PPUSH
58984: CALL_OW 310
58988: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
58989: LD_VAR 0 11
58993: PPUSH
58994: CALL_OW 247
58998: PUSH
58999: LD_INT 2
59001: EQUAL
59002: IFFALSE 59006
// exit ;
59004: GO 59516
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59006: LD_ADDR_VAR 0 8
59010: PUSH
59011: LD_INT 81
59013: PUSH
59014: LD_VAR 0 9
59018: PUSH
59019: EMPTY
59020: LIST
59021: LIST
59022: PUSH
59023: LD_INT 3
59025: PUSH
59026: LD_INT 21
59028: PUSH
59029: LD_INT 3
59031: PUSH
59032: EMPTY
59033: LIST
59034: LIST
59035: PUSH
59036: EMPTY
59037: LIST
59038: LIST
59039: PUSH
59040: EMPTY
59041: LIST
59042: LIST
59043: PPUSH
59044: CALL_OW 69
59048: ST_TO_ADDR
// if not tmp then
59049: LD_VAR 0 8
59053: NOT
59054: IFFALSE 59058
// exit ;
59056: GO 59516
// if in_unit then
59058: LD_VAR 0 11
59062: IFFALSE 59086
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
59064: LD_ADDR_VAR 0 10
59068: PUSH
59069: LD_VAR 0 8
59073: PPUSH
59074: LD_VAR 0 11
59078: PPUSH
59079: CALL_OW 74
59083: ST_TO_ADDR
59084: GO 59106
// enemy := NearestUnitToUnit ( tmp , unit ) ;
59086: LD_ADDR_VAR 0 10
59090: PUSH
59091: LD_VAR 0 8
59095: PPUSH
59096: LD_VAR 0 1
59100: PPUSH
59101: CALL_OW 74
59105: ST_TO_ADDR
// if not enemy then
59106: LD_VAR 0 10
59110: NOT
59111: IFFALSE 59115
// exit ;
59113: GO 59516
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
59115: LD_VAR 0 11
59119: PUSH
59120: LD_VAR 0 11
59124: PPUSH
59125: LD_VAR 0 10
59129: PPUSH
59130: CALL_OW 296
59134: PUSH
59135: LD_INT 13
59137: GREATER
59138: AND
59139: PUSH
59140: LD_VAR 0 1
59144: PPUSH
59145: LD_VAR 0 10
59149: PPUSH
59150: CALL_OW 296
59154: PUSH
59155: LD_INT 12
59157: GREATER
59158: OR
59159: IFFALSE 59163
// exit ;
59161: GO 59516
// missile := [ 1 ] ;
59163: LD_ADDR_VAR 0 14
59167: PUSH
59168: LD_INT 1
59170: PUSH
59171: EMPTY
59172: LIST
59173: ST_TO_ADDR
// if Researched ( side , tech_space ) then
59174: LD_VAR 0 9
59178: PPUSH
59179: LD_VAR 0 12
59183: PPUSH
59184: CALL_OW 325
59188: IFFALSE 59217
// missile := Insert ( missile , missile + 1 , 2 ) ;
59190: LD_ADDR_VAR 0 14
59194: PUSH
59195: LD_VAR 0 14
59199: PPUSH
59200: LD_VAR 0 14
59204: PUSH
59205: LD_INT 1
59207: PLUS
59208: PPUSH
59209: LD_INT 2
59211: PPUSH
59212: CALL_OW 2
59216: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
59217: LD_VAR 0 9
59221: PPUSH
59222: LD_VAR 0 13
59226: PPUSH
59227: CALL_OW 325
59231: PUSH
59232: LD_VAR 0 10
59236: PPUSH
59237: CALL_OW 255
59241: PPUSH
59242: LD_VAR 0 13
59246: PPUSH
59247: CALL_OW 325
59251: NOT
59252: AND
59253: IFFALSE 59282
// missile := Insert ( missile , missile + 1 , 3 ) ;
59255: LD_ADDR_VAR 0 14
59259: PUSH
59260: LD_VAR 0 14
59264: PPUSH
59265: LD_VAR 0 14
59269: PUSH
59270: LD_INT 1
59272: PLUS
59273: PPUSH
59274: LD_INT 3
59276: PPUSH
59277: CALL_OW 2
59281: ST_TO_ADDR
// if missile < 2 then
59282: LD_VAR 0 14
59286: PUSH
59287: LD_INT 2
59289: LESS
59290: IFFALSE 59294
// exit ;
59292: GO 59516
// x := GetX ( enemy ) ;
59294: LD_ADDR_VAR 0 4
59298: PUSH
59299: LD_VAR 0 10
59303: PPUSH
59304: CALL_OW 250
59308: ST_TO_ADDR
// y := GetY ( enemy ) ;
59309: LD_ADDR_VAR 0 5
59313: PUSH
59314: LD_VAR 0 10
59318: PPUSH
59319: CALL_OW 251
59323: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
59324: LD_ADDR_VAR 0 6
59328: PUSH
59329: LD_VAR 0 4
59333: PUSH
59334: LD_INT 1
59336: NEG
59337: PPUSH
59338: LD_INT 1
59340: PPUSH
59341: CALL_OW 12
59345: PLUS
59346: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
59347: LD_ADDR_VAR 0 7
59351: PUSH
59352: LD_VAR 0 5
59356: PUSH
59357: LD_INT 1
59359: NEG
59360: PPUSH
59361: LD_INT 1
59363: PPUSH
59364: CALL_OW 12
59368: PLUS
59369: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
59370: LD_VAR 0 6
59374: PPUSH
59375: LD_VAR 0 7
59379: PPUSH
59380: CALL_OW 488
59384: NOT
59385: IFFALSE 59407
// begin _x := x ;
59387: LD_ADDR_VAR 0 6
59391: PUSH
59392: LD_VAR 0 4
59396: ST_TO_ADDR
// _y := y ;
59397: LD_ADDR_VAR 0 7
59401: PUSH
59402: LD_VAR 0 5
59406: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
59407: LD_ADDR_VAR 0 3
59411: PUSH
59412: LD_INT 1
59414: PPUSH
59415: LD_VAR 0 14
59419: PPUSH
59420: CALL_OW 12
59424: ST_TO_ADDR
// case i of 1 :
59425: LD_VAR 0 3
59429: PUSH
59430: LD_INT 1
59432: DOUBLE
59433: EQUAL
59434: IFTRUE 59438
59436: GO 59455
59438: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
59439: LD_VAR 0 1
59443: PPUSH
59444: LD_VAR 0 10
59448: PPUSH
59449: CALL_OW 115
59453: GO 59516
59455: LD_INT 2
59457: DOUBLE
59458: EQUAL
59459: IFTRUE 59463
59461: GO 59485
59463: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
59464: LD_VAR 0 1
59468: PPUSH
59469: LD_VAR 0 6
59473: PPUSH
59474: LD_VAR 0 7
59478: PPUSH
59479: CALL_OW 153
59483: GO 59516
59485: LD_INT 3
59487: DOUBLE
59488: EQUAL
59489: IFTRUE 59493
59491: GO 59515
59493: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
59494: LD_VAR 0 1
59498: PPUSH
59499: LD_VAR 0 6
59503: PPUSH
59504: LD_VAR 0 7
59508: PPUSH
59509: CALL_OW 154
59513: GO 59516
59515: POP
// end ;
59516: LD_VAR 0 2
59520: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
59521: LD_INT 0
59523: PPUSH
59524: PPUSH
59525: PPUSH
59526: PPUSH
59527: PPUSH
59528: PPUSH
// if not unit or not building then
59529: LD_VAR 0 1
59533: NOT
59534: PUSH
59535: LD_VAR 0 2
59539: NOT
59540: OR
59541: IFFALSE 59545
// exit ;
59543: GO 59703
// x := GetX ( building ) ;
59545: LD_ADDR_VAR 0 5
59549: PUSH
59550: LD_VAR 0 2
59554: PPUSH
59555: CALL_OW 250
59559: ST_TO_ADDR
// y := GetY ( building ) ;
59560: LD_ADDR_VAR 0 6
59564: PUSH
59565: LD_VAR 0 2
59569: PPUSH
59570: CALL_OW 251
59574: ST_TO_ADDR
// for i = 0 to 5 do
59575: LD_ADDR_VAR 0 4
59579: PUSH
59580: DOUBLE
59581: LD_INT 0
59583: DEC
59584: ST_TO_ADDR
59585: LD_INT 5
59587: PUSH
59588: FOR_TO
59589: IFFALSE 59701
// begin _x := ShiftX ( x , i , 3 ) ;
59591: LD_ADDR_VAR 0 7
59595: PUSH
59596: LD_VAR 0 5
59600: PPUSH
59601: LD_VAR 0 4
59605: PPUSH
59606: LD_INT 3
59608: PPUSH
59609: CALL_OW 272
59613: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
59614: LD_ADDR_VAR 0 8
59618: PUSH
59619: LD_VAR 0 6
59623: PPUSH
59624: LD_VAR 0 4
59628: PPUSH
59629: LD_INT 3
59631: PPUSH
59632: CALL_OW 273
59636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
59637: LD_VAR 0 7
59641: PPUSH
59642: LD_VAR 0 8
59646: PPUSH
59647: CALL_OW 488
59651: NOT
59652: IFFALSE 59656
// continue ;
59654: GO 59588
// if HexInfo ( _x , _y ) = 0 then
59656: LD_VAR 0 7
59660: PPUSH
59661: LD_VAR 0 8
59665: PPUSH
59666: CALL_OW 428
59670: PUSH
59671: LD_INT 0
59673: EQUAL
59674: IFFALSE 59699
// begin ComMoveXY ( unit , _x , _y ) ;
59676: LD_VAR 0 1
59680: PPUSH
59681: LD_VAR 0 7
59685: PPUSH
59686: LD_VAR 0 8
59690: PPUSH
59691: CALL_OW 111
// exit ;
59695: POP
59696: POP
59697: GO 59703
// end ; end ;
59699: GO 59588
59701: POP
59702: POP
// end ;
59703: LD_VAR 0 3
59707: RET
// export function ScanBase ( side , base_area ) ; begin
59708: LD_INT 0
59710: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
59711: LD_ADDR_VAR 0 3
59715: PUSH
59716: LD_VAR 0 2
59720: PPUSH
59721: LD_INT 81
59723: PUSH
59724: LD_VAR 0 1
59728: PUSH
59729: EMPTY
59730: LIST
59731: LIST
59732: PPUSH
59733: CALL_OW 70
59737: ST_TO_ADDR
// end ;
59738: LD_VAR 0 3
59742: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
59743: LD_INT 0
59745: PPUSH
59746: PPUSH
59747: PPUSH
59748: PPUSH
// result := false ;
59749: LD_ADDR_VAR 0 2
59753: PUSH
59754: LD_INT 0
59756: ST_TO_ADDR
// side := GetSide ( unit ) ;
59757: LD_ADDR_VAR 0 3
59761: PUSH
59762: LD_VAR 0 1
59766: PPUSH
59767: CALL_OW 255
59771: ST_TO_ADDR
// nat := GetNation ( unit ) ;
59772: LD_ADDR_VAR 0 4
59776: PUSH
59777: LD_VAR 0 1
59781: PPUSH
59782: CALL_OW 248
59786: ST_TO_ADDR
// case nat of 1 :
59787: LD_VAR 0 4
59791: PUSH
59792: LD_INT 1
59794: DOUBLE
59795: EQUAL
59796: IFTRUE 59800
59798: GO 59811
59800: POP
// tech := tech_lassight ; 2 :
59801: LD_ADDR_VAR 0 5
59805: PUSH
59806: LD_INT 12
59808: ST_TO_ADDR
59809: GO 59850
59811: LD_INT 2
59813: DOUBLE
59814: EQUAL
59815: IFTRUE 59819
59817: GO 59830
59819: POP
// tech := tech_mortar ; 3 :
59820: LD_ADDR_VAR 0 5
59824: PUSH
59825: LD_INT 41
59827: ST_TO_ADDR
59828: GO 59850
59830: LD_INT 3
59832: DOUBLE
59833: EQUAL
59834: IFTRUE 59838
59836: GO 59849
59838: POP
// tech := tech_bazooka ; end ;
59839: LD_ADDR_VAR 0 5
59843: PUSH
59844: LD_INT 44
59846: ST_TO_ADDR
59847: GO 59850
59849: POP
// if Researched ( side , tech ) then
59850: LD_VAR 0 3
59854: PPUSH
59855: LD_VAR 0 5
59859: PPUSH
59860: CALL_OW 325
59864: IFFALSE 59891
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
59866: LD_ADDR_VAR 0 2
59870: PUSH
59871: LD_INT 5
59873: PUSH
59874: LD_INT 8
59876: PUSH
59877: LD_INT 9
59879: PUSH
59880: EMPTY
59881: LIST
59882: LIST
59883: LIST
59884: PUSH
59885: LD_VAR 0 4
59889: ARRAY
59890: ST_TO_ADDR
// end ;
59891: LD_VAR 0 2
59895: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
59896: LD_INT 0
59898: PPUSH
59899: PPUSH
59900: PPUSH
// if not mines then
59901: LD_VAR 0 2
59905: NOT
59906: IFFALSE 59910
// exit ;
59908: GO 60054
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59910: LD_ADDR_VAR 0 5
59914: PUSH
59915: LD_INT 81
59917: PUSH
59918: LD_VAR 0 1
59922: PUSH
59923: EMPTY
59924: LIST
59925: LIST
59926: PUSH
59927: LD_INT 3
59929: PUSH
59930: LD_INT 21
59932: PUSH
59933: LD_INT 3
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: EMPTY
59941: LIST
59942: LIST
59943: PUSH
59944: EMPTY
59945: LIST
59946: LIST
59947: PPUSH
59948: CALL_OW 69
59952: ST_TO_ADDR
// for i in mines do
59953: LD_ADDR_VAR 0 4
59957: PUSH
59958: LD_VAR 0 2
59962: PUSH
59963: FOR_IN
59964: IFFALSE 60052
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
59966: LD_VAR 0 4
59970: PUSH
59971: LD_INT 1
59973: ARRAY
59974: PPUSH
59975: LD_VAR 0 4
59979: PUSH
59980: LD_INT 2
59982: ARRAY
59983: PPUSH
59984: CALL_OW 458
59988: NOT
59989: IFFALSE 59993
// continue ;
59991: GO 59963
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
59993: LD_VAR 0 4
59997: PUSH
59998: LD_INT 1
60000: ARRAY
60001: PPUSH
60002: LD_VAR 0 4
60006: PUSH
60007: LD_INT 2
60009: ARRAY
60010: PPUSH
60011: CALL_OW 428
60015: PUSH
60016: LD_VAR 0 5
60020: IN
60021: IFFALSE 60050
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
60023: LD_VAR 0 4
60027: PUSH
60028: LD_INT 1
60030: ARRAY
60031: PPUSH
60032: LD_VAR 0 4
60036: PUSH
60037: LD_INT 2
60039: ARRAY
60040: PPUSH
60041: LD_VAR 0 1
60045: PPUSH
60046: CALL_OW 456
// end ;
60050: GO 59963
60052: POP
60053: POP
// end ;
60054: LD_VAR 0 3
60058: RET
// export function Count ( array ) ; var i ; begin
60059: LD_INT 0
60061: PPUSH
60062: PPUSH
// result := 0 ;
60063: LD_ADDR_VAR 0 2
60067: PUSH
60068: LD_INT 0
60070: ST_TO_ADDR
// for i in array do
60071: LD_ADDR_VAR 0 3
60075: PUSH
60076: LD_VAR 0 1
60080: PUSH
60081: FOR_IN
60082: IFFALSE 60106
// if i then
60084: LD_VAR 0 3
60088: IFFALSE 60104
// result := result + 1 ;
60090: LD_ADDR_VAR 0 2
60094: PUSH
60095: LD_VAR 0 2
60099: PUSH
60100: LD_INT 1
60102: PLUS
60103: ST_TO_ADDR
60104: GO 60081
60106: POP
60107: POP
// end ;
60108: LD_VAR 0 2
60112: RET
// export function IsEmpty ( building ) ; begin
60113: LD_INT 0
60115: PPUSH
// if not building then
60116: LD_VAR 0 1
60120: NOT
60121: IFFALSE 60125
// exit ;
60123: GO 60168
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
60125: LD_ADDR_VAR 0 2
60129: PUSH
60130: LD_VAR 0 1
60134: PUSH
60135: LD_INT 22
60137: PUSH
60138: LD_VAR 0 1
60142: PPUSH
60143: CALL_OW 255
60147: PUSH
60148: EMPTY
60149: LIST
60150: LIST
60151: PUSH
60152: LD_INT 58
60154: PUSH
60155: EMPTY
60156: LIST
60157: PUSH
60158: EMPTY
60159: LIST
60160: LIST
60161: PPUSH
60162: CALL_OW 69
60166: IN
60167: ST_TO_ADDR
// end ;
60168: LD_VAR 0 2
60172: RET
// export function IsNotFull ( building ) ; begin
60173: LD_INT 0
60175: PPUSH
// if not building then
60176: LD_VAR 0 1
60180: NOT
60181: IFFALSE 60185
// exit ;
60183: GO 60204
// result := UnitsInside ( building ) < 6 ;
60185: LD_ADDR_VAR 0 2
60189: PUSH
60190: LD_VAR 0 1
60194: PPUSH
60195: CALL_OW 313
60199: PUSH
60200: LD_INT 6
60202: LESS
60203: ST_TO_ADDR
// end ;
60204: LD_VAR 0 2
60208: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
60209: LD_INT 0
60211: PPUSH
60212: PPUSH
60213: PPUSH
60214: PPUSH
// tmp := [ ] ;
60215: LD_ADDR_VAR 0 3
60219: PUSH
60220: EMPTY
60221: ST_TO_ADDR
// list := [ ] ;
60222: LD_ADDR_VAR 0 5
60226: PUSH
60227: EMPTY
60228: ST_TO_ADDR
// for i = 16 to 25 do
60229: LD_ADDR_VAR 0 4
60233: PUSH
60234: DOUBLE
60235: LD_INT 16
60237: DEC
60238: ST_TO_ADDR
60239: LD_INT 25
60241: PUSH
60242: FOR_TO
60243: IFFALSE 60316
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
60245: LD_ADDR_VAR 0 3
60249: PUSH
60250: LD_VAR 0 3
60254: PUSH
60255: LD_INT 22
60257: PUSH
60258: LD_VAR 0 1
60262: PPUSH
60263: CALL_OW 255
60267: PUSH
60268: EMPTY
60269: LIST
60270: LIST
60271: PUSH
60272: LD_INT 91
60274: PUSH
60275: LD_VAR 0 1
60279: PUSH
60280: LD_INT 6
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: LIST
60287: PUSH
60288: LD_INT 30
60290: PUSH
60291: LD_VAR 0 4
60295: PUSH
60296: EMPTY
60297: LIST
60298: LIST
60299: PUSH
60300: EMPTY
60301: LIST
60302: LIST
60303: LIST
60304: PUSH
60305: EMPTY
60306: LIST
60307: PPUSH
60308: CALL_OW 69
60312: ADD
60313: ST_TO_ADDR
60314: GO 60242
60316: POP
60317: POP
// for i = 1 to tmp do
60318: LD_ADDR_VAR 0 4
60322: PUSH
60323: DOUBLE
60324: LD_INT 1
60326: DEC
60327: ST_TO_ADDR
60328: LD_VAR 0 3
60332: PUSH
60333: FOR_TO
60334: IFFALSE 60422
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
60336: LD_ADDR_VAR 0 5
60340: PUSH
60341: LD_VAR 0 5
60345: PUSH
60346: LD_VAR 0 3
60350: PUSH
60351: LD_VAR 0 4
60355: ARRAY
60356: PPUSH
60357: CALL_OW 266
60361: PUSH
60362: LD_VAR 0 3
60366: PUSH
60367: LD_VAR 0 4
60371: ARRAY
60372: PPUSH
60373: CALL_OW 250
60377: PUSH
60378: LD_VAR 0 3
60382: PUSH
60383: LD_VAR 0 4
60387: ARRAY
60388: PPUSH
60389: CALL_OW 251
60393: PUSH
60394: LD_VAR 0 3
60398: PUSH
60399: LD_VAR 0 4
60403: ARRAY
60404: PPUSH
60405: CALL_OW 254
60409: PUSH
60410: EMPTY
60411: LIST
60412: LIST
60413: LIST
60414: LIST
60415: PUSH
60416: EMPTY
60417: LIST
60418: ADD
60419: ST_TO_ADDR
60420: GO 60333
60422: POP
60423: POP
// result := list ;
60424: LD_ADDR_VAR 0 2
60428: PUSH
60429: LD_VAR 0 5
60433: ST_TO_ADDR
// end ;
60434: LD_VAR 0 2
60438: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
60439: LD_INT 0
60441: PPUSH
60442: PPUSH
60443: PPUSH
60444: PPUSH
60445: PPUSH
60446: PPUSH
60447: PPUSH
// if not factory then
60448: LD_VAR 0 1
60452: NOT
60453: IFFALSE 60457
// exit ;
60455: GO 61050
// if control = control_apeman then
60457: LD_VAR 0 4
60461: PUSH
60462: LD_INT 5
60464: EQUAL
60465: IFFALSE 60574
// begin tmp := UnitsInside ( factory ) ;
60467: LD_ADDR_VAR 0 8
60471: PUSH
60472: LD_VAR 0 1
60476: PPUSH
60477: CALL_OW 313
60481: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
60482: LD_VAR 0 8
60486: PPUSH
60487: LD_INT 25
60489: PUSH
60490: LD_INT 12
60492: PUSH
60493: EMPTY
60494: LIST
60495: LIST
60496: PPUSH
60497: CALL_OW 72
60501: NOT
60502: IFFALSE 60512
// control := control_manual ;
60504: LD_ADDR_VAR 0 4
60508: PUSH
60509: LD_INT 1
60511: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
60512: LD_ADDR_VAR 0 8
60516: PUSH
60517: LD_VAR 0 1
60521: PPUSH
60522: CALL 60209 0 1
60526: ST_TO_ADDR
// if tmp then
60527: LD_VAR 0 8
60531: IFFALSE 60574
// begin for i in tmp do
60533: LD_ADDR_VAR 0 7
60537: PUSH
60538: LD_VAR 0 8
60542: PUSH
60543: FOR_IN
60544: IFFALSE 60572
// if i [ 1 ] = b_ext_radio then
60546: LD_VAR 0 7
60550: PUSH
60551: LD_INT 1
60553: ARRAY
60554: PUSH
60555: LD_INT 22
60557: EQUAL
60558: IFFALSE 60570
// begin control := control_remote ;
60560: LD_ADDR_VAR 0 4
60564: PUSH
60565: LD_INT 2
60567: ST_TO_ADDR
// break ;
60568: GO 60572
// end ;
60570: GO 60543
60572: POP
60573: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
60574: LD_VAR 0 1
60578: PPUSH
60579: LD_VAR 0 2
60583: PPUSH
60584: LD_VAR 0 3
60588: PPUSH
60589: LD_VAR 0 4
60593: PPUSH
60594: LD_VAR 0 5
60598: PPUSH
60599: CALL_OW 448
60603: IFFALSE 60638
// begin result := [ chassis , engine , control , weapon ] ;
60605: LD_ADDR_VAR 0 6
60609: PUSH
60610: LD_VAR 0 2
60614: PUSH
60615: LD_VAR 0 3
60619: PUSH
60620: LD_VAR 0 4
60624: PUSH
60625: LD_VAR 0 5
60629: PUSH
60630: EMPTY
60631: LIST
60632: LIST
60633: LIST
60634: LIST
60635: ST_TO_ADDR
// exit ;
60636: GO 61050
// end ; _chassis := AvailableChassisList ( factory ) ;
60638: LD_ADDR_VAR 0 9
60642: PUSH
60643: LD_VAR 0 1
60647: PPUSH
60648: CALL_OW 475
60652: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
60653: LD_ADDR_VAR 0 11
60657: PUSH
60658: LD_VAR 0 1
60662: PPUSH
60663: CALL_OW 476
60667: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
60668: LD_ADDR_VAR 0 12
60672: PUSH
60673: LD_VAR 0 1
60677: PPUSH
60678: CALL_OW 477
60682: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
60683: LD_ADDR_VAR 0 10
60687: PUSH
60688: LD_VAR 0 1
60692: PPUSH
60693: CALL_OW 478
60697: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
60698: LD_VAR 0 9
60702: NOT
60703: PUSH
60704: LD_VAR 0 11
60708: NOT
60709: OR
60710: PUSH
60711: LD_VAR 0 12
60715: NOT
60716: OR
60717: PUSH
60718: LD_VAR 0 10
60722: NOT
60723: OR
60724: IFFALSE 60759
// begin result := [ chassis , engine , control , weapon ] ;
60726: LD_ADDR_VAR 0 6
60730: PUSH
60731: LD_VAR 0 2
60735: PUSH
60736: LD_VAR 0 3
60740: PUSH
60741: LD_VAR 0 4
60745: PUSH
60746: LD_VAR 0 5
60750: PUSH
60751: EMPTY
60752: LIST
60753: LIST
60754: LIST
60755: LIST
60756: ST_TO_ADDR
// exit ;
60757: GO 61050
// end ; if not chassis in _chassis then
60759: LD_VAR 0 2
60763: PUSH
60764: LD_VAR 0 9
60768: IN
60769: NOT
60770: IFFALSE 60796
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
60772: LD_ADDR_VAR 0 2
60776: PUSH
60777: LD_VAR 0 9
60781: PUSH
60782: LD_INT 1
60784: PPUSH
60785: LD_VAR 0 9
60789: PPUSH
60790: CALL_OW 12
60794: ARRAY
60795: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
60796: LD_VAR 0 2
60800: PPUSH
60801: LD_VAR 0 3
60805: PPUSH
60806: CALL 61055 0 2
60810: NOT
60811: IFFALSE 60870
// repeat engine := _engine [ 1 ] ;
60813: LD_ADDR_VAR 0 3
60817: PUSH
60818: LD_VAR 0 11
60822: PUSH
60823: LD_INT 1
60825: ARRAY
60826: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
60827: LD_ADDR_VAR 0 11
60831: PUSH
60832: LD_VAR 0 11
60836: PPUSH
60837: LD_INT 1
60839: PPUSH
60840: CALL_OW 3
60844: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
60845: LD_VAR 0 2
60849: PPUSH
60850: LD_VAR 0 3
60854: PPUSH
60855: CALL 61055 0 2
60859: PUSH
60860: LD_VAR 0 11
60864: PUSH
60865: EMPTY
60866: EQUAL
60867: OR
60868: IFFALSE 60813
// if not control in _control then
60870: LD_VAR 0 4
60874: PUSH
60875: LD_VAR 0 12
60879: IN
60880: NOT
60881: IFFALSE 60907
// control := _control [ rand ( 1 , _control ) ] ;
60883: LD_ADDR_VAR 0 4
60887: PUSH
60888: LD_VAR 0 12
60892: PUSH
60893: LD_INT 1
60895: PPUSH
60896: LD_VAR 0 12
60900: PPUSH
60901: CALL_OW 12
60905: ARRAY
60906: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
60907: LD_VAR 0 2
60911: PPUSH
60912: LD_VAR 0 5
60916: PPUSH
60917: CALL 61275 0 2
60921: NOT
60922: IFFALSE 60981
// repeat weapon := _weapon [ 1 ] ;
60924: LD_ADDR_VAR 0 5
60928: PUSH
60929: LD_VAR 0 10
60933: PUSH
60934: LD_INT 1
60936: ARRAY
60937: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
60938: LD_ADDR_VAR 0 10
60942: PUSH
60943: LD_VAR 0 10
60947: PPUSH
60948: LD_INT 1
60950: PPUSH
60951: CALL_OW 3
60955: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
60956: LD_VAR 0 2
60960: PPUSH
60961: LD_VAR 0 5
60965: PPUSH
60966: CALL 61275 0 2
60970: PUSH
60971: LD_VAR 0 10
60975: PUSH
60976: EMPTY
60977: EQUAL
60978: OR
60979: IFFALSE 60924
// result := [ ] ;
60981: LD_ADDR_VAR 0 6
60985: PUSH
60986: EMPTY
60987: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
60988: LD_VAR 0 1
60992: PPUSH
60993: LD_VAR 0 2
60997: PPUSH
60998: LD_VAR 0 3
61002: PPUSH
61003: LD_VAR 0 4
61007: PPUSH
61008: LD_VAR 0 5
61012: PPUSH
61013: CALL_OW 448
61017: IFFALSE 61050
// result := [ chassis , engine , control , weapon ] ;
61019: LD_ADDR_VAR 0 6
61023: PUSH
61024: LD_VAR 0 2
61028: PUSH
61029: LD_VAR 0 3
61033: PUSH
61034: LD_VAR 0 4
61038: PUSH
61039: LD_VAR 0 5
61043: PUSH
61044: EMPTY
61045: LIST
61046: LIST
61047: LIST
61048: LIST
61049: ST_TO_ADDR
// end ;
61050: LD_VAR 0 6
61054: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
61055: LD_INT 0
61057: PPUSH
// if not chassis or not engine then
61058: LD_VAR 0 1
61062: NOT
61063: PUSH
61064: LD_VAR 0 2
61068: NOT
61069: OR
61070: IFFALSE 61074
// exit ;
61072: GO 61270
// case engine of engine_solar :
61074: LD_VAR 0 2
61078: PUSH
61079: LD_INT 2
61081: DOUBLE
61082: EQUAL
61083: IFTRUE 61087
61085: GO 61125
61087: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
61088: LD_ADDR_VAR 0 3
61092: PUSH
61093: LD_INT 11
61095: PUSH
61096: LD_INT 12
61098: PUSH
61099: LD_INT 13
61101: PUSH
61102: LD_INT 14
61104: PUSH
61105: LD_INT 1
61107: PUSH
61108: LD_INT 2
61110: PUSH
61111: LD_INT 3
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: ST_TO_ADDR
61123: GO 61254
61125: LD_INT 1
61127: DOUBLE
61128: EQUAL
61129: IFTRUE 61133
61131: GO 61195
61133: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
61134: LD_ADDR_VAR 0 3
61138: PUSH
61139: LD_INT 11
61141: PUSH
61142: LD_INT 12
61144: PUSH
61145: LD_INT 13
61147: PUSH
61148: LD_INT 14
61150: PUSH
61151: LD_INT 1
61153: PUSH
61154: LD_INT 2
61156: PUSH
61157: LD_INT 3
61159: PUSH
61160: LD_INT 4
61162: PUSH
61163: LD_INT 5
61165: PUSH
61166: LD_INT 21
61168: PUSH
61169: LD_INT 23
61171: PUSH
61172: LD_INT 22
61174: PUSH
61175: LD_INT 24
61177: PUSH
61178: EMPTY
61179: LIST
61180: LIST
61181: LIST
61182: LIST
61183: LIST
61184: LIST
61185: LIST
61186: LIST
61187: LIST
61188: LIST
61189: LIST
61190: LIST
61191: LIST
61192: ST_TO_ADDR
61193: GO 61254
61195: LD_INT 3
61197: DOUBLE
61198: EQUAL
61199: IFTRUE 61203
61201: GO 61253
61203: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
61204: LD_ADDR_VAR 0 3
61208: PUSH
61209: LD_INT 13
61211: PUSH
61212: LD_INT 14
61214: PUSH
61215: LD_INT 2
61217: PUSH
61218: LD_INT 3
61220: PUSH
61221: LD_INT 4
61223: PUSH
61224: LD_INT 5
61226: PUSH
61227: LD_INT 21
61229: PUSH
61230: LD_INT 22
61232: PUSH
61233: LD_INT 23
61235: PUSH
61236: LD_INT 24
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: LIST
61243: LIST
61244: LIST
61245: LIST
61246: LIST
61247: LIST
61248: LIST
61249: LIST
61250: ST_TO_ADDR
61251: GO 61254
61253: POP
// result := ( chassis in result ) ;
61254: LD_ADDR_VAR 0 3
61258: PUSH
61259: LD_VAR 0 1
61263: PUSH
61264: LD_VAR 0 3
61268: IN
61269: ST_TO_ADDR
// end ;
61270: LD_VAR 0 3
61274: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
61275: LD_INT 0
61277: PPUSH
// if not chassis or not weapon then
61278: LD_VAR 0 1
61282: NOT
61283: PUSH
61284: LD_VAR 0 2
61288: NOT
61289: OR
61290: IFFALSE 61294
// exit ;
61292: GO 62320
// case weapon of us_machine_gun :
61294: LD_VAR 0 2
61298: PUSH
61299: LD_INT 2
61301: DOUBLE
61302: EQUAL
61303: IFTRUE 61307
61305: GO 61337
61307: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
61308: LD_ADDR_VAR 0 3
61312: PUSH
61313: LD_INT 1
61315: PUSH
61316: LD_INT 2
61318: PUSH
61319: LD_INT 3
61321: PUSH
61322: LD_INT 4
61324: PUSH
61325: LD_INT 5
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: LIST
61332: LIST
61333: LIST
61334: ST_TO_ADDR
61335: GO 62304
61337: LD_INT 3
61339: DOUBLE
61340: EQUAL
61341: IFTRUE 61345
61343: GO 61375
61345: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
61346: LD_ADDR_VAR 0 3
61350: PUSH
61351: LD_INT 1
61353: PUSH
61354: LD_INT 2
61356: PUSH
61357: LD_INT 3
61359: PUSH
61360: LD_INT 4
61362: PUSH
61363: LD_INT 5
61365: PUSH
61366: EMPTY
61367: LIST
61368: LIST
61369: LIST
61370: LIST
61371: LIST
61372: ST_TO_ADDR
61373: GO 62304
61375: LD_INT 11
61377: DOUBLE
61378: EQUAL
61379: IFTRUE 61383
61381: GO 61413
61383: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
61384: LD_ADDR_VAR 0 3
61388: PUSH
61389: LD_INT 1
61391: PUSH
61392: LD_INT 2
61394: PUSH
61395: LD_INT 3
61397: PUSH
61398: LD_INT 4
61400: PUSH
61401: LD_INT 5
61403: PUSH
61404: EMPTY
61405: LIST
61406: LIST
61407: LIST
61408: LIST
61409: LIST
61410: ST_TO_ADDR
61411: GO 62304
61413: LD_INT 4
61415: DOUBLE
61416: EQUAL
61417: IFTRUE 61421
61419: GO 61447
61421: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
61422: LD_ADDR_VAR 0 3
61426: PUSH
61427: LD_INT 2
61429: PUSH
61430: LD_INT 3
61432: PUSH
61433: LD_INT 4
61435: PUSH
61436: LD_INT 5
61438: PUSH
61439: EMPTY
61440: LIST
61441: LIST
61442: LIST
61443: LIST
61444: ST_TO_ADDR
61445: GO 62304
61447: LD_INT 5
61449: DOUBLE
61450: EQUAL
61451: IFTRUE 61455
61453: GO 61481
61455: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
61456: LD_ADDR_VAR 0 3
61460: PUSH
61461: LD_INT 2
61463: PUSH
61464: LD_INT 3
61466: PUSH
61467: LD_INT 4
61469: PUSH
61470: LD_INT 5
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: LIST
61477: LIST
61478: ST_TO_ADDR
61479: GO 62304
61481: LD_INT 9
61483: DOUBLE
61484: EQUAL
61485: IFTRUE 61489
61487: GO 61515
61489: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
61490: LD_ADDR_VAR 0 3
61494: PUSH
61495: LD_INT 2
61497: PUSH
61498: LD_INT 3
61500: PUSH
61501: LD_INT 4
61503: PUSH
61504: LD_INT 5
61506: PUSH
61507: EMPTY
61508: LIST
61509: LIST
61510: LIST
61511: LIST
61512: ST_TO_ADDR
61513: GO 62304
61515: LD_INT 7
61517: DOUBLE
61518: EQUAL
61519: IFTRUE 61523
61521: GO 61549
61523: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
61524: LD_ADDR_VAR 0 3
61528: PUSH
61529: LD_INT 2
61531: PUSH
61532: LD_INT 3
61534: PUSH
61535: LD_INT 4
61537: PUSH
61538: LD_INT 5
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: LIST
61545: LIST
61546: ST_TO_ADDR
61547: GO 62304
61549: LD_INT 12
61551: DOUBLE
61552: EQUAL
61553: IFTRUE 61557
61555: GO 61583
61557: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
61558: LD_ADDR_VAR 0 3
61562: PUSH
61563: LD_INT 2
61565: PUSH
61566: LD_INT 3
61568: PUSH
61569: LD_INT 4
61571: PUSH
61572: LD_INT 5
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: LIST
61579: LIST
61580: ST_TO_ADDR
61581: GO 62304
61583: LD_INT 13
61585: DOUBLE
61586: EQUAL
61587: IFTRUE 61591
61589: GO 61617
61591: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
61592: LD_ADDR_VAR 0 3
61596: PUSH
61597: LD_INT 2
61599: PUSH
61600: LD_INT 3
61602: PUSH
61603: LD_INT 4
61605: PUSH
61606: LD_INT 5
61608: PUSH
61609: EMPTY
61610: LIST
61611: LIST
61612: LIST
61613: LIST
61614: ST_TO_ADDR
61615: GO 62304
61617: LD_INT 14
61619: DOUBLE
61620: EQUAL
61621: IFTRUE 61625
61623: GO 61643
61625: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
61626: LD_ADDR_VAR 0 3
61630: PUSH
61631: LD_INT 4
61633: PUSH
61634: LD_INT 5
61636: PUSH
61637: EMPTY
61638: LIST
61639: LIST
61640: ST_TO_ADDR
61641: GO 62304
61643: LD_INT 6
61645: DOUBLE
61646: EQUAL
61647: IFTRUE 61651
61649: GO 61669
61651: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
61652: LD_ADDR_VAR 0 3
61656: PUSH
61657: LD_INT 4
61659: PUSH
61660: LD_INT 5
61662: PUSH
61663: EMPTY
61664: LIST
61665: LIST
61666: ST_TO_ADDR
61667: GO 62304
61669: LD_INT 10
61671: DOUBLE
61672: EQUAL
61673: IFTRUE 61677
61675: GO 61695
61677: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
61678: LD_ADDR_VAR 0 3
61682: PUSH
61683: LD_INT 4
61685: PUSH
61686: LD_INT 5
61688: PUSH
61689: EMPTY
61690: LIST
61691: LIST
61692: ST_TO_ADDR
61693: GO 62304
61695: LD_INT 22
61697: DOUBLE
61698: EQUAL
61699: IFTRUE 61703
61701: GO 61729
61703: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
61704: LD_ADDR_VAR 0 3
61708: PUSH
61709: LD_INT 11
61711: PUSH
61712: LD_INT 12
61714: PUSH
61715: LD_INT 13
61717: PUSH
61718: LD_INT 14
61720: PUSH
61721: EMPTY
61722: LIST
61723: LIST
61724: LIST
61725: LIST
61726: ST_TO_ADDR
61727: GO 62304
61729: LD_INT 23
61731: DOUBLE
61732: EQUAL
61733: IFTRUE 61737
61735: GO 61763
61737: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
61738: LD_ADDR_VAR 0 3
61742: PUSH
61743: LD_INT 11
61745: PUSH
61746: LD_INT 12
61748: PUSH
61749: LD_INT 13
61751: PUSH
61752: LD_INT 14
61754: PUSH
61755: EMPTY
61756: LIST
61757: LIST
61758: LIST
61759: LIST
61760: ST_TO_ADDR
61761: GO 62304
61763: LD_INT 24
61765: DOUBLE
61766: EQUAL
61767: IFTRUE 61771
61769: GO 61797
61771: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
61772: LD_ADDR_VAR 0 3
61776: PUSH
61777: LD_INT 11
61779: PUSH
61780: LD_INT 12
61782: PUSH
61783: LD_INT 13
61785: PUSH
61786: LD_INT 14
61788: PUSH
61789: EMPTY
61790: LIST
61791: LIST
61792: LIST
61793: LIST
61794: ST_TO_ADDR
61795: GO 62304
61797: LD_INT 30
61799: DOUBLE
61800: EQUAL
61801: IFTRUE 61805
61803: GO 61831
61805: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
61806: LD_ADDR_VAR 0 3
61810: PUSH
61811: LD_INT 11
61813: PUSH
61814: LD_INT 12
61816: PUSH
61817: LD_INT 13
61819: PUSH
61820: LD_INT 14
61822: PUSH
61823: EMPTY
61824: LIST
61825: LIST
61826: LIST
61827: LIST
61828: ST_TO_ADDR
61829: GO 62304
61831: LD_INT 25
61833: DOUBLE
61834: EQUAL
61835: IFTRUE 61839
61837: GO 61857
61839: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
61840: LD_ADDR_VAR 0 3
61844: PUSH
61845: LD_INT 13
61847: PUSH
61848: LD_INT 14
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: ST_TO_ADDR
61855: GO 62304
61857: LD_INT 27
61859: DOUBLE
61860: EQUAL
61861: IFTRUE 61865
61863: GO 61883
61865: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
61866: LD_ADDR_VAR 0 3
61870: PUSH
61871: LD_INT 13
61873: PUSH
61874: LD_INT 14
61876: PUSH
61877: EMPTY
61878: LIST
61879: LIST
61880: ST_TO_ADDR
61881: GO 62304
61883: LD_INT 28
61885: DOUBLE
61886: EQUAL
61887: IFTRUE 61891
61889: GO 61909
61891: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
61892: LD_ADDR_VAR 0 3
61896: PUSH
61897: LD_INT 13
61899: PUSH
61900: LD_INT 14
61902: PUSH
61903: EMPTY
61904: LIST
61905: LIST
61906: ST_TO_ADDR
61907: GO 62304
61909: LD_INT 29
61911: DOUBLE
61912: EQUAL
61913: IFTRUE 61917
61915: GO 61935
61917: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
61918: LD_ADDR_VAR 0 3
61922: PUSH
61923: LD_INT 13
61925: PUSH
61926: LD_INT 14
61928: PUSH
61929: EMPTY
61930: LIST
61931: LIST
61932: ST_TO_ADDR
61933: GO 62304
61935: LD_INT 31
61937: DOUBLE
61938: EQUAL
61939: IFTRUE 61943
61941: GO 61961
61943: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
61944: LD_ADDR_VAR 0 3
61948: PUSH
61949: LD_INT 13
61951: PUSH
61952: LD_INT 14
61954: PUSH
61955: EMPTY
61956: LIST
61957: LIST
61958: ST_TO_ADDR
61959: GO 62304
61961: LD_INT 26
61963: DOUBLE
61964: EQUAL
61965: IFTRUE 61969
61967: GO 61987
61969: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
61970: LD_ADDR_VAR 0 3
61974: PUSH
61975: LD_INT 13
61977: PUSH
61978: LD_INT 14
61980: PUSH
61981: EMPTY
61982: LIST
61983: LIST
61984: ST_TO_ADDR
61985: GO 62304
61987: LD_INT 42
61989: DOUBLE
61990: EQUAL
61991: IFTRUE 61995
61993: GO 62021
61995: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
61996: LD_ADDR_VAR 0 3
62000: PUSH
62001: LD_INT 21
62003: PUSH
62004: LD_INT 22
62006: PUSH
62007: LD_INT 23
62009: PUSH
62010: LD_INT 24
62012: PUSH
62013: EMPTY
62014: LIST
62015: LIST
62016: LIST
62017: LIST
62018: ST_TO_ADDR
62019: GO 62304
62021: LD_INT 43
62023: DOUBLE
62024: EQUAL
62025: IFTRUE 62029
62027: GO 62055
62029: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
62030: LD_ADDR_VAR 0 3
62034: PUSH
62035: LD_INT 21
62037: PUSH
62038: LD_INT 22
62040: PUSH
62041: LD_INT 23
62043: PUSH
62044: LD_INT 24
62046: PUSH
62047: EMPTY
62048: LIST
62049: LIST
62050: LIST
62051: LIST
62052: ST_TO_ADDR
62053: GO 62304
62055: LD_INT 44
62057: DOUBLE
62058: EQUAL
62059: IFTRUE 62063
62061: GO 62089
62063: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
62064: LD_ADDR_VAR 0 3
62068: PUSH
62069: LD_INT 21
62071: PUSH
62072: LD_INT 22
62074: PUSH
62075: LD_INT 23
62077: PUSH
62078: LD_INT 24
62080: PUSH
62081: EMPTY
62082: LIST
62083: LIST
62084: LIST
62085: LIST
62086: ST_TO_ADDR
62087: GO 62304
62089: LD_INT 45
62091: DOUBLE
62092: EQUAL
62093: IFTRUE 62097
62095: GO 62123
62097: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
62098: LD_ADDR_VAR 0 3
62102: PUSH
62103: LD_INT 21
62105: PUSH
62106: LD_INT 22
62108: PUSH
62109: LD_INT 23
62111: PUSH
62112: LD_INT 24
62114: PUSH
62115: EMPTY
62116: LIST
62117: LIST
62118: LIST
62119: LIST
62120: ST_TO_ADDR
62121: GO 62304
62123: LD_INT 49
62125: DOUBLE
62126: EQUAL
62127: IFTRUE 62131
62129: GO 62157
62131: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
62132: LD_ADDR_VAR 0 3
62136: PUSH
62137: LD_INT 21
62139: PUSH
62140: LD_INT 22
62142: PUSH
62143: LD_INT 23
62145: PUSH
62146: LD_INT 24
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: LIST
62153: LIST
62154: ST_TO_ADDR
62155: GO 62304
62157: LD_INT 51
62159: DOUBLE
62160: EQUAL
62161: IFTRUE 62165
62163: GO 62191
62165: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
62166: LD_ADDR_VAR 0 3
62170: PUSH
62171: LD_INT 21
62173: PUSH
62174: LD_INT 22
62176: PUSH
62177: LD_INT 23
62179: PUSH
62180: LD_INT 24
62182: PUSH
62183: EMPTY
62184: LIST
62185: LIST
62186: LIST
62187: LIST
62188: ST_TO_ADDR
62189: GO 62304
62191: LD_INT 52
62193: DOUBLE
62194: EQUAL
62195: IFTRUE 62199
62197: GO 62225
62199: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
62200: LD_ADDR_VAR 0 3
62204: PUSH
62205: LD_INT 21
62207: PUSH
62208: LD_INT 22
62210: PUSH
62211: LD_INT 23
62213: PUSH
62214: LD_INT 24
62216: PUSH
62217: EMPTY
62218: LIST
62219: LIST
62220: LIST
62221: LIST
62222: ST_TO_ADDR
62223: GO 62304
62225: LD_INT 53
62227: DOUBLE
62228: EQUAL
62229: IFTRUE 62233
62231: GO 62251
62233: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
62234: LD_ADDR_VAR 0 3
62238: PUSH
62239: LD_INT 23
62241: PUSH
62242: LD_INT 24
62244: PUSH
62245: EMPTY
62246: LIST
62247: LIST
62248: ST_TO_ADDR
62249: GO 62304
62251: LD_INT 46
62253: DOUBLE
62254: EQUAL
62255: IFTRUE 62259
62257: GO 62277
62259: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
62260: LD_ADDR_VAR 0 3
62264: PUSH
62265: LD_INT 23
62267: PUSH
62268: LD_INT 24
62270: PUSH
62271: EMPTY
62272: LIST
62273: LIST
62274: ST_TO_ADDR
62275: GO 62304
62277: LD_INT 47
62279: DOUBLE
62280: EQUAL
62281: IFTRUE 62285
62283: GO 62303
62285: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
62286: LD_ADDR_VAR 0 3
62290: PUSH
62291: LD_INT 23
62293: PUSH
62294: LD_INT 24
62296: PUSH
62297: EMPTY
62298: LIST
62299: LIST
62300: ST_TO_ADDR
62301: GO 62304
62303: POP
// result := ( chassis in result ) ;
62304: LD_ADDR_VAR 0 3
62308: PUSH
62309: LD_VAR 0 1
62313: PUSH
62314: LD_VAR 0 3
62318: IN
62319: ST_TO_ADDR
// end ;
62320: LD_VAR 0 3
62324: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
62325: LD_INT 0
62327: PPUSH
62328: PPUSH
62329: PPUSH
62330: PPUSH
62331: PPUSH
62332: PPUSH
62333: PPUSH
// result := array ;
62334: LD_ADDR_VAR 0 5
62338: PUSH
62339: LD_VAR 0 1
62343: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
62344: LD_VAR 0 1
62348: NOT
62349: PUSH
62350: LD_VAR 0 2
62354: NOT
62355: OR
62356: PUSH
62357: LD_VAR 0 3
62361: NOT
62362: OR
62363: PUSH
62364: LD_VAR 0 2
62368: PUSH
62369: LD_VAR 0 1
62373: GREATER
62374: OR
62375: PUSH
62376: LD_VAR 0 3
62380: PUSH
62381: LD_VAR 0 1
62385: GREATER
62386: OR
62387: IFFALSE 62391
// exit ;
62389: GO 62687
// if direction then
62391: LD_VAR 0 4
62395: IFFALSE 62459
// begin d := 1 ;
62397: LD_ADDR_VAR 0 9
62401: PUSH
62402: LD_INT 1
62404: ST_TO_ADDR
// if i_from > i_to then
62405: LD_VAR 0 2
62409: PUSH
62410: LD_VAR 0 3
62414: GREATER
62415: IFFALSE 62441
// length := ( array - i_from ) + i_to else
62417: LD_ADDR_VAR 0 11
62421: PUSH
62422: LD_VAR 0 1
62426: PUSH
62427: LD_VAR 0 2
62431: MINUS
62432: PUSH
62433: LD_VAR 0 3
62437: PLUS
62438: ST_TO_ADDR
62439: GO 62457
// length := i_to - i_from ;
62441: LD_ADDR_VAR 0 11
62445: PUSH
62446: LD_VAR 0 3
62450: PUSH
62451: LD_VAR 0 2
62455: MINUS
62456: ST_TO_ADDR
// end else
62457: GO 62520
// begin d := - 1 ;
62459: LD_ADDR_VAR 0 9
62463: PUSH
62464: LD_INT 1
62466: NEG
62467: ST_TO_ADDR
// if i_from > i_to then
62468: LD_VAR 0 2
62472: PUSH
62473: LD_VAR 0 3
62477: GREATER
62478: IFFALSE 62498
// length := i_from - i_to else
62480: LD_ADDR_VAR 0 11
62484: PUSH
62485: LD_VAR 0 2
62489: PUSH
62490: LD_VAR 0 3
62494: MINUS
62495: ST_TO_ADDR
62496: GO 62520
// length := ( array - i_to ) + i_from ;
62498: LD_ADDR_VAR 0 11
62502: PUSH
62503: LD_VAR 0 1
62507: PUSH
62508: LD_VAR 0 3
62512: MINUS
62513: PUSH
62514: LD_VAR 0 2
62518: PLUS
62519: ST_TO_ADDR
// end ; if not length then
62520: LD_VAR 0 11
62524: NOT
62525: IFFALSE 62529
// exit ;
62527: GO 62687
// tmp := array ;
62529: LD_ADDR_VAR 0 10
62533: PUSH
62534: LD_VAR 0 1
62538: ST_TO_ADDR
// for i = 1 to length do
62539: LD_ADDR_VAR 0 6
62543: PUSH
62544: DOUBLE
62545: LD_INT 1
62547: DEC
62548: ST_TO_ADDR
62549: LD_VAR 0 11
62553: PUSH
62554: FOR_TO
62555: IFFALSE 62675
// begin for j = 1 to array do
62557: LD_ADDR_VAR 0 7
62561: PUSH
62562: DOUBLE
62563: LD_INT 1
62565: DEC
62566: ST_TO_ADDR
62567: LD_VAR 0 1
62571: PUSH
62572: FOR_TO
62573: IFFALSE 62661
// begin k := j + d ;
62575: LD_ADDR_VAR 0 8
62579: PUSH
62580: LD_VAR 0 7
62584: PUSH
62585: LD_VAR 0 9
62589: PLUS
62590: ST_TO_ADDR
// if k > array then
62591: LD_VAR 0 8
62595: PUSH
62596: LD_VAR 0 1
62600: GREATER
62601: IFFALSE 62611
// k := 1 ;
62603: LD_ADDR_VAR 0 8
62607: PUSH
62608: LD_INT 1
62610: ST_TO_ADDR
// if not k then
62611: LD_VAR 0 8
62615: NOT
62616: IFFALSE 62628
// k := array ;
62618: LD_ADDR_VAR 0 8
62622: PUSH
62623: LD_VAR 0 1
62627: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
62628: LD_ADDR_VAR 0 10
62632: PUSH
62633: LD_VAR 0 10
62637: PPUSH
62638: LD_VAR 0 8
62642: PPUSH
62643: LD_VAR 0 1
62647: PUSH
62648: LD_VAR 0 7
62652: ARRAY
62653: PPUSH
62654: CALL_OW 1
62658: ST_TO_ADDR
// end ;
62659: GO 62572
62661: POP
62662: POP
// array := tmp ;
62663: LD_ADDR_VAR 0 1
62667: PUSH
62668: LD_VAR 0 10
62672: ST_TO_ADDR
// end ;
62673: GO 62554
62675: POP
62676: POP
// result := array ;
62677: LD_ADDR_VAR 0 5
62681: PUSH
62682: LD_VAR 0 1
62686: ST_TO_ADDR
// end ;
62687: LD_VAR 0 5
62691: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
62692: LD_INT 0
62694: PPUSH
62695: PPUSH
// result := 0 ;
62696: LD_ADDR_VAR 0 3
62700: PUSH
62701: LD_INT 0
62703: ST_TO_ADDR
// if not array or not value in array then
62704: LD_VAR 0 1
62708: NOT
62709: PUSH
62710: LD_VAR 0 2
62714: PUSH
62715: LD_VAR 0 1
62719: IN
62720: NOT
62721: OR
62722: IFFALSE 62726
// exit ;
62724: GO 62780
// for i = 1 to array do
62726: LD_ADDR_VAR 0 4
62730: PUSH
62731: DOUBLE
62732: LD_INT 1
62734: DEC
62735: ST_TO_ADDR
62736: LD_VAR 0 1
62740: PUSH
62741: FOR_TO
62742: IFFALSE 62778
// if value = array [ i ] then
62744: LD_VAR 0 2
62748: PUSH
62749: LD_VAR 0 1
62753: PUSH
62754: LD_VAR 0 4
62758: ARRAY
62759: EQUAL
62760: IFFALSE 62776
// begin result := i ;
62762: LD_ADDR_VAR 0 3
62766: PUSH
62767: LD_VAR 0 4
62771: ST_TO_ADDR
// exit ;
62772: POP
62773: POP
62774: GO 62780
// end ;
62776: GO 62741
62778: POP
62779: POP
// end ;
62780: LD_VAR 0 3
62784: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
62785: LD_INT 0
62787: PPUSH
// vc_chassis := chassis ;
62788: LD_ADDR_OWVAR 37
62792: PUSH
62793: LD_VAR 0 1
62797: ST_TO_ADDR
// vc_engine := engine ;
62798: LD_ADDR_OWVAR 39
62802: PUSH
62803: LD_VAR 0 2
62807: ST_TO_ADDR
// vc_control := control ;
62808: LD_ADDR_OWVAR 38
62812: PUSH
62813: LD_VAR 0 3
62817: ST_TO_ADDR
// vc_weapon := weapon ;
62818: LD_ADDR_OWVAR 40
62822: PUSH
62823: LD_VAR 0 4
62827: ST_TO_ADDR
// vc_fuel_battery := fuel ;
62828: LD_ADDR_OWVAR 41
62832: PUSH
62833: LD_VAR 0 5
62837: ST_TO_ADDR
// end ;
62838: LD_VAR 0 6
62842: RET
// export function WantPlant ( unit ) ; var task ; begin
62843: LD_INT 0
62845: PPUSH
62846: PPUSH
// result := false ;
62847: LD_ADDR_VAR 0 2
62851: PUSH
62852: LD_INT 0
62854: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
62855: LD_ADDR_VAR 0 3
62859: PUSH
62860: LD_VAR 0 1
62864: PPUSH
62865: CALL_OW 437
62869: ST_TO_ADDR
// if task then
62870: LD_VAR 0 3
62874: IFFALSE 62902
// if task [ 1 ] [ 1 ] = p then
62876: LD_VAR 0 3
62880: PUSH
62881: LD_INT 1
62883: ARRAY
62884: PUSH
62885: LD_INT 1
62887: ARRAY
62888: PUSH
62889: LD_STRING p
62891: EQUAL
62892: IFFALSE 62902
// result := true ;
62894: LD_ADDR_VAR 0 2
62898: PUSH
62899: LD_INT 1
62901: ST_TO_ADDR
// end ;
62902: LD_VAR 0 2
62906: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
62907: LD_INT 0
62909: PPUSH
62910: PPUSH
62911: PPUSH
62912: PPUSH
// if pos < 1 then
62913: LD_VAR 0 2
62917: PUSH
62918: LD_INT 1
62920: LESS
62921: IFFALSE 62925
// exit ;
62923: GO 63228
// if pos = 1 then
62925: LD_VAR 0 2
62929: PUSH
62930: LD_INT 1
62932: EQUAL
62933: IFFALSE 62966
// result := Replace ( arr , pos [ 1 ] , value ) else
62935: LD_ADDR_VAR 0 4
62939: PUSH
62940: LD_VAR 0 1
62944: PPUSH
62945: LD_VAR 0 2
62949: PUSH
62950: LD_INT 1
62952: ARRAY
62953: PPUSH
62954: LD_VAR 0 3
62958: PPUSH
62959: CALL_OW 1
62963: ST_TO_ADDR
62964: GO 63228
// begin tmp := arr ;
62966: LD_ADDR_VAR 0 6
62970: PUSH
62971: LD_VAR 0 1
62975: ST_TO_ADDR
// s_arr := [ tmp ] ;
62976: LD_ADDR_VAR 0 7
62980: PUSH
62981: LD_VAR 0 6
62985: PUSH
62986: EMPTY
62987: LIST
62988: ST_TO_ADDR
// for i = 1 to pos - 1 do
62989: LD_ADDR_VAR 0 5
62993: PUSH
62994: DOUBLE
62995: LD_INT 1
62997: DEC
62998: ST_TO_ADDR
62999: LD_VAR 0 2
63003: PUSH
63004: LD_INT 1
63006: MINUS
63007: PUSH
63008: FOR_TO
63009: IFFALSE 63054
// begin tmp := tmp [ pos [ i ] ] ;
63011: LD_ADDR_VAR 0 6
63015: PUSH
63016: LD_VAR 0 6
63020: PUSH
63021: LD_VAR 0 2
63025: PUSH
63026: LD_VAR 0 5
63030: ARRAY
63031: ARRAY
63032: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
63033: LD_ADDR_VAR 0 7
63037: PUSH
63038: LD_VAR 0 7
63042: PUSH
63043: LD_VAR 0 6
63047: PUSH
63048: EMPTY
63049: LIST
63050: ADD
63051: ST_TO_ADDR
// end ;
63052: GO 63008
63054: POP
63055: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
63056: LD_ADDR_VAR 0 6
63060: PUSH
63061: LD_VAR 0 6
63065: PPUSH
63066: LD_VAR 0 2
63070: PUSH
63071: LD_VAR 0 2
63075: ARRAY
63076: PPUSH
63077: LD_VAR 0 3
63081: PPUSH
63082: CALL_OW 1
63086: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
63087: LD_ADDR_VAR 0 7
63091: PUSH
63092: LD_VAR 0 7
63096: PPUSH
63097: LD_VAR 0 7
63101: PPUSH
63102: LD_VAR 0 6
63106: PPUSH
63107: CALL_OW 1
63111: ST_TO_ADDR
// for i = s_arr downto 2 do
63112: LD_ADDR_VAR 0 5
63116: PUSH
63117: DOUBLE
63118: LD_VAR 0 7
63122: INC
63123: ST_TO_ADDR
63124: LD_INT 2
63126: PUSH
63127: FOR_DOWNTO
63128: IFFALSE 63212
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
63130: LD_ADDR_VAR 0 6
63134: PUSH
63135: LD_VAR 0 7
63139: PUSH
63140: LD_VAR 0 5
63144: PUSH
63145: LD_INT 1
63147: MINUS
63148: ARRAY
63149: PPUSH
63150: LD_VAR 0 2
63154: PUSH
63155: LD_VAR 0 5
63159: PUSH
63160: LD_INT 1
63162: MINUS
63163: ARRAY
63164: PPUSH
63165: LD_VAR 0 7
63169: PUSH
63170: LD_VAR 0 5
63174: ARRAY
63175: PPUSH
63176: CALL_OW 1
63180: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
63181: LD_ADDR_VAR 0 7
63185: PUSH
63186: LD_VAR 0 7
63190: PPUSH
63191: LD_VAR 0 5
63195: PUSH
63196: LD_INT 1
63198: MINUS
63199: PPUSH
63200: LD_VAR 0 6
63204: PPUSH
63205: CALL_OW 1
63209: ST_TO_ADDR
// end ;
63210: GO 63127
63212: POP
63213: POP
// result := s_arr [ 1 ] ;
63214: LD_ADDR_VAR 0 4
63218: PUSH
63219: LD_VAR 0 7
63223: PUSH
63224: LD_INT 1
63226: ARRAY
63227: ST_TO_ADDR
// end ; end ;
63228: LD_VAR 0 4
63232: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
63233: LD_INT 0
63235: PPUSH
63236: PPUSH
// if not list then
63237: LD_VAR 0 1
63241: NOT
63242: IFFALSE 63246
// exit ;
63244: GO 63337
// i := list [ pos1 ] ;
63246: LD_ADDR_VAR 0 5
63250: PUSH
63251: LD_VAR 0 1
63255: PUSH
63256: LD_VAR 0 2
63260: ARRAY
63261: ST_TO_ADDR
// if not i then
63262: LD_VAR 0 5
63266: NOT
63267: IFFALSE 63271
// exit ;
63269: GO 63337
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
63271: LD_ADDR_VAR 0 1
63275: PUSH
63276: LD_VAR 0 1
63280: PPUSH
63281: LD_VAR 0 2
63285: PPUSH
63286: LD_VAR 0 1
63290: PUSH
63291: LD_VAR 0 3
63295: ARRAY
63296: PPUSH
63297: CALL_OW 1
63301: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
63302: LD_ADDR_VAR 0 1
63306: PUSH
63307: LD_VAR 0 1
63311: PPUSH
63312: LD_VAR 0 3
63316: PPUSH
63317: LD_VAR 0 5
63321: PPUSH
63322: CALL_OW 1
63326: ST_TO_ADDR
// result := list ;
63327: LD_ADDR_VAR 0 4
63331: PUSH
63332: LD_VAR 0 1
63336: ST_TO_ADDR
// end ;
63337: LD_VAR 0 4
63341: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
63342: LD_INT 0
63344: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
63345: LD_ADDR_VAR 0 5
63349: PUSH
63350: LD_VAR 0 1
63354: PPUSH
63355: CALL_OW 250
63359: PPUSH
63360: LD_VAR 0 1
63364: PPUSH
63365: CALL_OW 251
63369: PPUSH
63370: LD_VAR 0 2
63374: PPUSH
63375: LD_VAR 0 3
63379: PPUSH
63380: LD_VAR 0 4
63384: PPUSH
63385: CALL 63395 0 5
63389: ST_TO_ADDR
// end ;
63390: LD_VAR 0 5
63394: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
63395: LD_INT 0
63397: PPUSH
63398: PPUSH
63399: PPUSH
63400: PPUSH
// if not list then
63401: LD_VAR 0 3
63405: NOT
63406: IFFALSE 63410
// exit ;
63408: GO 63798
// result := [ ] ;
63410: LD_ADDR_VAR 0 6
63414: PUSH
63415: EMPTY
63416: ST_TO_ADDR
// for i in list do
63417: LD_ADDR_VAR 0 7
63421: PUSH
63422: LD_VAR 0 3
63426: PUSH
63427: FOR_IN
63428: IFFALSE 63630
// begin tmp := GetDistUnitXY ( i , x , y ) ;
63430: LD_ADDR_VAR 0 9
63434: PUSH
63435: LD_VAR 0 7
63439: PPUSH
63440: LD_VAR 0 1
63444: PPUSH
63445: LD_VAR 0 2
63449: PPUSH
63450: CALL_OW 297
63454: ST_TO_ADDR
// if not result then
63455: LD_VAR 0 6
63459: NOT
63460: IFFALSE 63486
// result := [ [ i , tmp ] ] else
63462: LD_ADDR_VAR 0 6
63466: PUSH
63467: LD_VAR 0 7
63471: PUSH
63472: LD_VAR 0 9
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: EMPTY
63482: LIST
63483: ST_TO_ADDR
63484: GO 63628
// begin if result [ result ] [ 2 ] < tmp then
63486: LD_VAR 0 6
63490: PUSH
63491: LD_VAR 0 6
63495: ARRAY
63496: PUSH
63497: LD_INT 2
63499: ARRAY
63500: PUSH
63501: LD_VAR 0 9
63505: LESS
63506: IFFALSE 63548
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
63508: LD_ADDR_VAR 0 6
63512: PUSH
63513: LD_VAR 0 6
63517: PPUSH
63518: LD_VAR 0 6
63522: PUSH
63523: LD_INT 1
63525: PLUS
63526: PPUSH
63527: LD_VAR 0 7
63531: PUSH
63532: LD_VAR 0 9
63536: PUSH
63537: EMPTY
63538: LIST
63539: LIST
63540: PPUSH
63541: CALL_OW 2
63545: ST_TO_ADDR
63546: GO 63628
// for j = 1 to result do
63548: LD_ADDR_VAR 0 8
63552: PUSH
63553: DOUBLE
63554: LD_INT 1
63556: DEC
63557: ST_TO_ADDR
63558: LD_VAR 0 6
63562: PUSH
63563: FOR_TO
63564: IFFALSE 63626
// begin if tmp < result [ j ] [ 2 ] then
63566: LD_VAR 0 9
63570: PUSH
63571: LD_VAR 0 6
63575: PUSH
63576: LD_VAR 0 8
63580: ARRAY
63581: PUSH
63582: LD_INT 2
63584: ARRAY
63585: LESS
63586: IFFALSE 63624
// begin result := Insert ( result , j , [ i , tmp ] ) ;
63588: LD_ADDR_VAR 0 6
63592: PUSH
63593: LD_VAR 0 6
63597: PPUSH
63598: LD_VAR 0 8
63602: PPUSH
63603: LD_VAR 0 7
63607: PUSH
63608: LD_VAR 0 9
63612: PUSH
63613: EMPTY
63614: LIST
63615: LIST
63616: PPUSH
63617: CALL_OW 2
63621: ST_TO_ADDR
// break ;
63622: GO 63626
// end ; end ;
63624: GO 63563
63626: POP
63627: POP
// end ; end ;
63628: GO 63427
63630: POP
63631: POP
// if result and not asc then
63632: LD_VAR 0 6
63636: PUSH
63637: LD_VAR 0 4
63641: NOT
63642: AND
63643: IFFALSE 63718
// begin tmp := result ;
63645: LD_ADDR_VAR 0 9
63649: PUSH
63650: LD_VAR 0 6
63654: ST_TO_ADDR
// for i = tmp downto 1 do
63655: LD_ADDR_VAR 0 7
63659: PUSH
63660: DOUBLE
63661: LD_VAR 0 9
63665: INC
63666: ST_TO_ADDR
63667: LD_INT 1
63669: PUSH
63670: FOR_DOWNTO
63671: IFFALSE 63716
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
63673: LD_ADDR_VAR 0 6
63677: PUSH
63678: LD_VAR 0 6
63682: PPUSH
63683: LD_VAR 0 9
63687: PUSH
63688: LD_VAR 0 7
63692: MINUS
63693: PUSH
63694: LD_INT 1
63696: PLUS
63697: PPUSH
63698: LD_VAR 0 9
63702: PUSH
63703: LD_VAR 0 7
63707: ARRAY
63708: PPUSH
63709: CALL_OW 1
63713: ST_TO_ADDR
63714: GO 63670
63716: POP
63717: POP
// end ; tmp := [ ] ;
63718: LD_ADDR_VAR 0 9
63722: PUSH
63723: EMPTY
63724: ST_TO_ADDR
// if mode then
63725: LD_VAR 0 5
63729: IFFALSE 63798
// begin for i = 1 to result do
63731: LD_ADDR_VAR 0 7
63735: PUSH
63736: DOUBLE
63737: LD_INT 1
63739: DEC
63740: ST_TO_ADDR
63741: LD_VAR 0 6
63745: PUSH
63746: FOR_TO
63747: IFFALSE 63786
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
63749: LD_ADDR_VAR 0 9
63753: PUSH
63754: LD_VAR 0 9
63758: PPUSH
63759: LD_VAR 0 7
63763: PPUSH
63764: LD_VAR 0 6
63768: PUSH
63769: LD_VAR 0 7
63773: ARRAY
63774: PUSH
63775: LD_INT 1
63777: ARRAY
63778: PPUSH
63779: CALL_OW 1
63783: ST_TO_ADDR
63784: GO 63746
63786: POP
63787: POP
// result := tmp ;
63788: LD_ADDR_VAR 0 6
63792: PUSH
63793: LD_VAR 0 9
63797: ST_TO_ADDR
// end ; end ;
63798: LD_VAR 0 6
63802: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
63803: LD_INT 0
63805: PPUSH
63806: PPUSH
63807: PPUSH
63808: PPUSH
63809: PPUSH
63810: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
63811: LD_ADDR_VAR 0 5
63815: PUSH
63816: LD_INT 0
63818: PUSH
63819: LD_INT 0
63821: PUSH
63822: LD_INT 0
63824: PUSH
63825: EMPTY
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: LIST
63831: LIST
63832: ST_TO_ADDR
// if not x or not y then
63833: LD_VAR 0 2
63837: NOT
63838: PUSH
63839: LD_VAR 0 3
63843: NOT
63844: OR
63845: IFFALSE 63849
// exit ;
63847: GO 65495
// if not range then
63849: LD_VAR 0 4
63853: NOT
63854: IFFALSE 63864
// range := 10 ;
63856: LD_ADDR_VAR 0 4
63860: PUSH
63861: LD_INT 10
63863: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63864: LD_ADDR_VAR 0 8
63868: PUSH
63869: LD_INT 81
63871: PUSH
63872: LD_VAR 0 1
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PUSH
63881: LD_INT 92
63883: PUSH
63884: LD_VAR 0 2
63888: PUSH
63889: LD_VAR 0 3
63893: PUSH
63894: LD_VAR 0 4
63898: PUSH
63899: EMPTY
63900: LIST
63901: LIST
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 3
63907: PUSH
63908: LD_INT 21
63910: PUSH
63911: LD_INT 3
63913: PUSH
63914: EMPTY
63915: LIST
63916: LIST
63917: PUSH
63918: EMPTY
63919: LIST
63920: LIST
63921: PUSH
63922: EMPTY
63923: LIST
63924: LIST
63925: LIST
63926: PPUSH
63927: CALL_OW 69
63931: ST_TO_ADDR
// if not tmp then
63932: LD_VAR 0 8
63936: NOT
63937: IFFALSE 63941
// exit ;
63939: GO 65495
// for i in tmp do
63941: LD_ADDR_VAR 0 6
63945: PUSH
63946: LD_VAR 0 8
63950: PUSH
63951: FOR_IN
63952: IFFALSE 65470
// begin points := [ 0 , 0 , 0 ] ;
63954: LD_ADDR_VAR 0 9
63958: PUSH
63959: LD_INT 0
63961: PUSH
63962: LD_INT 0
63964: PUSH
63965: LD_INT 0
63967: PUSH
63968: EMPTY
63969: LIST
63970: LIST
63971: LIST
63972: ST_TO_ADDR
// bpoints := 1 ;
63973: LD_ADDR_VAR 0 10
63977: PUSH
63978: LD_INT 1
63980: ST_TO_ADDR
// case GetType ( i ) of unit_human :
63981: LD_VAR 0 6
63985: PPUSH
63986: CALL_OW 247
63990: PUSH
63991: LD_INT 1
63993: DOUBLE
63994: EQUAL
63995: IFTRUE 63999
63997: GO 64577
63999: POP
// begin if GetClass ( i ) = 1 then
64000: LD_VAR 0 6
64004: PPUSH
64005: CALL_OW 257
64009: PUSH
64010: LD_INT 1
64012: EQUAL
64013: IFFALSE 64034
// points := [ 10 , 5 , 3 ] ;
64015: LD_ADDR_VAR 0 9
64019: PUSH
64020: LD_INT 10
64022: PUSH
64023: LD_INT 5
64025: PUSH
64026: LD_INT 3
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: LIST
64033: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
64034: LD_VAR 0 6
64038: PPUSH
64039: CALL_OW 257
64043: PUSH
64044: LD_INT 2
64046: PUSH
64047: LD_INT 3
64049: PUSH
64050: LD_INT 4
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: LIST
64057: IN
64058: IFFALSE 64079
// points := [ 3 , 2 , 1 ] ;
64060: LD_ADDR_VAR 0 9
64064: PUSH
64065: LD_INT 3
64067: PUSH
64068: LD_INT 2
64070: PUSH
64071: LD_INT 1
64073: PUSH
64074: EMPTY
64075: LIST
64076: LIST
64077: LIST
64078: ST_TO_ADDR
// if GetClass ( i ) = 5 then
64079: LD_VAR 0 6
64083: PPUSH
64084: CALL_OW 257
64088: PUSH
64089: LD_INT 5
64091: EQUAL
64092: IFFALSE 64113
// points := [ 130 , 5 , 2 ] ;
64094: LD_ADDR_VAR 0 9
64098: PUSH
64099: LD_INT 130
64101: PUSH
64102: LD_INT 5
64104: PUSH
64105: LD_INT 2
64107: PUSH
64108: EMPTY
64109: LIST
64110: LIST
64111: LIST
64112: ST_TO_ADDR
// if GetClass ( i ) = 8 then
64113: LD_VAR 0 6
64117: PPUSH
64118: CALL_OW 257
64122: PUSH
64123: LD_INT 8
64125: EQUAL
64126: IFFALSE 64147
// points := [ 35 , 35 , 30 ] ;
64128: LD_ADDR_VAR 0 9
64132: PUSH
64133: LD_INT 35
64135: PUSH
64136: LD_INT 35
64138: PUSH
64139: LD_INT 30
64141: PUSH
64142: EMPTY
64143: LIST
64144: LIST
64145: LIST
64146: ST_TO_ADDR
// if GetClass ( i ) = 9 then
64147: LD_VAR 0 6
64151: PPUSH
64152: CALL_OW 257
64156: PUSH
64157: LD_INT 9
64159: EQUAL
64160: IFFALSE 64181
// points := [ 20 , 55 , 40 ] ;
64162: LD_ADDR_VAR 0 9
64166: PUSH
64167: LD_INT 20
64169: PUSH
64170: LD_INT 55
64172: PUSH
64173: LD_INT 40
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: LIST
64180: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
64181: LD_VAR 0 6
64185: PPUSH
64186: CALL_OW 257
64190: PUSH
64191: LD_INT 12
64193: PUSH
64194: LD_INT 16
64196: PUSH
64197: EMPTY
64198: LIST
64199: LIST
64200: IN
64201: IFFALSE 64222
// points := [ 5 , 3 , 2 ] ;
64203: LD_ADDR_VAR 0 9
64207: PUSH
64208: LD_INT 5
64210: PUSH
64211: LD_INT 3
64213: PUSH
64214: LD_INT 2
64216: PUSH
64217: EMPTY
64218: LIST
64219: LIST
64220: LIST
64221: ST_TO_ADDR
// if GetClass ( i ) = 17 then
64222: LD_VAR 0 6
64226: PPUSH
64227: CALL_OW 257
64231: PUSH
64232: LD_INT 17
64234: EQUAL
64235: IFFALSE 64256
// points := [ 100 , 50 , 75 ] ;
64237: LD_ADDR_VAR 0 9
64241: PUSH
64242: LD_INT 100
64244: PUSH
64245: LD_INT 50
64247: PUSH
64248: LD_INT 75
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: LIST
64255: ST_TO_ADDR
// if GetClass ( i ) = 15 then
64256: LD_VAR 0 6
64260: PPUSH
64261: CALL_OW 257
64265: PUSH
64266: LD_INT 15
64268: EQUAL
64269: IFFALSE 64290
// points := [ 10 , 5 , 3 ] ;
64271: LD_ADDR_VAR 0 9
64275: PUSH
64276: LD_INT 10
64278: PUSH
64279: LD_INT 5
64281: PUSH
64282: LD_INT 3
64284: PUSH
64285: EMPTY
64286: LIST
64287: LIST
64288: LIST
64289: ST_TO_ADDR
// if GetClass ( i ) = 14 then
64290: LD_VAR 0 6
64294: PPUSH
64295: CALL_OW 257
64299: PUSH
64300: LD_INT 14
64302: EQUAL
64303: IFFALSE 64324
// points := [ 10 , 0 , 0 ] ;
64305: LD_ADDR_VAR 0 9
64309: PUSH
64310: LD_INT 10
64312: PUSH
64313: LD_INT 0
64315: PUSH
64316: LD_INT 0
64318: PUSH
64319: EMPTY
64320: LIST
64321: LIST
64322: LIST
64323: ST_TO_ADDR
// if GetClass ( i ) = 11 then
64324: LD_VAR 0 6
64328: PPUSH
64329: CALL_OW 257
64333: PUSH
64334: LD_INT 11
64336: EQUAL
64337: IFFALSE 64358
// points := [ 30 , 10 , 5 ] ;
64339: LD_ADDR_VAR 0 9
64343: PUSH
64344: LD_INT 30
64346: PUSH
64347: LD_INT 10
64349: PUSH
64350: LD_INT 5
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: LIST
64357: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
64358: LD_VAR 0 1
64362: PPUSH
64363: LD_INT 5
64365: PPUSH
64366: CALL_OW 321
64370: PUSH
64371: LD_INT 2
64373: EQUAL
64374: IFFALSE 64391
// bpoints := bpoints * 1.8 ;
64376: LD_ADDR_VAR 0 10
64380: PUSH
64381: LD_VAR 0 10
64385: PUSH
64386: LD_REAL  1.80000000000000E+0000
64389: MUL
64390: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
64391: LD_VAR 0 6
64395: PPUSH
64396: CALL_OW 257
64400: PUSH
64401: LD_INT 1
64403: PUSH
64404: LD_INT 2
64406: PUSH
64407: LD_INT 3
64409: PUSH
64410: LD_INT 4
64412: PUSH
64413: EMPTY
64414: LIST
64415: LIST
64416: LIST
64417: LIST
64418: IN
64419: PUSH
64420: LD_VAR 0 1
64424: PPUSH
64425: LD_INT 51
64427: PPUSH
64428: CALL_OW 321
64432: PUSH
64433: LD_INT 2
64435: EQUAL
64436: AND
64437: IFFALSE 64454
// bpoints := bpoints * 1.2 ;
64439: LD_ADDR_VAR 0 10
64443: PUSH
64444: LD_VAR 0 10
64448: PUSH
64449: LD_REAL  1.20000000000000E+0000
64452: MUL
64453: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
64454: LD_VAR 0 6
64458: PPUSH
64459: CALL_OW 257
64463: PUSH
64464: LD_INT 5
64466: PUSH
64467: LD_INT 7
64469: PUSH
64470: LD_INT 9
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: LIST
64477: IN
64478: PUSH
64479: LD_VAR 0 1
64483: PPUSH
64484: LD_INT 52
64486: PPUSH
64487: CALL_OW 321
64491: PUSH
64492: LD_INT 2
64494: EQUAL
64495: AND
64496: IFFALSE 64513
// bpoints := bpoints * 1.5 ;
64498: LD_ADDR_VAR 0 10
64502: PUSH
64503: LD_VAR 0 10
64507: PUSH
64508: LD_REAL  1.50000000000000E+0000
64511: MUL
64512: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
64513: LD_VAR 0 1
64517: PPUSH
64518: LD_INT 66
64520: PPUSH
64521: CALL_OW 321
64525: PUSH
64526: LD_INT 2
64528: EQUAL
64529: IFFALSE 64546
// bpoints := bpoints * 1.1 ;
64531: LD_ADDR_VAR 0 10
64535: PUSH
64536: LD_VAR 0 10
64540: PUSH
64541: LD_REAL  1.10000000000000E+0000
64544: MUL
64545: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
64546: LD_ADDR_VAR 0 10
64550: PUSH
64551: LD_VAR 0 10
64555: PUSH
64556: LD_VAR 0 6
64560: PPUSH
64561: LD_INT 1
64563: PPUSH
64564: CALL_OW 259
64568: PUSH
64569: LD_REAL  1.15000000000000E+0000
64572: MUL
64573: MUL
64574: ST_TO_ADDR
// end ; unit_vehicle :
64575: GO 65399
64577: LD_INT 2
64579: DOUBLE
64580: EQUAL
64581: IFTRUE 64585
64583: GO 65387
64585: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
64586: LD_VAR 0 6
64590: PPUSH
64591: CALL_OW 264
64595: PUSH
64596: LD_INT 2
64598: PUSH
64599: LD_INT 42
64601: PUSH
64602: LD_INT 24
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: LIST
64609: IN
64610: IFFALSE 64631
// points := [ 25 , 5 , 3 ] ;
64612: LD_ADDR_VAR 0 9
64616: PUSH
64617: LD_INT 25
64619: PUSH
64620: LD_INT 5
64622: PUSH
64623: LD_INT 3
64625: PUSH
64626: EMPTY
64627: LIST
64628: LIST
64629: LIST
64630: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
64631: LD_VAR 0 6
64635: PPUSH
64636: CALL_OW 264
64640: PUSH
64641: LD_INT 4
64643: PUSH
64644: LD_INT 43
64646: PUSH
64647: LD_INT 25
64649: PUSH
64650: EMPTY
64651: LIST
64652: LIST
64653: LIST
64654: IN
64655: IFFALSE 64676
// points := [ 40 , 15 , 5 ] ;
64657: LD_ADDR_VAR 0 9
64661: PUSH
64662: LD_INT 40
64664: PUSH
64665: LD_INT 15
64667: PUSH
64668: LD_INT 5
64670: PUSH
64671: EMPTY
64672: LIST
64673: LIST
64674: LIST
64675: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
64676: LD_VAR 0 6
64680: PPUSH
64681: CALL_OW 264
64685: PUSH
64686: LD_INT 3
64688: PUSH
64689: LD_INT 23
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: IN
64696: IFFALSE 64717
// points := [ 7 , 25 , 8 ] ;
64698: LD_ADDR_VAR 0 9
64702: PUSH
64703: LD_INT 7
64705: PUSH
64706: LD_INT 25
64708: PUSH
64709: LD_INT 8
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: LIST
64716: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
64717: LD_VAR 0 6
64721: PPUSH
64722: CALL_OW 264
64726: PUSH
64727: LD_INT 5
64729: PUSH
64730: LD_INT 27
64732: PUSH
64733: LD_INT 44
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: LIST
64740: IN
64741: IFFALSE 64762
// points := [ 14 , 50 , 16 ] ;
64743: LD_ADDR_VAR 0 9
64747: PUSH
64748: LD_INT 14
64750: PUSH
64751: LD_INT 50
64753: PUSH
64754: LD_INT 16
64756: PUSH
64757: EMPTY
64758: LIST
64759: LIST
64760: LIST
64761: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
64762: LD_VAR 0 6
64766: PPUSH
64767: CALL_OW 264
64771: PUSH
64772: LD_INT 6
64774: PUSH
64775: LD_INT 46
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: IN
64782: IFFALSE 64803
// points := [ 32 , 120 , 70 ] ;
64784: LD_ADDR_VAR 0 9
64788: PUSH
64789: LD_INT 32
64791: PUSH
64792: LD_INT 120
64794: PUSH
64795: LD_INT 70
64797: PUSH
64798: EMPTY
64799: LIST
64800: LIST
64801: LIST
64802: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
64803: LD_VAR 0 6
64807: PPUSH
64808: CALL_OW 264
64812: PUSH
64813: LD_INT 7
64815: PUSH
64816: LD_INT 28
64818: PUSH
64819: LD_INT 45
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: LIST
64826: IN
64827: IFFALSE 64848
// points := [ 35 , 20 , 45 ] ;
64829: LD_ADDR_VAR 0 9
64833: PUSH
64834: LD_INT 35
64836: PUSH
64837: LD_INT 20
64839: PUSH
64840: LD_INT 45
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: LIST
64847: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
64848: LD_VAR 0 6
64852: PPUSH
64853: CALL_OW 264
64857: PUSH
64858: LD_INT 47
64860: PUSH
64861: EMPTY
64862: LIST
64863: IN
64864: IFFALSE 64885
// points := [ 67 , 45 , 75 ] ;
64866: LD_ADDR_VAR 0 9
64870: PUSH
64871: LD_INT 67
64873: PUSH
64874: LD_INT 45
64876: PUSH
64877: LD_INT 75
64879: PUSH
64880: EMPTY
64881: LIST
64882: LIST
64883: LIST
64884: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
64885: LD_VAR 0 6
64889: PPUSH
64890: CALL_OW 264
64894: PUSH
64895: LD_INT 26
64897: PUSH
64898: EMPTY
64899: LIST
64900: IN
64901: IFFALSE 64922
// points := [ 120 , 30 , 80 ] ;
64903: LD_ADDR_VAR 0 9
64907: PUSH
64908: LD_INT 120
64910: PUSH
64911: LD_INT 30
64913: PUSH
64914: LD_INT 80
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: LIST
64921: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
64922: LD_VAR 0 6
64926: PPUSH
64927: CALL_OW 264
64931: PUSH
64932: LD_INT 22
64934: PUSH
64935: EMPTY
64936: LIST
64937: IN
64938: IFFALSE 64959
// points := [ 40 , 1 , 1 ] ;
64940: LD_ADDR_VAR 0 9
64944: PUSH
64945: LD_INT 40
64947: PUSH
64948: LD_INT 1
64950: PUSH
64951: LD_INT 1
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: LIST
64958: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
64959: LD_VAR 0 6
64963: PPUSH
64964: CALL_OW 264
64968: PUSH
64969: LD_INT 29
64971: PUSH
64972: EMPTY
64973: LIST
64974: IN
64975: IFFALSE 64996
// points := [ 70 , 200 , 400 ] ;
64977: LD_ADDR_VAR 0 9
64981: PUSH
64982: LD_INT 70
64984: PUSH
64985: LD_INT 200
64987: PUSH
64988: LD_INT 400
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: LIST
64995: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
64996: LD_VAR 0 6
65000: PPUSH
65001: CALL_OW 264
65005: PUSH
65006: LD_INT 14
65008: PUSH
65009: LD_INT 53
65011: PUSH
65012: EMPTY
65013: LIST
65014: LIST
65015: IN
65016: IFFALSE 65037
// points := [ 40 , 10 , 20 ] ;
65018: LD_ADDR_VAR 0 9
65022: PUSH
65023: LD_INT 40
65025: PUSH
65026: LD_INT 10
65028: PUSH
65029: LD_INT 20
65031: PUSH
65032: EMPTY
65033: LIST
65034: LIST
65035: LIST
65036: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
65037: LD_VAR 0 6
65041: PPUSH
65042: CALL_OW 264
65046: PUSH
65047: LD_INT 9
65049: PUSH
65050: EMPTY
65051: LIST
65052: IN
65053: IFFALSE 65074
// points := [ 5 , 70 , 20 ] ;
65055: LD_ADDR_VAR 0 9
65059: PUSH
65060: LD_INT 5
65062: PUSH
65063: LD_INT 70
65065: PUSH
65066: LD_INT 20
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: LIST
65073: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
65074: LD_VAR 0 6
65078: PPUSH
65079: CALL_OW 264
65083: PUSH
65084: LD_INT 10
65086: PUSH
65087: EMPTY
65088: LIST
65089: IN
65090: IFFALSE 65111
// points := [ 35 , 110 , 70 ] ;
65092: LD_ADDR_VAR 0 9
65096: PUSH
65097: LD_INT 35
65099: PUSH
65100: LD_INT 110
65102: PUSH
65103: LD_INT 70
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: LIST
65110: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
65111: LD_VAR 0 6
65115: PPUSH
65116: CALL_OW 265
65120: PUSH
65121: LD_INT 25
65123: EQUAL
65124: IFFALSE 65145
// points := [ 80 , 65 , 100 ] ;
65126: LD_ADDR_VAR 0 9
65130: PUSH
65131: LD_INT 80
65133: PUSH
65134: LD_INT 65
65136: PUSH
65137: LD_INT 100
65139: PUSH
65140: EMPTY
65141: LIST
65142: LIST
65143: LIST
65144: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
65145: LD_VAR 0 6
65149: PPUSH
65150: CALL_OW 263
65154: PUSH
65155: LD_INT 1
65157: EQUAL
65158: IFFALSE 65193
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
65160: LD_ADDR_VAR 0 10
65164: PUSH
65165: LD_VAR 0 10
65169: PUSH
65170: LD_VAR 0 6
65174: PPUSH
65175: CALL_OW 311
65179: PPUSH
65180: LD_INT 3
65182: PPUSH
65183: CALL_OW 259
65187: PUSH
65188: LD_INT 4
65190: MUL
65191: MUL
65192: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
65193: LD_VAR 0 6
65197: PPUSH
65198: CALL_OW 263
65202: PUSH
65203: LD_INT 2
65205: EQUAL
65206: IFFALSE 65257
// begin j := IsControledBy ( i ) ;
65208: LD_ADDR_VAR 0 7
65212: PUSH
65213: LD_VAR 0 6
65217: PPUSH
65218: CALL_OW 312
65222: ST_TO_ADDR
// if j then
65223: LD_VAR 0 7
65227: IFFALSE 65257
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
65229: LD_ADDR_VAR 0 10
65233: PUSH
65234: LD_VAR 0 10
65238: PUSH
65239: LD_VAR 0 7
65243: PPUSH
65244: LD_INT 3
65246: PPUSH
65247: CALL_OW 259
65251: PUSH
65252: LD_INT 3
65254: MUL
65255: MUL
65256: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
65257: LD_VAR 0 6
65261: PPUSH
65262: CALL_OW 264
65266: PUSH
65267: LD_INT 5
65269: PUSH
65270: LD_INT 6
65272: PUSH
65273: LD_INT 46
65275: PUSH
65276: LD_INT 44
65278: PUSH
65279: LD_INT 47
65281: PUSH
65282: LD_INT 45
65284: PUSH
65285: LD_INT 28
65287: PUSH
65288: LD_INT 7
65290: PUSH
65291: LD_INT 27
65293: PUSH
65294: LD_INT 29
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: LIST
65301: LIST
65302: LIST
65303: LIST
65304: LIST
65305: LIST
65306: LIST
65307: LIST
65308: IN
65309: PUSH
65310: LD_VAR 0 1
65314: PPUSH
65315: LD_INT 52
65317: PPUSH
65318: CALL_OW 321
65322: PUSH
65323: LD_INT 2
65325: EQUAL
65326: AND
65327: IFFALSE 65344
// bpoints := bpoints * 1.2 ;
65329: LD_ADDR_VAR 0 10
65333: PUSH
65334: LD_VAR 0 10
65338: PUSH
65339: LD_REAL  1.20000000000000E+0000
65342: MUL
65343: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
65344: LD_VAR 0 6
65348: PPUSH
65349: CALL_OW 264
65353: PUSH
65354: LD_INT 6
65356: PUSH
65357: LD_INT 46
65359: PUSH
65360: LD_INT 47
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: LIST
65367: IN
65368: IFFALSE 65385
// bpoints := bpoints * 1.2 ;
65370: LD_ADDR_VAR 0 10
65374: PUSH
65375: LD_VAR 0 10
65379: PUSH
65380: LD_REAL  1.20000000000000E+0000
65383: MUL
65384: ST_TO_ADDR
// end ; unit_building :
65385: GO 65399
65387: LD_INT 3
65389: DOUBLE
65390: EQUAL
65391: IFTRUE 65395
65393: GO 65398
65395: POP
// ; end ;
65396: GO 65399
65398: POP
// for j = 1 to 3 do
65399: LD_ADDR_VAR 0 7
65403: PUSH
65404: DOUBLE
65405: LD_INT 1
65407: DEC
65408: ST_TO_ADDR
65409: LD_INT 3
65411: PUSH
65412: FOR_TO
65413: IFFALSE 65466
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
65415: LD_ADDR_VAR 0 5
65419: PUSH
65420: LD_VAR 0 5
65424: PPUSH
65425: LD_VAR 0 7
65429: PPUSH
65430: LD_VAR 0 5
65434: PUSH
65435: LD_VAR 0 7
65439: ARRAY
65440: PUSH
65441: LD_VAR 0 9
65445: PUSH
65446: LD_VAR 0 7
65450: ARRAY
65451: PUSH
65452: LD_VAR 0 10
65456: MUL
65457: PLUS
65458: PPUSH
65459: CALL_OW 1
65463: ST_TO_ADDR
65464: GO 65412
65466: POP
65467: POP
// end ;
65468: GO 63951
65470: POP
65471: POP
// result := Replace ( result , 4 , tmp ) ;
65472: LD_ADDR_VAR 0 5
65476: PUSH
65477: LD_VAR 0 5
65481: PPUSH
65482: LD_INT 4
65484: PPUSH
65485: LD_VAR 0 8
65489: PPUSH
65490: CALL_OW 1
65494: ST_TO_ADDR
// end ;
65495: LD_VAR 0 5
65499: RET
// export function DangerAtRange ( unit , range ) ; begin
65500: LD_INT 0
65502: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
65503: LD_ADDR_VAR 0 3
65507: PUSH
65508: LD_VAR 0 1
65512: PPUSH
65513: CALL_OW 255
65517: PPUSH
65518: LD_VAR 0 1
65522: PPUSH
65523: CALL_OW 250
65527: PPUSH
65528: LD_VAR 0 1
65532: PPUSH
65533: CALL_OW 251
65537: PPUSH
65538: LD_VAR 0 2
65542: PPUSH
65543: CALL 63803 0 4
65547: ST_TO_ADDR
// end ;
65548: LD_VAR 0 3
65552: RET
// export function DangerInArea ( side , area ) ; begin
65553: LD_INT 0
65555: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
65556: LD_ADDR_VAR 0 3
65560: PUSH
65561: LD_VAR 0 2
65565: PPUSH
65566: LD_INT 81
65568: PUSH
65569: LD_VAR 0 1
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PPUSH
65578: CALL_OW 70
65582: ST_TO_ADDR
// end ;
65583: LD_VAR 0 3
65587: RET
// export function IsExtension ( b ) ; begin
65588: LD_INT 0
65590: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
65591: LD_ADDR_VAR 0 2
65595: PUSH
65596: LD_VAR 0 1
65600: PUSH
65601: LD_INT 23
65603: PUSH
65604: LD_INT 20
65606: PUSH
65607: LD_INT 22
65609: PUSH
65610: LD_INT 17
65612: PUSH
65613: LD_INT 24
65615: PUSH
65616: LD_INT 21
65618: PUSH
65619: LD_INT 19
65621: PUSH
65622: LD_INT 16
65624: PUSH
65625: LD_INT 25
65627: PUSH
65628: LD_INT 18
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: LIST
65635: LIST
65636: LIST
65637: LIST
65638: LIST
65639: LIST
65640: LIST
65641: LIST
65642: IN
65643: ST_TO_ADDR
// end ;
65644: LD_VAR 0 2
65648: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
65649: LD_INT 0
65651: PPUSH
65652: PPUSH
65653: PPUSH
// result := [ ] ;
65654: LD_ADDR_VAR 0 3
65658: PUSH
65659: EMPTY
65660: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
65661: LD_ADDR_VAR 0 4
65665: PUSH
65666: LD_VAR 0 2
65670: PPUSH
65671: LD_INT 21
65673: PUSH
65674: LD_INT 3
65676: PUSH
65677: EMPTY
65678: LIST
65679: LIST
65680: PPUSH
65681: CALL_OW 70
65685: ST_TO_ADDR
// if not tmp then
65686: LD_VAR 0 4
65690: NOT
65691: IFFALSE 65695
// exit ;
65693: GO 65753
// for i in tmp do
65695: LD_ADDR_VAR 0 5
65699: PUSH
65700: LD_VAR 0 4
65704: PUSH
65705: FOR_IN
65706: IFFALSE 65741
// if GetBase ( i ) <> base then
65708: LD_VAR 0 5
65712: PPUSH
65713: CALL_OW 274
65717: PUSH
65718: LD_VAR 0 1
65722: NONEQUAL
65723: IFFALSE 65739
// ComLinkToBase ( base , i ) ;
65725: LD_VAR 0 1
65729: PPUSH
65730: LD_VAR 0 5
65734: PPUSH
65735: CALL_OW 169
65739: GO 65705
65741: POP
65742: POP
// result := tmp ;
65743: LD_ADDR_VAR 0 3
65747: PUSH
65748: LD_VAR 0 4
65752: ST_TO_ADDR
// end ;
65753: LD_VAR 0 3
65757: RET
// export function ComComplete ( unit , b ) ; var i ; begin
65758: LD_INT 0
65760: PPUSH
65761: PPUSH
// if BuildingStatus ( b ) = bs_build then
65762: LD_VAR 0 2
65766: PPUSH
65767: CALL_OW 461
65771: PUSH
65772: LD_INT 1
65774: EQUAL
65775: IFFALSE 65835
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
65777: LD_VAR 0 1
65781: PPUSH
65782: LD_STRING h
65784: PUSH
65785: LD_VAR 0 2
65789: PPUSH
65790: CALL_OW 250
65794: PUSH
65795: LD_VAR 0 2
65799: PPUSH
65800: CALL_OW 251
65804: PUSH
65805: LD_VAR 0 2
65809: PUSH
65810: LD_INT 0
65812: PUSH
65813: LD_INT 0
65815: PUSH
65816: LD_INT 0
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: PUSH
65828: EMPTY
65829: LIST
65830: PPUSH
65831: CALL_OW 446
// end ;
65835: LD_VAR 0 3
65839: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
65840: LD_INT 0
65842: PPUSH
65843: PPUSH
65844: PPUSH
65845: PPUSH
65846: PPUSH
65847: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
65848: LD_VAR 0 1
65852: NOT
65853: PUSH
65854: LD_VAR 0 1
65858: PPUSH
65859: CALL_OW 263
65863: PUSH
65864: LD_INT 2
65866: EQUAL
65867: NOT
65868: OR
65869: IFFALSE 65873
// exit ;
65871: GO 66189
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
65873: LD_ADDR_VAR 0 6
65877: PUSH
65878: LD_INT 22
65880: PUSH
65881: LD_VAR 0 1
65885: PPUSH
65886: CALL_OW 255
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 2
65897: PUSH
65898: LD_INT 30
65900: PUSH
65901: LD_INT 36
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 34
65910: PUSH
65911: LD_INT 31
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: LIST
65922: PUSH
65923: EMPTY
65924: LIST
65925: LIST
65926: PPUSH
65927: CALL_OW 69
65931: ST_TO_ADDR
// if not tmp then
65932: LD_VAR 0 6
65936: NOT
65937: IFFALSE 65941
// exit ;
65939: GO 66189
// result := [ ] ;
65941: LD_ADDR_VAR 0 2
65945: PUSH
65946: EMPTY
65947: ST_TO_ADDR
// for i in tmp do
65948: LD_ADDR_VAR 0 3
65952: PUSH
65953: LD_VAR 0 6
65957: PUSH
65958: FOR_IN
65959: IFFALSE 66030
// begin t := UnitsInside ( i ) ;
65961: LD_ADDR_VAR 0 4
65965: PUSH
65966: LD_VAR 0 3
65970: PPUSH
65971: CALL_OW 313
65975: ST_TO_ADDR
// if t then
65976: LD_VAR 0 4
65980: IFFALSE 66028
// for j in t do
65982: LD_ADDR_VAR 0 7
65986: PUSH
65987: LD_VAR 0 4
65991: PUSH
65992: FOR_IN
65993: IFFALSE 66026
// result := Insert ( result , result + 1 , j ) ;
65995: LD_ADDR_VAR 0 2
65999: PUSH
66000: LD_VAR 0 2
66004: PPUSH
66005: LD_VAR 0 2
66009: PUSH
66010: LD_INT 1
66012: PLUS
66013: PPUSH
66014: LD_VAR 0 7
66018: PPUSH
66019: CALL_OW 2
66023: ST_TO_ADDR
66024: GO 65992
66026: POP
66027: POP
// end ;
66028: GO 65958
66030: POP
66031: POP
// if not result then
66032: LD_VAR 0 2
66036: NOT
66037: IFFALSE 66041
// exit ;
66039: GO 66189
// mech := result [ 1 ] ;
66041: LD_ADDR_VAR 0 5
66045: PUSH
66046: LD_VAR 0 2
66050: PUSH
66051: LD_INT 1
66053: ARRAY
66054: ST_TO_ADDR
// if result > 1 then
66055: LD_VAR 0 2
66059: PUSH
66060: LD_INT 1
66062: GREATER
66063: IFFALSE 66175
// for i = 2 to result do
66065: LD_ADDR_VAR 0 3
66069: PUSH
66070: DOUBLE
66071: LD_INT 2
66073: DEC
66074: ST_TO_ADDR
66075: LD_VAR 0 2
66079: PUSH
66080: FOR_TO
66081: IFFALSE 66173
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
66083: LD_ADDR_VAR 0 4
66087: PUSH
66088: LD_VAR 0 2
66092: PUSH
66093: LD_VAR 0 3
66097: ARRAY
66098: PPUSH
66099: LD_INT 3
66101: PPUSH
66102: CALL_OW 259
66106: PUSH
66107: LD_VAR 0 2
66111: PUSH
66112: LD_VAR 0 3
66116: ARRAY
66117: PPUSH
66118: CALL_OW 432
66122: MINUS
66123: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
66124: LD_VAR 0 4
66128: PUSH
66129: LD_VAR 0 5
66133: PPUSH
66134: LD_INT 3
66136: PPUSH
66137: CALL_OW 259
66141: PUSH
66142: LD_VAR 0 5
66146: PPUSH
66147: CALL_OW 432
66151: MINUS
66152: GREATEREQUAL
66153: IFFALSE 66171
// mech := result [ i ] ;
66155: LD_ADDR_VAR 0 5
66159: PUSH
66160: LD_VAR 0 2
66164: PUSH
66165: LD_VAR 0 3
66169: ARRAY
66170: ST_TO_ADDR
// end ;
66171: GO 66080
66173: POP
66174: POP
// ComLinkTo ( vehicle , mech ) ;
66175: LD_VAR 0 1
66179: PPUSH
66180: LD_VAR 0 5
66184: PPUSH
66185: CALL_OW 135
// end ;
66189: LD_VAR 0 2
66193: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
66194: LD_INT 0
66196: PPUSH
66197: PPUSH
66198: PPUSH
66199: PPUSH
66200: PPUSH
66201: PPUSH
66202: PPUSH
66203: PPUSH
66204: PPUSH
66205: PPUSH
66206: PPUSH
66207: PPUSH
66208: PPUSH
// result := [ ] ;
66209: LD_ADDR_VAR 0 7
66213: PUSH
66214: EMPTY
66215: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
66216: LD_VAR 0 1
66220: PPUSH
66221: CALL_OW 266
66225: PUSH
66226: LD_INT 0
66228: PUSH
66229: LD_INT 1
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: IN
66236: NOT
66237: IFFALSE 66241
// exit ;
66239: GO 67872
// if name then
66241: LD_VAR 0 3
66245: IFFALSE 66261
// SetBName ( base_dep , name ) ;
66247: LD_VAR 0 1
66251: PPUSH
66252: LD_VAR 0 3
66256: PPUSH
66257: CALL_OW 500
// base := GetBase ( base_dep ) ;
66261: LD_ADDR_VAR 0 15
66265: PUSH
66266: LD_VAR 0 1
66270: PPUSH
66271: CALL_OW 274
66275: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
66276: LD_ADDR_VAR 0 16
66280: PUSH
66281: LD_VAR 0 1
66285: PPUSH
66286: CALL_OW 255
66290: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
66291: LD_ADDR_VAR 0 17
66295: PUSH
66296: LD_VAR 0 1
66300: PPUSH
66301: CALL_OW 248
66305: ST_TO_ADDR
// if sources then
66306: LD_VAR 0 5
66310: IFFALSE 66357
// for i = 1 to 3 do
66312: LD_ADDR_VAR 0 8
66316: PUSH
66317: DOUBLE
66318: LD_INT 1
66320: DEC
66321: ST_TO_ADDR
66322: LD_INT 3
66324: PUSH
66325: FOR_TO
66326: IFFALSE 66355
// AddResourceType ( base , i , sources [ i ] ) ;
66328: LD_VAR 0 15
66332: PPUSH
66333: LD_VAR 0 8
66337: PPUSH
66338: LD_VAR 0 5
66342: PUSH
66343: LD_VAR 0 8
66347: ARRAY
66348: PPUSH
66349: CALL_OW 276
66353: GO 66325
66355: POP
66356: POP
// buildings := GetBaseBuildings ( base , area ) ;
66357: LD_ADDR_VAR 0 18
66361: PUSH
66362: LD_VAR 0 15
66366: PPUSH
66367: LD_VAR 0 2
66371: PPUSH
66372: CALL 65649 0 2
66376: ST_TO_ADDR
// InitHc ;
66377: CALL_OW 19
// InitUc ;
66381: CALL_OW 18
// uc_side := side ;
66385: LD_ADDR_OWVAR 20
66389: PUSH
66390: LD_VAR 0 16
66394: ST_TO_ADDR
// uc_nation := nation ;
66395: LD_ADDR_OWVAR 21
66399: PUSH
66400: LD_VAR 0 17
66404: ST_TO_ADDR
// if buildings then
66405: LD_VAR 0 18
66409: IFFALSE 67731
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
66411: LD_ADDR_VAR 0 19
66415: PUSH
66416: LD_VAR 0 18
66420: PPUSH
66421: LD_INT 2
66423: PUSH
66424: LD_INT 30
66426: PUSH
66427: LD_INT 29
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 30
66436: PUSH
66437: LD_INT 30
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: LIST
66448: PPUSH
66449: CALL_OW 72
66453: ST_TO_ADDR
// if tmp then
66454: LD_VAR 0 19
66458: IFFALSE 66506
// for i in tmp do
66460: LD_ADDR_VAR 0 8
66464: PUSH
66465: LD_VAR 0 19
66469: PUSH
66470: FOR_IN
66471: IFFALSE 66504
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
66473: LD_VAR 0 8
66477: PPUSH
66478: CALL_OW 250
66482: PPUSH
66483: LD_VAR 0 8
66487: PPUSH
66488: CALL_OW 251
66492: PPUSH
66493: LD_VAR 0 16
66497: PPUSH
66498: CALL_OW 441
66502: GO 66470
66504: POP
66505: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
66506: LD_VAR 0 18
66510: PPUSH
66511: LD_INT 2
66513: PUSH
66514: LD_INT 30
66516: PUSH
66517: LD_INT 32
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 30
66526: PUSH
66527: LD_INT 33
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: EMPTY
66535: LIST
66536: LIST
66537: LIST
66538: PPUSH
66539: CALL_OW 72
66543: IFFALSE 66631
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
66545: LD_ADDR_VAR 0 8
66549: PUSH
66550: LD_VAR 0 18
66554: PPUSH
66555: LD_INT 2
66557: PUSH
66558: LD_INT 30
66560: PUSH
66561: LD_INT 32
66563: PUSH
66564: EMPTY
66565: LIST
66566: LIST
66567: PUSH
66568: LD_INT 30
66570: PUSH
66571: LD_INT 33
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: LIST
66582: PPUSH
66583: CALL_OW 72
66587: PUSH
66588: FOR_IN
66589: IFFALSE 66629
// begin if not GetBWeapon ( i ) then
66591: LD_VAR 0 8
66595: PPUSH
66596: CALL_OW 269
66600: NOT
66601: IFFALSE 66627
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
66603: LD_VAR 0 8
66607: PPUSH
66608: LD_VAR 0 8
66612: PPUSH
66613: LD_VAR 0 2
66617: PPUSH
66618: CALL 67877 0 2
66622: PPUSH
66623: CALL_OW 431
// end ;
66627: GO 66588
66629: POP
66630: POP
// end ; for i = 1 to personel do
66631: LD_ADDR_VAR 0 8
66635: PUSH
66636: DOUBLE
66637: LD_INT 1
66639: DEC
66640: ST_TO_ADDR
66641: LD_VAR 0 6
66645: PUSH
66646: FOR_TO
66647: IFFALSE 67711
// begin if i > 4 then
66649: LD_VAR 0 8
66653: PUSH
66654: LD_INT 4
66656: GREATER
66657: IFFALSE 66661
// break ;
66659: GO 67711
// case i of 1 :
66661: LD_VAR 0 8
66665: PUSH
66666: LD_INT 1
66668: DOUBLE
66669: EQUAL
66670: IFTRUE 66674
66672: GO 66754
66674: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
66675: LD_ADDR_VAR 0 12
66679: PUSH
66680: LD_VAR 0 18
66684: PPUSH
66685: LD_INT 22
66687: PUSH
66688: LD_VAR 0 16
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 58
66699: PUSH
66700: EMPTY
66701: LIST
66702: PUSH
66703: LD_INT 2
66705: PUSH
66706: LD_INT 30
66708: PUSH
66709: LD_INT 32
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 30
66718: PUSH
66719: LD_INT 4
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: LD_INT 30
66728: PUSH
66729: LD_INT 5
66731: PUSH
66732: EMPTY
66733: LIST
66734: LIST
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: LIST
66746: PPUSH
66747: CALL_OW 72
66751: ST_TO_ADDR
66752: GO 66976
66754: LD_INT 2
66756: DOUBLE
66757: EQUAL
66758: IFTRUE 66762
66760: GO 66824
66762: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
66763: LD_ADDR_VAR 0 12
66767: PUSH
66768: LD_VAR 0 18
66772: PPUSH
66773: LD_INT 22
66775: PUSH
66776: LD_VAR 0 16
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PUSH
66785: LD_INT 2
66787: PUSH
66788: LD_INT 30
66790: PUSH
66791: LD_INT 0
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 30
66800: PUSH
66801: LD_INT 1
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: LIST
66812: PUSH
66813: EMPTY
66814: LIST
66815: LIST
66816: PPUSH
66817: CALL_OW 72
66821: ST_TO_ADDR
66822: GO 66976
66824: LD_INT 3
66826: DOUBLE
66827: EQUAL
66828: IFTRUE 66832
66830: GO 66894
66832: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
66833: LD_ADDR_VAR 0 12
66837: PUSH
66838: LD_VAR 0 18
66842: PPUSH
66843: LD_INT 22
66845: PUSH
66846: LD_VAR 0 16
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 2
66857: PUSH
66858: LD_INT 30
66860: PUSH
66861: LD_INT 2
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 30
66870: PUSH
66871: LD_INT 3
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: LIST
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PPUSH
66887: CALL_OW 72
66891: ST_TO_ADDR
66892: GO 66976
66894: LD_INT 4
66896: DOUBLE
66897: EQUAL
66898: IFTRUE 66902
66900: GO 66975
66902: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
66903: LD_ADDR_VAR 0 12
66907: PUSH
66908: LD_VAR 0 18
66912: PPUSH
66913: LD_INT 22
66915: PUSH
66916: LD_VAR 0 16
66920: PUSH
66921: EMPTY
66922: LIST
66923: LIST
66924: PUSH
66925: LD_INT 2
66927: PUSH
66928: LD_INT 30
66930: PUSH
66931: LD_INT 6
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: PUSH
66938: LD_INT 30
66940: PUSH
66941: LD_INT 7
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 30
66950: PUSH
66951: LD_INT 8
66953: PUSH
66954: EMPTY
66955: LIST
66956: LIST
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: LIST
66962: LIST
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PPUSH
66968: CALL_OW 72
66972: ST_TO_ADDR
66973: GO 66976
66975: POP
// if i = 1 then
66976: LD_VAR 0 8
66980: PUSH
66981: LD_INT 1
66983: EQUAL
66984: IFFALSE 67095
// begin tmp := [ ] ;
66986: LD_ADDR_VAR 0 19
66990: PUSH
66991: EMPTY
66992: ST_TO_ADDR
// for j in f do
66993: LD_ADDR_VAR 0 9
66997: PUSH
66998: LD_VAR 0 12
67002: PUSH
67003: FOR_IN
67004: IFFALSE 67077
// if GetBType ( j ) = b_bunker then
67006: LD_VAR 0 9
67010: PPUSH
67011: CALL_OW 266
67015: PUSH
67016: LD_INT 32
67018: EQUAL
67019: IFFALSE 67046
// tmp := Insert ( tmp , 1 , j ) else
67021: LD_ADDR_VAR 0 19
67025: PUSH
67026: LD_VAR 0 19
67030: PPUSH
67031: LD_INT 1
67033: PPUSH
67034: LD_VAR 0 9
67038: PPUSH
67039: CALL_OW 2
67043: ST_TO_ADDR
67044: GO 67075
// tmp := Insert ( tmp , tmp + 1 , j ) ;
67046: LD_ADDR_VAR 0 19
67050: PUSH
67051: LD_VAR 0 19
67055: PPUSH
67056: LD_VAR 0 19
67060: PUSH
67061: LD_INT 1
67063: PLUS
67064: PPUSH
67065: LD_VAR 0 9
67069: PPUSH
67070: CALL_OW 2
67074: ST_TO_ADDR
67075: GO 67003
67077: POP
67078: POP
// if tmp then
67079: LD_VAR 0 19
67083: IFFALSE 67095
// f := tmp ;
67085: LD_ADDR_VAR 0 12
67089: PUSH
67090: LD_VAR 0 19
67094: ST_TO_ADDR
// end ; x := personel [ i ] ;
67095: LD_ADDR_VAR 0 13
67099: PUSH
67100: LD_VAR 0 6
67104: PUSH
67105: LD_VAR 0 8
67109: ARRAY
67110: ST_TO_ADDR
// if x = - 1 then
67111: LD_VAR 0 13
67115: PUSH
67116: LD_INT 1
67118: NEG
67119: EQUAL
67120: IFFALSE 67329
// begin for j in f do
67122: LD_ADDR_VAR 0 9
67126: PUSH
67127: LD_VAR 0 12
67131: PUSH
67132: FOR_IN
67133: IFFALSE 67325
// repeat InitHc ;
67135: CALL_OW 19
// if GetBType ( j ) = b_barracks then
67139: LD_VAR 0 9
67143: PPUSH
67144: CALL_OW 266
67148: PUSH
67149: LD_INT 5
67151: EQUAL
67152: IFFALSE 67222
// begin if UnitsInside ( j ) < 3 then
67154: LD_VAR 0 9
67158: PPUSH
67159: CALL_OW 313
67163: PUSH
67164: LD_INT 3
67166: LESS
67167: IFFALSE 67203
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
67169: LD_INT 0
67171: PPUSH
67172: LD_INT 5
67174: PUSH
67175: LD_INT 8
67177: PUSH
67178: LD_INT 9
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: LIST
67185: PUSH
67186: LD_VAR 0 17
67190: ARRAY
67191: PPUSH
67192: LD_VAR 0 4
67196: PPUSH
67197: CALL_OW 380
67201: GO 67220
// PrepareHuman ( false , i , skill ) ;
67203: LD_INT 0
67205: PPUSH
67206: LD_VAR 0 8
67210: PPUSH
67211: LD_VAR 0 4
67215: PPUSH
67216: CALL_OW 380
// end else
67220: GO 67239
// PrepareHuman ( false , i , skill ) ;
67222: LD_INT 0
67224: PPUSH
67225: LD_VAR 0 8
67229: PPUSH
67230: LD_VAR 0 4
67234: PPUSH
67235: CALL_OW 380
// un := CreateHuman ;
67239: LD_ADDR_VAR 0 14
67243: PUSH
67244: CALL_OW 44
67248: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
67249: LD_ADDR_VAR 0 7
67253: PUSH
67254: LD_VAR 0 7
67258: PPUSH
67259: LD_INT 1
67261: PPUSH
67262: LD_VAR 0 14
67266: PPUSH
67267: CALL_OW 2
67271: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
67272: LD_VAR 0 14
67276: PPUSH
67277: LD_VAR 0 9
67281: PPUSH
67282: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
67286: LD_VAR 0 9
67290: PPUSH
67291: CALL_OW 313
67295: PUSH
67296: LD_INT 6
67298: EQUAL
67299: PUSH
67300: LD_VAR 0 9
67304: PPUSH
67305: CALL_OW 266
67309: PUSH
67310: LD_INT 32
67312: PUSH
67313: LD_INT 31
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: IN
67320: OR
67321: IFFALSE 67135
67323: GO 67132
67325: POP
67326: POP
// end else
67327: GO 67709
// for j = 1 to x do
67329: LD_ADDR_VAR 0 9
67333: PUSH
67334: DOUBLE
67335: LD_INT 1
67337: DEC
67338: ST_TO_ADDR
67339: LD_VAR 0 13
67343: PUSH
67344: FOR_TO
67345: IFFALSE 67707
// begin InitHc ;
67347: CALL_OW 19
// if not f then
67351: LD_VAR 0 12
67355: NOT
67356: IFFALSE 67445
// begin PrepareHuman ( false , i , skill ) ;
67358: LD_INT 0
67360: PPUSH
67361: LD_VAR 0 8
67365: PPUSH
67366: LD_VAR 0 4
67370: PPUSH
67371: CALL_OW 380
// un := CreateHuman ;
67375: LD_ADDR_VAR 0 14
67379: PUSH
67380: CALL_OW 44
67384: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
67385: LD_ADDR_VAR 0 7
67389: PUSH
67390: LD_VAR 0 7
67394: PPUSH
67395: LD_INT 1
67397: PPUSH
67398: LD_VAR 0 14
67402: PPUSH
67403: CALL_OW 2
67407: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
67408: LD_VAR 0 14
67412: PPUSH
67413: LD_VAR 0 1
67417: PPUSH
67418: CALL_OW 250
67422: PPUSH
67423: LD_VAR 0 1
67427: PPUSH
67428: CALL_OW 251
67432: PPUSH
67433: LD_INT 10
67435: PPUSH
67436: LD_INT 0
67438: PPUSH
67439: CALL_OW 50
// continue ;
67443: GO 67344
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
67445: LD_VAR 0 12
67449: PUSH
67450: LD_INT 1
67452: ARRAY
67453: PPUSH
67454: CALL_OW 313
67458: PUSH
67459: LD_VAR 0 12
67463: PUSH
67464: LD_INT 1
67466: ARRAY
67467: PPUSH
67468: CALL_OW 266
67472: PUSH
67473: LD_INT 32
67475: PUSH
67476: LD_INT 31
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: IN
67483: AND
67484: PUSH
67485: LD_VAR 0 12
67489: PUSH
67490: LD_INT 1
67492: ARRAY
67493: PPUSH
67494: CALL_OW 313
67498: PUSH
67499: LD_INT 6
67501: EQUAL
67502: OR
67503: IFFALSE 67523
// f := Delete ( f , 1 ) ;
67505: LD_ADDR_VAR 0 12
67509: PUSH
67510: LD_VAR 0 12
67514: PPUSH
67515: LD_INT 1
67517: PPUSH
67518: CALL_OW 3
67522: ST_TO_ADDR
// if not f then
67523: LD_VAR 0 12
67527: NOT
67528: IFFALSE 67546
// begin x := x + 2 ;
67530: LD_ADDR_VAR 0 13
67534: PUSH
67535: LD_VAR 0 13
67539: PUSH
67540: LD_INT 2
67542: PLUS
67543: ST_TO_ADDR
// continue ;
67544: GO 67344
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
67546: LD_VAR 0 12
67550: PUSH
67551: LD_INT 1
67553: ARRAY
67554: PPUSH
67555: CALL_OW 266
67559: PUSH
67560: LD_INT 5
67562: EQUAL
67563: IFFALSE 67637
// begin if UnitsInside ( f [ 1 ] ) < 3 then
67565: LD_VAR 0 12
67569: PUSH
67570: LD_INT 1
67572: ARRAY
67573: PPUSH
67574: CALL_OW 313
67578: PUSH
67579: LD_INT 3
67581: LESS
67582: IFFALSE 67618
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
67584: LD_INT 0
67586: PPUSH
67587: LD_INT 5
67589: PUSH
67590: LD_INT 8
67592: PUSH
67593: LD_INT 9
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: LIST
67600: PUSH
67601: LD_VAR 0 17
67605: ARRAY
67606: PPUSH
67607: LD_VAR 0 4
67611: PPUSH
67612: CALL_OW 380
67616: GO 67635
// PrepareHuman ( false , i , skill ) ;
67618: LD_INT 0
67620: PPUSH
67621: LD_VAR 0 8
67625: PPUSH
67626: LD_VAR 0 4
67630: PPUSH
67631: CALL_OW 380
// end else
67635: GO 67654
// PrepareHuman ( false , i , skill ) ;
67637: LD_INT 0
67639: PPUSH
67640: LD_VAR 0 8
67644: PPUSH
67645: LD_VAR 0 4
67649: PPUSH
67650: CALL_OW 380
// un := CreateHuman ;
67654: LD_ADDR_VAR 0 14
67658: PUSH
67659: CALL_OW 44
67663: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
67664: LD_ADDR_VAR 0 7
67668: PUSH
67669: LD_VAR 0 7
67673: PPUSH
67674: LD_INT 1
67676: PPUSH
67677: LD_VAR 0 14
67681: PPUSH
67682: CALL_OW 2
67686: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
67687: LD_VAR 0 14
67691: PPUSH
67692: LD_VAR 0 12
67696: PUSH
67697: LD_INT 1
67699: ARRAY
67700: PPUSH
67701: CALL_OW 52
// end ;
67705: GO 67344
67707: POP
67708: POP
// end ;
67709: GO 66646
67711: POP
67712: POP
// result := result ^ buildings ;
67713: LD_ADDR_VAR 0 7
67717: PUSH
67718: LD_VAR 0 7
67722: PUSH
67723: LD_VAR 0 18
67727: ADD
67728: ST_TO_ADDR
// end else
67729: GO 67872
// begin for i = 1 to personel do
67731: LD_ADDR_VAR 0 8
67735: PUSH
67736: DOUBLE
67737: LD_INT 1
67739: DEC
67740: ST_TO_ADDR
67741: LD_VAR 0 6
67745: PUSH
67746: FOR_TO
67747: IFFALSE 67870
// begin if i > 4 then
67749: LD_VAR 0 8
67753: PUSH
67754: LD_INT 4
67756: GREATER
67757: IFFALSE 67761
// break ;
67759: GO 67870
// x := personel [ i ] ;
67761: LD_ADDR_VAR 0 13
67765: PUSH
67766: LD_VAR 0 6
67770: PUSH
67771: LD_VAR 0 8
67775: ARRAY
67776: ST_TO_ADDR
// if x = - 1 then
67777: LD_VAR 0 13
67781: PUSH
67782: LD_INT 1
67784: NEG
67785: EQUAL
67786: IFFALSE 67790
// continue ;
67788: GO 67746
// PrepareHuman ( false , i , skill ) ;
67790: LD_INT 0
67792: PPUSH
67793: LD_VAR 0 8
67797: PPUSH
67798: LD_VAR 0 4
67802: PPUSH
67803: CALL_OW 380
// un := CreateHuman ;
67807: LD_ADDR_VAR 0 14
67811: PUSH
67812: CALL_OW 44
67816: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
67817: LD_VAR 0 14
67821: PPUSH
67822: LD_VAR 0 1
67826: PPUSH
67827: CALL_OW 250
67831: PPUSH
67832: LD_VAR 0 1
67836: PPUSH
67837: CALL_OW 251
67841: PPUSH
67842: LD_INT 10
67844: PPUSH
67845: LD_INT 0
67847: PPUSH
67848: CALL_OW 50
// result := result ^ un ;
67852: LD_ADDR_VAR 0 7
67856: PUSH
67857: LD_VAR 0 7
67861: PUSH
67862: LD_VAR 0 14
67866: ADD
67867: ST_TO_ADDR
// end ;
67868: GO 67746
67870: POP
67871: POP
// end ; end ;
67872: LD_VAR 0 7
67876: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
67877: LD_INT 0
67879: PPUSH
67880: PPUSH
67881: PPUSH
67882: PPUSH
67883: PPUSH
67884: PPUSH
67885: PPUSH
67886: PPUSH
67887: PPUSH
67888: PPUSH
67889: PPUSH
67890: PPUSH
67891: PPUSH
67892: PPUSH
67893: PPUSH
67894: PPUSH
// result := false ;
67895: LD_ADDR_VAR 0 3
67899: PUSH
67900: LD_INT 0
67902: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
67903: LD_VAR 0 1
67907: NOT
67908: PUSH
67909: LD_VAR 0 1
67913: PPUSH
67914: CALL_OW 266
67918: PUSH
67919: LD_INT 32
67921: PUSH
67922: LD_INT 33
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: IN
67929: NOT
67930: OR
67931: IFFALSE 67935
// exit ;
67933: GO 69071
// nat := GetNation ( tower ) ;
67935: LD_ADDR_VAR 0 12
67939: PUSH
67940: LD_VAR 0 1
67944: PPUSH
67945: CALL_OW 248
67949: ST_TO_ADDR
// side := GetSide ( tower ) ;
67950: LD_ADDR_VAR 0 16
67954: PUSH
67955: LD_VAR 0 1
67959: PPUSH
67960: CALL_OW 255
67964: ST_TO_ADDR
// x := GetX ( tower ) ;
67965: LD_ADDR_VAR 0 10
67969: PUSH
67970: LD_VAR 0 1
67974: PPUSH
67975: CALL_OW 250
67979: ST_TO_ADDR
// y := GetY ( tower ) ;
67980: LD_ADDR_VAR 0 11
67984: PUSH
67985: LD_VAR 0 1
67989: PPUSH
67990: CALL_OW 251
67994: ST_TO_ADDR
// if not x or not y then
67995: LD_VAR 0 10
67999: NOT
68000: PUSH
68001: LD_VAR 0 11
68005: NOT
68006: OR
68007: IFFALSE 68011
// exit ;
68009: GO 69071
// weapon := 0 ;
68011: LD_ADDR_VAR 0 18
68015: PUSH
68016: LD_INT 0
68018: ST_TO_ADDR
// fac_list := [ ] ;
68019: LD_ADDR_VAR 0 17
68023: PUSH
68024: EMPTY
68025: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
68026: LD_ADDR_VAR 0 6
68030: PUSH
68031: LD_VAR 0 1
68035: PPUSH
68036: CALL_OW 274
68040: PPUSH
68041: LD_VAR 0 2
68045: PPUSH
68046: CALL 65649 0 2
68050: PPUSH
68051: LD_INT 30
68053: PUSH
68054: LD_INT 3
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PPUSH
68061: CALL_OW 72
68065: ST_TO_ADDR
// if not factories then
68066: LD_VAR 0 6
68070: NOT
68071: IFFALSE 68075
// exit ;
68073: GO 69071
// for i in factories do
68075: LD_ADDR_VAR 0 8
68079: PUSH
68080: LD_VAR 0 6
68084: PUSH
68085: FOR_IN
68086: IFFALSE 68111
// fac_list := fac_list union AvailableWeaponList ( i ) ;
68088: LD_ADDR_VAR 0 17
68092: PUSH
68093: LD_VAR 0 17
68097: PUSH
68098: LD_VAR 0 8
68102: PPUSH
68103: CALL_OW 478
68107: UNION
68108: ST_TO_ADDR
68109: GO 68085
68111: POP
68112: POP
// if not fac_list then
68113: LD_VAR 0 17
68117: NOT
68118: IFFALSE 68122
// exit ;
68120: GO 69071
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
68122: LD_ADDR_VAR 0 5
68126: PUSH
68127: LD_INT 4
68129: PUSH
68130: LD_INT 5
68132: PUSH
68133: LD_INT 9
68135: PUSH
68136: LD_INT 10
68138: PUSH
68139: LD_INT 6
68141: PUSH
68142: LD_INT 7
68144: PUSH
68145: LD_INT 11
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 27
68159: PUSH
68160: LD_INT 28
68162: PUSH
68163: LD_INT 26
68165: PUSH
68166: LD_INT 30
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: PUSH
68175: LD_INT 43
68177: PUSH
68178: LD_INT 44
68180: PUSH
68181: LD_INT 46
68183: PUSH
68184: LD_INT 45
68186: PUSH
68187: LD_INT 47
68189: PUSH
68190: LD_INT 49
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: PUSH
68201: EMPTY
68202: LIST
68203: LIST
68204: LIST
68205: PUSH
68206: LD_VAR 0 12
68210: ARRAY
68211: ST_TO_ADDR
// for i in list do
68212: LD_ADDR_VAR 0 8
68216: PUSH
68217: LD_VAR 0 5
68221: PUSH
68222: FOR_IN
68223: IFFALSE 68256
// if not i in fac_list then
68225: LD_VAR 0 8
68229: PUSH
68230: LD_VAR 0 17
68234: IN
68235: NOT
68236: IFFALSE 68254
// list := list diff i ;
68238: LD_ADDR_VAR 0 5
68242: PUSH
68243: LD_VAR 0 5
68247: PUSH
68248: LD_VAR 0 8
68252: DIFF
68253: ST_TO_ADDR
68254: GO 68222
68256: POP
68257: POP
// if not list then
68258: LD_VAR 0 5
68262: NOT
68263: IFFALSE 68267
// exit ;
68265: GO 69071
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
68267: LD_VAR 0 12
68271: PUSH
68272: LD_INT 3
68274: EQUAL
68275: PUSH
68276: LD_INT 49
68278: PUSH
68279: LD_VAR 0 5
68283: IN
68284: AND
68285: PUSH
68286: LD_INT 31
68288: PPUSH
68289: LD_VAR 0 16
68293: PPUSH
68294: CALL_OW 321
68298: PUSH
68299: LD_INT 2
68301: EQUAL
68302: AND
68303: IFFALSE 68363
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
68305: LD_INT 22
68307: PUSH
68308: LD_VAR 0 16
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PUSH
68317: LD_INT 35
68319: PUSH
68320: LD_INT 49
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 91
68329: PUSH
68330: LD_VAR 0 1
68334: PUSH
68335: LD_INT 10
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: LIST
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: LIST
68347: PPUSH
68348: CALL_OW 69
68352: NOT
68353: IFFALSE 68363
// weapon := ru_time_lapser ;
68355: LD_ADDR_VAR 0 18
68359: PUSH
68360: LD_INT 49
68362: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
68363: LD_VAR 0 12
68367: PUSH
68368: LD_INT 1
68370: PUSH
68371: LD_INT 2
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: IN
68378: PUSH
68379: LD_INT 11
68381: PUSH
68382: LD_VAR 0 5
68386: IN
68387: PUSH
68388: LD_INT 30
68390: PUSH
68391: LD_VAR 0 5
68395: IN
68396: OR
68397: AND
68398: PUSH
68399: LD_INT 6
68401: PPUSH
68402: LD_VAR 0 16
68406: PPUSH
68407: CALL_OW 321
68411: PUSH
68412: LD_INT 2
68414: EQUAL
68415: AND
68416: IFFALSE 68581
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
68418: LD_INT 22
68420: PUSH
68421: LD_VAR 0 16
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 2
68432: PUSH
68433: LD_INT 35
68435: PUSH
68436: LD_INT 11
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 35
68445: PUSH
68446: LD_INT 30
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: EMPTY
68454: LIST
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 91
68460: PUSH
68461: LD_VAR 0 1
68465: PUSH
68466: LD_INT 18
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: LIST
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: LIST
68478: PPUSH
68479: CALL_OW 69
68483: NOT
68484: PUSH
68485: LD_INT 22
68487: PUSH
68488: LD_VAR 0 16
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 2
68499: PUSH
68500: LD_INT 30
68502: PUSH
68503: LD_INT 32
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 30
68512: PUSH
68513: LD_INT 33
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 91
68527: PUSH
68528: LD_VAR 0 1
68532: PUSH
68533: LD_INT 12
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: LIST
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: LIST
68545: PUSH
68546: EMPTY
68547: LIST
68548: PPUSH
68549: CALL_OW 69
68553: PUSH
68554: LD_INT 2
68556: GREATER
68557: AND
68558: IFFALSE 68581
// weapon := [ us_radar , ar_radar ] [ nat ] ;
68560: LD_ADDR_VAR 0 18
68564: PUSH
68565: LD_INT 11
68567: PUSH
68568: LD_INT 30
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PUSH
68575: LD_VAR 0 12
68579: ARRAY
68580: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
68581: LD_VAR 0 18
68585: NOT
68586: PUSH
68587: LD_INT 40
68589: PPUSH
68590: LD_VAR 0 16
68594: PPUSH
68595: CALL_OW 321
68599: PUSH
68600: LD_INT 2
68602: EQUAL
68603: AND
68604: PUSH
68605: LD_INT 7
68607: PUSH
68608: LD_VAR 0 5
68612: IN
68613: PUSH
68614: LD_INT 28
68616: PUSH
68617: LD_VAR 0 5
68621: IN
68622: OR
68623: PUSH
68624: LD_INT 45
68626: PUSH
68627: LD_VAR 0 5
68631: IN
68632: OR
68633: AND
68634: IFFALSE 68888
// begin hex := GetHexInfo ( x , y ) ;
68636: LD_ADDR_VAR 0 4
68640: PUSH
68641: LD_VAR 0 10
68645: PPUSH
68646: LD_VAR 0 11
68650: PPUSH
68651: CALL_OW 546
68655: ST_TO_ADDR
// if hex [ 1 ] then
68656: LD_VAR 0 4
68660: PUSH
68661: LD_INT 1
68663: ARRAY
68664: IFFALSE 68668
// exit ;
68666: GO 69071
// height := hex [ 2 ] ;
68668: LD_ADDR_VAR 0 15
68672: PUSH
68673: LD_VAR 0 4
68677: PUSH
68678: LD_INT 2
68680: ARRAY
68681: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
68682: LD_ADDR_VAR 0 14
68686: PUSH
68687: LD_INT 0
68689: PUSH
68690: LD_INT 2
68692: PUSH
68693: LD_INT 3
68695: PUSH
68696: LD_INT 5
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: ST_TO_ADDR
// for i in tmp do
68705: LD_ADDR_VAR 0 8
68709: PUSH
68710: LD_VAR 0 14
68714: PUSH
68715: FOR_IN
68716: IFFALSE 68886
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
68718: LD_ADDR_VAR 0 9
68722: PUSH
68723: LD_VAR 0 10
68727: PPUSH
68728: LD_VAR 0 8
68732: PPUSH
68733: LD_INT 5
68735: PPUSH
68736: CALL_OW 272
68740: PUSH
68741: LD_VAR 0 11
68745: PPUSH
68746: LD_VAR 0 8
68750: PPUSH
68751: LD_INT 5
68753: PPUSH
68754: CALL_OW 273
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
68763: LD_VAR 0 9
68767: PUSH
68768: LD_INT 1
68770: ARRAY
68771: PPUSH
68772: LD_VAR 0 9
68776: PUSH
68777: LD_INT 2
68779: ARRAY
68780: PPUSH
68781: CALL_OW 488
68785: IFFALSE 68884
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
68787: LD_ADDR_VAR 0 4
68791: PUSH
68792: LD_VAR 0 9
68796: PUSH
68797: LD_INT 1
68799: ARRAY
68800: PPUSH
68801: LD_VAR 0 9
68805: PUSH
68806: LD_INT 2
68808: ARRAY
68809: PPUSH
68810: CALL_OW 546
68814: ST_TO_ADDR
// if hex [ 1 ] then
68815: LD_VAR 0 4
68819: PUSH
68820: LD_INT 1
68822: ARRAY
68823: IFFALSE 68827
// continue ;
68825: GO 68715
// h := hex [ 2 ] ;
68827: LD_ADDR_VAR 0 13
68831: PUSH
68832: LD_VAR 0 4
68836: PUSH
68837: LD_INT 2
68839: ARRAY
68840: ST_TO_ADDR
// if h + 7 < height then
68841: LD_VAR 0 13
68845: PUSH
68846: LD_INT 7
68848: PLUS
68849: PUSH
68850: LD_VAR 0 15
68854: LESS
68855: IFFALSE 68884
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
68857: LD_ADDR_VAR 0 18
68861: PUSH
68862: LD_INT 7
68864: PUSH
68865: LD_INT 28
68867: PUSH
68868: LD_INT 45
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: LIST
68875: PUSH
68876: LD_VAR 0 12
68880: ARRAY
68881: ST_TO_ADDR
// break ;
68882: GO 68886
// end ; end ; end ;
68884: GO 68715
68886: POP
68887: POP
// end ; if not weapon then
68888: LD_VAR 0 18
68892: NOT
68893: IFFALSE 68953
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
68895: LD_ADDR_VAR 0 5
68899: PUSH
68900: LD_VAR 0 5
68904: PUSH
68905: LD_INT 11
68907: PUSH
68908: LD_INT 30
68910: PUSH
68911: LD_INT 49
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: LIST
68918: DIFF
68919: ST_TO_ADDR
// if not list then
68920: LD_VAR 0 5
68924: NOT
68925: IFFALSE 68929
// exit ;
68927: GO 69071
// weapon := list [ rand ( 1 , list ) ] ;
68929: LD_ADDR_VAR 0 18
68933: PUSH
68934: LD_VAR 0 5
68938: PUSH
68939: LD_INT 1
68941: PPUSH
68942: LD_VAR 0 5
68946: PPUSH
68947: CALL_OW 12
68951: ARRAY
68952: ST_TO_ADDR
// end ; if weapon then
68953: LD_VAR 0 18
68957: IFFALSE 69071
// begin tmp := CostOfWeapon ( weapon ) ;
68959: LD_ADDR_VAR 0 14
68963: PUSH
68964: LD_VAR 0 18
68968: PPUSH
68969: CALL_OW 451
68973: ST_TO_ADDR
// j := GetBase ( tower ) ;
68974: LD_ADDR_VAR 0 9
68978: PUSH
68979: LD_VAR 0 1
68983: PPUSH
68984: CALL_OW 274
68988: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
68989: LD_VAR 0 9
68993: PPUSH
68994: LD_INT 1
68996: PPUSH
68997: CALL_OW 275
69001: PUSH
69002: LD_VAR 0 14
69006: PUSH
69007: LD_INT 1
69009: ARRAY
69010: GREATEREQUAL
69011: PUSH
69012: LD_VAR 0 9
69016: PPUSH
69017: LD_INT 2
69019: PPUSH
69020: CALL_OW 275
69024: PUSH
69025: LD_VAR 0 14
69029: PUSH
69030: LD_INT 2
69032: ARRAY
69033: GREATEREQUAL
69034: AND
69035: PUSH
69036: LD_VAR 0 9
69040: PPUSH
69041: LD_INT 3
69043: PPUSH
69044: CALL_OW 275
69048: PUSH
69049: LD_VAR 0 14
69053: PUSH
69054: LD_INT 3
69056: ARRAY
69057: GREATEREQUAL
69058: AND
69059: IFFALSE 69071
// result := weapon ;
69061: LD_ADDR_VAR 0 3
69065: PUSH
69066: LD_VAR 0 18
69070: ST_TO_ADDR
// end ; end ;
69071: LD_VAR 0 3
69075: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
69076: LD_INT 0
69078: PPUSH
69079: PPUSH
// result := true ;
69080: LD_ADDR_VAR 0 3
69084: PUSH
69085: LD_INT 1
69087: ST_TO_ADDR
// if array1 = array2 then
69088: LD_VAR 0 1
69092: PUSH
69093: LD_VAR 0 2
69097: EQUAL
69098: IFFALSE 69158
// begin for i = 1 to array1 do
69100: LD_ADDR_VAR 0 4
69104: PUSH
69105: DOUBLE
69106: LD_INT 1
69108: DEC
69109: ST_TO_ADDR
69110: LD_VAR 0 1
69114: PUSH
69115: FOR_TO
69116: IFFALSE 69154
// if array1 [ i ] <> array2 [ i ] then
69118: LD_VAR 0 1
69122: PUSH
69123: LD_VAR 0 4
69127: ARRAY
69128: PUSH
69129: LD_VAR 0 2
69133: PUSH
69134: LD_VAR 0 4
69138: ARRAY
69139: NONEQUAL
69140: IFFALSE 69152
// begin result := false ;
69142: LD_ADDR_VAR 0 3
69146: PUSH
69147: LD_INT 0
69149: ST_TO_ADDR
// break ;
69150: GO 69154
// end ;
69152: GO 69115
69154: POP
69155: POP
// end else
69156: GO 69166
// result := false ;
69158: LD_ADDR_VAR 0 3
69162: PUSH
69163: LD_INT 0
69165: ST_TO_ADDR
// end ;
69166: LD_VAR 0 3
69170: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
69171: LD_INT 0
69173: PPUSH
69174: PPUSH
69175: PPUSH
// pom := GetBase ( fac ) ;
69176: LD_ADDR_VAR 0 5
69180: PUSH
69181: LD_VAR 0 1
69185: PPUSH
69186: CALL_OW 274
69190: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
69191: LD_ADDR_VAR 0 4
69195: PUSH
69196: LD_VAR 0 2
69200: PUSH
69201: LD_INT 1
69203: ARRAY
69204: PPUSH
69205: LD_VAR 0 2
69209: PUSH
69210: LD_INT 2
69212: ARRAY
69213: PPUSH
69214: LD_VAR 0 2
69218: PUSH
69219: LD_INT 3
69221: ARRAY
69222: PPUSH
69223: LD_VAR 0 2
69227: PUSH
69228: LD_INT 4
69230: ARRAY
69231: PPUSH
69232: CALL_OW 449
69236: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
69237: LD_ADDR_VAR 0 3
69241: PUSH
69242: LD_VAR 0 5
69246: PPUSH
69247: LD_INT 1
69249: PPUSH
69250: CALL_OW 275
69254: PUSH
69255: LD_VAR 0 4
69259: PUSH
69260: LD_INT 1
69262: ARRAY
69263: GREATEREQUAL
69264: PUSH
69265: LD_VAR 0 5
69269: PPUSH
69270: LD_INT 2
69272: PPUSH
69273: CALL_OW 275
69277: PUSH
69278: LD_VAR 0 4
69282: PUSH
69283: LD_INT 2
69285: ARRAY
69286: GREATEREQUAL
69287: AND
69288: PUSH
69289: LD_VAR 0 5
69293: PPUSH
69294: LD_INT 3
69296: PPUSH
69297: CALL_OW 275
69301: PUSH
69302: LD_VAR 0 4
69306: PUSH
69307: LD_INT 3
69309: ARRAY
69310: GREATEREQUAL
69311: AND
69312: ST_TO_ADDR
// end ;
69313: LD_VAR 0 3
69317: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
69318: LD_INT 0
69320: PPUSH
69321: PPUSH
69322: PPUSH
69323: PPUSH
// pom := GetBase ( building ) ;
69324: LD_ADDR_VAR 0 3
69328: PUSH
69329: LD_VAR 0 1
69333: PPUSH
69334: CALL_OW 274
69338: ST_TO_ADDR
// if not pom then
69339: LD_VAR 0 3
69343: NOT
69344: IFFALSE 69348
// exit ;
69346: GO 69518
// btype := GetBType ( building ) ;
69348: LD_ADDR_VAR 0 5
69352: PUSH
69353: LD_VAR 0 1
69357: PPUSH
69358: CALL_OW 266
69362: ST_TO_ADDR
// if btype = b_armoury then
69363: LD_VAR 0 5
69367: PUSH
69368: LD_INT 4
69370: EQUAL
69371: IFFALSE 69381
// btype := b_barracks ;
69373: LD_ADDR_VAR 0 5
69377: PUSH
69378: LD_INT 5
69380: ST_TO_ADDR
// if btype = b_depot then
69381: LD_VAR 0 5
69385: PUSH
69386: LD_INT 0
69388: EQUAL
69389: IFFALSE 69399
// btype := b_warehouse ;
69391: LD_ADDR_VAR 0 5
69395: PUSH
69396: LD_INT 1
69398: ST_TO_ADDR
// if btype = b_workshop then
69399: LD_VAR 0 5
69403: PUSH
69404: LD_INT 2
69406: EQUAL
69407: IFFALSE 69417
// btype := b_factory ;
69409: LD_ADDR_VAR 0 5
69413: PUSH
69414: LD_INT 3
69416: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
69417: LD_ADDR_VAR 0 4
69421: PUSH
69422: LD_VAR 0 5
69426: PPUSH
69427: LD_VAR 0 1
69431: PPUSH
69432: CALL_OW 248
69436: PPUSH
69437: CALL_OW 450
69441: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
69442: LD_ADDR_VAR 0 2
69446: PUSH
69447: LD_VAR 0 3
69451: PPUSH
69452: LD_INT 1
69454: PPUSH
69455: CALL_OW 275
69459: PUSH
69460: LD_VAR 0 4
69464: PUSH
69465: LD_INT 1
69467: ARRAY
69468: GREATEREQUAL
69469: PUSH
69470: LD_VAR 0 3
69474: PPUSH
69475: LD_INT 2
69477: PPUSH
69478: CALL_OW 275
69482: PUSH
69483: LD_VAR 0 4
69487: PUSH
69488: LD_INT 2
69490: ARRAY
69491: GREATEREQUAL
69492: AND
69493: PUSH
69494: LD_VAR 0 3
69498: PPUSH
69499: LD_INT 3
69501: PPUSH
69502: CALL_OW 275
69506: PUSH
69507: LD_VAR 0 4
69511: PUSH
69512: LD_INT 3
69514: ARRAY
69515: GREATEREQUAL
69516: AND
69517: ST_TO_ADDR
// end ;
69518: LD_VAR 0 2
69522: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
69523: LD_INT 0
69525: PPUSH
69526: PPUSH
69527: PPUSH
// pom := GetBase ( building ) ;
69528: LD_ADDR_VAR 0 4
69532: PUSH
69533: LD_VAR 0 1
69537: PPUSH
69538: CALL_OW 274
69542: ST_TO_ADDR
// if not pom then
69543: LD_VAR 0 4
69547: NOT
69548: IFFALSE 69552
// exit ;
69550: GO 69653
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
69552: LD_ADDR_VAR 0 5
69556: PUSH
69557: LD_VAR 0 2
69561: PPUSH
69562: LD_VAR 0 1
69566: PPUSH
69567: CALL_OW 248
69571: PPUSH
69572: CALL_OW 450
69576: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
69577: LD_ADDR_VAR 0 3
69581: PUSH
69582: LD_VAR 0 4
69586: PPUSH
69587: LD_INT 1
69589: PPUSH
69590: CALL_OW 275
69594: PUSH
69595: LD_VAR 0 5
69599: PUSH
69600: LD_INT 1
69602: ARRAY
69603: GREATEREQUAL
69604: PUSH
69605: LD_VAR 0 4
69609: PPUSH
69610: LD_INT 2
69612: PPUSH
69613: CALL_OW 275
69617: PUSH
69618: LD_VAR 0 5
69622: PUSH
69623: LD_INT 2
69625: ARRAY
69626: GREATEREQUAL
69627: AND
69628: PUSH
69629: LD_VAR 0 4
69633: PPUSH
69634: LD_INT 3
69636: PPUSH
69637: CALL_OW 275
69641: PUSH
69642: LD_VAR 0 5
69646: PUSH
69647: LD_INT 3
69649: ARRAY
69650: GREATEREQUAL
69651: AND
69652: ST_TO_ADDR
// end ;
69653: LD_VAR 0 3
69657: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
69658: LD_INT 0
69660: PPUSH
69661: PPUSH
69662: PPUSH
69663: PPUSH
69664: PPUSH
69665: PPUSH
69666: PPUSH
69667: PPUSH
69668: PPUSH
69669: PPUSH
// result := false ;
69670: LD_ADDR_VAR 0 6
69674: PUSH
69675: LD_INT 0
69677: ST_TO_ADDR
// if not base or not btype or not x or not y then
69678: LD_VAR 0 1
69682: NOT
69683: PUSH
69684: LD_VAR 0 2
69688: NOT
69689: OR
69690: PUSH
69691: LD_VAR 0 3
69695: NOT
69696: OR
69697: PUSH
69698: LD_VAR 0 4
69702: NOT
69703: OR
69704: IFFALSE 69708
// exit ;
69706: GO 70317
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
69708: LD_ADDR_VAR 0 12
69712: PUSH
69713: LD_VAR 0 2
69717: PPUSH
69718: LD_VAR 0 3
69722: PPUSH
69723: LD_VAR 0 4
69727: PPUSH
69728: LD_VAR 0 5
69732: PPUSH
69733: LD_VAR 0 1
69737: PUSH
69738: LD_INT 1
69740: ARRAY
69741: PPUSH
69742: CALL_OW 248
69746: PPUSH
69747: LD_INT 0
69749: PPUSH
69750: CALL 71154 0 6
69754: ST_TO_ADDR
// if not hexes then
69755: LD_VAR 0 12
69759: NOT
69760: IFFALSE 69764
// exit ;
69762: GO 70317
// for i = 1 to hexes do
69764: LD_ADDR_VAR 0 7
69768: PUSH
69769: DOUBLE
69770: LD_INT 1
69772: DEC
69773: ST_TO_ADDR
69774: LD_VAR 0 12
69778: PUSH
69779: FOR_TO
69780: IFFALSE 70315
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
69782: LD_ADDR_VAR 0 11
69786: PUSH
69787: LD_VAR 0 12
69791: PUSH
69792: LD_VAR 0 7
69796: ARRAY
69797: PUSH
69798: LD_INT 1
69800: ARRAY
69801: PPUSH
69802: LD_VAR 0 12
69806: PUSH
69807: LD_VAR 0 7
69811: ARRAY
69812: PUSH
69813: LD_INT 2
69815: ARRAY
69816: PPUSH
69817: CALL_OW 428
69821: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
69822: LD_VAR 0 12
69826: PUSH
69827: LD_VAR 0 7
69831: ARRAY
69832: PUSH
69833: LD_INT 1
69835: ARRAY
69836: PPUSH
69837: LD_VAR 0 12
69841: PUSH
69842: LD_VAR 0 7
69846: ARRAY
69847: PUSH
69848: LD_INT 2
69850: ARRAY
69851: PPUSH
69852: CALL_OW 351
69856: PUSH
69857: LD_VAR 0 12
69861: PUSH
69862: LD_VAR 0 7
69866: ARRAY
69867: PUSH
69868: LD_INT 1
69870: ARRAY
69871: PPUSH
69872: LD_VAR 0 12
69876: PUSH
69877: LD_VAR 0 7
69881: ARRAY
69882: PUSH
69883: LD_INT 2
69885: ARRAY
69886: PPUSH
69887: CALL_OW 488
69891: NOT
69892: OR
69893: PUSH
69894: LD_VAR 0 11
69898: PPUSH
69899: CALL_OW 247
69903: PUSH
69904: LD_INT 3
69906: EQUAL
69907: OR
69908: IFFALSE 69914
// exit ;
69910: POP
69911: POP
69912: GO 70317
// if not tmp or not tmp in base then
69914: LD_VAR 0 11
69918: NOT
69919: PUSH
69920: LD_VAR 0 11
69924: PUSH
69925: LD_VAR 0 1
69929: IN
69930: NOT
69931: OR
69932: IFFALSE 69936
// continue ;
69934: GO 69779
// result := true ;
69936: LD_ADDR_VAR 0 6
69940: PUSH
69941: LD_INT 1
69943: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
69944: LD_ADDR_VAR 0 15
69948: PUSH
69949: LD_VAR 0 1
69953: PPUSH
69954: LD_INT 22
69956: PUSH
69957: LD_VAR 0 11
69961: PPUSH
69962: CALL_OW 255
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 2
69973: PUSH
69974: LD_INT 30
69976: PUSH
69977: LD_INT 0
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 30
69986: PUSH
69987: LD_INT 1
69989: PUSH
69990: EMPTY
69991: LIST
69992: LIST
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: LIST
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PPUSH
70003: CALL_OW 72
70007: ST_TO_ADDR
// if dep then
70008: LD_VAR 0 15
70012: IFFALSE 70148
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
70014: LD_ADDR_VAR 0 14
70018: PUSH
70019: LD_VAR 0 15
70023: PUSH
70024: LD_INT 1
70026: ARRAY
70027: PPUSH
70028: CALL_OW 250
70032: PPUSH
70033: LD_VAR 0 15
70037: PUSH
70038: LD_INT 1
70040: ARRAY
70041: PPUSH
70042: CALL_OW 254
70046: PPUSH
70047: LD_INT 5
70049: PPUSH
70050: CALL_OW 272
70054: PUSH
70055: LD_VAR 0 15
70059: PUSH
70060: LD_INT 1
70062: ARRAY
70063: PPUSH
70064: CALL_OW 251
70068: PPUSH
70069: LD_VAR 0 15
70073: PUSH
70074: LD_INT 1
70076: ARRAY
70077: PPUSH
70078: CALL_OW 254
70082: PPUSH
70083: LD_INT 5
70085: PPUSH
70086: CALL_OW 273
70090: PUSH
70091: EMPTY
70092: LIST
70093: LIST
70094: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
70095: LD_VAR 0 14
70099: PUSH
70100: LD_INT 1
70102: ARRAY
70103: PPUSH
70104: LD_VAR 0 14
70108: PUSH
70109: LD_INT 2
70111: ARRAY
70112: PPUSH
70113: CALL_OW 488
70117: IFFALSE 70148
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
70119: LD_VAR 0 11
70123: PPUSH
70124: LD_VAR 0 14
70128: PUSH
70129: LD_INT 1
70131: ARRAY
70132: PPUSH
70133: LD_VAR 0 14
70137: PUSH
70138: LD_INT 2
70140: ARRAY
70141: PPUSH
70142: CALL_OW 111
// continue ;
70146: GO 69779
// end ; end ; r := GetDir ( tmp ) ;
70148: LD_ADDR_VAR 0 13
70152: PUSH
70153: LD_VAR 0 11
70157: PPUSH
70158: CALL_OW 254
70162: ST_TO_ADDR
// if r = 5 then
70163: LD_VAR 0 13
70167: PUSH
70168: LD_INT 5
70170: EQUAL
70171: IFFALSE 70181
// r := 0 ;
70173: LD_ADDR_VAR 0 13
70177: PUSH
70178: LD_INT 0
70180: ST_TO_ADDR
// for j = r to 5 do
70181: LD_ADDR_VAR 0 8
70185: PUSH
70186: DOUBLE
70187: LD_VAR 0 13
70191: DEC
70192: ST_TO_ADDR
70193: LD_INT 5
70195: PUSH
70196: FOR_TO
70197: IFFALSE 70311
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
70199: LD_ADDR_VAR 0 9
70203: PUSH
70204: LD_VAR 0 11
70208: PPUSH
70209: CALL_OW 250
70213: PPUSH
70214: LD_VAR 0 8
70218: PPUSH
70219: LD_INT 2
70221: PPUSH
70222: CALL_OW 272
70226: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
70227: LD_ADDR_VAR 0 10
70231: PUSH
70232: LD_VAR 0 11
70236: PPUSH
70237: CALL_OW 251
70241: PPUSH
70242: LD_VAR 0 8
70246: PPUSH
70247: LD_INT 2
70249: PPUSH
70250: CALL_OW 273
70254: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
70255: LD_VAR 0 9
70259: PPUSH
70260: LD_VAR 0 10
70264: PPUSH
70265: CALL_OW 488
70269: PUSH
70270: LD_VAR 0 9
70274: PPUSH
70275: LD_VAR 0 10
70279: PPUSH
70280: CALL_OW 428
70284: NOT
70285: AND
70286: IFFALSE 70309
// begin ComMoveXY ( tmp , _x , _y ) ;
70288: LD_VAR 0 11
70292: PPUSH
70293: LD_VAR 0 9
70297: PPUSH
70298: LD_VAR 0 10
70302: PPUSH
70303: CALL_OW 111
// break ;
70307: GO 70311
// end ; end ;
70309: GO 70196
70311: POP
70312: POP
// end ;
70313: GO 69779
70315: POP
70316: POP
// end ;
70317: LD_VAR 0 6
70321: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
70322: LD_INT 0
70324: PPUSH
70325: PPUSH
70326: PPUSH
70327: PPUSH
70328: PPUSH
70329: PPUSH
70330: PPUSH
70331: PPUSH
70332: PPUSH
70333: PPUSH
// result := false ;
70334: LD_ADDR_VAR 0 6
70338: PUSH
70339: LD_INT 0
70341: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
70342: LD_VAR 0 1
70346: NOT
70347: PUSH
70348: LD_VAR 0 1
70352: PPUSH
70353: CALL_OW 266
70357: PUSH
70358: LD_INT 0
70360: PUSH
70361: LD_INT 1
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: IN
70368: NOT
70369: OR
70370: PUSH
70371: LD_VAR 0 2
70375: NOT
70376: OR
70377: PUSH
70378: LD_VAR 0 5
70382: PUSH
70383: LD_INT 0
70385: PUSH
70386: LD_INT 1
70388: PUSH
70389: LD_INT 2
70391: PUSH
70392: LD_INT 3
70394: PUSH
70395: LD_INT 4
70397: PUSH
70398: LD_INT 5
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: LIST
70408: IN
70409: NOT
70410: OR
70411: PUSH
70412: LD_VAR 0 3
70416: PPUSH
70417: LD_VAR 0 4
70421: PPUSH
70422: CALL_OW 488
70426: NOT
70427: OR
70428: IFFALSE 70432
// exit ;
70430: GO 71149
// pom := GetBase ( depot ) ;
70432: LD_ADDR_VAR 0 10
70436: PUSH
70437: LD_VAR 0 1
70441: PPUSH
70442: CALL_OW 274
70446: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
70447: LD_ADDR_VAR 0 11
70451: PUSH
70452: LD_VAR 0 2
70456: PPUSH
70457: LD_VAR 0 1
70461: PPUSH
70462: CALL_OW 248
70466: PPUSH
70467: CALL_OW 450
70471: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
70472: LD_VAR 0 10
70476: PPUSH
70477: LD_INT 1
70479: PPUSH
70480: CALL_OW 275
70484: PUSH
70485: LD_VAR 0 11
70489: PUSH
70490: LD_INT 1
70492: ARRAY
70493: GREATEREQUAL
70494: PUSH
70495: LD_VAR 0 10
70499: PPUSH
70500: LD_INT 2
70502: PPUSH
70503: CALL_OW 275
70507: PUSH
70508: LD_VAR 0 11
70512: PUSH
70513: LD_INT 2
70515: ARRAY
70516: GREATEREQUAL
70517: AND
70518: PUSH
70519: LD_VAR 0 10
70523: PPUSH
70524: LD_INT 3
70526: PPUSH
70527: CALL_OW 275
70531: PUSH
70532: LD_VAR 0 11
70536: PUSH
70537: LD_INT 3
70539: ARRAY
70540: GREATEREQUAL
70541: AND
70542: NOT
70543: IFFALSE 70547
// exit ;
70545: GO 71149
// if GetBType ( depot ) = b_depot then
70547: LD_VAR 0 1
70551: PPUSH
70552: CALL_OW 266
70556: PUSH
70557: LD_INT 0
70559: EQUAL
70560: IFFALSE 70572
// dist := 28 else
70562: LD_ADDR_VAR 0 14
70566: PUSH
70567: LD_INT 28
70569: ST_TO_ADDR
70570: GO 70580
// dist := 36 ;
70572: LD_ADDR_VAR 0 14
70576: PUSH
70577: LD_INT 36
70579: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
70580: LD_VAR 0 1
70584: PPUSH
70585: LD_VAR 0 3
70589: PPUSH
70590: LD_VAR 0 4
70594: PPUSH
70595: CALL_OW 297
70599: PUSH
70600: LD_VAR 0 14
70604: GREATER
70605: IFFALSE 70609
// exit ;
70607: GO 71149
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
70609: LD_ADDR_VAR 0 12
70613: PUSH
70614: LD_VAR 0 2
70618: PPUSH
70619: LD_VAR 0 3
70623: PPUSH
70624: LD_VAR 0 4
70628: PPUSH
70629: LD_VAR 0 5
70633: PPUSH
70634: LD_VAR 0 1
70638: PPUSH
70639: CALL_OW 248
70643: PPUSH
70644: LD_INT 0
70646: PPUSH
70647: CALL 71154 0 6
70651: ST_TO_ADDR
// if not hexes then
70652: LD_VAR 0 12
70656: NOT
70657: IFFALSE 70661
// exit ;
70659: GO 71149
// hex := GetHexInfo ( x , y ) ;
70661: LD_ADDR_VAR 0 15
70665: PUSH
70666: LD_VAR 0 3
70670: PPUSH
70671: LD_VAR 0 4
70675: PPUSH
70676: CALL_OW 546
70680: ST_TO_ADDR
// if hex [ 1 ] then
70681: LD_VAR 0 15
70685: PUSH
70686: LD_INT 1
70688: ARRAY
70689: IFFALSE 70693
// exit ;
70691: GO 71149
// height := hex [ 2 ] ;
70693: LD_ADDR_VAR 0 13
70697: PUSH
70698: LD_VAR 0 15
70702: PUSH
70703: LD_INT 2
70705: ARRAY
70706: ST_TO_ADDR
// for i = 1 to hexes do
70707: LD_ADDR_VAR 0 7
70711: PUSH
70712: DOUBLE
70713: LD_INT 1
70715: DEC
70716: ST_TO_ADDR
70717: LD_VAR 0 12
70721: PUSH
70722: FOR_TO
70723: IFFALSE 71053
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
70725: LD_VAR 0 12
70729: PUSH
70730: LD_VAR 0 7
70734: ARRAY
70735: PUSH
70736: LD_INT 1
70738: ARRAY
70739: PPUSH
70740: LD_VAR 0 12
70744: PUSH
70745: LD_VAR 0 7
70749: ARRAY
70750: PUSH
70751: LD_INT 2
70753: ARRAY
70754: PPUSH
70755: CALL_OW 488
70759: NOT
70760: PUSH
70761: LD_VAR 0 12
70765: PUSH
70766: LD_VAR 0 7
70770: ARRAY
70771: PUSH
70772: LD_INT 1
70774: ARRAY
70775: PPUSH
70776: LD_VAR 0 12
70780: PUSH
70781: LD_VAR 0 7
70785: ARRAY
70786: PUSH
70787: LD_INT 2
70789: ARRAY
70790: PPUSH
70791: CALL_OW 428
70795: PUSH
70796: LD_INT 0
70798: GREATER
70799: OR
70800: PUSH
70801: LD_VAR 0 12
70805: PUSH
70806: LD_VAR 0 7
70810: ARRAY
70811: PUSH
70812: LD_INT 1
70814: ARRAY
70815: PPUSH
70816: LD_VAR 0 12
70820: PUSH
70821: LD_VAR 0 7
70825: ARRAY
70826: PUSH
70827: LD_INT 2
70829: ARRAY
70830: PPUSH
70831: CALL_OW 351
70835: OR
70836: IFFALSE 70842
// exit ;
70838: POP
70839: POP
70840: GO 71149
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
70842: LD_ADDR_VAR 0 8
70846: PUSH
70847: LD_VAR 0 12
70851: PUSH
70852: LD_VAR 0 7
70856: ARRAY
70857: PUSH
70858: LD_INT 1
70860: ARRAY
70861: PPUSH
70862: LD_VAR 0 12
70866: PUSH
70867: LD_VAR 0 7
70871: ARRAY
70872: PUSH
70873: LD_INT 2
70875: ARRAY
70876: PPUSH
70877: CALL_OW 546
70881: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
70882: LD_VAR 0 8
70886: PUSH
70887: LD_INT 1
70889: ARRAY
70890: PUSH
70891: LD_VAR 0 8
70895: PUSH
70896: LD_INT 2
70898: ARRAY
70899: PUSH
70900: LD_VAR 0 13
70904: PUSH
70905: LD_INT 2
70907: PLUS
70908: GREATER
70909: OR
70910: PUSH
70911: LD_VAR 0 8
70915: PUSH
70916: LD_INT 2
70918: ARRAY
70919: PUSH
70920: LD_VAR 0 13
70924: PUSH
70925: LD_INT 2
70927: MINUS
70928: LESS
70929: OR
70930: PUSH
70931: LD_VAR 0 8
70935: PUSH
70936: LD_INT 3
70938: ARRAY
70939: PUSH
70940: LD_INT 0
70942: PUSH
70943: LD_INT 8
70945: PUSH
70946: LD_INT 9
70948: PUSH
70949: LD_INT 10
70951: PUSH
70952: LD_INT 11
70954: PUSH
70955: LD_INT 12
70957: PUSH
70958: LD_INT 13
70960: PUSH
70961: LD_INT 16
70963: PUSH
70964: LD_INT 17
70966: PUSH
70967: LD_INT 18
70969: PUSH
70970: LD_INT 19
70972: PUSH
70973: LD_INT 20
70975: PUSH
70976: LD_INT 21
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: IN
70994: NOT
70995: OR
70996: PUSH
70997: LD_VAR 0 8
71001: PUSH
71002: LD_INT 5
71004: ARRAY
71005: NOT
71006: OR
71007: PUSH
71008: LD_VAR 0 8
71012: PUSH
71013: LD_INT 6
71015: ARRAY
71016: PUSH
71017: LD_INT 1
71019: PUSH
71020: LD_INT 2
71022: PUSH
71023: LD_INT 7
71025: PUSH
71026: LD_INT 9
71028: PUSH
71029: LD_INT 10
71031: PUSH
71032: LD_INT 11
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: IN
71043: NOT
71044: OR
71045: IFFALSE 71051
// exit ;
71047: POP
71048: POP
71049: GO 71149
// end ;
71051: GO 70722
71053: POP
71054: POP
// side := GetSide ( depot ) ;
71055: LD_ADDR_VAR 0 9
71059: PUSH
71060: LD_VAR 0 1
71064: PPUSH
71065: CALL_OW 255
71069: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71070: LD_VAR 0 9
71074: PPUSH
71075: LD_VAR 0 3
71079: PPUSH
71080: LD_VAR 0 4
71084: PPUSH
71085: LD_INT 20
71087: PPUSH
71088: CALL 63803 0 4
71092: PUSH
71093: LD_INT 4
71095: ARRAY
71096: IFFALSE 71100
// exit ;
71098: GO 71149
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
71100: LD_VAR 0 2
71104: PUSH
71105: LD_INT 29
71107: PUSH
71108: LD_INT 30
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: IN
71115: PUSH
71116: LD_VAR 0 3
71120: PPUSH
71121: LD_VAR 0 4
71125: PPUSH
71126: LD_VAR 0 9
71130: PPUSH
71131: CALL_OW 440
71135: NOT
71136: AND
71137: IFFALSE 71141
// exit ;
71139: GO 71149
// result := true ;
71141: LD_ADDR_VAR 0 6
71145: PUSH
71146: LD_INT 1
71148: ST_TO_ADDR
// end ;
71149: LD_VAR 0 6
71153: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
71154: LD_INT 0
71156: PPUSH
71157: PPUSH
71158: PPUSH
71159: PPUSH
71160: PPUSH
71161: PPUSH
71162: PPUSH
71163: PPUSH
71164: PPUSH
71165: PPUSH
71166: PPUSH
71167: PPUSH
71168: PPUSH
71169: PPUSH
71170: PPUSH
71171: PPUSH
71172: PPUSH
71173: PPUSH
71174: PPUSH
71175: PPUSH
71176: PPUSH
71177: PPUSH
71178: PPUSH
71179: PPUSH
71180: PPUSH
71181: PPUSH
71182: PPUSH
71183: PPUSH
71184: PPUSH
71185: PPUSH
71186: PPUSH
71187: PPUSH
71188: PPUSH
71189: PPUSH
71190: PPUSH
71191: PPUSH
71192: PPUSH
71193: PPUSH
71194: PPUSH
71195: PPUSH
71196: PPUSH
71197: PPUSH
71198: PPUSH
71199: PPUSH
71200: PPUSH
71201: PPUSH
71202: PPUSH
71203: PPUSH
71204: PPUSH
71205: PPUSH
71206: PPUSH
71207: PPUSH
71208: PPUSH
71209: PPUSH
71210: PPUSH
71211: PPUSH
71212: PPUSH
71213: PPUSH
// result = [ ] ;
71214: LD_ADDR_VAR 0 7
71218: PUSH
71219: EMPTY
71220: ST_TO_ADDR
// temp_list = [ ] ;
71221: LD_ADDR_VAR 0 9
71225: PUSH
71226: EMPTY
71227: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
71228: LD_VAR 0 4
71232: PUSH
71233: LD_INT 0
71235: PUSH
71236: LD_INT 1
71238: PUSH
71239: LD_INT 2
71241: PUSH
71242: LD_INT 3
71244: PUSH
71245: LD_INT 4
71247: PUSH
71248: LD_INT 5
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: IN
71259: NOT
71260: PUSH
71261: LD_VAR 0 1
71265: PUSH
71266: LD_INT 0
71268: PUSH
71269: LD_INT 1
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: IN
71276: PUSH
71277: LD_VAR 0 5
71281: PUSH
71282: LD_INT 1
71284: PUSH
71285: LD_INT 2
71287: PUSH
71288: LD_INT 3
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: LIST
71295: IN
71296: NOT
71297: AND
71298: OR
71299: IFFALSE 71303
// exit ;
71301: GO 89694
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
71303: LD_VAR 0 1
71307: PUSH
71308: LD_INT 6
71310: PUSH
71311: LD_INT 7
71313: PUSH
71314: LD_INT 8
71316: PUSH
71317: LD_INT 13
71319: PUSH
71320: LD_INT 12
71322: PUSH
71323: LD_INT 15
71325: PUSH
71326: LD_INT 11
71328: PUSH
71329: LD_INT 14
71331: PUSH
71332: LD_INT 10
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: IN
71346: IFFALSE 71356
// btype = b_lab ;
71348: LD_ADDR_VAR 0 1
71352: PUSH
71353: LD_INT 6
71355: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
71356: LD_VAR 0 6
71360: PUSH
71361: LD_INT 0
71363: PUSH
71364: LD_INT 1
71366: PUSH
71367: LD_INT 2
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: LIST
71374: IN
71375: NOT
71376: PUSH
71377: LD_VAR 0 1
71381: PUSH
71382: LD_INT 0
71384: PUSH
71385: LD_INT 1
71387: PUSH
71388: LD_INT 2
71390: PUSH
71391: LD_INT 3
71393: PUSH
71394: LD_INT 6
71396: PUSH
71397: LD_INT 36
71399: PUSH
71400: LD_INT 4
71402: PUSH
71403: LD_INT 5
71405: PUSH
71406: LD_INT 31
71408: PUSH
71409: LD_INT 32
71411: PUSH
71412: LD_INT 33
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: IN
71428: NOT
71429: PUSH
71430: LD_VAR 0 6
71434: PUSH
71435: LD_INT 1
71437: EQUAL
71438: AND
71439: OR
71440: PUSH
71441: LD_VAR 0 1
71445: PUSH
71446: LD_INT 2
71448: PUSH
71449: LD_INT 3
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: IN
71456: NOT
71457: PUSH
71458: LD_VAR 0 6
71462: PUSH
71463: LD_INT 2
71465: EQUAL
71466: AND
71467: OR
71468: IFFALSE 71478
// mode = 0 ;
71470: LD_ADDR_VAR 0 6
71474: PUSH
71475: LD_INT 0
71477: ST_TO_ADDR
// case mode of 0 :
71478: LD_VAR 0 6
71482: PUSH
71483: LD_INT 0
71485: DOUBLE
71486: EQUAL
71487: IFTRUE 71491
71489: GO 82944
71491: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
71492: LD_ADDR_VAR 0 11
71496: PUSH
71497: LD_INT 0
71499: PUSH
71500: LD_INT 0
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 0
71509: PUSH
71510: LD_INT 1
71512: NEG
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 1
71520: PUSH
71521: LD_INT 0
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: LD_INT 1
71530: PUSH
71531: LD_INT 1
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 0
71540: PUSH
71541: LD_INT 1
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: LD_INT 1
71550: NEG
71551: PUSH
71552: LD_INT 0
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: PUSH
71559: LD_INT 1
71561: NEG
71562: PUSH
71563: LD_INT 1
71565: NEG
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 1
71573: NEG
71574: PUSH
71575: LD_INT 2
71577: NEG
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 0
71585: PUSH
71586: LD_INT 2
71588: NEG
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: LD_INT 1
71599: NEG
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: LD_INT 1
71607: PUSH
71608: LD_INT 2
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 0
71617: PUSH
71618: LD_INT 2
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: PUSH
71625: LD_INT 1
71627: NEG
71628: PUSH
71629: LD_INT 1
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 1
71638: PUSH
71639: LD_INT 3
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PUSH
71646: LD_INT 0
71648: PUSH
71649: LD_INT 3
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 1
71658: NEG
71659: PUSH
71660: LD_INT 2
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: LIST
71671: LIST
71672: LIST
71673: LIST
71674: LIST
71675: LIST
71676: LIST
71677: LIST
71678: LIST
71679: LIST
71680: LIST
71681: LIST
71682: LIST
71683: LIST
71684: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71685: LD_ADDR_VAR 0 12
71689: PUSH
71690: LD_INT 0
71692: PUSH
71693: LD_INT 0
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 0
71702: PUSH
71703: LD_INT 1
71705: NEG
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 1
71713: PUSH
71714: LD_INT 0
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PUSH
71721: LD_INT 1
71723: PUSH
71724: LD_INT 1
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: PUSH
71731: LD_INT 0
71733: PUSH
71734: LD_INT 1
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 1
71743: NEG
71744: PUSH
71745: LD_INT 0
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 1
71754: NEG
71755: PUSH
71756: LD_INT 1
71758: NEG
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: PUSH
71764: LD_INT 1
71766: PUSH
71767: LD_INT 1
71769: NEG
71770: PUSH
71771: EMPTY
71772: LIST
71773: LIST
71774: PUSH
71775: LD_INT 2
71777: PUSH
71778: LD_INT 0
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: PUSH
71785: LD_INT 2
71787: PUSH
71788: LD_INT 1
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 1
71797: NEG
71798: PUSH
71799: LD_INT 1
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 2
71808: NEG
71809: PUSH
71810: LD_INT 0
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 2
71819: NEG
71820: PUSH
71821: LD_INT 1
71823: NEG
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: LD_INT 2
71831: NEG
71832: PUSH
71833: LD_INT 1
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: LD_INT 3
71842: NEG
71843: PUSH
71844: LD_INT 0
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PUSH
71851: LD_INT 3
71853: NEG
71854: PUSH
71855: LD_INT 1
71857: NEG
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71881: LD_ADDR_VAR 0 13
71885: PUSH
71886: LD_INT 0
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: LD_INT 1
71901: NEG
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: LD_INT 1
71909: PUSH
71910: LD_INT 0
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: LD_INT 1
71919: PUSH
71920: LD_INT 1
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 0
71929: PUSH
71930: LD_INT 1
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: LD_INT 1
71939: NEG
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 1
71950: NEG
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 1
71962: NEG
71963: PUSH
71964: LD_INT 2
71966: NEG
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 2
71974: PUSH
71975: LD_INT 1
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 2
71984: PUSH
71985: LD_INT 2
71987: PUSH
71988: EMPTY
71989: LIST
71990: LIST
71991: PUSH
71992: LD_INT 1
71994: PUSH
71995: LD_INT 2
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: LD_INT 2
72004: NEG
72005: PUSH
72006: LD_INT 1
72008: NEG
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 2
72016: NEG
72017: PUSH
72018: LD_INT 2
72020: NEG
72021: PUSH
72022: EMPTY
72023: LIST
72024: LIST
72025: PUSH
72026: LD_INT 2
72028: NEG
72029: PUSH
72030: LD_INT 3
72032: NEG
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 3
72040: NEG
72041: PUSH
72042: LD_INT 2
72044: NEG
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: PUSH
72050: LD_INT 3
72052: NEG
72053: PUSH
72054: LD_INT 3
72056: NEG
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: LIST
72078: LIST
72079: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72080: LD_ADDR_VAR 0 14
72084: PUSH
72085: LD_INT 0
72087: PUSH
72088: LD_INT 0
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 0
72097: PUSH
72098: LD_INT 1
72100: NEG
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 1
72108: PUSH
72109: LD_INT 0
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 1
72118: PUSH
72119: LD_INT 1
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 0
72128: PUSH
72129: LD_INT 1
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 1
72138: NEG
72139: PUSH
72140: LD_INT 0
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 1
72149: NEG
72150: PUSH
72151: LD_INT 1
72153: NEG
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: LD_INT 1
72161: NEG
72162: PUSH
72163: LD_INT 2
72165: NEG
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 0
72173: PUSH
72174: LD_INT 2
72176: NEG
72177: PUSH
72178: EMPTY
72179: LIST
72180: LIST
72181: PUSH
72182: LD_INT 1
72184: PUSH
72185: LD_INT 1
72187: NEG
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: LD_INT 1
72195: PUSH
72196: LD_INT 2
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 0
72205: PUSH
72206: LD_INT 2
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 1
72215: NEG
72216: PUSH
72217: LD_INT 1
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 1
72226: NEG
72227: PUSH
72228: LD_INT 3
72230: NEG
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 0
72238: PUSH
72239: LD_INT 3
72241: NEG
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PUSH
72247: LD_INT 1
72249: PUSH
72250: LD_INT 2
72252: NEG
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: LIST
72262: LIST
72263: LIST
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: LIST
72269: LIST
72270: LIST
72271: LIST
72272: LIST
72273: LIST
72274: LIST
72275: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72276: LD_ADDR_VAR 0 15
72280: PUSH
72281: LD_INT 0
72283: PUSH
72284: LD_INT 0
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PUSH
72291: LD_INT 0
72293: PUSH
72294: LD_INT 1
72296: NEG
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 1
72304: PUSH
72305: LD_INT 0
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 1
72314: PUSH
72315: LD_INT 1
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 0
72324: PUSH
72325: LD_INT 1
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: LD_INT 1
72334: NEG
72335: PUSH
72336: LD_INT 0
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 1
72345: NEG
72346: PUSH
72347: LD_INT 1
72349: NEG
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: PUSH
72355: LD_INT 1
72357: PUSH
72358: LD_INT 1
72360: NEG
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 2
72368: PUSH
72369: LD_INT 0
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 2
72378: PUSH
72379: LD_INT 1
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: LD_INT 1
72388: NEG
72389: PUSH
72390: LD_INT 1
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: PUSH
72397: LD_INT 2
72399: NEG
72400: PUSH
72401: LD_INT 0
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: LD_INT 2
72410: NEG
72411: PUSH
72412: LD_INT 1
72414: NEG
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 2
72422: PUSH
72423: LD_INT 1
72425: NEG
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: PUSH
72431: LD_INT 3
72433: PUSH
72434: LD_INT 0
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 3
72443: PUSH
72444: LD_INT 1
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72469: LD_ADDR_VAR 0 16
72473: PUSH
72474: LD_INT 0
72476: PUSH
72477: LD_INT 0
72479: PUSH
72480: EMPTY
72481: LIST
72482: LIST
72483: PUSH
72484: LD_INT 0
72486: PUSH
72487: LD_INT 1
72489: NEG
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: LD_INT 1
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 1
72507: PUSH
72508: LD_INT 1
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 0
72517: PUSH
72518: LD_INT 1
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 1
72527: NEG
72528: PUSH
72529: LD_INT 0
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 1
72538: NEG
72539: PUSH
72540: LD_INT 1
72542: NEG
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: PUSH
72548: LD_INT 1
72550: NEG
72551: PUSH
72552: LD_INT 2
72554: NEG
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 2
72562: PUSH
72563: LD_INT 1
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 2
72572: PUSH
72573: LD_INT 2
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 1
72582: PUSH
72583: LD_INT 2
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 2
72592: NEG
72593: PUSH
72594: LD_INT 1
72596: NEG
72597: PUSH
72598: EMPTY
72599: LIST
72600: LIST
72601: PUSH
72602: LD_INT 2
72604: NEG
72605: PUSH
72606: LD_INT 2
72608: NEG
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 3
72616: PUSH
72617: LD_INT 2
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 3
72626: PUSH
72627: LD_INT 3
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 2
72636: PUSH
72637: LD_INT 3
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: LIST
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72662: LD_ADDR_VAR 0 17
72666: PUSH
72667: LD_INT 0
72669: PUSH
72670: LD_INT 0
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 0
72679: PUSH
72680: LD_INT 1
72682: NEG
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 1
72690: PUSH
72691: LD_INT 0
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: LD_INT 1
72700: PUSH
72701: LD_INT 1
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: LD_INT 1
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PUSH
72718: LD_INT 1
72720: NEG
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 1
72731: NEG
72732: PUSH
72733: LD_INT 1
72735: NEG
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: LD_INT 1
72743: NEG
72744: PUSH
72745: LD_INT 2
72747: NEG
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 0
72755: PUSH
72756: LD_INT 2
72758: NEG
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: PUSH
72764: LD_INT 1
72766: PUSH
72767: LD_INT 1
72769: NEG
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: LD_INT 2
72777: PUSH
72778: LD_INT 0
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: PUSH
72785: LD_INT 2
72787: PUSH
72788: LD_INT 1
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 2
72797: PUSH
72798: LD_INT 2
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: PUSH
72805: LD_INT 1
72807: PUSH
72808: LD_INT 2
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 0
72817: PUSH
72818: LD_INT 2
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 1
72827: NEG
72828: PUSH
72829: LD_INT 1
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 2
72838: NEG
72839: PUSH
72840: LD_INT 0
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PUSH
72847: LD_INT 2
72849: NEG
72850: PUSH
72851: LD_INT 1
72853: NEG
72854: PUSH
72855: EMPTY
72856: LIST
72857: LIST
72858: PUSH
72859: LD_INT 2
72861: NEG
72862: PUSH
72863: LD_INT 2
72865: NEG
72866: PUSH
72867: EMPTY
72868: LIST
72869: LIST
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: LIST
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: LIST
72890: LIST
72891: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72892: LD_ADDR_VAR 0 18
72896: PUSH
72897: LD_INT 0
72899: PUSH
72900: LD_INT 0
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 0
72909: PUSH
72910: LD_INT 1
72912: NEG
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 1
72920: PUSH
72921: LD_INT 0
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: LD_INT 1
72930: PUSH
72931: LD_INT 1
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 0
72940: PUSH
72941: LD_INT 1
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 1
72950: NEG
72951: PUSH
72952: LD_INT 0
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 1
72961: NEG
72962: PUSH
72963: LD_INT 1
72965: NEG
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 1
72973: NEG
72974: PUSH
72975: LD_INT 2
72977: NEG
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 0
72985: PUSH
72986: LD_INT 2
72988: NEG
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: PUSH
72994: LD_INT 1
72996: PUSH
72997: LD_INT 1
72999: NEG
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: LD_INT 2
73007: PUSH
73008: LD_INT 0
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: LD_INT 2
73017: PUSH
73018: LD_INT 1
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 2
73027: PUSH
73028: LD_INT 2
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: PUSH
73035: LD_INT 1
73037: PUSH
73038: LD_INT 2
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 0
73047: PUSH
73048: LD_INT 2
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 1
73057: NEG
73058: PUSH
73059: LD_INT 1
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: LD_INT 2
73068: NEG
73069: PUSH
73070: LD_INT 0
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 2
73079: NEG
73080: PUSH
73081: LD_INT 1
73083: NEG
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_INT 2
73091: NEG
73092: PUSH
73093: LD_INT 2
73095: NEG
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: LIST
73117: LIST
73118: LIST
73119: LIST
73120: LIST
73121: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73122: LD_ADDR_VAR 0 19
73126: PUSH
73127: LD_INT 0
73129: PUSH
73130: LD_INT 0
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 0
73139: PUSH
73140: LD_INT 1
73142: NEG
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 1
73150: PUSH
73151: LD_INT 0
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: PUSH
73158: LD_INT 1
73160: PUSH
73161: LD_INT 1
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 0
73170: PUSH
73171: LD_INT 1
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 1
73180: NEG
73181: PUSH
73182: LD_INT 0
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 1
73191: NEG
73192: PUSH
73193: LD_INT 1
73195: NEG
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 1
73203: NEG
73204: PUSH
73205: LD_INT 2
73207: NEG
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: PUSH
73213: LD_INT 0
73215: PUSH
73216: LD_INT 2
73218: NEG
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 1
73226: PUSH
73227: LD_INT 1
73229: NEG
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 2
73237: PUSH
73238: LD_INT 0
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 2
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 2
73257: PUSH
73258: LD_INT 2
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 1
73267: PUSH
73268: LD_INT 2
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 0
73277: PUSH
73278: LD_INT 2
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: PUSH
73285: LD_INT 1
73287: NEG
73288: PUSH
73289: LD_INT 1
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PUSH
73296: LD_INT 2
73298: NEG
73299: PUSH
73300: LD_INT 0
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PUSH
73307: LD_INT 2
73309: NEG
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 2
73321: NEG
73322: PUSH
73323: LD_INT 2
73325: NEG
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: LIST
73335: LIST
73336: LIST
73337: LIST
73338: LIST
73339: LIST
73340: LIST
73341: LIST
73342: LIST
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73352: LD_ADDR_VAR 0 20
73356: PUSH
73357: LD_INT 0
73359: PUSH
73360: LD_INT 0
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 0
73369: PUSH
73370: LD_INT 1
73372: NEG
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 1
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 1
73390: PUSH
73391: LD_INT 1
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 0
73400: PUSH
73401: LD_INT 1
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PUSH
73408: LD_INT 1
73410: NEG
73411: PUSH
73412: LD_INT 0
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 1
73421: NEG
73422: PUSH
73423: LD_INT 1
73425: NEG
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 1
73433: NEG
73434: PUSH
73435: LD_INT 2
73437: NEG
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 0
73445: PUSH
73446: LD_INT 2
73448: NEG
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: PUSH
73454: LD_INT 1
73456: PUSH
73457: LD_INT 1
73459: NEG
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 2
73467: PUSH
73468: LD_INT 0
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 2
73477: PUSH
73478: LD_INT 1
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 2
73487: PUSH
73488: LD_INT 2
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 1
73497: PUSH
73498: LD_INT 2
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 0
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: EMPTY
73512: LIST
73513: LIST
73514: PUSH
73515: LD_INT 1
73517: NEG
73518: PUSH
73519: LD_INT 1
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 2
73528: NEG
73529: PUSH
73530: LD_INT 0
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 2
73539: NEG
73540: PUSH
73541: LD_INT 1
73543: NEG
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 2
73551: NEG
73552: PUSH
73553: LD_INT 2
73555: NEG
73556: PUSH
73557: EMPTY
73558: LIST
73559: LIST
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: LIST
73580: LIST
73581: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73582: LD_ADDR_VAR 0 21
73586: PUSH
73587: LD_INT 0
73589: PUSH
73590: LD_INT 0
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 0
73599: PUSH
73600: LD_INT 1
73602: NEG
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 1
73610: PUSH
73611: LD_INT 0
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 1
73620: PUSH
73621: LD_INT 1
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 0
73630: PUSH
73631: LD_INT 1
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 1
73640: NEG
73641: PUSH
73642: LD_INT 0
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 1
73651: NEG
73652: PUSH
73653: LD_INT 1
73655: NEG
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: LD_INT 1
73663: NEG
73664: PUSH
73665: LD_INT 2
73667: NEG
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 0
73675: PUSH
73676: LD_INT 2
73678: NEG
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 1
73686: PUSH
73687: LD_INT 1
73689: NEG
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 2
73697: PUSH
73698: LD_INT 0
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 2
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 2
73717: PUSH
73718: LD_INT 2
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 1
73727: PUSH
73728: LD_INT 2
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 0
73737: PUSH
73738: LD_INT 2
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 1
73747: NEG
73748: PUSH
73749: LD_INT 1
73751: PUSH
73752: EMPTY
73753: LIST
73754: LIST
73755: PUSH
73756: LD_INT 2
73758: NEG
73759: PUSH
73760: LD_INT 0
73762: PUSH
73763: EMPTY
73764: LIST
73765: LIST
73766: PUSH
73767: LD_INT 2
73769: NEG
73770: PUSH
73771: LD_INT 1
73773: NEG
73774: PUSH
73775: EMPTY
73776: LIST
73777: LIST
73778: PUSH
73779: LD_INT 2
73781: NEG
73782: PUSH
73783: LD_INT 2
73785: NEG
73786: PUSH
73787: EMPTY
73788: LIST
73789: LIST
73790: PUSH
73791: EMPTY
73792: LIST
73793: LIST
73794: LIST
73795: LIST
73796: LIST
73797: LIST
73798: LIST
73799: LIST
73800: LIST
73801: LIST
73802: LIST
73803: LIST
73804: LIST
73805: LIST
73806: LIST
73807: LIST
73808: LIST
73809: LIST
73810: LIST
73811: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73812: LD_ADDR_VAR 0 22
73816: PUSH
73817: LD_INT 0
73819: PUSH
73820: LD_INT 0
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 0
73829: PUSH
73830: LD_INT 1
73832: NEG
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: PUSH
73838: LD_INT 1
73840: PUSH
73841: LD_INT 0
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: PUSH
73848: LD_INT 1
73850: PUSH
73851: LD_INT 1
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 0
73860: PUSH
73861: LD_INT 1
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 1
73870: NEG
73871: PUSH
73872: LD_INT 0
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 1
73881: NEG
73882: PUSH
73883: LD_INT 1
73885: NEG
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 1
73893: NEG
73894: PUSH
73895: LD_INT 2
73897: NEG
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 0
73905: PUSH
73906: LD_INT 2
73908: NEG
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: PUSH
73914: LD_INT 1
73916: PUSH
73917: LD_INT 1
73919: NEG
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: PUSH
73925: LD_INT 2
73927: PUSH
73928: LD_INT 0
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 2
73937: PUSH
73938: LD_INT 1
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 2
73947: PUSH
73948: LD_INT 2
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 1
73957: PUSH
73958: LD_INT 2
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 0
73967: PUSH
73968: LD_INT 2
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PUSH
73975: LD_INT 1
73977: NEG
73978: PUSH
73979: LD_INT 1
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: LD_INT 2
73988: NEG
73989: PUSH
73990: LD_INT 0
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 2
73999: NEG
74000: PUSH
74001: LD_INT 1
74003: NEG
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 2
74011: NEG
74012: PUSH
74013: LD_INT 2
74015: NEG
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: LIST
74025: LIST
74026: LIST
74027: LIST
74028: LIST
74029: LIST
74030: LIST
74031: LIST
74032: LIST
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
74042: LD_ADDR_VAR 0 23
74046: PUSH
74047: LD_INT 0
74049: PUSH
74050: LD_INT 0
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: LD_INT 1
74062: NEG
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 1
74070: PUSH
74071: LD_INT 0
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PUSH
74078: LD_INT 1
74080: PUSH
74081: LD_INT 1
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 0
74090: PUSH
74091: LD_INT 1
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 1
74100: NEG
74101: PUSH
74102: LD_INT 0
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: LD_INT 1
74111: NEG
74112: PUSH
74113: LD_INT 1
74115: NEG
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: PUSH
74121: LD_INT 1
74123: NEG
74124: PUSH
74125: LD_INT 2
74127: NEG
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: LD_INT 0
74135: PUSH
74136: LD_INT 2
74138: NEG
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 1
74146: PUSH
74147: LD_INT 1
74149: NEG
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: PUSH
74155: LD_INT 2
74157: PUSH
74158: LD_INT 0
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 2
74167: PUSH
74168: LD_INT 1
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 2
74177: PUSH
74178: LD_INT 2
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 1
74187: PUSH
74188: LD_INT 2
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: PUSH
74195: LD_INT 0
74197: PUSH
74198: LD_INT 2
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: PUSH
74205: LD_INT 1
74207: NEG
74208: PUSH
74209: LD_INT 1
74211: PUSH
74212: EMPTY
74213: LIST
74214: LIST
74215: PUSH
74216: LD_INT 2
74218: NEG
74219: PUSH
74220: LD_INT 0
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 2
74229: NEG
74230: PUSH
74231: LD_INT 1
74233: NEG
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: LD_INT 2
74241: NEG
74242: PUSH
74243: LD_INT 2
74245: NEG
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: PUSH
74251: LD_INT 2
74253: NEG
74254: PUSH
74255: LD_INT 3
74257: NEG
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: LD_INT 3
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 1
74277: PUSH
74278: LD_INT 2
74280: NEG
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 2
74288: PUSH
74289: LD_INT 1
74291: NEG
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: LIST
74307: LIST
74308: LIST
74309: LIST
74310: LIST
74311: LIST
74312: LIST
74313: LIST
74314: LIST
74315: LIST
74316: LIST
74317: LIST
74318: LIST
74319: LIST
74320: LIST
74321: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
74322: LD_ADDR_VAR 0 24
74326: PUSH
74327: LD_INT 0
74329: PUSH
74330: LD_INT 0
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 0
74339: PUSH
74340: LD_INT 1
74342: NEG
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: PUSH
74348: LD_INT 1
74350: PUSH
74351: LD_INT 0
74353: PUSH
74354: EMPTY
74355: LIST
74356: LIST
74357: PUSH
74358: LD_INT 1
74360: PUSH
74361: LD_INT 1
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: LD_INT 0
74370: PUSH
74371: LD_INT 1
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 1
74380: NEG
74381: PUSH
74382: LD_INT 0
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 1
74391: NEG
74392: PUSH
74393: LD_INT 1
74395: NEG
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 1
74403: NEG
74404: PUSH
74405: LD_INT 2
74407: NEG
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 0
74415: PUSH
74416: LD_INT 2
74418: NEG
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: PUSH
74424: LD_INT 1
74426: PUSH
74427: LD_INT 1
74429: NEG
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 2
74437: PUSH
74438: LD_INT 0
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 2
74447: PUSH
74448: LD_INT 1
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 2
74457: PUSH
74458: LD_INT 2
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 1
74467: PUSH
74468: LD_INT 2
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PUSH
74475: LD_INT 0
74477: PUSH
74478: LD_INT 2
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 1
74487: NEG
74488: PUSH
74489: LD_INT 1
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 2
74498: NEG
74499: PUSH
74500: LD_INT 0
74502: PUSH
74503: EMPTY
74504: LIST
74505: LIST
74506: PUSH
74507: LD_INT 2
74509: NEG
74510: PUSH
74511: LD_INT 1
74513: NEG
74514: PUSH
74515: EMPTY
74516: LIST
74517: LIST
74518: PUSH
74519: LD_INT 2
74521: NEG
74522: PUSH
74523: LD_INT 2
74525: NEG
74526: PUSH
74527: EMPTY
74528: LIST
74529: LIST
74530: PUSH
74531: LD_INT 1
74533: PUSH
74534: LD_INT 2
74536: NEG
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 2
74544: PUSH
74545: LD_INT 1
74547: NEG
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 3
74555: PUSH
74556: LD_INT 1
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 3
74565: PUSH
74566: LD_INT 2
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: LIST
74580: LIST
74581: LIST
74582: LIST
74583: LIST
74584: LIST
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: LIST
74590: LIST
74591: LIST
74592: LIST
74593: LIST
74594: LIST
74595: LIST
74596: LIST
74597: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
74598: LD_ADDR_VAR 0 25
74602: PUSH
74603: LD_INT 0
74605: PUSH
74606: LD_INT 0
74608: PUSH
74609: EMPTY
74610: LIST
74611: LIST
74612: PUSH
74613: LD_INT 0
74615: PUSH
74616: LD_INT 1
74618: NEG
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: LD_INT 1
74626: PUSH
74627: LD_INT 0
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 1
74636: PUSH
74637: LD_INT 1
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 0
74646: PUSH
74647: LD_INT 1
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 1
74656: NEG
74657: PUSH
74658: LD_INT 0
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 1
74667: NEG
74668: PUSH
74669: LD_INT 1
74671: NEG
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 1
74679: NEG
74680: PUSH
74681: LD_INT 2
74683: NEG
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 0
74691: PUSH
74692: LD_INT 2
74694: NEG
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 1
74702: PUSH
74703: LD_INT 1
74705: NEG
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 2
74713: PUSH
74714: LD_INT 0
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: LD_INT 2
74723: PUSH
74724: LD_INT 1
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 2
74733: PUSH
74734: LD_INT 2
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 1
74743: PUSH
74744: LD_INT 2
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 0
74753: PUSH
74754: LD_INT 2
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 1
74763: NEG
74764: PUSH
74765: LD_INT 1
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 2
74774: NEG
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 2
74785: NEG
74786: PUSH
74787: LD_INT 1
74789: NEG
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PUSH
74795: LD_INT 2
74797: NEG
74798: PUSH
74799: LD_INT 2
74801: NEG
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 3
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 3
74819: PUSH
74820: LD_INT 2
74822: PUSH
74823: EMPTY
74824: LIST
74825: LIST
74826: PUSH
74827: LD_INT 2
74829: PUSH
74830: LD_INT 3
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: PUSH
74837: LD_INT 1
74839: PUSH
74840: LD_INT 3
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: EMPTY
74848: LIST
74849: LIST
74850: LIST
74851: LIST
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: LIST
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
74872: LD_ADDR_VAR 0 26
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: LD_INT 0
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: LD_INT 1
74892: NEG
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 0
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 1
74910: PUSH
74911: LD_INT 1
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 0
74920: PUSH
74921: LD_INT 1
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: LD_INT 1
74930: NEG
74931: PUSH
74932: LD_INT 0
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: LD_INT 1
74941: NEG
74942: PUSH
74943: LD_INT 1
74945: NEG
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: PUSH
74951: LD_INT 1
74953: NEG
74954: PUSH
74955: LD_INT 2
74957: NEG
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 0
74965: PUSH
74966: LD_INT 2
74968: NEG
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 1
74976: PUSH
74977: LD_INT 1
74979: NEG
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 2
74987: PUSH
74988: LD_INT 0
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 2
74997: PUSH
74998: LD_INT 1
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 2
75007: PUSH
75008: LD_INT 2
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PUSH
75015: LD_INT 1
75017: PUSH
75018: LD_INT 2
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: LD_INT 0
75027: PUSH
75028: LD_INT 2
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: LD_INT 1
75037: NEG
75038: PUSH
75039: LD_INT 1
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 2
75048: NEG
75049: PUSH
75050: LD_INT 0
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 2
75059: NEG
75060: PUSH
75061: LD_INT 1
75063: NEG
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 2
75071: NEG
75072: PUSH
75073: LD_INT 2
75075: NEG
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 2
75083: PUSH
75084: LD_INT 3
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 1
75093: PUSH
75094: LD_INT 3
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 1
75103: NEG
75104: PUSH
75105: LD_INT 2
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: PUSH
75112: LD_INT 2
75114: NEG
75115: PUSH
75116: LD_INT 1
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: LIST
75143: LIST
75144: LIST
75145: LIST
75146: LIST
75147: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
75148: LD_ADDR_VAR 0 27
75152: PUSH
75153: LD_INT 0
75155: PUSH
75156: LD_INT 0
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: LD_INT 0
75165: PUSH
75166: LD_INT 1
75168: NEG
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: PUSH
75174: LD_INT 1
75176: PUSH
75177: LD_INT 0
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 1
75186: PUSH
75187: LD_INT 1
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 0
75196: PUSH
75197: LD_INT 1
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 1
75206: NEG
75207: PUSH
75208: LD_INT 0
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PUSH
75215: LD_INT 1
75217: NEG
75218: PUSH
75219: LD_INT 1
75221: NEG
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 1
75229: NEG
75230: PUSH
75231: LD_INT 2
75233: NEG
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 0
75241: PUSH
75242: LD_INT 2
75244: NEG
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 1
75252: PUSH
75253: LD_INT 1
75255: NEG
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 2
75263: PUSH
75264: LD_INT 0
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 2
75273: PUSH
75274: LD_INT 1
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 2
75283: PUSH
75284: LD_INT 2
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 1
75293: PUSH
75294: LD_INT 2
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: PUSH
75301: LD_INT 0
75303: PUSH
75304: LD_INT 2
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 1
75313: NEG
75314: PUSH
75315: LD_INT 1
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 2
75324: NEG
75325: PUSH
75326: LD_INT 0
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 2
75335: NEG
75336: PUSH
75337: LD_INT 1
75339: NEG
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 2
75347: NEG
75348: PUSH
75349: LD_INT 2
75351: NEG
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: LD_INT 1
75359: NEG
75360: PUSH
75361: LD_INT 2
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 2
75370: NEG
75371: PUSH
75372: LD_INT 1
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 3
75381: NEG
75382: PUSH
75383: LD_INT 1
75385: NEG
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: LD_INT 3
75393: NEG
75394: PUSH
75395: LD_INT 2
75397: NEG
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: LIST
75410: LIST
75411: LIST
75412: LIST
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: LIST
75418: LIST
75419: LIST
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: LIST
75425: LIST
75426: LIST
75427: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
75428: LD_ADDR_VAR 0 28
75432: PUSH
75433: LD_INT 0
75435: PUSH
75436: LD_INT 0
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 0
75445: PUSH
75446: LD_INT 1
75448: NEG
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 1
75456: PUSH
75457: LD_INT 0
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PUSH
75464: LD_INT 1
75466: PUSH
75467: LD_INT 1
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 0
75476: PUSH
75477: LD_INT 1
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 1
75486: NEG
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 1
75497: NEG
75498: PUSH
75499: LD_INT 1
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 1
75509: NEG
75510: PUSH
75511: LD_INT 2
75513: NEG
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 0
75521: PUSH
75522: LD_INT 2
75524: NEG
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 1
75532: PUSH
75533: LD_INT 1
75535: NEG
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 2
75543: PUSH
75544: LD_INT 0
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: LD_INT 2
75553: PUSH
75554: LD_INT 1
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 2
75563: PUSH
75564: LD_INT 2
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 1
75573: PUSH
75574: LD_INT 2
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 0
75583: PUSH
75584: LD_INT 2
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 1
75593: NEG
75594: PUSH
75595: LD_INT 1
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 2
75604: NEG
75605: PUSH
75606: LD_INT 0
75608: PUSH
75609: EMPTY
75610: LIST
75611: LIST
75612: PUSH
75613: LD_INT 2
75615: NEG
75616: PUSH
75617: LD_INT 1
75619: NEG
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: LD_INT 2
75627: NEG
75628: PUSH
75629: LD_INT 2
75631: NEG
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 2
75639: NEG
75640: PUSH
75641: LD_INT 3
75643: NEG
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 1
75651: NEG
75652: PUSH
75653: LD_INT 3
75655: NEG
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 3
75663: NEG
75664: PUSH
75665: LD_INT 1
75667: NEG
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 3
75675: NEG
75676: PUSH
75677: LD_INT 2
75679: NEG
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: LIST
75689: LIST
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: LIST
75696: LIST
75697: LIST
75698: LIST
75699: LIST
75700: LIST
75701: LIST
75702: LIST
75703: LIST
75704: LIST
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
75710: LD_ADDR_VAR 0 29
75714: PUSH
75715: LD_INT 0
75717: PUSH
75718: LD_INT 0
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 0
75727: PUSH
75728: LD_INT 1
75730: NEG
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: PUSH
75736: LD_INT 1
75738: PUSH
75739: LD_INT 0
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: PUSH
75746: LD_INT 1
75748: PUSH
75749: LD_INT 1
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: PUSH
75756: LD_INT 0
75758: PUSH
75759: LD_INT 1
75761: PUSH
75762: EMPTY
75763: LIST
75764: LIST
75765: PUSH
75766: LD_INT 1
75768: NEG
75769: PUSH
75770: LD_INT 0
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: LD_INT 1
75779: NEG
75780: PUSH
75781: LD_INT 1
75783: NEG
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: LD_INT 1
75791: NEG
75792: PUSH
75793: LD_INT 2
75795: NEG
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 0
75803: PUSH
75804: LD_INT 2
75806: NEG
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: LD_INT 1
75814: PUSH
75815: LD_INT 1
75817: NEG
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: PUSH
75823: LD_INT 2
75825: PUSH
75826: LD_INT 0
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: LD_INT 2
75835: PUSH
75836: LD_INT 1
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: PUSH
75843: LD_INT 1
75845: PUSH
75846: LD_INT 2
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: PUSH
75853: LD_INT 0
75855: PUSH
75856: LD_INT 2
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 1
75865: NEG
75866: PUSH
75867: LD_INT 1
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 2
75876: NEG
75877: PUSH
75878: LD_INT 1
75880: NEG
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 2
75888: NEG
75889: PUSH
75890: LD_INT 2
75892: NEG
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 2
75900: NEG
75901: PUSH
75902: LD_INT 3
75904: NEG
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 2
75912: PUSH
75913: LD_INT 1
75915: NEG
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: LD_INT 3
75923: PUSH
75924: LD_INT 1
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 1
75933: PUSH
75934: LD_INT 3
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: PUSH
75941: LD_INT 1
75943: NEG
75944: PUSH
75945: LD_INT 2
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 3
75954: NEG
75955: PUSH
75956: LD_INT 2
75958: NEG
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: LIST
75968: LIST
75969: LIST
75970: LIST
75971: LIST
75972: LIST
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: LIST
75987: LIST
75988: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75989: LD_ADDR_VAR 0 30
75993: PUSH
75994: LD_INT 0
75996: PUSH
75997: LD_INT 0
75999: PUSH
76000: EMPTY
76001: LIST
76002: LIST
76003: PUSH
76004: LD_INT 0
76006: PUSH
76007: LD_INT 1
76009: NEG
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 1
76017: PUSH
76018: LD_INT 0
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 1
76027: PUSH
76028: LD_INT 1
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 0
76037: PUSH
76038: LD_INT 1
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 1
76047: NEG
76048: PUSH
76049: LD_INT 0
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 1
76058: NEG
76059: PUSH
76060: LD_INT 1
76062: NEG
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PUSH
76068: LD_INT 1
76070: NEG
76071: PUSH
76072: LD_INT 2
76074: NEG
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: LD_INT 0
76082: PUSH
76083: LD_INT 2
76085: NEG
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 1
76093: PUSH
76094: LD_INT 1
76096: NEG
76097: PUSH
76098: EMPTY
76099: LIST
76100: LIST
76101: PUSH
76102: LD_INT 2
76104: PUSH
76105: LD_INT 0
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: PUSH
76112: LD_INT 2
76114: PUSH
76115: LD_INT 1
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 2
76124: PUSH
76125: LD_INT 2
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 1
76134: PUSH
76135: LD_INT 2
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 1
76144: NEG
76145: PUSH
76146: LD_INT 1
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 2
76155: NEG
76156: PUSH
76157: LD_INT 0
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 2
76166: NEG
76167: PUSH
76168: LD_INT 1
76170: NEG
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: LD_INT 1
76178: NEG
76179: PUSH
76180: LD_INT 3
76182: NEG
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: LD_INT 1
76190: PUSH
76191: LD_INT 2
76193: NEG
76194: PUSH
76195: EMPTY
76196: LIST
76197: LIST
76198: PUSH
76199: LD_INT 3
76201: PUSH
76202: LD_INT 2
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: LD_INT 2
76211: PUSH
76212: LD_INT 3
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 2
76221: NEG
76222: PUSH
76223: LD_INT 1
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 3
76232: NEG
76233: PUSH
76234: LD_INT 1
76236: NEG
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: LIST
76246: LIST
76247: LIST
76248: LIST
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
76267: LD_ADDR_VAR 0 31
76271: PUSH
76272: LD_INT 0
76274: PUSH
76275: LD_INT 0
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 0
76284: PUSH
76285: LD_INT 1
76287: NEG
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 1
76295: PUSH
76296: LD_INT 0
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 1
76305: PUSH
76306: LD_INT 1
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 0
76315: PUSH
76316: LD_INT 1
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: LD_INT 1
76325: NEG
76326: PUSH
76327: LD_INT 0
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: PUSH
76334: LD_INT 1
76336: NEG
76337: PUSH
76338: LD_INT 1
76340: NEG
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 1
76348: NEG
76349: PUSH
76350: LD_INT 2
76352: NEG
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 1
76360: PUSH
76361: LD_INT 1
76363: NEG
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: PUSH
76369: LD_INT 2
76371: PUSH
76372: LD_INT 0
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 2
76381: PUSH
76382: LD_INT 1
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 2
76391: PUSH
76392: LD_INT 2
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 1
76401: PUSH
76402: LD_INT 2
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 0
76411: PUSH
76412: LD_INT 2
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: PUSH
76419: LD_INT 1
76421: NEG
76422: PUSH
76423: LD_INT 1
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: LD_INT 1
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 2
76444: NEG
76445: PUSH
76446: LD_INT 2
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 2
76456: NEG
76457: PUSH
76458: LD_INT 3
76460: NEG
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 2
76468: PUSH
76469: LD_INT 1
76471: NEG
76472: PUSH
76473: EMPTY
76474: LIST
76475: LIST
76476: PUSH
76477: LD_INT 3
76479: PUSH
76480: LD_INT 1
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 1
76489: PUSH
76490: LD_INT 3
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 1
76499: NEG
76500: PUSH
76501: LD_INT 2
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 3
76510: NEG
76511: PUSH
76512: LD_INT 2
76514: NEG
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76545: LD_ADDR_VAR 0 32
76549: PUSH
76550: LD_INT 0
76552: PUSH
76553: LD_INT 0
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 0
76562: PUSH
76563: LD_INT 1
76565: NEG
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PUSH
76571: LD_INT 1
76573: PUSH
76574: LD_INT 0
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: LD_INT 1
76583: PUSH
76584: LD_INT 1
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 0
76593: PUSH
76594: LD_INT 1
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 1
76603: NEG
76604: PUSH
76605: LD_INT 0
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 1
76614: NEG
76615: PUSH
76616: LD_INT 1
76618: NEG
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: LD_INT 1
76626: NEG
76627: PUSH
76628: LD_INT 2
76630: NEG
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 0
76638: PUSH
76639: LD_INT 2
76641: NEG
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 1
76649: PUSH
76650: LD_INT 1
76652: NEG
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 2
76660: PUSH
76661: LD_INT 1
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PUSH
76668: LD_INT 2
76670: PUSH
76671: LD_INT 2
76673: PUSH
76674: EMPTY
76675: LIST
76676: LIST
76677: PUSH
76678: LD_INT 1
76680: PUSH
76681: LD_INT 2
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: PUSH
76688: LD_INT 0
76690: PUSH
76691: LD_INT 2
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: LD_INT 1
76700: NEG
76701: PUSH
76702: LD_INT 1
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: LD_INT 2
76711: NEG
76712: PUSH
76713: LD_INT 0
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PUSH
76720: LD_INT 2
76722: NEG
76723: PUSH
76724: LD_INT 1
76726: NEG
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 1
76734: NEG
76735: PUSH
76736: LD_INT 3
76738: NEG
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 1
76746: PUSH
76747: LD_INT 2
76749: NEG
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PUSH
76755: LD_INT 3
76757: PUSH
76758: LD_INT 2
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: LD_INT 2
76767: PUSH
76768: LD_INT 3
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 2
76777: NEG
76778: PUSH
76779: LD_INT 1
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 3
76788: NEG
76789: PUSH
76790: LD_INT 1
76792: NEG
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: LIST
76802: LIST
76803: LIST
76804: LIST
76805: LIST
76806: LIST
76807: LIST
76808: LIST
76809: LIST
76810: LIST
76811: LIST
76812: LIST
76813: LIST
76814: LIST
76815: LIST
76816: LIST
76817: LIST
76818: LIST
76819: LIST
76820: LIST
76821: LIST
76822: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
76823: LD_ADDR_VAR 0 33
76827: PUSH
76828: LD_INT 0
76830: PUSH
76831: LD_INT 0
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 0
76840: PUSH
76841: LD_INT 1
76843: NEG
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 1
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 1
76861: PUSH
76862: LD_INT 1
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 0
76871: PUSH
76872: LD_INT 1
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: PUSH
76879: LD_INT 1
76881: NEG
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 1
76892: NEG
76893: PUSH
76894: LD_INT 1
76896: NEG
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 1
76904: NEG
76905: PUSH
76906: LD_INT 2
76908: NEG
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 1
76916: PUSH
76917: LD_INT 1
76919: NEG
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: LD_INT 2
76927: PUSH
76928: LD_INT 0
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 2
76937: PUSH
76938: LD_INT 1
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: PUSH
76945: LD_INT 1
76947: PUSH
76948: LD_INT 2
76950: PUSH
76951: EMPTY
76952: LIST
76953: LIST
76954: PUSH
76955: LD_INT 0
76957: PUSH
76958: LD_INT 2
76960: PUSH
76961: EMPTY
76962: LIST
76963: LIST
76964: PUSH
76965: LD_INT 1
76967: NEG
76968: PUSH
76969: LD_INT 1
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 2
76978: NEG
76979: PUSH
76980: LD_INT 0
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PUSH
76987: LD_INT 2
76989: NEG
76990: PUSH
76991: LD_INT 1
76993: NEG
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 2
77001: NEG
77002: PUSH
77003: LD_INT 2
77005: NEG
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 2
77013: NEG
77014: PUSH
77015: LD_INT 3
77017: NEG
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 2
77025: PUSH
77026: LD_INT 1
77028: NEG
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 3
77036: PUSH
77037: LD_INT 1
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 1
77046: PUSH
77047: LD_INT 3
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 1
77056: NEG
77057: PUSH
77058: LD_INT 2
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 3
77067: NEG
77068: PUSH
77069: LD_INT 2
77071: NEG
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: LIST
77087: LIST
77088: LIST
77089: LIST
77090: LIST
77091: LIST
77092: LIST
77093: LIST
77094: LIST
77095: LIST
77096: LIST
77097: LIST
77098: LIST
77099: LIST
77100: LIST
77101: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77102: LD_ADDR_VAR 0 34
77106: PUSH
77107: LD_INT 0
77109: PUSH
77110: LD_INT 0
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 0
77119: PUSH
77120: LD_INT 1
77122: NEG
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 1
77130: PUSH
77131: LD_INT 0
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 1
77140: PUSH
77141: LD_INT 1
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 0
77150: PUSH
77151: LD_INT 1
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 1
77160: NEG
77161: PUSH
77162: LD_INT 0
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 1
77171: NEG
77172: PUSH
77173: LD_INT 1
77175: NEG
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: LD_INT 1
77183: NEG
77184: PUSH
77185: LD_INT 2
77187: NEG
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: LD_INT 0
77195: PUSH
77196: LD_INT 2
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 1
77206: PUSH
77207: LD_INT 1
77209: NEG
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 2
77217: PUSH
77218: LD_INT 1
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 2
77227: PUSH
77228: LD_INT 2
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 1
77237: PUSH
77238: LD_INT 2
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: LD_INT 1
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 2
77258: NEG
77259: PUSH
77260: LD_INT 0
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 2
77269: NEG
77270: PUSH
77271: LD_INT 1
77273: NEG
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 2
77281: NEG
77282: PUSH
77283: LD_INT 2
77285: NEG
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 1
77293: NEG
77294: PUSH
77295: LD_INT 3
77297: NEG
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 1
77305: PUSH
77306: LD_INT 2
77308: NEG
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: LD_INT 3
77316: PUSH
77317: LD_INT 2
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: LD_INT 2
77326: PUSH
77327: LD_INT 3
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 2
77336: NEG
77337: PUSH
77338: LD_INT 1
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 3
77347: NEG
77348: PUSH
77349: LD_INT 1
77351: NEG
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: LIST
77361: LIST
77362: LIST
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: LIST
77368: LIST
77369: LIST
77370: LIST
77371: LIST
77372: LIST
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: LIST
77381: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
77382: LD_ADDR_VAR 0 35
77386: PUSH
77387: LD_INT 0
77389: PUSH
77390: LD_INT 0
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 0
77399: PUSH
77400: LD_INT 1
77402: NEG
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 1
77410: PUSH
77411: LD_INT 0
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 1
77420: PUSH
77421: LD_INT 1
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 0
77430: PUSH
77431: LD_INT 1
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 1
77440: NEG
77441: PUSH
77442: LD_INT 0
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 1
77451: NEG
77452: PUSH
77453: LD_INT 1
77455: NEG
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: PUSH
77461: LD_INT 2
77463: PUSH
77464: LD_INT 1
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: PUSH
77471: LD_INT 2
77473: NEG
77474: PUSH
77475: LD_INT 1
77477: NEG
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: LIST
77487: LIST
77488: LIST
77489: LIST
77490: LIST
77491: LIST
77492: LIST
77493: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
77494: LD_ADDR_VAR 0 36
77498: PUSH
77499: LD_INT 0
77501: PUSH
77502: LD_INT 0
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: LD_INT 1
77514: NEG
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: PUSH
77520: LD_INT 1
77522: PUSH
77523: LD_INT 0
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: LD_INT 1
77532: PUSH
77533: LD_INT 1
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 0
77542: PUSH
77543: LD_INT 1
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: LD_INT 1
77552: NEG
77553: PUSH
77554: LD_INT 0
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 1
77563: NEG
77564: PUSH
77565: LD_INT 1
77567: NEG
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 1
77575: NEG
77576: PUSH
77577: LD_INT 2
77579: NEG
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 1
77587: PUSH
77588: LD_INT 2
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
77606: LD_ADDR_VAR 0 37
77610: PUSH
77611: LD_INT 0
77613: PUSH
77614: LD_INT 0
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 0
77623: PUSH
77624: LD_INT 1
77626: NEG
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: PUSH
77632: LD_INT 1
77634: PUSH
77635: LD_INT 0
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: PUSH
77642: LD_INT 1
77644: PUSH
77645: LD_INT 1
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: LD_INT 0
77654: PUSH
77655: LD_INT 1
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 1
77664: NEG
77665: PUSH
77666: LD_INT 0
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 1
77675: NEG
77676: PUSH
77677: LD_INT 1
77679: NEG
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 1
77687: PUSH
77688: LD_INT 1
77690: NEG
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 1
77698: NEG
77699: PUSH
77700: LD_INT 1
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: EMPTY
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
77718: LD_ADDR_VAR 0 38
77722: PUSH
77723: LD_INT 0
77725: PUSH
77726: LD_INT 0
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 0
77735: PUSH
77736: LD_INT 1
77738: NEG
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 1
77746: PUSH
77747: LD_INT 0
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 1
77756: PUSH
77757: LD_INT 1
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: PUSH
77764: LD_INT 0
77766: PUSH
77767: LD_INT 1
77769: PUSH
77770: EMPTY
77771: LIST
77772: LIST
77773: PUSH
77774: LD_INT 1
77776: NEG
77777: PUSH
77778: LD_INT 0
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: PUSH
77785: LD_INT 1
77787: NEG
77788: PUSH
77789: LD_INT 1
77791: NEG
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 2
77799: PUSH
77800: LD_INT 1
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 2
77809: NEG
77810: PUSH
77811: LD_INT 1
77813: NEG
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
77830: LD_ADDR_VAR 0 39
77834: PUSH
77835: LD_INT 0
77837: PUSH
77838: LD_INT 0
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 0
77847: PUSH
77848: LD_INT 1
77850: NEG
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 1
77858: PUSH
77859: LD_INT 0
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 1
77868: PUSH
77869: LD_INT 1
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 0
77878: PUSH
77879: LD_INT 1
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 1
77888: NEG
77889: PUSH
77890: LD_INT 0
77892: PUSH
77893: EMPTY
77894: LIST
77895: LIST
77896: PUSH
77897: LD_INT 1
77899: NEG
77900: PUSH
77901: LD_INT 1
77903: NEG
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 1
77911: NEG
77912: PUSH
77913: LD_INT 2
77915: NEG
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 1
77923: PUSH
77924: LD_INT 2
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: LIST
77935: LIST
77936: LIST
77937: LIST
77938: LIST
77939: LIST
77940: LIST
77941: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
77942: LD_ADDR_VAR 0 40
77946: PUSH
77947: LD_INT 0
77949: PUSH
77950: LD_INT 0
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PUSH
77957: LD_INT 0
77959: PUSH
77960: LD_INT 1
77962: NEG
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PUSH
77968: LD_INT 1
77970: PUSH
77971: LD_INT 0
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: PUSH
77978: LD_INT 1
77980: PUSH
77981: LD_INT 1
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 0
77990: PUSH
77991: LD_INT 1
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 1
78000: NEG
78001: PUSH
78002: LD_INT 0
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 1
78011: NEG
78012: PUSH
78013: LD_INT 1
78015: NEG
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: LD_INT 1
78023: PUSH
78024: LD_INT 1
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 1
78034: NEG
78035: PUSH
78036: LD_INT 1
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: LIST
78047: LIST
78048: LIST
78049: LIST
78050: LIST
78051: LIST
78052: LIST
78053: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78054: LD_ADDR_VAR 0 41
78058: PUSH
78059: LD_INT 0
78061: PUSH
78062: LD_INT 0
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 0
78071: PUSH
78072: LD_INT 1
78074: NEG
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 1
78082: PUSH
78083: LD_INT 0
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 1
78092: PUSH
78093: LD_INT 1
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 0
78102: PUSH
78103: LD_INT 1
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 1
78112: NEG
78113: PUSH
78114: LD_INT 0
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: PUSH
78121: LD_INT 1
78123: NEG
78124: PUSH
78125: LD_INT 1
78127: NEG
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: LD_INT 1
78135: NEG
78136: PUSH
78137: LD_INT 2
78139: NEG
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_INT 1
78147: PUSH
78148: LD_INT 1
78150: NEG
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: PUSH
78156: LD_INT 2
78158: PUSH
78159: LD_INT 0
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 2
78168: PUSH
78169: LD_INT 1
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 2
78178: PUSH
78179: LD_INT 2
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 1
78188: PUSH
78189: LD_INT 2
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: LD_INT 1
78198: NEG
78199: PUSH
78200: LD_INT 1
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PUSH
78207: LD_INT 2
78209: NEG
78210: PUSH
78211: LD_INT 0
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 2
78220: NEG
78221: PUSH
78222: LD_INT 1
78224: NEG
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 2
78232: NEG
78233: PUSH
78234: LD_INT 2
78236: NEG
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: LD_INT 2
78244: NEG
78245: PUSH
78246: LD_INT 3
78248: NEG
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: LD_INT 2
78256: PUSH
78257: LD_INT 1
78259: NEG
78260: PUSH
78261: EMPTY
78262: LIST
78263: LIST
78264: PUSH
78265: LD_INT 3
78267: PUSH
78268: LD_INT 0
78270: PUSH
78271: EMPTY
78272: LIST
78273: LIST
78274: PUSH
78275: LD_INT 3
78277: PUSH
78278: LD_INT 1
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 3
78287: PUSH
78288: LD_INT 2
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 3
78297: PUSH
78298: LD_INT 3
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PUSH
78305: LD_INT 2
78307: PUSH
78308: LD_INT 3
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 2
78317: NEG
78318: PUSH
78319: LD_INT 1
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PUSH
78326: LD_INT 3
78328: NEG
78329: PUSH
78330: LD_INT 0
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 3
78339: NEG
78340: PUSH
78341: LD_INT 1
78343: NEG
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: LD_INT 3
78351: NEG
78352: PUSH
78353: LD_INT 2
78355: NEG
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PUSH
78361: LD_INT 3
78363: NEG
78364: PUSH
78365: LD_INT 3
78367: NEG
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: LIST
78382: LIST
78383: LIST
78384: LIST
78385: LIST
78386: LIST
78387: LIST
78388: LIST
78389: LIST
78390: LIST
78391: LIST
78392: LIST
78393: LIST
78394: LIST
78395: LIST
78396: LIST
78397: LIST
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78404: LD_ADDR_VAR 0 42
78408: PUSH
78409: LD_INT 0
78411: PUSH
78412: LD_INT 0
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 0
78421: PUSH
78422: LD_INT 1
78424: NEG
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 1
78432: PUSH
78433: LD_INT 0
78435: PUSH
78436: EMPTY
78437: LIST
78438: LIST
78439: PUSH
78440: LD_INT 1
78442: PUSH
78443: LD_INT 1
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 0
78452: PUSH
78453: LD_INT 1
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 1
78462: NEG
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 1
78473: NEG
78474: PUSH
78475: LD_INT 1
78477: NEG
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: LD_INT 1
78485: NEG
78486: PUSH
78487: LD_INT 2
78489: NEG
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: LD_INT 0
78497: PUSH
78498: LD_INT 2
78500: NEG
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 1
78508: PUSH
78509: LD_INT 1
78511: NEG
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 2
78519: PUSH
78520: LD_INT 1
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 2
78529: PUSH
78530: LD_INT 2
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 1
78539: PUSH
78540: LD_INT 2
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 0
78549: PUSH
78550: LD_INT 2
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 1
78559: NEG
78560: PUSH
78561: LD_INT 1
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 2
78570: NEG
78571: PUSH
78572: LD_INT 1
78574: NEG
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 2
78582: NEG
78583: PUSH
78584: LD_INT 2
78586: NEG
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 2
78594: NEG
78595: PUSH
78596: LD_INT 3
78598: NEG
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PUSH
78604: LD_INT 1
78606: NEG
78607: PUSH
78608: LD_INT 3
78610: NEG
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 0
78618: PUSH
78619: LD_INT 3
78621: NEG
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 1
78629: PUSH
78630: LD_INT 2
78632: NEG
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 3
78640: PUSH
78641: LD_INT 2
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 3
78650: PUSH
78651: LD_INT 3
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 2
78660: PUSH
78661: LD_INT 3
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 1
78670: PUSH
78671: LD_INT 3
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: LD_INT 0
78680: PUSH
78681: LD_INT 3
78683: PUSH
78684: EMPTY
78685: LIST
78686: LIST
78687: PUSH
78688: LD_INT 1
78690: NEG
78691: PUSH
78692: LD_INT 2
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 3
78701: NEG
78702: PUSH
78703: LD_INT 2
78705: NEG
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 3
78713: NEG
78714: PUSH
78715: LD_INT 3
78717: NEG
78718: PUSH
78719: EMPTY
78720: LIST
78721: LIST
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: LIST
78731: LIST
78732: LIST
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: LIST
78752: LIST
78753: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78754: LD_ADDR_VAR 0 43
78758: PUSH
78759: LD_INT 0
78761: PUSH
78762: LD_INT 0
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 0
78771: PUSH
78772: LD_INT 1
78774: NEG
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: LD_INT 1
78782: PUSH
78783: LD_INT 0
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PUSH
78790: LD_INT 1
78792: PUSH
78793: LD_INT 1
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: LD_INT 0
78802: PUSH
78803: LD_INT 1
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 1
78812: NEG
78813: PUSH
78814: LD_INT 0
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 1
78823: NEG
78824: PUSH
78825: LD_INT 1
78827: NEG
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 1
78835: NEG
78836: PUSH
78837: LD_INT 2
78839: NEG
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 0
78847: PUSH
78848: LD_INT 2
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 1
78858: PUSH
78859: LD_INT 1
78861: NEG
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 2
78869: PUSH
78870: LD_INT 0
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 2
78879: PUSH
78880: LD_INT 1
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 1
78889: PUSH
78890: LD_INT 2
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: LD_INT 0
78899: PUSH
78900: LD_INT 2
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 1
78909: NEG
78910: PUSH
78911: LD_INT 1
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 2
78920: NEG
78921: PUSH
78922: LD_INT 0
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: NEG
78932: PUSH
78933: LD_INT 1
78935: NEG
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 1
78943: NEG
78944: PUSH
78945: LD_INT 3
78947: NEG
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 0
78955: PUSH
78956: LD_INT 3
78958: NEG
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 1
78966: PUSH
78967: LD_INT 2
78969: NEG
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: PUSH
78975: LD_INT 2
78977: PUSH
78978: LD_INT 1
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 3
78988: PUSH
78989: LD_INT 0
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 3
78998: PUSH
78999: LD_INT 1
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 1
79008: PUSH
79009: LD_INT 3
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 0
79018: PUSH
79019: LD_INT 3
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 1
79028: NEG
79029: PUSH
79030: LD_INT 2
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 2
79039: NEG
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 3
79050: NEG
79051: PUSH
79052: LD_INT 0
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 3
79061: NEG
79062: PUSH
79063: LD_INT 1
79065: NEG
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: LIST
79079: LIST
79080: LIST
79081: LIST
79082: LIST
79083: LIST
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79102: LD_ADDR_VAR 0 44
79106: PUSH
79107: LD_INT 0
79109: PUSH
79110: LD_INT 0
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 0
79119: PUSH
79120: LD_INT 1
79122: NEG
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 1
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 1
79140: PUSH
79141: LD_INT 1
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 0
79150: PUSH
79151: LD_INT 1
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: PUSH
79158: LD_INT 1
79160: NEG
79161: PUSH
79162: LD_INT 0
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 1
79171: NEG
79172: PUSH
79173: LD_INT 1
79175: NEG
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 1
79183: NEG
79184: PUSH
79185: LD_INT 2
79187: NEG
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 1
79195: PUSH
79196: LD_INT 1
79198: NEG
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: PUSH
79204: LD_INT 2
79206: PUSH
79207: LD_INT 0
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 2
79216: PUSH
79217: LD_INT 1
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: PUSH
79224: LD_INT 2
79226: PUSH
79227: LD_INT 2
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 1
79236: PUSH
79237: LD_INT 2
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: PUSH
79244: LD_INT 1
79246: NEG
79247: PUSH
79248: LD_INT 1
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 2
79257: NEG
79258: PUSH
79259: LD_INT 0
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 2
79268: NEG
79269: PUSH
79270: LD_INT 1
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 2
79280: NEG
79281: PUSH
79282: LD_INT 2
79284: NEG
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 2
79292: NEG
79293: PUSH
79294: LD_INT 3
79296: NEG
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 2
79304: PUSH
79305: LD_INT 1
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 3
79315: PUSH
79316: LD_INT 0
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 3
79325: PUSH
79326: LD_INT 1
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 3
79335: PUSH
79336: LD_INT 2
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 3
79345: PUSH
79346: LD_INT 3
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: PUSH
79353: LD_INT 2
79355: PUSH
79356: LD_INT 3
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 2
79365: NEG
79366: PUSH
79367: LD_INT 1
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 3
79376: NEG
79377: PUSH
79378: LD_INT 0
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 3
79387: NEG
79388: PUSH
79389: LD_INT 1
79391: NEG
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 3
79399: NEG
79400: PUSH
79401: LD_INT 2
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 3
79411: NEG
79412: PUSH
79413: LD_INT 3
79415: NEG
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79452: LD_ADDR_VAR 0 45
79456: PUSH
79457: LD_INT 0
79459: PUSH
79460: LD_INT 0
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 0
79469: PUSH
79470: LD_INT 1
79472: NEG
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 1
79480: PUSH
79481: LD_INT 0
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 1
79490: PUSH
79491: LD_INT 1
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: LD_INT 0
79500: PUSH
79501: LD_INT 1
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 1
79510: NEG
79511: PUSH
79512: LD_INT 0
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 1
79521: NEG
79522: PUSH
79523: LD_INT 1
79525: NEG
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 1
79533: NEG
79534: PUSH
79535: LD_INT 2
79537: NEG
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: LD_INT 2
79548: NEG
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 1
79556: PUSH
79557: LD_INT 1
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 2
79567: PUSH
79568: LD_INT 1
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 2
79577: PUSH
79578: LD_INT 2
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 1
79587: PUSH
79588: LD_INT 2
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 0
79597: PUSH
79598: LD_INT 2
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PUSH
79605: LD_INT 1
79607: NEG
79608: PUSH
79609: LD_INT 1
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 2
79618: NEG
79619: PUSH
79620: LD_INT 1
79622: NEG
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 2
79630: NEG
79631: PUSH
79632: LD_INT 2
79634: NEG
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 2
79642: NEG
79643: PUSH
79644: LD_INT 3
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 1
79654: NEG
79655: PUSH
79656: LD_INT 3
79658: NEG
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: LD_INT 0
79666: PUSH
79667: LD_INT 3
79669: NEG
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 1
79677: PUSH
79678: LD_INT 2
79680: NEG
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 3
79688: PUSH
79689: LD_INT 2
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 3
79698: PUSH
79699: LD_INT 3
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 2
79708: PUSH
79709: LD_INT 3
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 1
79718: PUSH
79719: LD_INT 3
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 0
79728: PUSH
79729: LD_INT 3
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PUSH
79736: LD_INT 1
79738: NEG
79739: PUSH
79740: LD_INT 2
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 3
79749: NEG
79750: PUSH
79751: LD_INT 2
79753: NEG
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 3
79761: NEG
79762: PUSH
79763: LD_INT 3
79765: NEG
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: LIST
79775: LIST
79776: LIST
79777: LIST
79778: LIST
79779: LIST
79780: LIST
79781: LIST
79782: LIST
79783: LIST
79784: LIST
79785: LIST
79786: LIST
79787: LIST
79788: LIST
79789: LIST
79790: LIST
79791: LIST
79792: LIST
79793: LIST
79794: LIST
79795: LIST
79796: LIST
79797: LIST
79798: LIST
79799: LIST
79800: LIST
79801: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79802: LD_ADDR_VAR 0 46
79806: PUSH
79807: LD_INT 0
79809: PUSH
79810: LD_INT 0
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: PUSH
79817: LD_INT 0
79819: PUSH
79820: LD_INT 1
79822: NEG
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 1
79830: PUSH
79831: LD_INT 0
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 1
79840: PUSH
79841: LD_INT 1
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 0
79850: PUSH
79851: LD_INT 1
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 1
79860: NEG
79861: PUSH
79862: LD_INT 0
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 1
79871: NEG
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: PUSH
79881: LD_INT 1
79883: NEG
79884: PUSH
79885: LD_INT 2
79887: NEG
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: LD_INT 2
79898: NEG
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 1
79906: PUSH
79907: LD_INT 1
79909: NEG
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 2
79917: PUSH
79918: LD_INT 0
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 2
79927: PUSH
79928: LD_INT 1
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: LD_INT 1
79937: PUSH
79938: LD_INT 2
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 0
79947: PUSH
79948: LD_INT 2
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 1
79957: NEG
79958: PUSH
79959: LD_INT 1
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 2
79968: NEG
79969: PUSH
79970: LD_INT 0
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 2
79979: NEG
79980: PUSH
79981: LD_INT 1
79983: NEG
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 1
79991: NEG
79992: PUSH
79993: LD_INT 3
79995: NEG
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: LD_INT 3
80006: NEG
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 1
80014: PUSH
80015: LD_INT 2
80017: NEG
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 2
80025: PUSH
80026: LD_INT 1
80028: NEG
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 3
80036: PUSH
80037: LD_INT 0
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 3
80046: PUSH
80047: LD_INT 1
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 1
80056: PUSH
80057: LD_INT 3
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: LD_INT 0
80066: PUSH
80067: LD_INT 3
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 1
80076: NEG
80077: PUSH
80078: LD_INT 2
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 2
80087: NEG
80088: PUSH
80089: LD_INT 1
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 3
80098: NEG
80099: PUSH
80100: LD_INT 0
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 3
80109: NEG
80110: PUSH
80111: LD_INT 1
80113: NEG
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: LIST
80141: LIST
80142: LIST
80143: LIST
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80150: LD_ADDR_VAR 0 47
80154: PUSH
80155: LD_INT 0
80157: PUSH
80158: LD_INT 0
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 0
80167: PUSH
80168: LD_INT 1
80170: NEG
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 1
80178: PUSH
80179: LD_INT 0
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 1
80188: PUSH
80189: LD_INT 1
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 0
80198: PUSH
80199: LD_INT 1
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 1
80208: NEG
80209: PUSH
80210: LD_INT 0
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 1
80219: NEG
80220: PUSH
80221: LD_INT 1
80223: NEG
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 1
80231: NEG
80232: PUSH
80233: LD_INT 2
80235: NEG
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 0
80243: PUSH
80244: LD_INT 2
80246: NEG
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 1
80254: PUSH
80255: LD_INT 1
80257: NEG
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 2
80265: NEG
80266: PUSH
80267: LD_INT 1
80269: NEG
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 2
80277: NEG
80278: PUSH
80279: LD_INT 2
80281: NEG
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: LIST
80300: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80301: LD_ADDR_VAR 0 48
80305: PUSH
80306: LD_INT 0
80308: PUSH
80309: LD_INT 0
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 0
80318: PUSH
80319: LD_INT 1
80321: NEG
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 1
80329: PUSH
80330: LD_INT 0
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: LD_INT 1
80339: PUSH
80340: LD_INT 1
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 0
80349: PUSH
80350: LD_INT 1
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 1
80359: NEG
80360: PUSH
80361: LD_INT 0
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 1
80370: NEG
80371: PUSH
80372: LD_INT 1
80374: NEG
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 1
80382: NEG
80383: PUSH
80384: LD_INT 2
80386: NEG
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 0
80394: PUSH
80395: LD_INT 2
80397: NEG
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 1
80405: PUSH
80406: LD_INT 1
80408: NEG
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 2
80416: PUSH
80417: LD_INT 0
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 2
80426: PUSH
80427: LD_INT 1
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: LIST
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80448: LD_ADDR_VAR 0 49
80452: PUSH
80453: LD_INT 0
80455: PUSH
80456: LD_INT 0
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 0
80465: PUSH
80466: LD_INT 1
80468: NEG
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 1
80476: PUSH
80477: LD_INT 0
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 1
80486: PUSH
80487: LD_INT 1
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 0
80496: PUSH
80497: LD_INT 1
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 1
80506: NEG
80507: PUSH
80508: LD_INT 0
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 1
80517: NEG
80518: PUSH
80519: LD_INT 1
80521: NEG
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: LD_INT 1
80529: PUSH
80530: LD_INT 1
80532: NEG
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 2
80540: PUSH
80541: LD_INT 0
80543: PUSH
80544: EMPTY
80545: LIST
80546: LIST
80547: PUSH
80548: LD_INT 2
80550: PUSH
80551: LD_INT 1
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 2
80560: PUSH
80561: LD_INT 2
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 1
80570: PUSH
80571: LD_INT 2
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80592: LD_ADDR_VAR 0 50
80596: PUSH
80597: LD_INT 0
80599: PUSH
80600: LD_INT 0
80602: PUSH
80603: EMPTY
80604: LIST
80605: LIST
80606: PUSH
80607: LD_INT 0
80609: PUSH
80610: LD_INT 1
80612: NEG
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 1
80620: PUSH
80621: LD_INT 0
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 1
80630: PUSH
80631: LD_INT 1
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: LD_INT 1
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 1
80650: NEG
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 1
80661: NEG
80662: PUSH
80663: LD_INT 1
80665: NEG
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PUSH
80671: LD_INT 2
80673: PUSH
80674: LD_INT 1
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 2
80683: PUSH
80684: LD_INT 2
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 1
80693: PUSH
80694: LD_INT 2
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 0
80703: PUSH
80704: LD_INT 2
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 1
80713: NEG
80714: PUSH
80715: LD_INT 1
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80736: LD_ADDR_VAR 0 51
80740: PUSH
80741: LD_INT 0
80743: PUSH
80744: LD_INT 0
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 0
80753: PUSH
80754: LD_INT 1
80756: NEG
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 1
80764: PUSH
80765: LD_INT 0
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 1
80774: PUSH
80775: LD_INT 1
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: LD_INT 0
80784: PUSH
80785: LD_INT 1
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 1
80794: NEG
80795: PUSH
80796: LD_INT 0
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 1
80805: NEG
80806: PUSH
80807: LD_INT 1
80809: NEG
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 1
80817: PUSH
80818: LD_INT 2
80820: PUSH
80821: EMPTY
80822: LIST
80823: LIST
80824: PUSH
80825: LD_INT 0
80827: PUSH
80828: LD_INT 2
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 1
80837: NEG
80838: PUSH
80839: LD_INT 1
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 2
80848: NEG
80849: PUSH
80850: LD_INT 0
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 2
80859: NEG
80860: PUSH
80861: LD_INT 1
80863: NEG
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80883: LD_ADDR_VAR 0 52
80887: PUSH
80888: LD_INT 0
80890: PUSH
80891: LD_INT 0
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 0
80900: PUSH
80901: LD_INT 1
80903: NEG
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 1
80911: PUSH
80912: LD_INT 0
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 1
80921: PUSH
80922: LD_INT 1
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: PUSH
80929: LD_INT 0
80931: PUSH
80932: LD_INT 1
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 1
80941: NEG
80942: PUSH
80943: LD_INT 0
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 1
80952: NEG
80953: PUSH
80954: LD_INT 1
80956: NEG
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: LD_INT 1
80964: NEG
80965: PUSH
80966: LD_INT 2
80968: NEG
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 1
80976: NEG
80977: PUSH
80978: LD_INT 1
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 2
80987: NEG
80988: PUSH
80989: LD_INT 0
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 2
80998: NEG
80999: PUSH
81000: LD_INT 1
81002: NEG
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 2
81010: NEG
81011: PUSH
81012: LD_INT 2
81014: NEG
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: LIST
81028: LIST
81029: LIST
81030: LIST
81031: LIST
81032: LIST
81033: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81034: LD_ADDR_VAR 0 53
81038: PUSH
81039: LD_INT 0
81041: PUSH
81042: LD_INT 0
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 0
81051: PUSH
81052: LD_INT 1
81054: NEG
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 1
81062: PUSH
81063: LD_INT 0
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 1
81072: PUSH
81073: LD_INT 1
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 0
81082: PUSH
81083: LD_INT 1
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 1
81092: NEG
81093: PUSH
81094: LD_INT 0
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 1
81103: NEG
81104: PUSH
81105: LD_INT 1
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 1
81115: NEG
81116: PUSH
81117: LD_INT 2
81119: NEG
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 0
81127: PUSH
81128: LD_INT 2
81130: NEG
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: LD_INT 1
81138: PUSH
81139: LD_INT 1
81141: NEG
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 2
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 2
81159: PUSH
81160: LD_INT 1
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 2
81169: PUSH
81170: LD_INT 2
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 1
81179: PUSH
81180: LD_INT 2
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 0
81189: PUSH
81190: LD_INT 2
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 1
81199: NEG
81200: PUSH
81201: LD_INT 1
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 2
81210: NEG
81211: PUSH
81212: LD_INT 0
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 2
81221: NEG
81222: PUSH
81223: LD_INT 1
81225: NEG
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 2
81233: NEG
81234: PUSH
81235: LD_INT 2
81237: NEG
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81264: LD_ADDR_VAR 0 54
81268: PUSH
81269: LD_INT 0
81271: PUSH
81272: LD_INT 0
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 0
81281: PUSH
81282: LD_INT 1
81284: NEG
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 1
81292: PUSH
81293: LD_INT 0
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 1
81302: PUSH
81303: LD_INT 1
81305: PUSH
81306: EMPTY
81307: LIST
81308: LIST
81309: PUSH
81310: LD_INT 0
81312: PUSH
81313: LD_INT 1
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 1
81322: NEG
81323: PUSH
81324: LD_INT 0
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 1
81333: NEG
81334: PUSH
81335: LD_INT 1
81337: NEG
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: LD_INT 1
81345: NEG
81346: PUSH
81347: LD_INT 2
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: LD_INT 2
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 1
81368: PUSH
81369: LD_INT 1
81371: NEG
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 2
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 2
81389: PUSH
81390: LD_INT 1
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 2
81399: PUSH
81400: LD_INT 2
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: PUSH
81410: LD_INT 2
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: LD_INT 2
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: PUSH
81427: LD_INT 1
81429: NEG
81430: PUSH
81431: LD_INT 1
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 2
81440: NEG
81441: PUSH
81442: LD_INT 0
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 2
81451: NEG
81452: PUSH
81453: LD_INT 1
81455: NEG
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 2
81463: NEG
81464: PUSH
81465: LD_INT 2
81467: NEG
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81494: LD_ADDR_VAR 0 55
81498: PUSH
81499: LD_INT 0
81501: PUSH
81502: LD_INT 0
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: LD_INT 1
81514: NEG
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 1
81522: PUSH
81523: LD_INT 0
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 1
81532: PUSH
81533: LD_INT 1
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 0
81542: PUSH
81543: LD_INT 1
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PUSH
81550: LD_INT 1
81552: NEG
81553: PUSH
81554: LD_INT 0
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: PUSH
81561: LD_INT 1
81563: NEG
81564: PUSH
81565: LD_INT 1
81567: NEG
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 1
81575: NEG
81576: PUSH
81577: LD_INT 2
81579: NEG
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_INT 0
81587: PUSH
81588: LD_INT 2
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 1
81598: PUSH
81599: LD_INT 1
81601: NEG
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: PUSH
81607: LD_INT 2
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 2
81619: PUSH
81620: LD_INT 1
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 2
81629: PUSH
81630: LD_INT 2
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 1
81639: PUSH
81640: LD_INT 2
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: LD_INT 2
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: PUSH
81657: LD_INT 1
81659: NEG
81660: PUSH
81661: LD_INT 1
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 2
81670: NEG
81671: PUSH
81672: LD_INT 0
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 2
81681: NEG
81682: PUSH
81683: LD_INT 1
81685: NEG
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: PUSH
81691: LD_INT 2
81693: NEG
81694: PUSH
81695: LD_INT 2
81697: NEG
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81724: LD_ADDR_VAR 0 56
81728: PUSH
81729: LD_INT 0
81731: PUSH
81732: LD_INT 0
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 0
81741: PUSH
81742: LD_INT 1
81744: NEG
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 1
81752: PUSH
81753: LD_INT 0
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: PUSH
81760: LD_INT 1
81762: PUSH
81763: LD_INT 1
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: PUSH
81770: LD_INT 0
81772: PUSH
81773: LD_INT 1
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 1
81782: NEG
81783: PUSH
81784: LD_INT 0
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 1
81793: NEG
81794: PUSH
81795: LD_INT 1
81797: NEG
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 1
81805: NEG
81806: PUSH
81807: LD_INT 2
81809: NEG
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 0
81817: PUSH
81818: LD_INT 2
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 1
81828: PUSH
81829: LD_INT 1
81831: NEG
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PUSH
81837: LD_INT 2
81839: PUSH
81840: LD_INT 0
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: LD_INT 2
81849: PUSH
81850: LD_INT 1
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 2
81859: PUSH
81860: LD_INT 2
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 1
81869: PUSH
81870: LD_INT 2
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 0
81879: PUSH
81880: LD_INT 2
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 1
81889: NEG
81890: PUSH
81891: LD_INT 1
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 2
81900: NEG
81901: PUSH
81902: LD_INT 0
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 2
81911: NEG
81912: PUSH
81913: LD_INT 1
81915: NEG
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 2
81923: NEG
81924: PUSH
81925: LD_INT 2
81927: NEG
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81954: LD_ADDR_VAR 0 57
81958: PUSH
81959: LD_INT 0
81961: PUSH
81962: LD_INT 0
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 0
81971: PUSH
81972: LD_INT 1
81974: NEG
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: PUSH
81983: LD_INT 0
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 1
81992: PUSH
81993: LD_INT 1
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PUSH
82000: LD_INT 0
82002: PUSH
82003: LD_INT 1
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 1
82012: NEG
82013: PUSH
82014: LD_INT 0
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 1
82023: NEG
82024: PUSH
82025: LD_INT 1
82027: NEG
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 1
82035: NEG
82036: PUSH
82037: LD_INT 2
82039: NEG
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: LD_INT 0
82047: PUSH
82048: LD_INT 2
82050: NEG
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PUSH
82056: LD_INT 1
82058: PUSH
82059: LD_INT 1
82061: NEG
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 2
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 2
82079: PUSH
82080: LD_INT 1
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 2
82089: PUSH
82090: LD_INT 2
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 1
82099: PUSH
82100: LD_INT 2
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: LD_INT 2
82112: PUSH
82113: EMPTY
82114: LIST
82115: LIST
82116: PUSH
82117: LD_INT 1
82119: NEG
82120: PUSH
82121: LD_INT 1
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 2
82130: NEG
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 2
82141: NEG
82142: PUSH
82143: LD_INT 1
82145: NEG
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 2
82153: NEG
82154: PUSH
82155: LD_INT 2
82157: NEG
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82184: LD_ADDR_VAR 0 58
82188: PUSH
82189: LD_INT 0
82191: PUSH
82192: LD_INT 0
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 0
82201: PUSH
82202: LD_INT 1
82204: NEG
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 1
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 1
82222: PUSH
82223: LD_INT 1
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 0
82232: PUSH
82233: LD_INT 1
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 1
82242: NEG
82243: PUSH
82244: LD_INT 0
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PUSH
82251: LD_INT 1
82253: NEG
82254: PUSH
82255: LD_INT 1
82257: NEG
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: LD_INT 2
82269: NEG
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 0
82277: PUSH
82278: LD_INT 2
82280: NEG
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 1
82288: PUSH
82289: LD_INT 1
82291: NEG
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 2
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 2
82309: PUSH
82310: LD_INT 1
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 2
82319: PUSH
82320: LD_INT 2
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 1
82329: PUSH
82330: LD_INT 2
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: LD_INT 2
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 1
82349: NEG
82350: PUSH
82351: LD_INT 1
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 2
82360: NEG
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 2
82371: NEG
82372: PUSH
82373: LD_INT 1
82375: NEG
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 2
82383: NEG
82384: PUSH
82385: LD_INT 2
82387: NEG
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: LIST
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82414: LD_ADDR_VAR 0 59
82418: PUSH
82419: LD_INT 0
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 0
82431: PUSH
82432: LD_INT 1
82434: NEG
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 1
82442: PUSH
82443: LD_INT 0
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 1
82452: PUSH
82453: LD_INT 1
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 0
82462: PUSH
82463: LD_INT 1
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: LD_INT 0
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 1
82483: NEG
82484: PUSH
82485: LD_INT 1
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82502: LD_ADDR_VAR 0 60
82506: PUSH
82507: LD_INT 0
82509: PUSH
82510: LD_INT 0
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PUSH
82517: LD_INT 0
82519: PUSH
82520: LD_INT 1
82522: NEG
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 1
82530: PUSH
82531: LD_INT 0
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: PUSH
82538: LD_INT 1
82540: PUSH
82541: LD_INT 1
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 0
82550: PUSH
82551: LD_INT 1
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 1
82560: NEG
82561: PUSH
82562: LD_INT 0
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 1
82571: NEG
82572: PUSH
82573: LD_INT 1
82575: NEG
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82590: LD_ADDR_VAR 0 61
82594: PUSH
82595: LD_INT 0
82597: PUSH
82598: LD_INT 0
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 0
82607: PUSH
82608: LD_INT 1
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 1
82618: PUSH
82619: LD_INT 0
82621: PUSH
82622: EMPTY
82623: LIST
82624: LIST
82625: PUSH
82626: LD_INT 1
82628: PUSH
82629: LD_INT 1
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PUSH
82636: LD_INT 0
82638: PUSH
82639: LD_INT 1
82641: PUSH
82642: EMPTY
82643: LIST
82644: LIST
82645: PUSH
82646: LD_INT 1
82648: NEG
82649: PUSH
82650: LD_INT 0
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 1
82659: NEG
82660: PUSH
82661: LD_INT 1
82663: NEG
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82678: LD_ADDR_VAR 0 62
82682: PUSH
82683: LD_INT 0
82685: PUSH
82686: LD_INT 0
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 0
82695: PUSH
82696: LD_INT 1
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 1
82706: PUSH
82707: LD_INT 0
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: PUSH
82717: LD_INT 1
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PUSH
82724: LD_INT 0
82726: PUSH
82727: LD_INT 1
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 1
82736: NEG
82737: PUSH
82738: LD_INT 0
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 1
82747: NEG
82748: PUSH
82749: LD_INT 1
82751: NEG
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82766: LD_ADDR_VAR 0 63
82770: PUSH
82771: LD_INT 0
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 0
82783: PUSH
82784: LD_INT 1
82786: NEG
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 1
82794: PUSH
82795: LD_INT 0
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 1
82804: PUSH
82805: LD_INT 1
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 0
82814: PUSH
82815: LD_INT 1
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 1
82824: NEG
82825: PUSH
82826: LD_INT 0
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 1
82835: NEG
82836: PUSH
82837: LD_INT 1
82839: NEG
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82854: LD_ADDR_VAR 0 64
82858: PUSH
82859: LD_INT 0
82861: PUSH
82862: LD_INT 0
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: LD_INT 1
82874: NEG
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 1
82882: PUSH
82883: LD_INT 0
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 1
82892: PUSH
82893: LD_INT 1
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 0
82902: PUSH
82903: LD_INT 1
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: PUSH
82910: LD_INT 1
82912: NEG
82913: PUSH
82914: LD_INT 0
82916: PUSH
82917: EMPTY
82918: LIST
82919: LIST
82920: PUSH
82921: LD_INT 1
82923: NEG
82924: PUSH
82925: LD_INT 1
82927: NEG
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: LIST
82937: LIST
82938: LIST
82939: LIST
82940: LIST
82941: ST_TO_ADDR
// end ; 1 :
82942: GO 88839
82944: LD_INT 1
82946: DOUBLE
82947: EQUAL
82948: IFTRUE 82952
82950: GO 85575
82952: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82953: LD_ADDR_VAR 0 11
82957: PUSH
82958: LD_INT 1
82960: NEG
82961: PUSH
82962: LD_INT 3
82964: NEG
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: LD_INT 0
82972: PUSH
82973: LD_INT 3
82975: NEG
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 1
82983: PUSH
82984: LD_INT 2
82986: NEG
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: LIST
82996: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82997: LD_ADDR_VAR 0 12
83001: PUSH
83002: LD_INT 2
83004: PUSH
83005: LD_INT 1
83007: NEG
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: PUSH
83013: LD_INT 3
83015: PUSH
83016: LD_INT 0
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: PUSH
83023: LD_INT 3
83025: PUSH
83026: LD_INT 1
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: LIST
83037: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
83038: LD_ADDR_VAR 0 13
83042: PUSH
83043: LD_INT 3
83045: PUSH
83046: LD_INT 2
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 3
83055: PUSH
83056: LD_INT 3
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 2
83065: PUSH
83066: LD_INT 3
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: LIST
83077: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83078: LD_ADDR_VAR 0 14
83082: PUSH
83083: LD_INT 1
83085: PUSH
83086: LD_INT 3
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: PUSH
83093: LD_INT 0
83095: PUSH
83096: LD_INT 3
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 1
83105: NEG
83106: PUSH
83107: LD_INT 2
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: LIST
83118: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83119: LD_ADDR_VAR 0 15
83123: PUSH
83124: LD_INT 2
83126: NEG
83127: PUSH
83128: LD_INT 1
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 3
83137: NEG
83138: PUSH
83139: LD_INT 0
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 3
83148: NEG
83149: PUSH
83150: LD_INT 1
83152: NEG
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: LIST
83162: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83163: LD_ADDR_VAR 0 16
83167: PUSH
83168: LD_INT 2
83170: NEG
83171: PUSH
83172: LD_INT 3
83174: NEG
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 3
83182: NEG
83183: PUSH
83184: LD_INT 2
83186: NEG
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 3
83194: NEG
83195: PUSH
83196: LD_INT 3
83198: NEG
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: LIST
83208: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
83209: LD_ADDR_VAR 0 17
83213: PUSH
83214: LD_INT 1
83216: NEG
83217: PUSH
83218: LD_INT 3
83220: NEG
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 0
83228: PUSH
83229: LD_INT 3
83231: NEG
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 1
83239: PUSH
83240: LD_INT 2
83242: NEG
83243: PUSH
83244: EMPTY
83245: LIST
83246: LIST
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: LIST
83252: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
83253: LD_ADDR_VAR 0 18
83257: PUSH
83258: LD_INT 2
83260: PUSH
83261: LD_INT 1
83263: NEG
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: PUSH
83269: LD_INT 3
83271: PUSH
83272: LD_INT 0
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: PUSH
83279: LD_INT 3
83281: PUSH
83282: LD_INT 1
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: LIST
83293: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
83294: LD_ADDR_VAR 0 19
83298: PUSH
83299: LD_INT 3
83301: PUSH
83302: LD_INT 2
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 3
83311: PUSH
83312: LD_INT 3
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 2
83321: PUSH
83322: LD_INT 3
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: LIST
83333: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83334: LD_ADDR_VAR 0 20
83338: PUSH
83339: LD_INT 1
83341: PUSH
83342: LD_INT 3
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 0
83351: PUSH
83352: LD_INT 3
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PUSH
83359: LD_INT 1
83361: NEG
83362: PUSH
83363: LD_INT 2
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: LIST
83374: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83375: LD_ADDR_VAR 0 21
83379: PUSH
83380: LD_INT 2
83382: NEG
83383: PUSH
83384: LD_INT 1
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: PUSH
83391: LD_INT 3
83393: NEG
83394: PUSH
83395: LD_INT 0
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 3
83404: NEG
83405: PUSH
83406: LD_INT 1
83408: NEG
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: LIST
83418: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83419: LD_ADDR_VAR 0 22
83423: PUSH
83424: LD_INT 2
83426: NEG
83427: PUSH
83428: LD_INT 3
83430: NEG
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 3
83438: NEG
83439: PUSH
83440: LD_INT 2
83442: NEG
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 3
83450: NEG
83451: PUSH
83452: LD_INT 3
83454: NEG
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: LIST
83464: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
83465: LD_ADDR_VAR 0 23
83469: PUSH
83470: LD_INT 0
83472: PUSH
83473: LD_INT 3
83475: NEG
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: PUSH
83481: LD_INT 1
83483: NEG
83484: PUSH
83485: LD_INT 4
83487: NEG
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: PUSH
83493: LD_INT 1
83495: PUSH
83496: LD_INT 3
83498: NEG
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: LIST
83508: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
83509: LD_ADDR_VAR 0 24
83513: PUSH
83514: LD_INT 3
83516: PUSH
83517: LD_INT 0
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: LD_INT 3
83526: PUSH
83527: LD_INT 1
83529: NEG
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 4
83537: PUSH
83538: LD_INT 1
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: LIST
83549: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
83550: LD_ADDR_VAR 0 25
83554: PUSH
83555: LD_INT 3
83557: PUSH
83558: LD_INT 3
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PUSH
83565: LD_INT 4
83567: PUSH
83568: LD_INT 3
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: PUSH
83575: LD_INT 3
83577: PUSH
83578: LD_INT 4
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: LIST
83589: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
83590: LD_ADDR_VAR 0 26
83594: PUSH
83595: LD_INT 0
83597: PUSH
83598: LD_INT 3
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 1
83607: PUSH
83608: LD_INT 4
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: NEG
83618: PUSH
83619: LD_INT 3
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: LIST
83630: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
83631: LD_ADDR_VAR 0 27
83635: PUSH
83636: LD_INT 3
83638: NEG
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 3
83649: NEG
83650: PUSH
83651: LD_INT 1
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: LD_INT 4
83660: NEG
83661: PUSH
83662: LD_INT 1
83664: NEG
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: EMPTY
83671: LIST
83672: LIST
83673: LIST
83674: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
83675: LD_ADDR_VAR 0 28
83679: PUSH
83680: LD_INT 3
83682: NEG
83683: PUSH
83684: LD_INT 3
83686: NEG
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 3
83694: NEG
83695: PUSH
83696: LD_INT 4
83698: NEG
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 4
83706: NEG
83707: PUSH
83708: LD_INT 3
83710: NEG
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: LIST
83720: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
83721: LD_ADDR_VAR 0 29
83725: PUSH
83726: LD_INT 1
83728: NEG
83729: PUSH
83730: LD_INT 3
83732: NEG
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: PUSH
83738: LD_INT 0
83740: PUSH
83741: LD_INT 3
83743: NEG
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: LD_INT 2
83754: NEG
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 1
83762: NEG
83763: PUSH
83764: LD_INT 4
83766: NEG
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 0
83774: PUSH
83775: LD_INT 4
83777: NEG
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 1
83785: PUSH
83786: LD_INT 3
83788: NEG
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 1
83796: NEG
83797: PUSH
83798: LD_INT 5
83800: NEG
83801: PUSH
83802: EMPTY
83803: LIST
83804: LIST
83805: PUSH
83806: LD_INT 0
83808: PUSH
83809: LD_INT 5
83811: NEG
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: LD_INT 1
83819: PUSH
83820: LD_INT 4
83822: NEG
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: PUSH
83828: LD_INT 1
83830: NEG
83831: PUSH
83832: LD_INT 6
83834: NEG
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 0
83842: PUSH
83843: LD_INT 6
83845: NEG
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: LD_INT 1
83853: PUSH
83854: LD_INT 5
83856: NEG
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: LIST
83866: LIST
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: LIST
83874: LIST
83875: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
83876: LD_ADDR_VAR 0 30
83880: PUSH
83881: LD_INT 2
83883: PUSH
83884: LD_INT 1
83886: NEG
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 3
83894: PUSH
83895: LD_INT 0
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PUSH
83902: LD_INT 3
83904: PUSH
83905: LD_INT 1
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 3
83914: PUSH
83915: LD_INT 1
83917: NEG
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: LD_INT 4
83925: PUSH
83926: LD_INT 0
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 4
83935: PUSH
83936: LD_INT 1
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 4
83945: PUSH
83946: LD_INT 1
83948: NEG
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 5
83956: PUSH
83957: LD_INT 0
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: PUSH
83964: LD_INT 5
83966: PUSH
83967: LD_INT 1
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 5
83976: PUSH
83977: LD_INT 1
83979: NEG
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 6
83987: PUSH
83988: LD_INT 0
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 6
83997: PUSH
83998: LD_INT 1
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
84019: LD_ADDR_VAR 0 31
84023: PUSH
84024: LD_INT 3
84026: PUSH
84027: LD_INT 2
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 3
84036: PUSH
84037: LD_INT 3
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PUSH
84044: LD_INT 2
84046: PUSH
84047: LD_INT 3
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 4
84056: PUSH
84057: LD_INT 3
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: LD_INT 4
84066: PUSH
84067: LD_INT 4
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: PUSH
84074: LD_INT 3
84076: PUSH
84077: LD_INT 4
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: LD_INT 5
84086: PUSH
84087: LD_INT 4
84089: PUSH
84090: EMPTY
84091: LIST
84092: LIST
84093: PUSH
84094: LD_INT 5
84096: PUSH
84097: LD_INT 5
84099: PUSH
84100: EMPTY
84101: LIST
84102: LIST
84103: PUSH
84104: LD_INT 4
84106: PUSH
84107: LD_INT 5
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 6
84116: PUSH
84117: LD_INT 5
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: LD_INT 6
84126: PUSH
84127: LD_INT 6
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PUSH
84134: LD_INT 5
84136: PUSH
84137: LD_INT 6
84139: PUSH
84140: EMPTY
84141: LIST
84142: LIST
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
84158: LD_ADDR_VAR 0 32
84162: PUSH
84163: LD_INT 1
84165: PUSH
84166: LD_INT 3
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 0
84175: PUSH
84176: LD_INT 3
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 1
84185: NEG
84186: PUSH
84187: LD_INT 2
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 1
84196: PUSH
84197: LD_INT 4
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 0
84206: PUSH
84207: LD_INT 4
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: PUSH
84214: LD_INT 1
84216: NEG
84217: PUSH
84218: LD_INT 3
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 1
84227: PUSH
84228: LD_INT 5
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 0
84237: PUSH
84238: LD_INT 5
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 1
84247: NEG
84248: PUSH
84249: LD_INT 4
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PUSH
84256: LD_INT 1
84258: PUSH
84259: LD_INT 6
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 0
84268: PUSH
84269: LD_INT 6
84271: PUSH
84272: EMPTY
84273: LIST
84274: LIST
84275: PUSH
84276: LD_INT 1
84278: NEG
84279: PUSH
84280: LD_INT 5
84282: PUSH
84283: EMPTY
84284: LIST
84285: LIST
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
84301: LD_ADDR_VAR 0 33
84305: PUSH
84306: LD_INT 2
84308: NEG
84309: PUSH
84310: LD_INT 1
84312: PUSH
84313: EMPTY
84314: LIST
84315: LIST
84316: PUSH
84317: LD_INT 3
84319: NEG
84320: PUSH
84321: LD_INT 0
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 3
84330: NEG
84331: PUSH
84332: LD_INT 1
84334: NEG
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 3
84342: NEG
84343: PUSH
84344: LD_INT 1
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 4
84353: NEG
84354: PUSH
84355: LD_INT 0
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 4
84364: NEG
84365: PUSH
84366: LD_INT 1
84368: NEG
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PUSH
84374: LD_INT 4
84376: NEG
84377: PUSH
84378: LD_INT 1
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PUSH
84385: LD_INT 5
84387: NEG
84388: PUSH
84389: LD_INT 0
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: LD_INT 5
84398: NEG
84399: PUSH
84400: LD_INT 1
84402: NEG
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 5
84410: NEG
84411: PUSH
84412: LD_INT 1
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 6
84421: NEG
84422: PUSH
84423: LD_INT 0
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 6
84432: NEG
84433: PUSH
84434: LD_INT 1
84436: NEG
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: LIST
84455: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
84456: LD_ADDR_VAR 0 34
84460: PUSH
84461: LD_INT 2
84463: NEG
84464: PUSH
84465: LD_INT 3
84467: NEG
84468: PUSH
84469: EMPTY
84470: LIST
84471: LIST
84472: PUSH
84473: LD_INT 3
84475: NEG
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 3
84487: NEG
84488: PUSH
84489: LD_INT 3
84491: NEG
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 3
84499: NEG
84500: PUSH
84501: LD_INT 4
84503: NEG
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: PUSH
84509: LD_INT 4
84511: NEG
84512: PUSH
84513: LD_INT 3
84515: NEG
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 4
84523: NEG
84524: PUSH
84525: LD_INT 4
84527: NEG
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 4
84535: NEG
84536: PUSH
84537: LD_INT 5
84539: NEG
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 5
84547: NEG
84548: PUSH
84549: LD_INT 4
84551: NEG
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: PUSH
84557: LD_INT 5
84559: NEG
84560: PUSH
84561: LD_INT 5
84563: NEG
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 5
84571: NEG
84572: PUSH
84573: LD_INT 6
84575: NEG
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 6
84583: NEG
84584: PUSH
84585: LD_INT 5
84587: NEG
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 6
84595: NEG
84596: PUSH
84597: LD_INT 6
84599: NEG
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: EMPTY
84606: LIST
84607: LIST
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
84619: LD_ADDR_VAR 0 41
84623: PUSH
84624: LD_INT 0
84626: PUSH
84627: LD_INT 2
84629: NEG
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PUSH
84635: LD_INT 1
84637: NEG
84638: PUSH
84639: LD_INT 3
84641: NEG
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: LD_INT 2
84652: NEG
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: LIST
84662: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
84663: LD_ADDR_VAR 0 42
84667: PUSH
84668: LD_INT 2
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 2
84680: PUSH
84681: LD_INT 1
84683: NEG
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 3
84691: PUSH
84692: LD_INT 1
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: LIST
84703: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
84704: LD_ADDR_VAR 0 43
84708: PUSH
84709: LD_INT 2
84711: PUSH
84712: LD_INT 2
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 3
84721: PUSH
84722: LD_INT 2
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: PUSH
84729: LD_INT 2
84731: PUSH
84732: LD_INT 3
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: LIST
84743: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
84744: LD_ADDR_VAR 0 44
84748: PUSH
84749: LD_INT 0
84751: PUSH
84752: LD_INT 2
84754: PUSH
84755: EMPTY
84756: LIST
84757: LIST
84758: PUSH
84759: LD_INT 1
84761: PUSH
84762: LD_INT 3
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PUSH
84769: LD_INT 1
84771: NEG
84772: PUSH
84773: LD_INT 2
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: LIST
84784: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84785: LD_ADDR_VAR 0 45
84789: PUSH
84790: LD_INT 2
84792: NEG
84793: PUSH
84794: LD_INT 0
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PUSH
84801: LD_INT 2
84803: NEG
84804: PUSH
84805: LD_INT 1
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: PUSH
84812: LD_INT 3
84814: NEG
84815: PUSH
84816: LD_INT 1
84818: NEG
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: LIST
84828: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
84829: LD_ADDR_VAR 0 46
84833: PUSH
84834: LD_INT 2
84836: NEG
84837: PUSH
84838: LD_INT 2
84840: NEG
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 2
84848: NEG
84849: PUSH
84850: LD_INT 3
84852: NEG
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 3
84860: NEG
84861: PUSH
84862: LD_INT 2
84864: NEG
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: LIST
84874: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
84875: LD_ADDR_VAR 0 47
84879: PUSH
84880: LD_INT 2
84882: NEG
84883: PUSH
84884: LD_INT 3
84886: NEG
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 1
84894: NEG
84895: PUSH
84896: LD_INT 3
84898: NEG
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84908: LD_ADDR_VAR 0 48
84912: PUSH
84913: LD_INT 1
84915: PUSH
84916: LD_INT 2
84918: NEG
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PUSH
84924: LD_INT 2
84926: PUSH
84927: LD_INT 1
84929: NEG
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
84939: LD_ADDR_VAR 0 49
84943: PUSH
84944: LD_INT 3
84946: PUSH
84947: LD_INT 1
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 3
84956: PUSH
84957: LD_INT 2
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: EMPTY
84965: LIST
84966: LIST
84967: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
84968: LD_ADDR_VAR 0 50
84972: PUSH
84973: LD_INT 2
84975: PUSH
84976: LD_INT 3
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 1
84985: PUSH
84986: LD_INT 3
84988: PUSH
84989: EMPTY
84990: LIST
84991: LIST
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
84997: LD_ADDR_VAR 0 51
85001: PUSH
85002: LD_INT 1
85004: NEG
85005: PUSH
85006: LD_INT 2
85008: PUSH
85009: EMPTY
85010: LIST
85011: LIST
85012: PUSH
85013: LD_INT 2
85015: NEG
85016: PUSH
85017: LD_INT 1
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85028: LD_ADDR_VAR 0 52
85032: PUSH
85033: LD_INT 3
85035: NEG
85036: PUSH
85037: LD_INT 1
85039: NEG
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: LD_INT 3
85047: NEG
85048: PUSH
85049: LD_INT 2
85051: NEG
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85061: LD_ADDR_VAR 0 53
85065: PUSH
85066: LD_INT 1
85068: NEG
85069: PUSH
85070: LD_INT 3
85072: NEG
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 0
85080: PUSH
85081: LD_INT 3
85083: NEG
85084: PUSH
85085: EMPTY
85086: LIST
85087: LIST
85088: PUSH
85089: LD_INT 1
85091: PUSH
85092: LD_INT 2
85094: NEG
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: LIST
85104: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85105: LD_ADDR_VAR 0 54
85109: PUSH
85110: LD_INT 2
85112: PUSH
85113: LD_INT 1
85115: NEG
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 3
85123: PUSH
85124: LD_INT 0
85126: PUSH
85127: EMPTY
85128: LIST
85129: LIST
85130: PUSH
85131: LD_INT 3
85133: PUSH
85134: LD_INT 1
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: LIST
85145: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85146: LD_ADDR_VAR 0 55
85150: PUSH
85151: LD_INT 3
85153: PUSH
85154: LD_INT 2
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 3
85163: PUSH
85164: LD_INT 3
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 2
85173: PUSH
85174: LD_INT 3
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: LIST
85185: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85186: LD_ADDR_VAR 0 56
85190: PUSH
85191: LD_INT 1
85193: PUSH
85194: LD_INT 3
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 0
85203: PUSH
85204: LD_INT 3
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 1
85213: NEG
85214: PUSH
85215: LD_INT 2
85217: PUSH
85218: EMPTY
85219: LIST
85220: LIST
85221: PUSH
85222: EMPTY
85223: LIST
85224: LIST
85225: LIST
85226: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85227: LD_ADDR_VAR 0 57
85231: PUSH
85232: LD_INT 2
85234: NEG
85235: PUSH
85236: LD_INT 1
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 3
85245: NEG
85246: PUSH
85247: LD_INT 0
85249: PUSH
85250: EMPTY
85251: LIST
85252: LIST
85253: PUSH
85254: LD_INT 3
85256: NEG
85257: PUSH
85258: LD_INT 1
85260: NEG
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: LIST
85270: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85271: LD_ADDR_VAR 0 58
85275: PUSH
85276: LD_INT 2
85278: NEG
85279: PUSH
85280: LD_INT 3
85282: NEG
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 3
85290: NEG
85291: PUSH
85292: LD_INT 2
85294: NEG
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 3
85302: NEG
85303: PUSH
85304: LD_INT 3
85306: NEG
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: LIST
85316: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
85317: LD_ADDR_VAR 0 59
85321: PUSH
85322: LD_INT 1
85324: NEG
85325: PUSH
85326: LD_INT 2
85328: NEG
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 0
85336: PUSH
85337: LD_INT 2
85339: NEG
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: LD_INT 1
85347: PUSH
85348: LD_INT 1
85350: NEG
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: LIST
85360: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
85361: LD_ADDR_VAR 0 60
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: LD_INT 1
85371: NEG
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 2
85379: PUSH
85380: LD_INT 0
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: PUSH
85387: LD_INT 2
85389: PUSH
85390: LD_INT 1
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: LIST
85401: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
85402: LD_ADDR_VAR 0 61
85406: PUSH
85407: LD_INT 2
85409: PUSH
85410: LD_INT 1
85412: PUSH
85413: EMPTY
85414: LIST
85415: LIST
85416: PUSH
85417: LD_INT 2
85419: PUSH
85420: LD_INT 2
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PUSH
85427: LD_INT 1
85429: PUSH
85430: LD_INT 2
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: LIST
85441: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
85442: LD_ADDR_VAR 0 62
85446: PUSH
85447: LD_INT 1
85449: PUSH
85450: LD_INT 2
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 0
85459: PUSH
85460: LD_INT 2
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: LD_INT 1
85469: NEG
85470: PUSH
85471: LD_INT 1
85473: PUSH
85474: EMPTY
85475: LIST
85476: LIST
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: LIST
85482: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
85483: LD_ADDR_VAR 0 63
85487: PUSH
85488: LD_INT 1
85490: NEG
85491: PUSH
85492: LD_INT 1
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: PUSH
85499: LD_INT 2
85501: NEG
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 2
85512: NEG
85513: PUSH
85514: LD_INT 1
85516: NEG
85517: PUSH
85518: EMPTY
85519: LIST
85520: LIST
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: LIST
85526: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85527: LD_ADDR_VAR 0 64
85531: PUSH
85532: LD_INT 1
85534: NEG
85535: PUSH
85536: LD_INT 2
85538: NEG
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: PUSH
85544: LD_INT 2
85546: NEG
85547: PUSH
85548: LD_INT 1
85550: NEG
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 2
85558: NEG
85559: PUSH
85560: LD_INT 2
85562: NEG
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: LIST
85572: ST_TO_ADDR
// end ; 2 :
85573: GO 88839
85575: LD_INT 2
85577: DOUBLE
85578: EQUAL
85579: IFTRUE 85583
85581: GO 88838
85583: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
85584: LD_ADDR_VAR 0 29
85588: PUSH
85589: LD_INT 4
85591: PUSH
85592: LD_INT 0
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 4
85601: PUSH
85602: LD_INT 1
85604: NEG
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: LD_INT 5
85612: PUSH
85613: LD_INT 0
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 5
85622: PUSH
85623: LD_INT 1
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PUSH
85630: LD_INT 4
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 3
85642: PUSH
85643: LD_INT 0
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 3
85652: PUSH
85653: LD_INT 1
85655: NEG
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PUSH
85661: LD_INT 3
85663: PUSH
85664: LD_INT 2
85666: NEG
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 5
85674: PUSH
85675: LD_INT 2
85677: PUSH
85678: EMPTY
85679: LIST
85680: LIST
85681: PUSH
85682: LD_INT 3
85684: PUSH
85685: LD_INT 3
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: PUSH
85692: LD_INT 3
85694: PUSH
85695: LD_INT 2
85697: PUSH
85698: EMPTY
85699: LIST
85700: LIST
85701: PUSH
85702: LD_INT 4
85704: PUSH
85705: LD_INT 3
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 4
85714: PUSH
85715: LD_INT 4
85717: PUSH
85718: EMPTY
85719: LIST
85720: LIST
85721: PUSH
85722: LD_INT 3
85724: PUSH
85725: LD_INT 4
85727: PUSH
85728: EMPTY
85729: LIST
85730: LIST
85731: PUSH
85732: LD_INT 2
85734: PUSH
85735: LD_INT 3
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: LD_INT 2
85744: PUSH
85745: LD_INT 2
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: PUSH
85752: LD_INT 4
85754: PUSH
85755: LD_INT 2
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 2
85764: PUSH
85765: LD_INT 4
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 0
85774: PUSH
85775: LD_INT 4
85777: PUSH
85778: EMPTY
85779: LIST
85780: LIST
85781: PUSH
85782: LD_INT 0
85784: PUSH
85785: LD_INT 3
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 1
85794: PUSH
85795: LD_INT 4
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 1
85804: PUSH
85805: LD_INT 5
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 0
85814: PUSH
85815: LD_INT 5
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: NEG
85825: PUSH
85826: LD_INT 4
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 1
85835: NEG
85836: PUSH
85837: LD_INT 3
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 2
85846: PUSH
85847: LD_INT 5
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 2
85856: NEG
85857: PUSH
85858: LD_INT 3
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 3
85867: NEG
85868: PUSH
85869: LD_INT 0
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: PUSH
85876: LD_INT 3
85878: NEG
85879: PUSH
85880: LD_INT 1
85882: NEG
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 2
85890: NEG
85891: PUSH
85892: LD_INT 0
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 2
85901: NEG
85902: PUSH
85903: LD_INT 1
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 3
85912: NEG
85913: PUSH
85914: LD_INT 1
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: LD_INT 4
85923: NEG
85924: PUSH
85925: LD_INT 0
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 4
85934: NEG
85935: PUSH
85936: LD_INT 1
85938: NEG
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 4
85946: NEG
85947: PUSH
85948: LD_INT 2
85950: NEG
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 2
85958: NEG
85959: PUSH
85960: LD_INT 2
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 4
85969: NEG
85970: PUSH
85971: LD_INT 4
85973: NEG
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: LD_INT 4
85981: NEG
85982: PUSH
85983: LD_INT 5
85985: NEG
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 3
85993: NEG
85994: PUSH
85995: LD_INT 4
85997: NEG
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 3
86005: NEG
86006: PUSH
86007: LD_INT 3
86009: NEG
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 4
86017: NEG
86018: PUSH
86019: LD_INT 3
86021: NEG
86022: PUSH
86023: EMPTY
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 5
86029: NEG
86030: PUSH
86031: LD_INT 4
86033: NEG
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 5
86041: NEG
86042: PUSH
86043: LD_INT 5
86045: NEG
86046: PUSH
86047: EMPTY
86048: LIST
86049: LIST
86050: PUSH
86051: LD_INT 3
86053: NEG
86054: PUSH
86055: LD_INT 5
86057: NEG
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 5
86065: NEG
86066: PUSH
86067: LD_INT 3
86069: NEG
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: LIST
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
86122: LD_ADDR_VAR 0 30
86126: PUSH
86127: LD_INT 4
86129: PUSH
86130: LD_INT 4
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 4
86139: PUSH
86140: LD_INT 3
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 5
86149: PUSH
86150: LD_INT 4
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 5
86159: PUSH
86160: LD_INT 5
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 4
86169: PUSH
86170: LD_INT 5
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 3
86179: PUSH
86180: LD_INT 4
86182: PUSH
86183: EMPTY
86184: LIST
86185: LIST
86186: PUSH
86187: LD_INT 3
86189: PUSH
86190: LD_INT 3
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 5
86199: PUSH
86200: LD_INT 3
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 3
86209: PUSH
86210: LD_INT 5
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 0
86219: PUSH
86220: LD_INT 3
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: PUSH
86227: LD_INT 0
86229: PUSH
86230: LD_INT 2
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: PUSH
86237: LD_INT 1
86239: PUSH
86240: LD_INT 3
86242: PUSH
86243: EMPTY
86244: LIST
86245: LIST
86246: PUSH
86247: LD_INT 1
86249: PUSH
86250: LD_INT 4
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 0
86259: PUSH
86260: LD_INT 4
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: PUSH
86267: LD_INT 1
86269: NEG
86270: PUSH
86271: LD_INT 3
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 1
86280: NEG
86281: PUSH
86282: LD_INT 2
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 2
86291: PUSH
86292: LD_INT 4
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 2
86301: NEG
86302: PUSH
86303: LD_INT 2
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PUSH
86310: LD_INT 4
86312: NEG
86313: PUSH
86314: LD_INT 0
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 4
86323: NEG
86324: PUSH
86325: LD_INT 1
86327: NEG
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 3
86335: NEG
86336: PUSH
86337: LD_INT 0
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 3
86346: NEG
86347: PUSH
86348: LD_INT 1
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 4
86357: NEG
86358: PUSH
86359: LD_INT 1
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: PUSH
86366: LD_INT 5
86368: NEG
86369: PUSH
86370: LD_INT 0
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 5
86379: NEG
86380: PUSH
86381: LD_INT 1
86383: NEG
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: LD_INT 5
86391: NEG
86392: PUSH
86393: LD_INT 2
86395: NEG
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 3
86403: NEG
86404: PUSH
86405: LD_INT 2
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: LD_INT 3
86414: NEG
86415: PUSH
86416: LD_INT 3
86418: NEG
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 3
86426: NEG
86427: PUSH
86428: LD_INT 4
86430: NEG
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 2
86438: NEG
86439: PUSH
86440: LD_INT 3
86442: NEG
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PUSH
86448: LD_INT 2
86450: NEG
86451: PUSH
86452: LD_INT 2
86454: NEG
86455: PUSH
86456: EMPTY
86457: LIST
86458: LIST
86459: PUSH
86460: LD_INT 3
86462: NEG
86463: PUSH
86464: LD_INT 2
86466: NEG
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PUSH
86472: LD_INT 4
86474: NEG
86475: PUSH
86476: LD_INT 3
86478: NEG
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 4
86486: NEG
86487: PUSH
86488: LD_INT 4
86490: NEG
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: PUSH
86496: LD_INT 2
86498: NEG
86499: PUSH
86500: LD_INT 4
86502: NEG
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 4
86510: NEG
86511: PUSH
86512: LD_INT 2
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 0
86522: PUSH
86523: LD_INT 4
86525: NEG
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 0
86533: PUSH
86534: LD_INT 5
86536: NEG
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 1
86544: PUSH
86545: LD_INT 4
86547: NEG
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 1
86555: PUSH
86556: LD_INT 3
86558: NEG
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 0
86566: PUSH
86567: LD_INT 3
86569: NEG
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 1
86577: NEG
86578: PUSH
86579: LD_INT 4
86581: NEG
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 1
86589: NEG
86590: PUSH
86591: LD_INT 5
86593: NEG
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 2
86601: PUSH
86602: LD_INT 3
86604: NEG
86605: PUSH
86606: EMPTY
86607: LIST
86608: LIST
86609: PUSH
86610: LD_INT 2
86612: NEG
86613: PUSH
86614: LD_INT 5
86616: NEG
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: LIST
86626: LIST
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
86669: LD_ADDR_VAR 0 31
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: LD_INT 4
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: PUSH
86684: LD_INT 0
86686: PUSH
86687: LD_INT 3
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 1
86696: PUSH
86697: LD_INT 4
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: LD_INT 1
86706: PUSH
86707: LD_INT 5
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: PUSH
86714: LD_INT 0
86716: PUSH
86717: LD_INT 5
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 1
86726: NEG
86727: PUSH
86728: LD_INT 4
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 1
86737: NEG
86738: PUSH
86739: LD_INT 3
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 2
86748: PUSH
86749: LD_INT 5
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 2
86758: NEG
86759: PUSH
86760: LD_INT 3
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 3
86769: NEG
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 3
86780: NEG
86781: PUSH
86782: LD_INT 1
86784: NEG
86785: PUSH
86786: EMPTY
86787: LIST
86788: LIST
86789: PUSH
86790: LD_INT 2
86792: NEG
86793: PUSH
86794: LD_INT 0
86796: PUSH
86797: EMPTY
86798: LIST
86799: LIST
86800: PUSH
86801: LD_INT 2
86803: NEG
86804: PUSH
86805: LD_INT 1
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 3
86814: NEG
86815: PUSH
86816: LD_INT 1
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 4
86825: NEG
86826: PUSH
86827: LD_INT 0
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PUSH
86834: LD_INT 4
86836: NEG
86837: PUSH
86838: LD_INT 1
86840: NEG
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 4
86848: NEG
86849: PUSH
86850: LD_INT 2
86852: NEG
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 2
86860: NEG
86861: PUSH
86862: LD_INT 2
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 4
86871: NEG
86872: PUSH
86873: LD_INT 4
86875: NEG
86876: PUSH
86877: EMPTY
86878: LIST
86879: LIST
86880: PUSH
86881: LD_INT 4
86883: NEG
86884: PUSH
86885: LD_INT 5
86887: NEG
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: LD_INT 3
86895: NEG
86896: PUSH
86897: LD_INT 4
86899: NEG
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: PUSH
86905: LD_INT 3
86907: NEG
86908: PUSH
86909: LD_INT 3
86911: NEG
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: PUSH
86917: LD_INT 4
86919: NEG
86920: PUSH
86921: LD_INT 3
86923: NEG
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 5
86931: NEG
86932: PUSH
86933: LD_INT 4
86935: NEG
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 5
86943: NEG
86944: PUSH
86945: LD_INT 5
86947: NEG
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 3
86955: NEG
86956: PUSH
86957: LD_INT 5
86959: NEG
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 5
86967: NEG
86968: PUSH
86969: LD_INT 3
86971: NEG
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 0
86979: PUSH
86980: LD_INT 3
86982: NEG
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: LD_INT 0
86990: PUSH
86991: LD_INT 4
86993: NEG
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 1
87001: PUSH
87002: LD_INT 3
87004: NEG
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: PUSH
87010: LD_INT 1
87012: PUSH
87013: LD_INT 2
87015: NEG
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 0
87023: PUSH
87024: LD_INT 2
87026: NEG
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: PUSH
87032: LD_INT 1
87034: NEG
87035: PUSH
87036: LD_INT 3
87038: NEG
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 1
87046: NEG
87047: PUSH
87048: LD_INT 4
87050: NEG
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 2
87058: PUSH
87059: LD_INT 2
87061: NEG
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 2
87069: NEG
87070: PUSH
87071: LD_INT 4
87073: NEG
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: LD_INT 4
87081: PUSH
87082: LD_INT 0
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PUSH
87089: LD_INT 4
87091: PUSH
87092: LD_INT 1
87094: NEG
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 5
87102: PUSH
87103: LD_INT 0
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 5
87112: PUSH
87113: LD_INT 1
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 4
87122: PUSH
87123: LD_INT 1
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 3
87132: PUSH
87133: LD_INT 0
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 3
87142: PUSH
87143: LD_INT 1
87145: NEG
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 3
87153: PUSH
87154: LD_INT 2
87156: NEG
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 5
87164: PUSH
87165: LD_INT 2
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: EMPTY
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
87219: LD_ADDR_VAR 0 32
87223: PUSH
87224: LD_INT 4
87226: NEG
87227: PUSH
87228: LD_INT 0
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: LD_INT 4
87237: NEG
87238: PUSH
87239: LD_INT 1
87241: NEG
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: PUSH
87247: LD_INT 3
87249: NEG
87250: PUSH
87251: LD_INT 0
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: PUSH
87258: LD_INT 3
87260: NEG
87261: PUSH
87262: LD_INT 1
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 4
87271: NEG
87272: PUSH
87273: LD_INT 1
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 5
87282: NEG
87283: PUSH
87284: LD_INT 0
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 5
87293: NEG
87294: PUSH
87295: LD_INT 1
87297: NEG
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: PUSH
87303: LD_INT 5
87305: NEG
87306: PUSH
87307: LD_INT 2
87309: NEG
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 3
87317: NEG
87318: PUSH
87319: LD_INT 2
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 3
87328: NEG
87329: PUSH
87330: LD_INT 3
87332: NEG
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: LD_INT 3
87340: NEG
87341: PUSH
87342: LD_INT 4
87344: NEG
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 2
87352: NEG
87353: PUSH
87354: LD_INT 3
87356: NEG
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 2
87364: NEG
87365: PUSH
87366: LD_INT 2
87368: NEG
87369: PUSH
87370: EMPTY
87371: LIST
87372: LIST
87373: PUSH
87374: LD_INT 3
87376: NEG
87377: PUSH
87378: LD_INT 2
87380: NEG
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 4
87388: NEG
87389: PUSH
87390: LD_INT 3
87392: NEG
87393: PUSH
87394: EMPTY
87395: LIST
87396: LIST
87397: PUSH
87398: LD_INT 4
87400: NEG
87401: PUSH
87402: LD_INT 4
87404: NEG
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: LD_INT 2
87412: NEG
87413: PUSH
87414: LD_INT 4
87416: NEG
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 4
87424: NEG
87425: PUSH
87426: LD_INT 2
87428: NEG
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: PUSH
87434: LD_INT 0
87436: PUSH
87437: LD_INT 4
87439: NEG
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: LD_INT 0
87447: PUSH
87448: LD_INT 5
87450: NEG
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 1
87458: PUSH
87459: LD_INT 4
87461: NEG
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 1
87469: PUSH
87470: LD_INT 3
87472: NEG
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 0
87480: PUSH
87481: LD_INT 3
87483: NEG
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: LD_INT 1
87491: NEG
87492: PUSH
87493: LD_INT 4
87495: NEG
87496: PUSH
87497: EMPTY
87498: LIST
87499: LIST
87500: PUSH
87501: LD_INT 1
87503: NEG
87504: PUSH
87505: LD_INT 5
87507: NEG
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 2
87515: PUSH
87516: LD_INT 3
87518: NEG
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 2
87526: NEG
87527: PUSH
87528: LD_INT 5
87530: NEG
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: PUSH
87536: LD_INT 3
87538: PUSH
87539: LD_INT 0
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 3
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 4
87559: PUSH
87560: LD_INT 0
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 4
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 3
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: LD_INT 2
87589: PUSH
87590: LD_INT 0
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: LD_INT 2
87599: PUSH
87600: LD_INT 1
87602: NEG
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: PUSH
87608: LD_INT 2
87610: PUSH
87611: LD_INT 2
87613: NEG
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 4
87621: PUSH
87622: LD_INT 2
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: PUSH
87629: LD_INT 4
87631: PUSH
87632: LD_INT 4
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 4
87641: PUSH
87642: LD_INT 3
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 5
87651: PUSH
87652: LD_INT 4
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 5
87661: PUSH
87662: LD_INT 5
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 4
87671: PUSH
87672: LD_INT 5
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 3
87681: PUSH
87682: LD_INT 4
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 3
87691: PUSH
87692: LD_INT 3
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 5
87701: PUSH
87702: LD_INT 3
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 3
87711: PUSH
87712: LD_INT 5
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
87766: LD_ADDR_VAR 0 33
87770: PUSH
87771: LD_INT 4
87773: NEG
87774: PUSH
87775: LD_INT 4
87777: NEG
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PUSH
87783: LD_INT 4
87785: NEG
87786: PUSH
87787: LD_INT 5
87789: NEG
87790: PUSH
87791: EMPTY
87792: LIST
87793: LIST
87794: PUSH
87795: LD_INT 3
87797: NEG
87798: PUSH
87799: LD_INT 4
87801: NEG
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 3
87809: NEG
87810: PUSH
87811: LD_INT 3
87813: NEG
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: LD_INT 4
87821: NEG
87822: PUSH
87823: LD_INT 3
87825: NEG
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: LD_INT 5
87833: NEG
87834: PUSH
87835: LD_INT 4
87837: NEG
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 5
87845: NEG
87846: PUSH
87847: LD_INT 5
87849: NEG
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 3
87857: NEG
87858: PUSH
87859: LD_INT 5
87861: NEG
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 5
87869: NEG
87870: PUSH
87871: LD_INT 3
87873: NEG
87874: PUSH
87875: EMPTY
87876: LIST
87877: LIST
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: LD_INT 3
87884: NEG
87885: PUSH
87886: EMPTY
87887: LIST
87888: LIST
87889: PUSH
87890: LD_INT 0
87892: PUSH
87893: LD_INT 4
87895: NEG
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: LD_INT 1
87903: PUSH
87904: LD_INT 3
87906: NEG
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 1
87914: PUSH
87915: LD_INT 2
87917: NEG
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 0
87925: PUSH
87926: LD_INT 2
87928: NEG
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 1
87936: NEG
87937: PUSH
87938: LD_INT 3
87940: NEG
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 1
87948: NEG
87949: PUSH
87950: LD_INT 4
87952: NEG
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 2
87960: PUSH
87961: LD_INT 2
87963: NEG
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 2
87971: NEG
87972: PUSH
87973: LD_INT 4
87975: NEG
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 4
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: PUSH
87991: LD_INT 4
87993: PUSH
87994: LD_INT 1
87996: NEG
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 5
88004: PUSH
88005: LD_INT 0
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 5
88014: PUSH
88015: LD_INT 1
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: PUSH
88022: LD_INT 4
88024: PUSH
88025: LD_INT 1
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 3
88034: PUSH
88035: LD_INT 0
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: LD_INT 3
88044: PUSH
88045: LD_INT 1
88047: NEG
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 3
88055: PUSH
88056: LD_INT 2
88058: NEG
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 5
88066: PUSH
88067: LD_INT 2
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 3
88076: PUSH
88077: LD_INT 3
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 3
88086: PUSH
88087: LD_INT 2
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 4
88096: PUSH
88097: LD_INT 3
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 4
88106: PUSH
88107: LD_INT 4
88109: PUSH
88110: EMPTY
88111: LIST
88112: LIST
88113: PUSH
88114: LD_INT 3
88116: PUSH
88117: LD_INT 4
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 2
88126: PUSH
88127: LD_INT 3
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: LD_INT 2
88136: PUSH
88137: LD_INT 2
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: PUSH
88144: LD_INT 4
88146: PUSH
88147: LD_INT 2
88149: PUSH
88150: EMPTY
88151: LIST
88152: LIST
88153: PUSH
88154: LD_INT 2
88156: PUSH
88157: LD_INT 4
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 0
88166: PUSH
88167: LD_INT 4
88169: PUSH
88170: EMPTY
88171: LIST
88172: LIST
88173: PUSH
88174: LD_INT 0
88176: PUSH
88177: LD_INT 3
88179: PUSH
88180: EMPTY
88181: LIST
88182: LIST
88183: PUSH
88184: LD_INT 1
88186: PUSH
88187: LD_INT 4
88189: PUSH
88190: EMPTY
88191: LIST
88192: LIST
88193: PUSH
88194: LD_INT 1
88196: PUSH
88197: LD_INT 5
88199: PUSH
88200: EMPTY
88201: LIST
88202: LIST
88203: PUSH
88204: LD_INT 0
88206: PUSH
88207: LD_INT 5
88209: PUSH
88210: EMPTY
88211: LIST
88212: LIST
88213: PUSH
88214: LD_INT 1
88216: NEG
88217: PUSH
88218: LD_INT 4
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: PUSH
88225: LD_INT 1
88227: NEG
88228: PUSH
88229: LD_INT 3
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: PUSH
88236: LD_INT 2
88238: PUSH
88239: LD_INT 5
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: PUSH
88246: LD_INT 2
88248: NEG
88249: PUSH
88250: LD_INT 3
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: LIST
88261: LIST
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
88304: LD_ADDR_VAR 0 34
88308: PUSH
88309: LD_INT 0
88311: PUSH
88312: LD_INT 4
88314: NEG
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PUSH
88320: LD_INT 0
88322: PUSH
88323: LD_INT 5
88325: NEG
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: PUSH
88331: LD_INT 1
88333: PUSH
88334: LD_INT 4
88336: NEG
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 1
88344: PUSH
88345: LD_INT 3
88347: NEG
88348: PUSH
88349: EMPTY
88350: LIST
88351: LIST
88352: PUSH
88353: LD_INT 0
88355: PUSH
88356: LD_INT 3
88358: NEG
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 1
88366: NEG
88367: PUSH
88368: LD_INT 4
88370: NEG
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: PUSH
88376: LD_INT 1
88378: NEG
88379: PUSH
88380: LD_INT 5
88382: NEG
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 2
88390: PUSH
88391: LD_INT 3
88393: NEG
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 2
88401: NEG
88402: PUSH
88403: LD_INT 5
88405: NEG
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 3
88413: PUSH
88414: LD_INT 0
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 3
88423: PUSH
88424: LD_INT 1
88426: NEG
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: PUSH
88432: LD_INT 4
88434: PUSH
88435: LD_INT 0
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 4
88444: PUSH
88445: LD_INT 1
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: PUSH
88452: LD_INT 3
88454: PUSH
88455: LD_INT 1
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 2
88464: PUSH
88465: LD_INT 0
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PUSH
88472: LD_INT 2
88474: PUSH
88475: LD_INT 1
88477: NEG
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: LD_INT 2
88485: PUSH
88486: LD_INT 2
88488: NEG
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: PUSH
88494: LD_INT 4
88496: PUSH
88497: LD_INT 2
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 4
88506: PUSH
88507: LD_INT 4
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: PUSH
88514: LD_INT 4
88516: PUSH
88517: LD_INT 3
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PUSH
88524: LD_INT 5
88526: PUSH
88527: LD_INT 4
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: PUSH
88534: LD_INT 5
88536: PUSH
88537: LD_INT 5
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: PUSH
88544: LD_INT 4
88546: PUSH
88547: LD_INT 5
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PUSH
88554: LD_INT 3
88556: PUSH
88557: LD_INT 4
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: LD_INT 3
88566: PUSH
88567: LD_INT 3
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 5
88576: PUSH
88577: LD_INT 3
88579: PUSH
88580: EMPTY
88581: LIST
88582: LIST
88583: PUSH
88584: LD_INT 3
88586: PUSH
88587: LD_INT 5
88589: PUSH
88590: EMPTY
88591: LIST
88592: LIST
88593: PUSH
88594: LD_INT 0
88596: PUSH
88597: LD_INT 3
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 0
88606: PUSH
88607: LD_INT 2
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: PUSH
88614: LD_INT 1
88616: PUSH
88617: LD_INT 3
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: PUSH
88624: LD_INT 1
88626: PUSH
88627: LD_INT 4
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: LD_INT 0
88636: PUSH
88637: LD_INT 4
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: PUSH
88644: LD_INT 1
88646: NEG
88647: PUSH
88648: LD_INT 3
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: PUSH
88655: LD_INT 1
88657: NEG
88658: PUSH
88659: LD_INT 2
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 2
88668: PUSH
88669: LD_INT 4
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 2
88678: NEG
88679: PUSH
88680: LD_INT 2
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 4
88689: NEG
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 4
88700: NEG
88701: PUSH
88702: LD_INT 1
88704: NEG
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 3
88712: NEG
88713: PUSH
88714: LD_INT 0
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: LD_INT 3
88723: NEG
88724: PUSH
88725: LD_INT 1
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 4
88734: NEG
88735: PUSH
88736: LD_INT 1
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 5
88745: NEG
88746: PUSH
88747: LD_INT 0
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: PUSH
88754: LD_INT 5
88756: NEG
88757: PUSH
88758: LD_INT 1
88760: NEG
88761: PUSH
88762: EMPTY
88763: LIST
88764: LIST
88765: PUSH
88766: LD_INT 5
88768: NEG
88769: PUSH
88770: LD_INT 2
88772: NEG
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: PUSH
88778: LD_INT 3
88780: NEG
88781: PUSH
88782: LD_INT 2
88784: PUSH
88785: EMPTY
88786: LIST
88787: LIST
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: ST_TO_ADDR
// end ; end ;
88836: GO 88839
88838: POP
// case btype of b_depot , b_warehouse :
88839: LD_VAR 0 1
88843: PUSH
88844: LD_INT 0
88846: DOUBLE
88847: EQUAL
88848: IFTRUE 88858
88850: LD_INT 1
88852: DOUBLE
88853: EQUAL
88854: IFTRUE 88858
88856: GO 89059
88858: POP
// case nation of nation_american :
88859: LD_VAR 0 5
88863: PUSH
88864: LD_INT 1
88866: DOUBLE
88867: EQUAL
88868: IFTRUE 88872
88870: GO 88928
88872: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
88873: LD_ADDR_VAR 0 9
88877: PUSH
88878: LD_VAR 0 11
88882: PUSH
88883: LD_VAR 0 12
88887: PUSH
88888: LD_VAR 0 13
88892: PUSH
88893: LD_VAR 0 14
88897: PUSH
88898: LD_VAR 0 15
88902: PUSH
88903: LD_VAR 0 16
88907: PUSH
88908: EMPTY
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: PUSH
88916: LD_VAR 0 4
88920: PUSH
88921: LD_INT 1
88923: PLUS
88924: ARRAY
88925: ST_TO_ADDR
88926: GO 89057
88928: LD_INT 2
88930: DOUBLE
88931: EQUAL
88932: IFTRUE 88936
88934: GO 88992
88936: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
88937: LD_ADDR_VAR 0 9
88941: PUSH
88942: LD_VAR 0 17
88946: PUSH
88947: LD_VAR 0 18
88951: PUSH
88952: LD_VAR 0 19
88956: PUSH
88957: LD_VAR 0 20
88961: PUSH
88962: LD_VAR 0 21
88966: PUSH
88967: LD_VAR 0 22
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: PUSH
88980: LD_VAR 0 4
88984: PUSH
88985: LD_INT 1
88987: PLUS
88988: ARRAY
88989: ST_TO_ADDR
88990: GO 89057
88992: LD_INT 3
88994: DOUBLE
88995: EQUAL
88996: IFTRUE 89000
88998: GO 89056
89000: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
89001: LD_ADDR_VAR 0 9
89005: PUSH
89006: LD_VAR 0 23
89010: PUSH
89011: LD_VAR 0 24
89015: PUSH
89016: LD_VAR 0 25
89020: PUSH
89021: LD_VAR 0 26
89025: PUSH
89026: LD_VAR 0 27
89030: PUSH
89031: LD_VAR 0 28
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: PUSH
89044: LD_VAR 0 4
89048: PUSH
89049: LD_INT 1
89051: PLUS
89052: ARRAY
89053: ST_TO_ADDR
89054: GO 89057
89056: POP
89057: GO 89612
89059: LD_INT 2
89061: DOUBLE
89062: EQUAL
89063: IFTRUE 89073
89065: LD_INT 3
89067: DOUBLE
89068: EQUAL
89069: IFTRUE 89073
89071: GO 89129
89073: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
89074: LD_ADDR_VAR 0 9
89078: PUSH
89079: LD_VAR 0 29
89083: PUSH
89084: LD_VAR 0 30
89088: PUSH
89089: LD_VAR 0 31
89093: PUSH
89094: LD_VAR 0 32
89098: PUSH
89099: LD_VAR 0 33
89103: PUSH
89104: LD_VAR 0 34
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: PUSH
89117: LD_VAR 0 4
89121: PUSH
89122: LD_INT 1
89124: PLUS
89125: ARRAY
89126: ST_TO_ADDR
89127: GO 89612
89129: LD_INT 16
89131: DOUBLE
89132: EQUAL
89133: IFTRUE 89191
89135: LD_INT 17
89137: DOUBLE
89138: EQUAL
89139: IFTRUE 89191
89141: LD_INT 18
89143: DOUBLE
89144: EQUAL
89145: IFTRUE 89191
89147: LD_INT 19
89149: DOUBLE
89150: EQUAL
89151: IFTRUE 89191
89153: LD_INT 22
89155: DOUBLE
89156: EQUAL
89157: IFTRUE 89191
89159: LD_INT 20
89161: DOUBLE
89162: EQUAL
89163: IFTRUE 89191
89165: LD_INT 21
89167: DOUBLE
89168: EQUAL
89169: IFTRUE 89191
89171: LD_INT 23
89173: DOUBLE
89174: EQUAL
89175: IFTRUE 89191
89177: LD_INT 24
89179: DOUBLE
89180: EQUAL
89181: IFTRUE 89191
89183: LD_INT 25
89185: DOUBLE
89186: EQUAL
89187: IFTRUE 89191
89189: GO 89247
89191: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
89192: LD_ADDR_VAR 0 9
89196: PUSH
89197: LD_VAR 0 35
89201: PUSH
89202: LD_VAR 0 36
89206: PUSH
89207: LD_VAR 0 37
89211: PUSH
89212: LD_VAR 0 38
89216: PUSH
89217: LD_VAR 0 39
89221: PUSH
89222: LD_VAR 0 40
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: PUSH
89235: LD_VAR 0 4
89239: PUSH
89240: LD_INT 1
89242: PLUS
89243: ARRAY
89244: ST_TO_ADDR
89245: GO 89612
89247: LD_INT 6
89249: DOUBLE
89250: EQUAL
89251: IFTRUE 89303
89253: LD_INT 7
89255: DOUBLE
89256: EQUAL
89257: IFTRUE 89303
89259: LD_INT 8
89261: DOUBLE
89262: EQUAL
89263: IFTRUE 89303
89265: LD_INT 13
89267: DOUBLE
89268: EQUAL
89269: IFTRUE 89303
89271: LD_INT 12
89273: DOUBLE
89274: EQUAL
89275: IFTRUE 89303
89277: LD_INT 15
89279: DOUBLE
89280: EQUAL
89281: IFTRUE 89303
89283: LD_INT 11
89285: DOUBLE
89286: EQUAL
89287: IFTRUE 89303
89289: LD_INT 14
89291: DOUBLE
89292: EQUAL
89293: IFTRUE 89303
89295: LD_INT 10
89297: DOUBLE
89298: EQUAL
89299: IFTRUE 89303
89301: GO 89359
89303: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
89304: LD_ADDR_VAR 0 9
89308: PUSH
89309: LD_VAR 0 41
89313: PUSH
89314: LD_VAR 0 42
89318: PUSH
89319: LD_VAR 0 43
89323: PUSH
89324: LD_VAR 0 44
89328: PUSH
89329: LD_VAR 0 45
89333: PUSH
89334: LD_VAR 0 46
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: PUSH
89347: LD_VAR 0 4
89351: PUSH
89352: LD_INT 1
89354: PLUS
89355: ARRAY
89356: ST_TO_ADDR
89357: GO 89612
89359: LD_INT 36
89361: DOUBLE
89362: EQUAL
89363: IFTRUE 89367
89365: GO 89423
89367: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
89368: LD_ADDR_VAR 0 9
89372: PUSH
89373: LD_VAR 0 47
89377: PUSH
89378: LD_VAR 0 48
89382: PUSH
89383: LD_VAR 0 49
89387: PUSH
89388: LD_VAR 0 50
89392: PUSH
89393: LD_VAR 0 51
89397: PUSH
89398: LD_VAR 0 52
89402: PUSH
89403: EMPTY
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: PUSH
89411: LD_VAR 0 4
89415: PUSH
89416: LD_INT 1
89418: PLUS
89419: ARRAY
89420: ST_TO_ADDR
89421: GO 89612
89423: LD_INT 4
89425: DOUBLE
89426: EQUAL
89427: IFTRUE 89449
89429: LD_INT 5
89431: DOUBLE
89432: EQUAL
89433: IFTRUE 89449
89435: LD_INT 34
89437: DOUBLE
89438: EQUAL
89439: IFTRUE 89449
89441: LD_INT 37
89443: DOUBLE
89444: EQUAL
89445: IFTRUE 89449
89447: GO 89505
89449: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
89450: LD_ADDR_VAR 0 9
89454: PUSH
89455: LD_VAR 0 53
89459: PUSH
89460: LD_VAR 0 54
89464: PUSH
89465: LD_VAR 0 55
89469: PUSH
89470: LD_VAR 0 56
89474: PUSH
89475: LD_VAR 0 57
89479: PUSH
89480: LD_VAR 0 58
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: PUSH
89493: LD_VAR 0 4
89497: PUSH
89498: LD_INT 1
89500: PLUS
89501: ARRAY
89502: ST_TO_ADDR
89503: GO 89612
89505: LD_INT 31
89507: DOUBLE
89508: EQUAL
89509: IFTRUE 89555
89511: LD_INT 32
89513: DOUBLE
89514: EQUAL
89515: IFTRUE 89555
89517: LD_INT 33
89519: DOUBLE
89520: EQUAL
89521: IFTRUE 89555
89523: LD_INT 27
89525: DOUBLE
89526: EQUAL
89527: IFTRUE 89555
89529: LD_INT 26
89531: DOUBLE
89532: EQUAL
89533: IFTRUE 89555
89535: LD_INT 28
89537: DOUBLE
89538: EQUAL
89539: IFTRUE 89555
89541: LD_INT 29
89543: DOUBLE
89544: EQUAL
89545: IFTRUE 89555
89547: LD_INT 30
89549: DOUBLE
89550: EQUAL
89551: IFTRUE 89555
89553: GO 89611
89555: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
89556: LD_ADDR_VAR 0 9
89560: PUSH
89561: LD_VAR 0 59
89565: PUSH
89566: LD_VAR 0 60
89570: PUSH
89571: LD_VAR 0 61
89575: PUSH
89576: LD_VAR 0 62
89580: PUSH
89581: LD_VAR 0 63
89585: PUSH
89586: LD_VAR 0 64
89590: PUSH
89591: EMPTY
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: PUSH
89599: LD_VAR 0 4
89603: PUSH
89604: LD_INT 1
89606: PLUS
89607: ARRAY
89608: ST_TO_ADDR
89609: GO 89612
89611: POP
// temp_list2 = [ ] ;
89612: LD_ADDR_VAR 0 10
89616: PUSH
89617: EMPTY
89618: ST_TO_ADDR
// for i in temp_list do
89619: LD_ADDR_VAR 0 8
89623: PUSH
89624: LD_VAR 0 9
89628: PUSH
89629: FOR_IN
89630: IFFALSE 89682
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
89632: LD_ADDR_VAR 0 10
89636: PUSH
89637: LD_VAR 0 10
89641: PUSH
89642: LD_VAR 0 8
89646: PUSH
89647: LD_INT 1
89649: ARRAY
89650: PUSH
89651: LD_VAR 0 2
89655: PLUS
89656: PUSH
89657: LD_VAR 0 8
89661: PUSH
89662: LD_INT 2
89664: ARRAY
89665: PUSH
89666: LD_VAR 0 3
89670: PLUS
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: EMPTY
89677: LIST
89678: ADD
89679: ST_TO_ADDR
89680: GO 89629
89682: POP
89683: POP
// result = temp_list2 ;
89684: LD_ADDR_VAR 0 7
89688: PUSH
89689: LD_VAR 0 10
89693: ST_TO_ADDR
// end ;
89694: LD_VAR 0 7
89698: RET
// export function EnemyInRange ( unit , dist ) ; begin
89699: LD_INT 0
89701: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
89702: LD_ADDR_VAR 0 3
89706: PUSH
89707: LD_VAR 0 1
89711: PPUSH
89712: CALL_OW 255
89716: PPUSH
89717: LD_VAR 0 1
89721: PPUSH
89722: CALL_OW 250
89726: PPUSH
89727: LD_VAR 0 1
89731: PPUSH
89732: CALL_OW 251
89736: PPUSH
89737: LD_VAR 0 2
89741: PPUSH
89742: CALL 63803 0 4
89746: PUSH
89747: LD_INT 4
89749: ARRAY
89750: ST_TO_ADDR
// end ;
89751: LD_VAR 0 3
89755: RET
// export function PlayerSeeMe ( unit ) ; begin
89756: LD_INT 0
89758: PPUSH
// result := See ( your_side , unit ) ;
89759: LD_ADDR_VAR 0 2
89763: PUSH
89764: LD_OWVAR 2
89768: PPUSH
89769: LD_VAR 0 1
89773: PPUSH
89774: CALL_OW 292
89778: ST_TO_ADDR
// end ;
89779: LD_VAR 0 2
89783: RET
// export function ReverseDir ( unit ) ; begin
89784: LD_INT 0
89786: PPUSH
// if not unit then
89787: LD_VAR 0 1
89791: NOT
89792: IFFALSE 89796
// exit ;
89794: GO 89819
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
89796: LD_ADDR_VAR 0 2
89800: PUSH
89801: LD_VAR 0 1
89805: PPUSH
89806: CALL_OW 254
89810: PUSH
89811: LD_INT 3
89813: PLUS
89814: PUSH
89815: LD_INT 6
89817: MOD
89818: ST_TO_ADDR
// end ;
89819: LD_VAR 0 2
89823: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
89824: LD_INT 0
89826: PPUSH
89827: PPUSH
89828: PPUSH
89829: PPUSH
89830: PPUSH
// if not hexes then
89831: LD_VAR 0 2
89835: NOT
89836: IFFALSE 89840
// exit ;
89838: GO 89988
// dist := 9999 ;
89840: LD_ADDR_VAR 0 5
89844: PUSH
89845: LD_INT 9999
89847: ST_TO_ADDR
// for i = 1 to hexes do
89848: LD_ADDR_VAR 0 4
89852: PUSH
89853: DOUBLE
89854: LD_INT 1
89856: DEC
89857: ST_TO_ADDR
89858: LD_VAR 0 2
89862: PUSH
89863: FOR_TO
89864: IFFALSE 89976
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
89866: LD_VAR 0 1
89870: PPUSH
89871: LD_VAR 0 2
89875: PUSH
89876: LD_VAR 0 4
89880: ARRAY
89881: PUSH
89882: LD_INT 1
89884: ARRAY
89885: PPUSH
89886: LD_VAR 0 2
89890: PUSH
89891: LD_VAR 0 4
89895: ARRAY
89896: PUSH
89897: LD_INT 2
89899: ARRAY
89900: PPUSH
89901: CALL_OW 297
89905: PUSH
89906: LD_VAR 0 5
89910: LESS
89911: IFFALSE 89974
// begin hex := hexes [ i ] ;
89913: LD_ADDR_VAR 0 7
89917: PUSH
89918: LD_VAR 0 2
89922: PUSH
89923: LD_VAR 0 4
89927: ARRAY
89928: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
89929: LD_ADDR_VAR 0 5
89933: PUSH
89934: LD_VAR 0 1
89938: PPUSH
89939: LD_VAR 0 2
89943: PUSH
89944: LD_VAR 0 4
89948: ARRAY
89949: PUSH
89950: LD_INT 1
89952: ARRAY
89953: PPUSH
89954: LD_VAR 0 2
89958: PUSH
89959: LD_VAR 0 4
89963: ARRAY
89964: PUSH
89965: LD_INT 2
89967: ARRAY
89968: PPUSH
89969: CALL_OW 297
89973: ST_TO_ADDR
// end ; end ;
89974: GO 89863
89976: POP
89977: POP
// result := hex ;
89978: LD_ADDR_VAR 0 3
89982: PUSH
89983: LD_VAR 0 7
89987: ST_TO_ADDR
// end ;
89988: LD_VAR 0 3
89992: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
89993: LD_INT 0
89995: PPUSH
89996: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89997: LD_VAR 0 1
90001: NOT
90002: PUSH
90003: LD_VAR 0 1
90007: PUSH
90008: LD_INT 21
90010: PUSH
90011: LD_INT 2
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: PUSH
90018: LD_INT 23
90020: PUSH
90021: LD_INT 2
90023: PUSH
90024: EMPTY
90025: LIST
90026: LIST
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: PPUSH
90032: CALL_OW 69
90036: IN
90037: NOT
90038: OR
90039: IFFALSE 90043
// exit ;
90041: GO 90090
// for i = 1 to 3 do
90043: LD_ADDR_VAR 0 3
90047: PUSH
90048: DOUBLE
90049: LD_INT 1
90051: DEC
90052: ST_TO_ADDR
90053: LD_INT 3
90055: PUSH
90056: FOR_TO
90057: IFFALSE 90088
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
90059: LD_VAR 0 1
90063: PPUSH
90064: CALL_OW 250
90068: PPUSH
90069: LD_VAR 0 1
90073: PPUSH
90074: CALL_OW 251
90078: PPUSH
90079: LD_INT 1
90081: PPUSH
90082: CALL_OW 453
90086: GO 90056
90088: POP
90089: POP
// end ;
90090: LD_VAR 0 2
90094: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
90095: LD_INT 0
90097: PPUSH
90098: PPUSH
90099: PPUSH
90100: PPUSH
90101: PPUSH
90102: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
90103: LD_VAR 0 1
90107: NOT
90108: PUSH
90109: LD_VAR 0 2
90113: NOT
90114: OR
90115: PUSH
90116: LD_VAR 0 1
90120: PPUSH
90121: CALL_OW 314
90125: OR
90126: IFFALSE 90130
// exit ;
90128: GO 90571
// x := GetX ( enemy_unit ) ;
90130: LD_ADDR_VAR 0 7
90134: PUSH
90135: LD_VAR 0 2
90139: PPUSH
90140: CALL_OW 250
90144: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
90145: LD_ADDR_VAR 0 8
90149: PUSH
90150: LD_VAR 0 2
90154: PPUSH
90155: CALL_OW 251
90159: ST_TO_ADDR
// if not x or not y then
90160: LD_VAR 0 7
90164: NOT
90165: PUSH
90166: LD_VAR 0 8
90170: NOT
90171: OR
90172: IFFALSE 90176
// exit ;
90174: GO 90571
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
90176: LD_ADDR_VAR 0 6
90180: PUSH
90181: LD_VAR 0 7
90185: PPUSH
90186: LD_INT 0
90188: PPUSH
90189: LD_INT 4
90191: PPUSH
90192: CALL_OW 272
90196: PUSH
90197: LD_VAR 0 8
90201: PPUSH
90202: LD_INT 0
90204: PPUSH
90205: LD_INT 4
90207: PPUSH
90208: CALL_OW 273
90212: PUSH
90213: EMPTY
90214: LIST
90215: LIST
90216: PUSH
90217: LD_VAR 0 7
90221: PPUSH
90222: LD_INT 1
90224: PPUSH
90225: LD_INT 4
90227: PPUSH
90228: CALL_OW 272
90232: PUSH
90233: LD_VAR 0 8
90237: PPUSH
90238: LD_INT 1
90240: PPUSH
90241: LD_INT 4
90243: PPUSH
90244: CALL_OW 273
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: PUSH
90253: LD_VAR 0 7
90257: PPUSH
90258: LD_INT 2
90260: PPUSH
90261: LD_INT 4
90263: PPUSH
90264: CALL_OW 272
90268: PUSH
90269: LD_VAR 0 8
90273: PPUSH
90274: LD_INT 2
90276: PPUSH
90277: LD_INT 4
90279: PPUSH
90280: CALL_OW 273
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_VAR 0 7
90293: PPUSH
90294: LD_INT 3
90296: PPUSH
90297: LD_INT 4
90299: PPUSH
90300: CALL_OW 272
90304: PUSH
90305: LD_VAR 0 8
90309: PPUSH
90310: LD_INT 3
90312: PPUSH
90313: LD_INT 4
90315: PPUSH
90316: CALL_OW 273
90320: PUSH
90321: EMPTY
90322: LIST
90323: LIST
90324: PUSH
90325: LD_VAR 0 7
90329: PPUSH
90330: LD_INT 4
90332: PPUSH
90333: LD_INT 4
90335: PPUSH
90336: CALL_OW 272
90340: PUSH
90341: LD_VAR 0 8
90345: PPUSH
90346: LD_INT 4
90348: PPUSH
90349: LD_INT 4
90351: PPUSH
90352: CALL_OW 273
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_VAR 0 7
90365: PPUSH
90366: LD_INT 5
90368: PPUSH
90369: LD_INT 4
90371: PPUSH
90372: CALL_OW 272
90376: PUSH
90377: LD_VAR 0 8
90381: PPUSH
90382: LD_INT 5
90384: PPUSH
90385: LD_INT 4
90387: PPUSH
90388: CALL_OW 273
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: ST_TO_ADDR
// for i = tmp downto 1 do
90405: LD_ADDR_VAR 0 4
90409: PUSH
90410: DOUBLE
90411: LD_VAR 0 6
90415: INC
90416: ST_TO_ADDR
90417: LD_INT 1
90419: PUSH
90420: FOR_DOWNTO
90421: IFFALSE 90522
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
90423: LD_VAR 0 6
90427: PUSH
90428: LD_VAR 0 4
90432: ARRAY
90433: PUSH
90434: LD_INT 1
90436: ARRAY
90437: PPUSH
90438: LD_VAR 0 6
90442: PUSH
90443: LD_VAR 0 4
90447: ARRAY
90448: PUSH
90449: LD_INT 2
90451: ARRAY
90452: PPUSH
90453: CALL_OW 488
90457: NOT
90458: PUSH
90459: LD_VAR 0 6
90463: PUSH
90464: LD_VAR 0 4
90468: ARRAY
90469: PUSH
90470: LD_INT 1
90472: ARRAY
90473: PPUSH
90474: LD_VAR 0 6
90478: PUSH
90479: LD_VAR 0 4
90483: ARRAY
90484: PUSH
90485: LD_INT 2
90487: ARRAY
90488: PPUSH
90489: CALL_OW 428
90493: PUSH
90494: LD_INT 0
90496: NONEQUAL
90497: OR
90498: IFFALSE 90520
// tmp := Delete ( tmp , i ) ;
90500: LD_ADDR_VAR 0 6
90504: PUSH
90505: LD_VAR 0 6
90509: PPUSH
90510: LD_VAR 0 4
90514: PPUSH
90515: CALL_OW 3
90519: ST_TO_ADDR
90520: GO 90420
90522: POP
90523: POP
// j := GetClosestHex ( unit , tmp ) ;
90524: LD_ADDR_VAR 0 5
90528: PUSH
90529: LD_VAR 0 1
90533: PPUSH
90534: LD_VAR 0 6
90538: PPUSH
90539: CALL 89824 0 2
90543: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
90544: LD_VAR 0 1
90548: PPUSH
90549: LD_VAR 0 5
90553: PUSH
90554: LD_INT 1
90556: ARRAY
90557: PPUSH
90558: LD_VAR 0 5
90562: PUSH
90563: LD_INT 2
90565: ARRAY
90566: PPUSH
90567: CALL_OW 111
// end ;
90571: LD_VAR 0 3
90575: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
90576: LD_INT 0
90578: PPUSH
90579: PPUSH
90580: PPUSH
// uc_side = 0 ;
90581: LD_ADDR_OWVAR 20
90585: PUSH
90586: LD_INT 0
90588: ST_TO_ADDR
// uc_nation = 0 ;
90589: LD_ADDR_OWVAR 21
90593: PUSH
90594: LD_INT 0
90596: ST_TO_ADDR
// InitHc ;
90597: CALL_OW 19
// InitVc ;
90601: CALL_OW 20
// if mastodonts then
90605: LD_VAR 0 6
90609: IFFALSE 90676
// for i = 1 to mastodonts do
90611: LD_ADDR_VAR 0 11
90615: PUSH
90616: DOUBLE
90617: LD_INT 1
90619: DEC
90620: ST_TO_ADDR
90621: LD_VAR 0 6
90625: PUSH
90626: FOR_TO
90627: IFFALSE 90674
// begin vc_chassis := 31 ;
90629: LD_ADDR_OWVAR 37
90633: PUSH
90634: LD_INT 31
90636: ST_TO_ADDR
// vc_control := control_rider ;
90637: LD_ADDR_OWVAR 38
90641: PUSH
90642: LD_INT 4
90644: ST_TO_ADDR
// animal := CreateVehicle ;
90645: LD_ADDR_VAR 0 12
90649: PUSH
90650: CALL_OW 45
90654: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
90655: LD_VAR 0 12
90659: PPUSH
90660: LD_VAR 0 8
90664: PPUSH
90665: LD_INT 0
90667: PPUSH
90668: CALL 92745 0 3
// end ;
90672: GO 90626
90674: POP
90675: POP
// if horses then
90676: LD_VAR 0 5
90680: IFFALSE 90747
// for i = 1 to horses do
90682: LD_ADDR_VAR 0 11
90686: PUSH
90687: DOUBLE
90688: LD_INT 1
90690: DEC
90691: ST_TO_ADDR
90692: LD_VAR 0 5
90696: PUSH
90697: FOR_TO
90698: IFFALSE 90745
// begin hc_class := 21 ;
90700: LD_ADDR_OWVAR 28
90704: PUSH
90705: LD_INT 21
90707: ST_TO_ADDR
// hc_gallery :=  ;
90708: LD_ADDR_OWVAR 33
90712: PUSH
90713: LD_STRING 
90715: ST_TO_ADDR
// animal := CreateHuman ;
90716: LD_ADDR_VAR 0 12
90720: PUSH
90721: CALL_OW 44
90725: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
90726: LD_VAR 0 12
90730: PPUSH
90731: LD_VAR 0 8
90735: PPUSH
90736: LD_INT 0
90738: PPUSH
90739: CALL 92745 0 3
// end ;
90743: GO 90697
90745: POP
90746: POP
// if birds then
90747: LD_VAR 0 1
90751: IFFALSE 90818
// for i = 1 to birds do
90753: LD_ADDR_VAR 0 11
90757: PUSH
90758: DOUBLE
90759: LD_INT 1
90761: DEC
90762: ST_TO_ADDR
90763: LD_VAR 0 1
90767: PUSH
90768: FOR_TO
90769: IFFALSE 90816
// begin hc_class = 18 ;
90771: LD_ADDR_OWVAR 28
90775: PUSH
90776: LD_INT 18
90778: ST_TO_ADDR
// hc_gallery =  ;
90779: LD_ADDR_OWVAR 33
90783: PUSH
90784: LD_STRING 
90786: ST_TO_ADDR
// animal := CreateHuman ;
90787: LD_ADDR_VAR 0 12
90791: PUSH
90792: CALL_OW 44
90796: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
90797: LD_VAR 0 12
90801: PPUSH
90802: LD_VAR 0 8
90806: PPUSH
90807: LD_INT 0
90809: PPUSH
90810: CALL 92745 0 3
// end ;
90814: GO 90768
90816: POP
90817: POP
// if tigers then
90818: LD_VAR 0 2
90822: IFFALSE 90906
// for i = 1 to tigers do
90824: LD_ADDR_VAR 0 11
90828: PUSH
90829: DOUBLE
90830: LD_INT 1
90832: DEC
90833: ST_TO_ADDR
90834: LD_VAR 0 2
90838: PUSH
90839: FOR_TO
90840: IFFALSE 90904
// begin hc_class = class_tiger ;
90842: LD_ADDR_OWVAR 28
90846: PUSH
90847: LD_INT 14
90849: ST_TO_ADDR
// hc_gallery =  ;
90850: LD_ADDR_OWVAR 33
90854: PUSH
90855: LD_STRING 
90857: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
90858: LD_ADDR_OWVAR 35
90862: PUSH
90863: LD_INT 7
90865: NEG
90866: PPUSH
90867: LD_INT 7
90869: PPUSH
90870: CALL_OW 12
90874: ST_TO_ADDR
// animal := CreateHuman ;
90875: LD_ADDR_VAR 0 12
90879: PUSH
90880: CALL_OW 44
90884: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
90885: LD_VAR 0 12
90889: PPUSH
90890: LD_VAR 0 8
90894: PPUSH
90895: LD_INT 0
90897: PPUSH
90898: CALL 92745 0 3
// end ;
90902: GO 90839
90904: POP
90905: POP
// if apemans then
90906: LD_VAR 0 3
90910: IFFALSE 91033
// for i = 1 to apemans do
90912: LD_ADDR_VAR 0 11
90916: PUSH
90917: DOUBLE
90918: LD_INT 1
90920: DEC
90921: ST_TO_ADDR
90922: LD_VAR 0 3
90926: PUSH
90927: FOR_TO
90928: IFFALSE 91031
// begin hc_class = class_apeman ;
90930: LD_ADDR_OWVAR 28
90934: PUSH
90935: LD_INT 12
90937: ST_TO_ADDR
// hc_gallery =  ;
90938: LD_ADDR_OWVAR 33
90942: PUSH
90943: LD_STRING 
90945: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
90946: LD_ADDR_OWVAR 35
90950: PUSH
90951: LD_INT 5
90953: NEG
90954: PPUSH
90955: LD_INT 5
90957: PPUSH
90958: CALL_OW 12
90962: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
90963: LD_ADDR_OWVAR 31
90967: PUSH
90968: LD_INT 1
90970: PPUSH
90971: LD_INT 3
90973: PPUSH
90974: CALL_OW 12
90978: PUSH
90979: LD_INT 1
90981: PPUSH
90982: LD_INT 3
90984: PPUSH
90985: CALL_OW 12
90989: PUSH
90990: LD_INT 0
90992: PUSH
90993: LD_INT 0
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: ST_TO_ADDR
// animal := CreateHuman ;
91002: LD_ADDR_VAR 0 12
91006: PUSH
91007: CALL_OW 44
91011: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
91012: LD_VAR 0 12
91016: PPUSH
91017: LD_VAR 0 8
91021: PPUSH
91022: LD_INT 0
91024: PPUSH
91025: CALL 92745 0 3
// end ;
91029: GO 90927
91031: POP
91032: POP
// if enchidnas then
91033: LD_VAR 0 4
91037: IFFALSE 91104
// for i = 1 to enchidnas do
91039: LD_ADDR_VAR 0 11
91043: PUSH
91044: DOUBLE
91045: LD_INT 1
91047: DEC
91048: ST_TO_ADDR
91049: LD_VAR 0 4
91053: PUSH
91054: FOR_TO
91055: IFFALSE 91102
// begin hc_class = 13 ;
91057: LD_ADDR_OWVAR 28
91061: PUSH
91062: LD_INT 13
91064: ST_TO_ADDR
// hc_gallery =  ;
91065: LD_ADDR_OWVAR 33
91069: PUSH
91070: LD_STRING 
91072: ST_TO_ADDR
// animal := CreateHuman ;
91073: LD_ADDR_VAR 0 12
91077: PUSH
91078: CALL_OW 44
91082: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
91083: LD_VAR 0 12
91087: PPUSH
91088: LD_VAR 0 8
91092: PPUSH
91093: LD_INT 0
91095: PPUSH
91096: CALL 92745 0 3
// end ;
91100: GO 91054
91102: POP
91103: POP
// if fishes then
91104: LD_VAR 0 7
91108: IFFALSE 91175
// for i = 1 to fishes do
91110: LD_ADDR_VAR 0 11
91114: PUSH
91115: DOUBLE
91116: LD_INT 1
91118: DEC
91119: ST_TO_ADDR
91120: LD_VAR 0 7
91124: PUSH
91125: FOR_TO
91126: IFFALSE 91173
// begin hc_class = 20 ;
91128: LD_ADDR_OWVAR 28
91132: PUSH
91133: LD_INT 20
91135: ST_TO_ADDR
// hc_gallery =  ;
91136: LD_ADDR_OWVAR 33
91140: PUSH
91141: LD_STRING 
91143: ST_TO_ADDR
// animal := CreateHuman ;
91144: LD_ADDR_VAR 0 12
91148: PUSH
91149: CALL_OW 44
91153: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
91154: LD_VAR 0 12
91158: PPUSH
91159: LD_VAR 0 9
91163: PPUSH
91164: LD_INT 0
91166: PPUSH
91167: CALL 92745 0 3
// end ;
91171: GO 91125
91173: POP
91174: POP
// end ;
91175: LD_VAR 0 10
91179: RET
// export function WantHeal ( sci , unit ) ; begin
91180: LD_INT 0
91182: PPUSH
// if GetTaskList ( sci ) > 0 then
91183: LD_VAR 0 1
91187: PPUSH
91188: CALL_OW 437
91192: PUSH
91193: LD_INT 0
91195: GREATER
91196: IFFALSE 91266
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
91198: LD_VAR 0 1
91202: PPUSH
91203: CALL_OW 437
91207: PUSH
91208: LD_INT 1
91210: ARRAY
91211: PUSH
91212: LD_INT 1
91214: ARRAY
91215: PUSH
91216: LD_STRING l
91218: EQUAL
91219: PUSH
91220: LD_VAR 0 1
91224: PPUSH
91225: CALL_OW 437
91229: PUSH
91230: LD_INT 1
91232: ARRAY
91233: PUSH
91234: LD_INT 4
91236: ARRAY
91237: PUSH
91238: LD_VAR 0 2
91242: EQUAL
91243: AND
91244: IFFALSE 91256
// result := true else
91246: LD_ADDR_VAR 0 3
91250: PUSH
91251: LD_INT 1
91253: ST_TO_ADDR
91254: GO 91264
// result := false ;
91256: LD_ADDR_VAR 0 3
91260: PUSH
91261: LD_INT 0
91263: ST_TO_ADDR
// end else
91264: GO 91274
// result := false ;
91266: LD_ADDR_VAR 0 3
91270: PUSH
91271: LD_INT 0
91273: ST_TO_ADDR
// end ;
91274: LD_VAR 0 3
91278: RET
// export function HealTarget ( sci ) ; begin
91279: LD_INT 0
91281: PPUSH
// if not sci then
91282: LD_VAR 0 1
91286: NOT
91287: IFFALSE 91291
// exit ;
91289: GO 91356
// result := 0 ;
91291: LD_ADDR_VAR 0 2
91295: PUSH
91296: LD_INT 0
91298: ST_TO_ADDR
// if GetTaskList ( sci ) then
91299: LD_VAR 0 1
91303: PPUSH
91304: CALL_OW 437
91308: IFFALSE 91356
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
91310: LD_VAR 0 1
91314: PPUSH
91315: CALL_OW 437
91319: PUSH
91320: LD_INT 1
91322: ARRAY
91323: PUSH
91324: LD_INT 1
91326: ARRAY
91327: PUSH
91328: LD_STRING l
91330: EQUAL
91331: IFFALSE 91356
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
91333: LD_ADDR_VAR 0 2
91337: PUSH
91338: LD_VAR 0 1
91342: PPUSH
91343: CALL_OW 437
91347: PUSH
91348: LD_INT 1
91350: ARRAY
91351: PUSH
91352: LD_INT 4
91354: ARRAY
91355: ST_TO_ADDR
// end ;
91356: LD_VAR 0 2
91360: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
91361: LD_INT 0
91363: PPUSH
91364: PPUSH
91365: PPUSH
91366: PPUSH
// if not base_units then
91367: LD_VAR 0 1
91371: NOT
91372: IFFALSE 91376
// exit ;
91374: GO 91463
// result := false ;
91376: LD_ADDR_VAR 0 2
91380: PUSH
91381: LD_INT 0
91383: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
91384: LD_ADDR_VAR 0 5
91388: PUSH
91389: LD_VAR 0 1
91393: PPUSH
91394: LD_INT 21
91396: PUSH
91397: LD_INT 3
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PPUSH
91404: CALL_OW 72
91408: ST_TO_ADDR
// if not tmp then
91409: LD_VAR 0 5
91413: NOT
91414: IFFALSE 91418
// exit ;
91416: GO 91463
// for i in tmp do
91418: LD_ADDR_VAR 0 3
91422: PUSH
91423: LD_VAR 0 5
91427: PUSH
91428: FOR_IN
91429: IFFALSE 91461
// begin result := EnemyInRange ( i , 22 ) ;
91431: LD_ADDR_VAR 0 2
91435: PUSH
91436: LD_VAR 0 3
91440: PPUSH
91441: LD_INT 22
91443: PPUSH
91444: CALL 89699 0 2
91448: ST_TO_ADDR
// if result then
91449: LD_VAR 0 2
91453: IFFALSE 91459
// exit ;
91455: POP
91456: POP
91457: GO 91463
// end ;
91459: GO 91428
91461: POP
91462: POP
// end ;
91463: LD_VAR 0 2
91467: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
91468: LD_INT 0
91470: PPUSH
91471: PPUSH
// if not units then
91472: LD_VAR 0 1
91476: NOT
91477: IFFALSE 91481
// exit ;
91479: GO 91551
// result := [ ] ;
91481: LD_ADDR_VAR 0 3
91485: PUSH
91486: EMPTY
91487: ST_TO_ADDR
// for i in units do
91488: LD_ADDR_VAR 0 4
91492: PUSH
91493: LD_VAR 0 1
91497: PUSH
91498: FOR_IN
91499: IFFALSE 91549
// if GetTag ( i ) = tag then
91501: LD_VAR 0 4
91505: PPUSH
91506: CALL_OW 110
91510: PUSH
91511: LD_VAR 0 2
91515: EQUAL
91516: IFFALSE 91547
// result := Insert ( result , result + 1 , i ) ;
91518: LD_ADDR_VAR 0 3
91522: PUSH
91523: LD_VAR 0 3
91527: PPUSH
91528: LD_VAR 0 3
91532: PUSH
91533: LD_INT 1
91535: PLUS
91536: PPUSH
91537: LD_VAR 0 4
91541: PPUSH
91542: CALL_OW 2
91546: ST_TO_ADDR
91547: GO 91498
91549: POP
91550: POP
// end ;
91551: LD_VAR 0 3
91555: RET
// export function IsDriver ( un ) ; begin
91556: LD_INT 0
91558: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
91559: LD_ADDR_VAR 0 2
91563: PUSH
91564: LD_VAR 0 1
91568: PUSH
91569: LD_INT 55
91571: PUSH
91572: EMPTY
91573: LIST
91574: PPUSH
91575: CALL_OW 69
91579: IN
91580: ST_TO_ADDR
// end ;
91581: LD_VAR 0 2
91585: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
91586: LD_INT 0
91588: PPUSH
91589: PPUSH
// list := [ ] ;
91590: LD_ADDR_VAR 0 5
91594: PUSH
91595: EMPTY
91596: ST_TO_ADDR
// case d of 0 :
91597: LD_VAR 0 3
91601: PUSH
91602: LD_INT 0
91604: DOUBLE
91605: EQUAL
91606: IFTRUE 91610
91608: GO 91743
91610: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
91611: LD_ADDR_VAR 0 5
91615: PUSH
91616: LD_VAR 0 1
91620: PUSH
91621: LD_INT 4
91623: MINUS
91624: PUSH
91625: LD_VAR 0 2
91629: PUSH
91630: LD_INT 4
91632: MINUS
91633: PUSH
91634: LD_INT 2
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: LIST
91641: PUSH
91642: LD_VAR 0 1
91646: PUSH
91647: LD_INT 3
91649: MINUS
91650: PUSH
91651: LD_VAR 0 2
91655: PUSH
91656: LD_INT 1
91658: PUSH
91659: EMPTY
91660: LIST
91661: LIST
91662: LIST
91663: PUSH
91664: LD_VAR 0 1
91668: PUSH
91669: LD_INT 4
91671: PLUS
91672: PUSH
91673: LD_VAR 0 2
91677: PUSH
91678: LD_INT 4
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: LIST
91685: PUSH
91686: LD_VAR 0 1
91690: PUSH
91691: LD_INT 3
91693: PLUS
91694: PUSH
91695: LD_VAR 0 2
91699: PUSH
91700: LD_INT 3
91702: PLUS
91703: PUSH
91704: LD_INT 5
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: LIST
91711: PUSH
91712: LD_VAR 0 1
91716: PUSH
91717: LD_VAR 0 2
91721: PUSH
91722: LD_INT 4
91724: PLUS
91725: PUSH
91726: LD_INT 0
91728: PUSH
91729: EMPTY
91730: LIST
91731: LIST
91732: LIST
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: ST_TO_ADDR
// end ; 1 :
91741: GO 92441
91743: LD_INT 1
91745: DOUBLE
91746: EQUAL
91747: IFTRUE 91751
91749: GO 91884
91751: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91752: LD_ADDR_VAR 0 5
91756: PUSH
91757: LD_VAR 0 1
91761: PUSH
91762: LD_VAR 0 2
91766: PUSH
91767: LD_INT 4
91769: MINUS
91770: PUSH
91771: LD_INT 3
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: LIST
91778: PUSH
91779: LD_VAR 0 1
91783: PUSH
91784: LD_INT 3
91786: MINUS
91787: PUSH
91788: LD_VAR 0 2
91792: PUSH
91793: LD_INT 3
91795: MINUS
91796: PUSH
91797: LD_INT 2
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: LIST
91804: PUSH
91805: LD_VAR 0 1
91809: PUSH
91810: LD_INT 4
91812: MINUS
91813: PUSH
91814: LD_VAR 0 2
91818: PUSH
91819: LD_INT 1
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: LIST
91826: PUSH
91827: LD_VAR 0 1
91831: PUSH
91832: LD_VAR 0 2
91836: PUSH
91837: LD_INT 3
91839: PLUS
91840: PUSH
91841: LD_INT 0
91843: PUSH
91844: EMPTY
91845: LIST
91846: LIST
91847: LIST
91848: PUSH
91849: LD_VAR 0 1
91853: PUSH
91854: LD_INT 4
91856: PLUS
91857: PUSH
91858: LD_VAR 0 2
91862: PUSH
91863: LD_INT 4
91865: PLUS
91866: PUSH
91867: LD_INT 5
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: LIST
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: LIST
91881: ST_TO_ADDR
// end ; 2 :
91882: GO 92441
91884: LD_INT 2
91886: DOUBLE
91887: EQUAL
91888: IFTRUE 91892
91890: GO 92021
91892: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91893: LD_ADDR_VAR 0 5
91897: PUSH
91898: LD_VAR 0 1
91902: PUSH
91903: LD_VAR 0 2
91907: PUSH
91908: LD_INT 3
91910: MINUS
91911: PUSH
91912: LD_INT 3
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: LIST
91919: PUSH
91920: LD_VAR 0 1
91924: PUSH
91925: LD_INT 4
91927: PLUS
91928: PUSH
91929: LD_VAR 0 2
91933: PUSH
91934: LD_INT 4
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: LIST
91941: PUSH
91942: LD_VAR 0 1
91946: PUSH
91947: LD_VAR 0 2
91951: PUSH
91952: LD_INT 4
91954: PLUS
91955: PUSH
91956: LD_INT 0
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: LIST
91963: PUSH
91964: LD_VAR 0 1
91968: PUSH
91969: LD_INT 3
91971: MINUS
91972: PUSH
91973: LD_VAR 0 2
91977: PUSH
91978: LD_INT 1
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: LIST
91985: PUSH
91986: LD_VAR 0 1
91990: PUSH
91991: LD_INT 4
91993: MINUS
91994: PUSH
91995: LD_VAR 0 2
91999: PUSH
92000: LD_INT 4
92002: MINUS
92003: PUSH
92004: LD_INT 2
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: LIST
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: ST_TO_ADDR
// end ; 3 :
92019: GO 92441
92021: LD_INT 3
92023: DOUBLE
92024: EQUAL
92025: IFTRUE 92029
92027: GO 92162
92029: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
92030: LD_ADDR_VAR 0 5
92034: PUSH
92035: LD_VAR 0 1
92039: PUSH
92040: LD_INT 3
92042: PLUS
92043: PUSH
92044: LD_VAR 0 2
92048: PUSH
92049: LD_INT 4
92051: PUSH
92052: EMPTY
92053: LIST
92054: LIST
92055: LIST
92056: PUSH
92057: LD_VAR 0 1
92061: PUSH
92062: LD_INT 4
92064: PLUS
92065: PUSH
92066: LD_VAR 0 2
92070: PUSH
92071: LD_INT 4
92073: PLUS
92074: PUSH
92075: LD_INT 5
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: LIST
92082: PUSH
92083: LD_VAR 0 1
92087: PUSH
92088: LD_INT 4
92090: MINUS
92091: PUSH
92092: LD_VAR 0 2
92096: PUSH
92097: LD_INT 1
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: LIST
92104: PUSH
92105: LD_VAR 0 1
92109: PUSH
92110: LD_VAR 0 2
92114: PUSH
92115: LD_INT 4
92117: MINUS
92118: PUSH
92119: LD_INT 3
92121: PUSH
92122: EMPTY
92123: LIST
92124: LIST
92125: LIST
92126: PUSH
92127: LD_VAR 0 1
92131: PUSH
92132: LD_INT 3
92134: MINUS
92135: PUSH
92136: LD_VAR 0 2
92140: PUSH
92141: LD_INT 3
92143: MINUS
92144: PUSH
92145: LD_INT 2
92147: PUSH
92148: EMPTY
92149: LIST
92150: LIST
92151: LIST
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: ST_TO_ADDR
// end ; 4 :
92160: GO 92441
92162: LD_INT 4
92164: DOUBLE
92165: EQUAL
92166: IFTRUE 92170
92168: GO 92303
92170: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
92171: LD_ADDR_VAR 0 5
92175: PUSH
92176: LD_VAR 0 1
92180: PUSH
92181: LD_VAR 0 2
92185: PUSH
92186: LD_INT 4
92188: PLUS
92189: PUSH
92190: LD_INT 0
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: LIST
92197: PUSH
92198: LD_VAR 0 1
92202: PUSH
92203: LD_INT 3
92205: PLUS
92206: PUSH
92207: LD_VAR 0 2
92211: PUSH
92212: LD_INT 3
92214: PLUS
92215: PUSH
92216: LD_INT 5
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: LIST
92223: PUSH
92224: LD_VAR 0 1
92228: PUSH
92229: LD_INT 4
92231: PLUS
92232: PUSH
92233: LD_VAR 0 2
92237: PUSH
92238: LD_INT 4
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: LIST
92245: PUSH
92246: LD_VAR 0 1
92250: PUSH
92251: LD_VAR 0 2
92255: PUSH
92256: LD_INT 3
92258: MINUS
92259: PUSH
92260: LD_INT 3
92262: PUSH
92263: EMPTY
92264: LIST
92265: LIST
92266: LIST
92267: PUSH
92268: LD_VAR 0 1
92272: PUSH
92273: LD_INT 4
92275: MINUS
92276: PUSH
92277: LD_VAR 0 2
92281: PUSH
92282: LD_INT 4
92284: MINUS
92285: PUSH
92286: LD_INT 2
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: LIST
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: ST_TO_ADDR
// end ; 5 :
92301: GO 92441
92303: LD_INT 5
92305: DOUBLE
92306: EQUAL
92307: IFTRUE 92311
92309: GO 92440
92311: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
92312: LD_ADDR_VAR 0 5
92316: PUSH
92317: LD_VAR 0 1
92321: PUSH
92322: LD_INT 4
92324: MINUS
92325: PUSH
92326: LD_VAR 0 2
92330: PUSH
92331: LD_INT 1
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: LIST
92338: PUSH
92339: LD_VAR 0 1
92343: PUSH
92344: LD_VAR 0 2
92348: PUSH
92349: LD_INT 4
92351: MINUS
92352: PUSH
92353: LD_INT 3
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: LIST
92360: PUSH
92361: LD_VAR 0 1
92365: PUSH
92366: LD_INT 4
92368: PLUS
92369: PUSH
92370: LD_VAR 0 2
92374: PUSH
92375: LD_INT 4
92377: PLUS
92378: PUSH
92379: LD_INT 5
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: LIST
92386: PUSH
92387: LD_VAR 0 1
92391: PUSH
92392: LD_INT 3
92394: PLUS
92395: PUSH
92396: LD_VAR 0 2
92400: PUSH
92401: LD_INT 4
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: LIST
92408: PUSH
92409: LD_VAR 0 1
92413: PUSH
92414: LD_VAR 0 2
92418: PUSH
92419: LD_INT 3
92421: PLUS
92422: PUSH
92423: LD_INT 0
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: LIST
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: ST_TO_ADDR
// end ; end ;
92438: GO 92441
92440: POP
// result := list ;
92441: LD_ADDR_VAR 0 4
92445: PUSH
92446: LD_VAR 0 5
92450: ST_TO_ADDR
// end ;
92451: LD_VAR 0 4
92455: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
92456: LD_INT 0
92458: PPUSH
92459: PPUSH
92460: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
92461: LD_VAR 0 1
92465: NOT
92466: PUSH
92467: LD_VAR 0 2
92471: PUSH
92472: LD_INT 1
92474: PUSH
92475: LD_INT 2
92477: PUSH
92478: LD_INT 3
92480: PUSH
92481: LD_INT 4
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: IN
92490: NOT
92491: OR
92492: IFFALSE 92496
// exit ;
92494: GO 92588
// tmp := [ ] ;
92496: LD_ADDR_VAR 0 5
92500: PUSH
92501: EMPTY
92502: ST_TO_ADDR
// for i in units do
92503: LD_ADDR_VAR 0 4
92507: PUSH
92508: LD_VAR 0 1
92512: PUSH
92513: FOR_IN
92514: IFFALSE 92557
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
92516: LD_ADDR_VAR 0 5
92520: PUSH
92521: LD_VAR 0 5
92525: PPUSH
92526: LD_VAR 0 5
92530: PUSH
92531: LD_INT 1
92533: PLUS
92534: PPUSH
92535: LD_VAR 0 4
92539: PPUSH
92540: LD_VAR 0 2
92544: PPUSH
92545: CALL_OW 259
92549: PPUSH
92550: CALL_OW 2
92554: ST_TO_ADDR
92555: GO 92513
92557: POP
92558: POP
// if not tmp then
92559: LD_VAR 0 5
92563: NOT
92564: IFFALSE 92568
// exit ;
92566: GO 92588
// result := SortListByListDesc ( units , tmp ) ;
92568: LD_ADDR_VAR 0 3
92572: PUSH
92573: LD_VAR 0 1
92577: PPUSH
92578: LD_VAR 0 5
92582: PPUSH
92583: CALL_OW 77
92587: ST_TO_ADDR
// end ;
92588: LD_VAR 0 3
92592: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
92593: LD_INT 0
92595: PPUSH
92596: PPUSH
92597: PPUSH
// x := GetX ( building ) ;
92598: LD_ADDR_VAR 0 4
92602: PUSH
92603: LD_VAR 0 2
92607: PPUSH
92608: CALL_OW 250
92612: ST_TO_ADDR
// y := GetY ( building ) ;
92613: LD_ADDR_VAR 0 5
92617: PUSH
92618: LD_VAR 0 2
92622: PPUSH
92623: CALL_OW 251
92627: ST_TO_ADDR
// if GetTaskList ( unit ) then
92628: LD_VAR 0 1
92632: PPUSH
92633: CALL_OW 437
92637: IFFALSE 92732
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
92639: LD_STRING e
92641: PUSH
92642: LD_VAR 0 1
92646: PPUSH
92647: CALL_OW 437
92651: PUSH
92652: LD_INT 1
92654: ARRAY
92655: PUSH
92656: LD_INT 1
92658: ARRAY
92659: EQUAL
92660: PUSH
92661: LD_VAR 0 4
92665: PUSH
92666: LD_VAR 0 1
92670: PPUSH
92671: CALL_OW 437
92675: PUSH
92676: LD_INT 1
92678: ARRAY
92679: PUSH
92680: LD_INT 2
92682: ARRAY
92683: EQUAL
92684: AND
92685: PUSH
92686: LD_VAR 0 5
92690: PUSH
92691: LD_VAR 0 1
92695: PPUSH
92696: CALL_OW 437
92700: PUSH
92701: LD_INT 1
92703: ARRAY
92704: PUSH
92705: LD_INT 3
92707: ARRAY
92708: EQUAL
92709: AND
92710: IFFALSE 92722
// result := true else
92712: LD_ADDR_VAR 0 3
92716: PUSH
92717: LD_INT 1
92719: ST_TO_ADDR
92720: GO 92730
// result := false ;
92722: LD_ADDR_VAR 0 3
92726: PUSH
92727: LD_INT 0
92729: ST_TO_ADDR
// end else
92730: GO 92740
// result := false ;
92732: LD_ADDR_VAR 0 3
92736: PUSH
92737: LD_INT 0
92739: ST_TO_ADDR
// end ;
92740: LD_VAR 0 3
92744: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92745: LD_INT 0
92747: PPUSH
92748: PPUSH
92749: PPUSH
92750: PPUSH
// if not unit or not area then
92751: LD_VAR 0 1
92755: NOT
92756: PUSH
92757: LD_VAR 0 2
92761: NOT
92762: OR
92763: IFFALSE 92767
// exit ;
92765: GO 92931
// tmp := AreaToList ( area , i ) ;
92767: LD_ADDR_VAR 0 6
92771: PUSH
92772: LD_VAR 0 2
92776: PPUSH
92777: LD_VAR 0 5
92781: PPUSH
92782: CALL_OW 517
92786: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92787: LD_ADDR_VAR 0 5
92791: PUSH
92792: DOUBLE
92793: LD_INT 1
92795: DEC
92796: ST_TO_ADDR
92797: LD_VAR 0 6
92801: PUSH
92802: LD_INT 1
92804: ARRAY
92805: PUSH
92806: FOR_TO
92807: IFFALSE 92929
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92809: LD_ADDR_VAR 0 7
92813: PUSH
92814: LD_VAR 0 6
92818: PUSH
92819: LD_INT 1
92821: ARRAY
92822: PUSH
92823: LD_VAR 0 5
92827: ARRAY
92828: PUSH
92829: LD_VAR 0 6
92833: PUSH
92834: LD_INT 2
92836: ARRAY
92837: PUSH
92838: LD_VAR 0 5
92842: ARRAY
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92848: LD_VAR 0 7
92852: PUSH
92853: LD_INT 1
92855: ARRAY
92856: PPUSH
92857: LD_VAR 0 7
92861: PUSH
92862: LD_INT 2
92864: ARRAY
92865: PPUSH
92866: CALL_OW 428
92870: PUSH
92871: LD_INT 0
92873: EQUAL
92874: IFFALSE 92927
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92876: LD_VAR 0 1
92880: PPUSH
92881: LD_VAR 0 7
92885: PUSH
92886: LD_INT 1
92888: ARRAY
92889: PPUSH
92890: LD_VAR 0 7
92894: PUSH
92895: LD_INT 2
92897: ARRAY
92898: PPUSH
92899: LD_VAR 0 3
92903: PPUSH
92904: CALL_OW 48
// result := IsPlaced ( unit ) ;
92908: LD_ADDR_VAR 0 4
92912: PUSH
92913: LD_VAR 0 1
92917: PPUSH
92918: CALL_OW 305
92922: ST_TO_ADDR
// exit ;
92923: POP
92924: POP
92925: GO 92931
// end ; end ;
92927: GO 92806
92929: POP
92930: POP
// end ;
92931: LD_VAR 0 4
92935: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92936: LD_INT 0
92938: PPUSH
92939: PPUSH
92940: PPUSH
// if not side or side > 8 then
92941: LD_VAR 0 1
92945: NOT
92946: PUSH
92947: LD_VAR 0 1
92951: PUSH
92952: LD_INT 8
92954: GREATER
92955: OR
92956: IFFALSE 92960
// exit ;
92958: GO 93147
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92960: LD_ADDR_VAR 0 4
92964: PUSH
92965: LD_INT 22
92967: PUSH
92968: LD_VAR 0 1
92972: PUSH
92973: EMPTY
92974: LIST
92975: LIST
92976: PUSH
92977: LD_INT 21
92979: PUSH
92980: LD_INT 3
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PPUSH
92991: CALL_OW 69
92995: ST_TO_ADDR
// if not tmp then
92996: LD_VAR 0 4
93000: NOT
93001: IFFALSE 93005
// exit ;
93003: GO 93147
// enable_addtolog := true ;
93005: LD_ADDR_OWVAR 81
93009: PUSH
93010: LD_INT 1
93012: ST_TO_ADDR
// AddToLog ( [ ) ;
93013: LD_STRING [
93015: PPUSH
93016: CALL_OW 561
// for i in tmp do
93020: LD_ADDR_VAR 0 3
93024: PUSH
93025: LD_VAR 0 4
93029: PUSH
93030: FOR_IN
93031: IFFALSE 93138
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
93033: LD_STRING [
93035: PUSH
93036: LD_VAR 0 3
93040: PPUSH
93041: CALL_OW 266
93045: STR
93046: PUSH
93047: LD_STRING , 
93049: STR
93050: PUSH
93051: LD_VAR 0 3
93055: PPUSH
93056: CALL_OW 250
93060: STR
93061: PUSH
93062: LD_STRING , 
93064: STR
93065: PUSH
93066: LD_VAR 0 3
93070: PPUSH
93071: CALL_OW 251
93075: STR
93076: PUSH
93077: LD_STRING , 
93079: STR
93080: PUSH
93081: LD_VAR 0 3
93085: PPUSH
93086: CALL_OW 254
93090: STR
93091: PUSH
93092: LD_STRING , 
93094: STR
93095: PUSH
93096: LD_VAR 0 3
93100: PPUSH
93101: LD_INT 1
93103: PPUSH
93104: CALL_OW 268
93108: STR
93109: PUSH
93110: LD_STRING , 
93112: STR
93113: PUSH
93114: LD_VAR 0 3
93118: PPUSH
93119: LD_INT 2
93121: PPUSH
93122: CALL_OW 268
93126: STR
93127: PUSH
93128: LD_STRING ],
93130: STR
93131: PPUSH
93132: CALL_OW 561
// end ;
93136: GO 93030
93138: POP
93139: POP
// AddToLog ( ]; ) ;
93140: LD_STRING ];
93142: PPUSH
93143: CALL_OW 561
// end ;
93147: LD_VAR 0 2
93151: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
93152: LD_INT 0
93154: PPUSH
93155: PPUSH
93156: PPUSH
93157: PPUSH
93158: PPUSH
// if not area or not rate or not max then
93159: LD_VAR 0 1
93163: NOT
93164: PUSH
93165: LD_VAR 0 2
93169: NOT
93170: OR
93171: PUSH
93172: LD_VAR 0 4
93176: NOT
93177: OR
93178: IFFALSE 93182
// exit ;
93180: GO 93374
// while 1 do
93182: LD_INT 1
93184: IFFALSE 93374
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
93186: LD_ADDR_VAR 0 9
93190: PUSH
93191: LD_VAR 0 1
93195: PPUSH
93196: LD_INT 1
93198: PPUSH
93199: CALL_OW 287
93203: PUSH
93204: LD_INT 10
93206: MUL
93207: ST_TO_ADDR
// r := rate / 10 ;
93208: LD_ADDR_VAR 0 7
93212: PUSH
93213: LD_VAR 0 2
93217: PUSH
93218: LD_INT 10
93220: DIVREAL
93221: ST_TO_ADDR
// time := 1 1$00 ;
93222: LD_ADDR_VAR 0 8
93226: PUSH
93227: LD_INT 2100
93229: ST_TO_ADDR
// if amount < min then
93230: LD_VAR 0 9
93234: PUSH
93235: LD_VAR 0 3
93239: LESS
93240: IFFALSE 93258
// r := r * 2 else
93242: LD_ADDR_VAR 0 7
93246: PUSH
93247: LD_VAR 0 7
93251: PUSH
93252: LD_INT 2
93254: MUL
93255: ST_TO_ADDR
93256: GO 93284
// if amount > max then
93258: LD_VAR 0 9
93262: PUSH
93263: LD_VAR 0 4
93267: GREATER
93268: IFFALSE 93284
// r := r / 2 ;
93270: LD_ADDR_VAR 0 7
93274: PUSH
93275: LD_VAR 0 7
93279: PUSH
93280: LD_INT 2
93282: DIVREAL
93283: ST_TO_ADDR
// time := time / r ;
93284: LD_ADDR_VAR 0 8
93288: PUSH
93289: LD_VAR 0 8
93293: PUSH
93294: LD_VAR 0 7
93298: DIVREAL
93299: ST_TO_ADDR
// if time < 0 then
93300: LD_VAR 0 8
93304: PUSH
93305: LD_INT 0
93307: LESS
93308: IFFALSE 93325
// time := time * - 1 ;
93310: LD_ADDR_VAR 0 8
93314: PUSH
93315: LD_VAR 0 8
93319: PUSH
93320: LD_INT 1
93322: NEG
93323: MUL
93324: ST_TO_ADDR
// wait ( time ) ;
93325: LD_VAR 0 8
93329: PPUSH
93330: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
93334: LD_INT 35
93336: PPUSH
93337: LD_INT 875
93339: PPUSH
93340: CALL_OW 12
93344: PPUSH
93345: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
93349: LD_INT 1
93351: PPUSH
93352: LD_INT 5
93354: PPUSH
93355: CALL_OW 12
93359: PPUSH
93360: LD_VAR 0 1
93364: PPUSH
93365: LD_INT 1
93367: PPUSH
93368: CALL_OW 55
// end ;
93372: GO 93182
// end ;
93374: LD_VAR 0 5
93378: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
93379: LD_INT 0
93381: PPUSH
93382: PPUSH
93383: PPUSH
93384: PPUSH
93385: PPUSH
93386: PPUSH
93387: PPUSH
93388: PPUSH
// if not turrets or not factories then
93389: LD_VAR 0 1
93393: NOT
93394: PUSH
93395: LD_VAR 0 2
93399: NOT
93400: OR
93401: IFFALSE 93405
// exit ;
93403: GO 93712
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
93405: LD_ADDR_VAR 0 10
93409: PUSH
93410: LD_INT 5
93412: PUSH
93413: LD_INT 6
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 2
93422: PUSH
93423: LD_INT 4
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 3
93432: PUSH
93433: LD_INT 5
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: LIST
93444: PUSH
93445: LD_INT 24
93447: PUSH
93448: LD_INT 25
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: LD_INT 23
93457: PUSH
93458: LD_INT 27
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: PUSH
93469: LD_INT 42
93471: PUSH
93472: LD_INT 43
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: PUSH
93479: LD_INT 44
93481: PUSH
93482: LD_INT 46
93484: PUSH
93485: EMPTY
93486: LIST
93487: LIST
93488: PUSH
93489: LD_INT 45
93491: PUSH
93492: LD_INT 47
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: LIST
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: LIST
93508: ST_TO_ADDR
// result := [ ] ;
93509: LD_ADDR_VAR 0 3
93513: PUSH
93514: EMPTY
93515: ST_TO_ADDR
// for i in turrets do
93516: LD_ADDR_VAR 0 4
93520: PUSH
93521: LD_VAR 0 1
93525: PUSH
93526: FOR_IN
93527: IFFALSE 93710
// begin nat := GetNation ( i ) ;
93529: LD_ADDR_VAR 0 7
93533: PUSH
93534: LD_VAR 0 4
93538: PPUSH
93539: CALL_OW 248
93543: ST_TO_ADDR
// weapon := 0 ;
93544: LD_ADDR_VAR 0 8
93548: PUSH
93549: LD_INT 0
93551: ST_TO_ADDR
// if not nat then
93552: LD_VAR 0 7
93556: NOT
93557: IFFALSE 93561
// continue ;
93559: GO 93526
// for j in list [ nat ] do
93561: LD_ADDR_VAR 0 5
93565: PUSH
93566: LD_VAR 0 10
93570: PUSH
93571: LD_VAR 0 7
93575: ARRAY
93576: PUSH
93577: FOR_IN
93578: IFFALSE 93619
// if GetBWeapon ( i ) = j [ 1 ] then
93580: LD_VAR 0 4
93584: PPUSH
93585: CALL_OW 269
93589: PUSH
93590: LD_VAR 0 5
93594: PUSH
93595: LD_INT 1
93597: ARRAY
93598: EQUAL
93599: IFFALSE 93617
// begin weapon := j [ 2 ] ;
93601: LD_ADDR_VAR 0 8
93605: PUSH
93606: LD_VAR 0 5
93610: PUSH
93611: LD_INT 2
93613: ARRAY
93614: ST_TO_ADDR
// break ;
93615: GO 93619
// end ;
93617: GO 93577
93619: POP
93620: POP
// if not weapon then
93621: LD_VAR 0 8
93625: NOT
93626: IFFALSE 93630
// continue ;
93628: GO 93526
// for k in factories do
93630: LD_ADDR_VAR 0 6
93634: PUSH
93635: LD_VAR 0 2
93639: PUSH
93640: FOR_IN
93641: IFFALSE 93706
// begin weapons := AvailableWeaponList ( k ) ;
93643: LD_ADDR_VAR 0 9
93647: PUSH
93648: LD_VAR 0 6
93652: PPUSH
93653: CALL_OW 478
93657: ST_TO_ADDR
// if not weapons then
93658: LD_VAR 0 9
93662: NOT
93663: IFFALSE 93667
// continue ;
93665: GO 93640
// if weapon in weapons then
93667: LD_VAR 0 8
93671: PUSH
93672: LD_VAR 0 9
93676: IN
93677: IFFALSE 93704
// begin result := [ i , weapon ] ;
93679: LD_ADDR_VAR 0 3
93683: PUSH
93684: LD_VAR 0 4
93688: PUSH
93689: LD_VAR 0 8
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: ST_TO_ADDR
// exit ;
93698: POP
93699: POP
93700: POP
93701: POP
93702: GO 93712
// end ; end ;
93704: GO 93640
93706: POP
93707: POP
// end ;
93708: GO 93526
93710: POP
93711: POP
// end ;
93712: LD_VAR 0 3
93716: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
93717: LD_INT 0
93719: PPUSH
// if not side or side > 8 then
93720: LD_VAR 0 3
93724: NOT
93725: PUSH
93726: LD_VAR 0 3
93730: PUSH
93731: LD_INT 8
93733: GREATER
93734: OR
93735: IFFALSE 93739
// exit ;
93737: GO 93798
// if not range then
93739: LD_VAR 0 4
93743: NOT
93744: IFFALSE 93755
// range := - 12 ;
93746: LD_ADDR_VAR 0 4
93750: PUSH
93751: LD_INT 12
93753: NEG
93754: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93755: LD_VAR 0 1
93759: PPUSH
93760: LD_VAR 0 2
93764: PPUSH
93765: LD_VAR 0 3
93769: PPUSH
93770: LD_VAR 0 4
93774: PPUSH
93775: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93779: LD_VAR 0 1
93783: PPUSH
93784: LD_VAR 0 2
93788: PPUSH
93789: LD_VAR 0 3
93793: PPUSH
93794: CALL_OW 331
// end ;
93798: LD_VAR 0 5
93802: RET
// export function Video ( mode ) ; begin
93803: LD_INT 0
93805: PPUSH
// ingame_video = mode ;
93806: LD_ADDR_OWVAR 52
93810: PUSH
93811: LD_VAR 0 1
93815: ST_TO_ADDR
// interface_hidden = mode ;
93816: LD_ADDR_OWVAR 54
93820: PUSH
93821: LD_VAR 0 1
93825: ST_TO_ADDR
// end ;
93826: LD_VAR 0 2
93830: RET
// export function Join ( array , element ) ; begin
93831: LD_INT 0
93833: PPUSH
// result := Replace ( array , array + 1 , element ) ;
93834: LD_ADDR_VAR 0 3
93838: PUSH
93839: LD_VAR 0 1
93843: PPUSH
93844: LD_VAR 0 1
93848: PUSH
93849: LD_INT 1
93851: PLUS
93852: PPUSH
93853: LD_VAR 0 2
93857: PPUSH
93858: CALL_OW 1
93862: ST_TO_ADDR
// end ;
93863: LD_VAR 0 3
93867: RET
// export function JoinUnion ( array , element ) ; begin
93868: LD_INT 0
93870: PPUSH
// result := array union element ;
93871: LD_ADDR_VAR 0 3
93875: PUSH
93876: LD_VAR 0 1
93880: PUSH
93881: LD_VAR 0 2
93885: UNION
93886: ST_TO_ADDR
// end ;
93887: LD_VAR 0 3
93891: RET
// export function GetBehemoths ( side ) ; begin
93892: LD_INT 0
93894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93895: LD_ADDR_VAR 0 2
93899: PUSH
93900: LD_INT 22
93902: PUSH
93903: LD_VAR 0 1
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: PUSH
93912: LD_INT 31
93914: PUSH
93915: LD_INT 25
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PPUSH
93926: CALL_OW 69
93930: ST_TO_ADDR
// end ;
93931: LD_VAR 0 2
93935: RET
// export function Shuffle ( array ) ; var i , index ; begin
93936: LD_INT 0
93938: PPUSH
93939: PPUSH
93940: PPUSH
// result := [ ] ;
93941: LD_ADDR_VAR 0 2
93945: PUSH
93946: EMPTY
93947: ST_TO_ADDR
// if not array then
93948: LD_VAR 0 1
93952: NOT
93953: IFFALSE 93957
// exit ;
93955: GO 94056
// Randomize ;
93957: CALL_OW 10
// for i = array downto 1 do
93961: LD_ADDR_VAR 0 3
93965: PUSH
93966: DOUBLE
93967: LD_VAR 0 1
93971: INC
93972: ST_TO_ADDR
93973: LD_INT 1
93975: PUSH
93976: FOR_DOWNTO
93977: IFFALSE 94054
// begin index := rand ( 1 , array ) ;
93979: LD_ADDR_VAR 0 4
93983: PUSH
93984: LD_INT 1
93986: PPUSH
93987: LD_VAR 0 1
93991: PPUSH
93992: CALL_OW 12
93996: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93997: LD_ADDR_VAR 0 2
94001: PUSH
94002: LD_VAR 0 2
94006: PPUSH
94007: LD_VAR 0 2
94011: PUSH
94012: LD_INT 1
94014: PLUS
94015: PPUSH
94016: LD_VAR 0 1
94020: PUSH
94021: LD_VAR 0 4
94025: ARRAY
94026: PPUSH
94027: CALL_OW 2
94031: ST_TO_ADDR
// array := Delete ( array , index ) ;
94032: LD_ADDR_VAR 0 1
94036: PUSH
94037: LD_VAR 0 1
94041: PPUSH
94042: LD_VAR 0 4
94046: PPUSH
94047: CALL_OW 3
94051: ST_TO_ADDR
// end ;
94052: GO 93976
94054: POP
94055: POP
// end ;
94056: LD_VAR 0 2
94060: RET
// export function GetBaseMaterials ( base ) ; begin
94061: LD_INT 0
94063: PPUSH
// result := [ 0 , 0 , 0 ] ;
94064: LD_ADDR_VAR 0 2
94068: PUSH
94069: LD_INT 0
94071: PUSH
94072: LD_INT 0
94074: PUSH
94075: LD_INT 0
94077: PUSH
94078: EMPTY
94079: LIST
94080: LIST
94081: LIST
94082: ST_TO_ADDR
// if not base then
94083: LD_VAR 0 1
94087: NOT
94088: IFFALSE 94092
// exit ;
94090: GO 94141
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
94092: LD_ADDR_VAR 0 2
94096: PUSH
94097: LD_VAR 0 1
94101: PPUSH
94102: LD_INT 1
94104: PPUSH
94105: CALL_OW 275
94109: PUSH
94110: LD_VAR 0 1
94114: PPUSH
94115: LD_INT 2
94117: PPUSH
94118: CALL_OW 275
94122: PUSH
94123: LD_VAR 0 1
94127: PPUSH
94128: LD_INT 3
94130: PPUSH
94131: CALL_OW 275
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: LIST
94140: ST_TO_ADDR
// end ;
94141: LD_VAR 0 2
94145: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
94146: LD_INT 0
94148: PPUSH
94149: PPUSH
// result := array ;
94150: LD_ADDR_VAR 0 3
94154: PUSH
94155: LD_VAR 0 1
94159: ST_TO_ADDR
// if size > 0 then
94160: LD_VAR 0 2
94164: PUSH
94165: LD_INT 0
94167: GREATER
94168: IFFALSE 94214
// for i := array downto size do
94170: LD_ADDR_VAR 0 4
94174: PUSH
94175: DOUBLE
94176: LD_VAR 0 1
94180: INC
94181: ST_TO_ADDR
94182: LD_VAR 0 2
94186: PUSH
94187: FOR_DOWNTO
94188: IFFALSE 94212
// result := Delete ( result , result ) ;
94190: LD_ADDR_VAR 0 3
94194: PUSH
94195: LD_VAR 0 3
94199: PPUSH
94200: LD_VAR 0 3
94204: PPUSH
94205: CALL_OW 3
94209: ST_TO_ADDR
94210: GO 94187
94212: POP
94213: POP
// end ;
94214: LD_VAR 0 3
94218: RET
// export function ComExit ( unit ) ; var tmp ; begin
94219: LD_INT 0
94221: PPUSH
94222: PPUSH
// if not IsInUnit ( unit ) then
94223: LD_VAR 0 1
94227: PPUSH
94228: CALL_OW 310
94232: NOT
94233: IFFALSE 94237
// exit ;
94235: GO 94297
// tmp := IsInUnit ( unit ) ;
94237: LD_ADDR_VAR 0 3
94241: PUSH
94242: LD_VAR 0 1
94246: PPUSH
94247: CALL_OW 310
94251: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
94252: LD_VAR 0 3
94256: PPUSH
94257: CALL_OW 247
94261: PUSH
94262: LD_INT 2
94264: EQUAL
94265: IFFALSE 94278
// ComExitVehicle ( unit ) else
94267: LD_VAR 0 1
94271: PPUSH
94272: CALL_OW 121
94276: GO 94287
// ComExitBuilding ( unit ) ;
94278: LD_VAR 0 1
94282: PPUSH
94283: CALL_OW 122
// result := tmp ;
94287: LD_ADDR_VAR 0 2
94291: PUSH
94292: LD_VAR 0 3
94296: ST_TO_ADDR
// end ;
94297: LD_VAR 0 2
94301: RET
// export function ResetHc ; begin
94302: LD_INT 0
94304: PPUSH
// InitHc ;
94305: CALL_OW 19
// hc_importance := 0 ;
94309: LD_ADDR_OWVAR 32
94313: PUSH
94314: LD_INT 0
94316: ST_TO_ADDR
// end ;
94317: LD_VAR 0 1
94321: RET
